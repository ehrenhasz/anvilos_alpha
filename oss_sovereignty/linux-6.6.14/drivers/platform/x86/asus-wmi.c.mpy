{
  "module_name": "asus-wmi.c",
  "hash_id": "ff1c463867a50e9058945be7b6445b3678b17bed968ffeae229820abdbb34683",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/asus-wmi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/backlight.h>\n#include <linux/debugfs.h>\n#include <linux/dmi.h>\n#include <linux/fb.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/platform_data/x86/asus-wmi.h>\n#include <linux/platform_device.h>\n#include <linux/platform_profile.h>\n#include <linux/power_supply.h>\n#include <linux/rfkill.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/units.h>\n\n#include <acpi/battery.h>\n#include <acpi/video.h>\n\n#include \"asus-wmi.h\"\n\nMODULE_AUTHOR(\"Corentin Chary <corentin.chary@gmail.com>\");\nMODULE_AUTHOR(\"Yong Wang <yong.y.wang@intel.com>\");\nMODULE_DESCRIPTION(\"Asus Generic WMI Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool fnlock_default = true;\nmodule_param(fnlock_default, bool, 0444);\n\n#define to_asus_wmi_driver(pdrv)\t\t\t\t\t\\\n\t(container_of((pdrv), struct asus_wmi_driver, platform_driver))\n\n#define ASUS_WMI_MGMT_GUID\t\"97845ED0-4E6D-11DE-8A39-0800200C9A66\"\n\n#define NOTIFY_BRNUP_MIN\t\t0x11\n#define NOTIFY_BRNUP_MAX\t\t0x1f\n#define NOTIFY_BRNDOWN_MIN\t\t0x20\n#define NOTIFY_BRNDOWN_MAX\t\t0x2e\n#define NOTIFY_FNLOCK_TOGGLE\t\t0x4e\n#define NOTIFY_KBD_DOCK_CHANGE\t\t0x75\n#define NOTIFY_KBD_BRTUP\t\t0xc4\n#define NOTIFY_KBD_BRTDWN\t\t0xc5\n#define NOTIFY_KBD_BRTTOGGLE\t\t0xc7\n#define NOTIFY_KBD_FBM\t\t\t0x99\n#define NOTIFY_KBD_TTP\t\t\t0xae\n#define NOTIFY_LID_FLIP\t\t\t0xfa\n#define NOTIFY_LID_FLIP_ROG\t\t0xbd\n\n#define ASUS_WMI_FNLOCK_BIOS_DISABLED\tBIT(0)\n\n#define ASUS_MID_FAN_DESC\t\t\"mid_fan\"\n#define ASUS_GPU_FAN_DESC\t\t\"gpu_fan\"\n#define ASUS_FAN_DESC\t\t\t\"cpu_fan\"\n#define ASUS_FAN_MFUN\t\t\t0x13\n#define ASUS_FAN_SFUN_READ\t\t0x06\n#define ASUS_FAN_SFUN_WRITE\t\t0x07\n\n \n#define ASUS_FAN_CTRL_FULLSPEED\t\t0\n#define ASUS_FAN_CTRL_MANUAL\t\t1\n#define ASUS_FAN_CTRL_AUTO\t\t2\n\n#define ASUS_FAN_BOOST_MODE_NORMAL\t\t0\n#define ASUS_FAN_BOOST_MODE_OVERBOOST\t\t1\n#define ASUS_FAN_BOOST_MODE_OVERBOOST_MASK\t0x01\n#define ASUS_FAN_BOOST_MODE_SILENT\t\t2\n#define ASUS_FAN_BOOST_MODE_SILENT_MASK\t\t0x02\n#define ASUS_FAN_BOOST_MODES_MASK\t\t0x03\n\n#define ASUS_THROTTLE_THERMAL_POLICY_DEFAULT\t0\n#define ASUS_THROTTLE_THERMAL_POLICY_OVERBOOST\t1\n#define ASUS_THROTTLE_THERMAL_POLICY_SILENT\t2\n\n#define USB_INTEL_XUSB2PR\t\t0xD0\n#define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI\t0x9c31\n\n#define ASUS_ACPI_UID_ASUSWMI\t\t\"ASUSWMI\"\n#define ASUS_ACPI_UID_ATK\t\t\"ATK\"\n\n#define WMI_EVENT_QUEUE_SIZE\t\t0x10\n#define WMI_EVENT_QUEUE_END\t\t0x1\n#define WMI_EVENT_MASK\t\t\t0xFFFF\n \n#define WMI_EVENT_VALUE_ATK\t\t0xFF\n\n#define WMI_EVENT_MASK\t\t\t0xFFFF\n\n#define FAN_CURVE_POINTS\t\t8\n#define FAN_CURVE_BUF_LEN\t\t32\n#define FAN_CURVE_DEV_CPU\t\t0x00\n#define FAN_CURVE_DEV_GPU\t\t0x01\n#define FAN_CURVE_DEV_MID\t\t0x02\n \n#define FAN_CURVE_PWM_MASK\t\t0x04\n\n \n#define PPT_TOTAL_MIN\t\t5\n#define PPT_TOTAL_MAX\t\t250\n#define PPT_CPU_MIN\t\t\t5\n#define PPT_CPU_MAX\t\t\t130\n#define NVIDIA_BOOST_MIN\t5\n#define NVIDIA_BOOST_MAX\t25\n#define NVIDIA_TEMP_MIN\t\t75\n#define NVIDIA_TEMP_MAX\t\t87\n\nstatic const char * const ashs_ids[] = { \"ATK4001\", \"ATK4002\", NULL };\n\nstatic int throttle_thermal_policy_write(struct asus_wmi *);\n\nstatic bool ashs_present(void)\n{\n\tint i = 0;\n\twhile (ashs_ids[i]) {\n\t\tif (acpi_dev_found(ashs_ids[i++]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct bios_args {\n\tu32 arg0;\n\tu32 arg1;\n\tu32 arg2;  \n\tu32 arg3;\n\tu32 arg4;  \n\tu32 arg5;\n} __packed;\n\n \nstruct agfn_args {\n\tu16 mfun;  \n\tu16 sfun;  \n\tu16 len;   \n\tu8 stas;   \n\tu8 err;    \n} __packed;\n\n \nstruct agfn_fan_args {\n\tstruct agfn_args agfn;\t \n\tu8 fan;\t\t\t \n\tu32 speed;\t\t \n} __packed;\n\n \nstruct asus_wmi_debug {\n\tstruct dentry *root;\n\tu32 method_id;\n\tu32 dev_id;\n\tu32 ctrl_param;\n};\n\nstruct asus_rfkill {\n\tstruct asus_wmi *asus;\n\tstruct rfkill *rfkill;\n\tu32 dev_id;\n};\n\nenum fan_type {\n\tFAN_TYPE_NONE = 0,\n\tFAN_TYPE_AGFN,\t\t \n\tFAN_TYPE_SPEC83,\t \n};\n\nstruct fan_curve_data {\n\tbool enabled;\n\tu32 device_id;\n\tu8 temps[FAN_CURVE_POINTS];\n\tu8 percents[FAN_CURVE_POINTS];\n};\n\nstruct asus_wmi {\n\tint dsts_id;\n\tint spec;\n\tint sfun;\n\tbool wmi_event_queue;\n\n\tstruct input_dev *inputdev;\n\tstruct backlight_device *backlight_device;\n\tstruct platform_device *platform_device;\n\n\tstruct led_classdev wlan_led;\n\tint wlan_led_wk;\n\tstruct led_classdev tpd_led;\n\tint tpd_led_wk;\n\tstruct led_classdev kbd_led;\n\tint kbd_led_wk;\n\tstruct led_classdev lightbar_led;\n\tint lightbar_led_wk;\n\tstruct led_classdev micmute_led;\n\tstruct workqueue_struct *led_workqueue;\n\tstruct work_struct tpd_led_work;\n\tstruct work_struct wlan_led_work;\n\tstruct work_struct lightbar_led_work;\n\n\tstruct asus_rfkill wlan;\n\tstruct asus_rfkill bluetooth;\n\tstruct asus_rfkill wimax;\n\tstruct asus_rfkill wwan3g;\n\tstruct asus_rfkill gps;\n\tstruct asus_rfkill uwb;\n\n\tint tablet_switch_event_code;\n\tu32 tablet_switch_dev_id;\n\tbool tablet_switch_inverted;\n\n\tenum fan_type fan_type;\n\tenum fan_type gpu_fan_type;\n\tenum fan_type mid_fan_type;\n\tint fan_pwm_mode;\n\tint gpu_fan_pwm_mode;\n\tint mid_fan_pwm_mode;\n\tint agfn_pwm;\n\n\tbool fan_boost_mode_available;\n\tu8 fan_boost_mode_mask;\n\tu8 fan_boost_mode;\n\n\tbool charge_mode_available;\n\tbool egpu_enable_available;\n\tbool egpu_connect_available;\n\tbool dgpu_disable_available;\n\tbool gpu_mux_mode_available;\n\n\t \n\tbool ppt_pl2_sppt_available;\n\tbool ppt_pl1_spl_available;\n\tbool ppt_apu_sppt_available;\n\tbool ppt_plat_sppt_available;\n\tbool ppt_fppt_available;\n\tbool nv_dyn_boost_available;\n\tbool nv_temp_tgt_available;\n\n\tbool kbd_rgb_mode_available;\n\tbool kbd_rgb_state_available;\n\n\tbool throttle_thermal_policy_available;\n\tu8 throttle_thermal_policy_mode;\n\n\tbool cpu_fan_curve_available;\n\tbool gpu_fan_curve_available;\n\tbool mid_fan_curve_available;\n\tstruct fan_curve_data custom_fan_curves[3];\n\n\tstruct platform_profile_handler platform_profile_handler;\n\tbool platform_profile_support;\n\n\t \n\tbool battery_rsoc_available;\n\n\tbool panel_overdrive_available;\n\tbool mini_led_mode_available;\n\n\tstruct hotplug_slot hotplug_slot;\n\tstruct mutex hotplug_lock;\n\tstruct mutex wmi_lock;\n\tstruct workqueue_struct *hotplug_workqueue;\n\tstruct work_struct hotplug_work;\n\n\tbool fnlock_locked;\n\n\tstruct asus_wmi_debug debug;\n\n\tstruct asus_wmi_driver *driver;\n};\n\n \n\nstatic int asus_wmi_evaluate_method3(u32 method_id,\n\t\tu32 arg0, u32 arg1, u32 arg2, u32 *retval)\n{\n\tstruct bios_args args = {\n\t\t.arg0 = arg0,\n\t\t.arg1 = arg1,\n\t\t.arg2 = arg2,\n\t};\n\tstruct acpi_buffer input = { (acpi_size) sizeof(args), &args };\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status status;\n\tunion acpi_object *obj;\n\tu32 tmp = 0;\n\n\tstatus = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 0, method_id,\n\t\t\t\t     &input, &output);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tobj = (union acpi_object *)output.pointer;\n\tif (obj && obj->type == ACPI_TYPE_INTEGER)\n\t\ttmp = (u32) obj->integer.value;\n\n\tif (retval)\n\t\t*retval = tmp;\n\n\tkfree(obj);\n\n\tif (tmp == ASUS_WMI_UNSUPPORTED_METHOD)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nint asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval)\n{\n\treturn asus_wmi_evaluate_method3(method_id, arg0, arg1, 0, retval);\n}\nEXPORT_SYMBOL_GPL(asus_wmi_evaluate_method);\n\nstatic int asus_wmi_evaluate_method5(u32 method_id,\n\t\tu32 arg0, u32 arg1, u32 arg2, u32 arg3, u32 arg4, u32 *retval)\n{\n\tstruct bios_args args = {\n\t\t.arg0 = arg0,\n\t\t.arg1 = arg1,\n\t\t.arg2 = arg2,\n\t\t.arg3 = arg3,\n\t\t.arg4 = arg4,\n\t};\n\tstruct acpi_buffer input = { (acpi_size) sizeof(args), &args };\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status status;\n\tunion acpi_object *obj;\n\tu32 tmp = 0;\n\n\tstatus = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 0, method_id,\n\t\t\t\t     &input, &output);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tobj = (union acpi_object *)output.pointer;\n\tif (obj && obj->type == ACPI_TYPE_INTEGER)\n\t\ttmp = (u32) obj->integer.value;\n\n\tif (retval)\n\t\t*retval = tmp;\n\n\tkfree(obj);\n\n\tif (tmp == ASUS_WMI_UNSUPPORTED_METHOD)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstatic int asus_wmi_evaluate_method_buf(u32 method_id,\n\t\tu32 arg0, u32 arg1, u8 *ret_buffer, size_t size)\n{\n\tstruct bios_args args = {\n\t\t.arg0 = arg0,\n\t\t.arg1 = arg1,\n\t\t.arg2 = 0,\n\t};\n\tstruct acpi_buffer input = { (acpi_size) sizeof(args), &args };\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status status;\n\tunion acpi_object *obj;\n\tint err = 0;\n\n\tstatus = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 0, method_id,\n\t\t\t\t     &input, &output);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tobj = (union acpi_object *)output.pointer;\n\n\tswitch (obj->type) {\n\tcase ACPI_TYPE_BUFFER:\n\t\tif (obj->buffer.length > size) {\n\t\t\terr = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\t\tif (obj->buffer.length == 0) {\n\t\t\terr = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(ret_buffer, obj->buffer.pointer, obj->buffer.length);\n\t\tbreak;\n\tcase ACPI_TYPE_INTEGER:\n\t\terr = (u32)obj->integer.value;\n\n\t\tif (err == ASUS_WMI_UNSUPPORTED_METHOD)\n\t\t\terr = -ENODEV;\n\t\t \n\t\tif (err == 0)\n\t\t\terr = -ENODATA;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENODATA;\n\t\tbreak;\n\t}\n\n\tkfree(obj);\n\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int asus_wmi_evaluate_method_agfn(const struct acpi_buffer args)\n{\n\tstruct acpi_buffer input;\n\tu64 phys_addr;\n\tu32 retval;\n\tu32 status;\n\n\t \n\tinput.pointer = kmemdup(args.pointer, args.length, GFP_DMA | GFP_KERNEL);\n\tinput.length = args.length;\n\tif (!input.pointer)\n\t\treturn -ENOMEM;\n\tphys_addr = virt_to_phys(input.pointer);\n\n\tstatus = asus_wmi_evaluate_method(ASUS_WMI_METHODID_AGFN,\n\t\t\t\t\tphys_addr, 0, &retval);\n\tif (!status)\n\t\tmemcpy(args.pointer, input.pointer, args.length);\n\n\tkfree(input.pointer);\n\tif (status)\n\t\treturn -ENXIO;\n\n\treturn retval;\n}\n\nstatic int asus_wmi_get_devstate(struct asus_wmi *asus, u32 dev_id, u32 *retval)\n{\n\treturn asus_wmi_evaluate_method(asus->dsts_id, dev_id, 0, retval);\n}\n\nstatic int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param,\n\t\t\t\t u32 *retval)\n{\n\treturn asus_wmi_evaluate_method(ASUS_WMI_METHODID_DEVS, dev_id,\n\t\t\t\t\tctrl_param, retval);\n}\n\n \nstatic int asus_wmi_get_devstate_bits(struct asus_wmi *asus,\n\t\t\t\t      u32 dev_id, u32 mask)\n{\n\tu32 retval = 0;\n\tint err;\n\n\terr = asus_wmi_get_devstate(asus, dev_id, &retval);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!(retval & ASUS_WMI_DSTS_PRESENCE_BIT))\n\t\treturn -ENODEV;\n\n\tif (mask == ASUS_WMI_DSTS_STATUS_BIT) {\n\t\tif (retval & ASUS_WMI_DSTS_UNKNOWN_BIT)\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn retval & mask;\n}\n\nstatic int asus_wmi_get_devstate_simple(struct asus_wmi *asus, u32 dev_id)\n{\n\treturn asus_wmi_get_devstate_bits(asus, dev_id,\n\t\t\t\t\t  ASUS_WMI_DSTS_STATUS_BIT);\n}\n\nstatic bool asus_wmi_dev_is_present(struct asus_wmi *asus, u32 dev_id)\n{\n\tu32 retval;\n\tint status = asus_wmi_get_devstate(asus, dev_id, &retval);\n\n\treturn status == 0 && (retval & ASUS_WMI_DSTS_PRESENCE_BIT);\n}\n\n \nstatic void asus_wmi_tablet_sw_report(struct asus_wmi *asus, bool value)\n{\n\tinput_report_switch(asus->inputdev, SW_TABLET_MODE,\n\t\t\t    asus->tablet_switch_inverted ? !value : value);\n\tinput_sync(asus->inputdev);\n}\n\nstatic void asus_wmi_tablet_sw_init(struct asus_wmi *asus, u32 dev_id, int event_code)\n{\n\tstruct device *dev = &asus->platform_device->dev;\n\tint result;\n\n\tresult = asus_wmi_get_devstate_simple(asus, dev_id);\n\tif (result >= 0) {\n\t\tinput_set_capability(asus->inputdev, EV_SW, SW_TABLET_MODE);\n\t\tasus_wmi_tablet_sw_report(asus, result);\n\t\tasus->tablet_switch_dev_id = dev_id;\n\t\tasus->tablet_switch_event_code = event_code;\n\t} else if (result == -ENODEV) {\n\t\tdev_err(dev, \"This device has tablet-mode-switch quirk but got ENODEV checking it. This is a bug.\");\n\t} else {\n\t\tdev_err(dev, \"Error checking for tablet-mode-switch: %d\\n\", result);\n\t}\n}\n\nstatic int asus_wmi_input_init(struct asus_wmi *asus)\n{\n\tstruct device *dev = &asus->platform_device->dev;\n\tint err;\n\n\tasus->inputdev = input_allocate_device();\n\tif (!asus->inputdev)\n\t\treturn -ENOMEM;\n\n\tasus->inputdev->name = asus->driver->input_name;\n\tasus->inputdev->phys = asus->driver->input_phys;\n\tasus->inputdev->id.bustype = BUS_HOST;\n\tasus->inputdev->dev.parent = dev;\n\tset_bit(EV_REP, asus->inputdev->evbit);\n\n\terr = sparse_keymap_setup(asus->inputdev, asus->driver->keymap, NULL);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\tswitch (asus->driver->quirks->tablet_switch_mode) {\n\tcase asus_wmi_no_tablet_switch:\n\t\tbreak;\n\tcase asus_wmi_kbd_dock_devid:\n\t\tasus->tablet_switch_inverted = true;\n\t\tasus_wmi_tablet_sw_init(asus, ASUS_WMI_DEVID_KBD_DOCK, NOTIFY_KBD_DOCK_CHANGE);\n\t\tbreak;\n\tcase asus_wmi_lid_flip_devid:\n\t\tasus_wmi_tablet_sw_init(asus, ASUS_WMI_DEVID_LID_FLIP, NOTIFY_LID_FLIP);\n\t\tbreak;\n\tcase asus_wmi_lid_flip_rog_devid:\n\t\tasus_wmi_tablet_sw_init(asus, ASUS_WMI_DEVID_LID_FLIP_ROG, NOTIFY_LID_FLIP_ROG);\n\t\tbreak;\n\t}\n\n\terr = input_register_device(asus->inputdev);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\treturn 0;\n\nerr_free_dev:\n\tinput_free_device(asus->inputdev);\n\treturn err;\n}\n\nstatic void asus_wmi_input_exit(struct asus_wmi *asus)\n{\n\tif (asus->inputdev)\n\t\tinput_unregister_device(asus->inputdev);\n\n\tasus->inputdev = NULL;\n}\n\n \n\nstatic void asus_wmi_tablet_mode_get_state(struct asus_wmi *asus)\n{\n\tint result;\n\n\tif (!asus->tablet_switch_dev_id)\n\t\treturn;\n\n\tresult = asus_wmi_get_devstate_simple(asus, asus->tablet_switch_dev_id);\n\tif (result >= 0)\n\t\tasus_wmi_tablet_sw_report(asus, result);\n}\n\n \nstatic ssize_t charge_mode_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint result, value;\n\n\tresult = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_CHARGE_MODE, &value);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sysfs_emit(buf, \"%d\\n\", value & 0xff);\n}\n\nstatic DEVICE_ATTR_RO(charge_mode);\n\n \nstatic ssize_t dgpu_disable_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint result;\n\n\tresult = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_DGPU);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sysfs_emit(buf, \"%d\\n\", result);\n}\n\n \nstatic ssize_t dgpu_disable_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint result, err;\n\tu32 disable;\n\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\tresult = kstrtou32(buf, 10, &disable);\n\tif (result)\n\t\treturn result;\n\n\tif (disable > 1)\n\t\treturn -EINVAL;\n\n\tif (asus->gpu_mux_mode_available) {\n\t\tresult = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_GPU_MUX);\n\t\tif (result < 0)\n\t\t\t \n\t\t\treturn result;\n\t\tif (!result && disable) {\n\t\t\terr = -ENODEV;\n\t\t\tpr_warn(\"Can not disable dGPU when the MUX is in dGPU mode: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_DGPU, disable, &result);\n\tif (err) {\n\t\tpr_warn(\"Failed to set dgpu disable: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (result > 1) {\n\t\tpr_warn(\"Failed to set dgpu disable (result): 0x%x\\n\", result);\n\t\treturn -EIO;\n\t}\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL, \"dgpu_disable\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(dgpu_disable);\n\n \nstatic ssize_t egpu_enable_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint result;\n\n\tresult = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_EGPU);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sysfs_emit(buf, \"%d\\n\", result);\n}\n\n \nstatic ssize_t egpu_enable_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint result, err;\n\tu32 enable;\n\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\terr = kstrtou32(buf, 10, &enable);\n\tif (err)\n\t\treturn err;\n\n\tif (enable > 1)\n\t\treturn -EINVAL;\n\n\terr = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_EGPU_CONNECTED);\n\tif (err < 0) {\n\t\tpr_warn(\"Failed to get egpu connection status: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (asus->gpu_mux_mode_available) {\n\t\tresult = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_GPU_MUX);\n\t\tif (result < 0) {\n\t\t\t \n\t\t\tpr_warn(\"Failed to get gpu mux status: %d\\n\", result);\n\t\t\treturn result;\n\t\t}\n\t\tif (!result && enable) {\n\t\t\terr = -ENODEV;\n\t\t\tpr_warn(\"Can not enable eGPU when the MUX is in dGPU mode: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_EGPU, enable, &result);\n\tif (err) {\n\t\tpr_warn(\"Failed to set egpu state: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (result > 1) {\n\t\tpr_warn(\"Failed to set egpu state (retval): 0x%x\\n\", result);\n\t\treturn -EIO;\n\t}\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL, \"egpu_enable\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(egpu_enable);\n\n \nstatic ssize_t egpu_connected_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint result;\n\n\tresult = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_EGPU_CONNECTED);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sysfs_emit(buf, \"%d\\n\", result);\n}\n\nstatic DEVICE_ATTR_RO(egpu_connected);\n\n \nstatic ssize_t gpu_mux_mode_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint result;\n\n\tresult = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_GPU_MUX);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sysfs_emit(buf, \"%d\\n\", result);\n}\n\nstatic ssize_t gpu_mux_mode_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint result, err;\n\tu32 optimus;\n\n\terr = kstrtou32(buf, 10, &optimus);\n\tif (err)\n\t\treturn err;\n\n\tif (optimus > 1)\n\t\treturn -EINVAL;\n\n\tif (asus->dgpu_disable_available) {\n\t\tresult = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_DGPU);\n\t\tif (result < 0)\n\t\t\t \n\t\t\treturn result;\n\t\tif (result && !optimus) {\n\t\t\terr = -ENODEV;\n\t\t\tpr_warn(\"Can not switch MUX to dGPU mode when dGPU is disabled: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (asus->egpu_enable_available) {\n\t\tresult = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_EGPU);\n\t\tif (result < 0)\n\t\t\t \n\t\t\treturn result;\n\t\tif (result && !optimus) {\n\t\t\terr = -ENODEV;\n\t\t\tpr_warn(\"Can not switch MUX to dGPU mode when eGPU is enabled: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_GPU_MUX, optimus, &result);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to set GPU MUX mode: %d\\n\", err);\n\t\treturn err;\n\t}\n\t \n\tif (result != 1) {\n\t\tdev_warn(dev, \"Failed to set GPU MUX mode (result): 0x%x\\n\", result);\n\t\treturn -EIO;\n\t}\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL, \"gpu_mux_mode\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(gpu_mux_mode);\n\n \nstatic ssize_t kbd_rgb_mode_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tu32 cmd, mode, r, g, b, speed;\n\tint err;\n\n\tif (sscanf(buf, \"%d %d %d %d %d %d\", &cmd, &mode, &r, &g, &b, &speed) != 6)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (cmd) {\n\tcase 0:\n\t\tcmd = 0xb3;\n\t\tbreak;\n\tcase 1:\n\t\tcmd = 0xb4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mode >= 12 || mode == 9)\n\t\tmode = 10;\n\n\tswitch (speed) {\n\tcase 0:\n\t\tspeed = 0xe1;\n\t\tbreak;\n\tcase 1:\n\t\tspeed = 0xeb;\n\t\tbreak;\n\tcase 2:\n\t\tspeed = 0xf5;\n\t\tbreak;\n\tdefault:\n\t\tspeed = 0xeb;\n\t}\n\n\terr = asus_wmi_evaluate_method3(ASUS_WMI_METHODID_DEVS, ASUS_WMI_DEVID_TUF_RGB_MODE,\n\t\t\tcmd | (mode << 8) | (r << 16) | (g << 24), b | (speed << 8), NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(kbd_rgb_mode);\n\nstatic ssize_t kbd_rgb_mode_index_show(struct device *device,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", \"cmd mode red green blue speed\");\n}\nstatic DEVICE_ATTR_RO(kbd_rgb_mode_index);\n\nstatic struct attribute *kbd_rgb_mode_attrs[] = {\n\t&dev_attr_kbd_rgb_mode.attr,\n\t&dev_attr_kbd_rgb_mode_index.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group kbd_rgb_mode_group = {\n\t.attrs = kbd_rgb_mode_attrs,\n};\n\n \nstatic ssize_t kbd_rgb_state_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tu32 flags, cmd, boot, awake, sleep, keyboard;\n\tint err;\n\n\tif (sscanf(buf, \"%d %d %d %d %d\", &cmd, &boot, &awake, &sleep, &keyboard) != 5)\n\t\treturn -EINVAL;\n\n\tif (cmd)\n\t\tcmd = BIT(2);\n\n\tflags = 0;\n\tif (boot)\n\t\tflags |= BIT(1);\n\tif (awake)\n\t\tflags |= BIT(3);\n\tif (sleep)\n\t\tflags |= BIT(5);\n\tif (keyboard)\n\t\tflags |= BIT(7);\n\n\t \n\terr = asus_wmi_evaluate_method3(ASUS_WMI_METHODID_DEVS,\n\t\t\tASUS_WMI_DEVID_TUF_RGB_STATE, 0xbd | cmd << 8 | (flags << 16), 0, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(kbd_rgb_state);\n\nstatic ssize_t kbd_rgb_state_index_show(struct device *device,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", \"cmd boot awake sleep keyboard\");\n}\nstatic DEVICE_ATTR_RO(kbd_rgb_state_index);\n\nstatic struct attribute *kbd_rgb_state_attrs[] = {\n\t&dev_attr_kbd_rgb_state.attr,\n\t&dev_attr_kbd_rgb_state_index.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group kbd_rgb_state_group = {\n\t.attrs = kbd_rgb_state_attrs,\n};\n\nstatic const struct attribute_group *kbd_rgb_mode_groups[] = {\n\tNULL,\n\tNULL,\n\tNULL,\n};\n\n \nstatic ssize_t ppt_pl2_sppt_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint result, err;\n\tu32 value;\n\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\tresult = kstrtou32(buf, 10, &value);\n\tif (result)\n\t\treturn result;\n\n\tif (value < PPT_TOTAL_MIN || value > PPT_TOTAL_MAX)\n\t\treturn -EINVAL;\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_PPT_PL2_SPPT, value, &result);\n\tif (err) {\n\t\tpr_warn(\"Failed to set ppt_pl2_sppt: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (result > 1) {\n\t\tpr_warn(\"Failed to set ppt_pl2_sppt (result): 0x%x\\n\", result);\n\t\treturn -EIO;\n\t}\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL, \"ppt_pl2_sppt\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(ppt_pl2_sppt);\n\n \nstatic ssize_t ppt_pl1_spl_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint result, err;\n\tu32 value;\n\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\tresult = kstrtou32(buf, 10, &value);\n\tif (result)\n\t\treturn result;\n\n\tif (value < PPT_TOTAL_MIN || value > PPT_TOTAL_MAX)\n\t\treturn -EINVAL;\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_PPT_PL1_SPL, value, &result);\n\tif (err) {\n\t\tpr_warn(\"Failed to set ppt_pl1_spl: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (result > 1) {\n\t\tpr_warn(\"Failed to set ppt_pl1_spl (result): 0x%x\\n\", result);\n\t\treturn -EIO;\n\t}\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL, \"ppt_pl1_spl\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(ppt_pl1_spl);\n\n \nstatic ssize_t ppt_fppt_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint result, err;\n\tu32 value;\n\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\tresult = kstrtou32(buf, 10, &value);\n\tif (result)\n\t\treturn result;\n\n\tif (value < PPT_TOTAL_MIN || value > PPT_TOTAL_MAX)\n\t\treturn -EINVAL;\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_PPT_FPPT, value, &result);\n\tif (err) {\n\t\tpr_warn(\"Failed to set ppt_fppt: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (result > 1) {\n\t\tpr_warn(\"Failed to set ppt_fppt (result): 0x%x\\n\", result);\n\t\treturn -EIO;\n\t}\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL, \"ppt_fpu_sppt\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(ppt_fppt);\n\n \nstatic ssize_t ppt_apu_sppt_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint result, err;\n\tu32 value;\n\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\tresult = kstrtou32(buf, 10, &value);\n\tif (result)\n\t\treturn result;\n\n\tif (value < PPT_CPU_MIN || value > PPT_CPU_MAX)\n\t\treturn -EINVAL;\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_PPT_APU_SPPT, value, &result);\n\tif (err) {\n\t\tpr_warn(\"Failed to set ppt_apu_sppt: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (result > 1) {\n\t\tpr_warn(\"Failed to set ppt_apu_sppt (result): 0x%x\\n\", result);\n\t\treturn -EIO;\n\t}\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL, \"ppt_apu_sppt\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(ppt_apu_sppt);\n\n \nstatic ssize_t ppt_platform_sppt_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint result, err;\n\tu32 value;\n\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\tresult = kstrtou32(buf, 10, &value);\n\tif (result)\n\t\treturn result;\n\n\tif (value < PPT_CPU_MIN || value > PPT_CPU_MAX)\n\t\treturn -EINVAL;\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_PPT_PLAT_SPPT, value, &result);\n\tif (err) {\n\t\tpr_warn(\"Failed to set ppt_platform_sppt: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (result > 1) {\n\t\tpr_warn(\"Failed to set ppt_platform_sppt (result): 0x%x\\n\", result);\n\t\treturn -EIO;\n\t}\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL, \"ppt_platform_sppt\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(ppt_platform_sppt);\n\n \nstatic ssize_t nv_dynamic_boost_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint result, err;\n\tu32 value;\n\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\tresult = kstrtou32(buf, 10, &value);\n\tif (result)\n\t\treturn result;\n\n\tif (value < NVIDIA_BOOST_MIN || value > NVIDIA_BOOST_MAX)\n\t\treturn -EINVAL;\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_NV_DYN_BOOST, value, &result);\n\tif (err) {\n\t\tpr_warn(\"Failed to set nv_dynamic_boost: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (result > 1) {\n\t\tpr_warn(\"Failed to set nv_dynamic_boost (result): 0x%x\\n\", result);\n\t\treturn -EIO;\n\t}\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL, \"nv_dynamic_boost\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(nv_dynamic_boost);\n\n \nstatic ssize_t nv_temp_target_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint result, err;\n\tu32 value;\n\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\tresult = kstrtou32(buf, 10, &value);\n\tif (result)\n\t\treturn result;\n\n\tif (value < NVIDIA_TEMP_MIN || value > NVIDIA_TEMP_MAX)\n\t\treturn -EINVAL;\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_NV_THERM_TARGET, value, &result);\n\tif (err) {\n\t\tpr_warn(\"Failed to set nv_temp_target: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (result > 1) {\n\t\tpr_warn(\"Failed to set nv_temp_target (result): 0x%x\\n\", result);\n\t\treturn -EIO;\n\t}\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL, \"nv_temp_target\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(nv_temp_target);\n\n \n\n \nstatic int charge_end_threshold;\n\nstatic ssize_t charge_control_end_threshold_store(struct device *dev,\n\t\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t\t  const char *buf, size_t count)\n{\n\tint value, ret, rv;\n\n\tret = kstrtouint(buf, 10, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value < 0 || value > 100)\n\t\treturn -EINVAL;\n\n\tret = asus_wmi_set_devstate(ASUS_WMI_DEVID_RSOC, value, &rv);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rv != 1)\n\t\treturn -EIO;\n\n\t \n\tcharge_end_threshold = value;\n\treturn count;\n}\n\nstatic ssize_t charge_control_end_threshold_show(struct device *device,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", charge_end_threshold);\n}\n\nstatic DEVICE_ATTR_RW(charge_control_end_threshold);\n\nstatic int asus_wmi_battery_add(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\t \n\tif (strcmp(battery->desc->name, \"BAT0\") != 0 &&\n\t    strcmp(battery->desc->name, \"BAT1\") != 0 &&\n\t    strcmp(battery->desc->name, \"BATC\") != 0 &&\n\t    strcmp(battery->desc->name, \"BATT\") != 0)\n\t\treturn -ENODEV;\n\n\tif (device_create_file(&battery->dev,\n\t    &dev_attr_charge_control_end_threshold))\n\t\treturn -ENODEV;\n\n\t \n\tasus_wmi_set_devstate(ASUS_WMI_DEVID_RSOC, 100, NULL);\n\tcharge_end_threshold = 100;\n\n\treturn 0;\n}\n\nstatic int asus_wmi_battery_remove(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\tdevice_remove_file(&battery->dev,\n\t\t\t   &dev_attr_charge_control_end_threshold);\n\treturn 0;\n}\n\nstatic struct acpi_battery_hook battery_hook = {\n\t.add_battery = asus_wmi_battery_add,\n\t.remove_battery = asus_wmi_battery_remove,\n\t.name = \"ASUS Battery Extension\",\n};\n\nstatic void asus_wmi_battery_init(struct asus_wmi *asus)\n{\n\tasus->battery_rsoc_available = false;\n\tif (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_RSOC)) {\n\t\tasus->battery_rsoc_available = true;\n\t\tbattery_hook_register(&battery_hook);\n\t}\n}\n\nstatic void asus_wmi_battery_exit(struct asus_wmi *asus)\n{\n\tif (asus->battery_rsoc_available)\n\t\tbattery_hook_unregister(&battery_hook);\n}\n\n \n\n \nstatic void tpd_led_update(struct work_struct *work)\n{\n\tint ctrl_param;\n\tstruct asus_wmi *asus;\n\n\tasus = container_of(work, struct asus_wmi, tpd_led_work);\n\n\tctrl_param = asus->tpd_led_wk;\n\tasus_wmi_set_devstate(ASUS_WMI_DEVID_TOUCHPAD_LED, ctrl_param, NULL);\n}\n\nstatic void tpd_led_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness value)\n{\n\tstruct asus_wmi *asus;\n\n\tasus = container_of(led_cdev, struct asus_wmi, tpd_led);\n\n\tasus->tpd_led_wk = !!value;\n\tqueue_work(asus->led_workqueue, &asus->tpd_led_work);\n}\n\nstatic int read_tpd_led_state(struct asus_wmi *asus)\n{\n\treturn asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_TOUCHPAD_LED);\n}\n\nstatic enum led_brightness tpd_led_get(struct led_classdev *led_cdev)\n{\n\tstruct asus_wmi *asus;\n\n\tasus = container_of(led_cdev, struct asus_wmi, tpd_led);\n\n\treturn read_tpd_led_state(asus);\n}\n\nstatic void kbd_led_update(struct asus_wmi *asus)\n{\n\tint ctrl_param = 0;\n\n\tctrl_param = 0x80 | (asus->kbd_led_wk & 0x7F);\n\tasus_wmi_set_devstate(ASUS_WMI_DEVID_KBD_BACKLIGHT, ctrl_param, NULL);\n}\n\nstatic int kbd_led_read(struct asus_wmi *asus, int *level, int *env)\n{\n\tint retval;\n\n\t \n\tretval = asus_wmi_get_devstate_bits(asus, ASUS_WMI_DEVID_KBD_BACKLIGHT,\n\t\t\t\t\t    0xFFFF);\n\n\t \n\tif (retval == 0x8000)\n\t\tretval = 0;\n\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif (level)\n\t\t*level = retval & 0x7F;\n\tif (env)\n\t\t*env = (retval >> 8) & 0x7F;\n\treturn 0;\n}\n\nstatic void do_kbd_led_set(struct led_classdev *led_cdev, int value)\n{\n\tstruct asus_wmi *asus;\n\tint max_level;\n\n\tasus = container_of(led_cdev, struct asus_wmi, kbd_led);\n\tmax_level = asus->kbd_led.max_brightness;\n\n\tasus->kbd_led_wk = clamp_val(value, 0, max_level);\n\tkbd_led_update(asus);\n}\n\nstatic void kbd_led_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness value)\n{\n\t \n\tif (led_cdev->flags & LED_UNREGISTERING)\n\t\treturn;\n\n\tdo_kbd_led_set(led_cdev, value);\n}\n\nstatic void kbd_led_set_by_kbd(struct asus_wmi *asus, enum led_brightness value)\n{\n\tstruct led_classdev *led_cdev = &asus->kbd_led;\n\n\tdo_kbd_led_set(led_cdev, value);\n\tled_classdev_notify_brightness_hw_changed(led_cdev, asus->kbd_led_wk);\n}\n\nstatic enum led_brightness kbd_led_get(struct led_classdev *led_cdev)\n{\n\tstruct asus_wmi *asus;\n\tint retval, value;\n\n\tasus = container_of(led_cdev, struct asus_wmi, kbd_led);\n\n\tretval = kbd_led_read(asus, &value, NULL);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn value;\n}\n\nstatic int wlan_led_unknown_state(struct asus_wmi *asus)\n{\n\tu32 result;\n\n\tasus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WIRELESS_LED, &result);\n\n\treturn result & ASUS_WMI_DSTS_UNKNOWN_BIT;\n}\n\nstatic void wlan_led_update(struct work_struct *work)\n{\n\tint ctrl_param;\n\tstruct asus_wmi *asus;\n\n\tasus = container_of(work, struct asus_wmi, wlan_led_work);\n\n\tctrl_param = asus->wlan_led_wk;\n\tasus_wmi_set_devstate(ASUS_WMI_DEVID_WIRELESS_LED, ctrl_param, NULL);\n}\n\nstatic void wlan_led_set(struct led_classdev *led_cdev,\n\t\t\t enum led_brightness value)\n{\n\tstruct asus_wmi *asus;\n\n\tasus = container_of(led_cdev, struct asus_wmi, wlan_led);\n\n\tasus->wlan_led_wk = !!value;\n\tqueue_work(asus->led_workqueue, &asus->wlan_led_work);\n}\n\nstatic enum led_brightness wlan_led_get(struct led_classdev *led_cdev)\n{\n\tstruct asus_wmi *asus;\n\tu32 result;\n\n\tasus = container_of(led_cdev, struct asus_wmi, wlan_led);\n\tasus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WIRELESS_LED, &result);\n\n\treturn result & ASUS_WMI_DSTS_BRIGHTNESS_MASK;\n}\n\nstatic void lightbar_led_update(struct work_struct *work)\n{\n\tstruct asus_wmi *asus;\n\tint ctrl_param;\n\n\tasus = container_of(work, struct asus_wmi, lightbar_led_work);\n\n\tctrl_param = asus->lightbar_led_wk;\n\tasus_wmi_set_devstate(ASUS_WMI_DEVID_LIGHTBAR, ctrl_param, NULL);\n}\n\nstatic void lightbar_led_set(struct led_classdev *led_cdev,\n\t\t\t     enum led_brightness value)\n{\n\tstruct asus_wmi *asus;\n\n\tasus = container_of(led_cdev, struct asus_wmi, lightbar_led);\n\n\tasus->lightbar_led_wk = !!value;\n\tqueue_work(asus->led_workqueue, &asus->lightbar_led_work);\n}\n\nstatic enum led_brightness lightbar_led_get(struct led_classdev *led_cdev)\n{\n\tstruct asus_wmi *asus;\n\tu32 result;\n\n\tasus = container_of(led_cdev, struct asus_wmi, lightbar_led);\n\tasus_wmi_get_devstate(asus, ASUS_WMI_DEVID_LIGHTBAR, &result);\n\n\treturn result & ASUS_WMI_DSTS_LIGHTBAR_MASK;\n}\n\nstatic int micmute_led_set(struct led_classdev *led_cdev,\n\t\t\t   enum led_brightness brightness)\n{\n\tint state = brightness != LED_OFF;\n\tint err;\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_MICMUTE_LED, state, NULL);\n\treturn err < 0 ? err : 0;\n}\n\nstatic void asus_wmi_led_exit(struct asus_wmi *asus)\n{\n\tled_classdev_unregister(&asus->kbd_led);\n\tled_classdev_unregister(&asus->tpd_led);\n\tled_classdev_unregister(&asus->wlan_led);\n\tled_classdev_unregister(&asus->lightbar_led);\n\tled_classdev_unregister(&asus->micmute_led);\n\n\tif (asus->led_workqueue)\n\t\tdestroy_workqueue(asus->led_workqueue);\n}\n\nstatic int asus_wmi_led_init(struct asus_wmi *asus)\n{\n\tint rv = 0, num_rgb_groups = 0, led_val;\n\n\tif (asus->kbd_rgb_mode_available)\n\t\tkbd_rgb_mode_groups[num_rgb_groups++] = &kbd_rgb_mode_group;\n\tif (asus->kbd_rgb_state_available)\n\t\tkbd_rgb_mode_groups[num_rgb_groups++] = &kbd_rgb_state_group;\n\n\tasus->led_workqueue = create_singlethread_workqueue(\"led_workqueue\");\n\tif (!asus->led_workqueue)\n\t\treturn -ENOMEM;\n\n\tif (read_tpd_led_state(asus) >= 0) {\n\t\tINIT_WORK(&asus->tpd_led_work, tpd_led_update);\n\n\t\tasus->tpd_led.name = \"asus::touchpad\";\n\t\tasus->tpd_led.brightness_set = tpd_led_set;\n\t\tasus->tpd_led.brightness_get = tpd_led_get;\n\t\tasus->tpd_led.max_brightness = 1;\n\n\t\trv = led_classdev_register(&asus->platform_device->dev,\n\t\t\t\t\t   &asus->tpd_led);\n\t\tif (rv)\n\t\t\tgoto error;\n\t}\n\n\tif (!kbd_led_read(asus, &led_val, NULL)) {\n\t\tasus->kbd_led_wk = led_val;\n\t\tasus->kbd_led.name = \"asus::kbd_backlight\";\n\t\tasus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;\n\t\tasus->kbd_led.brightness_set = kbd_led_set;\n\t\tasus->kbd_led.brightness_get = kbd_led_get;\n\t\tasus->kbd_led.max_brightness = 3;\n\n\t\tif (num_rgb_groups != 0)\n\t\t\tasus->kbd_led.groups = kbd_rgb_mode_groups;\n\n\t\trv = led_classdev_register(&asus->platform_device->dev,\n\t\t\t\t\t   &asus->kbd_led);\n\t\tif (rv)\n\t\t\tgoto error;\n\t}\n\n\tif (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_WIRELESS_LED)\n\t\t\t&& (asus->driver->quirks->wapf > 0)) {\n\t\tINIT_WORK(&asus->wlan_led_work, wlan_led_update);\n\n\t\tasus->wlan_led.name = \"asus::wlan\";\n\t\tasus->wlan_led.brightness_set = wlan_led_set;\n\t\tif (!wlan_led_unknown_state(asus))\n\t\t\tasus->wlan_led.brightness_get = wlan_led_get;\n\t\tasus->wlan_led.flags = LED_CORE_SUSPENDRESUME;\n\t\tasus->wlan_led.max_brightness = 1;\n\t\tasus->wlan_led.default_trigger = \"asus-wlan\";\n\n\t\trv = led_classdev_register(&asus->platform_device->dev,\n\t\t\t\t\t   &asus->wlan_led);\n\t\tif (rv)\n\t\t\tgoto error;\n\t}\n\n\tif (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_LIGHTBAR)) {\n\t\tINIT_WORK(&asus->lightbar_led_work, lightbar_led_update);\n\n\t\tasus->lightbar_led.name = \"asus::lightbar\";\n\t\tasus->lightbar_led.brightness_set = lightbar_led_set;\n\t\tasus->lightbar_led.brightness_get = lightbar_led_get;\n\t\tasus->lightbar_led.max_brightness = 1;\n\n\t\trv = led_classdev_register(&asus->platform_device->dev,\n\t\t\t\t\t   &asus->lightbar_led);\n\t}\n\n\tif (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_MICMUTE_LED)) {\n\t\tasus->micmute_led.name = \"platform::micmute\";\n\t\tasus->micmute_led.max_brightness = 1;\n\t\tasus->micmute_led.brightness = ledtrig_audio_get(LED_AUDIO_MICMUTE);\n\t\tasus->micmute_led.brightness_set_blocking = micmute_led_set;\n\t\tasus->micmute_led.default_trigger = \"audio-micmute\";\n\n\t\trv = led_classdev_register(&asus->platform_device->dev,\n\t\t\t\t\t\t&asus->micmute_led);\n\t\tif (rv)\n\t\t\tgoto error;\n\t}\n\nerror:\n\tif (rv)\n\t\tasus_wmi_led_exit(asus);\n\n\treturn rv;\n}\n\n \n\n \nstatic bool asus_wlan_rfkill_blocked(struct asus_wmi *asus)\n{\n\tint result = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WLAN);\n\n\tif (result < 0)\n\t\treturn false;\n\treturn !result;\n}\n\nstatic void asus_rfkill_hotplug(struct asus_wmi *asus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *bus;\n\tbool blocked;\n\tbool absent;\n\tu32 l;\n\n\tmutex_lock(&asus->wmi_lock);\n\tblocked = asus_wlan_rfkill_blocked(asus);\n\tmutex_unlock(&asus->wmi_lock);\n\n\tmutex_lock(&asus->hotplug_lock);\n\tpci_lock_rescan_remove();\n\n\tif (asus->wlan.rfkill)\n\t\trfkill_set_sw_state(asus->wlan.rfkill, blocked);\n\n\tif (asus->hotplug_slot.ops) {\n\t\tbus = pci_find_bus(0, 1);\n\t\tif (!bus) {\n\t\t\tpr_warn(\"Unable to find PCI bus 1?\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (pci_bus_read_config_dword(bus, 0, PCI_VENDOR_ID, &l)) {\n\t\t\tpr_err(\"Unable to read PCI config space?\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tabsent = (l == 0xffffffff);\n\n\t\tif (blocked != absent) {\n\t\t\tpr_warn(\"BIOS says wireless lan is %s, but the pci device is %s\\n\",\n\t\t\t\tblocked ? \"blocked\" : \"unblocked\",\n\t\t\t\tabsent ? \"absent\" : \"present\");\n\t\t\tpr_warn(\"skipped wireless hotplug as probably inappropriate for this model\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (!blocked) {\n\t\t\tdev = pci_get_slot(bus, 0);\n\t\t\tif (dev) {\n\t\t\t\t \n\t\t\t\tpci_dev_put(dev);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tdev = pci_scan_single_device(bus, 0);\n\t\t\tif (dev) {\n\t\t\t\tpci_bus_assign_resources(bus);\n\t\t\t\tpci_bus_add_device(dev);\n\t\t\t}\n\t\t} else {\n\t\t\tdev = pci_get_slot(bus, 0);\n\t\t\tif (dev) {\n\t\t\t\tpci_stop_and_remove_bus_device(dev);\n\t\t\t\tpci_dev_put(dev);\n\t\t\t}\n\t\t}\n\t}\n\nout_unlock:\n\tpci_unlock_rescan_remove();\n\tmutex_unlock(&asus->hotplug_lock);\n}\n\nstatic void asus_rfkill_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct asus_wmi *asus = data;\n\n\tif (event != ACPI_NOTIFY_BUS_CHECK)\n\t\treturn;\n\n\t \n\tqueue_work(asus->hotplug_workqueue, &asus->hotplug_work);\n}\n\nstatic int asus_register_rfkill_notifier(struct asus_wmi *asus, char *node)\n{\n\tacpi_status status;\n\tacpi_handle handle;\n\n\tstatus = acpi_get_handle(NULL, node, &handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tstatus = acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,\n\t\t\t\t\t     asus_rfkill_notify, asus);\n\tif (ACPI_FAILURE(status))\n\t\tpr_warn(\"Failed to register notify on %s\\n\", node);\n\n\treturn 0;\n}\n\nstatic void asus_unregister_rfkill_notifier(struct asus_wmi *asus, char *node)\n{\n\tacpi_status status = AE_OK;\n\tacpi_handle handle;\n\n\tstatus = acpi_get_handle(NULL, node, &handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tstatus = acpi_remove_notify_handler(handle, ACPI_SYSTEM_NOTIFY,\n\t\t\t\t\t    asus_rfkill_notify);\n\tif (ACPI_FAILURE(status))\n\t\tpr_err(\"Error removing rfkill notify handler %s\\n\", node);\n}\n\nstatic int asus_get_adapter_status(struct hotplug_slot *hotplug_slot,\n\t\t\t\t   u8 *value)\n{\n\tstruct asus_wmi *asus = container_of(hotplug_slot,\n\t\t\t\t\t     struct asus_wmi, hotplug_slot);\n\tint result = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WLAN);\n\n\tif (result < 0)\n\t\treturn result;\n\n\t*value = !!result;\n\treturn 0;\n}\n\nstatic const struct hotplug_slot_ops asus_hotplug_slot_ops = {\n\t.get_adapter_status = asus_get_adapter_status,\n\t.get_power_status = asus_get_adapter_status,\n};\n\nstatic void asus_hotplug_work(struct work_struct *work)\n{\n\tstruct asus_wmi *asus;\n\n\tasus = container_of(work, struct asus_wmi, hotplug_work);\n\tasus_rfkill_hotplug(asus);\n}\n\nstatic int asus_setup_pci_hotplug(struct asus_wmi *asus)\n{\n\tint ret = -ENOMEM;\n\tstruct pci_bus *bus = pci_find_bus(0, 1);\n\n\tif (!bus) {\n\t\tpr_err(\"Unable to find wifi PCI bus\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tasus->hotplug_workqueue =\n\t    create_singlethread_workqueue(\"hotplug_workqueue\");\n\tif (!asus->hotplug_workqueue)\n\t\tgoto error_workqueue;\n\n\tINIT_WORK(&asus->hotplug_work, asus_hotplug_work);\n\n\tasus->hotplug_slot.ops = &asus_hotplug_slot_ops;\n\n\tret = pci_hp_register(&asus->hotplug_slot, bus, 0, \"asus-wifi\");\n\tif (ret) {\n\t\tpr_err(\"Unable to register hotplug slot - %d\\n\", ret);\n\t\tgoto error_register;\n\t}\n\n\treturn 0;\n\nerror_register:\n\tasus->hotplug_slot.ops = NULL;\n\tdestroy_workqueue(asus->hotplug_workqueue);\nerror_workqueue:\n\treturn ret;\n}\n\n \nstatic int asus_rfkill_set(void *data, bool blocked)\n{\n\tstruct asus_rfkill *priv = data;\n\tu32 ctrl_param = !blocked;\n\tu32 dev_id = priv->dev_id;\n\n\t \n\tif ((dev_id == ASUS_WMI_DEVID_WLAN) &&\n\t     priv->asus->driver->wlan_ctrl_by_user)\n\t\tdev_id = ASUS_WMI_DEVID_WLAN_LED;\n\n\treturn asus_wmi_set_devstate(dev_id, ctrl_param, NULL);\n}\n\nstatic void asus_rfkill_query(struct rfkill *rfkill, void *data)\n{\n\tstruct asus_rfkill *priv = data;\n\tint result;\n\n\tresult = asus_wmi_get_devstate_simple(priv->asus, priv->dev_id);\n\n\tif (result < 0)\n\t\treturn;\n\n\trfkill_set_sw_state(priv->rfkill, !result);\n}\n\nstatic int asus_rfkill_wlan_set(void *data, bool blocked)\n{\n\tstruct asus_rfkill *priv = data;\n\tstruct asus_wmi *asus = priv->asus;\n\tint ret;\n\n\t \n\tmutex_lock(&asus->wmi_lock);\n\tret = asus_rfkill_set(data, blocked);\n\tmutex_unlock(&asus->wmi_lock);\n\treturn ret;\n}\n\nstatic const struct rfkill_ops asus_rfkill_wlan_ops = {\n\t.set_block = asus_rfkill_wlan_set,\n\t.query = asus_rfkill_query,\n};\n\nstatic const struct rfkill_ops asus_rfkill_ops = {\n\t.set_block = asus_rfkill_set,\n\t.query = asus_rfkill_query,\n};\n\nstatic int asus_new_rfkill(struct asus_wmi *asus,\n\t\t\t   struct asus_rfkill *arfkill,\n\t\t\t   const char *name, enum rfkill_type type, int dev_id)\n{\n\tint result = asus_wmi_get_devstate_simple(asus, dev_id);\n\tstruct rfkill **rfkill = &arfkill->rfkill;\n\n\tif (result < 0)\n\t\treturn result;\n\n\tarfkill->dev_id = dev_id;\n\tarfkill->asus = asus;\n\n\tif (dev_id == ASUS_WMI_DEVID_WLAN &&\n\t    asus->driver->quirks->hotplug_wireless)\n\t\t*rfkill = rfkill_alloc(name, &asus->platform_device->dev, type,\n\t\t\t\t       &asus_rfkill_wlan_ops, arfkill);\n\telse\n\t\t*rfkill = rfkill_alloc(name, &asus->platform_device->dev, type,\n\t\t\t\t       &asus_rfkill_ops, arfkill);\n\n\tif (!*rfkill)\n\t\treturn -EINVAL;\n\n\tif ((dev_id == ASUS_WMI_DEVID_WLAN) &&\n\t\t\t(asus->driver->quirks->wapf > 0))\n\t\trfkill_set_led_trigger_name(*rfkill, \"asus-wlan\");\n\n\trfkill_init_sw_state(*rfkill, !result);\n\tresult = rfkill_register(*rfkill);\n\tif (result) {\n\t\trfkill_destroy(*rfkill);\n\t\t*rfkill = NULL;\n\t\treturn result;\n\t}\n\treturn 0;\n}\n\nstatic void asus_wmi_rfkill_exit(struct asus_wmi *asus)\n{\n\tif (asus->driver->wlan_ctrl_by_user && ashs_present())\n\t\treturn;\n\n\tasus_unregister_rfkill_notifier(asus, \"\\\\_SB.PCI0.P0P5\");\n\tasus_unregister_rfkill_notifier(asus, \"\\\\_SB.PCI0.P0P6\");\n\tasus_unregister_rfkill_notifier(asus, \"\\\\_SB.PCI0.P0P7\");\n\tif (asus->wlan.rfkill) {\n\t\trfkill_unregister(asus->wlan.rfkill);\n\t\trfkill_destroy(asus->wlan.rfkill);\n\t\tasus->wlan.rfkill = NULL;\n\t}\n\t \n\tasus_rfkill_hotplug(asus);\n\tif (asus->hotplug_slot.ops)\n\t\tpci_hp_deregister(&asus->hotplug_slot);\n\tif (asus->hotplug_workqueue)\n\t\tdestroy_workqueue(asus->hotplug_workqueue);\n\n\tif (asus->bluetooth.rfkill) {\n\t\trfkill_unregister(asus->bluetooth.rfkill);\n\t\trfkill_destroy(asus->bluetooth.rfkill);\n\t\tasus->bluetooth.rfkill = NULL;\n\t}\n\tif (asus->wimax.rfkill) {\n\t\trfkill_unregister(asus->wimax.rfkill);\n\t\trfkill_destroy(asus->wimax.rfkill);\n\t\tasus->wimax.rfkill = NULL;\n\t}\n\tif (asus->wwan3g.rfkill) {\n\t\trfkill_unregister(asus->wwan3g.rfkill);\n\t\trfkill_destroy(asus->wwan3g.rfkill);\n\t\tasus->wwan3g.rfkill = NULL;\n\t}\n\tif (asus->gps.rfkill) {\n\t\trfkill_unregister(asus->gps.rfkill);\n\t\trfkill_destroy(asus->gps.rfkill);\n\t\tasus->gps.rfkill = NULL;\n\t}\n\tif (asus->uwb.rfkill) {\n\t\trfkill_unregister(asus->uwb.rfkill);\n\t\trfkill_destroy(asus->uwb.rfkill);\n\t\tasus->uwb.rfkill = NULL;\n\t}\n}\n\nstatic int asus_wmi_rfkill_init(struct asus_wmi *asus)\n{\n\tint result = 0;\n\n\tmutex_init(&asus->hotplug_lock);\n\tmutex_init(&asus->wmi_lock);\n\n\tresult = asus_new_rfkill(asus, &asus->wlan, \"asus-wlan\",\n\t\t\t\t RFKILL_TYPE_WLAN, ASUS_WMI_DEVID_WLAN);\n\n\tif (result && result != -ENODEV)\n\t\tgoto exit;\n\n\tresult = asus_new_rfkill(asus, &asus->bluetooth,\n\t\t\t\t \"asus-bluetooth\", RFKILL_TYPE_BLUETOOTH,\n\t\t\t\t ASUS_WMI_DEVID_BLUETOOTH);\n\n\tif (result && result != -ENODEV)\n\t\tgoto exit;\n\n\tresult = asus_new_rfkill(asus, &asus->wimax, \"asus-wimax\",\n\t\t\t\t RFKILL_TYPE_WIMAX, ASUS_WMI_DEVID_WIMAX);\n\n\tif (result && result != -ENODEV)\n\t\tgoto exit;\n\n\tresult = asus_new_rfkill(asus, &asus->wwan3g, \"asus-wwan3g\",\n\t\t\t\t RFKILL_TYPE_WWAN, ASUS_WMI_DEVID_WWAN3G);\n\n\tif (result && result != -ENODEV)\n\t\tgoto exit;\n\n\tresult = asus_new_rfkill(asus, &asus->gps, \"asus-gps\",\n\t\t\t\t RFKILL_TYPE_GPS, ASUS_WMI_DEVID_GPS);\n\n\tif (result && result != -ENODEV)\n\t\tgoto exit;\n\n\tresult = asus_new_rfkill(asus, &asus->uwb, \"asus-uwb\",\n\t\t\t\t RFKILL_TYPE_UWB, ASUS_WMI_DEVID_UWB);\n\n\tif (result && result != -ENODEV)\n\t\tgoto exit;\n\n\tif (!asus->driver->quirks->hotplug_wireless)\n\t\tgoto exit;\n\n\tresult = asus_setup_pci_hotplug(asus);\n\t \n\tif (result == -EBUSY)\n\t\tresult = 0;\n\n\tasus_register_rfkill_notifier(asus, \"\\\\_SB.PCI0.P0P5\");\n\tasus_register_rfkill_notifier(asus, \"\\\\_SB.PCI0.P0P6\");\n\tasus_register_rfkill_notifier(asus, \"\\\\_SB.PCI0.P0P7\");\n\t \n\tasus_rfkill_hotplug(asus);\n\nexit:\n\tif (result && result != -ENODEV)\n\t\tasus_wmi_rfkill_exit(asus);\n\n\tif (result == -ENODEV)\n\t\tresult = 0;\n\n\treturn result;\n}\n\n \nstatic ssize_t panel_od_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint result;\n\n\tresult = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_PANEL_OD);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sysfs_emit(buf, \"%d\\n\", result);\n}\n\nstatic ssize_t panel_od_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint result, err;\n\tu32 overdrive;\n\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\tresult = kstrtou32(buf, 10, &overdrive);\n\tif (result)\n\t\treturn result;\n\n\tif (overdrive > 1)\n\t\treturn -EINVAL;\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_PANEL_OD, overdrive, &result);\n\n\tif (err) {\n\t\tpr_warn(\"Failed to set panel overdrive: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (result > 1) {\n\t\tpr_warn(\"Failed to set panel overdrive (result): 0x%x\\n\", result);\n\t\treturn -EIO;\n\t}\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL, \"panel_od\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(panel_od);\n\n \nstatic ssize_t mini_led_mode_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint result;\n\n\tresult = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_MINI_LED_MODE);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sysfs_emit(buf, \"%d\\n\", result);\n}\n\nstatic ssize_t mini_led_mode_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint result, err;\n\tu32 mode;\n\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\tresult = kstrtou32(buf, 10, &mode);\n\tif (result)\n\t\treturn result;\n\n\tif (mode > 1)\n\t\treturn -EINVAL;\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_MINI_LED_MODE, mode, &result);\n\n\tif (err) {\n\t\tpr_warn(\"Failed to set mini-LED: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (result > 1) {\n\t\tpr_warn(\"Failed to set mini-LED mode (result): 0x%x\\n\", result);\n\t\treturn -EIO;\n\t}\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL, \"mini_led_mode\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(mini_led_mode);\n\n \n\nstatic void asus_wmi_set_xusb2pr(struct asus_wmi *asus)\n{\n\tstruct pci_dev *xhci_pdev;\n\tu32 orig_ports_available;\n\tu32 ports_available = asus->driver->quirks->xusb2pr;\n\n\txhci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\tPCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI,\n\t\t\tNULL);\n\n\tif (!xhci_pdev)\n\t\treturn;\n\n\tpci_read_config_dword(xhci_pdev, USB_INTEL_XUSB2PR,\n\t\t\t\t&orig_ports_available);\n\n\tpci_write_config_dword(xhci_pdev, USB_INTEL_XUSB2PR,\n\t\t\t\tcpu_to_le32(ports_available));\n\n\tpci_dev_put(xhci_pdev);\n\n\tpr_info(\"set USB_INTEL_XUSB2PR old: 0x%04x, new: 0x%04x\\n\",\n\t\t\torig_ports_available, ports_available);\n}\n\n \nstatic void asus_wmi_set_als(void)\n{\n\tasus_wmi_set_devstate(ASUS_WMI_DEVID_ALS_ENABLE, 1, NULL);\n}\n\n \n\nstatic int asus_agfn_fan_speed_read(struct asus_wmi *asus, int fan,\n\t\t\t\t\t  int *speed)\n{\n\tstruct agfn_fan_args args = {\n\t\t.agfn.len = sizeof(args),\n\t\t.agfn.mfun = ASUS_FAN_MFUN,\n\t\t.agfn.sfun = ASUS_FAN_SFUN_READ,\n\t\t.fan = fan,\n\t\t.speed = 0,\n\t};\n\tstruct acpi_buffer input = { (acpi_size) sizeof(args), &args };\n\tint status;\n\n\tif (fan != 1)\n\t\treturn -EINVAL;\n\n\tstatus = asus_wmi_evaluate_method_agfn(input);\n\n\tif (status || args.agfn.err)\n\t\treturn -ENXIO;\n\n\tif (speed)\n\t\t*speed = args.speed;\n\n\treturn 0;\n}\n\nstatic int asus_agfn_fan_speed_write(struct asus_wmi *asus, int fan,\n\t\t\t\t     int *speed)\n{\n\tstruct agfn_fan_args args = {\n\t\t.agfn.len = sizeof(args),\n\t\t.agfn.mfun = ASUS_FAN_MFUN,\n\t\t.agfn.sfun = ASUS_FAN_SFUN_WRITE,\n\t\t.fan = fan,\n\t\t.speed = speed ?  *speed : 0,\n\t};\n\tstruct acpi_buffer input = { (acpi_size) sizeof(args), &args };\n\tint status;\n\n\t \n\tif (fan != 1 && fan != 0)\n\t\treturn -EINVAL;\n\n\tstatus = asus_wmi_evaluate_method_agfn(input);\n\n\tif (status || args.agfn.err)\n\t\treturn -ENXIO;\n\n\tif (speed && fan == 1)\n\t\tasus->agfn_pwm = *speed;\n\n\treturn 0;\n}\n\n \nstatic bool asus_wmi_has_agfn_fan(struct asus_wmi *asus)\n{\n\tint status;\n\tint speed;\n\tu32 value;\n\n\tstatus = asus_agfn_fan_speed_read(asus, 1, &speed);\n\tif (status != 0)\n\t\treturn false;\n\n\tstatus = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_CTRL, &value);\n\tif (status != 0)\n\t\treturn false;\n\n\t \n\treturn !(value == ASUS_WMI_UNSUPPORTED_METHOD || value & 0xFFF80000\n\t\t || (!asus->sfun && !(value & ASUS_WMI_DSTS_PRESENCE_BIT)));\n}\n\nstatic int asus_fan_set_auto(struct asus_wmi *asus)\n{\n\tint status;\n\tu32 retval;\n\n\tswitch (asus->fan_type) {\n\tcase FAN_TYPE_SPEC83:\n\t\tstatus = asus_wmi_set_devstate(ASUS_WMI_DEVID_CPU_FAN_CTRL,\n\t\t\t\t\t       0, &retval);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tif (retval != 1)\n\t\t\treturn -EIO;\n\t\tbreak;\n\n\tcase FAN_TYPE_AGFN:\n\t\tstatus = asus_agfn_fan_speed_write(asus, 0, NULL);\n\t\tif (status)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tif (asus->gpu_fan_type == FAN_TYPE_SPEC83) {\n\t\tstatus = asus_wmi_set_devstate(ASUS_WMI_DEVID_GPU_FAN_CTRL,\n\t\t\t\t\t       0, &retval);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tif (retval != 1)\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t pwm1_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint err;\n\tint value;\n\n\t \n\tif (asus->agfn_pwm >= 0)\n\t\treturn sprintf(buf, \"%d\\n\", asus->agfn_pwm);\n\n\t \n\terr = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_CTRL, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue &= 0xFF;\n\n\tif (value == 1)  \n\t\tvalue = 85;\n\telse if (value == 2)\n\t\tvalue = 170;\n\telse if (value == 3)\n\t\tvalue = 255;\n\telse if (value) {\n\t\tpr_err(\"Unknown fan speed %#x\\n\", value);\n\t\tvalue = -1;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t pwm1_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count) {\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint value;\n\tint state;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tvalue = clamp(value, 0, 255);\n\n\tstate = asus_agfn_fan_speed_write(asus, 1, &value);\n\tif (state)\n\t\tpr_warn(\"Setting fan speed failed: %d\\n\", state);\n\telse\n\t\tasus->fan_pwm_mode = ASUS_FAN_CTRL_MANUAL;\n\n\treturn count;\n}\n\nstatic ssize_t fan1_input_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint value;\n\tint ret;\n\n\tswitch (asus->fan_type) {\n\tcase FAN_TYPE_SPEC83:\n\t\tret = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_CPU_FAN_CTRL,\n\t\t\t\t\t    &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tvalue &= 0xffff;\n\t\tbreak;\n\n\tcase FAN_TYPE_AGFN:\n\t\t \n\t\tif (asus->fan_pwm_mode == ASUS_FAN_CTRL_MANUAL)\n\t\t\treturn -ENXIO;\n\n\t\tret = asus_agfn_fan_speed_read(asus, 1, &value);\n\t\tif (ret) {\n\t\t\tpr_warn(\"reading fan speed failed: %d\\n\", ret);\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", value < 0 ? -1 : value * 100);\n}\n\nstatic ssize_t pwm1_enable_show(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\t \n\treturn sysfs_emit(buf, \"%d\\n\", asus->fan_pwm_mode);\n}\n\nstatic ssize_t pwm1_enable_store(struct device *dev,\n\t\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint status = 0;\n\tint state;\n\tint value;\n\tint ret;\n\tu32 retval;\n\n\tret = kstrtouint(buf, 10, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (asus->fan_type == FAN_TYPE_SPEC83) {\n\t\tswitch (state) {  \n\t\tcase ASUS_FAN_CTRL_FULLSPEED:\n\t\t\tvalue = 1;\n\t\t\tbreak;\n\t\tcase ASUS_FAN_CTRL_AUTO:\n\t\t\tvalue = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = asus_wmi_set_devstate(ASUS_WMI_DEVID_CPU_FAN_CTRL,\n\t\t\t\t\t    value, &retval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (retval != 1)\n\t\t\treturn -EIO;\n\t} else if (asus->fan_type == FAN_TYPE_AGFN) {\n\t\tswitch (state) {\n\t\tcase ASUS_FAN_CTRL_MANUAL:\n\t\t\tbreak;\n\n\t\tcase ASUS_FAN_CTRL_AUTO:\n\t\t\tstatus = asus_fan_set_auto(asus);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tasus->fan_pwm_mode = state;\n\n\t \n\tif (asus->cpu_fan_curve_available)\n\t\tasus->custom_fan_curves[FAN_CURVE_DEV_CPU].enabled = false;\n\tif (asus->gpu_fan_curve_available)\n\t\tasus->custom_fan_curves[FAN_CURVE_DEV_GPU].enabled = false;\n\tif (asus->mid_fan_curve_available)\n\t\tasus->custom_fan_curves[FAN_CURVE_DEV_MID].enabled = false;\n\n\treturn count;\n}\n\nstatic ssize_t fan1_label_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", ASUS_FAN_DESC);\n}\n\nstatic ssize_t asus_hwmon_temp1(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tu32 value;\n\tint err;\n\n\terr = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_THERMAL_CTRL, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%ld\\n\",\n\t\t       deci_kelvin_to_millicelsius(value & 0xFFFF));\n}\n\n \nstatic ssize_t fan2_input_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint value;\n\tint ret;\n\n\tret = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_GPU_FAN_CTRL, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvalue &= 0xffff;\n\n\treturn sysfs_emit(buf, \"%d\\n\", value * 100);\n}\n\nstatic ssize_t fan2_label_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", ASUS_GPU_FAN_DESC);\n}\n\n \nstatic ssize_t fan3_input_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint value;\n\tint ret;\n\n\tret = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_MID_FAN_CTRL, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvalue &= 0xffff;\n\n\treturn sysfs_emit(buf, \"%d\\n\", value * 100);\n}\n\nstatic ssize_t fan3_label_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", ASUS_MID_FAN_DESC);\n}\n\nstatic ssize_t pwm2_enable_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", asus->gpu_fan_pwm_mode);\n}\n\nstatic ssize_t pwm2_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint state;\n\tint value;\n\tint ret;\n\tu32 retval;\n\n\tret = kstrtouint(buf, 10, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (state) {  \n\tcase ASUS_FAN_CTRL_FULLSPEED:\n\t\tvalue = 1;\n\t\tbreak;\n\tcase ASUS_FAN_CTRL_AUTO:\n\t\tvalue = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = asus_wmi_set_devstate(ASUS_WMI_DEVID_GPU_FAN_CTRL,\n\t\t\t\t    value, &retval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (retval != 1)\n\t\treturn -EIO;\n\n\tasus->gpu_fan_pwm_mode = state;\n\treturn count;\n}\n\nstatic ssize_t pwm3_enable_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", asus->mid_fan_pwm_mode);\n}\n\nstatic ssize_t pwm3_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tint state;\n\tint value;\n\tint ret;\n\tu32 retval;\n\n\tret = kstrtouint(buf, 10, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (state) {  \n\tcase ASUS_FAN_CTRL_FULLSPEED:\n\t\tvalue = 1;\n\t\tbreak;\n\tcase ASUS_FAN_CTRL_AUTO:\n\t\tvalue = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = asus_wmi_set_devstate(ASUS_WMI_DEVID_MID_FAN_CTRL,\n\t\t\t\t    value, &retval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (retval != 1)\n\t\treturn -EIO;\n\n\tasus->mid_fan_pwm_mode = state;\n\treturn count;\n}\n\n \nstatic DEVICE_ATTR_RW(pwm1);\nstatic DEVICE_ATTR_RW(pwm1_enable);\nstatic DEVICE_ATTR_RO(fan1_input);\nstatic DEVICE_ATTR_RO(fan1_label);\n \nstatic DEVICE_ATTR_RW(pwm2_enable);\nstatic DEVICE_ATTR_RO(fan2_input);\nstatic DEVICE_ATTR_RO(fan2_label);\n \nstatic DEVICE_ATTR_RW(pwm3_enable);\nstatic DEVICE_ATTR_RO(fan3_input);\nstatic DEVICE_ATTR_RO(fan3_label);\n\n \nstatic DEVICE_ATTR(temp1_input, S_IRUGO, asus_hwmon_temp1, NULL);\n\nstatic struct attribute *hwmon_attributes[] = {\n\t&dev_attr_pwm1.attr,\n\t&dev_attr_pwm1_enable.attr,\n\t&dev_attr_pwm2_enable.attr,\n\t&dev_attr_pwm3_enable.attr,\n\t&dev_attr_fan1_input.attr,\n\t&dev_attr_fan1_label.attr,\n\t&dev_attr_fan2_input.attr,\n\t&dev_attr_fan2_label.attr,\n\t&dev_attr_fan3_input.attr,\n\t&dev_attr_fan3_label.attr,\n\n\t&dev_attr_temp1_input.attr,\n\tNULL\n};\n\nstatic umode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct asus_wmi *asus = dev_get_drvdata(dev->parent);\n\tu32 value = ASUS_WMI_UNSUPPORTED_METHOD;\n\n\tif (attr == &dev_attr_pwm1.attr) {\n\t\tif (asus->fan_type != FAN_TYPE_AGFN)\n\t\t\treturn 0;\n\t} else if (attr == &dev_attr_fan1_input.attr\n\t    || attr == &dev_attr_fan1_label.attr\n\t    || attr == &dev_attr_pwm1_enable.attr) {\n\t\tif (asus->fan_type == FAN_TYPE_NONE)\n\t\t\treturn 0;\n\t} else if (attr == &dev_attr_fan2_input.attr\n\t    || attr == &dev_attr_fan2_label.attr\n\t    || attr == &dev_attr_pwm2_enable.attr) {\n\t\tif (asus->gpu_fan_type == FAN_TYPE_NONE)\n\t\t\treturn 0;\n\t} else if (attr == &dev_attr_fan3_input.attr\n\t    || attr == &dev_attr_fan3_label.attr\n\t    || attr == &dev_attr_pwm3_enable.attr) {\n\t\tif (asus->mid_fan_type == FAN_TYPE_NONE)\n\t\t\treturn 0;\n\t} else if (attr == &dev_attr_temp1_input.attr) {\n\t\tint err = asus_wmi_get_devstate(asus,\n\t\t\t\t\t\tASUS_WMI_DEVID_THERMAL_CTRL,\n\t\t\t\t\t\t&value);\n\n\t\tif (err < 0)\n\t\t\treturn 0;  \n\n\t\t \n\t\tif (value == 0 || value == 1)\n\t\t\treturn 0;\n\t}\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group hwmon_attribute_group = {\n\t.is_visible = asus_hwmon_sysfs_is_visible,\n\t.attrs = hwmon_attributes\n};\n__ATTRIBUTE_GROUPS(hwmon_attribute);\n\nstatic int asus_wmi_hwmon_init(struct asus_wmi *asus)\n{\n\tstruct device *dev = &asus->platform_device->dev;\n\tstruct device *hwmon;\n\n\thwmon = devm_hwmon_device_register_with_groups(dev, \"asus\", asus,\n\t\t\thwmon_attribute_groups);\n\n\tif (IS_ERR(hwmon)) {\n\t\tpr_err(\"Could not register asus hwmon device\\n\");\n\t\treturn PTR_ERR(hwmon);\n\t}\n\treturn 0;\n}\n\nstatic int asus_wmi_fan_init(struct asus_wmi *asus)\n{\n\tasus->gpu_fan_type = FAN_TYPE_NONE;\n\tasus->mid_fan_type = FAN_TYPE_NONE;\n\tasus->fan_type = FAN_TYPE_NONE;\n\tasus->agfn_pwm = -1;\n\n\tif (asus->driver->quirks->wmi_ignore_fan)\n\t\tasus->fan_type = FAN_TYPE_NONE;\n\telse if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_CPU_FAN_CTRL))\n\t\tasus->fan_type = FAN_TYPE_SPEC83;\n\telse if (asus_wmi_has_agfn_fan(asus))\n\t\tasus->fan_type = FAN_TYPE_AGFN;\n\n\t \n\tif (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_GPU_FAN_CTRL))\n\t\tasus->gpu_fan_type = FAN_TYPE_SPEC83;\n\n\t \n\tif (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_MID_FAN_CTRL))\n\t\tasus->mid_fan_type = FAN_TYPE_SPEC83;\n\n\tif (asus->fan_type == FAN_TYPE_NONE)\n\t\treturn -ENODEV;\n\n\tasus_fan_set_auto(asus);\n\tasus->fan_pwm_mode = ASUS_FAN_CTRL_AUTO;\n\treturn 0;\n}\n\n \n\nstatic int fan_boost_mode_check_present(struct asus_wmi *asus)\n{\n\tu32 result;\n\tint err;\n\n\tasus->fan_boost_mode_available = false;\n\n\terr = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_BOOST_MODE,\n\t\t\t\t    &result);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn err;\n\t}\n\n\tif ((result & ASUS_WMI_DSTS_PRESENCE_BIT) &&\n\t\t\t(result & ASUS_FAN_BOOST_MODES_MASK)) {\n\t\tasus->fan_boost_mode_available = true;\n\t\tasus->fan_boost_mode_mask = result & ASUS_FAN_BOOST_MODES_MASK;\n\t}\n\n\treturn 0;\n}\n\nstatic int fan_boost_mode_write(struct asus_wmi *asus)\n{\n\tu32 retval;\n\tu8 value;\n\tint err;\n\n\tvalue = asus->fan_boost_mode;\n\n\tpr_info(\"Set fan boost mode: %u\\n\", value);\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_FAN_BOOST_MODE, value,\n\t\t\t\t    &retval);\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL,\n\t\t\t\"fan_boost_mode\");\n\n\tif (err) {\n\t\tpr_warn(\"Failed to set fan boost mode: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (retval != 1) {\n\t\tpr_warn(\"Failed to set fan boost mode (retval): 0x%x\\n\",\n\t\t\tretval);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int fan_boost_mode_switch_next(struct asus_wmi *asus)\n{\n\tu8 mask = asus->fan_boost_mode_mask;\n\n\tif (asus->fan_boost_mode == ASUS_FAN_BOOST_MODE_NORMAL) {\n\t\tif (mask & ASUS_FAN_BOOST_MODE_OVERBOOST_MASK)\n\t\t\tasus->fan_boost_mode = ASUS_FAN_BOOST_MODE_OVERBOOST;\n\t\telse if (mask & ASUS_FAN_BOOST_MODE_SILENT_MASK)\n\t\t\tasus->fan_boost_mode = ASUS_FAN_BOOST_MODE_SILENT;\n\t} else if (asus->fan_boost_mode == ASUS_FAN_BOOST_MODE_OVERBOOST) {\n\t\tif (mask & ASUS_FAN_BOOST_MODE_SILENT_MASK)\n\t\t\tasus->fan_boost_mode = ASUS_FAN_BOOST_MODE_SILENT;\n\t\telse\n\t\t\tasus->fan_boost_mode = ASUS_FAN_BOOST_MODE_NORMAL;\n\t} else {\n\t\tasus->fan_boost_mode = ASUS_FAN_BOOST_MODE_NORMAL;\n\t}\n\n\treturn fan_boost_mode_write(asus);\n}\n\nstatic ssize_t fan_boost_mode_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", asus->fan_boost_mode);\n}\n\nstatic ssize_t fan_boost_mode_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tu8 mask = asus->fan_boost_mode_mask;\n\tu8 new_mode;\n\tint result;\n\n\tresult = kstrtou8(buf, 10, &new_mode);\n\tif (result < 0) {\n\t\tpr_warn(\"Trying to store invalid value\\n\");\n\t\treturn result;\n\t}\n\n\tif (new_mode == ASUS_FAN_BOOST_MODE_OVERBOOST) {\n\t\tif (!(mask & ASUS_FAN_BOOST_MODE_OVERBOOST_MASK))\n\t\t\treturn -EINVAL;\n\t} else if (new_mode == ASUS_FAN_BOOST_MODE_SILENT) {\n\t\tif (!(mask & ASUS_FAN_BOOST_MODE_SILENT_MASK))\n\t\t\treturn -EINVAL;\n\t} else if (new_mode != ASUS_FAN_BOOST_MODE_NORMAL) {\n\t\treturn -EINVAL;\n\t}\n\n\tasus->fan_boost_mode = new_mode;\n\tfan_boost_mode_write(asus);\n\n\treturn count;\n}\n\n \nstatic DEVICE_ATTR_RW(fan_boost_mode);\n\n \n\nstatic void fan_curve_copy_from_buf(struct fan_curve_data *data, u8 *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < FAN_CURVE_POINTS; i++) {\n\t\tdata->temps[i] = buf[i];\n\t}\n\n\tfor (i = 0; i < FAN_CURVE_POINTS; i++) {\n\t\tdata->percents[i] =\n\t\t\t255 * buf[i + FAN_CURVE_POINTS] / 100;\n\t}\n}\n\nstatic int fan_curve_get_factory_default(struct asus_wmi *asus, u32 fan_dev)\n{\n\tstruct fan_curve_data *curves;\n\tu8 buf[FAN_CURVE_BUF_LEN];\n\tint err, fan_idx;\n\tu8 mode = 0;\n\n\tif (asus->throttle_thermal_policy_available)\n\t\tmode = asus->throttle_thermal_policy_mode;\n\t \n\tif (mode == 2)\n\t\tmode = 1;\n\telse if (mode == 1)\n\t\tmode = 2;\n\n\terr = asus_wmi_evaluate_method_buf(asus->dsts_id, fan_dev, mode, buf,\n\t\t\t\t\t   FAN_CURVE_BUF_LEN);\n\tif (err) {\n\t\tpr_warn(\"%s (0x%08x) failed: %d\\n\", __func__, fan_dev, err);\n\t\treturn err;\n\t}\n\n\tfan_idx = FAN_CURVE_DEV_CPU;\n\tif (fan_dev == ASUS_WMI_DEVID_GPU_FAN_CURVE)\n\t\tfan_idx = FAN_CURVE_DEV_GPU;\n\n\tif (fan_dev == ASUS_WMI_DEVID_MID_FAN_CURVE)\n\t\tfan_idx = FAN_CURVE_DEV_MID;\n\n\tcurves = &asus->custom_fan_curves[fan_idx];\n\tcurves->device_id = fan_dev;\n\n\tfan_curve_copy_from_buf(curves, buf);\n\treturn 0;\n}\n\n \nstatic int fan_curve_check_present(struct asus_wmi *asus, bool *available,\n\t\t\t\t   u32 fan_dev)\n{\n\tint err;\n\n\t*available = false;\n\n\tif (asus->fan_type == FAN_TYPE_NONE)\n\t\treturn 0;\n\n\terr = fan_curve_get_factory_default(asus, fan_dev);\n\tif (err) {\n\t\treturn 0;\n\t}\n\n\t*available = true;\n\treturn 0;\n}\n\n \nstatic struct fan_curve_data *fan_curve_attr_select(struct asus_wmi *asus,\n\t\t\t\t\t      struct device_attribute *attr)\n{\n\tint index = to_sensor_dev_attr(attr)->index;\n\n\treturn &asus->custom_fan_curves[index];\n}\n\n \nstatic struct fan_curve_data *fan_curve_attr_2_select(struct asus_wmi *asus,\n\t\t\t\t\t    struct device_attribute *attr)\n{\n\tint nr = to_sensor_dev_attr_2(attr)->nr;\n\n\treturn &asus->custom_fan_curves[nr & ~FAN_CURVE_PWM_MASK];\n}\n\nstatic ssize_t fan_curve_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct sensor_device_attribute_2 *dev_attr = to_sensor_dev_attr_2(attr);\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tstruct fan_curve_data *data;\n\tint value, pwm, index;\n\n\tdata = fan_curve_attr_2_select(asus, attr);\n\tpwm = dev_attr->nr & FAN_CURVE_PWM_MASK;\n\tindex = dev_attr->index;\n\n\tif (pwm)\n\t\tvalue = data->percents[index];\n\telse\n\t\tvalue = data->temps[index];\n\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\n \nstatic int fan_curve_write(struct asus_wmi *asus,\n\t\t\t   struct fan_curve_data *data)\n{\n\tu32 arg1 = 0, arg2 = 0, arg3 = 0, arg4 = 0;\n\tu8 *percents = data->percents;\n\tu8 *temps = data->temps;\n\tint ret, i, shift = 0;\n\n\tif (!data->enabled)\n\t\treturn 0;\n\n\tfor (i = 0; i < FAN_CURVE_POINTS / 2; i++) {\n\t\targ1 += (temps[i]) << shift;\n\t\targ2 += (temps[i + 4]) << shift;\n\t\t \n\t\targ3 += (100 * percents[i] / 255) << shift;\n\t\targ4 += (100 * percents[i + 4] / 255) << shift;\n\t\tshift += 8;\n\t}\n\n\treturn asus_wmi_evaluate_method5(ASUS_WMI_METHODID_DEVS,\n\t\t\t\t\t data->device_id,\n\t\t\t\t\t arg1, arg2, arg3, arg4, &ret);\n}\n\nstatic ssize_t fan_curve_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct sensor_device_attribute_2 *dev_attr = to_sensor_dev_attr_2(attr);\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tstruct fan_curve_data *data;\n\tint err, pwm, index;\n\tu8 value;\n\n\tdata = fan_curve_attr_2_select(asus, attr);\n\tpwm = dev_attr->nr & FAN_CURVE_PWM_MASK;\n\tindex = dev_attr->index;\n\n\terr = kstrtou8(buf, 10, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (pwm)\n\t\tdata->percents[index] = value;\n\telse\n\t\tdata->temps[index] = value;\n\n\t \n\tdata->enabled = false;\n\n\treturn count;\n}\n\nstatic ssize_t fan_curve_enable_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tstruct fan_curve_data *data;\n\tint out = 2;\n\n\tdata = fan_curve_attr_select(asus, attr);\n\n\tif (data->enabled)\n\t\tout = 1;\n\n\treturn sysfs_emit(buf, \"%d\\n\", out);\n}\n\nstatic ssize_t fan_curve_enable_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tstruct fan_curve_data *data;\n\tint value, err;\n\n\tdata = fan_curve_attr_select(asus, attr);\n\n\terr = kstrtoint(buf, 10, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (value) {\n\tcase 1:\n\t\tdata->enabled = true;\n\t\tbreak;\n\tcase 2:\n\t\tdata->enabled = false;\n\t\tbreak;\n\t \n\tcase 3:\n\t\terr = fan_curve_get_factory_default(asus, data->device_id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata->enabled = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (data->enabled) {\n\t\terr = fan_curve_write(asus, data);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\t \n\t\tif (asus->throttle_thermal_policy_available) {\n\t\t\terr = throttle_thermal_policy_write(asus);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t \n\t\t} else if (asus->fan_type == FAN_TYPE_SPEC83) {\n\t\t\terr = asus_fan_set_auto(asus);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\t \n\t\t\terr = fan_curve_get_factory_default(asus, data->device_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = fan_curve_write(asus, data);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn count;\n}\n\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm1_enable, fan_curve_enable, FAN_CURVE_DEV_CPU);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point1_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point2_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point3_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point4_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point5_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point6_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point7_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU, 6);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point8_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU, 7);\n\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point1_pwm, fan_curve,\n\t\t\t\tFAN_CURVE_DEV_CPU | FAN_CURVE_PWM_MASK, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point2_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU | FAN_CURVE_PWM_MASK, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point3_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU | FAN_CURVE_PWM_MASK, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point4_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU | FAN_CURVE_PWM_MASK, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point5_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU | FAN_CURVE_PWM_MASK, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point6_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU | FAN_CURVE_PWM_MASK, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point7_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU | FAN_CURVE_PWM_MASK, 6);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point8_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_CPU | FAN_CURVE_PWM_MASK, 7);\n\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm2_enable, fan_curve_enable, FAN_CURVE_DEV_GPU);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point1_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point2_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point3_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point4_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point5_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point6_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point7_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU, 6);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point8_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU, 7);\n\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point1_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU | FAN_CURVE_PWM_MASK, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point2_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU | FAN_CURVE_PWM_MASK, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point3_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU | FAN_CURVE_PWM_MASK, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point4_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU | FAN_CURVE_PWM_MASK, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point5_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU | FAN_CURVE_PWM_MASK, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point6_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU | FAN_CURVE_PWM_MASK, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point7_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU | FAN_CURVE_PWM_MASK, 6);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point8_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_GPU | FAN_CURVE_PWM_MASK, 7);\n\n \nstatic SENSOR_DEVICE_ATTR_RW(pwm3_enable, fan_curve_enable, FAN_CURVE_DEV_MID);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point1_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point2_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point3_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point4_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point5_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point6_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point7_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID, 6);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point8_temp, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID, 7);\n\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point1_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID | FAN_CURVE_PWM_MASK, 0);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point2_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID | FAN_CURVE_PWM_MASK, 1);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point3_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID | FAN_CURVE_PWM_MASK, 2);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point4_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID | FAN_CURVE_PWM_MASK, 3);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point5_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID | FAN_CURVE_PWM_MASK, 4);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point6_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID | FAN_CURVE_PWM_MASK, 5);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point7_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID | FAN_CURVE_PWM_MASK, 6);\nstatic SENSOR_DEVICE_ATTR_2_RW(pwm3_auto_point8_pwm, fan_curve,\n\t\t\t       FAN_CURVE_DEV_MID | FAN_CURVE_PWM_MASK, 7);\n\nstatic struct attribute *asus_fan_curve_attr[] = {\n\t \n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point5_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point6_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point7_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point8_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point3_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point4_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point5_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point6_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point7_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_auto_point8_pwm.dev_attr.attr,\n\t \n\t&sensor_dev_attr_pwm2_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point4_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point5_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point6_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point7_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point8_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point3_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point4_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point5_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point6_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point7_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm2_auto_point8_pwm.dev_attr.attr,\n\t \n\t&sensor_dev_attr_pwm3_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point2_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point3_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point4_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point5_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point6_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point7_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point8_temp.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point2_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point3_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point4_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point5_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point6_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point7_pwm.dev_attr.attr,\n\t&sensor_dev_attr_pwm3_auto_point8_pwm.dev_attr.attr,\n\tNULL\n};\n\nstatic umode_t asus_fan_curve_is_visible(struct kobject *kobj,\n\t\t\t\t\t struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct asus_wmi *asus = dev_get_drvdata(dev->parent);\n\n\t \n\tif (asus->cpu_fan_curve_available && attr->name[3] == '1')\n\t\treturn 0644;\n\n\tif (asus->gpu_fan_curve_available && attr->name[3] == '2')\n\t\treturn 0644;\n\n\tif (asus->mid_fan_curve_available && attr->name[3] == '3')\n\t\treturn 0644;\n\n\treturn 0;\n}\n\nstatic const struct attribute_group asus_fan_curve_attr_group = {\n\t.is_visible = asus_fan_curve_is_visible,\n\t.attrs = asus_fan_curve_attr,\n};\n__ATTRIBUTE_GROUPS(asus_fan_curve_attr);\n\n \nstatic int asus_wmi_custom_fan_curve_init(struct asus_wmi *asus)\n{\n\tstruct device *dev = &asus->platform_device->dev;\n\tstruct device *hwmon;\n\tint err;\n\n\terr = fan_curve_check_present(asus, &asus->cpu_fan_curve_available,\n\t\t\t\t      ASUS_WMI_DEVID_CPU_FAN_CURVE);\n\tif (err)\n\t\treturn err;\n\n\terr = fan_curve_check_present(asus, &asus->gpu_fan_curve_available,\n\t\t\t\t      ASUS_WMI_DEVID_GPU_FAN_CURVE);\n\tif (err)\n\t\treturn err;\n\n\terr = fan_curve_check_present(asus, &asus->mid_fan_curve_available,\n\t\t\t\t      ASUS_WMI_DEVID_MID_FAN_CURVE);\n\tif (err)\n\t\treturn err;\n\n\tif (!asus->cpu_fan_curve_available\n\t\t&& !asus->gpu_fan_curve_available\n\t\t&& !asus->mid_fan_curve_available)\n\t\treturn 0;\n\n\thwmon = devm_hwmon_device_register_with_groups(\n\t\tdev, \"asus_custom_fan_curve\", asus, asus_fan_curve_attr_groups);\n\n\tif (IS_ERR(hwmon)) {\n\t\tdev_err(dev,\n\t\t\t\"Could not register asus_custom_fan_curve device\\n\");\n\t\treturn PTR_ERR(hwmon);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int throttle_thermal_policy_check_present(struct asus_wmi *asus)\n{\n\tu32 result;\n\tint err;\n\n\tasus->throttle_thermal_policy_available = false;\n\n\terr = asus_wmi_get_devstate(asus,\n\t\t\t\t    ASUS_WMI_DEVID_THROTTLE_THERMAL_POLICY,\n\t\t\t\t    &result);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tif (result & ASUS_WMI_DSTS_PRESENCE_BIT)\n\t\tasus->throttle_thermal_policy_available = true;\n\n\treturn 0;\n}\n\nstatic int throttle_thermal_policy_write(struct asus_wmi *asus)\n{\n\tint err;\n\tu8 value;\n\tu32 retval;\n\n\tvalue = asus->throttle_thermal_policy_mode;\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_THROTTLE_THERMAL_POLICY,\n\t\t\t\t    value, &retval);\n\n\tsysfs_notify(&asus->platform_device->dev.kobj, NULL,\n\t\t\t\"throttle_thermal_policy\");\n\n\tif (err) {\n\t\tpr_warn(\"Failed to set throttle thermal policy: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (retval != 1) {\n\t\tpr_warn(\"Failed to set throttle thermal policy (retval): 0x%x\\n\",\n\t\t\tretval);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (asus->cpu_fan_curve_available)\n\t\tasus->custom_fan_curves[FAN_CURVE_DEV_CPU].enabled = false;\n\tif (asus->gpu_fan_curve_available)\n\t\tasus->custom_fan_curves[FAN_CURVE_DEV_GPU].enabled = false;\n\tif (asus->mid_fan_curve_available)\n\t\tasus->custom_fan_curves[FAN_CURVE_DEV_MID].enabled = false;\n\n\treturn 0;\n}\n\nstatic int throttle_thermal_policy_set_default(struct asus_wmi *asus)\n{\n\tif (!asus->throttle_thermal_policy_available)\n\t\treturn 0;\n\n\tasus->throttle_thermal_policy_mode = ASUS_THROTTLE_THERMAL_POLICY_DEFAULT;\n\treturn throttle_thermal_policy_write(asus);\n}\n\nstatic int throttle_thermal_policy_switch_next(struct asus_wmi *asus)\n{\n\tu8 new_mode = asus->throttle_thermal_policy_mode + 1;\n\tint err;\n\n\tif (new_mode > ASUS_THROTTLE_THERMAL_POLICY_SILENT)\n\t\tnew_mode = ASUS_THROTTLE_THERMAL_POLICY_DEFAULT;\n\n\tasus->throttle_thermal_policy_mode = new_mode;\n\terr = throttle_thermal_policy_write(asus);\n\tif (err)\n\t\treturn err;\n\n\t \n\tplatform_profile_notify();\n\n\treturn 0;\n}\n\nstatic ssize_t throttle_thermal_policy_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tu8 mode = asus->throttle_thermal_policy_mode;\n\n\treturn sysfs_emit(buf, \"%d\\n\", mode);\n}\n\nstatic ssize_t throttle_thermal_policy_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tu8 new_mode;\n\tint result;\n\tint err;\n\n\tresult = kstrtou8(buf, 10, &new_mode);\n\tif (result < 0)\n\t\treturn result;\n\n\tif (new_mode > ASUS_THROTTLE_THERMAL_POLICY_SILENT)\n\t\treturn -EINVAL;\n\n\tasus->throttle_thermal_policy_mode = new_mode;\n\terr = throttle_thermal_policy_write(asus);\n\tif (err)\n\t\treturn err;\n\n\t \n\tplatform_profile_notify();\n\n\treturn count;\n}\n\n\nstatic DEVICE_ATTR_RW(throttle_thermal_policy);\n\n \nstatic int asus_wmi_platform_profile_get(struct platform_profile_handler *pprof,\n\t\t\t\t\tenum platform_profile_option *profile)\n{\n\tstruct asus_wmi *asus;\n\tint tp;\n\n\tasus = container_of(pprof, struct asus_wmi, platform_profile_handler);\n\n\ttp = asus->throttle_thermal_policy_mode;\n\n\tswitch (tp) {\n\tcase ASUS_THROTTLE_THERMAL_POLICY_DEFAULT:\n\t\t*profile = PLATFORM_PROFILE_BALANCED;\n\t\tbreak;\n\tcase ASUS_THROTTLE_THERMAL_POLICY_OVERBOOST:\n\t\t*profile = PLATFORM_PROFILE_PERFORMANCE;\n\t\tbreak;\n\tcase ASUS_THROTTLE_THERMAL_POLICY_SILENT:\n\t\t*profile = PLATFORM_PROFILE_QUIET;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int asus_wmi_platform_profile_set(struct platform_profile_handler *pprof,\n\t\t\t\t\tenum platform_profile_option profile)\n{\n\tstruct asus_wmi *asus;\n\tint tp;\n\n\tasus = container_of(pprof, struct asus_wmi, platform_profile_handler);\n\n\tswitch (profile) {\n\tcase PLATFORM_PROFILE_PERFORMANCE:\n\t\ttp = ASUS_THROTTLE_THERMAL_POLICY_OVERBOOST;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_BALANCED:\n\t\ttp = ASUS_THROTTLE_THERMAL_POLICY_DEFAULT;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_QUIET:\n\t\ttp = ASUS_THROTTLE_THERMAL_POLICY_SILENT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tasus->throttle_thermal_policy_mode = tp;\n\treturn throttle_thermal_policy_write(asus);\n}\n\nstatic int platform_profile_setup(struct asus_wmi *asus)\n{\n\tstruct device *dev = &asus->platform_device->dev;\n\tint err;\n\n\t \n\tif (!asus->throttle_thermal_policy_available)\n\t\treturn 0;\n\n\tdev_info(dev, \"Using throttle_thermal_policy for platform_profile support\\n\");\n\n\tasus->platform_profile_handler.profile_get = asus_wmi_platform_profile_get;\n\tasus->platform_profile_handler.profile_set = asus_wmi_platform_profile_set;\n\n\tset_bit(PLATFORM_PROFILE_QUIET, asus->platform_profile_handler.choices);\n\tset_bit(PLATFORM_PROFILE_BALANCED,\n\t\tasus->platform_profile_handler.choices);\n\tset_bit(PLATFORM_PROFILE_PERFORMANCE,\n\t\tasus->platform_profile_handler.choices);\n\n\terr = platform_profile_register(&asus->platform_profile_handler);\n\tif (err)\n\t\treturn err;\n\n\tasus->platform_profile_support = true;\n\treturn 0;\n}\n\n \n\nstatic int read_backlight_power(struct asus_wmi *asus)\n{\n\tint ret;\n\n\tif (asus->driver->quirks->store_backlight_power)\n\t\tret = !asus->driver->panel_power;\n\telse\n\t\tret = asus_wmi_get_devstate_simple(asus,\n\t\t\t\t\t\t   ASUS_WMI_DEVID_BACKLIGHT);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;\n}\n\nstatic int read_brightness_max(struct asus_wmi *asus)\n{\n\tu32 retval;\n\tint err;\n\n\terr = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_BRIGHTNESS, &retval);\n\tif (err < 0)\n\t\treturn err;\n\n\tretval = retval & ASUS_WMI_DSTS_MAX_BRIGTH_MASK;\n\tretval >>= 8;\n\n\tif (!retval)\n\t\treturn -ENODEV;\n\n\treturn retval;\n}\n\nstatic int read_brightness(struct backlight_device *bd)\n{\n\tstruct asus_wmi *asus = bl_get_data(bd);\n\tu32 retval;\n\tint err;\n\n\terr = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_BRIGHTNESS, &retval);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn retval & ASUS_WMI_DSTS_BRIGHTNESS_MASK;\n}\n\nstatic u32 get_scalar_command(struct backlight_device *bd)\n{\n\tstruct asus_wmi *asus = bl_get_data(bd);\n\tu32 ctrl_param = 0;\n\n\tif ((asus->driver->brightness < bd->props.brightness) ||\n\t    bd->props.brightness == bd->props.max_brightness)\n\t\tctrl_param = 0x00008001;\n\telse if ((asus->driver->brightness > bd->props.brightness) ||\n\t\t bd->props.brightness == 0)\n\t\tctrl_param = 0x00008000;\n\n\tasus->driver->brightness = bd->props.brightness;\n\n\treturn ctrl_param;\n}\n\nstatic int update_bl_status(struct backlight_device *bd)\n{\n\tstruct asus_wmi *asus = bl_get_data(bd);\n\tu32 ctrl_param;\n\tint power, err = 0;\n\n\tpower = read_backlight_power(asus);\n\tif (power != -ENODEV && bd->props.power != power) {\n\t\tctrl_param = !!(bd->props.power == FB_BLANK_UNBLANK);\n\t\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT,\n\t\t\t\t\t    ctrl_param, NULL);\n\t\tif (asus->driver->quirks->store_backlight_power)\n\t\t\tasus->driver->panel_power = bd->props.power;\n\n\t\t \n\t\tif (asus->driver->quirks->scalar_panel_brightness)\n\t\t\treturn err;\n\t}\n\n\tif (asus->driver->quirks->scalar_panel_brightness)\n\t\tctrl_param = get_scalar_command(bd);\n\telse\n\t\tctrl_param = bd->props.brightness;\n\n\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_BRIGHTNESS,\n\t\t\t\t    ctrl_param, NULL);\n\n\treturn err;\n}\n\nstatic const struct backlight_ops asus_wmi_bl_ops = {\n\t.get_brightness = read_brightness,\n\t.update_status = update_bl_status,\n};\n\nstatic int asus_wmi_backlight_notify(struct asus_wmi *asus, int code)\n{\n\tstruct backlight_device *bd = asus->backlight_device;\n\tint old = bd->props.brightness;\n\tint new = old;\n\n\tif (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)\n\t\tnew = code - NOTIFY_BRNUP_MIN + 1;\n\telse if (code >= NOTIFY_BRNDOWN_MIN && code <= NOTIFY_BRNDOWN_MAX)\n\t\tnew = code - NOTIFY_BRNDOWN_MIN;\n\n\tbd->props.brightness = new;\n\tbacklight_update_status(bd);\n\tbacklight_force_update(bd, BACKLIGHT_UPDATE_HOTKEY);\n\n\treturn old;\n}\n\nstatic int asus_wmi_backlight_init(struct asus_wmi *asus)\n{\n\tstruct backlight_device *bd;\n\tstruct backlight_properties props;\n\tint max;\n\tint power;\n\n\tmax = read_brightness_max(asus);\n\tif (max < 0)\n\t\treturn max;\n\n\tpower = read_backlight_power(asus);\n\tif (power == -ENODEV)\n\t\tpower = FB_BLANK_UNBLANK;\n\telse if (power < 0)\n\t\treturn power;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = max;\n\tbd = backlight_device_register(asus->driver->name,\n\t\t\t\t       &asus->platform_device->dev, asus,\n\t\t\t\t       &asus_wmi_bl_ops, &props);\n\tif (IS_ERR(bd)) {\n\t\tpr_err(\"Could not register backlight device\\n\");\n\t\treturn PTR_ERR(bd);\n\t}\n\n\tasus->backlight_device = bd;\n\n\tif (asus->driver->quirks->store_backlight_power)\n\t\tasus->driver->panel_power = power;\n\n\tbd->props.brightness = read_brightness(bd);\n\tbd->props.power = power;\n\tbacklight_update_status(bd);\n\n\tasus->driver->brightness = bd->props.brightness;\n\n\treturn 0;\n}\n\nstatic void asus_wmi_backlight_exit(struct asus_wmi *asus)\n{\n\tbacklight_device_unregister(asus->backlight_device);\n\n\tasus->backlight_device = NULL;\n}\n\nstatic int is_display_toggle(int code)\n{\n\t \n\tif ((code >= 0x61 && code <= 0x67) ||\n\t    (code >= 0x8c && code <= 0x93) ||\n\t    (code >= 0xa0 && code <= 0xa7) ||\n\t    (code >= 0xd0 && code <= 0xd5))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \n\nstatic bool asus_wmi_has_fnlock_key(struct asus_wmi *asus)\n{\n\tu32 result;\n\n\tasus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FNLOCK, &result);\n\n\treturn (result & ASUS_WMI_DSTS_PRESENCE_BIT) &&\n\t\t!(result & ASUS_WMI_FNLOCK_BIOS_DISABLED);\n}\n\nstatic void asus_wmi_fnlock_update(struct asus_wmi *asus)\n{\n\tint mode = asus->fnlock_locked;\n\n\tasus_wmi_set_devstate(ASUS_WMI_DEVID_FNLOCK, mode, NULL);\n}\n\n \n\nstatic int asus_wmi_get_event_code(u32 value)\n{\n\tstruct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tint code;\n\n\tstatus = wmi_get_event_data(value, &response);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_warn(\"Failed to get WMI notify code: %s\\n\",\n\t\t\t\tacpi_format_exception(status));\n\t\treturn -EIO;\n\t}\n\n\tobj = (union acpi_object *)response.pointer;\n\n\tif (obj && obj->type == ACPI_TYPE_INTEGER)\n\t\tcode = (int)(obj->integer.value & WMI_EVENT_MASK);\n\telse\n\t\tcode = -EIO;\n\n\tkfree(obj);\n\treturn code;\n}\n\nstatic void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)\n{\n\tunsigned int key_value = 1;\n\tbool autorelease = 1;\n\n\tif (asus->driver->key_filter) {\n\t\tasus->driver->key_filter(asus->driver, &code, &key_value,\n\t\t\t\t\t &autorelease);\n\t\tif (code == ASUS_WMI_KEY_IGNORE)\n\t\t\treturn;\n\t}\n\n\tif (acpi_video_get_backlight_type() == acpi_backlight_vendor &&\n\t    code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNDOWN_MAX) {\n\t\tasus_wmi_backlight_notify(asus, code);\n\t\treturn;\n\t}\n\n\tif (code == NOTIFY_KBD_BRTUP) {\n\t\tkbd_led_set_by_kbd(asus, asus->kbd_led_wk + 1);\n\t\treturn;\n\t}\n\tif (code == NOTIFY_KBD_BRTDWN) {\n\t\tkbd_led_set_by_kbd(asus, asus->kbd_led_wk - 1);\n\t\treturn;\n\t}\n\tif (code == NOTIFY_KBD_BRTTOGGLE) {\n\t\tif (asus->kbd_led_wk == asus->kbd_led.max_brightness)\n\t\t\tkbd_led_set_by_kbd(asus, 0);\n\t\telse\n\t\t\tkbd_led_set_by_kbd(asus, asus->kbd_led_wk + 1);\n\t\treturn;\n\t}\n\n\tif (code == NOTIFY_FNLOCK_TOGGLE) {\n\t\tasus->fnlock_locked = !asus->fnlock_locked;\n\t\tasus_wmi_fnlock_update(asus);\n\t\treturn;\n\t}\n\n\tif (code == asus->tablet_switch_event_code) {\n\t\tasus_wmi_tablet_mode_get_state(asus);\n\t\treturn;\n\t}\n\n\tif (code == NOTIFY_KBD_FBM || code == NOTIFY_KBD_TTP) {\n\t\tif (asus->fan_boost_mode_available)\n\t\t\tfan_boost_mode_switch_next(asus);\n\t\tif (asus->throttle_thermal_policy_available)\n\t\t\tthrottle_thermal_policy_switch_next(asus);\n\t\treturn;\n\n\t}\n\n\tif (is_display_toggle(code) && asus->driver->quirks->no_display_toggle)\n\t\treturn;\n\n\tif (!sparse_keymap_report_event(asus->inputdev, code,\n\t\t\t\t\tkey_value, autorelease))\n\t\tpr_info(\"Unknown key code 0x%x\\n\", code);\n}\n\nstatic void asus_wmi_notify(u32 value, void *context)\n{\n\tstruct asus_wmi *asus = context;\n\tint code;\n\tint i;\n\n\tfor (i = 0; i < WMI_EVENT_QUEUE_SIZE + 1; i++) {\n\t\tcode = asus_wmi_get_event_code(value);\n\t\tif (code < 0) {\n\t\t\tpr_warn(\"Failed to get notify code: %d\\n\", code);\n\t\t\treturn;\n\t\t}\n\n\t\tif (code == WMI_EVENT_QUEUE_END || code == WMI_EVENT_MASK)\n\t\t\treturn;\n\n\t\tasus_wmi_handle_event_code(code, asus);\n\n\t\t \n\t\tif (!asus->wmi_event_queue || value != WMI_EVENT_VALUE_ATK)\n\t\t\treturn;\n\t}\n\n\tpr_warn(\"Failed to process event queue, last code: 0x%x\\n\", code);\n}\n\nstatic int asus_wmi_notify_queue_flush(struct asus_wmi *asus)\n{\n\tint code;\n\tint i;\n\n\tfor (i = 0; i < WMI_EVENT_QUEUE_SIZE + 1; i++) {\n\t\tcode = asus_wmi_get_event_code(WMI_EVENT_VALUE_ATK);\n\t\tif (code < 0) {\n\t\t\tpr_warn(\"Failed to get event during flush: %d\\n\", code);\n\t\t\treturn code;\n\t\t}\n\n\t\tif (code == WMI_EVENT_QUEUE_END || code == WMI_EVENT_MASK)\n\t\t\treturn 0;\n\t}\n\n\tpr_warn(\"Failed to flush event queue\\n\");\n\treturn -EIO;\n}\n\n \n\nstatic ssize_t store_sys_wmi(struct asus_wmi *asus, int devid,\n\t\t\t     const char *buf, size_t count)\n{\n\tu32 retval;\n\tint err, value;\n\n\tvalue = asus_wmi_get_devstate_simple(asus, devid);\n\tif (value < 0)\n\t\treturn value;\n\n\terr = kstrtoint(buf, 0, &value);\n\tif (err)\n\t\treturn err;\n\n\terr = asus_wmi_set_devstate(devid, value, &retval);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic ssize_t show_sys_wmi(struct asus_wmi *asus, int devid, char *buf)\n{\n\tint value = asus_wmi_get_devstate_simple(asus, devid);\n\n\tif (value < 0)\n\t\treturn value;\n\n\treturn sprintf(buf, \"%d\\n\", value);\n}\n\n#define ASUS_WMI_CREATE_DEVICE_ATTR(_name, _mode, _cm)\t\t\t\\\n\tstatic ssize_t show_##_name(struct device *dev,\t\t\t\\\n\t\t\t\t    struct device_attribute *attr,\t\\\n\t\t\t\t    char *buf)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tstruct asus_wmi *asus = dev_get_drvdata(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\treturn show_sys_wmi(asus, _cm, buf);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic ssize_t store_##_name(struct device *dev,\t\t\\\n\t\t\t\t     struct device_attribute *attr,\t\\\n\t\t\t\t     const char *buf, size_t count)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tstruct asus_wmi *asus = dev_get_drvdata(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\treturn store_sys_wmi(asus, _cm, buf, count);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic struct device_attribute dev_attr_##_name = {\t\t\\\n\t\t.attr = {\t\t\t\t\t\t\\\n\t\t\t.name = __stringify(_name),\t\t\t\\\n\t\t\t.mode = _mode },\t\t\t\t\\\n\t\t.show   = show_##_name,\t\t\t\t\t\\\n\t\t.store  = store_##_name,\t\t\t\t\\\n\t}\n\nASUS_WMI_CREATE_DEVICE_ATTR(touchpad, 0644, ASUS_WMI_DEVID_TOUCHPAD);\nASUS_WMI_CREATE_DEVICE_ATTR(camera, 0644, ASUS_WMI_DEVID_CAMERA);\nASUS_WMI_CREATE_DEVICE_ATTR(cardr, 0644, ASUS_WMI_DEVID_CARDREADER);\nASUS_WMI_CREATE_DEVICE_ATTR(lid_resume, 0644, ASUS_WMI_DEVID_LID_RESUME);\nASUS_WMI_CREATE_DEVICE_ATTR(als_enable, 0644, ASUS_WMI_DEVID_ALS_ENABLE);\n\nstatic ssize_t cpufv_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tint value, rv;\n\n\trv = kstrtoint(buf, 0, &value);\n\tif (rv)\n\t\treturn rv;\n\n\tif (value < 0 || value > 2)\n\t\treturn -EINVAL;\n\n\trv = asus_wmi_evaluate_method(ASUS_WMI_METHODID_CFVS, value, 0, NULL);\n\tif (rv < 0)\n\t\treturn rv;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_WO(cpufv);\n\nstatic struct attribute *platform_attributes[] = {\n\t&dev_attr_cpufv.attr,\n\t&dev_attr_camera.attr,\n\t&dev_attr_cardr.attr,\n\t&dev_attr_touchpad.attr,\n\t&dev_attr_charge_mode.attr,\n\t&dev_attr_egpu_enable.attr,\n\t&dev_attr_egpu_connected.attr,\n\t&dev_attr_dgpu_disable.attr,\n\t&dev_attr_gpu_mux_mode.attr,\n\t&dev_attr_lid_resume.attr,\n\t&dev_attr_als_enable.attr,\n\t&dev_attr_fan_boost_mode.attr,\n\t&dev_attr_throttle_thermal_policy.attr,\n\t&dev_attr_ppt_pl2_sppt.attr,\n\t&dev_attr_ppt_pl1_spl.attr,\n\t&dev_attr_ppt_fppt.attr,\n\t&dev_attr_ppt_apu_sppt.attr,\n\t&dev_attr_ppt_platform_sppt.attr,\n\t&dev_attr_nv_dynamic_boost.attr,\n\t&dev_attr_nv_temp_target.attr,\n\t&dev_attr_panel_od.attr,\n\t&dev_attr_mini_led_mode.attr,\n\tNULL\n};\n\nstatic umode_t asus_sysfs_is_visible(struct kobject *kobj,\n\t\t\t\t    struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct asus_wmi *asus = dev_get_drvdata(dev);\n\tbool ok = true;\n\tint devid = -1;\n\n\tif (attr == &dev_attr_camera.attr)\n\t\tdevid = ASUS_WMI_DEVID_CAMERA;\n\telse if (attr == &dev_attr_cardr.attr)\n\t\tdevid = ASUS_WMI_DEVID_CARDREADER;\n\telse if (attr == &dev_attr_touchpad.attr)\n\t\tdevid = ASUS_WMI_DEVID_TOUCHPAD;\n\telse if (attr == &dev_attr_lid_resume.attr)\n\t\tdevid = ASUS_WMI_DEVID_LID_RESUME;\n\telse if (attr == &dev_attr_als_enable.attr)\n\t\tdevid = ASUS_WMI_DEVID_ALS_ENABLE;\n\telse if (attr == &dev_attr_charge_mode.attr)\n\t\tok = asus->charge_mode_available;\n\telse if (attr == &dev_attr_egpu_enable.attr)\n\t\tok = asus->egpu_enable_available;\n\telse if (attr == &dev_attr_egpu_connected.attr)\n\t\tok = asus->egpu_connect_available;\n\telse if (attr == &dev_attr_dgpu_disable.attr)\n\t\tok = asus->dgpu_disable_available;\n\telse if (attr == &dev_attr_gpu_mux_mode.attr)\n\t\tok = asus->gpu_mux_mode_available;\n\telse if (attr == &dev_attr_fan_boost_mode.attr)\n\t\tok = asus->fan_boost_mode_available;\n\telse if (attr == &dev_attr_throttle_thermal_policy.attr)\n\t\tok = asus->throttle_thermal_policy_available;\n\telse if (attr == &dev_attr_ppt_pl2_sppt.attr)\n\t\tok = asus->ppt_pl2_sppt_available;\n\telse if (attr == &dev_attr_ppt_pl1_spl.attr)\n\t\tok = asus->ppt_pl1_spl_available;\n\telse if (attr == &dev_attr_ppt_fppt.attr)\n\t\tok = asus->ppt_fppt_available;\n\telse if (attr == &dev_attr_ppt_apu_sppt.attr)\n\t\tok = asus->ppt_apu_sppt_available;\n\telse if (attr == &dev_attr_ppt_platform_sppt.attr)\n\t\tok = asus->ppt_plat_sppt_available;\n\telse if (attr == &dev_attr_nv_dynamic_boost.attr)\n\t\tok = asus->nv_dyn_boost_available;\n\telse if (attr == &dev_attr_nv_temp_target.attr)\n\t\tok = asus->nv_temp_tgt_available;\n\telse if (attr == &dev_attr_panel_od.attr)\n\t\tok = asus->panel_overdrive_available;\n\telse if (attr == &dev_attr_mini_led_mode.attr)\n\t\tok = asus->mini_led_mode_available;\n\n\tif (devid != -1)\n\t\tok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);\n\n\treturn ok ? attr->mode : 0;\n}\n\nstatic const struct attribute_group platform_attribute_group = {\n\t.is_visible = asus_sysfs_is_visible,\n\t.attrs = platform_attributes\n};\n\nstatic void asus_wmi_sysfs_exit(struct platform_device *device)\n{\n\tsysfs_remove_group(&device->dev.kobj, &platform_attribute_group);\n}\n\nstatic int asus_wmi_sysfs_init(struct platform_device *device)\n{\n\treturn sysfs_create_group(&device->dev.kobj, &platform_attribute_group);\n}\n\n \n\nstatic int asus_wmi_platform_init(struct asus_wmi *asus)\n{\n\tstruct device *dev = &asus->platform_device->dev;\n\tchar *wmi_uid;\n\tint rv;\n\n\t \n\tif (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_INIT, 0, 0, &rv))\n\t\tpr_info(\"Initialization: %#x\\n\", rv);\n\n\t \n\tif (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_SPEC, 0, 0x9, &rv)) {\n\t\tpr_info(\"BIOS WMI version: %d.%d\\n\", rv >> 16, rv & 0xFF);\n\t\tasus->spec = rv;\n\t}\n\n\t \n\tif (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_SFUN, 0, 0, &rv)) {\n\t\tpr_info(\"SFUN value: %#x\\n\", rv);\n\t\tasus->sfun = rv;\n\t}\n\n\t \n\twmi_uid = wmi_get_acpi_device_uid(ASUS_WMI_MGMT_GUID);\n\tif (!wmi_uid)\n\t\treturn -ENODEV;\n\n\tif (!strcmp(wmi_uid, ASUS_ACPI_UID_ASUSWMI)) {\n\t\tdev_info(dev, \"Detected ASUSWMI, use DCTS\\n\");\n\t\tasus->dsts_id = ASUS_WMI_METHODID_DCTS;\n\t} else {\n\t\tdev_info(dev, \"Detected %s, not ASUSWMI, use DSTS\\n\", wmi_uid);\n\t\tasus->dsts_id = ASUS_WMI_METHODID_DSTS;\n\t}\n\n\t \n\twmi_uid = wmi_get_acpi_device_uid(asus->driver->event_guid);\n\tif (wmi_uid && !strcmp(wmi_uid, ASUS_ACPI_UID_ATK)) {\n\t\tdev_info(dev, \"Detected ATK, enable event queue\\n\");\n\n\t\tif (!asus_wmi_notify_queue_flush(asus))\n\t\t\tasus->wmi_event_queue = true;\n\t}\n\n\t \n\tif (asus->driver->quirks->wapf >= 0)\n\t\tasus_wmi_set_devstate(ASUS_WMI_DEVID_CWAP,\n\t\t\t\t      asus->driver->quirks->wapf, NULL);\n\n\treturn 0;\n}\n\n \n\nstruct asus_wmi_debugfs_node {\n\tstruct asus_wmi *asus;\n\tchar *name;\n\tint (*show) (struct seq_file *m, void *data);\n};\n\nstatic int show_dsts(struct seq_file *m, void *data)\n{\n\tstruct asus_wmi *asus = m->private;\n\tint err;\n\tu32 retval = -1;\n\n\terr = asus_wmi_get_devstate(asus, asus->debug.dev_id, &retval);\n\tif (err < 0)\n\t\treturn err;\n\n\tseq_printf(m, \"DSTS(%#x) = %#x\\n\", asus->debug.dev_id, retval);\n\n\treturn 0;\n}\n\nstatic int show_devs(struct seq_file *m, void *data)\n{\n\tstruct asus_wmi *asus = m->private;\n\tint err;\n\tu32 retval = -1;\n\n\terr = asus_wmi_set_devstate(asus->debug.dev_id, asus->debug.ctrl_param,\n\t\t\t\t    &retval);\n\tif (err < 0)\n\t\treturn err;\n\n\tseq_printf(m, \"DEVS(%#x, %#x) = %#x\\n\", asus->debug.dev_id,\n\t\t   asus->debug.ctrl_param, retval);\n\n\treturn 0;\n}\n\nstatic int show_call(struct seq_file *m, void *data)\n{\n\tstruct asus_wmi *asus = m->private;\n\tstruct bios_args args = {\n\t\t.arg0 = asus->debug.dev_id,\n\t\t.arg1 = asus->debug.ctrl_param,\n\t};\n\tstruct acpi_buffer input = { (acpi_size) sizeof(args), &args };\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tstatus = wmi_evaluate_method(ASUS_WMI_MGMT_GUID,\n\t\t\t\t     0, asus->debug.method_id,\n\t\t\t\t     &input, &output);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tobj = (union acpi_object *)output.pointer;\n\tif (obj && obj->type == ACPI_TYPE_INTEGER)\n\t\tseq_printf(m, \"%#x(%#x, %#x) = %#x\\n\", asus->debug.method_id,\n\t\t\t   asus->debug.dev_id, asus->debug.ctrl_param,\n\t\t\t   (u32) obj->integer.value);\n\telse\n\t\tseq_printf(m, \"%#x(%#x, %#x) = t:%d\\n\", asus->debug.method_id,\n\t\t\t   asus->debug.dev_id, asus->debug.ctrl_param,\n\t\t\t   obj ? obj->type : -1);\n\n\tkfree(obj);\n\n\treturn 0;\n}\n\nstatic struct asus_wmi_debugfs_node asus_wmi_debug_files[] = {\n\t{NULL, \"devs\", show_devs},\n\t{NULL, \"dsts\", show_dsts},\n\t{NULL, \"call\", show_call},\n};\n\nstatic int asus_wmi_debugfs_open(struct inode *inode, struct file *file)\n{\n\tstruct asus_wmi_debugfs_node *node = inode->i_private;\n\n\treturn single_open(file, node->show, node->asus);\n}\n\nstatic const struct file_operations asus_wmi_debugfs_io_ops = {\n\t.owner = THIS_MODULE,\n\t.open = asus_wmi_debugfs_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void asus_wmi_debugfs_exit(struct asus_wmi *asus)\n{\n\tdebugfs_remove_recursive(asus->debug.root);\n}\n\nstatic void asus_wmi_debugfs_init(struct asus_wmi *asus)\n{\n\tint i;\n\n\tasus->debug.root = debugfs_create_dir(asus->driver->name, NULL);\n\n\tdebugfs_create_x32(\"method_id\", S_IRUGO | S_IWUSR, asus->debug.root,\n\t\t\t   &asus->debug.method_id);\n\n\tdebugfs_create_x32(\"dev_id\", S_IRUGO | S_IWUSR, asus->debug.root,\n\t\t\t   &asus->debug.dev_id);\n\n\tdebugfs_create_x32(\"ctrl_param\", S_IRUGO | S_IWUSR, asus->debug.root,\n\t\t\t   &asus->debug.ctrl_param);\n\n\tfor (i = 0; i < ARRAY_SIZE(asus_wmi_debug_files); i++) {\n\t\tstruct asus_wmi_debugfs_node *node = &asus_wmi_debug_files[i];\n\n\t\tnode->asus = asus;\n\t\tdebugfs_create_file(node->name, S_IFREG | S_IRUGO,\n\t\t\t\t    asus->debug.root, node,\n\t\t\t\t    &asus_wmi_debugfs_io_ops);\n\t}\n}\n\n \n\nstatic int asus_wmi_add(struct platform_device *pdev)\n{\n\tstruct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);\n\tstruct asus_wmi_driver *wdrv = to_asus_wmi_driver(pdrv);\n\tstruct asus_wmi *asus;\n\tacpi_status status;\n\tint err;\n\tu32 result;\n\n\tasus = kzalloc(sizeof(struct asus_wmi), GFP_KERNEL);\n\tif (!asus)\n\t\treturn -ENOMEM;\n\n\tasus->driver = wdrv;\n\tasus->platform_device = pdev;\n\twdrv->platform_device = pdev;\n\tplatform_set_drvdata(asus->platform_device, asus);\n\n\tif (wdrv->detect_quirks)\n\t\twdrv->detect_quirks(asus->driver);\n\n\terr = asus_wmi_platform_init(asus);\n\tif (err)\n\t\tgoto fail_platform;\n\n\tasus->charge_mode_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_CHARGE_MODE);\n\tasus->egpu_enable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_EGPU);\n\tasus->egpu_connect_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_EGPU_CONNECTED);\n\tasus->dgpu_disable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_DGPU);\n\tasus->gpu_mux_mode_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_GPU_MUX);\n\tasus->kbd_rgb_mode_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_TUF_RGB_MODE);\n\tasus->kbd_rgb_state_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_TUF_RGB_STATE);\n\tasus->ppt_pl2_sppt_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_PPT_PL2_SPPT);\n\tasus->ppt_pl1_spl_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_PPT_PL1_SPL);\n\tasus->ppt_fppt_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_PPT_FPPT);\n\tasus->ppt_apu_sppt_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_PPT_APU_SPPT);\n\tasus->ppt_plat_sppt_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_PPT_PLAT_SPPT);\n\tasus->nv_dyn_boost_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_NV_DYN_BOOST);\n\tasus->nv_temp_tgt_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_NV_THERM_TARGET);\n\tasus->panel_overdrive_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_PANEL_OD);\n\tasus->mini_led_mode_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_MINI_LED_MODE);\n\n\terr = fan_boost_mode_check_present(asus);\n\tif (err)\n\t\tgoto fail_fan_boost_mode;\n\n\terr = throttle_thermal_policy_check_present(asus);\n\tif (err)\n\t\tgoto fail_throttle_thermal_policy;\n\telse\n\t\tthrottle_thermal_policy_set_default(asus);\n\n\terr = platform_profile_setup(asus);\n\tif (err)\n\t\tgoto fail_platform_profile_setup;\n\n\terr = asus_wmi_sysfs_init(asus->platform_device);\n\tif (err)\n\t\tgoto fail_sysfs;\n\n\terr = asus_wmi_input_init(asus);\n\tif (err)\n\t\tgoto fail_input;\n\n\terr = asus_wmi_fan_init(asus);  \n\n\terr = asus_wmi_hwmon_init(asus);\n\tif (err)\n\t\tgoto fail_hwmon;\n\n\terr = asus_wmi_custom_fan_curve_init(asus);\n\tif (err)\n\t\tgoto fail_custom_fan_curve;\n\n\terr = asus_wmi_led_init(asus);\n\tif (err)\n\t\tgoto fail_leds;\n\n\tasus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WLAN, &result);\n\tif (result & (ASUS_WMI_DSTS_PRESENCE_BIT | ASUS_WMI_DSTS_USER_BIT))\n\t\tasus->driver->wlan_ctrl_by_user = 1;\n\n\tif (!(asus->driver->wlan_ctrl_by_user && ashs_present())) {\n\t\terr = asus_wmi_rfkill_init(asus);\n\t\tif (err)\n\t\t\tgoto fail_rfkill;\n\t}\n\n\tif (asus->driver->quirks->wmi_force_als_set)\n\t\tasus_wmi_set_als();\n\n\tif (asus->driver->quirks->xusb2pr)\n\t\tasus_wmi_set_xusb2pr(asus);\n\n\tif (acpi_video_get_backlight_type() == acpi_backlight_vendor) {\n\t\terr = asus_wmi_backlight_init(asus);\n\t\tif (err && err != -ENODEV)\n\t\t\tgoto fail_backlight;\n\t} else if (asus->driver->quirks->wmi_backlight_set_devstate)\n\t\terr = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT, 2, NULL);\n\n\tif (asus_wmi_has_fnlock_key(asus)) {\n\t\tasus->fnlock_locked = fnlock_default;\n\t\tasus_wmi_fnlock_update(asus);\n\t}\n\n\tstatus = wmi_install_notify_handler(asus->driver->event_guid,\n\t\t\t\t\t    asus_wmi_notify, asus);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Unable to register notify handler - %d\\n\", status);\n\t\terr = -ENODEV;\n\t\tgoto fail_wmi_handler;\n\t}\n\n\tif (asus->driver->quirks->i8042_filter) {\n\t\terr = i8042_install_filter(asus->driver->quirks->i8042_filter);\n\t\tif (err)\n\t\t\tpr_warn(\"Unable to install key filter - %d\\n\", err);\n\t}\n\n\tasus_wmi_battery_init(asus);\n\n\tasus_wmi_debugfs_init(asus);\n\n\treturn 0;\n\nfail_wmi_handler:\n\tasus_wmi_backlight_exit(asus);\nfail_backlight:\n\tasus_wmi_rfkill_exit(asus);\nfail_rfkill:\n\tasus_wmi_led_exit(asus);\nfail_leds:\nfail_hwmon:\n\tasus_wmi_input_exit(asus);\nfail_input:\n\tasus_wmi_sysfs_exit(asus->platform_device);\nfail_sysfs:\nfail_throttle_thermal_policy:\nfail_custom_fan_curve:\nfail_platform_profile_setup:\n\tif (asus->platform_profile_support)\n\t\tplatform_profile_remove();\nfail_fan_boost_mode:\nfail_platform:\n\tkfree(asus);\n\treturn err;\n}\n\nstatic int asus_wmi_remove(struct platform_device *device)\n{\n\tstruct asus_wmi *asus;\n\n\tasus = platform_get_drvdata(device);\n\tif (asus->driver->quirks->i8042_filter)\n\t\ti8042_remove_filter(asus->driver->quirks->i8042_filter);\n\twmi_remove_notify_handler(asus->driver->event_guid);\n\tasus_wmi_backlight_exit(asus);\n\tasus_wmi_input_exit(asus);\n\tasus_wmi_led_exit(asus);\n\tasus_wmi_rfkill_exit(asus);\n\tasus_wmi_debugfs_exit(asus);\n\tasus_wmi_sysfs_exit(asus->platform_device);\n\tasus_fan_set_auto(asus);\n\tthrottle_thermal_policy_set_default(asus);\n\tasus_wmi_battery_exit(asus);\n\n\tif (asus->platform_profile_support)\n\t\tplatform_profile_remove();\n\n\tkfree(asus);\n\treturn 0;\n}\n\n \n\nstatic int asus_hotk_thaw(struct device *device)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(device);\n\n\tif (asus->wlan.rfkill) {\n\t\tbool wlan;\n\n\t\t \n\t\twlan = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WLAN);\n\t\tasus_wmi_set_devstate(ASUS_WMI_DEVID_WLAN, wlan, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int asus_hotk_resume(struct device *device)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(device);\n\n\tif (!IS_ERR_OR_NULL(asus->kbd_led.dev))\n\t\tkbd_led_update(asus);\n\n\tif (asus_wmi_has_fnlock_key(asus))\n\t\tasus_wmi_fnlock_update(asus);\n\n\tasus_wmi_tablet_mode_get_state(asus);\n\treturn 0;\n}\n\nstatic int asus_hotk_restore(struct device *device)\n{\n\tstruct asus_wmi *asus = dev_get_drvdata(device);\n\tint bl;\n\n\t \n\tif (asus->wlan.rfkill)\n\t\tasus_rfkill_hotplug(asus);\n\n\tif (asus->bluetooth.rfkill) {\n\t\tbl = !asus_wmi_get_devstate_simple(asus,\n\t\t\t\t\t\t   ASUS_WMI_DEVID_BLUETOOTH);\n\t\trfkill_set_sw_state(asus->bluetooth.rfkill, bl);\n\t}\n\tif (asus->wimax.rfkill) {\n\t\tbl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WIMAX);\n\t\trfkill_set_sw_state(asus->wimax.rfkill, bl);\n\t}\n\tif (asus->wwan3g.rfkill) {\n\t\tbl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WWAN3G);\n\t\trfkill_set_sw_state(asus->wwan3g.rfkill, bl);\n\t}\n\tif (asus->gps.rfkill) {\n\t\tbl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_GPS);\n\t\trfkill_set_sw_state(asus->gps.rfkill, bl);\n\t}\n\tif (asus->uwb.rfkill) {\n\t\tbl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_UWB);\n\t\trfkill_set_sw_state(asus->uwb.rfkill, bl);\n\t}\n\tif (!IS_ERR_OR_NULL(asus->kbd_led.dev))\n\t\tkbd_led_update(asus);\n\n\tif (asus_wmi_has_fnlock_key(asus))\n\t\tasus_wmi_fnlock_update(asus);\n\n\tasus_wmi_tablet_mode_get_state(asus);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops asus_pm_ops = {\n\t.thaw = asus_hotk_thaw,\n\t.restore = asus_hotk_restore,\n\t.resume = asus_hotk_resume,\n};\n\n \n\nstatic int asus_wmi_probe(struct platform_device *pdev)\n{\n\tstruct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);\n\tstruct asus_wmi_driver *wdrv = to_asus_wmi_driver(pdrv);\n\tint ret;\n\n\tif (!wmi_has_guid(ASUS_WMI_MGMT_GUID)) {\n\t\tpr_warn(\"ASUS Management GUID not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (wdrv->event_guid && !wmi_has_guid(wdrv->event_guid)) {\n\t\tpr_warn(\"ASUS Event GUID not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (wdrv->probe) {\n\t\tret = wdrv->probe(pdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn asus_wmi_add(pdev);\n}\n\nstatic bool used;\n\nint __init_or_module asus_wmi_register_driver(struct asus_wmi_driver *driver)\n{\n\tstruct platform_driver *platform_driver;\n\tstruct platform_device *platform_device;\n\n\tif (used)\n\t\treturn -EBUSY;\n\n\tplatform_driver = &driver->platform_driver;\n\tplatform_driver->remove = asus_wmi_remove;\n\tplatform_driver->driver.owner = driver->owner;\n\tplatform_driver->driver.name = driver->name;\n\tplatform_driver->driver.pm = &asus_pm_ops;\n\n\tplatform_device = platform_create_bundle(platform_driver,\n\t\t\t\t\t\t asus_wmi_probe,\n\t\t\t\t\t\t NULL, 0, NULL, 0);\n\tif (IS_ERR(platform_device))\n\t\treturn PTR_ERR(platform_device);\n\n\tused = true;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asus_wmi_register_driver);\n\nvoid asus_wmi_unregister_driver(struct asus_wmi_driver *driver)\n{\n\tplatform_device_unregister(driver->platform_device);\n\tplatform_driver_unregister(&driver->platform_driver);\n\tused = false;\n}\nEXPORT_SYMBOL_GPL(asus_wmi_unregister_driver);\n\nstatic int __init asus_wmi_init(void)\n{\n\tpr_info(\"ASUS WMI generic driver loaded\\n\");\n\treturn 0;\n}\n\nstatic void __exit asus_wmi_exit(void)\n{\n\tpr_info(\"ASUS WMI generic driver unloaded\\n\");\n}\n\nmodule_init(asus_wmi_init);\nmodule_exit(asus_wmi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}