{
  "module_name": "msi-laptop.c",
  "hash_id": "2826bd626bcec51cfbc972e3464c51c964604521102ea07a478dcc2daf1e7530",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/msi-laptop.c",
  "human_readable_source": "\n \n\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/backlight.h>\n#include <linux/platform_device.h>\n#include <linux/rfkill.h>\n#include <linux/i8042.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <acpi/video.h>\n\n#define MSI_LCD_LEVEL_MAX 9\n\n#define MSI_EC_COMMAND_WIRELESS 0x10\n#define MSI_EC_COMMAND_LCD_LEVEL 0x11\n\n#define MSI_STANDARD_EC_COMMAND_ADDRESS\t0x2e\n#define MSI_STANDARD_EC_BLUETOOTH_MASK\t(1 << 0)\n#define MSI_STANDARD_EC_WEBCAM_MASK\t(1 << 1)\n#define MSI_STANDARD_EC_WLAN_MASK\t(1 << 3)\n#define MSI_STANDARD_EC_3G_MASK\t\t(1 << 4)\n\n \n#define MSI_STANDARD_EC_SCM_LOAD_ADDRESS\t0x2d\n#define MSI_STANDARD_EC_SCM_LOAD_MASK\t\t(1 << 0)\n\n#define MSI_STANDARD_EC_FUNCTIONS_ADDRESS\t0xe4\n \n#define MSI_STANDARD_EC_TURBO_MASK\t\t(1 << 1)\n \n#define MSI_STANDARD_EC_ECO_MASK\t\t(1 << 3)\n \n#define MSI_STANDARD_EC_TOUCHPAD_MASK\t\t(1 << 4)\n \n#define MSI_STANDARD_EC_TURBO_COOLDOWN_MASK\t(1 << 7)\n\n#define MSI_STANDARD_EC_FAN_ADDRESS\t\t0x33\n \n#define MSI_STANDARD_EC_AUTOFAN_MASK\t\t(1 << 0)\n\n#ifdef CONFIG_PM_SLEEP\nstatic int msi_laptop_resume(struct device *device);\n#endif\nstatic SIMPLE_DEV_PM_OPS(msi_laptop_pm, NULL, msi_laptop_resume);\n\n#define MSI_STANDARD_EC_DEVICES_EXISTS_ADDRESS\t0x2f\n\nstatic bool force;\nmodule_param(force, bool, 0);\nMODULE_PARM_DESC(force, \"Force driver load, ignore DMI data\");\n\nstatic int auto_brightness;\nmodule_param(auto_brightness, int, 0);\nMODULE_PARM_DESC(auto_brightness, \"Enable automatic brightness control (0: disabled; 1: enabled; 2: don't touch)\");\n\nstatic const struct key_entry msi_laptop_keymap[] = {\n\t{KE_KEY, KEY_TOUCHPAD_ON, {KEY_TOUCHPAD_ON} },\t \n\t{KE_KEY, KEY_TOUCHPAD_OFF, {KEY_TOUCHPAD_OFF} }, \n\t{KE_END, 0}\n};\n\nstatic struct input_dev *msi_laptop_input_dev;\n\nstatic int wlan_s, bluetooth_s, threeg_s;\nstatic int threeg_exists;\nstatic struct rfkill *rfk_wlan, *rfk_bluetooth, *rfk_threeg;\n\n \nstruct quirk_entry {\n\tbool old_ec_model;\n\n\t \n\tbool load_scm_model;\n\n\t \n\tbool ec_delay;\n\n\t \n\tbool ec_read_only;\n};\n\nstatic struct quirk_entry *quirks;\n\n \n\nstatic int set_lcd_level(int level)\n{\n\tu8 buf[2];\n\n\tif (level < 0 || level >= MSI_LCD_LEVEL_MAX)\n\t\treturn -EINVAL;\n\n\tbuf[0] = 0x80;\n\tbuf[1] = (u8) (level*31);\n\n\treturn ec_transaction(MSI_EC_COMMAND_LCD_LEVEL, buf, sizeof(buf),\n\t\t\t      NULL, 0);\n}\n\nstatic int get_lcd_level(void)\n{\n\tu8 wdata = 0, rdata;\n\tint result;\n\n\tresult = ec_transaction(MSI_EC_COMMAND_LCD_LEVEL, &wdata, 1,\n\t\t\t\t&rdata, 1);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn (int) rdata / 31;\n}\n\nstatic int get_auto_brightness(void)\n{\n\tu8 wdata = 4, rdata;\n\tint result;\n\n\tresult = ec_transaction(MSI_EC_COMMAND_LCD_LEVEL, &wdata, 1,\n\t\t\t\t&rdata, 1);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn !!(rdata & 8);\n}\n\nstatic int set_auto_brightness(int enable)\n{\n\tu8 wdata[2], rdata;\n\tint result;\n\n\twdata[0] = 4;\n\n\tresult = ec_transaction(MSI_EC_COMMAND_LCD_LEVEL, wdata, 1,\n\t\t\t\t&rdata, 1);\n\tif (result < 0)\n\t\treturn result;\n\n\twdata[0] = 0x84;\n\twdata[1] = (rdata & 0xF7) | (enable ? 8 : 0);\n\n\treturn ec_transaction(MSI_EC_COMMAND_LCD_LEVEL, wdata, 2,\n\t\t\t      NULL, 0);\n}\n\nstatic ssize_t set_device_state(const char *buf, size_t count, u8 mask)\n{\n\tint status;\n\tu8 wdata = 0, rdata;\n\tint result;\n\n\tif (sscanf(buf, \"%i\", &status) != 1 || (status < 0 || status > 1))\n\t\treturn -EINVAL;\n\n\tif (quirks->ec_read_only)\n\t\treturn 0;\n\n\t \n\tresult = ec_read(MSI_STANDARD_EC_COMMAND_ADDRESS, &rdata);\n\tif (result < 0)\n\t\treturn result;\n\n\tif (!!(rdata & mask) != status) {\n\t\t \n\t\tif (rdata & mask)\n\t\t\twdata = rdata & ~mask;\n\t\telse\n\t\t\twdata = rdata | mask;\n\n\t\tresult = ec_write(MSI_STANDARD_EC_COMMAND_ADDRESS, wdata);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t}\n\n\treturn count;\n}\n\nstatic int get_wireless_state(int *wlan, int *bluetooth)\n{\n\tu8 wdata = 0, rdata;\n\tint result;\n\n\tresult = ec_transaction(MSI_EC_COMMAND_WIRELESS, &wdata, 1, &rdata, 1);\n\tif (result < 0)\n\t\treturn result;\n\n\tif (wlan)\n\t\t*wlan = !!(rdata & 8);\n\n\tif (bluetooth)\n\t\t*bluetooth = !!(rdata & 128);\n\n\treturn 0;\n}\n\nstatic int get_wireless_state_ec_standard(void)\n{\n\tu8 rdata;\n\tint result;\n\n\tresult = ec_read(MSI_STANDARD_EC_COMMAND_ADDRESS, &rdata);\n\tif (result < 0)\n\t\treturn result;\n\n\twlan_s = !!(rdata & MSI_STANDARD_EC_WLAN_MASK);\n\n\tbluetooth_s = !!(rdata & MSI_STANDARD_EC_BLUETOOTH_MASK);\n\n\tthreeg_s = !!(rdata & MSI_STANDARD_EC_3G_MASK);\n\n\treturn 0;\n}\n\nstatic int get_threeg_exists(void)\n{\n\tu8 rdata;\n\tint result;\n\n\tresult = ec_read(MSI_STANDARD_EC_DEVICES_EXISTS_ADDRESS, &rdata);\n\tif (result < 0)\n\t\treturn result;\n\n\tthreeg_exists = !!(rdata & MSI_STANDARD_EC_3G_MASK);\n\n\treturn 0;\n}\n\n \n\nstatic int bl_get_brightness(struct backlight_device *b)\n{\n\treturn get_lcd_level();\n}\n\n\nstatic int bl_update_status(struct backlight_device *b)\n{\n\treturn set_lcd_level(b->props.brightness);\n}\n\nstatic const struct backlight_ops msibl_ops = {\n\t.get_brightness = bl_get_brightness,\n\t.update_status  = bl_update_status,\n};\n\nstatic struct backlight_device *msibl_device;\n\n \n\nstatic ssize_t show_wlan(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\n\tint ret, enabled = 0;\n\n\tif (quirks->old_ec_model) {\n\t\tret = get_wireless_state(&enabled, NULL);\n\t} else {\n\t\tret = get_wireless_state_ec_standard();\n\t\tenabled = wlan_s;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%i\\n\", enabled);\n}\n\nstatic ssize_t store_wlan(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn set_device_state(buf, count, MSI_STANDARD_EC_WLAN_MASK);\n}\n\nstatic ssize_t show_bluetooth(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\n\tint ret, enabled = 0;\n\n\tif (quirks->old_ec_model) {\n\t\tret = get_wireless_state(NULL, &enabled);\n\t} else {\n\t\tret = get_wireless_state_ec_standard();\n\t\tenabled = bluetooth_s;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%i\\n\", enabled);\n}\n\nstatic ssize_t store_bluetooth(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn set_device_state(buf, count, MSI_STANDARD_EC_BLUETOOTH_MASK);\n}\n\nstatic ssize_t show_threeg(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\n\tint ret;\n\n\t \n\tif (quirks->old_ec_model)\n\t\treturn -ENODEV;\n\n\tret = get_wireless_state_ec_standard();\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%i\\n\", threeg_s);\n}\n\nstatic ssize_t store_threeg(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn set_device_state(buf, count, MSI_STANDARD_EC_3G_MASK);\n}\n\nstatic ssize_t show_lcd_level(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\n\tint ret;\n\n\tret = get_lcd_level();\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%i\\n\", ret);\n}\n\nstatic ssize_t store_lcd_level(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\n\tint level, ret;\n\n\tif (sscanf(buf, \"%i\", &level) != 1 ||\n\t    (level < 0 || level >= MSI_LCD_LEVEL_MAX))\n\t\treturn -EINVAL;\n\n\tret = set_lcd_level(level);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t show_auto_brightness(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\n\tint ret;\n\n\tret = get_auto_brightness();\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%i\\n\", ret);\n}\n\nstatic ssize_t store_auto_brightness(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\n\tint enable, ret;\n\n\tif (sscanf(buf, \"%i\", &enable) != 1 || (enable != (enable & 1)))\n\t\treturn -EINVAL;\n\n\tret = set_auto_brightness(enable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t show_touchpad(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\n\tu8 rdata;\n\tint result;\n\n\tresult = ec_read(MSI_STANDARD_EC_FUNCTIONS_ADDRESS, &rdata);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sprintf(buf, \"%i\\n\", !!(rdata & MSI_STANDARD_EC_TOUCHPAD_MASK));\n}\n\nstatic ssize_t show_turbo(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\n\tu8 rdata;\n\tint result;\n\n\tresult = ec_read(MSI_STANDARD_EC_FUNCTIONS_ADDRESS, &rdata);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sprintf(buf, \"%i\\n\", !!(rdata & MSI_STANDARD_EC_TURBO_MASK));\n}\n\nstatic ssize_t show_eco(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\n\tu8 rdata;\n\tint result;\n\n\tresult = ec_read(MSI_STANDARD_EC_FUNCTIONS_ADDRESS, &rdata);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sprintf(buf, \"%i\\n\", !!(rdata & MSI_STANDARD_EC_ECO_MASK));\n}\n\nstatic ssize_t show_turbo_cooldown(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\n\tu8 rdata;\n\tint result;\n\n\tresult = ec_read(MSI_STANDARD_EC_FUNCTIONS_ADDRESS, &rdata);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sprintf(buf, \"%i\\n\", (!!(rdata & MSI_STANDARD_EC_TURBO_MASK)) |\n\t\t(!!(rdata & MSI_STANDARD_EC_TURBO_COOLDOWN_MASK) << 1));\n}\n\nstatic ssize_t show_auto_fan(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\n\tu8 rdata;\n\tint result;\n\n\tresult = ec_read(MSI_STANDARD_EC_FAN_ADDRESS, &rdata);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn sprintf(buf, \"%i\\n\", !!(rdata & MSI_STANDARD_EC_AUTOFAN_MASK));\n}\n\nstatic ssize_t store_auto_fan(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\n\tint enable, result;\n\n\tif (sscanf(buf, \"%i\", &enable) != 1 || (enable != (enable & 1)))\n\t\treturn -EINVAL;\n\n\tresult = ec_write(MSI_STANDARD_EC_FAN_ADDRESS, enable);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(lcd_level, 0644, show_lcd_level, store_lcd_level);\nstatic DEVICE_ATTR(auto_brightness, 0644, show_auto_brightness,\n\t\t   store_auto_brightness);\nstatic DEVICE_ATTR(bluetooth, 0444, show_bluetooth, NULL);\nstatic DEVICE_ATTR(wlan, 0444, show_wlan, NULL);\nstatic DEVICE_ATTR(threeg, 0444, show_threeg, NULL);\nstatic DEVICE_ATTR(touchpad, 0444, show_touchpad, NULL);\nstatic DEVICE_ATTR(turbo_mode, 0444, show_turbo, NULL);\nstatic DEVICE_ATTR(eco_mode, 0444, show_eco, NULL);\nstatic DEVICE_ATTR(turbo_cooldown, 0444, show_turbo_cooldown, NULL);\nstatic DEVICE_ATTR(auto_fan, 0644, show_auto_fan, store_auto_fan);\n\nstatic struct attribute *msipf_attributes[] = {\n\t&dev_attr_bluetooth.attr,\n\t&dev_attr_wlan.attr,\n\t&dev_attr_touchpad.attr,\n\t&dev_attr_turbo_mode.attr,\n\t&dev_attr_eco_mode.attr,\n\t&dev_attr_turbo_cooldown.attr,\n\t&dev_attr_auto_fan.attr,\n\tNULL\n};\n\nstatic struct attribute *msipf_old_attributes[] = {\n\t&dev_attr_lcd_level.attr,\n\t&dev_attr_auto_brightness.attr,\n\tNULL\n};\n\nstatic const struct attribute_group msipf_attribute_group = {\n\t.attrs = msipf_attributes\n};\n\nstatic const struct attribute_group msipf_old_attribute_group = {\n\t.attrs = msipf_old_attributes\n};\n\nstatic struct platform_driver msipf_driver = {\n\t.driver = {\n\t\t.name = \"msi-laptop-pf\",\n\t\t.pm = &msi_laptop_pm,\n\t},\n};\n\nstatic struct platform_device *msipf_device;\n\n \n\nstatic struct quirk_entry quirk_old_ec_model = {\n\t.old_ec_model = true,\n};\n\nstatic struct quirk_entry quirk_load_scm_model = {\n\t.load_scm_model = true,\n\t.ec_delay = true,\n};\n\nstatic struct quirk_entry quirk_load_scm_ro_model = {\n\t.load_scm_model = true,\n\t.ec_read_only = true,\n};\n\nstatic int dmi_check_cb(const struct dmi_system_id *dmi)\n{\n\tpr_info(\"Identified laptop model '%s'\\n\", dmi->ident);\n\n\tquirks = dmi->driver_data;\n\n\treturn 1;\n}\n\nstatic unsigned long msi_work_delay(int msecs)\n{\n\tif (quirks->ec_delay)\n\t\treturn msecs_to_jiffies(msecs);\n\n\treturn 0;\n}\n\nstatic const struct dmi_system_id msi_dmi_table[] __initconst = {\n\t{\n\t\t.ident = \"MSI S270\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MICRO-STAR INT\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MS-1013\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"0131\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_VENDOR, \"MICRO-STAR INT\")\n\t\t},\n\t\t.driver_data = &quirk_old_ec_model,\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"MSI S271\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Micro-Star International\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MS-1058\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"0581\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"MS-1058\")\n\t\t},\n\t\t.driver_data = &quirk_old_ec_model,\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"MSI S420\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Micro-Star International\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MS-1412\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"MSI\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"MS-1412\")\n\t\t},\n\t\t.driver_data = &quirk_old_ec_model,\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"Medion MD96100\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"NOTEBOOK\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"SAM2000\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"0131\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_VENDOR, \"MICRO-STAR INT\")\n\t\t},\n\t\t.driver_data = &quirk_old_ec_model,\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"MSI N034\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\"MICRO-STAR INTERNATIONAL CO., LTD\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MS-N034\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_VENDOR,\n\t\t\t\"MICRO-STAR INTERNATIONAL CO., LTD\")\n\t\t},\n\t\t.driver_data = &quirk_load_scm_model,\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"MSI N051\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\"MICRO-STAR INTERNATIONAL CO., LTD\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MS-N051\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_VENDOR,\n\t\t\t\"MICRO-STAR INTERNATIONAL CO., LTD\")\n\t\t},\n\t\t.driver_data = &quirk_load_scm_model,\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"MSI N014\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\"MICRO-STAR INTERNATIONAL CO., LTD\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MS-N014\"),\n\t\t},\n\t\t.driver_data = &quirk_load_scm_model,\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"MSI CR620\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\"Micro-Star International\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CR620\"),\n\t\t},\n\t\t.driver_data = &quirk_load_scm_model,\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"MSI U270\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\"Micro-Star International Co., Ltd.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"U270 series\"),\n\t\t},\n\t\t.driver_data = &quirk_load_scm_model,\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"MSI U90/U100\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\"MICRO-STAR INTERNATIONAL CO., LTD\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"U90/U100\"),\n\t\t},\n\t\t.driver_data = &quirk_load_scm_ro_model,\n\t\t.callback = dmi_check_cb\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(dmi, msi_dmi_table);\n\nstatic int rfkill_bluetooth_set(void *data, bool blocked)\n{\n\t \n\t \n\tint result = set_device_state(blocked ? \"0\" : \"1\", 0,\n\t\t\tMSI_STANDARD_EC_BLUETOOTH_MASK);\n\n\treturn min(result, 0);\n}\n\nstatic int rfkill_wlan_set(void *data, bool blocked)\n{\n\tint result = set_device_state(blocked ? \"0\" : \"1\", 0,\n\t\t\tMSI_STANDARD_EC_WLAN_MASK);\n\n\treturn min(result, 0);\n}\n\nstatic int rfkill_threeg_set(void *data, bool blocked)\n{\n\tint result = set_device_state(blocked ? \"0\" : \"1\", 0,\n\t\t\tMSI_STANDARD_EC_3G_MASK);\n\n\treturn min(result, 0);\n}\n\nstatic const struct rfkill_ops rfkill_bluetooth_ops = {\n\t.set_block = rfkill_bluetooth_set\n};\n\nstatic const struct rfkill_ops rfkill_wlan_ops = {\n\t.set_block = rfkill_wlan_set\n};\n\nstatic const struct rfkill_ops rfkill_threeg_ops = {\n\t.set_block = rfkill_threeg_set\n};\n\nstatic void rfkill_cleanup(void)\n{\n\tif (rfk_bluetooth) {\n\t\trfkill_unregister(rfk_bluetooth);\n\t\trfkill_destroy(rfk_bluetooth);\n\t}\n\n\tif (rfk_threeg) {\n\t\trfkill_unregister(rfk_threeg);\n\t\trfkill_destroy(rfk_threeg);\n\t}\n\n\tif (rfk_wlan) {\n\t\trfkill_unregister(rfk_wlan);\n\t\trfkill_destroy(rfk_wlan);\n\t}\n}\n\nstatic bool msi_rfkill_set_state(struct rfkill *rfkill, bool blocked)\n{\n\tif (quirks->ec_read_only)\n\t\treturn rfkill_set_hw_state(rfkill, blocked);\n\telse\n\t\treturn rfkill_set_sw_state(rfkill, blocked);\n}\n\nstatic void msi_update_rfkill(struct work_struct *ignored)\n{\n\tget_wireless_state_ec_standard();\n\n\tif (rfk_wlan)\n\t\tmsi_rfkill_set_state(rfk_wlan, !wlan_s);\n\tif (rfk_bluetooth)\n\t\tmsi_rfkill_set_state(rfk_bluetooth, !bluetooth_s);\n\tif (rfk_threeg)\n\t\tmsi_rfkill_set_state(rfk_threeg, !threeg_s);\n}\nstatic DECLARE_DELAYED_WORK(msi_rfkill_dwork, msi_update_rfkill);\n\nstatic void msi_send_touchpad_key(struct work_struct *ignored)\n{\n\tu8 rdata;\n\tint result;\n\n\tresult = ec_read(MSI_STANDARD_EC_FUNCTIONS_ADDRESS, &rdata);\n\tif (result < 0)\n\t\treturn;\n\n\tsparse_keymap_report_event(msi_laptop_input_dev,\n\t\t(rdata & MSI_STANDARD_EC_TOUCHPAD_MASK) ?\n\t\tKEY_TOUCHPAD_ON : KEY_TOUCHPAD_OFF, 1, true);\n}\nstatic DECLARE_DELAYED_WORK(msi_touchpad_dwork, msi_send_touchpad_key);\n\nstatic bool msi_laptop_i8042_filter(unsigned char data, unsigned char str,\n\t\t\t\tstruct serio *port)\n{\n\tstatic bool extended;\n\n\tif (str & I8042_STR_AUXDATA)\n\t\treturn false;\n\n\t \n\tif (unlikely(data == 0xe0)) {\n\t\textended = true;\n\t\treturn false;\n\t} else if (unlikely(extended)) {\n\t\textended = false;\n\t\tswitch (data) {\n\t\tcase 0xE4:\n\t\t\tschedule_delayed_work(&msi_touchpad_dwork, msi_work_delay(500));\n\t\t\tbreak;\n\t\tcase 0x54:\n\t\tcase 0x62:\n\t\tcase 0x76:\n\t\t\tschedule_delayed_work(&msi_rfkill_dwork, msi_work_delay(500));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic void msi_init_rfkill(struct work_struct *ignored)\n{\n\tif (rfk_wlan) {\n\t\tmsi_rfkill_set_state(rfk_wlan, !wlan_s);\n\t\trfkill_wlan_set(NULL, !wlan_s);\n\t}\n\tif (rfk_bluetooth) {\n\t\tmsi_rfkill_set_state(rfk_bluetooth, !bluetooth_s);\n\t\trfkill_bluetooth_set(NULL, !bluetooth_s);\n\t}\n\tif (rfk_threeg) {\n\t\tmsi_rfkill_set_state(rfk_threeg, !threeg_s);\n\t\trfkill_threeg_set(NULL, !threeg_s);\n\t}\n}\nstatic DECLARE_DELAYED_WORK(msi_rfkill_init, msi_init_rfkill);\n\nstatic int rfkill_init(struct platform_device *sdev)\n{\n\t \n\tint retval;\n\n\t \n\tget_wireless_state_ec_standard();\n\n\trfk_bluetooth = rfkill_alloc(\"msi-bluetooth\", &sdev->dev,\n\t\t\t\tRFKILL_TYPE_BLUETOOTH,\n\t\t\t\t&rfkill_bluetooth_ops, NULL);\n\tif (!rfk_bluetooth) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_bluetooth;\n\t}\n\tretval = rfkill_register(rfk_bluetooth);\n\tif (retval)\n\t\tgoto err_bluetooth;\n\n\trfk_wlan = rfkill_alloc(\"msi-wlan\", &sdev->dev, RFKILL_TYPE_WLAN,\n\t\t\t\t&rfkill_wlan_ops, NULL);\n\tif (!rfk_wlan) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_wlan;\n\t}\n\tretval = rfkill_register(rfk_wlan);\n\tif (retval)\n\t\tgoto err_wlan;\n\n\tif (threeg_exists) {\n\t\trfk_threeg = rfkill_alloc(\"msi-threeg\", &sdev->dev,\n\t\t\t\tRFKILL_TYPE_WWAN, &rfkill_threeg_ops, NULL);\n\t\tif (!rfk_threeg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_threeg;\n\t\t}\n\t\tretval = rfkill_register(rfk_threeg);\n\t\tif (retval)\n\t\t\tgoto err_threeg;\n\t}\n\n\t \n\tschedule_delayed_work(&msi_rfkill_init, msi_work_delay(1000));\n\treturn 0;\n\nerr_threeg:\n\trfkill_destroy(rfk_threeg);\n\tif (rfk_wlan)\n\t\trfkill_unregister(rfk_wlan);\nerr_wlan:\n\trfkill_destroy(rfk_wlan);\n\tif (rfk_bluetooth)\n\t\trfkill_unregister(rfk_bluetooth);\nerr_bluetooth:\n\trfkill_destroy(rfk_bluetooth);\n\n\treturn retval;\n}\n\nstatic int msi_scm_disable_hw_fn_handling(void)\n{\n\tu8 data;\n\tint result;\n\n\tif (!quirks->load_scm_model)\n\t\treturn 0;\n\n\t \n\tresult = ec_read(MSI_STANDARD_EC_SCM_LOAD_ADDRESS, &data);\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = ec_write(MSI_STANDARD_EC_SCM_LOAD_ADDRESS,\n\t\tdata | MSI_STANDARD_EC_SCM_LOAD_MASK);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int msi_laptop_resume(struct device *device)\n{\n\treturn msi_scm_disable_hw_fn_handling();\n}\n#endif\n\nstatic int __init msi_laptop_input_setup(void)\n{\n\tint err;\n\n\tmsi_laptop_input_dev = input_allocate_device();\n\tif (!msi_laptop_input_dev)\n\t\treturn -ENOMEM;\n\n\tmsi_laptop_input_dev->name = \"MSI Laptop hotkeys\";\n\tmsi_laptop_input_dev->phys = \"msi-laptop/input0\";\n\tmsi_laptop_input_dev->id.bustype = BUS_HOST;\n\n\terr = sparse_keymap_setup(msi_laptop_input_dev,\n\t\tmsi_laptop_keymap, NULL);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\terr = input_register_device(msi_laptop_input_dev);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\treturn 0;\n\nerr_free_dev:\n\tinput_free_device(msi_laptop_input_dev);\n\treturn err;\n}\n\nstatic int __init load_scm_model_init(struct platform_device *sdev)\n{\n\tint result;\n\n\tif (!quirks->ec_read_only) {\n\t\t \n\t\tdev_attr_bluetooth.store = store_bluetooth;\n\t\tdev_attr_wlan.store = store_wlan;\n\t\tdev_attr_threeg.store = store_threeg;\n\t\tdev_attr_bluetooth.attr.mode |= S_IWUSR;\n\t\tdev_attr_wlan.attr.mode |= S_IWUSR;\n\t\tdev_attr_threeg.attr.mode |= S_IWUSR;\n\t}\n\n\t \n\tresult = msi_scm_disable_hw_fn_handling();\n\tif (result < 0)\n\t\treturn result;\n\n\t \n\tresult = rfkill_init(sdev);\n\tif (result < 0)\n\t\tgoto fail_rfkill;\n\n\t \n\tresult = msi_laptop_input_setup();\n\tif (result)\n\t\tgoto fail_input;\n\n\tresult = i8042_install_filter(msi_laptop_i8042_filter);\n\tif (result) {\n\t\tpr_err(\"Unable to install key filter\\n\");\n\t\tgoto fail_filter;\n\t}\n\n\treturn 0;\n\nfail_filter:\n\tinput_unregister_device(msi_laptop_input_dev);\n\nfail_input:\n\trfkill_cleanup();\n\nfail_rfkill:\n\treturn result;\n}\n\nstatic void msi_scm_model_exit(void)\n{\n\tif (!quirks->load_scm_model)\n\t\treturn;\n\n\ti8042_remove_filter(msi_laptop_i8042_filter);\n\tcancel_delayed_work_sync(&msi_touchpad_dwork);\n\tinput_unregister_device(msi_laptop_input_dev);\n\tcancel_delayed_work_sync(&msi_rfkill_dwork);\n\trfkill_cleanup();\n}\n\nstatic int __init msi_init(void)\n{\n\tint ret;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\tdmi_check_system(msi_dmi_table);\n\tif (!quirks)\n\t\t \n\t\tquirks = &quirk_load_scm_model;\n\tif (force)\n\t\tquirks = &quirk_old_ec_model;\n\n\tif (!quirks->old_ec_model)\n\t\tget_threeg_exists();\n\n\tif (auto_brightness < 0 || auto_brightness > 2)\n\t\treturn -EINVAL;\n\n\t \n\tif (quirks->old_ec_model &&\n\t    acpi_video_get_backlight_type() == acpi_backlight_vendor) {\n\t\tstruct backlight_properties props;\n\t\tmemset(&props, 0, sizeof(struct backlight_properties));\n\t\tprops.type = BACKLIGHT_PLATFORM;\n\t\tprops.max_brightness = MSI_LCD_LEVEL_MAX - 1;\n\t\tmsibl_device = backlight_device_register(\"msi-laptop-bl\", NULL,\n\t\t\t\t\t\t\t NULL, &msibl_ops,\n\t\t\t\t\t\t\t &props);\n\t\tif (IS_ERR(msibl_device))\n\t\t\treturn PTR_ERR(msibl_device);\n\t}\n\n\tret = platform_driver_register(&msipf_driver);\n\tif (ret)\n\t\tgoto fail_backlight;\n\n\t \n\n\tmsipf_device = platform_device_alloc(\"msi-laptop-pf\", PLATFORM_DEVID_NONE);\n\tif (!msipf_device) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_platform_driver;\n\t}\n\n\tret = platform_device_add(msipf_device);\n\tif (ret)\n\t\tgoto fail_device_add;\n\n\tif (quirks->load_scm_model && (load_scm_model_init(msipf_device) < 0)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_scm_model_init;\n\t}\n\n\tret = sysfs_create_group(&msipf_device->dev.kobj,\n\t\t\t\t &msipf_attribute_group);\n\tif (ret)\n\t\tgoto fail_create_group;\n\n\tif (!quirks->old_ec_model) {\n\t\tif (threeg_exists)\n\t\t\tret = device_create_file(&msipf_device->dev,\n\t\t\t\t\t\t&dev_attr_threeg);\n\t\tif (ret)\n\t\t\tgoto fail_create_attr;\n\t} else {\n\t\tret = sysfs_create_group(&msipf_device->dev.kobj,\n\t\t\t\t\t &msipf_old_attribute_group);\n\t\tif (ret)\n\t\t\tgoto fail_create_attr;\n\n\t\t \n\n\t\tif (auto_brightness != 2)\n\t\t\tset_auto_brightness(auto_brightness);\n\t}\n\n\treturn 0;\n\nfail_create_attr:\n\tsysfs_remove_group(&msipf_device->dev.kobj, &msipf_attribute_group);\nfail_create_group:\n\tmsi_scm_model_exit();\nfail_scm_model_init:\n\tplatform_device_del(msipf_device);\nfail_device_add:\n\tplatform_device_put(msipf_device);\nfail_platform_driver:\n\tplatform_driver_unregister(&msipf_driver);\nfail_backlight:\n\tbacklight_device_unregister(msibl_device);\n\n\treturn ret;\n}\n\nstatic void __exit msi_cleanup(void)\n{\n\tmsi_scm_model_exit();\n\tsysfs_remove_group(&msipf_device->dev.kobj, &msipf_attribute_group);\n\tif (!quirks->old_ec_model && threeg_exists)\n\t\tdevice_remove_file(&msipf_device->dev, &dev_attr_threeg);\n\tplatform_device_unregister(msipf_device);\n\tplatform_driver_unregister(&msipf_driver);\n\tbacklight_device_unregister(msibl_device);\n\n\tif (quirks->old_ec_model) {\n\t\t \n\t\tif (auto_brightness != 2)\n\t\t\tset_auto_brightness(1);\n\t}\n}\n\nmodule_init(msi_init);\nmodule_exit(msi_cleanup);\n\nMODULE_AUTHOR(\"Lennart Poettering\");\nMODULE_DESCRIPTION(\"MSI Laptop Support\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}