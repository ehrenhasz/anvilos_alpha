{
  "module_name": "panasonic-laptop.c",
  "hash_id": "0ac5cbe944dfff0406c9affd9f48cb2300862a9fd9e976fb2818ef1682f213c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/panasonic-laptop.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/backlight.h>\n#include <linux/ctype.h>\n#include <linux/i8042.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/serio.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <acpi/video.h>\n\nMODULE_AUTHOR(\"Hiroshi Miura <miura@da-cha.org>\");\nMODULE_AUTHOR(\"David Bronaugh <dbronaugh@linuxboxen.org>\");\nMODULE_AUTHOR(\"Harald Welte <laforge@gnumonks.org>\");\nMODULE_AUTHOR(\"Martin Lucina <mato@kotelna.sk>\");\nMODULE_AUTHOR(\"Kenneth Chan <kenneth.t.chan@gmail.com>\");\nMODULE_DESCRIPTION(\"ACPI HotKey driver for Panasonic Let's Note laptops\");\nMODULE_LICENSE(\"GPL\");\n\n#define LOGPREFIX \"pcc_acpi: \"\n\n \n \n#define METHOD_HKEY_QUERY\t\"HINF\"\n#define METHOD_HKEY_SQTY\t\"SQTY\"\n#define METHOD_HKEY_SINF\t\"SINF\"\n#define METHOD_HKEY_SSET\t\"SSET\"\n#define METHOD_ECWR\t\t\"\\\\_SB.ECWR\"\n#define HKEY_NOTIFY\t\t0x80\n#define ECO_MODE_OFF\t\t0x00\n#define ECO_MODE_ON\t\t0x80\n\n#define ACPI_PCC_DRIVER_NAME\t\"Panasonic Laptop Support\"\n#define ACPI_PCC_DEVICE_NAME\t\"Hotkey\"\n#define ACPI_PCC_CLASS\t\t\"pcc\"\n\n#define ACPI_PCC_INPUT_PHYS\t\"panasonic/hkey0\"\n\n \nenum SINF_BITS { SINF_NUM_BATTERIES = 0,\n\t\t SINF_LCD_TYPE,\n\t\t SINF_AC_MAX_BRIGHT,\n\t\t SINF_AC_MIN_BRIGHT,\n\t\t SINF_AC_CUR_BRIGHT,\n\t\t SINF_DC_MAX_BRIGHT,\n\t\t SINF_DC_MIN_BRIGHT,\n\t\t SINF_DC_CUR_BRIGHT,\n\t\t SINF_MUTE,\n\t\t SINF_RESERVED,\n\t\t SINF_ECO_MODE = 0x0A,\n\t\t SINF_CUR_BRIGHT = 0x0D,\n\t\t SINF_STICKY_KEY = 0x80,\n\t};\n \n\nstatic int acpi_pcc_hotkey_add(struct acpi_device *device);\nstatic void acpi_pcc_hotkey_remove(struct acpi_device *device);\nstatic void acpi_pcc_hotkey_notify(struct acpi_device *device, u32 event);\n\nstatic const struct acpi_device_id pcc_device_ids[] = {\n\t{ \"MAT0012\", 0},\n\t{ \"MAT0013\", 0},\n\t{ \"MAT0018\", 0},\n\t{ \"MAT0019\", 0},\n\t{ \"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, pcc_device_ids);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acpi_pcc_hotkey_resume(struct device *dev);\n#endif\nstatic SIMPLE_DEV_PM_OPS(acpi_pcc_hotkey_pm, NULL, acpi_pcc_hotkey_resume);\n\nstatic struct acpi_driver acpi_pcc_driver = {\n\t.name =\t\tACPI_PCC_DRIVER_NAME,\n\t.class =\tACPI_PCC_CLASS,\n\t.ids =\t\tpcc_device_ids,\n\t.ops =\t\t{\n\t\t\t\t.add =\t\tacpi_pcc_hotkey_add,\n\t\t\t\t.remove =\tacpi_pcc_hotkey_remove,\n\t\t\t\t.notify =\tacpi_pcc_hotkey_notify,\n\t\t\t},\n\t.drv.pm =\t&acpi_pcc_hotkey_pm,\n};\n\nstatic const struct key_entry panasonic_keymap[] = {\n\t{ KE_KEY, 0, { KEY_RESERVED } },\n\t{ KE_KEY, 1, { KEY_BRIGHTNESSDOWN } },\n\t{ KE_KEY, 2, { KEY_BRIGHTNESSUP } },\n\t{ KE_KEY, 3, { KEY_DISPLAYTOGGLE } },\n\t{ KE_KEY, 4, { KEY_MUTE } },\n\t{ KE_KEY, 5, { KEY_VOLUMEDOWN } },\n\t{ KE_KEY, 6, { KEY_VOLUMEUP } },\n\t{ KE_KEY, 7, { KEY_SLEEP } },\n\t{ KE_KEY, 8, { KEY_PROG1 } },  \n\t{ KE_KEY, 9, { KEY_BATTERY } },\n\t{ KE_KEY, 10, { KEY_SUSPEND } },\n\t{ KE_END, 0 }\n};\n\nstruct pcc_acpi {\n\tacpi_handle\t\thandle;\n\tunsigned long\t\tnum_sifr;\n\tint\t\t\tsticky_key;\n\tint\t\t\teco_mode;\n\tint\t\t\tmute;\n\tint\t\t\tac_brightness;\n\tint\t\t\tdc_brightness;\n\tint\t\t\tcurrent_brightness;\n\tu32\t\t\t*sinf;\n\tstruct acpi_device\t*device;\n\tstruct input_dev\t*input_dev;\n\tstruct backlight_device\t*backlight;\n\tstruct platform_device\t*platform;\n};\n\n \nstatic bool panasonic_i8042_filter(unsigned char data, unsigned char str,\n\t\t\t\t   struct serio *port)\n{\n\tstatic bool extended;\n\n\tif (str & I8042_STR_AUXDATA)\n\t\treturn false;\n\n\tif (data == 0xe0) {\n\t\textended = true;\n\t\treturn true;\n\t} else if (extended) {\n\t\textended = false;\n\n\t\tswitch (data & 0x7f) {\n\t\tcase 0x20:  \n\t\tcase 0x2e:  \n\t\tcase 0x30:  \n\t\t\treturn true;\n\t\tdefault:\n\t\t\t \n\t\t\tserio_interrupt(port, 0xe0, 0);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic int acpi_pcc_write_sset(struct pcc_acpi *pcc, int func, int val)\n{\n\tunion acpi_object in_objs[] = {\n\t\t{ .integer.type  = ACPI_TYPE_INTEGER,\n\t\t  .integer.value = func, },\n\t\t{ .integer.type  = ACPI_TYPE_INTEGER,\n\t\t  .integer.value = val, },\n\t};\n\tstruct acpi_object_list params = {\n\t\t.count   = ARRAY_SIZE(in_objs),\n\t\t.pointer = in_objs,\n\t};\n\tacpi_status status = AE_OK;\n\n\tstatus = acpi_evaluate_object(pcc->handle, METHOD_HKEY_SSET,\n\t\t\t\t      &params, NULL);\n\n\treturn (status == AE_OK) ? 0 : -EIO;\n}\n\nstatic inline int acpi_pcc_get_sqty(struct acpi_device *device)\n{\n\tunsigned long long s;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(device->handle, METHOD_HKEY_SQTY,\n\t\t\t\t       NULL, &s);\n\tif (ACPI_SUCCESS(status))\n\t\treturn s;\n\telse {\n\t\tpr_err(\"evaluation error HKEY.SQTY\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int acpi_pcc_retrieve_biosdata(struct pcc_acpi *pcc)\n{\n\tacpi_status status;\n\tstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\n\tunion acpi_object *hkey = NULL;\n\tint i;\n\n\tstatus = acpi_evaluate_object(pcc->handle, METHOD_HKEY_SINF, NULL,\n\t\t\t\t      &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"evaluation error HKEY.SINF\\n\");\n\t\treturn 0;\n\t}\n\n\thkey = buffer.pointer;\n\tif (!hkey || (hkey->type != ACPI_TYPE_PACKAGE)) {\n\t\tpr_err(\"Invalid HKEY.SINF\\n\");\n\t\tstatus = AE_ERROR;\n\t\tgoto end;\n\t}\n\n\tif (pcc->num_sifr < hkey->package.count) {\n\t\tpr_err(\"SQTY reports bad SINF length\\n\");\n\t\tstatus = AE_ERROR;\n\t\tgoto end;\n\t}\n\n\tfor (i = 0; i < hkey->package.count; i++) {\n\t\tunion acpi_object *element = &(hkey->package.elements[i]);\n\t\tif (likely(element->type == ACPI_TYPE_INTEGER)) {\n\t\t\tpcc->sinf[i] = element->integer.value;\n\t\t} else\n\t\t\tpr_err(\"Invalid HKEY.SINF data\\n\");\n\t}\n\tpcc->sinf[hkey->package.count] = -1;\n\nend:\n\tkfree(buffer.pointer);\n\treturn status == AE_OK;\n}\n\n \n\n \n\nstatic int bl_get(struct backlight_device *bd)\n{\n\tstruct pcc_acpi *pcc = bl_get_data(bd);\n\n\tif (!acpi_pcc_retrieve_biosdata(pcc))\n\t\treturn -EIO;\n\n\treturn pcc->sinf[SINF_AC_CUR_BRIGHT];\n}\n\nstatic int bl_set_status(struct backlight_device *bd)\n{\n\tstruct pcc_acpi *pcc = bl_get_data(bd);\n\tint bright = bd->props.brightness;\n\tint rc;\n\n\tif (!acpi_pcc_retrieve_biosdata(pcc))\n\t\treturn -EIO;\n\n\tif (bright < pcc->sinf[SINF_AC_MIN_BRIGHT])\n\t\tbright = pcc->sinf[SINF_AC_MIN_BRIGHT];\n\n\tif (bright < pcc->sinf[SINF_DC_MIN_BRIGHT])\n\t\tbright = pcc->sinf[SINF_DC_MIN_BRIGHT];\n\n\tif (bright < pcc->sinf[SINF_AC_MIN_BRIGHT] ||\n\t    bright > pcc->sinf[SINF_AC_MAX_BRIGHT])\n\t\treturn -EINVAL;\n\n\trc = acpi_pcc_write_sset(pcc, SINF_AC_CUR_BRIGHT, bright);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn acpi_pcc_write_sset(pcc, SINF_DC_CUR_BRIGHT, bright);\n}\n\nstatic const struct backlight_ops pcc_backlight_ops = {\n\t.get_brightness\t= bl_get,\n\t.update_status\t= bl_set_status,\n};\n\n\n \n\nstatic acpi_status check_optd_present(void)\n{\n\tacpi_status status = AE_OK;\n\tacpi_handle handle;\n\n\tstatus = acpi_get_handle(NULL, \"\\\\_SB.STAT\", &handle);\n\tif (ACPI_FAILURE(status))\n\t\tgoto out;\n\tstatus = acpi_get_handle(NULL, \"\\\\_SB.FBAY\", &handle);\n\tif (ACPI_FAILURE(status))\n\t\tgoto out;\n\tstatus = acpi_get_handle(NULL, \"\\\\_SB.CDDI\", &handle);\n\tif (ACPI_FAILURE(status))\n\t\tgoto out;\n\nout:\n\treturn status;\n}\n\n \n\nstatic int get_optd_power_state(void)\n{\n\tacpi_status status;\n\tunsigned long long state;\n\tint result;\n\n\tstatus = acpi_evaluate_integer(NULL, \"\\\\_SB.STAT\", NULL, &state);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"evaluation error _SB.STAT\\n\");\n\t\tresult = -EIO;\n\t\tgoto out;\n\t}\n\tswitch (state) {\n\tcase 0:  \n\t\tresult = 0;\n\t\tbreak;\n\tcase 0x0f:  \n\t\tresult = 1;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EIO;\n\t\tbreak;\n\t}\n\nout:\n\treturn result;\n}\n\n \n\nstatic int set_optd_power_state(int new_state)\n{\n\tint result;\n\tacpi_status status;\n\n\tresult = get_optd_power_state();\n\tif (result < 0)\n\t\tgoto out;\n\tif (new_state == result)\n\t\tgoto out;\n\n\tswitch (new_state) {\n\tcase 0:  \n\t\t \n\t\tstatus = acpi_evaluate_object(NULL, \"\\\\_SB.CDDR\", NULL, NULL);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tpr_err(\"evaluation error _SB.CDDR\\n\");\n\t\t\tresult = -EIO;\n\t\t}\n\t\tbreak;\n\tcase 1:  \n\t\tstatus = acpi_evaluate_object(NULL, \"\\\\_SB.FBAY\", NULL, NULL);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tpr_err(\"evaluation error _SB.FBAY\\n\");\n\t\t\tresult = -EIO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\treturn result;\n}\n\n\n \n\nstatic ssize_t numbatt_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\n\tif (!acpi_pcc_retrieve_biosdata(pcc))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%u\\n\", pcc->sinf[SINF_NUM_BATTERIES]);\n}\n\nstatic ssize_t lcdtype_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\n\tif (!acpi_pcc_retrieve_biosdata(pcc))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%u\\n\", pcc->sinf[SINF_LCD_TYPE]);\n}\n\nstatic ssize_t mute_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\n\tif (!acpi_pcc_retrieve_biosdata(pcc))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%u\\n\", pcc->sinf[SINF_MUTE]);\n}\n\nstatic ssize_t mute_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\tint err, val;\n\n\terr = kstrtoint(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\tif (val == 0 || val == 1) {\n\t\tacpi_pcc_write_sset(pcc, SINF_MUTE, val);\n\t\tpcc->mute = val;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t sticky_key_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\n\tif (!acpi_pcc_retrieve_biosdata(pcc))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%u\\n\", pcc->sticky_key);\n}\n\nstatic ssize_t sticky_key_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\tint err, val;\n\n\terr = kstrtoint(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\tif (val == 0 || val == 1) {\n\t\tacpi_pcc_write_sset(pcc, SINF_STICKY_KEY, val);\n\t\tpcc->sticky_key = val;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t eco_mode_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\tint result;\n\n\tif (!acpi_pcc_retrieve_biosdata(pcc))\n\t\treturn -EIO;\n\n\tswitch (pcc->sinf[SINF_ECO_MODE]) {\n\tcase (ECO_MODE_OFF + 3):\n\t\tresult = 0;\n\t\tbreak;\n\tcase (ECO_MODE_ON + 3):\n\t\tresult = 1;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EIO;\n\t\tbreak;\n\t}\n\treturn sysfs_emit(buf, \"%u\\n\", result);\n}\n\nstatic ssize_t eco_mode_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\tint err, state;\n\n\tunion acpi_object param[2];\n\tstruct acpi_object_list input;\n\tacpi_status status;\n\n\tparam[0].type = ACPI_TYPE_INTEGER;\n\tparam[0].integer.value = 0x15;\n\tparam[1].type = ACPI_TYPE_INTEGER;\n\tinput.count = 2;\n\tinput.pointer = param;\n\n\terr = kstrtoint(buf, 0, &state);\n\tif (err)\n\t\treturn err;\n\n\tswitch (state) {\n\tcase 0:\n\t\tparam[1].integer.value = ECO_MODE_OFF;\n\t\tpcc->sinf[SINF_ECO_MODE] = 0;\n\t\tpcc->eco_mode = 0;\n\t\tbreak;\n\tcase 1:\n\t\tparam[1].integer.value = ECO_MODE_ON;\n\t\tpcc->sinf[SINF_ECO_MODE] = 1;\n\t\tpcc->eco_mode = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn count;\n\t}\n\n\tstatus = acpi_evaluate_object(NULL, METHOD_ECWR,\n\t\t\t\t       &input, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"%s evaluation failed\\n\", METHOD_ECWR);\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t ac_brightness_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\n\tif (!acpi_pcc_retrieve_biosdata(pcc))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%u\\n\", pcc->sinf[SINF_AC_CUR_BRIGHT]);\n}\n\nstatic ssize_t ac_brightness_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\tint err, val;\n\n\terr = kstrtoint(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\tif (val >= 0 && val <= 255) {\n\t\tacpi_pcc_write_sset(pcc, SINF_AC_CUR_BRIGHT, val);\n\t\tpcc->ac_brightness = val;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t dc_brightness_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\n\tif (!acpi_pcc_retrieve_biosdata(pcc))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%u\\n\", pcc->sinf[SINF_DC_CUR_BRIGHT]);\n}\n\nstatic ssize_t dc_brightness_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\tint err, val;\n\n\terr = kstrtoint(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\tif (val >= 0 && val <= 255) {\n\t\tacpi_pcc_write_sset(pcc, SINF_DC_CUR_BRIGHT, val);\n\t\tpcc->dc_brightness = val;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t current_brightness_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\n\tif (!acpi_pcc_retrieve_biosdata(pcc))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%u\\n\", pcc->sinf[SINF_CUR_BRIGHT]);\n}\n\nstatic ssize_t current_brightness_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct acpi_device *acpi = to_acpi_device(dev);\n\tstruct pcc_acpi *pcc = acpi_driver_data(acpi);\n\tint err, val;\n\n\terr = kstrtoint(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val >= 0 && val <= 255) {\n\t\terr = acpi_pcc_write_sset(pcc, SINF_CUR_BRIGHT, val);\n\t\tpcc->current_brightness = val;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t cdpower_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", get_optd_power_state());\n}\n\nstatic ssize_t cdpower_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tint err, val;\n\n\terr = kstrtoint(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tset_optd_power_state(val);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RO(numbatt);\nstatic DEVICE_ATTR_RO(lcdtype);\nstatic DEVICE_ATTR_RW(mute);\nstatic DEVICE_ATTR_RW(sticky_key);\nstatic DEVICE_ATTR_RW(eco_mode);\nstatic DEVICE_ATTR_RW(ac_brightness);\nstatic DEVICE_ATTR_RW(dc_brightness);\nstatic DEVICE_ATTR_RW(current_brightness);\nstatic DEVICE_ATTR_RW(cdpower);\n\nstatic struct attribute *pcc_sysfs_entries[] = {\n\t&dev_attr_numbatt.attr,\n\t&dev_attr_lcdtype.attr,\n\t&dev_attr_mute.attr,\n\t&dev_attr_sticky_key.attr,\n\t&dev_attr_eco_mode.attr,\n\t&dev_attr_ac_brightness.attr,\n\t&dev_attr_dc_brightness.attr,\n\t&dev_attr_current_brightness.attr,\n\t&dev_attr_cdpower.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group pcc_attr_group = {\n\t.name\t= NULL,\t\t \n\t.attrs\t= pcc_sysfs_entries,\n};\n\n\n \n\nstatic int sleep_keydown_seen;\nstatic void acpi_pcc_generate_keyinput(struct pcc_acpi *pcc)\n{\n\tstruct input_dev *hotk_input_dev = pcc->input_dev;\n\tint rc;\n\tunsigned long long result;\n\tunsigned int key;\n\tunsigned int updown;\n\n\trc = acpi_evaluate_integer(pcc->handle, METHOD_HKEY_QUERY,\n\t\t\t\t   NULL, &result);\n\tif (ACPI_FAILURE(rc)) {\n\t\tpr_err(\"error getting hotkey status\\n\");\n\t\treturn;\n\t}\n\n\tkey = result & 0xf;\n\tupdown = result & 0x80;  \n\n\t \n\tif (key == 7 || key == 10) {\n\t\tif (updown)\n\t\t\tsleep_keydown_seen = 1;\n\t\tif (!sleep_keydown_seen)\n\t\t\tsparse_keymap_report_event(hotk_input_dev,\n\t\t\t\t\tkey, 0x80, false);\n\t}\n\n\t \n\tif ((key == 1 || key == 2) && acpi_video_handles_brightness_key_presses())\n\t\treturn;\n\n\tif (!sparse_keymap_report_event(hotk_input_dev, key, updown, false))\n\t\tpr_err(\"Unknown hotkey event: 0x%04llx\\n\", result);\n}\n\nstatic void acpi_pcc_hotkey_notify(struct acpi_device *device, u32 event)\n{\n\tstruct pcc_acpi *pcc = acpi_driver_data(device);\n\n\tswitch (event) {\n\tcase HKEY_NOTIFY:\n\t\tacpi_pcc_generate_keyinput(pcc);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic void pcc_optd_notify(acpi_handle handle, u32 event, void *data)\n{\n\tif (event != ACPI_NOTIFY_EJECT_REQUEST)\n\t\treturn;\n\n\tset_optd_power_state(0);\n}\n\nstatic int pcc_register_optd_notifier(struct pcc_acpi *pcc, char *node)\n{\n\tacpi_status status;\n\tacpi_handle handle;\n\n\tstatus = acpi_get_handle(NULL, node, &handle);\n\n\tif (ACPI_SUCCESS(status)) {\n\t\tstatus = acpi_install_notify_handler(handle,\n\t\t\t\tACPI_SYSTEM_NOTIFY,\n\t\t\t\tpcc_optd_notify, pcc);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tpr_err(\"Failed to register notify on %s\\n\", node);\n\t} else\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void pcc_unregister_optd_notifier(struct pcc_acpi *pcc, char *node)\n{\n\tacpi_status status = AE_OK;\n\tacpi_handle handle;\n\n\tstatus = acpi_get_handle(NULL, node, &handle);\n\n\tif (ACPI_SUCCESS(status)) {\n\t\tstatus = acpi_remove_notify_handler(handle,\n\t\t\t\tACPI_SYSTEM_NOTIFY,\n\t\t\t\tpcc_optd_notify);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tpr_err(\"Error removing optd notify handler %s\\n\",\n\t\t\t\t\tnode);\n\t}\n}\n\nstatic int acpi_pcc_init_input(struct pcc_acpi *pcc)\n{\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tinput_dev->name = ACPI_PCC_DRIVER_NAME;\n\tinput_dev->phys = ACPI_PCC_INPUT_PHYS;\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->id.vendor = 0x0001;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0100;\n\n\terror = sparse_keymap_setup(input_dev, panasonic_keymap, NULL);\n\tif (error) {\n\t\tpr_err(\"Unable to setup input device keymap\\n\");\n\t\tgoto err_free_dev;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tpr_err(\"Unable to register input device\\n\");\n\t\tgoto err_free_dev;\n\t}\n\n\tpcc->input_dev = input_dev;\n\treturn 0;\n\n err_free_dev:\n\tinput_free_device(input_dev);\n\treturn error;\n}\n\n \n\n#ifdef CONFIG_PM_SLEEP\nstatic int acpi_pcc_hotkey_resume(struct device *dev)\n{\n\tstruct pcc_acpi *pcc;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tpcc = acpi_driver_data(to_acpi_device(dev));\n\tif (!pcc)\n\t\treturn -EINVAL;\n\n\tacpi_pcc_write_sset(pcc, SINF_MUTE, pcc->mute);\n\tacpi_pcc_write_sset(pcc, SINF_ECO_MODE, pcc->eco_mode);\n\tacpi_pcc_write_sset(pcc, SINF_STICKY_KEY, pcc->sticky_key);\n\tacpi_pcc_write_sset(pcc, SINF_AC_CUR_BRIGHT, pcc->ac_brightness);\n\tacpi_pcc_write_sset(pcc, SINF_DC_CUR_BRIGHT, pcc->dc_brightness);\n\tacpi_pcc_write_sset(pcc, SINF_CUR_BRIGHT, pcc->current_brightness);\n\n\treturn 0;\n}\n#endif\n\nstatic int acpi_pcc_hotkey_add(struct acpi_device *device)\n{\n\tstruct backlight_properties props;\n\tstruct pcc_acpi *pcc;\n\tint num_sifr, result;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tnum_sifr = acpi_pcc_get_sqty(device);\n\n\tif (num_sifr < 0 || num_sifr > 255) {\n\t\tpr_err(\"num_sifr out of range\");\n\t\treturn -ENODEV;\n\t}\n\n\tpcc = kzalloc(sizeof(struct pcc_acpi), GFP_KERNEL);\n\tif (!pcc) {\n\t\tpr_err(\"Couldn't allocate mem for pcc\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpcc->sinf = kcalloc(num_sifr + 1, sizeof(u32), GFP_KERNEL);\n\tif (!pcc->sinf) {\n\t\tresult = -ENOMEM;\n\t\tgoto out_hotkey;\n\t}\n\n\tpcc->device = device;\n\tpcc->handle = device->handle;\n\tpcc->num_sifr = num_sifr;\n\tdevice->driver_data = pcc;\n\tstrcpy(acpi_device_name(device), ACPI_PCC_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_PCC_CLASS);\n\n\tresult = acpi_pcc_init_input(pcc);\n\tif (result) {\n\t\tpr_err(\"Error installing keyinput handler\\n\");\n\t\tgoto out_sinf;\n\t}\n\n\tif (!acpi_pcc_retrieve_biosdata(pcc)) {\n\t\tresult = -EIO;\n\t\tpr_err(\"Couldn't retrieve BIOS data\\n\");\n\t\tgoto out_input;\n\t}\n\n\tif (acpi_video_get_backlight_type() == acpi_backlight_vendor) {\n\t\t \n\t\tmemset(&props, 0, sizeof(struct backlight_properties));\n\t\tprops.type = BACKLIGHT_PLATFORM;\n\t\tprops.max_brightness = pcc->sinf[SINF_AC_MAX_BRIGHT];\n\n\t\tpcc->backlight = backlight_device_register(\"panasonic\", NULL, pcc,\n\t\t\t\t\t\t\t   &pcc_backlight_ops, &props);\n\t\tif (IS_ERR(pcc->backlight)) {\n\t\t\tresult = PTR_ERR(pcc->backlight);\n\t\t\tgoto out_input;\n\t\t}\n\n\t\t \n\t\tpcc->backlight->props.brightness = pcc->sinf[SINF_AC_CUR_BRIGHT];\n\t}\n\n\t \n\tacpi_pcc_write_sset(pcc, SINF_STICKY_KEY, 0);\n\tpcc->sticky_key = 0;\n\n\tpcc->eco_mode = pcc->sinf[SINF_ECO_MODE];\n\tpcc->mute = pcc->sinf[SINF_MUTE];\n\tpcc->ac_brightness = pcc->sinf[SINF_AC_CUR_BRIGHT];\n\tpcc->dc_brightness = pcc->sinf[SINF_DC_CUR_BRIGHT];\n\tpcc->current_brightness = pcc->sinf[SINF_CUR_BRIGHT];\n\n\t \n\tresult = sysfs_create_group(&device->dev.kobj, &pcc_attr_group);\n\tif (result)\n\t\tgoto out_backlight;\n\n\t \n\tif (ACPI_SUCCESS(check_optd_present())) {\n\t\tpcc->platform = platform_device_register_simple(\"panasonic\",\n\t\t\tPLATFORM_DEVID_NONE, NULL, 0);\n\t\tif (IS_ERR(pcc->platform)) {\n\t\t\tresult = PTR_ERR(pcc->platform);\n\t\t\tgoto out_backlight;\n\t\t}\n\t\tresult = device_create_file(&pcc->platform->dev,\n\t\t\t&dev_attr_cdpower);\n\t\tpcc_register_optd_notifier(pcc, \"\\\\_SB.PCI0.EHCI.ERHB.OPTD\");\n\t\tif (result)\n\t\t\tgoto out_platform;\n\t} else {\n\t\tpcc->platform = NULL;\n\t}\n\n\ti8042_install_filter(panasonic_i8042_filter);\n\treturn 0;\n\nout_platform:\n\tplatform_device_unregister(pcc->platform);\nout_backlight:\n\tbacklight_device_unregister(pcc->backlight);\nout_input:\n\tinput_unregister_device(pcc->input_dev);\nout_sinf:\n\tkfree(pcc->sinf);\nout_hotkey:\n\tkfree(pcc);\n\n\treturn result;\n}\n\nstatic void acpi_pcc_hotkey_remove(struct acpi_device *device)\n{\n\tstruct pcc_acpi *pcc = acpi_driver_data(device);\n\n\tif (!device || !pcc)\n\t\treturn;\n\n\ti8042_remove_filter(panasonic_i8042_filter);\n\n\tif (pcc->platform) {\n\t\tdevice_remove_file(&pcc->platform->dev, &dev_attr_cdpower);\n\t\tplatform_device_unregister(pcc->platform);\n\t}\n\tpcc_unregister_optd_notifier(pcc, \"\\\\_SB.PCI0.EHCI.ERHB.OPTD\");\n\n\tsysfs_remove_group(&device->dev.kobj, &pcc_attr_group);\n\n\tbacklight_device_unregister(pcc->backlight);\n\n\tinput_unregister_device(pcc->input_dev);\n\n\tkfree(pcc->sinf);\n\tkfree(pcc);\n}\n\nmodule_acpi_driver(acpi_pcc_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}