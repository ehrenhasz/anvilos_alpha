{
  "module_name": "fujitsu-tablet.c",
  "hash_id": "b79e1d893b5a0c0f2de70a14f016b675bbae3adc9d5798da40005955d5ce9bfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/fujitsu-tablet.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n\n#define MODULENAME \"fujitsu-tablet\"\n\n#define ACPI_FUJITSU_CLASS \"fujitsu\"\n\n#define INVERT_TABLET_MODE_BIT      0x01\n#define INVERT_DOCK_STATE_BIT       0x02\n#define FORCE_TABLET_MODE_IF_UNDOCK 0x04\n\n#define KEYMAP_LEN 16\n\nstatic const struct acpi_device_id fujitsu_ids[] = {\n\t{ .id = \"FUJ02BD\" },\n\t{ .id = \"FUJ02BF\" },\n\t{ .id = \"\" }\n};\n\nstruct fujitsu_config {\n\tunsigned short keymap[KEYMAP_LEN];\n\tunsigned int quirks;\n};\n\nstatic unsigned short keymap_Lifebook_Tseries[KEYMAP_LEN] __initdata = {\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_SCROLLDOWN,\n\tKEY_SCROLLUP,\n\tKEY_ROTATE_DISPLAY,\n\tKEY_LEFTCTRL,\n\tKEY_BRIGHTNESSUP,\n\tKEY_BRIGHTNESSDOWN,\n\tKEY_BRIGHTNESS_ZERO,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_LEFTALT\n};\n\nstatic unsigned short keymap_Lifebook_T901[KEYMAP_LEN] __initdata = {\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_SCROLLDOWN,\n\tKEY_SCROLLUP,\n\tKEY_CYCLEWINDOWS,\n\tKEY_LEFTCTRL,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_LEFTMETA\n};\n\nstatic unsigned short keymap_Lifebook_T902[KEYMAP_LEN] __initdata = {\n\tKEY_RESERVED,\n\tKEY_VOLUMEDOWN,\n\tKEY_VOLUMEUP,\n\tKEY_CYCLEWINDOWS,\n\tKEY_PROG1,\n\tKEY_PROG2,\n\tKEY_LEFTMETA,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n};\n\nstatic unsigned short keymap_Lifebook_U810[KEYMAP_LEN] __initdata = {\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_PROG1,\n\tKEY_PROG2,\n\tKEY_ROTATE_DISPLAY,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_UP,\n\tKEY_DOWN,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_LEFTCTRL,\n\tKEY_LEFTALT\n};\n\nstatic unsigned short keymap_Stylistic_Tseries[KEYMAP_LEN] __initdata = {\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_PRINT,\n\tKEY_BACKSPACE,\n\tKEY_SPACE,\n\tKEY_ENTER,\n\tKEY_BRIGHTNESSUP,\n\tKEY_BRIGHTNESSDOWN,\n\tKEY_DOWN,\n\tKEY_UP,\n\tKEY_SCROLLUP,\n\tKEY_SCROLLDOWN,\n\tKEY_LEFTCTRL,\n\tKEY_LEFTALT\n};\n\nstatic unsigned short keymap_Stylistic_ST5xxx[KEYMAP_LEN] __initdata = {\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_MAIL,\n\tKEY_ROTATE_DISPLAY,\n\tKEY_ESC,\n\tKEY_ENTER,\n\tKEY_BRIGHTNESSUP,\n\tKEY_BRIGHTNESSDOWN,\n\tKEY_DOWN,\n\tKEY_UP,\n\tKEY_SCROLLUP,\n\tKEY_SCROLLDOWN,\n\tKEY_LEFTCTRL,\n\tKEY_LEFTALT\n};\n\nstatic struct {\n\tstruct input_dev *idev;\n\tstruct fujitsu_config config;\n\tunsigned long prev_keymask;\n\n\tchar phys[21];\n\n\tint irq;\n\tint io_base;\n\tint io_length;\n} fujitsu;\n\nstatic u8 fujitsu_ack(void)\n{\n\treturn inb(fujitsu.io_base + 2);\n}\n\nstatic u8 fujitsu_status(void)\n{\n\treturn inb(fujitsu.io_base + 6);\n}\n\nstatic u8 fujitsu_read_register(const u8 addr)\n{\n\toutb(addr, fujitsu.io_base);\n\treturn inb(fujitsu.io_base + 4);\n}\n\nstatic void fujitsu_send_state(void)\n{\n\tint state;\n\tint dock, tablet_mode;\n\n\tstate = fujitsu_read_register(0xdd);\n\n\tdock = state & 0x02;\n\tif (fujitsu.config.quirks & INVERT_DOCK_STATE_BIT)\n\t\tdock = !dock;\n\n\tif ((fujitsu.config.quirks & FORCE_TABLET_MODE_IF_UNDOCK) && (!dock)) {\n\t\ttablet_mode = 1;\n\t} else{\n\t\ttablet_mode = state & 0x01;\n\t\tif (fujitsu.config.quirks & INVERT_TABLET_MODE_BIT)\n\t\t\ttablet_mode = !tablet_mode;\n\t}\n\n\tinput_report_switch(fujitsu.idev, SW_DOCK, dock);\n\tinput_report_switch(fujitsu.idev, SW_TABLET_MODE, tablet_mode);\n\tinput_sync(fujitsu.idev);\n}\n\nstatic void fujitsu_reset(void)\n{\n\tint timeout = 50;\n\n\tfujitsu_ack();\n\n\twhile ((fujitsu_status() & 0x02) && (--timeout))\n\t\tmsleep(20);\n\n\tfujitsu_send_state();\n}\n\nstatic int input_fujitsu_setup(struct device *parent, const char *name,\n\t\t\t       const char *phys)\n{\n\tstruct input_dev *idev;\n\tint error;\n\tint i;\n\n\tidev = input_allocate_device();\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tidev->dev.parent = parent;\n\tidev->phys = phys;\n\tidev->name = name;\n\tidev->id.bustype = BUS_HOST;\n\tidev->id.vendor  = 0x1734;\t \n\tidev->id.product = 0x0001;\n\tidev->id.version = 0x0101;\n\n\tidev->keycode = fujitsu.config.keymap;\n\tidev->keycodesize = sizeof(fujitsu.config.keymap[0]);\n\tidev->keycodemax = ARRAY_SIZE(fujitsu.config.keymap);\n\n\t__set_bit(EV_REP, idev->evbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(fujitsu.config.keymap); i++)\n\t\tif (fujitsu.config.keymap[i])\n\t\t\tinput_set_capability(idev, EV_KEY, fujitsu.config.keymap[i]);\n\n\tinput_set_capability(idev, EV_MSC, MSC_SCAN);\n\n\tinput_set_capability(idev, EV_SW, SW_DOCK);\n\tinput_set_capability(idev, EV_SW, SW_TABLET_MODE);\n\n\terror = input_register_device(idev);\n\tif (error) {\n\t\tinput_free_device(idev);\n\t\treturn error;\n\t}\n\n\tfujitsu.idev = idev;\n\treturn 0;\n}\n\nstatic void input_fujitsu_remove(void)\n{\n\tinput_unregister_device(fujitsu.idev);\n}\n\nstatic irqreturn_t fujitsu_interrupt(int irq, void *dev_id)\n{\n\tunsigned long keymask, changed;\n\tunsigned int keycode;\n\tint pressed;\n\tint i;\n\n\tif (unlikely(!(fujitsu_status() & 0x01)))\n\t\treturn IRQ_NONE;\n\n\tfujitsu_send_state();\n\n\tkeymask  = fujitsu_read_register(0xde);\n\tkeymask |= fujitsu_read_register(0xdf) << 8;\n\tkeymask ^= 0xffff;\n\n\tchanged = keymask ^ fujitsu.prev_keymask;\n\tif (changed) {\n\t\tfujitsu.prev_keymask = keymask;\n\n\t\tfor_each_set_bit(i, &changed, KEYMAP_LEN) {\n\t\t\tkeycode = fujitsu.config.keymap[i];\n\t\t\tpressed = keymask & changed & BIT(i);\n\n\t\t\tif (pressed)\n\t\t\t\tinput_event(fujitsu.idev, EV_MSC, MSC_SCAN, i);\n\n\t\t\tinput_report_key(fujitsu.idev, keycode, pressed);\n\t\t\tinput_sync(fujitsu.idev);\n\t\t}\n\t}\n\n\tfujitsu_ack();\n\treturn IRQ_HANDLED;\n}\n\nstatic void __init fujitsu_dmi_common(const struct dmi_system_id *dmi)\n{\n\tpr_info(\"%s\\n\", dmi->ident);\n\tmemcpy(fujitsu.config.keymap, dmi->driver_data,\n\t\t\tsizeof(fujitsu.config.keymap));\n}\n\nstatic int __init fujitsu_dmi_lifebook(const struct dmi_system_id *dmi)\n{\n\tfujitsu_dmi_common(dmi);\n\tfujitsu.config.quirks |= INVERT_TABLET_MODE_BIT;\n\treturn 1;\n}\n\nstatic int __init fujitsu_dmi_stylistic(const struct dmi_system_id *dmi)\n{\n\tfujitsu_dmi_common(dmi);\n\tfujitsu.config.quirks |= FORCE_TABLET_MODE_IF_UNDOCK;\n\tfujitsu.config.quirks |= INVERT_DOCK_STATE_BIT;\n\treturn 1;\n}\n\nstatic const struct dmi_system_id dmi_ids[] __initconst = {\n\t{\n\t\t.callback = fujitsu_dmi_lifebook,\n\t\t.ident = \"Fujitsu Lifebook T901\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LifeBook T901\")\n\t\t},\n\t\t.driver_data = keymap_Lifebook_T901\n\t},\n\t{\n\t\t.callback = fujitsu_dmi_lifebook,\n\t\t.ident = \"Fujitsu Lifebook T901\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK T901\")\n\t\t},\n\t\t.driver_data = keymap_Lifebook_T901\n\t},\n\t{\n\t\t.callback = fujitsu_dmi_lifebook,\n\t\t.ident = \"Fujitsu Lifebook T902\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK T902\")\n\t\t},\n\t\t.driver_data = keymap_Lifebook_T902\n\t},\n\t{\n\t\t.callback = fujitsu_dmi_lifebook,\n\t\t.ident = \"Fujitsu Siemens P/T Series\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK\")\n\t\t},\n\t\t.driver_data = keymap_Lifebook_Tseries\n\t},\n\t{\n\t\t.callback = fujitsu_dmi_lifebook,\n\t\t.ident = \"Fujitsu Lifebook T Series\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LifeBook T\")\n\t\t},\n\t\t.driver_data = keymap_Lifebook_Tseries\n\t},\n\t{\n\t\t.callback = fujitsu_dmi_stylistic,\n\t\t.ident = \"Fujitsu Siemens Stylistic T Series\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Stylistic T\")\n\t\t},\n\t\t.driver_data = keymap_Stylistic_Tseries\n\t},\n\t{\n\t\t.callback = fujitsu_dmi_lifebook,\n\t\t.ident = \"Fujitsu LifeBook U810\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LifeBook U810\")\n\t\t},\n\t\t.driver_data = keymap_Lifebook_U810\n\t},\n\t{\n\t\t.callback = fujitsu_dmi_stylistic,\n\t\t.ident = \"Fujitsu Siemens Stylistic ST5xxx Series\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"STYLISTIC ST5\")\n\t\t},\n\t\t.driver_data = keymap_Stylistic_ST5xxx\n\t},\n\t{\n\t\t.callback = fujitsu_dmi_stylistic,\n\t\t.ident = \"Fujitsu Siemens Stylistic ST5xxx Series\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Stylistic ST5\")\n\t\t},\n\t\t.driver_data = keymap_Stylistic_ST5xxx\n\t},\n\t{\n\t\t.callback = fujitsu_dmi_lifebook,\n\t\t.ident = \"Unknown (using defaults)\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"\")\n\t\t},\n\t\t.driver_data = keymap_Lifebook_Tseries\n\t},\n\t{ NULL }\n};\n\nstatic acpi_status fujitsu_walk_resources(struct acpi_resource *res, void *data)\n{\n\tswitch (res->type) {\n\tcase ACPI_RESOURCE_TYPE_IRQ:\n\t\tfujitsu.irq = res->data.irq.interrupts[0];\n\t\treturn AE_OK;\n\n\tcase ACPI_RESOURCE_TYPE_IO:\n\t\tfujitsu.io_base = res->data.io.minimum;\n\t\tfujitsu.io_length = res->data.io.address_length;\n\t\treturn AE_OK;\n\n\tcase ACPI_RESOURCE_TYPE_END_TAG:\n\t\tif (fujitsu.irq && fujitsu.io_base)\n\t\t\treturn AE_OK;\n\t\telse\n\t\t\treturn AE_NOT_FOUND;\n\n\tdefault:\n\t\treturn AE_ERROR;\n\t}\n}\n\nstatic int acpi_fujitsu_add(struct acpi_device *adev)\n{\n\tacpi_status status;\n\tint error;\n\n\tif (!adev)\n\t\treturn -EINVAL;\n\n\tstatus = acpi_walk_resources(adev->handle, METHOD_NAME__CRS,\n\t\t\tfujitsu_walk_resources, NULL);\n\tif (ACPI_FAILURE(status) || !fujitsu.irq || !fujitsu.io_base)\n\t\treturn -ENODEV;\n\n\tsprintf(acpi_device_name(adev), \"Fujitsu %s\", acpi_device_hid(adev));\n\tsprintf(acpi_device_class(adev), \"%s\", ACPI_FUJITSU_CLASS);\n\n\tsnprintf(fujitsu.phys, sizeof(fujitsu.phys),\n\t\t\t\"%s/input0\", acpi_device_hid(adev));\n\n\terror = input_fujitsu_setup(&adev->dev,\n\t\tacpi_device_name(adev), fujitsu.phys);\n\tif (error)\n\t\treturn error;\n\n\tif (!request_region(fujitsu.io_base, fujitsu.io_length, MODULENAME)) {\n\t\tinput_fujitsu_remove();\n\t\treturn -EBUSY;\n\t}\n\n\tfujitsu_reset();\n\n\terror = request_irq(fujitsu.irq, fujitsu_interrupt,\n\t\t\tIRQF_SHARED, MODULENAME, fujitsu_interrupt);\n\tif (error) {\n\t\trelease_region(fujitsu.io_base, fujitsu.io_length);\n\t\tinput_fujitsu_remove();\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void acpi_fujitsu_remove(struct acpi_device *adev)\n{\n\tfree_irq(fujitsu.irq, fujitsu_interrupt);\n\trelease_region(fujitsu.io_base, fujitsu.io_length);\n\tinput_fujitsu_remove();\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acpi_fujitsu_resume(struct device *dev)\n{\n\tfujitsu_reset();\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(acpi_fujitsu_pm, NULL, acpi_fujitsu_resume);\n\nstatic struct acpi_driver acpi_fujitsu_driver = {\n\t.name  = MODULENAME,\n\t.class = \"hotkey\",\n\t.ids   = fujitsu_ids,\n\t.ops   = {\n\t\t.add    = acpi_fujitsu_add,\n\t\t.remove\t= acpi_fujitsu_remove,\n\t},\n\t.drv.pm = &acpi_fujitsu_pm,\n};\n\nstatic int __init fujitsu_module_init(void)\n{\n\tint error;\n\n\tdmi_check_system(dmi_ids);\n\n\terror = acpi_bus_register_driver(&acpi_fujitsu_driver);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic void __exit fujitsu_module_exit(void)\n{\n\tacpi_bus_unregister_driver(&acpi_fujitsu_driver);\n}\n\nmodule_init(fujitsu_module_init);\nmodule_exit(fujitsu_module_exit);\n\nMODULE_AUTHOR(\"Robert Gerlach <khnz@gmx.de>\");\nMODULE_DESCRIPTION(\"Fujitsu tablet pc extras driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"2.5\");\n\nMODULE_DEVICE_TABLE(acpi, fujitsu_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}