{
  "module_name": "system76_acpi.c",
  "hash_id": "c8376de0234c45ce2941c298d7e278f1d383bf18eff8cbc35c482c76de9a8405",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/system76_acpi.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/pci_ids.h>\n#include <linux/power_supply.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n\n#include <acpi/battery.h>\n\nenum kbled_type {\n\tKBLED_NONE,\n\tKBLED_WHITE,\n\tKBLED_RGB,\n};\n\nstruct system76_data {\n\tstruct acpi_device *acpi_dev;\n\tstruct led_classdev ap_led;\n\tstruct led_classdev kb_led;\n\tenum led_brightness kb_brightness;\n\tenum led_brightness kb_toggle_brightness;\n\tint kb_color;\n\tstruct device *therm;\n\tunion acpi_object *nfan;\n\tunion acpi_object *ntmp;\n\tstruct input_dev *input;\n\tbool has_open_ec;\n\tenum kbled_type kbled_type;\n};\n\nstatic const struct acpi_device_id device_ids[] = {\n\t{\"17761776\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, device_ids);\n\n\nstatic const enum led_brightness kb_levels[] = {\n\t48,\n\t72,\n\t96,\n\t144,\n\t192,\n\t255\n};\n\n\nstatic const int kb_colors[] = {\n\t0xFFFFFF,\n\t0x0000FF,\n\t0xFF0000,\n\t0xFF00FF,\n\t0x00FF00,\n\t0x00FFFF,\n\t0xFFFF00\n};\n\n\nstatic int system76_get(struct system76_data *data, char *method)\n{\n\tacpi_handle handle;\n\tacpi_status status;\n\tunsigned long long ret = 0;\n\n\thandle = acpi_device_handle(data->acpi_dev);\n\tstatus = acpi_evaluate_integer(handle, method, NULL, &ret);\n\tif (ACPI_SUCCESS(status))\n\t\treturn ret;\n\treturn -ENODEV;\n}\n\n\nstatic int system76_get_index(struct system76_data *data, char *method, int index)\n{\n\tunion acpi_object obj;\n\tstruct acpi_object_list obj_list;\n\tacpi_handle handle;\n\tacpi_status status;\n\tunsigned long long ret = 0;\n\n\tobj.type = ACPI_TYPE_INTEGER;\n\tobj.integer.value = index;\n\tobj_list.count = 1;\n\tobj_list.pointer = &obj;\n\n\thandle = acpi_device_handle(data->acpi_dev);\n\tstatus = acpi_evaluate_integer(handle, method, &obj_list, &ret);\n\tif (ACPI_SUCCESS(status))\n\t\treturn ret;\n\treturn -ENODEV;\n}\n\n\nstatic int system76_get_object(struct system76_data *data, char *method, union acpi_object **obj)\n{\n\tacpi_handle handle;\n\tacpi_status status;\n\tstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\thandle = acpi_device_handle(data->acpi_dev);\n\tstatus = acpi_evaluate_object(handle, method, NULL, &buf);\n\tif (ACPI_SUCCESS(status)) {\n\t\t*obj = buf.pointer;\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\n\nstatic char *system76_name(union acpi_object *obj, int index)\n{\n\tif (obj && obj->type == ACPI_TYPE_PACKAGE && index <= obj->package.count) {\n\t\tif (obj->package.elements[index].type == ACPI_TYPE_STRING)\n\t\t\treturn obj->package.elements[index].string.pointer;\n\t}\n\n\treturn NULL;\n}\n\n\nstatic int system76_set(struct system76_data *data, char *method, int value)\n{\n\tunion acpi_object obj;\n\tstruct acpi_object_list obj_list;\n\tacpi_handle handle;\n\tacpi_status status;\n\n\tobj.type = ACPI_TYPE_INTEGER;\n\tobj.integer.value = value;\n\tobj_list.count = 1;\n\tobj_list.pointer = &obj;\n\thandle = acpi_device_handle(data->acpi_dev);\n\tstatus = acpi_evaluate_object(handle, method, &obj_list, NULL);\n\tif (ACPI_SUCCESS(status))\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\n#define BATTERY_THRESHOLD_INVALID\t0xFF\n\nenum {\n\tTHRESHOLD_START,\n\tTHRESHOLD_END,\n};\n\nstatic ssize_t battery_get_threshold(int which, char *buf)\n{\n\tstruct acpi_object_list input;\n\tunion acpi_object param;\n\tacpi_handle handle;\n\tacpi_status status;\n\tunsigned long long ret = BATTERY_THRESHOLD_INVALID;\n\n\thandle = ec_get_handle();\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tinput.count = 1;\n\tinput.pointer = &param;\n\t\n\tparam.type = ACPI_TYPE_INTEGER;\n\tparam.integer.value = which;\n\n\tstatus = acpi_evaluate_integer(handle, \"GBCT\", &input, &ret);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\tif (ret == BATTERY_THRESHOLD_INVALID)\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"%d\\n\", (int)ret);\n}\n\nstatic ssize_t battery_set_threshold(int which, const char *buf, size_t count)\n{\n\tstruct acpi_object_list input;\n\tunion acpi_object params[2];\n\tacpi_handle handle;\n\tacpi_status status;\n\tunsigned int value;\n\tint ret;\n\n\thandle = ec_get_handle();\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tret = kstrtouint(buf, 10, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value > 100)\n\t\treturn -EINVAL;\n\n\tinput.count = 2;\n\tinput.pointer = params;\n\t\n\tparams[0].type = ACPI_TYPE_INTEGER;\n\tparams[0].integer.value = which;\n\t\n\tparams[1].type = ACPI_TYPE_INTEGER;\n\tparams[1].integer.value = value;\n\n\tstatus = acpi_evaluate_object(handle, \"SBCT\", &input, NULL);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic ssize_t charge_control_start_threshold_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\treturn battery_get_threshold(THRESHOLD_START, buf);\n}\n\nstatic ssize_t charge_control_start_threshold_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn battery_set_threshold(THRESHOLD_START, buf, count);\n}\n\nstatic DEVICE_ATTR_RW(charge_control_start_threshold);\n\nstatic ssize_t charge_control_end_threshold_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\treturn battery_get_threshold(THRESHOLD_END, buf);\n}\n\nstatic ssize_t charge_control_end_threshold_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn battery_set_threshold(THRESHOLD_END, buf, count);\n}\n\nstatic DEVICE_ATTR_RW(charge_control_end_threshold);\n\nstatic struct attribute *system76_battery_attrs[] = {\n\t&dev_attr_charge_control_start_threshold.attr,\n\t&dev_attr_charge_control_end_threshold.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(system76_battery);\n\nstatic int system76_battery_add(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\t\n\tif (strcmp(battery->desc->name, \"BAT0\") != 0)\n\t\treturn -ENODEV;\n\n\tif (device_add_groups(&battery->dev, system76_battery_groups))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int system76_battery_remove(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\tdevice_remove_groups(&battery->dev, system76_battery_groups);\n\treturn 0;\n}\n\nstatic struct acpi_battery_hook system76_battery_hook = {\n\t.add_battery = system76_battery_add,\n\t.remove_battery = system76_battery_remove,\n\t.name = \"System76 Battery Extension\",\n};\n\nstatic void system76_battery_init(void)\n{\n\tbattery_hook_register(&system76_battery_hook);\n}\n\nstatic void system76_battery_exit(void)\n{\n\tbattery_hook_unregister(&system76_battery_hook);\n}\n\n\nstatic enum led_brightness ap_led_get(struct led_classdev *led)\n{\n\tstruct system76_data *data;\n\tint value;\n\n\tdata = container_of(led, struct system76_data, ap_led);\n\tvalue = system76_get(data, \"GAPL\");\n\tif (value > 0)\n\t\treturn (enum led_brightness)value;\n\telse\n\t\treturn LED_OFF;\n}\n\n\nstatic int ap_led_set(struct led_classdev *led, enum led_brightness value)\n{\n\tstruct system76_data *data;\n\n\tdata = container_of(led, struct system76_data, ap_led);\n\treturn system76_set(data, \"SAPL\", value == LED_OFF ? 0 : 1);\n}\n\n\nstatic enum led_brightness kb_led_get(struct led_classdev *led)\n{\n\tstruct system76_data *data;\n\n\tdata = container_of(led, struct system76_data, kb_led);\n\treturn data->kb_brightness;\n}\n\n\nstatic int kb_led_set(struct led_classdev *led, enum led_brightness value)\n{\n\tstruct system76_data *data;\n\n\tdata = container_of(led, struct system76_data, kb_led);\n\tdata->kb_brightness = value;\n\tif (acpi_has_method(acpi_device_handle(data->acpi_dev), \"GKBK\")) {\n\t\treturn system76_set(data, \"SKBB\", (int)data->kb_brightness);\n\t} else {\n\t\treturn system76_set(data, \"SKBL\", (int)data->kb_brightness);\n\t}\n}\n\n\nstatic ssize_t kb_led_color_show(\n\tstruct device *dev,\n\tstruct device_attribute *dev_attr,\n\tchar *buf)\n{\n\tstruct led_classdev *led;\n\tstruct system76_data *data;\n\n\tled = dev_get_drvdata(dev);\n\tdata = container_of(led, struct system76_data, kb_led);\n\treturn sysfs_emit(buf, \"%06X\\n\", data->kb_color);\n}\n\n\nstatic ssize_t kb_led_color_store(\n\tstruct device *dev,\n\tstruct device_attribute *dev_attr,\n\tconst char *buf,\n\tsize_t size)\n{\n\tstruct led_classdev *led;\n\tstruct system76_data *data;\n\tunsigned int val;\n\tint ret;\n\n\tled = dev_get_drvdata(dev);\n\tdata = container_of(led, struct system76_data, kb_led);\n\tret = kstrtouint(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val > 0xFFFFFF)\n\t\treturn -EINVAL;\n\tdata->kb_color = (int)val;\n\tsystem76_set(data, \"SKBC\", data->kb_color);\n\n\treturn size;\n}\n\nstatic struct device_attribute dev_attr_kb_led_color = {\n\t.attr = {\n\t\t.name = \"color\",\n\t\t.mode = 0644,\n\t},\n\t.show = kb_led_color_show,\n\t.store = kb_led_color_store,\n};\n\nstatic struct attribute *system76_kb_led_color_attrs[] = {\n\t&dev_attr_kb_led_color.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(system76_kb_led_color);\n\n\nstatic void kb_led_notify(struct system76_data *data)\n{\n\tled_classdev_notify_brightness_hw_changed(\n\t\t&data->kb_led,\n\t\tdata->kb_brightness\n\t);\n}\n\n\nstatic void kb_led_hotkey_hardware(struct system76_data *data)\n{\n\tint value;\n\n\tif (acpi_has_method(acpi_device_handle(data->acpi_dev), \"GKBK\")) {\n\t\tvalue = system76_get(data, \"GKBB\");\n\t} else {\n\t\tvalue = system76_get(data, \"GKBL\");\n\t}\n\n\tif (value < 0)\n\t\treturn;\n\tdata->kb_brightness = value;\n\tkb_led_notify(data);\n}\n\n\nstatic void kb_led_hotkey_toggle(struct system76_data *data)\n{\n\tif (data->kb_brightness > 0) {\n\t\tdata->kb_toggle_brightness = data->kb_brightness;\n\t\tkb_led_set(&data->kb_led, 0);\n\t} else {\n\t\tkb_led_set(&data->kb_led, data->kb_toggle_brightness);\n\t}\n\tkb_led_notify(data);\n}\n\n\nstatic void kb_led_hotkey_down(struct system76_data *data)\n{\n\tint i;\n\n\tif (data->kb_brightness > 0) {\n\t\tfor (i = ARRAY_SIZE(kb_levels); i > 0; i--) {\n\t\t\tif (kb_levels[i - 1] < data->kb_brightness) {\n\t\t\t\tkb_led_set(&data->kb_led, kb_levels[i - 1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tkb_led_set(&data->kb_led, data->kb_toggle_brightness);\n\t}\n\tkb_led_notify(data);\n}\n\n\nstatic void kb_led_hotkey_up(struct system76_data *data)\n{\n\tint i;\n\n\tif (data->kb_brightness > 0) {\n\t\tfor (i = 0; i < ARRAY_SIZE(kb_levels); i++) {\n\t\t\tif (kb_levels[i] > data->kb_brightness) {\n\t\t\t\tkb_led_set(&data->kb_led, kb_levels[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tkb_led_set(&data->kb_led, data->kb_toggle_brightness);\n\t}\n\tkb_led_notify(data);\n}\n\n\nstatic void kb_led_hotkey_color(struct system76_data *data)\n{\n\tint i;\n\n\tif (data->kbled_type != KBLED_RGB)\n\t\treturn;\n\n\tif (data->kb_brightness > 0) {\n\t\tfor (i = 0; i < ARRAY_SIZE(kb_colors); i++) {\n\t\t\tif (kb_colors[i] == data->kb_color)\n\t\t\t\tbreak;\n\t\t}\n\t\ti += 1;\n\t\tif (i >= ARRAY_SIZE(kb_colors))\n\t\t\ti = 0;\n\t\tdata->kb_color = kb_colors[i];\n\t\tsystem76_set(data, \"SKBC\", data->kb_color);\n\t} else {\n\t\tkb_led_set(&data->kb_led, data->kb_toggle_brightness);\n\t}\n\tkb_led_notify(data);\n}\n\nstatic umode_t thermal_is_visible(const void *drvdata, enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\tconst struct system76_data *data = drvdata;\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\tcase hwmon_pwm:\n\t\tif (system76_name(data->nfan, channel))\n\t\t\treturn 0444;\n\t\tbreak;\n\n\tcase hwmon_temp:\n\t\tif (system76_name(data->ntmp, channel))\n\t\t\treturn 0444;\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int thermal_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\tint channel, long *val)\n{\n\tstruct system76_data *data = dev_get_drvdata(dev);\n\tint raw;\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\tif (attr == hwmon_fan_input) {\n\t\t\traw = system76_get_index(data, \"GFAN\", channel);\n\t\t\tif (raw < 0)\n\t\t\t\treturn raw;\n\t\t\t*val = (raw >> 8) & 0xFFFF;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_pwm:\n\t\tif (attr == hwmon_pwm_input) {\n\t\t\traw = system76_get_index(data, \"GFAN\", channel);\n\t\t\tif (raw < 0)\n\t\t\t\treturn raw;\n\t\t\t*val = raw & 0xFF;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_temp:\n\t\tif (attr == hwmon_temp_input) {\n\t\t\traw = system76_get_index(data, \"GTMP\", channel);\n\t\t\tif (raw < 0)\n\t\t\t\treturn raw;\n\t\t\t*val = raw * 1000;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int thermal_read_string(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t       int channel, const char **str)\n{\n\tstruct system76_data *data = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\tif (attr == hwmon_fan_label) {\n\t\t\t*str = system76_name(data->nfan, channel);\n\t\t\tif (*str)\n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase hwmon_temp:\n\t\tif (attr == hwmon_temp_label) {\n\t\t\t*str = system76_name(data->ntmp, channel);\n\t\t\tif (*str)\n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct hwmon_ops thermal_ops = {\n\t.is_visible = thermal_is_visible,\n\t.read = thermal_read,\n\t.read_string = thermal_read_string,\n};\n\n\nstatic const struct hwmon_channel_info * const thermal_channel_info[] = {\n\tHWMON_CHANNEL_INFO(fan,\n\t\tHWMON_F_INPUT | HWMON_F_LABEL,\n\t\tHWMON_F_INPUT | HWMON_F_LABEL,\n\t\tHWMON_F_INPUT | HWMON_F_LABEL,\n\t\tHWMON_F_INPUT | HWMON_F_LABEL,\n\t\tHWMON_F_INPUT | HWMON_F_LABEL,\n\t\tHWMON_F_INPUT | HWMON_F_LABEL,\n\t\tHWMON_F_INPUT | HWMON_F_LABEL,\n\t\tHWMON_F_INPUT | HWMON_F_LABEL),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\tHWMON_PWM_INPUT,\n\t\tHWMON_PWM_INPUT,\n\t\tHWMON_PWM_INPUT,\n\t\tHWMON_PWM_INPUT,\n\t\tHWMON_PWM_INPUT,\n\t\tHWMON_PWM_INPUT,\n\t\tHWMON_PWM_INPUT,\n\t\tHWMON_PWM_INPUT),\n\tHWMON_CHANNEL_INFO(temp,\n\t\tHWMON_T_INPUT | HWMON_T_LABEL,\n\t\tHWMON_T_INPUT | HWMON_T_LABEL,\n\t\tHWMON_T_INPUT | HWMON_T_LABEL,\n\t\tHWMON_T_INPUT | HWMON_T_LABEL,\n\t\tHWMON_T_INPUT | HWMON_T_LABEL,\n\t\tHWMON_T_INPUT | HWMON_T_LABEL,\n\t\tHWMON_T_INPUT | HWMON_T_LABEL,\n\t\tHWMON_T_INPUT | HWMON_T_LABEL),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info thermal_chip_info = {\n\t.ops = &thermal_ops,\n\t.info = thermal_channel_info,\n};\n\nstatic void input_key(struct system76_data *data, unsigned int code)\n{\n\tinput_report_key(data->input, code, 1);\n\tinput_sync(data->input);\n\n\tinput_report_key(data->input, code, 0);\n\tinput_sync(data->input);\n}\n\n\nstatic void system76_notify(struct acpi_device *acpi_dev, u32 event)\n{\n\tstruct system76_data *data;\n\n\tdata = acpi_driver_data(acpi_dev);\n\tswitch (event) {\n\tcase 0x80:\n\t\tkb_led_hotkey_hardware(data);\n\t\tbreak;\n\tcase 0x81:\n\t\tkb_led_hotkey_toggle(data);\n\t\tbreak;\n\tcase 0x82:\n\t\tkb_led_hotkey_down(data);\n\t\tbreak;\n\tcase 0x83:\n\t\tkb_led_hotkey_up(data);\n\t\tbreak;\n\tcase 0x84:\n\t\tkb_led_hotkey_color(data);\n\t\tbreak;\n\tcase 0x85:\n\t\tinput_key(data, KEY_SCREENLOCK);\n\t\tbreak;\n\t}\n}\n\n\nstatic int system76_add(struct acpi_device *acpi_dev)\n{\n\tstruct system76_data *data;\n\tint err;\n\n\tdata = devm_kzalloc(&acpi_dev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tacpi_dev->driver_data = data;\n\tdata->acpi_dev = acpi_dev;\n\n\t\n\t\n\tdata->has_open_ec = acpi_has_method(acpi_device_handle(data->acpi_dev), \"NFAN\");\n\n\terr = system76_get(data, \"INIT\");\n\tif (err)\n\t\treturn err;\n\tdata->ap_led.name = \"system76_acpi::airplane\";\n\tdata->ap_led.flags = LED_CORE_SUSPENDRESUME;\n\tdata->ap_led.brightness_get = ap_led_get;\n\tdata->ap_led.brightness_set_blocking = ap_led_set;\n\tdata->ap_led.max_brightness = 1;\n\tdata->ap_led.default_trigger = \"rfkill-none\";\n\terr = devm_led_classdev_register(&acpi_dev->dev, &data->ap_led);\n\tif (err)\n\t\treturn err;\n\n\tdata->kb_led.name = \"system76_acpi::kbd_backlight\";\n\tdata->kb_led.flags = LED_BRIGHT_HW_CHANGED | LED_CORE_SUSPENDRESUME;\n\tdata->kb_led.brightness_get = kb_led_get;\n\tdata->kb_led.brightness_set_blocking = kb_led_set;\n\tif (acpi_has_method(acpi_device_handle(data->acpi_dev), \"GKBK\")) {\n\t\t\n\t\tdata->kbled_type = system76_get(data, \"GKBK\");\n\n\t\tswitch (data->kbled_type) {\n\t\tcase KBLED_NONE:\n\t\t\t\n\t\t\tbreak;\n\t\tcase KBLED_WHITE:\n\t\t\tdata->kb_led.max_brightness = 255;\n\t\t\tdata->kb_toggle_brightness = 72;\n\t\t\tbreak;\n\t\tcase KBLED_RGB:\n\t\t\tdata->kb_led.max_brightness = 255;\n\t\t\tdata->kb_led.groups = system76_kb_led_color_groups;\n\t\t\tdata->kb_toggle_brightness = 72;\n\t\t\tdata->kb_color = 0xffffff;\n\t\t\tsystem76_set(data, \"SKBC\", data->kb_color);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t\n\t\tif (acpi_has_method(acpi_device_handle(data->acpi_dev), \"SKBC\")) {\n\t\t\tdata->kbled_type = KBLED_RGB;\n\t\t\tdata->kb_led.max_brightness = 255;\n\t\t\tdata->kb_led.groups = system76_kb_led_color_groups;\n\t\t\tdata->kb_toggle_brightness = 72;\n\t\t\tdata->kb_color = 0xffffff;\n\t\t\tsystem76_set(data, \"SKBC\", data->kb_color);\n\t\t} else {\n\t\t\tdata->kbled_type = KBLED_WHITE;\n\t\t\tdata->kb_led.max_brightness = 5;\n\t\t}\n\t}\n\n\tif (data->kbled_type != KBLED_NONE) {\n\t\terr = devm_led_classdev_register(&acpi_dev->dev, &data->kb_led);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdata->input = devm_input_allocate_device(&acpi_dev->dev);\n\tif (!data->input)\n\t\treturn -ENOMEM;\n\n\tdata->input->name = \"System76 ACPI Hotkeys\";\n\tdata->input->phys = \"system76_acpi/input0\";\n\tdata->input->id.bustype = BUS_HOST;\n\tdata->input->dev.parent = &acpi_dev->dev;\n\tinput_set_capability(data->input, EV_KEY, KEY_SCREENLOCK);\n\n\terr = input_register_device(data->input);\n\tif (err)\n\t\tgoto error;\n\n\tif (data->has_open_ec) {\n\t\terr = system76_get_object(data, \"NFAN\", &data->nfan);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\terr = system76_get_object(data, \"NTMP\", &data->ntmp);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\tdata->therm = devm_hwmon_device_register_with_info(&acpi_dev->dev,\n\t\t\t\"system76_acpi\", data, &thermal_chip_info, NULL);\n\t\terr = PTR_ERR_OR_ZERO(data->therm);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\tsystem76_battery_init();\n\t}\n\n\treturn 0;\n\nerror:\n\tif (data->has_open_ec) {\n\t\tkfree(data->ntmp);\n\t\tkfree(data->nfan);\n\t}\n\treturn err;\n}\n\n\nstatic void system76_remove(struct acpi_device *acpi_dev)\n{\n\tstruct system76_data *data;\n\n\tdata = acpi_driver_data(acpi_dev);\n\n\tif (data->has_open_ec) {\n\t\tsystem76_battery_exit();\n\t\tkfree(data->nfan);\n\t\tkfree(data->ntmp);\n\t}\n\n\tdevm_led_classdev_unregister(&acpi_dev->dev, &data->ap_led);\n\tdevm_led_classdev_unregister(&acpi_dev->dev, &data->kb_led);\n\n\tsystem76_get(data, \"FINI\");\n}\n\nstatic struct acpi_driver system76_driver = {\n\t.name = \"System76 ACPI Driver\",\n\t.class = \"hotkey\",\n\t.ids = device_ids,\n\t.ops = {\n\t\t.add = system76_add,\n\t\t.remove = system76_remove,\n\t\t.notify = system76_notify,\n\t},\n};\nmodule_acpi_driver(system76_driver);\n\nMODULE_DESCRIPTION(\"System76 ACPI Driver\");\nMODULE_AUTHOR(\"Jeremy Soller <jeremy@system76.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}