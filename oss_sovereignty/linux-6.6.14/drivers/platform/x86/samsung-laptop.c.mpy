{
  "module_name": "samsung-laptop.c",
  "hash_id": "a1fff026157768a32e1f20e51ae6d63742d824b6e2112f45ad4862871f01c2a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/samsung-laptop.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/backlight.h>\n#include <linux/leds.h>\n#include <linux/fb.h>\n#include <linux/dmi.h>\n#include <linux/platform_device.h>\n#include <linux/rfkill.h>\n#include <linux/acpi.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/efi.h>\n#include <linux/suspend.h>\n#include <acpi/video.h>\n\n \n\n \n#define MAX_BRIGHT\t0x07\n\n\n#define SABI_IFACE_MAIN\t\t\t0x00\n#define SABI_IFACE_SUB\t\t\t0x02\n#define SABI_IFACE_COMPLETE\t\t0x04\n#define SABI_IFACE_DATA\t\t\t0x05\n\n#define WL_STATUS_WLAN\t\t\t0x0\n#define WL_STATUS_BT\t\t\t0x2\n\n \nstruct sabi_data {\n\tunion {\n\t\tstruct {\n\t\t\tu32 d0;\n\t\t\tu32 d1;\n\t\t\tu16 d2;\n\t\t\tu8  d3;\n\t\t};\n\t\tu8 data[11];\n\t};\n};\n\nstruct sabi_header_offsets {\n\tu8 port;\n\tu8 re_mem;\n\tu8 iface_func;\n\tu8 en_mem;\n\tu8 data_offset;\n\tu8 data_segment;\n};\n\nstruct sabi_commands {\n\t \n\tu16 get_brightness;\n\tu16 set_brightness;\n\n\t \n\tu16 get_wireless_button;\n\tu16 set_wireless_button;\n\n\t \n\tu16 get_backlight;\n\tu16 set_backlight;\n\n\t \n\tu16 get_recovery_mode;\n\tu16 set_recovery_mode;\n\n\t \n\tu16 get_performance_level;\n\tu16 set_performance_level;\n\n\t \n\tu16 get_battery_life_extender;\n\tu16 set_battery_life_extender;\n\n\t \n\tu16 get_usb_charge;\n\tu16 set_usb_charge;\n\n\t \n\tu16 get_wireless_status;\n\tu16 set_wireless_status;\n\n\t \n\tu16 get_lid_handling;\n\tu16 set_lid_handling;\n\n\t \n\tu16 kbd_backlight;\n\n\t \n\tu16 set_linux;\n};\n\nstruct sabi_performance_level {\n\tconst char *name;\n\tu16 value;\n};\n\nstruct sabi_config {\n\tint sabi_version;\n\tconst char *test_string;\n\tu16 main_function;\n\tconst struct sabi_header_offsets header_offsets;\n\tconst struct sabi_commands commands;\n\tconst struct sabi_performance_level performance_levels[4];\n\tu8 min_brightness;\n\tu8 max_brightness;\n};\n\nstatic const struct sabi_config sabi_configs[] = {\n\t{\n\t\t \n\t\t.sabi_version = 2,\n\n\t\t.test_string = \"SECLINUX\",\n\n\t\t.main_function = 0x4c49,\n\n\t\t.header_offsets = {\n\t\t\t.port = 0x00,\n\t\t\t.re_mem = 0x02,\n\t\t\t.iface_func = 0x03,\n\t\t\t.en_mem = 0x04,\n\t\t\t.data_offset = 0x05,\n\t\t\t.data_segment = 0x07,\n\t\t},\n\n\t\t.commands = {\n\t\t\t.get_brightness = 0x00,\n\t\t\t.set_brightness = 0x01,\n\n\t\t\t.get_wireless_button = 0x02,\n\t\t\t.set_wireless_button = 0x03,\n\n\t\t\t.get_backlight = 0x04,\n\t\t\t.set_backlight = 0x05,\n\n\t\t\t.get_recovery_mode = 0x06,\n\t\t\t.set_recovery_mode = 0x07,\n\n\t\t\t.get_performance_level = 0x08,\n\t\t\t.set_performance_level = 0x09,\n\n\t\t\t.get_battery_life_extender = 0xFFFF,\n\t\t\t.set_battery_life_extender = 0xFFFF,\n\n\t\t\t.get_usb_charge = 0xFFFF,\n\t\t\t.set_usb_charge = 0xFFFF,\n\n\t\t\t.get_wireless_status = 0xFFFF,\n\t\t\t.set_wireless_status = 0xFFFF,\n\n\t\t\t.get_lid_handling = 0xFFFF,\n\t\t\t.set_lid_handling = 0xFFFF,\n\n\t\t\t.kbd_backlight = 0xFFFF,\n\n\t\t\t.set_linux = 0x0a,\n\t\t},\n\n\t\t.performance_levels = {\n\t\t\t{\n\t\t\t\t.name = \"silent\",\n\t\t\t\t.value = 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.name = \"normal\",\n\t\t\t\t.value = 1,\n\t\t\t},\n\t\t\t{ },\n\t\t},\n\t\t.min_brightness = 1,\n\t\t.max_brightness = 8,\n\t},\n\t{\n\t\t.sabi_version = 3,\n\n\t\t.test_string = \"SwSmi@\",\n\n\t\t.main_function = 0x5843,\n\n\t\t.header_offsets = {\n\t\t\t.port = 0x00,\n\t\t\t.re_mem = 0x04,\n\t\t\t.iface_func = 0x02,\n\t\t\t.en_mem = 0x03,\n\t\t\t.data_offset = 0x05,\n\t\t\t.data_segment = 0x07,\n\t\t},\n\n\t\t.commands = {\n\t\t\t.get_brightness = 0x10,\n\t\t\t.set_brightness = 0x11,\n\n\t\t\t.get_wireless_button = 0x12,\n\t\t\t.set_wireless_button = 0x13,\n\n\t\t\t.get_backlight = 0x2d,\n\t\t\t.set_backlight = 0x2e,\n\n\t\t\t.get_recovery_mode = 0xff,\n\t\t\t.set_recovery_mode = 0xff,\n\n\t\t\t.get_performance_level = 0x31,\n\t\t\t.set_performance_level = 0x32,\n\n\t\t\t.get_battery_life_extender = 0x65,\n\t\t\t.set_battery_life_extender = 0x66,\n\n\t\t\t.get_usb_charge = 0x67,\n\t\t\t.set_usb_charge = 0x68,\n\n\t\t\t.get_wireless_status = 0x69,\n\t\t\t.set_wireless_status = 0x6a,\n\n\t\t\t.get_lid_handling = 0x6d,\n\t\t\t.set_lid_handling = 0x6e,\n\n\t\t\t.kbd_backlight = 0x78,\n\n\t\t\t.set_linux = 0xff,\n\t\t},\n\n\t\t.performance_levels = {\n\t\t\t{\n\t\t\t\t.name = \"normal\",\n\t\t\t\t.value = 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.name = \"silent\",\n\t\t\t\t.value = 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.name = \"overclock\",\n\t\t\t\t.value = 2,\n\t\t\t},\n\t\t\t{ },\n\t\t},\n\t\t.min_brightness = 0,\n\t\t.max_brightness = 8,\n\t},\n\t{ },\n};\n\n \n\nstruct samsung_laptop_debug {\n\tstruct dentry *root;\n\tstruct sabi_data data;\n\tu16 command;\n\n\tstruct debugfs_blob_wrapper f0000_wrapper;\n\tstruct debugfs_blob_wrapper data_wrapper;\n\tstruct debugfs_blob_wrapper sdiag_wrapper;\n};\n\nstruct samsung_laptop;\n\nstruct samsung_rfkill {\n\tstruct samsung_laptop *samsung;\n\tstruct rfkill *rfkill;\n\tenum rfkill_type type;\n};\n\nstruct samsung_laptop {\n\tconst struct sabi_config *config;\n\n\tvoid __iomem *sabi;\n\tvoid __iomem *sabi_iface;\n\tvoid __iomem *f0000_segment;\n\n\tstruct mutex sabi_mutex;\n\n\tstruct platform_device *platform_device;\n\tstruct backlight_device *backlight_device;\n\n\tstruct samsung_rfkill wlan;\n\tstruct samsung_rfkill bluetooth;\n\n\tstruct led_classdev kbd_led;\n\tint kbd_led_wk;\n\tstruct workqueue_struct *led_workqueue;\n\tstruct work_struct kbd_led_work;\n\n\tstruct samsung_laptop_debug debug;\n\tstruct samsung_quirks *quirks;\n\n\tstruct notifier_block pm_nb;\n\n\tbool handle_backlight;\n\tbool has_stepping_quirk;\n\n\tchar sdiag[64];\n};\n\nstruct samsung_quirks {\n\tbool four_kbd_backlight_levels;\n\tbool enable_kbd_backlight;\n\tbool lid_handling;\n};\n\nstatic struct samsung_quirks samsung_unknown = {};\n\nstatic struct samsung_quirks samsung_np740u3e = {\n\t.four_kbd_backlight_levels = true,\n\t.enable_kbd_backlight = true,\n};\n\nstatic struct samsung_quirks samsung_lid_handling = {\n\t.lid_handling = true,\n};\n\nstatic bool force;\nmodule_param(force, bool, 0);\nMODULE_PARM_DESC(force,\n\t\t\"Disable the DMI check and forces the driver to be loaded\");\n\nstatic bool debug;\nmodule_param(debug, bool, 0644);\nMODULE_PARM_DESC(debug, \"Debug enabled or not\");\n\nstatic int sabi_command(struct samsung_laptop *samsung, u16 command,\n\t\t\tstruct sabi_data *in,\n\t\t\tstruct sabi_data *out)\n{\n\tconst struct sabi_config *config = samsung->config;\n\tint ret = 0;\n\tu16 port = readw(samsung->sabi + config->header_offsets.port);\n\tu8 complete, iface_data;\n\n\tmutex_lock(&samsung->sabi_mutex);\n\n\tif (debug) {\n\t\tif (in)\n\t\t\tpr_info(\"SABI command:0x%04x \"\n\t\t\t\t\"data:{0x%08x, 0x%08x, 0x%04x, 0x%02x}\",\n\t\t\t\tcommand, in->d0, in->d1, in->d2, in->d3);\n\t\telse\n\t\t\tpr_info(\"SABI command:0x%04x\", command);\n\t}\n\n\t \n\toutb(readb(samsung->sabi + config->header_offsets.en_mem), port);\n\n\t \n\twritew(config->main_function, samsung->sabi_iface + SABI_IFACE_MAIN);\n\twritew(command, samsung->sabi_iface + SABI_IFACE_SUB);\n\twriteb(0, samsung->sabi_iface + SABI_IFACE_COMPLETE);\n\tif (in) {\n\t\twritel(in->d0, samsung->sabi_iface + SABI_IFACE_DATA);\n\t\twritel(in->d1, samsung->sabi_iface + SABI_IFACE_DATA + 4);\n\t\twritew(in->d2, samsung->sabi_iface + SABI_IFACE_DATA + 8);\n\t\twriteb(in->d3, samsung->sabi_iface + SABI_IFACE_DATA + 10);\n\t}\n\toutb(readb(samsung->sabi + config->header_offsets.iface_func), port);\n\n\t \n\toutb(readb(samsung->sabi + config->header_offsets.re_mem), port);\n\n\t \n\tcomplete = readb(samsung->sabi_iface + SABI_IFACE_COMPLETE);\n\tiface_data = readb(samsung->sabi_iface + SABI_IFACE_DATA);\n\n\t \n\tif (complete != 0xaa || (iface_data == 0xff && debug))\n\t\tpr_warn(\"SABI command 0x%04x failed with\"\n\t\t\t\" completion flag 0x%02x and interface data 0x%02x\",\n\t\t\tcommand, complete, iface_data);\n\n\tif (complete != 0xaa || iface_data == 0xff) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (out) {\n\t\tout->d0 = readl(samsung->sabi_iface + SABI_IFACE_DATA);\n\t\tout->d1 = readl(samsung->sabi_iface + SABI_IFACE_DATA + 4);\n\t\tout->d2 = readw(samsung->sabi_iface + SABI_IFACE_DATA + 2);\n\t\tout->d3 = readb(samsung->sabi_iface + SABI_IFACE_DATA + 1);\n\t}\n\n\tif (debug && out) {\n\t\tpr_info(\"SABI return data:{0x%08x, 0x%08x, 0x%04x, 0x%02x}\",\n\t\t\tout->d0, out->d1, out->d2, out->d3);\n\t}\n\nexit:\n\tmutex_unlock(&samsung->sabi_mutex);\n\treturn ret;\n}\n\n \nstatic int sabi_set_commandb(struct samsung_laptop *samsung,\n\t\t\t     u16 command, u8 data)\n{\n\tstruct sabi_data in = { { { .d0 = 0, .d1 = 0, .d2 = 0, .d3 = 0 } } };\n\n\tin.data[0] = data;\n\treturn sabi_command(samsung, command, &in, NULL);\n}\n\nstatic int read_brightness(struct samsung_laptop *samsung)\n{\n\tconst struct sabi_config *config = samsung->config;\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\tstruct sabi_data sretval;\n\tint user_brightness = 0;\n\tint retval;\n\n\tretval = sabi_command(samsung, commands->get_brightness,\n\t\t\t      NULL, &sretval);\n\tif (retval)\n\t\treturn retval;\n\n\tuser_brightness = sretval.data[0];\n\tif (user_brightness > config->min_brightness)\n\t\tuser_brightness -= config->min_brightness;\n\telse\n\t\tuser_brightness = 0;\n\n\treturn user_brightness;\n}\n\nstatic void set_brightness(struct samsung_laptop *samsung, u8 user_brightness)\n{\n\tconst struct sabi_config *config = samsung->config;\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\tu8 user_level = user_brightness + config->min_brightness;\n\n\tif (samsung->has_stepping_quirk && user_level != 0) {\n\t\t \n\t\tif (user_brightness == read_brightness(samsung))\n\t\t\treturn;\n\n\t\tsabi_set_commandb(samsung, commands->set_brightness, 0);\n\t}\n\n\tsabi_set_commandb(samsung, commands->set_brightness, user_level);\n}\n\nstatic int get_brightness(struct backlight_device *bd)\n{\n\tstruct samsung_laptop *samsung = bl_get_data(bd);\n\n\treturn read_brightness(samsung);\n}\n\nstatic void check_for_stepping_quirk(struct samsung_laptop *samsung)\n{\n\tint initial_level;\n\tint check_level;\n\tint orig_level = read_brightness(samsung);\n\n\t \n\n\tif (orig_level == 0)\n\t\tset_brightness(samsung, 1);\n\n\tinitial_level = read_brightness(samsung);\n\n\tif (initial_level <= 2)\n\t\tcheck_level = initial_level + 2;\n\telse\n\t\tcheck_level = initial_level - 2;\n\n\tsamsung->has_stepping_quirk = false;\n\tset_brightness(samsung, check_level);\n\n\tif (read_brightness(samsung) != check_level) {\n\t\tsamsung->has_stepping_quirk = true;\n\t\tpr_info(\"enabled workaround for brightness stepping quirk\\n\");\n\t}\n\n\tset_brightness(samsung, orig_level);\n}\n\nstatic int update_status(struct backlight_device *bd)\n{\n\tstruct samsung_laptop *samsung = bl_get_data(bd);\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\n\tset_brightness(samsung, bd->props.brightness);\n\n\tif (bd->props.power == FB_BLANK_UNBLANK)\n\t\tsabi_set_commandb(samsung, commands->set_backlight, 1);\n\telse\n\t\tsabi_set_commandb(samsung, commands->set_backlight, 0);\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops backlight_ops = {\n\t.get_brightness\t= get_brightness,\n\t.update_status\t= update_status,\n};\n\nstatic int seclinux_rfkill_set(void *data, bool blocked)\n{\n\tstruct samsung_rfkill *srfkill = data;\n\tstruct samsung_laptop *samsung = srfkill->samsung;\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\n\treturn sabi_set_commandb(samsung, commands->set_wireless_button,\n\t\t\t\t !blocked);\n}\n\nstatic const struct rfkill_ops seclinux_rfkill_ops = {\n\t.set_block = seclinux_rfkill_set,\n};\n\nstatic int swsmi_wireless_status(struct samsung_laptop *samsung,\n\t\t\t\t struct sabi_data *data)\n{\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\n\treturn sabi_command(samsung, commands->get_wireless_status,\n\t\t\t    NULL, data);\n}\n\nstatic int swsmi_rfkill_set(void *priv, bool blocked)\n{\n\tstruct samsung_rfkill *srfkill = priv;\n\tstruct samsung_laptop *samsung = srfkill->samsung;\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\tstruct sabi_data data;\n\tint ret, i;\n\n\tret = swsmi_wireless_status(samsung, &data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\tif (data.data[i] == 0x02)\n\t\t\tdata.data[1] = 0;\n\n\tif (srfkill->type == RFKILL_TYPE_WLAN)\n\t\tdata.data[WL_STATUS_WLAN] = !blocked;\n\telse if (srfkill->type == RFKILL_TYPE_BLUETOOTH)\n\t\tdata.data[WL_STATUS_BT] = !blocked;\n\n\treturn sabi_command(samsung, commands->set_wireless_status,\n\t\t\t    &data, &data);\n}\n\nstatic void swsmi_rfkill_query(struct rfkill *rfkill, void *priv)\n{\n\tstruct samsung_rfkill *srfkill = priv;\n\tstruct samsung_laptop *samsung = srfkill->samsung;\n\tstruct sabi_data data;\n\tint ret;\n\n\tret = swsmi_wireless_status(samsung, &data);\n\tif (ret)\n\t\treturn ;\n\n\tif (srfkill->type == RFKILL_TYPE_WLAN)\n\t\tret = data.data[WL_STATUS_WLAN];\n\telse if (srfkill->type == RFKILL_TYPE_BLUETOOTH)\n\t\tret = data.data[WL_STATUS_BT];\n\telse\n\t\treturn ;\n\n\trfkill_set_sw_state(rfkill, !ret);\n}\n\nstatic const struct rfkill_ops swsmi_rfkill_ops = {\n\t.set_block = swsmi_rfkill_set,\n\t.query = swsmi_rfkill_query,\n};\n\nstatic ssize_t get_performance_level(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct samsung_laptop *samsung = dev_get_drvdata(dev);\n\tconst struct sabi_config *config = samsung->config;\n\tconst struct sabi_commands *commands = &config->commands;\n\tstruct sabi_data sretval;\n\tint retval;\n\tint i;\n\n\t \n\tretval = sabi_command(samsung, commands->get_performance_level,\n\t\t\t      NULL, &sretval);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tfor (i = 0; config->performance_levels[i].name; ++i) {\n\t\tif (sretval.data[0] == config->performance_levels[i].value)\n\t\t\treturn sprintf(buf, \"%s\\n\", config->performance_levels[i].name);\n\t}\n\treturn sprintf(buf, \"%s\\n\", \"unknown\");\n}\n\nstatic ssize_t set_performance_level(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct samsung_laptop *samsung = dev_get_drvdata(dev);\n\tconst struct sabi_config *config = samsung->config;\n\tconst struct sabi_commands *commands = &config->commands;\n\tint i;\n\n\tif (count < 1)\n\t\treturn count;\n\n\tfor (i = 0; config->performance_levels[i].name; ++i) {\n\t\tconst struct sabi_performance_level *level =\n\t\t\t&config->performance_levels[i];\n\t\tif (!strncasecmp(level->name, buf, strlen(level->name))) {\n\t\t\tsabi_set_commandb(samsung,\n\t\t\t\t\t  commands->set_performance_level,\n\t\t\t\t\t  level->value);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!config->performance_levels[i].name)\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(performance_level, 0644,\n\t\t   get_performance_level, set_performance_level);\n\nstatic int read_battery_life_extender(struct samsung_laptop *samsung)\n{\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\tstruct sabi_data data;\n\tint retval;\n\n\tif (commands->get_battery_life_extender == 0xFFFF)\n\t\treturn -ENODEV;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.data[0] = 0x80;\n\tretval = sabi_command(samsung, commands->get_battery_life_extender,\n\t\t\t      &data, &data);\n\n\tif (retval)\n\t\treturn retval;\n\n\tif (data.data[0] != 0 && data.data[0] != 1)\n\t\treturn -ENODEV;\n\n\treturn data.data[0];\n}\n\nstatic int write_battery_life_extender(struct samsung_laptop *samsung,\n\t\t\t\t       int enabled)\n{\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\tstruct sabi_data data;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.data[0] = 0x80 | enabled;\n\treturn sabi_command(samsung, commands->set_battery_life_extender,\n\t\t\t    &data, NULL);\n}\n\nstatic ssize_t get_battery_life_extender(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct samsung_laptop *samsung = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = read_battery_life_extender(samsung);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", ret);\n}\n\nstatic ssize_t set_battery_life_extender(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct samsung_laptop *samsung = dev_get_drvdata(dev);\n\tint ret, value;\n\n\tif (!count || kstrtoint(buf, 0, &value) != 0)\n\t\treturn -EINVAL;\n\n\tret = write_battery_life_extender(samsung, !!value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(battery_life_extender, 0644,\n\t\t   get_battery_life_extender, set_battery_life_extender);\n\nstatic int read_usb_charge(struct samsung_laptop *samsung)\n{\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\tstruct sabi_data data;\n\tint retval;\n\n\tif (commands->get_usb_charge == 0xFFFF)\n\t\treturn -ENODEV;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.data[0] = 0x80;\n\tretval = sabi_command(samsung, commands->get_usb_charge,\n\t\t\t      &data, &data);\n\n\tif (retval)\n\t\treturn retval;\n\n\tif (data.data[0] != 0 && data.data[0] != 1)\n\t\treturn -ENODEV;\n\n\treturn data.data[0];\n}\n\nstatic int write_usb_charge(struct samsung_laptop *samsung,\n\t\t\t    int enabled)\n{\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\tstruct sabi_data data;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.data[0] = 0x80 | enabled;\n\treturn sabi_command(samsung, commands->set_usb_charge,\n\t\t\t    &data, NULL);\n}\n\nstatic ssize_t get_usb_charge(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct samsung_laptop *samsung = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = read_usb_charge(samsung);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", ret);\n}\n\nstatic ssize_t set_usb_charge(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct samsung_laptop *samsung = dev_get_drvdata(dev);\n\tint ret, value;\n\n\tif (!count || kstrtoint(buf, 0, &value) != 0)\n\t\treturn -EINVAL;\n\n\tret = write_usb_charge(samsung, !!value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(usb_charge, 0644,\n\t\t   get_usb_charge, set_usb_charge);\n\nstatic int read_lid_handling(struct samsung_laptop *samsung)\n{\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\tstruct sabi_data data;\n\tint retval;\n\n\tif (commands->get_lid_handling == 0xFFFF)\n\t\treturn -ENODEV;\n\n\tmemset(&data, 0, sizeof(data));\n\tretval = sabi_command(samsung, commands->get_lid_handling,\n\t\t\t      &data, &data);\n\n\tif (retval)\n\t\treturn retval;\n\n\treturn data.data[0] & 0x1;\n}\n\nstatic int write_lid_handling(struct samsung_laptop *samsung,\n\t\t\t      int enabled)\n{\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\tstruct sabi_data data;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.data[0] = 0x80 | enabled;\n\treturn sabi_command(samsung, commands->set_lid_handling,\n\t\t\t    &data, NULL);\n}\n\nstatic ssize_t get_lid_handling(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct samsung_laptop *samsung = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = read_lid_handling(samsung);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", ret);\n}\n\nstatic ssize_t set_lid_handling(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct samsung_laptop *samsung = dev_get_drvdata(dev);\n\tint ret, value;\n\n\tif (!count || kstrtoint(buf, 0, &value) != 0)\n\t\treturn -EINVAL;\n\n\tret = write_lid_handling(samsung, !!value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(lid_handling, 0644,\n\t\t   get_lid_handling, set_lid_handling);\n\nstatic struct attribute *platform_attributes[] = {\n\t&dev_attr_performance_level.attr,\n\t&dev_attr_battery_life_extender.attr,\n\t&dev_attr_usb_charge.attr,\n\t&dev_attr_lid_handling.attr,\n\tNULL\n};\n\nstatic int find_signature(void __iomem *memcheck, const char *testStr)\n{\n\tint i = 0;\n\tint loca;\n\n\tfor (loca = 0; loca < 0xffff; loca++) {\n\t\tchar temp = readb(memcheck + loca);\n\n\t\tif (temp == testStr[i]) {\n\t\t\tif (i == strlen(testStr)-1)\n\t\t\t\tbreak;\n\t\t\t++i;\n\t\t} else {\n\t\t\ti = 0;\n\t\t}\n\t}\n\treturn loca;\n}\n\nstatic void samsung_rfkill_exit(struct samsung_laptop *samsung)\n{\n\tif (samsung->wlan.rfkill) {\n\t\trfkill_unregister(samsung->wlan.rfkill);\n\t\trfkill_destroy(samsung->wlan.rfkill);\n\t\tsamsung->wlan.rfkill = NULL;\n\t}\n\tif (samsung->bluetooth.rfkill) {\n\t\trfkill_unregister(samsung->bluetooth.rfkill);\n\t\trfkill_destroy(samsung->bluetooth.rfkill);\n\t\tsamsung->bluetooth.rfkill = NULL;\n\t}\n}\n\nstatic int samsung_new_rfkill(struct samsung_laptop *samsung,\n\t\t\t      struct samsung_rfkill *arfkill,\n\t\t\t      const char *name, enum rfkill_type type,\n\t\t\t      const struct rfkill_ops *ops,\n\t\t\t      int blocked)\n{\n\tstruct rfkill **rfkill = &arfkill->rfkill;\n\tint ret;\n\n\tarfkill->type = type;\n\tarfkill->samsung = samsung;\n\n\t*rfkill = rfkill_alloc(name, &samsung->platform_device->dev,\n\t\t\t       type, ops, arfkill);\n\n\tif (!*rfkill)\n\t\treturn -EINVAL;\n\n\tif (blocked != -1)\n\t\trfkill_init_sw_state(*rfkill, blocked);\n\n\tret = rfkill_register(*rfkill);\n\tif (ret) {\n\t\trfkill_destroy(*rfkill);\n\t\t*rfkill = NULL;\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int __init samsung_rfkill_init_seclinux(struct samsung_laptop *samsung)\n{\n\treturn samsung_new_rfkill(samsung, &samsung->wlan, \"samsung-wlan\",\n\t\t\t\t  RFKILL_TYPE_WLAN, &seclinux_rfkill_ops, -1);\n}\n\nstatic int __init samsung_rfkill_init_swsmi(struct samsung_laptop *samsung)\n{\n\tstruct sabi_data data;\n\tint ret;\n\n\tret = swsmi_wireless_status(samsung, &data);\n\tif (ret) {\n\t\t \n\t\tif (ret == -EINVAL)\n\t\t\tret = samsung_rfkill_init_seclinux(samsung);\n\t\treturn ret;\n\t}\n\n\t \n\n\tif (data.data[WL_STATUS_WLAN] != 0x02)\n\t\tret = samsung_new_rfkill(samsung, &samsung->wlan,\n\t\t\t\t\t \"samsung-wlan\",\n\t\t\t\t\t RFKILL_TYPE_WLAN,\n\t\t\t\t\t &swsmi_rfkill_ops,\n\t\t\t\t\t !data.data[WL_STATUS_WLAN]);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (data.data[WL_STATUS_BT] != 0x02)\n\t\tret = samsung_new_rfkill(samsung, &samsung->bluetooth,\n\t\t\t\t\t \"samsung-bluetooth\",\n\t\t\t\t\t RFKILL_TYPE_BLUETOOTH,\n\t\t\t\t\t &swsmi_rfkill_ops,\n\t\t\t\t\t !data.data[WL_STATUS_BT]);\n\tif (ret)\n\t\tgoto exit;\n\nexit:\n\tif (ret)\n\t\tsamsung_rfkill_exit(samsung);\n\n\treturn ret;\n}\n\nstatic int __init samsung_rfkill_init(struct samsung_laptop *samsung)\n{\n\tif (samsung->config->sabi_version == 2)\n\t\treturn samsung_rfkill_init_seclinux(samsung);\n\tif (samsung->config->sabi_version == 3)\n\t\treturn samsung_rfkill_init_swsmi(samsung);\n\treturn 0;\n}\n\nstatic void samsung_lid_handling_exit(struct samsung_laptop *samsung)\n{\n\tif (samsung->quirks->lid_handling)\n\t\twrite_lid_handling(samsung, 0);\n}\n\nstatic int __init samsung_lid_handling_init(struct samsung_laptop *samsung)\n{\n\tint retval = 0;\n\n\tif (samsung->quirks->lid_handling)\n\t\tretval = write_lid_handling(samsung, 1);\n\n\treturn retval;\n}\n\nstatic int kbd_backlight_enable(struct samsung_laptop *samsung)\n{\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\tstruct sabi_data data;\n\tint retval;\n\n\tif (commands->kbd_backlight == 0xFFFF)\n\t\treturn -ENODEV;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.d0 = 0xaabb;\n\tretval = sabi_command(samsung, commands->kbd_backlight,\n\t\t\t      &data, &data);\n\n\tif (retval)\n\t\treturn retval;\n\n\tif (data.d0 != 0xccdd)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int kbd_backlight_read(struct samsung_laptop *samsung)\n{\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\tstruct sabi_data data;\n\tint retval;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.data[0] = 0x81;\n\tretval = sabi_command(samsung, commands->kbd_backlight,\n\t\t\t      &data, &data);\n\n\tif (retval)\n\t\treturn retval;\n\n\treturn data.data[0];\n}\n\nstatic int kbd_backlight_write(struct samsung_laptop *samsung, int brightness)\n{\n\tconst struct sabi_commands *commands = &samsung->config->commands;\n\tstruct sabi_data data;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.d0 = 0x82 | ((brightness & 0xFF) << 8);\n\treturn sabi_command(samsung, commands->kbd_backlight,\n\t\t\t    &data, NULL);\n}\n\nstatic void kbd_led_update(struct work_struct *work)\n{\n\tstruct samsung_laptop *samsung;\n\n\tsamsung = container_of(work, struct samsung_laptop, kbd_led_work);\n\tkbd_backlight_write(samsung, samsung->kbd_led_wk);\n}\n\nstatic void kbd_led_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness value)\n{\n\tstruct samsung_laptop *samsung;\n\n\tsamsung = container_of(led_cdev, struct samsung_laptop, kbd_led);\n\n\tif (value > samsung->kbd_led.max_brightness)\n\t\tvalue = samsung->kbd_led.max_brightness;\n\n\tsamsung->kbd_led_wk = value;\n\tqueue_work(samsung->led_workqueue, &samsung->kbd_led_work);\n}\n\nstatic enum led_brightness kbd_led_get(struct led_classdev *led_cdev)\n{\n\tstruct samsung_laptop *samsung;\n\n\tsamsung = container_of(led_cdev, struct samsung_laptop, kbd_led);\n\treturn kbd_backlight_read(samsung);\n}\n\nstatic void samsung_leds_exit(struct samsung_laptop *samsung)\n{\n\tled_classdev_unregister(&samsung->kbd_led);\n\tif (samsung->led_workqueue)\n\t\tdestroy_workqueue(samsung->led_workqueue);\n}\n\nstatic int __init samsung_leds_init(struct samsung_laptop *samsung)\n{\n\tint ret = 0;\n\n\tsamsung->led_workqueue = create_singlethread_workqueue(\"led_workqueue\");\n\tif (!samsung->led_workqueue)\n\t\treturn -ENOMEM;\n\n\tif (kbd_backlight_enable(samsung) >= 0) {\n\t\tINIT_WORK(&samsung->kbd_led_work, kbd_led_update);\n\n\t\tsamsung->kbd_led.name = \"samsung::kbd_backlight\";\n\t\tsamsung->kbd_led.brightness_set = kbd_led_set;\n\t\tsamsung->kbd_led.brightness_get = kbd_led_get;\n\t\tsamsung->kbd_led.max_brightness = 8;\n\t\tif (samsung->quirks->four_kbd_backlight_levels)\n\t\t\tsamsung->kbd_led.max_brightness = 4;\n\n\t\tret = led_classdev_register(&samsung->platform_device->dev,\n\t\t\t\t\t   &samsung->kbd_led);\n\t}\n\n\tif (ret)\n\t\tsamsung_leds_exit(samsung);\n\n\treturn ret;\n}\n\nstatic void samsung_backlight_exit(struct samsung_laptop *samsung)\n{\n\tif (samsung->backlight_device) {\n\t\tbacklight_device_unregister(samsung->backlight_device);\n\t\tsamsung->backlight_device = NULL;\n\t}\n}\n\nstatic int __init samsung_backlight_init(struct samsung_laptop *samsung)\n{\n\tstruct backlight_device *bd;\n\tstruct backlight_properties props;\n\n\tif (!samsung->handle_backlight)\n\t\treturn 0;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = samsung->config->max_brightness -\n\t\tsamsung->config->min_brightness;\n\n\tbd = backlight_device_register(\"samsung\",\n\t\t\t\t       &samsung->platform_device->dev,\n\t\t\t\t       samsung, &backlight_ops,\n\t\t\t\t       &props);\n\tif (IS_ERR(bd))\n\t\treturn PTR_ERR(bd);\n\n\tsamsung->backlight_device = bd;\n\tsamsung->backlight_device->props.brightness = read_brightness(samsung);\n\tsamsung->backlight_device->props.power = FB_BLANK_UNBLANK;\n\tbacklight_update_status(samsung->backlight_device);\n\n\treturn 0;\n}\n\nstatic umode_t samsung_sysfs_is_visible(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct samsung_laptop *samsung = dev_get_drvdata(dev);\n\tbool ok = true;\n\n\tif (attr == &dev_attr_performance_level.attr)\n\t\tok = !!samsung->config->performance_levels[0].name;\n\tif (attr == &dev_attr_battery_life_extender.attr)\n\t\tok = !!(read_battery_life_extender(samsung) >= 0);\n\tif (attr == &dev_attr_usb_charge.attr)\n\t\tok = !!(read_usb_charge(samsung) >= 0);\n\tif (attr == &dev_attr_lid_handling.attr)\n\t\tok = !!(read_lid_handling(samsung) >= 0);\n\n\treturn ok ? attr->mode : 0;\n}\n\nstatic const struct attribute_group platform_attribute_group = {\n\t.is_visible = samsung_sysfs_is_visible,\n\t.attrs = platform_attributes\n};\n\nstatic void samsung_sysfs_exit(struct samsung_laptop *samsung)\n{\n\tstruct platform_device *device = samsung->platform_device;\n\n\tsysfs_remove_group(&device->dev.kobj, &platform_attribute_group);\n}\n\nstatic int __init samsung_sysfs_init(struct samsung_laptop *samsung)\n{\n\tstruct platform_device *device = samsung->platform_device;\n\n\treturn sysfs_create_group(&device->dev.kobj, &platform_attribute_group);\n\n}\n\nstatic int samsung_laptop_call_show(struct seq_file *m, void *data)\n{\n\tstruct samsung_laptop *samsung = m->private;\n\tstruct sabi_data *sdata = &samsung->debug.data;\n\tint ret;\n\n\tseq_printf(m, \"SABI 0x%04x {0x%08x, 0x%08x, 0x%04x, 0x%02x}\\n\",\n\t\t   samsung->debug.command,\n\t\t   sdata->d0, sdata->d1, sdata->d2, sdata->d3);\n\n\tret = sabi_command(samsung, samsung->debug.command, sdata, sdata);\n\n\tif (ret) {\n\t\tseq_printf(m, \"SABI command 0x%04x failed\\n\",\n\t\t\t   samsung->debug.command);\n\t\treturn ret;\n\t}\n\n\tseq_printf(m, \"SABI {0x%08x, 0x%08x, 0x%04x, 0x%02x}\\n\",\n\t\t   sdata->d0, sdata->d1, sdata->d2, sdata->d3);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(samsung_laptop_call);\n\nstatic void samsung_debugfs_exit(struct samsung_laptop *samsung)\n{\n\tdebugfs_remove_recursive(samsung->debug.root);\n}\n\nstatic void samsung_debugfs_init(struct samsung_laptop *samsung)\n{\n\tstruct dentry *root;\n\n\troot = debugfs_create_dir(\"samsung-laptop\", NULL);\n\tsamsung->debug.root = root;\n\n\tsamsung->debug.f0000_wrapper.data = samsung->f0000_segment;\n\tsamsung->debug.f0000_wrapper.size = 0xffff;\n\n\tsamsung->debug.data_wrapper.data = &samsung->debug.data;\n\tsamsung->debug.data_wrapper.size = sizeof(samsung->debug.data);\n\n\tsamsung->debug.sdiag_wrapper.data = samsung->sdiag;\n\tsamsung->debug.sdiag_wrapper.size = strlen(samsung->sdiag);\n\n\tdebugfs_create_u16(\"command\", 0644, root, &samsung->debug.command);\n\tdebugfs_create_u32(\"d0\", 0644, root, &samsung->debug.data.d0);\n\tdebugfs_create_u32(\"d1\", 0644, root, &samsung->debug.data.d1);\n\tdebugfs_create_u16(\"d2\", 0644, root, &samsung->debug.data.d2);\n\tdebugfs_create_u8(\"d3\", 0644, root, &samsung->debug.data.d3);\n\tdebugfs_create_blob(\"data\", 0444, root, &samsung->debug.data_wrapper);\n\tdebugfs_create_blob(\"f0000_segment\", 0400, root,\n\t\t\t    &samsung->debug.f0000_wrapper);\n\tdebugfs_create_file(\"call\", 0444, root, samsung,\n\t\t\t    &samsung_laptop_call_fops);\n\tdebugfs_create_blob(\"sdiag\", 0444, root, &samsung->debug.sdiag_wrapper);\n}\n\nstatic void samsung_sabi_exit(struct samsung_laptop *samsung)\n{\n\tconst struct sabi_config *config = samsung->config;\n\n\t \n\tif (config && config->commands.set_linux != 0xff)\n\t\tsabi_set_commandb(samsung, config->commands.set_linux, 0x80);\n\n\tif (samsung->sabi_iface) {\n\t\tiounmap(samsung->sabi_iface);\n\t\tsamsung->sabi_iface = NULL;\n\t}\n\tif (samsung->f0000_segment) {\n\t\tiounmap(samsung->f0000_segment);\n\t\tsamsung->f0000_segment = NULL;\n\t}\n\n\tsamsung->config = NULL;\n}\n\nstatic __init void samsung_sabi_infos(struct samsung_laptop *samsung, int loca,\n\t\t\t\t      unsigned int ifaceP)\n{\n\tconst struct sabi_config *config = samsung->config;\n\n\tprintk(KERN_DEBUG \"This computer supports SABI==%x\\n\",\n\t       loca + 0xf0000 - 6);\n\n\tprintk(KERN_DEBUG \"SABI header:\\n\");\n\tprintk(KERN_DEBUG \" SMI Port Number = 0x%04x\\n\",\n\t       readw(samsung->sabi + config->header_offsets.port));\n\tprintk(KERN_DEBUG \" SMI Interface Function = 0x%02x\\n\",\n\t       readb(samsung->sabi + config->header_offsets.iface_func));\n\tprintk(KERN_DEBUG \" SMI enable memory buffer = 0x%02x\\n\",\n\t       readb(samsung->sabi + config->header_offsets.en_mem));\n\tprintk(KERN_DEBUG \" SMI restore memory buffer = 0x%02x\\n\",\n\t       readb(samsung->sabi + config->header_offsets.re_mem));\n\tprintk(KERN_DEBUG \" SABI data offset = 0x%04x\\n\",\n\t       readw(samsung->sabi + config->header_offsets.data_offset));\n\tprintk(KERN_DEBUG \" SABI data segment = 0x%04x\\n\",\n\t       readw(samsung->sabi + config->header_offsets.data_segment));\n\n\tprintk(KERN_DEBUG \" SABI pointer = 0x%08x\\n\", ifaceP);\n}\n\nstatic void __init samsung_sabi_diag(struct samsung_laptop *samsung)\n{\n\tint loca = find_signature(samsung->f0000_segment, \"SDiaG@\");\n\tint i;\n\n\tif (loca == 0xffff)\n\t\treturn ;\n\n\t \n\tloca += 1;\n\tfor (i = 0; loca < 0xffff && i < sizeof(samsung->sdiag) - 1; loca++) {\n\t\tchar temp = readb(samsung->f0000_segment + loca);\n\n\t\tif (isalnum(temp) || temp == '/' || temp == '-')\n\t\t\tsamsung->sdiag[i++] = temp;\n\t\telse\n\t\t\tbreak ;\n\t}\n\n\tif (debug && samsung->sdiag[0])\n\t\tpr_info(\"sdiag: %s\", samsung->sdiag);\n}\n\nstatic int __init samsung_sabi_init(struct samsung_laptop *samsung)\n{\n\tconst struct sabi_config *config = NULL;\n\tconst struct sabi_commands *commands;\n\tunsigned int ifaceP;\n\tint loca = 0xffff;\n\tint ret = 0;\n\tint i;\n\n\tsamsung->f0000_segment = ioremap(0xf0000, 0xffff);\n\tif (!samsung->f0000_segment) {\n\t\tif (debug || force)\n\t\t\tpr_err(\"Can't map the segment at 0xf0000\\n\");\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tsamsung_sabi_diag(samsung);\n\n\t \n\tfor (i = 0; sabi_configs[i].test_string != NULL; ++i) {\n\t\tsamsung->config = &sabi_configs[i];\n\t\tloca = find_signature(samsung->f0000_segment,\n\t\t\t\t      samsung->config->test_string);\n\t\tif (loca != 0xffff)\n\t\t\tbreak;\n\t}\n\n\tif (loca == 0xffff) {\n\t\tif (debug || force)\n\t\t\tpr_err(\"This computer does not support SABI\\n\");\n\t\tret = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tconfig = samsung->config;\n\tcommands = &config->commands;\n\n\t \n\tloca += 1;\n\tsamsung->sabi = (samsung->f0000_segment + loca);\n\n\t \n\tifaceP = (readw(samsung->sabi + config->header_offsets.data_segment) & 0x0ffff) << 4;\n\tifaceP += readw(samsung->sabi + config->header_offsets.data_offset) & 0x0ffff;\n\n\tif (debug)\n\t\tsamsung_sabi_infos(samsung, loca, ifaceP);\n\n\tsamsung->sabi_iface = ioremap(ifaceP, 16);\n\tif (!samsung->sabi_iface) {\n\t\tpr_err(\"Can't remap %x\\n\", ifaceP);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (commands->set_linux != 0xff) {\n\t\tint retval = sabi_set_commandb(samsung,\n\t\t\t\t\t       commands->set_linux, 0x81);\n\t\tif (retval) {\n\t\t\tpr_warn(\"Linux mode was not set!\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\tif (samsung->handle_backlight)\n\t\tcheck_for_stepping_quirk(samsung);\n\n\tpr_info(\"detected SABI interface: %s\\n\",\n\t\tsamsung->config->test_string);\n\nexit:\n\tif (ret)\n\t\tsamsung_sabi_exit(samsung);\n\n\treturn ret;\n}\n\nstatic void samsung_platform_exit(struct samsung_laptop *samsung)\n{\n\tif (samsung->platform_device) {\n\t\tplatform_device_unregister(samsung->platform_device);\n\t\tsamsung->platform_device = NULL;\n\t}\n}\n\nstatic int samsung_pm_notification(struct notifier_block *nb,\n\t\t\t\t   unsigned long val, void *ptr)\n{\n\tstruct samsung_laptop *samsung;\n\n\tsamsung = container_of(nb, struct samsung_laptop, pm_nb);\n\tif (val == PM_POST_HIBERNATION &&\n\t    samsung->quirks->enable_kbd_backlight)\n\t\tkbd_backlight_enable(samsung);\n\n\tif (val == PM_POST_HIBERNATION && samsung->quirks->lid_handling)\n\t\twrite_lid_handling(samsung, 1);\n\n\treturn 0;\n}\n\nstatic int __init samsung_platform_init(struct samsung_laptop *samsung)\n{\n\tstruct platform_device *pdev;\n\n\tpdev = platform_device_register_simple(\"samsung\", PLATFORM_DEVID_NONE, NULL, 0);\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\tsamsung->platform_device = pdev;\n\tplatform_set_drvdata(samsung->platform_device, samsung);\n\treturn 0;\n}\n\nstatic struct samsung_quirks *quirks;\n\nstatic int __init samsung_dmi_matched(const struct dmi_system_id *d)\n{\n\tquirks = d->driver_data;\n\treturn 0;\n}\n\nstatic const struct dmi_system_id samsung_dmi_table[] __initconst = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\t\"SAMSUNG ELECTRONICS CO., LTD.\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"8\"),  \n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\t\"SAMSUNG ELECTRONICS CO., LTD.\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"9\"),  \n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\t\"SAMSUNG ELECTRONICS CO., LTD.\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"10\"),  \n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\t\"SAMSUNG ELECTRONICS CO., LTD.\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"14\"),  \n\t\t},\n\t},\n\t \n\t{\n\t  .ident = \"R40/R41\",\n\t  .matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"SAMSUNG ELECTRONICS CO., LTD.\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"R40/R41\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"R40/R41\"),\n\t\t},\n\t},\n\t \n\t{\n\t .callback = samsung_dmi_matched,\n\t .ident = \"730U3E/740U3E\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"SAMSUNG ELECTRONICS CO., LTD.\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"730U3E/740U3E\"),\n\t\t},\n\t .driver_data = &samsung_np740u3e,\n\t},\n\t{\n\t .callback = samsung_dmi_matched,\n\t .ident = \"300V3Z/300V4Z/300V5Z\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"SAMSUNG ELECTRONICS CO., LTD.\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"300V3Z/300V4Z/300V5Z\"),\n\t\t},\n\t .driver_data = &samsung_lid_handling,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(dmi, samsung_dmi_table);\n\nstatic struct platform_device *samsung_platform_device;\n\nstatic int __init samsung_init(void)\n{\n\tstruct samsung_laptop *samsung;\n\tint ret;\n\n\tif (efi_enabled(EFI_BOOT))\n\t\treturn -ENODEV;\n\n\tquirks = &samsung_unknown;\n\tif (!force && !dmi_check_system(samsung_dmi_table))\n\t\treturn -ENODEV;\n\n\tsamsung = kzalloc(sizeof(*samsung), GFP_KERNEL);\n\tif (!samsung)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&samsung->sabi_mutex);\n\tsamsung->handle_backlight = true;\n\tsamsung->quirks = quirks;\n\n\tif (acpi_video_get_backlight_type() != acpi_backlight_vendor)\n\t\tsamsung->handle_backlight = false;\n\n\tret = samsung_platform_init(samsung);\n\tif (ret)\n\t\tgoto error_platform;\n\n\tret = samsung_sabi_init(samsung);\n\tif (ret)\n\t\tgoto error_sabi;\n\n\tret = samsung_sysfs_init(samsung);\n\tif (ret)\n\t\tgoto error_sysfs;\n\n\tret = samsung_backlight_init(samsung);\n\tif (ret)\n\t\tgoto error_backlight;\n\n\tret = samsung_rfkill_init(samsung);\n\tif (ret)\n\t\tgoto error_rfkill;\n\n\tret = samsung_leds_init(samsung);\n\tif (ret)\n\t\tgoto error_leds;\n\n\tret = samsung_lid_handling_init(samsung);\n\tif (ret)\n\t\tgoto error_lid_handling;\n\n\tsamsung_debugfs_init(samsung);\n\n\tsamsung->pm_nb.notifier_call = samsung_pm_notification;\n\tregister_pm_notifier(&samsung->pm_nb);\n\n\tsamsung_platform_device = samsung->platform_device;\n\treturn ret;\n\nerror_lid_handling:\n\tsamsung_leds_exit(samsung);\nerror_leds:\n\tsamsung_rfkill_exit(samsung);\nerror_rfkill:\n\tsamsung_backlight_exit(samsung);\nerror_backlight:\n\tsamsung_sysfs_exit(samsung);\nerror_sysfs:\n\tsamsung_sabi_exit(samsung);\nerror_sabi:\n\tsamsung_platform_exit(samsung);\nerror_platform:\n\tkfree(samsung);\n\treturn ret;\n}\n\nstatic void __exit samsung_exit(void)\n{\n\tstruct samsung_laptop *samsung;\n\n\tsamsung = platform_get_drvdata(samsung_platform_device);\n\tunregister_pm_notifier(&samsung->pm_nb);\n\n\tsamsung_debugfs_exit(samsung);\n\tsamsung_lid_handling_exit(samsung);\n\tsamsung_leds_exit(samsung);\n\tsamsung_rfkill_exit(samsung);\n\tsamsung_backlight_exit(samsung);\n\tsamsung_sysfs_exit(samsung);\n\tsamsung_sabi_exit(samsung);\n\tsamsung_platform_exit(samsung);\n\n\tkfree(samsung);\n\tsamsung_platform_device = NULL;\n}\n\nmodule_init(samsung_init);\nmodule_exit(samsung_exit);\n\nMODULE_AUTHOR(\"Greg Kroah-Hartman <gregkh@suse.de>\");\nMODULE_DESCRIPTION(\"Samsung Backlight driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}