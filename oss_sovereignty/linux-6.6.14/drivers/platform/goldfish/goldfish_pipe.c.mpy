{
  "module_name": "goldfish_pipe.c",
  "hash_id": "5648705432d1dfd8655dd70fb674b1510d1d9a279f62b31d82361da67e41fd76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/goldfish/goldfish_pipe.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/miscdevice.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/acpi.h>\n#include <linux/bug.h>\n#include \"goldfish_pipe_qemu.h\"\n\n \nenum {\n\tPIPE_DRIVER_VERSION = 2,\n\tPIPE_CURRENT_DEVICE_VERSION = 2\n};\n\nenum {\n\tMAX_BUFFERS_PER_COMMAND = 336,\n\tMAX_SIGNALLED_PIPES = 64,\n\tINITIAL_PIPES_CAPACITY = 64\n};\n\nstruct goldfish_pipe_dev;\n\n \nstruct goldfish_pipe_command {\n\ts32 cmd;\t \n\ts32 id;\t\t \n\ts32 status;\t \n\ts32 reserved;\t \n\tunion {\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\tu32 buffers_count;\n\t\t\t \n\t\t\ts32 consumed_size;\n\t\t\t \n\t\t\tu64 ptrs[MAX_BUFFERS_PER_COMMAND];\n\t\t\t \n\t\t\tu32 sizes[MAX_BUFFERS_PER_COMMAND];\n\t\t} rw_params;\n\t};\n};\n\n \nstruct signalled_pipe_buffer {\n\tu32 id;\n\tu32 flags;\n};\n\n \nstruct open_command_param {\n\tu64 command_buffer_ptr;\n\tu32 rw_params_max_count;\n};\n\n \nstruct goldfish_pipe_dev_buffers {\n\tstruct open_command_param open_command_params;\n\tstruct signalled_pipe_buffer\n\t\tsignalled_pipe_buffers[MAX_SIGNALLED_PIPES];\n};\n\n \nstruct goldfish_pipe {\n\t \n\tu32 id;\n\n\t \n\tunsigned long flags;\n\n\t \n\tunsigned long signalled_flags;\n\n\t \n\tstruct goldfish_pipe_command *command_buffer;\n\n\t \n\tstruct goldfish_pipe *prev_signalled;\n\tstruct goldfish_pipe *next_signalled;\n\n\t \n\tstruct mutex lock;\n\n\t \n\twait_queue_head_t wake_queue;\n\n\t \n\tstruct goldfish_pipe_dev *dev;\n\n\t \n\tstruct page *pages[MAX_BUFFERS_PER_COMMAND];\n};\n\n \nstruct goldfish_pipe_dev {\n\t \n\tvoid *magic;\n\n\t \n\tspinlock_t lock;\n\n\t \n\tstruct goldfish_pipe **pipes;\n\tu32 pipes_capacity;\n\n\t \n\tstruct goldfish_pipe_dev_buffers *buffers;\n\n\t \n\tstruct goldfish_pipe *first_signalled_pipe;\n\n\t \n\tstruct device *pdev_dev;\n\n\t \n\tint irq;\n\tint version;\n\tunsigned char __iomem *base;\n\n\tstruct miscdevice miscdev;\n};\n\nstatic int goldfish_pipe_cmd_locked(struct goldfish_pipe *pipe,\n\t\t\t\t    enum PipeCmdCode cmd)\n{\n\tpipe->command_buffer->cmd = cmd;\n\t \n\tpipe->command_buffer->status = PIPE_ERROR_INVAL;\n\twritel(pipe->id, pipe->dev->base + PIPE_REG_CMD);\n\treturn pipe->command_buffer->status;\n}\n\nstatic int goldfish_pipe_cmd(struct goldfish_pipe *pipe, enum PipeCmdCode cmd)\n{\n\tint status;\n\n\tif (mutex_lock_interruptible(&pipe->lock))\n\t\treturn PIPE_ERROR_IO;\n\tstatus = goldfish_pipe_cmd_locked(pipe, cmd);\n\tmutex_unlock(&pipe->lock);\n\treturn status;\n}\n\n \nstatic int goldfish_pipe_error_convert(int status)\n{\n\tswitch (status) {\n\tcase PIPE_ERROR_AGAIN:\n\t\treturn -EAGAIN;\n\tcase PIPE_ERROR_NOMEM:\n\t\treturn -ENOMEM;\n\tcase PIPE_ERROR_IO:\n\t\treturn -EIO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int goldfish_pin_pages(unsigned long first_page,\n\t\t\t      unsigned long last_page,\n\t\t\t      unsigned int last_page_size,\n\t\t\t      int is_write,\n\t\t\t      struct page *pages[MAX_BUFFERS_PER_COMMAND],\n\t\t\t      unsigned int *iter_last_page_size)\n{\n\tint ret;\n\tint requested_pages = ((last_page - first_page) >> PAGE_SHIFT) + 1;\n\n\tif (requested_pages > MAX_BUFFERS_PER_COMMAND) {\n\t\trequested_pages = MAX_BUFFERS_PER_COMMAND;\n\t\t*iter_last_page_size = PAGE_SIZE;\n\t} else {\n\t\t*iter_last_page_size = last_page_size;\n\t}\n\n\tret = pin_user_pages_fast(first_page, requested_pages,\n\t\t\t\t  !is_write ? FOLL_WRITE : 0,\n\t\t\t\t  pages);\n\tif (ret <= 0)\n\t\treturn -EFAULT;\n\tif (ret < requested_pages)\n\t\t*iter_last_page_size = PAGE_SIZE;\n\n\treturn ret;\n}\n\n \nstatic void populate_rw_params(struct page **pages,\n\t\t\t       int pages_count,\n\t\t\t       unsigned long address,\n\t\t\t       unsigned long address_end,\n\t\t\t       unsigned long first_page,\n\t\t\t       unsigned long last_page,\n\t\t\t       unsigned int iter_last_page_size,\n\t\t\t       int is_write,\n\t\t\t       struct goldfish_pipe_command *command)\n{\n\t \n\tunsigned long xaddr = page_to_phys(pages[0]);\n\tunsigned long xaddr_prev = xaddr;\n\tint buffer_idx = 0;\n\tint i = 1;\n\tint size_on_page = first_page == last_page\n\t\t\t? (int)(address_end - address)\n\t\t\t: (PAGE_SIZE - (address & ~PAGE_MASK));\n\tcommand->rw_params.ptrs[0] = (u64)(xaddr | (address & ~PAGE_MASK));\n\tcommand->rw_params.sizes[0] = size_on_page;\n\tfor (; i < pages_count; ++i) {\n\t\txaddr = page_to_phys(pages[i]);\n\t\tsize_on_page = (i == pages_count - 1) ?\n\t\t\titer_last_page_size : PAGE_SIZE;\n\t\tif (xaddr == xaddr_prev + PAGE_SIZE) {\n\t\t\tcommand->rw_params.sizes[buffer_idx] += size_on_page;\n\t\t} else {\n\t\t\t++buffer_idx;\n\t\t\tcommand->rw_params.ptrs[buffer_idx] = (u64)xaddr;\n\t\t\tcommand->rw_params.sizes[buffer_idx] = size_on_page;\n\t\t}\n\t\txaddr_prev = xaddr;\n\t}\n\tcommand->rw_params.buffers_count = buffer_idx + 1;\n}\n\nstatic int transfer_max_buffers(struct goldfish_pipe *pipe,\n\t\t\t\tunsigned long address,\n\t\t\t\tunsigned long address_end,\n\t\t\t\tint is_write,\n\t\t\t\tunsigned long last_page,\n\t\t\t\tunsigned int last_page_size,\n\t\t\t\ts32 *consumed_size,\n\t\t\t\tint *status)\n{\n\tunsigned long first_page = address & PAGE_MASK;\n\tunsigned int iter_last_page_size;\n\tint pages_count;\n\n\t \n\tif (mutex_lock_interruptible(&pipe->lock))\n\t\treturn -ERESTARTSYS;\n\n\tpages_count = goldfish_pin_pages(first_page, last_page,\n\t\t\t\t\t last_page_size, is_write,\n\t\t\t\t\t pipe->pages, &iter_last_page_size);\n\tif (pages_count < 0) {\n\t\tmutex_unlock(&pipe->lock);\n\t\treturn pages_count;\n\t}\n\n\tpopulate_rw_params(pipe->pages, pages_count, address, address_end,\n\t\t\t   first_page, last_page, iter_last_page_size, is_write,\n\t\t\t   pipe->command_buffer);\n\n\t \n\t*status = goldfish_pipe_cmd_locked(pipe,\n\t\t\t\tis_write ? PIPE_CMD_WRITE : PIPE_CMD_READ);\n\n\t*consumed_size = pipe->command_buffer->rw_params.consumed_size;\n\n\tunpin_user_pages_dirty_lock(pipe->pages, pages_count,\n\t\t\t\t    !is_write && *consumed_size > 0);\n\n\tmutex_unlock(&pipe->lock);\n\treturn 0;\n}\n\nstatic int wait_for_host_signal(struct goldfish_pipe *pipe, int is_write)\n{\n\tu32 wake_bit = is_write ? BIT_WAKE_ON_WRITE : BIT_WAKE_ON_READ;\n\n\tset_bit(wake_bit, &pipe->flags);\n\n\t \n\tgoldfish_pipe_cmd(pipe,\n\t\tis_write ? PIPE_CMD_WAKE_ON_WRITE : PIPE_CMD_WAKE_ON_READ);\n\n\twhile (test_bit(wake_bit, &pipe->flags)) {\n\t\tif (wait_event_interruptible(pipe->wake_queue,\n\t\t\t\t\t     !test_bit(wake_bit, &pipe->flags)))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (test_bit(BIT_CLOSED_ON_HOST, &pipe->flags))\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t goldfish_pipe_read_write(struct file *filp,\n\t\t\t\t\tchar __user *buffer,\n\t\t\t\t\tsize_t bufflen,\n\t\t\t\t\tint is_write)\n{\n\tstruct goldfish_pipe *pipe = filp->private_data;\n\tint count = 0, ret = -EINVAL;\n\tunsigned long address, address_end, last_page;\n\tunsigned int last_page_size;\n\n\t \n\tif (unlikely(test_bit(BIT_CLOSED_ON_HOST, &pipe->flags)))\n\t\treturn -EIO;\n\t \n\tif (unlikely(bufflen == 0))\n\t\treturn 0;\n\t \n\tif (unlikely(!access_ok(buffer, bufflen)))\n\t\treturn -EFAULT;\n\n\taddress = (unsigned long)buffer;\n\taddress_end = address + bufflen;\n\tlast_page = (address_end - 1) & PAGE_MASK;\n\tlast_page_size = ((address_end - 1) & ~PAGE_MASK) + 1;\n\n\twhile (address < address_end) {\n\t\ts32 consumed_size;\n\t\tint status;\n\n\t\tret = transfer_max_buffers(pipe, address, address_end, is_write,\n\t\t\t\t\t   last_page, last_page_size,\n\t\t\t\t\t   &consumed_size, &status);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (consumed_size > 0) {\n\t\t\t \n\t\t\tcount += consumed_size;\n\t\t\taddress += consumed_size;\n\t\t}\n\t\tif (status > 0)\n\t\t\tcontinue;\n\t\tif (status == 0) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (count > 0) {\n\t\t\t \n\t\t\tif (status != PIPE_ERROR_AGAIN)\n\t\t\t\tdev_err_ratelimited(pipe->dev->pdev_dev,\n\t\t\t\t\t\"backend error %d on %s\\n\",\n\t\t\t\t\tstatus, is_write ? \"write\" : \"read\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (status != PIPE_ERROR_AGAIN ||\n\t\t\t(filp->f_flags & O_NONBLOCK) != 0) {\n\t\t\tret = goldfish_pipe_error_convert(status);\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = wait_for_host_signal(pipe, is_write);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tif (count > 0)\n\t\treturn count;\n\treturn ret;\n}\n\nstatic ssize_t goldfish_pipe_read(struct file *filp, char __user *buffer,\n\t\t\t\t  size_t bufflen, loff_t *ppos)\n{\n\treturn goldfish_pipe_read_write(filp, buffer, bufflen,\n\t\t\t\t\t  0);\n}\n\nstatic ssize_t goldfish_pipe_write(struct file *filp,\n\t\t\t\t   const char __user *buffer, size_t bufflen,\n\t\t\t\t   loff_t *ppos)\n{\n\t \n\tchar __user *no_const_buffer = (char __user *)buffer;\n\n\treturn goldfish_pipe_read_write(filp, no_const_buffer, bufflen,\n\t\t\t\t\t  1);\n}\n\nstatic __poll_t goldfish_pipe_poll(struct file *filp, poll_table *wait)\n{\n\tstruct goldfish_pipe *pipe = filp->private_data;\n\t__poll_t mask = 0;\n\tint status;\n\n\tpoll_wait(filp, &pipe->wake_queue, wait);\n\n\tstatus = goldfish_pipe_cmd(pipe, PIPE_CMD_POLL);\n\tif (status < 0)\n\t\treturn -ERESTARTSYS;\n\n\tif (status & PIPE_POLL_IN)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (status & PIPE_POLL_OUT)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\tif (status & PIPE_POLL_HUP)\n\t\tmask |= EPOLLHUP;\n\tif (test_bit(BIT_CLOSED_ON_HOST, &pipe->flags))\n\t\tmask |= EPOLLERR;\n\n\treturn mask;\n}\n\nstatic void signalled_pipes_add_locked(struct goldfish_pipe_dev *dev,\n\t\t\t\t       u32 id, u32 flags)\n{\n\tstruct goldfish_pipe *pipe;\n\n\tif (WARN_ON(id >= dev->pipes_capacity))\n\t\treturn;\n\n\tpipe = dev->pipes[id];\n\tif (!pipe)\n\t\treturn;\n\tpipe->signalled_flags |= flags;\n\n\tif (pipe->prev_signalled || pipe->next_signalled ||\n\t\tdev->first_signalled_pipe == pipe)\n\t\treturn;\t \n\tpipe->next_signalled = dev->first_signalled_pipe;\n\tif (dev->first_signalled_pipe)\n\t\tdev->first_signalled_pipe->prev_signalled = pipe;\n\tdev->first_signalled_pipe = pipe;\n}\n\nstatic void signalled_pipes_remove_locked(struct goldfish_pipe_dev *dev,\n\t\t\t\t\t  struct goldfish_pipe *pipe)\n{\n\tif (pipe->prev_signalled)\n\t\tpipe->prev_signalled->next_signalled = pipe->next_signalled;\n\tif (pipe->next_signalled)\n\t\tpipe->next_signalled->prev_signalled = pipe->prev_signalled;\n\tif (pipe == dev->first_signalled_pipe)\n\t\tdev->first_signalled_pipe = pipe->next_signalled;\n\tpipe->prev_signalled = NULL;\n\tpipe->next_signalled = NULL;\n}\n\nstatic struct goldfish_pipe *signalled_pipes_pop_front(\n\t\tstruct goldfish_pipe_dev *dev, int *wakes)\n{\n\tstruct goldfish_pipe *pipe;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpipe = dev->first_signalled_pipe;\n\tif (pipe) {\n\t\t*wakes = pipe->signalled_flags;\n\t\tpipe->signalled_flags = 0;\n\t\t \n\t\tdev->first_signalled_pipe = pipe->next_signalled;\n\t\tif (dev->first_signalled_pipe)\n\t\t\tdev->first_signalled_pipe->prev_signalled = NULL;\n\t\tpipe->next_signalled = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn pipe;\n}\n\nstatic irqreturn_t goldfish_interrupt_task(int irq, void *dev_addr)\n{\n\t \n\tstruct goldfish_pipe_dev *dev = dev_addr;\n\tstruct goldfish_pipe *pipe;\n\tint wakes;\n\n\twhile ((pipe = signalled_pipes_pop_front(dev, &wakes)) != NULL) {\n\t\tif (wakes & PIPE_WAKE_CLOSED) {\n\t\t\tpipe->flags = 1 << BIT_CLOSED_ON_HOST;\n\t\t} else {\n\t\t\tif (wakes & PIPE_WAKE_READ)\n\t\t\t\tclear_bit(BIT_WAKE_ON_READ, &pipe->flags);\n\t\t\tif (wakes & PIPE_WAKE_WRITE)\n\t\t\t\tclear_bit(BIT_WAKE_ON_WRITE, &pipe->flags);\n\t\t}\n\t\t \n\t\twake_up_interruptible(&pipe->wake_queue);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void goldfish_pipe_device_deinit(struct platform_device *pdev,\n\t\t\t\t\tstruct goldfish_pipe_dev *dev);\n\n \nstatic irqreturn_t goldfish_pipe_interrupt(int irq, void *dev_id)\n{\n\tu32 count;\n\tu32 i;\n\tunsigned long flags;\n\tstruct goldfish_pipe_dev *dev = dev_id;\n\n\tif (dev->magic != &goldfish_pipe_device_deinit)\n\t\treturn IRQ_NONE;\n\n\t \n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tcount = readl(dev->base + PIPE_REG_GET_SIGNALLED);\n\tif (count == 0) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn IRQ_NONE;\n\t}\n\tif (count > MAX_SIGNALLED_PIPES)\n\t\tcount = MAX_SIGNALLED_PIPES;\n\n\tfor (i = 0; i < count; ++i)\n\t\tsignalled_pipes_add_locked(dev,\n\t\t\tdev->buffers->signalled_pipe_buffers[i].id,\n\t\t\tdev->buffers->signalled_pipe_buffers[i].flags);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic int get_free_pipe_id_locked(struct goldfish_pipe_dev *dev)\n{\n\tint id;\n\n\tfor (id = 0; id < dev->pipes_capacity; ++id)\n\t\tif (!dev->pipes[id])\n\t\t\treturn id;\n\n\t{\n\t\t \n\t\tu32 new_capacity = 2 * dev->pipes_capacity;\n\t\tstruct goldfish_pipe **pipes =\n\t\t\tkcalloc(new_capacity, sizeof(*pipes), GFP_ATOMIC);\n\t\tif (!pipes)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(pipes, dev->pipes, sizeof(*pipes) * dev->pipes_capacity);\n\t\tkfree(dev->pipes);\n\t\tdev->pipes = pipes;\n\t\tid = dev->pipes_capacity;\n\t\tdev->pipes_capacity = new_capacity;\n\t}\n\treturn id;\n}\n\n \nstatic struct goldfish_pipe_dev *to_goldfish_pipe_dev(struct file *file)\n{\n\tstruct miscdevice *miscdev = file->private_data;\n\n\treturn container_of(miscdev, struct goldfish_pipe_dev, miscdev);\n}\n\n \nstatic int goldfish_pipe_open(struct inode *inode, struct file *file)\n{\n\tstruct goldfish_pipe_dev *dev = to_goldfish_pipe_dev(file);\n\tunsigned long flags;\n\tint id;\n\tint status;\n\n\t \n\tstruct goldfish_pipe *pipe = kzalloc(sizeof(*pipe), GFP_KERNEL);\n\n\tif (!pipe)\n\t\treturn -ENOMEM;\n\n\tpipe->dev = dev;\n\tmutex_init(&pipe->lock);\n\tinit_waitqueue_head(&pipe->wake_queue);\n\n\t \n\tBUILD_BUG_ON(sizeof(struct goldfish_pipe_command) > PAGE_SIZE);\n\tpipe->command_buffer =\n\t\t(struct goldfish_pipe_command *)__get_free_page(GFP_KERNEL);\n\tif (!pipe->command_buffer) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_pipe;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tid = get_free_pipe_id_locked(dev);\n\tif (id < 0) {\n\t\tstatus = id;\n\t\tgoto err_id_locked;\n\t}\n\n\tdev->pipes[id] = pipe;\n\tpipe->id = id;\n\tpipe->command_buffer->id = id;\n\n\t \n\tdev->buffers->open_command_params.rw_params_max_count =\n\t\t\tMAX_BUFFERS_PER_COMMAND;\n\tdev->buffers->open_command_params.command_buffer_ptr =\n\t\t\t(u64)(unsigned long)__pa(pipe->command_buffer);\n\tstatus = goldfish_pipe_cmd_locked(pipe, PIPE_CMD_OPEN);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (status < 0)\n\t\tgoto err_cmd;\n\t \n\tfile->private_data = pipe;\n\treturn 0;\n\nerr_cmd:\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->pipes[id] = NULL;\nerr_id_locked:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tfree_page((unsigned long)pipe->command_buffer);\nerr_pipe:\n\tkfree(pipe);\n\treturn status;\n}\n\nstatic int goldfish_pipe_release(struct inode *inode, struct file *filp)\n{\n\tunsigned long flags;\n\tstruct goldfish_pipe *pipe = filp->private_data;\n\tstruct goldfish_pipe_dev *dev = pipe->dev;\n\n\t \n\tgoldfish_pipe_cmd(pipe, PIPE_CMD_CLOSE);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->pipes[pipe->id] = NULL;\n\tsignalled_pipes_remove_locked(dev, pipe);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tfilp->private_data = NULL;\n\tfree_page((unsigned long)pipe->command_buffer);\n\tkfree(pipe);\n\treturn 0;\n}\n\nstatic const struct file_operations goldfish_pipe_fops = {\n\t.owner = THIS_MODULE,\n\t.read = goldfish_pipe_read,\n\t.write = goldfish_pipe_write,\n\t.poll = goldfish_pipe_poll,\n\t.open = goldfish_pipe_open,\n\t.release = goldfish_pipe_release,\n};\n\nstatic void init_miscdevice(struct miscdevice *miscdev)\n{\n\tmemset(miscdev, 0, sizeof(*miscdev));\n\n\tmiscdev->minor = MISC_DYNAMIC_MINOR;\n\tmiscdev->name = \"goldfish_pipe\";\n\tmiscdev->fops = &goldfish_pipe_fops;\n}\n\nstatic void write_pa_addr(void *addr, void __iomem *portl, void __iomem *porth)\n{\n\tconst unsigned long paddr = __pa(addr);\n\n\twritel(upper_32_bits(paddr), porth);\n\twritel(lower_32_bits(paddr), portl);\n}\n\nstatic int goldfish_pipe_device_init(struct platform_device *pdev,\n\t\t\t\t     struct goldfish_pipe_dev *dev)\n{\n\tint err;\n\n\terr = devm_request_threaded_irq(&pdev->dev, dev->irq,\n\t\t\t\t\tgoldfish_pipe_interrupt,\n\t\t\t\t\tgoldfish_interrupt_task,\n\t\t\t\t\tIRQF_SHARED, \"goldfish_pipe\", dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"unable to allocate IRQ for v2\\n\");\n\t\treturn err;\n\t}\n\n\tinit_miscdevice(&dev->miscdev);\n\terr = misc_register(&dev->miscdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"unable to register v2 device\\n\");\n\t\treturn err;\n\t}\n\n\tdev->pdev_dev = &pdev->dev;\n\tdev->first_signalled_pipe = NULL;\n\tdev->pipes_capacity = INITIAL_PIPES_CAPACITY;\n\tdev->pipes = kcalloc(dev->pipes_capacity, sizeof(*dev->pipes),\n\t\t\t     GFP_KERNEL);\n\tif (!dev->pipes) {\n\t\tmisc_deregister(&dev->miscdev);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tBUILD_BUG_ON(sizeof(struct goldfish_pipe_dev_buffers) > PAGE_SIZE);\n\tdev->buffers = (struct goldfish_pipe_dev_buffers *)\n\t\t__get_free_page(GFP_KERNEL);\n\tif (!dev->buffers) {\n\t\tkfree(dev->pipes);\n\t\tmisc_deregister(&dev->miscdev);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\twrite_pa_addr(&dev->buffers->signalled_pipe_buffers,\n\t\t      dev->base + PIPE_REG_SIGNAL_BUFFER,\n\t\t      dev->base + PIPE_REG_SIGNAL_BUFFER_HIGH);\n\n\twritel(MAX_SIGNALLED_PIPES,\n\t       dev->base + PIPE_REG_SIGNAL_BUFFER_COUNT);\n\n\twrite_pa_addr(&dev->buffers->open_command_params,\n\t\t      dev->base + PIPE_REG_OPEN_BUFFER,\n\t\t      dev->base + PIPE_REG_OPEN_BUFFER_HIGH);\n\n\tplatform_set_drvdata(pdev, dev);\n\treturn 0;\n}\n\nstatic void goldfish_pipe_device_deinit(struct platform_device *pdev,\n\t\t\t\t\tstruct goldfish_pipe_dev *dev)\n{\n\tmisc_deregister(&dev->miscdev);\n\tkfree(dev->pipes);\n\tfree_page((unsigned long)dev->buffers);\n}\n\nstatic int goldfish_pipe_probe(struct platform_device *pdev)\n{\n\tstruct resource *r;\n\tstruct goldfish_pipe_dev *dev;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->magic = &goldfish_pipe_device_deinit;\n\tspin_lock_init(&dev->lock);\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r || resource_size(r) < PAGE_SIZE) {\n\t\tdev_err(&pdev->dev, \"can't allocate i/o page\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdev->base = devm_ioremap(&pdev->dev, r->start, PAGE_SIZE);\n\tif (!dev->base) {\n\t\tdev_err(&pdev->dev, \"ioremap failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev->irq = platform_get_irq(pdev, 0);\n\tif (dev->irq < 0)\n\t\treturn dev->irq;\n\n\t \n\twritel(PIPE_DRIVER_VERSION, dev->base + PIPE_REG_VERSION);\n\tdev->version = readl(dev->base + PIPE_REG_VERSION);\n\tif (WARN_ON(dev->version < PIPE_CURRENT_DEVICE_VERSION))\n\t\treturn -EINVAL;\n\n\treturn goldfish_pipe_device_init(pdev, dev);\n}\n\nstatic int goldfish_pipe_remove(struct platform_device *pdev)\n{\n\tstruct goldfish_pipe_dev *dev = platform_get_drvdata(pdev);\n\n\tgoldfish_pipe_device_deinit(pdev, dev);\n\treturn 0;\n}\n\nstatic const struct acpi_device_id goldfish_pipe_acpi_match[] = {\n\t{ \"GFSH0003\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, goldfish_pipe_acpi_match);\n\nstatic const struct of_device_id goldfish_pipe_of_match[] = {\n\t{ .compatible = \"google,android-pipe\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, goldfish_pipe_of_match);\n\nstatic struct platform_driver goldfish_pipe_driver = {\n\t.probe = goldfish_pipe_probe,\n\t.remove = goldfish_pipe_remove,\n\t.driver = {\n\t\t.name = \"goldfish_pipe\",\n\t\t.of_match_table = goldfish_pipe_of_match,\n\t\t.acpi_match_table = ACPI_PTR(goldfish_pipe_acpi_match),\n\t}\n};\n\nmodule_platform_driver(goldfish_pipe_driver);\nMODULE_AUTHOR(\"David Turner <digit@google.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}