{
  "module_name": "olpc-xo175-ec.c",
  "hash_id": "92de83d91361bc27c34db4f3ca3125650ff5124bec2a9150758b486d6ab782c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/olpc/olpc-xo175-ec.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/input.h>\n#include <linux/kfifo.h>\n#include <linux/module.h>\n#include <linux/olpc-ec.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/spi/spi.h>\n\nstruct ec_cmd_t {\n\tu8 cmd;\n\tu8 bytes_returned;\n};\n\nenum ec_chan_t {\n\tCHAN_NONE = 0,\n\tCHAN_SWITCH,\n\tCHAN_CMD_RESP,\n\tCHAN_KEYBOARD,\n\tCHAN_TOUCHPAD,\n\tCHAN_EVENT,\n\tCHAN_DEBUG,\n\tCHAN_CMD_ERROR,\n};\n\n \n#define EVENT_AC_CHANGE\t\t\t1   \n#define EVENT_BATTERY_STATUS\t\t2   \n#define EVENT_BATTERY_CRITICAL\t\t3   \n#define EVENT_BATTERY_SOC_CHANGE\t4   \n#define EVENT_BATTERY_ERROR\t\t5   \n#define EVENT_POWER_PRESSED\t\t6   \n#define EVENT_POWER_PRESS_WAKE\t\t7   \n#define EVENT_TIMED_HOST_WAKE\t\t8   \n#define EVENT_OLS_HIGH_LIMIT\t\t9   \n#define EVENT_OLS_LOW_LIMIT\t\t10  \n\n \n#define CMD_GET_API_VERSION\t\t0x08  \n#define CMD_READ_VOLTAGE\t\t0x10  \n#define CMD_READ_CURRENT\t\t0x11  \n#define CMD_READ_ACR\t\t\t0x12  \n#define CMD_READ_BATT_TEMPERATURE\t0x13  \n#define CMD_READ_AMBIENT_TEMPERATURE\t0x14  \n#define CMD_READ_BATTERY_STATUS\t\t0x15  \n#define CMD_READ_SOC\t\t\t0x16  \n#define CMD_READ_GAUGE_ID\t\t0x17  \n#define CMD_READ_GAUGE_DATA\t\t0x18  \n#define CMD_READ_BOARD_ID\t\t0x19  \n#define CMD_READ_BATT_ERR_CODE\t\t0x1f  \n#define CMD_SET_DCON_POWER\t\t0x26  \n#define CMD_RESET_EC\t\t\t0x28  \n#define CMD_READ_BATTERY_TYPE\t\t0x2c  \n#define CMD_SET_AUTOWAK\t\t\t0x33  \n#define CMD_SET_EC_WAKEUP_TIMER\t\t0x36  \n#define CMD_READ_EXT_SCI_MASK\t\t0x37  \n#define CMD_WRITE_EXT_SCI_MASK\t\t0x38  \n#define CMD_CLEAR_EC_WAKEUP_TIMER\t0x39  \n#define CMD_ENABLE_RUNIN_DISCHARGE\t0x3B  \n#define CMD_DISABLE_RUNIN_DISCHARGE\t0x3C  \n#define CMD_READ_MPPT_ACTIVE\t\t0x3d  \n#define CMD_READ_MPPT_LIMIT\t\t0x3e  \n#define CMD_SET_MPPT_LIMIT\t\t0x3f  \n#define CMD_DISABLE_MPPT\t\t0x40  \n#define CMD_ENABLE_MPPT\t\t\t0x41  \n#define CMD_READ_VIN\t\t\t0x42  \n#define CMD_EXT_SCI_QUERY\t\t0x43  \n#define RSP_KEYBOARD_DATA\t\t0x48  \n#define RSP_TOUCHPAD_DATA\t\t0x49  \n#define CMD_GET_FW_VERSION\t\t0x4a  \n#define CMD_POWER_CYCLE\t\t\t0x4b  \n#define CMD_POWER_OFF\t\t\t0x4c  \n#define CMD_RESET_EC_SOFT\t\t0x4d  \n#define CMD_READ_GAUGE_U16\t\t0x4e  \n#define CMD_ENABLE_MOUSE\t\t0x4f  \n#define CMD_ECHO\t\t\t0x52  \n#define CMD_GET_FW_DATE\t\t\t0x53  \n#define CMD_GET_FW_USER\t\t\t0x54  \n#define CMD_TURN_OFF_POWER\t\t0x55  \n#define CMD_READ_OLS\t\t\t0x56  \n#define CMD_OLS_SMT_LEDON\t\t0x57  \n#define CMD_OLS_SMT_LEDOFF\t\t0x58  \n#define CMD_START_OLS_ASSY\t\t0x59  \n#define CMD_STOP_OLS_ASSY\t\t0x5a  \n#define CMD_OLS_SMTTEST_STOP\t\t0x5b  \n#define CMD_READ_VIN_SCALED\t\t0x5c  \n#define CMD_READ_BAT_MIN_W\t\t0x5d  \n#define CMD_READ_BAR_MAX_W\t\t0x5e  \n#define CMD_RESET_BAT_MINMAX_W\t\t0x5f  \n#define CMD_READ_LOCATION\t\t0x60  \n#define CMD_WRITE_LOCATION\t\t0x61  \n#define CMD_KEYBOARD_CMD\t\t0x62  \n#define CMD_TOUCHPAD_CMD\t\t0x63  \n#define CMD_GET_FW_HASH\t\t\t0x64  \n#define CMD_SUSPEND_HINT\t\t0x65  \n#define CMD_ENABLE_WAKE_TIMER\t\t0x66  \n#define CMD_SET_WAKE_TIMER\t\t0x67  \n#define CMD_ENABLE_WAKE_AUTORESET\t0x68  \n#define CMD_OLS_SET_LIMITS\t\t0x69  \n#define CMD_OLS_GET_LIMITS\t\t0x6a  \n#define CMD_OLS_SET_CEILING\t\t0x6b  \n#define CMD_OLS_GET_CEILING\t\t0x6c  \n\n \nstatic const struct ec_cmd_t olpc_xo175_ec_cmds[] = {\n\t{ CMD_GET_API_VERSION, 1 },\n\t{ CMD_READ_VOLTAGE, 2 },\n\t{ CMD_READ_CURRENT, 2 },\n\t{ CMD_READ_ACR, 2 },\n\t{ CMD_READ_BATT_TEMPERATURE, 2 },\n\t{ CMD_READ_BATTERY_STATUS, 1 },\n\t{ CMD_READ_SOC, 1 },\n\t{ CMD_READ_GAUGE_ID, 8 },\n\t{ CMD_READ_GAUGE_DATA, 1 },\n\t{ CMD_READ_BOARD_ID, 2 },\n\t{ CMD_READ_BATT_ERR_CODE, 1 },\n\t{ CMD_SET_DCON_POWER, 0 },\n\t{ CMD_RESET_EC, 0 },\n\t{ CMD_READ_BATTERY_TYPE, 1 },\n\t{ CMD_ENABLE_RUNIN_DISCHARGE, 0 },\n\t{ CMD_DISABLE_RUNIN_DISCHARGE, 0 },\n\t{ CMD_READ_MPPT_ACTIVE, 1 },\n\t{ CMD_READ_MPPT_LIMIT, 1 },\n\t{ CMD_SET_MPPT_LIMIT, 0 },\n\t{ CMD_DISABLE_MPPT, 0 },\n\t{ CMD_ENABLE_MPPT, 0 },\n\t{ CMD_READ_VIN, 2 },\n\t{ CMD_GET_FW_VERSION, 16 },\n\t{ CMD_POWER_CYCLE, 0 },\n\t{ CMD_POWER_OFF, 0 },\n\t{ CMD_RESET_EC_SOFT, 0 },\n\t{ CMD_ECHO, 5 },\n\t{ CMD_GET_FW_DATE, 16 },\n\t{ CMD_GET_FW_USER, 16 },\n\t{ CMD_TURN_OFF_POWER, 0 },\n\t{ CMD_READ_OLS, 2 },\n\t{ CMD_OLS_SMT_LEDON, 0 },\n\t{ CMD_OLS_SMT_LEDOFF, 0 },\n\t{ CMD_START_OLS_ASSY, 0 },\n\t{ CMD_STOP_OLS_ASSY, 0 },\n\t{ CMD_OLS_SMTTEST_STOP, 0 },\n\t{ CMD_READ_VIN_SCALED, 2 },\n\t{ CMD_READ_BAT_MIN_W, 2 },\n\t{ CMD_READ_BAR_MAX_W, 2 },\n\t{ CMD_RESET_BAT_MINMAX_W, 0 },\n\t{ CMD_READ_LOCATION, 1 },\n\t{ CMD_WRITE_LOCATION, 0 },\n\t{ CMD_GET_FW_HASH, 16 },\n\t{ CMD_SUSPEND_HINT, 0 },\n\t{ CMD_ENABLE_WAKE_TIMER, 0 },\n\t{ CMD_SET_WAKE_TIMER, 0 },\n\t{ CMD_ENABLE_WAKE_AUTORESET, 0 },\n\t{ CMD_OLS_SET_LIMITS, 0 },\n\t{ CMD_OLS_GET_LIMITS, 4 },\n\t{ CMD_OLS_SET_CEILING, 0 },\n\t{ CMD_OLS_GET_CEILING, 2 },\n\t{ CMD_READ_EXT_SCI_MASK, 2 },\n\t{ CMD_WRITE_EXT_SCI_MASK, 0 },\n\n\t{ }\n};\n\n#define EC_MAX_CMD_DATA_LEN\t5\n#define EC_MAX_RESP_LEN\t\t16\n\n#define LOG_BUF_SIZE\t\t128\n\n#define PM_WAKEUP_TIME\t\t1000\n\n#define EC_ALL_EVENTS\t\tGENMASK(15, 0)\n\nenum ec_state_t {\n\tCMD_STATE_IDLE = 0,\n\tCMD_STATE_WAITING_FOR_SWITCH,\n\tCMD_STATE_CMD_IN_TX_FIFO,\n\tCMD_STATE_CMD_SENT,\n\tCMD_STATE_RESP_RECEIVED,\n\tCMD_STATE_ERROR_RECEIVED,\n};\n\nstruct olpc_xo175_ec_cmd {\n\tu8 command;\n\tu8 nr_args;\n\tu8 data_len;\n\tu8 args[EC_MAX_CMD_DATA_LEN];\n};\n\nstruct olpc_xo175_ec_resp {\n\tu8 channel;\n\tu8 byte;\n};\n\nstruct olpc_xo175_ec {\n\tbool suspended;\n\n\t \n\tstruct spi_device *spi;\n\tstruct spi_transfer xfer;\n\tstruct spi_message msg;\n\tunion {\n\t\tstruct olpc_xo175_ec_cmd cmd;\n\t\tstruct olpc_xo175_ec_resp resp;\n\t} tx_buf, rx_buf;\n\n\t \n\tstruct gpio_desc *gpio_cmd;\n\n\t \n\tspinlock_t cmd_state_lock;\n\tint cmd_state;\n\tbool cmd_running;\n\tstruct completion cmd_done;\n\tstruct olpc_xo175_ec_cmd cmd;\n\tu8 resp_data[EC_MAX_RESP_LEN];\n\tint expected_resp_len;\n\tint resp_len;\n\n\t \n\tstruct input_dev *pwrbtn;\n\n\t \n\tchar logbuf[LOG_BUF_SIZE];\n\tint logbuf_len;\n};\n\nstatic struct platform_device *olpc_ec;\n\nstatic int olpc_xo175_ec_resp_len(u8 cmd)\n{\n\tconst struct ec_cmd_t *p;\n\n\tfor (p = olpc_xo175_ec_cmds; p->cmd; p++) {\n\t\tif (p->cmd == cmd)\n\t\t\treturn p->bytes_returned;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void olpc_xo175_ec_flush_logbuf(struct olpc_xo175_ec *priv)\n{\n\tdev_dbg(&priv->spi->dev, \"got debug string [%*pE]\\n\",\n\t\t\t\tpriv->logbuf_len, priv->logbuf);\n\tpriv->logbuf_len = 0;\n}\n\nstatic void olpc_xo175_ec_complete(void *arg);\n\nstatic void olpc_xo175_ec_send_command(struct olpc_xo175_ec *priv, void *cmd,\n\t\t\t\t\t\t\t\tsize_t cmdlen)\n{\n\tint ret;\n\n\tmemcpy(&priv->tx_buf, cmd, cmdlen);\n\tpriv->xfer.len = cmdlen;\n\n\tspi_message_init_with_transfers(&priv->msg, &priv->xfer, 1);\n\n\tpriv->msg.complete = olpc_xo175_ec_complete;\n\tpriv->msg.context = priv;\n\n\tret = spi_async(priv->spi, &priv->msg);\n\tif (ret)\n\t\tdev_err(&priv->spi->dev, \"spi_async() failed %d\\n\", ret);\n}\n\nstatic void olpc_xo175_ec_read_packet(struct olpc_xo175_ec *priv)\n{\n\tu8 nonce[] = {0xA5, 0x5A};\n\n\tolpc_xo175_ec_send_command(priv, nonce, sizeof(nonce));\n}\n\nstatic void olpc_xo175_ec_complete(void *arg)\n{\n\tstruct olpc_xo175_ec *priv = arg;\n\tstruct device *dev = &priv->spi->dev;\n\tstruct power_supply *psy;\n\tunsigned long flags;\n\tu8 channel;\n\tu8 byte;\n\tint ret;\n\n\tret = priv->msg.status;\n\tif (ret) {\n\t\tdev_err(dev, \"SPI transfer failed: %d\\n\", ret);\n\n\t\tspin_lock_irqsave(&priv->cmd_state_lock, flags);\n\t\tif (priv->cmd_running) {\n\t\t\tpriv->resp_len = 0;\n\t\t\tpriv->cmd_state = CMD_STATE_ERROR_RECEIVED;\n\t\t\tcomplete(&priv->cmd_done);\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->cmd_state_lock, flags);\n\n\t\tif (ret != -EINTR)\n\t\t\tolpc_xo175_ec_read_packet(priv);\n\n\t\treturn;\n\t}\n\n\tchannel = priv->rx_buf.resp.channel;\n\tbyte = priv->rx_buf.resp.byte;\n\n\tswitch (channel) {\n\tcase CHAN_NONE:\n\t\tspin_lock_irqsave(&priv->cmd_state_lock, flags);\n\n\t\tif (!priv->cmd_running) {\n\t\t\t \n\t\t\tdev_err(dev, \"spurious FIFO read packet\\n\");\n\t\t\tspin_unlock_irqrestore(&priv->cmd_state_lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tpriv->cmd_state = CMD_STATE_CMD_SENT;\n\t\tif (!priv->expected_resp_len)\n\t\t\tcomplete(&priv->cmd_done);\n\t\tolpc_xo175_ec_read_packet(priv);\n\n\t\tspin_unlock_irqrestore(&priv->cmd_state_lock, flags);\n\t\treturn;\n\n\tcase CHAN_SWITCH:\n\t\tspin_lock_irqsave(&priv->cmd_state_lock, flags);\n\n\t\tif (!priv->cmd_running) {\n\t\t\t \n\t\t\tdev_err(dev, \"spurious SWITCH packet\\n\");\n\t\t\tmemset(&priv->cmd, 0, sizeof(priv->cmd));\n\t\t\tpriv->cmd.command = CMD_ECHO;\n\t\t}\n\n\t\tpriv->cmd_state = CMD_STATE_CMD_IN_TX_FIFO;\n\n\t\t \n\t\tgpiod_set_value_cansleep(priv->gpio_cmd, 0);\n\t\tolpc_xo175_ec_send_command(priv, &priv->cmd, sizeof(priv->cmd));\n\n\t\tspin_unlock_irqrestore(&priv->cmd_state_lock, flags);\n\t\treturn;\n\n\tcase CHAN_CMD_RESP:\n\t\tspin_lock_irqsave(&priv->cmd_state_lock, flags);\n\n\t\tif (!priv->cmd_running) {\n\t\t\tdev_err(dev, \"spurious response packet\\n\");\n\t\t} else if (priv->resp_len >= priv->expected_resp_len) {\n\t\t\tdev_err(dev, \"too many response packets\\n\");\n\t\t} else {\n\t\t\tpriv->resp_data[priv->resp_len++] = byte;\n\t\t\tif (priv->resp_len == priv->expected_resp_len) {\n\t\t\t\tpriv->cmd_state = CMD_STATE_RESP_RECEIVED;\n\t\t\t\tcomplete(&priv->cmd_done);\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock_irqrestore(&priv->cmd_state_lock, flags);\n\t\tbreak;\n\n\tcase CHAN_CMD_ERROR:\n\t\tspin_lock_irqsave(&priv->cmd_state_lock, flags);\n\n\t\tif (!priv->cmd_running) {\n\t\t\tdev_err(dev, \"spurious cmd error packet\\n\");\n\t\t} else {\n\t\t\tpriv->resp_data[0] = byte;\n\t\t\tpriv->resp_len = 1;\n\t\t\tpriv->cmd_state = CMD_STATE_ERROR_RECEIVED;\n\t\t\tcomplete(&priv->cmd_done);\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->cmd_state_lock, flags);\n\t\tbreak;\n\n\tcase CHAN_KEYBOARD:\n\t\tdev_warn(dev, \"keyboard is not supported\\n\");\n\t\tbreak;\n\n\tcase CHAN_TOUCHPAD:\n\t\tdev_warn(dev, \"touchpad is not supported\\n\");\n\t\tbreak;\n\n\tcase CHAN_EVENT:\n\t\tdev_dbg(dev, \"got event %.2x\\n\", byte);\n\t\tswitch (byte) {\n\t\tcase EVENT_AC_CHANGE:\n\t\t\tpsy = power_supply_get_by_name(\"olpc_ac\");\n\t\t\tif (psy) {\n\t\t\t\tpower_supply_changed(psy);\n\t\t\t\tpower_supply_put(psy);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENT_BATTERY_STATUS:\n\t\tcase EVENT_BATTERY_CRITICAL:\n\t\tcase EVENT_BATTERY_SOC_CHANGE:\n\t\tcase EVENT_BATTERY_ERROR:\n\t\t\tpsy = power_supply_get_by_name(\"olpc_battery\");\n\t\t\tif (psy) {\n\t\t\t\tpower_supply_changed(psy);\n\t\t\t\tpower_supply_put(psy);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENT_POWER_PRESSED:\n\t\t\tinput_report_key(priv->pwrbtn, KEY_POWER, 1);\n\t\t\tinput_sync(priv->pwrbtn);\n\t\t\tinput_report_key(priv->pwrbtn, KEY_POWER, 0);\n\t\t\tinput_sync(priv->pwrbtn);\n\t\t\tfallthrough;\n\t\tcase EVENT_POWER_PRESS_WAKE:\n\t\tcase EVENT_TIMED_HOST_WAKE:\n\t\t\tpm_wakeup_event(priv->pwrbtn->dev.parent,\n\t\t\t\t\t\tPM_WAKEUP_TIME);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(dev, \"ignored unknown event %.2x\\n\", byte);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase CHAN_DEBUG:\n\t\tif (byte == '\\n') {\n\t\t\tolpc_xo175_ec_flush_logbuf(priv);\n\t\t} else if (isprint(byte)) {\n\t\t\tpriv->logbuf[priv->logbuf_len++] = byte;\n\t\t\tif (priv->logbuf_len == LOG_BUF_SIZE)\n\t\t\t\tolpc_xo175_ec_flush_logbuf(priv);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(dev, \"unknown channel: %d, %.2x\\n\", channel, byte);\n\t\tbreak;\n\t}\n\n\t \n\tolpc_xo175_ec_read_packet(priv);\n}\n\n \nstatic int olpc_xo175_ec_cmd(u8 cmd, u8 *inbuf, size_t inlen, u8 *resp,\n\t\t\t\t\tsize_t resp_len, void *ec_cb_arg)\n{\n\tstruct olpc_xo175_ec *priv = ec_cb_arg;\n\tstruct device *dev = &priv->spi->dev;\n\tunsigned long flags;\n\tsize_t nr_bytes;\n\tint ret = 0;\n\n\tdev_dbg(dev, \"CMD %x, %zd bytes expected\\n\", cmd, resp_len);\n\n\tif (inlen > 5) {\n\t\tdev_err(dev, \"command len %zd too big!\\n\", resp_len);\n\t\treturn -EOVERFLOW;\n\t}\n\n\t \n\tif (WARN_ON(priv->suspended))\n\t\treturn -EBUSY;\n\n\t \n\tret = olpc_xo175_ec_resp_len(cmd);\n\tif (ret < 0) {\n\t\tdev_err_ratelimited(dev, \"unknown command 0x%x\\n\", cmd);\n\n\t\t \n\t\tif (resp_len > sizeof(priv->resp_data)) {\n\t\t\tdev_err(dev, \"response too big: %zd!\\n\", resp_len);\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\t\tnr_bytes = resp_len;\n\t} else {\n\t\tnr_bytes = (size_t)ret;\n\t\tret = 0;\n\t}\n\tresp_len = min(resp_len, nr_bytes);\n\n\tspin_lock_irqsave(&priv->cmd_state_lock, flags);\n\n\t \n\tinit_completion(&priv->cmd_done);\n\tpriv->cmd_running = true;\n\tpriv->cmd_state = CMD_STATE_WAITING_FOR_SWITCH;\n\tmemset(&priv->cmd, 0, sizeof(priv->cmd));\n\tpriv->cmd.command = cmd;\n\tpriv->cmd.nr_args = inlen;\n\tpriv->cmd.data_len = 0;\n\tmemcpy(priv->cmd.args, inbuf, inlen);\n\tpriv->expected_resp_len = nr_bytes;\n\tpriv->resp_len = 0;\n\n\t \n\tgpiod_set_value_cansleep(priv->gpio_cmd, 1);\n\n\tspin_unlock_irqrestore(&priv->cmd_state_lock, flags);\n\n\t \n\tif (!wait_for_completion_timeout(&priv->cmd_done,\n\t\t\tmsecs_to_jiffies(4000))) {\n\t\tdev_err(dev, \"EC cmd error: timeout in STATE %d\\n\",\n\t\t\t\tpriv->cmd_state);\n\t\tgpiod_set_value_cansleep(priv->gpio_cmd, 0);\n\t\tspi_slave_abort(priv->spi);\n\t\tolpc_xo175_ec_read_packet(priv);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tspin_lock_irqsave(&priv->cmd_state_lock, flags);\n\n\t \n\tif (priv->cmd_state == CMD_STATE_ERROR_RECEIVED) {\n\t\t \n\t\tdev_err(dev, \"command 0x%x returned error 0x%x\\n\",\n\t\t\t\t\t\tcmd, priv->resp_data[0]);\n\t\tret = -EREMOTEIO;\n\t} else if (priv->resp_len != nr_bytes) {\n\t\tdev_err(dev, \"command 0x%x returned %d bytes, expected %zd bytes\\n\",\n\t\t\t\t\t\tcmd, priv->resp_len, nr_bytes);\n\t\tret = -EREMOTEIO;\n\t} else {\n\t\t \n\t\tmemcpy(resp, priv->resp_data, resp_len);\n\t}\n\n\t \n\tgpiod_set_value_cansleep(priv->gpio_cmd, 0);\n\tpriv->cmd_running = false;\n\n\tspin_unlock_irqrestore(&priv->cmd_state_lock, flags);\n\n\treturn ret;\n}\n\nstatic int olpc_xo175_ec_set_event_mask(unsigned int mask)\n{\n\tu8 args[2];\n\n\targs[0] = mask >> 0;\n\targs[1] = mask >> 8;\n\treturn olpc_ec_cmd(CMD_WRITE_EXT_SCI_MASK, args, 2, NULL, 0);\n}\n\nstatic void olpc_xo175_ec_power_off(void)\n{\n\twhile (1) {\n\t\tolpc_ec_cmd(CMD_POWER_OFF, NULL, 0, NULL, 0);\n\t\tmdelay(1000);\n\t}\n}\n\nstatic int __maybe_unused olpc_xo175_ec_suspend(struct device *dev)\n{\n\tstruct olpc_xo175_ec *priv = dev_get_drvdata(dev);\n\tstatic struct {\n\t\tu8 suspend;\n\t\tu32 suspend_count;\n\t} __packed hintargs;\n\tstatic unsigned int suspend_count;\n\n\t \n\thintargs.suspend = 1;\n\thintargs.suspend_count = suspend_count++;\n\tolpc_ec_cmd(CMD_SUSPEND_HINT, (void *)&hintargs, sizeof(hintargs),\n\t\t\t\t\t\t\t\tNULL, 0);\n\n\t \n\tpriv->suspended = true;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused olpc_xo175_ec_resume_noirq(struct device *dev)\n{\n\tstruct olpc_xo175_ec *priv = dev_get_drvdata(dev);\n\n\tpriv->suspended = false;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused olpc_xo175_ec_resume(struct device *dev)\n{\n\tu8 x = 0;\n\n\t \n\tolpc_ec_cmd(CMD_SUSPEND_HINT, &x, 1, NULL, 0);\n\n\t \n\tolpc_xo175_ec_set_event_mask(EC_ALL_EVENTS);\n\n\treturn 0;\n}\n\nstatic struct olpc_ec_driver olpc_xo175_ec_driver = {\n\t.ec_cmd = olpc_xo175_ec_cmd,\n};\n\nstatic void olpc_xo175_ec_remove(struct spi_device *spi)\n{\n\tif (pm_power_off == olpc_xo175_ec_power_off)\n\t\tpm_power_off = NULL;\n\n\tspi_slave_abort(spi);\n\n\tplatform_device_unregister(olpc_ec);\n\tolpc_ec = NULL;\n}\n\nstatic int olpc_xo175_ec_probe(struct spi_device *spi)\n{\n\tstruct olpc_xo175_ec *priv;\n\tint ret;\n\n\tif (olpc_ec) {\n\t\tdev_err(&spi->dev, \"OLPC EC already registered.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tpriv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->gpio_cmd = devm_gpiod_get(&spi->dev, \"cmd\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->gpio_cmd)) {\n\t\tdev_err(&spi->dev, \"failed to get cmd gpio: %ld\\n\",\n\t\t\t\t\tPTR_ERR(priv->gpio_cmd));\n\t\treturn PTR_ERR(priv->gpio_cmd);\n\t}\n\n\tpriv->spi = spi;\n\n\tspin_lock_init(&priv->cmd_state_lock);\n\tpriv->cmd_state = CMD_STATE_IDLE;\n\tinit_completion(&priv->cmd_done);\n\n\tpriv->logbuf_len = 0;\n\n\t \n\tpriv->pwrbtn = devm_input_allocate_device(&spi->dev);\n\tif (!priv->pwrbtn)\n\t\treturn -ENOMEM;\n\tpriv->pwrbtn->name = \"Power Button\";\n\tpriv->pwrbtn->dev.parent = &spi->dev;\n\tinput_set_capability(priv->pwrbtn, EV_KEY, KEY_POWER);\n\tret = input_register_device(priv->pwrbtn);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"error registering input device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tspi_set_drvdata(spi, priv);\n\n\tpriv->xfer.rx_buf = &priv->rx_buf;\n\tpriv->xfer.tx_buf = &priv->tx_buf;\n\n\tolpc_xo175_ec_read_packet(priv);\n\n\tolpc_ec_driver_register(&olpc_xo175_ec_driver, priv);\n\tolpc_ec = platform_device_register_resndata(&spi->dev, \"olpc-ec\", -1,\n\t\t\t\t\t\t\tNULL, 0, NULL, 0);\n\n\t \n\tolpc_xo175_ec_set_event_mask(EC_ALL_EVENTS);\n\n\tif (pm_power_off == NULL)\n\t\tpm_power_off = olpc_xo175_ec_power_off;\n\n\tdev_info(&spi->dev, \"OLPC XO-1.75 Embedded Controller driver\\n\");\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops olpc_xo175_ec_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(NULL, olpc_xo175_ec_resume_noirq)\n\tSET_RUNTIME_PM_OPS(olpc_xo175_ec_suspend, olpc_xo175_ec_resume, NULL)\n};\n\nstatic const struct of_device_id olpc_xo175_ec_of_match[] = {\n\t{ .compatible = \"olpc,xo1.75-ec\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, olpc_xo175_ec_of_match);\n\nstatic const struct spi_device_id olpc_xo175_ec_id_table[] = {\n\t{ \"xo1.75-ec\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, olpc_xo175_ec_id_table);\n\nstatic struct spi_driver olpc_xo175_ec_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"olpc-xo175-ec\",\n\t\t.of_match_table = olpc_xo175_ec_of_match,\n\t\t.pm = &olpc_xo175_ec_pm_ops,\n\t},\n\t.id_table\t= olpc_xo175_ec_id_table,\n\t.probe\t\t= olpc_xo175_ec_probe,\n\t.remove\t\t= olpc_xo175_ec_remove,\n};\nmodule_spi_driver(olpc_xo175_ec_spi_driver);\n\nMODULE_DESCRIPTION(\"OLPC XO-1.75 Embedded Controller driver\");\nMODULE_AUTHOR(\"Lennert Buytenhek <buytenh@wantstofly.org>\");  \nMODULE_AUTHOR(\"Lubomir Rintel <lkundrak@v3.sk>\");  \nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}