{
  "module_name": "olpc-ec.c",
  "hash_id": "5a65e716e9f6fc5112cdfc9e0db58e9f72d8d47668367c44937b9ed666a78b3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/olpc/olpc-ec.c",
  "human_readable_source": "\n \n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/regulator/driver.h>\n#include <linux/olpc-ec.h>\n\nstruct ec_cmd_desc {\n\tu8 cmd;\n\tu8 *inbuf, *outbuf;\n\tsize_t inlen, outlen;\n\n\tint err;\n\tstruct completion finished;\n\tstruct list_head node;\n\n\tvoid *priv;\n};\n\nstruct olpc_ec_priv {\n\tstruct olpc_ec_driver *drv;\n\tu8 version;\n\tstruct work_struct worker;\n\tstruct mutex cmd_lock;\n\n\t \n\tbool dcon_enabled;\n\n\t \n\tstruct list_head cmd_q;\n\tspinlock_t cmd_q_lock;\n\n\tstruct dentry *dbgfs_dir;\n\n\t \n\tu16 ec_wakeup_mask;\n\n\t \n\tbool suspended;\n};\n\nstatic struct olpc_ec_driver *ec_driver;\nstatic struct olpc_ec_priv *ec_priv;\nstatic void *ec_cb_arg;\n\nvoid olpc_ec_driver_register(struct olpc_ec_driver *drv, void *arg)\n{\n\tec_driver = drv;\n\tec_cb_arg = arg;\n}\nEXPORT_SYMBOL_GPL(olpc_ec_driver_register);\n\nstatic void olpc_ec_worker(struct work_struct *w)\n{\n\tstruct olpc_ec_priv *ec = container_of(w, struct olpc_ec_priv, worker);\n\tstruct ec_cmd_desc *desc = NULL;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ec->cmd_q_lock, flags);\n\tif (!list_empty(&ec->cmd_q)) {\n\t\tdesc = list_first_entry(&ec->cmd_q, struct ec_cmd_desc, node);\n\t\tlist_del(&desc->node);\n\t}\n\tspin_unlock_irqrestore(&ec->cmd_q_lock, flags);\n\n\t \n\tif (!desc)\n\t\treturn;\n\n\t \n\tmutex_lock(&ec->cmd_lock);\n\tdesc->err = ec_driver->ec_cmd(desc->cmd, desc->inbuf, desc->inlen,\n\t\t\tdesc->outbuf, desc->outlen, ec_cb_arg);\n\tmutex_unlock(&ec->cmd_lock);\n\n\t \n\tcomplete(&desc->finished);\n\n\t \n\tschedule_work(&ec->worker);\n}\n\n \nstatic void queue_ec_descriptor(struct ec_cmd_desc *desc,\n\t\tstruct olpc_ec_priv *ec)\n{\n\tunsigned long flags;\n\n\tINIT_LIST_HEAD(&desc->node);\n\n\tspin_lock_irqsave(&ec->cmd_q_lock, flags);\n\tlist_add_tail(&desc->node, &ec->cmd_q);\n\tspin_unlock_irqrestore(&ec->cmd_q_lock, flags);\n\n\tschedule_work(&ec->worker);\n}\n\nint olpc_ec_cmd(u8 cmd, u8 *inbuf, size_t inlen, u8 *outbuf, size_t outlen)\n{\n\tstruct olpc_ec_priv *ec = ec_priv;\n\tstruct ec_cmd_desc desc;\n\n\t \n\tif (!ec_driver)\n\t\treturn -EPROBE_DEFER;\n\n\tif (WARN_ON(!ec_driver->ec_cmd))\n\t\treturn -ENODEV;\n\n\tif (!ec)\n\t\treturn -ENOMEM;\n\n\t \n\tif (WARN_ON(ec->suspended))\n\t\treturn -EBUSY;\n\n\tmight_sleep();\n\n\tdesc.cmd = cmd;\n\tdesc.inbuf = inbuf;\n\tdesc.outbuf = outbuf;\n\tdesc.inlen = inlen;\n\tdesc.outlen = outlen;\n\tdesc.err = 0;\n\tinit_completion(&desc.finished);\n\n\tqueue_ec_descriptor(&desc, ec);\n\n\t \n\twait_for_completion(&desc.finished);\n\n\t \n\treturn desc.err;\n}\nEXPORT_SYMBOL_GPL(olpc_ec_cmd);\n\nvoid olpc_ec_wakeup_set(u16 value)\n{\n\tstruct olpc_ec_priv *ec = ec_priv;\n\n\tif (WARN_ON(!ec))\n\t\treturn;\n\n\tec->ec_wakeup_mask |= value;\n}\nEXPORT_SYMBOL_GPL(olpc_ec_wakeup_set);\n\nvoid olpc_ec_wakeup_clear(u16 value)\n{\n\tstruct olpc_ec_priv *ec = ec_priv;\n\n\tif (WARN_ON(!ec))\n\t\treturn;\n\n\tec->ec_wakeup_mask &= ~value;\n}\nEXPORT_SYMBOL_GPL(olpc_ec_wakeup_clear);\n\nint olpc_ec_mask_write(u16 bits)\n{\n\tstruct olpc_ec_priv *ec = ec_priv;\n\n\tif (WARN_ON(!ec))\n\t\treturn -ENODEV;\n\n\t \n\tif (ec->version >= 0x5f) {\n\t\t__be16 ec_word = cpu_to_be16(bits);\n\n\t\treturn olpc_ec_cmd(EC_WRITE_EXT_SCI_MASK, (void *)&ec_word, 2, NULL, 0);\n\t} else {\n\t\tu8 ec_byte = bits & 0xff;\n\n\t\treturn olpc_ec_cmd(EC_WRITE_SCI_MASK, &ec_byte, 1, NULL, 0);\n\t}\n}\nEXPORT_SYMBOL_GPL(olpc_ec_mask_write);\n\n \nbool olpc_ec_wakeup_available(void)\n{\n\tif (WARN_ON(!ec_driver))\n\t\treturn false;\n\n\treturn ec_driver->wakeup_available;\n}\nEXPORT_SYMBOL_GPL(olpc_ec_wakeup_available);\n\nint olpc_ec_sci_query(u16 *sci_value)\n{\n\tstruct olpc_ec_priv *ec = ec_priv;\n\tint ret;\n\n\tif (WARN_ON(!ec))\n\t\treturn -ENODEV;\n\n\t \n\tif (ec->version >= 0x5f) {\n\t\t__be16 ec_word;\n\n\t\tret = olpc_ec_cmd(EC_EXT_SCI_QUERY, NULL, 0, (void *)&ec_word, 2);\n\t\tif (ret == 0)\n\t\t\t*sci_value = be16_to_cpu(ec_word);\n\t} else {\n\t\tu8 ec_byte;\n\n\t\tret = olpc_ec_cmd(EC_SCI_QUERY, NULL, 0, &ec_byte, 1);\n\t\tif (ret == 0)\n\t\t\t*sci_value = ec_byte;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(olpc_ec_sci_query);\n\n#ifdef CONFIG_DEBUG_FS\n\n \n\n#define EC_MAX_CMD_ARGS (5 + 1)\t\t \n#define EC_MAX_CMD_REPLY (8)\n\nstatic DEFINE_MUTEX(ec_dbgfs_lock);\nstatic unsigned char ec_dbgfs_resp[EC_MAX_CMD_REPLY];\nstatic unsigned int ec_dbgfs_resp_bytes;\n\nstatic ssize_t ec_dbgfs_cmd_write(struct file *file, const char __user *buf,\n\t\tsize_t size, loff_t *ppos)\n{\n\tint i, m;\n\tunsigned char ec_cmd[EC_MAX_CMD_ARGS];\n\tunsigned int ec_cmd_int[EC_MAX_CMD_ARGS];\n\tchar cmdbuf[64] = \"\";\n\tint ec_cmd_bytes;\n\n\tmutex_lock(&ec_dbgfs_lock);\n\n\tsize = simple_write_to_buffer(cmdbuf, sizeof(cmdbuf), ppos, buf, size);\n\n\tm = sscanf(cmdbuf, \"%x:%u %x %x %x %x %x\", &ec_cmd_int[0],\n\t\t\t&ec_dbgfs_resp_bytes, &ec_cmd_int[1], &ec_cmd_int[2],\n\t\t\t&ec_cmd_int[3], &ec_cmd_int[4], &ec_cmd_int[5]);\n\tif (m < 2 || ec_dbgfs_resp_bytes > EC_MAX_CMD_REPLY) {\n\t\t \n\t\tec_dbgfs_resp_bytes = 0;\n\n\t\tpr_debug(\"olpc-ec: bad ec cmd:  cmd:response-count [arg1 [arg2 ...]]\\n\");\n\t\tsize = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tec_cmd_bytes = m - 2;\n\tfor (i = 0; i <= ec_cmd_bytes; i++)\n\t\tec_cmd[i] = ec_cmd_int[i];\n\n\tpr_debug(\"olpc-ec: debugfs cmd 0x%02x with %d args %5ph, want %d returns\\n\",\n\t\t\tec_cmd[0], ec_cmd_bytes, ec_cmd + 1,\n\t\t\tec_dbgfs_resp_bytes);\n\n\tolpc_ec_cmd(ec_cmd[0], (ec_cmd_bytes == 0) ? NULL : &ec_cmd[1],\n\t\t\tec_cmd_bytes, ec_dbgfs_resp, ec_dbgfs_resp_bytes);\n\n\tpr_debug(\"olpc-ec: response %8ph (%d bytes expected)\\n\",\n\t\t\tec_dbgfs_resp, ec_dbgfs_resp_bytes);\n\nout:\n\tmutex_unlock(&ec_dbgfs_lock);\n\treturn size;\n}\n\nstatic ssize_t ec_dbgfs_cmd_read(struct file *file, char __user *buf,\n\t\tsize_t size, loff_t *ppos)\n{\n\tunsigned int i, r;\n\tchar *rp;\n\tchar respbuf[64];\n\n\tmutex_lock(&ec_dbgfs_lock);\n\trp = respbuf;\n\trp += sprintf(rp, \"%02x\", ec_dbgfs_resp[0]);\n\tfor (i = 1; i < ec_dbgfs_resp_bytes; i++)\n\t\trp += sprintf(rp, \", %02x\", ec_dbgfs_resp[i]);\n\tmutex_unlock(&ec_dbgfs_lock);\n\trp += sprintf(rp, \"\\n\");\n\n\tr = rp - respbuf;\n\treturn simple_read_from_buffer(buf, size, ppos, respbuf, r);\n}\n\nstatic const struct file_operations ec_dbgfs_ops = {\n\t.write = ec_dbgfs_cmd_write,\n\t.read = ec_dbgfs_cmd_read,\n};\n\nstatic struct dentry *olpc_ec_setup_debugfs(void)\n{\n\tstruct dentry *dbgfs_dir;\n\n\tdbgfs_dir = debugfs_create_dir(\"olpc-ec\", NULL);\n\tif (IS_ERR_OR_NULL(dbgfs_dir))\n\t\treturn NULL;\n\n\tdebugfs_create_file(\"cmd\", 0600, dbgfs_dir, NULL, &ec_dbgfs_ops);\n\n\treturn dbgfs_dir;\n}\n\n#else\n\nstatic struct dentry *olpc_ec_setup_debugfs(void)\n{\n\treturn NULL;\n}\n\n#endif  \n\nstatic int olpc_ec_set_dcon_power(struct olpc_ec_priv *ec, bool state)\n{\n\tunsigned char ec_byte = state;\n\tint ret;\n\n\tif (ec->dcon_enabled == state)\n\t\treturn 0;\n\n\tret = olpc_ec_cmd(EC_DCON_POWER_MODE, &ec_byte, 1, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tec->dcon_enabled = state;\n\treturn 0;\n}\n\nstatic int dcon_regulator_enable(struct regulator_dev *rdev)\n{\n\tstruct olpc_ec_priv *ec = rdev_get_drvdata(rdev);\n\n\treturn olpc_ec_set_dcon_power(ec, true);\n}\n\nstatic int dcon_regulator_disable(struct regulator_dev *rdev)\n{\n\tstruct olpc_ec_priv *ec = rdev_get_drvdata(rdev);\n\n\treturn olpc_ec_set_dcon_power(ec, false);\n}\n\nstatic int dcon_regulator_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct olpc_ec_priv *ec = rdev_get_drvdata(rdev);\n\n\treturn ec->dcon_enabled ? 1 : 0;\n}\n\nstatic const struct regulator_ops dcon_regulator_ops = {\n\t.enable\t\t= dcon_regulator_enable,\n\t.disable\t= dcon_regulator_disable,\n\t.is_enabled\t= dcon_regulator_is_enabled,\n};\n\nstatic const struct regulator_desc dcon_desc = {\n\t.name\t\t= \"dcon\",\n\t.id\t\t= 0,\n\t.ops\t\t= &dcon_regulator_ops,\n\t.type\t\t= REGULATOR_VOLTAGE,\n\t.owner\t\t= THIS_MODULE,\n\t.enable_time\t= 25000,\n};\n\nstatic int olpc_ec_probe(struct platform_device *pdev)\n{\n\tstruct olpc_ec_priv *ec;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *regulator;\n\tint err;\n\n\tif (!ec_driver)\n\t\treturn -ENODEV;\n\n\tec = kzalloc(sizeof(*ec), GFP_KERNEL);\n\tif (!ec)\n\t\treturn -ENOMEM;\n\n\tec->drv = ec_driver;\n\tINIT_WORK(&ec->worker, olpc_ec_worker);\n\tmutex_init(&ec->cmd_lock);\n\n\tINIT_LIST_HEAD(&ec->cmd_q);\n\tspin_lock_init(&ec->cmd_q_lock);\n\n\tec_priv = ec;\n\tplatform_set_drvdata(pdev, ec);\n\n\t \n\terr = olpc_ec_cmd(EC_FIRMWARE_REV, NULL, 0, &ec->version, 1);\n\tif (err)\n\t\tgoto error;\n\n\tconfig.dev = pdev->dev.parent;\n\tconfig.driver_data = ec;\n\tec->dcon_enabled = true;\n\tregulator = devm_regulator_register(&pdev->dev, &dcon_desc, &config);\n\tif (IS_ERR(regulator)) {\n\t\tdev_err(&pdev->dev, \"failed to register DCON regulator\\n\");\n\t\terr = PTR_ERR(regulator);\n\t\tgoto error;\n\t}\n\n\tec->dbgfs_dir = olpc_ec_setup_debugfs();\n\n\treturn 0;\n\nerror:\n\tec_priv = NULL;\n\tkfree(ec);\n\treturn err;\n}\n\nstatic int olpc_ec_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct olpc_ec_priv *ec = platform_get_drvdata(pdev);\n\tint err = 0;\n\n\tolpc_ec_mask_write(ec->ec_wakeup_mask);\n\n\tif (ec_driver->suspend)\n\t\terr = ec_driver->suspend(pdev);\n\tif (!err)\n\t\tec->suspended = true;\n\n\treturn err;\n}\n\nstatic int olpc_ec_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct olpc_ec_priv *ec = platform_get_drvdata(pdev);\n\n\tec->suspended = false;\n\treturn ec_driver->resume ? ec_driver->resume(pdev) : 0;\n}\n\nstatic const struct dev_pm_ops olpc_ec_pm_ops = {\n\t.suspend_late = olpc_ec_suspend,\n\t.resume_early = olpc_ec_resume,\n};\n\nstatic struct platform_driver olpc_ec_plat_driver = {\n\t.probe = olpc_ec_probe,\n\t.driver = {\n\t\t.name = \"olpc-ec\",\n\t\t.pm = &olpc_ec_pm_ops,\n\t},\n};\n\nstatic int __init olpc_ec_init_module(void)\n{\n\treturn platform_driver_register(&olpc_ec_plat_driver);\n}\narch_initcall(olpc_ec_init_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}