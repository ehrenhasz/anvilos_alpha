{
  "module_name": "gpio-arizona.c",
  "hash_id": "3e703fd0eb39c9aa006dc519baec7798f502a01aff8a936ded8712a82c178b92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-arizona.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include <linux/mfd/arizona/core.h>\n#include <linux/mfd/arizona/pdata.h>\n#include <linux/mfd/arizona/registers.h>\n\nstruct arizona_gpio {\n\tstruct arizona *arizona;\n\tstruct gpio_chip gpio_chip;\n};\n\nstatic int arizona_gpio_direction_in(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct arizona_gpio *arizona_gpio = gpiochip_get_data(chip);\n\tstruct arizona *arizona = arizona_gpio->arizona;\n\tbool persistent = gpiochip_line_is_persistent(chip, offset);\n\tbool change;\n\tint ret;\n\n\tret = regmap_update_bits_check(arizona->regmap,\n\t\t\t\t       ARIZONA_GPIO1_CTRL + offset,\n\t\t\t\t       ARIZONA_GPN_DIR, ARIZONA_GPN_DIR,\n\t\t\t\t       &change);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (change && persistent) {\n\t\tpm_runtime_mark_last_busy(chip->parent);\n\t\tpm_runtime_put_autosuspend(chip->parent);\n\t}\n\n\treturn 0;\n}\n\nstatic int arizona_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct arizona_gpio *arizona_gpio = gpiochip_get_data(chip);\n\tstruct arizona *arizona = arizona_gpio->arizona;\n\tunsigned int reg, val;\n\tint ret;\n\n\treg = ARIZONA_GPIO1_CTRL + offset;\n\tret = regmap_read(arizona->regmap, reg, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (val & ARIZONA_GPN_DIR) {\n\t\tret = pm_runtime_get_sync(chip->parent);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->parent, \"Failed to resume: %d\\n\", ret);\n\t\t\tpm_runtime_put_autosuspend(chip->parent);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = regcache_drop_region(arizona->regmap, reg, reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->parent, \"Failed to drop cache: %d\\n\",\n\t\t\t\tret);\n\t\t\tpm_runtime_put_autosuspend(chip->parent);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_read(arizona->regmap, reg, &val);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_autosuspend(chip->parent);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpm_runtime_mark_last_busy(chip->parent);\n\t\tpm_runtime_put_autosuspend(chip->parent);\n\t}\n\n\tif (val & ARIZONA_GPN_LVL)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int arizona_gpio_direction_out(struct gpio_chip *chip,\n\t\t\t\t     unsigned offset, int value)\n{\n\tstruct arizona_gpio *arizona_gpio = gpiochip_get_data(chip);\n\tstruct arizona *arizona = arizona_gpio->arizona;\n\tbool persistent = gpiochip_line_is_persistent(chip, offset);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(arizona->regmap, ARIZONA_GPIO1_CTRL + offset, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((val & ARIZONA_GPN_DIR) && persistent) {\n\t\tret = pm_runtime_get_sync(chip->parent);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->parent, \"Failed to resume: %d\\n\", ret);\n\t\t\tpm_runtime_put(chip->parent);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (value)\n\t\tvalue = ARIZONA_GPN_LVL;\n\n\treturn regmap_update_bits(arizona->regmap, ARIZONA_GPIO1_CTRL + offset,\n\t\t\t\t  ARIZONA_GPN_DIR | ARIZONA_GPN_LVL, value);\n}\n\nstatic void arizona_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct arizona_gpio *arizona_gpio = gpiochip_get_data(chip);\n\tstruct arizona *arizona = arizona_gpio->arizona;\n\n\tif (value)\n\t\tvalue = ARIZONA_GPN_LVL;\n\n\tregmap_update_bits(arizona->regmap, ARIZONA_GPIO1_CTRL + offset,\n\t\t\t   ARIZONA_GPN_LVL, value);\n}\n\nstatic const struct gpio_chip template_chip = {\n\t.label\t\t\t= \"arizona\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.direction_input\t= arizona_gpio_direction_in,\n\t.get\t\t\t= arizona_gpio_get,\n\t.direction_output\t= arizona_gpio_direction_out,\n\t.set\t\t\t= arizona_gpio_set,\n\t.can_sleep\t\t= true,\n};\n\nstatic int arizona_gpio_probe(struct platform_device *pdev)\n{\n\tstruct arizona *arizona = dev_get_drvdata(pdev->dev.parent);\n\tstruct arizona_pdata *pdata = &arizona->pdata;\n\tstruct arizona_gpio *arizona_gpio;\n\tint ret;\n\n\tdevice_set_node(&pdev->dev, dev_fwnode(pdev->dev.parent));\n\n\tarizona_gpio = devm_kzalloc(&pdev->dev, sizeof(*arizona_gpio),\n\t\t\t\t    GFP_KERNEL);\n\tif (!arizona_gpio)\n\t\treturn -ENOMEM;\n\n\tarizona_gpio->arizona = arizona;\n\tarizona_gpio->gpio_chip = template_chip;\n\tarizona_gpio->gpio_chip.parent = &pdev->dev;\n\n\tswitch (arizona->type) {\n\tcase WM5102:\n\tcase WM5110:\n\tcase WM8280:\n\tcase WM8997:\n\tcase WM8998:\n\tcase WM1814:\n\t\tarizona_gpio->gpio_chip.ngpio = 5;\n\t\tbreak;\n\tcase WM1831:\n\tcase CS47L24:\n\t\tarizona_gpio->gpio_chip.ngpio = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unknown chip variant %d\\n\",\n\t\t\tarizona->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->gpio_base)\n\t\tarizona_gpio->gpio_chip.base = pdata->gpio_base;\n\telse\n\t\tarizona_gpio->gpio_chip.base = -1;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &arizona_gpio->gpio_chip,\n\t\t\t\t     arizona_gpio);\n\tif (ret < 0) {\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tdev_err(&pdev->dev, \"Could not register gpiochip, %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver arizona_gpio_driver = {\n\t.driver.name\t= \"arizona-gpio\",\n\t.probe\t\t= arizona_gpio_probe,\n};\n\nmodule_platform_driver(arizona_gpio_driver);\n\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"GPIO interface for Arizona devices\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:arizona-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}