{
  "module_name": "gpio-max77620.c",
  "hash_id": "47ca978f3b11e7535649db030af68120c64e847a2863d8892266462d269ae273",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-max77620.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/max77620.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define GPIO_REG_ADDR(offset) (MAX77620_REG_GPIO0 + offset)\n\nstruct max77620_gpio {\n\tstruct gpio_chip\tgpio_chip;\n\tstruct regmap\t\t*rmap;\n\tstruct device\t\t*dev;\n\tstruct mutex\t\tbuslock;  \n\tunsigned int\t\tirq_type[MAX77620_GPIO_NR];\n\tbool\t\t\tirq_enabled[MAX77620_GPIO_NR];\n};\n\nstatic irqreturn_t max77620_gpio_irqhandler(int irq, void *data)\n{\n\tstruct max77620_gpio *gpio = data;\n\tunsigned int value, offset;\n\tunsigned long pending;\n\tint err;\n\n\terr = regmap_read(gpio->rmap, MAX77620_REG_IRQ_LVL2_GPIO, &value);\n\tif (err < 0) {\n\t\tdev_err(gpio->dev, \"REG_IRQ_LVL2_GPIO read failed: %d\\n\", err);\n\t\treturn IRQ_NONE;\n\t}\n\n\tpending = value;\n\n\tfor_each_set_bit(offset, &pending, MAX77620_GPIO_NR) {\n\t\tunsigned int virq;\n\n\t\tvirq = irq_find_mapping(gpio->gpio_chip.irq.domain, offset);\n\t\thandle_nested_irq(virq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void max77620_gpio_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct max77620_gpio *gpio = gpiochip_get_data(chip);\n\n\tgpio->irq_enabled[data->hwirq] = false;\n\tgpiochip_disable_irq(chip, data->hwirq);\n}\n\nstatic void max77620_gpio_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct max77620_gpio *gpio = gpiochip_get_data(chip);\n\n\tgpiochip_enable_irq(chip, data->hwirq);\n\tgpio->irq_enabled[data->hwirq] = true;\n}\n\nstatic int max77620_gpio_set_irq_type(struct irq_data *data, unsigned int type)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct max77620_gpio *gpio = gpiochip_get_data(chip);\n\tunsigned int irq_type;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tirq_type = MAX77620_CNFG_GPIO_INT_RISING;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tirq_type = MAX77620_CNFG_GPIO_INT_FALLING;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tirq_type = MAX77620_CNFG_GPIO_INT_RISING |\n\t\t\t   MAX77620_CNFG_GPIO_INT_FALLING;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tgpio->irq_type[data->hwirq] = irq_type;\n\n\treturn 0;\n}\n\nstatic void max77620_gpio_bus_lock(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct max77620_gpio *gpio = gpiochip_get_data(chip);\n\n\tmutex_lock(&gpio->buslock);\n}\n\nstatic void max77620_gpio_bus_sync_unlock(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct max77620_gpio *gpio = gpiochip_get_data(chip);\n\tunsigned int value, offset = data->hwirq;\n\tint err;\n\n\tvalue = gpio->irq_enabled[offset] ? gpio->irq_type[offset] : 0;\n\n\terr = regmap_update_bits(gpio->rmap, GPIO_REG_ADDR(offset),\n\t\t\t\t MAX77620_CNFG_GPIO_INT_MASK, value);\n\tif (err < 0)\n\t\tdev_err(chip->parent, \"failed to update interrupt mask: %d\\n\",\n\t\t\terr);\n\n\tmutex_unlock(&gpio->buslock);\n}\n\nstatic const struct irq_chip max77620_gpio_irqchip = {\n\t.name\t\t= \"max77620-gpio\",\n\t.irq_mask\t= max77620_gpio_irq_mask,\n\t.irq_unmask\t= max77620_gpio_irq_unmask,\n\t.irq_set_type\t= max77620_gpio_set_irq_type,\n\t.irq_bus_lock\t= max77620_gpio_bus_lock,\n\t.irq_bus_sync_unlock = max77620_gpio_bus_sync_unlock,\n\t.flags\t\t= IRQCHIP_IMMUTABLE | IRQCHIP_MASK_ON_SUSPEND,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int max77620_gpio_dir_input(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct max77620_gpio *mgpio = gpiochip_get_data(gc);\n\tint ret;\n\n\tret = regmap_update_bits(mgpio->rmap, GPIO_REG_ADDR(offset),\n\t\t\t\t MAX77620_CNFG_GPIO_DIR_MASK,\n\t\t\t\t MAX77620_CNFG_GPIO_DIR_INPUT);\n\tif (ret < 0)\n\t\tdev_err(mgpio->dev, \"CNFG_GPIOx dir update failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int max77620_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct max77620_gpio *mgpio = gpiochip_get_data(gc);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(mgpio->rmap, GPIO_REG_ADDR(offset), &val);\n\tif (ret < 0) {\n\t\tdev_err(mgpio->dev, \"CNFG_GPIOx read failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif  (val & MAX77620_CNFG_GPIO_DIR_MASK)\n\t\treturn !!(val & MAX77620_CNFG_GPIO_INPUT_VAL_MASK);\n\telse\n\t\treturn !!(val & MAX77620_CNFG_GPIO_OUTPUT_VAL_MASK);\n}\n\nstatic int max77620_gpio_dir_output(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\t    int value)\n{\n\tstruct max77620_gpio *mgpio = gpiochip_get_data(gc);\n\tu8 val;\n\tint ret;\n\n\tval = (value) ? MAX77620_CNFG_GPIO_OUTPUT_VAL_HIGH :\n\t\t\t\tMAX77620_CNFG_GPIO_OUTPUT_VAL_LOW;\n\n\tret = regmap_update_bits(mgpio->rmap, GPIO_REG_ADDR(offset),\n\t\t\t\t MAX77620_CNFG_GPIO_OUTPUT_VAL_MASK, val);\n\tif (ret < 0) {\n\t\tdev_err(mgpio->dev, \"CNFG_GPIOx val update failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(mgpio->rmap, GPIO_REG_ADDR(offset),\n\t\t\t\t MAX77620_CNFG_GPIO_DIR_MASK,\n\t\t\t\t MAX77620_CNFG_GPIO_DIR_OUTPUT);\n\tif (ret < 0)\n\t\tdev_err(mgpio->dev, \"CNFG_GPIOx dir update failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int max77620_gpio_set_debounce(struct max77620_gpio *mgpio,\n\t\t\t\t      unsigned int offset,\n\t\t\t\t      unsigned int debounce)\n{\n\tu8 val;\n\tint ret;\n\n\tswitch (debounce) {\n\tcase 0:\n\t\tval = MAX77620_CNFG_GPIO_DBNC_None;\n\t\tbreak;\n\tcase 1 ... 8000:\n\t\tval = MAX77620_CNFG_GPIO_DBNC_8ms;\n\t\tbreak;\n\tcase 8001 ... 16000:\n\t\tval = MAX77620_CNFG_GPIO_DBNC_16ms;\n\t\tbreak;\n\tcase 16001 ... 32000:\n\t\tval = MAX77620_CNFG_GPIO_DBNC_32ms;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mgpio->dev, \"Illegal value %u\\n\", debounce);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(mgpio->rmap, GPIO_REG_ADDR(offset),\n\t\t\t\t MAX77620_CNFG_GPIO_DBNC_MASK, val);\n\tif (ret < 0)\n\t\tdev_err(mgpio->dev, \"CNFG_GPIOx_DBNC update failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void max77620_gpio_set(struct gpio_chip *gc, unsigned int offset,\n\t\t\t      int value)\n{\n\tstruct max77620_gpio *mgpio = gpiochip_get_data(gc);\n\tu8 val;\n\tint ret;\n\n\tval = (value) ? MAX77620_CNFG_GPIO_OUTPUT_VAL_HIGH :\n\t\t\t\tMAX77620_CNFG_GPIO_OUTPUT_VAL_LOW;\n\n\tret = regmap_update_bits(mgpio->rmap, GPIO_REG_ADDR(offset),\n\t\t\t\t MAX77620_CNFG_GPIO_OUTPUT_VAL_MASK, val);\n\tif (ret < 0)\n\t\tdev_err(mgpio->dev, \"CNFG_GPIO_OUT update failed: %d\\n\", ret);\n}\n\nstatic int max77620_gpio_set_config(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\t    unsigned long config)\n{\n\tstruct max77620_gpio *mgpio = gpiochip_get_data(gc);\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\treturn regmap_update_bits(mgpio->rmap, GPIO_REG_ADDR(offset),\n\t\t\t\t\t  MAX77620_CNFG_GPIO_DRV_MASK,\n\t\t\t\t\t  MAX77620_CNFG_GPIO_DRV_OPENDRAIN);\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\treturn regmap_update_bits(mgpio->rmap, GPIO_REG_ADDR(offset),\n\t\t\t\t\t  MAX77620_CNFG_GPIO_DRV_MASK,\n\t\t\t\t\t  MAX77620_CNFG_GPIO_DRV_PUSHPULL);\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\treturn max77620_gpio_set_debounce(mgpio, offset,\n\t\t\tpinconf_to_config_argument(config));\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic int max77620_gpio_irq_init_hw(struct gpio_chip *gc)\n{\n\tstruct max77620_gpio *gpio = gpiochip_get_data(gc);\n\tunsigned int i;\n\tint err;\n\n\t \n\tfor (i = 0; i < MAX77620_GPIO_NR; i++) {\n\t\terr = regmap_update_bits(gpio->rmap, GPIO_REG_ADDR(i),\n\t\t\t\t\t MAX77620_CNFG_GPIO_INT_MASK, 0);\n\t\tif (err < 0) {\n\t\t\tdev_err(gpio->dev,\n\t\t\t\t\"failed to disable interrupt: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int max77620_gpio_probe(struct platform_device *pdev)\n{\n\tstruct max77620_chip *chip =  dev_get_drvdata(pdev->dev.parent);\n\tstruct max77620_gpio *mgpio;\n\tstruct gpio_irq_chip *girq;\n\tunsigned int gpio_irq;\n\tint ret;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgpio_irq = ret;\n\n\tmgpio = devm_kzalloc(&pdev->dev, sizeof(*mgpio), GFP_KERNEL);\n\tif (!mgpio)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&mgpio->buslock);\n\tmgpio->rmap = chip->rmap;\n\tmgpio->dev = &pdev->dev;\n\n\tmgpio->gpio_chip.label = pdev->name;\n\tmgpio->gpio_chip.parent = pdev->dev.parent;\n\tmgpio->gpio_chip.direction_input = max77620_gpio_dir_input;\n\tmgpio->gpio_chip.get = max77620_gpio_get;\n\tmgpio->gpio_chip.direction_output = max77620_gpio_dir_output;\n\tmgpio->gpio_chip.set = max77620_gpio_set;\n\tmgpio->gpio_chip.set_config = max77620_gpio_set_config;\n\tmgpio->gpio_chip.ngpio = MAX77620_GPIO_NR;\n\tmgpio->gpio_chip.can_sleep = 1;\n\tmgpio->gpio_chip.base = -1;\n\n\tgirq = &mgpio->gpio_chip.irq;\n\tgpio_irq_chip_set_chip(girq, &max77620_gpio_irqchip);\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_edge_irq;\n\tgirq->init_hw = max77620_gpio_irq_init_hw;\n\tgirq->threaded = true;\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &mgpio->gpio_chip, mgpio);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"gpio_init: Failed to add max77620_gpio\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, gpio_irq, NULL,\n\t\t\t\t\tmax77620_gpio_irqhandler, IRQF_ONESHOT,\n\t\t\t\t\t\"max77620-gpio\", mgpio);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id max77620_gpio_devtype[] = {\n\t{ .name = \"max77620-gpio\", },\n\t{ .name = \"max20024-gpio\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, max77620_gpio_devtype);\n\nstatic struct platform_driver max77620_gpio_driver = {\n\t.driver.name\t= \"max77620-gpio\",\n\t.probe\t\t= max77620_gpio_probe,\n\t.id_table\t= max77620_gpio_devtype,\n};\n\nmodule_platform_driver(max77620_gpio_driver);\n\nMODULE_DESCRIPTION(\"GPIO interface for MAX77620 and MAX20024 PMIC\");\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_AUTHOR(\"Chaitanya Bandi <bandik@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}