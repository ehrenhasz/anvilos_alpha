{
  "module_name": "gpio-sifive.c",
  "hash_id": "e6c273ebab935af91bcdcf61832bf8eec5b82786491509997ae91da41e9d5cb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-sifive.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/regmap.h>\n\n#define SIFIVE_GPIO_INPUT_VAL\t0x00\n#define SIFIVE_GPIO_INPUT_EN\t0x04\n#define SIFIVE_GPIO_OUTPUT_EN\t0x08\n#define SIFIVE_GPIO_OUTPUT_VAL\t0x0C\n#define SIFIVE_GPIO_RISE_IE\t0x18\n#define SIFIVE_GPIO_RISE_IP\t0x1C\n#define SIFIVE_GPIO_FALL_IE\t0x20\n#define SIFIVE_GPIO_FALL_IP\t0x24\n#define SIFIVE_GPIO_HIGH_IE\t0x28\n#define SIFIVE_GPIO_HIGH_IP\t0x2C\n#define SIFIVE_GPIO_LOW_IE\t0x30\n#define SIFIVE_GPIO_LOW_IP\t0x34\n#define SIFIVE_GPIO_OUTPUT_XOR\t0x40\n\n#define SIFIVE_GPIO_MAX\t\t32\n\nstruct sifive_gpio {\n\tvoid __iomem\t\t*base;\n\tstruct gpio_chip\tgc;\n\tstruct regmap\t\t*regs;\n\tunsigned long\t\tirq_state;\n\tunsigned int\t\ttrigger[SIFIVE_GPIO_MAX];\n\tunsigned int\t\tirq_number[SIFIVE_GPIO_MAX];\n};\n\nstatic void sifive_gpio_set_ie(struct sifive_gpio *chip, unsigned int offset)\n{\n\tunsigned long flags;\n\tunsigned int trigger;\n\n\traw_spin_lock_irqsave(&chip->gc.bgpio_lock, flags);\n\ttrigger = (chip->irq_state & BIT(offset)) ? chip->trigger[offset] : 0;\n\tregmap_update_bits(chip->regs, SIFIVE_GPIO_RISE_IE, BIT(offset),\n\t\t\t   (trigger & IRQ_TYPE_EDGE_RISING) ? BIT(offset) : 0);\n\tregmap_update_bits(chip->regs, SIFIVE_GPIO_FALL_IE, BIT(offset),\n\t\t\t   (trigger & IRQ_TYPE_EDGE_FALLING) ? BIT(offset) : 0);\n\tregmap_update_bits(chip->regs, SIFIVE_GPIO_HIGH_IE, BIT(offset),\n\t\t\t   (trigger & IRQ_TYPE_LEVEL_HIGH) ? BIT(offset) : 0);\n\tregmap_update_bits(chip->regs, SIFIVE_GPIO_LOW_IE, BIT(offset),\n\t\t\t   (trigger & IRQ_TYPE_LEVEL_LOW) ? BIT(offset) : 0);\n\traw_spin_unlock_irqrestore(&chip->gc.bgpio_lock, flags);\n}\n\nstatic int sifive_gpio_irq_set_type(struct irq_data *d, unsigned int trigger)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct sifive_gpio *chip = gpiochip_get_data(gc);\n\tint offset = irqd_to_hwirq(d);\n\n\tif (offset < 0 || offset >= gc->ngpio)\n\t\treturn -EINVAL;\n\n\tchip->trigger[offset] = trigger;\n\tsifive_gpio_set_ie(chip, offset);\n\treturn 0;\n}\n\nstatic void sifive_gpio_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct sifive_gpio *chip = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tint offset = hwirq % SIFIVE_GPIO_MAX;\n\tu32 bit = BIT(offset);\n\tunsigned long flags;\n\n\tgpiochip_enable_irq(gc, hwirq);\n\tirq_chip_enable_parent(d);\n\n\t \n\tgc->direction_input(gc, offset);\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\t \n\tregmap_write(chip->regs, SIFIVE_GPIO_RISE_IP, bit);\n\tregmap_write(chip->regs, SIFIVE_GPIO_FALL_IP, bit);\n\tregmap_write(chip->regs, SIFIVE_GPIO_HIGH_IP, bit);\n\tregmap_write(chip->regs, SIFIVE_GPIO_LOW_IP, bit);\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\n\t \n\tassign_bit(offset, &chip->irq_state, 1);\n\tsifive_gpio_set_ie(chip, offset);\n}\n\nstatic void sifive_gpio_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct sifive_gpio *chip = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tint offset = hwirq % SIFIVE_GPIO_MAX;\n\n\tassign_bit(offset, &chip->irq_state, 0);\n\tsifive_gpio_set_ie(chip, offset);\n\tirq_chip_disable_parent(d);\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void sifive_gpio_irq_eoi(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct sifive_gpio *chip = gpiochip_get_data(gc);\n\tint offset = irqd_to_hwirq(d) % SIFIVE_GPIO_MAX;\n\tu32 bit = BIT(offset);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\t \n\tregmap_write(chip->regs, SIFIVE_GPIO_RISE_IP, bit);\n\tregmap_write(chip->regs, SIFIVE_GPIO_FALL_IP, bit);\n\tregmap_write(chip->regs, SIFIVE_GPIO_HIGH_IP, bit);\n\tregmap_write(chip->regs, SIFIVE_GPIO_LOW_IP, bit);\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\n\tirq_chip_eoi_parent(d);\n}\n\nstatic int sifive_gpio_irq_set_affinity(struct irq_data *data,\n\t\t\t\t\tconst struct cpumask *dest,\n\t\t\t\t\tbool force)\n{\n\tif (data->parent_data)\n\t\treturn irq_chip_set_affinity_parent(data, dest, force);\n\n\treturn -EINVAL;\n}\n\nstatic const struct irq_chip sifive_gpio_irqchip = {\n\t.name\t\t= \"sifive-gpio\",\n\t.irq_set_type\t= sifive_gpio_irq_set_type,\n\t.irq_mask\t= irq_chip_mask_parent,\n\t.irq_unmask\t= irq_chip_unmask_parent,\n\t.irq_enable\t= sifive_gpio_irq_enable,\n\t.irq_disable\t= sifive_gpio_irq_disable,\n\t.irq_eoi\t= sifive_gpio_irq_eoi,\n\t.irq_set_affinity = sifive_gpio_irq_set_affinity,\n\t.irq_set_wake\t= irq_chip_set_wake_parent,\n\t.flags\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int sifive_gpio_child_to_parent_hwirq(struct gpio_chip *gc,\n\t\t\t\t\t     unsigned int child,\n\t\t\t\t\t     unsigned int child_type,\n\t\t\t\t\t     unsigned int *parent,\n\t\t\t\t\t     unsigned int *parent_type)\n{\n\tstruct sifive_gpio *chip = gpiochip_get_data(gc);\n\tstruct irq_data *d = irq_get_irq_data(chip->irq_number[child]);\n\n\t*parent_type = IRQ_TYPE_NONE;\n\t*parent = irqd_to_hwirq(d);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config sifive_gpio_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.fast_io = true,\n\t.disable_locking = true,\n};\n\nstatic int sifive_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct irq_domain *parent;\n\tstruct gpio_irq_chip *girq;\n\tstruct sifive_gpio *chip;\n\tint ret, ngpio;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(chip->base)) {\n\t\tdev_err(dev, \"failed to allocate device memory\\n\");\n\t\treturn PTR_ERR(chip->base);\n\t}\n\n\tchip->regs = devm_regmap_init_mmio(dev, chip->base,\n\t\t\t\t\t   &sifive_gpio_regmap_config);\n\tif (IS_ERR(chip->regs))\n\t\treturn PTR_ERR(chip->regs);\n\n\tfor (ngpio = 0; ngpio < SIFIVE_GPIO_MAX; ngpio++) {\n\t\tret = platform_get_irq_optional(pdev, ngpio);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tchip->irq_number[ngpio] = ret;\n\t}\n\tif (!ngpio) {\n\t\tdev_err(dev, \"no IRQ found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tparent = irq_get_irq_data(chip->irq_number[0])->domain;\n\n\tret = bgpio_init(&chip->gc, dev, 4,\n\t\t\t chip->base + SIFIVE_GPIO_INPUT_VAL,\n\t\t\t chip->base + SIFIVE_GPIO_OUTPUT_VAL,\n\t\t\t NULL,\n\t\t\t chip->base + SIFIVE_GPIO_OUTPUT_EN,\n\t\t\t chip->base + SIFIVE_GPIO_INPUT_EN,\n\t\t\t BGPIOF_READ_OUTPUT_REG_SET);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to init generic GPIO\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_write(chip->regs, SIFIVE_GPIO_RISE_IE, 0);\n\tregmap_write(chip->regs, SIFIVE_GPIO_FALL_IE, 0);\n\tregmap_write(chip->regs, SIFIVE_GPIO_HIGH_IE, 0);\n\tregmap_write(chip->regs, SIFIVE_GPIO_LOW_IE, 0);\n\tchip->irq_state = 0;\n\n\tchip->gc.base = -1;\n\tchip->gc.ngpio = ngpio;\n\tchip->gc.label = dev_name(dev);\n\tchip->gc.parent = dev;\n\tchip->gc.owner = THIS_MODULE;\n\tgirq = &chip->gc.irq;\n\tgpio_irq_chip_set_chip(girq, &sifive_gpio_irqchip);\n\tgirq->fwnode = dev_fwnode(dev);\n\tgirq->parent_domain = parent;\n\tgirq->child_to_parent_hwirq = sifive_gpio_child_to_parent_hwirq;\n\tgirq->handler = handle_bad_irq;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\n\tplatform_set_drvdata(pdev, chip);\n\treturn gpiochip_add_data(&chip->gc, chip);\n}\n\nstatic const struct of_device_id sifive_gpio_match[] = {\n\t{ .compatible = \"sifive,gpio0\" },\n\t{ .compatible = \"sifive,fu540-c000-gpio\" },\n\t{ },\n};\n\nstatic struct platform_driver sifive_gpio_driver = {\n\t.probe\t\t= sifive_gpio_probe,\n\t.driver = {\n\t\t.name\t= \"sifive_gpio\",\n\t\t.of_match_table = sifive_gpio_match,\n\t},\n};\nmodule_platform_driver(sifive_gpio_driver)\n\nMODULE_AUTHOR(\"Yash Shah <yash.shah@sifive.com>\");\nMODULE_DESCRIPTION(\"SiFive GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}