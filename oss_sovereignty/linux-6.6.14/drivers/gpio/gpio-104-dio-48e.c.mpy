{
  "module_name": "gpio-104-dio-48e.c",
  "hash_id": "92f5fdcf56cb25b5abc13242e1b9406375344f09a2a52ee485d0bbae03b96422",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-104-dio-48e.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i8254.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/isa.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#include \"gpio-i8255.h\"\n\nMODULE_IMPORT_NS(I8255);\n\n#define DIO48E_EXTENT 16\n#define MAX_NUM_DIO48E max_num_isa_dev(DIO48E_EXTENT)\n\nstatic unsigned int base[MAX_NUM_DIO48E];\nstatic unsigned int num_dio48e;\nmodule_param_hw_array(base, uint, ioport, &num_dio48e, 0);\nMODULE_PARM_DESC(base, \"ACCES 104-DIO-48E base addresses\");\n\nstatic unsigned int irq[MAX_NUM_DIO48E];\nstatic unsigned int num_irq;\nmodule_param_hw_array(irq, uint, irq, &num_irq, 0);\nMODULE_PARM_DESC(irq, \"ACCES 104-DIO-48E interrupt line numbers\");\n\n#define DIO48E_ENABLE_INTERRUPT 0xB\n#define DIO48E_DISABLE_INTERRUPT DIO48E_ENABLE_INTERRUPT\n#define DIO48E_ENABLE_COUNTER_TIMER_ADDRESSING 0xD\n#define DIO48E_DISABLE_COUNTER_TIMER_ADDRESSING DIO48E_ENABLE_COUNTER_TIMER_ADDRESSING\n#define DIO48E_CLEAR_INTERRUPT 0xF\n\n#define DIO48E_NUM_PPI 2\n\nstatic const struct regmap_range dio48e_wr_ranges[] = {\n\tregmap_reg_range(0x0, 0x9), regmap_reg_range(0xB, 0xB),\n\tregmap_reg_range(0xD, 0xD), regmap_reg_range(0xF, 0xF),\n};\nstatic const struct regmap_range dio48e_rd_ranges[] = {\n\tregmap_reg_range(0x0, 0x2), regmap_reg_range(0x4, 0x6),\n\tregmap_reg_range(0xB, 0xB), regmap_reg_range(0xD, 0xD),\n\tregmap_reg_range(0xF, 0xF),\n};\nstatic const struct regmap_range dio48e_volatile_ranges[] = {\n\ti8255_volatile_regmap_range(0x0), i8255_volatile_regmap_range(0x4),\n\tregmap_reg_range(0xB, 0xB), regmap_reg_range(0xD, 0xD),\n\tregmap_reg_range(0xF, 0xF),\n};\nstatic const struct regmap_range dio48e_precious_ranges[] = {\n\tregmap_reg_range(0xB, 0xB), regmap_reg_range(0xD, 0xD),\n\tregmap_reg_range(0xF, 0xF),\n};\nstatic const struct regmap_access_table dio48e_wr_table = {\n\t.yes_ranges = dio48e_wr_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(dio48e_wr_ranges),\n};\nstatic const struct regmap_access_table dio48e_rd_table = {\n\t.yes_ranges = dio48e_rd_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(dio48e_rd_ranges),\n};\nstatic const struct regmap_access_table dio48e_volatile_table = {\n\t.yes_ranges = dio48e_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(dio48e_volatile_ranges),\n};\nstatic const struct regmap_access_table dio48e_precious_table = {\n\t.yes_ranges = dio48e_precious_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(dio48e_precious_ranges),\n};\n\nstatic const struct regmap_range pit_wr_ranges[] = {\n\tregmap_reg_range(0x0, 0x3),\n};\nstatic const struct regmap_range pit_rd_ranges[] = {\n\tregmap_reg_range(0x0, 0x2),\n};\nstatic const struct regmap_access_table pit_wr_table = {\n\t.yes_ranges = pit_wr_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(pit_wr_ranges),\n};\nstatic const struct regmap_access_table pit_rd_table = {\n\t.yes_ranges = pit_rd_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(pit_rd_ranges),\n};\n\n \n#define DIO48E_REGMAP_IRQ(_ppi)\t\t\t\t\t\t\\\n\t[19 + (_ppi) * 24] = {\t\t\t\t\t\t\\\n\t\t.mask = BIT(_ppi),\t\t\t\t\t\\\n\t\t.type = { .types_supported = IRQ_TYPE_EDGE_RISING },\t\\\n\t}\n\nstatic const struct regmap_irq dio48e_regmap_irqs[] = {\n\tDIO48E_REGMAP_IRQ(0), DIO48E_REGMAP_IRQ(1),\n};\n\n \nstruct dio48e_gpio {\n\traw_spinlock_t lock;\n\tstruct regmap *map;\n\tvoid __iomem *regs;\n\tunsigned long flags;\n\tunsigned int irq_mask;\n};\n\nstatic void dio48e_regmap_lock(void *lock_arg) __acquires(&dio48egpio->lock)\n{\n\tstruct dio48e_gpio *const dio48egpio = lock_arg;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&dio48egpio->lock, flags);\n\tdio48egpio->flags = flags;\n}\n\nstatic void dio48e_regmap_unlock(void *lock_arg) __releases(&dio48egpio->lock)\n{\n\tstruct dio48e_gpio *const dio48egpio = lock_arg;\n\n\traw_spin_unlock_irqrestore(&dio48egpio->lock, dio48egpio->flags);\n}\n\nstatic void pit_regmap_lock(void *lock_arg) __acquires(&dio48egpio->lock)\n{\n\tstruct dio48e_gpio *const dio48egpio = lock_arg;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&dio48egpio->lock, flags);\n\tdio48egpio->flags = flags;\n\n\tiowrite8(0x00, dio48egpio->regs + DIO48E_ENABLE_COUNTER_TIMER_ADDRESSING);\n}\n\nstatic void pit_regmap_unlock(void *lock_arg) __releases(&dio48egpio->lock)\n{\n\tstruct dio48e_gpio *const dio48egpio = lock_arg;\n\n\tioread8(dio48egpio->regs + DIO48E_DISABLE_COUNTER_TIMER_ADDRESSING);\n\n\traw_spin_unlock_irqrestore(&dio48egpio->lock, dio48egpio->flags);\n}\n\nstatic int dio48e_handle_mask_sync(const int index,\n\t\t\t\t   const unsigned int mask_buf_def,\n\t\t\t\t   const unsigned int mask_buf,\n\t\t\t\t   void *const irq_drv_data)\n{\n\tstruct dio48e_gpio *const dio48egpio = irq_drv_data;\n\tconst unsigned int prev_mask = dio48egpio->irq_mask;\n\tint err;\n\tunsigned int val;\n\n\t \n\tif (mask_buf == prev_mask)\n\t\treturn 0;\n\n\t \n\tdio48egpio->irq_mask = mask_buf;\n\n\t \n\tif (prev_mask == mask_buf_def) {\n\t\terr = regmap_write(dio48egpio->map, DIO48E_CLEAR_INTERRUPT, 0x00);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn regmap_write(dio48egpio->map, DIO48E_ENABLE_INTERRUPT, 0x00);\n\t}\n\n\t \n\tif (mask_buf == mask_buf_def)\n\t\treturn regmap_read(dio48egpio->map, DIO48E_DISABLE_INTERRUPT, &val);\n\n\treturn 0;\n}\n\n#define DIO48E_NGPIO 48\nstatic const char *dio48e_names[DIO48E_NGPIO] = {\n\t\"PPI Group 0 Port A 0\", \"PPI Group 0 Port A 1\", \"PPI Group 0 Port A 2\",\n\t\"PPI Group 0 Port A 3\", \"PPI Group 0 Port A 4\", \"PPI Group 0 Port A 5\",\n\t\"PPI Group 0 Port A 6\", \"PPI Group 0 Port A 7\",\t\"PPI Group 0 Port B 0\",\n\t\"PPI Group 0 Port B 1\", \"PPI Group 0 Port B 2\", \"PPI Group 0 Port B 3\",\n\t\"PPI Group 0 Port B 4\", \"PPI Group 0 Port B 5\", \"PPI Group 0 Port B 6\",\n\t\"PPI Group 0 Port B 7\", \"PPI Group 0 Port C 0\", \"PPI Group 0 Port C 1\",\n\t\"PPI Group 0 Port C 2\", \"PPI Group 0 Port C 3\", \"PPI Group 0 Port C 4\",\n\t\"PPI Group 0 Port C 5\", \"PPI Group 0 Port C 6\", \"PPI Group 0 Port C 7\",\n\t\"PPI Group 1 Port A 0\", \"PPI Group 1 Port A 1\", \"PPI Group 1 Port A 2\",\n\t\"PPI Group 1 Port A 3\", \"PPI Group 1 Port A 4\", \"PPI Group 1 Port A 5\",\n\t\"PPI Group 1 Port A 6\", \"PPI Group 1 Port A 7\",\t\"PPI Group 1 Port B 0\",\n\t\"PPI Group 1 Port B 1\", \"PPI Group 1 Port B 2\", \"PPI Group 1 Port B 3\",\n\t\"PPI Group 1 Port B 4\", \"PPI Group 1 Port B 5\", \"PPI Group 1 Port B 6\",\n\t\"PPI Group 1 Port B 7\", \"PPI Group 1 Port C 0\", \"PPI Group 1 Port C 1\",\n\t\"PPI Group 1 Port C 2\", \"PPI Group 1 Port C 3\", \"PPI Group 1 Port C 4\",\n\t\"PPI Group 1 Port C 5\", \"PPI Group 1 Port C 6\", \"PPI Group 1 Port C 7\"\n};\n\nstatic int dio48e_irq_init_hw(struct regmap *const map)\n{\n\tunsigned int val;\n\n\t \n\treturn regmap_read(map, DIO48E_DISABLE_INTERRUPT, &val);\n}\n\nstatic int dio48e_probe(struct device *dev, unsigned int id)\n{\n\tconst char *const name = dev_name(dev);\n\tstruct i8255_regmap_config config = {};\n\tvoid __iomem *regs;\n\tstruct regmap *map;\n\tstruct regmap_config dio48e_regmap_config;\n\tstruct regmap_config pit_regmap_config;\n\tstruct i8254_regmap_config pit_config;\n\tint err;\n\tstruct regmap_irq_chip *chip;\n\tstruct dio48e_gpio *dio48egpio;\n\tstruct regmap_irq_chip_data *chip_data;\n\n\tif (!devm_request_region(dev, base[id], DIO48E_EXTENT, name)) {\n\t\tdev_err(dev, \"Unable to lock port addresses (0x%X-0x%X)\\n\",\n\t\t\tbase[id], base[id] + DIO48E_EXTENT);\n\t\treturn -EBUSY;\n\t}\n\n\tdio48egpio = devm_kzalloc(dev, sizeof(*dio48egpio), GFP_KERNEL);\n\tif (!dio48egpio)\n\t\treturn -ENOMEM;\n\n\tregs = devm_ioport_map(dev, base[id], DIO48E_EXTENT);\n\tif (!regs)\n\t\treturn -ENOMEM;\n\n\tdio48egpio->regs = regs;\n\n\traw_spin_lock_init(&dio48egpio->lock);\n\n\tdio48e_regmap_config = (struct regmap_config) {\n\t\t.reg_bits = 8,\n\t\t.reg_stride = 1,\n\t\t.val_bits = 8,\n\t\t.lock = dio48e_regmap_lock,\n\t\t.unlock = dio48e_regmap_unlock,\n\t\t.lock_arg = dio48egpio,\n\t\t.io_port = true,\n\t\t.wr_table = &dio48e_wr_table,\n\t\t.rd_table = &dio48e_rd_table,\n\t\t.volatile_table = &dio48e_volatile_table,\n\t\t.precious_table = &dio48e_precious_table,\n\t\t.cache_type = REGCACHE_FLAT,\n\t};\n\n\tmap = devm_regmap_init_mmio(dev, regs, &dio48e_regmap_config);\n\tif (IS_ERR(map))\n\t\treturn dev_err_probe(dev, PTR_ERR(map),\n\t\t\t\t     \"Unable to initialize register map\\n\");\n\n\tdio48egpio->map = map;\n\n\tpit_regmap_config = (struct regmap_config) {\n\t\t.name = \"i8254\",\n\t\t.reg_bits = 8,\n\t\t.reg_stride = 1,\n\t\t.val_bits = 8,\n\t\t.lock = pit_regmap_lock,\n\t\t.unlock = pit_regmap_unlock,\n\t\t.lock_arg = dio48egpio,\n\t\t.io_port = true,\n\t\t.wr_table = &pit_wr_table,\n\t\t.rd_table = &pit_rd_table,\n\t};\n\n\tpit_config.map = devm_regmap_init_mmio(dev, regs, &pit_regmap_config);\n\tif (IS_ERR(pit_config.map))\n\t\treturn dev_err_probe(dev, PTR_ERR(pit_config.map),\n\t\t\t\t     \"Unable to initialize i8254 register map\\n\");\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->name = name;\n\tchip->mask_base = DIO48E_ENABLE_INTERRUPT;\n\tchip->ack_base = DIO48E_CLEAR_INTERRUPT;\n\tchip->no_status = true;\n\tchip->num_regs = 1;\n\tchip->irqs = dio48e_regmap_irqs;\n\tchip->num_irqs = ARRAY_SIZE(dio48e_regmap_irqs);\n\tchip->handle_mask_sync = dio48e_handle_mask_sync;\n\tchip->irq_drv_data = dio48egpio;\n\n\t \n\terr = dio48e_irq_init_hw(map);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_regmap_add_irq_chip(dev, map, irq[id], 0, 0, chip, &chip_data);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"IRQ registration failed\\n\");\n\n\tpit_config.parent = dev;\n\n\terr = devm_i8254_regmap_register(dev, &pit_config);\n\tif (err)\n\t\treturn err;\n\n\tconfig.parent = dev;\n\tconfig.map = map;\n\tconfig.num_ppi = DIO48E_NUM_PPI;\n\tconfig.names = dio48e_names;\n\tconfig.domain = regmap_irq_get_domain(chip_data);\n\n\treturn devm_i8255_regmap_register(dev, &config);\n}\n\nstatic struct isa_driver dio48e_driver = {\n\t.probe = dio48e_probe,\n\t.driver = {\n\t\t.name = \"104-dio-48e\"\n\t},\n};\nmodule_isa_driver_with_irq(dio48e_driver, num_dio48e, num_irq);\n\nMODULE_AUTHOR(\"William Breathitt Gray <vilhelm.gray@gmail.com>\");\nMODULE_DESCRIPTION(\"ACCES 104-DIO-48E GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(I8254);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}