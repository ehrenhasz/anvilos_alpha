{
  "module_name": "gpio-stmpe.c",
  "hash_id": "e65549ffd467882b10a2fbe73e0aa227d2e1c50a21180f9912a1063215b1b5d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-stmpe.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/mfd/stmpe.h>\n#include <linux/seq_file.h>\n#include <linux/bitops.h>\n\n \nenum { REG_RE, REG_FE, REG_IE };\n\nenum { LSB, CSB, MSB };\n\n#define CACHE_NR_REGS\t3\n \n#define CACHE_NR_BANKS\t(24 / 8)\n\nstruct stmpe_gpio {\n\tstruct gpio_chip chip;\n\tstruct stmpe *stmpe;\n\tstruct device *dev;\n\tstruct mutex irq_lock;\n\tu32 norequest_mask;\n\t \n\tu8 regs[CACHE_NR_REGS][CACHE_NR_BANKS];\n\tu8 oldregs[CACHE_NR_REGS][CACHE_NR_BANKS];\n};\n\nstatic int stmpe_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\n\tstruct stmpe *stmpe = stmpe_gpio->stmpe;\n\tu8 reg = stmpe->regs[STMPE_IDX_GPMR_LSB + (offset / 8)];\n\tu8 mask = BIT(offset % 8);\n\tint ret;\n\n\tret = stmpe_reg_read(stmpe, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(ret & mask);\n}\n\nstatic void stmpe_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\n{\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\n\tstruct stmpe *stmpe = stmpe_gpio->stmpe;\n\tint which = val ? STMPE_IDX_GPSR_LSB : STMPE_IDX_GPCR_LSB;\n\tu8 reg = stmpe->regs[which + (offset / 8)];\n\tu8 mask = BIT(offset % 8);\n\n\t \n\tif (stmpe->regs[STMPE_IDX_GPSR_LSB] == stmpe->regs[STMPE_IDX_GPCR_LSB])\n\t\tstmpe_set_bits(stmpe, reg, mask, val ? mask : 0);\n\telse\n\t\tstmpe_reg_write(stmpe, reg, mask);\n}\n\nstatic int stmpe_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t    unsigned offset)\n{\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\n\tstruct stmpe *stmpe = stmpe_gpio->stmpe;\n\tu8 reg = stmpe->regs[STMPE_IDX_GPDR_LSB] - (offset / 8);\n\tu8 mask = BIT(offset % 8);\n\tint ret;\n\n\tret = stmpe_reg_read(stmpe, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & mask)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int stmpe_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t unsigned offset, int val)\n{\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\n\tstruct stmpe *stmpe = stmpe_gpio->stmpe;\n\tu8 reg = stmpe->regs[STMPE_IDX_GPDR_LSB + (offset / 8)];\n\tu8 mask = BIT(offset % 8);\n\n\tstmpe_gpio_set(chip, offset, val);\n\n\treturn stmpe_set_bits(stmpe, reg, mask, mask);\n}\n\nstatic int stmpe_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset)\n{\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\n\tstruct stmpe *stmpe = stmpe_gpio->stmpe;\n\tu8 reg = stmpe->regs[STMPE_IDX_GPDR_LSB + (offset / 8)];\n\tu8 mask = BIT(offset % 8);\n\n\treturn stmpe_set_bits(stmpe, reg, mask, 0);\n}\n\nstatic int stmpe_gpio_request(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\n\tstruct stmpe *stmpe = stmpe_gpio->stmpe;\n\n\tif (stmpe_gpio->norequest_mask & BIT(offset))\n\t\treturn -EINVAL;\n\n\treturn stmpe_set_altfunc(stmpe, BIT(offset), STMPE_BLOCK_GPIO);\n}\n\nstatic const struct gpio_chip template_chip = {\n\t.label\t\t\t= \"stmpe\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.get_direction\t\t= stmpe_gpio_get_direction,\n\t.direction_input\t= stmpe_gpio_direction_input,\n\t.get\t\t\t= stmpe_gpio_get,\n\t.direction_output\t= stmpe_gpio_direction_output,\n\t.set\t\t\t= stmpe_gpio_set,\n\t.request\t\t= stmpe_gpio_request,\n\t.can_sleep\t\t= true,\n};\n\nstatic int stmpe_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\n\tint offset = d->hwirq;\n\tint regoffset = offset / 8;\n\tint mask = BIT(offset % 8);\n\n\tif (type & IRQ_TYPE_LEVEL_LOW || type & IRQ_TYPE_LEVEL_HIGH)\n\t\treturn -EINVAL;\n\n\t \n\tif (stmpe_gpio->stmpe->partnum == STMPE801 ||\n\t    stmpe_gpio->stmpe->partnum == STMPE1600)\n\t\treturn 0;\n\n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tstmpe_gpio->regs[REG_RE][regoffset] |= mask;\n\telse\n\t\tstmpe_gpio->regs[REG_RE][regoffset] &= ~mask;\n\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tstmpe_gpio->regs[REG_FE][regoffset] |= mask;\n\telse\n\t\tstmpe_gpio->regs[REG_FE][regoffset] &= ~mask;\n\n\treturn 0;\n}\n\nstatic void stmpe_gpio_irq_lock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\n\n\tmutex_lock(&stmpe_gpio->irq_lock);\n}\n\nstatic void stmpe_gpio_irq_sync_unlock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\n\tstruct stmpe *stmpe = stmpe_gpio->stmpe;\n\tint num_banks = DIV_ROUND_UP(stmpe->num_gpios, 8);\n\tstatic const u8 regmap[CACHE_NR_REGS][CACHE_NR_BANKS] = {\n\t\t[REG_RE][LSB] = STMPE_IDX_GPRER_LSB,\n\t\t[REG_RE][CSB] = STMPE_IDX_GPRER_CSB,\n\t\t[REG_RE][MSB] = STMPE_IDX_GPRER_MSB,\n\t\t[REG_FE][LSB] = STMPE_IDX_GPFER_LSB,\n\t\t[REG_FE][CSB] = STMPE_IDX_GPFER_CSB,\n\t\t[REG_FE][MSB] = STMPE_IDX_GPFER_MSB,\n\t\t[REG_IE][LSB] = STMPE_IDX_IEGPIOR_LSB,\n\t\t[REG_IE][CSB] = STMPE_IDX_IEGPIOR_CSB,\n\t\t[REG_IE][MSB] = STMPE_IDX_IEGPIOR_MSB,\n\t};\n\tint i, j;\n\n\t \n\tif (stmpe->partnum == STMPE1600) {\n\t\tstmpe_reg_read(stmpe, stmpe->regs[STMPE_IDX_GPMR_LSB]);\n\t\tstmpe_reg_read(stmpe, stmpe->regs[STMPE_IDX_GPMR_CSB]);\n\t}\n\n\tfor (i = 0; i < CACHE_NR_REGS; i++) {\n\t\t \n\t\tif ((stmpe->partnum == STMPE801 ||\n\t\t     stmpe->partnum == STMPE1600) &&\n\t\t     (i != REG_IE))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < num_banks; j++) {\n\t\t\tu8 old = stmpe_gpio->oldregs[i][j];\n\t\t\tu8 new = stmpe_gpio->regs[i][j];\n\n\t\t\tif (new == old)\n\t\t\t\tcontinue;\n\n\t\t\tstmpe_gpio->oldregs[i][j] = new;\n\t\t\tstmpe_reg_write(stmpe, stmpe->regs[regmap[i][j]], new);\n\t\t}\n\t}\n\n\tmutex_unlock(&stmpe_gpio->irq_lock);\n}\n\nstatic void stmpe_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\n\tint offset = d->hwirq;\n\tint regoffset = offset / 8;\n\tint mask = BIT(offset % 8);\n\n\tstmpe_gpio->regs[REG_IE][regoffset] &= ~mask;\n\tgpiochip_disable_irq(gc, offset);\n}\n\nstatic void stmpe_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\n\tint offset = d->hwirq;\n\tint regoffset = offset / 8;\n\tint mask = BIT(offset % 8);\n\n\tgpiochip_enable_irq(gc, offset);\n\tstmpe_gpio->regs[REG_IE][regoffset] |= mask;\n}\n\nstatic void stmpe_dbg_show_one(struct seq_file *s,\n\t\t\t       struct gpio_chip *gc,\n\t\t\t       unsigned offset, unsigned gpio)\n{\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\n\tstruct stmpe *stmpe = stmpe_gpio->stmpe;\n\tconst char *label = gpiochip_is_requested(gc, offset);\n\tbool val = !!stmpe_gpio_get(gc, offset);\n\tu8 bank = offset / 8;\n\tu8 dir_reg = stmpe->regs[STMPE_IDX_GPDR_LSB + bank];\n\tu8 mask = BIT(offset % 8);\n\tint ret;\n\tu8 dir;\n\n\tret = stmpe_reg_read(stmpe, dir_reg);\n\tif (ret < 0)\n\t\treturn;\n\tdir = !!(ret & mask);\n\n\tif (dir) {\n\t\tseq_printf(s, \" gpio-%-3d (%-20.20s) out %s\",\n\t\t\t   gpio, label ?: \"(none)\",\n\t\t\t   val ? \"hi\" : \"lo\");\n\t} else {\n\t\tu8 edge_det_reg;\n\t\tu8 rise_reg;\n\t\tu8 fall_reg;\n\t\tu8 irqen_reg;\n\n\t\tstatic const char * const edge_det_values[] = {\n\t\t\t\"edge-inactive\",\n\t\t\t\"edge-asserted\",\n\t\t\t\"not-supported\"\n\t\t};\n\t\tstatic const char * const rise_values[] = {\n\t\t\t\"no-rising-edge-detection\",\n\t\t\t\"rising-edge-detection\",\n\t\t\t\"not-supported\"\n\t\t};\n\t\tstatic const char * const fall_values[] = {\n\t\t\t\"no-falling-edge-detection\",\n\t\t\t\"falling-edge-detection\",\n\t\t\t\"not-supported\"\n\t\t};\n\t\t#define NOT_SUPPORTED_IDX 2\n\t\tu8 edge_det = NOT_SUPPORTED_IDX;\n\t\tu8 rise = NOT_SUPPORTED_IDX;\n\t\tu8 fall = NOT_SUPPORTED_IDX;\n\t\tbool irqen;\n\n\t\tswitch (stmpe->partnum) {\n\t\tcase STMPE610:\n\t\tcase STMPE811:\n\t\tcase STMPE1601:\n\t\tcase STMPE2401:\n\t\tcase STMPE2403:\n\t\t\tedge_det_reg = stmpe->regs[STMPE_IDX_GPEDR_LSB + bank];\n\t\t\tret = stmpe_reg_read(stmpe, edge_det_reg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\t\t\tedge_det = !!(ret & mask);\n\t\t\tfallthrough;\n\t\tcase STMPE1801:\n\t\t\trise_reg = stmpe->regs[STMPE_IDX_GPRER_LSB + bank];\n\t\t\tfall_reg = stmpe->regs[STMPE_IDX_GPFER_LSB + bank];\n\n\t\t\tret = stmpe_reg_read(stmpe, rise_reg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\t\t\trise = !!(ret & mask);\n\t\t\tret = stmpe_reg_read(stmpe, fall_reg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\t\t\tfall = !!(ret & mask);\n\t\t\tfallthrough;\n\t\tcase STMPE801:\n\t\tcase STMPE1600:\n\t\t\tirqen_reg = stmpe->regs[STMPE_IDX_IEGPIOR_LSB + bank];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\n\t\tret = stmpe_reg_read(stmpe, irqen_reg);\n\t\tif (ret < 0)\n\t\t\treturn;\n\t\tirqen = !!(ret & mask);\n\n\t\tseq_printf(s, \" gpio-%-3d (%-20.20s) in  %s %13s %13s %25s %25s\",\n\t\t\t   gpio, label ?: \"(none)\",\n\t\t\t   val ? \"hi\" : \"lo\",\n\t\t\t   edge_det_values[edge_det],\n\t\t\t   irqen ? \"IRQ-enabled\" : \"IRQ-disabled\",\n\t\t\t   rise_values[rise],\n\t\t\t   fall_values[fall]);\n\t}\n}\n\nstatic void stmpe_dbg_show(struct seq_file *s, struct gpio_chip *gc)\n{\n\tunsigned i;\n\tunsigned gpio = gc->base;\n\n\tfor (i = 0; i < gc->ngpio; i++, gpio++) {\n\t\tstmpe_dbg_show_one(s, gc, i, gpio);\n\t\tseq_putc(s, '\\n');\n\t}\n}\n\nstatic const struct irq_chip stmpe_gpio_irq_chip = {\n\t.name\t\t\t= \"stmpe-gpio\",\n\t.irq_bus_lock\t\t= stmpe_gpio_irq_lock,\n\t.irq_bus_sync_unlock\t= stmpe_gpio_irq_sync_unlock,\n\t.irq_mask\t\t= stmpe_gpio_irq_mask,\n\t.irq_unmask\t\t= stmpe_gpio_irq_unmask,\n\t.irq_set_type\t\t= stmpe_gpio_irq_set_type,\n\t.flags\t\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\n#define MAX_GPIOS 24\n\nstatic irqreturn_t stmpe_gpio_irq(int irq, void *dev)\n{\n\tstruct stmpe_gpio *stmpe_gpio = dev;\n\tstruct stmpe *stmpe = stmpe_gpio->stmpe;\n\tu8 statmsbreg;\n\tint num_banks = DIV_ROUND_UP(stmpe->num_gpios, 8);\n\tu8 status[DIV_ROUND_UP(MAX_GPIOS, 8)];\n\tint ret;\n\tint i;\n\n\t \n\tif (stmpe->partnum == STMPE1600)\n\t\tstatmsbreg = stmpe->regs[STMPE_IDX_ISGPIOR_LSB];\n\telse\n\t\tstatmsbreg = stmpe->regs[STMPE_IDX_ISGPIOR_MSB];\n\n\tret = stmpe_block_read(stmpe, statmsbreg, num_banks, status);\n\tif (ret < 0)\n\t\treturn IRQ_NONE;\n\n\tfor (i = 0; i < num_banks; i++) {\n\t\tint bank = (stmpe_gpio->stmpe->partnum == STMPE1600) ? i :\n\t\t\t   num_banks - i - 1;\n\t\tunsigned int enabled = stmpe_gpio->regs[REG_IE][bank];\n\t\tunsigned int stat = status[i];\n\n\t\tstat &= enabled;\n\t\tif (!stat)\n\t\t\tcontinue;\n\n\t\twhile (stat) {\n\t\t\tint bit = __ffs(stat);\n\t\t\tint line = bank * 8 + bit;\n\t\t\tint child_irq = irq_find_mapping(stmpe_gpio->chip.irq.domain,\n\t\t\t\t\t\t\t line);\n\n\t\t\thandle_nested_irq(child_irq);\n\t\t\tstat &= ~BIT(bit);\n\t\t}\n\n\t\t \n\t\tif (stmpe->partnum != STMPE801 && stmpe->partnum != STMPE1600 &&\n\t\t    stmpe->partnum != STMPE1801) {\n\t\t\tstmpe_reg_write(stmpe, statmsbreg + i, status[i]);\n\t\t\tstmpe_reg_write(stmpe,\n\t\t\t\t\tstmpe->regs[STMPE_IDX_GPEDR_MSB] + i,\n\t\t\t\t\tstatus[i]);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void stmpe_init_irq_valid_mask(struct gpio_chip *gc,\n\t\t\t\t      unsigned long *valid_mask,\n\t\t\t\t      unsigned int ngpios)\n{\n\tstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\n\tint i;\n\n\tif (!stmpe_gpio->norequest_mask)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < sizeof(u32); i++) {\n\t\tif (stmpe_gpio->norequest_mask & BIT(i))\n\t\t\tclear_bit(i, valid_mask);\n\t}\n}\n\nstatic void stmpe_gpio_disable(void *stmpe)\n{\n\tstmpe_disable(stmpe, STMPE_BLOCK_GPIO);\n}\n\nstatic int stmpe_gpio_probe(struct platform_device *pdev)\n{\n\tstruct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct stmpe_gpio *stmpe_gpio;\n\tint ret, irq;\n\n\tif (stmpe->num_gpios > MAX_GPIOS) {\n\t\tdev_err(&pdev->dev, \"Need to increase maximum GPIO number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstmpe_gpio = devm_kzalloc(&pdev->dev, sizeof(*stmpe_gpio), GFP_KERNEL);\n\tif (!stmpe_gpio)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&stmpe_gpio->irq_lock);\n\n\tstmpe_gpio->dev = &pdev->dev;\n\tstmpe_gpio->stmpe = stmpe;\n\tstmpe_gpio->chip = template_chip;\n\tstmpe_gpio->chip.ngpio = stmpe->num_gpios;\n\tstmpe_gpio->chip.parent = &pdev->dev;\n\tstmpe_gpio->chip.base = -1;\n\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n                stmpe_gpio->chip.dbg_show = stmpe_dbg_show;\n\n\tof_property_read_u32(np, \"st,norequest-mask\",\n\t\t\t&stmpe_gpio->norequest_mask);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\tdev_info(&pdev->dev,\n\t\t\t\"device configured in no-irq mode: \"\n\t\t\t\"irqs are not available\\n\");\n\n\tret = stmpe_enable(stmpe, STMPE_BLOCK_GPIO);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&pdev->dev, stmpe_gpio_disable, stmpe);\n\tif (ret)\n\t\treturn ret;\n\n\tif (irq > 0) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\tstmpe_gpio_irq, IRQF_ONESHOT,\n\t\t\t\t\"stmpe-gpio\", stmpe_gpio);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"unable to get irq: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tgirq = &stmpe_gpio->chip.irq;\n\t\tgpio_irq_chip_set_chip(girq, &stmpe_gpio_irq_chip);\n\t\t \n\t\tgirq->parent_handler = NULL;\n\t\tgirq->num_parents = 0;\n\t\tgirq->parents = NULL;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_simple_irq;\n\t\tgirq->threaded = true;\n\t\tgirq->init_valid_mask = stmpe_init_irq_valid_mask;\n\t}\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &stmpe_gpio->chip, stmpe_gpio);\n}\n\nstatic struct platform_driver stmpe_gpio_driver = {\n\t.driver = {\n\t\t.suppress_bind_attrs\t= true,\n\t\t.name\t\t\t= \"stmpe-gpio\",\n\t},\n\t.probe\t\t= stmpe_gpio_probe,\n};\n\nstatic int __init stmpe_gpio_init(void)\n{\n\treturn platform_driver_register(&stmpe_gpio_driver);\n}\nsubsys_initcall(stmpe_gpio_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}