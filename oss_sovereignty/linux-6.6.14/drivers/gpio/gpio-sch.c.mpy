{
  "module_name": "gpio-sch.c",
  "hash_id": "a9b66aab1e116a18d74f9f2f4feeeed92303d88c9345ebea5b8c839fb035623e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-sch.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci_ids.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n#define GEN\t0x00\n#define GIO\t0x04\n#define GLV\t0x08\n#define GTPE\t0x0c\n#define GTNE\t0x10\n#define GGPE\t0x14\n#define GSMI\t0x18\n#define GTS\t0x1c\n\n#define CORE_BANK_OFFSET\t0x00\n#define RESUME_BANK_OFFSET\t0x20\n\n \n#define GPE0E_GPIO\t14\n\nstruct sch_gpio {\n\tstruct gpio_chip chip;\n\tspinlock_t lock;\n\tunsigned short iobase;\n\tunsigned short resume_base;\n\n\t \n\tu32 gpe;\n\tacpi_gpe_handler gpe_handler;\n};\n\nstatic unsigned int sch_gpio_offset(struct sch_gpio *sch, unsigned int gpio,\n\t\t\t\tunsigned int reg)\n{\n\tunsigned int base = CORE_BANK_OFFSET;\n\n\tif (gpio >= sch->resume_base) {\n\t\tgpio -= sch->resume_base;\n\t\tbase = RESUME_BANK_OFFSET;\n\t}\n\n\treturn base + reg + gpio / 8;\n}\n\nstatic unsigned int sch_gpio_bit(struct sch_gpio *sch, unsigned int gpio)\n{\n\tif (gpio >= sch->resume_base)\n\t\tgpio -= sch->resume_base;\n\treturn gpio % 8;\n}\n\nstatic int sch_gpio_reg_get(struct sch_gpio *sch, unsigned int gpio, unsigned int reg)\n{\n\tunsigned short offset, bit;\n\tu8 reg_val;\n\n\toffset = sch_gpio_offset(sch, gpio, reg);\n\tbit = sch_gpio_bit(sch, gpio);\n\n\treg_val = !!(inb(sch->iobase + offset) & BIT(bit));\n\n\treturn reg_val;\n}\n\nstatic void sch_gpio_reg_set(struct sch_gpio *sch, unsigned int gpio, unsigned int reg,\n\t\t\t     int val)\n{\n\tunsigned short offset, bit;\n\tu8 reg_val;\n\n\toffset = sch_gpio_offset(sch, gpio, reg);\n\tbit = sch_gpio_bit(sch, gpio);\n\n\treg_val = inb(sch->iobase + offset);\n\n\tif (val)\n\t\toutb(reg_val | BIT(bit), sch->iobase + offset);\n\telse\n\t\toutb((reg_val & ~BIT(bit)), sch->iobase + offset);\n}\n\nstatic int sch_gpio_direction_in(struct gpio_chip *gc, unsigned int gpio_num)\n{\n\tstruct sch_gpio *sch = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sch->lock, flags);\n\tsch_gpio_reg_set(sch, gpio_num, GIO, 1);\n\tspin_unlock_irqrestore(&sch->lock, flags);\n\treturn 0;\n}\n\nstatic int sch_gpio_get(struct gpio_chip *gc, unsigned int gpio_num)\n{\n\tstruct sch_gpio *sch = gpiochip_get_data(gc);\n\n\treturn sch_gpio_reg_get(sch, gpio_num, GLV);\n}\n\nstatic void sch_gpio_set(struct gpio_chip *gc, unsigned int gpio_num, int val)\n{\n\tstruct sch_gpio *sch = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sch->lock, flags);\n\tsch_gpio_reg_set(sch, gpio_num, GLV, val);\n\tspin_unlock_irqrestore(&sch->lock, flags);\n}\n\nstatic int sch_gpio_direction_out(struct gpio_chip *gc, unsigned int gpio_num,\n\t\t\t\t  int val)\n{\n\tstruct sch_gpio *sch = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sch->lock, flags);\n\tsch_gpio_reg_set(sch, gpio_num, GIO, 0);\n\tspin_unlock_irqrestore(&sch->lock, flags);\n\n\t \n\tsch_gpio_set(gc, gpio_num, val);\n\treturn 0;\n}\n\nstatic int sch_gpio_get_direction(struct gpio_chip *gc, unsigned int gpio_num)\n{\n\tstruct sch_gpio *sch = gpiochip_get_data(gc);\n\n\tif (sch_gpio_reg_get(sch, gpio_num, GIO))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic const struct gpio_chip sch_gpio_chip = {\n\t.label\t\t\t= \"sch_gpio\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.direction_input\t= sch_gpio_direction_in,\n\t.get\t\t\t= sch_gpio_get,\n\t.direction_output\t= sch_gpio_direction_out,\n\t.set\t\t\t= sch_gpio_set,\n\t.get_direction\t\t= sch_gpio_get_direction,\n};\n\nstatic int sch_irq_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct sch_gpio *sch = gpiochip_get_data(gc);\n\tirq_hw_number_t gpio_num = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tint rising, falling;\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\trising = 1;\n\t\tfalling = 0;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\trising = 0;\n\t\tfalling = 1;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\trising = 1;\n\t\tfalling = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&sch->lock, flags);\n\n\tsch_gpio_reg_set(sch, gpio_num, GTPE, rising);\n\tsch_gpio_reg_set(sch, gpio_num, GTNE, falling);\n\n\tirq_set_handler_locked(d, handle_edge_irq);\n\n\tspin_unlock_irqrestore(&sch->lock, flags);\n\n\treturn 0;\n}\n\nstatic void sch_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct sch_gpio *sch = gpiochip_get_data(gc);\n\tirq_hw_number_t gpio_num = irqd_to_hwirq(d);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sch->lock, flags);\n\tsch_gpio_reg_set(sch, gpio_num, GTS, 1);\n\tspin_unlock_irqrestore(&sch->lock, flags);\n}\n\nstatic void sch_irq_mask_unmask(struct gpio_chip *gc, irq_hw_number_t gpio_num, int val)\n{\n\tstruct sch_gpio *sch = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sch->lock, flags);\n\tsch_gpio_reg_set(sch, gpio_num, GGPE, val);\n\tspin_unlock_irqrestore(&sch->lock, flags);\n}\n\nstatic void sch_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t gpio_num = irqd_to_hwirq(d);\n\n\tsch_irq_mask_unmask(gc, gpio_num, 0);\n\tgpiochip_disable_irq(gc, gpio_num);\n}\n\nstatic void sch_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t gpio_num = irqd_to_hwirq(d);\n\n\tgpiochip_enable_irq(gc, gpio_num);\n\tsch_irq_mask_unmask(gc, gpio_num, 1);\n}\n\nstatic const struct irq_chip sch_irqchip = {\n\t.name = \"sch_gpio\",\n\t.irq_ack = sch_irq_ack,\n\t.irq_mask = sch_irq_mask,\n\t.irq_unmask = sch_irq_unmask,\n\t.irq_set_type = sch_irq_type,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic u32 sch_gpio_gpe_handler(acpi_handle gpe_device, u32 gpe, void *context)\n{\n\tstruct sch_gpio *sch = context;\n\tstruct gpio_chip *gc = &sch->chip;\n\tunsigned long core_status, resume_status;\n\tunsigned long pending;\n\tunsigned long flags;\n\tint offset;\n\tu32 ret;\n\n\tspin_lock_irqsave(&sch->lock, flags);\n\n\tcore_status = inl(sch->iobase + CORE_BANK_OFFSET + GTS);\n\tresume_status = inl(sch->iobase + RESUME_BANK_OFFSET + GTS);\n\n\tspin_unlock_irqrestore(&sch->lock, flags);\n\n\tpending = (resume_status << sch->resume_base) | core_status;\n\tfor_each_set_bit(offset, &pending, sch->chip.ngpio)\n\t\tgeneric_handle_domain_irq(gc->irq.domain, offset);\n\n\t \n\tret = pending ? ACPI_INTERRUPT_HANDLED : ACPI_INTERRUPT_NOT_HANDLED;\n\n\t \n\tret |= ACPI_REENABLE_GPE;\n\n\treturn ret;\n}\n\nstatic void sch_gpio_remove_gpe_handler(void *data)\n{\n\tstruct sch_gpio *sch = data;\n\n\tacpi_disable_gpe(NULL, sch->gpe);\n\tacpi_remove_gpe_handler(NULL, sch->gpe, sch->gpe_handler);\n}\n\nstatic int sch_gpio_install_gpe_handler(struct sch_gpio *sch)\n{\n\tstruct device *dev = sch->chip.parent;\n\tacpi_status status;\n\n\tstatus = acpi_install_gpe_handler(NULL, sch->gpe, ACPI_GPE_LEVEL_TRIGGERED,\n\t\t\t\t\t  sch->gpe_handler, sch);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(dev, \"Failed to install GPE handler for %u: %s\\n\",\n\t\t\tsch->gpe, acpi_format_exception(status));\n\t\treturn -ENODEV;\n\t}\n\n\tstatus = acpi_enable_gpe(NULL, sch->gpe);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(dev, \"Failed to enable GPE handler for %u: %s\\n\",\n\t\t\tsch->gpe, acpi_format_exception(status));\n\t\tacpi_remove_gpe_handler(NULL, sch->gpe, sch->gpe_handler);\n\t\treturn -ENODEV;\n\t}\n\n\treturn devm_add_action_or_reset(dev, sch_gpio_remove_gpe_handler, sch);\n}\n\nstatic int sch_gpio_probe(struct platform_device *pdev)\n{\n\tstruct gpio_irq_chip *girq;\n\tstruct sch_gpio *sch;\n\tstruct resource *res;\n\tint ret;\n\n\tsch = devm_kzalloc(&pdev->dev, sizeof(*sch), GFP_KERNEL);\n\tif (!sch)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!res)\n\t\treturn -EBUSY;\n\n\tif (!devm_request_region(&pdev->dev, res->start, resource_size(res),\n\t\t\t\t pdev->name))\n\t\treturn -EBUSY;\n\n\tspin_lock_init(&sch->lock);\n\tsch->iobase = res->start;\n\tsch->chip = sch_gpio_chip;\n\tsch->chip.label = dev_name(&pdev->dev);\n\tsch->chip.parent = &pdev->dev;\n\n\tswitch (pdev->id) {\n\tcase PCI_DEVICE_ID_INTEL_SCH_LPC:\n\t\tsch->resume_base = 10;\n\t\tsch->chip.ngpio = 14;\n\n\t\t \n\t\tsch_gpio_reg_set(sch, 8, GEN, 1);\n\t\tsch_gpio_reg_set(sch, 9, GEN, 1);\n\t\t \n\t\tsch_gpio_reg_set(sch, 13, GEN, 1);\n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_INTEL_ITC_LPC:\n\t\tsch->resume_base = 5;\n\t\tsch->chip.ngpio = 14;\n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_INTEL_CENTERTON_ILB:\n\t\tsch->resume_base = 21;\n\t\tsch->chip.ngpio = 30;\n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_INTEL_QUARK_X1000_ILB:\n\t\tsch->resume_base = 2;\n\t\tsch->chip.ngpio = 8;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tgirq = &sch->chip.irq;\n\tgpio_irq_chip_set_chip(girq, &sch_irqchip);\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->parent_handler = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\n\t \n\tsch->gpe = GPE0E_GPIO;\n\tsch->gpe_handler = sch_gpio_gpe_handler;\n\n\tret = sch_gpio_install_gpe_handler(sch);\n\tif (ret)\n\t\tdev_warn(&pdev->dev, \"Can't setup GPE, no IRQ support\\n\");\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &sch->chip, sch);\n}\n\nstatic struct platform_driver sch_gpio_driver = {\n\t.driver = {\n\t\t.name = \"sch_gpio\",\n\t},\n\t.probe\t\t= sch_gpio_probe,\n};\n\nmodule_platform_driver(sch_gpio_driver);\n\nMODULE_AUTHOR(\"Denis Turischev <denis@compulab.co.il>\");\nMODULE_DESCRIPTION(\"GPIO interface for Intel Poulsbo SCH\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:sch_gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}