{
  "module_name": "gpio-vx855.c",
  "hash_id": "5773aae87f79ef010d9aa64e32309ee3c6806ba36838c8680383bd1c9a0d0023",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-vx855.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio/driver.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n\n#define MODULE_NAME \"vx855_gpio\"\n\n \n\n#define NR_VX855_GPI\t14\n#define NR_VX855_GPO\t13\n#define NR_VX855_GPIO\t15\n\n#define NR_VX855_GPInO\t(NR_VX855_GPI + NR_VX855_GPO)\n#define NR_VX855_GP\t(NR_VX855_GPI + NR_VX855_GPO + NR_VX855_GPIO)\n\nstruct vx855_gpio {\n\tstruct gpio_chip gpio;\n\tspinlock_t lock;\n\tu32 io_gpi;\n\tu32 io_gpo;\n};\n\n \nstatic inline u_int32_t gpi_i_bit(int i)\n{\n\tif (i < 10)\n\t\treturn 1 << i;\n\telse\n\t\treturn 1 << (i + 14);\n}\n\nstatic inline u_int32_t gpo_o_bit(int i)\n{\n\tif (i < 11)\n\t\treturn 1 << i;\n\telse\n\t\treturn 1 << (i + 14);\n}\n\nstatic inline u_int32_t gpio_i_bit(int i)\n{\n\tif (i < 14)\n\t\treturn 1 << (i + 10);\n\telse\n\t\treturn 1 << (i + 14);\n}\n\nstatic inline u_int32_t gpio_o_bit(int i)\n{\n\tif (i < 14)\n\t\treturn 1 << (i + 11);\n\telse\n\t\treturn 1 << (i + 13);\n}\n\n \n\nstatic int vx855gpio_direction_input(struct gpio_chip *gpio,\n\t\t\t\t     unsigned int nr)\n{\n\tstruct vx855_gpio *vg = gpiochip_get_data(gpio);\n\tunsigned long flags;\n\tu_int32_t reg_out;\n\n\t \n\tif (nr < NR_VX855_GPI)\n\t\treturn 0;\n\n\t \n\tif (nr < NR_VX855_GPInO)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock_irqsave(&vg->lock, flags);\n\treg_out = inl(vg->io_gpo);\n\treg_out |= gpio_o_bit(nr - NR_VX855_GPInO);\n\toutl(reg_out, vg->io_gpo);\n\tspin_unlock_irqrestore(&vg->lock, flags);\n\n\treturn 0;\n}\n\nstatic int vx855gpio_get(struct gpio_chip *gpio, unsigned int nr)\n{\n\tstruct vx855_gpio *vg = gpiochip_get_data(gpio);\n\tu_int32_t reg_in;\n\tint ret = 0;\n\n\tif (nr < NR_VX855_GPI) {\n\t\treg_in = inl(vg->io_gpi);\n\t\tif (reg_in & gpi_i_bit(nr))\n\t\t\tret = 1;\n\t} else if (nr < NR_VX855_GPInO) {\n\t\t \n\t\treg_in = inl(vg->io_gpo);\n\t\tif (reg_in & gpo_o_bit(nr - NR_VX855_GPI))\n\t\t\tret = 1;\n\t} else {\n\t\treg_in = inl(vg->io_gpi);\n\t\tif (reg_in & gpio_i_bit(nr - NR_VX855_GPInO))\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic void vx855gpio_set(struct gpio_chip *gpio, unsigned int nr,\n\t\t\t  int val)\n{\n\tstruct vx855_gpio *vg = gpiochip_get_data(gpio);\n\tunsigned long flags;\n\tu_int32_t reg_out;\n\n\t \n\tif (nr < NR_VX855_GPI)\n\t\treturn;\n\n\tspin_lock_irqsave(&vg->lock, flags);\n\treg_out = inl(vg->io_gpo);\n\tif (nr < NR_VX855_GPInO) {\n\t\tif (val)\n\t\t\treg_out |= gpo_o_bit(nr - NR_VX855_GPI);\n\t\telse\n\t\t\treg_out &= ~gpo_o_bit(nr - NR_VX855_GPI);\n\t} else {\n\t\tif (val)\n\t\t\treg_out |= gpio_o_bit(nr - NR_VX855_GPInO);\n\t\telse\n\t\t\treg_out &= ~gpio_o_bit(nr - NR_VX855_GPInO);\n\t}\n\toutl(reg_out, vg->io_gpo);\n\tspin_unlock_irqrestore(&vg->lock, flags);\n}\n\nstatic int vx855gpio_direction_output(struct gpio_chip *gpio,\n\t\t\t\t      unsigned int nr, int val)\n{\n\t \n\tif (nr < NR_VX855_GPI)\n\t\treturn -EINVAL;\n\n\t \n\tvx855gpio_set(gpio, nr, val);\n\n\treturn 0;\n}\n\nstatic int vx855gpio_set_config(struct gpio_chip *gpio, unsigned int nr,\n\t\t\t\tunsigned long config)\n{\n\tenum pin_config_param param = pinconf_to_config_param(config);\n\n\t \n\tif (nr < NR_VX855_GPI)\n\t\treturn -EINVAL;\n\n\t \n\tif (nr < NR_VX855_GPInO) {\n\t\tif (param != PIN_CONFIG_DRIVE_PUSH_PULL)\n\t\t\treturn -ENOTSUPP;\n\t\treturn 0;\n\t}\n\n\t \n\tif (param != PIN_CONFIG_DRIVE_OPEN_DRAIN)\n\t\treturn -ENOTSUPP;\n\n\treturn 0;\n}\n\nstatic const char *vx855gpio_names[NR_VX855_GP] = {\n\t\"VX855_GPI0\", \"VX855_GPI1\", \"VX855_GPI2\", \"VX855_GPI3\", \"VX855_GPI4\",\n\t\"VX855_GPI5\", \"VX855_GPI6\", \"VX855_GPI7\", \"VX855_GPI8\", \"VX855_GPI9\",\n\t\"VX855_GPI10\", \"VX855_GPI11\", \"VX855_GPI12\", \"VX855_GPI13\",\n\t\"VX855_GPO0\", \"VX855_GPO1\", \"VX855_GPO2\", \"VX855_GPO3\", \"VX855_GPO4\",\n\t\"VX855_GPO5\", \"VX855_GPO6\", \"VX855_GPO7\", \"VX855_GPO8\", \"VX855_GPO9\",\n\t\"VX855_GPO10\", \"VX855_GPO11\", \"VX855_GPO12\",\n\t\"VX855_GPIO0\", \"VX855_GPIO1\", \"VX855_GPIO2\", \"VX855_GPIO3\",\n\t\"VX855_GPIO4\", \"VX855_GPIO5\", \"VX855_GPIO6\", \"VX855_GPIO7\",\n\t\"VX855_GPIO8\", \"VX855_GPIO9\", \"VX855_GPIO10\", \"VX855_GPIO11\",\n\t\"VX855_GPIO12\", \"VX855_GPIO13\", \"VX855_GPIO14\"\n};\n\nstatic void vx855gpio_gpio_setup(struct vx855_gpio *vg)\n{\n\tstruct gpio_chip *c = &vg->gpio;\n\n\tc->label = \"VX855 South Bridge\";\n\tc->owner = THIS_MODULE;\n\tc->direction_input = vx855gpio_direction_input;\n\tc->direction_output = vx855gpio_direction_output;\n\tc->get = vx855gpio_get;\n\tc->set = vx855gpio_set;\n\tc->set_config = vx855gpio_set_config;\n\tc->dbg_show = NULL;\n\tc->base = 0;\n\tc->ngpio = NR_VX855_GP;\n\tc->can_sleep = false;\n\tc->names = vx855gpio_names;\n}\n\n \nstatic int vx855gpio_probe(struct platform_device *pdev)\n{\n\tstruct resource *res_gpi;\n\tstruct resource *res_gpo;\n\tstruct vx855_gpio *vg;\n\n\tres_gpi = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tres_gpo = platform_get_resource(pdev, IORESOURCE_IO, 1);\n\tif (!res_gpi || !res_gpo)\n\t\treturn -EBUSY;\n\n\tvg = devm_kzalloc(&pdev->dev, sizeof(*vg), GFP_KERNEL);\n\tif (!vg)\n\t\treturn -ENOMEM;\n\n\tdev_info(&pdev->dev, \"found VX855 GPIO controller\\n\");\n\tvg->io_gpi = res_gpi->start;\n\tvg->io_gpo = res_gpo->start;\n\tspin_lock_init(&vg->lock);\n\n\t \n\n\tif (!devm_request_region(&pdev->dev, res_gpi->start,\n\t\t\t\t resource_size(res_gpi), MODULE_NAME \"_gpi\"))\n\t\tdev_warn(&pdev->dev,\n\t\t\t\"GPI I/O resource busy, probably claimed by ACPI\\n\");\n\n\tif (!devm_request_region(&pdev->dev, res_gpo->start,\n\t\t\t\t resource_size(res_gpo), MODULE_NAME \"_gpo\"))\n\t\tdev_warn(&pdev->dev,\n\t\t\t\"GPO I/O resource busy, probably claimed by ACPI\\n\");\n\n\tvx855gpio_gpio_setup(vg);\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &vg->gpio, vg);\n}\n\nstatic struct platform_driver vx855gpio_driver = {\n\t.driver = {\n\t\t.name\t= MODULE_NAME,\n\t},\n\t.probe\t\t= vx855gpio_probe,\n};\n\nmodule_platform_driver(vx855gpio_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Harald Welte <HaraldWelte@viatech.com>\");\nMODULE_DESCRIPTION(\"GPIO driver for the VIA VX855 chipset\");\nMODULE_ALIAS(\"platform:vx855_gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}