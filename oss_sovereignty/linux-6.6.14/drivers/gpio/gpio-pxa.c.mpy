{
  "module_name": "gpio-pxa.c",
  "hash_id": "03093a0c19ef9cf1d18157104562fa81aa60ba2c8ebb0fd0d666167bc0873871",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-pxa.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio-pxa.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/syscore_ops.h>\n#include <linux/slab.h>\n\n \n\n#define GPLR_OFFSET\t0x00\n#define GPDR_OFFSET\t0x0C\n#define GPSR_OFFSET\t0x18\n#define GPCR_OFFSET\t0x24\n#define GRER_OFFSET\t0x30\n#define GFER_OFFSET\t0x3C\n#define GEDR_OFFSET\t0x48\n#define GAFR_OFFSET\t0x54\n#define ED_MASK_OFFSET\t0x9C\t \n\n#define BANK_OFF(n)\t(((n) / 3) << 8) + (((n) % 3) << 2)\n\nint pxa_last_gpio;\nstatic int irq_base;\n\nstruct pxa_gpio_bank {\n\tvoid __iomem\t*regbase;\n\tunsigned long\tirq_mask;\n\tunsigned long\tirq_edge_rise;\n\tunsigned long\tirq_edge_fall;\n\n#ifdef CONFIG_PM\n\tunsigned long\tsaved_gplr;\n\tunsigned long\tsaved_gpdr;\n\tunsigned long\tsaved_grer;\n\tunsigned long\tsaved_gfer;\n#endif\n};\n\nstruct pxa_gpio_chip {\n\tstruct device *dev;\n\tstruct gpio_chip chip;\n\tstruct pxa_gpio_bank *banks;\n\tstruct irq_domain *irqdomain;\n\n\tint irq0;\n\tint irq1;\n\tint (*set_wake)(unsigned int gpio, unsigned int on);\n};\n\nenum pxa_gpio_type {\n\tPXA25X_GPIO = 0,\n\tPXA26X_GPIO,\n\tPXA27X_GPIO,\n\tPXA3XX_GPIO,\n\tPXA93X_GPIO,\n\tMMP_GPIO = 0x10,\n\tMMP2_GPIO,\n\tPXA1928_GPIO,\n};\n\nstruct pxa_gpio_id {\n\tenum pxa_gpio_type\ttype;\n\tint\t\t\tgpio_nums;\n};\n\nstatic DEFINE_SPINLOCK(gpio_lock);\nstatic struct pxa_gpio_chip *pxa_gpio_chip;\nstatic enum pxa_gpio_type gpio_type;\n\nstatic struct pxa_gpio_id pxa25x_id = {\n\t.type\t\t= PXA25X_GPIO,\n\t.gpio_nums\t= 85,\n};\n\nstatic struct pxa_gpio_id pxa26x_id = {\n\t.type\t\t= PXA26X_GPIO,\n\t.gpio_nums\t= 90,\n};\n\nstatic struct pxa_gpio_id pxa27x_id = {\n\t.type\t\t= PXA27X_GPIO,\n\t.gpio_nums\t= 121,\n};\n\nstatic struct pxa_gpio_id pxa3xx_id = {\n\t.type\t\t= PXA3XX_GPIO,\n\t.gpio_nums\t= 128,\n};\n\nstatic struct pxa_gpio_id pxa93x_id = {\n\t.type\t\t= PXA93X_GPIO,\n\t.gpio_nums\t= 192,\n};\n\nstatic struct pxa_gpio_id mmp_id = {\n\t.type\t\t= MMP_GPIO,\n\t.gpio_nums\t= 128,\n};\n\nstatic struct pxa_gpio_id mmp2_id = {\n\t.type\t\t= MMP2_GPIO,\n\t.gpio_nums\t= 192,\n};\n\nstatic struct pxa_gpio_id pxa1928_id = {\n\t.type\t\t= PXA1928_GPIO,\n\t.gpio_nums\t= 224,\n};\n\n#define for_each_gpio_bank(i, b, pc)\t\t\t\t\t\\\n\tfor (i = 0, b = pc->banks; i <= pxa_last_gpio; i += 32, b++)\n\nstatic inline struct pxa_gpio_chip *chip_to_pxachip(struct gpio_chip *c)\n{\n\tstruct pxa_gpio_chip *pxa_chip = gpiochip_get_data(c);\n\n\treturn pxa_chip;\n}\n\nstatic inline void __iomem *gpio_bank_base(struct gpio_chip *c, int gpio)\n{\n\tstruct pxa_gpio_chip *p = gpiochip_get_data(c);\n\tstruct pxa_gpio_bank *bank = p->banks + (gpio / 32);\n\n\treturn bank->regbase;\n}\n\nstatic inline struct pxa_gpio_bank *gpio_to_pxabank(struct gpio_chip *c,\n\t\t\t\t\t\t    unsigned gpio)\n{\n\treturn chip_to_pxachip(c)->banks + gpio / 32;\n}\n\nstatic inline int gpio_is_mmp_type(int type)\n{\n\treturn (type & MMP_GPIO) != 0;\n}\n\n \nstatic inline int __gpio_is_inverted(int gpio)\n{\n\tif ((gpio_type == PXA26X_GPIO) && (gpio > 85))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic inline int __gpio_is_occupied(struct pxa_gpio_chip *pchip, unsigned gpio)\n{\n\tvoid __iomem *base;\n\tunsigned long gafr = 0, gpdr = 0;\n\tint ret, af = 0, dir = 0;\n\n\tbase = gpio_bank_base(&pchip->chip, gpio);\n\tgpdr = readl_relaxed(base + GPDR_OFFSET);\n\n\tswitch (gpio_type) {\n\tcase PXA25X_GPIO:\n\tcase PXA26X_GPIO:\n\tcase PXA27X_GPIO:\n\t\tgafr = readl_relaxed(base + GAFR_OFFSET);\n\t\taf = (gafr >> ((gpio & 0xf) * 2)) & 0x3;\n\t\tdir = gpdr & GPIO_bit(gpio);\n\n\t\tif (__gpio_is_inverted(gpio))\n\t\t\tret = (af != 1) || (dir == 0);\n\t\telse\n\t\t\tret = (af != 0) || (dir != 0);\n\t\tbreak;\n\tdefault:\n\t\tret = gpdr & GPIO_bit(gpio);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint pxa_irq_to_gpio(int irq)\n{\n\tstruct pxa_gpio_chip *pchip = pxa_gpio_chip;\n\tint irq_gpio0;\n\n\tirq_gpio0 = irq_find_mapping(pchip->irqdomain, 0);\n\tif (irq_gpio0 > 0)\n\t\treturn irq - irq_gpio0;\n\n\treturn irq_gpio0;\n}\n\nstatic bool pxa_gpio_has_pinctrl(void)\n{\n\tswitch (gpio_type) {\n\tcase PXA3XX_GPIO:\n\tcase MMP2_GPIO:\n\tcase MMP_GPIO:\n\t\treturn false;\n\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic int pxa_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct pxa_gpio_chip *pchip = chip_to_pxachip(chip);\n\n\treturn irq_find_mapping(pchip->irqdomain, offset);\n}\n\nstatic int pxa_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tvoid __iomem *base = gpio_bank_base(chip, offset);\n\tuint32_t value, mask = GPIO_bit(offset);\n\tunsigned long flags;\n\tint ret;\n\n\tif (pxa_gpio_has_pinctrl()) {\n\t\tret = pinctrl_gpio_direction_input(chip->base + offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\n\tvalue = readl_relaxed(base + GPDR_OFFSET);\n\tif (__gpio_is_inverted(chip->base + offset))\n\t\tvalue |= mask;\n\telse\n\t\tvalue &= ~mask;\n\twritel_relaxed(value, base + GPDR_OFFSET);\n\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\treturn 0;\n}\n\nstatic int pxa_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t     unsigned offset, int value)\n{\n\tvoid __iomem *base = gpio_bank_base(chip, offset);\n\tuint32_t tmp, mask = GPIO_bit(offset);\n\tunsigned long flags;\n\tint ret;\n\n\twritel_relaxed(mask, base + (value ? GPSR_OFFSET : GPCR_OFFSET));\n\n\tif (pxa_gpio_has_pinctrl()) {\n\t\tret = pinctrl_gpio_direction_output(chip->base + offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\n\ttmp = readl_relaxed(base + GPDR_OFFSET);\n\tif (__gpio_is_inverted(chip->base + offset))\n\t\ttmp &= ~mask;\n\telse\n\t\ttmp |= mask;\n\twritel_relaxed(tmp, base + GPDR_OFFSET);\n\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\treturn 0;\n}\n\nstatic int pxa_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tvoid __iomem *base = gpio_bank_base(chip, offset);\n\tu32 gplr = readl_relaxed(base + GPLR_OFFSET);\n\n\treturn !!(gplr & GPIO_bit(offset));\n}\n\nstatic void pxa_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tvoid __iomem *base = gpio_bank_base(chip, offset);\n\n\twritel_relaxed(GPIO_bit(offset),\n\t\t       base + (value ? GPSR_OFFSET : GPCR_OFFSET));\n}\n\n#ifdef CONFIG_OF_GPIO\nstatic int pxa_gpio_of_xlate(struct gpio_chip *gc,\n\t\t\t     const struct of_phandle_args *gpiospec,\n\t\t\t     u32 *flags)\n{\n\tif (gpiospec->args[0] > pxa_last_gpio)\n\t\treturn -EINVAL;\n\n\tif (flags)\n\t\t*flags = gpiospec->args[1];\n\n\treturn gpiospec->args[0];\n}\n#endif\n\nstatic int pxa_init_gpio_chip(struct pxa_gpio_chip *pchip, int ngpio, void __iomem *regbase)\n{\n\tint i, gpio, nbanks = DIV_ROUND_UP(ngpio, 32);\n\tstruct pxa_gpio_bank *bank;\n\n\tpchip->banks = devm_kcalloc(pchip->dev, nbanks, sizeof(*pchip->banks),\n\t\t\t\t    GFP_KERNEL);\n\tif (!pchip->banks)\n\t\treturn -ENOMEM;\n\n\tpchip->chip.parent = pchip->dev;\n\tpchip->chip.label = \"gpio-pxa\";\n\tpchip->chip.direction_input  = pxa_gpio_direction_input;\n\tpchip->chip.direction_output = pxa_gpio_direction_output;\n\tpchip->chip.get = pxa_gpio_get;\n\tpchip->chip.set = pxa_gpio_set;\n\tpchip->chip.to_irq = pxa_gpio_to_irq;\n\tpchip->chip.ngpio = ngpio;\n\tpchip->chip.request = gpiochip_generic_request;\n\tpchip->chip.free = gpiochip_generic_free;\n\n#ifdef CONFIG_OF_GPIO\n\tpchip->chip.of_xlate = pxa_gpio_of_xlate;\n\tpchip->chip.of_gpio_n_cells = 2;\n#endif\n\n\tfor (i = 0, gpio = 0; i < nbanks; i++, gpio += 32) {\n\t\tbank = pchip->banks + i;\n\t\tbank->regbase = regbase + BANK_OFF(i);\n\t}\n\n\treturn gpiochip_add_data(&pchip->chip, pchip);\n}\n\n \nstatic inline void update_edge_detect(struct pxa_gpio_bank *c)\n{\n\tuint32_t grer, gfer;\n\n\tgrer = readl_relaxed(c->regbase + GRER_OFFSET) & ~c->irq_mask;\n\tgfer = readl_relaxed(c->regbase + GFER_OFFSET) & ~c->irq_mask;\n\tgrer |= c->irq_edge_rise & c->irq_mask;\n\tgfer |= c->irq_edge_fall & c->irq_mask;\n\twritel_relaxed(grer, c->regbase + GRER_OFFSET);\n\twritel_relaxed(gfer, c->regbase + GFER_OFFSET);\n}\n\nstatic int pxa_gpio_irq_type(struct irq_data *d, unsigned int type)\n{\n\tstruct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);\n\tunsigned int gpio = irqd_to_hwirq(d);\n\tstruct pxa_gpio_bank *c = gpio_to_pxabank(&pchip->chip, gpio);\n\tunsigned long gpdr, mask = GPIO_bit(gpio);\n\n\tif (type == IRQ_TYPE_PROBE) {\n\t\t \n\t\tif ((c->irq_edge_rise | c->irq_edge_fall) & GPIO_bit(gpio))\n\t\t\treturn 0;\n\n\t\tif (__gpio_is_occupied(pchip, gpio))\n\t\t\treturn 0;\n\n\t\ttype = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\n\t}\n\n\tgpdr = readl_relaxed(c->regbase + GPDR_OFFSET);\n\n\tif (__gpio_is_inverted(gpio))\n\t\twritel_relaxed(gpdr | mask,  c->regbase + GPDR_OFFSET);\n\telse\n\t\twritel_relaxed(gpdr & ~mask, c->regbase + GPDR_OFFSET);\n\n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tc->irq_edge_rise |= mask;\n\telse\n\t\tc->irq_edge_rise &= ~mask;\n\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tc->irq_edge_fall |= mask;\n\telse\n\t\tc->irq_edge_fall &= ~mask;\n\n\tupdate_edge_detect(c);\n\n\tpr_debug(\"%s: IRQ%d (GPIO%d) - edge%s%s\\n\", __func__, d->irq, gpio,\n\t\t((type & IRQ_TYPE_EDGE_RISING)  ? \" rising\"  : \"\"),\n\t\t((type & IRQ_TYPE_EDGE_FALLING) ? \" falling\" : \"\"));\n\treturn 0;\n}\n\nstatic irqreturn_t pxa_gpio_demux_handler(int in_irq, void *d)\n{\n\tint loop, gpio, n, handled = 0;\n\tunsigned long gedr;\n\tstruct pxa_gpio_chip *pchip = d;\n\tstruct pxa_gpio_bank *c;\n\n\tdo {\n\t\tloop = 0;\n\t\tfor_each_gpio_bank(gpio, c, pchip) {\n\t\t\tgedr = readl_relaxed(c->regbase + GEDR_OFFSET);\n\t\t\tgedr = gedr & c->irq_mask;\n\t\t\twritel_relaxed(gedr, c->regbase + GEDR_OFFSET);\n\n\t\t\tfor_each_set_bit(n, &gedr, BITS_PER_LONG) {\n\t\t\t\tloop = 1;\n\n\t\t\t\tgeneric_handle_domain_irq(pchip->irqdomain,\n\t\t\t\t\t\t\t  gpio + n);\n\t\t\t}\n\t\t}\n\t\thandled += loop;\n\t} while (loop);\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic irqreturn_t pxa_gpio_direct_handler(int in_irq, void *d)\n{\n\tstruct pxa_gpio_chip *pchip = d;\n\n\tif (in_irq == pchip->irq0) {\n\t\tgeneric_handle_domain_irq(pchip->irqdomain, 0);\n\t} else if (in_irq == pchip->irq1) {\n\t\tgeneric_handle_domain_irq(pchip->irqdomain, 1);\n\t} else {\n\t\tpr_err(\"%s() unknown irq %d\\n\", __func__, in_irq);\n\t\treturn IRQ_NONE;\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void pxa_ack_muxed_gpio(struct irq_data *d)\n{\n\tstruct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);\n\tunsigned int gpio = irqd_to_hwirq(d);\n\tvoid __iomem *base = gpio_bank_base(&pchip->chip, gpio);\n\n\twritel_relaxed(GPIO_bit(gpio), base + GEDR_OFFSET);\n}\n\nstatic void pxa_mask_muxed_gpio(struct irq_data *d)\n{\n\tstruct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);\n\tunsigned int gpio = irqd_to_hwirq(d);\n\tstruct pxa_gpio_bank *b = gpio_to_pxabank(&pchip->chip, gpio);\n\tvoid __iomem *base = gpio_bank_base(&pchip->chip, gpio);\n\tuint32_t grer, gfer;\n\n\tb->irq_mask &= ~GPIO_bit(gpio);\n\n\tgrer = readl_relaxed(base + GRER_OFFSET) & ~GPIO_bit(gpio);\n\tgfer = readl_relaxed(base + GFER_OFFSET) & ~GPIO_bit(gpio);\n\twritel_relaxed(grer, base + GRER_OFFSET);\n\twritel_relaxed(gfer, base + GFER_OFFSET);\n}\n\nstatic int pxa_gpio_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);\n\tunsigned int gpio = irqd_to_hwirq(d);\n\n\tif (pchip->set_wake)\n\t\treturn pchip->set_wake(gpio, on);\n\telse\n\t\treturn 0;\n}\n\nstatic void pxa_unmask_muxed_gpio(struct irq_data *d)\n{\n\tstruct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);\n\tunsigned int gpio = irqd_to_hwirq(d);\n\tstruct pxa_gpio_bank *c = gpio_to_pxabank(&pchip->chip, gpio);\n\n\tc->irq_mask |= GPIO_bit(gpio);\n\tupdate_edge_detect(c);\n}\n\nstatic struct irq_chip pxa_muxed_gpio_chip = {\n\t.name\t\t= \"GPIO\",\n\t.irq_ack\t= pxa_ack_muxed_gpio,\n\t.irq_mask\t= pxa_mask_muxed_gpio,\n\t.irq_unmask\t= pxa_unmask_muxed_gpio,\n\t.irq_set_type\t= pxa_gpio_irq_type,\n\t.irq_set_wake\t= pxa_gpio_set_wake,\n};\n\nstatic int pxa_gpio_nums(struct platform_device *pdev)\n{\n\tconst struct platform_device_id *id = platform_get_device_id(pdev);\n\tstruct pxa_gpio_id *pxa_id = (struct pxa_gpio_id *)id->driver_data;\n\tint count = 0;\n\n\tswitch (pxa_id->type) {\n\tcase PXA25X_GPIO:\n\tcase PXA26X_GPIO:\n\tcase PXA27X_GPIO:\n\tcase PXA3XX_GPIO:\n\tcase PXA93X_GPIO:\n\tcase MMP_GPIO:\n\tcase MMP2_GPIO:\n\tcase PXA1928_GPIO:\n\t\tgpio_type = pxa_id->type;\n\t\tcount = pxa_id->gpio_nums - 1;\n\t\tbreak;\n\tdefault:\n\t\tcount = -EINVAL;\n\t\tbreak;\n\t}\n\treturn count;\n}\n\nstatic int pxa_irq_domain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t      irq_hw_number_t hw)\n{\n\tirq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,\n\t\t\t\t handle_edge_irq);\n\tirq_set_chip_data(irq, d->host_data);\n\tirq_set_noprobe(irq);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops pxa_irq_domain_ops = {\n\t.map\t= pxa_irq_domain_map,\n\t.xlate\t= irq_domain_xlate_twocell,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pxa_gpio_dt_ids[] = {\n\t{ .compatible = \"intel,pxa25x-gpio\",\t.data = &pxa25x_id, },\n\t{ .compatible = \"intel,pxa26x-gpio\",\t.data = &pxa26x_id, },\n\t{ .compatible = \"intel,pxa27x-gpio\",\t.data = &pxa27x_id, },\n\t{ .compatible = \"intel,pxa3xx-gpio\",\t.data = &pxa3xx_id, },\n\t{ .compatible = \"marvell,pxa93x-gpio\",\t.data = &pxa93x_id, },\n\t{ .compatible = \"marvell,mmp-gpio\",\t.data = &mmp_id, },\n\t{ .compatible = \"marvell,mmp2-gpio\",\t.data = &mmp2_id, },\n\t{ .compatible = \"marvell,pxa1928-gpio\",\t.data = &pxa1928_id, },\n\t{}\n};\n\nstatic int pxa_gpio_probe_dt(struct platform_device *pdev,\n\t\t\t     struct pxa_gpio_chip *pchip)\n{\n\tint nr_gpios;\n\tconst struct pxa_gpio_id *gpio_id;\n\n\tgpio_id = of_device_get_match_data(&pdev->dev);\n\tgpio_type = gpio_id->type;\n\n\tnr_gpios = gpio_id->gpio_nums;\n\tpxa_last_gpio = nr_gpios - 1;\n\n\tirq_base = devm_irq_alloc_descs(&pdev->dev, -1, 0, nr_gpios, 0);\n\tif (irq_base < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate IRQ numbers\\n\");\n\t\treturn irq_base;\n\t}\n\treturn irq_base;\n}\n#else\n#define pxa_gpio_probe_dt(pdev, pchip)\t\t(-1)\n#endif\n\nstatic int pxa_gpio_probe(struct platform_device *pdev)\n{\n\tstruct pxa_gpio_chip *pchip;\n\tstruct pxa_gpio_bank *c;\n\tstruct clk *clk;\n\tstruct pxa_gpio_platform_data *info;\n\tvoid __iomem *gpio_reg_base;\n\tint gpio, ret;\n\tint irq0 = 0, irq1 = 0, irq_mux;\n\n\tpchip = devm_kzalloc(&pdev->dev, sizeof(*pchip), GFP_KERNEL);\n\tif (!pchip)\n\t\treturn -ENOMEM;\n\tpchip->dev = &pdev->dev;\n\n\tinfo = dev_get_platdata(&pdev->dev);\n\tif (info) {\n\t\tirq_base = info->irq_base;\n\t\tif (irq_base <= 0)\n\t\t\treturn -EINVAL;\n\t\tpxa_last_gpio = pxa_gpio_nums(pdev);\n\t\tpchip->set_wake = info->gpio_set_wake;\n\t} else {\n\t\tirq_base = pxa_gpio_probe_dt(pdev, pchip);\n\t\tif (irq_base < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!pxa_last_gpio)\n\t\treturn -EINVAL;\n\n\tpchip->irqdomain = irq_domain_add_legacy(pdev->dev.of_node,\n\t\t\t\t\t\t pxa_last_gpio + 1, irq_base,\n\t\t\t\t\t\t 0, &pxa_irq_domain_ops, pchip);\n\tif (!pchip->irqdomain)\n\t\treturn -ENOMEM;\n\n\tirq0 = platform_get_irq_byname_optional(pdev, \"gpio0\");\n\tirq1 = platform_get_irq_byname_optional(pdev, \"gpio1\");\n\tirq_mux = platform_get_irq_byname(pdev, \"gpio_mux\");\n\tif ((irq0 > 0 && irq1 <= 0) || (irq0 <= 0 && irq1 > 0)\n\t\t|| (irq_mux <= 0))\n\t\treturn -EINVAL;\n\n\tpchip->irq0 = irq0;\n\tpchip->irq1 = irq1;\n\n\tgpio_reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gpio_reg_base))\n\t\treturn PTR_ERR(gpio_reg_base);\n\n\tclk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"Error %ld to get gpio clock\\n\",\n\t\t\tPTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\n\t \n\tret = pxa_init_gpio_chip(pchip, pxa_last_gpio + 1, gpio_reg_base);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor_each_gpio_bank(gpio, c, pchip) {\n\t\twritel_relaxed(0, c->regbase + GFER_OFFSET);\n\t\twritel_relaxed(0, c->regbase + GRER_OFFSET);\n\t\twritel_relaxed(~0, c->regbase + GEDR_OFFSET);\n\t\t \n\t\tif (gpio_is_mmp_type(gpio_type))\n\t\t\twritel_relaxed(~0, c->regbase + ED_MASK_OFFSET);\n\t}\n\n\tif (irq0 > 0) {\n\t\tret = devm_request_irq(&pdev->dev,\n\t\t\t\t       irq0, pxa_gpio_direct_handler, 0,\n\t\t\t\t       \"gpio-0\", pchip);\n\t\tif (ret)\n\t\t\tdev_err(&pdev->dev, \"request of gpio0 irq failed: %d\\n\",\n\t\t\t\tret);\n\t}\n\tif (irq1 > 0) {\n\t\tret = devm_request_irq(&pdev->dev,\n\t\t\t\t       irq1, pxa_gpio_direct_handler, 0,\n\t\t\t\t       \"gpio-1\", pchip);\n\t\tif (ret)\n\t\t\tdev_err(&pdev->dev, \"request of gpio1 irq failed: %d\\n\",\n\t\t\t\tret);\n\t}\n\tret = devm_request_irq(&pdev->dev,\n\t\t\t       irq_mux, pxa_gpio_demux_handler, 0,\n\t\t\t\t       \"gpio-mux\", pchip);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"request of gpio-mux irq failed: %d\\n\",\n\t\t\t\tret);\n\n\tpxa_gpio_chip = pchip;\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id gpio_id_table[] = {\n\t{ \"pxa25x-gpio\",\t(unsigned long)&pxa25x_id },\n\t{ \"pxa26x-gpio\",\t(unsigned long)&pxa26x_id },\n\t{ \"pxa27x-gpio\",\t(unsigned long)&pxa27x_id },\n\t{ \"pxa3xx-gpio\",\t(unsigned long)&pxa3xx_id },\n\t{ \"pxa93x-gpio\",\t(unsigned long)&pxa93x_id },\n\t{ \"mmp-gpio\",\t\t(unsigned long)&mmp_id },\n\t{ \"mmp2-gpio\",\t\t(unsigned long)&mmp2_id },\n\t{ \"pxa1928-gpio\",\t(unsigned long)&pxa1928_id },\n\t{ },\n};\n\nstatic struct platform_driver pxa_gpio_driver = {\n\t.probe\t\t= pxa_gpio_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"pxa-gpio\",\n\t\t.of_match_table = of_match_ptr(pxa_gpio_dt_ids),\n\t},\n\t.id_table\t= gpio_id_table,\n};\n\nstatic int __init pxa_gpio_legacy_init(void)\n{\n\tif (of_have_populated_dt())\n\t\treturn 0;\n\n\treturn platform_driver_register(&pxa_gpio_driver);\n}\npostcore_initcall(pxa_gpio_legacy_init);\n\nstatic int __init pxa_gpio_dt_init(void)\n{\n\tif (of_have_populated_dt())\n\t\treturn platform_driver_register(&pxa_gpio_driver);\n\n\treturn 0;\n}\ndevice_initcall(pxa_gpio_dt_init);\n\n#ifdef CONFIG_PM\nstatic int pxa_gpio_suspend(void)\n{\n\tstruct pxa_gpio_chip *pchip = pxa_gpio_chip;\n\tstruct pxa_gpio_bank *c;\n\tint gpio;\n\n\tif (!pchip)\n\t\treturn 0;\n\n\tfor_each_gpio_bank(gpio, c, pchip) {\n\t\tc->saved_gplr = readl_relaxed(c->regbase + GPLR_OFFSET);\n\t\tc->saved_gpdr = readl_relaxed(c->regbase + GPDR_OFFSET);\n\t\tc->saved_grer = readl_relaxed(c->regbase + GRER_OFFSET);\n\t\tc->saved_gfer = readl_relaxed(c->regbase + GFER_OFFSET);\n\n\t\t \n\t\twritel_relaxed(0xffffffff, c->regbase + GEDR_OFFSET);\n\t}\n\treturn 0;\n}\n\nstatic void pxa_gpio_resume(void)\n{\n\tstruct pxa_gpio_chip *pchip = pxa_gpio_chip;\n\tstruct pxa_gpio_bank *c;\n\tint gpio;\n\n\tif (!pchip)\n\t\treturn;\n\n\tfor_each_gpio_bank(gpio, c, pchip) {\n\t\t \n\t\twritel_relaxed(c->saved_gplr, c->regbase + GPSR_OFFSET);\n\t\twritel_relaxed(~c->saved_gplr, c->regbase + GPCR_OFFSET);\n\n\t\twritel_relaxed(c->saved_grer, c->regbase + GRER_OFFSET);\n\t\twritel_relaxed(c->saved_gfer, c->regbase + GFER_OFFSET);\n\t\twritel_relaxed(c->saved_gpdr, c->regbase + GPDR_OFFSET);\n\t}\n}\n#else\n#define pxa_gpio_suspend\tNULL\n#define pxa_gpio_resume\t\tNULL\n#endif\n\nstatic struct syscore_ops pxa_gpio_syscore_ops = {\n\t.suspend\t= pxa_gpio_suspend,\n\t.resume\t\t= pxa_gpio_resume,\n};\n\nstatic int __init pxa_gpio_sysinit(void)\n{\n\tregister_syscore_ops(&pxa_gpio_syscore_ops);\n\treturn 0;\n}\npostcore_initcall(pxa_gpio_sysinit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}