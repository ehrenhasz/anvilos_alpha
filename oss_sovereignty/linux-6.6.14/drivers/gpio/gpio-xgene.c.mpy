{
  "module_name": "gpio-xgene.c",
  "hash_id": "7a14db46a9abce6f04435e86a3fe9c4d95899d7c3ade1e256de9589f5c3d71d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-xgene.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/driver.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n\n#define GPIO_SET_DR_OFFSET\t0x0C\n#define GPIO_DATA_OFFSET\t0x14\n#define GPIO_BANK_STRIDE\t0x0C\n\n#define XGENE_GPIOS_PER_BANK\t16\n#define XGENE_MAX_GPIO_BANKS\t3\n#define XGENE_MAX_GPIOS\t\t(XGENE_GPIOS_PER_BANK * XGENE_MAX_GPIO_BANKS)\n\n#define GPIO_BIT_OFFSET(x)\t(x % XGENE_GPIOS_PER_BANK)\n#define GPIO_BANK_OFFSET(x)\t((x / XGENE_GPIOS_PER_BANK) * GPIO_BANK_STRIDE)\n\nstruct xgene_gpio {\n\tstruct gpio_chip\tchip;\n\tvoid __iomem\t\t*base;\n\tspinlock_t\t\tlock;\n\tu32\t\t\tset_dr_val[XGENE_MAX_GPIO_BANKS];\n};\n\nstatic int xgene_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct xgene_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long bank_offset;\n\tu32 bit_offset;\n\n\tbank_offset = GPIO_DATA_OFFSET + GPIO_BANK_OFFSET(offset);\n\tbit_offset = GPIO_BIT_OFFSET(offset);\n\treturn !!(ioread32(chip->base + bank_offset) & BIT(bit_offset));\n}\n\nstatic void __xgene_gpio_set(struct gpio_chip *gc, unsigned int offset, int val)\n{\n\tstruct xgene_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long bank_offset;\n\tu32 setval, bit_offset;\n\n\tbank_offset = GPIO_SET_DR_OFFSET + GPIO_BANK_OFFSET(offset);\n\tbit_offset = GPIO_BIT_OFFSET(offset) + XGENE_GPIOS_PER_BANK;\n\n\tsetval = ioread32(chip->base + bank_offset);\n\tif (val)\n\t\tsetval |= BIT(bit_offset);\n\telse\n\t\tsetval &= ~BIT(bit_offset);\n\tiowrite32(setval, chip->base + bank_offset);\n}\n\nstatic void xgene_gpio_set(struct gpio_chip *gc, unsigned int offset, int val)\n{\n\tstruct xgene_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\t__xgene_gpio_set(gc, offset, val);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n\nstatic int xgene_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct xgene_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long bank_offset, bit_offset;\n\n\tbank_offset = GPIO_SET_DR_OFFSET + GPIO_BANK_OFFSET(offset);\n\tbit_offset = GPIO_BIT_OFFSET(offset);\n\n\tif (ioread32(chip->base + bank_offset) & BIT(bit_offset))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int xgene_gpio_dir_in(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct xgene_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags, bank_offset;\n\tu32 dirval, bit_offset;\n\n\tbank_offset = GPIO_SET_DR_OFFSET + GPIO_BANK_OFFSET(offset);\n\tbit_offset = GPIO_BIT_OFFSET(offset);\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tdirval = ioread32(chip->base + bank_offset);\n\tdirval |= BIT(bit_offset);\n\tiowrite32(dirval, chip->base + bank_offset);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic int xgene_gpio_dir_out(struct gpio_chip *gc,\n\t\t\t\t\tunsigned int offset, int val)\n{\n\tstruct xgene_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags, bank_offset;\n\tu32 dirval, bit_offset;\n\n\tbank_offset = GPIO_SET_DR_OFFSET + GPIO_BANK_OFFSET(offset);\n\tbit_offset = GPIO_BIT_OFFSET(offset);\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tdirval = ioread32(chip->base + bank_offset);\n\tdirval &= ~BIT(bit_offset);\n\tiowrite32(dirval, chip->base + bank_offset);\n\t__xgene_gpio_set(gc, offset, val);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int xgene_gpio_suspend(struct device *dev)\n{\n\tstruct xgene_gpio *gpio = dev_get_drvdata(dev);\n\tunsigned long bank_offset;\n\tunsigned int bank;\n\n\tfor (bank = 0; bank < XGENE_MAX_GPIO_BANKS; bank++) {\n\t\tbank_offset = GPIO_SET_DR_OFFSET + bank * GPIO_BANK_STRIDE;\n\t\tgpio->set_dr_val[bank] = ioread32(gpio->base + bank_offset);\n\t}\n\treturn 0;\n}\n\nstatic __maybe_unused int xgene_gpio_resume(struct device *dev)\n{\n\tstruct xgene_gpio *gpio = dev_get_drvdata(dev);\n\tunsigned long bank_offset;\n\tunsigned int bank;\n\n\tfor (bank = 0; bank < XGENE_MAX_GPIO_BANKS; bank++) {\n\t\tbank_offset = GPIO_SET_DR_OFFSET + bank * GPIO_BANK_STRIDE;\n\t\tiowrite32(gpio->set_dr_val[bank], gpio->base + bank_offset);\n\t}\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(xgene_gpio_pm, xgene_gpio_suspend, xgene_gpio_resume);\n\nstatic int xgene_gpio_probe(struct platform_device *pdev)\n{\n\tstruct xgene_gpio *gpio;\n\n\tgpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tgpio->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gpio->base))\n\t\treturn PTR_ERR(gpio->base);\n\n\tgpio->chip.ngpio = XGENE_MAX_GPIOS;\n\n\tspin_lock_init(&gpio->lock);\n\tgpio->chip.parent = &pdev->dev;\n\tgpio->chip.get_direction = xgene_gpio_get_direction;\n\tgpio->chip.direction_input = xgene_gpio_dir_in;\n\tgpio->chip.direction_output = xgene_gpio_dir_out;\n\tgpio->chip.get = xgene_gpio_get;\n\tgpio->chip.set = xgene_gpio_set;\n\tgpio->chip.label = dev_name(&pdev->dev);\n\tgpio->chip.base = -1;\n\n\tplatform_set_drvdata(pdev, gpio);\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &gpio->chip, gpio);\n}\n\nstatic const struct of_device_id xgene_gpio_of_match[] = {\n\t{ .compatible = \"apm,xgene-gpio\", },\n\t{},\n};\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id xgene_gpio_acpi_match[] = {\n\t{ \"APMC0D14\", 0 },\n\t{ },\n};\n#endif\n\nstatic struct platform_driver xgene_gpio_driver = {\n\t.driver = {\n\t\t.name = \"xgene-gpio\",\n\t\t.of_match_table = xgene_gpio_of_match,\n\t\t.acpi_match_table = ACPI_PTR(xgene_gpio_acpi_match),\n\t\t.pm     = &xgene_gpio_pm,\n\t},\n\t.probe = xgene_gpio_probe,\n};\nbuiltin_platform_driver(xgene_gpio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}