{
  "module_name": "gpio-viperboard.c",
  "hash_id": "adeb5d38f6d3d0b63de96991d7a4ae876cc47a64eea61e9382ed06affe00223e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-viperboard.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/usb.h>\n#include <linux/gpio/driver.h>\n\n#include <linux/mfd/viperboard.h>\n\n#define VPRBRD_GPIOA_CLK_1MHZ\t\t0\n#define VPRBRD_GPIOA_CLK_100KHZ\t\t1\n#define VPRBRD_GPIOA_CLK_10KHZ\t\t2\n#define VPRBRD_GPIOA_CLK_1KHZ\t\t3\n#define VPRBRD_GPIOA_CLK_100HZ\t\t4\n#define VPRBRD_GPIOA_CLK_10HZ\t\t5\n\n#define VPRBRD_GPIOA_FREQ_DEFAULT\t1000\n\n#define VPRBRD_GPIOA_CMD_CONT\t\t0x00\n#define VPRBRD_GPIOA_CMD_PULSE\t\t0x01\n#define VPRBRD_GPIOA_CMD_PWM\t\t0x02\n#define VPRBRD_GPIOA_CMD_SETOUT\t\t0x03\n#define VPRBRD_GPIOA_CMD_SETIN\t\t0x04\n#define VPRBRD_GPIOA_CMD_SETINT\t\t0x05\n#define VPRBRD_GPIOA_CMD_GETIN\t\t0x06\n\n#define VPRBRD_GPIOB_CMD_SETDIR\t\t0x00\n#define VPRBRD_GPIOB_CMD_SETVAL\t\t0x01\n\nstruct vprbrd_gpioa_msg {\n\tu8 cmd;\n\tu8 clk;\n\tu8 offset;\n\tu8 t1;\n\tu8 t2;\n\tu8 invert;\n\tu8 pwmlevel;\n\tu8 outval;\n\tu8 risefall;\n\tu8 answer;\n\tu8 __fill;\n} __packed;\n\nstruct vprbrd_gpiob_msg {\n\tu8 cmd;\n\tu16 val;\n\tu16 mask;\n} __packed;\n\nstruct vprbrd_gpio {\n\tstruct gpio_chip gpioa;  \n\tu32 gpioa_out;\n\tu32 gpioa_val;\n\tstruct gpio_chip gpiob;  \n\tu32 gpiob_out;\n\tu32 gpiob_val;\n\tstruct vprbrd *vb;\n};\n\n \nstatic unsigned char gpioa_clk;\nstatic unsigned int gpioa_freq = VPRBRD_GPIOA_FREQ_DEFAULT;\nmodule_param(gpioa_freq, uint, 0);\nMODULE_PARM_DESC(gpioa_freq,\n\t\"gpio-a sampling freq in Hz (default is 1000Hz) valid values: 10, 100, 1000, 10000, 100000, 1000000\");\n\n \n\nstatic int vprbrd_gpioa_get(struct gpio_chip *chip,\n\t\tunsigned int offset)\n{\n\tint ret, answer, error = 0;\n\tstruct vprbrd_gpio *gpio = gpiochip_get_data(chip);\n\tstruct vprbrd *vb = gpio->vb;\n\tstruct vprbrd_gpioa_msg *gamsg = (struct vprbrd_gpioa_msg *)vb->buf;\n\n\t \n\tif (gpio->gpioa_out & (1 << offset))\n\t\treturn !!(gpio->gpioa_val & (1 << offset));\n\n\tmutex_lock(&vb->lock);\n\n\tgamsg->cmd = VPRBRD_GPIOA_CMD_GETIN;\n\tgamsg->clk = 0x00;\n\tgamsg->offset = offset;\n\tgamsg->t1 = 0x00;\n\tgamsg->t2 = 0x00;\n\tgamsg->invert = 0x00;\n\tgamsg->pwmlevel = 0x00;\n\tgamsg->outval = 0x00;\n\tgamsg->risefall = 0x00;\n\tgamsg->answer = 0x00;\n\tgamsg->__fill = 0x00;\n\n\tret = usb_control_msg(vb->usb_dev, usb_sndctrlpipe(vb->usb_dev, 0),\n\t\tVPRBRD_USB_REQUEST_GPIOA, VPRBRD_USB_TYPE_OUT, 0x0000,\n\t\t0x0000, gamsg, sizeof(struct vprbrd_gpioa_msg),\n\t\tVPRBRD_USB_TIMEOUT_MS);\n\tif (ret != sizeof(struct vprbrd_gpioa_msg))\n\t\terror = -EREMOTEIO;\n\n\tret = usb_control_msg(vb->usb_dev, usb_rcvctrlpipe(vb->usb_dev, 0),\n\t\tVPRBRD_USB_REQUEST_GPIOA, VPRBRD_USB_TYPE_IN, 0x0000,\n\t\t0x0000, gamsg, sizeof(struct vprbrd_gpioa_msg),\n\t\tVPRBRD_USB_TIMEOUT_MS);\n\tanswer = gamsg->answer & 0x01;\n\n\tmutex_unlock(&vb->lock);\n\n\tif (ret != sizeof(struct vprbrd_gpioa_msg))\n\t\terror = -EREMOTEIO;\n\n\tif (error)\n\t\treturn error;\n\n\treturn answer;\n}\n\nstatic void vprbrd_gpioa_set(struct gpio_chip *chip,\n\t\tunsigned int offset, int value)\n{\n\tint ret;\n\tstruct vprbrd_gpio *gpio = gpiochip_get_data(chip);\n\tstruct vprbrd *vb = gpio->vb;\n\tstruct vprbrd_gpioa_msg *gamsg = (struct vprbrd_gpioa_msg *)vb->buf;\n\n\tif (gpio->gpioa_out & (1 << offset)) {\n\t\tif (value)\n\t\t\tgpio->gpioa_val |= (1 << offset);\n\t\telse\n\t\t\tgpio->gpioa_val &= ~(1 << offset);\n\n\t\tmutex_lock(&vb->lock);\n\n\t\tgamsg->cmd = VPRBRD_GPIOA_CMD_SETOUT;\n\t\tgamsg->clk = 0x00;\n\t\tgamsg->offset = offset;\n\t\tgamsg->t1 = 0x00;\n\t\tgamsg->t2 = 0x00;\n\t\tgamsg->invert = 0x00;\n\t\tgamsg->pwmlevel = 0x00;\n\t\tgamsg->outval = value;\n\t\tgamsg->risefall = 0x00;\n\t\tgamsg->answer = 0x00;\n\t\tgamsg->__fill = 0x00;\n\n\t\tret = usb_control_msg(vb->usb_dev,\n\t\t\tusb_sndctrlpipe(vb->usb_dev, 0),\n\t\t\tVPRBRD_USB_REQUEST_GPIOA, VPRBRD_USB_TYPE_OUT,\n\t\t\t0x0000,\t0x0000, gamsg,\n\t\t\tsizeof(struct vprbrd_gpioa_msg), VPRBRD_USB_TIMEOUT_MS);\n\n\t\tmutex_unlock(&vb->lock);\n\n\t\tif (ret != sizeof(struct vprbrd_gpioa_msg))\n\t\t\tdev_err(chip->parent, \"usb error setting pin value\\n\");\n\t}\n}\n\nstatic int vprbrd_gpioa_direction_input(struct gpio_chip *chip,\n\t\t\tunsigned int offset)\n{\n\tint ret;\n\tstruct vprbrd_gpio *gpio = gpiochip_get_data(chip);\n\tstruct vprbrd *vb = gpio->vb;\n\tstruct vprbrd_gpioa_msg *gamsg = (struct vprbrd_gpioa_msg *)vb->buf;\n\n\tgpio->gpioa_out &= ~(1 << offset);\n\n\tmutex_lock(&vb->lock);\n\n\tgamsg->cmd = VPRBRD_GPIOA_CMD_SETIN;\n\tgamsg->clk = gpioa_clk;\n\tgamsg->offset = offset;\n\tgamsg->t1 = 0x00;\n\tgamsg->t2 = 0x00;\n\tgamsg->invert = 0x00;\n\tgamsg->pwmlevel = 0x00;\n\tgamsg->outval = 0x00;\n\tgamsg->risefall = 0x00;\n\tgamsg->answer = 0x00;\n\tgamsg->__fill = 0x00;\n\n\tret = usb_control_msg(vb->usb_dev, usb_sndctrlpipe(vb->usb_dev, 0),\n\t\tVPRBRD_USB_REQUEST_GPIOA, VPRBRD_USB_TYPE_OUT, 0x0000,\n\t\t0x0000, gamsg, sizeof(struct vprbrd_gpioa_msg),\n\t\tVPRBRD_USB_TIMEOUT_MS);\n\n\tmutex_unlock(&vb->lock);\n\n\tif (ret != sizeof(struct vprbrd_gpioa_msg))\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic int vprbrd_gpioa_direction_output(struct gpio_chip *chip,\n\t\t\tunsigned int offset, int value)\n{\n\tint ret;\n\tstruct vprbrd_gpio *gpio = gpiochip_get_data(chip);\n\tstruct vprbrd *vb = gpio->vb;\n\tstruct vprbrd_gpioa_msg *gamsg = (struct vprbrd_gpioa_msg *)vb->buf;\n\n\tgpio->gpioa_out |= (1 << offset);\n\tif (value)\n\t\tgpio->gpioa_val |= (1 << offset);\n\telse\n\t\tgpio->gpioa_val &= ~(1 << offset);\n\n\tmutex_lock(&vb->lock);\n\n\tgamsg->cmd = VPRBRD_GPIOA_CMD_SETOUT;\n\tgamsg->clk = 0x00;\n\tgamsg->offset = offset;\n\tgamsg->t1 = 0x00;\n\tgamsg->t2 = 0x00;\n\tgamsg->invert = 0x00;\n\tgamsg->pwmlevel = 0x00;\n\tgamsg->outval = value;\n\tgamsg->risefall = 0x00;\n\tgamsg->answer = 0x00;\n\tgamsg->__fill = 0x00;\n\n\tret = usb_control_msg(vb->usb_dev, usb_sndctrlpipe(vb->usb_dev, 0),\n\t\tVPRBRD_USB_REQUEST_GPIOA, VPRBRD_USB_TYPE_OUT, 0x0000,\n\t\t0x0000, gamsg, sizeof(struct vprbrd_gpioa_msg),\n\t\tVPRBRD_USB_TIMEOUT_MS);\n\n\tmutex_unlock(&vb->lock);\n\n\tif (ret != sizeof(struct vprbrd_gpioa_msg))\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\n \n\n \n\nstatic int vprbrd_gpiob_setdir(struct vprbrd *vb, unsigned int offset,\n\tunsigned int dir)\n{\n\tstruct vprbrd_gpiob_msg *gbmsg = (struct vprbrd_gpiob_msg *)vb->buf;\n\tint ret;\n\n\tgbmsg->cmd = VPRBRD_GPIOB_CMD_SETDIR;\n\tgbmsg->val = cpu_to_be16(dir << offset);\n\tgbmsg->mask = cpu_to_be16(0x0001 << offset);\n\n\tret = usb_control_msg(vb->usb_dev, usb_sndctrlpipe(vb->usb_dev, 0),\n\t\tVPRBRD_USB_REQUEST_GPIOB, VPRBRD_USB_TYPE_OUT, 0x0000,\n\t\t0x0000, gbmsg, sizeof(struct vprbrd_gpiob_msg),\n\t\tVPRBRD_USB_TIMEOUT_MS);\n\n\tif (ret != sizeof(struct vprbrd_gpiob_msg))\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic int vprbrd_gpiob_get(struct gpio_chip *chip,\n\t\tunsigned int offset)\n{\n\tint ret;\n\tu16 val;\n\tstruct vprbrd_gpio *gpio = gpiochip_get_data(chip);\n\tstruct vprbrd *vb = gpio->vb;\n\tstruct vprbrd_gpiob_msg *gbmsg = (struct vprbrd_gpiob_msg *)vb->buf;\n\n\t \n\tif (gpio->gpiob_out & (1 << offset))\n\t\treturn gpio->gpiob_val & (1 << offset);\n\n\tmutex_lock(&vb->lock);\n\n\tret = usb_control_msg(vb->usb_dev, usb_rcvctrlpipe(vb->usb_dev, 0),\n\t\tVPRBRD_USB_REQUEST_GPIOB, VPRBRD_USB_TYPE_IN, 0x0000,\n\t\t0x0000, gbmsg,\tsizeof(struct vprbrd_gpiob_msg),\n\t\tVPRBRD_USB_TIMEOUT_MS);\n\tval = gbmsg->val;\n\n\tmutex_unlock(&vb->lock);\n\n\tif (ret != sizeof(struct vprbrd_gpiob_msg))\n\t\treturn ret;\n\n\t \n\tgpio->gpiob_val = be16_to_cpu(val);\n\n\treturn (gpio->gpiob_val >> offset) & 0x1;\n}\n\nstatic void vprbrd_gpiob_set(struct gpio_chip *chip,\n\t\tunsigned int offset, int value)\n{\n\tint ret;\n\tstruct vprbrd_gpio *gpio = gpiochip_get_data(chip);\n\tstruct vprbrd *vb = gpio->vb;\n\tstruct vprbrd_gpiob_msg *gbmsg = (struct vprbrd_gpiob_msg *)vb->buf;\n\n\tif (gpio->gpiob_out & (1 << offset)) {\n\t\tif (value)\n\t\t\tgpio->gpiob_val |= (1 << offset);\n\t\telse\n\t\t\tgpio->gpiob_val &= ~(1 << offset);\n\n\t\tmutex_lock(&vb->lock);\n\n\t\tgbmsg->cmd = VPRBRD_GPIOB_CMD_SETVAL;\n\t\tgbmsg->val = cpu_to_be16(value << offset);\n\t\tgbmsg->mask = cpu_to_be16(0x0001 << offset);\n\n\t\tret = usb_control_msg(vb->usb_dev,\n\t\t\tusb_sndctrlpipe(vb->usb_dev, 0),\n\t\t\tVPRBRD_USB_REQUEST_GPIOB, VPRBRD_USB_TYPE_OUT,\n\t\t\t0x0000,\t0x0000, gbmsg,\n\t\t\tsizeof(struct vprbrd_gpiob_msg), VPRBRD_USB_TIMEOUT_MS);\n\n\t\tmutex_unlock(&vb->lock);\n\n\t\tif (ret != sizeof(struct vprbrd_gpiob_msg))\n\t\t\tdev_err(chip->parent, \"usb error setting pin value\\n\");\n\t}\n}\n\nstatic int vprbrd_gpiob_direction_input(struct gpio_chip *chip,\n\t\t\tunsigned int offset)\n{\n\tint ret;\n\tstruct vprbrd_gpio *gpio = gpiochip_get_data(chip);\n\tstruct vprbrd *vb = gpio->vb;\n\n\tgpio->gpiob_out &= ~(1 << offset);\n\n\tmutex_lock(&vb->lock);\n\n\tret = vprbrd_gpiob_setdir(vb, offset, 0);\n\n\tmutex_unlock(&vb->lock);\n\n\tif (ret)\n\t\tdev_err(chip->parent, \"usb error setting pin to input\\n\");\n\n\treturn ret;\n}\n\nstatic int vprbrd_gpiob_direction_output(struct gpio_chip *chip,\n\t\t\tunsigned int offset, int value)\n{\n\tint ret;\n\tstruct vprbrd_gpio *gpio = gpiochip_get_data(chip);\n\tstruct vprbrd *vb = gpio->vb;\n\n\tgpio->gpiob_out |= (1 << offset);\n\n\tmutex_lock(&vb->lock);\n\n\tret = vprbrd_gpiob_setdir(vb, offset, 1);\n\tif (ret)\n\t\tdev_err(chip->parent, \"usb error setting pin to output\\n\");\n\n\tmutex_unlock(&vb->lock);\n\n\tvprbrd_gpiob_set(chip, offset, value);\n\n\treturn ret;\n}\n\n \n\nstatic int vprbrd_gpio_probe(struct platform_device *pdev)\n{\n\tstruct vprbrd *vb = dev_get_drvdata(pdev->dev.parent);\n\tstruct vprbrd_gpio *vb_gpio;\n\tint ret;\n\n\tvb_gpio = devm_kzalloc(&pdev->dev, sizeof(*vb_gpio), GFP_KERNEL);\n\tif (vb_gpio == NULL)\n\t\treturn -ENOMEM;\n\n\tvb_gpio->vb = vb;\n\t \n\tvb_gpio->gpioa.label = \"viperboard gpio a\";\n\tvb_gpio->gpioa.parent = &pdev->dev;\n\tvb_gpio->gpioa.owner = THIS_MODULE;\n\tvb_gpio->gpioa.base = -1;\n\tvb_gpio->gpioa.ngpio = 16;\n\tvb_gpio->gpioa.can_sleep = true;\n\tvb_gpio->gpioa.set = vprbrd_gpioa_set;\n\tvb_gpio->gpioa.get = vprbrd_gpioa_get;\n\tvb_gpio->gpioa.direction_input = vprbrd_gpioa_direction_input;\n\tvb_gpio->gpioa.direction_output = vprbrd_gpioa_direction_output;\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &vb_gpio->gpioa, vb_gpio);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tvb_gpio->gpiob.label = \"viperboard gpio b\";\n\tvb_gpio->gpiob.parent = &pdev->dev;\n\tvb_gpio->gpiob.owner = THIS_MODULE;\n\tvb_gpio->gpiob.base = -1;\n\tvb_gpio->gpiob.ngpio = 16;\n\tvb_gpio->gpiob.can_sleep = true;\n\tvb_gpio->gpiob.set = vprbrd_gpiob_set;\n\tvb_gpio->gpiob.get = vprbrd_gpiob_get;\n\tvb_gpio->gpiob.direction_input = vprbrd_gpiob_direction_input;\n\tvb_gpio->gpiob.direction_output = vprbrd_gpiob_direction_output;\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &vb_gpio->gpiob, vb_gpio);\n}\n\nstatic struct platform_driver vprbrd_gpio_driver = {\n\t.driver.name\t= \"viperboard-gpio\",\n\t.probe\t\t= vprbrd_gpio_probe,\n};\n\nstatic int __init vprbrd_gpio_init(void)\n{\n\tswitch (gpioa_freq) {\n\tcase 1000000:\n\t\tgpioa_clk = VPRBRD_GPIOA_CLK_1MHZ;\n\t\tbreak;\n\tcase 100000:\n\t\tgpioa_clk = VPRBRD_GPIOA_CLK_100KHZ;\n\t\tbreak;\n\tcase 10000:\n\t\tgpioa_clk = VPRBRD_GPIOA_CLK_10KHZ;\n\t\tbreak;\n\tcase 1000:\n\t\tgpioa_clk = VPRBRD_GPIOA_CLK_1KHZ;\n\t\tbreak;\n\tcase 100:\n\t\tgpioa_clk = VPRBRD_GPIOA_CLK_100HZ;\n\t\tbreak;\n\tcase 10:\n\t\tgpioa_clk = VPRBRD_GPIOA_CLK_10HZ;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"invalid gpioa_freq (%d)\\n\", gpioa_freq);\n\t\tgpioa_clk = VPRBRD_GPIOA_CLK_1KHZ;\n\t}\n\n\treturn platform_driver_register(&vprbrd_gpio_driver);\n}\nsubsys_initcall(vprbrd_gpio_init);\n\nstatic void __exit vprbrd_gpio_exit(void)\n{\n\tplatform_driver_unregister(&vprbrd_gpio_driver);\n}\nmodule_exit(vprbrd_gpio_exit);\n\nMODULE_AUTHOR(\"Lars Poeschel <poeschel@lemonage.de>\");\nMODULE_DESCRIPTION(\"GPIO driver for Nano River Techs Viperboard\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:viperboard-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}