{
  "module_name": "gpio-virtio.c",
  "hash_id": "45fd4aed2b481c1a578103b0a54c7b6fc55cac5d3c8cde859ab16551c606c4b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-virtio.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/virtio_config.h>\n#include <uapi/linux/virtio_gpio.h>\n#include <uapi/linux/virtio_ids.h>\n\nstruct virtio_gpio_line {\n\tstruct mutex lock;  \n\tstruct completion completion;\n\tstruct virtio_gpio_request req ____cacheline_aligned;\n\tstruct virtio_gpio_response res ____cacheline_aligned;\n\tunsigned int rxlen;\n};\n\nstruct vgpio_irq_line {\n\tu8 type;\n\tbool disabled;\n\tbool masked;\n\tbool queued;\n\tbool update_pending;\n\tbool queue_pending;\n\n\tstruct virtio_gpio_irq_request ireq ____cacheline_aligned;\n\tstruct virtio_gpio_irq_response ires ____cacheline_aligned;\n};\n\nstruct virtio_gpio {\n\tstruct virtio_device *vdev;\n\tstruct mutex lock;  \n\tstruct gpio_chip gc;\n\tstruct virtio_gpio_line *lines;\n\tstruct virtqueue *request_vq;\n\n\t \n\tstruct virtqueue *event_vq;\n\tstruct mutex irq_lock;  \n\traw_spinlock_t eventq_lock;  \n\tstruct vgpio_irq_line *irq_lines;\n};\n\nstatic int _virtio_gpio_req(struct virtio_gpio *vgpio, u16 type, u16 gpio,\n\t\t\t    u8 txvalue, u8 *rxvalue, void *response, u32 rxlen)\n{\n\tstruct virtio_gpio_line *line = &vgpio->lines[gpio];\n\tstruct virtio_gpio_request *req = &line->req;\n\tstruct virtio_gpio_response *res = response;\n\tstruct scatterlist *sgs[2], req_sg, res_sg;\n\tstruct device *dev = &vgpio->vdev->dev;\n\tint ret;\n\n\t \n\tmutex_lock(&line->lock);\n\n\treq->type = cpu_to_le16(type);\n\treq->gpio = cpu_to_le16(gpio);\n\treq->value = cpu_to_le32(txvalue);\n\n\tsg_init_one(&req_sg, req, sizeof(*req));\n\tsg_init_one(&res_sg, res, rxlen);\n\tsgs[0] = &req_sg;\n\tsgs[1] = &res_sg;\n\n\tline->rxlen = 0;\n\treinit_completion(&line->completion);\n\n\t \n\tmutex_lock(&vgpio->lock);\n\tret = virtqueue_add_sgs(vgpio->request_vq, sgs, 1, 1, line, GFP_KERNEL);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add request to vq\\n\");\n\t\tmutex_unlock(&vgpio->lock);\n\t\tgoto out;\n\t}\n\n\tvirtqueue_kick(vgpio->request_vq);\n\tmutex_unlock(&vgpio->lock);\n\n\twait_for_completion(&line->completion);\n\n\tif (unlikely(res->status != VIRTIO_GPIO_STATUS_OK)) {\n\t\tdev_err(dev, \"GPIO request failed: %d\\n\", gpio);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(line->rxlen != rxlen)) {\n\t\tdev_err(dev, \"GPIO operation returned incorrect len (%u : %u)\\n\",\n\t\t\trxlen, line->rxlen);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (rxvalue)\n\t\t*rxvalue = res->value;\n\nout:\n\tmutex_unlock(&line->lock);\n\treturn ret;\n}\n\nstatic int virtio_gpio_req(struct virtio_gpio *vgpio, u16 type, u16 gpio,\n\t\t\t   u8 txvalue, u8 *rxvalue)\n{\n\tstruct virtio_gpio_line *line = &vgpio->lines[gpio];\n\tstruct virtio_gpio_response *res = &line->res;\n\n\treturn _virtio_gpio_req(vgpio, type, gpio, txvalue, rxvalue, res,\n\t\t\t\tsizeof(*res));\n}\n\nstatic void virtio_gpio_free(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\n\tvirtio_gpio_req(vgpio, VIRTIO_GPIO_MSG_SET_DIRECTION, gpio,\n\t\t\tVIRTIO_GPIO_DIRECTION_NONE, NULL);\n}\n\nstatic int virtio_gpio_get_direction(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\tu8 direction;\n\tint ret;\n\n\tret = virtio_gpio_req(vgpio, VIRTIO_GPIO_MSG_GET_DIRECTION, gpio, 0,\n\t\t\t      &direction);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (direction) {\n\tcase VIRTIO_GPIO_DIRECTION_IN:\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\tcase VIRTIO_GPIO_DIRECTION_OUT:\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int virtio_gpio_direction_input(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\n\treturn virtio_gpio_req(vgpio, VIRTIO_GPIO_MSG_SET_DIRECTION, gpio,\n\t\t\t       VIRTIO_GPIO_DIRECTION_IN, NULL);\n}\n\nstatic int virtio_gpio_direction_output(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t\t\tint value)\n{\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\tint ret;\n\n\tret = virtio_gpio_req(vgpio, VIRTIO_GPIO_MSG_SET_VALUE, gpio, value, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn virtio_gpio_req(vgpio, VIRTIO_GPIO_MSG_SET_DIRECTION, gpio,\n\t\t\t       VIRTIO_GPIO_DIRECTION_OUT, NULL);\n}\n\nstatic int virtio_gpio_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\tu8 value;\n\tint ret;\n\n\tret = virtio_gpio_req(vgpio, VIRTIO_GPIO_MSG_GET_VALUE, gpio, 0, &value);\n\treturn ret ? ret : value;\n}\n\nstatic void virtio_gpio_set(struct gpio_chip *gc, unsigned int gpio, int value)\n{\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\n\tvirtio_gpio_req(vgpio, VIRTIO_GPIO_MSG_SET_VALUE, gpio, value, NULL);\n}\n\n \nstatic void virtio_gpio_irq_prepare(struct virtio_gpio *vgpio, u16 gpio)\n{\n\tstruct vgpio_irq_line *irq_line = &vgpio->irq_lines[gpio];\n\tstruct virtio_gpio_irq_request *ireq = &irq_line->ireq;\n\tstruct virtio_gpio_irq_response *ires = &irq_line->ires;\n\tstruct scatterlist *sgs[2], req_sg, res_sg;\n\tint ret;\n\n\tif (WARN_ON(irq_line->queued || irq_line->masked || irq_line->disabled))\n\t\treturn;\n\n\tireq->gpio = cpu_to_le16(gpio);\n\tsg_init_one(&req_sg, ireq, sizeof(*ireq));\n\tsg_init_one(&res_sg, ires, sizeof(*ires));\n\tsgs[0] = &req_sg;\n\tsgs[1] = &res_sg;\n\n\tret = virtqueue_add_sgs(vgpio->event_vq, sgs, 1, 1, irq_line, GFP_ATOMIC);\n\tif (ret) {\n\t\tdev_err(&vgpio->vdev->dev, \"failed to add request to eventq\\n\");\n\t\treturn;\n\t}\n\n\tirq_line->queued = true;\n\tvirtqueue_kick(vgpio->event_vq);\n}\n\nstatic void virtio_gpio_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\tstruct vgpio_irq_line *irq_line = &vgpio->irq_lines[d->hwirq];\n\n\traw_spin_lock(&vgpio->eventq_lock);\n\tirq_line->disabled = false;\n\tirq_line->masked = false;\n\tirq_line->queue_pending = true;\n\traw_spin_unlock(&vgpio->eventq_lock);\n\n\tirq_line->update_pending = true;\n}\n\nstatic void virtio_gpio_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\tstruct vgpio_irq_line *irq_line = &vgpio->irq_lines[d->hwirq];\n\n\traw_spin_lock(&vgpio->eventq_lock);\n\tirq_line->disabled = true;\n\tirq_line->masked = true;\n\tirq_line->queue_pending = false;\n\traw_spin_unlock(&vgpio->eventq_lock);\n\n\tirq_line->update_pending = true;\n}\n\nstatic void virtio_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\tstruct vgpio_irq_line *irq_line = &vgpio->irq_lines[d->hwirq];\n\n\traw_spin_lock(&vgpio->eventq_lock);\n\tirq_line->masked = true;\n\traw_spin_unlock(&vgpio->eventq_lock);\n}\n\nstatic void virtio_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\tstruct vgpio_irq_line *irq_line = &vgpio->irq_lines[d->hwirq];\n\n\traw_spin_lock(&vgpio->eventq_lock);\n\tirq_line->masked = false;\n\n\t \n\tvirtio_gpio_irq_prepare(vgpio, d->hwirq);\n\traw_spin_unlock(&vgpio->eventq_lock);\n}\n\nstatic int virtio_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\tstruct vgpio_irq_line *irq_line = &vgpio->irq_lines[d->hwirq];\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\ttype = VIRTIO_GPIO_IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\ttype = VIRTIO_GPIO_IRQ_TYPE_EDGE_FALLING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\ttype = VIRTIO_GPIO_IRQ_TYPE_EDGE_BOTH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\ttype = VIRTIO_GPIO_IRQ_TYPE_LEVEL_LOW;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\ttype = VIRTIO_GPIO_IRQ_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&vgpio->vdev->dev, \"unsupported irq type: %u\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tirq_line->type = type;\n\tirq_line->update_pending = true;\n\n\treturn 0;\n}\n\nstatic void virtio_gpio_irq_bus_lock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\n\tmutex_lock(&vgpio->irq_lock);\n}\n\nstatic void virtio_gpio_irq_bus_sync_unlock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct virtio_gpio *vgpio = gpiochip_get_data(gc);\n\tstruct vgpio_irq_line *irq_line = &vgpio->irq_lines[d->hwirq];\n\tu8 type = irq_line->disabled ? VIRTIO_GPIO_IRQ_TYPE_NONE : irq_line->type;\n\tunsigned long flags;\n\n\tif (irq_line->update_pending) {\n\t\tirq_line->update_pending = false;\n\t\tvirtio_gpio_req(vgpio, VIRTIO_GPIO_MSG_IRQ_TYPE, d->hwirq, type,\n\t\t\t\tNULL);\n\n\t\t \n\t\traw_spin_lock_irqsave(&vgpio->eventq_lock, flags);\n\t\tif (irq_line->queue_pending) {\n\t\t\tirq_line->queue_pending = false;\n\t\t\tvirtio_gpio_irq_prepare(vgpio, d->hwirq);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&vgpio->eventq_lock, flags);\n\t}\n\n\tmutex_unlock(&vgpio->irq_lock);\n}\n\nstatic struct irq_chip vgpio_irq_chip = {\n\t.name\t\t\t= \"virtio-gpio\",\n\t.irq_enable\t\t= virtio_gpio_irq_enable,\n\t.irq_disable\t\t= virtio_gpio_irq_disable,\n\t.irq_mask\t\t= virtio_gpio_irq_mask,\n\t.irq_unmask\t\t= virtio_gpio_irq_unmask,\n\t.irq_set_type\t\t= virtio_gpio_irq_set_type,\n\n\t \n\t.irq_bus_lock\t\t= virtio_gpio_irq_bus_lock,\n\t.irq_bus_sync_unlock\t= virtio_gpio_irq_bus_sync_unlock,\n};\n\nstatic bool ignore_irq(struct virtio_gpio *vgpio, int gpio,\n\t\t       struct vgpio_irq_line *irq_line)\n{\n\tbool ignore = false;\n\n\traw_spin_lock(&vgpio->eventq_lock);\n\tirq_line->queued = false;\n\n\t \n\tif (irq_line->masked || irq_line->disabled) {\n\t\tignore = true;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (irq_line->ires.status == VIRTIO_GPIO_IRQ_STATUS_INVALID) {\n\t\tvirtio_gpio_irq_prepare(vgpio, gpio);\n\t\tignore = true;\n\t\tgoto unlock;\n\t}\n\n\tif (WARN_ON(irq_line->ires.status != VIRTIO_GPIO_IRQ_STATUS_VALID))\n\t\tignore = true;\n\nunlock:\n\traw_spin_unlock(&vgpio->eventq_lock);\n\n\treturn ignore;\n}\n\nstatic void virtio_gpio_event_vq(struct virtqueue *vq)\n{\n\tstruct virtio_gpio *vgpio = vq->vdev->priv;\n\tstruct device *dev = &vgpio->vdev->dev;\n\tstruct vgpio_irq_line *irq_line;\n\tint gpio, ret;\n\tunsigned int len;\n\n\twhile (true) {\n\t\tirq_line = virtqueue_get_buf(vgpio->event_vq, &len);\n\t\tif (!irq_line)\n\t\t\tbreak;\n\n\t\tif (len != sizeof(irq_line->ires)) {\n\t\t\tdev_err(dev, \"irq with incorrect length (%u : %u)\\n\",\n\t\t\t\tlen, (unsigned int)sizeof(irq_line->ires));\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tgpio = irq_line - vgpio->irq_lines;\n\t\tWARN_ON(gpio >= vgpio->gc.ngpio);\n\n\t\tif (unlikely(ignore_irq(vgpio, gpio, irq_line)))\n\t\t\tcontinue;\n\n\t\tret = generic_handle_domain_irq(vgpio->gc.irq.domain, gpio);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"failed to handle interrupt: %d\\n\", ret);\n\t}\n}\n\nstatic void virtio_gpio_request_vq(struct virtqueue *vq)\n{\n\tstruct virtio_gpio_line *line;\n\tunsigned int len;\n\n\tdo {\n\t\tline = virtqueue_get_buf(vq, &len);\n\t\tif (!line)\n\t\t\treturn;\n\n\t\tline->rxlen = len;\n\t\tcomplete(&line->completion);\n\t} while (1);\n}\n\nstatic void virtio_gpio_free_vqs(struct virtio_device *vdev)\n{\n\tvirtio_reset_device(vdev);\n\tvdev->config->del_vqs(vdev);\n}\n\nstatic int virtio_gpio_alloc_vqs(struct virtio_gpio *vgpio,\n\t\t\t\t struct virtio_device *vdev)\n{\n\tconst char * const names[] = { \"requestq\", \"eventq\" };\n\tvq_callback_t *cbs[] = {\n\t\tvirtio_gpio_request_vq,\n\t\tvirtio_gpio_event_vq,\n\t};\n\tstruct virtqueue *vqs[2] = { NULL, NULL };\n\tint ret;\n\n\tret = virtio_find_vqs(vdev, vgpio->irq_lines ? 2 : 1, vqs, cbs, names, NULL);\n\tif (ret) {\n\t\tdev_err(&vdev->dev, \"failed to find vqs: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!vqs[0]) {\n\t\tdev_err(&vdev->dev, \"failed to find requestq vq\\n\");\n\t\tgoto out;\n\t}\n\tvgpio->request_vq = vqs[0];\n\n\tif (vgpio->irq_lines && !vqs[1]) {\n\t\tdev_err(&vdev->dev, \"failed to find eventq vq\\n\");\n\t\tgoto out;\n\t}\n\tvgpio->event_vq = vqs[1];\n\n\treturn 0;\n\nout:\n\tif (vqs[0] || vqs[1])\n\t\tvirtio_gpio_free_vqs(vdev);\n\n\treturn -ENODEV;\n}\n\nstatic const char **virtio_gpio_get_names(struct virtio_gpio *vgpio,\n\t\t\t\t\t  u32 gpio_names_size, u16 ngpio)\n{\n\tstruct virtio_gpio_response_get_names *res;\n\tstruct device *dev = &vgpio->vdev->dev;\n\tu8 *gpio_names, *str;\n\tconst char **names;\n\tint i, ret, len;\n\n\tif (!gpio_names_size)\n\t\treturn NULL;\n\n\tlen = sizeof(*res) + gpio_names_size;\n\tres = devm_kzalloc(dev, len, GFP_KERNEL);\n\tif (!res)\n\t\treturn NULL;\n\tgpio_names = res->value;\n\n\tret = _virtio_gpio_req(vgpio, VIRTIO_GPIO_MSG_GET_NAMES, 0, 0, NULL,\n\t\t\t       res, len);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get GPIO names: %d\\n\", ret);\n\t\treturn NULL;\n\t}\n\n\tnames = devm_kcalloc(dev, ngpio, sizeof(*names), GFP_KERNEL);\n\tif (!names)\n\t\treturn NULL;\n\n\t \n\tgpio_names[gpio_names_size - 1] = '\\0';\n\n\tfor (i = 0, str = gpio_names; i < ngpio; i++) {\n\t\tnames[i] = str;\n\t\tstr += strlen(str) + 1;  \n\n\t\tif (str > gpio_names + gpio_names_size) {\n\t\t\tdev_err(dev, \"gpio_names block is too short (%d)\\n\", i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn names;\n}\n\nstatic int virtio_gpio_probe(struct virtio_device *vdev)\n{\n\tstruct virtio_gpio_config config;\n\tstruct device *dev = &vdev->dev;\n\tstruct virtio_gpio *vgpio;\n\tu32 gpio_names_size;\n\tu16 ngpio;\n\tint ret, i;\n\n\tvgpio = devm_kzalloc(dev, sizeof(*vgpio), GFP_KERNEL);\n\tif (!vgpio)\n\t\treturn -ENOMEM;\n\n\t \n\tvirtio_cread_bytes(vdev, 0, &config, sizeof(config));\n\tgpio_names_size = le32_to_cpu(config.gpio_names_size);\n\tngpio = le16_to_cpu(config.ngpio);\n\tif (!ngpio) {\n\t\tdev_err(dev, \"Number of GPIOs can't be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvgpio->lines = devm_kcalloc(dev, ngpio, sizeof(*vgpio->lines), GFP_KERNEL);\n\tif (!vgpio->lines)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ngpio; i++) {\n\t\tmutex_init(&vgpio->lines[i].lock);\n\t\tinit_completion(&vgpio->lines[i].completion);\n\t}\n\n\tmutex_init(&vgpio->lock);\n\tvdev->priv = vgpio;\n\n\tvgpio->vdev\t\t\t= vdev;\n\tvgpio->gc.free\t\t\t= virtio_gpio_free;\n\tvgpio->gc.get_direction\t\t= virtio_gpio_get_direction;\n\tvgpio->gc.direction_input\t= virtio_gpio_direction_input;\n\tvgpio->gc.direction_output\t= virtio_gpio_direction_output;\n\tvgpio->gc.get\t\t\t= virtio_gpio_get;\n\tvgpio->gc.set\t\t\t= virtio_gpio_set;\n\tvgpio->gc.ngpio\t\t\t= ngpio;\n\tvgpio->gc.base\t\t\t= -1;  \n\tvgpio->gc.label\t\t\t= dev_name(dev);\n\tvgpio->gc.parent\t\t= dev;\n\tvgpio->gc.owner\t\t\t= THIS_MODULE;\n\tvgpio->gc.can_sleep\t\t= true;\n\n\t \n\tif (virtio_has_feature(vdev, VIRTIO_GPIO_F_IRQ)) {\n\t\tvgpio->irq_lines = devm_kcalloc(dev, ngpio, sizeof(*vgpio->irq_lines), GFP_KERNEL);\n\t\tif (!vgpio->irq_lines)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tvgpio->gc.irq.parent_handler\t= NULL;\n\t\tvgpio->gc.irq.num_parents\t= 0;\n\t\tvgpio->gc.irq.parents\t\t= NULL;\n\t\tvgpio->gc.irq.default_type\t= IRQ_TYPE_NONE;\n\t\tvgpio->gc.irq.handler\t\t= handle_level_irq;\n\t\tvgpio->gc.irq.chip\t\t= &vgpio_irq_chip;\n\n\t\tfor (i = 0; i < ngpio; i++) {\n\t\t\tvgpio->irq_lines[i].type = VIRTIO_GPIO_IRQ_TYPE_NONE;\n\t\t\tvgpio->irq_lines[i].disabled = true;\n\t\t\tvgpio->irq_lines[i].masked = true;\n\t\t}\n\n\t\tmutex_init(&vgpio->irq_lock);\n\t\traw_spin_lock_init(&vgpio->eventq_lock);\n\t}\n\n\tret = virtio_gpio_alloc_vqs(vgpio, vdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvirtio_device_ready(vdev);\n\n\tvgpio->gc.names = virtio_gpio_get_names(vgpio, gpio_names_size, ngpio);\n\n\tret = gpiochip_add_data(&vgpio->gc, vgpio);\n\tif (ret) {\n\t\tvirtio_gpio_free_vqs(vdev);\n\t\tdev_err(dev, \"Failed to add virtio-gpio controller\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic void virtio_gpio_remove(struct virtio_device *vdev)\n{\n\tstruct virtio_gpio *vgpio = vdev->priv;\n\n\tgpiochip_remove(&vgpio->gc);\n\tvirtio_gpio_free_vqs(vdev);\n}\n\nstatic const struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_GPIO, VIRTIO_DEV_ANY_ID },\n\t{},\n};\nMODULE_DEVICE_TABLE(virtio, id_table);\n\nstatic const unsigned int features[] = {\n\tVIRTIO_GPIO_F_IRQ,\n};\n\nstatic struct virtio_driver virtio_gpio_driver = {\n\t.feature_table\t\t= features,\n\t.feature_table_size\t= ARRAY_SIZE(features),\n\t.id_table\t\t= id_table,\n\t.probe\t\t\t= virtio_gpio_probe,\n\t.remove\t\t\t= virtio_gpio_remove,\n\t.driver\t\t\t= {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.owner\t\t= THIS_MODULE,\n\t},\n};\nmodule_virtio_driver(virtio_gpio_driver);\n\nMODULE_AUTHOR(\"Enrico Weigelt, metux IT consult <info@metux.net>\");\nMODULE_AUTHOR(\"Viresh Kumar <viresh.kumar@linaro.org>\");\nMODULE_DESCRIPTION(\"VirtIO GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}