{
  "module_name": "gpio-mpc8xxx.c",
  "hash_id": "87df3bbaf2bf2fc7c45961fd53d9de4716bc43bb276ccbbb93956b9c87eea799",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mpc8xxx.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/mod_devicetable.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/gpio/driver.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n\n#define MPC8XXX_GPIO_PINS\t32\n\n#define GPIO_DIR\t\t0x00\n#define GPIO_ODR\t\t0x04\n#define GPIO_DAT\t\t0x08\n#define GPIO_IER\t\t0x0c\n#define GPIO_IMR\t\t0x10\n#define GPIO_ICR\t\t0x14\n#define GPIO_ICR2\t\t0x18\n#define GPIO_IBE\t\t0x18\n\nstruct mpc8xxx_gpio_chip {\n\tstruct gpio_chip\tgc;\n\tvoid __iomem *regs;\n\traw_spinlock_t lock;\n\n\tint (*direction_output)(struct gpio_chip *chip,\n\t\t\t\tunsigned offset, int value);\n\n\tstruct irq_domain *irq;\n\tint irqn;\n};\n\n \nstatic inline u32 mpc_pin2mask(unsigned int offset)\n{\n\treturn BIT(31 - offset);\n}\n\n \nstatic int mpc8572_gpio_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\tu32 val;\n\tstruct mpc8xxx_gpio_chip *mpc8xxx_gc = gpiochip_get_data(gc);\n\tu32 out_mask, out_shadow;\n\n\tout_mask = gc->read_reg(mpc8xxx_gc->regs + GPIO_DIR);\n\tval = gc->read_reg(mpc8xxx_gc->regs + GPIO_DAT) & ~out_mask;\n\tout_shadow = gc->bgpio_data & out_mask;\n\n\treturn !!((val | out_shadow) & mpc_pin2mask(gpio));\n}\n\nstatic int mpc5121_gpio_dir_out(struct gpio_chip *gc,\n\t\t\t\tunsigned int gpio, int val)\n{\n\tstruct mpc8xxx_gpio_chip *mpc8xxx_gc = gpiochip_get_data(gc);\n\t \n\tif (gpio >= 28)\n\t\treturn -EINVAL;\n\n\treturn mpc8xxx_gc->direction_output(gc, gpio, val);\n}\n\nstatic int mpc5125_gpio_dir_out(struct gpio_chip *gc,\n\t\t\t\tunsigned int gpio, int val)\n{\n\tstruct mpc8xxx_gpio_chip *mpc8xxx_gc = gpiochip_get_data(gc);\n\t \n\tif (gpio <= 3)\n\t\treturn -EINVAL;\n\n\treturn mpc8xxx_gc->direction_output(gc, gpio, val);\n}\n\nstatic int mpc8xxx_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct mpc8xxx_gpio_chip *mpc8xxx_gc = gpiochip_get_data(gc);\n\n\tif (mpc8xxx_gc->irq && offset < MPC8XXX_GPIO_PINS)\n\t\treturn irq_create_mapping(mpc8xxx_gc->irq, offset);\n\telse\n\t\treturn -ENXIO;\n}\n\nstatic irqreturn_t mpc8xxx_gpio_irq_cascade(int irq, void *data)\n{\n\tstruct mpc8xxx_gpio_chip *mpc8xxx_gc = data;\n\tstruct gpio_chip *gc = &mpc8xxx_gc->gc;\n\tunsigned long mask;\n\tint i;\n\n\tmask = gc->read_reg(mpc8xxx_gc->regs + GPIO_IER)\n\t\t& gc->read_reg(mpc8xxx_gc->regs + GPIO_IMR);\n\tfor_each_set_bit(i, &mask, 32)\n\t\tgeneric_handle_domain_irq(mpc8xxx_gc->irq, 31 - i);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mpc8xxx_irq_unmask(struct irq_data *d)\n{\n\tstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_chip *gc = &mpc8xxx_gc->gc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\n\n\tgc->write_reg(mpc8xxx_gc->regs + GPIO_IMR,\n\t\tgc->read_reg(mpc8xxx_gc->regs + GPIO_IMR)\n\t\t| mpc_pin2mask(irqd_to_hwirq(d)));\n\n\traw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\n}\n\nstatic void mpc8xxx_irq_mask(struct irq_data *d)\n{\n\tstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_chip *gc = &mpc8xxx_gc->gc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\n\n\tgc->write_reg(mpc8xxx_gc->regs + GPIO_IMR,\n\t\tgc->read_reg(mpc8xxx_gc->regs + GPIO_IMR)\n\t\t& ~mpc_pin2mask(irqd_to_hwirq(d)));\n\n\traw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\n}\n\nstatic void mpc8xxx_irq_ack(struct irq_data *d)\n{\n\tstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_chip *gc = &mpc8xxx_gc->gc;\n\n\tgc->write_reg(mpc8xxx_gc->regs + GPIO_IER,\n\t\t      mpc_pin2mask(irqd_to_hwirq(d)));\n}\n\nstatic int mpc8xxx_irq_set_type(struct irq_data *d, unsigned int flow_type)\n{\n\tstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_chip *gc = &mpc8xxx_gc->gc;\n\tunsigned long flags;\n\n\tswitch (flow_type) {\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\traw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\n\t\tgc->write_reg(mpc8xxx_gc->regs + GPIO_ICR,\n\t\t\tgc->read_reg(mpc8xxx_gc->regs + GPIO_ICR)\n\t\t\t| mpc_pin2mask(irqd_to_hwirq(d)));\n\t\traw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\traw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\n\t\tgc->write_reg(mpc8xxx_gc->regs + GPIO_ICR,\n\t\t\tgc->read_reg(mpc8xxx_gc->regs + GPIO_ICR)\n\t\t\t& ~mpc_pin2mask(irqd_to_hwirq(d)));\n\t\traw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mpc512x_irq_set_type(struct irq_data *d, unsigned int flow_type)\n{\n\tstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_chip *gc = &mpc8xxx_gc->gc;\n\tunsigned long gpio = irqd_to_hwirq(d);\n\tvoid __iomem *reg;\n\tunsigned int shift;\n\tunsigned long flags;\n\n\tif (gpio < 16) {\n\t\treg = mpc8xxx_gc->regs + GPIO_ICR;\n\t\tshift = (15 - gpio) * 2;\n\t} else {\n\t\treg = mpc8xxx_gc->regs + GPIO_ICR2;\n\t\tshift = (15 - (gpio % 16)) * 2;\n\t}\n\n\tswitch (flow_type) {\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\traw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\n\t\tgc->write_reg(reg, (gc->read_reg(reg) & ~(3 << shift))\n\t\t\t| (2 << shift));\n\t\traw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\traw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\n\t\tgc->write_reg(reg, (gc->read_reg(reg) & ~(3 << shift))\n\t\t\t| (1 << shift));\n\t\traw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\traw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\n\t\tgc->write_reg(reg, (gc->read_reg(reg) & ~(3 << shift)));\n\t\traw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct irq_chip mpc8xxx_irq_chip = {\n\t.name\t\t= \"mpc8xxx-gpio\",\n\t.irq_unmask\t= mpc8xxx_irq_unmask,\n\t.irq_mask\t= mpc8xxx_irq_mask,\n\t.irq_ack\t= mpc8xxx_irq_ack,\n\t \n\t.irq_set_type\t= mpc8xxx_irq_set_type,\n};\n\nstatic int mpc8xxx_gpio_irq_map(struct irq_domain *h, unsigned int irq,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tirq_set_chip_data(irq, h->host_data);\n\tirq_set_chip_and_handler(irq, &mpc8xxx_irq_chip, handle_edge_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mpc8xxx_gpio_irq_ops = {\n\t.map\t= mpc8xxx_gpio_irq_map,\n\t.xlate\t= irq_domain_xlate_twocell,\n};\n\nstruct mpc8xxx_gpio_devtype {\n\tint (*gpio_dir_out)(struct gpio_chip *, unsigned int, int);\n\tint (*gpio_get)(struct gpio_chip *, unsigned int);\n\tint (*irq_set_type)(struct irq_data *, unsigned int);\n};\n\nstatic const struct mpc8xxx_gpio_devtype mpc512x_gpio_devtype = {\n\t.gpio_dir_out = mpc5121_gpio_dir_out,\n\t.irq_set_type = mpc512x_irq_set_type,\n};\n\nstatic const struct mpc8xxx_gpio_devtype mpc5125_gpio_devtype = {\n\t.gpio_dir_out = mpc5125_gpio_dir_out,\n\t.irq_set_type = mpc512x_irq_set_type,\n};\n\nstatic const struct mpc8xxx_gpio_devtype mpc8572_gpio_devtype = {\n\t.gpio_get = mpc8572_gpio_get,\n};\n\nstatic const struct mpc8xxx_gpio_devtype mpc8xxx_gpio_devtype_default = {\n\t.irq_set_type = mpc8xxx_irq_set_type,\n};\n\nstatic const struct of_device_id mpc8xxx_gpio_ids[] = {\n\t{ .compatible = \"fsl,mpc8349-gpio\", },\n\t{ .compatible = \"fsl,mpc8572-gpio\", .data = &mpc8572_gpio_devtype, },\n\t{ .compatible = \"fsl,mpc8610-gpio\", },\n\t{ .compatible = \"fsl,mpc5121-gpio\", .data = &mpc512x_gpio_devtype, },\n\t{ .compatible = \"fsl,mpc5125-gpio\", .data = &mpc5125_gpio_devtype, },\n\t{ .compatible = \"fsl,pq3-gpio\",     },\n\t{ .compatible = \"fsl,ls1028a-gpio\", },\n\t{ .compatible = \"fsl,ls1088a-gpio\", },\n\t{ .compatible = \"fsl,qoriq-gpio\",   },\n\t{}\n};\n\nstatic int mpc8xxx_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct mpc8xxx_gpio_chip *mpc8xxx_gc;\n\tstruct gpio_chip\t*gc;\n\tconst struct mpc8xxx_gpio_devtype *devtype = NULL;\n\tstruct fwnode_handle *fwnode;\n\tint ret;\n\n\tmpc8xxx_gc = devm_kzalloc(&pdev->dev, sizeof(*mpc8xxx_gc), GFP_KERNEL);\n\tif (!mpc8xxx_gc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, mpc8xxx_gc);\n\n\traw_spin_lock_init(&mpc8xxx_gc->lock);\n\n\tmpc8xxx_gc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mpc8xxx_gc->regs))\n\t\treturn PTR_ERR(mpc8xxx_gc->regs);\n\n\tgc = &mpc8xxx_gc->gc;\n\tgc->parent = &pdev->dev;\n\n\tif (device_property_read_bool(&pdev->dev, \"little-endian\")) {\n\t\tret = bgpio_init(gc, &pdev->dev, 4,\n\t\t\t\t mpc8xxx_gc->regs + GPIO_DAT,\n\t\t\t\t NULL, NULL,\n\t\t\t\t mpc8xxx_gc->regs + GPIO_DIR, NULL,\n\t\t\t\t BGPIOF_BIG_ENDIAN);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdev_dbg(&pdev->dev, \"GPIO registers are LITTLE endian\\n\");\n\t} else {\n\t\tret = bgpio_init(gc, &pdev->dev, 4,\n\t\t\t\t mpc8xxx_gc->regs + GPIO_DAT,\n\t\t\t\t NULL, NULL,\n\t\t\t\t mpc8xxx_gc->regs + GPIO_DIR, NULL,\n\t\t\t\t BGPIOF_BIG_ENDIAN\n\t\t\t\t | BGPIOF_BIG_ENDIAN_BYTE_ORDER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdev_dbg(&pdev->dev, \"GPIO registers are BIG endian\\n\");\n\t}\n\n\tmpc8xxx_gc->direction_output = gc->direction_output;\n\n\tdevtype = device_get_match_data(&pdev->dev);\n\tif (!devtype)\n\t\tdevtype = &mpc8xxx_gpio_devtype_default;\n\n\t \n\tif (devtype->irq_set_type)\n\t\tmpc8xxx_irq_chip.irq_set_type = devtype->irq_set_type;\n\n\tif (devtype->gpio_dir_out)\n\t\tgc->direction_output = devtype->gpio_dir_out;\n\tif (devtype->gpio_get)\n\t\tgc->get = devtype->gpio_get;\n\n\tgc->to_irq = mpc8xxx_gpio_to_irq;\n\n\t \n\tfwnode = dev_fwnode(&pdev->dev);\n\tif (of_device_is_compatible(np, \"fsl,qoriq-gpio\") ||\n\t    of_device_is_compatible(np, \"fsl,ls1028a-gpio\") ||\n\t    of_device_is_compatible(np, \"fsl,ls1088a-gpio\") ||\n\t    is_acpi_node(fwnode)) {\n\t\tgc->write_reg(mpc8xxx_gc->regs + GPIO_IBE, 0xffffffff);\n\t\t \n\t\tgc->bgpio_data = gc->read_reg(mpc8xxx_gc->regs + GPIO_DAT) &\n\t\t\tgc->read_reg(mpc8xxx_gc->regs + GPIO_DIR);\n\t}\n\n\tret = devm_gpiochip_add_data(&pdev->dev, gc, mpc8xxx_gc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"GPIO chip registration failed with status %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmpc8xxx_gc->irqn = platform_get_irq(pdev, 0);\n\tif (mpc8xxx_gc->irqn < 0)\n\t\treturn mpc8xxx_gc->irqn;\n\n\tmpc8xxx_gc->irq = irq_domain_create_linear(fwnode,\n\t\t\t\t\t\t   MPC8XXX_GPIO_PINS,\n\t\t\t\t\t\t   &mpc8xxx_gpio_irq_ops,\n\t\t\t\t\t\t   mpc8xxx_gc);\n\n\tif (!mpc8xxx_gc->irq)\n\t\treturn 0;\n\n\t \n\tgc->write_reg(mpc8xxx_gc->regs + GPIO_IER, 0xffffffff);\n\tgc->write_reg(mpc8xxx_gc->regs + GPIO_IMR, 0);\n\n\tret = devm_request_irq(&pdev->dev, mpc8xxx_gc->irqn,\n\t\t\t       mpc8xxx_gpio_irq_cascade,\n\t\t\t       IRQF_NO_THREAD | IRQF_SHARED, \"gpio-cascade\",\n\t\t\t       mpc8xxx_gc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to devm_request_irq(%d), ret = %d\\n\",\n\t\t\tmpc8xxx_gc->irqn, ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tirq_domain_remove(mpc8xxx_gc->irq);\n\treturn ret;\n}\n\nstatic int mpc8xxx_remove(struct platform_device *pdev)\n{\n\tstruct mpc8xxx_gpio_chip *mpc8xxx_gc = platform_get_drvdata(pdev);\n\n\tif (mpc8xxx_gc->irq) {\n\t\tirq_set_chained_handler_and_data(mpc8xxx_gc->irqn, NULL, NULL);\n\t\tirq_domain_remove(mpc8xxx_gc->irq);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id gpio_acpi_ids[] = {\n\t{\"NXP0031\",},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, gpio_acpi_ids);\n#endif\n\nstatic struct platform_driver mpc8xxx_plat_driver = {\n\t.probe\t\t= mpc8xxx_probe,\n\t.remove\t\t= mpc8xxx_remove,\n\t.driver\t\t= {\n\t\t.name = \"gpio-mpc8xxx\",\n\t\t.of_match_table\t= mpc8xxx_gpio_ids,\n\t\t.acpi_match_table = ACPI_PTR(gpio_acpi_ids),\n\t},\n};\n\nstatic int __init mpc8xxx_init(void)\n{\n\treturn platform_driver_register(&mpc8xxx_plat_driver);\n}\n\narch_initcall(mpc8xxx_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}