{
  "module_name": "gpio-twl4030.c",
  "hash_id": "ef17e5c4733885db14637da46edb86467d6d349de1a73621d571900cb51ec102",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-twl4030.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n#include <linux/gpio/machine.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/irqdomain.h>\n\n#include <linux/mfd/twl.h>\n\n \n\n \n#ifdef MODULE\n#define is_module()\ttrue\n#else\n#define is_module()\tfalse\n#endif\n\n \n#define MASK_GPIO_CTRL_GPIO0CD1\t\tBIT(0)\n#define MASK_GPIO_CTRL_GPIO1CD2\t\tBIT(1)\n#define MASK_GPIO_CTRL_GPIO_ON\t\tBIT(2)\n\n \n#define GPIO_32_MASK\t\t\t0x0003ffff\n\nstruct gpio_twl4030_priv {\n\tstruct gpio_chip gpio_chip;\n\tstruct mutex mutex;\n\tint irq_base;\n\n\t \n\tunsigned int usage_count;\n\tunsigned int direction;\n\tunsigned int out_state;\n};\n\n \n\n \nstatic inline int gpio_twl4030_write(u8 address, u8 data)\n{\n\treturn twl_i2c_write_u8(TWL4030_MODULE_GPIO, data, address);\n}\n\n \n\n \n\n#define TWL4030_LED_LEDEN_REG\t0x00\n#define TWL4030_PWMAON_REG\t0x01\n#define TWL4030_PWMAOFF_REG\t0x02\n#define TWL4030_PWMBON_REG\t0x03\n#define TWL4030_PWMBOFF_REG\t0x04\n\n \n#define LEDEN_LEDAON\t\tBIT(0)\n#define LEDEN_LEDBON\t\tBIT(1)\n#define LEDEN_LEDAEXT\t\tBIT(2)\n#define LEDEN_LEDBEXT\t\tBIT(3)\n#define LEDEN_LEDAPWM\t\tBIT(4)\n#define LEDEN_LEDBPWM\t\tBIT(5)\n#define LEDEN_PWM_LENGTHA\tBIT(6)\n#define LEDEN_PWM_LENGTHB\tBIT(7)\n\n#define PWMxON_LENGTH\t\tBIT(7)\n\n \n\n \nstatic inline int gpio_twl4030_read(u8 address)\n{\n\tu8 data;\n\tint ret = 0;\n\n\tret = twl_i2c_read_u8(TWL4030_MODULE_GPIO, &data, address);\n\treturn (ret < 0) ? ret : data;\n}\n\n \n\nstatic u8 cached_leden;\n\n \nstatic void twl4030_led_set_value(int led, int value)\n{\n\tu8 mask = LEDEN_LEDAON | LEDEN_LEDAPWM;\n\n\tif (led)\n\t\tmask <<= 1;\n\n\tif (value)\n\t\tcached_leden &= ~mask;\n\telse\n\t\tcached_leden |= mask;\n\n\tWARN_ON_ONCE(twl_i2c_write_u8(TWL4030_MODULE_LED, cached_leden,\n\t\t\t\t      TWL4030_LED_LEDEN_REG));\n}\n\nstatic int twl4030_set_gpio_direction(int gpio, int is_input)\n{\n\tu8 d_bnk = gpio >> 3;\n\tu8 d_msk = BIT(gpio & 0x7);\n\tu8 reg = 0;\n\tu8 base = REG_GPIODATADIR1 + d_bnk;\n\tint ret = 0;\n\n\tret = gpio_twl4030_read(base);\n\tif (ret >= 0) {\n\t\tif (is_input)\n\t\t\treg = ret & ~d_msk;\n\t\telse\n\t\t\treg = ret | d_msk;\n\n\t\tret = gpio_twl4030_write(base, reg);\n\t}\n\treturn ret;\n}\n\nstatic int twl4030_get_gpio_direction(int gpio)\n{\n\tu8 d_bnk = gpio >> 3;\n\tu8 d_msk = BIT(gpio & 0x7);\n\tu8 base = REG_GPIODATADIR1 + d_bnk;\n\tint ret = 0;\n\n\tret = gpio_twl4030_read(base);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & d_msk)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int twl4030_set_gpio_dataout(int gpio, int enable)\n{\n\tu8 d_bnk = gpio >> 3;\n\tu8 d_msk = BIT(gpio & 0x7);\n\tu8 base = 0;\n\n\tif (enable)\n\t\tbase = REG_SETGPIODATAOUT1 + d_bnk;\n\telse\n\t\tbase = REG_CLEARGPIODATAOUT1 + d_bnk;\n\n\treturn gpio_twl4030_write(base, d_msk);\n}\n\nstatic int twl4030_get_gpio_datain(int gpio)\n{\n\tu8 d_bnk = gpio >> 3;\n\tu8 d_off = gpio & 0x7;\n\tu8 base = 0;\n\tint ret = 0;\n\n\tbase = REG_GPIODATAIN1 + d_bnk;\n\tret = gpio_twl4030_read(base);\n\tif (ret > 0)\n\t\tret = (ret >> d_off) & 0x1;\n\n\treturn ret;\n}\n\n \n\nstatic int twl_request(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_twl4030_priv *priv = gpiochip_get_data(chip);\n\tint status = 0;\n\n\tmutex_lock(&priv->mutex);\n\n\t \n\tif (offset >= TWL4030_GPIO_MAX) {\n\t\tu8\tledclr_mask = LEDEN_LEDAON | LEDEN_LEDAEXT\n\t\t\t\t| LEDEN_LEDAPWM | LEDEN_PWM_LENGTHA;\n\t\tu8\treg = TWL4030_PWMAON_REG;\n\n\t\toffset -= TWL4030_GPIO_MAX;\n\t\tif (offset) {\n\t\t\tledclr_mask <<= 1;\n\t\t\treg = TWL4030_PWMBON_REG;\n\t\t}\n\n\t\t \n\t\t \n\t\tstatus = twl_i2c_write_u8(TWL4030_MODULE_LED, 0x7f, reg + 1);\n\t\tif (status < 0)\n\t\t\tgoto done;\n\n\t\t \n\t\tstatus = twl_i2c_write_u8(TWL4030_MODULE_LED, 0x7f, reg);\n\t\tif (status < 0)\n\t\t\tgoto done;\n\n\t\t \n\t\tstatus = twl_i2c_read_u8(TWL4030_MODULE_LED, &cached_leden,\n\t\t\t\t\t TWL4030_LED_LEDEN_REG);\n\t\tif (status < 0)\n\t\t\tgoto done;\n\t\tcached_leden &= ~ledclr_mask;\n\t\tstatus = twl_i2c_write_u8(TWL4030_MODULE_LED, cached_leden,\n\t\t\t\t\t  TWL4030_LED_LEDEN_REG);\n\t\tif (status < 0)\n\t\t\tgoto done;\n\n\t\tstatus = 0;\n\t\tgoto done;\n\t}\n\n\t \n\tif (!priv->usage_count) {\n\t\tstruct twl4030_gpio_platform_data *pdata;\n\t\tu8 value = MASK_GPIO_CTRL_GPIO_ON;\n\n\t\t \n\t\tpdata = dev_get_platdata(chip->parent);\n\t\tif (pdata)\n\t\t\tvalue |= pdata->mmc_cd & 0x03;\n\n\t\tstatus = gpio_twl4030_write(REG_GPIO_CTRL, value);\n\t}\n\ndone:\n\tif (!status)\n\t\tpriv->usage_count |= BIT(offset);\n\n\tmutex_unlock(&priv->mutex);\n\treturn status;\n}\n\nstatic void twl_free(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_twl4030_priv *priv = gpiochip_get_data(chip);\n\n\tmutex_lock(&priv->mutex);\n\tif (offset >= TWL4030_GPIO_MAX) {\n\t\ttwl4030_led_set_value(offset - TWL4030_GPIO_MAX, 1);\n\t\tgoto out;\n\t}\n\n\tpriv->usage_count &= ~BIT(offset);\n\n\t \n\tif (!priv->usage_count)\n\t\tgpio_twl4030_write(REG_GPIO_CTRL, 0x0);\n\nout:\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int twl_direction_in(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_twl4030_priv *priv = gpiochip_get_data(chip);\n\tint ret;\n\n\tmutex_lock(&priv->mutex);\n\tif (offset < TWL4030_GPIO_MAX)\n\t\tret = twl4030_set_gpio_direction(offset, 1);\n\telse\n\t\tret = -EINVAL;\t \n\n\tif (!ret)\n\t\tpriv->direction &= ~BIT(offset);\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic int twl_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_twl4030_priv *priv = gpiochip_get_data(chip);\n\tint ret;\n\tint status = 0;\n\n\tmutex_lock(&priv->mutex);\n\tif (!(priv->usage_count & BIT(offset))) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (priv->direction & BIT(offset))\n\t\tstatus = priv->out_state & BIT(offset);\n\telse\n\t\tstatus = twl4030_get_gpio_datain(offset);\n\n\tret = (status < 0) ? status : !!status;\nout:\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\nstatic void twl_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct gpio_twl4030_priv *priv = gpiochip_get_data(chip);\n\n\tmutex_lock(&priv->mutex);\n\tif (offset < TWL4030_GPIO_MAX)\n\t\ttwl4030_set_gpio_dataout(offset, value);\n\telse\n\t\ttwl4030_led_set_value(offset - TWL4030_GPIO_MAX, value);\n\n\tif (value)\n\t\tpriv->out_state |= BIT(offset);\n\telse\n\t\tpriv->out_state &= ~BIT(offset);\n\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int twl_direction_out(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct gpio_twl4030_priv *priv = gpiochip_get_data(chip);\n\tint ret = 0;\n\n\tmutex_lock(&priv->mutex);\n\tif (offset < TWL4030_GPIO_MAX) {\n\t\tret = twl4030_set_gpio_direction(offset, 0);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\n\tpriv->direction |= BIT(offset);\n\tmutex_unlock(&priv->mutex);\n\n\ttwl_set(chip, offset, value);\n\n\treturn ret;\n}\n\nstatic int twl_get_direction(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_twl4030_priv *priv = gpiochip_get_data(chip);\n\t \n\tint ret = GPIO_LINE_DIRECTION_OUT;\n\n\tmutex_lock(&priv->mutex);\n\tif (offset < TWL4030_GPIO_MAX) {\n\t\tret = twl4030_get_gpio_direction(offset);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic int twl_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_twl4030_priv *priv = gpiochip_get_data(chip);\n\n\treturn (priv->irq_base && (offset < TWL4030_GPIO_MAX))\n\t\t? (priv->irq_base + offset)\n\t\t: -EINVAL;\n}\n\nstatic const struct gpio_chip template_chip = {\n\t.label\t\t\t= \"twl4030\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.request\t\t= twl_request,\n\t.free\t\t\t= twl_free,\n\t.direction_input\t= twl_direction_in,\n\t.direction_output\t= twl_direction_out,\n\t.get_direction\t\t= twl_get_direction,\n\t.get\t\t\t= twl_get,\n\t.set\t\t\t= twl_set,\n\t.to_irq\t\t\t= twl_to_irq,\n\t.can_sleep\t\t= true,\n};\n\n \n\nstatic int gpio_twl4030_pulls(u32 ups, u32 downs)\n{\n\tu8\t\tmessage[5];\n\tunsigned\ti, gpio_bit;\n\n\t \n\tfor (gpio_bit = 1, i = 0; i < 5; i++) {\n\t\tu8\t\tbit_mask;\n\t\tunsigned\tj;\n\n\t\tfor (bit_mask = 0, j = 0; j < 8; j += 2, gpio_bit <<= 1) {\n\t\t\tif (ups & gpio_bit)\n\t\t\t\tbit_mask |= 1 << (j + 1);\n\t\t\telse if (downs & gpio_bit)\n\t\t\t\tbit_mask |= 1 << (j + 0);\n\t\t}\n\t\tmessage[i] = bit_mask;\n\t}\n\n\treturn twl_i2c_write(TWL4030_MODULE_GPIO, message,\n\t\t\t\tREG_GPIOPUPDCTR1, 5);\n}\n\nstatic int gpio_twl4030_debounce(u32 debounce, u8 mmc_cd)\n{\n\tu8\t\tmessage[3];\n\n\t \n\tmessage[0] = (debounce & 0xff) | (mmc_cd & 0x03);\n\tdebounce >>= 8;\n\tmessage[1] = (debounce & 0xff);\n\tdebounce >>= 8;\n\tmessage[2] = (debounce & 0x03);\n\n\treturn twl_i2c_write(TWL4030_MODULE_GPIO, message,\n\t\t\t\tREG_GPIO_DEBEN1, 3);\n}\n\nstatic struct twl4030_gpio_platform_data *of_gpio_twl4030(struct device *dev)\n{\n\tstruct twl4030_gpio_platform_data *omap_twl_info;\n\n\tomap_twl_info = devm_kzalloc(dev, sizeof(*omap_twl_info), GFP_KERNEL);\n\tif (!omap_twl_info)\n\t\treturn NULL;\n\n\tomap_twl_info->use_leds = of_property_read_bool(dev->of_node,\n\t\t\t\"ti,use-leds\");\n\n\tof_property_read_u32(dev->of_node, \"ti,debounce\",\n\t\t\t     &omap_twl_info->debounce);\n\tof_property_read_u32(dev->of_node, \"ti,mmc-cd\",\n\t\t\t     (u32 *)&omap_twl_info->mmc_cd);\n\tof_property_read_u32(dev->of_node, \"ti,pullups\",\n\t\t\t     &omap_twl_info->pullups);\n\tof_property_read_u32(dev->of_node, \"ti,pulldowns\",\n\t\t\t     &omap_twl_info->pulldowns);\n\n\treturn omap_twl_info;\n}\n\n \nstatic void gpio_twl4030_power_off_action(void *data)\n{\n\tstruct gpio_desc *d = data;\n\n\tgpiod_unexport(d);\n\tgpiochip_free_own_desc(d);\n}\n\nstatic int gpio_twl4030_probe(struct platform_device *pdev)\n{\n\tstruct twl4030_gpio_platform_data *pdata;\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct gpio_twl4030_priv *priv;\n\tint ret, irq_base;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct gpio_twl4030_priv),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tif (is_module()) {\n\t\tdev_err(&pdev->dev, \"can't dispatch IRQs from modules\\n\");\n\t\tgoto no_irqs;\n\t}\n\n\tirq_base = devm_irq_alloc_descs(&pdev->dev, -1,\n\t\t\t\t\t0, TWL4030_GPIO_MAX, 0);\n\tif (irq_base < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to alloc irq_descs\\n\");\n\t\treturn irq_base;\n\t}\n\n\tirq_domain_add_legacy(node, TWL4030_GPIO_MAX, irq_base, 0,\n\t\t\t      &irq_domain_simple_ops, NULL);\n\n\tret = twl4030_sih_setup(&pdev->dev, TWL4030_MODULE_GPIO, irq_base);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->irq_base = irq_base;\n\nno_irqs:\n\tpriv->gpio_chip = template_chip;\n\tpriv->gpio_chip.base = -1;\n\tpriv->gpio_chip.ngpio = TWL4030_GPIO_MAX;\n\tpriv->gpio_chip.parent = &pdev->dev;\n\n\tmutex_init(&priv->mutex);\n\n\tpdata = of_gpio_twl4030(&pdev->dev);\n\tif (pdata == NULL) {\n\t\tdev_err(&pdev->dev, \"Platform data is missing\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tret = gpio_twl4030_pulls(pdata->pullups, pdata->pulldowns);\n\tif (ret)\n\t\tdev_dbg(&pdev->dev, \"pullups %.05x %.05x --> %d\\n\",\n\t\t\tpdata->pullups, pdata->pulldowns, ret);\n\n\tret = gpio_twl4030_debounce(pdata->debounce, pdata->mmc_cd);\n\tif (ret)\n\t\tdev_dbg(&pdev->dev, \"debounce %.03x %.01x --> %d\\n\",\n\t\t\tpdata->debounce, pdata->mmc_cd, ret);\n\n\t \n\tif (pdata->use_leds)\n\t\tpriv->gpio_chip.ngpio += 2;\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &priv->gpio_chip, priv);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"could not register gpiochip, %d\\n\", ret);\n\t\tpriv->gpio_chip.ngpio = 0;\n\t\treturn ret;\n\t}\n\n\t \n\tif (IS_ENABLED(CONFIG_ARCH_OMAP3) &&\n\t    of_machine_is_compatible(\"compulab,omap3-sbc-t3730\")) {\n\t\tstruct gpio_desc *d;\n\n\t\td = gpiochip_request_own_desc(&priv->gpio_chip,\n\t\t\t\t\t\t 2, \"wlan pwr\",\n\t\t\t\t\t\t GPIO_ACTIVE_HIGH,\n\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(d))\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(d),\n\t\t\t\t\t     \"unable to hog wlan pwr GPIO\\n\");\n\n\t\tgpiod_export(d, 0);\n\n\t\tret = devm_add_action_or_reset(&pdev->dev, gpio_twl4030_power_off_action, d);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t\t     \"failed to install power off handler\\n\");\n\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id twl_gpio_match[] = {\n\t{ .compatible = \"ti,twl4030-gpio\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, twl_gpio_match);\n\n \nMODULE_ALIAS(\"platform:twl4030_gpio\");\n\nstatic struct platform_driver gpio_twl4030_driver = {\n\t.driver = {\n\t\t.name\t= \"twl4030_gpio\",\n\t\t.of_match_table = twl_gpio_match,\n\t},\n\t.probe\t\t= gpio_twl4030_probe,\n};\n\nstatic int __init gpio_twl4030_init(void)\n{\n\treturn platform_driver_register(&gpio_twl4030_driver);\n}\nsubsys_initcall(gpio_twl4030_init);\n\nstatic void __exit gpio_twl4030_exit(void)\n{\n\tplatform_driver_unregister(&gpio_twl4030_driver);\n}\nmodule_exit(gpio_twl4030_exit);\n\nMODULE_AUTHOR(\"Texas Instruments, Inc.\");\nMODULE_DESCRIPTION(\"GPIO interface for TWL4030\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}