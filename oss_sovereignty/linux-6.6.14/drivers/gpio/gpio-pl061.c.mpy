{
  "module_name": "gpio-pl061.c",
  "hash_id": "9ff4051e6bbf94b6bd17c67eae1063211a5c9d51f82ce89e519b2a4d12b2f052",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-pl061.c",
  "human_readable_source": "\n \n#include <linux/amba/bus.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#define GPIODIR 0x400\n#define GPIOIS  0x404\n#define GPIOIBE 0x408\n#define GPIOIEV 0x40C\n#define GPIOIE  0x410\n#define GPIORIS 0x414\n#define GPIOMIS 0x418\n#define GPIOIC  0x41C\n\n#define PL061_GPIO_NR\t8\n\n#ifdef CONFIG_PM\nstruct pl061_context_save_regs {\n\tu8 gpio_data;\n\tu8 gpio_dir;\n\tu8 gpio_is;\n\tu8 gpio_ibe;\n\tu8 gpio_iev;\n\tu8 gpio_ie;\n};\n#endif\n\nstruct pl061 {\n\traw_spinlock_t\t\tlock;\n\n\tvoid __iomem\t\t*base;\n\tstruct gpio_chip\tgc;\n\tint\t\t\tparent_irq;\n\n#ifdef CONFIG_PM\n\tstruct pl061_context_save_regs csave_regs;\n#endif\n};\n\nstatic int pl061_get_direction(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct pl061 *pl061 = gpiochip_get_data(gc);\n\n\tif (readb(pl061->base + GPIODIR) & BIT(offset))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int pl061_direction_input(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct pl061 *pl061 = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tunsigned char gpiodir;\n\n\traw_spin_lock_irqsave(&pl061->lock, flags);\n\tgpiodir = readb(pl061->base + GPIODIR);\n\tgpiodir &= ~(BIT(offset));\n\twriteb(gpiodir, pl061->base + GPIODIR);\n\traw_spin_unlock_irqrestore(&pl061->lock, flags);\n\n\treturn 0;\n}\n\nstatic int pl061_direction_output(struct gpio_chip *gc, unsigned offset,\n\t\tint value)\n{\n\tstruct pl061 *pl061 = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tunsigned char gpiodir;\n\n\traw_spin_lock_irqsave(&pl061->lock, flags);\n\twriteb(!!value << offset, pl061->base + (BIT(offset + 2)));\n\tgpiodir = readb(pl061->base + GPIODIR);\n\tgpiodir |= BIT(offset);\n\twriteb(gpiodir, pl061->base + GPIODIR);\n\n\t \n\twriteb(!!value << offset, pl061->base + (BIT(offset + 2)));\n\traw_spin_unlock_irqrestore(&pl061->lock, flags);\n\n\treturn 0;\n}\n\nstatic int pl061_get_value(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct pl061 *pl061 = gpiochip_get_data(gc);\n\n\treturn !!readb(pl061->base + (BIT(offset + 2)));\n}\n\nstatic void pl061_set_value(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tstruct pl061 *pl061 = gpiochip_get_data(gc);\n\n\twriteb(!!value << offset, pl061->base + (BIT(offset + 2)));\n}\n\nstatic int pl061_irq_type(struct irq_data *d, unsigned trigger)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct pl061 *pl061 = gpiochip_get_data(gc);\n\tint offset = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu8 gpiois, gpioibe, gpioiev;\n\tu8 bit = BIT(offset);\n\n\tif (offset < 0 || offset >= PL061_GPIO_NR)\n\t\treturn -EINVAL;\n\n\tif ((trigger & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) &&\n\t    (trigger & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)))\n\t{\n\t\tdev_err(gc->parent,\n\t\t\t\"trying to configure line %d for both level and edge \"\n\t\t\t\"detection, choose one!\\n\",\n\t\t\toffset);\n\t\treturn -EINVAL;\n\t}\n\n\n\traw_spin_lock_irqsave(&pl061->lock, flags);\n\n\tgpioiev = readb(pl061->base + GPIOIEV);\n\tgpiois = readb(pl061->base + GPIOIS);\n\tgpioibe = readb(pl061->base + GPIOIBE);\n\n\tif (trigger & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {\n\t\tbool polarity = trigger & IRQ_TYPE_LEVEL_HIGH;\n\n\t\t \n\t\tgpioibe &= ~bit;\n\t\t \n\t\tgpiois |= bit;\n\t\t \n\t\tif (polarity)\n\t\t\tgpioiev |= bit;\n\t\telse\n\t\t\tgpioiev &= ~bit;\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tdev_dbg(gc->parent, \"line %d: IRQ on %s level\\n\",\n\t\t\toffset,\n\t\t\tpolarity ? \"HIGH\" : \"LOW\");\n\t} else if ((trigger & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\n\t\t \n\t\tgpiois &= ~bit;\n\t\t \n\t\tgpioibe |= bit;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tdev_dbg(gc->parent, \"line %d: IRQ on both edges\\n\", offset);\n\t} else if ((trigger & IRQ_TYPE_EDGE_RISING) ||\n\t\t   (trigger & IRQ_TYPE_EDGE_FALLING)) {\n\t\tbool rising = trigger & IRQ_TYPE_EDGE_RISING;\n\n\t\t \n\t\tgpiois &= ~bit;\n\t\t \n\t\tgpioibe &= ~bit;\n\t\t \n\t\tif (rising)\n\t\t\tgpioiev |= bit;\n\t\telse\n\t\t\tgpioiev &= ~bit;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tdev_dbg(gc->parent, \"line %d: IRQ on %s edge\\n\",\n\t\t\toffset,\n\t\t\trising ? \"RISING\" : \"FALLING\");\n\t} else {\n\t\t \n\t\tgpiois &= ~bit;\n\t\tgpioibe &= ~bit;\n\t\tgpioiev &= ~bit;\n\t\tirq_set_handler_locked(d, handle_bad_irq);\n\t\tdev_warn(gc->parent, \"no trigger selected for line %d\\n\",\n\t\t\t offset);\n\t}\n\n\twriteb(gpiois, pl061->base + GPIOIS);\n\twriteb(gpioibe, pl061->base + GPIOIBE);\n\twriteb(gpioiev, pl061->base + GPIOIEV);\n\n\traw_spin_unlock_irqrestore(&pl061->lock, flags);\n\n\treturn 0;\n}\n\nstatic void pl061_irq_handler(struct irq_desc *desc)\n{\n\tunsigned long pending;\n\tint offset;\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct pl061 *pl061 = gpiochip_get_data(gc);\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\n\tchained_irq_enter(irqchip, desc);\n\n\tpending = readb(pl061->base + GPIOMIS);\n\tif (pending) {\n\t\tfor_each_set_bit(offset, &pending, PL061_GPIO_NR)\n\t\t\tgeneric_handle_domain_irq(gc->irq.domain,\n\t\t\t\t\t\t  offset);\n\t}\n\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic void pl061_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct pl061 *pl061 = gpiochip_get_data(gc);\n\tu8 mask = BIT(irqd_to_hwirq(d) % PL061_GPIO_NR);\n\tu8 gpioie;\n\n\traw_spin_lock(&pl061->lock);\n\tgpioie = readb(pl061->base + GPIOIE) & ~mask;\n\twriteb(gpioie, pl061->base + GPIOIE);\n\traw_spin_unlock(&pl061->lock);\n\n\tgpiochip_disable_irq(gc, d->hwirq);\n}\n\nstatic void pl061_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct pl061 *pl061 = gpiochip_get_data(gc);\n\tu8 mask = BIT(irqd_to_hwirq(d) % PL061_GPIO_NR);\n\tu8 gpioie;\n\n\tgpiochip_enable_irq(gc, d->hwirq);\n\n\traw_spin_lock(&pl061->lock);\n\tgpioie = readb(pl061->base + GPIOIE) | mask;\n\twriteb(gpioie, pl061->base + GPIOIE);\n\traw_spin_unlock(&pl061->lock);\n}\n\n \nstatic void pl061_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct pl061 *pl061 = gpiochip_get_data(gc);\n\tu8 mask = BIT(irqd_to_hwirq(d) % PL061_GPIO_NR);\n\n\traw_spin_lock(&pl061->lock);\n\twriteb(mask, pl061->base + GPIOIC);\n\traw_spin_unlock(&pl061->lock);\n}\n\nstatic int pl061_irq_set_wake(struct irq_data *d, unsigned int state)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct pl061 *pl061 = gpiochip_get_data(gc);\n\n\treturn irq_set_irq_wake(pl061->parent_irq, state);\n}\n\nstatic void pl061_irq_print_chip(struct irq_data *data, struct seq_file *p)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\n\tseq_printf(p, dev_name(gc->parent));\n}\n\nstatic const struct irq_chip pl061_irq_chip = {\n\t.irq_ack\t\t= pl061_irq_ack,\n\t.irq_mask\t\t= pl061_irq_mask,\n\t.irq_unmask\t\t= pl061_irq_unmask,\n\t.irq_set_type\t\t= pl061_irq_type,\n\t.irq_set_wake\t\t= pl061_irq_set_wake,\n\t.irq_print_chip\t\t= pl061_irq_print_chip,\n\t.flags\t\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int pl061_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tstruct device *dev = &adev->dev;\n\tstruct pl061 *pl061;\n\tstruct gpio_irq_chip *girq;\n\tint ret, irq;\n\n\tpl061 = devm_kzalloc(dev, sizeof(*pl061), GFP_KERNEL);\n\tif (pl061 == NULL)\n\t\treturn -ENOMEM;\n\n\tpl061->base = devm_ioremap_resource(dev, &adev->res);\n\tif (IS_ERR(pl061->base))\n\t\treturn PTR_ERR(pl061->base);\n\n\traw_spin_lock_init(&pl061->lock);\n\tpl061->gc.request = gpiochip_generic_request;\n\tpl061->gc.free = gpiochip_generic_free;\n\tpl061->gc.base = -1;\n\tpl061->gc.get_direction = pl061_get_direction;\n\tpl061->gc.direction_input = pl061_direction_input;\n\tpl061->gc.direction_output = pl061_direction_output;\n\tpl061->gc.get = pl061_get_value;\n\tpl061->gc.set = pl061_set_value;\n\tpl061->gc.ngpio = PL061_GPIO_NR;\n\tpl061->gc.label = dev_name(dev);\n\tpl061->gc.parent = dev;\n\tpl061->gc.owner = THIS_MODULE;\n\n\t \n\twriteb(0, pl061->base + GPIOIE);  \n\tirq = adev->irq[0];\n\tif (!irq)\n\t\tdev_warn(&adev->dev, \"IRQ support disabled\\n\");\n\tpl061->parent_irq = irq;\n\n\tgirq = &pl061->gc.irq;\n\tgpio_irq_chip_set_chip(girq, &pl061_irq_chip);\n\tgirq->parent_handler = pl061_irq_handler;\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(dev, 1, sizeof(*girq->parents),\n\t\t\t\t     GFP_KERNEL);\n\tif (!girq->parents)\n\t\treturn -ENOMEM;\n\tgirq->parents[0] = irq;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\n\tret = devm_gpiochip_add_data(dev, &pl061->gc, pl061);\n\tif (ret)\n\t\treturn ret;\n\n\tamba_set_drvdata(adev, pl061);\n\tdev_info(dev, \"PL061 GPIO chip registered\\n\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int pl061_suspend(struct device *dev)\n{\n\tstruct pl061 *pl061 = dev_get_drvdata(dev);\n\tint offset;\n\n\tpl061->csave_regs.gpio_data = 0;\n\tpl061->csave_regs.gpio_dir = readb(pl061->base + GPIODIR);\n\tpl061->csave_regs.gpio_is = readb(pl061->base + GPIOIS);\n\tpl061->csave_regs.gpio_ibe = readb(pl061->base + GPIOIBE);\n\tpl061->csave_regs.gpio_iev = readb(pl061->base + GPIOIEV);\n\tpl061->csave_regs.gpio_ie = readb(pl061->base + GPIOIE);\n\n\tfor (offset = 0; offset < PL061_GPIO_NR; offset++) {\n\t\tif (pl061->csave_regs.gpio_dir & (BIT(offset)))\n\t\t\tpl061->csave_regs.gpio_data |=\n\t\t\t\tpl061_get_value(&pl061->gc, offset) << offset;\n\t}\n\n\treturn 0;\n}\n\nstatic int pl061_resume(struct device *dev)\n{\n\tstruct pl061 *pl061 = dev_get_drvdata(dev);\n\tint offset;\n\n\tfor (offset = 0; offset < PL061_GPIO_NR; offset++) {\n\t\tif (pl061->csave_regs.gpio_dir & (BIT(offset)))\n\t\t\tpl061_direction_output(&pl061->gc, offset,\n\t\t\t\t\tpl061->csave_regs.gpio_data &\n\t\t\t\t\t(BIT(offset)));\n\t\telse\n\t\t\tpl061_direction_input(&pl061->gc, offset);\n\t}\n\n\twriteb(pl061->csave_regs.gpio_is, pl061->base + GPIOIS);\n\twriteb(pl061->csave_regs.gpio_ibe, pl061->base + GPIOIBE);\n\twriteb(pl061->csave_regs.gpio_iev, pl061->base + GPIOIEV);\n\twriteb(pl061->csave_regs.gpio_ie, pl061->base + GPIOIE);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops pl061_dev_pm_ops = {\n\t.suspend = pl061_suspend,\n\t.resume = pl061_resume,\n\t.freeze = pl061_suspend,\n\t.restore = pl061_resume,\n};\n#endif\n\nstatic const struct amba_id pl061_ids[] = {\n\t{\n\t\t.id\t= 0x00041061,\n\t\t.mask\t= 0x000fffff,\n\t},\n\t{ 0, 0 },\n};\nMODULE_DEVICE_TABLE(amba, pl061_ids);\n\nstatic struct amba_driver pl061_gpio_driver = {\n\t.drv = {\n\t\t.name\t= \"pl061_gpio\",\n#ifdef CONFIG_PM\n\t\t.pm\t= &pl061_dev_pm_ops,\n#endif\n\t},\n\t.id_table\t= pl061_ids,\n\t.probe\t\t= pl061_probe,\n};\nmodule_amba_driver(pl061_gpio_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}