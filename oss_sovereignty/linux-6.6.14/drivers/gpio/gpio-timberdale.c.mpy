{
  "module_name": "gpio-timberdale.c",
  "hash_id": "97251a5c3ebe3fff63a6ac43ec829aef5c63ffd926d657693d99804af2bdd741",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-timberdale.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/gpio/driver.h>\n#include <linux/platform_device.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/timb_gpio.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n\n#define DRIVER_NAME \"timb-gpio\"\n\n#define TGPIOVAL\t0x00\n#define TGPIODIR\t0x04\n#define TGPIO_IER\t0x08\n#define TGPIO_ISR\t0x0c\n#define TGPIO_IPR\t0x10\n#define TGPIO_ICR\t0x14\n#define TGPIO_FLR\t0x18\n#define TGPIO_LVR\t0x1c\n#define TGPIO_VER\t0x20\n#define TGPIO_BFLR\t0x24\n\nstruct timbgpio {\n\tvoid __iomem\t\t*membase;\n\tspinlock_t\t\tlock;  \n\tstruct gpio_chip\tgpio;\n\tint\t\t\tirq_base;\n\tunsigned long\t\tlast_ier;\n};\n\nstatic int timbgpio_update_bit(struct gpio_chip *gpio, unsigned index,\n\tunsigned offset, bool enabled)\n{\n\tstruct timbgpio *tgpio = gpiochip_get_data(gpio);\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&tgpio->lock, flags);\n\treg = ioread32(tgpio->membase + offset);\n\n\tif (enabled)\n\t\treg |= (1 << index);\n\telse\n\t\treg &= ~(1 << index);\n\n\tiowrite32(reg, tgpio->membase + offset);\n\tspin_unlock_irqrestore(&tgpio->lock, flags);\n\n\treturn 0;\n}\n\nstatic int timbgpio_gpio_direction_input(struct gpio_chip *gpio, unsigned nr)\n{\n\treturn timbgpio_update_bit(gpio, nr, TGPIODIR, true);\n}\n\nstatic int timbgpio_gpio_get(struct gpio_chip *gpio, unsigned nr)\n{\n\tstruct timbgpio *tgpio = gpiochip_get_data(gpio);\n\tu32 value;\n\n\tvalue = ioread32(tgpio->membase + TGPIOVAL);\n\treturn (value & (1 << nr)) ? 1 : 0;\n}\n\nstatic int timbgpio_gpio_direction_output(struct gpio_chip *gpio,\n\t\t\t\t\t\tunsigned nr, int val)\n{\n\treturn timbgpio_update_bit(gpio, nr, TGPIODIR, false);\n}\n\nstatic void timbgpio_gpio_set(struct gpio_chip *gpio,\n\t\t\t\tunsigned nr, int val)\n{\n\ttimbgpio_update_bit(gpio, nr, TGPIOVAL, val != 0);\n}\n\nstatic int timbgpio_to_irq(struct gpio_chip *gpio, unsigned offset)\n{\n\tstruct timbgpio *tgpio = gpiochip_get_data(gpio);\n\n\tif (tgpio->irq_base <= 0)\n\t\treturn -EINVAL;\n\n\treturn tgpio->irq_base + offset;\n}\n\n \nstatic void timbgpio_irq_disable(struct irq_data *d)\n{\n\tstruct timbgpio *tgpio = irq_data_get_irq_chip_data(d);\n\tint offset = d->irq - tgpio->irq_base;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tgpio->lock, flags);\n\ttgpio->last_ier &= ~(1UL << offset);\n\tiowrite32(tgpio->last_ier, tgpio->membase + TGPIO_IER);\n\tspin_unlock_irqrestore(&tgpio->lock, flags);\n}\n\nstatic void timbgpio_irq_enable(struct irq_data *d)\n{\n\tstruct timbgpio *tgpio = irq_data_get_irq_chip_data(d);\n\tint offset = d->irq - tgpio->irq_base;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tgpio->lock, flags);\n\ttgpio->last_ier |= 1UL << offset;\n\tiowrite32(tgpio->last_ier, tgpio->membase + TGPIO_IER);\n\tspin_unlock_irqrestore(&tgpio->lock, flags);\n}\n\nstatic int timbgpio_irq_type(struct irq_data *d, unsigned trigger)\n{\n\tstruct timbgpio *tgpio = irq_data_get_irq_chip_data(d);\n\tint offset = d->irq - tgpio->irq_base;\n\tunsigned long flags;\n\tu32 lvr, flr, bflr = 0;\n\tu32 ver;\n\tint ret = 0;\n\n\tif (offset < 0 || offset > tgpio->gpio.ngpio)\n\t\treturn -EINVAL;\n\n\tver = ioread32(tgpio->membase + TGPIO_VER);\n\n\tspin_lock_irqsave(&tgpio->lock, flags);\n\n\tlvr = ioread32(tgpio->membase + TGPIO_LVR);\n\tflr = ioread32(tgpio->membase + TGPIO_FLR);\n\tif (ver > 2)\n\t\tbflr = ioread32(tgpio->membase + TGPIO_BFLR);\n\n\tif (trigger & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {\n\t\tbflr &= ~(1 << offset);\n\t\tflr &= ~(1 << offset);\n\t\tif (trigger & IRQ_TYPE_LEVEL_HIGH)\n\t\t\tlvr |= 1 << offset;\n\t\telse\n\t\t\tlvr &= ~(1 << offset);\n\t}\n\n\tif ((trigger & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\n\t\tif (ver < 3) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tflr |= 1 << offset;\n\t\t\tbflr |= 1 << offset;\n\t\t}\n\t} else {\n\t\tbflr &= ~(1 << offset);\n\t\tflr |= 1 << offset;\n\t\tif (trigger & IRQ_TYPE_EDGE_FALLING)\n\t\t\tlvr &= ~(1 << offset);\n\t\telse\n\t\t\tlvr |= 1 << offset;\n\t}\n\n\tiowrite32(lvr, tgpio->membase + TGPIO_LVR);\n\tiowrite32(flr, tgpio->membase + TGPIO_FLR);\n\tif (ver > 2)\n\t\tiowrite32(bflr, tgpio->membase + TGPIO_BFLR);\n\n\tiowrite32(1 << offset, tgpio->membase + TGPIO_ICR);\n\nout:\n\tspin_unlock_irqrestore(&tgpio->lock, flags);\n\treturn ret;\n}\n\nstatic void timbgpio_irq(struct irq_desc *desc)\n{\n\tstruct timbgpio *tgpio = irq_desc_get_handler_data(desc);\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tunsigned long ipr;\n\tint offset;\n\n\tdata->chip->irq_ack(data);\n\tipr = ioread32(tgpio->membase + TGPIO_IPR);\n\tiowrite32(ipr, tgpio->membase + TGPIO_ICR);\n\n\t \n\tiowrite32(0, tgpio->membase + TGPIO_IER);\n\n\tfor_each_set_bit(offset, &ipr, tgpio->gpio.ngpio)\n\t\tgeneric_handle_irq(timbgpio_to_irq(&tgpio->gpio, offset));\n\n\tiowrite32(tgpio->last_ier, tgpio->membase + TGPIO_IER);\n}\n\nstatic struct irq_chip timbgpio_irqchip = {\n\t.name\t\t= \"GPIO\",\n\t.irq_enable\t= timbgpio_irq_enable,\n\t.irq_disable\t= timbgpio_irq_disable,\n\t.irq_set_type\t= timbgpio_irq_type,\n};\n\nstatic int timbgpio_probe(struct platform_device *pdev)\n{\n\tint err, i;\n\tstruct device *dev = &pdev->dev;\n\tstruct gpio_chip *gc;\n\tstruct timbgpio *tgpio;\n\tstruct timbgpio_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tint irq = platform_get_irq(pdev, 0);\n\n\tif (!pdata || pdata->nr_pins > 32) {\n\t\tdev_err(dev, \"Invalid platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttgpio = devm_kzalloc(dev, sizeof(*tgpio), GFP_KERNEL);\n\tif (!tgpio)\n\t\treturn -EINVAL;\n\n\ttgpio->irq_base = pdata->irq_base;\n\n\tspin_lock_init(&tgpio->lock);\n\n\ttgpio->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tgpio->membase))\n\t\treturn PTR_ERR(tgpio->membase);\n\n\tgc = &tgpio->gpio;\n\n\tgc->label = dev_name(&pdev->dev);\n\tgc->owner = THIS_MODULE;\n\tgc->parent = &pdev->dev;\n\tgc->direction_input = timbgpio_gpio_direction_input;\n\tgc->get = timbgpio_gpio_get;\n\tgc->direction_output = timbgpio_gpio_direction_output;\n\tgc->set = timbgpio_gpio_set;\n\tgc->to_irq = (irq >= 0 && tgpio->irq_base > 0) ? timbgpio_to_irq : NULL;\n\tgc->dbg_show = NULL;\n\tgc->base = pdata->gpio_base;\n\tgc->ngpio = pdata->nr_pins;\n\tgc->can_sleep = false;\n\n\terr = devm_gpiochip_add_data(&pdev->dev, gc, tgpio);\n\tif (err)\n\t\treturn err;\n\n\t \n\tiowrite32(0x0, tgpio->membase + TGPIO_IER);\n\n\tif (irq < 0 || tgpio->irq_base <= 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < pdata->nr_pins; i++) {\n\t\tirq_set_chip_and_handler(tgpio->irq_base + i,\n\t\t\t&timbgpio_irqchip, handle_simple_irq);\n\t\tirq_set_chip_data(tgpio->irq_base + i, tgpio);\n\t\tirq_clear_status_flags(tgpio->irq_base + i, IRQ_NOREQUEST | IRQ_NOPROBE);\n\t}\n\n\tirq_set_chained_handler_and_data(irq, timbgpio_irq, tgpio);\n\n\treturn 0;\n}\n\nstatic struct platform_driver timbgpio_platform_driver = {\n\t.driver = {\n\t\t.name\t\t\t= DRIVER_NAME,\n\t\t.suppress_bind_attrs\t= true,\n\t},\n\t.probe\t\t= timbgpio_probe,\n};\n\n \n\nbuiltin_platform_driver(timbgpio_platform_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}