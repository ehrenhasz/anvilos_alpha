{
  "module_name": "gpio-zevio.c",
  "hash_id": "f60767fe25fe3f02333f65f63ba494a91cf65dcaae78d81053900e1a7a390f9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-zevio.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <linux/gpio/driver.h>\n\n \n\n#define ZEVIO_GPIO_SECTION_SIZE\t\t\t0x40\n\n \n#define ZEVIO_GPIO_INT_MASKED_STATUS\t0x00\n#define ZEVIO_GPIO_INT_STATUS\t\t0x04\n#define ZEVIO_GPIO_INT_UNMASK\t\t0x08\n#define ZEVIO_GPIO_INT_MASK\t\t0x0C\n#define ZEVIO_GPIO_DIRECTION\t\t0x10\n#define ZEVIO_GPIO_OUTPUT\t\t0x14\n#define ZEVIO_GPIO_INPUT\t\t\t0x18\n#define ZEVIO_GPIO_INT_STICKY\t\t0x20\n\n \n#define ZEVIO_GPIO_BIT(gpio) (gpio&7)\n\nstruct zevio_gpio {\n\tstruct gpio_chip        chip;\n\tspinlock_t\t\tlock;\n\tvoid __iomem\t\t*regs;\n};\n\nstatic inline u32 zevio_gpio_port_get(struct zevio_gpio *c, unsigned pin,\n\t\t\t\t\tunsigned port_offset)\n{\n\tunsigned section_offset = ((pin >> 3) & 3)*ZEVIO_GPIO_SECTION_SIZE;\n\treturn readl(IOMEM(c->regs + section_offset + port_offset));\n}\n\nstatic inline void zevio_gpio_port_set(struct zevio_gpio *c, unsigned pin,\n\t\t\t\t\tunsigned port_offset, u32 val)\n{\n\tunsigned section_offset = ((pin >> 3) & 3)*ZEVIO_GPIO_SECTION_SIZE;\n\twritel(val, IOMEM(c->regs + section_offset + port_offset));\n}\n\n \nstatic int zevio_gpio_get(struct gpio_chip *chip, unsigned pin)\n{\n\tstruct zevio_gpio *controller = gpiochip_get_data(chip);\n\tu32 val, dir;\n\n\tspin_lock(&controller->lock);\n\tdir = zevio_gpio_port_get(controller, pin, ZEVIO_GPIO_DIRECTION);\n\tif (dir & BIT(ZEVIO_GPIO_BIT(pin)))\n\t\tval = zevio_gpio_port_get(controller, pin, ZEVIO_GPIO_INPUT);\n\telse\n\t\tval = zevio_gpio_port_get(controller, pin, ZEVIO_GPIO_OUTPUT);\n\tspin_unlock(&controller->lock);\n\n\treturn (val >> ZEVIO_GPIO_BIT(pin)) & 0x1;\n}\n\nstatic void zevio_gpio_set(struct gpio_chip *chip, unsigned pin, int value)\n{\n\tstruct zevio_gpio *controller = gpiochip_get_data(chip);\n\tu32 val;\n\n\tspin_lock(&controller->lock);\n\tval = zevio_gpio_port_get(controller, pin, ZEVIO_GPIO_OUTPUT);\n\tif (value)\n\t\tval |= BIT(ZEVIO_GPIO_BIT(pin));\n\telse\n\t\tval &= ~BIT(ZEVIO_GPIO_BIT(pin));\n\n\tzevio_gpio_port_set(controller, pin, ZEVIO_GPIO_OUTPUT, val);\n\tspin_unlock(&controller->lock);\n}\n\nstatic int zevio_gpio_direction_input(struct gpio_chip *chip, unsigned pin)\n{\n\tstruct zevio_gpio *controller = gpiochip_get_data(chip);\n\tu32 val;\n\n\tspin_lock(&controller->lock);\n\n\tval = zevio_gpio_port_get(controller, pin, ZEVIO_GPIO_DIRECTION);\n\tval |= BIT(ZEVIO_GPIO_BIT(pin));\n\tzevio_gpio_port_set(controller, pin, ZEVIO_GPIO_DIRECTION, val);\n\n\tspin_unlock(&controller->lock);\n\n\treturn 0;\n}\n\nstatic int zevio_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t       unsigned pin, int value)\n{\n\tstruct zevio_gpio *controller = gpiochip_get_data(chip);\n\tu32 val;\n\n\tspin_lock(&controller->lock);\n\tval = zevio_gpio_port_get(controller, pin, ZEVIO_GPIO_OUTPUT);\n\tif (value)\n\t\tval |= BIT(ZEVIO_GPIO_BIT(pin));\n\telse\n\t\tval &= ~BIT(ZEVIO_GPIO_BIT(pin));\n\n\tzevio_gpio_port_set(controller, pin, ZEVIO_GPIO_OUTPUT, val);\n\tval = zevio_gpio_port_get(controller, pin, ZEVIO_GPIO_DIRECTION);\n\tval &= ~BIT(ZEVIO_GPIO_BIT(pin));\n\tzevio_gpio_port_set(controller, pin, ZEVIO_GPIO_DIRECTION, val);\n\n\tspin_unlock(&controller->lock);\n\n\treturn 0;\n}\n\nstatic int zevio_gpio_to_irq(struct gpio_chip *chip, unsigned pin)\n{\n\t \n\n\treturn -ENXIO;\n}\n\nstatic const struct gpio_chip zevio_gpio_chip = {\n\t.direction_input\t= zevio_gpio_direction_input,\n\t.direction_output\t= zevio_gpio_direction_output,\n\t.set\t\t\t= zevio_gpio_set,\n\t.get\t\t\t= zevio_gpio_get,\n\t.to_irq\t\t\t= zevio_gpio_to_irq,\n\t.base\t\t\t= 0,\n\t.owner\t\t\t= THIS_MODULE,\n\t.ngpio\t\t\t= 32,\n};\n\n \nstatic int zevio_gpio_probe(struct platform_device *pdev)\n{\n\tstruct zevio_gpio *controller;\n\tint status, i;\n\n\tcontroller = devm_kzalloc(&pdev->dev, sizeof(*controller), GFP_KERNEL);\n\tif (!controller)\n\t\treturn -ENOMEM;\n\n\t \n\tcontroller->chip = zevio_gpio_chip;\n\tcontroller->chip.parent = &pdev->dev;\n\n\tcontroller->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(controller->regs))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(controller->regs),\n\t\t\t\t     \"failed to ioremap memory resource\\n\");\n\n\tstatus = devm_gpiochip_add_data(&pdev->dev, &controller->chip, controller);\n\tif (status) {\n\t\tdev_err(&pdev->dev, \"failed to add gpiochip: %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tspin_lock_init(&controller->lock);\n\n\t \n\tfor (i = 0; i < controller->chip.ngpio; i += 8)\n\t\tzevio_gpio_port_set(controller, i, ZEVIO_GPIO_INT_MASK, 0xFF);\n\n\tdev_dbg(controller->chip.parent, \"ZEVIO GPIO controller set up!\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id zevio_gpio_of_match[] = {\n\t{ .compatible = \"lsi,zevio-gpio\", },\n\t{ },\n};\n\nstatic struct platform_driver zevio_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"gpio-zevio\",\n\t\t.of_match_table = zevio_gpio_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= zevio_gpio_probe,\n};\nbuiltin_platform_driver(zevio_gpio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}