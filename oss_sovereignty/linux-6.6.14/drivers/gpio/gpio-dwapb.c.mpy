{
  "module_name": "gpio-dwapb.c",
  "hash_id": "18b762d43ca572ad3d437c272ee8dfb6579890b19f904b94522631f1111ad17b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-dwapb.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"gpiolib.h\"\n#include \"gpiolib-acpi.h\"\n\n#define GPIO_SWPORTA_DR\t\t0x00\n#define GPIO_SWPORTA_DDR\t0x04\n#define GPIO_SWPORTB_DR\t\t0x0c\n#define GPIO_SWPORTB_DDR\t0x10\n#define GPIO_SWPORTC_DR\t\t0x18\n#define GPIO_SWPORTC_DDR\t0x1c\n#define GPIO_SWPORTD_DR\t\t0x24\n#define GPIO_SWPORTD_DDR\t0x28\n#define GPIO_INTEN\t\t0x30\n#define GPIO_INTMASK\t\t0x34\n#define GPIO_INTTYPE_LEVEL\t0x38\n#define GPIO_INT_POLARITY\t0x3c\n#define GPIO_INTSTATUS\t\t0x40\n#define GPIO_PORTA_DEBOUNCE\t0x48\n#define GPIO_PORTA_EOI\t\t0x4c\n#define GPIO_EXT_PORTA\t\t0x50\n#define GPIO_EXT_PORTB\t\t0x54\n#define GPIO_EXT_PORTC\t\t0x58\n#define GPIO_EXT_PORTD\t\t0x5c\n\n#define DWAPB_DRIVER_NAME\t\"gpio-dwapb\"\n#define DWAPB_MAX_PORTS\t\t4\n#define DWAPB_MAX_GPIOS\t\t32\n\n#define GPIO_EXT_PORT_STRIDE\t0x04  \n#define GPIO_SWPORT_DR_STRIDE\t0x0c  \n#define GPIO_SWPORT_DDR_STRIDE\t0x0c  \n\n#define GPIO_REG_OFFSET_V1\t0\n#define GPIO_REG_OFFSET_V2\t1\n#define GPIO_REG_OFFSET_MASK\tBIT(0)\n\n#define GPIO_INTMASK_V2\t\t0x44\n#define GPIO_INTTYPE_LEVEL_V2\t0x34\n#define GPIO_INT_POLARITY_V2\t0x38\n#define GPIO_INTSTATUS_V2\t0x3c\n#define GPIO_PORTA_EOI_V2\t0x40\n\n#define DWAPB_NR_CLOCKS\t\t2\n\nstruct dwapb_gpio;\n\nstruct dwapb_port_property {\n\tstruct fwnode_handle *fwnode;\n\tunsigned int idx;\n\tunsigned int ngpio;\n\tunsigned int gpio_base;\n\tint irq[DWAPB_MAX_GPIOS];\n};\n\nstruct dwapb_platform_data {\n\tstruct dwapb_port_property *properties;\n\tunsigned int nports;\n};\n\n#ifdef CONFIG_PM_SLEEP\n \nstruct dwapb_context {\n\tu32 data;\n\tu32 dir;\n\tu32 ext;\n\tu32 int_en;\n\tu32 int_mask;\n\tu32 int_type;\n\tu32 int_pol;\n\tu32 int_deb;\n\tu32 wake_en;\n};\n#endif\n\nstruct dwapb_gpio_port_irqchip {\n\tunsigned int\t\tnr_irqs;\n\tunsigned int\t\tirq[DWAPB_MAX_GPIOS];\n};\n\nstruct dwapb_gpio_port {\n\tstruct gpio_chip\tgc;\n\tstruct dwapb_gpio_port_irqchip *pirq;\n\tstruct dwapb_gpio\t*gpio;\n#ifdef CONFIG_PM_SLEEP\n\tstruct dwapb_context\t*ctx;\n#endif\n\tunsigned int\t\tidx;\n};\n#define to_dwapb_gpio(_gc) \\\n\t(container_of(_gc, struct dwapb_gpio_port, gc)->gpio)\n\nstruct dwapb_gpio {\n\tstruct\tdevice\t\t*dev;\n\tvoid __iomem\t\t*regs;\n\tstruct dwapb_gpio_port\t*ports;\n\tunsigned int\t\tnr_ports;\n\tunsigned int\t\tflags;\n\tstruct reset_control\t*rst;\n\tstruct clk_bulk_data\tclks[DWAPB_NR_CLOCKS];\n};\n\nstatic inline u32 gpio_reg_v2_convert(unsigned int offset)\n{\n\tswitch (offset) {\n\tcase GPIO_INTMASK:\n\t\treturn GPIO_INTMASK_V2;\n\tcase GPIO_INTTYPE_LEVEL:\n\t\treturn GPIO_INTTYPE_LEVEL_V2;\n\tcase GPIO_INT_POLARITY:\n\t\treturn GPIO_INT_POLARITY_V2;\n\tcase GPIO_INTSTATUS:\n\t\treturn GPIO_INTSTATUS_V2;\n\tcase GPIO_PORTA_EOI:\n\t\treturn GPIO_PORTA_EOI_V2;\n\t}\n\n\treturn offset;\n}\n\nstatic inline u32 gpio_reg_convert(struct dwapb_gpio *gpio, unsigned int offset)\n{\n\tif ((gpio->flags & GPIO_REG_OFFSET_MASK) == GPIO_REG_OFFSET_V2)\n\t\treturn gpio_reg_v2_convert(offset);\n\n\treturn offset;\n}\n\nstatic inline u32 dwapb_read(struct dwapb_gpio *gpio, unsigned int offset)\n{\n\tstruct gpio_chip *gc\t= &gpio->ports[0].gc;\n\tvoid __iomem *reg_base\t= gpio->regs;\n\n\treturn gc->read_reg(reg_base + gpio_reg_convert(gpio, offset));\n}\n\nstatic inline void dwapb_write(struct dwapb_gpio *gpio, unsigned int offset,\n\t\t\t       u32 val)\n{\n\tstruct gpio_chip *gc\t= &gpio->ports[0].gc;\n\tvoid __iomem *reg_base\t= gpio->regs;\n\n\tgc->write_reg(reg_base + gpio_reg_convert(gpio, offset), val);\n}\n\nstatic struct dwapb_gpio_port *dwapb_offs_to_port(struct dwapb_gpio *gpio, unsigned int offs)\n{\n\tstruct dwapb_gpio_port *port;\n\tint i;\n\n\tfor (i = 0; i < gpio->nr_ports; i++) {\n\t\tport = &gpio->ports[i];\n\t\tif (port->idx == offs / DWAPB_MAX_GPIOS)\n\t\t\treturn port;\n\t}\n\n\treturn NULL;\n}\n\nstatic void dwapb_toggle_trigger(struct dwapb_gpio *gpio, unsigned int offs)\n{\n\tstruct dwapb_gpio_port *port = dwapb_offs_to_port(gpio, offs);\n\tstruct gpio_chip *gc;\n\tu32 pol;\n\tint val;\n\n\tif (!port)\n\t\treturn;\n\tgc = &port->gc;\n\n\tpol = dwapb_read(gpio, GPIO_INT_POLARITY);\n\t \n\tval = gc->get(gc, offs % DWAPB_MAX_GPIOS);\n\tif (val)\n\t\tpol &= ~BIT(offs);\n\telse\n\t\tpol |= BIT(offs);\n\n\tdwapb_write(gpio, GPIO_INT_POLARITY, pol);\n}\n\nstatic u32 dwapb_do_irq(struct dwapb_gpio *gpio)\n{\n\tstruct gpio_chip *gc = &gpio->ports[0].gc;\n\tunsigned long irq_status;\n\tirq_hw_number_t hwirq;\n\n\tirq_status = dwapb_read(gpio, GPIO_INTSTATUS);\n\tfor_each_set_bit(hwirq, &irq_status, DWAPB_MAX_GPIOS) {\n\t\tint gpio_irq = irq_find_mapping(gc->irq.domain, hwirq);\n\t\tu32 irq_type = irq_get_trigger_type(gpio_irq);\n\n\t\tgeneric_handle_irq(gpio_irq);\n\n\t\tif ((irq_type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH)\n\t\t\tdwapb_toggle_trigger(gpio, hwirq);\n\t}\n\n\treturn irq_status;\n}\n\nstatic void dwapb_irq_handler(struct irq_desc *desc)\n{\n\tstruct dwapb_gpio *gpio = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\tchained_irq_enter(chip, desc);\n\tdwapb_do_irq(gpio);\n\tchained_irq_exit(chip, desc);\n}\n\nstatic irqreturn_t dwapb_irq_handler_mfd(int irq, void *dev_id)\n{\n\treturn IRQ_RETVAL(dwapb_do_irq(dev_id));\n}\n\nstatic void dwapb_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct dwapb_gpio *gpio = to_dwapb_gpio(gc);\n\tu32 val = BIT(irqd_to_hwirq(d));\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\tdwapb_write(gpio, GPIO_PORTA_EOI, val);\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n}\n\nstatic void dwapb_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct dwapb_gpio *gpio = to_dwapb_gpio(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\tval = dwapb_read(gpio, GPIO_INTMASK) | BIT(hwirq);\n\tdwapb_write(gpio, GPIO_INTMASK, val);\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void dwapb_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct dwapb_gpio *gpio = to_dwapb_gpio(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 val;\n\n\tgpiochip_enable_irq(gc, hwirq);\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\tval = dwapb_read(gpio, GPIO_INTMASK) & ~BIT(hwirq);\n\tdwapb_write(gpio, GPIO_INTMASK, val);\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n}\n\nstatic void dwapb_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct dwapb_gpio *gpio = to_dwapb_gpio(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\tval = dwapb_read(gpio, GPIO_INTEN) | BIT(hwirq);\n\tdwapb_write(gpio, GPIO_INTEN, val);\n\tval = dwapb_read(gpio, GPIO_INTMASK) & ~BIT(hwirq);\n\tdwapb_write(gpio, GPIO_INTMASK, val);\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n}\n\nstatic void dwapb_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct dwapb_gpio *gpio = to_dwapb_gpio(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\tval = dwapb_read(gpio, GPIO_INTMASK) | BIT(hwirq);\n\tdwapb_write(gpio, GPIO_INTMASK, val);\n\tval = dwapb_read(gpio, GPIO_INTEN) & ~BIT(hwirq);\n\tdwapb_write(gpio, GPIO_INTEN, val);\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n}\n\nstatic int dwapb_irq_set_type(struct irq_data *d, u32 type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct dwapb_gpio *gpio = to_dwapb_gpio(gc);\n\tirq_hw_number_t bit = irqd_to_hwirq(d);\n\tunsigned long level, polarity, flags;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\tlevel = dwapb_read(gpio, GPIO_INTTYPE_LEVEL);\n\tpolarity = dwapb_read(gpio, GPIO_INT_POLARITY);\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tlevel |= BIT(bit);\n\t\tdwapb_toggle_trigger(gpio, bit);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tlevel |= BIT(bit);\n\t\tpolarity |= BIT(bit);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tlevel |= BIT(bit);\n\t\tpolarity &= ~BIT(bit);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tlevel &= ~BIT(bit);\n\t\tpolarity |= BIT(bit);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tlevel &= ~BIT(bit);\n\t\tpolarity &= ~BIT(bit);\n\t\tbreak;\n\t}\n\n\tif (type & IRQ_TYPE_LEVEL_MASK)\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\telse if (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\n\tdwapb_write(gpio, GPIO_INTTYPE_LEVEL, level);\n\tif (type != IRQ_TYPE_EDGE_BOTH)\n\t\tdwapb_write(gpio, GPIO_INT_POLARITY, polarity);\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int dwapb_irq_set_wake(struct irq_data *d, unsigned int enable)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct dwapb_gpio *gpio = to_dwapb_gpio(gc);\n\tstruct dwapb_context *ctx = gpio->ports[0].ctx;\n\tirq_hw_number_t bit = irqd_to_hwirq(d);\n\n\tif (enable)\n\t\tctx->wake_en |= BIT(bit);\n\telse\n\t\tctx->wake_en &= ~BIT(bit);\n\n\treturn 0;\n}\n#else\n#define dwapb_irq_set_wake\tNULL\n#endif\n\nstatic const struct irq_chip dwapb_irq_chip = {\n\t.name\t\t= DWAPB_DRIVER_NAME,\n\t.irq_ack\t= dwapb_irq_ack,\n\t.irq_mask\t= dwapb_irq_mask,\n\t.irq_unmask\t= dwapb_irq_unmask,\n\t.irq_set_type\t= dwapb_irq_set_type,\n\t.irq_enable\t= dwapb_irq_enable,\n\t.irq_disable\t= dwapb_irq_disable,\n\t.irq_set_wake\t= dwapb_irq_set_wake,\n\t.flags\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int dwapb_gpio_set_debounce(struct gpio_chip *gc,\n\t\t\t\t   unsigned offset, unsigned debounce)\n{\n\tstruct dwapb_gpio_port *port = gpiochip_get_data(gc);\n\tstruct dwapb_gpio *gpio = port->gpio;\n\tunsigned long flags, val_deb;\n\tunsigned long mask = BIT(offset);\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\n\tval_deb = dwapb_read(gpio, GPIO_PORTA_DEBOUNCE);\n\tif (debounce)\n\t\tval_deb |= mask;\n\telse\n\t\tval_deb &= ~mask;\n\tdwapb_write(gpio, GPIO_PORTA_DEBOUNCE, val_deb);\n\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\n\treturn 0;\n}\n\nstatic int dwapb_gpio_set_config(struct gpio_chip *gc, unsigned offset,\n\t\t\t\t unsigned long config)\n{\n\tu32 debounce;\n\n\tif (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)\n\t\treturn -ENOTSUPP;\n\n\tdebounce = pinconf_to_config_argument(config);\n\treturn dwapb_gpio_set_debounce(gc, offset, debounce);\n}\n\nstatic int dwapb_convert_irqs(struct dwapb_gpio_port_irqchip *pirq,\n\t\t\t      struct dwapb_port_property *pp)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < pp->ngpio; ++i) {\n\t\tif (!pp->irq[i])\n\t\t\tcontinue;\n\n\t\tpirq->irq[pirq->nr_irqs++] = pp->irq[i];\n\t}\n\n\treturn pirq->nr_irqs ? 0 : -ENOENT;\n}\n\nstatic void dwapb_configure_irqs(struct dwapb_gpio *gpio,\n\t\t\t\t struct dwapb_gpio_port *port,\n\t\t\t\t struct dwapb_port_property *pp)\n{\n\tstruct dwapb_gpio_port_irqchip *pirq;\n\tstruct gpio_chip *gc = &port->gc;\n\tstruct gpio_irq_chip *girq;\n\tint err;\n\n\tpirq = devm_kzalloc(gpio->dev, sizeof(*pirq), GFP_KERNEL);\n\tif (!pirq)\n\t\treturn;\n\n\tif (dwapb_convert_irqs(pirq, pp)) {\n\t\tdev_warn(gpio->dev, \"no IRQ for port%d\\n\", pp->idx);\n\t\tgoto err_kfree_pirq;\n\t}\n\n\tgirq = &gc->irq;\n\tgirq->handler = handle_bad_irq;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\n\tport->pirq = pirq;\n\n\t \n\tif (has_acpi_companion(gpio->dev)) {\n\t\tgirq->num_parents = 0;\n\t\tgirq->parents = NULL;\n\t\tgirq->parent_handler = NULL;\n\n\t\terr = devm_request_irq(gpio->dev, pp->irq[0],\n\t\t\t\t       dwapb_irq_handler_mfd,\n\t\t\t\t       IRQF_SHARED, DWAPB_DRIVER_NAME, gpio);\n\t\tif (err) {\n\t\t\tdev_err(gpio->dev, \"error requesting IRQ\\n\");\n\t\t\tgoto err_kfree_pirq;\n\t\t}\n\t} else {\n\t\tgirq->num_parents = pirq->nr_irqs;\n\t\tgirq->parents = pirq->irq;\n\t\tgirq->parent_handler_data = gpio;\n\t\tgirq->parent_handler = dwapb_irq_handler;\n\t}\n\n\tgpio_irq_chip_set_chip(girq, &dwapb_irq_chip);\n\n\treturn;\n\nerr_kfree_pirq:\n\tdevm_kfree(gpio->dev, pirq);\n}\n\nstatic int dwapb_gpio_add_port(struct dwapb_gpio *gpio,\n\t\t\t       struct dwapb_port_property *pp,\n\t\t\t       unsigned int offs)\n{\n\tstruct dwapb_gpio_port *port;\n\tvoid __iomem *dat, *set, *dirout;\n\tint err;\n\n\tport = &gpio->ports[offs];\n\tport->gpio = gpio;\n\tport->idx = pp->idx;\n\n#ifdef CONFIG_PM_SLEEP\n\tport->ctx = devm_kzalloc(gpio->dev, sizeof(*port->ctx), GFP_KERNEL);\n\tif (!port->ctx)\n\t\treturn -ENOMEM;\n#endif\n\n\tdat = gpio->regs + GPIO_EXT_PORTA + pp->idx * GPIO_EXT_PORT_STRIDE;\n\tset = gpio->regs + GPIO_SWPORTA_DR + pp->idx * GPIO_SWPORT_DR_STRIDE;\n\tdirout = gpio->regs + GPIO_SWPORTA_DDR + pp->idx * GPIO_SWPORT_DDR_STRIDE;\n\n\t \n\terr = bgpio_init(&port->gc, gpio->dev, 4, dat, set, NULL, dirout,\n\t\t\t NULL, 0);\n\tif (err) {\n\t\tdev_err(gpio->dev, \"failed to init gpio chip for port%d\\n\",\n\t\t\tport->idx);\n\t\treturn err;\n\t}\n\n\tport->gc.fwnode = pp->fwnode;\n\tport->gc.ngpio = pp->ngpio;\n\tport->gc.base = pp->gpio_base;\n\n\t \n\tif (pp->idx == 0)\n\t\tport->gc.set_config = dwapb_gpio_set_config;\n\n\t \n\tif (pp->idx == 0)\n\t\tdwapb_configure_irqs(gpio, port, pp);\n\n\terr = devm_gpiochip_add_data(gpio->dev, &port->gc, port);\n\tif (err) {\n\t\tdev_err(gpio->dev, \"failed to register gpiochip for port%d\\n\",\n\t\t\tport->idx);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void dwapb_get_irq(struct device *dev, struct fwnode_handle *fwnode,\n\t\t\t  struct dwapb_port_property *pp)\n{\n\tint irq, j;\n\n\tfor (j = 0; j < pp->ngpio; j++) {\n\t\tif (has_acpi_companion(dev))\n\t\t\tirq = platform_get_irq_optional(to_platform_device(dev), j);\n\t\telse\n\t\t\tirq = fwnode_irq_get(fwnode, j);\n\t\tif (irq > 0)\n\t\t\tpp->irq[j] = irq;\n\t}\n}\n\nstatic struct dwapb_platform_data *dwapb_gpio_get_pdata(struct device *dev)\n{\n\tstruct fwnode_handle *fwnode;\n\tstruct dwapb_platform_data *pdata;\n\tstruct dwapb_port_property *pp;\n\tint nports;\n\tint i;\n\n\tnports = device_get_child_node_count(dev);\n\tif (nports == 0)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->properties = devm_kcalloc(dev, nports, sizeof(*pp), GFP_KERNEL);\n\tif (!pdata->properties)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->nports = nports;\n\n\ti = 0;\n\tdevice_for_each_child_node(dev, fwnode)  {\n\t\tpp = &pdata->properties[i++];\n\t\tpp->fwnode = fwnode;\n\n\t\tif (fwnode_property_read_u32(fwnode, \"reg\", &pp->idx) ||\n\t\t    pp->idx >= DWAPB_MAX_PORTS) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"missing/invalid port index for port%d\\n\", i);\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tif (fwnode_property_read_u32(fwnode, \"ngpios\", &pp->ngpio) &&\n\t\t    fwnode_property_read_u32(fwnode, \"snps,nr-gpios\", &pp->ngpio)) {\n\t\t\tdev_info(dev,\n\t\t\t\t \"failed to get number of gpios for port%d\\n\",\n\t\t\t\t i);\n\t\t\tpp->ngpio = DWAPB_MAX_GPIOS;\n\t\t}\n\n\t\tpp->gpio_base\t= -1;\n\n\t\t \n\t\tif (is_software_node(fwnode))\n\t\t\tfwnode_property_read_u32(fwnode, \"gpio-base\", &pp->gpio_base);\n\n\t\t \n\t\tif (pp->idx == 0)\n\t\t\tdwapb_get_irq(dev, fwnode, pp);\n\t}\n\n\treturn pdata;\n}\n\nstatic void dwapb_assert_reset(void *data)\n{\n\tstruct dwapb_gpio *gpio = data;\n\n\treset_control_assert(gpio->rst);\n}\n\nstatic int dwapb_get_reset(struct dwapb_gpio *gpio)\n{\n\tint err;\n\n\tgpio->rst = devm_reset_control_get_optional_shared(gpio->dev, NULL);\n\tif (IS_ERR(gpio->rst))\n\t\treturn dev_err_probe(gpio->dev, PTR_ERR(gpio->rst),\n\t\t\t\t     \"Cannot get reset descriptor\\n\");\n\n\terr = reset_control_deassert(gpio->rst);\n\tif (err) {\n\t\tdev_err(gpio->dev, \"Cannot deassert reset lane\\n\");\n\t\treturn err;\n\t}\n\n\treturn devm_add_action_or_reset(gpio->dev, dwapb_assert_reset, gpio);\n}\n\nstatic void dwapb_disable_clks(void *data)\n{\n\tstruct dwapb_gpio *gpio = data;\n\n\tclk_bulk_disable_unprepare(DWAPB_NR_CLOCKS, gpio->clks);\n}\n\nstatic int dwapb_get_clks(struct dwapb_gpio *gpio)\n{\n\tint err;\n\n\t \n\tgpio->clks[0].id = \"bus\";\n\tgpio->clks[1].id = \"db\";\n\terr = devm_clk_bulk_get_optional(gpio->dev, DWAPB_NR_CLOCKS,\n\t\t\t\t\t gpio->clks);\n\tif (err)\n\t\treturn dev_err_probe(gpio->dev, err,\n\t\t\t\t     \"Cannot get APB/Debounce clocks\\n\");\n\n\terr = clk_bulk_prepare_enable(DWAPB_NR_CLOCKS, gpio->clks);\n\tif (err) {\n\t\tdev_err(gpio->dev, \"Cannot enable APB/Debounce clocks\\n\");\n\t\treturn err;\n\t}\n\n\treturn devm_add_action_or_reset(gpio->dev, dwapb_disable_clks, gpio);\n}\n\nstatic const struct of_device_id dwapb_of_match[] = {\n\t{ .compatible = \"snps,dw-apb-gpio\", .data = (void *)GPIO_REG_OFFSET_V1},\n\t{ .compatible = \"apm,xgene-gpio-v2\", .data = (void *)GPIO_REG_OFFSET_V2},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dwapb_of_match);\n\nstatic const struct acpi_device_id dwapb_acpi_match[] = {\n\t{\"HISI0181\", GPIO_REG_OFFSET_V1},\n\t{\"APMC0D07\", GPIO_REG_OFFSET_V1},\n\t{\"APMC0D81\", GPIO_REG_OFFSET_V2},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, dwapb_acpi_match);\n\nstatic int dwapb_gpio_probe(struct platform_device *pdev)\n{\n\tunsigned int i;\n\tstruct dwapb_gpio *gpio;\n\tint err;\n\tstruct dwapb_platform_data *pdata;\n\tstruct device *dev = &pdev->dev;\n\n\tpdata = dwapb_gpio_get_pdata(dev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\n\tgpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tgpio->dev = &pdev->dev;\n\tgpio->nr_ports = pdata->nports;\n\n\terr = dwapb_get_reset(gpio);\n\tif (err)\n\t\treturn err;\n\n\tgpio->ports = devm_kcalloc(&pdev->dev, gpio->nr_ports,\n\t\t\t\t   sizeof(*gpio->ports), GFP_KERNEL);\n\tif (!gpio->ports)\n\t\treturn -ENOMEM;\n\n\tgpio->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gpio->regs))\n\t\treturn PTR_ERR(gpio->regs);\n\n\terr = dwapb_get_clks(gpio);\n\tif (err)\n\t\treturn err;\n\n\tgpio->flags = (uintptr_t)device_get_match_data(dev);\n\n\tfor (i = 0; i < gpio->nr_ports; i++) {\n\t\terr = dwapb_gpio_add_port(gpio, &pdata->properties[i], i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, gpio);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int dwapb_gpio_suspend(struct device *dev)\n{\n\tstruct dwapb_gpio *gpio = dev_get_drvdata(dev);\n\tstruct gpio_chip *gc\t= &gpio->ports[0].gc;\n\tunsigned long flags;\n\tint i;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\tfor (i = 0; i < gpio->nr_ports; i++) {\n\t\tunsigned int offset;\n\t\tunsigned int idx = gpio->ports[i].idx;\n\t\tstruct dwapb_context *ctx = gpio->ports[i].ctx;\n\n\t\toffset = GPIO_SWPORTA_DDR + idx * GPIO_SWPORT_DDR_STRIDE;\n\t\tctx->dir = dwapb_read(gpio, offset);\n\n\t\toffset = GPIO_SWPORTA_DR + idx * GPIO_SWPORT_DR_STRIDE;\n\t\tctx->data = dwapb_read(gpio, offset);\n\n\t\toffset = GPIO_EXT_PORTA + idx * GPIO_EXT_PORT_STRIDE;\n\t\tctx->ext = dwapb_read(gpio, offset);\n\n\t\t \n\t\tif (idx == 0) {\n\t\t\tctx->int_mask\t= dwapb_read(gpio, GPIO_INTMASK);\n\t\t\tctx->int_en\t= dwapb_read(gpio, GPIO_INTEN);\n\t\t\tctx->int_pol\t= dwapb_read(gpio, GPIO_INT_POLARITY);\n\t\t\tctx->int_type\t= dwapb_read(gpio, GPIO_INTTYPE_LEVEL);\n\t\t\tctx->int_deb\t= dwapb_read(gpio, GPIO_PORTA_DEBOUNCE);\n\n\t\t\t \n\t\t\tdwapb_write(gpio, GPIO_INTMASK, ~ctx->wake_en);\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\n\tclk_bulk_disable_unprepare(DWAPB_NR_CLOCKS, gpio->clks);\n\n\treturn 0;\n}\n\nstatic int dwapb_gpio_resume(struct device *dev)\n{\n\tstruct dwapb_gpio *gpio = dev_get_drvdata(dev);\n\tstruct gpio_chip *gc\t= &gpio->ports[0].gc;\n\tunsigned long flags;\n\tint i, err;\n\n\terr = clk_bulk_prepare_enable(DWAPB_NR_CLOCKS, gpio->clks);\n\tif (err) {\n\t\tdev_err(gpio->dev, \"Cannot reenable APB/Debounce clocks\\n\");\n\t\treturn err;\n\t}\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\tfor (i = 0; i < gpio->nr_ports; i++) {\n\t\tunsigned int offset;\n\t\tunsigned int idx = gpio->ports[i].idx;\n\t\tstruct dwapb_context *ctx = gpio->ports[i].ctx;\n\n\t\toffset = GPIO_SWPORTA_DR + idx * GPIO_SWPORT_DR_STRIDE;\n\t\tdwapb_write(gpio, offset, ctx->data);\n\n\t\toffset = GPIO_SWPORTA_DDR + idx * GPIO_SWPORT_DDR_STRIDE;\n\t\tdwapb_write(gpio, offset, ctx->dir);\n\n\t\toffset = GPIO_EXT_PORTA + idx * GPIO_EXT_PORT_STRIDE;\n\t\tdwapb_write(gpio, offset, ctx->ext);\n\n\t\t \n\t\tif (idx == 0) {\n\t\t\tdwapb_write(gpio, GPIO_INTTYPE_LEVEL, ctx->int_type);\n\t\t\tdwapb_write(gpio, GPIO_INT_POLARITY, ctx->int_pol);\n\t\t\tdwapb_write(gpio, GPIO_PORTA_DEBOUNCE, ctx->int_deb);\n\t\t\tdwapb_write(gpio, GPIO_INTEN, ctx->int_en);\n\t\t\tdwapb_write(gpio, GPIO_INTMASK, ctx->int_mask);\n\n\t\t\t \n\t\t\tdwapb_write(gpio, GPIO_PORTA_EOI, 0xffffffff);\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(dwapb_gpio_pm_ops, dwapb_gpio_suspend,\n\t\t\t dwapb_gpio_resume);\n\nstatic struct platform_driver dwapb_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DWAPB_DRIVER_NAME,\n\t\t.pm\t= &dwapb_gpio_pm_ops,\n\t\t.of_match_table = dwapb_of_match,\n\t\t.acpi_match_table = dwapb_acpi_match,\n\t},\n\t.probe\t\t= dwapb_gpio_probe,\n};\n\nmodule_platform_driver(dwapb_gpio_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jamie Iles\");\nMODULE_DESCRIPTION(\"Synopsys DesignWare APB GPIO driver\");\nMODULE_ALIAS(\"platform:\" DWAPB_DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}