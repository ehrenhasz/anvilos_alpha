{
  "module_name": "gpio-xlp.c",
  "hash_id": "8a327421157706069af43c9b8f7fd32251bedf0eb4180d15a2e75ae0c068c5f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-xlp.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/acpi.h>\n\n \n#define GPIO_9XX_BYTESWAP\t0X00\n#define GPIO_9XX_CTRL\t\t0X04\n#define GPIO_9XX_OUTPUT_EN\t0x14\n#define GPIO_9XX_PADDRV\t\t0x24\n \n#define GPIO_9XX_INT_EN00\t0x44\n#define GPIO_9XX_INT_EN10\t0x54\n#define GPIO_9XX_INT_EN20\t0x64\n#define GPIO_9XX_INT_EN30\t0x74\n#define GPIO_9XX_INT_POL\t0x104\n#define GPIO_9XX_INT_TYPE\t0x114\n#define GPIO_9XX_INT_STAT\t0x124\n\n \n#define XLP_GPIO_IRQ_TYPE_LVL\t0x0\n#define XLP_GPIO_IRQ_TYPE_EDGE\t0x1\n\n \n#define XLP_GPIO_IRQ_POL_HIGH\t0x0\n#define XLP_GPIO_IRQ_POL_LOW\t0x1\n\n#define XLP_GPIO_REGSZ\t\t32\n#define XLP_GPIO_IRQ_BASE\t768\n#define XLP_MAX_NR_GPIO\t\t96\n\nstruct xlp_gpio_priv {\n\tstruct gpio_chip chip;\n\tDECLARE_BITMAP(gpio_enabled_mask, XLP_MAX_NR_GPIO);\n\tvoid __iomem *gpio_intr_en;\t \n\tvoid __iomem *gpio_intr_stat;\t \n\tvoid __iomem *gpio_intr_type;\t \n\tvoid __iomem *gpio_intr_pol;\t \n\tvoid __iomem *gpio_out_en;\t \n\tvoid __iomem *gpio_paddrv;\t \n\tspinlock_t lock;\n};\n\nstatic int xlp_gpio_get_reg(void __iomem *addr, unsigned gpio)\n{\n\tu32 pos, regset;\n\n\tpos = gpio % XLP_GPIO_REGSZ;\n\tregset = (gpio / XLP_GPIO_REGSZ) * 4;\n\treturn !!(readl(addr + regset) & BIT(pos));\n}\n\nstatic void xlp_gpio_set_reg(void __iomem *addr, unsigned gpio, int state)\n{\n\tu32 value, pos, regset;\n\n\tpos = gpio % XLP_GPIO_REGSZ;\n\tregset = (gpio / XLP_GPIO_REGSZ) * 4;\n\tvalue = readl(addr + regset);\n\n\tif (state)\n\t\tvalue |= BIT(pos);\n\telse\n\t\tvalue &= ~BIT(pos);\n\n\twritel(value, addr + regset);\n}\n\nstatic void xlp_gpio_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc  = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void xlp_gpio_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc  = irq_data_get_irq_chip_data(d);\n\tstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\txlp_gpio_set_reg(priv->gpio_intr_en, d->hwirq, 0x0);\n\t__clear_bit(d->hwirq, priv->gpio_enabled_mask);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void xlp_gpio_irq_mask_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc  = irq_data_get_irq_chip_data(d);\n\tstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\txlp_gpio_set_reg(priv->gpio_intr_en, d->hwirq, 0x0);\n\txlp_gpio_set_reg(priv->gpio_intr_stat, d->hwirq, 0x1);\n\t__clear_bit(d->hwirq, priv->gpio_enabled_mask);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void xlp_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc  = irq_data_get_irq_chip_data(d);\n\tstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\txlp_gpio_set_reg(priv->gpio_intr_en, d->hwirq, 0x1);\n\t__set_bit(d->hwirq, priv->gpio_enabled_mask);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int xlp_gpio_set_irq_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc  = irq_data_get_irq_chip_data(d);\n\tstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\n\tint pol, irq_type;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tirq_type = XLP_GPIO_IRQ_TYPE_EDGE;\n\t\tpol = XLP_GPIO_IRQ_POL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tirq_type = XLP_GPIO_IRQ_TYPE_EDGE;\n\t\tpol = XLP_GPIO_IRQ_POL_LOW;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tirq_type = XLP_GPIO_IRQ_TYPE_LVL;\n\t\tpol = XLP_GPIO_IRQ_POL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tirq_type = XLP_GPIO_IRQ_TYPE_LVL;\n\t\tpol = XLP_GPIO_IRQ_POL_LOW;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\txlp_gpio_set_reg(priv->gpio_intr_type, d->hwirq, irq_type);\n\txlp_gpio_set_reg(priv->gpio_intr_pol, d->hwirq, pol);\n\n\treturn 0;\n}\n\nstatic struct irq_chip xlp_gpio_irq_chip = {\n\t.name\t\t= \"XLP-GPIO\",\n\t.irq_mask_ack\t= xlp_gpio_irq_mask_ack,\n\t.irq_enable\t= xlp_gpio_irq_enable,\n\t.irq_disable\t= xlp_gpio_irq_disable,\n\t.irq_set_type\t= xlp_gpio_set_irq_type,\n\t.irq_unmask\t= xlp_gpio_irq_unmask,\n\t.flags\t\t= IRQCHIP_ONESHOT_SAFE | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void xlp_gpio_generic_handler(struct irq_desc *desc)\n{\n\tstruct xlp_gpio_priv *priv = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\tint gpio, regoff;\n\tu32 gpio_stat;\n\n\tregoff = -1;\n\tgpio_stat = 0;\n\n\tchained_irq_enter(irqchip, desc);\n\tfor_each_set_bit(gpio, priv->gpio_enabled_mask, XLP_MAX_NR_GPIO) {\n\t\tif (regoff != gpio / XLP_GPIO_REGSZ) {\n\t\t\tregoff = gpio / XLP_GPIO_REGSZ;\n\t\t\tgpio_stat = readl(priv->gpio_intr_stat + regoff * 4);\n\t\t}\n\n\t\tif (gpio_stat & BIT(gpio % XLP_GPIO_REGSZ))\n\t\t\tgeneric_handle_domain_irq(priv->chip.irq.domain, gpio);\n\t}\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic int xlp_gpio_dir_output(struct gpio_chip *gc, unsigned gpio, int state)\n{\n\tstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\n\n\tBUG_ON(gpio >= gc->ngpio);\n\txlp_gpio_set_reg(priv->gpio_out_en, gpio, 0x1);\n\n\treturn 0;\n}\n\nstatic int xlp_gpio_dir_input(struct gpio_chip *gc, unsigned gpio)\n{\n\tstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\n\n\tBUG_ON(gpio >= gc->ngpio);\n\txlp_gpio_set_reg(priv->gpio_out_en, gpio, 0x0);\n\n\treturn 0;\n}\n\nstatic int xlp_gpio_get(struct gpio_chip *gc, unsigned gpio)\n{\n\tstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\n\n\tBUG_ON(gpio >= gc->ngpio);\n\treturn xlp_gpio_get_reg(priv->gpio_paddrv, gpio);\n}\n\nstatic void xlp_gpio_set(struct gpio_chip *gc, unsigned gpio, int state)\n{\n\tstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\n\n\tBUG_ON(gpio >= gc->ngpio);\n\txlp_gpio_set_reg(priv->gpio_paddrv, gpio, state);\n}\n\nstatic int xlp_gpio_probe(struct platform_device *pdev)\n{\n\tstruct gpio_chip *gc;\n\tstruct gpio_irq_chip *girq;\n\tstruct xlp_gpio_priv *priv;\n\tvoid __iomem *gpio_base;\n\tint irq, err;\n\n\tpriv = devm_kzalloc(&pdev->dev,\tsizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tgpio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gpio_base))\n\t\treturn PTR_ERR(gpio_base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tpriv->gpio_out_en = gpio_base + GPIO_9XX_OUTPUT_EN;\n\tpriv->gpio_paddrv = gpio_base + GPIO_9XX_PADDRV;\n\tpriv->gpio_intr_stat = gpio_base + GPIO_9XX_INT_STAT;\n\tpriv->gpio_intr_type = gpio_base + GPIO_9XX_INT_TYPE;\n\tpriv->gpio_intr_pol = gpio_base + GPIO_9XX_INT_POL;\n\tpriv->gpio_intr_en = gpio_base + GPIO_9XX_INT_EN00;\n\n\tbitmap_zero(priv->gpio_enabled_mask, XLP_MAX_NR_GPIO);\n\n\tgc = &priv->chip;\n\n\tgc->owner = THIS_MODULE;\n\tgc->label = dev_name(&pdev->dev);\n\tgc->base = 0;\n\tgc->parent = &pdev->dev;\n\tgc->ngpio = 70;\n\tgc->direction_output = xlp_gpio_dir_output;\n\tgc->direction_input = xlp_gpio_dir_input;\n\tgc->set = xlp_gpio_set;\n\tgc->get = xlp_gpio_get;\n\n\tspin_lock_init(&priv->lock);\n\n\tgirq = &gc->irq;\n\tgpio_irq_chip_set_chip(girq, &xlp_gpio_irq_chip);\n\tgirq->parent_handler = xlp_gpio_generic_handler;\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(&pdev->dev, 1,\n\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t     GFP_KERNEL);\n\tif (!girq->parents)\n\t\treturn -ENOMEM;\n\tgirq->parents[0] = irq;\n\tgirq->first = 0;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_level_irq;\n\n\terr = gpiochip_add_data(gc, priv);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_info(&pdev->dev, \"registered %d GPIOs\\n\", gc->ngpio);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id xlp_gpio_acpi_match[] = {\n\t{ \"BRCM9006\" },\n\t{ \"CAV9006\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, xlp_gpio_acpi_match);\n#endif\n\nstatic struct platform_driver xlp_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"xlp-gpio\",\n\t\t.acpi_match_table = ACPI_PTR(xlp_gpio_acpi_match),\n\t},\n\t.probe\t\t= xlp_gpio_probe,\n};\nmodule_platform_driver(xlp_gpio_driver);\n\nMODULE_AUTHOR(\"Kamlakant Patel <kamlakant.patel@broadcom.com>\");\nMODULE_AUTHOR(\"Ganesan Ramalingam <ganesanr@broadcom.com>\");\nMODULE_DESCRIPTION(\"Netlogic XLP GPIO Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}