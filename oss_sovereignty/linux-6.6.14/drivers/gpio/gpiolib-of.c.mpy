{
  "module_name": "gpiolib-of.c",
  "hash_id": "2cbd7ecc9b6b872baf0159516dca06a707ad15b2c318de1c844b37b6a723ff4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpiolib-of.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_gpio.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>\n\n#include \"gpiolib.h\"\n#include \"gpiolib-of.h\"\n\n \nenum of_gpio_flags {\n\tOF_GPIO_ACTIVE_LOW = 0x1,\n\tOF_GPIO_SINGLE_ENDED = 0x2,\n\tOF_GPIO_OPEN_DRAIN = 0x4,\n\tOF_GPIO_TRANSITORY = 0x8,\n\tOF_GPIO_PULL_UP = 0x10,\n\tOF_GPIO_PULL_DOWN = 0x20,\n\tOF_GPIO_PULL_DISABLE = 0x40,\n};\n\n \nstatic int of_gpio_named_count(const struct device_node *np,\n\t\t\t       const char *propname)\n{\n\treturn of_count_phandle_with_args(np, propname, \"#gpio-cells\");\n}\n\n \nstatic int of_gpio_spi_cs_get_count(struct device *dev, const char *con_id)\n{\n\tstruct device_node *np = dev->of_node;\n\n\tif (!IS_ENABLED(CONFIG_SPI_MASTER))\n\t\treturn 0;\n\tif (!con_id || strcmp(con_id, \"cs\"))\n\t\treturn 0;\n\tif (!of_device_is_compatible(np, \"fsl,spi\") &&\n\t    !of_device_is_compatible(np, \"aeroflexgaisler,spictrl\") &&\n\t    !of_device_is_compatible(np, \"ibm,ppc4xx-spi\"))\n\t\treturn 0;\n\treturn of_gpio_named_count(np, \"gpios\");\n}\n\nint of_gpio_get_count(struct device *dev, const char *con_id)\n{\n\tint ret;\n\tchar propname[32];\n\tunsigned int i;\n\n\tret = of_gpio_spi_cs_get_count(dev, con_id);\n\tif (ret > 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {\n\t\tif (con_id)\n\t\t\tsnprintf(propname, sizeof(propname), \"%s-%s\",\n\t\t\t\t con_id, gpio_suffixes[i]);\n\t\telse\n\t\t\tsnprintf(propname, sizeof(propname), \"%s\",\n\t\t\t\t gpio_suffixes[i]);\n\n\t\tret = of_gpio_named_count(dev->of_node, propname);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t}\n\treturn ret ? ret : -ENOENT;\n}\n\nstatic int of_gpiochip_match_node_and_xlate(struct gpio_chip *chip, void *data)\n{\n\tstruct of_phandle_args *gpiospec = data;\n\n\treturn device_match_of_node(&chip->gpiodev->dev, gpiospec->np) &&\n\t\t\t\tchip->of_xlate &&\n\t\t\t\tchip->of_xlate(chip, gpiospec, NULL) >= 0;\n}\n\nstatic struct gpio_chip *of_find_gpiochip_by_xlate(\n\t\t\t\t\tstruct of_phandle_args *gpiospec)\n{\n\treturn gpiochip_find(gpiospec, of_gpiochip_match_node_and_xlate);\n}\n\nstatic struct gpio_desc *of_xlate_and_get_gpiod_flags(struct gpio_chip *chip,\n\t\t\t\t\tstruct of_phandle_args *gpiospec,\n\t\t\t\t\tenum of_gpio_flags *flags)\n{\n\tint ret;\n\n\tif (chip->of_gpio_n_cells != gpiospec->args_count)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tret = chip->of_xlate(chip, gpiospec, flags);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\treturn gpiochip_get_desc(chip, ret);\n}\n\n \nstatic void of_gpio_quirk_polarity(const struct device_node *np,\n\t\t\t\t   bool active_high,\n\t\t\t\t   enum of_gpio_flags *flags)\n{\n\tif (active_high) {\n\t\tif (*flags & OF_GPIO_ACTIVE_LOW) {\n\t\t\tpr_warn(\"%s GPIO handle specifies active low - ignored\\n\",\n\t\t\t\tof_node_full_name(np));\n\t\t\t*flags &= ~OF_GPIO_ACTIVE_LOW;\n\t\t}\n\t} else {\n\t\tif (!(*flags & OF_GPIO_ACTIVE_LOW))\n\t\t\tpr_info(\"%s enforce active low on GPIO handle\\n\",\n\t\t\t\tof_node_full_name(np));\n\t\t*flags |= OF_GPIO_ACTIVE_LOW;\n\t}\n}\n\n \nstatic void of_gpio_try_fixup_polarity(const struct device_node *np,\n\t\t\t\t       const char *propname,\n\t\t\t\t       enum of_gpio_flags *flags)\n{\n\tstatic const struct {\n\t\tconst char *compatible;\n\t\tconst char *propname;\n\t\tbool active_high;\n\t} gpios[] = {\n#if !IS_ENABLED(CONFIG_LCD_HX8357)\n\t\t \n\t\t{ \"himax,hx8357\",\t\"gpios-reset\",\tfalse },\n\t\t{ \"himax,hx8369\",\t\"gpios-reset\",\tfalse },\n#endif\n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(gpios); i++) {\n\t\tif (of_device_is_compatible(np, gpios[i].compatible) &&\n\t\t    !strcmp(propname, gpios[i].propname)) {\n\t\t\tof_gpio_quirk_polarity(np, gpios[i].active_high, flags);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void of_gpio_set_polarity_by_property(const struct device_node *np,\n\t\t\t\t\t     const char *propname,\n\t\t\t\t\t     enum of_gpio_flags *flags)\n{\n\tconst struct device_node *np_compat = np;\n\tconst struct device_node *np_propname = np;\n\tstatic const struct {\n\t\tconst char *compatible;\n\t\tconst char *gpio_propname;\n\t\tconst char *polarity_propname;\n\t} gpios[] = {\n#if IS_ENABLED(CONFIG_FEC)\n\t\t \n\t\t{ \"fsl,imx25-fec\",   \"phy-reset-gpios\", \"phy-reset-active-high\" },\n\t\t{ \"fsl,imx27-fec\",   \"phy-reset-gpios\", \"phy-reset-active-high\" },\n\t\t{ \"fsl,imx28-fec\",   \"phy-reset-gpios\", \"phy-reset-active-high\" },\n\t\t{ \"fsl,imx6q-fec\",   \"phy-reset-gpios\", \"phy-reset-active-high\" },\n\t\t{ \"fsl,mvf600-fec\",  \"phy-reset-gpios\", \"phy-reset-active-high\" },\n\t\t{ \"fsl,imx6sx-fec\",  \"phy-reset-gpios\", \"phy-reset-active-high\" },\n\t\t{ \"fsl,imx6ul-fec\",  \"phy-reset-gpios\", \"phy-reset-active-high\" },\n\t\t{ \"fsl,imx8mq-fec\",  \"phy-reset-gpios\", \"phy-reset-active-high\" },\n\t\t{ \"fsl,imx8qm-fec\",  \"phy-reset-gpios\", \"phy-reset-active-high\" },\n\t\t{ \"fsl,s32v234-fec\", \"phy-reset-gpios\", \"phy-reset-active-high\" },\n#endif\n#if IS_ENABLED(CONFIG_PCI_IMX6)\n\t\t{ \"fsl,imx6q-pcie\",  \"reset-gpio\", \"reset-gpio-active-high\" },\n\t\t{ \"fsl,imx6sx-pcie\", \"reset-gpio\", \"reset-gpio-active-high\" },\n\t\t{ \"fsl,imx6qp-pcie\", \"reset-gpio\", \"reset-gpio-active-high\" },\n\t\t{ \"fsl,imx7d-pcie\",  \"reset-gpio\", \"reset-gpio-active-high\" },\n\t\t{ \"fsl,imx8mq-pcie\", \"reset-gpio\", \"reset-gpio-active-high\" },\n\t\t{ \"fsl,imx8mm-pcie\", \"reset-gpio\", \"reset-gpio-active-high\" },\n\t\t{ \"fsl,imx8mp-pcie\", \"reset-gpio\", \"reset-gpio-active-high\" },\n#endif\n\n\t\t \n#if IS_ENABLED(CONFIG_REGULATOR_FIXED_VOLTAGE)\n\t\t{ \"regulator-fixed\",   \"gpios\",        \"enable-active-high\" },\n\t\t{ \"regulator-fixed\",   \"gpio\",         \"enable-active-high\" },\n\t\t{ \"reg-fixed-voltage\", \"gpios\",        \"enable-active-high\" },\n\t\t{ \"reg-fixed-voltage\", \"gpio\",         \"enable-active-high\" },\n#endif\n#if IS_ENABLED(CONFIG_REGULATOR_GPIO)\n\t\t{ \"regulator-gpio\",    \"enable-gpio\",  \"enable-active-high\" },\n\t\t{ \"regulator-gpio\",    \"enable-gpios\", \"enable-active-high\" },\n#endif\n#if IS_ENABLED(CONFIG_MMC_ATMELMCI)\n\t\t{ \"atmel,hsmci\",       \"cd-gpios\",     \"cd-inverted\" },\n#endif\n\t};\n\tunsigned int i;\n\tbool active_high;\n\n#if IS_ENABLED(CONFIG_MMC_ATMELMCI)\n\t \n\tif (of_device_is_compatible(np->parent, \"atmel,hsmci\")) {\n\t\tnp_compat = np->parent;\n\t\tnp_propname = np;\n\t}\n#endif\n\n\tfor (i = 0; i < ARRAY_SIZE(gpios); i++) {\n\t\tif (of_device_is_compatible(np_compat, gpios[i].compatible) &&\n\t\t    !strcmp(propname, gpios[i].gpio_propname)) {\n\t\t\tactive_high = of_property_read_bool(np_propname,\n\t\t\t\t\t\tgpios[i].polarity_propname);\n\t\t\tof_gpio_quirk_polarity(np, active_high, flags);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void of_gpio_flags_quirks(const struct device_node *np,\n\t\t\t\t const char *propname,\n\t\t\t\t enum of_gpio_flags *flags,\n\t\t\t\t int index)\n{\n\tof_gpio_try_fixup_polarity(np, propname, flags);\n\tof_gpio_set_polarity_by_property(np, propname, flags);\n\n\t \n\tif (IS_ENABLED(CONFIG_REGULATOR) &&\n\t    of_device_is_compatible(np, \"reg-fixed-voltage\") &&\n\t    of_property_read_bool(np, \"gpio-open-drain\")) {\n\t\t*flags |= (OF_GPIO_SINGLE_ENDED | OF_GPIO_OPEN_DRAIN);\n\t\tpr_info(\"%s uses legacy open drain flag - update the DTS if you can\\n\",\n\t\t\tof_node_full_name(np));\n\t}\n\n\t \n\tif (IS_ENABLED(CONFIG_SPI_MASTER) && !strcmp(propname, \"cs-gpios\") &&\n\t    of_property_read_bool(np, \"cs-gpios\")) {\n\t\tstruct device_node *child;\n\t\tu32 cs;\n\t\tint ret;\n\n\t\tfor_each_child_of_node(np, child) {\n\t\t\tret = of_property_read_u32(child, \"reg\", &cs);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\t\t\tif (cs == index) {\n\t\t\t\t \n\t\t\t\tbool active_high = of_property_read_bool(child,\n\t\t\t\t\t\t\t\t\"spi-cs-high\");\n\t\t\t\tof_gpio_quirk_polarity(child, active_high,\n\t\t\t\t\t\t       flags);\n\t\t\t\tof_node_put(child);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (IS_ENABLED(CONFIG_STMMAC_ETH) &&\n\t    !strcmp(propname, \"snps,reset-gpio\") &&\n\t    of_property_read_bool(np, \"snps,reset-active-low\"))\n\t\t*flags |= OF_GPIO_ACTIVE_LOW;\n}\n\n \nstatic struct gpio_desc *of_get_named_gpiod_flags(const struct device_node *np,\n\t\t     const char *propname, int index, enum of_gpio_flags *flags)\n{\n\tstruct of_phandle_args gpiospec;\n\tstruct gpio_chip *chip;\n\tstruct gpio_desc *desc;\n\tint ret;\n\n\tret = of_parse_phandle_with_args_map(np, propname, \"gpio\", index,\n\t\t\t\t\t     &gpiospec);\n\tif (ret) {\n\t\tpr_debug(\"%s: can't parse '%s' property of node '%pOF[%d]'\\n\",\n\t\t\t__func__, propname, np, index);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tchip = of_find_gpiochip_by_xlate(&gpiospec);\n\tif (!chip) {\n\t\tdesc = ERR_PTR(-EPROBE_DEFER);\n\t\tgoto out;\n\t}\n\n\tdesc = of_xlate_and_get_gpiod_flags(chip, &gpiospec, flags);\n\tif (IS_ERR(desc))\n\t\tgoto out;\n\n\tif (flags)\n\t\tof_gpio_flags_quirks(np, propname, flags, index);\n\n\tpr_debug(\"%s: parsed '%s' property of node '%pOF[%d]' - status (%d)\\n\",\n\t\t __func__, propname, np, index,\n\t\t PTR_ERR_OR_ZERO(desc));\n\nout:\n\tof_node_put(gpiospec.np);\n\n\treturn desc;\n}\n\n \nint of_get_named_gpio(const struct device_node *np, const char *propname,\n\t\t      int index)\n{\n\tstruct gpio_desc *desc;\n\n\tdesc = of_get_named_gpiod_flags(np, propname, index, NULL);\n\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\telse\n\t\treturn desc_to_gpio(desc);\n}\nEXPORT_SYMBOL_GPL(of_get_named_gpio);\n\n \nstatic unsigned long of_convert_gpio_flags(enum of_gpio_flags flags)\n{\n\tunsigned long lflags = GPIO_LOOKUP_FLAGS_DEFAULT;\n\n\tif (flags & OF_GPIO_ACTIVE_LOW)\n\t\tlflags |= GPIO_ACTIVE_LOW;\n\n\tif (flags & OF_GPIO_SINGLE_ENDED) {\n\t\tif (flags & OF_GPIO_OPEN_DRAIN)\n\t\t\tlflags |= GPIO_OPEN_DRAIN;\n\t\telse\n\t\t\tlflags |= GPIO_OPEN_SOURCE;\n\t}\n\n\tif (flags & OF_GPIO_TRANSITORY)\n\t\tlflags |= GPIO_TRANSITORY;\n\n\tif (flags & OF_GPIO_PULL_UP)\n\t\tlflags |= GPIO_PULL_UP;\n\n\tif (flags & OF_GPIO_PULL_DOWN)\n\t\tlflags |= GPIO_PULL_DOWN;\n\n\tif (flags & OF_GPIO_PULL_DISABLE)\n\t\tlflags |= GPIO_PULL_DISABLE;\n\n\treturn lflags;\n}\n\nstatic struct gpio_desc *of_find_gpio_rename(struct device_node *np,\n\t\t\t\t\t     const char *con_id,\n\t\t\t\t\t     unsigned int idx,\n\t\t\t\t\t     enum of_gpio_flags *of_flags)\n{\n\tstatic const struct of_rename_gpio {\n\t\tconst char *con_id;\n\t\tconst char *legacy_id;\t \n\t\t \n\t\tconst char *compatible;\n\t} gpios[] = {\n#if !IS_ENABLED(CONFIG_LCD_HX8357)\n\t\t \n\t\t{ \"reset\",\t\"gpios-reset\",\t\"himax,hx8357\" },\n\t\t{ \"reset\",\t\"gpios-reset\",\t\"himax,hx8369\" },\n#endif\n#if IS_ENABLED(CONFIG_MFD_ARIZONA)\n\t\t{ \"wlf,reset\",\tNULL,\t\tNULL },\n#endif\n#if IS_ENABLED(CONFIG_RTC_DRV_MOXART)\n\t\t{ \"rtc-data\",\t\"gpio-rtc-data\",\t\"moxa,moxart-rtc\" },\n\t\t{ \"rtc-sclk\",\t\"gpio-rtc-sclk\",\t\"moxa,moxart-rtc\" },\n\t\t{ \"rtc-reset\",\t\"gpio-rtc-reset\",\t\"moxa,moxart-rtc\" },\n#endif\n#if IS_ENABLED(CONFIG_NFC_MRVL_I2C)\n\t\t{ \"reset\",\t\"reset-n-io\",\t\"marvell,nfc-i2c\" },\n#endif\n#if IS_ENABLED(CONFIG_NFC_MRVL_SPI)\n\t\t{ \"reset\",\t\"reset-n-io\",\t\"marvell,nfc-spi\" },\n#endif\n#if IS_ENABLED(CONFIG_NFC_MRVL_UART)\n\t\t{ \"reset\",\t\"reset-n-io\",\t\"marvell,nfc-uart\" },\n\t\t{ \"reset\",\t\"reset-n-io\",\t\"mrvl,nfc-uart\" },\n#endif\n#if !IS_ENABLED(CONFIG_PCI_LANTIQ)\n\t\t \n\t\t{ \"reset\",\t\"gpios-reset\",\t\"lantiq,pci-xway\" },\n#endif\n\n\t\t \n#if IS_ENABLED(CONFIG_REGULATOR_ARIZONA_LDO1)\n\t\t{ \"wlf,ldoena\",  NULL,\t\tNULL },  \n#endif\n#if IS_ENABLED(CONFIG_REGULATOR_WM8994)\n\t\t{ \"wlf,ldo1ena\", NULL,\t\tNULL },  \n\t\t{ \"wlf,ldo2ena\", NULL,\t\tNULL },  \n#endif\n\n#if IS_ENABLED(CONFIG_SND_SOC_CS42L56)\n\t\t{ \"reset\",\t\"cirrus,gpio-nreset\",\t\"cirrus,cs42l56\" },\n#endif\n#if IS_ENABLED(CONFIG_SND_SOC_MT2701_CS42448)\n\t\t{ \"i2s1-in-sel-gpio1\",\tNULL,\t\"mediatek,mt2701-cs42448-machine\" },\n\t\t{ \"i2s1-in-sel-gpio2\",\tNULL,\t\"mediatek,mt2701-cs42448-machine\" },\n#endif\n#if IS_ENABLED(CONFIG_SND_SOC_TLV320AIC3X)\n\t\t{ \"reset\",\t\"gpio-reset\",\t\"ti,tlv320aic3x\" },\n\t\t{ \"reset\",\t\"gpio-reset\",\t\"ti,tlv320aic33\" },\n\t\t{ \"reset\",\t\"gpio-reset\",\t\"ti,tlv320aic3007\" },\n\t\t{ \"reset\",\t\"gpio-reset\",\t\"ti,tlv320aic3104\" },\n\t\t{ \"reset\",\t\"gpio-reset\",\t\"ti,tlv320aic3106\" },\n#endif\n#if IS_ENABLED(CONFIG_SPI_GPIO)\n\t\t \n\t\t{ \"miso\",\t\"gpio-miso\",\t\"spi-gpio\" },\n\t\t{ \"mosi\",\t\"gpio-mosi\",\t\"spi-gpio\" },\n\t\t{ \"sck\",\t\"gpio-sck\",\t\"spi-gpio\" },\n#endif\n\n\t\t \n#if IS_ENABLED(CONFIG_SPI_FSL_SPI)\n\t\t{ \"cs\",\t\t\"gpios\",\t\"fsl,spi\" },\n\t\t{ \"cs\",\t\t\"gpios\",\t\"aeroflexgaisler,spictrl\" },\n#endif\n#if IS_ENABLED(CONFIG_SPI_PPC4xx)\n\t\t{ \"cs\",\t\t\"gpios\",\t\"ibm,ppc4xx-spi\" },\n#endif\n\n#if IS_ENABLED(CONFIG_TYPEC_FUSB302)\n\t\t \n\t\t{ \"fcs,int_n\",\tNULL,\t\t\"fcs,fusb302\" },\n#endif\n\t};\n\tstruct gpio_desc *desc;\n\tconst char *legacy_id;\n\tunsigned int i;\n\n\tif (!con_id)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tfor (i = 0; i < ARRAY_SIZE(gpios); i++) {\n\t\tif (strcmp(con_id, gpios[i].con_id))\n\t\t\tcontinue;\n\n\t\tif (gpios[i].compatible &&\n\t\t    !of_device_is_compatible(np, gpios[i].compatible))\n\t\t\tcontinue;\n\n\t\tlegacy_id = gpios[i].legacy_id ?: gpios[i].con_id;\n\t\tdesc = of_get_named_gpiod_flags(np, legacy_id, idx, of_flags);\n\t\tif (!gpiod_not_found(desc)) {\n\t\t\tpr_info(\"%s uses legacy gpio name '%s' instead of '%s-gpios'\\n\",\n\t\t\t\tof_node_full_name(np), legacy_id, con_id);\n\t\t\treturn desc;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct gpio_desc *of_find_mt2701_gpio(struct device_node *np,\n\t\t\t\t\t     const char *con_id,\n\t\t\t\t\t     unsigned int idx,\n\t\t\t\t\t     enum of_gpio_flags *of_flags)\n{\n\tstruct gpio_desc *desc;\n\tconst char *legacy_id;\n\n\tif (!IS_ENABLED(CONFIG_SND_SOC_MT2701_CS42448))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (!of_device_is_compatible(np, \"mediatek,mt2701-cs42448-machine\"))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (!con_id || strcmp(con_id, \"i2s1-in-sel\"))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (idx == 0)\n\t\tlegacy_id = \"i2s1-in-sel-gpio1\";\n\telse if (idx == 1)\n\t\tlegacy_id = \"i2s1-in-sel-gpio2\";\n\telse\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdesc = of_get_named_gpiod_flags(np, legacy_id, 0, of_flags);\n\tif (!gpiod_not_found(desc))\n\t\tpr_info(\"%s is using legacy gpio name '%s' instead of '%s-gpios'\\n\",\n\t\t\tof_node_full_name(np), legacy_id, con_id);\n\n\treturn desc;\n}\n\ntypedef struct gpio_desc *(*of_find_gpio_quirk)(struct device_node *np,\n\t\t\t\t\t\tconst char *con_id,\n\t\t\t\t\t\tunsigned int idx,\n\t\t\t\t\t\tenum of_gpio_flags *of_flags);\nstatic const of_find_gpio_quirk of_find_gpio_quirks[] = {\n\tof_find_gpio_rename,\n\tof_find_mt2701_gpio,\n\tNULL\n};\n\nstruct gpio_desc *of_find_gpio(struct device_node *np, const char *con_id,\n\t\t\t       unsigned int idx, unsigned long *flags)\n{\n\tchar prop_name[32];  \n\tenum of_gpio_flags of_flags;\n\tconst of_find_gpio_quirk *q;\n\tstruct gpio_desc *desc;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {\n\t\tif (con_id)\n\t\t\tsnprintf(prop_name, sizeof(prop_name), \"%s-%s\", con_id,\n\t\t\t\t gpio_suffixes[i]);\n\t\telse\n\t\t\tsnprintf(prop_name, sizeof(prop_name), \"%s\",\n\t\t\t\t gpio_suffixes[i]);\n\n\t\tdesc = of_get_named_gpiod_flags(np, prop_name, idx, &of_flags);\n\n\t\tif (!gpiod_not_found(desc))\n\t\t\tbreak;\n\t}\n\n\t \n\tfor (q = of_find_gpio_quirks; gpiod_not_found(desc) && *q; q++)\n\t\tdesc = (*q)(np, con_id, idx, &of_flags);\n\n\tif (IS_ERR(desc))\n\t\treturn desc;\n\n\t*flags = of_convert_gpio_flags(of_flags);\n\n\treturn desc;\n}\n\n \nstatic struct gpio_desc *of_parse_own_gpio(struct device_node *np,\n\t\t\t\t\t   struct gpio_chip *chip,\n\t\t\t\t\t   unsigned int idx, const char **name,\n\t\t\t\t\t   unsigned long *lflags,\n\t\t\t\t\t   enum gpiod_flags *dflags)\n{\n\tstruct device_node *chip_np;\n\tenum of_gpio_flags xlate_flags;\n\tstruct of_phandle_args gpiospec;\n\tstruct gpio_desc *desc;\n\tunsigned int i;\n\tu32 tmp;\n\tint ret;\n\n\tchip_np = dev_of_node(&chip->gpiodev->dev);\n\tif (!chip_np)\n\t\treturn ERR_PTR(-EINVAL);\n\n\txlate_flags = 0;\n\t*lflags = GPIO_LOOKUP_FLAGS_DEFAULT;\n\t*dflags = GPIOD_ASIS;\n\n\tret = of_property_read_u32(chip_np, \"#gpio-cells\", &tmp);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tgpiospec.np = chip_np;\n\tgpiospec.args_count = tmp;\n\n\tfor (i = 0; i < tmp; i++) {\n\t\tret = of_property_read_u32_index(np, \"gpios\", idx * tmp + i,\n\t\t\t\t\t\t &gpiospec.args[i]);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tdesc = of_xlate_and_get_gpiod_flags(chip, &gpiospec, &xlate_flags);\n\tif (IS_ERR(desc))\n\t\treturn desc;\n\n\t*lflags = of_convert_gpio_flags(xlate_flags);\n\n\tif (of_property_read_bool(np, \"input\"))\n\t\t*dflags |= GPIOD_IN;\n\telse if (of_property_read_bool(np, \"output-low\"))\n\t\t*dflags |= GPIOD_OUT_LOW;\n\telse if (of_property_read_bool(np, \"output-high\"))\n\t\t*dflags |= GPIOD_OUT_HIGH;\n\telse {\n\t\tpr_warn(\"GPIO line %d (%pOFn): no hogging state specified, bailing out\\n\",\n\t\t\tdesc_to_gpio(desc), np);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (name && of_property_read_string(np, \"line-name\", name))\n\t\t*name = np->name;\n\n\treturn desc;\n}\n\n \nstatic int of_gpiochip_add_hog(struct gpio_chip *chip, struct device_node *hog)\n{\n\tenum gpiod_flags dflags;\n\tstruct gpio_desc *desc;\n\tunsigned long lflags;\n\tconst char *name;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0;; i++) {\n\t\tdesc = of_parse_own_gpio(hog, chip, i, &name, &lflags, &dflags);\n\t\tif (IS_ERR(desc))\n\t\t\tbreak;\n\n\t\tret = gpiod_hog(desc, name, lflags, dflags);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n#ifdef CONFIG_OF_DYNAMIC\n\t\tdesc->hog = hog;\n#endif\n\t}\n\n\treturn 0;\n}\n\n \nstatic int of_gpiochip_scan_gpios(struct gpio_chip *chip)\n{\n\tstruct device_node *np;\n\tint ret;\n\n\tfor_each_available_child_of_node(dev_of_node(&chip->gpiodev->dev), np) {\n\t\tif (!of_property_read_bool(np, \"gpio-hog\"))\n\t\t\tcontinue;\n\n\t\tret = of_gpiochip_add_hog(chip, np);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\n\t\tof_node_set_flag(np, OF_POPULATED);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF_DYNAMIC\n \nstatic void of_gpiochip_remove_hog(struct gpio_chip *chip,\n\t\t\t\t   struct device_node *hog)\n{\n\tstruct gpio_desc *desc;\n\n\tfor_each_gpio_desc_with_flag(chip, desc, FLAG_IS_HOGGED)\n\t\tif (desc->hog == hog)\n\t\t\tgpiochip_free_own_desc(desc);\n}\n\nstatic int of_gpiochip_match_node(struct gpio_chip *chip, void *data)\n{\n\treturn device_match_of_node(&chip->gpiodev->dev, data);\n}\n\nstatic struct gpio_chip *of_find_gpiochip_by_node(struct device_node *np)\n{\n\treturn gpiochip_find(np, of_gpiochip_match_node);\n}\n\nstatic int of_gpio_notify(struct notifier_block *nb, unsigned long action,\n\t\t\t  void *arg)\n{\n\tstruct of_reconfig_data *rd = arg;\n\tstruct gpio_chip *chip;\n\tint ret;\n\n\t \n\tswitch (of_reconfig_get_state_change(action, arg)) {\n\tcase OF_RECONFIG_CHANGE_ADD:\n\t\tif (!of_property_read_bool(rd->dn, \"gpio-hog\"))\n\t\t\treturn NOTIFY_OK;\t \n\n\t\tif (of_node_test_and_set_flag(rd->dn, OF_POPULATED))\n\t\t\treturn NOTIFY_OK;\n\n\t\tchip = of_find_gpiochip_by_node(rd->dn->parent);\n\t\tif (chip == NULL)\n\t\t\treturn NOTIFY_OK;\t \n\n\t\tret = of_gpiochip_add_hog(chip, rd->dn);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: failed to add hogs for %pOF\\n\", __func__,\n\t\t\t       rd->dn);\n\t\t\tof_node_clear_flag(rd->dn, OF_POPULATED);\n\t\t\treturn notifier_from_errno(ret);\n\t\t}\n\t\tbreak;\n\n\tcase OF_RECONFIG_CHANGE_REMOVE:\n\t\tif (!of_node_check_flag(rd->dn, OF_POPULATED))\n\t\t\treturn NOTIFY_OK;\t \n\n\t\tchip = of_find_gpiochip_by_node(rd->dn->parent);\n\t\tif (chip == NULL)\n\t\t\treturn NOTIFY_OK;\t \n\n\t\tof_gpiochip_remove_hog(chip, rd->dn);\n\t\tof_node_clear_flag(rd->dn, OF_POPULATED);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstruct notifier_block gpio_of_notifier = {\n\t.notifier_call = of_gpio_notify,\n};\n#endif  \n\n \nstatic int of_gpio_simple_xlate(struct gpio_chip *gc,\n\t\t\t\tconst struct of_phandle_args *gpiospec,\n\t\t\t\tu32 *flags)\n{\n\t \n\tif (gc->of_gpio_n_cells < 2) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (WARN_ON(gpiospec->args_count < gc->of_gpio_n_cells))\n\t\treturn -EINVAL;\n\n\tif (gpiospec->args[0] >= gc->ngpio)\n\t\treturn -EINVAL;\n\n\tif (flags)\n\t\t*flags = gpiospec->args[1];\n\n\treturn gpiospec->args[0];\n}\n\n#if IS_ENABLED(CONFIG_OF_GPIO_MM_GPIOCHIP)\n#include <linux/gpio/legacy-of-mm-gpiochip.h>\n \nint of_mm_gpiochip_add_data(struct device_node *np,\n\t\t\t    struct of_mm_gpio_chip *mm_gc,\n\t\t\t    void *data)\n{\n\tint ret = -ENOMEM;\n\tstruct gpio_chip *gc = &mm_gc->gc;\n\n\tgc->label = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tif (!gc->label)\n\t\tgoto err0;\n\n\tmm_gc->regs = of_iomap(np, 0);\n\tif (!mm_gc->regs)\n\t\tgoto err1;\n\n\tgc->base = -1;\n\n\tif (mm_gc->save_regs)\n\t\tmm_gc->save_regs(mm_gc);\n\n\tfwnode_handle_put(mm_gc->gc.fwnode);\n\tmm_gc->gc.fwnode = fwnode_handle_get(of_fwnode_handle(np));\n\n\tret = gpiochip_add_data(gc, data);\n\tif (ret)\n\t\tgoto err2;\n\n\treturn 0;\nerr2:\n\tof_node_put(np);\n\tiounmap(mm_gc->regs);\nerr1:\n\tkfree(gc->label);\nerr0:\n\tpr_err(\"%pOF: GPIO chip registration failed with status %d\\n\", np, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_mm_gpiochip_add_data);\n\n \nvoid of_mm_gpiochip_remove(struct of_mm_gpio_chip *mm_gc)\n{\n\tstruct gpio_chip *gc = &mm_gc->gc;\n\n\tgpiochip_remove(gc);\n\tiounmap(mm_gc->regs);\n\tkfree(gc->label);\n}\nEXPORT_SYMBOL_GPL(of_mm_gpiochip_remove);\n#endif\n\n#ifdef CONFIG_PINCTRL\nstatic int of_gpiochip_add_pin_range(struct gpio_chip *chip)\n{\n\tstruct of_phandle_args pinspec;\n\tstruct pinctrl_dev *pctldev;\n\tstruct device_node *np;\n\tint index = 0, ret;\n\tconst char *name;\n\tstatic const char group_names_propname[] = \"gpio-ranges-group-names\";\n\tstruct property *group_names;\n\n\tnp = dev_of_node(&chip->gpiodev->dev);\n\tif (!np)\n\t\treturn 0;\n\n\tgroup_names = of_find_property(np, group_names_propname, NULL);\n\n\tfor (;; index++) {\n\t\tret = of_parse_phandle_with_fixed_args(np, \"gpio-ranges\", 3,\n\t\t\t\tindex, &pinspec);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tpctldev = of_pinctrl_get(pinspec.np);\n\t\tof_node_put(pinspec.np);\n\t\tif (!pctldev)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tif (pinspec.args[2]) {\n\t\t\tif (group_names) {\n\t\t\t\tof_property_read_string_index(np,\n\t\t\t\t\t\tgroup_names_propname,\n\t\t\t\t\t\tindex, &name);\n\t\t\t\tif (strlen(name)) {\n\t\t\t\t\tpr_err(\"%pOF: Group name of numeric GPIO ranges must be the empty string.\\n\",\n\t\t\t\t\t\tnp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tret = gpiochip_add_pin_range(chip,\n\t\t\t\t\tpinctrl_dev_get_devname(pctldev),\n\t\t\t\t\tpinspec.args[0],\n\t\t\t\t\tpinspec.args[1],\n\t\t\t\t\tpinspec.args[2]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\t \n\t\t\tif (pinspec.args[1]) {\n\t\t\t\tpr_err(\"%pOF: Illegal gpio-range format.\\n\",\n\t\t\t\t\tnp);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!group_names) {\n\t\t\t\tpr_err(\"%pOF: GPIO group range requested but no %s property.\\n\",\n\t\t\t\t\tnp, group_names_propname);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = of_property_read_string_index(np,\n\t\t\t\t\t\tgroup_names_propname,\n\t\t\t\t\t\tindex, &name);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (!strlen(name)) {\n\t\t\t\tpr_err(\"%pOF: Group name of GPIO group range cannot be the empty string.\\n\",\n\t\t\t\tnp);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = gpiochip_add_pingroup_range(chip, pctldev,\n\t\t\t\t\t\tpinspec.args[0], name);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#else\nstatic int of_gpiochip_add_pin_range(struct gpio_chip *chip) { return 0; }\n#endif\n\nint of_gpiochip_add(struct gpio_chip *chip)\n{\n\tstruct device_node *np;\n\tint ret;\n\n\tnp = dev_of_node(&chip->gpiodev->dev);\n\tif (!np)\n\t\treturn 0;\n\n\tif (!chip->of_xlate) {\n\t\tchip->of_gpio_n_cells = 2;\n\t\tchip->of_xlate = of_gpio_simple_xlate;\n\t}\n\n\tif (chip->of_gpio_n_cells > MAX_PHANDLE_ARGS)\n\t\treturn -EINVAL;\n\n\tret = of_gpiochip_add_pin_range(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tof_node_get(np);\n\n\tret = of_gpiochip_scan_gpios(chip);\n\tif (ret)\n\t\tof_node_put(np);\n\n\treturn ret;\n}\n\nvoid of_gpiochip_remove(struct gpio_chip *chip)\n{\n\tof_node_put(dev_of_node(&chip->gpiodev->dev));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}