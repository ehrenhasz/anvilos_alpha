{
  "module_name": "gpio-tangier.c",
  "hash_id": "f8294d810c519068d14b60e92b7634885ce44f8a9f1e8a49715b3ff92f22c3d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-tangier.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/spinlock.h>\n#include <linux/string_helpers.h>\n#include <linux/types.h>\n\n#include <linux/gpio/driver.h>\n\n#include \"gpio-tangier.h\"\n\n#define GCCR\t\t0x000\t \n#define GPLR\t\t0x004\t \n#define GPDR\t\t0x01c\t \n#define GPSR\t\t0x034\t \n#define GPCR\t\t0x04c\t \n#define GRER\t\t0x064\t \n#define GFER\t\t0x07c\t \n#define GFBR\t\t0x094\t \n#define GIMR\t\t0x0ac\t \n#define GISR\t\t0x0c4\t \n#define GITR\t\t0x300\t \n#define GLPR\t\t0x318\t \n\n \nstruct tng_gpio_context {\n\tu32 level;\n\tu32 gpdr;\n\tu32 grer;\n\tu32 gfer;\n\tu32 gimr;\n\tu32 gwmr;\n};\n\nstatic void __iomem *gpio_reg(struct gpio_chip *chip, unsigned int offset,\n\t\t\t      unsigned int reg)\n{\n\tstruct tng_gpio *priv = gpiochip_get_data(chip);\n\tu8 reg_offset = offset / 32;\n\n\treturn priv->reg_base + reg + reg_offset * 4;\n}\n\nstatic void __iomem *gpio_reg_and_bit(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t      unsigned int reg, u8 *bit)\n{\n\tstruct tng_gpio *priv = gpiochip_get_data(chip);\n\tu8 reg_offset = offset / 32;\n\tu8 shift = offset % 32;\n\n\t*bit = shift;\n\treturn priv->reg_base + reg + reg_offset * 4;\n}\n\nstatic int tng_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tvoid __iomem *gplr;\n\tu8 shift;\n\n\tgplr = gpio_reg_and_bit(chip, offset, GPLR, &shift);\n\n\treturn !!(readl(gplr) & BIT(shift));\n}\n\nstatic void tng_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct tng_gpio *priv = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tvoid __iomem *reg;\n\tu8 shift;\n\n\treg = gpio_reg_and_bit(chip, offset, value ? GPSR : GPCR, &shift);\n\n\traw_spin_lock_irqsave(&priv->lock, flags);\n\n\twritel(BIT(shift), reg);\n\n\traw_spin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int tng_gpio_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct tng_gpio *priv = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tvoid __iomem *gpdr;\n\tu32 value;\n\tu8 shift;\n\n\tgpdr = gpio_reg_and_bit(chip, offset, GPDR, &shift);\n\n\traw_spin_lock_irqsave(&priv->lock, flags);\n\n\tvalue = readl(gpdr);\n\tvalue &= ~BIT(shift);\n\twritel(value, gpdr);\n\n\traw_spin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int tng_gpio_direction_output(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t     int value)\n{\n\tstruct tng_gpio *priv = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tvoid __iomem *gpdr;\n\tu8 shift;\n\n\tgpdr = gpio_reg_and_bit(chip, offset, GPDR, &shift);\n\ttng_gpio_set(chip, offset, value);\n\n\traw_spin_lock_irqsave(&priv->lock, flags);\n\n\tvalue = readl(gpdr);\n\tvalue |= BIT(shift);\n\twritel(value, gpdr);\n\n\traw_spin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int tng_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tvoid __iomem *gpdr;\n\tu8 shift;\n\n\tgpdr = gpio_reg_and_bit(chip, offset, GPDR, &shift);\n\n\tif (readl(gpdr) & BIT(shift))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int tng_gpio_set_debounce(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t unsigned int debounce)\n{\n\tstruct tng_gpio *priv = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tvoid __iomem *gfbr;\n\tu32 value;\n\tu8 shift;\n\n\tgfbr = gpio_reg_and_bit(chip, offset, GFBR, &shift);\n\n\traw_spin_lock_irqsave(&priv->lock, flags);\n\n\tvalue = readl(gfbr);\n\tif (debounce)\n\t\tvalue &= ~BIT(shift);\n\telse\n\t\tvalue |= BIT(shift);\n\twritel(value, gfbr);\n\n\traw_spin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int tng_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t       unsigned long config)\n{\n\tu32 debounce;\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\treturn gpiochip_generic_config(chip, offset, config);\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\tdebounce = pinconf_to_config_argument(config);\n\t\treturn tng_gpio_set_debounce(chip, offset, debounce);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic void tng_irq_ack(struct irq_data *d)\n{\n\tstruct tng_gpio *priv = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tvoid __iomem *gisr;\n\tu8 shift;\n\n\tgisr = gpio_reg_and_bit(&priv->chip, gpio, GISR, &shift);\n\n\traw_spin_lock_irqsave(&priv->lock, flags);\n\twritel(BIT(shift), gisr);\n\traw_spin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void tng_irq_unmask_mask(struct tng_gpio *priv, u32 gpio, bool unmask)\n{\n\tunsigned long flags;\n\tvoid __iomem *gimr;\n\tu32 value;\n\tu8 shift;\n\n\tgimr = gpio_reg_and_bit(&priv->chip, gpio, GIMR, &shift);\n\n\traw_spin_lock_irqsave(&priv->lock, flags);\n\n\tvalue = readl(gimr);\n\tif (unmask)\n\t\tvalue |= BIT(shift);\n\telse\n\t\tvalue &= ~BIT(shift);\n\twritel(value, gimr);\n\n\traw_spin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void tng_irq_mask(struct irq_data *d)\n{\n\tstruct tng_gpio *priv = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\n\ttng_irq_unmask_mask(priv, gpio, false);\n\tgpiochip_disable_irq(&priv->chip, gpio);\n}\n\nstatic void tng_irq_unmask(struct irq_data *d)\n{\n\tstruct tng_gpio *priv = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\n\tgpiochip_enable_irq(&priv->chip, gpio);\n\ttng_irq_unmask_mask(priv, gpio, true);\n}\n\nstatic int tng_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct tng_gpio *priv = gpiochip_get_data(gc);\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tvoid __iomem *grer = gpio_reg(&priv->chip, gpio, GRER);\n\tvoid __iomem *gfer = gpio_reg(&priv->chip, gpio, GFER);\n\tvoid __iomem *gitr = gpio_reg(&priv->chip, gpio, GITR);\n\tvoid __iomem *glpr = gpio_reg(&priv->chip, gpio, GLPR);\n\tu8 shift = gpio % 32;\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&priv->lock, flags);\n\n\tvalue = readl(grer);\n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tvalue |= BIT(shift);\n\telse\n\t\tvalue &= ~BIT(shift);\n\twritel(value, grer);\n\n\tvalue = readl(gfer);\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tvalue |= BIT(shift);\n\telse\n\t\tvalue &= ~BIT(shift);\n\twritel(value, gfer);\n\n\t \n\tvalue = readl(glpr);\n\tif (type & IRQ_TYPE_LEVEL_LOW)\n\t\tvalue |= BIT(shift);\n\telse\n\t\tvalue &= ~BIT(shift);\n\twritel(value, glpr);\n\n\tif (type & IRQ_TYPE_LEVEL_MASK) {\n\t\tvalue = readl(gitr);\n\t\tvalue |= BIT(shift);\n\t\twritel(value, gitr);\n\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t} else if (type & IRQ_TYPE_EDGE_BOTH) {\n\t\tvalue = readl(gitr);\n\t\tvalue &= ~BIT(shift);\n\t\twritel(value, gitr);\n\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t}\n\n\traw_spin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int tng_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct tng_gpio *priv = gpiochip_get_data(gc);\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tvoid __iomem *gwmr = gpio_reg(&priv->chip, gpio, priv->wake_regs.gwmr);\n\tvoid __iomem *gwsr = gpio_reg(&priv->chip, gpio, priv->wake_regs.gwsr);\n\tu8 shift = gpio % 32;\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&priv->lock, flags);\n\n\t \n\twritel(BIT(shift), gwsr);\n\n\tvalue = readl(gwmr);\n\tif (on)\n\t\tvalue |= BIT(shift);\n\telse\n\t\tvalue &= ~BIT(shift);\n\twritel(value, gwmr);\n\n\traw_spin_unlock_irqrestore(&priv->lock, flags);\n\n\tdev_dbg(priv->dev, \"%s wake for gpio %lu\\n\", str_enable_disable(on), gpio);\n\treturn 0;\n}\n\nstatic const struct irq_chip tng_irqchip = {\n\t.name\t\t= \"gpio-tangier\",\n\t.irq_ack\t= tng_irq_ack,\n\t.irq_mask\t= tng_irq_mask,\n\t.irq_unmask\t= tng_irq_unmask,\n\t.irq_set_type\t= tng_irq_set_type,\n\t.irq_set_wake\t= tng_irq_set_wake,\n\t.flags          = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void tng_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct tng_gpio *priv = gpiochip_get_data(gc);\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\tunsigned long base, gpio;\n\n\tchained_irq_enter(irqchip, desc);\n\n\t \n\tfor (base = 0; base < priv->chip.ngpio; base += 32) {\n\t\tvoid __iomem *gisr = gpio_reg(&priv->chip, base, GISR);\n\t\tvoid __iomem *gimr = gpio_reg(&priv->chip, base, GIMR);\n\t\tunsigned long pending, enabled;\n\n\t\tpending = readl(gisr);\n\t\tenabled = readl(gimr);\n\n\t\t \n\t\tpending &= enabled;\n\n\t\tfor_each_set_bit(gpio, &pending, 32)\n\t\t\tgeneric_handle_domain_irq(gc->irq.domain, base + gpio);\n\t}\n\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic int tng_irq_init_hw(struct gpio_chip *chip)\n{\n\tstruct tng_gpio *priv = gpiochip_get_data(chip);\n\tvoid __iomem *reg;\n\tunsigned int base;\n\n\tfor (base = 0; base < priv->chip.ngpio; base += 32) {\n\t\t \n\t\treg = gpio_reg(&priv->chip, base, GRER);\n\t\twritel(0, reg);\n\n\t\t \n\t\treg = gpio_reg(&priv->chip, base, GFER);\n\t\twritel(0, reg);\n\t}\n\n\treturn 0;\n}\n\nstatic int tng_gpio_add_pin_ranges(struct gpio_chip *chip)\n{\n\tstruct tng_gpio *priv = gpiochip_get_data(chip);\n\tconst struct tng_gpio_pinrange *range;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < priv->pin_info.nranges; i++) {\n\t\trange = &priv->pin_info.pin_ranges[i];\n\t\tret = gpiochip_add_pin_range(&priv->chip,\n\t\t\t\t\t     priv->pin_info.name,\n\t\t\t\t\t     range->gpio_base,\n\t\t\t\t\t     range->pin_base,\n\t\t\t\t\t     range->npins);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"failed to add GPIO pin range\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint devm_tng_gpio_probe(struct device *dev, struct tng_gpio *gpio)\n{\n\tconst struct tng_gpio_info *info = &gpio->info;\n\tsize_t nctx = DIV_ROUND_UP(info->ngpio, 32);\n\tstruct gpio_irq_chip *girq;\n\tint ret;\n\n\tgpio->ctx = devm_kcalloc(dev, nctx, sizeof(*gpio->ctx), GFP_KERNEL);\n\tif (!gpio->ctx)\n\t\treturn -ENOMEM;\n\n\tgpio->chip.label = dev_name(dev);\n\tgpio->chip.parent = dev;\n\tgpio->chip.request = gpiochip_generic_request;\n\tgpio->chip.free = gpiochip_generic_free;\n\tgpio->chip.direction_input = tng_gpio_direction_input;\n\tgpio->chip.direction_output = tng_gpio_direction_output;\n\tgpio->chip.get = tng_gpio_get;\n\tgpio->chip.set = tng_gpio_set;\n\tgpio->chip.get_direction = tng_gpio_get_direction;\n\tgpio->chip.set_config = tng_gpio_set_config;\n\tgpio->chip.base = info->base;\n\tgpio->chip.ngpio = info->ngpio;\n\tgpio->chip.can_sleep = false;\n\tgpio->chip.add_pin_ranges = tng_gpio_add_pin_ranges;\n\n\traw_spin_lock_init(&gpio->lock);\n\n\tgirq = &gpio->chip.irq;\n\tgpio_irq_chip_set_chip(girq, &tng_irqchip);\n\tgirq->init_hw = tng_irq_init_hw;\n\tgirq->parent_handler = tng_irq_handler;\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(dev, girq->num_parents,\n\t\t\t\t     sizeof(*girq->parents), GFP_KERNEL);\n\tif (!girq->parents)\n\t\treturn -ENOMEM;\n\n\tgirq->parents[0] = gpio->irq;\n\tgirq->first = info->first;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\n\tret = devm_gpiochip_add_data(dev, &gpio->chip, gpio);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"gpiochip_add error\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(devm_tng_gpio_probe, GPIO_TANGIER);\n\nint tng_gpio_suspend(struct device *dev)\n{\n\tstruct tng_gpio *priv = dev_get_drvdata(dev);\n\tstruct tng_gpio_context *ctx = priv->ctx;\n\tunsigned long flags;\n\tunsigned int base;\n\n\traw_spin_lock_irqsave(&priv->lock, flags);\n\n\tfor (base = 0; base < priv->chip.ngpio; base += 32, ctx++) {\n\t\t \n\t\tctx->level = readl(gpio_reg(&priv->chip, base, GPLR));\n\n\t\tctx->gpdr = readl(gpio_reg(&priv->chip, base, GPDR));\n\t\tctx->grer = readl(gpio_reg(&priv->chip, base, GRER));\n\t\tctx->gfer = readl(gpio_reg(&priv->chip, base, GFER));\n\t\tctx->gimr = readl(gpio_reg(&priv->chip, base, GIMR));\n\n\t\tctx->gwmr = readl(gpio_reg(&priv->chip, base, priv->wake_regs.gwmr));\n\t}\n\n\traw_spin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(tng_gpio_suspend, GPIO_TANGIER);\n\nint tng_gpio_resume(struct device *dev)\n{\n\tstruct tng_gpio *priv = dev_get_drvdata(dev);\n\tstruct tng_gpio_context *ctx = priv->ctx;\n\tunsigned long flags;\n\tunsigned int base;\n\n\traw_spin_lock_irqsave(&priv->lock, flags);\n\n\tfor (base = 0; base < priv->chip.ngpio; base += 32, ctx++) {\n\t\t \n\t\twritel(ctx->level, gpio_reg(&priv->chip, base, GPSR));\n\n\t\twritel(ctx->gpdr, gpio_reg(&priv->chip, base, GPDR));\n\t\twritel(ctx->grer, gpio_reg(&priv->chip, base, GRER));\n\t\twritel(ctx->gfer, gpio_reg(&priv->chip, base, GFER));\n\t\twritel(ctx->gimr, gpio_reg(&priv->chip, base, GIMR));\n\n\t\twritel(ctx->gwmr, gpio_reg(&priv->chip, base, priv->wake_regs.gwmr));\n\t}\n\n\traw_spin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(tng_gpio_resume, GPIO_TANGIER);\n\nMODULE_AUTHOR(\"Andy Shevchenko <andriy.shevchenko@linux.intel.com>\");\nMODULE_AUTHOR(\"Pandith N <pandith.n@intel.com>\");\nMODULE_AUTHOR(\"Raag Jadav <raag.jadav@intel.com>\");\nMODULE_DESCRIPTION(\"Intel Tangier GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}