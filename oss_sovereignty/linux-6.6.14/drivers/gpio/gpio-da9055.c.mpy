{
  "module_name": "gpio-da9055.c",
  "hash_id": "881deedcb89cdb5db4df976e197ddc5dd9e4a2286ea982c9581687a7989ddf33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-da9055.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/driver.h>\n\n#include <linux/mfd/da9055/core.h>\n#include <linux/mfd/da9055/reg.h>\n#include <linux/mfd/da9055/pdata.h>\n\n#define DA9055_VDD_IO\t\t\t0x0\n#define DA9055_PUSH_PULL\t\t0x3\n#define DA9055_ACT_LOW\t\t\t0x0\n#define DA9055_GPI\t\t\t0x1\n#define DA9055_PORT_MASK\t\t0x3\n#define DA9055_PORT_SHIFT(offset)\t(4 * (offset % 2))\n\n#define DA9055_INPUT\t\t\tDA9055_GPI\n#define DA9055_OUTPUT\t\t\tDA9055_PUSH_PULL\n#define DA9055_IRQ_GPI0\t\t\t3\n\nstruct da9055_gpio {\n\tstruct da9055 *da9055;\n\tstruct gpio_chip gp;\n};\n\nstatic int da9055_gpio_get(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct da9055_gpio *gpio = gpiochip_get_data(gc);\n\tint gpio_direction = 0;\n\tint ret;\n\n\t \n\tret = da9055_reg_read(gpio->da9055, (offset >> 1) + DA9055_REG_GPIO0_1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgpio_direction = ret & (DA9055_PORT_MASK) << DA9055_PORT_SHIFT(offset);\n\tgpio_direction >>= DA9055_PORT_SHIFT(offset);\n\tswitch (gpio_direction) {\n\tcase DA9055_INPUT:\n\t\tret = da9055_reg_read(gpio->da9055, DA9055_REG_STATUS_B);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase DA9055_OUTPUT:\n\t\tret = da9055_reg_read(gpio->da9055, DA9055_REG_GPIO_MODE0_2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret & (1 << offset);\n\n}\n\nstatic void da9055_gpio_set(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tstruct da9055_gpio *gpio = gpiochip_get_data(gc);\n\n\tda9055_reg_update(gpio->da9055,\n\t\t\tDA9055_REG_GPIO_MODE0_2,\n\t\t\t1 << offset,\n\t\t\tvalue << offset);\n}\n\nstatic int da9055_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct da9055_gpio *gpio = gpiochip_get_data(gc);\n\tunsigned char reg_byte;\n\n\treg_byte = (DA9055_ACT_LOW | DA9055_GPI)\n\t\t\t\t<< DA9055_PORT_SHIFT(offset);\n\n\treturn da9055_reg_update(gpio->da9055, (offset >> 1) +\n\t\t\t\tDA9055_REG_GPIO0_1,\n\t\t\t\tDA9055_PORT_MASK <<\n\t\t\t\tDA9055_PORT_SHIFT(offset),\n\t\t\t\treg_byte);\n}\n\nstatic int da9055_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct da9055_gpio *gpio = gpiochip_get_data(gc);\n\tunsigned char reg_byte;\n\tint ret;\n\n\treg_byte = (DA9055_VDD_IO | DA9055_PUSH_PULL)\n\t\t\t\t\t<< DA9055_PORT_SHIFT(offset);\n\n\tret = da9055_reg_update(gpio->da9055, (offset >> 1) +\n\t\t\t\tDA9055_REG_GPIO0_1,\n\t\t\t\tDA9055_PORT_MASK <<\n\t\t\t\tDA9055_PORT_SHIFT(offset),\n\t\t\t\treg_byte);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tda9055_gpio_set(gc, offset, value);\n\n\treturn 0;\n}\n\nstatic int da9055_gpio_to_irq(struct gpio_chip *gc, u32 offset)\n{\n\tstruct da9055_gpio *gpio = gpiochip_get_data(gc);\n\tstruct da9055 *da9055 = gpio->da9055;\n\n\treturn regmap_irq_get_virq(da9055->irq_data,\n\t\t\t\t  DA9055_IRQ_GPI0 + offset);\n}\n\nstatic const struct gpio_chip reference_gp = {\n\t.label = \"da9055-gpio\",\n\t.owner = THIS_MODULE,\n\t.get = da9055_gpio_get,\n\t.set = da9055_gpio_set,\n\t.direction_input = da9055_gpio_direction_input,\n\t.direction_output = da9055_gpio_direction_output,\n\t.to_irq = da9055_gpio_to_irq,\n\t.can_sleep = true,\n\t.ngpio = 3,\n\t.base = -1,\n};\n\nstatic int da9055_gpio_probe(struct platform_device *pdev)\n{\n\tstruct da9055_gpio *gpio;\n\tstruct da9055_pdata *pdata;\n\n\tgpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tgpio->da9055 = dev_get_drvdata(pdev->dev.parent);\n\tpdata = dev_get_platdata(gpio->da9055->dev);\n\n\tgpio->gp = reference_gp;\n\tif (pdata && pdata->gpio_base)\n\t\tgpio->gp.base = pdata->gpio_base;\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &gpio->gp, gpio);\n}\n\nstatic struct platform_driver da9055_gpio_driver = {\n\t.probe = da9055_gpio_probe,\n\t.driver = {\n\t\t.name\t= \"da9055-gpio\",\n\t},\n};\n\nstatic int __init da9055_gpio_init(void)\n{\n\treturn platform_driver_register(&da9055_gpio_driver);\n}\nsubsys_initcall(da9055_gpio_init);\n\nstatic void __exit da9055_gpio_exit(void)\n{\n\tplatform_driver_unregister(&da9055_gpio_driver);\n}\nmodule_exit(da9055_gpio_exit);\n\nMODULE_AUTHOR(\"David Dajun Chen <dchen@diasemi.com>\");\nMODULE_DESCRIPTION(\"DA9055 GPIO Device Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9055-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}