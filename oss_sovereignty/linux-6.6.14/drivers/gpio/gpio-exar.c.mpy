{
  "module_name": "gpio-exar.c",
  "hash_id": "d2fb80ea91e6d64b19bbd435422f33709da4dc645c6f02249d5862bb5f7bd7f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-exar.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/gpio/driver.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define EXAR_OFFSET_MPIOLVL_LO 0x90\n#define EXAR_OFFSET_MPIOSEL_LO 0x93\n#define EXAR_OFFSET_MPIOLVL_HI 0x96\n#define EXAR_OFFSET_MPIOSEL_HI 0x99\n\n \n#define EXAR_UART_CHANNEL_SIZE 0x400\n\n#define DRIVER_NAME \"gpio_exar\"\n\nstatic DEFINE_IDA(ida_index);\n\nstruct exar_gpio_chip {\n\tstruct gpio_chip gpio_chip;\n\tstruct regmap *regmap;\n\tint index;\n\tchar name[20];\n\tunsigned int first_pin;\n\t \n\tunsigned int cascaded_offset;\n};\n\nstatic unsigned int\nexar_offset_to_sel_addr(struct exar_gpio_chip *exar_gpio, unsigned int offset)\n{\n\tunsigned int pin = exar_gpio->first_pin + (offset % 16);\n\tunsigned int cascaded = offset / 16;\n\tunsigned int addr = pin / 8 ? EXAR_OFFSET_MPIOSEL_HI : EXAR_OFFSET_MPIOSEL_LO;\n\n\treturn addr + (cascaded ? exar_gpio->cascaded_offset : 0);\n}\n\nstatic unsigned int\nexar_offset_to_lvl_addr(struct exar_gpio_chip *exar_gpio, unsigned int offset)\n{\n\tunsigned int pin = exar_gpio->first_pin + (offset % 16);\n\tunsigned int cascaded = offset / 16;\n\tunsigned int addr = pin / 8 ? EXAR_OFFSET_MPIOLVL_HI : EXAR_OFFSET_MPIOLVL_LO;\n\n\treturn addr + (cascaded ? exar_gpio->cascaded_offset : 0);\n}\n\nstatic unsigned int\nexar_offset_to_bit(struct exar_gpio_chip *exar_gpio, unsigned int offset)\n{\n\tunsigned int pin = exar_gpio->first_pin + (offset % 16);\n\n\treturn pin % 8;\n}\n\nstatic int exar_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct exar_gpio_chip *exar_gpio = gpiochip_get_data(chip);\n\tunsigned int addr = exar_offset_to_sel_addr(exar_gpio, offset);\n\tunsigned int bit = exar_offset_to_bit(exar_gpio, offset);\n\n\tif (regmap_test_bits(exar_gpio->regmap, addr, BIT(bit)))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int exar_get_value(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct exar_gpio_chip *exar_gpio = gpiochip_get_data(chip);\n\tunsigned int addr = exar_offset_to_lvl_addr(exar_gpio, offset);\n\tunsigned int bit = exar_offset_to_bit(exar_gpio, offset);\n\n\treturn !!(regmap_test_bits(exar_gpio->regmap, addr, BIT(bit)));\n}\n\nstatic void exar_set_value(struct gpio_chip *chip, unsigned int offset,\n\t\t\t   int value)\n{\n\tstruct exar_gpio_chip *exar_gpio = gpiochip_get_data(chip);\n\tunsigned int addr = exar_offset_to_lvl_addr(exar_gpio, offset);\n\tunsigned int bit = exar_offset_to_bit(exar_gpio, offset);\n\n\tif (value)\n\t\tregmap_set_bits(exar_gpio->regmap, addr, BIT(bit));\n\telse\n\t\tregmap_clear_bits(exar_gpio->regmap, addr, BIT(bit));\n}\n\nstatic int exar_direction_output(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t int value)\n{\n\tstruct exar_gpio_chip *exar_gpio = gpiochip_get_data(chip);\n\tunsigned int addr = exar_offset_to_sel_addr(exar_gpio, offset);\n\tunsigned int bit = exar_offset_to_bit(exar_gpio, offset);\n\n\texar_set_value(chip, offset, value);\n\tregmap_clear_bits(exar_gpio->regmap, addr, BIT(bit));\n\n\treturn 0;\n}\n\nstatic int exar_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct exar_gpio_chip *exar_gpio = gpiochip_get_data(chip);\n\tunsigned int addr = exar_offset_to_sel_addr(exar_gpio, offset);\n\tunsigned int bit = exar_offset_to_bit(exar_gpio, offset);\n\n\tregmap_set_bits(exar_gpio->regmap, addr, BIT(bit));\n\n\treturn 0;\n}\n\nstatic void exar_devm_ida_free(void *data)\n{\n\tstruct exar_gpio_chip *exar_gpio = data;\n\n\tida_free(&ida_index, exar_gpio->index);\n}\n\nstatic const struct regmap_config exar_regmap_config = {\n\t.name\t\t= \"exar-gpio\",\n\t.reg_bits\t= 16,\n\t.val_bits\t= 8,\n\t.io_port\t= true,\n};\n\nstatic int gpio_exar_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pci_dev *pcidev = to_pci_dev(dev->parent);\n\tstruct exar_gpio_chip *exar_gpio;\n\tu32 first_pin, ngpios;\n\tvoid __iomem *p;\n\tint index, ret;\n\n\t \n\tp = pcim_iomap_table(pcidev)[0];\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = device_property_read_u32(dev, \"exar,first-pin\", &first_pin);\n\tif (ret)\n\t\treturn ret;\n\n\tret = device_property_read_u32(dev, \"ngpios\", &ngpios);\n\tif (ret)\n\t\treturn ret;\n\n\texar_gpio = devm_kzalloc(dev, sizeof(*exar_gpio), GFP_KERNEL);\n\tif (!exar_gpio)\n\t\treturn -ENOMEM;\n\n\t \n\tif (pcidev->device & GENMASK(15, 12)) {\n\t\tngpios += ngpios;\n\t\texar_gpio->cascaded_offset = (pcidev->device & GENMASK(3, 0)) *\n\t\t\t\tEXAR_UART_CHANNEL_SIZE;\n\t}\n\n\t \n\texar_gpio->regmap = devm_regmap_init_mmio(dev, p, &exar_regmap_config);\n\tif (IS_ERR(exar_gpio->regmap))\n\t\treturn PTR_ERR(exar_gpio->regmap);\n\n\tindex = ida_alloc(&ida_index, GFP_KERNEL);\n\tif (index < 0)\n\t\treturn index;\n\n\tret = devm_add_action_or_reset(dev, exar_devm_ida_free, exar_gpio);\n\tif (ret)\n\t\treturn ret;\n\n\tsprintf(exar_gpio->name, \"exar_gpio%d\", index);\n\texar_gpio->gpio_chip.label = exar_gpio->name;\n\texar_gpio->gpio_chip.parent = dev;\n\texar_gpio->gpio_chip.direction_output = exar_direction_output;\n\texar_gpio->gpio_chip.direction_input = exar_direction_input;\n\texar_gpio->gpio_chip.get_direction = exar_get_direction;\n\texar_gpio->gpio_chip.get = exar_get_value;\n\texar_gpio->gpio_chip.set = exar_set_value;\n\texar_gpio->gpio_chip.base = -1;\n\texar_gpio->gpio_chip.ngpio = ngpios;\n\texar_gpio->index = index;\n\texar_gpio->first_pin = first_pin;\n\n\tret = devm_gpiochip_add_data(dev, &exar_gpio->gpio_chip, exar_gpio);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic struct platform_driver gpio_exar_driver = {\n\t.probe\t= gpio_exar_probe,\n\t.driver\t= {\n\t\t.name = DRIVER_NAME,\n\t},\n};\n\nmodule_platform_driver(gpio_exar_driver);\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_DESCRIPTION(\"Exar GPIO driver\");\nMODULE_AUTHOR(\"Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}