{
  "module_name": "gpio-fxl6408.c",
  "hash_id": "d8316df4f673b7e3eaec300de184e5e68dddecc1469b35ce48d5e86d7df59345",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-fxl6408.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/regmap.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#define FXL6408_REG_DEVICE_ID\t\t0x01\n#define FXL6408_MF_FAIRCHILD\t\t0b101\n#define FXL6408_MF_SHIFT\t\t5\n\n \n#define FXL6408_REG_IO_DIR\t\t0x03\n\n \n#define FXL6408_REG_OUTPUT\t\t0x05\n\n \n#define FXL6408_REG_OUTPUT_HIGH_Z\t0x07\n\n \n#define FXL6408_REG_INPUT_STATUS\t0x0f\n\n \n#define FXL6408_REG_INT_STS\t\t0x13\n\n#define FXL6408_NGPIO\t\t\t8\n\nstatic const struct regmap_range rd_range[] = {\n\t{ FXL6408_REG_DEVICE_ID, FXL6408_REG_DEVICE_ID },\n\t{ FXL6408_REG_IO_DIR, FXL6408_REG_OUTPUT },\n\t{ FXL6408_REG_INPUT_STATUS, FXL6408_REG_INPUT_STATUS },\n};\n\nstatic const struct regmap_range wr_range[] = {\n\t{ FXL6408_REG_DEVICE_ID, FXL6408_REG_DEVICE_ID },\n\t{ FXL6408_REG_IO_DIR, FXL6408_REG_OUTPUT },\n\t{ FXL6408_REG_OUTPUT_HIGH_Z, FXL6408_REG_OUTPUT_HIGH_Z },\n};\n\nstatic const struct regmap_range volatile_range[] = {\n\t{ FXL6408_REG_DEVICE_ID, FXL6408_REG_DEVICE_ID },\n\t{ FXL6408_REG_INPUT_STATUS, FXL6408_REG_INPUT_STATUS },\n};\n\nstatic const struct regmap_access_table rd_table = {\n\t.yes_ranges = rd_range,\n\t.n_yes_ranges = ARRAY_SIZE(rd_range),\n};\n\nstatic const struct regmap_access_table wr_table = {\n\t.yes_ranges = wr_range,\n\t.n_yes_ranges = ARRAY_SIZE(wr_range),\n};\n\nstatic const struct regmap_access_table volatile_table = {\n\t.yes_ranges = volatile_range,\n\t.n_yes_ranges = ARRAY_SIZE(volatile_range),\n};\n\nstatic const struct regmap_config regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = FXL6408_REG_INT_STS,\n\t.wr_table = &wr_table,\n\t.rd_table = &rd_table,\n\t.volatile_table = &volatile_table,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.num_reg_defaults_raw = FXL6408_REG_INT_STS + 1,\n};\n\nstatic int fxl6408_identify(struct device *dev, struct regmap *regmap)\n{\n\tint val, ret;\n\n\tret = regmap_read(regmap, FXL6408_REG_DEVICE_ID, &val);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"error reading DEVICE_ID\\n\");\n\tif (val >> FXL6408_MF_SHIFT != FXL6408_MF_FAIRCHILD)\n\t\treturn dev_err_probe(dev, -ENODEV, \"invalid device id 0x%02x\\n\", val);\n\n\treturn 0;\n}\n\nstatic int fxl6408_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tint ret;\n\tstruct gpio_regmap_config gpio_config = {\n\t\t.parent = dev,\n\t\t.ngpio = FXL6408_NGPIO,\n\t\t.reg_dat_base = GPIO_REGMAP_ADDR(FXL6408_REG_INPUT_STATUS),\n\t\t.reg_set_base = GPIO_REGMAP_ADDR(FXL6408_REG_OUTPUT),\n\t\t.reg_dir_out_base = GPIO_REGMAP_ADDR(FXL6408_REG_IO_DIR),\n\t\t.ngpio_per_reg = FXL6408_NGPIO,\n\t};\n\n\tgpio_config.regmap = devm_regmap_init_i2c(client, &regmap);\n\tif (IS_ERR(gpio_config.regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(gpio_config.regmap),\n\t\t\t\t     \"failed to allocate register map\\n\");\n\n\tret = fxl6408_identify(dev, gpio_config.regmap);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(gpio_config.regmap, FXL6408_REG_OUTPUT_HIGH_Z, 0);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to write 'output high Z' register\\n\");\n\n\treturn PTR_ERR_OR_ZERO(devm_gpio_regmap_register(dev, &gpio_config));\n}\n\nstatic const __maybe_unused struct of_device_id fxl6408_dt_ids[] = {\n\t{ .compatible = \"fcs,fxl6408\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, fxl6408_dt_ids);\n\nstatic const struct i2c_device_id fxl6408_id[] = {\n\t{ \"fxl6408\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, fxl6408_id);\n\nstatic struct i2c_driver fxl6408_driver = {\n\t.driver = {\n\t\t.name\t= \"fxl6408\",\n\t\t.of_match_table = fxl6408_dt_ids,\n\t},\n\t.probe\t\t= fxl6408_probe,\n\t.id_table\t= fxl6408_id,\n};\nmodule_i2c_driver(fxl6408_driver);\n\nMODULE_AUTHOR(\"Emanuele Ghidoli <emanuele.ghidoli@toradex.com>\");\nMODULE_DESCRIPTION(\"FXL6408 GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}