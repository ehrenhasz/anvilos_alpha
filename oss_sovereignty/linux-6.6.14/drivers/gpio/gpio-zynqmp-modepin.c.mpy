{
  "module_name": "gpio-zynqmp-modepin.c",
  "hash_id": "93f64eeeff60d78c93cfe604f4bab0ffee6d3152376feb0e943cd9eeb3ae04cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-zynqmp-modepin.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/firmware/xlnx-zynqmp.h>\n\n \n#define MODE_PINS\t\t\t4\n\n \nstatic int modepin_gpio_get_value(struct gpio_chip *chip, unsigned int pin)\n{\n\tu32 regval = 0;\n\tint ret;\n\n\tret = zynqmp_pm_bootmode_read(&regval);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (regval & BIT(pin))\n\t\treturn !!(regval & BIT(pin + 8));\n\telse\n\t\treturn !!(regval & BIT(pin + 4));\n}\n\n \nstatic void modepin_gpio_set_value(struct gpio_chip *chip, unsigned int pin,\n\t\t\t\t   int state)\n{\n\tu32 bootpin_val = 0;\n\tint ret;\n\n\tzynqmp_pm_bootmode_read(&bootpin_val);\n\n\t \n\tbootpin_val |= BIT(pin);\n\n\tif (state)\n\t\tbootpin_val |= BIT(pin + 8);\n\telse\n\t\tbootpin_val &= ~BIT(pin + 8);\n\n\t \n\tret = zynqmp_pm_bootmode_write(bootpin_val);\n\tif (ret)\n\t\tpr_err(\"modepin: set value error %d for pin %d\\n\", ret, pin);\n}\n\n \nstatic int modepin_gpio_dir_in(struct gpio_chip *chip, unsigned int pin)\n{\n\treturn 0;\n}\n\n \nstatic int modepin_gpio_dir_out(struct gpio_chip *chip, unsigned int pin,\n\t\t\t\tint state)\n{\n\treturn 0;\n}\n\n \nstatic int modepin_gpio_probe(struct platform_device *pdev)\n{\n\tstruct gpio_chip *chip;\n\tint status;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, chip);\n\n\t \n\tchip->base = -1;\n\tchip->ngpio = MODE_PINS;\n\tchip->owner = THIS_MODULE;\n\tchip->parent = &pdev->dev;\n\tchip->get = modepin_gpio_get_value;\n\tchip->set = modepin_gpio_set_value;\n\tchip->direction_input = modepin_gpio_dir_in;\n\tchip->direction_output = modepin_gpio_dir_out;\n\tchip->label = dev_name(&pdev->dev);\n\n\t \n\tstatus = devm_gpiochip_add_data(&pdev->dev, chip, chip);\n\tif (status)\n\t\treturn dev_err_probe(&pdev->dev, status,\n\t\t\t      \"Failed to add GPIO chip\\n\");\n\n\treturn status;\n}\n\nstatic const struct of_device_id modepin_platform_id[] = {\n\t{ .compatible = \"xlnx,zynqmp-gpio-modepin\", },\n\t{ }\n};\n\nstatic struct platform_driver modepin_platform_driver = {\n\t.driver = {\n\t\t.name = \"modepin-gpio\",\n\t\t.of_match_table = modepin_platform_id,\n\t},\n\t.probe = modepin_gpio_probe,\n};\n\nmodule_platform_driver(modepin_platform_driver);\n\nMODULE_AUTHOR(\"Piyush Mehta <piyush.mehta@xilinx.com>\");\nMODULE_DESCRIPTION(\"ZynqMP Boot PS_MODE Configuration\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}