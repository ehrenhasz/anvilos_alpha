{
  "module_name": "gpio-en7523.c",
  "hash_id": "fd18e7d5555d3add00da4b020f1020c3e2db71875827eb0d9506d1fdc1256995",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-en7523.c",
  "human_readable_source": "\n\n#include <linux/types.h>\n#include <linux/io.h>\n#include <linux/bits.h>\n#include <linux/gpio/driver.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#define AIROHA_GPIO_MAX\t\t32\n\n \nstruct airoha_gpio_ctrl {\n\tstruct gpio_chip gc;\n\tvoid __iomem *data;\n\tvoid __iomem *dir[2];\n\tvoid __iomem *output;\n};\n\nstatic struct airoha_gpio_ctrl *gc_to_ctrl(struct gpio_chip *gc)\n{\n\treturn container_of(gc, struct airoha_gpio_ctrl, gc);\n}\n\nstatic int airoha_dir_set(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t  int val, int out)\n{\n\tstruct airoha_gpio_ctrl *ctrl = gc_to_ctrl(gc);\n\tu32 dir = ioread32(ctrl->dir[gpio / 16]);\n\tu32 output = ioread32(ctrl->output);\n\tu32 mask = BIT((gpio % 16) * 2);\n\n\tif (out) {\n\t\tdir |= mask;\n\t\toutput |= BIT(gpio);\n\t} else {\n\t\tdir &= ~mask;\n\t\toutput &= ~BIT(gpio);\n\t}\n\n\tiowrite32(dir, ctrl->dir[gpio / 16]);\n\n\tif (out)\n\t\tgc->set(gc, gpio, val);\n\n\tiowrite32(output, ctrl->output);\n\n\treturn 0;\n}\n\nstatic int airoha_dir_out(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t  int val)\n{\n\treturn airoha_dir_set(gc, gpio, val, 1);\n}\n\nstatic int airoha_dir_in(struct gpio_chip *gc, unsigned int gpio)\n{\n\treturn airoha_dir_set(gc, gpio, 0, 0);\n}\n\nstatic int airoha_get_dir(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct airoha_gpio_ctrl *ctrl = gc_to_ctrl(gc);\n\tu32 dir = ioread32(ctrl->dir[gpio / 16]);\n\tu32 mask = BIT((gpio % 16) * 2);\n\n\treturn (dir & mask) ? GPIO_LINE_DIRECTION_OUT : GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int airoha_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct airoha_gpio_ctrl *ctrl;\n\tint err;\n\n\tctrl = devm_kzalloc(dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->data = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctrl->data))\n\t\treturn PTR_ERR(ctrl->data);\n\n\tctrl->dir[0] = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(ctrl->dir[0]))\n\t\treturn PTR_ERR(ctrl->dir[0]);\n\n\tctrl->dir[1] = devm_platform_ioremap_resource(pdev, 2);\n\tif (IS_ERR(ctrl->dir[1]))\n\t\treturn PTR_ERR(ctrl->dir[1]);\n\n\tctrl->output = devm_platform_ioremap_resource(pdev, 3);\n\tif (IS_ERR(ctrl->output))\n\t\treturn PTR_ERR(ctrl->output);\n\n\terr = bgpio_init(&ctrl->gc, dev, 4, ctrl->data, NULL,\n\t\t\t NULL, NULL, NULL, 0);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"unable to init generic GPIO\");\n\n\tctrl->gc.ngpio = AIROHA_GPIO_MAX;\n\tctrl->gc.owner = THIS_MODULE;\n\tctrl->gc.direction_output = airoha_dir_out;\n\tctrl->gc.direction_input = airoha_dir_in;\n\tctrl->gc.get_direction = airoha_get_dir;\n\n\treturn devm_gpiochip_add_data(dev, &ctrl->gc, ctrl);\n}\n\nstatic const struct of_device_id airoha_gpio_of_match[] = {\n\t{ .compatible = \"airoha,en7523-gpio\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, airoha_gpio_of_match);\n\nstatic struct platform_driver airoha_gpio_driver = {\n\t.driver = {\n\t\t.name = \"airoha-gpio\",\n\t\t.of_match_table\t= airoha_gpio_of_match,\n\t},\n\t.probe = airoha_gpio_probe,\n};\nmodule_platform_driver(airoha_gpio_driver);\n\nMODULE_DESCRIPTION(\"Airoha GPIO support\");\nMODULE_AUTHOR(\"John Crispin <john@phrozen.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}