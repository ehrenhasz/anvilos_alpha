{
  "module_name": "gpio-mt7621.c",
  "hash_id": "bc0a0e785f5409a89a053b853fbf1a784f29941c6025907268bdb42b57816fc3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mt7621.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#define MTK_BANK_CNT\t3\n#define MTK_BANK_WIDTH\t32\n\n#define GPIO_BANK_STRIDE\t0x04\n#define GPIO_REG_CTRL\t\t0x00\n#define GPIO_REG_POL\t\t0x10\n#define GPIO_REG_DATA\t\t0x20\n#define GPIO_REG_DSET\t\t0x30\n#define GPIO_REG_DCLR\t\t0x40\n#define GPIO_REG_REDGE\t\t0x50\n#define GPIO_REG_FEDGE\t\t0x60\n#define GPIO_REG_HLVL\t\t0x70\n#define GPIO_REG_LLVL\t\t0x80\n#define GPIO_REG_STAT\t\t0x90\n#define GPIO_REG_EDGE\t\t0xA0\n\nstruct mtk_gc {\n\tstruct irq_chip irq_chip;\n\tstruct gpio_chip chip;\n\tspinlock_t lock;\n\tint bank;\n\tu32 rising;\n\tu32 falling;\n\tu32 hlevel;\n\tu32 llevel;\n};\n\n \nstruct mtk {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tint gpio_irq;\n\tstruct mtk_gc gc_map[MTK_BANK_CNT];\n};\n\nstatic inline struct mtk_gc *\nto_mediatek_gpio(struct gpio_chip *chip)\n{\n\treturn container_of(chip, struct mtk_gc, chip);\n}\n\nstatic inline void\nmtk_gpio_w32(struct mtk_gc *rg, u32 offset, u32 val)\n{\n\tstruct gpio_chip *gc = &rg->chip;\n\tstruct mtk *mtk = gpiochip_get_data(gc);\n\n\toffset = (rg->bank * GPIO_BANK_STRIDE) + offset;\n\tgc->write_reg(mtk->base + offset, val);\n}\n\nstatic inline u32\nmtk_gpio_r32(struct mtk_gc *rg, u32 offset)\n{\n\tstruct gpio_chip *gc = &rg->chip;\n\tstruct mtk *mtk = gpiochip_get_data(gc);\n\n\toffset = (rg->bank * GPIO_BANK_STRIDE) + offset;\n\treturn gc->read_reg(mtk->base + offset);\n}\n\nstatic irqreturn_t\nmediatek_gpio_irq_handler(int irq, void *data)\n{\n\tstruct gpio_chip *gc = data;\n\tstruct mtk_gc *rg = to_mediatek_gpio(gc);\n\tirqreturn_t ret = IRQ_NONE;\n\tunsigned long pending;\n\tint bit;\n\n\tpending = mtk_gpio_r32(rg, GPIO_REG_STAT);\n\n\tfor_each_set_bit(bit, &pending, MTK_BANK_WIDTH) {\n\t\tgeneric_handle_domain_irq(gc->irq.domain, bit);\n\t\tmtk_gpio_w32(rg, GPIO_REG_STAT, BIT(bit));\n\t\tret |= IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic void\nmediatek_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct mtk_gc *rg = to_mediatek_gpio(gc);\n\tint pin = d->hwirq;\n\tunsigned long flags;\n\tu32 rise, fall, high, low;\n\n\tgpiochip_enable_irq(gc, d->hwirq);\n\n\tspin_lock_irqsave(&rg->lock, flags);\n\trise = mtk_gpio_r32(rg, GPIO_REG_REDGE);\n\tfall = mtk_gpio_r32(rg, GPIO_REG_FEDGE);\n\thigh = mtk_gpio_r32(rg, GPIO_REG_HLVL);\n\tlow = mtk_gpio_r32(rg, GPIO_REG_LLVL);\n\tmtk_gpio_w32(rg, GPIO_REG_REDGE, rise | (BIT(pin) & rg->rising));\n\tmtk_gpio_w32(rg, GPIO_REG_FEDGE, fall | (BIT(pin) & rg->falling));\n\tmtk_gpio_w32(rg, GPIO_REG_HLVL, high | (BIT(pin) & rg->hlevel));\n\tmtk_gpio_w32(rg, GPIO_REG_LLVL, low | (BIT(pin) & rg->llevel));\n\tspin_unlock_irqrestore(&rg->lock, flags);\n}\n\nstatic void\nmediatek_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct mtk_gc *rg = to_mediatek_gpio(gc);\n\tint pin = d->hwirq;\n\tunsigned long flags;\n\tu32 rise, fall, high, low;\n\n\tspin_lock_irqsave(&rg->lock, flags);\n\trise = mtk_gpio_r32(rg, GPIO_REG_REDGE);\n\tfall = mtk_gpio_r32(rg, GPIO_REG_FEDGE);\n\thigh = mtk_gpio_r32(rg, GPIO_REG_HLVL);\n\tlow = mtk_gpio_r32(rg, GPIO_REG_LLVL);\n\tmtk_gpio_w32(rg, GPIO_REG_FEDGE, fall & ~BIT(pin));\n\tmtk_gpio_w32(rg, GPIO_REG_REDGE, rise & ~BIT(pin));\n\tmtk_gpio_w32(rg, GPIO_REG_HLVL, high & ~BIT(pin));\n\tmtk_gpio_w32(rg, GPIO_REG_LLVL, low & ~BIT(pin));\n\tspin_unlock_irqrestore(&rg->lock, flags);\n\n\tgpiochip_disable_irq(gc, d->hwirq);\n}\n\nstatic int\nmediatek_gpio_irq_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct mtk_gc *rg = to_mediatek_gpio(gc);\n\tint pin = d->hwirq;\n\tu32 mask = BIT(pin);\n\n\tif (type == IRQ_TYPE_PROBE) {\n\t\tif ((rg->rising | rg->falling |\n\t\t     rg->hlevel | rg->llevel) & mask)\n\t\t\treturn 0;\n\n\t\ttype = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\n\t}\n\n\trg->rising &= ~mask;\n\trg->falling &= ~mask;\n\trg->hlevel &= ~mask;\n\trg->llevel &= ~mask;\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\trg->rising |= mask;\n\t\trg->falling |= mask;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\trg->rising |= mask;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\trg->falling |= mask;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\trg->hlevel |= mask;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\trg->llevel |= mask;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmediatek_gpio_xlate(struct gpio_chip *chip,\n\t\t    const struct of_phandle_args *spec, u32 *flags)\n{\n\tint gpio = spec->args[0];\n\tstruct mtk_gc *rg = to_mediatek_gpio(chip);\n\n\tif (rg->bank != gpio / MTK_BANK_WIDTH)\n\t\treturn -EINVAL;\n\n\tif (flags)\n\t\t*flags = spec->args[1];\n\n\treturn gpio % MTK_BANK_WIDTH;\n}\n\nstatic const struct irq_chip mt7621_irq_chip = {\n\t.name\t\t= \"mt7621-gpio\",\n\t.irq_mask_ack\t= mediatek_gpio_irq_mask,\n\t.irq_mask\t= mediatek_gpio_irq_mask,\n\t.irq_unmask\t= mediatek_gpio_irq_unmask,\n\t.irq_set_type\t= mediatek_gpio_irq_type,\n\t.flags\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int\nmediatek_gpio_bank_probe(struct device *dev, int bank)\n{\n\tstruct mtk *mtk = dev_get_drvdata(dev);\n\tstruct mtk_gc *rg;\n\tvoid __iomem *dat, *set, *ctrl, *diro;\n\tint ret;\n\n\trg = &mtk->gc_map[bank];\n\tmemset(rg, 0, sizeof(*rg));\n\n\tspin_lock_init(&rg->lock);\n\trg->bank = bank;\n\n\tdat = mtk->base + GPIO_REG_DATA + (rg->bank * GPIO_BANK_STRIDE);\n\tset = mtk->base + GPIO_REG_DSET + (rg->bank * GPIO_BANK_STRIDE);\n\tctrl = mtk->base + GPIO_REG_DCLR + (rg->bank * GPIO_BANK_STRIDE);\n\tdiro = mtk->base + GPIO_REG_CTRL + (rg->bank * GPIO_BANK_STRIDE);\n\n\tret = bgpio_init(&rg->chip, dev, 4, dat, set, ctrl, diro, NULL,\n\t\t\t BGPIOF_NO_SET_ON_INPUT);\n\tif (ret) {\n\t\tdev_err(dev, \"bgpio_init() failed\\n\");\n\t\treturn ret;\n\t}\n\n\trg->chip.of_gpio_n_cells = 2;\n\trg->chip.of_xlate = mediatek_gpio_xlate;\n\trg->chip.label = devm_kasprintf(dev, GFP_KERNEL, \"%s-bank%d\",\n\t\t\t\t\tdev_name(dev), bank);\n\tif (!rg->chip.label)\n\t\treturn -ENOMEM;\n\n\trg->chip.offset = bank * MTK_BANK_WIDTH;\n\n\tif (mtk->gpio_irq) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\t \n\t\tret = devm_request_irq(dev, mtk->gpio_irq,\n\t\t\t\t       mediatek_gpio_irq_handler, IRQF_SHARED,\n\t\t\t\t       rg->chip.label, &rg->chip);\n\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Error requesting IRQ %d: %d\\n\",\n\t\t\t\tmtk->gpio_irq, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tgirq = &rg->chip.irq;\n\t\tgpio_irq_chip_set_chip(girq, &mt7621_irq_chip);\n\t\t \n\t\tgirq->parent_handler = NULL;\n\t\tgirq->num_parents = 0;\n\t\tgirq->parents = NULL;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_simple_irq;\n\t}\n\n\tret = devm_gpiochip_add_data(dev, &rg->chip, mtk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Could not register gpio %d, ret=%d\\n\",\n\t\t\trg->chip.ngpio, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmtk_gpio_w32(rg, GPIO_REG_POL, 0);\n\n\tdev_info(dev, \"registering %d gpios\\n\", rg->chip.ngpio);\n\n\treturn 0;\n}\n\nstatic int\nmediatek_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk *mtk;\n\tint i;\n\tint ret;\n\n\tmtk = devm_kzalloc(dev, sizeof(*mtk), GFP_KERNEL);\n\tif (!mtk)\n\t\treturn -ENOMEM;\n\n\tmtk->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mtk->base))\n\t\treturn PTR_ERR(mtk->base);\n\n\tmtk->gpio_irq = platform_get_irq(pdev, 0);\n\tif (mtk->gpio_irq < 0)\n\t\treturn mtk->gpio_irq;\n\n\tmtk->dev = dev;\n\tplatform_set_drvdata(pdev, mtk);\n\n\tfor (i = 0; i < MTK_BANK_CNT; i++) {\n\t\tret = mediatek_gpio_bank_probe(dev, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mediatek_gpio_match[] = {\n\t{ .compatible = \"mediatek,mt7621-gpio\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mediatek_gpio_match);\n\nstatic struct platform_driver mediatek_gpio_driver = {\n\t.probe = mediatek_gpio_probe,\n\t.driver = {\n\t\t.name = \"mt7621_gpio\",\n\t\t.of_match_table = mediatek_gpio_match,\n\t},\n};\n\nbuiltin_platform_driver(mediatek_gpio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}