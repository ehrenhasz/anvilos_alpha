{
  "module_name": "gpio-sprd.c",
  "hash_id": "461e58c231727b263e685a10943838d225287492e2c6ccce60fac5779bcf2a74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-sprd.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n \n#define SPRD_GPIO_DATA\t\t0x0\n#define SPRD_GPIO_DMSK\t\t0x4\n#define SPRD_GPIO_DIR\t\t0x8\n#define SPRD_GPIO_IS\t\t0xc\n#define SPRD_GPIO_IBE\t\t0x10\n#define SPRD_GPIO_IEV\t\t0x14\n#define SPRD_GPIO_IE\t\t0x18\n#define SPRD_GPIO_RIS\t\t0x1c\n#define SPRD_GPIO_MIS\t\t0x20\n#define SPRD_GPIO_IC\t\t0x24\n#define SPRD_GPIO_INEN\t\t0x28\n\n \n#define SPRD_GPIO_BANK_NR\t16\n#define SPRD_GPIO_NR\t\t256\n#define SPRD_GPIO_BANK_SIZE\t0x80\n#define SPRD_GPIO_BANK_MASK\tGENMASK(15, 0)\n#define SPRD_GPIO_BIT(x)\t((x) & (SPRD_GPIO_BANK_NR - 1))\n\nstruct sprd_gpio {\n\tstruct gpio_chip chip;\n\tvoid __iomem *base;\n\tspinlock_t lock;\n\tint irq;\n};\n\nstatic inline void __iomem *sprd_gpio_bank_base(struct sprd_gpio *sprd_gpio,\n\t\t\t\t\t\tunsigned int bank)\n{\n\treturn sprd_gpio->base + SPRD_GPIO_BANK_SIZE * bank;\n}\n\nstatic void sprd_gpio_update(struct gpio_chip *chip, unsigned int offset,\n\t\t\t     u16 reg, int val)\n{\n\tstruct sprd_gpio *sprd_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *base = sprd_gpio_bank_base(sprd_gpio,\n\t\t\t\t\t\t offset / SPRD_GPIO_BANK_NR);\n\tunsigned long flags;\n\tu32 tmp;\n\n\tspin_lock_irqsave(&sprd_gpio->lock, flags);\n\ttmp = readl_relaxed(base + reg);\n\n\tif (val)\n\t\ttmp |= BIT(SPRD_GPIO_BIT(offset));\n\telse\n\t\ttmp &= ~BIT(SPRD_GPIO_BIT(offset));\n\n\twritel_relaxed(tmp, base + reg);\n\tspin_unlock_irqrestore(&sprd_gpio->lock, flags);\n}\n\nstatic int sprd_gpio_read(struct gpio_chip *chip, unsigned int offset, u16 reg)\n{\n\tstruct sprd_gpio *sprd_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *base = sprd_gpio_bank_base(sprd_gpio,\n\t\t\t\t\t\t offset / SPRD_GPIO_BANK_NR);\n\n\treturn !!(readl_relaxed(base + reg) & BIT(SPRD_GPIO_BIT(offset)));\n}\n\nstatic int sprd_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tsprd_gpio_update(chip, offset, SPRD_GPIO_DMSK, 1);\n\treturn 0;\n}\n\nstatic void sprd_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tsprd_gpio_update(chip, offset, SPRD_GPIO_DMSK, 0);\n}\n\nstatic int sprd_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset)\n{\n\tsprd_gpio_update(chip, offset, SPRD_GPIO_DIR, 0);\n\tsprd_gpio_update(chip, offset, SPRD_GPIO_INEN, 1);\n\treturn 0;\n}\n\nstatic int sprd_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset, int value)\n{\n\tsprd_gpio_update(chip, offset, SPRD_GPIO_DIR, 1);\n\tsprd_gpio_update(chip, offset, SPRD_GPIO_INEN, 0);\n\tsprd_gpio_update(chip, offset, SPRD_GPIO_DATA, value);\n\treturn 0;\n}\n\nstatic int sprd_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\treturn sprd_gpio_read(chip, offset, SPRD_GPIO_DATA);\n}\n\nstatic void sprd_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t  int value)\n{\n\tsprd_gpio_update(chip, offset, SPRD_GPIO_DATA, value);\n}\n\nstatic void sprd_gpio_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tu32 offset = irqd_to_hwirq(data);\n\n\tsprd_gpio_update(chip, offset, SPRD_GPIO_IE, 0);\n\tgpiochip_disable_irq(chip, offset);\n}\n\nstatic void sprd_gpio_irq_ack(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tu32 offset = irqd_to_hwirq(data);\n\n\tsprd_gpio_update(chip, offset, SPRD_GPIO_IC, 1);\n}\n\nstatic void sprd_gpio_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tu32 offset = irqd_to_hwirq(data);\n\n\tsprd_gpio_update(chip, offset, SPRD_GPIO_IE, 1);\n\tgpiochip_enable_irq(chip, offset);\n}\n\nstatic int sprd_gpio_irq_set_type(struct irq_data *data,\n\t\t\t\t  unsigned int flow_type)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tu32 offset = irqd_to_hwirq(data);\n\n\tswitch (flow_type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IS, 0);\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IBE, 0);\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IEV, 1);\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IC, 1);\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IS, 0);\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IBE, 0);\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IEV, 0);\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IC, 1);\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IS, 0);\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IBE, 1);\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IC, 1);\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IS, 1);\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IBE, 0);\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IEV, 1);\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IS, 1);\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IBE, 0);\n\t\tsprd_gpio_update(chip, offset, SPRD_GPIO_IEV, 0);\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void sprd_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *chip = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *ic = irq_desc_get_chip(desc);\n\tstruct sprd_gpio *sprd_gpio = gpiochip_get_data(chip);\n\tu32 bank, n;\n\n\tchained_irq_enter(ic, desc);\n\n\tfor (bank = 0; bank * SPRD_GPIO_BANK_NR < chip->ngpio; bank++) {\n\t\tvoid __iomem *base = sprd_gpio_bank_base(sprd_gpio, bank);\n\t\tunsigned long reg = readl_relaxed(base + SPRD_GPIO_MIS) &\n\t\t\tSPRD_GPIO_BANK_MASK;\n\n\t\tfor_each_set_bit(n, &reg, SPRD_GPIO_BANK_NR)\n\t\t\tgeneric_handle_domain_irq(chip->irq.domain,\n\t\t\t\t\t\t  bank * SPRD_GPIO_BANK_NR + n);\n\t}\n\tchained_irq_exit(ic, desc);\n}\n\nstatic const struct irq_chip sprd_gpio_irqchip = {\n\t.name = \"sprd-gpio\",\n\t.irq_ack = sprd_gpio_irq_ack,\n\t.irq_mask = sprd_gpio_irq_mask,\n\t.irq_unmask = sprd_gpio_irq_unmask,\n\t.irq_set_type = sprd_gpio_irq_set_type,\n\t.flags = IRQCHIP_SKIP_SET_WAKE | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int sprd_gpio_probe(struct platform_device *pdev)\n{\n\tstruct gpio_irq_chip *irq;\n\tstruct sprd_gpio *sprd_gpio;\n\n\tsprd_gpio = devm_kzalloc(&pdev->dev, sizeof(*sprd_gpio), GFP_KERNEL);\n\tif (!sprd_gpio)\n\t\treturn -ENOMEM;\n\n\tsprd_gpio->irq = platform_get_irq(pdev, 0);\n\tif (sprd_gpio->irq < 0)\n\t\treturn sprd_gpio->irq;\n\n\tsprd_gpio->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sprd_gpio->base))\n\t\treturn PTR_ERR(sprd_gpio->base);\n\n\tspin_lock_init(&sprd_gpio->lock);\n\n\tsprd_gpio->chip.label = dev_name(&pdev->dev);\n\tsprd_gpio->chip.ngpio = SPRD_GPIO_NR;\n\tsprd_gpio->chip.base = -1;\n\tsprd_gpio->chip.parent = &pdev->dev;\n\tsprd_gpio->chip.request = sprd_gpio_request;\n\tsprd_gpio->chip.free = sprd_gpio_free;\n\tsprd_gpio->chip.get = sprd_gpio_get;\n\tsprd_gpio->chip.set = sprd_gpio_set;\n\tsprd_gpio->chip.direction_input = sprd_gpio_direction_input;\n\tsprd_gpio->chip.direction_output = sprd_gpio_direction_output;\n\n\tirq = &sprd_gpio->chip.irq;\n\tgpio_irq_chip_set_chip(irq, &sprd_gpio_irqchip);\n\tirq->handler = handle_bad_irq;\n\tirq->default_type = IRQ_TYPE_NONE;\n\tirq->parent_handler = sprd_gpio_irq_handler;\n\tirq->parent_handler_data = sprd_gpio;\n\tirq->num_parents = 1;\n\tirq->parents = &sprd_gpio->irq;\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &sprd_gpio->chip, sprd_gpio);\n}\n\nstatic const struct of_device_id sprd_gpio_of_match[] = {\n\t{ .compatible = \"sprd,sc9860-gpio\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sprd_gpio_of_match);\n\nstatic struct platform_driver sprd_gpio_driver = {\n\t.probe = sprd_gpio_probe,\n\t.driver = {\n\t\t.name = \"sprd-gpio\",\n\t\t.of_match_table\t= sprd_gpio_of_match,\n\t},\n};\n\nmodule_platform_driver_probe(sprd_gpio_driver, sprd_gpio_probe);\n\nMODULE_DESCRIPTION(\"Spreadtrum GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}