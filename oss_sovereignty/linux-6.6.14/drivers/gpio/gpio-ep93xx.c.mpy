{
  "module_name": "gpio-ep93xx.c",
  "hash_id": "3b904314a7e8601a4235a9bf46f95d1132823af62f6158aedc176f3d3cb3cfda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-ep93xx.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/gpio/driver.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n\n#define EP93XX_GPIO_F_INT_STATUS 0x5c\n#define EP93XX_GPIO_A_INT_STATUS 0xa0\n#define EP93XX_GPIO_B_INT_STATUS 0xbc\n\n \n#define EP93XX_GPIO_LINE_MAX 63\n\n \n#define EP93XX_GPIO_CHIP_NUM 8\n\n \n#define EP93XX_GPIO_LINE_MAX_IRQ 23\n\n#define EP93XX_GPIO_A_IRQ_BASE 64\n#define EP93XX_GPIO_B_IRQ_BASE 72\n \n#define EP93XX_GPIO_F_IRQ_BASE 80\n\nstruct ep93xx_gpio_irq_chip {\n\tu8 irq_offset;\n\tu8 int_unmasked;\n\tu8 int_enabled;\n\tu8 int_type1;\n\tu8 int_type2;\n\tu8 int_debounce;\n};\n\nstruct ep93xx_gpio_chip {\n\tstruct gpio_chip\t\tgc;\n\tstruct ep93xx_gpio_irq_chip\t*eic;\n};\n\nstruct ep93xx_gpio {\n\tvoid __iomem\t\t*base;\n\tstruct ep93xx_gpio_chip\tgc[EP93XX_GPIO_CHIP_NUM];\n};\n\n#define to_ep93xx_gpio_chip(x) container_of(x, struct ep93xx_gpio_chip, gc)\n\nstatic struct ep93xx_gpio_irq_chip *to_ep93xx_gpio_irq_chip(struct gpio_chip *gc)\n{\n\tstruct ep93xx_gpio_chip *egc = to_ep93xx_gpio_chip(gc);\n\n\treturn egc->eic;\n}\n\n \n#define EP93XX_INT_TYPE1_OFFSET\t\t0x00\n#define EP93XX_INT_TYPE2_OFFSET\t\t0x04\n#define EP93XX_INT_EOI_OFFSET\t\t0x08\n#define EP93XX_INT_EN_OFFSET\t\t0x0c\n#define EP93XX_INT_STATUS_OFFSET\t0x10\n#define EP93XX_INT_RAW_STATUS_OFFSET\t0x14\n#define EP93XX_INT_DEBOUNCE_OFFSET\t0x18\n\nstatic void ep93xx_gpio_update_int_params(struct ep93xx_gpio *epg,\n\t\t\t\t\t  struct ep93xx_gpio_irq_chip *eic)\n{\n\twriteb_relaxed(0, epg->base + eic->irq_offset + EP93XX_INT_EN_OFFSET);\n\n\twriteb_relaxed(eic->int_type2,\n\t\t       epg->base + eic->irq_offset + EP93XX_INT_TYPE2_OFFSET);\n\n\twriteb_relaxed(eic->int_type1,\n\t\t       epg->base + eic->irq_offset + EP93XX_INT_TYPE1_OFFSET);\n\n\twriteb_relaxed(eic->int_unmasked & eic->int_enabled,\n\t\t       epg->base + eic->irq_offset + EP93XX_INT_EN_OFFSET);\n}\n\nstatic void ep93xx_gpio_int_debounce(struct gpio_chip *gc,\n\t\t\t\t     unsigned int offset, bool enable)\n{\n\tstruct ep93xx_gpio *epg = gpiochip_get_data(gc);\n\tstruct ep93xx_gpio_irq_chip *eic = to_ep93xx_gpio_irq_chip(gc);\n\tint port_mask = BIT(offset);\n\n\tif (enable)\n\t\teic->int_debounce |= port_mask;\n\telse\n\t\teic->int_debounce &= ~port_mask;\n\n\twriteb(eic->int_debounce,\n\t       epg->base + eic->irq_offset + EP93XX_INT_DEBOUNCE_OFFSET);\n}\n\nstatic void ep93xx_gpio_ab_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct ep93xx_gpio *epg = gpiochip_get_data(gc);\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\tunsigned long stat;\n\tint offset;\n\n\tchained_irq_enter(irqchip, desc);\n\n\t \n\tstat = readb(epg->base + EP93XX_GPIO_A_INT_STATUS);\n\tfor_each_set_bit(offset, &stat, 8)\n\t\tgeneric_handle_domain_irq(epg->gc[0].gc.irq.domain,\n\t\t\t\t\t  offset);\n\n\tstat = readb(epg->base + EP93XX_GPIO_B_INT_STATUS);\n\tfor_each_set_bit(offset, &stat, 8)\n\t\tgeneric_handle_domain_irq(epg->gc[1].gc.irq.domain,\n\t\t\t\t\t  offset);\n\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic void ep93xx_gpio_f_irq_handler(struct irq_desc *desc)\n{\n\t \n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tint port_f_idx = (irq & 7) ^ 4;  \n\tint gpio_irq = EP93XX_GPIO_F_IRQ_BASE + port_f_idx;\n\n\tchained_irq_enter(irqchip, desc);\n\tgeneric_handle_irq(gpio_irq);\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic void ep93xx_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct ep93xx_gpio_irq_chip *eic = to_ep93xx_gpio_irq_chip(gc);\n\tstruct ep93xx_gpio *epg = gpiochip_get_data(gc);\n\tint port_mask = BIT(d->irq & 7);\n\n\tif (irqd_get_trigger_type(d) == IRQ_TYPE_EDGE_BOTH) {\n\t\teic->int_type2 ^= port_mask;  \n\t\tep93xx_gpio_update_int_params(epg, eic);\n\t}\n\n\twriteb(port_mask, epg->base + eic->irq_offset + EP93XX_INT_EOI_OFFSET);\n}\n\nstatic void ep93xx_gpio_irq_mask_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct ep93xx_gpio_irq_chip *eic = to_ep93xx_gpio_irq_chip(gc);\n\tstruct ep93xx_gpio *epg = gpiochip_get_data(gc);\n\tint port_mask = BIT(d->irq & 7);\n\n\tif (irqd_get_trigger_type(d) == IRQ_TYPE_EDGE_BOTH)\n\t\teic->int_type2 ^= port_mask;  \n\n\teic->int_unmasked &= ~port_mask;\n\tep93xx_gpio_update_int_params(epg, eic);\n\n\twriteb(port_mask, epg->base + eic->irq_offset + EP93XX_INT_EOI_OFFSET);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void ep93xx_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct ep93xx_gpio_irq_chip *eic = to_ep93xx_gpio_irq_chip(gc);\n\tstruct ep93xx_gpio *epg = gpiochip_get_data(gc);\n\n\teic->int_unmasked &= ~BIT(d->irq & 7);\n\tep93xx_gpio_update_int_params(epg, eic);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void ep93xx_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct ep93xx_gpio_irq_chip *eic = to_ep93xx_gpio_irq_chip(gc);\n\tstruct ep93xx_gpio *epg = gpiochip_get_data(gc);\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\teic->int_unmasked |= BIT(d->irq & 7);\n\tep93xx_gpio_update_int_params(epg, eic);\n}\n\n \nstatic int ep93xx_gpio_irq_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct ep93xx_gpio_irq_chip *eic = to_ep93xx_gpio_irq_chip(gc);\n\tstruct ep93xx_gpio *epg = gpiochip_get_data(gc);\n\tint offset = d->irq & 7;\n\tint port_mask = BIT(offset);\n\tirq_flow_handler_t handler;\n\n\tgc->direction_input(gc, offset);\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\teic->int_type1 |= port_mask;\n\t\teic->int_type2 |= port_mask;\n\t\thandler = handle_edge_irq;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\teic->int_type1 |= port_mask;\n\t\teic->int_type2 &= ~port_mask;\n\t\thandler = handle_edge_irq;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\teic->int_type1 &= ~port_mask;\n\t\teic->int_type2 |= port_mask;\n\t\thandler = handle_level_irq;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\teic->int_type1 &= ~port_mask;\n\t\teic->int_type2 &= ~port_mask;\n\t\thandler = handle_level_irq;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\teic->int_type1 |= port_mask;\n\t\t \n\t\tif (gc->get(gc, offset))\n\t\t\teic->int_type2 &= ~port_mask;  \n\t\telse\n\t\t\teic->int_type2 |= port_mask;  \n\t\thandler = handle_edge_irq;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tirq_set_handler_locked(d, handler);\n\n\teic->int_enabled |= port_mask;\n\n\tep93xx_gpio_update_int_params(epg, eic);\n\n\treturn 0;\n}\n\n \nstruct ep93xx_gpio_bank {\n\tconst char\t*label;\n\tint\t\tdata;\n\tint\t\tdir;\n\tint\t\tirq;\n\tint\t\tbase;\n\tbool\t\thas_irq;\n\tbool\t\thas_hierarchical_irq;\n\tunsigned int\tirq_base;\n};\n\n#define EP93XX_GPIO_BANK(_label, _data, _dir, _irq, _base, _has_irq, _has_hier, _irq_base) \\\n\t{\t\t\t\t\t\t\t\\\n\t\t.label\t\t= _label,\t\t\t\\\n\t\t.data\t\t= _data,\t\t\t\\\n\t\t.dir\t\t= _dir,\t\t\t\t\\\n\t\t.irq\t\t= _irq,\t\t\t\t\\\n\t\t.base\t\t= _base,\t\t\t\\\n\t\t.has_irq\t= _has_irq,\t\t\t\\\n\t\t.has_hierarchical_irq = _has_hier,\t\t\\\n\t\t.irq_base\t= _irq_base,\t\t\t\\\n\t}\n\nstatic struct ep93xx_gpio_bank ep93xx_gpio_banks[] = {\n\t \n\tEP93XX_GPIO_BANK(\"A\", 0x00, 0x10, 0x90, 0, true, false, EP93XX_GPIO_A_IRQ_BASE),\n\t \n\tEP93XX_GPIO_BANK(\"B\", 0x04, 0x14, 0xac, 8, true, false, EP93XX_GPIO_B_IRQ_BASE),\n\tEP93XX_GPIO_BANK(\"C\", 0x08, 0x18, 0x00, 40, false, false, 0),\n\tEP93XX_GPIO_BANK(\"D\", 0x0c, 0x1c, 0x00, 24, false, false, 0),\n\tEP93XX_GPIO_BANK(\"E\", 0x20, 0x24, 0x00, 32, false, false, 0),\n\t \n\tEP93XX_GPIO_BANK(\"F\", 0x30, 0x34, 0x4c, 16, false, true, EP93XX_GPIO_F_IRQ_BASE),\n\tEP93XX_GPIO_BANK(\"G\", 0x38, 0x3c, 0x00, 48, false, false, 0),\n\tEP93XX_GPIO_BANK(\"H\", 0x40, 0x44, 0x00, 56, false, false, 0),\n};\n\nstatic int ep93xx_gpio_set_config(struct gpio_chip *gc, unsigned offset,\n\t\t\t\t  unsigned long config)\n{\n\tu32 debounce;\n\n\tif (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)\n\t\treturn -ENOTSUPP;\n\n\tdebounce = pinconf_to_config_argument(config);\n\tep93xx_gpio_int_debounce(gc, offset, debounce ? true : false);\n\n\treturn 0;\n}\n\nstatic void ep93xx_irq_print_chip(struct irq_data *data, struct seq_file *p)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\n\tseq_printf(p, dev_name(gc->parent));\n}\n\nstatic const struct irq_chip gpio_eic_irq_chip = {\n\t.name\t\t\t= \"ep93xx-gpio-eic\",\n\t.irq_ack\t\t= ep93xx_gpio_irq_ack,\n\t.irq_mask\t\t= ep93xx_gpio_irq_mask,\n\t.irq_unmask\t\t= ep93xx_gpio_irq_unmask,\n\t.irq_mask_ack\t= ep93xx_gpio_irq_mask_ack,\n\t.irq_set_type\t= ep93xx_gpio_irq_type,\n\t.irq_print_chip\t= ep93xx_irq_print_chip,\n\t.flags\t\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int ep93xx_gpio_add_bank(struct ep93xx_gpio_chip *egc,\n\t\t\t\tstruct platform_device *pdev,\n\t\t\t\tstruct ep93xx_gpio *epg,\n\t\t\t\tstruct ep93xx_gpio_bank *bank)\n{\n\tvoid __iomem *data = epg->base + bank->data;\n\tvoid __iomem *dir = epg->base + bank->dir;\n\tstruct gpio_chip *gc = &egc->gc;\n\tstruct device *dev = &pdev->dev;\n\tstruct gpio_irq_chip *girq;\n\tint err;\n\n\terr = bgpio_init(gc, dev, 1, data, NULL, NULL, dir, NULL, 0);\n\tif (err)\n\t\treturn err;\n\n\tgc->label = bank->label;\n\tgc->base = bank->base;\n\n\tgirq = &gc->irq;\n\tif (bank->has_irq || bank->has_hierarchical_irq) {\n\t\tgc->set_config = ep93xx_gpio_set_config;\n\t\tegc->eic = devm_kcalloc(dev, 1,\n\t\t\t\t\tsizeof(*egc->eic),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!egc->eic)\n\t\t\treturn -ENOMEM;\n\t\tegc->eic->irq_offset = bank->irq;\n\t\tgpio_irq_chip_set_chip(girq, &gpio_eic_irq_chip);\n\t}\n\n\tif (bank->has_irq) {\n\t\tint ab_parent_irq = platform_get_irq(pdev, 0);\n\n\t\tgirq->parent_handler = ep93xx_gpio_ab_irq_handler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(dev, girq->num_parents,\n\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_level_irq;\n\t\tgirq->parents[0] = ab_parent_irq;\n\t\tgirq->first = bank->irq_base;\n\t}\n\n\t \n\tif (bank->has_hierarchical_irq) {\n\t\tint gpio_irq;\n\t\tint i;\n\n\t\t \n\t\tgirq->parent_handler = ep93xx_gpio_f_irq_handler;\n\t\tgirq->num_parents = 8;\n\t\tgirq->parents = devm_kcalloc(dev, girq->num_parents,\n\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tfor (i = 0; i < girq->num_parents; i++) {\n\t\t\tgirq->parents[i] = platform_get_irq(pdev, i + 1);\n\t\t\tgpio_irq = bank->irq_base + i;\n\t\t\tirq_set_chip_data(gpio_irq, &epg->gc[5]);\n\t\t\tirq_set_chip_and_handler(gpio_irq,\n\t\t\t\t\t\t girq->chip,\n\t\t\t\t\t\t handle_level_irq);\n\t\t\tirq_clear_status_flags(gpio_irq, IRQ_NOREQUEST);\n\t\t}\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_level_irq;\n\t\tgirq->first = bank->irq_base;\n\t}\n\n\treturn devm_gpiochip_add_data(dev, gc, epg);\n}\n\nstatic int ep93xx_gpio_probe(struct platform_device *pdev)\n{\n\tstruct ep93xx_gpio *epg;\n\tint i;\n\n\tepg = devm_kzalloc(&pdev->dev, sizeof(*epg), GFP_KERNEL);\n\tif (!epg)\n\t\treturn -ENOMEM;\n\n\tepg->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(epg->base))\n\t\treturn PTR_ERR(epg->base);\n\n\tfor (i = 0; i < ARRAY_SIZE(ep93xx_gpio_banks); i++) {\n\t\tstruct ep93xx_gpio_chip *gc = &epg->gc[i];\n\t\tstruct ep93xx_gpio_bank *bank = &ep93xx_gpio_banks[i];\n\n\t\tif (ep93xx_gpio_add_bank(gc, pdev, epg, bank))\n\t\t\tdev_warn(&pdev->dev, \"Unable to add gpio bank %s\\n\",\n\t\t\t\t bank->label);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver ep93xx_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"gpio-ep93xx\",\n\t},\n\t.probe\t\t= ep93xx_gpio_probe,\n};\n\nstatic int __init ep93xx_gpio_init(void)\n{\n\treturn platform_driver_register(&ep93xx_gpio_driver);\n}\npostcore_initcall(ep93xx_gpio_init);\n\nMODULE_AUTHOR(\"Ryan Mallon <ryan@bluewatersys.com> \"\n\t\t\"H Hartley Sweeten <hsweeten@visionengravers.com>\");\nMODULE_DESCRIPTION(\"EP93XX GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}