{
  "module_name": "gpio-eic-sprd.c",
  "hash_id": "55066947bbe12ff0b21a976e51c3d9ec40acd9bd540ba5065b94593d073bca8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-eic-sprd.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n \n#define SPRD_EIC_DBNC_DATA\t\t0x0\n#define SPRD_EIC_DBNC_DMSK\t\t0x4\n#define SPRD_EIC_DBNC_IEV\t\t0x14\n#define SPRD_EIC_DBNC_IE\t\t0x18\n#define SPRD_EIC_DBNC_RIS\t\t0x1c\n#define SPRD_EIC_DBNC_MIS\t\t0x20\n#define SPRD_EIC_DBNC_IC\t\t0x24\n#define SPRD_EIC_DBNC_TRIG\t\t0x28\n#define SPRD_EIC_DBNC_CTRL0\t\t0x40\n\n#define SPRD_EIC_LATCH_INTEN\t\t0x0\n#define SPRD_EIC_LATCH_INTRAW\t\t0x4\n#define SPRD_EIC_LATCH_INTMSK\t\t0x8\n#define SPRD_EIC_LATCH_INTCLR\t\t0xc\n#define SPRD_EIC_LATCH_INTPOL\t\t0x10\n#define SPRD_EIC_LATCH_INTMODE\t\t0x14\n\n#define SPRD_EIC_ASYNC_INTIE\t\t0x0\n#define SPRD_EIC_ASYNC_INTRAW\t\t0x4\n#define SPRD_EIC_ASYNC_INTMSK\t\t0x8\n#define SPRD_EIC_ASYNC_INTCLR\t\t0xc\n#define SPRD_EIC_ASYNC_INTMODE\t\t0x10\n#define SPRD_EIC_ASYNC_INTBOTH\t\t0x14\n#define SPRD_EIC_ASYNC_INTPOL\t\t0x18\n#define SPRD_EIC_ASYNC_DATA\t\t0x1c\n\n#define SPRD_EIC_SYNC_INTIE\t\t0x0\n#define SPRD_EIC_SYNC_INTRAW\t\t0x4\n#define SPRD_EIC_SYNC_INTMSK\t\t0x8\n#define SPRD_EIC_SYNC_INTCLR\t\t0xc\n#define SPRD_EIC_SYNC_INTMODE\t\t0x10\n#define SPRD_EIC_SYNC_INTBOTH\t\t0x14\n#define SPRD_EIC_SYNC_INTPOL\t\t0x18\n#define SPRD_EIC_SYNC_DATA\t\t0x1c\n\n \n#define SPRD_EIC_MAX_BANK\t\t3\n#define SPRD_EIC_PER_BANK_NR\t\t8\n#define SPRD_EIC_DATA_MASK\t\tGENMASK(7, 0)\n#define SPRD_EIC_BIT(x)\t\t\t((x) & (SPRD_EIC_PER_BANK_NR - 1))\n#define SPRD_EIC_DBNC_MASK\t\tGENMASK(11, 0)\n\n \nenum sprd_eic_type {\n\tSPRD_EIC_DEBOUNCE,\n\tSPRD_EIC_LATCH,\n\tSPRD_EIC_ASYNC,\n\tSPRD_EIC_SYNC,\n\tSPRD_EIC_MAX,\n};\n\nstruct sprd_eic {\n\tstruct gpio_chip chip;\n\tvoid __iomem *base[SPRD_EIC_MAX_BANK];\n\tenum sprd_eic_type type;\n\tspinlock_t lock;\n\tint irq;\n};\n\nstruct sprd_eic_variant_data {\n\tenum sprd_eic_type type;\n\tu32 num_eics;\n};\n\nstatic const char *sprd_eic_label_name[SPRD_EIC_MAX] = {\n\t\"eic-debounce\", \"eic-latch\", \"eic-async\",\n\t\"eic-sync\",\n};\n\nstatic const struct sprd_eic_variant_data sc9860_eic_dbnc_data = {\n\t.type = SPRD_EIC_DEBOUNCE,\n\t.num_eics = 8,\n};\n\nstatic const struct sprd_eic_variant_data sc9860_eic_latch_data = {\n\t.type = SPRD_EIC_LATCH,\n\t.num_eics = 8,\n};\n\nstatic const struct sprd_eic_variant_data sc9860_eic_async_data = {\n\t.type = SPRD_EIC_ASYNC,\n\t.num_eics = 8,\n};\n\nstatic const struct sprd_eic_variant_data sc9860_eic_sync_data = {\n\t.type = SPRD_EIC_SYNC,\n\t.num_eics = 8,\n};\n\nstatic inline void __iomem *sprd_eic_offset_base(struct sprd_eic *sprd_eic,\n\t\t\t\t\t\t unsigned int bank)\n{\n\tif (bank >= SPRD_EIC_MAX_BANK)\n\t\treturn NULL;\n\n\treturn sprd_eic->base[bank];\n}\n\nstatic void sprd_eic_update(struct gpio_chip *chip, unsigned int offset,\n\t\t\t    u16 reg, unsigned int val)\n{\n\tstruct sprd_eic *sprd_eic = gpiochip_get_data(chip);\n\tvoid __iomem *base =\n\t\tsprd_eic_offset_base(sprd_eic, offset / SPRD_EIC_PER_BANK_NR);\n\tunsigned long flags;\n\tu32 tmp;\n\n\tspin_lock_irqsave(&sprd_eic->lock, flags);\n\ttmp = readl_relaxed(base + reg);\n\n\tif (val)\n\t\ttmp |= BIT(SPRD_EIC_BIT(offset));\n\telse\n\t\ttmp &= ~BIT(SPRD_EIC_BIT(offset));\n\n\twritel_relaxed(tmp, base + reg);\n\tspin_unlock_irqrestore(&sprd_eic->lock, flags);\n}\n\nstatic int sprd_eic_read(struct gpio_chip *chip, unsigned int offset, u16 reg)\n{\n\tstruct sprd_eic *sprd_eic = gpiochip_get_data(chip);\n\tvoid __iomem *base =\n\t\tsprd_eic_offset_base(sprd_eic, offset / SPRD_EIC_PER_BANK_NR);\n\n\treturn !!(readl_relaxed(base + reg) & BIT(SPRD_EIC_BIT(offset)));\n}\n\nstatic int sprd_eic_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tsprd_eic_update(chip, offset, SPRD_EIC_DBNC_DMSK, 1);\n\treturn 0;\n}\n\nstatic void sprd_eic_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tsprd_eic_update(chip, offset, SPRD_EIC_DBNC_DMSK, 0);\n}\n\nstatic int sprd_eic_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sprd_eic *sprd_eic = gpiochip_get_data(chip);\n\n\tswitch (sprd_eic->type) {\n\tcase SPRD_EIC_DEBOUNCE:\n\t\treturn sprd_eic_read(chip, offset, SPRD_EIC_DBNC_DATA);\n\tcase SPRD_EIC_ASYNC:\n\t\treturn sprd_eic_read(chip, offset, SPRD_EIC_ASYNC_DATA);\n\tcase SPRD_EIC_SYNC:\n\t\treturn sprd_eic_read(chip, offset, SPRD_EIC_SYNC_DATA);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int sprd_eic_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\t \n\treturn 0;\n}\n\nstatic void sprd_eic_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\t \n}\n\nstatic int sprd_eic_set_debounce(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t unsigned int debounce)\n{\n\tstruct sprd_eic *sprd_eic = gpiochip_get_data(chip);\n\tvoid __iomem *base =\n\t\tsprd_eic_offset_base(sprd_eic, offset / SPRD_EIC_PER_BANK_NR);\n\tu32 reg = SPRD_EIC_DBNC_CTRL0 + SPRD_EIC_BIT(offset) * 0x4;\n\tu32 value = readl_relaxed(base + reg) & ~SPRD_EIC_DBNC_MASK;\n\n\tvalue |= (debounce / 1000) & SPRD_EIC_DBNC_MASK;\n\twritel_relaxed(value, base + reg);\n\n\treturn 0;\n}\n\nstatic int sprd_eic_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t       unsigned long config)\n{\n\tunsigned long param = pinconf_to_config_param(config);\n\tu32 arg = pinconf_to_config_argument(config);\n\n\tif (param == PIN_CONFIG_INPUT_DEBOUNCE)\n\t\treturn sprd_eic_set_debounce(chip, offset, arg);\n\n\treturn -ENOTSUPP;\n}\n\nstatic void sprd_eic_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct sprd_eic *sprd_eic = gpiochip_get_data(chip);\n\tu32 offset = irqd_to_hwirq(data);\n\n\tswitch (sprd_eic->type) {\n\tcase SPRD_EIC_DEBOUNCE:\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_DBNC_IE, 0);\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_DBNC_TRIG, 0);\n\t\tbreak;\n\tcase SPRD_EIC_LATCH:\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_LATCH_INTEN, 0);\n\t\tbreak;\n\tcase SPRD_EIC_ASYNC:\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTIE, 0);\n\t\tbreak;\n\tcase SPRD_EIC_SYNC:\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTIE, 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->parent, \"Unsupported EIC type.\\n\");\n\t}\n\n\tgpiochip_disable_irq(chip, offset);\n}\n\nstatic void sprd_eic_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct sprd_eic *sprd_eic = gpiochip_get_data(chip);\n\tu32 offset = irqd_to_hwirq(data);\n\n\tgpiochip_enable_irq(chip, offset);\n\n\tswitch (sprd_eic->type) {\n\tcase SPRD_EIC_DEBOUNCE:\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_DBNC_IE, 1);\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_DBNC_TRIG, 1);\n\t\tbreak;\n\tcase SPRD_EIC_LATCH:\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_LATCH_INTEN, 1);\n\t\tbreak;\n\tcase SPRD_EIC_ASYNC:\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTIE, 1);\n\t\tbreak;\n\tcase SPRD_EIC_SYNC:\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTIE, 1);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->parent, \"Unsupported EIC type.\\n\");\n\t}\n}\n\nstatic void sprd_eic_irq_ack(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct sprd_eic *sprd_eic = gpiochip_get_data(chip);\n\tu32 offset = irqd_to_hwirq(data);\n\n\tswitch (sprd_eic->type) {\n\tcase SPRD_EIC_DEBOUNCE:\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_DBNC_IC, 1);\n\t\tbreak;\n\tcase SPRD_EIC_LATCH:\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_LATCH_INTCLR, 1);\n\t\tbreak;\n\tcase SPRD_EIC_ASYNC:\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTCLR, 1);\n\t\tbreak;\n\tcase SPRD_EIC_SYNC:\n\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTCLR, 1);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->parent, \"Unsupported EIC type.\\n\");\n\t}\n}\n\nstatic int sprd_eic_irq_set_type(struct irq_data *data, unsigned int flow_type)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct sprd_eic *sprd_eic = gpiochip_get_data(chip);\n\tu32 offset = irqd_to_hwirq(data);\n\tint state;\n\n\tswitch (sprd_eic->type) {\n\tcase SPRD_EIC_DEBOUNCE:\n\t\tswitch (flow_type) {\n\t\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_DBNC_IEV, 1);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_LEVEL_LOW:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_DBNC_IEV, 0);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_EDGE_RISING:\n\t\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t\tstate = sprd_eic_get(chip, offset);\n\t\t\tif (state)\n\t\t\t\tsprd_eic_update(chip, offset,\n\t\t\t\t\t\tSPRD_EIC_DBNC_IEV, 0);\n\t\t\telse\n\t\t\t\tsprd_eic_update(chip, offset,\n\t\t\t\t\t\tSPRD_EIC_DBNC_IEV, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\t\tbreak;\n\tcase SPRD_EIC_LATCH:\n\t\tswitch (flow_type) {\n\t\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_LATCH_INTPOL, 0);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_LEVEL_LOW:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_LATCH_INTPOL, 1);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_EDGE_RISING:\n\t\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t\tstate = sprd_eic_get(chip, offset);\n\t\t\tif (state)\n\t\t\t\tsprd_eic_update(chip, offset,\n\t\t\t\t\t\tSPRD_EIC_LATCH_INTPOL, 0);\n\t\t\telse\n\t\t\t\tsprd_eic_update(chip, offset,\n\t\t\t\t\t\tSPRD_EIC_LATCH_INTPOL, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\t\tbreak;\n\tcase SPRD_EIC_ASYNC:\n\t\tswitch (flow_type) {\n\t\tcase IRQ_TYPE_EDGE_RISING:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTBOTH, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTMODE, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTPOL, 1);\n\t\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_EDGE_FALLING:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTBOTH, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTMODE, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTPOL, 0);\n\t\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTMODE, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTBOTH, 1);\n\t\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTBOTH, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTMODE, 1);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTPOL, 1);\n\t\t\tirq_set_handler_locked(data, handle_level_irq);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_LEVEL_LOW:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTBOTH, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTMODE, 1);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_ASYNC_INTPOL, 0);\n\t\t\tirq_set_handler_locked(data, handle_level_irq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase SPRD_EIC_SYNC:\n\t\tswitch (flow_type) {\n\t\tcase IRQ_TYPE_EDGE_RISING:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTBOTH, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTMODE, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTPOL, 1);\n\t\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_EDGE_FALLING:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTBOTH, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTMODE, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTPOL, 0);\n\t\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTMODE, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTBOTH, 1);\n\t\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTBOTH, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTMODE, 1);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTPOL, 1);\n\t\t\tirq_set_handler_locked(data, handle_level_irq);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_LEVEL_LOW:\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTBOTH, 0);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTMODE, 1);\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_SYNC_INTPOL, 0);\n\t\t\tirq_set_handler_locked(data, handle_level_irq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->parent, \"Unsupported EIC type.\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void sprd_eic_toggle_trigger(struct gpio_chip *chip, unsigned int irq,\n\t\t\t\t    unsigned int offset)\n{\n\tstruct sprd_eic *sprd_eic = gpiochip_get_data(chip);\n\tstruct irq_data *data = irq_get_irq_data(irq);\n\tu32 trigger = irqd_get_trigger_type(data);\n\tint state, post_state;\n\n\t \n\tif ((sprd_eic->type != SPRD_EIC_DEBOUNCE &&\n\t     sprd_eic->type != SPRD_EIC_LATCH) ||\n\t    !(trigger & IRQ_TYPE_EDGE_BOTH))\n\t\treturn;\n\n\tsprd_eic_irq_mask(data);\n\tstate = sprd_eic_get(chip, offset);\n\nretry:\n\tswitch (sprd_eic->type) {\n\tcase SPRD_EIC_DEBOUNCE:\n\t\tif (state)\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_DBNC_IEV, 0);\n\t\telse\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_DBNC_IEV, 1);\n\t\tbreak;\n\tcase SPRD_EIC_LATCH:\n\t\tif (state)\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_LATCH_INTPOL, 0);\n\t\telse\n\t\t\tsprd_eic_update(chip, offset, SPRD_EIC_LATCH_INTPOL, 1);\n\t\tbreak;\n\tdefault:\n\t\tsprd_eic_irq_unmask(data);\n\t\treturn;\n\t}\n\n\tpost_state = sprd_eic_get(chip, offset);\n\tif (state != post_state) {\n\t\tdev_warn(chip->parent, \"EIC level was changed.\\n\");\n\t\tstate = post_state;\n\t\tgoto retry;\n\t}\n\n\tsprd_eic_irq_unmask(data);\n}\n\nstatic int sprd_eic_match_chip_by_type(struct gpio_chip *chip, void *data)\n{\n\tenum sprd_eic_type type = *(enum sprd_eic_type *)data;\n\n\treturn !strcmp(chip->label, sprd_eic_label_name[type]);\n}\n\nstatic void sprd_eic_handle_one_type(struct gpio_chip *chip)\n{\n\tstruct sprd_eic *sprd_eic = gpiochip_get_data(chip);\n\tu32 bank, n, girq;\n\n\tfor (bank = 0; bank * SPRD_EIC_PER_BANK_NR < chip->ngpio; bank++) {\n\t\tvoid __iomem *base = sprd_eic_offset_base(sprd_eic, bank);\n\t\tunsigned long reg;\n\n\t\tswitch (sprd_eic->type) {\n\t\tcase SPRD_EIC_DEBOUNCE:\n\t\t\treg = readl_relaxed(base + SPRD_EIC_DBNC_MIS) &\n\t\t\t\tSPRD_EIC_DATA_MASK;\n\t\t\tbreak;\n\t\tcase SPRD_EIC_LATCH:\n\t\t\treg = readl_relaxed(base + SPRD_EIC_LATCH_INTMSK) &\n\t\t\t\tSPRD_EIC_DATA_MASK;\n\t\t\tbreak;\n\t\tcase SPRD_EIC_ASYNC:\n\t\t\treg = readl_relaxed(base + SPRD_EIC_ASYNC_INTMSK) &\n\t\t\t\tSPRD_EIC_DATA_MASK;\n\t\t\tbreak;\n\t\tcase SPRD_EIC_SYNC:\n\t\t\treg = readl_relaxed(base + SPRD_EIC_SYNC_INTMSK) &\n\t\t\t\tSPRD_EIC_DATA_MASK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(chip->parent, \"Unsupported EIC type.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tfor_each_set_bit(n, &reg, SPRD_EIC_PER_BANK_NR) {\n\t\t\tu32 offset = bank * SPRD_EIC_PER_BANK_NR + n;\n\n\t\t\tgirq = irq_find_mapping(chip->irq.domain, offset);\n\n\t\t\tgeneric_handle_irq(girq);\n\t\t\tsprd_eic_toggle_trigger(chip, girq, offset);\n\t\t}\n\t}\n}\n\nstatic void sprd_eic_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *ic = irq_desc_get_chip(desc);\n\tstruct gpio_chip *chip;\n\tenum sprd_eic_type type;\n\n\tchained_irq_enter(ic, desc);\n\n\t \n\tfor (type = SPRD_EIC_DEBOUNCE; type < SPRD_EIC_MAX; type++) {\n\t\tchip = gpiochip_find(&type, sprd_eic_match_chip_by_type);\n\t\tif (!chip)\n\t\t\tcontinue;\n\n\t\tsprd_eic_handle_one_type(chip);\n\t}\n\n\tchained_irq_exit(ic, desc);\n}\n\nstatic const struct irq_chip sprd_eic_irq = {\n\t.name\t\t= \"sprd-eic\",\n\t.irq_ack\t= sprd_eic_irq_ack,\n\t.irq_mask\t= sprd_eic_irq_mask,\n\t.irq_unmask\t= sprd_eic_irq_unmask,\n\t.irq_set_type\t= sprd_eic_irq_set_type,\n\t.flags\t\t= IRQCHIP_SKIP_SET_WAKE | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\nstatic int sprd_eic_probe(struct platform_device *pdev)\n{\n\tconst struct sprd_eic_variant_data *pdata;\n\tstruct gpio_irq_chip *irq;\n\tstruct sprd_eic *sprd_eic;\n\tstruct resource *res;\n\tint ret, i;\n\n\tpdata = of_device_get_match_data(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"No matching driver data found.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsprd_eic = devm_kzalloc(&pdev->dev, sizeof(*sprd_eic), GFP_KERNEL);\n\tif (!sprd_eic)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&sprd_eic->lock);\n\tsprd_eic->type = pdata->type;\n\n\tsprd_eic->irq = platform_get_irq(pdev, 0);\n\tif (sprd_eic->irq < 0)\n\t\treturn sprd_eic->irq;\n\n\tfor (i = 0; i < SPRD_EIC_MAX_BANK; i++) {\n\t\t \n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, i);\n\t\tif (!res)\n\t\t\tbreak;\n\n\t\tsprd_eic->base[i] = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(sprd_eic->base[i]))\n\t\t\treturn PTR_ERR(sprd_eic->base[i]);\n\t}\n\n\tsprd_eic->chip.label = sprd_eic_label_name[sprd_eic->type];\n\tsprd_eic->chip.ngpio = pdata->num_eics;\n\tsprd_eic->chip.base = -1;\n\tsprd_eic->chip.parent = &pdev->dev;\n\tsprd_eic->chip.direction_input = sprd_eic_direction_input;\n\tswitch (sprd_eic->type) {\n\tcase SPRD_EIC_DEBOUNCE:\n\t\tsprd_eic->chip.request = sprd_eic_request;\n\t\tsprd_eic->chip.free = sprd_eic_free;\n\t\tsprd_eic->chip.set_config = sprd_eic_set_config;\n\t\tsprd_eic->chip.set = sprd_eic_set;\n\t\tfallthrough;\n\tcase SPRD_EIC_ASYNC:\n\tcase SPRD_EIC_SYNC:\n\t\tsprd_eic->chip.get = sprd_eic_get;\n\t\tbreak;\n\tcase SPRD_EIC_LATCH:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tirq = &sprd_eic->chip.irq;\n\tgpio_irq_chip_set_chip(irq, &sprd_eic_irq);\n\tirq->handler = handle_bad_irq;\n\tirq->default_type = IRQ_TYPE_NONE;\n\tirq->parent_handler = sprd_eic_irq_handler;\n\tirq->parent_handler_data = sprd_eic;\n\tirq->num_parents = 1;\n\tirq->parents = &sprd_eic->irq;\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &sprd_eic->chip, sprd_eic);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Could not register gpiochip %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sprd_eic_of_match[] = {\n\t{\n\t\t.compatible = \"sprd,sc9860-eic-debounce\",\n\t\t.data = &sc9860_eic_dbnc_data,\n\t},\n\t{\n\t\t.compatible = \"sprd,sc9860-eic-latch\",\n\t\t.data = &sc9860_eic_latch_data,\n\t},\n\t{\n\t\t.compatible = \"sprd,sc9860-eic-async\",\n\t\t.data = &sc9860_eic_async_data,\n\t},\n\t{\n\t\t.compatible = \"sprd,sc9860-eic-sync\",\n\t\t.data = &sc9860_eic_sync_data,\n\t},\n\t{\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, sprd_eic_of_match);\n\nstatic struct platform_driver sprd_eic_driver = {\n\t.probe = sprd_eic_probe,\n\t.driver = {\n\t\t.name = \"sprd-eic\",\n\t\t.of_match_table\t= sprd_eic_of_match,\n\t},\n};\n\nmodule_platform_driver(sprd_eic_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum EIC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}