{
  "module_name": "gpio-amdpt.c",
  "hash_id": "310b0dbd055164c3ab40abdcdf8fbab028b2bc34ed304445f4ab0046705d8f7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-amdpt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio/driver.h>\n#include <linux/spinlock.h>\n#include <linux/acpi.h>\n#include <linux/platform_device.h>\n\n#define PT_TOTAL_GPIO 8\n#define PT_TOTAL_GPIO_EX 24\n\n \n#define PT_DIRECTION_REG   0x00\n#define PT_INPUTDATA_REG   0x04\n#define PT_OUTPUTDATA_REG  0x08\n#define PT_CLOCKRATE_REG   0x0C\n#define PT_SYNC_REG        0x28\n\nstruct pt_gpio_chip {\n\tstruct gpio_chip         gc;\n\tvoid __iomem             *reg_base;\n};\n\nstatic int pt_gpio_request(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct pt_gpio_chip *pt_gpio = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tu32 using_pins;\n\n\tdev_dbg(gc->parent, \"pt_gpio_request offset=%x\\n\", offset);\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\n\tusing_pins = readl(pt_gpio->reg_base + PT_SYNC_REG);\n\tif (using_pins & BIT(offset)) {\n\t\tdev_warn(gc->parent, \"PT GPIO pin %x reconfigured\\n\",\n\t\t\t offset);\n\t\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(using_pins | BIT(offset), pt_gpio->reg_base + PT_SYNC_REG);\n\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\n\treturn 0;\n}\n\nstatic void pt_gpio_free(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct pt_gpio_chip *pt_gpio = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tu32 using_pins;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\n\tusing_pins = readl(pt_gpio->reg_base + PT_SYNC_REG);\n\tusing_pins &= ~BIT(offset);\n\twritel(using_pins, pt_gpio->reg_base + PT_SYNC_REG);\n\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\n\tdev_dbg(gc->parent, \"pt_gpio_free offset=%x\\n\", offset);\n}\n\nstatic int pt_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pt_gpio_chip *pt_gpio;\n\tint ret = 0;\n\n\tif (!ACPI_COMPANION(dev)) {\n\t\tdev_err(dev, \"PT GPIO device node not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpt_gpio = devm_kzalloc(dev, sizeof(struct pt_gpio_chip), GFP_KERNEL);\n\tif (!pt_gpio)\n\t\treturn -ENOMEM;\n\n\tpt_gpio->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pt_gpio->reg_base)) {\n\t\tdev_err(dev, \"Failed to map MMIO resource for PT GPIO.\\n\");\n\t\treturn PTR_ERR(pt_gpio->reg_base);\n\t}\n\n\tret = bgpio_init(&pt_gpio->gc, dev, 4,\n\t\t\t pt_gpio->reg_base + PT_INPUTDATA_REG,\n\t\t\t pt_gpio->reg_base + PT_OUTPUTDATA_REG, NULL,\n\t\t\t pt_gpio->reg_base + PT_DIRECTION_REG, NULL,\n\t\t\t BGPIOF_READ_OUTPUT_REG_SET);\n\tif (ret) {\n\t\tdev_err(dev, \"bgpio_init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpt_gpio->gc.owner            = THIS_MODULE;\n\tpt_gpio->gc.request          = pt_gpio_request;\n\tpt_gpio->gc.free             = pt_gpio_free;\n\tpt_gpio->gc.ngpio            = (uintptr_t)device_get_match_data(dev);\n\n\tret = gpiochip_add_data(&pt_gpio->gc, pt_gpio);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register GPIO lib\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, pt_gpio);\n\n\t \n\twritel(0, pt_gpio->reg_base + PT_SYNC_REG);\n\twritel(0, pt_gpio->reg_base + PT_CLOCKRATE_REG);\n\n\tdev_dbg(dev, \"PT GPIO driver loaded\\n\");\n\treturn ret;\n}\n\nstatic int pt_gpio_remove(struct platform_device *pdev)\n{\n\tstruct pt_gpio_chip *pt_gpio = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&pt_gpio->gc);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id pt_gpio_acpi_match[] = {\n\t{ \"AMDF030\", PT_TOTAL_GPIO },\n\t{ \"AMDIF030\", PT_TOTAL_GPIO },\n\t{ \"AMDIF031\", PT_TOTAL_GPIO_EX },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, pt_gpio_acpi_match);\n\nstatic struct platform_driver pt_gpio_driver = {\n\t.driver = {\n\t\t.name = \"pt-gpio\",\n\t\t.acpi_match_table = ACPI_PTR(pt_gpio_acpi_match),\n\t},\n\t.probe = pt_gpio_probe,\n\t.remove = pt_gpio_remove,\n};\n\nmodule_platform_driver(pt_gpio_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"YD Tseng <yd_tseng@asmedia.com.tw>\");\nMODULE_DESCRIPTION(\"AMD Promontory GPIO Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}