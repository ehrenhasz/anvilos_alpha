{
  "module_name": "gpio-tc3589x.c",
  "hash_id": "74c647b872580c04b87359f7e4cea6251ecbef1256f853921fda042b5ced5dba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-tc3589x.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/gpio/driver.h>\n#include <linux/of.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/tc3589x.h>\n#include <linux/bitops.h>\n\n \nenum { REG_IBE, REG_IEV, REG_IS, REG_IE, REG_DIRECT };\n\n#define CACHE_NR_REGS\t5\n#define CACHE_NR_BANKS\t3\n\nstruct tc3589x_gpio {\n\tstruct gpio_chip chip;\n\tstruct tc3589x *tc3589x;\n\tstruct device *dev;\n\tstruct mutex irq_lock;\n\t \n\tu8 regs[CACHE_NR_REGS][CACHE_NR_BANKS];\n\tu8 oldregs[CACHE_NR_REGS][CACHE_NR_BANKS];\n};\n\nstatic int tc3589x_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct tc3589x_gpio *tc3589x_gpio = gpiochip_get_data(chip);\n\tstruct tc3589x *tc3589x = tc3589x_gpio->tc3589x;\n\tu8 reg = TC3589x_GPIODATA0 + (offset / 8) * 2;\n\tu8 mask = BIT(offset % 8);\n\tint ret;\n\n\tret = tc3589x_reg_read(tc3589x, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(ret & mask);\n}\n\nstatic void tc3589x_gpio_set(struct gpio_chip *chip, unsigned int offset, int val)\n{\n\tstruct tc3589x_gpio *tc3589x_gpio = gpiochip_get_data(chip);\n\tstruct tc3589x *tc3589x = tc3589x_gpio->tc3589x;\n\tu8 reg = TC3589x_GPIODATA0 + (offset / 8) * 2;\n\tunsigned int pos = offset % 8;\n\tu8 data[] = {val ? BIT(pos) : 0, BIT(pos)};\n\n\ttc3589x_block_write(tc3589x, reg, ARRAY_SIZE(data), data);\n}\n\nstatic int tc3589x_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t unsigned int offset, int val)\n{\n\tstruct tc3589x_gpio *tc3589x_gpio = gpiochip_get_data(chip);\n\tstruct tc3589x *tc3589x = tc3589x_gpio->tc3589x;\n\tu8 reg = TC3589x_GPIODIR0 + offset / 8;\n\tunsigned int pos = offset % 8;\n\n\ttc3589x_gpio_set(chip, offset, val);\n\n\treturn tc3589x_set_bits(tc3589x, reg, BIT(pos), BIT(pos));\n}\n\nstatic int tc3589x_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int offset)\n{\n\tstruct tc3589x_gpio *tc3589x_gpio = gpiochip_get_data(chip);\n\tstruct tc3589x *tc3589x = tc3589x_gpio->tc3589x;\n\tu8 reg = TC3589x_GPIODIR0 + offset / 8;\n\tunsigned int pos = offset % 8;\n\n\treturn tc3589x_set_bits(tc3589x, reg, BIT(pos), 0);\n}\n\nstatic int tc3589x_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset)\n{\n\tstruct tc3589x_gpio *tc3589x_gpio = gpiochip_get_data(chip);\n\tstruct tc3589x *tc3589x = tc3589x_gpio->tc3589x;\n\tu8 reg = TC3589x_GPIODIR0 + offset / 8;\n\tunsigned int pos = offset % 8;\n\tint ret;\n\n\tret = tc3589x_reg_read(tc3589x, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & BIT(pos))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int tc3589x_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t   unsigned long config)\n{\n\tstruct tc3589x_gpio *tc3589x_gpio = gpiochip_get_data(chip);\n\tstruct tc3589x *tc3589x = tc3589x_gpio->tc3589x;\n\t \n\tu8 odmreg = TC3589x_GPIOODM0 + (offset / 8) * 2;\n\tu8 odereg = TC3589x_GPIOODE0 + (offset / 8) * 2;\n\tunsigned int pos = offset % 8;\n\tint ret;\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t \n\t\tret = tc3589x_set_bits(tc3589x, odmreg, BIT(pos), 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\treturn tc3589x_set_bits(tc3589x, odereg, BIT(pos), BIT(pos));\n\tcase PIN_CONFIG_DRIVE_OPEN_SOURCE:\n\t\t \n\t\tret = tc3589x_set_bits(tc3589x, odmreg, BIT(pos), BIT(pos));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\treturn tc3589x_set_bits(tc3589x, odereg, BIT(pos), BIT(pos));\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\t \n\t\treturn tc3589x_set_bits(tc3589x, odereg, BIT(pos), 0);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -ENOTSUPP;\n}\n\nstatic const struct gpio_chip template_chip = {\n\t.label\t\t\t= \"tc3589x\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.get\t\t\t= tc3589x_gpio_get,\n\t.set\t\t\t= tc3589x_gpio_set,\n\t.direction_output\t= tc3589x_gpio_direction_output,\n\t.direction_input\t= tc3589x_gpio_direction_input,\n\t.get_direction\t\t= tc3589x_gpio_get_direction,\n\t.set_config\t\t= tc3589x_gpio_set_config,\n\t.can_sleep\t\t= true,\n};\n\nstatic int tc3589x_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct tc3589x_gpio *tc3589x_gpio = gpiochip_get_data(gc);\n\tint offset = d->hwirq;\n\tint regoffset = offset / 8;\n\tint mask = BIT(offset % 8);\n\n\tif (type == IRQ_TYPE_EDGE_BOTH) {\n\t\ttc3589x_gpio->regs[REG_IBE][regoffset] |= mask;\n\t\treturn 0;\n\t}\n\n\ttc3589x_gpio->regs[REG_IBE][regoffset] &= ~mask;\n\n\tif (type == IRQ_TYPE_LEVEL_LOW || type == IRQ_TYPE_LEVEL_HIGH)\n\t\ttc3589x_gpio->regs[REG_IS][regoffset] |= mask;\n\telse\n\t\ttc3589x_gpio->regs[REG_IS][regoffset] &= ~mask;\n\n\tif (type == IRQ_TYPE_EDGE_RISING || type == IRQ_TYPE_LEVEL_HIGH)\n\t\ttc3589x_gpio->regs[REG_IEV][regoffset] |= mask;\n\telse\n\t\ttc3589x_gpio->regs[REG_IEV][regoffset] &= ~mask;\n\n\treturn 0;\n}\n\nstatic void tc3589x_gpio_irq_lock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct tc3589x_gpio *tc3589x_gpio = gpiochip_get_data(gc);\n\n\tmutex_lock(&tc3589x_gpio->irq_lock);\n}\n\nstatic void tc3589x_gpio_irq_sync_unlock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct tc3589x_gpio *tc3589x_gpio = gpiochip_get_data(gc);\n\tstruct tc3589x *tc3589x = tc3589x_gpio->tc3589x;\n\tstatic const u8 regmap[] = {\n\t\t[REG_IBE]\t= TC3589x_GPIOIBE0,\n\t\t[REG_IEV]\t= TC3589x_GPIOIEV0,\n\t\t[REG_IS]\t= TC3589x_GPIOIS0,\n\t\t[REG_IE]\t= TC3589x_GPIOIE0,\n\t\t[REG_DIRECT]\t= TC3589x_DIRECT0,\n\t};\n\tint i, j;\n\n\tfor (i = 0; i < CACHE_NR_REGS; i++) {\n\t\tfor (j = 0; j < CACHE_NR_BANKS; j++) {\n\t\t\tu8 old = tc3589x_gpio->oldregs[i][j];\n\t\t\tu8 new = tc3589x_gpio->regs[i][j];\n\n\t\t\tif (new == old)\n\t\t\t\tcontinue;\n\n\t\t\ttc3589x_gpio->oldregs[i][j] = new;\n\t\t\ttc3589x_reg_write(tc3589x, regmap[i] + j, new);\n\t\t}\n\t}\n\n\tmutex_unlock(&tc3589x_gpio->irq_lock);\n}\n\nstatic void tc3589x_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct tc3589x_gpio *tc3589x_gpio = gpiochip_get_data(gc);\n\tint offset = d->hwirq;\n\tint regoffset = offset / 8;\n\tint mask = BIT(offset % 8);\n\n\ttc3589x_gpio->regs[REG_IE][regoffset] &= ~mask;\n\ttc3589x_gpio->regs[REG_DIRECT][regoffset] |= mask;\n\tgpiochip_disable_irq(gc, offset);\n}\n\nstatic void tc3589x_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct tc3589x_gpio *tc3589x_gpio = gpiochip_get_data(gc);\n\tint offset = d->hwirq;\n\tint regoffset = offset / 8;\n\tint mask = BIT(offset % 8);\n\n\tgpiochip_enable_irq(gc, offset);\n\ttc3589x_gpio->regs[REG_IE][regoffset] |= mask;\n\ttc3589x_gpio->regs[REG_DIRECT][regoffset] &= ~mask;\n}\n\nstatic const struct irq_chip tc3589x_gpio_irq_chip = {\n\t.name\t\t\t= \"tc3589x-gpio\",\n\t.irq_bus_lock\t\t= tc3589x_gpio_irq_lock,\n\t.irq_bus_sync_unlock\t= tc3589x_gpio_irq_sync_unlock,\n\t.irq_mask\t\t= tc3589x_gpio_irq_mask,\n\t.irq_unmask\t\t= tc3589x_gpio_irq_unmask,\n\t.irq_set_type\t\t= tc3589x_gpio_irq_set_type,\n\t.flags =\t\tIRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic irqreturn_t tc3589x_gpio_irq(int irq, void *dev)\n{\n\tstruct tc3589x_gpio *tc3589x_gpio = dev;\n\tstruct tc3589x *tc3589x = tc3589x_gpio->tc3589x;\n\tu8 status[CACHE_NR_BANKS];\n\tint ret;\n\tint i;\n\n\tret = tc3589x_block_read(tc3589x, TC3589x_GPIOMIS0,\n\t\t\t\t ARRAY_SIZE(status), status);\n\tif (ret < 0)\n\t\treturn IRQ_NONE;\n\n\tfor (i = 0; i < ARRAY_SIZE(status); i++) {\n\t\tunsigned int stat = status[i];\n\t\tif (!stat)\n\t\t\tcontinue;\n\n\t\twhile (stat) {\n\t\t\tint bit = __ffs(stat);\n\t\t\tint line = i * 8 + bit;\n\t\t\tint irq = irq_find_mapping(tc3589x_gpio->chip.irq.domain,\n\t\t\t\t\t\t   line);\n\n\t\t\thandle_nested_irq(irq);\n\t\t\tstat &= ~(1 << bit);\n\t\t}\n\n\t\ttc3589x_reg_write(tc3589x, TC3589x_GPIOIC0 + i, status[i]);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tc3589x_gpio_probe(struct platform_device *pdev)\n{\n\tstruct tc3589x *tc3589x = dev_get_drvdata(pdev->dev.parent);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct tc3589x_gpio *tc3589x_gpio;\n\tstruct gpio_irq_chip *girq;\n\tint ret;\n\tint irq;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"No Device Tree node found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\ttc3589x_gpio = devm_kzalloc(&pdev->dev, sizeof(struct tc3589x_gpio),\n\t\t\t\t    GFP_KERNEL);\n\tif (!tc3589x_gpio)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&tc3589x_gpio->irq_lock);\n\n\ttc3589x_gpio->dev = &pdev->dev;\n\ttc3589x_gpio->tc3589x = tc3589x;\n\n\ttc3589x_gpio->chip = template_chip;\n\ttc3589x_gpio->chip.ngpio = tc3589x->num_gpio;\n\ttc3589x_gpio->chip.parent = &pdev->dev;\n\ttc3589x_gpio->chip.base = -1;\n\n\tgirq = &tc3589x_gpio->chip.irq;\n\tgpio_irq_chip_set_chip(girq, &tc3589x_gpio_irq_chip);\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_simple_irq;\n\tgirq->threaded = true;\n\n\t \n\tret = tc3589x_set_bits(tc3589x, TC3589x_RSTCTRL,\n\t\t\t       TC3589x_RSTCTRL_GPIRST, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t  \n\tret = tc3589x_reg_write(tc3589x, TC3589x_DKBDMSK,\n\t\t\tTC3589x_DKBDMSK_ELINT | TC3589x_DKBDMSK_EINT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_request_threaded_irq(&pdev->dev,\n\t\t\t\t\tirq, NULL, tc3589x_gpio_irq,\n\t\t\t\t\tIRQF_ONESHOT, \"tc3589x-gpio\",\n\t\t\t\t\ttc3589x_gpio);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to get irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &tc3589x_gpio->chip, tc3589x_gpio);\n}\n\nstatic struct platform_driver tc3589x_gpio_driver = {\n\t.driver.name\t= \"tc3589x-gpio\",\n\t.probe\t\t= tc3589x_gpio_probe,\n};\n\nstatic int __init tc3589x_gpio_init(void)\n{\n\treturn platform_driver_register(&tc3589x_gpio_driver);\n}\nsubsys_initcall(tc3589x_gpio_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}