{
  "module_name": "gpio-tb10x.c",
  "hash_id": "42ea6f00ee483ff5958a78cf32c8dce3b98d8efb83158bec88d1cc2eb707566c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-tb10x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/driver.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/pinctrl/consumer.h>\n\n#define TB10X_GPIO_DIR_IN\t(0x00000000)\n#define TB10X_GPIO_DIR_OUT\t(0x00000001)\n#define OFFSET_TO_REG_DDR\t(0x00)\n#define OFFSET_TO_REG_DATA\t(0x04)\n#define OFFSET_TO_REG_INT_EN\t(0x08)\n#define OFFSET_TO_REG_CHANGE\t(0x0C)\n#define OFFSET_TO_REG_WRMASK\t(0x10)\n#define OFFSET_TO_REG_INT_TYPE\t(0x14)\n\n\n \nstruct tb10x_gpio {\n\tvoid __iomem *base;\n\tstruct irq_domain *domain;\n\tint irq;\n\tstruct gpio_chip gc;\n};\n\nstatic inline u32 tb10x_reg_read(struct tb10x_gpio *gpio, unsigned int offs)\n{\n\treturn ioread32(gpio->base + offs);\n}\n\nstatic inline void tb10x_reg_write(struct tb10x_gpio *gpio, unsigned int offs,\n\t\t\t\tu32 val)\n{\n\tiowrite32(val, gpio->base + offs);\n}\n\nstatic inline void tb10x_set_bits(struct tb10x_gpio *gpio, unsigned int offs,\n\t\t\t\tu32 mask, u32 val)\n{\n\tu32 r;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gpio->gc.bgpio_lock, flags);\n\n\tr = tb10x_reg_read(gpio, offs);\n\tr = (r & ~mask) | (val & mask);\n\n\ttb10x_reg_write(gpio, offs, r);\n\n\traw_spin_unlock_irqrestore(&gpio->gc.bgpio_lock, flags);\n}\n\nstatic int tb10x_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct tb10x_gpio *tb10x_gpio = gpiochip_get_data(chip);\n\n\treturn irq_create_mapping(tb10x_gpio->domain, offset);\n}\n\nstatic int tb10x_gpio_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tif ((type & IRQF_TRIGGER_MASK) != IRQ_TYPE_EDGE_BOTH) {\n\t\tpr_err(\"Only (both) edge triggered interrupts supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirqd_set_trigger_type(data, type);\n\n\treturn IRQ_SET_MASK_OK;\n}\n\nstatic irqreturn_t tb10x_gpio_irq_cascade(int irq, void *data)\n{\n\tstruct tb10x_gpio *tb10x_gpio = data;\n\tu32 r = tb10x_reg_read(tb10x_gpio, OFFSET_TO_REG_CHANGE);\n\tu32 m = tb10x_reg_read(tb10x_gpio, OFFSET_TO_REG_INT_EN);\n\tconst unsigned long bits = r & m;\n\tint i;\n\n\tfor_each_set_bit(i, &bits, 32)\n\t\tgeneric_handle_domain_irq(tb10x_gpio->domain, i);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tb10x_gpio_probe(struct platform_device *pdev)\n{\n\tstruct tb10x_gpio *tb10x_gpio;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint ret = -EBUSY;\n\tu32 ngpio;\n\n\tif (!np)\n\t\treturn -EINVAL;\n\n\tif (of_property_read_u32(np, \"abilis,ngpio\", &ngpio))\n\t\treturn -EINVAL;\n\n\ttb10x_gpio = devm_kzalloc(dev, sizeof(*tb10x_gpio), GFP_KERNEL);\n\tif (tb10x_gpio == NULL)\n\t\treturn -ENOMEM;\n\n\ttb10x_gpio->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tb10x_gpio->base))\n\t\treturn PTR_ERR(tb10x_gpio->base);\n\n\ttb10x_gpio->gc.label =\n\t\tdevm_kasprintf(dev, GFP_KERNEL, \"%pOF\", pdev->dev.of_node);\n\tif (!tb10x_gpio->gc.label)\n\t\treturn -ENOMEM;\n\n\t \n\tret = bgpio_init(&tb10x_gpio->gc, dev, 4,\n\t\t\t tb10x_gpio->base + OFFSET_TO_REG_DATA,\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t tb10x_gpio->base + OFFSET_TO_REG_DDR,\n\t\t\t NULL,\n\t\t\t 0);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to init generic GPIO\\n\");\n\t\treturn ret;\n\t}\n\ttb10x_gpio->gc.base = -1;\n\ttb10x_gpio->gc.parent = dev;\n\ttb10x_gpio->gc.owner = THIS_MODULE;\n\t \n\ttb10x_gpio->gc.ngpio = ngpio;\n\ttb10x_gpio->gc.request = gpiochip_generic_request;\n\ttb10x_gpio->gc.free = gpiochip_generic_free;\n\n\tret = devm_gpiochip_add_data(dev, &tb10x_gpio->gc, tb10x_gpio);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Could not add gpiochip.\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, tb10x_gpio);\n\n\tif (of_property_read_bool(np, \"interrupt-controller\")) {\n\t\tstruct irq_chip_generic *gc;\n\n\t\tret = platform_get_irq(pdev, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttb10x_gpio->gc.to_irq\t= tb10x_gpio_to_irq;\n\t\ttb10x_gpio->irq\t\t= ret;\n\n\t\tret = devm_request_irq(dev, ret, tb10x_gpio_irq_cascade,\n\t\t\t\tIRQF_TRIGGER_NONE | IRQF_SHARED,\n\t\t\t\tdev_name(dev), tb10x_gpio);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\ttb10x_gpio->domain = irq_domain_add_linear(np,\n\t\t\t\t\t\ttb10x_gpio->gc.ngpio,\n\t\t\t\t\t\t&irq_generic_chip_ops, NULL);\n\t\tif (!tb10x_gpio->domain) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tret = irq_alloc_domain_generic_chips(tb10x_gpio->domain,\n\t\t\t\ttb10x_gpio->gc.ngpio, 1, tb10x_gpio->gc.label,\n\t\t\t\thandle_edge_irq, IRQ_NOREQUEST, IRQ_NOPROBE,\n\t\t\t\tIRQ_GC_INIT_MASK_CACHE);\n\t\tif (ret)\n\t\t\tgoto err_remove_domain;\n\n\t\tgc = tb10x_gpio->domain->gc->gc[0];\n\t\tgc->reg_base                         = tb10x_gpio->base;\n\t\tgc->chip_types[0].type               = IRQ_TYPE_EDGE_BOTH;\n\t\tgc->chip_types[0].chip.irq_ack       = irq_gc_ack_set_bit;\n\t\tgc->chip_types[0].chip.irq_mask      = irq_gc_mask_clr_bit;\n\t\tgc->chip_types[0].chip.irq_unmask    = irq_gc_mask_set_bit;\n\t\tgc->chip_types[0].chip.irq_set_type  = tb10x_gpio_irq_set_type;\n\t\tgc->chip_types[0].regs.ack           = OFFSET_TO_REG_CHANGE;\n\t\tgc->chip_types[0].regs.mask          = OFFSET_TO_REG_INT_EN;\n\t}\n\n\treturn 0;\n\nerr_remove_domain:\n\tirq_domain_remove(tb10x_gpio->domain);\n\treturn ret;\n}\n\nstatic int tb10x_gpio_remove(struct platform_device *pdev)\n{\n\tstruct tb10x_gpio *tb10x_gpio = platform_get_drvdata(pdev);\n\n\tif (tb10x_gpio->gc.to_irq) {\n\t\tirq_remove_generic_chip(tb10x_gpio->domain->gc->gc[0],\n\t\t\t\t\tBIT(tb10x_gpio->gc.ngpio) - 1, 0, 0);\n\t\tkfree(tb10x_gpio->domain->gc);\n\t\tirq_domain_remove(tb10x_gpio->domain);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tb10x_gpio_dt_ids[] = {\n\t{ .compatible = \"abilis,tb10x-gpio\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tb10x_gpio_dt_ids);\n\nstatic struct platform_driver tb10x_gpio_driver = {\n\t.probe\t\t= tb10x_gpio_probe,\n\t.remove\t\t= tb10x_gpio_remove,\n\t.driver = {\n\t\t.name\t= \"tb10x-gpio\",\n\t\t.of_match_table = tb10x_gpio_dt_ids,\n\t}\n};\n\nmodule_platform_driver(tb10x_gpio_driver);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"tb10x gpio.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}