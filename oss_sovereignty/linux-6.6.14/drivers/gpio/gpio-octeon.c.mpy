{
  "module_name": "gpio-octeon.c",
  "hash_id": "e24e3afdea74a0572c29c820cda3549bb5caa412300a97cc354a1f19b81064d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-octeon.c",
  "human_readable_source": " \n\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n\n#include <asm/octeon/octeon.h>\n#include <asm/octeon/cvmx-gpio-defs.h>\n\n#define RX_DAT 0x80\n#define TX_SET 0x88\n#define TX_CLEAR 0x90\n \nstatic unsigned int bit_cfg_reg(unsigned int offset)\n{\n\t \n\tif (offset < 16)\n\t\treturn 8 * offset;\n\telse\n\t\treturn 8 * (offset - 16) + 0x100;\n}\n\nstruct octeon_gpio {\n\tstruct gpio_chip chip;\n\tu64 register_base;\n};\n\nstatic int octeon_gpio_dir_in(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct octeon_gpio *gpio = gpiochip_get_data(chip);\n\n\tcvmx_write_csr(gpio->register_base + bit_cfg_reg(offset), 0);\n\treturn 0;\n}\n\nstatic void octeon_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct octeon_gpio *gpio = gpiochip_get_data(chip);\n\tu64 mask = 1ull << offset;\n\tu64 reg = gpio->register_base + (value ? TX_SET : TX_CLEAR);\n\tcvmx_write_csr(reg, mask);\n}\n\nstatic int octeon_gpio_dir_out(struct gpio_chip *chip, unsigned offset,\n\t\t\t       int value)\n{\n\tstruct octeon_gpio *gpio = gpiochip_get_data(chip);\n\tunion cvmx_gpio_bit_cfgx cfgx;\n\n\tocteon_gpio_set(chip, offset, value);\n\n\tcfgx.u64 = 0;\n\tcfgx.s.tx_oe = 1;\n\n\tcvmx_write_csr(gpio->register_base + bit_cfg_reg(offset), cfgx.u64);\n\treturn 0;\n}\n\nstatic int octeon_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct octeon_gpio *gpio = gpiochip_get_data(chip);\n\tu64 read_bits = cvmx_read_csr(gpio->register_base + RX_DAT);\n\n\treturn ((1ull << offset) & read_bits) != 0;\n}\n\nstatic int octeon_gpio_probe(struct platform_device *pdev)\n{\n\tstruct octeon_gpio *gpio;\n\tstruct gpio_chip *chip;\n\tvoid __iomem *reg_base;\n\tint err = 0;\n\n\tgpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\tchip = &gpio->chip;\n\n\treg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reg_base))\n\t\treturn PTR_ERR(reg_base);\n\n\tgpio->register_base = (u64)reg_base;\n\tpdev->dev.platform_data = chip;\n\tchip->label = \"octeon-gpio\";\n\tchip->parent = &pdev->dev;\n\tchip->owner = THIS_MODULE;\n\tchip->base = 0;\n\tchip->can_sleep = false;\n\tchip->ngpio = 20;\n\tchip->direction_input = octeon_gpio_dir_in;\n\tchip->get = octeon_gpio_get;\n\tchip->direction_output = octeon_gpio_dir_out;\n\tchip->set = octeon_gpio_set;\n\terr = devm_gpiochip_add_data(&pdev->dev, chip, gpio);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(&pdev->dev, \"OCTEON GPIO driver probed.\\n\");\n\treturn 0;\n}\n\nstatic const struct of_device_id octeon_gpio_match[] = {\n\t{\n\t\t.compatible = \"cavium,octeon-3860-gpio\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, octeon_gpio_match);\n\nstatic struct platform_driver octeon_gpio_driver = {\n\t.driver = {\n\t\t.name\t\t= \"octeon_gpio\",\n\t\t.of_match_table = octeon_gpio_match,\n\t},\n\t.probe\t\t= octeon_gpio_probe,\n};\n\nmodule_platform_driver(octeon_gpio_driver);\n\nMODULE_DESCRIPTION(\"Cavium Inc. OCTEON GPIO Driver\");\nMODULE_AUTHOR(\"David Daney\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}