{
  "module_name": "gpio-pcie-idio-24.c",
  "hash_id": "070d2c39d76fc6ee98ca1587e6e1bebfe57cea10b6e39c566143d26e1523494f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-pcie-idio-24.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/regmap.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n \n#define PLX_PEX8311_PCI_LCS_INTCSR  0x68\n#define INTCSR_INTERNAL_PCI_WIRE    BIT(8)\n#define INTCSR_LOCAL_INPUT          BIT(11)\n#define IDIO_24_ENABLE_IRQ          (INTCSR_INTERNAL_PCI_WIRE | INTCSR_LOCAL_INPUT)\n\n#define IDIO_24_OUT_BASE 0x0\n#define IDIO_24_TTLCMOS_OUT_REG 0x3\n#define IDIO_24_IN_BASE 0x4\n#define IDIO_24_TTLCMOS_IN_REG 0x7\n#define IDIO_24_COS_STATUS_BASE 0x8\n#define IDIO_24_CONTROL_REG 0xC\n#define IDIO_24_COS_ENABLE 0xE\n#define IDIO_24_SOFT_RESET 0xF\n\n#define CONTROL_REG_OUT_MODE BIT(1)\n\n#define COS_ENABLE_RISING BIT(1)\n#define COS_ENABLE_FALLING BIT(4)\n#define COS_ENABLE_BOTH (COS_ENABLE_RISING | COS_ENABLE_FALLING)\n\nstatic const struct regmap_config pex8311_intcsr_regmap_config = {\n\t.name = \"pex8311_intcsr\",\n\t.reg_bits = 32,\n\t.reg_stride = 1,\n\t.reg_base = PLX_PEX8311_PCI_LCS_INTCSR,\n\t.val_bits = 32,\n\t.io_port = true,\n};\n\nstatic const struct regmap_range idio_24_wr_ranges[] = {\n\tregmap_reg_range(0x0, 0x3), regmap_reg_range(0x8, 0xC),\n\tregmap_reg_range(0xE, 0xF),\n};\nstatic const struct regmap_range idio_24_rd_ranges[] = {\n\tregmap_reg_range(0x0, 0xC), regmap_reg_range(0xE, 0xF),\n};\nstatic const struct regmap_range idio_24_volatile_ranges[] = {\n\tregmap_reg_range(0x4, 0xB), regmap_reg_range(0xF, 0xF),\n};\nstatic const struct regmap_access_table idio_24_wr_table = {\n\t.yes_ranges = idio_24_wr_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(idio_24_wr_ranges),\n};\nstatic const struct regmap_access_table idio_24_rd_table = {\n\t.yes_ranges = idio_24_rd_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(idio_24_rd_ranges),\n};\nstatic const struct regmap_access_table idio_24_volatile_table = {\n\t.yes_ranges = idio_24_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(idio_24_volatile_ranges),\n};\n\nstatic const struct regmap_config idio_24_regmap_config = {\n\t.reg_bits = 8,\n\t.reg_stride = 1,\n\t.val_bits = 8,\n\t.io_port = true,\n\t.wr_table = &idio_24_wr_table,\n\t.rd_table = &idio_24_rd_table,\n\t.volatile_table = &idio_24_volatile_table,\n\t.cache_type = REGCACHE_FLAT,\n\t.use_raw_spinlock = true,\n};\n\n#define IDIO_24_NGPIO_PER_REG 8\n#define IDIO_24_REGMAP_IRQ(_id)\t\t\t\t\t\t\\\n\t[24 + _id] = {\t\t\t\t\t\t\t\\\n\t\t.reg_offset = (_id) / IDIO_24_NGPIO_PER_REG,\t\t\\\n\t\t.mask = BIT((_id) % IDIO_24_NGPIO_PER_REG),\t\t\\\n\t\t.type = { .types_supported = IRQ_TYPE_EDGE_BOTH },\t\\\n\t}\n#define IDIO_24_IIN_IRQ(_id) IDIO_24_REGMAP_IRQ(_id)\n#define IDIO_24_TTL_IRQ(_id) IDIO_24_REGMAP_IRQ(24 + _id)\n\nstatic const struct regmap_irq idio_24_regmap_irqs[] = {\n\tIDIO_24_IIN_IRQ(0), IDIO_24_IIN_IRQ(1), IDIO_24_IIN_IRQ(2),  \n\tIDIO_24_IIN_IRQ(3), IDIO_24_IIN_IRQ(4), IDIO_24_IIN_IRQ(5),  \n\tIDIO_24_IIN_IRQ(6), IDIO_24_IIN_IRQ(7), IDIO_24_IIN_IRQ(8),  \n\tIDIO_24_IIN_IRQ(9), IDIO_24_IIN_IRQ(10), IDIO_24_IIN_IRQ(11),  \n\tIDIO_24_IIN_IRQ(12), IDIO_24_IIN_IRQ(13), IDIO_24_IIN_IRQ(14),  \n\tIDIO_24_IIN_IRQ(15), IDIO_24_IIN_IRQ(16), IDIO_24_IIN_IRQ(17),  \n\tIDIO_24_IIN_IRQ(18), IDIO_24_IIN_IRQ(19), IDIO_24_IIN_IRQ(20),  \n\tIDIO_24_IIN_IRQ(21), IDIO_24_IIN_IRQ(22), IDIO_24_IIN_IRQ(23),  \n\tIDIO_24_TTL_IRQ(0), IDIO_24_TTL_IRQ(1), IDIO_24_TTL_IRQ(2),  \n\tIDIO_24_TTL_IRQ(3), IDIO_24_TTL_IRQ(4), IDIO_24_TTL_IRQ(5),  \n\tIDIO_24_TTL_IRQ(6), IDIO_24_TTL_IRQ(7),  \n};\n\n \nstruct idio_24_gpio {\n\tstruct regmap *map;\n\traw_spinlock_t lock;\n\tu8 irq_type;\n};\n\nstatic int idio_24_handle_mask_sync(const int index, const unsigned int mask_buf_def,\n\t\t\t\t    const unsigned int mask_buf, void *const irq_drv_data)\n{\n\tconst unsigned int type_mask = COS_ENABLE_BOTH << index;\n\tstruct idio_24_gpio *const idio24gpio = irq_drv_data;\n\tu8 type;\n\tint ret;\n\n\traw_spin_lock(&idio24gpio->lock);\n\n\t \n\ttype = (mask_buf == mask_buf_def) ? ~type_mask : idio24gpio->irq_type;\n\n\tret = regmap_update_bits(idio24gpio->map, IDIO_24_COS_ENABLE, type_mask, type);\n\n\traw_spin_unlock(&idio24gpio->lock);\n\n\treturn ret;\n}\n\nstatic int idio_24_set_type_config(unsigned int **const buf, const unsigned int type,\n\t\t\t\t   const struct regmap_irq *const irq_data, const int idx,\n\t\t\t\t   void *const irq_drv_data)\n{\n\tconst unsigned int offset = irq_data->reg_offset;\n\tconst unsigned int rising = COS_ENABLE_RISING << offset;\n\tconst unsigned int falling = COS_ENABLE_FALLING << offset;\n\tconst unsigned int mask = COS_ENABLE_BOTH << offset;\n\tstruct idio_24_gpio *const idio24gpio = irq_drv_data;\n\tunsigned int new;\n\tunsigned int cos_enable;\n\tint ret;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tnew = rising;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tnew = falling;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tnew = mask;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock(&idio24gpio->lock);\n\n\t \n\tidio24gpio->irq_type = (idio24gpio->irq_type & ~mask) | (new & mask);\n\n\tret = regmap_read(idio24gpio->map, IDIO_24_COS_ENABLE, &cos_enable);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\t \n\tif (cos_enable & mask) {\n\t\tret = regmap_update_bits(idio24gpio->map, IDIO_24_COS_ENABLE, mask,\n\t\t\t\t\t idio24gpio->irq_type);\n\t\tif (ret)\n\t\t\tgoto exit_unlock;\n\t}\n\nexit_unlock:\n\traw_spin_unlock(&idio24gpio->lock);\n\n\treturn ret;\n}\n\nstatic int idio_24_reg_mask_xlate(struct gpio_regmap *const gpio, const unsigned int base,\n\t\t\t\t  const unsigned int offset, unsigned int *const reg,\n\t\t\t\t  unsigned int *const mask)\n{\n\tconst unsigned int out_stride = offset / IDIO_24_NGPIO_PER_REG;\n\tconst unsigned int in_stride = (offset - 24) / IDIO_24_NGPIO_PER_REG;\n\tstruct regmap *const map = gpio_regmap_get_drvdata(gpio);\n\tint err;\n\tunsigned int ctrl_reg;\n\n\tswitch (base) {\n\tcase IDIO_24_OUT_BASE:\n\t\t*mask = BIT(offset % IDIO_24_NGPIO_PER_REG);\n\n\t\t \n\t\tif (offset < 24) {\n\t\t\t*reg = IDIO_24_OUT_BASE + out_stride;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (offset < 48) {\n\t\t\t*reg = IDIO_24_IN_BASE + in_stride;\n\t\t\treturn 0;\n\t\t}\n\n\t\terr = regmap_read(map, IDIO_24_CONTROL_REG, &ctrl_reg);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (ctrl_reg & CONTROL_REG_OUT_MODE) {\n\t\t\t*reg = IDIO_24_TTLCMOS_OUT_REG;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\t*reg = IDIO_24_TTLCMOS_IN_REG;\n\t\treturn 0;\n\tcase IDIO_24_CONTROL_REG:\n\t\t \n\t\tif (offset < 48)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t*reg = IDIO_24_CONTROL_REG;\n\t\t*mask = CONTROL_REG_OUT_MODE;\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\n#define IDIO_24_NGPIO 56\nstatic const char *idio_24_names[IDIO_24_NGPIO] = {\n\t\"OUT0\", \"OUT1\", \"OUT2\", \"OUT3\", \"OUT4\", \"OUT5\", \"OUT6\", \"OUT7\",\n\t\"OUT8\", \"OUT9\", \"OUT10\", \"OUT11\", \"OUT12\", \"OUT13\", \"OUT14\", \"OUT15\",\n\t\"OUT16\", \"OUT17\", \"OUT18\", \"OUT19\", \"OUT20\", \"OUT21\", \"OUT22\", \"OUT23\",\n\t\"IIN0\", \"IIN1\", \"IIN2\", \"IIN3\", \"IIN4\", \"IIN5\", \"IIN6\", \"IIN7\",\n\t\"IIN8\", \"IIN9\", \"IIN10\", \"IIN11\", \"IIN12\", \"IIN13\", \"IIN14\", \"IIN15\",\n\t\"IIN16\", \"IIN17\", \"IIN18\", \"IIN19\", \"IIN20\", \"IIN21\", \"IIN22\", \"IIN23\",\n\t\"TTL0\", \"TTL1\", \"TTL2\", \"TTL3\", \"TTL4\", \"TTL5\", \"TTL6\", \"TTL7\"\n};\n\nstatic int idio_24_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct device *const dev = &pdev->dev;\n\tstruct idio_24_gpio *idio24gpio;\n\tint err;\n\tconst size_t pci_plx_bar_index = 1;\n\tconst size_t pci_bar_index = 2;\n\tconst char *const name = pci_name(pdev);\n\tstruct gpio_regmap_config gpio_config = {};\n\tvoid __iomem *pex8311_regs;\n\tvoid __iomem *idio_24_regs;\n\tstruct regmap *intcsr_map;\n\tstruct regmap_irq_chip *chip;\n\tstruct regmap_irq_chip_data *chip_data;\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to enable PCI device (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = pcim_iomap_regions(pdev, BIT(pci_plx_bar_index) | BIT(pci_bar_index), name);\n\tif (err) {\n\t\tdev_err(dev, \"Unable to map PCI I/O addresses (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tpex8311_regs = pcim_iomap_table(pdev)[pci_plx_bar_index];\n\tidio_24_regs = pcim_iomap_table(pdev)[pci_bar_index];\n\n\tintcsr_map = devm_regmap_init_mmio(dev, pex8311_regs, &pex8311_intcsr_regmap_config);\n\tif (IS_ERR(intcsr_map))\n\t\treturn dev_err_probe(dev, PTR_ERR(intcsr_map),\n\t\t\t\t     \"Unable to initialize PEX8311 register map\\n\");\n\n\tidio24gpio = devm_kzalloc(dev, sizeof(*idio24gpio), GFP_KERNEL);\n\tif (!idio24gpio)\n\t\treturn -ENOMEM;\n\n\tidio24gpio->map = devm_regmap_init_mmio(dev, idio_24_regs, &idio_24_regmap_config);\n\tif (IS_ERR(idio24gpio->map))\n\t\treturn dev_err_probe(dev, PTR_ERR(idio24gpio->map),\n\t\t\t\t     \"Unable to initialize register map\\n\");\n\n\traw_spin_lock_init(&idio24gpio->lock);\n\n\t \n\tidio24gpio->irq_type = GENMASK(7, 0);\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->name = name;\n\tchip->status_base = IDIO_24_COS_STATUS_BASE;\n\tchip->mask_base = IDIO_24_COS_ENABLE;\n\tchip->ack_base = IDIO_24_COS_STATUS_BASE;\n\tchip->num_regs = 4;\n\tchip->irqs = idio_24_regmap_irqs;\n\tchip->num_irqs = ARRAY_SIZE(idio_24_regmap_irqs);\n\tchip->handle_mask_sync = idio_24_handle_mask_sync;\n\tchip->set_type_config = idio_24_set_type_config;\n\tchip->irq_drv_data = idio24gpio;\n\n\t \n\terr = regmap_write(idio24gpio->map, IDIO_24_SOFT_RESET, 0);\n\tif (err)\n\t\treturn err;\n\t \n\terr = regmap_update_bits(intcsr_map, 0x0, IDIO_24_ENABLE_IRQ, IDIO_24_ENABLE_IRQ);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_regmap_add_irq_chip(dev, idio24gpio->map, pdev->irq, 0, 0, chip, &chip_data);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"IRQ registration failed\\n\");\n\n\tgpio_config.parent = dev;\n\tgpio_config.regmap = idio24gpio->map;\n\tgpio_config.ngpio = IDIO_24_NGPIO;\n\tgpio_config.names = idio_24_names;\n\tgpio_config.reg_dat_base = GPIO_REGMAP_ADDR(IDIO_24_OUT_BASE);\n\tgpio_config.reg_set_base = GPIO_REGMAP_ADDR(IDIO_24_OUT_BASE);\n\tgpio_config.reg_dir_out_base = GPIO_REGMAP_ADDR(IDIO_24_CONTROL_REG);\n\tgpio_config.ngpio_per_reg = IDIO_24_NGPIO_PER_REG;\n\tgpio_config.irq_domain = regmap_irq_get_domain(chip_data);\n\tgpio_config.reg_mask_xlate = idio_24_reg_mask_xlate;\n\tgpio_config.drvdata = idio24gpio->map;\n\n\treturn PTR_ERR_OR_ZERO(devm_gpio_regmap_register(dev, &gpio_config));\n}\n\nstatic const struct pci_device_id idio_24_pci_dev_id[] = {\n\t{ PCI_DEVICE(0x494F, 0x0FD0) }, { PCI_DEVICE(0x494F, 0x0BD0) },\n\t{ PCI_DEVICE(0x494F, 0x07D0) }, { PCI_DEVICE(0x494F, 0x0FC0) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, idio_24_pci_dev_id);\n\nstatic struct pci_driver idio_24_driver = {\n\t.name = \"pcie-idio-24\",\n\t.id_table = idio_24_pci_dev_id,\n\t.probe = idio_24_probe\n};\n\nmodule_pci_driver(idio_24_driver);\n\nMODULE_AUTHOR(\"William Breathitt Gray <vilhelm.gray@gmail.com>\");\nMODULE_DESCRIPTION(\"ACCES PCIe-IDIO-24 GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}