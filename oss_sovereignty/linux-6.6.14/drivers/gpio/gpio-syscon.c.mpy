{
  "module_name": "gpio-syscon.c",
  "hash_id": "f92f4ccb97d371ab1cc58c50e8c82c0c9490345ff32a3227c83073c47abc2e32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-syscon.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n\n#define GPIO_SYSCON_FEAT_IN\tBIT(0)\n#define GPIO_SYSCON_FEAT_OUT\tBIT(1)\n#define GPIO_SYSCON_FEAT_DIR\tBIT(2)\n\n \n#define SYSCON_REG_SIZE\t\t(4)\n#define SYSCON_REG_BITS\t\t(SYSCON_REG_SIZE * 8)\n\n \n\nstruct syscon_gpio_data {\n\tunsigned int\tflags;\n\tunsigned int\tbit_count;\n\tunsigned int\tdat_bit_offset;\n\tunsigned int\tdir_bit_offset;\n\tvoid\t\t(*set)(struct gpio_chip *chip,\n\t\t\t       unsigned offset, int value);\n};\n\nstruct syscon_gpio_priv {\n\tstruct gpio_chip\t\tchip;\n\tstruct regmap\t\t\t*syscon;\n\tconst struct syscon_gpio_data\t*data;\n\tu32\t\t\t\tdreg_offset;\n\tu32\t\t\t\tdir_reg_offset;\n};\n\nstatic int syscon_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct syscon_gpio_priv *priv = gpiochip_get_data(chip);\n\tunsigned int val, offs;\n\tint ret;\n\n\toffs = priv->dreg_offset + priv->data->dat_bit_offset + offset;\n\n\tret = regmap_read(priv->syscon,\n\t\t\t  (offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & BIT(offs % SYSCON_REG_BITS));\n}\n\nstatic void syscon_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\n{\n\tstruct syscon_gpio_priv *priv = gpiochip_get_data(chip);\n\tunsigned int offs;\n\n\toffs = priv->dreg_offset + priv->data->dat_bit_offset + offset;\n\n\tregmap_update_bits(priv->syscon,\n\t\t\t   (offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE,\n\t\t\t   BIT(offs % SYSCON_REG_BITS),\n\t\t\t   val ? BIT(offs % SYSCON_REG_BITS) : 0);\n}\n\nstatic int syscon_gpio_dir_in(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct syscon_gpio_priv *priv = gpiochip_get_data(chip);\n\n\tif (priv->data->flags & GPIO_SYSCON_FEAT_DIR) {\n\t\tunsigned int offs;\n\n\t\toffs = priv->dir_reg_offset +\n\t\t       priv->data->dir_bit_offset + offset;\n\n\t\tregmap_update_bits(priv->syscon,\n\t\t\t\t   (offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE,\n\t\t\t\t   BIT(offs % SYSCON_REG_BITS), 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int syscon_gpio_dir_out(struct gpio_chip *chip, unsigned offset, int val)\n{\n\tstruct syscon_gpio_priv *priv = gpiochip_get_data(chip);\n\n\tif (priv->data->flags & GPIO_SYSCON_FEAT_DIR) {\n\t\tunsigned int offs;\n\n\t\toffs = priv->dir_reg_offset +\n\t\t       priv->data->dir_bit_offset + offset;\n\n\t\tregmap_update_bits(priv->syscon,\n\t\t\t\t   (offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE,\n\t\t\t\t   BIT(offs % SYSCON_REG_BITS),\n\t\t\t\t   BIT(offs % SYSCON_REG_BITS));\n\t}\n\n\tchip->set(chip, offset, val);\n\n\treturn 0;\n}\n\nstatic const struct syscon_gpio_data clps711x_mctrl_gpio = {\n\t \n\t.flags\t\t= GPIO_SYSCON_FEAT_IN,\n\t.bit_count\t= 3,\n\t.dat_bit_offset\t= 0x40 * 8 + 8,\n};\n\nstatic void rockchip_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t      int val)\n{\n\tstruct syscon_gpio_priv *priv = gpiochip_get_data(chip);\n\tunsigned int offs;\n\tu8 bit;\n\tu32 data;\n\tint ret;\n\n\toffs = priv->dreg_offset + priv->data->dat_bit_offset + offset;\n\tbit = offs % SYSCON_REG_BITS;\n\tdata = (val ? BIT(bit) : 0) | BIT(bit + 16);\n\tret = regmap_write(priv->syscon,\n\t\t\t   (offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE,\n\t\t\t   data);\n\tif (ret < 0)\n\t\tdev_err(chip->parent, \"gpio write failed ret(%d)\\n\", ret);\n}\n\nstatic const struct syscon_gpio_data rockchip_rk3328_gpio_mute = {\n\t \n\t.flags\t\t= GPIO_SYSCON_FEAT_OUT,\n\t.bit_count\t= 1,\n\t.dat_bit_offset = 0x0428 * 8 + 1,\n\t.set\t\t= rockchip_gpio_set,\n};\n\n#define KEYSTONE_LOCK_BIT BIT(0)\n\nstatic void keystone_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\n{\n\tstruct syscon_gpio_priv *priv = gpiochip_get_data(chip);\n\tunsigned int offs;\n\tint ret;\n\n\toffs = priv->dreg_offset + priv->data->dat_bit_offset + offset;\n\n\tif (!val)\n\t\treturn;\n\n\tret = regmap_update_bits(\n\t\t\tpriv->syscon,\n\t\t\t(offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE,\n\t\t\tBIT(offs % SYSCON_REG_BITS) | KEYSTONE_LOCK_BIT,\n\t\t\tBIT(offs % SYSCON_REG_BITS) | KEYSTONE_LOCK_BIT);\n\tif (ret < 0)\n\t\tdev_err(chip->parent, \"gpio write failed ret(%d)\\n\", ret);\n}\n\nstatic const struct syscon_gpio_data keystone_dsp_gpio = {\n\t \n\t.flags\t\t= GPIO_SYSCON_FEAT_OUT,\n\t.bit_count\t= 28,\n\t.dat_bit_offset\t= 4,\n\t.set\t\t= keystone_gpio_set,\n};\n\nstatic const struct of_device_id syscon_gpio_ids[] = {\n\t{\n\t\t.compatible\t= \"cirrus,ep7209-mctrl-gpio\",\n\t\t.data\t\t= &clps711x_mctrl_gpio,\n\t},\n\t{\n\t\t.compatible\t= \"ti,keystone-dsp-gpio\",\n\t\t.data\t\t= &keystone_dsp_gpio,\n\t},\n\t{\n\t\t.compatible\t= \"rockchip,rk3328-grf-gpio\",\n\t\t.data\t\t= &rockchip_rk3328_gpio_mute,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, syscon_gpio_ids);\n\nstatic int syscon_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct syscon_gpio_priv *priv;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->data = of_device_get_match_data(dev);\n\n\tpriv->syscon = syscon_regmap_lookup_by_phandle(np, \"gpio,syscon-dev\");\n\tif (IS_ERR(priv->syscon) && np->parent)\n\t\tpriv->syscon = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(priv->syscon))\n\t\treturn PTR_ERR(priv->syscon);\n\n\tret = of_property_read_u32_index(np, \"gpio,syscon-dev\", 1,\n\t\t\t\t\t &priv->dreg_offset);\n\tif (ret)\n\t\tdev_err(dev, \"can't read the data register offset!\\n\");\n\n\tpriv->dreg_offset <<= 3;\n\n\tret = of_property_read_u32_index(np, \"gpio,syscon-dev\", 2,\n\t\t\t\t\t &priv->dir_reg_offset);\n\tif (ret)\n\t\tdev_dbg(dev, \"can't read the dir register offset!\\n\");\n\n\tpriv->dir_reg_offset <<= 3;\n\n\tpriv->chip.parent = dev;\n\tpriv->chip.owner = THIS_MODULE;\n\tpriv->chip.label = dev_name(dev);\n\tpriv->chip.base = -1;\n\tpriv->chip.ngpio = priv->data->bit_count;\n\tpriv->chip.get = syscon_gpio_get;\n\tif (priv->data->flags & GPIO_SYSCON_FEAT_IN)\n\t\tpriv->chip.direction_input = syscon_gpio_dir_in;\n\tif (priv->data->flags & GPIO_SYSCON_FEAT_OUT) {\n\t\tpriv->chip.set = priv->data->set ? : syscon_gpio_set;\n\t\tpriv->chip.direction_output = syscon_gpio_dir_out;\n\t}\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &priv->chip, priv);\n}\n\nstatic struct platform_driver syscon_gpio_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"gpio-syscon\",\n\t\t.of_match_table\t= syscon_gpio_ids,\n\t},\n\t.probe\t= syscon_gpio_probe,\n};\nmodule_platform_driver(syscon_gpio_driver);\n\nMODULE_AUTHOR(\"Alexander Shiyan <shc_work@mail.ru>\");\nMODULE_DESCRIPTION(\"SYSCON GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}