{
  "module_name": "gpio-grgpio.c",
  "hash_id": "3a9ded59d30531d33361d42f4dc9bb93cf6e08400dfc9d101eee99b7f2c83e92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-grgpio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/gpio/driver.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/bitops.h>\n\n#define GRGPIO_MAX_NGPIO 32\n\n#define GRGPIO_DATA\t\t0x00\n#define GRGPIO_OUTPUT\t\t0x04\n#define GRGPIO_DIR\t\t0x08\n#define GRGPIO_IMASK\t\t0x0c\n#define GRGPIO_IPOL\t\t0x10\n#define GRGPIO_IEDGE\t\t0x14\n#define GRGPIO_BYPASS\t\t0x18\n#define GRGPIO_IMAP_BASE\t0x20\n\n \nstruct grgpio_uirq {\n\tu8 refcnt;  \n\tu8 uirq;  \n};\n\n \nstruct grgpio_lirq {\n\ts8 index;  \n\tu8 irq;  \n};\n\nstruct grgpio_priv {\n\tstruct gpio_chip gc;\n\tvoid __iomem *regs;\n\tstruct device *dev;\n\n\tu32 imask;  \n\n\t \n\tstruct irq_domain *domain;\n\n\t \n\tstruct grgpio_uirq uirqs[GRGPIO_MAX_NGPIO];\n\n\t \n\tstruct grgpio_lirq lirqs[GRGPIO_MAX_NGPIO];\n};\n\nstatic void grgpio_set_imask(struct grgpio_priv *priv, unsigned int offset,\n\t\t\t     int val)\n{\n\tstruct gpio_chip *gc = &priv->gc;\n\n\tif (val)\n\t\tpriv->imask |= BIT(offset);\n\telse\n\t\tpriv->imask &= ~BIT(offset);\n\tgc->write_reg(priv->regs + GRGPIO_IMASK, priv->imask);\n}\n\nstatic int grgpio_to_irq(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct grgpio_priv *priv = gpiochip_get_data(gc);\n\n\tif (offset >= gc->ngpio)\n\t\treturn -ENXIO;\n\n\tif (priv->lirqs[offset].index < 0)\n\t\treturn -ENXIO;\n\n\treturn irq_create_mapping(priv->domain, offset);\n}\n\n \n\nstatic int grgpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct grgpio_priv *priv = irq_data_get_irq_chip_data(d);\n\tunsigned long flags;\n\tu32 mask = BIT(d->hwirq);\n\tu32 ipol;\n\tu32 iedge;\n\tu32 pol;\n\tu32 edge;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tpol = 0;\n\t\tedge = 0;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tpol = mask;\n\t\tedge = 0;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tpol = 0;\n\t\tedge = mask;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tpol = mask;\n\t\tedge = mask;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&priv->gc.bgpio_lock, flags);\n\n\tipol = priv->gc.read_reg(priv->regs + GRGPIO_IPOL) & ~mask;\n\tiedge = priv->gc.read_reg(priv->regs + GRGPIO_IEDGE) & ~mask;\n\n\tpriv->gc.write_reg(priv->regs + GRGPIO_IPOL, ipol | pol);\n\tpriv->gc.write_reg(priv->regs + GRGPIO_IEDGE, iedge | edge);\n\n\traw_spin_unlock_irqrestore(&priv->gc.bgpio_lock, flags);\n\n\treturn 0;\n}\n\nstatic void grgpio_irq_mask(struct irq_data *d)\n{\n\tstruct grgpio_priv *priv = irq_data_get_irq_chip_data(d);\n\tint offset = d->hwirq;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&priv->gc.bgpio_lock, flags);\n\n\tgrgpio_set_imask(priv, offset, 0);\n\n\traw_spin_unlock_irqrestore(&priv->gc.bgpio_lock, flags);\n}\n\nstatic void grgpio_irq_unmask(struct irq_data *d)\n{\n\tstruct grgpio_priv *priv = irq_data_get_irq_chip_data(d);\n\tint offset = d->hwirq;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&priv->gc.bgpio_lock, flags);\n\n\tgrgpio_set_imask(priv, offset, 1);\n\n\traw_spin_unlock_irqrestore(&priv->gc.bgpio_lock, flags);\n}\n\nstatic struct irq_chip grgpio_irq_chip = {\n\t.name\t\t\t= \"grgpio\",\n\t.irq_mask\t\t= grgpio_irq_mask,\n\t.irq_unmask\t\t= grgpio_irq_unmask,\n\t.irq_set_type\t\t= grgpio_irq_set_type,\n};\n\nstatic irqreturn_t grgpio_irq_handler(int irq, void *dev)\n{\n\tstruct grgpio_priv *priv = dev;\n\tint ngpio = priv->gc.ngpio;\n\tunsigned long flags;\n\tint i;\n\tint match = 0;\n\n\traw_spin_lock_irqsave(&priv->gc.bgpio_lock, flags);\n\n\t \n\tfor (i = 0; i < ngpio; i++) {\n\t\tstruct grgpio_lirq *lirq = &priv->lirqs[i];\n\n\t\tif (priv->imask & BIT(i) && lirq->index >= 0 &&\n\t\t    priv->uirqs[lirq->index].uirq == irq) {\n\t\t\tgeneric_handle_irq(lirq->irq);\n\t\t\tmatch = 1;\n\t\t}\n\t}\n\n\traw_spin_unlock_irqrestore(&priv->gc.bgpio_lock, flags);\n\n\tif (!match)\n\t\tdev_warn(priv->dev, \"No gpio line matched irq %d\\n\", irq);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int grgpio_irq_map(struct irq_domain *d, unsigned int irq,\n\t\t\t  irq_hw_number_t hwirq)\n{\n\tstruct grgpio_priv *priv = d->host_data;\n\tstruct grgpio_lirq *lirq;\n\tstruct grgpio_uirq *uirq;\n\tunsigned long flags;\n\tint offset = hwirq;\n\tint ret = 0;\n\n\tif (!priv)\n\t\treturn -EINVAL;\n\n\tlirq = &priv->lirqs[offset];\n\tif (lirq->index < 0)\n\t\treturn -EINVAL;\n\n\tdev_dbg(priv->dev, \"Mapping irq %d for gpio line %d\\n\",\n\t\tirq, offset);\n\n\traw_spin_lock_irqsave(&priv->gc.bgpio_lock, flags);\n\n\t \n\tlirq->irq = irq;\n\tuirq = &priv->uirqs[lirq->index];\n\tif (uirq->refcnt == 0) {\n\t\traw_spin_unlock_irqrestore(&priv->gc.bgpio_lock, flags);\n\t\tret = request_irq(uirq->uirq, grgpio_irq_handler, 0,\n\t\t\t\t  dev_name(priv->dev), priv);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"Could not request underlying irq %d\\n\",\n\t\t\t\tuirq->uirq);\n\t\t\treturn ret;\n\t\t}\n\t\traw_spin_lock_irqsave(&priv->gc.bgpio_lock, flags);\n\t}\n\tuirq->refcnt++;\n\n\traw_spin_unlock_irqrestore(&priv->gc.bgpio_lock, flags);\n\n\t \n\tirq_set_chip_data(irq, priv);\n\tirq_set_chip_and_handler(irq, &grgpio_irq_chip,\n\t\t\t\t handle_simple_irq);\n\tirq_set_noprobe(irq);\n\n\treturn ret;\n}\n\nstatic void grgpio_irq_unmap(struct irq_domain *d, unsigned int irq)\n{\n\tstruct grgpio_priv *priv = d->host_data;\n\tint index;\n\tstruct grgpio_lirq *lirq;\n\tstruct grgpio_uirq *uirq;\n\tunsigned long flags;\n\tint ngpio = priv->gc.ngpio;\n\tint i;\n\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\tirq_set_chip_data(irq, NULL);\n\n\traw_spin_lock_irqsave(&priv->gc.bgpio_lock, flags);\n\n\t \n\tindex = -1;\n\tfor (i = 0; i < ngpio; i++) {\n\t\tlirq = &priv->lirqs[i];\n\t\tif (lirq->irq == irq) {\n\t\t\tgrgpio_set_imask(priv, i, 0);\n\t\t\tlirq->irq = 0;\n\t\t\tindex = lirq->index;\n\t\t\tbreak;\n\t\t}\n\t}\n\tWARN_ON(index < 0);\n\n\tif (index >= 0) {\n\t\tuirq = &priv->uirqs[lirq->index];\n\t\tuirq->refcnt--;\n\t\tif (uirq->refcnt == 0) {\n\t\t\traw_spin_unlock_irqrestore(&priv->gc.bgpio_lock, flags);\n\t\t\tfree_irq(uirq->uirq, priv);\n\t\t\treturn;\n\t\t}\n\t}\n\n\traw_spin_unlock_irqrestore(&priv->gc.bgpio_lock, flags);\n}\n\nstatic const struct irq_domain_ops grgpio_irq_domain_ops = {\n\t.map\t= grgpio_irq_map,\n\t.unmap\t= grgpio_irq_unmap,\n};\n\n \n\nstatic int grgpio_probe(struct platform_device *ofdev)\n{\n\tstruct device_node *np = ofdev->dev.of_node;\n\tvoid  __iomem *regs;\n\tstruct gpio_chip *gc;\n\tstruct grgpio_priv *priv;\n\tint err;\n\tu32 prop;\n\ts32 *irqmap;\n\tint size;\n\tint i;\n\n\tpriv = devm_kzalloc(&ofdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tregs = devm_platform_ioremap_resource(ofdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tgc = &priv->gc;\n\terr = bgpio_init(gc, &ofdev->dev, 4, regs + GRGPIO_DATA,\n\t\t\t regs + GRGPIO_OUTPUT, NULL, regs + GRGPIO_DIR, NULL,\n\t\t\t BGPIOF_BIG_ENDIAN_BYTE_ORDER);\n\tif (err) {\n\t\tdev_err(&ofdev->dev, \"bgpio_init() failed\\n\");\n\t\treturn err;\n\t}\n\n\tpriv->regs = regs;\n\tpriv->imask = gc->read_reg(regs + GRGPIO_IMASK);\n\tpriv->dev = &ofdev->dev;\n\n\tgc->owner = THIS_MODULE;\n\tgc->to_irq = grgpio_to_irq;\n\tgc->label = devm_kasprintf(&ofdev->dev, GFP_KERNEL, \"%pOF\", np);\n\tgc->base = -1;\n\n\terr = of_property_read_u32(np, \"nbits\", &prop);\n\tif (err || prop <= 0 || prop > GRGPIO_MAX_NGPIO) {\n\t\tgc->ngpio = GRGPIO_MAX_NGPIO;\n\t\tdev_dbg(&ofdev->dev,\n\t\t\t\"No or invalid nbits property: assume %d\\n\", gc->ngpio);\n\t} else {\n\t\tgc->ngpio = prop;\n\t}\n\n\t \n\tirqmap = (s32 *)of_get_property(np, \"irqmap\", &size);\n\tif (irqmap) {\n\t\tif (size < gc->ngpio) {\n\t\t\tdev_err(&ofdev->dev,\n\t\t\t\t\"irqmap shorter than ngpio (%d < %d)\\n\",\n\t\t\t\tsize, gc->ngpio);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpriv->domain = irq_domain_add_linear(np, gc->ngpio,\n\t\t\t\t\t\t     &grgpio_irq_domain_ops,\n\t\t\t\t\t\t     priv);\n\t\tif (!priv->domain) {\n\t\t\tdev_err(&ofdev->dev, \"Could not add irq domain\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < gc->ngpio; i++) {\n\t\t\tstruct grgpio_lirq *lirq;\n\t\t\tint ret;\n\n\t\t\tlirq = &priv->lirqs[i];\n\t\t\tlirq->index = irqmap[i];\n\n\t\t\tif (lirq->index < 0)\n\t\t\t\tcontinue;\n\n\t\t\tret = platform_get_irq(ofdev, lirq->index);\n\t\t\tif (ret <= 0) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpriv->uirqs[lirq->index].uirq = ret;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(ofdev, priv);\n\n\terr = gpiochip_add_data(gc, priv);\n\tif (err) {\n\t\tdev_err(&ofdev->dev, \"Could not add gpiochip\\n\");\n\t\tif (priv->domain)\n\t\t\tirq_domain_remove(priv->domain);\n\t\treturn err;\n\t}\n\n\tdev_info(&ofdev->dev, \"regs=0x%p, base=%d, ngpio=%d, irqs=%s\\n\",\n\t\t priv->regs, gc->base, gc->ngpio, priv->domain ? \"on\" : \"off\");\n\n\treturn 0;\n}\n\nstatic int grgpio_remove(struct platform_device *ofdev)\n{\n\tstruct grgpio_priv *priv = platform_get_drvdata(ofdev);\n\n\tgpiochip_remove(&priv->gc);\n\n\tif (priv->domain)\n\t\tirq_domain_remove(priv->domain);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id grgpio_match[] = {\n\t{.name = \"GAISLER_GPIO\"},\n\t{.name = \"01_01a\"},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, grgpio_match);\n\nstatic struct platform_driver grgpio_driver = {\n\t.driver = {\n\t\t.name = \"grgpio\",\n\t\t.of_match_table = grgpio_match,\n\t},\n\t.probe = grgpio_probe,\n\t.remove = grgpio_remove,\n};\nmodule_platform_driver(grgpio_driver);\n\nMODULE_AUTHOR(\"Aeroflex Gaisler AB.\");\nMODULE_DESCRIPTION(\"Driver for Aeroflex Gaisler GRGPIO\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}