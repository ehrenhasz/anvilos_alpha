{
  "module_name": "gpio-xgs-iproc.c",
  "hash_id": "25c4689c2174fa5c00e445c12a95d930d6e5925326c8a828f3856c9ad5579ba8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-xgs-iproc.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n#define IPROC_CCA_INT_F_GPIOINT\t\tBIT(0)\n#define IPROC_CCA_INT_STS\t\t0x20\n#define IPROC_CCA_INT_MASK\t\t0x24\n\n#define IPROC_GPIO_CCA_DIN\t\t0x0\n#define IPROC_GPIO_CCA_DOUT\t\t0x4\n#define IPROC_GPIO_CCA_OUT_EN\t\t0x8\n#define IPROC_GPIO_CCA_INT_LEVEL\t0x10\n#define IPROC_GPIO_CCA_INT_LEVEL_MASK\t0x14\n#define IPROC_GPIO_CCA_INT_EVENT\t0x18\n#define IPROC_GPIO_CCA_INT_EVENT_MASK\t0x1C\n#define IPROC_GPIO_CCA_INT_EDGE\t\t0x24\n\nstruct iproc_gpio_chip {\n\tstruct gpio_chip gc;\n\tspinlock_t lock;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tvoid __iomem *intr;\n};\n\nstatic inline struct iproc_gpio_chip *\nto_iproc_gpio(struct gpio_chip *gc)\n{\n\treturn container_of(gc, struct iproc_gpio_chip, gc);\n}\n\nstatic void iproc_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct iproc_gpio_chip *chip = to_iproc_gpio(gc);\n\tint pin = d->hwirq;\n\tunsigned long flags;\n\tu32 irq = d->irq;\n\tu32 irq_type, event_status = 0;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tirq_type = irq_get_trigger_type(irq);\n\tif (irq_type & IRQ_TYPE_EDGE_BOTH) {\n\t\tevent_status |= BIT(pin);\n\t\twritel_relaxed(event_status,\n\t\t\t       chip->base + IPROC_GPIO_CCA_INT_EVENT);\n\t}\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n\nstatic void iproc_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct iproc_gpio_chip *chip = to_iproc_gpio(gc);\n\tint pin = d->hwirq;\n\tunsigned long flags;\n\tu32 irq = d->irq;\n\tu32 int_mask, irq_type, event_mask;\n\n\tgpiochip_enable_irq(gc, pin);\n\tspin_lock_irqsave(&chip->lock, flags);\n\tirq_type = irq_get_trigger_type(irq);\n\tevent_mask = readl_relaxed(chip->base + IPROC_GPIO_CCA_INT_EVENT_MASK);\n\tint_mask = readl_relaxed(chip->base + IPROC_GPIO_CCA_INT_LEVEL_MASK);\n\n\tif (irq_type & IRQ_TYPE_EDGE_BOTH) {\n\t\tevent_mask |= 1 << pin;\n\t\twritel_relaxed(event_mask,\n\t\t\t       chip->base + IPROC_GPIO_CCA_INT_EVENT_MASK);\n\t} else {\n\t\tint_mask |= 1 << pin;\n\t\twritel_relaxed(int_mask,\n\t\t\t       chip->base + IPROC_GPIO_CCA_INT_LEVEL_MASK);\n\t}\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n\nstatic void iproc_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct iproc_gpio_chip *chip = to_iproc_gpio(gc);\n\tint pin = d->hwirq;\n\tunsigned long flags;\n\tu32 irq = d->irq;\n\tu32 irq_type, int_mask, event_mask;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tirq_type = irq_get_trigger_type(irq);\n\tevent_mask = readl_relaxed(chip->base + IPROC_GPIO_CCA_INT_EVENT_MASK);\n\tint_mask = readl_relaxed(chip->base + IPROC_GPIO_CCA_INT_LEVEL_MASK);\n\n\tif (irq_type & IRQ_TYPE_EDGE_BOTH) {\n\t\tevent_mask &= ~BIT(pin);\n\t\twritel_relaxed(event_mask,\n\t\t\t       chip->base + IPROC_GPIO_CCA_INT_EVENT_MASK);\n\t} else {\n\t\tint_mask &= ~BIT(pin);\n\t\twritel_relaxed(int_mask,\n\t\t\t       chip->base + IPROC_GPIO_CCA_INT_LEVEL_MASK);\n\t}\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\tgpiochip_disable_irq(gc, pin);\n}\n\nstatic int iproc_gpio_irq_set_type(struct irq_data *d, u32 type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct iproc_gpio_chip *chip = to_iproc_gpio(gc);\n\tint pin = d->hwirq;\n\tunsigned long flags;\n\tu32 irq = d->irq;\n\tu32 event_pol, int_pol;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tevent_pol = readl_relaxed(chip->base + IPROC_GPIO_CCA_INT_EDGE);\n\t\tevent_pol &= ~BIT(pin);\n\t\twritel_relaxed(event_pol, chip->base + IPROC_GPIO_CCA_INT_EDGE);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tevent_pol = readl_relaxed(chip->base + IPROC_GPIO_CCA_INT_EDGE);\n\t\tevent_pol |= BIT(pin);\n\t\twritel_relaxed(event_pol, chip->base + IPROC_GPIO_CCA_INT_EDGE);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tint_pol = readl_relaxed(chip->base + IPROC_GPIO_CCA_INT_LEVEL);\n\t\tint_pol &= ~BIT(pin);\n\t\twritel_relaxed(int_pol, chip->base + IPROC_GPIO_CCA_INT_LEVEL);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tint_pol = readl_relaxed(chip->base + IPROC_GPIO_CCA_INT_LEVEL);\n\t\tint_pol |= BIT(pin);\n\t\twritel_relaxed(int_pol, chip->base + IPROC_GPIO_CCA_INT_LEVEL);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (type & IRQ_TYPE_LEVEL_MASK)\n\t\tirq_set_handler_locked(irq_get_irq_data(irq), handle_level_irq);\n\telse if (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(irq_get_irq_data(irq), handle_edge_irq);\n\nout_unlock:\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn ret;\n}\n\nstatic irqreturn_t iproc_gpio_irq_handler(int irq, void *data)\n{\n\tstruct gpio_chip *gc = (struct gpio_chip *)data;\n\tstruct iproc_gpio_chip *chip = to_iproc_gpio(gc);\n\tint bit;\n\tunsigned long int_bits = 0;\n\tu32 int_status;\n\n\t \n\tint_status = readl_relaxed(chip->intr + IPROC_CCA_INT_STS);\n\tif (int_status & IPROC_CCA_INT_F_GPIOINT) {\n\t\tu32 event, level;\n\n\t\t \n\t\tevent =\n\t\t    readl_relaxed(chip->base + IPROC_GPIO_CCA_INT_EVENT_MASK);\n\t\tevent &= readl_relaxed(chip->base + IPROC_GPIO_CCA_INT_EVENT);\n\t\tlevel = readl_relaxed(chip->base + IPROC_GPIO_CCA_DIN);\n\t\tlevel ^= readl_relaxed(chip->base + IPROC_GPIO_CCA_INT_LEVEL);\n\t\tlevel &=\n\t\t    readl_relaxed(chip->base + IPROC_GPIO_CCA_INT_LEVEL_MASK);\n\t\tint_bits = level | event;\n\n\t\tfor_each_set_bit(bit, &int_bits, gc->ngpio)\n\t\t\tgeneric_handle_domain_irq(gc->irq.domain, bit);\n\t}\n\n\treturn int_bits ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic void iproc_gpio_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct iproc_gpio_chip *chip = to_iproc_gpio(gc);\n\n\tseq_printf(p, dev_name(chip->dev));\n}\n\nstatic const struct irq_chip iproc_gpio_irq_chip = {\n\t.irq_ack = iproc_gpio_irq_ack,\n\t.irq_mask = iproc_gpio_irq_mask,\n\t.irq_unmask = iproc_gpio_irq_unmask,\n\t.irq_set_type = iproc_gpio_irq_set_type,\n\t.irq_print_chip = iproc_gpio_irq_print_chip,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int iproc_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *dn = pdev->dev.of_node;\n\tstruct iproc_gpio_chip *chip;\n\tu32 num_gpios;\n\tint irq, ret;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = dev;\n\tplatform_set_drvdata(pdev, chip);\n\tspin_lock_init(&chip->lock);\n\n\tchip->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(chip->base))\n\t\treturn PTR_ERR(chip->base);\n\n\tret = bgpio_init(&chip->gc, dev, 4,\n\t\t\t chip->base + IPROC_GPIO_CCA_DIN,\n\t\t\t chip->base + IPROC_GPIO_CCA_DOUT,\n\t\t\t NULL,\n\t\t\t chip->base + IPROC_GPIO_CCA_OUT_EN,\n\t\t\t NULL,\n\t\t\t 0);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to init GPIO chip\\n\");\n\t\treturn ret;\n\t}\n\n\tchip->gc.label = dev_name(dev);\n\tif (!of_property_read_u32(dn, \"ngpios\", &num_gpios))\n\t\tchip->gc.ngpio = num_gpios;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq > 0) {\n\t\tstruct gpio_irq_chip *girq;\n\t\tu32 val;\n\n\t\tchip->intr = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(chip->intr))\n\t\t\treturn PTR_ERR(chip->intr);\n\n\t\t \n\t\tval = readl_relaxed(chip->intr + IPROC_CCA_INT_MASK);\n\t\tval |= IPROC_CCA_INT_F_GPIOINT;\n\t\twritel_relaxed(val, chip->intr + IPROC_CCA_INT_MASK);\n\n\t\t \n\t\tret = devm_request_irq(dev, irq, iproc_gpio_irq_handler,\n\t\t\t\t       IRQF_SHARED, chip->gc.label, &chip->gc);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Fail to request IRQ%d: %d\\n\", irq, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tgirq = &chip->gc.irq;\n\t\tgpio_irq_chip_set_chip(girq, &iproc_gpio_irq_chip);\n\t\t \n\t\tgirq->parent_handler = NULL;\n\t\tgirq->num_parents = 0;\n\t\tgirq->parents = NULL;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_simple_irq;\n\t}\n\n\tret = devm_gpiochip_add_data(dev, &chip->gc, chip);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to add GPIO chip\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int iproc_gpio_remove(struct platform_device *pdev)\n{\n\tstruct iproc_gpio_chip *chip = platform_get_drvdata(pdev);\n\n\tif (chip->intr) {\n\t\tu32 val;\n\n\t\tval = readl_relaxed(chip->intr + IPROC_CCA_INT_MASK);\n\t\tval &= ~IPROC_CCA_INT_F_GPIOINT;\n\t\twritel_relaxed(val, chip->intr + IPROC_CCA_INT_MASK);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm_iproc_gpio_of_match[] = {\n\t{ .compatible = \"brcm,iproc-gpio-cca\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, bcm_iproc_gpio_of_match);\n\nstatic struct platform_driver bcm_iproc_gpio_driver = {\n\t.driver = {\n\t\t.name = \"iproc-xgs-gpio\",\n\t\t.of_match_table = bcm_iproc_gpio_of_match,\n\t},\n\t.probe = iproc_gpio_probe,\n\t.remove = iproc_gpio_remove,\n};\n\nmodule_platform_driver(bcm_iproc_gpio_driver);\n\nMODULE_DESCRIPTION(\"XGS IPROC GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}