{
  "module_name": "gpio-idt3243x.c",
  "hash_id": "b7bb0d5de5636c7af25cfbb71ef2dfe66df0971263bbd7d643ce20b33ae9c618",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-idt3243x.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#define IDT_PIC_IRQ_PEND\t0x00\n#define IDT_PIC_IRQ_MASK\t0x08\n\n#define IDT_GPIO_DIR\t\t0x00\n#define IDT_GPIO_DATA\t\t0x04\n#define IDT_GPIO_ILEVEL\t\t0x08\n#define IDT_GPIO_ISTAT\t\t0x0C\n\nstruct idt_gpio_ctrl {\n\tstruct gpio_chip gc;\n\tvoid __iomem *pic;\n\tvoid __iomem *gpio;\n\tu32 mask_cache;\n};\n\nstatic void idt_gpio_dispatch(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct idt_gpio_ctrl *ctrl = gpiochip_get_data(gc);\n\tstruct irq_chip *host_chip = irq_desc_get_chip(desc);\n\tunsigned int bit, virq;\n\tunsigned long pending;\n\n\tchained_irq_enter(host_chip, desc);\n\n\tpending = readl(ctrl->pic + IDT_PIC_IRQ_PEND);\n\tpending &= ~ctrl->mask_cache;\n\tfor_each_set_bit(bit, &pending, gc->ngpio) {\n\t\tvirq = irq_linear_revmap(gc->irq.domain, bit);\n\t\tif (virq)\n\t\t\tgeneric_handle_irq(virq);\n\t}\n\n\tchained_irq_exit(host_chip, desc);\n}\n\nstatic int idt_gpio_irq_set_type(struct irq_data *d, unsigned int flow_type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct idt_gpio_ctrl *ctrl = gpiochip_get_data(gc);\n\tunsigned int sense = flow_type & IRQ_TYPE_SENSE_MASK;\n\tunsigned long flags;\n\tu32 ilevel;\n\n\t \n\tif (sense == IRQ_TYPE_NONE || (sense & IRQ_TYPE_EDGE_BOTH))\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\n\tilevel = readl(ctrl->gpio + IDT_GPIO_ILEVEL);\n\tif (sense & IRQ_TYPE_LEVEL_HIGH)\n\t\tilevel |= BIT(d->hwirq);\n\telse if (sense & IRQ_TYPE_LEVEL_LOW)\n\t\tilevel &= ~BIT(d->hwirq);\n\n\twritel(ilevel, ctrl->gpio + IDT_GPIO_ILEVEL);\n\tirq_set_handler_locked(d, handle_level_irq);\n\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\treturn 0;\n}\n\nstatic void idt_gpio_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct idt_gpio_ctrl *ctrl = gpiochip_get_data(gc);\n\n\twritel(~BIT(d->hwirq), ctrl->gpio + IDT_GPIO_ISTAT);\n}\n\nstatic void idt_gpio_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct idt_gpio_ctrl *ctrl = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\n\tctrl->mask_cache |= BIT(d->hwirq);\n\twritel(ctrl->mask_cache, ctrl->pic + IDT_PIC_IRQ_MASK);\n\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void idt_gpio_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct idt_gpio_ctrl *ctrl = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\n\tctrl->mask_cache &= ~BIT(d->hwirq);\n\twritel(ctrl->mask_cache, ctrl->pic + IDT_PIC_IRQ_MASK);\n\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n}\n\nstatic int idt_gpio_irq_init_hw(struct gpio_chip *gc)\n{\n\tstruct idt_gpio_ctrl *ctrl = gpiochip_get_data(gc);\n\n\t \n\tctrl->mask_cache = 0xffffffff;\n\twritel(ctrl->mask_cache, ctrl->pic + IDT_PIC_IRQ_MASK);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip idt_gpio_irqchip = {\n\t.name = \"IDTGPIO\",\n\t.irq_mask = idt_gpio_mask,\n\t.irq_ack = idt_gpio_ack,\n\t.irq_unmask = idt_gpio_unmask,\n\t.irq_set_type = idt_gpio_irq_set_type,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int idt_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct gpio_irq_chip *girq;\n\tstruct idt_gpio_ctrl *ctrl;\n\tint parent_irq;\n\tint ngpios;\n\tint ret;\n\n\n\tctrl = devm_kzalloc(dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->gpio = devm_platform_ioremap_resource_byname(pdev, \"gpio\");\n\tif (IS_ERR(ctrl->gpio))\n\t\treturn PTR_ERR(ctrl->gpio);\n\n\tctrl->gc.parent = dev;\n\n\tret = bgpio_init(&ctrl->gc, &pdev->dev, 4, ctrl->gpio + IDT_GPIO_DATA,\n\t\t\t NULL, NULL, ctrl->gpio + IDT_GPIO_DIR, NULL, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"bgpio_init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(dev, \"ngpios\", &ngpios);\n\tif (!ret)\n\t\tctrl->gc.ngpio = ngpios;\n\n\tif (device_property_read_bool(dev, \"interrupt-controller\")) {\n\t\tctrl->pic = devm_platform_ioremap_resource_byname(pdev, \"pic\");\n\t\tif (IS_ERR(ctrl->pic))\n\t\t\treturn PTR_ERR(ctrl->pic);\n\n\t\tparent_irq = platform_get_irq(pdev, 0);\n\t\tif (parent_irq < 0)\n\t\t\treturn parent_irq;\n\n\t\tgirq = &ctrl->gc.irq;\n\t\tgpio_irq_chip_set_chip(girq, &idt_gpio_irqchip);\n\t\tgirq->init_hw = idt_gpio_irq_init_hw;\n\t\tgirq->parent_handler = idt_gpio_dispatch;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(dev, girq->num_parents,\n\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\n\t\tgirq->parents[0] = parent_irq;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_bad_irq;\n\t}\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &ctrl->gc, ctrl);\n}\n\nstatic const struct of_device_id idt_gpio_of_match[] = {\n\t{ .compatible = \"idt,32434-gpio\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, idt_gpio_of_match);\n\nstatic struct platform_driver idt_gpio_driver = {\n\t.probe = idt_gpio_probe,\n\t.driver = {\n\t\t.name = \"idt3243x-gpio\",\n\t\t.of_match_table = idt_gpio_of_match,\n\t},\n};\nmodule_platform_driver(idt_gpio_driver);\n\nMODULE_DESCRIPTION(\"IDT 79RC3243x GPIO/PIC Driver\");\nMODULE_AUTHOR(\"Thomas Bogendoerfer <tsbogend@alpha.franken.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}