{
  "module_name": "gpio-altera.c",
  "hash_id": "9bfa39796ac19a0cfbb9a4d52f0cc5e6e0f6215e40e005e89c070df24ada3c56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-altera.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/legacy-of-mm-gpiochip.h>\n#include <linux/platform_device.h>\n\n#define ALTERA_GPIO_MAX_NGPIO\t\t32\n#define ALTERA_GPIO_DATA\t\t0x0\n#define ALTERA_GPIO_DIR\t\t\t0x4\n#define ALTERA_GPIO_IRQ_MASK\t\t0x8\n#define ALTERA_GPIO_EDGE_CAP\t\t0xc\n\n \nstruct altera_gpio_chip {\n\tstruct of_mm_gpio_chip mmchip;\n\traw_spinlock_t gpio_lock;\n\tint interrupt_trigger;\n\tint mapped_irq;\n};\n\nstatic void altera_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct altera_gpio_chip *altera_gc;\n\tstruct of_mm_gpio_chip *mm_gc;\n\tunsigned long flags;\n\tu32 intmask;\n\n\taltera_gc = gpiochip_get_data(irq_data_get_irq_chip_data(d));\n\tmm_gc = &altera_gc->mmchip;\n\tgpiochip_enable_irq(&mm_gc->gc, irqd_to_hwirq(d));\n\n\traw_spin_lock_irqsave(&altera_gc->gpio_lock, flags);\n\tintmask = readl(mm_gc->regs + ALTERA_GPIO_IRQ_MASK);\n\t \n\tintmask |= BIT(irqd_to_hwirq(d));\n\twritel(intmask, mm_gc->regs + ALTERA_GPIO_IRQ_MASK);\n\traw_spin_unlock_irqrestore(&altera_gc->gpio_lock, flags);\n}\n\nstatic void altera_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct altera_gpio_chip *altera_gc;\n\tstruct of_mm_gpio_chip *mm_gc;\n\tunsigned long flags;\n\tu32 intmask;\n\n\taltera_gc = gpiochip_get_data(irq_data_get_irq_chip_data(d));\n\tmm_gc = &altera_gc->mmchip;\n\n\traw_spin_lock_irqsave(&altera_gc->gpio_lock, flags);\n\tintmask = readl(mm_gc->regs + ALTERA_GPIO_IRQ_MASK);\n\t \n\tintmask &= ~BIT(irqd_to_hwirq(d));\n\twritel(intmask, mm_gc->regs + ALTERA_GPIO_IRQ_MASK);\n\traw_spin_unlock_irqrestore(&altera_gc->gpio_lock, flags);\n\tgpiochip_disable_irq(&mm_gc->gc, irqd_to_hwirq(d));\n}\n\n \nstatic int altera_gpio_irq_set_type(struct irq_data *d,\n\t\t\t\t   unsigned int type)\n{\n\tstruct altera_gpio_chip *altera_gc;\n\n\taltera_gc = gpiochip_get_data(irq_data_get_irq_chip_data(d));\n\n\tif (type == IRQ_TYPE_NONE) {\n\t\tirq_set_handler_locked(d, handle_bad_irq);\n\t\treturn 0;\n\t}\n\tif (type == altera_gc->interrupt_trigger) {\n\t\tif (type == IRQ_TYPE_LEVEL_HIGH)\n\t\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\telse\n\t\t\tirq_set_handler_locked(d, handle_simple_irq);\n\t\treturn 0;\n\t}\n\tirq_set_handler_locked(d, handle_bad_irq);\n\treturn -EINVAL;\n}\n\nstatic unsigned int altera_gpio_irq_startup(struct irq_data *d)\n{\n\taltera_gpio_irq_unmask(d);\n\n\treturn 0;\n}\n\nstatic int altera_gpio_get(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct of_mm_gpio_chip *mm_gc;\n\n\tmm_gc = to_of_mm_gpio_chip(gc);\n\n\treturn !!(readl(mm_gc->regs + ALTERA_GPIO_DATA) & BIT(offset));\n}\n\nstatic void altera_gpio_set(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tstruct of_mm_gpio_chip *mm_gc;\n\tstruct altera_gpio_chip *chip;\n\tunsigned long flags;\n\tunsigned int data_reg;\n\n\tmm_gc = to_of_mm_gpio_chip(gc);\n\tchip = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&chip->gpio_lock, flags);\n\tdata_reg = readl(mm_gc->regs + ALTERA_GPIO_DATA);\n\tif (value)\n\t\tdata_reg |= BIT(offset);\n\telse\n\t\tdata_reg &= ~BIT(offset);\n\twritel(data_reg, mm_gc->regs + ALTERA_GPIO_DATA);\n\traw_spin_unlock_irqrestore(&chip->gpio_lock, flags);\n}\n\nstatic int altera_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct of_mm_gpio_chip *mm_gc;\n\tstruct altera_gpio_chip *chip;\n\tunsigned long flags;\n\tunsigned int gpio_ddr;\n\n\tmm_gc = to_of_mm_gpio_chip(gc);\n\tchip = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&chip->gpio_lock, flags);\n\t \n\tgpio_ddr = readl(mm_gc->regs + ALTERA_GPIO_DIR);\n\tgpio_ddr &= ~BIT(offset);\n\twritel(gpio_ddr, mm_gc->regs + ALTERA_GPIO_DIR);\n\traw_spin_unlock_irqrestore(&chip->gpio_lock, flags);\n\n\treturn 0;\n}\n\nstatic int altera_gpio_direction_output(struct gpio_chip *gc,\n\t\tunsigned offset, int value)\n{\n\tstruct of_mm_gpio_chip *mm_gc;\n\tstruct altera_gpio_chip *chip;\n\tunsigned long flags;\n\tunsigned int data_reg, gpio_ddr;\n\n\tmm_gc = to_of_mm_gpio_chip(gc);\n\tchip = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&chip->gpio_lock, flags);\n\t \n\tdata_reg = readl(mm_gc->regs + ALTERA_GPIO_DATA);\n\tif (value)\n\t\tdata_reg |= BIT(offset);\n\telse\n\t\tdata_reg &= ~BIT(offset);\n\twritel(data_reg, mm_gc->regs + ALTERA_GPIO_DATA);\n\n\t \n\tgpio_ddr = readl(mm_gc->regs + ALTERA_GPIO_DIR);\n\tgpio_ddr |= BIT(offset);\n\twritel(gpio_ddr, mm_gc->regs + ALTERA_GPIO_DIR);\n\traw_spin_unlock_irqrestore(&chip->gpio_lock, flags);\n\n\treturn 0;\n}\n\nstatic void altera_gpio_irq_edge_handler(struct irq_desc *desc)\n{\n\tstruct altera_gpio_chip *altera_gc;\n\tstruct irq_chip *chip;\n\tstruct of_mm_gpio_chip *mm_gc;\n\tstruct irq_domain *irqdomain;\n\tunsigned long status;\n\tint i;\n\n\taltera_gc = gpiochip_get_data(irq_desc_get_handler_data(desc));\n\tchip = irq_desc_get_chip(desc);\n\tmm_gc = &altera_gc->mmchip;\n\tirqdomain = altera_gc->mmchip.gc.irq.domain;\n\n\tchained_irq_enter(chip, desc);\n\n\twhile ((status =\n\t      (readl(mm_gc->regs + ALTERA_GPIO_EDGE_CAP) &\n\t      readl(mm_gc->regs + ALTERA_GPIO_IRQ_MASK)))) {\n\t\twritel(status, mm_gc->regs + ALTERA_GPIO_EDGE_CAP);\n\t\tfor_each_set_bit(i, &status, mm_gc->gc.ngpio)\n\t\t\tgeneric_handle_domain_irq(irqdomain, i);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void altera_gpio_irq_leveL_high_handler(struct irq_desc *desc)\n{\n\tstruct altera_gpio_chip *altera_gc;\n\tstruct irq_chip *chip;\n\tstruct of_mm_gpio_chip *mm_gc;\n\tstruct irq_domain *irqdomain;\n\tunsigned long status;\n\tint i;\n\n\taltera_gc = gpiochip_get_data(irq_desc_get_handler_data(desc));\n\tchip = irq_desc_get_chip(desc);\n\tmm_gc = &altera_gc->mmchip;\n\tirqdomain = altera_gc->mmchip.gc.irq.domain;\n\n\tchained_irq_enter(chip, desc);\n\n\tstatus = readl(mm_gc->regs + ALTERA_GPIO_DATA);\n\tstatus &= readl(mm_gc->regs + ALTERA_GPIO_IRQ_MASK);\n\n\tfor_each_set_bit(i, &status, mm_gc->gc.ngpio)\n\t\tgeneric_handle_domain_irq(irqdomain, i);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic const struct irq_chip altera_gpio_irq_chip = {\n\t.name = \"altera-gpio\",\n\t.irq_mask = altera_gpio_irq_mask,\n\t.irq_unmask = altera_gpio_irq_unmask,\n\t.irq_set_type = altera_gpio_irq_set_type,\n\t.irq_startup  = altera_gpio_irq_startup,\n\t.irq_shutdown = altera_gpio_irq_mask,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int altera_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tint reg, ret;\n\tstruct altera_gpio_chip *altera_gc;\n\tstruct gpio_irq_chip *girq;\n\n\taltera_gc = devm_kzalloc(&pdev->dev, sizeof(*altera_gc), GFP_KERNEL);\n\tif (!altera_gc)\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_init(&altera_gc->gpio_lock);\n\n\tif (of_property_read_u32(node, \"altr,ngpio\", &reg))\n\t\t \n\t\taltera_gc->mmchip.gc.ngpio = ALTERA_GPIO_MAX_NGPIO;\n\telse\n\t\taltera_gc->mmchip.gc.ngpio = reg;\n\n\tif (altera_gc->mmchip.gc.ngpio > ALTERA_GPIO_MAX_NGPIO) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t\"ngpio is greater than %d, defaulting to %d\\n\",\n\t\t\tALTERA_GPIO_MAX_NGPIO, ALTERA_GPIO_MAX_NGPIO);\n\t\taltera_gc->mmchip.gc.ngpio = ALTERA_GPIO_MAX_NGPIO;\n\t}\n\n\taltera_gc->mmchip.gc.direction_input\t= altera_gpio_direction_input;\n\taltera_gc->mmchip.gc.direction_output\t= altera_gpio_direction_output;\n\taltera_gc->mmchip.gc.get\t\t= altera_gpio_get;\n\taltera_gc->mmchip.gc.set\t\t= altera_gpio_set;\n\taltera_gc->mmchip.gc.owner\t\t= THIS_MODULE;\n\taltera_gc->mmchip.gc.parent\t\t= &pdev->dev;\n\n\taltera_gc->mapped_irq = platform_get_irq_optional(pdev, 0);\n\n\tif (altera_gc->mapped_irq < 0)\n\t\tgoto skip_irq;\n\n\tif (of_property_read_u32(node, \"altr,interrupt-type\", &reg)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"altr,interrupt-type value not set in device tree\\n\");\n\t\treturn -EINVAL;\n\t}\n\taltera_gc->interrupt_trigger = reg;\n\n\tgirq = &altera_gc->mmchip.gc.irq;\n\tgpio_irq_chip_set_chip(girq, &altera_gpio_irq_chip);\n\n\tif (altera_gc->interrupt_trigger == IRQ_TYPE_LEVEL_HIGH)\n\t\tgirq->parent_handler = altera_gpio_irq_leveL_high_handler;\n\telse\n\t\tgirq->parent_handler = altera_gpio_irq_edge_handler;\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(&pdev->dev, 1, sizeof(*girq->parents),\n\t\t\t\t     GFP_KERNEL);\n\tif (!girq->parents)\n\t\treturn -ENOMEM;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\tgirq->parents[0] = altera_gc->mapped_irq;\n\nskip_irq:\n\tret = of_mm_gpiochip_add_data(node, &altera_gc->mmchip, altera_gc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed adding memory mapped gpiochip\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, altera_gc);\n\n\treturn 0;\n}\n\nstatic int altera_gpio_remove(struct platform_device *pdev)\n{\n\tstruct altera_gpio_chip *altera_gc = platform_get_drvdata(pdev);\n\n\tof_mm_gpiochip_remove(&altera_gc->mmchip);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id altera_gpio_of_match[] = {\n\t{ .compatible = \"altr,pio-1.0\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altera_gpio_of_match);\n\nstatic struct platform_driver altera_gpio_driver = {\n\t.driver = {\n\t\t.name\t= \"altera_gpio\",\n\t\t.of_match_table = altera_gpio_of_match,\n\t},\n\t.probe\t\t= altera_gpio_probe,\n\t.remove\t\t= altera_gpio_remove,\n};\n\nstatic int __init altera_gpio_init(void)\n{\n\treturn platform_driver_register(&altera_gpio_driver);\n}\nsubsys_initcall(altera_gpio_init);\n\nstatic void __exit altera_gpio_exit(void)\n{\n\tplatform_driver_unregister(&altera_gpio_driver);\n}\nmodule_exit(altera_gpio_exit);\n\nMODULE_AUTHOR(\"Tien Hock Loh <thloh@altera.com>\");\nMODULE_DESCRIPTION(\"Altera GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}