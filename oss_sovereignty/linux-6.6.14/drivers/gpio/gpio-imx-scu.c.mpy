{
  "module_name": "gpio-imx-scu.c",
  "hash_id": "04c966cd5e0388ca985ef50dc480e901217b519030c7d9d29920640df1f43158",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-imx-scu.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio/driver.h>\n#include <linux/platform_device.h>\n#include <linux/firmware/imx/svc/rm.h>\n#include <dt-bindings/firmware/imx/rsrc.h>\n\nstruct scu_gpio_priv {\n\tstruct gpio_chip\tchip;\n\tstruct mutex\t\tlock;\n\tstruct device\t\t*dev;\n\tstruct imx_sc_ipc\t*handle;\n};\n\nstatic unsigned int scu_rsrc_arr[] = {\n\tIMX_SC_R_BOARD_R0,\n\tIMX_SC_R_BOARD_R1,\n\tIMX_SC_R_BOARD_R2,\n\tIMX_SC_R_BOARD_R3,\n\tIMX_SC_R_BOARD_R4,\n\tIMX_SC_R_BOARD_R5,\n\tIMX_SC_R_BOARD_R6,\n\tIMX_SC_R_BOARD_R7,\n};\n\nstatic int imx_scu_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct scu_gpio_priv *priv = gpiochip_get_data(chip);\n\tint level;\n\tint err;\n\n\tif (offset >= chip->ngpio)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\terr = imx_sc_misc_get_control(priv->handle,\n\t\t\tscu_rsrc_arr[offset], 0, &level);\n\tmutex_unlock(&priv->lock);\n\n\tif (err) {\n\t\tdev_err(priv->dev, \"SCU get failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn level;\n}\n\nstatic void imx_scu_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct scu_gpio_priv *priv = gpiochip_get_data(chip);\n\tint err;\n\n\tif (offset >= chip->ngpio)\n\t\treturn;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\terr = imx_sc_misc_set_control(priv->handle,\n\t\t\tscu_rsrc_arr[offset], 0, value);\n\tmutex_unlock(&priv->lock);\n\n\tif (err)\n\t\tdev_err(priv->dev, \"SCU set (%d) failed: %d\\n\",\n\t\t\t\tscu_rsrc_arr[offset], err);\n}\n\nstatic int imx_scu_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tif (offset >= chip->ngpio)\n\t\treturn -EINVAL;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int imx_scu_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct scu_gpio_priv *priv;\n\tstruct gpio_chip *gc;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tret = imx_scu_get_handle(&priv->handle);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->dev = dev;\n\tmutex_init(&priv->lock);\n\n\tgc = &priv->chip;\n\tgc->base = -1;\n\tgc->parent = dev;\n\tgc->ngpio = ARRAY_SIZE(scu_rsrc_arr);\n\tgc->label = dev_name(dev);\n\tgc->get = imx_scu_gpio_get;\n\tgc->set = imx_scu_gpio_set;\n\tgc->get_direction = imx_scu_gpio_get_direction;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn devm_gpiochip_add_data(dev, gc, priv);\n}\n\nstatic const struct of_device_id imx_scu_gpio_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8qxp-sc-gpio\" },\n\t{   }\n};\n\nstatic struct platform_driver imx_scu_gpio_driver = {\n\t.driver\t= {\n\t\t.name = \"gpio-imx-scu\",\n\t\t.of_match_table = imx_scu_gpio_dt_ids,\n\t},\n\t.probe = imx_scu_gpio_probe,\n};\n\nstatic int __init _imx_scu_gpio_init(void)\n{\n\treturn platform_driver_register(&imx_scu_gpio_driver);\n}\n\nsubsys_initcall_sync(_imx_scu_gpio_init);\n\nMODULE_AUTHOR(\"Shenwei Wang <shenwei.wang@nxp.com>\");\nMODULE_DESCRIPTION(\"NXP GPIO over IMX SCU API\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}