{
  "module_name": "gpio-mvebu.c",
  "hash_id": "7602629430acb550db9f84211b5065c464ecf6165e583219ce614f3876c2291b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mvebu.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \n#define GPIO_OUT_OFF\t\t\t0x0000\n#define GPIO_IO_CONF_OFF\t\t0x0004\n#define GPIO_BLINK_EN_OFF\t\t0x0008\n#define GPIO_IN_POL_OFF\t\t\t0x000c\n#define GPIO_DATA_IN_OFF\t\t0x0010\n#define GPIO_EDGE_CAUSE_OFF\t\t0x0014\n#define GPIO_EDGE_MASK_OFF\t\t0x0018\n#define GPIO_LEVEL_MASK_OFF\t\t0x001c\n#define GPIO_BLINK_CNT_SELECT_OFF\t0x0020\n\n \n#define PWM_BLINK_ON_DURATION_OFF\t0x0\n#define PWM_BLINK_OFF_DURATION_OFF\t0x4\n#define PWM_BLINK_COUNTER_B_OFF\t\t0x8\n\n \n#define AP80X_GPIO0_OFF_A8K\t\t0x1040\n#define CP11X_GPIO0_OFF_A8K\t\t0x100\n#define CP11X_GPIO1_OFF_A8K\t\t0x140\n\n \n#define GPIO_EDGE_MASK_MV78200_OFF(cpu)\t  ((cpu) ? 0x30 : 0x18)\n#define GPIO_LEVEL_MASK_MV78200_OFF(cpu)  ((cpu) ? 0x34 : 0x1C)\n\n \n#define GPIO_EDGE_CAUSE_ARMADAXP_OFF(cpu) ((cpu) * 0x4)\n#define GPIO_EDGE_MASK_ARMADAXP_OFF(cpu)  (0x10 + (cpu) * 0x4)\n#define GPIO_LEVEL_MASK_ARMADAXP_OFF(cpu) (0x20 + (cpu) * 0x4)\n\n#define MVEBU_GPIO_SOC_VARIANT_ORION\t0x1\n#define MVEBU_GPIO_SOC_VARIANT_MV78200\t0x2\n#define MVEBU_GPIO_SOC_VARIANT_ARMADAXP 0x3\n#define MVEBU_GPIO_SOC_VARIANT_A8K\t0x4\n\n#define MVEBU_MAX_GPIO_PER_BANK\t\t32\n\nstruct mvebu_pwm {\n\tstruct regmap\t\t*regs;\n\tu32\t\t\t offset;\n\tunsigned long\t\t clk_rate;\n\tstruct gpio_desc\t*gpiod;\n\tstruct pwm_chip\t\t chip;\n\tspinlock_t\t\t lock;\n\tstruct mvebu_gpio_chip\t*mvchip;\n\n\t \n\tu32\t\t\t blink_select;\n\tu32\t\t\t blink_on_duration;\n\tu32\t\t\t blink_off_duration;\n};\n\nstruct mvebu_gpio_chip {\n\tstruct gpio_chip   chip;\n\tstruct regmap     *regs;\n\tu32\t\t   offset;\n\tstruct regmap     *percpu_regs;\n\tint\t\t   irqbase;\n\tstruct irq_domain *domain;\n\tint\t\t   soc_variant;\n\n\t \n\tstruct clk\t  *clk;\n\tstruct mvebu_pwm  *mvpwm;\n\n\t \n\tu32\t\t   out_reg;\n\tu32\t\t   io_conf_reg;\n\tu32\t\t   blink_en_reg;\n\tu32\t\t   in_pol_reg;\n\tu32\t\t   edge_mask_regs[4];\n\tu32\t\t   level_mask_regs[4];\n};\n\n \n\nstatic void mvebu_gpioreg_edge_cause(struct mvebu_gpio_chip *mvchip,\n\t\t\t struct regmap **map, unsigned int *offset)\n{\n\tint cpu;\n\n\tswitch (mvchip->soc_variant) {\n\tcase MVEBU_GPIO_SOC_VARIANT_ORION:\n\tcase MVEBU_GPIO_SOC_VARIANT_MV78200:\n\tcase MVEBU_GPIO_SOC_VARIANT_A8K:\n\t\t*map = mvchip->regs;\n\t\t*offset = GPIO_EDGE_CAUSE_OFF + mvchip->offset;\n\t\tbreak;\n\tcase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\n\t\tcpu = smp_processor_id();\n\t\t*map = mvchip->percpu_regs;\n\t\t*offset = GPIO_EDGE_CAUSE_ARMADAXP_OFF(cpu);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic u32\nmvebu_gpio_read_edge_cause(struct mvebu_gpio_chip *mvchip)\n{\n\tstruct regmap *map;\n\tunsigned int offset;\n\tu32 val;\n\n\tmvebu_gpioreg_edge_cause(mvchip, &map, &offset);\n\tregmap_read(map, offset, &val);\n\n\treturn val;\n}\n\nstatic void\nmvebu_gpio_write_edge_cause(struct mvebu_gpio_chip *mvchip, u32 val)\n{\n\tstruct regmap *map;\n\tunsigned int offset;\n\n\tmvebu_gpioreg_edge_cause(mvchip, &map, &offset);\n\tregmap_write(map, offset, val);\n}\n\nstatic inline void\nmvebu_gpioreg_edge_mask(struct mvebu_gpio_chip *mvchip,\n\t\t\tstruct regmap **map, unsigned int *offset)\n{\n\tint cpu;\n\n\tswitch (mvchip->soc_variant) {\n\tcase MVEBU_GPIO_SOC_VARIANT_ORION:\n\tcase MVEBU_GPIO_SOC_VARIANT_A8K:\n\t\t*map = mvchip->regs;\n\t\t*offset = GPIO_EDGE_MASK_OFF + mvchip->offset;\n\t\tbreak;\n\tcase MVEBU_GPIO_SOC_VARIANT_MV78200:\n\t\tcpu = smp_processor_id();\n\t\t*map = mvchip->regs;\n\t\t*offset = GPIO_EDGE_MASK_MV78200_OFF(cpu);\n\t\tbreak;\n\tcase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\n\t\tcpu = smp_processor_id();\n\t\t*map = mvchip->percpu_regs;\n\t\t*offset = GPIO_EDGE_MASK_ARMADAXP_OFF(cpu);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic u32\nmvebu_gpio_read_edge_mask(struct mvebu_gpio_chip *mvchip)\n{\n\tstruct regmap *map;\n\tunsigned int offset;\n\tu32 val;\n\n\tmvebu_gpioreg_edge_mask(mvchip, &map, &offset);\n\tregmap_read(map, offset, &val);\n\n\treturn val;\n}\n\nstatic void\nmvebu_gpio_write_edge_mask(struct mvebu_gpio_chip *mvchip, u32 val)\n{\n\tstruct regmap *map;\n\tunsigned int offset;\n\n\tmvebu_gpioreg_edge_mask(mvchip, &map, &offset);\n\tregmap_write(map, offset, val);\n}\n\nstatic void\nmvebu_gpioreg_level_mask(struct mvebu_gpio_chip *mvchip,\n\t\t\t struct regmap **map, unsigned int *offset)\n{\n\tint cpu;\n\n\tswitch (mvchip->soc_variant) {\n\tcase MVEBU_GPIO_SOC_VARIANT_ORION:\n\tcase MVEBU_GPIO_SOC_VARIANT_A8K:\n\t\t*map = mvchip->regs;\n\t\t*offset = GPIO_LEVEL_MASK_OFF + mvchip->offset;\n\t\tbreak;\n\tcase MVEBU_GPIO_SOC_VARIANT_MV78200:\n\t\tcpu = smp_processor_id();\n\t\t*map = mvchip->regs;\n\t\t*offset = GPIO_LEVEL_MASK_MV78200_OFF(cpu);\n\t\tbreak;\n\tcase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\n\t\tcpu = smp_processor_id();\n\t\t*map = mvchip->percpu_regs;\n\t\t*offset = GPIO_LEVEL_MASK_ARMADAXP_OFF(cpu);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic u32\nmvebu_gpio_read_level_mask(struct mvebu_gpio_chip *mvchip)\n{\n\tstruct regmap *map;\n\tunsigned int offset;\n\tu32 val;\n\n\tmvebu_gpioreg_level_mask(mvchip, &map, &offset);\n\tregmap_read(map, offset, &val);\n\n\treturn val;\n}\n\nstatic void\nmvebu_gpio_write_level_mask(struct mvebu_gpio_chip *mvchip, u32 val)\n{\n\tstruct regmap *map;\n\tunsigned int offset;\n\n\tmvebu_gpioreg_level_mask(mvchip, &map, &offset);\n\tregmap_write(map, offset, val);\n}\n\n \nstatic unsigned int mvebu_pwmreg_blink_on_duration(struct mvebu_pwm *mvpwm)\n{\n\treturn mvpwm->offset + PWM_BLINK_ON_DURATION_OFF;\n}\n\nstatic unsigned int mvebu_pwmreg_blink_off_duration(struct mvebu_pwm *mvpwm)\n{\n\treturn mvpwm->offset + PWM_BLINK_OFF_DURATION_OFF;\n}\n\n \nstatic void mvebu_gpio_set(struct gpio_chip *chip, unsigned int pin, int value)\n{\n\tstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\n\n\tregmap_update_bits(mvchip->regs, GPIO_OUT_OFF + mvchip->offset,\n\t\t\t   BIT(pin), value ? BIT(pin) : 0);\n}\n\nstatic int mvebu_gpio_get(struct gpio_chip *chip, unsigned int pin)\n{\n\tstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\n\tu32 u;\n\n\tregmap_read(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset, &u);\n\n\tif (u & BIT(pin)) {\n\t\tu32 data_in, in_pol;\n\n\t\tregmap_read(mvchip->regs, GPIO_DATA_IN_OFF + mvchip->offset,\n\t\t\t    &data_in);\n\t\tregmap_read(mvchip->regs, GPIO_IN_POL_OFF + mvchip->offset,\n\t\t\t    &in_pol);\n\t\tu = data_in ^ in_pol;\n\t} else {\n\t\tregmap_read(mvchip->regs, GPIO_OUT_OFF + mvchip->offset, &u);\n\t}\n\n\treturn (u >> pin) & 1;\n}\n\nstatic void mvebu_gpio_blink(struct gpio_chip *chip, unsigned int pin,\n\t\t\t     int value)\n{\n\tstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\n\n\tregmap_update_bits(mvchip->regs, GPIO_BLINK_EN_OFF + mvchip->offset,\n\t\t\t   BIT(pin), value ? BIT(pin) : 0);\n}\n\nstatic int mvebu_gpio_direction_input(struct gpio_chip *chip, unsigned int pin)\n{\n\tstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\n\tint ret;\n\n\t \n\tret = pinctrl_gpio_direction_input(chip->base + pin);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset,\n\t\t\t   BIT(pin), BIT(pin));\n\n\treturn 0;\n}\n\nstatic int mvebu_gpio_direction_output(struct gpio_chip *chip, unsigned int pin,\n\t\t\t\t       int value)\n{\n\tstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\n\tint ret;\n\n\t \n\tret = pinctrl_gpio_direction_output(chip->base + pin);\n\tif (ret)\n\t\treturn ret;\n\n\tmvebu_gpio_blink(chip, pin, 0);\n\tmvebu_gpio_set(chip, pin, value);\n\n\tregmap_update_bits(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset,\n\t\t\t   BIT(pin), 0);\n\n\treturn 0;\n}\n\nstatic int mvebu_gpio_get_direction(struct gpio_chip *chip, unsigned int pin)\n{\n\tstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\n\tu32 u;\n\n\tregmap_read(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset, &u);\n\n\tif (u & BIT(pin))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int mvebu_gpio_to_irq(struct gpio_chip *chip, unsigned int pin)\n{\n\tstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\n\n\treturn irq_create_mapping(mvchip->domain, pin);\n}\n\n \nstatic void mvebu_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct mvebu_gpio_chip *mvchip = gc->private;\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tmvebu_gpio_write_edge_cause(mvchip, ~mask);\n\tirq_gc_unlock(gc);\n}\n\nstatic void mvebu_gpio_edge_irq_mask(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct mvebu_gpio_chip *mvchip = gc->private;\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tct->mask_cache_priv &= ~mask;\n\tmvebu_gpio_write_edge_mask(mvchip, ct->mask_cache_priv);\n\tirq_gc_unlock(gc);\n}\n\nstatic void mvebu_gpio_edge_irq_unmask(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct mvebu_gpio_chip *mvchip = gc->private;\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tmvebu_gpio_write_edge_cause(mvchip, ~mask);\n\tct->mask_cache_priv |= mask;\n\tmvebu_gpio_write_edge_mask(mvchip, ct->mask_cache_priv);\n\tirq_gc_unlock(gc);\n}\n\nstatic void mvebu_gpio_level_irq_mask(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct mvebu_gpio_chip *mvchip = gc->private;\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tct->mask_cache_priv &= ~mask;\n\tmvebu_gpio_write_level_mask(mvchip, ct->mask_cache_priv);\n\tirq_gc_unlock(gc);\n}\n\nstatic void mvebu_gpio_level_irq_unmask(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct mvebu_gpio_chip *mvchip = gc->private;\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tct->mask_cache_priv |= mask;\n\tmvebu_gpio_write_level_mask(mvchip, ct->mask_cache_priv);\n\tirq_gc_unlock(gc);\n}\n\n \n\nstatic int mvebu_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tstruct mvebu_gpio_chip *mvchip = gc->private;\n\tint pin;\n\tu32 u;\n\n\tpin = d->hwirq;\n\n\tregmap_read(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset, &u);\n\tif ((u & BIT(pin)) == 0)\n\t\treturn -EINVAL;\n\n\ttype &= IRQ_TYPE_SENSE_MASK;\n\tif (type == IRQ_TYPE_NONE)\n\t\treturn -EINVAL;\n\n\t \n\tif (!(ct->type & type))\n\t\tif (irq_setup_alt_chip(d, type))\n\t\t\treturn -EINVAL;\n\n\t \n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tregmap_update_bits(mvchip->regs,\n\t\t\t\t   GPIO_IN_POL_OFF + mvchip->offset,\n\t\t\t\t   BIT(pin), 0);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tregmap_update_bits(mvchip->regs,\n\t\t\t\t   GPIO_IN_POL_OFF + mvchip->offset,\n\t\t\t\t   BIT(pin), BIT(pin));\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH: {\n\t\tu32 data_in, in_pol, val;\n\n\t\tregmap_read(mvchip->regs,\n\t\t\t    GPIO_IN_POL_OFF + mvchip->offset, &in_pol);\n\t\tregmap_read(mvchip->regs,\n\t\t\t    GPIO_DATA_IN_OFF + mvchip->offset, &data_in);\n\n\t\t \n\t\tif ((data_in ^ in_pol) & BIT(pin))\n\t\t\tval = BIT(pin);  \n\t\telse\n\t\t\tval = 0;  \n\n\t\tregmap_update_bits(mvchip->regs,\n\t\t\t\t   GPIO_IN_POL_OFF + mvchip->offset,\n\t\t\t\t   BIT(pin), val);\n\t\tbreak;\n\t}\n\t}\n\treturn 0;\n}\n\nstatic void mvebu_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct mvebu_gpio_chip *mvchip = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tu32 cause, type, data_in, level_mask, edge_cause, edge_mask;\n\tint i;\n\n\tif (mvchip == NULL)\n\t\treturn;\n\n\tchained_irq_enter(chip, desc);\n\n\tregmap_read(mvchip->regs, GPIO_DATA_IN_OFF + mvchip->offset, &data_in);\n\tlevel_mask = mvebu_gpio_read_level_mask(mvchip);\n\tedge_cause = mvebu_gpio_read_edge_cause(mvchip);\n\tedge_mask  = mvebu_gpio_read_edge_mask(mvchip);\n\n\tcause = (data_in & level_mask) | (edge_cause & edge_mask);\n\n\tfor (i = 0; i < mvchip->chip.ngpio; i++) {\n\t\tint irq;\n\n\t\tirq = irq_find_mapping(mvchip->domain, i);\n\n\t\tif (!(cause & BIT(i)))\n\t\t\tcontinue;\n\n\t\ttype = irq_get_trigger_type(irq);\n\t\tif ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {\n\t\t\t \n\t\t\tu32 polarity;\n\n\t\t\tregmap_read(mvchip->regs,\n\t\t\t\t    GPIO_IN_POL_OFF + mvchip->offset,\n\t\t\t\t    &polarity);\n\t\t\tpolarity ^= BIT(i);\n\t\t\tregmap_write(mvchip->regs,\n\t\t\t\t     GPIO_IN_POL_OFF + mvchip->offset,\n\t\t\t\t     polarity);\n\t\t}\n\n\t\tgeneric_handle_irq(irq);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic const struct regmap_config mvebu_gpio_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.fast_io = true,\n};\n\n \nstatic struct mvebu_pwm *to_mvebu_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct mvebu_pwm, chip);\n}\n\nstatic int mvebu_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct mvebu_pwm *mvpwm = to_mvebu_pwm(chip);\n\tstruct mvebu_gpio_chip *mvchip = mvpwm->mvchip;\n\tstruct gpio_desc *desc;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&mvpwm->lock, flags);\n\n\tif (mvpwm->gpiod) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tdesc = gpiochip_request_own_desc(&mvchip->chip,\n\t\t\t\t\t\t pwm->hwpwm, \"mvebu-pwm\",\n\t\t\t\t\t\t GPIO_ACTIVE_HIGH,\n\t\t\t\t\t\t GPIOD_OUT_LOW);\n\t\tif (IS_ERR(desc)) {\n\t\t\tret = PTR_ERR(desc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmvpwm->gpiod = desc;\n\t}\nout:\n\tspin_unlock_irqrestore(&mvpwm->lock, flags);\n\treturn ret;\n}\n\nstatic void mvebu_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct mvebu_pwm *mvpwm = to_mvebu_pwm(chip);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mvpwm->lock, flags);\n\tgpiochip_free_own_desc(mvpwm->gpiod);\n\tmvpwm->gpiod = NULL;\n\tspin_unlock_irqrestore(&mvpwm->lock, flags);\n}\n\nstatic int mvebu_pwm_get_state(struct pwm_chip *chip,\n\t\t\t       struct pwm_device *pwm,\n\t\t\t       struct pwm_state *state)\n{\n\n\tstruct mvebu_pwm *mvpwm = to_mvebu_pwm(chip);\n\tstruct mvebu_gpio_chip *mvchip = mvpwm->mvchip;\n\tunsigned long long val;\n\tunsigned long flags;\n\tu32 u;\n\n\tspin_lock_irqsave(&mvpwm->lock, flags);\n\n\tregmap_read(mvpwm->regs, mvebu_pwmreg_blink_on_duration(mvpwm), &u);\n\t \n\tif (u > 0)\n\t\tval = u;\n\telse\n\t\tval = UINT_MAX + 1ULL;\n\tstate->duty_cycle = DIV_ROUND_UP_ULL(val * NSEC_PER_SEC,\n\t\t\tmvpwm->clk_rate);\n\n\tregmap_read(mvpwm->regs, mvebu_pwmreg_blink_off_duration(mvpwm), &u);\n\t \n\tif (u > 0)\n\t\tval += u;\n\telse\n\t\tval += UINT_MAX + 1ULL;\n\tstate->period = DIV_ROUND_UP_ULL(val * NSEC_PER_SEC, mvpwm->clk_rate);\n\n\tregmap_read(mvchip->regs, GPIO_BLINK_EN_OFF + mvchip->offset, &u);\n\tif (u)\n\t\tstate->enabled = true;\n\telse\n\t\tstate->enabled = false;\n\n\tspin_unlock_irqrestore(&mvpwm->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mvebu_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   const struct pwm_state *state)\n{\n\tstruct mvebu_pwm *mvpwm = to_mvebu_pwm(chip);\n\tstruct mvebu_gpio_chip *mvchip = mvpwm->mvchip;\n\tunsigned long long val;\n\tunsigned long flags;\n\tunsigned int on, off;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tval = (unsigned long long) mvpwm->clk_rate * state->duty_cycle;\n\tdo_div(val, NSEC_PER_SEC);\n\tif (val > UINT_MAX + 1ULL)\n\t\treturn -EINVAL;\n\t \n\tif (val == UINT_MAX + 1ULL)\n\t\ton = 0;\n\telse if (val)\n\t\ton = val;\n\telse\n\t\ton = 1;\n\n\tval = (unsigned long long) mvpwm->clk_rate * state->period;\n\tdo_div(val, NSEC_PER_SEC);\n\tval -= on;\n\tif (val > UINT_MAX + 1ULL)\n\t\treturn -EINVAL;\n\tif (val == UINT_MAX + 1ULL)\n\t\toff = 0;\n\telse if (val)\n\t\toff = val;\n\telse\n\t\toff = 1;\n\n\tspin_lock_irqsave(&mvpwm->lock, flags);\n\n\tregmap_write(mvpwm->regs, mvebu_pwmreg_blink_on_duration(mvpwm), on);\n\tregmap_write(mvpwm->regs, mvebu_pwmreg_blink_off_duration(mvpwm), off);\n\tif (state->enabled)\n\t\tmvebu_gpio_blink(&mvchip->chip, pwm->hwpwm, 1);\n\telse\n\t\tmvebu_gpio_blink(&mvchip->chip, pwm->hwpwm, 0);\n\n\tspin_unlock_irqrestore(&mvpwm->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops mvebu_pwm_ops = {\n\t.request = mvebu_pwm_request,\n\t.free = mvebu_pwm_free,\n\t.get_state = mvebu_pwm_get_state,\n\t.apply = mvebu_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic void __maybe_unused mvebu_pwm_suspend(struct mvebu_gpio_chip *mvchip)\n{\n\tstruct mvebu_pwm *mvpwm = mvchip->mvpwm;\n\n\tregmap_read(mvchip->regs, GPIO_BLINK_CNT_SELECT_OFF + mvchip->offset,\n\t\t    &mvpwm->blink_select);\n\tregmap_read(mvpwm->regs, mvebu_pwmreg_blink_on_duration(mvpwm),\n\t\t    &mvpwm->blink_on_duration);\n\tregmap_read(mvpwm->regs, mvebu_pwmreg_blink_off_duration(mvpwm),\n\t\t    &mvpwm->blink_off_duration);\n}\n\nstatic void __maybe_unused mvebu_pwm_resume(struct mvebu_gpio_chip *mvchip)\n{\n\tstruct mvebu_pwm *mvpwm = mvchip->mvpwm;\n\n\tregmap_write(mvchip->regs, GPIO_BLINK_CNT_SELECT_OFF + mvchip->offset,\n\t\t     mvpwm->blink_select);\n\tregmap_write(mvpwm->regs, mvebu_pwmreg_blink_on_duration(mvpwm),\n\t\t     mvpwm->blink_on_duration);\n\tregmap_write(mvpwm->regs, mvebu_pwmreg_blink_off_duration(mvpwm),\n\t\t     mvpwm->blink_off_duration);\n}\n\nstatic int mvebu_pwm_probe(struct platform_device *pdev,\n\t\t\t   struct mvebu_gpio_chip *mvchip,\n\t\t\t   int id)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mvebu_pwm *mvpwm;\n\tvoid __iomem *base;\n\tu32 offset;\n\tu32 set;\n\n\tif (mvchip->soc_variant == MVEBU_GPIO_SOC_VARIANT_A8K) {\n\t\tint ret = of_property_read_u32(dev->of_node,\n\t\t\t\t\t       \"marvell,pwm-offset\", &offset);\n\t\tif (ret < 0)\n\t\t\treturn 0;\n\t} else {\n\t\t \n\t\tif (!platform_get_resource_byname(pdev, IORESOURCE_MEM, \"pwm\"))\n\t\t\treturn 0;\n\t\toffset = 0;\n\t}\n\n\tif (IS_ERR(mvchip->clk))\n\t\treturn PTR_ERR(mvchip->clk);\n\n\tmvpwm = devm_kzalloc(dev, sizeof(struct mvebu_pwm), GFP_KERNEL);\n\tif (!mvpwm)\n\t\treturn -ENOMEM;\n\tmvchip->mvpwm = mvpwm;\n\tmvpwm->mvchip = mvchip;\n\tmvpwm->offset = offset;\n\n\tif (mvchip->soc_variant == MVEBU_GPIO_SOC_VARIANT_A8K) {\n\t\tmvpwm->regs = mvchip->regs;\n\n\t\tswitch (mvchip->offset) {\n\t\tcase AP80X_GPIO0_OFF_A8K:\n\t\tcase CP11X_GPIO0_OFF_A8K:\n\t\t\t \n\t\t\tset = 0;\n\t\t\tbreak;\n\t\tcase CP11X_GPIO1_OFF_A8K:\n\t\t\t \n\t\t\tset = U32_MAX;\n\t\t\tmvpwm->offset += PWM_BLINK_COUNTER_B_OFF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tbase = devm_platform_ioremap_resource_byname(pdev, \"pwm\");\n\t\tif (IS_ERR(base))\n\t\t\treturn PTR_ERR(base);\n\n\t\tmvpwm->regs = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t\t    &mvebu_gpio_regmap_config);\n\t\tif (IS_ERR(mvpwm->regs))\n\t\t\treturn PTR_ERR(mvpwm->regs);\n\n\t\t \n\t\tif (id == 0)\n\t\t\tset = 0;\n\t\telse if (id == 1)\n\t\t\tset = U32_MAX;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(mvchip->regs,\n\t\t     GPIO_BLINK_CNT_SELECT_OFF + mvchip->offset, set);\n\n\tmvpwm->clk_rate = clk_get_rate(mvchip->clk);\n\tif (!mvpwm->clk_rate) {\n\t\tdev_err(dev, \"failed to get clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmvpwm->chip.dev = dev;\n\tmvpwm->chip.ops = &mvebu_pwm_ops;\n\tmvpwm->chip.npwm = mvchip->chip.ngpio;\n\n\tspin_lock_init(&mvpwm->lock);\n\n\treturn devm_pwmchip_add(dev, &mvpwm->chip);\n}\n\n#ifdef CONFIG_DEBUG_FS\n#include <linux/seq_file.h>\n\nstatic void mvebu_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\n\tu32 out, io_conf, blink, in_pol, data_in, cause, edg_msk, lvl_msk;\n\tconst char *label;\n\tint i;\n\n\tregmap_read(mvchip->regs, GPIO_OUT_OFF + mvchip->offset, &out);\n\tregmap_read(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset, &io_conf);\n\tregmap_read(mvchip->regs, GPIO_BLINK_EN_OFF + mvchip->offset, &blink);\n\tregmap_read(mvchip->regs, GPIO_IN_POL_OFF + mvchip->offset, &in_pol);\n\tregmap_read(mvchip->regs, GPIO_DATA_IN_OFF + mvchip->offset, &data_in);\n\tcause\t= mvebu_gpio_read_edge_cause(mvchip);\n\tedg_msk\t= mvebu_gpio_read_edge_mask(mvchip);\n\tlvl_msk\t= mvebu_gpio_read_level_mask(mvchip);\n\n\tfor_each_requested_gpio(chip, i, label) {\n\t\tu32 msk;\n\t\tbool is_out;\n\n\t\tmsk = BIT(i);\n\t\tis_out = !(io_conf & msk);\n\n\t\tseq_printf(s, \" gpio-%-3d (%-20.20s)\", chip->base + i, label);\n\n\t\tif (is_out) {\n\t\t\tseq_printf(s, \" out %s %s\\n\",\n\t\t\t\t   out & msk ? \"hi\" : \"lo\",\n\t\t\t\t   blink & msk ? \"(blink )\" : \"\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(s, \" in  %s (act %s) - IRQ\",\n\t\t\t   (data_in ^ in_pol) & msk  ? \"hi\" : \"lo\",\n\t\t\t   in_pol & msk ? \"lo\" : \"hi\");\n\t\tif (!((edg_msk | lvl_msk) & msk)) {\n\t\t\tseq_puts(s, \" disabled\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (edg_msk & msk)\n\t\t\tseq_puts(s, \" edge \");\n\t\tif (lvl_msk & msk)\n\t\t\tseq_puts(s, \" level\");\n\t\tseq_printf(s, \" (%s)\\n\", cause & msk ? \"pending\" : \"clear  \");\n\t}\n}\n#else\n#define mvebu_gpio_dbg_show NULL\n#endif\n\nstatic const struct of_device_id mvebu_gpio_of_match[] = {\n\t{\n\t\t.compatible = \"marvell,orion-gpio\",\n\t\t.data\t    = (void *) MVEBU_GPIO_SOC_VARIANT_ORION,\n\t},\n\t{\n\t\t.compatible = \"marvell,mv78200-gpio\",\n\t\t.data\t    = (void *) MVEBU_GPIO_SOC_VARIANT_MV78200,\n\t},\n\t{\n\t\t.compatible = \"marvell,armadaxp-gpio\",\n\t\t.data\t    = (void *) MVEBU_GPIO_SOC_VARIANT_ARMADAXP,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-370-gpio\",\n\t\t.data\t    = (void *) MVEBU_GPIO_SOC_VARIANT_ORION,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-8k-gpio\",\n\t\t.data       = (void *) MVEBU_GPIO_SOC_VARIANT_A8K,\n\t},\n\t{\n\t\t \n\t},\n};\n\nstatic int mvebu_gpio_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct mvebu_gpio_chip *mvchip = platform_get_drvdata(pdev);\n\tint i;\n\n\tregmap_read(mvchip->regs, GPIO_OUT_OFF + mvchip->offset,\n\t\t    &mvchip->out_reg);\n\tregmap_read(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset,\n\t\t    &mvchip->io_conf_reg);\n\tregmap_read(mvchip->regs, GPIO_BLINK_EN_OFF + mvchip->offset,\n\t\t    &mvchip->blink_en_reg);\n\tregmap_read(mvchip->regs, GPIO_IN_POL_OFF + mvchip->offset,\n\t\t    &mvchip->in_pol_reg);\n\n\tswitch (mvchip->soc_variant) {\n\tcase MVEBU_GPIO_SOC_VARIANT_ORION:\n\tcase MVEBU_GPIO_SOC_VARIANT_A8K:\n\t\tregmap_read(mvchip->regs, GPIO_EDGE_MASK_OFF + mvchip->offset,\n\t\t\t    &mvchip->edge_mask_regs[0]);\n\t\tregmap_read(mvchip->regs, GPIO_LEVEL_MASK_OFF + mvchip->offset,\n\t\t\t    &mvchip->level_mask_regs[0]);\n\t\tbreak;\n\tcase MVEBU_GPIO_SOC_VARIANT_MV78200:\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tregmap_read(mvchip->regs,\n\t\t\t\t    GPIO_EDGE_MASK_MV78200_OFF(i),\n\t\t\t\t    &mvchip->edge_mask_regs[i]);\n\t\t\tregmap_read(mvchip->regs,\n\t\t\t\t    GPIO_LEVEL_MASK_MV78200_OFF(i),\n\t\t\t\t    &mvchip->level_mask_regs[i]);\n\t\t}\n\t\tbreak;\n\tcase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tregmap_read(mvchip->regs,\n\t\t\t\t    GPIO_EDGE_MASK_ARMADAXP_OFF(i),\n\t\t\t\t    &mvchip->edge_mask_regs[i]);\n\t\t\tregmap_read(mvchip->regs,\n\t\t\t\t    GPIO_LEVEL_MASK_ARMADAXP_OFF(i),\n\t\t\t\t    &mvchip->level_mask_regs[i]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (IS_REACHABLE(CONFIG_PWM))\n\t\tmvebu_pwm_suspend(mvchip);\n\n\treturn 0;\n}\n\nstatic int mvebu_gpio_resume(struct platform_device *pdev)\n{\n\tstruct mvebu_gpio_chip *mvchip = platform_get_drvdata(pdev);\n\tint i;\n\n\tregmap_write(mvchip->regs, GPIO_OUT_OFF + mvchip->offset,\n\t\t     mvchip->out_reg);\n\tregmap_write(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset,\n\t\t     mvchip->io_conf_reg);\n\tregmap_write(mvchip->regs, GPIO_BLINK_EN_OFF + mvchip->offset,\n\t\t     mvchip->blink_en_reg);\n\tregmap_write(mvchip->regs, GPIO_IN_POL_OFF + mvchip->offset,\n\t\t     mvchip->in_pol_reg);\n\n\tswitch (mvchip->soc_variant) {\n\tcase MVEBU_GPIO_SOC_VARIANT_ORION:\n\tcase MVEBU_GPIO_SOC_VARIANT_A8K:\n\t\tregmap_write(mvchip->regs, GPIO_EDGE_MASK_OFF + mvchip->offset,\n\t\t\t     mvchip->edge_mask_regs[0]);\n\t\tregmap_write(mvchip->regs, GPIO_LEVEL_MASK_OFF + mvchip->offset,\n\t\t\t     mvchip->level_mask_regs[0]);\n\t\tbreak;\n\tcase MVEBU_GPIO_SOC_VARIANT_MV78200:\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tregmap_write(mvchip->regs,\n\t\t\t\t     GPIO_EDGE_MASK_MV78200_OFF(i),\n\t\t\t\t     mvchip->edge_mask_regs[i]);\n\t\t\tregmap_write(mvchip->regs,\n\t\t\t\t     GPIO_LEVEL_MASK_MV78200_OFF(i),\n\t\t\t\t     mvchip->level_mask_regs[i]);\n\t\t}\n\t\tbreak;\n\tcase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tregmap_write(mvchip->regs,\n\t\t\t\t     GPIO_EDGE_MASK_ARMADAXP_OFF(i),\n\t\t\t\t     mvchip->edge_mask_regs[i]);\n\t\t\tregmap_write(mvchip->regs,\n\t\t\t\t     GPIO_LEVEL_MASK_ARMADAXP_OFF(i),\n\t\t\t\t     mvchip->level_mask_regs[i]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (IS_REACHABLE(CONFIG_PWM))\n\t\tmvebu_pwm_resume(mvchip);\n\n\treturn 0;\n}\n\nstatic int mvebu_gpio_probe_raw(struct platform_device *pdev,\n\t\t\t\tstruct mvebu_gpio_chip *mvchip)\n{\n\tvoid __iomem *base;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tmvchip->regs = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t     &mvebu_gpio_regmap_config);\n\tif (IS_ERR(mvchip->regs))\n\t\treturn PTR_ERR(mvchip->regs);\n\n\t \n\tmvchip->offset = 0;\n\n\t \n\tif (mvchip->soc_variant == MVEBU_GPIO_SOC_VARIANT_ARMADAXP) {\n\t\tbase = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(base))\n\t\t\treturn PTR_ERR(base);\n\n\t\tmvchip->percpu_regs =\n\t\t\tdevm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t      &mvebu_gpio_regmap_config);\n\t\tif (IS_ERR(mvchip->percpu_regs))\n\t\t\treturn PTR_ERR(mvchip->percpu_regs);\n\t}\n\n\treturn 0;\n}\n\nstatic int mvebu_gpio_probe_syscon(struct platform_device *pdev,\n\t\t\t\t   struct mvebu_gpio_chip *mvchip)\n{\n\tmvchip->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(mvchip->regs))\n\t\treturn PTR_ERR(mvchip->regs);\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"offset\", &mvchip->offset))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void mvebu_gpio_remove_irq_domain(void *data)\n{\n\tstruct irq_domain *domain = data;\n\n\tirq_domain_remove(domain);\n}\n\nstatic int mvebu_gpio_probe(struct platform_device *pdev)\n{\n\tstruct mvebu_gpio_chip *mvchip;\n\tconst struct of_device_id *match;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\tunsigned int ngpios;\n\tbool have_irqs;\n\tint soc_variant;\n\tint i, cpu, id;\n\tint err;\n\n\tmatch = of_match_device(mvebu_gpio_of_match, &pdev->dev);\n\tif (match)\n\t\tsoc_variant = (unsigned long) match->data;\n\telse\n\t\tsoc_variant = MVEBU_GPIO_SOC_VARIANT_ORION;\n\n\t \n\terr = platform_irq_count(pdev);\n\tif (err < 0)\n\t\treturn err;\n\n\thave_irqs = err != 0;\n\n\tmvchip = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_gpio_chip),\n\t\t\t      GFP_KERNEL);\n\tif (!mvchip)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, mvchip);\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"ngpios\", &ngpios)) {\n\t\tdev_err(&pdev->dev, \"Missing ngpios OF property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tid = of_alias_get_id(pdev->dev.of_node, \"gpio\");\n\tif (id < 0) {\n\t\tdev_err(&pdev->dev, \"Couldn't get OF id\\n\");\n\t\treturn id;\n\t}\n\n\tmvchip->clk = devm_clk_get(&pdev->dev, NULL);\n\t \n\tif (!IS_ERR(mvchip->clk))\n\t\tclk_prepare_enable(mvchip->clk);\n\n\tmvchip->soc_variant = soc_variant;\n\tmvchip->chip.label = dev_name(&pdev->dev);\n\tmvchip->chip.parent = &pdev->dev;\n\tmvchip->chip.request = gpiochip_generic_request;\n\tmvchip->chip.free = gpiochip_generic_free;\n\tmvchip->chip.get_direction = mvebu_gpio_get_direction;\n\tmvchip->chip.direction_input = mvebu_gpio_direction_input;\n\tmvchip->chip.get = mvebu_gpio_get;\n\tmvchip->chip.direction_output = mvebu_gpio_direction_output;\n\tmvchip->chip.set = mvebu_gpio_set;\n\tif (have_irqs)\n\t\tmvchip->chip.to_irq = mvebu_gpio_to_irq;\n\tmvchip->chip.base = id * MVEBU_MAX_GPIO_PER_BANK;\n\tmvchip->chip.ngpio = ngpios;\n\tmvchip->chip.can_sleep = false;\n\tmvchip->chip.dbg_show = mvebu_gpio_dbg_show;\n\n\tif (soc_variant == MVEBU_GPIO_SOC_VARIANT_A8K)\n\t\terr = mvebu_gpio_probe_syscon(pdev, mvchip);\n\telse\n\t\terr = mvebu_gpio_probe_raw(pdev, mvchip);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tswitch (soc_variant) {\n\tcase MVEBU_GPIO_SOC_VARIANT_ORION:\n\tcase MVEBU_GPIO_SOC_VARIANT_A8K:\n\t\tregmap_write(mvchip->regs,\n\t\t\t     GPIO_EDGE_CAUSE_OFF + mvchip->offset, 0);\n\t\tregmap_write(mvchip->regs,\n\t\t\t     GPIO_EDGE_MASK_OFF + mvchip->offset, 0);\n\t\tregmap_write(mvchip->regs,\n\t\t\t     GPIO_LEVEL_MASK_OFF + mvchip->offset, 0);\n\t\tbreak;\n\tcase MVEBU_GPIO_SOC_VARIANT_MV78200:\n\t\tregmap_write(mvchip->regs, GPIO_EDGE_CAUSE_OFF, 0);\n\t\tfor (cpu = 0; cpu < 2; cpu++) {\n\t\t\tregmap_write(mvchip->regs,\n\t\t\t\t     GPIO_EDGE_MASK_MV78200_OFF(cpu), 0);\n\t\t\tregmap_write(mvchip->regs,\n\t\t\t\t     GPIO_LEVEL_MASK_MV78200_OFF(cpu), 0);\n\t\t}\n\t\tbreak;\n\tcase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\n\t\tregmap_write(mvchip->regs, GPIO_EDGE_CAUSE_OFF, 0);\n\t\tregmap_write(mvchip->regs, GPIO_EDGE_MASK_OFF, 0);\n\t\tregmap_write(mvchip->regs, GPIO_LEVEL_MASK_OFF, 0);\n\t\tfor (cpu = 0; cpu < 4; cpu++) {\n\t\t\tregmap_write(mvchip->percpu_regs,\n\t\t\t\t     GPIO_EDGE_CAUSE_ARMADAXP_OFF(cpu), 0);\n\t\t\tregmap_write(mvchip->percpu_regs,\n\t\t\t\t     GPIO_EDGE_MASK_ARMADAXP_OFF(cpu), 0);\n\t\t\tregmap_write(mvchip->percpu_regs,\n\t\t\t\t     GPIO_LEVEL_MASK_ARMADAXP_OFF(cpu), 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tdevm_gpiochip_add_data(&pdev->dev, &mvchip->chip, mvchip);\n\n\t \n\tif (IS_REACHABLE(CONFIG_PWM)) {\n\t\terr = mvebu_pwm_probe(pdev, mvchip, id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (!have_irqs)\n\t\treturn 0;\n\n\tmvchip->domain =\n\t    irq_domain_add_linear(np, ngpios, &irq_generic_chip_ops, NULL);\n\tif (!mvchip->domain) {\n\t\tdev_err(&pdev->dev, \"couldn't allocate irq domain %s (DT).\\n\",\n\t\t\tmvchip->chip.label);\n\t\treturn -ENODEV;\n\t}\n\n\terr = devm_add_action_or_reset(&pdev->dev, mvebu_gpio_remove_irq_domain,\n\t\t\t\t       mvchip->domain);\n\tif (err)\n\t\treturn err;\n\n\terr = irq_alloc_domain_generic_chips(\n\t    mvchip->domain, ngpios, 2, np->name, handle_level_irq,\n\t    IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_LEVEL, 0, 0);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"couldn't allocate irq chips %s (DT).\\n\",\n\t\t\tmvchip->chip.label);\n\t\treturn err;\n\t}\n\n\t \n\tgc = irq_get_domain_generic_chip(mvchip->domain, 0);\n\tgc->private = mvchip;\n\tct = &gc->chip_types[0];\n\tct->type = IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW;\n\tct->chip.irq_mask = mvebu_gpio_level_irq_mask;\n\tct->chip.irq_unmask = mvebu_gpio_level_irq_unmask;\n\tct->chip.irq_set_type = mvebu_gpio_irq_set_type;\n\tct->chip.name = mvchip->chip.label;\n\n\tct = &gc->chip_types[1];\n\tct->type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\n\tct->chip.irq_ack = mvebu_gpio_irq_ack;\n\tct->chip.irq_mask = mvebu_gpio_edge_irq_mask;\n\tct->chip.irq_unmask = mvebu_gpio_edge_irq_unmask;\n\tct->chip.irq_set_type = mvebu_gpio_irq_set_type;\n\tct->handler = handle_edge_irq;\n\tct->chip.name = mvchip->chip.label;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tint irq = platform_get_irq_optional(pdev, i);\n\n\t\tif (irq < 0)\n\t\t\tcontinue;\n\t\tirq_set_chained_handler_and_data(irq, mvebu_gpio_irq_handler,\n\t\t\t\t\t\t mvchip);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver mvebu_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"mvebu-gpio\",\n\t\t.of_match_table = mvebu_gpio_of_match,\n\t},\n\t.probe\t\t= mvebu_gpio_probe,\n\t.suspend        = mvebu_gpio_suspend,\n\t.resume         = mvebu_gpio_resume,\n};\nbuiltin_platform_driver(mvebu_gpio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}