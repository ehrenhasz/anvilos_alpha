{
  "module_name": "gpio-janz-ttl.c",
  "hash_id": "b46cd431e0ff5eb59a91f60688d0539af56bad6a63b73197f10031453143d57e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-janz-ttl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/gpio/driver.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\n#include <linux/mfd/janz.h>\n\n#define DRV_NAME \"janz-ttl\"\n\n#define PORTA_DIRECTION\t\t0x23\n#define PORTB_DIRECTION\t\t0x2B\n#define PORTC_DIRECTION\t\t0x06\n#define PORTA_IOCTL\t\t0x24\n#define PORTB_IOCTL\t\t0x2C\n#define PORTC_IOCTL\t\t0x07\n\n#define MASTER_INT_CTL\t\t0x00\n#define MASTER_CONF_CTL\t\t0x01\n\n#define CONF_PAE\t\tBIT(2)\n#define CONF_PBE\t\tBIT(7)\n#define CONF_PCE\t\tBIT(4)\n\nstruct ttl_control_regs {\n\t__be16 portc;\n\t__be16 portb;\n\t__be16 porta;\n\t__be16 control;\n};\n\nstruct ttl_module {\n\tstruct gpio_chip gpio;\n\n\t \n\tstruct ttl_control_regs __iomem *regs;\n\n\tu8 portc_shadow;\n\tu8 portb_shadow;\n\tu8 porta_shadow;\n\n\tspinlock_t lock;\n};\n\nstatic int ttl_get_value(struct gpio_chip *gpio, unsigned offset)\n{\n\tstruct ttl_module *mod = dev_get_drvdata(gpio->parent);\n\tu8 *shadow;\n\tint ret;\n\n\tif (offset < 8) {\n\t\tshadow = &mod->porta_shadow;\n\t} else if (offset < 16) {\n\t\tshadow = &mod->portb_shadow;\n\t\toffset -= 8;\n\t} else {\n\t\tshadow = &mod->portc_shadow;\n\t\toffset -= 16;\n\t}\n\n\tspin_lock(&mod->lock);\n\tret = *shadow & BIT(offset);\n\tspin_unlock(&mod->lock);\n\treturn !!ret;\n}\n\nstatic void ttl_set_value(struct gpio_chip *gpio, unsigned offset, int value)\n{\n\tstruct ttl_module *mod = dev_get_drvdata(gpio->parent);\n\tvoid __iomem *port;\n\tu8 *shadow;\n\n\tif (offset < 8) {\n\t\tport = &mod->regs->porta;\n\t\tshadow = &mod->porta_shadow;\n\t} else if (offset < 16) {\n\t\tport = &mod->regs->portb;\n\t\tshadow = &mod->portb_shadow;\n\t\toffset -= 8;\n\t} else {\n\t\tport = &mod->regs->portc;\n\t\tshadow = &mod->portc_shadow;\n\t\toffset -= 16;\n\t}\n\n\tspin_lock(&mod->lock);\n\tif (value)\n\t\t*shadow |= BIT(offset);\n\telse\n\t\t*shadow &= ~BIT(offset);\n\n\tiowrite16be(*shadow, port);\n\tspin_unlock(&mod->lock);\n}\n\nstatic void ttl_write_reg(struct ttl_module *mod, u8 reg, u16 val)\n{\n\tiowrite16be(reg, &mod->regs->control);\n\tiowrite16be(val, &mod->regs->control);\n}\n\nstatic void ttl_setup_device(struct ttl_module *mod)\n{\n\t \n\tiowrite16be(0x0000, &mod->regs->control);\n\tiowrite16be(0x0001, &mod->regs->control);\n\tiowrite16be(0x0000, &mod->regs->control);\n\n\t \n\tttl_write_reg(mod, PORTA_IOCTL, 0x00ff);\n\tttl_write_reg(mod, PORTB_IOCTL, 0x00ff);\n\tttl_write_reg(mod, PORTC_IOCTL, 0x000f);\n\n\t \n\tttl_write_reg(mod, PORTA_DIRECTION, 0x0000);\n\tttl_write_reg(mod, PORTB_DIRECTION, 0x0000);\n\tttl_write_reg(mod, PORTC_DIRECTION, 0x0000);\n\n\t \n\tiowrite16be(0x0000, &mod->regs->porta);\n\tiowrite16be(0x0000, &mod->regs->portb);\n\tiowrite16be(0x0000, &mod->regs->portc);\n\n\t \n\tttl_write_reg(mod, MASTER_CONF_CTL, CONF_PAE | CONF_PBE | CONF_PCE);\n}\n\nstatic int ttl_probe(struct platform_device *pdev)\n{\n\tstruct janz_platform_data *pdata;\n\tstruct ttl_module *mod;\n\tstruct gpio_chip *gpio;\n\tint ret;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tmod = devm_kzalloc(&pdev->dev, sizeof(*mod), GFP_KERNEL);\n\tif (!mod)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, mod);\n\tspin_lock_init(&mod->lock);\n\n\t \n\tmod->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mod->regs))\n\t\treturn PTR_ERR(mod->regs);\n\n\tttl_setup_device(mod);\n\n\t \n\tgpio = &mod->gpio;\n\tgpio->parent = &pdev->dev;\n\tgpio->label = pdev->name;\n\tgpio->get = ttl_get_value;\n\tgpio->set = ttl_set_value;\n\tgpio->owner = THIS_MODULE;\n\n\t \n\tgpio->base = -1;\n\tgpio->ngpio = 20;\n\n\tret = devm_gpiochip_add_data(&pdev->dev, gpio, NULL);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to add GPIO chip\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver ttl_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t},\n\t.probe\t\t= ttl_probe,\n};\n\nmodule_platform_driver(ttl_driver);\n\nMODULE_AUTHOR(\"Ira W. Snyder <iws@ovro.caltech.edu>\");\nMODULE_DESCRIPTION(\"Janz MODULbus VMOD-TTL Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:janz-ttl\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}