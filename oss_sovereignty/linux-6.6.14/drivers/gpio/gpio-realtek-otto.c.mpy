{
  "module_name": "gpio-realtek-otto.c",
  "hash_id": "1bf695b319fb88af8aae0e327c0aa037a1189e0ec318a81fbba15f2ad19f3317",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-realtek-otto.c",
  "human_readable_source": "\n\n#include <linux/gpio/driver.h>\n#include <linux/cpumask.h>\n#include <linux/irq.h>\n#include <linux/minmax.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n \n\n \n#define REALTEK_GPIO_REG_CNR\t\t0x00\n \n#define REALTEK_GPIO_REG_DIR\t\t0x08\n#define REALTEK_GPIO_REG_DATA\t\t0x0C\n \n#define REALTEK_GPIO_REG_ISR\t\t0x10\n \n#define REALTEK_GPIO_REG_IMR\t\t0x14\n#define REALTEK_GPIO_REG_IMR_AB\t\t0x14\n#define REALTEK_GPIO_REG_IMR_CD\t\t0x18\n#define REALTEK_GPIO_IMR_LINE_MASK\tGENMASK(1, 0)\n#define REALTEK_GPIO_IRQ_EDGE_FALLING\t1\n#define REALTEK_GPIO_IRQ_EDGE_RISING\t2\n#define REALTEK_GPIO_IRQ_EDGE_BOTH\t3\n\n#define REALTEK_GPIO_MAX\t\t32\n#define REALTEK_GPIO_PORTS_PER_BANK\t4\n\n \nstruct realtek_gpio_ctrl {\n\tstruct gpio_chip gc;\n\tvoid __iomem *base;\n\tvoid __iomem *cpumask_base;\n\tstruct cpumask cpu_irq_maskable;\n\traw_spinlock_t lock;\n\tu8 intr_mask[REALTEK_GPIO_MAX];\n\tu8 intr_type[REALTEK_GPIO_MAX];\n\tu32 (*bank_read)(void __iomem *reg);\n\tvoid (*bank_write)(void __iomem *reg, u32 value);\n\tunsigned int (*line_imr_pos)(unsigned int line);\n};\n\n \nenum realtek_gpio_flags {\n\t \n\tGPIO_INTERRUPTS_DISABLED = BIT(0),\n\t \n\tGPIO_PORTS_REVERSED = BIT(1),\n\t \n\tGPIO_INTERRUPTS_PER_CPU = BIT(2),\n};\n\nstatic struct realtek_gpio_ctrl *irq_data_to_ctrl(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\n\treturn container_of(gc, struct realtek_gpio_ctrl, gc);\n}\n\n \nstatic u32 realtek_gpio_bank_read_swapped(void __iomem *reg)\n{\n\treturn ioread32be(reg);\n}\n\nstatic void realtek_gpio_bank_write_swapped(void __iomem *reg, u32 value)\n{\n\tiowrite32be(value, reg);\n}\n\nstatic unsigned int realtek_gpio_line_imr_pos_swapped(unsigned int line)\n{\n\tunsigned int port_pin = line % 8;\n\tunsigned int port = line / 8;\n\n\treturn 2 * (8 * (port ^ 1) + port_pin);\n}\n\n \nstatic u32 realtek_gpio_bank_read(void __iomem *reg)\n{\n\treturn ioread32(reg);\n}\n\nstatic void realtek_gpio_bank_write(void __iomem *reg, u32 value)\n{\n\tiowrite32(value, reg);\n}\n\nstatic unsigned int realtek_gpio_line_imr_pos(unsigned int line)\n{\n\treturn 2 * line;\n}\n\nstatic void realtek_gpio_clear_isr(struct realtek_gpio_ctrl *ctrl, u32 mask)\n{\n\tctrl->bank_write(ctrl->base + REALTEK_GPIO_REG_ISR, mask);\n}\n\nstatic u32 realtek_gpio_read_isr(struct realtek_gpio_ctrl *ctrl)\n{\n\treturn ctrl->bank_read(ctrl->base + REALTEK_GPIO_REG_ISR);\n}\n\n \nstatic void realtek_gpio_update_line_imr(struct realtek_gpio_ctrl *ctrl, unsigned int line)\n{\n\tvoid __iomem *reg = ctrl->base + REALTEK_GPIO_REG_IMR;\n\tunsigned int line_shift = ctrl->line_imr_pos(line);\n\tunsigned int shift = line_shift % 32;\n\tu32 irq_type = ctrl->intr_type[line];\n\tu32 irq_mask = ctrl->intr_mask[line];\n\tu32 reg_val;\n\n\treg += 4 * (line_shift / 32);\n\treg_val = ioread32(reg);\n\treg_val &= ~(REALTEK_GPIO_IMR_LINE_MASK << shift);\n\treg_val |= (irq_type & irq_mask & REALTEK_GPIO_IMR_LINE_MASK) << shift;\n\tiowrite32(reg_val, reg);\n}\n\nstatic void realtek_gpio_irq_ack(struct irq_data *data)\n{\n\tstruct realtek_gpio_ctrl *ctrl = irq_data_to_ctrl(data);\n\tirq_hw_number_t line = irqd_to_hwirq(data);\n\n\trealtek_gpio_clear_isr(ctrl, BIT(line));\n}\n\nstatic void realtek_gpio_irq_unmask(struct irq_data *data)\n{\n\tstruct realtek_gpio_ctrl *ctrl = irq_data_to_ctrl(data);\n\tunsigned int line = irqd_to_hwirq(data);\n\tunsigned long flags;\n\n\tgpiochip_enable_irq(&ctrl->gc, line);\n\n\traw_spin_lock_irqsave(&ctrl->lock, flags);\n\tctrl->intr_mask[line] = REALTEK_GPIO_IMR_LINE_MASK;\n\trealtek_gpio_update_line_imr(ctrl, line);\n\traw_spin_unlock_irqrestore(&ctrl->lock, flags);\n}\n\nstatic void realtek_gpio_irq_mask(struct irq_data *data)\n{\n\tstruct realtek_gpio_ctrl *ctrl = irq_data_to_ctrl(data);\n\tunsigned int line = irqd_to_hwirq(data);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ctrl->lock, flags);\n\tctrl->intr_mask[line] = 0;\n\trealtek_gpio_update_line_imr(ctrl, line);\n\traw_spin_unlock_irqrestore(&ctrl->lock, flags);\n\n\tgpiochip_disable_irq(&ctrl->gc, line);\n}\n\nstatic int realtek_gpio_irq_set_type(struct irq_data *data, unsigned int flow_type)\n{\n\tstruct realtek_gpio_ctrl *ctrl = irq_data_to_ctrl(data);\n\tunsigned int line = irqd_to_hwirq(data);\n\tunsigned long flags;\n\tu8 type;\n\n\tswitch (flow_type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\ttype = REALTEK_GPIO_IRQ_EDGE_FALLING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\ttype = REALTEK_GPIO_IRQ_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\ttype = REALTEK_GPIO_IRQ_EDGE_BOTH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tirq_set_handler_locked(data, handle_edge_irq);\n\n\traw_spin_lock_irqsave(&ctrl->lock, flags);\n\tctrl->intr_type[line] = type;\n\trealtek_gpio_update_line_imr(ctrl, line);\n\traw_spin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic void realtek_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct realtek_gpio_ctrl *ctrl = gpiochip_get_data(gc);\n\tstruct irq_chip *irq_chip = irq_desc_get_chip(desc);\n\tunsigned long status;\n\tint offset;\n\n\tchained_irq_enter(irq_chip, desc);\n\n\tstatus = realtek_gpio_read_isr(ctrl);\n\tfor_each_set_bit(offset, &status, gc->ngpio)\n\t\tgeneric_handle_domain_irq(gc->irq.domain, offset);\n\n\tchained_irq_exit(irq_chip, desc);\n}\n\nstatic inline void __iomem *realtek_gpio_irq_cpu_mask(struct realtek_gpio_ctrl *ctrl, int cpu)\n{\n\treturn ctrl->cpumask_base + REALTEK_GPIO_PORTS_PER_BANK * cpu;\n}\n\nstatic int realtek_gpio_irq_set_affinity(struct irq_data *data,\n\tconst struct cpumask *dest, bool force)\n{\n\tstruct realtek_gpio_ctrl *ctrl = irq_data_to_ctrl(data);\n\tunsigned int line = irqd_to_hwirq(data);\n\tvoid __iomem *irq_cpu_mask;\n\tunsigned long flags;\n\tint cpu;\n\tu32 v;\n\n\tif (!ctrl->cpumask_base)\n\t\treturn -ENXIO;\n\n\traw_spin_lock_irqsave(&ctrl->lock, flags);\n\n\tfor_each_cpu(cpu, &ctrl->cpu_irq_maskable) {\n\t\tirq_cpu_mask = realtek_gpio_irq_cpu_mask(ctrl, cpu);\n\t\tv = ctrl->bank_read(irq_cpu_mask);\n\n\t\tif (cpumask_test_cpu(cpu, dest))\n\t\t\tv |= BIT(line);\n\t\telse\n\t\t\tv &= ~BIT(line);\n\n\t\tctrl->bank_write(irq_cpu_mask, v);\n\t}\n\n\traw_spin_unlock_irqrestore(&ctrl->lock, flags);\n\n\tirq_data_update_effective_affinity(data, dest);\n\n\treturn 0;\n}\n\nstatic int realtek_gpio_irq_init(struct gpio_chip *gc)\n{\n\tstruct realtek_gpio_ctrl *ctrl = gpiochip_get_data(gc);\n\tu32 mask_all = GENMASK(gc->ngpio - 1, 0);\n\tunsigned int line;\n\tint cpu;\n\n\tfor (line = 0; line < gc->ngpio; line++)\n\t\trealtek_gpio_update_line_imr(ctrl, line);\n\n\trealtek_gpio_clear_isr(ctrl, mask_all);\n\n\tfor_each_cpu(cpu, &ctrl->cpu_irq_maskable)\n\t\tctrl->bank_write(realtek_gpio_irq_cpu_mask(ctrl, cpu), mask_all);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip realtek_gpio_irq_chip = {\n\t.name = \"realtek-otto-gpio\",\n\t.irq_ack = realtek_gpio_irq_ack,\n\t.irq_mask = realtek_gpio_irq_mask,\n\t.irq_unmask = realtek_gpio_irq_unmask,\n\t.irq_set_type = realtek_gpio_irq_set_type,\n\t.irq_set_affinity = realtek_gpio_irq_set_affinity,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic const struct of_device_id realtek_gpio_of_match[] = {\n\t{\n\t\t.compatible = \"realtek,otto-gpio\",\n\t\t.data = (void *)GPIO_INTERRUPTS_DISABLED,\n\t},\n\t{\n\t\t.compatible = \"realtek,rtl8380-gpio\",\n\t},\n\t{\n\t\t.compatible = \"realtek,rtl8390-gpio\",\n\t},\n\t{\n\t\t.compatible = \"realtek,rtl9300-gpio\",\n\t\t.data = (void *)(GPIO_PORTS_REVERSED | GPIO_INTERRUPTS_PER_CPU)\n\t},\n\t{\n\t\t.compatible = \"realtek,rtl9310-gpio\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, realtek_gpio_of_match);\n\nstatic int realtek_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tunsigned long bgpio_flags;\n\tunsigned int dev_flags;\n\tstruct gpio_irq_chip *girq;\n\tstruct realtek_gpio_ctrl *ctrl;\n\tstruct resource *res;\n\tu32 ngpios;\n\tunsigned int nr_cpus;\n\tint cpu, err, irq;\n\n\tctrl = devm_kzalloc(dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tdev_flags = (unsigned int) device_get_match_data(dev);\n\n\tngpios = REALTEK_GPIO_MAX;\n\tdevice_property_read_u32(dev, \"ngpios\", &ngpios);\n\n\tif (ngpios > REALTEK_GPIO_MAX) {\n\t\tdev_err(&pdev->dev, \"invalid ngpios (max. %d)\\n\",\n\t\t\tREALTEK_GPIO_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\tctrl->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctrl->base))\n\t\treturn PTR_ERR(ctrl->base);\n\n\traw_spin_lock_init(&ctrl->lock);\n\n\tif (dev_flags & GPIO_PORTS_REVERSED) {\n\t\tbgpio_flags = 0;\n\t\tctrl->bank_read = realtek_gpio_bank_read;\n\t\tctrl->bank_write = realtek_gpio_bank_write;\n\t\tctrl->line_imr_pos = realtek_gpio_line_imr_pos;\n\t} else {\n\t\tbgpio_flags = BGPIOF_BIG_ENDIAN_BYTE_ORDER;\n\t\tctrl->bank_read = realtek_gpio_bank_read_swapped;\n\t\tctrl->bank_write = realtek_gpio_bank_write_swapped;\n\t\tctrl->line_imr_pos = realtek_gpio_line_imr_pos_swapped;\n\t}\n\n\terr = bgpio_init(&ctrl->gc, dev, 4,\n\t\tctrl->base + REALTEK_GPIO_REG_DATA, NULL, NULL,\n\t\tctrl->base + REALTEK_GPIO_REG_DIR, NULL,\n\t\tbgpio_flags);\n\tif (err) {\n\t\tdev_err(dev, \"unable to init generic GPIO\");\n\t\treturn err;\n\t}\n\n\tctrl->gc.ngpio = ngpios;\n\tctrl->gc.owner = THIS_MODULE;\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (!(dev_flags & GPIO_INTERRUPTS_DISABLED) && irq > 0) {\n\t\tgirq = &ctrl->gc.irq;\n\t\tgpio_irq_chip_set_chip(girq, &realtek_gpio_irq_chip);\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_bad_irq;\n\t\tgirq->parent_handler = realtek_gpio_irq_handler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(dev, girq->num_parents,\n\t\t\t\t\tsizeof(*girq->parents),\tGFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\tgirq->parents[0] = irq;\n\t\tgirq->init_hw = realtek_gpio_irq_init;\n\t}\n\n\tcpumask_clear(&ctrl->cpu_irq_maskable);\n\n\tif ((dev_flags & GPIO_INTERRUPTS_PER_CPU) && irq > 0) {\n\t\tctrl->cpumask_base = devm_platform_get_and_ioremap_resource(pdev, 1, &res);\n\t\tif (IS_ERR(ctrl->cpumask_base))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(ctrl->cpumask_base),\n\t\t\t\t\"missing CPU IRQ mask registers\");\n\n\t\tnr_cpus = resource_size(res) / REALTEK_GPIO_PORTS_PER_BANK;\n\t\tnr_cpus = min(nr_cpus, num_present_cpus());\n\n\t\tfor (cpu = 0; cpu < nr_cpus; cpu++)\n\t\t\tcpumask_set_cpu(cpu, &ctrl->cpu_irq_maskable);\n\t}\n\n\treturn devm_gpiochip_add_data(dev, &ctrl->gc, ctrl);\n}\n\nstatic struct platform_driver realtek_gpio_driver = {\n\t.driver = {\n\t\t.name = \"realtek-otto-gpio\",\n\t\t.of_match_table\t= realtek_gpio_of_match,\n\t},\n\t.probe = realtek_gpio_probe,\n};\nmodule_platform_driver(realtek_gpio_driver);\n\nMODULE_DESCRIPTION(\"Realtek Otto GPIO support\");\nMODULE_AUTHOR(\"Sander Vanheule <sander@svanheule.net>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}