{
  "module_name": "gpio-max730x.c",
  "hash_id": "1341cdedf9a61f4779f8f67675d4ad3573f234da2541c789f79db44fb66e2f90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-max730x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/spi/max7301.h>\n#include <linux/gpio/driver.h>\n#include <linux/slab.h>\n\n \n#define PIN_CONFIG_MASK 0x03\n#define PIN_CONFIG_IN_PULLUP 0x03\n#define PIN_CONFIG_IN_WO_PULLUP 0x02\n#define PIN_CONFIG_OUT 0x01\n\n#define PIN_NUMBER 28\n\nstatic int max7301_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct max7301 *ts = container_of(chip, struct max7301, chip);\n\tu8 *config;\n\tu8 offset_bits, pin_config;\n\tint ret;\n\n\t \n\toffset += 4;\n\toffset_bits = (offset & 3) << 1;\n\n\tconfig = &ts->port_config[offset >> 2];\n\n\tif (ts->input_pullup_active & BIT(offset))\n\t\tpin_config = PIN_CONFIG_IN_PULLUP;\n\telse\n\t\tpin_config = PIN_CONFIG_IN_WO_PULLUP;\n\n\tmutex_lock(&ts->lock);\n\n\t*config = (*config & ~(PIN_CONFIG_MASK << offset_bits))\n\t\t\t   | (pin_config << offset_bits);\n\n\tret = ts->write(ts->dev, 0x08 + (offset >> 2), *config);\n\n\tmutex_unlock(&ts->lock);\n\n\treturn ret;\n}\n\nstatic int __max7301_set(struct max7301 *ts, unsigned offset, int value)\n{\n\tif (value) {\n\t\tts->out_level |= 1 << offset;\n\t\treturn ts->write(ts->dev, 0x20 + offset, 0x01);\n\t} else {\n\t\tts->out_level &= ~(1 << offset);\n\t\treturn ts->write(ts->dev, 0x20 + offset, 0x00);\n\t}\n}\n\nstatic int max7301_direction_output(struct gpio_chip *chip, unsigned offset,\n\t\t\t\t    int value)\n{\n\tstruct max7301 *ts = container_of(chip, struct max7301, chip);\n\tu8 *config;\n\tu8 offset_bits;\n\tint ret;\n\n\t \n\toffset += 4;\n\toffset_bits = (offset & 3) << 1;\n\n\tconfig = &ts->port_config[offset >> 2];\n\n\tmutex_lock(&ts->lock);\n\n\t*config = (*config & ~(PIN_CONFIG_MASK << offset_bits))\n\t\t\t   | (PIN_CONFIG_OUT << offset_bits);\n\n\tret = __max7301_set(ts, offset, value);\n\n\tif (!ret)\n\t\tret = ts->write(ts->dev, 0x08 + (offset >> 2), *config);\n\n\tmutex_unlock(&ts->lock);\n\n\treturn ret;\n}\n\nstatic int max7301_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct max7301 *ts = gpiochip_get_data(chip);\n\tint config, level = -EINVAL;\n\n\t \n\toffset += 4;\n\n\tmutex_lock(&ts->lock);\n\n\tconfig = (ts->port_config[offset >> 2] >> ((offset & 3) << 1))\n\t\t\t& PIN_CONFIG_MASK;\n\n\tswitch (config) {\n\tcase PIN_CONFIG_OUT:\n\t\t \n\t\tlevel =  !!(ts->out_level & (1 << offset));\n\t\tbreak;\n\tcase PIN_CONFIG_IN_WO_PULLUP:\n\tcase PIN_CONFIG_IN_PULLUP:\n\t\t \n\t\tlevel = ts->read(ts->dev, 0x20 + offset) & 0x01;\n\t}\n\tmutex_unlock(&ts->lock);\n\n\treturn level;\n}\n\nstatic void max7301_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct max7301 *ts = gpiochip_get_data(chip);\n\n\t \n\toffset += 4;\n\n\tmutex_lock(&ts->lock);\n\n\t__max7301_set(ts, offset, value);\n\n\tmutex_unlock(&ts->lock);\n}\n\nint __max730x_probe(struct max7301 *ts)\n{\n\tstruct device *dev = ts->dev;\n\tstruct max7301_platform_data *pdata;\n\tint i, ret;\n\n\tpdata = dev_get_platdata(dev);\n\n\tmutex_init(&ts->lock);\n\tdev_set_drvdata(dev, ts);\n\n\t \n\tts->write(dev, 0x04, 0x01);\n\n\tif (pdata) {\n\t\tts->input_pullup_active = pdata->input_pullup_active;\n\t\tts->chip.base = pdata->base;\n\t} else {\n\t\tts->chip.base = -1;\n\t}\n\tts->chip.label = dev->driver->name;\n\n\tts->chip.direction_input = max7301_direction_input;\n\tts->chip.get = max7301_get;\n\tts->chip.direction_output = max7301_direction_output;\n\tts->chip.set = max7301_set;\n\n\tts->chip.ngpio = PIN_NUMBER;\n\tts->chip.can_sleep = true;\n\tts->chip.parent = dev;\n\tts->chip.owner = THIS_MODULE;\n\n\t \n\tfor (i = 1; i < 8; i++) {\n\t\tint j;\n\t\t \n\t\tts->port_config[i] = 0xAA;\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tint offset = (i - 1) * 4 + j;\n\t\t\tret = max7301_direction_input(&ts->chip, offset);\n\t\t\tif (ret)\n\t\t\t\tgoto exit_destroy;\n\t\t}\n\t}\n\n\tret = gpiochip_add_data(&ts->chip, ts);\n\tif (!ret)\n\t\treturn ret;\n\nexit_destroy:\n\tmutex_destroy(&ts->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__max730x_probe);\n\nvoid __max730x_remove(struct device *dev)\n{\n\tstruct max7301 *ts = dev_get_drvdata(dev);\n\n\t \n\tts->write(dev, 0x04, 0x00);\n\tgpiochip_remove(&ts->chip);\n\tmutex_destroy(&ts->lock);\n}\nEXPORT_SYMBOL_GPL(__max730x_remove);\n\nMODULE_AUTHOR(\"Juergen Beisert, Wolfram Sang\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MAX730x GPIO-Expanders, generic parts\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}