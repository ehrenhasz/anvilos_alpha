{
  "module_name": "gpio-wcove.c",
  "hash_id": "63020ba19a0b0b0fb09b84a509a1f4cffe74b383ca72d3c71b418fa92a596bdb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-wcove.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n\n \n#define BANK0_NR_PINS\t\t7\n#define BANK1_NR_PINS\t\t4\n#define BANK2_NR_PINS\t\t2\n#define WCOVE_GPIO_NUM\t\t(BANK0_NR_PINS + BANK1_NR_PINS + BANK2_NR_PINS)\n#define WCOVE_VGPIO_NUM\t\t94\n \n#define GPIO_OUT_CTRL_BASE\t0x4e44\n \n#define GPIO_IN_CTRL_BASE\t0x4e51\n\n \n#define GROUP0_NR_IRQS\t\t7\n#define GROUP1_NR_IRQS\t\t6\n#define IRQ_MASK_BASE\t\t0x4e19\n#define IRQ_STATUS_BASE\t\t0x4e0b\n#define GPIO_IRQ0_MASK\t\tGENMASK(6, 0)\n#define GPIO_IRQ1_MASK\t\tGENMASK(5, 0)\n#define UPDATE_IRQ_TYPE\t\tBIT(0)\n#define UPDATE_IRQ_MASK\t\tBIT(1)\n\n#define CTLI_INTCNT_DIS\t\t(0 << 1)\n#define CTLI_INTCNT_NE\t\t(1 << 1)\n#define CTLI_INTCNT_PE\t\t(2 << 1)\n#define CTLI_INTCNT_BE\t\t(3 << 1)\n\n#define CTLO_DIR_IN\t\t(0 << 5)\n#define CTLO_DIR_OUT\t\t(1 << 5)\n\n#define CTLO_DRV_MASK\t\t(1 << 4)\n#define CTLO_DRV_OD\t\t(0 << 4)\n#define CTLO_DRV_CMOS\t\t(1 << 4)\n\n#define CTLO_DRV_REN\t\t(1 << 3)\n\n#define CTLO_RVAL_2KDOWN\t(0 << 1)\n#define CTLO_RVAL_2KUP\t\t(1 << 1)\n#define CTLO_RVAL_50KDOWN\t(2 << 1)\n#define CTLO_RVAL_50KUP\t\t(3 << 1)\n\n#define CTLO_INPUT_SET\t\t(CTLO_DRV_CMOS | CTLO_DRV_REN | CTLO_RVAL_2KUP)\n#define CTLO_OUTPUT_SET\t\t(CTLO_DIR_OUT | CTLO_INPUT_SET)\n\nenum ctrl_register {\n\tCTRL_IN,\n\tCTRL_OUT,\n\tIRQ_STATUS,\n\tIRQ_MASK,\n};\n\n \nstruct wcove_gpio {\n\tstruct mutex buslock;\n\tstruct gpio_chip chip;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regmap_irq_chip_data *regmap_irq_chip;\n\tint update;\n\tint intcnt;\n\tbool set_irq_mask;\n};\n\nstatic inline int to_reg(int gpio, enum ctrl_register type)\n{\n\tunsigned int reg = type == CTRL_IN ? GPIO_IN_CTRL_BASE : GPIO_OUT_CTRL_BASE;\n\n\tif (gpio >= WCOVE_GPIO_NUM)\n\t\treturn -EOPNOTSUPP;\n\n\treturn reg + gpio;\n}\n\nstatic inline int to_ireg(int gpio, enum ctrl_register type, unsigned int *mask)\n{\n\tunsigned int reg = type == IRQ_STATUS ? IRQ_STATUS_BASE : IRQ_MASK_BASE;\n\n\tif (gpio < GROUP0_NR_IRQS) {\n\t\treg += 0;\n\t\t*mask = BIT(gpio);\n\t} else {\n\t\treg += 1;\n\t\t*mask = BIT(gpio - GROUP0_NR_IRQS);\n\t}\n\n\treturn reg;\n}\n\nstatic void wcove_update_irq_mask(struct wcove_gpio *wg, irq_hw_number_t gpio)\n{\n\tunsigned int mask, reg = to_ireg(gpio, IRQ_MASK, &mask);\n\n\tif (wg->set_irq_mask)\n\t\tregmap_set_bits(wg->regmap, reg, mask);\n\telse\n\t\tregmap_clear_bits(wg->regmap, reg, mask);\n}\n\nstatic void wcove_update_irq_ctrl(struct wcove_gpio *wg, irq_hw_number_t gpio)\n{\n\tint reg = to_reg(gpio, CTRL_IN);\n\n\tregmap_update_bits(wg->regmap, reg, CTLI_INTCNT_BE, wg->intcnt);\n}\n\nstatic int wcove_gpio_dir_in(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\tint reg = to_reg(gpio, CTRL_OUT);\n\n\tif (reg < 0)\n\t\treturn 0;\n\n\treturn regmap_write(wg->regmap, reg, CTLO_INPUT_SET);\n}\n\nstatic int wcove_gpio_dir_out(struct gpio_chip *chip, unsigned int gpio,\n\t\t\t\t    int value)\n{\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\tint reg = to_reg(gpio, CTRL_OUT);\n\n\tif (reg < 0)\n\t\treturn 0;\n\n\treturn regmap_write(wg->regmap, reg, CTLO_OUTPUT_SET | value);\n}\n\nstatic int wcove_gpio_get_direction(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\tunsigned int val;\n\tint ret, reg = to_reg(gpio, CTRL_OUT);\n\n\tif (reg < 0)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\tret = regmap_read(wg->regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & CTLO_DIR_OUT)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int wcove_gpio_get(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\tunsigned int val;\n\tint ret, reg = to_reg(gpio, CTRL_IN);\n\n\tif (reg < 0)\n\t\treturn 0;\n\n\tret = regmap_read(wg->regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val & 0x1;\n}\n\nstatic void wcove_gpio_set(struct gpio_chip *chip, unsigned int gpio, int value)\n{\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\tint reg = to_reg(gpio, CTRL_OUT);\n\n\tif (reg < 0)\n\t\treturn;\n\n\tif (value)\n\t\tregmap_set_bits(wg->regmap, reg, 1);\n\telse\n\t\tregmap_clear_bits(wg->regmap, reg, 1);\n}\n\nstatic int wcove_gpio_set_config(struct gpio_chip *chip, unsigned int gpio,\n\t\t\t\t unsigned long config)\n{\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\tint reg = to_reg(gpio, CTRL_OUT);\n\n\tif (reg < 0)\n\t\treturn 0;\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\treturn regmap_update_bits(wg->regmap, reg, CTLO_DRV_MASK,\n\t\t\t\t\t  CTLO_DRV_OD);\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\treturn regmap_update_bits(wg->regmap, reg, CTLO_DRV_MASK,\n\t\t\t\t\t  CTLO_DRV_CMOS);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic int wcove_irq_type(struct irq_data *data, unsigned int type)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\tirq_hw_number_t gpio = irqd_to_hwirq(data);\n\n\tif (gpio >= WCOVE_GPIO_NUM)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_NONE:\n\t\twg->intcnt = CTLI_INTCNT_DIS;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\twg->intcnt = CTLI_INTCNT_BE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\twg->intcnt = CTLI_INTCNT_PE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\twg->intcnt = CTLI_INTCNT_NE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twg->update |= UPDATE_IRQ_TYPE;\n\n\treturn 0;\n}\n\nstatic void wcove_bus_lock(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\n\tmutex_lock(&wg->buslock);\n}\n\nstatic void wcove_bus_sync_unlock(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\tirq_hw_number_t gpio = irqd_to_hwirq(data);\n\n\tif (wg->update & UPDATE_IRQ_TYPE)\n\t\twcove_update_irq_ctrl(wg, gpio);\n\tif (wg->update & UPDATE_IRQ_MASK)\n\t\twcove_update_irq_mask(wg, gpio);\n\twg->update = 0;\n\n\tmutex_unlock(&wg->buslock);\n}\n\nstatic void wcove_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\tirq_hw_number_t gpio = irqd_to_hwirq(data);\n\n\tif (gpio >= WCOVE_GPIO_NUM)\n\t\treturn;\n\n\tgpiochip_enable_irq(chip, gpio);\n\n\twg->set_irq_mask = false;\n\twg->update |= UPDATE_IRQ_MASK;\n}\n\nstatic void wcove_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\tirq_hw_number_t gpio = irqd_to_hwirq(data);\n\n\tif (gpio >= WCOVE_GPIO_NUM)\n\t\treturn;\n\n\twg->set_irq_mask = true;\n\twg->update |= UPDATE_IRQ_MASK;\n\n\tgpiochip_disable_irq(chip, gpio);\n}\n\nstatic const struct irq_chip wcove_irqchip = {\n\t.name\t\t\t= \"Whiskey Cove\",\n\t.irq_mask\t\t= wcove_irq_mask,\n\t.irq_unmask\t\t= wcove_irq_unmask,\n\t.irq_set_type\t\t= wcove_irq_type,\n\t.irq_bus_lock\t\t= wcove_bus_lock,\n\t.irq_bus_sync_unlock\t= wcove_bus_sync_unlock,\n\t.flags\t\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic irqreturn_t wcove_gpio_irq_handler(int irq, void *data)\n{\n\tstruct wcove_gpio *wg = (struct wcove_gpio *)data;\n\tunsigned int virq, gpio;\n\tunsigned long pending;\n\tu8 p[2];\n\n\tif (regmap_bulk_read(wg->regmap, IRQ_STATUS_BASE, p, 2)) {\n\t\tdev_err(wg->dev, \"Failed to read irq status register\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tpending = (p[0] & GPIO_IRQ0_MASK) | ((p[1] & GPIO_IRQ1_MASK) << 7);\n\tif (!pending)\n\t\treturn IRQ_NONE;\n\n\t \n\twhile (pending) {\n\t\t \n\t\tfor_each_set_bit(gpio, &pending, WCOVE_GPIO_NUM) {\n\t\t\tunsigned int mask, reg = to_ireg(gpio, IRQ_STATUS, &mask);\n\n\t\t\tvirq = irq_find_mapping(wg->chip.irq.domain, gpio);\n\t\t\thandle_nested_irq(virq);\n\t\t\tregmap_set_bits(wg->regmap, reg, mask);\n\t\t}\n\n\t\t \n\t\tif (regmap_bulk_read(wg->regmap, IRQ_STATUS_BASE, p, 2)) {\n\t\t\tdev_err(wg->dev, \"Failed to read irq status\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tpending = (p[0] & GPIO_IRQ0_MASK) | ((p[1] & GPIO_IRQ1_MASK) << 7);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void wcove_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tunsigned int ctlo, ctli, irq_mask, irq_status;\n\tstruct wcove_gpio *wg = gpiochip_get_data(chip);\n\tint gpio, mask, ret = 0;\n\n\tfor (gpio = 0; gpio < WCOVE_GPIO_NUM; gpio++) {\n\t\tret += regmap_read(wg->regmap, to_reg(gpio, CTRL_OUT), &ctlo);\n\t\tret += regmap_read(wg->regmap, to_reg(gpio, CTRL_IN), &ctli);\n\t\tif (ret) {\n\t\t\tdev_err(wg->dev, \"Failed to read registers: CTRL out/in\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tret += regmap_read(wg->regmap, to_ireg(gpio, IRQ_MASK, &mask), &irq_mask);\n\t\tret += regmap_read(wg->regmap, to_ireg(gpio, IRQ_STATUS, &mask), &irq_status);\n\t\tif (ret) {\n\t\t\tdev_err(wg->dev, \"Failed to read registers: IRQ status/mask\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tseq_printf(s, \" gpio-%-2d %s %s %s %s ctlo=%2x,%s %s\\n\",\n\t\t\t   gpio, ctlo & CTLO_DIR_OUT ? \"out\" : \"in \",\n\t\t\t   ctli & 0x1 ? \"hi\" : \"lo\",\n\t\t\t   ctli & CTLI_INTCNT_NE ? \"fall\" : \"    \",\n\t\t\t   ctli & CTLI_INTCNT_PE ? \"rise\" : \"    \",\n\t\t\t   ctlo,\n\t\t\t   irq_mask & mask ? \"mask  \" : \"unmask\",\n\t\t\t   irq_status & mask ? \"pending\" : \"       \");\n\t}\n}\n\nstatic int wcove_gpio_probe(struct platform_device *pdev)\n{\n\tstruct intel_soc_pmic *pmic;\n\tstruct wcove_gpio *wg;\n\tint virq, ret, irq;\n\tstruct device *dev;\n\tstruct gpio_irq_chip *girq;\n\n\t \n\tpmic = dev_get_drvdata(pdev->dev.parent);\n\tif (!pmic)\n\t\treturn -ENODEV;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tdev = &pdev->dev;\n\n\twg = devm_kzalloc(dev, sizeof(*wg), GFP_KERNEL);\n\tif (!wg)\n\t\treturn -ENOMEM;\n\n\twg->regmap_irq_chip = pmic->irq_chip_data;\n\n\tplatform_set_drvdata(pdev, wg);\n\n\tmutex_init(&wg->buslock);\n\twg->chip.label = KBUILD_MODNAME;\n\twg->chip.direction_input = wcove_gpio_dir_in;\n\twg->chip.direction_output = wcove_gpio_dir_out;\n\twg->chip.get_direction = wcove_gpio_get_direction;\n\twg->chip.get = wcove_gpio_get;\n\twg->chip.set = wcove_gpio_set;\n\twg->chip.set_config = wcove_gpio_set_config;\n\twg->chip.base = -1;\n\twg->chip.ngpio = WCOVE_VGPIO_NUM;\n\twg->chip.can_sleep = true;\n\twg->chip.parent = pdev->dev.parent;\n\twg->chip.dbg_show = wcove_gpio_dbg_show;\n\twg->dev = dev;\n\twg->regmap = pmic->regmap;\n\n\tvirq = regmap_irq_get_virq(wg->regmap_irq_chip, irq);\n\tif (virq < 0) {\n\t\tdev_err(dev, \"Failed to get virq by irq %d\\n\", irq);\n\t\treturn virq;\n\t}\n\n\tgirq = &wg->chip.irq;\n\tgpio_irq_chip_set_chip(girq, &wcove_irqchip);\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_simple_irq;\n\tgirq->threaded = true;\n\n\tret = devm_request_threaded_irq(dev, virq, NULL, wcove_gpio_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT, pdev->name, wg);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request irq %d\\n\", virq);\n\t\treturn ret;\n\t}\n\n\tret = devm_gpiochip_add_data(dev, &wg->chip, wg);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add gpiochip: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_clear_bits(wg->regmap, IRQ_MASK_BASE + 0, GPIO_IRQ0_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_clear_bits(wg->regmap, IRQ_MASK_BASE + 1, GPIO_IRQ1_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic struct platform_driver wcove_gpio_driver = {\n\t.driver = {\n\t\t.name = \"bxt_wcove_gpio\",\n\t},\n\t.probe = wcove_gpio_probe,\n};\n\nmodule_platform_driver(wcove_gpio_driver);\n\nMODULE_AUTHOR(\"Ajay Thomas <ajay.thomas.david.rajamanickam@intel.com>\");\nMODULE_AUTHOR(\"Bin Gao <bin.gao@intel.com>\");\nMODULE_DESCRIPTION(\"Intel Whiskey Cove GPIO Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:bxt_wcove_gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}