{
  "module_name": "gpio-xgene-sb.c",
  "hash_id": "3c6c291d653ed957dbf20d6c691ef95db18e87145f3926164a0dc7342cbfd6c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-xgene-sb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/driver.h>\n#include <linux/acpi.h>\n\n#include \"gpiolib.h\"\n#include \"gpiolib-acpi.h\"\n\n \n#define XGENE_NIRQ_PROPERTY\t\t\"apm,nr-irqs\"\n#define XGENE_NGPIO_PROPERTY\t\t\"apm,nr-gpios\"\n#define XGENE_IRQ_START_PROPERTY\t\"apm,irq-start\"\n\n#define XGENE_DFLT_MAX_NGPIO\t\t22\n#define XGENE_DFLT_MAX_NIRQ\t\t6\n#define XGENE_DFLT_IRQ_START_PIN\t8\n#define GPIO_MASK(x)\t\t\t(1U << ((x) % 32))\n\n#define MPA_GPIO_INT_LVL\t\t0x0290\n#define MPA_GPIO_OE_ADDR\t\t0x029c\n#define MPA_GPIO_OUT_ADDR\t\t0x02a0\n#define MPA_GPIO_IN_ADDR \t\t0x02a4\n#define MPA_GPIO_SEL_LO \t\t0x0294\n\n#define GPIO_INT_LEVEL_H\t0x000001\n#define GPIO_INT_LEVEL_L\t0x000000\n\n \nstruct xgene_gpio_sb {\n\tstruct gpio_chip\tgc;\n\tvoid __iomem\t\t*regs;\n\tstruct irq_domain\t*irq_domain;\n\tu16\t\t\tirq_start;\n\tu16\t\t\tnirq;\n\tu16\t\t\tparent_irq_base;\n};\n\n#define HWIRQ_TO_GPIO(priv, hwirq) ((hwirq) + (priv)->irq_start)\n#define GPIO_TO_HWIRQ(priv, gpio) ((gpio) - (priv)->irq_start)\n\nstatic void xgene_gpio_set_bit(struct gpio_chip *gc,\n\t\t\t\tvoid __iomem *reg, u32 gpio, int val)\n{\n\tu32 data;\n\n\tdata = gc->read_reg(reg);\n\tif (val)\n\t\tdata |= GPIO_MASK(gpio);\n\telse\n\t\tdata &= ~GPIO_MASK(gpio);\n\tgc->write_reg(reg, data);\n}\n\nstatic int xgene_gpio_sb_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct xgene_gpio_sb *priv = irq_data_get_irq_chip_data(d);\n\tint gpio = HWIRQ_TO_GPIO(priv, d->hwirq);\n\tint lvl_type = GPIO_INT_LEVEL_H;\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tlvl_type = GPIO_INT_LEVEL_H;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tlvl_type = GPIO_INT_LEVEL_L;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\txgene_gpio_set_bit(&priv->gc, priv->regs + MPA_GPIO_SEL_LO,\n\t\t\tgpio * 2, 1);\n\txgene_gpio_set_bit(&priv->gc, priv->regs + MPA_GPIO_INT_LVL,\n\t\t\td->hwirq, lvl_type);\n\n\t \n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\treturn irq_chip_set_type_parent(d, IRQ_TYPE_EDGE_RISING);\n\telse\n\t\treturn irq_chip_set_type_parent(d, IRQ_TYPE_LEVEL_HIGH);\n}\n\nstatic struct irq_chip xgene_gpio_sb_irq_chip = {\n\t.name           = \"sbgpio\",\n\t.irq_eoi\t= irq_chip_eoi_parent,\n\t.irq_mask       = irq_chip_mask_parent,\n\t.irq_unmask     = irq_chip_unmask_parent,\n\t.irq_set_type   = xgene_gpio_sb_irq_set_type,\n};\n\nstatic int xgene_gpio_sb_to_irq(struct gpio_chip *gc, u32 gpio)\n{\n\tstruct xgene_gpio_sb *priv = gpiochip_get_data(gc);\n\tstruct irq_fwspec fwspec;\n\n\tif ((gpio < priv->irq_start) ||\n\t\t\t(gpio > HWIRQ_TO_GPIO(priv, priv->nirq)))\n\t\treturn -ENXIO;\n\n\tfwspec.fwnode = gc->parent->fwnode;\n\tfwspec.param_count = 2;\n\tfwspec.param[0] = GPIO_TO_HWIRQ(priv, gpio);\n\tfwspec.param[1] = IRQ_TYPE_EDGE_RISING;\n\treturn irq_create_fwspec_mapping(&fwspec);\n}\n\nstatic int xgene_gpio_sb_domain_activate(struct irq_domain *d,\n\t\t\t\t\t struct irq_data *irq_data,\n\t\t\t\t\t bool reserve)\n{\n\tstruct xgene_gpio_sb *priv = d->host_data;\n\tu32 gpio = HWIRQ_TO_GPIO(priv, irq_data->hwirq);\n\tint ret;\n\n\tret = gpiochip_lock_as_irq(&priv->gc, gpio);\n\tif (ret) {\n\t\tdev_err(priv->gc.parent,\n\t\t\"Unable to configure XGene GPIO standby pin %d as IRQ\\n\",\n\t\t\t\tgpio);\n\t\treturn ret;\n\t}\n\n\txgene_gpio_set_bit(&priv->gc, priv->regs + MPA_GPIO_SEL_LO,\n\t\t\tgpio * 2, 1);\n\treturn 0;\n}\n\nstatic void xgene_gpio_sb_domain_deactivate(struct irq_domain *d,\n\t\tstruct irq_data *irq_data)\n{\n\tstruct xgene_gpio_sb *priv = d->host_data;\n\tu32 gpio = HWIRQ_TO_GPIO(priv, irq_data->hwirq);\n\n\tgpiochip_unlock_as_irq(&priv->gc, gpio);\n\txgene_gpio_set_bit(&priv->gc, priv->regs + MPA_GPIO_SEL_LO,\n\t\t\tgpio * 2, 0);\n}\n\nstatic int xgene_gpio_sb_domain_translate(struct irq_domain *d,\n\t\tstruct irq_fwspec *fwspec,\n\t\tunsigned long *hwirq,\n\t\tunsigned int *type)\n{\n\tstruct xgene_gpio_sb *priv = d->host_data;\n\n\tif ((fwspec->param_count != 2) ||\n\t\t(fwspec->param[0] >= priv->nirq))\n\t\treturn -EINVAL;\n\t*hwirq = fwspec->param[0];\n\t*type = fwspec->param[1];\n\treturn 0;\n}\n\nstatic int xgene_gpio_sb_domain_alloc(struct irq_domain *domain,\n\t\t\t\t\tunsigned int virq,\n\t\t\t\t\tunsigned int nr_irqs, void *data)\n{\n\tstruct irq_fwspec *fwspec = data;\n\tstruct irq_fwspec parent_fwspec;\n\tstruct xgene_gpio_sb *priv = domain->host_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int i;\n\n\thwirq = fwspec->param[0];\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\n\t\t\t\t&xgene_gpio_sb_irq_chip, priv);\n\n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\tif (is_of_node(parent_fwspec.fwnode)) {\n\t\tparent_fwspec.param_count = 3;\n\t\tparent_fwspec.param[0] = 0; \n\t\t \n\t\tparent_fwspec.param[1] = hwirq + priv->parent_irq_base - 32;\n\t\tparent_fwspec.param[2] = fwspec->param[1];\n\t} else if (is_fwnode_irqchip(parent_fwspec.fwnode)) {\n\t\tparent_fwspec.param_count = 2;\n\t\tparent_fwspec.param[0] = hwirq + priv->parent_irq_base;\n\t\tparent_fwspec.param[1] = fwspec->param[1];\n\t} else\n\t\treturn -EINVAL;\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs,\n\t\t\t&parent_fwspec);\n}\n\nstatic const struct irq_domain_ops xgene_gpio_sb_domain_ops = {\n\t.translate      = xgene_gpio_sb_domain_translate,\n\t.alloc          = xgene_gpio_sb_domain_alloc,\n\t.free           = irq_domain_free_irqs_common,\n\t.activate\t= xgene_gpio_sb_domain_activate,\n\t.deactivate\t= xgene_gpio_sb_domain_deactivate,\n};\n\nstatic int xgene_gpio_sb_probe(struct platform_device *pdev)\n{\n\tstruct xgene_gpio_sb *priv;\n\tint ret;\n\tvoid __iomem *regs;\n\tstruct irq_domain *parent_domain = NULL;\n\tu32 val32;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tpriv->regs = regs;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret > 0) {\n\t\tpriv->parent_irq_base = irq_get_irq_data(ret)->hwirq;\n\t\tparent_domain = irq_get_irq_data(ret)->domain;\n\t}\n\tif (!parent_domain) {\n\t\tdev_err(&pdev->dev, \"unable to obtain parent domain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = bgpio_init(&priv->gc, &pdev->dev, 4,\n\t\t\tregs + MPA_GPIO_IN_ADDR,\n\t\t\tregs + MPA_GPIO_OUT_ADDR, NULL,\n\t\t\tregs + MPA_GPIO_OE_ADDR, NULL, 0);\n        if (ret)\n                return ret;\n\n\tpriv->gc.to_irq = xgene_gpio_sb_to_irq;\n\n\t \n\tpriv->irq_start = XGENE_DFLT_IRQ_START_PIN;\n\tif (!device_property_read_u32(&pdev->dev,\n\t\t\t\t\tXGENE_IRQ_START_PROPERTY, &val32))\n\t\tpriv->irq_start = val32;\n\n\t \n\tpriv->nirq = XGENE_DFLT_MAX_NIRQ;\n\tif (!device_property_read_u32(&pdev->dev, XGENE_NIRQ_PROPERTY, &val32))\n\t\tpriv->nirq = val32;\n\n\t \n\tpriv->gc.ngpio = XGENE_DFLT_MAX_NGPIO;\n\tif (!device_property_read_u32(&pdev->dev, XGENE_NGPIO_PROPERTY, &val32))\n\t\tpriv->gc.ngpio = val32;\n\n\tdev_info(&pdev->dev, \"Support %d gpios, %d irqs start from pin %d\\n\",\n\t\t\tpriv->gc.ngpio, priv->nirq, priv->irq_start);\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->irq_domain = irq_domain_create_hierarchy(parent_domain,\n\t\t\t\t\t0, priv->nirq, pdev->dev.fwnode,\n\t\t\t\t\t&xgene_gpio_sb_domain_ops, priv);\n\tif (!priv->irq_domain)\n\t\treturn -ENODEV;\n\n\tpriv->gc.irq.domain = priv->irq_domain;\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &priv->gc, priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to register X-Gene GPIO Standby driver\\n\");\n\t\tirq_domain_remove(priv->irq_domain);\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"X-Gene GPIO Standby driver registered\\n\");\n\n\t \n\tacpi_gpiochip_request_interrupts(&priv->gc);\n\n\treturn ret;\n}\n\nstatic int xgene_gpio_sb_remove(struct platform_device *pdev)\n{\n\tstruct xgene_gpio_sb *priv = platform_get_drvdata(pdev);\n\n\tacpi_gpiochip_free_interrupts(&priv->gc);\n\n\tirq_domain_remove(priv->irq_domain);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id xgene_gpio_sb_of_match[] = {\n\t{.compatible = \"apm,xgene-gpio-sb\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xgene_gpio_sb_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id xgene_gpio_sb_acpi_match[] = {\n\t{\"APMC0D15\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, xgene_gpio_sb_acpi_match);\n#endif\n\nstatic struct platform_driver xgene_gpio_sb_driver = {\n\t.driver = {\n\t\t   .name = \"xgene-gpio-sb\",\n\t\t   .of_match_table = xgene_gpio_sb_of_match,\n\t\t   .acpi_match_table = ACPI_PTR(xgene_gpio_sb_acpi_match),\n\t\t   },\n\t.probe = xgene_gpio_sb_probe,\n\t.remove = xgene_gpio_sb_remove,\n};\nmodule_platform_driver(xgene_gpio_sb_driver);\n\nMODULE_AUTHOR(\"AppliedMicro\");\nMODULE_DESCRIPTION(\"APM X-Gene GPIO Standby driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}