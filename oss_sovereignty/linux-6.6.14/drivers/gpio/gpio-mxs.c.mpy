{
  "module_name": "gpio-mxs.c",
  "hash_id": "2ace4ec1464beed0e604e99e1ea63da7cfec6022500a125e4d4caec2d76f45a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mxs.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n\n#define MXS_SET\t\t0x4\n#define MXS_CLR\t\t0x8\n\n#define PINCTRL_DOUT(p)\t\t((is_imx23_gpio(p) ? 0x0500 : 0x0700) + (p->id) * 0x10)\n#define PINCTRL_DIN(p)\t\t((is_imx23_gpio(p) ? 0x0600 : 0x0900) + (p->id) * 0x10)\n#define PINCTRL_DOE(p)\t\t((is_imx23_gpio(p) ? 0x0700 : 0x0b00) + (p->id) * 0x10)\n#define PINCTRL_PIN2IRQ(p)\t((is_imx23_gpio(p) ? 0x0800 : 0x1000) + (p->id) * 0x10)\n#define PINCTRL_IRQEN(p)\t((is_imx23_gpio(p) ? 0x0900 : 0x1100) + (p->id) * 0x10)\n#define PINCTRL_IRQLEV(p)\t((is_imx23_gpio(p) ? 0x0a00 : 0x1200) + (p->id) * 0x10)\n#define PINCTRL_IRQPOL(p)\t((is_imx23_gpio(p) ? 0x0b00 : 0x1300) + (p->id) * 0x10)\n#define PINCTRL_IRQSTAT(p)\t((is_imx23_gpio(p) ? 0x0c00 : 0x1400) + (p->id) * 0x10)\n\n#define GPIO_INT_FALL_EDGE\t0x0\n#define GPIO_INT_LOW_LEV\t0x1\n#define GPIO_INT_RISE_EDGE\t0x2\n#define GPIO_INT_HIGH_LEV\t0x3\n#define GPIO_INT_LEV_MASK\t(1 << 0)\n#define GPIO_INT_POL_MASK\t(1 << 1)\n\nenum mxs_gpio_id {\n\tIMX23_GPIO,\n\tIMX28_GPIO,\n};\n\nstruct mxs_gpio_port {\n\tvoid __iomem *base;\n\tint id;\n\tint irq;\n\tstruct irq_domain *domain;\n\tstruct gpio_chip gc;\n\tstruct device *dev;\n\tenum mxs_gpio_id devid;\n\tu32 both_edges;\n};\n\nstatic inline int is_imx23_gpio(struct mxs_gpio_port *port)\n{\n\treturn port->devid == IMX23_GPIO;\n}\n\n \n\nstatic int mxs_gpio_set_irq_type(struct irq_data *d, unsigned int type)\n{\n\tu32 val;\n\tu32 pin_mask = 1 << d->hwirq;\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tstruct mxs_gpio_port *port = gc->private;\n\tvoid __iomem *pin_addr;\n\tint edge;\n\n\tif (!(ct->type & type))\n\t\tif (irq_setup_alt_chip(d, type))\n\t\t\treturn -EINVAL;\n\n\tport->both_edges &= ~pin_mask;\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tval = readl(port->base + PINCTRL_DIN(port)) & pin_mask;\n\t\tif (val)\n\t\t\tedge = GPIO_INT_FALL_EDGE;\n\t\telse\n\t\t\tedge = GPIO_INT_RISE_EDGE;\n\t\tport->both_edges |= pin_mask;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tedge = GPIO_INT_RISE_EDGE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tedge = GPIO_INT_FALL_EDGE;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tedge = GPIO_INT_LOW_LEV;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tedge = GPIO_INT_HIGH_LEV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpin_addr = port->base + PINCTRL_IRQLEV(port);\n\tif (edge & GPIO_INT_LEV_MASK) {\n\t\twritel(pin_mask, pin_addr + MXS_SET);\n\t\twritel(pin_mask, port->base + PINCTRL_IRQEN(port) + MXS_SET);\n\t} else {\n\t\twritel(pin_mask, pin_addr + MXS_CLR);\n\t\twritel(pin_mask, port->base + PINCTRL_PIN2IRQ(port) + MXS_SET);\n\t}\n\n\t \n\tpin_addr = port->base + PINCTRL_IRQPOL(port);\n\tif (edge & GPIO_INT_POL_MASK)\n\t\twritel(pin_mask, pin_addr + MXS_SET);\n\telse\n\t\twritel(pin_mask, pin_addr + MXS_CLR);\n\n\twritel(pin_mask, port->base + PINCTRL_IRQSTAT(port) + MXS_CLR);\n\n\treturn 0;\n}\n\nstatic void mxs_flip_edge(struct mxs_gpio_port *port, u32 gpio)\n{\n\tu32 bit, val, edge;\n\tvoid __iomem *pin_addr;\n\n\tbit = 1 << gpio;\n\n\tpin_addr = port->base + PINCTRL_IRQPOL(port);\n\tval = readl(pin_addr);\n\tedge = val & bit;\n\n\tif (edge)\n\t\twritel(bit, pin_addr + MXS_CLR);\n\telse\n\t\twritel(bit, pin_addr + MXS_SET);\n}\n\n \nstatic void mxs_gpio_irq_handler(struct irq_desc *desc)\n{\n\tu32 irq_stat;\n\tstruct mxs_gpio_port *port = irq_desc_get_handler_data(desc);\n\n\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\n\tirq_stat = readl(port->base + PINCTRL_IRQSTAT(port)) &\n\t\t\treadl(port->base + PINCTRL_IRQEN(port));\n\n\twhile (irq_stat != 0) {\n\t\tint irqoffset = fls(irq_stat) - 1;\n\t\tif (port->both_edges & (1 << irqoffset))\n\t\t\tmxs_flip_edge(port, irqoffset);\n\n\t\tgeneric_handle_domain_irq(port->domain, irqoffset);\n\t\tirq_stat &= ~(1 << irqoffset);\n\t}\n}\n\n \nstatic int mxs_gpio_set_wake_irq(struct irq_data *d, unsigned int enable)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct mxs_gpio_port *port = gc->private;\n\n\tif (enable)\n\t\tenable_irq_wake(port->irq);\n\telse\n\t\tdisable_irq_wake(port->irq);\n\n\treturn 0;\n}\n\nstatic int mxs_gpio_init_gc(struct mxs_gpio_port *port, int irq_base)\n{\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\tint rv;\n\n\tgc = devm_irq_alloc_generic_chip(port->dev, \"gpio-mxs\", 2, irq_base,\n\t\t\t\t\t port->base, handle_level_irq);\n\tif (!gc)\n\t\treturn -ENOMEM;\n\n\tgc->private = port;\n\n\tct = &gc->chip_types[0];\n\tct->type = IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW;\n\tct->chip.irq_ack = irq_gc_ack_set_bit;\n\tct->chip.irq_mask = irq_gc_mask_disable_reg;\n\tct->chip.irq_unmask = irq_gc_unmask_enable_reg;\n\tct->chip.irq_set_type = mxs_gpio_set_irq_type;\n\tct->chip.irq_set_wake = mxs_gpio_set_wake_irq;\n\tct->chip.flags = IRQCHIP_SET_TYPE_MASKED;\n\tct->regs.ack = PINCTRL_IRQSTAT(port) + MXS_CLR;\n\tct->regs.enable = PINCTRL_PIN2IRQ(port) + MXS_SET;\n\tct->regs.disable = PINCTRL_PIN2IRQ(port) + MXS_CLR;\n\n\tct = &gc->chip_types[1];\n\tct->type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\n\tct->chip.irq_ack = irq_gc_ack_set_bit;\n\tct->chip.irq_mask = irq_gc_mask_disable_reg;\n\tct->chip.irq_unmask = irq_gc_unmask_enable_reg;\n\tct->chip.irq_set_type = mxs_gpio_set_irq_type;\n\tct->chip.irq_set_wake = mxs_gpio_set_wake_irq;\n\tct->chip.flags = IRQCHIP_SET_TYPE_MASKED;\n\tct->regs.ack = PINCTRL_IRQSTAT(port) + MXS_CLR;\n\tct->regs.enable = PINCTRL_IRQEN(port) + MXS_SET;\n\tct->regs.disable = PINCTRL_IRQEN(port) + MXS_CLR;\n\tct->handler = handle_level_irq;\n\n\trv = devm_irq_setup_generic_chip(port->dev, gc, IRQ_MSK(32),\n\t\t\t\t\t IRQ_GC_INIT_NESTED_LOCK,\n\t\t\t\t\t IRQ_NOREQUEST, 0);\n\n\treturn rv;\n}\n\nstatic int mxs_gpio_to_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct mxs_gpio_port *port = gpiochip_get_data(gc);\n\n\treturn irq_find_mapping(port->domain, offset);\n}\n\nstatic int mxs_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct mxs_gpio_port *port = gpiochip_get_data(gc);\n\tu32 mask = 1 << offset;\n\tu32 dir;\n\n\tdir = readl(port->base + PINCTRL_DOE(port));\n\tif (dir & mask)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic const struct of_device_id mxs_gpio_dt_ids[] = {\n\t{ .compatible = \"fsl,imx23-gpio\", .data = (void *) IMX23_GPIO, },\n\t{ .compatible = \"fsl,imx28-gpio\", .data = (void *) IMX28_GPIO, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxs_gpio_dt_ids);\n\nstatic int mxs_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *parent;\n\tstatic void __iomem *base;\n\tstruct mxs_gpio_port *port;\n\tint irq_base;\n\tint err;\n\n\tport = devm_kzalloc(&pdev->dev, sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->id = of_alias_get_id(np, \"gpio\");\n\tif (port->id < 0)\n\t\treturn port->id;\n\tport->devid = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\tport->dev = &pdev->dev;\n\tport->irq = platform_get_irq(pdev, 0);\n\tif (port->irq < 0)\n\t\treturn port->irq;\n\n\t \n\tif (!base) {\n\t\tparent = of_get_parent(np);\n\t\tbase = of_iomap(parent, 0);\n\t\tof_node_put(parent);\n\t\tif (!base)\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\tport->base = base;\n\n\t \n\twritel(0, port->base + PINCTRL_PIN2IRQ(port));\n\twritel(0, port->base + PINCTRL_IRQEN(port));\n\n\t \n\twritel(~0U, port->base + PINCTRL_IRQSTAT(port) + MXS_CLR);\n\n\tirq_base = devm_irq_alloc_descs(&pdev->dev, -1, 0, 32, numa_node_id());\n\tif (irq_base < 0) {\n\t\terr = irq_base;\n\t\tgoto out_iounmap;\n\t}\n\n\tport->domain = irq_domain_add_legacy(np, 32, irq_base, 0,\n\t\t\t\t\t     &irq_domain_simple_ops, NULL);\n\tif (!port->domain) {\n\t\terr = -ENODEV;\n\t\tgoto out_iounmap;\n\t}\n\n\t \n\terr = mxs_gpio_init_gc(port, irq_base);\n\tif (err < 0)\n\t\tgoto out_irqdomain_remove;\n\n\t \n\tirq_set_chained_handler_and_data(port->irq, mxs_gpio_irq_handler,\n\t\t\t\t\t port);\n\n\terr = bgpio_init(&port->gc, &pdev->dev, 4,\n\t\t\t port->base + PINCTRL_DIN(port),\n\t\t\t port->base + PINCTRL_DOUT(port) + MXS_SET,\n\t\t\t port->base + PINCTRL_DOUT(port) + MXS_CLR,\n\t\t\t port->base + PINCTRL_DOE(port), NULL, 0);\n\tif (err)\n\t\tgoto out_irqdomain_remove;\n\n\tport->gc.to_irq = mxs_gpio_to_irq;\n\tport->gc.get_direction = mxs_gpio_get_direction;\n\tport->gc.base = port->id * 32;\n\n\terr = gpiochip_add_data(&port->gc, port);\n\tif (err)\n\t\tgoto out_irqdomain_remove;\n\n\treturn 0;\n\nout_irqdomain_remove:\n\tirq_domain_remove(port->domain);\nout_iounmap:\n\tiounmap(port->base);\n\treturn err;\n}\n\nstatic struct platform_driver mxs_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"gpio-mxs\",\n\t\t.of_match_table = mxs_gpio_dt_ids,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= mxs_gpio_probe,\n};\n\nstatic int __init mxs_gpio_init(void)\n{\n\treturn platform_driver_register(&mxs_gpio_driver);\n}\npostcore_initcall(mxs_gpio_init);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, \"\n\t      \"Daniel Mack <danielncaiaq.de>, \"\n\t      \"Juergen Beisert <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"Freescale MXS GPIO\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}