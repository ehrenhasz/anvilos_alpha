{
  "module_name": "gpio-mm-lantiq.c",
  "hash_id": "4bcf038c05995be75b3ce00afb848c6498018f7bd34ab4db5526750459e57c6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mm-lantiq.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/legacy-of-mm-gpiochip.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include <lantiq_soc.h>\n\n \n\n#define LTQ_EBU_BUSCON\t0x1e7ff\t\t \n#define LTQ_EBU_WP\t0x80000000\t \n\nstruct ltq_mm {\n\tstruct of_mm_gpio_chip mmchip;\n\tu16 shadow;\t \n};\n\n \nstatic void ltq_mm_apply(struct ltq_mm *chip)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ebu_lock, flags);\n\tltq_ebu_w32(LTQ_EBU_BUSCON, LTQ_EBU_BUSCON1);\n\t__raw_writew(chip->shadow, chip->mmchip.regs);\n\tltq_ebu_w32(LTQ_EBU_BUSCON | LTQ_EBU_WP, LTQ_EBU_BUSCON1);\n\tspin_unlock_irqrestore(&ebu_lock, flags);\n}\n\n \nstatic void ltq_mm_set(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tstruct ltq_mm *chip = gpiochip_get_data(gc);\n\n\tif (value)\n\t\tchip->shadow |= (1 << offset);\n\telse\n\t\tchip->shadow &= ~(1 << offset);\n\tltq_mm_apply(chip);\n}\n\n \nstatic int ltq_mm_dir_out(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tltq_mm_set(gc, offset, value);\n\n\treturn 0;\n}\n\n \nstatic void ltq_mm_save_regs(struct of_mm_gpio_chip *mm_gc)\n{\n\tstruct ltq_mm *chip =\n\t\tcontainer_of(mm_gc, struct ltq_mm, mmchip);\n\n\t \n\tltq_ebu_w32(CPHYSADDR(chip->mmchip.regs) | 0x1, LTQ_EBU_ADDRSEL1);\n\n\tltq_mm_apply(chip);\n}\n\nstatic int ltq_mm_probe(struct platform_device *pdev)\n{\n\tstruct ltq_mm *chip;\n\tu32 shadow;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, chip);\n\n\tchip->mmchip.gc.ngpio = 16;\n\tchip->mmchip.gc.direction_output = ltq_mm_dir_out;\n\tchip->mmchip.gc.set = ltq_mm_set;\n\tchip->mmchip.save_regs = ltq_mm_save_regs;\n\n\t \n\tif (!of_property_read_u32(pdev->dev.of_node, \"lantiq,shadow\", &shadow))\n\t\tchip->shadow = shadow;\n\n\treturn of_mm_gpiochip_add_data(pdev->dev.of_node, &chip->mmchip, chip);\n}\n\nstatic int ltq_mm_remove(struct platform_device *pdev)\n{\n\tstruct ltq_mm *chip = platform_get_drvdata(pdev);\n\n\tof_mm_gpiochip_remove(&chip->mmchip);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ltq_mm_match[] = {\n\t{ .compatible = \"lantiq,gpio-mm\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ltq_mm_match);\n\nstatic struct platform_driver ltq_mm_driver = {\n\t.probe = ltq_mm_probe,\n\t.remove = ltq_mm_remove,\n\t.driver = {\n\t\t.name = \"gpio-mm-ltq\",\n\t\t.of_match_table = ltq_mm_match,\n\t},\n};\n\nstatic int __init ltq_mm_init(void)\n{\n\treturn platform_driver_register(&ltq_mm_driver);\n}\n\nsubsys_initcall(ltq_mm_init);\n\nstatic void __exit ltq_mm_exit(void)\n{\n\tplatform_driver_unregister(&ltq_mm_driver);\n}\nmodule_exit(ltq_mm_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}