{
  "module_name": "gpio-xtensa.c",
  "hash_id": "44b83dbe0eb20692b2dc6db658f2796719b582d77559af8df7596860e8bcf898",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-xtensa.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/gpio/driver.h>\n#include <linux/bitops.h>\n#include <linux/platform_device.h>\n\n#include <asm/coprocessor.h>  \n\n#ifndef XCHAL_CP_ID_XTIOP\n#error GPIO32 option is not enabled for your xtensa core variant\n#endif\n\n#if XCHAL_HAVE_CP\n\nstatic inline unsigned long enable_cp(unsigned long *cpenable)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t*cpenable = xtensa_get_sr(cpenable);\n\txtensa_set_sr(*cpenable | BIT(XCHAL_CP_ID_XTIOP), cpenable);\n\treturn flags;\n}\n\nstatic inline void disable_cp(unsigned long flags, unsigned long cpenable)\n{\n\txtensa_set_sr(cpenable, cpenable);\n\tlocal_irq_restore(flags);\n}\n\n#else\n\nstatic inline unsigned long enable_cp(unsigned long *cpenable)\n{\n\t*cpenable = 0;  \n\treturn 0;\n}\n\nstatic inline void disable_cp(unsigned long flags, unsigned long cpenable)\n{\n}\n\n#endif  \n\nstatic int xtensa_impwire_get_direction(struct gpio_chip *gc, unsigned offset)\n{\n\treturn GPIO_LINE_DIRECTION_IN;  \n}\n\nstatic int xtensa_impwire_get_value(struct gpio_chip *gc, unsigned offset)\n{\n\tunsigned long flags, saved_cpenable;\n\tu32 impwire;\n\n\tflags = enable_cp(&saved_cpenable);\n\t__asm__ __volatile__(\"read_impwire %0\" : \"=a\" (impwire));\n\tdisable_cp(flags, saved_cpenable);\n\n\treturn !!(impwire & BIT(offset));\n}\n\nstatic void xtensa_impwire_set_value(struct gpio_chip *gc, unsigned offset,\n\t\t\t\t    int value)\n{\n\tBUG();  \n}\n\nstatic int xtensa_expstate_get_direction(struct gpio_chip *gc, unsigned offset)\n{\n\treturn GPIO_LINE_DIRECTION_OUT;  \n}\n\nstatic int xtensa_expstate_get_value(struct gpio_chip *gc, unsigned offset)\n{\n\tunsigned long flags, saved_cpenable;\n\tu32 expstate;\n\n\tflags = enable_cp(&saved_cpenable);\n\t__asm__ __volatile__(\"rur.expstate %0\" : \"=a\" (expstate));\n\tdisable_cp(flags, saved_cpenable);\n\n\treturn !!(expstate & BIT(offset));\n}\n\nstatic void xtensa_expstate_set_value(struct gpio_chip *gc, unsigned offset,\n\t\t\t\t     int value)\n{\n\tunsigned long flags, saved_cpenable;\n\tu32 mask = BIT(offset);\n\tu32 val = value ? BIT(offset) : 0;\n\n\tflags = enable_cp(&saved_cpenable);\n\t__asm__ __volatile__(\"wrmsk_expstate %0, %1\"\n\t\t\t     :: \"a\" (val), \"a\" (mask));\n\tdisable_cp(flags, saved_cpenable);\n}\n\nstatic struct gpio_chip impwire_chip = {\n\t.label\t\t= \"impwire\",\n\t.base\t\t= -1,\n\t.ngpio\t\t= 32,\n\t.get_direction\t= xtensa_impwire_get_direction,\n\t.get\t\t= xtensa_impwire_get_value,\n\t.set\t\t= xtensa_impwire_set_value,\n};\n\nstatic struct gpio_chip expstate_chip = {\n\t.label\t\t= \"expstate\",\n\t.base\t\t= -1,\n\t.ngpio\t\t= 32,\n\t.get_direction\t= xtensa_expstate_get_direction,\n\t.get\t\t= xtensa_expstate_get_value,\n\t.set\t\t= xtensa_expstate_set_value,\n};\n\nstatic int xtensa_gpio_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = gpiochip_add_data(&impwire_chip, NULL);\n\tif (ret)\n\t\treturn ret;\n\treturn gpiochip_add_data(&expstate_chip, NULL);\n}\n\nstatic struct platform_driver xtensa_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"xtensa-gpio\",\n\t},\n\t.probe\t\t= xtensa_gpio_probe,\n};\n\nstatic int __init xtensa_gpio_init(void)\n{\n\tstruct platform_device *pdev;\n\n\tpdev = platform_device_register_simple(\"xtensa-gpio\", 0, NULL, 0);\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\treturn platform_driver_register(&xtensa_gpio_driver);\n}\ndevice_initcall(xtensa_gpio_init);\n\nMODULE_AUTHOR(\"Baruch Siach <baruch@tkos.co.il>\");\nMODULE_DESCRIPTION(\"Xtensa LX4 GPIO32 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}