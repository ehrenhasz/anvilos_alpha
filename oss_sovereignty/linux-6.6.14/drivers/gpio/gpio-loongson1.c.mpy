{
  "module_name": "gpio-loongson1.c",
  "hash_id": "541bd1b32ac8e8ba5175bab1c7b80f4f66889c4e63f2c0229600cc3f1576647c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-loongson1.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/gpio/driver.h>\n#include <linux/platform_device.h>\n#include <linux/bitops.h>\n\n \n#define GPIO_CFG\t\t0x0\n#define GPIO_DIR\t\t0x10\n#define GPIO_DATA\t\t0x20\n#define GPIO_OUTPUT\t\t0x30\n\nstruct ls1x_gpio_chip {\n\tstruct gpio_chip gc;\n\tvoid __iomem *reg_base;\n};\n\nstatic int ls1x_gpio_request(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct ls1x_gpio_chip *ls1x_gc = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\t__raw_writel(__raw_readl(ls1x_gc->reg_base + GPIO_CFG) | BIT(offset),\n\t\t     ls1x_gc->reg_base + GPIO_CFG);\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\n\treturn 0;\n}\n\nstatic void ls1x_gpio_free(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct ls1x_gpio_chip *ls1x_gc = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\t__raw_writel(__raw_readl(ls1x_gc->reg_base + GPIO_CFG) & ~BIT(offset),\n\t\t     ls1x_gc->reg_base + GPIO_CFG);\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n}\n\nstatic int ls1x_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ls1x_gpio_chip *ls1x_gc;\n\tint ret;\n\n\tls1x_gc = devm_kzalloc(dev, sizeof(*ls1x_gc), GFP_KERNEL);\n\tif (!ls1x_gc)\n\t\treturn -ENOMEM;\n\n\tls1x_gc->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ls1x_gc->reg_base))\n\t\treturn PTR_ERR(ls1x_gc->reg_base);\n\n\tret = bgpio_init(&ls1x_gc->gc, dev, 4, ls1x_gc->reg_base + GPIO_DATA,\n\t\t\t ls1x_gc->reg_base + GPIO_OUTPUT, NULL,\n\t\t\t NULL, ls1x_gc->reg_base + GPIO_DIR, 0);\n\tif (ret)\n\t\tgoto err;\n\n\tls1x_gc->gc.owner = THIS_MODULE;\n\tls1x_gc->gc.request = ls1x_gpio_request;\n\tls1x_gc->gc.free = ls1x_gpio_free;\n\t \n\tls1x_gc->gc.ngpio = 0;\n\n\tret = devm_gpiochip_add_data(dev, &ls1x_gc->gc, ls1x_gc);\n\tif (ret)\n\t\tgoto err;\n\n\tplatform_set_drvdata(pdev, ls1x_gc);\n\n\tdev_info(dev, \"GPIO controller registered with %d pins\\n\",\n\t\t ls1x_gc->gc.ngpio);\n\n\treturn 0;\nerr:\n\tdev_err(dev, \"failed to register GPIO controller\\n\");\n\treturn ret;\n}\n\nstatic const struct of_device_id ls1x_gpio_dt_ids[] = {\n\t{ .compatible = \"loongson,ls1x-gpio\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ls1x_gpio_dt_ids);\n\nstatic struct platform_driver ls1x_gpio_driver = {\n\t.probe\t= ls1x_gpio_probe,\n\t.driver\t= {\n\t\t.name\t= \"ls1x-gpio\",\n\t\t.of_match_table = ls1x_gpio_dt_ids,\n\t},\n};\n\nmodule_platform_driver(ls1x_gpio_driver);\n\nMODULE_AUTHOR(\"Keguang Zhang <keguang.zhang@gmail.com>\");\nMODULE_DESCRIPTION(\"Loongson1 GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}