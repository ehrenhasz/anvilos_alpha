{
  "module_name": "gpio-mmio.c",
  "hash_id": "edadf753e437cf32330406f7df4bf7ab243fcf155f0ef4ba84585f30a44be92a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mmio.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/log2.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/gpio/driver.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/platform_device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n\n#include \"gpiolib.h\"\n\nstatic void bgpio_write8(void __iomem *reg, unsigned long data)\n{\n\twriteb(data, reg);\n}\n\nstatic unsigned long bgpio_read8(void __iomem *reg)\n{\n\treturn readb(reg);\n}\n\nstatic void bgpio_write16(void __iomem *reg, unsigned long data)\n{\n\twritew(data, reg);\n}\n\nstatic unsigned long bgpio_read16(void __iomem *reg)\n{\n\treturn readw(reg);\n}\n\nstatic void bgpio_write32(void __iomem *reg, unsigned long data)\n{\n\twritel(data, reg);\n}\n\nstatic unsigned long bgpio_read32(void __iomem *reg)\n{\n\treturn readl(reg);\n}\n\n#if BITS_PER_LONG >= 64\nstatic void bgpio_write64(void __iomem *reg, unsigned long data)\n{\n\twriteq(data, reg);\n}\n\nstatic unsigned long bgpio_read64(void __iomem *reg)\n{\n\treturn readq(reg);\n}\n#endif  \n\nstatic void bgpio_write16be(void __iomem *reg, unsigned long data)\n{\n\tiowrite16be(data, reg);\n}\n\nstatic unsigned long bgpio_read16be(void __iomem *reg)\n{\n\treturn ioread16be(reg);\n}\n\nstatic void bgpio_write32be(void __iomem *reg, unsigned long data)\n{\n\tiowrite32be(data, reg);\n}\n\nstatic unsigned long bgpio_read32be(void __iomem *reg)\n{\n\treturn ioread32be(reg);\n}\n\nstatic unsigned long bgpio_line2mask(struct gpio_chip *gc, unsigned int line)\n{\n\tif (gc->be_bits)\n\t\treturn BIT(gc->bgpio_bits - 1 - line);\n\treturn BIT(line);\n}\n\nstatic int bgpio_get_set(struct gpio_chip *gc, unsigned int gpio)\n{\n\tunsigned long pinmask = bgpio_line2mask(gc, gpio);\n\tbool dir = !!(gc->bgpio_dir & pinmask);\n\n\tif (dir)\n\t\treturn !!(gc->read_reg(gc->reg_set) & pinmask);\n\telse\n\t\treturn !!(gc->read_reg(gc->reg_dat) & pinmask);\n}\n\n \nstatic int bgpio_get_set_multiple(struct gpio_chip *gc, unsigned long *mask,\n\t\t\t\t  unsigned long *bits)\n{\n\tunsigned long get_mask = 0;\n\tunsigned long set_mask = 0;\n\n\t \n\t*bits &= ~*mask;\n\n\tset_mask = *mask & gc->bgpio_dir;\n\tget_mask = *mask & ~gc->bgpio_dir;\n\n\tif (set_mask)\n\t\t*bits |= gc->read_reg(gc->reg_set) & set_mask;\n\tif (get_mask)\n\t\t*bits |= gc->read_reg(gc->reg_dat) & get_mask;\n\n\treturn 0;\n}\n\nstatic int bgpio_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\treturn !!(gc->read_reg(gc->reg_dat) & bgpio_line2mask(gc, gpio));\n}\n\n \nstatic int bgpio_get_multiple(struct gpio_chip *gc, unsigned long *mask,\n\t\t\t      unsigned long *bits)\n{\n\t \n\t*bits &= ~*mask;\n\t*bits |= gc->read_reg(gc->reg_dat) & *mask;\n\treturn 0;\n}\n\n \nstatic int bgpio_get_multiple_be(struct gpio_chip *gc, unsigned long *mask,\n\t\t\t\t unsigned long *bits)\n{\n\tunsigned long readmask = 0;\n\tunsigned long val;\n\tint bit;\n\n\t \n\t*bits &= ~*mask;\n\n\t \n\tfor_each_set_bit(bit, mask, gc->ngpio)\n\t\treadmask |= bgpio_line2mask(gc, bit);\n\n\t \n\tval = gc->read_reg(gc->reg_dat) & readmask;\n\n\t \n\tfor_each_set_bit(bit, &val, gc->ngpio)\n\t\t*bits |= bgpio_line2mask(gc, bit);\n\n\treturn 0;\n}\n\nstatic void bgpio_set_none(struct gpio_chip *gc, unsigned int gpio, int val)\n{\n}\n\nstatic void bgpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\n{\n\tunsigned long mask = bgpio_line2mask(gc, gpio);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\n\tif (val)\n\t\tgc->bgpio_data |= mask;\n\telse\n\t\tgc->bgpio_data &= ~mask;\n\n\tgc->write_reg(gc->reg_dat, gc->bgpio_data);\n\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n}\n\nstatic void bgpio_set_with_clear(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t\t int val)\n{\n\tunsigned long mask = bgpio_line2mask(gc, gpio);\n\n\tif (val)\n\t\tgc->write_reg(gc->reg_set, mask);\n\telse\n\t\tgc->write_reg(gc->reg_clr, mask);\n}\n\nstatic void bgpio_set_set(struct gpio_chip *gc, unsigned int gpio, int val)\n{\n\tunsigned long mask = bgpio_line2mask(gc, gpio);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\n\tif (val)\n\t\tgc->bgpio_data |= mask;\n\telse\n\t\tgc->bgpio_data &= ~mask;\n\n\tgc->write_reg(gc->reg_set, gc->bgpio_data);\n\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n}\n\nstatic void bgpio_multiple_get_masks(struct gpio_chip *gc,\n\t\t\t\t     unsigned long *mask, unsigned long *bits,\n\t\t\t\t     unsigned long *set_mask,\n\t\t\t\t     unsigned long *clear_mask)\n{\n\tint i;\n\n\t*set_mask = 0;\n\t*clear_mask = 0;\n\n\tfor_each_set_bit(i, mask, gc->bgpio_bits) {\n\t\tif (test_bit(i, bits))\n\t\t\t*set_mask |= bgpio_line2mask(gc, i);\n\t\telse\n\t\t\t*clear_mask |= bgpio_line2mask(gc, i);\n\t}\n}\n\nstatic void bgpio_set_multiple_single_reg(struct gpio_chip *gc,\n\t\t\t\t\t  unsigned long *mask,\n\t\t\t\t\t  unsigned long *bits,\n\t\t\t\t\t  void __iomem *reg)\n{\n\tunsigned long flags;\n\tunsigned long set_mask, clear_mask;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\n\tbgpio_multiple_get_masks(gc, mask, bits, &set_mask, &clear_mask);\n\n\tgc->bgpio_data |= set_mask;\n\tgc->bgpio_data &= ~clear_mask;\n\n\tgc->write_reg(reg, gc->bgpio_data);\n\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n}\n\nstatic void bgpio_set_multiple(struct gpio_chip *gc, unsigned long *mask,\n\t\t\t       unsigned long *bits)\n{\n\tbgpio_set_multiple_single_reg(gc, mask, bits, gc->reg_dat);\n}\n\nstatic void bgpio_set_multiple_set(struct gpio_chip *gc, unsigned long *mask,\n\t\t\t\t   unsigned long *bits)\n{\n\tbgpio_set_multiple_single_reg(gc, mask, bits, gc->reg_set);\n}\n\nstatic void bgpio_set_multiple_with_clear(struct gpio_chip *gc,\n\t\t\t\t\t  unsigned long *mask,\n\t\t\t\t\t  unsigned long *bits)\n{\n\tunsigned long set_mask, clear_mask;\n\n\tbgpio_multiple_get_masks(gc, mask, bits, &set_mask, &clear_mask);\n\n\tif (set_mask)\n\t\tgc->write_reg(gc->reg_set, set_mask);\n\tif (clear_mask)\n\t\tgc->write_reg(gc->reg_clr, clear_mask);\n}\n\nstatic int bgpio_simple_dir_in(struct gpio_chip *gc, unsigned int gpio)\n{\n\treturn 0;\n}\n\nstatic int bgpio_dir_out_err(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t\tint val)\n{\n\treturn -EINVAL;\n}\n\nstatic int bgpio_simple_dir_out(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t\tint val)\n{\n\tgc->set(gc, gpio, val);\n\n\treturn 0;\n}\n\nstatic int bgpio_dir_in(struct gpio_chip *gc, unsigned int gpio)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\n\tgc->bgpio_dir &= ~bgpio_line2mask(gc, gpio);\n\n\tif (gc->reg_dir_in)\n\t\tgc->write_reg(gc->reg_dir_in, ~gc->bgpio_dir);\n\tif (gc->reg_dir_out)\n\t\tgc->write_reg(gc->reg_dir_out, gc->bgpio_dir);\n\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n\n\treturn 0;\n}\n\nstatic int bgpio_get_dir(struct gpio_chip *gc, unsigned int gpio)\n{\n\t \n\tif (gc->bgpio_dir_unreadable) {\n\t\tif (gc->bgpio_dir & bgpio_line2mask(gc, gpio))\n\t\t\treturn GPIO_LINE_DIRECTION_OUT;\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\t}\n\n\tif (gc->reg_dir_out) {\n\t\tif (gc->read_reg(gc->reg_dir_out) & bgpio_line2mask(gc, gpio))\n\t\t\treturn GPIO_LINE_DIRECTION_OUT;\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\t}\n\n\tif (gc->reg_dir_in)\n\t\tif (!(gc->read_reg(gc->reg_dir_in) & bgpio_line2mask(gc, gpio)))\n\t\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic void bgpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\n\tgc->bgpio_dir |= bgpio_line2mask(gc, gpio);\n\n\tif (gc->reg_dir_in)\n\t\tgc->write_reg(gc->reg_dir_in, ~gc->bgpio_dir);\n\tif (gc->reg_dir_out)\n\t\tgc->write_reg(gc->reg_dir_out, gc->bgpio_dir);\n\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n}\n\nstatic int bgpio_dir_out_dir_first(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t\t   int val)\n{\n\tbgpio_dir_out(gc, gpio, val);\n\tgc->set(gc, gpio, val);\n\treturn 0;\n}\n\nstatic int bgpio_dir_out_val_first(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t\t   int val)\n{\n\tgc->set(gc, gpio, val);\n\tbgpio_dir_out(gc, gpio, val);\n\treturn 0;\n}\n\nstatic int bgpio_setup_accessors(struct device *dev,\n\t\t\t\t struct gpio_chip *gc,\n\t\t\t\t bool byte_be)\n{\n\n\tswitch (gc->bgpio_bits) {\n\tcase 8:\n\t\tgc->read_reg\t= bgpio_read8;\n\t\tgc->write_reg\t= bgpio_write8;\n\t\tbreak;\n\tcase 16:\n\t\tif (byte_be) {\n\t\t\tgc->read_reg\t= bgpio_read16be;\n\t\t\tgc->write_reg\t= bgpio_write16be;\n\t\t} else {\n\t\t\tgc->read_reg\t= bgpio_read16;\n\t\t\tgc->write_reg\t= bgpio_write16;\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tif (byte_be) {\n\t\t\tgc->read_reg\t= bgpio_read32be;\n\t\t\tgc->write_reg\t= bgpio_write32be;\n\t\t} else {\n\t\t\tgc->read_reg\t= bgpio_read32;\n\t\t\tgc->write_reg\t= bgpio_write32;\n\t\t}\n\t\tbreak;\n#if BITS_PER_LONG >= 64\n\tcase 64:\n\t\tif (byte_be) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"64 bit big endian byte order unsupported\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tgc->read_reg\t= bgpio_read64;\n\t\t\tgc->write_reg\t= bgpio_write64;\n\t\t}\n\t\tbreak;\n#endif  \n\tdefault:\n\t\tdev_err(dev, \"unsupported data width %u bits\\n\", gc->bgpio_bits);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bgpio_setup_io(struct gpio_chip *gc,\n\t\t\t  void __iomem *dat,\n\t\t\t  void __iomem *set,\n\t\t\t  void __iomem *clr,\n\t\t\t  unsigned long flags)\n{\n\n\tgc->reg_dat = dat;\n\tif (!gc->reg_dat)\n\t\treturn -EINVAL;\n\n\tif (set && clr) {\n\t\tgc->reg_set = set;\n\t\tgc->reg_clr = clr;\n\t\tgc->set = bgpio_set_with_clear;\n\t\tgc->set_multiple = bgpio_set_multiple_with_clear;\n\t} else if (set && !clr) {\n\t\tgc->reg_set = set;\n\t\tgc->set = bgpio_set_set;\n\t\tgc->set_multiple = bgpio_set_multiple_set;\n\t} else if (flags & BGPIOF_NO_OUTPUT) {\n\t\tgc->set = bgpio_set_none;\n\t\tgc->set_multiple = NULL;\n\t} else {\n\t\tgc->set = bgpio_set;\n\t\tgc->set_multiple = bgpio_set_multiple;\n\t}\n\n\tif (!(flags & BGPIOF_UNREADABLE_REG_SET) &&\n\t    (flags & BGPIOF_READ_OUTPUT_REG_SET)) {\n\t\tgc->get = bgpio_get_set;\n\t\tif (!gc->be_bits)\n\t\t\tgc->get_multiple = bgpio_get_set_multiple;\n\t\t \n\t} else {\n\t\tgc->get = bgpio_get;\n\t\tif (gc->be_bits)\n\t\t\tgc->get_multiple = bgpio_get_multiple_be;\n\t\telse\n\t\t\tgc->get_multiple = bgpio_get_multiple;\n\t}\n\n\treturn 0;\n}\n\nstatic int bgpio_setup_direction(struct gpio_chip *gc,\n\t\t\t\t void __iomem *dirout,\n\t\t\t\t void __iomem *dirin,\n\t\t\t\t unsigned long flags)\n{\n\tif (dirout || dirin) {\n\t\tgc->reg_dir_out = dirout;\n\t\tgc->reg_dir_in = dirin;\n\t\tif (flags & BGPIOF_NO_SET_ON_INPUT)\n\t\t\tgc->direction_output = bgpio_dir_out_dir_first;\n\t\telse\n\t\t\tgc->direction_output = bgpio_dir_out_val_first;\n\t\tgc->direction_input = bgpio_dir_in;\n\t\tgc->get_direction = bgpio_get_dir;\n\t} else {\n\t\tif (flags & BGPIOF_NO_OUTPUT)\n\t\t\tgc->direction_output = bgpio_dir_out_err;\n\t\telse\n\t\t\tgc->direction_output = bgpio_simple_dir_out;\n\t\tgc->direction_input = bgpio_simple_dir_in;\n\t}\n\n\treturn 0;\n}\n\nstatic int bgpio_request(struct gpio_chip *chip, unsigned gpio_pin)\n{\n\tif (gpio_pin < chip->ngpio)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\n \nint bgpio_init(struct gpio_chip *gc, struct device *dev,\n\t       unsigned long sz, void __iomem *dat, void __iomem *set,\n\t       void __iomem *clr, void __iomem *dirout, void __iomem *dirin,\n\t       unsigned long flags)\n{\n\tint ret;\n\n\tif (!is_power_of_2(sz))\n\t\treturn -EINVAL;\n\n\tgc->bgpio_bits = sz * 8;\n\tif (gc->bgpio_bits > BITS_PER_LONG)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_init(&gc->bgpio_lock);\n\tgc->parent = dev;\n\tgc->label = dev_name(dev);\n\tgc->base = -1;\n\tgc->request = bgpio_request;\n\tgc->be_bits = !!(flags & BGPIOF_BIG_ENDIAN);\n\n\tret = gpiochip_get_ngpios(gc, dev);\n\tif (ret)\n\t\tgc->ngpio = gc->bgpio_bits;\n\telse\n\t\tgc->bgpio_bits = roundup_pow_of_two(round_up(gc->ngpio, 8));\n\n\tret = bgpio_setup_io(gc, dat, set, clr, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bgpio_setup_accessors(dev, gc, flags & BGPIOF_BIG_ENDIAN_BYTE_ORDER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bgpio_setup_direction(gc, dirout, dirin, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tgc->bgpio_data = gc->read_reg(gc->reg_dat);\n\tif (gc->set == bgpio_set_set &&\n\t\t\t!(flags & BGPIOF_UNREADABLE_REG_SET))\n\t\tgc->bgpio_data = gc->read_reg(gc->reg_set);\n\n\tif (flags & BGPIOF_UNREADABLE_REG_DIR)\n\t\tgc->bgpio_dir_unreadable = true;\n\n\t \n\tif ((gc->reg_dir_out || gc->reg_dir_in) &&\n\t    !(flags & BGPIOF_UNREADABLE_REG_DIR)) {\n\t\tif (gc->reg_dir_out)\n\t\t\tgc->bgpio_dir = gc->read_reg(gc->reg_dir_out);\n\t\telse if (gc->reg_dir_in)\n\t\t\tgc->bgpio_dir = ~gc->read_reg(gc->reg_dir_in);\n\t\t \n\t\tif (gc->reg_dir_out && gc->reg_dir_in)\n\t\t\tgc->write_reg(gc->reg_dir_in, ~gc->bgpio_dir);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(bgpio_init);\n\n#if IS_ENABLED(CONFIG_GPIO_GENERIC_PLATFORM)\n\nstatic void __iomem *bgpio_map(struct platform_device *pdev,\n\t\t\t       const char *name,\n\t\t\t       resource_size_t sane_sz)\n{\n\tstruct resource *r;\n\tresource_size_t sz;\n\n\tr = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);\n\tif (!r)\n\t\treturn NULL;\n\n\tsz = resource_size(r);\n\tif (sz != sane_sz)\n\t\treturn IOMEM_ERR_PTR(-EINVAL);\n\n\treturn devm_ioremap_resource(&pdev->dev, r);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id bgpio_of_match[] = {\n\t{ .compatible = \"brcm,bcm6345-gpio\" },\n\t{ .compatible = \"wd,mbl-gpio\" },\n\t{ .compatible = \"ni,169445-nand-gpio\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, bgpio_of_match);\n\nstatic struct bgpio_pdata *bgpio_parse_dt(struct platform_device *pdev,\n\t\t\t\t\t  unsigned long *flags)\n{\n\tstruct bgpio_pdata *pdata;\n\n\tif (!of_match_device(bgpio_of_match, &pdev->dev))\n\t\treturn NULL;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(struct bgpio_pdata),\n\t\t\t     GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->base = -1;\n\n\tif (of_device_is_big_endian(pdev->dev.of_node))\n\t\t*flags |= BGPIOF_BIG_ENDIAN_BYTE_ORDER;\n\n\tif (of_property_read_bool(pdev->dev.of_node, \"no-output\"))\n\t\t*flags |= BGPIOF_NO_OUTPUT;\n\n\treturn pdata;\n}\n#else\nstatic struct bgpio_pdata *bgpio_parse_dt(struct platform_device *pdev,\n\t\t\t\t\t  unsigned long *flags)\n{\n\treturn NULL;\n}\n#endif  \n\nstatic int bgpio_pdev_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *r;\n\tvoid __iomem *dat;\n\tvoid __iomem *set;\n\tvoid __iomem *clr;\n\tvoid __iomem *dirout;\n\tvoid __iomem *dirin;\n\tunsigned long sz;\n\tunsigned long flags = 0;\n\tint err;\n\tstruct gpio_chip *gc;\n\tstruct bgpio_pdata *pdata;\n\n\tpdata = bgpio_parse_dt(pdev, &flags);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\n\tif (!pdata) {\n\t\tpdata = dev_get_platdata(dev);\n\t\tflags = pdev->id_entry->driver_data;\n\t}\n\n\tr = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dat\");\n\tif (!r)\n\t\treturn -EINVAL;\n\n\tsz = resource_size(r);\n\n\tdat = bgpio_map(pdev, \"dat\", sz);\n\tif (IS_ERR(dat))\n\t\treturn PTR_ERR(dat);\n\n\tset = bgpio_map(pdev, \"set\", sz);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tclr = bgpio_map(pdev, \"clr\", sz);\n\tif (IS_ERR(clr))\n\t\treturn PTR_ERR(clr);\n\n\tdirout = bgpio_map(pdev, \"dirout\", sz);\n\tif (IS_ERR(dirout))\n\t\treturn PTR_ERR(dirout);\n\n\tdirin = bgpio_map(pdev, \"dirin\", sz);\n\tif (IS_ERR(dirin))\n\t\treturn PTR_ERR(dirin);\n\n\tgc = devm_kzalloc(&pdev->dev, sizeof(*gc), GFP_KERNEL);\n\tif (!gc)\n\t\treturn -ENOMEM;\n\n\terr = bgpio_init(gc, dev, sz, dat, set, clr, dirout, dirin, flags);\n\tif (err)\n\t\treturn err;\n\n\tif (pdata) {\n\t\tif (pdata->label)\n\t\t\tgc->label = pdata->label;\n\t\tgc->base = pdata->base;\n\t\tif (pdata->ngpio > 0)\n\t\t\tgc->ngpio = pdata->ngpio;\n\t}\n\n\tplatform_set_drvdata(pdev, gc);\n\n\treturn devm_gpiochip_add_data(&pdev->dev, gc, NULL);\n}\n\nstatic const struct platform_device_id bgpio_id_table[] = {\n\t{\n\t\t.name\t\t= \"basic-mmio-gpio\",\n\t\t.driver_data\t= 0,\n\t}, {\n\t\t.name\t\t= \"basic-mmio-gpio-be\",\n\t\t.driver_data\t= BGPIOF_BIG_ENDIAN,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, bgpio_id_table);\n\nstatic struct platform_driver bgpio_driver = {\n\t.driver = {\n\t\t.name = \"basic-mmio-gpio\",\n\t\t.of_match_table = of_match_ptr(bgpio_of_match),\n\t},\n\t.id_table = bgpio_id_table,\n\t.probe = bgpio_pdev_probe,\n};\n\nmodule_platform_driver(bgpio_driver);\n\n#endif  \n\nMODULE_DESCRIPTION(\"Driver for basic memory-mapped GPIO controllers\");\nMODULE_AUTHOR(\"Anton Vorontsov <cbouatmailru@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}