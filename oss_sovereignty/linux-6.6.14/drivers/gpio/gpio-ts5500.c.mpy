{
  "module_name": "gpio-ts5500.c",
  "hash_id": "6a175bf536650b9203b29742c6b76c4d78250ece166c95769649cb7f1dfb6df1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-ts5500.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n \nenum ts5500_blocks { TS5500_DIO1, TS5500_DIO2, TS5500_LCD, TS5600_LCD };\n\nstruct ts5500_priv {\n\tconst struct ts5500_dio *pinout;\n\tstruct gpio_chip gpio_chip;\n\tspinlock_t lock;\n\tbool strap;\n\tu8 hwirq;\n};\n\n \nstatic bool hex7d_reserved;\n\n \nstruct ts5500_dio {\n\tconst u8 value_addr;\n\tconst u8 value_mask;\n\tconst u8 control_addr;\n\tconst u8 control_mask;\n\tconst bool no_input;\n\tconst bool no_output;\n\tconst u8 irq;\n};\n\n#define TS5500_DIO_IN_OUT(vaddr, vbit, caddr, cbit)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.value_addr = vaddr,\t\t\t\\\n\t\t.value_mask = BIT(vbit),\t\t\\\n\t\t.control_addr = caddr,\t\t\t\\\n\t\t.control_mask = BIT(cbit),\t\t\\\n\t}\n\n#define TS5500_DIO_IN(addr, bit)\t\t\\\n\t{\t\t\t\t\t\\\n\t\t.value_addr = addr,\t\t\\\n\t\t.value_mask = BIT(bit),\t\t\\\n\t\t.no_output = true,\t\t\\\n\t}\n\n#define TS5500_DIO_IN_IRQ(addr, bit, _irq)\t\\\n\t{\t\t\t\t\t\\\n\t\t.value_addr = addr,\t\t\\\n\t\t.value_mask = BIT(bit),\t\t\\\n\t\t.no_output = true,\t\t\\\n\t\t.irq = _irq,\t\t\t\\\n\t}\n\n#define TS5500_DIO_OUT(addr, bit)\t\t\\\n\t{\t\t\t\t\t\\\n\t\t.value_addr = addr,\t\t\\\n\t\t.value_mask = BIT(bit),\t\t\\\n\t\t.no_input = true,\t\t\\\n\t}\n\n \n#define TS5500_DIO_GROUP(vaddr, vbitfrom, caddr, cbit)\t\t\\\n\tTS5500_DIO_IN_OUT(vaddr, vbitfrom + 0, caddr, cbit),\t\\\n\tTS5500_DIO_IN_OUT(vaddr, vbitfrom + 1, caddr, cbit),\t\\\n\tTS5500_DIO_IN_OUT(vaddr, vbitfrom + 2, caddr, cbit),\t\\\n\tTS5500_DIO_IN_OUT(vaddr, vbitfrom + 3, caddr, cbit)\n\n \nstatic const struct ts5500_dio ts5500_dio1[] = {\n\tTS5500_DIO_GROUP(0x7b, 0, 0x7a, 0),\n\tTS5500_DIO_GROUP(0x7b, 4, 0x7a, 1),\n\tTS5500_DIO_GROUP(0x7c, 0, 0x7a, 5),\n\tTS5500_DIO_IN(0x7c, 4),\n\tTS5500_DIO_IN_IRQ(0x7c, 5, 7),\n};\n\n \nstatic const struct ts5500_dio ts5500_dio2[] = {\n\tTS5500_DIO_GROUP(0x7e, 0, 0x7d, 0),\n\tTS5500_DIO_GROUP(0x7e, 4, 0x7d, 1),\n\tTS5500_DIO_GROUP(0x7f, 0, 0x7d, 5),\n\tTS5500_DIO_IN_IRQ(0x7f, 4, 6),\n};\n\n \nstatic const struct ts5500_dio ts5500_lcd[] = {\n\tTS5500_DIO_GROUP(0x72, 0, 0x7d, 2),\n\tTS5500_DIO_GROUP(0x72, 4, 0x7d, 3),\n\tTS5500_DIO_OUT(0x73, 0),\n\tTS5500_DIO_IN(0x73, 6),\n\tTS5500_DIO_IN_IRQ(0x73, 7, 1),\n};\n\nstatic inline void ts5500_set_mask(u8 mask, u8 addr)\n{\n\tu8 val = inb(addr);\n\tval |= mask;\n\toutb(val, addr);\n}\n\nstatic inline void ts5500_clear_mask(u8 mask, u8 addr)\n{\n\tu8 val = inb(addr);\n\tval &= ~mask;\n\toutb(val, addr);\n}\n\nstatic int ts5500_gpio_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct ts5500_priv *priv = gpiochip_get_data(chip);\n\tconst struct ts5500_dio line = priv->pinout[offset];\n\tunsigned long flags;\n\n\tif (line.no_input)\n\t\treturn -ENXIO;\n\n\tif (line.no_output)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tts5500_clear_mask(line.control_mask, line.control_addr);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ts5500_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct ts5500_priv *priv = gpiochip_get_data(chip);\n\tconst struct ts5500_dio line = priv->pinout[offset];\n\n\treturn !!(inb(line.value_addr) & line.value_mask);\n}\n\nstatic int ts5500_gpio_output(struct gpio_chip *chip, unsigned offset, int val)\n{\n\tstruct ts5500_priv *priv = gpiochip_get_data(chip);\n\tconst struct ts5500_dio line = priv->pinout[offset];\n\tunsigned long flags;\n\n\tif (line.no_output)\n\t\treturn -ENXIO;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (!line.no_input)\n\t\tts5500_set_mask(line.control_mask, line.control_addr);\n\n\tif (val)\n\t\tts5500_set_mask(line.value_mask, line.value_addr);\n\telse\n\t\tts5500_clear_mask(line.value_mask, line.value_addr);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic void ts5500_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\n{\n\tstruct ts5500_priv *priv = gpiochip_get_data(chip);\n\tconst struct ts5500_dio line = priv->pinout[offset];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (val)\n\t\tts5500_set_mask(line.value_mask, line.value_addr);\n\telse\n\t\tts5500_clear_mask(line.value_mask, line.value_addr);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int ts5500_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct ts5500_priv *priv = gpiochip_get_data(chip);\n\tconst struct ts5500_dio *block = priv->pinout;\n\tconst struct ts5500_dio line = block[offset];\n\n\t \n\tif (line.irq)\n\t\treturn line.irq;\n\n\t \n\tif (priv->strap)\n\t\treturn priv->hwirq;\n\n\treturn -ENXIO;\n}\n\nstatic int ts5500_enable_irq(struct ts5500_priv *priv)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->hwirq == 7)\n\t\tts5500_set_mask(BIT(7), 0x7a);  \n\telse if (priv->hwirq == 6)\n\t\tts5500_set_mask(BIT(7), 0x7d);  \n\telse if (priv->hwirq == 1)\n\t\tts5500_set_mask(BIT(6), 0x7d);  \n\telse\n\t\tret = -EINVAL;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn ret;\n}\n\nstatic void ts5500_disable_irq(struct ts5500_priv *priv)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->hwirq == 7)\n\t\tts5500_clear_mask(BIT(7), 0x7a);  \n\telse if (priv->hwirq == 6)\n\t\tts5500_clear_mask(BIT(7), 0x7d);  \n\telse if (priv->hwirq == 1)\n\t\tts5500_clear_mask(BIT(6), 0x7d);  \n\telse\n\t\tdev_err(priv->gpio_chip.parent, \"invalid hwirq %d\\n\",\n\t\t\tpriv->hwirq);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int ts5500_dio_probe(struct platform_device *pdev)\n{\n\tenum ts5500_blocks block = platform_get_device_id(pdev)->driver_data;\n\tstruct device *dev = &pdev->dev;\n\tconst char *name = dev_name(dev);\n\tstruct ts5500_priv *priv;\n\tunsigned long flags;\n\tint ret;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct ts5500_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\tpriv->hwirq = ret;\n\tspin_lock_init(&priv->lock);\n\n\tpriv->gpio_chip.owner = THIS_MODULE;\n\tpriv->gpio_chip.label = name;\n\tpriv->gpio_chip.parent = dev;\n\tpriv->gpio_chip.direction_input = ts5500_gpio_input;\n\tpriv->gpio_chip.direction_output = ts5500_gpio_output;\n\tpriv->gpio_chip.get = ts5500_gpio_get;\n\tpriv->gpio_chip.set = ts5500_gpio_set;\n\tpriv->gpio_chip.to_irq = ts5500_gpio_to_irq;\n\tpriv->gpio_chip.base = -1;\n\n\tswitch (block) {\n\tcase TS5500_DIO1:\n\t\tpriv->pinout = ts5500_dio1;\n\t\tpriv->gpio_chip.ngpio = ARRAY_SIZE(ts5500_dio1);\n\n\t\tif (!devm_request_region(dev, 0x7a, 3, name)) {\n\t\t\tdev_err(dev, \"failed to request %s ports\\n\", name);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tbreak;\n\tcase TS5500_DIO2:\n\t\tpriv->pinout = ts5500_dio2;\n\t\tpriv->gpio_chip.ngpio = ARRAY_SIZE(ts5500_dio2);\n\n\t\tif (!devm_request_region(dev, 0x7e, 2, name)) {\n\t\t\tdev_err(dev, \"failed to request %s ports\\n\", name);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (hex7d_reserved)\n\t\t\tbreak;\n\n\t\tif (!devm_request_region(dev, 0x7d, 1, name)) {\n\t\t\tdev_err(dev, \"failed to request %s 7D\\n\", name);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\thex7d_reserved = true;\n\t\tbreak;\n\tcase TS5500_LCD:\n\tcase TS5600_LCD:\n\t\tpriv->pinout = ts5500_lcd;\n\t\tpriv->gpio_chip.ngpio = ARRAY_SIZE(ts5500_lcd);\n\n\t\tif (!devm_request_region(dev, 0x72, 2, name)) {\n\t\t\tdev_err(dev, \"failed to request %s ports\\n\", name);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (!hex7d_reserved) {\n\t\t\tif (!devm_request_region(dev, 0x7d, 1, name)) {\n\t\t\t\tdev_err(dev, \"failed to request %s 7D\\n\", name);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\n\t\t\thex7d_reserved = true;\n\t\t}\n\n\t\t \n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tts5500_clear_mask(BIT(4), 0x7d);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tbreak;\n\t}\n\n\tret = devm_gpiochip_add_data(dev, &priv->gpio_chip, priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register the gpio chip\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ts5500_enable_irq(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"invalid interrupt %d\\n\", priv->hwirq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ts5500_dio_remove(struct platform_device *pdev)\n{\n\tstruct ts5500_priv *priv = platform_get_drvdata(pdev);\n\n\tts5500_disable_irq(priv);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id ts5500_dio_ids[] = {\n\t{ \"ts5500-dio1\", TS5500_DIO1 },\n\t{ \"ts5500-dio2\", TS5500_DIO2 },\n\t{ \"ts5500-dio-lcd\", TS5500_LCD },\n\t{ \"ts5600-dio-lcd\", TS5600_LCD },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, ts5500_dio_ids);\n\nstatic struct platform_driver ts5500_dio_driver = {\n\t.driver = {\n\t\t.name = \"ts5500-dio\",\n\t},\n\t.probe = ts5500_dio_probe,\n\t.remove = ts5500_dio_remove,\n\t.id_table = ts5500_dio_ids,\n};\n\nmodule_platform_driver(ts5500_dio_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Savoir-faire Linux Inc. <kernel@savoirfairelinux.com>\");\nMODULE_DESCRIPTION(\"Technologic Systems TS-5500 Digital I/O driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}