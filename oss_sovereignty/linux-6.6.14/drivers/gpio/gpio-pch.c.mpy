{
  "module_name": "gpio-pch.c",
  "hash_id": "639633a5631a240e643e5ac1fff8415cc3ccfd2dc53f661821706553ec31a263",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-pch.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#define PCH_EDGE_FALLING\t0\n#define PCH_EDGE_RISING\t\t1\n#define PCH_LEVEL_L\t\t2\n#define PCH_LEVEL_H\t\t3\n#define PCH_EDGE_BOTH\t\t4\n#define PCH_IM_MASK\t\tGENMASK(2, 0)\n\n#define PCH_IRQ_BASE\t\t24\n\nstruct pch_regs {\n\tu32\tien;\n\tu32\tistatus;\n\tu32\tidisp;\n\tu32\ticlr;\n\tu32\timask;\n\tu32\timaskclr;\n\tu32\tpo;\n\tu32\tpi;\n\tu32\tpm;\n\tu32\tim0;\n\tu32\tim1;\n\tu32\treserved[3];\n\tu32\tgpio_use_sel;\n\tu32\treset;\n};\n\n#define PCI_DEVICE_ID_INTEL_EG20T_PCH\t\t0x8803\n#define PCI_DEVICE_ID_ROHM_ML7223m_IOH\t\t0x8014\n#define PCI_DEVICE_ID_ROHM_ML7223n_IOH\t\t0x8043\n#define PCI_DEVICE_ID_ROHM_EG20T_PCH\t\t0x8803\n\nenum pch_type_t {\n\tINTEL_EG20T_PCH,\n\tOKISEMI_ML7223m_IOH,  \n\tOKISEMI_ML7223n_IOH   \n};\n\n \nstatic int gpio_pins[] = {\n\t[INTEL_EG20T_PCH] = 12,\n\t[OKISEMI_ML7223m_IOH] = 8,\n\t[OKISEMI_ML7223n_IOH] = 8,\n};\n\n \nstruct pch_gpio_reg_data {\n\tu32 ien_reg;\n\tu32 imask_reg;\n\tu32 po_reg;\n\tu32 pm_reg;\n\tu32 im0_reg;\n\tu32 im1_reg;\n\tu32 gpio_use_sel_reg;\n};\n\n \nstruct pch_gpio {\n\tvoid __iomem *base;\n\tstruct pch_regs __iomem *reg;\n\tstruct device *dev;\n\tstruct gpio_chip gpio;\n\tstruct pch_gpio_reg_data pch_gpio_reg;\n\tint irq_base;\n\tenum pch_type_t ioh;\n\tspinlock_t spinlock;\n};\n\nstatic void pch_gpio_set(struct gpio_chip *gpio, unsigned int nr, int val)\n{\n\tu32 reg_val;\n\tstruct pch_gpio *chip =\tgpiochip_get_data(gpio);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\treg_val = ioread32(&chip->reg->po);\n\tif (val)\n\t\treg_val |= BIT(nr);\n\telse\n\t\treg_val &= ~BIT(nr);\n\n\tiowrite32(reg_val, &chip->reg->po);\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n}\n\nstatic int pch_gpio_get(struct gpio_chip *gpio, unsigned int nr)\n{\n\tstruct pch_gpio *chip =\tgpiochip_get_data(gpio);\n\n\treturn !!(ioread32(&chip->reg->pi) & BIT(nr));\n}\n\nstatic int pch_gpio_direction_output(struct gpio_chip *gpio, unsigned int nr,\n\t\t\t\t     int val)\n{\n\tstruct pch_gpio *chip =\tgpiochip_get_data(gpio);\n\tu32 pm;\n\tu32 reg_val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\n\treg_val = ioread32(&chip->reg->po);\n\tif (val)\n\t\treg_val |= BIT(nr);\n\telse\n\t\treg_val &= ~BIT(nr);\n\tiowrite32(reg_val, &chip->reg->po);\n\n\tpm = ioread32(&chip->reg->pm);\n\tpm &= BIT(gpio_pins[chip->ioh]) - 1;\n\tpm |= BIT(nr);\n\tiowrite32(pm, &chip->reg->pm);\n\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int pch_gpio_direction_input(struct gpio_chip *gpio, unsigned int nr)\n{\n\tstruct pch_gpio *chip =\tgpiochip_get_data(gpio);\n\tu32 pm;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\tpm = ioread32(&chip->reg->pm);\n\tpm &= BIT(gpio_pins[chip->ioh]) - 1;\n\tpm &= ~BIT(nr);\n\tiowrite32(pm, &chip->reg->pm);\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\treturn 0;\n}\n\n \nstatic void __maybe_unused pch_gpio_save_reg_conf(struct pch_gpio *chip)\n{\n\tchip->pch_gpio_reg.ien_reg = ioread32(&chip->reg->ien);\n\tchip->pch_gpio_reg.imask_reg = ioread32(&chip->reg->imask);\n\tchip->pch_gpio_reg.po_reg = ioread32(&chip->reg->po);\n\tchip->pch_gpio_reg.pm_reg = ioread32(&chip->reg->pm);\n\tchip->pch_gpio_reg.im0_reg = ioread32(&chip->reg->im0);\n\tif (chip->ioh == INTEL_EG20T_PCH)\n\t\tchip->pch_gpio_reg.im1_reg = ioread32(&chip->reg->im1);\n\tif (chip->ioh == OKISEMI_ML7223n_IOH)\n\t\tchip->pch_gpio_reg.gpio_use_sel_reg = ioread32(&chip->reg->gpio_use_sel);\n}\n\n \nstatic void __maybe_unused pch_gpio_restore_reg_conf(struct pch_gpio *chip)\n{\n\tiowrite32(chip->pch_gpio_reg.ien_reg, &chip->reg->ien);\n\tiowrite32(chip->pch_gpio_reg.imask_reg, &chip->reg->imask);\n\t \n\tiowrite32(chip->pch_gpio_reg.po_reg, &chip->reg->po);\n\t \n\tiowrite32(chip->pch_gpio_reg.pm_reg, &chip->reg->pm);\n\tiowrite32(chip->pch_gpio_reg.im0_reg, &chip->reg->im0);\n\tif (chip->ioh == INTEL_EG20T_PCH)\n\t\tiowrite32(chip->pch_gpio_reg.im1_reg, &chip->reg->im1);\n\tif (chip->ioh == OKISEMI_ML7223n_IOH)\n\t\tiowrite32(chip->pch_gpio_reg.gpio_use_sel_reg, &chip->reg->gpio_use_sel);\n}\n\nstatic int pch_gpio_to_irq(struct gpio_chip *gpio, unsigned int offset)\n{\n\tstruct pch_gpio *chip = gpiochip_get_data(gpio);\n\n\treturn chip->irq_base + offset;\n}\n\nstatic void pch_gpio_setup(struct pch_gpio *chip)\n{\n\tstruct gpio_chip *gpio = &chip->gpio;\n\n\tgpio->label = dev_name(chip->dev);\n\tgpio->parent = chip->dev;\n\tgpio->owner = THIS_MODULE;\n\tgpio->direction_input = pch_gpio_direction_input;\n\tgpio->get = pch_gpio_get;\n\tgpio->direction_output = pch_gpio_direction_output;\n\tgpio->set = pch_gpio_set;\n\tgpio->base = -1;\n\tgpio->ngpio = gpio_pins[chip->ioh];\n\tgpio->can_sleep = false;\n\tgpio->to_irq = pch_gpio_to_irq;\n}\n\nstatic int pch_irq_type(struct irq_data *d, unsigned int type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct pch_gpio *chip = gc->private;\n\tu32 im, im_pos, val;\n\tu32 __iomem *im_reg;\n\tunsigned long flags;\n\tint ch, irq = d->irq;\n\n\tch = irq - chip->irq_base;\n\tif (irq < chip->irq_base + 8) {\n\t\tim_reg = &chip->reg->im0;\n\t\tim_pos = ch - 0;\n\t} else {\n\t\tim_reg = &chip->reg->im1;\n\t\tim_pos = ch - 8;\n\t}\n\tdev_dbg(chip->dev, \"irq=%d type=%d ch=%d pos=%d\\n\", irq, type, ch, im_pos);\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tval = PCH_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tval = PCH_EDGE_FALLING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tval = PCH_EDGE_BOTH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tval = PCH_LEVEL_H;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tval = PCH_LEVEL_L;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\n\t \n\tim = ioread32(im_reg) & ~(PCH_IM_MASK << (im_pos * 4));\n\tiowrite32(im | (val << (im_pos * 4)), im_reg);\n\n\t \n\tif (type & IRQ_TYPE_LEVEL_MASK)\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\telse if (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\treturn 0;\n}\n\nstatic void pch_irq_unmask(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct pch_gpio *chip = gc->private;\n\n\tiowrite32(BIT(d->irq - chip->irq_base), &chip->reg->imaskclr);\n}\n\nstatic void pch_irq_mask(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct pch_gpio *chip = gc->private;\n\n\tiowrite32(BIT(d->irq - chip->irq_base), &chip->reg->imask);\n}\n\nstatic void pch_irq_ack(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct pch_gpio *chip = gc->private;\n\n\tiowrite32(BIT(d->irq - chip->irq_base), &chip->reg->iclr);\n}\n\nstatic irqreturn_t pch_gpio_handler(int irq, void *dev_id)\n{\n\tstruct pch_gpio *chip = dev_id;\n\tunsigned long reg_val = ioread32(&chip->reg->istatus);\n\tint i;\n\n\tdev_vdbg(chip->dev, \"irq=%d  status=0x%lx\\n\", irq, reg_val);\n\n\treg_val &= BIT(gpio_pins[chip->ioh]) - 1;\n\n\tfor_each_set_bit(i, &reg_val, gpio_pins[chip->ioh])\n\t\tgeneric_handle_irq(chip->irq_base + i);\n\n\treturn IRQ_RETVAL(reg_val);\n}\n\nstatic int pch_gpio_alloc_generic_chip(struct pch_gpio *chip,\n\t\t\t\t       unsigned int irq_start,\n\t\t\t\t       unsigned int num)\n{\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\tint rv;\n\n\tgc = devm_irq_alloc_generic_chip(chip->dev, \"pch_gpio\", 1, irq_start,\n\t\t\t\t\t chip->base, handle_simple_irq);\n\tif (!gc)\n\t\treturn -ENOMEM;\n\n\tgc->private = chip;\n\tct = gc->chip_types;\n\n\tct->chip.irq_ack = pch_irq_ack;\n\tct->chip.irq_mask = pch_irq_mask;\n\tct->chip.irq_unmask = pch_irq_unmask;\n\tct->chip.irq_set_type = pch_irq_type;\n\n\trv = devm_irq_setup_generic_chip(chip->dev, gc, IRQ_MSK(num),\n\t\t\t\t\t IRQ_GC_INIT_MASK_CACHE,\n\t\t\t\t\t IRQ_NOREQUEST | IRQ_NOPROBE, 0);\n\n\treturn rv;\n}\n\nstatic int pch_gpio_probe(struct pci_dev *pdev,\n\t\t\t\t    const struct pci_device_id *id)\n{\n\tstruct device *dev = &pdev->dev;\n\ts32 ret;\n\tstruct pch_gpio *chip;\n\tint irq_base;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\n\tchip->dev = dev;\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to enable PCI device\\n\");\n\n\tret = pcim_iomap_regions(pdev, BIT(1), KBUILD_MODNAME);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to request and map PCI regions\\n\");\n\n\tchip->base = pcim_iomap_table(pdev)[1];\n\tchip->ioh = id->driver_data;\n\tchip->reg = chip->base;\n\tpci_set_drvdata(pdev, chip);\n\tspin_lock_init(&chip->spinlock);\n\tpch_gpio_setup(chip);\n\n\tret = devm_gpiochip_add_data(dev, &chip->gpio, chip);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to register GPIO\\n\");\n\n\tirq_base = devm_irq_alloc_descs(dev, -1, 0,\n\t\t\t\t\tgpio_pins[chip->ioh], NUMA_NO_NODE);\n\tif (irq_base < 0) {\n\t\tdev_warn(dev, \"PCH gpio: Failed to get IRQ base num\\n\");\n\t\tchip->irq_base = -1;\n\t\treturn 0;\n\t}\n\tchip->irq_base = irq_base;\n\n\t \n\tiowrite32(BIT(gpio_pins[chip->ioh]) - 1, &chip->reg->imask);\n\tiowrite32(BIT(gpio_pins[chip->ioh]) - 1, &chip->reg->ien);\n\n\tret = devm_request_irq(dev, pdev->irq, pch_gpio_handler,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, chip);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to request IRQ\\n\");\n\n\treturn pch_gpio_alloc_generic_chip(chip, irq_base, gpio_pins[chip->ioh]);\n}\n\nstatic int __maybe_unused pch_gpio_suspend(struct device *dev)\n{\n\tstruct pch_gpio *chip = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\tpch_gpio_save_reg_conf(chip);\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused pch_gpio_resume(struct device *dev)\n{\n\tstruct pch_gpio *chip = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\tiowrite32(0x01, &chip->reg->reset);\n\tiowrite32(0x00, &chip->reg->reset);\n\tpch_gpio_restore_reg_conf(chip);\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(pch_gpio_pm_ops, pch_gpio_suspend, pch_gpio_resume);\n\nstatic const struct pci_device_id pch_gpio_pcidev_id[] = {\n\t{ PCI_DEVICE_DATA(INTEL, EG20T_PCH, INTEL_EG20T_PCH) },\n\t{ PCI_DEVICE_DATA(ROHM, ML7223m_IOH, OKISEMI_ML7223m_IOH) },\n\t{ PCI_DEVICE_DATA(ROHM, ML7223n_IOH, OKISEMI_ML7223n_IOH) },\n\t{ PCI_DEVICE_DATA(ROHM, EG20T_PCH, INTEL_EG20T_PCH) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, pch_gpio_pcidev_id);\n\nstatic struct pci_driver pch_gpio_driver = {\n\t.name = \"pch_gpio\",\n\t.id_table = pch_gpio_pcidev_id,\n\t.probe = pch_gpio_probe,\n\t.driver = {\n\t\t.pm = &pch_gpio_pm_ops,\n\t},\n};\n\nmodule_pci_driver(pch_gpio_driver);\n\nMODULE_DESCRIPTION(\"PCH GPIO PCI Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}