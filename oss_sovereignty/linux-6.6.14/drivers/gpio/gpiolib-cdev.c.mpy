{
  "module_name": "gpiolib-cdev.c",
  "hash_id": "b2159b28049dc79371a5855e6d4c6739fa0aa1c75afd193275af139076341ac9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpiolib-cdev.c",
  "human_readable_source": "\n\n#include <linux/anon_inodes.h>\n#include <linux/atomic.h>\n#include <linux/bitmap.h>\n#include <linux/build_bug.h>\n#include <linux/cdev.h>\n#include <linux/compat.h>\n#include <linux/compiler.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/file.h>\n#include <linux/gpio.h>\n#include <linux/gpio/driver.h>\n#include <linux/hte.h>\n#include <linux/interrupt.h>\n#include <linux/irqreturn.h>\n#include <linux/kernel.h>\n#include <linux/kfifo.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n#include <linux/timekeeping.h>\n#include <linux/uaccess.h>\n#include <linux/workqueue.h>\n\n#include <uapi/linux/gpio.h>\n\n#include \"gpiolib.h\"\n#include \"gpiolib-cdev.h\"\n\n \nstatic_assert(IS_ALIGNED(GPIO_V2_LINES_MAX, 2));\nstatic_assert(IS_ALIGNED(GPIO_MAX_NAME_SIZE, 8));\n\n \nstatic_assert(IS_ALIGNED(sizeof(struct gpio_v2_line_attribute), 8));\nstatic_assert(IS_ALIGNED(sizeof(struct gpio_v2_line_config_attribute), 8));\nstatic_assert(IS_ALIGNED(sizeof(struct gpio_v2_line_config), 8));\nstatic_assert(IS_ALIGNED(sizeof(struct gpio_v2_line_request), 8));\nstatic_assert(IS_ALIGNED(sizeof(struct gpio_v2_line_info), 8));\nstatic_assert(IS_ALIGNED(sizeof(struct gpio_v2_line_info_changed), 8));\nstatic_assert(IS_ALIGNED(sizeof(struct gpio_v2_line_event), 8));\nstatic_assert(IS_ALIGNED(sizeof(struct gpio_v2_line_values), 8));\n\n \n\ntypedef __poll_t (*poll_fn)(struct file *, struct poll_table_struct *);\ntypedef long (*ioctl_fn)(struct file *, unsigned int, unsigned long);\ntypedef ssize_t (*read_fn)(struct file *, char __user *,\n\t\t\t   size_t count, loff_t *);\n\nstatic __poll_t call_poll_locked(struct file *file,\n\t\t\t\t struct poll_table_struct *wait,\n\t\t\t\t struct gpio_device *gdev, poll_fn func)\n{\n\t__poll_t ret;\n\n\tdown_read(&gdev->sem);\n\tret = func(file, wait);\n\tup_read(&gdev->sem);\n\n\treturn ret;\n}\n\nstatic long call_ioctl_locked(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg, struct gpio_device *gdev,\n\t\t\t      ioctl_fn func)\n{\n\tlong ret;\n\n\tdown_read(&gdev->sem);\n\tret = func(file, cmd, arg);\n\tup_read(&gdev->sem);\n\n\treturn ret;\n}\n\nstatic ssize_t call_read_locked(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *f_ps,\n\t\t\t\tstruct gpio_device *gdev, read_fn func)\n{\n\tssize_t ret;\n\n\tdown_read(&gdev->sem);\n\tret = func(file, buf, count, f_ps);\n\tup_read(&gdev->sem);\n\n\treturn ret;\n}\n\n \n\n#ifdef CONFIG_GPIO_CDEV_V1\n \nstruct linehandle_state {\n\tstruct gpio_device *gdev;\n\tconst char *label;\n\tstruct gpio_desc *descs[GPIOHANDLES_MAX];\n\tu32 num_descs;\n};\n\n#define GPIOHANDLE_REQUEST_VALID_FLAGS \\\n\t(GPIOHANDLE_REQUEST_INPUT | \\\n\tGPIOHANDLE_REQUEST_OUTPUT | \\\n\tGPIOHANDLE_REQUEST_ACTIVE_LOW | \\\n\tGPIOHANDLE_REQUEST_BIAS_PULL_UP | \\\n\tGPIOHANDLE_REQUEST_BIAS_PULL_DOWN | \\\n\tGPIOHANDLE_REQUEST_BIAS_DISABLE | \\\n\tGPIOHANDLE_REQUEST_OPEN_DRAIN | \\\n\tGPIOHANDLE_REQUEST_OPEN_SOURCE)\n\nstatic int linehandle_validate_flags(u32 flags)\n{\n\t \n\tif (flags & ~GPIOHANDLE_REQUEST_VALID_FLAGS)\n\t\treturn -EINVAL;\n\n\t \n\tif ((flags & GPIOHANDLE_REQUEST_INPUT) &&\n\t    (flags & GPIOHANDLE_REQUEST_OUTPUT))\n\t\treturn -EINVAL;\n\n\t \n\tif ((flags & GPIOHANDLE_REQUEST_OPEN_DRAIN) &&\n\t    (flags & GPIOHANDLE_REQUEST_OPEN_SOURCE))\n\t\treturn -EINVAL;\n\n\t \n\tif (!(flags & GPIOHANDLE_REQUEST_OUTPUT) &&\n\t    ((flags & GPIOHANDLE_REQUEST_OPEN_DRAIN) ||\n\t     (flags & GPIOHANDLE_REQUEST_OPEN_SOURCE)))\n\t\treturn -EINVAL;\n\n\t \n\tif (!((flags & GPIOHANDLE_REQUEST_INPUT) ||\n\t      (flags & GPIOHANDLE_REQUEST_OUTPUT)) &&\n\t    ((flags & GPIOHANDLE_REQUEST_BIAS_DISABLE) ||\n\t     (flags & GPIOHANDLE_REQUEST_BIAS_PULL_UP) ||\n\t     (flags & GPIOHANDLE_REQUEST_BIAS_PULL_DOWN)))\n\t\treturn -EINVAL;\n\n\t \n\tif (((flags & GPIOHANDLE_REQUEST_BIAS_DISABLE) &&\n\t     (flags & (GPIOHANDLE_REQUEST_BIAS_PULL_DOWN |\n\t\t       GPIOHANDLE_REQUEST_BIAS_PULL_UP))) ||\n\t    ((flags & GPIOHANDLE_REQUEST_BIAS_PULL_DOWN) &&\n\t     (flags & GPIOHANDLE_REQUEST_BIAS_PULL_UP)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void linehandle_flags_to_desc_flags(u32 lflags, unsigned long *flagsp)\n{\n\tassign_bit(FLAG_ACTIVE_LOW, flagsp,\n\t\t   lflags & GPIOHANDLE_REQUEST_ACTIVE_LOW);\n\tassign_bit(FLAG_OPEN_DRAIN, flagsp,\n\t\t   lflags & GPIOHANDLE_REQUEST_OPEN_DRAIN);\n\tassign_bit(FLAG_OPEN_SOURCE, flagsp,\n\t\t   lflags & GPIOHANDLE_REQUEST_OPEN_SOURCE);\n\tassign_bit(FLAG_PULL_UP, flagsp,\n\t\t   lflags & GPIOHANDLE_REQUEST_BIAS_PULL_UP);\n\tassign_bit(FLAG_PULL_DOWN, flagsp,\n\t\t   lflags & GPIOHANDLE_REQUEST_BIAS_PULL_DOWN);\n\tassign_bit(FLAG_BIAS_DISABLE, flagsp,\n\t\t   lflags & GPIOHANDLE_REQUEST_BIAS_DISABLE);\n}\n\nstatic long linehandle_set_config(struct linehandle_state *lh,\n\t\t\t\t  void __user *ip)\n{\n\tstruct gpiohandle_config gcnf;\n\tstruct gpio_desc *desc;\n\tint i, ret;\n\tu32 lflags;\n\n\tif (copy_from_user(&gcnf, ip, sizeof(gcnf)))\n\t\treturn -EFAULT;\n\n\tlflags = gcnf.flags;\n\tret = linehandle_validate_flags(lflags);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < lh->num_descs; i++) {\n\t\tdesc = lh->descs[i];\n\t\tlinehandle_flags_to_desc_flags(gcnf.flags, &desc->flags);\n\n\t\t \n\t\tif (lflags & GPIOHANDLE_REQUEST_OUTPUT) {\n\t\t\tint val = !!gcnf.default_values[i];\n\n\t\t\tret = gpiod_direction_output(desc, val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else if (lflags & GPIOHANDLE_REQUEST_INPUT) {\n\t\t\tret = gpiod_direction_input(desc);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tgpiod_line_state_notify(desc, GPIO_V2_LINE_CHANGED_CONFIG);\n\t}\n\treturn 0;\n}\n\nstatic long linehandle_ioctl_unlocked(struct file *file, unsigned int cmd,\n\t\t\t\t      unsigned long arg)\n{\n\tstruct linehandle_state *lh = file->private_data;\n\tvoid __user *ip = (void __user *)arg;\n\tstruct gpiohandle_data ghd;\n\tDECLARE_BITMAP(vals, GPIOHANDLES_MAX);\n\tunsigned int i;\n\tint ret;\n\n\tif (!lh->gdev->chip)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase GPIOHANDLE_GET_LINE_VALUES_IOCTL:\n\t\t \n\t\tret = gpiod_get_array_value_complex(false, true,\n\t\t\t\t\t\t    lh->num_descs, lh->descs,\n\t\t\t\t\t\t    NULL, vals);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmemset(&ghd, 0, sizeof(ghd));\n\t\tfor (i = 0; i < lh->num_descs; i++)\n\t\t\tghd.values[i] = test_bit(i, vals);\n\n\t\tif (copy_to_user(ip, &ghd, sizeof(ghd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\tcase GPIOHANDLE_SET_LINE_VALUES_IOCTL:\n\t\t \n\t\tif (!test_bit(FLAG_IS_OUT, &lh->descs[0]->flags))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&ghd, ip, sizeof(ghd)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tfor (i = 0; i < lh->num_descs; i++)\n\t\t\t__assign_bit(i, vals, ghd.values[i]);\n\n\t\t \n\t\treturn gpiod_set_array_value_complex(false,\n\t\t\t\t\t\t     true,\n\t\t\t\t\t\t     lh->num_descs,\n\t\t\t\t\t\t     lh->descs,\n\t\t\t\t\t\t     NULL,\n\t\t\t\t\t\t     vals);\n\tcase GPIOHANDLE_SET_CONFIG_IOCTL:\n\t\treturn linehandle_set_config(lh, ip);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic long linehandle_ioctl(struct file *file, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tstruct linehandle_state *lh = file->private_data;\n\n\treturn call_ioctl_locked(file, cmd, arg, lh->gdev,\n\t\t\t\t linehandle_ioctl_unlocked);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long linehandle_ioctl_compat(struct file *file, unsigned int cmd,\n\t\t\t\t    unsigned long arg)\n{\n\treturn linehandle_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic void linehandle_free(struct linehandle_state *lh)\n{\n\tint i;\n\n\tfor (i = 0; i < lh->num_descs; i++)\n\t\tif (lh->descs[i])\n\t\t\tgpiod_free(lh->descs[i]);\n\tkfree(lh->label);\n\tgpio_device_put(lh->gdev);\n\tkfree(lh);\n}\n\nstatic int linehandle_release(struct inode *inode, struct file *file)\n{\n\tlinehandle_free(file->private_data);\n\treturn 0;\n}\n\nstatic const struct file_operations linehandle_fileops = {\n\t.release = linehandle_release,\n\t.owner = THIS_MODULE,\n\t.llseek = noop_llseek,\n\t.unlocked_ioctl = linehandle_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = linehandle_ioctl_compat,\n#endif\n};\n\nstatic int linehandle_create(struct gpio_device *gdev, void __user *ip)\n{\n\tstruct gpiohandle_request handlereq;\n\tstruct linehandle_state *lh;\n\tstruct file *file;\n\tint fd, i, ret;\n\tu32 lflags;\n\n\tif (copy_from_user(&handlereq, ip, sizeof(handlereq)))\n\t\treturn -EFAULT;\n\tif ((handlereq.lines == 0) || (handlereq.lines > GPIOHANDLES_MAX))\n\t\treturn -EINVAL;\n\n\tlflags = handlereq.flags;\n\n\tret = linehandle_validate_flags(lflags);\n\tif (ret)\n\t\treturn ret;\n\n\tlh = kzalloc(sizeof(*lh), GFP_KERNEL);\n\tif (!lh)\n\t\treturn -ENOMEM;\n\tlh->gdev = gpio_device_get(gdev);\n\n\tif (handlereq.consumer_label[0] != '\\0') {\n\t\t \n\t\tlh->label = kstrndup(handlereq.consumer_label,\n\t\t\t\t     sizeof(handlereq.consumer_label) - 1,\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!lh->label) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free_lh;\n\t\t}\n\t}\n\n\tlh->num_descs = handlereq.lines;\n\n\t \n\tfor (i = 0; i < handlereq.lines; i++) {\n\t\tu32 offset = handlereq.lineoffsets[i];\n\t\tstruct gpio_desc *desc = gpiochip_get_desc(gdev->chip, offset);\n\n\t\tif (IS_ERR(desc)) {\n\t\t\tret = PTR_ERR(desc);\n\t\t\tgoto out_free_lh;\n\t\t}\n\n\t\tret = gpiod_request_user(desc, lh->label);\n\t\tif (ret)\n\t\t\tgoto out_free_lh;\n\t\tlh->descs[i] = desc;\n\t\tlinehandle_flags_to_desc_flags(handlereq.flags, &desc->flags);\n\n\t\tret = gpiod_set_transitory(desc, false);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_lh;\n\n\t\t \n\t\tif (lflags & GPIOHANDLE_REQUEST_OUTPUT) {\n\t\t\tint val = !!handlereq.default_values[i];\n\n\t\t\tret = gpiod_direction_output(desc, val);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_lh;\n\t\t} else if (lflags & GPIOHANDLE_REQUEST_INPUT) {\n\t\t\tret = gpiod_direction_input(desc);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_lh;\n\t\t}\n\n\t\tgpiod_line_state_notify(desc, GPIO_V2_LINE_CHANGED_REQUESTED);\n\n\t\tdev_dbg(&gdev->dev, \"registered chardev handle for line %d\\n\",\n\t\t\toffset);\n\t}\n\n\tfd = get_unused_fd_flags(O_RDONLY | O_CLOEXEC);\n\tif (fd < 0) {\n\t\tret = fd;\n\t\tgoto out_free_lh;\n\t}\n\n\tfile = anon_inode_getfile(\"gpio-linehandle\",\n\t\t\t\t  &linehandle_fileops,\n\t\t\t\t  lh,\n\t\t\t\t  O_RDONLY | O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tret = PTR_ERR(file);\n\t\tgoto out_put_unused_fd;\n\t}\n\n\thandlereq.fd = fd;\n\tif (copy_to_user(ip, &handlereq, sizeof(handlereq))) {\n\t\t \n\t\tfput(file);\n\t\tput_unused_fd(fd);\n\t\treturn -EFAULT;\n\t}\n\n\tfd_install(fd, file);\n\n\tdev_dbg(&gdev->dev, \"registered chardev handle for %d lines\\n\",\n\t\tlh->num_descs);\n\n\treturn 0;\n\nout_put_unused_fd:\n\tput_unused_fd(fd);\nout_free_lh:\n\tlinehandle_free(lh);\n\treturn ret;\n}\n#endif  \n\n \nstruct line {\n\tstruct gpio_desc *desc;\n\t \n\tstruct linereq *req;\n\tunsigned int irq;\n\t \n\tu64 edflags;\n\t \n\tu64 timestamp_ns;\n\tu32 req_seqno;\n\t \n\tu32 line_seqno;\n\t \n\tstruct delayed_work work;\n\t \n\tunsigned int sw_debounced;\n\t \n\tunsigned int level;\n#ifdef CONFIG_HTE\n\tstruct hte_ts_desc hdesc;\n\t \n\tint raw_level;\n\t \n\tu32 total_discard_seq;\n\t \n\tu32 last_seqno;\n#endif  \n};\n\n \nstruct linereq {\n\tstruct gpio_device *gdev;\n\tconst char *label;\n\tu32 num_lines;\n\twait_queue_head_t wait;\n\tstruct notifier_block device_unregistered_nb;\n\tu32 event_buffer_size;\n\tDECLARE_KFIFO_PTR(events, struct gpio_v2_line_event);\n\tatomic_t seqno;\n\tstruct mutex config_mutex;\n\tstruct line lines[];\n};\n\n#define GPIO_V2_LINE_BIAS_FLAGS \\\n\t(GPIO_V2_LINE_FLAG_BIAS_PULL_UP | \\\n\t GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN | \\\n\t GPIO_V2_LINE_FLAG_BIAS_DISABLED)\n\n#define GPIO_V2_LINE_DIRECTION_FLAGS \\\n\t(GPIO_V2_LINE_FLAG_INPUT | \\\n\t GPIO_V2_LINE_FLAG_OUTPUT)\n\n#define GPIO_V2_LINE_DRIVE_FLAGS \\\n\t(GPIO_V2_LINE_FLAG_OPEN_DRAIN | \\\n\t GPIO_V2_LINE_FLAG_OPEN_SOURCE)\n\n#define GPIO_V2_LINE_EDGE_FLAGS \\\n\t(GPIO_V2_LINE_FLAG_EDGE_RISING | \\\n\t GPIO_V2_LINE_FLAG_EDGE_FALLING)\n\n#define GPIO_V2_LINE_FLAG_EDGE_BOTH GPIO_V2_LINE_EDGE_FLAGS\n\n#define GPIO_V2_LINE_VALID_FLAGS \\\n\t(GPIO_V2_LINE_FLAG_ACTIVE_LOW | \\\n\t GPIO_V2_LINE_DIRECTION_FLAGS | \\\n\t GPIO_V2_LINE_DRIVE_FLAGS | \\\n\t GPIO_V2_LINE_EDGE_FLAGS | \\\n\t GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME | \\\n\t GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE | \\\n\t GPIO_V2_LINE_BIAS_FLAGS)\n\n \n#define GPIO_V2_LINE_EDGE_DETECTOR_FLAGS \\\n\t(GPIO_V2_LINE_FLAG_ACTIVE_LOW | \\\n\t GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE | \\\n\t GPIO_V2_LINE_EDGE_FLAGS)\n\nstatic int linereq_unregistered_notify(struct notifier_block *nb,\n\t\t\t\t       unsigned long action, void *data)\n{\n\tstruct linereq *lr = container_of(nb, struct linereq,\n\t\t\t\t\t  device_unregistered_nb);\n\n\twake_up_poll(&lr->wait, EPOLLIN | EPOLLERR);\n\n\treturn NOTIFY_OK;\n}\n\nstatic void linereq_put_event(struct linereq *lr,\n\t\t\t      struct gpio_v2_line_event *le)\n{\n\tbool overflow = false;\n\n\tspin_lock(&lr->wait.lock);\n\tif (kfifo_is_full(&lr->events)) {\n\t\toverflow = true;\n\t\tkfifo_skip(&lr->events);\n\t}\n\tkfifo_in(&lr->events, le, 1);\n\tspin_unlock(&lr->wait.lock);\n\tif (!overflow)\n\t\twake_up_poll(&lr->wait, EPOLLIN);\n\telse\n\t\tpr_debug_ratelimited(\"event FIFO is full - event dropped\\n\");\n}\n\nstatic u64 line_event_timestamp(struct line *line)\n{\n\tif (test_bit(FLAG_EVENT_CLOCK_REALTIME, &line->desc->flags))\n\t\treturn ktime_get_real_ns();\n\telse if (IS_ENABLED(CONFIG_HTE) &&\n\t\t test_bit(FLAG_EVENT_CLOCK_HTE, &line->desc->flags))\n\t\treturn line->timestamp_ns;\n\n\treturn ktime_get_ns();\n}\n\nstatic u32 line_event_id(int level)\n{\n\treturn level ? GPIO_V2_LINE_EVENT_RISING_EDGE :\n\t\t       GPIO_V2_LINE_EVENT_FALLING_EDGE;\n}\n\n#ifdef CONFIG_HTE\n\nstatic enum hte_return process_hw_ts_thread(void *p)\n{\n\tstruct line *line;\n\tstruct linereq *lr;\n\tstruct gpio_v2_line_event le;\n\tu64 edflags;\n\tint level;\n\n\tif (!p)\n\t\treturn HTE_CB_HANDLED;\n\n\tline = p;\n\tlr = line->req;\n\n\tmemset(&le, 0, sizeof(le));\n\n\tle.timestamp_ns = line->timestamp_ns;\n\tedflags = READ_ONCE(line->edflags);\n\n\tswitch (edflags & GPIO_V2_LINE_EDGE_FLAGS) {\n\tcase GPIO_V2_LINE_FLAG_EDGE_BOTH:\n\t\tlevel = (line->raw_level >= 0) ?\n\t\t\t\tline->raw_level :\n\t\t\t\tgpiod_get_raw_value_cansleep(line->desc);\n\n\t\tif (edflags & GPIO_V2_LINE_FLAG_ACTIVE_LOW)\n\t\t\tlevel = !level;\n\n\t\tle.id = line_event_id(level);\n\t\tbreak;\n\tcase GPIO_V2_LINE_FLAG_EDGE_RISING:\n\t\tle.id = GPIO_V2_LINE_EVENT_RISING_EDGE;\n\t\tbreak;\n\tcase GPIO_V2_LINE_FLAG_EDGE_FALLING:\n\t\tle.id = GPIO_V2_LINE_EVENT_FALLING_EDGE;\n\t\tbreak;\n\tdefault:\n\t\treturn HTE_CB_HANDLED;\n\t}\n\tle.line_seqno = line->line_seqno;\n\tle.seqno = (lr->num_lines == 1) ? le.line_seqno : line->req_seqno;\n\tle.offset = gpio_chip_hwgpio(line->desc);\n\n\tlinereq_put_event(lr, &le);\n\n\treturn HTE_CB_HANDLED;\n}\n\nstatic enum hte_return process_hw_ts(struct hte_ts_data *ts, void *p)\n{\n\tstruct line *line;\n\tstruct linereq *lr;\n\tint diff_seqno = 0;\n\n\tif (!ts || !p)\n\t\treturn HTE_CB_HANDLED;\n\n\tline = p;\n\tline->timestamp_ns = ts->tsc;\n\tline->raw_level = ts->raw_level;\n\tlr = line->req;\n\n\tif (READ_ONCE(line->sw_debounced)) {\n\t\tline->total_discard_seq++;\n\t\tline->last_seqno = ts->seq;\n\t\tmod_delayed_work(system_wq, &line->work,\n\t\t  usecs_to_jiffies(READ_ONCE(line->desc->debounce_period_us)));\n\t} else {\n\t\tif (unlikely(ts->seq < line->line_seqno))\n\t\t\treturn HTE_CB_HANDLED;\n\n\t\tdiff_seqno = ts->seq - line->line_seqno;\n\t\tline->line_seqno = ts->seq;\n\t\tif (lr->num_lines != 1)\n\t\t\tline->req_seqno = atomic_add_return(diff_seqno,\n\t\t\t\t\t\t\t    &lr->seqno);\n\n\t\treturn HTE_RUN_SECOND_CB;\n\t}\n\n\treturn HTE_CB_HANDLED;\n}\n\nstatic int hte_edge_setup(struct line *line, u64 eflags)\n{\n\tint ret;\n\tunsigned long flags = 0;\n\tstruct hte_ts_desc *hdesc = &line->hdesc;\n\n\tif (eflags & GPIO_V2_LINE_FLAG_EDGE_RISING)\n\t\tflags |= test_bit(FLAG_ACTIVE_LOW, &line->desc->flags) ?\n\t\t\t\t HTE_FALLING_EDGE_TS :\n\t\t\t\t HTE_RISING_EDGE_TS;\n\tif (eflags & GPIO_V2_LINE_FLAG_EDGE_FALLING)\n\t\tflags |= test_bit(FLAG_ACTIVE_LOW, &line->desc->flags) ?\n\t\t\t\t HTE_RISING_EDGE_TS :\n\t\t\t\t HTE_FALLING_EDGE_TS;\n\n\tline->total_discard_seq = 0;\n\n\thte_init_line_attr(hdesc, desc_to_gpio(line->desc), flags, NULL,\n\t\t\t   line->desc);\n\n\tret = hte_ts_get(NULL, hdesc, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hte_request_ts_ns(hdesc, process_hw_ts, process_hw_ts_thread,\n\t\t\t\t line);\n}\n\n#else\n\nstatic int hte_edge_setup(struct line *line, u64 eflags)\n{\n\treturn 0;\n}\n#endif  \n\nstatic irqreturn_t edge_irq_thread(int irq, void *p)\n{\n\tstruct line *line = p;\n\tstruct linereq *lr = line->req;\n\tstruct gpio_v2_line_event le;\n\n\t \n\tmemset(&le, 0, sizeof(le));\n\n\tif (line->timestamp_ns) {\n\t\tle.timestamp_ns = line->timestamp_ns;\n\t} else {\n\t\t \n\t\tle.timestamp_ns = line_event_timestamp(line);\n\t\tif (lr->num_lines != 1)\n\t\t\tline->req_seqno = atomic_inc_return(&lr->seqno);\n\t}\n\tline->timestamp_ns = 0;\n\n\tswitch (READ_ONCE(line->edflags) & GPIO_V2_LINE_EDGE_FLAGS) {\n\tcase GPIO_V2_LINE_FLAG_EDGE_BOTH:\n\t\tle.id = line_event_id(gpiod_get_value_cansleep(line->desc));\n\t\tbreak;\n\tcase GPIO_V2_LINE_FLAG_EDGE_RISING:\n\t\tle.id = GPIO_V2_LINE_EVENT_RISING_EDGE;\n\t\tbreak;\n\tcase GPIO_V2_LINE_FLAG_EDGE_FALLING:\n\t\tle.id = GPIO_V2_LINE_EVENT_FALLING_EDGE;\n\t\tbreak;\n\tdefault:\n\t\treturn IRQ_NONE;\n\t}\n\tline->line_seqno++;\n\tle.line_seqno = line->line_seqno;\n\tle.seqno = (lr->num_lines == 1) ? le.line_seqno : line->req_seqno;\n\tle.offset = gpio_chip_hwgpio(line->desc);\n\n\tlinereq_put_event(lr, &le);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t edge_irq_handler(int irq, void *p)\n{\n\tstruct line *line = p;\n\tstruct linereq *lr = line->req;\n\n\t \n\tline->timestamp_ns = line_event_timestamp(line);\n\n\tif (lr->num_lines != 1)\n\t\tline->req_seqno = atomic_inc_return(&lr->seqno);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic bool debounced_value(struct line *line)\n{\n\tbool value;\n\n\t \n\tvalue = READ_ONCE(line->level);\n\n\tif (test_bit(FLAG_ACTIVE_LOW, &line->desc->flags))\n\t\tvalue = !value;\n\n\treturn value;\n}\n\nstatic irqreturn_t debounce_irq_handler(int irq, void *p)\n{\n\tstruct line *line = p;\n\n\tmod_delayed_work(system_wq, &line->work,\n\t\tusecs_to_jiffies(READ_ONCE(line->desc->debounce_period_us)));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void debounce_work_func(struct work_struct *work)\n{\n\tstruct gpio_v2_line_event le;\n\tstruct line *line = container_of(work, struct line, work.work);\n\tstruct linereq *lr;\n\tu64 eflags, edflags = READ_ONCE(line->edflags);\n\tint level = -1;\n#ifdef CONFIG_HTE\n\tint diff_seqno;\n\n\tif (edflags & GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE)\n\t\tlevel = line->raw_level;\n#endif\n\tif (level < 0)\n\t\tlevel = gpiod_get_raw_value_cansleep(line->desc);\n\tif (level < 0) {\n\t\tpr_debug_ratelimited(\"debouncer failed to read line value\\n\");\n\t\treturn;\n\t}\n\n\tif (READ_ONCE(line->level) == level)\n\t\treturn;\n\n\tWRITE_ONCE(line->level, level);\n\n\t \n\teflags = edflags & GPIO_V2_LINE_EDGE_FLAGS;\n\tif (!eflags)\n\t\treturn;\n\n\t \n\tif (edflags & GPIO_V2_LINE_FLAG_ACTIVE_LOW)\n\t\tlevel = !level;\n\n\t \n\tif (((eflags == GPIO_V2_LINE_FLAG_EDGE_RISING) && !level) ||\n\t    ((eflags == GPIO_V2_LINE_FLAG_EDGE_FALLING) && level))\n\t\treturn;\n\n\t \n\tmemset(&le, 0, sizeof(le));\n\n\tlr = line->req;\n\tle.timestamp_ns = line_event_timestamp(line);\n\tle.offset = gpio_chip_hwgpio(line->desc);\n#ifdef CONFIG_HTE\n\tif (edflags & GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE) {\n\t\t \n\t\tline->total_discard_seq -= 1;\n\t\tdiff_seqno = line->last_seqno - line->total_discard_seq -\n\t\t\t\tline->line_seqno;\n\t\tline->line_seqno = line->last_seqno - line->total_discard_seq;\n\t\tle.line_seqno = line->line_seqno;\n\t\tle.seqno = (lr->num_lines == 1) ?\n\t\t\tle.line_seqno : atomic_add_return(diff_seqno, &lr->seqno);\n\t} else\n#endif  \n\t{\n\t\tline->line_seqno++;\n\t\tle.line_seqno = line->line_seqno;\n\t\tle.seqno = (lr->num_lines == 1) ?\n\t\t\tle.line_seqno : atomic_inc_return(&lr->seqno);\n\t}\n\n\tle.id = line_event_id(level);\n\n\tlinereq_put_event(lr, &le);\n}\n\nstatic int debounce_setup(struct line *line, unsigned int debounce_period_us)\n{\n\tunsigned long irqflags;\n\tint ret, level, irq;\n\n\t \n\tret = gpiod_set_debounce(line->desc, debounce_period_us);\n\tif (!ret) {\n\t\tWRITE_ONCE(line->desc->debounce_period_us, debounce_period_us);\n\t\treturn ret;\n\t}\n\tif (ret != -ENOTSUPP)\n\t\treturn ret;\n\n\tif (debounce_period_us) {\n\t\t \n\t\tlevel = gpiod_get_raw_value_cansleep(line->desc);\n\t\tif (level < 0)\n\t\t\treturn level;\n\n\t\tif (!(IS_ENABLED(CONFIG_HTE) &&\n\t\t      test_bit(FLAG_EVENT_CLOCK_HTE, &line->desc->flags))) {\n\t\t\tirq = gpiod_to_irq(line->desc);\n\t\t\tif (irq < 0)\n\t\t\t\treturn -ENXIO;\n\n\t\t\tirqflags = IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING;\n\t\t\tret = request_irq(irq, debounce_irq_handler, irqflags,\n\t\t\t\t\t  line->req->label, line);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tline->irq = irq;\n\t\t} else {\n\t\t\tret = hte_edge_setup(line, GPIO_V2_LINE_FLAG_EDGE_BOTH);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tWRITE_ONCE(line->level, level);\n\t\tWRITE_ONCE(line->sw_debounced, 1);\n\t}\n\treturn 0;\n}\n\nstatic bool gpio_v2_line_config_debounced(struct gpio_v2_line_config *lc,\n\t\t\t\t\t  unsigned int line_idx)\n{\n\tunsigned int i;\n\tu64 mask = BIT_ULL(line_idx);\n\n\tfor (i = 0; i < lc->num_attrs; i++) {\n\t\tif ((lc->attrs[i].attr.id == GPIO_V2_LINE_ATTR_ID_DEBOUNCE) &&\n\t\t    (lc->attrs[i].mask & mask))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic u32 gpio_v2_line_config_debounce_period(struct gpio_v2_line_config *lc,\n\t\t\t\t\t       unsigned int line_idx)\n{\n\tunsigned int i;\n\tu64 mask = BIT_ULL(line_idx);\n\n\tfor (i = 0; i < lc->num_attrs; i++) {\n\t\tif ((lc->attrs[i].attr.id == GPIO_V2_LINE_ATTR_ID_DEBOUNCE) &&\n\t\t    (lc->attrs[i].mask & mask))\n\t\t\treturn lc->attrs[i].attr.debounce_period_us;\n\t}\n\treturn 0;\n}\n\nstatic void edge_detector_stop(struct line *line)\n{\n\tif (line->irq) {\n\t\tfree_irq(line->irq, line);\n\t\tline->irq = 0;\n\t}\n\n#ifdef CONFIG_HTE\n\tif (READ_ONCE(line->edflags) & GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE)\n\t\thte_ts_put(&line->hdesc);\n#endif\n\n\tcancel_delayed_work_sync(&line->work);\n\tWRITE_ONCE(line->sw_debounced, 0);\n\tWRITE_ONCE(line->edflags, 0);\n\tif (line->desc)\n\t\tWRITE_ONCE(line->desc->debounce_period_us, 0);\n\t \n}\n\nstatic int edge_detector_setup(struct line *line,\n\t\t\t       struct gpio_v2_line_config *lc,\n\t\t\t       unsigned int line_idx, u64 edflags)\n{\n\tu32 debounce_period_us;\n\tunsigned long irqflags = 0;\n\tu64 eflags;\n\tint irq, ret;\n\n\teflags = edflags & GPIO_V2_LINE_EDGE_FLAGS;\n\tif (eflags && !kfifo_initialized(&line->req->events)) {\n\t\tret = kfifo_alloc(&line->req->events,\n\t\t\t\t  line->req->event_buffer_size, GFP_KERNEL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (gpio_v2_line_config_debounced(lc, line_idx)) {\n\t\tdebounce_period_us = gpio_v2_line_config_debounce_period(lc, line_idx);\n\t\tret = debounce_setup(line, debounce_period_us);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tWRITE_ONCE(line->desc->debounce_period_us, debounce_period_us);\n\t}\n\n\t \n\tif (!eflags || READ_ONCE(line->sw_debounced))\n\t\treturn 0;\n\n\tif (IS_ENABLED(CONFIG_HTE) &&\n\t    (edflags & GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE))\n\t\treturn hte_edge_setup(line, edflags);\n\n\tirq = gpiod_to_irq(line->desc);\n\tif (irq < 0)\n\t\treturn -ENXIO;\n\n\tif (eflags & GPIO_V2_LINE_FLAG_EDGE_RISING)\n\t\tirqflags |= test_bit(FLAG_ACTIVE_LOW, &line->desc->flags) ?\n\t\t\tIRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;\n\tif (eflags & GPIO_V2_LINE_FLAG_EDGE_FALLING)\n\t\tirqflags |= test_bit(FLAG_ACTIVE_LOW, &line->desc->flags) ?\n\t\t\tIRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;\n\tirqflags |= IRQF_ONESHOT;\n\n\t \n\tret = request_threaded_irq(irq, edge_irq_handler, edge_irq_thread,\n\t\t\t\t   irqflags, line->req->label, line);\n\tif (ret)\n\t\treturn ret;\n\n\tline->irq = irq;\n\treturn 0;\n}\n\nstatic int edge_detector_update(struct line *line,\n\t\t\t\tstruct gpio_v2_line_config *lc,\n\t\t\t\tunsigned int line_idx, u64 edflags)\n{\n\tu64 active_edflags = READ_ONCE(line->edflags);\n\tunsigned int debounce_period_us =\n\t\t\tgpio_v2_line_config_debounce_period(lc, line_idx);\n\n\tif ((active_edflags == edflags) &&\n\t    (READ_ONCE(line->desc->debounce_period_us) == debounce_period_us))\n\t\treturn 0;\n\n\t \n\tif (debounce_period_us && READ_ONCE(line->sw_debounced)) {\n\t\tWRITE_ONCE(line->desc->debounce_period_us, debounce_period_us);\n\t\treturn 0;\n\t}\n\n\t \n\tif ((line->irq && !READ_ONCE(line->sw_debounced)) ||\n\t    (active_edflags & GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE) ||\n\t    (!debounce_period_us && READ_ONCE(line->sw_debounced)))\n\t\tedge_detector_stop(line);\n\n\treturn edge_detector_setup(line, lc, line_idx, edflags);\n}\n\nstatic u64 gpio_v2_line_config_flags(struct gpio_v2_line_config *lc,\n\t\t\t\t     unsigned int line_idx)\n{\n\tunsigned int i;\n\tu64 mask = BIT_ULL(line_idx);\n\n\tfor (i = 0; i < lc->num_attrs; i++) {\n\t\tif ((lc->attrs[i].attr.id == GPIO_V2_LINE_ATTR_ID_FLAGS) &&\n\t\t    (lc->attrs[i].mask & mask))\n\t\t\treturn lc->attrs[i].attr.flags;\n\t}\n\treturn lc->flags;\n}\n\nstatic int gpio_v2_line_config_output_value(struct gpio_v2_line_config *lc,\n\t\t\t\t\t    unsigned int line_idx)\n{\n\tunsigned int i;\n\tu64 mask = BIT_ULL(line_idx);\n\n\tfor (i = 0; i < lc->num_attrs; i++) {\n\t\tif ((lc->attrs[i].attr.id == GPIO_V2_LINE_ATTR_ID_OUTPUT_VALUES) &&\n\t\t    (lc->attrs[i].mask & mask))\n\t\t\treturn !!(lc->attrs[i].attr.values & mask);\n\t}\n\treturn 0;\n}\n\nstatic int gpio_v2_line_flags_validate(u64 flags)\n{\n\t \n\tif (flags & ~GPIO_V2_LINE_VALID_FLAGS)\n\t\treturn -EINVAL;\n\n\tif (!IS_ENABLED(CONFIG_HTE) &&\n\t    (flags & GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((flags & GPIO_V2_LINE_FLAG_INPUT) &&\n\t    (flags & GPIO_V2_LINE_FLAG_OUTPUT))\n\t\treturn -EINVAL;\n\n\t \n\tif (IS_ENABLED(CONFIG_HTE) &&\n\t    (flags & GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME) &&\n\t    (flags & GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE))\n\t\treturn -EINVAL;\n\n\t \n\tif ((flags & GPIO_V2_LINE_EDGE_FLAGS) &&\n\t    !(flags & GPIO_V2_LINE_FLAG_INPUT))\n\t\treturn -EINVAL;\n\n\t \n\tif ((flags & GPIO_V2_LINE_FLAG_OPEN_DRAIN) &&\n\t    (flags & GPIO_V2_LINE_FLAG_OPEN_SOURCE))\n\t\treturn -EINVAL;\n\n\t \n\tif ((flags & GPIO_V2_LINE_DRIVE_FLAGS) &&\n\t    !(flags & GPIO_V2_LINE_FLAG_OUTPUT))\n\t\treturn -EINVAL;\n\n\t \n\tif ((flags & GPIO_V2_LINE_BIAS_FLAGS) &&\n\t    !(flags & GPIO_V2_LINE_DIRECTION_FLAGS))\n\t\treturn -EINVAL;\n\n\t \n\tif (((flags & GPIO_V2_LINE_FLAG_BIAS_DISABLED) &&\n\t     (flags & (GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN |\n\t\t       GPIO_V2_LINE_FLAG_BIAS_PULL_UP))) ||\n\t    ((flags & GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN) &&\n\t     (flags & GPIO_V2_LINE_FLAG_BIAS_PULL_UP)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int gpio_v2_line_config_validate(struct gpio_v2_line_config *lc,\n\t\t\t\t\tunsigned int num_lines)\n{\n\tunsigned int i;\n\tu64 flags;\n\tint ret;\n\n\tif (lc->num_attrs > GPIO_V2_LINE_NUM_ATTRS_MAX)\n\t\treturn -EINVAL;\n\n\tif (memchr_inv(lc->padding, 0, sizeof(lc->padding)))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_lines; i++) {\n\t\tflags = gpio_v2_line_config_flags(lc, i);\n\t\tret = gpio_v2_line_flags_validate(flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (gpio_v2_line_config_debounced(lc, i) &&\n\t\t    !(flags & GPIO_V2_LINE_FLAG_INPUT))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void gpio_v2_line_config_flags_to_desc_flags(u64 flags,\n\t\t\t\t\t\t    unsigned long *flagsp)\n{\n\tassign_bit(FLAG_ACTIVE_LOW, flagsp,\n\t\t   flags & GPIO_V2_LINE_FLAG_ACTIVE_LOW);\n\n\tif (flags & GPIO_V2_LINE_FLAG_OUTPUT)\n\t\tset_bit(FLAG_IS_OUT, flagsp);\n\telse if (flags & GPIO_V2_LINE_FLAG_INPUT)\n\t\tclear_bit(FLAG_IS_OUT, flagsp);\n\n\tassign_bit(FLAG_EDGE_RISING, flagsp,\n\t\t   flags & GPIO_V2_LINE_FLAG_EDGE_RISING);\n\tassign_bit(FLAG_EDGE_FALLING, flagsp,\n\t\t   flags & GPIO_V2_LINE_FLAG_EDGE_FALLING);\n\n\tassign_bit(FLAG_OPEN_DRAIN, flagsp,\n\t\t   flags & GPIO_V2_LINE_FLAG_OPEN_DRAIN);\n\tassign_bit(FLAG_OPEN_SOURCE, flagsp,\n\t\t   flags & GPIO_V2_LINE_FLAG_OPEN_SOURCE);\n\n\tassign_bit(FLAG_PULL_UP, flagsp,\n\t\t   flags & GPIO_V2_LINE_FLAG_BIAS_PULL_UP);\n\tassign_bit(FLAG_PULL_DOWN, flagsp,\n\t\t   flags & GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN);\n\tassign_bit(FLAG_BIAS_DISABLE, flagsp,\n\t\t   flags & GPIO_V2_LINE_FLAG_BIAS_DISABLED);\n\n\tassign_bit(FLAG_EVENT_CLOCK_REALTIME, flagsp,\n\t\t   flags & GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME);\n\tassign_bit(FLAG_EVENT_CLOCK_HTE, flagsp,\n\t\t   flags & GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE);\n}\n\nstatic long linereq_get_values(struct linereq *lr, void __user *ip)\n{\n\tstruct gpio_v2_line_values lv;\n\tDECLARE_BITMAP(vals, GPIO_V2_LINES_MAX);\n\tstruct gpio_desc **descs;\n\tunsigned int i, didx, num_get;\n\tbool val;\n\tint ret;\n\n\t \n\tif (copy_from_user(&lv, ip, sizeof(lv)))\n\t\treturn -EFAULT;\n\n\tfor (num_get = 0, i = 0; i < lr->num_lines; i++) {\n\t\tif (lv.mask & BIT_ULL(i)) {\n\t\t\tnum_get++;\n\t\t\tdescs = &lr->lines[i].desc;\n\t\t}\n\t}\n\n\tif (num_get == 0)\n\t\treturn -EINVAL;\n\n\tif (num_get != 1) {\n\t\tdescs = kmalloc_array(num_get, sizeof(*descs), GFP_KERNEL);\n\t\tif (!descs)\n\t\t\treturn -ENOMEM;\n\t\tfor (didx = 0, i = 0; i < lr->num_lines; i++) {\n\t\t\tif (lv.mask & BIT_ULL(i)) {\n\t\t\t\tdescs[didx] = lr->lines[i].desc;\n\t\t\t\tdidx++;\n\t\t\t}\n\t\t}\n\t}\n\tret = gpiod_get_array_value_complex(false, true, num_get,\n\t\t\t\t\t    descs, NULL, vals);\n\n\tif (num_get != 1)\n\t\tkfree(descs);\n\tif (ret)\n\t\treturn ret;\n\n\tlv.bits = 0;\n\tfor (didx = 0, i = 0; i < lr->num_lines; i++) {\n\t\tif (lv.mask & BIT_ULL(i)) {\n\t\t\tif (lr->lines[i].sw_debounced)\n\t\t\t\tval = debounced_value(&lr->lines[i]);\n\t\t\telse\n\t\t\t\tval = test_bit(didx, vals);\n\t\t\tif (val)\n\t\t\t\tlv.bits |= BIT_ULL(i);\n\t\t\tdidx++;\n\t\t}\n\t}\n\n\tif (copy_to_user(ip, &lv, sizeof(lv)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long linereq_set_values_unlocked(struct linereq *lr,\n\t\t\t\t\tstruct gpio_v2_line_values *lv)\n{\n\tDECLARE_BITMAP(vals, GPIO_V2_LINES_MAX);\n\tstruct gpio_desc **descs;\n\tunsigned int i, didx, num_set;\n\tint ret;\n\n\tbitmap_zero(vals, GPIO_V2_LINES_MAX);\n\tfor (num_set = 0, i = 0; i < lr->num_lines; i++) {\n\t\tif (lv->mask & BIT_ULL(i)) {\n\t\t\tif (!test_bit(FLAG_IS_OUT, &lr->lines[i].desc->flags))\n\t\t\t\treturn -EPERM;\n\t\t\tif (lv->bits & BIT_ULL(i))\n\t\t\t\t__set_bit(num_set, vals);\n\t\t\tnum_set++;\n\t\t\tdescs = &lr->lines[i].desc;\n\t\t}\n\t}\n\tif (num_set == 0)\n\t\treturn -EINVAL;\n\n\tif (num_set != 1) {\n\t\t \n\t\tdescs = kmalloc_array(num_set, sizeof(*descs), GFP_KERNEL);\n\t\tif (!descs)\n\t\t\treturn -ENOMEM;\n\t\tfor (didx = 0, i = 0; i < lr->num_lines; i++) {\n\t\t\tif (lv->mask & BIT_ULL(i)) {\n\t\t\t\tdescs[didx] = lr->lines[i].desc;\n\t\t\t\tdidx++;\n\t\t\t}\n\t\t}\n\t}\n\tret = gpiod_set_array_value_complex(false, true, num_set,\n\t\t\t\t\t    descs, NULL, vals);\n\n\tif (num_set != 1)\n\t\tkfree(descs);\n\treturn ret;\n}\n\nstatic long linereq_set_values(struct linereq *lr, void __user *ip)\n{\n\tstruct gpio_v2_line_values lv;\n\tint ret;\n\n\tif (copy_from_user(&lv, ip, sizeof(lv)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&lr->config_mutex);\n\n\tret = linereq_set_values_unlocked(lr, &lv);\n\n\tmutex_unlock(&lr->config_mutex);\n\n\treturn ret;\n}\n\nstatic long linereq_set_config_unlocked(struct linereq *lr,\n\t\t\t\t\tstruct gpio_v2_line_config *lc)\n{\n\tstruct gpio_desc *desc;\n\tstruct line *line;\n\tunsigned int i;\n\tu64 flags, edflags;\n\tint ret;\n\n\tfor (i = 0; i < lr->num_lines; i++) {\n\t\tline = &lr->lines[i];\n\t\tdesc = lr->lines[i].desc;\n\t\tflags = gpio_v2_line_config_flags(lc, i);\n\t\tgpio_v2_line_config_flags_to_desc_flags(flags, &desc->flags);\n\t\tedflags = flags & GPIO_V2_LINE_EDGE_DETECTOR_FLAGS;\n\t\t \n\t\tif (flags & GPIO_V2_LINE_FLAG_OUTPUT) {\n\t\t\tint val = gpio_v2_line_config_output_value(lc, i);\n\n\t\t\tedge_detector_stop(line);\n\t\t\tret = gpiod_direction_output(desc, val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else if (flags & GPIO_V2_LINE_FLAG_INPUT) {\n\t\t\tret = gpiod_direction_input(desc);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = edge_detector_update(line, lc, i, edflags);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tWRITE_ONCE(line->edflags, edflags);\n\n\t\tgpiod_line_state_notify(desc, GPIO_V2_LINE_CHANGED_CONFIG);\n\t}\n\treturn 0;\n}\n\nstatic long linereq_set_config(struct linereq *lr, void __user *ip)\n{\n\tstruct gpio_v2_line_config lc;\n\tint ret;\n\n\tif (copy_from_user(&lc, ip, sizeof(lc)))\n\t\treturn -EFAULT;\n\n\tret = gpio_v2_line_config_validate(&lc, lr->num_lines);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&lr->config_mutex);\n\n\tret = linereq_set_config_unlocked(lr, &lc);\n\n\tmutex_unlock(&lr->config_mutex);\n\n\treturn ret;\n}\n\nstatic long linereq_ioctl_unlocked(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct linereq *lr = file->private_data;\n\tvoid __user *ip = (void __user *)arg;\n\n\tif (!lr->gdev->chip)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase GPIO_V2_LINE_GET_VALUES_IOCTL:\n\t\treturn linereq_get_values(lr, ip);\n\tcase GPIO_V2_LINE_SET_VALUES_IOCTL:\n\t\treturn linereq_set_values(lr, ip);\n\tcase GPIO_V2_LINE_SET_CONFIG_IOCTL:\n\t\treturn linereq_set_config(lr, ip);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic long linereq_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct linereq *lr = file->private_data;\n\n\treturn call_ioctl_locked(file, cmd, arg, lr->gdev,\n\t\t\t\t linereq_ioctl_unlocked);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long linereq_ioctl_compat(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\treturn linereq_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic __poll_t linereq_poll_unlocked(struct file *file,\n\t\t\t\t      struct poll_table_struct *wait)\n{\n\tstruct linereq *lr = file->private_data;\n\t__poll_t events = 0;\n\n\tif (!lr->gdev->chip)\n\t\treturn EPOLLHUP | EPOLLERR;\n\n\tpoll_wait(file, &lr->wait, wait);\n\n\tif (!kfifo_is_empty_spinlocked_noirqsave(&lr->events,\n\t\t\t\t\t\t &lr->wait.lock))\n\t\tevents = EPOLLIN | EPOLLRDNORM;\n\n\treturn events;\n}\n\nstatic __poll_t linereq_poll(struct file *file,\n\t\t\t     struct poll_table_struct *wait)\n{\n\tstruct linereq *lr = file->private_data;\n\n\treturn call_poll_locked(file, wait, lr->gdev, linereq_poll_unlocked);\n}\n\nstatic ssize_t linereq_read_unlocked(struct file *file, char __user *buf,\n\t\t\t\t     size_t count, loff_t *f_ps)\n{\n\tstruct linereq *lr = file->private_data;\n\tstruct gpio_v2_line_event le;\n\tssize_t bytes_read = 0;\n\tint ret;\n\n\tif (!lr->gdev->chip)\n\t\treturn -ENODEV;\n\n\tif (count < sizeof(le))\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tspin_lock(&lr->wait.lock);\n\t\tif (kfifo_is_empty(&lr->events)) {\n\t\t\tif (bytes_read) {\n\t\t\t\tspin_unlock(&lr->wait.lock);\n\t\t\t\treturn bytes_read;\n\t\t\t}\n\n\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\tspin_unlock(&lr->wait.lock);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\n\t\t\tret = wait_event_interruptible_locked(lr->wait,\n\t\t\t\t\t!kfifo_is_empty(&lr->events));\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock(&lr->wait.lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = kfifo_out(&lr->events, &le, 1);\n\t\tspin_unlock(&lr->wait.lock);\n\t\tif (ret != 1) {\n\t\t\t \n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf + bytes_read, &le, sizeof(le)))\n\t\t\treturn -EFAULT;\n\t\tbytes_read += sizeof(le);\n\t} while (count >= bytes_read + sizeof(le));\n\n\treturn bytes_read;\n}\n\nstatic ssize_t linereq_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *f_ps)\n{\n\tstruct linereq *lr = file->private_data;\n\n\treturn call_read_locked(file, buf, count, f_ps, lr->gdev,\n\t\t\t\tlinereq_read_unlocked);\n}\n\nstatic void linereq_free(struct linereq *lr)\n{\n\tunsigned int i;\n\n\tif (lr->device_unregistered_nb.notifier_call)\n\t\tblocking_notifier_chain_unregister(&lr->gdev->device_notifier,\n\t\t\t\t\t\t   &lr->device_unregistered_nb);\n\n\tfor (i = 0; i < lr->num_lines; i++) {\n\t\tif (lr->lines[i].desc) {\n\t\t\tedge_detector_stop(&lr->lines[i]);\n\t\t\tgpiod_free(lr->lines[i].desc);\n\t\t}\n\t}\n\tkfifo_free(&lr->events);\n\tkfree(lr->label);\n\tgpio_device_put(lr->gdev);\n\tkfree(lr);\n}\n\nstatic int linereq_release(struct inode *inode, struct file *file)\n{\n\tstruct linereq *lr = file->private_data;\n\n\tlinereq_free(lr);\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void linereq_show_fdinfo(struct seq_file *out, struct file *file)\n{\n\tstruct linereq *lr = file->private_data;\n\tstruct device *dev = &lr->gdev->dev;\n\tu16 i;\n\n\tseq_printf(out, \"gpio-chip:\\t%s\\n\", dev_name(dev));\n\n\tfor (i = 0; i < lr->num_lines; i++)\n\t\tseq_printf(out, \"gpio-line:\\t%d\\n\",\n\t\t\t   gpio_chip_hwgpio(lr->lines[i].desc));\n}\n#endif\n\nstatic const struct file_operations line_fileops = {\n\t.release = linereq_release,\n\t.read = linereq_read,\n\t.poll = linereq_poll,\n\t.owner = THIS_MODULE,\n\t.llseek = noop_llseek,\n\t.unlocked_ioctl = linereq_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = linereq_ioctl_compat,\n#endif\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo = linereq_show_fdinfo,\n#endif\n};\n\nstatic int linereq_create(struct gpio_device *gdev, void __user *ip)\n{\n\tstruct gpio_v2_line_request ulr;\n\tstruct gpio_v2_line_config *lc;\n\tstruct linereq *lr;\n\tstruct file *file;\n\tu64 flags, edflags;\n\tunsigned int i;\n\tint fd, ret;\n\n\tif (copy_from_user(&ulr, ip, sizeof(ulr)))\n\t\treturn -EFAULT;\n\n\tif ((ulr.num_lines == 0) || (ulr.num_lines > GPIO_V2_LINES_MAX))\n\t\treturn -EINVAL;\n\n\tif (memchr_inv(ulr.padding, 0, sizeof(ulr.padding)))\n\t\treturn -EINVAL;\n\n\tlc = &ulr.config;\n\tret = gpio_v2_line_config_validate(lc, ulr.num_lines);\n\tif (ret)\n\t\treturn ret;\n\n\tlr = kzalloc(struct_size(lr, lines, ulr.num_lines), GFP_KERNEL);\n\tif (!lr)\n\t\treturn -ENOMEM;\n\n\tlr->gdev = gpio_device_get(gdev);\n\n\tfor (i = 0; i < ulr.num_lines; i++) {\n\t\tlr->lines[i].req = lr;\n\t\tWRITE_ONCE(lr->lines[i].sw_debounced, 0);\n\t\tINIT_DELAYED_WORK(&lr->lines[i].work, debounce_work_func);\n\t}\n\n\tif (ulr.consumer[0] != '\\0') {\n\t\t \n\t\tlr->label = kstrndup(ulr.consumer, sizeof(ulr.consumer) - 1,\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!lr->label) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free_linereq;\n\t\t}\n\t}\n\n\tmutex_init(&lr->config_mutex);\n\tinit_waitqueue_head(&lr->wait);\n\tlr->event_buffer_size = ulr.event_buffer_size;\n\tif (lr->event_buffer_size == 0)\n\t\tlr->event_buffer_size = ulr.num_lines * 16;\n\telse if (lr->event_buffer_size > GPIO_V2_LINES_MAX * 16)\n\t\tlr->event_buffer_size = GPIO_V2_LINES_MAX * 16;\n\n\tatomic_set(&lr->seqno, 0);\n\tlr->num_lines = ulr.num_lines;\n\n\t \n\tfor (i = 0; i < ulr.num_lines; i++) {\n\t\tu32 offset = ulr.offsets[i];\n\t\tstruct gpio_desc *desc = gpiochip_get_desc(gdev->chip, offset);\n\n\t\tif (IS_ERR(desc)) {\n\t\t\tret = PTR_ERR(desc);\n\t\t\tgoto out_free_linereq;\n\t\t}\n\n\t\tret = gpiod_request_user(desc, lr->label);\n\t\tif (ret)\n\t\t\tgoto out_free_linereq;\n\n\t\tlr->lines[i].desc = desc;\n\t\tflags = gpio_v2_line_config_flags(lc, i);\n\t\tgpio_v2_line_config_flags_to_desc_flags(flags, &desc->flags);\n\n\t\tret = gpiod_set_transitory(desc, false);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_linereq;\n\n\t\tedflags = flags & GPIO_V2_LINE_EDGE_DETECTOR_FLAGS;\n\t\t \n\t\tif (flags & GPIO_V2_LINE_FLAG_OUTPUT) {\n\t\t\tint val = gpio_v2_line_config_output_value(lc, i);\n\n\t\t\tret = gpiod_direction_output(desc, val);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_linereq;\n\t\t} else if (flags & GPIO_V2_LINE_FLAG_INPUT) {\n\t\t\tret = gpiod_direction_input(desc);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_linereq;\n\n\t\t\tret = edge_detector_setup(&lr->lines[i], lc, i,\n\t\t\t\t\t\t  edflags);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_linereq;\n\t\t}\n\n\t\tlr->lines[i].edflags = edflags;\n\n\t\tgpiod_line_state_notify(desc, GPIO_V2_LINE_CHANGED_REQUESTED);\n\n\t\tdev_dbg(&gdev->dev, \"registered chardev handle for line %d\\n\",\n\t\t\toffset);\n\t}\n\n\tlr->device_unregistered_nb.notifier_call = linereq_unregistered_notify;\n\tret = blocking_notifier_chain_register(&gdev->device_notifier,\n\t\t\t\t\t       &lr->device_unregistered_nb);\n\tif (ret)\n\t\tgoto out_free_linereq;\n\n\tfd = get_unused_fd_flags(O_RDONLY | O_CLOEXEC);\n\tif (fd < 0) {\n\t\tret = fd;\n\t\tgoto out_free_linereq;\n\t}\n\n\tfile = anon_inode_getfile(\"gpio-line\", &line_fileops, lr,\n\t\t\t\t  O_RDONLY | O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tret = PTR_ERR(file);\n\t\tgoto out_put_unused_fd;\n\t}\n\n\tulr.fd = fd;\n\tif (copy_to_user(ip, &ulr, sizeof(ulr))) {\n\t\t \n\t\tfput(file);\n\t\tput_unused_fd(fd);\n\t\treturn -EFAULT;\n\t}\n\n\tfd_install(fd, file);\n\n\tdev_dbg(&gdev->dev, \"registered chardev handle for %d lines\\n\",\n\t\tlr->num_lines);\n\n\treturn 0;\n\nout_put_unused_fd:\n\tput_unused_fd(fd);\nout_free_linereq:\n\tlinereq_free(lr);\n\treturn ret;\n}\n\n#ifdef CONFIG_GPIO_CDEV_V1\n\n \n\n \nstruct lineevent_state {\n\tstruct gpio_device *gdev;\n\tconst char *label;\n\tstruct gpio_desc *desc;\n\tu32 eflags;\n\tint irq;\n\twait_queue_head_t wait;\n\tstruct notifier_block device_unregistered_nb;\n\tDECLARE_KFIFO(events, struct gpioevent_data, 16);\n\tu64 timestamp;\n};\n\n#define GPIOEVENT_REQUEST_VALID_FLAGS \\\n\t(GPIOEVENT_REQUEST_RISING_EDGE | \\\n\tGPIOEVENT_REQUEST_FALLING_EDGE)\n\nstatic __poll_t lineevent_poll_unlocked(struct file *file,\n\t\t\t\t\tstruct poll_table_struct *wait)\n{\n\tstruct lineevent_state *le = file->private_data;\n\t__poll_t events = 0;\n\n\tif (!le->gdev->chip)\n\t\treturn EPOLLHUP | EPOLLERR;\n\n\tpoll_wait(file, &le->wait, wait);\n\n\tif (!kfifo_is_empty_spinlocked_noirqsave(&le->events, &le->wait.lock))\n\t\tevents = EPOLLIN | EPOLLRDNORM;\n\n\treturn events;\n}\n\nstatic __poll_t lineevent_poll(struct file *file,\n\t\t\t       struct poll_table_struct *wait)\n{\n\tstruct lineevent_state *le = file->private_data;\n\n\treturn call_poll_locked(file, wait, le->gdev, lineevent_poll_unlocked);\n}\n\nstatic int lineevent_unregistered_notify(struct notifier_block *nb,\n\t\t\t\t\t unsigned long action, void *data)\n{\n\tstruct lineevent_state *le = container_of(nb, struct lineevent_state,\n\t\t\t\t\t\t  device_unregistered_nb);\n\n\twake_up_poll(&le->wait, EPOLLIN | EPOLLERR);\n\n\treturn NOTIFY_OK;\n}\n\nstruct compat_gpioeevent_data {\n\tcompat_u64\ttimestamp;\n\tu32\t\tid;\n};\n\nstatic ssize_t lineevent_read_unlocked(struct file *file, char __user *buf,\n\t\t\t\t       size_t count, loff_t *f_ps)\n{\n\tstruct lineevent_state *le = file->private_data;\n\tstruct gpioevent_data ge;\n\tssize_t bytes_read = 0;\n\tssize_t ge_size;\n\tint ret;\n\n\tif (!le->gdev->chip)\n\t\treturn -ENODEV;\n\n\t \n\tif (compat_need_64bit_alignment_fixup())\n\t\tge_size = sizeof(struct compat_gpioeevent_data);\n\telse\n\t\tge_size = sizeof(struct gpioevent_data);\n\tif (count < ge_size)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tspin_lock(&le->wait.lock);\n\t\tif (kfifo_is_empty(&le->events)) {\n\t\t\tif (bytes_read) {\n\t\t\t\tspin_unlock(&le->wait.lock);\n\t\t\t\treturn bytes_read;\n\t\t\t}\n\n\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\tspin_unlock(&le->wait.lock);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\n\t\t\tret = wait_event_interruptible_locked(le->wait,\n\t\t\t\t\t!kfifo_is_empty(&le->events));\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock(&le->wait.lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = kfifo_out(&le->events, &ge, 1);\n\t\tspin_unlock(&le->wait.lock);\n\t\tif (ret != 1) {\n\t\t\t \n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf + bytes_read, &ge, ge_size))\n\t\t\treturn -EFAULT;\n\t\tbytes_read += ge_size;\n\t} while (count >= bytes_read + ge_size);\n\n\treturn bytes_read;\n}\n\nstatic ssize_t lineevent_read(struct file *file, char __user *buf,\n\t\t\t      size_t count, loff_t *f_ps)\n{\n\tstruct lineevent_state *le = file->private_data;\n\n\treturn call_read_locked(file, buf, count, f_ps, le->gdev,\n\t\t\t\tlineevent_read_unlocked);\n}\n\nstatic void lineevent_free(struct lineevent_state *le)\n{\n\tif (le->device_unregistered_nb.notifier_call)\n\t\tblocking_notifier_chain_unregister(&le->gdev->device_notifier,\n\t\t\t\t\t\t   &le->device_unregistered_nb);\n\tif (le->irq)\n\t\tfree_irq(le->irq, le);\n\tif (le->desc)\n\t\tgpiod_free(le->desc);\n\tkfree(le->label);\n\tgpio_device_put(le->gdev);\n\tkfree(le);\n}\n\nstatic int lineevent_release(struct inode *inode, struct file *file)\n{\n\tlineevent_free(file->private_data);\n\treturn 0;\n}\n\nstatic long lineevent_ioctl_unlocked(struct file *file, unsigned int cmd,\n\t\t\t\t     unsigned long arg)\n{\n\tstruct lineevent_state *le = file->private_data;\n\tvoid __user *ip = (void __user *)arg;\n\tstruct gpiohandle_data ghd;\n\n\tif (!le->gdev->chip)\n\t\treturn -ENODEV;\n\n\t \n\tif (cmd == GPIOHANDLE_GET_LINE_VALUES_IOCTL) {\n\t\tint val;\n\n\t\tmemset(&ghd, 0, sizeof(ghd));\n\n\t\tval = gpiod_get_value_cansleep(le->desc);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tghd.values[0] = val;\n\n\t\tif (copy_to_user(ip, &ghd, sizeof(ghd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic long lineevent_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct lineevent_state *le = file->private_data;\n\n\treturn call_ioctl_locked(file, cmd, arg, le->gdev,\n\t\t\t\t lineevent_ioctl_unlocked);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long lineevent_ioctl_compat(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\treturn lineevent_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic const struct file_operations lineevent_fileops = {\n\t.release = lineevent_release,\n\t.read = lineevent_read,\n\t.poll = lineevent_poll,\n\t.owner = THIS_MODULE,\n\t.llseek = noop_llseek,\n\t.unlocked_ioctl = lineevent_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = lineevent_ioctl_compat,\n#endif\n};\n\nstatic irqreturn_t lineevent_irq_thread(int irq, void *p)\n{\n\tstruct lineevent_state *le = p;\n\tstruct gpioevent_data ge;\n\tint ret;\n\n\t \n\tmemset(&ge, 0, sizeof(ge));\n\n\t \n\tif (!le->timestamp)\n\t\tge.timestamp = ktime_get_ns();\n\telse\n\t\tge.timestamp = le->timestamp;\n\n\tif (le->eflags & GPIOEVENT_REQUEST_RISING_EDGE\n\t    && le->eflags & GPIOEVENT_REQUEST_FALLING_EDGE) {\n\t\tint level = gpiod_get_value_cansleep(le->desc);\n\n\t\tif (level)\n\t\t\t \n\t\t\tge.id = GPIOEVENT_EVENT_RISING_EDGE;\n\t\telse\n\t\t\t \n\t\t\tge.id = GPIOEVENT_EVENT_FALLING_EDGE;\n\t} else if (le->eflags & GPIOEVENT_REQUEST_RISING_EDGE) {\n\t\t \n\t\tge.id = GPIOEVENT_EVENT_RISING_EDGE;\n\t} else if (le->eflags & GPIOEVENT_REQUEST_FALLING_EDGE) {\n\t\t \n\t\tge.id = GPIOEVENT_EVENT_FALLING_EDGE;\n\t} else {\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = kfifo_in_spinlocked_noirqsave(&le->events, &ge,\n\t\t\t\t\t    1, &le->wait.lock);\n\tif (ret)\n\t\twake_up_poll(&le->wait, EPOLLIN);\n\telse\n\t\tpr_debug_ratelimited(\"event FIFO is full - event dropped\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t lineevent_irq_handler(int irq, void *p)\n{\n\tstruct lineevent_state *le = p;\n\n\t \n\tle->timestamp = ktime_get_ns();\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic int lineevent_create(struct gpio_device *gdev, void __user *ip)\n{\n\tstruct gpioevent_request eventreq;\n\tstruct lineevent_state *le;\n\tstruct gpio_desc *desc;\n\tstruct file *file;\n\tu32 offset;\n\tu32 lflags;\n\tu32 eflags;\n\tint fd;\n\tint ret;\n\tint irq, irqflags = 0;\n\n\tif (copy_from_user(&eventreq, ip, sizeof(eventreq)))\n\t\treturn -EFAULT;\n\n\toffset = eventreq.lineoffset;\n\tlflags = eventreq.handleflags;\n\teflags = eventreq.eventflags;\n\n\tdesc = gpiochip_get_desc(gdev->chip, offset);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\t \n\tif ((lflags & ~GPIOHANDLE_REQUEST_VALID_FLAGS) ||\n\t    (eflags & ~GPIOEVENT_REQUEST_VALID_FLAGS))\n\t\treturn -EINVAL;\n\n\t \n\tif ((lflags & GPIOHANDLE_REQUEST_OUTPUT) ||\n\t    (lflags & GPIOHANDLE_REQUEST_OPEN_DRAIN) ||\n\t    (lflags & GPIOHANDLE_REQUEST_OPEN_SOURCE))\n\t\treturn -EINVAL;\n\n\t \n\tif (((lflags & GPIOHANDLE_REQUEST_BIAS_DISABLE) &&\n\t     (lflags & (GPIOHANDLE_REQUEST_BIAS_PULL_DOWN |\n\t\t\tGPIOHANDLE_REQUEST_BIAS_PULL_UP))) ||\n\t    ((lflags & GPIOHANDLE_REQUEST_BIAS_PULL_DOWN) &&\n\t     (lflags & GPIOHANDLE_REQUEST_BIAS_PULL_UP)))\n\t\treturn -EINVAL;\n\n\tle = kzalloc(sizeof(*le), GFP_KERNEL);\n\tif (!le)\n\t\treturn -ENOMEM;\n\tle->gdev = gpio_device_get(gdev);\n\n\tif (eventreq.consumer_label[0] != '\\0') {\n\t\t \n\t\tle->label = kstrndup(eventreq.consumer_label,\n\t\t\t\t     sizeof(eventreq.consumer_label) - 1,\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!le->label) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free_le;\n\t\t}\n\t}\n\n\tret = gpiod_request_user(desc, le->label);\n\tif (ret)\n\t\tgoto out_free_le;\n\tle->desc = desc;\n\tle->eflags = eflags;\n\n\tlinehandle_flags_to_desc_flags(lflags, &desc->flags);\n\n\tret = gpiod_direction_input(desc);\n\tif (ret)\n\t\tgoto out_free_le;\n\n\tgpiod_line_state_notify(desc, GPIO_V2_LINE_CHANGED_REQUESTED);\n\n\tirq = gpiod_to_irq(desc);\n\tif (irq <= 0) {\n\t\tret = -ENODEV;\n\t\tgoto out_free_le;\n\t}\n\n\tif (eflags & GPIOEVENT_REQUEST_RISING_EDGE)\n\t\tirqflags |= test_bit(FLAG_ACTIVE_LOW, &desc->flags) ?\n\t\t\tIRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;\n\tif (eflags & GPIOEVENT_REQUEST_FALLING_EDGE)\n\t\tirqflags |= test_bit(FLAG_ACTIVE_LOW, &desc->flags) ?\n\t\t\tIRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;\n\tirqflags |= IRQF_ONESHOT;\n\n\tINIT_KFIFO(le->events);\n\tinit_waitqueue_head(&le->wait);\n\n\tle->device_unregistered_nb.notifier_call = lineevent_unregistered_notify;\n\tret = blocking_notifier_chain_register(&gdev->device_notifier,\n\t\t\t\t\t       &le->device_unregistered_nb);\n\tif (ret)\n\t\tgoto out_free_le;\n\n\t \n\tret = request_threaded_irq(irq,\n\t\t\t\t   lineevent_irq_handler,\n\t\t\t\t   lineevent_irq_thread,\n\t\t\t\t   irqflags,\n\t\t\t\t   le->label,\n\t\t\t\t   le);\n\tif (ret)\n\t\tgoto out_free_le;\n\n\tle->irq = irq;\n\n\tfd = get_unused_fd_flags(O_RDONLY | O_CLOEXEC);\n\tif (fd < 0) {\n\t\tret = fd;\n\t\tgoto out_free_le;\n\t}\n\n\tfile = anon_inode_getfile(\"gpio-event\",\n\t\t\t\t  &lineevent_fileops,\n\t\t\t\t  le,\n\t\t\t\t  O_RDONLY | O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tret = PTR_ERR(file);\n\t\tgoto out_put_unused_fd;\n\t}\n\n\teventreq.fd = fd;\n\tif (copy_to_user(ip, &eventreq, sizeof(eventreq))) {\n\t\t \n\t\tfput(file);\n\t\tput_unused_fd(fd);\n\t\treturn -EFAULT;\n\t}\n\n\tfd_install(fd, file);\n\n\treturn 0;\n\nout_put_unused_fd:\n\tput_unused_fd(fd);\nout_free_le:\n\tlineevent_free(le);\n\treturn ret;\n}\n\nstatic void gpio_v2_line_info_to_v1(struct gpio_v2_line_info *info_v2,\n\t\t\t\t    struct gpioline_info *info_v1)\n{\n\tu64 flagsv2 = info_v2->flags;\n\n\tmemcpy(info_v1->name, info_v2->name, sizeof(info_v1->name));\n\tmemcpy(info_v1->consumer, info_v2->consumer, sizeof(info_v1->consumer));\n\tinfo_v1->line_offset = info_v2->offset;\n\tinfo_v1->flags = 0;\n\n\tif (flagsv2 & GPIO_V2_LINE_FLAG_USED)\n\t\tinfo_v1->flags |= GPIOLINE_FLAG_KERNEL;\n\n\tif (flagsv2 & GPIO_V2_LINE_FLAG_OUTPUT)\n\t\tinfo_v1->flags |= GPIOLINE_FLAG_IS_OUT;\n\n\tif (flagsv2 & GPIO_V2_LINE_FLAG_ACTIVE_LOW)\n\t\tinfo_v1->flags |= GPIOLINE_FLAG_ACTIVE_LOW;\n\n\tif (flagsv2 & GPIO_V2_LINE_FLAG_OPEN_DRAIN)\n\t\tinfo_v1->flags |= GPIOLINE_FLAG_OPEN_DRAIN;\n\tif (flagsv2 & GPIO_V2_LINE_FLAG_OPEN_SOURCE)\n\t\tinfo_v1->flags |= GPIOLINE_FLAG_OPEN_SOURCE;\n\n\tif (flagsv2 & GPIO_V2_LINE_FLAG_BIAS_PULL_UP)\n\t\tinfo_v1->flags |= GPIOLINE_FLAG_BIAS_PULL_UP;\n\tif (flagsv2 & GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN)\n\t\tinfo_v1->flags |= GPIOLINE_FLAG_BIAS_PULL_DOWN;\n\tif (flagsv2 & GPIO_V2_LINE_FLAG_BIAS_DISABLED)\n\t\tinfo_v1->flags |= GPIOLINE_FLAG_BIAS_DISABLE;\n}\n\nstatic void gpio_v2_line_info_changed_to_v1(\n\t\tstruct gpio_v2_line_info_changed *lic_v2,\n\t\tstruct gpioline_info_changed *lic_v1)\n{\n\tmemset(lic_v1, 0, sizeof(*lic_v1));\n\tgpio_v2_line_info_to_v1(&lic_v2->info, &lic_v1->info);\n\tlic_v1->timestamp = lic_v2->timestamp_ns;\n\tlic_v1->event_type = lic_v2->event_type;\n}\n\n#endif  \n\nstatic void gpio_desc_to_lineinfo(struct gpio_desc *desc,\n\t\t\t\t  struct gpio_v2_line_info *info)\n{\n\tstruct gpio_chip *gc = desc->gdev->chip;\n\tbool ok_for_pinctrl;\n\tunsigned long flags;\n\tu32 debounce_period_us;\n\tunsigned int num_attrs = 0;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->offset = gpio_chip_hwgpio(desc);\n\n\t \n\tok_for_pinctrl =\n\t\tpinctrl_gpio_can_use_line(gc->base + info->offset);\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\n\tif (desc->name)\n\t\tstrscpy(info->name, desc->name, sizeof(info->name));\n\n\tif (desc->label)\n\t\tstrscpy(info->consumer, desc->label, sizeof(info->consumer));\n\n\t \n\tinfo->flags = 0;\n\tif (test_bit(FLAG_REQUESTED, &desc->flags) ||\n\t    test_bit(FLAG_IS_HOGGED, &desc->flags) ||\n\t    test_bit(FLAG_USED_AS_IRQ, &desc->flags) ||\n\t    test_bit(FLAG_EXPORT, &desc->flags) ||\n\t    test_bit(FLAG_SYSFS, &desc->flags) ||\n\t    !gpiochip_line_is_valid(gc, info->offset) ||\n\t    !ok_for_pinctrl)\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_USED;\n\n\tif (test_bit(FLAG_IS_OUT, &desc->flags))\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_OUTPUT;\n\telse\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_INPUT;\n\n\tif (test_bit(FLAG_ACTIVE_LOW, &desc->flags))\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_ACTIVE_LOW;\n\n\tif (test_bit(FLAG_OPEN_DRAIN, &desc->flags))\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_OPEN_DRAIN;\n\tif (test_bit(FLAG_OPEN_SOURCE, &desc->flags))\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_OPEN_SOURCE;\n\n\tif (test_bit(FLAG_BIAS_DISABLE, &desc->flags))\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_BIAS_DISABLED;\n\tif (test_bit(FLAG_PULL_DOWN, &desc->flags))\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN;\n\tif (test_bit(FLAG_PULL_UP, &desc->flags))\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_BIAS_PULL_UP;\n\n\tif (test_bit(FLAG_EDGE_RISING, &desc->flags))\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_EDGE_RISING;\n\tif (test_bit(FLAG_EDGE_FALLING, &desc->flags))\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_EDGE_FALLING;\n\n\tif (test_bit(FLAG_EVENT_CLOCK_REALTIME, &desc->flags))\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME;\n\telse if (test_bit(FLAG_EVENT_CLOCK_HTE, &desc->flags))\n\t\tinfo->flags |= GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE;\n\n\tdebounce_period_us = READ_ONCE(desc->debounce_period_us);\n\tif (debounce_period_us) {\n\t\tinfo->attrs[num_attrs].id = GPIO_V2_LINE_ATTR_ID_DEBOUNCE;\n\t\tinfo->attrs[num_attrs].debounce_period_us = debounce_period_us;\n\t\tnum_attrs++;\n\t}\n\tinfo->num_attrs = num_attrs;\n\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n}\n\nstruct gpio_chardev_data {\n\tstruct gpio_device *gdev;\n\twait_queue_head_t wait;\n\tDECLARE_KFIFO(events, struct gpio_v2_line_info_changed, 32);\n\tstruct notifier_block lineinfo_changed_nb;\n\tstruct notifier_block device_unregistered_nb;\n\tunsigned long *watched_lines;\n#ifdef CONFIG_GPIO_CDEV_V1\n\tatomic_t watch_abi_version;\n#endif\n};\n\nstatic int chipinfo_get(struct gpio_chardev_data *cdev, void __user *ip)\n{\n\tstruct gpio_device *gdev = cdev->gdev;\n\tstruct gpiochip_info chipinfo;\n\n\tmemset(&chipinfo, 0, sizeof(chipinfo));\n\n\tstrscpy(chipinfo.name, dev_name(&gdev->dev), sizeof(chipinfo.name));\n\tstrscpy(chipinfo.label, gdev->label, sizeof(chipinfo.label));\n\tchipinfo.lines = gdev->ngpio;\n\tif (copy_to_user(ip, &chipinfo, sizeof(chipinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#ifdef CONFIG_GPIO_CDEV_V1\n \nstatic int lineinfo_ensure_abi_version(struct gpio_chardev_data *cdata,\n\t\t\t\t       unsigned int version)\n{\n\tint abiv = atomic_cmpxchg(&cdata->watch_abi_version, 0, version);\n\n\tif (abiv == version)\n\t\treturn 0;\n\n\treturn abiv;\n}\n\nstatic int lineinfo_get_v1(struct gpio_chardev_data *cdev, void __user *ip,\n\t\t\t   bool watch)\n{\n\tstruct gpio_desc *desc;\n\tstruct gpioline_info lineinfo;\n\tstruct gpio_v2_line_info lineinfo_v2;\n\n\tif (copy_from_user(&lineinfo, ip, sizeof(lineinfo)))\n\t\treturn -EFAULT;\n\n\t \n\tdesc = gpiochip_get_desc(cdev->gdev->chip, lineinfo.line_offset);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\tif (watch) {\n\t\tif (lineinfo_ensure_abi_version(cdev, 1))\n\t\t\treturn -EPERM;\n\n\t\tif (test_and_set_bit(lineinfo.line_offset, cdev->watched_lines))\n\t\t\treturn -EBUSY;\n\t}\n\n\tgpio_desc_to_lineinfo(desc, &lineinfo_v2);\n\tgpio_v2_line_info_to_v1(&lineinfo_v2, &lineinfo);\n\n\tif (copy_to_user(ip, &lineinfo, sizeof(lineinfo))) {\n\t\tif (watch)\n\t\t\tclear_bit(lineinfo.line_offset, cdev->watched_lines);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int lineinfo_get(struct gpio_chardev_data *cdev, void __user *ip,\n\t\t\tbool watch)\n{\n\tstruct gpio_desc *desc;\n\tstruct gpio_v2_line_info lineinfo;\n\n\tif (copy_from_user(&lineinfo, ip, sizeof(lineinfo)))\n\t\treturn -EFAULT;\n\n\tif (memchr_inv(lineinfo.padding, 0, sizeof(lineinfo.padding)))\n\t\treturn -EINVAL;\n\n\tdesc = gpiochip_get_desc(cdev->gdev->chip, lineinfo.offset);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\tif (watch) {\n#ifdef CONFIG_GPIO_CDEV_V1\n\t\tif (lineinfo_ensure_abi_version(cdev, 2))\n\t\t\treturn -EPERM;\n#endif\n\t\tif (test_and_set_bit(lineinfo.offset, cdev->watched_lines))\n\t\t\treturn -EBUSY;\n\t}\n\tgpio_desc_to_lineinfo(desc, &lineinfo);\n\n\tif (copy_to_user(ip, &lineinfo, sizeof(lineinfo))) {\n\t\tif (watch)\n\t\t\tclear_bit(lineinfo.offset, cdev->watched_lines);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int lineinfo_unwatch(struct gpio_chardev_data *cdev, void __user *ip)\n{\n\t__u32 offset;\n\n\tif (copy_from_user(&offset, ip, sizeof(offset)))\n\t\treturn -EFAULT;\n\n\tif (offset >= cdev->gdev->ngpio)\n\t\treturn -EINVAL;\n\n\tif (!test_and_clear_bit(offset, cdev->watched_lines))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic long gpio_ioctl_unlocked(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct gpio_chardev_data *cdev = file->private_data;\n\tstruct gpio_device *gdev = cdev->gdev;\n\tvoid __user *ip = (void __user *)arg;\n\n\t \n\tif (!gdev->chip)\n\t\treturn -ENODEV;\n\n\t \n\tswitch (cmd) {\n\tcase GPIO_GET_CHIPINFO_IOCTL:\n\t\treturn chipinfo_get(cdev, ip);\n#ifdef CONFIG_GPIO_CDEV_V1\n\tcase GPIO_GET_LINEHANDLE_IOCTL:\n\t\treturn linehandle_create(gdev, ip);\n\tcase GPIO_GET_LINEEVENT_IOCTL:\n\t\treturn lineevent_create(gdev, ip);\n\tcase GPIO_GET_LINEINFO_IOCTL:\n\t\treturn lineinfo_get_v1(cdev, ip, false);\n\tcase GPIO_GET_LINEINFO_WATCH_IOCTL:\n\t\treturn lineinfo_get_v1(cdev, ip, true);\n#endif  \n\tcase GPIO_V2_GET_LINEINFO_IOCTL:\n\t\treturn lineinfo_get(cdev, ip, false);\n\tcase GPIO_V2_GET_LINEINFO_WATCH_IOCTL:\n\t\treturn lineinfo_get(cdev, ip, true);\n\tcase GPIO_V2_GET_LINE_IOCTL:\n\t\treturn linereq_create(gdev, ip);\n\tcase GPIO_GET_LINEINFO_UNWATCH_IOCTL:\n\t\treturn lineinfo_unwatch(cdev, ip);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic long gpio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct gpio_chardev_data *cdev = file->private_data;\n\n\treturn call_ioctl_locked(file, cmd, arg, cdev->gdev,\n\t\t\t\t gpio_ioctl_unlocked);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long gpio_ioctl_compat(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\treturn gpio_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic int lineinfo_changed_notify(struct notifier_block *nb,\n\t\t\t\t   unsigned long action, void *data)\n{\n\tstruct gpio_chardev_data *cdev =\n\t\tcontainer_of(nb, struct gpio_chardev_data, lineinfo_changed_nb);\n\tstruct gpio_v2_line_info_changed chg;\n\tstruct gpio_desc *desc = data;\n\tint ret;\n\n\tif (!test_bit(gpio_chip_hwgpio(desc), cdev->watched_lines))\n\t\treturn NOTIFY_DONE;\n\n\tmemset(&chg, 0, sizeof(chg));\n\tchg.event_type = action;\n\tchg.timestamp_ns = ktime_get_ns();\n\tgpio_desc_to_lineinfo(desc, &chg.info);\n\n\tret = kfifo_in_spinlocked(&cdev->events, &chg, 1, &cdev->wait.lock);\n\tif (ret)\n\t\twake_up_poll(&cdev->wait, EPOLLIN);\n\telse\n\t\tpr_debug_ratelimited(\"lineinfo event FIFO is full - event dropped\\n\");\n\n\treturn NOTIFY_OK;\n}\n\nstatic int gpio_device_unregistered_notify(struct notifier_block *nb,\n\t\t\t\t\t   unsigned long action, void *data)\n{\n\tstruct gpio_chardev_data *cdev = container_of(nb,\n\t\t\t\t\t\t      struct gpio_chardev_data,\n\t\t\t\t\t\t      device_unregistered_nb);\n\n\twake_up_poll(&cdev->wait, EPOLLIN | EPOLLERR);\n\n\treturn NOTIFY_OK;\n}\n\nstatic __poll_t lineinfo_watch_poll_unlocked(struct file *file,\n\t\t\t\t\t     struct poll_table_struct *pollt)\n{\n\tstruct gpio_chardev_data *cdev = file->private_data;\n\t__poll_t events = 0;\n\n\tif (!cdev->gdev->chip)\n\t\treturn EPOLLHUP | EPOLLERR;\n\n\tpoll_wait(file, &cdev->wait, pollt);\n\n\tif (!kfifo_is_empty_spinlocked_noirqsave(&cdev->events,\n\t\t\t\t\t\t &cdev->wait.lock))\n\t\tevents = EPOLLIN | EPOLLRDNORM;\n\n\treturn events;\n}\n\nstatic __poll_t lineinfo_watch_poll(struct file *file,\n\t\t\t\t    struct poll_table_struct *pollt)\n{\n\tstruct gpio_chardev_data *cdev = file->private_data;\n\n\treturn call_poll_locked(file, pollt, cdev->gdev,\n\t\t\t\tlineinfo_watch_poll_unlocked);\n}\n\nstatic ssize_t lineinfo_watch_read_unlocked(struct file *file, char __user *buf,\n\t\t\t\t\t    size_t count, loff_t *off)\n{\n\tstruct gpio_chardev_data *cdev = file->private_data;\n\tstruct gpio_v2_line_info_changed event;\n\tssize_t bytes_read = 0;\n\tint ret;\n\tsize_t event_size;\n\n\tif (!cdev->gdev->chip)\n\t\treturn -ENODEV;\n\n#ifndef CONFIG_GPIO_CDEV_V1\n\tevent_size = sizeof(struct gpio_v2_line_info_changed);\n\tif (count < event_size)\n\t\treturn -EINVAL;\n#endif\n\n\tdo {\n\t\tspin_lock(&cdev->wait.lock);\n\t\tif (kfifo_is_empty(&cdev->events)) {\n\t\t\tif (bytes_read) {\n\t\t\t\tspin_unlock(&cdev->wait.lock);\n\t\t\t\treturn bytes_read;\n\t\t\t}\n\n\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\tspin_unlock(&cdev->wait.lock);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\n\t\t\tret = wait_event_interruptible_locked(cdev->wait,\n\t\t\t\t\t!kfifo_is_empty(&cdev->events));\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock(&cdev->wait.lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n#ifdef CONFIG_GPIO_CDEV_V1\n\t\t \n\t\tif (atomic_read(&cdev->watch_abi_version) == 2)\n\t\t\tevent_size = sizeof(struct gpio_v2_line_info_changed);\n\t\telse\n\t\t\tevent_size = sizeof(struct gpioline_info_changed);\n\t\tif (count < event_size) {\n\t\t\tspin_unlock(&cdev->wait.lock);\n\t\t\treturn -EINVAL;\n\t\t}\n#endif\n\t\tret = kfifo_out(&cdev->events, &event, 1);\n\t\tspin_unlock(&cdev->wait.lock);\n\t\tif (ret != 1) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t\t \n\t\t}\n\n#ifdef CONFIG_GPIO_CDEV_V1\n\t\tif (event_size == sizeof(struct gpio_v2_line_info_changed)) {\n\t\t\tif (copy_to_user(buf + bytes_read, &event, event_size))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tstruct gpioline_info_changed event_v1;\n\n\t\t\tgpio_v2_line_info_changed_to_v1(&event, &event_v1);\n\t\t\tif (copy_to_user(buf + bytes_read, &event_v1,\n\t\t\t\t\t event_size))\n\t\t\t\treturn -EFAULT;\n\t\t}\n#else\n\t\tif (copy_to_user(buf + bytes_read, &event, event_size))\n\t\t\treturn -EFAULT;\n#endif\n\t\tbytes_read += event_size;\n\t} while (count >= bytes_read + sizeof(event));\n\n\treturn bytes_read;\n}\n\nstatic ssize_t lineinfo_watch_read(struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t *off)\n{\n\tstruct gpio_chardev_data *cdev = file->private_data;\n\n\treturn call_read_locked(file, buf, count, off, cdev->gdev,\n\t\t\t\tlineinfo_watch_read_unlocked);\n}\n\n \nstatic int gpio_chrdev_open(struct inode *inode, struct file *file)\n{\n\tstruct gpio_device *gdev = container_of(inode->i_cdev,\n\t\t\t\t\t\tstruct gpio_device, chrdev);\n\tstruct gpio_chardev_data *cdev;\n\tint ret = -ENOMEM;\n\n\tdown_read(&gdev->sem);\n\n\t \n\tif (!gdev->chip) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tcdev = kzalloc(sizeof(*cdev), GFP_KERNEL);\n\tif (!cdev)\n\t\tgoto out_unlock;\n\n\tcdev->watched_lines = bitmap_zalloc(gdev->chip->ngpio, GFP_KERNEL);\n\tif (!cdev->watched_lines)\n\t\tgoto out_free_cdev;\n\n\tinit_waitqueue_head(&cdev->wait);\n\tINIT_KFIFO(cdev->events);\n\tcdev->gdev = gpio_device_get(gdev);\n\n\tcdev->lineinfo_changed_nb.notifier_call = lineinfo_changed_notify;\n\tret = blocking_notifier_chain_register(&gdev->line_state_notifier,\n\t\t\t\t\t       &cdev->lineinfo_changed_nb);\n\tif (ret)\n\t\tgoto out_free_bitmap;\n\n\tcdev->device_unregistered_nb.notifier_call =\n\t\t\t\t\tgpio_device_unregistered_notify;\n\tret = blocking_notifier_chain_register(&gdev->device_notifier,\n\t\t\t\t\t       &cdev->device_unregistered_nb);\n\tif (ret)\n\t\tgoto out_unregister_line_notifier;\n\n\tfile->private_data = cdev;\n\n\tret = nonseekable_open(inode, file);\n\tif (ret)\n\t\tgoto out_unregister_device_notifier;\n\n\tup_read(&gdev->sem);\n\n\treturn ret;\n\nout_unregister_device_notifier:\n\tblocking_notifier_chain_unregister(&gdev->device_notifier,\n\t\t\t\t\t   &cdev->device_unregistered_nb);\nout_unregister_line_notifier:\n\tblocking_notifier_chain_unregister(&gdev->line_state_notifier,\n\t\t\t\t\t   &cdev->lineinfo_changed_nb);\nout_free_bitmap:\n\tgpio_device_put(gdev);\n\tbitmap_free(cdev->watched_lines);\nout_free_cdev:\n\tkfree(cdev);\nout_unlock:\n\tup_read(&gdev->sem);\n\treturn ret;\n}\n\n \nstatic int gpio_chrdev_release(struct inode *inode, struct file *file)\n{\n\tstruct gpio_chardev_data *cdev = file->private_data;\n\tstruct gpio_device *gdev = cdev->gdev;\n\n\tbitmap_free(cdev->watched_lines);\n\tblocking_notifier_chain_unregister(&gdev->device_notifier,\n\t\t\t\t\t   &cdev->device_unregistered_nb);\n\tblocking_notifier_chain_unregister(&gdev->line_state_notifier,\n\t\t\t\t\t   &cdev->lineinfo_changed_nb);\n\tgpio_device_put(gdev);\n\tkfree(cdev);\n\n\treturn 0;\n}\n\nstatic const struct file_operations gpio_fileops = {\n\t.release = gpio_chrdev_release,\n\t.open = gpio_chrdev_open,\n\t.poll = lineinfo_watch_poll,\n\t.read = lineinfo_watch_read,\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n\t.unlocked_ioctl = gpio_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = gpio_ioctl_compat,\n#endif\n};\n\nint gpiolib_cdev_register(struct gpio_device *gdev, dev_t devt)\n{\n\tint ret;\n\n\tcdev_init(&gdev->chrdev, &gpio_fileops);\n\tgdev->chrdev.owner = THIS_MODULE;\n\tgdev->dev.devt = MKDEV(MAJOR(devt), gdev->id);\n\n\tret = cdev_device_add(&gdev->chrdev, &gdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tchip_dbg(gdev->chip, \"added GPIO chardev (%d:%d)\\n\",\n\t\t MAJOR(devt), gdev->id);\n\n\treturn 0;\n}\n\nvoid gpiolib_cdev_unregister(struct gpio_device *gdev)\n{\n\tcdev_device_del(&gdev->chrdev, &gdev->dev);\n\tblocking_notifier_call_chain(&gdev->device_notifier, 0, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}