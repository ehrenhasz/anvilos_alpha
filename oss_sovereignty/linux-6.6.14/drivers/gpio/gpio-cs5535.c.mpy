{
  "module_name": "gpio-cs5535.c",
  "hash_id": "b0d54765f1dcb5e824f1fd50b404ff2dc2d63d1c56df76591a1da26a6eb4c88e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-cs5535.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/cs5535.h>\n#include <asm/msr.h>\n\n#define DRV_NAME \"cs5535-gpio\"\n\n \n#define GPIO_DEFAULT_MASK 0x0F7FFFFF\n\nstatic ulong mask = GPIO_DEFAULT_MASK;\nmodule_param_named(mask, mask, ulong, 0444);\nMODULE_PARM_DESC(mask, \"GPIO channel mask.\");\n\n \nstatic struct cs5535_gpio_chip {\n\tstruct gpio_chip chip;\n\tresource_size_t base;\n\n\tstruct platform_device *pdev;\n\tspinlock_t lock;\n} cs5535_gpio_chip;\n\n \n\nstatic void errata_outl(struct cs5535_gpio_chip *chip, u32 val,\n\t\tunsigned int reg)\n{\n\tunsigned long addr = chip->base + 0x80 + reg;\n\n\t \n\tif (reg != GPIO_POSITIVE_EDGE_STS && reg != GPIO_NEGATIVE_EDGE_STS) {\n\t\tif (val & 0xffff)\n\t\t\tval |= (inl(addr) & 0xffff);  \n\t\telse\n\t\t\tval |= (inl(addr) ^ (val >> 16));\n\t}\n\toutl(val, addr);\n}\n\nstatic void __cs5535_gpio_set(struct cs5535_gpio_chip *chip, unsigned offset,\n\t\tunsigned int reg)\n{\n\tif (offset < 16)\n\t\t \n\t\toutl(1 << offset, chip->base + reg);\n\telse\n\t\t \n\t\terrata_outl(chip, 1 << (offset - 16), reg);\n}\n\nvoid cs5535_gpio_set(unsigned offset, unsigned int reg)\n{\n\tstruct cs5535_gpio_chip *chip = &cs5535_gpio_chip;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\t__cs5535_gpio_set(chip, offset, reg);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\nEXPORT_SYMBOL_GPL(cs5535_gpio_set);\n\nstatic void __cs5535_gpio_clear(struct cs5535_gpio_chip *chip, unsigned offset,\n\t\tunsigned int reg)\n{\n\tif (offset < 16)\n\t\t \n\t\toutl(1 << (offset + 16), chip->base + reg);\n\telse\n\t\t \n\t\terrata_outl(chip, 1 << offset, reg);\n}\n\nvoid cs5535_gpio_clear(unsigned offset, unsigned int reg)\n{\n\tstruct cs5535_gpio_chip *chip = &cs5535_gpio_chip;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\t__cs5535_gpio_clear(chip, offset, reg);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\nEXPORT_SYMBOL_GPL(cs5535_gpio_clear);\n\nint cs5535_gpio_isset(unsigned offset, unsigned int reg)\n{\n\tstruct cs5535_gpio_chip *chip = &cs5535_gpio_chip;\n\tunsigned long flags;\n\tlong val;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tif (offset < 16)\n\t\t \n\t\tval = inl(chip->base + reg);\n\telse {\n\t\t \n\t\tval = inl(chip->base + 0x80 + reg);\n\t\toffset -= 16;\n\t}\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn (val & (1 << offset)) ? 1 : 0;\n}\nEXPORT_SYMBOL_GPL(cs5535_gpio_isset);\n\nint cs5535_gpio_set_irq(unsigned group, unsigned irq)\n{\n\tuint32_t lo, hi;\n\n\tif (group > 7 || irq > 15)\n\t\treturn -EINVAL;\n\n\trdmsr(MSR_PIC_ZSEL_HIGH, lo, hi);\n\n\tlo &= ~(0xF << (group * 4));\n\tlo |= (irq & 0xF) << (group * 4);\n\n\twrmsr(MSR_PIC_ZSEL_HIGH, lo, hi);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cs5535_gpio_set_irq);\n\nvoid cs5535_gpio_setup_event(unsigned offset, int pair, int pme)\n{\n\tstruct cs5535_gpio_chip *chip = &cs5535_gpio_chip;\n\tuint32_t shift = (offset % 8) * 4;\n\tunsigned long flags;\n\tuint32_t val;\n\n\tif (offset >= 24)\n\t\toffset = GPIO_MAP_W;\n\telse if (offset >= 16)\n\t\toffset = GPIO_MAP_Z;\n\telse if (offset >= 8)\n\t\toffset = GPIO_MAP_Y;\n\telse\n\t\toffset = GPIO_MAP_X;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tval = inl(chip->base + offset);\n\n\t \n\tval &= ~(0xF << shift);\n\n\t \n\tval |= ((pair & 7) << shift);\n\n\t \n\tif (pme)\n\t\tval |= (1 << (shift + 3));\n\n\toutl(val, chip->base + offset);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\nEXPORT_SYMBOL_GPL(cs5535_gpio_setup_event);\n\n \n\nstatic int chip_gpio_request(struct gpio_chip *c, unsigned offset)\n{\n\tstruct cs5535_gpio_chip *chip = gpiochip_get_data(c);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\t \n\tif ((mask & (1 << offset)) == 0) {\n\t\tdev_info(&chip->pdev->dev,\n\t\t\t\"pin %u is not available (check mask)\\n\", offset);\n\t\tspin_unlock_irqrestore(&chip->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t__cs5535_gpio_clear(chip, offset, GPIO_OUTPUT_AUX1);\n\t__cs5535_gpio_clear(chip, offset, GPIO_OUTPUT_AUX2);\n\n\t \n\t__cs5535_gpio_clear(chip, offset, GPIO_INPUT_AUX1);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic int chip_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\treturn cs5535_gpio_isset(offset, GPIO_READ_BACK);\n}\n\nstatic void chip_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\n{\n\tif (val)\n\t\tcs5535_gpio_set(offset, GPIO_OUTPUT_VAL);\n\telse\n\t\tcs5535_gpio_clear(offset, GPIO_OUTPUT_VAL);\n}\n\nstatic int chip_direction_input(struct gpio_chip *c, unsigned offset)\n{\n\tstruct cs5535_gpio_chip *chip = gpiochip_get_data(c);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\t__cs5535_gpio_set(chip, offset, GPIO_INPUT_ENABLE);\n\t__cs5535_gpio_clear(chip, offset, GPIO_OUTPUT_ENABLE);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic int chip_direction_output(struct gpio_chip *c, unsigned offset, int val)\n{\n\tstruct cs5535_gpio_chip *chip = gpiochip_get_data(c);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\t__cs5535_gpio_set(chip, offset, GPIO_INPUT_ENABLE);\n\t__cs5535_gpio_set(chip, offset, GPIO_OUTPUT_ENABLE);\n\tif (val)\n\t\t__cs5535_gpio_set(chip, offset, GPIO_OUTPUT_VAL);\n\telse\n\t\t__cs5535_gpio_clear(chip, offset, GPIO_OUTPUT_VAL);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic const char * const cs5535_gpio_names[] = {\n\t\"GPIO0\", \"GPIO1\", \"GPIO2\", \"GPIO3\",\n\t\"GPIO4\", \"GPIO5\", \"GPIO6\", \"GPIO7\",\n\t\"GPIO8\", \"GPIO9\", \"GPIO10\", \"GPIO11\",\n\t\"GPIO12\", \"GPIO13\", \"GPIO14\", \"GPIO15\",\n\t\"GPIO16\", \"GPIO17\", \"GPIO18\", \"GPIO19\",\n\t\"GPIO20\", \"GPIO21\", \"GPIO22\", NULL,\n\t\"GPIO24\", \"GPIO25\", \"GPIO26\", \"GPIO27\",\n\t\"GPIO28\", NULL, NULL, NULL,\n};\n\nstatic struct cs5535_gpio_chip cs5535_gpio_chip = {\n\t.chip = {\n\t\t.owner = THIS_MODULE,\n\t\t.label = DRV_NAME,\n\n\t\t.base = 0,\n\t\t.ngpio = 32,\n\t\t.names = cs5535_gpio_names,\n\t\t.request = chip_gpio_request,\n\n\t\t.get = chip_gpio_get,\n\t\t.set = chip_gpio_set,\n\n\t\t.direction_input = chip_direction_input,\n\t\t.direction_output = chip_direction_output,\n\t},\n};\n\nstatic int cs5535_gpio_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tint err = -EIO;\n\tulong mask_orig = mask;\n\n\t \n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"can't fetch device resource info\\n\");\n\t\treturn err;\n\t}\n\n\tif (!devm_request_region(&pdev->dev, res->start, resource_size(res),\n\t\t\t\t pdev->name)) {\n\t\tdev_err(&pdev->dev, \"can't request region\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tcs5535_gpio_chip.base = res->start;\n\tcs5535_gpio_chip.pdev = pdev;\n\tspin_lock_init(&cs5535_gpio_chip.lock);\n\n\tdev_info(&pdev->dev, \"reserved resource region %pR\\n\", res);\n\n\t \n\tmask &= 0x1F7FFFFF;\n\n\t \n\tmask &= ~(1 << 28);\n\n\tif (mask_orig != mask)\n\t\tdev_info(&pdev->dev, \"mask changed from 0x%08lX to 0x%08lX\\n\",\n\t\t\t\tmask_orig, mask);\n\n\t \n\treturn devm_gpiochip_add_data(&pdev->dev, &cs5535_gpio_chip.chip,\n\t\t\t\t      &cs5535_gpio_chip);\n}\n\nstatic struct platform_driver cs5535_gpio_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.probe = cs5535_gpio_probe,\n};\n\nmodule_platform_driver(cs5535_gpio_driver);\n\nMODULE_AUTHOR(\"Andres Salomon <dilinger@queued.net>\");\nMODULE_DESCRIPTION(\"AMD CS5535/CS5536 GPIO driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}