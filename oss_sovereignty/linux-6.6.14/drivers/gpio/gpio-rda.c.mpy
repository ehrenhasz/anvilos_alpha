{
  "module_name": "gpio-rda.c",
  "hash_id": "04e5e645502d9e2ba968e35cb53ef594752b8eccfbc0d3bdf4fb45049698813e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-rda.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#define RDA_GPIO_OEN_VAL\t\t0x00\n#define RDA_GPIO_OEN_SET_OUT\t\t0x04\n#define RDA_GPIO_OEN_SET_IN\t\t0x08\n#define RDA_GPIO_VAL\t\t\t0x0c\n#define RDA_GPIO_SET\t\t\t0x10\n#define RDA_GPIO_CLR\t\t\t0x14\n#define RDA_GPIO_INT_CTRL_SET\t\t0x18\n#define RDA_GPIO_INT_CTRL_CLR\t\t0x1c\n#define RDA_GPIO_INT_CLR\t\t0x20\n#define RDA_GPIO_INT_STATUS\t\t0x24\n\n#define RDA_GPIO_IRQ_RISE_SHIFT\t\t0\n#define RDA_GPIO_IRQ_FALL_SHIFT\t\t8\n#define RDA_GPIO_DEBOUCE_SHIFT\t\t16\n#define RDA_GPIO_LEVEL_SHIFT\t\t24\n\n#define RDA_GPIO_IRQ_MASK\t\t0xff\n\n \n#define RDA_GPIO_BANK_NR\t32\n\nstruct rda_gpio {\n\tstruct gpio_chip chip;\n\tvoid __iomem *base;\n\tspinlock_t lock;\n\tint irq;\n};\n\nstatic inline void rda_gpio_update(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t   u16 reg, int val)\n{\n\tstruct rda_gpio *rda_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *base = rda_gpio->base;\n\tunsigned long flags;\n\tu32 tmp;\n\n\tspin_lock_irqsave(&rda_gpio->lock, flags);\n\ttmp = readl_relaxed(base + reg);\n\n\tif (val)\n\t\ttmp |= BIT(offset);\n\telse\n\t\ttmp &= ~BIT(offset);\n\n\twritel_relaxed(tmp, base + reg);\n\tspin_unlock_irqrestore(&rda_gpio->lock, flags);\n}\n\nstatic void rda_gpio_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct rda_gpio *rda_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *base = rda_gpio->base;\n\tu32 offset = irqd_to_hwirq(data);\n\tu32 value;\n\n\tvalue = BIT(offset) << RDA_GPIO_IRQ_RISE_SHIFT;\n\tvalue |= BIT(offset) << RDA_GPIO_IRQ_FALL_SHIFT;\n\n\twritel_relaxed(value, base + RDA_GPIO_INT_CTRL_CLR);\n\tgpiochip_disable_irq(chip, offset);\n}\n\nstatic void rda_gpio_irq_ack(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tu32 offset = irqd_to_hwirq(data);\n\n\trda_gpio_update(chip, offset, RDA_GPIO_INT_CLR, 1);\n}\n\nstatic int rda_gpio_set_irq(struct gpio_chip *chip, u32 offset,\n\t\t\t    unsigned int flow_type)\n{\n\tstruct rda_gpio *rda_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *base = rda_gpio->base;\n\tu32 value;\n\n\tswitch (flow_type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\t \n\t\tvalue = BIT(offset) << RDA_GPIO_IRQ_RISE_SHIFT;\n\t\twritel_relaxed(value, base + RDA_GPIO_INT_CTRL_SET);\n\n\t\t \n\t\tvalue = BIT(offset) << RDA_GPIO_LEVEL_SHIFT;\n\t\twritel_relaxed(value, base + RDA_GPIO_INT_CTRL_CLR);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\t \n\t\tvalue = BIT(offset) << RDA_GPIO_IRQ_FALL_SHIFT;\n\t\twritel_relaxed(value, base + RDA_GPIO_INT_CTRL_SET);\n\n\t\t \n\t\tvalue = BIT(offset) << RDA_GPIO_LEVEL_SHIFT;\n\t\twritel_relaxed(value, base + RDA_GPIO_INT_CTRL_CLR);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t \n\t\tvalue = BIT(offset) << RDA_GPIO_IRQ_RISE_SHIFT;\n\t\tvalue |= BIT(offset) << RDA_GPIO_IRQ_FALL_SHIFT;\n\t\twritel_relaxed(value, base + RDA_GPIO_INT_CTRL_SET);\n\n\t\t \n\t\tvalue = BIT(offset) << RDA_GPIO_LEVEL_SHIFT;\n\t\twritel_relaxed(value, base + RDA_GPIO_INT_CTRL_CLR);\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\t \n\t\tvalue = BIT(offset) << RDA_GPIO_IRQ_RISE_SHIFT;\n\n\t\t \n\t\tvalue |= BIT(offset) << RDA_GPIO_LEVEL_SHIFT;\n\t\twritel_relaxed(value, base + RDA_GPIO_INT_CTRL_SET);\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\t \n\t\tvalue = BIT(offset) << RDA_GPIO_IRQ_FALL_SHIFT;\n\n\t\t \n\t\tvalue |= BIT(offset) << RDA_GPIO_LEVEL_SHIFT;\n\t\twritel_relaxed(value, base + RDA_GPIO_INT_CTRL_SET);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void rda_gpio_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tu32 offset = irqd_to_hwirq(data);\n\tu32 trigger = irqd_get_trigger_type(data);\n\n\tgpiochip_enable_irq(chip, offset);\n\trda_gpio_set_irq(chip, offset, trigger);\n}\n\nstatic int rda_gpio_irq_set_type(struct irq_data *data, unsigned int flow_type)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tu32 offset = irqd_to_hwirq(data);\n\tint ret;\n\n\tret = rda_gpio_set_irq(chip, offset, flow_type);\n\tif (ret)\n\t\treturn ret;\n\n\tif (flow_type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\telse if (flow_type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\n\treturn 0;\n}\n\nstatic void rda_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *chip = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *ic = irq_desc_get_chip(desc);\n\tstruct rda_gpio *rda_gpio = gpiochip_get_data(chip);\n\tunsigned long status;\n\tu32 n;\n\n\tchained_irq_enter(ic, desc);\n\n\tstatus = readl_relaxed(rda_gpio->base + RDA_GPIO_INT_STATUS);\n\t \n\tstatus &= RDA_GPIO_IRQ_MASK;\n\n\tfor_each_set_bit(n, &status, RDA_GPIO_BANK_NR)\n\t\tgeneric_handle_domain_irq(chip->irq.domain, n);\n\n\tchained_irq_exit(ic, desc);\n}\n\nstatic const struct irq_chip rda_gpio_irq_chip = {\n\t.name = \"rda-gpio\",\n\t.irq_ack = rda_gpio_irq_ack,\n\t.irq_mask = rda_gpio_irq_mask,\n\t.irq_unmask = rda_gpio_irq_unmask,\n\t.irq_set_type = rda_gpio_irq_set_type,\n\t.flags = IRQCHIP_SKIP_SET_WAKE | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int rda_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct gpio_irq_chip *girq;\n\tstruct rda_gpio *rda_gpio;\n\tu32 ngpios;\n\tint ret;\n\n\trda_gpio = devm_kzalloc(dev, sizeof(*rda_gpio), GFP_KERNEL);\n\tif (!rda_gpio)\n\t\treturn -ENOMEM;\n\n\tret = device_property_read_u32(dev, \"ngpios\", &ngpios);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\trda_gpio->irq = platform_get_irq(pdev, 0);\n\n\trda_gpio->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rda_gpio->base))\n\t\treturn PTR_ERR(rda_gpio->base);\n\n\tspin_lock_init(&rda_gpio->lock);\n\n\tret = bgpio_init(&rda_gpio->chip, dev, 4,\n\t\t\t rda_gpio->base + RDA_GPIO_VAL,\n\t\t\t rda_gpio->base + RDA_GPIO_SET,\n\t\t\t rda_gpio->base + RDA_GPIO_CLR,\n\t\t\t rda_gpio->base + RDA_GPIO_OEN_SET_OUT,\n\t\t\t rda_gpio->base + RDA_GPIO_OEN_SET_IN,\n\t\t\t BGPIOF_READ_OUTPUT_REG_SET);\n\tif (ret) {\n\t\tdev_err(dev, \"bgpio_init failed\\n\");\n\t\treturn ret;\n\t}\n\n\trda_gpio->chip.label = dev_name(dev);\n\trda_gpio->chip.ngpio = ngpios;\n\trda_gpio->chip.base = -1;\n\n\tif (rda_gpio->irq >= 0) {\n\t\tgirq = &rda_gpio->chip.irq;\n\t\tgpio_irq_chip_set_chip(girq, &rda_gpio_irq_chip);\n\t\tgirq->handler = handle_bad_irq;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->parent_handler = rda_gpio_irq_handler;\n\t\tgirq->parent_handler_data = rda_gpio;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(dev, 1,\n\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\tgirq->parents[0] = rda_gpio->irq;\n\t}\n\n\tplatform_set_drvdata(pdev, rda_gpio);\n\n\treturn devm_gpiochip_add_data(dev, &rda_gpio->chip, rda_gpio);\n}\n\nstatic const struct of_device_id rda_gpio_of_match[] = {\n\t{ .compatible = \"rda,8810pl-gpio\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rda_gpio_of_match);\n\nstatic struct platform_driver rda_gpio_driver = {\n\t.probe = rda_gpio_probe,\n\t.driver = {\n\t\t.name = \"rda-gpio\",\n\t\t.of_match_table\t= rda_gpio_of_match,\n\t},\n};\n\nmodule_platform_driver_probe(rda_gpio_driver, rda_gpio_probe);\n\nMODULE_DESCRIPTION(\"RDA Micro GPIO driver\");\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}