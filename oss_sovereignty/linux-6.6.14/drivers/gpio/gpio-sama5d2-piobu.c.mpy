{
  "module_name": "gpio-sama5d2-piobu.c",
  "hash_id": "4b7d50a44006ba03e86e362ec701c755d02e342227dde7b96e2bd5272540000d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-sama5d2-piobu.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define PIOBU_NUM 8\n#define PIOBU_REG_SIZE 4\n\n \n#define PIOBU_BMPR 0x7C\n#define PIOBU_NMPR 0x80\n#define PIOBU_WKPR 0x90\n\n#define PIOBU_BASE 0x18  \n\n#define PIOBU_DET_OFFSET 16\n\n \n#define PIOBU_DIRECTION BIT(8)\n#define PIOBU_OUT BIT(8)\n#define PIOBU_IN 0\n\n#define PIOBU_SOD BIT(9)\n#define PIOBU_PDS BIT(10)\n\n#define PIOBU_HIGH BIT(9)\n#define PIOBU_LOW 0\n\nstruct sama5d2_piobu {\n\tstruct gpio_chip chip;\n\tstruct regmap *regmap;\n};\n\n \nstatic int sama5d2_piobu_setup_pin(struct gpio_chip *chip, unsigned int pin)\n{\n\tint ret;\n\tstruct sama5d2_piobu *piobu = container_of(chip, struct sama5d2_piobu,\n\t\t\t\t\t\t   chip);\n\tunsigned int mask = BIT(PIOBU_DET_OFFSET + pin);\n\n\tret = regmap_update_bits(piobu->regmap, PIOBU_BMPR, mask, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(piobu->regmap, PIOBU_NMPR, mask, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(piobu->regmap, PIOBU_WKPR, mask, 0);\n}\n\n \nstatic int sama5d2_piobu_write_value(struct gpio_chip *chip, unsigned int pin,\n\t\t\t\t     unsigned int mask, unsigned int value)\n{\n\tint reg;\n\tstruct sama5d2_piobu *piobu = container_of(chip, struct sama5d2_piobu,\n\t\t\t\t\t\t   chip);\n\n\treg = PIOBU_BASE + pin * PIOBU_REG_SIZE;\n\n\treturn regmap_update_bits(piobu->regmap, reg, mask, value);\n}\n\n \nstatic int sama5d2_piobu_read_value(struct gpio_chip *chip, unsigned int pin,\n\t\t\t\t    unsigned int mask)\n{\n\tstruct sama5d2_piobu *piobu = container_of(chip, struct sama5d2_piobu,\n\t\t\t\t\t\t   chip);\n\tunsigned int val, reg;\n\tint ret;\n\n\treg = PIOBU_BASE + pin * PIOBU_REG_SIZE;\n\tret = regmap_read(piobu->regmap, reg, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn val & mask;\n}\n\n \nstatic int sama5d2_piobu_get_direction(struct gpio_chip *chip,\n\t\t\t\t       unsigned int pin)\n{\n\tint ret = sama5d2_piobu_read_value(chip, pin, PIOBU_DIRECTION);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (ret == PIOBU_IN) ? GPIO_LINE_DIRECTION_IN :\n\t\t\t\t   GPIO_LINE_DIRECTION_OUT;\n}\n\n \nstatic int sama5d2_piobu_direction_input(struct gpio_chip *chip,\n\t\t\t\t\t unsigned int pin)\n{\n\treturn sama5d2_piobu_write_value(chip, pin, PIOBU_DIRECTION, PIOBU_IN);\n}\n\n \nstatic int sama5d2_piobu_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t  unsigned int pin, int value)\n{\n\tunsigned int val = PIOBU_OUT;\n\n\tif (value)\n\t\tval |= PIOBU_HIGH;\n\n\treturn sama5d2_piobu_write_value(chip, pin, PIOBU_DIRECTION | PIOBU_SOD,\n\t\t\t\t\t val);\n}\n\n \nstatic int sama5d2_piobu_get(struct gpio_chip *chip, unsigned int pin)\n{\n\t \n\tint ret = sama5d2_piobu_get_direction(chip, pin);\n\n\tif (ret == GPIO_LINE_DIRECTION_IN)\n\t\tret = sama5d2_piobu_read_value(chip, pin, PIOBU_PDS);\n\telse if (ret == GPIO_LINE_DIRECTION_OUT)\n\t\tret = sama5d2_piobu_read_value(chip, pin, PIOBU_SOD);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!ret;\n}\n\n \nstatic void sama5d2_piobu_set(struct gpio_chip *chip, unsigned int pin,\n\t\t\t      int value)\n{\n\tif (!value)\n\t\tvalue = PIOBU_LOW;\n\telse\n\t\tvalue = PIOBU_HIGH;\n\n\tsama5d2_piobu_write_value(chip, pin, PIOBU_SOD, value);\n}\n\nstatic int sama5d2_piobu_probe(struct platform_device *pdev)\n{\n\tstruct sama5d2_piobu *piobu;\n\tint ret, i;\n\n\tpiobu = devm_kzalloc(&pdev->dev, sizeof(*piobu), GFP_KERNEL);\n\tif (!piobu)\n\t\treturn -ENOMEM;\n\n\tpiobu->chip.label = pdev->name;\n\tpiobu->chip.parent = &pdev->dev;\n\tpiobu->chip.owner = THIS_MODULE,\n\tpiobu->chip.get_direction = sama5d2_piobu_get_direction,\n\tpiobu->chip.direction_input = sama5d2_piobu_direction_input,\n\tpiobu->chip.direction_output = sama5d2_piobu_direction_output,\n\tpiobu->chip.get = sama5d2_piobu_get,\n\tpiobu->chip.set = sama5d2_piobu_set,\n\tpiobu->chip.base = -1,\n\tpiobu->chip.ngpio = PIOBU_NUM,\n\tpiobu->chip.can_sleep = 0,\n\n\tpiobu->regmap = syscon_node_to_regmap(pdev->dev.of_node);\n\tif (IS_ERR(piobu->regmap)) {\n\t\tdev_err(&pdev->dev, \"Failed to get syscon regmap %ld\\n\",\n\t\t\tPTR_ERR(piobu->regmap));\n\t\treturn PTR_ERR(piobu->regmap);\n\t}\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &piobu->chip, piobu);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to add gpiochip %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < PIOBU_NUM; ++i) {\n\t\tret = sama5d2_piobu_setup_pin(&piobu->chip, i);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Failed to setup pin: %d %d\\n\",\n\t\t\t\ti, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sama5d2_piobu_ids[] = {\n\t{ .compatible = \"atmel,sama5d2-secumod\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sama5d2_piobu_ids);\n\nstatic struct platform_driver sama5d2_piobu_driver = {\n\t.driver = {\n\t\t.name\t\t= \"sama5d2-piobu\",\n\t\t.of_match_table\t= sama5d2_piobu_ids,\n\t},\n\t.probe = sama5d2_piobu_probe,\n};\n\nmodule_platform_driver(sama5d2_piobu_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"SAMA5D2 PIOBU controller driver\");\nMODULE_AUTHOR(\"Andrei Stefanescu <andrei.stefanescu@microchip.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}