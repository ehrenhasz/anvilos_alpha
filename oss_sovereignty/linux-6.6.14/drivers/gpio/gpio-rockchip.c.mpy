{
  "module_name": "gpio-rockchip.c",
  "hash_id": "6773258eb579bf8d43d4f41a6f8d85ad5894d65a749e1032d9721f7606370d6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-rockchip.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include \"../pinctrl/core.h\"\n#include \"../pinctrl/pinctrl-rockchip.h\"\n\n#define GPIO_TYPE_V1\t\t(0)            \n#define GPIO_TYPE_V2\t\t(0x01000C2B)   \n#define GPIO_TYPE_V2_1\t\t(0x0101157C)   \n\nstatic const struct rockchip_gpio_regs gpio_regs_v1 = {\n\t.port_dr = 0x00,\n\t.port_ddr = 0x04,\n\t.int_en = 0x30,\n\t.int_mask = 0x34,\n\t.int_type = 0x38,\n\t.int_polarity = 0x3c,\n\t.int_status = 0x40,\n\t.int_rawstatus = 0x44,\n\t.debounce = 0x48,\n\t.port_eoi = 0x4c,\n\t.ext_port = 0x50,\n};\n\nstatic const struct rockchip_gpio_regs gpio_regs_v2 = {\n\t.port_dr = 0x00,\n\t.port_ddr = 0x08,\n\t.int_en = 0x10,\n\t.int_mask = 0x18,\n\t.int_type = 0x20,\n\t.int_polarity = 0x28,\n\t.int_bothedge = 0x30,\n\t.int_status = 0x50,\n\t.int_rawstatus = 0x58,\n\t.debounce = 0x38,\n\t.dbclk_div_en = 0x40,\n\t.dbclk_div_con = 0x48,\n\t.port_eoi = 0x60,\n\t.ext_port = 0x70,\n\t.version_id = 0x78,\n};\n\nstatic inline void gpio_writel_v2(u32 val, void __iomem *reg)\n{\n\twritel((val & 0xffff) | 0xffff0000, reg);\n\twritel((val >> 16) | 0xffff0000, reg + 0x4);\n}\n\nstatic inline u32 gpio_readl_v2(void __iomem *reg)\n{\n\treturn readl(reg + 0x4) << 16 | readl(reg);\n}\n\nstatic inline void rockchip_gpio_writel(struct rockchip_pin_bank *bank,\n\t\t\t\t\tu32 value, unsigned int offset)\n{\n\tvoid __iomem *reg = bank->reg_base + offset;\n\n\tif (bank->gpio_type == GPIO_TYPE_V2)\n\t\tgpio_writel_v2(value, reg);\n\telse\n\t\twritel(value, reg);\n}\n\nstatic inline u32 rockchip_gpio_readl(struct rockchip_pin_bank *bank,\n\t\t\t\t      unsigned int offset)\n{\n\tvoid __iomem *reg = bank->reg_base + offset;\n\tu32 value;\n\n\tif (bank->gpio_type == GPIO_TYPE_V2)\n\t\tvalue = gpio_readl_v2(reg);\n\telse\n\t\tvalue = readl(reg);\n\n\treturn value;\n}\n\nstatic inline void rockchip_gpio_writel_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\t    u32 bit, u32 value,\n\t\t\t\t\t    unsigned int offset)\n{\n\tvoid __iomem *reg = bank->reg_base + offset;\n\tu32 data;\n\n\tif (bank->gpio_type == GPIO_TYPE_V2) {\n\t\tif (value)\n\t\t\tdata = BIT(bit % 16) | BIT(bit % 16 + 16);\n\t\telse\n\t\t\tdata = BIT(bit % 16 + 16);\n\t\twritel(data, bit >= 16 ? reg + 0x4 : reg);\n\t} else {\n\t\tdata = readl(reg);\n\t\tdata &= ~BIT(bit);\n\t\tif (value)\n\t\t\tdata |= BIT(bit);\n\t\twritel(data, reg);\n\t}\n}\n\nstatic inline u32 rockchip_gpio_readl_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\t  u32 bit, unsigned int offset)\n{\n\tvoid __iomem *reg = bank->reg_base + offset;\n\tu32 data;\n\n\tif (bank->gpio_type == GPIO_TYPE_V2) {\n\t\tdata = readl(bit >= 16 ? reg + 0x4 : reg);\n\t\tdata >>= bit % 16;\n\t} else {\n\t\tdata = readl(reg);\n\t\tdata >>= bit;\n\t}\n\n\treturn data & (0x1);\n}\n\nstatic int rockchip_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset)\n{\n\tstruct rockchip_pin_bank *bank = gpiochip_get_data(chip);\n\tu32 data;\n\n\tdata = rockchip_gpio_readl_bit(bank, offset, bank->gpio_regs->port_ddr);\n\tif (data)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int rockchip_gpio_set_direction(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset, bool input)\n{\n\tstruct rockchip_pin_bank *bank = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu32 data = input ? 0 : 1;\n\n\n\tif (input)\n\t\tpinctrl_gpio_direction_input(bank->pin_base + offset);\n\telse\n\t\tpinctrl_gpio_direction_output(bank->pin_base + offset);\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\trockchip_gpio_writel_bit(bank, offset, data, bank->gpio_regs->port_ddr);\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n\n\treturn 0;\n}\n\nstatic void rockchip_gpio_set(struct gpio_chip *gc, unsigned int offset,\n\t\t\t      int value)\n{\n\tstruct rockchip_pin_bank *bank = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\trockchip_gpio_writel_bit(bank, offset, value, bank->gpio_regs->port_dr);\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n}\n\nstatic int rockchip_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct rockchip_pin_bank *bank = gpiochip_get_data(gc);\n\tu32 data;\n\n\tdata = readl(bank->reg_base + bank->gpio_regs->ext_port);\n\tdata >>= offset;\n\tdata &= 1;\n\n\treturn data;\n}\n\nstatic int rockchip_gpio_set_debounce(struct gpio_chip *gc,\n\t\t\t\t      unsigned int offset,\n\t\t\t\t      unsigned int debounce)\n{\n\tstruct rockchip_pin_bank *bank = gpiochip_get_data(gc);\n\tconst struct rockchip_gpio_regs\t*reg = bank->gpio_regs;\n\tunsigned long flags, div_reg, freq, max_debounce;\n\tbool div_debounce_support;\n\tunsigned int cur_div_reg;\n\tu64 div;\n\n\tif (bank->gpio_type == GPIO_TYPE_V2 && !IS_ERR(bank->db_clk)) {\n\t\tdiv_debounce_support = true;\n\t\tfreq = clk_get_rate(bank->db_clk);\n\t\tmax_debounce = (GENMASK(23, 0) + 1) * 2 * 1000000 / freq;\n\t\tif (debounce > max_debounce)\n\t\t\treturn -EINVAL;\n\n\t\tdiv = debounce * freq;\n\t\tdiv_reg = DIV_ROUND_CLOSEST_ULL(div, 2 * USEC_PER_SEC) - 1;\n\t} else {\n\t\tdiv_debounce_support = false;\n\t}\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\n\t \n\tif (debounce) {\n\t\tif (div_debounce_support) {\n\t\t\t \n\t\t\tcur_div_reg = readl(bank->reg_base +\n\t\t\t\t\t    reg->dbclk_div_con);\n\t\t\tif (cur_div_reg < div_reg)\n\t\t\t\twritel(div_reg, bank->reg_base +\n\t\t\t\t       reg->dbclk_div_con);\n\t\t\trockchip_gpio_writel_bit(bank, offset, 1,\n\t\t\t\t\t\t reg->dbclk_div_en);\n\t\t}\n\n\t\trockchip_gpio_writel_bit(bank, offset, 1, reg->debounce);\n\t} else {\n\t\tif (div_debounce_support)\n\t\t\trockchip_gpio_writel_bit(bank, offset, 0,\n\t\t\t\t\t\t reg->dbclk_div_en);\n\n\t\trockchip_gpio_writel_bit(bank, offset, 0, reg->debounce);\n\t}\n\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n\n\t \n\tif (div_debounce_support) {\n\t\tif (debounce)\n\t\t\tclk_prepare_enable(bank->db_clk);\n\t\telse\n\t\t\tclk_disable_unprepare(bank->db_clk);\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_gpio_direction_input(struct gpio_chip *gc,\n\t\t\t\t\t unsigned int offset)\n{\n\treturn rockchip_gpio_set_direction(gc, offset, true);\n}\n\nstatic int rockchip_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\t  unsigned int offset, int value)\n{\n\trockchip_gpio_set(gc, offset, value);\n\n\treturn rockchip_gpio_set_direction(gc, offset, false);\n}\n\n \nstatic int rockchip_gpio_set_config(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\t  unsigned long config)\n{\n\tenum pin_config_param param = pinconf_to_config_param(config);\n\n\tswitch (param) {\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\trockchip_gpio_set_debounce(gc, offset, true);\n\t\t \n\t\treturn -ENOTSUPP;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\n \nstatic int rockchip_gpio_to_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct rockchip_pin_bank *bank = gpiochip_get_data(gc);\n\tunsigned int virq;\n\n\tif (!bank->domain)\n\t\treturn -ENXIO;\n\n\tvirq = irq_create_mapping(bank->domain, offset);\n\n\treturn (virq) ? : -ENXIO;\n}\n\nstatic const struct gpio_chip rockchip_gpiolib_chip = {\n\t.request = gpiochip_generic_request,\n\t.free = gpiochip_generic_free,\n\t.set = rockchip_gpio_set,\n\t.get = rockchip_gpio_get,\n\t.get_direction\t= rockchip_gpio_get_direction,\n\t.direction_input = rockchip_gpio_direction_input,\n\t.direction_output = rockchip_gpio_direction_output,\n\t.set_config = rockchip_gpio_set_config,\n\t.to_irq = rockchip_gpio_to_irq,\n\t.owner = THIS_MODULE,\n};\n\nstatic void rockchip_irq_demux(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct rockchip_pin_bank *bank = irq_desc_get_handler_data(desc);\n\tunsigned long pending;\n\tunsigned int irq;\n\n\tdev_dbg(bank->dev, \"got irq for bank %s\\n\", bank->name);\n\n\tchained_irq_enter(chip, desc);\n\n\tpending = readl_relaxed(bank->reg_base + bank->gpio_regs->int_status);\n\tfor_each_set_bit(irq, &pending, 32) {\n\t\tdev_dbg(bank->dev, \"handling irq %d\\n\", irq);\n\n\t\t \n\t\tif (bank->toggle_edge_mode & BIT(irq)) {\n\t\t\tu32 data, data_old, polarity;\n\t\t\tunsigned long flags;\n\n\t\t\tdata = readl_relaxed(bank->reg_base +\n\t\t\t\t\t     bank->gpio_regs->ext_port);\n\t\t\tdo {\n\t\t\t\traw_spin_lock_irqsave(&bank->slock, flags);\n\n\t\t\t\tpolarity = readl_relaxed(bank->reg_base +\n\t\t\t\t\t\t\t bank->gpio_regs->int_polarity);\n\t\t\t\tif (data & BIT(irq))\n\t\t\t\t\tpolarity &= ~BIT(irq);\n\t\t\t\telse\n\t\t\t\t\tpolarity |= BIT(irq);\n\t\t\t\twritel(polarity,\n\t\t\t\t       bank->reg_base +\n\t\t\t\t       bank->gpio_regs->int_polarity);\n\n\t\t\t\traw_spin_unlock_irqrestore(&bank->slock, flags);\n\n\t\t\t\tdata_old = data;\n\t\t\t\tdata = readl_relaxed(bank->reg_base +\n\t\t\t\t\t\t     bank->gpio_regs->ext_port);\n\t\t\t} while ((data & BIT(irq)) != (data_old & BIT(irq)));\n\t\t}\n\n\t\tgeneric_handle_domain_irq(bank->domain, irq);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int rockchip_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct rockchip_pin_bank *bank = gc->private;\n\tu32 mask = BIT(d->hwirq);\n\tu32 polarity;\n\tu32 level;\n\tu32 data;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\n\trockchip_gpio_writel_bit(bank, d->hwirq, 0,\n\t\t\t\t bank->gpio_regs->port_ddr);\n\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\telse\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\n\tlevel = rockchip_gpio_readl(bank, bank->gpio_regs->int_type);\n\tpolarity = rockchip_gpio_readl(bank, bank->gpio_regs->int_polarity);\n\n\tif (type == IRQ_TYPE_EDGE_BOTH) {\n\t\tif (bank->gpio_type == GPIO_TYPE_V2) {\n\t\t\trockchip_gpio_writel_bit(bank, d->hwirq, 1,\n\t\t\t\t\t\t bank->gpio_regs->int_bothedge);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tbank->toggle_edge_mode |= mask;\n\t\t\tlevel &= ~mask;\n\n\t\t\t \n\t\t\tdata = readl(bank->reg_base + bank->gpio_regs->ext_port);\n\t\t\tif (data & mask)\n\t\t\t\tpolarity &= ~mask;\n\t\t\telse\n\t\t\t\tpolarity |= mask;\n\t\t}\n\t} else {\n\t\tif (bank->gpio_type == GPIO_TYPE_V2) {\n\t\t\trockchip_gpio_writel_bit(bank, d->hwirq, 0,\n\t\t\t\t\t\t bank->gpio_regs->int_bothedge);\n\t\t} else {\n\t\t\tbank->toggle_edge_mode &= ~mask;\n\t\t}\n\t\tswitch (type) {\n\t\tcase IRQ_TYPE_EDGE_RISING:\n\t\t\tlevel |= mask;\n\t\t\tpolarity |= mask;\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_EDGE_FALLING:\n\t\t\tlevel |= mask;\n\t\t\tpolarity &= ~mask;\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\t\tlevel &= ~mask;\n\t\t\tpolarity |= mask;\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_LEVEL_LOW:\n\t\t\tlevel &= ~mask;\n\t\t\tpolarity &= ~mask;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trockchip_gpio_writel(bank, level, bank->gpio_regs->int_type);\n\trockchip_gpio_writel(bank, polarity, bank->gpio_regs->int_polarity);\nout:\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n\n\treturn ret;\n}\n\nstatic int rockchip_irq_reqres(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct rockchip_pin_bank *bank = gc->private;\n\n\treturn gpiochip_reqres_irq(&bank->gpio_chip, d->hwirq);\n}\n\nstatic void rockchip_irq_relres(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct rockchip_pin_bank *bank = gc->private;\n\n\tgpiochip_relres_irq(&bank->gpio_chip, d->hwirq);\n}\n\nstatic void rockchip_irq_suspend(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct rockchip_pin_bank *bank = gc->private;\n\n\tbank->saved_masks = irq_reg_readl(gc, bank->gpio_regs->int_mask);\n\tirq_reg_writel(gc, ~gc->wake_active, bank->gpio_regs->int_mask);\n}\n\nstatic void rockchip_irq_resume(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct rockchip_pin_bank *bank = gc->private;\n\n\tirq_reg_writel(gc, bank->saved_masks, bank->gpio_regs->int_mask);\n}\n\nstatic void rockchip_irq_enable(struct irq_data *d)\n{\n\tirq_gc_mask_clr_bit(d);\n}\n\nstatic void rockchip_irq_disable(struct irq_data *d)\n{\n\tirq_gc_mask_set_bit(d);\n}\n\nstatic int rockchip_interrupts_register(struct rockchip_pin_bank *bank)\n{\n\tunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\n\tstruct irq_chip_generic *gc;\n\tint ret;\n\n\tbank->domain = irq_domain_add_linear(bank->of_node, 32,\n\t\t\t\t\t&irq_generic_chip_ops, NULL);\n\tif (!bank->domain) {\n\t\tdev_warn(bank->dev, \"could not init irq domain for bank %s\\n\",\n\t\t\t bank->name);\n\t\treturn -EINVAL;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(bank->domain, 32, 1,\n\t\t\t\t\t     \"rockchip_gpio_irq\",\n\t\t\t\t\t     handle_level_irq,\n\t\t\t\t\t     clr, 0, 0);\n\tif (ret) {\n\t\tdev_err(bank->dev, \"could not alloc generic chips for bank %s\\n\",\n\t\t\tbank->name);\n\t\tirq_domain_remove(bank->domain);\n\t\treturn -EINVAL;\n\t}\n\n\tgc = irq_get_domain_generic_chip(bank->domain, 0);\n\tif (bank->gpio_type == GPIO_TYPE_V2) {\n\t\tgc->reg_writel = gpio_writel_v2;\n\t\tgc->reg_readl = gpio_readl_v2;\n\t}\n\n\tgc->reg_base = bank->reg_base;\n\tgc->private = bank;\n\tgc->chip_types[0].regs.mask = bank->gpio_regs->int_mask;\n\tgc->chip_types[0].regs.ack = bank->gpio_regs->port_eoi;\n\tgc->chip_types[0].chip.irq_ack = irq_gc_ack_set_bit;\n\tgc->chip_types[0].chip.irq_mask = irq_gc_mask_set_bit;\n\tgc->chip_types[0].chip.irq_unmask = irq_gc_mask_clr_bit;\n\tgc->chip_types[0].chip.irq_enable = rockchip_irq_enable;\n\tgc->chip_types[0].chip.irq_disable = rockchip_irq_disable;\n\tgc->chip_types[0].chip.irq_set_wake = irq_gc_set_wake;\n\tgc->chip_types[0].chip.irq_suspend = rockchip_irq_suspend;\n\tgc->chip_types[0].chip.irq_resume = rockchip_irq_resume;\n\tgc->chip_types[0].chip.irq_set_type = rockchip_irq_set_type;\n\tgc->chip_types[0].chip.irq_request_resources = rockchip_irq_reqres;\n\tgc->chip_types[0].chip.irq_release_resources = rockchip_irq_relres;\n\tgc->wake_enabled = IRQ_MSK(bank->nr_pins);\n\n\t \n\trockchip_gpio_writel(bank, 0xffffffff, bank->gpio_regs->int_mask);\n\trockchip_gpio_writel(bank, 0xffffffff, bank->gpio_regs->port_eoi);\n\trockchip_gpio_writel(bank, 0xffffffff, bank->gpio_regs->int_en);\n\tgc->mask_cache = 0xffffffff;\n\n\tirq_set_chained_handler_and_data(bank->irq,\n\t\t\t\t\t rockchip_irq_demux, bank);\n\n\treturn 0;\n}\n\nstatic int rockchip_gpiolib_register(struct rockchip_pin_bank *bank)\n{\n\tstruct gpio_chip *gc;\n\tint ret;\n\n\tbank->gpio_chip = rockchip_gpiolib_chip;\n\n\tgc = &bank->gpio_chip;\n\tgc->base = bank->pin_base;\n\tgc->ngpio = bank->nr_pins;\n\tgc->label = bank->name;\n\tgc->parent = bank->dev;\n\n\tret = gpiochip_add_data(gc, bank);\n\tif (ret) {\n\t\tdev_err(bank->dev, \"failed to add gpiochip %s, %d\\n\",\n\t\t\tgc->label, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!of_property_read_bool(bank->of_node, \"gpio-ranges\")) {\n\t\tstruct device_node *pctlnp = of_get_parent(bank->of_node);\n\t\tstruct pinctrl_dev *pctldev = NULL;\n\n\t\tif (!pctlnp)\n\t\t\treturn -ENODATA;\n\n\t\tpctldev = of_pinctrl_get(pctlnp);\n\t\tof_node_put(pctlnp);\n\t\tif (!pctldev)\n\t\t\treturn -ENODEV;\n\n\t\tret = gpiochip_add_pin_range(gc, dev_name(pctldev->dev), 0,\n\t\t\t\t\t     gc->base, gc->ngpio);\n\t\tif (ret) {\n\t\t\tdev_err(bank->dev, \"Failed to add pin range\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tret = rockchip_interrupts_register(bank);\n\tif (ret) {\n\t\tdev_err(bank->dev, \"failed to register interrupt, %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tgpiochip_remove(&bank->gpio_chip);\n\n\treturn ret;\n}\n\nstatic int rockchip_get_bank_data(struct rockchip_pin_bank *bank)\n{\n\tstruct resource res;\n\tint id = 0;\n\n\tif (of_address_to_resource(bank->of_node, 0, &res)) {\n\t\tdev_err(bank->dev, \"cannot find IO resource for bank\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tbank->reg_base = devm_ioremap_resource(bank->dev, &res);\n\tif (IS_ERR(bank->reg_base))\n\t\treturn PTR_ERR(bank->reg_base);\n\n\tbank->irq = irq_of_parse_and_map(bank->of_node, 0);\n\tif (!bank->irq)\n\t\treturn -EINVAL;\n\n\tbank->clk = of_clk_get(bank->of_node, 0);\n\tif (IS_ERR(bank->clk))\n\t\treturn PTR_ERR(bank->clk);\n\n\tclk_prepare_enable(bank->clk);\n\tid = readl(bank->reg_base + gpio_regs_v2.version_id);\n\n\t \n\tif (id == GPIO_TYPE_V2 || id == GPIO_TYPE_V2_1) {\n\t\tbank->gpio_regs = &gpio_regs_v2;\n\t\tbank->gpio_type = GPIO_TYPE_V2;\n\t\tbank->db_clk = of_clk_get(bank->of_node, 1);\n\t\tif (IS_ERR(bank->db_clk)) {\n\t\t\tdev_err(bank->dev, \"cannot find debounce clk\\n\");\n\t\t\tclk_disable_unprepare(bank->clk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tbank->gpio_regs = &gpio_regs_v1;\n\t\tbank->gpio_type = GPIO_TYPE_V1;\n\t}\n\n\treturn 0;\n}\n\nstatic struct rockchip_pin_bank *\nrockchip_gpio_find_bank(struct pinctrl_dev *pctldev, int id)\n{\n\tstruct rockchip_pinctrl *info;\n\tstruct rockchip_pin_bank *bank;\n\tint i, found = 0;\n\n\tinfo = pinctrl_dev_get_drvdata(pctldev);\n\tbank = info->ctrl->pin_banks;\n\tfor (i = 0; i < info->ctrl->nr_banks; i++, bank++) {\n\t\tif (bank->bank_num == id) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found ? bank : NULL;\n}\n\nstatic int rockchip_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *pctlnp = of_get_parent(np);\n\tstruct pinctrl_dev *pctldev = NULL;\n\tstruct rockchip_pin_bank *bank = NULL;\n\tstruct rockchip_pin_deferred *cfg;\n\tstatic int gpio;\n\tint id, ret;\n\n\tif (!np || !pctlnp)\n\t\treturn -ENODEV;\n\n\tpctldev = of_pinctrl_get(pctlnp);\n\tif (!pctldev)\n\t\treturn -EPROBE_DEFER;\n\n\tid = of_alias_get_id(np, \"gpio\");\n\tif (id < 0)\n\t\tid = gpio++;\n\n\tbank = rockchip_gpio_find_bank(pctldev, id);\n\tif (!bank)\n\t\treturn -EINVAL;\n\n\tbank->dev = dev;\n\tbank->of_node = np;\n\n\traw_spin_lock_init(&bank->slock);\n\n\tret = rockchip_get_bank_data(bank);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmutex_lock(&bank->deferred_lock);\n\n\tret = rockchip_gpiolib_register(bank);\n\tif (ret) {\n\t\tclk_disable_unprepare(bank->clk);\n\t\tmutex_unlock(&bank->deferred_lock);\n\t\treturn ret;\n\t}\n\n\twhile (!list_empty(&bank->deferred_pins)) {\n\t\tcfg = list_first_entry(&bank->deferred_pins,\n\t\t\t\t       struct rockchip_pin_deferred, head);\n\t\tlist_del(&cfg->head);\n\n\t\tswitch (cfg->param) {\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tret = rockchip_gpio_direction_output(&bank->gpio_chip, cfg->pin, cfg->arg);\n\t\t\tif (ret)\n\t\t\t\tdev_warn(dev, \"setting output pin %u to %u failed\\n\", cfg->pin,\n\t\t\t\t\t cfg->arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\tret = rockchip_gpio_direction_input(&bank->gpio_chip, cfg->pin);\n\t\t\tif (ret)\n\t\t\t\tdev_warn(dev, \"setting input pin %u failed\\n\", cfg->pin);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(dev, \"unknown deferred config param %d\\n\", cfg->param);\n\t\t\tbreak;\n\t\t}\n\t\tkfree(cfg);\n\t}\n\n\tmutex_unlock(&bank->deferred_lock);\n\n\tplatform_set_drvdata(pdev, bank);\n\tdev_info(dev, \"probed %pOF\\n\", np);\n\n\treturn 0;\n}\n\nstatic int rockchip_gpio_remove(struct platform_device *pdev)\n{\n\tstruct rockchip_pin_bank *bank = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(bank->clk);\n\tgpiochip_remove(&bank->gpio_chip);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rockchip_gpio_match[] = {\n\t{ .compatible = \"rockchip,gpio-bank\", },\n\t{ .compatible = \"rockchip,rk3188-gpio-bank0\" },\n\t{ },\n};\n\nstatic struct platform_driver rockchip_gpio_driver = {\n\t.probe\t\t= rockchip_gpio_probe,\n\t.remove\t\t= rockchip_gpio_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"rockchip-gpio\",\n\t\t.of_match_table = rockchip_gpio_match,\n\t},\n};\n\nstatic int __init rockchip_gpio_init(void)\n{\n\treturn platform_driver_register(&rockchip_gpio_driver);\n}\npostcore_initcall(rockchip_gpio_init);\n\nstatic void __exit rockchip_gpio_exit(void)\n{\n\tplatform_driver_unregister(&rockchip_gpio_driver);\n}\nmodule_exit(rockchip_gpio_exit);\n\nMODULE_DESCRIPTION(\"Rockchip gpio driver\");\nMODULE_ALIAS(\"platform:rockchip-gpio\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(of, rockchip_gpio_match);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}