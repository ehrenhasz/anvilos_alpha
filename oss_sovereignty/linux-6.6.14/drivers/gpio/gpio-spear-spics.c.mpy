{
  "module_name": "gpio-spear-spics.c",
  "hash_id": "2e8b3b7a350d37bb442b467820bd289aaa0e53ae05ba6e07382b1e79b3c116cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-spear-spics.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n \n#define NUM_OF_GPIO\t4\n\n \n\n \nstruct spear_spics {\n\tvoid __iomem\t\t*base;\n\tu32\t\t\tperip_cfg;\n\tu32\t\t\tsw_enable_bit;\n\tu32\t\t\tcs_value_bit;\n\tu32\t\t\tcs_enable_mask;\n\tu32\t\t\tcs_enable_shift;\n\tunsigned long\t\tuse_count;\n\tint\t\t\tlast_off;\n\tstruct gpio_chip\tchip;\n};\n\n \nstatic int spics_get_value(struct gpio_chip *chip, unsigned offset)\n{\n\treturn -ENXIO;\n}\n\nstatic void spics_set_value(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct spear_spics *spics = gpiochip_get_data(chip);\n\tu32 tmp;\n\n\t \n\ttmp = readl_relaxed(spics->base + spics->perip_cfg);\n\tif (spics->last_off != offset) {\n\t\tspics->last_off = offset;\n\t\ttmp &= ~(spics->cs_enable_mask << spics->cs_enable_shift);\n\t\ttmp |= offset << spics->cs_enable_shift;\n\t}\n\n\t \n\ttmp &= ~(0x1 << spics->cs_value_bit);\n\ttmp |= value << spics->cs_value_bit;\n\twritel_relaxed(tmp, spics->base + spics->perip_cfg);\n}\n\nstatic int spics_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\treturn -ENXIO;\n}\n\nstatic int spics_direction_output(struct gpio_chip *chip, unsigned offset,\n\t\tint value)\n{\n\tspics_set_value(chip, offset, value);\n\treturn 0;\n}\n\nstatic int spics_request(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct spear_spics *spics = gpiochip_get_data(chip);\n\tu32 tmp;\n\n\tif (!spics->use_count++) {\n\t\ttmp = readl_relaxed(spics->base + spics->perip_cfg);\n\t\ttmp |= 0x1 << spics->sw_enable_bit;\n\t\ttmp |= 0x1 << spics->cs_value_bit;\n\t\twritel_relaxed(tmp, spics->base + spics->perip_cfg);\n\t}\n\n\treturn 0;\n}\n\nstatic void spics_free(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct spear_spics *spics = gpiochip_get_data(chip);\n\tu32 tmp;\n\n\tif (!--spics->use_count) {\n\t\ttmp = readl_relaxed(spics->base + spics->perip_cfg);\n\t\ttmp &= ~(0x1 << spics->sw_enable_bit);\n\t\twritel_relaxed(tmp, spics->base + spics->perip_cfg);\n\t}\n}\n\nstatic int spics_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct spear_spics *spics;\n\n\tspics = devm_kzalloc(&pdev->dev, sizeof(*spics), GFP_KERNEL);\n\tif (!spics)\n\t\treturn -ENOMEM;\n\n\tspics->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(spics->base))\n\t\treturn PTR_ERR(spics->base);\n\n\tif (of_property_read_u32(np, \"st-spics,peripcfg-reg\",\n\t\t\t\t&spics->perip_cfg))\n\t\tgoto err_dt_data;\n\tif (of_property_read_u32(np, \"st-spics,sw-enable-bit\",\n\t\t\t\t&spics->sw_enable_bit))\n\t\tgoto err_dt_data;\n\tif (of_property_read_u32(np, \"st-spics,cs-value-bit\",\n\t\t\t\t&spics->cs_value_bit))\n\t\tgoto err_dt_data;\n\tif (of_property_read_u32(np, \"st-spics,cs-enable-mask\",\n\t\t\t\t&spics->cs_enable_mask))\n\t\tgoto err_dt_data;\n\tif (of_property_read_u32(np, \"st-spics,cs-enable-shift\",\n\t\t\t\t&spics->cs_enable_shift))\n\t\tgoto err_dt_data;\n\n\tspics->chip.ngpio = NUM_OF_GPIO;\n\tspics->chip.base = -1;\n\tspics->chip.request = spics_request;\n\tspics->chip.free = spics_free;\n\tspics->chip.direction_input = spics_direction_input;\n\tspics->chip.direction_output = spics_direction_output;\n\tspics->chip.get = spics_get_value;\n\tspics->chip.set = spics_set_value;\n\tspics->chip.label = dev_name(&pdev->dev);\n\tspics->chip.parent = &pdev->dev;\n\tspics->chip.owner = THIS_MODULE;\n\tspics->last_off = -1;\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &spics->chip, spics);\n\nerr_dt_data:\n\tdev_err(&pdev->dev, \"DT probe failed\\n\");\n\treturn -EINVAL;\n}\n\nstatic const struct of_device_id spics_gpio_of_match[] = {\n\t{ .compatible = \"st,spear-spics-gpio\" },\n\t{}\n};\n\nstatic struct platform_driver spics_gpio_driver = {\n\t.probe = spics_gpio_probe,\n\t.driver = {\n\t\t.name = \"spear-spics-gpio\",\n\t\t.of_match_table = spics_gpio_of_match,\n\t},\n};\n\nstatic int __init spics_gpio_init(void)\n{\n\treturn platform_driver_register(&spics_gpio_driver);\n}\nsubsys_initcall(spics_gpio_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}