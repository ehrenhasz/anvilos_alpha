{
  "module_name": "gpio-palmas.c",
  "hash_id": "f45a514f8c1b5ba26fdf2c34a3b7ba9e900e92bdaf09723ff903a0574861e3c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-palmas.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/mfd/palmas.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\nstruct palmas_gpio {\n\tstruct gpio_chip gpio_chip;\n\tstruct palmas *palmas;\n};\n\nstruct palmas_device_data {\n\tint ngpio;\n};\n\nstatic int palmas_gpio_get(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct palmas_gpio *pg = gpiochip_get_data(gc);\n\tstruct palmas *palmas = pg->palmas;\n\tunsigned int val;\n\tint ret;\n\tunsigned int reg;\n\tint gpio16 = (offset/8);\n\n\toffset %= 8;\n\treg = (gpio16) ? PALMAS_GPIO_DATA_DIR2 : PALMAS_GPIO_DATA_DIR;\n\n\tret = palmas_read(palmas, PALMAS_GPIO_BASE, reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(gc->parent, \"Reg 0x%02x read failed, %d\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\tif (val & BIT(offset))\n\t\treg = (gpio16) ? PALMAS_GPIO_DATA_OUT2 : PALMAS_GPIO_DATA_OUT;\n\telse\n\t\treg = (gpio16) ? PALMAS_GPIO_DATA_IN2 : PALMAS_GPIO_DATA_IN;\n\n\tret = palmas_read(palmas, PALMAS_GPIO_BASE, reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(gc->parent, \"Reg 0x%02x read failed, %d\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\treturn !!(val & BIT(offset));\n}\n\nstatic void palmas_gpio_set(struct gpio_chip *gc, unsigned offset,\n\t\t\tint value)\n{\n\tstruct palmas_gpio *pg = gpiochip_get_data(gc);\n\tstruct palmas *palmas = pg->palmas;\n\tint ret;\n\tunsigned int reg;\n\tint gpio16 = (offset/8);\n\n\toffset %= 8;\n\tif (gpio16)\n\t\treg = (value) ?\n\t\t\tPALMAS_GPIO_SET_DATA_OUT2 : PALMAS_GPIO_CLEAR_DATA_OUT2;\n\telse\n\t\treg = (value) ?\n\t\t\tPALMAS_GPIO_SET_DATA_OUT : PALMAS_GPIO_CLEAR_DATA_OUT;\n\n\tret = palmas_write(palmas, PALMAS_GPIO_BASE, reg, BIT(offset));\n\tif (ret < 0)\n\t\tdev_err(gc->parent, \"Reg 0x%02x write failed, %d\\n\", reg, ret);\n}\n\nstatic int palmas_gpio_output(struct gpio_chip *gc, unsigned offset,\n\t\t\t\tint value)\n{\n\tstruct palmas_gpio *pg = gpiochip_get_data(gc);\n\tstruct palmas *palmas = pg->palmas;\n\tint ret;\n\tunsigned int reg;\n\tint gpio16 = (offset/8);\n\n\toffset %= 8;\n\treg = (gpio16) ? PALMAS_GPIO_DATA_DIR2 : PALMAS_GPIO_DATA_DIR;\n\n\t \n\tpalmas_gpio_set(gc, offset, value);\n\n\tret = palmas_update_bits(palmas, PALMAS_GPIO_BASE, reg,\n\t\t\t\tBIT(offset), BIT(offset));\n\tif (ret < 0)\n\t\tdev_err(gc->parent, \"Reg 0x%02x update failed, %d\\n\", reg,\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int palmas_gpio_input(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct palmas_gpio *pg = gpiochip_get_data(gc);\n\tstruct palmas *palmas = pg->palmas;\n\tint ret;\n\tunsigned int reg;\n\tint gpio16 = (offset/8);\n\n\toffset %= 8;\n\treg = (gpio16) ? PALMAS_GPIO_DATA_DIR2 : PALMAS_GPIO_DATA_DIR;\n\n\tret = palmas_update_bits(palmas, PALMAS_GPIO_BASE, reg, BIT(offset), 0);\n\tif (ret < 0)\n\t\tdev_err(gc->parent, \"Reg 0x%02x update failed, %d\\n\", reg,\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int palmas_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct palmas_gpio *pg = gpiochip_get_data(gc);\n\tstruct palmas *palmas = pg->palmas;\n\n\treturn palmas_irq_get_virq(palmas, PALMAS_GPIO_0_IRQ + offset);\n}\n\nstatic const struct palmas_device_data palmas_dev_data = {\n\t.ngpio = 8,\n};\n\nstatic const struct palmas_device_data tps80036_dev_data = {\n\t.ngpio = 16,\n};\n\nstatic const struct of_device_id of_palmas_gpio_match[] = {\n\t{ .compatible = \"ti,palmas-gpio\", .data = &palmas_dev_data,},\n\t{ .compatible = \"ti,tps65913-gpio\", .data = &palmas_dev_data,},\n\t{ .compatible = \"ti,tps65914-gpio\", .data = &palmas_dev_data,},\n\t{ .compatible = \"ti,tps80036-gpio\", .data = &tps80036_dev_data,},\n\t{ },\n};\n\nstatic int palmas_gpio_probe(struct platform_device *pdev)\n{\n\tstruct palmas *palmas = dev_get_drvdata(pdev->dev.parent);\n\tstruct palmas_platform_data *palmas_pdata;\n\tstruct palmas_gpio *palmas_gpio;\n\tint ret;\n\tconst struct palmas_device_data *dev_data;\n\n\tdev_data = of_device_get_match_data(&pdev->dev);\n\tif (!dev_data)\n\t\tdev_data = &palmas_dev_data;\n\n\tpalmas_gpio = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(*palmas_gpio), GFP_KERNEL);\n\tif (!palmas_gpio)\n\t\treturn -ENOMEM;\n\n\tpalmas_gpio->palmas = palmas;\n\tpalmas_gpio->gpio_chip.owner = THIS_MODULE;\n\tpalmas_gpio->gpio_chip.label = dev_name(&pdev->dev);\n\tpalmas_gpio->gpio_chip.ngpio = dev_data->ngpio;\n\tpalmas_gpio->gpio_chip.can_sleep = true;\n\tpalmas_gpio->gpio_chip.direction_input = palmas_gpio_input;\n\tpalmas_gpio->gpio_chip.direction_output = palmas_gpio_output;\n\tpalmas_gpio->gpio_chip.to_irq = palmas_gpio_to_irq;\n\tpalmas_gpio->gpio_chip.set\t= palmas_gpio_set;\n\tpalmas_gpio->gpio_chip.get\t= palmas_gpio_get;\n\tpalmas_gpio->gpio_chip.parent = &pdev->dev;\n\n\tpalmas_pdata = dev_get_platdata(palmas->dev);\n\tif (palmas_pdata && palmas_pdata->gpio_base)\n\t\tpalmas_gpio->gpio_chip.base = palmas_pdata->gpio_base;\n\telse\n\t\tpalmas_gpio->gpio_chip.base = -1;\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &palmas_gpio->gpio_chip,\n\t\t\t\t     palmas_gpio);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Could not register gpiochip, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic struct platform_driver palmas_gpio_driver = {\n\t.driver.name\t= \"palmas-gpio\",\n\t.driver.of_match_table = of_palmas_gpio_match,\n\t.probe\t\t= palmas_gpio_probe,\n};\n\nstatic int __init palmas_gpio_init(void)\n{\n\treturn platform_driver_register(&palmas_gpio_driver);\n}\nsubsys_initcall(palmas_gpio_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}