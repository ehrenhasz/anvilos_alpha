{
  "module_name": "gpio-tegra186.c",
  "hash_id": "868ae6a264bad0eb1de7f27f601137a82b09f80d681e59758ba15e6e00fa477e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-tegra186.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/hte.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n\n#include <dt-bindings/gpio/tegra186-gpio.h>\n#include <dt-bindings/gpio/tegra194-gpio.h>\n#include <dt-bindings/gpio/tegra234-gpio.h>\n#include <dt-bindings/gpio/tegra241-gpio.h>\n\n \n#define TEGRA186_GPIO_CTL_SCR 0x0c\n#define  TEGRA186_GPIO_CTL_SCR_SEC_WEN BIT(28)\n#define  TEGRA186_GPIO_CTL_SCR_SEC_REN BIT(27)\n\n#define TEGRA186_GPIO_INT_ROUTE_MAPPING(p, x) (0x14 + (p) * 0x20 + (x) * 4)\n\n#define  TEGRA186_GPIO_VM\t\t\t0x00\n#define  TEGRA186_GPIO_VM_RW_MASK\t\t0x03\n#define  TEGRA186_GPIO_SCR\t\t\t0x04\n#define  TEGRA186_GPIO_SCR_PIN_SIZE\t\t0x08\n#define  TEGRA186_GPIO_SCR_PORT_SIZE\t\t0x40\n#define  TEGRA186_GPIO_SCR_SEC_WEN\t\tBIT(28)\n#define  TEGRA186_GPIO_SCR_SEC_REN\t\tBIT(27)\n#define  TEGRA186_GPIO_SCR_SEC_G1W\t\tBIT(9)\n#define  TEGRA186_GPIO_SCR_SEC_G1R\t\tBIT(1)\n#define  TEGRA186_GPIO_FULL_ACCESS\t\t(TEGRA186_GPIO_SCR_SEC_WEN | \\\n\t\t\t\t\t\t TEGRA186_GPIO_SCR_SEC_REN | \\\n\t\t\t\t\t\t TEGRA186_GPIO_SCR_SEC_G1R | \\\n\t\t\t\t\t\t TEGRA186_GPIO_SCR_SEC_G1W)\n#define  TEGRA186_GPIO_SCR_SEC_ENABLE\t\t(TEGRA186_GPIO_SCR_SEC_WEN | \\\n\t\t\t\t\t\t TEGRA186_GPIO_SCR_SEC_REN)\n\n \n#define TEGRA186_GPIO_ENABLE_CONFIG 0x00\n#define  TEGRA186_GPIO_ENABLE_CONFIG_ENABLE BIT(0)\n#define  TEGRA186_GPIO_ENABLE_CONFIG_OUT BIT(1)\n#define  TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_NONE (0x0 << 2)\n#define  TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_LEVEL (0x1 << 2)\n#define  TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_SINGLE_EDGE (0x2 << 2)\n#define  TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_DOUBLE_EDGE (0x3 << 2)\n#define  TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_MASK (0x3 << 2)\n#define  TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_LEVEL BIT(4)\n#define  TEGRA186_GPIO_ENABLE_CONFIG_DEBOUNCE BIT(5)\n#define  TEGRA186_GPIO_ENABLE_CONFIG_INTERRUPT BIT(6)\n#define  TEGRA186_GPIO_ENABLE_CONFIG_TIMESTAMP_FUNC BIT(7)\n\n#define TEGRA186_GPIO_DEBOUNCE_CONTROL 0x04\n#define  TEGRA186_GPIO_DEBOUNCE_CONTROL_THRESHOLD(x) ((x) & 0xff)\n\n#define TEGRA186_GPIO_INPUT 0x08\n#define  TEGRA186_GPIO_INPUT_HIGH BIT(0)\n\n#define TEGRA186_GPIO_OUTPUT_CONTROL 0x0c\n#define  TEGRA186_GPIO_OUTPUT_CONTROL_FLOATED BIT(0)\n\n#define TEGRA186_GPIO_OUTPUT_VALUE 0x10\n#define  TEGRA186_GPIO_OUTPUT_VALUE_HIGH BIT(0)\n\n#define TEGRA186_GPIO_INTERRUPT_CLEAR 0x14\n\n#define TEGRA186_GPIO_INTERRUPT_STATUS(x) (0x100 + (x) * 4)\n\nstruct tegra_gpio_port {\n\tconst char *name;\n\tunsigned int bank;\n\tunsigned int port;\n\tunsigned int pins;\n};\n\nstruct tegra186_pin_range {\n\tunsigned int offset;\n\tconst char *group;\n};\n\nstruct tegra_gpio_soc {\n\tconst struct tegra_gpio_port *ports;\n\tunsigned int num_ports;\n\tconst char *name;\n\tunsigned int instance;\n\n\tunsigned int num_irqs_per_bank;\n\n\tconst struct tegra186_pin_range *pin_ranges;\n\tunsigned int num_pin_ranges;\n\tconst char *pinmux;\n\tbool has_gte;\n\tbool has_vm_support;\n};\n\nstruct tegra_gpio {\n\tstruct gpio_chip gpio;\n\tunsigned int num_irq;\n\tunsigned int *irq;\n\n\tconst struct tegra_gpio_soc *soc;\n\tunsigned int num_irqs_per_bank;\n\tunsigned int num_banks;\n\n\tvoid __iomem *secure;\n\tvoid __iomem *base;\n};\n\nstatic const struct tegra_gpio_port *\ntegra186_gpio_get_port(struct tegra_gpio *gpio, unsigned int *pin)\n{\n\tunsigned int start = 0, i;\n\n\tfor (i = 0; i < gpio->soc->num_ports; i++) {\n\t\tconst struct tegra_gpio_port *port = &gpio->soc->ports[i];\n\n\t\tif (*pin >= start && *pin < start + port->pins) {\n\t\t\t*pin -= start;\n\t\t\treturn port;\n\t\t}\n\n\t\tstart += port->pins;\n\t}\n\n\treturn NULL;\n}\n\nstatic void __iomem *tegra186_gpio_get_base(struct tegra_gpio *gpio,\n\t\t\t\t\t    unsigned int pin)\n{\n\tconst struct tegra_gpio_port *port;\n\tunsigned int offset;\n\n\tport = tegra186_gpio_get_port(gpio, &pin);\n\tif (!port)\n\t\treturn NULL;\n\n\toffset = port->bank * 0x1000 + port->port * 0x200;\n\n\treturn gpio->base + offset + pin * 0x20;\n}\n\nstatic void __iomem *tegra186_gpio_get_secure_base(struct tegra_gpio *gpio,\n\t\t\t\t\t\t   unsigned int pin)\n{\n\tconst struct tegra_gpio_port *port;\n\tunsigned int offset;\n\n\tport = tegra186_gpio_get_port(gpio, &pin);\n\tif (!port)\n\t\treturn NULL;\n\n\toffset = port->bank * 0x1000 + port->port * TEGRA186_GPIO_SCR_PORT_SIZE;\n\n\treturn gpio->secure + offset + pin * TEGRA186_GPIO_SCR_PIN_SIZE;\n}\n\nstatic inline bool tegra186_gpio_is_accessible(struct tegra_gpio *gpio, unsigned int pin)\n{\n\tvoid __iomem *secure;\n\tu32 value;\n\n\tsecure = tegra186_gpio_get_secure_base(gpio, pin);\n\n\tif (gpio->soc->has_vm_support) {\n\t\tvalue = readl(secure + TEGRA186_GPIO_VM);\n\t\tif ((value & TEGRA186_GPIO_VM_RW_MASK) != TEGRA186_GPIO_VM_RW_MASK)\n\t\t\treturn false;\n\t}\n\n\tvalue = __raw_readl(secure + TEGRA186_GPIO_SCR);\n\n\tif ((value & TEGRA186_GPIO_SCR_SEC_ENABLE) == 0)\n\t\treturn true;\n\n\tif ((value & TEGRA186_GPIO_FULL_ACCESS) == TEGRA186_GPIO_FULL_ACCESS)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int tegra186_init_valid_mask(struct gpio_chip *chip,\n\t\t\t\t    unsigned long *valid_mask, unsigned int ngpios)\n{\n\tstruct tegra_gpio *gpio = gpiochip_get_data(chip);\n\tunsigned int j;\n\n\tfor (j = 0; j < ngpios; j++) {\n\t\tif (!tegra186_gpio_is_accessible(gpio, j))\n\t\t\tclear_bit(j, valid_mask);\n\t}\n\treturn 0;\n}\n\nstatic int tegra186_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset)\n{\n\tstruct tegra_gpio *gpio = gpiochip_get_data(chip);\n\tvoid __iomem *base;\n\tu32 value;\n\n\tbase = tegra186_gpio_get_base(gpio, offset);\n\tif (WARN_ON(base == NULL))\n\t\treturn -ENODEV;\n\n\tvalue = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);\n\tif (value & TEGRA186_GPIO_ENABLE_CONFIG_OUT)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int tegra186_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t\t unsigned int offset)\n{\n\tstruct tegra_gpio *gpio = gpiochip_get_data(chip);\n\tvoid __iomem *base;\n\tu32 value;\n\n\tbase = tegra186_gpio_get_base(gpio, offset);\n\tif (WARN_ON(base == NULL))\n\t\treturn -ENODEV;\n\n\tvalue = readl(base + TEGRA186_GPIO_OUTPUT_CONTROL);\n\tvalue |= TEGRA186_GPIO_OUTPUT_CONTROL_FLOATED;\n\twritel(value, base + TEGRA186_GPIO_OUTPUT_CONTROL);\n\n\tvalue = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);\n\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_ENABLE;\n\tvalue &= ~TEGRA186_GPIO_ENABLE_CONFIG_OUT;\n\twritel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);\n\n\treturn 0;\n}\n\nstatic int tegra186_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t  unsigned int offset, int level)\n{\n\tstruct tegra_gpio *gpio = gpiochip_get_data(chip);\n\tvoid __iomem *base;\n\tu32 value;\n\n\t \n\tchip->set(chip, offset, level);\n\n\tbase = tegra186_gpio_get_base(gpio, offset);\n\tif (WARN_ON(base == NULL))\n\t\treturn -EINVAL;\n\n\t \n\tvalue = readl(base + TEGRA186_GPIO_OUTPUT_CONTROL);\n\tvalue &= ~TEGRA186_GPIO_OUTPUT_CONTROL_FLOATED;\n\twritel(value, base + TEGRA186_GPIO_OUTPUT_CONTROL);\n\n\tvalue = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);\n\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_ENABLE;\n\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_OUT;\n\twritel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);\n\n\treturn 0;\n}\n\n#define HTE_BOTH_EDGES\t(HTE_RISING_EDGE_TS | HTE_FALLING_EDGE_TS)\n\nstatic int tegra186_gpio_en_hw_ts(struct gpio_chip *gc, u32 offset,\n\t\t\t\t  unsigned long flags)\n{\n\tstruct tegra_gpio *gpio;\n\tvoid __iomem *base;\n\tint value;\n\n\tif (!gc)\n\t\treturn -EINVAL;\n\n\tgpio = gpiochip_get_data(gc);\n\tif (!gpio)\n\t\treturn -ENODEV;\n\n\tbase = tegra186_gpio_get_base(gpio, offset);\n\tif (WARN_ON(base == NULL))\n\t\treturn -EINVAL;\n\n\tvalue = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);\n\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_TIMESTAMP_FUNC;\n\n\tif (flags == HTE_BOTH_EDGES) {\n\t\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_DOUBLE_EDGE;\n\t} else if (flags == HTE_RISING_EDGE_TS) {\n\t\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_SINGLE_EDGE;\n\t\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_LEVEL;\n\t} else if (flags == HTE_FALLING_EDGE_TS) {\n\t\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_SINGLE_EDGE;\n\t}\n\n\twritel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);\n\n\treturn 0;\n}\n\nstatic int tegra186_gpio_dis_hw_ts(struct gpio_chip *gc, u32 offset,\n\t\t\t\t   unsigned long flags)\n{\n\tstruct tegra_gpio *gpio;\n\tvoid __iomem *base;\n\tint value;\n\n\tif (!gc)\n\t\treturn -EINVAL;\n\n\tgpio = gpiochip_get_data(gc);\n\tif (!gpio)\n\t\treturn -ENODEV;\n\n\tbase = tegra186_gpio_get_base(gpio, offset);\n\tif (WARN_ON(base == NULL))\n\t\treturn -EINVAL;\n\n\tvalue = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);\n\tvalue &= ~TEGRA186_GPIO_ENABLE_CONFIG_TIMESTAMP_FUNC;\n\tif (flags == HTE_BOTH_EDGES) {\n\t\tvalue &= ~TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_DOUBLE_EDGE;\n\t} else if (flags == HTE_RISING_EDGE_TS) {\n\t\tvalue &= ~TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_SINGLE_EDGE;\n\t\tvalue &= ~TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_LEVEL;\n\t} else if (flags == HTE_FALLING_EDGE_TS) {\n\t\tvalue &= ~TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_SINGLE_EDGE;\n\t}\n\twritel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);\n\n\treturn 0;\n}\n\nstatic int tegra186_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct tegra_gpio *gpio = gpiochip_get_data(chip);\n\tvoid __iomem *base;\n\tu32 value;\n\n\tbase = tegra186_gpio_get_base(gpio, offset);\n\tif (WARN_ON(base == NULL))\n\t\treturn -ENODEV;\n\n\tvalue = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);\n\tif (value & TEGRA186_GPIO_ENABLE_CONFIG_OUT)\n\t\tvalue = readl(base + TEGRA186_GPIO_OUTPUT_VALUE);\n\telse\n\t\tvalue = readl(base + TEGRA186_GPIO_INPUT);\n\n\treturn value & BIT(0);\n}\n\nstatic void tegra186_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t      int level)\n{\n\tstruct tegra_gpio *gpio = gpiochip_get_data(chip);\n\tvoid __iomem *base;\n\tu32 value;\n\n\tbase = tegra186_gpio_get_base(gpio, offset);\n\tif (WARN_ON(base == NULL))\n\t\treturn;\n\n\tvalue = readl(base + TEGRA186_GPIO_OUTPUT_VALUE);\n\tif (level == 0)\n\t\tvalue &= ~TEGRA186_GPIO_OUTPUT_VALUE_HIGH;\n\telse\n\t\tvalue |= TEGRA186_GPIO_OUTPUT_VALUE_HIGH;\n\n\twritel(value, base + TEGRA186_GPIO_OUTPUT_VALUE);\n}\n\nstatic int tegra186_gpio_set_config(struct gpio_chip *chip,\n\t\t\t\t    unsigned int offset,\n\t\t\t\t    unsigned long config)\n{\n\tstruct tegra_gpio *gpio = gpiochip_get_data(chip);\n\tu32 debounce, value;\n\tvoid __iomem *base;\n\n\tbase = tegra186_gpio_get_base(gpio, offset);\n\tif (base == NULL)\n\t\treturn -ENXIO;\n\n\tif (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)\n\t\treturn -ENOTSUPP;\n\n\tdebounce = pinconf_to_config_argument(config);\n\n\t \n\tif (debounce > 255000)\n\t\treturn -EINVAL;\n\n\tdebounce = DIV_ROUND_UP(debounce, USEC_PER_MSEC);\n\n\tvalue = TEGRA186_GPIO_DEBOUNCE_CONTROL_THRESHOLD(debounce);\n\twritel(value, base + TEGRA186_GPIO_DEBOUNCE_CONTROL);\n\n\tvalue = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);\n\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_DEBOUNCE;\n\twritel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);\n\n\treturn 0;\n}\n\nstatic int tegra186_gpio_add_pin_ranges(struct gpio_chip *chip)\n{\n\tstruct tegra_gpio *gpio = gpiochip_get_data(chip);\n\tstruct pinctrl_dev *pctldev;\n\tstruct device_node *np;\n\tunsigned int i, j;\n\tint err;\n\n\tif (!gpio->soc->pinmux || gpio->soc->num_pin_ranges == 0)\n\t\treturn 0;\n\n\tnp = of_find_compatible_node(NULL, NULL, gpio->soc->pinmux);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tpctldev = of_pinctrl_get(np);\n\tof_node_put(np);\n\tif (!pctldev)\n\t\treturn -EPROBE_DEFER;\n\n\tfor (i = 0; i < gpio->soc->num_pin_ranges; i++) {\n\t\tunsigned int pin = gpio->soc->pin_ranges[i].offset, port;\n\t\tconst char *group = gpio->soc->pin_ranges[i].group;\n\n\t\tport = pin / 8;\n\t\tpin = pin % 8;\n\n\t\tif (port >= gpio->soc->num_ports) {\n\t\t\tdev_warn(chip->parent, \"invalid port %u for %s\\n\",\n\t\t\t\t port, group);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < port; j++)\n\t\t\tpin += gpio->soc->ports[j].pins;\n\n\t\terr = gpiochip_add_pingroup_range(chip, pctldev, pin, group);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra186_gpio_of_xlate(struct gpio_chip *chip,\n\t\t\t\t  const struct of_phandle_args *spec,\n\t\t\t\t  u32 *flags)\n{\n\tstruct tegra_gpio *gpio = gpiochip_get_data(chip);\n\tunsigned int port, pin, i, offset = 0;\n\n\tif (WARN_ON(chip->of_gpio_n_cells < 2))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(spec->args_count < chip->of_gpio_n_cells))\n\t\treturn -EINVAL;\n\n\tport = spec->args[0] / 8;\n\tpin = spec->args[0] % 8;\n\n\tif (port >= gpio->soc->num_ports) {\n\t\tdev_err(chip->parent, \"invalid port number: %u\\n\", port);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < port; i++)\n\t\toffset += gpio->soc->ports[i].pins;\n\n\tif (flags)\n\t\t*flags = spec->args[1];\n\n\treturn offset + pin;\n}\n\n#define to_tegra_gpio(x) container_of((x), struct tegra_gpio, gpio)\n\nstatic void tegra186_irq_ack(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct tegra_gpio *gpio = to_tegra_gpio(gc);\n\tvoid __iomem *base;\n\n\tbase = tegra186_gpio_get_base(gpio, data->hwirq);\n\tif (WARN_ON(base == NULL))\n\t\treturn;\n\n\twritel(1, base + TEGRA186_GPIO_INTERRUPT_CLEAR);\n}\n\nstatic void tegra186_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct tegra_gpio *gpio = to_tegra_gpio(gc);\n\tvoid __iomem *base;\n\tu32 value;\n\n\tbase = tegra186_gpio_get_base(gpio, data->hwirq);\n\tif (WARN_ON(base == NULL))\n\t\treturn;\n\n\tvalue = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);\n\tvalue &= ~TEGRA186_GPIO_ENABLE_CONFIG_INTERRUPT;\n\twritel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);\n\n\tgpiochip_disable_irq(&gpio->gpio, data->hwirq);\n}\n\nstatic void tegra186_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct tegra_gpio *gpio = to_tegra_gpio(gc);\n\tvoid __iomem *base;\n\tu32 value;\n\n\tbase = tegra186_gpio_get_base(gpio, data->hwirq);\n\tif (WARN_ON(base == NULL))\n\t\treturn;\n\n\tgpiochip_enable_irq(&gpio->gpio, data->hwirq);\n\n\tvalue = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);\n\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_INTERRUPT;\n\twritel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);\n}\n\nstatic int tegra186_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct tegra_gpio *gpio = to_tegra_gpio(gc);\n\tvoid __iomem *base;\n\tu32 value;\n\n\tbase = tegra186_gpio_get_base(gpio, data->hwirq);\n\tif (WARN_ON(base == NULL))\n\t\treturn -ENODEV;\n\n\tvalue = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);\n\tvalue &= ~TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_MASK;\n\tvalue &= ~TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_LEVEL;\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_NONE:\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_SINGLE_EDGE;\n\t\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_LEVEL;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_SINGLE_EDGE;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_DOUBLE_EDGE;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_LEVEL;\n\t\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_LEVEL;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tvalue |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_LEVEL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twritel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);\n\n\tif ((type & IRQ_TYPE_EDGE_BOTH) == 0)\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\telse\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\n\tif (data->parent_data)\n\t\treturn irq_chip_set_type_parent(data, type);\n\n\treturn 0;\n}\n\nstatic int tegra186_irq_set_wake(struct irq_data *data, unsigned int on)\n{\n\tif (data->parent_data)\n\t\treturn irq_chip_set_wake_parent(data, on);\n\n\treturn 0;\n}\n\nstatic void tegra186_irq_print_chip(struct irq_data *data, struct seq_file *p)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\n\tseq_printf(p, dev_name(gc->parent));\n}\n\nstatic const struct irq_chip tegra186_gpio_irq_chip = {\n\t.irq_ack\t\t= tegra186_irq_ack,\n\t.irq_mask\t\t= tegra186_irq_mask,\n\t.irq_unmask\t\t= tegra186_irq_unmask,\n\t.irq_set_type\t\t= tegra186_irq_set_type,\n\t.irq_set_wake\t\t= tegra186_irq_set_wake,\n\t.irq_print_chip\t\t= tegra186_irq_print_chip,\n\t.flags\t\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void tegra186_gpio_irq(struct irq_desc *desc)\n{\n\tstruct tegra_gpio *gpio = irq_desc_get_handler_data(desc);\n\tstruct irq_domain *domain = gpio->gpio.irq.domain;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned int parent = irq_desc_get_irq(desc);\n\tunsigned int i, j, offset = 0;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (i = 0; i < gpio->soc->num_ports; i++) {\n\t\tconst struct tegra_gpio_port *port = &gpio->soc->ports[i];\n\t\tunsigned int pin;\n\t\tunsigned long value;\n\t\tvoid __iomem *base;\n\n\t\tbase = gpio->base + port->bank * 0x1000 + port->port * 0x200;\n\n\t\t \n\t\tfor (j = 0; j < gpio->num_irqs_per_bank; j++) {\n\t\t\tif (parent == gpio->irq[port->bank * gpio->num_irqs_per_bank + j])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j == gpio->num_irqs_per_bank)\n\t\t\tgoto skip;\n\n\t\tvalue = readl(base + TEGRA186_GPIO_INTERRUPT_STATUS(1));\n\n\t\tfor_each_set_bit(pin, &value, port->pins) {\n\t\t\tint ret = generic_handle_domain_irq(domain, offset + pin);\n\t\t\tWARN_RATELIMIT(ret, \"hwirq = %d\", offset + pin);\n\t\t}\n\nskip:\n\t\toffset += port->pins;\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int tegra186_gpio_irq_domain_translate(struct irq_domain *domain,\n\t\t\t\t\t      struct irq_fwspec *fwspec,\n\t\t\t\t\t      unsigned long *hwirq,\n\t\t\t\t\t      unsigned int *type)\n{\n\tstruct tegra_gpio *gpio = gpiochip_get_data(domain->host_data);\n\tunsigned int port, pin, i, offset = 0;\n\n\tif (WARN_ON(gpio->gpio.of_gpio_n_cells < 2))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(fwspec->param_count < gpio->gpio.of_gpio_n_cells))\n\t\treturn -EINVAL;\n\n\tport = fwspec->param[0] / 8;\n\tpin = fwspec->param[0] % 8;\n\n\tif (port >= gpio->soc->num_ports)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < port; i++)\n\t\toffset += gpio->soc->ports[i].pins;\n\n\t*type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\t*hwirq = offset + pin;\n\n\treturn 0;\n}\n\nstatic int tegra186_gpio_populate_parent_fwspec(struct gpio_chip *chip,\n\t\t\t\t\t\tunion gpio_irq_fwspec *gfwspec,\n\t\t\t\t\t\tunsigned int parent_hwirq,\n\t\t\t\t\t\tunsigned int parent_type)\n{\n\tstruct tegra_gpio *gpio = gpiochip_get_data(chip);\n\tstruct irq_fwspec *fwspec = &gfwspec->fwspec;\n\n\tfwspec->fwnode = chip->irq.parent_domain->fwnode;\n\tfwspec->param_count = 3;\n\tfwspec->param[0] = gpio->soc->instance;\n\tfwspec->param[1] = parent_hwirq;\n\tfwspec->param[2] = parent_type;\n\n\treturn 0;\n}\n\nstatic int tegra186_gpio_child_to_parent_hwirq(struct gpio_chip *chip,\n\t\t\t\t\t       unsigned int hwirq,\n\t\t\t\t\t       unsigned int type,\n\t\t\t\t\t       unsigned int *parent_hwirq,\n\t\t\t\t\t       unsigned int *parent_type)\n{\n\t*parent_hwirq = chip->irq.child_offset_to_irq(chip, hwirq);\n\t*parent_type = type;\n\n\treturn 0;\n}\n\nstatic unsigned int tegra186_gpio_child_offset_to_irq(struct gpio_chip *chip,\n\t\t\t\t\t\t      unsigned int offset)\n{\n\tstruct tegra_gpio *gpio = gpiochip_get_data(chip);\n\tunsigned int i;\n\n\tfor (i = 0; i < gpio->soc->num_ports; i++) {\n\t\tif (offset < gpio->soc->ports[i].pins)\n\t\t\tbreak;\n\n\t\toffset -= gpio->soc->ports[i].pins;\n\t}\n\n\treturn offset + i * 8;\n}\n\nstatic const struct of_device_id tegra186_pmc_of_match[] = {\n\t{ .compatible = \"nvidia,tegra186-pmc\" },\n\t{ .compatible = \"nvidia,tegra194-pmc\" },\n\t{ .compatible = \"nvidia,tegra234-pmc\" },\n\t{   }\n};\n\nstatic void tegra186_gpio_init_route_mapping(struct tegra_gpio *gpio)\n{\n\tstruct device *dev = gpio->gpio.parent;\n\tunsigned int i;\n\tu32 value;\n\n\tfor (i = 0; i < gpio->soc->num_ports; i++) {\n\t\tconst struct tegra_gpio_port *port = &gpio->soc->ports[i];\n\t\tunsigned int offset, p = port->port;\n\t\tvoid __iomem *base;\n\n\t\tbase = gpio->secure + port->bank * 0x1000 + 0x800;\n\n\t\tvalue = readl(base + TEGRA186_GPIO_CTL_SCR);\n\n\t\t \n\t\tif ((value & TEGRA186_GPIO_CTL_SCR_SEC_REN) == 0 &&\n\t\t    (value & TEGRA186_GPIO_CTL_SCR_SEC_WEN) == 0) {\n\t\t\t \n\t\t\tdev_dbg(dev, \"programming default interrupt routing for port %s\\n\",\n\t\t\t\tport->name);\n\n\t\t\toffset = TEGRA186_GPIO_INT_ROUTE_MAPPING(p, 0);\n\n\t\t\t \n\t\t\tvalue = readl(base + offset);\n\t\t\tvalue = BIT(port->pins) - 1;\n\t\t\twritel(value, base + offset);\n\t\t}\n\t}\n}\n\nstatic unsigned int tegra186_gpio_irqs_per_bank(struct tegra_gpio *gpio)\n{\n\tstruct device *dev = gpio->gpio.parent;\n\n\tif (gpio->num_irq > gpio->num_banks) {\n\t\tif (gpio->num_irq % gpio->num_banks != 0)\n\t\t\tgoto error;\n\t}\n\n\tif (gpio->num_irq < gpio->num_banks)\n\t\tgoto error;\n\n\tgpio->num_irqs_per_bank = gpio->num_irq / gpio->num_banks;\n\n\tif (gpio->num_irqs_per_bank > gpio->soc->num_irqs_per_bank)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tdev_err(dev, \"invalid number of interrupts (%u) for %u banks\\n\",\n\t\tgpio->num_irq, gpio->num_banks);\n\treturn -EINVAL;\n}\n\nstatic int tegra186_gpio_probe(struct platform_device *pdev)\n{\n\tunsigned int i, j, offset;\n\tstruct gpio_irq_chip *irq;\n\tstruct tegra_gpio *gpio;\n\tstruct device_node *np;\n\tchar **names;\n\tint err;\n\n\tgpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tgpio->soc = device_get_match_data(&pdev->dev);\n\tgpio->gpio.label = gpio->soc->name;\n\tgpio->gpio.parent = &pdev->dev;\n\n\t \n\tfor (i = 0; i < gpio->soc->num_ports; i++)\n\t\tif (gpio->soc->ports[i].bank > gpio->num_banks)\n\t\t\tgpio->num_banks = gpio->soc->ports[i].bank;\n\n\tgpio->num_banks++;\n\n\t \n\tgpio->secure = devm_platform_ioremap_resource_byname(pdev, \"security\");\n\tif (IS_ERR(gpio->secure)) {\n\t\tgpio->secure = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(gpio->secure))\n\t\t\treturn PTR_ERR(gpio->secure);\n\t}\n\n\tgpio->base = devm_platform_ioremap_resource_byname(pdev, \"gpio\");\n\tif (IS_ERR(gpio->base)) {\n\t\tgpio->base = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(gpio->base))\n\t\t\treturn PTR_ERR(gpio->base);\n\t}\n\n\terr = platform_irq_count(pdev);\n\tif (err < 0)\n\t\treturn err;\n\n\tgpio->num_irq = err;\n\n\terr = tegra186_gpio_irqs_per_bank(gpio);\n\tif (err < 0)\n\t\treturn err;\n\n\tgpio->irq = devm_kcalloc(&pdev->dev, gpio->num_irq, sizeof(*gpio->irq),\n\t\t\t\t GFP_KERNEL);\n\tif (!gpio->irq)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < gpio->num_irq; i++) {\n\t\terr = platform_get_irq(pdev, i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tgpio->irq[i] = err;\n\t}\n\n\tgpio->gpio.request = gpiochip_generic_request;\n\tgpio->gpio.free = gpiochip_generic_free;\n\tgpio->gpio.get_direction = tegra186_gpio_get_direction;\n\tgpio->gpio.direction_input = tegra186_gpio_direction_input;\n\tgpio->gpio.direction_output = tegra186_gpio_direction_output;\n\tgpio->gpio.get = tegra186_gpio_get;\n\tgpio->gpio.set = tegra186_gpio_set;\n\tgpio->gpio.set_config = tegra186_gpio_set_config;\n\tgpio->gpio.add_pin_ranges = tegra186_gpio_add_pin_ranges;\n\tgpio->gpio.init_valid_mask = tegra186_init_valid_mask;\n\tif (gpio->soc->has_gte) {\n\t\tgpio->gpio.en_hw_timestamp = tegra186_gpio_en_hw_ts;\n\t\tgpio->gpio.dis_hw_timestamp = tegra186_gpio_dis_hw_ts;\n\t}\n\n\tgpio->gpio.base = -1;\n\n\tfor (i = 0; i < gpio->soc->num_ports; i++)\n\t\tgpio->gpio.ngpio += gpio->soc->ports[i].pins;\n\n\tnames = devm_kcalloc(gpio->gpio.parent, gpio->gpio.ngpio,\n\t\t\t     sizeof(*names), GFP_KERNEL);\n\tif (!names)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, offset = 0; i < gpio->soc->num_ports; i++) {\n\t\tconst struct tegra_gpio_port *port = &gpio->soc->ports[i];\n\t\tchar *name;\n\n\t\tfor (j = 0; j < port->pins; j++) {\n\t\t\tname = devm_kasprintf(gpio->gpio.parent, GFP_KERNEL,\n\t\t\t\t\t      \"P%s.%02x\", port->name, j);\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnames[offset + j] = name;\n\t\t}\n\n\t\toffset += port->pins;\n\t}\n\n\tgpio->gpio.names = (const char * const *)names;\n\n#if defined(CONFIG_OF_GPIO)\n\tgpio->gpio.of_gpio_n_cells = 2;\n\tgpio->gpio.of_xlate = tegra186_gpio_of_xlate;\n#endif  \n\n\tirq = &gpio->gpio.irq;\n\tgpio_irq_chip_set_chip(irq, &tegra186_gpio_irq_chip);\n\tirq->fwnode = of_node_to_fwnode(pdev->dev.of_node);\n\tirq->child_to_parent_hwirq = tegra186_gpio_child_to_parent_hwirq;\n\tirq->populate_parent_alloc_arg = tegra186_gpio_populate_parent_fwspec;\n\tirq->child_offset_to_irq = tegra186_gpio_child_offset_to_irq;\n\tirq->child_irq_domain_ops.translate = tegra186_gpio_irq_domain_translate;\n\tirq->handler = handle_simple_irq;\n\tirq->default_type = IRQ_TYPE_NONE;\n\tirq->parent_handler = tegra186_gpio_irq;\n\tirq->parent_handler_data = gpio;\n\tirq->num_parents = gpio->num_irq;\n\n\t \n\tif (gpio->num_irqs_per_bank > 1) {\n\t\tirq->parents = devm_kcalloc(&pdev->dev, gpio->num_banks,\n\t\t\t\t\t    sizeof(*irq->parents), GFP_KERNEL);\n\t\tif (!irq->parents)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < gpio->num_banks; i++)\n\t\t\tirq->parents[i] = gpio->irq[i * gpio->num_irqs_per_bank];\n\n\t\tirq->num_parents = gpio->num_banks;\n\t} else {\n\t\tirq->num_parents = gpio->num_irq;\n\t\tirq->parents = gpio->irq;\n\t}\n\n\tif (gpio->soc->num_irqs_per_bank > 1)\n\t\ttegra186_gpio_init_route_mapping(gpio);\n\n\tnp = of_find_matching_node(NULL, tegra186_pmc_of_match);\n\tif (np) {\n\t\tif (of_device_is_available(np)) {\n\t\t\tirq->parent_domain = irq_find_host(np);\n\t\t\tof_node_put(np);\n\n\t\t\tif (!irq->parent_domain)\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t} else {\n\t\t\tof_node_put(np);\n\t\t}\n\t}\n\n\tirq->map = devm_kcalloc(&pdev->dev, gpio->gpio.ngpio,\n\t\t\t\tsizeof(*irq->map), GFP_KERNEL);\n\tif (!irq->map)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, offset = 0; i < gpio->soc->num_ports; i++) {\n\t\tconst struct tegra_gpio_port *port = &gpio->soc->ports[i];\n\n\t\tfor (j = 0; j < port->pins; j++)\n\t\t\tirq->map[offset + j] = irq->parents[port->bank];\n\n\t\toffset += port->pins;\n\t}\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &gpio->gpio, gpio);\n}\n\n#define TEGRA186_MAIN_GPIO_PORT(_name, _bank, _port, _pins)\t\\\n\t[TEGRA186_MAIN_GPIO_PORT_##_name] = {\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\\\n\t\t.bank = _bank,\t\t\t\t\t\\\n\t\t.port = _port,\t\t\t\t\t\\\n\t\t.pins = _pins,\t\t\t\t\t\\\n\t}\n\nstatic const struct tegra_gpio_port tegra186_main_ports[] = {\n\tTEGRA186_MAIN_GPIO_PORT( A, 2, 0, 7),\n\tTEGRA186_MAIN_GPIO_PORT( B, 3, 0, 7),\n\tTEGRA186_MAIN_GPIO_PORT( C, 3, 1, 7),\n\tTEGRA186_MAIN_GPIO_PORT( D, 3, 2, 6),\n\tTEGRA186_MAIN_GPIO_PORT( E, 2, 1, 8),\n\tTEGRA186_MAIN_GPIO_PORT( F, 2, 2, 6),\n\tTEGRA186_MAIN_GPIO_PORT( G, 4, 1, 6),\n\tTEGRA186_MAIN_GPIO_PORT( H, 1, 0, 7),\n\tTEGRA186_MAIN_GPIO_PORT( I, 0, 4, 8),\n\tTEGRA186_MAIN_GPIO_PORT( J, 5, 0, 8),\n\tTEGRA186_MAIN_GPIO_PORT( K, 5, 1, 1),\n\tTEGRA186_MAIN_GPIO_PORT( L, 1, 1, 8),\n\tTEGRA186_MAIN_GPIO_PORT( M, 5, 3, 6),\n\tTEGRA186_MAIN_GPIO_PORT( N, 0, 0, 7),\n\tTEGRA186_MAIN_GPIO_PORT( O, 0, 1, 4),\n\tTEGRA186_MAIN_GPIO_PORT( P, 4, 0, 7),\n\tTEGRA186_MAIN_GPIO_PORT( Q, 0, 2, 6),\n\tTEGRA186_MAIN_GPIO_PORT( R, 0, 5, 6),\n\tTEGRA186_MAIN_GPIO_PORT( T, 0, 3, 4),\n\tTEGRA186_MAIN_GPIO_PORT( X, 1, 2, 8),\n\tTEGRA186_MAIN_GPIO_PORT( Y, 1, 3, 7),\n\tTEGRA186_MAIN_GPIO_PORT(BB, 2, 3, 2),\n\tTEGRA186_MAIN_GPIO_PORT(CC, 5, 2, 4),\n};\n\nstatic const struct tegra_gpio_soc tegra186_main_soc = {\n\t.num_ports = ARRAY_SIZE(tegra186_main_ports),\n\t.ports = tegra186_main_ports,\n\t.name = \"tegra186-gpio\",\n\t.instance = 0,\n\t.num_irqs_per_bank = 1,\n\t.has_vm_support = false,\n};\n\n#define TEGRA186_AON_GPIO_PORT(_name, _bank, _port, _pins)\t\\\n\t[TEGRA186_AON_GPIO_PORT_##_name] = {\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\\\n\t\t.bank = _bank,\t\t\t\t\t\\\n\t\t.port = _port,\t\t\t\t\t\\\n\t\t.pins = _pins,\t\t\t\t\t\\\n\t}\n\nstatic const struct tegra_gpio_port tegra186_aon_ports[] = {\n\tTEGRA186_AON_GPIO_PORT( S, 0, 1, 5),\n\tTEGRA186_AON_GPIO_PORT( U, 0, 2, 6),\n\tTEGRA186_AON_GPIO_PORT( V, 0, 4, 8),\n\tTEGRA186_AON_GPIO_PORT( W, 0, 5, 8),\n\tTEGRA186_AON_GPIO_PORT( Z, 0, 7, 4),\n\tTEGRA186_AON_GPIO_PORT(AA, 0, 6, 8),\n\tTEGRA186_AON_GPIO_PORT(EE, 0, 3, 3),\n\tTEGRA186_AON_GPIO_PORT(FF, 0, 0, 5),\n};\n\nstatic const struct tegra_gpio_soc tegra186_aon_soc = {\n\t.num_ports = ARRAY_SIZE(tegra186_aon_ports),\n\t.ports = tegra186_aon_ports,\n\t.name = \"tegra186-gpio-aon\",\n\t.instance = 1,\n\t.num_irqs_per_bank = 1,\n\t.has_vm_support = false,\n};\n\n#define TEGRA194_MAIN_GPIO_PORT(_name, _bank, _port, _pins)\t\\\n\t[TEGRA194_MAIN_GPIO_PORT_##_name] = {\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\\\n\t\t.bank = _bank,\t\t\t\t\t\\\n\t\t.port = _port,\t\t\t\t\t\\\n\t\t.pins = _pins,\t\t\t\t\t\\\n\t}\n\nstatic const struct tegra_gpio_port tegra194_main_ports[] = {\n\tTEGRA194_MAIN_GPIO_PORT( A, 1, 2, 8),\n\tTEGRA194_MAIN_GPIO_PORT( B, 4, 7, 2),\n\tTEGRA194_MAIN_GPIO_PORT( C, 4, 3, 8),\n\tTEGRA194_MAIN_GPIO_PORT( D, 4, 4, 4),\n\tTEGRA194_MAIN_GPIO_PORT( E, 4, 5, 8),\n\tTEGRA194_MAIN_GPIO_PORT( F, 4, 6, 6),\n\tTEGRA194_MAIN_GPIO_PORT( G, 4, 0, 8),\n\tTEGRA194_MAIN_GPIO_PORT( H, 4, 1, 8),\n\tTEGRA194_MAIN_GPIO_PORT( I, 4, 2, 5),\n\tTEGRA194_MAIN_GPIO_PORT( J, 5, 1, 6),\n\tTEGRA194_MAIN_GPIO_PORT( K, 3, 0, 8),\n\tTEGRA194_MAIN_GPIO_PORT( L, 3, 1, 4),\n\tTEGRA194_MAIN_GPIO_PORT( M, 2, 3, 8),\n\tTEGRA194_MAIN_GPIO_PORT( N, 2, 4, 3),\n\tTEGRA194_MAIN_GPIO_PORT( O, 5, 0, 6),\n\tTEGRA194_MAIN_GPIO_PORT( P, 2, 5, 8),\n\tTEGRA194_MAIN_GPIO_PORT( Q, 2, 6, 8),\n\tTEGRA194_MAIN_GPIO_PORT( R, 2, 7, 6),\n\tTEGRA194_MAIN_GPIO_PORT( S, 3, 3, 8),\n\tTEGRA194_MAIN_GPIO_PORT( T, 3, 4, 8),\n\tTEGRA194_MAIN_GPIO_PORT( U, 3, 5, 1),\n\tTEGRA194_MAIN_GPIO_PORT( V, 1, 0, 8),\n\tTEGRA194_MAIN_GPIO_PORT( W, 1, 1, 2),\n\tTEGRA194_MAIN_GPIO_PORT( X, 2, 0, 8),\n\tTEGRA194_MAIN_GPIO_PORT( Y, 2, 1, 8),\n\tTEGRA194_MAIN_GPIO_PORT( Z, 2, 2, 8),\n\tTEGRA194_MAIN_GPIO_PORT(FF, 3, 2, 2),\n\tTEGRA194_MAIN_GPIO_PORT(GG, 0, 0, 2)\n};\n\nstatic const struct tegra186_pin_range tegra194_main_pin_ranges[] = {\n\t{ TEGRA194_MAIN_GPIO(GG, 0), \"pex_l5_clkreq_n_pgg0\" },\n\t{ TEGRA194_MAIN_GPIO(GG, 1), \"pex_l5_rst_n_pgg1\" },\n};\n\nstatic const struct tegra_gpio_soc tegra194_main_soc = {\n\t.num_ports = ARRAY_SIZE(tegra194_main_ports),\n\t.ports = tegra194_main_ports,\n\t.name = \"tegra194-gpio\",\n\t.instance = 0,\n\t.num_irqs_per_bank = 8,\n\t.num_pin_ranges = ARRAY_SIZE(tegra194_main_pin_ranges),\n\t.pin_ranges = tegra194_main_pin_ranges,\n\t.pinmux = \"nvidia,tegra194-pinmux\",\n\t.has_vm_support = true,\n};\n\n#define TEGRA194_AON_GPIO_PORT(_name, _bank, _port, _pins)\t\\\n\t[TEGRA194_AON_GPIO_PORT_##_name] = {\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\\\n\t\t.bank = _bank,\t\t\t\t\t\\\n\t\t.port = _port,\t\t\t\t\t\\\n\t\t.pins = _pins,\t\t\t\t\t\\\n\t}\n\nstatic const struct tegra_gpio_port tegra194_aon_ports[] = {\n\tTEGRA194_AON_GPIO_PORT(AA, 0, 3, 8),\n\tTEGRA194_AON_GPIO_PORT(BB, 0, 4, 4),\n\tTEGRA194_AON_GPIO_PORT(CC, 0, 1, 8),\n\tTEGRA194_AON_GPIO_PORT(DD, 0, 2, 3),\n\tTEGRA194_AON_GPIO_PORT(EE, 0, 0, 7)\n};\n\nstatic const struct tegra_gpio_soc tegra194_aon_soc = {\n\t.num_ports = ARRAY_SIZE(tegra194_aon_ports),\n\t.ports = tegra194_aon_ports,\n\t.name = \"tegra194-gpio-aon\",\n\t.instance = 1,\n\t.num_irqs_per_bank = 8,\n\t.has_gte = true,\n\t.has_vm_support = false,\n};\n\n#define TEGRA234_MAIN_GPIO_PORT(_name, _bank, _port, _pins)\t\\\n\t[TEGRA234_MAIN_GPIO_PORT_##_name] = {\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\\\n\t\t.bank = _bank,\t\t\t\t\t\\\n\t\t.port = _port,\t\t\t\t\t\\\n\t\t.pins = _pins,\t\t\t\t\t\\\n\t}\n\nstatic const struct tegra_gpio_port tegra234_main_ports[] = {\n\tTEGRA234_MAIN_GPIO_PORT( A, 0, 0, 8),\n\tTEGRA234_MAIN_GPIO_PORT( B, 0, 3, 1),\n\tTEGRA234_MAIN_GPIO_PORT( C, 5, 1, 8),\n\tTEGRA234_MAIN_GPIO_PORT( D, 5, 2, 4),\n\tTEGRA234_MAIN_GPIO_PORT( E, 5, 3, 8),\n\tTEGRA234_MAIN_GPIO_PORT( F, 5, 4, 6),\n\tTEGRA234_MAIN_GPIO_PORT( G, 4, 0, 8),\n\tTEGRA234_MAIN_GPIO_PORT( H, 4, 1, 8),\n\tTEGRA234_MAIN_GPIO_PORT( I, 4, 2, 7),\n\tTEGRA234_MAIN_GPIO_PORT( J, 5, 0, 6),\n\tTEGRA234_MAIN_GPIO_PORT( K, 3, 0, 8),\n\tTEGRA234_MAIN_GPIO_PORT( L, 3, 1, 4),\n\tTEGRA234_MAIN_GPIO_PORT( M, 2, 0, 8),\n\tTEGRA234_MAIN_GPIO_PORT( N, 2, 1, 8),\n\tTEGRA234_MAIN_GPIO_PORT( P, 2, 2, 8),\n\tTEGRA234_MAIN_GPIO_PORT( Q, 2, 3, 8),\n\tTEGRA234_MAIN_GPIO_PORT( R, 2, 4, 6),\n\tTEGRA234_MAIN_GPIO_PORT( X, 1, 0, 8),\n\tTEGRA234_MAIN_GPIO_PORT( Y, 1, 1, 8),\n\tTEGRA234_MAIN_GPIO_PORT( Z, 1, 2, 8),\n\tTEGRA234_MAIN_GPIO_PORT(AC, 0, 1, 8),\n\tTEGRA234_MAIN_GPIO_PORT(AD, 0, 2, 4),\n\tTEGRA234_MAIN_GPIO_PORT(AE, 3, 3, 2),\n\tTEGRA234_MAIN_GPIO_PORT(AF, 3, 4, 4),\n\tTEGRA234_MAIN_GPIO_PORT(AG, 3, 2, 8),\n};\n\nstatic const struct tegra_gpio_soc tegra234_main_soc = {\n\t.num_ports = ARRAY_SIZE(tegra234_main_ports),\n\t.ports = tegra234_main_ports,\n\t.name = \"tegra234-gpio\",\n\t.instance = 0,\n\t.num_irqs_per_bank = 8,\n\t.has_vm_support = true,\n};\n\n#define TEGRA234_AON_GPIO_PORT(_name, _bank, _port, _pins)\t\\\n\t[TEGRA234_AON_GPIO_PORT_##_name] = {\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\\\n\t\t.bank = _bank,\t\t\t\t\t\\\n\t\t.port = _port,\t\t\t\t\t\\\n\t\t.pins = _pins,\t\t\t\t\t\\\n\t}\n\nstatic const struct tegra_gpio_port tegra234_aon_ports[] = {\n\tTEGRA234_AON_GPIO_PORT(AA, 0, 4, 8),\n\tTEGRA234_AON_GPIO_PORT(BB, 0, 5, 4),\n\tTEGRA234_AON_GPIO_PORT(CC, 0, 2, 8),\n\tTEGRA234_AON_GPIO_PORT(DD, 0, 3, 3),\n\tTEGRA234_AON_GPIO_PORT(EE, 0, 0, 8),\n\tTEGRA234_AON_GPIO_PORT(GG, 0, 1, 1),\n};\n\nstatic const struct tegra_gpio_soc tegra234_aon_soc = {\n\t.num_ports = ARRAY_SIZE(tegra234_aon_ports),\n\t.ports = tegra234_aon_ports,\n\t.name = \"tegra234-gpio-aon\",\n\t.instance = 1,\n\t.num_irqs_per_bank = 8,\n\t.has_gte = true,\n\t.has_vm_support = false,\n};\n\n#define TEGRA241_MAIN_GPIO_PORT(_name, _bank, _port, _pins)\t\\\n\t[TEGRA241_MAIN_GPIO_PORT_##_name] = {\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\\\n\t\t.bank = _bank,\t\t\t\t\t\\\n\t\t.port = _port,\t\t\t\t\t\\\n\t\t.pins = _pins,\t\t\t\t\t\\\n\t}\n\nstatic const struct tegra_gpio_port tegra241_main_ports[] = {\n\tTEGRA241_MAIN_GPIO_PORT(A, 0, 0, 8),\n\tTEGRA241_MAIN_GPIO_PORT(B, 0, 1, 8),\n\tTEGRA241_MAIN_GPIO_PORT(C, 0, 2, 2),\n\tTEGRA241_MAIN_GPIO_PORT(D, 0, 3, 6),\n\tTEGRA241_MAIN_GPIO_PORT(E, 0, 4, 8),\n\tTEGRA241_MAIN_GPIO_PORT(F, 1, 0, 8),\n\tTEGRA241_MAIN_GPIO_PORT(G, 1, 1, 8),\n\tTEGRA241_MAIN_GPIO_PORT(H, 1, 2, 8),\n\tTEGRA241_MAIN_GPIO_PORT(J, 1, 3, 8),\n\tTEGRA241_MAIN_GPIO_PORT(K, 1, 4, 4),\n\tTEGRA241_MAIN_GPIO_PORT(L, 1, 5, 6),\n};\n\nstatic const struct tegra_gpio_soc tegra241_main_soc = {\n\t.num_ports = ARRAY_SIZE(tegra241_main_ports),\n\t.ports = tegra241_main_ports,\n\t.name = \"tegra241-gpio\",\n\t.instance = 0,\n\t.num_irqs_per_bank = 8,\n\t.has_vm_support = false,\n};\n\n#define TEGRA241_AON_GPIO_PORT(_name, _bank, _port, _pins)\t\\\n\t[TEGRA241_AON_GPIO_PORT_##_name] = {\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\\\n\t\t.bank = _bank,\t\t\t\t\t\\\n\t\t.port = _port,\t\t\t\t\t\\\n\t\t.pins = _pins,\t\t\t\t\t\\\n\t}\n\nstatic const struct tegra_gpio_port tegra241_aon_ports[] = {\n\tTEGRA241_AON_GPIO_PORT(AA, 0, 0, 8),\n\tTEGRA241_AON_GPIO_PORT(BB, 0, 0, 4),\n};\n\nstatic const struct tegra_gpio_soc tegra241_aon_soc = {\n\t.num_ports = ARRAY_SIZE(tegra241_aon_ports),\n\t.ports = tegra241_aon_ports,\n\t.name = \"tegra241-gpio-aon\",\n\t.instance = 1,\n\t.num_irqs_per_bank = 8,\n\t.has_vm_support = false,\n};\n\nstatic const struct of_device_id tegra186_gpio_of_match[] = {\n\t{\n\t\t.compatible = \"nvidia,tegra186-gpio\",\n\t\t.data = &tegra186_main_soc\n\t}, {\n\t\t.compatible = \"nvidia,tegra186-gpio-aon\",\n\t\t.data = &tegra186_aon_soc\n\t}, {\n\t\t.compatible = \"nvidia,tegra194-gpio\",\n\t\t.data = &tegra194_main_soc\n\t}, {\n\t\t.compatible = \"nvidia,tegra194-gpio-aon\",\n\t\t.data = &tegra194_aon_soc\n\t}, {\n\t\t.compatible = \"nvidia,tegra234-gpio\",\n\t\t.data = &tegra234_main_soc\n\t}, {\n\t\t.compatible = \"nvidia,tegra234-gpio-aon\",\n\t\t.data = &tegra234_aon_soc\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, tegra186_gpio_of_match);\n\nstatic const struct acpi_device_id  tegra186_gpio_acpi_match[] = {\n\t{ .id = \"NVDA0108\", .driver_data = (kernel_ulong_t)&tegra186_main_soc },\n\t{ .id = \"NVDA0208\", .driver_data = (kernel_ulong_t)&tegra186_aon_soc },\n\t{ .id = \"NVDA0308\", .driver_data = (kernel_ulong_t)&tegra194_main_soc },\n\t{ .id = \"NVDA0408\", .driver_data = (kernel_ulong_t)&tegra194_aon_soc },\n\t{ .id = \"NVDA0508\", .driver_data = (kernel_ulong_t)&tegra241_main_soc },\n\t{ .id = \"NVDA0608\", .driver_data = (kernel_ulong_t)&tegra241_aon_soc },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, tegra186_gpio_acpi_match);\n\nstatic struct platform_driver tegra186_gpio_driver = {\n\t.driver = {\n\t\t.name = \"tegra186-gpio\",\n\t\t.of_match_table = tegra186_gpio_of_match,\n\t\t.acpi_match_table = tegra186_gpio_acpi_match,\n\t},\n\t.probe = tegra186_gpio_probe,\n};\nmodule_platform_driver(tegra186_gpio_driver);\n\nMODULE_DESCRIPTION(\"NVIDIA Tegra186 GPIO controller driver\");\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}