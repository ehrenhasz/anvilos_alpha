{
  "module_name": "gpio-lpc18xx.c",
  "hash_id": "e25a1b85acfd74963d59ad498cf44ecd8670811ca69c48fe5bedb62c5add1a97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-lpc18xx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n\n \n#define LPC18XX_REG_DIR(n)\t(0x2000 + n * sizeof(u32))\n\n#define LPC18XX_MAX_PORTS\t8\n#define LPC18XX_PINS_PER_PORT\t32\n\n \n#define LPC18XX_GPIO_PIN_IC_ISEL\t0x00\n#define LPC18XX_GPIO_PIN_IC_IENR\t0x04\n#define LPC18XX_GPIO_PIN_IC_SIENR\t0x08\n#define LPC18XX_GPIO_PIN_IC_CIENR\t0x0c\n#define LPC18XX_GPIO_PIN_IC_IENF\t0x10\n#define LPC18XX_GPIO_PIN_IC_SIENF\t0x14\n#define LPC18XX_GPIO_PIN_IC_CIENF\t0x18\n#define LPC18XX_GPIO_PIN_IC_RISE\t0x1c\n#define LPC18XX_GPIO_PIN_IC_FALL\t0x20\n#define LPC18XX_GPIO_PIN_IC_IST\t\t0x24\n\n#define NR_LPC18XX_GPIO_PIN_IC_IRQS\t8\n\nstruct lpc18xx_gpio_pin_ic {\n\tvoid __iomem *base;\n\tstruct irq_domain *domain;\n\tstruct raw_spinlock lock;\n};\n\nstruct lpc18xx_gpio_chip {\n\tstruct gpio_chip gpio;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct lpc18xx_gpio_pin_ic *pin_ic;\n\tspinlock_t lock;\n};\n\nstatic inline void lpc18xx_gpio_pin_ic_isel(struct lpc18xx_gpio_pin_ic *ic,\n\t\t\t\t\t    u32 pin, bool set)\n{\n\tu32 val = readl_relaxed(ic->base + LPC18XX_GPIO_PIN_IC_ISEL);\n\n\tif (set)\n\t\tval &= ~BIT(pin);\n\telse\n\t\tval |= BIT(pin);\n\n\twritel_relaxed(val, ic->base + LPC18XX_GPIO_PIN_IC_ISEL);\n}\n\nstatic inline void lpc18xx_gpio_pin_ic_set(struct lpc18xx_gpio_pin_ic *ic,\n\t\t\t\t\t   u32 pin, u32 reg)\n{\n\twritel_relaxed(BIT(pin), ic->base + reg);\n}\n\nstatic void lpc18xx_gpio_pin_ic_mask(struct irq_data *d)\n{\n\tstruct lpc18xx_gpio_pin_ic *ic = d->chip_data;\n\tu32 type = irqd_get_trigger_type(d);\n\n\traw_spin_lock(&ic->lock);\n\n\tif (type & IRQ_TYPE_LEVEL_MASK || type & IRQ_TYPE_EDGE_RISING)\n\t\tlpc18xx_gpio_pin_ic_set(ic, d->hwirq,\n\t\t\t\t\tLPC18XX_GPIO_PIN_IC_CIENR);\n\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tlpc18xx_gpio_pin_ic_set(ic, d->hwirq,\n\t\t\t\t\tLPC18XX_GPIO_PIN_IC_CIENF);\n\n\traw_spin_unlock(&ic->lock);\n\n\tirq_chip_mask_parent(d);\n}\n\nstatic void lpc18xx_gpio_pin_ic_unmask(struct irq_data *d)\n{\n\tstruct lpc18xx_gpio_pin_ic *ic = d->chip_data;\n\tu32 type = irqd_get_trigger_type(d);\n\n\traw_spin_lock(&ic->lock);\n\n\tif (type & IRQ_TYPE_LEVEL_MASK || type & IRQ_TYPE_EDGE_RISING)\n\t\tlpc18xx_gpio_pin_ic_set(ic, d->hwirq,\n\t\t\t\t\tLPC18XX_GPIO_PIN_IC_SIENR);\n\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tlpc18xx_gpio_pin_ic_set(ic, d->hwirq,\n\t\t\t\t\tLPC18XX_GPIO_PIN_IC_SIENF);\n\n\traw_spin_unlock(&ic->lock);\n\n\tirq_chip_unmask_parent(d);\n}\n\nstatic void lpc18xx_gpio_pin_ic_eoi(struct irq_data *d)\n{\n\tstruct lpc18xx_gpio_pin_ic *ic = d->chip_data;\n\tu32 type = irqd_get_trigger_type(d);\n\n\traw_spin_lock(&ic->lock);\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tlpc18xx_gpio_pin_ic_set(ic, d->hwirq,\n\t\t\t\t\tLPC18XX_GPIO_PIN_IC_IST);\n\n\traw_spin_unlock(&ic->lock);\n\n\tirq_chip_eoi_parent(d);\n}\n\nstatic int lpc18xx_gpio_pin_ic_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct lpc18xx_gpio_pin_ic *ic = d->chip_data;\n\n\traw_spin_lock(&ic->lock);\n\n\tif (type & IRQ_TYPE_LEVEL_HIGH) {\n\t\tlpc18xx_gpio_pin_ic_isel(ic, d->hwirq, true);\n\t\tlpc18xx_gpio_pin_ic_set(ic, d->hwirq,\n\t\t\t\t\tLPC18XX_GPIO_PIN_IC_SIENF);\n\t} else if (type & IRQ_TYPE_LEVEL_LOW) {\n\t\tlpc18xx_gpio_pin_ic_isel(ic, d->hwirq, true);\n\t\tlpc18xx_gpio_pin_ic_set(ic, d->hwirq,\n\t\t\t\t\tLPC18XX_GPIO_PIN_IC_CIENF);\n\t} else {\n\t\tlpc18xx_gpio_pin_ic_isel(ic, d->hwirq, false);\n\t}\n\n\traw_spin_unlock(&ic->lock);\n\n\treturn 0;\n}\n\nstatic struct irq_chip lpc18xx_gpio_pin_ic = {\n\t.name\t\t= \"LPC18xx GPIO pin\",\n\t.irq_mask\t= lpc18xx_gpio_pin_ic_mask,\n\t.irq_unmask\t= lpc18xx_gpio_pin_ic_unmask,\n\t.irq_eoi\t= lpc18xx_gpio_pin_ic_eoi,\n\t.irq_set_type\t= lpc18xx_gpio_pin_ic_set_type,\n\t.flags\t\t= IRQCHIP_SET_TYPE_MASKED,\n};\n\nstatic int lpc18xx_gpio_pin_ic_domain_alloc(struct irq_domain *domain,\n\t\t\t\t\t    unsigned int virq,\n\t\t\t\t\t    unsigned int nr_irqs, void *data)\n{\n\tstruct irq_fwspec parent_fwspec, *fwspec = data;\n\tstruct lpc18xx_gpio_pin_ic *ic = domain->host_data;\n\tirq_hw_number_t hwirq;\n\tint ret;\n\n\tif (nr_irqs != 1)\n\t\treturn -EINVAL;\n\n\thwirq = fwspec->param[0];\n\tif (hwirq >= NR_LPC18XX_GPIO_PIN_IC_IRQS)\n\t\treturn -EINVAL;\n\n\t \n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\tparent_fwspec.param_count = 1;\n\tparent_fwspec.param[0] = hwirq + 32;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, 1, &parent_fwspec);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to allocate parent irq %u: %d\\n\",\n\t\t       parent_fwspec.param[0], ret);\n\t\treturn ret;\n\t}\n\n\treturn irq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t\t     &lpc18xx_gpio_pin_ic, ic);\n}\n\nstatic const struct irq_domain_ops lpc18xx_gpio_pin_ic_domain_ops = {\n\t.alloc\t= lpc18xx_gpio_pin_ic_domain_alloc,\n\t.xlate\t= irq_domain_xlate_twocell,\n\t.free\t= irq_domain_free_irqs_common,\n};\n\nstatic int lpc18xx_gpio_pin_ic_probe(struct lpc18xx_gpio_chip *gc)\n{\n\tstruct device *dev = gc->gpio.parent;\n\tstruct irq_domain *parent_domain;\n\tstruct device_node *parent_node;\n\tstruct lpc18xx_gpio_pin_ic *ic;\n\tstruct resource res;\n\tint ret, index;\n\n\tparent_node = of_irq_find_parent(dev->of_node);\n\tif (!parent_node)\n\t\treturn -ENXIO;\n\n\tparent_domain = irq_find_host(parent_node);\n\tof_node_put(parent_node);\n\tif (!parent_domain)\n\t\treturn -ENXIO;\n\n\tic = devm_kzalloc(dev, sizeof(*ic), GFP_KERNEL);\n\tif (!ic)\n\t\treturn -ENOMEM;\n\n\tindex = of_property_match_string(dev->of_node, \"reg-names\",\n\t\t\t\t\t \"gpio-pin-ic\");\n\tif (index < 0) {\n\t\tret = -ENODEV;\n\t\tgoto free_ic;\n\t}\n\n\tret = of_address_to_resource(dev->of_node, index, &res);\n\tif (ret < 0)\n\t\tgoto free_ic;\n\n\tic->base = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(ic->base)) {\n\t\tret = PTR_ERR(ic->base);\n\t\tgoto free_ic;\n\t}\n\n\traw_spin_lock_init(&ic->lock);\n\n\tic->domain = irq_domain_add_hierarchy(parent_domain, 0,\n\t\t\t\t\t      NR_LPC18XX_GPIO_PIN_IC_IRQS,\n\t\t\t\t\t      dev->of_node,\n\t\t\t\t\t      &lpc18xx_gpio_pin_ic_domain_ops,\n\t\t\t\t\t      ic);\n\tif (!ic->domain) {\n\t\tpr_err(\"unable to add irq domain\\n\");\n\t\tret = -ENODEV;\n\t\tgoto free_iomap;\n\t}\n\n\tgc->pin_ic = ic;\n\n\treturn 0;\n\nfree_iomap:\n\tdevm_iounmap(dev, ic->base);\nfree_ic:\n\tdevm_kfree(dev, ic);\n\n\treturn ret;\n}\n\nstatic void lpc18xx_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct lpc18xx_gpio_chip *gc = gpiochip_get_data(chip);\n\twriteb(value ? 1 : 0, gc->base + offset);\n}\n\nstatic int lpc18xx_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct lpc18xx_gpio_chip *gc = gpiochip_get_data(chip);\n\treturn !!readb(gc->base + offset);\n}\n\nstatic int lpc18xx_gpio_direction(struct gpio_chip *chip, unsigned offset,\n\t\t\t\t  bool out)\n{\n\tstruct lpc18xx_gpio_chip *gc = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu32 port, pin, dir;\n\n\tport = offset / LPC18XX_PINS_PER_PORT;\n\tpin  = offset % LPC18XX_PINS_PER_PORT;\n\n\tspin_lock_irqsave(&gc->lock, flags);\n\tdir = readl(gc->base + LPC18XX_REG_DIR(port));\n\tif (out)\n\t\tdir |= BIT(pin);\n\telse\n\t\tdir &= ~BIT(pin);\n\twritel(dir, gc->base + LPC18XX_REG_DIR(port));\n\tspin_unlock_irqrestore(&gc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int lpc18xx_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset)\n{\n\treturn lpc18xx_gpio_direction(chip, offset, false);\n}\n\nstatic int lpc18xx_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t unsigned offset, int value)\n{\n\tlpc18xx_gpio_set(chip, offset, value);\n\treturn lpc18xx_gpio_direction(chip, offset, true);\n}\n\nstatic const struct gpio_chip lpc18xx_chip = {\n\t.label\t\t\t= \"lpc18xx/43xx-gpio\",\n\t.request\t\t= gpiochip_generic_request,\n\t.free\t\t\t= gpiochip_generic_free,\n\t.direction_input\t= lpc18xx_gpio_direction_input,\n\t.direction_output\t= lpc18xx_gpio_direction_output,\n\t.set\t\t\t= lpc18xx_gpio_set,\n\t.get\t\t\t= lpc18xx_gpio_get,\n\t.ngpio\t\t\t= LPC18XX_MAX_PORTS * LPC18XX_PINS_PER_PORT,\n\t.owner\t\t\t= THIS_MODULE,\n};\n\nstatic int lpc18xx_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct lpc18xx_gpio_chip *gc;\n\tint index, ret;\n\n\tgc = devm_kzalloc(dev, sizeof(*gc), GFP_KERNEL);\n\tif (!gc)\n\t\treturn -ENOMEM;\n\n\tgc->gpio = lpc18xx_chip;\n\tplatform_set_drvdata(pdev, gc);\n\n\tindex = of_property_match_string(dev->of_node, \"reg-names\", \"gpio\");\n\tif (index < 0) {\n\t\t \n\t\tgc->base = devm_platform_ioremap_resource(pdev, 0);\n\t} else {\n\t\tstruct resource res;\n\n\t\tret = of_address_to_resource(dev->of_node, index, &res);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tgc->base = devm_ioremap_resource(dev, &res);\n\t}\n\tif (IS_ERR(gc->base))\n\t\treturn PTR_ERR(gc->base);\n\n\tgc->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(gc->clk)) {\n\t\tdev_err(dev, \"input clock not found\\n\");\n\t\treturn PTR_ERR(gc->clk);\n\t}\n\n\tret = clk_prepare_enable(gc->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tspin_lock_init(&gc->lock);\n\n\tgc->gpio.parent = dev;\n\n\tret = devm_gpiochip_add_data(dev, &gc->gpio, gc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add gpio chip\\n\");\n\t\tclk_disable_unprepare(gc->clk);\n\t\treturn ret;\n\t}\n\n\t \n\tlpc18xx_gpio_pin_ic_probe(gc);\n\n\treturn 0;\n}\n\nstatic int lpc18xx_gpio_remove(struct platform_device *pdev)\n{\n\tstruct lpc18xx_gpio_chip *gc = platform_get_drvdata(pdev);\n\n\tif (gc->pin_ic)\n\t\tirq_domain_remove(gc->pin_ic->domain);\n\n\tclk_disable_unprepare(gc->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id lpc18xx_gpio_match[] = {\n\t{ .compatible = \"nxp,lpc1850-gpio\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lpc18xx_gpio_match);\n\nstatic struct platform_driver lpc18xx_gpio_driver = {\n\t.probe\t= lpc18xx_gpio_probe,\n\t.remove\t= lpc18xx_gpio_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"lpc18xx-gpio\",\n\t\t.of_match_table\t= lpc18xx_gpio_match,\n\t},\n};\nmodule_platform_driver(lpc18xx_gpio_driver);\n\nMODULE_AUTHOR(\"Joachim Eastwood <manabian@gmail.com>\");\nMODULE_AUTHOR(\"Vladimir Zapolskiy <vz@mleia.com>\");\nMODULE_DESCRIPTION(\"GPIO driver for LPC18xx/43xx\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}