{
  "module_name": "gpio-ws16c48.c",
  "hash_id": "89910a1cc7f2487ce577657552ccf4314bc7d97d2e6186adae10ee628e9b490d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-ws16c48.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/regmap.h>\n#include <linux/irq.h>\n#include <linux/isa.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n#define WS16C48_EXTENT 11\n#define MAX_NUM_WS16C48 max_num_isa_dev(WS16C48_EXTENT)\n\nstatic unsigned int base[MAX_NUM_WS16C48];\nstatic unsigned int num_ws16c48;\nmodule_param_hw_array(base, uint, ioport, &num_ws16c48, 0);\nMODULE_PARM_DESC(base, \"WinSystems WS16C48 base addresses\");\n\nstatic unsigned int irq[MAX_NUM_WS16C48];\nstatic unsigned int num_irq;\nmodule_param_hw_array(irq, uint, irq, &num_irq, 0);\nMODULE_PARM_DESC(irq, \"WinSystems WS16C48 interrupt line numbers\");\n\n#define WS16C48_DAT_BASE 0x0\n#define WS16C48_PAGE_LOCK 0x7\n#define WS16C48_PAGE_BASE 0x8\n#define WS16C48_POL WS16C48_PAGE_BASE\n#define WS16C48_ENAB WS16C48_PAGE_BASE\n#define WS16C48_INT_ID WS16C48_PAGE_BASE\n\n#define PAGE_LOCK_PAGE_FIELD GENMASK(7, 6)\n#define POL_PAGE u8_encode_bits(1, PAGE_LOCK_PAGE_FIELD)\n#define ENAB_PAGE u8_encode_bits(2, PAGE_LOCK_PAGE_FIELD)\n#define INT_ID_PAGE u8_encode_bits(3, PAGE_LOCK_PAGE_FIELD)\n\nstatic const struct regmap_range ws16c48_wr_ranges[] = {\n\tregmap_reg_range(0x0, 0x5), regmap_reg_range(0x7, 0xA),\n};\nstatic const struct regmap_range ws16c48_rd_ranges[] = {\n\tregmap_reg_range(0x0, 0xA),\n};\nstatic const struct regmap_range ws16c48_volatile_ranges[] = {\n\tregmap_reg_range(0x0, 0x6), regmap_reg_range(0x8, 0xA),\n};\nstatic const struct regmap_access_table ws16c48_wr_table = {\n\t.yes_ranges = ws16c48_wr_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(ws16c48_wr_ranges),\n};\nstatic const struct regmap_access_table ws16c48_rd_table = {\n\t.yes_ranges = ws16c48_rd_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(ws16c48_rd_ranges),\n};\nstatic const struct regmap_access_table ws16c48_volatile_table = {\n\t.yes_ranges = ws16c48_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(ws16c48_volatile_ranges),\n};\nstatic const struct regmap_config ws16c48_regmap_config = {\n\t.reg_bits = 8,\n\t.reg_stride = 1,\n\t.val_bits = 8,\n\t.io_port = true,\n\t.wr_table = &ws16c48_wr_table,\n\t.rd_table = &ws16c48_rd_table,\n\t.volatile_table = &ws16c48_volatile_table,\n\t.cache_type = REGCACHE_FLAT,\n\t.use_raw_spinlock = true,\n};\n\n#define WS16C48_NGPIO_PER_REG 8\n#define WS16C48_REGMAP_IRQ(_id)\t\t\t\t\t\t\t\\\n\t[_id] = {\t\t\t\t\t\t\t\t\\\n\t\t.reg_offset = (_id) / WS16C48_NGPIO_PER_REG,\t\t\t\\\n\t\t.mask = BIT((_id) % WS16C48_NGPIO_PER_REG),\t\t\t\\\n\t\t.type = {\t\t\t\t\t\t\t\\\n\t\t\t.type_reg_offset = (_id) / WS16C48_NGPIO_PER_REG,\t\\\n\t\t\t.types_supported = IRQ_TYPE_EDGE_BOTH,\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\t\\\n\t}\n\n \n#define WS16C48_NUM_IRQS 24\nstatic const struct regmap_irq ws16c48_regmap_irqs[WS16C48_NUM_IRQS] = {\n\tWS16C48_REGMAP_IRQ(0), WS16C48_REGMAP_IRQ(1), WS16C48_REGMAP_IRQ(2),  \n\tWS16C48_REGMAP_IRQ(3), WS16C48_REGMAP_IRQ(4), WS16C48_REGMAP_IRQ(5),  \n\tWS16C48_REGMAP_IRQ(6), WS16C48_REGMAP_IRQ(7), WS16C48_REGMAP_IRQ(8),  \n\tWS16C48_REGMAP_IRQ(9), WS16C48_REGMAP_IRQ(10), WS16C48_REGMAP_IRQ(11),  \n\tWS16C48_REGMAP_IRQ(12), WS16C48_REGMAP_IRQ(13), WS16C48_REGMAP_IRQ(14),  \n\tWS16C48_REGMAP_IRQ(15), WS16C48_REGMAP_IRQ(16), WS16C48_REGMAP_IRQ(17),  \n\tWS16C48_REGMAP_IRQ(18), WS16C48_REGMAP_IRQ(19), WS16C48_REGMAP_IRQ(20),  \n\tWS16C48_REGMAP_IRQ(21), WS16C48_REGMAP_IRQ(22), WS16C48_REGMAP_IRQ(23),  \n};\n\n \nstruct ws16c48_gpio {\n\tstruct regmap *map;\n\traw_spinlock_t lock;\n\tu8 irq_mask[WS16C48_NUM_IRQS / WS16C48_NGPIO_PER_REG];\n};\n\nstatic int ws16c48_handle_pre_irq(void *const irq_drv_data) __acquires(&ws16c48gpio->lock)\n{\n\tstruct ws16c48_gpio *const ws16c48gpio = irq_drv_data;\n\n\t \n\traw_spin_lock(&ws16c48gpio->lock);\n\n\treturn 0;\n}\n\nstatic int ws16c48_handle_post_irq(void *const irq_drv_data) __releases(&ws16c48gpio->lock)\n{\n\tstruct ws16c48_gpio *const ws16c48gpio = irq_drv_data;\n\n\traw_spin_unlock(&ws16c48gpio->lock);\n\n\treturn 0;\n}\n\nstatic int ws16c48_handle_mask_sync(const int index, const unsigned int mask_buf_def,\n\t\t\t\t    const unsigned int mask_buf, void *const irq_drv_data)\n{\n\tstruct ws16c48_gpio *const ws16c48gpio = irq_drv_data;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&ws16c48gpio->lock, flags);\n\n\t \n\tif (mask_buf == ws16c48gpio->irq_mask[index])\n\t\tgoto exit_unlock;\n\tws16c48gpio->irq_mask[index] = mask_buf;\n\n\tret = regmap_write(ws16c48gpio->map, WS16C48_PAGE_LOCK, ENAB_PAGE);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\t \n\tret = regmap_write(ws16c48gpio->map, WS16C48_ENAB + index, ~mask_buf);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\tret = regmap_write(ws16c48gpio->map, WS16C48_PAGE_LOCK, INT_ID_PAGE);\n\tif (ret)\n\t\tgoto exit_unlock;\n\nexit_unlock:\n\traw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\n\n\treturn ret;\n}\n\nstatic int ws16c48_set_type_config(unsigned int **const buf, const unsigned int type,\n\t\t\t\t   const struct regmap_irq *const irq_data, const int idx,\n\t\t\t\t   void *const irq_drv_data)\n{\n\tstruct ws16c48_gpio *const ws16c48gpio = irq_drv_data;\n\tunsigned int polarity;\n\tunsigned long flags;\n\tint ret;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tpolarity = irq_data->mask;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tpolarity = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&ws16c48gpio->lock, flags);\n\n\tret = regmap_write(ws16c48gpio->map, WS16C48_PAGE_LOCK, POL_PAGE);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\t \n\tret = regmap_update_bits(ws16c48gpio->map, WS16C48_POL + idx, irq_data->mask, polarity);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\tret = regmap_write(ws16c48gpio->map, WS16C48_PAGE_LOCK, INT_ID_PAGE);\n\tif (ret)\n\t\tgoto exit_unlock;\n\nexit_unlock:\n\traw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\n\n\treturn ret;\n}\n\n#define WS16C48_NGPIO 48\nstatic const char *ws16c48_names[WS16C48_NGPIO] = {\n\t\"Port 0 Bit 0\", \"Port 0 Bit 1\", \"Port 0 Bit 2\", \"Port 0 Bit 3\",\n\t\"Port 0 Bit 4\", \"Port 0 Bit 5\", \"Port 0 Bit 6\", \"Port 0 Bit 7\",\n\t\"Port 1 Bit 0\", \"Port 1 Bit 1\", \"Port 1 Bit 2\", \"Port 1 Bit 3\",\n\t\"Port 1 Bit 4\", \"Port 1 Bit 5\", \"Port 1 Bit 6\", \"Port 1 Bit 7\",\n\t\"Port 2 Bit 0\", \"Port 2 Bit 1\", \"Port 2 Bit 2\", \"Port 2 Bit 3\",\n\t\"Port 2 Bit 4\", \"Port 2 Bit 5\", \"Port 2 Bit 6\", \"Port 2 Bit 7\",\n\t\"Port 3 Bit 0\", \"Port 3 Bit 1\", \"Port 3 Bit 2\", \"Port 3 Bit 3\",\n\t\"Port 3 Bit 4\", \"Port 3 Bit 5\", \"Port 3 Bit 6\", \"Port 3 Bit 7\",\n\t\"Port 4 Bit 0\", \"Port 4 Bit 1\", \"Port 4 Bit 2\", \"Port 4 Bit 3\",\n\t\"Port 4 Bit 4\", \"Port 4 Bit 5\", \"Port 4 Bit 6\", \"Port 4 Bit 7\",\n\t\"Port 5 Bit 0\", \"Port 5 Bit 1\", \"Port 5 Bit 2\", \"Port 5 Bit 3\",\n\t\"Port 5 Bit 4\", \"Port 5 Bit 5\", \"Port 5 Bit 6\", \"Port 5 Bit 7\"\n};\n\nstatic int ws16c48_irq_init_hw(struct regmap *const map)\n{\n\tint err;\n\n\terr = regmap_write(map, WS16C48_PAGE_LOCK, ENAB_PAGE);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_write(map, WS16C48_ENAB + 0, 0x00);\n\tif (err)\n\t\treturn err;\n\terr = regmap_write(map, WS16C48_ENAB + 1, 0x00);\n\tif (err)\n\t\treturn err;\n\terr = regmap_write(map, WS16C48_ENAB + 2, 0x00);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_write(map, WS16C48_PAGE_LOCK, INT_ID_PAGE);\n}\n\nstatic int ws16c48_probe(struct device *dev, unsigned int id)\n{\n\tstruct ws16c48_gpio *ws16c48gpio;\n\tconst char *const name = dev_name(dev);\n\tint err;\n\tstruct gpio_regmap_config gpio_config = {};\n\tvoid __iomem *regs;\n\tstruct regmap_irq_chip *chip;\n\tstruct regmap_irq_chip_data *chip_data;\n\n\tws16c48gpio = devm_kzalloc(dev, sizeof(*ws16c48gpio), GFP_KERNEL);\n\tif (!ws16c48gpio)\n\t\treturn -ENOMEM;\n\n\tif (!devm_request_region(dev, base[id], WS16C48_EXTENT, name)) {\n\t\tdev_err(dev, \"Unable to lock port addresses (0x%X-0x%X)\\n\",\n\t\t\tbase[id], base[id] + WS16C48_EXTENT);\n\t\treturn -EBUSY;\n\t}\n\n\tregs = devm_ioport_map(dev, base[id], WS16C48_EXTENT);\n\tif (!regs)\n\t\treturn -ENOMEM;\n\n\tws16c48gpio->map = devm_regmap_init_mmio(dev, regs, &ws16c48_regmap_config);\n\tif (IS_ERR(ws16c48gpio->map))\n\t\treturn dev_err_probe(dev, PTR_ERR(ws16c48gpio->map),\n\t\t\t\t     \"Unable to initialize register map\\n\");\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->name = name;\n\tchip->status_base = WS16C48_INT_ID;\n\tchip->mask_base = WS16C48_ENAB;\n\tchip->ack_base = WS16C48_INT_ID;\n\tchip->num_regs = 3;\n\tchip->irqs = ws16c48_regmap_irqs;\n\tchip->num_irqs = ARRAY_SIZE(ws16c48_regmap_irqs);\n\tchip->handle_pre_irq = ws16c48_handle_pre_irq;\n\tchip->handle_post_irq = ws16c48_handle_post_irq;\n\tchip->handle_mask_sync = ws16c48_handle_mask_sync;\n\tchip->set_type_config = ws16c48_set_type_config;\n\tchip->irq_drv_data = ws16c48gpio;\n\n\traw_spin_lock_init(&ws16c48gpio->lock);\n\n\t \n\terr = ws16c48_irq_init_hw(ws16c48gpio->map);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_regmap_add_irq_chip(dev, ws16c48gpio->map, irq[id], 0, 0, chip, &chip_data);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"IRQ registration failed\\n\");\n\n\tgpio_config.parent = dev;\n\tgpio_config.regmap = ws16c48gpio->map;\n\tgpio_config.ngpio = WS16C48_NGPIO;\n\tgpio_config.names = ws16c48_names;\n\tgpio_config.reg_dat_base = GPIO_REGMAP_ADDR(WS16C48_DAT_BASE);\n\tgpio_config.reg_set_base = GPIO_REGMAP_ADDR(WS16C48_DAT_BASE);\n\t \n\tgpio_config.reg_dir_out_base = GPIO_REGMAP_ADDR(WS16C48_DAT_BASE);\n\tgpio_config.ngpio_per_reg = WS16C48_NGPIO_PER_REG;\n\tgpio_config.irq_domain = regmap_irq_get_domain(chip_data);\n\n\treturn PTR_ERR_OR_ZERO(devm_gpio_regmap_register(dev, &gpio_config));\n}\n\nstatic struct isa_driver ws16c48_driver = {\n\t.probe = ws16c48_probe,\n\t.driver = {\n\t\t.name = \"ws16c48\"\n\t},\n};\n\nmodule_isa_driver_with_irq(ws16c48_driver, num_ws16c48, num_irq);\n\nMODULE_AUTHOR(\"William Breathitt Gray <vilhelm.gray@gmail.com>\");\nMODULE_DESCRIPTION(\"WinSystems WS16C48 GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}