{
  "module_name": "gpio-it87.c",
  "hash_id": "ab6591519fc646f918e94222b8541b372fbe1eb8b54e4ee8445730af72100ce2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-it87.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/gpio/driver.h>\n\n \n#define NO_DEV_ID\t0xffff\n#define IT8613_ID\t0x8613\n#define IT8620_ID\t0x8620\n#define IT8628_ID\t0x8628\n#define IT8718_ID       0x8718\n#define IT8728_ID\t0x8728\n#define IT8732_ID\t0x8732\n#define IT8761_ID\t0x8761\n#define IT8772_ID\t0x8772\n#define IT8786_ID\t0x8786\n\n \n#define REG\t\t0x2e\n#define VAL\t\t0x2f\n\n \n#define GPIO\t\t0x07\n\n \n#define LDNREG\t\t0x07\n#define CHIPID\t\t0x20\n#define CHIPREV\t\t0x22\n\n \nstruct it87_gpio {\n\tstruct gpio_chip chip;\n\tspinlock_t lock;\n\tu16 io_base;\n\tu16 io_size;\n\tu8 output_base;\n\tu8 simple_base;\n\tu8 simple_size;\n};\n\nstatic struct it87_gpio it87_gpio_chip = {\n\t.lock = __SPIN_LOCK_UNLOCKED(it87_gpio_chip.lock),\n};\n\n \n\nstatic inline int superio_enter(void)\n{\n\t \n\tif (!request_muxed_region(REG, 2, KBUILD_MODNAME))\n\t\treturn -EBUSY;\n\n\toutb(0x87, REG);\n\toutb(0x01, REG);\n\toutb(0x55, REG);\n\toutb(0x55, REG);\n\treturn 0;\n}\n\nstatic inline void superio_exit(void)\n{\n\toutb(0x02, REG);\n\toutb(0x02, VAL);\n\trelease_region(REG, 2);\n}\n\nstatic inline void superio_select(int ldn)\n{\n\toutb(LDNREG, REG);\n\toutb(ldn, VAL);\n}\n\nstatic inline int superio_inb(int reg)\n{\n\toutb(reg, REG);\n\treturn inb(VAL);\n}\n\nstatic inline void superio_outb(int val, int reg)\n{\n\toutb(reg, REG);\n\toutb(val, VAL);\n}\n\nstatic inline int superio_inw(int reg)\n{\n\tint val;\n\n\toutb(reg++, REG);\n\tval = inb(VAL) << 8;\n\toutb(reg, REG);\n\tval |= inb(VAL);\n\treturn val;\n}\n\nstatic inline void superio_set_mask(int mask, int reg)\n{\n\tu8 curr_val = superio_inb(reg);\n\tu8 new_val = curr_val | mask;\n\n\tif (curr_val != new_val)\n\t\tsuperio_outb(new_val, reg);\n}\n\nstatic inline void superio_clear_mask(int mask, int reg)\n{\n\tu8 curr_val = superio_inb(reg);\n\tu8 new_val = curr_val & ~mask;\n\n\tif (curr_val != new_val)\n\t\tsuperio_outb(new_val, reg);\n}\n\nstatic int it87_gpio_request(struct gpio_chip *chip, unsigned gpio_num)\n{\n\tu8 mask, group;\n\tint rc = 0;\n\tstruct it87_gpio *it87_gpio = gpiochip_get_data(chip);\n\n\tmask = 1 << (gpio_num % 8);\n\tgroup = (gpio_num / 8);\n\n\tspin_lock(&it87_gpio->lock);\n\n\trc = superio_enter();\n\tif (rc)\n\t\tgoto exit;\n\n\t \n\tif (group < it87_gpio->simple_size)\n\t\tsuperio_set_mask(mask, group + it87_gpio->simple_base);\n\n\t \n\tsuperio_clear_mask(mask, group + it87_gpio->output_base);\n\n\tsuperio_exit();\n\nexit:\n\tspin_unlock(&it87_gpio->lock);\n\treturn rc;\n}\n\nstatic int it87_gpio_get(struct gpio_chip *chip, unsigned gpio_num)\n{\n\tu16 reg;\n\tu8 mask;\n\tstruct it87_gpio *it87_gpio = gpiochip_get_data(chip);\n\n\tmask = 1 << (gpio_num % 8);\n\treg = (gpio_num / 8) + it87_gpio->io_base;\n\n\treturn !!(inb(reg) & mask);\n}\n\nstatic int it87_gpio_direction_in(struct gpio_chip *chip, unsigned gpio_num)\n{\n\tu8 mask, group;\n\tint rc = 0;\n\tstruct it87_gpio *it87_gpio = gpiochip_get_data(chip);\n\n\tmask = 1 << (gpio_num % 8);\n\tgroup = (gpio_num / 8);\n\n\tspin_lock(&it87_gpio->lock);\n\n\trc = superio_enter();\n\tif (rc)\n\t\tgoto exit;\n\n\t \n\tsuperio_clear_mask(mask, group + it87_gpio->output_base);\n\n\tsuperio_exit();\n\nexit:\n\tspin_unlock(&it87_gpio->lock);\n\treturn rc;\n}\n\nstatic void it87_gpio_set(struct gpio_chip *chip,\n\t\t\t  unsigned gpio_num, int val)\n{\n\tu8 mask, curr_vals;\n\tu16 reg;\n\tstruct it87_gpio *it87_gpio = gpiochip_get_data(chip);\n\n\tmask = 1 << (gpio_num % 8);\n\treg = (gpio_num / 8) + it87_gpio->io_base;\n\n\tcurr_vals = inb(reg);\n\tif (val)\n\t\toutb(curr_vals | mask, reg);\n\telse\n\t\toutb(curr_vals & ~mask, reg);\n}\n\nstatic int it87_gpio_direction_out(struct gpio_chip *chip,\n\t\t\t\t   unsigned gpio_num, int val)\n{\n\tu8 mask, group;\n\tint rc = 0;\n\tstruct it87_gpio *it87_gpio = gpiochip_get_data(chip);\n\n\tmask = 1 << (gpio_num % 8);\n\tgroup = (gpio_num / 8);\n\n\tspin_lock(&it87_gpio->lock);\n\n\trc = superio_enter();\n\tif (rc)\n\t\tgoto exit;\n\n\t \n\tsuperio_set_mask(mask, group + it87_gpio->output_base);\n\n\tit87_gpio_set(chip, gpio_num, val);\n\n\tsuperio_exit();\n\nexit:\n\tspin_unlock(&it87_gpio->lock);\n\treturn rc;\n}\n\nstatic const struct gpio_chip it87_template_chip = {\n\t.label\t\t\t= KBUILD_MODNAME,\n\t.owner\t\t\t= THIS_MODULE,\n\t.request\t\t= it87_gpio_request,\n\t.get\t\t\t= it87_gpio_get,\n\t.direction_input\t= it87_gpio_direction_in,\n\t.set\t\t\t= it87_gpio_set,\n\t.direction_output\t= it87_gpio_direction_out,\n\t.base\t\t\t= -1\n};\n\nstatic int __init it87_gpio_init(void)\n{\n\tint rc = 0, i;\n\tu16 chip_type;\n\tu8 chip_rev, gpio_ba_reg;\n\tchar *labels, **labels_table;\n\n\tstruct it87_gpio *it87_gpio = &it87_gpio_chip;\n\n\trc = superio_enter();\n\tif (rc)\n\t\treturn rc;\n\n\tchip_type = superio_inw(CHIPID);\n\tchip_rev  = superio_inb(CHIPREV) & 0x0f;\n\tsuperio_exit();\n\n\tit87_gpio->chip = it87_template_chip;\n\n\tswitch (chip_type) {\n\tcase IT8613_ID:\n\t\tgpio_ba_reg = 0x62;\n\t\tit87_gpio->io_size = 8;   \n\t\tit87_gpio->output_base = 0xc8;\n\t\tit87_gpio->simple_base = 0xc0;\n\t\tit87_gpio->simple_size = 6;\n\t\tit87_gpio->chip.ngpio = 64;   \n\t\tbreak;\n\tcase IT8620_ID:\n\tcase IT8628_ID:\n\t\tgpio_ba_reg = 0x62;\n\t\tit87_gpio->io_size = 11;\n\t\tit87_gpio->output_base = 0xc8;\n\t\tit87_gpio->simple_size = 0;\n\t\tit87_gpio->chip.ngpio = 64;\n\t\tbreak;\n\tcase IT8718_ID:\n\tcase IT8728_ID:\n\tcase IT8732_ID:\n\tcase IT8772_ID:\n\tcase IT8786_ID:\n\t\tgpio_ba_reg = 0x62;\n\t\tit87_gpio->io_size = 8;\n\t\tit87_gpio->output_base = 0xc8;\n\t\tit87_gpio->simple_base = 0xc0;\n\t\tit87_gpio->simple_size = 5;\n\t\tit87_gpio->chip.ngpio = 64;\n\t\tbreak;\n\tcase IT8761_ID:\n\t\tgpio_ba_reg = 0x60;\n\t\tit87_gpio->io_size = 4;\n\t\tit87_gpio->output_base = 0xf0;\n\t\tit87_gpio->simple_size = 0;\n\t\tit87_gpio->chip.ngpio = 16;\n\t\tbreak;\n\tcase NO_DEV_ID:\n\t\tpr_err(\"no device\\n\");\n\t\treturn -ENODEV;\n\tdefault:\n\t\tpr_err(\"Unknown Chip found, Chip %04x Revision %x\\n\",\n\t\t       chip_type, chip_rev);\n\t\treturn -ENODEV;\n\t}\n\n\trc = superio_enter();\n\tif (rc)\n\t\treturn rc;\n\n\tsuperio_select(GPIO);\n\n\t \n\tit87_gpio->io_base = superio_inw(gpio_ba_reg);\n\n\tsuperio_exit();\n\n\tpr_info(\"Found Chip IT%04x rev %x. %u GPIO lines starting at %04xh\\n\",\n\t\tchip_type, chip_rev, it87_gpio->chip.ngpio,\n\t\tit87_gpio->io_base);\n\n\tif (!request_region(it87_gpio->io_base, it87_gpio->io_size,\n\t\t\t\t\t\t\tKBUILD_MODNAME))\n\t\treturn -EBUSY;\n\n\t \n\tlabels = kcalloc(it87_gpio->chip.ngpio, sizeof(\"it87_gpXY\"),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tlabels_table = kcalloc(it87_gpio->chip.ngpio, sizeof(const char *),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (!labels || !labels_table) {\n\t\trc = -ENOMEM;\n\t\tgoto labels_free;\n\t}\n\n\tfor (i = 0; i < it87_gpio->chip.ngpio; i++) {\n\t\tchar *label = &labels[i * sizeof(\"it87_gpXY\")];\n\n\t\tsprintf(label, \"it87_gp%u%u\", 1+(i/8), i%8);\n\t\tlabels_table[i] = label;\n\t}\n\n\tit87_gpio->chip.names = (const char *const*)labels_table;\n\n\trc = gpiochip_add_data(&it87_gpio->chip, it87_gpio);\n\tif (rc)\n\t\tgoto labels_free;\n\n\treturn 0;\n\nlabels_free:\n\tkfree(labels_table);\n\tkfree(labels);\n\trelease_region(it87_gpio->io_base, it87_gpio->io_size);\n\treturn rc;\n}\n\nstatic void __exit it87_gpio_exit(void)\n{\n\tstruct it87_gpio *it87_gpio = &it87_gpio_chip;\n\n\tgpiochip_remove(&it87_gpio->chip);\n\trelease_region(it87_gpio->io_base, it87_gpio->io_size);\n\tkfree(it87_gpio->chip.names[0]);\n\tkfree(it87_gpio->chip.names);\n}\n\nmodule_init(it87_gpio_init);\nmodule_exit(it87_gpio_exit);\n\nMODULE_AUTHOR(\"Diego Elio Petten\u00f2 <flameeyes@flameeyes.eu>\");\nMODULE_DESCRIPTION(\"GPIO interface for IT87xx Super I/O chips\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}