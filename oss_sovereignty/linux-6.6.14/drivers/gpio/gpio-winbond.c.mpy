{
  "module_name": "gpio-winbond.c",
  "hash_id": "a3687e6e1adaf49151b5912048e2fbf664b5afba6d841979cbf7a46bb1962c34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-winbond.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/gpio/driver.h>\n#include <linux/ioport.h>\n#include <linux/isa.h>\n#include <linux/module.h>\n\n#define WB_GPIO_DRIVER_NAME\t\tKBUILD_MODNAME\n\n#define WB_SIO_BASE\t\t\t0x2e\n#define WB_SIO_BASE_HIGH\t\t0x4e\n\n#define WB_SIO_EXT_ENTER_KEY\t\t0x87\n#define WB_SIO_EXT_EXIT_KEY\t\t0xaa\n\n \n\n#define WB_SIO_REG_LOGICAL\t\t0x07\n\n#define WB_SIO_REG_CHIP_MSB\t\t0x20\n#define WB_SIO_REG_CHIP_LSB\t\t0x21\n\n#define WB_SIO_CHIP_ID_W83627UHG\t0xa230\n#define WB_SIO_CHIP_ID_W83627UHG_MASK\tGENMASK(15, 4)\n\n#define WB_SIO_REG_DPD\t\t\t0x22\n#define WB_SIO_REG_DPD_UARTA\t\t4\n#define WB_SIO_REG_DPD_UARTB\t\t5\n\n#define WB_SIO_REG_IDPD\t\t0x23\n#define WB_SIO_REG_IDPD_UARTC\t\t4\n#define WB_SIO_REG_IDPD_UARTD\t\t5\n#define WB_SIO_REG_IDPD_UARTE\t\t6\n#define WB_SIO_REG_IDPD_UARTF\t\t7\n\n#define WB_SIO_REG_GLOBAL_OPT\t\t0x24\n#define WB_SIO_REG_GO_ENFDC\t\t1\n\n#define WB_SIO_REG_OVTGPIO3456\t\t0x29\n#define WB_SIO_REG_OG3456_G3PP\t\t3\n#define WB_SIO_REG_OG3456_G4PP\t\t4\n#define WB_SIO_REG_OG3456_G5PP\t\t5\n#define WB_SIO_REG_OG3456_G6PP\t\t7\n\n#define WB_SIO_REG_I2C_PS\t\t0x2a\n#define WB_SIO_REG_I2CPS_I2CFS\t\t1\n\n#define WB_SIO_REG_GPIO1_MF\t\t0x2c\n#define WB_SIO_REG_G1MF_G1PP\t\t6\n#define WB_SIO_REG_G1MF_G2PP\t\t7\n#define WB_SIO_REG_G1MF_FS_MASK\tGENMASK(1, 0)\n#define WB_SIO_REG_G1MF_FS_IR_OFF\t0\n#define WB_SIO_REG_G1MF_FS_IR\t\t1\n#define WB_SIO_REG_G1MF_FS_GPIO1\t2\n#define WB_SIO_REG_G1MF_FS_UARTB\t3\n\n \n#define WB_SIO_DEV_NONE\t\t0xff\n\n \n\n \n#define WB_SIO_DEV_UARTB\t\t0x03\n#define WB_SIO_UARTB_REG_ENABLE\t0x30\n#define WB_SIO_UARTB_ENABLE_ON\t\t0\n\n \n#define WB_SIO_DEV_UARTC\t\t0x06\n#define WB_SIO_UARTC_REG_ENABLE\t0x30\n#define WB_SIO_UARTC_ENABLE_ON\t\t0\n\n \n#define WB_SIO_DEV_GPIO34\t\t0x07\n#define WB_SIO_GPIO34_REG_ENABLE\t0x30\n#define WB_SIO_GPIO34_ENABLE_3\t\t0\n#define WB_SIO_GPIO34_ENABLE_4\t\t1\n#define WB_SIO_GPIO34_REG_IO3\t\t0xe0\n#define WB_SIO_GPIO34_REG_DATA3\t0xe1\n#define WB_SIO_GPIO34_REG_INV3\t\t0xe2\n#define WB_SIO_GPIO34_REG_IO4\t\t0xe4\n#define WB_SIO_GPIO34_REG_DATA4\t0xe5\n#define WB_SIO_GPIO34_REG_INV4\t\t0xe6\n\n \n#define WB_SIO_DEV_WDGPIO56\t\t0x08\n#define WB_SIO_WDGPIO56_REG_ENABLE\t0x30\n#define WB_SIO_WDGPIO56_ENABLE_5\t1\n#define WB_SIO_WDGPIO56_ENABLE_6\t2\n#define WB_SIO_WDGPIO56_REG_IO5\t0xe0\n#define WB_SIO_WDGPIO56_REG_DATA5\t0xe1\n#define WB_SIO_WDGPIO56_REG_INV5\t0xe2\n#define WB_SIO_WDGPIO56_REG_IO6\t0xe4\n#define WB_SIO_WDGPIO56_REG_DATA6\t0xe5\n#define WB_SIO_WDGPIO56_REG_INV6\t0xe6\n\n \n#define WB_SIO_DEV_GPIO12\t\t0x09\n#define WB_SIO_GPIO12_REG_ENABLE\t0x30\n#define WB_SIO_GPIO12_ENABLE_1\t\t0\n#define WB_SIO_GPIO12_ENABLE_2\t\t1\n#define WB_SIO_GPIO12_REG_IO1\t\t0xe0\n#define WB_SIO_GPIO12_REG_DATA1\t0xe1\n#define WB_SIO_GPIO12_REG_INV1\t\t0xe2\n#define WB_SIO_GPIO12_REG_IO2\t\t0xe4\n#define WB_SIO_GPIO12_REG_DATA2\t0xe5\n#define WB_SIO_GPIO12_REG_INV2\t\t0xe6\n\n \n#define WB_SIO_DEV_UARTD\t\t0x0d\n#define WB_SIO_UARTD_REG_ENABLE\t0x30\n#define WB_SIO_UARTD_ENABLE_ON\t\t0\n\n \n#define WB_SIO_DEV_UARTE\t\t0x0e\n#define WB_SIO_UARTE_REG_ENABLE\t0x30\n#define WB_SIO_UARTE_ENABLE_ON\t\t0\n\n \nstruct winbond_gpio_params {\n\tunsigned long base;\n\tunsigned long gpios;\n\tunsigned long ppgpios;\n\tunsigned long odgpios;\n\tbool pledgpio;\n\tbool beepgpio;\n\tbool i2cgpio;\n};\n\nstatic struct winbond_gpio_params params;\n\nstatic int winbond_sio_enter(unsigned long base)\n{\n\tif (!request_muxed_region(base, 2, WB_GPIO_DRIVER_NAME))\n\t\treturn -EBUSY;\n\n\t \n\toutb(WB_SIO_EXT_ENTER_KEY, base);\n\toutb(WB_SIO_EXT_ENTER_KEY, base);\n\n\treturn 0;\n}\n\nstatic void winbond_sio_select_logical(unsigned long base, u8 dev)\n{\n\toutb(WB_SIO_REG_LOGICAL, base);\n\toutb(dev, base + 1);\n}\n\nstatic void winbond_sio_leave(unsigned long base)\n{\n\toutb(WB_SIO_EXT_EXIT_KEY, base);\n\n\trelease_region(base, 2);\n}\n\nstatic void winbond_sio_reg_write(unsigned long base, u8 reg, u8 data)\n{\n\toutb(reg, base);\n\toutb(data, base + 1);\n}\n\nstatic u8 winbond_sio_reg_read(unsigned long base, u8 reg)\n{\n\toutb(reg, base);\n\treturn inb(base + 1);\n}\n\nstatic void winbond_sio_reg_bset(unsigned long base, u8 reg, u8 bit)\n{\n\tu8 val;\n\n\tval = winbond_sio_reg_read(base, reg);\n\tval |= BIT(bit);\n\twinbond_sio_reg_write(base, reg, val);\n}\n\nstatic void winbond_sio_reg_bclear(unsigned long base, u8 reg, u8 bit)\n{\n\tu8 val;\n\n\tval = winbond_sio_reg_read(base, reg);\n\tval &= ~BIT(bit);\n\twinbond_sio_reg_write(base, reg, val);\n}\n\nstatic bool winbond_sio_reg_btest(unsigned long base, u8 reg, u8 bit)\n{\n\treturn winbond_sio_reg_read(base, reg) & BIT(bit);\n}\n\n \nstruct winbond_gpio_port_conflict {\n\tconst char *name;\n\tu8 dev;\n\tu8 testreg;\n\tu8 testbit;\n\tbool warnonly;\n};\n\n \nstruct winbond_gpio_info {\n\tu8 dev;\n\tu8 enablereg;\n\tu8 enablebit;\n\tu8 outputreg;\n\tu8 outputppbit;\n\tu8 ioreg;\n\tu8 invreg;\n\tu8 datareg;\n\tstruct winbond_gpio_port_conflict conflict;\n};\n\nstatic const struct winbond_gpio_info winbond_gpio_infos[6] = {\n\t{  \n\t\t.dev = WB_SIO_DEV_GPIO12,\n\t\t.enablereg = WB_SIO_GPIO12_REG_ENABLE,\n\t\t.enablebit = WB_SIO_GPIO12_ENABLE_1,\n\t\t.outputreg = WB_SIO_REG_GPIO1_MF,\n\t\t.outputppbit = WB_SIO_REG_G1MF_G1PP,\n\t\t.ioreg = WB_SIO_GPIO12_REG_IO1,\n\t\t.invreg = WB_SIO_GPIO12_REG_INV1,\n\t\t.datareg = WB_SIO_GPIO12_REG_DATA1,\n\t\t.conflict = {\n\t\t\t.name = \"UARTB\",\n\t\t\t.dev = WB_SIO_DEV_UARTB,\n\t\t\t.testreg = WB_SIO_UARTB_REG_ENABLE,\n\t\t\t.testbit = WB_SIO_UARTB_ENABLE_ON,\n\t\t\t.warnonly = true\n\t\t}\n\t},\n\t{  \n\t\t.dev = WB_SIO_DEV_GPIO12,\n\t\t.enablereg = WB_SIO_GPIO12_REG_ENABLE,\n\t\t.enablebit = WB_SIO_GPIO12_ENABLE_2,\n\t\t.outputreg = WB_SIO_REG_GPIO1_MF,\n\t\t.outputppbit = WB_SIO_REG_G1MF_G2PP,\n\t\t.ioreg = WB_SIO_GPIO12_REG_IO2,\n\t\t.invreg = WB_SIO_GPIO12_REG_INV2,\n\t\t.datareg = WB_SIO_GPIO12_REG_DATA2\n\t\t \n\t},\n\t{  \n\t\t.dev = WB_SIO_DEV_GPIO34,\n\t\t.enablereg = WB_SIO_GPIO34_REG_ENABLE,\n\t\t.enablebit = WB_SIO_GPIO34_ENABLE_3,\n\t\t.outputreg = WB_SIO_REG_OVTGPIO3456,\n\t\t.outputppbit = WB_SIO_REG_OG3456_G3PP,\n\t\t.ioreg = WB_SIO_GPIO34_REG_IO3,\n\t\t.invreg = WB_SIO_GPIO34_REG_INV3,\n\t\t.datareg = WB_SIO_GPIO34_REG_DATA3,\n\t\t.conflict = {\n\t\t\t.name = \"UARTC\",\n\t\t\t.dev = WB_SIO_DEV_UARTC,\n\t\t\t.testreg = WB_SIO_UARTC_REG_ENABLE,\n\t\t\t.testbit = WB_SIO_UARTC_ENABLE_ON,\n\t\t\t.warnonly = true\n\t\t}\n\t},\n\t{  \n\t\t.dev = WB_SIO_DEV_GPIO34,\n\t\t.enablereg = WB_SIO_GPIO34_REG_ENABLE,\n\t\t.enablebit = WB_SIO_GPIO34_ENABLE_4,\n\t\t.outputreg = WB_SIO_REG_OVTGPIO3456,\n\t\t.outputppbit = WB_SIO_REG_OG3456_G4PP,\n\t\t.ioreg = WB_SIO_GPIO34_REG_IO4,\n\t\t.invreg = WB_SIO_GPIO34_REG_INV4,\n\t\t.datareg = WB_SIO_GPIO34_REG_DATA4,\n\t\t.conflict = {\n\t\t\t.name = \"UARTD\",\n\t\t\t.dev = WB_SIO_DEV_UARTD,\n\t\t\t.testreg = WB_SIO_UARTD_REG_ENABLE,\n\t\t\t.testbit = WB_SIO_UARTD_ENABLE_ON,\n\t\t\t.warnonly = true\n\t\t}\n\t},\n\t{  \n\t\t.dev = WB_SIO_DEV_WDGPIO56,\n\t\t.enablereg = WB_SIO_WDGPIO56_REG_ENABLE,\n\t\t.enablebit = WB_SIO_WDGPIO56_ENABLE_5,\n\t\t.outputreg = WB_SIO_REG_OVTGPIO3456,\n\t\t.outputppbit = WB_SIO_REG_OG3456_G5PP,\n\t\t.ioreg = WB_SIO_WDGPIO56_REG_IO5,\n\t\t.invreg = WB_SIO_WDGPIO56_REG_INV5,\n\t\t.datareg = WB_SIO_WDGPIO56_REG_DATA5,\n\t\t.conflict = {\n\t\t\t.name = \"UARTE\",\n\t\t\t.dev = WB_SIO_DEV_UARTE,\n\t\t\t.testreg = WB_SIO_UARTE_REG_ENABLE,\n\t\t\t.testbit = WB_SIO_UARTE_ENABLE_ON,\n\t\t\t.warnonly = true\n\t\t}\n\t},\n\t{  \n\t\t.dev = WB_SIO_DEV_WDGPIO56,\n\t\t.enablereg = WB_SIO_WDGPIO56_REG_ENABLE,\n\t\t.enablebit = WB_SIO_WDGPIO56_ENABLE_6,\n\t\t.outputreg = WB_SIO_REG_OVTGPIO3456,\n\t\t.outputppbit = WB_SIO_REG_OG3456_G6PP,\n\t\t.ioreg = WB_SIO_WDGPIO56_REG_IO6,\n\t\t.invreg = WB_SIO_WDGPIO56_REG_INV6,\n\t\t.datareg = WB_SIO_WDGPIO56_REG_DATA6,\n\t\t.conflict = {\n\t\t\t.name = \"FDC\",\n\t\t\t.dev = WB_SIO_DEV_NONE,\n\t\t\t.testreg = WB_SIO_REG_GLOBAL_OPT,\n\t\t\t.testbit = WB_SIO_REG_GO_ENFDC,\n\t\t\t.warnonly = false\n\t\t}\n\t}\n};\n\n \nstatic bool winbond_gpio_get_info(unsigned int *gpio_num,\n\t\t\t\t  const struct winbond_gpio_info **info)\n{\n\tbool allow_changing = true;\n\tunsigned long i;\n\n\tfor_each_set_bit(i, &params.gpios, BITS_PER_LONG) {\n\t\tif (*gpio_num < 8)\n\t\t\tbreak;\n\n\t\t*gpio_num -= 8;\n\t}\n\n\t*info = &winbond_gpio_infos[i];\n\n\t \n\tif (i == 1) {\n\t\tif (*gpio_num == 0 && !params.pledgpio)\n\t\t\tallow_changing = false;\n\t\telse if (*gpio_num == 1 && !params.beepgpio)\n\t\t\tallow_changing = false;\n\t\telse if ((*gpio_num == 5 || *gpio_num == 6) && !params.i2cgpio)\n\t\t\tallow_changing = false;\n\t}\n\n\treturn allow_changing;\n}\n\nstatic int winbond_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tunsigned long *base = gpiochip_get_data(gc);\n\tconst struct winbond_gpio_info *info;\n\tbool val;\n\tint ret;\n\n\twinbond_gpio_get_info(&offset, &info);\n\n\tret = winbond_sio_enter(*base);\n\tif (ret)\n\t\treturn ret;\n\n\twinbond_sio_select_logical(*base, info->dev);\n\n\tval = winbond_sio_reg_btest(*base, info->datareg, offset);\n\tif (winbond_sio_reg_btest(*base, info->invreg, offset))\n\t\tval = !val;\n\n\twinbond_sio_leave(*base);\n\n\treturn val;\n}\n\nstatic int winbond_gpio_direction_in(struct gpio_chip *gc, unsigned int offset)\n{\n\tunsigned long *base = gpiochip_get_data(gc);\n\tconst struct winbond_gpio_info *info;\n\tint ret;\n\n\tif (!winbond_gpio_get_info(&offset, &info))\n\t\treturn -EACCES;\n\n\tret = winbond_sio_enter(*base);\n\tif (ret)\n\t\treturn ret;\n\n\twinbond_sio_select_logical(*base, info->dev);\n\n\twinbond_sio_reg_bset(*base, info->ioreg, offset);\n\n\twinbond_sio_leave(*base);\n\n\treturn 0;\n}\n\nstatic int winbond_gpio_direction_out(struct gpio_chip *gc,\n\t\t\t\t      unsigned int offset,\n\t\t\t\t      int val)\n{\n\tunsigned long *base = gpiochip_get_data(gc);\n\tconst struct winbond_gpio_info *info;\n\tint ret;\n\n\tif (!winbond_gpio_get_info(&offset, &info))\n\t\treturn -EACCES;\n\n\tret = winbond_sio_enter(*base);\n\tif (ret)\n\t\treturn ret;\n\n\twinbond_sio_select_logical(*base, info->dev);\n\n\twinbond_sio_reg_bclear(*base, info->ioreg, offset);\n\n\tif (winbond_sio_reg_btest(*base, info->invreg, offset))\n\t\tval = !val;\n\n\tif (val)\n\t\twinbond_sio_reg_bset(*base, info->datareg, offset);\n\telse\n\t\twinbond_sio_reg_bclear(*base, info->datareg, offset);\n\n\twinbond_sio_leave(*base);\n\n\treturn 0;\n}\n\nstatic void winbond_gpio_set(struct gpio_chip *gc, unsigned int offset,\n\t\t\t     int val)\n{\n\tunsigned long *base = gpiochip_get_data(gc);\n\tconst struct winbond_gpio_info *info;\n\n\tif (!winbond_gpio_get_info(&offset, &info))\n\t\treturn;\n\n\tif (winbond_sio_enter(*base) != 0)\n\t\treturn;\n\n\twinbond_sio_select_logical(*base, info->dev);\n\n\tif (winbond_sio_reg_btest(*base, info->invreg, offset))\n\t\tval = !val;\n\n\tif (val)\n\t\twinbond_sio_reg_bset(*base, info->datareg, offset);\n\telse\n\t\twinbond_sio_reg_bclear(*base, info->datareg, offset);\n\n\twinbond_sio_leave(*base);\n}\n\nstatic struct gpio_chip winbond_gpio_chip = {\n\t.base\t\t\t= -1,\n\t.label\t\t\t= WB_GPIO_DRIVER_NAME,\n\t.owner\t\t\t= THIS_MODULE,\n\t.can_sleep\t\t= true,\n\t.get\t\t\t= winbond_gpio_get,\n\t.direction_input\t= winbond_gpio_direction_in,\n\t.set\t\t\t= winbond_gpio_set,\n\t.direction_output\t= winbond_gpio_direction_out,\n};\n\nstatic void winbond_gpio_configure_port0_pins(unsigned long base)\n{\n\tunsigned int val;\n\n\tval = winbond_sio_reg_read(base, WB_SIO_REG_GPIO1_MF);\n\tif ((val & WB_SIO_REG_G1MF_FS_MASK) == WB_SIO_REG_G1MF_FS_GPIO1)\n\t\treturn;\n\n\tpr_warn(\"GPIO1 pins were connected to something else (%.2x), fixing\\n\",\n\t\tval);\n\n\tval &= ~WB_SIO_REG_G1MF_FS_MASK;\n\tval |= WB_SIO_REG_G1MF_FS_GPIO1;\n\n\twinbond_sio_reg_write(base, WB_SIO_REG_GPIO1_MF, val);\n}\n\nstatic void winbond_gpio_configure_port1_check_i2c(unsigned long base)\n{\n\tparams.i2cgpio = !winbond_sio_reg_btest(base, WB_SIO_REG_I2C_PS,\n\t\t\t\t\t\tWB_SIO_REG_I2CPS_I2CFS);\n\tif (!params.i2cgpio)\n\t\tpr_warn(\"disabling GPIO2.5 and GPIO2.6 as I2C is enabled\\n\");\n}\n\nstatic bool winbond_gpio_configure_port(unsigned long base, unsigned int idx)\n{\n\tconst struct winbond_gpio_info *info = &winbond_gpio_infos[idx];\n\tconst struct winbond_gpio_port_conflict *conflict = &info->conflict;\n\n\t \n\tif (conflict->name != NULL) {\n\t\tif (conflict->dev != WB_SIO_DEV_NONE)\n\t\t\twinbond_sio_select_logical(base, conflict->dev);\n\n\t\tif (winbond_sio_reg_btest(base, conflict->testreg,\n\t\t\t\t\t  conflict->testbit)) {\n\t\t\tif (conflict->warnonly)\n\t\t\t\tpr_warn(\"enabled GPIO%u share pins with active %s\\n\",\n\t\t\t\t\tidx + 1, conflict->name);\n\t\t\telse {\n\t\t\t\tpr_warn(\"disabling GPIO%u as %s is enabled\\n\",\n\t\t\t\t\tidx + 1, conflict->name);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (idx == 0)\n\t\twinbond_gpio_configure_port0_pins(base);\n\telse if (idx == 1)\n\t\twinbond_gpio_configure_port1_check_i2c(base);\n\n\twinbond_sio_select_logical(base, info->dev);\n\n\twinbond_sio_reg_bset(base, info->enablereg, info->enablebit);\n\n\tif (params.ppgpios & BIT(idx))\n\t\twinbond_sio_reg_bset(base, info->outputreg,\n\t\t\t\t     info->outputppbit);\n\telse if (params.odgpios & BIT(idx))\n\t\twinbond_sio_reg_bclear(base, info->outputreg,\n\t\t\t\t       info->outputppbit);\n\telse\n\t\tpr_notice(\"GPIO%u pins are %s\\n\", idx + 1,\n\t\t\t  winbond_sio_reg_btest(base, info->outputreg,\n\t\t\t\t\t\tinfo->outputppbit) ?\n\t\t\t  \"push-pull\" :\n\t\t\t  \"open drain\");\n\n\treturn true;\n}\n\nstatic int winbond_gpio_configure(unsigned long base)\n{\n\tunsigned long i;\n\n\tfor_each_set_bit(i, &params.gpios, BITS_PER_LONG)\n\t\tif (!winbond_gpio_configure_port(base, i))\n\t\t\t__clear_bit(i, &params.gpios);\n\n\tif (!params.gpios) {\n\t\tpr_err(\"please use 'gpios' module parameter to select some active GPIO ports to enable\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int winbond_gpio_check_chip(unsigned long base)\n{\n\tint ret;\n\tunsigned int chip;\n\n\tret = winbond_sio_enter(base);\n\tif (ret)\n\t\treturn ret;\n\n\tchip = winbond_sio_reg_read(base, WB_SIO_REG_CHIP_MSB) << 8;\n\tchip |= winbond_sio_reg_read(base, WB_SIO_REG_CHIP_LSB);\n\n\tpr_notice(\"chip ID at %lx is %.4x\\n\", base, chip);\n\n\tif ((chip & WB_SIO_CHIP_ID_W83627UHG_MASK) !=\n\t    WB_SIO_CHIP_ID_W83627UHG) {\n\t\tpr_err(\"not an our chip\\n\");\n\t\tret = -ENODEV;\n\t}\n\n\twinbond_sio_leave(base);\n\n\treturn ret;\n}\n\nstatic int winbond_gpio_imatch(struct device *dev, unsigned int id)\n{\n\tunsigned long gpios_rem;\n\tint ret;\n\n\tgpios_rem = params.gpios & ~GENMASK(ARRAY_SIZE(winbond_gpio_infos) - 1,\n\t\t\t\t\t    0);\n\tif (gpios_rem) {\n\t\tpr_warn(\"unknown ports (%lx) enabled in GPIO ports bitmask\\n\",\n\t\t\tgpios_rem);\n\t\tparams.gpios &= ~gpios_rem;\n\t}\n\n\tif (params.ppgpios & params.odgpios) {\n\t\tpr_err(\"some GPIO ports are set both to push-pull and open drain mode at the same time\\n\");\n\t\treturn 0;\n\t}\n\n\tif (params.base != 0)\n\t\treturn winbond_gpio_check_chip(params.base) == 0;\n\n\t \n\tparams.base = WB_SIO_BASE;\n\tret = winbond_gpio_check_chip(params.base);\n\tif (ret == 0)\n\t\treturn 1;\n\tif (ret != -ENODEV && ret != -EBUSY)\n\t\treturn 0;\n\n\tparams.base = WB_SIO_BASE_HIGH;\n\treturn winbond_gpio_check_chip(params.base) == 0;\n}\n\nstatic int winbond_gpio_iprobe(struct device *dev, unsigned int id)\n{\n\tint ret;\n\n\tif (params.base == 0)\n\t\treturn -EINVAL;\n\n\tret = winbond_sio_enter(params.base);\n\tif (ret)\n\t\treturn ret;\n\n\tret = winbond_gpio_configure(params.base);\n\n\twinbond_sio_leave(params.base);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twinbond_gpio_chip.ngpio = hweight_long(params.gpios) * 8;\n\n\t \n\tif (params.gpios & BIT(5))\n\t\twinbond_gpio_chip.ngpio -= (8 - 5);\n\n\twinbond_gpio_chip.parent = dev;\n\n\treturn devm_gpiochip_add_data(dev, &winbond_gpio_chip, &params.base);\n}\n\nstatic struct isa_driver winbond_gpio_idriver = {\n\t.driver = {\n\t\t.name\t= WB_GPIO_DRIVER_NAME,\n\t},\n\t.match\t= winbond_gpio_imatch,\n\t.probe\t= winbond_gpio_iprobe,\n};\n\nmodule_isa_driver(winbond_gpio_idriver, 1);\n\nmodule_param_named(base, params.base, ulong, 0444);\nMODULE_PARM_DESC(base,\n\t\t \"I/O port base (when unset - probe chip default ones)\");\n\n \nmodule_param_named(gpios, params.gpios, ulong, 0444);\nMODULE_PARM_DESC(gpios,\n\t\t \"bitmask of GPIO ports to enable (bit 0 - GPIO1, bit 1 - GPIO2, etc.\");\n\n \nmodule_param_named(ppgpios, params.ppgpios, ulong, 0444);\nMODULE_PARM_DESC(ppgpios,\n\t\t \"bitmask of GPIO ports to set to push-pull mode (bit 0 - GPIO1, bit 1 - GPIO2, etc.\");\n\nmodule_param_named(odgpios, params.odgpios, ulong, 0444);\nMODULE_PARM_DESC(odgpios,\n\t\t \"bitmask of GPIO ports to set to open drain mode (bit 0 - GPIO1, bit 1 - GPIO2, etc.\");\n\n \nmodule_param_named(pledgpio, params.pledgpio, bool, 0644);\nMODULE_PARM_DESC(pledgpio,\n\t\t \"enable changing value of GPIO2.0 bit (Power LED), default no.\");\n\nmodule_param_named(beepgpio, params.beepgpio, bool, 0644);\nMODULE_PARM_DESC(beepgpio,\n\t\t \"enable changing value of GPIO2.1 bit (BEEP), default no.\");\n\nMODULE_AUTHOR(\"Maciej S. Szmigiero <mail@maciej.szmigiero.name>\");\nMODULE_DESCRIPTION(\"GPIO interface for Winbond Super I/O chips\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}