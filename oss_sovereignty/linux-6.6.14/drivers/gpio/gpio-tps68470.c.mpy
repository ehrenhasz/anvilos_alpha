{
  "module_name": "gpio-tps68470.c",
  "hash_id": "520bb033f633cba829f0db81a62f744c975d21414cad60d01fa3f8e871785520",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-tps68470.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/mfd/tps68470.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define TPS68470_N_LOGIC_OUTPUT\t3\n#define TPS68470_N_REGULAR_GPIO\t7\n#define TPS68470_N_GPIO\t(TPS68470_N_LOGIC_OUTPUT + TPS68470_N_REGULAR_GPIO)\n\nstruct tps68470_gpio_data {\n\tstruct regmap *tps68470_regmap;\n\tstruct gpio_chip gc;\n};\n\nstatic int tps68470_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct tps68470_gpio_data *tps68470_gpio = gpiochip_get_data(gc);\n\tstruct regmap *regmap = tps68470_gpio->tps68470_regmap;\n\tunsigned int reg = TPS68470_REG_GPDO;\n\tint val, ret;\n\n\tif (offset >= TPS68470_N_REGULAR_GPIO) {\n\t\toffset -= TPS68470_N_REGULAR_GPIO;\n\t\treg = TPS68470_REG_SGPO;\n\t}\n\n\tret = regmap_read(regmap, reg, &val);\n\tif (ret) {\n\t\tdev_err(tps68470_gpio->gc.parent, \"reg 0x%x read failed\\n\",\n\t\t\tTPS68470_REG_SGPO);\n\t\treturn ret;\n\t}\n\treturn !!(val & BIT(offset));\n}\n\nstatic int tps68470_gpio_get_direction(struct gpio_chip *gc,\n\t\t\t\t       unsigned int offset)\n{\n\tstruct tps68470_gpio_data *tps68470_gpio = gpiochip_get_data(gc);\n\tstruct regmap *regmap = tps68470_gpio->tps68470_regmap;\n\tint val, ret;\n\n\t \n\tif (offset >= TPS68470_N_REGULAR_GPIO)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\tret = regmap_read(regmap, TPS68470_GPIO_CTL_REG_A(offset), &val);\n\tif (ret) {\n\t\tdev_err(tps68470_gpio->gc.parent, \"reg 0x%x read failed\\n\",\n\t\t\tTPS68470_GPIO_CTL_REG_A(offset));\n\t\treturn ret;\n\t}\n\n\tval &= TPS68470_GPIO_MODE_MASK;\n\treturn val >= TPS68470_GPIO_MODE_OUT_CMOS ? GPIO_LINE_DIRECTION_OUT :\n\t\t\t\t\t\t    GPIO_LINE_DIRECTION_IN;\n}\n\nstatic void tps68470_gpio_set(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\tint value)\n{\n\tstruct tps68470_gpio_data *tps68470_gpio = gpiochip_get_data(gc);\n\tstruct regmap *regmap = tps68470_gpio->tps68470_regmap;\n\tunsigned int reg = TPS68470_REG_GPDO;\n\n\tif (offset >= TPS68470_N_REGULAR_GPIO) {\n\t\treg = TPS68470_REG_SGPO;\n\t\toffset -= TPS68470_N_REGULAR_GPIO;\n\t}\n\n\tregmap_update_bits(regmap, reg, BIT(offset), value ? BIT(offset) : 0);\n}\n\nstatic int tps68470_gpio_output(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\tint value)\n{\n\tstruct tps68470_gpio_data *tps68470_gpio = gpiochip_get_data(gc);\n\tstruct regmap *regmap = tps68470_gpio->tps68470_regmap;\n\n\t \n\ttps68470_gpio_set(gc, offset, value);\n\n\t \n\tif (offset >= TPS68470_N_REGULAR_GPIO)\n\t\treturn 0;\n\n\treturn regmap_update_bits(regmap, TPS68470_GPIO_CTL_REG_A(offset),\n\t\t\t\t TPS68470_GPIO_MODE_MASK,\n\t\t\t\t TPS68470_GPIO_MODE_OUT_CMOS);\n}\n\nstatic int tps68470_gpio_input(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct tps68470_gpio_data *tps68470_gpio = gpiochip_get_data(gc);\n\tstruct regmap *regmap = tps68470_gpio->tps68470_regmap;\n\n\t \n\tif (offset >= TPS68470_N_REGULAR_GPIO)\n\t\treturn -EINVAL;\n\n\treturn regmap_update_bits(regmap, TPS68470_GPIO_CTL_REG_A(offset),\n\t\t\t\t   TPS68470_GPIO_MODE_MASK, 0x00);\n}\n\nstatic const char *tps68470_names[TPS68470_N_GPIO] = {\n\t\"gpio.0\", \"gpio.1\", \"gpio.2\", \"gpio.3\",\n\t\"gpio.4\", \"gpio.5\", \"gpio.6\",\n\t\"s_enable\", \"s_idle\", \"s_resetn\",\n};\n\nstatic int tps68470_gpio_probe(struct platform_device *pdev)\n{\n\tstruct tps68470_gpio_data *tps68470_gpio;\n\n\ttps68470_gpio = devm_kzalloc(&pdev->dev, sizeof(*tps68470_gpio),\n\t\t\t\t     GFP_KERNEL);\n\tif (!tps68470_gpio)\n\t\treturn -ENOMEM;\n\n\ttps68470_gpio->tps68470_regmap = dev_get_drvdata(pdev->dev.parent);\n\ttps68470_gpio->gc.label = \"tps68470-gpio\";\n\ttps68470_gpio->gc.owner = THIS_MODULE;\n\ttps68470_gpio->gc.direction_input = tps68470_gpio_input;\n\ttps68470_gpio->gc.direction_output = tps68470_gpio_output;\n\ttps68470_gpio->gc.get = tps68470_gpio_get;\n\ttps68470_gpio->gc.get_direction = tps68470_gpio_get_direction;\n\ttps68470_gpio->gc.set = tps68470_gpio_set;\n\ttps68470_gpio->gc.can_sleep = true;\n\ttps68470_gpio->gc.names = tps68470_names;\n\ttps68470_gpio->gc.ngpio = TPS68470_N_GPIO;\n\ttps68470_gpio->gc.base = -1;\n\ttps68470_gpio->gc.parent = &pdev->dev;\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &tps68470_gpio->gc, tps68470_gpio);\n}\n\nstatic struct platform_driver tps68470_gpio_driver = {\n\t.driver = {\n\t\t   .name = \"tps68470-gpio\",\n\t},\n\t.probe = tps68470_gpio_probe,\n};\nmodule_platform_driver(tps68470_gpio_driver);\n\nMODULE_ALIAS(\"platform:tps68470-gpio\");\nMODULE_DESCRIPTION(\"GPIO driver for TPS68470 PMIC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}