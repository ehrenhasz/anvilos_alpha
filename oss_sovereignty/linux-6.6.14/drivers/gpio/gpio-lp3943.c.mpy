{
  "module_name": "gpio-lp3943.c",
  "hash_id": "e16e14ef7e11d13e815e0fa18a10fe45f23e96e6e0b9626d54d3dfb849670333",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-lp3943.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/mfd/lp3943.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\nenum lp3943_gpios {\n\tLP3943_GPIO1,\n\tLP3943_GPIO2,\n\tLP3943_GPIO3,\n\tLP3943_GPIO4,\n\tLP3943_GPIO5,\n\tLP3943_GPIO6,\n\tLP3943_GPIO7,\n\tLP3943_GPIO8,\n\tLP3943_GPIO9,\n\tLP3943_GPIO10,\n\tLP3943_GPIO11,\n\tLP3943_GPIO12,\n\tLP3943_GPIO13,\n\tLP3943_GPIO14,\n\tLP3943_GPIO15,\n\tLP3943_GPIO16,\n\tLP3943_MAX_GPIO,\n};\n\nstruct lp3943_gpio {\n\tstruct gpio_chip chip;\n\tstruct lp3943 *lp3943;\n\tu16 input_mask;\t\t \n};\n\nstatic int lp3943_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct lp3943_gpio *lp3943_gpio = gpiochip_get_data(chip);\n\tstruct lp3943 *lp3943 = lp3943_gpio->lp3943;\n\n\t \n\tif (test_and_set_bit(offset, &lp3943->pin_used))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic void lp3943_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct lp3943_gpio *lp3943_gpio = gpiochip_get_data(chip);\n\tstruct lp3943 *lp3943 = lp3943_gpio->lp3943;\n\n\tclear_bit(offset, &lp3943->pin_used);\n}\n\nstatic int lp3943_gpio_set_mode(struct lp3943_gpio *lp3943_gpio, u8 offset,\n\t\t\t\tu8 val)\n{\n\tstruct lp3943 *lp3943 = lp3943_gpio->lp3943;\n\tconst struct lp3943_reg_cfg *mux = lp3943->mux_cfg;\n\n\treturn lp3943_update_bits(lp3943, mux[offset].reg, mux[offset].mask,\n\t\t\t\t  val << mux[offset].shift);\n}\n\nstatic int lp3943_gpio_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct lp3943_gpio *lp3943_gpio = gpiochip_get_data(chip);\n\n\tlp3943_gpio->input_mask |= BIT(offset);\n\n\treturn lp3943_gpio_set_mode(lp3943_gpio, offset, LP3943_GPIO_IN);\n}\n\nstatic int lp3943_get_gpio_in_status(struct lp3943_gpio *lp3943_gpio,\n\t\t\t\t     struct gpio_chip *chip, unsigned int offset)\n{\n\tu8 addr, read;\n\tint err;\n\n\tswitch (offset) {\n\tcase LP3943_GPIO1 ... LP3943_GPIO8:\n\t\taddr = LP3943_REG_GPIO_A;\n\t\tbreak;\n\tcase LP3943_GPIO9 ... LP3943_GPIO16:\n\t\taddr = LP3943_REG_GPIO_B;\n\t\toffset = offset - 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = lp3943_read_byte(lp3943_gpio->lp3943, addr, &read);\n\tif (err)\n\t\treturn err;\n\n\treturn !!(read & BIT(offset));\n}\n\nstatic int lp3943_get_gpio_out_status(struct lp3943_gpio *lp3943_gpio,\n\t\t\t\t      struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct lp3943 *lp3943 = lp3943_gpio->lp3943;\n\tconst struct lp3943_reg_cfg *mux = lp3943->mux_cfg;\n\tu8 read;\n\tint err;\n\n\terr = lp3943_read_byte(lp3943, mux[offset].reg, &read);\n\tif (err)\n\t\treturn err;\n\n\tread = (read & mux[offset].mask) >> mux[offset].shift;\n\n\tif (read == LP3943_GPIO_OUT_HIGH)\n\t\treturn 1;\n\telse if (read == LP3943_GPIO_OUT_LOW)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int lp3943_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct lp3943_gpio *lp3943_gpio = gpiochip_get_data(chip);\n\n\t \n\n\tif (lp3943_gpio->input_mask & BIT(offset))\n\t\treturn lp3943_get_gpio_in_status(lp3943_gpio, chip, offset);\n\telse\n\t\treturn lp3943_get_gpio_out_status(lp3943_gpio, chip, offset);\n}\n\nstatic void lp3943_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct lp3943_gpio *lp3943_gpio = gpiochip_get_data(chip);\n\tu8 data;\n\n\tif (value)\n\t\tdata = LP3943_GPIO_OUT_HIGH;\n\telse\n\t\tdata = LP3943_GPIO_OUT_LOW;\n\n\tlp3943_gpio_set_mode(lp3943_gpio, offset, data);\n}\n\nstatic int lp3943_gpio_direction_output(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t\tint value)\n{\n\tstruct lp3943_gpio *lp3943_gpio = gpiochip_get_data(chip);\n\n\tlp3943_gpio_set(chip, offset, value);\n\tlp3943_gpio->input_mask &= ~BIT(offset);\n\n\treturn 0;\n}\n\nstatic const struct gpio_chip lp3943_gpio_chip = {\n\t.label\t\t\t= \"lp3943\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.request\t\t= lp3943_gpio_request,\n\t.free\t\t\t= lp3943_gpio_free,\n\t.direction_input\t= lp3943_gpio_direction_input,\n\t.get\t\t\t= lp3943_gpio_get,\n\t.direction_output\t= lp3943_gpio_direction_output,\n\t.set\t\t\t= lp3943_gpio_set,\n\t.base\t\t\t= -1,\n\t.ngpio\t\t\t= LP3943_MAX_GPIO,\n\t.can_sleep\t\t= 1,\n};\n\nstatic int lp3943_gpio_probe(struct platform_device *pdev)\n{\n\tstruct lp3943 *lp3943 = dev_get_drvdata(pdev->dev.parent);\n\tstruct lp3943_gpio *lp3943_gpio;\n\n\tlp3943_gpio = devm_kzalloc(&pdev->dev, sizeof(*lp3943_gpio),\n\t\t\t\tGFP_KERNEL);\n\tif (!lp3943_gpio)\n\t\treturn -ENOMEM;\n\n\tlp3943_gpio->lp3943 = lp3943;\n\tlp3943_gpio->chip = lp3943_gpio_chip;\n\tlp3943_gpio->chip.parent = &pdev->dev;\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &lp3943_gpio->chip,\n\t\t\t\t      lp3943_gpio);\n}\n\nstatic const struct of_device_id lp3943_gpio_of_match[] = {\n\t{ .compatible = \"ti,lp3943-gpio\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lp3943_gpio_of_match);\n\nstatic struct platform_driver lp3943_gpio_driver = {\n\t.probe = lp3943_gpio_probe,\n\t.driver = {\n\t\t.name = \"lp3943-gpio\",\n\t\t.of_match_table = lp3943_gpio_of_match,\n\t},\n};\nmodule_platform_driver(lp3943_gpio_driver);\n\nMODULE_DESCRIPTION(\"LP3943 GPIO driver\");\nMODULE_ALIAS(\"platform:lp3943-gpio\");\nMODULE_AUTHOR(\"Milo Kim\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}