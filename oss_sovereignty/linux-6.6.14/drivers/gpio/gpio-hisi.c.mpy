{
  "module_name": "gpio-hisi.c",
  "hash_id": "9df1909624e1b89ae8a595cb2b4e90a2bbf6d3dcd0d5acc2455bcdfe6c38a621",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-hisi.c",
  "human_readable_source": "\n \n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#define HISI_GPIO_SWPORT_DR_SET_WX\t0x000\n#define HISI_GPIO_SWPORT_DR_CLR_WX\t0x004\n#define HISI_GPIO_SWPORT_DDR_SET_WX\t0x010\n#define HISI_GPIO_SWPORT_DDR_CLR_WX\t0x014\n#define HISI_GPIO_SWPORT_DDR_ST_WX\t0x018\n#define HISI_GPIO_INTEN_SET_WX\t\t0x020\n#define HISI_GPIO_INTEN_CLR_WX\t\t0x024\n#define HISI_GPIO_INTMASK_SET_WX\t0x030\n#define HISI_GPIO_INTMASK_CLR_WX\t0x034\n#define HISI_GPIO_INTTYPE_EDGE_SET_WX\t0x040\n#define HISI_GPIO_INTTYPE_EDGE_CLR_WX\t0x044\n#define HISI_GPIO_INT_POLARITY_SET_WX\t0x050\n#define HISI_GPIO_INT_POLARITY_CLR_WX\t0x054\n#define HISI_GPIO_DEBOUNCE_SET_WX\t0x060\n#define HISI_GPIO_DEBOUNCE_CLR_WX\t0x064\n#define HISI_GPIO_INTSTATUS_WX\t\t0x070\n#define HISI_GPIO_PORTA_EOI_WX\t\t0x078\n#define HISI_GPIO_EXT_PORT_WX\t\t0x080\n#define HISI_GPIO_INTCOMB_MASK_WX\t0x0a0\n#define HISI_GPIO_INT_DEDGE_SET\t\t0x0b0\n#define HISI_GPIO_INT_DEDGE_CLR\t\t0x0b4\n#define HISI_GPIO_INT_DEDGE_ST\t\t0x0b8\n\n#define HISI_GPIO_LINE_NUM_MAX\t32\n#define HISI_GPIO_DRIVER_NAME\t\"gpio-hisi\"\n\nstruct hisi_gpio {\n\tstruct gpio_chip\tchip;\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*reg_base;\n\tunsigned int\t\tline_num;\n\tint\t\t\tirq;\n};\n\nstatic inline u32 hisi_gpio_read_reg(struct gpio_chip *chip,\n\t\t\t\t     unsigned int off)\n{\n\tstruct hisi_gpio *hisi_gpio =\n\t\t\tcontainer_of(chip, struct hisi_gpio, chip);\n\tvoid __iomem *reg = hisi_gpio->reg_base + off;\n\n\treturn readl(reg);\n}\n\nstatic inline void hisi_gpio_write_reg(struct gpio_chip *chip,\n\t\t\t\t       unsigned int off, u32 val)\n{\n\tstruct hisi_gpio *hisi_gpio =\n\t\t\tcontainer_of(chip, struct hisi_gpio, chip);\n\tvoid __iomem *reg = hisi_gpio->reg_base + off;\n\n\twritel(val, reg);\n}\n\nstatic void hisi_gpio_set_debounce(struct gpio_chip *chip, unsigned int off,\n\t\t\t\t   u32 debounce)\n{\n\tif (debounce)\n\t\thisi_gpio_write_reg(chip, HISI_GPIO_DEBOUNCE_SET_WX, BIT(off));\n\telse\n\t\thisi_gpio_write_reg(chip, HISI_GPIO_DEBOUNCE_CLR_WX, BIT(off));\n}\n\nstatic int hisi_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\tunsigned long config)\n{\n\tu32 config_para = pinconf_to_config_param(config);\n\tu32 config_arg;\n\n\tswitch (config_para) {\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\tconfig_arg = pinconf_to_config_argument(config);\n\t\thisi_gpio_set_debounce(chip, offset, config_arg);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void hisi_gpio_set_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\n\thisi_gpio_write_reg(chip, HISI_GPIO_PORTA_EOI_WX, BIT(irqd_to_hwirq(d)));\n}\n\nstatic void hisi_gpio_irq_set_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\n\thisi_gpio_write_reg(chip, HISI_GPIO_INTMASK_SET_WX, BIT(irqd_to_hwirq(d)));\n\tgpiochip_disable_irq(chip, irqd_to_hwirq(d));\n}\n\nstatic void hisi_gpio_irq_clr_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_enable_irq(chip, irqd_to_hwirq(d));\n\thisi_gpio_write_reg(chip, HISI_GPIO_INTMASK_CLR_WX, BIT(irqd_to_hwirq(d)));\n}\n\nstatic int hisi_gpio_irq_set_type(struct irq_data *d, u32 type)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tunsigned int mask = BIT(irqd_to_hwirq(d));\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\thisi_gpio_write_reg(chip, HISI_GPIO_INT_DEDGE_SET, mask);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\thisi_gpio_write_reg(chip, HISI_GPIO_INTTYPE_EDGE_SET_WX, mask);\n\t\thisi_gpio_write_reg(chip, HISI_GPIO_INT_POLARITY_SET_WX, mask);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\thisi_gpio_write_reg(chip, HISI_GPIO_INTTYPE_EDGE_SET_WX, mask);\n\t\thisi_gpio_write_reg(chip, HISI_GPIO_INT_POLARITY_CLR_WX, mask);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\thisi_gpio_write_reg(chip, HISI_GPIO_INTTYPE_EDGE_CLR_WX, mask);\n\t\thisi_gpio_write_reg(chip, HISI_GPIO_INT_POLARITY_SET_WX, mask);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\thisi_gpio_write_reg(chip, HISI_GPIO_INTTYPE_EDGE_CLR_WX, mask);\n\t\thisi_gpio_write_reg(chip, HISI_GPIO_INT_POLARITY_CLR_WX, mask);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (type != IRQ_TYPE_EDGE_BOTH) {\n\t\tunsigned int both = hisi_gpio_read_reg(chip, HISI_GPIO_INT_DEDGE_ST);\n\n\t\tif (both & mask)\n\t\t\thisi_gpio_write_reg(chip, HISI_GPIO_INT_DEDGE_CLR, mask);\n\t}\n\n\tif (type & IRQ_TYPE_LEVEL_MASK)\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\telse if (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\n\treturn 0;\n}\n\nstatic void hisi_gpio_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\n\thisi_gpio_irq_clr_mask(d);\n\thisi_gpio_write_reg(chip, HISI_GPIO_INTEN_SET_WX, BIT(irqd_to_hwirq(d)));\n}\n\nstatic void hisi_gpio_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\n\thisi_gpio_irq_set_mask(d);\n\thisi_gpio_write_reg(chip, HISI_GPIO_INTEN_CLR_WX, BIT(irqd_to_hwirq(d)));\n}\n\nstatic void hisi_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct hisi_gpio *hisi_gpio = irq_desc_get_handler_data(desc);\n\tunsigned long irq_msk = hisi_gpio_read_reg(&hisi_gpio->chip,\n\t\t\t\t\t\t   HISI_GPIO_INTSTATUS_WX);\n\tstruct irq_chip *irq_c = irq_desc_get_chip(desc);\n\tint hwirq;\n\n\tchained_irq_enter(irq_c, desc);\n\tfor_each_set_bit(hwirq, &irq_msk, HISI_GPIO_LINE_NUM_MAX)\n\t\tgeneric_handle_domain_irq(hisi_gpio->chip.irq.domain,\n\t\t\t\t\t  hwirq);\n\tchained_irq_exit(irq_c, desc);\n}\n\nstatic const struct irq_chip hisi_gpio_irq_chip = {\n\t.name = \"HISI-GPIO\",\n\t.irq_ack = hisi_gpio_set_ack,\n\t.irq_mask = hisi_gpio_irq_set_mask,\n\t.irq_unmask = hisi_gpio_irq_clr_mask,\n\t.irq_set_type = hisi_gpio_irq_set_type,\n\t.irq_enable = hisi_gpio_irq_enable,\n\t.irq_disable = hisi_gpio_irq_disable,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void hisi_gpio_init_irq(struct hisi_gpio *hisi_gpio)\n{\n\tstruct gpio_chip *chip = &hisi_gpio->chip;\n\tstruct gpio_irq_chip *girq_chip = &chip->irq;\n\n\tgpio_irq_chip_set_chip(girq_chip, &hisi_gpio_irq_chip);\n\tgirq_chip->default_type = IRQ_TYPE_NONE;\n\tgirq_chip->num_parents = 1;\n\tgirq_chip->parents = &hisi_gpio->irq;\n\tgirq_chip->parent_handler = hisi_gpio_irq_handler;\n\tgirq_chip->parent_handler_data = hisi_gpio;\n\n\t \n\thisi_gpio_write_reg(chip, HISI_GPIO_INTCOMB_MASK_WX, 1);\n}\n\nstatic const struct acpi_device_id hisi_gpio_acpi_match[] = {\n\t{\"HISI0184\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, hisi_gpio_acpi_match);\n\nstatic const struct of_device_id hisi_gpio_dts_match[] = {\n\t{ .compatible = \"hisilicon,ascend910-gpio\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, hisi_gpio_dts_match);\n\nstatic void hisi_gpio_get_pdata(struct device *dev,\n\t\t\t\tstruct hisi_gpio *hisi_gpio)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct fwnode_handle *fwnode;\n\tint idx = 0;\n\n\tdevice_for_each_child_node(dev, fwnode)  {\n\t\t \n\t\tif (fwnode_property_read_u32(fwnode, \"ngpios\",\n\t\t\t\t\t     &hisi_gpio->line_num)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to get number of lines for port%d and use default value instead\\n\",\n\t\t\t\tidx);\n\t\t\thisi_gpio->line_num = HISI_GPIO_LINE_NUM_MAX;\n\t\t}\n\n\t\tif (WARN_ON(hisi_gpio->line_num > HISI_GPIO_LINE_NUM_MAX))\n\t\t\thisi_gpio->line_num = HISI_GPIO_LINE_NUM_MAX;\n\n\t\thisi_gpio->irq = platform_get_irq(pdev, idx);\n\n\t\tdev_info(dev,\n\t\t\t \"get hisi_gpio[%d] with %d lines\\n\", idx,\n\t\t\t hisi_gpio->line_num);\n\n\t\tidx++;\n\t}\n}\n\nstatic int hisi_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct hisi_gpio *hisi_gpio;\n\tint port_num;\n\tint ret;\n\n\t \n\tport_num = device_get_child_node_count(dev);\n\tif (WARN_ON(port_num != 1))\n\t\treturn -ENODEV;\n\n\thisi_gpio = devm_kzalloc(dev, sizeof(*hisi_gpio), GFP_KERNEL);\n\tif (!hisi_gpio)\n\t\treturn -ENOMEM;\n\n\thisi_gpio->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hisi_gpio->reg_base))\n\t\treturn PTR_ERR(hisi_gpio->reg_base);\n\n\thisi_gpio_get_pdata(dev, hisi_gpio);\n\n\thisi_gpio->dev = dev;\n\n\tret = bgpio_init(&hisi_gpio->chip, hisi_gpio->dev, 0x4,\n\t\t\t hisi_gpio->reg_base + HISI_GPIO_EXT_PORT_WX,\n\t\t\t hisi_gpio->reg_base + HISI_GPIO_SWPORT_DR_SET_WX,\n\t\t\t hisi_gpio->reg_base + HISI_GPIO_SWPORT_DR_CLR_WX,\n\t\t\t hisi_gpio->reg_base + HISI_GPIO_SWPORT_DDR_SET_WX,\n\t\t\t hisi_gpio->reg_base + HISI_GPIO_SWPORT_DDR_CLR_WX,\n\t\t\t BGPIOF_NO_SET_ON_INPUT);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thisi_gpio->chip.set_config = hisi_gpio_set_config;\n\thisi_gpio->chip.ngpio = hisi_gpio->line_num;\n\thisi_gpio->chip.bgpio_dir_unreadable = 1;\n\thisi_gpio->chip.base = -1;\n\n\tif (hisi_gpio->irq > 0)\n\t\thisi_gpio_init_irq(hisi_gpio);\n\n\tret = devm_gpiochip_add_data(dev, &hisi_gpio->chip, hisi_gpio);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register gpiochip, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver hisi_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= HISI_GPIO_DRIVER_NAME,\n\t\t.acpi_match_table = hisi_gpio_acpi_match,\n\t\t.of_match_table = hisi_gpio_dts_match,\n\t},\n\t.probe\t\t= hisi_gpio_probe,\n};\n\nmodule_platform_driver(hisi_gpio_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Luo Jiaxing <luojiaxing@huawei.com>\");\nMODULE_DESCRIPTION(\"HiSilicon GPIO controller driver\");\nMODULE_ALIAS(\"platform:\" HISI_GPIO_DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}