{
  "module_name": "gpio-bcm-kona.c",
  "hash_id": "cf90f105948af334db61c95679303b8dabc05ec1dfbf3c57e2d952aedd191b48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-bcm-kona.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#define BCM_GPIO_PASSWD\t\t\t\t0x00a5a501\n#define GPIO_PER_BANK\t\t\t\t32\n#define GPIO_MAX_BANK_NUM\t\t\t8\n\n#define GPIO_BANK(gpio)\t\t\t\t((gpio) >> 5)\n#define GPIO_BIT(gpio)\t\t\t\t((gpio) & (GPIO_PER_BANK - 1))\n\n \n#define GPIO_CONTROL(gpio)\t\t\t(0x00000100 + ((gpio) << 2))\n\n \n#define GPIO_OUT_STATUS(bank)\t\t\t(0x00000000 + ((bank) << 2))\n#define GPIO_IN_STATUS(bank)\t\t\t(0x00000020 + ((bank) << 2))\n#define GPIO_OUT_SET(bank)\t\t\t(0x00000040 + ((bank) << 2))\n#define GPIO_OUT_CLEAR(bank)\t\t\t(0x00000060 + ((bank) << 2))\n#define GPIO_INT_STATUS(bank)\t\t\t(0x00000080 + ((bank) << 2))\n#define GPIO_INT_MASK(bank)\t\t\t(0x000000a0 + ((bank) << 2))\n#define GPIO_INT_MSKCLR(bank)\t\t\t(0x000000c0 + ((bank) << 2))\n#define GPIO_PWD_STATUS(bank)\t\t\t(0x00000500 + ((bank) << 2))\n\n#define GPIO_GPPWR_OFFSET\t\t\t0x00000520\n\n#define GPIO_GPCTR0_DBR_SHIFT\t\t\t5\n#define GPIO_GPCTR0_DBR_MASK\t\t\t0x000001e0\n\n#define GPIO_GPCTR0_ITR_SHIFT\t\t\t3\n#define GPIO_GPCTR0_ITR_MASK\t\t\t0x00000018\n#define GPIO_GPCTR0_ITR_CMD_RISING_EDGE\t\t0x00000001\n#define GPIO_GPCTR0_ITR_CMD_FALLING_EDGE\t0x00000002\n#define GPIO_GPCTR0_ITR_CMD_BOTH_EDGE\t\t0x00000003\n\n#define GPIO_GPCTR0_IOTR_MASK\t\t\t0x00000001\n#define GPIO_GPCTR0_IOTR_CMD_0UTPUT\t\t0x00000000\n#define GPIO_GPCTR0_IOTR_CMD_INPUT\t\t0x00000001\n\n#define GPIO_GPCTR0_DB_ENABLE_MASK\t\t0x00000100\n\n#define LOCK_CODE\t\t\t\t0xffffffff\n#define UNLOCK_CODE\t\t\t\t0x00000000\n\nstruct bcm_kona_gpio {\n\tvoid __iomem *reg_base;\n\tint num_bank;\n\traw_spinlock_t lock;\n\tstruct gpio_chip gpio_chip;\n\tstruct irq_domain *irq_domain;\n\tstruct bcm_kona_gpio_bank *banks;\n};\n\nstruct bcm_kona_gpio_bank {\n\tint id;\n\tint irq;\n\t \n\tstruct bcm_kona_gpio *kona_gpio;\n};\n\nstatic inline void bcm_kona_gpio_write_lock_regs(void __iomem *reg_base,\n\t\t\t\t\t\tint bank_id, u32 lockcode)\n{\n\twritel(BCM_GPIO_PASSWD, reg_base + GPIO_GPPWR_OFFSET);\n\twritel(lockcode, reg_base + GPIO_PWD_STATUS(bank_id));\n}\n\nstatic void bcm_kona_gpio_lock_gpio(struct bcm_kona_gpio *kona_gpio,\n\t\t\t\t\tunsigned gpio)\n{\n\tu32 val;\n\tunsigned long flags;\n\tint bank_id = GPIO_BANK(gpio);\n\n\traw_spin_lock_irqsave(&kona_gpio->lock, flags);\n\n\tval = readl(kona_gpio->reg_base + GPIO_PWD_STATUS(bank_id));\n\tval |= BIT(gpio);\n\tbcm_kona_gpio_write_lock_regs(kona_gpio->reg_base, bank_id, val);\n\n\traw_spin_unlock_irqrestore(&kona_gpio->lock, flags);\n}\n\nstatic void bcm_kona_gpio_unlock_gpio(struct bcm_kona_gpio *kona_gpio,\n\t\t\t\t\tunsigned gpio)\n{\n\tu32 val;\n\tunsigned long flags;\n\tint bank_id = GPIO_BANK(gpio);\n\n\traw_spin_lock_irqsave(&kona_gpio->lock, flags);\n\n\tval = readl(kona_gpio->reg_base + GPIO_PWD_STATUS(bank_id));\n\tval &= ~BIT(gpio);\n\tbcm_kona_gpio_write_lock_regs(kona_gpio->reg_base, bank_id, val);\n\n\traw_spin_unlock_irqrestore(&kona_gpio->lock, flags);\n}\n\nstatic int bcm_kona_gpio_get_dir(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct bcm_kona_gpio *kona_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *reg_base = kona_gpio->reg_base;\n\tu32 val;\n\n\tval = readl(reg_base + GPIO_CONTROL(gpio)) & GPIO_GPCTR0_IOTR_MASK;\n\treturn val ? GPIO_LINE_DIRECTION_IN : GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic void bcm_kona_gpio_set(struct gpio_chip *chip, unsigned gpio, int value)\n{\n\tstruct bcm_kona_gpio *kona_gpio;\n\tvoid __iomem *reg_base;\n\tint bank_id = GPIO_BANK(gpio);\n\tint bit = GPIO_BIT(gpio);\n\tu32 val, reg_offset;\n\tunsigned long flags;\n\n\tkona_gpio = gpiochip_get_data(chip);\n\treg_base = kona_gpio->reg_base;\n\traw_spin_lock_irqsave(&kona_gpio->lock, flags);\n\n\t \n\tif (bcm_kona_gpio_get_dir(chip, gpio) == GPIO_LINE_DIRECTION_IN)\n\t\tgoto out;\n\n\treg_offset = value ? GPIO_OUT_SET(bank_id) : GPIO_OUT_CLEAR(bank_id);\n\n\tval = readl(reg_base + reg_offset);\n\tval |= BIT(bit);\n\twritel(val, reg_base + reg_offset);\n\nout:\n\traw_spin_unlock_irqrestore(&kona_gpio->lock, flags);\n}\n\nstatic int bcm_kona_gpio_get(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct bcm_kona_gpio *kona_gpio;\n\tvoid __iomem *reg_base;\n\tint bank_id = GPIO_BANK(gpio);\n\tint bit = GPIO_BIT(gpio);\n\tu32 val, reg_offset;\n\tunsigned long flags;\n\n\tkona_gpio = gpiochip_get_data(chip);\n\treg_base = kona_gpio->reg_base;\n\traw_spin_lock_irqsave(&kona_gpio->lock, flags);\n\n\tif (bcm_kona_gpio_get_dir(chip, gpio) == GPIO_LINE_DIRECTION_IN)\n\t\treg_offset = GPIO_IN_STATUS(bank_id);\n\telse\n\t\treg_offset = GPIO_OUT_STATUS(bank_id);\n\n\t \n\tval = readl(reg_base + reg_offset);\n\n\traw_spin_unlock_irqrestore(&kona_gpio->lock, flags);\n\n\t \n\treturn !!(val & BIT(bit));\n}\n\nstatic int bcm_kona_gpio_request(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct bcm_kona_gpio *kona_gpio = gpiochip_get_data(chip);\n\n\tbcm_kona_gpio_unlock_gpio(kona_gpio, gpio);\n\treturn 0;\n}\n\nstatic void bcm_kona_gpio_free(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct bcm_kona_gpio *kona_gpio = gpiochip_get_data(chip);\n\n\tbcm_kona_gpio_lock_gpio(kona_gpio, gpio);\n}\n\nstatic int bcm_kona_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct bcm_kona_gpio *kona_gpio;\n\tvoid __iomem *reg_base;\n\tu32 val;\n\tunsigned long flags;\n\n\tkona_gpio = gpiochip_get_data(chip);\n\treg_base = kona_gpio->reg_base;\n\traw_spin_lock_irqsave(&kona_gpio->lock, flags);\n\n\tval = readl(reg_base + GPIO_CONTROL(gpio));\n\tval &= ~GPIO_GPCTR0_IOTR_MASK;\n\tval |= GPIO_GPCTR0_IOTR_CMD_INPUT;\n\twritel(val, reg_base + GPIO_CONTROL(gpio));\n\n\traw_spin_unlock_irqrestore(&kona_gpio->lock, flags);\n\n\treturn 0;\n}\n\nstatic int bcm_kona_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t  unsigned gpio, int value)\n{\n\tstruct bcm_kona_gpio *kona_gpio;\n\tvoid __iomem *reg_base;\n\tint bank_id = GPIO_BANK(gpio);\n\tint bit = GPIO_BIT(gpio);\n\tu32 val, reg_offset;\n\tunsigned long flags;\n\n\tkona_gpio = gpiochip_get_data(chip);\n\treg_base = kona_gpio->reg_base;\n\traw_spin_lock_irqsave(&kona_gpio->lock, flags);\n\n\tval = readl(reg_base + GPIO_CONTROL(gpio));\n\tval &= ~GPIO_GPCTR0_IOTR_MASK;\n\tval |= GPIO_GPCTR0_IOTR_CMD_0UTPUT;\n\twritel(val, reg_base + GPIO_CONTROL(gpio));\n\treg_offset = value ? GPIO_OUT_SET(bank_id) : GPIO_OUT_CLEAR(bank_id);\n\n\tval = readl(reg_base + reg_offset);\n\tval |= BIT(bit);\n\twritel(val, reg_base + reg_offset);\n\n\traw_spin_unlock_irqrestore(&kona_gpio->lock, flags);\n\n\treturn 0;\n}\n\nstatic int bcm_kona_gpio_to_irq(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct bcm_kona_gpio *kona_gpio;\n\n\tkona_gpio = gpiochip_get_data(chip);\n\tif (gpio >= kona_gpio->gpio_chip.ngpio)\n\t\treturn -ENXIO;\n\treturn irq_create_mapping(kona_gpio->irq_domain, gpio);\n}\n\nstatic int bcm_kona_gpio_set_debounce(struct gpio_chip *chip, unsigned gpio,\n\t\t\t\t      unsigned debounce)\n{\n\tstruct bcm_kona_gpio *kona_gpio;\n\tvoid __iomem *reg_base;\n\tu32 val, res;\n\tunsigned long flags;\n\n\tkona_gpio = gpiochip_get_data(chip);\n\treg_base = kona_gpio->reg_base;\n\t \n\tif ((debounce > 0 && debounce < 1000) || debounce > 128000) {\n\t\tdev_err(chip->parent, \"Debounce value %u not in range\\n\",\n\t\t\tdebounce);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (debounce != 0) {\n\t\t \n\t\tdebounce /= 1000;\n\t\t \n\t\tres = fls(debounce) - 1;\n\t\t \n\t\tif (res > 0 && (debounce & BIT(res - 1)))\n\t\t\tres++;\n\t}\n\n\t \n\traw_spin_lock_irqsave(&kona_gpio->lock, flags);\n\n\tval = readl(reg_base + GPIO_CONTROL(gpio));\n\tval &= ~GPIO_GPCTR0_DBR_MASK;\n\n\tif (debounce == 0) {\n\t\t \n\t\tval &= ~GPIO_GPCTR0_DB_ENABLE_MASK;\n\t} else {\n\t\tval |= GPIO_GPCTR0_DB_ENABLE_MASK |\n\t\t    (res << GPIO_GPCTR0_DBR_SHIFT);\n\t}\n\n\twritel(val, reg_base + GPIO_CONTROL(gpio));\n\n\traw_spin_unlock_irqrestore(&kona_gpio->lock, flags);\n\n\treturn 0;\n}\n\nstatic int bcm_kona_gpio_set_config(struct gpio_chip *chip, unsigned gpio,\n\t\t\t\t    unsigned long config)\n{\n\tu32 debounce;\n\n\tif (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)\n\t\treturn -ENOTSUPP;\n\n\tdebounce = pinconf_to_config_argument(config);\n\treturn bcm_kona_gpio_set_debounce(chip, gpio, debounce);\n}\n\nstatic const struct gpio_chip template_chip = {\n\t.label = \"bcm-kona-gpio\",\n\t.owner = THIS_MODULE,\n\t.request = bcm_kona_gpio_request,\n\t.free = bcm_kona_gpio_free,\n\t.get_direction = bcm_kona_gpio_get_dir,\n\t.direction_input = bcm_kona_gpio_direction_input,\n\t.get = bcm_kona_gpio_get,\n\t.direction_output = bcm_kona_gpio_direction_output,\n\t.set = bcm_kona_gpio_set,\n\t.set_config = bcm_kona_gpio_set_config,\n\t.to_irq = bcm_kona_gpio_to_irq,\n\t.base = 0,\n};\n\nstatic void bcm_kona_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct bcm_kona_gpio *kona_gpio;\n\tvoid __iomem *reg_base;\n\tunsigned gpio = d->hwirq;\n\tint bank_id = GPIO_BANK(gpio);\n\tint bit = GPIO_BIT(gpio);\n\tu32 val;\n\tunsigned long flags;\n\n\tkona_gpio = irq_data_get_irq_chip_data(d);\n\treg_base = kona_gpio->reg_base;\n\traw_spin_lock_irqsave(&kona_gpio->lock, flags);\n\n\tval = readl(reg_base + GPIO_INT_STATUS(bank_id));\n\tval |= BIT(bit);\n\twritel(val, reg_base + GPIO_INT_STATUS(bank_id));\n\n\traw_spin_unlock_irqrestore(&kona_gpio->lock, flags);\n}\n\nstatic void bcm_kona_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct bcm_kona_gpio *kona_gpio;\n\tvoid __iomem *reg_base;\n\tunsigned gpio = d->hwirq;\n\tint bank_id = GPIO_BANK(gpio);\n\tint bit = GPIO_BIT(gpio);\n\tu32 val;\n\tunsigned long flags;\n\n\tkona_gpio = irq_data_get_irq_chip_data(d);\n\treg_base = kona_gpio->reg_base;\n\traw_spin_lock_irqsave(&kona_gpio->lock, flags);\n\n\tval = readl(reg_base + GPIO_INT_MASK(bank_id));\n\tval |= BIT(bit);\n\twritel(val, reg_base + GPIO_INT_MASK(bank_id));\n\tgpiochip_disable_irq(&kona_gpio->gpio_chip, gpio);\n\n\traw_spin_unlock_irqrestore(&kona_gpio->lock, flags);\n}\n\nstatic void bcm_kona_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct bcm_kona_gpio *kona_gpio;\n\tvoid __iomem *reg_base;\n\tunsigned gpio = d->hwirq;\n\tint bank_id = GPIO_BANK(gpio);\n\tint bit = GPIO_BIT(gpio);\n\tu32 val;\n\tunsigned long flags;\n\n\tkona_gpio = irq_data_get_irq_chip_data(d);\n\treg_base = kona_gpio->reg_base;\n\traw_spin_lock_irqsave(&kona_gpio->lock, flags);\n\n\tval = readl(reg_base + GPIO_INT_MSKCLR(bank_id));\n\tval |= BIT(bit);\n\twritel(val, reg_base + GPIO_INT_MSKCLR(bank_id));\n\tgpiochip_enable_irq(&kona_gpio->gpio_chip, gpio);\n\n\traw_spin_unlock_irqrestore(&kona_gpio->lock, flags);\n}\n\nstatic int bcm_kona_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct bcm_kona_gpio *kona_gpio;\n\tvoid __iomem *reg_base;\n\tunsigned gpio = d->hwirq;\n\tu32 lvl_type;\n\tu32 val;\n\tunsigned long flags;\n\n\tkona_gpio = irq_data_get_irq_chip_data(d);\n\treg_base = kona_gpio->reg_base;\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tlvl_type = GPIO_GPCTR0_ITR_CMD_RISING_EDGE;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tlvl_type = GPIO_GPCTR0_ITR_CMD_FALLING_EDGE;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tlvl_type = GPIO_GPCTR0_ITR_CMD_BOTH_EDGE;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\t \n\tdefault:\n\t\tdev_err(kona_gpio->gpio_chip.parent,\n\t\t\t\"Invalid BCM GPIO irq type 0x%x\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&kona_gpio->lock, flags);\n\n\tval = readl(reg_base + GPIO_CONTROL(gpio));\n\tval &= ~GPIO_GPCTR0_ITR_MASK;\n\tval |= lvl_type << GPIO_GPCTR0_ITR_SHIFT;\n\twritel(val, reg_base + GPIO_CONTROL(gpio));\n\n\traw_spin_unlock_irqrestore(&kona_gpio->lock, flags);\n\n\treturn 0;\n}\n\nstatic void bcm_kona_gpio_irq_handler(struct irq_desc *desc)\n{\n\tvoid __iomem *reg_base;\n\tint bit, bank_id;\n\tunsigned long sta;\n\tstruct bcm_kona_gpio_bank *bank = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\tchained_irq_enter(chip, desc);\n\n\t \n\treg_base = bank->kona_gpio->reg_base;\n\tbank_id = bank->id;\n\n\twhile ((sta = readl(reg_base + GPIO_INT_STATUS(bank_id)) &\n\t\t    (~(readl(reg_base + GPIO_INT_MASK(bank_id)))))) {\n\t\tfor_each_set_bit(bit, &sta, 32) {\n\t\t\tint hwirq = GPIO_PER_BANK * bank_id + bit;\n\t\t\t \n\t\t\twritel(readl(reg_base + GPIO_INT_STATUS(bank_id)) |\n\t\t\t       BIT(bit), reg_base + GPIO_INT_STATUS(bank_id));\n\t\t\t \n\t\t\tgeneric_handle_domain_irq(bank->kona_gpio->irq_domain,\n\t\t\t\t\t\t  hwirq);\n\t\t}\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int bcm_kona_gpio_irq_reqres(struct irq_data *d)\n{\n\tstruct bcm_kona_gpio *kona_gpio = irq_data_get_irq_chip_data(d);\n\n\treturn gpiochip_reqres_irq(&kona_gpio->gpio_chip, d->hwirq);\n}\n\nstatic void bcm_kona_gpio_irq_relres(struct irq_data *d)\n{\n\tstruct bcm_kona_gpio *kona_gpio = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_relres_irq(&kona_gpio->gpio_chip, d->hwirq);\n}\n\nstatic struct irq_chip bcm_gpio_irq_chip = {\n\t.name = \"bcm-kona-gpio\",\n\t.irq_ack = bcm_kona_gpio_irq_ack,\n\t.irq_mask = bcm_kona_gpio_irq_mask,\n\t.irq_unmask = bcm_kona_gpio_irq_unmask,\n\t.irq_set_type = bcm_kona_gpio_irq_set_type,\n\t.irq_request_resources = bcm_kona_gpio_irq_reqres,\n\t.irq_release_resources = bcm_kona_gpio_irq_relres,\n};\n\nstatic struct of_device_id const bcm_kona_gpio_of_match[] = {\n\t{ .compatible = \"brcm,kona-gpio\" },\n\t{}\n};\n\n \nstatic struct lock_class_key gpio_lock_class;\nstatic struct lock_class_key gpio_request_class;\n\nstatic int bcm_kona_gpio_irq_map(struct irq_domain *d, unsigned int irq,\n\t\t\t\t irq_hw_number_t hwirq)\n{\n\tint ret;\n\n\tret = irq_set_chip_data(irq, d->host_data);\n\tif (ret < 0)\n\t\treturn ret;\n\tirq_set_lockdep_class(irq, &gpio_lock_class, &gpio_request_class);\n\tirq_set_chip_and_handler(irq, &bcm_gpio_irq_chip, handle_simple_irq);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic void bcm_kona_gpio_irq_unmap(struct irq_domain *d, unsigned int irq)\n{\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\tirq_set_chip_data(irq, NULL);\n}\n\nstatic const struct irq_domain_ops bcm_kona_irq_ops = {\n\t.map = bcm_kona_gpio_irq_map,\n\t.unmap = bcm_kona_gpio_irq_unmap,\n\t.xlate = irq_domain_xlate_twocell,\n};\n\nstatic void bcm_kona_gpio_reset(struct bcm_kona_gpio *kona_gpio)\n{\n\tvoid __iomem *reg_base;\n\tint i;\n\n\treg_base = kona_gpio->reg_base;\n\t \n\tfor (i = 0; i < kona_gpio->num_bank; i++) {\n\t\t \n\t\tbcm_kona_gpio_write_lock_regs(reg_base, i, UNLOCK_CODE);\n\t\twritel(0xffffffff, reg_base + GPIO_INT_MASK(i));\n\t\twritel(0xffffffff, reg_base + GPIO_INT_STATUS(i));\n\t\t \n\t\tbcm_kona_gpio_write_lock_regs(reg_base, i, LOCK_CODE);\n\t}\n}\n\nstatic int bcm_kona_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm_kona_gpio_bank *bank;\n\tstruct bcm_kona_gpio *kona_gpio;\n\tstruct gpio_chip *chip;\n\tint ret;\n\tint i;\n\n\tkona_gpio = devm_kzalloc(dev, sizeof(*kona_gpio), GFP_KERNEL);\n\tif (!kona_gpio)\n\t\treturn -ENOMEM;\n\n\tkona_gpio->gpio_chip = template_chip;\n\tchip = &kona_gpio->gpio_chip;\n\tret = platform_irq_count(pdev);\n\tif (!ret) {\n\t\tdev_err(dev, \"Couldn't determine # GPIO banks\\n\");\n\t\treturn -ENOENT;\n\t} else if (ret < 0) {\n\t\treturn dev_err_probe(dev, ret, \"Couldn't determine GPIO banks\\n\");\n\t}\n\tkona_gpio->num_bank = ret;\n\n\tif (kona_gpio->num_bank > GPIO_MAX_BANK_NUM) {\n\t\tdev_err(dev, \"Too many GPIO banks configured (max=%d)\\n\",\n\t\t\tGPIO_MAX_BANK_NUM);\n\t\treturn -ENXIO;\n\t}\n\tkona_gpio->banks = devm_kcalloc(dev,\n\t\t\t\t\tkona_gpio->num_bank,\n\t\t\t\t\tsizeof(*kona_gpio->banks),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!kona_gpio->banks)\n\t\treturn -ENOMEM;\n\n\tchip->parent = dev;\n\tchip->ngpio = kona_gpio->num_bank * GPIO_PER_BANK;\n\n\tkona_gpio->irq_domain = irq_domain_create_linear(dev_fwnode(dev),\n\t\t\t\t\t\t\t chip->ngpio,\n\t\t\t\t\t\t\t &bcm_kona_irq_ops,\n\t\t\t\t\t\t\t kona_gpio);\n\tif (!kona_gpio->irq_domain) {\n\t\tdev_err(dev, \"Couldn't allocate IRQ domain\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tkona_gpio->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(kona_gpio->reg_base)) {\n\t\tret = PTR_ERR(kona_gpio->reg_base);\n\t\tgoto err_irq_domain;\n\t}\n\n\tfor (i = 0; i < kona_gpio->num_bank; i++) {\n\t\tbank = &kona_gpio->banks[i];\n\t\tbank->id = i;\n\t\tbank->irq = platform_get_irq(pdev, i);\n\t\tbank->kona_gpio = kona_gpio;\n\t\tif (bank->irq < 0) {\n\t\t\tdev_err(dev, \"Couldn't get IRQ for bank %d\", i);\n\t\t\tret = -ENOENT;\n\t\t\tgoto err_irq_domain;\n\t\t}\n\t}\n\n\tdev_info(&pdev->dev, \"Setting up Kona GPIO\\n\");\n\n\tbcm_kona_gpio_reset(kona_gpio);\n\n\tret = devm_gpiochip_add_data(dev, chip, kona_gpio);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Couldn't add GPIO chip -- %d\\n\", ret);\n\t\tgoto err_irq_domain;\n\t}\n\tfor (i = 0; i < kona_gpio->num_bank; i++) {\n\t\tbank = &kona_gpio->banks[i];\n\t\tirq_set_chained_handler_and_data(bank->irq,\n\t\t\t\t\t\t bcm_kona_gpio_irq_handler,\n\t\t\t\t\t\t bank);\n\t}\n\n\traw_spin_lock_init(&kona_gpio->lock);\n\n\treturn 0;\n\nerr_irq_domain:\n\tirq_domain_remove(kona_gpio->irq_domain);\n\n\treturn ret;\n}\n\nstatic struct platform_driver bcm_kona_gpio_driver = {\n\t.driver = {\n\t\t\t.name = \"bcm-kona-gpio\",\n\t\t\t.of_match_table = bcm_kona_gpio_of_match,\n\t},\n\t.probe = bcm_kona_gpio_probe,\n};\nbuiltin_platform_driver(bcm_kona_gpio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}