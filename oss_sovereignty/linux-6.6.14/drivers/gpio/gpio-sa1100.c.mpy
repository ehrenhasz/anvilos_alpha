{
  "module_name": "gpio-sa1100.c",
  "hash_id": "5b52ebe29cdd0b383052ae5b70a5936353bfe424e6268aa064036705a82d76eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-sa1100.c",
  "human_readable_source": "\n \n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/syscore_ops.h>\n#include <soc/sa1100/pwer.h>\n#include <mach/hardware.h>\n#include <mach/irqs.h>\n#include <mach/generic.h>\n\nstruct sa1100_gpio_chip {\n\tstruct gpio_chip chip;\n\tvoid __iomem *membase;\n\tint irqbase;\n\tu32 irqmask;\n\tu32 irqrising;\n\tu32 irqfalling;\n\tu32 irqwake;\n};\n\n#define sa1100_gpio_chip(x) container_of(x, struct sa1100_gpio_chip, chip)\n\nenum {\n\tR_GPLR = 0x00,\n\tR_GPDR = 0x04,\n\tR_GPSR = 0x08,\n\tR_GPCR = 0x0c,\n\tR_GRER = 0x10,\n\tR_GFER = 0x14,\n\tR_GEDR = 0x18,\n\tR_GAFR = 0x1c,\n};\n\nstatic int sa1100_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\treturn readl_relaxed(sa1100_gpio_chip(chip)->membase + R_GPLR) &\n\t\tBIT(offset);\n}\n\nstatic void sa1100_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tint reg = value ? R_GPSR : R_GPCR;\n\n\twritel_relaxed(BIT(offset), sa1100_gpio_chip(chip)->membase + reg);\n}\n\nstatic int sa1100_get_direction(struct gpio_chip *chip, unsigned offset)\n{\n\tvoid __iomem *gpdr = sa1100_gpio_chip(chip)->membase + R_GPDR;\n\n\tif (readl_relaxed(gpdr) & BIT(offset))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int sa1100_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tvoid __iomem *gpdr = sa1100_gpio_chip(chip)->membase + R_GPDR;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\twritel_relaxed(readl_relaxed(gpdr) & ~BIT(offset), gpdr);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\nstatic int sa1100_direction_output(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tvoid __iomem *gpdr = sa1100_gpio_chip(chip)->membase + R_GPDR;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tsa1100_gpio_set(chip, offset, value);\n\twritel_relaxed(readl_relaxed(gpdr) | BIT(offset), gpdr);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\nstatic int sa1100_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\treturn sa1100_gpio_chip(chip)->irqbase + offset;\n}\n\nstatic struct sa1100_gpio_chip sa1100_gpio_chip = {\n\t.chip = {\n\t\t.label\t\t\t= \"gpio\",\n\t\t.get_direction\t\t= sa1100_get_direction,\n\t\t.direction_input\t= sa1100_direction_input,\n\t\t.direction_output\t= sa1100_direction_output,\n\t\t.set\t\t\t= sa1100_gpio_set,\n\t\t.get\t\t\t= sa1100_gpio_get,\n\t\t.to_irq\t\t\t= sa1100_to_irq,\n\t\t.base\t\t\t= 0,\n\t\t.ngpio\t\t\t= GPIO_MAX + 1,\n\t},\n\t.membase = (void *)&GPLR,\n\t.irqbase = IRQ_GPIO0,\n};\n\n \nstatic void sa1100_update_edge_regs(struct sa1100_gpio_chip *sgc)\n{\n\tvoid *base = sgc->membase;\n\tu32 grer, gfer;\n\n\tgrer = sgc->irqrising & sgc->irqmask;\n\tgfer = sgc->irqfalling & sgc->irqmask;\n\n\twritel_relaxed(grer, base + R_GRER);\n\twritel_relaxed(gfer, base + R_GFER);\n}\n\nstatic int sa1100_gpio_type(struct irq_data *d, unsigned int type)\n{\n\tstruct sa1100_gpio_chip *sgc = irq_data_get_irq_chip_data(d);\n\tunsigned int mask = BIT(d->hwirq);\n\n\tif (type == IRQ_TYPE_PROBE) {\n\t\tif ((sgc->irqrising | sgc->irqfalling) & mask)\n\t\t\treturn 0;\n\t\ttype = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\n\t}\n\n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tsgc->irqrising |= mask;\n\telse\n\t\tsgc->irqrising &= ~mask;\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tsgc->irqfalling |= mask;\n\telse\n\t\tsgc->irqfalling &= ~mask;\n\n\tsa1100_update_edge_regs(sgc);\n\n\treturn 0;\n}\n\n \nstatic void sa1100_gpio_ack(struct irq_data *d)\n{\n\tstruct sa1100_gpio_chip *sgc = irq_data_get_irq_chip_data(d);\n\n\twritel_relaxed(BIT(d->hwirq), sgc->membase + R_GEDR);\n}\n\nstatic void sa1100_gpio_mask(struct irq_data *d)\n{\n\tstruct sa1100_gpio_chip *sgc = irq_data_get_irq_chip_data(d);\n\tunsigned int mask = BIT(d->hwirq);\n\n\tsgc->irqmask &= ~mask;\n\n\tsa1100_update_edge_regs(sgc);\n}\n\nstatic void sa1100_gpio_unmask(struct irq_data *d)\n{\n\tstruct sa1100_gpio_chip *sgc = irq_data_get_irq_chip_data(d);\n\tunsigned int mask = BIT(d->hwirq);\n\n\tsgc->irqmask |= mask;\n\n\tsa1100_update_edge_regs(sgc);\n}\n\nstatic int sa1100_gpio_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct sa1100_gpio_chip *sgc = irq_data_get_irq_chip_data(d);\n\tint ret = sa11x0_gpio_set_wake(d->hwirq, on);\n\tif (!ret) {\n\t\tif (on)\n\t\t\tsgc->irqwake |= BIT(d->hwirq);\n\t\telse\n\t\t\tsgc->irqwake &= ~BIT(d->hwirq);\n\t}\n\treturn ret;\n}\n\n \nstatic struct irq_chip sa1100_gpio_irq_chip = {\n\t.name\t\t= \"GPIO\",\n\t.irq_ack\t= sa1100_gpio_ack,\n\t.irq_mask\t= sa1100_gpio_mask,\n\t.irq_unmask\t= sa1100_gpio_unmask,\n\t.irq_set_type\t= sa1100_gpio_type,\n\t.irq_set_wake\t= sa1100_gpio_wake,\n};\n\nstatic int sa1100_gpio_irqdomain_map(struct irq_domain *d,\n\t\tunsigned int irq, irq_hw_number_t hwirq)\n{\n\tstruct sa1100_gpio_chip *sgc = d->host_data;\n\n\tirq_set_chip_data(irq, sgc);\n\tirq_set_chip_and_handler(irq, &sa1100_gpio_irq_chip, handle_edge_irq);\n\tirq_set_probe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops sa1100_gpio_irqdomain_ops = {\n\t.map = sa1100_gpio_irqdomain_map,\n\t.xlate = irq_domain_xlate_onetwocell,\n};\n\nstatic struct irq_domain *sa1100_gpio_irqdomain;\n\n \nstatic void sa1100_gpio_handler(struct irq_desc *desc)\n{\n\tstruct sa1100_gpio_chip *sgc = irq_desc_get_handler_data(desc);\n\tunsigned int irq, mask;\n\tvoid __iomem *gedr = sgc->membase + R_GEDR;\n\n\tmask = readl_relaxed(gedr);\n\tdo {\n\t\t \n\t\twritel_relaxed(mask, gedr);\n\n\t\tirq = sgc->irqbase;\n\t\tdo {\n\t\t\tif (mask & 1)\n\t\t\t\tgeneric_handle_irq(irq);\n\t\t\tmask >>= 1;\n\t\t\tirq++;\n\t\t} while (mask);\n\n\t\tmask = readl_relaxed(gedr);\n\t} while (mask);\n}\n\nstatic int sa1100_gpio_suspend(void)\n{\n\tstruct sa1100_gpio_chip *sgc = &sa1100_gpio_chip;\n\n\t \n\twritel_relaxed(sgc->irqwake & sgc->irqrising, sgc->membase + R_GRER);\n\twritel_relaxed(sgc->irqwake & sgc->irqfalling, sgc->membase + R_GFER);\n\n\t \n\twritel_relaxed(readl_relaxed(sgc->membase + R_GEDR),\n\t\t       sgc->membase + R_GEDR);\n\n\treturn 0;\n}\n\nstatic void sa1100_gpio_resume(void)\n{\n\tsa1100_update_edge_regs(&sa1100_gpio_chip);\n}\n\nstatic struct syscore_ops sa1100_gpio_syscore_ops = {\n\t.suspend\t= sa1100_gpio_suspend,\n\t.resume\t\t= sa1100_gpio_resume,\n};\n\nstatic int __init sa1100_gpio_init_devicefs(void)\n{\n\tregister_syscore_ops(&sa1100_gpio_syscore_ops);\n\treturn 0;\n}\n\ndevice_initcall(sa1100_gpio_init_devicefs);\n\nstatic const int sa1100_gpio_irqs[] __initconst = {\n\t \n\tIRQ_GPIO0_SC,\n\tIRQ_GPIO1_SC,\n\tIRQ_GPIO2_SC,\n\tIRQ_GPIO3_SC,\n\tIRQ_GPIO4_SC,\n\tIRQ_GPIO5_SC,\n\tIRQ_GPIO6_SC,\n\tIRQ_GPIO7_SC,\n\tIRQ_GPIO8_SC,\n\tIRQ_GPIO9_SC,\n\tIRQ_GPIO10_SC,\n\t \n\tIRQ_GPIO11_27,\n};\n\nvoid __init sa1100_init_gpio(void)\n{\n\tstruct sa1100_gpio_chip *sgc = &sa1100_gpio_chip;\n\tint i;\n\n\t \n\twritel_relaxed(0, sgc->membase + R_GFER);\n\twritel_relaxed(0, sgc->membase + R_GRER);\n\twritel_relaxed(-1, sgc->membase + R_GEDR);\n\n\tgpiochip_add_data(&sa1100_gpio_chip.chip, NULL);\n\n\tsa1100_gpio_irqdomain = irq_domain_add_simple(NULL,\n\t\t\t28, IRQ_GPIO0,\n\t\t\t&sa1100_gpio_irqdomain_ops, sgc);\n\n\tfor (i = 0; i < ARRAY_SIZE(sa1100_gpio_irqs); i++)\n\t\tirq_set_chained_handler_and_data(sa1100_gpio_irqs[i],\n\t\t\t\t\t\t sa1100_gpio_handler, sgc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}