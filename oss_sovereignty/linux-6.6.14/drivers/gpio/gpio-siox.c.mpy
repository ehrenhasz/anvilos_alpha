{
  "module_name": "gpio-siox.c",
  "hash_id": "3486bd603b8954516399d97099598589250b9c7d23a036ba1200268e82f3d1b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-siox.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/siox.h>\n#include <linux/gpio/driver.h>\n#include <linux/of.h>\n\nstruct gpio_siox_ddata {\n\tstruct gpio_chip gchip;\n\tstruct mutex lock;\n\tu8 setdata[1];\n\tu8 getdata[3];\n\n\traw_spinlock_t irqlock;\n\tu32 irq_enable;\n\tu32 irq_status;\n\tu32 irq_type[20];\n};\n\n \nstatic int gpio_siox_set_data(struct siox_device *sdevice, u8 status, u8 buf[])\n{\n\tstruct gpio_siox_ddata *ddata = dev_get_drvdata(&sdevice->dev);\n\n\tmutex_lock(&ddata->lock);\n\tbuf[0] = ddata->setdata[0];\n\tmutex_unlock(&ddata->lock);\n\n\treturn 0;\n}\n\nstatic int gpio_siox_get_data(struct siox_device *sdevice, const u8 buf[])\n{\n\tstruct gpio_siox_ddata *ddata = dev_get_drvdata(&sdevice->dev);\n\tsize_t offset;\n\tu32 trigger;\n\n\tmutex_lock(&ddata->lock);\n\n\traw_spin_lock_irq(&ddata->irqlock);\n\n\tfor (offset = 0; offset < 12; ++offset) {\n\t\tunsigned int bitpos = 11 - offset;\n\t\tunsigned int gpiolevel = buf[bitpos / 8] & (1 << bitpos % 8);\n\t\tunsigned int prev_level =\n\t\t\tddata->getdata[bitpos / 8] & (1 << (bitpos % 8));\n\t\tu32 irq_type = ddata->irq_type[offset];\n\n\t\tif (gpiolevel) {\n\t\t\tif ((irq_type & IRQ_TYPE_LEVEL_HIGH) ||\n\t\t\t    ((irq_type & IRQ_TYPE_EDGE_RISING) && !prev_level))\n\t\t\t\tddata->irq_status |= 1 << offset;\n\t\t} else {\n\t\t\tif ((irq_type & IRQ_TYPE_LEVEL_LOW) ||\n\t\t\t    ((irq_type & IRQ_TYPE_EDGE_FALLING) && prev_level))\n\t\t\t\tddata->irq_status |= 1 << offset;\n\t\t}\n\t}\n\n\ttrigger = ddata->irq_status & ddata->irq_enable;\n\n\traw_spin_unlock_irq(&ddata->irqlock);\n\n\tddata->getdata[0] = buf[0];\n\tddata->getdata[1] = buf[1];\n\tddata->getdata[2] = buf[2];\n\n\tmutex_unlock(&ddata->lock);\n\n\tfor (offset = 0; offset < 12; ++offset) {\n\t\tif (trigger & (1 << offset)) {\n\t\t\tstruct irq_domain *irqdomain = ddata->gchip.irq.domain;\n\t\t\tunsigned int irq = irq_find_mapping(irqdomain, offset);\n\n\t\t\t \n\t\t\traw_spin_lock_irq(&ddata->irqlock);\n\t\t\tddata->irq_status &= ~(1 << offset);\n\t\t\traw_spin_unlock_irq(&ddata->irqlock);\n\n\t\t\thandle_nested_irq(irq);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void gpio_siox_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_siox_ddata *ddata = gpiochip_get_data(gc);\n\n\traw_spin_lock(&ddata->irqlock);\n\tddata->irq_status &= ~(1 << d->hwirq);\n\traw_spin_unlock(&ddata->irqlock);\n}\n\nstatic void gpio_siox_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_siox_ddata *ddata = gpiochip_get_data(gc);\n\n\traw_spin_lock(&ddata->irqlock);\n\tddata->irq_enable &= ~(1 << d->hwirq);\n\traw_spin_unlock(&ddata->irqlock);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void gpio_siox_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_siox_ddata *ddata = gpiochip_get_data(gc);\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\traw_spin_lock(&ddata->irqlock);\n\tddata->irq_enable |= 1 << d->hwirq;\n\traw_spin_unlock(&ddata->irqlock);\n}\n\nstatic int gpio_siox_irq_set_type(struct irq_data *d, u32 type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_siox_ddata *ddata = gpiochip_get_data(gc);\n\n\traw_spin_lock(&ddata->irqlock);\n\tddata->irq_type[d->hwirq] = type;\n\traw_spin_unlock(&ddata->irqlock);\n\n\treturn 0;\n}\n\nstatic int gpio_siox_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct gpio_siox_ddata *ddata = gpiochip_get_data(chip);\n\tint ret;\n\n\tmutex_lock(&ddata->lock);\n\n\tif (offset >= 12) {\n\t\tunsigned int bitpos = 19 - offset;\n\n\t\tret = ddata->setdata[0] & (1 << bitpos);\n\t} else {\n\t\tunsigned int bitpos = 11 - offset;\n\n\t\tret = ddata->getdata[bitpos / 8] & (1 << (bitpos % 8));\n\t}\n\n\tmutex_unlock(&ddata->lock);\n\n\treturn ret;\n}\n\nstatic void gpio_siox_set(struct gpio_chip *chip,\n\t\t\t  unsigned int offset, int value)\n{\n\tstruct gpio_siox_ddata *ddata = gpiochip_get_data(chip);\n\tu8 mask = 1 << (19 - offset);\n\n\tmutex_lock(&ddata->lock);\n\n\tif (value)\n\t\tddata->setdata[0] |= mask;\n\telse\n\t\tddata->setdata[0] &= ~mask;\n\n\tmutex_unlock(&ddata->lock);\n}\n\nstatic int gpio_siox_direction_input(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset)\n{\n\tif (offset >= 12)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int gpio_siox_direction_output(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset, int value)\n{\n\tif (offset < 12)\n\t\treturn -EINVAL;\n\n\tgpio_siox_set(chip, offset, value);\n\treturn 0;\n}\n\nstatic int gpio_siox_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tif (offset < 12)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\telse\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic const struct irq_chip gpio_siox_irq_chip = {\n\t.name = \"siox-gpio\",\n\t.irq_ack = gpio_siox_irq_ack,\n\t.irq_mask = gpio_siox_irq_mask,\n\t.irq_unmask = gpio_siox_irq_unmask,\n\t.irq_set_type = gpio_siox_irq_set_type,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int gpio_siox_probe(struct siox_device *sdevice)\n{\n\tstruct gpio_siox_ddata *ddata;\n\tstruct gpio_irq_chip *girq;\n\tstruct device *dev = &sdevice->dev;\n\tstruct gpio_chip *gc;\n\tint ret;\n\n\tddata = devm_kzalloc(dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ddata);\n\n\tmutex_init(&ddata->lock);\n\traw_spin_lock_init(&ddata->irqlock);\n\n\tgc = &ddata->gchip;\n\tgc->base = -1;\n\tgc->can_sleep = 1;\n\tgc->parent = dev;\n\tgc->owner = THIS_MODULE;\n\tgc->get = gpio_siox_get;\n\tgc->set = gpio_siox_set;\n\tgc->direction_input = gpio_siox_direction_input;\n\tgc->direction_output = gpio_siox_direction_output;\n\tgc->get_direction = gpio_siox_get_direction;\n\tgc->ngpio = 20;\n\n\tgirq = &gc->irq;\n\tgpio_irq_chip_set_chip(girq, &gpio_siox_irq_chip);\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_level_irq;\n\tgirq->threaded = true;\n\n\tret = devm_gpiochip_add_data(dev, gc, ddata);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to register gpio chip (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct siox_driver gpio_siox_driver = {\n\t.probe = gpio_siox_probe,\n\t.set_data = gpio_siox_set_data,\n\t.get_data = gpio_siox_get_data,\n\t.driver = {\n\t\t.name = \"gpio-siox\",\n\t},\n};\nmodule_siox_driver(gpio_siox_driver);\n\nMODULE_AUTHOR(\"Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>\");\nMODULE_DESCRIPTION(\"SIOX gpio driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}