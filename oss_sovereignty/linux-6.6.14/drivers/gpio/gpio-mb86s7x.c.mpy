{
  "module_name": "gpio-mb86s7x.c",
  "hash_id": "2d51d1626462c372856177e0e63c4fd69af94acfdc59f6a12c854d4c9b0e1458",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mb86s7x.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/clk.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/gpio/driver.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#include \"gpiolib.h\"\n#include \"gpiolib-acpi.h\"\n\n \n#define PDR(x)\t(0x0 + x / 8 * 4)\n#define DDR(x)\t(0x10 + x / 8 * 4)\n#define PFR(x)\t(0x20 + x / 8 * 4)\n\n#define OFFSET(x)\tBIT((x) % 8)\n\nstruct mb86s70_gpio_chip {\n\tstruct gpio_chip gc;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tspinlock_t lock;\n};\n\nstatic int mb86s70_gpio_request(struct gpio_chip *gc, unsigned gpio)\n{\n\tstruct mb86s70_gpio_chip *gchip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&gchip->lock, flags);\n\n\tval = readl(gchip->base + PFR(gpio));\n\tval &= ~OFFSET(gpio);\n\twritel(val, gchip->base + PFR(gpio));\n\n\tspin_unlock_irqrestore(&gchip->lock, flags);\n\n\treturn 0;\n}\n\nstatic void mb86s70_gpio_free(struct gpio_chip *gc, unsigned gpio)\n{\n\tstruct mb86s70_gpio_chip *gchip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&gchip->lock, flags);\n\n\tval = readl(gchip->base + PFR(gpio));\n\tval |= OFFSET(gpio);\n\twritel(val, gchip->base + PFR(gpio));\n\n\tspin_unlock_irqrestore(&gchip->lock, flags);\n}\n\nstatic int mb86s70_gpio_direction_input(struct gpio_chip *gc, unsigned gpio)\n{\n\tstruct mb86s70_gpio_chip *gchip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tunsigned char val;\n\n\tspin_lock_irqsave(&gchip->lock, flags);\n\n\tval = readl(gchip->base + DDR(gpio));\n\tval &= ~OFFSET(gpio);\n\twritel(val, gchip->base + DDR(gpio));\n\n\tspin_unlock_irqrestore(&gchip->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mb86s70_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\t unsigned gpio, int value)\n{\n\tstruct mb86s70_gpio_chip *gchip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tunsigned char val;\n\n\tspin_lock_irqsave(&gchip->lock, flags);\n\n\tval = readl(gchip->base + PDR(gpio));\n\tif (value)\n\t\tval |= OFFSET(gpio);\n\telse\n\t\tval &= ~OFFSET(gpio);\n\twritel(val, gchip->base + PDR(gpio));\n\n\tval = readl(gchip->base + DDR(gpio));\n\tval |= OFFSET(gpio);\n\twritel(val, gchip->base + DDR(gpio));\n\n\tspin_unlock_irqrestore(&gchip->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mb86s70_gpio_get(struct gpio_chip *gc, unsigned gpio)\n{\n\tstruct mb86s70_gpio_chip *gchip = gpiochip_get_data(gc);\n\n\treturn !!(readl(gchip->base + PDR(gpio)) & OFFSET(gpio));\n}\n\nstatic void mb86s70_gpio_set(struct gpio_chip *gc, unsigned gpio, int value)\n{\n\tstruct mb86s70_gpio_chip *gchip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tunsigned char val;\n\n\tspin_lock_irqsave(&gchip->lock, flags);\n\n\tval = readl(gchip->base + PDR(gpio));\n\tif (value)\n\t\tval |= OFFSET(gpio);\n\telse\n\t\tval &= ~OFFSET(gpio);\n\twritel(val, gchip->base + PDR(gpio));\n\n\tspin_unlock_irqrestore(&gchip->lock, flags);\n}\n\nstatic int mb86s70_gpio_to_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tint irq, index;\n\n\tfor (index = 0;; index++) {\n\t\tirq = platform_get_irq(to_platform_device(gc->parent), index);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t\tif (irq == 0)\n\t\t\tbreak;\n\t\tif (irq_get_irq_data(irq)->hwirq == offset)\n\t\t\treturn irq;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int mb86s70_gpio_probe(struct platform_device *pdev)\n{\n\tstruct mb86s70_gpio_chip *gchip;\n\tint ret;\n\n\tgchip = devm_kzalloc(&pdev->dev, sizeof(*gchip), GFP_KERNEL);\n\tif (gchip == NULL)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, gchip);\n\n\tgchip->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gchip->base))\n\t\treturn PTR_ERR(gchip->base);\n\n\tgchip->clk = devm_clk_get_optional(&pdev->dev, NULL);\n\tif (IS_ERR(gchip->clk))\n\t\treturn PTR_ERR(gchip->clk);\n\n\tret = clk_prepare_enable(gchip->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_init(&gchip->lock);\n\n\tgchip->gc.direction_output = mb86s70_gpio_direction_output;\n\tgchip->gc.direction_input = mb86s70_gpio_direction_input;\n\tgchip->gc.request = mb86s70_gpio_request;\n\tgchip->gc.free = mb86s70_gpio_free;\n\tgchip->gc.get = mb86s70_gpio_get;\n\tgchip->gc.set = mb86s70_gpio_set;\n\tgchip->gc.to_irq = mb86s70_gpio_to_irq;\n\tgchip->gc.label = dev_name(&pdev->dev);\n\tgchip->gc.ngpio = 32;\n\tgchip->gc.owner = THIS_MODULE;\n\tgchip->gc.parent = &pdev->dev;\n\tgchip->gc.base = -1;\n\n\tret = gpiochip_add_data(&gchip->gc, gchip);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"couldn't register gpio driver\\n\");\n\t\tclk_disable_unprepare(gchip->clk);\n\t\treturn ret;\n\t}\n\n\tacpi_gpiochip_request_interrupts(&gchip->gc);\n\n\treturn 0;\n}\n\nstatic int mb86s70_gpio_remove(struct platform_device *pdev)\n{\n\tstruct mb86s70_gpio_chip *gchip = platform_get_drvdata(pdev);\n\n\tacpi_gpiochip_free_interrupts(&gchip->gc);\n\tgpiochip_remove(&gchip->gc);\n\tclk_disable_unprepare(gchip->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mb86s70_gpio_dt_ids[] = {\n\t{ .compatible = \"fujitsu,mb86s70-gpio\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mb86s70_gpio_dt_ids);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id mb86s70_gpio_acpi_ids[] = {\n\t{ \"SCX0007\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(acpi, mb86s70_gpio_acpi_ids);\n#endif\n\nstatic struct platform_driver mb86s70_gpio_driver = {\n\t.driver = {\n\t\t.name = \"mb86s70-gpio\",\n\t\t.of_match_table = mb86s70_gpio_dt_ids,\n\t\t.acpi_match_table = ACPI_PTR(mb86s70_gpio_acpi_ids),\n\t},\n\t.probe = mb86s70_gpio_probe,\n\t.remove = mb86s70_gpio_remove,\n};\nmodule_platform_driver(mb86s70_gpio_driver);\n\nMODULE_DESCRIPTION(\"MB86S7x GPIO Driver\");\nMODULE_ALIAS(\"platform:mb86s70-gpio\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}