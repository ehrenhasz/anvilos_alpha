{
  "module_name": "gpio-pmic-eic-sprd.c",
  "hash_id": "aab0f2836317c11e88005c87c29525465170d6a4f56db40fd61eec9a4cee0932",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-pmic-eic-sprd.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define SPRD_PMIC_EIC_DATA\t\t0x0\n#define SPRD_PMIC_EIC_DMSK\t\t0x4\n#define SPRD_PMIC_EIC_IEV\t\t0x14\n#define SPRD_PMIC_EIC_IE\t\t0x18\n#define SPRD_PMIC_EIC_RIS\t\t0x1c\n#define SPRD_PMIC_EIC_MIS\t\t0x20\n#define SPRD_PMIC_EIC_IC\t\t0x24\n#define SPRD_PMIC_EIC_TRIG\t\t0x28\n#define SPRD_PMIC_EIC_CTRL0\t\t0x40\n\n \n#define SPRD_PMIC_EIC_PER_BANK_NR\t16\n#define SPRD_PMIC_EIC_NR\t\tSPRD_PMIC_EIC_PER_BANK_NR\n#define SPRD_PMIC_EIC_DATA_MASK\t\tGENMASK(15, 0)\n#define SPRD_PMIC_EIC_BIT(x)\t\t((x) & (SPRD_PMIC_EIC_PER_BANK_NR - 1))\n#define SPRD_PMIC_EIC_DBNC_MASK\t\tGENMASK(11, 0)\n\n \nenum {\n\tREG_IEV,\n\tREG_IE,\n\tREG_TRIG,\n\tCACHE_NR_REGS\n};\n\n \nstruct sprd_pmic_eic {\n\tstruct gpio_chip chip;\n\tstruct regmap *map;\n\tu32 offset;\n\tu8 reg[CACHE_NR_REGS];\n\tstruct mutex buslock;\n\tint irq;\n};\n\nstatic void sprd_pmic_eic_update(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t u16 reg, unsigned int val)\n{\n\tstruct sprd_pmic_eic *pmic_eic = gpiochip_get_data(chip);\n\tu32 shift = SPRD_PMIC_EIC_BIT(offset);\n\n\tregmap_update_bits(pmic_eic->map, pmic_eic->offset + reg,\n\t\t\t   BIT(shift), val << shift);\n}\n\nstatic int sprd_pmic_eic_read(struct gpio_chip *chip, unsigned int offset,\n\t\t\t      u16 reg)\n{\n\tstruct sprd_pmic_eic *pmic_eic = gpiochip_get_data(chip);\n\tu32 value;\n\tint ret;\n\n\tret = regmap_read(pmic_eic->map, pmic_eic->offset + reg, &value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(value & BIT(SPRD_PMIC_EIC_BIT(offset)));\n}\n\nstatic int sprd_pmic_eic_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tsprd_pmic_eic_update(chip, offset, SPRD_PMIC_EIC_DMSK, 1);\n\treturn 0;\n}\n\nstatic void sprd_pmic_eic_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tsprd_pmic_eic_update(chip, offset, SPRD_PMIC_EIC_DMSK, 0);\n}\n\nstatic int sprd_pmic_eic_get(struct gpio_chip *chip, unsigned int offset)\n{\n\treturn sprd_pmic_eic_read(chip, offset, SPRD_PMIC_EIC_DATA);\n}\n\nstatic int sprd_pmic_eic_direction_input(struct gpio_chip *chip,\n\t\t\t\t\t unsigned int offset)\n{\n\t \n\treturn 0;\n}\n\nstatic void sprd_pmic_eic_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t      int value)\n{\n\t \n}\n\nstatic int sprd_pmic_eic_set_debounce(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset,\n\t\t\t\t      unsigned int debounce)\n{\n\tstruct sprd_pmic_eic *pmic_eic = gpiochip_get_data(chip);\n\tu32 reg, value;\n\tint ret;\n\n\treg = SPRD_PMIC_EIC_CTRL0 + SPRD_PMIC_EIC_BIT(offset) * 0x4;\n\tret = regmap_read(pmic_eic->map, pmic_eic->offset + reg, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tvalue &= ~SPRD_PMIC_EIC_DBNC_MASK;\n\tvalue |= (debounce / 1000) & SPRD_PMIC_EIC_DBNC_MASK;\n\treturn regmap_write(pmic_eic->map, pmic_eic->offset + reg, value);\n}\n\nstatic int sprd_pmic_eic_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t    unsigned long config)\n{\n\tunsigned long param = pinconf_to_config_param(config);\n\tu32 arg = pinconf_to_config_argument(config);\n\n\tif (param == PIN_CONFIG_INPUT_DEBOUNCE)\n\t\treturn sprd_pmic_eic_set_debounce(chip, offset, arg);\n\n\treturn -ENOTSUPP;\n}\n\nstatic void sprd_pmic_eic_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct sprd_pmic_eic *pmic_eic = gpiochip_get_data(chip);\n\tu32 offset = irqd_to_hwirq(data);\n\n\tpmic_eic->reg[REG_IE] = 0;\n\tpmic_eic->reg[REG_TRIG] = 0;\n\n\tgpiochip_disable_irq(chip, offset);\n}\n\nstatic void sprd_pmic_eic_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct sprd_pmic_eic *pmic_eic = gpiochip_get_data(chip);\n\tu32 offset = irqd_to_hwirq(data);\n\n\tgpiochip_enable_irq(chip, offset);\n\n\tpmic_eic->reg[REG_IE] = 1;\n\tpmic_eic->reg[REG_TRIG] = 1;\n}\n\nstatic int sprd_pmic_eic_irq_set_type(struct irq_data *data,\n\t\t\t\t      unsigned int flow_type)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct sprd_pmic_eic *pmic_eic = gpiochip_get_data(chip);\n\n\tswitch (flow_type) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tpmic_eic->reg[REG_IEV] = 1;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tpmic_eic->reg[REG_IEV] = 0;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void sprd_pmic_eic_bus_lock(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct sprd_pmic_eic *pmic_eic = gpiochip_get_data(chip);\n\n\tmutex_lock(&pmic_eic->buslock);\n}\n\nstatic void sprd_pmic_eic_bus_sync_unlock(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct sprd_pmic_eic *pmic_eic = gpiochip_get_data(chip);\n\tu32 trigger = irqd_get_trigger_type(data);\n\tu32 offset = irqd_to_hwirq(data);\n\tint state;\n\n\t \n\tif (trigger & IRQ_TYPE_EDGE_BOTH) {\n\t\tstate = sprd_pmic_eic_get(chip, offset);\n\t\tif (state)\n\t\t\tsprd_pmic_eic_update(chip, offset, SPRD_PMIC_EIC_IEV, 0);\n\t\telse\n\t\t\tsprd_pmic_eic_update(chip, offset, SPRD_PMIC_EIC_IEV, 1);\n\t} else {\n\t\tsprd_pmic_eic_update(chip, offset, SPRD_PMIC_EIC_IEV,\n\t\t\t\t     pmic_eic->reg[REG_IEV]);\n\t}\n\n\t \n\tsprd_pmic_eic_update(chip, offset, SPRD_PMIC_EIC_IE,\n\t\t\t     pmic_eic->reg[REG_IE]);\n\t \n\tsprd_pmic_eic_update(chip, offset, SPRD_PMIC_EIC_TRIG,\n\t\t\t     pmic_eic->reg[REG_TRIG]);\n\n\tmutex_unlock(&pmic_eic->buslock);\n}\n\nstatic void sprd_pmic_eic_toggle_trigger(struct gpio_chip *chip,\n\t\t\t\t\t unsigned int irq, unsigned int offset)\n{\n\tu32 trigger = irq_get_trigger_type(irq);\n\tint state, post_state;\n\n\tif (!(trigger & IRQ_TYPE_EDGE_BOTH))\n\t\treturn;\n\n\tstate = sprd_pmic_eic_get(chip, offset);\nretry:\n\tif (state)\n\t\tsprd_pmic_eic_update(chip, offset, SPRD_PMIC_EIC_IEV, 0);\n\telse\n\t\tsprd_pmic_eic_update(chip, offset, SPRD_PMIC_EIC_IEV, 1);\n\n\tpost_state = sprd_pmic_eic_get(chip, offset);\n\tif (state != post_state) {\n\t\tdev_warn(chip->parent, \"PMIC EIC level was changed.\\n\");\n\t\tstate = post_state;\n\t\tgoto retry;\n\t}\n\n\t \n\tsprd_pmic_eic_update(chip, offset, SPRD_PMIC_EIC_IE, 1);\n\t \n\tsprd_pmic_eic_update(chip, offset, SPRD_PMIC_EIC_TRIG, 1);\n}\n\nstatic irqreturn_t sprd_pmic_eic_irq_handler(int irq, void *data)\n{\n\tstruct sprd_pmic_eic *pmic_eic = data;\n\tstruct gpio_chip *chip = &pmic_eic->chip;\n\tunsigned long status;\n\tu32 n, girq, val;\n\tint ret;\n\n\tret = regmap_read(pmic_eic->map, pmic_eic->offset + SPRD_PMIC_EIC_MIS,\n\t\t\t  &val);\n\tif (ret)\n\t\treturn IRQ_RETVAL(ret);\n\n\tstatus = val & SPRD_PMIC_EIC_DATA_MASK;\n\n\tfor_each_set_bit(n, &status, chip->ngpio) {\n\t\t \n\t\tsprd_pmic_eic_update(chip, n, SPRD_PMIC_EIC_IC, 1);\n\n\t\tgirq = irq_find_mapping(chip->irq.domain, n);\n\t\thandle_nested_irq(girq);\n\n\t\t \n\t\tsprd_pmic_eic_toggle_trigger(chip, girq, n);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct irq_chip pmic_eic_irq_chip = {\n\t.name\t\t\t= \"sprd-pmic-eic\",\n\t.irq_mask\t\t= sprd_pmic_eic_irq_mask,\n\t.irq_unmask\t\t= sprd_pmic_eic_irq_unmask,\n\t.irq_set_type\t\t= sprd_pmic_eic_irq_set_type,\n\t.irq_bus_lock\t\t= sprd_pmic_eic_bus_lock,\n\t.irq_bus_sync_unlock\t= sprd_pmic_eic_bus_sync_unlock,\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int sprd_pmic_eic_probe(struct platform_device *pdev)\n{\n\tstruct gpio_irq_chip *irq;\n\tstruct sprd_pmic_eic *pmic_eic;\n\tint ret;\n\n\tpmic_eic = devm_kzalloc(&pdev->dev, sizeof(*pmic_eic), GFP_KERNEL);\n\tif (!pmic_eic)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&pmic_eic->buslock);\n\n\tpmic_eic->irq = platform_get_irq(pdev, 0);\n\tif (pmic_eic->irq < 0)\n\t\treturn pmic_eic->irq;\n\n\tpmic_eic->map = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!pmic_eic->map)\n\t\treturn -ENODEV;\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"reg\", &pmic_eic->offset);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to get PMIC EIC base address.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, pmic_eic->irq, NULL,\n\t\t\t\t\tsprd_pmic_eic_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_NO_SUSPEND,\n\t\t\t\t\tdev_name(&pdev->dev), pmic_eic);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request PMIC EIC IRQ.\\n\");\n\t\treturn ret;\n\t}\n\n\tpmic_eic->chip.label = dev_name(&pdev->dev);\n\tpmic_eic->chip.ngpio = SPRD_PMIC_EIC_NR;\n\tpmic_eic->chip.base = -1;\n\tpmic_eic->chip.parent = &pdev->dev;\n\tpmic_eic->chip.direction_input = sprd_pmic_eic_direction_input;\n\tpmic_eic->chip.request = sprd_pmic_eic_request;\n\tpmic_eic->chip.free = sprd_pmic_eic_free;\n\tpmic_eic->chip.set_config = sprd_pmic_eic_set_config;\n\tpmic_eic->chip.set = sprd_pmic_eic_set;\n\tpmic_eic->chip.get = sprd_pmic_eic_get;\n\tpmic_eic->chip.can_sleep = true;\n\n\tirq = &pmic_eic->chip.irq;\n\tgpio_irq_chip_set_chip(irq, &pmic_eic_irq_chip);\n\tirq->threaded = true;\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &pmic_eic->chip, pmic_eic);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Could not register gpiochip %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sprd_pmic_eic_of_match[] = {\n\t{ .compatible = \"sprd,sc2731-eic\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sprd_pmic_eic_of_match);\n\nstatic struct platform_driver sprd_pmic_eic_driver = {\n\t.probe = sprd_pmic_eic_probe,\n\t.driver = {\n\t\t.name = \"sprd-pmic-eic\",\n\t\t.of_match_table\t= sprd_pmic_eic_of_match,\n\t},\n};\n\nmodule_platform_driver(sprd_pmic_eic_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum PMIC EIC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}