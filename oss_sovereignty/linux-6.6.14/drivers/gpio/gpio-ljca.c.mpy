{
  "module_name": "gpio-ljca.c",
  "hash_id": "73e6640706a9dcc7195ac95b8b94c83f6df1859bc8299e867e8d98eaaaa3e560",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-ljca.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/dev_printk.h>\n#include <linux/gpio/driver.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/mfd/ljca.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n \n#define LJCA_GPIO_CONFIG\t1\n#define LJCA_GPIO_READ\t\t2\n#define LJCA_GPIO_WRITE\t\t3\n#define LJCA_GPIO_INT_EVENT\t4\n#define LJCA_GPIO_INT_MASK\t5\n#define LJCA_GPIO_INT_UNMASK\t6\n\n#define LJCA_GPIO_CONF_DISABLE\t\tBIT(0)\n#define LJCA_GPIO_CONF_INPUT\t\tBIT(1)\n#define LJCA_GPIO_CONF_OUTPUT\t\tBIT(2)\n#define LJCA_GPIO_CONF_PULLUP\t\tBIT(3)\n#define LJCA_GPIO_CONF_PULLDOWN\t\tBIT(4)\n#define LJCA_GPIO_CONF_DEFAULT\t\tBIT(5)\n#define LJCA_GPIO_CONF_INTERRUPT\tBIT(6)\n#define LJCA_GPIO_INT_TYPE\t\tBIT(7)\n\n#define LJCA_GPIO_CONF_EDGE\tFIELD_PREP(LJCA_GPIO_INT_TYPE, 1)\n#define LJCA_GPIO_CONF_LEVEL\tFIELD_PREP(LJCA_GPIO_INT_TYPE, 0)\n\n \n#define LJCA_GPIO_CONF_SET\tBIT(3)\n#define LJCA_GPIO_CONF_CLR\tBIT(4)\n\nstruct gpio_op {\n\tu8 index;\n\tu8 value;\n} __packed;\n\nstruct gpio_packet {\n\tu8 num;\n\tstruct gpio_op item[];\n} __packed;\n\n#define LJCA_GPIO_BUF_SIZE 60\nstruct ljca_gpio_dev {\n\tstruct platform_device *pdev;\n\tstruct gpio_chip gc;\n\tstruct ljca_gpio_info *gpio_info;\n\tDECLARE_BITMAP(unmasked_irqs, LJCA_MAX_GPIO_NUM);\n\tDECLARE_BITMAP(enabled_irqs, LJCA_MAX_GPIO_NUM);\n\tDECLARE_BITMAP(reenable_irqs, LJCA_MAX_GPIO_NUM);\n\tu8 *connect_mode;\n\t \n\tstruct mutex irq_lock;\n\tstruct work_struct work;\n\t \n\tstruct mutex trans_lock;\n\n\tu8 obuf[LJCA_GPIO_BUF_SIZE];\n\tu8 ibuf[LJCA_GPIO_BUF_SIZE];\n};\n\nstatic int gpio_config(struct ljca_gpio_dev *ljca_gpio, u8 gpio_id, u8 config)\n{\n\tstruct gpio_packet *packet = (struct gpio_packet *)ljca_gpio->obuf;\n\tint ret;\n\n\tmutex_lock(&ljca_gpio->trans_lock);\n\tpacket->item[0].index = gpio_id;\n\tpacket->item[0].value = config | ljca_gpio->connect_mode[gpio_id];\n\tpacket->num = 1;\n\n\tret = ljca_transfer(ljca_gpio->gpio_info->ljca, LJCA_GPIO_CONFIG, packet,\n\t\t\t    struct_size(packet, item, packet->num), NULL, NULL);\n\tmutex_unlock(&ljca_gpio->trans_lock);\n\treturn ret;\n}\n\nstatic int ljca_gpio_read(struct ljca_gpio_dev *ljca_gpio, u8 gpio_id)\n{\n\tstruct gpio_packet *packet = (struct gpio_packet *)ljca_gpio->obuf;\n\tstruct gpio_packet *ack_packet = (struct gpio_packet *)ljca_gpio->ibuf;\n\tunsigned int ibuf_len = LJCA_GPIO_BUF_SIZE;\n\tint ret;\n\n\tmutex_lock(&ljca_gpio->trans_lock);\n\tpacket->num = 1;\n\tpacket->item[0].index = gpio_id;\n\tret = ljca_transfer(ljca_gpio->gpio_info->ljca, LJCA_GPIO_READ, packet,\n\t\t\t    struct_size(packet, item, packet->num), ljca_gpio->ibuf, &ibuf_len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (!ibuf_len || ack_packet->num != packet->num) {\n\t\tdev_err(&ljca_gpio->pdev->dev, \"failed gpio_id:%u %u\", gpio_id, ack_packet->num);\n\t\tret = -EIO;\n\t}\n\nout_unlock:\n\tmutex_unlock(&ljca_gpio->trans_lock);\n\tif (ret)\n\t\treturn ret;\n\treturn ack_packet->item[0].value > 0;\n}\n\nstatic int ljca_gpio_write(struct ljca_gpio_dev *ljca_gpio, u8 gpio_id,\n\t\t\t   int value)\n{\n\tstruct gpio_packet *packet = (struct gpio_packet *)ljca_gpio->obuf;\n\tint ret;\n\n\tmutex_lock(&ljca_gpio->trans_lock);\n\tpacket->num = 1;\n\tpacket->item[0].index = gpio_id;\n\tpacket->item[0].value = value & 1;\n\n\tret = ljca_transfer(ljca_gpio->gpio_info->ljca, LJCA_GPIO_WRITE, packet,\n\t\t\t    struct_size(packet, item, packet->num), NULL, NULL);\n\tmutex_unlock(&ljca_gpio->trans_lock);\n\treturn ret;\n}\n\nstatic int ljca_gpio_get_value(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct ljca_gpio_dev *ljca_gpio = gpiochip_get_data(chip);\n\n\treturn ljca_gpio_read(ljca_gpio, offset);\n}\n\nstatic void ljca_gpio_set_value(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\tint val)\n{\n\tstruct ljca_gpio_dev *ljca_gpio = gpiochip_get_data(chip);\n\tint ret;\n\n\tret = ljca_gpio_write(ljca_gpio, offset, val);\n\tif (ret)\n\t\tdev_err(chip->parent, \"offset:%u val:%d set value failed %d\\n\", offset, val, ret);\n}\n\nstatic int ljca_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset)\n{\n\tstruct ljca_gpio_dev *ljca_gpio = gpiochip_get_data(chip);\n\tu8 config = LJCA_GPIO_CONF_INPUT | LJCA_GPIO_CONF_CLR;\n\n\treturn gpio_config(ljca_gpio, offset, config);\n}\n\nstatic int ljca_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset, int val)\n{\n\tstruct ljca_gpio_dev *ljca_gpio = gpiochip_get_data(chip);\n\tu8 config = LJCA_GPIO_CONF_OUTPUT | LJCA_GPIO_CONF_CLR;\n\tint ret;\n\n\tret = gpio_config(ljca_gpio, offset, config);\n\tif (ret)\n\t\treturn ret;\n\n\tljca_gpio_set_value(chip, offset, val);\n\treturn 0;\n}\n\nstatic int ljca_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\tunsigned long config)\n{\n\tstruct ljca_gpio_dev *ljca_gpio = gpiochip_get_data(chip);\n\n\tljca_gpio->connect_mode[offset] = 0;\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tljca_gpio->connect_mode[offset] |= LJCA_GPIO_CONF_PULLUP;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tljca_gpio->connect_mode[offset] |= LJCA_GPIO_CONF_PULLDOWN;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\tcase PIN_CONFIG_PERSIST_STATE:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ljca_gpio_init_valid_mask(struct gpio_chip *chip, unsigned long *valid_mask,\n\t\t\t\t     unsigned int ngpios)\n{\n\tstruct ljca_gpio_dev *ljca_gpio = gpiochip_get_data(chip);\n\n\tWARN_ON_ONCE(ngpios != ljca_gpio->gpio_info->num);\n\tbitmap_copy(valid_mask, ljca_gpio->gpio_info->valid_pin_map, ngpios);\n\n\treturn 0;\n}\n\nstatic void ljca_gpio_irq_init_valid_mask(struct gpio_chip *chip, unsigned long *valid_mask,\n\t\t\t\t\t  unsigned int ngpios)\n{\n\tljca_gpio_init_valid_mask(chip, valid_mask, ngpios);\n}\n\nstatic int ljca_enable_irq(struct ljca_gpio_dev *ljca_gpio, int gpio_id, bool enable)\n{\n\tstruct gpio_packet *packet = (struct gpio_packet *)ljca_gpio->obuf;\n\tint ret;\n\n\tmutex_lock(&ljca_gpio->trans_lock);\n\tpacket->num = 1;\n\tpacket->item[0].index = gpio_id;\n\tpacket->item[0].value = 0;\n\n\tret = ljca_transfer(ljca_gpio->gpio_info->ljca,\n\t\t\t    enable ? LJCA_GPIO_INT_UNMASK : LJCA_GPIO_INT_MASK, packet,\n\t\t\t    struct_size(packet, item, packet->num), NULL, NULL);\n\tmutex_unlock(&ljca_gpio->trans_lock);\n\treturn ret;\n}\n\nstatic void ljca_gpio_async(struct work_struct *work)\n{\n\tstruct ljca_gpio_dev *ljca_gpio = container_of(work, struct ljca_gpio_dev, work);\n\tint gpio_id;\n\tint unmasked;\n\n\tfor_each_set_bit(gpio_id, ljca_gpio->reenable_irqs, ljca_gpio->gc.ngpio) {\n\t\tclear_bit(gpio_id, ljca_gpio->reenable_irqs);\n\t\tunmasked = test_bit(gpio_id, ljca_gpio->unmasked_irqs);\n\t\tif (unmasked)\n\t\t\tljca_enable_irq(ljca_gpio, gpio_id, true);\n\t}\n}\n\nstatic void ljca_gpio_event_cb(void *context, u8 cmd, const void *evt_data, int len)\n{\n\tconst struct gpio_packet *packet = evt_data;\n\tstruct ljca_gpio_dev *ljca_gpio = context;\n\tint i;\n\tint irq;\n\n\tif (cmd != LJCA_GPIO_INT_EVENT)\n\t\treturn;\n\n\tfor (i = 0; i < packet->num; i++) {\n\t\tirq = irq_find_mapping(ljca_gpio->gc.irq.domain, packet->item[i].index);\n\t\tif (!irq) {\n\t\t\tdev_err(ljca_gpio->gc.parent, \"gpio_id %u does not mapped to IRQ yet\\n\",\n\t\t\t\tpacket->item[i].index);\n\t\t\treturn;\n\t\t}\n\n\t\tgeneric_handle_domain_irq(ljca_gpio->gc.irq.domain, irq);\n\t\tset_bit(packet->item[i].index, ljca_gpio->reenable_irqs);\n\t}\n\n\tschedule_work(&ljca_gpio->work);\n}\n\nstatic void ljca_irq_unmask(struct irq_data *irqd)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct ljca_gpio_dev *ljca_gpio = gpiochip_get_data(gc);\n\tint gpio_id = irqd_to_hwirq(irqd);\n\n\tgpiochip_enable_irq(gc, gpio_id);\n\tset_bit(gpio_id, ljca_gpio->unmasked_irqs);\n}\n\nstatic void ljca_irq_mask(struct irq_data *irqd)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct ljca_gpio_dev *ljca_gpio = gpiochip_get_data(gc);\n\tint gpio_id = irqd_to_hwirq(irqd);\n\n\tclear_bit(gpio_id, ljca_gpio->unmasked_irqs);\n\tgpiochip_disable_irq(gc, gpio_id);\n}\n\nstatic int ljca_irq_set_type(struct irq_data *irqd, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct ljca_gpio_dev *ljca_gpio = gpiochip_get_data(gc);\n\tint gpio_id = irqd_to_hwirq(irqd);\n\n\tljca_gpio->connect_mode[gpio_id] = LJCA_GPIO_CONF_INTERRUPT;\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tljca_gpio->connect_mode[gpio_id] |= (LJCA_GPIO_CONF_LEVEL | LJCA_GPIO_CONF_PULLUP);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tljca_gpio->connect_mode[gpio_id] |= (LJCA_GPIO_CONF_LEVEL | LJCA_GPIO_CONF_PULLDOWN);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tljca_gpio->connect_mode[gpio_id] |= (LJCA_GPIO_CONF_EDGE | LJCA_GPIO_CONF_PULLUP);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tljca_gpio->connect_mode[gpio_id] |= (LJCA_GPIO_CONF_EDGE | LJCA_GPIO_CONF_PULLDOWN);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void ljca_irq_bus_lock(struct irq_data *irqd)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct ljca_gpio_dev *ljca_gpio = gpiochip_get_data(gc);\n\n\tmutex_lock(&ljca_gpio->irq_lock);\n}\n\nstatic void ljca_irq_bus_unlock(struct irq_data *irqd)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct ljca_gpio_dev *ljca_gpio = gpiochip_get_data(gc);\n\tint gpio_id = irqd_to_hwirq(irqd);\n\tint enabled;\n\tint unmasked;\n\n\tenabled = test_bit(gpio_id, ljca_gpio->enabled_irqs);\n\tunmasked = test_bit(gpio_id, ljca_gpio->unmasked_irqs);\n\n\tif (enabled != unmasked) {\n\t\tif (unmasked) {\n\t\t\tgpio_config(ljca_gpio, gpio_id, 0);\n\t\t\tljca_enable_irq(ljca_gpio, gpio_id, true);\n\t\t\tset_bit(gpio_id, ljca_gpio->enabled_irqs);\n\t\t} else {\n\t\t\tljca_enable_irq(ljca_gpio, gpio_id, false);\n\t\t\tclear_bit(gpio_id, ljca_gpio->enabled_irqs);\n\t\t}\n\t}\n\n\tmutex_unlock(&ljca_gpio->irq_lock);\n}\n\nstatic const struct irq_chip ljca_gpio_irqchip = {\n\t.name = \"ljca-irq\",\n\t.irq_mask = ljca_irq_mask,\n\t.irq_unmask = ljca_irq_unmask,\n\t.irq_set_type = ljca_irq_set_type,\n\t.irq_bus_lock = ljca_irq_bus_lock,\n\t.irq_bus_sync_unlock = ljca_irq_bus_unlock,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int ljca_gpio_probe(struct platform_device *pdev)\n{\n\tstruct ljca_gpio_dev *ljca_gpio;\n\tstruct gpio_irq_chip *girq;\n\tint ret;\n\n\tljca_gpio = devm_kzalloc(&pdev->dev, sizeof(*ljca_gpio), GFP_KERNEL);\n\tif (!ljca_gpio)\n\t\treturn -ENOMEM;\n\n\tljca_gpio->gpio_info = dev_get_platdata(&pdev->dev);\n\tljca_gpio->connect_mode = devm_kcalloc(&pdev->dev, ljca_gpio->gpio_info->num,\n\t\t\t\t\t       sizeof(*ljca_gpio->connect_mode), GFP_KERNEL);\n\tif (!ljca_gpio->connect_mode)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ljca_gpio->irq_lock);\n\tmutex_init(&ljca_gpio->trans_lock);\n\tljca_gpio->pdev = pdev;\n\tljca_gpio->gc.direction_input = ljca_gpio_direction_input;\n\tljca_gpio->gc.direction_output = ljca_gpio_direction_output;\n\tljca_gpio->gc.get = ljca_gpio_get_value;\n\tljca_gpio->gc.set = ljca_gpio_set_value;\n\tljca_gpio->gc.set_config = ljca_gpio_set_config;\n\tljca_gpio->gc.init_valid_mask = ljca_gpio_init_valid_mask;\n\tljca_gpio->gc.can_sleep = true;\n\tljca_gpio->gc.parent = &pdev->dev;\n\n\tljca_gpio->gc.base = -1;\n\tljca_gpio->gc.ngpio = ljca_gpio->gpio_info->num;\n\tljca_gpio->gc.label = ACPI_COMPANION(&pdev->dev) ?\n\t\t\t      acpi_dev_name(ACPI_COMPANION(&pdev->dev)) :\n\t\t\t      dev_name(&pdev->dev);\n\tljca_gpio->gc.owner = THIS_MODULE;\n\n\tplatform_set_drvdata(pdev, ljca_gpio);\n\tljca_register_event_cb(ljca_gpio->gpio_info->ljca, ljca_gpio_event_cb, ljca_gpio);\n\n\tgirq = &ljca_gpio->gc.irq;\n\tgpio_irq_chip_set_chip(girq, &ljca_gpio_irqchip);\n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_simple_irq;\n\tgirq->init_valid_mask = ljca_gpio_irq_init_valid_mask;\n\n\tINIT_WORK(&ljca_gpio->work, ljca_gpio_async);\n\tret = gpiochip_add_data(&ljca_gpio->gc, ljca_gpio);\n\tif (ret) {\n\t\tljca_unregister_event_cb(ljca_gpio->gpio_info->ljca);\n\t\tmutex_destroy(&ljca_gpio->irq_lock);\n\t\tmutex_destroy(&ljca_gpio->trans_lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int ljca_gpio_remove(struct platform_device *pdev)\n{\n\tstruct ljca_gpio_dev *ljca_gpio = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&ljca_gpio->gc);\n\tljca_unregister_event_cb(ljca_gpio->gpio_info->ljca);\n\tmutex_destroy(&ljca_gpio->irq_lock);\n\tmutex_destroy(&ljca_gpio->trans_lock);\n\treturn 0;\n}\n\n#define LJCA_GPIO_DRV_NAME \"ljca-gpio\"\nstatic const struct platform_device_id ljca_gpio_id[] = {\n\t{ LJCA_GPIO_DRV_NAME, 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, ljca_gpio_id);\n\nstatic struct platform_driver ljca_gpio_driver = {\n\t.driver.name = LJCA_GPIO_DRV_NAME,\n\t.probe = ljca_gpio_probe,\n\t.remove = ljca_gpio_remove,\n};\nmodule_platform_driver(ljca_gpio_driver);\n\nMODULE_AUTHOR(\"Ye Xiang <xiang.ye@intel.com>\");\nMODULE_AUTHOR(\"Wang Zhifeng <zhifeng.wang@intel.com>\");\nMODULE_AUTHOR(\"Zhang Lixu <lixu.zhang@intel.com>\");\nMODULE_DESCRIPTION(\"Intel La Jolla Cove Adapter USB-GPIO driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(LJCA);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}