{
  "module_name": "gpio-ml-ioh.c",
  "hash_id": "4e27ea40e980e1d429576a06dbb396de0c8c28f40c5831aaf36a27209f8f5127",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-ml-ioh.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n\n#define IOH_EDGE_FALLING\t0\n#define IOH_EDGE_RISING\t\tBIT(0)\n#define IOH_LEVEL_L\t\tBIT(1)\n#define IOH_LEVEL_H\t\t(BIT(0) | BIT(1))\n#define IOH_EDGE_BOTH\t\tBIT(2)\n#define IOH_IM_MASK\t\t(BIT(0) | BIT(1) | BIT(2))\n\n#define IOH_IRQ_BASE\t\t0\n\nstruct ioh_reg_comn {\n\tu32\tien;\n\tu32\tistatus;\n\tu32\tidisp;\n\tu32\ticlr;\n\tu32\timask;\n\tu32\timaskclr;\n\tu32\tpo;\n\tu32\tpi;\n\tu32\tpm;\n\tu32\tim_0;\n\tu32\tim_1;\n\tu32\treserved;\n};\n\nstruct ioh_regs {\n\tstruct ioh_reg_comn regs[8];\n\tu32 reserve1[16];\n\tu32 ioh_sel_reg[4];\n\tu32 reserve2[11];\n\tu32 srst;\n};\n\n \nstruct ioh_gpio_reg_data {\n\tu32 ien_reg;\n\tu32 imask_reg;\n\tu32 po_reg;\n\tu32 pm_reg;\n\tu32 im0_reg;\n\tu32 im1_reg;\n\tu32 use_sel_reg;\n};\n\n \nstruct ioh_gpio {\n\tvoid __iomem *base;\n\tstruct ioh_regs __iomem *reg;\n\tstruct device *dev;\n\tstruct gpio_chip gpio;\n\tstruct ioh_gpio_reg_data ioh_gpio_reg;\n\tu32 gpio_use_sel;\n\tint ch;\n\tint irq_base;\n\tspinlock_t spinlock;\n};\n\nstatic const int num_ports[] = {6, 12, 16, 16, 15, 16, 16, 12};\n\nstatic void ioh_gpio_set(struct gpio_chip *gpio, unsigned nr, int val)\n{\n\tu32 reg_val;\n\tstruct ioh_gpio *chip =\tgpiochip_get_data(gpio);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\treg_val = ioread32(&chip->reg->regs[chip->ch].po);\n\tif (val)\n\t\treg_val |= BIT(nr);\n\telse\n\t\treg_val &= ~BIT(nr);\n\n\tiowrite32(reg_val, &chip->reg->regs[chip->ch].po);\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n}\n\nstatic int ioh_gpio_get(struct gpio_chip *gpio, unsigned nr)\n{\n\tstruct ioh_gpio *chip =\tgpiochip_get_data(gpio);\n\n\treturn !!(ioread32(&chip->reg->regs[chip->ch].pi) & BIT(nr));\n}\n\nstatic int ioh_gpio_direction_output(struct gpio_chip *gpio, unsigned nr,\n\t\t\t\t     int val)\n{\n\tstruct ioh_gpio *chip =\tgpiochip_get_data(gpio);\n\tu32 pm;\n\tu32 reg_val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\tpm = ioread32(&chip->reg->regs[chip->ch].pm);\n\tpm &= BIT(num_ports[chip->ch]) - 1;\n\tpm |= BIT(nr);\n\tiowrite32(pm, &chip->reg->regs[chip->ch].pm);\n\n\treg_val = ioread32(&chip->reg->regs[chip->ch].po);\n\tif (val)\n\t\treg_val |= BIT(nr);\n\telse\n\t\treg_val &= ~BIT(nr);\n\tiowrite32(reg_val, &chip->reg->regs[chip->ch].po);\n\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int ioh_gpio_direction_input(struct gpio_chip *gpio, unsigned nr)\n{\n\tstruct ioh_gpio *chip =\tgpiochip_get_data(gpio);\n\tu32 pm;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\tpm = ioread32(&chip->reg->regs[chip->ch].pm);\n\tpm &= BIT(num_ports[chip->ch]) - 1;\n\tpm &= ~BIT(nr);\n\tiowrite32(pm, &chip->reg->regs[chip->ch].pm);\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\treturn 0;\n}\n\n \nstatic void __maybe_unused ioh_gpio_save_reg_conf(struct ioh_gpio *chip)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i ++, chip++) {\n\t\tchip->ioh_gpio_reg.po_reg =\n\t\t\t\t\tioread32(&chip->reg->regs[chip->ch].po);\n\t\tchip->ioh_gpio_reg.pm_reg =\n\t\t\t\t\tioread32(&chip->reg->regs[chip->ch].pm);\n\t\tchip->ioh_gpio_reg.ien_reg =\n\t\t\t\t       ioread32(&chip->reg->regs[chip->ch].ien);\n\t\tchip->ioh_gpio_reg.imask_reg =\n\t\t\t\t     ioread32(&chip->reg->regs[chip->ch].imask);\n\t\tchip->ioh_gpio_reg.im0_reg =\n\t\t\t\t      ioread32(&chip->reg->regs[chip->ch].im_0);\n\t\tchip->ioh_gpio_reg.im1_reg =\n\t\t\t\t      ioread32(&chip->reg->regs[chip->ch].im_1);\n\t\tif (i < 4)\n\t\t\tchip->ioh_gpio_reg.use_sel_reg =\n\t\t\t\t\t   ioread32(&chip->reg->ioh_sel_reg[i]);\n\t}\n}\n\n \nstatic void __maybe_unused ioh_gpio_restore_reg_conf(struct ioh_gpio *chip)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i ++, chip++) {\n\t\tiowrite32(chip->ioh_gpio_reg.po_reg,\n\t\t\t  &chip->reg->regs[chip->ch].po);\n\t\tiowrite32(chip->ioh_gpio_reg.pm_reg,\n\t\t\t  &chip->reg->regs[chip->ch].pm);\n\t\tiowrite32(chip->ioh_gpio_reg.ien_reg,\n\t\t\t  &chip->reg->regs[chip->ch].ien);\n\t\tiowrite32(chip->ioh_gpio_reg.imask_reg,\n\t\t\t  &chip->reg->regs[chip->ch].imask);\n\t\tiowrite32(chip->ioh_gpio_reg.im0_reg,\n\t\t\t  &chip->reg->regs[chip->ch].im_0);\n\t\tiowrite32(chip->ioh_gpio_reg.im1_reg,\n\t\t\t  &chip->reg->regs[chip->ch].im_1);\n\t\tif (i < 4)\n\t\t\tiowrite32(chip->ioh_gpio_reg.use_sel_reg,\n\t\t\t\t  &chip->reg->ioh_sel_reg[i]);\n\t}\n}\n\nstatic int ioh_gpio_to_irq(struct gpio_chip *gpio, unsigned offset)\n{\n\tstruct ioh_gpio *chip = gpiochip_get_data(gpio);\n\treturn chip->irq_base + offset;\n}\n\nstatic void ioh_gpio_setup(struct ioh_gpio *chip, int num_port)\n{\n\tstruct gpio_chip *gpio = &chip->gpio;\n\n\tgpio->label = dev_name(chip->dev);\n\tgpio->owner = THIS_MODULE;\n\tgpio->direction_input = ioh_gpio_direction_input;\n\tgpio->get = ioh_gpio_get;\n\tgpio->direction_output = ioh_gpio_direction_output;\n\tgpio->set = ioh_gpio_set;\n\tgpio->dbg_show = NULL;\n\tgpio->base = -1;\n\tgpio->ngpio = num_port;\n\tgpio->can_sleep = false;\n\tgpio->to_irq = ioh_gpio_to_irq;\n}\n\nstatic int ioh_irq_type(struct irq_data *d, unsigned int type)\n{\n\tu32 im;\n\tvoid __iomem *im_reg;\n\tu32 ien;\n\tu32 im_pos;\n\tint ch;\n\tunsigned long flags;\n\tu32 val;\n\tint irq = d->irq;\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct ioh_gpio *chip = gc->private;\n\n\tch = irq - chip->irq_base;\n\tif (irq <= chip->irq_base + 7) {\n\t\tim_reg = &chip->reg->regs[chip->ch].im_0;\n\t\tim_pos = ch;\n\t} else {\n\t\tim_reg = &chip->reg->regs[chip->ch].im_1;\n\t\tim_pos = ch - 8;\n\t}\n\tdev_dbg(chip->dev, \"%s:irq=%d type=%d ch=%d pos=%d type=%d\\n\",\n\t\t__func__, irq, type, ch, im_pos, type);\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tval = IOH_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tval = IOH_EDGE_FALLING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tval = IOH_EDGE_BOTH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tval = IOH_LEVEL_H;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tval = IOH_LEVEL_L;\n\t\tbreak;\n\tcase IRQ_TYPE_PROBE:\n\t\tgoto end;\n\tdefault:\n\t\tdev_warn(chip->dev, \"%s: unknown type(%dd)\",\n\t\t\t__func__, type);\n\t\tgoto end;\n\t}\n\n\t \n\tim = ioread32(im_reg) & ~(IOH_IM_MASK << (im_pos * 4));\n\tiowrite32(im | (val << (im_pos * 4)), im_reg);\n\n\t \n\tiowrite32(BIT(ch), &chip->reg->regs[chip->ch].iclr);\n\n\t \n\tiowrite32(BIT(ch), &chip->reg->regs[chip->ch].imaskclr);\n\n\t \n\tien = ioread32(&chip->reg->regs[chip->ch].ien);\n\tiowrite32(ien | BIT(ch), &chip->reg->regs[chip->ch].ien);\nend:\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic void ioh_irq_unmask(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct ioh_gpio *chip = gc->private;\n\n\tiowrite32(BIT(d->irq - chip->irq_base),\n\t\t  &chip->reg->regs[chip->ch].imaskclr);\n}\n\nstatic void ioh_irq_mask(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct ioh_gpio *chip = gc->private;\n\n\tiowrite32(BIT(d->irq - chip->irq_base),\n\t\t  &chip->reg->regs[chip->ch].imask);\n}\n\nstatic void ioh_irq_disable(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct ioh_gpio *chip = gc->private;\n\tunsigned long flags;\n\tu32 ien;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\tien = ioread32(&chip->reg->regs[chip->ch].ien);\n\tien &= ~BIT(d->irq - chip->irq_base);\n\tiowrite32(ien, &chip->reg->regs[chip->ch].ien);\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n}\n\nstatic void ioh_irq_enable(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct ioh_gpio *chip = gc->private;\n\tunsigned long flags;\n\tu32 ien;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\tien = ioread32(&chip->reg->regs[chip->ch].ien);\n\tien |= BIT(d->irq - chip->irq_base);\n\tiowrite32(ien, &chip->reg->regs[chip->ch].ien);\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n}\n\nstatic irqreturn_t ioh_gpio_handler(int irq, void *dev_id)\n{\n\tstruct ioh_gpio *chip = dev_id;\n\tu32 reg_val;\n\tint i, j;\n\tint ret = IRQ_NONE;\n\n\tfor (i = 0; i < 8; i++, chip++) {\n\t\treg_val = ioread32(&chip->reg->regs[i].istatus);\n\t\tfor (j = 0; j < num_ports[i]; j++) {\n\t\t\tif (reg_val & BIT(j)) {\n\t\t\t\tdev_dbg(chip->dev,\n\t\t\t\t\t\"%s:[%d]:irq=%d status=0x%x\\n\",\n\t\t\t\t\t__func__, j, irq, reg_val);\n\t\t\t\tiowrite32(BIT(j),\n\t\t\t\t\t  &chip->reg->regs[chip->ch].iclr);\n\t\t\t\tgeneric_handle_irq(chip->irq_base + j);\n\t\t\t\tret = IRQ_HANDLED;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int ioh_gpio_alloc_generic_chip(struct ioh_gpio *chip,\n\t\t\t\t       unsigned int irq_start,\n\t\t\t\t       unsigned int num)\n{\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\tint rv;\n\n\tgc = devm_irq_alloc_generic_chip(chip->dev, \"ioh_gpio\", 1, irq_start,\n\t\t\t\t\t chip->base, handle_simple_irq);\n\tif (!gc)\n\t\treturn -ENOMEM;\n\n\tgc->private = chip;\n\tct = gc->chip_types;\n\n\tct->chip.irq_mask = ioh_irq_mask;\n\tct->chip.irq_unmask = ioh_irq_unmask;\n\tct->chip.irq_set_type = ioh_irq_type;\n\tct->chip.irq_disable = ioh_irq_disable;\n\tct->chip.irq_enable = ioh_irq_enable;\n\n\trv = devm_irq_setup_generic_chip(chip->dev, gc, IRQ_MSK(num),\n\t\t\t\t\t IRQ_GC_INIT_MASK_CACHE,\n\t\t\t\t\t IRQ_NOREQUEST | IRQ_NOPROBE, 0);\n\n\treturn rv;\n}\n\nstatic int ioh_gpio_probe(struct pci_dev *pdev,\n\t\t\t\t    const struct pci_device_id *id)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\tint i, j;\n\tstruct ioh_gpio *chip;\n\tvoid __iomem *base;\n\tvoid *chip_save;\n\tint irq_base;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"%s : pcim_enable_device failed\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = pcim_iomap_regions(pdev, BIT(1), KBUILD_MODNAME);\n\tif (ret) {\n\t\tdev_err(dev, \"pcim_iomap_regions failed-%d\", ret);\n\t\treturn ret;\n\t}\n\n\tbase = pcim_iomap_table(pdev)[1];\n\tif (!base) {\n\t\tdev_err(dev, \"%s : pcim_iomap_table failed\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tchip_save = devm_kcalloc(dev, 8, sizeof(*chip), GFP_KERNEL);\n\tif (chip_save == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\n\tchip = chip_save;\n\tfor (i = 0; i < 8; i++, chip++) {\n\t\tchip->dev = dev;\n\t\tchip->base = base;\n\t\tchip->reg = chip->base;\n\t\tchip->ch = i;\n\t\tspin_lock_init(&chip->spinlock);\n\t\tioh_gpio_setup(chip, num_ports[i]);\n\t\tret = devm_gpiochip_add_data(dev, &chip->gpio, chip);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"IOH gpio: Failed to register GPIO\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tchip = chip_save;\n\tfor (j = 0; j < 8; j++, chip++) {\n\t\tirq_base = devm_irq_alloc_descs(dev, -1, IOH_IRQ_BASE,\n\t\t\t\t\t\tnum_ports[j], NUMA_NO_NODE);\n\t\tif (irq_base < 0) {\n\t\t\tdev_warn(dev,\n\t\t\t\t\"ml_ioh_gpio: Failed to get IRQ base num\\n\");\n\t\t\treturn irq_base;\n\t\t}\n\t\tchip->irq_base = irq_base;\n\n\t\tret = ioh_gpio_alloc_generic_chip(chip,\n\t\t\t\t\t\t  irq_base, num_ports[j]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tchip = chip_save;\n\tret = devm_request_irq(dev, pdev->irq, ioh_gpio_handler,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, chip);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"%s request_irq failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tpci_set_drvdata(pdev, chip);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ioh_gpio_suspend(struct device *dev)\n{\n\tstruct ioh_gpio *chip = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\tioh_gpio_save_reg_conf(chip);\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ioh_gpio_resume(struct device *dev)\n{\n\tstruct ioh_gpio *chip = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\tiowrite32(0x01, &chip->reg->srst);\n\tiowrite32(0x00, &chip->reg->srst);\n\tioh_gpio_restore_reg_conf(chip);\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ioh_gpio_pm_ops, ioh_gpio_suspend, ioh_gpio_resume);\n\nstatic const struct pci_device_id ioh_gpio_pcidev_id[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ROHM, 0x802E) },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, ioh_gpio_pcidev_id);\n\nstatic struct pci_driver ioh_gpio_driver = {\n\t.name = \"ml_ioh_gpio\",\n\t.id_table = ioh_gpio_pcidev_id,\n\t.probe = ioh_gpio_probe,\n\t.driver = {\n\t\t.pm = &ioh_gpio_pm_ops,\n\t},\n};\n\nmodule_pci_driver(ioh_gpio_driver);\n\nMODULE_DESCRIPTION(\"OKI SEMICONDUCTOR ML-IOH series GPIO Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}