{
  "module_name": "gpio-regmap.c",
  "hash_id": "794b834ef56acb5673c8b26954d5663b73e28cb0f2adbcc408787c6394936dae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-regmap.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <linux/gpio/driver.h>\n#include <linux/gpio/regmap.h>\n\nstruct gpio_regmap {\n\tstruct device *parent;\n\tstruct regmap *regmap;\n\tstruct gpio_chip gpio_chip;\n\n\tint reg_stride;\n\tint ngpio_per_reg;\n\tunsigned int reg_dat_base;\n\tunsigned int reg_set_base;\n\tunsigned int reg_clr_base;\n\tunsigned int reg_dir_in_base;\n\tunsigned int reg_dir_out_base;\n\n\tint (*reg_mask_xlate)(struct gpio_regmap *gpio, unsigned int base,\n\t\t\t      unsigned int offset, unsigned int *reg,\n\t\t\t      unsigned int *mask);\n\n\tvoid *driver_data;\n};\n\nstatic unsigned int gpio_regmap_addr(unsigned int addr)\n{\n\tif (addr == GPIO_REGMAP_ADDR_ZERO)\n\t\treturn 0;\n\n\treturn addr;\n}\n\nstatic int gpio_regmap_simple_xlate(struct gpio_regmap *gpio,\n\t\t\t\t    unsigned int base, unsigned int offset,\n\t\t\t\t    unsigned int *reg, unsigned int *mask)\n{\n\tunsigned int line = offset % gpio->ngpio_per_reg;\n\tunsigned int stride = offset / gpio->ngpio_per_reg;\n\n\t*reg = base + stride * gpio->reg_stride;\n\t*mask = BIT(line);\n\n\treturn 0;\n}\n\nstatic int gpio_regmap_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct gpio_regmap *gpio = gpiochip_get_data(chip);\n\tunsigned int base, val, reg, mask;\n\tint ret;\n\n\t \n\tif (gpio->reg_dat_base)\n\t\tbase = gpio_regmap_addr(gpio->reg_dat_base);\n\telse\n\t\tbase = gpio_regmap_addr(gpio->reg_set_base);\n\n\tret = gpio->reg_mask_xlate(gpio, base, offset, &reg, &mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(gpio->regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & mask);\n}\n\nstatic void gpio_regmap_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t    int val)\n{\n\tstruct gpio_regmap *gpio = gpiochip_get_data(chip);\n\tunsigned int base = gpio_regmap_addr(gpio->reg_set_base);\n\tunsigned int reg, mask;\n\n\tgpio->reg_mask_xlate(gpio, base, offset, &reg, &mask);\n\tif (val)\n\t\tregmap_update_bits(gpio->regmap, reg, mask, mask);\n\telse\n\t\tregmap_update_bits(gpio->regmap, reg, mask, 0);\n}\n\nstatic void gpio_regmap_set_with_clear(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset, int val)\n{\n\tstruct gpio_regmap *gpio = gpiochip_get_data(chip);\n\tunsigned int base, reg, mask;\n\n\tif (val)\n\t\tbase = gpio_regmap_addr(gpio->reg_set_base);\n\telse\n\t\tbase = gpio_regmap_addr(gpio->reg_clr_base);\n\n\tgpio->reg_mask_xlate(gpio, base, offset, &reg, &mask);\n\tregmap_write(gpio->regmap, reg, mask);\n}\n\nstatic int gpio_regmap_get_direction(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset)\n{\n\tstruct gpio_regmap *gpio = gpiochip_get_data(chip);\n\tunsigned int base, val, reg, mask;\n\tint invert, ret;\n\n\tif (gpio->reg_dat_base && !gpio->reg_set_base)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\tif (gpio->reg_set_base && !gpio->reg_dat_base)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\tif (gpio->reg_dir_out_base) {\n\t\tbase = gpio_regmap_addr(gpio->reg_dir_out_base);\n\t\tinvert = 0;\n\t} else if (gpio->reg_dir_in_base) {\n\t\tbase = gpio_regmap_addr(gpio->reg_dir_in_base);\n\t\tinvert = 1;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = gpio->reg_mask_xlate(gpio, base, offset, &reg, &mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(gpio->regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!!(val & mask) ^ invert)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\telse\n\t\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int gpio_regmap_set_direction(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset, bool output)\n{\n\tstruct gpio_regmap *gpio = gpiochip_get_data(chip);\n\tunsigned int base, val, reg, mask;\n\tint invert, ret;\n\n\tif (gpio->reg_dir_out_base) {\n\t\tbase = gpio_regmap_addr(gpio->reg_dir_out_base);\n\t\tinvert = 0;\n\t} else if (gpio->reg_dir_in_base) {\n\t\tbase = gpio_regmap_addr(gpio->reg_dir_in_base);\n\t\tinvert = 1;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = gpio->reg_mask_xlate(gpio, base, offset, &reg, &mask);\n\tif (ret)\n\t\treturn ret;\n\n\tif (invert)\n\t\tval = output ? 0 : mask;\n\telse\n\t\tval = output ? mask : 0;\n\n\treturn regmap_update_bits(gpio->regmap, reg, mask, val);\n}\n\nstatic int gpio_regmap_direction_input(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset)\n{\n\treturn gpio_regmap_set_direction(chip, offset, false);\n}\n\nstatic int gpio_regmap_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int offset, int value)\n{\n\tgpio_regmap_set(chip, offset, value);\n\n\treturn gpio_regmap_set_direction(chip, offset, true);\n}\n\nvoid *gpio_regmap_get_drvdata(struct gpio_regmap *gpio)\n{\n\treturn gpio->driver_data;\n}\nEXPORT_SYMBOL_GPL(gpio_regmap_get_drvdata);\n\n \nstruct gpio_regmap *gpio_regmap_register(const struct gpio_regmap_config *config)\n{\n\tstruct gpio_regmap *gpio;\n\tstruct gpio_chip *chip;\n\tint ret;\n\n\tif (!config->parent)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!config->ngpio)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (!config->reg_dat_base && !config->reg_set_base)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif ((config->reg_dir_out_base || config->reg_dir_in_base) &&\n\t    (!config->reg_dat_base || !config->reg_set_base))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (config->reg_dir_out_base && config->reg_dir_in_base)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tgpio = kzalloc(sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgpio->parent = config->parent;\n\tgpio->driver_data = config->drvdata;\n\tgpio->regmap = config->regmap;\n\tgpio->ngpio_per_reg = config->ngpio_per_reg;\n\tgpio->reg_stride = config->reg_stride;\n\tgpio->reg_mask_xlate = config->reg_mask_xlate;\n\tgpio->reg_dat_base = config->reg_dat_base;\n\tgpio->reg_set_base = config->reg_set_base;\n\tgpio->reg_clr_base = config->reg_clr_base;\n\tgpio->reg_dir_in_base = config->reg_dir_in_base;\n\tgpio->reg_dir_out_base = config->reg_dir_out_base;\n\n\t \n\tif (!gpio->ngpio_per_reg)\n\t\tgpio->ngpio_per_reg = config->ngpio;\n\n\t \n\tif (!gpio->reg_stride)\n\t\tgpio->reg_stride = 1;\n\n\tif (!gpio->reg_mask_xlate)\n\t\tgpio->reg_mask_xlate = gpio_regmap_simple_xlate;\n\n\tchip = &gpio->gpio_chip;\n\tchip->parent = config->parent;\n\tchip->fwnode = config->fwnode;\n\tchip->base = -1;\n\tchip->ngpio = config->ngpio;\n\tchip->names = config->names;\n\tchip->label = config->label ?: dev_name(config->parent);\n\tchip->can_sleep = regmap_might_sleep(config->regmap);\n\n\tchip->get = gpio_regmap_get;\n\tif (gpio->reg_set_base && gpio->reg_clr_base)\n\t\tchip->set = gpio_regmap_set_with_clear;\n\telse if (gpio->reg_set_base)\n\t\tchip->set = gpio_regmap_set;\n\n\tchip->get_direction = gpio_regmap_get_direction;\n\tif (gpio->reg_dir_in_base || gpio->reg_dir_out_base) {\n\t\tchip->direction_input = gpio_regmap_direction_input;\n\t\tchip->direction_output = gpio_regmap_direction_output;\n\t}\n\n\tret = gpiochip_add_data(chip, gpio);\n\tif (ret < 0)\n\t\tgoto err_free_gpio;\n\n\tif (config->irq_domain) {\n\t\tret = gpiochip_irqchip_add_domain(chip, config->irq_domain);\n\t\tif (ret)\n\t\t\tgoto err_remove_gpiochip;\n\t}\n\n\treturn gpio;\n\nerr_remove_gpiochip:\n\tgpiochip_remove(chip);\nerr_free_gpio:\n\tkfree(gpio);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(gpio_regmap_register);\n\n \nvoid gpio_regmap_unregister(struct gpio_regmap *gpio)\n{\n\tgpiochip_remove(&gpio->gpio_chip);\n\tkfree(gpio);\n}\nEXPORT_SYMBOL_GPL(gpio_regmap_unregister);\n\nstatic void devm_gpio_regmap_unregister(void *res)\n{\n\tgpio_regmap_unregister(res);\n}\n\n \nstruct gpio_regmap *devm_gpio_regmap_register(struct device *dev,\n\t\t\t\t\t      const struct gpio_regmap_config *config)\n{\n\tstruct gpio_regmap *gpio;\n\tint ret;\n\n\tgpio = gpio_regmap_register(config);\n\n\tif (IS_ERR(gpio))\n\t\treturn gpio;\n\n\tret = devm_add_action_or_reset(dev, devm_gpio_regmap_unregister, gpio);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn gpio;\n}\nEXPORT_SYMBOL_GPL(devm_gpio_regmap_register);\n\nMODULE_AUTHOR(\"Michael Walle <michael@walle.cc>\");\nMODULE_DESCRIPTION(\"GPIO generic regmap driver core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}