{
  "module_name": "gpio-thunderx.c",
  "hash_id": "67a0a024a5fc914d6bcc047df6203879c4004c5fefebe9b64198982fc1819788",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-thunderx.c",
  "human_readable_source": " \n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n\n#define GPIO_RX_DAT\t0x0\n#define GPIO_TX_SET\t0x8\n#define GPIO_TX_CLR\t0x10\n#define GPIO_CONST\t0x90\n#define  GPIO_CONST_GPIOS_MASK 0xff\n#define GPIO_BIT_CFG\t0x400\n#define  GPIO_BIT_CFG_TX_OE\t\tBIT(0)\n#define  GPIO_BIT_CFG_PIN_XOR\t\tBIT(1)\n#define  GPIO_BIT_CFG_INT_EN\t\tBIT(2)\n#define  GPIO_BIT_CFG_INT_TYPE\t\tBIT(3)\n#define  GPIO_BIT_CFG_FIL_MASK\t\tGENMASK(11, 4)\n#define  GPIO_BIT_CFG_FIL_CNT_SHIFT\t4\n#define  GPIO_BIT_CFG_FIL_SEL_SHIFT\t8\n#define  GPIO_BIT_CFG_TX_OD\t\tBIT(12)\n#define  GPIO_BIT_CFG_PIN_SEL_MASK\tGENMASK(25, 16)\n#define GPIO_INTR\t0x800\n#define  GPIO_INTR_INTR\t\t\tBIT(0)\n#define  GPIO_INTR_INTR_W1S\t\tBIT(1)\n#define  GPIO_INTR_ENA_W1C\t\tBIT(2)\n#define  GPIO_INTR_ENA_W1S\t\tBIT(3)\n#define GPIO_2ND_BANK\t0x1400\n\n#define GLITCH_FILTER_400NS ((4u << GPIO_BIT_CFG_FIL_SEL_SHIFT) | \\\n\t\t\t     (9u << GPIO_BIT_CFG_FIL_CNT_SHIFT))\n\nstruct thunderx_gpio;\n\nstruct thunderx_line {\n\tstruct thunderx_gpio\t*txgpio;\n\tunsigned int\t\tline;\n\tunsigned int\t\tfil_bits;\n};\n\nstruct thunderx_gpio {\n\tstruct gpio_chip\tchip;\n\tu8 __iomem\t\t*register_base;\n\tstruct msix_entry\t*msix_entries;\t \n\tstruct thunderx_line\t*line_entries;\t \n\traw_spinlock_t\t\tlock;\n\tunsigned long\t\tinvert_mask[2];\n\tunsigned long\t\tod_mask[2];\n\tint\t\t\tbase_msi;\n};\n\nstatic unsigned int bit_cfg_reg(unsigned int line)\n{\n\treturn 8 * line + GPIO_BIT_CFG;\n}\n\nstatic unsigned int intr_reg(unsigned int line)\n{\n\treturn 8 * line + GPIO_INTR;\n}\n\nstatic bool thunderx_gpio_is_gpio_nowarn(struct thunderx_gpio *txgpio,\n\t\t\t\t\t unsigned int line)\n{\n\tu64 bit_cfg = readq(txgpio->register_base + bit_cfg_reg(line));\n\n\treturn (bit_cfg & GPIO_BIT_CFG_PIN_SEL_MASK) == 0;\n}\n\n \nstatic bool thunderx_gpio_is_gpio(struct thunderx_gpio *txgpio,\n\t\t\t\t  unsigned int line)\n{\n\tbool rv = thunderx_gpio_is_gpio_nowarn(txgpio, line);\n\n\tWARN_RATELIMIT(!rv, \"Pin %d not available for GPIO\\n\", line);\n\n\treturn rv;\n}\n\nstatic int thunderx_gpio_request(struct gpio_chip *chip, unsigned int line)\n{\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(chip);\n\n\treturn thunderx_gpio_is_gpio(txgpio, line) ? 0 : -EIO;\n}\n\nstatic int thunderx_gpio_dir_in(struct gpio_chip *chip, unsigned int line)\n{\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(chip);\n\n\tif (!thunderx_gpio_is_gpio(txgpio, line))\n\t\treturn -EIO;\n\n\traw_spin_lock(&txgpio->lock);\n\tclear_bit(line, txgpio->invert_mask);\n\tclear_bit(line, txgpio->od_mask);\n\twriteq(txgpio->line_entries[line].fil_bits,\n\t       txgpio->register_base + bit_cfg_reg(line));\n\traw_spin_unlock(&txgpio->lock);\n\treturn 0;\n}\n\nstatic void thunderx_gpio_set(struct gpio_chip *chip, unsigned int line,\n\t\t\t      int value)\n{\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(chip);\n\tint bank = line / 64;\n\tint bank_bit = line % 64;\n\n\tvoid __iomem *reg = txgpio->register_base +\n\t\t(bank * GPIO_2ND_BANK) + (value ? GPIO_TX_SET : GPIO_TX_CLR);\n\n\twriteq(BIT_ULL(bank_bit), reg);\n}\n\nstatic int thunderx_gpio_dir_out(struct gpio_chip *chip, unsigned int line,\n\t\t\t\t int value)\n{\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(chip);\n\tu64 bit_cfg = txgpio->line_entries[line].fil_bits | GPIO_BIT_CFG_TX_OE;\n\n\tif (!thunderx_gpio_is_gpio(txgpio, line))\n\t\treturn -EIO;\n\n\traw_spin_lock(&txgpio->lock);\n\n\tthunderx_gpio_set(chip, line, value);\n\n\tif (test_bit(line, txgpio->invert_mask))\n\t\tbit_cfg |= GPIO_BIT_CFG_PIN_XOR;\n\n\tif (test_bit(line, txgpio->od_mask))\n\t\tbit_cfg |= GPIO_BIT_CFG_TX_OD;\n\n\twriteq(bit_cfg, txgpio->register_base + bit_cfg_reg(line));\n\n\traw_spin_unlock(&txgpio->lock);\n\treturn 0;\n}\n\nstatic int thunderx_gpio_get_direction(struct gpio_chip *chip, unsigned int line)\n{\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(chip);\n\tu64 bit_cfg;\n\n\tif (!thunderx_gpio_is_gpio_nowarn(txgpio, line))\n\t\t \n\t\treturn 1;\n\n\tbit_cfg = readq(txgpio->register_base + bit_cfg_reg(line));\n\n\tif (bit_cfg & GPIO_BIT_CFG_TX_OE)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int thunderx_gpio_set_config(struct gpio_chip *chip,\n\t\t\t\t    unsigned int line,\n\t\t\t\t    unsigned long cfg)\n{\n\tbool orig_invert, orig_od, orig_dat, new_invert, new_od;\n\tu32 arg, sel;\n\tu64 bit_cfg;\n\tint bank = line / 64;\n\tint bank_bit = line % 64;\n\tint ret = -ENOTSUPP;\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(chip);\n\tvoid __iomem *reg = txgpio->register_base + (bank * GPIO_2ND_BANK) + GPIO_TX_SET;\n\n\tif (!thunderx_gpio_is_gpio(txgpio, line))\n\t\treturn -EIO;\n\n\traw_spin_lock(&txgpio->lock);\n\torig_invert = test_bit(line, txgpio->invert_mask);\n\tnew_invert  = orig_invert;\n\torig_od = test_bit(line, txgpio->od_mask);\n\tnew_od = orig_od;\n\torig_dat = ((readq(reg) >> bank_bit) & 1) ^ orig_invert;\n\tbit_cfg = readq(txgpio->register_base + bit_cfg_reg(line));\n\tswitch (pinconf_to_config_param(cfg)) {\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t \n\t\tset_bit(line, txgpio->invert_mask);\n\t\tnew_invert  = true;\n\t\tset_bit(line, txgpio->od_mask);\n\t\tnew_od = true;\n\t\tret = 0;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tclear_bit(line, txgpio->invert_mask);\n\t\tnew_invert  = false;\n\t\tclear_bit(line, txgpio->od_mask);\n\t\tnew_od  = false;\n\t\tret = 0;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\targ = pinconf_to_config_argument(cfg);\n\t\tif (arg > 1228) {  \n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\targ *= 400;  \n\t\tsel = 0;\n\t\twhile (arg > 15) {\n\t\t\tsel++;\n\t\t\targ++;  \n\t\t\targ >>= 1;\n\t\t}\n\t\ttxgpio->line_entries[line].fil_bits =\n\t\t\t(sel << GPIO_BIT_CFG_FIL_SEL_SHIFT) |\n\t\t\t(arg << GPIO_BIT_CFG_FIL_CNT_SHIFT);\n\t\tbit_cfg &= ~GPIO_BIT_CFG_FIL_MASK;\n\t\tbit_cfg |= txgpio->line_entries[line].fil_bits;\n\t\twriteq(bit_cfg, txgpio->register_base + bit_cfg_reg(line));\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\traw_spin_unlock(&txgpio->lock);\n\n\t \n\tif ((new_invert != orig_invert || new_od != orig_od) &&\n\t    (bit_cfg & GPIO_BIT_CFG_TX_OE))\n\t\tret = thunderx_gpio_dir_out(chip, line, orig_dat ^ new_invert);\n\n\treturn ret;\n}\n\nstatic int thunderx_gpio_get(struct gpio_chip *chip, unsigned int line)\n{\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(chip);\n\tint bank = line / 64;\n\tint bank_bit = line % 64;\n\tu64 read_bits = readq(txgpio->register_base + (bank * GPIO_2ND_BANK) + GPIO_RX_DAT);\n\tu64 masked_bits = read_bits & BIT_ULL(bank_bit);\n\n\tif (test_bit(line, txgpio->invert_mask))\n\t\treturn masked_bits == 0;\n\telse\n\t\treturn masked_bits != 0;\n}\n\nstatic void thunderx_gpio_set_multiple(struct gpio_chip *chip,\n\t\t\t\t       unsigned long *mask,\n\t\t\t\t       unsigned long *bits)\n{\n\tint bank;\n\tu64 set_bits, clear_bits;\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(chip);\n\n\tfor (bank = 0; bank <= chip->ngpio / 64; bank++) {\n\t\tset_bits = bits[bank] & mask[bank];\n\t\tclear_bits = ~bits[bank] & mask[bank];\n\t\twriteq(set_bits, txgpio->register_base + (bank * GPIO_2ND_BANK) + GPIO_TX_SET);\n\t\twriteq(clear_bits, txgpio->register_base + (bank * GPIO_2ND_BANK) + GPIO_TX_CLR);\n\t}\n}\n\nstatic void thunderx_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(gc);\n\n\twriteq(GPIO_INTR_INTR,\n\t       txgpio->register_base + intr_reg(irqd_to_hwirq(d)));\n}\n\nstatic void thunderx_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(gc);\n\n\twriteq(GPIO_INTR_ENA_W1C,\n\t       txgpio->register_base + intr_reg(irqd_to_hwirq(d)));\n}\n\nstatic void thunderx_gpio_irq_mask_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(gc);\n\n\twriteq(GPIO_INTR_ENA_W1C | GPIO_INTR_INTR,\n\t       txgpio->register_base + intr_reg(irqd_to_hwirq(d)));\n}\n\nstatic void thunderx_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(gc);\n\n\twriteq(GPIO_INTR_ENA_W1S,\n\t       txgpio->register_base + intr_reg(irqd_to_hwirq(d)));\n}\n\nstatic int thunderx_gpio_irq_set_type(struct irq_data *d,\n\t\t\t\t      unsigned int flow_type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(gc);\n\tstruct thunderx_line *txline =\n\t\t&txgpio->line_entries[irqd_to_hwirq(d)];\n\tu64 bit_cfg;\n\n\tirqd_set_trigger_type(d, flow_type);\n\n\tbit_cfg = txline->fil_bits | GPIO_BIT_CFG_INT_EN;\n\n\tif (flow_type & IRQ_TYPE_EDGE_BOTH) {\n\t\tirq_set_handler_locked(d, handle_fasteoi_ack_irq);\n\t\tbit_cfg |= GPIO_BIT_CFG_INT_TYPE;\n\t} else {\n\t\tirq_set_handler_locked(d, handle_fasteoi_mask_irq);\n\t}\n\n\traw_spin_lock(&txgpio->lock);\n\tif (flow_type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_LEVEL_LOW)) {\n\t\tbit_cfg |= GPIO_BIT_CFG_PIN_XOR;\n\t\tset_bit(txline->line, txgpio->invert_mask);\n\t} else {\n\t\tclear_bit(txline->line, txgpio->invert_mask);\n\t}\n\tclear_bit(txline->line, txgpio->od_mask);\n\twriteq(bit_cfg, txgpio->register_base + bit_cfg_reg(txline->line));\n\traw_spin_unlock(&txgpio->lock);\n\n\treturn IRQ_SET_MASK_OK;\n}\n\nstatic void thunderx_gpio_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\tirq_chip_enable_parent(d);\n\tthunderx_gpio_irq_unmask(d);\n}\n\nstatic void thunderx_gpio_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\tthunderx_gpio_irq_mask(d);\n\tirq_chip_disable_parent(d);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\n \nstatic const struct irq_chip thunderx_gpio_irq_chip = {\n\t.name\t\t\t= \"GPIO\",\n\t.irq_enable\t\t= thunderx_gpio_irq_enable,\n\t.irq_disable\t\t= thunderx_gpio_irq_disable,\n\t.irq_ack\t\t= thunderx_gpio_irq_ack,\n\t.irq_mask\t\t= thunderx_gpio_irq_mask,\n\t.irq_mask_ack\t\t= thunderx_gpio_irq_mask_ack,\n\t.irq_unmask\t\t= thunderx_gpio_irq_unmask,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.irq_set_type\t\t= thunderx_gpio_irq_set_type,\n\t.flags\t\t\t= IRQCHIP_SET_TYPE_MASKED | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int thunderx_gpio_child_to_parent_hwirq(struct gpio_chip *gc,\n\t\t\t\t\t       unsigned int child,\n\t\t\t\t\t       unsigned int child_type,\n\t\t\t\t\t       unsigned int *parent,\n\t\t\t\t\t       unsigned int *parent_type)\n{\n\tstruct thunderx_gpio *txgpio = gpiochip_get_data(gc);\n\tstruct irq_data *irqd;\n\tunsigned int irq;\n\n\tirq = txgpio->msix_entries[child].vector;\n\tirqd = irq_domain_get_irq_data(gc->irq.parent_domain, irq);\n\tif (!irqd)\n\t\treturn -EINVAL;\n\t*parent = irqd_to_hwirq(irqd);\n\t*parent_type = IRQ_TYPE_LEVEL_HIGH;\n\treturn 0;\n}\n\nstatic int thunderx_gpio_populate_parent_alloc_info(struct gpio_chip *chip,\n\t\t\t\t\t\t    union gpio_irq_fwspec *gfwspec,\n\t\t\t\t\t\t    unsigned int parent_hwirq,\n\t\t\t\t\t\t    unsigned int parent_type)\n{\n\tmsi_alloc_info_t *info = &gfwspec->msiinfo;\n\n\tinfo->hwirq = parent_hwirq;\n\treturn 0;\n}\n\nstatic int thunderx_gpio_probe(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *id)\n{\n\tvoid __iomem * const *tbl;\n\tstruct device *dev = &pdev->dev;\n\tstruct thunderx_gpio *txgpio;\n\tstruct gpio_chip *chip;\n\tstruct gpio_irq_chip *girq;\n\tint ngpio, i;\n\tint err = 0;\n\n\ttxgpio = devm_kzalloc(dev, sizeof(*txgpio), GFP_KERNEL);\n\tif (!txgpio)\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_init(&txgpio->lock);\n\tchip = &txgpio->chip;\n\n\tpci_set_drvdata(pdev, txgpio);\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to enable PCI device: err %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\terr = pcim_iomap_regions(pdev, 1 << 0, KBUILD_MODNAME);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to iomap PCI device: err %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\ttbl = pcim_iomap_table(pdev);\n\ttxgpio->register_base = tbl[0];\n\tif (!txgpio->register_base) {\n\t\tdev_err(dev, \"Cannot map PCI resource\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (pdev->subsystem_device == 0xa10a) {\n\t\t \n\t\tngpio = 50;\n\t\ttxgpio->base_msi = 48;\n\t} else {\n\t\tu64 c = readq(txgpio->register_base + GPIO_CONST);\n\n\t\tngpio = c & GPIO_CONST_GPIOS_MASK;\n\t\ttxgpio->base_msi = (c >> 8) & 0xff;\n\t}\n\n\ttxgpio->msix_entries = devm_kcalloc(dev,\n\t\t\t\t\t    ngpio, sizeof(struct msix_entry),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!txgpio->msix_entries) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttxgpio->line_entries = devm_kcalloc(dev,\n\t\t\t\t\t    ngpio,\n\t\t\t\t\t    sizeof(struct thunderx_line),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!txgpio->line_entries) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ngpio; i++) {\n\t\tu64 bit_cfg = readq(txgpio->register_base + bit_cfg_reg(i));\n\n\t\ttxgpio->msix_entries[i].entry = txgpio->base_msi + (2 * i);\n\t\ttxgpio->line_entries[i].line = i;\n\t\ttxgpio->line_entries[i].txgpio = txgpio;\n\t\t \n\t\ttxgpio->line_entries[i].fil_bits = bit_cfg ?\n\t\t\t(bit_cfg & GPIO_BIT_CFG_FIL_MASK) : GLITCH_FILTER_400NS;\n\n\t\tif ((bit_cfg & GPIO_BIT_CFG_TX_OE) && (bit_cfg & GPIO_BIT_CFG_TX_OD))\n\t\t\tset_bit(i, txgpio->od_mask);\n\t\tif (bit_cfg & GPIO_BIT_CFG_PIN_XOR)\n\t\t\tset_bit(i, txgpio->invert_mask);\n\t}\n\n\n\t \n\terr = pci_enable_msix_range(pdev, txgpio->msix_entries, ngpio, ngpio);\n\tif (err < 0)\n\t\tgoto out;\n\n\tchip->label = KBUILD_MODNAME;\n\tchip->parent = dev;\n\tchip->owner = THIS_MODULE;\n\tchip->request = thunderx_gpio_request;\n\tchip->base = -1;  \n\tchip->can_sleep = false;\n\tchip->ngpio = ngpio;\n\tchip->get_direction = thunderx_gpio_get_direction;\n\tchip->direction_input = thunderx_gpio_dir_in;\n\tchip->get = thunderx_gpio_get;\n\tchip->direction_output = thunderx_gpio_dir_out;\n\tchip->set = thunderx_gpio_set;\n\tchip->set_multiple = thunderx_gpio_set_multiple;\n\tchip->set_config = thunderx_gpio_set_config;\n\tgirq = &chip->irq;\n\tgpio_irq_chip_set_chip(girq, &thunderx_gpio_irq_chip);\n\tgirq->fwnode = of_node_to_fwnode(dev->of_node);\n\tgirq->parent_domain =\n\t\tirq_get_irq_data(txgpio->msix_entries[0].vector)->domain;\n\tgirq->child_to_parent_hwirq = thunderx_gpio_child_to_parent_hwirq;\n\tgirq->populate_parent_alloc_arg = thunderx_gpio_populate_parent_alloc_info;\n\tgirq->handler = handle_bad_irq;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\n\terr = devm_gpiochip_add_data(dev, chip, txgpio);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < ngpio; i++) {\n\t\tstruct irq_fwspec fwspec;\n\n\t\tfwspec.fwnode = of_node_to_fwnode(dev->of_node);\n\t\tfwspec.param_count = 2;\n\t\tfwspec.param[0] = i;\n\t\tfwspec.param[1] = IRQ_TYPE_NONE;\n\t\terr = irq_domain_push_irq(girq->domain,\n\t\t\t\t\t  txgpio->msix_entries[i].vector,\n\t\t\t\t\t  &fwspec);\n\t\tif (err < 0)\n\t\t\tdev_err(dev, \"irq_domain_push_irq: %d\\n\", err);\n\t}\n\n\tdev_info(dev, \"ThunderX GPIO: %d lines with base %d.\\n\",\n\t\t ngpio, chip->base);\n\treturn 0;\nout:\n\tpci_set_drvdata(pdev, NULL);\n\treturn err;\n}\n\nstatic void thunderx_gpio_remove(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct thunderx_gpio *txgpio = pci_get_drvdata(pdev);\n\n\tfor (i = 0; i < txgpio->chip.ngpio; i++)\n\t\tirq_domain_pop_irq(txgpio->chip.irq.domain,\n\t\t\t\t   txgpio->msix_entries[i].vector);\n\n\tirq_domain_remove(txgpio->chip.irq.domain);\n\n\tpci_set_drvdata(pdev, NULL);\n}\n\nstatic const struct pci_device_id thunderx_gpio_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, 0xA00A) },\n\t{ 0, }\t \n};\n\nMODULE_DEVICE_TABLE(pci, thunderx_gpio_id_table);\n\nstatic struct pci_driver thunderx_gpio_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = thunderx_gpio_id_table,\n\t.probe = thunderx_gpio_probe,\n\t.remove = thunderx_gpio_remove,\n};\n\nmodule_pci_driver(thunderx_gpio_driver);\n\nMODULE_DESCRIPTION(\"Cavium Inc. ThunderX/OCTEON-TX GPIO Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}