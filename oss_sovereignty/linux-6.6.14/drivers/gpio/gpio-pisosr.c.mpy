{
  "module_name": "gpio-pisosr.c",
  "hash_id": "4c4d5aefd0ce24ac9e8596ff8b78bbcf149d4634e9727a97dc0d067f13def0e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-pisosr.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/spi/spi.h>\n\n#define DEFAULT_NGPIO 8\n\n \nstruct pisosr_gpio {\n\tstruct gpio_chip chip;\n\tstruct spi_device *spi;\n\tu8 *buffer;\n\tsize_t buffer_size;\n\tstruct gpio_desc *load_gpio;\n\tstruct mutex lock;\n};\n\nstatic int pisosr_gpio_refresh(struct pisosr_gpio *gpio)\n{\n\tint ret;\n\n\tmutex_lock(&gpio->lock);\n\n\tif (gpio->load_gpio) {\n\t\tgpiod_set_value_cansleep(gpio->load_gpio, 1);\n\t\tudelay(1);  \n\t\tgpiod_set_value_cansleep(gpio->load_gpio, 0);\n\t\tudelay(1);  \n\t}\n\n\tret = spi_read(gpio->spi, gpio->buffer, gpio->buffer_size);\n\n\tmutex_unlock(&gpio->lock);\n\n\treturn ret;\n}\n\nstatic int pisosr_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t     unsigned offset)\n{\n\t \n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int pisosr_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t       unsigned offset)\n{\n\t \n\treturn 0;\n}\n\nstatic int pisosr_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic int pisosr_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct pisosr_gpio *gpio = gpiochip_get_data(chip);\n\n\t \n\tpisosr_gpio_refresh(gpio);\n\n\treturn (gpio->buffer[offset / 8] >> (offset % 8)) & 0x1;\n}\n\nstatic int pisosr_gpio_get_multiple(struct gpio_chip *chip,\n\t\t\t\t    unsigned long *mask, unsigned long *bits)\n{\n\tstruct pisosr_gpio *gpio = gpiochip_get_data(chip);\n\tunsigned long offset;\n\tunsigned long gpio_mask;\n\tunsigned long buffer_state;\n\n\tpisosr_gpio_refresh(gpio);\n\n\tbitmap_zero(bits, chip->ngpio);\n\tfor_each_set_clump8(offset, gpio_mask, mask, chip->ngpio) {\n\t\tbuffer_state = gpio->buffer[offset / 8] & gpio_mask;\n\t\tbitmap_set_value8(bits, buffer_state, offset);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct gpio_chip template_chip = {\n\t.label\t\t\t= \"pisosr-gpio\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.get_direction\t\t= pisosr_gpio_get_direction,\n\t.direction_input\t= pisosr_gpio_direction_input,\n\t.direction_output\t= pisosr_gpio_direction_output,\n\t.get\t\t\t= pisosr_gpio_get,\n\t.get_multiple\t\t= pisosr_gpio_get_multiple,\n\t.base\t\t\t= -1,\n\t.ngpio\t\t\t= DEFAULT_NGPIO,\n\t.can_sleep\t\t= true,\n};\n\nstatic void pisosr_mutex_destroy(void *lock)\n{\n\tmutex_destroy(lock);\n}\n\nstatic int pisosr_gpio_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct pisosr_gpio *gpio;\n\tint ret;\n\n\tgpio = devm_kzalloc(dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tgpio->chip = template_chip;\n\tgpio->chip.parent = dev;\n\tof_property_read_u16(dev->of_node, \"ngpios\", &gpio->chip.ngpio);\n\n\tgpio->spi = spi;\n\n\tgpio->buffer_size = DIV_ROUND_UP(gpio->chip.ngpio, 8);\n\tgpio->buffer = devm_kzalloc(dev, gpio->buffer_size, GFP_KERNEL);\n\tif (!gpio->buffer)\n\t\treturn -ENOMEM;\n\n\tgpio->load_gpio = devm_gpiod_get_optional(dev, \"load\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpio->load_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(gpio->load_gpio),\n\t\t\t\t     \"Unable to allocate load GPIO\\n\");\n\n\tmutex_init(&gpio->lock);\n\tret = devm_add_action_or_reset(dev, pisosr_mutex_destroy, &gpio->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_gpiochip_add_data(dev, &gpio->chip, gpio);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unable to register gpiochip\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct spi_device_id pisosr_gpio_id_table[] = {\n\t{ \"pisosr-gpio\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, pisosr_gpio_id_table);\n\nstatic const struct of_device_id pisosr_gpio_of_match_table[] = {\n\t{ .compatible = \"pisosr-gpio\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pisosr_gpio_of_match_table);\n\nstatic struct spi_driver pisosr_gpio_driver = {\n\t.driver = {\n\t\t.name = \"pisosr-gpio\",\n\t\t.of_match_table = pisosr_gpio_of_match_table,\n\t},\n\t.probe = pisosr_gpio_probe,\n\t.id_table = pisosr_gpio_id_table,\n};\nmodule_spi_driver(pisosr_gpio_driver);\n\nMODULE_AUTHOR(\"Andrew Davis <afd@ti.com>\");\nMODULE_DESCRIPTION(\"SPI Compatible PISO Shift Register GPIO Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}