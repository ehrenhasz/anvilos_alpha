{
  "module_name": "gpio-amd-fch.c",
  "hash_id": "c20a366cbc4c4d93aa514d7789d8af172149d1cd3738649d846309105fa350ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-amd-fch.c",
  "human_readable_source": "\n\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/driver.h>\n#include <linux/platform_data/gpio/gpio-amd-fch.h>\n#include <linux/spinlock.h>\n\n#define AMD_FCH_MMIO_BASE\t\t0xFED80000\n#define AMD_FCH_GPIO_BANK0_BASE\t\t0x1500\n#define AMD_FCH_GPIO_SIZE\t\t0x0300\n\n#define AMD_FCH_GPIO_FLAG_DIRECTION\tBIT(23)\n#define AMD_FCH_GPIO_FLAG_WRITE\t\tBIT(22)\n#define AMD_FCH_GPIO_FLAG_READ\t\tBIT(16)\n\nstatic const struct resource amd_fch_gpio_iores =\n\tDEFINE_RES_MEM_NAMED(\n\t\tAMD_FCH_MMIO_BASE + AMD_FCH_GPIO_BANK0_BASE,\n\t\tAMD_FCH_GPIO_SIZE,\n\t\t\"amd-fch-gpio-iomem\");\n\nstruct amd_fch_gpio_priv {\n\tstruct gpio_chip\t\tgc;\n\tvoid __iomem\t\t\t*base;\n\tstruct amd_fch_gpio_pdata\t*pdata;\n\tspinlock_t\t\t\tlock;\n};\n\nstatic void __iomem *amd_fch_gpio_addr(struct amd_fch_gpio_priv *priv,\n\t\t\t\t       unsigned int gpio)\n{\n\treturn priv->base + priv->pdata->gpio_reg[gpio]*sizeof(u32);\n}\n\nstatic int amd_fch_gpio_direction_input(struct gpio_chip *gc,\n\t\t\t\t\tunsigned int offset)\n{\n\tunsigned long flags;\n\tstruct amd_fch_gpio_priv *priv = gpiochip_get_data(gc);\n\tvoid __iomem *ptr = amd_fch_gpio_addr(priv, offset);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\twritel_relaxed(readl_relaxed(ptr) & ~AMD_FCH_GPIO_FLAG_DIRECTION, ptr);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int amd_fch_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\t unsigned int gpio, int value)\n{\n\tunsigned long flags;\n\tstruct amd_fch_gpio_priv *priv = gpiochip_get_data(gc);\n\tvoid __iomem *ptr = amd_fch_gpio_addr(priv, gpio);\n\tu32 val;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tval = readl_relaxed(ptr);\n\tif (value)\n\t\tval |= AMD_FCH_GPIO_FLAG_WRITE;\n\telse\n\t\tval &= ~AMD_FCH_GPIO_FLAG_WRITE;\n\n\twritel_relaxed(val | AMD_FCH_GPIO_FLAG_DIRECTION, ptr);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int amd_fch_gpio_get_direction(struct gpio_chip *gc, unsigned int gpio)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct amd_fch_gpio_priv *priv = gpiochip_get_data(gc);\n\tvoid __iomem *ptr = amd_fch_gpio_addr(priv, gpio);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tret = (readl_relaxed(ptr) & AMD_FCH_GPIO_FLAG_DIRECTION);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn ret ? GPIO_LINE_DIRECTION_OUT : GPIO_LINE_DIRECTION_IN;\n}\n\nstatic void amd_fch_gpio_set(struct gpio_chip *gc,\n\t\t\t     unsigned int gpio, int value)\n{\n\tunsigned long flags;\n\tstruct amd_fch_gpio_priv *priv = gpiochip_get_data(gc);\n\tvoid __iomem *ptr = amd_fch_gpio_addr(priv, gpio);\n\tu32 mask;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tmask = readl_relaxed(ptr);\n\tif (value)\n\t\tmask |= AMD_FCH_GPIO_FLAG_WRITE;\n\telse\n\t\tmask &= ~AMD_FCH_GPIO_FLAG_WRITE;\n\twritel_relaxed(mask, ptr);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int amd_fch_gpio_get(struct gpio_chip *gc,\n\t\t\t    unsigned int offset)\n{\n\tunsigned long flags;\n\tint ret;\n\tstruct amd_fch_gpio_priv *priv = gpiochip_get_data(gc);\n\tvoid __iomem *ptr = amd_fch_gpio_addr(priv, offset);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tret = (readl_relaxed(ptr) & AMD_FCH_GPIO_FLAG_READ);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn ret;\n}\n\nstatic int amd_fch_gpio_request(struct gpio_chip *chip,\n\t\t\t\tunsigned int gpio_pin)\n{\n\treturn 0;\n}\n\nstatic int amd_fch_gpio_probe(struct platform_device *pdev)\n{\n\tstruct amd_fch_gpio_priv *priv;\n\tstruct amd_fch_gpio_pdata *pdata;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"no platform_data\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->pdata\t= pdata;\n\n\tpriv->gc.owner\t\t\t= THIS_MODULE;\n\tpriv->gc.parent\t\t\t= &pdev->dev;\n\tpriv->gc.label\t\t\t= dev_name(&pdev->dev);\n\tpriv->gc.ngpio\t\t\t= priv->pdata->gpio_num;\n\tpriv->gc.names\t\t\t= priv->pdata->gpio_names;\n\tpriv->gc.base\t\t\t= -1;\n\tpriv->gc.request\t\t= amd_fch_gpio_request;\n\tpriv->gc.direction_input\t= amd_fch_gpio_direction_input;\n\tpriv->gc.direction_output\t= amd_fch_gpio_direction_output;\n\tpriv->gc.get_direction\t\t= amd_fch_gpio_get_direction;\n\tpriv->gc.get\t\t\t= amd_fch_gpio_get;\n\tpriv->gc.set\t\t\t= amd_fch_gpio_set;\n\n\tspin_lock_init(&priv->lock);\n\n\tpriv->base = devm_ioremap_resource(&pdev->dev, &amd_fch_gpio_iores);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &priv->gc, priv);\n}\n\nstatic struct platform_driver amd_fch_gpio_driver = {\n\t.driver = {\n\t\t.name = AMD_FCH_GPIO_DRIVER_NAME,\n\t},\n\t.probe = amd_fch_gpio_probe,\n};\n\nmodule_platform_driver(amd_fch_gpio_driver);\n\nMODULE_AUTHOR(\"Enrico Weigelt, metux IT consult <info@metux.net>\");\nMODULE_DESCRIPTION(\"AMD G-series FCH GPIO driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" AMD_FCH_GPIO_DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}