{
  "module_name": "gpio-mockup.c",
  "hash_id": "1af0e82ead482f79d13574fdc451bf8b0aeb85dadea03a07d681dcbcd8f16354",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mockup.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/debugfs.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/irqdomain.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n#include <linux/uaccess.h>\n\n#include \"gpiolib.h\"\n\n#define GPIO_MOCKUP_MAX_GC\t10\n \n#define GPIO_MOCKUP_MAX_RANGES\t(GPIO_MOCKUP_MAX_GC * 2)\n \n#define GPIO_MOCKUP_MAX_PROP\t5\n\n \nstruct gpio_mockup_line_status {\n\tint dir;\n\tint value;\n\tint pull;\n};\n\nstruct gpio_mockup_chip {\n\tstruct gpio_chip gc;\n\tstruct gpio_mockup_line_status *lines;\n\tstruct irq_domain *irq_sim_domain;\n\tstruct dentry *dbg_dir;\n\tstruct mutex lock;\n};\n\nstruct gpio_mockup_dbgfs_private {\n\tstruct gpio_mockup_chip *chip;\n\tstruct gpio_desc *desc;\n\tunsigned int offset;\n};\n\nstatic int gpio_mockup_ranges[GPIO_MOCKUP_MAX_RANGES];\nstatic int gpio_mockup_num_ranges;\nmodule_param_array(gpio_mockup_ranges, int, &gpio_mockup_num_ranges, 0400);\n\nstatic bool gpio_mockup_named_lines;\nmodule_param_named(gpio_mockup_named_lines,\n\t\t   gpio_mockup_named_lines, bool, 0400);\n\nstatic struct dentry *gpio_mockup_dbg_dir;\n\nstatic int gpio_mockup_range_base(unsigned int index)\n{\n\treturn gpio_mockup_ranges[index * 2];\n}\n\nstatic int gpio_mockup_range_ngpio(unsigned int index)\n{\n\treturn gpio_mockup_ranges[index * 2 + 1];\n}\n\nstatic int __gpio_mockup_get(struct gpio_mockup_chip *chip,\n\t\t\t     unsigned int offset)\n{\n\treturn chip->lines[offset].value;\n}\n\nstatic int gpio_mockup_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_mockup_chip *chip = gpiochip_get_data(gc);\n\tint val;\n\n\tmutex_lock(&chip->lock);\n\tval = __gpio_mockup_get(chip, offset);\n\tmutex_unlock(&chip->lock);\n\n\treturn val;\n}\n\nstatic int gpio_mockup_get_multiple(struct gpio_chip *gc,\n\t\t\t\t    unsigned long *mask, unsigned long *bits)\n{\n\tstruct gpio_mockup_chip *chip = gpiochip_get_data(gc);\n\tunsigned int bit, val;\n\n\tmutex_lock(&chip->lock);\n\tfor_each_set_bit(bit, mask, gc->ngpio) {\n\t\tval = __gpio_mockup_get(chip, bit);\n\t\t__assign_bit(bit, bits, val);\n\t}\n\tmutex_unlock(&chip->lock);\n\n\treturn 0;\n}\n\nstatic void __gpio_mockup_set(struct gpio_mockup_chip *chip,\n\t\t\t      unsigned int offset, int value)\n{\n\tchip->lines[offset].value = !!value;\n}\n\nstatic void gpio_mockup_set(struct gpio_chip *gc,\n\t\t\t   unsigned int offset, int value)\n{\n\tstruct gpio_mockup_chip *chip = gpiochip_get_data(gc);\n\n\tmutex_lock(&chip->lock);\n\t__gpio_mockup_set(chip, offset, value);\n\tmutex_unlock(&chip->lock);\n}\n\nstatic void gpio_mockup_set_multiple(struct gpio_chip *gc,\n\t\t\t\t     unsigned long *mask, unsigned long *bits)\n{\n\tstruct gpio_mockup_chip *chip = gpiochip_get_data(gc);\n\tunsigned int bit;\n\n\tmutex_lock(&chip->lock);\n\tfor_each_set_bit(bit, mask, gc->ngpio)\n\t\t__gpio_mockup_set(chip, bit, test_bit(bit, bits));\n\tmutex_unlock(&chip->lock);\n}\n\nstatic int gpio_mockup_apply_pull(struct gpio_mockup_chip *chip,\n\t\t\t\t  unsigned int offset, int value)\n{\n\tstruct gpio_chip *gc = &chip->gc;\n\tstruct gpio_desc *desc = gpiochip_get_desc(gc, offset);\n\tint curr, irq, irq_type, ret = 0;\n\n\tmutex_lock(&chip->lock);\n\n\tif (test_bit(FLAG_REQUESTED, &desc->flags) &&\n\t    !test_bit(FLAG_IS_OUT, &desc->flags)) {\n\t\tcurr = __gpio_mockup_get(chip, offset);\n\t\tif (curr == value)\n\t\t\tgoto out;\n\n\t\tirq = irq_find_mapping(chip->irq_sim_domain, offset);\n\t\tif (!irq)\n\t\t\t \n\t\t\tgoto set_value;\n\n\t\tirq_type = irq_get_trigger_type(irq);\n\n\t\tif ((value == 1 && (irq_type & IRQ_TYPE_EDGE_RISING)) ||\n\t\t    (value == 0 && (irq_type & IRQ_TYPE_EDGE_FALLING))) {\n\t\t\tret = irq_set_irqchip_state(irq, IRQCHIP_STATE_PENDING,\n\t\t\t\t\t\t    true);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nset_value:\n\t \n\tif (!test_bit(FLAG_REQUESTED, &desc->flags) ||\n\t    !test_bit(FLAG_IS_OUT, &desc->flags))\n\t\t__gpio_mockup_set(chip, offset, value);\n\nout:\n\tchip->lines[offset].pull = value;\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nstatic int gpio_mockup_set_config(struct gpio_chip *gc,\n\t\t\t\t  unsigned int offset, unsigned long config)\n{\n\tstruct gpio_mockup_chip *chip = gpiochip_get_data(gc);\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\treturn gpio_mockup_apply_pull(chip, offset, 1);\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\treturn gpio_mockup_apply_pull(chip, offset, 0);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -ENOTSUPP;\n}\n\nstatic int gpio_mockup_dirout(struct gpio_chip *gc,\n\t\t\t      unsigned int offset, int value)\n{\n\tstruct gpio_mockup_chip *chip = gpiochip_get_data(gc);\n\n\tmutex_lock(&chip->lock);\n\tchip->lines[offset].dir = GPIO_LINE_DIRECTION_OUT;\n\t__gpio_mockup_set(chip, offset, value);\n\tmutex_unlock(&chip->lock);\n\n\treturn 0;\n}\n\nstatic int gpio_mockup_dirin(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_mockup_chip *chip = gpiochip_get_data(gc);\n\n\tmutex_lock(&chip->lock);\n\tchip->lines[offset].dir = GPIO_LINE_DIRECTION_IN;\n\tmutex_unlock(&chip->lock);\n\n\treturn 0;\n}\n\nstatic int gpio_mockup_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_mockup_chip *chip = gpiochip_get_data(gc);\n\tint direction;\n\n\tmutex_lock(&chip->lock);\n\tdirection = chip->lines[offset].dir;\n\tmutex_unlock(&chip->lock);\n\n\treturn direction;\n}\n\nstatic int gpio_mockup_to_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_mockup_chip *chip = gpiochip_get_data(gc);\n\n\treturn irq_create_mapping(chip->irq_sim_domain, offset);\n}\n\nstatic void gpio_mockup_free(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_mockup_chip *chip = gpiochip_get_data(gc);\n\n\t__gpio_mockup_set(chip, offset, chip->lines[offset].pull);\n}\n\nstatic ssize_t gpio_mockup_debugfs_read(struct file *file,\n\t\t\t\t\tchar __user *usr_buf,\n\t\t\t\t\tsize_t size, loff_t *ppos)\n{\n\tstruct gpio_mockup_dbgfs_private *priv;\n\tstruct gpio_mockup_chip *chip;\n\tstruct seq_file *sfile;\n\tstruct gpio_chip *gc;\n\tint val, cnt;\n\tchar buf[3];\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsfile = file->private_data;\n\tpriv = sfile->private;\n\tchip = priv->chip;\n\tgc = &chip->gc;\n\n\tval = gpio_mockup_get(gc, priv->offset);\n\tcnt = snprintf(buf, sizeof(buf), \"%d\\n\", val);\n\n\treturn simple_read_from_buffer(usr_buf, size, ppos, buf, cnt);\n}\n\nstatic ssize_t gpio_mockup_debugfs_write(struct file *file,\n\t\t\t\t\t const char __user *usr_buf,\n\t\t\t\t\t size_t size, loff_t *ppos)\n{\n\tstruct gpio_mockup_dbgfs_private *priv;\n\tint rv, val;\n\tstruct seq_file *sfile;\n\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\trv = kstrtoint_from_user(usr_buf, size, 0, &val);\n\tif (rv)\n\t\treturn rv;\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\n\tsfile = file->private_data;\n\tpriv = sfile->private;\n\trv = gpio_mockup_apply_pull(priv->chip, priv->offset, val);\n\tif (rv)\n\t\treturn rv;\n\n\treturn size;\n}\n\nstatic int gpio_mockup_debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, NULL, inode->i_private);\n}\n\n \nstatic const struct file_operations gpio_mockup_debugfs_ops = {\n\t.owner = THIS_MODULE,\n\t.open = gpio_mockup_debugfs_open,\n\t.read = gpio_mockup_debugfs_read,\n\t.write = gpio_mockup_debugfs_write,\n\t.llseek = no_llseek,\n\t.release = single_release,\n};\n\nstatic void gpio_mockup_debugfs_setup(struct device *dev,\n\t\t\t\t      struct gpio_mockup_chip *chip)\n{\n\tstruct gpio_mockup_dbgfs_private *priv;\n\tstruct gpio_chip *gc;\n\tconst char *devname;\n\tchar *name;\n\tint i;\n\n\tgc = &chip->gc;\n\tdevname = dev_name(&gc->gpiodev->dev);\n\n\tchip->dbg_dir = debugfs_create_dir(devname, gpio_mockup_dbg_dir);\n\n\tfor (i = 0; i < gc->ngpio; i++) {\n\t\tname = devm_kasprintf(dev, GFP_KERNEL, \"%d\", i);\n\t\tif (!name)\n\t\t\treturn;\n\n\t\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\t\tif (!priv)\n\t\t\treturn;\n\n\t\tpriv->chip = chip;\n\t\tpriv->offset = i;\n\t\tpriv->desc = gpiochip_get_desc(gc, i);\n\n\t\tdebugfs_create_file(name, 0600, chip->dbg_dir, priv,\n\t\t\t\t    &gpio_mockup_debugfs_ops);\n\t}\n}\n\nstatic void gpio_mockup_debugfs_cleanup(void *data)\n{\n\tstruct gpio_mockup_chip *chip = data;\n\n\tdebugfs_remove_recursive(chip->dbg_dir);\n}\n\nstatic void gpio_mockup_dispose_mappings(void *data)\n{\n\tstruct gpio_mockup_chip *chip = data;\n\tstruct gpio_chip *gc = &chip->gc;\n\tint i, irq;\n\n\tfor (i = 0; i < gc->ngpio; i++) {\n\t\tirq = irq_find_mapping(chip->irq_sim_domain, i);\n\t\tif (irq)\n\t\t\tirq_dispose_mapping(irq);\n\t}\n}\n\nstatic int gpio_mockup_probe(struct platform_device *pdev)\n{\n\tstruct gpio_mockup_chip *chip;\n\tstruct gpio_chip *gc;\n\tstruct device *dev;\n\tconst char *name;\n\tint rv, base, i;\n\tu16 ngpio;\n\n\tdev = &pdev->dev;\n\n\trv = device_property_read_u32(dev, \"gpio-base\", &base);\n\tif (rv)\n\t\tbase = -1;\n\n\trv = device_property_read_u16(dev, \"nr-gpios\", &ngpio);\n\tif (rv)\n\t\treturn rv;\n\n\trv = device_property_read_string(dev, \"chip-label\", &name);\n\tif (rv)\n\t\tname = dev_name(dev);\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&chip->lock);\n\n\tgc = &chip->gc;\n\tgc->base = base;\n\tgc->ngpio = ngpio;\n\tgc->label = name;\n\tgc->owner = THIS_MODULE;\n\tgc->parent = dev;\n\tgc->get = gpio_mockup_get;\n\tgc->set = gpio_mockup_set;\n\tgc->get_multiple = gpio_mockup_get_multiple;\n\tgc->set_multiple = gpio_mockup_set_multiple;\n\tgc->direction_output = gpio_mockup_dirout;\n\tgc->direction_input = gpio_mockup_dirin;\n\tgc->get_direction = gpio_mockup_get_direction;\n\tgc->set_config = gpio_mockup_set_config;\n\tgc->to_irq = gpio_mockup_to_irq;\n\tgc->free = gpio_mockup_free;\n\n\tchip->lines = devm_kcalloc(dev, gc->ngpio,\n\t\t\t\t   sizeof(*chip->lines), GFP_KERNEL);\n\tif (!chip->lines)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < gc->ngpio; i++)\n\t\tchip->lines[i].dir = GPIO_LINE_DIRECTION_IN;\n\n\tchip->irq_sim_domain = devm_irq_domain_create_sim(dev, NULL,\n\t\t\t\t\t\t\t  gc->ngpio);\n\tif (IS_ERR(chip->irq_sim_domain))\n\t\treturn PTR_ERR(chip->irq_sim_domain);\n\n\trv = devm_add_action_or_reset(dev, gpio_mockup_dispose_mappings, chip);\n\tif (rv)\n\t\treturn rv;\n\n\trv = devm_gpiochip_add_data(dev, &chip->gc, chip);\n\tif (rv)\n\t\treturn rv;\n\n\tgpio_mockup_debugfs_setup(dev, chip);\n\n\treturn devm_add_action_or_reset(dev, gpio_mockup_debugfs_cleanup, chip);\n}\n\nstatic const struct of_device_id gpio_mockup_of_match[] = {\n\t{ .compatible = \"gpio-mockup\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, gpio_mockup_of_match);\n\nstatic struct platform_driver gpio_mockup_driver = {\n\t.driver = {\n\t\t.name = \"gpio-mockup\",\n\t\t.of_match_table = gpio_mockup_of_match,\n\t},\n\t.probe = gpio_mockup_probe,\n};\n\nstatic struct platform_device *gpio_mockup_pdevs[GPIO_MOCKUP_MAX_GC];\n\nstatic void gpio_mockup_unregister_pdevs(void)\n{\n\tstruct platform_device *pdev;\n\tstruct fwnode_handle *fwnode;\n\tint i;\n\n\tfor (i = 0; i < GPIO_MOCKUP_MAX_GC; i++) {\n\t\tpdev = gpio_mockup_pdevs[i];\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfwnode = dev_fwnode(&pdev->dev);\n\t\tplatform_device_unregister(pdev);\n\t\tfwnode_remove_software_node(fwnode);\n\t}\n}\n\nstatic int __init gpio_mockup_register_chip(int idx)\n{\n\tstruct property_entry properties[GPIO_MOCKUP_MAX_PROP];\n\tstruct platform_device_info pdevinfo;\n\tstruct platform_device *pdev;\n\tstruct fwnode_handle *fwnode;\n\tchar **line_names = NULL;\n\tchar chip_label[32];\n\tint prop = 0, base;\n\tu16 ngpio;\n\n\tmemset(properties, 0, sizeof(properties));\n\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\n\tsnprintf(chip_label, sizeof(chip_label), \"gpio-mockup-%c\", idx + 'A');\n\tproperties[prop++] = PROPERTY_ENTRY_STRING(\"chip-label\", chip_label);\n\n\tbase = gpio_mockup_range_base(idx);\n\tif (base >= 0)\n\t\tproperties[prop++] = PROPERTY_ENTRY_U32(\"gpio-base\", base);\n\n\tngpio = base < 0 ? gpio_mockup_range_ngpio(idx)\n\t\t\t : gpio_mockup_range_ngpio(idx) - base;\n\tproperties[prop++] = PROPERTY_ENTRY_U16(\"nr-gpios\", ngpio);\n\n\tif (gpio_mockup_named_lines) {\n\t\tline_names = kasprintf_strarray(GFP_KERNEL, chip_label, ngpio);\n\t\tif (!line_names)\n\t\t\treturn -ENOMEM;\n\n\t\tproperties[prop++] = PROPERTY_ENTRY_STRING_ARRAY_LEN(\n\t\t\t\t\t\"gpio-line-names\", line_names, ngpio);\n\t}\n\n\tfwnode = fwnode_create_software_node(properties, NULL);\n\tif (IS_ERR(fwnode)) {\n\t\tkfree_strarray(line_names, ngpio);\n\t\treturn PTR_ERR(fwnode);\n\t}\n\n\tpdevinfo.name = \"gpio-mockup\";\n\tpdevinfo.id = idx;\n\tpdevinfo.fwnode = fwnode;\n\n\tpdev = platform_device_register_full(&pdevinfo);\n\tkfree_strarray(line_names, ngpio);\n\tif (IS_ERR(pdev)) {\n\t\tfwnode_remove_software_node(fwnode);\n\t\tpr_err(\"error registering device\");\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\tgpio_mockup_pdevs[idx] = pdev;\n\n\treturn 0;\n}\n\nstatic int __init gpio_mockup_init(void)\n{\n\tint i, num_chips, err;\n\n\tif ((gpio_mockup_num_ranges % 2) ||\n\t    (gpio_mockup_num_ranges > GPIO_MOCKUP_MAX_RANGES))\n\t\treturn -EINVAL;\n\n\t \n\tnum_chips = gpio_mockup_num_ranges / 2;\n\n\t \n\tfor (i = 0; i < num_chips; i++) {\n\t\tif (gpio_mockup_range_ngpio(i) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tgpio_mockup_dbg_dir = debugfs_create_dir(\"gpio-mockup\", NULL);\n\n\terr = platform_driver_register(&gpio_mockup_driver);\n\tif (err) {\n\t\tpr_err(\"error registering platform driver\\n\");\n\t\tdebugfs_remove_recursive(gpio_mockup_dbg_dir);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < num_chips; i++) {\n\t\terr = gpio_mockup_register_chip(i);\n\t\tif (err) {\n\t\t\tplatform_driver_unregister(&gpio_mockup_driver);\n\t\t\tgpio_mockup_unregister_pdevs();\n\t\t\tdebugfs_remove_recursive(gpio_mockup_dbg_dir);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit gpio_mockup_exit(void)\n{\n\tgpio_mockup_unregister_pdevs();\n\tdebugfs_remove_recursive(gpio_mockup_dbg_dir);\n\tplatform_driver_unregister(&gpio_mockup_driver);\n}\n\nmodule_init(gpio_mockup_init);\nmodule_exit(gpio_mockup_exit);\n\nMODULE_AUTHOR(\"Kamlakant Patel <kamlakant.patel@broadcom.com>\");\nMODULE_AUTHOR(\"Bamvor Jian Zhang <bamv2005@gmail.com>\");\nMODULE_AUTHOR(\"Bartosz Golaszewski <brgl@bgdev.pl>\");\nMODULE_DESCRIPTION(\"GPIO Testing driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}