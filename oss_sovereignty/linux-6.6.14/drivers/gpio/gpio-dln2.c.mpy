{
  "module_name": "gpio-dln2.c",
  "hash_id": "76c9e6b099a690cdbc4792dce80b4b378a5a19c537081938e68a32030cbd98a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-dln2.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/gpio/driver.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/dln2.h>\n\n#define DLN2_GPIO_ID\t\t\t0x01\n\n#define DLN2_GPIO_GET_PIN_COUNT\t\tDLN2_CMD(0x01, DLN2_GPIO_ID)\n#define DLN2_GPIO_SET_DEBOUNCE\t\tDLN2_CMD(0x04, DLN2_GPIO_ID)\n#define DLN2_GPIO_GET_DEBOUNCE\t\tDLN2_CMD(0x05, DLN2_GPIO_ID)\n#define DLN2_GPIO_PORT_GET_VAL\t\tDLN2_CMD(0x06, DLN2_GPIO_ID)\n#define DLN2_GPIO_PIN_GET_VAL\t\tDLN2_CMD(0x0B, DLN2_GPIO_ID)\n#define DLN2_GPIO_PIN_SET_OUT_VAL\tDLN2_CMD(0x0C, DLN2_GPIO_ID)\n#define DLN2_GPIO_PIN_GET_OUT_VAL\tDLN2_CMD(0x0D, DLN2_GPIO_ID)\n#define DLN2_GPIO_CONDITION_MET_EV\tDLN2_CMD(0x0F, DLN2_GPIO_ID)\n#define DLN2_GPIO_PIN_ENABLE\t\tDLN2_CMD(0x10, DLN2_GPIO_ID)\n#define DLN2_GPIO_PIN_DISABLE\t\tDLN2_CMD(0x11, DLN2_GPIO_ID)\n#define DLN2_GPIO_PIN_SET_DIRECTION\tDLN2_CMD(0x13, DLN2_GPIO_ID)\n#define DLN2_GPIO_PIN_GET_DIRECTION\tDLN2_CMD(0x14, DLN2_GPIO_ID)\n#define DLN2_GPIO_PIN_SET_EVENT_CFG\tDLN2_CMD(0x1E, DLN2_GPIO_ID)\n#define DLN2_GPIO_PIN_GET_EVENT_CFG\tDLN2_CMD(0x1F, DLN2_GPIO_ID)\n\n#define DLN2_GPIO_EVENT_NONE\t\t0\n#define DLN2_GPIO_EVENT_CHANGE\t\t1\n#define DLN2_GPIO_EVENT_LVL_HIGH\t2\n#define DLN2_GPIO_EVENT_LVL_LOW\t\t3\n#define DLN2_GPIO_EVENT_CHANGE_RISING\t0x11\n#define DLN2_GPIO_EVENT_CHANGE_FALLING  0x21\n#define DLN2_GPIO_EVENT_MASK\t\t0x0F\n\n#define DLN2_GPIO_MAX_PINS 32\n\nstruct dln2_gpio {\n\tstruct platform_device *pdev;\n\tstruct gpio_chip gpio;\n\n\t \n\tDECLARE_BITMAP(output_enabled, DLN2_GPIO_MAX_PINS);\n\n\t \n\tDECLARE_BITMAP(unmasked_irqs, DLN2_GPIO_MAX_PINS);\n\t \n\tDECLARE_BITMAP(enabled_irqs, DLN2_GPIO_MAX_PINS);\n\tint irq_type[DLN2_GPIO_MAX_PINS];\n\tstruct mutex irq_lock;\n};\n\nstruct dln2_gpio_pin {\n\t__le16 pin;\n};\n\nstruct dln2_gpio_pin_val {\n\t__le16 pin __packed;\n\tu8 value;\n};\n\nstatic int dln2_gpio_get_pin_count(struct platform_device *pdev)\n{\n\tint ret;\n\t__le16 count;\n\tint len = sizeof(count);\n\n\tret = dln2_transfer_rx(pdev, DLN2_GPIO_GET_PIN_COUNT, &count, &len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (len < sizeof(count))\n\t\treturn -EPROTO;\n\n\treturn le16_to_cpu(count);\n}\n\nstatic int dln2_gpio_pin_cmd(struct dln2_gpio *dln2, int cmd, unsigned pin)\n{\n\tstruct dln2_gpio_pin req = {\n\t\t.pin = cpu_to_le16(pin),\n\t};\n\n\treturn dln2_transfer_tx(dln2->pdev, cmd, &req, sizeof(req));\n}\n\nstatic int dln2_gpio_pin_val(struct dln2_gpio *dln2, int cmd, unsigned int pin)\n{\n\tint ret;\n\tstruct dln2_gpio_pin req = {\n\t\t.pin = cpu_to_le16(pin),\n\t};\n\tstruct dln2_gpio_pin_val rsp;\n\tint len = sizeof(rsp);\n\n\tret = dln2_transfer(dln2->pdev, cmd, &req, sizeof(req), &rsp, &len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (len < sizeof(rsp) || req.pin != rsp.pin)\n\t\treturn -EPROTO;\n\n\treturn rsp.value;\n}\n\nstatic int dln2_gpio_pin_get_in_val(struct dln2_gpio *dln2, unsigned int pin)\n{\n\tint ret;\n\n\tret = dln2_gpio_pin_val(dln2, DLN2_GPIO_PIN_GET_VAL, pin);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn !!ret;\n}\n\nstatic int dln2_gpio_pin_get_out_val(struct dln2_gpio *dln2, unsigned int pin)\n{\n\tint ret;\n\n\tret = dln2_gpio_pin_val(dln2, DLN2_GPIO_PIN_GET_OUT_VAL, pin);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn !!ret;\n}\n\nstatic int dln2_gpio_pin_set_out_val(struct dln2_gpio *dln2,\n\t\t\t\t     unsigned int pin, int value)\n{\n\tstruct dln2_gpio_pin_val req = {\n\t\t.pin = cpu_to_le16(pin),\n\t\t.value = value,\n\t};\n\n\treturn dln2_transfer_tx(dln2->pdev, DLN2_GPIO_PIN_SET_OUT_VAL, &req,\n\t\t\t\tsizeof(req));\n}\n\n#define DLN2_GPIO_DIRECTION_IN\t\t0\n#define DLN2_GPIO_DIRECTION_OUT\t\t1\n\nstatic int dln2_gpio_request(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\n\tstruct dln2_gpio_pin req = {\n\t\t.pin = cpu_to_le16(offset),\n\t};\n\tstruct dln2_gpio_pin_val rsp;\n\tint len = sizeof(rsp);\n\tint ret;\n\n\tret = dln2_gpio_pin_cmd(dln2, DLN2_GPIO_PIN_ENABLE, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = dln2_transfer(dln2->pdev, DLN2_GPIO_PIN_GET_DIRECTION,\n\t\t\t    &req, sizeof(req), &rsp, &len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (len < sizeof(rsp) || req.pin != rsp.pin) {\n\t\tret = -EPROTO;\n\t\tgoto out_disable;\n\t}\n\n\tswitch (rsp.value) {\n\tcase DLN2_GPIO_DIRECTION_IN:\n\t\tclear_bit(offset, dln2->output_enabled);\n\t\treturn 0;\n\tcase DLN2_GPIO_DIRECTION_OUT:\n\t\tset_bit(offset, dln2->output_enabled);\n\t\treturn 0;\n\tdefault:\n\t\tret = -EPROTO;\n\t\tgoto out_disable;\n\t}\n\nout_disable:\n\tdln2_gpio_pin_cmd(dln2, DLN2_GPIO_PIN_DISABLE, offset);\n\treturn ret;\n}\n\nstatic void dln2_gpio_free(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\n\n\tdln2_gpio_pin_cmd(dln2, DLN2_GPIO_PIN_DISABLE, offset);\n}\n\nstatic int dln2_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\n\n\tif (test_bit(offset, dln2->output_enabled))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int dln2_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\n\tint dir;\n\n\tdir = dln2_gpio_get_direction(chip, offset);\n\tif (dir < 0)\n\t\treturn dir;\n\n\tif (dir == GPIO_LINE_DIRECTION_IN)\n\t\treturn dln2_gpio_pin_get_in_val(dln2, offset);\n\n\treturn dln2_gpio_pin_get_out_val(dln2, offset);\n}\n\nstatic void dln2_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\n\n\tdln2_gpio_pin_set_out_val(dln2, offset, value);\n}\n\nstatic int dln2_gpio_set_direction(struct gpio_chip *chip, unsigned offset,\n\t\t\t\t   unsigned dir)\n{\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\n\tstruct dln2_gpio_pin_val req = {\n\t\t.pin = cpu_to_le16(offset),\n\t\t.value = dir,\n\t};\n\tint ret;\n\n\tret = dln2_transfer_tx(dln2->pdev, DLN2_GPIO_PIN_SET_DIRECTION,\n\t\t\t       &req, sizeof(req));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dir == DLN2_GPIO_DIRECTION_OUT)\n\t\tset_bit(offset, dln2->output_enabled);\n\telse\n\t\tclear_bit(offset, dln2->output_enabled);\n\n\treturn ret;\n}\n\nstatic int dln2_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\treturn dln2_gpio_set_direction(chip, offset, DLN2_GPIO_DIRECTION_IN);\n}\n\nstatic int dln2_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\n\t\t\t\t      int value)\n{\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\n\tint ret;\n\n\tret = dln2_gpio_pin_set_out_val(dln2, offset, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn dln2_gpio_set_direction(chip, offset, DLN2_GPIO_DIRECTION_OUT);\n}\n\nstatic int dln2_gpio_set_config(struct gpio_chip *chip, unsigned offset,\n\t\t\t\tunsigned long config)\n{\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\n\t__le32 duration;\n\n\tif (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)\n\t\treturn -ENOTSUPP;\n\n\tduration = cpu_to_le32(pinconf_to_config_argument(config));\n\treturn dln2_transfer_tx(dln2->pdev, DLN2_GPIO_SET_DEBOUNCE,\n\t\t\t\t&duration, sizeof(duration));\n}\n\nstatic int dln2_gpio_set_event_cfg(struct dln2_gpio *dln2, unsigned pin,\n\t\t\t\t   unsigned type, unsigned period)\n{\n\tstruct {\n\t\t__le16 pin;\n\t\tu8 type;\n\t\t__le16 period;\n\t} __packed req = {\n\t\t.pin = cpu_to_le16(pin),\n\t\t.type = type,\n\t\t.period = cpu_to_le16(period),\n\t};\n\n\treturn dln2_transfer_tx(dln2->pdev, DLN2_GPIO_PIN_SET_EVENT_CFG,\n\t\t\t\t&req, sizeof(req));\n}\n\nstatic void dln2_irq_unmask(struct irq_data *irqd)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(gc);\n\tint pin = irqd_to_hwirq(irqd);\n\n\tgpiochip_enable_irq(gc, pin);\n\tset_bit(pin, dln2->unmasked_irqs);\n}\n\nstatic void dln2_irq_mask(struct irq_data *irqd)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(gc);\n\tint pin = irqd_to_hwirq(irqd);\n\n\tclear_bit(pin, dln2->unmasked_irqs);\n\tgpiochip_disable_irq(gc, pin);\n}\n\nstatic int dln2_irq_set_type(struct irq_data *irqd, unsigned type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(gc);\n\tint pin = irqd_to_hwirq(irqd);\n\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tdln2->irq_type[pin] = DLN2_GPIO_EVENT_LVL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tdln2->irq_type[pin] = DLN2_GPIO_EVENT_LVL_LOW;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tdln2->irq_type[pin] = DLN2_GPIO_EVENT_CHANGE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tdln2->irq_type[pin] = DLN2_GPIO_EVENT_CHANGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tdln2->irq_type[pin] = DLN2_GPIO_EVENT_CHANGE_FALLING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void dln2_irq_bus_lock(struct irq_data *irqd)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(gc);\n\n\tmutex_lock(&dln2->irq_lock);\n}\n\nstatic void dln2_irq_bus_unlock(struct irq_data *irqd)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct dln2_gpio *dln2 = gpiochip_get_data(gc);\n\tint pin = irqd_to_hwirq(irqd);\n\tint enabled, unmasked;\n\tunsigned type;\n\tint ret;\n\n\tenabled = test_bit(pin, dln2->enabled_irqs);\n\tunmasked = test_bit(pin, dln2->unmasked_irqs);\n\n\tif (enabled != unmasked) {\n\t\tif (unmasked) {\n\t\t\ttype = dln2->irq_type[pin] & DLN2_GPIO_EVENT_MASK;\n\t\t\tset_bit(pin, dln2->enabled_irqs);\n\t\t} else {\n\t\t\ttype = DLN2_GPIO_EVENT_NONE;\n\t\t\tclear_bit(pin, dln2->enabled_irqs);\n\t\t}\n\n\t\tret = dln2_gpio_set_event_cfg(dln2, pin, type, 0);\n\t\tif (ret)\n\t\t\tdev_err(dln2->gpio.parent, \"failed to set event\\n\");\n\t}\n\n\tmutex_unlock(&dln2->irq_lock);\n}\n\nstatic const struct irq_chip dln2_irqchip = {\n\t.name = \"dln2-irq\",\n\t.irq_mask = dln2_irq_mask,\n\t.irq_unmask = dln2_irq_unmask,\n\t.irq_set_type = dln2_irq_set_type,\n\t.irq_bus_lock = dln2_irq_bus_lock,\n\t.irq_bus_sync_unlock = dln2_irq_bus_unlock,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void dln2_gpio_event(struct platform_device *pdev, u16 echo,\n\t\t\t    const void *data, int len)\n{\n\tint pin, ret;\n\n\tconst struct {\n\t\t__le16 count;\n\t\t__u8 type;\n\t\t__le16 pin;\n\t\t__u8 value;\n\t} __packed *event = data;\n\tstruct dln2_gpio *dln2 = platform_get_drvdata(pdev);\n\n\tif (len < sizeof(*event)) {\n\t\tdev_err(dln2->gpio.parent, \"short event message\\n\");\n\t\treturn;\n\t}\n\n\tpin = le16_to_cpu(event->pin);\n\tif (pin >= dln2->gpio.ngpio) {\n\t\tdev_err(dln2->gpio.parent, \"out of bounds pin %d\\n\", pin);\n\t\treturn;\n\t}\n\n\tswitch (dln2->irq_type[pin]) {\n\tcase DLN2_GPIO_EVENT_CHANGE_RISING:\n\t\tif (!event->value)\n\t\t\treturn;\n\t\tbreak;\n\tcase DLN2_GPIO_EVENT_CHANGE_FALLING:\n\t\tif (event->value)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\n\tret = generic_handle_domain_irq(dln2->gpio.irq.domain, pin);\n\tif (unlikely(ret))\n\t\tdev_err(dln2->gpio.parent, \"pin %d not mapped to IRQ\\n\", pin);\n}\n\nstatic int dln2_gpio_probe(struct platform_device *pdev)\n{\n\tstruct dln2_gpio *dln2;\n\tstruct device *dev = &pdev->dev;\n\tstruct gpio_irq_chip *girq;\n\tint pins;\n\tint ret;\n\n\tpins = dln2_gpio_get_pin_count(pdev);\n\tif (pins < 0) {\n\t\tdev_err(dev, \"failed to get pin count: %d\\n\", pins);\n\t\treturn pins;\n\t}\n\tif (pins > DLN2_GPIO_MAX_PINS) {\n\t\tpins = DLN2_GPIO_MAX_PINS;\n\t\tdev_warn(dev, \"clamping pins to %d\\n\", DLN2_GPIO_MAX_PINS);\n\t}\n\n\tdln2 = devm_kzalloc(&pdev->dev, sizeof(*dln2), GFP_KERNEL);\n\tif (!dln2)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dln2->irq_lock);\n\n\tdln2->pdev = pdev;\n\n\tdln2->gpio.label = \"dln2\";\n\tdln2->gpio.parent = dev;\n\tdln2->gpio.owner = THIS_MODULE;\n\tdln2->gpio.base = -1;\n\tdln2->gpio.ngpio = pins;\n\tdln2->gpio.can_sleep = true;\n\tdln2->gpio.set = dln2_gpio_set;\n\tdln2->gpio.get = dln2_gpio_get;\n\tdln2->gpio.request = dln2_gpio_request;\n\tdln2->gpio.free = dln2_gpio_free;\n\tdln2->gpio.get_direction = dln2_gpio_get_direction;\n\tdln2->gpio.direction_input = dln2_gpio_direction_input;\n\tdln2->gpio.direction_output = dln2_gpio_direction_output;\n\tdln2->gpio.set_config = dln2_gpio_set_config;\n\n\tgirq = &dln2->gpio.irq;\n\tgpio_irq_chip_set_chip(girq, &dln2_irqchip);\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_simple_irq;\n\n\tplatform_set_drvdata(pdev, dln2);\n\n\tret = devm_gpiochip_add_data(dev, &dln2->gpio, dln2);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to add gpio chip: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = dln2_register_event_cb(pdev, DLN2_GPIO_CONDITION_MET_EV,\n\t\t\t\t     dln2_gpio_event);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register event cb: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dln2_gpio_remove(struct platform_device *pdev)\n{\n\tdln2_unregister_event_cb(pdev, DLN2_GPIO_CONDITION_MET_EV);\n\n\treturn 0;\n}\n\nstatic struct platform_driver dln2_gpio_driver = {\n\t.driver.name\t= \"dln2-gpio\",\n\t.probe\t\t= dln2_gpio_probe,\n\t.remove\t\t= dln2_gpio_remove,\n};\n\nmodule_platform_driver(dln2_gpio_driver);\n\nMODULE_AUTHOR(\"Daniel Baluta <daniel.baluta@intel.com\");\nMODULE_DESCRIPTION(\"Driver for the Diolan DLN2 GPIO interface\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:dln2-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}