{
  "module_name": "gpio-hlwd.c",
  "hash_id": "c37b555cc225ddce263161e9e62535cbda450a845f32066397945eea5fb73b91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-hlwd.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n \n#define HW_GPIOB_OUT\t\t0x00\n#define HW_GPIOB_DIR\t\t0x04\n#define HW_GPIOB_IN\t\t0x08\n#define HW_GPIOB_INTLVL\t\t0x0c\n#define HW_GPIOB_INTFLAG\t0x10\n#define HW_GPIOB_INTMASK\t0x14\n#define HW_GPIOB_INMIR\t\t0x18\n#define HW_GPIO_ENABLE\t\t0x1c\n#define HW_GPIO_OUT\t\t0x20\n#define HW_GPIO_DIR\t\t0x24\n#define HW_GPIO_IN\t\t0x28\n#define HW_GPIO_INTLVL\t\t0x2c\n#define HW_GPIO_INTFLAG\t\t0x30\n#define HW_GPIO_INTMASK\t\t0x34\n#define HW_GPIO_INMIR\t\t0x38\n#define HW_GPIO_OWNER\t\t0x3c\n\nstruct hlwd_gpio {\n\tstruct gpio_chip gpioc;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tint irq;\n\tu32 edge_emulation;\n\tu32 rising_edge, falling_edge;\n};\n\nstatic void hlwd_gpio_irqhandler(struct irq_desc *desc)\n{\n\tstruct hlwd_gpio *hlwd =\n\t\tgpiochip_get_data(irq_desc_get_handler_data(desc));\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned long flags;\n\tunsigned long pending;\n\tint hwirq;\n\tu32 emulated_pending;\n\n\traw_spin_lock_irqsave(&hlwd->gpioc.bgpio_lock, flags);\n\tpending = ioread32be(hlwd->regs + HW_GPIOB_INTFLAG);\n\tpending &= ioread32be(hlwd->regs + HW_GPIOB_INTMASK);\n\n\t \n\temulated_pending = hlwd->edge_emulation & pending;\n\tpending &= ~emulated_pending;\n\tif (emulated_pending) {\n\t\tu32 level, rising, falling;\n\n\t\tlevel = ioread32be(hlwd->regs + HW_GPIOB_INTLVL);\n\t\trising = level & emulated_pending;\n\t\tfalling = ~level & emulated_pending;\n\n\t\t \n\t\tiowrite32be(level ^ emulated_pending,\n\t\t\t    hlwd->regs + HW_GPIOB_INTLVL);\n\n\t\t \n\t\tiowrite32be(emulated_pending, hlwd->regs + HW_GPIOB_INTFLAG);\n\n\t\t \n\t\trising &= hlwd->rising_edge;\n\t\tfalling &= hlwd->falling_edge;\n\n\t\t \n\t\tpending |= rising | falling;\n\t}\n\traw_spin_unlock_irqrestore(&hlwd->gpioc.bgpio_lock, flags);\n\n\tchained_irq_enter(chip, desc);\n\n\tfor_each_set_bit(hwirq, &pending, 32)\n\t\tgeneric_handle_domain_irq(hlwd->gpioc.irq.domain, hwirq);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void hlwd_gpio_irq_ack(struct irq_data *data)\n{\n\tstruct hlwd_gpio *hlwd =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(data));\n\n\tiowrite32be(BIT(data->hwirq), hlwd->regs + HW_GPIOB_INTFLAG);\n}\n\nstatic void hlwd_gpio_irq_mask(struct irq_data *data)\n{\n\tstruct hlwd_gpio *hlwd =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(data));\n\tunsigned long flags;\n\tu32 mask;\n\n\traw_spin_lock_irqsave(&hlwd->gpioc.bgpio_lock, flags);\n\tmask = ioread32be(hlwd->regs + HW_GPIOB_INTMASK);\n\tmask &= ~BIT(data->hwirq);\n\tiowrite32be(mask, hlwd->regs + HW_GPIOB_INTMASK);\n\traw_spin_unlock_irqrestore(&hlwd->gpioc.bgpio_lock, flags);\n\tgpiochip_disable_irq(&hlwd->gpioc, irqd_to_hwirq(data));\n}\n\nstatic void hlwd_gpio_irq_unmask(struct irq_data *data)\n{\n\tstruct hlwd_gpio *hlwd =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(data));\n\tunsigned long flags;\n\tu32 mask;\n\n\tgpiochip_enable_irq(&hlwd->gpioc, irqd_to_hwirq(data));\n\traw_spin_lock_irqsave(&hlwd->gpioc.bgpio_lock, flags);\n\tmask = ioread32be(hlwd->regs + HW_GPIOB_INTMASK);\n\tmask |= BIT(data->hwirq);\n\tiowrite32be(mask, hlwd->regs + HW_GPIOB_INTMASK);\n\traw_spin_unlock_irqrestore(&hlwd->gpioc.bgpio_lock, flags);\n}\n\nstatic void hlwd_gpio_irq_enable(struct irq_data *data)\n{\n\thlwd_gpio_irq_ack(data);\n\thlwd_gpio_irq_unmask(data);\n}\n\nstatic void hlwd_gpio_irq_setup_emulation(struct hlwd_gpio *hlwd, int hwirq,\n\t\t\t\t\t  unsigned int flow_type)\n{\n\tu32 level, state;\n\n\t \n\tlevel = ioread32be(hlwd->regs + HW_GPIOB_INTLVL);\n\tstate = ioread32be(hlwd->regs + HW_GPIOB_IN) & BIT(hwirq);\n\tlevel &= ~BIT(hwirq);\n\tlevel |= state ^ BIT(hwirq);\n\tiowrite32be(level, hlwd->regs + HW_GPIOB_INTLVL);\n\n\thlwd->edge_emulation |= BIT(hwirq);\n\thlwd->rising_edge &= ~BIT(hwirq);\n\thlwd->falling_edge &= ~BIT(hwirq);\n\tif (flow_type & IRQ_TYPE_EDGE_RISING)\n\t\thlwd->rising_edge |= BIT(hwirq);\n\tif (flow_type & IRQ_TYPE_EDGE_FALLING)\n\t\thlwd->falling_edge |= BIT(hwirq);\n}\n\nstatic int hlwd_gpio_irq_set_type(struct irq_data *data, unsigned int flow_type)\n{\n\tstruct hlwd_gpio *hlwd =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(data));\n\tunsigned long flags;\n\tu32 level;\n\n\traw_spin_lock_irqsave(&hlwd->gpioc.bgpio_lock, flags);\n\n\thlwd->edge_emulation &= ~BIT(data->hwirq);\n\n\tswitch (flow_type) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tlevel = ioread32be(hlwd->regs + HW_GPIOB_INTLVL);\n\t\tlevel |= BIT(data->hwirq);\n\t\tiowrite32be(level, hlwd->regs + HW_GPIOB_INTLVL);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tlevel = ioread32be(hlwd->regs + HW_GPIOB_INTLVL);\n\t\tlevel &= ~BIT(data->hwirq);\n\t\tiowrite32be(level, hlwd->regs + HW_GPIOB_INTLVL);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\thlwd_gpio_irq_setup_emulation(hlwd, data->hwirq, flow_type);\n\t\tbreak;\n\tdefault:\n\t\traw_spin_unlock_irqrestore(&hlwd->gpioc.bgpio_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_unlock_irqrestore(&hlwd->gpioc.bgpio_lock, flags);\n\treturn 0;\n}\n\nstatic void hlwd_gpio_irq_print_chip(struct irq_data *data, struct seq_file *p)\n{\n\tstruct hlwd_gpio *hlwd =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(data));\n\n\tseq_printf(p, dev_name(hlwd->dev));\n}\n\nstatic const struct irq_chip hlwd_gpio_irq_chip = {\n\t.irq_mask = hlwd_gpio_irq_mask,\n\t.irq_unmask = hlwd_gpio_irq_unmask,\n\t.irq_enable = hlwd_gpio_irq_enable,\n\t.irq_set_type = hlwd_gpio_irq_set_type,\n\t.irq_print_chip = hlwd_gpio_irq_print_chip,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int hlwd_gpio_probe(struct platform_device *pdev)\n{\n\tstruct hlwd_gpio *hlwd;\n\tu32 ngpios;\n\tint res;\n\n\thlwd = devm_kzalloc(&pdev->dev, sizeof(*hlwd), GFP_KERNEL);\n\tif (!hlwd)\n\t\treturn -ENOMEM;\n\n\thlwd->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hlwd->regs))\n\t\treturn PTR_ERR(hlwd->regs);\n\n\thlwd->dev = &pdev->dev;\n\n\t \n\tiowrite32be(0xffffffff, hlwd->regs + HW_GPIO_OWNER);\n\n\tres = bgpio_init(&hlwd->gpioc, &pdev->dev, 4,\n\t\t\thlwd->regs + HW_GPIOB_IN, hlwd->regs + HW_GPIOB_OUT,\n\t\t\tNULL, hlwd->regs + HW_GPIOB_DIR, NULL,\n\t\t\tBGPIOF_BIG_ENDIAN_BYTE_ORDER);\n\tif (res < 0) {\n\t\tdev_warn(&pdev->dev, \"bgpio_init failed: %d\\n\", res);\n\t\treturn res;\n\t}\n\n\tres = of_property_read_u32(pdev->dev.of_node, \"ngpios\", &ngpios);\n\tif (res)\n\t\tngpios = 32;\n\thlwd->gpioc.ngpio = ngpios;\n\n\t \n\tiowrite32be(0, hlwd->regs + HW_GPIOB_INTMASK);\n\tiowrite32be(0xffffffff, hlwd->regs + HW_GPIOB_INTFLAG);\n\n\t \n\tif (of_property_read_bool(pdev->dev.of_node, \"interrupt-controller\")) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\thlwd->irq = platform_get_irq(pdev, 0);\n\t\tif (hlwd->irq < 0) {\n\t\t\tdev_info(&pdev->dev, \"platform_get_irq returned %d\\n\",\n\t\t\t\t hlwd->irq);\n\t\t\treturn hlwd->irq;\n\t\t}\n\n\t\tgirq = &hlwd->gpioc.irq;\n\t\tgpio_irq_chip_set_chip(girq, &hlwd_gpio_irq_chip);\n\t\tgirq->parent_handler = hlwd_gpio_irqhandler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(&pdev->dev, 1,\n\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\tgirq->parents[0] = hlwd->irq;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_level_irq;\n\t}\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &hlwd->gpioc, hlwd);\n}\n\nstatic const struct of_device_id hlwd_gpio_match[] = {\n\t{ .compatible = \"nintendo,hollywood-gpio\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hlwd_gpio_match);\n\nstatic struct platform_driver hlwd_gpio_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"gpio-hlwd\",\n\t\t.of_match_table\t= hlwd_gpio_match,\n\t},\n\t.probe\t= hlwd_gpio_probe,\n};\nmodule_platform_driver(hlwd_gpio_driver);\n\nMODULE_AUTHOR(\"Jonathan Neusch\u00e4fer <j.neuschaefer@gmx.net>\");\nMODULE_DESCRIPTION(\"Nintendo Wii GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}