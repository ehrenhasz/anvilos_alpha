{
  "module_name": "gpiolib-acpi.c",
  "hash_id": "da09cc18e7f8dd2a81a2487291904b5798e973af9c29ab0a0b469ba07433b029",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpiolib-acpi.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/mutex.h>\n#include <linux/pinctrl/pinctrl.h>\n\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/machine.h>\n\n#include \"gpiolib.h\"\n#include \"gpiolib-acpi.h\"\n\nstatic int run_edge_events_on_boot = -1;\nmodule_param(run_edge_events_on_boot, int, 0444);\nMODULE_PARM_DESC(run_edge_events_on_boot,\n\t\t \"Run edge _AEI event-handlers at boot: 0=no, 1=yes, -1=auto\");\n\nstatic char *ignore_wake;\nmodule_param(ignore_wake, charp, 0444);\nMODULE_PARM_DESC(ignore_wake,\n\t\t \"controller@pin combos on which to ignore the ACPI wake flag \"\n\t\t \"ignore_wake=controller@pin[,controller@pin[,...]]\");\n\nstatic char *ignore_interrupt;\nmodule_param(ignore_interrupt, charp, 0444);\nMODULE_PARM_DESC(ignore_interrupt,\n\t\t \"controller@pin combos on which to ignore interrupt \"\n\t\t \"ignore_interrupt=controller@pin[,controller@pin[,...]]\");\n\nstruct acpi_gpiolib_dmi_quirk {\n\tbool no_edge_events_on_boot;\n\tchar *ignore_wake;\n\tchar *ignore_interrupt;\n};\n\n \nstruct acpi_gpio_event {\n\tstruct list_head node;\n\tacpi_handle handle;\n\tirq_handler_t handler;\n\tunsigned int pin;\n\tunsigned int irq;\n\tunsigned long irqflags;\n\tbool irq_is_wake;\n\tbool irq_requested;\n\tstruct gpio_desc *desc;\n};\n\nstruct acpi_gpio_connection {\n\tstruct list_head node;\n\tunsigned int pin;\n\tstruct gpio_desc *desc;\n};\n\nstruct acpi_gpio_chip {\n\t \n\tstruct acpi_connection_info conn_info;\n\tstruct list_head conns;\n\tstruct mutex conn_lock;\n\tstruct gpio_chip *chip;\n\tstruct list_head events;\n\tstruct list_head deferred_req_irqs_list_entry;\n};\n\n \nstruct acpi_gpio_info {\n\tstruct acpi_device *adev;\n\tenum gpiod_flags flags;\n\tbool gpioint;\n\tint pin_config;\n\tint polarity;\n\tint triggering;\n\tbool wake_capable;\n\tunsigned int debounce;\n\tunsigned int quirks;\n};\n\n \nstatic DEFINE_MUTEX(acpi_gpio_deferred_req_irqs_lock);\nstatic LIST_HEAD(acpi_gpio_deferred_req_irqs_list);\nstatic bool acpi_gpio_deferred_req_irqs_done;\n\nstatic int acpi_gpiochip_find(struct gpio_chip *gc, void *data)\n{\n\treturn device_match_acpi_handle(&gc->gpiodev->dev, data);\n}\n\n \nstatic struct gpio_desc *acpi_get_gpiod(char *path, unsigned int pin)\n{\n\tstruct gpio_chip *chip;\n\tacpi_handle handle;\n\tacpi_status status;\n\n\tstatus = acpi_get_handle(NULL, path, &handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tchip = gpiochip_find(handle, acpi_gpiochip_find);\n\tif (!chip)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\treturn gpiochip_get_desc(chip, pin);\n}\n\n \nstruct gpio_desc *acpi_get_and_request_gpiod(char *path, unsigned int pin, char *label)\n{\n\tstruct gpio_desc *gpio;\n\tint ret;\n\n\tgpio = acpi_get_gpiod(path, pin);\n\tif (IS_ERR(gpio))\n\t\treturn gpio;\n\n\tret = gpiod_request(gpio, label);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn gpio;\n}\nEXPORT_SYMBOL_GPL(acpi_get_and_request_gpiod);\n\nstatic irqreturn_t acpi_gpio_irq_handler(int irq, void *data)\n{\n\tstruct acpi_gpio_event *event = data;\n\n\tacpi_evaluate_object(event->handle, NULL, NULL, NULL);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t acpi_gpio_irq_handler_evt(int irq, void *data)\n{\n\tstruct acpi_gpio_event *event = data;\n\n\tacpi_execute_simple_method(event->handle, NULL, event->pin);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void acpi_gpio_chip_dh(acpi_handle handle, void *data)\n{\n\t \n}\n\nbool acpi_gpio_get_irq_resource(struct acpi_resource *ares,\n\t\t\t\tstruct acpi_resource_gpio **agpio)\n{\n\tstruct acpi_resource_gpio *gpio;\n\n\tif (ares->type != ACPI_RESOURCE_TYPE_GPIO)\n\t\treturn false;\n\n\tgpio = &ares->data.gpio;\n\tif (gpio->connection_type != ACPI_RESOURCE_GPIO_TYPE_INT)\n\t\treturn false;\n\n\t*agpio = gpio;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(acpi_gpio_get_irq_resource);\n\n \nbool acpi_gpio_get_io_resource(struct acpi_resource *ares,\n\t\t\t       struct acpi_resource_gpio **agpio)\n{\n\tstruct acpi_resource_gpio *gpio;\n\n\tif (ares->type != ACPI_RESOURCE_TYPE_GPIO)\n\t\treturn false;\n\n\tgpio = &ares->data.gpio;\n\tif (gpio->connection_type != ACPI_RESOURCE_GPIO_TYPE_IO)\n\t\treturn false;\n\n\t*agpio = gpio;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(acpi_gpio_get_io_resource);\n\nstatic void acpi_gpiochip_request_irq(struct acpi_gpio_chip *acpi_gpio,\n\t\t\t\t      struct acpi_gpio_event *event)\n{\n\tstruct device *parent = acpi_gpio->chip->parent;\n\tint ret, value;\n\n\tret = request_threaded_irq(event->irq, NULL, event->handler,\n\t\t\t\t   event->irqflags | IRQF_ONESHOT, \"ACPI:Event\", event);\n\tif (ret) {\n\t\tdev_err(parent, \"Failed to setup interrupt handler for %d\\n\", event->irq);\n\t\treturn;\n\t}\n\n\tif (event->irq_is_wake)\n\t\tenable_irq_wake(event->irq);\n\n\tevent->irq_requested = true;\n\n\t \n\tif (run_edge_events_on_boot &&\n\t    (event->irqflags & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING))) {\n\t\tvalue = gpiod_get_raw_value_cansleep(event->desc);\n\t\tif (((event->irqflags & IRQF_TRIGGER_RISING) && value == 1) ||\n\t\t    ((event->irqflags & IRQF_TRIGGER_FALLING) && value == 0))\n\t\t\tevent->handler(event->irq, event);\n\t}\n}\n\nstatic void acpi_gpiochip_request_irqs(struct acpi_gpio_chip *acpi_gpio)\n{\n\tstruct acpi_gpio_event *event;\n\n\tlist_for_each_entry(event, &acpi_gpio->events, node)\n\t\tacpi_gpiochip_request_irq(acpi_gpio, event);\n}\n\nstatic enum gpiod_flags\nacpi_gpio_to_gpiod_flags(const struct acpi_resource_gpio *agpio, int polarity)\n{\n\t \n\tif (agpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT)\n\t\treturn GPIOD_IN;\n\n\tswitch (agpio->io_restriction) {\n\tcase ACPI_IO_RESTRICT_INPUT:\n\t\treturn GPIOD_IN;\n\tcase ACPI_IO_RESTRICT_OUTPUT:\n\t\t \n\t\tswitch (agpio->pin_config) {\n\t\tcase ACPI_PIN_CONFIG_PULLUP:\n\t\t\treturn polarity == GPIO_ACTIVE_LOW ? GPIOD_OUT_LOW : GPIOD_OUT_HIGH;\n\t\tcase ACPI_PIN_CONFIG_PULLDOWN:\n\t\t\treturn polarity == GPIO_ACTIVE_LOW ? GPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\treturn GPIOD_ASIS;\n}\n\nstatic struct gpio_desc *acpi_request_own_gpiod(struct gpio_chip *chip,\n\t\t\t\t\t\tstruct acpi_resource_gpio *agpio,\n\t\t\t\t\t\tunsigned int index,\n\t\t\t\t\t\tconst char *label)\n{\n\tint polarity = GPIO_ACTIVE_HIGH;\n\tenum gpiod_flags flags = acpi_gpio_to_gpiod_flags(agpio, polarity);\n\tunsigned int pin = agpio->pin_table[index];\n\tstruct gpio_desc *desc;\n\tint ret;\n\n\tdesc = gpiochip_request_own_desc(chip, pin, label, polarity, flags);\n\tif (IS_ERR(desc))\n\t\treturn desc;\n\n\t \n\tret = gpio_set_debounce_timeout(desc, agpio->debounce_timeout * 10);\n\tif (ret)\n\t\tdev_warn(chip->parent,\n\t\t\t \"Failed to set debounce-timeout for pin 0x%04X, err %d\\n\",\n\t\t\t pin, ret);\n\n\treturn desc;\n}\n\nstatic bool acpi_gpio_in_ignore_list(const char *ignore_list, const char *controller_in,\n\t\t\t\t     unsigned int pin_in)\n{\n\tconst char *controller, *pin_str;\n\tunsigned int pin;\n\tchar *endp;\n\tint len;\n\n\tcontroller = ignore_list;\n\twhile (controller) {\n\t\tpin_str = strchr(controller, '@');\n\t\tif (!pin_str)\n\t\t\tgoto err;\n\n\t\tlen = pin_str - controller;\n\t\tif (len == strlen(controller_in) &&\n\t\t    strncmp(controller, controller_in, len) == 0) {\n\t\t\tpin = simple_strtoul(pin_str + 1, &endp, 10);\n\t\t\tif (*endp != 0 && *endp != ',')\n\t\t\t\tgoto err;\n\n\t\t\tif (pin == pin_in)\n\t\t\t\treturn true;\n\t\t}\n\n\t\tcontroller = strchr(controller, ',');\n\t\tif (controller)\n\t\t\tcontroller++;\n\t}\n\n\treturn false;\nerr:\n\tpr_err_once(\"Error: Invalid value for gpiolib_acpi.ignore_...: %s\\n\", ignore_list);\n\treturn false;\n}\n\nstatic bool acpi_gpio_irq_is_wake(struct device *parent,\n\t\t\t\t  const struct acpi_resource_gpio *agpio)\n{\n\tunsigned int pin = agpio->pin_table[0];\n\n\tif (agpio->wake_capable != ACPI_WAKE_CAPABLE)\n\t\treturn false;\n\n\tif (acpi_gpio_in_ignore_list(ignore_wake, dev_name(parent), pin)) {\n\t\tdev_info(parent, \"Ignoring wakeup on pin %u\\n\", pin);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic acpi_status acpi_gpiochip_alloc_event(struct acpi_resource *ares,\n\t\t\t\t\t     void *context)\n{\n\tstruct acpi_gpio_chip *acpi_gpio = context;\n\tstruct gpio_chip *chip = acpi_gpio->chip;\n\tstruct acpi_resource_gpio *agpio;\n\tacpi_handle handle, evt_handle;\n\tstruct acpi_gpio_event *event;\n\tirq_handler_t handler = NULL;\n\tstruct gpio_desc *desc;\n\tunsigned int pin;\n\tint ret, irq;\n\n\tif (!acpi_gpio_get_irq_resource(ares, &agpio))\n\t\treturn AE_OK;\n\n\thandle = ACPI_HANDLE(chip->parent);\n\tpin = agpio->pin_table[0];\n\n\tif (pin <= 255) {\n\t\tchar ev_name[8];\n\t\tsprintf(ev_name, \"_%c%02X\",\n\t\t\tagpio->triggering == ACPI_EDGE_SENSITIVE ? 'E' : 'L',\n\t\t\tpin);\n\t\tif (ACPI_SUCCESS(acpi_get_handle(handle, ev_name, &evt_handle)))\n\t\t\thandler = acpi_gpio_irq_handler;\n\t}\n\tif (!handler) {\n\t\tif (ACPI_SUCCESS(acpi_get_handle(handle, \"_EVT\", &evt_handle)))\n\t\t\thandler = acpi_gpio_irq_handler_evt;\n\t}\n\tif (!handler)\n\t\treturn AE_OK;\n\n\tdesc = acpi_request_own_gpiod(chip, agpio, 0, \"ACPI:Event\");\n\tif (IS_ERR(desc)) {\n\t\tdev_err(chip->parent,\n\t\t\t\"Failed to request GPIO for pin 0x%04X, err %ld\\n\",\n\t\t\tpin, PTR_ERR(desc));\n\t\treturn AE_OK;\n\t}\n\n\tret = gpiochip_lock_as_irq(chip, pin);\n\tif (ret) {\n\t\tdev_err(chip->parent,\n\t\t\t\"Failed to lock GPIO pin 0x%04X as interrupt, err %d\\n\",\n\t\t\tpin, ret);\n\t\tgoto fail_free_desc;\n\t}\n\n\tirq = gpiod_to_irq(desc);\n\tif (irq < 0) {\n\t\tdev_err(chip->parent,\n\t\t\t\"Failed to translate GPIO pin 0x%04X to IRQ, err %d\\n\",\n\t\t\tpin, irq);\n\t\tgoto fail_unlock_irq;\n\t}\n\n\tif (acpi_gpio_in_ignore_list(ignore_interrupt, dev_name(chip->parent), pin)) {\n\t\tdev_info(chip->parent, \"Ignoring interrupt on pin %u\\n\", pin);\n\t\treturn AE_OK;\n\t}\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event)\n\t\tgoto fail_unlock_irq;\n\n\tevent->irqflags = IRQF_ONESHOT;\n\tif (agpio->triggering == ACPI_LEVEL_SENSITIVE) {\n\t\tif (agpio->polarity == ACPI_ACTIVE_HIGH)\n\t\t\tevent->irqflags |= IRQF_TRIGGER_HIGH;\n\t\telse\n\t\t\tevent->irqflags |= IRQF_TRIGGER_LOW;\n\t} else {\n\t\tswitch (agpio->polarity) {\n\t\tcase ACPI_ACTIVE_HIGH:\n\t\t\tevent->irqflags |= IRQF_TRIGGER_RISING;\n\t\t\tbreak;\n\t\tcase ACPI_ACTIVE_LOW:\n\t\t\tevent->irqflags |= IRQF_TRIGGER_FALLING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tevent->irqflags |= IRQF_TRIGGER_RISING |\n\t\t\t\t\t   IRQF_TRIGGER_FALLING;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tevent->handle = evt_handle;\n\tevent->handler = handler;\n\tevent->irq = irq;\n\tevent->irq_is_wake = acpi_gpio_irq_is_wake(chip->parent, agpio);\n\tevent->pin = pin;\n\tevent->desc = desc;\n\n\tlist_add_tail(&event->node, &acpi_gpio->events);\n\n\treturn AE_OK;\n\nfail_unlock_irq:\n\tgpiochip_unlock_as_irq(chip, pin);\nfail_free_desc:\n\tgpiochip_free_own_desc(desc);\n\n\treturn AE_OK;\n}\n\n \nvoid acpi_gpiochip_request_interrupts(struct gpio_chip *chip)\n{\n\tstruct acpi_gpio_chip *acpi_gpio;\n\tacpi_handle handle;\n\tacpi_status status;\n\tbool defer;\n\n\tif (!chip->parent || !chip->to_irq)\n\t\treturn;\n\n\thandle = ACPI_HANDLE(chip->parent);\n\tif (!handle)\n\t\treturn;\n\n\tstatus = acpi_get_data(handle, acpi_gpio_chip_dh, (void **)&acpi_gpio);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tif (acpi_quirk_skip_gpio_event_handlers())\n\t\treturn;\n\n\tacpi_walk_resources(handle, METHOD_NAME__AEI,\n\t\t\t    acpi_gpiochip_alloc_event, acpi_gpio);\n\n\tmutex_lock(&acpi_gpio_deferred_req_irqs_lock);\n\tdefer = !acpi_gpio_deferred_req_irqs_done;\n\tif (defer)\n\t\tlist_add(&acpi_gpio->deferred_req_irqs_list_entry,\n\t\t\t &acpi_gpio_deferred_req_irqs_list);\n\tmutex_unlock(&acpi_gpio_deferred_req_irqs_lock);\n\n\tif (defer)\n\t\treturn;\n\n\tacpi_gpiochip_request_irqs(acpi_gpio);\n}\nEXPORT_SYMBOL_GPL(acpi_gpiochip_request_interrupts);\n\n \nvoid acpi_gpiochip_free_interrupts(struct gpio_chip *chip)\n{\n\tstruct acpi_gpio_chip *acpi_gpio;\n\tstruct acpi_gpio_event *event, *ep;\n\tacpi_handle handle;\n\tacpi_status status;\n\n\tif (!chip->parent || !chip->to_irq)\n\t\treturn;\n\n\thandle = ACPI_HANDLE(chip->parent);\n\tif (!handle)\n\t\treturn;\n\n\tstatus = acpi_get_data(handle, acpi_gpio_chip_dh, (void **)&acpi_gpio);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tmutex_lock(&acpi_gpio_deferred_req_irqs_lock);\n\tif (!list_empty(&acpi_gpio->deferred_req_irqs_list_entry))\n\t\tlist_del_init(&acpi_gpio->deferred_req_irqs_list_entry);\n\tmutex_unlock(&acpi_gpio_deferred_req_irqs_lock);\n\n\tlist_for_each_entry_safe_reverse(event, ep, &acpi_gpio->events, node) {\n\t\tif (event->irq_requested) {\n\t\t\tif (event->irq_is_wake)\n\t\t\t\tdisable_irq_wake(event->irq);\n\n\t\t\tfree_irq(event->irq, event);\n\t\t}\n\n\t\tgpiochip_unlock_as_irq(chip, event->pin);\n\t\tgpiochip_free_own_desc(event->desc);\n\t\tlist_del(&event->node);\n\t\tkfree(event);\n\t}\n}\nEXPORT_SYMBOL_GPL(acpi_gpiochip_free_interrupts);\n\nint acpi_dev_add_driver_gpios(struct acpi_device *adev,\n\t\t\t      const struct acpi_gpio_mapping *gpios)\n{\n\tif (adev && gpios) {\n\t\tadev->driver_gpios = gpios;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_add_driver_gpios);\n\nvoid acpi_dev_remove_driver_gpios(struct acpi_device *adev)\n{\n\tif (adev)\n\t\tadev->driver_gpios = NULL;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_remove_driver_gpios);\n\nstatic void acpi_dev_release_driver_gpios(void *adev)\n{\n\tacpi_dev_remove_driver_gpios(adev);\n}\n\nint devm_acpi_dev_add_driver_gpios(struct device *dev,\n\t\t\t\t   const struct acpi_gpio_mapping *gpios)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tint ret;\n\n\tret = acpi_dev_add_driver_gpios(adev, gpios);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, acpi_dev_release_driver_gpios, adev);\n}\nEXPORT_SYMBOL_GPL(devm_acpi_dev_add_driver_gpios);\n\nstatic bool acpi_get_driver_gpio_data(struct acpi_device *adev,\n\t\t\t\t      const char *name, int index,\n\t\t\t\t      struct fwnode_reference_args *args,\n\t\t\t\t      unsigned int *quirks)\n{\n\tconst struct acpi_gpio_mapping *gm;\n\n\tif (!adev || !adev->driver_gpios)\n\t\treturn false;\n\n\tfor (gm = adev->driver_gpios; gm->name; gm++)\n\t\tif (!strcmp(name, gm->name) && gm->data && index < gm->size) {\n\t\t\tconst struct acpi_gpio_params *par = gm->data + index;\n\n\t\t\targs->fwnode = acpi_fwnode_handle(adev);\n\t\t\targs->args[0] = par->crs_entry_index;\n\t\t\targs->args[1] = par->line_index;\n\t\t\targs->args[2] = par->active_low;\n\t\t\targs->nargs = 3;\n\n\t\t\t*quirks = gm->quirks;\n\t\t\treturn true;\n\t\t}\n\n\treturn false;\n}\n\nstatic int\n__acpi_gpio_update_gpiod_flags(enum gpiod_flags *flags, enum gpiod_flags update)\n{\n\tconst enum gpiod_flags mask =\n\t\tGPIOD_FLAGS_BIT_DIR_SET | GPIOD_FLAGS_BIT_DIR_OUT |\n\t\tGPIOD_FLAGS_BIT_DIR_VAL;\n\tint ret = 0;\n\n\t \n\tif (update & GPIOD_FLAGS_BIT_DIR_SET) {\n\t\tenum gpiod_flags diff = *flags ^ update;\n\n\t\t \n\t\tif (((*flags & GPIOD_FLAGS_BIT_DIR_SET) && (diff & GPIOD_FLAGS_BIT_DIR_OUT)) ||\n\t\t    ((*flags & GPIOD_FLAGS_BIT_DIR_OUT) && (diff & GPIOD_FLAGS_BIT_DIR_VAL)))\n\t\t\tret = -EINVAL;\n\t\t*flags = (*flags & ~mask) | (update & mask);\n\t}\n\treturn ret;\n}\n\nstatic int acpi_gpio_update_gpiod_flags(enum gpiod_flags *flags,\n\t\t\t\t        struct acpi_gpio_info *info)\n{\n\tstruct device *dev = &info->adev->dev;\n\tenum gpiod_flags old = *flags;\n\tint ret;\n\n\tret = __acpi_gpio_update_gpiod_flags(&old, info->flags);\n\tif (info->quirks & ACPI_GPIO_QUIRK_NO_IO_RESTRICTION) {\n\t\tif (ret)\n\t\t\tdev_warn(dev, FW_BUG \"GPIO not in correct mode, fixing\\n\");\n\t} else {\n\t\tif (ret)\n\t\t\tdev_dbg(dev, \"Override GPIO initialization flags\\n\");\n\t\t*flags = old;\n\t}\n\n\treturn ret;\n}\n\nstatic int acpi_gpio_update_gpiod_lookup_flags(unsigned long *lookupflags,\n\t\t\t\t\t       struct acpi_gpio_info *info)\n{\n\tswitch (info->pin_config) {\n\tcase ACPI_PIN_CONFIG_PULLUP:\n\t\t*lookupflags |= GPIO_PULL_UP;\n\t\tbreak;\n\tcase ACPI_PIN_CONFIG_PULLDOWN:\n\t\t*lookupflags |= GPIO_PULL_DOWN;\n\t\tbreak;\n\tcase ACPI_PIN_CONFIG_NOPULL:\n\t\t*lookupflags |= GPIO_PULL_DISABLE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (info->polarity == GPIO_ACTIVE_LOW)\n\t\t*lookupflags |= GPIO_ACTIVE_LOW;\n\n\treturn 0;\n}\n\nstruct acpi_gpio_lookup {\n\tstruct acpi_gpio_info info;\n\tint index;\n\tu16 pin_index;\n\tbool active_low;\n\tstruct gpio_desc *desc;\n\tint n;\n};\n\nstatic int acpi_populate_gpio_lookup(struct acpi_resource *ares, void *data)\n{\n\tstruct acpi_gpio_lookup *lookup = data;\n\n\tif (ares->type != ACPI_RESOURCE_TYPE_GPIO)\n\t\treturn 1;\n\n\tif (!lookup->desc) {\n\t\tconst struct acpi_resource_gpio *agpio = &ares->data.gpio;\n\t\tbool gpioint = agpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT;\n\t\tstruct gpio_desc *desc;\n\t\tu16 pin_index;\n\n\t\tif (lookup->info.quirks & ACPI_GPIO_QUIRK_ONLY_GPIOIO && gpioint)\n\t\t\tlookup->index++;\n\n\t\tif (lookup->n++ != lookup->index)\n\t\t\treturn 1;\n\n\t\tpin_index = lookup->pin_index;\n\t\tif (pin_index >= agpio->pin_table_length)\n\t\t\treturn 1;\n\n\t\tif (lookup->info.quirks & ACPI_GPIO_QUIRK_ABSOLUTE_NUMBER)\n\t\t\tdesc = gpio_to_desc(agpio->pin_table[pin_index]);\n\t\telse\n\t\t\tdesc = acpi_get_gpiod(agpio->resource_source.string_ptr,\n\t\t\t\t\t      agpio->pin_table[pin_index]);\n\t\tlookup->desc = desc;\n\t\tlookup->info.pin_config = agpio->pin_config;\n\t\tlookup->info.debounce = agpio->debounce_timeout;\n\t\tlookup->info.gpioint = gpioint;\n\t\tlookup->info.wake_capable = acpi_gpio_irq_is_wake(&lookup->info.adev->dev, agpio);\n\n\t\t \n\t\tif (lookup->info.gpioint) {\n\t\t\tlookup->info.polarity = agpio->polarity;\n\t\t\tlookup->info.triggering = agpio->triggering;\n\t\t} else {\n\t\t\tlookup->info.polarity = lookup->active_low;\n\t\t}\n\n\t\tlookup->info.flags = acpi_gpio_to_gpiod_flags(agpio, lookup->info.polarity);\n\t}\n\n\treturn 1;\n}\n\nstatic int acpi_gpio_resource_lookup(struct acpi_gpio_lookup *lookup,\n\t\t\t\t     struct acpi_gpio_info *info)\n{\n\tstruct acpi_device *adev = lookup->info.adev;\n\tstruct list_head res_list;\n\tint ret;\n\n\tINIT_LIST_HEAD(&res_list);\n\n\tret = acpi_dev_get_resources(adev, &res_list,\n\t\t\t\t     acpi_populate_gpio_lookup,\n\t\t\t\t     lookup);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tacpi_dev_free_resource_list(&res_list);\n\n\tif (!lookup->desc)\n\t\treturn -ENOENT;\n\n\tif (info)\n\t\t*info = lookup->info;\n\treturn 0;\n}\n\nstatic int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,\n\t\t\t\t     const char *propname, int index,\n\t\t\t\t     struct acpi_gpio_lookup *lookup)\n{\n\tstruct fwnode_reference_args args;\n\tunsigned int quirks = 0;\n\tint ret;\n\n\tmemset(&args, 0, sizeof(args));\n\tret = __acpi_node_get_property_reference(fwnode, propname, index, 3,\n\t\t\t\t\t\t &args);\n\tif (ret) {\n\t\tstruct acpi_device *adev;\n\n\t\tadev = to_acpi_device_node(fwnode);\n\t\tif (!acpi_get_driver_gpio_data(adev, propname, index, &args, &quirks))\n\t\t\treturn ret;\n\t}\n\t \n\tif (!to_acpi_device_node(args.fwnode))\n\t\treturn -EINVAL;\n\tif (args.nargs != 3)\n\t\treturn -EPROTO;\n\n\tlookup->index = args.args[0];\n\tlookup->pin_index = args.args[1];\n\tlookup->active_low = !!args.args[2];\n\n\tlookup->info.adev = to_acpi_device_node(args.fwnode);\n\tlookup->info.quirks = quirks;\n\n\treturn 0;\n}\n\n \nstatic struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,\n\t\t\t\t\t\t const char *propname,\n\t\t\t\t\t\t int index,\n\t\t\t\t\t\t struct acpi_gpio_info *info)\n{\n\tstruct acpi_gpio_lookup lookup;\n\tint ret;\n\n\tif (!adev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmemset(&lookup, 0, sizeof(lookup));\n\tlookup.index = index;\n\n\tif (propname) {\n\t\tdev_dbg(&adev->dev, \"GPIO: looking up %s\\n\", propname);\n\n\t\tret = acpi_gpio_property_lookup(acpi_fwnode_handle(adev),\n\t\t\t\t\t\tpropname, index, &lookup);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tdev_dbg(&adev->dev, \"GPIO: _DSD returned %s %d %u %u\\n\",\n\t\t\tdev_name(&lookup.info.adev->dev), lookup.index,\n\t\t\tlookup.pin_index, lookup.active_low);\n\t} else {\n\t\tdev_dbg(&adev->dev, \"GPIO: looking up %d in _CRS\\n\", index);\n\t\tlookup.info.adev = adev;\n\t}\n\n\tret = acpi_gpio_resource_lookup(&lookup, info);\n\treturn ret ? ERR_PTR(ret) : lookup.desc;\n}\n\n \nstatic struct gpio_desc *acpi_get_gpiod_from_data(struct fwnode_handle *fwnode,\n\t\t\t\t\t\t  const char *propname,\n\t\t\t\t\t\t  int index,\n\t\t\t\t\t\t  struct acpi_gpio_info *info)\n{\n\tstruct acpi_gpio_lookup lookup;\n\tint ret;\n\n\tif (!is_acpi_data_node(fwnode))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (!propname)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmemset(&lookup, 0, sizeof(lookup));\n\tlookup.index = index;\n\n\tret = acpi_gpio_property_lookup(fwnode, propname, index, &lookup);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = acpi_gpio_resource_lookup(&lookup, info);\n\treturn ret ? ERR_PTR(ret) : lookup.desc;\n}\n\nstatic bool acpi_can_fallback_to_crs(struct acpi_device *adev,\n\t\t\t\t     const char *con_id)\n{\n\t \n\tif (acpi_dev_has_props(adev) || adev->driver_gpios)\n\t\treturn false;\n\n\treturn con_id == NULL;\n}\n\nstruct gpio_desc *acpi_find_gpio(struct fwnode_handle *fwnode,\n\t\t\t\t const char *con_id,\n\t\t\t\t unsigned int idx,\n\t\t\t\t enum gpiod_flags *dflags,\n\t\t\t\t unsigned long *lookupflags)\n{\n\tstruct acpi_device *adev = to_acpi_device_node(fwnode);\n\tstruct acpi_gpio_info info;\n\tstruct gpio_desc *desc;\n\tchar propname[32];\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {\n\t\tif (con_id) {\n\t\t\tsnprintf(propname, sizeof(propname), \"%s-%s\",\n\t\t\t\t con_id, gpio_suffixes[i]);\n\t\t} else {\n\t\t\tsnprintf(propname, sizeof(propname), \"%s\",\n\t\t\t\t gpio_suffixes[i]);\n\t\t}\n\n\t\tif (adev)\n\t\t\tdesc = acpi_get_gpiod_by_index(adev,\n\t\t\t\t\t\t       propname, idx, &info);\n\t\telse\n\t\t\tdesc = acpi_get_gpiod_from_data(fwnode,\n\t\t\t\t\t\t        propname, idx, &info);\n\t\tif (!IS_ERR(desc))\n\t\t\tbreak;\n\t\tif (PTR_ERR(desc) == -EPROBE_DEFER)\n\t\t\treturn ERR_CAST(desc);\n\t}\n\n\t \n\tif (IS_ERR(desc)) {\n\t\tif (!adev || !acpi_can_fallback_to_crs(adev, con_id))\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\tdesc = acpi_get_gpiod_by_index(adev, NULL, idx, &info);\n\t\tif (IS_ERR(desc))\n\t\t\treturn desc;\n\t}\n\n\tif (info.gpioint &&\n\t    (*dflags == GPIOD_OUT_LOW || *dflags == GPIOD_OUT_HIGH)) {\n\t\tdev_dbg(&adev->dev, \"refusing GpioInt() entry when doing GPIOD_OUT_* lookup\\n\");\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tacpi_gpio_update_gpiod_flags(dflags, &info);\n\tacpi_gpio_update_gpiod_lookup_flags(lookupflags, &info);\n\treturn desc;\n}\n\n \nint acpi_dev_gpio_irq_wake_get_by(struct acpi_device *adev, const char *name, int index,\n\t\t\t\t  bool *wake_capable)\n{\n\tint idx, i;\n\tunsigned int irq_flags;\n\tint ret;\n\n\tfor (i = 0, idx = 0; idx <= index; i++) {\n\t\tstruct acpi_gpio_info info;\n\t\tstruct gpio_desc *desc;\n\n\t\tdesc = acpi_get_gpiod_by_index(adev, name, i, &info);\n\n\t\t \n\t\tif (IS_ERR(desc) && PTR_ERR(desc) != -EPROBE_DEFER)\n\t\t\treturn PTR_ERR(desc);\n\n\t\tif (info.gpioint && idx++ == index) {\n\t\t\tunsigned long lflags = GPIO_LOOKUP_FLAGS_DEFAULT;\n\t\t\tenum gpiod_flags dflags = GPIOD_ASIS;\n\t\t\tchar label[32];\n\t\t\tint irq;\n\n\t\t\tif (IS_ERR(desc))\n\t\t\t\treturn PTR_ERR(desc);\n\n\t\t\tirq = gpiod_to_irq(desc);\n\t\t\tif (irq < 0)\n\t\t\t\treturn irq;\n\n\t\t\tacpi_gpio_update_gpiod_flags(&dflags, &info);\n\t\t\tacpi_gpio_update_gpiod_lookup_flags(&lflags, &info);\n\n\t\t\tsnprintf(label, sizeof(label), \"GpioInt() %d\", index);\n\t\t\tret = gpiod_configure_flags(desc, label, lflags, dflags);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tret = gpio_set_debounce_timeout(desc, info.debounce * 10);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tirq_flags = acpi_dev_get_irq_type(info.triggering,\n\t\t\t\t\t\t\t  info.polarity);\n\n\t\t\t \n\t\t\tif (can_request_irq(irq, irq_flags)) {\n\t\t\t\tif (irq_flags != IRQ_TYPE_NONE &&\n\t\t\t\t    irq_flags != irq_get_trigger_type(irq))\n\t\t\t\t\tirq_set_irq_type(irq, irq_flags);\n\t\t\t} else {\n\t\t\t\tdev_dbg(&adev->dev, \"IRQ %d already in use\\n\", irq);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (wake_capable && acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0)\n\t\t\t\t*wake_capable = info.wake_capable;\n\n\t\t\treturn irq;\n\t\t}\n\n\t}\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_gpio_irq_wake_get_by);\n\nstatic acpi_status\nacpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,\n\t\t\t    u32 bits, u64 *value, void *handler_context,\n\t\t\t    void *region_context)\n{\n\tstruct acpi_gpio_chip *achip = region_context;\n\tstruct gpio_chip *chip = achip->chip;\n\tstruct acpi_resource_gpio *agpio;\n\tstruct acpi_resource *ares;\n\tu16 pin_index = address;\n\tacpi_status status;\n\tint length;\n\tint i;\n\n\tstatus = acpi_buffer_to_resource(achip->conn_info.connection,\n\t\t\t\t\t achip->conn_info.length, &ares);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tif (WARN_ON(ares->type != ACPI_RESOURCE_TYPE_GPIO)) {\n\t\tACPI_FREE(ares);\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\n\tagpio = &ares->data.gpio;\n\n\tif (WARN_ON(agpio->io_restriction == ACPI_IO_RESTRICT_INPUT &&\n\t    function == ACPI_WRITE)) {\n\t\tACPI_FREE(ares);\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\n\tlength = min_t(u16, agpio->pin_table_length, pin_index + bits);\n\tfor (i = pin_index; i < length; ++i) {\n\t\tunsigned int pin = agpio->pin_table[i];\n\t\tstruct acpi_gpio_connection *conn;\n\t\tstruct gpio_desc *desc;\n\t\tbool found;\n\n\t\tmutex_lock(&achip->conn_lock);\n\n\t\tfound = false;\n\t\tlist_for_each_entry(conn, &achip->conns, node) {\n\t\t\tif (conn->pin == pin) {\n\t\t\t\tfound = true;\n\t\t\t\tdesc = conn->desc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!found && agpio->shareable == ACPI_SHARED &&\n\t\t     function == ACPI_READ) {\n\t\t\tstruct acpi_gpio_event *event;\n\n\t\t\tlist_for_each_entry(event, &achip->events, node) {\n\t\t\t\tif (event->pin == pin) {\n\t\t\t\t\tdesc = event->desc;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tdesc = acpi_request_own_gpiod(chip, agpio, i, \"ACPI:OpRegion\");\n\t\t\tif (IS_ERR(desc)) {\n\t\t\t\tmutex_unlock(&achip->conn_lock);\n\t\t\t\tstatus = AE_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tconn = kzalloc(sizeof(*conn), GFP_KERNEL);\n\t\t\tif (!conn) {\n\t\t\t\tgpiochip_free_own_desc(desc);\n\t\t\t\tmutex_unlock(&achip->conn_lock);\n\t\t\t\tstatus = AE_NO_MEMORY;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tconn->pin = pin;\n\t\t\tconn->desc = desc;\n\t\t\tlist_add_tail(&conn->node, &achip->conns);\n\t\t}\n\n\t\tmutex_unlock(&achip->conn_lock);\n\n\t\tif (function == ACPI_WRITE)\n\t\t\tgpiod_set_raw_value_cansleep(desc, !!(*value & BIT(i)));\n\t\telse\n\t\t\t*value |= (u64)gpiod_get_raw_value_cansleep(desc) << i;\n\t}\n\nout:\n\tACPI_FREE(ares);\n\treturn status;\n}\n\nstatic void acpi_gpiochip_request_regions(struct acpi_gpio_chip *achip)\n{\n\tstruct gpio_chip *chip = achip->chip;\n\tacpi_handle handle = ACPI_HANDLE(chip->parent);\n\tacpi_status status;\n\n\tINIT_LIST_HEAD(&achip->conns);\n\tmutex_init(&achip->conn_lock);\n\tstatus = acpi_install_address_space_handler(handle, ACPI_ADR_SPACE_GPIO,\n\t\t\t\t\t\t    acpi_gpio_adr_space_handler,\n\t\t\t\t\t\t    NULL, achip);\n\tif (ACPI_FAILURE(status))\n\t\tdev_err(chip->parent,\n\t\t        \"Failed to install GPIO OpRegion handler\\n\");\n}\n\nstatic void acpi_gpiochip_free_regions(struct acpi_gpio_chip *achip)\n{\n\tstruct gpio_chip *chip = achip->chip;\n\tacpi_handle handle = ACPI_HANDLE(chip->parent);\n\tstruct acpi_gpio_connection *conn, *tmp;\n\tacpi_status status;\n\n\tstatus = acpi_remove_address_space_handler(handle, ACPI_ADR_SPACE_GPIO,\n\t\t\t\t\t\t   acpi_gpio_adr_space_handler);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(chip->parent,\n\t\t\t\"Failed to remove GPIO OpRegion handler\\n\");\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe_reverse(conn, tmp, &achip->conns, node) {\n\t\tgpiochip_free_own_desc(conn->desc);\n\t\tlist_del(&conn->node);\n\t\tkfree(conn);\n\t}\n}\n\nstatic struct gpio_desc *\nacpi_gpiochip_parse_own_gpio(struct acpi_gpio_chip *achip,\n\t\t\t     struct fwnode_handle *fwnode,\n\t\t\t     const char **name,\n\t\t\t     unsigned long *lflags,\n\t\t\t     enum gpiod_flags *dflags)\n{\n\tstruct gpio_chip *chip = achip->chip;\n\tstruct gpio_desc *desc;\n\tu32 gpios[2];\n\tint ret;\n\n\t*lflags = GPIO_LOOKUP_FLAGS_DEFAULT;\n\t*dflags = GPIOD_ASIS;\n\t*name = NULL;\n\n\tret = fwnode_property_read_u32_array(fwnode, \"gpios\", gpios,\n\t\t\t\t\t     ARRAY_SIZE(gpios));\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tdesc = gpiochip_get_desc(chip, gpios[0]);\n\tif (IS_ERR(desc))\n\t\treturn desc;\n\n\tif (gpios[1])\n\t\t*lflags |= GPIO_ACTIVE_LOW;\n\n\tif (fwnode_property_present(fwnode, \"input\"))\n\t\t*dflags |= GPIOD_IN;\n\telse if (fwnode_property_present(fwnode, \"output-low\"))\n\t\t*dflags |= GPIOD_OUT_LOW;\n\telse if (fwnode_property_present(fwnode, \"output-high\"))\n\t\t*dflags |= GPIOD_OUT_HIGH;\n\telse\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfwnode_property_read_string(fwnode, \"line-name\", name);\n\n\treturn desc;\n}\n\nstatic void acpi_gpiochip_scan_gpios(struct acpi_gpio_chip *achip)\n{\n\tstruct gpio_chip *chip = achip->chip;\n\tstruct fwnode_handle *fwnode;\n\n\tdevice_for_each_child_node(chip->parent, fwnode) {\n\t\tunsigned long lflags;\n\t\tenum gpiod_flags dflags;\n\t\tstruct gpio_desc *desc;\n\t\tconst char *name;\n\t\tint ret;\n\n\t\tif (!fwnode_property_present(fwnode, \"gpio-hog\"))\n\t\t\tcontinue;\n\n\t\tdesc = acpi_gpiochip_parse_own_gpio(achip, fwnode, &name,\n\t\t\t\t\t\t    &lflags, &dflags);\n\t\tif (IS_ERR(desc))\n\t\t\tcontinue;\n\n\t\tret = gpiod_hog(desc, name, lflags, dflags);\n\t\tif (ret) {\n\t\t\tdev_err(chip->parent, \"Failed to hog GPIO\\n\");\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid acpi_gpiochip_add(struct gpio_chip *chip)\n{\n\tstruct acpi_gpio_chip *acpi_gpio;\n\tstruct acpi_device *adev;\n\tacpi_status status;\n\n\tif (!chip || !chip->parent)\n\t\treturn;\n\n\tadev = ACPI_COMPANION(chip->parent);\n\tif (!adev)\n\t\treturn;\n\n\tacpi_gpio = kzalloc(sizeof(*acpi_gpio), GFP_KERNEL);\n\tif (!acpi_gpio) {\n\t\tdev_err(chip->parent,\n\t\t\t\"Failed to allocate memory for ACPI GPIO chip\\n\");\n\t\treturn;\n\t}\n\n\tacpi_gpio->chip = chip;\n\tINIT_LIST_HEAD(&acpi_gpio->events);\n\tINIT_LIST_HEAD(&acpi_gpio->deferred_req_irqs_list_entry);\n\n\tstatus = acpi_attach_data(adev->handle, acpi_gpio_chip_dh, acpi_gpio);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(chip->parent, \"Failed to attach ACPI GPIO chip\\n\");\n\t\tkfree(acpi_gpio);\n\t\treturn;\n\t}\n\n\tacpi_gpiochip_request_regions(acpi_gpio);\n\tacpi_gpiochip_scan_gpios(acpi_gpio);\n\tacpi_dev_clear_dependencies(adev);\n}\n\nvoid acpi_gpiochip_remove(struct gpio_chip *chip)\n{\n\tstruct acpi_gpio_chip *acpi_gpio;\n\tacpi_handle handle;\n\tacpi_status status;\n\n\tif (!chip || !chip->parent)\n\t\treturn;\n\n\thandle = ACPI_HANDLE(chip->parent);\n\tif (!handle)\n\t\treturn;\n\n\tstatus = acpi_get_data(handle, acpi_gpio_chip_dh, (void **)&acpi_gpio);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_warn(chip->parent, \"Failed to retrieve ACPI GPIO chip\\n\");\n\t\treturn;\n\t}\n\n\tacpi_gpiochip_free_regions(acpi_gpio);\n\n\tacpi_detach_data(handle, acpi_gpio_chip_dh);\n\tkfree(acpi_gpio);\n}\n\nstatic int acpi_gpio_package_count(const union acpi_object *obj)\n{\n\tconst union acpi_object *element = obj->package.elements;\n\tconst union acpi_object *end = element + obj->package.count;\n\tunsigned int count = 0;\n\n\twhile (element < end) {\n\t\tswitch (element->type) {\n\t\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\t\t\telement += 3;\n\t\t\tfallthrough;\n\t\tcase ACPI_TYPE_INTEGER:\n\t\t\telement++;\n\t\t\tcount++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EPROTO;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic int acpi_find_gpio_count(struct acpi_resource *ares, void *data)\n{\n\tunsigned int *count = data;\n\n\tif (ares->type == ACPI_RESOURCE_TYPE_GPIO)\n\t\t*count += ares->data.gpio.pin_table_length;\n\n\treturn 1;\n}\n\n \nint acpi_gpio_count(struct device *dev, const char *con_id)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tconst union acpi_object *obj;\n\tconst struct acpi_gpio_mapping *gm;\n\tint count = -ENOENT;\n\tint ret;\n\tchar propname[32];\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {\n\t\tif (con_id)\n\t\t\tsnprintf(propname, sizeof(propname), \"%s-%s\",\n\t\t\t\t con_id, gpio_suffixes[i]);\n\t\telse\n\t\t\tsnprintf(propname, sizeof(propname), \"%s\",\n\t\t\t\t gpio_suffixes[i]);\n\n\t\tret = acpi_dev_get_property(adev, propname, ACPI_TYPE_ANY,\n\t\t\t\t\t    &obj);\n\t\tif (ret == 0) {\n\t\t\tif (obj->type == ACPI_TYPE_LOCAL_REFERENCE)\n\t\t\t\tcount = 1;\n\t\t\telse if (obj->type == ACPI_TYPE_PACKAGE)\n\t\t\t\tcount = acpi_gpio_package_count(obj);\n\t\t} else if (adev->driver_gpios) {\n\t\t\tfor (gm = adev->driver_gpios; gm->name; gm++)\n\t\t\t\tif (strcmp(propname, gm->name) == 0) {\n\t\t\t\t\tcount = gm->size;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif (count > 0)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (count < 0) {\n\t\tstruct list_head resource_list;\n\t\tunsigned int crs_count = 0;\n\n\t\tif (!acpi_can_fallback_to_crs(adev, con_id))\n\t\t\treturn count;\n\n\t\tINIT_LIST_HEAD(&resource_list);\n\t\tacpi_dev_get_resources(adev, &resource_list,\n\t\t\t\t       acpi_find_gpio_count, &crs_count);\n\t\tacpi_dev_free_resource_list(&resource_list);\n\t\tif (crs_count > 0)\n\t\t\tcount = crs_count;\n\t}\n\treturn count ? count : -ENOENT;\n}\n\n \nstatic int __init acpi_gpio_handle_deferred_request_irqs(void)\n{\n\tstruct acpi_gpio_chip *acpi_gpio, *tmp;\n\n\tmutex_lock(&acpi_gpio_deferred_req_irqs_lock);\n\tlist_for_each_entry_safe(acpi_gpio, tmp,\n\t\t\t\t &acpi_gpio_deferred_req_irqs_list,\n\t\t\t\t deferred_req_irqs_list_entry)\n\t\tacpi_gpiochip_request_irqs(acpi_gpio);\n\n\tacpi_gpio_deferred_req_irqs_done = true;\n\tmutex_unlock(&acpi_gpio_deferred_req_irqs_lock);\n\n\treturn 0;\n}\n \nlate_initcall_sync(acpi_gpio_handle_deferred_request_irqs);\n\nstatic const struct dmi_system_id gpiolib_acpi_quirks[] __initconst = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MINIX\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Z83-4\"),\n\t\t},\n\t\t.driver_data = &(struct acpi_gpiolib_dmi_quirk) {\n\t\t\t.no_edge_events_on_boot = true,\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Wortmann_AG\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TERRA_PAD_1061\"),\n\t\t},\n\t\t.driver_data = &(struct acpi_gpiolib_dmi_quirk) {\n\t\t\t.no_edge_events_on_boot = true,\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Venue 10 Pro 5055\"),\n\t\t},\n\t\t.driver_data = &(struct acpi_gpiolib_dmi_quirk) {\n\t\t\t.ignore_wake = \"INT33FC:02@12\",\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP x2 Detachable 10-p0XX\"),\n\t\t},\n\t\t.driver_data = &(struct acpi_gpiolib_dmi_quirk) {\n\t\t\t.ignore_wake = \"INT33FF:01@0,INT0002:00@2\",\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Pavilion x2 Detachable\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"815D\"),\n\t\t},\n\t\t.driver_data = &(struct acpi_gpiolib_dmi_quirk) {\n\t\t\t.ignore_wake = \"INT33FC:02@28\",\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Pavilion x2 Detachable\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"813E\"),\n\t\t},\n\t\t.driver_data = &(struct acpi_gpiolib_dmi_quirk) {\n\t\t\t.ignore_wake = \"INT33FF:01@0\",\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ZenBook UX325UAZ_UM325UAZ\"),\n\t\t},\n\t\t.driver_data = &(struct acpi_gpiolib_dmi_quirk) {\n\t\t\t.ignore_interrupt = \"AMDI0030:00@18\",\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"NL5xNU\"),\n\t\t},\n\t\t.driver_data = &(struct acpi_gpiolib_dmi_quirk) {\n\t\t\t.ignore_wake = \"ELAN0415:00@9\",\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"NL5xRU\"),\n\t\t},\n\t\t.driver_data = &(struct acpi_gpiolib_dmi_quirk) {\n\t\t\t.ignore_wake = \"ELAN0415:00@9\",\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"NH5xAx\"),\n\t\t},\n\t\t.driver_data = &(struct acpi_gpiolib_dmi_quirk) {\n\t\t\t.ignore_wake = \"SYNA1202:00@16\",\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"PEAQ\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PEAQ PMM C1010 MD99187\"),\n\t\t},\n\t\t.driver_data = &(struct acpi_gpiolib_dmi_quirk) {\n\t\t\t.ignore_interrupt = \"INT33FC:00@3\",\n\t\t},\n\t},\n\t{}  \n};\n\nstatic int __init acpi_gpio_setup_params(void)\n{\n\tconst struct acpi_gpiolib_dmi_quirk *quirk = NULL;\n\tconst struct dmi_system_id *id;\n\n\tid = dmi_first_match(gpiolib_acpi_quirks);\n\tif (id)\n\t\tquirk = id->driver_data;\n\n\tif (run_edge_events_on_boot < 0) {\n\t\tif (quirk && quirk->no_edge_events_on_boot)\n\t\t\trun_edge_events_on_boot = 0;\n\t\telse\n\t\t\trun_edge_events_on_boot = 1;\n\t}\n\n\tif (ignore_wake == NULL && quirk && quirk->ignore_wake)\n\t\tignore_wake = quirk->ignore_wake;\n\n\tif (ignore_interrupt == NULL && quirk && quirk->ignore_interrupt)\n\t\tignore_interrupt = quirk->ignore_interrupt;\n\n\treturn 0;\n}\n\n \npostcore_initcall(acpi_gpio_setup_params);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}