{
  "module_name": "gpiolib.c",
  "hash_id": "b9aa439a69dfedf0c1b67dd20d2d31e956f3c571014e5139d3c2e27448b3afce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpiolib.c",
  "human_readable_source": "\n\n#include <linux/acpi.h>\n#include <linux/bitmap.h>\n#include <linux/compat.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <linux/gpio.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/machine.h>\n\n#include <uapi/linux/gpio.h>\n\n#include \"gpiolib-acpi.h\"\n#include \"gpiolib-cdev.h\"\n#include \"gpiolib-of.h\"\n#include \"gpiolib-swnode.h\"\n#include \"gpiolib-sysfs.h\"\n#include \"gpiolib.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/gpio.h>\n\n \n\n\n \n#ifdef\tDEBUG\n#define\textra_checks\t1\n#else\n#define\textra_checks\t0\n#endif\n\n \nstatic DEFINE_IDA(gpio_ida);\nstatic dev_t gpio_devt;\n#define GPIO_DEV_MAX 256  \n\nstatic int gpio_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\n\t \n\tif (fwnode && fwnode->dev != dev)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic struct bus_type gpio_bus_type = {\n\t.name = \"gpio\",\n\t.match = gpio_bus_match,\n};\n\n \n#define FASTPATH_NGPIO CONFIG_GPIOLIB_FASTPATH_LIMIT\n\n \nDEFINE_SPINLOCK(gpio_lock);\n\nstatic DEFINE_MUTEX(gpio_lookup_lock);\nstatic LIST_HEAD(gpio_lookup_list);\nLIST_HEAD(gpio_devices);\n\nstatic DEFINE_MUTEX(gpio_machine_hogs_mutex);\nstatic LIST_HEAD(gpio_machine_hogs);\n\nstatic void gpiochip_free_hogs(struct gpio_chip *gc);\nstatic int gpiochip_add_irqchip(struct gpio_chip *gc,\n\t\t\t\tstruct lock_class_key *lock_key,\n\t\t\t\tstruct lock_class_key *request_key);\nstatic void gpiochip_irqchip_remove(struct gpio_chip *gc);\nstatic int gpiochip_irqchip_init_hw(struct gpio_chip *gc);\nstatic int gpiochip_irqchip_init_valid_mask(struct gpio_chip *gc);\nstatic void gpiochip_irqchip_free_valid_mask(struct gpio_chip *gc);\n\nstatic bool gpiolib_initialized;\n\nstatic inline void desc_set_label(struct gpio_desc *d, const char *label)\n{\n\td->label = label;\n}\n\n \nstruct gpio_desc *gpio_to_desc(unsigned gpio)\n{\n\tstruct gpio_device *gdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\n\tlist_for_each_entry(gdev, &gpio_devices, list) {\n\t\tif (gdev->base <= gpio &&\n\t\t    gdev->base + gdev->ngpio > gpio) {\n\t\t\tspin_unlock_irqrestore(&gpio_lock, flags);\n\t\t\treturn &gdev->descs[gpio - gdev->base];\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\n\tif (!gpio_is_valid(gpio))\n\t\tpr_warn(\"invalid GPIO %d\\n\", gpio);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(gpio_to_desc);\n\n \nstruct gpio_desc *gpiochip_get_desc(struct gpio_chip *gc,\n\t\t\t\t    unsigned int hwnum)\n{\n\tstruct gpio_device *gdev = gc->gpiodev;\n\n\tif (hwnum >= gdev->ngpio)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn &gdev->descs[hwnum];\n}\nEXPORT_SYMBOL_GPL(gpiochip_get_desc);\n\n \nint desc_to_gpio(const struct gpio_desc *desc)\n{\n\treturn desc->gdev->base + (desc - &desc->gdev->descs[0]);\n}\nEXPORT_SYMBOL_GPL(desc_to_gpio);\n\n\n \nstruct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc)\n{\n\tif (!desc || !desc->gdev)\n\t\treturn NULL;\n\treturn desc->gdev->chip;\n}\nEXPORT_SYMBOL_GPL(gpiod_to_chip);\n\n \nstatic int gpiochip_find_base(int ngpio)\n{\n\tstruct gpio_device *gdev;\n\tint base = GPIO_DYNAMIC_BASE;\n\n\tlist_for_each_entry(gdev, &gpio_devices, list) {\n\t\t \n\t\tif (gdev->base >= base + ngpio)\n\t\t\tbreak;\n\t\t \n\t\tbase = gdev->base + gdev->ngpio;\n\t\tif (base < GPIO_DYNAMIC_BASE)\n\t\t\tbase = GPIO_DYNAMIC_BASE;\n\t}\n\n\tif (gpio_is_valid(base)) {\n\t\tpr_debug(\"%s: found new base at %d\\n\", __func__, base);\n\t\treturn base;\n\t} else {\n\t\tpr_err(\"%s: cannot find free range\\n\", __func__);\n\t\treturn -ENOSPC;\n\t}\n}\n\n \nint gpiod_get_direction(struct gpio_desc *desc)\n{\n\tstruct gpio_chip *gc;\n\tunsigned int offset;\n\tint ret;\n\n\tgc = gpiod_to_chip(desc);\n\toffset = gpio_chip_hwgpio(desc);\n\n\t \n\tif (test_bit(FLAG_OPEN_DRAIN, &desc->flags) &&\n\t    test_bit(FLAG_IS_OUT, &desc->flags))\n\t\treturn 0;\n\n\tif (!gc->get_direction)\n\t\treturn -ENOTSUPP;\n\n\tret = gc->get_direction(gc, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ret > 0)\n\t\tret = 1;\n\n\tassign_bit(FLAG_IS_OUT, &desc->flags, !ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gpiod_get_direction);\n\n \nstatic int gpiodev_add_to_list(struct gpio_device *gdev)\n{\n\tstruct gpio_device *prev, *next;\n\n\tif (list_empty(&gpio_devices)) {\n\t\t \n\t\tlist_add_tail(&gdev->list, &gpio_devices);\n\t\treturn 0;\n\t}\n\n\tnext = list_first_entry(&gpio_devices, struct gpio_device, list);\n\tif (gdev->base + gdev->ngpio <= next->base) {\n\t\t \n\t\tlist_add(&gdev->list, &gpio_devices);\n\t\treturn 0;\n\t}\n\n\tprev = list_last_entry(&gpio_devices, struct gpio_device, list);\n\tif (prev->base + prev->ngpio <= gdev->base) {\n\t\t \n\t\tlist_add_tail(&gdev->list, &gpio_devices);\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry_safe(prev, next, &gpio_devices, list) {\n\t\t \n\t\tif (&next->list == &gpio_devices)\n\t\t\tbreak;\n\n\t\t \n\t\tif (prev->base + prev->ngpio <= gdev->base\n\t\t\t\t&& gdev->base + gdev->ngpio <= next->base) {\n\t\t\tlist_add(&gdev->list, &prev->list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EBUSY;\n}\n\n \nstatic struct gpio_desc *gpio_name_to_desc(const char * const name)\n{\n\tstruct gpio_device *gdev;\n\tunsigned long flags;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\n\tlist_for_each_entry(gdev, &gpio_devices, list) {\n\t\tstruct gpio_desc *desc;\n\n\t\tfor_each_gpio_desc(gdev->chip, desc) {\n\t\t\tif (desc->name && !strcmp(desc->name, name)) {\n\t\t\t\tspin_unlock_irqrestore(&gpio_lock, flags);\n\t\t\t\treturn desc;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\n\treturn NULL;\n}\n\n \nstatic int gpiochip_set_desc_names(struct gpio_chip *gc)\n{\n\tstruct gpio_device *gdev = gc->gpiodev;\n\tint i;\n\n\t \n\tfor (i = 0; i != gc->ngpio; ++i) {\n\t\tstruct gpio_desc *gpio;\n\n\t\tgpio = gpio_name_to_desc(gc->names[i]);\n\t\tif (gpio)\n\t\t\tdev_warn(&gdev->dev,\n\t\t\t\t \"Detected name collision for GPIO name '%s'\\n\",\n\t\t\t\t gc->names[i]);\n\t}\n\n\t \n\tfor (i = 0; i != gc->ngpio; ++i)\n\t\tgdev->descs[i].name = gc->names[i];\n\n\treturn 0;\n}\n\n \nstatic int gpiochip_set_names(struct gpio_chip *chip)\n{\n\tstruct gpio_device *gdev = chip->gpiodev;\n\tstruct device *dev = &gdev->dev;\n\tconst char **names;\n\tint ret, i;\n\tint count;\n\n\tcount = device_property_string_array_count(dev, \"gpio-line-names\");\n\tif (count < 0)\n\t\treturn 0;\n\n\t \n\tif (count <= chip->offset) {\n\t\tdev_warn(dev, \"gpio-line-names too short (length %d), cannot map names for the gpiochip at offset %u\\n\",\n\t\t\t count, chip->offset);\n\t\treturn 0;\n\t}\n\n\tnames = kcalloc(count, sizeof(*names), GFP_KERNEL);\n\tif (!names)\n\t\treturn -ENOMEM;\n\n\tret = device_property_read_string_array(dev, \"gpio-line-names\",\n\t\t\t\t\t\tnames, count);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"failed to read GPIO line names\\n\");\n\t\tkfree(names);\n\t\treturn ret;\n\t}\n\n\t \n\tcount = (count > chip->offset) ? count - chip->offset : count;\n\tif (count > chip->ngpio)\n\t\tcount = chip->ngpio;\n\n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tif (names[chip->offset + i] && names[chip->offset + i][0])\n\t\t\tgdev->descs[i].name = names[chip->offset + i];\n\t}\n\n\tkfree(names);\n\n\treturn 0;\n}\n\nstatic unsigned long *gpiochip_allocate_mask(struct gpio_chip *gc)\n{\n\tunsigned long *p;\n\n\tp = bitmap_alloc(gc->ngpio, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\t \n\tbitmap_fill(p, gc->ngpio);\n\n\treturn p;\n}\n\nstatic void gpiochip_free_mask(unsigned long **p)\n{\n\tbitmap_free(*p);\n\t*p = NULL;\n}\n\nstatic unsigned int gpiochip_count_reserved_ranges(struct gpio_chip *gc)\n{\n\tstruct device *dev = &gc->gpiodev->dev;\n\tint size;\n\n\t \n\tsize = device_property_count_u32(dev, \"gpio-reserved-ranges\");\n\tif (size > 0 && size % 2 == 0)\n\t\treturn size;\n\n\treturn 0;\n}\n\nstatic int gpiochip_apply_reserved_ranges(struct gpio_chip *gc)\n{\n\tstruct device *dev = &gc->gpiodev->dev;\n\tunsigned int size;\n\tu32 *ranges;\n\tint ret;\n\n\tsize = gpiochip_count_reserved_ranges(gc);\n\tif (size == 0)\n\t\treturn 0;\n\n\tranges = kmalloc_array(size, sizeof(*ranges), GFP_KERNEL);\n\tif (!ranges)\n\t\treturn -ENOMEM;\n\n\tret = device_property_read_u32_array(dev, \"gpio-reserved-ranges\",\n\t\t\t\t\t     ranges, size);\n\tif (ret) {\n\t\tkfree(ranges);\n\t\treturn ret;\n\t}\n\n\twhile (size) {\n\t\tu32 count = ranges[--size];\n\t\tu32 start = ranges[--size];\n\n\t\tif (start >= gc->ngpio || start + count > gc->ngpio)\n\t\t\tcontinue;\n\n\t\tbitmap_clear(gc->valid_mask, start, count);\n\t}\n\n\tkfree(ranges);\n\treturn 0;\n}\n\nstatic int gpiochip_init_valid_mask(struct gpio_chip *gc)\n{\n\tint ret;\n\n\tif (!(gpiochip_count_reserved_ranges(gc) || gc->init_valid_mask))\n\t\treturn 0;\n\n\tgc->valid_mask = gpiochip_allocate_mask(gc);\n\tif (!gc->valid_mask)\n\t\treturn -ENOMEM;\n\n\tret = gpiochip_apply_reserved_ranges(gc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (gc->init_valid_mask)\n\t\treturn gc->init_valid_mask(gc,\n\t\t\t\t\t   gc->valid_mask,\n\t\t\t\t\t   gc->ngpio);\n\n\treturn 0;\n}\n\nstatic void gpiochip_free_valid_mask(struct gpio_chip *gc)\n{\n\tgpiochip_free_mask(&gc->valid_mask);\n}\n\nstatic int gpiochip_add_pin_ranges(struct gpio_chip *gc)\n{\n\t \n\tif (device_property_present(&gc->gpiodev->dev, \"gpio-ranges\"))\n\t\treturn 0;\n\n\tif (gc->add_pin_ranges)\n\t\treturn gc->add_pin_ranges(gc);\n\n\treturn 0;\n}\n\nbool gpiochip_line_is_valid(const struct gpio_chip *gc,\n\t\t\t\tunsigned int offset)\n{\n\t \n\tif (likely(!gc->valid_mask))\n\t\treturn true;\n\treturn test_bit(offset, gc->valid_mask);\n}\nEXPORT_SYMBOL_GPL(gpiochip_line_is_valid);\n\nstatic void gpiodev_release(struct device *dev)\n{\n\tstruct gpio_device *gdev = to_gpio_device(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\tlist_del(&gdev->list);\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\n\tida_free(&gpio_ida, gdev->id);\n\tkfree_const(gdev->label);\n\tkfree(gdev->descs);\n\tkfree(gdev);\n}\n\n#ifdef CONFIG_GPIO_CDEV\n#define gcdev_register(gdev, devt)\tgpiolib_cdev_register((gdev), (devt))\n#define gcdev_unregister(gdev)\t\tgpiolib_cdev_unregister((gdev))\n#else\n \n#define gcdev_register(gdev, devt)\tdevice_add(&(gdev)->dev)\n#define gcdev_unregister(gdev)\t\tdevice_del(&(gdev)->dev)\n#endif\n\nstatic int gpiochip_setup_dev(struct gpio_device *gdev)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(&gdev->dev);\n\tint ret;\n\n\t \n\tif (fwnode && !fwnode->dev)\n\t\tfwnode_dev_initialized(fwnode, false);\n\n\tret = gcdev_register(gdev, gpio_devt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tgdev->dev.release = gpiodev_release;\n\n\tret = gpiochip_sysfs_register(gdev);\n\tif (ret)\n\t\tgoto err_remove_device;\n\n\tdev_dbg(&gdev->dev, \"registered GPIOs %d to %d on %s\\n\", gdev->base,\n\t\tgdev->base + gdev->ngpio - 1, gdev->chip->label ? : \"generic\");\n\n\treturn 0;\n\nerr_remove_device:\n\tgcdev_unregister(gdev);\n\treturn ret;\n}\n\nstatic void gpiochip_machine_hog(struct gpio_chip *gc, struct gpiod_hog *hog)\n{\n\tstruct gpio_desc *desc;\n\tint rv;\n\n\tdesc = gpiochip_get_desc(gc, hog->chip_hwnum);\n\tif (IS_ERR(desc)) {\n\t\tchip_err(gc, \"%s: unable to get GPIO desc: %ld\\n\", __func__,\n\t\t\t PTR_ERR(desc));\n\t\treturn;\n\t}\n\n\tif (test_bit(FLAG_IS_HOGGED, &desc->flags))\n\t\treturn;\n\n\trv = gpiod_hog(desc, hog->line_name, hog->lflags, hog->dflags);\n\tif (rv)\n\t\tgpiod_err(desc, \"%s: unable to hog GPIO line (%s:%u): %d\\n\",\n\t\t\t  __func__, gc->label, hog->chip_hwnum, rv);\n}\n\nstatic void machine_gpiochip_add(struct gpio_chip *gc)\n{\n\tstruct gpiod_hog *hog;\n\n\tmutex_lock(&gpio_machine_hogs_mutex);\n\n\tlist_for_each_entry(hog, &gpio_machine_hogs, list) {\n\t\tif (!strcmp(gc->label, hog->chip_label))\n\t\t\tgpiochip_machine_hog(gc, hog);\n\t}\n\n\tmutex_unlock(&gpio_machine_hogs_mutex);\n}\n\nstatic void gpiochip_setup_devs(void)\n{\n\tstruct gpio_device *gdev;\n\tint ret;\n\n\tlist_for_each_entry(gdev, &gpio_devices, list) {\n\t\tret = gpiochip_setup_dev(gdev);\n\t\tif (ret)\n\t\t\tdev_err(&gdev->dev,\n\t\t\t\t\"Failed to initialize gpio device (%d)\\n\", ret);\n\t}\n}\n\nstatic void gpiochip_set_data(struct gpio_chip *gc, void *data)\n{\n\tgc->gpiodev->data = data;\n}\n\n \nvoid *gpiochip_get_data(struct gpio_chip *gc)\n{\n\treturn gc->gpiodev->data;\n}\nEXPORT_SYMBOL_GPL(gpiochip_get_data);\n\nint gpiochip_get_ngpios(struct gpio_chip *gc, struct device *dev)\n{\n\tu32 ngpios = gc->ngpio;\n\tint ret;\n\n\tif (ngpios == 0) {\n\t\tret = device_property_read_u32(dev, \"ngpios\", &ngpios);\n\t\tif (ret == -ENODATA)\n\t\t\t \n\t\t\tngpios = 0;\n\t\telse if (ret)\n\t\t\treturn ret;\n\n\t\tgc->ngpio = ngpios;\n\t}\n\n\tif (gc->ngpio == 0) {\n\t\tchip_err(gc, \"tried to insert a GPIO chip with zero lines\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (gc->ngpio > FASTPATH_NGPIO)\n\t\tchip_warn(gc, \"line cnt %u is greater than fast path cnt %u\\n\",\n\t\t\tgc->ngpio, FASTPATH_NGPIO);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gpiochip_get_ngpios);\n\nint gpiochip_add_data_with_key(struct gpio_chip *gc, void *data,\n\t\t\t       struct lock_class_key *lock_key,\n\t\t\t       struct lock_class_key *request_key)\n{\n\tstruct gpio_device *gdev;\n\tunsigned long flags;\n\tunsigned int i;\n\tint base = 0;\n\tint ret = 0;\n\n\t \n\tgdev = kzalloc(sizeof(*gdev), GFP_KERNEL);\n\tif (!gdev)\n\t\treturn -ENOMEM;\n\tgdev->dev.bus = &gpio_bus_type;\n\tgdev->dev.parent = gc->parent;\n\tgdev->chip = gc;\n\n\tgc->gpiodev = gdev;\n\tgpiochip_set_data(gc, data);\n\n\t \n\tif (gc->fwnode)\n\t\tdevice_set_node(&gdev->dev, gc->fwnode);\n\telse if (gc->parent)\n\t\tdevice_set_node(&gdev->dev, dev_fwnode(gc->parent));\n\n\tgdev->id = ida_alloc(&gpio_ida, GFP_KERNEL);\n\tif (gdev->id < 0) {\n\t\tret = gdev->id;\n\t\tgoto err_free_gdev;\n\t}\n\n\tret = dev_set_name(&gdev->dev, GPIOCHIP_NAME \"%d\", gdev->id);\n\tif (ret)\n\t\tgoto err_free_ida;\n\n\tdevice_initialize(&gdev->dev);\n\tif (gc->parent && gc->parent->driver)\n\t\tgdev->owner = gc->parent->driver->owner;\n\telse if (gc->owner)\n\t\t \n\t\tgdev->owner = gc->owner;\n\telse\n\t\tgdev->owner = THIS_MODULE;\n\n\tret = gpiochip_get_ngpios(gc, &gdev->dev);\n\tif (ret)\n\t\tgoto err_free_dev_name;\n\n\tgdev->descs = kcalloc(gc->ngpio, sizeof(*gdev->descs), GFP_KERNEL);\n\tif (!gdev->descs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_dev_name;\n\t}\n\n\tgdev->label = kstrdup_const(gc->label ?: \"unknown\", GFP_KERNEL);\n\tif (!gdev->label) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_descs;\n\t}\n\n\tgdev->ngpio = gc->ngpio;\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\n\t \n\tbase = gc->base;\n\tif (base < 0) {\n\t\tbase = gpiochip_find_base(gc->ngpio);\n\t\tif (base < 0) {\n\t\t\tspin_unlock_irqrestore(&gpio_lock, flags);\n\t\t\tret = base;\n\t\t\tbase = 0;\n\t\t\tgoto err_free_label;\n\t\t}\n\t\t \n\t\tgc->base = base;\n\t} else {\n\t\tdev_warn(&gdev->dev,\n\t\t\t \"Static allocation of GPIO base is deprecated, use dynamic allocation.\\n\");\n\t}\n\tgdev->base = base;\n\n\tret = gpiodev_add_to_list(gdev);\n\tif (ret) {\n\t\tspin_unlock_irqrestore(&gpio_lock, flags);\n\t\tchip_err(gc, \"GPIO integer space overlap, cannot add chip\\n\");\n\t\tgoto err_free_label;\n\t}\n\n\tfor (i = 0; i < gc->ngpio; i++)\n\t\tgdev->descs[i].gdev = gdev;\n\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\n\tBLOCKING_INIT_NOTIFIER_HEAD(&gdev->line_state_notifier);\n\tBLOCKING_INIT_NOTIFIER_HEAD(&gdev->device_notifier);\n\tinit_rwsem(&gdev->sem);\n\n#ifdef CONFIG_PINCTRL\n\tINIT_LIST_HEAD(&gdev->pin_ranges);\n#endif\n\n\tif (gc->names) {\n\t\tret = gpiochip_set_desc_names(gc);\n\t\tif (ret)\n\t\t\tgoto err_remove_from_list;\n\t}\n\tret = gpiochip_set_names(gc);\n\tif (ret)\n\t\tgoto err_remove_from_list;\n\n\tret = gpiochip_init_valid_mask(gc);\n\tif (ret)\n\t\tgoto err_remove_from_list;\n\n\tret = of_gpiochip_add(gc);\n\tif (ret)\n\t\tgoto err_free_gpiochip_mask;\n\n\tfor (i = 0; i < gc->ngpio; i++) {\n\t\tstruct gpio_desc *desc = &gdev->descs[i];\n\n\t\tif (gc->get_direction && gpiochip_line_is_valid(gc, i)) {\n\t\t\tassign_bit(FLAG_IS_OUT,\n\t\t\t\t   &desc->flags, !gc->get_direction(gc, i));\n\t\t} else {\n\t\t\tassign_bit(FLAG_IS_OUT,\n\t\t\t\t   &desc->flags, !gc->direction_input);\n\t\t}\n\t}\n\n\tret = gpiochip_add_pin_ranges(gc);\n\tif (ret)\n\t\tgoto err_remove_of_chip;\n\n\tacpi_gpiochip_add(gc);\n\n\tmachine_gpiochip_add(gc);\n\n\tret = gpiochip_irqchip_init_valid_mask(gc);\n\tif (ret)\n\t\tgoto err_remove_acpi_chip;\n\n\tret = gpiochip_irqchip_init_hw(gc);\n\tif (ret)\n\t\tgoto err_remove_acpi_chip;\n\n\tret = gpiochip_add_irqchip(gc, lock_key, request_key);\n\tif (ret)\n\t\tgoto err_remove_irqchip_mask;\n\n\t \n\tif (gpiolib_initialized) {\n\t\tret = gpiochip_setup_dev(gdev);\n\t\tif (ret)\n\t\t\tgoto err_remove_irqchip;\n\t}\n\treturn 0;\n\nerr_remove_irqchip:\n\tgpiochip_irqchip_remove(gc);\nerr_remove_irqchip_mask:\n\tgpiochip_irqchip_free_valid_mask(gc);\nerr_remove_acpi_chip:\n\tacpi_gpiochip_remove(gc);\nerr_remove_of_chip:\n\tgpiochip_free_hogs(gc);\n\tof_gpiochip_remove(gc);\nerr_free_gpiochip_mask:\n\tgpiochip_remove_pin_ranges(gc);\n\tgpiochip_free_valid_mask(gc);\n\tif (gdev->dev.release) {\n\t\t \n\t\tgpio_device_put(gdev);\n\t\tgoto err_print_message;\n\t}\nerr_remove_from_list:\n\tspin_lock_irqsave(&gpio_lock, flags);\n\tlist_del(&gdev->list);\n\tspin_unlock_irqrestore(&gpio_lock, flags);\nerr_free_label:\n\tkfree_const(gdev->label);\nerr_free_descs:\n\tkfree(gdev->descs);\nerr_free_dev_name:\n\tkfree(dev_name(&gdev->dev));\nerr_free_ida:\n\tida_free(&gpio_ida, gdev->id);\nerr_free_gdev:\n\tkfree(gdev);\nerr_print_message:\n\t \n\tif (ret != -EPROBE_DEFER) {\n\t\tpr_err(\"%s: GPIOs %d..%d (%s) failed to register, %d\\n\", __func__,\n\t\t       base, base + (int)gc->ngpio - 1,\n\t\t       gc->label ? : \"generic\", ret);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gpiochip_add_data_with_key);\n\n \nvoid gpiochip_remove(struct gpio_chip *gc)\n{\n\tstruct gpio_device *gdev = gc->gpiodev;\n\tunsigned long\tflags;\n\tunsigned int\ti;\n\n\tdown_write(&gdev->sem);\n\n\t \n\tgpiochip_sysfs_unregister(gdev);\n\tgpiochip_free_hogs(gc);\n\t \n\tgdev->chip = NULL;\n\tgpiochip_irqchip_remove(gc);\n\tacpi_gpiochip_remove(gc);\n\tof_gpiochip_remove(gc);\n\tgpiochip_remove_pin_ranges(gc);\n\tgpiochip_free_valid_mask(gc);\n\t \n\tgpiochip_set_data(gc, NULL);\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\tfor (i = 0; i < gdev->ngpio; i++) {\n\t\tif (gpiochip_is_requested(gc, i))\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\n\tif (i != gdev->ngpio)\n\t\tdev_crit(&gdev->dev,\n\t\t\t \"REMOVING GPIOCHIP WITH GPIOS STILL REQUESTED\\n\");\n\n\t \n\tgcdev_unregister(gdev);\n\tup_write(&gdev->sem);\n\tgpio_device_put(gdev);\n}\nEXPORT_SYMBOL_GPL(gpiochip_remove);\n\n \nstruct gpio_chip *gpiochip_find(void *data,\n\t\t\t\tint (*match)(struct gpio_chip *gc,\n\t\t\t\t\t     void *data))\n{\n\tstruct gpio_device *gdev;\n\tstruct gpio_chip *gc = NULL;\n\n\tgdev = gpio_device_find(data, match);\n\tif (gdev) {\n\t\tgc = gdev->chip;\n\t\tgpio_device_put(gdev);\n\t}\n\n\treturn gc;\n}\nEXPORT_SYMBOL_GPL(gpiochip_find);\n\n \nstruct gpio_device *gpio_device_find(void *data,\n\t\t\t\t     int (*match)(struct gpio_chip *gc,\n\t\t\t\t\t\t  void *data))\n{\n\tstruct gpio_device *gdev;\n\n\t \n\tmight_sleep();\n\n\tguard(spinlock_irqsave)(&gpio_lock);\n\n\tlist_for_each_entry(gdev, &gpio_devices, list) {\n\t\tif (gdev->chip && match(gdev->chip, data))\n\t\t\treturn gpio_device_get(gdev);\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(gpio_device_find);\n\nstatic int gpiochip_match_name(struct gpio_chip *gc, void *data)\n{\n\tconst char *name = data;\n\n\treturn !strcmp(gc->label, name);\n}\n\nstatic struct gpio_chip *find_chip_by_name(const char *name)\n{\n\treturn gpiochip_find((void *)name, gpiochip_match_name);\n}\n\n \nstruct gpio_device *gpio_device_get(struct gpio_device *gdev)\n{\n\treturn to_gpio_device(get_device(&gdev->dev));\n}\nEXPORT_SYMBOL_GPL(gpio_device_get);\n\n \nvoid gpio_device_put(struct gpio_device *gdev)\n{\n\tput_device(&gdev->dev);\n}\nEXPORT_SYMBOL_GPL(gpio_device_put);\n\n#ifdef CONFIG_GPIOLIB_IRQCHIP\n\n \n\nstatic int gpiochip_irqchip_init_hw(struct gpio_chip *gc)\n{\n\tstruct gpio_irq_chip *girq = &gc->irq;\n\n\tif (!girq->init_hw)\n\t\treturn 0;\n\n\treturn girq->init_hw(gc);\n}\n\nstatic int gpiochip_irqchip_init_valid_mask(struct gpio_chip *gc)\n{\n\tstruct gpio_irq_chip *girq = &gc->irq;\n\n\tif (!girq->init_valid_mask)\n\t\treturn 0;\n\n\tgirq->valid_mask = gpiochip_allocate_mask(gc);\n\tif (!girq->valid_mask)\n\t\treturn -ENOMEM;\n\n\tgirq->init_valid_mask(gc, girq->valid_mask, gc->ngpio);\n\n\treturn 0;\n}\n\nstatic void gpiochip_irqchip_free_valid_mask(struct gpio_chip *gc)\n{\n\tgpiochip_free_mask(&gc->irq.valid_mask);\n}\n\nbool gpiochip_irqchip_irq_valid(const struct gpio_chip *gc,\n\t\t\t\tunsigned int offset)\n{\n\tif (!gpiochip_line_is_valid(gc, offset))\n\t\treturn false;\n\t \n\tif (likely(!gc->irq.valid_mask))\n\t\treturn true;\n\treturn test_bit(offset, gc->irq.valid_mask);\n}\nEXPORT_SYMBOL_GPL(gpiochip_irqchip_irq_valid);\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\n \nstatic void gpiochip_set_hierarchical_irqchip(struct gpio_chip *gc,\n\t\t\t\t\t      struct irq_chip *irqchip)\n{\n\t \n\tif (is_of_node(gc->irq.fwnode))\n\t\treturn;\n\n\t \n\tif (is_fwnode_irqchip(gc->irq.fwnode)) {\n\t\tint i;\n\t\tint ret;\n\n\t\tfor (i = 0; i < gc->ngpio; i++) {\n\t\t\tstruct irq_fwspec fwspec;\n\t\t\tunsigned int parent_hwirq;\n\t\t\tunsigned int parent_type;\n\t\t\tstruct gpio_irq_chip *girq = &gc->irq;\n\n\t\t\t \n\t\t\tret = girq->child_to_parent_hwirq(gc, i,\n\t\t\t\t\t\t\t  IRQ_TYPE_EDGE_RISING,\n\t\t\t\t\t\t\t  &parent_hwirq,\n\t\t\t\t\t\t\t  &parent_type);\n\t\t\tif (ret) {\n\t\t\t\tchip_err(gc, \"skip set-up on hwirq %d\\n\",\n\t\t\t\t\t i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfwspec.fwnode = gc->irq.fwnode;\n\t\t\t \n\t\t\tfwspec.param[0] = girq->child_offset_to_irq(gc, i);\n\t\t\t \n\t\t\tfwspec.param[1] = IRQ_TYPE_EDGE_RISING;\n\t\t\tfwspec.param_count = 2;\n\t\t\tret = irq_domain_alloc_irqs(gc->irq.domain, 1,\n\t\t\t\t\t\t    NUMA_NO_NODE, &fwspec);\n\t\t\tif (ret < 0) {\n\t\t\t\tchip_err(gc,\n\t\t\t\t\t \"can not allocate irq for GPIO line %d parent hwirq %d in hierarchy domain: %d\\n\",\n\t\t\t\t\t i, parent_hwirq,\n\t\t\t\t\t ret);\n\t\t\t}\n\t\t}\n\t}\n\n\tchip_err(gc, \"%s unknown fwnode type proceed anyway\\n\", __func__);\n\n\treturn;\n}\n\nstatic int gpiochip_hierarchy_irq_domain_translate(struct irq_domain *d,\n\t\t\t\t\t\t   struct irq_fwspec *fwspec,\n\t\t\t\t\t\t   unsigned long *hwirq,\n\t\t\t\t\t\t   unsigned int *type)\n{\n\t \n\tif (is_of_node(fwspec->fwnode) && fwspec->param_count == 2) {\n\t\treturn irq_domain_translate_twocell(d, fwspec, hwirq, type);\n\t}\n\n\t \n\tif (is_fwnode_irqchip(fwspec->fwnode)) {\n\t\tint ret;\n\n\t\tret = irq_domain_translate_twocell(d, fwspec, hwirq, type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tWARN_ON(*type == IRQ_TYPE_NONE);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int gpiochip_hierarchy_irq_domain_alloc(struct irq_domain *d,\n\t\t\t\t\t       unsigned int irq,\n\t\t\t\t\t       unsigned int nr_irqs,\n\t\t\t\t\t       void *data)\n{\n\tstruct gpio_chip *gc = d->host_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tstruct irq_fwspec *fwspec = data;\n\tunion gpio_irq_fwspec gpio_parent_fwspec = {};\n\tunsigned int parent_hwirq;\n\tunsigned int parent_type;\n\tstruct gpio_irq_chip *girq = &gc->irq;\n\tint ret;\n\n\t \n\tWARN_ON(nr_irqs != 1);\n\n\tret = gc->irq.child_irq_domain_ops.translate(d, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tchip_dbg(gc, \"allocate IRQ %d, hwirq %lu\\n\", irq, hwirq);\n\n\tret = girq->child_to_parent_hwirq(gc, hwirq, type,\n\t\t\t\t\t  &parent_hwirq, &parent_type);\n\tif (ret) {\n\t\tchip_err(gc, \"can't look up hwirq %lu\\n\", hwirq);\n\t\treturn ret;\n\t}\n\tchip_dbg(gc, \"found parent hwirq %u\\n\", parent_hwirq);\n\n\t \n\tirq_domain_set_info(d,\n\t\t\t    irq,\n\t\t\t    hwirq,\n\t\t\t    gc->irq.chip,\n\t\t\t    gc,\n\t\t\t    girq->handler,\n\t\t\t    NULL, NULL);\n\tirq_set_probe(irq);\n\n\t \n\tret = girq->populate_parent_alloc_arg(gc, &gpio_parent_fwspec,\n\t\t\t\t\t      parent_hwirq, parent_type);\n\tif (ret)\n\t\treturn ret;\n\n\tchip_dbg(gc, \"alloc_irqs_parent for %d parent hwirq %d\\n\",\n\t\t  irq, parent_hwirq);\n\tirq_set_lockdep_class(irq, gc->irq.lock_key, gc->irq.request_key);\n\tret = irq_domain_alloc_irqs_parent(d, irq, 1, &gpio_parent_fwspec);\n\t \n\tif (irq_domain_is_msi(d->parent) && (ret == -EEXIST))\n\t\tret = 0;\n\tif (ret)\n\t\tchip_err(gc,\n\t\t\t \"failed to allocate parent hwirq %d for hwirq %lu\\n\",\n\t\t\t parent_hwirq, hwirq);\n\n\treturn ret;\n}\n\nstatic unsigned int gpiochip_child_offset_to_irq_noop(struct gpio_chip *gc,\n\t\t\t\t\t\t      unsigned int offset)\n{\n\treturn offset;\n}\n\nstatic void gpiochip_hierarchy_setup_domain_ops(struct irq_domain_ops *ops)\n{\n\tops->activate = gpiochip_irq_domain_activate;\n\tops->deactivate = gpiochip_irq_domain_deactivate;\n\tops->alloc = gpiochip_hierarchy_irq_domain_alloc;\n\n\t \n\tif (!ops->translate)\n\t\tops->translate = gpiochip_hierarchy_irq_domain_translate;\n\tif (!ops->free)\n\t\tops->free = irq_domain_free_irqs_common;\n}\n\nstatic struct irq_domain *gpiochip_hierarchy_create_domain(struct gpio_chip *gc)\n{\n\tstruct irq_domain *domain;\n\n\tif (!gc->irq.child_to_parent_hwirq ||\n\t    !gc->irq.fwnode) {\n\t\tchip_err(gc, \"missing irqdomain vital data\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!gc->irq.child_offset_to_irq)\n\t\tgc->irq.child_offset_to_irq = gpiochip_child_offset_to_irq_noop;\n\n\tif (!gc->irq.populate_parent_alloc_arg)\n\t\tgc->irq.populate_parent_alloc_arg =\n\t\t\tgpiochip_populate_parent_fwspec_twocell;\n\n\tgpiochip_hierarchy_setup_domain_ops(&gc->irq.child_irq_domain_ops);\n\n\tdomain = irq_domain_create_hierarchy(\n\t\tgc->irq.parent_domain,\n\t\t0,\n\t\tgc->ngpio,\n\t\tgc->irq.fwnode,\n\t\t&gc->irq.child_irq_domain_ops,\n\t\tgc);\n\n\tif (!domain)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgpiochip_set_hierarchical_irqchip(gc, gc->irq.chip);\n\n\treturn domain;\n}\n\nstatic bool gpiochip_hierarchy_is_hierarchical(struct gpio_chip *gc)\n{\n\treturn !!gc->irq.parent_domain;\n}\n\nint gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *gc,\n\t\t\t\t\t    union gpio_irq_fwspec *gfwspec,\n\t\t\t\t\t    unsigned int parent_hwirq,\n\t\t\t\t\t    unsigned int parent_type)\n{\n\tstruct irq_fwspec *fwspec = &gfwspec->fwspec;\n\n\tfwspec->fwnode = gc->irq.parent_domain->fwnode;\n\tfwspec->param_count = 2;\n\tfwspec->param[0] = parent_hwirq;\n\tfwspec->param[1] = parent_type;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gpiochip_populate_parent_fwspec_twocell);\n\nint gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *gc,\n\t\t\t\t\t     union gpio_irq_fwspec *gfwspec,\n\t\t\t\t\t     unsigned int parent_hwirq,\n\t\t\t\t\t     unsigned int parent_type)\n{\n\tstruct irq_fwspec *fwspec = &gfwspec->fwspec;\n\n\tfwspec->fwnode = gc->irq.parent_domain->fwnode;\n\tfwspec->param_count = 4;\n\tfwspec->param[0] = 0;\n\tfwspec->param[1] = parent_hwirq;\n\tfwspec->param[2] = 0;\n\tfwspec->param[3] = parent_type;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gpiochip_populate_parent_fwspec_fourcell);\n\n#else\n\nstatic struct irq_domain *gpiochip_hierarchy_create_domain(struct gpio_chip *gc)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic bool gpiochip_hierarchy_is_hierarchical(struct gpio_chip *gc)\n{\n\treturn false;\n}\n\n#endif  \n\n \nint gpiochip_irq_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hwirq)\n{\n\tstruct gpio_chip *gc = d->host_data;\n\tint ret = 0;\n\n\tif (!gpiochip_irqchip_irq_valid(gc, hwirq))\n\t\treturn -ENXIO;\n\n\tirq_set_chip_data(irq, gc);\n\t \n\tirq_set_lockdep_class(irq, gc->irq.lock_key, gc->irq.request_key);\n\tirq_set_chip_and_handler(irq, gc->irq.chip, gc->irq.handler);\n\t \n\tif (gc->irq.threaded)\n\t\tirq_set_nested_thread(irq, 1);\n\tirq_set_noprobe(irq);\n\n\tif (gc->irq.num_parents == 1)\n\t\tret = irq_set_parent(irq, gc->irq.parents[0]);\n\telse if (gc->irq.map)\n\t\tret = irq_set_parent(irq, gc->irq.map[hwirq]);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (gc->irq.default_type != IRQ_TYPE_NONE)\n\t\tirq_set_irq_type(irq, gc->irq.default_type);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gpiochip_irq_map);\n\nvoid gpiochip_irq_unmap(struct irq_domain *d, unsigned int irq)\n{\n\tstruct gpio_chip *gc = d->host_data;\n\n\tif (gc->irq.threaded)\n\t\tirq_set_nested_thread(irq, 0);\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\tirq_set_chip_data(irq, NULL);\n}\nEXPORT_SYMBOL_GPL(gpiochip_irq_unmap);\n\nstatic const struct irq_domain_ops gpiochip_domain_ops = {\n\t.map\t= gpiochip_irq_map,\n\t.unmap\t= gpiochip_irq_unmap,\n\t \n\t.xlate\t= irq_domain_xlate_twocell,\n};\n\nstatic struct irq_domain *gpiochip_simple_create_domain(struct gpio_chip *gc)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(&gc->gpiodev->dev);\n\tstruct irq_domain *domain;\n\n\tdomain = irq_domain_create_simple(fwnode, gc->ngpio, gc->irq.first,\n\t\t\t\t\t  &gpiochip_domain_ops, gc);\n\tif (!domain)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn domain;\n}\n\n \n \nint gpiochip_irq_domain_activate(struct irq_domain *domain,\n\t\t\t\t struct irq_data *data, bool reserve)\n{\n\tstruct gpio_chip *gc = domain->host_data;\n\tunsigned int hwirq = irqd_to_hwirq(data);\n\n\treturn gpiochip_lock_as_irq(gc, hwirq);\n}\nEXPORT_SYMBOL_GPL(gpiochip_irq_domain_activate);\n\n \nvoid gpiochip_irq_domain_deactivate(struct irq_domain *domain,\n\t\t\t\t    struct irq_data *data)\n{\n\tstruct gpio_chip *gc = domain->host_data;\n\tunsigned int hwirq = irqd_to_hwirq(data);\n\n\treturn gpiochip_unlock_as_irq(gc, hwirq);\n}\nEXPORT_SYMBOL_GPL(gpiochip_irq_domain_deactivate);\n\nstatic int gpiochip_to_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct irq_domain *domain = gc->irq.domain;\n\n#ifdef CONFIG_GPIOLIB_IRQCHIP\n\t \n\tif (!gc->irq.initialized)\n\t\treturn -EPROBE_DEFER;\n#endif\n\n\tif (!gpiochip_irqchip_irq_valid(gc, offset))\n\t\treturn -ENXIO;\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tstruct irq_fwspec spec;\n\n\t\tspec.fwnode = domain->fwnode;\n\t\tspec.param_count = 2;\n\t\tspec.param[0] = gc->irq.child_offset_to_irq(gc, offset);\n\t\tspec.param[1] = IRQ_TYPE_NONE;\n\n\t\treturn irq_create_fwspec_mapping(&spec);\n\t}\n#endif\n\n\treturn irq_create_mapping(domain, offset);\n}\n\nint gpiochip_irq_reqres(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\n\treturn gpiochip_reqres_irq(gc, hwirq);\n}\nEXPORT_SYMBOL(gpiochip_irq_reqres);\n\nvoid gpiochip_irq_relres(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\n\tgpiochip_relres_irq(gc, hwirq);\n}\nEXPORT_SYMBOL(gpiochip_irq_relres);\n\nstatic void gpiochip_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\n\tif (gc->irq.irq_mask)\n\t\tgc->irq.irq_mask(d);\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void gpiochip_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\n\tgpiochip_enable_irq(gc, hwirq);\n\tif (gc->irq.irq_unmask)\n\t\tgc->irq.irq_unmask(d);\n}\n\nstatic void gpiochip_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\n\tgpiochip_enable_irq(gc, hwirq);\n\tgc->irq.irq_enable(d);\n}\n\nstatic void gpiochip_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\n\tgc->irq.irq_disable(d);\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void gpiochip_set_irq_hooks(struct gpio_chip *gc)\n{\n\tstruct irq_chip *irqchip = gc->irq.chip;\n\n\tif (irqchip->flags & IRQCHIP_IMMUTABLE)\n\t\treturn;\n\n\tchip_warn(gc, \"not an immutable chip, please consider fixing it!\\n\");\n\n\tif (!irqchip->irq_request_resources &&\n\t    !irqchip->irq_release_resources) {\n\t\tirqchip->irq_request_resources = gpiochip_irq_reqres;\n\t\tirqchip->irq_release_resources = gpiochip_irq_relres;\n\t}\n\tif (WARN_ON(gc->irq.irq_enable))\n\t\treturn;\n\t \n\tif (irqchip->irq_enable == gpiochip_irq_enable ||\n\t\tirqchip->irq_mask == gpiochip_irq_mask) {\n\t\t \n\t\tchip_info(gc,\n\t\t\t  \"detected irqchip that is shared with multiple gpiochips: please fix the driver.\\n\");\n\t\treturn;\n\t}\n\n\tif (irqchip->irq_disable) {\n\t\tgc->irq.irq_disable = irqchip->irq_disable;\n\t\tirqchip->irq_disable = gpiochip_irq_disable;\n\t} else {\n\t\tgc->irq.irq_mask = irqchip->irq_mask;\n\t\tirqchip->irq_mask = gpiochip_irq_mask;\n\t}\n\n\tif (irqchip->irq_enable) {\n\t\tgc->irq.irq_enable = irqchip->irq_enable;\n\t\tirqchip->irq_enable = gpiochip_irq_enable;\n\t} else {\n\t\tgc->irq.irq_unmask = irqchip->irq_unmask;\n\t\tirqchip->irq_unmask = gpiochip_irq_unmask;\n\t}\n}\n\nstatic int gpiochip_irqchip_add_allocated_domain(struct gpio_chip *gc,\n\t\t\t\t\t\t struct irq_domain *domain,\n\t\t\t\t\t\t bool allocated_externally)\n{\n\tif (!domain)\n\t\treturn -EINVAL;\n\n\tif (gc->to_irq)\n\t\tchip_warn(gc, \"to_irq is redefined in %s and you shouldn't rely on it\\n\", __func__);\n\n\tgc->to_irq = gpiochip_to_irq;\n\tgc->irq.domain = domain;\n\tgc->irq.domain_is_allocated_externally = allocated_externally;\n\n\t \n\tbarrier();\n\n\tgc->irq.initialized = true;\n\n\treturn 0;\n}\n\n \nstatic int gpiochip_add_irqchip(struct gpio_chip *gc,\n\t\t\t\tstruct lock_class_key *lock_key,\n\t\t\t\tstruct lock_class_key *request_key)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(&gc->gpiodev->dev);\n\tstruct irq_chip *irqchip = gc->irq.chip;\n\tstruct irq_domain *domain;\n\tunsigned int type;\n\tunsigned int i;\n\tint ret;\n\n\tif (!irqchip)\n\t\treturn 0;\n\n\tif (gc->irq.parent_handler && gc->can_sleep) {\n\t\tchip_err(gc, \"you cannot have chained interrupts on a chip that may sleep\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttype = gc->irq.default_type;\n\n\t \n\tif (WARN(fwnode && type != IRQ_TYPE_NONE,\n\t\t \"%pfw: Ignoring %u default trigger\\n\", fwnode, type))\n\t\ttype = IRQ_TYPE_NONE;\n\n\tgc->irq.default_type = type;\n\tgc->irq.lock_key = lock_key;\n\tgc->irq.request_key = request_key;\n\n\t \n\tif (gpiochip_hierarchy_is_hierarchical(gc)) {\n\t\tdomain = gpiochip_hierarchy_create_domain(gc);\n\t} else {\n\t\tdomain = gpiochip_simple_create_domain(gc);\n\t}\n\tif (IS_ERR(domain))\n\t\treturn PTR_ERR(domain);\n\n\tif (gc->irq.parent_handler) {\n\t\tfor (i = 0; i < gc->irq.num_parents; i++) {\n\t\t\tvoid *data;\n\n\t\t\tif (gc->irq.per_parent_data)\n\t\t\t\tdata = gc->irq.parent_handler_data_array[i];\n\t\t\telse\n\t\t\t\tdata = gc->irq.parent_handler_data ?: gc;\n\n\t\t\t \n\t\t\tirq_set_chained_handler_and_data(gc->irq.parents[i],\n\t\t\t\t\t\t\t gc->irq.parent_handler,\n\t\t\t\t\t\t\t data);\n\t\t}\n\t}\n\n\tgpiochip_set_irq_hooks(gc);\n\n\tret = gpiochip_irqchip_add_allocated_domain(gc, domain, false);\n\tif (ret)\n\t\treturn ret;\n\n\tacpi_gpiochip_request_interrupts(gc);\n\n\treturn 0;\n}\n\n \nstatic void gpiochip_irqchip_remove(struct gpio_chip *gc)\n{\n\tstruct irq_chip *irqchip = gc->irq.chip;\n\tunsigned int offset;\n\n\tacpi_gpiochip_free_interrupts(gc);\n\n\tif (irqchip && gc->irq.parent_handler) {\n\t\tstruct gpio_irq_chip *irq = &gc->irq;\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < irq->num_parents; i++)\n\t\t\tirq_set_chained_handler_and_data(irq->parents[i],\n\t\t\t\t\t\t\t NULL, NULL);\n\t}\n\n\t \n\tif (!gc->irq.domain_is_allocated_externally && gc->irq.domain) {\n\t\tunsigned int irq;\n\n\t\tfor (offset = 0; offset < gc->ngpio; offset++) {\n\t\t\tif (!gpiochip_irqchip_irq_valid(gc, offset))\n\t\t\t\tcontinue;\n\n\t\t\tirq = irq_find_mapping(gc->irq.domain, offset);\n\t\t\tirq_dispose_mapping(irq);\n\t\t}\n\n\t\tirq_domain_remove(gc->irq.domain);\n\t}\n\n\tif (irqchip && !(irqchip->flags & IRQCHIP_IMMUTABLE)) {\n\t\tif (irqchip->irq_request_resources == gpiochip_irq_reqres) {\n\t\t\tirqchip->irq_request_resources = NULL;\n\t\t\tirqchip->irq_release_resources = NULL;\n\t\t}\n\t\tif (irqchip->irq_enable == gpiochip_irq_enable) {\n\t\t\tirqchip->irq_enable = gc->irq.irq_enable;\n\t\t\tirqchip->irq_disable = gc->irq.irq_disable;\n\t\t}\n\t}\n\tgc->irq.irq_enable = NULL;\n\tgc->irq.irq_disable = NULL;\n\tgc->irq.chip = NULL;\n\n\tgpiochip_irqchip_free_valid_mask(gc);\n}\n\n \nint gpiochip_irqchip_add_domain(struct gpio_chip *gc,\n\t\t\t\tstruct irq_domain *domain)\n{\n\treturn gpiochip_irqchip_add_allocated_domain(gc, domain, true);\n}\nEXPORT_SYMBOL_GPL(gpiochip_irqchip_add_domain);\n\n#else  \n\nstatic inline int gpiochip_add_irqchip(struct gpio_chip *gc,\n\t\t\t\t       struct lock_class_key *lock_key,\n\t\t\t\t       struct lock_class_key *request_key)\n{\n\treturn 0;\n}\nstatic void gpiochip_irqchip_remove(struct gpio_chip *gc) {}\n\nstatic inline int gpiochip_irqchip_init_hw(struct gpio_chip *gc)\n{\n\treturn 0;\n}\n\nstatic inline int gpiochip_irqchip_init_valid_mask(struct gpio_chip *gc)\n{\n\treturn 0;\n}\nstatic inline void gpiochip_irqchip_free_valid_mask(struct gpio_chip *gc)\n{ }\n\n#endif  \n\n \nint gpiochip_generic_request(struct gpio_chip *gc, unsigned int offset)\n{\n#ifdef CONFIG_PINCTRL\n\tif (list_empty(&gc->gpiodev->pin_ranges))\n\t\treturn 0;\n#endif\n\n\treturn pinctrl_gpio_request(gc->gpiodev->base + offset);\n}\nEXPORT_SYMBOL_GPL(gpiochip_generic_request);\n\n \nvoid gpiochip_generic_free(struct gpio_chip *gc, unsigned int offset)\n{\n#ifdef CONFIG_PINCTRL\n\tif (list_empty(&gc->gpiodev->pin_ranges))\n\t\treturn;\n#endif\n\n\tpinctrl_gpio_free(gc->gpiodev->base + offset);\n}\nEXPORT_SYMBOL_GPL(gpiochip_generic_free);\n\n \nint gpiochip_generic_config(struct gpio_chip *gc, unsigned int offset,\n\t\t\t    unsigned long config)\n{\n\treturn pinctrl_gpio_set_config(gc->gpiodev->base + offset, config);\n}\nEXPORT_SYMBOL_GPL(gpiochip_generic_config);\n\n#ifdef CONFIG_PINCTRL\n\n \nint gpiochip_add_pingroup_range(struct gpio_chip *gc,\n\t\t\tstruct pinctrl_dev *pctldev,\n\t\t\tunsigned int gpio_offset, const char *pin_group)\n{\n\tstruct gpio_pin_range *pin_range;\n\tstruct gpio_device *gdev = gc->gpiodev;\n\tint ret;\n\n\tpin_range = kzalloc(sizeof(*pin_range), GFP_KERNEL);\n\tif (!pin_range) {\n\t\tchip_err(gc, \"failed to allocate pin ranges\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpin_range->range.id = gpio_offset;\n\tpin_range->range.gc = gc;\n\tpin_range->range.name = gc->label;\n\tpin_range->range.base = gdev->base + gpio_offset;\n\tpin_range->pctldev = pctldev;\n\n\tret = pinctrl_get_group_pins(pctldev, pin_group,\n\t\t\t\t\t&pin_range->range.pins,\n\t\t\t\t\t&pin_range->range.npins);\n\tif (ret < 0) {\n\t\tkfree(pin_range);\n\t\treturn ret;\n\t}\n\n\tpinctrl_add_gpio_range(pctldev, &pin_range->range);\n\n\tchip_dbg(gc, \"created GPIO range %d->%d ==> %s PINGRP %s\\n\",\n\t\t gpio_offset, gpio_offset + pin_range->range.npins - 1,\n\t\t pinctrl_dev_get_devname(pctldev), pin_group);\n\n\tlist_add_tail(&pin_range->node, &gdev->pin_ranges);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gpiochip_add_pingroup_range);\n\n \nint gpiochip_add_pin_range(struct gpio_chip *gc, const char *pinctl_name,\n\t\t\t   unsigned int gpio_offset, unsigned int pin_offset,\n\t\t\t   unsigned int npins)\n{\n\tstruct gpio_pin_range *pin_range;\n\tstruct gpio_device *gdev = gc->gpiodev;\n\tint ret;\n\n\tpin_range = kzalloc(sizeof(*pin_range), GFP_KERNEL);\n\tif (!pin_range) {\n\t\tchip_err(gc, \"failed to allocate pin ranges\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpin_range->range.id = gpio_offset;\n\tpin_range->range.gc = gc;\n\tpin_range->range.name = gc->label;\n\tpin_range->range.base = gdev->base + gpio_offset;\n\tpin_range->range.pin_base = pin_offset;\n\tpin_range->range.npins = npins;\n\tpin_range->pctldev = pinctrl_find_and_add_gpio_range(pinctl_name,\n\t\t\t&pin_range->range);\n\tif (IS_ERR(pin_range->pctldev)) {\n\t\tret = PTR_ERR(pin_range->pctldev);\n\t\tchip_err(gc, \"could not create pin range\\n\");\n\t\tkfree(pin_range);\n\t\treturn ret;\n\t}\n\tchip_dbg(gc, \"created GPIO range %d->%d ==> %s PIN %d->%d\\n\",\n\t\t gpio_offset, gpio_offset + npins - 1,\n\t\t pinctl_name,\n\t\t pin_offset, pin_offset + npins - 1);\n\n\tlist_add_tail(&pin_range->node, &gdev->pin_ranges);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gpiochip_add_pin_range);\n\n \nvoid gpiochip_remove_pin_ranges(struct gpio_chip *gc)\n{\n\tstruct gpio_pin_range *pin_range, *tmp;\n\tstruct gpio_device *gdev = gc->gpiodev;\n\n\tlist_for_each_entry_safe(pin_range, tmp, &gdev->pin_ranges, node) {\n\t\tlist_del(&pin_range->node);\n\t\tpinctrl_remove_gpio_range(pin_range->pctldev,\n\t\t\t\t&pin_range->range);\n\t\tkfree(pin_range);\n\t}\n}\nEXPORT_SYMBOL_GPL(gpiochip_remove_pin_ranges);\n\n#endif  \n\n \nstatic int gpiod_request_commit(struct gpio_desc *desc, const char *label)\n{\n\tstruct gpio_chip\t*gc = desc->gdev->chip;\n\tint\t\t\tret;\n\tunsigned long\t\tflags;\n\tunsigned\t\toffset;\n\n\tif (label) {\n\t\tlabel = kstrdup_const(label, GFP_KERNEL);\n\t\tif (!label)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\n\t \n\n\tif (test_and_set_bit(FLAG_REQUESTED, &desc->flags) == 0) {\n\t\tdesc_set_label(desc, label ? : \"?\");\n\t} else {\n\t\tret = -EBUSY;\n\t\tgoto out_free_unlock;\n\t}\n\n\tif (gc->request) {\n\t\t \n\t\tspin_unlock_irqrestore(&gpio_lock, flags);\n\t\toffset = gpio_chip_hwgpio(desc);\n\t\tif (gpiochip_line_is_valid(gc, offset))\n\t\t\tret = gc->request(gc, offset);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tspin_lock_irqsave(&gpio_lock, flags);\n\n\t\tif (ret) {\n\t\t\tdesc_set_label(desc, NULL);\n\t\t\tclear_bit(FLAG_REQUESTED, &desc->flags);\n\t\t\tgoto out_free_unlock;\n\t\t}\n\t}\n\tif (gc->get_direction) {\n\t\t \n\t\tspin_unlock_irqrestore(&gpio_lock, flags);\n\t\tgpiod_get_direction(desc);\n\t\tspin_lock_irqsave(&gpio_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\treturn 0;\n\nout_free_unlock:\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\tkfree_const(label);\n\treturn ret;\n}\n\n \nstatic int validate_desc(const struct gpio_desc *desc, const char *func)\n{\n\tif (!desc)\n\t\treturn 0;\n\tif (IS_ERR(desc)) {\n\t\tpr_warn(\"%s: invalid GPIO (errorpointer)\\n\", func);\n\t\treturn PTR_ERR(desc);\n\t}\n\tif (!desc->gdev) {\n\t\tpr_warn(\"%s: invalid GPIO (no device)\\n\", func);\n\t\treturn -EINVAL;\n\t}\n\tif (!desc->gdev->chip) {\n\t\tdev_warn(&desc->gdev->dev,\n\t\t\t \"%s: backing chip is gone\\n\", func);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n#define VALIDATE_DESC(desc) do { \\\n\tint __valid = validate_desc(desc, __func__); \\\n\tif (__valid <= 0) \\\n\t\treturn __valid; \\\n\t} while (0)\n\n#define VALIDATE_DESC_VOID(desc) do { \\\n\tint __valid = validate_desc(desc, __func__); \\\n\tif (__valid <= 0) \\\n\t\treturn; \\\n\t} while (0)\n\nint gpiod_request(struct gpio_desc *desc, const char *label)\n{\n\tint ret = -EPROBE_DEFER;\n\n\tVALIDATE_DESC(desc);\n\n\tif (try_module_get(desc->gdev->owner)) {\n\t\tret = gpiod_request_commit(desc, label);\n\t\tif (ret)\n\t\t\tmodule_put(desc->gdev->owner);\n\t\telse\n\t\t\tgpio_device_get(desc->gdev);\n\t}\n\n\tif (ret)\n\t\tgpiod_dbg(desc, \"%s: status %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic bool gpiod_free_commit(struct gpio_desc *desc)\n{\n\tbool\t\t\tret = false;\n\tunsigned long\t\tflags;\n\tstruct gpio_chip\t*gc;\n\n\tmight_sleep();\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\n\tgc = desc->gdev->chip;\n\tif (gc && test_bit(FLAG_REQUESTED, &desc->flags)) {\n\t\tif (gc->free) {\n\t\t\tspin_unlock_irqrestore(&gpio_lock, flags);\n\t\t\tmight_sleep_if(gc->can_sleep);\n\t\t\tgc->free(gc, gpio_chip_hwgpio(desc));\n\t\t\tspin_lock_irqsave(&gpio_lock, flags);\n\t\t}\n\t\tkfree_const(desc->label);\n\t\tdesc_set_label(desc, NULL);\n\t\tclear_bit(FLAG_ACTIVE_LOW, &desc->flags);\n\t\tclear_bit(FLAG_REQUESTED, &desc->flags);\n\t\tclear_bit(FLAG_OPEN_DRAIN, &desc->flags);\n\t\tclear_bit(FLAG_OPEN_SOURCE, &desc->flags);\n\t\tclear_bit(FLAG_PULL_UP, &desc->flags);\n\t\tclear_bit(FLAG_PULL_DOWN, &desc->flags);\n\t\tclear_bit(FLAG_BIAS_DISABLE, &desc->flags);\n\t\tclear_bit(FLAG_EDGE_RISING, &desc->flags);\n\t\tclear_bit(FLAG_EDGE_FALLING, &desc->flags);\n\t\tclear_bit(FLAG_IS_HOGGED, &desc->flags);\n#ifdef CONFIG_OF_DYNAMIC\n\t\tdesc->hog = NULL;\n#endif\n#ifdef CONFIG_GPIO_CDEV\n\t\tWRITE_ONCE(desc->debounce_period_us, 0);\n#endif\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\tgpiod_line_state_notify(desc, GPIOLINE_CHANGED_RELEASED);\n\n\treturn ret;\n}\n\nvoid gpiod_free(struct gpio_desc *desc)\n{\n\t \n\tif (!desc)\n\t\treturn;\n\n\tif (!gpiod_free_commit(desc))\n\t\tWARN_ON(extra_checks);\n\n\tmodule_put(desc->gdev->owner);\n\tgpio_device_put(desc->gdev);\n}\n\n \nconst char *gpiochip_is_requested(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_desc *desc;\n\n\tdesc = gpiochip_get_desc(gc, offset);\n\tif (IS_ERR(desc))\n\t\treturn NULL;\n\n\tif (test_bit(FLAG_REQUESTED, &desc->flags) == 0)\n\t\treturn NULL;\n\treturn desc->label;\n}\nEXPORT_SYMBOL_GPL(gpiochip_is_requested);\n\n \nstruct gpio_desc *gpiochip_request_own_desc(struct gpio_chip *gc,\n\t\t\t\t\t    unsigned int hwnum,\n\t\t\t\t\t    const char *label,\n\t\t\t\t\t    enum gpio_lookup_flags lflags,\n\t\t\t\t\t    enum gpiod_flags dflags)\n{\n\tstruct gpio_desc *desc = gpiochip_get_desc(gc, hwnum);\n\tint ret;\n\n\tif (IS_ERR(desc)) {\n\t\tchip_err(gc, \"failed to get GPIO descriptor\\n\");\n\t\treturn desc;\n\t}\n\n\tret = gpiod_request_commit(desc, label);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tret = gpiod_configure_flags(desc, label, lflags, dflags);\n\tif (ret) {\n\t\tchip_err(gc, \"setup of own GPIO %s failed\\n\", label);\n\t\tgpiod_free_commit(desc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn desc;\n}\nEXPORT_SYMBOL_GPL(gpiochip_request_own_desc);\n\n \nvoid gpiochip_free_own_desc(struct gpio_desc *desc)\n{\n\tif (desc)\n\t\tgpiod_free_commit(desc);\n}\nEXPORT_SYMBOL_GPL(gpiochip_free_own_desc);\n\n \n\nstatic int gpio_do_set_config(struct gpio_chip *gc, unsigned int offset,\n\t\t\t      unsigned long config)\n{\n\tif (!gc->set_config)\n\t\treturn -ENOTSUPP;\n\n\treturn gc->set_config(gc, offset, config);\n}\n\nstatic int gpio_set_config_with_argument(struct gpio_desc *desc,\n\t\t\t\t\t enum pin_config_param mode,\n\t\t\t\t\t u32 argument)\n{\n\tstruct gpio_chip *gc = desc->gdev->chip;\n\tunsigned long config;\n\n\tconfig = pinconf_to_config_packed(mode, argument);\n\treturn gpio_do_set_config(gc, gpio_chip_hwgpio(desc), config);\n}\n\nstatic int gpio_set_config_with_argument_optional(struct gpio_desc *desc,\n\t\t\t\t\t\t  enum pin_config_param mode,\n\t\t\t\t\t\t  u32 argument)\n{\n\tstruct device *dev = &desc->gdev->dev;\n\tint gpio = gpio_chip_hwgpio(desc);\n\tint ret;\n\n\tret = gpio_set_config_with_argument(desc, mode, argument);\n\tif (ret != -ENOTSUPP)\n\t\treturn ret;\n\n\tswitch (mode) {\n\tcase PIN_CONFIG_PERSIST_STATE:\n\t\tdev_dbg(dev, \"Persistence not supported for GPIO %d\\n\", gpio);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int gpio_set_config(struct gpio_desc *desc, enum pin_config_param mode)\n{\n\treturn gpio_set_config_with_argument(desc, mode, 0);\n}\n\nstatic int gpio_set_bias(struct gpio_desc *desc)\n{\n\tenum pin_config_param bias;\n\tunsigned int arg;\n\n\tif (test_bit(FLAG_BIAS_DISABLE, &desc->flags))\n\t\tbias = PIN_CONFIG_BIAS_DISABLE;\n\telse if (test_bit(FLAG_PULL_UP, &desc->flags))\n\t\tbias = PIN_CONFIG_BIAS_PULL_UP;\n\telse if (test_bit(FLAG_PULL_DOWN, &desc->flags))\n\t\tbias = PIN_CONFIG_BIAS_PULL_DOWN;\n\telse\n\t\treturn 0;\n\n\tswitch (bias) {\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\targ = 1;\n\t\tbreak;\n\n\tdefault:\n\t\targ = 0;\n\t\tbreak;\n\t}\n\n\treturn gpio_set_config_with_argument_optional(desc, bias, arg);\n}\n\n \nint gpio_set_debounce_timeout(struct gpio_desc *desc, unsigned int debounce)\n{\n\treturn gpio_set_config_with_argument_optional(desc,\n\t\t\t\t\t\t      PIN_CONFIG_INPUT_DEBOUNCE,\n\t\t\t\t\t\t      debounce);\n}\n\n \nint gpiod_direction_input(struct gpio_desc *desc)\n{\n\tstruct gpio_chip\t*gc;\n\tint\t\t\tret = 0;\n\n\tVALIDATE_DESC(desc);\n\tgc = desc->gdev->chip;\n\n\t \n\tif (!gc->get && gc->direction_input) {\n\t\tgpiod_warn(desc,\n\t\t\t   \"%s: missing get() but have direction_input()\\n\",\n\t\t\t   __func__);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (gc->direction_input) {\n\t\tret = gc->direction_input(gc, gpio_chip_hwgpio(desc));\n\t} else if (gc->get_direction &&\n\t\t  (gc->get_direction(gc, gpio_chip_hwgpio(desc)) != 1)) {\n\t\tgpiod_warn(desc,\n\t\t\t   \"%s: missing direction_input() operation and line is output\\n\",\n\t\t\t   __func__);\n\t\treturn -EIO;\n\t}\n\tif (ret == 0) {\n\t\tclear_bit(FLAG_IS_OUT, &desc->flags);\n\t\tret = gpio_set_bias(desc);\n\t}\n\n\ttrace_gpio_direction(desc_to_gpio(desc), 1, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gpiod_direction_input);\n\nstatic int gpiod_direction_output_raw_commit(struct gpio_desc *desc, int value)\n{\n\tstruct gpio_chip *gc = desc->gdev->chip;\n\tint val = !!value;\n\tint ret = 0;\n\n\t \n\tif (!gc->set && !gc->direction_output) {\n\t\tgpiod_warn(desc,\n\t\t\t   \"%s: missing set() and direction_output() operations\\n\",\n\t\t\t   __func__);\n\t\treturn -EIO;\n\t}\n\n\tif (gc->direction_output) {\n\t\tret = gc->direction_output(gc, gpio_chip_hwgpio(desc), val);\n\t} else {\n\t\t \n\t\tif (gc->get_direction &&\n\t\t    gc->get_direction(gc, gpio_chip_hwgpio(desc))) {\n\t\t\tgpiod_warn(desc,\n\t\t\t\t\"%s: missing direction_output() operation\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EIO;\n\t\t}\n\t\t \n\t\tgc->set(gc, gpio_chip_hwgpio(desc), val);\n\t}\n\n\tif (!ret)\n\t\tset_bit(FLAG_IS_OUT, &desc->flags);\n\ttrace_gpio_value(desc_to_gpio(desc), 0, val);\n\ttrace_gpio_direction(desc_to_gpio(desc), 0, ret);\n\treturn ret;\n}\n\n \nint gpiod_direction_output_raw(struct gpio_desc *desc, int value)\n{\n\tVALIDATE_DESC(desc);\n\treturn gpiod_direction_output_raw_commit(desc, value);\n}\nEXPORT_SYMBOL_GPL(gpiod_direction_output_raw);\n\n \nint gpiod_direction_output(struct gpio_desc *desc, int value)\n{\n\tint ret;\n\n\tVALIDATE_DESC(desc);\n\tif (test_bit(FLAG_ACTIVE_LOW, &desc->flags))\n\t\tvalue = !value;\n\telse\n\t\tvalue = !!value;\n\n\t \n\tif (test_bit(FLAG_USED_AS_IRQ, &desc->flags) &&\n\t    test_bit(FLAG_IRQ_IS_ENABLED, &desc->flags)) {\n\t\tgpiod_err(desc,\n\t\t\t  \"%s: tried to set a GPIO tied to an IRQ as output\\n\",\n\t\t\t  __func__);\n\t\treturn -EIO;\n\t}\n\n\tif (test_bit(FLAG_OPEN_DRAIN, &desc->flags)) {\n\t\t \n\t\tret = gpio_set_config(desc, PIN_CONFIG_DRIVE_OPEN_DRAIN);\n\t\tif (!ret)\n\t\t\tgoto set_output_value;\n\t\t \n\t\tif (value) {\n\t\t\tret = gpiod_direction_input(desc);\n\t\t\tgoto set_output_flag;\n\t\t}\n\t} else if (test_bit(FLAG_OPEN_SOURCE, &desc->flags)) {\n\t\tret = gpio_set_config(desc, PIN_CONFIG_DRIVE_OPEN_SOURCE);\n\t\tif (!ret)\n\t\t\tgoto set_output_value;\n\t\t \n\t\tif (!value) {\n\t\t\tret = gpiod_direction_input(desc);\n\t\t\tgoto set_output_flag;\n\t\t}\n\t} else {\n\t\tgpio_set_config(desc, PIN_CONFIG_DRIVE_PUSH_PULL);\n\t}\n\nset_output_value:\n\tret = gpio_set_bias(desc);\n\tif (ret)\n\t\treturn ret;\n\treturn gpiod_direction_output_raw_commit(desc, value);\n\nset_output_flag:\n\t \n\tif (ret == 0)\n\t\tset_bit(FLAG_IS_OUT, &desc->flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gpiod_direction_output);\n\n \nint gpiod_enable_hw_timestamp_ns(struct gpio_desc *desc, unsigned long flags)\n{\n\tint ret = 0;\n\tstruct gpio_chip *gc;\n\n\tVALIDATE_DESC(desc);\n\n\tgc = desc->gdev->chip;\n\tif (!gc->en_hw_timestamp) {\n\t\tgpiod_warn(desc, \"%s: hw ts not supported\\n\", __func__);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tret = gc->en_hw_timestamp(gc, gpio_chip_hwgpio(desc), flags);\n\tif (ret)\n\t\tgpiod_warn(desc, \"%s: hw ts request failed\\n\", __func__);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gpiod_enable_hw_timestamp_ns);\n\n \nint gpiod_disable_hw_timestamp_ns(struct gpio_desc *desc, unsigned long flags)\n{\n\tint ret = 0;\n\tstruct gpio_chip *gc;\n\n\tVALIDATE_DESC(desc);\n\n\tgc = desc->gdev->chip;\n\tif (!gc->dis_hw_timestamp) {\n\t\tgpiod_warn(desc, \"%s: hw ts not supported\\n\", __func__);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tret = gc->dis_hw_timestamp(gc, gpio_chip_hwgpio(desc), flags);\n\tif (ret)\n\t\tgpiod_warn(desc, \"%s: hw ts release failed\\n\", __func__);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gpiod_disable_hw_timestamp_ns);\n\n \nint gpiod_set_config(struct gpio_desc *desc, unsigned long config)\n{\n\tstruct gpio_chip *gc;\n\n\tVALIDATE_DESC(desc);\n\tgc = desc->gdev->chip;\n\n\treturn gpio_do_set_config(gc, gpio_chip_hwgpio(desc), config);\n}\nEXPORT_SYMBOL_GPL(gpiod_set_config);\n\n \nint gpiod_set_debounce(struct gpio_desc *desc, unsigned int debounce)\n{\n\tunsigned long config;\n\n\tconfig = pinconf_to_config_packed(PIN_CONFIG_INPUT_DEBOUNCE, debounce);\n\treturn gpiod_set_config(desc, config);\n}\nEXPORT_SYMBOL_GPL(gpiod_set_debounce);\n\n \nint gpiod_set_transitory(struct gpio_desc *desc, bool transitory)\n{\n\tVALIDATE_DESC(desc);\n\t \n\tassign_bit(FLAG_TRANSITORY, &desc->flags, transitory);\n\n\t \n\treturn gpio_set_config_with_argument_optional(desc,\n\t\t\t\t\t\t      PIN_CONFIG_PERSIST_STATE,\n\t\t\t\t\t\t      !transitory);\n}\nEXPORT_SYMBOL_GPL(gpiod_set_transitory);\n\n \nint gpiod_is_active_low(const struct gpio_desc *desc)\n{\n\tVALIDATE_DESC(desc);\n\treturn test_bit(FLAG_ACTIVE_LOW, &desc->flags);\n}\nEXPORT_SYMBOL_GPL(gpiod_is_active_low);\n\n \nvoid gpiod_toggle_active_low(struct gpio_desc *desc)\n{\n\tVALIDATE_DESC_VOID(desc);\n\tchange_bit(FLAG_ACTIVE_LOW, &desc->flags);\n}\nEXPORT_SYMBOL_GPL(gpiod_toggle_active_low);\n\nstatic int gpio_chip_get_value(struct gpio_chip *gc, const struct gpio_desc *desc)\n{\n\treturn gc->get ? gc->get(gc, gpio_chip_hwgpio(desc)) : -EIO;\n}\n\n \n\nstatic int gpiod_get_raw_value_commit(const struct gpio_desc *desc)\n{\n\tstruct gpio_chip\t*gc;\n\tint value;\n\n\tgc = desc->gdev->chip;\n\tvalue = gpio_chip_get_value(gc, desc);\n\tvalue = value < 0 ? value : !!value;\n\ttrace_gpio_value(desc_to_gpio(desc), 1, value);\n\treturn value;\n}\n\nstatic int gpio_chip_get_multiple(struct gpio_chip *gc,\n\t\t\t\t  unsigned long *mask, unsigned long *bits)\n{\n\tif (gc->get_multiple)\n\t\treturn gc->get_multiple(gc, mask, bits);\n\tif (gc->get) {\n\t\tint i, value;\n\n\t\tfor_each_set_bit(i, mask, gc->ngpio) {\n\t\t\tvalue = gc->get(gc, i);\n\t\t\tif (value < 0)\n\t\t\t\treturn value;\n\t\t\t__assign_bit(i, bits, value);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\nint gpiod_get_array_value_complex(bool raw, bool can_sleep,\n\t\t\t\t  unsigned int array_size,\n\t\t\t\t  struct gpio_desc **desc_array,\n\t\t\t\t  struct gpio_array *array_info,\n\t\t\t\t  unsigned long *value_bitmap)\n{\n\tint ret, i = 0;\n\n\t \n\tif (array_info && array_info->desc == desc_array &&\n\t    array_size <= array_info->size &&\n\t    (void *)array_info == desc_array + array_info->size) {\n\t\tif (!can_sleep)\n\t\t\tWARN_ON(array_info->chip->can_sleep);\n\n\t\tret = gpio_chip_get_multiple(array_info->chip,\n\t\t\t\t\t     array_info->get_mask,\n\t\t\t\t\t     value_bitmap);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!raw && !bitmap_empty(array_info->invert_mask, array_size))\n\t\t\tbitmap_xor(value_bitmap, value_bitmap,\n\t\t\t\t   array_info->invert_mask, array_size);\n\n\t\ti = find_first_zero_bit(array_info->get_mask, array_size);\n\t\tif (i == array_size)\n\t\t\treturn 0;\n\t} else {\n\t\tarray_info = NULL;\n\t}\n\n\twhile (i < array_size) {\n\t\tstruct gpio_chip *gc = desc_array[i]->gdev->chip;\n\t\tDECLARE_BITMAP(fastpath_mask, FASTPATH_NGPIO);\n\t\tDECLARE_BITMAP(fastpath_bits, FASTPATH_NGPIO);\n\t\tunsigned long *mask, *bits;\n\t\tint first, j;\n\n\t\tif (likely(gc->ngpio <= FASTPATH_NGPIO)) {\n\t\t\tmask = fastpath_mask;\n\t\t\tbits = fastpath_bits;\n\t\t} else {\n\t\t\tgfp_t flags = can_sleep ? GFP_KERNEL : GFP_ATOMIC;\n\n\t\t\tmask = bitmap_alloc(gc->ngpio, flags);\n\t\t\tif (!mask)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbits = bitmap_alloc(gc->ngpio, flags);\n\t\t\tif (!bits) {\n\t\t\t\tbitmap_free(mask);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tbitmap_zero(mask, gc->ngpio);\n\n\t\tif (!can_sleep)\n\t\t\tWARN_ON(gc->can_sleep);\n\n\t\t \n\t\tfirst = i;\n\t\tdo {\n\t\t\tconst struct gpio_desc *desc = desc_array[i];\n\t\t\tint hwgpio = gpio_chip_hwgpio(desc);\n\n\t\t\t__set_bit(hwgpio, mask);\n\t\t\ti++;\n\n\t\t\tif (array_info)\n\t\t\t\ti = find_next_zero_bit(array_info->get_mask,\n\t\t\t\t\t\t       array_size, i);\n\t\t} while ((i < array_size) &&\n\t\t\t (desc_array[i]->gdev->chip == gc));\n\n\t\tret = gpio_chip_get_multiple(gc, mask, bits);\n\t\tif (ret) {\n\t\t\tif (mask != fastpath_mask)\n\t\t\t\tbitmap_free(mask);\n\t\t\tif (bits != fastpath_bits)\n\t\t\t\tbitmap_free(bits);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (j = first; j < i; ) {\n\t\t\tconst struct gpio_desc *desc = desc_array[j];\n\t\t\tint hwgpio = gpio_chip_hwgpio(desc);\n\t\t\tint value = test_bit(hwgpio, bits);\n\n\t\t\tif (!raw && test_bit(FLAG_ACTIVE_LOW, &desc->flags))\n\t\t\t\tvalue = !value;\n\t\t\t__assign_bit(j, value_bitmap, value);\n\t\t\ttrace_gpio_value(desc_to_gpio(desc), 1, value);\n\t\t\tj++;\n\n\t\t\tif (array_info)\n\t\t\t\tj = find_next_zero_bit(array_info->get_mask, i,\n\t\t\t\t\t\t       j);\n\t\t}\n\n\t\tif (mask != fastpath_mask)\n\t\t\tbitmap_free(mask);\n\t\tif (bits != fastpath_bits)\n\t\t\tbitmap_free(bits);\n\t}\n\treturn 0;\n}\n\n \nint gpiod_get_raw_value(const struct gpio_desc *desc)\n{\n\tVALIDATE_DESC(desc);\n\t \n\tWARN_ON(desc->gdev->chip->can_sleep);\n\treturn gpiod_get_raw_value_commit(desc);\n}\nEXPORT_SYMBOL_GPL(gpiod_get_raw_value);\n\n \nint gpiod_get_value(const struct gpio_desc *desc)\n{\n\tint value;\n\n\tVALIDATE_DESC(desc);\n\t \n\tWARN_ON(desc->gdev->chip->can_sleep);\n\n\tvalue = gpiod_get_raw_value_commit(desc);\n\tif (value < 0)\n\t\treturn value;\n\n\tif (test_bit(FLAG_ACTIVE_LOW, &desc->flags))\n\t\tvalue = !value;\n\n\treturn value;\n}\nEXPORT_SYMBOL_GPL(gpiod_get_value);\n\n \nint gpiod_get_raw_array_value(unsigned int array_size,\n\t\t\t      struct gpio_desc **desc_array,\n\t\t\t      struct gpio_array *array_info,\n\t\t\t      unsigned long *value_bitmap)\n{\n\tif (!desc_array)\n\t\treturn -EINVAL;\n\treturn gpiod_get_array_value_complex(true, false, array_size,\n\t\t\t\t\t     desc_array, array_info,\n\t\t\t\t\t     value_bitmap);\n}\nEXPORT_SYMBOL_GPL(gpiod_get_raw_array_value);\n\n \nint gpiod_get_array_value(unsigned int array_size,\n\t\t\t  struct gpio_desc **desc_array,\n\t\t\t  struct gpio_array *array_info,\n\t\t\t  unsigned long *value_bitmap)\n{\n\tif (!desc_array)\n\t\treturn -EINVAL;\n\treturn gpiod_get_array_value_complex(false, false, array_size,\n\t\t\t\t\t     desc_array, array_info,\n\t\t\t\t\t     value_bitmap);\n}\nEXPORT_SYMBOL_GPL(gpiod_get_array_value);\n\n \nstatic void gpio_set_open_drain_value_commit(struct gpio_desc *desc, bool value)\n{\n\tint ret = 0;\n\tstruct gpio_chip *gc = desc->gdev->chip;\n\tint offset = gpio_chip_hwgpio(desc);\n\n\tif (value) {\n\t\tret = gc->direction_input(gc, offset);\n\t} else {\n\t\tret = gc->direction_output(gc, offset, 0);\n\t\tif (!ret)\n\t\t\tset_bit(FLAG_IS_OUT, &desc->flags);\n\t}\n\ttrace_gpio_direction(desc_to_gpio(desc), value, ret);\n\tif (ret < 0)\n\t\tgpiod_err(desc,\n\t\t\t  \"%s: Error in set_value for open drain err %d\\n\",\n\t\t\t  __func__, ret);\n}\n\n \nstatic void gpio_set_open_source_value_commit(struct gpio_desc *desc, bool value)\n{\n\tint ret = 0;\n\tstruct gpio_chip *gc = desc->gdev->chip;\n\tint offset = gpio_chip_hwgpio(desc);\n\n\tif (value) {\n\t\tret = gc->direction_output(gc, offset, 1);\n\t\tif (!ret)\n\t\t\tset_bit(FLAG_IS_OUT, &desc->flags);\n\t} else {\n\t\tret = gc->direction_input(gc, offset);\n\t}\n\ttrace_gpio_direction(desc_to_gpio(desc), !value, ret);\n\tif (ret < 0)\n\t\tgpiod_err(desc,\n\t\t\t  \"%s: Error in set_value for open source err %d\\n\",\n\t\t\t  __func__, ret);\n}\n\nstatic void gpiod_set_raw_value_commit(struct gpio_desc *desc, bool value)\n{\n\tstruct gpio_chip\t*gc;\n\n\tgc = desc->gdev->chip;\n\ttrace_gpio_value(desc_to_gpio(desc), 0, value);\n\tgc->set(gc, gpio_chip_hwgpio(desc), value);\n}\n\n \nstatic void gpio_chip_set_multiple(struct gpio_chip *gc,\n\t\t\t\t   unsigned long *mask, unsigned long *bits)\n{\n\tif (gc->set_multiple) {\n\t\tgc->set_multiple(gc, mask, bits);\n\t} else {\n\t\tunsigned int i;\n\n\t\t \n\t\tfor_each_set_bit(i, mask, gc->ngpio)\n\t\t\tgc->set(gc, i, test_bit(i, bits));\n\t}\n}\n\nint gpiod_set_array_value_complex(bool raw, bool can_sleep,\n\t\t\t\t  unsigned int array_size,\n\t\t\t\t  struct gpio_desc **desc_array,\n\t\t\t\t  struct gpio_array *array_info,\n\t\t\t\t  unsigned long *value_bitmap)\n{\n\tint i = 0;\n\n\t \n\tif (array_info && array_info->desc == desc_array &&\n\t    array_size <= array_info->size &&\n\t    (void *)array_info == desc_array + array_info->size) {\n\t\tif (!can_sleep)\n\t\t\tWARN_ON(array_info->chip->can_sleep);\n\n\t\tif (!raw && !bitmap_empty(array_info->invert_mask, array_size))\n\t\t\tbitmap_xor(value_bitmap, value_bitmap,\n\t\t\t\t   array_info->invert_mask, array_size);\n\n\t\tgpio_chip_set_multiple(array_info->chip, array_info->set_mask,\n\t\t\t\t       value_bitmap);\n\n\t\ti = find_first_zero_bit(array_info->set_mask, array_size);\n\t\tif (i == array_size)\n\t\t\treturn 0;\n\t} else {\n\t\tarray_info = NULL;\n\t}\n\n\twhile (i < array_size) {\n\t\tstruct gpio_chip *gc = desc_array[i]->gdev->chip;\n\t\tDECLARE_BITMAP(fastpath_mask, FASTPATH_NGPIO);\n\t\tDECLARE_BITMAP(fastpath_bits, FASTPATH_NGPIO);\n\t\tunsigned long *mask, *bits;\n\t\tint count = 0;\n\n\t\tif (likely(gc->ngpio <= FASTPATH_NGPIO)) {\n\t\t\tmask = fastpath_mask;\n\t\t\tbits = fastpath_bits;\n\t\t} else {\n\t\t\tgfp_t flags = can_sleep ? GFP_KERNEL : GFP_ATOMIC;\n\n\t\t\tmask = bitmap_alloc(gc->ngpio, flags);\n\t\t\tif (!mask)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbits = bitmap_alloc(gc->ngpio, flags);\n\t\t\tif (!bits) {\n\t\t\t\tbitmap_free(mask);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tbitmap_zero(mask, gc->ngpio);\n\n\t\tif (!can_sleep)\n\t\t\tWARN_ON(gc->can_sleep);\n\n\t\tdo {\n\t\t\tstruct gpio_desc *desc = desc_array[i];\n\t\t\tint hwgpio = gpio_chip_hwgpio(desc);\n\t\t\tint value = test_bit(i, value_bitmap);\n\n\t\t\t \n\t\t\tif (!raw && !(array_info &&\n\t\t\t    test_bit(i, array_info->invert_mask)) &&\n\t\t\t    test_bit(FLAG_ACTIVE_LOW, &desc->flags))\n\t\t\t\tvalue = !value;\n\t\t\ttrace_gpio_value(desc_to_gpio(desc), 0, value);\n\t\t\t \n\t\t\tif (test_bit(FLAG_OPEN_DRAIN, &desc->flags) && !raw) {\n\t\t\t\tgpio_set_open_drain_value_commit(desc, value);\n\t\t\t} else if (test_bit(FLAG_OPEN_SOURCE, &desc->flags) && !raw) {\n\t\t\t\tgpio_set_open_source_value_commit(desc, value);\n\t\t\t} else {\n\t\t\t\t__set_bit(hwgpio, mask);\n\t\t\t\t__assign_bit(hwgpio, bits, value);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ti++;\n\n\t\t\tif (array_info)\n\t\t\t\ti = find_next_zero_bit(array_info->set_mask,\n\t\t\t\t\t\t       array_size, i);\n\t\t} while ((i < array_size) &&\n\t\t\t (desc_array[i]->gdev->chip == gc));\n\t\t \n\t\tif (count != 0)\n\t\t\tgpio_chip_set_multiple(gc, mask, bits);\n\n\t\tif (mask != fastpath_mask)\n\t\t\tbitmap_free(mask);\n\t\tif (bits != fastpath_bits)\n\t\t\tbitmap_free(bits);\n\t}\n\treturn 0;\n}\n\n \nvoid gpiod_set_raw_value(struct gpio_desc *desc, int value)\n{\n\tVALIDATE_DESC_VOID(desc);\n\t \n\tWARN_ON(desc->gdev->chip->can_sleep);\n\tgpiod_set_raw_value_commit(desc, value);\n}\nEXPORT_SYMBOL_GPL(gpiod_set_raw_value);\n\n \nstatic void gpiod_set_value_nocheck(struct gpio_desc *desc, int value)\n{\n\tif (test_bit(FLAG_ACTIVE_LOW, &desc->flags))\n\t\tvalue = !value;\n\tif (test_bit(FLAG_OPEN_DRAIN, &desc->flags))\n\t\tgpio_set_open_drain_value_commit(desc, value);\n\telse if (test_bit(FLAG_OPEN_SOURCE, &desc->flags))\n\t\tgpio_set_open_source_value_commit(desc, value);\n\telse\n\t\tgpiod_set_raw_value_commit(desc, value);\n}\n\n \nvoid gpiod_set_value(struct gpio_desc *desc, int value)\n{\n\tVALIDATE_DESC_VOID(desc);\n\t \n\tWARN_ON(desc->gdev->chip->can_sleep);\n\tgpiod_set_value_nocheck(desc, value);\n}\nEXPORT_SYMBOL_GPL(gpiod_set_value);\n\n \nint gpiod_set_raw_array_value(unsigned int array_size,\n\t\t\t      struct gpio_desc **desc_array,\n\t\t\t      struct gpio_array *array_info,\n\t\t\t      unsigned long *value_bitmap)\n{\n\tif (!desc_array)\n\t\treturn -EINVAL;\n\treturn gpiod_set_array_value_complex(true, false, array_size,\n\t\t\t\t\tdesc_array, array_info, value_bitmap);\n}\nEXPORT_SYMBOL_GPL(gpiod_set_raw_array_value);\n\n \nint gpiod_set_array_value(unsigned int array_size,\n\t\t\t  struct gpio_desc **desc_array,\n\t\t\t  struct gpio_array *array_info,\n\t\t\t  unsigned long *value_bitmap)\n{\n\tif (!desc_array)\n\t\treturn -EINVAL;\n\treturn gpiod_set_array_value_complex(false, false, array_size,\n\t\t\t\t\t     desc_array, array_info,\n\t\t\t\t\t     value_bitmap);\n}\nEXPORT_SYMBOL_GPL(gpiod_set_array_value);\n\n \nint gpiod_cansleep(const struct gpio_desc *desc)\n{\n\tVALIDATE_DESC(desc);\n\treturn desc->gdev->chip->can_sleep;\n}\nEXPORT_SYMBOL_GPL(gpiod_cansleep);\n\n \nint gpiod_set_consumer_name(struct gpio_desc *desc, const char *name)\n{\n\tVALIDATE_DESC(desc);\n\tif (name) {\n\t\tname = kstrdup_const(name, GFP_KERNEL);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tkfree_const(desc->label);\n\tdesc_set_label(desc, name);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gpiod_set_consumer_name);\n\n \nint gpiod_to_irq(const struct gpio_desc *desc)\n{\n\tstruct gpio_chip *gc;\n\tint offset;\n\n\t \n\tif (!desc || IS_ERR(desc) || !desc->gdev || !desc->gdev->chip)\n\t\treturn -EINVAL;\n\n\tgc = desc->gdev->chip;\n\toffset = gpio_chip_hwgpio(desc);\n\tif (gc->to_irq) {\n\t\tint retirq = gc->to_irq(gc, offset);\n\n\t\t \n\t\tif (!retirq)\n\t\t\treturn -ENXIO;\n\n\t\treturn retirq;\n\t}\n#ifdef CONFIG_GPIOLIB_IRQCHIP\n\tif (gc->irq.chip) {\n\t\t \n\t\treturn -EPROBE_DEFER;\n\t}\n#endif\n\treturn -ENXIO;\n}\nEXPORT_SYMBOL_GPL(gpiod_to_irq);\n\n \nint gpiochip_lock_as_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_desc *desc;\n\n\tdesc = gpiochip_get_desc(gc, offset);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\t \n\tif (!gc->can_sleep && gc->get_direction) {\n\t\tint dir = gpiod_get_direction(desc);\n\n\t\tif (dir < 0) {\n\t\t\tchip_err(gc, \"%s: cannot get GPIO direction\\n\",\n\t\t\t\t __func__);\n\t\t\treturn dir;\n\t\t}\n\t}\n\n\t \n\tif (test_bit(FLAG_IS_OUT, &desc->flags) &&\n\t    !test_bit(FLAG_OPEN_DRAIN, &desc->flags)) {\n\t\tchip_err(gc,\n\t\t\t \"%s: tried to flag a GPIO set as output for IRQ\\n\",\n\t\t\t __func__);\n\t\treturn -EIO;\n\t}\n\n\tset_bit(FLAG_USED_AS_IRQ, &desc->flags);\n\tset_bit(FLAG_IRQ_IS_ENABLED, &desc->flags);\n\n\t \n\tif (!desc->label)\n\t\tdesc_set_label(desc, \"interrupt\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gpiochip_lock_as_irq);\n\n \nvoid gpiochip_unlock_as_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_desc *desc;\n\n\tdesc = gpiochip_get_desc(gc, offset);\n\tif (IS_ERR(desc))\n\t\treturn;\n\n\tclear_bit(FLAG_USED_AS_IRQ, &desc->flags);\n\tclear_bit(FLAG_IRQ_IS_ENABLED, &desc->flags);\n\n\t \n\tif (desc->label && !strcmp(desc->label, \"interrupt\"))\n\t\tdesc_set_label(desc, NULL);\n}\nEXPORT_SYMBOL_GPL(gpiochip_unlock_as_irq);\n\nvoid gpiochip_disable_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_desc *desc = gpiochip_get_desc(gc, offset);\n\n\tif (!IS_ERR(desc) &&\n\t    !WARN_ON(!test_bit(FLAG_USED_AS_IRQ, &desc->flags)))\n\t\tclear_bit(FLAG_IRQ_IS_ENABLED, &desc->flags);\n}\nEXPORT_SYMBOL_GPL(gpiochip_disable_irq);\n\nvoid gpiochip_enable_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_desc *desc = gpiochip_get_desc(gc, offset);\n\n\tif (!IS_ERR(desc) &&\n\t    !WARN_ON(!test_bit(FLAG_USED_AS_IRQ, &desc->flags))) {\n\t\t \n\t\tWARN_ON(test_bit(FLAG_IS_OUT, &desc->flags) &&\n\t\t\t!test_bit(FLAG_OPEN_DRAIN, &desc->flags));\n\t\tset_bit(FLAG_IRQ_IS_ENABLED, &desc->flags);\n\t}\n}\nEXPORT_SYMBOL_GPL(gpiochip_enable_irq);\n\nbool gpiochip_line_is_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tif (offset >= gc->ngpio)\n\t\treturn false;\n\n\treturn test_bit(FLAG_USED_AS_IRQ, &gc->gpiodev->descs[offset].flags);\n}\nEXPORT_SYMBOL_GPL(gpiochip_line_is_irq);\n\nint gpiochip_reqres_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tint ret;\n\n\tif (!try_module_get(gc->gpiodev->owner))\n\t\treturn -ENODEV;\n\n\tret = gpiochip_lock_as_irq(gc, offset);\n\tif (ret) {\n\t\tchip_err(gc, \"unable to lock HW IRQ %u for IRQ\\n\", offset);\n\t\tmodule_put(gc->gpiodev->owner);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gpiochip_reqres_irq);\n\nvoid gpiochip_relres_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tgpiochip_unlock_as_irq(gc, offset);\n\tmodule_put(gc->gpiodev->owner);\n}\nEXPORT_SYMBOL_GPL(gpiochip_relres_irq);\n\nbool gpiochip_line_is_open_drain(struct gpio_chip *gc, unsigned int offset)\n{\n\tif (offset >= gc->ngpio)\n\t\treturn false;\n\n\treturn test_bit(FLAG_OPEN_DRAIN, &gc->gpiodev->descs[offset].flags);\n}\nEXPORT_SYMBOL_GPL(gpiochip_line_is_open_drain);\n\nbool gpiochip_line_is_open_source(struct gpio_chip *gc, unsigned int offset)\n{\n\tif (offset >= gc->ngpio)\n\t\treturn false;\n\n\treturn test_bit(FLAG_OPEN_SOURCE, &gc->gpiodev->descs[offset].flags);\n}\nEXPORT_SYMBOL_GPL(gpiochip_line_is_open_source);\n\nbool gpiochip_line_is_persistent(struct gpio_chip *gc, unsigned int offset)\n{\n\tif (offset >= gc->ngpio)\n\t\treturn false;\n\n\treturn !test_bit(FLAG_TRANSITORY, &gc->gpiodev->descs[offset].flags);\n}\nEXPORT_SYMBOL_GPL(gpiochip_line_is_persistent);\n\n \nint gpiod_get_raw_value_cansleep(const struct gpio_desc *desc)\n{\n\tmight_sleep_if(extra_checks);\n\tVALIDATE_DESC(desc);\n\treturn gpiod_get_raw_value_commit(desc);\n}\nEXPORT_SYMBOL_GPL(gpiod_get_raw_value_cansleep);\n\n \nint gpiod_get_value_cansleep(const struct gpio_desc *desc)\n{\n\tint value;\n\n\tmight_sleep_if(extra_checks);\n\tVALIDATE_DESC(desc);\n\tvalue = gpiod_get_raw_value_commit(desc);\n\tif (value < 0)\n\t\treturn value;\n\n\tif (test_bit(FLAG_ACTIVE_LOW, &desc->flags))\n\t\tvalue = !value;\n\n\treturn value;\n}\nEXPORT_SYMBOL_GPL(gpiod_get_value_cansleep);\n\n \nint gpiod_get_raw_array_value_cansleep(unsigned int array_size,\n\t\t\t\t       struct gpio_desc **desc_array,\n\t\t\t\t       struct gpio_array *array_info,\n\t\t\t\t       unsigned long *value_bitmap)\n{\n\tmight_sleep_if(extra_checks);\n\tif (!desc_array)\n\t\treturn -EINVAL;\n\treturn gpiod_get_array_value_complex(true, true, array_size,\n\t\t\t\t\t     desc_array, array_info,\n\t\t\t\t\t     value_bitmap);\n}\nEXPORT_SYMBOL_GPL(gpiod_get_raw_array_value_cansleep);\n\n \nint gpiod_get_array_value_cansleep(unsigned int array_size,\n\t\t\t\t   struct gpio_desc **desc_array,\n\t\t\t\t   struct gpio_array *array_info,\n\t\t\t\t   unsigned long *value_bitmap)\n{\n\tmight_sleep_if(extra_checks);\n\tif (!desc_array)\n\t\treturn -EINVAL;\n\treturn gpiod_get_array_value_complex(false, true, array_size,\n\t\t\t\t\t     desc_array, array_info,\n\t\t\t\t\t     value_bitmap);\n}\nEXPORT_SYMBOL_GPL(gpiod_get_array_value_cansleep);\n\n \nvoid gpiod_set_raw_value_cansleep(struct gpio_desc *desc, int value)\n{\n\tmight_sleep_if(extra_checks);\n\tVALIDATE_DESC_VOID(desc);\n\tgpiod_set_raw_value_commit(desc, value);\n}\nEXPORT_SYMBOL_GPL(gpiod_set_raw_value_cansleep);\n\n \nvoid gpiod_set_value_cansleep(struct gpio_desc *desc, int value)\n{\n\tmight_sleep_if(extra_checks);\n\tVALIDATE_DESC_VOID(desc);\n\tgpiod_set_value_nocheck(desc, value);\n}\nEXPORT_SYMBOL_GPL(gpiod_set_value_cansleep);\n\n \nint gpiod_set_raw_array_value_cansleep(unsigned int array_size,\n\t\t\t\t       struct gpio_desc **desc_array,\n\t\t\t\t       struct gpio_array *array_info,\n\t\t\t\t       unsigned long *value_bitmap)\n{\n\tmight_sleep_if(extra_checks);\n\tif (!desc_array)\n\t\treturn -EINVAL;\n\treturn gpiod_set_array_value_complex(true, true, array_size, desc_array,\n\t\t\t\t      array_info, value_bitmap);\n}\nEXPORT_SYMBOL_GPL(gpiod_set_raw_array_value_cansleep);\n\n \nvoid gpiod_add_lookup_tables(struct gpiod_lookup_table **tables, size_t n)\n{\n\tunsigned int i;\n\n\tmutex_lock(&gpio_lookup_lock);\n\n\tfor (i = 0; i < n; i++)\n\t\tlist_add_tail(&tables[i]->list, &gpio_lookup_list);\n\n\tmutex_unlock(&gpio_lookup_lock);\n}\n\n \nint gpiod_set_array_value_cansleep(unsigned int array_size,\n\t\t\t\t   struct gpio_desc **desc_array,\n\t\t\t\t   struct gpio_array *array_info,\n\t\t\t\t   unsigned long *value_bitmap)\n{\n\tmight_sleep_if(extra_checks);\n\tif (!desc_array)\n\t\treturn -EINVAL;\n\treturn gpiod_set_array_value_complex(false, true, array_size,\n\t\t\t\t\t     desc_array, array_info,\n\t\t\t\t\t     value_bitmap);\n}\nEXPORT_SYMBOL_GPL(gpiod_set_array_value_cansleep);\n\nvoid gpiod_line_state_notify(struct gpio_desc *desc, unsigned long action)\n{\n\tblocking_notifier_call_chain(&desc->gdev->line_state_notifier,\n\t\t\t\t     action, desc);\n}\n\n \nvoid gpiod_add_lookup_table(struct gpiod_lookup_table *table)\n{\n\tgpiod_add_lookup_tables(&table, 1);\n}\nEXPORT_SYMBOL_GPL(gpiod_add_lookup_table);\n\n \nvoid gpiod_remove_lookup_table(struct gpiod_lookup_table *table)\n{\n\t \n\tif (!table)\n\t\treturn;\n\n\tmutex_lock(&gpio_lookup_lock);\n\n\tlist_del(&table->list);\n\n\tmutex_unlock(&gpio_lookup_lock);\n}\nEXPORT_SYMBOL_GPL(gpiod_remove_lookup_table);\n\n \nvoid gpiod_add_hogs(struct gpiod_hog *hogs)\n{\n\tstruct gpio_chip *gc;\n\tstruct gpiod_hog *hog;\n\n\tmutex_lock(&gpio_machine_hogs_mutex);\n\n\tfor (hog = &hogs[0]; hog->chip_label; hog++) {\n\t\tlist_add_tail(&hog->list, &gpio_machine_hogs);\n\n\t\t \n\t\tgc = find_chip_by_name(hog->chip_label);\n\t\tif (gc)\n\t\t\tgpiochip_machine_hog(gc, hog);\n\t}\n\n\tmutex_unlock(&gpio_machine_hogs_mutex);\n}\nEXPORT_SYMBOL_GPL(gpiod_add_hogs);\n\nvoid gpiod_remove_hogs(struct gpiod_hog *hogs)\n{\n\tstruct gpiod_hog *hog;\n\n\tmutex_lock(&gpio_machine_hogs_mutex);\n\tfor (hog = &hogs[0]; hog->chip_label; hog++)\n\t\tlist_del(&hog->list);\n\tmutex_unlock(&gpio_machine_hogs_mutex);\n}\nEXPORT_SYMBOL_GPL(gpiod_remove_hogs);\n\nstatic struct gpiod_lookup_table *gpiod_find_lookup_table(struct device *dev)\n{\n\tconst char *dev_id = dev ? dev_name(dev) : NULL;\n\tstruct gpiod_lookup_table *table;\n\n\tmutex_lock(&gpio_lookup_lock);\n\n\tlist_for_each_entry(table, &gpio_lookup_list, list) {\n\t\tif (table->dev_id && dev_id) {\n\t\t\t \n\t\t\tif (!strcmp(table->dev_id, dev_id))\n\t\t\t\tgoto found;\n\t\t} else {\n\t\t\t \n\t\t\tif (dev_id == table->dev_id)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\ttable = NULL;\n\nfound:\n\tmutex_unlock(&gpio_lookup_lock);\n\treturn table;\n}\n\nstatic struct gpio_desc *gpiod_find(struct device *dev, const char *con_id,\n\t\t\t\t    unsigned int idx, unsigned long *flags)\n{\n\tstruct gpio_desc *desc = ERR_PTR(-ENOENT);\n\tstruct gpiod_lookup_table *table;\n\tstruct gpiod_lookup *p;\n\n\ttable = gpiod_find_lookup_table(dev);\n\tif (!table)\n\t\treturn desc;\n\n\tfor (p = &table->table[0]; p->key; p++) {\n\t\tstruct gpio_chip *gc;\n\n\t\t \n\t\tif (p->idx != idx)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (p->con_id && (!con_id || strcmp(p->con_id, con_id)))\n\t\t\tcontinue;\n\n\t\tif (p->chip_hwnum == U16_MAX) {\n\t\t\tdesc = gpio_name_to_desc(p->key);\n\t\t\tif (desc) {\n\t\t\t\t*flags = p->flags;\n\t\t\t\treturn desc;\n\t\t\t}\n\n\t\t\tdev_warn(dev, \"cannot find GPIO line %s, deferring\\n\",\n\t\t\t\t p->key);\n\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t\t}\n\n\t\tgc = find_chip_by_name(p->key);\n\n\t\tif (!gc) {\n\t\t\t \n\t\t\tdev_warn(dev, \"cannot find GPIO chip %s, deferring\\n\",\n\t\t\t\t p->key);\n\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t\t}\n\n\t\tif (gc->ngpio <= p->chip_hwnum) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"requested GPIO %u (%u) is out of range [0..%u] for chip %s\\n\",\n\t\t\t\tidx, p->chip_hwnum, gc->ngpio - 1,\n\t\t\t\tgc->label);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tdesc = gpiochip_get_desc(gc, p->chip_hwnum);\n\t\t*flags = p->flags;\n\n\t\treturn desc;\n\t}\n\n\treturn desc;\n}\n\nstatic int platform_gpio_count(struct device *dev, const char *con_id)\n{\n\tstruct gpiod_lookup_table *table;\n\tstruct gpiod_lookup *p;\n\tunsigned int count = 0;\n\n\ttable = gpiod_find_lookup_table(dev);\n\tif (!table)\n\t\treturn -ENOENT;\n\n\tfor (p = &table->table[0]; p->key; p++) {\n\t\tif ((con_id && p->con_id && !strcmp(con_id, p->con_id)) ||\n\t\t    (!con_id && !p->con_id))\n\t\t\tcount++;\n\t}\n\tif (!count)\n\t\treturn -ENOENT;\n\n\treturn count;\n}\n\nstatic struct gpio_desc *gpiod_find_by_fwnode(struct fwnode_handle *fwnode,\n\t\t\t\t\t      struct device *consumer,\n\t\t\t\t\t      const char *con_id,\n\t\t\t\t\t      unsigned int idx,\n\t\t\t\t\t      enum gpiod_flags *flags,\n\t\t\t\t\t      unsigned long *lookupflags)\n{\n\tstruct gpio_desc *desc = ERR_PTR(-ENOENT);\n\n\tif (is_of_node(fwnode)) {\n\t\tdev_dbg(consumer, \"using DT '%pfw' for '%s' GPIO lookup\\n\",\n\t\t\tfwnode, con_id);\n\t\tdesc = of_find_gpio(to_of_node(fwnode), con_id, idx, lookupflags);\n\t} else if (is_acpi_node(fwnode)) {\n\t\tdev_dbg(consumer, \"using ACPI '%pfw' for '%s' GPIO lookup\\n\",\n\t\t\tfwnode, con_id);\n\t\tdesc = acpi_find_gpio(fwnode, con_id, idx, flags, lookupflags);\n\t} else if (is_software_node(fwnode)) {\n\t\tdev_dbg(consumer, \"using swnode '%pfw' for '%s' GPIO lookup\\n\",\n\t\t\tfwnode, con_id);\n\t\tdesc = swnode_find_gpio(fwnode, con_id, idx, lookupflags);\n\t}\n\n\treturn desc;\n}\n\nstatic struct gpio_desc *gpiod_find_and_request(struct device *consumer,\n\t\t\t\t\t\tstruct fwnode_handle *fwnode,\n\t\t\t\t\t\tconst char *con_id,\n\t\t\t\t\t\tunsigned int idx,\n\t\t\t\t\t\tenum gpiod_flags flags,\n\t\t\t\t\t\tconst char *label,\n\t\t\t\t\t\tbool platform_lookup_allowed)\n{\n\tunsigned long lookupflags = GPIO_LOOKUP_FLAGS_DEFAULT;\n\tstruct gpio_desc *desc;\n\tint ret;\n\n\tdesc = gpiod_find_by_fwnode(fwnode, consumer, con_id, idx, &flags, &lookupflags);\n\tif (gpiod_not_found(desc) && platform_lookup_allowed) {\n\t\t \n\t\tdev_dbg(consumer, \"using lookup tables for GPIO lookup\\n\");\n\t\tdesc = gpiod_find(consumer, con_id, idx, &lookupflags);\n\t}\n\n\tif (IS_ERR(desc)) {\n\t\tdev_dbg(consumer, \"No GPIO consumer %s found\\n\", con_id);\n\t\treturn desc;\n\t}\n\n\t \n\tret = gpiod_request(desc, label);\n\tif (ret) {\n\t\tif (!(ret == -EBUSY && flags & GPIOD_FLAGS_BIT_NONEXCLUSIVE))\n\t\t\treturn ERR_PTR(ret);\n\n\t\t \n\t\tdev_info(consumer,\n\t\t\t \"nonexclusive access to GPIO for %s\\n\", con_id);\n\t\treturn desc;\n\t}\n\n\tret = gpiod_configure_flags(desc, con_id, lookupflags, flags);\n\tif (ret < 0) {\n\t\tdev_dbg(consumer, \"setup of GPIO %s failed\\n\", con_id);\n\t\tgpiod_put(desc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tgpiod_line_state_notify(desc, GPIOLINE_CHANGED_REQUESTED);\n\n\treturn desc;\n}\n\n \nstruct gpio_desc *fwnode_gpiod_get_index(struct fwnode_handle *fwnode,\n\t\t\t\t\t const char *con_id,\n\t\t\t\t\t int index,\n\t\t\t\t\t enum gpiod_flags flags,\n\t\t\t\t\t const char *label)\n{\n\treturn gpiod_find_and_request(NULL, fwnode, con_id, index, flags, label, false);\n}\nEXPORT_SYMBOL_GPL(fwnode_gpiod_get_index);\n\n \nint gpiod_count(struct device *dev, const char *con_id)\n{\n\tconst struct fwnode_handle *fwnode = dev ? dev_fwnode(dev) : NULL;\n\tint count = -ENOENT;\n\n\tif (is_of_node(fwnode))\n\t\tcount = of_gpio_get_count(dev, con_id);\n\telse if (is_acpi_node(fwnode))\n\t\tcount = acpi_gpio_count(dev, con_id);\n\telse if (is_software_node(fwnode))\n\t\tcount = swnode_gpio_count(fwnode, con_id);\n\n\tif (count < 0)\n\t\tcount = platform_gpio_count(dev, con_id);\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(gpiod_count);\n\n \nstruct gpio_desc *__must_check gpiod_get(struct device *dev, const char *con_id,\n\t\t\t\t\t enum gpiod_flags flags)\n{\n\treturn gpiod_get_index(dev, con_id, 0, flags);\n}\nEXPORT_SYMBOL_GPL(gpiod_get);\n\n \nstruct gpio_desc *__must_check gpiod_get_optional(struct device *dev,\n\t\t\t\t\t\t  const char *con_id,\n\t\t\t\t\t\t  enum gpiod_flags flags)\n{\n\treturn gpiod_get_index_optional(dev, con_id, 0, flags);\n}\nEXPORT_SYMBOL_GPL(gpiod_get_optional);\n\n\n \nint gpiod_configure_flags(struct gpio_desc *desc, const char *con_id,\n\t\tunsigned long lflags, enum gpiod_flags dflags)\n{\n\tint ret;\n\n\tif (lflags & GPIO_ACTIVE_LOW)\n\t\tset_bit(FLAG_ACTIVE_LOW, &desc->flags);\n\n\tif (lflags & GPIO_OPEN_DRAIN)\n\t\tset_bit(FLAG_OPEN_DRAIN, &desc->flags);\n\telse if (dflags & GPIOD_FLAGS_BIT_OPEN_DRAIN) {\n\t\t \n\t\tset_bit(FLAG_OPEN_DRAIN, &desc->flags);\n\t\tgpiod_warn(desc,\n\t\t\t   \"enforced open drain please flag it properly in DT/ACPI DSDT/board file\\n\");\n\t}\n\n\tif (lflags & GPIO_OPEN_SOURCE)\n\t\tset_bit(FLAG_OPEN_SOURCE, &desc->flags);\n\n\tif (((lflags & GPIO_PULL_UP) && (lflags & GPIO_PULL_DOWN)) ||\n\t    ((lflags & GPIO_PULL_UP) && (lflags & GPIO_PULL_DISABLE)) ||\n\t    ((lflags & GPIO_PULL_DOWN) && (lflags & GPIO_PULL_DISABLE))) {\n\t\tgpiod_err(desc,\n\t\t\t  \"multiple pull-up, pull-down or pull-disable enabled, invalid configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (lflags & GPIO_PULL_UP)\n\t\tset_bit(FLAG_PULL_UP, &desc->flags);\n\telse if (lflags & GPIO_PULL_DOWN)\n\t\tset_bit(FLAG_PULL_DOWN, &desc->flags);\n\telse if (lflags & GPIO_PULL_DISABLE)\n\t\tset_bit(FLAG_BIAS_DISABLE, &desc->flags);\n\n\tret = gpiod_set_transitory(desc, (lflags & GPIO_TRANSITORY));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!(dflags & GPIOD_FLAGS_BIT_DIR_SET)) {\n\t\tgpiod_dbg(desc, \"no flags found for %s\\n\", con_id);\n\t\treturn 0;\n\t}\n\n\t \n\tif (dflags & GPIOD_FLAGS_BIT_DIR_OUT)\n\t\tret = gpiod_direction_output(desc,\n\t\t\t\t!!(dflags & GPIOD_FLAGS_BIT_DIR_VAL));\n\telse\n\t\tret = gpiod_direction_input(desc);\n\n\treturn ret;\n}\n\n \nstruct gpio_desc *__must_check gpiod_get_index(struct device *dev,\n\t\t\t\t\t       const char *con_id,\n\t\t\t\t\t       unsigned int idx,\n\t\t\t\t\t       enum gpiod_flags flags)\n{\n\tstruct fwnode_handle *fwnode = dev ? dev_fwnode(dev) : NULL;\n\tconst char *devname = dev ? dev_name(dev) : \"?\";\n\tconst char *label = con_id ?: devname;\n\n\treturn gpiod_find_and_request(dev, fwnode, con_id, idx, flags, label, true);\n}\nEXPORT_SYMBOL_GPL(gpiod_get_index);\n\n \nstruct gpio_desc *__must_check gpiod_get_index_optional(struct device *dev,\n\t\t\t\t\t\t\tconst char *con_id,\n\t\t\t\t\t\t\tunsigned int index,\n\t\t\t\t\t\t\tenum gpiod_flags flags)\n{\n\tstruct gpio_desc *desc;\n\n\tdesc = gpiod_get_index(dev, con_id, index, flags);\n\tif (gpiod_not_found(desc))\n\t\treturn NULL;\n\n\treturn desc;\n}\nEXPORT_SYMBOL_GPL(gpiod_get_index_optional);\n\n \nint gpiod_hog(struct gpio_desc *desc, const char *name,\n\t      unsigned long lflags, enum gpiod_flags dflags)\n{\n\tstruct gpio_chip *gc;\n\tstruct gpio_desc *local_desc;\n\tint hwnum;\n\tint ret;\n\n\tgc = gpiod_to_chip(desc);\n\thwnum = gpio_chip_hwgpio(desc);\n\n\tlocal_desc = gpiochip_request_own_desc(gc, hwnum, name,\n\t\t\t\t\t       lflags, dflags);\n\tif (IS_ERR(local_desc)) {\n\t\tret = PTR_ERR(local_desc);\n\t\tpr_err(\"requesting hog GPIO %s (chip %s, offset %d) failed, %d\\n\",\n\t\t       name, gc->label, hwnum, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tset_bit(FLAG_IS_HOGGED, &desc->flags);\n\n\tgpiod_dbg(desc, \"hogged as %s%s\\n\",\n\t\t(dflags & GPIOD_FLAGS_BIT_DIR_OUT) ? \"output\" : \"input\",\n\t\t(dflags & GPIOD_FLAGS_BIT_DIR_OUT) ?\n\t\t  (dflags & GPIOD_FLAGS_BIT_DIR_VAL) ? \"/high\" : \"/low\" : \"\");\n\n\treturn 0;\n}\n\n \nstatic void gpiochip_free_hogs(struct gpio_chip *gc)\n{\n\tstruct gpio_desc *desc;\n\n\tfor_each_gpio_desc_with_flag(gc, desc, FLAG_IS_HOGGED)\n\t\tgpiochip_free_own_desc(desc);\n}\n\n \nstruct gpio_descs *__must_check gpiod_get_array(struct device *dev,\n\t\t\t\t\t\tconst char *con_id,\n\t\t\t\t\t\tenum gpiod_flags flags)\n{\n\tstruct gpio_desc *desc;\n\tstruct gpio_descs *descs;\n\tstruct gpio_array *array_info = NULL;\n\tstruct gpio_chip *gc;\n\tint count, bitmap_size;\n\tsize_t descs_size;\n\n\tcount = gpiod_count(dev, con_id);\n\tif (count < 0)\n\t\treturn ERR_PTR(count);\n\n\tdescs_size = struct_size(descs, desc, count);\n\tdescs = kzalloc(descs_size, GFP_KERNEL);\n\tif (!descs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (descs->ndescs = 0; descs->ndescs < count; descs->ndescs++) {\n\t\tdesc = gpiod_get_index(dev, con_id, descs->ndescs, flags);\n\t\tif (IS_ERR(desc)) {\n\t\t\tgpiod_put_array(descs);\n\t\t\treturn ERR_CAST(desc);\n\t\t}\n\n\t\tdescs->desc[descs->ndescs] = desc;\n\n\t\tgc = gpiod_to_chip(desc);\n\t\t \n\t\tif (descs->ndescs == 0 && gpio_chip_hwgpio(desc) == 0) {\n\t\t\tstruct gpio_descs *array;\n\n\t\t\tbitmap_size = BITS_TO_LONGS(gc->ngpio > count ?\n\t\t\t\t\t\t    gc->ngpio : count);\n\n\t\t\tarray = krealloc(descs, descs_size +\n\t\t\t\t\t struct_size(array_info, invert_mask, 3 * bitmap_size),\n\t\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\t\t\tif (!array) {\n\t\t\t\tgpiod_put_array(descs);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\n\t\t\tdescs = array;\n\n\t\t\tarray_info = (void *)descs + descs_size;\n\t\t\tarray_info->get_mask = array_info->invert_mask +\n\t\t\t\t\t\t  bitmap_size;\n\t\t\tarray_info->set_mask = array_info->get_mask +\n\t\t\t\t\t\t  bitmap_size;\n\n\t\t\tarray_info->desc = descs->desc;\n\t\t\tarray_info->size = count;\n\t\t\tarray_info->chip = gc;\n\t\t\tbitmap_set(array_info->get_mask, descs->ndescs,\n\t\t\t\t   count - descs->ndescs);\n\t\t\tbitmap_set(array_info->set_mask, descs->ndescs,\n\t\t\t\t   count - descs->ndescs);\n\t\t\tdescs->info = array_info;\n\t\t}\n\n\t\t \n\t\tif (!array_info)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (array_info->chip != gc) {\n\t\t\t__clear_bit(descs->ndescs, array_info->get_mask);\n\t\t\t__clear_bit(descs->ndescs, array_info->set_mask);\n\t\t}\n\t\t \n\t\telse if (gpio_chip_hwgpio(desc) != descs->ndescs) {\n\t\t\t \n\t\t\tif (bitmap_full(array_info->get_mask, descs->ndescs)) {\n\t\t\t\tarray_info = NULL;\n\t\t\t} else {\n\t\t\t\t__clear_bit(descs->ndescs,\n\t\t\t\t\t    array_info->get_mask);\n\t\t\t\t__clear_bit(descs->ndescs,\n\t\t\t\t\t    array_info->set_mask);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (gpiochip_line_is_open_drain(gc, descs->ndescs) ||\n\t\t\t    gpiochip_line_is_open_source(gc, descs->ndescs))\n\t\t\t\t__clear_bit(descs->ndescs,\n\t\t\t\t\t    array_info->set_mask);\n\t\t\t \n\t\t\tif (gpiod_is_active_low(desc))\n\t\t\t\t__set_bit(descs->ndescs,\n\t\t\t\t\t  array_info->invert_mask);\n\t\t}\n\t}\n\tif (array_info)\n\t\tdev_dbg(dev,\n\t\t\t\"GPIO array info: chip=%s, size=%d, get_mask=%lx, set_mask=%lx, invert_mask=%lx\\n\",\n\t\t\tarray_info->chip->label, array_info->size,\n\t\t\t*array_info->get_mask, *array_info->set_mask,\n\t\t\t*array_info->invert_mask);\n\treturn descs;\n}\nEXPORT_SYMBOL_GPL(gpiod_get_array);\n\n \nstruct gpio_descs *__must_check gpiod_get_array_optional(struct device *dev,\n\t\t\t\t\t\t\tconst char *con_id,\n\t\t\t\t\t\t\tenum gpiod_flags flags)\n{\n\tstruct gpio_descs *descs;\n\n\tdescs = gpiod_get_array(dev, con_id, flags);\n\tif (gpiod_not_found(descs))\n\t\treturn NULL;\n\n\treturn descs;\n}\nEXPORT_SYMBOL_GPL(gpiod_get_array_optional);\n\n \nvoid gpiod_put(struct gpio_desc *desc)\n{\n\tif (desc)\n\t\tgpiod_free(desc);\n}\nEXPORT_SYMBOL_GPL(gpiod_put);\n\n \nvoid gpiod_put_array(struct gpio_descs *descs)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < descs->ndescs; i++)\n\t\tgpiod_put(descs->desc[i]);\n\n\tkfree(descs);\n}\nEXPORT_SYMBOL_GPL(gpiod_put_array);\n\nstatic int gpio_stub_drv_probe(struct device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic struct device_driver gpio_stub_drv = {\n\t.name = \"gpio_stub_drv\",\n\t.bus = &gpio_bus_type,\n\t.probe = gpio_stub_drv_probe,\n};\n\nstatic int __init gpiolib_dev_init(void)\n{\n\tint ret;\n\n\t \n\tret = bus_register(&gpio_bus_type);\n\tif (ret < 0) {\n\t\tpr_err(\"gpiolib: could not register GPIO bus type\\n\");\n\t\treturn ret;\n\t}\n\n\tret = driver_register(&gpio_stub_drv);\n\tif (ret < 0) {\n\t\tpr_err(\"gpiolib: could not register GPIO stub driver\\n\");\n\t\tbus_unregister(&gpio_bus_type);\n\t\treturn ret;\n\t}\n\n\tret = alloc_chrdev_region(&gpio_devt, 0, GPIO_DEV_MAX, GPIOCHIP_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"gpiolib: failed to allocate char dev region\\n\");\n\t\tdriver_unregister(&gpio_stub_drv);\n\t\tbus_unregister(&gpio_bus_type);\n\t\treturn ret;\n\t}\n\n\tgpiolib_initialized = true;\n\tgpiochip_setup_devs();\n\n#if IS_ENABLED(CONFIG_OF_DYNAMIC) && IS_ENABLED(CONFIG_OF_GPIO)\n\tWARN_ON(of_reconfig_notifier_register(&gpio_of_notifier));\n#endif  \n\n\treturn ret;\n}\ncore_initcall(gpiolib_dev_init);\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic void gpiolib_dbg_show(struct seq_file *s, struct gpio_device *gdev)\n{\n\tstruct gpio_chip\t*gc = gdev->chip;\n\tstruct gpio_desc\t*desc;\n\tunsigned\t\tgpio = gdev->base;\n\tint\t\t\tvalue;\n\tbool\t\t\tis_out;\n\tbool\t\t\tis_irq;\n\tbool\t\t\tactive_low;\n\n\tfor_each_gpio_desc(gc, desc) {\n\t\tif (test_bit(FLAG_REQUESTED, &desc->flags)) {\n\t\t\tgpiod_get_direction(desc);\n\t\t\tis_out = test_bit(FLAG_IS_OUT, &desc->flags);\n\t\t\tvalue = gpio_chip_get_value(gc, desc);\n\t\t\tis_irq = test_bit(FLAG_USED_AS_IRQ, &desc->flags);\n\t\t\tactive_low = test_bit(FLAG_ACTIVE_LOW, &desc->flags);\n\t\t\tseq_printf(s, \" gpio-%-3d (%-20.20s|%-20.20s) %s %s %s%s\\n\",\n\t\t\t\t   gpio, desc->name ?: \"\", desc->label,\n\t\t\t\t   is_out ? \"out\" : \"in \",\n\t\t\t\t   value >= 0 ? (value ? \"hi\" : \"lo\") : \"?  \",\n\t\t\t\t   is_irq ? \"IRQ \" : \"\",\n\t\t\t\t   active_low ? \"ACTIVE LOW\" : \"\");\n\t\t} else if (desc->name) {\n\t\t\tseq_printf(s, \" gpio-%-3d (%-20.20s)\\n\", gpio, desc->name);\n\t\t}\n\n\t\tgpio++;\n\t}\n}\n\nstatic void *gpiolib_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tunsigned long flags;\n\tstruct gpio_device *gdev = NULL;\n\tloff_t index = *pos;\n\n\ts->private = \"\";\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\tlist_for_each_entry(gdev, &gpio_devices, list)\n\t\tif (index-- == 0) {\n\t\t\tspin_unlock_irqrestore(&gpio_lock, flags);\n\t\t\treturn gdev;\n\t\t}\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\n\treturn NULL;\n}\n\nstatic void *gpiolib_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tunsigned long flags;\n\tstruct gpio_device *gdev = v;\n\tvoid *ret = NULL;\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\tif (list_is_last(&gdev->list, &gpio_devices))\n\t\tret = NULL;\n\telse\n\t\tret = list_first_entry(&gdev->list, struct gpio_device, list);\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\n\ts->private = \"\\n\";\n\t++*pos;\n\n\treturn ret;\n}\n\nstatic void gpiolib_seq_stop(struct seq_file *s, void *v)\n{\n}\n\nstatic int gpiolib_seq_show(struct seq_file *s, void *v)\n{\n\tstruct gpio_device *gdev = v;\n\tstruct gpio_chip *gc = gdev->chip;\n\tstruct device *parent;\n\n\tif (!gc) {\n\t\tseq_printf(s, \"%s%s: (dangling chip)\", (char *)s->private,\n\t\t\t   dev_name(&gdev->dev));\n\t\treturn 0;\n\t}\n\n\tseq_printf(s, \"%s%s: GPIOs %d-%d\", (char *)s->private,\n\t\t   dev_name(&gdev->dev),\n\t\t   gdev->base, gdev->base + gdev->ngpio - 1);\n\tparent = gc->parent;\n\tif (parent)\n\t\tseq_printf(s, \", parent: %s/%s\",\n\t\t\t   parent->bus ? parent->bus->name : \"no-bus\",\n\t\t\t   dev_name(parent));\n\tif (gc->label)\n\t\tseq_printf(s, \", %s\", gc->label);\n\tif (gc->can_sleep)\n\t\tseq_printf(s, \", can sleep\");\n\tseq_printf(s, \":\\n\");\n\n\tif (gc->dbg_show)\n\t\tgc->dbg_show(s, gc);\n\telse\n\t\tgpiolib_dbg_show(s, gdev);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations gpiolib_sops = {\n\t.start = gpiolib_seq_start,\n\t.next = gpiolib_seq_next,\n\t.stop = gpiolib_seq_stop,\n\t.show = gpiolib_seq_show,\n};\nDEFINE_SEQ_ATTRIBUTE(gpiolib);\n\nstatic int __init gpiolib_debugfs_init(void)\n{\n\t \n\tdebugfs_create_file(\"gpio\", 0444, NULL, NULL, &gpiolib_fops);\n\treturn 0;\n}\nsubsys_initcall(gpiolib_debugfs_init);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}