{
  "module_name": "gpio-tqmx86.c",
  "hash_id": "2cdf1858b76470aeabedddf0037c94175e19861dfa6769cd24bc2fd4ba9baf7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-tqmx86.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#define TQMX86_NGPIO\t8\n#define TQMX86_NGPO\t4\t \n#define TQMX86_NGPI\t4\t \n#define TQMX86_DIR_INPUT_MASK\t0xf0\t \n\n#define TQMX86_GPIODD\t0\t \n#define TQMX86_GPIOD\t1\t \n#define TQMX86_GPIIC\t3\t \n#define TQMX86_GPIIS\t4\t \n\n#define TQMX86_GPII_FALLING\tBIT(0)\n#define TQMX86_GPII_RISING\tBIT(1)\n#define TQMX86_GPII_MASK\t(BIT(0) | BIT(1))\n#define TQMX86_GPII_BITS\t2\n\nstruct tqmx86_gpio_data {\n\tstruct gpio_chip\tchip;\n\tvoid __iomem\t\t*io_base;\n\tint\t\t\tirq;\n\traw_spinlock_t\t\tspinlock;\n\tu8\t\t\tirq_type[TQMX86_NGPI];\n};\n\nstatic u8 tqmx86_gpio_read(struct tqmx86_gpio_data *gd, unsigned int reg)\n{\n\treturn ioread8(gd->io_base + reg);\n}\n\nstatic void tqmx86_gpio_write(struct tqmx86_gpio_data *gd, u8 val,\n\t\t\t      unsigned int reg)\n{\n\tiowrite8(val, gd->io_base + reg);\n}\n\nstatic int tqmx86_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct tqmx86_gpio_data *gpio = gpiochip_get_data(chip);\n\n\treturn !!(tqmx86_gpio_read(gpio, TQMX86_GPIOD) & BIT(offset));\n}\n\nstatic void tqmx86_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t    int value)\n{\n\tstruct tqmx86_gpio_data *gpio = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu8 val;\n\n\traw_spin_lock_irqsave(&gpio->spinlock, flags);\n\tval = tqmx86_gpio_read(gpio, TQMX86_GPIOD);\n\tif (value)\n\t\tval |= BIT(offset);\n\telse\n\t\tval &= ~BIT(offset);\n\ttqmx86_gpio_write(gpio, val, TQMX86_GPIOD);\n\traw_spin_unlock_irqrestore(&gpio->spinlock, flags);\n}\n\nstatic int tqmx86_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset)\n{\n\t \n\tif (BIT(offset) & TQMX86_DIR_INPUT_MASK)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int tqmx86_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int offset,\n\t\t\t\t\tint value)\n{\n\t \n\tif (BIT(offset) & TQMX86_DIR_INPUT_MASK)\n\t\treturn -EINVAL;\n\n\ttqmx86_gpio_set(chip, offset, value);\n\treturn 0;\n}\n\nstatic int tqmx86_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset)\n{\n\tif (TQMX86_DIR_INPUT_MASK & BIT(offset))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic void tqmx86_gpio_irq_mask(struct irq_data *data)\n{\n\tunsigned int offset = (data->hwirq - TQMX86_NGPO);\n\tstruct tqmx86_gpio_data *gpio = gpiochip_get_data(\n\t\tirq_data_get_irq_chip_data(data));\n\tunsigned long flags;\n\tu8 gpiic, mask;\n\n\tmask = TQMX86_GPII_MASK << (offset * TQMX86_GPII_BITS);\n\n\traw_spin_lock_irqsave(&gpio->spinlock, flags);\n\tgpiic = tqmx86_gpio_read(gpio, TQMX86_GPIIC);\n\tgpiic &= ~mask;\n\ttqmx86_gpio_write(gpio, gpiic, TQMX86_GPIIC);\n\traw_spin_unlock_irqrestore(&gpio->spinlock, flags);\n\tgpiochip_disable_irq(&gpio->chip, irqd_to_hwirq(data));\n}\n\nstatic void tqmx86_gpio_irq_unmask(struct irq_data *data)\n{\n\tunsigned int offset = (data->hwirq - TQMX86_NGPO);\n\tstruct tqmx86_gpio_data *gpio = gpiochip_get_data(\n\t\tirq_data_get_irq_chip_data(data));\n\tunsigned long flags;\n\tu8 gpiic, mask;\n\n\tmask = TQMX86_GPII_MASK << (offset * TQMX86_GPII_BITS);\n\n\tgpiochip_enable_irq(&gpio->chip, irqd_to_hwirq(data));\n\traw_spin_lock_irqsave(&gpio->spinlock, flags);\n\tgpiic = tqmx86_gpio_read(gpio, TQMX86_GPIIC);\n\tgpiic &= ~mask;\n\tgpiic |= gpio->irq_type[offset] << (offset * TQMX86_GPII_BITS);\n\ttqmx86_gpio_write(gpio, gpiic, TQMX86_GPIIC);\n\traw_spin_unlock_irqrestore(&gpio->spinlock, flags);\n}\n\nstatic int tqmx86_gpio_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct tqmx86_gpio_data *gpio = gpiochip_get_data(\n\t\tirq_data_get_irq_chip_data(data));\n\tunsigned int offset = (data->hwirq - TQMX86_NGPO);\n\tunsigned int edge_type = type & IRQF_TRIGGER_MASK;\n\tunsigned long flags;\n\tu8 new_type, gpiic;\n\n\tswitch (edge_type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tnew_type = TQMX86_GPII_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tnew_type = TQMX86_GPII_FALLING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tnew_type = TQMX86_GPII_FALLING | TQMX86_GPII_RISING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;  \n\t}\n\n\tgpio->irq_type[offset] = new_type;\n\n\traw_spin_lock_irqsave(&gpio->spinlock, flags);\n\tgpiic = tqmx86_gpio_read(gpio, TQMX86_GPIIC);\n\tgpiic &= ~((TQMX86_GPII_MASK) << (offset * TQMX86_GPII_BITS));\n\tgpiic |= new_type << (offset * TQMX86_GPII_BITS);\n\ttqmx86_gpio_write(gpio, gpiic, TQMX86_GPIIC);\n\traw_spin_unlock_irqrestore(&gpio->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic void tqmx86_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *chip = irq_desc_get_handler_data(desc);\n\tstruct tqmx86_gpio_data *gpio = gpiochip_get_data(chip);\n\tstruct irq_chip *irq_chip = irq_desc_get_chip(desc);\n\tunsigned long irq_bits;\n\tint i = 0;\n\tu8 irq_status;\n\n\tchained_irq_enter(irq_chip, desc);\n\n\tirq_status = tqmx86_gpio_read(gpio, TQMX86_GPIIS);\n\ttqmx86_gpio_write(gpio, irq_status, TQMX86_GPIIS);\n\n\tirq_bits = irq_status;\n\tfor_each_set_bit(i, &irq_bits, TQMX86_NGPI)\n\t\tgeneric_handle_domain_irq(gpio->chip.irq.domain,\n\t\t\t\t\t  i + TQMX86_NGPO);\n\n\tchained_irq_exit(irq_chip, desc);\n}\n\n \nstatic int __maybe_unused tqmx86_gpio_runtime_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int __maybe_unused tqmx86_gpio_runtime_resume(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tqmx86_gpio_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tqmx86_gpio_runtime_suspend,\n\t\t\t   tqmx86_gpio_runtime_resume, NULL)\n};\n\nstatic void tqmx86_init_irq_valid_mask(struct gpio_chip *chip,\n\t\t\t\t       unsigned long *valid_mask,\n\t\t\t\t       unsigned int ngpios)\n{\n\t \n\tclear_bit(0, valid_mask);\n\tclear_bit(1, valid_mask);\n\tclear_bit(2, valid_mask);\n\tclear_bit(3, valid_mask);\n}\n\nstatic void tqmx86_gpio_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\tseq_printf(p, gc->label);\n}\n\nstatic const struct irq_chip tqmx86_gpio_irq_chip = {\n\t.irq_mask = tqmx86_gpio_irq_mask,\n\t.irq_unmask = tqmx86_gpio_irq_unmask,\n\t.irq_set_type = tqmx86_gpio_irq_set_type,\n\t.irq_print_chip = tqmx86_gpio_irq_print_chip,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int tqmx86_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tqmx86_gpio_data *gpio;\n\tstruct gpio_chip *chip;\n\tstruct gpio_irq_chip *girq;\n\tvoid __iomem *io_base;\n\tstruct resource *res;\n\tint ret, irq;\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq < 0 && irq != -ENXIO)\n\t\treturn irq;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Cannot get I/O\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tio_base = devm_ioport_map(&pdev->dev, res->start, resource_size(res));\n\tif (!io_base)\n\t\treturn -ENOMEM;\n\n\tgpio = devm_kzalloc(dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_init(&gpio->spinlock);\n\tgpio->io_base = io_base;\n\n\ttqmx86_gpio_write(gpio, (u8)~TQMX86_DIR_INPUT_MASK, TQMX86_GPIODD);\n\n\tchip = &gpio->chip;\n\tchip->label = \"gpio-tqmx86\";\n\tchip->owner = THIS_MODULE;\n\tchip->can_sleep = false;\n\tchip->base = -1;\n\tchip->direction_input = tqmx86_gpio_direction_input;\n\tchip->direction_output = tqmx86_gpio_direction_output;\n\tchip->get_direction = tqmx86_gpio_get_direction;\n\tchip->get = tqmx86_gpio_get;\n\tchip->set = tqmx86_gpio_set;\n\tchip->ngpio = TQMX86_NGPIO;\n\tchip->parent = pdev->dev.parent;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tif (irq > 0) {\n\t\tu8 irq_status;\n\n\t\t \n\t\ttqmx86_gpio_write(gpio, 0, TQMX86_GPIIC);\n\n\t\t \n\t\tirq_status = tqmx86_gpio_read(gpio, TQMX86_GPIIS);\n\t\ttqmx86_gpio_write(gpio, irq_status, TQMX86_GPIIS);\n\n\t\tgirq = &chip->irq;\n\t\tgpio_irq_chip_set_chip(girq, &tqmx86_gpio_irq_chip);\n\t\tgirq->parent_handler = tqmx86_gpio_irq_handler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(&pdev->dev, 1,\n\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_pm_dis;\n\t\t}\n\t\tgirq->parents[0] = irq;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_simple_irq;\n\t\tgirq->init_valid_mask = tqmx86_init_irq_valid_mask;\n\n\t\tirq_domain_set_pm_device(girq->domain, dev);\n\t}\n\n\tret = devm_gpiochip_add_data(dev, chip, gpio);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not register GPIO chip\\n\");\n\t\tgoto out_pm_dis;\n\t}\n\n\tdev_info(dev, \"GPIO functionality initialized with %d pins\\n\",\n\t\t chip->ngpio);\n\n\treturn 0;\n\nout_pm_dis:\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic struct platform_driver tqmx86_gpio_driver = {\n\t.driver = {\n\t\t.name = \"tqmx86-gpio\",\n\t\t.pm = &tqmx86_gpio_dev_pm_ops,\n\t},\n\t.probe\t\t= tqmx86_gpio_probe,\n};\n\nmodule_platform_driver(tqmx86_gpio_driver);\n\nMODULE_DESCRIPTION(\"TQMx86 PLD GPIO Driver\");\nMODULE_AUTHOR(\"Andrew Lunn <andrew@lunn.ch>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:tqmx86-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}