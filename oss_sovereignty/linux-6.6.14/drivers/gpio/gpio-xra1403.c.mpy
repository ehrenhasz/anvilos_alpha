{
  "module_name": "gpio-xra1403.c",
  "hash_id": "a554ec6d730f67ed7f48f5eade376e6a038083282ce4f0e9331bf72013e23f62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-xra1403.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/spi/spi.h>\n#include <linux/regmap.h>\n\n \n#define XRA_GSR   0x00  \n#define XRA_OCR   0x02  \n#define XRA_PIR   0x04  \n#define XRA_GCR   0x06  \n#define XRA_PUR   0x08  \n#define XRA_IER   0x0A  \n#define XRA_TSCR  0x0C  \n#define XRA_ISR   0x0E  \n#define XRA_REIR  0x10  \n#define XRA_FEIR  0x12  \n#define XRA_IFR   0x14  \n#define XRA_LAST  0x15  \n\nstruct xra1403 {\n\tstruct gpio_chip  chip;\n\tstruct regmap     *regmap;\n};\n\nstatic const struct regmap_config xra1403_regmap_cfg = {\n\t\t.reg_bits = 7,\n\t\t.pad_bits = 1,\n\t\t.val_bits = 8,\n\n\t\t.max_register = XRA_LAST,\n};\n\nstatic unsigned int to_reg(unsigned int reg, unsigned int offset)\n{\n\treturn reg + (offset > 7);\n}\n\nstatic int xra1403_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct xra1403 *xra = gpiochip_get_data(chip);\n\n\treturn regmap_update_bits(xra->regmap, to_reg(XRA_GCR, offset),\n\t\t\tBIT(offset % 8), BIT(offset % 8));\n}\n\nstatic int xra1403_direction_output(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t    int value)\n{\n\tint ret;\n\tstruct xra1403 *xra = gpiochip_get_data(chip);\n\n\tret = regmap_update_bits(xra->regmap, to_reg(XRA_GCR, offset),\n\t\t\tBIT(offset % 8), 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(xra->regmap, to_reg(XRA_OCR, offset),\n\t\t\tBIT(offset % 8), value ? BIT(offset % 8) : 0);\n\n\treturn ret;\n}\n\nstatic int xra1403_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tint ret;\n\tunsigned int val;\n\tstruct xra1403 *xra = gpiochip_get_data(chip);\n\n\tret = regmap_read(xra->regmap, to_reg(XRA_GCR, offset), &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & BIT(offset % 8))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int xra1403_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tint ret;\n\tunsigned int val;\n\tstruct xra1403 *xra = gpiochip_get_data(chip);\n\n\tret = regmap_read(xra->regmap, to_reg(XRA_GSR, offset), &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & BIT(offset % 8));\n}\n\nstatic void xra1403_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tint ret;\n\tstruct xra1403 *xra = gpiochip_get_data(chip);\n\n\tret = regmap_update_bits(xra->regmap, to_reg(XRA_OCR, offset),\n\t\t\tBIT(offset % 8), value ? BIT(offset % 8) : 0);\n\tif (ret)\n\t\tdev_err(chip->parent, \"Failed to set pin: %d, ret: %d\\n\",\n\t\t\t\toffset, ret);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void xra1403_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tint reg;\n\tstruct xra1403 *xra = gpiochip_get_data(chip);\n\tint value[XRA_LAST];\n\tint i;\n\tconst char *label;\n\tunsigned int gcr;\n\tunsigned int gsr;\n\n\tseq_puts(s, \"xra reg:\");\n\tfor (reg = 0; reg <= XRA_LAST; reg++)\n\t\tseq_printf(s, \" %2.2x\", reg);\n\tseq_puts(s, \"\\n  value:\");\n\tfor (reg = 0; reg < XRA_LAST; reg++) {\n\t\tregmap_read(xra->regmap, reg, &value[reg]);\n\t\tseq_printf(s, \" %2.2x\", value[reg]);\n\t}\n\tseq_puts(s, \"\\n\");\n\n\tgcr = value[XRA_GCR + 1] << 8 | value[XRA_GCR];\n\tgsr = value[XRA_GSR + 1] << 8 | value[XRA_GSR];\n\tfor_each_requested_gpio(chip, i, label) {\n\t\tseq_printf(s, \" gpio-%-3d (%-12s) %s %s\\n\",\n\t\t\t   chip->base + i, label,\n\t\t\t   (gcr & BIT(i)) ? \"in\" : \"out\",\n\t\t\t   (gsr & BIT(i)) ? \"hi\" : \"lo\");\n\t}\n}\n#else\n#define xra1403_dbg_show NULL\n#endif\n\nstatic int xra1403_probe(struct spi_device *spi)\n{\n\tstruct xra1403 *xra;\n\tstruct gpio_desc *reset_gpio;\n\tint ret;\n\n\txra = devm_kzalloc(&spi->dev, sizeof(*xra), GFP_KERNEL);\n\tif (!xra)\n\t\treturn -ENOMEM;\n\n\t \n\treset_gpio = devm_gpiod_get_optional(&spi->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(reset_gpio))\n\t\tdev_warn(&spi->dev, \"Could not get reset-gpios\\n\");\n\n\txra->chip.direction_input = xra1403_direction_input;\n\txra->chip.direction_output = xra1403_direction_output;\n\txra->chip.get_direction = xra1403_get_direction;\n\txra->chip.get = xra1403_get;\n\txra->chip.set = xra1403_set;\n\n\txra->chip.dbg_show = xra1403_dbg_show;\n\n\txra->chip.ngpio = 16;\n\txra->chip.label = \"xra1403\";\n\n\txra->chip.base = -1;\n\txra->chip.can_sleep = true;\n\txra->chip.parent = &spi->dev;\n\txra->chip.owner = THIS_MODULE;\n\n\txra->regmap = devm_regmap_init_spi(spi, &xra1403_regmap_cfg);\n\tif (IS_ERR(xra->regmap)) {\n\t\tret = PTR_ERR(xra->regmap);\n\t\tdev_err(&spi->dev, \"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn devm_gpiochip_add_data(&spi->dev, &xra->chip, xra);\n}\n\nstatic const struct spi_device_id xra1403_ids[] = {\n\t{ \"xra1403\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, xra1403_ids);\n\nstatic const struct of_device_id xra1403_spi_of_match[] = {\n\t{ .compatible = \"exar,xra1403\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xra1403_spi_of_match);\n\nstatic struct spi_driver xra1403_driver = {\n\t.probe    = xra1403_probe,\n\t.id_table = xra1403_ids,\n\t.driver   = {\n\t\t.name           = \"xra1403\",\n\t\t.of_match_table = xra1403_spi_of_match,\n\t},\n};\n\nmodule_spi_driver(xra1403_driver);\n\nMODULE_AUTHOR(\"Nandor Han <nandor.han@ge.com>\");\nMODULE_AUTHOR(\"Semi Malinen <semi.malinen@ge.com>\");\nMODULE_DESCRIPTION(\"GPIO expander driver for EXAR XRA1403\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}