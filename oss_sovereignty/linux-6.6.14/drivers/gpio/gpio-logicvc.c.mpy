{
  "module_name": "gpio-logicvc.c",
  "hash_id": "33a2958ad4f966a35dcec1202eb6ea6c3c78ff26d2e60b1a3c55b31c9a5766ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-logicvc.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n\n#define LOGICVC_CTRL_REG\t\t0x40\n#define LOGICVC_CTRL_GPIO_SHIFT\t\t11\n#define LOGICVC_CTRL_GPIO_BITS\t\t5\n\n#define LOGICVC_POWER_CTRL_REG\t\t0x78\n#define LOGICVC_POWER_CTRL_GPIO_SHIFT\t0\n#define LOGICVC_POWER_CTRL_GPIO_BITS\t4\n\nstruct logicvc_gpio {\n\tstruct gpio_chip chip;\n\tstruct regmap *regmap;\n};\n\nstatic void logicvc_gpio_offset(struct logicvc_gpio *logicvc, unsigned offset,\n\t\t\t\tunsigned int *reg, unsigned int *bit)\n{\n\tif (offset >= LOGICVC_CTRL_GPIO_BITS) {\n\t\t*reg = LOGICVC_POWER_CTRL_REG;\n\n\t\t \n\t\toffset -= LOGICVC_CTRL_GPIO_BITS;\n\t\t \n\t\toffset += LOGICVC_POWER_CTRL_GPIO_SHIFT;\n\t} else {\n\t\t*reg = LOGICVC_CTRL_REG;\n\n\t\t \n\t\toffset += LOGICVC_CTRL_GPIO_SHIFT;\n\t}\n\n\t*bit = BIT(offset);\n}\n\nstatic int logicvc_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct logicvc_gpio *logicvc = gpiochip_get_data(chip);\n\tunsigned int reg, bit, value;\n\tint ret;\n\n\tlogicvc_gpio_offset(logicvc, offset, &reg, &bit);\n\n\tret = regmap_read(logicvc->regmap, reg, &value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(value & bit);\n}\n\nstatic void logicvc_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct logicvc_gpio *logicvc = gpiochip_get_data(chip);\n\tunsigned int reg, bit;\n\n\tlogicvc_gpio_offset(logicvc, offset, &reg, &bit);\n\n\tregmap_update_bits(logicvc->regmap, reg, bit, value ? bit : 0);\n}\n\nstatic int logicvc_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t unsigned offset, int value)\n{\n\t \n\tlogicvc_gpio_set(chip, offset, value);\n\n\treturn 0;\n}\n\nstatic struct regmap_config logicvc_gpio_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.name\t\t= \"logicvc-gpio\",\n};\n\nstatic int logicvc_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *of_node = dev->of_node;\n\tstruct logicvc_gpio *logicvc;\n\tint ret;\n\n\tlogicvc = devm_kzalloc(dev, sizeof(*logicvc), GFP_KERNEL);\n\tif (!logicvc)\n\t\treturn -ENOMEM;\n\n\t \n\tlogicvc->regmap = syscon_node_to_regmap(of_node->parent);\n\n\t \n\tif (IS_ERR(logicvc->regmap)) {\n\t\tstruct resource res;\n\t\tvoid __iomem *base;\n\n\t\tret = of_address_to_resource(of_node, 0, &res);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to get resource from address\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tbase = devm_ioremap_resource(dev, &res);\n\t\tif (IS_ERR(base))\n\t\t\treturn PTR_ERR(base);\n\n\t\tlogicvc_gpio_regmap_config.max_register = resource_size(&res) -\n\t\t\tlogicvc_gpio_regmap_config.reg_stride;\n\n\t\tlogicvc->regmap =\n\t\t\tdevm_regmap_init_mmio(dev, base,\n\t\t\t\t\t      &logicvc_gpio_regmap_config);\n\t\tif (IS_ERR(logicvc->regmap)) {\n\t\t\tdev_err(dev, \"Failed to create regmap for I/O\\n\");\n\t\t\treturn PTR_ERR(logicvc->regmap);\n\t\t}\n\t}\n\n\tlogicvc->chip.parent = dev;\n\tlogicvc->chip.owner = THIS_MODULE;\n\tlogicvc->chip.label = dev_name(dev);\n\tlogicvc->chip.base = -1;\n\tlogicvc->chip.ngpio = LOGICVC_CTRL_GPIO_BITS +\n\t\t\t      LOGICVC_POWER_CTRL_GPIO_BITS;\n\tlogicvc->chip.get = logicvc_gpio_get;\n\tlogicvc->chip.set = logicvc_gpio_set;\n\tlogicvc->chip.direction_output = logicvc_gpio_direction_output;\n\n\treturn devm_gpiochip_add_data(dev, &logicvc->chip, logicvc);\n}\n\nstatic const struct of_device_id logicivc_gpio_of_table[] = {\n\t{\n\t\t.compatible\t= \"xylon,logicvc-3.02.a-gpio\",\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, logicivc_gpio_of_table);\n\nstatic struct platform_driver logicvc_gpio_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"gpio-logicvc\",\n\t\t.of_match_table\t= logicivc_gpio_of_table,\n\t},\n\t.probe\t= logicvc_gpio_probe,\n};\n\nmodule_platform_driver(logicvc_gpio_driver);\n\nMODULE_AUTHOR(\"Paul Kocialkowski <paul.kocialkowski@bootlin.com>\");\nMODULE_DESCRIPTION(\"Xylon LogiCVC GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}