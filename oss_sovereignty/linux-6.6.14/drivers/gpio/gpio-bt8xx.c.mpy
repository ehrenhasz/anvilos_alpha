{
  "module_name": "gpio-bt8xx.c",
  "hash_id": "c3c258013365fe38a814bd073b57e4692d595139d736da26e5bcb72e7c2a7d6c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-bt8xx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/gpio/driver.h>\n#include <linux/slab.h>\n\n \n#include \"../media/pci/bt8xx/bt848.h\"\n\n\n#define BT8XXGPIO_NR_GPIOS\t\t24  \n\n\nstruct bt8xxgpio {\n\tspinlock_t lock;\n\n\tvoid __iomem *mmio;\n\tstruct pci_dev *pdev;\n\tstruct gpio_chip gpio;\n\n#ifdef CONFIG_PM\n\tu32 saved_outen;\n\tu32 saved_data;\n#endif\n};\n\n#define bgwrite(dat, adr)\twritel((dat), bg->mmio+(adr))\n#define bgread(adr)\t\treadl(bg->mmio+(adr))\n\n\nstatic int modparam_gpiobase = -1 ;\nmodule_param_named(gpiobase, modparam_gpiobase, int, 0444);\nMODULE_PARM_DESC(gpiobase, \"The GPIO number base. -1 means dynamic, which is the default.\");\n\n\nstatic int bt8xxgpio_gpio_direction_input(struct gpio_chip *gpio, unsigned nr)\n{\n\tstruct bt8xxgpio *bg = gpiochip_get_data(gpio);\n\tunsigned long flags;\n\tu32 outen, data;\n\n\tspin_lock_irqsave(&bg->lock, flags);\n\n\tdata = bgread(BT848_GPIO_DATA);\n\tdata &= ~(1 << nr);\n\tbgwrite(data, BT848_GPIO_DATA);\n\n\touten = bgread(BT848_GPIO_OUT_EN);\n\touten &= ~(1 << nr);\n\tbgwrite(outen, BT848_GPIO_OUT_EN);\n\n\tspin_unlock_irqrestore(&bg->lock, flags);\n\n\treturn 0;\n}\n\nstatic int bt8xxgpio_gpio_get(struct gpio_chip *gpio, unsigned nr)\n{\n\tstruct bt8xxgpio *bg = gpiochip_get_data(gpio);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&bg->lock, flags);\n\tval = bgread(BT848_GPIO_DATA);\n\tspin_unlock_irqrestore(&bg->lock, flags);\n\n\treturn !!(val & (1 << nr));\n}\n\nstatic int bt8xxgpio_gpio_direction_output(struct gpio_chip *gpio,\n\t\t\t\t\tunsigned nr, int val)\n{\n\tstruct bt8xxgpio *bg = gpiochip_get_data(gpio);\n\tunsigned long flags;\n\tu32 outen, data;\n\n\tspin_lock_irqsave(&bg->lock, flags);\n\n\touten = bgread(BT848_GPIO_OUT_EN);\n\touten |= (1 << nr);\n\tbgwrite(outen, BT848_GPIO_OUT_EN);\n\n\tdata = bgread(BT848_GPIO_DATA);\n\tif (val)\n\t\tdata |= (1 << nr);\n\telse\n\t\tdata &= ~(1 << nr);\n\tbgwrite(data, BT848_GPIO_DATA);\n\n\tspin_unlock_irqrestore(&bg->lock, flags);\n\n\treturn 0;\n}\n\nstatic void bt8xxgpio_gpio_set(struct gpio_chip *gpio,\n\t\t\t    unsigned nr, int val)\n{\n\tstruct bt8xxgpio *bg = gpiochip_get_data(gpio);\n\tunsigned long flags;\n\tu32 data;\n\n\tspin_lock_irqsave(&bg->lock, flags);\n\n\tdata = bgread(BT848_GPIO_DATA);\n\tif (val)\n\t\tdata |= (1 << nr);\n\telse\n\t\tdata &= ~(1 << nr);\n\tbgwrite(data, BT848_GPIO_DATA);\n\n\tspin_unlock_irqrestore(&bg->lock, flags);\n}\n\nstatic void bt8xxgpio_gpio_setup(struct bt8xxgpio *bg)\n{\n\tstruct gpio_chip *c = &bg->gpio;\n\n\tc->label = dev_name(&bg->pdev->dev);\n\tc->owner = THIS_MODULE;\n\tc->direction_input = bt8xxgpio_gpio_direction_input;\n\tc->get = bt8xxgpio_gpio_get;\n\tc->direction_output = bt8xxgpio_gpio_direction_output;\n\tc->set = bt8xxgpio_gpio_set;\n\tc->dbg_show = NULL;\n\tc->base = modparam_gpiobase;\n\tc->ngpio = BT8XXGPIO_NR_GPIOS;\n\tc->can_sleep = false;\n}\n\nstatic int bt8xxgpio_probe(struct pci_dev *dev,\n\t\t\tconst struct pci_device_id *pci_id)\n{\n\tstruct bt8xxgpio *bg;\n\tint err;\n\n\tbg = devm_kzalloc(&dev->dev, sizeof(struct bt8xxgpio), GFP_KERNEL);\n\tif (!bg)\n\t\treturn -ENOMEM;\n\n\tbg->pdev = dev;\n\tspin_lock_init(&bg->lock);\n\n\terr = pci_enable_device(dev);\n\tif (err) {\n\t\tdev_err(&dev->dev, \"can't enable device.\\n\");\n\t\treturn err;\n\t}\n\tif (!devm_request_mem_region(&dev->dev, pci_resource_start(dev, 0),\n\t\t\t\tpci_resource_len(dev, 0),\n\t\t\t\t\"bt8xxgpio\")) {\n\t\tdev_warn(&dev->dev, \"can't request iomem (0x%llx).\\n\",\n\t\t       (unsigned long long)pci_resource_start(dev, 0));\n\t\terr = -EBUSY;\n\t\tgoto err_disable;\n\t}\n\tpci_set_master(dev);\n\tpci_set_drvdata(dev, bg);\n\n\tbg->mmio = devm_ioremap(&dev->dev, pci_resource_start(dev, 0), 0x1000);\n\tif (!bg->mmio) {\n\t\tdev_err(&dev->dev, \"ioremap() failed\\n\");\n\t\terr = -EIO;\n\t\tgoto err_disable;\n\t}\n\n\t \n\tbgwrite(0, BT848_INT_MASK);\n\n\t \n\tbgwrite(0, BT848_GPIO_DMA_CTL);\n\tbgwrite(0, BT848_GPIO_REG_INP);\n\tbgwrite(0, BT848_GPIO_OUT_EN);\n\n\tbt8xxgpio_gpio_setup(bg);\n\terr = gpiochip_add_data(&bg->gpio, bg);\n\tif (err) {\n\t\tdev_err(&dev->dev, \"failed to register GPIOs\\n\");\n\t\tgoto err_disable;\n\t}\n\n\treturn 0;\n\nerr_disable:\n\tpci_disable_device(dev);\n\n\treturn err;\n}\n\nstatic void bt8xxgpio_remove(struct pci_dev *pdev)\n{\n\tstruct bt8xxgpio *bg = pci_get_drvdata(pdev);\n\n\tgpiochip_remove(&bg->gpio);\n\n\tbgwrite(0, BT848_INT_MASK);\n\tbgwrite(~0x0, BT848_INT_STAT);\n\tbgwrite(0x0, BT848_GPIO_OUT_EN);\n\n\tpci_disable_device(pdev);\n}\n\n#ifdef CONFIG_PM\nstatic int bt8xxgpio_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct bt8xxgpio *bg = pci_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bg->lock, flags);\n\n\tbg->saved_outen = bgread(BT848_GPIO_OUT_EN);\n\tbg->saved_data = bgread(BT848_GPIO_DATA);\n\n\tbgwrite(0, BT848_INT_MASK);\n\tbgwrite(~0x0, BT848_INT_STAT);\n\tbgwrite(0x0, BT848_GPIO_OUT_EN);\n\n\tspin_unlock_irqrestore(&bg->lock, flags);\n\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\n\treturn 0;\n}\n\nstatic int bt8xxgpio_resume(struct pci_dev *pdev)\n{\n\tstruct bt8xxgpio *bg = pci_get_drvdata(pdev);\n\tunsigned long flags;\n\tint err;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\tpci_restore_state(pdev);\n\n\tspin_lock_irqsave(&bg->lock, flags);\n\n\tbgwrite(0, BT848_INT_MASK);\n\tbgwrite(0, BT848_GPIO_DMA_CTL);\n\tbgwrite(0, BT848_GPIO_REG_INP);\n\tbgwrite(bg->saved_outen, BT848_GPIO_OUT_EN);\n\tbgwrite(bg->saved_data & bg->saved_outen,\n\t\tBT848_GPIO_DATA);\n\n\tspin_unlock_irqrestore(&bg->lock, flags);\n\n\treturn 0;\n}\n#else\n#define bt8xxgpio_suspend NULL\n#define bt8xxgpio_resume NULL\n#endif  \n\nstatic const struct pci_device_id bt8xxgpio_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROOKTREE, PCI_DEVICE_ID_BT848) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROOKTREE, PCI_DEVICE_ID_BT849) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROOKTREE, PCI_DEVICE_ID_BT878) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROOKTREE, PCI_DEVICE_ID_BT879) },\n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, bt8xxgpio_pci_tbl);\n\nstatic struct pci_driver bt8xxgpio_pci_driver = {\n\t.name\t\t= \"bt8xxgpio\",\n\t.id_table\t= bt8xxgpio_pci_tbl,\n\t.probe\t\t= bt8xxgpio_probe,\n\t.remove\t\t= bt8xxgpio_remove,\n\t.suspend\t= bt8xxgpio_suspend,\n\t.resume\t\t= bt8xxgpio_resume,\n};\n\nmodule_pci_driver(bt8xxgpio_pci_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michael Buesch\");\nMODULE_DESCRIPTION(\"Abuse a BT8xx framegrabber card as generic GPIO card\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}