{
  "module_name": "gpio-brcmstb.c",
  "hash_id": "b96261d0cd005dfd725d42431a30b79b4d8535c0151a6b0b0b9fa13ef86c81fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-brcmstb.c",
  "human_readable_source": "\n\n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n\nenum gio_reg_index {\n\tGIO_REG_ODEN = 0,\n\tGIO_REG_DATA,\n\tGIO_REG_IODIR,\n\tGIO_REG_EC,\n\tGIO_REG_EI,\n\tGIO_REG_MASK,\n\tGIO_REG_LEVEL,\n\tGIO_REG_STAT,\n\tNUMBER_OF_GIO_REGISTERS\n};\n\n#define GIO_BANK_SIZE           (NUMBER_OF_GIO_REGISTERS * sizeof(u32))\n#define GIO_BANK_OFF(bank, off)\t(((bank) * GIO_BANK_SIZE) + (off * sizeof(u32)))\n#define GIO_ODEN(bank)          GIO_BANK_OFF(bank, GIO_REG_ODEN)\n#define GIO_DATA(bank)          GIO_BANK_OFF(bank, GIO_REG_DATA)\n#define GIO_IODIR(bank)         GIO_BANK_OFF(bank, GIO_REG_IODIR)\n#define GIO_EC(bank)            GIO_BANK_OFF(bank, GIO_REG_EC)\n#define GIO_EI(bank)            GIO_BANK_OFF(bank, GIO_REG_EI)\n#define GIO_MASK(bank)          GIO_BANK_OFF(bank, GIO_REG_MASK)\n#define GIO_LEVEL(bank)         GIO_BANK_OFF(bank, GIO_REG_LEVEL)\n#define GIO_STAT(bank)          GIO_BANK_OFF(bank, GIO_REG_STAT)\n\nstruct brcmstb_gpio_bank {\n\tstruct list_head node;\n\tint id;\n\tstruct gpio_chip gc;\n\tstruct brcmstb_gpio_priv *parent_priv;\n\tu32 width;\n\tu32 wake_active;\n\tu32 saved_regs[GIO_REG_STAT];  \n};\n\nstruct brcmstb_gpio_priv {\n\tstruct list_head bank_list;\n\tvoid __iomem *reg_base;\n\tstruct platform_device *pdev;\n\tstruct irq_domain *irq_domain;\n\tstruct irq_chip irq_chip;\n\tint parent_irq;\n\tint gpio_base;\n\tint num_gpios;\n\tint parent_wake_irq;\n};\n\n#define MAX_GPIO_PER_BANK       32\n#define GPIO_BANK(gpio)         ((gpio) >> 5)\n \n#define GPIO_BIT(gpio)          ((gpio) & (MAX_GPIO_PER_BANK - 1))\n\nstatic inline struct brcmstb_gpio_priv *\nbrcmstb_gpio_gc_to_priv(struct gpio_chip *gc)\n{\n\tstruct brcmstb_gpio_bank *bank = gpiochip_get_data(gc);\n\treturn bank->parent_priv;\n}\n\nstatic unsigned long\n__brcmstb_gpio_get_active_irqs(struct brcmstb_gpio_bank *bank)\n{\n\tvoid __iomem *reg_base = bank->parent_priv->reg_base;\n\n\treturn bank->gc.read_reg(reg_base + GIO_STAT(bank->id)) &\n\t       bank->gc.read_reg(reg_base + GIO_MASK(bank->id));\n}\n\nstatic unsigned long\nbrcmstb_gpio_get_active_irqs(struct brcmstb_gpio_bank *bank)\n{\n\tunsigned long status;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&bank->gc.bgpio_lock, flags);\n\tstatus = __brcmstb_gpio_get_active_irqs(bank);\n\traw_spin_unlock_irqrestore(&bank->gc.bgpio_lock, flags);\n\n\treturn status;\n}\n\nstatic int brcmstb_gpio_hwirq_to_offset(irq_hw_number_t hwirq,\n\t\t\t\t\tstruct brcmstb_gpio_bank *bank)\n{\n\treturn hwirq - (bank->gc.base - bank->parent_priv->gpio_base);\n}\n\nstatic void brcmstb_gpio_set_imask(struct brcmstb_gpio_bank *bank,\n\t\tunsigned int hwirq, bool enable)\n{\n\tstruct gpio_chip *gc = &bank->gc;\n\tstruct brcmstb_gpio_priv *priv = bank->parent_priv;\n\tu32 mask = BIT(brcmstb_gpio_hwirq_to_offset(hwirq, bank));\n\tu32 imask;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gc->bgpio_lock, flags);\n\timask = gc->read_reg(priv->reg_base + GIO_MASK(bank->id));\n\tif (enable)\n\t\timask |= mask;\n\telse\n\t\timask &= ~mask;\n\tgc->write_reg(priv->reg_base + GIO_MASK(bank->id), imask);\n\traw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);\n}\n\nstatic int brcmstb_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct brcmstb_gpio_priv *priv = brcmstb_gpio_gc_to_priv(gc);\n\t \n\tint hwirq = offset + (gc->base - priv->gpio_base);\n\n\tif (hwirq >= priv->num_gpios)\n\t\treturn -ENXIO;\n\treturn irq_create_mapping(priv->irq_domain, hwirq);\n}\n\n \n\nstatic void brcmstb_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct brcmstb_gpio_bank *bank = gpiochip_get_data(gc);\n\n\tbrcmstb_gpio_set_imask(bank, d->hwirq, false);\n}\n\nstatic void brcmstb_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct brcmstb_gpio_bank *bank = gpiochip_get_data(gc);\n\n\tbrcmstb_gpio_set_imask(bank, d->hwirq, true);\n}\n\nstatic void brcmstb_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct brcmstb_gpio_bank *bank = gpiochip_get_data(gc);\n\tstruct brcmstb_gpio_priv *priv = bank->parent_priv;\n\tu32 mask = BIT(brcmstb_gpio_hwirq_to_offset(d->hwirq, bank));\n\n\tgc->write_reg(priv->reg_base + GIO_STAT(bank->id), mask);\n}\n\nstatic int brcmstb_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct brcmstb_gpio_bank *bank = gpiochip_get_data(gc);\n\tstruct brcmstb_gpio_priv *priv = bank->parent_priv;\n\tu32 mask = BIT(brcmstb_gpio_hwirq_to_offset(d->hwirq, bank));\n\tu32 edge_insensitive, iedge_insensitive;\n\tu32 edge_config, iedge_config;\n\tu32 level, ilevel;\n\tunsigned long flags;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tlevel = mask;\n\t\tedge_config = 0;\n\t\tedge_insensitive = 0;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tlevel = mask;\n\t\tedge_config = mask;\n\t\tedge_insensitive = 0;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tlevel = 0;\n\t\tedge_config = 0;\n\t\tedge_insensitive = 0;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tlevel = 0;\n\t\tedge_config = mask;\n\t\tedge_insensitive = 0;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tlevel = 0;\n\t\tedge_config = 0;   \n\t\tedge_insensitive = mask;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&bank->gc.bgpio_lock, flags);\n\n\tiedge_config = bank->gc.read_reg(priv->reg_base +\n\t\t\tGIO_EC(bank->id)) & ~mask;\n\tiedge_insensitive = bank->gc.read_reg(priv->reg_base +\n\t\t\tGIO_EI(bank->id)) & ~mask;\n\tilevel = bank->gc.read_reg(priv->reg_base +\n\t\t\tGIO_LEVEL(bank->id)) & ~mask;\n\n\tbank->gc.write_reg(priv->reg_base + GIO_EC(bank->id),\n\t\t\tiedge_config | edge_config);\n\tbank->gc.write_reg(priv->reg_base + GIO_EI(bank->id),\n\t\t\tiedge_insensitive | edge_insensitive);\n\tbank->gc.write_reg(priv->reg_base + GIO_LEVEL(bank->id),\n\t\t\tilevel | level);\n\n\traw_spin_unlock_irqrestore(&bank->gc.bgpio_lock, flags);\n\treturn 0;\n}\n\nstatic int brcmstb_gpio_priv_set_wake(struct brcmstb_gpio_priv *priv,\n\t\tunsigned int enable)\n{\n\tint ret = 0;\n\n\tif (enable)\n\t\tret = enable_irq_wake(priv->parent_wake_irq);\n\telse\n\t\tret = disable_irq_wake(priv->parent_wake_irq);\n\tif (ret)\n\t\tdev_err(&priv->pdev->dev, \"failed to %s wake-up interrupt\\n\",\n\t\t\t\tenable ? \"enable\" : \"disable\");\n\treturn ret;\n}\n\nstatic int brcmstb_gpio_irq_set_wake(struct irq_data *d, unsigned int enable)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct brcmstb_gpio_bank *bank = gpiochip_get_data(gc);\n\tstruct brcmstb_gpio_priv *priv = bank->parent_priv;\n\tu32 mask = BIT(brcmstb_gpio_hwirq_to_offset(d->hwirq, bank));\n\n\t \n\tif (enable)\n\t\tbank->wake_active |= mask;\n\telse\n\t\tbank->wake_active &= ~mask;\n\n\treturn brcmstb_gpio_priv_set_wake(priv, enable);\n}\n\nstatic irqreturn_t brcmstb_gpio_wake_irq_handler(int irq, void *data)\n{\n\tstruct brcmstb_gpio_priv *priv = data;\n\n\tif (!priv || irq != priv->parent_wake_irq)\n\t\treturn IRQ_NONE;\n\n\t \n\treturn IRQ_HANDLED;\n}\n\nstatic void brcmstb_gpio_irq_bank_handler(struct brcmstb_gpio_bank *bank)\n{\n\tstruct brcmstb_gpio_priv *priv = bank->parent_priv;\n\tstruct irq_domain *domain = priv->irq_domain;\n\tint hwbase = bank->gc.base - priv->gpio_base;\n\tunsigned long status;\n\n\twhile ((status = brcmstb_gpio_get_active_irqs(bank))) {\n\t\tunsigned int offset;\n\n\t\tfor_each_set_bit(offset, &status, 32) {\n\t\t\tif (offset >= bank->width)\n\t\t\t\tdev_warn(&priv->pdev->dev,\n\t\t\t\t\t \"IRQ for invalid GPIO (bank=%d, offset=%d)\\n\",\n\t\t\t\t\t bank->id, offset);\n\t\t\tgeneric_handle_domain_irq(domain, hwbase + offset);\n\t\t}\n\t}\n}\n\n \nstatic void brcmstb_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct brcmstb_gpio_priv *priv = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct brcmstb_gpio_bank *bank;\n\n\t \n\tBUG_ON(!priv || !chip);\n\n\tchained_irq_enter(chip, desc);\n\tlist_for_each_entry(bank, &priv->bank_list, node)\n\t\tbrcmstb_gpio_irq_bank_handler(bank);\n\tchained_irq_exit(chip, desc);\n}\n\nstatic struct brcmstb_gpio_bank *brcmstb_gpio_hwirq_to_bank(\n\t\tstruct brcmstb_gpio_priv *priv, irq_hw_number_t hwirq)\n{\n\tstruct brcmstb_gpio_bank *bank;\n\tint i = 0;\n\n\t \n\tlist_for_each_entry_reverse(bank, &priv->bank_list, node) {\n\t\ti += bank->gc.ngpio;\n\t\tif (hwirq < i)\n\t\t\treturn bank;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct lock_class_key brcmstb_gpio_irq_lock_class;\nstatic struct lock_class_key brcmstb_gpio_irq_request_class;\n\n\nstatic int brcmstb_gpio_irq_map(struct irq_domain *d, unsigned int irq,\n\t\tirq_hw_number_t hwirq)\n{\n\tstruct brcmstb_gpio_priv *priv = d->host_data;\n\tstruct brcmstb_gpio_bank *bank =\n\t\tbrcmstb_gpio_hwirq_to_bank(priv, hwirq);\n\tstruct platform_device *pdev = priv->pdev;\n\tint ret;\n\n\tif (!bank)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&pdev->dev, \"Mapping irq %d for gpio line %d (bank %d)\\n\",\n\t\tirq, (int)hwirq, bank->id);\n\tret = irq_set_chip_data(irq, &bank->gc);\n\tif (ret < 0)\n\t\treturn ret;\n\tirq_set_lockdep_class(irq, &brcmstb_gpio_irq_lock_class,\n\t\t\t      &brcmstb_gpio_irq_request_class);\n\tirq_set_chip_and_handler(irq, &priv->irq_chip, handle_level_irq);\n\tirq_set_noprobe(irq);\n\treturn 0;\n}\n\nstatic void brcmstb_gpio_irq_unmap(struct irq_domain *d, unsigned int irq)\n{\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\tirq_set_chip_data(irq, NULL);\n}\n\nstatic const struct irq_domain_ops brcmstb_gpio_irq_domain_ops = {\n\t.map = brcmstb_gpio_irq_map,\n\t.unmap = brcmstb_gpio_irq_unmap,\n\t.xlate = irq_domain_xlate_twocell,\n};\n\n \nstatic int brcmstb_gpio_sanity_check_banks(struct device *dev,\n\t\tstruct device_node *np, struct resource *res)\n{\n\tint res_num_banks = resource_size(res) / GIO_BANK_SIZE;\n\tint num_banks =\n\t\tof_property_count_u32_elems(np, \"brcm,gpio-bank-widths\");\n\n\tif (res_num_banks != num_banks) {\n\t\tdev_err(dev, \"Mismatch in banks: res had %d, bank-widths had %d\\n\",\n\t\t\t\tres_num_banks, num_banks);\n\t\treturn -EINVAL;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic int brcmstb_gpio_remove(struct platform_device *pdev)\n{\n\tstruct brcmstb_gpio_priv *priv = platform_get_drvdata(pdev);\n\tstruct brcmstb_gpio_bank *bank;\n\tint offset, virq;\n\n\tif (priv->parent_irq > 0)\n\t\tirq_set_chained_handler_and_data(priv->parent_irq, NULL, NULL);\n\n\t \n\tif (priv->irq_domain) {\n\t\tfor (offset = 0; offset < priv->num_gpios; offset++) {\n\t\t\tvirq = irq_find_mapping(priv->irq_domain, offset);\n\t\t\tirq_dispose_mapping(virq);\n\t\t}\n\t\tirq_domain_remove(priv->irq_domain);\n\t}\n\n\t \n\tlist_for_each_entry(bank, &priv->bank_list, node)\n\t\tgpiochip_remove(&bank->gc);\n\n\treturn 0;\n}\n\nstatic int brcmstb_gpio_of_xlate(struct gpio_chip *gc,\n\t\tconst struct of_phandle_args *gpiospec, u32 *flags)\n{\n\tstruct brcmstb_gpio_priv *priv = brcmstb_gpio_gc_to_priv(gc);\n\tstruct brcmstb_gpio_bank *bank = gpiochip_get_data(gc);\n\tint offset;\n\n\tif (gc->of_gpio_n_cells != 2) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (WARN_ON(gpiospec->args_count < gc->of_gpio_n_cells))\n\t\treturn -EINVAL;\n\n\toffset = gpiospec->args[0] - (gc->base - priv->gpio_base);\n\tif (offset >= gc->ngpio || offset < 0)\n\t\treturn -EINVAL;\n\n\tif (unlikely(offset >= bank->width)) {\n\t\tdev_warn_ratelimited(&priv->pdev->dev,\n\t\t\t\"Received request for invalid GPIO offset %d\\n\",\n\t\t\tgpiospec->args[0]);\n\t}\n\n\tif (flags)\n\t\t*flags = gpiospec->args[1];\n\n\treturn offset;\n}\n\n \nstatic int brcmstb_gpio_irq_setup(struct platform_device *pdev,\n\t\tstruct brcmstb_gpio_priv *priv)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint err;\n\n\tpriv->irq_domain =\n\t\tirq_domain_add_linear(np, priv->num_gpios,\n\t\t\t\t      &brcmstb_gpio_irq_domain_ops,\n\t\t\t\t      priv);\n\tif (!priv->irq_domain) {\n\t\tdev_err(dev, \"Couldn't allocate IRQ domain\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_bool(np, \"wakeup-source\")) {\n\t\tpriv->parent_wake_irq = platform_get_irq(pdev, 1);\n\t\tif (priv->parent_wake_irq < 0) {\n\t\t\tpriv->parent_wake_irq = 0;\n\t\t\tdev_warn(dev,\n\t\t\t\t\"Couldn't get wake IRQ - GPIOs will not be able to wake from sleep\");\n\t\t} else {\n\t\t\t \n\t\t\tdevice_set_wakeup_capable(dev, true);\n\t\t\tdevice_wakeup_enable(dev);\n\t\t\terr = devm_request_irq(dev, priv->parent_wake_irq,\n\t\t\t\t\t       brcmstb_gpio_wake_irq_handler,\n\t\t\t\t\t       IRQF_SHARED,\n\t\t\t\t\t       \"brcmstb-gpio-wake\", priv);\n\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(dev, \"Couldn't request wake IRQ\");\n\t\t\t\tgoto out_free_domain;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriv->irq_chip.name = dev_name(dev);\n\tpriv->irq_chip.irq_disable = brcmstb_gpio_irq_mask;\n\tpriv->irq_chip.irq_mask = brcmstb_gpio_irq_mask;\n\tpriv->irq_chip.irq_unmask = brcmstb_gpio_irq_unmask;\n\tpriv->irq_chip.irq_ack = brcmstb_gpio_irq_ack;\n\tpriv->irq_chip.irq_set_type = brcmstb_gpio_irq_set_type;\n\n\tif (priv->parent_wake_irq)\n\t\tpriv->irq_chip.irq_set_wake = brcmstb_gpio_irq_set_wake;\n\n\tirq_set_chained_handler_and_data(priv->parent_irq,\n\t\t\t\t\t brcmstb_gpio_irq_handler, priv);\n\tirq_set_status_flags(priv->parent_irq, IRQ_DISABLE_UNLAZY);\n\n\treturn 0;\n\nout_free_domain:\n\tirq_domain_remove(priv->irq_domain);\n\n\treturn err;\n}\n\nstatic void brcmstb_gpio_bank_save(struct brcmstb_gpio_priv *priv,\n\t\t\t\t   struct brcmstb_gpio_bank *bank)\n{\n\tstruct gpio_chip *gc = &bank->gc;\n\tunsigned int i;\n\n\tfor (i = 0; i < GIO_REG_STAT; i++)\n\t\tbank->saved_regs[i] = gc->read_reg(priv->reg_base +\n\t\t\t\t\t\t   GIO_BANK_OFF(bank->id, i));\n}\n\nstatic void brcmstb_gpio_quiesce(struct device *dev, bool save)\n{\n\tstruct brcmstb_gpio_priv *priv = dev_get_drvdata(dev);\n\tstruct brcmstb_gpio_bank *bank;\n\tstruct gpio_chip *gc;\n\tu32 imask;\n\n\t \n\tif (priv->parent_irq >= 0)\n\t\tdisable_irq(priv->parent_irq);\n\n\tlist_for_each_entry(bank, &priv->bank_list, node) {\n\t\tgc = &bank->gc;\n\n\t\tif (save)\n\t\t\tbrcmstb_gpio_bank_save(priv, bank);\n\n\t\t \n\t\tif (priv->parent_wake_irq)\n\t\t\timask = bank->wake_active;\n\t\telse\n\t\t\timask = 0;\n\t\tgc->write_reg(priv->reg_base + GIO_MASK(bank->id),\n\t\t\t       imask);\n\t}\n}\n\nstatic void brcmstb_gpio_shutdown(struct platform_device *pdev)\n{\n\t \n\tbrcmstb_gpio_quiesce(&pdev->dev, false);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void brcmstb_gpio_bank_restore(struct brcmstb_gpio_priv *priv,\n\t\t\t\t      struct brcmstb_gpio_bank *bank)\n{\n\tstruct gpio_chip *gc = &bank->gc;\n\tunsigned int i;\n\n\tfor (i = 0; i < GIO_REG_STAT; i++)\n\t\tgc->write_reg(priv->reg_base + GIO_BANK_OFF(bank->id, i),\n\t\t\t      bank->saved_regs[i]);\n}\n\nstatic int brcmstb_gpio_suspend(struct device *dev)\n{\n\tbrcmstb_gpio_quiesce(dev, true);\n\treturn 0;\n}\n\nstatic int brcmstb_gpio_resume(struct device *dev)\n{\n\tstruct brcmstb_gpio_priv *priv = dev_get_drvdata(dev);\n\tstruct brcmstb_gpio_bank *bank;\n\tbool need_wakeup_event = false;\n\n\tlist_for_each_entry(bank, &priv->bank_list, node) {\n\t\tneed_wakeup_event |= !!__brcmstb_gpio_get_active_irqs(bank);\n\t\tbrcmstb_gpio_bank_restore(priv, bank);\n\t}\n\n\tif (priv->parent_wake_irq && need_wakeup_event)\n\t\tpm_wakeup_event(dev, 0);\n\n\t \n\tif (priv->parent_irq >= 0)\n\t\tenable_irq(priv->parent_irq);\n\n\treturn 0;\n}\n\n#else\n#define brcmstb_gpio_suspend\tNULL\n#define brcmstb_gpio_resume\tNULL\n#endif  \n\nstatic const struct dev_pm_ops brcmstb_gpio_pm_ops = {\n\t.suspend_noirq\t= brcmstb_gpio_suspend,\n\t.resume_noirq = brcmstb_gpio_resume,\n};\n\nstatic int brcmstb_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tvoid __iomem *reg_base;\n\tstruct brcmstb_gpio_priv *priv;\n\tstruct resource *res;\n\tstruct property *prop;\n\tconst __be32 *p;\n\tu32 bank_width;\n\tint num_banks = 0;\n\tint err;\n\tstatic int gpio_base;\n\tunsigned long flags = 0;\n\tbool need_wakeup_event = false;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, priv);\n\tINIT_LIST_HEAD(&priv->bank_list);\n\n\treg_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(reg_base))\n\t\treturn PTR_ERR(reg_base);\n\n\tpriv->gpio_base = gpio_base;\n\tpriv->reg_base = reg_base;\n\tpriv->pdev = pdev;\n\n\tif (of_property_read_bool(np, \"interrupt-controller\")) {\n\t\tpriv->parent_irq = platform_get_irq(pdev, 0);\n\t\tif (priv->parent_irq <= 0)\n\t\t\treturn -ENOENT;\n\t} else {\n\t\tpriv->parent_irq = -ENOENT;\n\t}\n\n\tif (brcmstb_gpio_sanity_check_banks(dev, np, res))\n\t\treturn -EINVAL;\n\n\t \n#if defined(CONFIG_MIPS) && defined(__BIG_ENDIAN)\n\tflags = BGPIOF_BIG_ENDIAN_BYTE_ORDER;\n#endif\n\n\tof_property_for_each_u32(np, \"brcm,gpio-bank-widths\", prop, p,\n\t\t\tbank_width) {\n\t\tstruct brcmstb_gpio_bank *bank;\n\t\tstruct gpio_chip *gc;\n\n\t\t \n\t\tif (bank_width == 0) {\n\t\t\tdev_dbg(dev, \"Width 0 found: Empty bank @ %d\\n\",\n\t\t\t\tnum_banks);\n\t\t\tnum_banks++;\n\t\t\tgpio_base += MAX_GPIO_PER_BANK;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbank = devm_kzalloc(dev, sizeof(*bank), GFP_KERNEL);\n\t\tif (!bank) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tbank->parent_priv = priv;\n\t\tbank->id = num_banks;\n\t\tif (bank_width <= 0 || bank_width > MAX_GPIO_PER_BANK) {\n\t\t\tdev_err(dev, \"Invalid bank width %d\\n\", bank_width);\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tbank->width = bank_width;\n\t\t}\n\n\t\t \n\t\tgc = &bank->gc;\n\t\terr = bgpio_init(gc, dev, 4,\n\t\t\t\treg_base + GIO_DATA(bank->id),\n\t\t\t\tNULL, NULL, NULL,\n\t\t\t\treg_base + GIO_IODIR(bank->id), flags);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"bgpio_init() failed\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tgc->owner = THIS_MODULE;\n\t\tgc->label = devm_kasprintf(dev, GFP_KERNEL, \"%pOF\", np);\n\t\tif (!gc->label) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tgc->base = gpio_base;\n\t\tgc->of_gpio_n_cells = 2;\n\t\tgc->of_xlate = brcmstb_gpio_of_xlate;\n\t\t \n\t\tgc->ngpio = MAX_GPIO_PER_BANK;\n\t\tgc->offset = bank->id * MAX_GPIO_PER_BANK;\n\t\tif (priv->parent_irq > 0)\n\t\t\tgc->to_irq = brcmstb_gpio_to_irq;\n\n\t\t \n\t\tneed_wakeup_event |= !!__brcmstb_gpio_get_active_irqs(bank);\n\t\tgc->write_reg(reg_base + GIO_MASK(bank->id), 0);\n\n\t\terr = gpiochip_add_data(gc, bank);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Could not add gpiochip for bank %d\\n\",\n\t\t\t\t\tbank->id);\n\t\t\tgoto fail;\n\t\t}\n\t\tgpio_base += gc->ngpio;\n\n\t\tdev_dbg(dev, \"bank=%d, base=%d, ngpio=%d, width=%d\\n\", bank->id,\n\t\t\tgc->base, gc->ngpio, bank->width);\n\n\t\t \n\t\tlist_add(&bank->node, &priv->bank_list);\n\n\t\tnum_banks++;\n\t}\n\n\tpriv->num_gpios = gpio_base - priv->gpio_base;\n\tif (priv->parent_irq > 0) {\n\t\terr = brcmstb_gpio_irq_setup(pdev, priv);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\tif (priv->parent_wake_irq && need_wakeup_event)\n\t\tpm_wakeup_event(dev, 0);\n\n\treturn 0;\n\nfail:\n\t(void) brcmstb_gpio_remove(pdev);\n\treturn err;\n}\n\nstatic const struct of_device_id brcmstb_gpio_of_match[] = {\n\t{ .compatible = \"brcm,brcmstb-gpio\" },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, brcmstb_gpio_of_match);\n\nstatic struct platform_driver brcmstb_gpio_driver = {\n\t.driver = {\n\t\t.name = \"brcmstb-gpio\",\n\t\t.of_match_table = brcmstb_gpio_of_match,\n\t\t.pm = &brcmstb_gpio_pm_ops,\n\t},\n\t.probe = brcmstb_gpio_probe,\n\t.remove = brcmstb_gpio_remove,\n\t.shutdown = brcmstb_gpio_shutdown,\n};\nmodule_platform_driver(brcmstb_gpio_driver);\n\nMODULE_AUTHOR(\"Gregory Fong\");\nMODULE_DESCRIPTION(\"Driver for Broadcom BRCMSTB SoC UPG GPIO\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}