{
  "module_name": "gpio-zynq.c",
  "hash_id": "3c276a54dd5a1af045e668a182dafa1005bfe7efdf743f5dc4f24ad708f771ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-zynq.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n\n#define DRIVER_NAME \"zynq-gpio\"\n\n \n#define ZYNQ_GPIO_MAX_BANK\t4\n#define ZYNQMP_GPIO_MAX_BANK\t6\n#define VERSAL_GPIO_MAX_BANK\t4\n#define PMC_GPIO_MAX_BANK\t5\n#define VERSAL_UNUSED_BANKS\t2\n\n#define ZYNQ_GPIO_BANK0_NGPIO\t32\n#define ZYNQ_GPIO_BANK1_NGPIO\t22\n#define ZYNQ_GPIO_BANK2_NGPIO\t32\n#define ZYNQ_GPIO_BANK3_NGPIO\t32\n\n#define ZYNQMP_GPIO_BANK0_NGPIO 26\n#define ZYNQMP_GPIO_BANK1_NGPIO 26\n#define ZYNQMP_GPIO_BANK2_NGPIO 26\n#define ZYNQMP_GPIO_BANK3_NGPIO 32\n#define ZYNQMP_GPIO_BANK4_NGPIO 32\n#define ZYNQMP_GPIO_BANK5_NGPIO 32\n\n#define\tZYNQ_GPIO_NR_GPIOS\t118\n#define\tZYNQMP_GPIO_NR_GPIOS\t174\n\n#define ZYNQ_GPIO_BANK0_PIN_MIN(str)\t0\n#define ZYNQ_GPIO_BANK0_PIN_MAX(str)\t(ZYNQ_GPIO_BANK0_PIN_MIN(str) + \\\n\t\t\t\t\tZYNQ##str##_GPIO_BANK0_NGPIO - 1)\n#define ZYNQ_GPIO_BANK1_PIN_MIN(str)\t(ZYNQ_GPIO_BANK0_PIN_MAX(str) + 1)\n#define ZYNQ_GPIO_BANK1_PIN_MAX(str)\t(ZYNQ_GPIO_BANK1_PIN_MIN(str) + \\\n\t\t\t\t\tZYNQ##str##_GPIO_BANK1_NGPIO - 1)\n#define ZYNQ_GPIO_BANK2_PIN_MIN(str)\t(ZYNQ_GPIO_BANK1_PIN_MAX(str) + 1)\n#define ZYNQ_GPIO_BANK2_PIN_MAX(str)\t(ZYNQ_GPIO_BANK2_PIN_MIN(str) + \\\n\t\t\t\t\tZYNQ##str##_GPIO_BANK2_NGPIO - 1)\n#define ZYNQ_GPIO_BANK3_PIN_MIN(str)\t(ZYNQ_GPIO_BANK2_PIN_MAX(str) + 1)\n#define ZYNQ_GPIO_BANK3_PIN_MAX(str)\t(ZYNQ_GPIO_BANK3_PIN_MIN(str) + \\\n\t\t\t\t\tZYNQ##str##_GPIO_BANK3_NGPIO - 1)\n#define ZYNQ_GPIO_BANK4_PIN_MIN(str)\t(ZYNQ_GPIO_BANK3_PIN_MAX(str) + 1)\n#define ZYNQ_GPIO_BANK4_PIN_MAX(str)\t(ZYNQ_GPIO_BANK4_PIN_MIN(str) + \\\n\t\t\t\t\tZYNQ##str##_GPIO_BANK4_NGPIO - 1)\n#define ZYNQ_GPIO_BANK5_PIN_MIN(str)\t(ZYNQ_GPIO_BANK4_PIN_MAX(str) + 1)\n#define ZYNQ_GPIO_BANK5_PIN_MAX(str)\t(ZYNQ_GPIO_BANK5_PIN_MIN(str) + \\\n\t\t\t\t\tZYNQ##str##_GPIO_BANK5_NGPIO - 1)\n\n \n \n#define ZYNQ_GPIO_DATA_LSW_OFFSET(BANK)\t(0x000 + (8 * BANK))\n \n#define ZYNQ_GPIO_DATA_MSW_OFFSET(BANK)\t(0x004 + (8 * BANK))\n \n#define ZYNQ_GPIO_DATA_OFFSET(BANK)\t(0x040 + (4 * BANK))\n#define ZYNQ_GPIO_DATA_RO_OFFSET(BANK)\t(0x060 + (4 * BANK))\n \n#define ZYNQ_GPIO_DIRM_OFFSET(BANK)\t(0x204 + (0x40 * BANK))\n \n#define ZYNQ_GPIO_OUTEN_OFFSET(BANK)\t(0x208 + (0x40 * BANK))\n \n#define ZYNQ_GPIO_INTMASK_OFFSET(BANK)\t(0x20C + (0x40 * BANK))\n \n#define ZYNQ_GPIO_INTEN_OFFSET(BANK)\t(0x210 + (0x40 * BANK))\n \n#define ZYNQ_GPIO_INTDIS_OFFSET(BANK)\t(0x214 + (0x40 * BANK))\n \n#define ZYNQ_GPIO_INTSTS_OFFSET(BANK)\t(0x218 + (0x40 * BANK))\n \n#define ZYNQ_GPIO_INTTYPE_OFFSET(BANK)\t(0x21C + (0x40 * BANK))\n \n#define ZYNQ_GPIO_INTPOL_OFFSET(BANK)\t(0x220 + (0x40 * BANK))\n \n#define ZYNQ_GPIO_INTANY_OFFSET(BANK)\t(0x224 + (0x40 * BANK))\n\n \n#define ZYNQ_GPIO_IXR_DISABLE_ALL\t0xFFFFFFFF\n\n \n#define ZYNQ_GPIO_MID_PIN_NUM 16\n\n \n#define ZYNQ_GPIO_UPPER_MASK 0xFFFF0000\n\n \n#define ZYNQ_GPIO_QUIRK_IS_ZYNQ\tBIT(0)\n#define GPIO_QUIRK_DATA_RO_BUG\tBIT(1)\n#define GPIO_QUIRK_VERSAL\tBIT(2)\n\nstruct gpio_regs {\n\tu32 datamsw[ZYNQMP_GPIO_MAX_BANK];\n\tu32 datalsw[ZYNQMP_GPIO_MAX_BANK];\n\tu32 dirm[ZYNQMP_GPIO_MAX_BANK];\n\tu32 outen[ZYNQMP_GPIO_MAX_BANK];\n\tu32 int_en[ZYNQMP_GPIO_MAX_BANK];\n\tu32 int_dis[ZYNQMP_GPIO_MAX_BANK];\n\tu32 int_type[ZYNQMP_GPIO_MAX_BANK];\n\tu32 int_polarity[ZYNQMP_GPIO_MAX_BANK];\n\tu32 int_any[ZYNQMP_GPIO_MAX_BANK];\n};\n\n \nstruct zynq_gpio {\n\tstruct gpio_chip chip;\n\tvoid __iomem *base_addr;\n\tstruct clk *clk;\n\tint irq;\n\tconst struct zynq_platform_data *p_data;\n\tstruct gpio_regs context;\n\tspinlock_t dirlock;  \n};\n\n \nstruct zynq_platform_data {\n\tconst char *label;\n\tu32 quirks;\n\tu16 ngpio;\n\tint max_bank;\n\tint bank_min[ZYNQMP_GPIO_MAX_BANK];\n\tint bank_max[ZYNQMP_GPIO_MAX_BANK];\n};\n\nstatic const struct irq_chip zynq_gpio_level_irqchip;\nstatic const struct irq_chip zynq_gpio_edge_irqchip;\n\n \nstatic int zynq_gpio_is_zynq(struct zynq_gpio *gpio)\n{\n\treturn !!(gpio->p_data->quirks & ZYNQ_GPIO_QUIRK_IS_ZYNQ);\n}\n\n \nstatic int gpio_data_ro_bug(struct zynq_gpio *gpio)\n{\n\treturn !!(gpio->p_data->quirks & GPIO_QUIRK_DATA_RO_BUG);\n}\n\n \nstatic inline void zynq_gpio_get_bank_pin(unsigned int pin_num,\n\t\t\t\t\t  unsigned int *bank_num,\n\t\t\t\t\t  unsigned int *bank_pin_num,\n\t\t\t\t\t  struct zynq_gpio *gpio)\n{\n\tint bank;\n\n\tfor (bank = 0; bank < gpio->p_data->max_bank; bank++) {\n\t\tif ((pin_num >= gpio->p_data->bank_min[bank]) &&\n\t\t    (pin_num <= gpio->p_data->bank_max[bank])) {\n\t\t\t*bank_num = bank;\n\t\t\t*bank_pin_num = pin_num -\n\t\t\t\t\tgpio->p_data->bank_min[bank];\n\t\t\treturn;\n\t\t}\n\t\tif (gpio->p_data->quirks & GPIO_QUIRK_VERSAL)\n\t\t\tbank = bank + VERSAL_UNUSED_BANKS;\n\t}\n\n\t \n\tWARN(true, \"invalid GPIO pin number: %u\", pin_num);\n\t*bank_num = 0;\n\t*bank_pin_num = 0;\n}\n\n \nstatic int zynq_gpio_get_value(struct gpio_chip *chip, unsigned int pin)\n{\n\tu32 data;\n\tunsigned int bank_num, bank_pin_num;\n\tstruct zynq_gpio *gpio = gpiochip_get_data(chip);\n\n\tzynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num, gpio);\n\n\tif (gpio_data_ro_bug(gpio)) {\n\t\tif (zynq_gpio_is_zynq(gpio)) {\n\t\t\tif (bank_num <= 1) {\n\t\t\t\tdata = readl_relaxed(gpio->base_addr +\n\t\t\t\t\tZYNQ_GPIO_DATA_RO_OFFSET(bank_num));\n\t\t\t} else {\n\t\t\t\tdata = readl_relaxed(gpio->base_addr +\n\t\t\t\t\tZYNQ_GPIO_DATA_OFFSET(bank_num));\n\t\t\t}\n\t\t} else {\n\t\t\tif (bank_num <= 2) {\n\t\t\t\tdata = readl_relaxed(gpio->base_addr +\n\t\t\t\t\tZYNQ_GPIO_DATA_RO_OFFSET(bank_num));\n\t\t\t} else {\n\t\t\t\tdata = readl_relaxed(gpio->base_addr +\n\t\t\t\t\tZYNQ_GPIO_DATA_OFFSET(bank_num));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdata = readl_relaxed(gpio->base_addr +\n\t\t\tZYNQ_GPIO_DATA_RO_OFFSET(bank_num));\n\t}\n\treturn (data >> bank_pin_num) & 1;\n}\n\n \nstatic void zynq_gpio_set_value(struct gpio_chip *chip, unsigned int pin,\n\t\t\t\tint state)\n{\n\tunsigned int reg_offset, bank_num, bank_pin_num;\n\tstruct zynq_gpio *gpio = gpiochip_get_data(chip);\n\n\tzynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num, gpio);\n\n\tif (bank_pin_num >= ZYNQ_GPIO_MID_PIN_NUM) {\n\t\t \n\t\tbank_pin_num -= ZYNQ_GPIO_MID_PIN_NUM;\n\t\treg_offset = ZYNQ_GPIO_DATA_MSW_OFFSET(bank_num);\n\t} else {\n\t\treg_offset = ZYNQ_GPIO_DATA_LSW_OFFSET(bank_num);\n\t}\n\n\t \n\tstate = !!state;\n\tstate = ~(1 << (bank_pin_num + ZYNQ_GPIO_MID_PIN_NUM)) &\n\t\t((state << bank_pin_num) | ZYNQ_GPIO_UPPER_MASK);\n\n\twritel_relaxed(state, gpio->base_addr + reg_offset);\n}\n\n \nstatic int zynq_gpio_dir_in(struct gpio_chip *chip, unsigned int pin)\n{\n\tu32 reg;\n\tunsigned int bank_num, bank_pin_num;\n\tunsigned long flags;\n\tstruct zynq_gpio *gpio = gpiochip_get_data(chip);\n\n\tzynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num, gpio);\n\n\t \n\tif (zynq_gpio_is_zynq(gpio) && bank_num == 0 &&\n\t    (bank_pin_num == 7 || bank_pin_num == 8))\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock_irqsave(&gpio->dirlock, flags);\n\treg = readl_relaxed(gpio->base_addr + ZYNQ_GPIO_DIRM_OFFSET(bank_num));\n\treg &= ~BIT(bank_pin_num);\n\twritel_relaxed(reg, gpio->base_addr + ZYNQ_GPIO_DIRM_OFFSET(bank_num));\n\tspin_unlock_irqrestore(&gpio->dirlock, flags);\n\n\treturn 0;\n}\n\n \nstatic int zynq_gpio_dir_out(struct gpio_chip *chip, unsigned int pin,\n\t\t\t     int state)\n{\n\tu32 reg;\n\tunsigned int bank_num, bank_pin_num;\n\tunsigned long flags;\n\tstruct zynq_gpio *gpio = gpiochip_get_data(chip);\n\n\tzynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num, gpio);\n\n\t \n\tspin_lock_irqsave(&gpio->dirlock, flags);\n\treg = readl_relaxed(gpio->base_addr + ZYNQ_GPIO_DIRM_OFFSET(bank_num));\n\treg |= BIT(bank_pin_num);\n\twritel_relaxed(reg, gpio->base_addr + ZYNQ_GPIO_DIRM_OFFSET(bank_num));\n\n\t \n\treg = readl_relaxed(gpio->base_addr + ZYNQ_GPIO_OUTEN_OFFSET(bank_num));\n\treg |= BIT(bank_pin_num);\n\twritel_relaxed(reg, gpio->base_addr + ZYNQ_GPIO_OUTEN_OFFSET(bank_num));\n\tspin_unlock_irqrestore(&gpio->dirlock, flags);\n\n\t \n\tzynq_gpio_set_value(chip, pin, state);\n\treturn 0;\n}\n\n \nstatic int zynq_gpio_get_direction(struct gpio_chip *chip, unsigned int pin)\n{\n\tu32 reg;\n\tunsigned int bank_num, bank_pin_num;\n\tstruct zynq_gpio *gpio = gpiochip_get_data(chip);\n\n\tzynq_gpio_get_bank_pin(pin, &bank_num, &bank_pin_num, gpio);\n\n\treg = readl_relaxed(gpio->base_addr + ZYNQ_GPIO_DIRM_OFFSET(bank_num));\n\n\tif (reg & BIT(bank_pin_num))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\n \nstatic void zynq_gpio_irq_mask(struct irq_data *irq_data)\n{\n\tunsigned int device_pin_num, bank_num, bank_pin_num;\n\tconst unsigned long offset = irqd_to_hwirq(irq_data);\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(irq_data);\n\tstruct zynq_gpio *gpio =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(irq_data));\n\n\tgpiochip_disable_irq(chip, offset);\n\tdevice_pin_num = irq_data->hwirq;\n\tzynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num, gpio);\n\twritel_relaxed(BIT(bank_pin_num),\n\t\t       gpio->base_addr + ZYNQ_GPIO_INTDIS_OFFSET(bank_num));\n}\n\n \nstatic void zynq_gpio_irq_unmask(struct irq_data *irq_data)\n{\n\tunsigned int device_pin_num, bank_num, bank_pin_num;\n\tconst unsigned long offset = irqd_to_hwirq(irq_data);\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(irq_data);\n\tstruct zynq_gpio *gpio =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(irq_data));\n\n\tgpiochip_enable_irq(chip, offset);\n\tdevice_pin_num = irq_data->hwirq;\n\tzynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num, gpio);\n\twritel_relaxed(BIT(bank_pin_num),\n\t\t       gpio->base_addr + ZYNQ_GPIO_INTEN_OFFSET(bank_num));\n}\n\n \nstatic void zynq_gpio_irq_ack(struct irq_data *irq_data)\n{\n\tunsigned int device_pin_num, bank_num, bank_pin_num;\n\tstruct zynq_gpio *gpio =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(irq_data));\n\n\tdevice_pin_num = irq_data->hwirq;\n\tzynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num, gpio);\n\twritel_relaxed(BIT(bank_pin_num),\n\t\t       gpio->base_addr + ZYNQ_GPIO_INTSTS_OFFSET(bank_num));\n}\n\n \nstatic void zynq_gpio_irq_enable(struct irq_data *irq_data)\n{\n\t \n\tzynq_gpio_irq_ack(irq_data);\n\tzynq_gpio_irq_unmask(irq_data);\n}\n\n \nstatic int zynq_gpio_set_irq_type(struct irq_data *irq_data, unsigned int type)\n{\n\tu32 int_type, int_pol, int_any;\n\tunsigned int device_pin_num, bank_num, bank_pin_num;\n\tstruct zynq_gpio *gpio =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(irq_data));\n\n\tdevice_pin_num = irq_data->hwirq;\n\tzynq_gpio_get_bank_pin(device_pin_num, &bank_num, &bank_pin_num, gpio);\n\n\tint_type = readl_relaxed(gpio->base_addr +\n\t\t\t\t ZYNQ_GPIO_INTTYPE_OFFSET(bank_num));\n\tint_pol = readl_relaxed(gpio->base_addr +\n\t\t\t\tZYNQ_GPIO_INTPOL_OFFSET(bank_num));\n\tint_any = readl_relaxed(gpio->base_addr +\n\t\t\t\tZYNQ_GPIO_INTANY_OFFSET(bank_num));\n\n\t \n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tint_type |= BIT(bank_pin_num);\n\t\tint_pol |= BIT(bank_pin_num);\n\t\tint_any &= ~BIT(bank_pin_num);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tint_type |= BIT(bank_pin_num);\n\t\tint_pol &= ~BIT(bank_pin_num);\n\t\tint_any &= ~BIT(bank_pin_num);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tint_type |= BIT(bank_pin_num);\n\t\tint_any |= BIT(bank_pin_num);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tint_type &= ~BIT(bank_pin_num);\n\t\tint_pol |= BIT(bank_pin_num);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tint_type &= ~BIT(bank_pin_num);\n\t\tint_pol &= ~BIT(bank_pin_num);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twritel_relaxed(int_type,\n\t\t       gpio->base_addr + ZYNQ_GPIO_INTTYPE_OFFSET(bank_num));\n\twritel_relaxed(int_pol,\n\t\t       gpio->base_addr + ZYNQ_GPIO_INTPOL_OFFSET(bank_num));\n\twritel_relaxed(int_any,\n\t\t       gpio->base_addr + ZYNQ_GPIO_INTANY_OFFSET(bank_num));\n\n\tif (type & IRQ_TYPE_LEVEL_MASK)\n\t\tirq_set_chip_handler_name_locked(irq_data,\n\t\t\t\t\t\t &zynq_gpio_level_irqchip,\n\t\t\t\t\t\t handle_fasteoi_irq, NULL);\n\telse\n\t\tirq_set_chip_handler_name_locked(irq_data,\n\t\t\t\t\t\t &zynq_gpio_edge_irqchip,\n\t\t\t\t\t\t handle_level_irq, NULL);\n\n\treturn 0;\n}\n\nstatic int zynq_gpio_set_wake(struct irq_data *data, unsigned int on)\n{\n\tstruct zynq_gpio *gpio =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(data));\n\n\tirq_set_irq_wake(gpio->irq, on);\n\n\treturn 0;\n}\n\nstatic int zynq_gpio_irq_reqres(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(chip->parent);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn gpiochip_reqres_irq(chip, d->hwirq);\n}\n\nstatic void zynq_gpio_irq_relres(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_relres_irq(chip, d->hwirq);\n\tpm_runtime_put(chip->parent);\n}\n\n \nstatic const struct irq_chip zynq_gpio_level_irqchip = {\n\t.name\t\t= DRIVER_NAME,\n\t.irq_enable\t= zynq_gpio_irq_enable,\n\t.irq_eoi\t= zynq_gpio_irq_ack,\n\t.irq_mask\t= zynq_gpio_irq_mask,\n\t.irq_unmask\t= zynq_gpio_irq_unmask,\n\t.irq_set_type\t= zynq_gpio_set_irq_type,\n\t.irq_set_wake\t= zynq_gpio_set_wake,\n\t.irq_request_resources = zynq_gpio_irq_reqres,\n\t.irq_release_resources = zynq_gpio_irq_relres,\n\t.flags\t\t= IRQCHIP_EOI_THREADED | IRQCHIP_EOI_IF_HANDLED |\n\t\t\t  IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_IMMUTABLE,\n};\n\nstatic const struct irq_chip zynq_gpio_edge_irqchip = {\n\t.name\t\t= DRIVER_NAME,\n\t.irq_enable\t= zynq_gpio_irq_enable,\n\t.irq_ack\t= zynq_gpio_irq_ack,\n\t.irq_mask\t= zynq_gpio_irq_mask,\n\t.irq_unmask\t= zynq_gpio_irq_unmask,\n\t.irq_set_type\t= zynq_gpio_set_irq_type,\n\t.irq_set_wake\t= zynq_gpio_set_wake,\n\t.irq_request_resources = zynq_gpio_irq_reqres,\n\t.irq_release_resources = zynq_gpio_irq_relres,\n\t.flags\t\t= IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_IMMUTABLE,\n};\n\nstatic void zynq_gpio_handle_bank_irq(struct zynq_gpio *gpio,\n\t\t\t\t      unsigned int bank_num,\n\t\t\t\t      unsigned long pending)\n{\n\tunsigned int bank_offset = gpio->p_data->bank_min[bank_num];\n\tstruct irq_domain *irqdomain = gpio->chip.irq.domain;\n\tint offset;\n\n\tif (!pending)\n\t\treturn;\n\n\tfor_each_set_bit(offset, &pending, 32)\n\t\tgeneric_handle_domain_irq(irqdomain, offset + bank_offset);\n}\n\n \nstatic void zynq_gpio_irqhandler(struct irq_desc *desc)\n{\n\tu32 int_sts, int_enb;\n\tunsigned int bank_num;\n\tstruct zynq_gpio *gpio =\n\t\tgpiochip_get_data(irq_desc_get_handler_data(desc));\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\n\tchained_irq_enter(irqchip, desc);\n\n\tfor (bank_num = 0; bank_num < gpio->p_data->max_bank; bank_num++) {\n\t\tint_sts = readl_relaxed(gpio->base_addr +\n\t\t\t\t\tZYNQ_GPIO_INTSTS_OFFSET(bank_num));\n\t\tint_enb = readl_relaxed(gpio->base_addr +\n\t\t\t\t\tZYNQ_GPIO_INTMASK_OFFSET(bank_num));\n\t\tzynq_gpio_handle_bank_irq(gpio, bank_num, int_sts & ~int_enb);\n\t\tif (gpio->p_data->quirks & GPIO_QUIRK_VERSAL)\n\t\t\tbank_num = bank_num + VERSAL_UNUSED_BANKS;\n\t}\n\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic void zynq_gpio_save_context(struct zynq_gpio *gpio)\n{\n\tunsigned int bank_num;\n\n\tfor (bank_num = 0; bank_num < gpio->p_data->max_bank; bank_num++) {\n\t\tgpio->context.datalsw[bank_num] =\n\t\t\t\treadl_relaxed(gpio->base_addr +\n\t\t\t\tZYNQ_GPIO_DATA_LSW_OFFSET(bank_num));\n\t\tgpio->context.datamsw[bank_num] =\n\t\t\t\treadl_relaxed(gpio->base_addr +\n\t\t\t\tZYNQ_GPIO_DATA_MSW_OFFSET(bank_num));\n\t\tgpio->context.dirm[bank_num] = readl_relaxed(gpio->base_addr +\n\t\t\t\tZYNQ_GPIO_DIRM_OFFSET(bank_num));\n\t\tgpio->context.int_en[bank_num] = readl_relaxed(gpio->base_addr +\n\t\t\t\tZYNQ_GPIO_INTMASK_OFFSET(bank_num));\n\t\tgpio->context.int_type[bank_num] =\n\t\t\t\treadl_relaxed(gpio->base_addr +\n\t\t\t\tZYNQ_GPIO_INTTYPE_OFFSET(bank_num));\n\t\tgpio->context.int_polarity[bank_num] =\n\t\t\t\treadl_relaxed(gpio->base_addr +\n\t\t\t\tZYNQ_GPIO_INTPOL_OFFSET(bank_num));\n\t\tgpio->context.int_any[bank_num] =\n\t\t\t\treadl_relaxed(gpio->base_addr +\n\t\t\t\tZYNQ_GPIO_INTANY_OFFSET(bank_num));\n\t\tif (gpio->p_data->quirks & GPIO_QUIRK_VERSAL)\n\t\t\tbank_num = bank_num + VERSAL_UNUSED_BANKS;\n\t}\n}\n\nstatic void zynq_gpio_restore_context(struct zynq_gpio *gpio)\n{\n\tunsigned int bank_num;\n\n\tfor (bank_num = 0; bank_num < gpio->p_data->max_bank; bank_num++) {\n\t\twritel_relaxed(ZYNQ_GPIO_IXR_DISABLE_ALL, gpio->base_addr +\n\t\t\t\tZYNQ_GPIO_INTDIS_OFFSET(bank_num));\n\t\twritel_relaxed(gpio->context.datalsw[bank_num],\n\t\t\t       gpio->base_addr +\n\t\t\t       ZYNQ_GPIO_DATA_LSW_OFFSET(bank_num));\n\t\twritel_relaxed(gpio->context.datamsw[bank_num],\n\t\t\t       gpio->base_addr +\n\t\t\t       ZYNQ_GPIO_DATA_MSW_OFFSET(bank_num));\n\t\twritel_relaxed(gpio->context.dirm[bank_num],\n\t\t\t       gpio->base_addr +\n\t\t\t       ZYNQ_GPIO_DIRM_OFFSET(bank_num));\n\t\twritel_relaxed(gpio->context.int_type[bank_num],\n\t\t\t       gpio->base_addr +\n\t\t\t       ZYNQ_GPIO_INTTYPE_OFFSET(bank_num));\n\t\twritel_relaxed(gpio->context.int_polarity[bank_num],\n\t\t\t       gpio->base_addr +\n\t\t\t       ZYNQ_GPIO_INTPOL_OFFSET(bank_num));\n\t\twritel_relaxed(gpio->context.int_any[bank_num],\n\t\t\t       gpio->base_addr +\n\t\t\t       ZYNQ_GPIO_INTANY_OFFSET(bank_num));\n\t\twritel_relaxed(~(gpio->context.int_en[bank_num]),\n\t\t\t       gpio->base_addr +\n\t\t\t       ZYNQ_GPIO_INTEN_OFFSET(bank_num));\n\t\tif (gpio->p_data->quirks & GPIO_QUIRK_VERSAL)\n\t\t\tbank_num = bank_num + VERSAL_UNUSED_BANKS;\n\t}\n}\n\nstatic int __maybe_unused zynq_gpio_suspend(struct device *dev)\n{\n\tstruct zynq_gpio *gpio = dev_get_drvdata(dev);\n\tstruct irq_data *data = irq_get_irq_data(gpio->irq);\n\n\tif (!data) {\n\t\tdev_err(dev, \"irq_get_irq_data() failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!device_may_wakeup(dev))\n\t\tdisable_irq(gpio->irq);\n\n\tif (!irqd_is_wakeup_set(data)) {\n\t\tzynq_gpio_save_context(gpio);\n\t\treturn pm_runtime_force_suspend(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused zynq_gpio_resume(struct device *dev)\n{\n\tstruct zynq_gpio *gpio = dev_get_drvdata(dev);\n\tstruct irq_data *data = irq_get_irq_data(gpio->irq);\n\tint ret;\n\n\tif (!data) {\n\t\tdev_err(dev, \"irq_get_irq_data() failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!device_may_wakeup(dev))\n\t\tenable_irq(gpio->irq);\n\n\tif (!irqd_is_wakeup_set(data)) {\n\t\tret = pm_runtime_force_resume(dev);\n\t\tzynq_gpio_restore_context(gpio);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused zynq_gpio_runtime_suspend(struct device *dev)\n{\n\tstruct zynq_gpio *gpio = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(gpio->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused zynq_gpio_runtime_resume(struct device *dev)\n{\n\tstruct zynq_gpio *gpio = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(gpio->clk);\n}\n\nstatic int zynq_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tint ret;\n\n\tret = pm_runtime_get_sync(chip->parent);\n\n\t \n\treturn ret < 0 ? ret : 0;\n}\n\nstatic void zynq_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tpm_runtime_put(chip->parent);\n}\n\nstatic const struct dev_pm_ops zynq_gpio_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(zynq_gpio_suspend, zynq_gpio_resume)\n\tSET_RUNTIME_PM_OPS(zynq_gpio_runtime_suspend,\n\t\t\t   zynq_gpio_runtime_resume, NULL)\n};\n\nstatic const struct zynq_platform_data versal_gpio_def = {\n\t.label = \"versal_gpio\",\n\t.quirks = GPIO_QUIRK_VERSAL,\n\t.ngpio = 58,\n\t.max_bank = VERSAL_GPIO_MAX_BANK,\n\t.bank_min[0] = 0,\n\t.bank_max[0] = 25,  \n\t.bank_min[3] = 26,\n\t.bank_max[3] = 57,  \n};\n\nstatic const struct zynq_platform_data pmc_gpio_def = {\n\t.label = \"pmc_gpio\",\n\t.ngpio = 116,\n\t.max_bank = PMC_GPIO_MAX_BANK,\n\t.bank_min[0] = 0,\n\t.bank_max[0] = 25,  \n\t.bank_min[1] = 26,\n\t.bank_max[1] = 51,  \n\t.bank_min[3] = 52,\n\t.bank_max[3] = 83,  \n\t.bank_min[4] = 84,\n\t.bank_max[4] = 115,  \n};\n\nstatic const struct zynq_platform_data zynqmp_gpio_def = {\n\t.label = \"zynqmp_gpio\",\n\t.quirks = GPIO_QUIRK_DATA_RO_BUG,\n\t.ngpio = ZYNQMP_GPIO_NR_GPIOS,\n\t.max_bank = ZYNQMP_GPIO_MAX_BANK,\n\t.bank_min[0] = ZYNQ_GPIO_BANK0_PIN_MIN(MP),\n\t.bank_max[0] = ZYNQ_GPIO_BANK0_PIN_MAX(MP),\n\t.bank_min[1] = ZYNQ_GPIO_BANK1_PIN_MIN(MP),\n\t.bank_max[1] = ZYNQ_GPIO_BANK1_PIN_MAX(MP),\n\t.bank_min[2] = ZYNQ_GPIO_BANK2_PIN_MIN(MP),\n\t.bank_max[2] = ZYNQ_GPIO_BANK2_PIN_MAX(MP),\n\t.bank_min[3] = ZYNQ_GPIO_BANK3_PIN_MIN(MP),\n\t.bank_max[3] = ZYNQ_GPIO_BANK3_PIN_MAX(MP),\n\t.bank_min[4] = ZYNQ_GPIO_BANK4_PIN_MIN(MP),\n\t.bank_max[4] = ZYNQ_GPIO_BANK4_PIN_MAX(MP),\n\t.bank_min[5] = ZYNQ_GPIO_BANK5_PIN_MIN(MP),\n\t.bank_max[5] = ZYNQ_GPIO_BANK5_PIN_MAX(MP),\n};\n\nstatic const struct zynq_platform_data zynq_gpio_def = {\n\t.label = \"zynq_gpio\",\n\t.quirks = ZYNQ_GPIO_QUIRK_IS_ZYNQ | GPIO_QUIRK_DATA_RO_BUG,\n\t.ngpio = ZYNQ_GPIO_NR_GPIOS,\n\t.max_bank = ZYNQ_GPIO_MAX_BANK,\n\t.bank_min[0] = ZYNQ_GPIO_BANK0_PIN_MIN(),\n\t.bank_max[0] = ZYNQ_GPIO_BANK0_PIN_MAX(),\n\t.bank_min[1] = ZYNQ_GPIO_BANK1_PIN_MIN(),\n\t.bank_max[1] = ZYNQ_GPIO_BANK1_PIN_MAX(),\n\t.bank_min[2] = ZYNQ_GPIO_BANK2_PIN_MIN(),\n\t.bank_max[2] = ZYNQ_GPIO_BANK2_PIN_MAX(),\n\t.bank_min[3] = ZYNQ_GPIO_BANK3_PIN_MIN(),\n\t.bank_max[3] = ZYNQ_GPIO_BANK3_PIN_MAX(),\n};\n\nstatic const struct of_device_id zynq_gpio_of_match[] = {\n\t{ .compatible = \"xlnx,zynq-gpio-1.0\", .data = &zynq_gpio_def },\n\t{ .compatible = \"xlnx,zynqmp-gpio-1.0\", .data = &zynqmp_gpio_def },\n\t{ .compatible = \"xlnx,versal-gpio-1.0\", .data = &versal_gpio_def },\n\t{ .compatible = \"xlnx,pmc-gpio-1.0\", .data = &pmc_gpio_def },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, zynq_gpio_of_match);\n\n \nstatic int zynq_gpio_probe(struct platform_device *pdev)\n{\n\tint ret, bank_num;\n\tstruct zynq_gpio *gpio;\n\tstruct gpio_chip *chip;\n\tstruct gpio_irq_chip *girq;\n\tconst struct of_device_id *match;\n\n\tgpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_node(zynq_gpio_of_match, pdev->dev.of_node);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"of_match_node() failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\tgpio->p_data = match->data;\n\tplatform_set_drvdata(pdev, gpio);\n\n\tgpio->base_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gpio->base_addr))\n\t\treturn PTR_ERR(gpio->base_addr);\n\n\tgpio->irq = platform_get_irq(pdev, 0);\n\tif (gpio->irq < 0)\n\t\treturn gpio->irq;\n\n\t \n\tchip = &gpio->chip;\n\tchip->label = gpio->p_data->label;\n\tchip->owner = THIS_MODULE;\n\tchip->parent = &pdev->dev;\n\tchip->get = zynq_gpio_get_value;\n\tchip->set = zynq_gpio_set_value;\n\tchip->request = zynq_gpio_request;\n\tchip->free = zynq_gpio_free;\n\tchip->direction_input = zynq_gpio_dir_in;\n\tchip->direction_output = zynq_gpio_dir_out;\n\tchip->get_direction = zynq_gpio_get_direction;\n\tchip->base = of_alias_get_id(pdev->dev.of_node, \"gpio\");\n\tchip->ngpio = gpio->p_data->ngpio;\n\n\t \n\tgpio->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(gpio->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(gpio->clk), \"input clock not found.\\n\");\n\n\tret = clk_prepare_enable(gpio->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to enable clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tspin_lock_init(&gpio->dirlock);\n\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0)\n\t\tgoto err_pm_dis;\n\n\t \n\tfor (bank_num = 0; bank_num < gpio->p_data->max_bank; bank_num++) {\n\t\twritel_relaxed(ZYNQ_GPIO_IXR_DISABLE_ALL, gpio->base_addr +\n\t\t\t       ZYNQ_GPIO_INTDIS_OFFSET(bank_num));\n\t\tif (gpio->p_data->quirks & GPIO_QUIRK_VERSAL)\n\t\t\tbank_num = bank_num + VERSAL_UNUSED_BANKS;\n\t}\n\n\t \n\tgirq = &chip->irq;\n\tgpio_irq_chip_set_chip(girq, &zynq_gpio_edge_irqchip);\n\tgirq->parent_handler = zynq_gpio_irqhandler;\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(&pdev->dev, 1,\n\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t     GFP_KERNEL);\n\tif (!girq->parents) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pm_put;\n\t}\n\tgirq->parents[0] = gpio->irq;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_level_irq;\n\n\t \n\tret = gpiochip_add_data(chip, gpio);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to add gpio chip\\n\");\n\t\tgoto err_pm_put;\n\t}\n\n\tirq_set_status_flags(gpio->irq, IRQ_DISABLE_UNLAZY);\n\tdevice_init_wakeup(&pdev->dev, 1);\n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\n\nerr_pm_put:\n\tpm_runtime_put(&pdev->dev);\nerr_pm_dis:\n\tpm_runtime_disable(&pdev->dev);\n\tclk_disable_unprepare(gpio->clk);\n\n\treturn ret;\n}\n\n \nstatic int zynq_gpio_remove(struct platform_device *pdev)\n{\n\tstruct zynq_gpio *gpio = platform_get_drvdata(pdev);\n\tint ret;\n\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret < 0)\n\t\tdev_warn(&pdev->dev, \"pm_runtime_get_sync() Failed\\n\");\n\tgpiochip_remove(&gpio->chip);\n\tclk_disable_unprepare(gpio->clk);\n\tdevice_set_wakeup_capable(&pdev->dev, 0);\n\tpm_runtime_disable(&pdev->dev);\n\treturn 0;\n}\n\nstatic struct platform_driver zynq_gpio_driver = {\n\t.driver\t= {\n\t\t.name = DRIVER_NAME,\n\t\t.pm = &zynq_gpio_dev_pm_ops,\n\t\t.of_match_table = zynq_gpio_of_match,\n\t},\n\t.probe = zynq_gpio_probe,\n\t.remove = zynq_gpio_remove,\n};\n\nmodule_platform_driver(zynq_gpio_driver);\n\nMODULE_AUTHOR(\"Xilinx Inc.\");\nMODULE_DESCRIPTION(\"Zynq GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}