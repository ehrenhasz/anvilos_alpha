{
  "module_name": "gpio-amd8111.c",
  "hash_id": "966a1f3a993afebeebdba3dc5c6d99254abec2532c445d7855d6c187de05194f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-amd8111.c",
  "human_readable_source": "\n \n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/gpio/driver.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n\n#define PMBASE_OFFSET 0xb0\n#define PMBASE_SIZE   0x30\n\n#define AMD_REG_GPIO(i) (0x10 + (i))\n\n#define AMD_GPIO_LTCH_STS\t0x40  \n#define AMD_GPIO_RTIN\t\t0x20  \n#define AMD_GPIO_DEBOUNCE\t0x10  \n#define AMD_GPIO_MODE_MASK\t0x0c  \n#define AMD_GPIO_MODE_IN\t0x00\n#define AMD_GPIO_MODE_OUT\t0x04\n \n#define AMD_GPIO_MODE_ALTFN\t0x08  \n#define AMD_GPIO_X_MASK\t\t0x03  \n#define AMD_GPIO_X_IN_ACTIVEHI\t0x01  \n#define AMD_GPIO_X_IN_LATCH\t0x02  \n#define AMD_GPIO_X_OUT_LOW\t0x00\n#define AMD_GPIO_X_OUT_HI\t0x01\n#define AMD_GPIO_X_OUT_CLK0\t0x02\n#define AMD_GPIO_X_OUT_CLK1\t0x03\n\n \nstatic const struct pci_device_id pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_SMBUS), 0 },\n\t{ 0, },\t \n};\nMODULE_DEVICE_TABLE(pci, pci_tbl);\n\nstruct amd_gpio {\n\tstruct gpio_chip\tchip;\n\tu32\t\t\tpmbase;\n\tvoid __iomem\t\t*pm;\n\tstruct pci_dev\t\t*pdev;\n\tspinlock_t\t\tlock;  \n\tu8\t\t\torig[32];\n};\n\nstatic int amd_gpio_request(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct amd_gpio *agp = gpiochip_get_data(chip);\n\n\tagp->orig[offset] = ioread8(agp->pm + AMD_REG_GPIO(offset)) &\n\t\t(AMD_GPIO_DEBOUNCE | AMD_GPIO_MODE_MASK | AMD_GPIO_X_MASK);\n\n\tdev_dbg(&agp->pdev->dev, \"Requested gpio %d, data %x\\n\", offset, agp->orig[offset]);\n\n\treturn 0;\n}\n\nstatic void amd_gpio_free(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct amd_gpio *agp = gpiochip_get_data(chip);\n\n\tdev_dbg(&agp->pdev->dev, \"Freed gpio %d, data %x\\n\", offset, agp->orig[offset]);\n\n\tiowrite8(agp->orig[offset], agp->pm + AMD_REG_GPIO(offset));\n}\n\nstatic void amd_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct amd_gpio *agp = gpiochip_get_data(chip);\n\tu8 temp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&agp->lock, flags);\n\ttemp = ioread8(agp->pm + AMD_REG_GPIO(offset));\n\ttemp = (temp & AMD_GPIO_DEBOUNCE) | AMD_GPIO_MODE_OUT | (value ? AMD_GPIO_X_OUT_HI : AMD_GPIO_X_OUT_LOW);\n\tiowrite8(temp, agp->pm + AMD_REG_GPIO(offset));\n\tspin_unlock_irqrestore(&agp->lock, flags);\n\n\tdev_dbg(&agp->pdev->dev, \"Setting gpio %d, value %d, reg=%02x\\n\", offset, !!value, temp);\n}\n\nstatic int amd_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct amd_gpio *agp = gpiochip_get_data(chip);\n\tu8 temp;\n\n\ttemp = ioread8(agp->pm + AMD_REG_GPIO(offset));\n\n\tdev_dbg(&agp->pdev->dev, \"Getting gpio %d, reg=%02x\\n\", offset, temp);\n\n\treturn (temp & AMD_GPIO_RTIN) ? 1 : 0;\n}\n\nstatic int amd_gpio_dirout(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct amd_gpio *agp = gpiochip_get_data(chip);\n\tu8 temp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&agp->lock, flags);\n\ttemp = ioread8(agp->pm + AMD_REG_GPIO(offset));\n\ttemp = (temp & AMD_GPIO_DEBOUNCE) | AMD_GPIO_MODE_OUT | (value ? AMD_GPIO_X_OUT_HI : AMD_GPIO_X_OUT_LOW);\n\tiowrite8(temp, agp->pm + AMD_REG_GPIO(offset));\n\tspin_unlock_irqrestore(&agp->lock, flags);\n\n\tdev_dbg(&agp->pdev->dev, \"Dirout gpio %d, value %d, reg=%02x\\n\", offset, !!value, temp);\n\n\treturn 0;\n}\n\nstatic int amd_gpio_dirin(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct amd_gpio *agp = gpiochip_get_data(chip);\n\tu8 temp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&agp->lock, flags);\n\ttemp = ioread8(agp->pm + AMD_REG_GPIO(offset));\n\ttemp = (temp & AMD_GPIO_DEBOUNCE) | AMD_GPIO_MODE_IN;\n\tiowrite8(temp, agp->pm + AMD_REG_GPIO(offset));\n\tspin_unlock_irqrestore(&agp->lock, flags);\n\n\tdev_dbg(&agp->pdev->dev, \"Dirin gpio %d, reg=%02x\\n\", offset, temp);\n\n\treturn 0;\n}\n\nstatic struct amd_gpio gp = {\n\t.chip = {\n\t\t.label\t\t= \"AMD GPIO\",\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.base\t\t= -1,\n\t\t.ngpio\t\t= 32,\n\t\t.request\t= amd_gpio_request,\n\t\t.free\t\t= amd_gpio_free,\n\t\t.set\t\t= amd_gpio_set,\n\t\t.get\t\t= amd_gpio_get,\n\t\t.direction_output = amd_gpio_dirout,\n\t\t.direction_input = amd_gpio_dirin,\n\t},\n};\n\nstatic int __init amd_gpio_init(void)\n{\n\tint err = -ENODEV;\n\tstruct pci_dev *pdev = NULL;\n\tconst struct pci_device_id *ent;\n\n\t \n\tfor_each_pci_dev(pdev) {\n\t\tent = pci_match_id(pci_tbl, pdev);\n\t\tif (ent)\n\t\t\tgoto found;\n\t}\n\t \n\tgoto out;\n\nfound:\n\terr = pci_read_config_dword(pdev, 0x58, &gp.pmbase);\n\tif (err)\n\t\tgoto out;\n\terr = -EIO;\n\tgp.pmbase &= 0x0000FF00;\n\tif (gp.pmbase == 0)\n\t\tgoto out;\n\tif (!devm_request_region(&pdev->dev, gp.pmbase + PMBASE_OFFSET,\n\t\tPMBASE_SIZE, \"AMD GPIO\")) {\n\t\tdev_err(&pdev->dev, \"AMD GPIO region 0x%x already in use!\\n\",\n\t\t\tgp.pmbase + PMBASE_OFFSET);\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tgp.pm = ioport_map(gp.pmbase + PMBASE_OFFSET, PMBASE_SIZE);\n\tif (!gp.pm) {\n\t\tdev_err(&pdev->dev, \"Couldn't map io port into io memory\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgp.pdev = pdev;\n\tgp.chip.parent = &pdev->dev;\n\n\tspin_lock_init(&gp.lock);\n\n\tdev_info(&pdev->dev, \"AMD-8111 GPIO detected\\n\");\n\terr = gpiochip_add_data(&gp.chip, &gp);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"GPIO registering failed (%d)\\n\", err);\n\t\tioport_unmap(gp.pm);\n\t\tgoto out;\n\t}\n\treturn 0;\n\nout:\n\tpci_dev_put(pdev);\n\treturn err;\n}\n\nstatic void __exit amd_gpio_exit(void)\n{\n\tgpiochip_remove(&gp.chip);\n\tioport_unmap(gp.pm);\n\tpci_dev_put(gp.pdev);\n}\n\nmodule_init(amd_gpio_init);\nmodule_exit(amd_gpio_exit);\n\nMODULE_AUTHOR(\"The Linux Kernel team\");\nMODULE_DESCRIPTION(\"GPIO driver for AMD chipsets\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}