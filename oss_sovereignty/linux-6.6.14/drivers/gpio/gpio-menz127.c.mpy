{
  "module_name": "gpio-menz127.c",
  "hash_id": "fc7decee7d5705179cb23595b5bbaf53db566b366623ac433ee2780793c1e46b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-menz127.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/mcb.h>\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n\n#define MEN_Z127_CTRL\t0x00\n#define MEN_Z127_PSR\t0x04\n#define MEN_Z127_IRQR\t0x08\n#define MEN_Z127_GPIODR\t0x0c\n#define MEN_Z127_IER1\t0x10\n#define MEN_Z127_IER2\t0x14\n#define MEN_Z127_DBER\t0x18\n#define MEN_Z127_ODER\t0x1C\n#define GPIO_TO_DBCNT_REG(gpio)\t((gpio * 4) + 0x80)\n\n#define MEN_Z127_DB_MIN_US\t50\n \n#define MEN_Z127_DB_MAX_US\t(0xffff * MEN_Z127_DB_MIN_US)\n#define MEN_Z127_DB_IN_RANGE(db)\t((db >= MEN_Z127_DB_MIN_US) && \\\n\t\t\t\t\t (db <= MEN_Z127_DB_MAX_US))\n\nstruct men_z127_gpio {\n\tstruct gpio_chip gc;\n\tvoid __iomem *reg_base;\n\tstruct resource *mem;\n};\n\nstatic int men_z127_debounce(struct gpio_chip *gc, unsigned gpio,\n\t\t\t     unsigned debounce)\n{\n\tstruct men_z127_gpio *priv = gpiochip_get_data(gc);\n\tstruct device *dev = gc->parent;\n\tunsigned int rnd;\n\tu32 db_en, db_cnt;\n\n\tif (!MEN_Z127_DB_IN_RANGE(debounce)) {\n\t\tdev_err(dev, \"debounce value %u out of range\", debounce);\n\t\treturn -EINVAL;\n\t}\n\n\tif (debounce > 0) {\n\t\t \n\t\trnd = fls(debounce) - 1;\n\n\t\tif (rnd && (debounce & BIT(rnd - 1)))\n\t\t\tdebounce = roundup(debounce, MEN_Z127_DB_MIN_US);\n\t\telse\n\t\t\tdebounce = rounddown(debounce, MEN_Z127_DB_MIN_US);\n\n\t\tif (debounce > MEN_Z127_DB_MAX_US)\n\t\t\tdebounce = MEN_Z127_DB_MAX_US;\n\n\t\t \n\t\tdebounce /= 50;\n\t}\n\n\traw_spin_lock(&gc->bgpio_lock);\n\n\tdb_en = readl(priv->reg_base + MEN_Z127_DBER);\n\n\tif (debounce == 0) {\n\t\tdb_en &= ~BIT(gpio);\n\t\tdb_cnt = 0;\n\t} else {\n\t\tdb_en |= BIT(gpio);\n\t\tdb_cnt = debounce;\n\t}\n\n\twritel(db_en, priv->reg_base + MEN_Z127_DBER);\n\twritel(db_cnt, priv->reg_base + GPIO_TO_DBCNT_REG(gpio));\n\n\traw_spin_unlock(&gc->bgpio_lock);\n\n\treturn 0;\n}\n\nstatic int men_z127_set_single_ended(struct gpio_chip *gc,\n\t\t\t\t     unsigned offset,\n\t\t\t\t     enum pin_config_param param)\n{\n\tstruct men_z127_gpio *priv = gpiochip_get_data(gc);\n\tu32 od_en;\n\n\traw_spin_lock(&gc->bgpio_lock);\n\tod_en = readl(priv->reg_base + MEN_Z127_ODER);\n\n\tif (param == PIN_CONFIG_DRIVE_OPEN_DRAIN)\n\t\tod_en |= BIT(offset);\n\telse\n\t\t \n\t\tod_en &= ~BIT(offset);\n\n\twritel(od_en, priv->reg_base + MEN_Z127_ODER);\n\traw_spin_unlock(&gc->bgpio_lock);\n\n\treturn 0;\n}\n\nstatic int men_z127_set_config(struct gpio_chip *gc, unsigned offset,\n\t\t\t       unsigned long config)\n{\n\tenum pin_config_param param = pinconf_to_config_param(config);\n\n\tswitch (param) {\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\treturn men_z127_set_single_ended(gc, offset, param);\n\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\treturn men_z127_debounce(gc, offset,\n\t\t\tpinconf_to_config_argument(config));\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic int men_z127_probe(struct mcb_device *mdev,\n\t\t\t  const struct mcb_device_id *id)\n{\n\tstruct men_z127_gpio *men_z127_gpio;\n\tstruct device *dev = &mdev->dev;\n\tint ret;\n\n\tmen_z127_gpio = devm_kzalloc(dev, sizeof(struct men_z127_gpio),\n\t\t\t\t     GFP_KERNEL);\n\tif (!men_z127_gpio)\n\t\treturn -ENOMEM;\n\n\tmen_z127_gpio->mem = mcb_request_mem(mdev, dev_name(dev));\n\tif (IS_ERR(men_z127_gpio->mem)) {\n\t\tdev_err(dev, \"failed to request device memory\");\n\t\treturn PTR_ERR(men_z127_gpio->mem);\n\t}\n\n\tmen_z127_gpio->reg_base = ioremap(men_z127_gpio->mem->start,\n\t\t\t\t\t  resource_size(men_z127_gpio->mem));\n\tif (men_z127_gpio->reg_base == NULL) {\n\t\tret = -ENXIO;\n\t\tgoto err_release;\n\t}\n\n\tmcb_set_drvdata(mdev, men_z127_gpio);\n\n\tret = bgpio_init(&men_z127_gpio->gc, &mdev->dev, 4,\n\t\t\t men_z127_gpio->reg_base + MEN_Z127_PSR,\n\t\t\t men_z127_gpio->reg_base + MEN_Z127_CTRL,\n\t\t\t NULL,\n\t\t\t men_z127_gpio->reg_base + MEN_Z127_GPIODR,\n\t\t\t NULL, 0);\n\tif (ret)\n\t\tgoto err_unmap;\n\n\tmen_z127_gpio->gc.set_config = men_z127_set_config;\n\n\tret = gpiochip_add_data(&men_z127_gpio->gc, men_z127_gpio);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register MEN 16Z127 GPIO controller\");\n\t\tgoto err_unmap;\n\t}\n\n\tdev_info(dev, \"MEN 16Z127 GPIO driver registered\");\n\n\treturn 0;\n\nerr_unmap:\n\tiounmap(men_z127_gpio->reg_base);\nerr_release:\n\tmcb_release_mem(men_z127_gpio->mem);\n\treturn ret;\n}\n\nstatic void men_z127_remove(struct mcb_device *mdev)\n{\n\tstruct men_z127_gpio *men_z127_gpio = mcb_get_drvdata(mdev);\n\n\tgpiochip_remove(&men_z127_gpio->gc);\n\tiounmap(men_z127_gpio->reg_base);\n\tmcb_release_mem(men_z127_gpio->mem);\n}\n\nstatic const struct mcb_device_id men_z127_ids[] = {\n\t{ .device = 0x7f },\n\t{ }\n};\nMODULE_DEVICE_TABLE(mcb, men_z127_ids);\n\nstatic struct mcb_driver men_z127_driver = {\n\t.driver = {\n\t\t.name = \"z127-gpio\",\n\t},\n\t.probe = men_z127_probe,\n\t.remove = men_z127_remove,\n\t.id_table = men_z127_ids,\n};\nmodule_mcb_driver(men_z127_driver);\n\nMODULE_AUTHOR(\"Andreas Werner <andreas.werner@men.de>\");\nMODULE_DESCRIPTION(\"MEN 16z127 GPIO Controller\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"mcb:16z127\");\nMODULE_IMPORT_NS(MCB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}