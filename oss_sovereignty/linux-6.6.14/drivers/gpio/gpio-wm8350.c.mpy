{
  "module_name": "gpio-wm8350.c",
  "hash_id": "99a53ad3f46c78f945d674252938b701f3921d5c5d5f978d0e4bd558016551d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-wm8350.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/kernel.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <linux/mfd/wm8350/core.h>\n#include <linux/mfd/wm8350/gpio.h>\n\nstruct wm8350_gpio_data {\n\tstruct wm8350 *wm8350;\n\tstruct gpio_chip gpio_chip;\n};\n\nstatic int wm8350_gpio_direction_in(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct wm8350_gpio_data *wm8350_gpio = gpiochip_get_data(chip);\n\tstruct wm8350 *wm8350 = wm8350_gpio->wm8350;\n\n\treturn wm8350_set_bits(wm8350, WM8350_GPIO_CONFIGURATION_I_O,\n\t\t\t       1 << offset);\n}\n\nstatic int wm8350_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct wm8350_gpio_data *wm8350_gpio = gpiochip_get_data(chip);\n\tstruct wm8350 *wm8350 = wm8350_gpio->wm8350;\n\tint ret;\n\n\tret = wm8350_reg_read(wm8350, WM8350_GPIO_LEVEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & (1 << offset))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void wm8350_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct wm8350_gpio_data *wm8350_gpio = gpiochip_get_data(chip);\n\tstruct wm8350 *wm8350 = wm8350_gpio->wm8350;\n\n\tif (value)\n\t\twm8350_set_bits(wm8350, WM8350_GPIO_LEVEL, 1 << offset);\n\telse\n\t\twm8350_clear_bits(wm8350, WM8350_GPIO_LEVEL, 1 << offset);\n}\n\nstatic int wm8350_gpio_direction_out(struct gpio_chip *chip,\n\t\t\t\t     unsigned offset, int value)\n{\n\tstruct wm8350_gpio_data *wm8350_gpio = gpiochip_get_data(chip);\n\tstruct wm8350 *wm8350 = wm8350_gpio->wm8350;\n\tint ret;\n\n\tret = wm8350_clear_bits(wm8350, WM8350_GPIO_CONFIGURATION_I_O,\n\t\t\t\t1 << offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\twm8350_gpio_set(chip, offset, value);\n\n\treturn 0;\n}\n\nstatic int wm8350_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct wm8350_gpio_data *wm8350_gpio = gpiochip_get_data(chip);\n\tstruct wm8350 *wm8350 = wm8350_gpio->wm8350;\n\n\tif (!wm8350->irq_base)\n\t\treturn -EINVAL;\n\n\treturn wm8350->irq_base + WM8350_IRQ_GPIO(offset);\n}\n\nstatic const struct gpio_chip template_chip = {\n\t.label\t\t\t= \"wm8350\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.direction_input\t= wm8350_gpio_direction_in,\n\t.get\t\t\t= wm8350_gpio_get,\n\t.direction_output\t= wm8350_gpio_direction_out,\n\t.set\t\t\t= wm8350_gpio_set,\n\t.to_irq\t\t\t= wm8350_gpio_to_irq,\n\t.can_sleep\t\t= true,\n};\n\nstatic int wm8350_gpio_probe(struct platform_device *pdev)\n{\n\tstruct wm8350 *wm8350 = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm8350_platform_data *pdata = dev_get_platdata(wm8350->dev);\n\tstruct wm8350_gpio_data *wm8350_gpio;\n\n\twm8350_gpio = devm_kzalloc(&pdev->dev, sizeof(*wm8350_gpio),\n\t\t\t\t   GFP_KERNEL);\n\tif (wm8350_gpio == NULL)\n\t\treturn -ENOMEM;\n\n\twm8350_gpio->wm8350 = wm8350;\n\twm8350_gpio->gpio_chip = template_chip;\n\twm8350_gpio->gpio_chip.ngpio = 13;\n\twm8350_gpio->gpio_chip.parent = &pdev->dev;\n\tif (pdata && pdata->gpio_base)\n\t\twm8350_gpio->gpio_chip.base = pdata->gpio_base;\n\telse\n\t\twm8350_gpio->gpio_chip.base = -1;\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &wm8350_gpio->gpio_chip, wm8350_gpio);\n}\n\nstatic struct platform_driver wm8350_gpio_driver = {\n\t.driver.name\t= \"wm8350-gpio\",\n\t.probe\t\t= wm8350_gpio_probe,\n};\n\nstatic int __init wm8350_gpio_init(void)\n{\n\treturn platform_driver_register(&wm8350_gpio_driver);\n}\nsubsys_initcall(wm8350_gpio_init);\n\nstatic void __exit wm8350_gpio_exit(void)\n{\n\tplatform_driver_unregister(&wm8350_gpio_driver);\n}\nmodule_exit(wm8350_gpio_exit);\n\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"GPIO interface for WM8350 PMICs\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm8350-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}