{
  "module_name": "gpio-adnp.c",
  "hash_id": "f7655fdd8b99e1f9f32d5b809da8ba3822abfa692d01ad25dcb4549664313bc1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-adnp.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#define GPIO_DDR(gpio) (0x00 << (gpio)->reg_shift)\n#define GPIO_PLR(gpio) (0x01 << (gpio)->reg_shift)\n#define GPIO_IER(gpio) (0x02 << (gpio)->reg_shift)\n#define GPIO_ISR(gpio) (0x03 << (gpio)->reg_shift)\n#define GPIO_PTR(gpio) (0x04 << (gpio)->reg_shift)\n\nstruct adnp {\n\tstruct i2c_client *client;\n\tstruct gpio_chip gpio;\n\tunsigned int reg_shift;\n\n\tstruct mutex i2c_lock;\n\tstruct mutex irq_lock;\n\n\tu8 *irq_enable;\n\tu8 *irq_level;\n\tu8 *irq_rise;\n\tu8 *irq_fall;\n\tu8 *irq_high;\n\tu8 *irq_low;\n};\n\nstatic int adnp_read(struct adnp *adnp, unsigned offset, uint8_t *value)\n{\n\tint err;\n\n\terr = i2c_smbus_read_byte_data(adnp->client, offset);\n\tif (err < 0) {\n\t\tdev_err(adnp->gpio.parent, \"%s failed: %d\\n\",\n\t\t\t\"i2c_smbus_read_byte_data()\", err);\n\t\treturn err;\n\t}\n\n\t*value = err;\n\treturn 0;\n}\n\nstatic int adnp_write(struct adnp *adnp, unsigned offset, uint8_t value)\n{\n\tint err;\n\n\terr = i2c_smbus_write_byte_data(adnp->client, offset, value);\n\tif (err < 0) {\n\t\tdev_err(adnp->gpio.parent, \"%s failed: %d\\n\",\n\t\t\t\"i2c_smbus_write_byte_data()\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int adnp_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct adnp *adnp = gpiochip_get_data(chip);\n\tunsigned int reg = offset >> adnp->reg_shift;\n\tunsigned int pos = offset & 7;\n\tu8 value;\n\tint err;\n\n\terr = adnp_read(adnp, GPIO_PLR(adnp) + reg, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn (value & BIT(pos)) ? 1 : 0;\n}\n\nstatic void __adnp_gpio_set(struct adnp *adnp, unsigned offset, int value)\n{\n\tunsigned int reg = offset >> adnp->reg_shift;\n\tunsigned int pos = offset & 7;\n\tint err;\n\tu8 val;\n\n\terr = adnp_read(adnp, GPIO_PLR(adnp) + reg, &val);\n\tif (err < 0)\n\t\treturn;\n\n\tif (value)\n\t\tval |= BIT(pos);\n\telse\n\t\tval &= ~BIT(pos);\n\n\tadnp_write(adnp, GPIO_PLR(adnp) + reg, val);\n}\n\nstatic void adnp_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct adnp *adnp = gpiochip_get_data(chip);\n\n\tmutex_lock(&adnp->i2c_lock);\n\t__adnp_gpio_set(adnp, offset, value);\n\tmutex_unlock(&adnp->i2c_lock);\n}\n\nstatic int adnp_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct adnp *adnp = gpiochip_get_data(chip);\n\tunsigned int reg = offset >> adnp->reg_shift;\n\tunsigned int pos = offset & 7;\n\tu8 value;\n\tint err;\n\n\tmutex_lock(&adnp->i2c_lock);\n\n\terr = adnp_read(adnp, GPIO_DDR(adnp) + reg, &value);\n\tif (err < 0)\n\t\tgoto out;\n\n\tvalue &= ~BIT(pos);\n\n\terr = adnp_write(adnp, GPIO_DDR(adnp) + reg, value);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = adnp_read(adnp, GPIO_DDR(adnp) + reg, &value);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (value & BIT(pos)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\nout:\n\tmutex_unlock(&adnp->i2c_lock);\n\treturn err;\n}\n\nstatic int adnp_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\n\t\t\t\t      int value)\n{\n\tstruct adnp *adnp = gpiochip_get_data(chip);\n\tunsigned int reg = offset >> adnp->reg_shift;\n\tunsigned int pos = offset & 7;\n\tint err;\n\tu8 val;\n\n\tmutex_lock(&adnp->i2c_lock);\n\n\terr = adnp_read(adnp, GPIO_DDR(adnp) + reg, &val);\n\tif (err < 0)\n\t\tgoto out;\n\n\tval |= BIT(pos);\n\n\terr = adnp_write(adnp, GPIO_DDR(adnp) + reg, val);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = adnp_read(adnp, GPIO_DDR(adnp) + reg, &val);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (!(val & BIT(pos))) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\t__adnp_gpio_set(adnp, offset, value);\n\terr = 0;\n\nout:\n\tmutex_unlock(&adnp->i2c_lock);\n\treturn err;\n}\n\nstatic void adnp_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tstruct adnp *adnp = gpiochip_get_data(chip);\n\tunsigned int num_regs = 1 << adnp->reg_shift, i, j;\n\tint err;\n\n\tfor (i = 0; i < num_regs; i++) {\n\t\tu8 ddr, plr, ier, isr;\n\n\t\tmutex_lock(&adnp->i2c_lock);\n\n\t\terr = adnp_read(adnp, GPIO_DDR(adnp) + i, &ddr);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\terr = adnp_read(adnp, GPIO_PLR(adnp) + i, &plr);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\terr = adnp_read(adnp, GPIO_IER(adnp) + i, &ier);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\terr = adnp_read(adnp, GPIO_ISR(adnp) + i, &isr);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\tmutex_unlock(&adnp->i2c_lock);\n\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tunsigned int bit = (i << adnp->reg_shift) + j;\n\t\t\tconst char *direction = \"input \";\n\t\t\tconst char *level = \"low \";\n\t\t\tconst char *interrupt = \"disabled\";\n\t\t\tconst char *pending = \"\";\n\n\t\t\tif (ddr & BIT(j))\n\t\t\t\tdirection = \"output\";\n\n\t\t\tif (plr & BIT(j))\n\t\t\t\tlevel = \"high\";\n\n\t\t\tif (ier & BIT(j))\n\t\t\t\tinterrupt = \"enabled \";\n\n\t\t\tif (isr & BIT(j))\n\t\t\t\tpending = \"pending\";\n\n\t\t\tseq_printf(s, \"%2u: %s %s IRQ %s %s\\n\", bit,\n\t\t\t\t   direction, level, interrupt, pending);\n\t\t}\n\t}\n\n\treturn;\n\nunlock:\n\tmutex_unlock(&adnp->i2c_lock);\n}\n\nstatic irqreturn_t adnp_irq(int irq, void *data)\n{\n\tstruct adnp *adnp = data;\n\tunsigned int num_regs, i;\n\n\tnum_regs = 1 << adnp->reg_shift;\n\n\tfor (i = 0; i < num_regs; i++) {\n\t\tunsigned int base = i << adnp->reg_shift, bit;\n\t\tu8 changed, level, isr, ier;\n\t\tunsigned long pending;\n\t\tint err;\n\n\t\tmutex_lock(&adnp->i2c_lock);\n\n\t\terr = adnp_read(adnp, GPIO_PLR(adnp) + i, &level);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&adnp->i2c_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = adnp_read(adnp, GPIO_ISR(adnp) + i, &isr);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&adnp->i2c_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = adnp_read(adnp, GPIO_IER(adnp) + i, &ier);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&adnp->i2c_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmutex_unlock(&adnp->i2c_lock);\n\n\t\t \n\t\tchanged = level ^ adnp->irq_level[i];\n\n\t\t \n\t\tpending = changed & ((adnp->irq_fall[i] & ~level) |\n\t\t\t\t     (adnp->irq_rise[i] & level));\n\n\t\t \n\t\tpending |= (adnp->irq_high[i] & level) |\n\t\t\t   (adnp->irq_low[i] & ~level);\n\n\t\t \n\t\tpending &= isr & ier;\n\n\t\tfor_each_set_bit(bit, &pending, 8) {\n\t\t\tunsigned int child_irq;\n\t\t\tchild_irq = irq_find_mapping(adnp->gpio.irq.domain,\n\t\t\t\t\t\t     base + bit);\n\t\t\thandle_nested_irq(child_irq);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void adnp_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct adnp *adnp = gpiochip_get_data(gc);\n\tunsigned int reg = d->hwirq >> adnp->reg_shift;\n\tunsigned int pos = d->hwirq & 7;\n\n\tadnp->irq_enable[reg] &= ~BIT(pos);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void adnp_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct adnp *adnp = gpiochip_get_data(gc);\n\tunsigned int reg = d->hwirq >> adnp->reg_shift;\n\tunsigned int pos = d->hwirq & 7;\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\tadnp->irq_enable[reg] |= BIT(pos);\n}\n\nstatic int adnp_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct adnp *adnp = gpiochip_get_data(gc);\n\tunsigned int reg = d->hwirq >> adnp->reg_shift;\n\tunsigned int pos = d->hwirq & 7;\n\n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tadnp->irq_rise[reg] |= BIT(pos);\n\telse\n\t\tadnp->irq_rise[reg] &= ~BIT(pos);\n\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tadnp->irq_fall[reg] |= BIT(pos);\n\telse\n\t\tadnp->irq_fall[reg] &= ~BIT(pos);\n\n\tif (type & IRQ_TYPE_LEVEL_HIGH)\n\t\tadnp->irq_high[reg] |= BIT(pos);\n\telse\n\t\tadnp->irq_high[reg] &= ~BIT(pos);\n\n\tif (type & IRQ_TYPE_LEVEL_LOW)\n\t\tadnp->irq_low[reg] |= BIT(pos);\n\telse\n\t\tadnp->irq_low[reg] &= ~BIT(pos);\n\n\treturn 0;\n}\n\nstatic void adnp_irq_bus_lock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct adnp *adnp = gpiochip_get_data(gc);\n\n\tmutex_lock(&adnp->irq_lock);\n}\n\nstatic void adnp_irq_bus_unlock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct adnp *adnp = gpiochip_get_data(gc);\n\tunsigned int num_regs = 1 << adnp->reg_shift, i;\n\n\tmutex_lock(&adnp->i2c_lock);\n\n\tfor (i = 0; i < num_regs; i++)\n\t\tadnp_write(adnp, GPIO_IER(adnp) + i, adnp->irq_enable[i]);\n\n\tmutex_unlock(&adnp->i2c_lock);\n\tmutex_unlock(&adnp->irq_lock);\n}\n\nstatic const struct irq_chip adnp_irq_chip = {\n\t.name = \"gpio-adnp\",\n\t.irq_mask = adnp_irq_mask,\n\t.irq_unmask = adnp_irq_unmask,\n\t.irq_set_type = adnp_irq_set_type,\n\t.irq_bus_lock = adnp_irq_bus_lock,\n\t.irq_bus_sync_unlock = adnp_irq_bus_unlock,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int adnp_irq_setup(struct adnp *adnp)\n{\n\tunsigned int num_regs = 1 << adnp->reg_shift, i;\n\tstruct gpio_chip *chip = &adnp->gpio;\n\tint err;\n\n\tmutex_init(&adnp->irq_lock);\n\n\t \n\tadnp->irq_enable = devm_kcalloc(chip->parent, num_regs, 6,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!adnp->irq_enable)\n\t\treturn -ENOMEM;\n\n\tadnp->irq_level = adnp->irq_enable + (num_regs * 1);\n\tadnp->irq_rise = adnp->irq_enable + (num_regs * 2);\n\tadnp->irq_fall = adnp->irq_enable + (num_regs * 3);\n\tadnp->irq_high = adnp->irq_enable + (num_regs * 4);\n\tadnp->irq_low = adnp->irq_enable + (num_regs * 5);\n\n\tfor (i = 0; i < num_regs; i++) {\n\t\t \n\t\terr = adnp_read(adnp, GPIO_PLR(adnp) + i, &adnp->irq_level[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = adnp_write(adnp, GPIO_IER(adnp) + i, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tadnp->irq_enable[i] = 0x00;\n\t}\n\n\terr = devm_request_threaded_irq(chip->parent, adnp->client->irq,\n\t\t\t\t\tNULL, adnp_irq,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(chip->parent), adnp);\n\tif (err != 0) {\n\t\tdev_err(chip->parent, \"can't request IRQ#%d: %d\\n\",\n\t\t\tadnp->client->irq, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int adnp_gpio_setup(struct adnp *adnp, unsigned int num_gpios,\n\t\t\t   bool is_irq_controller)\n{\n\tstruct gpio_chip *chip = &adnp->gpio;\n\tint err;\n\n\tadnp->reg_shift = get_count_order(num_gpios) - 3;\n\n\tchip->direction_input = adnp_gpio_direction_input;\n\tchip->direction_output = adnp_gpio_direction_output;\n\tchip->get = adnp_gpio_get;\n\tchip->set = adnp_gpio_set;\n\tchip->can_sleep = true;\n\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tchip->dbg_show = adnp_gpio_dbg_show;\n\n\tchip->base = -1;\n\tchip->ngpio = num_gpios;\n\tchip->label = adnp->client->name;\n\tchip->parent = &adnp->client->dev;\n\tchip->owner = THIS_MODULE;\n\n\tif (is_irq_controller) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\terr = adnp_irq_setup(adnp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tgirq = &chip->irq;\n\t\tgpio_irq_chip_set_chip(girq, &adnp_irq_chip);\n\n\t\t \n\t\tgirq->parent_handler = NULL;\n\t\tgirq->num_parents = 0;\n\t\tgirq->parents = NULL;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_simple_irq;\n\t\tgirq->threaded = true;\n\t}\n\n\terr = devm_gpiochip_add_data(&adnp->client->dev, chip, adnp);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int adnp_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct adnp *adnp;\n\tu32 num_gpios;\n\tint err;\n\n\terr = device_property_read_u32(dev, \"nr-gpios\", &num_gpios);\n\tif (err < 0)\n\t\treturn err;\n\n\tadnp = devm_kzalloc(&client->dev, sizeof(*adnp), GFP_KERNEL);\n\tif (!adnp)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&adnp->i2c_lock);\n\tadnp->client = client;\n\n\terr = adnp_gpio_setup(adnp, num_gpios, device_property_read_bool(dev, \"interrupt-controller\"));\n\tif (err)\n\t\treturn err;\n\n\ti2c_set_clientdata(client, adnp);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id adnp_i2c_id[] = {\n\t{ \"gpio-adnp\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, adnp_i2c_id);\n\nstatic const struct of_device_id adnp_of_match[] = {\n\t{ .compatible = \"ad,gpio-adnp\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, adnp_of_match);\n\nstatic struct i2c_driver adnp_i2c_driver = {\n\t.driver = {\n\t\t.name = \"gpio-adnp\",\n\t\t.of_match_table = adnp_of_match,\n\t},\n\t.probe = adnp_i2c_probe,\n\t.id_table = adnp_i2c_id,\n};\nmodule_i2c_driver(adnp_i2c_driver);\n\nMODULE_DESCRIPTION(\"Avionic Design N-bit GPIO expander\");\nMODULE_AUTHOR(\"Thierry Reding <thierry.reding@avionic-design.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}