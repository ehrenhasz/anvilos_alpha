{
  "module_name": "gpio-bd71828.c",
  "hash_id": "4be10118d5454692e074c57f5223907fe66d7bc2acaf17934af9e736084b920b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-bd71828.c",
  "human_readable_source": "\n\n\n#include <linux/gpio/driver.h>\n#include <linux/mfd/rohm-bd71828.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define GPIO_OUT_REG(off) (BD71828_REG_GPIO_CTRL1 + (off))\n#define HALL_GPIO_OFFSET 3\n\nstruct bd71828_gpio {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct gpio_chip gpio;\n};\n\nstatic void bd71828_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t     int value)\n{\n\tint ret;\n\tstruct bd71828_gpio *bdgpio = gpiochip_get_data(chip);\n\tu8 val = (value) ? BD71828_GPIO_OUT_HI : BD71828_GPIO_OUT_LO;\n\n\t \n\tif (offset == HALL_GPIO_OFFSET)\n\t\treturn;\n\n\tret = regmap_update_bits(bdgpio->regmap, GPIO_OUT_REG(offset),\n\t\t\t\t BD71828_GPIO_OUT_MASK, val);\n\tif (ret)\n\t\tdev_err(bdgpio->dev, \"Could not set gpio to %d\\n\", value);\n}\n\nstatic int bd71828_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tint ret;\n\tunsigned int val;\n\tstruct bd71828_gpio *bdgpio = gpiochip_get_data(chip);\n\n\tif (offset == HALL_GPIO_OFFSET)\n\t\tret = regmap_read(bdgpio->regmap, BD71828_REG_IO_STAT,\n\t\t\t\t  &val);\n\telse\n\t\tret = regmap_read(bdgpio->regmap, GPIO_OUT_REG(offset),\n\t\t\t\t  &val);\n\tif (!ret)\n\t\tret = (val & BD71828_GPIO_OUT_MASK);\n\n\treturn ret;\n}\n\nstatic int bd71828_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t   unsigned long config)\n{\n\tstruct bd71828_gpio *bdgpio = gpiochip_get_data(chip);\n\n\tif (offset == HALL_GPIO_OFFSET)\n\t\treturn -ENOTSUPP;\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\treturn regmap_update_bits(bdgpio->regmap,\n\t\t\t\t\t  GPIO_OUT_REG(offset),\n\t\t\t\t\t  BD71828_GPIO_DRIVE_MASK,\n\t\t\t\t\t  BD71828_GPIO_OPEN_DRAIN);\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\treturn regmap_update_bits(bdgpio->regmap,\n\t\t\t\t\t  GPIO_OUT_REG(offset),\n\t\t\t\t\t  BD71828_GPIO_DRIVE_MASK,\n\t\t\t\t\t  BD71828_GPIO_PUSH_PULL);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -ENOTSUPP;\n}\n\nstatic int bd71828_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\t \n\tif (offset == HALL_GPIO_OFFSET)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int bd71828_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bd71828_gpio *bdgpio;\n\n\tbdgpio = devm_kzalloc(dev, sizeof(*bdgpio), GFP_KERNEL);\n\tif (!bdgpio)\n\t\treturn -ENOMEM;\n\n\tbdgpio->dev = dev;\n\tbdgpio->gpio.parent = dev->parent;\n\tbdgpio->gpio.label = \"bd71828-gpio\";\n\tbdgpio->gpio.owner = THIS_MODULE;\n\tbdgpio->gpio.get_direction = bd71828_get_direction;\n\tbdgpio->gpio.set_config = bd71828_gpio_set_config;\n\tbdgpio->gpio.can_sleep = true;\n\tbdgpio->gpio.get = bd71828_gpio_get;\n\tbdgpio->gpio.set = bd71828_gpio_set;\n\tbdgpio->gpio.base = -1;\n\n\t \n\tbdgpio->gpio.ngpio = 4;\n\tbdgpio->regmap = dev_get_regmap(dev->parent, NULL);\n\tif (!bdgpio->regmap)\n\t\treturn -ENODEV;\n\n\treturn devm_gpiochip_add_data(dev, &bdgpio->gpio, bdgpio);\n}\n\nstatic struct platform_driver bd71828_gpio = {\n\t.driver = {\n\t\t.name = \"bd71828-gpio\"\n\t},\n\t.probe = bd71828_probe,\n};\n\nmodule_platform_driver(bd71828_gpio);\n\nMODULE_AUTHOR(\"Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>\");\nMODULE_DESCRIPTION(\"BD71828 voltage regulator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:bd71828-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}