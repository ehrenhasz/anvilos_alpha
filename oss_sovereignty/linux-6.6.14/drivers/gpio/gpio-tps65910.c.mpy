{
  "module_name": "gpio-tps65910.c",
  "hash_id": "572995751df7a73107e8df13a41759da9a7991aab33727c54f39adfae6757949",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-tps65910.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/tps65910.h>\n#include <linux/of.h>\n\nstruct tps65910_gpio {\n\tstruct gpio_chip gpio_chip;\n\tstruct tps65910 *tps65910;\n};\n\nstatic int tps65910_gpio_get(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct tps65910_gpio *tps65910_gpio = gpiochip_get_data(gc);\n\tstruct tps65910 *tps65910 = tps65910_gpio->tps65910;\n\tunsigned int val;\n\n\tregmap_read(tps65910->regmap, TPS65910_GPIO0 + offset, &val);\n\n\tif (val & GPIO_STS_MASK)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void tps65910_gpio_set(struct gpio_chip *gc, unsigned offset,\n\t\t\t      int value)\n{\n\tstruct tps65910_gpio *tps65910_gpio = gpiochip_get_data(gc);\n\tstruct tps65910 *tps65910 = tps65910_gpio->tps65910;\n\n\tif (value)\n\t\tregmap_set_bits(tps65910->regmap, TPS65910_GPIO0 + offset,\n\t\t\t\t\t\tGPIO_SET_MASK);\n\telse\n\t\tregmap_clear_bits(tps65910->regmap, TPS65910_GPIO0 + offset,\n\t\t\t\t\t\tGPIO_SET_MASK);\n}\n\nstatic int tps65910_gpio_output(struct gpio_chip *gc, unsigned offset,\n\t\t\t\tint value)\n{\n\tstruct tps65910_gpio *tps65910_gpio = gpiochip_get_data(gc);\n\tstruct tps65910 *tps65910 = tps65910_gpio->tps65910;\n\n\t \n\ttps65910_gpio_set(gc, offset, value);\n\n\treturn regmap_set_bits(tps65910->regmap, TPS65910_GPIO0 + offset,\n\t\t\t\t\t\tGPIO_CFG_MASK);\n}\n\nstatic int tps65910_gpio_input(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct tps65910_gpio *tps65910_gpio = gpiochip_get_data(gc);\n\tstruct tps65910 *tps65910 = tps65910_gpio->tps65910;\n\n\treturn regmap_clear_bits(tps65910->regmap, TPS65910_GPIO0 + offset,\n\t\t\t\t\t\tGPIO_CFG_MASK);\n}\n\n#ifdef CONFIG_OF\nstatic struct tps65910_board *tps65910_parse_dt_for_gpio(struct device *dev,\n\t\tstruct tps65910 *tps65910, int chip_ngpio)\n{\n\tstruct tps65910_board *tps65910_board = tps65910->of_plat_data;\n\tunsigned int prop_array[TPS6591X_MAX_NUM_GPIO];\n\tint ngpio = min(chip_ngpio, TPS6591X_MAX_NUM_GPIO);\n\tint ret;\n\tint idx;\n\n\ttps65910_board->gpio_base = -1;\n\tret = of_property_read_u32_array(tps65910->dev->of_node,\n\t\t\t\"ti,en-gpio-sleep\", prop_array, ngpio);\n\tif (ret < 0) {\n\t\tdev_dbg(dev, \"ti,en-gpio-sleep not specified\\n\");\n\t\treturn tps65910_board;\n\t}\n\n\tfor (idx = 0; idx < ngpio; idx++)\n\t\ttps65910_board->en_gpio_sleep[idx] = (prop_array[idx] != 0);\n\n\treturn tps65910_board;\n}\n#else\nstatic struct tps65910_board *tps65910_parse_dt_for_gpio(struct device *dev,\n\t\tstruct tps65910 *tps65910, int chip_ngpio)\n{\n\treturn NULL;\n}\n#endif\n\nstatic int tps65910_gpio_probe(struct platform_device *pdev)\n{\n\tstruct tps65910 *tps65910 = dev_get_drvdata(pdev->dev.parent);\n\tstruct tps65910_board *pdata = dev_get_platdata(tps65910->dev);\n\tstruct tps65910_gpio *tps65910_gpio;\n\tint ret;\n\tint i;\n\n\tdevice_set_node(&pdev->dev, dev_fwnode(pdev->dev.parent));\n\n\ttps65910_gpio = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(*tps65910_gpio), GFP_KERNEL);\n\tif (!tps65910_gpio)\n\t\treturn -ENOMEM;\n\n\ttps65910_gpio->tps65910 = tps65910;\n\n\ttps65910_gpio->gpio_chip.owner = THIS_MODULE;\n\ttps65910_gpio->gpio_chip.label = tps65910->i2c_client->name;\n\n\tswitch (tps65910_chip_id(tps65910)) {\n\tcase TPS65910:\n\t\ttps65910_gpio->gpio_chip.ngpio = TPS65910_NUM_GPIO;\n\t\tbreak;\n\tcase TPS65911:\n\t\ttps65910_gpio->gpio_chip.ngpio = TPS65911_NUM_GPIO;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\ttps65910_gpio->gpio_chip.can_sleep = true;\n\ttps65910_gpio->gpio_chip.direction_input = tps65910_gpio_input;\n\ttps65910_gpio->gpio_chip.direction_output = tps65910_gpio_output;\n\ttps65910_gpio->gpio_chip.set\t= tps65910_gpio_set;\n\ttps65910_gpio->gpio_chip.get\t= tps65910_gpio_get;\n\ttps65910_gpio->gpio_chip.parent = &pdev->dev;\n\n\tif (pdata && pdata->gpio_base)\n\t\ttps65910_gpio->gpio_chip.base = pdata->gpio_base;\n\telse\n\t\ttps65910_gpio->gpio_chip.base = -1;\n\n\tif (!pdata && tps65910->dev->of_node)\n\t\tpdata = tps65910_parse_dt_for_gpio(&pdev->dev, tps65910,\n\t\t\ttps65910_gpio->gpio_chip.ngpio);\n\n\tif (!pdata)\n\t\tgoto skip_init;\n\n\t \n\tfor (i = 0; i < tps65910_gpio->gpio_chip.ngpio; ++i) {\n\t\tif (!pdata->en_gpio_sleep[i])\n\t\t\tcontinue;\n\n\t\tret = regmap_set_bits(tps65910->regmap,\n\t\t\tTPS65910_GPIO0 + i, GPIO_SLEEP_MASK);\n\t\tif (ret < 0)\n\t\t\tdev_warn(tps65910->dev,\n\t\t\t\t\"GPIO Sleep setting failed with err %d\\n\", ret);\n\t}\n\nskip_init:\n\treturn devm_gpiochip_add_data(&pdev->dev, &tps65910_gpio->gpio_chip,\n\t\t\t\t      tps65910_gpio);\n}\n\nstatic struct platform_driver tps65910_gpio_driver = {\n\t.driver.name    = \"tps65910-gpio\",\n\t.probe\t\t= tps65910_gpio_probe,\n};\n\nstatic int __init tps65910_gpio_init(void)\n{\n\treturn platform_driver_register(&tps65910_gpio_driver);\n}\nsubsys_initcall(tps65910_gpio_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}