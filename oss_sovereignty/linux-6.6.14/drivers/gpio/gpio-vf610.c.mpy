{
  "module_name": "gpio-vf610.c",
  "hash_id": "e9281394414b837ba7b4e768dbf844cd1ffcc9215e6f9590e3af3deb3d2d24a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-vf610.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/pinctrl/consumer.h>\n\n#define VF610_GPIO_PER_PORT\t\t32\n\nstruct fsl_gpio_soc_data {\n\t \n\tbool have_paddr;\n};\n\nstruct vf610_gpio_port {\n\tstruct gpio_chip gc;\n\tvoid __iomem *base;\n\tvoid __iomem *gpio_base;\n\tconst struct fsl_gpio_soc_data *sdata;\n\tu8 irqc[VF610_GPIO_PER_PORT];\n\tstruct clk *clk_port;\n\tstruct clk *clk_gpio;\n\tint irq;\n};\n\n#define GPIO_PDOR\t\t0x00\n#define GPIO_PSOR\t\t0x04\n#define GPIO_PCOR\t\t0x08\n#define GPIO_PTOR\t\t0x0c\n#define GPIO_PDIR\t\t0x10\n#define GPIO_PDDR\t\t0x14\n\n#define PORT_PCR(n)\t\t((n) * 0x4)\n#define PORT_PCR_IRQC_OFFSET\t16\n\n#define PORT_ISFR\t\t0xa0\n#define PORT_DFER\t\t0xc0\n#define PORT_DFCR\t\t0xc4\n#define PORT_DFWR\t\t0xc8\n\n#define PORT_INT_OFF\t\t0x0\n#define PORT_INT_LOGIC_ZERO\t0x8\n#define PORT_INT_RISING_EDGE\t0x9\n#define PORT_INT_FALLING_EDGE\t0xa\n#define PORT_INT_EITHER_EDGE\t0xb\n#define PORT_INT_LOGIC_ONE\t0xc\n\nstatic const struct fsl_gpio_soc_data imx_data = {\n\t.have_paddr = true,\n};\n\nstatic const struct of_device_id vf610_gpio_dt_ids[] = {\n\t{ .compatible = \"fsl,vf610-gpio\",\t.data = NULL, },\n\t{ .compatible = \"fsl,imx7ulp-gpio\",\t.data = &imx_data, },\n\t{   }\n};\n\nstatic inline void vf610_gpio_writel(u32 val, void __iomem *reg)\n{\n\twritel_relaxed(val, reg);\n}\n\nstatic inline u32 vf610_gpio_readl(void __iomem *reg)\n{\n\treturn readl_relaxed(reg);\n}\n\nstatic int vf610_gpio_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct vf610_gpio_port *port = gpiochip_get_data(gc);\n\tunsigned long mask = BIT(gpio);\n\tunsigned long offset = GPIO_PDIR;\n\n\tif (port->sdata && port->sdata->have_paddr) {\n\t\tmask &= vf610_gpio_readl(port->gpio_base + GPIO_PDDR);\n\t\tif (mask)\n\t\t\toffset = GPIO_PDOR;\n\t}\n\n\treturn !!(vf610_gpio_readl(port->gpio_base + offset) & BIT(gpio));\n}\n\nstatic void vf610_gpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\n{\n\tstruct vf610_gpio_port *port = gpiochip_get_data(gc);\n\tunsigned long mask = BIT(gpio);\n\tunsigned long offset = val ? GPIO_PSOR : GPIO_PCOR;\n\n\tvf610_gpio_writel(mask, port->gpio_base + offset);\n}\n\nstatic int vf610_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct vf610_gpio_port *port = gpiochip_get_data(chip);\n\tunsigned long mask = BIT(gpio);\n\tu32 val;\n\n\tif (port->sdata && port->sdata->have_paddr) {\n\t\tval = vf610_gpio_readl(port->gpio_base + GPIO_PDDR);\n\t\tval &= ~mask;\n\t\tvf610_gpio_writel(val, port->gpio_base + GPIO_PDDR);\n\t}\n\n\treturn pinctrl_gpio_direction_input(chip->base + gpio);\n}\n\nstatic int vf610_gpio_direction_output(struct gpio_chip *chip, unsigned gpio,\n\t\t\t\t       int value)\n{\n\tstruct vf610_gpio_port *port = gpiochip_get_data(chip);\n\tunsigned long mask = BIT(gpio);\n\tu32 val;\n\n\tvf610_gpio_set(chip, gpio, value);\n\n\tif (port->sdata && port->sdata->have_paddr) {\n\t\tval = vf610_gpio_readl(port->gpio_base + GPIO_PDDR);\n\t\tval |= mask;\n\t\tvf610_gpio_writel(val, port->gpio_base + GPIO_PDDR);\n\t}\n\n\treturn pinctrl_gpio_direction_output(chip->base + gpio);\n}\n\nstatic void vf610_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct vf610_gpio_port *port =\n\t\tgpiochip_get_data(irq_desc_get_handler_data(desc));\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tint pin;\n\tunsigned long irq_isfr;\n\n\tchained_irq_enter(chip, desc);\n\n\tirq_isfr = vf610_gpio_readl(port->base + PORT_ISFR);\n\n\tfor_each_set_bit(pin, &irq_isfr, VF610_GPIO_PER_PORT) {\n\t\tvf610_gpio_writel(BIT(pin), port->base + PORT_ISFR);\n\n\t\tgeneric_handle_domain_irq(port->gc.irq.domain, pin);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void vf610_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct vf610_gpio_port *port =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(d));\n\tint gpio = d->hwirq;\n\n\tvf610_gpio_writel(BIT(gpio), port->base + PORT_ISFR);\n}\n\nstatic int vf610_gpio_irq_set_type(struct irq_data *d, u32 type)\n{\n\tstruct vf610_gpio_port *port =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(d));\n\tu8 irqc;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tirqc = PORT_INT_RISING_EDGE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tirqc = PORT_INT_FALLING_EDGE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tirqc = PORT_INT_EITHER_EDGE;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tirqc = PORT_INT_LOGIC_ZERO;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tirqc = PORT_INT_LOGIC_ONE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tport->irqc[d->hwirq] = irqc;\n\n\tif (type & IRQ_TYPE_LEVEL_MASK)\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\telse\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\n\treturn 0;\n}\n\nstatic void vf610_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct vf610_gpio_port *port = gpiochip_get_data(gc);\n\tirq_hw_number_t gpio_num = irqd_to_hwirq(d);\n\tvoid __iomem *pcr_base = port->base + PORT_PCR(gpio_num);\n\n\tvf610_gpio_writel(0, pcr_base);\n\tgpiochip_disable_irq(gc, gpio_num);\n}\n\nstatic void vf610_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct vf610_gpio_port *port = gpiochip_get_data(gc);\n\tirq_hw_number_t gpio_num = irqd_to_hwirq(d);\n\tvoid __iomem *pcr_base = port->base + PORT_PCR(gpio_num);\n\n\tgpiochip_enable_irq(gc, gpio_num);\n\tvf610_gpio_writel(port->irqc[gpio_num] << PORT_PCR_IRQC_OFFSET,\n\t\t\t  pcr_base);\n}\n\nstatic int vf610_gpio_irq_set_wake(struct irq_data *d, u32 enable)\n{\n\tstruct vf610_gpio_port *port =\n\t\tgpiochip_get_data(irq_data_get_irq_chip_data(d));\n\n\tif (enable)\n\t\tenable_irq_wake(port->irq);\n\telse\n\t\tdisable_irq_wake(port->irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip vf610_irqchip = {\n\t.name = \"gpio-vf610\",\n\t.irq_ack = vf610_gpio_irq_ack,\n\t.irq_mask = vf610_gpio_irq_mask,\n\t.irq_unmask = vf610_gpio_irq_unmask,\n\t.irq_set_type = vf610_gpio_irq_set_type,\n\t.irq_set_wake = vf610_gpio_irq_set_wake,\n\t.flags = IRQCHIP_IMMUTABLE | IRQCHIP_MASK_ON_SUSPEND\n\t\t\t| IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void vf610_gpio_disable_clk(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int vf610_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct vf610_gpio_port *port;\n\tstruct gpio_chip *gc;\n\tstruct gpio_irq_chip *girq;\n\tint i;\n\tint ret;\n\n\tport = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->sdata = of_device_get_match_data(dev);\n\tport->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(port->base))\n\t\treturn PTR_ERR(port->base);\n\n\tport->gpio_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(port->gpio_base))\n\t\treturn PTR_ERR(port->gpio_base);\n\n\tport->irq = platform_get_irq(pdev, 0);\n\tif (port->irq < 0)\n\t\treturn port->irq;\n\n\tport->clk_port = devm_clk_get(dev, \"port\");\n\tret = PTR_ERR_OR_ZERO(port->clk_port);\n\tif (!ret) {\n\t\tret = clk_prepare_enable(port->clk_port);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = devm_add_action_or_reset(dev, vf610_gpio_disable_clk,\n\t\t\t\t\t       port->clk_port);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (ret == -EPROBE_DEFER) {\n\t\t \n\t\treturn ret;\n\t}\n\n\tport->clk_gpio = devm_clk_get(dev, \"gpio\");\n\tret = PTR_ERR_OR_ZERO(port->clk_gpio);\n\tif (!ret) {\n\t\tret = clk_prepare_enable(port->clk_gpio);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = devm_add_action_or_reset(dev, vf610_gpio_disable_clk,\n\t\t\t\t\t       port->clk_gpio);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (ret == -EPROBE_DEFER) {\n\t\treturn ret;\n\t}\n\n\tgc = &port->gc;\n\tgc->parent = dev;\n\tgc->label = dev_name(dev);\n\tgc->ngpio = VF610_GPIO_PER_PORT;\n\tgc->base = -1;\n\n\tgc->request = gpiochip_generic_request;\n\tgc->free = gpiochip_generic_free;\n\tgc->direction_input = vf610_gpio_direction_input;\n\tgc->get = vf610_gpio_get;\n\tgc->direction_output = vf610_gpio_direction_output;\n\tgc->set = vf610_gpio_set;\n\n\t \n\tfor (i = 0; i < gc->ngpio; i++)\n\t\tvf610_gpio_writel(0, port->base + PORT_PCR(i));\n\n\t \n\tvf610_gpio_writel(~0, port->base + PORT_ISFR);\n\n\tgirq = &gc->irq;\n\tgpio_irq_chip_set_chip(girq, &vf610_irqchip);\n\tgirq->parent_handler = vf610_gpio_irq_handler;\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(&pdev->dev, 1,\n\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t     GFP_KERNEL);\n\tif (!girq->parents)\n\t\treturn -ENOMEM;\n\tgirq->parents[0] = port->irq;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_edge_irq;\n\n\treturn devm_gpiochip_add_data(dev, gc, port);\n}\n\nstatic struct platform_driver vf610_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"gpio-vf610\",\n\t\t.of_match_table = vf610_gpio_dt_ids,\n\t},\n\t.probe\t\t= vf610_gpio_probe,\n};\n\nbuiltin_platform_driver(vf610_gpio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}