{
  "module_name": "gpio-ftgpio010.c",
  "hash_id": "a3940b5833edb548747347ceae6f16e3c460a7a331e68bacc15015a134782600",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-ftgpio010.c",
  "human_readable_source": "\n \n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n\n \n#define GPIO_DATA_OUT\t\t0x00\n#define GPIO_DATA_IN\t\t0x04\n#define GPIO_DIR\t\t0x08\n#define GPIO_BYPASS_IN\t\t0x0C\n#define GPIO_DATA_SET\t\t0x10\n#define GPIO_DATA_CLR\t\t0x14\n#define GPIO_PULL_EN\t\t0x18\n#define GPIO_PULL_TYPE\t\t0x1C\n#define GPIO_INT_EN\t\t0x20\n#define GPIO_INT_STAT_RAW\t0x24\n#define GPIO_INT_STAT_MASKED\t0x28\n#define GPIO_INT_MASK\t\t0x2C\n#define GPIO_INT_CLR\t\t0x30\n#define GPIO_INT_TYPE\t\t0x34\n#define GPIO_INT_BOTH_EDGE\t0x38\n#define GPIO_INT_LEVEL\t\t0x3C\n#define GPIO_DEBOUNCE_EN\t0x40\n#define GPIO_DEBOUNCE_PRESCALE\t0x44\n\n \nstruct ftgpio_gpio {\n\tstruct device *dev;\n\tstruct gpio_chip gc;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic void ftgpio_gpio_ack_irq(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct ftgpio_gpio *g = gpiochip_get_data(gc);\n\n\twritel(BIT(irqd_to_hwirq(d)), g->base + GPIO_INT_CLR);\n}\n\nstatic void ftgpio_gpio_mask_irq(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct ftgpio_gpio *g = gpiochip_get_data(gc);\n\tu32 val;\n\n\tval = readl(g->base + GPIO_INT_EN);\n\tval &= ~BIT(irqd_to_hwirq(d));\n\twritel(val, g->base + GPIO_INT_EN);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void ftgpio_gpio_unmask_irq(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct ftgpio_gpio *g = gpiochip_get_data(gc);\n\tu32 val;\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\tval = readl(g->base + GPIO_INT_EN);\n\tval |= BIT(irqd_to_hwirq(d));\n\twritel(val, g->base + GPIO_INT_EN);\n}\n\nstatic int ftgpio_gpio_set_irq_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct ftgpio_gpio *g = gpiochip_get_data(gc);\n\tu32 mask = BIT(irqd_to_hwirq(d));\n\tu32 reg_both, reg_level, reg_type;\n\n\treg_type = readl(g->base + GPIO_INT_TYPE);\n\treg_level = readl(g->base + GPIO_INT_LEVEL);\n\treg_both = readl(g->base + GPIO_INT_BOTH_EDGE);\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\treg_type &= ~mask;\n\t\treg_both |= mask;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\treg_type &= ~mask;\n\t\treg_both &= ~mask;\n\t\treg_level &= ~mask;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\treg_type &= ~mask;\n\t\treg_both &= ~mask;\n\t\treg_level |= mask;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\treg_type |= mask;\n\t\treg_level &= ~mask;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\treg_type |= mask;\n\t\treg_level |= mask;\n\t\tbreak;\n\tdefault:\n\t\tirq_set_handler_locked(d, handle_bad_irq);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(reg_type, g->base + GPIO_INT_TYPE);\n\twritel(reg_level, g->base + GPIO_INT_LEVEL);\n\twritel(reg_both, g->base + GPIO_INT_BOTH_EDGE);\n\n\tftgpio_gpio_ack_irq(d);\n\n\treturn 0;\n}\n\nstatic void ftgpio_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct ftgpio_gpio *g = gpiochip_get_data(gc);\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\tint offset;\n\tunsigned long stat;\n\n\tchained_irq_enter(irqchip, desc);\n\n\tstat = readl(g->base + GPIO_INT_STAT_RAW);\n\tif (stat)\n\t\tfor_each_set_bit(offset, &stat, gc->ngpio)\n\t\t\tgeneric_handle_domain_irq(gc->irq.domain, offset);\n\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic int ftgpio_gpio_set_config(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\t  unsigned long config)\n{\n\tenum pin_config_param param = pinconf_to_config_param(config);\n\tu32 arg = pinconf_to_config_argument(config);\n\tstruct ftgpio_gpio *g = gpiochip_get_data(gc);\n\tunsigned long pclk_freq;\n\tu32 deb_div;\n\tu32 val;\n\n\tif (param != PIN_CONFIG_INPUT_DEBOUNCE)\n\t\treturn -ENOTSUPP;\n\n\t \n\tpclk_freq = clk_get_rate(g->clk);\n\tdeb_div = DIV_ROUND_CLOSEST(pclk_freq, arg);\n\n\t \n\tif (deb_div > (1 << 24))\n\t\treturn -ENOTSUPP;\n\n\tdev_dbg(g->dev, \"prescale divisor: %08x, resulting frequency %lu Hz\\n\",\n\t\tdeb_div, (pclk_freq/deb_div));\n\n\tval = readl(g->base + GPIO_DEBOUNCE_PRESCALE);\n\tif (val == deb_div) {\n\t\t \n\t\tval = readl(g->base + GPIO_DEBOUNCE_EN);\n\t\tval |= BIT(offset);\n\t\twritel(val, g->base + GPIO_DEBOUNCE_EN);\n\t\treturn 0;\n\t}\n\n\tval = readl(g->base + GPIO_DEBOUNCE_EN);\n\tif (val) {\n\t\t \n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\twritel(deb_div, g->base + GPIO_DEBOUNCE_PRESCALE);\n\t \n\tval |= BIT(offset);\n\twritel(val, g->base + GPIO_DEBOUNCE_EN);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip ftgpio_irq_chip = {\n\t.name = \"FTGPIO010\",\n\t.irq_ack = ftgpio_gpio_ack_irq,\n\t.irq_mask = ftgpio_gpio_mask_irq,\n\t.irq_unmask = ftgpio_gpio_unmask_irq,\n\t.irq_set_type = ftgpio_gpio_set_irq_type,\n\t.flags = IRQCHIP_IMMUTABLE,\n\t GPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int ftgpio_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ftgpio_gpio *g;\n\tstruct gpio_irq_chip *girq;\n\tint irq;\n\tint ret;\n\n\tg = devm_kzalloc(dev, sizeof(*g), GFP_KERNEL);\n\tif (!g)\n\t\treturn -ENOMEM;\n\n\tg->dev = dev;\n\n\tg->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(g->base))\n\t\treturn PTR_ERR(g->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tg->clk = devm_clk_get(dev, NULL);\n\tif (!IS_ERR(g->clk)) {\n\t\tret = clk_prepare_enable(g->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (PTR_ERR(g->clk) == -EPROBE_DEFER) {\n\t\t \n\t\treturn PTR_ERR(g->clk);\n\t}\n\n\tret = bgpio_init(&g->gc, dev, 4,\n\t\t\t g->base + GPIO_DATA_IN,\n\t\t\t g->base + GPIO_DATA_SET,\n\t\t\t g->base + GPIO_DATA_CLR,\n\t\t\t g->base + GPIO_DIR,\n\t\t\t NULL,\n\t\t\t 0);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to init generic GPIO\\n\");\n\t\tgoto dis_clk;\n\t}\n\tg->gc.label = dev_name(dev);\n\tg->gc.base = -1;\n\tg->gc.parent = dev;\n\tg->gc.owner = THIS_MODULE;\n\t \n\n\t \n\tif (!IS_ERR(g->clk))\n\t\tg->gc.set_config = ftgpio_gpio_set_config;\n\n\tgirq = &g->gc.irq;\n\tgpio_irq_chip_set_chip(girq, &ftgpio_irq_chip);\n\tgirq->parent_handler = ftgpio_gpio_irq_handler;\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(dev, 1, sizeof(*girq->parents),\n\t\t\t\t     GFP_KERNEL);\n\tif (!girq->parents) {\n\t\tret = -ENOMEM;\n\t\tgoto dis_clk;\n\t}\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\tgirq->parents[0] = irq;\n\n\t \n\twritel(0x0, g->base + GPIO_INT_EN);\n\twritel(0x0, g->base + GPIO_INT_MASK);\n\twritel(~0x0, g->base + GPIO_INT_CLR);\n\n\t \n\twritel(0x0, g->base + GPIO_DEBOUNCE_EN);\n\n\tret = devm_gpiochip_add_data(dev, &g->gc, g);\n\tif (ret)\n\t\tgoto dis_clk;\n\n\tplatform_set_drvdata(pdev, g);\n\tdev_info(dev, \"FTGPIO010 @%p registered\\n\", g->base);\n\n\treturn 0;\n\ndis_clk:\n\tclk_disable_unprepare(g->clk);\n\n\treturn ret;\n}\n\nstatic int ftgpio_gpio_remove(struct platform_device *pdev)\n{\n\tstruct ftgpio_gpio *g = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(g->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ftgpio_gpio_of_match[] = {\n\t{\n\t\t.compatible = \"cortina,gemini-gpio\",\n\t},\n\t{\n\t\t.compatible = \"moxa,moxart-gpio\",\n\t},\n\t{\n\t\t.compatible = \"faraday,ftgpio010\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver ftgpio_gpio_driver = {\n\t.driver = {\n\t\t.name\t\t= \"ftgpio010-gpio\",\n\t\t.of_match_table = ftgpio_gpio_of_match,\n\t},\n\t.probe = ftgpio_gpio_probe,\n\t.remove = ftgpio_gpio_remove,\n};\nbuiltin_platform_driver(ftgpio_gpio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}