{
  "module_name": "gpio-latch.c",
  "hash_id": "4ffb0197af6fabfd0c7140e6ecf2d3f38610b364db05ae9b4196dc4247e8331b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-latch.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n\n#include \"gpiolib.h\"\n\nstruct gpio_latch_priv {\n\tstruct gpio_chip gc;\n\tstruct gpio_descs *clk_gpios;\n\tstruct gpio_descs *latched_gpios;\n\tint n_latched_gpios;\n\tunsigned int setup_duration_ns;\n\tunsigned int clock_duration_ns;\n\tunsigned long *shadow;\n\t \n\tunion {\n\t\tstruct mutex mutex;  \n\t\tspinlock_t spinlock;  \n\t};\n};\n\nstatic int gpio_latch_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic void gpio_latch_set_unlocked(struct gpio_latch_priv *priv,\n\t\t\t\t    void (*set)(struct gpio_desc *desc, int value),\n\t\t\t\t    unsigned int offset, bool val)\n{\n\tint latch = offset / priv->n_latched_gpios;\n\tint i;\n\n\tassign_bit(offset, priv->shadow, val);\n\n\tfor (i = 0; i < priv->n_latched_gpios; i++)\n\t\tset(priv->latched_gpios->desc[i],\n\t\t    test_bit(latch * priv->n_latched_gpios + i, priv->shadow));\n\n\tndelay(priv->setup_duration_ns);\n\tset(priv->clk_gpios->desc[latch], 1);\n\tndelay(priv->clock_duration_ns);\n\tset(priv->clk_gpios->desc[latch], 0);\n}\n\nstatic void gpio_latch_set(struct gpio_chip *gc, unsigned int offset, int val)\n{\n\tstruct gpio_latch_priv *priv = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\n\tgpio_latch_set_unlocked(priv, gpiod_set_value, offset, val);\n\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n}\n\nstatic void gpio_latch_set_can_sleep(struct gpio_chip *gc, unsigned int offset, int val)\n{\n\tstruct gpio_latch_priv *priv = gpiochip_get_data(gc);\n\n\tmutex_lock(&priv->mutex);\n\n\tgpio_latch_set_unlocked(priv, gpiod_set_value_cansleep, offset, val);\n\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic bool gpio_latch_can_sleep(struct gpio_latch_priv *priv, unsigned int n_latches)\n{\n\tint i;\n\n\tfor (i = 0; i < n_latches; i++)\n\t\tif (gpiod_cansleep(priv->clk_gpios->desc[i]))\n\t\t\treturn true;\n\n\tfor (i = 0; i < priv->n_latched_gpios; i++)\n\t\tif (gpiod_cansleep(priv->latched_gpios->desc[i]))\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \n#define DURATION_NS_MAX 5000\n\nstatic int gpio_latch_probe(struct platform_device *pdev)\n{\n\tstruct gpio_latch_priv *priv;\n\tunsigned int n_latches;\n\tstruct device_node *np = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->clk_gpios = devm_gpiod_get_array(&pdev->dev, \"clk\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->clk_gpios))\n\t\treturn PTR_ERR(priv->clk_gpios);\n\n\tpriv->latched_gpios = devm_gpiod_get_array(&pdev->dev, \"latched\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->latched_gpios))\n\t\treturn PTR_ERR(priv->latched_gpios);\n\n\tn_latches = priv->clk_gpios->ndescs;\n\tpriv->n_latched_gpios = priv->latched_gpios->ndescs;\n\n\tpriv->shadow = devm_bitmap_zalloc(&pdev->dev, n_latches * priv->n_latched_gpios,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!priv->shadow)\n\t\treturn -ENOMEM;\n\n\tif (gpio_latch_can_sleep(priv, n_latches)) {\n\t\tpriv->gc.can_sleep = true;\n\t\tpriv->gc.set = gpio_latch_set_can_sleep;\n\t\tmutex_init(&priv->mutex);\n\t} else {\n\t\tpriv->gc.can_sleep = false;\n\t\tpriv->gc.set = gpio_latch_set;\n\t\tspin_lock_init(&priv->spinlock);\n\t}\n\n\tof_property_read_u32(np, \"setup-duration-ns\", &priv->setup_duration_ns);\n\tif (priv->setup_duration_ns > DURATION_NS_MAX) {\n\t\tdev_warn(&pdev->dev, \"setup-duration-ns too high, limit to %d\\n\",\n\t\t\t DURATION_NS_MAX);\n\t\tpriv->setup_duration_ns = DURATION_NS_MAX;\n\t}\n\n\tof_property_read_u32(np, \"clock-duration-ns\", &priv->clock_duration_ns);\n\tif (priv->clock_duration_ns > DURATION_NS_MAX) {\n\t\tdev_warn(&pdev->dev, \"clock-duration-ns too high, limit to %d\\n\",\n\t\t\t DURATION_NS_MAX);\n\t\tpriv->clock_duration_ns = DURATION_NS_MAX;\n\t}\n\n\tpriv->gc.get_direction = gpio_latch_get_direction;\n\tpriv->gc.ngpio = n_latches * priv->n_latched_gpios;\n\tpriv->gc.owner = THIS_MODULE;\n\tpriv->gc.base = -1;\n\tpriv->gc.parent = &pdev->dev;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &priv->gc, priv);\n}\n\nstatic const struct of_device_id gpio_latch_ids[] = {\n\t{\n\t\t.compatible = \"gpio-latch\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, gpio_latch_ids);\n\nstatic struct platform_driver gpio_latch_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"gpio-latch\",\n\t\t.of_match_table\t= gpio_latch_ids,\n\t},\n\t.probe\t= gpio_latch_probe,\n};\nmodule_platform_driver(gpio_latch_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Sascha Hauer <s.hauer@pengutronix.de>\");\nMODULE_DESCRIPTION(\"GPIO latch driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}