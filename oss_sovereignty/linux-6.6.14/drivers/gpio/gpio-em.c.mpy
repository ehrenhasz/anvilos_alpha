{
  "module_name": "gpio-em.c",
  "hash_id": "f9cb55a39f8d6aaef08d4e35ed1ab58618a9520cef206571098633bee7a714a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-em.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n\nstruct em_gio_priv {\n\tvoid __iomem *base0;\n\tvoid __iomem *base1;\n\tspinlock_t sense_lock;\n\tstruct platform_device *pdev;\n\tstruct gpio_chip gpio_chip;\n\tstruct irq_chip irq_chip;\n\tstruct irq_domain *irq_domain;\n};\n\n#define GIO_E1 0x00\n#define GIO_E0 0x04\n#define GIO_EM 0x04\n#define GIO_OL 0x08\n#define GIO_OH 0x0c\n#define GIO_I 0x10\n#define GIO_IIA 0x14\n#define GIO_IEN 0x18\n#define GIO_IDS 0x1c\n#define GIO_IIM 0x1c\n#define GIO_RAW 0x20\n#define GIO_MST 0x24\n#define GIO_IIR 0x28\n\n#define GIO_IDT0 0x40\n#define GIO_IDT1 0x44\n#define GIO_IDT2 0x48\n#define GIO_IDT3 0x4c\n#define GIO_RAWBL 0x50\n#define GIO_RAWBH 0x54\n#define GIO_IRBL 0x58\n#define GIO_IRBH 0x5c\n\n#define GIO_IDT(n) (GIO_IDT0 + ((n) * 4))\n\nstatic inline unsigned long em_gio_read(struct em_gio_priv *p, int offs)\n{\n\tif (offs < GIO_IDT0)\n\t\treturn ioread32(p->base0 + offs);\n\telse\n\t\treturn ioread32(p->base1 + (offs - GIO_IDT0));\n}\n\nstatic inline void em_gio_write(struct em_gio_priv *p, int offs,\n\t\t\t\tunsigned long value)\n{\n\tif (offs < GIO_IDT0)\n\t\tiowrite32(value, p->base0 + offs);\n\telse\n\t\tiowrite32(value, p->base1 + (offs - GIO_IDT0));\n}\n\nstatic void em_gio_irq_disable(struct irq_data *d)\n{\n\tstruct em_gio_priv *p = irq_data_get_irq_chip_data(d);\n\n\tem_gio_write(p, GIO_IDS, BIT(irqd_to_hwirq(d)));\n}\n\nstatic void em_gio_irq_enable(struct irq_data *d)\n{\n\tstruct em_gio_priv *p = irq_data_get_irq_chip_data(d);\n\n\tem_gio_write(p, GIO_IEN, BIT(irqd_to_hwirq(d)));\n}\n\nstatic int em_gio_irq_reqres(struct irq_data *d)\n{\n\tstruct em_gio_priv *p = irq_data_get_irq_chip_data(d);\n\tint ret;\n\n\tret = gpiochip_lock_as_irq(&p->gpio_chip, irqd_to_hwirq(d));\n\tif (ret) {\n\t\tdev_err(p->gpio_chip.parent,\n\t\t\t\"unable to lock HW IRQ %lu for IRQ\\n\",\n\t\t\tirqd_to_hwirq(d));\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void em_gio_irq_relres(struct irq_data *d)\n{\n\tstruct em_gio_priv *p = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_unlock_as_irq(&p->gpio_chip, irqd_to_hwirq(d));\n}\n\n\n#define GIO_ASYNC(x) (x + 8)\n\nstatic unsigned char em_gio_sense_table[IRQ_TYPE_SENSE_MASK + 1] = {\n\t[IRQ_TYPE_EDGE_RISING] = GIO_ASYNC(0x00),\n\t[IRQ_TYPE_EDGE_FALLING] = GIO_ASYNC(0x01),\n\t[IRQ_TYPE_LEVEL_HIGH] = GIO_ASYNC(0x02),\n\t[IRQ_TYPE_LEVEL_LOW] = GIO_ASYNC(0x03),\n\t[IRQ_TYPE_EDGE_BOTH] = GIO_ASYNC(0x04),\n};\n\nstatic int em_gio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tunsigned char value = em_gio_sense_table[type & IRQ_TYPE_SENSE_MASK];\n\tstruct em_gio_priv *p = irq_data_get_irq_chip_data(d);\n\tunsigned int reg, offset, shift;\n\tunsigned long flags;\n\tunsigned long tmp;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\toffset = irqd_to_hwirq(d);\n\n\tpr_debug(\"gio: sense irq = %d, mode = %d\\n\", offset, value);\n\n\t \n\treg = GIO_IDT(offset >> 3);\n\tshift = (offset & 0x07) << 4;\n\n\tspin_lock_irqsave(&p->sense_lock, flags);\n\n\t \n\ttmp = em_gio_read(p, GIO_IIA);\n\ttmp &= ~BIT(offset);\n\tem_gio_write(p, GIO_IIA, tmp);\n\n\t \n\ttmp = em_gio_read(p, reg);\n\ttmp &= ~(0xf << shift);\n\ttmp |= value << shift;\n\tem_gio_write(p, reg, tmp);\n\n\t \n\tem_gio_write(p, GIO_IIR, BIT(offset));\n\n\t \n\ttmp = em_gio_read(p, GIO_IIA);\n\ttmp |= BIT(offset);\n\tem_gio_write(p, GIO_IIA, tmp);\n\n\tspin_unlock_irqrestore(&p->sense_lock, flags);\n\n\treturn 0;\n}\n\nstatic irqreturn_t em_gio_irq_handler(int irq, void *dev_id)\n{\n\tstruct em_gio_priv *p = dev_id;\n\tunsigned long pending;\n\tunsigned int offset, irqs_handled = 0;\n\n\twhile ((pending = em_gio_read(p, GIO_MST))) {\n\t\toffset = __ffs(pending);\n\t\tem_gio_write(p, GIO_IIR, BIT(offset));\n\t\tgeneric_handle_domain_irq(p->irq_domain, offset);\n\t\tirqs_handled++;\n\t}\n\n\treturn irqs_handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic inline struct em_gio_priv *gpio_to_priv(struct gpio_chip *chip)\n{\n\treturn gpiochip_get_data(chip);\n}\n\nstatic int em_gio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tem_gio_write(gpio_to_priv(chip), GIO_E0, BIT(offset));\n\treturn 0;\n}\n\nstatic int em_gio_get(struct gpio_chip *chip, unsigned offset)\n{\n\treturn !!(em_gio_read(gpio_to_priv(chip), GIO_I) & BIT(offset));\n}\n\nstatic void __em_gio_set(struct gpio_chip *chip, unsigned int reg,\n\t\t\t unsigned shift, int value)\n{\n\t \n\tem_gio_write(gpio_to_priv(chip), reg,\n\t\t     (BIT(shift + 16)) | (value << shift));\n}\n\nstatic void em_gio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\t \n\tif (offset < 16)\n\t\t__em_gio_set(chip, GIO_OL, offset, value);\n\telse\n\t\t__em_gio_set(chip, GIO_OH, offset - 16, value);\n}\n\nstatic int em_gio_direction_output(struct gpio_chip *chip, unsigned offset,\n\t\t\t\t   int value)\n{\n\t \n\tem_gio_set(chip, offset, value);\n\tem_gio_write(gpio_to_priv(chip), GIO_E1, BIT(offset));\n\treturn 0;\n}\n\nstatic int em_gio_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\treturn irq_create_mapping(gpio_to_priv(chip)->irq_domain, offset);\n}\n\nstatic int em_gio_request(struct gpio_chip *chip, unsigned offset)\n{\n\treturn pinctrl_gpio_request(chip->base + offset);\n}\n\nstatic void em_gio_free(struct gpio_chip *chip, unsigned offset)\n{\n\tpinctrl_gpio_free(chip->base + offset);\n\n\t \n\tem_gio_direction_input(chip, offset);\n}\n\nstatic int em_gio_irq_domain_map(struct irq_domain *h, unsigned int irq,\n\t\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct em_gio_priv *p = h->host_data;\n\n\tpr_debug(\"gio: map hw irq = %d, irq = %d\\n\", (int)hwirq, irq);\n\n\tirq_set_chip_data(irq, h->host_data);\n\tirq_set_chip_and_handler(irq, &p->irq_chip, handle_level_irq);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops em_gio_irq_domain_ops = {\n\t.map\t= em_gio_irq_domain_map,\n\t.xlate\t= irq_domain_xlate_twocell,\n};\n\nstatic void em_gio_irq_domain_remove(void *data)\n{\n\tstruct irq_domain *domain = data;\n\n\tirq_domain_remove(domain);\n}\n\nstatic int em_gio_probe(struct platform_device *pdev)\n{\n\tstruct em_gio_priv *p;\n\tstruct gpio_chip *gpio_chip;\n\tstruct irq_chip *irq_chip;\n\tstruct device *dev = &pdev->dev;\n\tconst char *name = dev_name(dev);\n\tunsigned int ngpios;\n\tint irq[2], ret;\n\n\tp = devm_kzalloc(dev, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->pdev = pdev;\n\tplatform_set_drvdata(pdev, p);\n\tspin_lock_init(&p->sense_lock);\n\n\tirq[0] = platform_get_irq(pdev, 0);\n\tif (irq[0] < 0)\n\t\treturn irq[0];\n\n\tirq[1] = platform_get_irq(pdev, 1);\n\tif (irq[1] < 0)\n\t\treturn irq[1];\n\n\tp->base0 = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(p->base0))\n\t\treturn PTR_ERR(p->base0);\n\n\tp->base1 = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(p->base1))\n\t\treturn PTR_ERR(p->base1);\n\n\tif (of_property_read_u32(dev->of_node, \"ngpios\", &ngpios)) {\n\t\tdev_err(dev, \"Missing ngpios OF property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_chip = &p->gpio_chip;\n\tgpio_chip->direction_input = em_gio_direction_input;\n\tgpio_chip->get = em_gio_get;\n\tgpio_chip->direction_output = em_gio_direction_output;\n\tgpio_chip->set = em_gio_set;\n\tgpio_chip->to_irq = em_gio_to_irq;\n\tgpio_chip->request = em_gio_request;\n\tgpio_chip->free = em_gio_free;\n\tgpio_chip->label = name;\n\tgpio_chip->parent = dev;\n\tgpio_chip->owner = THIS_MODULE;\n\tgpio_chip->base = -1;\n\tgpio_chip->ngpio = ngpios;\n\n\tirq_chip = &p->irq_chip;\n\tirq_chip->name = \"gpio-em\";\n\tirq_chip->irq_mask = em_gio_irq_disable;\n\tirq_chip->irq_unmask = em_gio_irq_enable;\n\tirq_chip->irq_set_type = em_gio_irq_set_type;\n\tirq_chip->irq_request_resources = em_gio_irq_reqres;\n\tirq_chip->irq_release_resources = em_gio_irq_relres;\n\tirq_chip->flags\t= IRQCHIP_SKIP_SET_WAKE | IRQCHIP_MASK_ON_SUSPEND;\n\n\tp->irq_domain = irq_domain_add_simple(dev->of_node, ngpios, 0,\n\t\t\t\t\t      &em_gio_irq_domain_ops, p);\n\tif (!p->irq_domain) {\n\t\tdev_err(dev, \"cannot initialize irq domain\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = devm_add_action_or_reset(dev, em_gio_irq_domain_remove,\n\t\t\t\t       p->irq_domain);\n\tif (ret)\n\t\treturn ret;\n\n\tif (devm_request_irq(dev, irq[0], em_gio_irq_handler, 0, name, p)) {\n\t\tdev_err(dev, \"failed to request low IRQ\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (devm_request_irq(dev, irq[1], em_gio_irq_handler, 0, name, p)) {\n\t\tdev_err(dev, \"failed to request high IRQ\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tret = devm_gpiochip_add_data(dev, gpio_chip, p);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add GPIO controller\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id em_gio_dt_ids[] = {\n\t{ .compatible = \"renesas,em-gio\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, em_gio_dt_ids);\n\nstatic struct platform_driver em_gio_device_driver = {\n\t.probe\t\t= em_gio_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"em_gio\",\n\t\t.of_match_table = em_gio_dt_ids,\n\t}\n};\n\nstatic int __init em_gio_init(void)\n{\n\treturn platform_driver_register(&em_gio_device_driver);\n}\npostcore_initcall(em_gio_init);\n\nstatic void __exit em_gio_exit(void)\n{\n\tplatform_driver_unregister(&em_gio_device_driver);\n}\nmodule_exit(em_gio_exit);\n\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_DESCRIPTION(\"Renesas Emma Mobile GIO Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}