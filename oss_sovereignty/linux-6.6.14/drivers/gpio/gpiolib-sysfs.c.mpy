{
  "module_name": "gpiolib-sysfs.c",
  "hash_id": "441e1e1b7581e120ea4002f0a96d6f6a991f74774b7b66282d118ad826bc85b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpiolib-sysfs.c",
  "human_readable_source": "\n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kdev_t.h>\n#include <linux/kstrtox.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n\n#include \"gpiolib.h\"\n#include \"gpiolib-sysfs.h\"\n\nstruct kernfs_node;\n\n#define GPIO_IRQF_TRIGGER_NONE\t\t0\n#define GPIO_IRQF_TRIGGER_FALLING\tBIT(0)\n#define GPIO_IRQF_TRIGGER_RISING\tBIT(1)\n#define GPIO_IRQF_TRIGGER_BOTH\t\t(GPIO_IRQF_TRIGGER_FALLING | \\\n\t\t\t\t\t GPIO_IRQF_TRIGGER_RISING)\n\nstruct gpiod_data {\n\tstruct gpio_desc *desc;\n\n\tstruct mutex mutex;\n\tstruct kernfs_node *value_kn;\n\tint irq;\n\tunsigned char irq_flags;\n\n\tbool direction_can_change;\n};\n\n \nstatic DEFINE_MUTEX(sysfs_lock);\n\n \n\nstatic ssize_t direction_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gpiod_data *data = dev_get_drvdata(dev);\n\tstruct gpio_desc *desc = data->desc;\n\tint value;\n\n\tmutex_lock(&data->mutex);\n\n\tgpiod_get_direction(desc);\n\tvalue = !!test_bit(FLAG_IS_OUT, &desc->flags);\n\n\tmutex_unlock(&data->mutex);\n\n\treturn sysfs_emit(buf, \"%s\\n\", value ? \"out\" : \"in\");\n}\n\nstatic ssize_t direction_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct gpiod_data *data = dev_get_drvdata(dev);\n\tstruct gpio_desc *desc = data->desc;\n\tssize_t\t\t\tstatus;\n\n\tmutex_lock(&data->mutex);\n\n\tif (sysfs_streq(buf, \"high\"))\n\t\tstatus = gpiod_direction_output_raw(desc, 1);\n\telse if (sysfs_streq(buf, \"out\") || sysfs_streq(buf, \"low\"))\n\t\tstatus = gpiod_direction_output_raw(desc, 0);\n\telse if (sysfs_streq(buf, \"in\"))\n\t\tstatus = gpiod_direction_input(desc);\n\telse\n\t\tstatus = -EINVAL;\n\n\tmutex_unlock(&data->mutex);\n\n\treturn status ? : size;\n}\nstatic DEVICE_ATTR_RW(direction);\n\nstatic ssize_t value_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gpiod_data *data = dev_get_drvdata(dev);\n\tstruct gpio_desc *desc = data->desc;\n\tssize_t\t\t\tstatus;\n\n\tmutex_lock(&data->mutex);\n\n\tstatus = gpiod_get_value_cansleep(desc);\n\n\tmutex_unlock(&data->mutex);\n\n\tif (status < 0)\n\t\treturn status;\n\n\treturn sysfs_emit(buf, \"%zd\\n\", status);\n}\n\nstatic ssize_t value_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct gpiod_data *data = dev_get_drvdata(dev);\n\tstruct gpio_desc *desc = data->desc;\n\tssize_t status;\n\tlong value;\n\n\tstatus = kstrtol(buf, 0, &value);\n\n\tmutex_lock(&data->mutex);\n\n\tif (!test_bit(FLAG_IS_OUT, &desc->flags)) {\n\t\tstatus = -EPERM;\n\t} else if (status == 0) {\n\t\tgpiod_set_value_cansleep(desc, value);\n\t\tstatus = size;\n\t}\n\n\tmutex_unlock(&data->mutex);\n\n\treturn status;\n}\nstatic DEVICE_ATTR_PREALLOC(value, S_IWUSR | S_IRUGO, value_show, value_store);\n\nstatic irqreturn_t gpio_sysfs_irq(int irq, void *priv)\n{\n\tstruct gpiod_data *data = priv;\n\n\tsysfs_notify_dirent(data->value_kn);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int gpio_sysfs_request_irq(struct device *dev, unsigned char flags)\n{\n\tstruct gpiod_data\t*data = dev_get_drvdata(dev);\n\tstruct gpio_desc\t*desc = data->desc;\n\tunsigned long\t\tirq_flags;\n\tint\t\t\tret;\n\n\tdata->irq = gpiod_to_irq(desc);\n\tif (data->irq < 0)\n\t\treturn -EIO;\n\n\tdata->value_kn = sysfs_get_dirent(dev->kobj.sd, \"value\");\n\tif (!data->value_kn)\n\t\treturn -ENODEV;\n\n\tirq_flags = IRQF_SHARED;\n\tif (flags & GPIO_IRQF_TRIGGER_FALLING)\n\t\tirq_flags |= test_bit(FLAG_ACTIVE_LOW, &desc->flags) ?\n\t\t\tIRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;\n\tif (flags & GPIO_IRQF_TRIGGER_RISING)\n\t\tirq_flags |= test_bit(FLAG_ACTIVE_LOW, &desc->flags) ?\n\t\t\tIRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;\n\n\t \n\tret = gpiochip_lock_as_irq(desc->gdev->chip, gpio_chip_hwgpio(desc));\n\tif (ret < 0)\n\t\tgoto err_put_kn;\n\n\tret = request_any_context_irq(data->irq, gpio_sysfs_irq, irq_flags,\n\t\t\t\t\"gpiolib\", data);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\tdata->irq_flags = flags;\n\n\treturn 0;\n\nerr_unlock:\n\tgpiochip_unlock_as_irq(desc->gdev->chip, gpio_chip_hwgpio(desc));\nerr_put_kn:\n\tsysfs_put(data->value_kn);\n\n\treturn ret;\n}\n\n \nstatic void gpio_sysfs_free_irq(struct device *dev)\n{\n\tstruct gpiod_data *data = dev_get_drvdata(dev);\n\tstruct gpio_desc *desc = data->desc;\n\n\tdata->irq_flags = 0;\n\tfree_irq(data->irq, data);\n\tgpiochip_unlock_as_irq(desc->gdev->chip, gpio_chip_hwgpio(desc));\n\tsysfs_put(data->value_kn);\n}\n\nstatic const char * const trigger_names[] = {\n\t[GPIO_IRQF_TRIGGER_NONE]\t= \"none\",\n\t[GPIO_IRQF_TRIGGER_FALLING]\t= \"falling\",\n\t[GPIO_IRQF_TRIGGER_RISING]\t= \"rising\",\n\t[GPIO_IRQF_TRIGGER_BOTH]\t= \"both\",\n};\n\nstatic ssize_t edge_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gpiod_data *data = dev_get_drvdata(dev);\n\tint flags;\n\n\tmutex_lock(&data->mutex);\n\n\tflags = data->irq_flags;\n\n\tmutex_unlock(&data->mutex);\n\n\tif (flags >= ARRAY_SIZE(trigger_names))\n\t\treturn 0;\n\n\treturn sysfs_emit(buf, \"%s\\n\", trigger_names[flags]);\n}\n\nstatic ssize_t edge_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct gpiod_data *data = dev_get_drvdata(dev);\n\tssize_t\tstatus = size;\n\tint flags;\n\n\tflags = sysfs_match_string(trigger_names, buf);\n\tif (flags < 0)\n\t\treturn flags;\n\n\tmutex_lock(&data->mutex);\n\n\tif (flags == data->irq_flags) {\n\t\tstatus = size;\n\t\tgoto out_unlock;\n\t}\n\n\tif (data->irq_flags)\n\t\tgpio_sysfs_free_irq(dev);\n\n\tif (flags) {\n\t\tstatus = gpio_sysfs_request_irq(dev, flags);\n\t\tif (!status)\n\t\t\tstatus = size;\n\t}\n\nout_unlock:\n\tmutex_unlock(&data->mutex);\n\n\treturn status;\n}\nstatic DEVICE_ATTR_RW(edge);\n\n \nstatic int gpio_sysfs_set_active_low(struct device *dev, int value)\n{\n\tstruct gpiod_data\t*data = dev_get_drvdata(dev);\n\tstruct gpio_desc\t*desc = data->desc;\n\tint\t\t\tstatus = 0;\n\tunsigned int\t\tflags = data->irq_flags;\n\n\tif (!!test_bit(FLAG_ACTIVE_LOW, &desc->flags) == !!value)\n\t\treturn 0;\n\n\tassign_bit(FLAG_ACTIVE_LOW, &desc->flags, value);\n\n\t \n\tif (flags == GPIO_IRQF_TRIGGER_FALLING ||\n\t\t\t\t\tflags == GPIO_IRQF_TRIGGER_RISING) {\n\t\tgpio_sysfs_free_irq(dev);\n\t\tstatus = gpio_sysfs_request_irq(dev, flags);\n\t}\n\n\treturn status;\n}\n\nstatic ssize_t active_low_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gpiod_data *data = dev_get_drvdata(dev);\n\tstruct gpio_desc *desc = data->desc;\n\tint value;\n\n\tmutex_lock(&data->mutex);\n\n\tvalue = !!test_bit(FLAG_ACTIVE_LOW, &desc->flags);\n\n\tmutex_unlock(&data->mutex);\n\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t active_low_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct gpiod_data\t*data = dev_get_drvdata(dev);\n\tssize_t\t\t\tstatus;\n\tlong\t\t\tvalue;\n\n\tstatus = kstrtol(buf, 0, &value);\n\tif (status)\n\t\treturn status;\n\n\tmutex_lock(&data->mutex);\n\n\tstatus = gpio_sysfs_set_active_low(dev, value);\n\n\tmutex_unlock(&data->mutex);\n\n\treturn status ? : size;\n}\nstatic DEVICE_ATTR_RW(active_low);\n\nstatic umode_t gpio_is_visible(struct kobject *kobj, struct attribute *attr,\n\t\t\t       int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct gpiod_data *data = dev_get_drvdata(dev);\n\tstruct gpio_desc *desc = data->desc;\n\tumode_t mode = attr->mode;\n\tbool show_direction = data->direction_can_change;\n\n\tif (attr == &dev_attr_direction.attr) {\n\t\tif (!show_direction)\n\t\t\tmode = 0;\n\t} else if (attr == &dev_attr_edge.attr) {\n\t\tif (gpiod_to_irq(desc) < 0)\n\t\t\tmode = 0;\n\t\tif (!show_direction && test_bit(FLAG_IS_OUT, &desc->flags))\n\t\t\tmode = 0;\n\t}\n\n\treturn mode;\n}\n\nstatic struct attribute *gpio_attrs[] = {\n\t&dev_attr_direction.attr,\n\t&dev_attr_edge.attr,\n\t&dev_attr_value.attr,\n\t&dev_attr_active_low.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group gpio_group = {\n\t.attrs = gpio_attrs,\n\t.is_visible = gpio_is_visible,\n};\n\nstatic const struct attribute_group *gpio_groups[] = {\n\t&gpio_group,\n\tNULL\n};\n\n \n\nstatic ssize_t base_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tconst struct gpio_chip\t*chip = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", chip->base);\n}\nstatic DEVICE_ATTR_RO(base);\n\nstatic ssize_t label_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tconst struct gpio_chip\t*chip = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", chip->label ?: \"\");\n}\nstatic DEVICE_ATTR_RO(label);\n\nstatic ssize_t ngpio_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tconst struct gpio_chip\t*chip = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", chip->ngpio);\n}\nstatic DEVICE_ATTR_RO(ngpio);\n\nstatic struct attribute *gpiochip_attrs[] = {\n\t&dev_attr_base.attr,\n\t&dev_attr_label.attr,\n\t&dev_attr_ngpio.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(gpiochip);\n\n \nstatic ssize_t export_store(const struct class *class,\n\t\t\t\tconst struct class_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tlong\t\t\tgpio;\n\tstruct gpio_desc\t*desc;\n\tint\t\t\tstatus;\n\tstruct gpio_chip\t*gc;\n\tint\t\t\toffset;\n\n\tstatus = kstrtol(buf, 0, &gpio);\n\tif (status < 0)\n\t\tgoto done;\n\n\tdesc = gpio_to_desc(gpio);\n\t \n\tif (!desc) {\n\t\tpr_warn(\"%s: invalid GPIO %ld\\n\", __func__, gpio);\n\t\treturn -EINVAL;\n\t}\n\tgc = desc->gdev->chip;\n\toffset = gpio_chip_hwgpio(desc);\n\tif (!gpiochip_line_is_valid(gc, offset)) {\n\t\tpr_warn(\"%s: GPIO %ld masked\\n\", __func__, gpio);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tstatus = gpiod_request_user(desc, \"sysfs\");\n\tif (status)\n\t\tgoto done;\n\n\tstatus = gpiod_set_transitory(desc, false);\n\tif (status) {\n\t\tgpiod_free(desc);\n\t\tgoto done;\n\t}\n\n\tstatus = gpiod_export(desc, true);\n\tif (status < 0)\n\t\tgpiod_free(desc);\n\telse\n\t\tset_bit(FLAG_SYSFS, &desc->flags);\n\ndone:\n\tif (status)\n\t\tpr_debug(\"%s: status %d\\n\", __func__, status);\n\treturn status ? : len;\n}\nstatic CLASS_ATTR_WO(export);\n\nstatic ssize_t unexport_store(const struct class *class,\n\t\t\t\tconst struct class_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tlong\t\t\tgpio;\n\tstruct gpio_desc\t*desc;\n\tint\t\t\tstatus;\n\n\tstatus = kstrtol(buf, 0, &gpio);\n\tif (status < 0)\n\t\tgoto done;\n\n\tdesc = gpio_to_desc(gpio);\n\t \n\tif (!desc) {\n\t\tpr_warn(\"%s: invalid GPIO %ld\\n\", __func__, gpio);\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = -EINVAL;\n\n\t \n\tif (test_and_clear_bit(FLAG_SYSFS, &desc->flags)) {\n\t\tgpiod_unexport(desc);\n\t\tgpiod_free(desc);\n\t\tstatus = 0;\n\t}\ndone:\n\tif (status)\n\t\tpr_debug(\"%s: status %d\\n\", __func__, status);\n\treturn status ? : len;\n}\nstatic CLASS_ATTR_WO(unexport);\n\nstatic struct attribute *gpio_class_attrs[] = {\n\t&class_attr_export.attr,\n\t&class_attr_unexport.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(gpio_class);\n\nstatic struct class gpio_class = {\n\t.name =\t\t\"gpio\",\n\t.class_groups = gpio_class_groups,\n};\n\n\n \nint gpiod_export(struct gpio_desc *desc, bool direction_may_change)\n{\n\tstruct gpio_chip\t*chip;\n\tstruct gpio_device\t*gdev;\n\tstruct gpiod_data\t*data;\n\tunsigned long\t\tflags;\n\tint\t\t\tstatus;\n\tconst char\t\t*ioname = NULL;\n\tstruct device\t\t*dev;\n\tint\t\t\toffset;\n\n\t \n\tif (!class_is_registered(&gpio_class)) {\n\t\tpr_debug(\"%s: called too early!\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\tif (!desc) {\n\t\tpr_debug(\"%s: invalid gpio descriptor\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tgdev = desc->gdev;\n\tchip = gdev->chip;\n\n\tmutex_lock(&sysfs_lock);\n\n\t \n\tif (!chip || !gdev->mockdev) {\n\t\tstatus = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tspin_lock_irqsave(&gpio_lock, flags);\n\tif (!test_bit(FLAG_REQUESTED, &desc->flags) ||\n\t     test_bit(FLAG_EXPORT, &desc->flags)) {\n\t\tspin_unlock_irqrestore(&gpio_lock, flags);\n\t\tgpiod_dbg(desc, \"%s: unavailable (requested=%d, exported=%d)\\n\",\n\t\t\t\t__func__,\n\t\t\t\ttest_bit(FLAG_REQUESTED, &desc->flags),\n\t\t\t\ttest_bit(FLAG_EXPORT, &desc->flags));\n\t\tstatus = -EPERM;\n\t\tgoto err_unlock;\n\t}\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\tdata->desc = desc;\n\tmutex_init(&data->mutex);\n\tif (chip->direction_input && chip->direction_output)\n\t\tdata->direction_can_change = direction_may_change;\n\telse\n\t\tdata->direction_can_change = false;\n\n\toffset = gpio_chip_hwgpio(desc);\n\tif (chip->names && chip->names[offset])\n\t\tioname = chip->names[offset];\n\n\tdev = device_create_with_groups(&gpio_class, &gdev->dev,\n\t\t\t\t\tMKDEV(0, 0), data, gpio_groups,\n\t\t\t\t\tioname ? ioname : \"gpio%u\",\n\t\t\t\t\tdesc_to_gpio(desc));\n\tif (IS_ERR(dev)) {\n\t\tstatus = PTR_ERR(dev);\n\t\tgoto err_free_data;\n\t}\n\n\tset_bit(FLAG_EXPORT, &desc->flags);\n\tmutex_unlock(&sysfs_lock);\n\treturn 0;\n\nerr_free_data:\n\tkfree(data);\nerr_unlock:\n\tmutex_unlock(&sysfs_lock);\n\tgpiod_dbg(desc, \"%s: status %d\\n\", __func__, status);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(gpiod_export);\n\nstatic int match_export(struct device *dev, const void *desc)\n{\n\tstruct gpiod_data *data = dev_get_drvdata(dev);\n\n\treturn data->desc == desc;\n}\n\n \nint gpiod_export_link(struct device *dev, const char *name,\n\t\t      struct gpio_desc *desc)\n{\n\tstruct device *cdev;\n\tint ret;\n\n\tif (!desc) {\n\t\tpr_warn(\"%s: invalid GPIO\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tcdev = class_find_device(&gpio_class, NULL, desc, match_export);\n\tif (!cdev)\n\t\treturn -ENODEV;\n\n\tret = sysfs_create_link(&dev->kobj, &cdev->kobj, name);\n\tput_device(cdev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gpiod_export_link);\n\n \nvoid gpiod_unexport(struct gpio_desc *desc)\n{\n\tstruct gpiod_data *data;\n\tstruct device *dev;\n\n\tif (!desc) {\n\t\tpr_warn(\"%s: invalid GPIO\\n\", __func__);\n\t\treturn;\n\t}\n\n\tmutex_lock(&sysfs_lock);\n\n\tif (!test_bit(FLAG_EXPORT, &desc->flags))\n\t\tgoto err_unlock;\n\n\tdev = class_find_device(&gpio_class, NULL, desc, match_export);\n\tif (!dev)\n\t\tgoto err_unlock;\n\n\tdata = dev_get_drvdata(dev);\n\n\tclear_bit(FLAG_EXPORT, &desc->flags);\n\n\tdevice_unregister(dev);\n\n\t \n\tif (data->irq_flags)\n\t\tgpio_sysfs_free_irq(dev);\n\n\tmutex_unlock(&sysfs_lock);\n\n\tput_device(dev);\n\tkfree(data);\n\n\treturn;\n\nerr_unlock:\n\tmutex_unlock(&sysfs_lock);\n}\nEXPORT_SYMBOL_GPL(gpiod_unexport);\n\nint gpiochip_sysfs_register(struct gpio_device *gdev)\n{\n\tstruct device\t*dev;\n\tstruct device\t*parent;\n\tstruct gpio_chip *chip = gdev->chip;\n\n\t \n\tif (!class_is_registered(&gpio_class))\n\t\treturn 0;\n\n\t \n\tif (chip->parent)\n\t\tparent = chip->parent;\n\telse\n\t\tparent = &gdev->dev;\n\n\t \n\tdev = device_create_with_groups(&gpio_class, parent, MKDEV(0, 0), chip,\n\t\t\t\t\tgpiochip_groups, GPIOCHIP_NAME \"%d\",\n\t\t\t\t\tchip->base);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tmutex_lock(&sysfs_lock);\n\tgdev->mockdev = dev;\n\tmutex_unlock(&sysfs_lock);\n\n\treturn 0;\n}\n\nvoid gpiochip_sysfs_unregister(struct gpio_device *gdev)\n{\n\tstruct gpio_desc *desc;\n\tstruct gpio_chip *chip = gdev->chip;\n\n\tif (!gdev->mockdev)\n\t\treturn;\n\n\tdevice_unregister(gdev->mockdev);\n\n\t \n\tmutex_lock(&sysfs_lock);\n\tgdev->mockdev = NULL;\n\tmutex_unlock(&sysfs_lock);\n\n\t \n\tfor_each_gpio_desc_with_flag(chip, desc, FLAG_SYSFS) {\n\t\tgpiod_unexport(desc);\n\t\tgpiod_free(desc);\n\t}\n}\n\nstatic int __init gpiolib_sysfs_init(void)\n{\n\tint\t\tstatus;\n\tunsigned long\tflags;\n\tstruct gpio_device *gdev;\n\n\tstatus = class_register(&gpio_class);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tspin_lock_irqsave(&gpio_lock, flags);\n\tlist_for_each_entry(gdev, &gpio_devices, list) {\n\t\tif (gdev->mockdev)\n\t\t\tcontinue;\n\n\t\t \n\t\tspin_unlock_irqrestore(&gpio_lock, flags);\n\t\tstatus = gpiochip_sysfs_register(gdev);\n\t\tspin_lock_irqsave(&gpio_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&gpio_lock, flags);\n\n\treturn status;\n}\npostcore_initcall(gpiolib_sysfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}