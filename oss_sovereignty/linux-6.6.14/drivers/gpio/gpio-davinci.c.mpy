{
  "module_name": "gpio-davinci.c",
  "hash_id": "87806d33d50ae6f6adadf3038a0d686ca7c54eae915d4fb85cb30fa3b1556415",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-davinci.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/gpio-davinci.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/spinlock.h>\n#include <linux/pm_runtime.h>\n\n#define MAX_REGS_BANKS 5\n#define MAX_INT_PER_BANK 32\n\nstruct davinci_gpio_regs {\n\tu32\tdir;\n\tu32\tout_data;\n\tu32\tset_data;\n\tu32\tclr_data;\n\tu32\tin_data;\n\tu32\tset_rising;\n\tu32\tclr_rising;\n\tu32\tset_falling;\n\tu32\tclr_falling;\n\tu32\tintstat;\n};\n\ntypedef struct irq_chip *(*gpio_get_irq_chip_cb_t)(unsigned int irq);\n\n#define BINTEN\t0x8  \n\nstatic void __iomem *gpio_base;\nstatic unsigned int offset_array[5] = {0x10, 0x38, 0x60, 0x88, 0xb0};\n\nstruct davinci_gpio_irq_data {\n\tvoid __iomem\t\t\t*regs;\n\tstruct davinci_gpio_controller\t*chip;\n\tint\t\t\t\tbank_num;\n};\n\nstruct davinci_gpio_controller {\n\tstruct gpio_chip\tchip;\n\tstruct irq_domain\t*irq_domain;\n\t \n\tspinlock_t\t\tlock;\n\tvoid __iomem\t\t*regs[MAX_REGS_BANKS];\n\tint\t\t\tgpio_unbanked;\n\tint\t\t\tirqs[MAX_INT_PER_BANK];\n\tstruct davinci_gpio_regs context[MAX_REGS_BANKS];\n\tu32\t\t\tbinten_context;\n};\n\nstatic inline u32 __gpio_mask(unsigned gpio)\n{\n\treturn 1 << (gpio % 32);\n}\n\nstatic inline struct davinci_gpio_regs __iomem *irq2regs(struct irq_data *d)\n{\n\tstruct davinci_gpio_regs __iomem *g;\n\n\tg = (__force struct davinci_gpio_regs __iomem *)irq_data_get_irq_chip_data(d);\n\n\treturn g;\n}\n\nstatic int davinci_gpio_irq_setup(struct platform_device *pdev);\n\n \n\n \nstatic inline int __davinci_direction(struct gpio_chip *chip,\n\t\t\tunsigned offset, bool out, int value)\n{\n\tstruct davinci_gpio_controller *d = gpiochip_get_data(chip);\n\tstruct davinci_gpio_regs __iomem *g;\n\tunsigned long flags;\n\tu32 temp;\n\tint bank = offset / 32;\n\tu32 mask = __gpio_mask(offset);\n\n\tg = d->regs[bank];\n\tspin_lock_irqsave(&d->lock, flags);\n\ttemp = readl_relaxed(&g->dir);\n\tif (out) {\n\t\ttemp &= ~mask;\n\t\twritel_relaxed(mask, value ? &g->set_data : &g->clr_data);\n\t} else {\n\t\ttemp |= mask;\n\t}\n\twritel_relaxed(temp, &g->dir);\n\tspin_unlock_irqrestore(&d->lock, flags);\n\n\treturn 0;\n}\n\nstatic int davinci_direction_in(struct gpio_chip *chip, unsigned offset)\n{\n\treturn __davinci_direction(chip, offset, false, 0);\n}\n\nstatic int\ndavinci_direction_out(struct gpio_chip *chip, unsigned offset, int value)\n{\n\treturn __davinci_direction(chip, offset, true, value);\n}\n\n \nstatic int davinci_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct davinci_gpio_controller *d = gpiochip_get_data(chip);\n\tstruct davinci_gpio_regs __iomem *g;\n\tint bank = offset / 32;\n\n\tg = d->regs[bank];\n\n\treturn !!(__gpio_mask(offset) & readl_relaxed(&g->in_data));\n}\n\n \nstatic void\ndavinci_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct davinci_gpio_controller *d = gpiochip_get_data(chip);\n\tstruct davinci_gpio_regs __iomem *g;\n\tint bank = offset / 32;\n\n\tg = d->regs[bank];\n\n\twritel_relaxed(__gpio_mask(offset),\n\t\t       value ? &g->set_data : &g->clr_data);\n}\n\nstatic struct davinci_gpio_platform_data *\ndavinci_gpio_get_pdata(struct platform_device *pdev)\n{\n\tstruct device_node *dn = pdev->dev.of_node;\n\tstruct davinci_gpio_platform_data *pdata;\n\tint ret;\n\tu32 val;\n\n\tif (!IS_ENABLED(CONFIG_OF) || !pdev->dev.of_node)\n\t\treturn dev_get_platdata(&pdev->dev);\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tret = of_property_read_u32(dn, \"ti,ngpio\", &val);\n\tif (ret)\n\t\tgoto of_err;\n\n\tpdata->ngpio = val;\n\n\tret = of_property_read_u32(dn, \"ti,davinci-gpio-unbanked\", &val);\n\tif (ret)\n\t\tgoto of_err;\n\n\tpdata->gpio_unbanked = val;\n\n\treturn pdata;\n\nof_err:\n\tdev_err(&pdev->dev, \"Populating pdata from DT failed: err %d\\n\", ret);\n\treturn NULL;\n}\n\nstatic int davinci_gpio_probe(struct platform_device *pdev)\n{\n\tint bank, i, ret = 0;\n\tunsigned int ngpio, nbank, nirq;\n\tstruct davinci_gpio_controller *chips;\n\tstruct davinci_gpio_platform_data *pdata;\n\tstruct device *dev = &pdev->dev;\n\n\tpdata = davinci_gpio_get_pdata(pdev);\n\tif (!pdata) {\n\t\tdev_err(dev, \"No platform data found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev->platform_data = pdata;\n\n\t \n\tngpio = pdata->ngpio;\n\tif (ngpio == 0) {\n\t\tdev_err(dev, \"How many GPIOs?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (pdata->gpio_unbanked)\n\t\tnirq = pdata->gpio_unbanked;\n\telse\n\t\tnirq = DIV_ROUND_UP(ngpio, 16);\n\n\tchips = devm_kzalloc(dev, sizeof(*chips), GFP_KERNEL);\n\tif (!chips)\n\t\treturn -ENOMEM;\n\n\tgpio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gpio_base))\n\t\treturn PTR_ERR(gpio_base);\n\n\tfor (i = 0; i < nirq; i++) {\n\t\tchips->irqs[i] = platform_get_irq(pdev, i);\n\t\tif (chips->irqs[i] < 0)\n\t\t\treturn chips->irqs[i];\n\t}\n\n\tchips->chip.label = dev_name(dev);\n\n\tchips->chip.direction_input = davinci_direction_in;\n\tchips->chip.get = davinci_gpio_get;\n\tchips->chip.direction_output = davinci_direction_out;\n\tchips->chip.set = davinci_gpio_set;\n\n\tchips->chip.ngpio = ngpio;\n\tchips->chip.base = pdata->no_auto_base ? pdata->base : -1;\n\n#ifdef CONFIG_OF_GPIO\n\tchips->chip.parent = dev;\n\tchips->chip.request = gpiochip_generic_request;\n\tchips->chip.free = gpiochip_generic_free;\n#endif\n\tspin_lock_init(&chips->lock);\n\n\tnbank = DIV_ROUND_UP(ngpio, 32);\n\tfor (bank = 0; bank < nbank; bank++)\n\t\tchips->regs[bank] = gpio_base + offset_array[bank];\n\n\tret = devm_gpiochip_add_data(dev, &chips->chip, chips);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, chips);\n\tret = davinci_gpio_irq_setup(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \n \n\nstatic void gpio_irq_disable(struct irq_data *d)\n{\n\tstruct davinci_gpio_regs __iomem *g = irq2regs(d);\n\tuintptr_t mask = (uintptr_t)irq_data_get_irq_handler_data(d);\n\n\twritel_relaxed(mask, &g->clr_falling);\n\twritel_relaxed(mask, &g->clr_rising);\n}\n\nstatic void gpio_irq_enable(struct irq_data *d)\n{\n\tstruct davinci_gpio_regs __iomem *g = irq2regs(d);\n\tuintptr_t mask = (uintptr_t)irq_data_get_irq_handler_data(d);\n\tunsigned status = irqd_get_trigger_type(d);\n\n\tstatus &= IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING;\n\tif (!status)\n\t\tstatus = IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING;\n\n\tif (status & IRQ_TYPE_EDGE_FALLING)\n\t\twritel_relaxed(mask, &g->set_falling);\n\tif (status & IRQ_TYPE_EDGE_RISING)\n\t\twritel_relaxed(mask, &g->set_rising);\n}\n\nstatic int gpio_irq_type(struct irq_data *d, unsigned trigger)\n{\n\tif (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct irq_chip gpio_irqchip = {\n\t.name\t\t= \"GPIO\",\n\t.irq_enable\t= gpio_irq_enable,\n\t.irq_disable\t= gpio_irq_disable,\n\t.irq_set_type\t= gpio_irq_type,\n\t.flags\t\t= IRQCHIP_SET_TYPE_MASKED | IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic void gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct davinci_gpio_regs __iomem *g;\n\tu32 mask = 0xffff;\n\tint bank_num;\n\tstruct davinci_gpio_controller *d;\n\tstruct davinci_gpio_irq_data *irqdata;\n\n\tirqdata = (struct davinci_gpio_irq_data *)irq_desc_get_handler_data(desc);\n\tbank_num = irqdata->bank_num;\n\tg = irqdata->regs;\n\td = irqdata->chip;\n\n\t \n\tif ((bank_num % 2) == 1)\n\t\tmask <<= 16;\n\n\t \n\tchained_irq_enter(irq_desc_get_chip(desc), desc);\n\twhile (1) {\n\t\tu32\t\tstatus;\n\t\tint\t\tbit;\n\t\tirq_hw_number_t hw_irq;\n\n\t\t \n\t\tstatus = readl_relaxed(&g->intstat) & mask;\n\t\tif (!status)\n\t\t\tbreak;\n\t\twritel_relaxed(status, &g->intstat);\n\n\t\t \n\n\t\twhile (status) {\n\t\t\tbit = __ffs(status);\n\t\t\tstatus &= ~BIT(bit);\n\t\t\t \n\t\t\thw_irq = (bank_num / 2) * 32 + bit;\n\n\t\t\tgeneric_handle_domain_irq(d->irq_domain, hw_irq);\n\t\t}\n\t}\n\tchained_irq_exit(irq_desc_get_chip(desc), desc);\n\t \n}\n\nstatic int gpio_to_irq_banked(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct davinci_gpio_controller *d = gpiochip_get_data(chip);\n\n\tif (d->irq_domain)\n\t\treturn irq_create_mapping(d->irq_domain, offset);\n\telse\n\t\treturn -ENXIO;\n}\n\nstatic int gpio_to_irq_unbanked(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct davinci_gpio_controller *d = gpiochip_get_data(chip);\n\n\t \n\tif (offset < d->gpio_unbanked)\n\t\treturn d->irqs[offset];\n\telse\n\t\treturn -ENODEV;\n}\n\nstatic int gpio_irq_type_unbanked(struct irq_data *data, unsigned trigger)\n{\n\tstruct davinci_gpio_controller *d;\n\tstruct davinci_gpio_regs __iomem *g;\n\tu32 mask, i;\n\n\td = (struct davinci_gpio_controller *)irq_data_get_irq_handler_data(data);\n\tg = (struct davinci_gpio_regs __iomem *)d->regs[0];\n\tfor (i = 0; i < MAX_INT_PER_BANK; i++)\n\t\tif (data->irq == d->irqs[i])\n\t\t\tbreak;\n\n\tif (i == MAX_INT_PER_BANK)\n\t\treturn -EINVAL;\n\n\tmask = __gpio_mask(i);\n\n\tif (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\n\t\treturn -EINVAL;\n\n\twritel_relaxed(mask, (trigger & IRQ_TYPE_EDGE_FALLING)\n\t\t     ? &g->set_falling : &g->clr_falling);\n\twritel_relaxed(mask, (trigger & IRQ_TYPE_EDGE_RISING)\n\t\t     ? &g->set_rising : &g->clr_rising);\n\n\treturn 0;\n}\n\nstatic int\ndavinci_gpio_irq_map(struct irq_domain *d, unsigned int irq,\n\t\t     irq_hw_number_t hw)\n{\n\tstruct davinci_gpio_controller *chips =\n\t\t\t\t(struct davinci_gpio_controller *)d->host_data;\n\tstruct davinci_gpio_regs __iomem *g = chips->regs[hw / 32];\n\n\tirq_set_chip_and_handler_name(irq, &gpio_irqchip, handle_simple_irq,\n\t\t\t\t\"davinci_gpio\");\n\tirq_set_irq_type(irq, IRQ_TYPE_NONE);\n\tirq_set_chip_data(irq, (__force void *)g);\n\tirq_set_handler_data(irq, (void *)(uintptr_t)__gpio_mask(hw));\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops davinci_gpio_irq_ops = {\n\t.map = davinci_gpio_irq_map,\n\t.xlate = irq_domain_xlate_onetwocell,\n};\n\nstatic struct irq_chip *davinci_gpio_get_irq_chip(unsigned int irq)\n{\n\tstatic struct irq_chip_type gpio_unbanked;\n\n\tgpio_unbanked = *irq_data_get_chip_type(irq_get_irq_data(irq));\n\n\treturn &gpio_unbanked.chip;\n};\n\nstatic struct irq_chip *keystone_gpio_get_irq_chip(unsigned int irq)\n{\n\tstatic struct irq_chip gpio_unbanked;\n\n\tgpio_unbanked = *irq_get_chip(irq);\n\treturn &gpio_unbanked;\n};\n\nstatic const struct of_device_id davinci_gpio_ids[];\n\n \n\nstatic int davinci_gpio_irq_setup(struct platform_device *pdev)\n{\n\tunsigned\tgpio, bank;\n\tint\t\tirq;\n\tint\t\tret;\n\tstruct clk\t*clk;\n\tu32\t\tbinten = 0;\n\tunsigned\tngpio;\n\tstruct device *dev = &pdev->dev;\n\tstruct davinci_gpio_controller *chips = platform_get_drvdata(pdev);\n\tstruct davinci_gpio_platform_data *pdata = dev->platform_data;\n\tstruct davinci_gpio_regs __iomem *g;\n\tstruct irq_domain\t*irq_domain = NULL;\n\tconst struct of_device_id *match;\n\tstruct irq_chip *irq_chip;\n\tstruct davinci_gpio_irq_data *irqdata;\n\tgpio_get_irq_chip_cb_t gpio_get_irq_chip;\n\n\t \n\tgpio_get_irq_chip = davinci_gpio_get_irq_chip;\n\tmatch = of_match_device(of_match_ptr(davinci_gpio_ids),\n\t\t\t\tdev);\n\tif (match)\n\t\tgpio_get_irq_chip = (gpio_get_irq_chip_cb_t)match->data;\n\n\tngpio = pdata->ngpio;\n\n\tclk = devm_clk_get(dev, \"gpio\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"Error %ld getting gpio clock\\n\", PTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!pdata->gpio_unbanked) {\n\t\tirq = devm_irq_alloc_descs(dev, -1, 0, ngpio, 0);\n\t\tif (irq < 0) {\n\t\t\tdev_err(dev, \"Couldn't allocate IRQ numbers\\n\");\n\t\t\tclk_disable_unprepare(clk);\n\t\t\treturn irq;\n\t\t}\n\n\t\tirq_domain = irq_domain_add_legacy(dev->of_node, ngpio, irq, 0,\n\t\t\t\t\t\t\t&davinci_gpio_irq_ops,\n\t\t\t\t\t\t\tchips);\n\t\tif (!irq_domain) {\n\t\t\tdev_err(dev, \"Couldn't register an IRQ domain\\n\");\n\t\t\tclk_disable_unprepare(clk);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tchips->chip.to_irq = gpio_to_irq_banked;\n\tchips->irq_domain = irq_domain;\n\n\t \n\tif (pdata->gpio_unbanked) {\n\t\t \n\t\tchips->chip.to_irq = gpio_to_irq_unbanked;\n\t\tchips->gpio_unbanked = pdata->gpio_unbanked;\n\t\tbinten = GENMASK(pdata->gpio_unbanked / 16, 0);\n\n\t\t \n\t\tirq = chips->irqs[0];\n\t\tirq_chip = gpio_get_irq_chip(irq);\n\t\tirq_chip->name = \"GPIO-AINTC\";\n\t\tirq_chip->irq_set_type = gpio_irq_type_unbanked;\n\n\t\t \n\t\tg = chips->regs[0];\n\t\twritel_relaxed(~0, &g->set_falling);\n\t\twritel_relaxed(~0, &g->set_rising);\n\n\t\t \n\t\tfor (gpio = 0; gpio < pdata->gpio_unbanked; gpio++) {\n\t\t\tirq_set_chip(chips->irqs[gpio], irq_chip);\n\t\t\tirq_set_handler_data(chips->irqs[gpio], chips);\n\t\t\tirq_set_status_flags(chips->irqs[gpio],\n\t\t\t\t\t     IRQ_TYPE_EDGE_BOTH);\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\t \n\tfor (gpio = 0, bank = 0; gpio < ngpio; bank++, gpio += 16) {\n\t\t \n\t\tg = chips->regs[bank / 2];\n\t\twritel_relaxed(~0, &g->clr_falling);\n\t\twritel_relaxed(~0, &g->clr_rising);\n\n\t\t \n\t\tirqdata = devm_kzalloc(&pdev->dev,\n\t\t\t\t       sizeof(struct\n\t\t\t\t\t      davinci_gpio_irq_data),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!irqdata) {\n\t\t\tclk_disable_unprepare(clk);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tirqdata->regs = g;\n\t\tirqdata->bank_num = bank;\n\t\tirqdata->chip = chips;\n\n\t\tirq_set_chained_handler_and_data(chips->irqs[bank],\n\t\t\t\t\t\t gpio_irq_handler, irqdata);\n\n\t\tbinten |= BIT(bank);\n\t}\n\ndone:\n\t \n\twritel_relaxed(binten, gpio_base + BINTEN);\n\n\treturn 0;\n}\n\nstatic void davinci_gpio_save_context(struct davinci_gpio_controller *chips,\n\t\t\t\t      u32 nbank)\n{\n\tstruct davinci_gpio_regs __iomem *g;\n\tstruct davinci_gpio_regs *context;\n\tu32 bank;\n\tvoid __iomem *base;\n\n\tbase = chips->regs[0] - offset_array[0];\n\tchips->binten_context = readl_relaxed(base + BINTEN);\n\n\tfor (bank = 0; bank < nbank; bank++) {\n\t\tg = chips->regs[bank];\n\t\tcontext = &chips->context[bank];\n\t\tcontext->dir = readl_relaxed(&g->dir);\n\t\tcontext->set_data = readl_relaxed(&g->set_data);\n\t\tcontext->set_rising = readl_relaxed(&g->set_rising);\n\t\tcontext->set_falling = readl_relaxed(&g->set_falling);\n\t}\n\n\t \n\twritel_relaxed(GENMASK(31, 0), &g->intstat);\n}\n\nstatic void davinci_gpio_restore_context(struct davinci_gpio_controller *chips,\n\t\t\t\t\t u32 nbank)\n{\n\tstruct davinci_gpio_regs __iomem *g;\n\tstruct davinci_gpio_regs *context;\n\tu32 bank;\n\tvoid __iomem *base;\n\n\tbase = chips->regs[0] - offset_array[0];\n\n\tif (readl_relaxed(base + BINTEN) != chips->binten_context)\n\t\twritel_relaxed(chips->binten_context, base + BINTEN);\n\n\tfor (bank = 0; bank < nbank; bank++) {\n\t\tg = chips->regs[bank];\n\t\tcontext = &chips->context[bank];\n\t\tif (readl_relaxed(&g->dir) != context->dir)\n\t\t\twritel_relaxed(context->dir, &g->dir);\n\t\tif (readl_relaxed(&g->set_data) != context->set_data)\n\t\t\twritel_relaxed(context->set_data, &g->set_data);\n\t\tif (readl_relaxed(&g->set_rising) != context->set_rising)\n\t\t\twritel_relaxed(context->set_rising, &g->set_rising);\n\t\tif (readl_relaxed(&g->set_falling) != context->set_falling)\n\t\t\twritel_relaxed(context->set_falling, &g->set_falling);\n\t}\n}\n\nstatic int davinci_gpio_suspend(struct device *dev)\n{\n\tstruct davinci_gpio_controller *chips = dev_get_drvdata(dev);\n\tstruct davinci_gpio_platform_data *pdata = dev_get_platdata(dev);\n\tu32 nbank = DIV_ROUND_UP(pdata->ngpio, 32);\n\n\tdavinci_gpio_save_context(chips, nbank);\n\n\treturn 0;\n}\n\nstatic int davinci_gpio_resume(struct device *dev)\n{\n\tstruct davinci_gpio_controller *chips = dev_get_drvdata(dev);\n\tstruct davinci_gpio_platform_data *pdata = dev_get_platdata(dev);\n\tu32 nbank = DIV_ROUND_UP(pdata->ngpio, 32);\n\n\tdavinci_gpio_restore_context(chips, nbank);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(davinci_gpio_dev_pm_ops, davinci_gpio_suspend,\n\t\t\t davinci_gpio_resume);\n\nstatic const struct of_device_id davinci_gpio_ids[] = {\n\t{ .compatible = \"ti,keystone-gpio\", keystone_gpio_get_irq_chip},\n\t{ .compatible = \"ti,am654-gpio\", keystone_gpio_get_irq_chip},\n\t{ .compatible = \"ti,dm6441-gpio\", davinci_gpio_get_irq_chip},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, davinci_gpio_ids);\n\nstatic struct platform_driver davinci_gpio_driver = {\n\t.probe\t\t= davinci_gpio_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"davinci_gpio\",\n\t\t.pm = pm_sleep_ptr(&davinci_gpio_dev_pm_ops),\n\t\t.of_match_table\t= of_match_ptr(davinci_gpio_ids),\n\t},\n};\n\n \nstatic int __init davinci_gpio_drv_reg(void)\n{\n\treturn platform_driver_register(&davinci_gpio_driver);\n}\npostcore_initcall(davinci_gpio_drv_reg);\n\nstatic void __exit davinci_gpio_exit(void)\n{\n\tplatform_driver_unregister(&davinci_gpio_driver);\n}\nmodule_exit(davinci_gpio_exit);\n\nMODULE_AUTHOR(\"Jan Kotas <jank@cadence.com>\");\nMODULE_DESCRIPTION(\"DAVINCI GPIO driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:gpio-davinci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}