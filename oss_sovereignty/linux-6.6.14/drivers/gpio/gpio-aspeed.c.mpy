{
  "module_name": "gpio-aspeed.c",
  "hash_id": "efe9859f872f4422981f133bad5719ee235802d04b6fbd35ed4540f8e4bb503c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-aspeed.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/gpio/aspeed.h>\n#include <linux/gpio/driver.h>\n#include <linux/hashtable.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n\n#include <asm/div64.h>\n\n \n#include <linux/gpio/consumer.h>\n#include \"gpiolib.h\"\n\nstruct aspeed_bank_props {\n\tunsigned int bank;\n\tu32 input;\n\tu32 output;\n};\n\nstruct aspeed_gpio_config {\n\tunsigned int nr_gpios;\n\tconst struct aspeed_bank_props *props;\n};\n\n \nstruct aspeed_gpio {\n\tstruct gpio_chip chip;\n\tstruct device *dev;\n\traw_spinlock_t lock;\n\tvoid __iomem *base;\n\tint irq;\n\tconst struct aspeed_gpio_config *config;\n\n\tu8 *offset_timer;\n\tunsigned int timer_users[4];\n\tstruct clk *clk;\n\n\tu32 *dcache;\n\tu8 *cf_copro_bankmap;\n};\n\nstruct aspeed_gpio_bank {\n\tuint16_t\tval_regs;\t \n\tuint16_t\trdata_reg;\t \n\tuint16_t\tirq_regs;\n\tuint16_t\tdebounce_regs;\n\tuint16_t\ttolerance_regs;\n\tuint16_t\tcmdsrc_regs;\n\tconst char\tnames[4][3];\n};\n\n \n\nstatic const int debounce_timers[4] = { 0x00, 0x50, 0x54, 0x58 };\n\nstatic const struct aspeed_gpio_copro_ops *copro_ops;\nstatic void *copro_data;\n\nstatic const struct aspeed_gpio_bank aspeed_gpio_banks[] = {\n\t{\n\t\t.val_regs = 0x0000,\n\t\t.rdata_reg = 0x00c0,\n\t\t.irq_regs = 0x0008,\n\t\t.debounce_regs = 0x0040,\n\t\t.tolerance_regs = 0x001c,\n\t\t.cmdsrc_regs = 0x0060,\n\t\t.names = { \"A\", \"B\", \"C\", \"D\" },\n\t},\n\t{\n\t\t.val_regs = 0x0020,\n\t\t.rdata_reg = 0x00c4,\n\t\t.irq_regs = 0x0028,\n\t\t.debounce_regs = 0x0048,\n\t\t.tolerance_regs = 0x003c,\n\t\t.cmdsrc_regs = 0x0068,\n\t\t.names = { \"E\", \"F\", \"G\", \"H\" },\n\t},\n\t{\n\t\t.val_regs = 0x0070,\n\t\t.rdata_reg = 0x00c8,\n\t\t.irq_regs = 0x0098,\n\t\t.debounce_regs = 0x00b0,\n\t\t.tolerance_regs = 0x00ac,\n\t\t.cmdsrc_regs = 0x0090,\n\t\t.names = { \"I\", \"J\", \"K\", \"L\" },\n\t},\n\t{\n\t\t.val_regs = 0x0078,\n\t\t.rdata_reg = 0x00cc,\n\t\t.irq_regs = 0x00e8,\n\t\t.debounce_regs = 0x0100,\n\t\t.tolerance_regs = 0x00fc,\n\t\t.cmdsrc_regs = 0x00e0,\n\t\t.names = { \"M\", \"N\", \"O\", \"P\" },\n\t},\n\t{\n\t\t.val_regs = 0x0080,\n\t\t.rdata_reg = 0x00d0,\n\t\t.irq_regs = 0x0118,\n\t\t.debounce_regs = 0x0130,\n\t\t.tolerance_regs = 0x012c,\n\t\t.cmdsrc_regs = 0x0110,\n\t\t.names = { \"Q\", \"R\", \"S\", \"T\" },\n\t},\n\t{\n\t\t.val_regs = 0x0088,\n\t\t.rdata_reg = 0x00d4,\n\t\t.irq_regs = 0x0148,\n\t\t.debounce_regs = 0x0160,\n\t\t.tolerance_regs = 0x015c,\n\t\t.cmdsrc_regs = 0x0140,\n\t\t.names = { \"U\", \"V\", \"W\", \"X\" },\n\t},\n\t{\n\t\t.val_regs = 0x01E0,\n\t\t.rdata_reg = 0x00d8,\n\t\t.irq_regs = 0x0178,\n\t\t.debounce_regs = 0x0190,\n\t\t.tolerance_regs = 0x018c,\n\t\t.cmdsrc_regs = 0x0170,\n\t\t.names = { \"Y\", \"Z\", \"AA\", \"AB\" },\n\t},\n\t{\n\t\t.val_regs = 0x01e8,\n\t\t.rdata_reg = 0x00dc,\n\t\t.irq_regs = 0x01a8,\n\t\t.debounce_regs = 0x01c0,\n\t\t.tolerance_regs = 0x01bc,\n\t\t.cmdsrc_regs = 0x01a0,\n\t\t.names = { \"AC\", \"\", \"\", \"\" },\n\t},\n};\n\nenum aspeed_gpio_reg {\n\treg_val,\n\treg_rdata,\n\treg_dir,\n\treg_irq_enable,\n\treg_irq_type0,\n\treg_irq_type1,\n\treg_irq_type2,\n\treg_irq_status,\n\treg_debounce_sel1,\n\treg_debounce_sel2,\n\treg_tolerance,\n\treg_cmdsrc0,\n\treg_cmdsrc1,\n};\n\n#define GPIO_VAL_VALUE\t0x00\n#define GPIO_VAL_DIR\t0x04\n\n#define GPIO_IRQ_ENABLE\t0x00\n#define GPIO_IRQ_TYPE0\t0x04\n#define GPIO_IRQ_TYPE1\t0x08\n#define GPIO_IRQ_TYPE2\t0x0c\n#define GPIO_IRQ_STATUS\t0x10\n\n#define GPIO_DEBOUNCE_SEL1 0x00\n#define GPIO_DEBOUNCE_SEL2 0x04\n\n#define GPIO_CMDSRC_0\t0x00\n#define GPIO_CMDSRC_1\t0x04\n#define  GPIO_CMDSRC_ARM\t\t0\n#define  GPIO_CMDSRC_LPC\t\t1\n#define  GPIO_CMDSRC_COLDFIRE\t\t2\n#define  GPIO_CMDSRC_RESERVED\t\t3\n\n \nstatic inline void __iomem *bank_reg(struct aspeed_gpio *gpio,\n\t\t\t\t     const struct aspeed_gpio_bank *bank,\n\t\t\t\t     const enum aspeed_gpio_reg reg)\n{\n\tswitch (reg) {\n\tcase reg_val:\n\t\treturn gpio->base + bank->val_regs + GPIO_VAL_VALUE;\n\tcase reg_rdata:\n\t\treturn gpio->base + bank->rdata_reg;\n\tcase reg_dir:\n\t\treturn gpio->base + bank->val_regs + GPIO_VAL_DIR;\n\tcase reg_irq_enable:\n\t\treturn gpio->base + bank->irq_regs + GPIO_IRQ_ENABLE;\n\tcase reg_irq_type0:\n\t\treturn gpio->base + bank->irq_regs + GPIO_IRQ_TYPE0;\n\tcase reg_irq_type1:\n\t\treturn gpio->base + bank->irq_regs + GPIO_IRQ_TYPE1;\n\tcase reg_irq_type2:\n\t\treturn gpio->base + bank->irq_regs + GPIO_IRQ_TYPE2;\n\tcase reg_irq_status:\n\t\treturn gpio->base + bank->irq_regs + GPIO_IRQ_STATUS;\n\tcase reg_debounce_sel1:\n\t\treturn gpio->base + bank->debounce_regs + GPIO_DEBOUNCE_SEL1;\n\tcase reg_debounce_sel2:\n\t\treturn gpio->base + bank->debounce_regs + GPIO_DEBOUNCE_SEL2;\n\tcase reg_tolerance:\n\t\treturn gpio->base + bank->tolerance_regs;\n\tcase reg_cmdsrc0:\n\t\treturn gpio->base + bank->cmdsrc_regs + GPIO_CMDSRC_0;\n\tcase reg_cmdsrc1:\n\t\treturn gpio->base + bank->cmdsrc_regs + GPIO_CMDSRC_1;\n\t}\n\tBUG();\n}\n\n#define GPIO_BANK(x)\t((x) >> 5)\n#define GPIO_OFFSET(x)\t((x) & 0x1f)\n#define GPIO_BIT(x)\tBIT(GPIO_OFFSET(x))\n\n#define _GPIO_SET_DEBOUNCE(t, o, i) ((!!((t) & BIT(i))) << GPIO_OFFSET(o))\n#define GPIO_SET_DEBOUNCE1(t, o) _GPIO_SET_DEBOUNCE(t, o, 1)\n#define GPIO_SET_DEBOUNCE2(t, o) _GPIO_SET_DEBOUNCE(t, o, 0)\n\nstatic const struct aspeed_gpio_bank *to_bank(unsigned int offset)\n{\n\tunsigned int bank = GPIO_BANK(offset);\n\n\tWARN_ON(bank >= ARRAY_SIZE(aspeed_gpio_banks));\n\treturn &aspeed_gpio_banks[bank];\n}\n\nstatic inline bool is_bank_props_sentinel(const struct aspeed_bank_props *props)\n{\n\treturn !(props->input || props->output);\n}\n\nstatic inline const struct aspeed_bank_props *find_bank_props(\n\t\tstruct aspeed_gpio *gpio, unsigned int offset)\n{\n\tconst struct aspeed_bank_props *props = gpio->config->props;\n\n\twhile (!is_bank_props_sentinel(props)) {\n\t\tif (props->bank == GPIO_BANK(offset))\n\t\t\treturn props;\n\t\tprops++;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline bool have_gpio(struct aspeed_gpio *gpio, unsigned int offset)\n{\n\tconst struct aspeed_bank_props *props = find_bank_props(gpio, offset);\n\tconst struct aspeed_gpio_bank *bank = to_bank(offset);\n\tunsigned int group = GPIO_OFFSET(offset) / 8;\n\n\treturn bank->names[group][0] != '\\0' &&\n\t\t(!props || ((props->input | props->output) & GPIO_BIT(offset)));\n}\n\nstatic inline bool have_input(struct aspeed_gpio *gpio, unsigned int offset)\n{\n\tconst struct aspeed_bank_props *props = find_bank_props(gpio, offset);\n\n\treturn !props || (props->input & GPIO_BIT(offset));\n}\n\n#define have_irq(g, o) have_input((g), (o))\n#define have_debounce(g, o) have_input((g), (o))\n\nstatic inline bool have_output(struct aspeed_gpio *gpio, unsigned int offset)\n{\n\tconst struct aspeed_bank_props *props = find_bank_props(gpio, offset);\n\n\treturn !props || (props->output & GPIO_BIT(offset));\n}\n\nstatic void aspeed_gpio_change_cmd_source(struct aspeed_gpio *gpio,\n\t\t\t\t\t  const struct aspeed_gpio_bank *bank,\n\t\t\t\t\t  int bindex, int cmdsrc)\n{\n\tvoid __iomem *c0 = bank_reg(gpio, bank, reg_cmdsrc0);\n\tvoid __iomem *c1 = bank_reg(gpio, bank, reg_cmdsrc1);\n\tu32 bit, reg;\n\n\t \n\tbit = BIT((bindex & 3) << 3);\n\n\t \n\treg = ioread32(c1);\n\tif (cmdsrc & 2)\n\t\treg |= bit;\n\telse\n\t\treg &= ~bit;\n\tiowrite32(reg, c1);\n\n\t \n\treg = ioread32(c0);\n\tif (cmdsrc & 1)\n\t\treg |= bit;\n\telse\n\t\treg &= ~bit;\n\tiowrite32(reg, c0);\n}\n\nstatic bool aspeed_gpio_copro_request(struct aspeed_gpio *gpio,\n\t\t\t\t      unsigned int offset)\n{\n\tconst struct aspeed_gpio_bank *bank = to_bank(offset);\n\n\tif (!copro_ops || !gpio->cf_copro_bankmap)\n\t\treturn false;\n\tif (!gpio->cf_copro_bankmap[offset >> 3])\n\t\treturn false;\n\tif (!copro_ops->request_access)\n\t\treturn false;\n\n\t \n\tcopro_ops->request_access(copro_data);\n\n\t \n\taspeed_gpio_change_cmd_source(gpio, bank, offset >> 3, GPIO_CMDSRC_ARM);\n\n\t \n\tgpio->dcache[GPIO_BANK(offset)] = ioread32(bank_reg(gpio, bank, reg_rdata));\n\n\treturn true;\n}\n\nstatic void aspeed_gpio_copro_release(struct aspeed_gpio *gpio,\n\t\t\t\t      unsigned int offset)\n{\n\tconst struct aspeed_gpio_bank *bank = to_bank(offset);\n\n\tif (!copro_ops || !gpio->cf_copro_bankmap)\n\t\treturn;\n\tif (!gpio->cf_copro_bankmap[offset >> 3])\n\t\treturn;\n\tif (!copro_ops->release_access)\n\t\treturn;\n\n\t \n\taspeed_gpio_change_cmd_source(gpio, bank, offset >> 3,\n\t\t\t\t      GPIO_CMDSRC_COLDFIRE);\n\n\t \n\tcopro_ops->release_access(copro_data);\n}\n\nstatic int aspeed_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(gc);\n\tconst struct aspeed_gpio_bank *bank = to_bank(offset);\n\n\treturn !!(ioread32(bank_reg(gpio, bank, reg_val)) & GPIO_BIT(offset));\n}\n\nstatic void __aspeed_gpio_set(struct gpio_chip *gc, unsigned int offset,\n\t\t\t      int val)\n{\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(gc);\n\tconst struct aspeed_gpio_bank *bank = to_bank(offset);\n\tvoid __iomem *addr;\n\tu32 reg;\n\n\taddr = bank_reg(gpio, bank, reg_val);\n\treg = gpio->dcache[GPIO_BANK(offset)];\n\n\tif (val)\n\t\treg |= GPIO_BIT(offset);\n\telse\n\t\treg &= ~GPIO_BIT(offset);\n\tgpio->dcache[GPIO_BANK(offset)] = reg;\n\n\tiowrite32(reg, addr);\n}\n\nstatic void aspeed_gpio_set(struct gpio_chip *gc, unsigned int offset,\n\t\t\t    int val)\n{\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tbool copro;\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\tcopro = aspeed_gpio_copro_request(gpio, offset);\n\n\t__aspeed_gpio_set(gc, offset, val);\n\n\tif (copro)\n\t\taspeed_gpio_copro_release(gpio, offset);\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n}\n\nstatic int aspeed_gpio_dir_in(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(gc);\n\tconst struct aspeed_gpio_bank *bank = to_bank(offset);\n\tvoid __iomem *addr = bank_reg(gpio, bank, reg_dir);\n\tunsigned long flags;\n\tbool copro;\n\tu32 reg;\n\n\tif (!have_input(gpio, offset))\n\t\treturn -ENOTSUPP;\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\treg = ioread32(addr);\n\treg &= ~GPIO_BIT(offset);\n\n\tcopro = aspeed_gpio_copro_request(gpio, offset);\n\tiowrite32(reg, addr);\n\tif (copro)\n\t\taspeed_gpio_copro_release(gpio, offset);\n\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\treturn 0;\n}\n\nstatic int aspeed_gpio_dir_out(struct gpio_chip *gc,\n\t\t\t       unsigned int offset, int val)\n{\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(gc);\n\tconst struct aspeed_gpio_bank *bank = to_bank(offset);\n\tvoid __iomem *addr = bank_reg(gpio, bank, reg_dir);\n\tunsigned long flags;\n\tbool copro;\n\tu32 reg;\n\n\tif (!have_output(gpio, offset))\n\t\treturn -ENOTSUPP;\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\treg = ioread32(addr);\n\treg |= GPIO_BIT(offset);\n\n\tcopro = aspeed_gpio_copro_request(gpio, offset);\n\t__aspeed_gpio_set(gc, offset, val);\n\tiowrite32(reg, addr);\n\n\tif (copro)\n\t\taspeed_gpio_copro_release(gpio, offset);\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\treturn 0;\n}\n\nstatic int aspeed_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(gc);\n\tconst struct aspeed_gpio_bank *bank = to_bank(offset);\n\tunsigned long flags;\n\tu32 val;\n\n\tif (!have_input(gpio, offset))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\tif (!have_output(gpio, offset))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\tval = ioread32(bank_reg(gpio, bank, reg_dir)) & GPIO_BIT(offset);\n\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\treturn val ? GPIO_LINE_DIRECTION_OUT : GPIO_LINE_DIRECTION_IN;\n}\n\nstatic inline int irqd_to_aspeed_gpio_data(struct irq_data *d,\n\t\t\t\t\t   struct aspeed_gpio **gpio,\n\t\t\t\t\t   const struct aspeed_gpio_bank **bank,\n\t\t\t\t\t   u32 *bit, int *offset)\n{\n\tstruct aspeed_gpio *internal;\n\n\t*offset = irqd_to_hwirq(d);\n\n\tinternal = irq_data_get_irq_chip_data(d);\n\n\t \n\tif (!have_irq(internal, *offset))\n\t\treturn -ENOTSUPP;\n\n\t*gpio = internal;\n\t*bank = to_bank(*offset);\n\t*bit = GPIO_BIT(*offset);\n\n\treturn 0;\n}\n\nstatic void aspeed_gpio_irq_ack(struct irq_data *d)\n{\n\tconst struct aspeed_gpio_bank *bank;\n\tstruct aspeed_gpio *gpio;\n\tunsigned long flags;\n\tvoid __iomem *status_addr;\n\tint rc, offset;\n\tbool copro;\n\tu32 bit;\n\n\trc = irqd_to_aspeed_gpio_data(d, &gpio, &bank, &bit, &offset);\n\tif (rc)\n\t\treturn;\n\n\tstatus_addr = bank_reg(gpio, bank, reg_irq_status);\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\tcopro = aspeed_gpio_copro_request(gpio, offset);\n\n\tiowrite32(bit, status_addr);\n\n\tif (copro)\n\t\taspeed_gpio_copro_release(gpio, offset);\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n}\n\nstatic void aspeed_gpio_irq_set_mask(struct irq_data *d, bool set)\n{\n\tconst struct aspeed_gpio_bank *bank;\n\tstruct aspeed_gpio *gpio;\n\tunsigned long flags;\n\tu32 reg, bit;\n\tvoid __iomem *addr;\n\tint rc, offset;\n\tbool copro;\n\n\trc = irqd_to_aspeed_gpio_data(d, &gpio, &bank, &bit, &offset);\n\tif (rc)\n\t\treturn;\n\n\taddr = bank_reg(gpio, bank, reg_irq_enable);\n\n\t \n\tif (set)\n\t\tgpiochip_enable_irq(&gpio->chip, irqd_to_hwirq(d));\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\tcopro = aspeed_gpio_copro_request(gpio, offset);\n\n\treg = ioread32(addr);\n\tif (set)\n\t\treg |= bit;\n\telse\n\t\treg &= ~bit;\n\tiowrite32(reg, addr);\n\n\tif (copro)\n\t\taspeed_gpio_copro_release(gpio, offset);\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\t \n\tif (!set)\n\t\tgpiochip_disable_irq(&gpio->chip, irqd_to_hwirq(d));\n}\n\nstatic void aspeed_gpio_irq_mask(struct irq_data *d)\n{\n\taspeed_gpio_irq_set_mask(d, false);\n}\n\nstatic void aspeed_gpio_irq_unmask(struct irq_data *d)\n{\n\taspeed_gpio_irq_set_mask(d, true);\n}\n\nstatic int aspeed_gpio_set_type(struct irq_data *d, unsigned int type)\n{\n\tu32 type0 = 0;\n\tu32 type1 = 0;\n\tu32 type2 = 0;\n\tu32 bit, reg;\n\tconst struct aspeed_gpio_bank *bank;\n\tirq_flow_handler_t handler;\n\tstruct aspeed_gpio *gpio;\n\tunsigned long flags;\n\tvoid __iomem *addr;\n\tint rc, offset;\n\tbool copro;\n\n\trc = irqd_to_aspeed_gpio_data(d, &gpio, &bank, &bit, &offset);\n\tif (rc)\n\t\treturn -EINVAL;\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\ttype2 |= bit;\n\t\tfallthrough;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\ttype0 |= bit;\n\t\tfallthrough;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\thandler = handle_edge_irq;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\ttype0 |= bit;\n\t\tfallthrough;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\ttype1 |= bit;\n\t\thandler = handle_level_irq;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\tcopro = aspeed_gpio_copro_request(gpio, offset);\n\n\taddr = bank_reg(gpio, bank, reg_irq_type0);\n\treg = ioread32(addr);\n\treg = (reg & ~bit) | type0;\n\tiowrite32(reg, addr);\n\n\taddr = bank_reg(gpio, bank, reg_irq_type1);\n\treg = ioread32(addr);\n\treg = (reg & ~bit) | type1;\n\tiowrite32(reg, addr);\n\n\taddr = bank_reg(gpio, bank, reg_irq_type2);\n\treg = ioread32(addr);\n\treg = (reg & ~bit) | type2;\n\tiowrite32(reg, addr);\n\n\tif (copro)\n\t\taspeed_gpio_copro_release(gpio, offset);\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\tirq_set_handler_locked(d, handler);\n\n\treturn 0;\n}\n\nstatic void aspeed_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *ic = irq_desc_get_chip(desc);\n\tstruct aspeed_gpio *data = gpiochip_get_data(gc);\n\tunsigned int i, p, banks;\n\tunsigned long reg;\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(gc);\n\n\tchained_irq_enter(ic, desc);\n\n\tbanks = DIV_ROUND_UP(gpio->chip.ngpio, 32);\n\tfor (i = 0; i < banks; i++) {\n\t\tconst struct aspeed_gpio_bank *bank = &aspeed_gpio_banks[i];\n\n\t\treg = ioread32(bank_reg(data, bank, reg_irq_status));\n\n\t\tfor_each_set_bit(p, &reg, 32)\n\t\t\tgeneric_handle_domain_irq(gc->irq.domain, i * 32 + p);\n\t}\n\n\tchained_irq_exit(ic, desc);\n}\n\nstatic void aspeed_init_irq_valid_mask(struct gpio_chip *gc,\n\t\t\t\t       unsigned long *valid_mask,\n\t\t\t\t       unsigned int ngpios)\n{\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(gc);\n\tconst struct aspeed_bank_props *props = gpio->config->props;\n\n\twhile (!is_bank_props_sentinel(props)) {\n\t\tunsigned int offset;\n\t\tconst unsigned long int input = props->input;\n\n\t\t \n\t\tfor_each_clear_bit(offset, &input, 32) {\n\t\t\tunsigned int i = props->bank * 32 + offset;\n\n\t\t\tif (i >= gpio->chip.ngpio)\n\t\t\t\tbreak;\n\n\t\t\tclear_bit(i, valid_mask);\n\t\t}\n\n\t\tprops++;\n\t}\n}\n\nstatic int aspeed_gpio_reset_tolerance(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int offset, bool enable)\n{\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tvoid __iomem *treg;\n\tbool copro;\n\tu32 val;\n\n\ttreg = bank_reg(gpio, to_bank(offset), reg_tolerance);\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\tcopro = aspeed_gpio_copro_request(gpio, offset);\n\n\tval = readl(treg);\n\n\tif (enable)\n\t\tval |= GPIO_BIT(offset);\n\telse\n\t\tval &= ~GPIO_BIT(offset);\n\n\twritel(val, treg);\n\n\tif (copro)\n\t\taspeed_gpio_copro_release(gpio, offset);\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\treturn 0;\n}\n\nstatic int aspeed_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tif (!have_gpio(gpiochip_get_data(chip), offset))\n\t\treturn -ENODEV;\n\n\treturn pinctrl_gpio_request(chip->base + offset);\n}\n\nstatic void aspeed_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tpinctrl_gpio_free(chip->base + offset);\n}\n\nstatic int usecs_to_cycles(struct aspeed_gpio *gpio, unsigned long usecs,\n\t\tu32 *cycles)\n{\n\tu64 rate;\n\tu64 n;\n\tu32 r;\n\n\trate = clk_get_rate(gpio->clk);\n\tif (!rate)\n\t\treturn -ENOTSUPP;\n\n\tn = rate * usecs;\n\tr = do_div(n, 1000000);\n\n\tif (n >= U32_MAX)\n\t\treturn -ERANGE;\n\n\t \n\t*cycles = n + (!!r);\n\n\treturn 0;\n}\n\n \nstatic int register_allocated_timer(struct aspeed_gpio *gpio,\n\t\tunsigned int offset, unsigned int timer)\n{\n\tif (WARN(gpio->offset_timer[offset] != 0,\n\t\t\t\t\"Offset %d already allocated timer %d\\n\",\n\t\t\t\toffset, gpio->offset_timer[offset]))\n\t\treturn -EINVAL;\n\n\tif (WARN(gpio->timer_users[timer] == UINT_MAX,\n\t\t\t\t\"Timer user count would overflow\\n\"))\n\t\treturn -EPERM;\n\n\tgpio->offset_timer[offset] = timer;\n\tgpio->timer_users[timer]++;\n\n\treturn 0;\n}\n\n \nstatic int unregister_allocated_timer(struct aspeed_gpio *gpio,\n\t\tunsigned int offset)\n{\n\tif (WARN(gpio->offset_timer[offset] == 0,\n\t\t\t\t\"No timer allocated to offset %d\\n\", offset))\n\t\treturn -EINVAL;\n\n\tif (WARN(gpio->timer_users[gpio->offset_timer[offset]] == 0,\n\t\t\t\t\"No users recorded for timer %d\\n\",\n\t\t\t\tgpio->offset_timer[offset]))\n\t\treturn -EINVAL;\n\n\tgpio->timer_users[gpio->offset_timer[offset]]--;\n\tgpio->offset_timer[offset] = 0;\n\n\treturn 0;\n}\n\n \nstatic inline bool timer_allocation_registered(struct aspeed_gpio *gpio,\n\t\tunsigned int offset)\n{\n\treturn gpio->offset_timer[offset] > 0;\n}\n\n \nstatic void configure_timer(struct aspeed_gpio *gpio, unsigned int offset,\n\t\tunsigned int timer)\n{\n\tconst struct aspeed_gpio_bank *bank = to_bank(offset);\n\tconst u32 mask = GPIO_BIT(offset);\n\tvoid __iomem *addr;\n\tu32 val;\n\n\t \n\taddr = bank_reg(gpio, bank, reg_debounce_sel1);\n\tval = ioread32(addr);\n\tiowrite32((val & ~mask) | GPIO_SET_DEBOUNCE1(timer, offset), addr);\n\n\taddr = bank_reg(gpio, bank, reg_debounce_sel2);\n\tval = ioread32(addr);\n\tiowrite32((val & ~mask) | GPIO_SET_DEBOUNCE2(timer, offset), addr);\n}\n\nstatic int enable_debounce(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t    unsigned long usecs)\n{\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(chip);\n\tu32 requested_cycles;\n\tunsigned long flags;\n\tint rc;\n\tint i;\n\n\tif (!gpio->clk)\n\t\treturn -EINVAL;\n\n\trc = usecs_to_cycles(gpio, usecs, &requested_cycles);\n\tif (rc < 0) {\n\t\tdev_warn(chip->parent, \"Failed to convert %luus to cycles at %luHz: %d\\n\",\n\t\t\t\tusecs, clk_get_rate(gpio->clk), rc);\n\t\treturn rc;\n\t}\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\tif (timer_allocation_registered(gpio, offset)) {\n\t\trc = unregister_allocated_timer(gpio, offset);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 1; i < ARRAY_SIZE(debounce_timers); i++) {\n\t\tu32 cycles;\n\n\t\tcycles = ioread32(gpio->base + debounce_timers[i]);\n\t\tif (requested_cycles == cycles)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(debounce_timers)) {\n\t\tint j;\n\n\t\t \n\t\tfor (j = 1; j < ARRAY_SIZE(gpio->timer_users); j++) {\n\t\t\tif (gpio->timer_users[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j == ARRAY_SIZE(gpio->timer_users)) {\n\t\t\tdev_warn(chip->parent,\n\t\t\t\t\t\"Debounce timers exhausted, cannot debounce for period %luus\\n\",\n\t\t\t\t\tusecs);\n\n\t\t\trc = -EPERM;\n\n\t\t\t \n\t\t\tconfigure_timer(gpio, offset, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\ti = j;\n\n\t\tiowrite32(requested_cycles, gpio->base + debounce_timers[i]);\n\t}\n\n\tif (WARN(i == 0, \"Cannot register index of disabled timer\\n\")) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tregister_allocated_timer(gpio, offset, i);\n\tconfigure_timer(gpio, offset, i);\n\nout:\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\treturn rc;\n}\n\nstatic int disable_debounce(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tint rc;\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\trc = unregister_allocated_timer(gpio, offset);\n\tif (!rc)\n\t\tconfigure_timer(gpio, offset, 0);\n\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\treturn rc;\n}\n\nstatic int set_debounce(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t    unsigned long usecs)\n{\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(chip);\n\n\tif (!have_debounce(gpio, offset))\n\t\treturn -ENOTSUPP;\n\n\tif (usecs)\n\t\treturn enable_debounce(chip, offset, usecs);\n\n\treturn disable_debounce(chip, offset);\n}\n\nstatic int aspeed_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t  unsigned long config)\n{\n\tunsigned long param = pinconf_to_config_param(config);\n\tu32 arg = pinconf_to_config_argument(config);\n\n\tif (param == PIN_CONFIG_INPUT_DEBOUNCE)\n\t\treturn set_debounce(chip, offset, arg);\n\telse if (param == PIN_CONFIG_BIAS_DISABLE ||\n\t\t\tparam == PIN_CONFIG_BIAS_PULL_DOWN ||\n\t\t\tparam == PIN_CONFIG_DRIVE_STRENGTH)\n\t\treturn pinctrl_gpio_set_config(chip->base + offset, config);\n\telse if (param == PIN_CONFIG_DRIVE_OPEN_DRAIN ||\n\t\t\tparam == PIN_CONFIG_DRIVE_OPEN_SOURCE)\n\t\t \n\t\treturn -ENOTSUPP;\n\telse if (param == PIN_CONFIG_PERSIST_STATE)\n\t\treturn aspeed_gpio_reset_tolerance(chip, offset, arg);\n\n\treturn -ENOTSUPP;\n}\n\n \nint aspeed_gpio_copro_set_ops(const struct aspeed_gpio_copro_ops *ops, void *data)\n{\n\tcopro_data = data;\n\tcopro_ops = ops;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(aspeed_gpio_copro_set_ops);\n\n \nint aspeed_gpio_copro_grab_gpio(struct gpio_desc *desc,\n\t\t\t\tu16 *vreg_offset, u16 *dreg_offset, u8 *bit)\n{\n\tstruct gpio_chip *chip = gpiod_to_chip(desc);\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(chip);\n\tint rc = 0, bindex, offset = gpio_chip_hwgpio(desc);\n\tconst struct aspeed_gpio_bank *bank = to_bank(offset);\n\tunsigned long flags;\n\n\tif (!gpio->cf_copro_bankmap)\n\t\tgpio->cf_copro_bankmap = kzalloc(gpio->chip.ngpio >> 3, GFP_KERNEL);\n\tif (!gpio->cf_copro_bankmap)\n\t\treturn -ENOMEM;\n\tif (offset < 0 || offset > gpio->chip.ngpio)\n\t\treturn -EINVAL;\n\tbindex = offset >> 3;\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\t \n\tif (gpio->cf_copro_bankmap[bindex] == 0xff) {\n\t\trc = -EIO;\n\t\tgoto bail;\n\t}\n\tgpio->cf_copro_bankmap[bindex]++;\n\n\t \n\tif (gpio->cf_copro_bankmap[bindex] == 1)\n\t\taspeed_gpio_change_cmd_source(gpio, bank, bindex,\n\t\t\t\t\t      GPIO_CMDSRC_COLDFIRE);\n\n\tif (vreg_offset)\n\t\t*vreg_offset = bank->val_regs;\n\tif (dreg_offset)\n\t\t*dreg_offset = bank->rdata_reg;\n\tif (bit)\n\t\t*bit = GPIO_OFFSET(offset);\n bail:\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(aspeed_gpio_copro_grab_gpio);\n\n \nint aspeed_gpio_copro_release_gpio(struct gpio_desc *desc)\n{\n\tstruct gpio_chip *chip = gpiod_to_chip(desc);\n\tstruct aspeed_gpio *gpio = gpiochip_get_data(chip);\n\tint rc = 0, bindex, offset = gpio_chip_hwgpio(desc);\n\tconst struct aspeed_gpio_bank *bank = to_bank(offset);\n\tunsigned long flags;\n\n\tif (!gpio->cf_copro_bankmap)\n\t\treturn -ENXIO;\n\n\tif (offset < 0 || offset > gpio->chip.ngpio)\n\t\treturn -EINVAL;\n\tbindex = offset >> 3;\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\t \n\tif (gpio->cf_copro_bankmap[bindex] == 0) {\n\t\trc = -EIO;\n\t\tgoto bail;\n\t}\n\tgpio->cf_copro_bankmap[bindex]--;\n\n\t \n\tif (gpio->cf_copro_bankmap[bindex] == 0)\n\t\taspeed_gpio_change_cmd_source(gpio, bank, bindex,\n\t\t\t\t\t      GPIO_CMDSRC_ARM);\n bail:\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(aspeed_gpio_copro_release_gpio);\n\nstatic void aspeed_gpio_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tconst struct aspeed_gpio_bank *bank;\n\tstruct aspeed_gpio *gpio;\n\tu32 bit;\n\tint rc, offset;\n\n\trc = irqd_to_aspeed_gpio_data(d, &gpio, &bank, &bit, &offset);\n\tif (rc)\n\t\treturn;\n\n\tseq_printf(p, dev_name(gpio->dev));\n}\n\nstatic const struct irq_chip aspeed_gpio_irq_chip = {\n\t.irq_ack = aspeed_gpio_irq_ack,\n\t.irq_mask = aspeed_gpio_irq_mask,\n\t.irq_unmask = aspeed_gpio_irq_unmask,\n\t.irq_set_type = aspeed_gpio_set_type,\n\t.irq_print_chip = aspeed_gpio_irq_print_chip,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\n \n\nstatic const struct aspeed_bank_props ast2400_bank_props[] = {\n\t \n\t{ 5, 0xffffffff, 0x0000ffff },  \n\t{ 6, 0x0000000f, 0x0fffff0f },  \n\t{ },\n};\n\nstatic const struct aspeed_gpio_config ast2400_config =\n\t \n\t{ .nr_gpios = 220, .props = ast2400_bank_props, };\n\nstatic const struct aspeed_bank_props ast2500_bank_props[] = {\n\t \n\t{ 5, 0xffffffff, 0x0000ffff },  \n\t{ 6, 0x0fffffff, 0x0fffffff },  \n\t{ 7, 0x000000ff, 0x000000ff },  \n\t{ },\n};\n\nstatic const struct aspeed_gpio_config ast2500_config =\n\t \n\t{ .nr_gpios = 232, .props = ast2500_bank_props, };\n\nstatic const struct aspeed_bank_props ast2600_bank_props[] = {\n\t \n\t{4, 0xffffffff,  0x00ffffff},  \n\t{5, 0xffffffff,  0xffffff00},  \n\t{6, 0x0000ffff,  0x0000ffff},  \n\t{ },\n};\n\nstatic const struct aspeed_gpio_config ast2600_config =\n\t \n\t{ .nr_gpios = 208, .props = ast2600_bank_props, };\n\nstatic const struct of_device_id aspeed_gpio_of_table[] = {\n\t{ .compatible = \"aspeed,ast2400-gpio\", .data = &ast2400_config, },\n\t{ .compatible = \"aspeed,ast2500-gpio\", .data = &ast2500_config, },\n\t{ .compatible = \"aspeed,ast2600-gpio\", .data = &ast2600_config, },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, aspeed_gpio_of_table);\n\nstatic int __init aspeed_gpio_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *gpio_id;\n\tstruct gpio_irq_chip *girq;\n\tstruct aspeed_gpio *gpio;\n\tint rc, irq, i, banks, err;\n\tu32 ngpio;\n\n\tgpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tgpio->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gpio->base))\n\t\treturn PTR_ERR(gpio->base);\n\n\tgpio->dev = &pdev->dev;\n\n\traw_spin_lock_init(&gpio->lock);\n\n\tgpio_id = of_match_node(aspeed_gpio_of_table, pdev->dev.of_node);\n\tif (!gpio_id)\n\t\treturn -EINVAL;\n\n\tgpio->clk = of_clk_get(pdev->dev.of_node, 0);\n\tif (IS_ERR(gpio->clk)) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t\t\"Failed to get clock from devicetree, debouncing disabled\\n\");\n\t\tgpio->clk = NULL;\n\t}\n\n\tgpio->config = gpio_id->data;\n\n\tgpio->chip.parent = &pdev->dev;\n\terr = of_property_read_u32(pdev->dev.of_node, \"ngpios\", &ngpio);\n\tgpio->chip.ngpio = (u16) ngpio;\n\tif (err)\n\t\tgpio->chip.ngpio = gpio->config->nr_gpios;\n\tgpio->chip.direction_input = aspeed_gpio_dir_in;\n\tgpio->chip.direction_output = aspeed_gpio_dir_out;\n\tgpio->chip.get_direction = aspeed_gpio_get_direction;\n\tgpio->chip.request = aspeed_gpio_request;\n\tgpio->chip.free = aspeed_gpio_free;\n\tgpio->chip.get = aspeed_gpio_get;\n\tgpio->chip.set = aspeed_gpio_set;\n\tgpio->chip.set_config = aspeed_gpio_set_config;\n\tgpio->chip.label = dev_name(&pdev->dev);\n\tgpio->chip.base = -1;\n\n\t \n\tbanks = DIV_ROUND_UP(gpio->chip.ngpio, 32);\n\tgpio->dcache = devm_kcalloc(&pdev->dev,\n\t\t\t\t    banks, sizeof(u32), GFP_KERNEL);\n\tif (!gpio->dcache)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < banks; i++) {\n\t\tconst struct aspeed_gpio_bank *bank = &aspeed_gpio_banks[i];\n\t\tvoid __iomem *addr = bank_reg(gpio, bank, reg_rdata);\n\t\tgpio->dcache[i] = ioread32(addr);\n\t\taspeed_gpio_change_cmd_source(gpio, bank, 0, GPIO_CMDSRC_ARM);\n\t\taspeed_gpio_change_cmd_source(gpio, bank, 1, GPIO_CMDSRC_ARM);\n\t\taspeed_gpio_change_cmd_source(gpio, bank, 2, GPIO_CMDSRC_ARM);\n\t\taspeed_gpio_change_cmd_source(gpio, bank, 3, GPIO_CMDSRC_ARM);\n\t}\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tgpio->irq = irq;\n\tgirq = &gpio->chip.irq;\n\tgpio_irq_chip_set_chip(girq, &aspeed_gpio_irq_chip);\n\n\tgirq->parent_handler = aspeed_gpio_irq_handler;\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(&pdev->dev, 1, sizeof(*girq->parents), GFP_KERNEL);\n\tif (!girq->parents)\n\t\treturn -ENOMEM;\n\tgirq->parents[0] = gpio->irq;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\tgirq->init_valid_mask = aspeed_init_irq_valid_mask;\n\n\tgpio->offset_timer =\n\t\tdevm_kzalloc(&pdev->dev, gpio->chip.ngpio, GFP_KERNEL);\n\tif (!gpio->offset_timer)\n\t\treturn -ENOMEM;\n\n\trc = devm_gpiochip_add_data(&pdev->dev, &gpio->chip, gpio);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic struct platform_driver aspeed_gpio_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = aspeed_gpio_of_table,\n\t},\n};\n\nmodule_platform_driver_probe(aspeed_gpio_driver, aspeed_gpio_probe);\n\nMODULE_DESCRIPTION(\"Aspeed GPIO Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}