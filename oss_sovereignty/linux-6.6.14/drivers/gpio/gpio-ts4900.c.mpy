{
  "module_name": "gpio-ts4900.c",
  "hash_id": "1f01eef6daa27e22befccd5a19f64973fa8e809ad29cb84d5a802e0867ec59ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-ts4900.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#define DEFAULT_PIN_NUMBER\t32\n \n#define TS4900_GPIO_OE\t\t0x01\n#define TS4900_GPIO_OUT\t\t0x02\n#define TS4900_GPIO_IN\t\t0x04\n#define TS7970_GPIO_IN\t\t0x02\n\nstruct ts4900_gpio_priv {\n\tstruct regmap *regmap;\n\tstruct gpio_chip gpio_chip;\n\tunsigned int input_bit;\n};\n\nstatic int ts4900_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset)\n{\n\tstruct ts4900_gpio_priv *priv = gpiochip_get_data(chip);\n\tunsigned int reg;\n\n\tregmap_read(priv->regmap, offset, &reg);\n\n\tif (reg & TS4900_GPIO_OE)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int ts4900_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset)\n{\n\tstruct ts4900_gpio_priv *priv = gpiochip_get_data(chip);\n\n\t \n\treturn regmap_update_bits(priv->regmap, offset, TS4900_GPIO_OE, 0);\n}\n\nstatic int ts4900_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int offset, int value)\n{\n\tstruct ts4900_gpio_priv *priv = gpiochip_get_data(chip);\n\tunsigned int reg;\n\tint ret;\n\n\t \n\tregmap_read(priv->regmap, offset, &reg);\n\tif (!(reg & TS4900_GPIO_OE)) {\n\t\tif (value)\n\t\t\treg = TS4900_GPIO_OUT;\n\t\telse\n\t\t\treg &= ~TS4900_GPIO_OUT;\n\n\t\tregmap_write(priv->regmap, offset, reg);\n\t}\n\n\tif (value)\n\t\tret = regmap_write(priv->regmap, offset, TS4900_GPIO_OE |\n\t\t\t\t\t\t\t TS4900_GPIO_OUT);\n\telse\n\t\tret = regmap_write(priv->regmap, offset, TS4900_GPIO_OE);\n\n\treturn ret;\n}\n\nstatic int ts4900_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct ts4900_gpio_priv *priv = gpiochip_get_data(chip);\n\tunsigned int reg;\n\n\tregmap_read(priv->regmap, offset, &reg);\n\n\treturn !!(reg & priv->input_bit);\n}\n\nstatic void ts4900_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t    int value)\n{\n\tstruct ts4900_gpio_priv *priv = gpiochip_get_data(chip);\n\n\tif (value)\n\t\tregmap_update_bits(priv->regmap, offset, TS4900_GPIO_OUT,\n\t\t\t\t   TS4900_GPIO_OUT);\n\telse\n\t\tregmap_update_bits(priv->regmap, offset, TS4900_GPIO_OUT, 0);\n}\n\nstatic const struct regmap_config ts4900_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n};\n\nstatic const struct gpio_chip template_chip = {\n\t.label\t\t\t= \"ts4900-gpio\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.get_direction\t\t= ts4900_gpio_get_direction,\n\t.direction_input\t= ts4900_gpio_direction_input,\n\t.direction_output\t= ts4900_gpio_direction_output,\n\t.get\t\t\t= ts4900_gpio_get,\n\t.set\t\t\t= ts4900_gpio_set,\n\t.base\t\t\t= -1,\n\t.can_sleep\t\t= true,\n};\n\nstatic const struct of_device_id ts4900_gpio_of_match_table[] = {\n\t{\n\t\t.compatible = \"technologic,ts4900-gpio\",\n\t\t.data = (void *)TS4900_GPIO_IN,\n\t}, {\n\t\t.compatible = \"technologic,ts7970-gpio\",\n\t\t.data = (void *)TS7970_GPIO_IN,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ts4900_gpio_of_match_table);\n\nstatic int ts4900_gpio_probe(struct i2c_client *client)\n{\n\tstruct ts4900_gpio_priv *priv;\n\tu32 ngpio;\n\tint ret;\n\n\tif (of_property_read_u32(client->dev.of_node, \"ngpios\", &ngpio))\n\t\tngpio = DEFAULT_PIN_NUMBER;\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->gpio_chip = template_chip;\n\tpriv->gpio_chip.label = \"ts4900-gpio\";\n\tpriv->gpio_chip.ngpio = ngpio;\n\tpriv->gpio_chip.parent = &client->dev;\n\tpriv->input_bit = (uintptr_t)of_device_get_match_data(&client->dev);\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &ts4900_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tret = PTR_ERR(priv->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = devm_gpiochip_add_data(&client->dev, &priv->gpio_chip, priv);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Unable to register gpiochip\\n\");\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(client, priv);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id ts4900_gpio_id_table[] = {\n\t{ \"ts4900-gpio\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, ts4900_gpio_id_table);\n\nstatic struct i2c_driver ts4900_gpio_driver = {\n\t.driver = {\n\t\t.name = \"ts4900-gpio\",\n\t\t.of_match_table = ts4900_gpio_of_match_table,\n\t},\n\t.probe = ts4900_gpio_probe,\n\t.id_table = ts4900_gpio_id_table,\n};\nmodule_i2c_driver(ts4900_gpio_driver);\n\nMODULE_AUTHOR(\"Technologic Systems\");\nMODULE_DESCRIPTION(\"GPIO interface for Technologic Systems I2C-FPGA core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}