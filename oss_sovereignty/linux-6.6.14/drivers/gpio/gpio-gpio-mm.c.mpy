{
  "module_name": "gpio-gpio-mm.c",
  "hash_id": "d1ec0a5645f862b05aa902c3cef0e2db509e5c9af20f3b353677c8230c510d51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-gpio-mm.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/isa.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n#include \"gpio-i8255.h\"\n\nMODULE_IMPORT_NS(I8255);\n\n#define GPIOMM_EXTENT 8\n#define MAX_NUM_GPIOMM max_num_isa_dev(GPIOMM_EXTENT)\n\nstatic unsigned int base[MAX_NUM_GPIOMM];\nstatic unsigned int num_gpiomm;\nmodule_param_hw_array(base, uint, ioport, &num_gpiomm, 0);\nMODULE_PARM_DESC(base, \"Diamond Systems GPIO-MM base addresses\");\n\n#define GPIOMM_NUM_PPI 2\n\nstatic const struct regmap_range gpiomm_volatile_ranges[] = {\n\ti8255_volatile_regmap_range(0x0), i8255_volatile_regmap_range(0x4),\n};\nstatic const struct regmap_access_table gpiomm_volatile_table = {\n\t.yes_ranges = gpiomm_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(gpiomm_volatile_ranges),\n};\nstatic const struct regmap_config gpiomm_regmap_config = {\n\t.reg_bits = 8,\n\t.reg_stride = 1,\n\t.val_bits = 8,\n\t.io_port = true,\n\t.max_register = 0x7,\n\t.volatile_table = &gpiomm_volatile_table,\n\t.cache_type = REGCACHE_FLAT,\n};\n\n#define GPIOMM_NGPIO 48\nstatic const char *gpiomm_names[GPIOMM_NGPIO] = {\n\t\"Port 1A0\", \"Port 1A1\", \"Port 1A2\", \"Port 1A3\", \"Port 1A4\", \"Port 1A5\",\n\t\"Port 1A6\", \"Port 1A7\", \"Port 1B0\", \"Port 1B1\", \"Port 1B2\", \"Port 1B3\",\n\t\"Port 1B4\", \"Port 1B5\", \"Port 1B6\", \"Port 1B7\", \"Port 1C0\", \"Port 1C1\",\n\t\"Port 1C2\", \"Port 1C3\", \"Port 1C4\", \"Port 1C5\", \"Port 1C6\", \"Port 1C7\",\n\t\"Port 2A0\", \"Port 2A1\", \"Port 2A2\", \"Port 2A3\", \"Port 2A4\", \"Port 2A5\",\n\t\"Port 2A6\", \"Port 2A7\", \"Port 2B0\", \"Port 2B1\", \"Port 2B2\", \"Port 2B3\",\n\t\"Port 2B4\", \"Port 2B5\", \"Port 2B6\", \"Port 2B7\", \"Port 2C0\", \"Port 2C1\",\n\t\"Port 2C2\", \"Port 2C3\", \"Port 2C4\", \"Port 2C5\", \"Port 2C6\", \"Port 2C7\",\n};\n\nstatic int gpiomm_probe(struct device *dev, unsigned int id)\n{\n\tconst char *const name = dev_name(dev);\n\tstruct i8255_regmap_config config = {};\n\tvoid __iomem *regs;\n\n\tif (!devm_request_region(dev, base[id], GPIOMM_EXTENT, name)) {\n\t\tdev_err(dev, \"Unable to lock port addresses (0x%X-0x%X)\\n\",\n\t\t\tbase[id], base[id] + GPIOMM_EXTENT);\n\t\treturn -EBUSY;\n\t}\n\n\tregs = devm_ioport_map(dev, base[id], GPIOMM_EXTENT);\n\tif (!regs)\n\t\treturn -ENOMEM;\n\n\tconfig.map = devm_regmap_init_mmio(dev, regs, &gpiomm_regmap_config);\n\tif (IS_ERR(config.map))\n\t\treturn dev_err_probe(dev, PTR_ERR(config.map),\n\t\t\t\t     \"Unable to initialize register map\\n\");\n\n\tconfig.parent = dev;\n\tconfig.num_ppi = GPIOMM_NUM_PPI;\n\tconfig.names = gpiomm_names;\n\n\treturn devm_i8255_regmap_register(dev, &config);\n}\n\nstatic struct isa_driver gpiomm_driver = {\n\t.probe = gpiomm_probe,\n\t.driver = {\n\t\t.name = \"gpio-mm\"\n\t},\n};\n\nmodule_isa_driver(gpiomm_driver, num_gpiomm);\n\nMODULE_AUTHOR(\"William Breathitt Gray <vilhelm.gray@gmail.com>\");\nMODULE_DESCRIPTION(\"Diamond Systems GPIO-MM GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}