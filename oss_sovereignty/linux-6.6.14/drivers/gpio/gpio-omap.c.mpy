{
  "module_name": "gpio-omap.c",
  "hash_id": "9aece4180e8a7f60a114428b6f88e3a0d612cdcc87e436fded2cb0e3d284a5db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-omap.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/syscore_ops.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/cpu_pm.h>\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm.h>\n#include <linux/of.h>\n#include <linux/gpio/driver.h>\n#include <linux/bitops.h>\n#include <linux/platform_data/gpio-omap.h>\n\n#define OMAP4_GPIO_DEBOUNCINGTIME_MASK 0xFF\n\nstruct gpio_regs {\n\tu32 sysconfig;\n\tu32 irqenable1;\n\tu32 irqenable2;\n\tu32 wake_en;\n\tu32 ctrl;\n\tu32 oe;\n\tu32 leveldetect0;\n\tu32 leveldetect1;\n\tu32 risingdetect;\n\tu32 fallingdetect;\n\tu32 dataout;\n\tu32 debounce;\n\tu32 debounce_en;\n};\n\nstruct gpio_bank {\n\tvoid __iomem *base;\n\tconst struct omap_gpio_reg_offs *regs;\n\tstruct device *dev;\n\n\tint irq;\n\tu32 non_wakeup_gpios;\n\tu32 enabled_non_wakeup_gpios;\n\tstruct gpio_regs context;\n\tu32 saved_datain;\n\tu32 level_mask;\n\tu32 toggle_mask;\n\traw_spinlock_t lock;\n\traw_spinlock_t wa_lock;\n\tstruct gpio_chip chip;\n\tstruct clk *dbck;\n\tstruct notifier_block nb;\n\tunsigned int is_suspended:1;\n\tunsigned int needs_resume:1;\n\tu32 mod_usage;\n\tu32 irq_usage;\n\tu32 dbck_enable_mask;\n\tbool dbck_enabled;\n\tbool is_mpuio;\n\tbool dbck_flag;\n\tbool loses_context;\n\tbool context_valid;\n\tint stride;\n\tu32 width;\n\tint context_loss_count;\n\n\tvoid (*set_dataout)(struct gpio_bank *bank, unsigned gpio, int enable);\n\tint (*get_context_loss_count)(struct device *dev);\n};\n\n#define GPIO_MOD_CTRL_BIT\tBIT(0)\n\n#define BANK_USED(bank) (bank->mod_usage || bank->irq_usage)\n#define LINE_USED(line, offset) (line & (BIT(offset)))\n\nstatic void omap_gpio_unmask_irq(struct irq_data *d);\n\nstatic inline struct gpio_bank *omap_irq_data_get_bank(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\treturn gpiochip_get_data(chip);\n}\n\nstatic inline u32 omap_gpio_rmw(void __iomem *reg, u32 mask, bool set)\n{\n\tu32 val = readl_relaxed(reg);\n\n\tif (set)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\n\twritel_relaxed(val, reg);\n\n\treturn val;\n}\n\nstatic void omap_set_gpio_direction(struct gpio_bank *bank, int gpio,\n\t\t\t\t    int is_input)\n{\n\tbank->context.oe = omap_gpio_rmw(bank->base + bank->regs->direction,\n\t\t\t\t\t BIT(gpio), is_input);\n}\n\n\n \nstatic void omap_set_gpio_dataout_reg(struct gpio_bank *bank, unsigned offset,\n\t\t\t\t      int enable)\n{\n\tvoid __iomem *reg = bank->base;\n\tu32 l = BIT(offset);\n\n\tif (enable) {\n\t\treg += bank->regs->set_dataout;\n\t\tbank->context.dataout |= l;\n\t} else {\n\t\treg += bank->regs->clr_dataout;\n\t\tbank->context.dataout &= ~l;\n\t}\n\n\twritel_relaxed(l, reg);\n}\n\n \nstatic void omap_set_gpio_dataout_mask(struct gpio_bank *bank, unsigned offset,\n\t\t\t\t       int enable)\n{\n\tbank->context.dataout = omap_gpio_rmw(bank->base + bank->regs->dataout,\n\t\t\t\t\t      BIT(offset), enable);\n}\n\nstatic inline void omap_gpio_dbck_enable(struct gpio_bank *bank)\n{\n\tif (bank->dbck_enable_mask && !bank->dbck_enabled) {\n\t\tclk_enable(bank->dbck);\n\t\tbank->dbck_enabled = true;\n\n\t\twritel_relaxed(bank->dbck_enable_mask,\n\t\t\t     bank->base + bank->regs->debounce_en);\n\t}\n}\n\nstatic inline void omap_gpio_dbck_disable(struct gpio_bank *bank)\n{\n\tif (bank->dbck_enable_mask && bank->dbck_enabled) {\n\t\t \n\t\twritel_relaxed(0, bank->base + bank->regs->debounce_en);\n\n\t\tclk_disable(bank->dbck);\n\t\tbank->dbck_enabled = false;\n\t}\n}\n\n \nstatic int omap2_set_gpio_debounce(struct gpio_bank *bank, unsigned offset,\n\t\t\t\t   unsigned debounce)\n{\n\tu32\t\t\tval;\n\tu32\t\t\tl;\n\tbool\t\t\tenable = !!debounce;\n\n\tif (!bank->dbck_flag)\n\t\treturn -ENOTSUPP;\n\n\tif (enable) {\n\t\tdebounce = DIV_ROUND_UP(debounce, 31) - 1;\n\t\tif ((debounce & OMAP4_GPIO_DEBOUNCINGTIME_MASK) != debounce)\n\t\t\treturn -EINVAL;\n\t}\n\n\tl = BIT(offset);\n\n\tclk_enable(bank->dbck);\n\twritel_relaxed(debounce, bank->base + bank->regs->debounce);\n\n\tval = omap_gpio_rmw(bank->base + bank->regs->debounce_en, l, enable);\n\tbank->dbck_enable_mask = val;\n\n\tclk_disable(bank->dbck);\n\t \n\tomap_gpio_dbck_enable(bank);\n\tif (bank->dbck_enable_mask) {\n\t\tbank->context.debounce = debounce;\n\t\tbank->context.debounce_en = val;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void omap_clear_gpio_debounce(struct gpio_bank *bank, unsigned offset)\n{\n\tu32 gpio_bit = BIT(offset);\n\n\tif (!bank->dbck_flag)\n\t\treturn;\n\n\tif (!(bank->dbck_enable_mask & gpio_bit))\n\t\treturn;\n\n\tbank->dbck_enable_mask &= ~gpio_bit;\n\tbank->context.debounce_en &= ~gpio_bit;\n        writel_relaxed(bank->context.debounce_en,\n\t\t     bank->base + bank->regs->debounce_en);\n\n\tif (!bank->dbck_enable_mask) {\n\t\tbank->context.debounce = 0;\n\t\twritel_relaxed(bank->context.debounce, bank->base +\n\t\t\t     bank->regs->debounce);\n\t\tclk_disable(bank->dbck);\n\t\tbank->dbck_enabled = false;\n\t}\n}\n\n \nstatic bool omap_gpio_is_off_wakeup_capable(struct gpio_bank *bank, u32 gpio_mask)\n{\n\tu32 no_wake = bank->non_wakeup_gpios;\n\n\tif (no_wake)\n\t\treturn !!(~no_wake & gpio_mask);\n\n\treturn false;\n}\n\nstatic inline void omap_set_gpio_trigger(struct gpio_bank *bank, int gpio,\n\t\t\t\t\t\tunsigned trigger)\n{\n\tvoid __iomem *base = bank->base;\n\tu32 gpio_bit = BIT(gpio);\n\n\tomap_gpio_rmw(base + bank->regs->leveldetect0, gpio_bit,\n\t\t      trigger & IRQ_TYPE_LEVEL_LOW);\n\tomap_gpio_rmw(base + bank->regs->leveldetect1, gpio_bit,\n\t\t      trigger & IRQ_TYPE_LEVEL_HIGH);\n\n\t \n\tomap_gpio_rmw(base + bank->regs->risingdetect, gpio_bit,\n\t\t      trigger & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_LEVEL_HIGH));\n\tomap_gpio_rmw(base + bank->regs->fallingdetect, gpio_bit,\n\t\t      trigger & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_LEVEL_LOW));\n\n\tbank->context.leveldetect0 =\n\t\t\treadl_relaxed(bank->base + bank->regs->leveldetect0);\n\tbank->context.leveldetect1 =\n\t\t\treadl_relaxed(bank->base + bank->regs->leveldetect1);\n\tbank->context.risingdetect =\n\t\t\treadl_relaxed(bank->base + bank->regs->risingdetect);\n\tbank->context.fallingdetect =\n\t\t\treadl_relaxed(bank->base + bank->regs->fallingdetect);\n\n\tbank->level_mask = bank->context.leveldetect0 |\n\t\t\t   bank->context.leveldetect1;\n\n\t \n\tif (!bank->regs->irqctrl && !omap_gpio_is_off_wakeup_capable(bank, gpio)) {\n\t\t \n\t\tif (trigger & IRQ_TYPE_EDGE_BOTH)\n\t\t\tbank->enabled_non_wakeup_gpios |= gpio_bit;\n\t\telse\n\t\t\tbank->enabled_non_wakeup_gpios &= ~gpio_bit;\n\t}\n}\n\n \nstatic void omap_toggle_gpio_edge_triggering(struct gpio_bank *bank, int gpio)\n{\n\tif (IS_ENABLED(CONFIG_ARCH_OMAP1) && bank->regs->irqctrl) {\n\t\tvoid __iomem *reg = bank->base + bank->regs->irqctrl;\n\n\t\twritel_relaxed(readl_relaxed(reg) ^ BIT(gpio), reg);\n\t}\n}\n\nstatic int omap_set_gpio_triggering(struct gpio_bank *bank, int gpio,\n\t\t\t\t    unsigned trigger)\n{\n\tvoid __iomem *reg = bank->base;\n\tu32 l = 0;\n\n\tif (bank->regs->leveldetect0 && bank->regs->wkup_en) {\n\t\tomap_set_gpio_trigger(bank, gpio, trigger);\n\t} else if (bank->regs->irqctrl) {\n\t\treg += bank->regs->irqctrl;\n\n\t\tl = readl_relaxed(reg);\n\t\tif ((trigger & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH)\n\t\t\tbank->toggle_mask |= BIT(gpio);\n\t\tif (trigger & IRQ_TYPE_EDGE_RISING)\n\t\t\tl |= BIT(gpio);\n\t\telse if (trigger & IRQ_TYPE_EDGE_FALLING)\n\t\t\tl &= ~(BIT(gpio));\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\twritel_relaxed(l, reg);\n\t} else if (bank->regs->edgectrl1) {\n\t\tif (gpio & 0x08)\n\t\t\treg += bank->regs->edgectrl2;\n\t\telse\n\t\t\treg += bank->regs->edgectrl1;\n\n\t\tgpio &= 0x07;\n\t\tl = readl_relaxed(reg);\n\t\tl &= ~(3 << (gpio << 1));\n\t\tif (trigger & IRQ_TYPE_EDGE_RISING)\n\t\t\tl |= 2 << (gpio << 1);\n\t\tif (trigger & IRQ_TYPE_EDGE_FALLING)\n\t\t\tl |= BIT(gpio << 1);\n\t\twritel_relaxed(l, reg);\n\t}\n\treturn 0;\n}\n\nstatic void omap_enable_gpio_module(struct gpio_bank *bank, unsigned offset)\n{\n\tif (bank->regs->pinctrl) {\n\t\tvoid __iomem *reg = bank->base + bank->regs->pinctrl;\n\n\t\t \n\t\twritel_relaxed(readl_relaxed(reg) | (BIT(offset)), reg);\n\t}\n\n\tif (bank->regs->ctrl && !BANK_USED(bank)) {\n\t\tvoid __iomem *reg = bank->base + bank->regs->ctrl;\n\t\tu32 ctrl;\n\n\t\tctrl = readl_relaxed(reg);\n\t\t \n\t\tctrl &= ~GPIO_MOD_CTRL_BIT;\n\t\twritel_relaxed(ctrl, reg);\n\t\tbank->context.ctrl = ctrl;\n\t}\n}\n\nstatic void omap_disable_gpio_module(struct gpio_bank *bank, unsigned offset)\n{\n\tif (bank->regs->ctrl && !BANK_USED(bank)) {\n\t\tvoid __iomem *reg = bank->base + bank->regs->ctrl;\n\t\tu32 ctrl;\n\n\t\tctrl = readl_relaxed(reg);\n\t\t \n\t\tctrl |= GPIO_MOD_CTRL_BIT;\n\t\twritel_relaxed(ctrl, reg);\n\t\tbank->context.ctrl = ctrl;\n\t}\n}\n\nstatic int omap_gpio_is_input(struct gpio_bank *bank, unsigned offset)\n{\n\tvoid __iomem *reg = bank->base + bank->regs->direction;\n\n\treturn readl_relaxed(reg) & BIT(offset);\n}\n\nstatic void omap_gpio_init_irq(struct gpio_bank *bank, unsigned offset)\n{\n\tif (!LINE_USED(bank->mod_usage, offset)) {\n\t\tomap_enable_gpio_module(bank, offset);\n\t\tomap_set_gpio_direction(bank, offset, 1);\n\t}\n\tbank->irq_usage |= BIT(offset);\n}\n\nstatic int omap_gpio_irq_type(struct irq_data *d, unsigned type)\n{\n\tstruct gpio_bank *bank = omap_irq_data_get_bank(d);\n\tint retval;\n\tunsigned long flags;\n\tunsigned offset = d->hwirq;\n\n\tif (type & ~IRQ_TYPE_SENSE_MASK)\n\t\treturn -EINVAL;\n\n\tif (!bank->regs->leveldetect0 &&\n\t\t(type & (IRQ_TYPE_LEVEL_LOW|IRQ_TYPE_LEVEL_HIGH)))\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tretval = omap_set_gpio_triggering(bank, offset, type);\n\tif (retval) {\n\t\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\t\tgoto error;\n\t}\n\tomap_gpio_init_irq(bank, offset);\n\tif (!omap_gpio_is_input(bank, offset)) {\n\t\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\t\tretval = -EINVAL;\n\t\tgoto error;\n\t}\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\n\tif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\telse if (type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\n\t\t \n\t\tirq_set_handler_locked(d, handle_simple_irq);\n\n\treturn 0;\n\nerror:\n\treturn retval;\n}\n\nstatic void omap_clear_gpio_irqbank(struct gpio_bank *bank, int gpio_mask)\n{\n\tvoid __iomem *reg = bank->base;\n\n\treg += bank->regs->irqstatus;\n\twritel_relaxed(gpio_mask, reg);\n\n\t \n\tif (bank->regs->irqstatus2) {\n\t\treg = bank->base + bank->regs->irqstatus2;\n\t\twritel_relaxed(gpio_mask, reg);\n\t}\n\n\t \n\treadl_relaxed(reg);\n}\n\nstatic inline void omap_clear_gpio_irqstatus(struct gpio_bank *bank,\n\t\t\t\t\t     unsigned offset)\n{\n\tomap_clear_gpio_irqbank(bank, BIT(offset));\n}\n\nstatic u32 omap_get_gpio_irqbank_mask(struct gpio_bank *bank)\n{\n\tvoid __iomem *reg = bank->base;\n\tu32 l;\n\tu32 mask = (BIT(bank->width)) - 1;\n\n\treg += bank->regs->irqenable;\n\tl = readl_relaxed(reg);\n\tif (bank->regs->irqenable_inv)\n\t\tl = ~l;\n\tl &= mask;\n\treturn l;\n}\n\nstatic inline void omap_set_gpio_irqenable(struct gpio_bank *bank,\n\t\t\t\t\t   unsigned offset, int enable)\n{\n\tvoid __iomem *reg = bank->base;\n\tu32 gpio_mask = BIT(offset);\n\n\tif (bank->regs->set_irqenable && bank->regs->clr_irqenable) {\n\t\tif (enable) {\n\t\t\treg += bank->regs->set_irqenable;\n\t\t\tbank->context.irqenable1 |= gpio_mask;\n\t\t} else {\n\t\t\treg += bank->regs->clr_irqenable;\n\t\t\tbank->context.irqenable1 &= ~gpio_mask;\n\t\t}\n\t\twritel_relaxed(gpio_mask, reg);\n\t} else {\n\t\tbank->context.irqenable1 =\n\t\t\tomap_gpio_rmw(reg + bank->regs->irqenable, gpio_mask,\n\t\t\t\t      enable ^ bank->regs->irqenable_inv);\n\t}\n\n\t \n\tif (bank->regs->wkup_en &&\n\t    (bank->regs->edgectrl1 || !(bank->non_wakeup_gpios & gpio_mask))) {\n\t\tbank->context.wake_en =\n\t\t\tomap_gpio_rmw(bank->base + bank->regs->wkup_en,\n\t\t\t\t      gpio_mask, enable);\n\t}\n}\n\n \nstatic int omap_gpio_wake_enable(struct irq_data *d, unsigned int enable)\n{\n\tstruct gpio_bank *bank = omap_irq_data_get_bank(d);\n\n\treturn irq_set_irq_wake(bank->irq, enable);\n}\n\n \nstatic irqreturn_t omap_gpio_irq_handler(int irq, void *gpiobank)\n{\n\tvoid __iomem *isr_reg = NULL;\n\tu32 enabled, isr, edge;\n\tunsigned int bit;\n\tstruct gpio_bank *bank = gpiobank;\n\tunsigned long wa_lock_flags;\n\tunsigned long lock_flags;\n\n\tisr_reg = bank->base + bank->regs->irqstatus;\n\tif (WARN_ON(!isr_reg))\n\t\tgoto exit;\n\n\tif (WARN_ONCE(!pm_runtime_active(bank->chip.parent),\n\t\t      \"gpio irq%i while runtime suspended?\\n\", irq))\n\t\treturn IRQ_NONE;\n\n\twhile (1) {\n\t\traw_spin_lock_irqsave(&bank->lock, lock_flags);\n\n\t\tenabled = omap_get_gpio_irqbank_mask(bank);\n\t\tisr = readl_relaxed(isr_reg) & enabled;\n\n\t\t \n\t\tedge = isr & ~bank->level_mask;\n\t\tif (edge)\n\t\t\tomap_clear_gpio_irqbank(bank, edge);\n\n\t\traw_spin_unlock_irqrestore(&bank->lock, lock_flags);\n\n\t\tif (!isr)\n\t\t\tbreak;\n\n\t\twhile (isr) {\n\t\t\tbit = __ffs(isr);\n\t\t\tisr &= ~(BIT(bit));\n\n\t\t\traw_spin_lock_irqsave(&bank->lock, lock_flags);\n\t\t\t \n\t\t\tif (bank->toggle_mask & (BIT(bit)))\n\t\t\t\tomap_toggle_gpio_edge_triggering(bank, bit);\n\n\t\t\traw_spin_unlock_irqrestore(&bank->lock, lock_flags);\n\n\t\t\traw_spin_lock_irqsave(&bank->wa_lock, wa_lock_flags);\n\n\t\t\tgeneric_handle_domain_irq(bank->chip.irq.domain, bit);\n\n\t\t\traw_spin_unlock_irqrestore(&bank->wa_lock,\n\t\t\t\t\t\t   wa_lock_flags);\n\t\t}\n\t}\nexit:\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int omap_gpio_irq_startup(struct irq_data *d)\n{\n\tstruct gpio_bank *bank = omap_irq_data_get_bank(d);\n\tunsigned long flags;\n\tunsigned offset = d->hwirq;\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\n\tif (!LINE_USED(bank->mod_usage, offset))\n\t\tomap_set_gpio_direction(bank, offset, 1);\n\tomap_enable_gpio_module(bank, offset);\n\tbank->irq_usage |= BIT(offset);\n\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\tomap_gpio_unmask_irq(d);\n\n\treturn 0;\n}\n\nstatic void omap_gpio_irq_shutdown(struct irq_data *d)\n{\n\tstruct gpio_bank *bank = omap_irq_data_get_bank(d);\n\tunsigned long flags;\n\tunsigned offset = d->hwirq;\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tbank->irq_usage &= ~(BIT(offset));\n\tomap_set_gpio_triggering(bank, offset, IRQ_TYPE_NONE);\n\tomap_clear_gpio_irqstatus(bank, offset);\n\tomap_set_gpio_irqenable(bank, offset, 0);\n\tif (!LINE_USED(bank->mod_usage, offset))\n\t\tomap_clear_gpio_debounce(bank, offset);\n\tomap_disable_gpio_module(bank, offset);\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n}\n\nstatic void omap_gpio_irq_bus_lock(struct irq_data *data)\n{\n\tstruct gpio_bank *bank = omap_irq_data_get_bank(data);\n\n\tpm_runtime_get_sync(bank->chip.parent);\n}\n\nstatic void gpio_irq_bus_sync_unlock(struct irq_data *data)\n{\n\tstruct gpio_bank *bank = omap_irq_data_get_bank(data);\n\n\tpm_runtime_put(bank->chip.parent);\n}\n\nstatic void omap_gpio_mask_irq(struct irq_data *d)\n{\n\tstruct gpio_bank *bank = omap_irq_data_get_bank(d);\n\tunsigned offset = d->hwirq;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tomap_set_gpio_triggering(bank, offset, IRQ_TYPE_NONE);\n\tomap_set_gpio_irqenable(bank, offset, 0);\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\tgpiochip_disable_irq(&bank->chip, offset);\n}\n\nstatic void omap_gpio_unmask_irq(struct irq_data *d)\n{\n\tstruct gpio_bank *bank = omap_irq_data_get_bank(d);\n\tunsigned offset = d->hwirq;\n\tu32 trigger = irqd_get_trigger_type(d);\n\tunsigned long flags;\n\n\tgpiochip_enable_irq(&bank->chip, offset);\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tomap_set_gpio_irqenable(bank, offset, 1);\n\n\t \n\tif (bank->regs->leveldetect0 && bank->regs->wkup_en &&\n\t    trigger & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW))\n\t\tomap_clear_gpio_irqstatus(bank, offset);\n\n\tif (trigger)\n\t\tomap_set_gpio_triggering(bank, offset, trigger);\n\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n}\n\nstatic void omap_gpio_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct gpio_bank *bank = omap_irq_data_get_bank(d);\n\n\tseq_printf(p, dev_name(bank->dev));\n}\n\nstatic const struct irq_chip omap_gpio_irq_chip = {\n\t.irq_startup = omap_gpio_irq_startup,\n\t.irq_shutdown = omap_gpio_irq_shutdown,\n\t.irq_mask = omap_gpio_mask_irq,\n\t.irq_unmask = omap_gpio_unmask_irq,\n\t.irq_set_type = omap_gpio_irq_type,\n\t.irq_set_wake = omap_gpio_wake_enable,\n\t.irq_bus_lock = omap_gpio_irq_bus_lock,\n\t.irq_bus_sync_unlock = gpio_irq_bus_sync_unlock,\n\t.irq_print_chip = omap_gpio_irq_print_chip,\n\t.flags = IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_IMMUTABLE,\n\t GPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic const struct irq_chip omap_gpio_irq_chip_nowake = {\n\t.irq_startup = omap_gpio_irq_startup,\n\t.irq_shutdown = omap_gpio_irq_shutdown,\n\t.irq_mask = omap_gpio_mask_irq,\n\t.irq_unmask = omap_gpio_unmask_irq,\n\t.irq_set_type = omap_gpio_irq_type,\n\t.irq_bus_lock = omap_gpio_irq_bus_lock,\n\t.irq_bus_sync_unlock = gpio_irq_bus_sync_unlock,\n\t.irq_print_chip = omap_gpio_irq_print_chip,\n\t.flags = IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_IMMUTABLE,\n\t GPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\n \n\nstatic int omap_mpuio_suspend_noirq(struct device *dev)\n{\n\tstruct gpio_bank\t*bank = dev_get_drvdata(dev);\n\tvoid __iomem\t\t*mask_reg = bank->base +\n\t\t\t\t\tOMAP_MPUIO_GPIO_MASKIT / bank->stride;\n\tunsigned long\t\tflags;\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\twritel_relaxed(0xffff & ~bank->context.wake_en, mask_reg);\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn 0;\n}\n\nstatic int omap_mpuio_resume_noirq(struct device *dev)\n{\n\tstruct gpio_bank\t*bank = dev_get_drvdata(dev);\n\tvoid __iomem\t\t*mask_reg = bank->base +\n\t\t\t\t\tOMAP_MPUIO_GPIO_MASKIT / bank->stride;\n\tunsigned long\t\tflags;\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\twritel_relaxed(bank->context.wake_en, mask_reg);\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops omap_mpuio_dev_pm_ops = {\n\t.suspend_noirq = omap_mpuio_suspend_noirq,\n\t.resume_noirq = omap_mpuio_resume_noirq,\n};\n\n \nstatic struct platform_driver omap_mpuio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"mpuio\",\n\t\t.pm\t= &omap_mpuio_dev_pm_ops,\n\t},\n};\n\nstatic struct platform_device omap_mpuio_device = {\n\t.name\t\t= \"mpuio\",\n\t.id\t\t= -1,\n\t.dev = {\n\t\t.driver = &omap_mpuio_driver.driver,\n\t}\n\t \n};\n\nstatic inline void omap_mpuio_init(struct gpio_bank *bank)\n{\n\tplatform_set_drvdata(&omap_mpuio_device, bank);\n\n\tif (platform_driver_register(&omap_mpuio_driver) == 0)\n\t\t(void) platform_device_register(&omap_mpuio_device);\n}\n\n \n\nstatic int omap_gpio_request(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_bank *bank = gpiochip_get_data(chip);\n\tunsigned long flags;\n\n\tpm_runtime_get_sync(chip->parent);\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tomap_enable_gpio_module(bank, offset);\n\tbank->mod_usage |= BIT(offset);\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn 0;\n}\n\nstatic void omap_gpio_free(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_bank *bank = gpiochip_get_data(chip);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tbank->mod_usage &= ~(BIT(offset));\n\tif (!LINE_USED(bank->irq_usage, offset)) {\n\t\tomap_set_gpio_direction(bank, offset, 1);\n\t\tomap_clear_gpio_debounce(bank, offset);\n\t}\n\tomap_disable_gpio_module(bank, offset);\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\n\tpm_runtime_put(chip->parent);\n}\n\nstatic int omap_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_bank *bank = gpiochip_get_data(chip);\n\n\tif (readl_relaxed(bank->base + bank->regs->direction) & BIT(offset))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int omap_gpio_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_bank *bank;\n\tunsigned long flags;\n\n\tbank = gpiochip_get_data(chip);\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tomap_set_gpio_direction(bank, offset, 1);\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\treturn 0;\n}\n\nstatic int omap_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_bank *bank = gpiochip_get_data(chip);\n\tvoid __iomem *reg;\n\n\tif (omap_gpio_is_input(bank, offset))\n\t\treg = bank->base + bank->regs->datain;\n\telse\n\t\treg = bank->base + bank->regs->dataout;\n\n\treturn (readl_relaxed(reg) & BIT(offset)) != 0;\n}\n\nstatic int omap_gpio_output(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct gpio_bank *bank;\n\tunsigned long flags;\n\n\tbank = gpiochip_get_data(chip);\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tbank->set_dataout(bank, offset, value);\n\tomap_set_gpio_direction(bank, offset, 0);\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\treturn 0;\n}\n\nstatic int omap_gpio_get_multiple(struct gpio_chip *chip, unsigned long *mask,\n\t\t\t\t  unsigned long *bits)\n{\n\tstruct gpio_bank *bank = gpiochip_get_data(chip);\n\tvoid __iomem *base = bank->base;\n\tu32 direction, m, val = 0;\n\n\tdirection = readl_relaxed(base + bank->regs->direction);\n\n\tm = direction & *mask;\n\tif (m)\n\t\tval |= readl_relaxed(base + bank->regs->datain) & m;\n\n\tm = ~direction & *mask;\n\tif (m)\n\t\tval |= readl_relaxed(base + bank->regs->dataout) & m;\n\n\t*bits = val;\n\n\treturn 0;\n}\n\nstatic int omap_gpio_debounce(struct gpio_chip *chip, unsigned offset,\n\t\t\t      unsigned debounce)\n{\n\tstruct gpio_bank *bank;\n\tunsigned long flags;\n\tint ret;\n\n\tbank = gpiochip_get_data(chip);\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tret = omap2_set_gpio_debounce(bank, offset, debounce);\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\n\tif (ret)\n\t\tdev_info(chip->parent,\n\t\t\t \"Could not set line %u debounce to %u microseconds (%d)\",\n\t\t\t offset, debounce, ret);\n\n\treturn ret;\n}\n\nstatic int omap_gpio_set_config(struct gpio_chip *chip, unsigned offset,\n\t\t\t\tunsigned long config)\n{\n\tu32 debounce;\n\tint ret = -ENOTSUPP;\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tret = gpiochip_generic_config(chip, offset, config);\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\tdebounce = pinconf_to_config_argument(config);\n\t\tret = omap_gpio_debounce(chip, offset, debounce);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void omap_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct gpio_bank *bank;\n\tunsigned long flags;\n\n\tbank = gpiochip_get_data(chip);\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tbank->set_dataout(bank, offset, value);\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n}\n\nstatic void omap_gpio_set_multiple(struct gpio_chip *chip, unsigned long *mask,\n\t\t\t\t   unsigned long *bits)\n{\n\tstruct gpio_bank *bank = gpiochip_get_data(chip);\n\tvoid __iomem *reg = bank->base + bank->regs->dataout;\n\tunsigned long flags;\n\tu32 l;\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tl = (readl_relaxed(reg) & ~*mask) | (*bits & *mask);\n\twritel_relaxed(l, reg);\n\tbank->context.dataout = l;\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n}\n\n \n\nstatic void omap_gpio_show_rev(struct gpio_bank *bank)\n{\n\tstatic bool called;\n\tu32 rev;\n\n\tif (called || bank->regs->revision == USHRT_MAX)\n\t\treturn;\n\n\trev = readw_relaxed(bank->base + bank->regs->revision);\n\tpr_info(\"OMAP GPIO hardware version %d.%d\\n\",\n\t\t(rev >> 4) & 0x0f, rev & 0x0f);\n\n\tcalled = true;\n}\n\nstatic void omap_gpio_mod_init(struct gpio_bank *bank)\n{\n\tvoid __iomem *base = bank->base;\n\tu32 l = 0xffffffff;\n\n\tif (bank->width == 16)\n\t\tl = 0xffff;\n\n\tif (bank->is_mpuio) {\n\t\twritel_relaxed(l, bank->base + bank->regs->irqenable);\n\t\treturn;\n\t}\n\n\tomap_gpio_rmw(base + bank->regs->irqenable, l,\n\t\t      bank->regs->irqenable_inv);\n\tomap_gpio_rmw(base + bank->regs->irqstatus, l,\n\t\t      !bank->regs->irqenable_inv);\n\tif (bank->regs->debounce_en)\n\t\twritel_relaxed(0, base + bank->regs->debounce_en);\n\n\t \n\tbank->context.oe = readl_relaxed(bank->base + bank->regs->direction);\n\t  \n\tif (bank->regs->ctrl)\n\t\twritel_relaxed(0, base + bank->regs->ctrl);\n}\n\nstatic int omap_gpio_chip_init(struct gpio_bank *bank, struct device *pm_dev)\n{\n\tstruct gpio_irq_chip *irq;\n\tstatic int gpio;\n\tconst char *label;\n\tint ret;\n\n\t \n\tbank->chip.request = omap_gpio_request;\n\tbank->chip.free = omap_gpio_free;\n\tbank->chip.get_direction = omap_gpio_get_direction;\n\tbank->chip.direction_input = omap_gpio_input;\n\tbank->chip.get = omap_gpio_get;\n\tbank->chip.get_multiple = omap_gpio_get_multiple;\n\tbank->chip.direction_output = omap_gpio_output;\n\tbank->chip.set_config = omap_gpio_set_config;\n\tbank->chip.set = omap_gpio_set;\n\tbank->chip.set_multiple = omap_gpio_set_multiple;\n\tif (bank->is_mpuio) {\n\t\tbank->chip.label = \"mpuio\";\n\t\tif (bank->regs->wkup_en)\n\t\t\tbank->chip.parent = &omap_mpuio_device.dev;\n\t\tbank->chip.base = OMAP_MPUIO(0);\n\t} else {\n\t\tlabel = devm_kasprintf(bank->chip.parent, GFP_KERNEL, \"gpio-%d-%d\",\n\t\t\t\t       gpio, gpio + bank->width - 1);\n\t\tif (!label)\n\t\t\treturn -ENOMEM;\n\t\tbank->chip.label = label;\n\t\tbank->chip.base = -1;\n\t}\n\tbank->chip.ngpio = bank->width;\n\n\tirq = &bank->chip.irq;\n\t \n\tif (bank->is_mpuio && !bank->regs->wkup_en)\n\t\tgpio_irq_chip_set_chip(irq, &omap_gpio_irq_chip_nowake);\n\telse\n\t\tgpio_irq_chip_set_chip(irq, &omap_gpio_irq_chip);\n\tirq->handler = handle_bad_irq;\n\tirq->default_type = IRQ_TYPE_NONE;\n\tirq->num_parents = 1;\n\tirq->parents = &bank->irq;\n\n\tret = gpiochip_add_data(&bank->chip, bank);\n\tif (ret)\n\t\treturn dev_err_probe(bank->chip.parent, ret, \"Could not register gpio chip\\n\");\n\n\tirq_domain_set_pm_device(bank->chip.irq.domain, pm_dev);\n\tret = devm_request_irq(bank->chip.parent, bank->irq,\n\t\t\t       omap_gpio_irq_handler,\n\t\t\t       0, dev_name(bank->chip.parent), bank);\n\tif (ret)\n\t\tgpiochip_remove(&bank->chip);\n\n\tif (!bank->is_mpuio)\n\t\tgpio += bank->width;\n\n\treturn ret;\n}\n\nstatic void omap_gpio_init_context(struct gpio_bank *p)\n{\n\tconst struct omap_gpio_reg_offs *regs = p->regs;\n\tvoid __iomem *base = p->base;\n\n\tp->context.sysconfig\t= readl_relaxed(base + regs->sysconfig);\n\tp->context.ctrl\t\t= readl_relaxed(base + regs->ctrl);\n\tp->context.oe\t\t= readl_relaxed(base + regs->direction);\n\tp->context.wake_en\t= readl_relaxed(base + regs->wkup_en);\n\tp->context.leveldetect0\t= readl_relaxed(base + regs->leveldetect0);\n\tp->context.leveldetect1\t= readl_relaxed(base + regs->leveldetect1);\n\tp->context.risingdetect\t= readl_relaxed(base + regs->risingdetect);\n\tp->context.fallingdetect = readl_relaxed(base + regs->fallingdetect);\n\tp->context.irqenable1\t= readl_relaxed(base + regs->irqenable);\n\tp->context.irqenable2\t= readl_relaxed(base + regs->irqenable2);\n\tp->context.dataout\t= readl_relaxed(base + regs->dataout);\n\n\tp->context_valid = true;\n}\n\nstatic void omap_gpio_restore_context(struct gpio_bank *bank)\n{\n\tconst struct omap_gpio_reg_offs *regs = bank->regs;\n\tvoid __iomem *base = bank->base;\n\n\twritel_relaxed(bank->context.sysconfig, base + regs->sysconfig);\n\twritel_relaxed(bank->context.wake_en, base + regs->wkup_en);\n\twritel_relaxed(bank->context.ctrl, base + regs->ctrl);\n\twritel_relaxed(bank->context.leveldetect0, base + regs->leveldetect0);\n\twritel_relaxed(bank->context.leveldetect1, base + regs->leveldetect1);\n\twritel_relaxed(bank->context.risingdetect, base + regs->risingdetect);\n\twritel_relaxed(bank->context.fallingdetect, base + regs->fallingdetect);\n\twritel_relaxed(bank->context.dataout, base + regs->dataout);\n\twritel_relaxed(bank->context.oe, base + regs->direction);\n\n\tif (bank->dbck_enable_mask) {\n\t\twritel_relaxed(bank->context.debounce, base + regs->debounce);\n\t\twritel_relaxed(bank->context.debounce_en,\n\t\t\t       base + regs->debounce_en);\n\t}\n\n\twritel_relaxed(bank->context.irqenable1, base + regs->irqenable);\n\twritel_relaxed(bank->context.irqenable2, base + regs->irqenable2);\n}\n\nstatic void omap_gpio_idle(struct gpio_bank *bank, bool may_lose_context)\n{\n\tstruct device *dev = bank->chip.parent;\n\tvoid __iomem *base = bank->base;\n\tu32 mask, nowake;\n\n\tbank->saved_datain = readl_relaxed(base + bank->regs->datain);\n\n\t \n\tif (bank->loses_context)\n\t\tbank->context.sysconfig = readl_relaxed(base + bank->regs->sysconfig);\n\n\tif (!bank->enabled_non_wakeup_gpios)\n\t\tgoto update_gpio_context_count;\n\n\t \n\tmask = bank->enabled_non_wakeup_gpios & bank->context.fallingdetect;\n\tmask &= ~bank->context.risingdetect;\n\tbank->saved_datain |= mask;\n\n\t \n\tmask = bank->enabled_non_wakeup_gpios & bank->context.risingdetect;\n\tmask &= ~bank->context.fallingdetect;\n\tbank->saved_datain &= ~mask;\n\n\tif (!may_lose_context)\n\t\tgoto update_gpio_context_count;\n\n\t \n\tif (!bank->loses_context && bank->enabled_non_wakeup_gpios) {\n\t\tnowake = bank->enabled_non_wakeup_gpios;\n\t\tomap_gpio_rmw(base + bank->regs->fallingdetect, nowake, ~nowake);\n\t\tomap_gpio_rmw(base + bank->regs->risingdetect, nowake, ~nowake);\n\t}\n\nupdate_gpio_context_count:\n\tif (bank->get_context_loss_count)\n\t\tbank->context_loss_count =\n\t\t\t\tbank->get_context_loss_count(dev);\n\n\tomap_gpio_dbck_disable(bank);\n}\n\nstatic void omap_gpio_unidle(struct gpio_bank *bank)\n{\n\tstruct device *dev = bank->chip.parent;\n\tu32 l = 0, gen, gen0, gen1;\n\tint c;\n\n\t \n\tif (bank->loses_context && !bank->context_valid) {\n\t\tomap_gpio_init_context(bank);\n\n\t\tif (bank->get_context_loss_count)\n\t\t\tbank->context_loss_count =\n\t\t\t\tbank->get_context_loss_count(dev);\n\t}\n\n\tomap_gpio_dbck_enable(bank);\n\n\tif (bank->loses_context) {\n\t\tif (!bank->get_context_loss_count) {\n\t\t\tomap_gpio_restore_context(bank);\n\t\t} else {\n\t\t\tc = bank->get_context_loss_count(dev);\n\t\t\tif (c != bank->context_loss_count) {\n\t\t\t\tomap_gpio_restore_context(bank);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\twritel_relaxed(bank->context.fallingdetect,\n\t\t\t       bank->base + bank->regs->fallingdetect);\n\t\twritel_relaxed(bank->context.risingdetect,\n\t\t\t       bank->base + bank->regs->risingdetect);\n\t}\n\n\tl = readl_relaxed(bank->base + bank->regs->datain);\n\n\t \n\tl ^= bank->saved_datain;\n\tl &= bank->enabled_non_wakeup_gpios;\n\n\t \n\tgen0 = l & bank->context.fallingdetect;\n\tgen0 &= bank->saved_datain;\n\n\tgen1 = l & bank->context.risingdetect;\n\tgen1 &= ~(bank->saved_datain);\n\n\t \n\tgen = l & (~(bank->context.fallingdetect) &\n\t\t\t\t\t ~(bank->context.risingdetect));\n\t \n\tgen |= gen0 | gen1;\n\n\tif (gen) {\n\t\tu32 old0, old1;\n\n\t\told0 = readl_relaxed(bank->base + bank->regs->leveldetect0);\n\t\told1 = readl_relaxed(bank->base + bank->regs->leveldetect1);\n\n\t\tif (!bank->regs->irqstatus_raw0) {\n\t\t\twritel_relaxed(old0 | gen, bank->base +\n\t\t\t\t\t\tbank->regs->leveldetect0);\n\t\t\twritel_relaxed(old1 | gen, bank->base +\n\t\t\t\t\t\tbank->regs->leveldetect1);\n\t\t}\n\n\t\tif (bank->regs->irqstatus_raw0) {\n\t\t\twritel_relaxed(old0 | l, bank->base +\n\t\t\t\t\t\tbank->regs->leveldetect0);\n\t\t\twritel_relaxed(old1 | l, bank->base +\n\t\t\t\t\t\tbank->regs->leveldetect1);\n\t\t}\n\t\twritel_relaxed(old0, bank->base + bank->regs->leveldetect0);\n\t\twritel_relaxed(old1, bank->base + bank->regs->leveldetect1);\n\t}\n}\n\nstatic int gpio_omap_cpu_notifier(struct notifier_block *nb,\n\t\t\t\t  unsigned long cmd, void *v)\n{\n\tstruct gpio_bank *bank;\n\tunsigned long flags;\n\tint ret = NOTIFY_OK;\n\tu32 isr, mask;\n\n\tbank = container_of(nb, struct gpio_bank, nb);\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tif (bank->is_suspended)\n\t\tgoto out_unlock;\n\n\tswitch (cmd) {\n\tcase CPU_CLUSTER_PM_ENTER:\n\t\tmask = omap_get_gpio_irqbank_mask(bank);\n\t\tisr = readl_relaxed(bank->base + bank->regs->irqstatus) & mask;\n\t\tif (isr) {\n\t\t\tret = NOTIFY_BAD;\n\t\t\tbreak;\n\t\t}\n\t\tomap_gpio_idle(bank, true);\n\t\tbreak;\n\tcase CPU_CLUSTER_PM_ENTER_FAILED:\n\tcase CPU_CLUSTER_PM_EXIT:\n\t\tomap_gpio_unidle(bank);\n\t\tbreak;\n\t}\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct omap_gpio_reg_offs omap2_gpio_regs = {\n\t.revision =\t\tOMAP24XX_GPIO_REVISION,\n\t.sysconfig =\t\tOMAP24XX_GPIO_SYSCONFIG,\n\t.direction =\t\tOMAP24XX_GPIO_OE,\n\t.datain =\t\tOMAP24XX_GPIO_DATAIN,\n\t.dataout =\t\tOMAP24XX_GPIO_DATAOUT,\n\t.set_dataout =\t\tOMAP24XX_GPIO_SETDATAOUT,\n\t.clr_dataout =\t\tOMAP24XX_GPIO_CLEARDATAOUT,\n\t.irqstatus =\t\tOMAP24XX_GPIO_IRQSTATUS1,\n\t.irqstatus2 =\t\tOMAP24XX_GPIO_IRQSTATUS2,\n\t.irqenable =\t\tOMAP24XX_GPIO_IRQENABLE1,\n\t.irqenable2 =\t\tOMAP24XX_GPIO_IRQENABLE2,\n\t.set_irqenable =\tOMAP24XX_GPIO_SETIRQENABLE1,\n\t.clr_irqenable =\tOMAP24XX_GPIO_CLEARIRQENABLE1,\n\t.debounce =\t\tOMAP24XX_GPIO_DEBOUNCE_VAL,\n\t.debounce_en =\t\tOMAP24XX_GPIO_DEBOUNCE_EN,\n\t.ctrl =\t\t\tOMAP24XX_GPIO_CTRL,\n\t.wkup_en =\t\tOMAP24XX_GPIO_WAKE_EN,\n\t.leveldetect0 =\t\tOMAP24XX_GPIO_LEVELDETECT0,\n\t.leveldetect1 =\t\tOMAP24XX_GPIO_LEVELDETECT1,\n\t.risingdetect =\t\tOMAP24XX_GPIO_RISINGDETECT,\n\t.fallingdetect =\tOMAP24XX_GPIO_FALLINGDETECT,\n};\n\nstatic const struct omap_gpio_reg_offs omap4_gpio_regs = {\n\t.revision =\t\tOMAP4_GPIO_REVISION,\n\t.sysconfig =\t\tOMAP4_GPIO_SYSCONFIG,\n\t.direction =\t\tOMAP4_GPIO_OE,\n\t.datain =\t\tOMAP4_GPIO_DATAIN,\n\t.dataout =\t\tOMAP4_GPIO_DATAOUT,\n\t.set_dataout =\t\tOMAP4_GPIO_SETDATAOUT,\n\t.clr_dataout =\t\tOMAP4_GPIO_CLEARDATAOUT,\n\t.irqstatus =\t\tOMAP4_GPIO_IRQSTATUS0,\n\t.irqstatus2 =\t\tOMAP4_GPIO_IRQSTATUS1,\n\t.irqstatus_raw0 =\tOMAP4_GPIO_IRQSTATUSRAW0,\n\t.irqstatus_raw1 =\tOMAP4_GPIO_IRQSTATUSRAW1,\n\t.irqenable =\t\tOMAP4_GPIO_IRQSTATUSSET0,\n\t.irqenable2 =\t\tOMAP4_GPIO_IRQSTATUSSET1,\n\t.set_irqenable =\tOMAP4_GPIO_IRQSTATUSSET0,\n\t.clr_irqenable =\tOMAP4_GPIO_IRQSTATUSCLR0,\n\t.debounce =\t\tOMAP4_GPIO_DEBOUNCINGTIME,\n\t.debounce_en =\t\tOMAP4_GPIO_DEBOUNCENABLE,\n\t.ctrl =\t\t\tOMAP4_GPIO_CTRL,\n\t.wkup_en =\t\tOMAP4_GPIO_IRQWAKEN0,\n\t.leveldetect0 =\t\tOMAP4_GPIO_LEVELDETECT0,\n\t.leveldetect1 =\t\tOMAP4_GPIO_LEVELDETECT1,\n\t.risingdetect =\t\tOMAP4_GPIO_RISINGDETECT,\n\t.fallingdetect =\tOMAP4_GPIO_FALLINGDETECT,\n};\n\nstatic const struct omap_gpio_platform_data omap2_pdata = {\n\t.regs = &omap2_gpio_regs,\n\t.bank_width = 32,\n\t.dbck_flag = false,\n};\n\nstatic const struct omap_gpio_platform_data omap3_pdata = {\n\t.regs = &omap2_gpio_regs,\n\t.bank_width = 32,\n\t.dbck_flag = true,\n};\n\nstatic const struct omap_gpio_platform_data omap4_pdata = {\n\t.regs = &omap4_gpio_regs,\n\t.bank_width = 32,\n\t.dbck_flag = true,\n};\n\nstatic const struct of_device_id omap_gpio_match[] = {\n\t{\n\t\t.compatible = \"ti,omap4-gpio\",\n\t\t.data = &omap4_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,omap3-gpio\",\n\t\t.data = &omap3_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,omap2-gpio\",\n\t\t.data = &omap2_pdata,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, omap_gpio_match);\n\nstatic int omap_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tconst struct omap_gpio_platform_data *pdata;\n\tstruct gpio_bank *bank;\n\tint ret;\n\n\tpdata = device_get_match_data(dev);\n\n\tpdata = pdata ?: dev_get_platdata(dev);\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tbank = devm_kzalloc(dev, sizeof(*bank), GFP_KERNEL);\n\tif (!bank)\n\t\treturn -ENOMEM;\n\n\tbank->dev = dev;\n\n\tbank->irq = platform_get_irq(pdev, 0);\n\tif (bank->irq < 0)\n\t\treturn bank->irq;\n\n\tbank->chip.parent = dev;\n\tbank->chip.owner = THIS_MODULE;\n\tbank->dbck_flag = pdata->dbck_flag;\n\tbank->stride = pdata->bank_stride;\n\tbank->width = pdata->bank_width;\n\tbank->is_mpuio = pdata->is_mpuio;\n\tbank->non_wakeup_gpios = pdata->non_wakeup_gpios;\n\tbank->regs = pdata->regs;\n\n\tif (node) {\n\t\tif (!of_property_read_bool(node, \"ti,gpio-always-on\"))\n\t\t\tbank->loses_context = true;\n\t} else {\n\t\tbank->loses_context = pdata->loses_context;\n\n\t\tif (bank->loses_context)\n\t\t\tbank->get_context_loss_count =\n\t\t\t\tpdata->get_context_loss_count;\n\t}\n\n\tif (bank->regs->set_dataout && bank->regs->clr_dataout)\n\t\tbank->set_dataout = omap_set_gpio_dataout_reg;\n\telse\n\t\tbank->set_dataout = omap_set_gpio_dataout_mask;\n\n\traw_spin_lock_init(&bank->lock);\n\traw_spin_lock_init(&bank->wa_lock);\n\n\t \n\tbank->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(bank->base)) {\n\t\treturn PTR_ERR(bank->base);\n\t}\n\n\tif (bank->dbck_flag) {\n\t\tbank->dbck = devm_clk_get(dev, \"dbclk\");\n\t\tif (IS_ERR(bank->dbck)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Could not get gpio dbck. Disable debounce\\n\");\n\t\t\tbank->dbck_flag = false;\n\t\t} else {\n\t\t\tclk_prepare(bank->dbck);\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, bank);\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\tif (bank->is_mpuio)\n\t\tomap_mpuio_init(bank);\n\n\tomap_gpio_mod_init(bank);\n\n\tret = omap_gpio_chip_init(bank, dev);\n\tif (ret) {\n\t\tpm_runtime_put_sync(dev);\n\t\tpm_runtime_disable(dev);\n\t\tif (bank->dbck_flag)\n\t\t\tclk_unprepare(bank->dbck);\n\t\treturn ret;\n\t}\n\n\tomap_gpio_show_rev(bank);\n\n\tbank->nb.notifier_call = gpio_omap_cpu_notifier;\n\tcpu_pm_register_notifier(&bank->nb);\n\n\tpm_runtime_put(dev);\n\n\treturn 0;\n}\n\nstatic int omap_gpio_remove(struct platform_device *pdev)\n{\n\tstruct gpio_bank *bank = platform_get_drvdata(pdev);\n\n\tcpu_pm_unregister_notifier(&bank->nb);\n\tgpiochip_remove(&bank->chip);\n\tpm_runtime_disable(&pdev->dev);\n\tif (bank->dbck_flag)\n\t\tclk_unprepare(bank->dbck);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused omap_gpio_runtime_suspend(struct device *dev)\n{\n\tstruct gpio_bank *bank = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tomap_gpio_idle(bank, true);\n\tbank->is_suspended = true;\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused omap_gpio_runtime_resume(struct device *dev)\n{\n\tstruct gpio_bank *bank = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&bank->lock, flags);\n\tomap_gpio_unidle(bank);\n\tbank->is_suspended = false;\n\traw_spin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused omap_gpio_suspend(struct device *dev)\n{\n\tstruct gpio_bank *bank = dev_get_drvdata(dev);\n\n\tif (bank->is_suspended)\n\t\treturn 0;\n\n\tbank->needs_resume = 1;\n\n\treturn omap_gpio_runtime_suspend(dev);\n}\n\nstatic int __maybe_unused omap_gpio_resume(struct device *dev)\n{\n\tstruct gpio_bank *bank = dev_get_drvdata(dev);\n\n\tif (!bank->needs_resume)\n\t\treturn 0;\n\n\tbank->needs_resume = 0;\n\n\treturn omap_gpio_runtime_resume(dev);\n}\n\nstatic const struct dev_pm_ops gpio_pm_ops = {\n\tSET_RUNTIME_PM_OPS(omap_gpio_runtime_suspend, omap_gpio_runtime_resume,\n\t\t\t\t\t\t\t\t\tNULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(omap_gpio_suspend, omap_gpio_resume)\n};\n\nstatic struct platform_driver omap_gpio_driver = {\n\t.probe\t\t= omap_gpio_probe,\n\t.remove\t\t= omap_gpio_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"omap_gpio\",\n\t\t.pm\t= &gpio_pm_ops,\n\t\t.of_match_table = omap_gpio_match,\n\t},\n};\n\n \nstatic int __init omap_gpio_drv_reg(void)\n{\n\treturn platform_driver_register(&omap_gpio_driver);\n}\npostcore_initcall(omap_gpio_drv_reg);\n\nstatic void __exit omap_gpio_exit(void)\n{\n\tplatform_driver_unregister(&omap_gpio_driver);\n}\nmodule_exit(omap_gpio_exit);\n\nMODULE_DESCRIPTION(\"omap gpio driver\");\nMODULE_ALIAS(\"platform:gpio-omap\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}