{
  "module_name": "gpio-ich.c",
  "hash_id": "22392ff0afb237b312442b924d6daa6ee9cf279d7c5e02d5ca5f4f19deaccae9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-ich.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/ioport.h>\n#include <linux/mfd/lpc_ich.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#define DRV_NAME \"gpio_ich\"\n\n \nenum GPIO_REG {\n\tGPIO_USE_SEL = 0,\n\tGPIO_IO_SEL,\n\tGPIO_LVL,\n\tGPO_BLINK\n};\n\nstatic const u8 ichx_regs[4][3] = {\n\t{0x00, 0x30, 0x40},\t \n\t{0x04, 0x34, 0x44},\t \n\t{0x0c, 0x38, 0x48},\t \n\t{0x18, 0x18, 0x18},\t \n};\n\nstatic const u8 ichx_reglen[3] = {\n\t0x30, 0x10, 0x10,\n};\n\nstatic const u8 avoton_regs[4][3] = {\n\t{0x00, 0x80, 0x00},\n\t{0x04, 0x84, 0x00},\n\t{0x08, 0x88, 0x00},\n};\n\nstatic const u8 avoton_reglen[3] = {\n\t0x10, 0x10, 0x00,\n};\n\n#define ICHX_WRITE(val, reg, base_res)\toutl(val, (reg) + (base_res)->start)\n#define ICHX_READ(reg, base_res)\tinl((reg) + (base_res)->start)\n\nstruct ichx_desc {\n\t \n\tuint ngpio;\n\n\t \n\tconst u8 (*regs)[3];\n\tconst u8 *reglen;\n\n\t \n\tbool have_blink;\n\n\t \n\tbool uses_gpe0;\n\n\t \n\tu32 use_sel_ignore[3];\n\n\t \n\tint (*request)(struct gpio_chip *chip, unsigned int offset);\n\tint (*get)(struct gpio_chip *chip, unsigned int offset);\n\n\t \n\tbool use_outlvl_cache;\n};\n\nstatic struct {\n\tspinlock_t lock;\n\tstruct device *dev;\n\tstruct gpio_chip chip;\n\tstruct resource *gpio_base;\t \n\tstruct resource *pm_base;\t \n\tstruct ichx_desc *desc;\t \n\tu32 orig_gpio_ctrl;\t \n\tu8 use_gpio;\t\t \n\tint outlvl_cache[3];\t \n} ichx_priv;\n\nstatic int modparam_gpiobase = -1;\t \nmodule_param_named(gpiobase, modparam_gpiobase, int, 0444);\nMODULE_PARM_DESC(gpiobase, \"The GPIO number base. -1 means dynamic, which is the default.\");\n\nstatic int ichx_write_bit(int reg, unsigned int nr, int val, int verify)\n{\n\tunsigned long flags;\n\tu32 data, tmp;\n\tint reg_nr = nr / 32;\n\tint bit = nr & 0x1f;\n\n\tspin_lock_irqsave(&ichx_priv.lock, flags);\n\n\tif (reg == GPIO_LVL && ichx_priv.desc->use_outlvl_cache)\n\t\tdata = ichx_priv.outlvl_cache[reg_nr];\n\telse\n\t\tdata = ICHX_READ(ichx_priv.desc->regs[reg][reg_nr],\n\t\t\t\t ichx_priv.gpio_base);\n\n\tif (val)\n\t\tdata |= BIT(bit);\n\telse\n\t\tdata &= ~BIT(bit);\n\tICHX_WRITE(data, ichx_priv.desc->regs[reg][reg_nr],\n\t\t\t ichx_priv.gpio_base);\n\tif (reg == GPIO_LVL && ichx_priv.desc->use_outlvl_cache)\n\t\tichx_priv.outlvl_cache[reg_nr] = data;\n\n\ttmp = ICHX_READ(ichx_priv.desc->regs[reg][reg_nr],\n\t\t\tichx_priv.gpio_base);\n\n\tspin_unlock_irqrestore(&ichx_priv.lock, flags);\n\n\treturn (verify && data != tmp) ? -EPERM : 0;\n}\n\nstatic int ichx_read_bit(int reg, unsigned int nr)\n{\n\tunsigned long flags;\n\tu32 data;\n\tint reg_nr = nr / 32;\n\tint bit = nr & 0x1f;\n\n\tspin_lock_irqsave(&ichx_priv.lock, flags);\n\n\tdata = ICHX_READ(ichx_priv.desc->regs[reg][reg_nr],\n\t\t\t ichx_priv.gpio_base);\n\n\tif (reg == GPIO_LVL && ichx_priv.desc->use_outlvl_cache)\n\t\tdata = ichx_priv.outlvl_cache[reg_nr] | data;\n\n\tspin_unlock_irqrestore(&ichx_priv.lock, flags);\n\n\treturn !!(data & BIT(bit));\n}\n\nstatic bool ichx_gpio_check_available(struct gpio_chip *gpio, unsigned int nr)\n{\n\treturn !!(ichx_priv.use_gpio & BIT(nr / 32));\n}\n\nstatic int ichx_gpio_get_direction(struct gpio_chip *gpio, unsigned int nr)\n{\n\tif (ichx_read_bit(GPIO_IO_SEL, nr))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int ichx_gpio_direction_input(struct gpio_chip *gpio, unsigned int nr)\n{\n\t \n\treturn ichx_write_bit(GPIO_IO_SEL, nr, 1, 1);\n}\n\nstatic int ichx_gpio_direction_output(struct gpio_chip *gpio, unsigned int nr,\n\t\t\t\t\tint val)\n{\n\t \n\tif (nr < 32 && ichx_priv.desc->have_blink)\n\t\tichx_write_bit(GPO_BLINK, nr, 0, 0);\n\n\t \n\tichx_write_bit(GPIO_LVL, nr, val, 0);\n\n\t \n\treturn ichx_write_bit(GPIO_IO_SEL, nr, 0, 1);\n}\n\nstatic int ichx_gpio_get(struct gpio_chip *chip, unsigned int nr)\n{\n\treturn ichx_read_bit(GPIO_LVL, nr);\n}\n\nstatic int ich6_gpio_get(struct gpio_chip *chip, unsigned int nr)\n{\n\tunsigned long flags;\n\tu32 data;\n\n\t \n\tif (nr < 16) {\n\t\tif (!ichx_priv.pm_base)\n\t\t\treturn -ENXIO;\n\n\t\tspin_lock_irqsave(&ichx_priv.lock, flags);\n\n\t\t \n\t\tICHX_WRITE(BIT(16 + nr), 0, ichx_priv.pm_base);\n\t\tdata = ICHX_READ(0, ichx_priv.pm_base);\n\n\t\tspin_unlock_irqrestore(&ichx_priv.lock, flags);\n\n\t\treturn !!((data >> 16) & BIT(nr));\n\t} else {\n\t\treturn ichx_gpio_get(chip, nr);\n\t}\n}\n\nstatic int ichx_gpio_request(struct gpio_chip *chip, unsigned int nr)\n{\n\tif (!ichx_gpio_check_available(chip, nr))\n\t\treturn -ENXIO;\n\n\t \n\tif (ichx_priv.desc->use_sel_ignore[nr / 32] & BIT(nr & 0x1f))\n\t\treturn 0;\n\n\treturn ichx_read_bit(GPIO_USE_SEL, nr) ? 0 : -ENODEV;\n}\n\nstatic int ich6_gpio_request(struct gpio_chip *chip, unsigned int nr)\n{\n\t \n\tif (nr == 16 || nr == 17)\n\t\tnr -= 16;\n\n\treturn ichx_gpio_request(chip, nr);\n}\n\nstatic void ichx_gpio_set(struct gpio_chip *chip, unsigned int nr, int val)\n{\n\tichx_write_bit(GPIO_LVL, nr, val, 0);\n}\n\nstatic void ichx_gpiolib_setup(struct gpio_chip *chip)\n{\n\tchip->owner = THIS_MODULE;\n\tchip->label = DRV_NAME;\n\tchip->parent = ichx_priv.dev;\n\n\t \n\tchip->request = ichx_priv.desc->request ?\n\t\tichx_priv.desc->request : ichx_gpio_request;\n\tchip->get = ichx_priv.desc->get ?\n\t\tichx_priv.desc->get : ichx_gpio_get;\n\n\tchip->set = ichx_gpio_set;\n\tchip->get_direction = ichx_gpio_get_direction;\n\tchip->direction_input = ichx_gpio_direction_input;\n\tchip->direction_output = ichx_gpio_direction_output;\n\tchip->base = modparam_gpiobase;\n\tchip->ngpio = ichx_priv.desc->ngpio;\n\tchip->can_sleep = false;\n\tchip->dbg_show = NULL;\n}\n\n \nstatic struct ichx_desc ich6_desc = {\n\t \n\t.request = ich6_gpio_request,\n\t.get = ich6_gpio_get,\n\n\t \n\t.uses_gpe0 = true,\n\n\t.ngpio = 50,\n\t.have_blink = true,\n\t.regs = ichx_regs,\n\t.reglen = ichx_reglen,\n};\n\n \nstatic struct ichx_desc i3100_desc = {\n\t \n\t.use_sel_ignore = {0x00130000, 0x00010000, 0x0},\n\n\t \n\t.request = ich6_gpio_request,\n\t.get = ich6_gpio_get,\n\n\t \n\t.uses_gpe0 = true,\n\n\t.ngpio = 50,\n\t.regs = ichx_regs,\n\t.reglen = ichx_reglen,\n};\n\n \nstatic struct ichx_desc ich7_desc = {\n\t.ngpio = 50,\n\t.have_blink = true,\n\t.regs = ichx_regs,\n\t.reglen = ichx_reglen,\n};\n\n \nstatic struct ichx_desc ich9_desc = {\n\t.ngpio = 61,\n\t.have_blink = true,\n\t.regs = ichx_regs,\n\t.reglen = ichx_reglen,\n};\n\n \nstatic struct ichx_desc ich10_cons_desc = {\n\t.ngpio = 61,\n\t.have_blink = true,\n\t.regs = ichx_regs,\n\t.reglen = ichx_reglen,\n};\nstatic struct ichx_desc ich10_corp_desc = {\n\t.ngpio = 72,\n\t.have_blink = true,\n\t.regs = ichx_regs,\n\t.reglen = ichx_reglen,\n};\n\n \nstatic struct ichx_desc intel5_desc = {\n\t.ngpio = 76,\n\t.regs = ichx_regs,\n\t.reglen = ichx_reglen,\n};\n\n \nstatic struct ichx_desc avoton_desc = {\n\t \n\t.ngpio = 60,\n\t.regs = avoton_regs,\n\t.reglen = avoton_reglen,\n\t.use_outlvl_cache = true,\n};\n\nstatic int ichx_gpio_request_regions(struct device *dev,\n\tstruct resource *res_base, const char *name, u8 use_gpio)\n{\n\tint i;\n\n\tif (!res_base || !res_base->start || !res_base->end)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < ARRAY_SIZE(ichx_priv.desc->regs[0]); i++) {\n\t\tif (!(use_gpio & BIT(i)))\n\t\t\tcontinue;\n\t\tif (!devm_request_region(dev,\n\t\t\t\tres_base->start + ichx_priv.desc->regs[0][i],\n\t\t\t\tichx_priv.desc->reglen[i], name))\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int ichx_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct lpc_ich_info *ich_info = dev_get_platdata(dev);\n\tstruct resource *res_base, *res_pm;\n\tint err;\n\n\tif (!ich_info)\n\t\treturn -ENODEV;\n\n\tswitch (ich_info->gpio_version) {\n\tcase ICH_I3100_GPIO:\n\t\tichx_priv.desc = &i3100_desc;\n\t\tbreak;\n\tcase ICH_V5_GPIO:\n\t\tichx_priv.desc = &intel5_desc;\n\t\tbreak;\n\tcase ICH_V6_GPIO:\n\t\tichx_priv.desc = &ich6_desc;\n\t\tbreak;\n\tcase ICH_V7_GPIO:\n\t\tichx_priv.desc = &ich7_desc;\n\t\tbreak;\n\tcase ICH_V9_GPIO:\n\t\tichx_priv.desc = &ich9_desc;\n\t\tbreak;\n\tcase ICH_V10CORP_GPIO:\n\t\tichx_priv.desc = &ich10_corp_desc;\n\t\tbreak;\n\tcase ICH_V10CONS_GPIO:\n\t\tichx_priv.desc = &ich10_cons_desc;\n\t\tbreak;\n\tcase AVOTON_GPIO:\n\t\tichx_priv.desc = &avoton_desc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tichx_priv.dev = dev;\n\tspin_lock_init(&ichx_priv.lock);\n\n\tres_base = platform_get_resource(pdev, IORESOURCE_IO, ICH_RES_GPIO);\n\terr = ichx_gpio_request_regions(dev, res_base, pdev->name,\n\t\t\t\t\tich_info->use_gpio);\n\tif (err)\n\t\treturn err;\n\n\tichx_priv.gpio_base = res_base;\n\tichx_priv.use_gpio = ich_info->use_gpio;\n\n\t \n\tif (!ichx_priv.desc->uses_gpe0)\n\t\tgoto init;\n\n\tres_pm = platform_get_resource(pdev, IORESOURCE_IO, ICH_RES_GPE0);\n\tif (!res_pm) {\n\t\tdev_warn(dev, \"ACPI BAR is unavailable, GPI 0 - 15 unavailable\\n\");\n\t\tgoto init;\n\t}\n\n\tif (!devm_request_region(dev, res_pm->start, resource_size(res_pm),\n\t\t\t\t pdev->name)) {\n\t\tdev_warn(dev, \"ACPI BAR is busy, GPI 0 - 15 unavailable\\n\");\n\t\tgoto init;\n\t}\n\n\tichx_priv.pm_base = res_pm;\n\ninit:\n\tichx_gpiolib_setup(&ichx_priv.chip);\n\terr = devm_gpiochip_add_data(dev, &ichx_priv.chip, NULL);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register GPIOs\\n\");\n\t\treturn err;\n\t}\n\n\tdev_info(dev, \"GPIO from %d to %d\\n\", ichx_priv.chip.base,\n\t\t ichx_priv.chip.base + ichx_priv.chip.ngpio - 1);\n\n\treturn 0;\n}\n\nstatic struct platform_driver ichx_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t},\n\t.probe\t\t= ichx_gpio_probe,\n};\n\nmodule_platform_driver(ichx_gpio_driver);\n\nMODULE_AUTHOR(\"Peter Tyser <ptyser@xes-inc.com>\");\nMODULE_DESCRIPTION(\"GPIO interface for Intel ICH series\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\"DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}