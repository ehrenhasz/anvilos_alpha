{
  "module_name": "gpio-tps65219.c",
  "hash_id": "418c96e3a4730abd4f822fdfd9403a8c5dada6dd231b45afc027c201a7af6a8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-tps65219.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/gpio/driver.h>\n#include <linux/mfd/tps65219.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define TPS65219_GPIO0_DIR_MASK\t\tBIT(3)\n#define TPS65219_GPIO0_OFFSET\t\t2\n#define TPS65219_GPIO0_IDX\t\t0\n#define TPS65219_GPIO_DIR_IN\t\t1\n#define TPS65219_GPIO_DIR_OUT\t\t0\n\nstruct tps65219_gpio {\n\tstruct gpio_chip gpio_chip;\n\tstruct tps65219 *tps;\n};\n\nstatic int tps65219_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct tps65219_gpio *gpio = gpiochip_get_data(gc);\n\tint ret, val;\n\n\tif (offset != TPS65219_GPIO0_IDX)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\tret = regmap_read(gpio->tps->regmap, TPS65219_REG_MFP_1_CONFIG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & TPS65219_GPIO0_DIR_MASK);\n}\n\nstatic int tps65219_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct tps65219_gpio *gpio = gpiochip_get_data(gc);\n\tstruct device *dev = gpio->tps->dev;\n\tint ret, val;\n\n\tif (offset != TPS65219_GPIO0_IDX) {\n\t\tdev_err(dev, \"GPIO%d is output only, cannot get\\n\", offset);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tret = regmap_read(gpio->tps->regmap, TPS65219_REG_MFP_CTRL, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = !!(val & BIT(TPS65219_MFP_GPIO_STATUS_MASK));\n\tdev_warn(dev, \"GPIO%d = %d, MULTI_DEVICE_ENABLE, not a standard GPIO\\n\", offset, ret);\n\n\t \n\n\tif (tps65219_gpio_get_direction(gc, offset) == TPS65219_GPIO_DIR_OUT)\n\t\treturn -ENOTSUPP;\n\n\treturn ret;\n}\n\nstatic void tps65219_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)\n{\n\tstruct tps65219_gpio *gpio = gpiochip_get_data(gc);\n\tstruct device *dev = gpio->tps->dev;\n\tint v, mask, bit;\n\n\tbit = (offset == TPS65219_GPIO0_IDX) ? TPS65219_GPIO0_OFFSET : offset - 1;\n\n\tmask = BIT(bit);\n\tv = value ? mask : 0;\n\n\tif (regmap_update_bits(gpio->tps->regmap, TPS65219_REG_GENERAL_CONFIG, mask, v))\n\t\tdev_err(dev, \"GPIO%d, set to value %d failed.\\n\", offset, value);\n}\n\nstatic int tps65219_gpio_change_direction(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\t\t  unsigned int direction)\n{\n\tstruct tps65219_gpio *gpio = gpiochip_get_data(gc);\n\tstruct device *dev = gpio->tps->dev;\n\n\t \n\n\tif (IS_ENABLED(CONFIG_DEBUG_GPIO)) {\n\t\tint ret = regmap_update_bits(gpio->tps->regmap, TPS65219_REG_MFP_1_CONFIG,\n\t\t\t\t\t     TPS65219_GPIO0_DIR_MASK, direction);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"GPIO DEBUG enabled: Fail to change direction to %u for GPIO%d.\\n\",\n\t\t\t\tdirection, offset);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev_err(dev,\n\t\t\"GPIO%d direction set by NVM, change to %u failed, not allowed by specification\\n\",\n\t\t offset, direction);\n\n\treturn -ENOTSUPP;\n}\n\nstatic int tps65219_gpio_direction_input(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct tps65219_gpio *gpio = gpiochip_get_data(gc);\n\tstruct device *dev = gpio->tps->dev;\n\n\tif (offset != TPS65219_GPIO0_IDX) {\n\t\tdev_err(dev, \"GPIO%d is output only, cannot change to input\\n\", offset);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (tps65219_gpio_get_direction(gc, offset) == TPS65219_GPIO_DIR_IN)\n\t\treturn 0;\n\n\treturn tps65219_gpio_change_direction(gc, offset, TPS65219_GPIO_DIR_IN);\n}\n\nstatic int tps65219_gpio_direction_output(struct gpio_chip *gc, unsigned int offset, int value)\n{\n\ttps65219_gpio_set(gc, offset, value);\n\tif (offset != TPS65219_GPIO0_IDX)\n\t\treturn 0;\n\n\tif (tps65219_gpio_get_direction(gc, offset) == TPS65219_GPIO_DIR_OUT)\n\t\treturn 0;\n\n\treturn tps65219_gpio_change_direction(gc, offset, TPS65219_GPIO_DIR_OUT);\n}\n\nstatic const struct gpio_chip tps65219_template_chip = {\n\t.label\t\t\t= \"tps65219-gpio\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.get_direction\t\t= tps65219_gpio_get_direction,\n\t.direction_input\t= tps65219_gpio_direction_input,\n\t.direction_output\t= tps65219_gpio_direction_output,\n\t.get\t\t\t= tps65219_gpio_get,\n\t.set\t\t\t= tps65219_gpio_set,\n\t.base\t\t\t= -1,\n\t.ngpio\t\t\t= 3,\n\t.can_sleep\t\t= true,\n};\n\nstatic int tps65219_gpio_probe(struct platform_device *pdev)\n{\n\tstruct tps65219 *tps = dev_get_drvdata(pdev->dev.parent);\n\tstruct tps65219_gpio *gpio;\n\n\tgpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tgpio->tps = tps;\n\tgpio->gpio_chip = tps65219_template_chip;\n\tgpio->gpio_chip.parent = tps->dev;\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &gpio->gpio_chip, gpio);\n}\n\nstatic struct platform_driver tps65219_gpio_driver = {\n\t.driver = {\n\t\t.name = \"tps65219-gpio\",\n\t},\n\t.probe = tps65219_gpio_probe,\n};\nmodule_platform_driver(tps65219_gpio_driver);\n\nMODULE_ALIAS(\"platform:tps65219-gpio\");\nMODULE_AUTHOR(\"Jonathan Cormier <jcormier@criticallink.com>\");\nMODULE_DESCRIPTION(\"TPS65219 GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}