{
  "module_name": "gpio-mlxbf2.c",
  "hash_id": "8809e2329095182d4fc5d2bfb4c63b28e60f34ce25e5e3ab6b2622ea74c207c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mlxbf2.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/resource.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n \n#define MLXBF2_GPIO_MAX_PINS_PER_BLOCK 32\n\n \n#define YU_ARM_GPIO_LOCK_ADDR\t\t0x2801088\n#define YU_ARM_GPIO_LOCK_SIZE\t\t0x8\n#define YU_LOCK_ACTIVE_BIT(val)\t\t(val >> 31)\n#define YU_ARM_GPIO_LOCK_ACQUIRE\t0xd42f\n#define YU_ARM_GPIO_LOCK_RELEASE\t0x0\n\n \n#define YU_GPIO_DATAIN\t\t\t0x04\n#define YU_GPIO_MODE1\t\t\t0x08\n#define YU_GPIO_MODE0\t\t\t0x0c\n#define YU_GPIO_DATASET\t\t\t0x14\n#define YU_GPIO_DATACLEAR\t\t0x18\n#define YU_GPIO_CAUSE_RISE_EN\t\t0x44\n#define YU_GPIO_CAUSE_FALL_EN\t\t0x48\n#define YU_GPIO_MODE1_CLEAR\t\t0x50\n#define YU_GPIO_MODE0_SET\t\t0x54\n#define YU_GPIO_MODE0_CLEAR\t\t0x58\n#define YU_GPIO_CAUSE_OR_CAUSE_EVTEN0\t0x80\n#define YU_GPIO_CAUSE_OR_EVTEN0\t\t0x94\n#define YU_GPIO_CAUSE_OR_CLRCAUSE\t0x98\n\nstruct mlxbf2_gpio_context_save_regs {\n\tu32 gpio_mode0;\n\tu32 gpio_mode1;\n};\n\n \nstruct mlxbf2_gpio_context {\n\tstruct gpio_chip gc;\n\n\t \n\tvoid __iomem *gpio_io;\n\tstruct device *dev;\n\n\tstruct mlxbf2_gpio_context_save_regs *csave_regs;\n};\n\n \nstruct mlxbf2_gpio_param {\n\tvoid __iomem *io;\n\tstruct resource *res;\n\tstruct mutex *lock;\n};\n\nstatic struct resource yu_arm_gpio_lock_res =\n\tDEFINE_RES_MEM_NAMED(YU_ARM_GPIO_LOCK_ADDR, YU_ARM_GPIO_LOCK_SIZE, \"YU_ARM_GPIO_LOCK\");\n\nstatic DEFINE_MUTEX(yu_arm_gpio_lock_mutex);\n\nstatic struct mlxbf2_gpio_param yu_arm_gpio_lock_param = {\n\t.res = &yu_arm_gpio_lock_res,\n\t.lock = &yu_arm_gpio_lock_mutex,\n};\n\n \nstatic int mlxbf2_gpio_get_lock_res(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tresource_size_t size;\n\tint ret = 0;\n\n\tmutex_lock(yu_arm_gpio_lock_param.lock);\n\n\t \n\tif (yu_arm_gpio_lock_param.io)\n\t\tgoto exit;\n\n\tres = yu_arm_gpio_lock_param.res;\n\tsize = resource_size(res);\n\n\tif (!devm_request_mem_region(dev, res->start, size, res->name)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tyu_arm_gpio_lock_param.io = devm_ioremap(dev, res->start, size);\n\tif (!yu_arm_gpio_lock_param.io)\n\t\tret = -ENOMEM;\n\nexit:\n\tmutex_unlock(yu_arm_gpio_lock_param.lock);\n\n\treturn ret;\n}\n\n \nstatic int mlxbf2_gpio_lock_acquire(struct mlxbf2_gpio_context *gs)\n{\n\tu32 arm_gpio_lock_val;\n\n\tmutex_lock(yu_arm_gpio_lock_param.lock);\n\traw_spin_lock(&gs->gc.bgpio_lock);\n\n\tarm_gpio_lock_val = readl(yu_arm_gpio_lock_param.io);\n\n\t \n\tif (YU_LOCK_ACTIVE_BIT(arm_gpio_lock_val)) {\n\t\traw_spin_unlock(&gs->gc.bgpio_lock);\n\t\tmutex_unlock(yu_arm_gpio_lock_param.lock);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(YU_ARM_GPIO_LOCK_ACQUIRE, yu_arm_gpio_lock_param.io);\n\n\treturn 0;\n}\n\n \nstatic void mlxbf2_gpio_lock_release(struct mlxbf2_gpio_context *gs)\n\t__releases(&gs->gc.bgpio_lock)\n\t__releases(yu_arm_gpio_lock_param.lock)\n{\n\twritel(YU_ARM_GPIO_LOCK_RELEASE, yu_arm_gpio_lock_param.io);\n\traw_spin_unlock(&gs->gc.bgpio_lock);\n\tmutex_unlock(yu_arm_gpio_lock_param.lock);\n}\n\n \n\n \nstatic int mlxbf2_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset)\n{\n\tstruct mlxbf2_gpio_context *gs = gpiochip_get_data(chip);\n\tint ret;\n\n\t \n\tret = mlxbf2_gpio_lock_acquire(gs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel(BIT(offset), gs->gpio_io + YU_GPIO_MODE0_CLEAR);\n\twritel(BIT(offset), gs->gpio_io + YU_GPIO_MODE1_CLEAR);\n\n\tmlxbf2_gpio_lock_release(gs);\n\n\treturn ret;\n}\n\n \nstatic int mlxbf2_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int offset,\n\t\t\t\t\tint value)\n{\n\tstruct mlxbf2_gpio_context *gs = gpiochip_get_data(chip);\n\tint ret = 0;\n\n\t \n\tret = mlxbf2_gpio_lock_acquire(gs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel(BIT(offset), gs->gpio_io + YU_GPIO_MODE1_CLEAR);\n\twritel(BIT(offset), gs->gpio_io + YU_GPIO_MODE0_SET);\n\n\tmlxbf2_gpio_lock_release(gs);\n\n\treturn ret;\n}\n\nstatic void mlxbf2_gpio_irq_enable(struct irq_data *irqd)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct mlxbf2_gpio_context *gs = gpiochip_get_data(gc);\n\tint offset = irqd_to_hwirq(irqd);\n\tunsigned long flags;\n\tu32 val;\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(irqd));\n\traw_spin_lock_irqsave(&gs->gc.bgpio_lock, flags);\n\tval = readl(gs->gpio_io + YU_GPIO_CAUSE_OR_CLRCAUSE);\n\tval |= BIT(offset);\n\twritel(val, gs->gpio_io + YU_GPIO_CAUSE_OR_CLRCAUSE);\n\n\tval = readl(gs->gpio_io + YU_GPIO_CAUSE_OR_EVTEN0);\n\tval |= BIT(offset);\n\twritel(val, gs->gpio_io + YU_GPIO_CAUSE_OR_EVTEN0);\n\traw_spin_unlock_irqrestore(&gs->gc.bgpio_lock, flags);\n}\n\nstatic void mlxbf2_gpio_irq_disable(struct irq_data *irqd)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct mlxbf2_gpio_context *gs = gpiochip_get_data(gc);\n\tint offset = irqd_to_hwirq(irqd);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&gs->gc.bgpio_lock, flags);\n\tval = readl(gs->gpio_io + YU_GPIO_CAUSE_OR_EVTEN0);\n\tval &= ~BIT(offset);\n\twritel(val, gs->gpio_io + YU_GPIO_CAUSE_OR_EVTEN0);\n\traw_spin_unlock_irqrestore(&gs->gc.bgpio_lock, flags);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(irqd));\n}\n\nstatic irqreturn_t mlxbf2_gpio_irq_handler(int irq, void *ptr)\n{\n\tstruct mlxbf2_gpio_context *gs = ptr;\n\tstruct gpio_chip *gc = &gs->gc;\n\tunsigned long pending;\n\tu32 level;\n\n\tpending = readl(gs->gpio_io + YU_GPIO_CAUSE_OR_CAUSE_EVTEN0);\n\twritel(pending, gs->gpio_io + YU_GPIO_CAUSE_OR_CLRCAUSE);\n\n\tfor_each_set_bit(level, &pending, gc->ngpio)\n\t\tgeneric_handle_domain_irq_safe(gc->irq.domain, level);\n\n\treturn IRQ_RETVAL(pending);\n}\n\nstatic int\nmlxbf2_gpio_irq_set_type(struct irq_data *irqd, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct mlxbf2_gpio_context *gs = gpiochip_get_data(gc);\n\tint offset = irqd_to_hwirq(irqd);\n\tunsigned long flags;\n\tbool fall = false;\n\tbool rise = false;\n\tu32 val;\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tfall = true;\n\t\trise = true;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\trise = true;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tfall = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&gs->gc.bgpio_lock, flags);\n\tif (fall) {\n\t\tval = readl(gs->gpio_io + YU_GPIO_CAUSE_FALL_EN);\n\t\tval |= BIT(offset);\n\t\twritel(val, gs->gpio_io + YU_GPIO_CAUSE_FALL_EN);\n\t}\n\n\tif (rise) {\n\t\tval = readl(gs->gpio_io + YU_GPIO_CAUSE_RISE_EN);\n\t\tval |= BIT(offset);\n\t\twritel(val, gs->gpio_io + YU_GPIO_CAUSE_RISE_EN);\n\t}\n\traw_spin_unlock_irqrestore(&gs->gc.bgpio_lock, flags);\n\n\treturn 0;\n}\n\nstatic void mlxbf2_gpio_irq_print_chip(struct irq_data *irqd,\n\t\t\t\t       struct seq_file *p)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct mlxbf2_gpio_context *gs = gpiochip_get_data(gc);\n\n\tseq_printf(p, dev_name(gs->dev));\n}\n\nstatic const struct irq_chip mlxbf2_gpio_irq_chip = {\n\t.irq_set_type = mlxbf2_gpio_irq_set_type,\n\t.irq_enable = mlxbf2_gpio_irq_enable,\n\t.irq_disable = mlxbf2_gpio_irq_disable,\n\t.irq_print_chip = mlxbf2_gpio_irq_print_chip,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\n \nstatic int\nmlxbf2_gpio_probe(struct platform_device *pdev)\n{\n\tstruct mlxbf2_gpio_context *gs;\n\tstruct device *dev = &pdev->dev;\n\tstruct gpio_irq_chip *girq;\n\tstruct gpio_chip *gc;\n\tunsigned int npins;\n\tconst char *name;\n\tint ret, irq;\n\n\tname = dev_name(dev);\n\n\tgs = devm_kzalloc(dev, sizeof(*gs), GFP_KERNEL);\n\tif (!gs)\n\t\treturn -ENOMEM;\n\n\tgs->dev = dev;\n\n\t \n\tgs->gpio_io = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gs->gpio_io))\n\t\treturn PTR_ERR(gs->gpio_io);\n\n\tret = mlxbf2_gpio_get_lock_res(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get yu_arm_gpio_lock resource\\n\");\n\t\treturn ret;\n\t}\n\n\tif (device_property_read_u32(dev, \"npins\", &npins))\n\t\tnpins = MLXBF2_GPIO_MAX_PINS_PER_BLOCK;\n\n\tgc = &gs->gc;\n\n\tret = bgpio_init(gc, dev, 4,\n\t\t\tgs->gpio_io + YU_GPIO_DATAIN,\n\t\t\tgs->gpio_io + YU_GPIO_DATASET,\n\t\t\tgs->gpio_io + YU_GPIO_DATACLEAR,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\t0);\n\n\tif (ret) {\n\t\tdev_err(dev, \"bgpio_init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tgc->direction_input = mlxbf2_gpio_direction_input;\n\tgc->direction_output = mlxbf2_gpio_direction_output;\n\tgc->ngpio = npins;\n\tgc->owner = THIS_MODULE;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq >= 0) {\n\t\tgirq = &gs->gc.irq;\n\t\tgpio_irq_chip_set_chip(girq, &mlxbf2_gpio_irq_chip);\n\t\tgirq->handler = handle_simple_irq;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\t \n\t\tgirq->num_parents = 0;\n\t\tgirq->parents = NULL;\n\t\tgirq->parent_handler = NULL;\n\n\t\t \n\t\tret = devm_request_irq(dev, irq, mlxbf2_gpio_irq_handler,\n\t\t\t\t       IRQF_SHARED, name, gs);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to request IRQ\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, gs);\n\n\tret = devm_gpiochip_add_data(dev, &gs->gc, gs);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed adding memory mapped gpiochip\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mlxbf2_gpio_suspend(struct device *dev)\n{\n\tstruct mlxbf2_gpio_context *gs = dev_get_drvdata(dev);\n\n\tgs->csave_regs->gpio_mode0 = readl(gs->gpio_io +\n\t\tYU_GPIO_MODE0);\n\tgs->csave_regs->gpio_mode1 = readl(gs->gpio_io +\n\t\tYU_GPIO_MODE1);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mlxbf2_gpio_resume(struct device *dev)\n{\n\tstruct mlxbf2_gpio_context *gs = dev_get_drvdata(dev);\n\n\twritel(gs->csave_regs->gpio_mode0, gs->gpio_io +\n\t\tYU_GPIO_MODE0);\n\twritel(gs->csave_regs->gpio_mode1, gs->gpio_io +\n\t\tYU_GPIO_MODE1);\n\n\treturn 0;\n}\nstatic SIMPLE_DEV_PM_OPS(mlxbf2_pm_ops, mlxbf2_gpio_suspend, mlxbf2_gpio_resume);\n\nstatic const struct acpi_device_id __maybe_unused mlxbf2_gpio_acpi_match[] = {\n\t{ \"MLNXBF22\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, mlxbf2_gpio_acpi_match);\n\nstatic struct platform_driver mlxbf2_gpio_driver = {\n\t.driver = {\n\t\t.name = \"mlxbf2_gpio\",\n\t\t.acpi_match_table = mlxbf2_gpio_acpi_match,\n\t\t.pm = &mlxbf2_pm_ops,\n\t},\n\t.probe    = mlxbf2_gpio_probe,\n};\n\nmodule_platform_driver(mlxbf2_gpio_driver);\n\nMODULE_DESCRIPTION(\"Mellanox BlueField-2 GPIO Driver\");\nMODULE_AUTHOR(\"Asmaa Mnebhi <asmaa@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}