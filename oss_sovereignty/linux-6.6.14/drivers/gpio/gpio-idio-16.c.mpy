{
  "module_name": "gpio-idio-16.c",
  "hash_id": "45a68f84c08b3e4b1af4e0afb3ed085a81ea580f9c455a9508c260bd9eb5660c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-idio-16.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/gpio/regmap.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n#include \"gpio-idio-16.h\"\n\n#define DEFAULT_SYMBOL_NAMESPACE GPIO_IDIO_16\n\n#define IDIO_16_DAT_BASE 0x0\n#define IDIO_16_OUT_BASE IDIO_16_DAT_BASE\n#define IDIO_16_IN_BASE (IDIO_16_DAT_BASE + 1)\n#define IDIO_16_CLEAR_INTERRUPT 0x1\n#define IDIO_16_ENABLE_IRQ 0x2\n#define IDIO_16_DEACTIVATE_INPUT_FILTERS 0x3\n#define IDIO_16_DISABLE_IRQ IDIO_16_ENABLE_IRQ\n#define IDIO_16_INTERRUPT_STATUS 0x6\n\n#define IDIO_16_NGPIO 32\n#define IDIO_16_NGPIO_PER_REG 8\n#define IDIO_16_REG_STRIDE 4\n\nstruct idio_16_data {\n\tstruct regmap *map;\n\tunsigned int irq_mask;\n};\n\nstatic int idio_16_handle_mask_sync(const int index, const unsigned int mask_buf_def,\n\t\t\t\t    const unsigned int mask_buf, void *const irq_drv_data)\n{\n\tstruct idio_16_data *const data = irq_drv_data;\n\tconst unsigned int prev_mask = data->irq_mask;\n\tint err;\n\tunsigned int val;\n\n\t \n\tif (mask_buf == prev_mask)\n\t\treturn 0;\n\n\t \n\tdata->irq_mask = mask_buf;\n\n\t \n\tif (prev_mask == mask_buf_def) {\n\t\terr = regmap_write(data->map, IDIO_16_CLEAR_INTERRUPT, 0x00);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn regmap_read(data->map, IDIO_16_ENABLE_IRQ, &val);\n\t}\n\n\t \n\tif (mask_buf == mask_buf_def)\n\t\treturn regmap_write(data->map, IDIO_16_DISABLE_IRQ, 0x00);\n\n\treturn 0;\n}\n\nstatic int idio_16_reg_mask_xlate(struct gpio_regmap *const gpio, const unsigned int base,\n\t\t\t\t  const unsigned int offset, unsigned int *const reg,\n\t\t\t\t  unsigned int *const mask)\n{\n\tunsigned int stride;\n\n\t \n\tif (offset < 16) {\n\t\tstride = offset / IDIO_16_NGPIO_PER_REG;\n\t\t*reg = IDIO_16_OUT_BASE + stride * IDIO_16_REG_STRIDE;\n\t} else {\n\t\tstride = (offset - 16) / IDIO_16_NGPIO_PER_REG;\n\t\t*reg = IDIO_16_IN_BASE + stride * IDIO_16_REG_STRIDE;\n\t}\n\n\t*mask = BIT(offset % IDIO_16_NGPIO_PER_REG);\n\n\treturn 0;\n}\n\nstatic const char *idio_16_names[IDIO_16_NGPIO] = {\n\t\"OUT0\", \"OUT1\", \"OUT2\", \"OUT3\", \"OUT4\", \"OUT5\", \"OUT6\", \"OUT7\",\n\t\"OUT8\", \"OUT9\", \"OUT10\", \"OUT11\", \"OUT12\", \"OUT13\", \"OUT14\", \"OUT15\",\n\t\"IIN0\", \"IIN1\", \"IIN2\", \"IIN3\", \"IIN4\", \"IIN5\", \"IIN6\", \"IIN7\",\n\t\"IIN8\", \"IIN9\", \"IIN10\", \"IIN11\", \"IIN12\", \"IIN13\", \"IIN14\", \"IIN15\",\n};\n\n \nint devm_idio_16_regmap_register(struct device *const dev,\n\t\t\t\t const struct idio_16_regmap_config *const config)\n{\n\tstruct gpio_regmap_config gpio_config = {};\n\tint err;\n\tstruct idio_16_data *data;\n\tstruct regmap_irq_chip *chip;\n\tstruct regmap_irq_chip_data *chip_data;\n\n\tif (!config->parent)\n\t\treturn -EINVAL;\n\n\tif (!config->map)\n\t\treturn -EINVAL;\n\n\tif (!config->regmap_irqs)\n\t\treturn -EINVAL;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->map = config->map;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->name = dev_name(dev);\n\tchip->status_base = IDIO_16_INTERRUPT_STATUS;\n\tchip->mask_base = IDIO_16_ENABLE_IRQ;\n\tchip->ack_base = IDIO_16_CLEAR_INTERRUPT;\n\tchip->no_status = config->no_status;\n\tchip->num_regs = 1;\n\tchip->irqs = config->regmap_irqs;\n\tchip->num_irqs = config->num_regmap_irqs;\n\tchip->handle_mask_sync = idio_16_handle_mask_sync;\n\tchip->irq_drv_data = data;\n\n\t \n\terr = regmap_write(data->map, IDIO_16_DISABLE_IRQ, 0x00);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_regmap_add_irq_chip(dev, data->map, config->irq, 0, 0, chip, &chip_data);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"IRQ registration failed\\n\");\n\n\tif (config->filters) {\n\t\t \n\t\terr = regmap_write(data->map, IDIO_16_DEACTIVATE_INPUT_FILTERS, 0x00);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tgpio_config.parent = config->parent;\n\tgpio_config.regmap = data->map;\n\tgpio_config.ngpio = IDIO_16_NGPIO;\n\tgpio_config.names = idio_16_names;\n\tgpio_config.reg_dat_base = GPIO_REGMAP_ADDR(IDIO_16_DAT_BASE);\n\tgpio_config.reg_set_base = GPIO_REGMAP_ADDR(IDIO_16_DAT_BASE);\n\tgpio_config.ngpio_per_reg = IDIO_16_NGPIO_PER_REG;\n\tgpio_config.reg_stride = IDIO_16_REG_STRIDE;\n\tgpio_config.irq_domain = regmap_irq_get_domain(chip_data);\n\tgpio_config.reg_mask_xlate = idio_16_reg_mask_xlate;\n\n\treturn PTR_ERR_OR_ZERO(devm_gpio_regmap_register(dev, &gpio_config));\n}\nEXPORT_SYMBOL_GPL(devm_idio_16_regmap_register);\n\nMODULE_AUTHOR(\"William Breathitt Gray\");\nMODULE_DESCRIPTION(\"ACCES IDIO-16 GPIO Library\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}