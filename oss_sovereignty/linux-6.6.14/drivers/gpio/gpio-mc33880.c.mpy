{
  "module_name": "gpio-mc33880.c",
  "hash_id": "91c78158687a505885c2213befad733cc3305783f2f6be3fb5627704ccbfc4a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mc33880.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/mc33880.h>\n#include <linux/gpio/driver.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define DRIVER_NAME \"mc33880\"\n\n \n#define PIN_CONFIG_MASK 0x03\n#define PIN_CONFIG_IN_PULLUP 0x03\n#define PIN_CONFIG_IN_WO_PULLUP 0x02\n#define PIN_CONFIG_OUT 0x01\n\n#define PIN_NUMBER 8\n\n\n \nstruct mc33880 {\n\tstruct mutex\tlock;\t \n\tu8\t\tport_config;\n\tstruct gpio_chip chip;\n\tstruct spi_device *spi;\n};\n\nstatic int mc33880_write_config(struct mc33880 *mc)\n{\n\treturn spi_write(mc->spi, &mc->port_config, sizeof(mc->port_config));\n}\n\n\nstatic int __mc33880_set(struct mc33880 *mc, unsigned offset, int value)\n{\n\tif (value)\n\t\tmc->port_config |= 1 << offset;\n\telse\n\t\tmc->port_config &= ~(1 << offset);\n\n\treturn mc33880_write_config(mc);\n}\n\n\nstatic void mc33880_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct mc33880 *mc = gpiochip_get_data(chip);\n\n\tmutex_lock(&mc->lock);\n\n\t__mc33880_set(mc, offset, value);\n\n\tmutex_unlock(&mc->lock);\n}\n\nstatic int mc33880_probe(struct spi_device *spi)\n{\n\tstruct mc33880 *mc;\n\tstruct mc33880_platform_data *pdata;\n\tint ret;\n\n\tpdata = dev_get_platdata(&spi->dev);\n\tif (!pdata || !pdata->base) {\n\t\tdev_dbg(&spi->dev, \"incorrect or missing platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspi->bits_per_word = 8;\n\n\tret = spi_setup(spi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmc = devm_kzalloc(&spi->dev, sizeof(struct mc33880), GFP_KERNEL);\n\tif (!mc)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&mc->lock);\n\n\tspi_set_drvdata(spi, mc);\n\n\tmc->spi = spi;\n\n\tmc->chip.label = DRIVER_NAME,\n\tmc->chip.set = mc33880_set;\n\tmc->chip.base = pdata->base;\n\tmc->chip.ngpio = PIN_NUMBER;\n\tmc->chip.can_sleep = true;\n\tmc->chip.parent = &spi->dev;\n\tmc->chip.owner = THIS_MODULE;\n\n\tmc->port_config = 0x00;\n\t \n\tret = mc33880_write_config(mc);\n\tmc->port_config = 0x00;\n\tif (!ret)\n\t\tret = mc33880_write_config(mc);\n\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed writing to \" DRIVER_NAME \": %d\\n\",\n\t\t\tret);\n\t\tgoto exit_destroy;\n\t}\n\n\tret = gpiochip_add_data(&mc->chip, mc);\n\tif (ret)\n\t\tgoto exit_destroy;\n\n\treturn ret;\n\nexit_destroy:\n\tmutex_destroy(&mc->lock);\n\treturn ret;\n}\n\nstatic void mc33880_remove(struct spi_device *spi)\n{\n\tstruct mc33880 *mc;\n\n\tmc = spi_get_drvdata(spi);\n\n\tgpiochip_remove(&mc->chip);\n\tmutex_destroy(&mc->lock);\n}\n\nstatic struct spi_driver mc33880_driver = {\n\t.driver = {\n\t\t.name\t\t= DRIVER_NAME,\n\t},\n\t.probe\t\t= mc33880_probe,\n\t.remove\t\t= mc33880_remove,\n};\n\nstatic int __init mc33880_init(void)\n{\n\treturn spi_register_driver(&mc33880_driver);\n}\n \nsubsys_initcall(mc33880_init);\n\nstatic void __exit mc33880_exit(void)\n{\n\tspi_unregister_driver(&mc33880_driver);\n}\nmodule_exit(mc33880_exit);\n\nMODULE_AUTHOR(\"Mocean Laboratories <info@mocean-labs.com>\");\nMODULE_LICENSE(\"GPL v2\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}