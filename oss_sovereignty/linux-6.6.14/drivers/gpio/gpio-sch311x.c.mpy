{
  "module_name": "gpio-sch311x.c",
  "hash_id": "0924364544dba0c4b84278a82a1b61a5a1be9d283cb7a61b0ff09c0e9afdd65a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-sch311x.c",
  "human_readable_source": "\n \n\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/driver.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n\n#define DRV_NAME\t\t\t\"gpio-sch311x\"\n\n#define SCH311X_GPIO_CONF_DIR\t\tBIT(0)\n#define SCH311X_GPIO_CONF_INVERT\tBIT(1)\n#define SCH311X_GPIO_CONF_OPEN_DRAIN\tBIT(7)\n\n#define SIO_CONFIG_KEY_ENTER\t\t0x55\n#define SIO_CONFIG_KEY_EXIT\t\t0xaa\n\n#define GP1\t\t\t\t0x4b\n\nstatic int sch311x_ioports[] = { 0x2e, 0x4e, 0x162e, 0x164e };\n\nstatic struct platform_device *sch311x_gpio_pdev;\n\nstruct sch311x_pdev_data {\t\t \n\tunsigned short runtime_reg;\t \n};\n\nstruct sch311x_gpio_block {\t\t \n\tstruct gpio_chip chip;\n\tunsigned short data_reg;\t \n\tunsigned short *config_regs;\t \n\tunsigned short runtime_reg;\t \n\tspinlock_t lock;\t\t \n};\n\nstruct sch311x_gpio_priv {\t\t \n\tstruct sch311x_gpio_block blocks[6];\n};\n\nstruct sch311x_gpio_block_def {\t\t \n\tunsigned short data_reg;\n\tunsigned short config_regs[8];\n\tunsigned short base;\n};\n\n \n\nstatic struct sch311x_gpio_block_def sch311x_gpio_blocks[] = {\n\t{\n\t\t.data_reg = 0x4b,\t \n\t\t.config_regs = {0x23, 0x24, 0x25, 0x26, 0x27, 0x29, 0x2a, 0x2b},\n\t\t.base = 10,\n\t},\n\t{\n\t\t.data_reg = 0x4c,\t \n\t\t.config_regs = {0x00, 0x2c, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x32},\n\t\t.base = 20,\n\t},\n\t{\n\t\t.data_reg = 0x4d,\t \n\t\t.config_regs = {0x33, 0x34, 0x35, 0x36, 0x37, 0x00, 0x39, 0x3a},\n\t\t.base = 30,\n\t},\n\t{\n\t\t.data_reg = 0x4e,\t \n\t\t.config_regs = {0x3b, 0x00, 0x3d, 0x00, 0x6e, 0x6f, 0x72, 0x73},\n\t\t.base = 40,\n\t},\n\t{\n\t\t.data_reg = 0x4f,\t \n\t\t.config_regs = {0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46},\n\t\t.base = 50,\n\t},\n\t{\n\t\t.data_reg = 0x50,\t \n\t\t.config_regs = {0x47, 0x48, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59},\n\t\t.base = 60,\n\t},\n};\n\n \n\nstatic inline int sch311x_sio_enter(int sio_config_port)\n{\n\t \n\tif (!request_muxed_region(sio_config_port, 2, DRV_NAME)) {\n\t\tpr_err(DRV_NAME \"I/O address 0x%04x already in use\\n\",\n\t\t       sio_config_port);\n\t\treturn -EBUSY;\n\t}\n\n\toutb(SIO_CONFIG_KEY_ENTER, sio_config_port);\n\treturn 0;\n}\n\nstatic inline void sch311x_sio_exit(int sio_config_port)\n{\n\toutb(SIO_CONFIG_KEY_EXIT, sio_config_port);\n\trelease_region(sio_config_port, 2);\n}\n\nstatic inline int sch311x_sio_inb(int sio_config_port, int reg)\n{\n\toutb(reg, sio_config_port);\n\treturn inb(sio_config_port + 1);\n}\n\nstatic inline void sch311x_sio_outb(int sio_config_port, int reg, int val)\n{\n\toutb(reg, sio_config_port);\n\toutb(val, sio_config_port + 1);\n}\n\n\n \n\nstatic int sch311x_gpio_request(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct sch311x_gpio_block *block = gpiochip_get_data(chip);\n\n\tif (block->config_regs[offset] == 0)  \n\t\treturn -ENODEV;\n\n\tif (!request_region(block->runtime_reg + block->config_regs[offset],\n\t\t\t    1, DRV_NAME)) {\n\t\tdev_err(chip->parent, \"Failed to request region 0x%04x.\\n\",\n\t\t\tblock->runtime_reg + block->config_regs[offset]);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic void sch311x_gpio_free(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct sch311x_gpio_block *block = gpiochip_get_data(chip);\n\n\tif (block->config_regs[offset] == 0)  \n\t\treturn;\n\n\trelease_region(block->runtime_reg + block->config_regs[offset], 1);\n}\n\nstatic int sch311x_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct sch311x_gpio_block *block = gpiochip_get_data(chip);\n\tu8 data;\n\n\tspin_lock(&block->lock);\n\tdata = inb(block->runtime_reg + block->data_reg);\n\tspin_unlock(&block->lock);\n\n\treturn !!(data & BIT(offset));\n}\n\nstatic void __sch311x_gpio_set(struct sch311x_gpio_block *block,\n\t\t\t       unsigned offset, int value)\n{\n\tu8 data = inb(block->runtime_reg + block->data_reg);\n\tif (value)\n\t\tdata |= BIT(offset);\n\telse\n\t\tdata &= ~BIT(offset);\n\toutb(data, block->runtime_reg + block->data_reg);\n}\n\nstatic void sch311x_gpio_set(struct gpio_chip *chip, unsigned offset,\n\t\t\t     int value)\n{\n\tstruct sch311x_gpio_block *block = gpiochip_get_data(chip);\n\n\tspin_lock(&block->lock);\n\t__sch311x_gpio_set(block, offset, value);\n\tspin_unlock(&block->lock);\n}\n\nstatic int sch311x_gpio_direction_in(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct sch311x_gpio_block *block = gpiochip_get_data(chip);\n\tu8 data;\n\n\tspin_lock(&block->lock);\n\tdata = inb(block->runtime_reg + block->config_regs[offset]);\n\tdata |= SCH311X_GPIO_CONF_DIR;\n\toutb(data, block->runtime_reg + block->config_regs[offset]);\n\tspin_unlock(&block->lock);\n\n\treturn 0;\n}\n\nstatic int sch311x_gpio_direction_out(struct gpio_chip *chip, unsigned offset,\n\t\t\t\t      int value)\n{\n\tstruct sch311x_gpio_block *block = gpiochip_get_data(chip);\n\tu8 data;\n\n\tspin_lock(&block->lock);\n\n\tdata = inb(block->runtime_reg + block->config_regs[offset]);\n\tdata &= ~SCH311X_GPIO_CONF_DIR;\n\toutb(data, block->runtime_reg + block->config_regs[offset]);\n\t__sch311x_gpio_set(block, offset, value);\n\n\tspin_unlock(&block->lock);\n\treturn 0;\n}\n\nstatic int sch311x_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct sch311x_gpio_block *block = gpiochip_get_data(chip);\n\tu8 data;\n\n\tspin_lock(&block->lock);\n\tdata = inb(block->runtime_reg + block->config_regs[offset]);\n\tspin_unlock(&block->lock);\n\n\tif (data & SCH311X_GPIO_CONF_DIR)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int sch311x_gpio_set_config(struct gpio_chip *chip, unsigned offset,\n\t\t\t\t   unsigned long config)\n{\n\tstruct sch311x_gpio_block *block = gpiochip_get_data(chip);\n\tenum pin_config_param param = pinconf_to_config_param(config);\n\tu8 data;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tspin_lock(&block->lock);\n\t\tdata = inb(block->runtime_reg + block->config_regs[offset]);\n\t\tdata |= SCH311X_GPIO_CONF_OPEN_DRAIN;\n\t\toutb(data, block->runtime_reg + block->config_regs[offset]);\n\t\tspin_unlock(&block->lock);\n\t\treturn 0;\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tspin_lock(&block->lock);\n\t\tdata = inb(block->runtime_reg + block->config_regs[offset]);\n\t\tdata &= ~SCH311X_GPIO_CONF_OPEN_DRAIN;\n\t\toutb(data, block->runtime_reg + block->config_regs[offset]);\n\t\tspin_unlock(&block->lock);\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -ENOTSUPP;\n}\n\nstatic int sch311x_gpio_probe(struct platform_device *pdev)\n{\n\tstruct sch311x_pdev_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct sch311x_gpio_priv *priv;\n\tstruct sch311x_gpio_block *block;\n\tint err, i;\n\n\t \n\tif (!devm_request_region(&pdev->dev, pdata->runtime_reg + GP1, 6,\n\t\tDRV_NAME)) {\n\t\tdev_err(&pdev->dev, \"Failed to request region 0x%04x-0x%04x.\\n\",\n\t\t\tpdata->runtime_reg + GP1, pdata->runtime_reg + GP1 + 5);\n\t\treturn -EBUSY;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->blocks); i++) {\n\t\tblock = &priv->blocks[i];\n\n\t\tspin_lock_init(&block->lock);\n\n\t\tblock->chip.label = DRV_NAME;\n\t\tblock->chip.owner = THIS_MODULE;\n\t\tblock->chip.request = sch311x_gpio_request;\n\t\tblock->chip.free = sch311x_gpio_free;\n\t\tblock->chip.direction_input = sch311x_gpio_direction_in;\n\t\tblock->chip.direction_output = sch311x_gpio_direction_out;\n\t\tblock->chip.get_direction = sch311x_gpio_get_direction;\n\t\tblock->chip.set_config = sch311x_gpio_set_config;\n\t\tblock->chip.get = sch311x_gpio_get;\n\t\tblock->chip.set = sch311x_gpio_set;\n\t\tblock->chip.ngpio = 8;\n\t\tblock->chip.parent = &pdev->dev;\n\t\tblock->chip.base = sch311x_gpio_blocks[i].base;\n\t\tblock->config_regs = sch311x_gpio_blocks[i].config_regs;\n\t\tblock->data_reg = sch311x_gpio_blocks[i].data_reg;\n\t\tblock->runtime_reg = pdata->runtime_reg;\n\n\t\terr = devm_gpiochip_add_data(&pdev->dev, &block->chip, block);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Could not register gpiochip, %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tdev_info(&pdev->dev,\n\t\t\t \"SMSC SCH311x GPIO block %d registered.\\n\", i);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver sch311x_gpio_driver = {\n\t.driver.name\t= DRV_NAME,\n\t.probe\t\t= sch311x_gpio_probe,\n};\n\n\n \n\nstatic int __init sch311x_detect(int sio_config_port, unsigned short *addr)\n{\n\tint err = 0, reg;\n\tunsigned short base_addr;\n\tu8 dev_id;\n\n\terr = sch311x_sio_enter(sio_config_port);\n\tif (err)\n\t\treturn err;\n\n\t \n\treg = sch311x_sio_inb(sio_config_port, 0x20);\n\tswitch (reg) {\n\tcase 0x7c:  \n\t\tdev_id = 2;\n\t\tbreak;\n\tcase 0x7d:  \n\t\tdev_id = 4;\n\t\tbreak;\n\tcase 0x7f:  \n\t\tdev_id = 6;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\tsch311x_sio_outb(sio_config_port, 0x07, 0x0a);\n\n\t \n\tif ((sch311x_sio_inb(sio_config_port, 0x30) & 0x01) == 0)\n\t\tpr_info(\"Seems that LDN 0x0a is not active...\\n\");\n\n\t \n\tbase_addr = (sch311x_sio_inb(sio_config_port, 0x60) << 8) |\n\t\t\t   sch311x_sio_inb(sio_config_port, 0x61);\n\tif (!base_addr) {\n\t\tpr_err(\"Base address not set\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\t*addr = base_addr;\n\n\tpr_info(\"Found an SMSC SCH311%d chip at 0x%04x\\n\", dev_id, base_addr);\n\nexit:\n\tsch311x_sio_exit(sio_config_port);\n\treturn err;\n}\n\nstatic int __init sch311x_gpio_pdev_add(const unsigned short addr)\n{\n\tstruct sch311x_pdev_data pdata;\n\tint err;\n\n\tpdata.runtime_reg = addr;\n\n\tsch311x_gpio_pdev = platform_device_alloc(DRV_NAME, -1);\n\tif (!sch311x_gpio_pdev)\n\t\treturn -ENOMEM;\n\n\terr = platform_device_add_data(sch311x_gpio_pdev,\n\t\t\t\t       &pdata, sizeof(pdata));\n\tif (err) {\n\t\tpr_err(DRV_NAME \"Platform data allocation failed\\n\");\n\t\tgoto err;\n\t}\n\n\terr = platform_device_add(sch311x_gpio_pdev);\n\tif (err) {\n\t\tpr_err(DRV_NAME \"Device addition failed\\n\");\n\t\tgoto err;\n\t}\n\treturn 0;\n\nerr:\n\tplatform_device_put(sch311x_gpio_pdev);\n\treturn err;\n}\n\nstatic int __init sch311x_gpio_init(void)\n{\n\tint err, i;\n\tunsigned short addr = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(sch311x_ioports); i++)\n\t\tif (sch311x_detect(sch311x_ioports[i], &addr) == 0)\n\t\t\tbreak;\n\n\tif (!addr)\n\t\treturn -ENODEV;\n\n\terr = platform_driver_register(&sch311x_gpio_driver);\n\tif (err)\n\t\treturn err;\n\n\terr = sch311x_gpio_pdev_add(addr);\n\tif (err)\n\t\tgoto unreg_platform_driver;\n\n\treturn 0;\n\nunreg_platform_driver:\n\tplatform_driver_unregister(&sch311x_gpio_driver);\n\treturn err;\n}\n\nstatic void __exit sch311x_gpio_exit(void)\n{\n\tplatform_device_unregister(sch311x_gpio_pdev);\n\tplatform_driver_unregister(&sch311x_gpio_driver);\n}\n\nmodule_init(sch311x_gpio_init);\nmodule_exit(sch311x_gpio_exit);\n\nMODULE_AUTHOR(\"Bruno Randolf <br1@einfach.org>\");\nMODULE_DESCRIPTION(\"SMSC SCH311x GPIO Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:gpio-sch311x\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}