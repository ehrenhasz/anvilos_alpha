{
  "module_name": "gpio-104-idi-48.c",
  "hash_id": "ccf98905916d86785d9945c28fb5ff1535aa05917fa956b0002c6c7f7a883072",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-104-idi-48.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/regmap.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/isa.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n#define IDI_48_EXTENT 8\n#define MAX_NUM_IDI_48 max_num_isa_dev(IDI_48_EXTENT)\n\nstatic unsigned int base[MAX_NUM_IDI_48];\nstatic unsigned int num_idi_48;\nmodule_param_hw_array(base, uint, ioport, &num_idi_48, 0);\nMODULE_PARM_DESC(base, \"ACCES 104-IDI-48 base addresses\");\n\nstatic unsigned int irq[MAX_NUM_IDI_48];\nstatic unsigned int num_irq;\nmodule_param_hw_array(irq, uint, irq, &num_irq, 0);\nMODULE_PARM_DESC(irq, \"ACCES 104-IDI-48 interrupt line numbers\");\n\n#define IDI48_IRQ_STATUS 0x7\n#define IDI48_IRQ_ENABLE IDI48_IRQ_STATUS\n\nstatic int idi_48_reg_mask_xlate(struct gpio_regmap *gpio, unsigned int base,\n\t\t\t\t unsigned int offset, unsigned int *reg,\n\t\t\t\t unsigned int *mask)\n{\n\tconst unsigned int line = offset % 8;\n\tconst unsigned int stride = offset / 8;\n\tconst unsigned int port = (stride / 3) * 4;\n\tconst unsigned int port_stride = stride % 3;\n\n\t*reg = base + port + port_stride;\n\t*mask = BIT(line);\n\n\treturn 0;\n}\n\nstatic const struct regmap_range idi_48_wr_ranges[] = {\n\tregmap_reg_range(0x0, 0x6),\n};\nstatic const struct regmap_range idi_48_rd_ranges[] = {\n\tregmap_reg_range(0x0, 0x2), regmap_reg_range(0x4, 0x7),\n};\nstatic const struct regmap_range idi_48_precious_ranges[] = {\n\tregmap_reg_range(0x7, 0x7),\n};\nstatic const struct regmap_access_table idi_48_wr_table = {\n\t.no_ranges = idi_48_wr_ranges,\n\t.n_no_ranges = ARRAY_SIZE(idi_48_wr_ranges),\n};\nstatic const struct regmap_access_table idi_48_rd_table = {\n\t.yes_ranges = idi_48_rd_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(idi_48_rd_ranges),\n};\nstatic const struct regmap_access_table idi_48_precious_table = {\n\t.yes_ranges = idi_48_precious_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(idi_48_precious_ranges),\n};\nstatic const struct regmap_config idi48_regmap_config = {\n\t.reg_bits = 8,\n\t.reg_stride = 1,\n\t.val_bits = 8,\n\t.io_port = true,\n\t.max_register = 0x6,\n\t.wr_table = &idi_48_wr_table,\n\t.rd_table = &idi_48_rd_table,\n\t.precious_table = &idi_48_precious_table,\n\t.use_raw_spinlock = true,\n};\n\n#define IDI48_NGPIO 48\n\n#define IDI48_REGMAP_IRQ(_id)\t\t\t\t\t\t\\\n\t[_id] = {\t\t\t\t\t\t\t\\\n\t\t.mask = BIT((_id) / 8),\t\t\t\t\t\\\n\t\t.type = { .types_supported = IRQ_TYPE_EDGE_BOTH },\t\\\n\t}\n\nstatic const struct regmap_irq idi48_regmap_irqs[IDI48_NGPIO] = {\n\tIDI48_REGMAP_IRQ(0), IDI48_REGMAP_IRQ(1), IDI48_REGMAP_IRQ(2),  \n\tIDI48_REGMAP_IRQ(3), IDI48_REGMAP_IRQ(4), IDI48_REGMAP_IRQ(5),  \n\tIDI48_REGMAP_IRQ(6), IDI48_REGMAP_IRQ(7), IDI48_REGMAP_IRQ(8),  \n\tIDI48_REGMAP_IRQ(9), IDI48_REGMAP_IRQ(10), IDI48_REGMAP_IRQ(11),  \n\tIDI48_REGMAP_IRQ(12), IDI48_REGMAP_IRQ(13), IDI48_REGMAP_IRQ(14),  \n\tIDI48_REGMAP_IRQ(15), IDI48_REGMAP_IRQ(16), IDI48_REGMAP_IRQ(17),  \n\tIDI48_REGMAP_IRQ(18), IDI48_REGMAP_IRQ(19), IDI48_REGMAP_IRQ(20),  \n\tIDI48_REGMAP_IRQ(21), IDI48_REGMAP_IRQ(22), IDI48_REGMAP_IRQ(23),  \n\tIDI48_REGMAP_IRQ(24), IDI48_REGMAP_IRQ(25), IDI48_REGMAP_IRQ(26),  \n\tIDI48_REGMAP_IRQ(27), IDI48_REGMAP_IRQ(28), IDI48_REGMAP_IRQ(29),  \n\tIDI48_REGMAP_IRQ(30), IDI48_REGMAP_IRQ(31), IDI48_REGMAP_IRQ(32),  \n\tIDI48_REGMAP_IRQ(33), IDI48_REGMAP_IRQ(34), IDI48_REGMAP_IRQ(35),  \n\tIDI48_REGMAP_IRQ(36), IDI48_REGMAP_IRQ(37), IDI48_REGMAP_IRQ(38),  \n\tIDI48_REGMAP_IRQ(39), IDI48_REGMAP_IRQ(40), IDI48_REGMAP_IRQ(41),  \n\tIDI48_REGMAP_IRQ(42), IDI48_REGMAP_IRQ(43), IDI48_REGMAP_IRQ(44),  \n\tIDI48_REGMAP_IRQ(45), IDI48_REGMAP_IRQ(46), IDI48_REGMAP_IRQ(47),  \n};\n\nstatic const char *idi48_names[IDI48_NGPIO] = {\n\t\"Bit 0 A\", \"Bit 1 A\", \"Bit 2 A\", \"Bit 3 A\", \"Bit 4 A\", \"Bit 5 A\",\n\t\"Bit 6 A\", \"Bit 7 A\", \"Bit 8 A\", \"Bit 9 A\", \"Bit 10 A\", \"Bit 11 A\",\n\t\"Bit 12 A\", \"Bit 13 A\", \"Bit 14 A\", \"Bit 15 A\",\t\"Bit 16 A\", \"Bit 17 A\",\n\t\"Bit 18 A\", \"Bit 19 A\", \"Bit 20 A\", \"Bit 21 A\", \"Bit 22 A\", \"Bit 23 A\",\n\t\"Bit 0 B\", \"Bit 1 B\", \"Bit 2 B\", \"Bit 3 B\", \"Bit 4 B\", \"Bit 5 B\",\n\t\"Bit 6 B\", \"Bit 7 B\", \"Bit 8 B\", \"Bit 9 B\", \"Bit 10 B\", \"Bit 11 B\",\n\t\"Bit 12 B\", \"Bit 13 B\", \"Bit 14 B\", \"Bit 15 B\",\t\"Bit 16 B\", \"Bit 17 B\",\n\t\"Bit 18 B\", \"Bit 19 B\", \"Bit 20 B\", \"Bit 21 B\", \"Bit 22 B\", \"Bit 23 B\"\n};\n\nstatic int idi_48_probe(struct device *dev, unsigned int id)\n{\n\tconst char *const name = dev_name(dev);\n\tstruct gpio_regmap_config config = {};\n\tvoid __iomem *regs;\n\tstruct regmap *map;\n\tstruct regmap_irq_chip *chip;\n\tstruct regmap_irq_chip_data *chip_data;\n\tint err;\n\n\tif (!devm_request_region(dev, base[id], IDI_48_EXTENT, name)) {\n\t\tdev_err(dev, \"Unable to lock port addresses (0x%X-0x%X)\\n\",\n\t\t\tbase[id], base[id] + IDI_48_EXTENT);\n\t\treturn -EBUSY;\n\t}\n\n\tregs = devm_ioport_map(dev, base[id], IDI_48_EXTENT);\n\tif (!regs)\n\t\treturn -ENOMEM;\n\n\tmap = devm_regmap_init_mmio(dev, regs, &idi48_regmap_config);\n\tif (IS_ERR(map))\n\t\treturn dev_err_probe(dev, PTR_ERR(map),\n\t\t\t\t     \"Unable to initialize register map\\n\");\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->name = name;\n\tchip->status_base = IDI48_IRQ_STATUS;\n\tchip->unmask_base = IDI48_IRQ_ENABLE;\n\tchip->clear_on_unmask = true;\n\tchip->num_regs = 1;\n\tchip->irqs = idi48_regmap_irqs;\n\tchip->num_irqs = ARRAY_SIZE(idi48_regmap_irqs);\n\n\terr = devm_regmap_add_irq_chip(dev, map, irq[id], IRQF_SHARED, 0, chip,\n\t\t\t\t       &chip_data);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"IRQ registration failed\\n\");\n\n\tconfig.parent = dev;\n\tconfig.regmap = map;\n\tconfig.ngpio = IDI48_NGPIO;\n\tconfig.names = idi48_names;\n\tconfig.reg_dat_base = GPIO_REGMAP_ADDR(0x0);\n\tconfig.ngpio_per_reg = 8;\n\tconfig.reg_mask_xlate = idi_48_reg_mask_xlate;\n\tconfig.irq_domain = regmap_irq_get_domain(chip_data);\n\n\treturn PTR_ERR_OR_ZERO(devm_gpio_regmap_register(dev, &config));\n}\n\nstatic struct isa_driver idi_48_driver = {\n\t.probe = idi_48_probe,\n\t.driver = {\n\t\t.name = \"104-idi-48\"\n\t},\n};\nmodule_isa_driver_with_irq(idi_48_driver, num_idi_48, num_irq);\n\nMODULE_AUTHOR(\"William Breathitt Gray <vilhelm.gray@gmail.com>\");\nMODULE_DESCRIPTION(\"ACCES 104-IDI-48 GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}