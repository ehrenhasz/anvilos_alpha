{
  "module_name": "gpio-tegra.c",
  "hash_id": "bffab5817fe12911cfbfac1be23ce685f310eaa5de23269049ee6de11db86bf9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-tegra.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/gpio/driver.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm.h>\n\n#define GPIO_BANK(x)\t\t((x) >> 5)\n#define GPIO_PORT(x)\t\t(((x) >> 3) & 0x3)\n#define GPIO_BIT(x)\t\t((x) & 0x7)\n\n#define GPIO_REG(tgi, x)\t(GPIO_BANK(x) * tgi->soc->bank_stride + \\\n\t\t\t\t\tGPIO_PORT(x) * 4)\n\n#define GPIO_CNF(t, x)\t\t(GPIO_REG(t, x) + 0x00)\n#define GPIO_OE(t, x)\t\t(GPIO_REG(t, x) + 0x10)\n#define GPIO_OUT(t, x)\t\t(GPIO_REG(t, x) + 0X20)\n#define GPIO_IN(t, x)\t\t(GPIO_REG(t, x) + 0x30)\n#define GPIO_INT_STA(t, x)\t(GPIO_REG(t, x) + 0x40)\n#define GPIO_INT_ENB(t, x)\t(GPIO_REG(t, x) + 0x50)\n#define GPIO_INT_LVL(t, x)\t(GPIO_REG(t, x) + 0x60)\n#define GPIO_INT_CLR(t, x)\t(GPIO_REG(t, x) + 0x70)\n#define GPIO_DBC_CNT(t, x)\t(GPIO_REG(t, x) + 0xF0)\n\n\n#define GPIO_MSK_CNF(t, x)\t(GPIO_REG(t, x) + t->soc->upper_offset + 0x00)\n#define GPIO_MSK_OE(t, x)\t(GPIO_REG(t, x) + t->soc->upper_offset + 0x10)\n#define GPIO_MSK_OUT(t, x)\t(GPIO_REG(t, x) + t->soc->upper_offset + 0X20)\n#define GPIO_MSK_DBC_EN(t, x)\t(GPIO_REG(t, x) + t->soc->upper_offset + 0x30)\n#define GPIO_MSK_INT_STA(t, x)\t(GPIO_REG(t, x) + t->soc->upper_offset + 0x40)\n#define GPIO_MSK_INT_ENB(t, x)\t(GPIO_REG(t, x) + t->soc->upper_offset + 0x50)\n#define GPIO_MSK_INT_LVL(t, x)\t(GPIO_REG(t, x) + t->soc->upper_offset + 0x60)\n\n#define GPIO_INT_LVL_MASK\t\t0x010101\n#define GPIO_INT_LVL_EDGE_RISING\t0x000101\n#define GPIO_INT_LVL_EDGE_FALLING\t0x000100\n#define GPIO_INT_LVL_EDGE_BOTH\t\t0x010100\n#define GPIO_INT_LVL_LEVEL_HIGH\t\t0x000001\n#define GPIO_INT_LVL_LEVEL_LOW\t\t0x000000\n\nstruct tegra_gpio_info;\n\nstruct tegra_gpio_bank {\n\tunsigned int bank;\n\n\t \n\traw_spinlock_t lvl_lock[4];\n\n\t \n\tspinlock_t dbc_lock[4];\n\n#ifdef CONFIG_PM_SLEEP\n\tu32 cnf[4];\n\tu32 out[4];\n\tu32 oe[4];\n\tu32 int_enb[4];\n\tu32 int_lvl[4];\n\tu32 wake_enb[4];\n\tu32 dbc_enb[4];\n#endif\n\tu32 dbc_cnt[4];\n};\n\nstruct tegra_gpio_soc_config {\n\tbool debounce_supported;\n\tu32 bank_stride;\n\tu32 upper_offset;\n};\n\nstruct tegra_gpio_info {\n\tstruct device\t\t\t\t*dev;\n\tvoid __iomem\t\t\t\t*regs;\n\tstruct tegra_gpio_bank\t\t\t*bank_info;\n\tconst struct tegra_gpio_soc_config\t*soc;\n\tstruct gpio_chip\t\t\tgc;\n\tu32\t\t\t\t\tbank_count;\n\tunsigned int\t\t\t\t*irqs;\n};\n\nstatic inline void tegra_gpio_writel(struct tegra_gpio_info *tgi,\n\t\t\t\t     u32 val, u32 reg)\n{\n\twritel_relaxed(val, tgi->regs + reg);\n}\n\nstatic inline u32 tegra_gpio_readl(struct tegra_gpio_info *tgi, u32 reg)\n{\n\treturn readl_relaxed(tgi->regs + reg);\n}\n\nstatic unsigned int tegra_gpio_compose(unsigned int bank, unsigned int port,\n\t\t\t\t       unsigned int bit)\n{\n\treturn (bank << 5) | ((port & 0x3) << 3) | (bit & 0x7);\n}\n\nstatic void tegra_gpio_mask_write(struct tegra_gpio_info *tgi, u32 reg,\n\t\t\t\t  unsigned int gpio, u32 value)\n{\n\tu32 val;\n\n\tval = 0x100 << GPIO_BIT(gpio);\n\tif (value)\n\t\tval |= 1 << GPIO_BIT(gpio);\n\ttegra_gpio_writel(tgi, val, reg);\n}\n\nstatic void tegra_gpio_enable(struct tegra_gpio_info *tgi, unsigned int gpio)\n{\n\ttegra_gpio_mask_write(tgi, GPIO_MSK_CNF(tgi, gpio), gpio, 1);\n}\n\nstatic void tegra_gpio_disable(struct tegra_gpio_info *tgi, unsigned int gpio)\n{\n\ttegra_gpio_mask_write(tgi, GPIO_MSK_CNF(tgi, gpio), gpio, 0);\n}\n\nstatic int tegra_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\treturn pinctrl_gpio_request(chip->base + offset);\n}\n\nstatic void tegra_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\n\tpinctrl_gpio_free(chip->base + offset);\n\ttegra_gpio_disable(tgi, offset);\n}\n\nstatic void tegra_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t   int value)\n{\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\n\ttegra_gpio_mask_write(tgi, GPIO_MSK_OUT(tgi, offset), offset, value);\n}\n\nstatic int tegra_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\tunsigned int bval = BIT(GPIO_BIT(offset));\n\n\t \n\tif (tegra_gpio_readl(tgi, GPIO_OE(tgi, offset)) & bval)\n\t\treturn !!(tegra_gpio_readl(tgi, GPIO_OUT(tgi, offset)) & bval);\n\n\treturn !!(tegra_gpio_readl(tgi, GPIO_IN(tgi, offset)) & bval);\n}\n\nstatic int tegra_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset)\n{\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\tint ret;\n\n\ttegra_gpio_mask_write(tgi, GPIO_MSK_OE(tgi, offset), offset, 0);\n\ttegra_gpio_enable(tgi, offset);\n\n\tret = pinctrl_gpio_direction_input(chip->base + offset);\n\tif (ret < 0)\n\t\tdev_err(tgi->dev,\n\t\t\t\"Failed to set pinctrl input direction of GPIO %d: %d\",\n\t\t\t chip->base + offset, ret);\n\n\treturn ret;\n}\n\nstatic int tegra_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset,\n\t\t\t\t       int value)\n{\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\tint ret;\n\n\ttegra_gpio_set(chip, offset, value);\n\ttegra_gpio_mask_write(tgi, GPIO_MSK_OE(tgi, offset), offset, 1);\n\ttegra_gpio_enable(tgi, offset);\n\n\tret = pinctrl_gpio_direction_output(chip->base + offset);\n\tif (ret < 0)\n\t\tdev_err(tgi->dev,\n\t\t\t\"Failed to set pinctrl output direction of GPIO %d: %d\",\n\t\t\t chip->base + offset, ret);\n\n\treturn ret;\n}\n\nstatic int tegra_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t    unsigned int offset)\n{\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\tu32 pin_mask = BIT(GPIO_BIT(offset));\n\tu32 cnf, oe;\n\n\tcnf = tegra_gpio_readl(tgi, GPIO_CNF(tgi, offset));\n\tif (!(cnf & pin_mask))\n\t\treturn -EINVAL;\n\n\toe = tegra_gpio_readl(tgi, GPIO_OE(tgi, offset));\n\n\tif (oe & pin_mask)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int tegra_gpio_set_debounce(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t   unsigned int debounce)\n{\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\tstruct tegra_gpio_bank *bank = &tgi->bank_info[GPIO_BANK(offset)];\n\tunsigned int debounce_ms = DIV_ROUND_UP(debounce, 1000);\n\tunsigned long flags;\n\tunsigned int port;\n\n\tif (!debounce_ms) {\n\t\ttegra_gpio_mask_write(tgi, GPIO_MSK_DBC_EN(tgi, offset),\n\t\t\t\t      offset, 0);\n\t\treturn 0;\n\t}\n\n\tdebounce_ms = min(debounce_ms, 255U);\n\tport = GPIO_PORT(offset);\n\n\t \n\tspin_lock_irqsave(&bank->dbc_lock[port], flags);\n\tif (bank->dbc_cnt[port] < debounce_ms) {\n\t\ttegra_gpio_writel(tgi, debounce_ms, GPIO_DBC_CNT(tgi, offset));\n\t\tbank->dbc_cnt[port] = debounce_ms;\n\t}\n\tspin_unlock_irqrestore(&bank->dbc_lock[port], flags);\n\n\ttegra_gpio_mask_write(tgi, GPIO_MSK_DBC_EN(tgi, offset), offset, 1);\n\n\treturn 0;\n}\n\nstatic int tegra_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t unsigned long config)\n{\n\tu32 debounce;\n\n\tif (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)\n\t\treturn -ENOTSUPP;\n\n\tdebounce = pinconf_to_config_argument(config);\n\treturn tegra_gpio_set_debounce(chip, offset, debounce);\n}\n\nstatic void tegra_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\tunsigned int gpio = d->hwirq;\n\n\ttegra_gpio_writel(tgi, 1 << GPIO_BIT(gpio), GPIO_INT_CLR(tgi, gpio));\n}\n\nstatic void tegra_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\tunsigned int gpio = d->hwirq;\n\n\ttegra_gpio_mask_write(tgi, GPIO_MSK_INT_ENB(tgi, gpio), gpio, 0);\n\tgpiochip_disable_irq(chip, gpio);\n}\n\nstatic void tegra_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\tunsigned int gpio = d->hwirq;\n\n\tgpiochip_enable_irq(chip, gpio);\n\ttegra_gpio_mask_write(tgi, GPIO_MSK_INT_ENB(tgi, gpio), gpio, 1);\n}\n\nstatic int tegra_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tunsigned int gpio = d->hwirq, port = GPIO_PORT(gpio), lvl_type;\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\tstruct tegra_gpio_bank *bank;\n\tunsigned long flags;\n\tint ret;\n\tu32 val;\n\n\tbank = &tgi->bank_info[GPIO_BANK(d->hwirq)];\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tlvl_type = GPIO_INT_LVL_EDGE_RISING;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tlvl_type = GPIO_INT_LVL_EDGE_FALLING;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tlvl_type = GPIO_INT_LVL_EDGE_BOTH;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tlvl_type = GPIO_INT_LVL_LEVEL_HIGH;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tlvl_type = GPIO_INT_LVL_LEVEL_LOW;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&bank->lvl_lock[port], flags);\n\n\tval = tegra_gpio_readl(tgi, GPIO_INT_LVL(tgi, gpio));\n\tval &= ~(GPIO_INT_LVL_MASK << GPIO_BIT(gpio));\n\tval |= lvl_type << GPIO_BIT(gpio);\n\ttegra_gpio_writel(tgi, val, GPIO_INT_LVL(tgi, gpio));\n\n\traw_spin_unlock_irqrestore(&bank->lvl_lock[port], flags);\n\n\ttegra_gpio_mask_write(tgi, GPIO_MSK_OE(tgi, gpio), gpio, 0);\n\ttegra_gpio_enable(tgi, gpio);\n\n\tret = gpiochip_lock_as_irq(&tgi->gc, gpio);\n\tif (ret) {\n\t\tdev_err(tgi->dev,\n\t\t\t\"unable to lock Tegra GPIO %u as IRQ\\n\", gpio);\n\t\ttegra_gpio_disable(tgi, gpio);\n\t\treturn ret;\n\t}\n\n\tif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\telse if (type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\n\tif (d->parent_data)\n\t\tret = irq_chip_set_type_parent(d, type);\n\n\treturn ret;\n}\n\nstatic void tegra_gpio_irq_shutdown(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\tunsigned int gpio = d->hwirq;\n\n\ttegra_gpio_irq_mask(d);\n\tgpiochip_unlock_as_irq(&tgi->gc, gpio);\n}\n\nstatic void tegra_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct tegra_gpio_info *tgi = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irq_domain *domain = tgi->gc.irq.domain;\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct tegra_gpio_bank *bank = NULL;\n\tunsigned int port, pin, gpio, i;\n\tbool unmasked = false;\n\tunsigned long sta;\n\tu32 lvl;\n\n\tfor (i = 0; i < tgi->bank_count; i++) {\n\t\tif (tgi->irqs[i] == irq) {\n\t\t\tbank = &tgi->bank_info[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ON(bank == NULL))\n\t\treturn;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (port = 0; port < 4; port++) {\n\t\tgpio = tegra_gpio_compose(bank->bank, port, 0);\n\t\tsta = tegra_gpio_readl(tgi, GPIO_INT_STA(tgi, gpio)) &\n\t\t\ttegra_gpio_readl(tgi, GPIO_INT_ENB(tgi, gpio));\n\t\tlvl = tegra_gpio_readl(tgi, GPIO_INT_LVL(tgi, gpio));\n\n\t\tfor_each_set_bit(pin, &sta, 8) {\n\t\t\tint ret;\n\n\t\t\ttegra_gpio_writel(tgi, 1 << pin,\n\t\t\t\t\t  GPIO_INT_CLR(tgi, gpio));\n\n\t\t\t \n\t\t\tif (!unmasked && lvl & (0x100 << pin)) {\n\t\t\t\tunmasked = true;\n\t\t\t\tchained_irq_exit(chip, desc);\n\t\t\t}\n\n\t\t\tret = generic_handle_domain_irq(domain, gpio + pin);\n\t\t\tWARN_RATELIMIT(ret, \"hwirq = %d\", gpio + pin);\n\t\t}\n\t}\n\n\tif (!unmasked)\n\t\tchained_irq_exit(chip, desc);\n}\n\nstatic int tegra_gpio_child_to_parent_hwirq(struct gpio_chip *chip,\n\t\t\t\t\t    unsigned int hwirq,\n\t\t\t\t\t    unsigned int type,\n\t\t\t\t\t    unsigned int *parent_hwirq,\n\t\t\t\t\t    unsigned int *parent_type)\n{\n\t*parent_hwirq = chip->irq.child_offset_to_irq(chip, hwirq);\n\t*parent_type = type;\n\n\treturn 0;\n}\n\nstatic int tegra_gpio_populate_parent_fwspec(struct gpio_chip *chip,\n\t\t\t\t\t     union gpio_irq_fwspec *gfwspec,\n\t\t\t\t\t     unsigned int parent_hwirq,\n\t\t\t\t\t     unsigned int parent_type)\n{\n\tstruct irq_fwspec *fwspec = &gfwspec->fwspec;\n\n\tfwspec->fwnode = chip->irq.parent_domain->fwnode;\n\tfwspec->param_count = 3;\n\tfwspec->param[0] = 0;\n\tfwspec->param[1] = parent_hwirq;\n\tfwspec->param[2] = parent_type;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tegra_gpio_resume(struct device *dev)\n{\n\tstruct tegra_gpio_info *tgi = dev_get_drvdata(dev);\n\tunsigned int b, p;\n\n\tfor (b = 0; b < tgi->bank_count; b++) {\n\t\tstruct tegra_gpio_bank *bank = &tgi->bank_info[b];\n\n\t\tfor (p = 0; p < ARRAY_SIZE(bank->oe); p++) {\n\t\t\tunsigned int gpio = (b << 5) | (p << 3);\n\n\t\t\ttegra_gpio_writel(tgi, bank->cnf[p],\n\t\t\t\t\t  GPIO_CNF(tgi, gpio));\n\n\t\t\tif (tgi->soc->debounce_supported) {\n\t\t\t\ttegra_gpio_writel(tgi, bank->dbc_cnt[p],\n\t\t\t\t\t\t  GPIO_DBC_CNT(tgi, gpio));\n\t\t\t\ttegra_gpio_writel(tgi, bank->dbc_enb[p],\n\t\t\t\t\t\t  GPIO_MSK_DBC_EN(tgi, gpio));\n\t\t\t}\n\n\t\t\ttegra_gpio_writel(tgi, bank->out[p],\n\t\t\t\t\t  GPIO_OUT(tgi, gpio));\n\t\t\ttegra_gpio_writel(tgi, bank->oe[p],\n\t\t\t\t\t  GPIO_OE(tgi, gpio));\n\t\t\ttegra_gpio_writel(tgi, bank->int_lvl[p],\n\t\t\t\t\t  GPIO_INT_LVL(tgi, gpio));\n\t\t\ttegra_gpio_writel(tgi, bank->int_enb[p],\n\t\t\t\t\t  GPIO_INT_ENB(tgi, gpio));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_gpio_suspend(struct device *dev)\n{\n\tstruct tegra_gpio_info *tgi = dev_get_drvdata(dev);\n\tunsigned int b, p;\n\n\tfor (b = 0; b < tgi->bank_count; b++) {\n\t\tstruct tegra_gpio_bank *bank = &tgi->bank_info[b];\n\n\t\tfor (p = 0; p < ARRAY_SIZE(bank->oe); p++) {\n\t\t\tunsigned int gpio = (b << 5) | (p << 3);\n\n\t\t\tbank->cnf[p] = tegra_gpio_readl(tgi,\n\t\t\t\t\t\t\tGPIO_CNF(tgi, gpio));\n\t\t\tbank->out[p] = tegra_gpio_readl(tgi,\n\t\t\t\t\t\t\tGPIO_OUT(tgi, gpio));\n\t\t\tbank->oe[p] = tegra_gpio_readl(tgi,\n\t\t\t\t\t\t       GPIO_OE(tgi, gpio));\n\t\t\tif (tgi->soc->debounce_supported) {\n\t\t\t\tbank->dbc_enb[p] = tegra_gpio_readl(tgi,\n\t\t\t\t\t\tGPIO_MSK_DBC_EN(tgi, gpio));\n\t\t\t\tbank->dbc_enb[p] = (bank->dbc_enb[p] << 8) |\n\t\t\t\t\t\t\tbank->dbc_enb[p];\n\t\t\t}\n\n\t\t\tbank->int_enb[p] = tegra_gpio_readl(tgi,\n\t\t\t\t\t\tGPIO_INT_ENB(tgi, gpio));\n\t\t\tbank->int_lvl[p] = tegra_gpio_readl(tgi,\n\t\t\t\t\t\tGPIO_INT_LVL(tgi, gpio));\n\n\t\t\t \n\t\t\ttegra_gpio_writel(tgi, bank->wake_enb[p],\n\t\t\t\t\t  GPIO_INT_ENB(tgi, gpio));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_gpio_irq_set_wake(struct irq_data *d, unsigned int enable)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\tstruct tegra_gpio_bank *bank;\n\tunsigned int gpio = d->hwirq;\n\tu32 port, bit, mask;\n\tint err;\n\n\tbank = &tgi->bank_info[GPIO_BANK(d->hwirq)];\n\n\tport = GPIO_PORT(gpio);\n\tbit = GPIO_BIT(gpio);\n\tmask = BIT(bit);\n\n\terr = irq_set_irq_wake(tgi->irqs[bank->bank], enable);\n\tif (err)\n\t\treturn err;\n\n\tif (d->parent_data) {\n\t\terr = irq_chip_set_wake_parent(d, enable);\n\t\tif (err) {\n\t\t\tirq_set_irq_wake(tgi->irqs[bank->bank], !enable);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (enable)\n\t\tbank->wake_enb[port] |= mask;\n\telse\n\t\tbank->wake_enb[port] &= ~mask;\n\n\treturn 0;\n}\n#endif\n\nstatic int tegra_gpio_irq_set_affinity(struct irq_data *data,\n\t\t\t\t       const struct cpumask *dest,\n\t\t\t\t       bool force)\n{\n\tif (data->parent_data)\n\t\treturn irq_chip_set_affinity_parent(data, dest, force);\n\n\treturn -EINVAL;\n}\n\nstatic int tegra_gpio_irq_request_resources(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\n\ttegra_gpio_enable(tgi, d->hwirq);\n\n\treturn gpiochip_reqres_irq(chip, d->hwirq);\n}\n\nstatic void tegra_gpio_irq_release_resources(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\n\n\tgpiochip_relres_irq(chip, d->hwirq);\n\ttegra_gpio_enable(tgi, d->hwirq);\n}\n\nstatic void tegra_gpio_irq_print_chip(struct irq_data *d, struct seq_file *s)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\n\tseq_printf(s, dev_name(chip->parent));\n}\n\nstatic const struct irq_chip tegra_gpio_irq_chip = {\n\t.irq_shutdown\t\t= tegra_gpio_irq_shutdown,\n\t.irq_ack\t\t= tegra_gpio_irq_ack,\n\t.irq_mask\t\t= tegra_gpio_irq_mask,\n\t.irq_unmask\t\t= tegra_gpio_irq_unmask,\n\t.irq_set_type\t\t= tegra_gpio_irq_set_type,\n#ifdef CONFIG_PM_SLEEP\n\t.irq_set_wake\t\t= tegra_gpio_irq_set_wake,\n#endif\n\t.irq_print_chip\t\t= tegra_gpio_irq_print_chip,\n\t.irq_request_resources\t= tegra_gpio_irq_request_resources,\n\t.irq_release_resources\t= tegra_gpio_irq_release_resources,\n\t.flags\t\t\t= IRQCHIP_IMMUTABLE,\n};\n\nstatic const struct irq_chip tegra210_gpio_irq_chip = {\n\t.irq_shutdown\t\t= tegra_gpio_irq_shutdown,\n\t.irq_ack\t\t= tegra_gpio_irq_ack,\n\t.irq_mask\t\t= tegra_gpio_irq_mask,\n\t.irq_unmask\t\t= tegra_gpio_irq_unmask,\n\t.irq_set_affinity\t= tegra_gpio_irq_set_affinity,\n\t.irq_set_type\t\t= tegra_gpio_irq_set_type,\n#ifdef CONFIG_PM_SLEEP\n\t.irq_set_wake\t\t= tegra_gpio_irq_set_wake,\n#endif\n\t.irq_print_chip\t\t= tegra_gpio_irq_print_chip,\n\t.irq_request_resources\t= tegra_gpio_irq_request_resources,\n\t.irq_release_resources\t= tegra_gpio_irq_release_resources,\n\t.flags\t\t\t= IRQCHIP_IMMUTABLE,\n};\n\n#ifdef\tCONFIG_DEBUG_FS\n\n#include <linux/debugfs.h>\n\nstatic int tegra_dbg_gpio_show(struct seq_file *s, void *unused)\n{\n\tstruct tegra_gpio_info *tgi = dev_get_drvdata(s->private);\n\tunsigned int i, j;\n\n\tfor (i = 0; i < tgi->bank_count; i++) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tunsigned int gpio = tegra_gpio_compose(i, j, 0);\n\n\t\t\tseq_printf(s,\n\t\t\t\t\"%u:%u %02x %02x %02x %02x %02x %02x %06x\\n\",\n\t\t\t\ti, j,\n\t\t\t\ttegra_gpio_readl(tgi, GPIO_CNF(tgi, gpio)),\n\t\t\t\ttegra_gpio_readl(tgi, GPIO_OE(tgi, gpio)),\n\t\t\t\ttegra_gpio_readl(tgi, GPIO_OUT(tgi, gpio)),\n\t\t\t\ttegra_gpio_readl(tgi, GPIO_IN(tgi, gpio)),\n\t\t\t\ttegra_gpio_readl(tgi, GPIO_INT_STA(tgi, gpio)),\n\t\t\t\ttegra_gpio_readl(tgi, GPIO_INT_ENB(tgi, gpio)),\n\t\t\t\ttegra_gpio_readl(tgi, GPIO_INT_LVL(tgi, gpio)));\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void tegra_gpio_debuginit(struct tegra_gpio_info *tgi)\n{\n\tdebugfs_create_devm_seqfile(tgi->dev, \"tegra_gpio\", NULL,\n\t\t\t\t    tegra_dbg_gpio_show);\n}\n\n#else\n\nstatic inline void tegra_gpio_debuginit(struct tegra_gpio_info *tgi)\n{\n}\n\n#endif\n\nstatic const struct dev_pm_ops tegra_gpio_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(tegra_gpio_suspend, tegra_gpio_resume)\n};\n\nstatic const struct of_device_id tegra_pmc_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-pmc\", },\n\t{   },\n};\n\nstatic int tegra_gpio_probe(struct platform_device *pdev)\n{\n\tstruct tegra_gpio_bank *bank;\n\tstruct tegra_gpio_info *tgi;\n\tstruct gpio_irq_chip *irq;\n\tstruct device_node *np;\n\tunsigned int i, j;\n\tint ret;\n\n\ttgi = devm_kzalloc(&pdev->dev, sizeof(*tgi), GFP_KERNEL);\n\tif (!tgi)\n\t\treturn -ENODEV;\n\n\ttgi->soc = of_device_get_match_data(&pdev->dev);\n\ttgi->dev = &pdev->dev;\n\n\tret = platform_irq_count(pdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttgi->bank_count = ret;\n\n\tif (!tgi->bank_count) {\n\t\tdev_err(&pdev->dev, \"Missing IRQ resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttgi->gc.label\t\t\t= \"tegra-gpio\";\n\ttgi->gc.request\t\t\t= tegra_gpio_request;\n\ttgi->gc.free\t\t\t= tegra_gpio_free;\n\ttgi->gc.direction_input\t\t= tegra_gpio_direction_input;\n\ttgi->gc.get\t\t\t= tegra_gpio_get;\n\ttgi->gc.direction_output\t= tegra_gpio_direction_output;\n\ttgi->gc.set\t\t\t= tegra_gpio_set;\n\ttgi->gc.get_direction\t\t= tegra_gpio_get_direction;\n\ttgi->gc.base\t\t\t= 0;\n\ttgi->gc.ngpio\t\t\t= tgi->bank_count * 32;\n\ttgi->gc.parent\t\t\t= &pdev->dev;\n\n\tplatform_set_drvdata(pdev, tgi);\n\n\tif (tgi->soc->debounce_supported)\n\t\ttgi->gc.set_config = tegra_gpio_set_config;\n\n\ttgi->bank_info = devm_kcalloc(&pdev->dev, tgi->bank_count,\n\t\t\t\t      sizeof(*tgi->bank_info), GFP_KERNEL);\n\tif (!tgi->bank_info)\n\t\treturn -ENOMEM;\n\n\ttgi->irqs = devm_kcalloc(&pdev->dev, tgi->bank_count,\n\t\t\t\t sizeof(*tgi->irqs), GFP_KERNEL);\n\tif (!tgi->irqs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < tgi->bank_count; i++) {\n\t\tret = platform_get_irq(pdev, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbank = &tgi->bank_info[i];\n\t\tbank->bank = i;\n\n\t\ttgi->irqs[i] = ret;\n\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\traw_spin_lock_init(&bank->lvl_lock[j]);\n\t\t\tspin_lock_init(&bank->dbc_lock[j]);\n\t\t}\n\t}\n\n\tirq = &tgi->gc.irq;\n\tirq->fwnode = of_node_to_fwnode(pdev->dev.of_node);\n\tirq->child_to_parent_hwirq = tegra_gpio_child_to_parent_hwirq;\n\tirq->populate_parent_alloc_arg = tegra_gpio_populate_parent_fwspec;\n\tirq->handler = handle_simple_irq;\n\tirq->default_type = IRQ_TYPE_NONE;\n\tirq->parent_handler = tegra_gpio_irq_handler;\n\tirq->parent_handler_data = tgi;\n\tirq->num_parents = tgi->bank_count;\n\tirq->parents = tgi->irqs;\n\n\tnp = of_find_matching_node(NULL, tegra_pmc_of_match);\n\tif (np) {\n\t\tirq->parent_domain = irq_find_host(np);\n\t\tof_node_put(np);\n\n\t\tif (!irq->parent_domain)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tgpio_irq_chip_set_chip(irq, &tegra210_gpio_irq_chip);\n\t} else {\n\t\tgpio_irq_chip_set_chip(irq, &tegra_gpio_irq_chip);\n\t}\n\n\ttgi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tgi->regs))\n\t\treturn PTR_ERR(tgi->regs);\n\n\tfor (i = 0; i < tgi->bank_count; i++) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tint gpio = tegra_gpio_compose(i, j, 0);\n\n\t\t\ttegra_gpio_writel(tgi, 0x00, GPIO_INT_ENB(tgi, gpio));\n\t\t}\n\t}\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &tgi->gc, tgi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttegra_gpio_debuginit(tgi);\n\n\treturn 0;\n}\n\nstatic const struct tegra_gpio_soc_config tegra20_gpio_config = {\n\t.bank_stride = 0x80,\n\t.upper_offset = 0x800,\n};\n\nstatic const struct tegra_gpio_soc_config tegra30_gpio_config = {\n\t.bank_stride = 0x100,\n\t.upper_offset = 0x80,\n};\n\nstatic const struct tegra_gpio_soc_config tegra210_gpio_config = {\n\t.debounce_supported = true,\n\t.bank_stride = 0x100,\n\t.upper_offset = 0x80,\n};\n\nstatic const struct of_device_id tegra_gpio_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-gpio\", .data = &tegra210_gpio_config },\n\t{ .compatible = \"nvidia,tegra30-gpio\", .data = &tegra30_gpio_config },\n\t{ .compatible = \"nvidia,tegra20-gpio\", .data = &tegra20_gpio_config },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_gpio_of_match);\n\nstatic struct platform_driver tegra_gpio_driver = {\n\t.driver = {\n\t\t.name = \"tegra-gpio\",\n\t\t.pm = &tegra_gpio_pm_ops,\n\t\t.of_match_table = tegra_gpio_of_match,\n\t},\n\t.probe = tegra_gpio_probe,\n};\nmodule_platform_driver(tegra_gpio_driver);\n\nMODULE_DESCRIPTION(\"NVIDIA Tegra GPIO controller driver\");\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_AUTHOR(\"Stephen Warren <swarren@nvidia.com>\");\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_AUTHOR(\"Erik Gilling <konkers@google.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}