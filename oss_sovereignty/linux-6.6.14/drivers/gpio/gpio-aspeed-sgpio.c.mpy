{
  "module_name": "gpio-aspeed-sgpio.c",
  "hash_id": "a249fba5b7dcfdc528036bfcabce0e994c9c317e36fa434f2bac4a5b39bf0fda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-aspeed-sgpio.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/gpio/driver.h>\n#include <linux/hashtable.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n\n#define ASPEED_SGPIO_CTRL\t\t0x54\n\n#define ASPEED_SGPIO_CLK_DIV_MASK\tGENMASK(31, 16)\n#define ASPEED_SGPIO_ENABLE\t\tBIT(0)\n#define ASPEED_SGPIO_PINS_SHIFT\t\t6\n\nstruct aspeed_sgpio_pdata {\n\tconst u32 pin_mask;\n};\n\nstruct aspeed_sgpio {\n\tstruct gpio_chip chip;\n\tstruct device *dev;\n\tstruct clk *pclk;\n\traw_spinlock_t lock;\n\tvoid __iomem *base;\n\tint irq;\n};\n\nstruct aspeed_sgpio_bank {\n\tu16    val_regs;\n\tu16    rdata_reg;\n\tu16    irq_regs;\n\tu16    tolerance_regs;\n\tconst char  names[4][3];\n};\n\n \nstatic const struct aspeed_sgpio_bank aspeed_sgpio_banks[] = {\n\t{\n\t\t.val_regs = 0x0000,\n\t\t.rdata_reg = 0x0070,\n\t\t.irq_regs = 0x0004,\n\t\t.tolerance_regs = 0x0018,\n\t\t.names = { \"A\", \"B\", \"C\", \"D\" },\n\t},\n\t{\n\t\t.val_regs = 0x001C,\n\t\t.rdata_reg = 0x0074,\n\t\t.irq_regs = 0x0020,\n\t\t.tolerance_regs = 0x0034,\n\t\t.names = { \"E\", \"F\", \"G\", \"H\" },\n\t},\n\t{\n\t\t.val_regs = 0x0038,\n\t\t.rdata_reg = 0x0078,\n\t\t.irq_regs = 0x003C,\n\t\t.tolerance_regs = 0x0050,\n\t\t.names = { \"I\", \"J\", \"K\", \"L\" },\n\t},\n\t{\n\t\t.val_regs = 0x0090,\n\t\t.rdata_reg = 0x007C,\n\t\t.irq_regs = 0x0094,\n\t\t.tolerance_regs = 0x00A8,\n\t\t.names = { \"M\", \"N\", \"O\", \"P\" },\n\t},\n};\n\nenum aspeed_sgpio_reg {\n\treg_val,\n\treg_rdata,\n\treg_irq_enable,\n\treg_irq_type0,\n\treg_irq_type1,\n\treg_irq_type2,\n\treg_irq_status,\n\treg_tolerance,\n};\n\n#define GPIO_VAL_VALUE      0x00\n#define GPIO_IRQ_ENABLE     0x00\n#define GPIO_IRQ_TYPE0      0x04\n#define GPIO_IRQ_TYPE1      0x08\n#define GPIO_IRQ_TYPE2      0x0C\n#define GPIO_IRQ_STATUS     0x10\n\nstatic void __iomem *bank_reg(struct aspeed_sgpio *gpio,\n\t\t\t\t     const struct aspeed_sgpio_bank *bank,\n\t\t\t\t     const enum aspeed_sgpio_reg reg)\n{\n\tswitch (reg) {\n\tcase reg_val:\n\t\treturn gpio->base + bank->val_regs + GPIO_VAL_VALUE;\n\tcase reg_rdata:\n\t\treturn gpio->base + bank->rdata_reg;\n\tcase reg_irq_enable:\n\t\treturn gpio->base + bank->irq_regs + GPIO_IRQ_ENABLE;\n\tcase reg_irq_type0:\n\t\treturn gpio->base + bank->irq_regs + GPIO_IRQ_TYPE0;\n\tcase reg_irq_type1:\n\t\treturn gpio->base + bank->irq_regs + GPIO_IRQ_TYPE1;\n\tcase reg_irq_type2:\n\t\treturn gpio->base + bank->irq_regs + GPIO_IRQ_TYPE2;\n\tcase reg_irq_status:\n\t\treturn gpio->base + bank->irq_regs + GPIO_IRQ_STATUS;\n\tcase reg_tolerance:\n\t\treturn gpio->base + bank->tolerance_regs;\n\tdefault:\n\t\t \n\t\tBUG();\n\t}\n}\n\n#define GPIO_BANK(x)    ((x) >> 6)\n#define GPIO_OFFSET(x)  ((x) & GENMASK(5, 0))\n#define GPIO_BIT(x)     BIT(GPIO_OFFSET(x) >> 1)\n\nstatic const struct aspeed_sgpio_bank *to_bank(unsigned int offset)\n{\n\tunsigned int bank;\n\n\tbank = GPIO_BANK(offset);\n\n\tWARN_ON(bank >= ARRAY_SIZE(aspeed_sgpio_banks));\n\treturn &aspeed_sgpio_banks[bank];\n}\n\nstatic int aspeed_sgpio_init_valid_mask(struct gpio_chip *gc,\n\t\tunsigned long *valid_mask, unsigned int ngpios)\n{\n\tbitmap_set(valid_mask, 0, ngpios);\n\treturn 0;\n}\n\nstatic void aspeed_sgpio_irq_init_valid_mask(struct gpio_chip *gc,\n\t\tunsigned long *valid_mask, unsigned int ngpios)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ngpios; i++) {\n\t\tif (i % 2)\n\t\t\tclear_bit(i, valid_mask);\n\t}\n}\n\nstatic bool aspeed_sgpio_is_input(unsigned int offset)\n{\n\treturn !(offset % 2);\n}\n\nstatic int aspeed_sgpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct aspeed_sgpio *gpio = gpiochip_get_data(gc);\n\tconst struct aspeed_sgpio_bank *bank = to_bank(offset);\n\tunsigned long flags;\n\tenum aspeed_sgpio_reg reg;\n\tint rc = 0;\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\treg = aspeed_sgpio_is_input(offset) ? reg_val : reg_rdata;\n\trc = !!(ioread32(bank_reg(gpio, bank, reg)) & GPIO_BIT(offset));\n\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\treturn rc;\n}\n\nstatic int sgpio_set_value(struct gpio_chip *gc, unsigned int offset, int val)\n{\n\tstruct aspeed_sgpio *gpio = gpiochip_get_data(gc);\n\tconst struct aspeed_sgpio_bank *bank = to_bank(offset);\n\tvoid __iomem *addr_r, *addr_w;\n\tu32 reg = 0;\n\n\tif (aspeed_sgpio_is_input(offset))\n\t\treturn -EINVAL;\n\n\t \n\taddr_r = bank_reg(gpio, bank, reg_rdata);\n\taddr_w = bank_reg(gpio, bank, reg_val);\n\n\treg = ioread32(addr_r);\n\n\tif (val)\n\t\treg |= GPIO_BIT(offset);\n\telse\n\t\treg &= ~GPIO_BIT(offset);\n\n\tiowrite32(reg, addr_w);\n\n\treturn 0;\n}\n\nstatic void aspeed_sgpio_set(struct gpio_chip *gc, unsigned int offset, int val)\n{\n\tstruct aspeed_sgpio *gpio = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\tsgpio_set_value(gc, offset, val);\n\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n}\n\nstatic int aspeed_sgpio_dir_in(struct gpio_chip *gc, unsigned int offset)\n{\n\treturn aspeed_sgpio_is_input(offset) ? 0 : -EINVAL;\n}\n\nstatic int aspeed_sgpio_dir_out(struct gpio_chip *gc, unsigned int offset, int val)\n{\n\tstruct aspeed_sgpio *gpio = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tint rc;\n\n\t \n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\trc = sgpio_set_value(gc, offset, val);\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\treturn rc;\n}\n\nstatic int aspeed_sgpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\treturn !!aspeed_sgpio_is_input(offset);\n}\n\nstatic void irqd_to_aspeed_sgpio_data(struct irq_data *d,\n\t\t\t\t\tstruct aspeed_sgpio **gpio,\n\t\t\t\t\tconst struct aspeed_sgpio_bank **bank,\n\t\t\t\t\tu32 *bit, int *offset)\n{\n\tstruct aspeed_sgpio *internal;\n\n\t*offset = irqd_to_hwirq(d);\n\tinternal = irq_data_get_irq_chip_data(d);\n\tWARN_ON(!internal);\n\n\t*gpio = internal;\n\t*bank = to_bank(*offset);\n\t*bit = GPIO_BIT(*offset);\n}\n\nstatic void aspeed_sgpio_irq_ack(struct irq_data *d)\n{\n\tconst struct aspeed_sgpio_bank *bank;\n\tstruct aspeed_sgpio *gpio;\n\tunsigned long flags;\n\tvoid __iomem *status_addr;\n\tint offset;\n\tu32 bit;\n\n\tirqd_to_aspeed_sgpio_data(d, &gpio, &bank, &bit, &offset);\n\n\tstatus_addr = bank_reg(gpio, bank, reg_irq_status);\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\tiowrite32(bit, status_addr);\n\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n}\n\nstatic void aspeed_sgpio_irq_set_mask(struct irq_data *d, bool set)\n{\n\tconst struct aspeed_sgpio_bank *bank;\n\tstruct aspeed_sgpio *gpio;\n\tunsigned long flags;\n\tu32 reg, bit;\n\tvoid __iomem *addr;\n\tint offset;\n\n\tirqd_to_aspeed_sgpio_data(d, &gpio, &bank, &bit, &offset);\n\taddr = bank_reg(gpio, bank, reg_irq_enable);\n\n\t \n\tif (set)\n\t\tgpiochip_enable_irq(&gpio->chip, irqd_to_hwirq(d));\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\treg = ioread32(addr);\n\tif (set)\n\t\treg |= bit;\n\telse\n\t\treg &= ~bit;\n\n\tiowrite32(reg, addr);\n\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\t \n\tif (!set)\n\t\tgpiochip_disable_irq(&gpio->chip, irqd_to_hwirq(d));\n\n\n}\n\nstatic void aspeed_sgpio_irq_mask(struct irq_data *d)\n{\n\taspeed_sgpio_irq_set_mask(d, false);\n}\n\nstatic void aspeed_sgpio_irq_unmask(struct irq_data *d)\n{\n\taspeed_sgpio_irq_set_mask(d, true);\n}\n\nstatic int aspeed_sgpio_set_type(struct irq_data *d, unsigned int type)\n{\n\tu32 type0 = 0;\n\tu32 type1 = 0;\n\tu32 type2 = 0;\n\tu32 bit, reg;\n\tconst struct aspeed_sgpio_bank *bank;\n\tirq_flow_handler_t handler;\n\tstruct aspeed_sgpio *gpio;\n\tunsigned long flags;\n\tvoid __iomem *addr;\n\tint offset;\n\n\tirqd_to_aspeed_sgpio_data(d, &gpio, &bank, &bit, &offset);\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\ttype2 |= bit;\n\t\tfallthrough;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\ttype0 |= bit;\n\t\tfallthrough;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\thandler = handle_edge_irq;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\ttype0 |= bit;\n\t\tfallthrough;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\ttype1 |= bit;\n\t\thandler = handle_level_irq;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\taddr = bank_reg(gpio, bank, reg_irq_type0);\n\treg = ioread32(addr);\n\treg = (reg & ~bit) | type0;\n\tiowrite32(reg, addr);\n\n\taddr = bank_reg(gpio, bank, reg_irq_type1);\n\treg = ioread32(addr);\n\treg = (reg & ~bit) | type1;\n\tiowrite32(reg, addr);\n\n\taddr = bank_reg(gpio, bank, reg_irq_type2);\n\treg = ioread32(addr);\n\treg = (reg & ~bit) | type2;\n\tiowrite32(reg, addr);\n\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\tirq_set_handler_locked(d, handler);\n\n\treturn 0;\n}\n\nstatic void aspeed_sgpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *ic = irq_desc_get_chip(desc);\n\tstruct aspeed_sgpio *data = gpiochip_get_data(gc);\n\tunsigned int i, p;\n\tunsigned long reg;\n\n\tchained_irq_enter(ic, desc);\n\n\tfor (i = 0; i < ARRAY_SIZE(aspeed_sgpio_banks); i++) {\n\t\tconst struct aspeed_sgpio_bank *bank = &aspeed_sgpio_banks[i];\n\n\t\treg = ioread32(bank_reg(data, bank, reg_irq_status));\n\n\t\tfor_each_set_bit(p, &reg, 32)\n\t\t\tgeneric_handle_domain_irq(gc->irq.domain, (i * 32 + p) * 2);\n\t}\n\n\tchained_irq_exit(ic, desc);\n}\n\nstatic void aspeed_sgpio_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tconst struct aspeed_sgpio_bank *bank;\n\tstruct aspeed_sgpio *gpio;\n\tu32 bit;\n\tint offset;\n\n\tirqd_to_aspeed_sgpio_data(d, &gpio, &bank, &bit, &offset);\n\tseq_printf(p, dev_name(gpio->dev));\n}\n\nstatic const struct irq_chip aspeed_sgpio_irq_chip = {\n\t.irq_ack = aspeed_sgpio_irq_ack,\n\t.irq_mask = aspeed_sgpio_irq_mask,\n\t.irq_unmask = aspeed_sgpio_irq_unmask,\n\t.irq_set_type = aspeed_sgpio_set_type,\n\t.irq_print_chip = aspeed_sgpio_irq_print_chip,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int aspeed_sgpio_setup_irqs(struct aspeed_sgpio *gpio,\n\t\t\t\t   struct platform_device *pdev)\n{\n\tint rc, i;\n\tconst struct aspeed_sgpio_bank *bank;\n\tstruct gpio_irq_chip *irq;\n\n\trc = platform_get_irq(pdev, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tgpio->irq = rc;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(aspeed_sgpio_banks); i++) {\n\t\tbank =  &aspeed_sgpio_banks[i];\n\t\t \n\t\tiowrite32(0x00000000, bank_reg(gpio, bank, reg_irq_enable));\n\t\t \n\t\tiowrite32(0xffffffff, bank_reg(gpio, bank, reg_irq_status));\n\t}\n\n\tirq = &gpio->chip.irq;\n\tgpio_irq_chip_set_chip(irq, &aspeed_sgpio_irq_chip);\n\tirq->init_valid_mask = aspeed_sgpio_irq_init_valid_mask;\n\tirq->handler = handle_bad_irq;\n\tirq->default_type = IRQ_TYPE_NONE;\n\tirq->parent_handler = aspeed_sgpio_irq_handler;\n\tirq->parent_handler_data = gpio;\n\tirq->parents = &gpio->irq;\n\tirq->num_parents = 1;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(aspeed_sgpio_banks); i++) {\n\t\tbank = &aspeed_sgpio_banks[i];\n\t\t \n\t\tiowrite32(0x00000000, bank_reg(gpio, bank, reg_irq_type0));\n\t\t \n\t\tiowrite32(0x00000000, bank_reg(gpio, bank, reg_irq_type1));\n\t\t \n\t\tiowrite32(0x00000000, bank_reg(gpio, bank, reg_irq_type2));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct aspeed_sgpio_pdata ast2400_sgpio_pdata = {\n\t.pin_mask = GENMASK(9, 6),\n};\n\nstatic int aspeed_sgpio_reset_tolerance(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int offset, bool enable)\n{\n\tstruct aspeed_sgpio *gpio = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tvoid __iomem *reg;\n\tu32 val;\n\n\treg = bank_reg(gpio, to_bank(offset), reg_tolerance);\n\n\traw_spin_lock_irqsave(&gpio->lock, flags);\n\n\tval = readl(reg);\n\n\tif (enable)\n\t\tval |= GPIO_BIT(offset);\n\telse\n\t\tval &= ~GPIO_BIT(offset);\n\n\twritel(val, reg);\n\n\traw_spin_unlock_irqrestore(&gpio->lock, flags);\n\n\treturn 0;\n}\n\nstatic int aspeed_sgpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t   unsigned long config)\n{\n\tunsigned long param = pinconf_to_config_param(config);\n\tu32 arg = pinconf_to_config_argument(config);\n\n\tif (param == PIN_CONFIG_PERSIST_STATE)\n\t\treturn aspeed_sgpio_reset_tolerance(chip, offset, arg);\n\n\treturn -ENOTSUPP;\n}\n\nstatic const struct aspeed_sgpio_pdata ast2600_sgpiom_pdata = {\n\t.pin_mask = GENMASK(10, 6),\n};\n\nstatic const struct of_device_id aspeed_sgpio_of_table[] = {\n\t{ .compatible = \"aspeed,ast2400-sgpio\", .data = &ast2400_sgpio_pdata, },\n\t{ .compatible = \"aspeed,ast2500-sgpio\", .data = &ast2400_sgpio_pdata, },\n\t{ .compatible = \"aspeed,ast2600-sgpiom\", .data = &ast2600_sgpiom_pdata, },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, aspeed_sgpio_of_table);\n\nstatic int __init aspeed_sgpio_probe(struct platform_device *pdev)\n{\n\tu32 nr_gpios, sgpio_freq, sgpio_clk_div, gpio_cnt_regval, pin_mask;\n\tconst struct aspeed_sgpio_pdata *pdata;\n\tstruct aspeed_sgpio *gpio;\n\tunsigned long apb_freq;\n\tint rc;\n\n\tgpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tgpio->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gpio->base))\n\t\treturn PTR_ERR(gpio->base);\n\n\tgpio->dev = &pdev->dev;\n\n\tpdata = device_get_match_data(&pdev->dev);\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tpin_mask = pdata->pin_mask;\n\n\trc = device_property_read_u32(&pdev->dev, \"ngpios\", &nr_gpios);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"Could not read ngpios property\\n\");\n\t\treturn -EINVAL;\n\t} else if (nr_gpios % 8) {\n\t\tdev_err(&pdev->dev, \"Number of GPIOs not multiple of 8: %d\\n\",\n\t\t\tnr_gpios);\n\t\treturn -EINVAL;\n\t}\n\n\trc = device_property_read_u32(&pdev->dev, \"bus-frequency\", &sgpio_freq);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"Could not read bus-frequency property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio->pclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(gpio->pclk)) {\n\t\tdev_err(&pdev->dev, \"devm_clk_get failed\\n\");\n\t\treturn PTR_ERR(gpio->pclk);\n\t}\n\n\tapb_freq = clk_get_rate(gpio->pclk);\n\n\t \n\tif (sgpio_freq == 0)\n\t\treturn -EINVAL;\n\n\tsgpio_clk_div = (apb_freq / (sgpio_freq * 2)) - 1;\n\n\tif (sgpio_clk_div > (1 << 16) - 1)\n\t\treturn -EINVAL;\n\n\tgpio_cnt_regval = ((nr_gpios / 8) << ASPEED_SGPIO_PINS_SHIFT) & pin_mask;\n\tiowrite32(FIELD_PREP(ASPEED_SGPIO_CLK_DIV_MASK, sgpio_clk_div) | gpio_cnt_regval |\n\t\t  ASPEED_SGPIO_ENABLE, gpio->base + ASPEED_SGPIO_CTRL);\n\n\traw_spin_lock_init(&gpio->lock);\n\n\tgpio->chip.parent = &pdev->dev;\n\tgpio->chip.ngpio = nr_gpios * 2;\n\tgpio->chip.init_valid_mask = aspeed_sgpio_init_valid_mask;\n\tgpio->chip.direction_input = aspeed_sgpio_dir_in;\n\tgpio->chip.direction_output = aspeed_sgpio_dir_out;\n\tgpio->chip.get_direction = aspeed_sgpio_get_direction;\n\tgpio->chip.request = NULL;\n\tgpio->chip.free = NULL;\n\tgpio->chip.get = aspeed_sgpio_get;\n\tgpio->chip.set = aspeed_sgpio_set;\n\tgpio->chip.set_config = aspeed_sgpio_set_config;\n\tgpio->chip.label = dev_name(&pdev->dev);\n\tgpio->chip.base = -1;\n\n\taspeed_sgpio_setup_irqs(gpio, pdev);\n\n\trc = devm_gpiochip_add_data(&pdev->dev, &gpio->chip, gpio);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic struct platform_driver aspeed_sgpio_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = aspeed_sgpio_of_table,\n\t},\n};\n\nmodule_platform_driver_probe(aspeed_sgpio_driver, aspeed_sgpio_probe);\nMODULE_DESCRIPTION(\"Aspeed Serial GPIO Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}