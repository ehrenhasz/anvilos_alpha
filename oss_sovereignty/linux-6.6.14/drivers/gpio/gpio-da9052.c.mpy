{
  "module_name": "gpio-da9052.c",
  "hash_id": "6cf3ebe6c784926a0719aed919627c45bcc9e1f7676168d9505156274c4a98a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-da9052.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n\n#include <linux/mfd/da9052/da9052.h>\n#include <linux/mfd/da9052/pdata.h>\n#include <linux/mfd/da9052/reg.h>\n\n#define DA9052_INPUT\t\t\t\t1\n#define DA9052_OUTPUT_OPENDRAIN\t\t2\n#define DA9052_OUTPUT_PUSHPULL\t\t\t3\n\n#define DA9052_SUPPLY_VDD_IO1\t\t\t0\n\n#define DA9052_DEBOUNCING_OFF\t\t\t0\n#define DA9052_DEBOUNCING_ON\t\t\t1\n\n#define DA9052_OUTPUT_LOWLEVEL\t\t\t0\n\n#define DA9052_ACTIVE_LOW\t\t\t0\n#define DA9052_ACTIVE_HIGH\t\t\t1\n\n#define DA9052_GPIO_MAX_PORTS_PER_REGISTER\t8\n#define DA9052_GPIO_SHIFT_COUNT(no)\t\t(no%8)\n#define DA9052_GPIO_MASK_UPPER_NIBBLE\t\t0xF0\n#define DA9052_GPIO_MASK_LOWER_NIBBLE\t\t0x0F\n#define DA9052_GPIO_NIBBLE_SHIFT\t\t4\n#define DA9052_IRQ_GPI0\t\t\t16\n#define DA9052_GPIO_ODD_SHIFT\t\t\t7\n#define DA9052_GPIO_EVEN_SHIFT\t\t\t3\n\nstruct da9052_gpio {\n\tstruct da9052 *da9052;\n\tstruct gpio_chip gp;\n};\n\nstatic unsigned char da9052_gpio_port_odd(unsigned offset)\n{\n\treturn offset % 2;\n}\n\nstatic int da9052_gpio_get(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct da9052_gpio *gpio = gpiochip_get_data(gc);\n\tint da9052_port_direction = 0;\n\tint ret;\n\n\tret = da9052_reg_read(gpio->da9052,\n\t\t\t      DA9052_GPIO_0_1_REG + (offset >> 1));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (da9052_gpio_port_odd(offset)) {\n\t\tda9052_port_direction = ret & DA9052_GPIO_ODD_PORT_PIN;\n\t\tda9052_port_direction >>= 4;\n\t} else {\n\t\tda9052_port_direction = ret & DA9052_GPIO_EVEN_PORT_PIN;\n\t}\n\n\tswitch (da9052_port_direction) {\n\tcase DA9052_INPUT:\n\t\tif (offset < DA9052_GPIO_MAX_PORTS_PER_REGISTER)\n\t\t\tret = da9052_reg_read(gpio->da9052,\n\t\t\t\t\t      DA9052_STATUS_C_REG);\n\t\telse\n\t\t\tret = da9052_reg_read(gpio->da9052,\n\t\t\t\t\t      DA9052_STATUS_D_REG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn !!(ret & (1 << DA9052_GPIO_SHIFT_COUNT(offset)));\n\tcase DA9052_OUTPUT_PUSHPULL:\n\t\tif (da9052_gpio_port_odd(offset))\n\t\t\treturn !!(ret & DA9052_GPIO_ODD_PORT_MODE);\n\t\telse\n\t\t\treturn !!(ret & DA9052_GPIO_EVEN_PORT_MODE);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void da9052_gpio_set(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tstruct da9052_gpio *gpio = gpiochip_get_data(gc);\n\tint ret;\n\n\tif (da9052_gpio_port_odd(offset)) {\n\t\t\tret = da9052_reg_update(gpio->da9052, (offset >> 1) +\n\t\t\t\t\t\tDA9052_GPIO_0_1_REG,\n\t\t\t\t\t\tDA9052_GPIO_ODD_PORT_MODE,\n\t\t\t\t\t\tvalue << DA9052_GPIO_ODD_SHIFT);\n\t\t\tif (ret != 0)\n\t\t\t\tdev_err(gpio->da9052->dev,\n\t\t\t\t\t\"Failed to updated gpio odd reg,%d\",\n\t\t\t\t\tret);\n\t} else {\n\t\t\tret = da9052_reg_update(gpio->da9052, (offset >> 1) +\n\t\t\t\t\t\tDA9052_GPIO_0_1_REG,\n\t\t\t\t\t\tDA9052_GPIO_EVEN_PORT_MODE,\n\t\t\t\t\t\tvalue << DA9052_GPIO_EVEN_SHIFT);\n\t\t\tif (ret != 0)\n\t\t\t\tdev_err(gpio->da9052->dev,\n\t\t\t\t\t\"Failed to updated gpio even reg,%d\",\n\t\t\t\t\tret);\n\t}\n}\n\nstatic int da9052_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct da9052_gpio *gpio = gpiochip_get_data(gc);\n\tunsigned char register_value;\n\tint ret;\n\n\t \n\tregister_value = DA9052_INPUT | DA9052_ACTIVE_LOW << 2 |\n\t\t\t DA9052_DEBOUNCING_ON << 3;\n\n\tif (da9052_gpio_port_odd(offset))\n\t\tret = da9052_reg_update(gpio->da9052, (offset >> 1) +\n\t\t\t\t\tDA9052_GPIO_0_1_REG,\n\t\t\t\t\tDA9052_GPIO_MASK_UPPER_NIBBLE,\n\t\t\t\t\t(register_value <<\n\t\t\t\t\tDA9052_GPIO_NIBBLE_SHIFT));\n\telse\n\t\tret = da9052_reg_update(gpio->da9052, (offset >> 1) +\n\t\t\t\t\tDA9052_GPIO_0_1_REG,\n\t\t\t\t\tDA9052_GPIO_MASK_LOWER_NIBBLE,\n\t\t\t\t\tregister_value);\n\n\treturn ret;\n}\n\nstatic int da9052_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct da9052_gpio *gpio = gpiochip_get_data(gc);\n\tunsigned char register_value;\n\tint ret;\n\n\t \n\tregister_value = DA9052_OUTPUT_PUSHPULL | DA9052_SUPPLY_VDD_IO1 << 2 |\n\t\t\t value << 3;\n\n\tif (da9052_gpio_port_odd(offset))\n\t\tret = da9052_reg_update(gpio->da9052, (offset >> 1) +\n\t\t\t\t\tDA9052_GPIO_0_1_REG,\n\t\t\t\t\tDA9052_GPIO_MASK_UPPER_NIBBLE,\n\t\t\t\t\t(register_value <<\n\t\t\t\t\tDA9052_GPIO_NIBBLE_SHIFT));\n\telse\n\t\tret = da9052_reg_update(gpio->da9052, (offset >> 1) +\n\t\t\t\t\tDA9052_GPIO_0_1_REG,\n\t\t\t\t\tDA9052_GPIO_MASK_LOWER_NIBBLE,\n\t\t\t\t\tregister_value);\n\n\treturn ret;\n}\n\nstatic int da9052_gpio_to_irq(struct gpio_chip *gc, u32 offset)\n{\n\tstruct da9052_gpio *gpio = gpiochip_get_data(gc);\n\tstruct da9052 *da9052 = gpio->da9052;\n\n\tint irq;\n\n\tirq = regmap_irq_get_virq(da9052->irq_data, DA9052_IRQ_GPI0 + offset);\n\n\treturn irq;\n}\n\nstatic const struct gpio_chip reference_gp = {\n\t.label = \"da9052-gpio\",\n\t.owner = THIS_MODULE,\n\t.get = da9052_gpio_get,\n\t.set = da9052_gpio_set,\n\t.direction_input = da9052_gpio_direction_input,\n\t.direction_output = da9052_gpio_direction_output,\n\t.to_irq = da9052_gpio_to_irq,\n\t.can_sleep = true,\n\t.ngpio = 16,\n\t.base = -1,\n};\n\nstatic int da9052_gpio_probe(struct platform_device *pdev)\n{\n\tstruct da9052_gpio *gpio;\n\tstruct da9052_pdata *pdata;\n\n\tgpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tgpio->da9052 = dev_get_drvdata(pdev->dev.parent);\n\tpdata = dev_get_platdata(gpio->da9052->dev);\n\n\tgpio->gp = reference_gp;\n\tif (pdata && pdata->gpio_base)\n\t\tgpio->gp.base = pdata->gpio_base;\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &gpio->gp, gpio);\n}\n\nstatic struct platform_driver da9052_gpio_driver = {\n\t.probe = da9052_gpio_probe,\n\t.driver = {\n\t\t.name\t= \"da9052-gpio\",\n\t},\n};\n\nmodule_platform_driver(da9052_gpio_driver);\n\nMODULE_AUTHOR(\"David Dajun Chen <dchen@diasemi.com>\");\nMODULE_DESCRIPTION(\"DA9052 GPIO Device Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9052-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}