{
  "module_name": "gpio-madera.c",
  "hash_id": "178b6339dea535fa4145ac734c8d31594e509343ab6d605259f723f44bcecf3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-madera.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include <linux/mfd/madera/core.h>\n#include <linux/mfd/madera/pdata.h>\n#include <linux/mfd/madera/registers.h>\n\nstruct madera_gpio {\n\tstruct madera *madera;\n\t \n\tstruct gpio_chip gpio_chip;\n};\n\nstatic int madera_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset)\n{\n\tstruct madera_gpio *madera_gpio = gpiochip_get_data(chip);\n\tstruct madera *madera = madera_gpio->madera;\n\tunsigned int reg_offset = 2 * offset;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(madera->regmap, MADERA_GPIO1_CTRL_2 + reg_offset,\n\t\t\t  &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val & MADERA_GP1_DIR_MASK)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int madera_gpio_direction_in(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct madera_gpio *madera_gpio = gpiochip_get_data(chip);\n\tstruct madera *madera = madera_gpio->madera;\n\tunsigned int reg_offset = 2 * offset;\n\n\treturn regmap_update_bits(madera->regmap,\n\t\t\t\t  MADERA_GPIO1_CTRL_2 + reg_offset,\n\t\t\t\t  MADERA_GP1_DIR_MASK, MADERA_GP1_DIR);\n}\n\nstatic int madera_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct madera_gpio *madera_gpio = gpiochip_get_data(chip);\n\tstruct madera *madera = madera_gpio->madera;\n\tunsigned int reg_offset = 2 * offset;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(madera->regmap, MADERA_GPIO1_CTRL_1 + reg_offset,\n\t\t\t  &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(val & MADERA_GP1_LVL_MASK);\n}\n\nstatic int madera_gpio_direction_out(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset, int value)\n{\n\tstruct madera_gpio *madera_gpio = gpiochip_get_data(chip);\n\tstruct madera *madera = madera_gpio->madera;\n\tunsigned int reg_offset = 2 * offset;\n\tunsigned int reg_val = value ? MADERA_GP1_LVL : 0;\n\tint ret;\n\n\tret = regmap_update_bits(madera->regmap,\n\t\t\t\t MADERA_GPIO1_CTRL_2 + reg_offset,\n\t\t\t\t MADERA_GP1_DIR_MASK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_update_bits(madera->regmap,\n\t\t\t\t  MADERA_GPIO1_CTRL_1 + reg_offset,\n\t\t\t\t  MADERA_GP1_LVL_MASK, reg_val);\n}\n\nstatic void madera_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t    int value)\n{\n\tstruct madera_gpio *madera_gpio = gpiochip_get_data(chip);\n\tstruct madera *madera = madera_gpio->madera;\n\tunsigned int reg_offset = 2 * offset;\n\tunsigned int reg_val = value ? MADERA_GP1_LVL : 0;\n\tint ret;\n\n\tret = regmap_update_bits(madera->regmap,\n\t\t\t\t MADERA_GPIO1_CTRL_1 + reg_offset,\n\t\t\t\t MADERA_GP1_LVL_MASK, reg_val);\n\n\t \n\tif (ret)\n\t\tdev_warn(madera->dev, \"Failed to write to 0x%x (%d)\\n\",\n\t\t\t MADERA_GPIO1_CTRL_1 + reg_offset, ret);\n}\n\nstatic const struct gpio_chip madera_gpio_chip = {\n\t.label\t\t\t= \"madera\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.request\t\t= gpiochip_generic_request,\n\t.free\t\t\t= gpiochip_generic_free,\n\t.get_direction\t\t= madera_gpio_get_direction,\n\t.direction_input\t= madera_gpio_direction_in,\n\t.get\t\t\t= madera_gpio_get,\n\t.direction_output\t= madera_gpio_direction_out,\n\t.set\t\t\t= madera_gpio_set,\n\t.set_config\t\t= gpiochip_generic_config,\n\t.can_sleep\t\t= true,\n};\n\nstatic int madera_gpio_probe(struct platform_device *pdev)\n{\n\tstruct madera *madera = dev_get_drvdata(pdev->dev.parent);\n\tstruct madera_pdata *pdata = &madera->pdata;\n\tstruct madera_gpio *madera_gpio;\n\tint ret;\n\n\tmadera_gpio = devm_kzalloc(&pdev->dev, sizeof(*madera_gpio),\n\t\t\t\t   GFP_KERNEL);\n\tif (!madera_gpio)\n\t\treturn -ENOMEM;\n\n\tmadera_gpio->madera = madera;\n\n\t \n\tmadera_gpio->gpio_chip = madera_gpio_chip;\n\tmadera_gpio->gpio_chip.parent = pdev->dev.parent;\n\n\tswitch (madera->type) {\n\tcase CS47L15:\n\t\tmadera_gpio->gpio_chip.ngpio = CS47L15_NUM_GPIOS;\n\t\tbreak;\n\tcase CS47L35:\n\t\tmadera_gpio->gpio_chip.ngpio = CS47L35_NUM_GPIOS;\n\t\tbreak;\n\tcase CS47L85:\n\tcase WM1840:\n\t\tmadera_gpio->gpio_chip.ngpio = CS47L85_NUM_GPIOS;\n\t\tbreak;\n\tcase CS47L90:\n\tcase CS47L91:\n\t\tmadera_gpio->gpio_chip.ngpio = CS47L90_NUM_GPIOS;\n\t\tbreak;\n\tcase CS42L92:\n\tcase CS47L92:\n\tcase CS47L93:\n\t\tmadera_gpio->gpio_chip.ngpio = CS47L92_NUM_GPIOS;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unknown chip variant %d\\n\", madera->type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (pdata->gpio_base)\n\t\tmadera_gpio->gpio_chip.base = pdata->gpio_base;\n\telse\n\t\tmadera_gpio->gpio_chip.base = -1;\n\n\tret = devm_gpiochip_add_data(&pdev->dev,\n\t\t\t\t     &madera_gpio->gpio_chip,\n\t\t\t\t     madera_gpio);\n\tif (ret < 0) {\n\t\tdev_dbg(&pdev->dev, \"Could not register gpiochip, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = gpiochip_add_pin_range(&madera_gpio->gpio_chip, \"madera-pinctrl\",\n\t\t\t\t     0, 0, madera_gpio->gpio_chip.ngpio);\n\tif (ret) {\n\t\tdev_dbg(&pdev->dev, \"Failed to add pin range (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver madera_gpio_driver = {\n\t.driver = {\n\t\t.name\t= \"madera-gpio\",\n\t},\n\t.probe\t\t= madera_gpio_probe,\n};\n\nmodule_platform_driver(madera_gpio_driver);\n\nMODULE_SOFTDEP(\"pre: pinctrl-madera\");\nMODULE_DESCRIPTION(\"GPIO interface for Madera codecs\");\nMODULE_AUTHOR(\"Nariman Poushin <nariman@opensource.cirrus.com>\");\nMODULE_AUTHOR(\"Richard Fitzgerald <rf@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:madera-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}