{
  "module_name": "gpio-pcf857x.c",
  "hash_id": "8cf81bb2ca0ea924667b6040ee89e405ecee03ef1d5d79665be731a403fb1bbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-pcf857x.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\nstatic const struct i2c_device_id pcf857x_id[] = {\n\t{ \"pcf8574\", 8 },\n\t{ \"pcf8574a\", 8 },\n\t{ \"pca8574\", 8 },\n\t{ \"pca9670\", 8 },\n\t{ \"pca9672\", 8 },\n\t{ \"pca9674\", 8 },\n\t{ \"pcf8575\", 16 },\n\t{ \"pca8575\", 16 },\n\t{ \"pca9671\", 16 },\n\t{ \"pca9673\", 16 },\n\t{ \"pca9675\", 16 },\n\t{ \"max7328\", 8 },\n\t{ \"max7329\", 8 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pcf857x_id);\n\nstatic const struct of_device_id pcf857x_of_table[] = {\n\t{ .compatible = \"nxp,pcf8574\", (void *)8 },\n\t{ .compatible = \"nxp,pcf8574a\", (void *)8 },\n\t{ .compatible = \"nxp,pca8574\", (void *)8 },\n\t{ .compatible = \"nxp,pca9670\", (void *)8 },\n\t{ .compatible = \"nxp,pca9672\", (void *)8 },\n\t{ .compatible = \"nxp,pca9674\", (void *)8 },\n\t{ .compatible = \"nxp,pcf8575\", (void *)16 },\n\t{ .compatible = \"nxp,pca8575\", (void *)16 },\n\t{ .compatible = \"nxp,pca9671\", (void *)16 },\n\t{ .compatible = \"nxp,pca9673\", (void *)16 },\n\t{ .compatible = \"nxp,pca9675\", (void *)16 },\n\t{ .compatible = \"maxim,max7328\", (void *)8 },\n\t{ .compatible = \"maxim,max7329\", (void *)8 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pcf857x_of_table);\n\n \nstruct pcf857x {\n\tstruct gpio_chip\tchip;\n\tstruct i2c_client\t*client;\n\tstruct mutex\t\tlock;\t\t \n\tunsigned int\t\tout;\t\t \n\tunsigned int\t\tstatus;\t\t \n\tunsigned int\t\tirq_enabled;\t \n\n\tint (*write)(struct i2c_client *client, unsigned int data);\n\tint (*read)(struct i2c_client *client);\n};\n\n \n\n \n\nstatic int i2c_write_le8(struct i2c_client *client, unsigned int data)\n{\n\treturn i2c_smbus_write_byte(client, data);\n}\n\nstatic int i2c_read_le8(struct i2c_client *client)\n{\n\treturn i2c_smbus_read_byte(client);\n}\n\n \n\nstatic int i2c_write_le16(struct i2c_client *client, unsigned int word)\n{\n\tu8 buf[2] = { word & 0xff, word >> 8, };\n\tint status;\n\n\tstatus = i2c_master_send(client, buf, 2);\n\treturn (status < 0) ? status : 0;\n}\n\nstatic int i2c_read_le16(struct i2c_client *client)\n{\n\tu8 buf[2];\n\tint status;\n\n\tstatus = i2c_master_recv(client, buf, 2);\n\tif (status < 0)\n\t\treturn status;\n\treturn (buf[1] << 8) | buf[0];\n}\n\n \n\nstatic int pcf857x_input(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct pcf857x *gpio = gpiochip_get_data(chip);\n\tint status;\n\n\tmutex_lock(&gpio->lock);\n\tgpio->out |= (1 << offset);\n\tstatus = gpio->write(gpio->client, gpio->out);\n\tmutex_unlock(&gpio->lock);\n\n\treturn status;\n}\n\nstatic int pcf857x_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct pcf857x *gpio = gpiochip_get_data(chip);\n\tint value;\n\n\tvalue = gpio->read(gpio->client);\n\treturn (value < 0) ? value : !!(value & (1 << offset));\n}\n\nstatic int pcf857x_get_multiple(struct gpio_chip *chip, unsigned long *mask,\n\t\t\t\tunsigned long *bits)\n{\n\tstruct pcf857x *gpio = gpiochip_get_data(chip);\n\tint value = gpio->read(gpio->client);\n\n\tif (value < 0)\n\t\treturn value;\n\n\t*bits &= ~*mask;\n\t*bits |= value & *mask;\n\n\treturn 0;\n}\n\nstatic int pcf857x_output(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct pcf857x *gpio = gpiochip_get_data(chip);\n\tunsigned int bit = 1 << offset;\n\tint status;\n\n\tmutex_lock(&gpio->lock);\n\tif (value)\n\t\tgpio->out |= bit;\n\telse\n\t\tgpio->out &= ~bit;\n\tstatus = gpio->write(gpio->client, gpio->out);\n\tmutex_unlock(&gpio->lock);\n\n\treturn status;\n}\n\nstatic void pcf857x_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tpcf857x_output(chip, offset, value);\n}\n\nstatic void pcf857x_set_multiple(struct gpio_chip *chip, unsigned long *mask,\n\t\t\t\t unsigned long *bits)\n{\n\tstruct pcf857x *gpio = gpiochip_get_data(chip);\n\n\tmutex_lock(&gpio->lock);\n\tgpio->out &= ~*mask;\n\tgpio->out |= *bits & *mask;\n\tgpio->write(gpio->client, gpio->out);\n\tmutex_unlock(&gpio->lock);\n}\n\n \n\nstatic irqreturn_t pcf857x_irq(int irq, void *data)\n{\n\tstruct pcf857x *gpio = data;\n\tunsigned long change, i, status;\n\n\tstatus = gpio->read(gpio->client);\n\n\t \n\tmutex_lock(&gpio->lock);\n\tchange = (gpio->status ^ status) & gpio->irq_enabled;\n\tgpio->status = status;\n\tmutex_unlock(&gpio->lock);\n\n\tfor_each_set_bit(i, &change, gpio->chip.ngpio)\n\t\thandle_nested_irq(irq_find_mapping(gpio->chip.irq.domain, i));\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void noop(struct irq_data *data) { }\n\nstatic int pcf857x_irq_set_wake(struct irq_data *data, unsigned int on)\n{\n\tstruct pcf857x *gpio = irq_data_get_irq_chip_data(data);\n\n\treturn irq_set_irq_wake(gpio->client->irq, on);\n}\n\nstatic void pcf857x_irq_enable(struct irq_data *data)\n{\n\tstruct pcf857x *gpio = irq_data_get_irq_chip_data(data);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\n\tgpiochip_enable_irq(&gpio->chip, hwirq);\n\tgpio->irq_enabled |= (1 << hwirq);\n}\n\nstatic void pcf857x_irq_disable(struct irq_data *data)\n{\n\tstruct pcf857x *gpio = irq_data_get_irq_chip_data(data);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\n\tgpio->irq_enabled &= ~(1 << hwirq);\n\tgpiochip_disable_irq(&gpio->chip, hwirq);\n}\n\nstatic void pcf857x_irq_bus_lock(struct irq_data *data)\n{\n\tstruct pcf857x *gpio = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&gpio->lock);\n}\n\nstatic void pcf857x_irq_bus_sync_unlock(struct irq_data *data)\n{\n\tstruct pcf857x *gpio = irq_data_get_irq_chip_data(data);\n\n\tmutex_unlock(&gpio->lock);\n}\n\nstatic const struct irq_chip pcf857x_irq_chip = {\n\t.name\t\t\t= \"pcf857x\",\n\t.irq_enable\t\t= pcf857x_irq_enable,\n\t.irq_disable\t\t= pcf857x_irq_disable,\n\t.irq_ack\t\t= noop,\n\t.irq_mask\t\t= noop,\n\t.irq_unmask\t\t= noop,\n\t.irq_set_wake\t\t= pcf857x_irq_set_wake,\n\t.irq_bus_lock\t\t= pcf857x_irq_bus_lock,\n\t.irq_bus_sync_unlock\t= pcf857x_irq_bus_sync_unlock,\n\t.flags\t\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\n \n\nstatic int pcf857x_probe(struct i2c_client *client)\n{\n\tstruct pcf857x *gpio;\n\tunsigned int n_latch = 0;\n\tint status;\n\n\tdevice_property_read_u32(&client->dev, \"lines-initial-states\", &n_latch);\n\n\t \n\tgpio = devm_kzalloc(&client->dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&gpio->lock);\n\n\tgpio->chip.base\t\t\t= -1;\n\tgpio->chip.can_sleep\t\t= true;\n\tgpio->chip.parent\t\t= &client->dev;\n\tgpio->chip.owner\t\t= THIS_MODULE;\n\tgpio->chip.get\t\t\t= pcf857x_get;\n\tgpio->chip.get_multiple\t\t= pcf857x_get_multiple;\n\tgpio->chip.set\t\t\t= pcf857x_set;\n\tgpio->chip.set_multiple\t\t= pcf857x_set_multiple;\n\tgpio->chip.direction_input\t= pcf857x_input;\n\tgpio->chip.direction_output\t= pcf857x_output;\n\tgpio->chip.ngpio\t\t= (uintptr_t)i2c_get_match_data(client);\n\n\t \n\n\t \n\tif (gpio->chip.ngpio == 8) {\n\t\tgpio->write\t= i2c_write_le8;\n\t\tgpio->read\t= i2c_read_le8;\n\n\t\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\tI2C_FUNC_SMBUS_BYTE))\n\t\t\tstatus = -EIO;\n\n\t\t \n\t\telse\n\t\t\tstatus = i2c_smbus_read_byte(client);\n\n\t \n\t} else if (gpio->chip.ngpio == 16) {\n\t\tgpio->write\t= i2c_write_le16;\n\t\tgpio->read\t= i2c_read_le16;\n\n\t\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\t\tstatus = -EIO;\n\n\t\t \n\t\telse\n\t\t\tstatus = i2c_read_le16(client);\n\n\t} else {\n\t\tdev_dbg(&client->dev, \"unsupported number of gpios\\n\");\n\t\tstatus = -EINVAL;\n\t}\n\n\tif (status < 0)\n\t\tgoto fail;\n\n\tgpio->chip.label = client->name;\n\n\tgpio->client = client;\n\ti2c_set_clientdata(client, gpio);\n\n\t \n\tgpio->out = ~n_latch;\n\tgpio->status = gpio->read(gpio->client);\n\n\t \n\tif (client->irq) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\tstatus = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, pcf857x_irq, IRQF_ONESHOT |\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_SHARED,\n\t\t\t\t\tdev_name(&client->dev), gpio);\n\t\tif (status)\n\t\t\tgoto fail;\n\n\t\tgirq = &gpio->chip.irq;\n\t\tgpio_irq_chip_set_chip(girq, &pcf857x_irq_chip);\n\t\t \n\t\tgirq->parent_handler = NULL;\n\t\tgirq->num_parents = 0;\n\t\tgirq->parents = NULL;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_level_irq;\n\t\tgirq->threaded = true;\n\t}\n\n\tstatus = devm_gpiochip_add_data(&client->dev, &gpio->chip, gpio);\n\tif (status < 0)\n\t\tgoto fail;\n\n\tdev_info(&client->dev, \"probed\\n\");\n\n\treturn 0;\n\nfail:\n\tdev_dbg(&client->dev, \"probe error %d for '%s'\\n\", status,\n\t\tclient->name);\n\n\treturn status;\n}\n\nstatic void pcf857x_shutdown(struct i2c_client *client)\n{\n\tstruct pcf857x *gpio = i2c_get_clientdata(client);\n\n\t \n\tgpio->write(gpio->client, BIT(gpio->chip.ngpio) - 1);\n}\n\nstatic struct i2c_driver pcf857x_driver = {\n\t.driver = {\n\t\t.name\t= \"pcf857x\",\n\t\t.of_match_table = pcf857x_of_table,\n\t},\n\t.probe = pcf857x_probe,\n\t.shutdown = pcf857x_shutdown,\n\t.id_table = pcf857x_id,\n};\n\nstatic int __init pcf857x_init(void)\n{\n\treturn i2c_add_driver(&pcf857x_driver);\n}\n \nsubsys_initcall(pcf857x_init);\n\nstatic void __exit pcf857x_exit(void)\n{\n\ti2c_del_driver(&pcf857x_driver);\n}\nmodule_exit(pcf857x_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Brownell\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}