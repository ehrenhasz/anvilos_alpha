{
  "module_name": "gpio-mxc.c",
  "hash_id": "ffb145d74a868205fb81a33f2eb42ec5a10cd4f4ca49ebb514bcd47fe020492a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mxc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/syscore_ops.h>\n#include <linux/gpio/driver.h>\n#include <linux/of.h>\n#include <linux/bug.h>\n\n#define IMX_SCU_WAKEUP_OFF\t\t0\n#define IMX_SCU_WAKEUP_LOW_LVL\t\t4\n#define IMX_SCU_WAKEUP_FALL_EDGE\t5\n#define IMX_SCU_WAKEUP_RISE_EDGE\t6\n#define IMX_SCU_WAKEUP_HIGH_LVL\t\t7\n\n \nstruct mxc_gpio_hwdata {\n\tunsigned dr_reg;\n\tunsigned gdir_reg;\n\tunsigned psr_reg;\n\tunsigned icr1_reg;\n\tunsigned icr2_reg;\n\tunsigned imr_reg;\n\tunsigned isr_reg;\n\tint edge_sel_reg;\n\tunsigned low_level;\n\tunsigned high_level;\n\tunsigned rise_edge;\n\tunsigned fall_edge;\n};\n\nstruct mxc_gpio_reg_saved {\n\tu32 icr1;\n\tu32 icr2;\n\tu32 imr;\n\tu32 gdir;\n\tu32 edge_sel;\n\tu32 dr;\n};\n\nstruct mxc_gpio_port {\n\tstruct list_head node;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tint irq;\n\tint irq_high;\n\tvoid (*mx_irq_handler)(struct irq_desc *desc);\n\tstruct irq_domain *domain;\n\tstruct gpio_chip gc;\n\tstruct device *dev;\n\tu32 both_edges;\n\tstruct mxc_gpio_reg_saved gpio_saved_reg;\n\tbool power_off;\n\tu32 wakeup_pads;\n\tbool is_pad_wakeup;\n\tu32 pad_type[32];\n\tconst struct mxc_gpio_hwdata *hwdata;\n};\n\nstatic struct mxc_gpio_hwdata imx1_imx21_gpio_hwdata = {\n\t.dr_reg\t\t= 0x1c,\n\t.gdir_reg\t= 0x00,\n\t.psr_reg\t= 0x24,\n\t.icr1_reg\t= 0x28,\n\t.icr2_reg\t= 0x2c,\n\t.imr_reg\t= 0x30,\n\t.isr_reg\t= 0x34,\n\t.edge_sel_reg\t= -EINVAL,\n\t.low_level\t= 0x03,\n\t.high_level\t= 0x02,\n\t.rise_edge\t= 0x00,\n\t.fall_edge\t= 0x01,\n};\n\nstatic struct mxc_gpio_hwdata imx31_gpio_hwdata = {\n\t.dr_reg\t\t= 0x00,\n\t.gdir_reg\t= 0x04,\n\t.psr_reg\t= 0x08,\n\t.icr1_reg\t= 0x0c,\n\t.icr2_reg\t= 0x10,\n\t.imr_reg\t= 0x14,\n\t.isr_reg\t= 0x18,\n\t.edge_sel_reg\t= -EINVAL,\n\t.low_level\t= 0x00,\n\t.high_level\t= 0x01,\n\t.rise_edge\t= 0x02,\n\t.fall_edge\t= 0x03,\n};\n\nstatic struct mxc_gpio_hwdata imx35_gpio_hwdata = {\n\t.dr_reg\t\t= 0x00,\n\t.gdir_reg\t= 0x04,\n\t.psr_reg\t= 0x08,\n\t.icr1_reg\t= 0x0c,\n\t.icr2_reg\t= 0x10,\n\t.imr_reg\t= 0x14,\n\t.isr_reg\t= 0x18,\n\t.edge_sel_reg\t= 0x1c,\n\t.low_level\t= 0x00,\n\t.high_level\t= 0x01,\n\t.rise_edge\t= 0x02,\n\t.fall_edge\t= 0x03,\n};\n\n#define GPIO_DR\t\t\t(port->hwdata->dr_reg)\n#define GPIO_GDIR\t\t(port->hwdata->gdir_reg)\n#define GPIO_PSR\t\t(port->hwdata->psr_reg)\n#define GPIO_ICR1\t\t(port->hwdata->icr1_reg)\n#define GPIO_ICR2\t\t(port->hwdata->icr2_reg)\n#define GPIO_IMR\t\t(port->hwdata->imr_reg)\n#define GPIO_ISR\t\t(port->hwdata->isr_reg)\n#define GPIO_EDGE_SEL\t\t(port->hwdata->edge_sel_reg)\n\n#define GPIO_INT_LOW_LEV\t(port->hwdata->low_level)\n#define GPIO_INT_HIGH_LEV\t(port->hwdata->high_level)\n#define GPIO_INT_RISE_EDGE\t(port->hwdata->rise_edge)\n#define GPIO_INT_FALL_EDGE\t(port->hwdata->fall_edge)\n#define GPIO_INT_BOTH_EDGES\t0x4\n\nstatic const struct of_device_id mxc_gpio_dt_ids[] = {\n\t{ .compatible = \"fsl,imx1-gpio\", .data =  &imx1_imx21_gpio_hwdata },\n\t{ .compatible = \"fsl,imx21-gpio\", .data = &imx1_imx21_gpio_hwdata },\n\t{ .compatible = \"fsl,imx31-gpio\", .data = &imx31_gpio_hwdata },\n\t{ .compatible = \"fsl,imx35-gpio\", .data = &imx35_gpio_hwdata },\n\t{ .compatible = \"fsl,imx7d-gpio\", .data = &imx35_gpio_hwdata },\n\t{ .compatible = \"fsl,imx8dxl-gpio\", .data = &imx35_gpio_hwdata },\n\t{ .compatible = \"fsl,imx8qm-gpio\", .data = &imx35_gpio_hwdata },\n\t{ .compatible = \"fsl,imx8qxp-gpio\", .data = &imx35_gpio_hwdata },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxc_gpio_dt_ids);\n\n \nstatic LIST_HEAD(mxc_gpio_ports);\n\n \n\nstatic int gpio_set_irq_type(struct irq_data *d, u32 type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct mxc_gpio_port *port = gc->private;\n\tunsigned long flags;\n\tu32 bit, val;\n\tu32 gpio_idx = d->hwirq;\n\tint edge;\n\tvoid __iomem *reg = port->base;\n\n\tport->both_edges &= ~(1 << gpio_idx);\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tedge = GPIO_INT_RISE_EDGE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tedge = GPIO_INT_FALL_EDGE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tif (GPIO_EDGE_SEL >= 0) {\n\t\t\tedge = GPIO_INT_BOTH_EDGES;\n\t\t} else {\n\t\t\tval = port->gc.get(&port->gc, gpio_idx);\n\t\t\tif (val) {\n\t\t\t\tedge = GPIO_INT_LOW_LEV;\n\t\t\t\tpr_debug(\"mxc: set GPIO %d to low trigger\\n\", gpio_idx);\n\t\t\t} else {\n\t\t\t\tedge = GPIO_INT_HIGH_LEV;\n\t\t\t\tpr_debug(\"mxc: set GPIO %d to high trigger\\n\", gpio_idx);\n\t\t\t}\n\t\t\tport->both_edges |= 1 << gpio_idx;\n\t\t}\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tedge = GPIO_INT_LOW_LEV;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tedge = GPIO_INT_HIGH_LEV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&port->gc.bgpio_lock, flags);\n\n\tif (GPIO_EDGE_SEL >= 0) {\n\t\tval = readl(port->base + GPIO_EDGE_SEL);\n\t\tif (edge == GPIO_INT_BOTH_EDGES)\n\t\t\twritel(val | (1 << gpio_idx),\n\t\t\t\tport->base + GPIO_EDGE_SEL);\n\t\telse\n\t\t\twritel(val & ~(1 << gpio_idx),\n\t\t\t\tport->base + GPIO_EDGE_SEL);\n\t}\n\n\tif (edge != GPIO_INT_BOTH_EDGES) {\n\t\treg += GPIO_ICR1 + ((gpio_idx & 0x10) >> 2);  \n\t\tbit = gpio_idx & 0xf;\n\t\tval = readl(reg) & ~(0x3 << (bit << 1));\n\t\twritel(val | (edge << (bit << 1)), reg);\n\t}\n\n\twritel(1 << gpio_idx, port->base + GPIO_ISR);\n\tport->pad_type[gpio_idx] = type;\n\n\traw_spin_unlock_irqrestore(&port->gc.bgpio_lock, flags);\n\n\treturn port->gc.direction_input(&port->gc, gpio_idx);\n}\n\nstatic void mxc_flip_edge(struct mxc_gpio_port *port, u32 gpio)\n{\n\tvoid __iomem *reg = port->base;\n\tunsigned long flags;\n\tu32 bit, val;\n\tint edge;\n\n\traw_spin_lock_irqsave(&port->gc.bgpio_lock, flags);\n\n\treg += GPIO_ICR1 + ((gpio & 0x10) >> 2);  \n\tbit = gpio & 0xf;\n\tval = readl(reg);\n\tedge = (val >> (bit << 1)) & 3;\n\tval &= ~(0x3 << (bit << 1));\n\tif (edge == GPIO_INT_HIGH_LEV) {\n\t\tedge = GPIO_INT_LOW_LEV;\n\t\tpr_debug(\"mxc: switch GPIO %d to low trigger\\n\", gpio);\n\t} else if (edge == GPIO_INT_LOW_LEV) {\n\t\tedge = GPIO_INT_HIGH_LEV;\n\t\tpr_debug(\"mxc: switch GPIO %d to high trigger\\n\", gpio);\n\t} else {\n\t\tpr_err(\"mxc: invalid configuration for GPIO %d: %x\\n\",\n\t\t       gpio, edge);\n\t\tgoto unlock;\n\t}\n\twritel(val | (edge << (bit << 1)), reg);\n\nunlock:\n\traw_spin_unlock_irqrestore(&port->gc.bgpio_lock, flags);\n}\n\n \nstatic void mxc_gpio_irq_handler(struct mxc_gpio_port *port, u32 irq_stat)\n{\n\twhile (irq_stat != 0) {\n\t\tint irqoffset = fls(irq_stat) - 1;\n\n\t\tif (port->both_edges & (1 << irqoffset))\n\t\t\tmxc_flip_edge(port, irqoffset);\n\n\t\tgeneric_handle_domain_irq(port->domain, irqoffset);\n\n\t\tirq_stat &= ~(1 << irqoffset);\n\t}\n}\n\n \nstatic void mx3_gpio_irq_handler(struct irq_desc *desc)\n{\n\tu32 irq_stat;\n\tstruct mxc_gpio_port *port = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\tif (port->is_pad_wakeup)\n\t\treturn;\n\n\tchained_irq_enter(chip, desc);\n\n\tirq_stat = readl(port->base + GPIO_ISR) & readl(port->base + GPIO_IMR);\n\n\tmxc_gpio_irq_handler(port, irq_stat);\n\n\tchained_irq_exit(chip, desc);\n}\n\n \nstatic void mx2_gpio_irq_handler(struct irq_desc *desc)\n{\n\tu32 irq_msk, irq_stat;\n\tstruct mxc_gpio_port *port;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\tchained_irq_enter(chip, desc);\n\n\t \n\tlist_for_each_entry(port, &mxc_gpio_ports, node) {\n\t\tirq_msk = readl(port->base + GPIO_IMR);\n\t\tif (!irq_msk)\n\t\t\tcontinue;\n\n\t\tirq_stat = readl(port->base + GPIO_ISR) & irq_msk;\n\t\tif (irq_stat)\n\t\t\tmxc_gpio_irq_handler(port, irq_stat);\n\t}\n\tchained_irq_exit(chip, desc);\n}\n\n \nstatic int gpio_set_wake_irq(struct irq_data *d, u32 enable)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct mxc_gpio_port *port = gc->private;\n\tu32 gpio_idx = d->hwirq;\n\tint ret;\n\n\tif (enable) {\n\t\tif (port->irq_high && (gpio_idx >= 16))\n\t\t\tret = enable_irq_wake(port->irq_high);\n\t\telse\n\t\t\tret = enable_irq_wake(port->irq);\n\t\tport->wakeup_pads |= (1 << gpio_idx);\n\t} else {\n\t\tif (port->irq_high && (gpio_idx >= 16))\n\t\t\tret = disable_irq_wake(port->irq_high);\n\t\telse\n\t\t\tret = disable_irq_wake(port->irq);\n\t\tport->wakeup_pads &= ~(1 << gpio_idx);\n\t}\n\n\treturn ret;\n}\n\nstatic int mxc_gpio_init_gc(struct mxc_gpio_port *port, int irq_base)\n{\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\tint rv;\n\n\tgc = devm_irq_alloc_generic_chip(port->dev, \"gpio-mxc\", 1, irq_base,\n\t\t\t\t\t port->base, handle_level_irq);\n\tif (!gc)\n\t\treturn -ENOMEM;\n\tgc->private = port;\n\n\tct = gc->chip_types;\n\tct->chip.irq_ack = irq_gc_ack_set_bit;\n\tct->chip.irq_mask = irq_gc_mask_clr_bit;\n\tct->chip.irq_unmask = irq_gc_mask_set_bit;\n\tct->chip.irq_set_type = gpio_set_irq_type;\n\tct->chip.irq_set_wake = gpio_set_wake_irq;\n\tct->chip.flags = IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND;\n\tct->regs.ack = GPIO_ISR;\n\tct->regs.mask = GPIO_IMR;\n\n\trv = devm_irq_setup_generic_chip(port->dev, gc, IRQ_MSK(32),\n\t\t\t\t\t IRQ_GC_INIT_NESTED_LOCK,\n\t\t\t\t\t IRQ_NOREQUEST, 0);\n\n\treturn rv;\n}\n\nstatic int mxc_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct mxc_gpio_port *port = gpiochip_get_data(gc);\n\n\treturn irq_find_mapping(port->domain, offset);\n}\n\nstatic int mxc_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tint ret;\n\n\tret = gpiochip_generic_request(chip, offset);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pm_runtime_resume_and_get(chip->parent);\n}\n\nstatic void mxc_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tgpiochip_generic_free(chip, offset);\n\tpm_runtime_put(chip->parent);\n}\n\nstatic void mxc_update_irq_chained_handler(struct mxc_gpio_port *port, bool enable)\n{\n\tif (enable)\n\t\tirq_set_chained_handler_and_data(port->irq, port->mx_irq_handler, port);\n\telse\n\t\tirq_set_chained_handler_and_data(port->irq, NULL, NULL);\n\n\t \n\tif (port->irq_high > 0) {\n\t\tif (enable)\n\t\t\tirq_set_chained_handler_and_data(port->irq_high,\n\t\t\t\t\t\t\t port->mx_irq_handler,\n\t\t\t\t\t\t\t port);\n\t\telse\n\t\t\tirq_set_chained_handler_and_data(port->irq_high, NULL, NULL);\n\t}\n}\n\nstatic int mxc_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct mxc_gpio_port *port;\n\tint irq_count;\n\tint irq_base;\n\tint err;\n\n\tport = devm_kzalloc(&pdev->dev, sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->dev = &pdev->dev;\n\tport->hwdata = device_get_match_data(&pdev->dev);\n\n\tport->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(port->base))\n\t\treturn PTR_ERR(port->base);\n\n\tirq_count = platform_irq_count(pdev);\n\tif (irq_count < 0)\n\t\treturn irq_count;\n\n\tif (irq_count > 1) {\n\t\tport->irq_high = platform_get_irq(pdev, 1);\n\t\tif (port->irq_high < 0)\n\t\t\tport->irq_high = 0;\n\t}\n\n\tport->irq = platform_get_irq(pdev, 0);\n\tif (port->irq < 0)\n\t\treturn port->irq;\n\n\t \n\tport->clk = devm_clk_get_optional_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(port->clk))\n\t\treturn PTR_ERR(port->clk);\n\n\tif (of_device_is_compatible(np, \"fsl,imx7d-gpio\"))\n\t\tport->power_off = true;\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\t \n\twritel(0, port->base + GPIO_IMR);\n\twritel(~0, port->base + GPIO_ISR);\n\n\tif (of_device_is_compatible(np, \"fsl,imx21-gpio\")) {\n\t\t \n\t\tport->irq_high = -1;\n\t\tport->mx_irq_handler = mx2_gpio_irq_handler;\n\t} else\n\t\tport->mx_irq_handler = mx3_gpio_irq_handler;\n\n\tmxc_update_irq_chained_handler(port, true);\n\terr = bgpio_init(&port->gc, &pdev->dev, 4,\n\t\t\t port->base + GPIO_PSR,\n\t\t\t port->base + GPIO_DR, NULL,\n\t\t\t port->base + GPIO_GDIR, NULL,\n\t\t\t BGPIOF_READ_OUTPUT_REG_SET);\n\tif (err)\n\t\tgoto out_bgio;\n\n\tport->gc.request = mxc_gpio_request;\n\tport->gc.free = mxc_gpio_free;\n\tport->gc.to_irq = mxc_gpio_to_irq;\n\tport->gc.base = (pdev->id < 0) ? of_alias_get_id(np, \"gpio\") * 32 :\n\t\t\t\t\t     pdev->id * 32;\n\n\terr = devm_gpiochip_add_data(&pdev->dev, &port->gc, port);\n\tif (err)\n\t\tgoto out_bgio;\n\n\tirq_base = devm_irq_alloc_descs(&pdev->dev, -1, 0, 32, numa_node_id());\n\tif (irq_base < 0) {\n\t\terr = irq_base;\n\t\tgoto out_bgio;\n\t}\n\n\tport->domain = irq_domain_add_legacy(np, 32, irq_base, 0,\n\t\t\t\t\t     &irq_domain_simple_ops, NULL);\n\tif (!port->domain) {\n\t\terr = -ENODEV;\n\t\tgoto out_bgio;\n\t}\n\n\tirq_domain_set_pm_device(port->domain, &pdev->dev);\n\n\t \n\terr = mxc_gpio_init_gc(port, irq_base);\n\tif (err < 0)\n\t\tgoto out_irqdomain_remove;\n\n\tlist_add_tail(&port->node, &mxc_gpio_ports);\n\n\tplatform_set_drvdata(pdev, port);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\nout_irqdomain_remove:\n\tirq_domain_remove(port->domain);\nout_bgio:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tdev_info(&pdev->dev, \"%s failed with errno %d\\n\", __func__, err);\n\treturn err;\n}\n\nstatic void mxc_gpio_save_regs(struct mxc_gpio_port *port)\n{\n\tif (!port->power_off)\n\t\treturn;\n\n\tport->gpio_saved_reg.icr1 = readl(port->base + GPIO_ICR1);\n\tport->gpio_saved_reg.icr2 = readl(port->base + GPIO_ICR2);\n\tport->gpio_saved_reg.imr = readl(port->base + GPIO_IMR);\n\tport->gpio_saved_reg.gdir = readl(port->base + GPIO_GDIR);\n\tport->gpio_saved_reg.edge_sel = readl(port->base + GPIO_EDGE_SEL);\n\tport->gpio_saved_reg.dr = readl(port->base + GPIO_DR);\n}\n\nstatic void mxc_gpio_restore_regs(struct mxc_gpio_port *port)\n{\n\tif (!port->power_off)\n\t\treturn;\n\n\twritel(port->gpio_saved_reg.icr1, port->base + GPIO_ICR1);\n\twritel(port->gpio_saved_reg.icr2, port->base + GPIO_ICR2);\n\twritel(port->gpio_saved_reg.imr, port->base + GPIO_IMR);\n\twritel(port->gpio_saved_reg.gdir, port->base + GPIO_GDIR);\n\twritel(port->gpio_saved_reg.edge_sel, port->base + GPIO_EDGE_SEL);\n\twritel(port->gpio_saved_reg.dr, port->base + GPIO_DR);\n}\n\nstatic bool mxc_gpio_generic_config(struct mxc_gpio_port *port,\n\t\tunsigned int offset, unsigned long conf)\n{\n\tstruct device_node *np = port->dev->of_node;\n\n\tif (of_device_is_compatible(np, \"fsl,imx8dxl-gpio\") ||\n\t    of_device_is_compatible(np, \"fsl,imx8qxp-gpio\") ||\n\t    of_device_is_compatible(np, \"fsl,imx8qm-gpio\"))\n\t\treturn (gpiochip_generic_config(&port->gc, offset, conf) == 0);\n\n\treturn false;\n}\n\nstatic bool mxc_gpio_set_pad_wakeup(struct mxc_gpio_port *port, bool enable)\n{\n\tunsigned long config;\n\tbool ret = false;\n\tint i, type;\n\n\tstatic const u32 pad_type_map[] = {\n\t\tIMX_SCU_WAKEUP_OFF,\t\t \n\t\tIMX_SCU_WAKEUP_RISE_EDGE,\t \n\t\tIMX_SCU_WAKEUP_FALL_EDGE,\t \n\t\tIMX_SCU_WAKEUP_FALL_EDGE,\t \n\t\tIMX_SCU_WAKEUP_HIGH_LVL,\t \n\t\tIMX_SCU_WAKEUP_OFF,\t\t \n\t\tIMX_SCU_WAKEUP_OFF,\t\t \n\t\tIMX_SCU_WAKEUP_OFF,\t\t \n\t\tIMX_SCU_WAKEUP_LOW_LVL,\t\t \n\t};\n\n\tfor (i = 0; i < 32; i++) {\n\t\tif ((port->wakeup_pads & (1 << i))) {\n\t\t\ttype = port->pad_type[i];\n\t\t\tif (enable)\n\t\t\t\tconfig = pad_type_map[type];\n\t\t\telse\n\t\t\t\tconfig = IMX_SCU_WAKEUP_OFF;\n\t\t\tret |= mxc_gpio_generic_config(port, i, config);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int mxc_gpio_runtime_suspend(struct device *dev)\n{\n\tstruct mxc_gpio_port *port = dev_get_drvdata(dev);\n\n\tmxc_gpio_save_regs(port);\n\tclk_disable_unprepare(port->clk);\n\tmxc_update_irq_chained_handler(port, false);\n\n\treturn 0;\n}\n\nstatic int mxc_gpio_runtime_resume(struct device *dev)\n{\n\tstruct mxc_gpio_port *port = dev_get_drvdata(dev);\n\tint ret;\n\n\tmxc_update_irq_chained_handler(port, true);\n\tret = clk_prepare_enable(port->clk);\n\tif (ret) {\n\t\tmxc_update_irq_chained_handler(port, false);\n\t\treturn ret;\n\t}\n\n\tmxc_gpio_restore_regs(port);\n\n\treturn 0;\n}\n\nstatic int mxc_gpio_noirq_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct mxc_gpio_port *port = platform_get_drvdata(pdev);\n\n\tif (port->wakeup_pads > 0)\n\t\tport->is_pad_wakeup = mxc_gpio_set_pad_wakeup(port, true);\n\n\treturn 0;\n}\n\nstatic int mxc_gpio_noirq_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct mxc_gpio_port *port = platform_get_drvdata(pdev);\n\n\tif (port->wakeup_pads > 0)\n\t\tmxc_gpio_set_pad_wakeup(port, false);\n\tport->is_pad_wakeup = false;\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mxc_gpio_dev_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(mxc_gpio_noirq_suspend, mxc_gpio_noirq_resume)\n\tRUNTIME_PM_OPS(mxc_gpio_runtime_suspend, mxc_gpio_runtime_resume, NULL)\n};\n\nstatic int mxc_gpio_syscore_suspend(void)\n{\n\tstruct mxc_gpio_port *port;\n\tint ret;\n\n\t \n\tlist_for_each_entry(port, &mxc_gpio_ports, node) {\n\t\tret = clk_prepare_enable(port->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmxc_gpio_save_regs(port);\n\t\tclk_disable_unprepare(port->clk);\n\t}\n\n\treturn 0;\n}\n\nstatic void mxc_gpio_syscore_resume(void)\n{\n\tstruct mxc_gpio_port *port;\n\tint ret;\n\n\t \n\tlist_for_each_entry(port, &mxc_gpio_ports, node) {\n\t\tret = clk_prepare_enable(port->clk);\n\t\tif (ret) {\n\t\t\tpr_err(\"mxc: failed to enable gpio clock %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\t\tmxc_gpio_restore_regs(port);\n\t\tclk_disable_unprepare(port->clk);\n\t}\n}\n\nstatic struct syscore_ops mxc_gpio_syscore_ops = {\n\t.suspend = mxc_gpio_syscore_suspend,\n\t.resume = mxc_gpio_syscore_resume,\n};\n\nstatic struct platform_driver mxc_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"gpio-mxc\",\n\t\t.of_match_table = mxc_gpio_dt_ids,\n\t\t.suppress_bind_attrs = true,\n\t\t.pm = pm_ptr(&mxc_gpio_dev_pm_ops),\n\t},\n\t.probe\t\t= mxc_gpio_probe,\n};\n\nstatic int __init gpio_mxc_init(void)\n{\n\tregister_syscore_ops(&mxc_gpio_syscore_ops);\n\n\treturn platform_driver_register(&mxc_gpio_driver);\n}\nsubsys_initcall(gpio_mxc_init);\n\nMODULE_AUTHOR(\"Shawn Guo <shawn.guo@linaro.org>\");\nMODULE_DESCRIPTION(\"i.MX GPIO Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}