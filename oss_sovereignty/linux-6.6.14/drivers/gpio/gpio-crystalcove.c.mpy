{
  "module_name": "gpio-crystalcove.c",
  "hash_id": "6d4c61d0c90451e2c7528e5048d9f229b4ec5da665d5354459bc9dd430ef7479",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-crystalcove.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n\n#define CRYSTALCOVE_GPIO_NUM\t16\n#define CRYSTALCOVE_VGPIO_NUM\t95\n\n#define UPDATE_IRQ_TYPE\t\tBIT(0)\n#define UPDATE_IRQ_MASK\t\tBIT(1)\n\n#define GPIO0IRQ\t\t0x0b\n#define GPIO1IRQ\t\t0x0c\n#define MGPIO0IRQS0\t\t0x19\n#define MGPIO1IRQS0\t\t0x1a\n#define MGPIO0IRQSX\t\t0x1b\n#define MGPIO1IRQSX\t\t0x1c\n#define GPIO0P0CTLO\t\t0x2b\n#define GPIO0P0CTLI\t\t0x33\n#define GPIO1P0CTLO\t\t0x3b\n#define GPIO1P0CTLI\t\t0x43\n#define GPIOPANELCTL\t\t0x52\n\n#define CTLI_INTCNT_DIS\t\t(0)\n#define CTLI_INTCNT_NE\t\t(1 << 1)\n#define CTLI_INTCNT_PE\t\t(2 << 1)\n#define CTLI_INTCNT_BE\t\t(3 << 1)\n\n#define CTLO_DIR_IN\t\t(0)\n#define CTLO_DIR_OUT\t\t(1 << 5)\n\n#define CTLO_DRV_CMOS\t\t(0)\n#define CTLO_DRV_OD\t\t(1 << 4)\n\n#define CTLO_DRV_REN\t\t(1 << 3)\n\n#define CTLO_RVAL_2KDW\t\t(0)\n#define CTLO_RVAL_2KUP\t\t(1 << 1)\n#define CTLO_RVAL_50KDW\t\t(2 << 1)\n#define CTLO_RVAL_50KUP\t\t(3 << 1)\n\n#define CTLO_INPUT_SET\t(CTLO_DRV_CMOS | CTLO_DRV_REN | CTLO_RVAL_2KUP)\n#define CTLO_OUTPUT_SET\t(CTLO_DIR_OUT | CTLO_INPUT_SET)\n\nenum ctrl_register {\n\tCTRL_IN,\n\tCTRL_OUT,\n};\n\n \nstruct crystalcove_gpio {\n\tstruct mutex buslock;  \n\tstruct gpio_chip chip;\n\tstruct regmap *regmap;\n\tint update;\n\tint intcnt_value;\n\tbool set_irq_mask;\n};\n\nstatic inline int to_reg(int gpio, enum ctrl_register reg_type)\n{\n\tint reg;\n\n\tif (gpio >= CRYSTALCOVE_GPIO_NUM) {\n\t\t \n\t\tswitch (gpio) {\n\t\tcase 0x5e:\n\t\t\treturn GPIOPANELCTL;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (reg_type == CTRL_IN) {\n\t\tif (gpio < 8)\n\t\t\treg = GPIO0P0CTLI;\n\t\telse\n\t\t\treg = GPIO1P0CTLI;\n\t} else {\n\t\tif (gpio < 8)\n\t\t\treg = GPIO0P0CTLO;\n\t\telse\n\t\t\treg = GPIO1P0CTLO;\n\t}\n\n\treturn reg + gpio % 8;\n}\n\nstatic void crystalcove_update_irq_mask(struct crystalcove_gpio *cg, int gpio)\n{\n\tu8 mirqs0 = gpio < 8 ? MGPIO0IRQS0 : MGPIO1IRQS0;\n\tint mask = BIT(gpio % 8);\n\n\tif (cg->set_irq_mask)\n\t\tregmap_update_bits(cg->regmap, mirqs0, mask, mask);\n\telse\n\t\tregmap_update_bits(cg->regmap, mirqs0, mask, 0);\n}\n\nstatic void crystalcove_update_irq_ctrl(struct crystalcove_gpio *cg, int gpio)\n{\n\tint reg = to_reg(gpio, CTRL_IN);\n\n\tregmap_update_bits(cg->regmap, reg, CTLI_INTCNT_BE, cg->intcnt_value);\n}\n\nstatic int crystalcove_gpio_dir_in(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct crystalcove_gpio *cg = gpiochip_get_data(chip);\n\tint reg = to_reg(gpio, CTRL_OUT);\n\n\tif (reg < 0)\n\t\treturn 0;\n\n\treturn regmap_write(cg->regmap, reg, CTLO_INPUT_SET);\n}\n\nstatic int crystalcove_gpio_dir_out(struct gpio_chip *chip, unsigned int gpio, int value)\n{\n\tstruct crystalcove_gpio *cg = gpiochip_get_data(chip);\n\tint reg = to_reg(gpio, CTRL_OUT);\n\n\tif (reg < 0)\n\t\treturn 0;\n\n\treturn regmap_write(cg->regmap, reg, CTLO_OUTPUT_SET | value);\n}\n\nstatic int crystalcove_gpio_get(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct crystalcove_gpio *cg = gpiochip_get_data(chip);\n\tunsigned int val;\n\tint ret, reg = to_reg(gpio, CTRL_IN);\n\n\tif (reg < 0)\n\t\treturn 0;\n\n\tret = regmap_read(cg->regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val & 0x1;\n}\n\nstatic void crystalcove_gpio_set(struct gpio_chip *chip, unsigned int gpio, int value)\n{\n\tstruct crystalcove_gpio *cg = gpiochip_get_data(chip);\n\tint reg = to_reg(gpio, CTRL_OUT);\n\n\tif (reg < 0)\n\t\treturn;\n\n\tif (value)\n\t\tregmap_update_bits(cg->regmap, reg, 1, 1);\n\telse\n\t\tregmap_update_bits(cg->regmap, reg, 1, 0);\n}\n\nstatic int crystalcove_irq_type(struct irq_data *data, unsigned int type)\n{\n\tstruct crystalcove_gpio *cg = gpiochip_get_data(irq_data_get_irq_chip_data(data));\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\n\tif (hwirq >= CRYSTALCOVE_GPIO_NUM)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_NONE:\n\t\tcg->intcnt_value = CTLI_INTCNT_DIS;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tcg->intcnt_value = CTLI_INTCNT_BE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tcg->intcnt_value = CTLI_INTCNT_PE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tcg->intcnt_value = CTLI_INTCNT_NE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcg->update |= UPDATE_IRQ_TYPE;\n\n\treturn 0;\n}\n\nstatic void crystalcove_bus_lock(struct irq_data *data)\n{\n\tstruct crystalcove_gpio *cg = gpiochip_get_data(irq_data_get_irq_chip_data(data));\n\n\tmutex_lock(&cg->buslock);\n}\n\nstatic void crystalcove_bus_sync_unlock(struct irq_data *data)\n{\n\tstruct crystalcove_gpio *cg = gpiochip_get_data(irq_data_get_irq_chip_data(data));\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\n\tif (cg->update & UPDATE_IRQ_TYPE)\n\t\tcrystalcove_update_irq_ctrl(cg, hwirq);\n\tif (cg->update & UPDATE_IRQ_MASK)\n\t\tcrystalcove_update_irq_mask(cg, hwirq);\n\tcg->update = 0;\n\n\tmutex_unlock(&cg->buslock);\n}\n\nstatic void crystalcove_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct crystalcove_gpio *cg = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\n\tif (hwirq >= CRYSTALCOVE_GPIO_NUM)\n\t\treturn;\n\n\tgpiochip_enable_irq(gc, hwirq);\n\n\tcg->set_irq_mask = false;\n\tcg->update |= UPDATE_IRQ_MASK;\n}\n\nstatic void crystalcove_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct crystalcove_gpio *cg = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\n\tif (hwirq >= CRYSTALCOVE_GPIO_NUM)\n\t\treturn;\n\n\tcg->set_irq_mask = true;\n\tcg->update |= UPDATE_IRQ_MASK;\n\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic const struct irq_chip crystalcove_irqchip = {\n\t.name\t\t\t= \"Crystal Cove\",\n\t.irq_mask\t\t= crystalcove_irq_mask,\n\t.irq_unmask\t\t= crystalcove_irq_unmask,\n\t.irq_set_type\t\t= crystalcove_irq_type,\n\t.irq_bus_lock\t\t= crystalcove_bus_lock,\n\t.irq_bus_sync_unlock\t= crystalcove_bus_sync_unlock,\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic irqreturn_t crystalcove_gpio_irq_handler(int irq, void *data)\n{\n\tstruct crystalcove_gpio *cg = data;\n\tunsigned long pending;\n\tunsigned int p0, p1;\n\tint gpio;\n\tunsigned int virq;\n\n\tif (regmap_read(cg->regmap, GPIO0IRQ, &p0) ||\n\t    regmap_read(cg->regmap, GPIO1IRQ, &p1))\n\t\treturn IRQ_NONE;\n\n\tregmap_write(cg->regmap, GPIO0IRQ, p0);\n\tregmap_write(cg->regmap, GPIO1IRQ, p1);\n\n\tpending = p0 | p1 << 8;\n\n\tfor_each_set_bit(gpio, &pending, CRYSTALCOVE_GPIO_NUM) {\n\t\tvirq = irq_find_mapping(cg->chip.irq.domain, gpio);\n\t\thandle_nested_irq(virq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void crystalcove_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tstruct crystalcove_gpio *cg = gpiochip_get_data(chip);\n\tint gpio, offset;\n\tunsigned int ctlo, ctli, mirqs0, mirqsx, irq;\n\n\tfor (gpio = 0; gpio < CRYSTALCOVE_GPIO_NUM; gpio++) {\n\t\tregmap_read(cg->regmap, to_reg(gpio, CTRL_OUT), &ctlo);\n\t\tregmap_read(cg->regmap, to_reg(gpio, CTRL_IN), &ctli);\n\t\tregmap_read(cg->regmap, gpio < 8 ? MGPIO0IRQS0 : MGPIO1IRQS0,\n\t\t\t    &mirqs0);\n\t\tregmap_read(cg->regmap, gpio < 8 ? MGPIO0IRQSX : MGPIO1IRQSX,\n\t\t\t    &mirqsx);\n\t\tregmap_read(cg->regmap, gpio < 8 ? GPIO0IRQ : GPIO1IRQ,\n\t\t\t    &irq);\n\n\t\toffset = gpio % 8;\n\t\tseq_printf(s, \" gpio-%-2d %s %s %s %s ctlo=%2x,%s %s %s\\n\",\n\t\t\t   gpio, ctlo & CTLO_DIR_OUT ? \"out\" : \"in \",\n\t\t\t   ctli & 0x1 ? \"hi\" : \"lo\",\n\t\t\t   ctli & CTLI_INTCNT_NE ? \"fall\" : \"    \",\n\t\t\t   ctli & CTLI_INTCNT_PE ? \"rise\" : \"    \",\n\t\t\t   ctlo,\n\t\t\t   mirqs0 & BIT(offset) ? \"s0 mask  \" : \"s0 unmask\",\n\t\t\t   mirqsx & BIT(offset) ? \"sx mask  \" : \"sx unmask\",\n\t\t\t   irq & BIT(offset) ? \"pending\" : \"       \");\n\t}\n}\n\nstatic int crystalcove_gpio_probe(struct platform_device *pdev)\n{\n\tint irq = platform_get_irq(pdev, 0);\n\tstruct crystalcove_gpio *cg;\n\tint retval;\n\tstruct device *dev = pdev->dev.parent;\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(dev);\n\tstruct gpio_irq_chip *girq;\n\n\tif (irq < 0)\n\t\treturn irq;\n\n\tcg = devm_kzalloc(&pdev->dev, sizeof(*cg), GFP_KERNEL);\n\tif (!cg)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&cg->buslock);\n\tcg->chip.label = KBUILD_MODNAME;\n\tcg->chip.direction_input = crystalcove_gpio_dir_in;\n\tcg->chip.direction_output = crystalcove_gpio_dir_out;\n\tcg->chip.get = crystalcove_gpio_get;\n\tcg->chip.set = crystalcove_gpio_set;\n\tcg->chip.base = -1;\n\tcg->chip.ngpio = CRYSTALCOVE_VGPIO_NUM;\n\tcg->chip.can_sleep = true;\n\tcg->chip.parent = dev;\n\tcg->chip.dbg_show = crystalcove_gpio_dbg_show;\n\tcg->regmap = pmic->regmap;\n\n\tgirq = &cg->chip.irq;\n\tgpio_irq_chip_set_chip(girq, &crystalcove_irqchip);\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_simple_irq;\n\tgirq->threaded = true;\n\n\tretval = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\t   crystalcove_gpio_irq_handler,\n\t\t\t\t\t   IRQF_ONESHOT, KBUILD_MODNAME, cg);\n\tif (retval) {\n\t\tdev_warn(&pdev->dev, \"request irq failed: %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\tretval = devm_gpiochip_add_data(&pdev->dev, &cg->chip, cg);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tirq_domain_update_bus_token(cg->chip.irq.domain, DOMAIN_BUS_WIRED);\n\n\treturn 0;\n}\n\nstatic struct platform_driver crystalcove_gpio_driver = {\n\t.probe = crystalcove_gpio_probe,\n\t.driver = {\n\t\t.name = \"crystal_cove_gpio\",\n\t},\n};\nmodule_platform_driver(crystalcove_gpio_driver);\n\nMODULE_AUTHOR(\"Yang, Bin <bin.yang@intel.com>\");\nMODULE_DESCRIPTION(\"Intel Crystal Cove GPIO Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}