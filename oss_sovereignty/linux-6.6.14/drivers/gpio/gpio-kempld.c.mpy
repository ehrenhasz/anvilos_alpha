{
  "module_name": "gpio-kempld.c",
  "hash_id": "787efd35b84ed43592806deae958de923ee18ec79c50f4d70f94415f1affbf91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-kempld.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/driver.h>\n#include <linux/mfd/kempld.h>\n\n#define KEMPLD_GPIO_MAX_NUM\t\t16\n#define KEMPLD_GPIO_MASK(x)\t\t(BIT((x) % 8))\n#define KEMPLD_GPIO_DIR_NUM(x)\t\t(0x40 + (x) / 8)\n#define KEMPLD_GPIO_LVL_NUM(x)\t\t(0x42 + (x) / 8)\n#define KEMPLD_GPIO_EVT_LVL_EDGE\t0x46\n#define KEMPLD_GPIO_IEN\t\t\t0x4A\n\nstruct kempld_gpio_data {\n\tstruct gpio_chip\t\tchip;\n\tstruct kempld_device_data\t*pld;\n};\n\n \nstatic void kempld_gpio_bitop(struct kempld_device_data *pld,\n\t\t\t      u8 reg, u8 bit, u8 val)\n{\n\tu8 status;\n\n\tstatus = kempld_read8(pld, reg);\n\tif (val)\n\t\tstatus |= KEMPLD_GPIO_MASK(bit);\n\telse\n\t\tstatus &= ~KEMPLD_GPIO_MASK(bit);\n\tkempld_write8(pld, reg, status);\n}\n\nstatic int kempld_gpio_get_bit(struct kempld_device_data *pld, u8 reg, u8 bit)\n{\n\tu8 status;\n\n\tkempld_get_mutex(pld);\n\tstatus = kempld_read8(pld, reg);\n\tkempld_release_mutex(pld);\n\n\treturn !!(status & KEMPLD_GPIO_MASK(bit));\n}\n\nstatic int kempld_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct kempld_gpio_data *gpio = gpiochip_get_data(chip);\n\tstruct kempld_device_data *pld = gpio->pld;\n\n\treturn !!kempld_gpio_get_bit(pld, KEMPLD_GPIO_LVL_NUM(offset), offset);\n}\n\nstatic void kempld_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct kempld_gpio_data *gpio = gpiochip_get_data(chip);\n\tstruct kempld_device_data *pld = gpio->pld;\n\n\tkempld_get_mutex(pld);\n\tkempld_gpio_bitop(pld, KEMPLD_GPIO_LVL_NUM(offset), offset, value);\n\tkempld_release_mutex(pld);\n}\n\nstatic int kempld_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct kempld_gpio_data *gpio = gpiochip_get_data(chip);\n\tstruct kempld_device_data *pld = gpio->pld;\n\n\tkempld_get_mutex(pld);\n\tkempld_gpio_bitop(pld, KEMPLD_GPIO_DIR_NUM(offset), offset, 0);\n\tkempld_release_mutex(pld);\n\n\treturn 0;\n}\n\nstatic int kempld_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\n\t\t\t\t\tint value)\n{\n\tstruct kempld_gpio_data *gpio = gpiochip_get_data(chip);\n\tstruct kempld_device_data *pld = gpio->pld;\n\n\tkempld_get_mutex(pld);\n\tkempld_gpio_bitop(pld, KEMPLD_GPIO_LVL_NUM(offset), offset, value);\n\tkempld_gpio_bitop(pld, KEMPLD_GPIO_DIR_NUM(offset), offset, 1);\n\tkempld_release_mutex(pld);\n\n\treturn 0;\n}\n\nstatic int kempld_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct kempld_gpio_data *gpio = gpiochip_get_data(chip);\n\tstruct kempld_device_data *pld = gpio->pld;\n\n\tif (kempld_gpio_get_bit(pld, KEMPLD_GPIO_DIR_NUM(offset), offset))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int kempld_gpio_pincount(struct kempld_device_data *pld)\n{\n\tu16 evt, evt_back;\n\n\tkempld_get_mutex(pld);\n\n\t \n\tevt_back = kempld_read16(pld, KEMPLD_GPIO_EVT_LVL_EDGE);\n\t \n\tkempld_write16(pld, KEMPLD_GPIO_EVT_LVL_EDGE, 0x0000);\n\t \n\tevt = kempld_read16(pld, KEMPLD_GPIO_EVT_LVL_EDGE);\n\t \n\tkempld_write16(pld, KEMPLD_GPIO_EVT_LVL_EDGE, evt_back);\n\n\tkempld_release_mutex(pld);\n\n\treturn evt ? __ffs(evt) : 16;\n}\n\nstatic int kempld_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct kempld_device_data *pld = dev_get_drvdata(dev->parent);\n\tstruct kempld_platform_data *pdata = dev_get_platdata(pld->dev);\n\tstruct kempld_gpio_data *gpio;\n\tstruct gpio_chip *chip;\n\tint ret;\n\n\tif (pld->info.spec_major < 2) {\n\t\tdev_err(dev,\n\t\t\t\"Driver only supports GPIO devices compatible to PLD spec. rev. 2.0 or higher\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tgpio = devm_kzalloc(dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tgpio->pld = pld;\n\n\tplatform_set_drvdata(pdev, gpio);\n\n\tchip = &gpio->chip;\n\tchip->label = \"gpio-kempld\";\n\tchip->owner = THIS_MODULE;\n\tchip->parent = dev;\n\tchip->can_sleep = true;\n\tif (pdata && pdata->gpio_base)\n\t\tchip->base = pdata->gpio_base;\n\telse\n\t\tchip->base = -1;\n\tchip->direction_input = kempld_gpio_direction_input;\n\tchip->direction_output = kempld_gpio_direction_output;\n\tchip->get_direction = kempld_gpio_get_direction;\n\tchip->get = kempld_gpio_get;\n\tchip->set = kempld_gpio_set;\n\tchip->ngpio = kempld_gpio_pincount(pld);\n\tif (chip->ngpio == 0) {\n\t\tdev_err(dev, \"No GPIO pins detected\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = devm_gpiochip_add_data(dev, chip, gpio);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not register GPIO chip\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(dev, \"GPIO functionality initialized with %d pins\\n\",\n\t\t chip->ngpio);\n\n\treturn 0;\n}\n\nstatic struct platform_driver kempld_gpio_driver = {\n\t.driver = {\n\t\t.name = \"kempld-gpio\",\n\t},\n\t.probe\t\t= kempld_gpio_probe,\n};\n\nmodule_platform_driver(kempld_gpio_driver);\n\nMODULE_DESCRIPTION(\"KEM PLD GPIO Driver\");\nMODULE_AUTHOR(\"Michael Brunner <michael.brunner@kontron.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:kempld-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}