{
  "module_name": "gpio-stp-xway.c",
  "hash_id": "02ec7ef7b7dcb1c79011658d59555b866570dfd8031e537de9f8c02f2b354ae2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-stp-xway.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n\n \n\n \n#define XWAY_STP_CON0\t\t0x00\n \n#define XWAY_STP_CON1\t\t0x04\n \n#define XWAY_STP_CPU0\t\t0x08\n \n#define XWAY_STP_CPU1\t\t0x0C\n \n#define XWAY_STP_AR\t\t0x10\n\n \n#define XWAY_STP_CON_SWU\tBIT(31)\n\n \n#define XWAY_STP_2HZ\t\t0\n#define XWAY_STP_4HZ\t\tBIT(23)\n#define XWAY_STP_8HZ\t\tBIT(24)\n#define XWAY_STP_10HZ\t\t(BIT(24) | BIT(23))\n#define XWAY_STP_SPEED_MASK\t(BIT(23) | BIT(24) | BIT(25) | BIT(26) | BIT(27))\n\n#define XWAY_STP_FPIS_VALUE\tBIT(21)\n#define XWAY_STP_FPIS_MASK\t(BIT(20) | BIT(21))\n\n \n#define XWAY_STP_UPD_FPI\tBIT(31)\n#define XWAY_STP_UPD_MASK\t(BIT(31) | BIT(30))\n\n \n#define XWAY_STP_ADSL_SHIFT\t24\n#define XWAY_STP_ADSL_MASK\t0x3\n\n \n#define XWAY_STP_PHY_MASK\t0x7\n#define XWAY_STP_PHY1_SHIFT\t27\n#define XWAY_STP_PHY2_SHIFT\t3\n#define XWAY_STP_PHY3_SHIFT\t6\n#define XWAY_STP_PHY4_SHIFT\t15\n\n \n#define XWAY_STP_GROUP0\t\tBIT(0)\n#define XWAY_STP_GROUP1\t\tBIT(1)\n#define XWAY_STP_GROUP2\t\tBIT(2)\n#define XWAY_STP_GROUP_MASK\t(0x7)\n\n \n#define XWAY_STP_FALLING\tBIT(26)\n#define XWAY_STP_EDGE_MASK\tBIT(26)\n\n#define xway_stp_r32(m, reg)\t\t__raw_readl(m + reg)\n#define xway_stp_w32(m, val, reg)\t__raw_writel(val, m + reg)\n#define xway_stp_w32_mask(m, clear, set, reg) \\\n\t\txway_stp_w32(m, (xway_stp_r32(m, reg) & ~(clear)) | (set), reg)\n\nstruct xway_stp {\n\tstruct gpio_chip gc;\n\tvoid __iomem *virt;\n\tu32 edge;\t \n\tu32 shadow;\t \n\tu8 groups;\t \n\tu8 dsl;\t\t \n\tu8 phy1;\t \n\tu8 phy2;\t \n\tu8 phy3;\t \n\tu8 phy4;\t \n\tu8 reserved;\t \n};\n\n \nstatic int xway_stp_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct xway_stp *chip = gpiochip_get_data(gc);\n\n\treturn (xway_stp_r32(chip->virt, XWAY_STP_CPU0) & BIT(gpio));\n}\n\n \nstatic void xway_stp_set(struct gpio_chip *gc, unsigned gpio, int val)\n{\n\tstruct xway_stp *chip = gpiochip_get_data(gc);\n\n\tif (val)\n\t\tchip->shadow |= BIT(gpio);\n\telse\n\t\tchip->shadow &= ~BIT(gpio);\n\txway_stp_w32(chip->virt, chip->shadow, XWAY_STP_CPU0);\n\tif (!chip->reserved)\n\t\txway_stp_w32_mask(chip->virt, 0, XWAY_STP_CON_SWU, XWAY_STP_CON0);\n}\n\n \nstatic int xway_stp_dir_out(struct gpio_chip *gc, unsigned gpio, int val)\n{\n\txway_stp_set(gc, gpio, val);\n\n\treturn 0;\n}\n\n \nstatic int xway_stp_request(struct gpio_chip *gc, unsigned gpio)\n{\n\tstruct xway_stp *chip = gpiochip_get_data(gc);\n\n\tif ((gpio < 8) && (chip->reserved & BIT(gpio))) {\n\t\tdev_err(gc->parent, \"GPIO %d is driven by hardware\\n\", gpio);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void xway_stp_hw_init(struct xway_stp *chip)\n{\n\t \n\txway_stp_w32(chip->virt, 0, XWAY_STP_AR);\n\txway_stp_w32(chip->virt, 0, XWAY_STP_CPU0);\n\txway_stp_w32(chip->virt, 0, XWAY_STP_CPU1);\n\txway_stp_w32(chip->virt, XWAY_STP_CON_SWU, XWAY_STP_CON0);\n\txway_stp_w32(chip->virt, 0, XWAY_STP_CON1);\n\n\t \n\txway_stp_w32_mask(chip->virt, XWAY_STP_EDGE_MASK,\n\t\t\t\tchip->edge, XWAY_STP_CON0);\n\n\t \n\txway_stp_w32_mask(chip->virt, XWAY_STP_GROUP_MASK,\n\t\t\t\tchip->groups, XWAY_STP_CON1);\n\n\t \n\txway_stp_w32_mask(chip->virt,\n\t\t\tXWAY_STP_ADSL_MASK << XWAY_STP_ADSL_SHIFT,\n\t\t\tchip->dsl << XWAY_STP_ADSL_SHIFT,\n\t\t\tXWAY_STP_CON0);\n\n\t \n\txway_stp_w32_mask(chip->virt,\n\t\t\tXWAY_STP_PHY_MASK << XWAY_STP_PHY1_SHIFT,\n\t\t\tchip->phy1 << XWAY_STP_PHY1_SHIFT,\n\t\t\tXWAY_STP_CON0);\n\txway_stp_w32_mask(chip->virt,\n\t\t\tXWAY_STP_PHY_MASK << XWAY_STP_PHY2_SHIFT,\n\t\t\tchip->phy2 << XWAY_STP_PHY2_SHIFT,\n\t\t\tXWAY_STP_CON1);\n\n\tif (of_machine_is_compatible(\"lantiq,grx390\")\n\t    || of_machine_is_compatible(\"lantiq,ar10\")) {\n\t\txway_stp_w32_mask(chip->virt,\n\t\t\t\tXWAY_STP_PHY_MASK << XWAY_STP_PHY3_SHIFT,\n\t\t\t\tchip->phy3 << XWAY_STP_PHY3_SHIFT,\n\t\t\t\tXWAY_STP_CON1);\n\t}\n\n\tif (of_machine_is_compatible(\"lantiq,grx390\")) {\n\t\txway_stp_w32_mask(chip->virt,\n\t\t\t\tXWAY_STP_PHY_MASK << XWAY_STP_PHY4_SHIFT,\n\t\t\t\tchip->phy4 << XWAY_STP_PHY4_SHIFT,\n\t\t\t\tXWAY_STP_CON1);\n\t}\n\n\t \n\tchip->reserved = (chip->phy4 << 11) | (chip->phy3 << 8) | (chip->phy2 << 5)\n\t\t| (chip->phy1 << 2) | chip->dsl;\n\n\t \n\tif (chip->reserved) {\n\t\txway_stp_w32_mask(chip->virt, XWAY_STP_UPD_MASK,\n\t\t\tXWAY_STP_UPD_FPI, XWAY_STP_CON1);\n\t\txway_stp_w32_mask(chip->virt, XWAY_STP_SPEED_MASK,\n\t\t\tXWAY_STP_10HZ, XWAY_STP_CON1);\n\t\txway_stp_w32_mask(chip->virt, XWAY_STP_FPIS_MASK,\n\t\t\tXWAY_STP_FPIS_VALUE, XWAY_STP_CON1);\n\t}\n}\n\nstatic int xway_stp_probe(struct platform_device *pdev)\n{\n\tu32 shadow, groups, dsl, phy;\n\tstruct xway_stp *chip;\n\tstruct clk *clk;\n\tint ret = 0;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->virt = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(chip->virt))\n\t\treturn PTR_ERR(chip->virt);\n\n\tchip->gc.parent = &pdev->dev;\n\tchip->gc.label = \"stp-xway\";\n\tchip->gc.direction_output = xway_stp_dir_out;\n\tchip->gc.get = xway_stp_get;\n\tchip->gc.set = xway_stp_set;\n\tchip->gc.request = xway_stp_request;\n\tchip->gc.base = -1;\n\tchip->gc.owner = THIS_MODULE;\n\n\t \n\tif (!of_property_read_u32(pdev->dev.of_node, \"lantiq,shadow\", &shadow))\n\t\tchip->shadow = shadow;\n\n\t \n\tif (!of_property_read_u32(pdev->dev.of_node, \"lantiq,groups\", &groups))\n\t\tchip->groups = groups & XWAY_STP_GROUP_MASK;\n\telse\n\t\tchip->groups = XWAY_STP_GROUP0;\n\tchip->gc.ngpio = fls(chip->groups) * 8;\n\n\t \n\tif (!of_property_read_u32(pdev->dev.of_node, \"lantiq,dsl\", &dsl))\n\t\tchip->dsl = dsl & XWAY_STP_ADSL_MASK;\n\n\t \n\tif (of_machine_is_compatible(\"lantiq,ar9\") ||\n\t\t\tof_machine_is_compatible(\"lantiq,gr9\") ||\n\t\t\tof_machine_is_compatible(\"lantiq,vr9\") ||\n\t\t\tof_machine_is_compatible(\"lantiq,ar10\") ||\n\t\t\tof_machine_is_compatible(\"lantiq,grx390\")) {\n\t\tif (!of_property_read_u32(pdev->dev.of_node, \"lantiq,phy1\", &phy))\n\t\t\tchip->phy1 = phy & XWAY_STP_PHY_MASK;\n\t\tif (!of_property_read_u32(pdev->dev.of_node, \"lantiq,phy2\", &phy))\n\t\t\tchip->phy2 = phy & XWAY_STP_PHY_MASK;\n\t}\n\n\tif (of_machine_is_compatible(\"lantiq,ar10\") ||\n\t\t\tof_machine_is_compatible(\"lantiq,grx390\")) {\n\t\tif (!of_property_read_u32(pdev->dev.of_node, \"lantiq,phy3\", &phy))\n\t\t\tchip->phy3 = phy & XWAY_STP_PHY_MASK;\n\t}\n\n\tif (of_machine_is_compatible(\"lantiq,grx390\")) {\n\t\tif (!of_property_read_u32(pdev->dev.of_node, \"lantiq,phy4\", &phy))\n\t\t\tchip->phy4 = phy & XWAY_STP_PHY_MASK;\n\t}\n\n\t \n\tif (!of_property_read_bool(pdev->dev.of_node, \"lantiq,rising\"))\n\t\tchip->edge = XWAY_STP_FALLING;\n\n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\txway_stp_hw_init(chip);\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &chip->gc, chip);\n\tif (ret) {\n\t\tclk_disable_unprepare(clk);\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"Init done\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id xway_stp_match[] = {\n\t{ .compatible = \"lantiq,gpio-stp-xway\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xway_stp_match);\n\nstatic struct platform_driver xway_stp_driver = {\n\t.probe = xway_stp_probe,\n\t.driver = {\n\t\t.name = \"gpio-stp-xway\",\n\t\t.of_match_table = xway_stp_match,\n\t},\n};\n\nstatic int __init xway_stp_init(void)\n{\n\treturn platform_driver_register(&xway_stp_driver);\n}\n\nsubsys_initcall(xway_stp_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}