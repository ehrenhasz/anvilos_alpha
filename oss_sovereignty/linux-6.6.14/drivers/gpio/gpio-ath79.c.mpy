{
  "module_name": "gpio-ath79.c",
  "hash_id": "3af5d67f9682f54bb1078344dd165aa2831ab10c538212f5133187b98377d77d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-ath79.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/gpio-ath79.h>\n#include <linux/of.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\n#define AR71XX_GPIO_REG_OE\t\t0x00\n#define AR71XX_GPIO_REG_IN\t\t0x04\n#define AR71XX_GPIO_REG_SET\t\t0x0c\n#define AR71XX_GPIO_REG_CLEAR\t\t0x10\n\n#define AR71XX_GPIO_REG_INT_ENABLE\t0x14\n#define AR71XX_GPIO_REG_INT_TYPE\t0x18\n#define AR71XX_GPIO_REG_INT_POLARITY\t0x1c\n#define AR71XX_GPIO_REG_INT_PENDING\t0x20\n#define AR71XX_GPIO_REG_INT_MASK\t0x24\n\nstruct ath79_gpio_ctrl {\n\tstruct gpio_chip gc;\n\tvoid __iomem *base;\n\traw_spinlock_t lock;\n\tunsigned long both_edges;\n};\n\nstatic struct ath79_gpio_ctrl *irq_data_to_ath79_gpio(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\n\treturn container_of(gc, struct ath79_gpio_ctrl, gc);\n}\n\nstatic u32 ath79_gpio_read(struct ath79_gpio_ctrl *ctrl, unsigned reg)\n{\n\treturn readl(ctrl->base + reg);\n}\n\nstatic void ath79_gpio_write(struct ath79_gpio_ctrl *ctrl,\n\t\t\tunsigned reg, u32 val)\n{\n\twritel(val, ctrl->base + reg);\n}\n\nstatic bool ath79_gpio_update_bits(\n\tstruct ath79_gpio_ctrl *ctrl, unsigned reg, u32 mask, u32 bits)\n{\n\tu32 old_val, new_val;\n\n\told_val = ath79_gpio_read(ctrl, reg);\n\tnew_val = (old_val & ~mask) | (bits & mask);\n\n\tif (new_val != old_val)\n\t\tath79_gpio_write(ctrl, reg, new_val);\n\n\treturn new_val != old_val;\n}\n\nstatic void ath79_gpio_irq_unmask(struct irq_data *data)\n{\n\tstruct ath79_gpio_ctrl *ctrl = irq_data_to_ath79_gpio(data);\n\tu32 mask = BIT(irqd_to_hwirq(data));\n\tunsigned long flags;\n\n\tgpiochip_enable_irq(&ctrl->gc, irqd_to_hwirq(data));\n\traw_spin_lock_irqsave(&ctrl->lock, flags);\n\tath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_MASK, mask, mask);\n\traw_spin_unlock_irqrestore(&ctrl->lock, flags);\n}\n\nstatic void ath79_gpio_irq_mask(struct irq_data *data)\n{\n\tstruct ath79_gpio_ctrl *ctrl = irq_data_to_ath79_gpio(data);\n\tu32 mask = BIT(irqd_to_hwirq(data));\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ctrl->lock, flags);\n\tath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_MASK, mask, 0);\n\traw_spin_unlock_irqrestore(&ctrl->lock, flags);\n\tgpiochip_disable_irq(&ctrl->gc, irqd_to_hwirq(data));\n}\n\nstatic void ath79_gpio_irq_enable(struct irq_data *data)\n{\n\tstruct ath79_gpio_ctrl *ctrl = irq_data_to_ath79_gpio(data);\n\tu32 mask = BIT(irqd_to_hwirq(data));\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ctrl->lock, flags);\n\tath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_ENABLE, mask, mask);\n\tath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_MASK, mask, mask);\n\traw_spin_unlock_irqrestore(&ctrl->lock, flags);\n}\n\nstatic void ath79_gpio_irq_disable(struct irq_data *data)\n{\n\tstruct ath79_gpio_ctrl *ctrl = irq_data_to_ath79_gpio(data);\n\tu32 mask = BIT(irqd_to_hwirq(data));\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ctrl->lock, flags);\n\tath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_MASK, mask, 0);\n\tath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_ENABLE, mask, 0);\n\traw_spin_unlock_irqrestore(&ctrl->lock, flags);\n}\n\nstatic int ath79_gpio_irq_set_type(struct irq_data *data,\n\t\t\t\tunsigned int flow_type)\n{\n\tstruct ath79_gpio_ctrl *ctrl = irq_data_to_ath79_gpio(data);\n\tu32 mask = BIT(irqd_to_hwirq(data));\n\tu32 type = 0, polarity = 0;\n\tunsigned long flags;\n\tbool disabled;\n\n\tswitch (flow_type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tpolarity |= mask;\n\t\tfallthrough;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tpolarity |= mask;\n\t\tfallthrough;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\ttype |= mask;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&ctrl->lock, flags);\n\n\tif (flow_type == IRQ_TYPE_EDGE_BOTH) {\n\t\tctrl->both_edges |= mask;\n\t\tpolarity = ~ath79_gpio_read(ctrl, AR71XX_GPIO_REG_IN);\n\t} else {\n\t\tctrl->both_edges &= ~mask;\n\t}\n\n\t \n\tdisabled = ath79_gpio_update_bits(\n\t\tctrl, AR71XX_GPIO_REG_INT_ENABLE, mask, 0);\n\n\tath79_gpio_update_bits(\n\t\tctrl, AR71XX_GPIO_REG_INT_TYPE, mask, type);\n\tath79_gpio_update_bits(\n\t\tctrl, AR71XX_GPIO_REG_INT_POLARITY, mask, polarity);\n\n\tif (disabled)\n\t\tath79_gpio_update_bits(\n\t\t\tctrl, AR71XX_GPIO_REG_INT_ENABLE, mask, mask);\n\n\traw_spin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip ath79_gpio_irqchip = {\n\t.name = \"gpio-ath79\",\n\t.irq_enable = ath79_gpio_irq_enable,\n\t.irq_disable = ath79_gpio_irq_disable,\n\t.irq_mask = ath79_gpio_irq_mask,\n\t.irq_unmask = ath79_gpio_irq_unmask,\n\t.irq_set_type = ath79_gpio_irq_set_type,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void ath79_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\tstruct ath79_gpio_ctrl *ctrl =\n\t\tcontainer_of(gc, struct ath79_gpio_ctrl, gc);\n\tunsigned long flags, pending;\n\tu32 both_edges, state;\n\tint irq;\n\n\tchained_irq_enter(irqchip, desc);\n\n\traw_spin_lock_irqsave(&ctrl->lock, flags);\n\n\tpending = ath79_gpio_read(ctrl, AR71XX_GPIO_REG_INT_PENDING);\n\n\t \n\tboth_edges = ctrl->both_edges & pending;\n\tif (both_edges) {\n\t\tstate = ath79_gpio_read(ctrl, AR71XX_GPIO_REG_IN);\n\t\tath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_POLARITY,\n\t\t\t\tboth_edges, ~state);\n\t}\n\n\traw_spin_unlock_irqrestore(&ctrl->lock, flags);\n\n\tfor_each_set_bit(irq, &pending, gc->ngpio)\n\t\tgeneric_handle_domain_irq(gc->irq.domain, irq);\n\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic const struct of_device_id ath79_gpio_of_match[] = {\n\t{ .compatible = \"qca,ar7100-gpio\" },\n\t{ .compatible = \"qca,ar9340-gpio\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ath79_gpio_of_match);\n\nstatic int ath79_gpio_probe(struct platform_device *pdev)\n{\n\tstruct ath79_gpio_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct ath79_gpio_ctrl *ctrl;\n\tstruct gpio_irq_chip *girq;\n\tu32 ath79_gpio_count;\n\tbool oe_inverted;\n\tint err;\n\n\tctrl = devm_kzalloc(dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tif (np) {\n\t\terr = of_property_read_u32(np, \"ngpios\", &ath79_gpio_count);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"ngpios property is not valid\\n\");\n\t\t\treturn err;\n\t\t}\n\t\toe_inverted = of_device_is_compatible(np, \"qca,ar9340-gpio\");\n\t} else if (pdata) {\n\t\tath79_gpio_count = pdata->ngpios;\n\t\toe_inverted = pdata->oe_inverted;\n\t} else {\n\t\tdev_err(dev, \"No DT node or platform data found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ath79_gpio_count >= 32) {\n\t\tdev_err(dev, \"ngpios must be less than 32\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctrl->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctrl->base))\n\t\treturn PTR_ERR(ctrl->base);\n\n\traw_spin_lock_init(&ctrl->lock);\n\terr = bgpio_init(&ctrl->gc, dev, 4,\n\t\t\tctrl->base + AR71XX_GPIO_REG_IN,\n\t\t\tctrl->base + AR71XX_GPIO_REG_SET,\n\t\t\tctrl->base + AR71XX_GPIO_REG_CLEAR,\n\t\t\toe_inverted ? NULL : ctrl->base + AR71XX_GPIO_REG_OE,\n\t\t\toe_inverted ? ctrl->base + AR71XX_GPIO_REG_OE : NULL,\n\t\t\t0);\n\tif (err) {\n\t\tdev_err(dev, \"bgpio_init failed\\n\");\n\t\treturn err;\n\t}\n\t \n\tctrl->gc.base = 0;\n\n\t \n\tif (!np || of_property_read_bool(np, \"interrupt-controller\")) {\n\t\tgirq = &ctrl->gc.irq;\n\t\tgpio_irq_chip_set_chip(girq, &ath79_gpio_irqchip);\n\t\tgirq->parent_handler = ath79_gpio_irq_handler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(dev, 1, sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\tgirq->parents[0] = platform_get_irq(pdev, 0);\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_simple_irq;\n\t}\n\n\treturn devm_gpiochip_add_data(dev, &ctrl->gc, ctrl);\n}\n\nstatic struct platform_driver ath79_gpio_driver = {\n\t.driver = {\n\t\t.name = \"ath79-gpio\",\n\t\t.of_match_table\t= ath79_gpio_of_match,\n\t},\n\t.probe = ath79_gpio_probe,\n};\n\nmodule_platform_driver(ath79_gpio_driver);\n\nMODULE_DESCRIPTION(\"Atheros AR71XX/AR724X/AR913X GPIO API support\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}