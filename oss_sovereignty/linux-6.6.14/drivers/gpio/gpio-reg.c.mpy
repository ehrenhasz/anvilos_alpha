{
  "module_name": "gpio-reg.c",
  "hash_id": "810677ad4fe416c87b7e38bd7f762dfcc6a437e554cf9953939e6efd587a61e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-reg.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/container_of.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/irqdomain.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#include <linux/gpio/driver.h>\n#include <linux/gpio/gpio-reg.h>\n\nstruct gpio_reg {\n\tstruct gpio_chip gc;\n\tspinlock_t lock;\n\tu32 direction;\n\tu32 out;\n\tvoid __iomem *reg;\n\tstruct irq_domain *irqdomain;\n\tconst int *irqs;\n};\n\n#define to_gpio_reg(x) container_of(x, struct gpio_reg, gc)\n\nstatic int gpio_reg_get_direction(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct gpio_reg *r = to_gpio_reg(gc);\n\n\treturn r->direction & BIT(offset) ? GPIO_LINE_DIRECTION_IN :\n\t\t\t\t\t    GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int gpio_reg_direction_output(struct gpio_chip *gc, unsigned offset,\n\tint value)\n{\n\tstruct gpio_reg *r = to_gpio_reg(gc);\n\n\tif (r->direction & BIT(offset))\n\t\treturn -ENOTSUPP;\n\n\tgc->set(gc, offset, value);\n\treturn 0;\n}\n\nstatic int gpio_reg_direction_input(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct gpio_reg *r = to_gpio_reg(gc);\n\n\treturn r->direction & BIT(offset) ? 0 : -ENOTSUPP;\n}\n\nstatic void gpio_reg_set(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tstruct gpio_reg *r = to_gpio_reg(gc);\n\tunsigned long flags;\n\tu32 val, mask = BIT(offset);\n\n\tspin_lock_irqsave(&r->lock, flags);\n\tval = r->out;\n\tif (value)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\tr->out = val;\n\twritel_relaxed(val, r->reg);\n\tspin_unlock_irqrestore(&r->lock, flags);\n}\n\nstatic int gpio_reg_get(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct gpio_reg *r = to_gpio_reg(gc);\n\tu32 val, mask = BIT(offset);\n\n\tif (r->direction & mask) {\n\t\t \n\t\treadl_relaxed(r->reg);\n\t\tval = readl_relaxed(r->reg);\n\t} else {\n\t\tval = r->out;\n\t}\n\treturn !!(val & mask);\n}\n\nstatic void gpio_reg_set_multiple(struct gpio_chip *gc, unsigned long *mask,\n\tunsigned long *bits)\n{\n\tstruct gpio_reg *r = to_gpio_reg(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&r->lock, flags);\n\tr->out = (r->out & ~*mask) | (*bits & *mask);\n\twritel_relaxed(r->out, r->reg);\n\tspin_unlock_irqrestore(&r->lock, flags);\n}\n\nstatic int gpio_reg_to_irq(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct gpio_reg *r = to_gpio_reg(gc);\n\tint irq = r->irqs[offset];\n\n\tif (irq >= 0 && r->irqdomain)\n\t\tirq = irq_find_mapping(r->irqdomain, irq);\n\n\treturn irq;\n}\n\n \nstruct gpio_chip *gpio_reg_init(struct device *dev, void __iomem *reg,\n\tint base, int num, const char *label, u32 direction, u32 def_out,\n\tconst char *const *names, struct irq_domain *irqdom, const int *irqs)\n{\n\tstruct gpio_reg *r;\n\tint ret;\n\n\tif (dev)\n\t\tr = devm_kzalloc(dev, sizeof(*r), GFP_KERNEL);\n\telse\n\t\tr = kzalloc(sizeof(*r), GFP_KERNEL);\n\n\tif (!r)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&r->lock);\n\n\tr->gc.label = label;\n\tr->gc.get_direction = gpio_reg_get_direction;\n\tr->gc.direction_input = gpio_reg_direction_input;\n\tr->gc.direction_output = gpio_reg_direction_output;\n\tr->gc.set = gpio_reg_set;\n\tr->gc.get = gpio_reg_get;\n\tr->gc.set_multiple = gpio_reg_set_multiple;\n\tif (irqs)\n\t\tr->gc.to_irq = gpio_reg_to_irq;\n\tr->gc.base = base;\n\tr->gc.ngpio = num;\n\tr->gc.names = names;\n\tr->direction = direction;\n\tr->out = def_out;\n\tr->reg = reg;\n\tr->irqs = irqs;\n\n\tif (dev)\n\t\tret = devm_gpiochip_add_data(dev, &r->gc, r);\n\telse\n\t\tret = gpiochip_add_data(&r->gc, r);\n\n\treturn ret ? ERR_PTR(ret) : &r->gc;\n}\n\nint gpio_reg_resume(struct gpio_chip *gc)\n{\n\tstruct gpio_reg *r = to_gpio_reg(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&r->lock, flags);\n\twritel_relaxed(r->out, r->reg);\n\tspin_unlock_irqrestore(&r->lock, flags);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}