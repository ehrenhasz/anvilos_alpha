{
  "module_name": "gpio-bd71815.c",
  "hash_id": "fce8021b93b9e3feff7cbbc5ebca0cb2587b75002c924f898b3ac3d6d6d3960c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-bd71815.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n \n#include <linux/mfd/rohm-bd71815.h>\n\nstruct bd71815_gpio {\n\t \n\tstruct gpio_chip chip;\n\t \n\tstruct device *dev;\n\tstruct regmap *regmap;\n};\n\nstatic int bd71815gpo_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct bd71815_gpio *bd71815 = gpiochip_get_data(chip);\n\tint ret, val;\n\n\tret = regmap_read(bd71815->regmap, BD71815_REG_GPO, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (val >> offset) & 1;\n}\n\nstatic void bd71815gpo_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t   int value)\n{\n\tstruct bd71815_gpio *bd71815 = gpiochip_get_data(chip);\n\tint ret, bit;\n\n\tbit = BIT(offset);\n\n\tif (value)\n\t\tret = regmap_set_bits(bd71815->regmap, BD71815_REG_GPO, bit);\n\telse\n\t\tret = regmap_clear_bits(bd71815->regmap, BD71815_REG_GPO, bit);\n\n\tif (ret)\n\t\tdev_warn(bd71815->dev, \"failed to toggle GPO\\n\");\n}\n\nstatic int bd71815_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t   unsigned long config)\n{\n\tstruct bd71815_gpio *bdgpio = gpiochip_get_data(chip);\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\treturn regmap_update_bits(bdgpio->regmap,\n\t\t\t\t\t  BD71815_REG_GPO,\n\t\t\t\t\t  BD71815_GPIO_DRIVE_MASK << offset,\n\t\t\t\t\t  BD71815_GPIO_OPEN_DRAIN << offset);\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\treturn regmap_update_bits(bdgpio->regmap,\n\t\t\t\t\t  BD71815_REG_GPO,\n\t\t\t\t\t  BD71815_GPIO_DRIVE_MASK << offset,\n\t\t\t\t\t  BD71815_GPIO_CMOS << offset);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -ENOTSUPP;\n}\n\n \nstatic int bd71815gpo_direction_get(struct gpio_chip *gc, unsigned int offset)\n{\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\n \nstatic const struct gpio_chip bd71815gpo_chip = {\n\t.label\t\t\t= \"bd71815\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.get\t\t\t= bd71815gpo_get,\n\t.get_direction\t\t= bd71815gpo_direction_get,\n\t.set\t\t\t= bd71815gpo_set,\n\t.set_config\t\t= bd71815_gpio_set_config,\n\t.can_sleep\t\t= true,\n};\n\n#define BD71815_TWO_GPIOS\tGENMASK(1, 0)\n#define BD71815_ONE_GPIO\tBIT(0)\n\n \nstatic int bd71815_init_valid_mask(struct gpio_chip *gc,\n\t\t\t\t   unsigned long *valid_mask,\n\t\t\t\t   unsigned int ngpios)\n{\n\tif (ngpios != 2)\n\t\treturn 0;\n\n\tif (gc->parent && device_property_present(gc->parent,\n\t\t\t\t\t\t  \"rohm,enable-hidden-gpo\"))\n\t\t*valid_mask = BD71815_TWO_GPIOS;\n\telse\n\t\t*valid_mask = BD71815_ONE_GPIO;\n\n\treturn 0;\n}\n\nstatic int gpo_bd71815_probe(struct platform_device *pdev)\n{\n\tstruct bd71815_gpio *g;\n\tstruct device *parent, *dev;\n\n\t \n\tdev = &pdev->dev;\n\t \n\tparent = dev->parent;\n\n\tg = devm_kzalloc(dev, sizeof(*g), GFP_KERNEL);\n\tif (!g)\n\t\treturn -ENOMEM;\n\n\tg->chip = bd71815gpo_chip;\n\n\t \n\tif (device_property_present(parent, \"rohm,enable-hidden-gpo\"))\n\t\tg->chip.ngpio = 2;\n\telse\n\t\tg->chip.ngpio = 1;\n\n\tg->chip.init_valid_mask = bd71815_init_valid_mask;\n\tg->chip.base = -1;\n\tg->chip.parent = parent;\n\tg->regmap = dev_get_regmap(parent, NULL);\n\tg->dev = dev;\n\n\treturn devm_gpiochip_add_data(dev, &g->chip, g);\n}\n\nstatic struct platform_driver gpo_bd71815_driver = {\n\t.driver = {\n\t\t.name\t= \"bd71815-gpo\",\n\t},\n\t.probe\t\t= gpo_bd71815_probe,\n};\nmodule_platform_driver(gpo_bd71815_driver);\n\nMODULE_ALIAS(\"platform:bd71815-gpo\");\nMODULE_AUTHOR(\"Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>\");\nMODULE_AUTHOR(\"Peter Yang <yanglsh@embest-tech.com>\");\nMODULE_DESCRIPTION(\"GPO interface for BD71815\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}