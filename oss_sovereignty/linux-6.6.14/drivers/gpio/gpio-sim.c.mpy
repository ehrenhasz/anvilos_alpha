{
  "module_name": "gpio-sim.c",
  "hash_id": "aee14833bbc5b62e7af739c9ce5bf19feec87a32bae6829c474dde888dcc63b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-sim.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitmap.h>\n#include <linux/cleanup.h>\n#include <linux/completion.h>\n#include <linux/configfs.h>\n#include <linux/device.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/machine.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/list.h>\n#include <linux/minmax.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/string_helpers.h>\n#include <linux/sysfs.h>\n\n#include \"gpiolib.h\"\n\n#define GPIO_SIM_NGPIO_MAX\t1024\n#define GPIO_SIM_PROP_MAX\t4  \n#define GPIO_SIM_NUM_ATTRS\t3  \n\nstatic DEFINE_IDA(gpio_sim_ida);\n\nstruct gpio_sim_chip {\n\tstruct gpio_chip gc;\n\tunsigned long *direction_map;\n\tunsigned long *value_map;\n\tunsigned long *pull_map;\n\tstruct irq_domain *irq_sim;\n\tstruct mutex lock;\n\tconst struct attribute_group **attr_groups;\n};\n\nstruct gpio_sim_attribute {\n\tstruct device_attribute dev_attr;\n\tunsigned int offset;\n};\n\nstatic struct gpio_sim_attribute *\nto_gpio_sim_attr(struct device_attribute *dev_attr)\n{\n\treturn container_of(dev_attr, struct gpio_sim_attribute, dev_attr);\n}\n\nstatic int gpio_sim_apply_pull(struct gpio_sim_chip *chip,\n\t\t\t       unsigned int offset, int value)\n{\n\tint irq, irq_type, ret;\n\tstruct gpio_desc *desc;\n\tstruct gpio_chip *gc;\n\n\tgc = &chip->gc;\n\tdesc = &gc->gpiodev->descs[offset];\n\n\tguard(mutex)(&chip->lock);\n\n\tif (test_bit(FLAG_REQUESTED, &desc->flags) &&\n\t    !test_bit(FLAG_IS_OUT, &desc->flags)) {\n\t\tif (value == !!test_bit(offset, chip->value_map))\n\t\t\tgoto set_pull;\n\n\t\t \n\t\tirq = irq_find_mapping(chip->irq_sim, offset);\n\t\tif (!irq)\n\t\t\tgoto set_value;\n\n\t\tirq_type = irq_get_trigger_type(irq);\n\n\t\tif ((value && (irq_type & IRQ_TYPE_EDGE_RISING)) ||\n\t\t    (!value && (irq_type & IRQ_TYPE_EDGE_FALLING))) {\n\t\t\tret = irq_set_irqchip_state(irq, IRQCHIP_STATE_PENDING,\n\t\t\t\t\t\t    true);\n\t\t\tif (ret)\n\t\t\t\tgoto set_pull;\n\t\t}\n\t}\n\nset_value:\n\t \n\tif (!test_bit(FLAG_REQUESTED, &desc->flags) ||\n\t    !test_bit(FLAG_IS_OUT, &desc->flags))\n\t\t__assign_bit(offset, chip->value_map, value);\n\nset_pull:\n\t__assign_bit(offset, chip->pull_map, value);\n\treturn 0;\n}\n\nstatic int gpio_sim_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_sim_chip *chip = gpiochip_get_data(gc);\n\n\tguard(mutex)(&chip->lock);\n\n\treturn !!test_bit(offset, chip->value_map);\n}\n\nstatic void gpio_sim_set(struct gpio_chip *gc, unsigned int offset, int value)\n{\n\tstruct gpio_sim_chip *chip = gpiochip_get_data(gc);\n\n\tscoped_guard(mutex, &chip->lock)\n\t\t__assign_bit(offset, chip->value_map, value);\n}\n\nstatic int gpio_sim_get_multiple(struct gpio_chip *gc,\n\t\t\t\t unsigned long *mask, unsigned long *bits)\n{\n\tstruct gpio_sim_chip *chip = gpiochip_get_data(gc);\n\n\tscoped_guard(mutex, &chip->lock)\n\t\tbitmap_replace(bits, bits, chip->value_map, mask, gc->ngpio);\n\n\treturn 0;\n}\n\nstatic void gpio_sim_set_multiple(struct gpio_chip *gc,\n\t\t\t\t  unsigned long *mask, unsigned long *bits)\n{\n\tstruct gpio_sim_chip *chip = gpiochip_get_data(gc);\n\n\tscoped_guard(mutex, &chip->lock)\n\t\tbitmap_replace(chip->value_map, chip->value_map, bits, mask,\n\t\t\t       gc->ngpio);\n}\n\nstatic int gpio_sim_direction_output(struct gpio_chip *gc,\n\t\t\t\t     unsigned int offset, int value)\n{\n\tstruct gpio_sim_chip *chip = gpiochip_get_data(gc);\n\n\tscoped_guard(mutex, &chip->lock) {\n\t\t__clear_bit(offset, chip->direction_map);\n\t\t__assign_bit(offset, chip->value_map, value);\n\t}\n\n\treturn 0;\n}\n\nstatic int gpio_sim_direction_input(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_sim_chip *chip = gpiochip_get_data(gc);\n\n\tscoped_guard(mutex, &chip->lock)\n\t\t__set_bit(offset, chip->direction_map);\n\n\treturn 0;\n}\n\nstatic int gpio_sim_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_sim_chip *chip = gpiochip_get_data(gc);\n\tint direction;\n\n\tscoped_guard(mutex, &chip->lock)\n\t\tdirection = !!test_bit(offset, chip->direction_map);\n\n\treturn direction ? GPIO_LINE_DIRECTION_IN : GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int gpio_sim_set_config(struct gpio_chip *gc,\n\t\t\t\t  unsigned int offset, unsigned long config)\n{\n\tstruct gpio_sim_chip *chip = gpiochip_get_data(gc);\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\treturn gpio_sim_apply_pull(chip, offset, 1);\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\treturn gpio_sim_apply_pull(chip, offset, 0);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic int gpio_sim_to_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_sim_chip *chip = gpiochip_get_data(gc);\n\n\treturn irq_create_mapping(chip->irq_sim, offset);\n}\n\nstatic void gpio_sim_free(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct gpio_sim_chip *chip = gpiochip_get_data(gc);\n\n\tscoped_guard(mutex, &chip->lock)\n\t\t__assign_bit(offset, chip->value_map,\n\t\t\t     !!test_bit(offset, chip->pull_map));\n}\n\nstatic ssize_t gpio_sim_sysfs_val_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct gpio_sim_attribute *line_attr = to_gpio_sim_attr(attr);\n\tstruct gpio_sim_chip *chip = dev_get_drvdata(dev);\n\tint val;\n\n\tscoped_guard(mutex, &chip->lock)\n\t\tval = !!test_bit(line_attr->offset, chip->value_map);\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t gpio_sim_sysfs_val_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\t \n\treturn -EPERM;\n}\n\nstatic const char *const gpio_sim_sysfs_pull_strings[] = {\n\t[0]\t= \"pull-down\",\n\t[1]\t= \"pull-up\",\n};\n\nstatic ssize_t gpio_sim_sysfs_pull_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct gpio_sim_attribute *line_attr = to_gpio_sim_attr(attr);\n\tstruct gpio_sim_chip *chip = dev_get_drvdata(dev);\n\tint pull;\n\n\tscoped_guard(mutex, &chip->lock)\n\t\tpull = !!test_bit(line_attr->offset, chip->pull_map);\n\n\treturn sysfs_emit(buf, \"%s\\n\", gpio_sim_sysfs_pull_strings[pull]);\n}\n\nstatic ssize_t gpio_sim_sysfs_pull_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t len)\n{\n\tstruct gpio_sim_attribute *line_attr = to_gpio_sim_attr(attr);\n\tstruct gpio_sim_chip *chip = dev_get_drvdata(dev);\n\tint ret, pull;\n\n\tpull = sysfs_match_string(gpio_sim_sysfs_pull_strings, buf);\n\tif (pull < 0)\n\t\treturn pull;\n\n\tret = gpio_sim_apply_pull(chip, line_attr->offset, pull);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic void gpio_sim_mutex_destroy(void *data)\n{\n\tstruct mutex *lock = data;\n\n\tmutex_destroy(lock);\n}\n\nstatic void gpio_sim_dispose_mappings(void *data)\n{\n\tstruct gpio_sim_chip *chip = data;\n\tunsigned int i;\n\n\tfor (i = 0; i < chip->gc.ngpio; i++)\n\t\tirq_dispose_mapping(irq_find_mapping(chip->irq_sim, i));\n}\n\nstatic void gpio_sim_sysfs_remove(void *data)\n{\n\tstruct gpio_sim_chip *chip = data;\n\n\tsysfs_remove_groups(&chip->gc.gpiodev->dev.kobj, chip->attr_groups);\n}\n\nstatic int gpio_sim_setup_sysfs(struct gpio_sim_chip *chip)\n{\n\tstruct device_attribute *val_dev_attr, *pull_dev_attr;\n\tstruct gpio_sim_attribute *val_attr, *pull_attr;\n\tunsigned int num_lines = chip->gc.ngpio;\n\tstruct device *dev = chip->gc.parent;\n\tstruct attribute_group *attr_group;\n\tstruct attribute **attrs;\n\tint i, ret;\n\n\tchip->attr_groups = devm_kcalloc(dev, sizeof(*chip->attr_groups),\n\t\t\t\t\t num_lines + 1, GFP_KERNEL);\n\tif (!chip->attr_groups)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_lines; i++) {\n\t\tattr_group = devm_kzalloc(dev, sizeof(*attr_group), GFP_KERNEL);\n\t\tattrs = devm_kcalloc(dev, GPIO_SIM_NUM_ATTRS, sizeof(*attrs),\n\t\t\t\t     GFP_KERNEL);\n\t\tval_attr = devm_kzalloc(dev, sizeof(*val_attr), GFP_KERNEL);\n\t\tpull_attr = devm_kzalloc(dev, sizeof(*pull_attr), GFP_KERNEL);\n\t\tif (!attr_group || !attrs || !val_attr || !pull_attr)\n\t\t\treturn -ENOMEM;\n\n\t\tattr_group->name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t  \"sim_gpio%u\", i);\n\t\tif (!attr_group->name)\n\t\t\treturn -ENOMEM;\n\n\t\tval_attr->offset = pull_attr->offset = i;\n\n\t\tval_dev_attr = &val_attr->dev_attr;\n\t\tpull_dev_attr = &pull_attr->dev_attr;\n\n\t\tsysfs_attr_init(&val_dev_attr->attr);\n\t\tsysfs_attr_init(&pull_dev_attr->attr);\n\n\t\tval_dev_attr->attr.name = \"value\";\n\t\tpull_dev_attr->attr.name = \"pull\";\n\n\t\tval_dev_attr->attr.mode = pull_dev_attr->attr.mode = 0644;\n\n\t\tval_dev_attr->show = gpio_sim_sysfs_val_show;\n\t\tval_dev_attr->store = gpio_sim_sysfs_val_store;\n\t\tpull_dev_attr->show = gpio_sim_sysfs_pull_show;\n\t\tpull_dev_attr->store = gpio_sim_sysfs_pull_store;\n\n\t\tattrs[0] = &val_dev_attr->attr;\n\t\tattrs[1] = &pull_dev_attr->attr;\n\n\t\tattr_group->attrs = attrs;\n\t\tchip->attr_groups[i] = attr_group;\n\t}\n\n\tret = sysfs_create_groups(&chip->gc.gpiodev->dev.kobj,\n\t\t\t\t  chip->attr_groups);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, gpio_sim_sysfs_remove, chip);\n}\n\nstatic int gpio_sim_add_bank(struct fwnode_handle *swnode, struct device *dev)\n{\n\tstruct gpio_sim_chip *chip;\n\tstruct gpio_chip *gc;\n\tconst char *label;\n\tu32 num_lines;\n\tint ret;\n\n\tret = fwnode_property_read_u32(swnode, \"ngpios\", &num_lines);\n\tif (ret)\n\t\treturn ret;\n\n\tif (num_lines > GPIO_SIM_NGPIO_MAX)\n\t\treturn -ERANGE;\n\n\tret = fwnode_property_read_string(swnode, \"gpio-sim,label\", &label);\n\tif (ret) {\n\t\tlabel = devm_kasprintf(dev, GFP_KERNEL, \"%s-%pfwP\",\n\t\t\t\t       dev_name(dev), swnode);\n\t\tif (!label)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->direction_map = devm_bitmap_alloc(dev, num_lines, GFP_KERNEL);\n\tif (!chip->direction_map)\n\t\treturn -ENOMEM;\n\n\t \n\tbitmap_fill(chip->direction_map, num_lines);\n\n\tchip->value_map = devm_bitmap_zalloc(dev, num_lines, GFP_KERNEL);\n\tif (!chip->value_map)\n\t\treturn -ENOMEM;\n\n\tchip->pull_map = devm_bitmap_zalloc(dev, num_lines, GFP_KERNEL);\n\tif (!chip->pull_map)\n\t\treturn -ENOMEM;\n\n\tchip->irq_sim = devm_irq_domain_create_sim(dev, swnode, num_lines);\n\tif (IS_ERR(chip->irq_sim))\n\t\treturn PTR_ERR(chip->irq_sim);\n\n\tret = devm_add_action_or_reset(dev, gpio_sim_dispose_mappings, chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&chip->lock);\n\tret = devm_add_action_or_reset(dev, gpio_sim_mutex_destroy,\n\t\t\t\t       &chip->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tgc = &chip->gc;\n\tgc->base = -1;\n\tgc->ngpio = num_lines;\n\tgc->label = label;\n\tgc->owner = THIS_MODULE;\n\tgc->parent = dev;\n\tgc->fwnode = swnode;\n\tgc->get = gpio_sim_get;\n\tgc->set = gpio_sim_set;\n\tgc->get_multiple = gpio_sim_get_multiple;\n\tgc->set_multiple = gpio_sim_set_multiple;\n\tgc->direction_output = gpio_sim_direction_output;\n\tgc->direction_input = gpio_sim_direction_input;\n\tgc->get_direction = gpio_sim_get_direction;\n\tgc->set_config = gpio_sim_set_config;\n\tgc->to_irq = gpio_sim_to_irq;\n\tgc->free = gpio_sim_free;\n\tgc->can_sleep = true;\n\n\tret = devm_gpiochip_add_data(dev, gc, chip);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdev_set_drvdata(&gc->gpiodev->dev, chip);\n\n\treturn gpio_sim_setup_sysfs(chip);\n}\n\nstatic int gpio_sim_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fwnode_handle *swnode;\n\tint ret;\n\n\tdevice_for_each_child_node(dev, swnode) {\n\t\tret = gpio_sim_add_bank(swnode, dev);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(swnode);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id gpio_sim_of_match[] = {\n\t{ .compatible = \"gpio-simulator\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, gpio_sim_of_match);\n\nstatic struct platform_driver gpio_sim_driver = {\n\t.driver = {\n\t\t.name = \"gpio-sim\",\n\t\t.of_match_table = gpio_sim_of_match,\n\t},\n\t.probe = gpio_sim_probe,\n};\n\nstruct gpio_sim_device {\n\tstruct config_group group;\n\n\t \n\tstruct platform_device *pdev;\n\tint id;\n\n\t \n\tstruct mutex lock;\n\n\t \n\tstruct notifier_block bus_notifier;\n\tstruct completion probe_completion;\n\tbool driver_bound;\n\n\tstruct gpiod_hog *hogs;\n\n\tstruct list_head bank_list;\n};\n\n \nstatic int gpio_sim_bus_notifier_call(struct notifier_block *nb,\n\t\t\t\t      unsigned long action, void *data)\n{\n\tstruct gpio_sim_device *simdev = container_of(nb,\n\t\t\t\t\t\t      struct gpio_sim_device,\n\t\t\t\t\t\t      bus_notifier);\n\tstruct device *dev = data;\n\tchar devname[32];\n\n\tsnprintf(devname, sizeof(devname), \"gpio-sim.%u\", simdev->id);\n\n\tif (strcmp(dev_name(dev), devname) == 0) {\n\t\tif (action == BUS_NOTIFY_BOUND_DRIVER)\n\t\t\tsimdev->driver_bound = true;\n\t\telse if (action == BUS_NOTIFY_DRIVER_NOT_BOUND)\n\t\t\tsimdev->driver_bound = false;\n\t\telse\n\t\t\treturn NOTIFY_DONE;\n\n\t\tcomplete(&simdev->probe_completion);\n\t\treturn NOTIFY_OK;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct gpio_sim_device *to_gpio_sim_device(struct config_item *item)\n{\n\tstruct config_group *group = to_config_group(item);\n\n\treturn container_of(group, struct gpio_sim_device, group);\n}\n\nstruct gpio_sim_bank {\n\tstruct config_group group;\n\n\t \n\tstruct gpio_sim_device *parent;\n\tstruct list_head siblings;\n\n\tchar *label;\n\tunsigned int num_lines;\n\n\tstruct list_head line_list;\n\n\tstruct fwnode_handle *swnode;\n};\n\nstatic struct gpio_sim_bank *to_gpio_sim_bank(struct config_item *item)\n{\n\tstruct config_group *group = to_config_group(item);\n\n\treturn container_of(group, struct gpio_sim_bank, group);\n}\n\nstatic bool gpio_sim_bank_has_label(struct gpio_sim_bank *bank)\n{\n\treturn bank->label && *bank->label;\n}\n\nstatic struct gpio_sim_device *\ngpio_sim_bank_get_device(struct gpio_sim_bank *bank)\n{\n\treturn bank->parent;\n}\n\nstruct gpio_sim_hog;\n\nstruct gpio_sim_line {\n\tstruct config_group group;\n\n\tstruct gpio_sim_bank *parent;\n\tstruct list_head siblings;\n\n\tunsigned int offset;\n\tchar *name;\n\n\t \n\tstruct gpio_sim_hog *hog;\n};\n\nstatic struct gpio_sim_line *to_gpio_sim_line(struct config_item *item)\n{\n\tstruct config_group *group = to_config_group(item);\n\n\treturn container_of(group, struct gpio_sim_line, group);\n}\n\nstatic struct gpio_sim_device *\ngpio_sim_line_get_device(struct gpio_sim_line *line)\n{\n\tstruct gpio_sim_bank *bank = line->parent;\n\n\treturn gpio_sim_bank_get_device(bank);\n}\n\nstruct gpio_sim_hog {\n\tstruct config_item item;\n\tstruct gpio_sim_line *parent;\n\n\tchar *name;\n\tint dir;\n};\n\nstatic struct gpio_sim_hog *to_gpio_sim_hog(struct config_item *item)\n{\n\treturn container_of(item, struct gpio_sim_hog, item);\n}\n\nstatic struct gpio_sim_device *gpio_sim_hog_get_device(struct gpio_sim_hog *hog)\n{\n\tstruct gpio_sim_line *line = hog->parent;\n\n\treturn gpio_sim_line_get_device(line);\n}\n\nstatic bool gpio_sim_device_is_live_unlocked(struct gpio_sim_device *dev)\n{\n\treturn !!dev->pdev;\n}\n\nstatic char *gpio_sim_strdup_trimmed(const char *str, size_t count)\n{\n\tchar *trimmed;\n\n\ttrimmed = kstrndup(skip_spaces(str), count, GFP_KERNEL);\n\tif (!trimmed)\n\t\treturn NULL;\n\n\treturn strim(trimmed);\n}\n\nstatic ssize_t gpio_sim_device_config_dev_name_show(struct config_item *item,\n\t\t\t\t\t\t    char *page)\n{\n\tstruct gpio_sim_device *dev = to_gpio_sim_device(item);\n\tstruct platform_device *pdev;\n\n\tguard(mutex)(&dev->lock);\n\n\tpdev = dev->pdev;\n\tif (pdev)\n\t\treturn sprintf(page, \"%s\\n\", dev_name(&pdev->dev));\n\n\treturn sprintf(page, \"gpio-sim.%d\\n\", dev->id);\n}\n\nCONFIGFS_ATTR_RO(gpio_sim_device_config_, dev_name);\n\nstatic ssize_t\ngpio_sim_device_config_live_show(struct config_item *item, char *page)\n{\n\tstruct gpio_sim_device *dev = to_gpio_sim_device(item);\n\tbool live;\n\n\tscoped_guard(mutex, &dev->lock)\n\t\tlive = gpio_sim_device_is_live_unlocked(dev);\n\n\treturn sprintf(page, \"%c\\n\", live ? '1' : '0');\n}\n\nstatic unsigned int gpio_sim_get_line_names_size(struct gpio_sim_bank *bank)\n{\n\tstruct gpio_sim_line *line;\n\tunsigned int size = 0;\n\n\tlist_for_each_entry(line, &bank->line_list, siblings) {\n\t\tif (!line->name || (line->offset >= bank->num_lines))\n\t\t\tcontinue;\n\n\t\tsize = max(size, line->offset + 1);\n\t}\n\n\treturn size;\n}\n\nstatic void\ngpio_sim_set_line_names(struct gpio_sim_bank *bank, char **line_names)\n{\n\tstruct gpio_sim_line *line;\n\n\tlist_for_each_entry(line, &bank->line_list, siblings) {\n\t\tif (!line->name || (line->offset >= bank->num_lines))\n\t\t\tcontinue;\n\n\t\tline_names[line->offset] = line->name;\n\t}\n}\n\nstatic void gpio_sim_remove_hogs(struct gpio_sim_device *dev)\n{\n\tstruct gpiod_hog *hog;\n\n\tif (!dev->hogs)\n\t\treturn;\n\n\tgpiod_remove_hogs(dev->hogs);\n\n\tfor (hog = dev->hogs; hog->chip_label; hog++) {\n\t\tkfree(hog->chip_label);\n\t\tkfree(hog->line_name);\n\t}\n\n\tkfree(dev->hogs);\n\tdev->hogs = NULL;\n}\n\nstatic int gpio_sim_add_hogs(struct gpio_sim_device *dev)\n{\n\tunsigned int num_hogs = 0, idx = 0;\n\tstruct gpio_sim_bank *bank;\n\tstruct gpio_sim_line *line;\n\tstruct gpiod_hog *hog;\n\n\tlist_for_each_entry(bank, &dev->bank_list, siblings) {\n\t\tlist_for_each_entry(line, &bank->line_list, siblings) {\n\t\t\tif (line->offset >= bank->num_lines)\n\t\t\t\tcontinue;\n\n\t\t\tif (line->hog)\n\t\t\t\tnum_hogs++;\n\t\t}\n\t}\n\n\tif (!num_hogs)\n\t\treturn 0;\n\n\t \n\tdev->hogs = kcalloc(num_hogs + 1, sizeof(*dev->hogs), GFP_KERNEL);\n\tif (!dev->hogs)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(bank, &dev->bank_list, siblings) {\n\t\tlist_for_each_entry(line, &bank->line_list, siblings) {\n\t\t\tif (line->offset >= bank->num_lines)\n\t\t\t\tcontinue;\n\n\t\t\tif (!line->hog)\n\t\t\t\tcontinue;\n\n\t\t\thog = &dev->hogs[idx++];\n\n\t\t\t \n\t\t\tif (gpio_sim_bank_has_label(bank))\n\t\t\t\thog->chip_label = kstrdup(bank->label,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\telse\n\t\t\t\thog->chip_label = kasprintf(GFP_KERNEL,\n\t\t\t\t\t\t\t\"gpio-sim.%u-%pfwP\",\n\t\t\t\t\t\t\tdev->id,\n\t\t\t\t\t\t\tbank->swnode);\n\t\t\tif (!hog->chip_label) {\n\t\t\t\tgpio_sim_remove_hogs(dev);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (line->hog->name) {\n\t\t\t\thog->line_name = kstrdup(line->hog->name,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\t\tif (!hog->line_name) {\n\t\t\t\t\tgpio_sim_remove_hogs(dev);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thog->chip_hwnum = line->offset;\n\t\t\thog->dflags = line->hog->dir;\n\t\t}\n\t}\n\n\tgpiod_add_hogs(dev->hogs);\n\n\treturn 0;\n}\n\nstatic struct fwnode_handle *\ngpio_sim_make_bank_swnode(struct gpio_sim_bank *bank,\n\t\t\t  struct fwnode_handle *parent)\n{\n\tstruct property_entry properties[GPIO_SIM_PROP_MAX];\n\tunsigned int prop_idx = 0, line_names_size;\n\tchar **line_names __free(kfree) = NULL;\n\n\tmemset(properties, 0, sizeof(properties));\n\n\tproperties[prop_idx++] = PROPERTY_ENTRY_U32(\"ngpios\", bank->num_lines);\n\n\tif (gpio_sim_bank_has_label(bank))\n\t\tproperties[prop_idx++] = PROPERTY_ENTRY_STRING(\"gpio-sim,label\",\n\t\t\t\t\t\t\t       bank->label);\n\n\tline_names_size = gpio_sim_get_line_names_size(bank);\n\tif (line_names_size) {\n\t\tline_names = kcalloc(line_names_size, sizeof(*line_names),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!line_names)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tgpio_sim_set_line_names(bank, line_names);\n\n\t\tproperties[prop_idx++] = PROPERTY_ENTRY_STRING_ARRAY_LEN(\n\t\t\t\t\t\t\"gpio-line-names\",\n\t\t\t\t\t\tline_names, line_names_size);\n\t}\n\n\treturn fwnode_create_software_node(properties, parent);\n}\n\nstatic void gpio_sim_remove_swnode_recursive(struct fwnode_handle *swnode)\n{\n\tstruct fwnode_handle *child;\n\n\tfwnode_for_each_child_node(swnode, child)\n\t\tfwnode_remove_software_node(child);\n\n\tfwnode_remove_software_node(swnode);\n}\n\nstatic bool gpio_sim_bank_labels_non_unique(struct gpio_sim_device *dev)\n{\n\tstruct gpio_sim_bank *this, *pos;\n\n\tlist_for_each_entry(this, &dev->bank_list, siblings) {\n\t\tlist_for_each_entry(pos, &dev->bank_list, siblings) {\n\t\t\tif (this == pos || (!this->label || !pos->label))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(this->label, pos->label) == 0)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int gpio_sim_device_activate_unlocked(struct gpio_sim_device *dev)\n{\n\tstruct platform_device_info pdevinfo;\n\tstruct fwnode_handle *swnode;\n\tstruct platform_device *pdev;\n\tstruct gpio_sim_bank *bank;\n\tint ret;\n\n\tif (list_empty(&dev->bank_list))\n\t\treturn -ENODATA;\n\n\t \n\tif (gpio_sim_bank_labels_non_unique(dev))\n\t\treturn -EINVAL;\n\n\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\n\tswnode = fwnode_create_software_node(NULL, NULL);\n\tif (IS_ERR(swnode))\n\t\treturn PTR_ERR(swnode);\n\n\tlist_for_each_entry(bank, &dev->bank_list, siblings) {\n\t\tbank->swnode = gpio_sim_make_bank_swnode(bank, swnode);\n\t\tif (IS_ERR(bank->swnode)) {\n\t\t\tret = PTR_ERR(bank->swnode);\n\t\t\tgpio_sim_remove_swnode_recursive(swnode);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = gpio_sim_add_hogs(dev);\n\tif (ret) {\n\t\tgpio_sim_remove_swnode_recursive(swnode);\n\t\treturn ret;\n\t}\n\n\tpdevinfo.name = \"gpio-sim\";\n\tpdevinfo.fwnode = swnode;\n\tpdevinfo.id = dev->id;\n\n\treinit_completion(&dev->probe_completion);\n\tdev->driver_bound = false;\n\tbus_register_notifier(&platform_bus_type, &dev->bus_notifier);\n\n\tpdev = platform_device_register_full(&pdevinfo);\n\tif (IS_ERR(pdev)) {\n\t\tbus_unregister_notifier(&platform_bus_type, &dev->bus_notifier);\n\t\tgpio_sim_remove_hogs(dev);\n\t\tgpio_sim_remove_swnode_recursive(swnode);\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\twait_for_completion(&dev->probe_completion);\n\tbus_unregister_notifier(&platform_bus_type, &dev->bus_notifier);\n\n\tif (!dev->driver_bound) {\n\t\t \n\t\tplatform_device_unregister(pdev);\n\t\tgpio_sim_remove_hogs(dev);\n\t\tgpio_sim_remove_swnode_recursive(swnode);\n\t\treturn -ENXIO;\n\t}\n\n\tdev->pdev = pdev;\n\n\treturn 0;\n}\n\nstatic void gpio_sim_device_deactivate_unlocked(struct gpio_sim_device *dev)\n{\n\tstruct fwnode_handle *swnode;\n\n\tswnode = dev_fwnode(&dev->pdev->dev);\n\tplatform_device_unregister(dev->pdev);\n\tgpio_sim_remove_hogs(dev);\n\tgpio_sim_remove_swnode_recursive(swnode);\n\tdev->pdev = NULL;\n}\n\nstatic ssize_t\ngpio_sim_device_config_live_store(struct config_item *item,\n\t\t\t\t  const char *page, size_t count)\n{\n\tstruct gpio_sim_device *dev = to_gpio_sim_device(item);\n\tbool live;\n\tint ret;\n\n\tret = kstrtobool(page, &live);\n\tif (ret)\n\t\treturn ret;\n\n\tguard(mutex)(&dev->lock);\n\n\tif (live == gpio_sim_device_is_live_unlocked(dev))\n\t\tret = -EPERM;\n\telse if (live)\n\t\tret = gpio_sim_device_activate_unlocked(dev);\n\telse\n\t\tgpio_sim_device_deactivate_unlocked(dev);\n\n\treturn ret ?: count;\n}\n\nCONFIGFS_ATTR(gpio_sim_device_config_, live);\n\nstatic struct configfs_attribute *gpio_sim_device_config_attrs[] = {\n\t&gpio_sim_device_config_attr_dev_name,\n\t&gpio_sim_device_config_attr_live,\n\tNULL\n};\n\nstruct gpio_sim_chip_name_ctx {\n\tstruct fwnode_handle *swnode;\n\tchar *page;\n};\n\nstatic int gpio_sim_emit_chip_name(struct device *dev, void *data)\n{\n\tstruct gpio_sim_chip_name_ctx *ctx = data;\n\n\t \n\tif (dev->class)\n\t\treturn 0;\n\n\tif (device_match_fwnode(dev, ctx->swnode))\n\t\treturn sprintf(ctx->page, \"%s\\n\", dev_name(dev));\n\n\treturn 0;\n}\n\nstatic ssize_t gpio_sim_bank_config_chip_name_show(struct config_item *item,\n\t\t\t\t\t\t   char *page)\n{\n\tstruct gpio_sim_bank *bank = to_gpio_sim_bank(item);\n\tstruct gpio_sim_device *dev = gpio_sim_bank_get_device(bank);\n\tstruct gpio_sim_chip_name_ctx ctx = { bank->swnode, page };\n\n\tguard(mutex)(&dev->lock);\n\n\tif (gpio_sim_device_is_live_unlocked(dev))\n\t\treturn device_for_each_child(&dev->pdev->dev, &ctx,\n\t\t\t\t\t     gpio_sim_emit_chip_name);\n\n\treturn sprintf(page, \"none\\n\");\n}\n\nCONFIGFS_ATTR_RO(gpio_sim_bank_config_, chip_name);\n\nstatic ssize_t\ngpio_sim_bank_config_label_show(struct config_item *item, char *page)\n{\n\tstruct gpio_sim_bank *bank = to_gpio_sim_bank(item);\n\tstruct gpio_sim_device *dev = gpio_sim_bank_get_device(bank);\n\n\tguard(mutex)(&dev->lock);\n\n\treturn sprintf(page, \"%s\\n\", bank->label ?: \"\");\n}\n\nstatic ssize_t gpio_sim_bank_config_label_store(struct config_item *item,\n\t\t\t\t\t\tconst char *page, size_t count)\n{\n\tstruct gpio_sim_bank *bank = to_gpio_sim_bank(item);\n\tstruct gpio_sim_device *dev = gpio_sim_bank_get_device(bank);\n\tchar *trimmed;\n\n\tguard(mutex)(&dev->lock);\n\n\tif (gpio_sim_device_is_live_unlocked(dev))\n\t\treturn -EBUSY;\n\n\ttrimmed = gpio_sim_strdup_trimmed(page, count);\n\tif (!trimmed)\n\t\treturn -ENOMEM;\n\n\tkfree(bank->label);\n\tbank->label = trimmed;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(gpio_sim_bank_config_, label);\n\nstatic ssize_t\ngpio_sim_bank_config_num_lines_show(struct config_item *item, char *page)\n{\n\tstruct gpio_sim_bank *bank = to_gpio_sim_bank(item);\n\tstruct gpio_sim_device *dev = gpio_sim_bank_get_device(bank);\n\n\tguard(mutex)(&dev->lock);\n\n\treturn sprintf(page, \"%u\\n\", bank->num_lines);\n}\n\nstatic ssize_t\ngpio_sim_bank_config_num_lines_store(struct config_item *item,\n\t\t\t\t     const char *page, size_t count)\n{\n\tstruct gpio_sim_bank *bank = to_gpio_sim_bank(item);\n\tstruct gpio_sim_device *dev = gpio_sim_bank_get_device(bank);\n\tunsigned int num_lines;\n\tint ret;\n\n\tret = kstrtouint(page, 0, &num_lines);\n\tif (ret)\n\t\treturn ret;\n\n\tif (num_lines == 0)\n\t\treturn -EINVAL;\n\n\tguard(mutex)(&dev->lock);\n\n\tif (gpio_sim_device_is_live_unlocked(dev))\n\t\treturn -EBUSY;\n\n\tbank->num_lines = num_lines;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(gpio_sim_bank_config_, num_lines);\n\nstatic struct configfs_attribute *gpio_sim_bank_config_attrs[] = {\n\t&gpio_sim_bank_config_attr_chip_name,\n\t&gpio_sim_bank_config_attr_label,\n\t&gpio_sim_bank_config_attr_num_lines,\n\tNULL\n};\n\nstatic ssize_t\ngpio_sim_line_config_name_show(struct config_item *item, char *page)\n{\n\tstruct gpio_sim_line *line = to_gpio_sim_line(item);\n\tstruct gpio_sim_device *dev = gpio_sim_line_get_device(line);\n\n\tguard(mutex)(&dev->lock);\n\n\treturn sprintf(page, \"%s\\n\", line->name ?: \"\");\n}\n\nstatic ssize_t gpio_sim_line_config_name_store(struct config_item *item,\n\t\t\t\t\t       const char *page, size_t count)\n{\n\tstruct gpio_sim_line *line = to_gpio_sim_line(item);\n\tstruct gpio_sim_device *dev = gpio_sim_line_get_device(line);\n\tchar *trimmed;\n\n\tguard(mutex)(&dev->lock);\n\n\tif (gpio_sim_device_is_live_unlocked(dev))\n\t\treturn -EBUSY;\n\n\ttrimmed = gpio_sim_strdup_trimmed(page, count);\n\tif (!trimmed)\n\t\treturn -ENOMEM;\n\n\tkfree(line->name);\n\tline->name = trimmed;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(gpio_sim_line_config_, name);\n\nstatic struct configfs_attribute *gpio_sim_line_config_attrs[] = {\n\t&gpio_sim_line_config_attr_name,\n\tNULL\n};\n\nstatic ssize_t gpio_sim_hog_config_name_show(struct config_item *item,\n\t\t\t\t\t     char *page)\n{\n\tstruct gpio_sim_hog *hog = to_gpio_sim_hog(item);\n\tstruct gpio_sim_device *dev = gpio_sim_hog_get_device(hog);\n\n\tguard(mutex)(&dev->lock);\n\n\treturn sprintf(page, \"%s\\n\", hog->name ?: \"\");\n}\n\nstatic ssize_t gpio_sim_hog_config_name_store(struct config_item *item,\n\t\t\t\t\t      const char *page, size_t count)\n{\n\tstruct gpio_sim_hog *hog = to_gpio_sim_hog(item);\n\tstruct gpio_sim_device *dev = gpio_sim_hog_get_device(hog);\n\tchar *trimmed;\n\n\tguard(mutex)(&dev->lock);\n\n\tif (gpio_sim_device_is_live_unlocked(dev))\n\t\treturn -EBUSY;\n\n\ttrimmed = gpio_sim_strdup_trimmed(page, count);\n\tif (!trimmed)\n\t\treturn -ENOMEM;\n\n\tkfree(hog->name);\n\thog->name = trimmed;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(gpio_sim_hog_config_, name);\n\nstatic ssize_t gpio_sim_hog_config_direction_show(struct config_item *item,\n\t\t\t\t\t\t  char *page)\n{\n\tstruct gpio_sim_hog *hog = to_gpio_sim_hog(item);\n\tstruct gpio_sim_device *dev = gpio_sim_hog_get_device(hog);\n\tchar *repr;\n\tint dir;\n\n\tscoped_guard(mutex, &dev->lock)\n\t\tdir = hog->dir;\n\n\tswitch (dir) {\n\tcase GPIOD_IN:\n\t\trepr = \"input\";\n\t\tbreak;\n\tcase GPIOD_OUT_HIGH:\n\t\trepr = \"output-high\";\n\t\tbreak;\n\tcase GPIOD_OUT_LOW:\n\t\trepr = \"output-low\";\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN(1, \"Unexpected hog direction value: %d\", dir);\n\t\treturn -EINVAL;\n\t}\n\n\treturn sprintf(page, \"%s\\n\", repr);\n}\n\nstatic ssize_t\ngpio_sim_hog_config_direction_store(struct config_item *item,\n\t\t\t\t    const char *page, size_t count)\n{\n\tstruct gpio_sim_hog *hog = to_gpio_sim_hog(item);\n\tstruct gpio_sim_device *dev = gpio_sim_hog_get_device(hog);\n\tint dir;\n\n\tguard(mutex)(&dev->lock);\n\n\tif (gpio_sim_device_is_live_unlocked(dev))\n\t\treturn -EBUSY;\n\n\tif (sysfs_streq(page, \"input\"))\n\t\tdir = GPIOD_IN;\n\telse if (sysfs_streq(page, \"output-high\"))\n\t\tdir = GPIOD_OUT_HIGH;\n\telse if (sysfs_streq(page, \"output-low\"))\n\t\tdir = GPIOD_OUT_LOW;\n\telse\n\t\treturn -EINVAL;\n\n\thog->dir = dir;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(gpio_sim_hog_config_, direction);\n\nstatic struct configfs_attribute *gpio_sim_hog_config_attrs[] = {\n\t&gpio_sim_hog_config_attr_name,\n\t&gpio_sim_hog_config_attr_direction,\n\tNULL\n};\n\nstatic void gpio_sim_hog_config_item_release(struct config_item *item)\n{\n\tstruct gpio_sim_hog *hog = to_gpio_sim_hog(item);\n\tstruct gpio_sim_line *line = hog->parent;\n\tstruct gpio_sim_device *dev = gpio_sim_hog_get_device(hog);\n\n\tscoped_guard(mutex, &dev->lock)\n\t\tline->hog = NULL;\n\n\tkfree(hog->name);\n\tkfree(hog);\n}\n\nstatic struct configfs_item_operations gpio_sim_hog_config_item_ops = {\n\t.release\t= gpio_sim_hog_config_item_release,\n};\n\nstatic const struct config_item_type gpio_sim_hog_config_type = {\n\t.ct_item_ops\t= &gpio_sim_hog_config_item_ops,\n\t.ct_attrs\t= gpio_sim_hog_config_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_item *\ngpio_sim_line_config_make_hog_item(struct config_group *group, const char *name)\n{\n\tstruct gpio_sim_line *line = to_gpio_sim_line(&group->cg_item);\n\tstruct gpio_sim_device *dev = gpio_sim_line_get_device(line);\n\tstruct gpio_sim_hog *hog;\n\n\tif (strcmp(name, \"hog\") != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tguard(mutex)(&dev->lock);\n\n\thog = kzalloc(sizeof(*hog), GFP_KERNEL);\n\tif (!hog)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig_item_init_type_name(&hog->item, name,\n\t\t\t\t   &gpio_sim_hog_config_type);\n\n\thog->dir = GPIOD_IN;\n\thog->name = NULL;\n\thog->parent = line;\n\tline->hog = hog;\n\n\treturn &hog->item;\n}\n\nstatic void gpio_sim_line_config_group_release(struct config_item *item)\n{\n\tstruct gpio_sim_line *line = to_gpio_sim_line(item);\n\tstruct gpio_sim_device *dev = gpio_sim_line_get_device(line);\n\n\tscoped_guard(mutex, &dev->lock)\n\t\tlist_del(&line->siblings);\n\n\tkfree(line->name);\n\tkfree(line);\n}\n\nstatic struct configfs_item_operations gpio_sim_line_config_item_ops = {\n\t.release\t= gpio_sim_line_config_group_release,\n};\n\nstatic struct configfs_group_operations gpio_sim_line_config_group_ops = {\n\t.make_item\t= gpio_sim_line_config_make_hog_item,\n};\n\nstatic const struct config_item_type gpio_sim_line_config_type = {\n\t.ct_item_ops\t= &gpio_sim_line_config_item_ops,\n\t.ct_group_ops\t= &gpio_sim_line_config_group_ops,\n\t.ct_attrs\t= gpio_sim_line_config_attrs,\n\t.ct_owner       = THIS_MODULE,\n};\n\nstatic struct config_group *\ngpio_sim_bank_config_make_line_group(struct config_group *group,\n\t\t\t\t     const char *name)\n{\n\tstruct gpio_sim_bank *bank = to_gpio_sim_bank(&group->cg_item);\n\tstruct gpio_sim_device *dev = gpio_sim_bank_get_device(bank);\n\tstruct gpio_sim_line *line;\n\tunsigned int offset;\n\tint ret, nchar;\n\n\tret = sscanf(name, \"line%u%n\", &offset, &nchar);\n\tif (ret != 1 || nchar != strlen(name))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tguard(mutex)(&dev->lock);\n\n\tif (gpio_sim_device_is_live_unlocked(dev))\n\t\treturn ERR_PTR(-EBUSY);\n\n\tline = kzalloc(sizeof(*line), GFP_KERNEL);\n\tif (!line)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig_group_init_type_name(&line->group, name,\n\t\t\t\t    &gpio_sim_line_config_type);\n\n\tline->parent = bank;\n\tline->offset = offset;\n\tlist_add_tail(&line->siblings, &bank->line_list);\n\n\treturn &line->group;\n}\n\nstatic void gpio_sim_bank_config_group_release(struct config_item *item)\n{\n\tstruct gpio_sim_bank *bank = to_gpio_sim_bank(item);\n\tstruct gpio_sim_device *dev = gpio_sim_bank_get_device(bank);\n\n\tscoped_guard(mutex, &dev->lock)\n\t\tlist_del(&bank->siblings);\n\n\tkfree(bank->label);\n\tkfree(bank);\n}\n\nstatic struct configfs_item_operations gpio_sim_bank_config_item_ops = {\n\t.release\t= gpio_sim_bank_config_group_release,\n};\n\nstatic struct configfs_group_operations gpio_sim_bank_config_group_ops = {\n\t.make_group\t= gpio_sim_bank_config_make_line_group,\n};\n\nstatic const struct config_item_type gpio_sim_bank_config_group_type = {\n\t.ct_item_ops\t= &gpio_sim_bank_config_item_ops,\n\t.ct_group_ops\t= &gpio_sim_bank_config_group_ops,\n\t.ct_attrs\t= gpio_sim_bank_config_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_group *\ngpio_sim_device_config_make_bank_group(struct config_group *group,\n\t\t\t\t       const char *name)\n{\n\tstruct gpio_sim_device *dev = to_gpio_sim_device(&group->cg_item);\n\tstruct gpio_sim_bank *bank;\n\n\tguard(mutex)(&dev->lock);\n\n\tif (gpio_sim_device_is_live_unlocked(dev))\n\t\treturn ERR_PTR(-EBUSY);\n\n\tbank = kzalloc(sizeof(*bank), GFP_KERNEL);\n\tif (!bank)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig_group_init_type_name(&bank->group, name,\n\t\t\t\t    &gpio_sim_bank_config_group_type);\n\tbank->num_lines = 1;\n\tbank->parent = dev;\n\tINIT_LIST_HEAD(&bank->line_list);\n\tlist_add_tail(&bank->siblings, &dev->bank_list);\n\n\treturn &bank->group;\n}\n\nstatic void gpio_sim_device_config_group_release(struct config_item *item)\n{\n\tstruct gpio_sim_device *dev = to_gpio_sim_device(item);\n\n\tscoped_guard(mutex, &dev->lock) {\n\t\tif (gpio_sim_device_is_live_unlocked(dev))\n\t\t\tgpio_sim_device_deactivate_unlocked(dev);\n\t}\n\n\tmutex_destroy(&dev->lock);\n\tida_free(&gpio_sim_ida, dev->id);\n\tkfree(dev);\n}\n\nstatic struct configfs_item_operations gpio_sim_device_config_item_ops = {\n\t.release\t= gpio_sim_device_config_group_release,\n};\n\nstatic struct configfs_group_operations gpio_sim_device_config_group_ops = {\n\t.make_group\t= gpio_sim_device_config_make_bank_group,\n};\n\nstatic const struct config_item_type gpio_sim_device_config_group_type = {\n\t.ct_item_ops\t= &gpio_sim_device_config_item_ops,\n\t.ct_group_ops\t= &gpio_sim_device_config_group_ops,\n\t.ct_attrs\t= gpio_sim_device_config_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_group *\ngpio_sim_config_make_device_group(struct config_group *group, const char *name)\n{\n\tint id;\n\n\tstruct gpio_sim_device *dev __free(kfree) = kzalloc(sizeof(*dev),\n\t\t\t\t\t\t\t    GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tid = ida_alloc(&gpio_sim_ida, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn ERR_PTR(id);\n\n\tconfig_group_init_type_name(&dev->group, name,\n\t\t\t\t    &gpio_sim_device_config_group_type);\n\tdev->id = id;\n\tmutex_init(&dev->lock);\n\tINIT_LIST_HEAD(&dev->bank_list);\n\n\tdev->bus_notifier.notifier_call = gpio_sim_bus_notifier_call;\n\tinit_completion(&dev->probe_completion);\n\n\treturn &no_free_ptr(dev)->group;\n}\n\nstatic struct configfs_group_operations gpio_sim_config_group_ops = {\n\t.make_group\t= gpio_sim_config_make_device_group,\n};\n\nstatic const struct config_item_type gpio_sim_config_type = {\n\t.ct_group_ops\t= &gpio_sim_config_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct configfs_subsystem gpio_sim_config_subsys = {\n\t.su_group = {\n\t\t.cg_item = {\n\t\t\t.ci_namebuf\t= \"gpio-sim\",\n\t\t\t.ci_type\t= &gpio_sim_config_type,\n\t\t},\n\t},\n};\n\nstatic int __init gpio_sim_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&gpio_sim_driver);\n\tif (ret) {\n\t\tpr_err(\"Error %d while registering the platform driver\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tconfig_group_init(&gpio_sim_config_subsys.su_group);\n\tmutex_init(&gpio_sim_config_subsys.su_mutex);\n\tret = configfs_register_subsystem(&gpio_sim_config_subsys);\n\tif (ret) {\n\t\tpr_err(\"Error %d while registering the configfs subsystem %s\\n\",\n\t\t       ret, gpio_sim_config_subsys.su_group.cg_item.ci_namebuf);\n\t\tmutex_destroy(&gpio_sim_config_subsys.su_mutex);\n\t\tplatform_driver_unregister(&gpio_sim_driver);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(gpio_sim_init);\n\nstatic void __exit gpio_sim_exit(void)\n{\n\tconfigfs_unregister_subsystem(&gpio_sim_config_subsys);\n\tmutex_destroy(&gpio_sim_config_subsys.su_mutex);\n\tplatform_driver_unregister(&gpio_sim_driver);\n}\nmodule_exit(gpio_sim_exit);\n\nMODULE_AUTHOR(\"Bartosz Golaszewski <brgl@bgdev.pl\");\nMODULE_DESCRIPTION(\"GPIO Simulator Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}