{
  "module_name": "gpio-uniphier.c",
  "hash_id": "e147ac66fee3fe3d2bb538912b11d8b9054c50ec7cdfa830368ad0344b11c747",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-uniphier.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bits.h>\n#include <linux/gpio/driver.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <dt-bindings/gpio/uniphier-gpio.h>\n\n#define UNIPHIER_GPIO_IRQ_MAX_NUM\t24\n\n#define UNIPHIER_GPIO_PORT_DATA\t\t0x0\t \n#define UNIPHIER_GPIO_PORT_DIR\t\t0x4\t \n#define UNIPHIER_GPIO_IRQ_EN\t\t0x90\t \n#define UNIPHIER_GPIO_IRQ_MODE\t\t0x94\t \n#define UNIPHIER_GPIO_IRQ_FLT_EN\t0x98\t \n#define UNIPHIER_GPIO_IRQ_FLT_CYC\t0x9c\t \n\nstruct uniphier_gpio_priv {\n\tstruct gpio_chip chip;\n\tstruct irq_chip irq_chip;\n\tstruct irq_domain *domain;\n\tvoid __iomem *regs;\n\tspinlock_t lock;\n\tu32 saved_vals[];\n};\n\nstatic unsigned int uniphier_gpio_bank_to_reg(unsigned int bank)\n{\n\tunsigned int reg;\n\n\treg = (bank + 1) * 8;\n\n\t \n\tif (reg >= UNIPHIER_GPIO_IRQ_EN)\n\t\treg += 0x10;\n\n\treturn reg;\n}\n\nstatic void uniphier_gpio_get_bank_and_mask(unsigned int offset,\n\t\t\t\t\t    unsigned int *bank, u32 *mask)\n{\n\t*bank = offset / UNIPHIER_GPIO_LINES_PER_BANK;\n\t*mask = BIT(offset % UNIPHIER_GPIO_LINES_PER_BANK);\n}\n\nstatic void uniphier_gpio_reg_update(struct uniphier_gpio_priv *priv,\n\t\t\t\t     unsigned int reg, u32 mask, u32 val)\n{\n\tunsigned long flags;\n\tu32 tmp;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\ttmp = readl(priv->regs + reg);\n\ttmp &= ~mask;\n\ttmp |= mask & val;\n\twritel(tmp, priv->regs + reg);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void uniphier_gpio_bank_write(struct gpio_chip *chip, unsigned int bank,\n\t\t\t\t     unsigned int reg, u32 mask, u32 val)\n{\n\tstruct uniphier_gpio_priv *priv = gpiochip_get_data(chip);\n\n\tif (!mask)\n\t\treturn;\n\n\tuniphier_gpio_reg_update(priv, uniphier_gpio_bank_to_reg(bank) + reg,\n\t\t\t\t mask, val);\n}\n\nstatic void uniphier_gpio_offset_write(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset, unsigned int reg,\n\t\t\t\t       int val)\n{\n\tunsigned int bank;\n\tu32 mask;\n\n\tuniphier_gpio_get_bank_and_mask(offset, &bank, &mask);\n\n\tuniphier_gpio_bank_write(chip, bank, reg, mask, val ? mask : 0);\n}\n\nstatic int uniphier_gpio_offset_read(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset, unsigned int reg)\n{\n\tstruct uniphier_gpio_priv *priv = gpiochip_get_data(chip);\n\tunsigned int bank, reg_offset;\n\tu32 mask;\n\n\tuniphier_gpio_get_bank_and_mask(offset, &bank, &mask);\n\treg_offset = uniphier_gpio_bank_to_reg(bank) + reg;\n\n\treturn !!(readl(priv->regs + reg_offset) & mask);\n}\n\nstatic int uniphier_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset)\n{\n\tif (uniphier_gpio_offset_read(chip, offset, UNIPHIER_GPIO_PORT_DIR))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int uniphier_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t\t unsigned int offset)\n{\n\tuniphier_gpio_offset_write(chip, offset, UNIPHIER_GPIO_PORT_DIR, 1);\n\n\treturn 0;\n}\n\nstatic int uniphier_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t  unsigned int offset, int val)\n{\n\tuniphier_gpio_offset_write(chip, offset, UNIPHIER_GPIO_PORT_DATA, val);\n\tuniphier_gpio_offset_write(chip, offset, UNIPHIER_GPIO_PORT_DIR, 0);\n\n\treturn 0;\n}\n\nstatic int uniphier_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\treturn uniphier_gpio_offset_read(chip, offset, UNIPHIER_GPIO_PORT_DATA);\n}\n\nstatic void uniphier_gpio_set(struct gpio_chip *chip,\n\t\t\t      unsigned int offset, int val)\n{\n\tuniphier_gpio_offset_write(chip, offset, UNIPHIER_GPIO_PORT_DATA, val);\n}\n\nstatic void uniphier_gpio_set_multiple(struct gpio_chip *chip,\n\t\t\t\t       unsigned long *mask, unsigned long *bits)\n{\n\tunsigned long i, bank, bank_mask, bank_bits;\n\n\tfor_each_set_clump8(i, bank_mask, mask, chip->ngpio) {\n\t\tbank = i / UNIPHIER_GPIO_LINES_PER_BANK;\n\t\tbank_bits = bitmap_get_value8(bits, i);\n\n\t\tuniphier_gpio_bank_write(chip, bank, UNIPHIER_GPIO_PORT_DATA,\n\t\t\t\t\t bank_mask, bank_bits);\n\t}\n}\n\nstatic int uniphier_gpio_to_irq(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct irq_fwspec fwspec;\n\n\tif (offset < UNIPHIER_GPIO_IRQ_OFFSET)\n\t\treturn -ENXIO;\n\n\tfwspec.fwnode = of_node_to_fwnode(chip->parent->of_node);\n\tfwspec.param_count = 2;\n\tfwspec.param[0] = offset - UNIPHIER_GPIO_IRQ_OFFSET;\n\t \n\tfwspec.param[1] = IRQ_TYPE_LEVEL_HIGH;\n\n\treturn irq_create_fwspec_mapping(&fwspec);\n}\n\nstatic void uniphier_gpio_irq_mask(struct irq_data *data)\n{\n\tstruct uniphier_gpio_priv *priv = irq_data_get_irq_chip_data(data);\n\tu32 mask = BIT(irqd_to_hwirq(data));\n\n\tuniphier_gpio_reg_update(priv, UNIPHIER_GPIO_IRQ_EN, mask, 0);\n\n\tirq_chip_mask_parent(data);\n}\n\nstatic void uniphier_gpio_irq_unmask(struct irq_data *data)\n{\n\tstruct uniphier_gpio_priv *priv = irq_data_get_irq_chip_data(data);\n\tu32 mask = BIT(irqd_to_hwirq(data));\n\n\tuniphier_gpio_reg_update(priv, UNIPHIER_GPIO_IRQ_EN, mask, mask);\n\n\tirq_chip_unmask_parent(data);\n}\n\nstatic int uniphier_gpio_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct uniphier_gpio_priv *priv = irq_data_get_irq_chip_data(data);\n\tu32 mask = BIT(irqd_to_hwirq(data));\n\tu32 val = 0;\n\n\tif (type == IRQ_TYPE_EDGE_BOTH) {\n\t\tval = mask;\n\t\ttype = IRQ_TYPE_EDGE_FALLING;\n\t}\n\n\tuniphier_gpio_reg_update(priv, UNIPHIER_GPIO_IRQ_MODE, mask, val);\n\t \n\tuniphier_gpio_reg_update(priv, UNIPHIER_GPIO_IRQ_FLT_EN, mask, val);\n\n\treturn irq_chip_set_type_parent(data, type);\n}\n\nstatic int uniphier_gpio_irq_get_parent_hwirq(struct uniphier_gpio_priv *priv,\n\t\t\t\t\t      unsigned int hwirq)\n{\n\tstruct device_node *np = priv->chip.parent->of_node;\n\tconst __be32 *range;\n\tu32 base, parent_base, size;\n\tint len;\n\n\trange = of_get_property(np, \"socionext,interrupt-ranges\", &len);\n\tif (!range)\n\t\treturn -EINVAL;\n\n\tlen /= sizeof(*range);\n\n\tfor (; len >= 3; len -= 3) {\n\t\tbase = be32_to_cpu(*range++);\n\t\tparent_base = be32_to_cpu(*range++);\n\t\tsize = be32_to_cpu(*range++);\n\n\t\tif (base <= hwirq && hwirq < base + size)\n\t\t\treturn hwirq - base + parent_base;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int uniphier_gpio_irq_domain_translate(struct irq_domain *domain,\n\t\t\t\t\t      struct irq_fwspec *fwspec,\n\t\t\t\t\t      unsigned long *out_hwirq,\n\t\t\t\t\t      unsigned int *out_type)\n{\n\tif (WARN_ON(fwspec->param_count < 2))\n\t\treturn -EINVAL;\n\n\t*out_hwirq = fwspec->param[0];\n\t*out_type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\n\treturn 0;\n}\n\nstatic int uniphier_gpio_irq_domain_alloc(struct irq_domain *domain,\n\t\t\t\t\t  unsigned int virq,\n\t\t\t\t\t  unsigned int nr_irqs, void *arg)\n{\n\tstruct uniphier_gpio_priv *priv = domain->host_data;\n\tstruct irq_fwspec parent_fwspec;\n\tirq_hw_number_t hwirq;\n\tunsigned int type;\n\tint ret;\n\n\tif (WARN_ON(nr_irqs != 1))\n\t\treturn -EINVAL;\n\n\tret = uniphier_gpio_irq_domain_translate(domain, arg, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uniphier_gpio_irq_get_parent_hwirq(priv, hwirq);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tparent_fwspec.fwnode = domain->parent->fwnode;\n\tparent_fwspec.param_count = 2;\n\tparent_fwspec.param[0] = ret;\n\tparent_fwspec.param[1] = (type == IRQ_TYPE_EDGE_BOTH) ?\n\t\t\t\t\t\tIRQ_TYPE_EDGE_FALLING : type;\n\n\tret = irq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t\t    &priv->irq_chip, priv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn irq_domain_alloc_irqs_parent(domain, virq, 1, &parent_fwspec);\n}\n\nstatic int uniphier_gpio_irq_domain_activate(struct irq_domain *domain,\n\t\t\t\t\t     struct irq_data *data, bool early)\n{\n\tstruct uniphier_gpio_priv *priv = domain->host_data;\n\tstruct gpio_chip *chip = &priv->chip;\n\n\treturn gpiochip_lock_as_irq(chip,\n\t\t\tirqd_to_hwirq(data) + UNIPHIER_GPIO_IRQ_OFFSET);\n}\n\nstatic void uniphier_gpio_irq_domain_deactivate(struct irq_domain *domain,\n\t\t\t\t\t\tstruct irq_data *data)\n{\n\tstruct uniphier_gpio_priv *priv = domain->host_data;\n\tstruct gpio_chip *chip = &priv->chip;\n\n\tgpiochip_unlock_as_irq(chip,\n\t\t\tirqd_to_hwirq(data) + UNIPHIER_GPIO_IRQ_OFFSET);\n}\n\nstatic const struct irq_domain_ops uniphier_gpio_irq_domain_ops = {\n\t.alloc = uniphier_gpio_irq_domain_alloc,\n\t.free = irq_domain_free_irqs_common,\n\t.activate = uniphier_gpio_irq_domain_activate,\n\t.deactivate = uniphier_gpio_irq_domain_deactivate,\n\t.translate = uniphier_gpio_irq_domain_translate,\n};\n\nstatic void uniphier_gpio_hw_init(struct uniphier_gpio_priv *priv)\n{\n\t \n\twritel(0xff, priv->regs + UNIPHIER_GPIO_IRQ_FLT_CYC);\n}\n\nstatic unsigned int uniphier_gpio_get_nbanks(unsigned int ngpio)\n{\n\treturn DIV_ROUND_UP(ngpio, UNIPHIER_GPIO_LINES_PER_BANK);\n}\n\nstatic int uniphier_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *parent_np;\n\tstruct irq_domain *parent_domain;\n\tstruct uniphier_gpio_priv *priv;\n\tstruct gpio_chip *chip;\n\tstruct irq_chip *irq_chip;\n\tunsigned int nregs;\n\tu32 ngpios;\n\tint ret;\n\n\tparent_np = of_irq_find_parent(dev->of_node);\n\tif (!parent_np)\n\t\treturn -ENXIO;\n\n\tparent_domain = irq_find_host(parent_np);\n\tof_node_put(parent_np);\n\tif (!parent_domain)\n\t\treturn -EPROBE_DEFER;\n\n\tret = of_property_read_u32(dev->of_node, \"ngpios\", &ngpios);\n\tif (ret)\n\t\treturn ret;\n\n\tnregs = uniphier_gpio_get_nbanks(ngpios) * 2 + 3;\n\tpriv = devm_kzalloc(dev, struct_size(priv, saved_vals, nregs),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->regs))\n\t\treturn PTR_ERR(priv->regs);\n\n\tspin_lock_init(&priv->lock);\n\n\tchip = &priv->chip;\n\tchip->label = dev_name(dev);\n\tchip->parent = dev;\n\tchip->request = gpiochip_generic_request;\n\tchip->free = gpiochip_generic_free;\n\tchip->get_direction = uniphier_gpio_get_direction;\n\tchip->direction_input = uniphier_gpio_direction_input;\n\tchip->direction_output = uniphier_gpio_direction_output;\n\tchip->get = uniphier_gpio_get;\n\tchip->set = uniphier_gpio_set;\n\tchip->set_multiple = uniphier_gpio_set_multiple;\n\tchip->to_irq = uniphier_gpio_to_irq;\n\tchip->base = -1;\n\tchip->ngpio = ngpios;\n\n\tirq_chip = &priv->irq_chip;\n\tirq_chip->name = dev_name(dev);\n\tirq_chip->irq_mask = uniphier_gpio_irq_mask;\n\tirq_chip->irq_unmask = uniphier_gpio_irq_unmask;\n\tirq_chip->irq_eoi = irq_chip_eoi_parent;\n\tirq_chip->irq_set_affinity = irq_chip_set_affinity_parent;\n\tirq_chip->irq_set_type = uniphier_gpio_irq_set_type;\n\n\tuniphier_gpio_hw_init(priv);\n\n\tret = devm_gpiochip_add_data(dev, chip, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->domain = irq_domain_create_hierarchy(\n\t\t\t\t\tparent_domain, 0,\n\t\t\t\t\tUNIPHIER_GPIO_IRQ_MAX_NUM,\n\t\t\t\t\tof_node_to_fwnode(dev->of_node),\n\t\t\t\t\t&uniphier_gpio_irq_domain_ops, priv);\n\tif (!priv->domain)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn 0;\n}\n\nstatic int uniphier_gpio_remove(struct platform_device *pdev)\n{\n\tstruct uniphier_gpio_priv *priv = platform_get_drvdata(pdev);\n\n\tirq_domain_remove(priv->domain);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused uniphier_gpio_suspend(struct device *dev)\n{\n\tstruct uniphier_gpio_priv *priv = dev_get_drvdata(dev);\n\tunsigned int nbanks = uniphier_gpio_get_nbanks(priv->chip.ngpio);\n\tu32 *val = priv->saved_vals;\n\tunsigned int reg;\n\tint i;\n\n\tfor (i = 0; i < nbanks; i++) {\n\t\treg = uniphier_gpio_bank_to_reg(i);\n\n\t\t*val++ = readl(priv->regs + reg + UNIPHIER_GPIO_PORT_DATA);\n\t\t*val++ = readl(priv->regs + reg + UNIPHIER_GPIO_PORT_DIR);\n\t}\n\n\t*val++ = readl(priv->regs + UNIPHIER_GPIO_IRQ_EN);\n\t*val++ = readl(priv->regs + UNIPHIER_GPIO_IRQ_MODE);\n\t*val++ = readl(priv->regs + UNIPHIER_GPIO_IRQ_FLT_EN);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused uniphier_gpio_resume(struct device *dev)\n{\n\tstruct uniphier_gpio_priv *priv = dev_get_drvdata(dev);\n\tunsigned int nbanks = uniphier_gpio_get_nbanks(priv->chip.ngpio);\n\tconst u32 *val = priv->saved_vals;\n\tunsigned int reg;\n\tint i;\n\n\tfor (i = 0; i < nbanks; i++) {\n\t\treg = uniphier_gpio_bank_to_reg(i);\n\n\t\twritel(*val++, priv->regs + reg + UNIPHIER_GPIO_PORT_DATA);\n\t\twritel(*val++, priv->regs + reg + UNIPHIER_GPIO_PORT_DIR);\n\t}\n\n\twritel(*val++, priv->regs + UNIPHIER_GPIO_IRQ_EN);\n\twritel(*val++, priv->regs + UNIPHIER_GPIO_IRQ_MODE);\n\twritel(*val++, priv->regs + UNIPHIER_GPIO_IRQ_FLT_EN);\n\n\tuniphier_gpio_hw_init(priv);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops uniphier_gpio_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(uniphier_gpio_suspend,\n\t\t\t\t     uniphier_gpio_resume)\n};\n\nstatic const struct of_device_id uniphier_gpio_match[] = {\n\t{ .compatible = \"socionext,uniphier-gpio\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_gpio_match);\n\nstatic struct platform_driver uniphier_gpio_driver = {\n\t.probe = uniphier_gpio_probe,\n\t.remove = uniphier_gpio_remove,\n\t.driver = {\n\t\t.name = \"uniphier-gpio\",\n\t\t.of_match_table = uniphier_gpio_match,\n\t\t.pm = &uniphier_gpio_pm_ops,\n\t},\n};\nmodule_platform_driver(uniphier_gpio_driver);\n\nMODULE_AUTHOR(\"Masahiro Yamada <yamada.masahiro@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}