{
  "module_name": "gpio-xilinx.c",
  "hash_id": "07d0e67ddefe4282d65d4ad89c323ec14ecab02e948b38e5e91c1a669b5f7787",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-xilinx.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n \n#define XGPIO_DATA_OFFSET   (0x0)\t \n#define XGPIO_TRI_OFFSET    (0x4)\t \n\n#define XGPIO_CHANNEL0_OFFSET\t0x0\n#define XGPIO_CHANNEL1_OFFSET\t0x8\n\n#define XGPIO_GIER_OFFSET\t0x11c  \n#define XGPIO_GIER_IE\t\tBIT(31)\n#define XGPIO_IPISR_OFFSET\t0x120  \n#define XGPIO_IPIER_OFFSET\t0x128  \n\n \n#if defined(CONFIG_ARCH_ZYNQ) || defined(CONFIG_X86)\n# define xgpio_readreg(offset)\t\treadl(offset)\n# define xgpio_writereg(offset, val)\twritel(val, offset)\n#else\n# define xgpio_readreg(offset)\t\t__raw_readl(offset)\n# define xgpio_writereg(offset, val)\t__raw_writel(val, offset)\n#endif\n\n \nstruct xgpio_instance {\n\tstruct gpio_chip gc;\n\tvoid __iomem *regs;\n\tDECLARE_BITMAP(hw_map, 64);\n\tDECLARE_BITMAP(sw_map, 64);\n\tDECLARE_BITMAP(state, 64);\n\tDECLARE_BITMAP(last_irq_read, 64);\n\tDECLARE_BITMAP(dir, 64);\n\tspinlock_t gpio_lock;\t \n\tint irq;\n\tDECLARE_BITMAP(enable, 64);\n\tDECLARE_BITMAP(rising_edge, 64);\n\tDECLARE_BITMAP(falling_edge, 64);\n\tstruct clk *clk;\n};\n\nstatic inline int xgpio_from_bit(struct xgpio_instance *chip, int bit)\n{\n\treturn bitmap_bitremap(bit, chip->hw_map, chip->sw_map, 64);\n}\n\nstatic inline int xgpio_to_bit(struct xgpio_instance *chip, int gpio)\n{\n\treturn bitmap_bitremap(gpio, chip->sw_map, chip->hw_map, 64);\n}\n\nstatic inline u32 xgpio_get_value32(const unsigned long *map, int bit)\n{\n\tconst size_t index = BIT_WORD(bit);\n\tconst unsigned long offset = (bit % BITS_PER_LONG) & BIT(5);\n\n\treturn (map[index] >> offset) & 0xFFFFFFFFul;\n}\n\nstatic inline void xgpio_set_value32(unsigned long *map, int bit, u32 v)\n{\n\tconst size_t index = BIT_WORD(bit);\n\tconst unsigned long offset = (bit % BITS_PER_LONG) & BIT(5);\n\n\tmap[index] &= ~(0xFFFFFFFFul << offset);\n\tmap[index] |= (unsigned long)v << offset;\n}\n\nstatic inline int xgpio_regoffset(struct xgpio_instance *chip, int ch)\n{\n\tswitch (ch) {\n\tcase 0:\n\t\treturn XGPIO_CHANNEL0_OFFSET;\n\tcase 1:\n\t\treturn XGPIO_CHANNEL1_OFFSET;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void xgpio_read_ch(struct xgpio_instance *chip, int reg, int bit, unsigned long *a)\n{\n\tvoid __iomem *addr = chip->regs + reg + xgpio_regoffset(chip, bit / 32);\n\n\txgpio_set_value32(a, bit, xgpio_readreg(addr));\n}\n\nstatic void xgpio_write_ch(struct xgpio_instance *chip, int reg, int bit, unsigned long *a)\n{\n\tvoid __iomem *addr = chip->regs + reg + xgpio_regoffset(chip, bit / 32);\n\n\txgpio_writereg(addr, xgpio_get_value32(a, bit));\n}\n\nstatic void xgpio_read_ch_all(struct xgpio_instance *chip, int reg, unsigned long *a)\n{\n\tint bit, lastbit = xgpio_to_bit(chip, chip->gc.ngpio - 1);\n\n\tfor (bit = 0; bit <= lastbit ; bit += 32)\n\t\txgpio_read_ch(chip, reg, bit, a);\n}\n\nstatic void xgpio_write_ch_all(struct xgpio_instance *chip, int reg, unsigned long *a)\n{\n\tint bit, lastbit = xgpio_to_bit(chip, chip->gc.ngpio - 1);\n\n\tfor (bit = 0; bit <= lastbit ; bit += 32)\n\t\txgpio_write_ch(chip, reg, bit, a);\n}\n\n \nstatic int xgpio_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct xgpio_instance *chip = gpiochip_get_data(gc);\n\tint bit = xgpio_to_bit(chip, gpio);\n\tDECLARE_BITMAP(state, 64);\n\n\txgpio_read_ch(chip, XGPIO_DATA_OFFSET, bit, state);\n\n\treturn test_bit(bit, state);\n}\n\n \nstatic void xgpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\n{\n\tunsigned long flags;\n\tstruct xgpio_instance *chip = gpiochip_get_data(gc);\n\tint bit = xgpio_to_bit(chip, gpio);\n\n\tspin_lock_irqsave(&chip->gpio_lock, flags);\n\n\t \n\t__assign_bit(bit, chip->state, val);\n\n\txgpio_write_ch(chip, XGPIO_DATA_OFFSET, bit, chip->state);\n\n\tspin_unlock_irqrestore(&chip->gpio_lock, flags);\n}\n\n \nstatic void xgpio_set_multiple(struct gpio_chip *gc, unsigned long *mask,\n\t\t\t       unsigned long *bits)\n{\n\tDECLARE_BITMAP(hw_mask, 64);\n\tDECLARE_BITMAP(hw_bits, 64);\n\tDECLARE_BITMAP(state, 64);\n\tunsigned long flags;\n\tstruct xgpio_instance *chip = gpiochip_get_data(gc);\n\n\tbitmap_remap(hw_mask, mask, chip->sw_map, chip->hw_map, 64);\n\tbitmap_remap(hw_bits, bits, chip->sw_map, chip->hw_map, 64);\n\n\tspin_lock_irqsave(&chip->gpio_lock, flags);\n\n\tbitmap_replace(state, chip->state, hw_bits, hw_mask, 64);\n\n\txgpio_write_ch_all(chip, XGPIO_DATA_OFFSET, state);\n\n\tbitmap_copy(chip->state, state, 64);\n\n\tspin_unlock_irqrestore(&chip->gpio_lock, flags);\n}\n\n \nstatic int xgpio_dir_in(struct gpio_chip *gc, unsigned int gpio)\n{\n\tunsigned long flags;\n\tstruct xgpio_instance *chip = gpiochip_get_data(gc);\n\tint bit = xgpio_to_bit(chip, gpio);\n\n\tspin_lock_irqsave(&chip->gpio_lock, flags);\n\n\t \n\t__set_bit(bit, chip->dir);\n\txgpio_write_ch(chip, XGPIO_TRI_OFFSET, bit, chip->dir);\n\n\tspin_unlock_irqrestore(&chip->gpio_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int xgpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\n{\n\tunsigned long flags;\n\tstruct xgpio_instance *chip = gpiochip_get_data(gc);\n\tint bit = xgpio_to_bit(chip, gpio);\n\n\tspin_lock_irqsave(&chip->gpio_lock, flags);\n\n\t \n\t__assign_bit(bit, chip->state, val);\n\txgpio_write_ch(chip, XGPIO_DATA_OFFSET, bit, chip->state);\n\n\t \n\t__clear_bit(bit, chip->dir);\n\txgpio_write_ch(chip, XGPIO_TRI_OFFSET, bit, chip->dir);\n\n\tspin_unlock_irqrestore(&chip->gpio_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void xgpio_save_regs(struct xgpio_instance *chip)\n{\n\txgpio_write_ch_all(chip, XGPIO_DATA_OFFSET, chip->state);\n\txgpio_write_ch_all(chip, XGPIO_TRI_OFFSET, chip->dir);\n}\n\nstatic int xgpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tint ret;\n\n\tret = pm_runtime_get_sync(chip->parent);\n\t \n\treturn ret < 0 ? ret : 0;\n}\n\nstatic void xgpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tpm_runtime_put(chip->parent);\n}\n\nstatic int __maybe_unused xgpio_suspend(struct device *dev)\n{\n\tstruct xgpio_instance *gpio = dev_get_drvdata(dev);\n\tstruct irq_data *data = irq_get_irq_data(gpio->irq);\n\n\tif (!data) {\n\t\tdev_dbg(dev, \"IRQ not connected\\n\");\n\t\treturn pm_runtime_force_suspend(dev);\n\t}\n\n\tif (!irqd_is_wakeup_set(data))\n\t\treturn pm_runtime_force_suspend(dev);\n\n\treturn 0;\n}\n\n \nstatic int xgpio_remove(struct platform_device *pdev)\n{\n\tstruct xgpio_instance *gpio = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tclk_disable_unprepare(gpio->clk);\n\n\treturn 0;\n}\n\n \nstatic void xgpio_irq_ack(struct irq_data *irq_data)\n{\n}\n\nstatic int __maybe_unused xgpio_resume(struct device *dev)\n{\n\tstruct xgpio_instance *gpio = dev_get_drvdata(dev);\n\tstruct irq_data *data = irq_get_irq_data(gpio->irq);\n\n\tif (!data) {\n\t\tdev_dbg(dev, \"IRQ not connected\\n\");\n\t\treturn pm_runtime_force_resume(dev);\n\t}\n\n\tif (!irqd_is_wakeup_set(data))\n\t\treturn pm_runtime_force_resume(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused xgpio_runtime_suspend(struct device *dev)\n{\n\tstruct xgpio_instance *gpio = dev_get_drvdata(dev);\n\n\tclk_disable(gpio->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused xgpio_runtime_resume(struct device *dev)\n{\n\tstruct xgpio_instance *gpio = dev_get_drvdata(dev);\n\n\treturn clk_enable(gpio->clk);\n}\n\nstatic const struct dev_pm_ops xgpio_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(xgpio_suspend, xgpio_resume)\n\tSET_RUNTIME_PM_OPS(xgpio_runtime_suspend,\n\t\t\t   xgpio_runtime_resume, NULL)\n};\n\n \nstatic void xgpio_irq_mask(struct irq_data *irq_data)\n{\n\tunsigned long flags;\n\tstruct xgpio_instance *chip = irq_data_get_irq_chip_data(irq_data);\n\tint irq_offset = irqd_to_hwirq(irq_data);\n\tint bit = xgpio_to_bit(chip, irq_offset);\n\tu32 mask = BIT(bit / 32), temp;\n\n\tspin_lock_irqsave(&chip->gpio_lock, flags);\n\n\t__clear_bit(bit, chip->enable);\n\n\tif (xgpio_get_value32(chip->enable, bit) == 0) {\n\t\t \n\t\ttemp = xgpio_readreg(chip->regs + XGPIO_IPIER_OFFSET);\n\t\ttemp &= ~mask;\n\t\txgpio_writereg(chip->regs + XGPIO_IPIER_OFFSET, temp);\n\t}\n\tspin_unlock_irqrestore(&chip->gpio_lock, flags);\n\n\tgpiochip_disable_irq(&chip->gc, irq_offset);\n}\n\n \nstatic void xgpio_irq_unmask(struct irq_data *irq_data)\n{\n\tunsigned long flags;\n\tstruct xgpio_instance *chip = irq_data_get_irq_chip_data(irq_data);\n\tint irq_offset = irqd_to_hwirq(irq_data);\n\tint bit = xgpio_to_bit(chip, irq_offset);\n\tu32 old_enable = xgpio_get_value32(chip->enable, bit);\n\tu32 mask = BIT(bit / 32), val;\n\n\tgpiochip_enable_irq(&chip->gc, irq_offset);\n\n\tspin_lock_irqsave(&chip->gpio_lock, flags);\n\n\t__set_bit(bit, chip->enable);\n\n\tif (old_enable == 0) {\n\t\t \n\t\tval = xgpio_readreg(chip->regs + XGPIO_IPISR_OFFSET);\n\t\tval &= mask;\n\t\txgpio_writereg(chip->regs + XGPIO_IPISR_OFFSET, val);\n\n\t\t \n\t\txgpio_read_ch(chip, XGPIO_DATA_OFFSET, bit, chip->last_irq_read);\n\n\t\t \n\t\tval = xgpio_readreg(chip->regs + XGPIO_IPIER_OFFSET);\n\t\tval |= mask;\n\t\txgpio_writereg(chip->regs + XGPIO_IPIER_OFFSET, val);\n\t}\n\n\tspin_unlock_irqrestore(&chip->gpio_lock, flags);\n}\n\n \nstatic int xgpio_set_irq_type(struct irq_data *irq_data, unsigned int type)\n{\n\tstruct xgpio_instance *chip = irq_data_get_irq_chip_data(irq_data);\n\tint irq_offset = irqd_to_hwirq(irq_data);\n\tint bit = xgpio_to_bit(chip, irq_offset);\n\n\t \n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t__set_bit(bit, chip->rising_edge);\n\t\t__set_bit(bit, chip->falling_edge);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\t__set_bit(bit, chip->rising_edge);\n\t\t__clear_bit(bit, chip->falling_edge);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\t__clear_bit(bit, chip->rising_edge);\n\t\t__set_bit(bit, chip->falling_edge);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tirq_set_handler_locked(irq_data, handle_edge_irq);\n\treturn 0;\n}\n\n \nstatic void xgpio_irqhandler(struct irq_desc *desc)\n{\n\tstruct xgpio_instance *chip = irq_desc_get_handler_data(desc);\n\tstruct gpio_chip *gc = &chip->gc;\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\tDECLARE_BITMAP(rising, 64);\n\tDECLARE_BITMAP(falling, 64);\n\tDECLARE_BITMAP(all, 64);\n\tint irq_offset;\n\tu32 status;\n\tu32 bit;\n\n\tstatus = xgpio_readreg(chip->regs + XGPIO_IPISR_OFFSET);\n\txgpio_writereg(chip->regs + XGPIO_IPISR_OFFSET, status);\n\n\tchained_irq_enter(irqchip, desc);\n\n\tspin_lock(&chip->gpio_lock);\n\n\txgpio_read_ch_all(chip, XGPIO_DATA_OFFSET, all);\n\n\tbitmap_complement(rising, chip->last_irq_read, 64);\n\tbitmap_and(rising, rising, all, 64);\n\tbitmap_and(rising, rising, chip->enable, 64);\n\tbitmap_and(rising, rising, chip->rising_edge, 64);\n\n\tbitmap_complement(falling, all, 64);\n\tbitmap_and(falling, falling, chip->last_irq_read, 64);\n\tbitmap_and(falling, falling, chip->enable, 64);\n\tbitmap_and(falling, falling, chip->falling_edge, 64);\n\n\tbitmap_copy(chip->last_irq_read, all, 64);\n\tbitmap_or(all, rising, falling, 64);\n\n\tspin_unlock(&chip->gpio_lock);\n\n\tdev_dbg(gc->parent, \"IRQ rising %*pb falling %*pb\\n\", 64, rising, 64, falling);\n\n\tfor_each_set_bit(bit, all, 64) {\n\t\tirq_offset = xgpio_from_bit(chip, bit);\n\t\tgeneric_handle_domain_irq(gc->irq.domain, irq_offset);\n\t}\n\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic const struct irq_chip xgpio_irq_chip = {\n\t.name = \"gpio-xilinx\",\n\t.irq_ack = xgpio_irq_ack,\n\t.irq_mask = xgpio_irq_mask,\n\t.irq_unmask = xgpio_irq_unmask,\n\t.irq_set_type = xgpio_set_irq_type,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\n \nstatic int xgpio_probe(struct platform_device *pdev)\n{\n\tstruct xgpio_instance *chip;\n\tint status = 0;\n\tstruct device_node *np = pdev->dev.of_node;\n\tu32 is_dual = 0;\n\tu32 width[2];\n\tu32 state[2];\n\tu32 dir[2];\n\tstruct gpio_irq_chip *girq;\n\tu32 temp;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, chip);\n\n\t \n\tof_property_read_u32(np, \"xlnx,is-dual\", &is_dual);\n\n\t \n\tmemset32(width, 0, ARRAY_SIZE(width));\n\tmemset32(state, 0, ARRAY_SIZE(state));\n\tmemset32(dir, 0xFFFFFFFF, ARRAY_SIZE(dir));\n\n\t \n\tof_property_read_u32(np, \"xlnx,dout-default\", &state[0]);\n\tof_property_read_u32(np, \"xlnx,dout-default-2\", &state[1]);\n\n\tbitmap_from_arr32(chip->state, state, 64);\n\n\t \n\tof_property_read_u32(np, \"xlnx,tri-default\", &dir[0]);\n\tof_property_read_u32(np, \"xlnx,tri-default-2\", &dir[1]);\n\n\tbitmap_from_arr32(chip->dir, dir, 64);\n\n\t \n\tif (of_property_read_u32(np, \"xlnx,gpio-width\", &width[0]))\n\t\twidth[0] = 32;\n\n\tif (width[0] > 32)\n\t\treturn -EINVAL;\n\n\tif (is_dual && of_property_read_u32(np, \"xlnx,gpio2-width\", &width[1]))\n\t\twidth[1] = 32;\n\n\tif (width[1] > 32)\n\t\treturn -EINVAL;\n\n\t \n\tbitmap_set(chip->sw_map, 0, width[0] + width[1]);\n\n\t \n\tbitmap_set(chip->hw_map,  0, width[0]);\n\tbitmap_set(chip->hw_map, 32, width[1]);\n\n\tspin_lock_init(&chip->gpio_lock);\n\n\tchip->gc.base = -1;\n\tchip->gc.ngpio = bitmap_weight(chip->hw_map, 64);\n\tchip->gc.parent = &pdev->dev;\n\tchip->gc.direction_input = xgpio_dir_in;\n\tchip->gc.direction_output = xgpio_dir_out;\n\tchip->gc.get = xgpio_get;\n\tchip->gc.set = xgpio_set;\n\tchip->gc.request = xgpio_request;\n\tchip->gc.free = xgpio_free;\n\tchip->gc.set_multiple = xgpio_set_multiple;\n\n\tchip->gc.label = dev_name(&pdev->dev);\n\n\tchip->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(chip->regs)) {\n\t\tdev_err(&pdev->dev, \"failed to ioremap memory resource\\n\");\n\t\treturn PTR_ERR(chip->regs);\n\t}\n\n\tchip->clk = devm_clk_get_optional(&pdev->dev, NULL);\n\tif (IS_ERR(chip->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(chip->clk), \"input clock not found.\\n\");\n\n\tstatus = clk_prepare_enable(chip->clk);\n\tif (status < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to prepare clk\\n\");\n\t\treturn status;\n\t}\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\txgpio_save_regs(chip);\n\n\tchip->irq = platform_get_irq_optional(pdev, 0);\n\tif (chip->irq <= 0)\n\t\tgoto skip_irq;\n\n\t \n\txgpio_writereg(chip->regs + XGPIO_IPIER_OFFSET, 0);\n\t \n\ttemp = xgpio_readreg(chip->regs + XGPIO_IPISR_OFFSET);\n\txgpio_writereg(chip->regs + XGPIO_IPISR_OFFSET, temp);\n\t \n\txgpio_writereg(chip->regs + XGPIO_GIER_OFFSET, XGPIO_GIER_IE);\n\n\tgirq = &chip->gc.irq;\n\tgpio_irq_chip_set_chip(girq, &xgpio_irq_chip);\n\tgirq->parent_handler = xgpio_irqhandler;\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(&pdev->dev, 1,\n\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t     GFP_KERNEL);\n\tif (!girq->parents) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_pm_put;\n\t}\n\tgirq->parents[0] = chip->irq;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\nskip_irq:\n\tstatus = devm_gpiochip_add_data(&pdev->dev, &chip->gc, chip);\n\tif (status) {\n\t\tdev_err(&pdev->dev, \"failed to add GPIO chip\\n\");\n\t\tgoto err_pm_put;\n\t}\n\n\tpm_runtime_put(&pdev->dev);\n\treturn 0;\n\nerr_pm_put:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tclk_disable_unprepare(chip->clk);\n\treturn status;\n}\n\nstatic const struct of_device_id xgpio_of_match[] = {\n\t{ .compatible = \"xlnx,xps-gpio-1.00.a\", },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, xgpio_of_match);\n\nstatic struct platform_driver xgpio_plat_driver = {\n\t.probe\t\t= xgpio_probe,\n\t.remove\t\t= xgpio_remove,\n\t.driver\t\t= {\n\t\t\t.name = \"gpio-xilinx\",\n\t\t\t.of_match_table\t= xgpio_of_match,\n\t\t\t.pm = &xgpio_dev_pm_ops,\n\t},\n};\n\nstatic int __init xgpio_init(void)\n{\n\treturn platform_driver_register(&xgpio_plat_driver);\n}\n\nsubsys_initcall(xgpio_init);\n\nstatic void __exit xgpio_exit(void)\n{\n\tplatform_driver_unregister(&xgpio_plat_driver);\n}\nmodule_exit(xgpio_exit);\n\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_DESCRIPTION(\"Xilinx GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}