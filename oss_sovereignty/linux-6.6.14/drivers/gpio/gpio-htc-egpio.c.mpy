{
  "module_name": "gpio-htc-egpio.c",
  "hash_id": "4c6249a87a3801b9f04f2da3026c4ec4116e7e8193bdab73773ad23e1e4dc315",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-htc-egpio.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/spinlock.h>\n#include <linux/platform_data/gpio-htc-egpio.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/gpio/driver.h>\n\nstruct egpio_chip {\n\tint              reg_start;\n\tint              cached_values;\n\tunsigned long    is_out;\n\tstruct device    *dev;\n\tstruct gpio_chip chip;\n};\n\nstruct egpio_info {\n\tspinlock_t        lock;\n\n\t \n\tvoid __iomem      *base_addr;\n\tint               bus_shift;\t \n\tint               reg_shift;\t \n\tint               reg_mask;\n\n\t \n\tint               ack_register;\n\tint               ack_write;\n\tu16               irqs_enabled;\n\tuint              irq_start;\n\tint               nirqs;\n\tuint              chained_irq;\n\n\t \n\tstruct egpio_chip *chip;\n\tint               nchips;\n};\n\nstatic inline void egpio_writew(u16 value, struct egpio_info *ei, int reg)\n{\n\twritew(value, ei->base_addr + (reg << ei->bus_shift));\n}\n\nstatic inline u16 egpio_readw(struct egpio_info *ei, int reg)\n{\n\treturn readw(ei->base_addr + (reg << ei->bus_shift));\n}\n\n \n\nstatic inline void ack_irqs(struct egpio_info *ei)\n{\n\tegpio_writew(ei->ack_write, ei, ei->ack_register);\n\tpr_debug(\"EGPIO ack - write %x to base+%x\\n\",\n\t\t\tei->ack_write, ei->ack_register << ei->bus_shift);\n}\n\nstatic void egpio_ack(struct irq_data *data)\n{\n}\n\n \nstatic void egpio_mask(struct irq_data *data)\n{\n\tstruct egpio_info *ei = irq_data_get_irq_chip_data(data);\n\tei->irqs_enabled &= ~(1 << (data->irq - ei->irq_start));\n\tpr_debug(\"EGPIO mask %d %04x\\n\", data->irq, ei->irqs_enabled);\n}\n\nstatic void egpio_unmask(struct irq_data *data)\n{\n\tstruct egpio_info *ei = irq_data_get_irq_chip_data(data);\n\tei->irqs_enabled |= 1 << (data->irq - ei->irq_start);\n\tpr_debug(\"EGPIO unmask %d %04x\\n\", data->irq, ei->irqs_enabled);\n}\n\nstatic struct irq_chip egpio_muxed_chip = {\n\t.name\t\t= \"htc-egpio\",\n\t.irq_ack\t= egpio_ack,\n\t.irq_mask\t= egpio_mask,\n\t.irq_unmask\t= egpio_unmask,\n};\n\nstatic void egpio_handler(struct irq_desc *desc)\n{\n\tstruct egpio_info *ei = irq_desc_get_handler_data(desc);\n\tint irqpin;\n\n\t \n\tunsigned long readval = egpio_readw(ei, ei->ack_register);\n\tpr_debug(\"IRQ reg: %x\\n\", (unsigned int)readval);\n\t \n\tack_irqs(ei);\n\t \n\treadval &= ei->irqs_enabled;\n\tfor_each_set_bit(irqpin, &readval, ei->nirqs) {\n\t\t \n\t\tpr_debug(\"got IRQ %d\\n\", irqpin);\n\t\tgeneric_handle_irq(ei->irq_start + irqpin);\n\t}\n}\n\nstatic inline int egpio_pos(struct egpio_info *ei, int bit)\n{\n\treturn bit >> ei->reg_shift;\n}\n\nstatic inline int egpio_bit(struct egpio_info *ei, int bit)\n{\n\treturn 1 << (bit & ((1 << ei->reg_shift)-1));\n}\n\n \n\nstatic int egpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct egpio_chip *egpio;\n\tstruct egpio_info *ei;\n\tunsigned           bit;\n\tint                reg;\n\tint                value;\n\n\tpr_debug(\"egpio_get_value(%d)\\n\", chip->base + offset);\n\n\tegpio = gpiochip_get_data(chip);\n\tei    = dev_get_drvdata(egpio->dev);\n\tbit   = egpio_bit(ei, offset);\n\treg   = egpio->reg_start + egpio_pos(ei, offset);\n\n\tif (test_bit(offset, &egpio->is_out)) {\n\t\treturn !!(egpio->cached_values & (1 << offset));\n\t} else {\n\t\tvalue = egpio_readw(ei, reg);\n\t\tpr_debug(\"readw(%p + %x) = %x\\n\",\n\t\t\t ei->base_addr, reg << ei->bus_shift, value);\n\t\treturn !!(value & bit);\n\t}\n}\n\nstatic int egpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct egpio_chip *egpio;\n\n\tegpio = gpiochip_get_data(chip);\n\treturn test_bit(offset, &egpio->is_out) ? -EINVAL : 0;\n}\n\n\n \n\nstatic void egpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tunsigned long     flag;\n\tstruct egpio_chip *egpio;\n\tstruct egpio_info *ei;\n\tint               pos;\n\tint               reg;\n\tint               shift;\n\n\tpr_debug(\"egpio_set(%s, %d(%d), %d)\\n\",\n\t\t\tchip->label, offset, offset+chip->base, value);\n\n\tegpio = gpiochip_get_data(chip);\n\tei    = dev_get_drvdata(egpio->dev);\n\tpos   = egpio_pos(ei, offset);\n\treg   = egpio->reg_start + pos;\n\tshift = pos << ei->reg_shift;\n\n\tpr_debug(\"egpio %s: reg %d = 0x%04x\\n\", value ? \"set\" : \"clear\",\n\t\t\treg, (egpio->cached_values >> shift) & ei->reg_mask);\n\n\tspin_lock_irqsave(&ei->lock, flag);\n\tif (value)\n\t\tegpio->cached_values |= (1 << offset);\n\telse\n\t\tegpio->cached_values &= ~(1 << offset);\n\tegpio_writew((egpio->cached_values >> shift) & ei->reg_mask, ei, reg);\n\tspin_unlock_irqrestore(&ei->lock, flag);\n}\n\nstatic int egpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct egpio_chip *egpio;\n\n\tegpio = gpiochip_get_data(chip);\n\tif (test_bit(offset, &egpio->is_out)) {\n\t\tegpio_set(chip, offset, value);\n\t\treturn 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int egpio_get_direction(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct egpio_chip *egpio;\n\n\tegpio = gpiochip_get_data(chip);\n\n\tif (test_bit(offset, &egpio->is_out))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic void egpio_write_cache(struct egpio_info *ei)\n{\n\tint               i;\n\tstruct egpio_chip *egpio;\n\tint               shift;\n\n\tfor (i = 0; i < ei->nchips; i++) {\n\t\tegpio = &(ei->chip[i]);\n\t\tif (!egpio->is_out)\n\t\t\tcontinue;\n\n\t\tfor (shift = 0; shift < egpio->chip.ngpio;\n\t\t\t\tshift += (1<<ei->reg_shift)) {\n\n\t\t\tint reg = egpio->reg_start + egpio_pos(ei, shift);\n\n\t\t\tif (!((egpio->is_out >> shift) & ei->reg_mask))\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"EGPIO: setting %x to %x, was %x\\n\", reg,\n\t\t\t\t(egpio->cached_values >> shift) & ei->reg_mask,\n\t\t\t\tegpio_readw(ei, reg));\n\n\t\t\tegpio_writew((egpio->cached_values >> shift)\n\t\t\t\t\t& ei->reg_mask, ei, reg);\n\t\t}\n\t}\n}\n\n\n \n\nstatic int __init egpio_probe(struct platform_device *pdev)\n{\n\tstruct htc_egpio_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct resource   *res;\n\tstruct egpio_info *ei;\n\tstruct gpio_chip  *chip;\n\tunsigned int      irq, irq_end;\n\tint               i;\n\n\t \n\tei = devm_kzalloc(&pdev->dev, sizeof(*ei), GFP_KERNEL);\n\tif (!ei)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ei->lock);\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (res)\n\t\tei->chained_irq = res->start;\n\n\t \n\tei->base_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ei->base_addr))\n\t\treturn PTR_ERR(ei->base_addr);\n\n\tif ((pdata->bus_width != 16) && (pdata->bus_width != 32))\n\t\treturn -EINVAL;\n\n\tei->bus_shift = fls(pdata->bus_width - 1) - 3;\n\tpr_debug(\"bus_shift = %d\\n\", ei->bus_shift);\n\n\tif ((pdata->reg_width != 8) && (pdata->reg_width != 16))\n\t\treturn -EINVAL;\n\n\tei->reg_shift = fls(pdata->reg_width - 1);\n\tpr_debug(\"reg_shift = %d\\n\", ei->reg_shift);\n\n\tei->reg_mask = (1 << pdata->reg_width) - 1;\n\n\tplatform_set_drvdata(pdev, ei);\n\n\tei->nchips = pdata->num_chips;\n\tei->chip = devm_kcalloc(&pdev->dev,\n\t\t\t\tei->nchips, sizeof(struct egpio_chip),\n\t\t\t\tGFP_KERNEL);\n\tif (!ei->chip)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ei->nchips; i++) {\n\t\tei->chip[i].reg_start = pdata->chip[i].reg_start;\n\t\tei->chip[i].cached_values = pdata->chip[i].initial_values;\n\t\tei->chip[i].is_out = pdata->chip[i].direction;\n\t\tei->chip[i].dev = &(pdev->dev);\n\t\tchip = &(ei->chip[i].chip);\n\t\tchip->label = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t     \"htc-egpio-%d\",\n\t\t\t\t\t     i);\n\t\tif (!chip->label)\n\t\t\treturn -ENOMEM;\n\n\t\tchip->parent          = &pdev->dev;\n\t\tchip->owner           = THIS_MODULE;\n\t\tchip->get             = egpio_get;\n\t\tchip->set             = egpio_set;\n\t\tchip->direction_input = egpio_direction_input;\n\t\tchip->direction_output = egpio_direction_output;\n\t\tchip->get_direction   = egpio_get_direction;\n\t\tchip->base            = pdata->chip[i].gpio_base;\n\t\tchip->ngpio           = pdata->chip[i].num_gpios;\n\n\t\tgpiochip_add_data(chip, &ei->chip[i]);\n\t}\n\n\t \n\tegpio_write_cache(ei);\n\n\tei->irq_start = pdata->irq_base;\n\tei->nirqs = pdata->num_irqs;\n\tei->ack_register = pdata->ack_register;\n\n\tif (ei->chained_irq) {\n\t\t \n\t\tei->ack_write = 0xFFFF;\n\t\tif (pdata->invert_acks)\n\t\t\tei->ack_write = 0;\n\t\tirq_end = ei->irq_start + ei->nirqs;\n\t\tfor (irq = ei->irq_start; irq < irq_end; irq++) {\n\t\t\tirq_set_chip_and_handler(irq, &egpio_muxed_chip,\n\t\t\t\t\t\t handle_simple_irq);\n\t\t\tirq_set_chip_data(irq, ei);\n\t\t\tirq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);\n\t\t}\n\t\tirq_set_irq_type(ei->chained_irq, IRQ_TYPE_EDGE_RISING);\n\t\tirq_set_chained_handler_and_data(ei->chained_irq,\n\t\t\t\t\t\t egpio_handler, ei);\n\t\tack_irqs(ei);\n\n\t\tdevice_init_wakeup(&pdev->dev, 1);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int egpio_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct egpio_info *ei = platform_get_drvdata(pdev);\n\n\tif (ei->chained_irq && device_may_wakeup(&pdev->dev))\n\t\tenable_irq_wake(ei->chained_irq);\n\treturn 0;\n}\n\nstatic int egpio_resume(struct platform_device *pdev)\n{\n\tstruct egpio_info *ei = platform_get_drvdata(pdev);\n\n\tif (ei->chained_irq && device_may_wakeup(&pdev->dev))\n\t\tdisable_irq_wake(ei->chained_irq);\n\n\t \n\tegpio_write_cache(ei);\n\treturn 0;\n}\n#else\n#define egpio_suspend NULL\n#define egpio_resume NULL\n#endif\n\n\nstatic struct platform_driver egpio_driver = {\n\t.driver = {\n\t\t.name = \"htc-egpio\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.suspend      = egpio_suspend,\n\t.resume       = egpio_resume,\n};\n\nstatic int __init egpio_init(void)\n{\n\treturn platform_driver_probe(&egpio_driver, egpio_probe);\n}\n \nsubsys_initcall(egpio_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}