{
  "module_name": "gpiolib-devres.c",
  "hash_id": "d7254b68c963bfd467e81179ad1dcd4438a809dfbd28020bf7acb21115fae486",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpiolib-devres.c",
  "human_readable_source": " \n \n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n\n#include \"gpiolib.h\"\n\nstatic void devm_gpiod_release(struct device *dev, void *res)\n{\n\tstruct gpio_desc **desc = res;\n\n\tgpiod_put(*desc);\n}\n\nstatic int devm_gpiod_match(struct device *dev, void *res, void *data)\n{\n\tstruct gpio_desc **this = res, **gpio = data;\n\n\treturn *this == *gpio;\n}\n\nstatic void devm_gpiod_release_array(struct device *dev, void *res)\n{\n\tstruct gpio_descs **descs = res;\n\n\tgpiod_put_array(*descs);\n}\n\nstatic int devm_gpiod_match_array(struct device *dev, void *res, void *data)\n{\n\tstruct gpio_descs **this = res, **gpios = data;\n\n\treturn *this == *gpios;\n}\n\n \nstruct gpio_desc *__must_check devm_gpiod_get(struct device *dev,\n\t\t\t\t\t      const char *con_id,\n\t\t\t\t\t      enum gpiod_flags flags)\n{\n\treturn devm_gpiod_get_index(dev, con_id, 0, flags);\n}\nEXPORT_SYMBOL_GPL(devm_gpiod_get);\n\n \nstruct gpio_desc *__must_check devm_gpiod_get_optional(struct device *dev,\n\t\t\t\t\t\t       const char *con_id,\n\t\t\t\t\t\t       enum gpiod_flags flags)\n{\n\treturn devm_gpiod_get_index_optional(dev, con_id, 0, flags);\n}\nEXPORT_SYMBOL_GPL(devm_gpiod_get_optional);\n\n \nstruct gpio_desc *__must_check devm_gpiod_get_index(struct device *dev,\n\t\t\t\t\t\t    const char *con_id,\n\t\t\t\t\t\t    unsigned int idx,\n\t\t\t\t\t\t    enum gpiod_flags flags)\n{\n\tstruct gpio_desc **dr;\n\tstruct gpio_desc *desc;\n\n\tdesc = gpiod_get_index(dev, con_id, idx, flags);\n\tif (IS_ERR(desc))\n\t\treturn desc;\n\n\t \n\tif (flags & GPIOD_FLAGS_BIT_NONEXCLUSIVE) {\n\t\tstruct devres *dres;\n\n\t\tdres = devres_find(dev, devm_gpiod_release,\n\t\t\t\t   devm_gpiod_match, &desc);\n\t\tif (dres)\n\t\t\treturn desc;\n\t}\n\n\tdr = devres_alloc(devm_gpiod_release, sizeof(struct gpio_desc *),\n\t\t\t  GFP_KERNEL);\n\tif (!dr) {\n\t\tgpiod_put(desc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t*dr = desc;\n\tdevres_add(dev, dr);\n\n\treturn desc;\n}\nEXPORT_SYMBOL_GPL(devm_gpiod_get_index);\n\n \nstruct gpio_desc *devm_fwnode_gpiod_get_index(struct device *dev,\n\t\t\t\t\t      struct fwnode_handle *fwnode,\n\t\t\t\t\t      const char *con_id, int index,\n\t\t\t\t\t      enum gpiod_flags flags,\n\t\t\t\t\t      const char *label)\n{\n\tstruct gpio_desc **dr;\n\tstruct gpio_desc *desc;\n\n\tdr = devres_alloc(devm_gpiod_release, sizeof(struct gpio_desc *),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc = fwnode_gpiod_get_index(fwnode, con_id, index, flags, label);\n\tif (IS_ERR(desc)) {\n\t\tdevres_free(dr);\n\t\treturn desc;\n\t}\n\n\t*dr = desc;\n\tdevres_add(dev, dr);\n\n\treturn desc;\n}\nEXPORT_SYMBOL_GPL(devm_fwnode_gpiod_get_index);\n\n \nstruct gpio_desc *__must_check devm_gpiod_get_index_optional(struct device *dev,\n\t\t\t\t\t\t\t     const char *con_id,\n\t\t\t\t\t\t\t     unsigned int index,\n\t\t\t\t\t\t\t     enum gpiod_flags flags)\n{\n\tstruct gpio_desc *desc;\n\n\tdesc = devm_gpiod_get_index(dev, con_id, index, flags);\n\tif (gpiod_not_found(desc))\n\t\treturn NULL;\n\n\treturn desc;\n}\nEXPORT_SYMBOL_GPL(devm_gpiod_get_index_optional);\n\n \nstruct gpio_descs *__must_check devm_gpiod_get_array(struct device *dev,\n\t\t\t\t\t\t     const char *con_id,\n\t\t\t\t\t\t     enum gpiod_flags flags)\n{\n\tstruct gpio_descs **dr;\n\tstruct gpio_descs *descs;\n\n\tdr = devres_alloc(devm_gpiod_release_array,\n\t\t\t  sizeof(struct gpio_descs *), GFP_KERNEL);\n\tif (!dr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdescs = gpiod_get_array(dev, con_id, flags);\n\tif (IS_ERR(descs)) {\n\t\tdevres_free(dr);\n\t\treturn descs;\n\t}\n\n\t*dr = descs;\n\tdevres_add(dev, dr);\n\n\treturn descs;\n}\nEXPORT_SYMBOL_GPL(devm_gpiod_get_array);\n\n \nstruct gpio_descs *__must_check\ndevm_gpiod_get_array_optional(struct device *dev, const char *con_id,\n\t\t\t      enum gpiod_flags flags)\n{\n\tstruct gpio_descs *descs;\n\n\tdescs = devm_gpiod_get_array(dev, con_id, flags);\n\tif (gpiod_not_found(descs))\n\t\treturn NULL;\n\n\treturn descs;\n}\nEXPORT_SYMBOL_GPL(devm_gpiod_get_array_optional);\n\n \nvoid devm_gpiod_put(struct device *dev, struct gpio_desc *desc)\n{\n\tWARN_ON(devres_release(dev, devm_gpiod_release, devm_gpiod_match,\n\t\t&desc));\n}\nEXPORT_SYMBOL_GPL(devm_gpiod_put);\n\n \n\nvoid devm_gpiod_unhinge(struct device *dev, struct gpio_desc *desc)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(desc))\n\t\treturn;\n\tret = devres_destroy(dev, devm_gpiod_release,\n\t\t\t     devm_gpiod_match, &desc);\n\t \n\tif (ret == -ENOENT)\n\t\treturn;\n\t \n\tWARN_ON(ret);\n}\nEXPORT_SYMBOL_GPL(devm_gpiod_unhinge);\n\n \nvoid devm_gpiod_put_array(struct device *dev, struct gpio_descs *descs)\n{\n\tWARN_ON(devres_release(dev, devm_gpiod_release_array,\n\t\t\t       devm_gpiod_match_array, &descs));\n}\nEXPORT_SYMBOL_GPL(devm_gpiod_put_array);\n\nstatic void devm_gpio_release(struct device *dev, void *res)\n{\n\tunsigned *gpio = res;\n\n\tgpio_free(*gpio);\n}\n\n \nint devm_gpio_request(struct device *dev, unsigned gpio, const char *label)\n{\n\tunsigned *dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_gpio_release, sizeof(unsigned), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\trc = gpio_request(gpio, label);\n\tif (rc) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\t*dr = gpio;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_gpio_request);\n\n \nint devm_gpio_request_one(struct device *dev, unsigned gpio,\n\t\t\t  unsigned long flags, const char *label)\n{\n\tunsigned *dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_gpio_release, sizeof(unsigned), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\trc = gpio_request_one(gpio, flags, label);\n\tif (rc) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\t*dr = gpio;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_gpio_request_one);\n\nstatic void devm_gpio_chip_release(void *data)\n{\n\tstruct gpio_chip *gc = data;\n\n\tgpiochip_remove(gc);\n}\n\n \nint devm_gpiochip_add_data_with_key(struct device *dev, struct gpio_chip *gc, void *data,\n\t\t\t\t    struct lock_class_key *lock_key,\n\t\t\t\t    struct lock_class_key *request_key)\n{\n\tint ret;\n\n\tret = gpiochip_add_data_with_key(gc, data, lock_key, request_key);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, devm_gpio_chip_release, gc);\n}\nEXPORT_SYMBOL_GPL(devm_gpiochip_add_data_with_key);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}