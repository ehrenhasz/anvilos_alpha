{
  "module_name": "gpio-pca953x.c",
  "hash_id": "4c6ccb98b64a9478e007b88c1f301ccb7a81e3066acf115836e646e0c2115e04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-pca953x.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitmap.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_data/pca953x.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <asm/unaligned.h>\n\n#define PCA953X_INPUT\t\t0x00\n#define PCA953X_OUTPUT\t\t0x01\n#define PCA953X_INVERT\t\t0x02\n#define PCA953X_DIRECTION\t0x03\n\n#define REG_ADDR_MASK\t\tGENMASK(5, 0)\n#define REG_ADDR_EXT\t\tBIT(6)\n#define REG_ADDR_AI\t\tBIT(7)\n\n#define PCA957X_IN\t\t0x00\n#define PCA957X_INVRT\t\t0x01\n#define PCA957X_BKEN\t\t0x02\n#define PCA957X_PUPD\t\t0x03\n#define PCA957X_CFG\t\t0x04\n#define PCA957X_OUT\t\t0x05\n#define PCA957X_MSK\t\t0x06\n#define PCA957X_INTS\t\t0x07\n\n#define PCAL953X_OUT_STRENGTH\t0x20\n#define PCAL953X_IN_LATCH\t0x22\n#define PCAL953X_PULL_EN\t0x23\n#define PCAL953X_PULL_SEL\t0x24\n#define PCAL953X_INT_MASK\t0x25\n#define PCAL953X_INT_STAT\t0x26\n#define PCAL953X_OUT_CONF\t0x27\n\n#define PCAL6524_INT_EDGE\t0x28\n#define PCAL6524_INT_CLR\t0x2a\n#define PCAL6524_IN_STATUS\t0x2b\n#define PCAL6524_OUT_INDCONF\t0x2c\n#define PCAL6524_DEBOUNCE\t0x2d\n\n#define PCA_GPIO_MASK\t\tGENMASK(7, 0)\n\n#define PCAL_GPIO_MASK\t\tGENMASK(4, 0)\n#define PCAL_PINCTRL_MASK\tGENMASK(6, 5)\n\n#define PCA_INT\t\t\tBIT(8)\n#define PCA_PCAL\t\tBIT(9)\n#define PCA_LATCH_INT\t\t(PCA_PCAL | PCA_INT)\n#define PCA953X_TYPE\t\tBIT(12)\n#define PCA957X_TYPE\t\tBIT(13)\n#define PCAL653X_TYPE\t\tBIT(14)\n#define PCA_TYPE_MASK\t\tGENMASK(15, 12)\n\n#define PCA_CHIP_TYPE(x)\t((x) & PCA_TYPE_MASK)\n\nstatic const struct i2c_device_id pca953x_id[] = {\n\t{ \"pca6408\", 8  | PCA953X_TYPE | PCA_INT, },\n\t{ \"pca6416\", 16 | PCA953X_TYPE | PCA_INT, },\n\t{ \"pca9505\", 40 | PCA953X_TYPE | PCA_INT, },\n\t{ \"pca9506\", 40 | PCA953X_TYPE | PCA_INT, },\n\t{ \"pca9534\", 8  | PCA953X_TYPE | PCA_INT, },\n\t{ \"pca9535\", 16 | PCA953X_TYPE | PCA_INT, },\n\t{ \"pca9536\", 4  | PCA953X_TYPE, },\n\t{ \"pca9537\", 4  | PCA953X_TYPE | PCA_INT, },\n\t{ \"pca9538\", 8  | PCA953X_TYPE | PCA_INT, },\n\t{ \"pca9539\", 16 | PCA953X_TYPE | PCA_INT, },\n\t{ \"pca9554\", 8  | PCA953X_TYPE | PCA_INT, },\n\t{ \"pca9555\", 16 | PCA953X_TYPE | PCA_INT, },\n\t{ \"pca9556\", 8  | PCA953X_TYPE, },\n\t{ \"pca9557\", 8  | PCA953X_TYPE, },\n\t{ \"pca9574\", 8  | PCA957X_TYPE | PCA_INT, },\n\t{ \"pca9575\", 16 | PCA957X_TYPE | PCA_INT, },\n\t{ \"pca9698\", 40 | PCA953X_TYPE, },\n\n\t{ \"pcal6408\", 8 | PCA953X_TYPE | PCA_LATCH_INT, },\n\t{ \"pcal6416\", 16 | PCA953X_TYPE | PCA_LATCH_INT, },\n\t{ \"pcal6524\", 24 | PCA953X_TYPE | PCA_LATCH_INT, },\n\t{ \"pcal6534\", 34 | PCAL653X_TYPE | PCA_LATCH_INT, },\n\t{ \"pcal9535\", 16 | PCA953X_TYPE | PCA_LATCH_INT, },\n\t{ \"pcal9554b\", 8  | PCA953X_TYPE | PCA_LATCH_INT, },\n\t{ \"pcal9555a\", 16 | PCA953X_TYPE | PCA_LATCH_INT, },\n\n\t{ \"max7310\", 8  | PCA953X_TYPE, },\n\t{ \"max7312\", 16 | PCA953X_TYPE | PCA_INT, },\n\t{ \"max7313\", 16 | PCA953X_TYPE | PCA_INT, },\n\t{ \"max7315\", 8  | PCA953X_TYPE | PCA_INT, },\n\t{ \"max7318\", 16 | PCA953X_TYPE | PCA_INT, },\n\t{ \"pca6107\", 8  | PCA953X_TYPE | PCA_INT, },\n\t{ \"tca6408\", 8  | PCA953X_TYPE | PCA_INT, },\n\t{ \"tca6416\", 16 | PCA953X_TYPE | PCA_INT, },\n\t{ \"tca6424\", 24 | PCA953X_TYPE | PCA_INT, },\n\t{ \"tca9538\", 8  | PCA953X_TYPE | PCA_INT, },\n\t{ \"tca9539\", 16 | PCA953X_TYPE | PCA_INT, },\n\t{ \"tca9554\", 8  | PCA953X_TYPE | PCA_INT, },\n\t{ \"xra1202\", 8  | PCA953X_TYPE },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pca953x_id);\n\n#ifdef CONFIG_GPIO_PCA953X_IRQ\n\n#include <linux/dmi.h>\n\nstatic const struct acpi_gpio_params pca953x_irq_gpios = { 0, 0, true };\n\nstatic const struct acpi_gpio_mapping pca953x_acpi_irq_gpios[] = {\n\t{ \"irq-gpios\", &pca953x_irq_gpios, 1, ACPI_GPIO_QUIRK_ABSOLUTE_NUMBER },\n\t{ }\n};\n\nstatic int pca953x_acpi_get_irq(struct device *dev)\n{\n\tint ret;\n\n\tret = devm_acpi_dev_add_driver_gpios(dev, pca953x_acpi_irq_gpios);\n\tif (ret)\n\t\tdev_warn(dev, \"can't add GPIO ACPI mapping\\n\");\n\n\tret = acpi_dev_gpio_irq_get_by(ACPI_COMPANION(dev), \"irq-gpios\", 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(dev, \"ACPI interrupt quirk (IRQ %d)\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dmi_system_id pca953x_dmi_acpi_irq_info[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"GalileoGen2\"),\n\t\t},\n\t},\n\t{}\n};\n#endif\n\nstatic const struct acpi_device_id pca953x_acpi_ids[] = {\n\t{ \"INT3491\", 16 | PCA953X_TYPE | PCA_LATCH_INT, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, pca953x_acpi_ids);\n\n#define MAX_BANK 5\n#define BANK_SZ 8\n#define MAX_LINE\t(MAX_BANK * BANK_SZ)\n\n#define NBANK(chip) DIV_ROUND_UP(chip->gpio_chip.ngpio, BANK_SZ)\n\nstruct pca953x_reg_config {\n\tint direction;\n\tint output;\n\tint input;\n\tint invert;\n};\n\nstatic const struct pca953x_reg_config pca953x_regs = {\n\t.direction = PCA953X_DIRECTION,\n\t.output = PCA953X_OUTPUT,\n\t.input = PCA953X_INPUT,\n\t.invert = PCA953X_INVERT,\n};\n\nstatic const struct pca953x_reg_config pca957x_regs = {\n\t.direction = PCA957X_CFG,\n\t.output = PCA957X_OUT,\n\t.input = PCA957X_IN,\n\t.invert = PCA957X_INVRT,\n};\n\nstruct pca953x_chip {\n\tunsigned gpio_start;\n\tstruct mutex i2c_lock;\n\tstruct regmap *regmap;\n\n#ifdef CONFIG_GPIO_PCA953X_IRQ\n\tstruct mutex irq_lock;\n\tDECLARE_BITMAP(irq_mask, MAX_LINE);\n\tDECLARE_BITMAP(irq_stat, MAX_LINE);\n\tDECLARE_BITMAP(irq_trig_raise, MAX_LINE);\n\tDECLARE_BITMAP(irq_trig_fall, MAX_LINE);\n#endif\n\tatomic_t wakeup_path;\n\n\tstruct i2c_client *client;\n\tstruct gpio_chip gpio_chip;\n\tconst char *const *names;\n\tunsigned long driver_data;\n\tstruct regulator *regulator;\n\n\tconst struct pca953x_reg_config *regs;\n\n\tu8 (*recalc_addr)(struct pca953x_chip *chip, int reg, int off);\n\tbool (*check_reg)(struct pca953x_chip *chip, unsigned int reg,\n\t\t\t  u32 checkbank);\n};\n\nstatic int pca953x_bank_shift(struct pca953x_chip *chip)\n{\n\treturn fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);\n}\n\n#define PCA953x_BANK_INPUT\tBIT(0)\n#define PCA953x_BANK_OUTPUT\tBIT(1)\n#define PCA953x_BANK_POLARITY\tBIT(2)\n#define PCA953x_BANK_CONFIG\tBIT(3)\n\n#define PCA957x_BANK_INPUT\tBIT(0)\n#define PCA957x_BANK_POLARITY\tBIT(1)\n#define PCA957x_BANK_BUSHOLD\tBIT(2)\n#define PCA957x_BANK_CONFIG\tBIT(4)\n#define PCA957x_BANK_OUTPUT\tBIT(5)\n\n#define PCAL9xxx_BANK_IN_LATCH\tBIT(8 + 2)\n#define PCAL9xxx_BANK_PULL_EN\tBIT(8 + 3)\n#define PCAL9xxx_BANK_PULL_SEL\tBIT(8 + 4)\n#define PCAL9xxx_BANK_IRQ_MASK\tBIT(8 + 5)\n#define PCAL9xxx_BANK_IRQ_STAT\tBIT(8 + 6)\n\n \n\nstatic bool pca953x_check_register(struct pca953x_chip *chip, unsigned int reg,\n\t\t\t\t   u32 checkbank)\n{\n\tint bank_shift = pca953x_bank_shift(chip);\n\tint bank = (reg & REG_ADDR_MASK) >> bank_shift;\n\tint offset = reg & (BIT(bank_shift) - 1);\n\n\t \n\tif (reg & REG_ADDR_EXT) {\n\t\tif (!(chip->driver_data & PCA_PCAL))\n\t\t\treturn false;\n\t\tbank += 8;\n\t}\n\n\t \n\tif (!(BIT(bank) & checkbank))\n\t\treturn false;\n\n\t \n\tif (offset >= NBANK(chip))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool pcal6534_check_register(struct pca953x_chip *chip, unsigned int reg,\n\t\t\t\t    u32 checkbank)\n{\n\tint bank_shift;\n\tint bank;\n\tint offset;\n\n\tif (reg >= 0x54) {\n\t\t \n\t\treg -= 0x54;\n\t\tbank_shift = 16;\n\t} else if (reg >= 0x30) {\n\t\t \n\t\treg -= 0x30;\n\t\tbank_shift = 8;\n\t} else {\n\t\tbank_shift = 0;\n\t}\n\n\tbank = bank_shift + reg / NBANK(chip);\n\toffset = reg % NBANK(chip);\n\n\t \n\tif (!(BIT(bank) & checkbank))\n\t\treturn false;\n\n\t \n\tif (offset >= NBANK(chip))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool pca953x_readable_register(struct device *dev, unsigned int reg)\n{\n\tstruct pca953x_chip *chip = dev_get_drvdata(dev);\n\tu32 bank;\n\n\tif (PCA_CHIP_TYPE(chip->driver_data) == PCA957X_TYPE) {\n\t\tbank = PCA957x_BANK_INPUT | PCA957x_BANK_OUTPUT |\n\t\t       PCA957x_BANK_POLARITY | PCA957x_BANK_CONFIG |\n\t\t       PCA957x_BANK_BUSHOLD;\n\t} else {\n\t\tbank = PCA953x_BANK_INPUT | PCA953x_BANK_OUTPUT |\n\t\t       PCA953x_BANK_POLARITY | PCA953x_BANK_CONFIG;\n\t}\n\n\tif (chip->driver_data & PCA_PCAL) {\n\t\tbank |= PCAL9xxx_BANK_IN_LATCH | PCAL9xxx_BANK_PULL_EN |\n\t\t\tPCAL9xxx_BANK_PULL_SEL | PCAL9xxx_BANK_IRQ_MASK |\n\t\t\tPCAL9xxx_BANK_IRQ_STAT;\n\t}\n\n\treturn chip->check_reg(chip, reg, bank);\n}\n\nstatic bool pca953x_writeable_register(struct device *dev, unsigned int reg)\n{\n\tstruct pca953x_chip *chip = dev_get_drvdata(dev);\n\tu32 bank;\n\n\tif (PCA_CHIP_TYPE(chip->driver_data) == PCA957X_TYPE) {\n\t\tbank = PCA957x_BANK_OUTPUT | PCA957x_BANK_POLARITY |\n\t\t\tPCA957x_BANK_CONFIG | PCA957x_BANK_BUSHOLD;\n\t} else {\n\t\tbank = PCA953x_BANK_OUTPUT | PCA953x_BANK_POLARITY |\n\t\t\tPCA953x_BANK_CONFIG;\n\t}\n\n\tif (chip->driver_data & PCA_PCAL)\n\t\tbank |= PCAL9xxx_BANK_IN_LATCH | PCAL9xxx_BANK_PULL_EN |\n\t\t\tPCAL9xxx_BANK_PULL_SEL | PCAL9xxx_BANK_IRQ_MASK;\n\n\treturn chip->check_reg(chip, reg, bank);\n}\n\nstatic bool pca953x_volatile_register(struct device *dev, unsigned int reg)\n{\n\tstruct pca953x_chip *chip = dev_get_drvdata(dev);\n\tu32 bank;\n\n\tif (PCA_CHIP_TYPE(chip->driver_data) == PCA957X_TYPE)\n\t\tbank = PCA957x_BANK_INPUT;\n\telse\n\t\tbank = PCA953x_BANK_INPUT;\n\n\tif (chip->driver_data & PCA_PCAL)\n\t\tbank |= PCAL9xxx_BANK_IRQ_STAT;\n\n\treturn chip->check_reg(chip, reg, bank);\n}\n\nstatic const struct regmap_config pca953x_i2c_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.use_single_read = true,\n\t.use_single_write = true,\n\n\t.readable_reg = pca953x_readable_register,\n\t.writeable_reg = pca953x_writeable_register,\n\t.volatile_reg = pca953x_volatile_register,\n\n\t.disable_locking = true,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = 0x7f,\n};\n\nstatic const struct regmap_config pca953x_ai_i2c_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.read_flag_mask = REG_ADDR_AI,\n\t.write_flag_mask = REG_ADDR_AI,\n\n\t.readable_reg = pca953x_readable_register,\n\t.writeable_reg = pca953x_writeable_register,\n\t.volatile_reg = pca953x_volatile_register,\n\n\t.disable_locking = true,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = 0x7f,\n};\n\nstatic u8 pca953x_recalc_addr(struct pca953x_chip *chip, int reg, int off)\n{\n\tint bank_shift = pca953x_bank_shift(chip);\n\tint addr = (reg & PCAL_GPIO_MASK) << bank_shift;\n\tint pinctrl = (reg & PCAL_PINCTRL_MASK) << 1;\n\tu8 regaddr = pinctrl | addr | (off / BANK_SZ);\n\n\treturn regaddr;\n}\n\n \nstatic u8 pcal6534_recalc_addr(struct pca953x_chip *chip, int reg, int off)\n{\n\tint addr;\n\tint pinctrl;\n\n\taddr = (reg & PCAL_GPIO_MASK) * NBANK(chip);\n\n\tswitch (reg) {\n\tcase PCAL953X_OUT_STRENGTH:\n\tcase PCAL953X_IN_LATCH:\n\tcase PCAL953X_PULL_EN:\n\tcase PCAL953X_PULL_SEL:\n\tcase PCAL953X_INT_MASK:\n\tcase PCAL953X_INT_STAT:\n\t\tpinctrl = ((reg & PCAL_PINCTRL_MASK) >> 1) + 0x20;\n\t\tbreak;\n\tcase PCAL6524_INT_EDGE:\n\tcase PCAL6524_INT_CLR:\n\tcase PCAL6524_IN_STATUS:\n\tcase PCAL6524_OUT_INDCONF:\n\tcase PCAL6524_DEBOUNCE:\n\t\tpinctrl = ((reg & PCAL_PINCTRL_MASK) >> 1) + 0x1c;\n\t\tbreak;\n\tdefault:\n\t\tpinctrl = 0;\n\t\tbreak;\n\t}\n\n\treturn pinctrl + addr + (off / BANK_SZ);\n}\n\nstatic int pca953x_write_regs(struct pca953x_chip *chip, int reg, unsigned long *val)\n{\n\tu8 regaddr = chip->recalc_addr(chip, reg, 0);\n\tu8 value[MAX_BANK];\n\tint i, ret;\n\n\tfor (i = 0; i < NBANK(chip); i++)\n\t\tvalue[i] = bitmap_get_value8(val, i * BANK_SZ);\n\n\tret = regmap_bulk_write(chip->regmap, regaddr, value, NBANK(chip));\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev, \"failed writing register\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int pca953x_read_regs(struct pca953x_chip *chip, int reg, unsigned long *val)\n{\n\tu8 regaddr = chip->recalc_addr(chip, reg, 0);\n\tu8 value[MAX_BANK];\n\tint i, ret;\n\n\tret = regmap_bulk_read(chip->regmap, regaddr, value, NBANK(chip));\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev, \"failed reading register\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < NBANK(chip); i++)\n\t\tbitmap_set_value8(val, value[i], i * BANK_SZ);\n\n\treturn 0;\n}\n\nstatic int pca953x_gpio_direction_input(struct gpio_chip *gc, unsigned off)\n{\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tu8 dirreg = chip->recalc_addr(chip, chip->regs->direction, off);\n\tu8 bit = BIT(off % BANK_SZ);\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\tret = regmap_write_bits(chip->regmap, dirreg, bit, bit);\n\tmutex_unlock(&chip->i2c_lock);\n\treturn ret;\n}\n\nstatic int pca953x_gpio_direction_output(struct gpio_chip *gc,\n\t\tunsigned off, int val)\n{\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tu8 dirreg = chip->recalc_addr(chip, chip->regs->direction, off);\n\tu8 outreg = chip->recalc_addr(chip, chip->regs->output, off);\n\tu8 bit = BIT(off % BANK_SZ);\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\t \n\tret = regmap_write_bits(chip->regmap, outreg, bit, val ? bit : 0);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tret = regmap_write_bits(chip->regmap, dirreg, bit, 0);\nexit:\n\tmutex_unlock(&chip->i2c_lock);\n\treturn ret;\n}\n\nstatic int pca953x_gpio_get_value(struct gpio_chip *gc, unsigned off)\n{\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tu8 inreg = chip->recalc_addr(chip, chip->regs->input, off);\n\tu8 bit = BIT(off % BANK_SZ);\n\tu32 reg_val;\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\tret = regmap_read(chip->regmap, inreg, &reg_val);\n\tmutex_unlock(&chip->i2c_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(reg_val & bit);\n}\n\nstatic void pca953x_gpio_set_value(struct gpio_chip *gc, unsigned off, int val)\n{\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tu8 outreg = chip->recalc_addr(chip, chip->regs->output, off);\n\tu8 bit = BIT(off % BANK_SZ);\n\n\tmutex_lock(&chip->i2c_lock);\n\tregmap_write_bits(chip->regmap, outreg, bit, val ? bit : 0);\n\tmutex_unlock(&chip->i2c_lock);\n}\n\nstatic int pca953x_gpio_get_direction(struct gpio_chip *gc, unsigned off)\n{\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tu8 dirreg = chip->recalc_addr(chip, chip->regs->direction, off);\n\tu8 bit = BIT(off % BANK_SZ);\n\tu32 reg_val;\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\tret = regmap_read(chip->regmap, dirreg, &reg_val);\n\tmutex_unlock(&chip->i2c_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (reg_val & bit)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int pca953x_gpio_get_multiple(struct gpio_chip *gc,\n\t\t\t\t     unsigned long *mask, unsigned long *bits)\n{\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tDECLARE_BITMAP(reg_val, MAX_LINE);\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\tret = pca953x_read_regs(chip, chip->regs->input, reg_val);\n\tmutex_unlock(&chip->i2c_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tbitmap_replace(bits, bits, reg_val, mask, gc->ngpio);\n\treturn 0;\n}\n\nstatic void pca953x_gpio_set_multiple(struct gpio_chip *gc,\n\t\t\t\t      unsigned long *mask, unsigned long *bits)\n{\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tDECLARE_BITMAP(reg_val, MAX_LINE);\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\tret = pca953x_read_regs(chip, chip->regs->output, reg_val);\n\tif (ret)\n\t\tgoto exit;\n\n\tbitmap_replace(reg_val, reg_val, bits, mask, gc->ngpio);\n\n\tpca953x_write_regs(chip, chip->regs->output, reg_val);\nexit:\n\tmutex_unlock(&chip->i2c_lock);\n}\n\nstatic int pca953x_gpio_set_pull_up_down(struct pca953x_chip *chip,\n\t\t\t\t\t unsigned int offset,\n\t\t\t\t\t unsigned long config)\n{\n\tenum pin_config_param param = pinconf_to_config_param(config);\n\n\tu8 pull_en_reg = chip->recalc_addr(chip, PCAL953X_PULL_EN, offset);\n\tu8 pull_sel_reg = chip->recalc_addr(chip, PCAL953X_PULL_SEL, offset);\n\tu8 bit = BIT(offset % BANK_SZ);\n\tint ret;\n\n\t \n\tif (!(chip->driver_data & PCA_PCAL))\n\t\treturn -ENOTSUPP;\n\n\tmutex_lock(&chip->i2c_lock);\n\n\t \n\tif (param == PIN_CONFIG_BIAS_PULL_UP)\n\t\tret = regmap_write_bits(chip->regmap, pull_sel_reg, bit, bit);\n\telse if (param == PIN_CONFIG_BIAS_PULL_DOWN)\n\t\tret = regmap_write_bits(chip->regmap, pull_sel_reg, bit, 0);\n\telse\n\t\tret = 0;\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tif (param == PIN_CONFIG_BIAS_DISABLE)\n\t\tret = regmap_write_bits(chip->regmap, pull_en_reg, bit, 0);\n\telse\n\t\tret = regmap_write_bits(chip->regmap, pull_en_reg, bit, bit);\n\nexit:\n\tmutex_unlock(&chip->i2c_lock);\n\treturn ret;\n}\n\nstatic int pca953x_gpio_set_config(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\t   unsigned long config)\n{\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\treturn pca953x_gpio_set_pull_up_down(chip, offset, config);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic void pca953x_setup_gpio(struct pca953x_chip *chip, int gpios)\n{\n\tstruct gpio_chip *gc;\n\n\tgc = &chip->gpio_chip;\n\n\tgc->direction_input  = pca953x_gpio_direction_input;\n\tgc->direction_output = pca953x_gpio_direction_output;\n\tgc->get = pca953x_gpio_get_value;\n\tgc->set = pca953x_gpio_set_value;\n\tgc->get_direction = pca953x_gpio_get_direction;\n\tgc->get_multiple = pca953x_gpio_get_multiple;\n\tgc->set_multiple = pca953x_gpio_set_multiple;\n\tgc->set_config = pca953x_gpio_set_config;\n\tgc->can_sleep = true;\n\n\tgc->base = chip->gpio_start;\n\tgc->ngpio = gpios;\n\tgc->label = dev_name(&chip->client->dev);\n\tgc->parent = &chip->client->dev;\n\tgc->owner = THIS_MODULE;\n\tgc->names = chip->names;\n}\n\n#ifdef CONFIG_GPIO_PCA953X_IRQ\nstatic void pca953x_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tclear_bit(hwirq, chip->irq_mask);\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void pca953x_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tgpiochip_enable_irq(gc, hwirq);\n\tset_bit(hwirq, chip->irq_mask);\n}\n\nstatic int pca953x_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\n\tif (on)\n\t\tatomic_inc(&chip->wakeup_path);\n\telse\n\t\tatomic_dec(&chip->wakeup_path);\n\n\treturn irq_set_irq_wake(chip->client->irq, on);\n}\n\nstatic void pca953x_irq_bus_lock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\n\tmutex_lock(&chip->irq_lock);\n}\n\nstatic void pca953x_irq_bus_sync_unlock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tDECLARE_BITMAP(irq_mask, MAX_LINE);\n\tDECLARE_BITMAP(reg_direction, MAX_LINE);\n\tint level;\n\n\tif (chip->driver_data & PCA_PCAL) {\n\t\t \n\t\tpca953x_write_regs(chip, PCAL953X_IN_LATCH, chip->irq_mask);\n\n\t\tbitmap_complement(irq_mask, chip->irq_mask, gc->ngpio);\n\n\t\t \n\t\tpca953x_write_regs(chip, PCAL953X_INT_MASK, irq_mask);\n\t}\n\n\t \n\tpca953x_read_regs(chip, chip->regs->direction, reg_direction);\n\n\tbitmap_or(irq_mask, chip->irq_trig_fall, chip->irq_trig_raise, gc->ngpio);\n\tbitmap_complement(reg_direction, reg_direction, gc->ngpio);\n\tbitmap_and(irq_mask, irq_mask, reg_direction, gc->ngpio);\n\n\t \n\tfor_each_set_bit(level, irq_mask, gc->ngpio)\n\t\tpca953x_gpio_direction_input(&chip->gpio_chip, level);\n\n\tmutex_unlock(&chip->irq_lock);\n}\n\nstatic int pca953x_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tif (!(type & IRQ_TYPE_EDGE_BOTH)) {\n\t\tdev_err(&chip->client->dev, \"irq %d: unsupported type %d\\n\",\n\t\t\td->irq, type);\n\t\treturn -EINVAL;\n\t}\n\n\tassign_bit(hwirq, chip->irq_trig_fall, type & IRQ_TYPE_EDGE_FALLING);\n\tassign_bit(hwirq, chip->irq_trig_raise, type & IRQ_TYPE_EDGE_RISING);\n\n\treturn 0;\n}\n\nstatic void pca953x_irq_shutdown(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct pca953x_chip *chip = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tclear_bit(hwirq, chip->irq_trig_raise);\n\tclear_bit(hwirq, chip->irq_trig_fall);\n}\n\nstatic void pca953x_irq_print_chip(struct irq_data *data, struct seq_file *p)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\n\tseq_printf(p, dev_name(gc->parent));\n}\n\nstatic const struct irq_chip pca953x_irq_chip = {\n\t.irq_mask\t\t= pca953x_irq_mask,\n\t.irq_unmask\t\t= pca953x_irq_unmask,\n\t.irq_set_wake\t\t= pca953x_irq_set_wake,\n\t.irq_bus_lock\t\t= pca953x_irq_bus_lock,\n\t.irq_bus_sync_unlock\t= pca953x_irq_bus_sync_unlock,\n\t.irq_set_type\t\t= pca953x_irq_set_type,\n\t.irq_shutdown\t\t= pca953x_irq_shutdown,\n\t.irq_print_chip\t\t= pca953x_irq_print_chip,\n\t.flags\t\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic bool pca953x_irq_pending(struct pca953x_chip *chip, unsigned long *pending)\n{\n\tstruct gpio_chip *gc = &chip->gpio_chip;\n\tDECLARE_BITMAP(reg_direction, MAX_LINE);\n\tDECLARE_BITMAP(old_stat, MAX_LINE);\n\tDECLARE_BITMAP(cur_stat, MAX_LINE);\n\tDECLARE_BITMAP(new_stat, MAX_LINE);\n\tDECLARE_BITMAP(trigger, MAX_LINE);\n\tint ret;\n\n\tif (chip->driver_data & PCA_PCAL) {\n\t\t \n\t\tret = pca953x_read_regs(chip, PCAL953X_INT_STAT, trigger);\n\t\tif (ret)\n\t\t\treturn false;\n\n\t\t \n\t\tret = pca953x_read_regs(chip, chip->regs->input, cur_stat);\n\t\tif (ret)\n\t\t\treturn false;\n\n\t\t \n\t\tbitmap_replace(new_stat, chip->irq_trig_fall, chip->irq_trig_raise, cur_stat, gc->ngpio);\n\n\t\tbitmap_and(pending, new_stat, trigger, gc->ngpio);\n\n\t\treturn !bitmap_empty(pending, gc->ngpio);\n\t}\n\n\tret = pca953x_read_regs(chip, chip->regs->input, cur_stat);\n\tif (ret)\n\t\treturn false;\n\n\t \n\tpca953x_read_regs(chip, chip->regs->direction, reg_direction);\n\n\tbitmap_copy(old_stat, chip->irq_stat, gc->ngpio);\n\n\tbitmap_and(new_stat, cur_stat, reg_direction, gc->ngpio);\n\tbitmap_xor(cur_stat, new_stat, old_stat, gc->ngpio);\n\tbitmap_and(trigger, cur_stat, chip->irq_mask, gc->ngpio);\n\n\tbitmap_copy(chip->irq_stat, new_stat, gc->ngpio);\n\n\tif (bitmap_empty(trigger, gc->ngpio))\n\t\treturn false;\n\n\tbitmap_and(cur_stat, chip->irq_trig_fall, old_stat, gc->ngpio);\n\tbitmap_and(old_stat, chip->irq_trig_raise, new_stat, gc->ngpio);\n\tbitmap_or(new_stat, old_stat, cur_stat, gc->ngpio);\n\tbitmap_and(pending, new_stat, trigger, gc->ngpio);\n\n\treturn !bitmap_empty(pending, gc->ngpio);\n}\n\nstatic irqreturn_t pca953x_irq_handler(int irq, void *devid)\n{\n\tstruct pca953x_chip *chip = devid;\n\tstruct gpio_chip *gc = &chip->gpio_chip;\n\tDECLARE_BITMAP(pending, MAX_LINE);\n\tint level;\n\tbool ret;\n\n\tbitmap_zero(pending, MAX_LINE);\n\n\tmutex_lock(&chip->i2c_lock);\n\tret = pca953x_irq_pending(chip, pending);\n\tmutex_unlock(&chip->i2c_lock);\n\n\tif (ret) {\n\t\tret = 0;\n\n\t\tfor_each_set_bit(level, pending, gc->ngpio) {\n\t\t\tint nested_irq = irq_find_mapping(gc->irq.domain, level);\n\n\t\t\tif (unlikely(nested_irq <= 0)) {\n\t\t\t\tdev_warn_ratelimited(gc->parent, \"unmapped interrupt %d\\n\", level);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thandle_nested_irq(nested_irq);\n\t\t\tret = 1;\n\t\t}\n\t}\n\n\treturn IRQ_RETVAL(ret);\n}\n\nstatic int pca953x_irq_setup(struct pca953x_chip *chip, int irq_base)\n{\n\tstruct i2c_client *client = chip->client;\n\tDECLARE_BITMAP(reg_direction, MAX_LINE);\n\tDECLARE_BITMAP(irq_stat, MAX_LINE);\n\tstruct gpio_irq_chip *girq;\n\tint ret;\n\n\tif (dmi_first_match(pca953x_dmi_acpi_irq_info)) {\n\t\tret = pca953x_acpi_get_irq(&client->dev);\n\t\tif (ret > 0)\n\t\t\tclient->irq = ret;\n\t}\n\n\tif (!client->irq)\n\t\treturn 0;\n\n\tif (irq_base == -1)\n\t\treturn 0;\n\n\tif (!(chip->driver_data & PCA_INT))\n\t\treturn 0;\n\n\tret = pca953x_read_regs(chip, chip->regs->input, irq_stat);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpca953x_read_regs(chip, chip->regs->direction, reg_direction);\n\tbitmap_and(chip->irq_stat, irq_stat, reg_direction, chip->gpio_chip.ngpio);\n\tmutex_init(&chip->irq_lock);\n\n\tgirq = &chip->gpio_chip.irq;\n\tgpio_irq_chip_set_chip(girq, &pca953x_irq_chip);\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_simple_irq;\n\tgirq->threaded = true;\n\tgirq->first = irq_base;  \n\n\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, pca953x_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED,\n\t\t\t\t\tdev_name(&client->dev), chip);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to request irq %d\\n\",\n\t\t\tclient->irq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#else  \nstatic int pca953x_irq_setup(struct pca953x_chip *chip,\n\t\t\t     int irq_base)\n{\n\tstruct i2c_client *client = chip->client;\n\n\tif (client->irq && irq_base != -1 && (chip->driver_data & PCA_INT))\n\t\tdev_warn(&client->dev, \"interrupt support not compiled in\\n\");\n\n\treturn 0;\n}\n#endif\n\nstatic int device_pca95xx_init(struct pca953x_chip *chip, u32 invert)\n{\n\tDECLARE_BITMAP(val, MAX_LINE);\n\tu8 regaddr;\n\tint ret;\n\n\tregaddr = chip->recalc_addr(chip, chip->regs->output, 0);\n\tret = regcache_sync_region(chip->regmap, regaddr,\n\t\t\t\t   regaddr + NBANK(chip) - 1);\n\tif (ret)\n\t\tgoto out;\n\n\tregaddr = chip->recalc_addr(chip, chip->regs->direction, 0);\n\tret = regcache_sync_region(chip->regmap, regaddr,\n\t\t\t\t   regaddr + NBANK(chip) - 1);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (invert)\n\t\tbitmap_fill(val, MAX_LINE);\n\telse\n\t\tbitmap_zero(val, MAX_LINE);\n\n\tret = pca953x_write_regs(chip, chip->regs->invert, val);\nout:\n\treturn ret;\n}\n\nstatic int device_pca957x_init(struct pca953x_chip *chip, u32 invert)\n{\n\tDECLARE_BITMAP(val, MAX_LINE);\n\tunsigned int i;\n\tint ret;\n\n\tret = device_pca95xx_init(chip, invert);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < NBANK(chip); i++)\n\t\tbitmap_set_value8(val, 0x02, i * BANK_SZ);\n\n\tret = pca953x_write_regs(chip, PCA957X_BKEN, val);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\treturn ret;\n}\n\nstatic int pca953x_probe(struct i2c_client *client)\n{\n\tstruct pca953x_platform_data *pdata;\n\tstruct pca953x_chip *chip;\n\tint irq_base = 0;\n\tint ret;\n\tu32 invert = 0;\n\tstruct regulator *reg;\n\tconst struct regmap_config *regmap_config;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\n\tpdata = dev_get_platdata(&client->dev);\n\tif (pdata) {\n\t\tirq_base = pdata->irq_base;\n\t\tchip->gpio_start = pdata->gpio_base;\n\t\tinvert = pdata->invert;\n\t\tchip->names = pdata->names;\n\t} else {\n\t\tstruct gpio_desc *reset_gpio;\n\n\t\tchip->gpio_start = -1;\n\t\tirq_base = 0;\n\n\t\t \n\t\treset_gpio = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\t\tif (IS_ERR(reset_gpio))\n\t\t\treturn PTR_ERR(reset_gpio);\n\t}\n\n\tchip->client = client;\n\tchip->driver_data = (uintptr_t)i2c_get_match_data(client);\n\tif (!chip->driver_data)\n\t\treturn -ENODEV;\n\n\treg = devm_regulator_get(&client->dev, \"vcc\");\n\tif (IS_ERR(reg))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(reg), \"reg get err\\n\");\n\n\tret = regulator_enable(reg);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"reg en err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tchip->regulator = reg;\n\n\ti2c_set_clientdata(client, chip);\n\n\tpca953x_setup_gpio(chip, chip->driver_data & PCA_GPIO_MASK);\n\n\tif (NBANK(chip) > 2 || PCA_CHIP_TYPE(chip->driver_data) == PCA957X_TYPE) {\n\t\tdev_info(&client->dev, \"using AI\\n\");\n\t\tregmap_config = &pca953x_ai_i2c_regmap;\n\t} else {\n\t\tdev_info(&client->dev, \"using no AI\\n\");\n\t\tregmap_config = &pca953x_i2c_regmap;\n\t}\n\n\tif (PCA_CHIP_TYPE(chip->driver_data) == PCAL653X_TYPE) {\n\t\tchip->recalc_addr = pcal6534_recalc_addr;\n\t\tchip->check_reg = pcal6534_check_register;\n\t} else {\n\t\tchip->recalc_addr = pca953x_recalc_addr;\n\t\tchip->check_reg = pca953x_check_register;\n\t}\n\n\tchip->regmap = devm_regmap_init_i2c(client, regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\tret = PTR_ERR(chip->regmap);\n\t\tgoto err_exit;\n\t}\n\n\tregcache_mark_dirty(chip->regmap);\n\n\tmutex_init(&chip->i2c_lock);\n\t \n\tlockdep_set_subclass(&chip->i2c_lock,\n\t\t\t     i2c_adapter_depth(client->adapter));\n\n\t \n\tif (PCA_CHIP_TYPE(chip->driver_data) == PCA957X_TYPE) {\n\t\tchip->regs = &pca957x_regs;\n\t\tret = device_pca957x_init(chip, invert);\n\t} else {\n\t\tchip->regs = &pca953x_regs;\n\t\tret = device_pca95xx_init(chip, invert);\n\t}\n\tif (ret)\n\t\tgoto err_exit;\n\n\tret = pca953x_irq_setup(chip, irq_base);\n\tif (ret)\n\t\tgoto err_exit;\n\n\tret = devm_gpiochip_add_data(&client->dev, &chip->gpio_chip, chip);\n\tif (ret)\n\t\tgoto err_exit;\n\n\tif (pdata && pdata->setup) {\n\t\tret = pdata->setup(client, chip->gpio_chip.base,\n\t\t\t\t   chip->gpio_chip.ngpio, pdata->context);\n\t\tif (ret < 0)\n\t\t\tdev_warn(&client->dev, \"setup failed, %d\\n\", ret);\n\t}\n\n\treturn 0;\n\nerr_exit:\n\tregulator_disable(chip->regulator);\n\treturn ret;\n}\n\nstatic void pca953x_remove(struct i2c_client *client)\n{\n\tstruct pca953x_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct pca953x_chip *chip = i2c_get_clientdata(client);\n\n\tif (pdata && pdata->teardown) {\n\t\tpdata->teardown(client, chip->gpio_chip.base,\n\t\t\t\tchip->gpio_chip.ngpio, pdata->context);\n\t}\n\n\tregulator_disable(chip->regulator);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pca953x_regcache_sync(struct device *dev)\n{\n\tstruct pca953x_chip *chip = dev_get_drvdata(dev);\n\tint ret;\n\tu8 regaddr;\n\n\t \n\tregaddr = chip->recalc_addr(chip, chip->regs->direction, 0);\n\tret = regcache_sync_region(chip->regmap, regaddr, regaddr + NBANK(chip) - 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to sync GPIO dir registers: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregaddr = chip->recalc_addr(chip, chip->regs->output, 0);\n\tret = regcache_sync_region(chip->regmap, regaddr, regaddr + NBANK(chip) - 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to sync GPIO out registers: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n#ifdef CONFIG_GPIO_PCA953X_IRQ\n\tif (chip->driver_data & PCA_PCAL) {\n\t\tregaddr = chip->recalc_addr(chip, PCAL953X_IN_LATCH, 0);\n\t\tret = regcache_sync_region(chip->regmap, regaddr,\n\t\t\t\t\t   regaddr + NBANK(chip) - 1);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to sync INT latch registers: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tregaddr = chip->recalc_addr(chip, PCAL953X_INT_MASK, 0);\n\t\tret = regcache_sync_region(chip->regmap, regaddr,\n\t\t\t\t\t   regaddr + NBANK(chip) - 1);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to sync INT mask registers: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic int pca953x_suspend(struct device *dev)\n{\n\tstruct pca953x_chip *chip = dev_get_drvdata(dev);\n\n\tmutex_lock(&chip->i2c_lock);\n\tregcache_cache_only(chip->regmap, true);\n\tmutex_unlock(&chip->i2c_lock);\n\n\tif (atomic_read(&chip->wakeup_path))\n\t\tdevice_set_wakeup_path(dev);\n\telse\n\t\tregulator_disable(chip->regulator);\n\n\treturn 0;\n}\n\nstatic int pca953x_resume(struct device *dev)\n{\n\tstruct pca953x_chip *chip = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!atomic_read(&chip->wakeup_path)) {\n\t\tret = regulator_enable(chip->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable regulator: %d\\n\", ret);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmutex_lock(&chip->i2c_lock);\n\tregcache_cache_only(chip->regmap, false);\n\tregcache_mark_dirty(chip->regmap);\n\tret = pca953x_regcache_sync(dev);\n\tif (ret) {\n\t\tmutex_unlock(&chip->i2c_lock);\n\t\treturn ret;\n\t}\n\n\tret = regcache_sync(chip->regmap);\n\tmutex_unlock(&chip->i2c_lock);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to restore register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\n \n#define OF_653X(__nrgpio, __int) ((void *)(__nrgpio | PCAL653X_TYPE | __int))\n#define OF_953X(__nrgpio, __int) (void *)(__nrgpio | PCA953X_TYPE | __int)\n#define OF_957X(__nrgpio, __int) (void *)(__nrgpio | PCA957X_TYPE | __int)\n\nstatic const struct of_device_id pca953x_dt_ids[] = {\n\t{ .compatible = \"nxp,pca6408\", .data = OF_953X(8, PCA_INT), },\n\t{ .compatible = \"nxp,pca6416\", .data = OF_953X(16, PCA_INT), },\n\t{ .compatible = \"nxp,pca9505\", .data = OF_953X(40, PCA_INT), },\n\t{ .compatible = \"nxp,pca9506\", .data = OF_953X(40, PCA_INT), },\n\t{ .compatible = \"nxp,pca9534\", .data = OF_953X( 8, PCA_INT), },\n\t{ .compatible = \"nxp,pca9535\", .data = OF_953X(16, PCA_INT), },\n\t{ .compatible = \"nxp,pca9536\", .data = OF_953X( 4, 0), },\n\t{ .compatible = \"nxp,pca9537\", .data = OF_953X( 4, PCA_INT), },\n\t{ .compatible = \"nxp,pca9538\", .data = OF_953X( 8, PCA_INT), },\n\t{ .compatible = \"nxp,pca9539\", .data = OF_953X(16, PCA_INT), },\n\t{ .compatible = \"nxp,pca9554\", .data = OF_953X( 8, PCA_INT), },\n\t{ .compatible = \"nxp,pca9555\", .data = OF_953X(16, PCA_INT), },\n\t{ .compatible = \"nxp,pca9556\", .data = OF_953X( 8, 0), },\n\t{ .compatible = \"nxp,pca9557\", .data = OF_953X( 8, 0), },\n\t{ .compatible = \"nxp,pca9574\", .data = OF_957X( 8, PCA_INT), },\n\t{ .compatible = \"nxp,pca9575\", .data = OF_957X(16, PCA_INT), },\n\t{ .compatible = \"nxp,pca9698\", .data = OF_953X(40, 0), },\n\n\t{ .compatible = \"nxp,pcal6408\", .data = OF_953X(8, PCA_LATCH_INT), },\n\t{ .compatible = \"nxp,pcal6416\", .data = OF_953X(16, PCA_LATCH_INT), },\n\t{ .compatible = \"nxp,pcal6524\", .data = OF_953X(24, PCA_LATCH_INT), },\n\t{ .compatible = \"nxp,pcal6534\", .data = OF_653X(34, PCA_LATCH_INT), },\n\t{ .compatible = \"nxp,pcal9535\", .data = OF_953X(16, PCA_LATCH_INT), },\n\t{ .compatible = \"nxp,pcal9554b\", .data = OF_953X( 8, PCA_LATCH_INT), },\n\t{ .compatible = \"nxp,pcal9555a\", .data = OF_953X(16, PCA_LATCH_INT), },\n\n\t{ .compatible = \"maxim,max7310\", .data = OF_953X( 8, 0), },\n\t{ .compatible = \"maxim,max7312\", .data = OF_953X(16, PCA_INT), },\n\t{ .compatible = \"maxim,max7313\", .data = OF_953X(16, PCA_INT), },\n\t{ .compatible = \"maxim,max7315\", .data = OF_953X( 8, PCA_INT), },\n\t{ .compatible = \"maxim,max7318\", .data = OF_953X(16, PCA_INT), },\n\n\t{ .compatible = \"ti,pca6107\", .data = OF_953X( 8, PCA_INT), },\n\t{ .compatible = \"ti,pca9536\", .data = OF_953X( 4, 0), },\n\t{ .compatible = \"ti,tca6408\", .data = OF_953X( 8, PCA_INT), },\n\t{ .compatible = \"ti,tca6416\", .data = OF_953X(16, PCA_INT), },\n\t{ .compatible = \"ti,tca6424\", .data = OF_953X(24, PCA_INT), },\n\t{ .compatible = \"ti,tca9538\", .data = OF_953X( 8, PCA_INT), },\n\t{ .compatible = \"ti,tca9539\", .data = OF_953X(16, PCA_INT), },\n\n\t{ .compatible = \"onnn,cat9554\", .data = OF_953X( 8, PCA_INT), },\n\t{ .compatible = \"onnn,pca9654\", .data = OF_953X( 8, PCA_INT), },\n\t{ .compatible = \"onnn,pca9655\", .data = OF_953X(16, PCA_INT), },\n\n\t{ .compatible = \"exar,xra1202\", .data = OF_953X( 8, 0), },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, pca953x_dt_ids);\n\nstatic SIMPLE_DEV_PM_OPS(pca953x_pm_ops, pca953x_suspend, pca953x_resume);\n\nstatic struct i2c_driver pca953x_driver = {\n\t.driver = {\n\t\t.name\t= \"pca953x\",\n\t\t.pm\t= &pca953x_pm_ops,\n\t\t.of_match_table = pca953x_dt_ids,\n\t\t.acpi_match_table = pca953x_acpi_ids,\n\t},\n\t.probe\t\t= pca953x_probe,\n\t.remove\t\t= pca953x_remove,\n\t.id_table\t= pca953x_id,\n};\n\nstatic int __init pca953x_init(void)\n{\n\treturn i2c_add_driver(&pca953x_driver);\n}\n \nsubsys_initcall(pca953x_init);\n\nstatic void __exit pca953x_exit(void)\n{\n\ti2c_del_driver(&pca953x_driver);\n}\nmodule_exit(pca953x_exit);\n\nMODULE_AUTHOR(\"eric miao <eric.miao@marvell.com>\");\nMODULE_DESCRIPTION(\"GPIO expander driver for PCA953x\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}