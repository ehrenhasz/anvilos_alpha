{
  "module_name": "gpio-max732x.c",
  "hash_id": "43aa60c72d1a9614c5a6d5d8fe559b25a05d25886fa48f0932c6c0f860263d6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-max732x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/platform_data/max732x.h>\n\n \n\n#define PORT_NONE\t0x0\t \n#define PORT_OUTPUT\t0x1\t \n#define PORT_INPUT\t0x2\t \n#define PORT_OPENDRAIN\t0x3\t \n\n#define IO_4I4O\t\t0x5AA5\t \n#define IO_4P4O\t\t0x5FF5\t \n#define IO_8I\t\t0xAAAA\t \n#define IO_8P\t\t0xFFFF\t \n#define IO_8O\t\t0x5555\t \n\n#define GROUP_A(x)\t((x) & 0xffff)\t \n#define GROUP_B(x)\t((x) << 16)\t \n\n#define INT_NONE\t0x0\t \n#define INT_NO_MASK\t0x1\t \n#define INT_INDEP_MASK\t0x2\t \n#define INT_MERGED_MASK 0x3\t \n\n#define INT_CAPS(x)\t(((uint64_t)(x)) << 32)\n\nenum {\n\tMAX7319,\n\tMAX7320,\n\tMAX7321,\n\tMAX7322,\n\tMAX7323,\n\tMAX7324,\n\tMAX7325,\n\tMAX7326,\n\tMAX7327,\n};\n\nstatic uint64_t max732x_features[] = {\n\t[MAX7319] = GROUP_A(IO_8I) | INT_CAPS(INT_MERGED_MASK),\n\t[MAX7320] = GROUP_B(IO_8O),\n\t[MAX7321] = GROUP_A(IO_8P) | INT_CAPS(INT_NO_MASK),\n\t[MAX7322] = GROUP_A(IO_4I4O) | INT_CAPS(INT_MERGED_MASK),\n\t[MAX7323] = GROUP_A(IO_4P4O) | INT_CAPS(INT_INDEP_MASK),\n\t[MAX7324] = GROUP_A(IO_8I) | GROUP_B(IO_8O) | INT_CAPS(INT_MERGED_MASK),\n\t[MAX7325] = GROUP_A(IO_8P) | GROUP_B(IO_8O) | INT_CAPS(INT_NO_MASK),\n\t[MAX7326] = GROUP_A(IO_4I4O) | GROUP_B(IO_8O) | INT_CAPS(INT_MERGED_MASK),\n\t[MAX7327] = GROUP_A(IO_4P4O) | GROUP_B(IO_8O) | INT_CAPS(INT_NO_MASK),\n};\n\nstatic const struct i2c_device_id max732x_id[] = {\n\t{ \"max7319\", MAX7319 },\n\t{ \"max7320\", MAX7320 },\n\t{ \"max7321\", MAX7321 },\n\t{ \"max7322\", MAX7322 },\n\t{ \"max7323\", MAX7323 },\n\t{ \"max7324\", MAX7324 },\n\t{ \"max7325\", MAX7325 },\n\t{ \"max7326\", MAX7326 },\n\t{ \"max7327\", MAX7327 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, max732x_id);\n\nstatic const struct of_device_id max732x_of_table[] = {\n\t{ .compatible = \"maxim,max7319\" },\n\t{ .compatible = \"maxim,max7320\" },\n\t{ .compatible = \"maxim,max7321\" },\n\t{ .compatible = \"maxim,max7322\" },\n\t{ .compatible = \"maxim,max7323\" },\n\t{ .compatible = \"maxim,max7324\" },\n\t{ .compatible = \"maxim,max7325\" },\n\t{ .compatible = \"maxim,max7326\" },\n\t{ .compatible = \"maxim,max7327\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max732x_of_table);\n\nstruct max732x_chip {\n\tstruct gpio_chip gpio_chip;\n\n\tstruct i2c_client *client;\t \n\tstruct i2c_client *client_dummy;\n\tstruct i2c_client *client_group_a;\n\tstruct i2c_client *client_group_b;\n\n\tunsigned int\tmask_group_a;\n\tunsigned int\tdir_input;\n\tunsigned int\tdir_output;\n\n\tstruct mutex\tlock;\n\tuint8_t\t\treg_out[2];\n\n#ifdef CONFIG_GPIO_MAX732X_IRQ\n\tstruct mutex\t\tirq_lock;\n\tuint8_t\t\t\tirq_mask;\n\tuint8_t\t\t\tirq_mask_cur;\n\tuint8_t\t\t\tirq_trig_raise;\n\tuint8_t\t\t\tirq_trig_fall;\n\tuint8_t\t\t\tirq_features;\n#endif\n};\n\nstatic int max732x_writeb(struct max732x_chip *chip, int group_a, uint8_t val)\n{\n\tstruct i2c_client *client;\n\tint ret;\n\n\tclient = group_a ? chip->client_group_a : chip->client_group_b;\n\tret = i2c_smbus_write_byte(client, val);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed writing\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int max732x_readb(struct max732x_chip *chip, int group_a, uint8_t *val)\n{\n\tstruct i2c_client *client;\n\tint ret;\n\n\tclient = group_a ? chip->client_group_a : chip->client_group_b;\n\tret = i2c_smbus_read_byte(client);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed reading\\n\");\n\t\treturn ret;\n\t}\n\n\t*val = (uint8_t)ret;\n\treturn 0;\n}\n\nstatic inline int is_group_a(struct max732x_chip *chip, unsigned off)\n{\n\treturn (1u << off) & chip->mask_group_a;\n}\n\nstatic int max732x_gpio_get_value(struct gpio_chip *gc, unsigned off)\n{\n\tstruct max732x_chip *chip = gpiochip_get_data(gc);\n\tuint8_t reg_val;\n\tint ret;\n\n\tret = max732x_readb(chip, is_group_a(chip, off), &reg_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(reg_val & (1u << (off & 0x7)));\n}\n\nstatic void max732x_gpio_set_mask(struct gpio_chip *gc, unsigned off, int mask,\n\t\t\t\t  int val)\n{\n\tstruct max732x_chip *chip = gpiochip_get_data(gc);\n\tuint8_t reg_out;\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\n\treg_out = (off > 7) ? chip->reg_out[1] : chip->reg_out[0];\n\treg_out = (reg_out & ~mask) | (val & mask);\n\n\tret = max732x_writeb(chip, is_group_a(chip, off), reg_out);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (off > 7)\n\t\tchip->reg_out[1] = reg_out;\n\telse\n\t\tchip->reg_out[0] = reg_out;\nout:\n\tmutex_unlock(&chip->lock);\n}\n\nstatic void max732x_gpio_set_value(struct gpio_chip *gc, unsigned off, int val)\n{\n\tunsigned base = off & ~0x7;\n\tuint8_t mask = 1u << (off & 0x7);\n\n\tmax732x_gpio_set_mask(gc, base, mask, val << (off & 0x7));\n}\n\nstatic void max732x_gpio_set_multiple(struct gpio_chip *gc,\n\t\t\t\t      unsigned long *mask, unsigned long *bits)\n{\n\tunsigned mask_lo = mask[0] & 0xff;\n\tunsigned mask_hi = (mask[0] >> 8) & 0xff;\n\n\tif (mask_lo)\n\t\tmax732x_gpio_set_mask(gc, 0, mask_lo, bits[0] & 0xff);\n\tif (mask_hi)\n\t\tmax732x_gpio_set_mask(gc, 8, mask_hi, (bits[0] >> 8) & 0xff);\n}\n\nstatic int max732x_gpio_direction_input(struct gpio_chip *gc, unsigned off)\n{\n\tstruct max732x_chip *chip = gpiochip_get_data(gc);\n\tunsigned int mask = 1u << off;\n\n\tif ((mask & chip->dir_input) == 0) {\n\t\tdev_dbg(&chip->client->dev, \"%s port %d is output only\\n\",\n\t\t\tchip->client->name, off);\n\t\treturn -EACCES;\n\t}\n\n\t \n\tif ((mask & chip->dir_output))\n\t\tmax732x_gpio_set_value(gc, off, 1);\n\n\treturn 0;\n}\n\nstatic int max732x_gpio_direction_output(struct gpio_chip *gc,\n\t\tunsigned off, int val)\n{\n\tstruct max732x_chip *chip = gpiochip_get_data(gc);\n\tunsigned int mask = 1u << off;\n\n\tif ((mask & chip->dir_output) == 0) {\n\t\tdev_dbg(&chip->client->dev, \"%s port %d is input only\\n\",\n\t\t\tchip->client->name, off);\n\t\treturn -EACCES;\n\t}\n\n\tmax732x_gpio_set_value(gc, off, val);\n\treturn 0;\n}\n\n#ifdef CONFIG_GPIO_MAX732X_IRQ\nstatic int max732x_writew(struct max732x_chip *chip, uint16_t val)\n{\n\tint ret;\n\n\tval = cpu_to_le16(val);\n\n\tret = i2c_master_send(chip->client_group_a, (char *)&val, 2);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client_group_a->dev, \"failed writing\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int max732x_readw(struct max732x_chip *chip, uint16_t *val)\n{\n\tint ret;\n\n\tret = i2c_master_recv(chip->client_group_a, (char *)val, 2);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client_group_a->dev, \"failed reading\\n\");\n\t\treturn ret;\n\t}\n\n\t*val = le16_to_cpu(*val);\n\treturn 0;\n}\n\nstatic void max732x_irq_update_mask(struct max732x_chip *chip)\n{\n\tuint16_t msg;\n\n\tif (chip->irq_mask == chip->irq_mask_cur)\n\t\treturn;\n\n\tchip->irq_mask = chip->irq_mask_cur;\n\n\tif (chip->irq_features == INT_NO_MASK)\n\t\treturn;\n\n\tmutex_lock(&chip->lock);\n\n\tswitch (chip->irq_features) {\n\tcase INT_INDEP_MASK:\n\t\tmsg = (chip->irq_mask << 8) | chip->reg_out[0];\n\t\tmax732x_writew(chip, msg);\n\t\tbreak;\n\n\tcase INT_MERGED_MASK:\n\t\tmsg = chip->irq_mask | chip->reg_out[0];\n\t\tmax732x_writeb(chip, 1, (uint8_t)msg);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&chip->lock);\n}\n\nstatic void max732x_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct max732x_chip *chip = gpiochip_get_data(gc);\n\n\tchip->irq_mask_cur &= ~(1 << d->hwirq);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void max732x_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct max732x_chip *chip = gpiochip_get_data(gc);\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\tchip->irq_mask_cur |= 1 << d->hwirq;\n}\n\nstatic void max732x_irq_bus_lock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct max732x_chip *chip = gpiochip_get_data(gc);\n\n\tmutex_lock(&chip->irq_lock);\n\tchip->irq_mask_cur = chip->irq_mask;\n}\n\nstatic void max732x_irq_bus_sync_unlock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct max732x_chip *chip = gpiochip_get_data(gc);\n\tuint16_t new_irqs;\n\tuint16_t level;\n\n\tmax732x_irq_update_mask(chip);\n\n\tnew_irqs = chip->irq_trig_fall | chip->irq_trig_raise;\n\twhile (new_irqs) {\n\t\tlevel = __ffs(new_irqs);\n\t\tmax732x_gpio_direction_input(&chip->gpio_chip, level);\n\t\tnew_irqs &= ~(1 << level);\n\t}\n\n\tmutex_unlock(&chip->irq_lock);\n}\n\nstatic int max732x_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct max732x_chip *chip = gpiochip_get_data(gc);\n\tuint16_t off = d->hwirq;\n\tuint16_t mask = 1 << off;\n\n\tif (!(mask & chip->dir_input)) {\n\t\tdev_dbg(&chip->client->dev, \"%s port %d is output only\\n\",\n\t\t\tchip->client->name, off);\n\t\treturn -EACCES;\n\t}\n\n\tif (!(type & IRQ_TYPE_EDGE_BOTH)) {\n\t\tdev_err(&chip->client->dev, \"irq %d: unsupported type %d\\n\",\n\t\t\td->irq, type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tchip->irq_trig_fall |= mask;\n\telse\n\t\tchip->irq_trig_fall &= ~mask;\n\n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tchip->irq_trig_raise |= mask;\n\telse\n\t\tchip->irq_trig_raise &= ~mask;\n\n\treturn 0;\n}\n\nstatic int max732x_irq_set_wake(struct irq_data *data, unsigned int on)\n{\n\tstruct max732x_chip *chip = irq_data_get_irq_chip_data(data);\n\n\tirq_set_irq_wake(chip->client->irq, on);\n\treturn 0;\n}\n\nstatic const struct irq_chip max732x_irq_chip = {\n\t.name\t\t\t= \"max732x\",\n\t.irq_mask\t\t= max732x_irq_mask,\n\t.irq_unmask\t\t= max732x_irq_unmask,\n\t.irq_bus_lock\t\t= max732x_irq_bus_lock,\n\t.irq_bus_sync_unlock\t= max732x_irq_bus_sync_unlock,\n\t.irq_set_type\t\t= max732x_irq_set_type,\n\t.irq_set_wake\t\t= max732x_irq_set_wake,\n\t.flags\t\t\t= IRQCHIP_IMMUTABLE,\n\t GPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic uint8_t max732x_irq_pending(struct max732x_chip *chip)\n{\n\tuint8_t cur_stat;\n\tuint8_t old_stat;\n\tuint8_t trigger;\n\tuint8_t pending;\n\tuint16_t status;\n\tint ret;\n\n\tret = max732x_readw(chip, &status);\n\tif (ret)\n\t\treturn 0;\n\n\ttrigger = status >> 8;\n\ttrigger &= chip->irq_mask;\n\n\tif (!trigger)\n\t\treturn 0;\n\n\tcur_stat = status & 0xFF;\n\tcur_stat &= chip->irq_mask;\n\n\told_stat = cur_stat ^ trigger;\n\n\tpending = (old_stat & chip->irq_trig_fall) |\n\t\t  (cur_stat & chip->irq_trig_raise);\n\tpending &= trigger;\n\n\treturn pending;\n}\n\nstatic irqreturn_t max732x_irq_handler(int irq, void *devid)\n{\n\tstruct max732x_chip *chip = devid;\n\tuint8_t pending;\n\tuint8_t level;\n\n\tpending = max732x_irq_pending(chip);\n\n\tif (!pending)\n\t\treturn IRQ_HANDLED;\n\n\tdo {\n\t\tlevel = __ffs(pending);\n\t\thandle_nested_irq(irq_find_mapping(chip->gpio_chip.irq.domain,\n\t\t\t\t\t\t   level));\n\n\t\tpending &= ~(1 << level);\n\t} while (pending);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int max732x_irq_setup(struct max732x_chip *chip,\n\t\t\t     const struct i2c_device_id *id)\n{\n\tstruct i2c_client *client = chip->client;\n\tint has_irq = max732x_features[id->driver_data] >> 32;\n\tint irq_base = 0;\n\tint ret;\n\n\tif (client->irq && has_irq != INT_NONE) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\tchip->irq_features = has_irq;\n\t\tmutex_init(&chip->irq_lock);\n\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\tNULL, max732x_irq_handler, IRQF_ONESHOT |\n\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_SHARED,\n\t\t\t\tdev_name(&client->dev), chip);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"failed to request irq %d\\n\",\n\t\t\t\tclient->irq);\n\t\t\treturn ret;\n\t\t}\n\n\t\tgirq = &chip->gpio_chip.irq;\n\t\tgpio_irq_chip_set_chip(girq, &max732x_irq_chip);\n\t\t \n\t\tgirq->parent_handler = NULL;\n\t\tgirq->num_parents = 0;\n\t\tgirq->parents = NULL;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_simple_irq;\n\t\tgirq->threaded = true;\n\t\tgirq->first = irq_base;  \n\t}\n\n\treturn 0;\n}\n\n#else  \nstatic int max732x_irq_setup(struct max732x_chip *chip,\n\t\t\t     const struct i2c_device_id *id)\n{\n\tstruct i2c_client *client = chip->client;\n\tint has_irq = max732x_features[id->driver_data] >> 32;\n\n\tif (client->irq && has_irq != INT_NONE)\n\t\tdev_warn(&client->dev, \"interrupt support not compiled in\\n\");\n\n\treturn 0;\n}\n#endif\n\nstatic int max732x_setup_gpio(struct max732x_chip *chip,\n\t\t\t\t\tconst struct i2c_device_id *id,\n\t\t\t\t\tunsigned gpio_start)\n{\n\tstruct gpio_chip *gc = &chip->gpio_chip;\n\tuint32_t id_data = (uint32_t)max732x_features[id->driver_data];\n\tint i, port = 0;\n\n\tfor (i = 0; i < 16; i++, id_data >>= 2) {\n\t\tunsigned int mask = 1 << port;\n\n\t\tswitch (id_data & 0x3) {\n\t\tcase PORT_OUTPUT:\n\t\t\tchip->dir_output |= mask;\n\t\t\tbreak;\n\t\tcase PORT_INPUT:\n\t\t\tchip->dir_input |= mask;\n\t\t\tbreak;\n\t\tcase PORT_OPENDRAIN:\n\t\t\tchip->dir_output |= mask;\n\t\t\tchip->dir_input |= mask;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i < 8)\n\t\t\tchip->mask_group_a |= mask;\n\t\tport++;\n\t}\n\n\tif (chip->dir_input)\n\t\tgc->direction_input = max732x_gpio_direction_input;\n\tif (chip->dir_output) {\n\t\tgc->direction_output = max732x_gpio_direction_output;\n\t\tgc->set = max732x_gpio_set_value;\n\t\tgc->set_multiple = max732x_gpio_set_multiple;\n\t}\n\tgc->get = max732x_gpio_get_value;\n\tgc->can_sleep = true;\n\n\tgc->base = gpio_start;\n\tgc->ngpio = port;\n\tgc->label = chip->client->name;\n\tgc->parent = &chip->client->dev;\n\tgc->owner = THIS_MODULE;\n\n\treturn port;\n}\n\nstatic struct max732x_platform_data *of_gpio_max732x(struct device *dev)\n{\n\tstruct max732x_platform_data *pdata;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tpdata->gpio_base = -1;\n\n\treturn pdata;\n}\n\nstatic int max732x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct max732x_platform_data *pdata;\n\tstruct device_node *node;\n\tstruct max732x_chip *chip;\n\tstruct i2c_client *c;\n\tuint16_t addr_a, addr_b;\n\tint ret, nr_port;\n\n\tpdata = dev_get_platdata(&client->dev);\n\tnode = client->dev.of_node;\n\n\tif (!pdata && node)\n\t\tpdata = of_gpio_max732x(&client->dev);\n\n\tif (!pdata) {\n\t\tdev_dbg(&client->dev, \"no platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\tchip->client = client;\n\n\tnr_port = max732x_setup_gpio(chip, id, pdata->gpio_base);\n\tchip->gpio_chip.parent = &client->dev;\n\n\taddr_a = (client->addr & 0x0f) | 0x60;\n\taddr_b = (client->addr & 0x0f) | 0x50;\n\n\tswitch (client->addr & 0x70) {\n\tcase 0x60:\n\t\tchip->client_group_a = client;\n\t\tif (nr_port > 8) {\n\t\t\tc = devm_i2c_new_dummy_device(&client->dev,\n\t\t\t\t\t\t      client->adapter, addr_b);\n\t\t\tif (IS_ERR(c)) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Failed to allocate I2C device\\n\");\n\t\t\t\treturn PTR_ERR(c);\n\t\t\t}\n\t\t\tchip->client_group_b = chip->client_dummy = c;\n\t\t}\n\t\tbreak;\n\tcase 0x50:\n\t\tchip->client_group_b = client;\n\t\tif (nr_port > 8) {\n\t\t\tc = devm_i2c_new_dummy_device(&client->dev,\n\t\t\t\t\t\t      client->adapter, addr_a);\n\t\t\tif (IS_ERR(c)) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Failed to allocate I2C device\\n\");\n\t\t\t\treturn PTR_ERR(c);\n\t\t\t}\n\t\t\tchip->client_group_a = chip->client_dummy = c;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"invalid I2C address specified %02x\\n\",\n\t\t\t\tclient->addr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nr_port > 8 && !chip->client_dummy) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to allocate second group I2C device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_init(&chip->lock);\n\n\tret = max732x_readb(chip, is_group_a(chip, 0), &chip->reg_out[0]);\n\tif (ret)\n\t\treturn ret;\n\tif (nr_port > 8) {\n\t\tret = max732x_readb(chip, is_group_a(chip, 8), &chip->reg_out[1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = max732x_irq_setup(chip, id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_gpiochip_add_data(&client->dev, &chip->gpio_chip, chip);\n\tif (ret)\n\t\treturn ret;\n\n\ti2c_set_clientdata(client, chip);\n\treturn 0;\n}\n\nstatic struct i2c_driver max732x_driver = {\n\t.driver = {\n\t\t.name\t\t= \"max732x\",\n\t\t.of_match_table\t= max732x_of_table,\n\t},\n\t.probe\t\t= max732x_probe,\n\t.id_table\t= max732x_id,\n};\n\nstatic int __init max732x_init(void)\n{\n\treturn i2c_add_driver(&max732x_driver);\n}\n \nsubsys_initcall(max732x_init);\n\nstatic void __exit max732x_exit(void)\n{\n\ti2c_del_driver(&max732x_driver);\n}\nmodule_exit(max732x_exit);\n\nMODULE_AUTHOR(\"Eric Miao <eric.miao@marvell.com>\");\nMODULE_DESCRIPTION(\"GPIO expander driver for MAX732X\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}