{
  "module_name": "gpio-creg-snps.c",
  "hash_id": "892af429f8f4fb4e14c531bbd53eab8fe64de7b6fb3cf4b3168a580e0f228614",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-creg-snps.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#define MAX_GPIO\t32\n\nstruct creg_layout {\n\tu8 ngpio;\n\tu8 shift[MAX_GPIO];\n\tu8 on[MAX_GPIO];\n\tu8 off[MAX_GPIO];\n\tu8 bit_per_gpio[MAX_GPIO];\n};\n\nstruct creg_gpio {\n\tstruct gpio_chip gc;\n\tvoid __iomem *regs;\n\tspinlock_t lock;\n\tconst struct creg_layout *layout;\n};\n\nstatic void creg_gpio_set(struct gpio_chip *gc, unsigned int offset, int val)\n{\n\tstruct creg_gpio *hcg = gpiochip_get_data(gc);\n\tconst struct creg_layout *layout = hcg->layout;\n\tu32 reg, reg_shift, value;\n\tunsigned long flags;\n\tint i;\n\n\tvalue = val ? hcg->layout->on[offset] : hcg->layout->off[offset];\n\n\treg_shift = layout->shift[offset];\n\tfor (i = 0; i < offset; i++)\n\t\treg_shift += layout->bit_per_gpio[i] + layout->shift[i];\n\n\tspin_lock_irqsave(&hcg->lock, flags);\n\treg = readl(hcg->regs);\n\treg &= ~(GENMASK(layout->bit_per_gpio[i] - 1, 0) << reg_shift);\n\treg |=  (value << reg_shift);\n\twritel(reg, hcg->regs);\n\tspin_unlock_irqrestore(&hcg->lock, flags);\n}\n\nstatic int creg_gpio_dir_out(struct gpio_chip *gc, unsigned int offset, int val)\n{\n\tcreg_gpio_set(gc, offset, val);\n\n\treturn 0;\n}\n\nstatic int creg_gpio_validate_pg(struct device *dev, struct creg_gpio *hcg,\n\t\t\t\t int i)\n{\n\tconst struct creg_layout *layout = hcg->layout;\n\n\tif (layout->bit_per_gpio[i] < 1 || layout->bit_per_gpio[i] > 8)\n\t\treturn -EINVAL;\n\n\t \n\tif (GENMASK(31, layout->bit_per_gpio[i]) & layout->on[i])\n\t\treturn -EINVAL;\n\n\t \n\tif (GENMASK(31, layout->bit_per_gpio[i]) & layout->off[i])\n\t\treturn -EINVAL;\n\n\tif (layout->on[i] == layout->off[i])\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int creg_gpio_validate(struct device *dev, struct creg_gpio *hcg,\n\t\t\t      u32 ngpios)\n{\n\tu32 reg_len = 0;\n\tint i;\n\n\tif (hcg->layout->ngpio < 1 || hcg->layout->ngpio > MAX_GPIO)\n\t\treturn -EINVAL;\n\n\tif (ngpios < 1 || ngpios > hcg->layout->ngpio) {\n\t\tdev_err(dev, \"ngpios must be in [1:%u]\\n\", hcg->layout->ngpio);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < hcg->layout->ngpio; i++) {\n\t\tif (creg_gpio_validate_pg(dev, hcg, i))\n\t\t\treturn -EINVAL;\n\n\t\treg_len += hcg->layout->shift[i] + hcg->layout->bit_per_gpio[i];\n\t}\n\n\t \n\tif (reg_len > 32)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct creg_layout hsdk_cs_ctl = {\n\t.ngpio\t\t= 10,\n\t.shift\t\t= { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t.off\t\t= { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 },\n\t.on\t\t= { 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 },\n\t.bit_per_gpio\t= { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 }\n};\n\nstatic const struct creg_layout axs10x_flsh_cs_ctl = {\n\t.ngpio\t\t= 1,\n\t.shift\t\t= { 0 },\n\t.off\t\t= { 1 },\n\t.on\t\t= { 3 },\n\t.bit_per_gpio\t= { 2 }\n};\n\nstatic const struct of_device_id creg_gpio_ids[] = {\n\t{\n\t\t.compatible = \"snps,creg-gpio-axs10x\",\n\t\t.data = &axs10x_flsh_cs_ctl\n\t}, {\n\t\t.compatible = \"snps,creg-gpio-hsdk\",\n\t\t.data = &hsdk_cs_ctl\n\t}, {   }\n};\n\nstatic int creg_gpio_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct device *dev = &pdev->dev;\n\tstruct creg_gpio *hcg;\n\tu32 ngpios;\n\tint ret;\n\n\thcg = devm_kzalloc(dev, sizeof(struct creg_gpio), GFP_KERNEL);\n\tif (!hcg)\n\t\treturn -ENOMEM;\n\n\thcg->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hcg->regs))\n\t\treturn PTR_ERR(hcg->regs);\n\n\tmatch = of_match_node(creg_gpio_ids, pdev->dev.of_node);\n\thcg->layout = match->data;\n\tif (!hcg->layout)\n\t\treturn -EINVAL;\n\n\tret = of_property_read_u32(dev->of_node, \"ngpios\", &ngpios);\n\tif (ret)\n\t\treturn ret;\n\n\tret = creg_gpio_validate(dev, hcg, ngpios);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_init(&hcg->lock);\n\n\thcg->gc.parent = dev;\n\thcg->gc.label = dev_name(dev);\n\thcg->gc.base = -1;\n\thcg->gc.ngpio = ngpios;\n\thcg->gc.set = creg_gpio_set;\n\thcg->gc.direction_output = creg_gpio_dir_out;\n\n\tret = devm_gpiochip_add_data(dev, &hcg->gc, hcg);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"GPIO controller with %d gpios probed\\n\", ngpios);\n\n\treturn 0;\n}\n\nstatic struct platform_driver creg_gpio_snps_driver = {\n\t.driver = {\n\t\t.name = \"snps-creg-gpio\",\n\t\t.of_match_table = creg_gpio_ids,\n\t},\n\t.probe  = creg_gpio_probe,\n};\nbuiltin_platform_driver(creg_gpio_snps_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}