{
  "module_name": "gpio-mlxbf.c",
  "hash_id": "a3e603cad6e2147b59ec1284793d52c6bb9f2d663e53e758cbccc7f212e0f2d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mlxbf.c",
  "human_readable_source": "\n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/resource.h>\n#include <linux/types.h>\n\n \n#define MLXBF_GPIO_NR 54\n\n \n#define MLXBF_GPIO_PAD_CONTROL_FIRST_WORD 0x0700\n#define MLXBF_GPIO_PAD_CONTROL_1_FIRST_WORD 0x0708\n#define MLXBF_GPIO_PAD_CONTROL_2_FIRST_WORD 0x0710\n#define MLXBF_GPIO_PAD_CONTROL_3_FIRST_WORD 0x0718\n\n#define MLXBF_GPIO_PIN_DIR_I 0x1040\n#define MLXBF_GPIO_PIN_DIR_O 0x1048\n#define MLXBF_GPIO_PIN_STATE 0x1000\n#define MLXBF_GPIO_SCRATCHPAD 0x20\n\n#ifdef CONFIG_PM\nstruct mlxbf_gpio_context_save_regs {\n\tu64 scratchpad;\n\tu64 pad_control[MLXBF_GPIO_NR];\n\tu64 pin_dir_i;\n\tu64 pin_dir_o;\n};\n#endif\n\n \nstruct mlxbf_gpio_state {\n\tstruct gpio_chip gc;\n\n\t \n\tvoid __iomem *base;\n\n#ifdef CONFIG_PM\n\tstruct mlxbf_gpio_context_save_regs csave_regs;\n#endif\n};\n\nstatic int mlxbf_gpio_probe(struct platform_device *pdev)\n{\n\tstruct mlxbf_gpio_state *gs;\n\tstruct device *dev = &pdev->dev;\n\tstruct gpio_chip *gc;\n\tint ret;\n\n\tgs = devm_kzalloc(&pdev->dev, sizeof(*gs), GFP_KERNEL);\n\tif (!gs)\n\t\treturn -ENOMEM;\n\n\tgs->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gs->base))\n\t\treturn PTR_ERR(gs->base);\n\n\tgc = &gs->gc;\n\tret = bgpio_init(gc, dev, 8,\n\t\t\t gs->base + MLXBF_GPIO_PIN_STATE,\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t gs->base + MLXBF_GPIO_PIN_DIR_O,\n\t\t\t gs->base + MLXBF_GPIO_PIN_DIR_I,\n\t\t\t 0);\n\tif (ret)\n\t\treturn -ENODEV;\n\n\tgc->owner = THIS_MODULE;\n\tgc->ngpio = MLXBF_GPIO_NR;\n\n\tret = devm_gpiochip_add_data(dev, &gs->gc, gs);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed adding memory mapped gpiochip\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, gs);\n\tdev_info(&pdev->dev, \"registered Mellanox BlueField GPIO\");\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int mlxbf_gpio_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct mlxbf_gpio_state *gs = platform_get_drvdata(pdev);\n\n\tgs->csave_regs.scratchpad = readq(gs->base + MLXBF_GPIO_SCRATCHPAD);\n\tgs->csave_regs.pad_control[0] =\n\t\treadq(gs->base + MLXBF_GPIO_PAD_CONTROL_FIRST_WORD);\n\tgs->csave_regs.pad_control[1] =\n\t\treadq(gs->base + MLXBF_GPIO_PAD_CONTROL_1_FIRST_WORD);\n\tgs->csave_regs.pad_control[2] =\n\t\treadq(gs->base + MLXBF_GPIO_PAD_CONTROL_2_FIRST_WORD);\n\tgs->csave_regs.pad_control[3] =\n\t\treadq(gs->base + MLXBF_GPIO_PAD_CONTROL_3_FIRST_WORD);\n\tgs->csave_regs.pin_dir_i = readq(gs->base + MLXBF_GPIO_PIN_DIR_I);\n\tgs->csave_regs.pin_dir_o = readq(gs->base + MLXBF_GPIO_PIN_DIR_O);\n\n\treturn 0;\n}\n\nstatic int mlxbf_gpio_resume(struct platform_device *pdev)\n{\n\tstruct mlxbf_gpio_state *gs = platform_get_drvdata(pdev);\n\n\twriteq(gs->csave_regs.scratchpad, gs->base + MLXBF_GPIO_SCRATCHPAD);\n\twriteq(gs->csave_regs.pad_control[0],\n\t       gs->base + MLXBF_GPIO_PAD_CONTROL_FIRST_WORD);\n\twriteq(gs->csave_regs.pad_control[1],\n\t       gs->base + MLXBF_GPIO_PAD_CONTROL_1_FIRST_WORD);\n\twriteq(gs->csave_regs.pad_control[2],\n\t       gs->base + MLXBF_GPIO_PAD_CONTROL_2_FIRST_WORD);\n\twriteq(gs->csave_regs.pad_control[3],\n\t       gs->base + MLXBF_GPIO_PAD_CONTROL_3_FIRST_WORD);\n\twriteq(gs->csave_regs.pin_dir_i, gs->base + MLXBF_GPIO_PIN_DIR_I);\n\twriteq(gs->csave_regs.pin_dir_o, gs->base + MLXBF_GPIO_PIN_DIR_O);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct acpi_device_id __maybe_unused mlxbf_gpio_acpi_match[] = {\n\t{ \"MLNXBF02\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, mlxbf_gpio_acpi_match);\n\nstatic struct platform_driver mlxbf_gpio_driver = {\n\t.driver = {\n\t\t.name = \"mlxbf_gpio\",\n\t\t.acpi_match_table = ACPI_PTR(mlxbf_gpio_acpi_match),\n\t},\n\t.probe    = mlxbf_gpio_probe,\n#ifdef CONFIG_PM\n\t.suspend  = mlxbf_gpio_suspend,\n\t.resume   = mlxbf_gpio_resume,\n#endif\n};\n\nmodule_platform_driver(mlxbf_gpio_driver);\n\nMODULE_DESCRIPTION(\"Mellanox BlueField GPIO Driver\");\nMODULE_AUTHOR(\"Mellanox Technologies\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}