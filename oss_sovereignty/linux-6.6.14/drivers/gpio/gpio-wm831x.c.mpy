{
  "module_name": "gpio-wm831x.c",
  "hash_id": "7d80caae7fcc24293d0fc16e6d69f8ec5fe3d04b5701842b8924c73df27d5626",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-wm831x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/gpio/driver.h>\n#include <linux/mfd/core.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n\n#include <linux/mfd/wm831x/core.h>\n#include <linux/mfd/wm831x/pdata.h>\n#include <linux/mfd/wm831x/gpio.h>\n#include <linux/mfd/wm831x/irq.h>\n\nstruct wm831x_gpio {\n\tstruct wm831x *wm831x;\n\tstruct gpio_chip gpio_chip;\n};\n\nstatic int wm831x_gpio_direction_in(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct wm831x_gpio *wm831x_gpio = gpiochip_get_data(chip);\n\tstruct wm831x *wm831x = wm831x_gpio->wm831x;\n\tint val = WM831X_GPN_DIR;\n\n\tif (wm831x->has_gpio_ena)\n\t\tval |= WM831X_GPN_TRI;\n\n\treturn wm831x_set_bits(wm831x, WM831X_GPIO1_CONTROL + offset,\n\t\t\t       WM831X_GPN_DIR | WM831X_GPN_TRI |\n\t\t\t       WM831X_GPN_FN_MASK, val);\n}\n\nstatic int wm831x_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct wm831x_gpio *wm831x_gpio = gpiochip_get_data(chip);\n\tstruct wm831x *wm831x = wm831x_gpio->wm831x;\n\tint ret;\n\n\tret = wm831x_reg_read(wm831x, WM831X_GPIO_LEVEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & 1 << offset)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void wm831x_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct wm831x_gpio *wm831x_gpio = gpiochip_get_data(chip);\n\tstruct wm831x *wm831x = wm831x_gpio->wm831x;\n\n\twm831x_set_bits(wm831x, WM831X_GPIO_LEVEL, 1 << offset,\n\t\t\tvalue << offset);\n}\n\nstatic int wm831x_gpio_direction_out(struct gpio_chip *chip,\n\t\t\t\t     unsigned offset, int value)\n{\n\tstruct wm831x_gpio *wm831x_gpio = gpiochip_get_data(chip);\n\tstruct wm831x *wm831x = wm831x_gpio->wm831x;\n\tint val = 0;\n\tint ret;\n\n\tif (wm831x->has_gpio_ena)\n\t\tval |= WM831X_GPN_TRI;\n\n\tret = wm831x_set_bits(wm831x, WM831X_GPIO1_CONTROL + offset,\n\t\t\t      WM831X_GPN_DIR | WM831X_GPN_TRI |\n\t\t\t      WM831X_GPN_FN_MASK, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\twm831x_gpio_set(chip, offset, value);\n\n\treturn 0;\n}\n\nstatic int wm831x_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct wm831x_gpio *wm831x_gpio = gpiochip_get_data(chip);\n\tstruct wm831x *wm831x = wm831x_gpio->wm831x;\n\n\treturn irq_create_mapping(wm831x->irq_domain,\n\t\t\t\t  WM831X_IRQ_GPIO_1 + offset);\n}\n\nstatic int wm831x_gpio_set_debounce(struct wm831x *wm831x, unsigned offset,\n\t\t\t\t    unsigned debounce)\n{\n\tint reg = WM831X_GPIO1_CONTROL + offset;\n\tint ret, fn;\n\n\tret = wm831x_reg_read(wm831x, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret & WM831X_GPN_FN_MASK) {\n\tcase 0:\n\tcase 1:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EBUSY;\n\t}\n\n\tif (debounce >= 32 && debounce <= 64)\n\t\tfn = 0;\n\telse if (debounce >= 4000 && debounce <= 8000)\n\t\tfn = 1;\n\telse\n\t\treturn -EINVAL;\n\n\treturn wm831x_set_bits(wm831x, reg, WM831X_GPN_FN_MASK, fn);\n}\n\nstatic int wm831x_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t     unsigned long config)\n{\n\tstruct wm831x_gpio *wm831x_gpio = gpiochip_get_data(chip);\n\tstruct wm831x *wm831x = wm831x_gpio->wm831x;\n\tint reg = WM831X_GPIO1_CONTROL + offset;\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\treturn wm831x_set_bits(wm831x, reg,\n\t\t\t\t       WM831X_GPN_OD_MASK, WM831X_GPN_OD);\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\treturn wm831x_set_bits(wm831x, reg,\n\t\t\t\t       WM831X_GPN_OD_MASK, 0);\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\treturn wm831x_gpio_set_debounce(wm831x, offset,\n\t\t\tpinconf_to_config_argument(config));\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void wm831x_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tstruct wm831x_gpio *wm831x_gpio = gpiochip_get_data(chip);\n\tstruct wm831x *wm831x = wm831x_gpio->wm831x;\n\tint i, tristated;\n\n\tfor (i = 0; i < chip->ngpio; i++) {\n\t\tint gpio = i + chip->base;\n\t\tint reg;\n\t\tconst char *label, *pull, *powerdomain;\n\n\t\t \n\t\tlabel = gpiochip_is_requested(chip, i);\n\t\tif (!label)\n\t\t\tlabel = \"Unrequested\";\n\n\t\tseq_printf(s, \" gpio-%-3d (%-20.20s) \", gpio, label);\n\n\t\treg = wm831x_reg_read(wm831x, WM831X_GPIO1_CONTROL + i);\n\t\tif (reg < 0) {\n\t\t\tdev_err(wm831x->dev,\n\t\t\t\t\"GPIO control %d read failed: %d\\n\",\n\t\t\t\tgpio, reg);\n\t\t\tseq_putc(s, '\\n');\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (reg & WM831X_GPN_PULL_MASK) {\n\t\tcase WM831X_GPIO_PULL_NONE:\n\t\t\tpull = \"nopull\";\n\t\t\tbreak;\n\t\tcase WM831X_GPIO_PULL_DOWN:\n\t\t\tpull = \"pulldown\";\n\t\t\tbreak;\n\t\tcase WM831X_GPIO_PULL_UP:\n\t\t\tpull = \"pullup\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpull = \"INVALID PULL\";\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (i + 1) {\n\t\tcase 1 ... 3:\n\t\tcase 7 ... 9:\n\t\t\tif (reg & WM831X_GPN_PWR_DOM)\n\t\t\t\tpowerdomain = \"VPMIC\";\n\t\t\telse\n\t\t\t\tpowerdomain = \"DBVDD\";\n\t\t\tbreak;\n\n\t\tcase 4 ... 6:\n\t\tcase 10 ... 12:\n\t\t\tif (reg & WM831X_GPN_PWR_DOM)\n\t\t\t\tpowerdomain = \"SYSVDD\";\n\t\t\telse\n\t\t\t\tpowerdomain = \"DBVDD\";\n\t\t\tbreak;\n\n\t\tcase 13 ... 16:\n\t\t\tpowerdomain = \"TPVDD\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\ttristated = reg & WM831X_GPN_TRI;\n\t\tif (wm831x->has_gpio_ena)\n\t\t\ttristated = !tristated;\n\n\t\tseq_printf(s, \" %s %s %s %s%s\\n\"\n\t\t\t   \"                                  %s%s (0x%4x)\\n\",\n\t\t\t   reg & WM831X_GPN_DIR ? \"in\" : \"out\",\n\t\t\t   wm831x_gpio_get(chip, i) ? \"high\" : \"low\",\n\t\t\t   pull,\n\t\t\t   powerdomain,\n\t\t\t   reg & WM831X_GPN_POL ? \"\" : \" inverted\",\n\t\t\t   reg & WM831X_GPN_OD ? \"open-drain\" : \"push-pull\",\n\t\t\t   tristated ? \" tristated\" : \"\",\n\t\t\t   reg);\n\t}\n}\n#else\n#define wm831x_gpio_dbg_show NULL\n#endif\n\nstatic const struct gpio_chip template_chip = {\n\t.label\t\t\t= \"wm831x\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.direction_input\t= wm831x_gpio_direction_in,\n\t.get\t\t\t= wm831x_gpio_get,\n\t.direction_output\t= wm831x_gpio_direction_out,\n\t.set\t\t\t= wm831x_gpio_set,\n\t.to_irq\t\t\t= wm831x_gpio_to_irq,\n\t.set_config\t\t= wm831x_set_config,\n\t.dbg_show\t\t= wm831x_gpio_dbg_show,\n\t.can_sleep\t\t= true,\n};\n\nstatic int wm831x_gpio_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_pdata *pdata = &wm831x->pdata;\n\tstruct wm831x_gpio *wm831x_gpio;\n\n\tdevice_set_node(&pdev->dev, dev_fwnode(pdev->dev.parent));\n\n\twm831x_gpio = devm_kzalloc(&pdev->dev, sizeof(*wm831x_gpio),\n\t\t\t\t   GFP_KERNEL);\n\tif (wm831x_gpio == NULL)\n\t\treturn -ENOMEM;\n\n\twm831x_gpio->wm831x = wm831x;\n\twm831x_gpio->gpio_chip = template_chip;\n\twm831x_gpio->gpio_chip.ngpio = wm831x->num_gpio;\n\twm831x_gpio->gpio_chip.parent = &pdev->dev;\n\tif (pdata && pdata->gpio_base)\n\t\twm831x_gpio->gpio_chip.base = pdata->gpio_base;\n\telse\n\t\twm831x_gpio->gpio_chip.base = -1;\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &wm831x_gpio->gpio_chip, wm831x_gpio);\n}\n\nstatic struct platform_driver wm831x_gpio_driver = {\n\t.driver.name\t= \"wm831x-gpio\",\n\t.probe\t\t= wm831x_gpio_probe,\n};\n\nstatic int __init wm831x_gpio_init(void)\n{\n\treturn platform_driver_register(&wm831x_gpio_driver);\n}\nsubsys_initcall(wm831x_gpio_init);\n\nstatic void __exit wm831x_gpio_exit(void)\n{\n\tplatform_driver_unregister(&wm831x_gpio_driver);\n}\nmodule_exit(wm831x_gpio_exit);\n\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"GPIO interface for WM831x PMICs\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm831x-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}