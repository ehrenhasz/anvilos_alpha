{
  "module_name": "gpio-pca9570.c",
  "hash_id": "9f4af41a0e576ecf915fd7f7edb91986895e54545bd5b2510797d994453cfd64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-pca9570.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n\n#define SLG7XL45106_GPO_REG\t0xDB\n\n \nstruct pca9570_chip_data {\n\tu16 ngpio;\n\tu32 command;\n};\n\n \nstruct pca9570 {\n\tstruct gpio_chip chip;\n\tconst struct pca9570_chip_data *chip_data;\n\tstruct mutex lock;\n\tu8 out;\n};\n\nstatic int pca9570_read(struct pca9570 *gpio, u8 *value)\n{\n\tstruct i2c_client *client = to_i2c_client(gpio->chip.parent);\n\tint ret;\n\n\tif (gpio->chip_data->command != 0)\n\t\tret = i2c_smbus_read_byte_data(client, gpio->chip_data->command);\n\telse\n\t\tret = i2c_smbus_read_byte(client);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*value = ret;\n\treturn 0;\n}\n\nstatic int pca9570_write(struct pca9570 *gpio, u8 value)\n{\n\tstruct i2c_client *client = to_i2c_client(gpio->chip.parent);\n\n\tif (gpio->chip_data->command != 0)\n\t\treturn i2c_smbus_write_byte_data(client, gpio->chip_data->command, value);\n\n\treturn i2c_smbus_write_byte(client, value);\n}\n\nstatic int pca9570_get_direction(struct gpio_chip *chip,\n\t\t\t\t unsigned offset)\n{\n\t \n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int pca9570_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct pca9570 *gpio = gpiochip_get_data(chip);\n\tu8 buffer;\n\tint ret;\n\n\tret = pca9570_read(gpio, &buffer);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(buffer & BIT(offset));\n}\n\nstatic void pca9570_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct pca9570 *gpio = gpiochip_get_data(chip);\n\tu8 buffer;\n\tint ret;\n\n\tmutex_lock(&gpio->lock);\n\n\tbuffer = gpio->out;\n\tif (value)\n\t\tbuffer |= BIT(offset);\n\telse\n\t\tbuffer &= ~BIT(offset);\n\n\tret = pca9570_write(gpio, buffer);\n\tif (ret)\n\t\tgoto out;\n\n\tgpio->out = buffer;\n\nout:\n\tmutex_unlock(&gpio->lock);\n}\n\nstatic int pca9570_probe(struct i2c_client *client)\n{\n\tstruct pca9570 *gpio;\n\n\tgpio = devm_kzalloc(&client->dev, sizeof(*gpio), GFP_KERNEL);\n\tif (!gpio)\n\t\treturn -ENOMEM;\n\n\tgpio->chip.label = client->name;\n\tgpio->chip.parent = &client->dev;\n\tgpio->chip.owner = THIS_MODULE;\n\tgpio->chip.get_direction = pca9570_get_direction;\n\tgpio->chip.get = pca9570_get;\n\tgpio->chip.set = pca9570_set;\n\tgpio->chip.base = -1;\n\tgpio->chip_data = device_get_match_data(&client->dev);\n\tgpio->chip.ngpio = gpio->chip_data->ngpio;\n\tgpio->chip.can_sleep = true;\n\n\tmutex_init(&gpio->lock);\n\n\t \n\tpca9570_read(gpio, &gpio->out);\n\n\ti2c_set_clientdata(client, gpio);\n\n\treturn devm_gpiochip_add_data(&client->dev, &gpio->chip, gpio);\n}\n\nstatic const struct pca9570_chip_data pca9570_gpio = {\n\t.ngpio = 4,\n};\n\nstatic const struct pca9570_chip_data pca9571_gpio = {\n\t.ngpio = 8,\n};\n\nstatic const struct pca9570_chip_data slg7xl45106_gpio = {\n\t.ngpio = 8,\n\t.command = SLG7XL45106_GPO_REG,\n};\n\nstatic const struct i2c_device_id pca9570_id_table[] = {\n\t{ \"pca9570\", (kernel_ulong_t)&pca9570_gpio},\n\t{ \"pca9571\", (kernel_ulong_t)&pca9571_gpio },\n\t{ \"slg7xl45106\", (kernel_ulong_t)&slg7xl45106_gpio },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, pca9570_id_table);\n\nstatic const struct of_device_id pca9570_of_match_table[] = {\n\t{ .compatible = \"dlg,slg7xl45106\", .data = &slg7xl45106_gpio},\n\t{ .compatible = \"nxp,pca9570\", .data = &pca9570_gpio },\n\t{ .compatible = \"nxp,pca9571\", .data = &pca9571_gpio },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pca9570_of_match_table);\n\nstatic struct i2c_driver pca9570_driver = {\n\t.driver = {\n\t\t.name = \"pca9570\",\n\t\t.of_match_table = pca9570_of_match_table,\n\t},\n\t.probe = pca9570_probe,\n\t.id_table = pca9570_id_table,\n};\nmodule_i2c_driver(pca9570_driver);\n\nMODULE_AUTHOR(\"Sungbo Eo <mans0n@gorani.run>\");\nMODULE_DESCRIPTION(\"GPIO expander driver for PCA9570\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}