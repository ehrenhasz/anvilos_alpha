{
  "module_name": "gpio-rcar.c",
  "hash_id": "c0818ebd1ea27768bc5b686e15b137afdb798136f4c45a041fb8751d07e4b219",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-rcar.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gpio_rcar_bank_info {\n\tu32 iointsel;\n\tu32 inoutsel;\n\tu32 outdt;\n\tu32 posneg;\n\tu32 edglevel;\n\tu32 bothedge;\n\tu32 intmsk;\n};\n\nstruct gpio_rcar_info {\n\tbool has_outdtsel;\n\tbool has_both_edge_trigger;\n\tbool has_always_in;\n\tbool has_inen;\n};\n\nstruct gpio_rcar_priv {\n\tvoid __iomem *base;\n\tspinlock_t lock;\n\tstruct device *dev;\n\tstruct gpio_chip gpio_chip;\n\tunsigned int irq_parent;\n\tatomic_t wakeup_path;\n\tstruct gpio_rcar_info info;\n\tstruct gpio_rcar_bank_info bank_info;\n};\n\n#define IOINTSEL\t0x00\t \n#define INOUTSEL\t0x04\t \n#define OUTDT\t\t0x08\t \n#define INDT\t\t0x0c\t \n#define INTDT\t\t0x10\t \n#define INTCLR\t\t0x14\t \n#define INTMSK\t\t0x18\t \n#define MSKCLR\t\t0x1c\t \n#define POSNEG\t\t0x20\t \n#define EDGLEVEL\t0x24\t \n#define FILONOFF\t0x28\t \n#define OUTDTSEL\t0x40\t \n#define BOTHEDGE\t0x4c\t \n#define INEN\t\t0x50\t \n\n#define RCAR_MAX_GPIO_PER_BANK\t\t32\n\nstatic inline u32 gpio_rcar_read(struct gpio_rcar_priv *p, int offs)\n{\n\treturn ioread32(p->base + offs);\n}\n\nstatic inline void gpio_rcar_write(struct gpio_rcar_priv *p, int offs,\n\t\t\t\t   u32 value)\n{\n\tiowrite32(value, p->base + offs);\n}\n\nstatic void gpio_rcar_modify_bit(struct gpio_rcar_priv *p, int offs,\n\t\t\t\t int bit, bool value)\n{\n\tu32 tmp = gpio_rcar_read(p, offs);\n\n\tif (value)\n\t\ttmp |= BIT(bit);\n\telse\n\t\ttmp &= ~BIT(bit);\n\n\tgpio_rcar_write(p, offs, tmp);\n}\n\nstatic void gpio_rcar_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_rcar_priv *p = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tgpio_rcar_write(p, INTMSK, ~BIT(hwirq));\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void gpio_rcar_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_rcar_priv *p = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tgpiochip_enable_irq(gc, hwirq);\n\tgpio_rcar_write(p, MSKCLR, BIT(hwirq));\n}\n\nstatic void gpio_rcar_config_interrupt_input_mode(struct gpio_rcar_priv *p,\n\t\t\t\t\t\t  unsigned int hwirq,\n\t\t\t\t\t\t  bool active_high_rising_edge,\n\t\t\t\t\t\t  bool level_trigger,\n\t\t\t\t\t\t  bool both)\n{\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(&p->lock, flags);\n\n\t \n\tgpio_rcar_modify_bit(p, POSNEG, hwirq, !active_high_rising_edge);\n\n\t \n\tgpio_rcar_modify_bit(p, EDGLEVEL, hwirq, !level_trigger);\n\n\t \n\tif (p->info.has_both_edge_trigger)\n\t\tgpio_rcar_modify_bit(p, BOTHEDGE, hwirq, both);\n\n\t \n\tgpio_rcar_modify_bit(p, IOINTSEL, hwirq, true);\n\n\t \n\tif (!level_trigger)\n\t\tgpio_rcar_write(p, INTCLR, BIT(hwirq));\n\n\tspin_unlock_irqrestore(&p->lock, flags);\n}\n\nstatic int gpio_rcar_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_rcar_priv *p = gpiochip_get_data(gc);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\n\tdev_dbg(p->dev, \"sense irq = %d, type = %d\\n\", hwirq, type);\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tgpio_rcar_config_interrupt_input_mode(p, hwirq, true, true,\n\t\t\t\t\t\t      false);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tgpio_rcar_config_interrupt_input_mode(p, hwirq, false, true,\n\t\t\t\t\t\t      false);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tgpio_rcar_config_interrupt_input_mode(p, hwirq, true, false,\n\t\t\t\t\t\t      false);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tgpio_rcar_config_interrupt_input_mode(p, hwirq, false, false,\n\t\t\t\t\t\t      false);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tif (!p->info.has_both_edge_trigger)\n\t\t\treturn -EINVAL;\n\t\tgpio_rcar_config_interrupt_input_mode(p, hwirq, true, false,\n\t\t\t\t\t\t      true);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int gpio_rcar_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct gpio_rcar_priv *p = gpiochip_get_data(gc);\n\tint error;\n\n\tif (p->irq_parent) {\n\t\terror = irq_set_irq_wake(p->irq_parent, on);\n\t\tif (error) {\n\t\t\tdev_dbg(p->dev, \"irq %u doesn't support irq_set_wake\\n\",\n\t\t\t\tp->irq_parent);\n\t\t\tp->irq_parent = 0;\n\t\t}\n\t}\n\n\tif (on)\n\t\tatomic_inc(&p->wakeup_path);\n\telse\n\t\tatomic_dec(&p->wakeup_path);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip gpio_rcar_irq_chip = {\n\t.name\t\t= \"gpio-rcar\",\n\t.irq_mask\t= gpio_rcar_irq_disable,\n\t.irq_unmask\t= gpio_rcar_irq_enable,\n\t.irq_set_type\t= gpio_rcar_irq_set_type,\n\t.irq_set_wake\t= gpio_rcar_irq_set_wake,\n\t.flags\t\t= IRQCHIP_IMMUTABLE | IRQCHIP_SET_TYPE_MASKED |\n\t\t\t  IRQCHIP_MASK_ON_SUSPEND,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic irqreturn_t gpio_rcar_irq_handler(int irq, void *dev_id)\n{\n\tstruct gpio_rcar_priv *p = dev_id;\n\tu32 pending;\n\tunsigned int offset, irqs_handled = 0;\n\n\twhile ((pending = gpio_rcar_read(p, INTDT) &\n\t\t\t  gpio_rcar_read(p, INTMSK))) {\n\t\toffset = __ffs(pending);\n\t\tgpio_rcar_write(p, INTCLR, BIT(offset));\n\t\tgeneric_handle_domain_irq(p->gpio_chip.irq.domain,\n\t\t\t\t\t  offset);\n\t\tirqs_handled++;\n\t}\n\n\treturn irqs_handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic void gpio_rcar_config_general_input_output_mode(struct gpio_chip *chip,\n\t\t\t\t\t\t       unsigned int gpio,\n\t\t\t\t\t\t       bool output)\n{\n\tstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(&p->lock, flags);\n\n\t \n\tgpio_rcar_modify_bit(p, POSNEG, gpio, false);\n\n\t \n\tgpio_rcar_modify_bit(p, IOINTSEL, gpio, false);\n\n\t \n\tgpio_rcar_modify_bit(p, INOUTSEL, gpio, output);\n\n\t \n\tif (p->info.has_outdtsel && output)\n\t\tgpio_rcar_modify_bit(p, OUTDTSEL, gpio, false);\n\n\tspin_unlock_irqrestore(&p->lock, flags);\n}\n\nstatic int gpio_rcar_request(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\n\tint error;\n\n\terror = pm_runtime_get_sync(p->dev);\n\tif (error < 0) {\n\t\tpm_runtime_put(p->dev);\n\t\treturn error;\n\t}\n\n\terror = pinctrl_gpio_request(chip->base + offset);\n\tif (error)\n\t\tpm_runtime_put(p->dev);\n\n\treturn error;\n}\n\nstatic void gpio_rcar_free(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\n\n\tpinctrl_gpio_free(chip->base + offset);\n\n\t \n\tgpio_rcar_config_general_input_output_mode(chip, offset, false);\n\n\tpm_runtime_put(p->dev);\n}\n\nstatic int gpio_rcar_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\n\n\tif (gpio_rcar_read(p, INOUTSEL) & BIT(offset))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int gpio_rcar_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tgpio_rcar_config_general_input_output_mode(chip, offset, false);\n\treturn 0;\n}\n\nstatic int gpio_rcar_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\n\tu32 bit = BIT(offset);\n\n\t \n\tif (!p->info.has_always_in && (gpio_rcar_read(p, INOUTSEL) & bit))\n\t\treturn !!(gpio_rcar_read(p, OUTDT) & bit);\n\telse\n\t\treturn !!(gpio_rcar_read(p, INDT) & bit);\n}\n\nstatic int gpio_rcar_get_multiple(struct gpio_chip *chip, unsigned long *mask,\n\t\t\t\t  unsigned long *bits)\n{\n\tstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\n\tu32 bankmask, outputs, m, val = 0;\n\tunsigned long flags;\n\n\tbankmask = mask[0] & GENMASK(chip->ngpio - 1, 0);\n\tif (chip->valid_mask)\n\t\tbankmask &= chip->valid_mask[0];\n\n\tif (!bankmask)\n\t\treturn 0;\n\n\tif (p->info.has_always_in) {\n\t\tbits[0] = gpio_rcar_read(p, INDT) & bankmask;\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&p->lock, flags);\n\toutputs = gpio_rcar_read(p, INOUTSEL);\n\tm = outputs & bankmask;\n\tif (m)\n\t\tval |= gpio_rcar_read(p, OUTDT) & m;\n\n\tm = ~outputs & bankmask;\n\tif (m)\n\t\tval |= gpio_rcar_read(p, INDT) & m;\n\tspin_unlock_irqrestore(&p->lock, flags);\n\n\tbits[0] = val;\n\treturn 0;\n}\n\nstatic void gpio_rcar_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&p->lock, flags);\n\tgpio_rcar_modify_bit(p, OUTDT, offset, value);\n\tspin_unlock_irqrestore(&p->lock, flags);\n}\n\nstatic void gpio_rcar_set_multiple(struct gpio_chip *chip, unsigned long *mask,\n\t\t\t\t   unsigned long *bits)\n{\n\tstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu32 val, bankmask;\n\n\tbankmask = mask[0] & GENMASK(chip->ngpio - 1, 0);\n\tif (chip->valid_mask)\n\t\tbankmask &= chip->valid_mask[0];\n\n\tif (!bankmask)\n\t\treturn;\n\n\tspin_lock_irqsave(&p->lock, flags);\n\tval = gpio_rcar_read(p, OUTDT);\n\tval &= ~bankmask;\n\tval |= (bankmask & bits[0]);\n\tgpio_rcar_write(p, OUTDT, val);\n\tspin_unlock_irqrestore(&p->lock, flags);\n}\n\nstatic int gpio_rcar_direction_output(struct gpio_chip *chip, unsigned offset,\n\t\t\t\t      int value)\n{\n\t \n\tgpio_rcar_set(chip, offset, value);\n\tgpio_rcar_config_general_input_output_mode(chip, offset, true);\n\treturn 0;\n}\n\nstatic const struct gpio_rcar_info gpio_rcar_info_gen1 = {\n\t.has_outdtsel = false,\n\t.has_both_edge_trigger = false,\n\t.has_always_in = false,\n\t.has_inen = false,\n};\n\nstatic const struct gpio_rcar_info gpio_rcar_info_gen2 = {\n\t.has_outdtsel = true,\n\t.has_both_edge_trigger = true,\n\t.has_always_in = false,\n\t.has_inen = false,\n};\n\nstatic const struct gpio_rcar_info gpio_rcar_info_gen3 = {\n\t.has_outdtsel = true,\n\t.has_both_edge_trigger = true,\n\t.has_always_in = true,\n\t.has_inen = false,\n};\n\nstatic const struct gpio_rcar_info gpio_rcar_info_gen4 = {\n\t.has_outdtsel = true,\n\t.has_both_edge_trigger = true,\n\t.has_always_in = true,\n\t.has_inen = true,\n};\n\nstatic const struct of_device_id gpio_rcar_of_table[] = {\n\t{\n\t\t.compatible = \"renesas,gpio-r8a779a0\",\n\t\t.data = &gpio_rcar_info_gen4,\n\t}, {\n\t\t.compatible = \"renesas,rcar-gen1-gpio\",\n\t\t.data = &gpio_rcar_info_gen1,\n\t}, {\n\t\t.compatible = \"renesas,rcar-gen2-gpio\",\n\t\t.data = &gpio_rcar_info_gen2,\n\t}, {\n\t\t.compatible = \"renesas,rcar-gen3-gpio\",\n\t\t.data = &gpio_rcar_info_gen3,\n\t}, {\n\t\t.compatible = \"renesas,rcar-gen4-gpio\",\n\t\t.data = &gpio_rcar_info_gen4,\n\t}, {\n\t\t.compatible = \"renesas,gpio-rcar\",\n\t\t.data = &gpio_rcar_info_gen1,\n\t}, {\n\t\t \n\t},\n};\n\nMODULE_DEVICE_TABLE(of, gpio_rcar_of_table);\n\nstatic int gpio_rcar_parse_dt(struct gpio_rcar_priv *p, unsigned int *npins)\n{\n\tstruct device_node *np = p->dev->of_node;\n\tconst struct gpio_rcar_info *info;\n\tstruct of_phandle_args args;\n\tint ret;\n\n\tinfo = of_device_get_match_data(p->dev);\n\tp->info = *info;\n\n\tret = of_parse_phandle_with_fixed_args(np, \"gpio-ranges\", 3, 0, &args);\n\t*npins = ret == 0 ? args.args[2] : RCAR_MAX_GPIO_PER_BANK;\n\n\tif (*npins == 0 || *npins > RCAR_MAX_GPIO_PER_BANK) {\n\t\tdev_warn(p->dev, \"Invalid number of gpio lines %u, using %u\\n\",\n\t\t\t *npins, RCAR_MAX_GPIO_PER_BANK);\n\t\t*npins = RCAR_MAX_GPIO_PER_BANK;\n\t}\n\n\treturn 0;\n}\n\nstatic void gpio_rcar_enable_inputs(struct gpio_rcar_priv *p)\n{\n\tu32 mask = GENMASK(p->gpio_chip.ngpio - 1, 0);\n\n\t \n\tif (p->gpio_chip.valid_mask)\n\t\tmask &= p->gpio_chip.valid_mask[0];\n\tif (mask)\n\t\tgpio_rcar_write(p, INEN, gpio_rcar_read(p, INEN) | mask);\n}\n\nstatic int gpio_rcar_probe(struct platform_device *pdev)\n{\n\tstruct gpio_rcar_priv *p;\n\tstruct gpio_chip *gpio_chip;\n\tstruct gpio_irq_chip *girq;\n\tstruct device *dev = &pdev->dev;\n\tconst char *name = dev_name(dev);\n\tunsigned int npins;\n\tint ret;\n\n\tp = devm_kzalloc(dev, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->dev = dev;\n\tspin_lock_init(&p->lock);\n\n\t \n\tret = gpio_rcar_parse_dt(p, &npins);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, p);\n\n\tpm_runtime_enable(dev);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err0;\n\tp->irq_parent = ret;\n\n\tp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(p->base)) {\n\t\tret = PTR_ERR(p->base);\n\t\tgoto err0;\n\t}\n\n\tgpio_chip = &p->gpio_chip;\n\tgpio_chip->request = gpio_rcar_request;\n\tgpio_chip->free = gpio_rcar_free;\n\tgpio_chip->get_direction = gpio_rcar_get_direction;\n\tgpio_chip->direction_input = gpio_rcar_direction_input;\n\tgpio_chip->get = gpio_rcar_get;\n\tgpio_chip->get_multiple = gpio_rcar_get_multiple;\n\tgpio_chip->direction_output = gpio_rcar_direction_output;\n\tgpio_chip->set = gpio_rcar_set;\n\tgpio_chip->set_multiple = gpio_rcar_set_multiple;\n\tgpio_chip->label = name;\n\tgpio_chip->parent = dev;\n\tgpio_chip->owner = THIS_MODULE;\n\tgpio_chip->base = -1;\n\tgpio_chip->ngpio = npins;\n\n\tgirq = &gpio_chip->irq;\n\tgpio_irq_chip_set_chip(girq, &gpio_rcar_irq_chip);\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_level_irq;\n\n\tret = gpiochip_add_data(gpio_chip, p);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add GPIO controller\\n\");\n\t\tgoto err0;\n\t}\n\n\tirq_domain_set_pm_device(gpio_chip->irq.domain, dev);\n\tret = devm_request_irq(dev, p->irq_parent, gpio_rcar_irq_handler,\n\t\t\t       IRQF_SHARED, name, p);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request IRQ\\n\");\n\t\tgoto err1;\n\t}\n\n\tif (p->info.has_inen) {\n\t\tpm_runtime_get_sync(dev);\n\t\tgpio_rcar_enable_inputs(p);\n\t\tpm_runtime_put(dev);\n\t}\n\n\tdev_info(dev, \"driving %d GPIOs\\n\", npins);\n\n\treturn 0;\n\nerr1:\n\tgpiochip_remove(gpio_chip);\nerr0:\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic int gpio_rcar_remove(struct platform_device *pdev)\n{\n\tstruct gpio_rcar_priv *p = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&p->gpio_chip);\n\n\tpm_runtime_disable(&pdev->dev);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int gpio_rcar_suspend(struct device *dev)\n{\n\tstruct gpio_rcar_priv *p = dev_get_drvdata(dev);\n\n\tp->bank_info.iointsel = gpio_rcar_read(p, IOINTSEL);\n\tp->bank_info.inoutsel = gpio_rcar_read(p, INOUTSEL);\n\tp->bank_info.outdt = gpio_rcar_read(p, OUTDT);\n\tp->bank_info.intmsk = gpio_rcar_read(p, INTMSK);\n\tp->bank_info.posneg = gpio_rcar_read(p, POSNEG);\n\tp->bank_info.edglevel = gpio_rcar_read(p, EDGLEVEL);\n\tif (p->info.has_both_edge_trigger)\n\t\tp->bank_info.bothedge = gpio_rcar_read(p, BOTHEDGE);\n\n\tif (atomic_read(&p->wakeup_path))\n\t\tdevice_set_wakeup_path(dev);\n\n\treturn 0;\n}\n\nstatic int gpio_rcar_resume(struct device *dev)\n{\n\tstruct gpio_rcar_priv *p = dev_get_drvdata(dev);\n\tunsigned int offset;\n\tu32 mask;\n\n\tfor (offset = 0; offset < p->gpio_chip.ngpio; offset++) {\n\t\tif (!gpiochip_line_is_valid(&p->gpio_chip, offset))\n\t\t\tcontinue;\n\n\t\tmask = BIT(offset);\n\t\t \n\t\tif (!(p->bank_info.iointsel & mask)) {\n\t\t\tif (p->bank_info.inoutsel & mask)\n\t\t\t\tgpio_rcar_direction_output(\n\t\t\t\t\t&p->gpio_chip, offset,\n\t\t\t\t\t!!(p->bank_info.outdt & mask));\n\t\t\telse\n\t\t\t\tgpio_rcar_direction_input(&p->gpio_chip,\n\t\t\t\t\t\t\t  offset);\n\t\t} else {\n\t\t\t \n\t\t\tgpio_rcar_config_interrupt_input_mode(\n\t\t\t\tp,\n\t\t\t\toffset,\n\t\t\t\t!(p->bank_info.posneg & mask),\n\t\t\t\t!(p->bank_info.edglevel & mask),\n\t\t\t\t!!(p->bank_info.bothedge & mask));\n\n\t\t\tif (p->bank_info.intmsk & mask)\n\t\t\t\tgpio_rcar_write(p, MSKCLR, mask);\n\t\t}\n\t}\n\n\tif (p->info.has_inen)\n\t\tgpio_rcar_enable_inputs(p);\n\n\treturn 0;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(gpio_rcar_pm_ops, gpio_rcar_suspend, gpio_rcar_resume);\n\nstatic struct platform_driver gpio_rcar_device_driver = {\n\t.probe\t\t= gpio_rcar_probe,\n\t.remove\t\t= gpio_rcar_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"gpio_rcar\",\n\t\t.pm     = &gpio_rcar_pm_ops,\n\t\t.of_match_table = gpio_rcar_of_table,\n\t}\n};\n\nmodule_platform_driver(gpio_rcar_device_driver);\n\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_DESCRIPTION(\"Renesas R-Car GPIO Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}