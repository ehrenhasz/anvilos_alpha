{
  "module_name": "gpio-mlxbf3.c",
  "hash_id": "26627cef488fde6f271b78aa666875435b79298718de6e855a4040aed5ade45d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-mlxbf3.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n \n#define MLXBF3_GPIO_MAX_PINS_PER_BLOCK 32\n#define MLXBF3_GPIO_MAX_PINS_BLOCK0    32\n#define MLXBF3_GPIO_MAX_PINS_BLOCK1    24\n\n \n#define MLXBF_GPIO_FW_OUTPUT_ENABLE_SET\t  0x00\n#define MLXBF_GPIO_FW_DATA_OUT_SET        0x04\n\n#define MLXBF_GPIO_FW_OUTPUT_ENABLE_CLEAR 0x00\n#define MLXBF_GPIO_FW_DATA_OUT_CLEAR      0x04\n\n#define MLXBF_GPIO_CAUSE_RISE_EN          0x00\n#define MLXBF_GPIO_CAUSE_FALL_EN          0x04\n#define MLXBF_GPIO_READ_DATA_IN           0x08\n\n#define MLXBF_GPIO_CAUSE_OR_CAUSE_EVTEN0  0x00\n#define MLXBF_GPIO_CAUSE_OR_EVTEN0        0x14\n#define MLXBF_GPIO_CAUSE_OR_CLRCAUSE      0x18\n\nstruct mlxbf3_gpio_context {\n\tstruct gpio_chip gc;\n\n\t \n\tvoid __iomem *gpio_set_io;\n\tvoid __iomem *gpio_clr_io;\n\tvoid __iomem *gpio_io;\n\n\t \n\tvoid __iomem *gpio_cause_io;\n};\n\nstatic void mlxbf3_gpio_irq_enable(struct irq_data *irqd)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct mlxbf3_gpio_context *gs = gpiochip_get_data(gc);\n\tirq_hw_number_t offset = irqd_to_hwirq(irqd);\n\tunsigned long flags;\n\tu32 val;\n\n\tgpiochip_enable_irq(gc, offset);\n\n\traw_spin_lock_irqsave(&gs->gc.bgpio_lock, flags);\n\twritel(BIT(offset), gs->gpio_cause_io + MLXBF_GPIO_CAUSE_OR_CLRCAUSE);\n\n\tval = readl(gs->gpio_cause_io + MLXBF_GPIO_CAUSE_OR_EVTEN0);\n\tval |= BIT(offset);\n\twritel(val, gs->gpio_cause_io + MLXBF_GPIO_CAUSE_OR_EVTEN0);\n\traw_spin_unlock_irqrestore(&gs->gc.bgpio_lock, flags);\n}\n\nstatic void mlxbf3_gpio_irq_disable(struct irq_data *irqd)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct mlxbf3_gpio_context *gs = gpiochip_get_data(gc);\n\tirq_hw_number_t offset = irqd_to_hwirq(irqd);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&gs->gc.bgpio_lock, flags);\n\tval = readl(gs->gpio_cause_io + MLXBF_GPIO_CAUSE_OR_EVTEN0);\n\tval &= ~BIT(offset);\n\twritel(val, gs->gpio_cause_io + MLXBF_GPIO_CAUSE_OR_EVTEN0);\n\traw_spin_unlock_irqrestore(&gs->gc.bgpio_lock, flags);\n\n\tgpiochip_disable_irq(gc, offset);\n}\n\nstatic irqreturn_t mlxbf3_gpio_irq_handler(int irq, void *ptr)\n{\n\tstruct mlxbf3_gpio_context *gs = ptr;\n\tstruct gpio_chip *gc = &gs->gc;\n\tunsigned long pending;\n\tu32 level;\n\n\tpending = readl(gs->gpio_cause_io + MLXBF_GPIO_CAUSE_OR_CAUSE_EVTEN0);\n\twritel(pending, gs->gpio_cause_io + MLXBF_GPIO_CAUSE_OR_CLRCAUSE);\n\n\tfor_each_set_bit(level, &pending, gc->ngpio)\n\t\tgeneric_handle_domain_irq(gc->irq.domain, level);\n\n\treturn IRQ_RETVAL(pending);\n}\n\nstatic int\nmlxbf3_gpio_irq_set_type(struct irq_data *irqd, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\n\tstruct mlxbf3_gpio_context *gs = gpiochip_get_data(gc);\n\tirq_hw_number_t offset = irqd_to_hwirq(irqd);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&gs->gc.bgpio_lock, flags);\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tval = readl(gs->gpio_io + MLXBF_GPIO_CAUSE_FALL_EN);\n\t\tval |= BIT(offset);\n\t\twritel(val, gs->gpio_io + MLXBF_GPIO_CAUSE_FALL_EN);\n\t\tval = readl(gs->gpio_io + MLXBF_GPIO_CAUSE_RISE_EN);\n\t\tval |= BIT(offset);\n\t\twritel(val, gs->gpio_io + MLXBF_GPIO_CAUSE_RISE_EN);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tval = readl(gs->gpio_io + MLXBF_GPIO_CAUSE_RISE_EN);\n\t\tval |= BIT(offset);\n\t\twritel(val, gs->gpio_io + MLXBF_GPIO_CAUSE_RISE_EN);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tval = readl(gs->gpio_io + MLXBF_GPIO_CAUSE_FALL_EN);\n\t\tval |= BIT(offset);\n\t\twritel(val, gs->gpio_io + MLXBF_GPIO_CAUSE_FALL_EN);\n\t\tbreak;\n\tdefault:\n\t\traw_spin_unlock_irqrestore(&gs->gc.bgpio_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_unlock_irqrestore(&gs->gc.bgpio_lock, flags);\n\n\tirq_set_handler_locked(irqd, handle_edge_irq);\n\n\treturn 0;\n}\n\n \nstatic void mlxbf3_gpio_irq_ack(struct irq_data *data)\n{\n}\n\nstatic const struct irq_chip gpio_mlxbf3_irqchip = {\n\t.name = \"MLNXBF33\",\n\t.irq_ack = mlxbf3_gpio_irq_ack,\n\t.irq_set_type = mlxbf3_gpio_irq_set_type,\n\t.irq_enable = mlxbf3_gpio_irq_enable,\n\t.irq_disable = mlxbf3_gpio_irq_disable,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int mlxbf3_gpio_add_pin_ranges(struct gpio_chip *chip)\n{\n\tunsigned int id;\n\n\tswitch(chip->ngpio) {\n\tcase MLXBF3_GPIO_MAX_PINS_BLOCK0:\n\t\tid = 0;\n\t\tbreak;\n\tcase MLXBF3_GPIO_MAX_PINS_BLOCK1:\n\t\tid = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn gpiochip_add_pin_range(chip, \"MLNXBF34:00\",\n\t\t\tchip->base, id * MLXBF3_GPIO_MAX_PINS_PER_BLOCK,\n\t\t\tchip->ngpio);\n}\n\nstatic int mlxbf3_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mlxbf3_gpio_context *gs;\n\tstruct gpio_irq_chip *girq;\n\tstruct gpio_chip *gc;\n\tint ret, irq;\n\n\tgs = devm_kzalloc(dev, sizeof(*gs), GFP_KERNEL);\n\tif (!gs)\n\t\treturn -ENOMEM;\n\n\tgs->gpio_io = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gs->gpio_io))\n\t\treturn PTR_ERR(gs->gpio_io);\n\n\tgs->gpio_cause_io = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(gs->gpio_cause_io))\n\t\treturn PTR_ERR(gs->gpio_cause_io);\n\n\tgs->gpio_set_io = devm_platform_ioremap_resource(pdev, 2);\n\tif (IS_ERR(gs->gpio_set_io))\n\t\treturn PTR_ERR(gs->gpio_set_io);\n\n\tgs->gpio_clr_io = devm_platform_ioremap_resource(pdev, 3);\n\tif (IS_ERR(gs->gpio_clr_io))\n\t\treturn PTR_ERR(gs->gpio_clr_io);\n\tgc = &gs->gc;\n\n\tret = bgpio_init(gc, dev, 4,\n\t\t\tgs->gpio_io + MLXBF_GPIO_READ_DATA_IN,\n\t\t\tgs->gpio_set_io + MLXBF_GPIO_FW_DATA_OUT_SET,\n\t\t\tgs->gpio_clr_io + MLXBF_GPIO_FW_DATA_OUT_CLEAR,\n\t\t\tgs->gpio_set_io + MLXBF_GPIO_FW_OUTPUT_ENABLE_SET,\n\t\t\tgs->gpio_clr_io + MLXBF_GPIO_FW_OUTPUT_ENABLE_CLEAR, 0);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"%s: bgpio_init() failed\", __func__);\n\n\tgc->request = gpiochip_generic_request;\n\tgc->free = gpiochip_generic_free;\n\tgc->owner = THIS_MODULE;\n\tgc->add_pin_ranges = mlxbf3_gpio_add_pin_ranges;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq >= 0) {\n\t\tgirq = &gs->gc.irq;\n\t\tgpio_irq_chip_set_chip(girq, &gpio_mlxbf3_irqchip);\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\t \n\t\tgirq->num_parents = 0;\n\t\tgirq->parents = NULL;\n\t\tgirq->parent_handler = NULL;\n\t\tgirq->handler = handle_bad_irq;\n\n\t\t \n\t\tret = devm_request_irq(dev, irq, mlxbf3_gpio_irq_handler,\n\t\t\t\t       IRQF_SHARED, dev_name(dev), gs);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"failed to request IRQ\");\n\t}\n\n\tplatform_set_drvdata(pdev, gs);\n\n\tret = devm_gpiochip_add_data(dev, &gs->gc, gs);\n\tif (ret)\n\t\tdev_err_probe(dev, ret, \"Failed adding memory mapped gpiochip\\n\");\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id mlxbf3_gpio_acpi_match[] = {\n\t{ \"MLNXBF33\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, mlxbf3_gpio_acpi_match);\n\nstatic struct platform_driver mlxbf3_gpio_driver = {\n\t.driver = {\n\t\t.name = \"mlxbf3_gpio\",\n\t\t.acpi_match_table = mlxbf3_gpio_acpi_match,\n\t},\n\t.probe    = mlxbf3_gpio_probe,\n};\nmodule_platform_driver(mlxbf3_gpio_driver);\n\nMODULE_SOFTDEP(\"pre: pinctrl-mlxbf3\");\nMODULE_DESCRIPTION(\"NVIDIA BlueField-3 GPIO Driver\");\nMODULE_AUTHOR(\"Asmaa Mnebhi <asmaa@nvidia.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}