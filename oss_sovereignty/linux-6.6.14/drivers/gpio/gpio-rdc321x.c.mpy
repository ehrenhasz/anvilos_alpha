{
  "module_name": "gpio-rdc321x.c",
  "hash_id": "aefff028a001731304ba2c3e716591cc9bab6d9c12cb330041d126875818c354",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-rdc321x.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/gpio/driver.h>\n#include <linux/mfd/rdc321x.h>\n#include <linux/slab.h>\n\nstruct rdc321x_gpio {\n\tspinlock_t\t\tlock;\n\tstruct pci_dev\t\t*sb_pdev;\n\tu32\t\t\tdata_reg[2];\n\tint\t\t\treg1_ctrl_base;\n\tint\t\t\treg1_data_base;\n\tint\t\t\treg2_ctrl_base;\n\tint\t\t\treg2_data_base;\n\tstruct gpio_chip\tchip;\n};\n\n \nstatic int rdc_gpio_get_value(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct rdc321x_gpio *gpch;\n\tu32 value = 0;\n\tint reg;\n\n\tgpch = gpiochip_get_data(chip);\n\treg = gpio < 32 ? gpch->reg1_data_base : gpch->reg2_data_base;\n\n\tspin_lock(&gpch->lock);\n\tpci_write_config_dword(gpch->sb_pdev, reg,\n\t\t\t\t\tgpch->data_reg[gpio < 32 ? 0 : 1]);\n\tpci_read_config_dword(gpch->sb_pdev, reg, &value);\n\tspin_unlock(&gpch->lock);\n\n\treturn (1 << (gpio & 0x1f)) & value ? 1 : 0;\n}\n\nstatic void rdc_gpio_set_value_impl(struct gpio_chip *chip,\n\t\t\t\tunsigned gpio, int value)\n{\n\tstruct rdc321x_gpio *gpch;\n\tint reg = (gpio < 32) ? 0 : 1;\n\n\tgpch = gpiochip_get_data(chip);\n\n\tif (value)\n\t\tgpch->data_reg[reg] |= 1 << (gpio & 0x1f);\n\telse\n\t\tgpch->data_reg[reg] &= ~(1 << (gpio & 0x1f));\n\n\tpci_write_config_dword(gpch->sb_pdev,\n\t\t\treg ? gpch->reg2_data_base : gpch->reg1_data_base,\n\t\t\tgpch->data_reg[reg]);\n}\n\n \nstatic void rdc_gpio_set_value(struct gpio_chip *chip,\n\t\t\t\tunsigned gpio, int value)\n{\n\tstruct rdc321x_gpio *gpch;\n\n\tgpch = gpiochip_get_data(chip);\n\tspin_lock(&gpch->lock);\n\trdc_gpio_set_value_impl(chip, gpio, value);\n\tspin_unlock(&gpch->lock);\n}\n\nstatic int rdc_gpio_config(struct gpio_chip *chip,\n\t\t\t\tunsigned gpio, int value)\n{\n\tstruct rdc321x_gpio *gpch;\n\tint err;\n\tu32 reg;\n\n\tgpch = gpiochip_get_data(chip);\n\n\tspin_lock(&gpch->lock);\n\terr = pci_read_config_dword(gpch->sb_pdev, gpio < 32 ?\n\t\t\tgpch->reg1_ctrl_base : gpch->reg2_ctrl_base, &reg);\n\tif (err)\n\t\tgoto unlock;\n\n\treg |= 1 << (gpio & 0x1f);\n\n\terr = pci_write_config_dword(gpch->sb_pdev, gpio < 32 ?\n\t\t\tgpch->reg1_ctrl_base : gpch->reg2_ctrl_base, reg);\n\tif (err)\n\t\tgoto unlock;\n\n\trdc_gpio_set_value_impl(chip, gpio, value);\n\nunlock:\n\tspin_unlock(&gpch->lock);\n\n\treturn err;\n}\n\n \nstatic int rdc_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)\n{\n\treturn rdc_gpio_config(chip, gpio, 1);\n}\n\n \nstatic int rdc321x_gpio_probe(struct platform_device *pdev)\n{\n\tint err;\n\tstruct resource *r;\n\tstruct rdc321x_gpio *rdc321x_gpio_dev;\n\tstruct rdc321x_gpio_pdata *pdata;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"no platform data supplied\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trdc321x_gpio_dev = devm_kzalloc(&pdev->dev, sizeof(struct rdc321x_gpio),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!rdc321x_gpio_dev)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource_byname(pdev, IORESOURCE_IO, \"gpio-reg1\");\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"failed to get gpio-reg1 resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_init(&rdc321x_gpio_dev->lock);\n\trdc321x_gpio_dev->sb_pdev = pdata->sb_pdev;\n\trdc321x_gpio_dev->reg1_ctrl_base = r->start;\n\trdc321x_gpio_dev->reg1_data_base = r->start + 0x4;\n\n\tr = platform_get_resource_byname(pdev, IORESOURCE_IO, \"gpio-reg2\");\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"failed to get gpio-reg2 resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trdc321x_gpio_dev->reg2_ctrl_base = r->start;\n\trdc321x_gpio_dev->reg2_data_base = r->start + 0x4;\n\n\trdc321x_gpio_dev->chip.label = \"rdc321x-gpio\";\n\trdc321x_gpio_dev->chip.owner = THIS_MODULE;\n\trdc321x_gpio_dev->chip.direction_input = rdc_gpio_direction_input;\n\trdc321x_gpio_dev->chip.direction_output = rdc_gpio_config;\n\trdc321x_gpio_dev->chip.get = rdc_gpio_get_value;\n\trdc321x_gpio_dev->chip.set = rdc_gpio_set_value;\n\trdc321x_gpio_dev->chip.base = 0;\n\trdc321x_gpio_dev->chip.ngpio = pdata->max_gpios;\n\n\tplatform_set_drvdata(pdev, rdc321x_gpio_dev);\n\n\t \n\terr = pci_read_config_dword(rdc321x_gpio_dev->sb_pdev,\n\t\t\t\t\trdc321x_gpio_dev->reg1_data_base,\n\t\t\t\t\t&rdc321x_gpio_dev->data_reg[0]);\n\tif (err)\n\t\treturn err;\n\n\terr = pci_read_config_dword(rdc321x_gpio_dev->sb_pdev,\n\t\t\t\t\trdc321x_gpio_dev->reg2_data_base,\n\t\t\t\t\t&rdc321x_gpio_dev->data_reg[1]);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(&pdev->dev, \"registering %d GPIOs\\n\",\n\t\t\t\t\trdc321x_gpio_dev->chip.ngpio);\n\treturn devm_gpiochip_add_data(&pdev->dev, &rdc321x_gpio_dev->chip,\n\t\t\t\t      rdc321x_gpio_dev);\n}\n\nstatic struct platform_driver rdc321x_gpio_driver = {\n\t.driver.name\t= \"rdc321x-gpio\",\n\t.probe\t\t= rdc321x_gpio_probe,\n};\n\nmodule_platform_driver(rdc321x_gpio_driver);\n\nMODULE_AUTHOR(\"Florian Fainelli <florian@openwrt.org>\");\nMODULE_DESCRIPTION(\"RDC321x GPIO driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rdc321x-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}