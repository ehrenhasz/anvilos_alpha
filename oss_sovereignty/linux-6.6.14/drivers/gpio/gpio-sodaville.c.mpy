{
  "module_name": "gpio-sodaville.c",
  "hash_id": "fc57e71510668791eb0483a33dfd84766e9a093746c91f88e4cfae7cfd5ac3f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-sodaville.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/of_irq.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n\n#define DRV_NAME\t\t\"sdv_gpio\"\n#define SDV_NUM_PUB_GPIOS\t12\n#define PCI_DEVICE_ID_SDV_GPIO\t0x2e67\n#define GPIO_BAR\t\t0\n\n#define GPOUTR\t\t0x00\n#define GPOER\t\t0x04\n#define GPINR\t\t0x08\n\n#define GPSTR\t\t0x0c\n#define GPIT1R0\t\t0x10\n#define GPIO_INT\t0x14\n#define GPIT1R1\t\t0x18\n\n#define GPMUXCTL\t0x1c\n\nstruct sdv_gpio_chip_data {\n\tint irq_base;\n\tvoid __iomem *gpio_pub_base;\n\tstruct irq_domain *id;\n\tstruct irq_chip_generic *gc;\n\tstruct gpio_chip chip;\n};\n\nstatic int sdv_gpio_pub_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct sdv_gpio_chip_data *sd = gc->private;\n\tvoid __iomem *type_reg;\n\tu32 reg;\n\n\tif (d->hwirq < 8)\n\t\ttype_reg = sd->gpio_pub_base + GPIT1R0;\n\telse\n\t\ttype_reg = sd->gpio_pub_base + GPIT1R1;\n\n\treg = readl(type_reg);\n\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\treg &= ~BIT(4 * (d->hwirq % 8));\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\treg |= BIT(4 * (d->hwirq % 8));\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twritel(reg, type_reg);\n\treturn 0;\n}\n\nstatic irqreturn_t sdv_gpio_pub_irq_handler(int irq, void *data)\n{\n\tstruct sdv_gpio_chip_data *sd = data;\n\tunsigned long irq_stat = readl(sd->gpio_pub_base + GPSTR);\n\tint irq_bit;\n\n\tirq_stat &= readl(sd->gpio_pub_base + GPIO_INT);\n\tif (!irq_stat)\n\t\treturn IRQ_NONE;\n\n\tfor_each_set_bit(irq_bit, &irq_stat, 32)\n\t\tgeneric_handle_domain_irq(sd->id, irq_bit);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sdv_xlate(struct irq_domain *h, struct device_node *node,\n\t\tconst u32 *intspec, u32 intsize, irq_hw_number_t *out_hwirq,\n\t\tu32 *out_type)\n{\n\tu32 line, type;\n\n\tif (node != irq_domain_get_of_node(h))\n\t\treturn -EINVAL;\n\n\tif (intsize < 2)\n\t\treturn -EINVAL;\n\n\tline = *intspec;\n\t*out_hwirq = line;\n\n\tintspec++;\n\ttype = *intspec;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_LOW:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\t*out_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops irq_domain_sdv_ops = {\n\t.xlate = sdv_xlate,\n};\n\nstatic int sdv_register_irqsupport(struct sdv_gpio_chip_data *sd,\n\t\tstruct pci_dev *pdev)\n{\n\tstruct irq_chip_type *ct;\n\tint ret;\n\n\tsd->irq_base = devm_irq_alloc_descs(&pdev->dev, -1, 0,\n\t\t\t\t\t    SDV_NUM_PUB_GPIOS, -1);\n\tif (sd->irq_base < 0)\n\t\treturn sd->irq_base;\n\n\t \n\twritel(0, sd->gpio_pub_base + GPIO_INT);\n\twritel((1 << 11) - 1, sd->gpio_pub_base + GPSTR);\n\n\tret = devm_request_irq(&pdev->dev, pdev->irq,\n\t\t\t       sdv_gpio_pub_irq_handler, IRQF_SHARED,\n\t\t\t       \"sdv_gpio\", sd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsd->gc = devm_irq_alloc_generic_chip(&pdev->dev, \"sdv-gpio\", 1,\n\t\t\t\t\t     sd->irq_base,\n\t\t\t\t\t     sd->gpio_pub_base,\n\t\t\t\t\t     handle_fasteoi_irq);\n\tif (!sd->gc)\n\t\treturn -ENOMEM;\n\n\tsd->gc->private = sd;\n\tct = sd->gc->chip_types;\n\tct->type = IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW;\n\tct->regs.eoi = GPSTR;\n\tct->regs.mask = GPIO_INT;\n\tct->chip.irq_mask = irq_gc_mask_clr_bit;\n\tct->chip.irq_unmask = irq_gc_mask_set_bit;\n\tct->chip.irq_eoi = irq_gc_eoi;\n\tct->chip.irq_set_type = sdv_gpio_pub_set_type;\n\n\tirq_setup_generic_chip(sd->gc, IRQ_MSK(SDV_NUM_PUB_GPIOS),\n\t\t\tIRQ_GC_INIT_MASK_CACHE, IRQ_NOREQUEST,\n\t\t\tIRQ_LEVEL | IRQ_NOPROBE);\n\n\tsd->id = irq_domain_add_legacy(pdev->dev.of_node, SDV_NUM_PUB_GPIOS,\n\t\t\t\tsd->irq_base, 0, &irq_domain_sdv_ops, sd);\n\tif (!sd->id)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int sdv_gpio_probe(struct pci_dev *pdev,\n\t\t\t\t\tconst struct pci_device_id *pci_id)\n{\n\tstruct sdv_gpio_chip_data *sd;\n\tint ret;\n\tu32 mux_val;\n\n\tsd = devm_kzalloc(&pdev->dev, sizeof(*sd), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't enable device.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pcim_iomap_regions(pdev, 1 << GPIO_BAR, DRV_NAME);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't alloc PCI BAR #%d\\n\", GPIO_BAR);\n\t\treturn ret;\n\t}\n\n\tsd->gpio_pub_base = pcim_iomap_table(pdev)[GPIO_BAR];\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"intel,muxctl\", &mux_val);\n\tif (!ret)\n\t\twritel(mux_val, sd->gpio_pub_base + GPMUXCTL);\n\n\tret = bgpio_init(&sd->chip, &pdev->dev, 4,\n\t\t\tsd->gpio_pub_base + GPINR, sd->gpio_pub_base + GPOUTR,\n\t\t\tNULL, sd->gpio_pub_base + GPOER, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tsd->chip.ngpio = SDV_NUM_PUB_GPIOS;\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &sd->chip, sd);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"gpiochip_add() failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sdv_register_irqsupport(sd, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_drvdata(pdev, sd);\n\tdev_info(&pdev->dev, \"Sodaville GPIO driver registered.\\n\");\n\treturn 0;\n}\n\nstatic const struct pci_device_id sdv_gpio_pci_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_SDV_GPIO) },\n\t{ 0, },\n};\n\nstatic struct pci_driver sdv_gpio_driver = {\n\t.driver = {\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.name = DRV_NAME,\n\t.id_table = sdv_gpio_pci_ids,\n\t.probe = sdv_gpio_probe,\n};\nbuiltin_pci_driver(sdv_gpio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}