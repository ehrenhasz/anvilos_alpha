{
  "module_name": "gpio-cadence.c",
  "hash_id": "9535d09b11e9a891a731b1d2f414cc81e4f20e60843ed6012c5420abba6c93ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpio/gpio-cadence.c",
  "human_readable_source": "\n\n \n\n#include <linux/gpio/driver.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#define CDNS_GPIO_BYPASS_MODE\t\t0x00\n#define CDNS_GPIO_DIRECTION_MODE\t0x04\n#define CDNS_GPIO_OUTPUT_EN\t\t0x08\n#define CDNS_GPIO_OUTPUT_VALUE\t\t0x0c\n#define CDNS_GPIO_INPUT_VALUE\t\t0x10\n#define CDNS_GPIO_IRQ_MASK\t\t0x14\n#define CDNS_GPIO_IRQ_EN\t\t0x18\n#define CDNS_GPIO_IRQ_DIS\t\t0x1c\n#define CDNS_GPIO_IRQ_STATUS\t\t0x20\n#define CDNS_GPIO_IRQ_TYPE\t\t0x24\n#define CDNS_GPIO_IRQ_VALUE\t\t0x28\n#define CDNS_GPIO_IRQ_ANY_EDGE\t\t0x2c\n\nstruct cdns_gpio_chip {\n\tstruct gpio_chip gc;\n\tstruct clk *pclk;\n\tvoid __iomem *regs;\n\tu32 bypass_orig;\n};\n\nstatic int cdns_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct cdns_gpio_chip *cgpio = gpiochip_get_data(chip);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->bgpio_lock, flags);\n\n\tiowrite32(ioread32(cgpio->regs + CDNS_GPIO_BYPASS_MODE) & ~BIT(offset),\n\t\t  cgpio->regs + CDNS_GPIO_BYPASS_MODE);\n\n\traw_spin_unlock_irqrestore(&chip->bgpio_lock, flags);\n\treturn 0;\n}\n\nstatic void cdns_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct cdns_gpio_chip *cgpio = gpiochip_get_data(chip);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->bgpio_lock, flags);\n\n\tiowrite32(ioread32(cgpio->regs + CDNS_GPIO_BYPASS_MODE) |\n\t\t  (BIT(offset) & cgpio->bypass_orig),\n\t\t  cgpio->regs + CDNS_GPIO_BYPASS_MODE);\n\n\traw_spin_unlock_irqrestore(&chip->bgpio_lock, flags);\n}\n\nstatic void cdns_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct cdns_gpio_chip *cgpio = gpiochip_get_data(chip);\n\n\tiowrite32(BIT(d->hwirq), cgpio->regs + CDNS_GPIO_IRQ_DIS);\n\tgpiochip_disable_irq(chip, irqd_to_hwirq(d));\n}\n\nstatic void cdns_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct cdns_gpio_chip *cgpio = gpiochip_get_data(chip);\n\n\tgpiochip_enable_irq(chip, irqd_to_hwirq(d));\n\tiowrite32(BIT(d->hwirq), cgpio->regs + CDNS_GPIO_IRQ_EN);\n}\n\nstatic int cdns_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct cdns_gpio_chip *cgpio = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu32 int_value;\n\tu32 int_type;\n\tu32 mask = BIT(d->hwirq);\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&chip->bgpio_lock, flags);\n\n\tint_value = ioread32(cgpio->regs + CDNS_GPIO_IRQ_VALUE) & ~mask;\n\tint_type = ioread32(cgpio->regs + CDNS_GPIO_IRQ_TYPE) & ~mask;\n\n\t \n\n\tif (type == IRQ_TYPE_LEVEL_HIGH) {\n\t\tint_type |= mask;\n\t\tint_value |= mask;\n\t} else if (type == IRQ_TYPE_LEVEL_LOW) {\n\t\tint_type |= mask;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err_irq_type;\n\t}\n\n\tiowrite32(int_value, cgpio->regs + CDNS_GPIO_IRQ_VALUE);\n\tiowrite32(int_type, cgpio->regs + CDNS_GPIO_IRQ_TYPE);\n\nerr_irq_type:\n\traw_spin_unlock_irqrestore(&chip->bgpio_lock, flags);\n\treturn ret;\n}\n\nstatic void cdns_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *chip = irq_desc_get_handler_data(desc);\n\tstruct cdns_gpio_chip *cgpio = gpiochip_get_data(chip);\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\tunsigned long status;\n\tint hwirq;\n\n\tchained_irq_enter(irqchip, desc);\n\n\tstatus = ioread32(cgpio->regs + CDNS_GPIO_IRQ_STATUS) &\n\t\t~ioread32(cgpio->regs + CDNS_GPIO_IRQ_MASK);\n\n\tfor_each_set_bit(hwirq, &status, chip->ngpio)\n\t\tgeneric_handle_domain_irq(chip->irq.domain, hwirq);\n\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic const struct irq_chip cdns_gpio_irqchip = {\n\t.name\t\t= \"cdns-gpio\",\n\t.irq_mask\t= cdns_gpio_irq_mask,\n\t.irq_unmask\t= cdns_gpio_irq_unmask,\n\t.irq_set_type\t= cdns_gpio_irq_set_type,\n\t.flags\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int cdns_gpio_probe(struct platform_device *pdev)\n{\n\tstruct cdns_gpio_chip *cgpio;\n\tint ret, irq;\n\tu32 dir_prev;\n\tu32 num_gpios = 32;\n\n\tcgpio = devm_kzalloc(&pdev->dev, sizeof(*cgpio), GFP_KERNEL);\n\tif (!cgpio)\n\t\treturn -ENOMEM;\n\n\tcgpio->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cgpio->regs))\n\t\treturn PTR_ERR(cgpio->regs);\n\n\tof_property_read_u32(pdev->dev.of_node, \"ngpios\", &num_gpios);\n\n\tif (num_gpios > 32) {\n\t\tdev_err(&pdev->dev, \"ngpios must be less or equal 32\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdir_prev = ioread32(cgpio->regs + CDNS_GPIO_DIRECTION_MODE);\n\tiowrite32(GENMASK(num_gpios - 1, 0),\n\t\t  cgpio->regs + CDNS_GPIO_DIRECTION_MODE);\n\n\tret = bgpio_init(&cgpio->gc, &pdev->dev, 4,\n\t\t\t cgpio->regs + CDNS_GPIO_INPUT_VALUE,\n\t\t\t cgpio->regs + CDNS_GPIO_OUTPUT_VALUE,\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t cgpio->regs + CDNS_GPIO_DIRECTION_MODE,\n\t\t\t BGPIOF_READ_OUTPUT_REG_SET);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register generic gpio, %d\\n\",\n\t\t\tret);\n\t\tgoto err_revert_dir;\n\t}\n\n\tcgpio->gc.label = dev_name(&pdev->dev);\n\tcgpio->gc.ngpio = num_gpios;\n\tcgpio->gc.parent = &pdev->dev;\n\tcgpio->gc.base = -1;\n\tcgpio->gc.owner = THIS_MODULE;\n\tcgpio->gc.request = cdns_gpio_request;\n\tcgpio->gc.free = cdns_gpio_free;\n\n\tcgpio->pclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(cgpio->pclk)) {\n\t\tret = PTR_ERR(cgpio->pclk);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to retrieve peripheral clock, %d\\n\", ret);\n\t\tgoto err_revert_dir;\n\t}\n\n\tret = clk_prepare_enable(cgpio->pclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to enable the peripheral clock, %d\\n\", ret);\n\t\tgoto err_revert_dir;\n\t}\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq >= 0) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\tgirq = &cgpio->gc.irq;\n\t\tgpio_irq_chip_set_chip(girq, &cdns_gpio_irqchip);\n\t\tgirq->parent_handler = cdns_gpio_irq_handler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(&pdev->dev, 1,\n\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_disable_clk;\n\t\t}\n\t\tgirq->parents[0] = irq;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_level_irq;\n\t}\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &cgpio->gc, cgpio);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Could not register gpiochip, %d\\n\", ret);\n\t\tgoto err_disable_clk;\n\t}\n\n\tcgpio->bypass_orig = ioread32(cgpio->regs + CDNS_GPIO_BYPASS_MODE);\n\n\t \n\tiowrite32(GENMASK(num_gpios - 1, 0),\n\t\t  cgpio->regs + CDNS_GPIO_OUTPUT_EN);\n\tiowrite32(0, cgpio->regs + CDNS_GPIO_BYPASS_MODE);\n\n\tplatform_set_drvdata(pdev, cgpio);\n\treturn 0;\n\nerr_disable_clk:\n\tclk_disable_unprepare(cgpio->pclk);\n\nerr_revert_dir:\n\tiowrite32(dir_prev, cgpio->regs + CDNS_GPIO_DIRECTION_MODE);\n\n\treturn ret;\n}\n\nstatic int cdns_gpio_remove(struct platform_device *pdev)\n{\n\tstruct cdns_gpio_chip *cgpio = platform_get_drvdata(pdev);\n\n\tiowrite32(cgpio->bypass_orig, cgpio->regs + CDNS_GPIO_BYPASS_MODE);\n\tclk_disable_unprepare(cgpio->pclk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id cdns_of_ids[] = {\n\t{ .compatible = \"cdns,gpio-r1p02\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, cdns_of_ids);\n\nstatic struct platform_driver cdns_gpio_driver = {\n\t.driver = {\n\t\t.name = \"cdns-gpio\",\n\t\t.of_match_table = cdns_of_ids,\n\t},\n\t.probe = cdns_gpio_probe,\n\t.remove = cdns_gpio_remove,\n};\nmodule_platform_driver(cdns_gpio_driver);\n\nMODULE_AUTHOR(\"Jan Kotas <jank@cadence.com>\");\nMODULE_DESCRIPTION(\"Cadence GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:cdns-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}