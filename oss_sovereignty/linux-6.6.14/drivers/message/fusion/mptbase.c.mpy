{
  "module_name": "mptbase.c",
  "hash_id": "a9587a661ae86c319cb4dc285b733ee9682696c4d21ae88c8a514da9fd4a86f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/message/fusion/mptbase.c",
  "human_readable_source": " \n \n \n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/kdev_t.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/kthread.h>\n#include <scsi/scsi_host.h>\n\n#include \"mptbase.h\"\n#include \"lsi/mpi_log_fc.h\"\n\n \n#define my_NAME\t\t\"Fusion MPT base driver\"\n#define my_VERSION\tMPT_LINUX_VERSION_COMMON\n#define MYNAM\t\t\"mptbase\"\n\nMODULE_AUTHOR(MODULEAUTHOR);\nMODULE_DESCRIPTION(my_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(my_VERSION);\n\n \n\nstatic int mpt_msi_enable_spi;\nmodule_param(mpt_msi_enable_spi, int, 0);\nMODULE_PARM_DESC(mpt_msi_enable_spi,\n\t\t \" Enable MSI Support for SPI controllers (default=0)\");\n\nstatic int mpt_msi_enable_fc;\nmodule_param(mpt_msi_enable_fc, int, 0);\nMODULE_PARM_DESC(mpt_msi_enable_fc,\n\t\t \" Enable MSI Support for FC controllers (default=0)\");\n\nstatic int mpt_msi_enable_sas;\nmodule_param(mpt_msi_enable_sas, int, 0);\nMODULE_PARM_DESC(mpt_msi_enable_sas,\n\t\t \" Enable MSI Support for SAS controllers (default=0)\");\n\nstatic int mpt_channel_mapping;\nmodule_param(mpt_channel_mapping, int, 0);\nMODULE_PARM_DESC(mpt_channel_mapping, \" Mapping id's to channels (default=0)\");\n\nstatic int mpt_debug_level;\nstatic int mpt_set_debug_level(const char *val, const struct kernel_param *kp);\nmodule_param_call(mpt_debug_level, mpt_set_debug_level, param_get_int,\n\t\t  &mpt_debug_level, 0600);\nMODULE_PARM_DESC(mpt_debug_level,\n\t\t \" debug level - refer to mptdebug.h - (default=0)\");\n\nint mpt_fwfault_debug;\nEXPORT_SYMBOL(mpt_fwfault_debug);\nmodule_param(mpt_fwfault_debug, int, 0600);\nMODULE_PARM_DESC(mpt_fwfault_debug,\n\t\t \"Enable detection of Firmware fault and halt Firmware on fault - (default=0)\");\n\nstatic char\tMptCallbacksName[MPT_MAX_PROTOCOL_DRIVERS]\n\t\t\t\t[MPT_MAX_CALLBACKNAME_LEN+1];\n\n#ifdef MFCNT\nstatic int mfcounter = 0;\n#define PRINT_MF_COUNT 20000\n#endif\n\n \n \n\n#define WHOINIT_UNKNOWN\t\t0xAA\n\n \n \n\t\t\t\t\t \nLIST_HEAD(ioc_list);\n\t\t\t\t\t \nstatic MPT_CALLBACK\t\t MptCallbacks[MPT_MAX_PROTOCOL_DRIVERS];\n\t\t\t\t\t \nstatic int\t\t\t MptDriverClass[MPT_MAX_PROTOCOL_DRIVERS];\n\t\t\t\t\t \nstatic MPT_EVHANDLER\t\t MptEvHandlers[MPT_MAX_PROTOCOL_DRIVERS];\n\t\t\t\t\t \nstatic MPT_RESETHANDLER\t\t MptResetHandlers[MPT_MAX_PROTOCOL_DRIVERS];\nstatic struct mpt_pci_driver \t*MptDeviceDriverHandlers[MPT_MAX_PROTOCOL_DRIVERS];\n\n#ifdef CONFIG_PROC_FS\nstatic struct proc_dir_entry \t*mpt_proc_root_dir;\n#endif\n\n \nstatic u8 mpt_base_index = MPT_MAX_PROTOCOL_DRIVERS;\nstatic u8 last_drv_idx;\n\n \n \nstatic irqreturn_t mpt_interrupt(int irq, void *bus_id);\nstatic int\tmptbase_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req,\n\t\tMPT_FRAME_HDR *reply);\nstatic int\tmpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes,\n\t\t\tu32 *req, int replyBytes, u16 *u16reply, int maxwait,\n\t\t\tint sleepFlag);\nstatic int\tmpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason, int sleepFlag);\nstatic void\tmpt_detect_bound_ports(MPT_ADAPTER *ioc, struct pci_dev *pdev);\nstatic void\tmpt_adapter_disable(MPT_ADAPTER *ioc);\nstatic void\tmpt_adapter_dispose(MPT_ADAPTER *ioc);\n\nstatic void\tMptDisplayIocCapabilities(MPT_ADAPTER *ioc);\nstatic int\tMakeIocReady(MPT_ADAPTER *ioc, int force, int sleepFlag);\nstatic int\tGetIocFacts(MPT_ADAPTER *ioc, int sleepFlag, int reason);\nstatic int\tGetPortFacts(MPT_ADAPTER *ioc, int portnum, int sleepFlag);\nstatic int\tSendIocInit(MPT_ADAPTER *ioc, int sleepFlag);\nstatic int\tSendPortEnable(MPT_ADAPTER *ioc, int portnum, int sleepFlag);\nstatic int\tmpt_do_upload(MPT_ADAPTER *ioc, int sleepFlag);\nstatic int\tmpt_downloadboot(MPT_ADAPTER *ioc, MpiFwHeader_t *pFwHeader, int sleepFlag);\nstatic int\tmpt_diag_reset(MPT_ADAPTER *ioc, int ignore, int sleepFlag);\nstatic int\tKickStart(MPT_ADAPTER *ioc, int ignore, int sleepFlag);\nstatic int\tSendIocReset(MPT_ADAPTER *ioc, u8 reset_type, int sleepFlag);\nstatic int\tPrimeIocFifos(MPT_ADAPTER *ioc);\nstatic int\tWaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong, int sleepFlag);\nstatic int\tWaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong, int sleepFlag);\nstatic int\tWaitForDoorbellReply(MPT_ADAPTER *ioc, int howlong, int sleepFlag);\nstatic int\tGetLanConfigPages(MPT_ADAPTER *ioc);\nstatic int\tGetIoUnitPage2(MPT_ADAPTER *ioc);\nint\t\tmptbase_sas_persist_operation(MPT_ADAPTER *ioc, u8 persist_opcode);\nstatic int\tmpt_GetScsiPortSettings(MPT_ADAPTER *ioc, int portnum);\nstatic int\tmpt_readScsiDevicePageHeaders(MPT_ADAPTER *ioc, int portnum);\nstatic void \tmpt_read_ioc_pg_1(MPT_ADAPTER *ioc);\nstatic void \tmpt_read_ioc_pg_4(MPT_ADAPTER *ioc);\nstatic void\tmpt_get_manufacturing_pg_0(MPT_ADAPTER *ioc);\nstatic int\tSendEventNotification(MPT_ADAPTER *ioc, u8 EvSwitch,\n\tint sleepFlag);\nstatic int\tSendEventAck(MPT_ADAPTER *ioc, EventNotificationReply_t *evnp);\nstatic int\tmpt_host_page_access_control(MPT_ADAPTER *ioc, u8 access_control_value, int sleepFlag);\nstatic int\tmpt_host_page_alloc(MPT_ADAPTER *ioc, pIOCInit_t ioc_init);\n\n#ifdef CONFIG_PROC_FS\nstatic int mpt_summary_proc_show(struct seq_file *m, void *v);\nstatic int mpt_version_proc_show(struct seq_file *m, void *v);\nstatic int mpt_iocinfo_proc_show(struct seq_file *m, void *v);\n#endif\nstatic void\tmpt_get_fw_exp_ver(char *buf, MPT_ADAPTER *ioc);\n\nstatic int\tProcessEventNotification(MPT_ADAPTER *ioc,\n\t\tEventNotificationReply_t *evReply, int *evHandlers);\nstatic void\tmpt_iocstatus_info(MPT_ADAPTER *ioc, u32 ioc_status, MPT_FRAME_HDR *mf);\nstatic void\tmpt_fc_log_info(MPT_ADAPTER *ioc, u32 log_info);\nstatic void\tmpt_spi_log_info(MPT_ADAPTER *ioc, u32 log_info);\nstatic void\tmpt_sas_log_info(MPT_ADAPTER *ioc, u32 log_info , u8 cb_idx);\nstatic int\tmpt_read_ioc_pg_3(MPT_ADAPTER *ioc);\nstatic void\tmpt_inactive_raid_list_free(MPT_ADAPTER *ioc);\n\n \nstatic int  __init    fusion_init  (void);\nstatic void __exit    fusion_exit  (void);\n\n#define CHIPREG_READ32(addr) \t\treadl_relaxed(addr)\n#define CHIPREG_READ32_dmasync(addr)\treadl(addr)\n#define CHIPREG_WRITE32(addr,val) \twritel(val, addr)\n#define CHIPREG_PIO_WRITE32(addr,val)\toutl(val, (unsigned long)addr)\n#define CHIPREG_PIO_READ32(addr) \tinl((unsigned long)addr)\n\nstatic void\npci_disable_io_access(struct pci_dev *pdev)\n{\n\tu16 command_reg;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &command_reg);\n\tcommand_reg &= ~1;\n\tpci_write_config_word(pdev, PCI_COMMAND, command_reg);\n}\n\nstatic void\npci_enable_io_access(struct pci_dev *pdev)\n{\n\tu16 command_reg;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &command_reg);\n\tcommand_reg |= 1;\n\tpci_write_config_word(pdev, PCI_COMMAND, command_reg);\n}\n\nstatic int mpt_set_debug_level(const char *val, const struct kernel_param *kp)\n{\n\tint ret = param_set_int(val, kp);\n\tMPT_ADAPTER *ioc;\n\n\tif (ret)\n\t\treturn ret;\n\n\tlist_for_each_entry(ioc, &ioc_list, list)\n\t\tioc->debug_level = mpt_debug_level;\n\treturn 0;\n}\n\n \nstatic u8\nmpt_get_cb_idx(MPT_DRIVER_CLASS dclass)\n{\n\tu8 cb_idx;\n\n\tfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--)\n\t\tif (MptDriverClass[cb_idx] == dclass)\n\t\t\treturn cb_idx;\n\treturn 0;\n}\n\n \nstatic int\nmpt_is_discovery_complete(MPT_ADAPTER *ioc)\n{\n\tConfigExtendedPageHeader_t hdr;\n\tCONFIGPARMS cfg;\n\tSasIOUnitPage0_t *buffer;\n\tdma_addr_t dma_handle;\n\tint rc = 0;\n\n\tmemset(&hdr, 0, sizeof(ConfigExtendedPageHeader_t));\n\tmemset(&cfg, 0, sizeof(CONFIGPARMS));\n\thdr.PageVersion = MPI_SASIOUNITPAGE0_PAGEVERSION;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\n\thdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT;\n\tcfg.cfghdr.ehdr = &hdr;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\n\tif ((mpt_config(ioc, &cfg)))\n\t\tgoto out;\n\tif (!hdr.ExtPageLength)\n\t\tgoto out;\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\tif (!buffer)\n\t\tgoto out;\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\tif ((mpt_config(ioc, &cfg)))\n\t\tgoto out_free_consistent;\n\n\tif (!(buffer->PhyData[0].PortFlags &\n\t    MPI_SAS_IOUNIT0_PORT_FLAGS_DISCOVERY_IN_PROGRESS))\n\t\trc = 1;\n\n out_free_consistent:\n\tdma_free_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4, buffer,\n\t\t\t  dma_handle);\n out:\n\treturn rc;\n}\n\n\n \nstatic int mpt_remove_dead_ioc_func(void *arg)\n{\n\tMPT_ADAPTER *ioc = (MPT_ADAPTER *)arg;\n\tstruct pci_dev *pdev;\n\n\tif (!ioc)\n\t\treturn -1;\n\n\tpdev = ioc->pcidev;\n\tif (!pdev)\n\t\treturn -1;\n\n\tpci_stop_and_remove_bus_device_locked(pdev);\n\treturn 0;\n}\n\n\n\n \nstatic void\nmpt_fault_reset_work(struct work_struct *work)\n{\n\tMPT_ADAPTER\t*ioc =\n\t    container_of(work, MPT_ADAPTER, fault_reset_work.work);\n\tu32\t\t ioc_raw_state;\n\tint\t\t rc;\n\tunsigned long\t flags;\n\tMPT_SCSI_HOST\t*hd;\n\tstruct task_struct *p;\n\n\tif (ioc->ioc_reset_in_progress || !ioc->active)\n\t\tgoto out;\n\n\n\tioc_raw_state = mpt_GetIocState(ioc, 0);\n\tif ((ioc_raw_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_MASK) {\n\t\tprintk(MYIOC_s_INFO_FMT \"%s: IOC is non-operational !!!!\\n\",\n\t\t    ioc->name, __func__);\n\n\t\t \n\t\thd = shost_priv(ioc->sh);\n\t\tioc->schedule_dead_ioc_flush_running_cmds(hd);\n\n\t\t \n\t\tp = kthread_run(mpt_remove_dead_ioc_func, ioc,\n\t\t\t\t\"mpt_dead_ioc_%d\", ioc->id);\n\t\tif (IS_ERR(p))\t{\n\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t\t\"%s: Running mpt_dead_ioc thread failed !\\n\",\n\t\t\t\tioc->name, __func__);\n\t\t} else {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\t\"%s: Running mpt_dead_ioc thread success !\\n\",\n\t\t\t\tioc->name, __func__);\n\t\t}\n\t\treturn;  \n\t}\n\n\tif ((ioc_raw_state & MPI_IOC_STATE_MASK)\n\t\t\t== MPI_IOC_STATE_FAULT) {\n\t\tprintk(MYIOC_s_WARN_FMT \"IOC is in FAULT state (%04xh)!!!\\n\",\n\t\t       ioc->name, ioc_raw_state & MPI_DOORBELL_DATA_MASK);\n\t\tprintk(MYIOC_s_WARN_FMT \"Issuing HardReset from %s!!\\n\",\n\t\t       ioc->name, __func__);\n\t\trc = mpt_HardResetHandler(ioc, CAN_SLEEP);\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: HardReset: %s\\n\", ioc->name,\n\t\t       __func__, (rc == 0) ? \"success\" : \"failed\");\n\t\tioc_raw_state = mpt_GetIocState(ioc, 0);\n\t\tif ((ioc_raw_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_FAULT)\n\t\t\tprintk(MYIOC_s_WARN_FMT \"IOC is in FAULT state after \"\n\t\t\t    \"reset (%04xh)\\n\", ioc->name, ioc_raw_state &\n\t\t\t    MPI_DOORBELL_DATA_MASK);\n\t} else if (ioc->bus_type == SAS && ioc->sas_discovery_quiesce_io) {\n\t\tif ((mpt_is_discovery_complete(ioc))) {\n\t\t\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"clearing \"\n\t\t\t    \"discovery_quiesce_io flag\\n\", ioc->name));\n\t\t\tioc->sas_discovery_quiesce_io = 0;\n\t\t}\n\t}\n\n out:\n\t \n\tif (ioc->alt_ioc)\n\t\tioc = ioc->alt_ioc;\n\n\t \n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->reset_work_q)\n\t\tqueue_delayed_work(ioc->reset_work_q, &ioc->fault_reset_work,\n\t\t\tmsecs_to_jiffies(MPT_POLLING_INTERVAL));\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n}\n\n\n \nstatic void\nmpt_turbo_reply(MPT_ADAPTER *ioc, u32 pa)\n{\n\tMPT_FRAME_HDR *mf = NULL;\n\tMPT_FRAME_HDR *mr = NULL;\n\tu16 req_idx = 0;\n\tu8 cb_idx;\n\n\tdmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Got TURBO reply req_idx=%08x\\n\",\n\t\t\t\tioc->name, pa));\n\n\tswitch (pa >> MPI_CONTEXT_REPLY_TYPE_SHIFT) {\n\tcase MPI_CONTEXT_REPLY_TYPE_SCSI_INIT:\n\t\treq_idx = pa & 0x0000FFFF;\n\t\tcb_idx = (pa & 0x00FF0000) >> 16;\n\t\tmf = MPT_INDEX_2_MFPTR(ioc, req_idx);\n\t\tbreak;\n\tcase MPI_CONTEXT_REPLY_TYPE_LAN:\n\t\tcb_idx = mpt_get_cb_idx(MPTLAN_DRIVER);\n\t\t \n\t\tif ((pa & 0x58000000) == 0x58000000) {\n\t\t\treq_idx = pa & 0x0000FFFF;\n\t\t\tmf = MPT_INDEX_2_MFPTR(ioc, req_idx);\n\t\t\tmpt_free_msg_frame(ioc, mf);\n\t\t\tmb();\n\t\t\treturn;\n\t\t}\n\t\tmr = (MPT_FRAME_HDR *) CAST_U32_TO_PTR(pa);\n\t\tbreak;\n\tcase MPI_CONTEXT_REPLY_TYPE_SCSI_TARGET:\n\t\tcb_idx = mpt_get_cb_idx(MPTSTM_DRIVER);\n\t\tmr = (MPT_FRAME_HDR *) CAST_U32_TO_PTR(pa);\n\t\tbreak;\n\tdefault:\n\t\tcb_idx = 0;\n\t\tBUG();\n\t}\n\n\t \n\tif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS ||\n\t\tMptCallbacks[cb_idx] == NULL) {\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: Invalid cb_idx (%d)!\\n\",\n\t\t\t\t__func__, ioc->name, cb_idx);\n\t\tgoto out;\n\t}\n\n\tif (MptCallbacks[cb_idx](ioc, mf, mr))\n\t\tmpt_free_msg_frame(ioc, mf);\n out:\n\tmb();\n}\n\nstatic void\nmpt_reply(MPT_ADAPTER *ioc, u32 pa)\n{\n\tMPT_FRAME_HDR\t*mf;\n\tMPT_FRAME_HDR\t*mr;\n\tu16\t\t req_idx;\n\tu8\t\t cb_idx;\n\tint\t\t freeme;\n\n\tu32 reply_dma_low;\n\tu16 ioc_stat;\n\n\t \n\n\t \n\n\treply_dma_low = (pa <<= 1);\n\tmr = (MPT_FRAME_HDR *)((u8 *)ioc->reply_frames +\n\t\t\t (reply_dma_low - ioc->reply_frames_low_dma));\n\n\treq_idx = le16_to_cpu(mr->u.frame.hwhdr.msgctxu.fld.req_idx);\n\tcb_idx = mr->u.frame.hwhdr.msgctxu.fld.cb_idx;\n\tmf = MPT_INDEX_2_MFPTR(ioc, req_idx);\n\n\tdmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Got non-TURBO reply=%p req_idx=%x cb_idx=%x Function=%x\\n\",\n\t\t\tioc->name, mr, req_idx, cb_idx, mr->u.hdr.Function));\n\tDBG_DUMP_REPLY_FRAME(ioc, (u32 *)mr);\n\n\t  \n\tioc_stat = le16_to_cpu(mr->u.reply.IOCStatus);\n\tif (ioc_stat & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {\n\t\tu32\t log_info = le32_to_cpu(mr->u.reply.IOCLogInfo);\n\t\tif (ioc->bus_type == FC)\n\t\t\tmpt_fc_log_info(ioc, log_info);\n\t\telse if (ioc->bus_type == SPI)\n\t\t\tmpt_spi_log_info(ioc, log_info);\n\t\telse if (ioc->bus_type == SAS)\n\t\t\tmpt_sas_log_info(ioc, log_info, cb_idx);\n\t}\n\n\tif (ioc_stat & MPI_IOCSTATUS_MASK)\n\t\tmpt_iocstatus_info(ioc, (u32)ioc_stat, mf);\n\n\t \n\tif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS ||\n\t\tMptCallbacks[cb_idx] == NULL) {\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: Invalid cb_idx (%d)!\\n\",\n\t\t\t\t__func__, ioc->name, cb_idx);\n\t\tfreeme = 0;\n\t\tgoto out;\n\t}\n\n\tfreeme = MptCallbacks[cb_idx](ioc, mf, mr);\n\n out:\n\t \n\tCHIPREG_WRITE32(&ioc->chip->ReplyFifo, pa);\n\n\tif (freeme)\n\t\tmpt_free_msg_frame(ioc, mf);\n\tmb();\n}\n\n \n \nstatic irqreturn_t\nmpt_interrupt(int irq, void *bus_id)\n{\n\tMPT_ADAPTER *ioc = bus_id;\n\tu32 pa = CHIPREG_READ32_dmasync(&ioc->chip->ReplyFifo);\n\n\tif (pa == 0xFFFFFFFF)\n\t\treturn IRQ_NONE;\n\n\t \n\tdo {\n\t\tif (pa & MPI_ADDRESS_REPLY_A_BIT)\n\t\t\tmpt_reply(ioc, pa);\n\t\telse\n\t\t\tmpt_turbo_reply(ioc, pa);\n\t\tpa = CHIPREG_READ32_dmasync(&ioc->chip->ReplyFifo);\n\t} while (pa != 0xFFFFFFFF);\n\n\treturn IRQ_HANDLED;\n}\n\n \n \nstatic int\nmptbase_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply)\n{\n\tEventNotificationReply_t *pEventReply;\n\tu8 event;\n\tint evHandlers;\n\tint freereq = 1;\n\n\tswitch (reply->u.hdr.Function) {\n\tcase MPI_FUNCTION_EVENT_NOTIFICATION:\n\t\tpEventReply = (EventNotificationReply_t *)reply;\n\t\tevHandlers = 0;\n\t\tProcessEventNotification(ioc, pEventReply, &evHandlers);\n\t\tevent = le32_to_cpu(pEventReply->Event) & 0xFF;\n\t\tif (pEventReply->MsgFlags & MPI_MSGFLAGS_CONTINUATION_REPLY)\n\t\t\tfreereq = 0;\n\t\tif (event != MPI_EVENT_EVENT_CHANGE)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase MPI_FUNCTION_CONFIG:\n\tcase MPI_FUNCTION_SAS_IO_UNIT_CONTROL:\n\t\tioc->mptbase_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\n\t\tioc->mptbase_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\n\t\tmemcpy(ioc->mptbase_cmds.reply, reply,\n\t\t    min(MPT_DEFAULT_FRAME_SIZE,\n\t\t\t4 * reply->u.reply.MsgLength));\n\t\tif (ioc->mptbase_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\t\tioc->mptbase_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\t\tcomplete(&ioc->mptbase_cmds.done);\n\t\t} else\n\t\t\tfreereq = 0;\n\t\tif (ioc->mptbase_cmds.status & MPT_MGMT_STATUS_FREE_MF)\n\t\t\tfreereq = 1;\n\t\tbreak;\n\tcase MPI_FUNCTION_EVENT_ACK:\n\t\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"EventAck reply received\\n\", ioc->name));\n\t\tbreak;\n\tdefault:\n\t\tprintk(MYIOC_s_ERR_FMT\n\t\t    \"Unexpected msg function (=%02Xh) reply received!\\n\",\n\t\t    ioc->name, reply->u.hdr.Function);\n\t\tbreak;\n\t}\n\n\t \n\treturn freereq;\n}\n\n \n \nu8\nmpt_register(MPT_CALLBACK cbfunc, MPT_DRIVER_CLASS dclass, char *func_name)\n{\n\tu8 cb_idx;\n\tlast_drv_idx = MPT_MAX_PROTOCOL_DRIVERS;\n\n\t \n\tfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\n\t\tif (MptCallbacks[cb_idx] == NULL) {\n\t\t\tMptCallbacks[cb_idx] = cbfunc;\n\t\t\tMptDriverClass[cb_idx] = dclass;\n\t\t\tMptEvHandlers[cb_idx] = NULL;\n\t\t\tlast_drv_idx = cb_idx;\n\t\t\tstrscpy(MptCallbacksName[cb_idx], func_name,\n\t\t\t\tMPT_MAX_CALLBACKNAME_LEN+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn last_drv_idx;\n}\n\n \n \nvoid\nmpt_deregister(u8 cb_idx)\n{\n\tif (cb_idx && (cb_idx < MPT_MAX_PROTOCOL_DRIVERS)) {\n\t\tMptCallbacks[cb_idx] = NULL;\n\t\tMptDriverClass[cb_idx] = MPTUNKNOWN_DRIVER;\n\t\tMptEvHandlers[cb_idx] = NULL;\n\n\t\tlast_drv_idx++;\n\t}\n}\n\n \n \nint\nmpt_event_register(u8 cb_idx, MPT_EVHANDLER ev_cbfunc)\n{\n\tif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS)\n\t\treturn -1;\n\n\tMptEvHandlers[cb_idx] = ev_cbfunc;\n\treturn 0;\n}\n\n \n \nvoid\nmpt_event_deregister(u8 cb_idx)\n{\n\tif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS)\n\t\treturn;\n\n\tMptEvHandlers[cb_idx] = NULL;\n}\n\n \n \nint\nmpt_reset_register(u8 cb_idx, MPT_RESETHANDLER reset_func)\n{\n\tif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS)\n\t\treturn -1;\n\n\tMptResetHandlers[cb_idx] = reset_func;\n\treturn 0;\n}\n\n \n \nvoid\nmpt_reset_deregister(u8 cb_idx)\n{\n\tif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS)\n\t\treturn;\n\n\tMptResetHandlers[cb_idx] = NULL;\n}\n\n \n \nint\nmpt_device_driver_register(struct mpt_pci_driver * dd_cbfunc, u8 cb_idx)\n{\n\tMPT_ADAPTER\t*ioc;\n\n\tif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS)\n\t\treturn -EINVAL;\n\n\tMptDeviceDriverHandlers[cb_idx] = dd_cbfunc;\n\n\t \n\tlist_for_each_entry(ioc, &ioc_list, list) {\n\t\tif (dd_cbfunc->probe)\n\t\t\tdd_cbfunc->probe(ioc->pcidev);\n\t }\n\n\treturn 0;\n}\n\n \n \nvoid\nmpt_device_driver_deregister(u8 cb_idx)\n{\n\tstruct mpt_pci_driver *dd_cbfunc;\n\tMPT_ADAPTER\t*ioc;\n\n\tif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS)\n\t\treturn;\n\n\tdd_cbfunc = MptDeviceDriverHandlers[cb_idx];\n\n\tlist_for_each_entry(ioc, &ioc_list, list) {\n\t\tif (dd_cbfunc->remove)\n\t\t\tdd_cbfunc->remove(ioc->pcidev);\n\t}\n\n\tMptDeviceDriverHandlers[cb_idx] = NULL;\n}\n\n\n \n \nMPT_FRAME_HDR*\nmpt_get_msg_frame(u8 cb_idx, MPT_ADAPTER *ioc)\n{\n\tMPT_FRAME_HDR *mf;\n\tunsigned long flags;\n\tu16\t req_idx;\t \n\n\t \n\n#ifdef MFCNT\n\tif (!ioc->active)\n\t\tprintk(MYIOC_s_WARN_FMT \"IOC Not Active! mpt_get_msg_frame \"\n\t\t    \"returning NULL!\\n\", ioc->name);\n#endif\n\n\t \n\tif (!ioc->active)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&ioc->FreeQlock, flags);\n\tif (!list_empty(&ioc->FreeQ)) {\n\t\tint req_offset;\n\n\t\tmf = list_entry(ioc->FreeQ.next, MPT_FRAME_HDR,\n\t\t\t\tu.frame.linkage.list);\n\t\tlist_del(&mf->u.frame.linkage.list);\n\t\tmf->u.frame.linkage.arg1 = 0;\n\t\tmf->u.frame.hwhdr.msgctxu.fld.cb_idx = cb_idx;\t \n\t\treq_offset = (u8 *)mf - (u8 *)ioc->req_frames;\n\t\t\t\t\t\t\t\t \n\t\treq_idx = req_offset / ioc->req_sz;\n\t\tmf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(req_idx);\n\t\tmf->u.frame.hwhdr.msgctxu.fld.rsvd = 0;\n\t\t \n\t\tioc->RequestNB[req_idx] = ioc->NB_for_64_byte_frame;\n#ifdef MFCNT\n\t\tioc->mfcnt++;\n#endif\n\t}\n\telse\n\t\tmf = NULL;\n\tspin_unlock_irqrestore(&ioc->FreeQlock, flags);\n\n#ifdef MFCNT\n\tif (mf == NULL)\n\t\tprintk(MYIOC_s_WARN_FMT \"IOC Active. No free Msg Frames! \"\n\t\t    \"Count 0x%x Max 0x%x\\n\", ioc->name, ioc->mfcnt,\n\t\t    ioc->req_depth);\n\tmfcounter++;\n\tif (mfcounter == PRINT_MF_COUNT)\n\t\tprintk(MYIOC_s_INFO_FMT \"MF Count 0x%x Max 0x%x \\n\", ioc->name,\n\t\t    ioc->mfcnt, ioc->req_depth);\n#endif\n\n\tdmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mpt_get_msg_frame(%d,%d), got mf=%p\\n\",\n\t    ioc->name, cb_idx, ioc->id, mf));\n\treturn mf;\n}\n\n \n \nvoid\nmpt_put_msg_frame(u8 cb_idx, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)\n{\n\tu32 mf_dma_addr;\n\tint req_offset;\n\tu16 req_idx;\t \n\n\t \n\tmf->u.frame.hwhdr.msgctxu.fld.cb_idx = cb_idx;\t\t \n\treq_offset = (u8 *)mf - (u8 *)ioc->req_frames;\n\t\t\t\t\t\t\t\t \n\treq_idx = req_offset / ioc->req_sz;\n\tmf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(req_idx);\n\tmf->u.frame.hwhdr.msgctxu.fld.rsvd = 0;\n\n\tDBG_DUMP_PUT_MSG_FRAME(ioc, (u32 *)mf);\n\n\tmf_dma_addr = (ioc->req_frames_low_dma + req_offset) | ioc->RequestNB[req_idx];\n\tdsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mf_dma_addr=%x req_idx=%d \"\n\t    \"RequestNB=%x\\n\", ioc->name, mf_dma_addr, req_idx,\n\t    ioc->RequestNB[req_idx]));\n\tCHIPREG_WRITE32(&ioc->chip->RequestFifo, mf_dma_addr);\n}\n\n \nvoid\nmpt_put_msg_frame_hi_pri(u8 cb_idx, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)\n{\n\tu32 mf_dma_addr;\n\tint req_offset;\n\tu16 req_idx;\t \n\n\t \n\tmf->u.frame.hwhdr.msgctxu.fld.cb_idx = cb_idx;\n\treq_offset = (u8 *)mf - (u8 *)ioc->req_frames;\n\treq_idx = req_offset / ioc->req_sz;\n\tmf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(req_idx);\n\tmf->u.frame.hwhdr.msgctxu.fld.rsvd = 0;\n\n\tDBG_DUMP_PUT_MSG_FRAME(ioc, (u32 *)mf);\n\n\tmf_dma_addr = (ioc->req_frames_low_dma + req_offset);\n\tdsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mf_dma_addr=%x req_idx=%d\\n\",\n\t\tioc->name, mf_dma_addr, req_idx));\n\tCHIPREG_WRITE32(&ioc->chip->RequestHiPriFifo, mf_dma_addr);\n}\n\n \n \nvoid\nmpt_free_msg_frame(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ioc->FreeQlock, flags);\n\tif (cpu_to_le32(mf->u.frame.linkage.arg1) == 0xdeadbeaf)\n\t\tgoto out;\n\t \n\tmf->u.frame.linkage.arg1 = cpu_to_le32(0xdeadbeaf);\n\tlist_add(&mf->u.frame.linkage.list, &ioc->FreeQ);\n#ifdef MFCNT\n\tioc->mfcnt--;\n#endif\n out:\n\tspin_unlock_irqrestore(&ioc->FreeQlock, flags);\n}\n\n \n \nstatic void\nmpt_add_sge(void *pAddr, u32 flagslength, dma_addr_t dma_addr)\n{\n\tSGESimple32_t *pSge = (SGESimple32_t *) pAddr;\n\tpSge->FlagsLength = cpu_to_le32(flagslength);\n\tpSge->Address = cpu_to_le32(dma_addr);\n}\n\n \nstatic void\nmpt_add_sge_64bit(void *pAddr, u32 flagslength, dma_addr_t dma_addr)\n{\n\tSGESimple64_t *pSge = (SGESimple64_t *) pAddr;\n\tpSge->Address.Low = cpu_to_le32\n\t\t\t(lower_32_bits(dma_addr));\n\tpSge->Address.High = cpu_to_le32\n\t\t\t(upper_32_bits(dma_addr));\n\tpSge->FlagsLength = cpu_to_le32\n\t\t\t((flagslength | MPT_SGE_FLAGS_64_BIT_ADDRESSING));\n}\n\n \nstatic void\nmpt_add_sge_64bit_1078(void *pAddr, u32 flagslength, dma_addr_t dma_addr)\n{\n\tSGESimple64_t *pSge = (SGESimple64_t *) pAddr;\n\tu32 tmp;\n\n\tpSge->Address.Low = cpu_to_le32\n\t\t\t(lower_32_bits(dma_addr));\n\ttmp = (u32)(upper_32_bits(dma_addr));\n\n\t \n\tif ((((u64)dma_addr + MPI_SGE_LENGTH(flagslength)) >> 32)  == 9) {\n\t\tflagslength |=\n\t\t    MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_LOCAL_ADDRESS);\n\t\ttmp |= (1<<31);\n\t\tif (mpt_debug_level & MPT_DEBUG_36GB_MEM)\n\t\t\tprintk(KERN_DEBUG \"1078 P0M2 addressing for \"\n\t\t\t    \"addr = 0x%llx len = %d\\n\",\n\t\t\t    (unsigned long long)dma_addr,\n\t\t\t    MPI_SGE_LENGTH(flagslength));\n\t}\n\n\tpSge->Address.High = cpu_to_le32(tmp);\n\tpSge->FlagsLength = cpu_to_le32(\n\t\t(flagslength | MPT_SGE_FLAGS_64_BIT_ADDRESSING));\n}\n\n \n \nstatic void\nmpt_add_chain(void *pAddr, u8 next, u16 length, dma_addr_t dma_addr)\n{\n\tSGEChain32_t *pChain = (SGEChain32_t *) pAddr;\n\n\tpChain->Length = cpu_to_le16(length);\n\tpChain->Flags = MPI_SGE_FLAGS_CHAIN_ELEMENT;\n\tpChain->NextChainOffset = next;\n\tpChain->Address = cpu_to_le32(dma_addr);\n}\n\n \n \nstatic void\nmpt_add_chain_64bit(void *pAddr, u8 next, u16 length, dma_addr_t dma_addr)\n{\n\tSGEChain64_t *pChain = (SGEChain64_t *) pAddr;\n\tu32 tmp = dma_addr & 0xFFFFFFFF;\n\n\tpChain->Length = cpu_to_le16(length);\n\tpChain->Flags = (MPI_SGE_FLAGS_CHAIN_ELEMENT |\n\t\t\t MPI_SGE_FLAGS_64_BIT_ADDRESSING);\n\n\tpChain->NextChainOffset = next;\n\n\tpChain->Address.Low = cpu_to_le32(tmp);\n\ttmp = (u32)(upper_32_bits(dma_addr));\n\tpChain->Address.High = cpu_to_le32(tmp);\n}\n\n \n \nint\nmpt_send_handshake_request(u8 cb_idx, MPT_ADAPTER *ioc, int reqBytes, u32 *req, int sleepFlag)\n{\n\tint\tr = 0;\n\tu8\t*req_as_bytes;\n\tint\t ii;\n\n\t \n\n\t \n\tii = MFPTR_2_MPT_INDEX(ioc,(MPT_FRAME_HDR*)req);\n\tif (reqBytes >= 12 && ii >= 0 && ii < ioc->req_depth) {\n\t\tMPT_FRAME_HDR *mf = (MPT_FRAME_HDR*)req;\n\t\tmf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(ii);\n\t\tmf->u.frame.hwhdr.msgctxu.fld.cb_idx = cb_idx;\n\t}\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\n\tCHIPREG_WRITE32(&ioc->chip->Doorbell,\n\t\t\t((MPI_FUNCTION_HANDSHAKE<<MPI_DOORBELL_FUNCTION_SHIFT) |\n\t\t\t ((reqBytes/4)<<MPI_DOORBELL_ADD_DWORDS_SHIFT)));\n\n\t \n\tif ((ii = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0) {\n\t\treturn ii;\n\t}\n\n\t \n\tif (!(CHIPREG_READ32(&ioc->chip->Doorbell) & MPI_DOORBELL_ACTIVE))\n\t\treturn -5;\n\n\tdhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mpt_send_handshake_request start, WaitCnt=%d\\n\",\n\t\tioc->name, ii));\n\n\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\n\tif ((r = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0) {\n\t\treturn -2;\n\t}\n\n\t \n\treq_as_bytes = (u8 *) req;\n\tfor (ii = 0; ii < reqBytes/4; ii++) {\n\t\tu32 word;\n\n\t\tword = ((req_as_bytes[(ii*4) + 0] <<  0) |\n\t\t\t(req_as_bytes[(ii*4) + 1] <<  8) |\n\t\t\t(req_as_bytes[(ii*4) + 2] << 16) |\n\t\t\t(req_as_bytes[(ii*4) + 3] << 24));\n\t\tCHIPREG_WRITE32(&ioc->chip->Doorbell, word);\n\t\tif ((r = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0) {\n\t\t\tr = -3;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (r >= 0 && WaitForDoorbellInt(ioc, 10, sleepFlag) >= 0)\n\t\tr = 0;\n\telse\n\t\tr = -4;\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\n\treturn r;\n}\n\n \n \n\nstatic int\nmpt_host_page_access_control(MPT_ADAPTER *ioc, u8 access_control_value, int sleepFlag)\n{\n\t \n\tif (CHIPREG_READ32(&ioc->chip->Doorbell)\n\t    & MPI_DOORBELL_ACTIVE)\n\t    return -1;\n\n\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\n\tCHIPREG_WRITE32(&ioc->chip->Doorbell,\n\t\t((MPI_FUNCTION_HOST_PAGEBUF_ACCESS_CONTROL\n\t\t <<MPI_DOORBELL_FUNCTION_SHIFT) |\n\t\t (access_control_value<<12)));\n\n\t \n\tif (WaitForDoorbellAck(ioc, 5, sleepFlag) < 0)\n\t\treturn -2;\n\telse\n\t\treturn 0;\n}\n\n \n \nstatic int\nmpt_host_page_alloc(MPT_ADAPTER *ioc, pIOCInit_t ioc_init)\n{\n\tchar\t*psge;\n\tint\tflags_length;\n\tu32\thost_page_buffer_sz=0;\n\n\tif(!ioc->HostPageBuffer) {\n\n\t\thost_page_buffer_sz =\n\t\t    le32_to_cpu(ioc->facts.HostPageBufferSGE.FlagsLength) & 0xFFFFFF;\n\n\t\tif(!host_page_buffer_sz)\n\t\t\treturn 0;  \n\n\t\t \n\t\twhile (host_page_buffer_sz > 0) {\n\t\t\tioc->HostPageBuffer =\n\t\t\t\tdma_alloc_coherent(&ioc->pcidev->dev,\n\t\t\t\t\t\thost_page_buffer_sz,\n\t\t\t\t\t\t&ioc->HostPageBuffer_dma,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (ioc->HostPageBuffer) {\n\t\t\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t    \"host_page_buffer @ %p, dma @ %x, sz=%d bytes\\n\",\n\t\t\t\t    ioc->name, ioc->HostPageBuffer,\n\t\t\t\t    (u32)ioc->HostPageBuffer_dma,\n\t\t\t\t    host_page_buffer_sz));\n\t\t\t\tioc->alloc_total += host_page_buffer_sz;\n\t\t\t\tioc->HostPageBuffer_sz = host_page_buffer_sz;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\thost_page_buffer_sz -= (4*1024);\n\t\t}\n\t}\n\n\tif(!ioc->HostPageBuffer) {\n\t\tprintk(MYIOC_s_ERR_FMT\n\t\t    \"Failed to alloc memory for host_page_buffer!\\n\",\n\t\t    ioc->name);\n\t\treturn -999;\n\t}\n\n\tpsge = (char *)&ioc_init->HostPageBufferSGE;\n\tflags_length = MPI_SGE_FLAGS_SIMPLE_ELEMENT |\n\t    MPI_SGE_FLAGS_SYSTEM_ADDRESS |\n\t    MPI_SGE_FLAGS_HOST_TO_IOC |\n\t    MPI_SGE_FLAGS_END_OF_BUFFER;\n\tflags_length = flags_length << MPI_SGE_FLAGS_SHIFT;\n\tflags_length |= ioc->HostPageBuffer_sz;\n\tioc->add_sge(psge, flags_length, ioc->HostPageBuffer_dma);\n\tioc->facts.HostPageBufferSGE = ioc_init->HostPageBufferSGE;\n\n\treturn 0;\n}\n\n \n \nint\nmpt_verify_adapter(int iocid, MPT_ADAPTER **iocpp)\n{\n\tMPT_ADAPTER *ioc;\n\n\tlist_for_each_entry(ioc,&ioc_list,list) {\n\t\tif (ioc->id == iocid) {\n\t\t\t*iocpp =ioc;\n\t\t\treturn iocid;\n\t\t}\n\t}\n\n\t*iocpp = NULL;\n\treturn -1;\n}\n\n \nstatic const char*\nmpt_get_product_name(u16 vendor, u16 device, u8 revision)\n{\n\tchar *product_str = NULL;\n\n\tif (vendor == PCI_VENDOR_ID_BROCADE) {\n\t\tswitch (device)\n\t\t{\n\t\tcase MPI_MANUFACTPAGE_DEVICEID_FC949E:\n\t\t\tswitch (revision)\n\t\t\t{\n\t\t\tcase 0x00:\n\t\t\t\tproduct_str = \"BRE040 A0\";\n\t\t\t\tbreak;\n\t\t\tcase 0x01:\n\t\t\t\tproduct_str = \"BRE040 A1\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tproduct_str = \"BRE040\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tswitch (device)\n\t{\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC909:\n\t\tproduct_str = \"LSIFC909 B1\";\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC919:\n\t\tproduct_str = \"LSIFC919 B0\";\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC929:\n\t\tproduct_str = \"LSIFC929 B0\";\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC919X:\n\t\tif (revision < 0x80)\n\t\t\tproduct_str = \"LSIFC919X A0\";\n\t\telse\n\t\t\tproduct_str = \"LSIFC919XL A1\";\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC929X:\n\t\tif (revision < 0x80)\n\t\t\tproduct_str = \"LSIFC929X A0\";\n\t\telse\n\t\t\tproduct_str = \"LSIFC929XL A1\";\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC939X:\n\t\tproduct_str = \"LSIFC939X A1\";\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC949X:\n\t\tproduct_str = \"LSIFC949X A1\";\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC949E:\n\t\tswitch (revision)\n\t\t{\n\t\tcase 0x00:\n\t\t\tproduct_str = \"LSIFC949E A0\";\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tproduct_str = \"LSIFC949E A1\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tproduct_str = \"LSIFC949E\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVID_53C1030:\n\t\tswitch (revision)\n\t\t{\n\t\tcase 0x00:\n\t\t\tproduct_str = \"LSI53C1030 A0\";\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tproduct_str = \"LSI53C1030 B0\";\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tproduct_str = \"LSI53C1030 B1\";\n\t\t\tbreak;\n\t\tcase 0x07:\n\t\t\tproduct_str = \"LSI53C1030 B2\";\n\t\t\tbreak;\n\t\tcase 0x08:\n\t\t\tproduct_str = \"LSI53C1030 C0\";\n\t\t\tbreak;\n\t\tcase 0x80:\n\t\t\tproduct_str = \"LSI53C1030T A0\";\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tproduct_str = \"LSI53C1030T A2\";\n\t\t\tbreak;\n\t\tcase 0x87:\n\t\t\tproduct_str = \"LSI53C1030T A3\";\n\t\t\tbreak;\n\t\tcase 0xc1:\n\t\t\tproduct_str = \"LSI53C1020A A1\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tproduct_str = \"LSI53C1030\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVID_1030_53C1035:\n\t\tswitch (revision)\n\t\t{\n\t\tcase 0x03:\n\t\t\tproduct_str = \"LSI53C1035 A2\";\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\tproduct_str = \"LSI53C1035 B0\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tproduct_str = \"LSI53C1035\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVID_SAS1064:\n\t\tswitch (revision)\n\t\t{\n\t\tcase 0x00:\n\t\t\tproduct_str = \"LSISAS1064 A1\";\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tproduct_str = \"LSISAS1064 A2\";\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tproduct_str = \"LSISAS1064 A3\";\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tproduct_str = \"LSISAS1064 A4\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tproduct_str = \"LSISAS1064\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVID_SAS1064E:\n\t\tswitch (revision)\n\t\t{\n\t\tcase 0x00:\n\t\t\tproduct_str = \"LSISAS1064E A0\";\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tproduct_str = \"LSISAS1064E B0\";\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tproduct_str = \"LSISAS1064E B1\";\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\tproduct_str = \"LSISAS1064E B2\";\n\t\t\tbreak;\n\t\tcase 0x08:\n\t\t\tproduct_str = \"LSISAS1064E B3\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tproduct_str = \"LSISAS1064E\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVID_SAS1068:\n\t\tswitch (revision)\n\t\t{\n\t\tcase 0x00:\n\t\t\tproduct_str = \"LSISAS1068 A0\";\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tproduct_str = \"LSISAS1068 B0\";\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tproduct_str = \"LSISAS1068 B1\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tproduct_str = \"LSISAS1068\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVID_SAS1068E:\n\t\tswitch (revision)\n\t\t{\n\t\tcase 0x00:\n\t\t\tproduct_str = \"LSISAS1068E A0\";\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tproduct_str = \"LSISAS1068E B0\";\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tproduct_str = \"LSISAS1068E B1\";\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\tproduct_str = \"LSISAS1068E B2\";\n\t\t\tbreak;\n\t\tcase 0x08:\n\t\t\tproduct_str = \"LSISAS1068E B3\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tproduct_str = \"LSISAS1068E\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MPI_MANUFACTPAGE_DEVID_SAS1078:\n\t\tswitch (revision)\n\t\t{\n\t\tcase 0x00:\n\t\t\tproduct_str = \"LSISAS1078 A0\";\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tproduct_str = \"LSISAS1078 B0\";\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tproduct_str = \"LSISAS1078 C0\";\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tproduct_str = \"LSISAS1078 C1\";\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\tproduct_str = \"LSISAS1078 C2\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tproduct_str = \"LSISAS1078\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n out:\n\treturn product_str;\n}\n\n \nstatic int\nmpt_mapresources(MPT_ADAPTER *ioc)\n{\n\tu8\t\t__iomem *mem;\n\tint\t\t ii;\n\tresource_size_t\t mem_phys;\n\tunsigned long\t port;\n\tu32\t\t msize;\n\tu32\t\t psize;\n\tint\t\t r = -ENODEV;\n\tstruct pci_dev *pdev;\n\n\tpdev = ioc->pcidev;\n\tioc->bars = pci_select_bars(pdev, IORESOURCE_MEM);\n\tif (pci_enable_device_mem(pdev)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"pci_enable_device_mem() \"\n\t\t    \"failed\\n\", ioc->name);\n\t\treturn r;\n\t}\n\tif (pci_request_selected_regions(pdev, ioc->bars, \"mpt\")) {\n\t\tprintk(MYIOC_s_ERR_FMT \"pci_request_selected_regions() with \"\n\t\t    \"MEM failed\\n\", ioc->name);\n\t\tgoto out_pci_disable_device;\n\t}\n\n\tif (sizeof(dma_addr_t) > 4) {\n\t\tconst uint64_t required_mask = dma_get_required_mask\n\t\t    (&pdev->dev);\n\t\tif (required_mask > DMA_BIT_MASK(32)\n\t\t\t&& !dma_set_mask(&pdev->dev, DMA_BIT_MASK(64))\n\t\t\t&& !dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64))) {\n\t\t\tioc->dma_mask = DMA_BIT_MASK(64);\n\t\t\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT\n\t\t\t\t\": 64 BIT PCI BUS DMA ADDRESSING SUPPORTED\\n\",\n\t\t\t\tioc->name));\n\t\t} else if (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))\n\t\t\t   && !dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\t\tioc->dma_mask = DMA_BIT_MASK(32);\n\t\t\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT\n\t\t\t\t\": 32 BIT PCI BUS DMA ADDRESSING SUPPORTED\\n\",\n\t\t\t\tioc->name));\n\t\t} else {\n\t\t\tprintk(MYIOC_s_WARN_FMT \"no suitable DMA mask for %s\\n\",\n\t\t\t    ioc->name, pci_name(pdev));\n\t\t\tgoto out_pci_release_region;\n\t\t}\n\t} else {\n\t\tif (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))\n\t\t\t&& !dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\t\tioc->dma_mask = DMA_BIT_MASK(32);\n\t\t\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT\n\t\t\t\t\": 32 BIT PCI BUS DMA ADDRESSING SUPPORTED\\n\",\n\t\t\t\tioc->name));\n\t\t} else {\n\t\t\tprintk(MYIOC_s_WARN_FMT \"no suitable DMA mask for %s\\n\",\n\t\t\t    ioc->name, pci_name(pdev));\n\t\t\tgoto out_pci_release_region;\n\t\t}\n\t}\n\n\tmem_phys = msize = 0;\n\tport = psize = 0;\n\tfor (ii = 0; ii < DEVICE_COUNT_RESOURCE; ii++) {\n\t\tif (pci_resource_flags(pdev, ii) & PCI_BASE_ADDRESS_SPACE_IO) {\n\t\t\tif (psize)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tport = pci_resource_start(pdev, ii);\n\t\t\tpsize = pci_resource_len(pdev, ii);\n\t\t} else {\n\t\t\tif (msize)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tmem_phys = pci_resource_start(pdev, ii);\n\t\t\tmsize = pci_resource_len(pdev, ii);\n\t\t}\n\t}\n\tioc->mem_size = msize;\n\n\tmem = NULL;\n\t \n\t \n\tmem = ioremap(mem_phys, msize);\n\tif (mem == NULL) {\n\t\tprintk(MYIOC_s_ERR_FMT \": ERROR - Unable to map adapter\"\n\t\t\t\" memory!\\n\", ioc->name);\n\t\tr = -EINVAL;\n\t\tgoto out_pci_release_region;\n\t}\n\tioc->memmap = mem;\n\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT \"mem = %p, mem_phys = %llx\\n\",\n\t    ioc->name, mem, (unsigned long long)mem_phys));\n\n\tioc->mem_phys = mem_phys;\n\tioc->chip = (SYSIF_REGS __iomem *)mem;\n\n\t \n\tioc->pio_mem_phys = port;\n\tioc->pio_chip = (SYSIF_REGS __iomem *)port;\n\n\treturn 0;\n\nout_pci_release_region:\n\tpci_release_selected_regions(pdev, ioc->bars);\nout_pci_disable_device:\n\tpci_disable_device(pdev);\n\treturn r;\n}\n\n \n \nint\nmpt_attach(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tMPT_ADAPTER\t*ioc;\n\tu8\t\t cb_idx;\n\tint\t\t r = -ENODEV;\n\tu8\t\t pcixcmd;\n\tstatic int\t mpt_ids = 0;\n#ifdef CONFIG_PROC_FS\n\tstruct proc_dir_entry *dent;\n#endif\n\n\tioc = kzalloc(sizeof(MPT_ADAPTER), GFP_KERNEL);\n\tif (ioc == NULL) {\n\t\tprintk(KERN_ERR MYNAM \": ERROR - Insufficient memory to add adapter!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tioc->id = mpt_ids++;\n\tsprintf(ioc->name, \"ioc%d\", ioc->id);\n\tdinitprintk(ioc, printk(KERN_WARNING MYNAM \": mpt_adapter_install\\n\"));\n\n\t \n\tioc->debug_level = mpt_debug_level;\n\tif (mpt_debug_level)\n\t\tprintk(KERN_INFO \"mpt_debug_level=%xh\\n\", mpt_debug_level);\n\n\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT \": mpt_adapter_install\\n\", ioc->name));\n\n\tioc->pcidev = pdev;\n\tif (mpt_mapresources(ioc)) {\n\t\tgoto out_free_ioc;\n\t}\n\n\t \n\tif (ioc->dma_mask == DMA_BIT_MASK(64)) {\n\t\tif (pdev->device == MPI_MANUFACTPAGE_DEVID_SAS1078)\n\t\t\tioc->add_sge = &mpt_add_sge_64bit_1078;\n\t\telse\n\t\t\tioc->add_sge = &mpt_add_sge_64bit;\n\t\tioc->add_chain = &mpt_add_chain_64bit;\n\t\tioc->sg_addr_size = 8;\n\t} else {\n\t\tioc->add_sge = &mpt_add_sge;\n\t\tioc->add_chain = &mpt_add_chain;\n\t\tioc->sg_addr_size = 4;\n\t}\n\tioc->SGE_size = sizeof(u32) + ioc->sg_addr_size;\n\n\tioc->alloc_total = sizeof(MPT_ADAPTER);\n\tioc->req_sz = MPT_DEFAULT_FRAME_SIZE;\t\t \n\tioc->reply_sz = MPT_REPLY_FRAME_SIZE;\n\n\n\tspin_lock_init(&ioc->taskmgmt_lock);\n\tmutex_init(&ioc->internal_cmds.mutex);\n\tinit_completion(&ioc->internal_cmds.done);\n\tmutex_init(&ioc->mptbase_cmds.mutex);\n\tinit_completion(&ioc->mptbase_cmds.done);\n\tmutex_init(&ioc->taskmgmt_cmds.mutex);\n\tinit_completion(&ioc->taskmgmt_cmds.done);\n\n\t \n\tioc->eventTypes = 0;\t \n\tioc->eventContext = 0;\n\tioc->eventLogSize = 0;\n\tioc->events = NULL;\n\n#ifdef MFCNT\n\tioc->mfcnt = 0;\n#endif\n\n\tioc->sh = NULL;\n\tioc->cached_fw = NULL;\n\n\t \n\tmemset(&ioc->spi_data, 0, sizeof(SpiCfgData));\n\n\t \n\tINIT_LIST_HEAD(&ioc->fc_rports);\n\n\t \n\tINIT_LIST_HEAD(&ioc->list);\n\n\n\t \n\tINIT_DELAYED_WORK(&ioc->fault_reset_work, mpt_fault_reset_work);\n\n\tsnprintf(ioc->reset_work_q_name, MPT_KOBJ_NAME_LEN,\n\t\t \"mpt_poll_%d\", ioc->id);\n\tioc->reset_work_q = alloc_workqueue(ioc->reset_work_q_name,\n\t\t\t\t\t    WQ_MEM_RECLAIM, 0);\n\tif (!ioc->reset_work_q) {\n\t\tprintk(MYIOC_s_ERR_FMT \"Insufficient memory to add adapter!\\n\",\n\t\t    ioc->name);\n\t\tr = -ENOMEM;\n\t\tgoto out_unmap_resources;\n\t}\n\n\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT \"facts @ %p, pfacts[0] @ %p\\n\",\n\t    ioc->name, &ioc->facts, &ioc->pfacts[0]));\n\n\tioc->prod_name = mpt_get_product_name(pdev->vendor, pdev->device,\n\t\t\t\t\t      pdev->revision);\n\n\tswitch (pdev->device)\n\t{\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC939X:\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC949X:\n\t\tioc->errata_flag_1064 = 1;\n\t\tfallthrough;\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC909:\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC929:\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC919:\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC949E:\n\t\tioc->bus_type = FC;\n\t\tbreak;\n\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC929X:\n\t\tif (pdev->revision < XL_929) {\n\t\t\t \n\t\t\tpci_read_config_byte(pdev, 0x6a, &pcixcmd);\n\t\t\tpcixcmd &= 0x8F;\n\t\t\tpci_write_config_byte(pdev, 0x6a, pcixcmd);\n\t\t} else {\n\t\t\t \n\t\t\tpci_read_config_byte(pdev, 0x6a, &pcixcmd);\n\t\t\tpcixcmd |= 0x08;\n\t\t\tpci_write_config_byte(pdev, 0x6a, pcixcmd);\n\t\t}\n\t\tioc->bus_type = FC;\n\t\tbreak;\n\n\tcase MPI_MANUFACTPAGE_DEVICEID_FC919X:\n\t\t \n\t\tpci_read_config_byte(pdev, 0x6a, &pcixcmd);\n\t\tpcixcmd &= 0x8F;\n\t\tpci_write_config_byte(pdev, 0x6a, pcixcmd);\n\t\tioc->bus_type = FC;\n\t\tbreak;\n\n\tcase MPI_MANUFACTPAGE_DEVID_53C1030:\n\t\t \n\t\tif (pdev->revision < C0_1030) {\n\t\t\tpci_read_config_byte(pdev, 0x6a, &pcixcmd);\n\t\t\tpcixcmd &= 0x8F;\n\t\t\tpci_write_config_byte(pdev, 0x6a, pcixcmd);\n\t\t}\n\t\tfallthrough;\n\n\tcase MPI_MANUFACTPAGE_DEVID_1030_53C1035:\n\t\tioc->bus_type = SPI;\n\t\tbreak;\n\n\tcase MPI_MANUFACTPAGE_DEVID_SAS1064:\n\tcase MPI_MANUFACTPAGE_DEVID_SAS1068:\n\t\tioc->errata_flag_1064 = 1;\n\t\tioc->bus_type = SAS;\n\t\tbreak;\n\n\tcase MPI_MANUFACTPAGE_DEVID_SAS1064E:\n\tcase MPI_MANUFACTPAGE_DEVID_SAS1068E:\n\tcase MPI_MANUFACTPAGE_DEVID_SAS1078:\n\t\tioc->bus_type = SAS;\n\t\tbreak;\n\t}\n\n\n\tswitch (ioc->bus_type) {\n\n\tcase SAS:\n\t\tioc->msi_enable = mpt_msi_enable_sas;\n\t\tbreak;\n\n\tcase SPI:\n\t\tioc->msi_enable = mpt_msi_enable_spi;\n\t\tbreak;\n\n\tcase FC:\n\t\tioc->msi_enable = mpt_msi_enable_fc;\n\t\tbreak;\n\n\tdefault:\n\t\tioc->msi_enable = 0;\n\t\tbreak;\n\t}\n\n\tioc->fw_events_off = 1;\n\n\tif (ioc->errata_flag_1064)\n\t\tpci_disable_io_access(pdev);\n\n\tspin_lock_init(&ioc->FreeQlock);\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);\n\tioc->active = 0;\n\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\n\t \n\tpci_set_drvdata(ioc->pcidev, ioc);\n\n\t \n\tlist_add_tail(&ioc->list, &ioc_list);\n\n\t \n\tmpt_detect_bound_ports(ioc, pdev);\n\n\tINIT_LIST_HEAD(&ioc->fw_event_list);\n\tspin_lock_init(&ioc->fw_event_lock);\n\tsnprintf(ioc->fw_event_q_name, MPT_KOBJ_NAME_LEN, \"mpt/%d\", ioc->id);\n\tioc->fw_event_q = alloc_workqueue(ioc->fw_event_q_name,\n\t\t\t\t\t  WQ_MEM_RECLAIM, 0);\n\tif (!ioc->fw_event_q) {\n\t\tprintk(MYIOC_s_ERR_FMT \"Insufficient memory to add adapter!\\n\",\n\t\t    ioc->name);\n\t\tr = -ENOMEM;\n\t\tgoto out_remove_ioc;\n\t}\n\n\tif ((r = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_BRINGUP,\n\t    CAN_SLEEP)) != 0){\n\t\tprintk(MYIOC_s_ERR_FMT \"didn't initialize properly! (%d)\\n\",\n\t\t    ioc->name, r);\n\n\t\tdestroy_workqueue(ioc->fw_event_q);\n\t\tioc->fw_event_q = NULL;\n\n\t\tlist_del(&ioc->list);\n\t\tif (ioc->alt_ioc)\n\t\t\tioc->alt_ioc->alt_ioc = NULL;\n\t\tiounmap(ioc->memmap);\n\t\tif (pci_is_enabled(pdev))\n\t\t\tpci_disable_device(pdev);\n\t\tif (r != -5)\n\t\t\tpci_release_selected_regions(pdev, ioc->bars);\n\n\t\tdestroy_workqueue(ioc->reset_work_q);\n\t\tioc->reset_work_q = NULL;\n\n\t\tkfree(ioc);\n\t\treturn r;\n\t}\n\n\t \n\tfor(cb_idx = 0; cb_idx < MPT_MAX_PROTOCOL_DRIVERS; cb_idx++) {\n\t\tif(MptDeviceDriverHandlers[cb_idx] &&\n\t\t  MptDeviceDriverHandlers[cb_idx]->probe) {\n\t\t\tMptDeviceDriverHandlers[cb_idx]->probe(pdev);\n\t\t}\n\t}\n\n#ifdef CONFIG_PROC_FS\n\t \n\tdent = proc_mkdir(ioc->name, mpt_proc_root_dir);\n\tif (dent) {\n\t\tproc_create_single_data(\"info\", S_IRUGO, dent,\n\t\t\t\tmpt_iocinfo_proc_show, ioc);\n\t\tproc_create_single_data(\"summary\", S_IRUGO, dent,\n\t\t\t\tmpt_summary_proc_show, ioc);\n\t}\n#endif\n\n\tif (!ioc->alt_ioc)\n\t\tqueue_delayed_work(ioc->reset_work_q, &ioc->fault_reset_work,\n\t\t\tmsecs_to_jiffies(MPT_POLLING_INTERVAL));\n\n\treturn 0;\n\nout_remove_ioc:\n\tlist_del(&ioc->list);\n\tif (ioc->alt_ioc)\n\t\tioc->alt_ioc->alt_ioc = NULL;\n\n\tdestroy_workqueue(ioc->reset_work_q);\n\tioc->reset_work_q = NULL;\n\nout_unmap_resources:\n\tiounmap(ioc->memmap);\n\tpci_disable_device(pdev);\n\tpci_release_selected_regions(pdev, ioc->bars);\n\nout_free_ioc:\n\tkfree(ioc);\n\n\treturn r;\n}\n\n \n \n\nvoid\nmpt_detach(struct pci_dev *pdev)\n{\n\tMPT_ADAPTER \t*ioc = pci_get_drvdata(pdev);\n\tchar pname[64];\n\tu8 cb_idx;\n\tunsigned long flags;\n\tstruct workqueue_struct *wq;\n\n\t \n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\twq = ioc->reset_work_q;\n\tioc->reset_work_q = NULL;\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\tcancel_delayed_work(&ioc->fault_reset_work);\n\tdestroy_workqueue(wq);\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\twq = ioc->fw_event_q;\n\tioc->fw_event_q = NULL;\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n\tdestroy_workqueue(wq);\n\n\tsnprintf(pname, sizeof(pname), MPT_PROCFS_MPTBASEDIR \"/%s/summary\", ioc->name);\n\tremove_proc_entry(pname, NULL);\n\tsnprintf(pname, sizeof(pname), MPT_PROCFS_MPTBASEDIR \"/%s/info\", ioc->name);\n\tremove_proc_entry(pname, NULL);\n\tsnprintf(pname, sizeof(pname), MPT_PROCFS_MPTBASEDIR \"/%s\", ioc->name);\n\tremove_proc_entry(pname, NULL);\n\n\t \n\tfor(cb_idx = 0; cb_idx < MPT_MAX_PROTOCOL_DRIVERS; cb_idx++) {\n\t\tif(MptDeviceDriverHandlers[cb_idx] &&\n\t\t  MptDeviceDriverHandlers[cb_idx]->remove) {\n\t\t\tMptDeviceDriverHandlers[cb_idx]->remove(pdev);\n\t\t}\n\t}\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);\n\n\tioc->active = 0;\n\tsynchronize_irq(pdev->irq);\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\n\tCHIPREG_READ32(&ioc->chip->IntStatus);\n\n\tmpt_adapter_dispose(ioc);\n\n}\n\n \n#ifdef CONFIG_PM\n \n \nint\nmpt_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tu32 device_state;\n\tMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\n\n\tdevice_state = pci_choose_state(pdev, state);\n\tprintk(MYIOC_s_INFO_FMT \"pci-suspend: pdev=0x%p, slot=%s, Entering \"\n\t    \"operating state [D%d]\\n\", ioc->name, pdev, pci_name(pdev),\n\t    device_state);\n\n\t \n\tif (SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, CAN_SLEEP)) {\n\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\"pci-suspend:  IOC msg unit reset failed!\\n\", ioc->name);\n\t}\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);\n\tioc->active = 0;\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\n\tfree_irq(ioc->pci_irq, ioc);\n\tif (ioc->msi_enable)\n\t\tpci_disable_msi(ioc->pcidev);\n\tioc->pci_irq = -1;\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\tpci_release_selected_regions(pdev, ioc->bars);\n\tpci_set_power_state(pdev, device_state);\n\treturn 0;\n}\n\n \n \nint\nmpt_resume(struct pci_dev *pdev)\n{\n\tMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\n\tu32 device_state = pdev->current_state;\n\tint recovery_state;\n\tint err;\n\n\tprintk(MYIOC_s_INFO_FMT \"pci-resume: pdev=0x%p, slot=%s, Previous \"\n\t    \"operating state [D%d]\\n\", ioc->name, pdev, pci_name(pdev),\n\t    device_state);\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\tpci_restore_state(pdev);\n\tioc->pcidev = pdev;\n\terr = mpt_mapresources(ioc);\n\tif (err)\n\t\treturn err;\n\n\tif (ioc->dma_mask == DMA_BIT_MASK(64)) {\n\t\tif (pdev->device == MPI_MANUFACTPAGE_DEVID_SAS1078)\n\t\t\tioc->add_sge = &mpt_add_sge_64bit_1078;\n\t\telse\n\t\t\tioc->add_sge = &mpt_add_sge_64bit;\n\t\tioc->add_chain = &mpt_add_chain_64bit;\n\t\tioc->sg_addr_size = 8;\n\t} else {\n\n\t\tioc->add_sge = &mpt_add_sge;\n\t\tioc->add_chain = &mpt_add_chain;\n\t\tioc->sg_addr_size = 4;\n\t}\n\tioc->SGE_size = sizeof(u32) + ioc->sg_addr_size;\n\n\tprintk(MYIOC_s_INFO_FMT \"pci-resume: ioc-state=0x%x,doorbell=0x%x\\n\",\n\t    ioc->name, (mpt_GetIocState(ioc, 1) >> MPI_IOC_STATE_SHIFT),\n\t    CHIPREG_READ32(&ioc->chip->Doorbell));\n\n\t \n\tif (ioc->bus_type == SAS && (pdev->device ==\n\t    MPI_MANUFACTPAGE_DEVID_SAS1068E || pdev->device ==\n\t    MPI_MANUFACTPAGE_DEVID_SAS1064E)) {\n\t\tif (KickStart(ioc, 1, CAN_SLEEP) < 0) {\n\t\t\tprintk(MYIOC_s_WARN_FMT \"pci-resume: Cannot recover\\n\",\n\t\t\t    ioc->name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tprintk(MYIOC_s_INFO_FMT \"Sending mpt_do_ioc_recovery\\n\", ioc->name);\n\trecovery_state = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_BRINGUP,\n\t\t\t\t\t\t CAN_SLEEP);\n\tif (recovery_state != 0)\n\t\tprintk(MYIOC_s_WARN_FMT \"pci-resume: Cannot recover, \"\n\t\t    \"error:[%x]\\n\", ioc->name, recovery_state);\n\telse\n\t\tprintk(MYIOC_s_INFO_FMT\n\t\t    \"pci-resume: success\\n\", ioc->name);\n out:\n\treturn 0;\n\n}\n#endif\n\nstatic int\nmpt_signal_reset(u8 index, MPT_ADAPTER *ioc, int reset_phase)\n{\n\tif ((MptDriverClass[index] == MPTSPI_DRIVER &&\n\t     ioc->bus_type != SPI) ||\n\t    (MptDriverClass[index] == MPTFC_DRIVER &&\n\t     ioc->bus_type != FC) ||\n\t    (MptDriverClass[index] == MPTSAS_DRIVER &&\n\t     ioc->bus_type != SAS))\n\t\t \n\t\treturn 0;\n\treturn (MptResetHandlers[index])(ioc, reset_phase);\n}\n\n \n \nstatic int\nmpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason, int sleepFlag)\n{\n\tint\t hard_reset_done = 0;\n\tint\t alt_ioc_ready = 0;\n\tint\t hard;\n\tint\t rc=0;\n\tint\t ii;\n\tint\t ret = 0;\n\tint\t reset_alt_ioc_active = 0;\n\tint\t irq_allocated = 0;\n\tu8\t*a;\n\n\tprintk(MYIOC_s_INFO_FMT \"Initiating %s\\n\", ioc->name,\n\t    reason == MPT_HOSTEVENT_IOC_BRINGUP ? \"bringup\" : \"recovery\");\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);\n\tioc->active = 0;\n\n\tif (ioc->alt_ioc) {\n\t\tif (ioc->alt_ioc->active ||\n\t\t    reason == MPT_HOSTEVENT_IOC_RECOVER) {\n\t\t\treset_alt_ioc_active = 1;\n\t\t\t \n\t\t\tCHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask,\n\t\t\t\t0xFFFFFFFF);\n\t\t\tioc->alt_ioc->active = 0;\n\t\t}\n\t}\n\n\thard = 1;\n\tif (reason == MPT_HOSTEVENT_IOC_BRINGUP)\n\t\thard = 0;\n\n\tif ((hard_reset_done = MakeIocReady(ioc, hard, sleepFlag)) < 0) {\n\t\tif (hard_reset_done == -4) {\n\t\t\tprintk(MYIOC_s_WARN_FMT \"Owned by PEER..skipping!\\n\",\n\t\t\t    ioc->name);\n\n\t\t\tif (reset_alt_ioc_active && ioc->alt_ioc) {\n\t\t\t\t \n\t\t\t\tdprintk(ioc, printk(MYIOC_s_INFO_FMT\n\t\t\t\t    \"alt_ioc reply irq re-enabled\\n\", ioc->alt_ioc->name));\n\t\t\t\tCHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, MPI_HIM_DIM);\n\t\t\t\tioc->alt_ioc->active = 1;\n\t\t\t}\n\n\t\t} else {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t    \"NOT READY WARNING!\\n\", ioc->name);\n\t\t}\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (hard_reset_done && reset_alt_ioc_active && ioc->alt_ioc) {\n\t\tif ((rc = MakeIocReady(ioc->alt_ioc, 0, sleepFlag)) == 0)\n\t\t\talt_ioc_ready = 1;\n\t\telse\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t    \": alt-ioc Not ready WARNING!\\n\",\n\t\t\t    ioc->alt_ioc->name);\n\t}\n\n\tfor (ii=0; ii<5; ii++) {\n\t\t \n\t\tif ((rc = GetIocFacts(ioc, sleepFlag, reason)) == 0)\n\t\t\tbreak;\n\t}\n\n\n\tif (ii == 5) {\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"Retry IocFacts failed rc=%x\\n\", ioc->name, rc));\n\t\tret = -2;\n\t} else if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {\n\t\tMptDisplayIocCapabilities(ioc);\n\t}\n\n\tif (alt_ioc_ready) {\n\t\tif ((rc = GetIocFacts(ioc->alt_ioc, sleepFlag, reason)) != 0) {\n\t\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t    \"Initial Alt IocFacts failed rc=%x\\n\",\n\t\t\t    ioc->name, rc));\n\t\t\t \n\t\t\trc = GetIocFacts(ioc->alt_ioc, sleepFlag, reason);\n\t\t}\n\t\tif (rc) {\n\t\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t    \"Retry Alt IocFacts failed rc=%x\\n\", ioc->name, rc));\n\t\t\talt_ioc_ready = 0;\n\t\t\treset_alt_ioc_active = 0;\n\t\t} else if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {\n\t\t\tMptDisplayIocCapabilities(ioc->alt_ioc);\n\t\t}\n\t}\n\n\tif ((ret == 0) && (reason == MPT_HOSTEVENT_IOC_BRINGUP) &&\n\t    (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT)) {\n\t\tpci_release_selected_regions(ioc->pcidev, ioc->bars);\n\t\tioc->bars = pci_select_bars(ioc->pcidev, IORESOURCE_MEM |\n\t\t    IORESOURCE_IO);\n\t\tif (pci_enable_device(ioc->pcidev))\n\t\t\treturn -5;\n\t\tif (pci_request_selected_regions(ioc->pcidev, ioc->bars,\n\t\t\t\"mpt\"))\n\t\t\treturn -5;\n\t}\n\n\t \n\tif ((ret == 0) && (reason == MPT_HOSTEVENT_IOC_BRINGUP)) {\n\t\tioc->pci_irq = -1;\n\t\tif (ioc->pcidev->irq) {\n\t\t\tif (ioc->msi_enable && !pci_enable_msi(ioc->pcidev))\n\t\t\t\tprintk(MYIOC_s_INFO_FMT \"PCI-MSI enabled\\n\",\n\t\t\t\t    ioc->name);\n\t\t\telse\n\t\t\t\tioc->msi_enable = 0;\n\t\t\trc = request_irq(ioc->pcidev->irq, mpt_interrupt,\n\t\t\t    IRQF_SHARED, ioc->name, ioc);\n\t\t\tif (rc < 0) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"Unable to allocate \"\n\t\t\t\t    \"interrupt %d!\\n\",\n\t\t\t\t    ioc->name, ioc->pcidev->irq);\n\t\t\t\tif (ioc->msi_enable)\n\t\t\t\t\tpci_disable_msi(ioc->pcidev);\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tirq_allocated = 1;\n\t\t\tioc->pci_irq = ioc->pcidev->irq;\n\t\t\tpci_set_master(ioc->pcidev);\t\t \n\t\t\tpci_set_drvdata(ioc->pcidev, ioc);\n\t\t\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT\n\t\t\t    \"installed at interrupt %d\\n\", ioc->name,\n\t\t\t    ioc->pcidev->irq));\n\t\t}\n\t}\n\n\t \n\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT \"PrimeIocFifos\\n\",\n\t    ioc->name));\n\tif ((ret == 0) && ((rc = PrimeIocFifos(ioc)) != 0))\n\t\tret = -3;\n\n\t \n\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT \"SendIocInit\\n\",\n\t    ioc->name));\n\tif ((ret == 0) && ((rc = SendIocInit(ioc, sleepFlag)) != 0))\n\t\tret = -4;\n\n\tif (alt_ioc_ready && ((rc = PrimeIocFifos(ioc->alt_ioc)) != 0)) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t    \": alt-ioc (%d) FIFO mgmt alloc WARNING!\\n\",\n\t\t    ioc->alt_ioc->name, rc);\n\t\talt_ioc_ready = 0;\n\t\treset_alt_ioc_active = 0;\n\t}\n\n\tif (alt_ioc_ready) {\n\t\tif ((rc = SendIocInit(ioc->alt_ioc, sleepFlag)) != 0) {\n\t\t\talt_ioc_ready = 0;\n\t\t\treset_alt_ioc_active = 0;\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\t\": alt-ioc: (%d) init failure WARNING!\\n\",\n\t\t\t\t\tioc->alt_ioc->name, rc);\n\t\t}\n\t}\n\n\tif (reason == MPT_HOSTEVENT_IOC_BRINGUP){\n\t\tif (ioc->upload_fw) {\n\t\t\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t    \"firmware upload required!\\n\", ioc->name));\n\n\t\t\t \n\t\t\tif (ret == 0) {\n\t\t\t\trc = mpt_do_upload(ioc, sleepFlag);\n\t\t\t\tif (rc == 0) {\n\t\t\t\t\tif (ioc->alt_ioc && ioc->alt_ioc->cached_fw) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\t    \"mpt_upload:  alt_%s has cached_fw=%p \\n\",\n\t\t\t\t\t\t    ioc->name, ioc->alt_ioc->name, ioc->alt_ioc->cached_fw));\n\t\t\t\t\t\tioc->cached_fw = NULL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\t\t    \"firmware upload failure!\\n\", ioc->name);\n\t\t\t\t\tret = -6;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((ret == 0) && (!ioc->facts.EventState)) {\n\t\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT\n\t\t\t\"SendEventNotification\\n\",\n\t\t    ioc->name));\n\t\tret = SendEventNotification(ioc, 1, sleepFlag);\t \n\t}\n\n\tif (ioc->alt_ioc && alt_ioc_ready && !ioc->alt_ioc->facts.EventState)\n\t\trc = SendEventNotification(ioc->alt_ioc, 1, sleepFlag);\n\n\tif (ret == 0) {\n\t\t \n\t\tCHIPREG_WRITE32(&ioc->chip->IntMask, MPI_HIM_DIM);\n\t\tioc->active = 1;\n\t}\n\tif (rc == 0) {\t \n\t\tif (reset_alt_ioc_active && ioc->alt_ioc) {\n\t\t\t \n\t\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"alt-ioc\"\n\t\t\t\t\"reply irq re-enabled\\n\",\n\t\t\t\tioc->alt_ioc->name));\n\t\t\tCHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask,\n\t\t\t\tMPI_HIM_DIM);\n\t\t\tioc->alt_ioc->active = 1;\n\t\t}\n\t}\n\n\n\t \n\tif ((ret == 0) && (reason == MPT_HOSTEVENT_IOC_BRINGUP)) {\n\n\t\t \n\t\tmutex_init(&ioc->raid_data.inactive_list_mutex);\n\t\tINIT_LIST_HEAD(&ioc->raid_data.inactive_list);\n\n\t\tswitch (ioc->bus_type) {\n\n\t\tcase SAS:\n\t\t\t \n\t\t\tif(ioc->facts.IOCExceptions &\n\t\t\t    MPI_IOCFACTS_EXCEPT_PERSISTENT_TABLE_FULL) {\n\t\t\t\tret = mptbase_sas_persist_operation(ioc,\n\t\t\t\t    MPI_SAS_OP_CLEAR_NOT_PRESENT);\n\t\t\t\tif(ret != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tmpt_findImVolumes(ioc);\n\n\t\t\t \n\t\t\tmpt_read_ioc_pg_1(ioc);\n\n\t\t\tbreak;\n\n\t\tcase FC:\n\t\t\tif ((ioc->pfacts[0].ProtocolFlags &\n\t\t\t\tMPI_PORTFACTS_PROTOCOL_LAN) &&\n\t\t\t    (ioc->lan_cnfg_page0.Header.PageLength == 0)) {\n\t\t\t\t \n\t\t\t\t(void) GetLanConfigPages(ioc);\n\t\t\t\ta = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\n\t\t\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\"LanAddr = %pMR\\n\", ioc->name, a));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SPI:\n\t\t\t \n\t\t\tmpt_GetScsiPortSettings(ioc, 0);\n\n\t\t\t \n\t\t\tmpt_readScsiDevicePageHeaders(ioc, 0);\n\n\t\t\t \n\t\t\tif (ioc->facts.MsgVersion >= MPI_VERSION_01_02)\n\t\t\t\tmpt_findImVolumes(ioc);\n\n\t\t\t \n\t\t\tmpt_read_ioc_pg_1(ioc);\n\n\t\t\tmpt_read_ioc_pg_4(ioc);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tGetIoUnitPage2(ioc);\n\t\tmpt_get_manufacturing_pg_0(ioc);\n\t}\n\n out:\n\tif ((ret != 0) && irq_allocated) {\n\t\tfree_irq(ioc->pci_irq, ioc);\n\t\tif (ioc->msi_enable)\n\t\t\tpci_disable_msi(ioc->pcidev);\n\t}\n\treturn ret;\n}\n\n \n \nstatic void\nmpt_detect_bound_ports(MPT_ADAPTER *ioc, struct pci_dev *pdev)\n{\n\tstruct pci_dev *peer=NULL;\n\tunsigned int slot = PCI_SLOT(pdev->devfn);\n\tunsigned int func = PCI_FUNC(pdev->devfn);\n\tMPT_ADAPTER *ioc_srch;\n\n\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"PCI device %s devfn=%x/%x,\"\n\t    \" searching for devfn match on %x or %x\\n\",\n\t    ioc->name, pci_name(pdev), pdev->bus->number,\n\t    pdev->devfn, func-1, func+1));\n\n\tpeer = pci_get_slot(pdev->bus, PCI_DEVFN(slot,func-1));\n\tif (!peer) {\n\t\tpeer = pci_get_slot(pdev->bus, PCI_DEVFN(slot,func+1));\n\t\tif (!peer)\n\t\t\treturn;\n\t}\n\n\tlist_for_each_entry(ioc_srch, &ioc_list, list) {\n\t\tstruct pci_dev *_pcidev = ioc_srch->pcidev;\n\t\tif (_pcidev == peer) {\n\t\t\t \n\t\t\tif (ioc->alt_ioc != NULL) {\n\t\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\t    \"Oops, already bound (%s <==> %s)!\\n\",\n\t\t\t\t    ioc->name, ioc->name, ioc->alt_ioc->name);\n\t\t\t\tbreak;\n\t\t\t} else if (ioc_srch->alt_ioc != NULL) {\n\t\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\t    \"Oops, already bound (%s <==> %s)!\\n\",\n\t\t\t\t    ioc_srch->name, ioc_srch->name,\n\t\t\t\t    ioc_srch->alt_ioc->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\"FOUND! binding %s <==> %s\\n\",\n\t\t\t\tioc->name, ioc->name, ioc_srch->name));\n\t\t\tioc_srch->alt_ioc = ioc;\n\t\t\tioc->alt_ioc = ioc_srch;\n\t\t}\n\t}\n\tpci_dev_put(peer);\n}\n\n \n \nstatic void\nmpt_adapter_disable(MPT_ADAPTER *ioc)\n{\n\tint sz;\n\tint ret;\n\n\tif (ioc->cached_fw != NULL) {\n\t\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"%s: Pushing FW onto adapter\\n\", __func__, ioc->name));\n\t\tif ((ret = mpt_downloadboot(ioc, (MpiFwHeader_t *)\n\t\t    ioc->cached_fw, CAN_SLEEP)) < 0) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t    \": firmware downloadboot failure (%d)!\\n\",\n\t\t\t    ioc->name, ret);\n\t\t}\n\t}\n\n\t \n\tif (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_READY) {\n\t\tif (!SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET,\n\t\t    CAN_SLEEP)) {\n\t\t\tif (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_READY)\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s:  IOC msg unit \"\n\t\t\t\t    \"reset failed to put ioc in ready state!\\n\",\n\t\t\t\t    ioc->name, __func__);\n\t\t} else\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s:  IOC msg unit reset \"\n\t\t\t    \"failed!\\n\", ioc->name, __func__);\n\t}\n\n\n\t \n\tsynchronize_irq(ioc->pcidev->irq);\n\tCHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);\n\tioc->active = 0;\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\tCHIPREG_READ32(&ioc->chip->IntStatus);\n\n\tif (ioc->alloc != NULL) {\n\t\tsz = ioc->alloc_sz;\n\t\tdexitprintk(ioc, printk(MYIOC_s_INFO_FMT \"free  @ %p, sz=%d bytes\\n\",\n\t\t    ioc->name, ioc->alloc, ioc->alloc_sz));\n\t\tdma_free_coherent(&ioc->pcidev->dev, sz, ioc->alloc,\n\t\t\t\tioc->alloc_dma);\n\t\tioc->reply_frames = NULL;\n\t\tioc->req_frames = NULL;\n\t\tioc->alloc = NULL;\n\t\tioc->alloc_total -= sz;\n\t}\n\n\tif (ioc->sense_buf_pool != NULL) {\n\t\tsz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);\n\t\tdma_free_coherent(&ioc->pcidev->dev, sz, ioc->sense_buf_pool,\n\t\t\t\tioc->sense_buf_pool_dma);\n\t\tioc->sense_buf_pool = NULL;\n\t\tioc->alloc_total -= sz;\n\t}\n\n\tif (ioc->events != NULL){\n\t\tsz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);\n\t\tkfree(ioc->events);\n\t\tioc->events = NULL;\n\t\tioc->alloc_total -= sz;\n\t}\n\n\tmpt_free_fw_memory(ioc);\n\n\tkfree(ioc->spi_data.nvram);\n\tmpt_inactive_raid_list_free(ioc);\n\tkfree(ioc->raid_data.pIocPg2);\n\tkfree(ioc->raid_data.pIocPg3);\n\tioc->spi_data.nvram = NULL;\n\tioc->raid_data.pIocPg3 = NULL;\n\n\tif (ioc->spi_data.pIocPg4 != NULL) {\n\t\tsz = ioc->spi_data.IocPg4Sz;\n\t\tdma_free_coherent(&ioc->pcidev->dev, sz,\n\t\t\t\t  ioc->spi_data.pIocPg4,\n\t\t\t\t  ioc->spi_data.IocPg4_dma);\n\t\tioc->spi_data.pIocPg4 = NULL;\n\t\tioc->alloc_total -= sz;\n\t}\n\n\tif (ioc->ReqToChain != NULL) {\n\t\tkfree(ioc->ReqToChain);\n\t\tkfree(ioc->RequestNB);\n\t\tioc->ReqToChain = NULL;\n\t}\n\n\tkfree(ioc->ChainToChain);\n\tioc->ChainToChain = NULL;\n\n\tif (ioc->HostPageBuffer != NULL) {\n\t\tif((ret = mpt_host_page_access_control(ioc,\n\t\t    MPI_DB_HPBAC_FREE_BUFFER, NO_SLEEP)) != 0) {\n\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t   \": %s: host page buffers free failed (%d)!\\n\",\n\t\t\t    ioc->name, __func__, ret);\n\t\t}\n\t\tdexitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"HostPageBuffer free  @ %p, sz=%d bytes\\n\",\n\t\t\tioc->name, ioc->HostPageBuffer,\n\t\t\tioc->HostPageBuffer_sz));\n\t\tdma_free_coherent(&ioc->pcidev->dev, ioc->HostPageBuffer_sz,\n\t\t    ioc->HostPageBuffer, ioc->HostPageBuffer_dma);\n\t\tioc->HostPageBuffer = NULL;\n\t\tioc->HostPageBuffer_sz = 0;\n\t\tioc->alloc_total -= ioc->HostPageBuffer_sz;\n\t}\n\n\tpci_set_drvdata(ioc->pcidev, NULL);\n}\n \n \nstatic void\nmpt_adapter_dispose(MPT_ADAPTER *ioc)\n{\n\tint sz_first, sz_last;\n\n\tif (ioc == NULL)\n\t\treturn;\n\n\tsz_first = ioc->alloc_total;\n\n\tmpt_adapter_disable(ioc);\n\n\tif (ioc->pci_irq != -1) {\n\t\tfree_irq(ioc->pci_irq, ioc);\n\t\tif (ioc->msi_enable)\n\t\t\tpci_disable_msi(ioc->pcidev);\n\t\tioc->pci_irq = -1;\n\t}\n\n\tif (ioc->memmap != NULL) {\n\t\tiounmap(ioc->memmap);\n\t\tioc->memmap = NULL;\n\t}\n\n\tpci_disable_device(ioc->pcidev);\n\tpci_release_selected_regions(ioc->pcidev, ioc->bars);\n\n\t \n\tlist_del(&ioc->list);\n\n\tsz_last = ioc->alloc_total;\n\tdprintk(ioc, printk(MYIOC_s_INFO_FMT \"free'd %d of %d bytes\\n\",\n\t    ioc->name, sz_first-sz_last+(int)sizeof(*ioc), sz_first));\n\n\tif (ioc->alt_ioc)\n\t\tioc->alt_ioc->alt_ioc = NULL;\n\n\tkfree(ioc);\n}\n\n \n \nstatic void\nMptDisplayIocCapabilities(MPT_ADAPTER *ioc)\n{\n\tint i = 0;\n\n\tprintk(KERN_INFO \"%s: \", ioc->name);\n\tif (ioc->prod_name)\n\t\tpr_cont(\"%s: \", ioc->prod_name);\n\tpr_cont(\"Capabilities={\");\n\n\tif (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_INITIATOR) {\n\t\tpr_cont(\"Initiator\");\n\t\ti++;\n\t}\n\n\tif (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_TARGET) {\n\t\tpr_cont(\"%sTarget\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) {\n\t\tpr_cont(\"%sLAN\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n#if 0\n\t \n\tif (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_TARGET) {\n\t\tpr_cont(\"%sLogBusAddr\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n#endif\n\n\tpr_cont(\"}\\n\");\n}\n\n \n \nstatic int\nMakeIocReady(MPT_ADAPTER *ioc, int force, int sleepFlag)\n{\n\tu32\t ioc_state;\n\tint\t statefault = 0;\n\tint\t cntdn;\n\tint\t hard_reset_done = 0;\n\tint\t r;\n\tint\t ii;\n\tint\t whoinit;\n\n\t \n\tioc_state = mpt_GetIocState(ioc, 0);\n\tdhsprintk(ioc, printk(MYIOC_s_INFO_FMT \"MakeIocReady [raw] state=%08x\\n\", ioc->name, ioc_state));\n\n\t \n\tif (ioc_state & MPI_DOORBELL_ACTIVE) {\n\t\tstatefault = 1;\n\t\tprintk(MYIOC_s_WARN_FMT \"Unexpected doorbell active!\\n\",\n\t\t\t\tioc->name);\n\t}\n\n\t \n\tif (!statefault &&\n\t    ((ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_READY)) {\n\t\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT\n\t\t    \"IOC is in READY state\\n\", ioc->name));\n\t\treturn 0;\n\t}\n\n\t \n\tif ((ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_FAULT) {\n\t\tstatefault = 2;\n\t\tprintk(MYIOC_s_WARN_FMT \"IOC is in FAULT state!!!\\n\",\n\t\t    ioc->name);\n\t\tprintk(MYIOC_s_WARN_FMT \"           FAULT code = %04xh\\n\",\n\t\t    ioc->name, ioc_state & MPI_DOORBELL_DATA_MASK);\n\t}\n\n\t \n\tif ((ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_OPERATIONAL) {\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"IOC operational unexpected\\n\",\n\t\t\t\tioc->name));\n\n\t\t \n\t\twhoinit = (ioc_state & MPI_DOORBELL_WHO_INIT_MASK) >> MPI_DOORBELL_WHO_INIT_SHIFT;\n\t\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT\n\t\t\t\"whoinit 0x%x statefault %d force %d\\n\",\n\t\t\tioc->name, whoinit, statefault, force));\n\t\tif (whoinit == MPI_WHOINIT_PCI_PEER)\n\t\t\treturn -4;\n\t\telse {\n\t\t\tif ((statefault == 0 ) && (force == 0)) {\n\t\t\t\tif ((r = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag)) == 0)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstatefault = 3;\n\t\t}\n\t}\n\n\thard_reset_done = KickStart(ioc, statefault||force, sleepFlag);\n\tif (hard_reset_done < 0)\n\t\treturn -1;\n\n\t \n\tii = 0;\n\tcntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * 5;\t \n\n\twhile ((ioc_state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {\n\t\tif (ioc_state == MPI_IOC_STATE_OPERATIONAL) {\n\t\t\t \n\t\t\tif ((r = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag)) != 0) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"IOC msg unit reset failed!\\n\", ioc->name);\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t} else if (ioc_state == MPI_IOC_STATE_RESET) {\n\t\t\t \n\t\t\tif ((r = SendIocReset(ioc, MPI_FUNCTION_IO_UNIT_RESET, sleepFlag)) != 0) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"IO unit reset failed!\\n\", ioc->name);\n\t\t\t\treturn -3;\n\t\t\t}\n\t\t}\n\n\t\tii++; cntdn--;\n\t\tif (!cntdn) {\n\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t\t\"Wait IOC_READY state (0x%x) timeout(%d)!\\n\",\n\t\t\t\tioc->name, ioc_state, (int)((ii+5)/HZ));\n\t\t\treturn -ETIME;\n\t\t}\n\n\t\tif (sleepFlag == CAN_SLEEP) {\n\t\t\tmsleep(1);\n\t\t} else {\n\t\t\tmdelay (1);\t \n\t\t}\n\n\t}\n\n\tif (statefault < 3) {\n\t\tprintk(MYIOC_s_INFO_FMT \"Recovered from %s\\n\", ioc->name,\n\t\t\tstatefault == 1 ? \"stuck handshake\" : \"IOC FAULT\");\n\t}\n\n\treturn hard_reset_done;\n}\n\n \n \nu32\nmpt_GetIocState(MPT_ADAPTER *ioc, int cooked)\n{\n\tu32 s, sc;\n\n\t \n\ts = CHIPREG_READ32(&ioc->chip->Doorbell);\n\tsc = s & MPI_IOC_STATE_MASK;\n\n\t \n\tioc->last_state = sc;\n\n\treturn cooked ? sc : s;\n}\n\n \n \nstatic int\nGetIocFacts(MPT_ADAPTER *ioc, int sleepFlag, int reason)\n{\n\tIOCFacts_t\t\t get_facts;\n\tIOCFactsReply_t\t\t*facts;\n\tint\t\t\t r;\n\tint\t\t\t req_sz;\n\tint\t\t\t reply_sz;\n\tint\t\t\t sz;\n\tu32\t\t\t vv;\n\tu8\t\t\t shiftFactor=1;\n\n\t \n\tif (ioc->last_state == MPI_IOC_STATE_RESET) {\n\t\tprintk(KERN_ERR MYNAM\n\t\t    \": ERROR - Can't get IOCFacts, %s NOT READY! (%08x)\\n\",\n\t\t    ioc->name, ioc->last_state);\n\t\treturn -44;\n\t}\n\n\tfacts = &ioc->facts;\n\n\t \n\treply_sz = sizeof(*facts);\n\tmemset(facts, 0, reply_sz);\n\n\t \n\treq_sz = sizeof(get_facts);\n\tmemset(&get_facts, 0, req_sz);\n\n\tget_facts.Function = MPI_FUNCTION_IOC_FACTS;\n\t \n\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"Sending get IocFacts request req_sz=%d reply_sz=%d\\n\",\n\t    ioc->name, req_sz, reply_sz));\n\n\t \n\tr = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&get_facts,\n\t\t\treply_sz, (u16*)facts, 5  , sleepFlag);\n\tif (r != 0)\n\t\treturn r;\n\n\t \n\t \n\tif (facts->MsgLength > offsetof(IOCFactsReply_t, RequestFrameSize)/sizeof(u32)) {\n\t\tif (reason == MPT_HOSTEVENT_IOC_BRINGUP) {\n\t\t\t \n\t\t\tif (ioc->FirstWhoInit == WHOINIT_UNKNOWN)\n\t\t\t\tioc->FirstWhoInit = facts->WhoInit;\n\t\t}\n\n\t\tfacts->MsgVersion = le16_to_cpu(facts->MsgVersion);\n\t\tfacts->MsgContext = le32_to_cpu(facts->MsgContext);\n\t\tfacts->IOCExceptions = le16_to_cpu(facts->IOCExceptions);\n\t\tfacts->IOCStatus = le16_to_cpu(facts->IOCStatus);\n\t\tfacts->IOCLogInfo = le32_to_cpu(facts->IOCLogInfo);\n\t\t \n\n\t\tfacts->ReplyQueueDepth = le16_to_cpu(facts->ReplyQueueDepth);\n\t\tfacts->RequestFrameSize = le16_to_cpu(facts->RequestFrameSize);\n\n\t\t \n\t\tif (facts->MsgVersion < MPI_VERSION_01_02) {\n\t\t\t \n\t\t\tu16\t oldv = le16_to_cpu(facts->Reserved_0101_FWVersion);\n\t\t\tfacts->FWVersion.Word =\n\t\t\t\t\t((oldv<<12) & 0xFF000000) |\n\t\t\t\t\t((oldv<<8)  & 0x000FFF00);\n\t\t} else\n\t\t\tfacts->FWVersion.Word = le32_to_cpu(facts->FWVersion.Word);\n\n\t\tfacts->ProductID = le16_to_cpu(facts->ProductID);\n\n\t\tif ((ioc->facts.ProductID & MPI_FW_HEADER_PID_PROD_MASK)\n\t\t    > MPI_FW_HEADER_PID_PROD_TARGET_SCSI)\n\t\t\tioc->ir_firmware = 1;\n\n\t\tfacts->CurrentHostMfaHighAddr =\n\t\t\t\tle32_to_cpu(facts->CurrentHostMfaHighAddr);\n\t\tfacts->GlobalCredits = le16_to_cpu(facts->GlobalCredits);\n\t\tfacts->CurrentSenseBufferHighAddr =\n\t\t\t\tle32_to_cpu(facts->CurrentSenseBufferHighAddr);\n\t\tfacts->CurReplyFrameSize =\n\t\t\t\tle16_to_cpu(facts->CurReplyFrameSize);\n\t\tfacts->IOCCapabilities = le32_to_cpu(facts->IOCCapabilities);\n\n\t\t \n\t\tif (facts->MsgLength >= (offsetof(IOCFactsReply_t,FWImageSize) + 7)/4 &&\n\t\t    facts->MsgVersion > MPI_VERSION_01_00) {\n\t\t\tfacts->FWImageSize = le32_to_cpu(facts->FWImageSize);\n\t\t}\n\n\t\tfacts->FWImageSize = ALIGN(facts->FWImageSize, 4);\n\n\t\tif (!facts->RequestFrameSize) {\n\t\t\t \n\t\t\tprintk(MYIOC_s_ERR_FMT \"IOC reported invalid 0 request size!\\n\",\n\t\t\t\t\tioc->name);\n\t\t\treturn -55;\n\t\t}\n\n\t\tr = sz = facts->BlockSize;\n\t\tvv = ((63 / (sz * 4)) + 1) & 0x03;\n\t\tioc->NB_for_64_byte_frame = vv;\n\t\twhile ( sz )\n\t\t{\n\t\t\tshiftFactor++;\n\t\t\tsz = sz >> 1;\n\t\t}\n\t\tioc->NBShiftFactor  = shiftFactor;\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"NB_for_64_byte_frame=%x NBShiftFactor=%x BlockSize=%x\\n\",\n\t\t    ioc->name, vv, shiftFactor, r));\n\n\t\tif (reason == MPT_HOSTEVENT_IOC_BRINGUP) {\n\t\t\t \n\t\t\tioc->req_sz = min(MPT_DEFAULT_FRAME_SIZE, facts->RequestFrameSize * 4);\n\t\t\tioc->req_depth = min_t(int, MPT_MAX_REQ_DEPTH, facts->GlobalCredits);\n\t\t\tioc->reply_sz = MPT_REPLY_FRAME_SIZE;\n\t\t\tioc->reply_depth = min_t(int, MPT_DEFAULT_REPLY_DEPTH, facts->ReplyQueueDepth);\n\n\t\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"reply_sz=%3d, reply_depth=%4d\\n\",\n\t\t\t\tioc->name, ioc->reply_sz, ioc->reply_depth));\n\t\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"req_sz  =%3d, req_depth  =%4d\\n\",\n\t\t\t\tioc->name, ioc->req_sz, ioc->req_depth));\n\n\t\t\t \n\t\t\tif ( (r = GetPortFacts(ioc, 0, sleepFlag)) != 0 )\n\t\t\t\treturn r;\n\t\t}\n\t} else {\n\t\tprintk(MYIOC_s_ERR_FMT\n\t\t     \"Invalid IOC facts reply, msgLength=%d offsetof=%zd!\\n\",\n\t\t     ioc->name, facts->MsgLength, (offsetof(IOCFactsReply_t,\n\t\t     RequestFrameSize)/sizeof(u32)));\n\t\treturn -66;\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic int\nGetPortFacts(MPT_ADAPTER *ioc, int portnum, int sleepFlag)\n{\n\tPortFacts_t\t\t get_pfacts;\n\tPortFactsReply_t\t*pfacts;\n\tint\t\t\t ii;\n\tint\t\t\t req_sz;\n\tint\t\t\t reply_sz;\n\tint\t\t\t max_id;\n\n\t \n\tif (ioc->last_state == MPI_IOC_STATE_RESET) {\n\t\tprintk(MYIOC_s_ERR_FMT \"Can't get PortFacts NOT READY! (%08x)\\n\",\n\t\t    ioc->name, ioc->last_state );\n\t\treturn -4;\n\t}\n\n\tpfacts = &ioc->pfacts[portnum];\n\n\t \n\treply_sz = sizeof(*pfacts);\n\tmemset(pfacts, 0, reply_sz);\n\n\t \n\treq_sz = sizeof(get_pfacts);\n\tmemset(&get_pfacts, 0, req_sz);\n\n\tget_pfacts.Function = MPI_FUNCTION_PORT_FACTS;\n\tget_pfacts.PortNumber = portnum;\n\t \n\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Sending get PortFacts(%d) request\\n\",\n\t\t\tioc->name, portnum));\n\n\t \n\tii = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&get_pfacts,\n\t\t\t\treply_sz, (u16*)pfacts, 5  , sleepFlag);\n\tif (ii != 0)\n\t\treturn ii;\n\n\t \n\n\t \n\tpfacts->MsgContext = le32_to_cpu(pfacts->MsgContext);\n\tpfacts->IOCStatus = le16_to_cpu(pfacts->IOCStatus);\n\tpfacts->IOCLogInfo = le32_to_cpu(pfacts->IOCLogInfo);\n\tpfacts->MaxDevices = le16_to_cpu(pfacts->MaxDevices);\n\tpfacts->PortSCSIID = le16_to_cpu(pfacts->PortSCSIID);\n\tpfacts->ProtocolFlags = le16_to_cpu(pfacts->ProtocolFlags);\n\tpfacts->MaxPostedCmdBuffers = le16_to_cpu(pfacts->MaxPostedCmdBuffers);\n\tpfacts->MaxPersistentIDs = le16_to_cpu(pfacts->MaxPersistentIDs);\n\tpfacts->MaxLanBuckets = le16_to_cpu(pfacts->MaxLanBuckets);\n\n\tmax_id = (ioc->bus_type == SAS) ? pfacts->PortSCSIID :\n\t    pfacts->MaxDevices;\n\tioc->devices_per_bus = (max_id > 255) ? 256 : max_id;\n\tioc->number_of_buses = (ioc->devices_per_bus < 256) ? 1 : max_id/256;\n\n\t \n\tif (mpt_channel_mapping) {\n\t\tioc->devices_per_bus = 1;\n\t\tioc->number_of_buses = (max_id > 255) ? 255 : max_id;\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic int\nSendIocInit(MPT_ADAPTER *ioc, int sleepFlag)\n{\n\tIOCInit_t\t\t ioc_init;\n\tMPIDefaultReply_t\t init_reply;\n\tu32\t\t\t state;\n\tint\t\t\t r;\n\tint\t\t\t count;\n\tint\t\t\t cntdn;\n\n\tmemset(&ioc_init, 0, sizeof(ioc_init));\n\tmemset(&init_reply, 0, sizeof(init_reply));\n\n\tioc_init.WhoInit = MPI_WHOINIT_HOST_DRIVER;\n\tioc_init.Function = MPI_FUNCTION_IOC_INIT;\n\n\t \n\tif (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT)\n\t\tioc->upload_fw = 1;\n\telse\n\t\tioc->upload_fw = 0;\n\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"upload_fw %d facts.Flags=%x\\n\",\n\t\t   ioc->name, ioc->upload_fw, ioc->facts.Flags));\n\n\tioc_init.MaxDevices = (U8)ioc->devices_per_bus;\n\tioc_init.MaxBuses = (U8)ioc->number_of_buses;\n\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"facts.MsgVersion=%x\\n\",\n\t\t   ioc->name, ioc->facts.MsgVersion));\n\tif (ioc->facts.MsgVersion >= MPI_VERSION_01_05) {\n\t\t\n\t\tioc_init.MsgVersion = cpu_to_le16(MPI_VERSION);\n\t        ioc_init.HeaderVersion = cpu_to_le16(MPI_HEADER_VERSION);\n\n\t\tif (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_HOST_PAGE_BUFFER_PERSISTENT) {\n\t\t\tioc_init.HostPageBufferSGE = ioc->facts.HostPageBufferSGE;\n\t\t} else if(mpt_host_page_alloc(ioc, &ioc_init))\n\t\t\treturn -99;\n\t}\n\tioc_init.ReplyFrameSize = cpu_to_le16(ioc->reply_sz);\t \n\n\tif (ioc->sg_addr_size == sizeof(u64)) {\n\t\t \n\t\tioc_init.HostMfaHighAddr = cpu_to_le32((u32)((u64)ioc->alloc_dma >> 32));\n\t\tioc_init.SenseBufferHighAddr = cpu_to_le32((u32)((u64)ioc->sense_buf_pool_dma >> 32));\n\t} else {\n\t\t \n\t\tioc_init.HostMfaHighAddr = cpu_to_le32(0);\n\t\tioc_init.SenseBufferHighAddr = cpu_to_le32(0);\n\t}\n\n\tioc->facts.CurrentHostMfaHighAddr = ioc_init.HostMfaHighAddr;\n\tioc->facts.CurrentSenseBufferHighAddr = ioc_init.SenseBufferHighAddr;\n\tioc->facts.MaxDevices = ioc_init.MaxDevices;\n\tioc->facts.MaxBuses = ioc_init.MaxBuses;\n\n\tdhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Sending IOCInit (req @ %p)\\n\",\n\t\t\tioc->name, &ioc_init));\n\n\tr = mpt_handshake_req_reply_wait(ioc, sizeof(IOCInit_t), (u32*)&ioc_init,\n\t\t\t\tsizeof(MPIDefaultReply_t), (u16*)&init_reply, 10  , sleepFlag);\n\tif (r != 0) {\n\t\tprintk(MYIOC_s_ERR_FMT \"Sending IOCInit failed(%d)!\\n\",ioc->name, r);\n\t\treturn r;\n\t}\n\n\t \n\n\tdhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Sending PortEnable (req @ %p)\\n\",\n\t\t\tioc->name, &ioc_init));\n\n\tif ((r = SendPortEnable(ioc, 0, sleepFlag)) != 0) {\n\t\tprintk(MYIOC_s_ERR_FMT \"Sending PortEnable failed(%d)!\\n\",ioc->name, r);\n\t\treturn r;\n\t}\n\n\t \n\tcount = 0;\n\tcntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * 60;\t \n\tstate = mpt_GetIocState(ioc, 1);\n\twhile (state != MPI_IOC_STATE_OPERATIONAL && --cntdn) {\n\t\tif (sleepFlag == CAN_SLEEP) {\n\t\t\tmsleep(1);\n\t\t} else {\n\t\t\tmdelay(1);\n\t\t}\n\n\t\tif (!cntdn) {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"Wait IOC_OP state timeout(%d)!\\n\",\n\t\t\t\t\tioc->name, (int)((count+5)/HZ));\n\t\t\treturn -9;\n\t\t}\n\n\t\tstate = mpt_GetIocState(ioc, 1);\n\t\tcount++;\n\t}\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Wait IOC_OPERATIONAL state (cnt=%d)\\n\",\n\t\t\tioc->name, count));\n\n\tioc->aen_event_read_flag=0;\n\treturn r;\n}\n\n \n \nstatic int\nSendPortEnable(MPT_ADAPTER *ioc, int portnum, int sleepFlag)\n{\n\tPortEnable_t\t\t port_enable;\n\tMPIDefaultReply_t\t reply_buf;\n\tint\t rc;\n\tint\t req_sz;\n\tint\t reply_sz;\n\n\t \n\treply_sz = sizeof(MPIDefaultReply_t);\n\tmemset(&reply_buf, 0, reply_sz);\n\n\treq_sz = sizeof(PortEnable_t);\n\tmemset(&port_enable, 0, req_sz);\n\n\tport_enable.Function = MPI_FUNCTION_PORT_ENABLE;\n\tport_enable.PortNumber = portnum;\n \n \n \n\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Sending Port(%d)Enable (req @ %p)\\n\",\n\t\t\tioc->name, portnum, &port_enable));\n\n\t \n\tif (ioc->ir_firmware || ioc->bus_type == SAS) {\n\t\trc = mpt_handshake_req_reply_wait(ioc, req_sz,\n\t\t(u32*)&port_enable, reply_sz, (u16*)&reply_buf,\n\t\t300  , sleepFlag);\n\t} else {\n\t\trc = mpt_handshake_req_reply_wait(ioc, req_sz,\n\t\t(u32*)&port_enable, reply_sz, (u16*)&reply_buf,\n\t\t30  , sleepFlag);\n\t}\n\treturn rc;\n}\n\n \nint\nmpt_alloc_fw_memory(MPT_ADAPTER *ioc, int size)\n{\n\tint rc;\n\n\tif (ioc->cached_fw) {\n\t\trc = 0;   \n\t\tgoto out;\n\t}\n\telse if (ioc->alt_ioc && ioc->alt_ioc->cached_fw) {\n\t\tioc->cached_fw = ioc->alt_ioc->cached_fw;   \n\t\tioc->cached_fw_dma = ioc->alt_ioc->cached_fw_dma;\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\tioc->cached_fw = dma_alloc_coherent(&ioc->pcidev->dev, size,\n\t\t\t\t\t    &ioc->cached_fw_dma, GFP_ATOMIC);\n\tif (!ioc->cached_fw) {\n\t\tprintk(MYIOC_s_ERR_FMT \"Unable to allocate memory for the cached firmware image!\\n\",\n\t\t    ioc->name);\n\t\trc = -1;\n\t} else {\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"FW Image  @ %p[%p], sz=%d[%x] bytes\\n\",\n\t\t    ioc->name, ioc->cached_fw, (void *)(ulong)ioc->cached_fw_dma, size, size));\n\t\tioc->alloc_total += size;\n\t\trc = 0;\n\t}\n out:\n\treturn rc;\n}\n\n \nvoid\nmpt_free_fw_memory(MPT_ADAPTER *ioc)\n{\n\tint sz;\n\n\tif (!ioc->cached_fw)\n\t\treturn;\n\n\tsz = ioc->facts.FWImageSize;\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"free_fw_memory: FW Image  @ %p[%p], sz=%d[%x] bytes\\n\",\n\t\t ioc->name, ioc->cached_fw, (void *)(ulong)ioc->cached_fw_dma, sz, sz));\n\tdma_free_coherent(&ioc->pcidev->dev, sz, ioc->cached_fw,\n\t\t\t  ioc->cached_fw_dma);\n\tioc->alloc_total -= sz;\n\tioc->cached_fw = NULL;\n}\n\n \n \nstatic int\nmpt_do_upload(MPT_ADAPTER *ioc, int sleepFlag)\n{\n\tu8\t\t\t reply[sizeof(FWUploadReply_t)];\n\tFWUpload_t\t\t*prequest;\n\tFWUploadReply_t\t\t*preply;\n\tFWUploadTCSGE_t\t\t*ptcsge;\n\tu32\t\t\t flagsLength;\n\tint\t\t\t ii, sz, reply_sz;\n\tint\t\t\t cmdStatus;\n\tint\t\t\trequest_size;\n\t \n\tif ((sz = ioc->facts.FWImageSize) == 0)\n\t\treturn 0;\n\n\tif (mpt_alloc_fw_memory(ioc, ioc->facts.FWImageSize) != 0)\n\t\treturn -ENOMEM;\n\n\tdinitprintk(ioc, printk(MYIOC_s_INFO_FMT \": FW Image  @ %p[%p], sz=%d[%x] bytes\\n\",\n\t    ioc->name, ioc->cached_fw, (void *)(ulong)ioc->cached_fw_dma, sz, sz));\n\n\tprequest = (sleepFlag == NO_SLEEP) ? kzalloc(ioc->req_sz, GFP_ATOMIC) :\n\t    kzalloc(ioc->req_sz, GFP_KERNEL);\n\tif (!prequest) {\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"fw upload failed \"\n\t\t    \"while allocating memory \\n\", ioc->name));\n\t\tmpt_free_fw_memory(ioc);\n\t\treturn -ENOMEM;\n\t}\n\n\tpreply = (FWUploadReply_t *)&reply;\n\n\treply_sz = sizeof(reply);\n\tmemset(preply, 0, reply_sz);\n\n\tprequest->ImageType = MPI_FW_UPLOAD_ITYPE_FW_IOC_MEM;\n\tprequest->Function = MPI_FUNCTION_FW_UPLOAD;\n\n\tptcsge = (FWUploadTCSGE_t *) &prequest->SGL;\n\tptcsge->DetailsLength = 12;\n\tptcsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;\n\tptcsge->ImageSize = cpu_to_le32(sz);\n\tptcsge++;\n\n\tflagsLength = MPT_SGE_FLAGS_SSIMPLE_READ | sz;\n\tioc->add_sge((char *)ptcsge, flagsLength, ioc->cached_fw_dma);\n\trequest_size = offsetof(FWUpload_t, SGL) + sizeof(FWUploadTCSGE_t) +\n\t    ioc->SGE_size;\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Sending FW Upload \"\n\t    \" (req @ %p) fw_size=%d mf_request_size=%d\\n\", ioc->name, prequest,\n\t    ioc->facts.FWImageSize, request_size));\n\tDBG_DUMP_FW_REQUEST_FRAME(ioc, (u32 *)prequest);\n\n\tii = mpt_handshake_req_reply_wait(ioc, request_size, (u32 *)prequest,\n\t    reply_sz, (u16 *)preply, 65  , sleepFlag);\n\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"FW Upload completed \"\n\t    \"rc=%x \\n\", ioc->name, ii));\n\n\tcmdStatus = -EFAULT;\n\tif (ii == 0) {\n\t\t \n\t\tint status;\n\t\tstatus = le16_to_cpu(preply->IOCStatus) &\n\t\t\t\tMPI_IOCSTATUS_MASK;\n\t\tif (status == MPI_IOCSTATUS_SUCCESS &&\n\t\t    ioc->facts.FWImageSize ==\n\t\t    le32_to_cpu(preply->ActualImageSize))\n\t\t\t\tcmdStatus = 0;\n\t}\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \": do_upload cmdStatus=%d \\n\",\n\t\t\tioc->name, cmdStatus));\n\n\n\tif (cmdStatus) {\n\t\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"fw upload failed, \"\n\t\t    \"freeing image \\n\", ioc->name));\n\t\tmpt_free_fw_memory(ioc);\n\t}\n\tkfree(prequest);\n\n\treturn cmdStatus;\n}\n\n \n \nstatic int\nmpt_downloadboot(MPT_ADAPTER *ioc, MpiFwHeader_t *pFwHeader, int sleepFlag)\n{\n\tMpiExtImageHeader_t\t*pExtImage;\n\tu32\t\t\t fwSize;\n\tu32\t\t\t diag0val;\n\tint\t\t\t count;\n\tu32\t\t\t*ptrFw;\n\tu32\t\t\t diagRwData;\n\tu32\t\t\t nextImage;\n\tu32\t\t\t load_addr;\n\tu32 \t\t\t ioc_state=0;\n\n\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"downloadboot: fw size 0x%x (%d), FW Ptr %p\\n\",\n\t\t\t\tioc->name, pFwHeader->ImageSize, pFwHeader->ImageSize, pFwHeader));\n\n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);\n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);\n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);\n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);\n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);\n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);\n\n\tCHIPREG_WRITE32(&ioc->chip->Diagnostic, (MPI_DIAG_PREVENT_IOC_BOOT | MPI_DIAG_DISABLE_ARM));\n\n\t \n\tif (sleepFlag == CAN_SLEEP) {\n\t\tmsleep(1);\n\t} else {\n\t\tmdelay (1);\n\t}\n\n\tdiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\n\tCHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_RESET_ADAPTER);\n\n\tfor (count = 0; count < 30; count ++) {\n\t\tdiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\n\t\tif (!(diag0val & MPI_DIAG_RESET_ADAPTER)) {\n\t\t\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"RESET_ADAPTER cleared, count=%d\\n\",\n\t\t\t\tioc->name, count));\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (sleepFlag == CAN_SLEEP) {\n\t\t\tmsleep (100);\n\t\t} else {\n\t\t\tmdelay (100);\n\t\t}\n\t}\n\n\tif ( count == 30 ) {\n\t\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"downloadboot failed! \"\n\t\t\"Unable to get MPI_DIAG_DRWE mode, diag0val=%x\\n\",\n\t\tioc->name, diag0val));\n\t\treturn -3;\n\t}\n\n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);\n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);\n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);\n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);\n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);\n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->Diagnostic, (MPI_DIAG_RW_ENABLE | MPI_DIAG_DISABLE_ARM));\n\n\tfwSize = (pFwHeader->ImageSize + 3)/4;\n\tptrFw = (u32 *) pFwHeader;\n\n\t \n\tif (ioc->errata_flag_1064)\n\t\tpci_enable_io_access(ioc->pcidev);\n\n\tCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, pFwHeader->LoadStartAddress);\n\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"LoadStart addr written 0x%x \\n\",\n\t\tioc->name, pFwHeader->LoadStartAddress));\n\n\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Write FW Image: 0x%x bytes @ %p\\n\",\n\t\t\t\tioc->name, fwSize*4, ptrFw));\n\twhile (fwSize--) {\n\t\tCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);\n\t}\n\n\tnextImage = pFwHeader->NextImageHeaderOffset;\n\twhile (nextImage) {\n\t\tpExtImage = (MpiExtImageHeader_t *) ((char *)pFwHeader + nextImage);\n\n\t\tload_addr = pExtImage->LoadStartAddress;\n\n\t\tfwSize = (pExtImage->ImageSize + 3) >> 2;\n\t\tptrFw = (u32 *)pExtImage;\n\n\t\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Write Ext Image: 0x%x (%d) bytes @ %p load_addr=%x\\n\",\n\t\t\t\t\t\tioc->name, fwSize*4, fwSize*4, ptrFw, load_addr));\n\t\tCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, load_addr);\n\n\t\twhile (fwSize--) {\n\t\t\tCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);\n\t\t}\n\t\tnextImage = pExtImage->NextImageHeaderOffset;\n\t}\n\n\t \n\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Write IopResetVector Addr=%x! \\n\", ioc->name, \tpFwHeader->IopResetRegAddr));\n\tCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, pFwHeader->IopResetRegAddr);\n\n\t \n\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Write IopResetVector Value=%x! \\n\", ioc->name, pFwHeader->IopResetVectorValue));\n\tCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, pFwHeader->IopResetVectorValue);\n\n\t \n\tif (ioc->bus_type == SPI) {\n\t\t \n\t\tCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);\n\t\tdiagRwData = CHIPREG_PIO_READ32(&ioc->pio_chip->DiagRwData);\n\t\tdiagRwData |= 0x40000000;\n\t\tCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);\n\t\tCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, diagRwData);\n\n\t} else   {\n\t\tdiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\n\t\tCHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val |\n\t\t    MPI_DIAG_CLEAR_FLASH_BAD_SIG);\n\n\t\t \n\t\tif (sleepFlag == CAN_SLEEP) {\n\t\t\tmsleep (1);\n\t\t} else {\n\t\t\tmdelay (1);\n\t\t}\n\t}\n\n\tif (ioc->errata_flag_1064)\n\t\tpci_disable_io_access(ioc->pcidev);\n\n\tdiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\n\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"downloadboot diag0val=%x, \"\n\t\t\"turning off PREVENT_IOC_BOOT, DISABLE_ARM, RW_ENABLE\\n\",\n\t\tioc->name, diag0val));\n\tdiag0val &= ~(MPI_DIAG_PREVENT_IOC_BOOT | MPI_DIAG_DISABLE_ARM | MPI_DIAG_RW_ENABLE);\n\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"downloadboot now diag0val=%x\\n\",\n\t\tioc->name, diag0val));\n\tCHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);\n\n\tif (ioc->bus_type == SAS) {\n\t\tioc_state = mpt_GetIocState(ioc, 0);\n\t\tif ( (GetIocFacts(ioc, sleepFlag,\n\t\t\t\tMPT_HOSTEVENT_IOC_BRINGUP)) != 0 ) {\n\t\t\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"GetIocFacts failed: IocState=%x\\n\",\n\t\t\t\t\tioc->name, ioc_state));\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tfor (count=0; count<HZ*20; count++) {\n\t\tif ((ioc_state = mpt_GetIocState(ioc, 0)) & MPI_IOC_STATE_READY) {\n\t\t\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\"downloadboot successful! (count=%d) IocState=%x\\n\",\n\t\t\t\tioc->name, count, ioc_state));\n\t\t\tif (ioc->bus_type == SAS) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((SendIocInit(ioc, sleepFlag)) != 0) {\n\t\t\t\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\"downloadboot: SendIocInit failed\\n\",\n\t\t\t\t\tioc->name));\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\"downloadboot: SendIocInit successful\\n\",\n\t\t\t\t\tioc->name));\n\t\t\treturn 0;\n\t\t}\n\t\tif (sleepFlag == CAN_SLEEP) {\n\t\t\tmsleep (10);\n\t\t} else {\n\t\t\tmdelay (10);\n\t\t}\n\t}\n\tddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"downloadboot failed! IocState=%x\\n\",ioc->name, ioc_state));\n\treturn -EFAULT;\n}\n\n \n \nstatic int\nKickStart(MPT_ADAPTER *ioc, int force, int sleepFlag)\n{\n\tint hard_reset_done = 0;\n\tu32 ioc_state=0;\n\tint cnt,cntdn;\n\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"KickStarting!\\n\", ioc->name));\n\tif (ioc->bus_type == SPI) {\n\t\t \n\t\tSendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag);\n\n\t\tif (sleepFlag == CAN_SLEEP) {\n\t\t\tmsleep (1000);\n\t\t} else {\n\t\t\tmdelay (1000);\n\t\t}\n\t}\n\n\thard_reset_done = mpt_diag_reset(ioc, force, sleepFlag);\n\tif (hard_reset_done < 0)\n\t\treturn hard_reset_done;\n\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Diagnostic reset successful!\\n\",\n\t\tioc->name));\n\n\tcntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * 2;\t \n\tfor (cnt=0; cnt<cntdn; cnt++) {\n\t\tioc_state = mpt_GetIocState(ioc, 1);\n\t\tif ((ioc_state == MPI_IOC_STATE_READY) || (ioc_state == MPI_IOC_STATE_OPERATIONAL)) {\n\t\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"KickStart successful! (cnt=%d)\\n\",\n \t\t\t\t\tioc->name, cnt));\n\t\t\treturn hard_reset_done;\n\t\t}\n\t\tif (sleepFlag == CAN_SLEEP) {\n\t\t\tmsleep (10);\n\t\t} else {\n\t\t\tmdelay (10);\n\t\t}\n\t}\n\n\tdinitprintk(ioc, printk(MYIOC_s_ERR_FMT \"Failed to come READY after reset! IocState=%x\\n\",\n\t\tioc->name, mpt_GetIocState(ioc, 0)));\n\treturn -1;\n}\n\n \n \nstatic int\nmpt_diag_reset(MPT_ADAPTER *ioc, int ignore, int sleepFlag)\n{\n\tu32 diag0val;\n\tu32 doorbell;\n\tint hard_reset_done = 0;\n\tint count = 0;\n\tu32 diag1val = 0;\n\tMpiFwHeader_t *cached_fw;\t \n\tu8\t cb_idx;\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\n\tif (ioc->pcidev->device == MPI_MANUFACTPAGE_DEVID_SAS1078) {\n\n\t\tif (!ignore)\n\t\t\treturn 0;\n\n\t\tdrsprintk(ioc, printk(MYIOC_s_WARN_FMT \"%s: Doorbell=%p; 1078 reset \"\n\t\t\t\"address=%p\\n\",  ioc->name, __func__,\n\t\t\t&ioc->chip->Doorbell, &ioc->chip->Reset_1078));\n\t\tCHIPREG_WRITE32(&ioc->chip->Reset_1078, 0x07);\n\t\tif (sleepFlag == CAN_SLEEP)\n\t\t\tmsleep(1);\n\t\telse\n\t\t\tmdelay(1);\n\n\t\t \n\t\tfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\n\t\t\tif (MptResetHandlers[cb_idx])\n\t\t\t\t(*(MptResetHandlers[cb_idx]))(ioc,\n\t\t\t\t\t\tMPT_IOC_PRE_RESET);\n\t\t}\n\n\t\tfor (count = 0; count < 60; count ++) {\n\t\t\tdoorbell = CHIPREG_READ32(&ioc->chip->Doorbell);\n\t\t\tdoorbell &= MPI_IOC_STATE_MASK;\n\n\t\t\tdrsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\"looking for READY STATE: doorbell=%x\"\n\t\t\t        \" count=%d\\n\",\n\t\t\t\tioc->name, doorbell, count));\n\n\t\t\tif (doorbell == MPI_IOC_STATE_READY) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (sleepFlag == CAN_SLEEP)\n\t\t\t\tmsleep(1000);\n\t\t\telse\n\t\t\t\tmdelay(1000);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t \n\tdiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\n\n\tif (ioc->debug_level & MPT_DEBUG) {\n\t\tif (ioc->alt_ioc)\n\t\t\tdiag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);\n\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"DbG1: diag0=%08x, diag1=%08x\\n\",\n\t\t\tioc->name, diag0val, diag1val));\n\t}\n\n\t \n\tif (ignore || !(diag0val & MPI_DIAG_RESET_HISTORY)) {\n\t\twhile ((diag0val & MPI_DIAG_DRWE) == 0) {\n\t\t\t \n\t\t\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);\n\t\t\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);\n\t\t\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);\n\t\t\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);\n\t\t\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);\n\t\t\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);\n\n\t\t\t \n\t\t\tif (sleepFlag == CAN_SLEEP) {\n\t\t\t\tmsleep (100);\n\t\t\t} else {\n\t\t\t\tmdelay (100);\n\t\t\t}\n\n\t\t\tcount++;\n\t\t\tif (count > 20) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"Enable Diagnostic mode FAILED! (%02xh)\\n\",\n\t\t\t\t\t\tioc->name, diag0val);\n\t\t\t\treturn -2;\n\n\t\t\t}\n\n\t\t\tdiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\n\n\t\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Wrote magic DiagWriteEn sequence (%x)\\n\",\n\t\t\t\t\tioc->name, diag0val));\n\t\t}\n\n\t\tif (ioc->debug_level & MPT_DEBUG) {\n\t\t\tif (ioc->alt_ioc)\n\t\t\t\tdiag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);\n\t\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"DbG2: diag0=%08x, diag1=%08x\\n\",\n\t\t\t\tioc->name, diag0val, diag1val));\n\t\t}\n\t\t \n\t\tCHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_DISABLE_ARM);\n\t\tmdelay(1);\n\n\t\t \n\t\tCHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_RESET_ADAPTER);\n\t\thard_reset_done = 1;\n\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Diagnostic reset performed\\n\",\n\t\t\t\tioc->name));\n\n\t\t \n\t\tfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\n\t\t\tif (MptResetHandlers[cb_idx]) {\n\t\t\t\tmpt_signal_reset(cb_idx,\n\t\t\t\t\tioc, MPT_IOC_PRE_RESET);\n\t\t\t\tif (ioc->alt_ioc) {\n\t\t\t\t\tmpt_signal_reset(cb_idx,\n\t\t\t\t\tioc->alt_ioc, MPT_IOC_PRE_RESET);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ioc->cached_fw)\n\t\t\tcached_fw = (MpiFwHeader_t *)ioc->cached_fw;\n\t\telse if (ioc->alt_ioc && ioc->alt_ioc->cached_fw)\n\t\t\tcached_fw = (MpiFwHeader_t *)ioc->alt_ioc->cached_fw;\n\t\telse\n\t\t\tcached_fw = NULL;\n\t\tif (cached_fw) {\n\t\t\t \n\t\t\tfor (count = 0; count < 30; count ++) {\n\t\t\t\tdiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\n\t\t\t\tif (!(diag0val & MPI_DIAG_RESET_ADAPTER)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"cached_fw: diag0val=%x count=%d\\n\",\n\t\t\t\t\tioc->name, diag0val, count));\n\t\t\t\t \n\t\t\t\tif (sleepFlag == CAN_SLEEP) {\n\t\t\t\t\tmsleep (1000);\n\t\t\t\t} else {\n\t\t\t\t\tmdelay (1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((count = mpt_downloadboot(ioc, cached_fw, sleepFlag)) < 0) {\n\t\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\t\t\"firmware downloadboot failure (%d)!\\n\", ioc->name, count);\n\t\t\t}\n\n\t\t} else {\n\t\t\t \n\t\t\tfor (count = 0; count < 60; count ++) {\n\t\t\t\tdoorbell = CHIPREG_READ32(&ioc->chip->Doorbell);\n\t\t\t\tdoorbell &= MPI_IOC_STATE_MASK;\n\n\t\t\t\tdrsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t    \"looking for READY STATE: doorbell=%x\"\n\t\t\t\t    \" count=%d\\n\", ioc->name, doorbell, count));\n\n\t\t\t\tif (doorbell == MPI_IOC_STATE_READY) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (sleepFlag == CAN_SLEEP) {\n\t\t\t\t\tmsleep (1000);\n\t\t\t\t} else {\n\t\t\t\t\tmdelay (1000);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (doorbell != MPI_IOC_STATE_READY)\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"Failed to come READY \"\n\t\t\t\t    \"after reset! IocState=%x\", ioc->name,\n\t\t\t\t    doorbell);\n\t\t}\n\t}\n\n\tdiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\n\tif (ioc->debug_level & MPT_DEBUG) {\n\t\tif (ioc->alt_ioc)\n\t\t\tdiag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);\n\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"DbG3: diag0=%08x, diag1=%08x\\n\",\n\t\t\tioc->name, diag0val, diag1val));\n\t}\n\n\t \n\tdiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\n\tcount = 0;\n\twhile ((diag0val & MPI_DIAG_DRWE) == 0) {\n\t\t \n\t\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);\n\t\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);\n\t\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);\n\t\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);\n\t\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);\n\t\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);\n\n\t\t \n\t\tif (sleepFlag == CAN_SLEEP) {\n\t\t\tmsleep (100);\n\t\t} else {\n\t\t\tmdelay (100);\n\t\t}\n\n\t\tcount++;\n\t\tif (count > 20) {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"Enable Diagnostic mode FAILED! (%02xh)\\n\",\n\t\t\t\t\tioc->name, diag0val);\n\t\t\tbreak;\n\t\t}\n\t\tdiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\n\t}\n\tdiag0val &= ~MPI_DIAG_RESET_HISTORY;\n\tCHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);\n\tdiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\n\tif (diag0val & MPI_DIAG_RESET_HISTORY) {\n\t\tprintk(MYIOC_s_WARN_FMT \"ResetHistory bit failed to clear!\\n\",\n\t\t\t\tioc->name);\n\t}\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFFFFFFFF);\n\n\t \n\tdiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\n\tif (diag0val & (MPI_DIAG_FLASH_BAD_SIG | MPI_DIAG_RESET_ADAPTER | MPI_DIAG_DISABLE_ARM)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"Diagnostic reset FAILED! (%02xh)\\n\",\n\t\t\t\tioc->name, diag0val);\n\t\treturn -3;\n\t}\n\n\tif (ioc->debug_level & MPT_DEBUG) {\n\t\tif (ioc->alt_ioc)\n\t\t\tdiag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);\n\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"DbG4: diag0=%08x, diag1=%08x\\n\",\n\t\t\tioc->name, diag0val, diag1val));\n\t}\n\n\t \n\tioc->facts.EventState = 0;\n\n\tif (ioc->alt_ioc)\n\t\tioc->alt_ioc->facts.EventState = 0;\n\n\treturn hard_reset_done;\n}\n\n \n \nstatic int\nSendIocReset(MPT_ADAPTER *ioc, u8 reset_type, int sleepFlag)\n{\n\tint r;\n\tu32 state;\n\tint cntdn, count;\n\n\tdrsprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Sending IOC reset(0x%02x)!\\n\",\n\t\t\tioc->name, reset_type));\n\tCHIPREG_WRITE32(&ioc->chip->Doorbell, reset_type<<MPI_DOORBELL_FUNCTION_SHIFT);\n\tif ((r = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0)\n\t\treturn r;\n\n\t \n\tcount = 0;\n\tcntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * 15;\t \n\n\twhile ((state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {\n\t\tcntdn--;\n\t\tcount++;\n\t\tif (!cntdn) {\n\t\t\tif (sleepFlag != CAN_SLEEP)\n\t\t\t\tcount *= 10;\n\n\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t    \"Wait IOC_READY state (0x%x) timeout(%d)!\\n\",\n\t\t\t    ioc->name, state, (int)((count+5)/HZ));\n\t\t\treturn -ETIME;\n\t\t}\n\n\t\tif (sleepFlag == CAN_SLEEP) {\n\t\t\tmsleep(1);\n\t\t} else {\n\t\t\tmdelay (1);\t \n\t\t}\n\t}\n\n\t \n\tif (ioc->facts.Function)\n\t\tioc->facts.EventState = 0;\n\n\treturn 0;\n}\n\n \n \nstatic int\ninitChainBuffers(MPT_ADAPTER *ioc)\n{\n\tu8\t\t*mem;\n\tint\t\tsz, ii, num_chain;\n\tint \t\tscale, num_sge, numSGE;\n\n\t \n\tif (ioc->ReqToChain == NULL) {\n\t\tsz = ioc->req_depth * sizeof(int);\n\t\tmem = kmalloc(sz, GFP_ATOMIC);\n\t\tif (mem == NULL)\n\t\t\treturn -1;\n\n\t\tioc->ReqToChain = (int *) mem;\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"ReqToChain alloc  @ %p, sz=%d bytes\\n\",\n\t\t\t \tioc->name, mem, sz));\n\t\tmem = kmalloc(sz, GFP_ATOMIC);\n\t\tif (mem == NULL)\n\t\t\treturn -1;\n\n\t\tioc->RequestNB = (int *) mem;\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"RequestNB alloc  @ %p, sz=%d bytes\\n\",\n\t\t\t \tioc->name, mem, sz));\n\t}\n\tfor (ii = 0; ii < ioc->req_depth; ii++) {\n\t\tioc->ReqToChain[ii] = MPT_HOST_NO_CHAIN;\n\t}\n\n\t \n\tscale = ioc->req_sz / ioc->SGE_size;\n\tif (ioc->sg_addr_size == sizeof(u64))\n\t\tnum_sge =  scale + (ioc->req_sz - 60) / ioc->SGE_size;\n\telse\n\t\tnum_sge =  1 + scale + (ioc->req_sz - 64) / ioc->SGE_size;\n\n\tif (ioc->sg_addr_size == sizeof(u64)) {\n\t\tnumSGE = (scale - 1) * (ioc->facts.MaxChainDepth-1) + scale +\n\t\t\t(ioc->req_sz - 60) / ioc->SGE_size;\n\t} else {\n\t\tnumSGE = 1 + (scale - 1) * (ioc->facts.MaxChainDepth-1) +\n\t\t    scale + (ioc->req_sz - 64) / ioc->SGE_size;\n\t}\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"num_sge=%d numSGE=%d\\n\",\n\t\tioc->name, num_sge, numSGE));\n\n\tif (ioc->bus_type == FC) {\n\t\tif (numSGE > MPT_SCSI_FC_SG_DEPTH)\n\t\t\tnumSGE = MPT_SCSI_FC_SG_DEPTH;\n\t} else {\n\t\tif (numSGE > MPT_SCSI_SG_DEPTH)\n\t\t\tnumSGE = MPT_SCSI_SG_DEPTH;\n\t}\n\n\tnum_chain = 1;\n\twhile (numSGE - num_sge > 0) {\n\t\tnum_chain++;\n\t\tnum_sge += (scale - 1);\n\t}\n\tnum_chain++;\n\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Now numSGE=%d num_sge=%d num_chain=%d\\n\",\n\t\tioc->name, numSGE, num_sge, num_chain));\n\n\tif (ioc->bus_type == SPI)\n\t\tnum_chain *= MPT_SCSI_CAN_QUEUE;\n\telse if (ioc->bus_type == SAS)\n\t\tnum_chain *= MPT_SAS_CAN_QUEUE;\n\telse\n\t\tnum_chain *= MPT_FC_CAN_QUEUE;\n\n\tioc->num_chain = num_chain;\n\n\tsz = num_chain * sizeof(int);\n\tif (ioc->ChainToChain == NULL) {\n\t\tmem = kmalloc(sz, GFP_ATOMIC);\n\t\tif (mem == NULL)\n\t\t\treturn -1;\n\n\t\tioc->ChainToChain = (int *) mem;\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"ChainToChain alloc @ %p, sz=%d bytes\\n\",\n\t\t\t \tioc->name, mem, sz));\n\t} else {\n\t\tmem = (u8 *) ioc->ChainToChain;\n\t}\n\tmemset(mem, 0xFF, sz);\n\treturn num_chain;\n}\n\n \n \nstatic int\nPrimeIocFifos(MPT_ADAPTER *ioc)\n{\n\tMPT_FRAME_HDR *mf;\n\tunsigned long flags;\n\tdma_addr_t alloc_dma;\n\tu8 *mem;\n\tint i, reply_sz, sz, total_size, num_chain;\n\tu64\tdma_mask;\n\n\tdma_mask = 0;\n\n\t \n\n\tif (ioc->reply_frames == NULL) {\n\t\tif ( (num_chain = initChainBuffers(ioc)) < 0)\n\t\t\treturn -1;\n\t\t \n\t\tif (ioc->pcidev->device == MPI_MANUFACTPAGE_DEVID_SAS1078 &&\n\t\t    ioc->dma_mask > DMA_BIT_MASK(35)) {\n\t\t\tif (!dma_set_mask(&ioc->pcidev->dev, DMA_BIT_MASK(32))\n\t\t\t    && !dma_set_coherent_mask(&ioc->pcidev->dev, DMA_BIT_MASK(32))) {\n\t\t\t\tdma_mask = DMA_BIT_MASK(35);\n\t\t\t\td36memprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t    \"setting 35 bit addressing for \"\n\t\t\t\t    \"Request/Reply/Chain and Sense Buffers\\n\",\n\t\t\t\t    ioc->name));\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdma_set_mask(&ioc->pcidev->dev,\n\t\t\t\t\t     DMA_BIT_MASK(64));\n\t\t\t\tdma_set_coherent_mask(&ioc->pcidev->dev,\n\t\t\t\t\t\t      DMA_BIT_MASK(64));\n\n\t\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t\t    \"failed setting 35 bit addressing for \"\n\t\t\t\t    \"Request/Reply/Chain and Sense Buffers\\n\",\n\t\t\t\t    ioc->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\ttotal_size = reply_sz = (ioc->reply_sz * ioc->reply_depth);\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"ReplyBuffer sz=%d bytes, ReplyDepth=%d\\n\",\n\t\t\t \tioc->name, ioc->reply_sz, ioc->reply_depth));\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"ReplyBuffer sz=%d[%x] bytes\\n\",\n\t\t\t \tioc->name, reply_sz, reply_sz));\n\n\t\tsz = (ioc->req_sz * ioc->req_depth);\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"RequestBuffer sz=%d bytes, RequestDepth=%d\\n\",\n\t\t\t \tioc->name, ioc->req_sz, ioc->req_depth));\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"RequestBuffer sz=%d[%x] bytes\\n\",\n\t\t\t \tioc->name, sz, sz));\n\t\ttotal_size += sz;\n\n\t\tsz = num_chain * ioc->req_sz;  \n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"ChainBuffer sz=%d bytes, ChainDepth=%d\\n\",\n\t\t\t \tioc->name, ioc->req_sz, num_chain));\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"ChainBuffer sz=%d[%x] bytes num_chain=%d\\n\",\n\t\t\t \tioc->name, sz, sz, num_chain));\n\n\t\ttotal_size += sz;\n\t\tmem = dma_alloc_coherent(&ioc->pcidev->dev, total_size,\n\t\t\t\t&alloc_dma, GFP_KERNEL);\n\t\tif (mem == NULL) {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"Unable to allocate Reply, Request, Chain Buffers!\\n\",\n\t\t\t\tioc->name);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Total alloc @ %p[%p], sz=%d[%x] bytes\\n\",\n\t\t\t \tioc->name, mem, (void *)(ulong)alloc_dma, total_size, total_size));\n\n\t\tmemset(mem, 0, total_size);\n\t\tioc->alloc_total += total_size;\n\t\tioc->alloc = mem;\n\t\tioc->alloc_dma = alloc_dma;\n\t\tioc->alloc_sz = total_size;\n\t\tioc->reply_frames = (MPT_FRAME_HDR *) mem;\n\t\tioc->reply_frames_low_dma = (u32) (alloc_dma & 0xFFFFFFFF);\n\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"ReplyBuffers @ %p[%p]\\n\",\n\t \t\tioc->name, ioc->reply_frames, (void *)(ulong)alloc_dma));\n\n\t\talloc_dma += reply_sz;\n\t\tmem += reply_sz;\n\n\t\t \n\n\t\tioc->req_frames = (MPT_FRAME_HDR *) mem;\n\t\tioc->req_frames_dma = alloc_dma;\n\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"RequestBuffers @ %p[%p]\\n\",\n\t\t\t \tioc->name, mem, (void *)(ulong)alloc_dma));\n\n\t\tioc->req_frames_low_dma = (u32) (alloc_dma & 0xFFFFFFFF);\n\n\t\tfor (i = 0; i < ioc->req_depth; i++) {\n\t\t\talloc_dma += ioc->req_sz;\n\t\t\tmem += ioc->req_sz;\n\t\t}\n\n\t\tioc->ChainBuffer = mem;\n\t\tioc->ChainBufferDMA = alloc_dma;\n\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"ChainBuffers @ %p(%p)\\n\",\n\t\t\tioc->name, ioc->ChainBuffer, (void *)(ulong)ioc->ChainBufferDMA));\n\n\t\t \n\n\t\tINIT_LIST_HEAD(&ioc->FreeChainQ);\n\n\t\t \n\t\tmem = (u8 *)ioc->ChainBuffer;\n\t\tfor (i=0; i < num_chain; i++) {\n\t\t\tmf = (MPT_FRAME_HDR *) mem;\n\t\t\tlist_add_tail(&mf->u.frame.linkage.list, &ioc->FreeChainQ);\n\t\t\tmem += ioc->req_sz;\n\t\t}\n\n\t\t \n\t\talloc_dma = ioc->req_frames_dma;\n\t\tmem = (u8 *) ioc->req_frames;\n\n\t\tspin_lock_irqsave(&ioc->FreeQlock, flags);\n\t\tINIT_LIST_HEAD(&ioc->FreeQ);\n\t\tfor (i = 0; i < ioc->req_depth; i++) {\n\t\t\tmf = (MPT_FRAME_HDR *) mem;\n\n\t\t\t \n\t\t\tlist_add_tail(&mf->u.frame.linkage.list, &ioc->FreeQ);\n\n\t\t\tmem += ioc->req_sz;\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->FreeQlock, flags);\n\n\t\tsz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);\n\t\tioc->sense_buf_pool = dma_alloc_coherent(&ioc->pcidev->dev, sz,\n\t\t\t\t&ioc->sense_buf_pool_dma, GFP_KERNEL);\n\t\tif (ioc->sense_buf_pool == NULL) {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"Unable to allocate Sense Buffers!\\n\",\n\t\t\t\tioc->name);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tioc->sense_buf_low_dma = (u32) (ioc->sense_buf_pool_dma & 0xFFFFFFFF);\n\t\tioc->alloc_total += sz;\n\t\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"SenseBuffers @ %p[%p]\\n\",\n \t\t\tioc->name, ioc->sense_buf_pool, (void *)(ulong)ioc->sense_buf_pool_dma));\n\n\t}\n\n\t \n\talloc_dma = ioc->alloc_dma;\n\tdinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"ReplyBuffers @ %p[%p]\\n\",\n\t \tioc->name, ioc->reply_frames, (void *)(ulong)alloc_dma));\n\n\tfor (i = 0; i < ioc->reply_depth; i++) {\n\t\t \n\t\tCHIPREG_WRITE32(&ioc->chip->ReplyFifo, alloc_dma);\n\t\talloc_dma += ioc->reply_sz;\n\t}\n\n\tif (dma_mask == DMA_BIT_MASK(35) && !dma_set_mask(&ioc->pcidev->dev,\n\t    ioc->dma_mask) && !dma_set_coherent_mask(&ioc->pcidev->dev,\n\t    ioc->dma_mask))\n\t\td36memprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"restoring 64 bit addressing\\n\", ioc->name));\n\n\treturn 0;\n\nout_fail:\n\n\tif (ioc->alloc != NULL) {\n\t\tsz = ioc->alloc_sz;\n\t\tdma_free_coherent(&ioc->pcidev->dev, sz, ioc->alloc,\n\t\t\t\tioc->alloc_dma);\n\t\tioc->reply_frames = NULL;\n\t\tioc->req_frames = NULL;\n\t\tioc->alloc_total -= sz;\n\t}\n\tif (ioc->sense_buf_pool != NULL) {\n\t\tsz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);\n\t\tdma_free_coherent(&ioc->pcidev->dev, sz, ioc->sense_buf_pool,\n\t\t\t\tioc->sense_buf_pool_dma);\n\t\tioc->sense_buf_pool = NULL;\n\t}\n\n\tif (dma_mask == DMA_BIT_MASK(35) && !dma_set_mask(&ioc->pcidev->dev,\n\t    DMA_BIT_MASK(64)) && !dma_set_coherent_mask(&ioc->pcidev->dev,\n\t    DMA_BIT_MASK(64)))\n\t\td36memprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"restoring 64 bit addressing\\n\", ioc->name));\n\n\treturn -1;\n}\n\n \n \nstatic int\nmpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes, u32 *req,\n\t\tint replyBytes, u16 *u16reply, int maxwait, int sleepFlag)\n{\n\tMPIDefaultReply_t *mptReply;\n\tint failcnt = 0;\n\tint t;\n\n\t \n\tioc->hs_reply_idx = 0;\n\tmptReply = (MPIDefaultReply_t *) ioc->hs_reply;\n\tmptReply->MsgLength = 0;\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\tCHIPREG_WRITE32(&ioc->chip->Doorbell,\n\t\t\t((MPI_FUNCTION_HANDSHAKE<<MPI_DOORBELL_FUNCTION_SHIFT) |\n\t\t\t ((reqBytes/4)<<MPI_DOORBELL_ADD_DWORDS_SHIFT)));\n\n\t \n\tif ((t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)\n\t\tfailcnt++;\n\n\tdhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"HandShake request start reqBytes=%d, WaitCnt=%d%s\\n\",\n\t\t\tioc->name, reqBytes, t, failcnt ? \" - MISSING DOORBELL HANDSHAKE!\" : \"\"));\n\n\t \n\tif (!(CHIPREG_READ32(&ioc->chip->Doorbell) & MPI_DOORBELL_ACTIVE))\n\t\t\treturn -1;\n\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\tif (!failcnt && (t = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0)\n\t\tfailcnt++;\n\n\tif (!failcnt) {\n\t\tint\t ii;\n\t\tu8\t*req_as_bytes = (u8 *) req;\n\n\t\t \n\t\tfor (ii = 0; !failcnt && ii < reqBytes/4; ii++) {\n\t\t\tu32 word = ((req_as_bytes[(ii*4) + 0] <<  0) |\n\t\t\t\t    (req_as_bytes[(ii*4) + 1] <<  8) |\n\t\t\t\t    (req_as_bytes[(ii*4) + 2] << 16) |\n\t\t\t\t    (req_as_bytes[(ii*4) + 3] << 24));\n\n\t\t\tCHIPREG_WRITE32(&ioc->chip->Doorbell, word);\n\t\t\tif ((t = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0)\n\t\t\t\tfailcnt++;\n\t\t}\n\n\t\tdhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Handshake request frame (@%p) header\\n\", ioc->name, req));\n\t\tDBG_DUMP_REQUEST_FRAME_HDR(ioc, (u32 *)req);\n\n\t\tdhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"HandShake request post done, WaitCnt=%d%s\\n\",\n\t\t\t\tioc->name, t, failcnt ? \" - MISSING DOORBELL ACK!\" : \"\"));\n\n\t\t \n\t\tif (!failcnt && (t = WaitForDoorbellReply(ioc, maxwait, sleepFlag)) < 0)\n\t\t\tfailcnt++;\n\n\t\tdhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"HandShake reply count=%d%s\\n\",\n\t\t\t\tioc->name, t, failcnt ? \" - MISSING DOORBELL REPLY!\" : \"\"));\n\n\t\t \n\t\tfor (ii=0; ii < min(replyBytes/2,mptReply->MsgLength*2); ii++)\n\t\t\tu16reply[ii] = ioc->hs_reply[ii];\n\t} else {\n\t\treturn -99;\n\t}\n\n\treturn -failcnt;\n}\n\n \n \nstatic int\nWaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong, int sleepFlag)\n{\n\tint cntdn;\n\tint count = 0;\n\tu32 intstat=0;\n\n\tcntdn = 1000 * howlong;\n\n\tif (sleepFlag == CAN_SLEEP) {\n\t\twhile (--cntdn) {\n\t\t\tmsleep (1);\n\t\t\tintstat = CHIPREG_READ32(&ioc->chip->IntStatus);\n\t\t\tif (! (intstat & MPI_HIS_IOP_DOORBELL_STATUS))\n\t\t\t\tbreak;\n\t\t\tcount++;\n\t\t}\n\t} else {\n\t\twhile (--cntdn) {\n\t\t\tudelay (1000);\n\t\t\tintstat = CHIPREG_READ32(&ioc->chip->IntStatus);\n\t\t\tif (! (intstat & MPI_HIS_IOP_DOORBELL_STATUS))\n\t\t\t\tbreak;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (cntdn) {\n\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"WaitForDoorbell ACK (count=%d)\\n\",\n\t\t\t\tioc->name, count));\n\t\treturn count;\n\t}\n\n\tprintk(MYIOC_s_ERR_FMT \"Doorbell ACK timeout (count=%d), IntStatus=%x!\\n\",\n\t\t\tioc->name, count, intstat);\n\treturn -1;\n}\n\n \n \nstatic int\nWaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong, int sleepFlag)\n{\n\tint cntdn;\n\tint count = 0;\n\tu32 intstat=0;\n\n\tcntdn = 1000 * howlong;\n\tif (sleepFlag == CAN_SLEEP) {\n\t\twhile (--cntdn) {\n\t\t\tintstat = CHIPREG_READ32(&ioc->chip->IntStatus);\n\t\t\tif (intstat & MPI_HIS_DOORBELL_INTERRUPT)\n\t\t\t\tbreak;\n\t\t\tmsleep(1);\n\t\t\tcount++;\n\t\t}\n\t} else {\n\t\twhile (--cntdn) {\n\t\t\tintstat = CHIPREG_READ32(&ioc->chip->IntStatus);\n\t\t\tif (intstat & MPI_HIS_DOORBELL_INTERRUPT)\n\t\t\t\tbreak;\n\t\t\tudelay (1000);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (cntdn) {\n\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"WaitForDoorbell INT (cnt=%d) howlong=%d\\n\",\n\t\t\t\tioc->name, count, howlong));\n\t\treturn count;\n\t}\n\n\tprintk(MYIOC_s_ERR_FMT \"Doorbell INT timeout (count=%d), IntStatus=%x!\\n\",\n\t\t\tioc->name, count, intstat);\n\treturn -1;\n}\n\n \n \nstatic int\nWaitForDoorbellReply(MPT_ADAPTER *ioc, int howlong, int sleepFlag)\n{\n\tint u16cnt = 0;\n\tint failcnt = 0;\n\tint t;\n\tu16 *hs_reply = ioc->hs_reply;\n\tvolatile MPIDefaultReply_t *mptReply = (MPIDefaultReply_t *) ioc->hs_reply;\n\tu16 hword;\n\n\ths_reply[0] = hs_reply[1] = hs_reply[7] = 0;\n\n\t \n\tu16cnt=0;\n\tif ((t = WaitForDoorbellInt(ioc, howlong, sleepFlag)) < 0) {\n\t\tfailcnt++;\n\t} else {\n\t\ths_reply[u16cnt++] = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);\n\t\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\t\tif ((t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)\n\t\t\tfailcnt++;\n\t\telse {\n\t\t\ths_reply[u16cnt++] = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);\n\t\t\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\t\t}\n\t}\n\n\tdhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"WaitCnt=%d First handshake reply word=%08x%s\\n\",\n\t\t\tioc->name, t, le32_to_cpu(*(u32 *)hs_reply),\n\t\t\tfailcnt ? \" - MISSING DOORBELL HANDSHAKE!\" : \"\"));\n\n\t \n\tfor (u16cnt=2; !failcnt && u16cnt < (2 * mptReply->MsgLength); u16cnt++) {\n\t\tif ((t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)\n\t\t\tfailcnt++;\n\t\thword = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);\n\t\t \n\t\tif (u16cnt < ARRAY_SIZE(ioc->hs_reply))\n\t\t\ths_reply[u16cnt] = hword;\n\t\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\t}\n\n\tif (!failcnt && (t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)\n\t\tfailcnt++;\n\tCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\n\n\tif (failcnt) {\n\t\tprintk(MYIOC_s_ERR_FMT \"Handshake reply failure!\\n\",\n\t\t\t\tioc->name);\n\t\treturn -failcnt;\n\t}\n#if 0\n\telse if (u16cnt != (2 * mptReply->MsgLength)) {\n\t\treturn -101;\n\t}\n\telse if ((mptReply->IOCStatus & MPI_IOCSTATUS_MASK) != MPI_IOCSTATUS_SUCCESS) {\n\t\treturn -102;\n\t}\n#endif\n\n\tdhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Got Handshake reply:\\n\", ioc->name));\n\tDBG_DUMP_REPLY_FRAME(ioc, (u32 *)mptReply);\n\n\tdhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"WaitForDoorbell REPLY WaitCnt=%d (sz=%d)\\n\",\n\t\t\tioc->name, t, u16cnt/2));\n\treturn u16cnt/2;\n}\n\n \n \nstatic int\nGetLanConfigPages(MPT_ADAPTER *ioc)\n{\n\tConfigPageHeader_t\t hdr;\n\tCONFIGPARMS\t\t cfg;\n\tLANPage0_t\t\t*ppage0_alloc;\n\tdma_addr_t\t\t page0_dma;\n\tLANPage1_t\t\t*ppage1_alloc;\n\tdma_addr_t\t\t page1_dma;\n\tint\t\t\t rc = 0;\n\tint\t\t\t data_sz;\n\tint\t\t\t copy_sz;\n\n\t \n\thdr.PageVersion = 0;\n\thdr.PageLength = 0;\n\thdr.PageNumber = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_LAN;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.pageAddr = 0;\n\tcfg.timeout = 0;\n\n\tif ((rc = mpt_config(ioc, &cfg)) != 0)\n\t\treturn rc;\n\n\tif (hdr.PageLength > 0) {\n\t\tdata_sz = hdr.PageLength * 4;\n\t\tppage0_alloc = dma_alloc_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t\t\t  &page0_dma, GFP_KERNEL);\n\t\trc = -ENOMEM;\n\t\tif (ppage0_alloc) {\n\t\t\tmemset((u8 *)ppage0_alloc, 0, data_sz);\n\t\t\tcfg.physAddr = page0_dma;\n\t\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\t\t\tif ((rc = mpt_config(ioc, &cfg)) == 0) {\n\t\t\t\t \n\t\t\t\tcopy_sz = min_t(int, sizeof(LANPage0_t), data_sz);\n\t\t\t\tmemcpy(&ioc->lan_cnfg_page0, ppage0_alloc, copy_sz);\n\n\t\t\t}\n\n\t\t\tdma_free_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t\t  (u8 *)ppage0_alloc, page0_dma);\n\n\t\t\t \n\n\t\t}\n\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\thdr.PageVersion = 0;\n\thdr.PageLength = 0;\n\thdr.PageNumber = 1;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_LAN;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.pageAddr = 0;\n\n\tif ((rc = mpt_config(ioc, &cfg)) != 0)\n\t\treturn rc;\n\n\tif (hdr.PageLength == 0)\n\t\treturn 0;\n\n\tdata_sz = hdr.PageLength * 4;\n\trc = -ENOMEM;\n\tppage1_alloc = dma_alloc_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t\t  &page1_dma, GFP_KERNEL);\n\tif (ppage1_alloc) {\n\t\tmemset((u8 *)ppage1_alloc, 0, data_sz);\n\t\tcfg.physAddr = page1_dma;\n\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\t\tif ((rc = mpt_config(ioc, &cfg)) == 0) {\n\t\t\t \n\t\t\tcopy_sz = min_t(int, sizeof(LANPage1_t), data_sz);\n\t\t\tmemcpy(&ioc->lan_cnfg_page1, ppage1_alloc, copy_sz);\n\t\t}\n\n\t\tdma_free_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t  (u8 *)ppage1_alloc, page1_dma);\n\n\t\t \n\n\t}\n\n\treturn rc;\n}\n\n \n \n\n \nint\nmptbase_sas_persist_operation(MPT_ADAPTER *ioc, u8 persist_opcode)\n{\n\tSasIoUnitControlRequest_t\t*sasIoUnitCntrReq;\n\tSasIoUnitControlReply_t\t\t*sasIoUnitCntrReply;\n\tMPT_FRAME_HDR\t\t\t*mf = NULL;\n\tMPIHeader_t\t\t\t*mpi_hdr;\n\tint\t\t\t\tret = 0;\n\tunsigned long \t \t\ttimeleft;\n\n\tmutex_lock(&ioc->mptbase_cmds.mutex);\n\n\t \n\tmemset(ioc->mptbase_cmds.reply, 0 , MPT_DEFAULT_FRAME_SIZE);\n\tINITIALIZE_MGMT_STATUS(ioc->mptbase_cmds.status)\n\n\t \n\tswitch(persist_opcode) {\n\n\tcase MPI_SAS_OP_CLEAR_NOT_PRESENT:\n\tcase MPI_SAS_OP_CLEAR_ALL_PERSISTENT:\n\t\tbreak;\n\n\tdefault:\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tprintk(KERN_DEBUG  \"%s: persist_opcode=%x\\n\",\n\t\t__func__, persist_opcode);\n\n\t \n\tif ((mf = mpt_get_msg_frame(mpt_base_index, ioc)) == NULL) {\n\t\tprintk(KERN_DEBUG \"%s: no msg frames!\\n\", __func__);\n\t\tret = -1;\n\t\tgoto out;\n        }\n\n\tmpi_hdr = (MPIHeader_t *) mf;\n\tsasIoUnitCntrReq = (SasIoUnitControlRequest_t *)mf;\n\tmemset(sasIoUnitCntrReq,0,sizeof(SasIoUnitControlRequest_t));\n\tsasIoUnitCntrReq->Function = MPI_FUNCTION_SAS_IO_UNIT_CONTROL;\n\tsasIoUnitCntrReq->MsgContext = mpi_hdr->MsgContext;\n\tsasIoUnitCntrReq->Operation = persist_opcode;\n\n\tmpt_put_msg_frame(mpt_base_index, ioc, mf);\n\ttimeleft = wait_for_completion_timeout(&ioc->mptbase_cmds.done, 10*HZ);\n\tif (!(ioc->mptbase_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tret = -ETIME;\n\t\tprintk(KERN_DEBUG \"%s: failed\\n\", __func__);\n\t\tif (ioc->mptbase_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\n\t\t\tgoto out;\n\t\tif (!timeleft) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t       \"Issuing Reset from %s!!, doorbell=0x%08x\\n\",\n\t\t\t       ioc->name, __func__, mpt_GetIocState(ioc, 0));\n\t\t\tmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\n\t\t\tmpt_free_msg_frame(ioc, mf);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (!(ioc->mptbase_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tsasIoUnitCntrReply =\n\t    (SasIoUnitControlReply_t *)ioc->mptbase_cmds.reply;\n\tif (le16_to_cpu(sasIoUnitCntrReply->IOCStatus) != MPI_IOCSTATUS_SUCCESS) {\n\t\tprintk(KERN_DEBUG \"%s: IOCStatus=0x%X IOCLogInfo=0x%X\\n\",\n\t\t    __func__, sasIoUnitCntrReply->IOCStatus,\n\t\t    sasIoUnitCntrReply->IOCLogInfo);\n\t\tprintk(KERN_DEBUG \"%s: failed\\n\", __func__);\n\t\tret = -1;\n\t} else\n\t\tprintk(KERN_DEBUG \"%s: success\\n\", __func__);\n out:\n\n\tCLEAR_MGMT_STATUS(ioc->mptbase_cmds.status)\n\tmutex_unlock(&ioc->mptbase_cmds.mutex);\n\treturn ret;\n}\n\n \n\nstatic void\nmptbase_raid_process_event_data(MPT_ADAPTER *ioc,\n    MpiEventDataRaid_t * pRaidEventData)\n{\n\tint \tvolume;\n\tint \treason;\n\tint \tdisk;\n\tint \tstatus;\n\tint \tflags;\n\tint \tstate;\n\n\tvolume\t= pRaidEventData->VolumeID;\n\treason\t= pRaidEventData->ReasonCode;\n\tdisk\t= pRaidEventData->PhysDiskNum;\n\tstatus\t= le32_to_cpu(pRaidEventData->SettingsStatus);\n\tflags\t= (status >> 0) & 0xff;\n\tstate\t= (status >> 8) & 0xff;\n\n\tif (reason == MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED) {\n\t\treturn;\n\t}\n\n\tif ((reason >= MPI_EVENT_RAID_RC_PHYSDISK_CREATED &&\n\t     reason <= MPI_EVENT_RAID_RC_PHYSDISK_STATUS_CHANGED) ||\n\t    (reason == MPI_EVENT_RAID_RC_SMART_DATA)) {\n\t\tprintk(MYIOC_s_INFO_FMT \"RAID STATUS CHANGE for PhysDisk %d id=%d\\n\",\n\t\t\tioc->name, disk, volume);\n\t} else {\n\t\tprintk(MYIOC_s_INFO_FMT \"RAID STATUS CHANGE for VolumeID %d\\n\",\n\t\t\tioc->name, volume);\n\t}\n\n\tswitch(reason) {\n\tcase MPI_EVENT_RAID_RC_VOLUME_CREATED:\n\t\tprintk(MYIOC_s_INFO_FMT \"  volume has been created\\n\",\n\t\t\tioc->name);\n\t\tbreak;\n\n\tcase MPI_EVENT_RAID_RC_VOLUME_DELETED:\n\n\t\tprintk(MYIOC_s_INFO_FMT \"  volume has been deleted\\n\",\n\t\t\tioc->name);\n\t\tbreak;\n\n\tcase MPI_EVENT_RAID_RC_VOLUME_SETTINGS_CHANGED:\n\t\tprintk(MYIOC_s_INFO_FMT \"  volume settings have been changed\\n\",\n\t\t\tioc->name);\n\t\tbreak;\n\n\tcase MPI_EVENT_RAID_RC_VOLUME_STATUS_CHANGED:\n\t\tprintk(MYIOC_s_INFO_FMT \"  volume is now %s%s%s%s\\n\",\n\t\t\tioc->name,\n\t\t\tstate == MPI_RAIDVOL0_STATUS_STATE_OPTIMAL\n\t\t\t ? \"optimal\"\n\t\t\t : state == MPI_RAIDVOL0_STATUS_STATE_DEGRADED\n\t\t\t  ? \"degraded\"\n\t\t\t  : state == MPI_RAIDVOL0_STATUS_STATE_FAILED\n\t\t\t   ? \"failed\"\n\t\t\t   : \"state unknown\",\n\t\t\tflags & MPI_RAIDVOL0_STATUS_FLAG_ENABLED\n\t\t\t ? \", enabled\" : \"\",\n\t\t\tflags & MPI_RAIDVOL0_STATUS_FLAG_QUIESCED\n\t\t\t ? \", quiesced\" : \"\",\n\t\t\tflags & MPI_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS\n\t\t\t ? \", resync in progress\" : \"\" );\n\t\tbreak;\n\n\tcase MPI_EVENT_RAID_RC_VOLUME_PHYSDISK_CHANGED:\n\t\tprintk(MYIOC_s_INFO_FMT \"  volume membership of PhysDisk %d has changed\\n\",\n\t\t\tioc->name, disk);\n\t\tbreak;\n\n\tcase MPI_EVENT_RAID_RC_PHYSDISK_CREATED:\n\t\tprintk(MYIOC_s_INFO_FMT \"  PhysDisk has been created\\n\",\n\t\t\tioc->name);\n\t\tbreak;\n\n\tcase MPI_EVENT_RAID_RC_PHYSDISK_DELETED:\n\t\tprintk(MYIOC_s_INFO_FMT \"  PhysDisk has been deleted\\n\",\n\t\t\tioc->name);\n\t\tbreak;\n\n\tcase MPI_EVENT_RAID_RC_PHYSDISK_SETTINGS_CHANGED:\n\t\tprintk(MYIOC_s_INFO_FMT \"  PhysDisk settings have been changed\\n\",\n\t\t\tioc->name);\n\t\tbreak;\n\n\tcase MPI_EVENT_RAID_RC_PHYSDISK_STATUS_CHANGED:\n\t\tprintk(MYIOC_s_INFO_FMT \"  PhysDisk is now %s%s%s\\n\",\n\t\t\tioc->name,\n\t\t\tstate == MPI_PHYSDISK0_STATUS_ONLINE\n\t\t\t ? \"online\"\n\t\t\t : state == MPI_PHYSDISK0_STATUS_MISSING\n\t\t\t  ? \"missing\"\n\t\t\t  : state == MPI_PHYSDISK0_STATUS_NOT_COMPATIBLE\n\t\t\t   ? \"not compatible\"\n\t\t\t   : state == MPI_PHYSDISK0_STATUS_FAILED\n\t\t\t    ? \"failed\"\n\t\t\t    : state == MPI_PHYSDISK0_STATUS_INITIALIZING\n\t\t\t     ? \"initializing\"\n\t\t\t     : state == MPI_PHYSDISK0_STATUS_OFFLINE_REQUESTED\n\t\t\t      ? \"offline requested\"\n\t\t\t      : state == MPI_PHYSDISK0_STATUS_FAILED_REQUESTED\n\t\t\t       ? \"failed requested\"\n\t\t\t       : state == MPI_PHYSDISK0_STATUS_OTHER_OFFLINE\n\t\t\t        ? \"offline\"\n\t\t\t        : \"state unknown\",\n\t\t\tflags & MPI_PHYSDISK0_STATUS_FLAG_OUT_OF_SYNC\n\t\t\t ? \", out of sync\" : \"\",\n\t\t\tflags & MPI_PHYSDISK0_STATUS_FLAG_QUIESCED\n\t\t\t ? \", quiesced\" : \"\" );\n\t\tbreak;\n\n\tcase MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED:\n\t\tprintk(MYIOC_s_INFO_FMT \"  Domain Validation needed for PhysDisk %d\\n\",\n\t\t\tioc->name, disk);\n\t\tbreak;\n\n\tcase MPI_EVENT_RAID_RC_SMART_DATA:\n\t\tprintk(MYIOC_s_INFO_FMT \"  SMART data received, ASC/ASCQ = %02xh/%02xh\\n\",\n\t\t\tioc->name, pRaidEventData->ASC, pRaidEventData->ASCQ);\n\t\tbreak;\n\n\tcase MPI_EVENT_RAID_RC_REPLACE_ACTION_STARTED:\n\t\tprintk(MYIOC_s_INFO_FMT \"  replacement of PhysDisk %d has started\\n\",\n\t\t\tioc->name, disk);\n\t\tbreak;\n\t}\n}\n\n \n \nstatic int\nGetIoUnitPage2(MPT_ADAPTER *ioc)\n{\n\tConfigPageHeader_t\t hdr;\n\tCONFIGPARMS\t\t cfg;\n\tIOUnitPage2_t\t\t*ppage_alloc;\n\tdma_addr_t\t\t page_dma;\n\tint\t\t\t data_sz;\n\tint\t\t\t rc;\n\n\t \n\thdr.PageVersion = 0;\n\thdr.PageLength = 0;\n\thdr.PageNumber = 2;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_IO_UNIT;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.pageAddr = 0;\n\tcfg.timeout = 0;\n\n\tif ((rc = mpt_config(ioc, &cfg)) != 0)\n\t\treturn rc;\n\n\tif (hdr.PageLength == 0)\n\t\treturn 0;\n\n\t \n\tdata_sz = hdr.PageLength * 4;\n\trc = -ENOMEM;\n\tppage_alloc = dma_alloc_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t\t &page_dma, GFP_KERNEL);\n\tif (ppage_alloc) {\n\t\tmemset((u8 *)ppage_alloc, 0, data_sz);\n\t\tcfg.physAddr = page_dma;\n\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\t\t \n\t\tif ((rc = mpt_config(ioc, &cfg)) == 0)\n\t\t\tioc->biosVersion = le32_to_cpu(ppage_alloc->BiosVersion);\n\n\t\tdma_free_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t  (u8 *)ppage_alloc, page_dma);\n\t}\n\n\treturn rc;\n}\n\n \n \nstatic int\nmpt_GetScsiPortSettings(MPT_ADAPTER *ioc, int portnum)\n{\n\tu8\t\t\t*pbuf;\n\tdma_addr_t\t\t buf_dma;\n\tCONFIGPARMS\t\t cfg;\n\tConfigPageHeader_t\t header;\n\tint\t\t\t ii;\n\tint\t\t\t data, rc = 0;\n\n\t \n\tif (!ioc->spi_data.nvram) {\n\t\tint\t sz;\n\t\tu8\t*mem;\n\t\tsz = MPT_MAX_SCSI_DEVICES * sizeof(int);\n\t\tmem = kmalloc(sz, GFP_ATOMIC);\n\t\tif (mem == NULL)\n\t\t\treturn -EFAULT;\n\n\t\tioc->spi_data.nvram = (int *) mem;\n\n\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"SCSI device NVRAM settings @ %p, sz=%d\\n\",\n\t\t\tioc->name, ioc->spi_data.nvram, sz));\n\t}\n\n\t \n\tfor (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {\n\t\tioc->spi_data.nvram[ii] = MPT_HOST_NVRAM_INVALID;\n\t}\n\n\t \n\theader.PageVersion = 0;\n\theader.PageLength = 0;\n\theader.PageNumber = 0;\n\theader.PageType = MPI_CONFIG_PAGETYPE_SCSI_PORT;\n\tcfg.cfghdr.hdr = &header;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = portnum;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.timeout = 0;\t \n\tif (mpt_config(ioc, &cfg) != 0)\n\t\t return -EFAULT;\n\n\tif (header.PageLength > 0) {\n\t\tpbuf = dma_alloc_coherent(&ioc->pcidev->dev,\n\t\t\t\t\t  header.PageLength * 4, &buf_dma,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (pbuf) {\n\t\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\t\t\tcfg.physAddr = buf_dma;\n\t\t\tif (mpt_config(ioc, &cfg) != 0) {\n\t\t\t\tioc->spi_data.maxBusWidth = MPT_NARROW;\n\t\t\t\tioc->spi_data.maxSyncOffset = 0;\n\t\t\t\tioc->spi_data.minSyncFactor = MPT_ASYNC;\n\t\t\t\tioc->spi_data.busType = MPT_HOST_BUS_UNKNOWN;\n\t\t\t\trc = 1;\n\t\t\t\tddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\"Unable to read PortPage0 minSyncFactor=%x\\n\",\n\t\t\t\t\tioc->name, ioc->spi_data.minSyncFactor));\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tSCSIPortPage0_t  *pPP0 = (SCSIPortPage0_t  *) pbuf;\n\t\t\t\tpPP0->Capabilities = le32_to_cpu(pPP0->Capabilities);\n\t\t\t\tpPP0->PhysicalInterface = le32_to_cpu(pPP0->PhysicalInterface);\n\n\t\t\t\tif ( (pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_QAS) == 0 ) {\n\t\t\t\t\tioc->spi_data.noQas |= MPT_TARGET_NO_NEGO_QAS;\n\t\t\t\t\tddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\t\"noQas due to Capabilities=%x\\n\",\n\t\t\t\t\t\tioc->name, pPP0->Capabilities));\n\t\t\t\t}\n\t\t\t\tioc->spi_data.maxBusWidth = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_WIDE ? 1 : 0;\n\t\t\t\tdata = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_MAX_SYNC_OFFSET_MASK;\n\t\t\t\tif (data) {\n\t\t\t\t\tioc->spi_data.maxSyncOffset = (u8) (data >> 16);\n\t\t\t\t\tdata = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK;\n\t\t\t\t\tioc->spi_data.minSyncFactor = (u8) (data >> 8);\n\t\t\t\t\tddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\t\"PortPage0 minSyncFactor=%x\\n\",\n\t\t\t\t\t\tioc->name, ioc->spi_data.minSyncFactor));\n\t\t\t\t} else {\n\t\t\t\t\tioc->spi_data.maxSyncOffset = 0;\n\t\t\t\t\tioc->spi_data.minSyncFactor = MPT_ASYNC;\n\t\t\t\t}\n\n\t\t\t\tioc->spi_data.busType = pPP0->PhysicalInterface & MPI_SCSIPORTPAGE0_PHY_SIGNAL_TYPE_MASK;\n\n\t\t\t\t \n\t\t\t\tif ((ioc->spi_data.busType == MPI_SCSIPORTPAGE0_PHY_SIGNAL_HVD) ||\n\t\t\t\t\t(ioc->spi_data.busType == MPI_SCSIPORTPAGE0_PHY_SIGNAL_SE))  {\n\n\t\t\t\t\tif (ioc->spi_data.minSyncFactor < MPT_ULTRA) {\n\t\t\t\t\t\tioc->spi_data.minSyncFactor = MPT_ULTRA;\n\t\t\t\t\t\tddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\t\t\"HVD or SE detected, minSyncFactor=%x\\n\",\n\t\t\t\t\t\t\tioc->name, ioc->spi_data.minSyncFactor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pbuf) {\n\t\t\t\tdma_free_coherent(&ioc->pcidev->dev,\n\t\t\t\t\t\t  header.PageLength * 4, pbuf,\n\t\t\t\t\t\t  buf_dma);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\theader.PageVersion = 0;\n\theader.PageLength = 0;\n\theader.PageNumber = 2;\n\theader.PageType = MPI_CONFIG_PAGETYPE_SCSI_PORT;\n\tcfg.cfghdr.hdr = &header;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = portnum;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\treturn -EFAULT;\n\n\tif (header.PageLength > 0) {\n\t\t \n\t\tpbuf = dma_alloc_coherent(&ioc->pcidev->dev,\n\t\t\t\t\t  header.PageLength * 4, &buf_dma,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (pbuf) {\n\t\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_NVRAM;\n\t\t\tcfg.physAddr = buf_dma;\n\t\t\tif (mpt_config(ioc, &cfg) != 0) {\n\t\t\t\t \n\t\t\t\trc = 1;\n\t\t\t} else if (ioc->pcidev->vendor == PCI_VENDOR_ID_ATTO) {\n\n\t\t\t\t \n\t\t\t\tATTO_SCSIPortPage2_t *pPP2 = (ATTO_SCSIPortPage2_t  *) pbuf;\n\t\t\t\tATTODeviceInfo_t *pdevice = NULL;\n\t\t\t\tu16 ATTOFlags;\n\n\t\t\t\t \n\t\t\t\tfor (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {\n\t\t\t\t  pdevice = &pPP2->DeviceSettings[ii];\n\t\t\t\t  ATTOFlags = le16_to_cpu(pdevice->ATTOFlags);\n\t\t\t\t  data = 0;\n\n\t\t\t\t   \n\t\t\t\t  if (ATTOFlags & ATTOFLAG_DISC)\n\t\t\t\t    data |= (MPI_SCSIPORTPAGE2_DEVICE_DISCONNECT_ENABLE);\n\t\t\t\t  if (ATTOFlags & ATTOFLAG_ID_ENB)\n\t\t\t\t    data |= (MPI_SCSIPORTPAGE2_DEVICE_ID_SCAN_ENABLE);\n\t\t\t\t  if (ATTOFlags & ATTOFLAG_LUN_ENB)\n\t\t\t\t    data |= (MPI_SCSIPORTPAGE2_DEVICE_LUN_SCAN_ENABLE);\n\t\t\t\t  if (ATTOFlags & ATTOFLAG_TAGGED)\n\t\t\t\t    data |= (MPI_SCSIPORTPAGE2_DEVICE_TAG_QUEUE_ENABLE);\n\t\t\t\t  if (!(ATTOFlags & ATTOFLAG_WIDE_ENB))\n\t\t\t\t    data |= (MPI_SCSIPORTPAGE2_DEVICE_WIDE_DISABLE);\n\n\t\t\t\t  data = (data << 16) | (pdevice->Period << 8) | 10;\n\t\t\t\t  ioc->spi_data.nvram[ii] = data;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSCSIPortPage2_t *pPP2 = (SCSIPortPage2_t  *) pbuf;\n\t\t\t\tMpiDeviceInfo_t\t*pdevice = NULL;\n\n\t\t\t\t \n\t\t\t\tioc->spi_data.bus_reset =\n\t\t\t\t    (le32_to_cpu(pPP2->PortFlags) &\n\t\t\t        MPI_SCSIPORTPAGE2_PORT_FLAGS_AVOID_SCSI_RESET) ?\n\t\t\t\t    0 : 1 ;\n\n\t\t\t\t \n\t\t\t\tdata = le32_to_cpu(pPP2->PortFlags) & MPI_SCSIPORTPAGE2_PORT_FLAGS_DV_MASK;\n\t\t\t\tioc->spi_data.PortFlags = data;\n\t\t\t\tfor (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {\n\t\t\t\t\tpdevice = &pPP2->DeviceSettings[ii];\n\t\t\t\t\tdata = (le16_to_cpu(pdevice->DeviceFlags) << 16) |\n\t\t\t\t\t\t(pdevice->SyncFactor << 8) | pdevice->Timeout;\n\t\t\t\t\tioc->spi_data.nvram[ii] = data;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdma_free_coherent(&ioc->pcidev->dev,\n\t\t\t\t\t  header.PageLength * 4, pbuf,\n\t\t\t\t\t  buf_dma);\n\t\t}\n\t}\n\n\t \n\n\treturn rc;\n}\n\n \n \nstatic int\nmpt_readScsiDevicePageHeaders(MPT_ADAPTER *ioc, int portnum)\n{\n\tCONFIGPARMS\t\t cfg;\n\tConfigPageHeader_t\t header;\n\n\t \n\theader.PageVersion = 0;\n\theader.PageLength = 0;\n\theader.PageNumber = 1;\n\theader.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\n\tcfg.cfghdr.hdr = &header;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = portnum;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.timeout = 0;\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\t return -EFAULT;\n\n\tioc->spi_data.sdp1version = cfg.cfghdr.hdr->PageVersion;\n\tioc->spi_data.sdp1length = cfg.cfghdr.hdr->PageLength;\n\n\theader.PageVersion = 0;\n\theader.PageLength = 0;\n\theader.PageNumber = 0;\n\theader.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\t return -EFAULT;\n\n\tioc->spi_data.sdp0version = cfg.cfghdr.hdr->PageVersion;\n\tioc->spi_data.sdp0length = cfg.cfghdr.hdr->PageLength;\n\n\tdcprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Headers: 0: version %d length %d\\n\",\n\t\t\tioc->name, ioc->spi_data.sdp0version, ioc->spi_data.sdp0length));\n\n\tdcprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Headers: 1: version %d length %d\\n\",\n\t\t\tioc->name, ioc->spi_data.sdp1version, ioc->spi_data.sdp1length));\n\treturn 0;\n}\n\n \nstatic void\nmpt_inactive_raid_list_free(MPT_ADAPTER *ioc)\n{\n\tstruct inactive_raid_component_info *component_info, *pNext;\n\n\tif (list_empty(&ioc->raid_data.inactive_list))\n\t\treturn;\n\n\tmutex_lock(&ioc->raid_data.inactive_list_mutex);\n\tlist_for_each_entry_safe(component_info, pNext,\n\t    &ioc->raid_data.inactive_list, list) {\n\t\tlist_del(&component_info->list);\n\t\tkfree(component_info);\n\t}\n\tmutex_unlock(&ioc->raid_data.inactive_list_mutex);\n}\n\n \nstatic void\nmpt_inactive_raid_volumes(MPT_ADAPTER *ioc, u8 channel, u8 id)\n{\n\tCONFIGPARMS\t\t\tcfg;\n\tConfigPageHeader_t\t\thdr;\n\tdma_addr_t\t\t\tdma_handle;\n\tpRaidVolumePage0_t\t\tbuffer = NULL;\n\tint\t\t\t\ti;\n\tRaidPhysDiskPage0_t \t\tphys_disk;\n\tstruct inactive_raid_component_info *component_info;\n\tint\t\t\t\thandle_inactive_volumes;\n\n\tmemset(&cfg, 0 , sizeof(CONFIGPARMS));\n\tmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\n\thdr.PageType = MPI_CONFIG_PAGETYPE_RAID_VOLUME;\n\tcfg.pageAddr = (channel << 8) + id;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\tgoto out;\n\n\tif (!hdr.PageLength)\n\t\tgoto out;\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\n\tif (!buffer)\n\t\tgoto out;\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\tgoto out;\n\n\tif (!buffer->NumPhysDisks)\n\t\tgoto out;\n\n\thandle_inactive_volumes =\n\t   (buffer->VolumeStatus.Flags & MPI_RAIDVOL0_STATUS_FLAG_VOLUME_INACTIVE ||\n\t   (buffer->VolumeStatus.Flags & MPI_RAIDVOL0_STATUS_FLAG_ENABLED) == 0 ||\n\t    buffer->VolumeStatus.State == MPI_RAIDVOL0_STATUS_STATE_FAILED ||\n\t    buffer->VolumeStatus.State == MPI_RAIDVOL0_STATUS_STATE_MISSING) ? 1 : 0;\n\n\tif (!handle_inactive_volumes)\n\t\tgoto out;\n\n\tmutex_lock(&ioc->raid_data.inactive_list_mutex);\n\tfor (i = 0; i < buffer->NumPhysDisks; i++) {\n\t\tif(mpt_raid_phys_disk_pg0(ioc,\n\t\t    buffer->PhysDisk[i].PhysDiskNum, &phys_disk) != 0)\n\t\t\tcontinue;\n\n\t\tif ((component_info = kmalloc(sizeof (*component_info),\n\t\t GFP_KERNEL)) == NULL)\n\t\t\tcontinue;\n\n\t\tcomponent_info->volumeID = id;\n\t\tcomponent_info->volumeBus = channel;\n\t\tcomponent_info->d.PhysDiskNum = phys_disk.PhysDiskNum;\n\t\tcomponent_info->d.PhysDiskBus = phys_disk.PhysDiskBus;\n\t\tcomponent_info->d.PhysDiskID = phys_disk.PhysDiskID;\n\t\tcomponent_info->d.PhysDiskIOC = phys_disk.PhysDiskIOC;\n\n\t\tlist_add_tail(&component_info->list,\n\t\t    &ioc->raid_data.inactive_list);\n\t}\n\tmutex_unlock(&ioc->raid_data.inactive_list_mutex);\n\n out:\n\tif (buffer)\n\t\tdma_free_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t  buffer, dma_handle);\n}\n\n \nint\nmpt_raid_phys_disk_pg0(MPT_ADAPTER *ioc, u8 phys_disk_num,\n\t\t\tRaidPhysDiskPage0_t *phys_disk)\n{\n\tCONFIGPARMS\t\t\tcfg;\n\tConfigPageHeader_t\t\thdr;\n\tdma_addr_t\t\t\tdma_handle;\n\tpRaidPhysDiskPage0_t\t\tbuffer = NULL;\n\tint\t\t\t\trc;\n\n\tmemset(&cfg, 0 , sizeof(CONFIGPARMS));\n\tmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\n\tmemset(phys_disk, 0, sizeof(RaidPhysDiskPage0_t));\n\n\thdr.PageVersion = MPI_RAIDPHYSDISKPAGE0_PAGEVERSION;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_RAID_PHYSDISK;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\n\tif (mpt_config(ioc, &cfg) != 0) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (!hdr.PageLength) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\n\tif (!buffer) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\tcfg.pageAddr = phys_disk_num;\n\n\tif (mpt_config(ioc, &cfg) != 0) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\tmemcpy(phys_disk, buffer, sizeof(*buffer));\n\tphys_disk->MaxLBA = le32_to_cpu(buffer->MaxLBA);\n\n out:\n\n\tif (buffer)\n\t\tdma_free_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t  buffer, dma_handle);\n\n\treturn rc;\n}\n\n \nint\nmpt_raid_phys_disk_get_num_paths(MPT_ADAPTER *ioc, u8 phys_disk_num)\n{\n\tCONFIGPARMS\t\t \tcfg;\n\tConfigPageHeader_t\t \thdr;\n\tdma_addr_t\t\t\tdma_handle;\n\tpRaidPhysDiskPage1_t\t\tbuffer = NULL;\n\tint\t\t\t\trc;\n\n\tmemset(&cfg, 0 , sizeof(CONFIGPARMS));\n\tmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\n\n\thdr.PageVersion = MPI_RAIDPHYSDISKPAGE1_PAGEVERSION;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_RAID_PHYSDISK;\n\thdr.PageNumber = 1;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\n\tif (mpt_config(ioc, &cfg) != 0) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (!hdr.PageLength) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\n\tif (!buffer) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\tcfg.pageAddr = phys_disk_num;\n\n\tif (mpt_config(ioc, &cfg) != 0) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = buffer->NumPhysDiskPaths;\n out:\n\n\tif (buffer)\n\t\tdma_free_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t  buffer, dma_handle);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(mpt_raid_phys_disk_get_num_paths);\n\n \nint\nmpt_raid_phys_disk_pg1(MPT_ADAPTER *ioc, u8 phys_disk_num,\n\t\tRaidPhysDiskPage1_t *phys_disk)\n{\n\tCONFIGPARMS\t\t \tcfg;\n\tConfigPageHeader_t\t \thdr;\n\tdma_addr_t\t\t\tdma_handle;\n\tpRaidPhysDiskPage1_t\t\tbuffer = NULL;\n\tint\t\t\t\trc;\n\tint\t\t\t\ti;\n\t__le64\t\t\t\tsas_address;\n\n\tmemset(&cfg, 0 , sizeof(CONFIGPARMS));\n\tmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\n\trc = 0;\n\n\thdr.PageVersion = MPI_RAIDPHYSDISKPAGE1_PAGEVERSION;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_RAID_PHYSDISK;\n\thdr.PageNumber = 1;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\n\tif (mpt_config(ioc, &cfg) != 0) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (!hdr.PageLength) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\n\tif (!buffer) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\tcfg.pageAddr = phys_disk_num;\n\n\tif (mpt_config(ioc, &cfg) != 0) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tphys_disk->NumPhysDiskPaths = buffer->NumPhysDiskPaths;\n\tphys_disk->PhysDiskNum = phys_disk_num;\n\tfor (i = 0; i < phys_disk->NumPhysDiskPaths; i++) {\n\t\tphys_disk->Path[i].PhysDiskID = buffer->Path[i].PhysDiskID;\n\t\tphys_disk->Path[i].PhysDiskBus = buffer->Path[i].PhysDiskBus;\n\t\tphys_disk->Path[i].OwnerIdentifier =\n\t\t\t\tbuffer->Path[i].OwnerIdentifier;\n\t\tphys_disk->Path[i].Flags = le16_to_cpu(buffer->Path[i].Flags);\n\t\tmemcpy(&sas_address, &buffer->Path[i].WWID, sizeof(__le64));\n\t\tsas_address = le64_to_cpu(sas_address);\n\t\tmemcpy(&phys_disk->Path[i].WWID, &sas_address, sizeof(__le64));\n\t\tmemcpy(&sas_address,\n\t\t\t\t&buffer->Path[i].OwnerWWID, sizeof(__le64));\n\t\tsas_address = le64_to_cpu(sas_address);\n\t\tmemcpy(&phys_disk->Path[i].OwnerWWID,\n\t\t\t\t&sas_address, sizeof(__le64));\n\t}\n\n out:\n\n\tif (buffer)\n\t\tdma_free_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t  buffer, dma_handle);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(mpt_raid_phys_disk_pg1);\n\n\n \nint\nmpt_findImVolumes(MPT_ADAPTER *ioc)\n{\n\tIOCPage2_t\t\t*pIoc2;\n\tu8\t\t\t*mem;\n\tdma_addr_t\t\t ioc2_dma;\n\tCONFIGPARMS\t\t cfg;\n\tConfigPageHeader_t\t header;\n\tint\t\t\t rc = 0;\n\tint\t\t\t iocpage2sz;\n\tint\t\t\t i;\n\n\tif (!ioc->ir_firmware)\n\t\treturn 0;\n\n\t \n\tkfree(ioc->raid_data.pIocPg2);\n\tioc->raid_data.pIocPg2 = NULL;\n\tmpt_inactive_raid_list_free(ioc);\n\n\t \n\theader.PageVersion = 0;\n\theader.PageLength = 0;\n\theader.PageNumber = 2;\n\theader.PageType = MPI_CONFIG_PAGETYPE_IOC;\n\tcfg.cfghdr.hdr = &header;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = 0;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.timeout = 0;\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\t return -EFAULT;\n\n\tif (header.PageLength == 0)\n\t\treturn -EFAULT;\n\n\tiocpage2sz = header.PageLength * 4;\n\tpIoc2 = dma_alloc_coherent(&ioc->pcidev->dev, iocpage2sz, &ioc2_dma,\n\t\t\t\t   GFP_KERNEL);\n\tif (!pIoc2)\n\t\treturn -ENOMEM;\n\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\tcfg.physAddr = ioc2_dma;\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\tgoto out;\n\n\tmem = kmemdup(pIoc2, iocpage2sz, GFP_KERNEL);\n\tif (!mem) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tioc->raid_data.pIocPg2 = (IOCPage2_t *) mem;\n\n\tmpt_read_ioc_pg_3(ioc);\n\n\tfor (i = 0; i < pIoc2->NumActiveVolumes ; i++)\n\t\tmpt_inactive_raid_volumes(ioc,\n\t\t    pIoc2->RaidVolume[i].VolumeBus,\n\t\t    pIoc2->RaidVolume[i].VolumeID);\n\n out:\n\tdma_free_coherent(&ioc->pcidev->dev, iocpage2sz, pIoc2, ioc2_dma);\n\n\treturn rc;\n}\n\nstatic int\nmpt_read_ioc_pg_3(MPT_ADAPTER *ioc)\n{\n\tIOCPage3_t\t\t*pIoc3;\n\tu8\t\t\t*mem;\n\tCONFIGPARMS\t\t cfg;\n\tConfigPageHeader_t\t header;\n\tdma_addr_t\t\t ioc3_dma;\n\tint\t\t\t iocpage3sz = 0;\n\n\t \n\tkfree(ioc->raid_data.pIocPg3);\n\tioc->raid_data.pIocPg3 = NULL;\n\n\t \n\theader.PageVersion = 0;\n\theader.PageLength = 0;\n\theader.PageNumber = 3;\n\theader.PageType = MPI_CONFIG_PAGETYPE_IOC;\n\tcfg.cfghdr.hdr = &header;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = 0;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.timeout = 0;\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\treturn 0;\n\n\tif (header.PageLength == 0)\n\t\treturn 0;\n\n\t \n\tiocpage3sz = header.PageLength * 4;\n\tpIoc3 = dma_alloc_coherent(&ioc->pcidev->dev, iocpage3sz, &ioc3_dma,\n\t\t\t\t   GFP_KERNEL);\n\tif (!pIoc3)\n\t\treturn 0;\n\n\t \n\tcfg.physAddr = ioc3_dma;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\tif (mpt_config(ioc, &cfg) == 0) {\n\t\tmem = kmalloc(iocpage3sz, GFP_KERNEL);\n\t\tif (mem) {\n\t\t\tmemcpy(mem, (u8 *)pIoc3, iocpage3sz);\n\t\t\tioc->raid_data.pIocPg3 = (IOCPage3_t *) mem;\n\t\t}\n\t}\n\n\tdma_free_coherent(&ioc->pcidev->dev, iocpage3sz, pIoc3, ioc3_dma);\n\n\treturn 0;\n}\n\nstatic void\nmpt_read_ioc_pg_4(MPT_ADAPTER *ioc)\n{\n\tIOCPage4_t\t\t*pIoc4;\n\tCONFIGPARMS\t\t cfg;\n\tConfigPageHeader_t\t header;\n\tdma_addr_t\t\t ioc4_dma;\n\tint\t\t\t iocpage4sz;\n\n\t \n\theader.PageVersion = 0;\n\theader.PageLength = 0;\n\theader.PageNumber = 4;\n\theader.PageType = MPI_CONFIG_PAGETYPE_IOC;\n\tcfg.cfghdr.hdr = &header;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = 0;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.timeout = 0;\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\treturn;\n\n\tif (header.PageLength == 0)\n\t\treturn;\n\n\tif ( (pIoc4 = ioc->spi_data.pIocPg4) == NULL ) {\n\t\tiocpage4sz = (header.PageLength + 4) * 4;  \n\t\tpIoc4 = dma_alloc_coherent(&ioc->pcidev->dev, iocpage4sz,\n\t\t\t\t\t   &ioc4_dma, GFP_KERNEL);\n\t\tif (!pIoc4)\n\t\t\treturn;\n\t\tioc->alloc_total += iocpage4sz;\n\t} else {\n\t\tioc4_dma = ioc->spi_data.IocPg4_dma;\n\t\tiocpage4sz = ioc->spi_data.IocPg4Sz;\n\t}\n\n\t \n\tcfg.physAddr = ioc4_dma;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\tif (mpt_config(ioc, &cfg) == 0) {\n\t\tioc->spi_data.pIocPg4 = (IOCPage4_t *) pIoc4;\n\t\tioc->spi_data.IocPg4_dma = ioc4_dma;\n\t\tioc->spi_data.IocPg4Sz = iocpage4sz;\n\t} else {\n\t\tdma_free_coherent(&ioc->pcidev->dev, iocpage4sz, pIoc4,\n\t\t\t\t  ioc4_dma);\n\t\tioc->spi_data.pIocPg4 = NULL;\n\t\tioc->alloc_total -= iocpage4sz;\n\t}\n}\n\nstatic void\nmpt_read_ioc_pg_1(MPT_ADAPTER *ioc)\n{\n\tIOCPage1_t\t\t*pIoc1;\n\tCONFIGPARMS\t\t cfg;\n\tConfigPageHeader_t\t header;\n\tdma_addr_t\t\t ioc1_dma;\n\tint\t\t\t iocpage1sz = 0;\n\tu32\t\t\t tmp;\n\n\t \n\theader.PageVersion = 0;\n\theader.PageLength = 0;\n\theader.PageNumber = 1;\n\theader.PageType = MPI_CONFIG_PAGETYPE_IOC;\n\tcfg.cfghdr.hdr = &header;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = 0;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.timeout = 0;\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\treturn;\n\n\tif (header.PageLength == 0)\n\t\treturn;\n\n\t \n\tiocpage1sz = header.PageLength * 4;\n\tpIoc1 = dma_alloc_coherent(&ioc->pcidev->dev, iocpage1sz, &ioc1_dma,\n\t\t\t\t   GFP_KERNEL);\n\tif (!pIoc1)\n\t\treturn;\n\n\t \n\tcfg.physAddr = ioc1_dma;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\tif (mpt_config(ioc, &cfg) == 0) {\n\n\t\ttmp = le32_to_cpu(pIoc1->Flags) & MPI_IOCPAGE1_REPLY_COALESCING;\n\t\tif (tmp == MPI_IOCPAGE1_REPLY_COALESCING) {\n\t\t\ttmp = le32_to_cpu(pIoc1->CoalescingTimeout);\n\n\t\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Coalescing Enabled Timeout = %d\\n\",\n\t\t\t\t\tioc->name, tmp));\n\n\t\t\tif (tmp > MPT_COALESCING_TIMEOUT) {\n\t\t\t\tpIoc1->CoalescingTimeout = cpu_to_le32(MPT_COALESCING_TIMEOUT);\n\n\t\t\t\t \n\t\t\t\tcfg.dir = 1;\n\t\t\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;\n\t\t\t\tif (mpt_config(ioc, &cfg) == 0) {\n\t\t\t\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Reset Current Coalescing Timeout to = %d\\n\",\n\t\t\t\t\t\t\tioc->name, MPT_COALESCING_TIMEOUT));\n\n\t\t\t\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM;\n\t\t\t\t\tif (mpt_config(ioc, &cfg) == 0) {\n\t\t\t\t\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\t\t\t\"Reset NVRAM Coalescing Timeout to = %d\\n\",\n\t\t\t\t\t\t\t\tioc->name, MPT_COALESCING_TIMEOUT));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\t\t\t\"Reset NVRAM Coalescing Timeout Failed\\n\",\n\t\t\t\t\t\t\t\tioc->name));\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(ioc, printk(MYIOC_s_WARN_FMT\n\t\t\t\t\t\t\"Reset of Current Coalescing Timeout Failed!\\n\",\n\t\t\t\t\t\tioc->name));\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tdprintk(ioc, printk(MYIOC_s_WARN_FMT \"Coalescing Disabled\\n\", ioc->name));\n\t\t}\n\t}\n\n\tdma_free_coherent(&ioc->pcidev->dev, iocpage1sz, pIoc1, ioc1_dma);\n\n\treturn;\n}\n\nstatic void\nmpt_get_manufacturing_pg_0(MPT_ADAPTER *ioc)\n{\n\tCONFIGPARMS\t\tcfg;\n\tConfigPageHeader_t\thdr;\n\tdma_addr_t\t\tbuf_dma;\n\tManufacturingPage0_t\t*pbuf = NULL;\n\n\tmemset(&cfg, 0 , sizeof(CONFIGPARMS));\n\tmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\n\n\thdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.timeout = 10;\n\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\tgoto out;\n\n\tif (!cfg.cfghdr.hdr->PageLength)\n\t\tgoto out;\n\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\tpbuf = dma_alloc_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t  &buf_dma, GFP_KERNEL);\n\tif (!pbuf)\n\t\tgoto out;\n\n\tcfg.physAddr = buf_dma;\n\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\tgoto out;\n\n\tmemcpy(ioc->board_name, pbuf->BoardName, sizeof(ioc->board_name));\n\tmemcpy(ioc->board_assembly, pbuf->BoardAssembly, sizeof(ioc->board_assembly));\n\tmemcpy(ioc->board_tracer, pbuf->BoardTracerNumber, sizeof(ioc->board_tracer));\n\nout:\n\n\tif (pbuf)\n\t\tdma_free_coherent(&ioc->pcidev->dev, hdr.PageLength * 4, pbuf,\n\t\t\t\t  buf_dma);\n}\n\n \n \nstatic int\nSendEventNotification(MPT_ADAPTER *ioc, u8 EvSwitch, int sleepFlag)\n{\n\tEventNotification_t\tevn;\n\tMPIDefaultReply_t\treply_buf;\n\n\tmemset(&evn, 0, sizeof(EventNotification_t));\n\tmemset(&reply_buf, 0, sizeof(MPIDefaultReply_t));\n\n\tevn.Function = MPI_FUNCTION_EVENT_NOTIFICATION;\n\tevn.Switch = EvSwitch;\n\tevn.MsgContext = cpu_to_le32(mpt_base_index << 16);\n\n\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"Sending EventNotification (%d) request %p\\n\",\n\t    ioc->name, EvSwitch, &evn));\n\n\treturn mpt_handshake_req_reply_wait(ioc, sizeof(EventNotification_t),\n\t    (u32 *)&evn, sizeof(MPIDefaultReply_t), (u16 *)&reply_buf, 30,\n\t    sleepFlag);\n}\n\n \n \nstatic int\nSendEventAck(MPT_ADAPTER *ioc, EventNotificationReply_t *evnp)\n{\n\tEventAck_t\t*pAck;\n\n\tif ((pAck = (EventAck_t *) mpt_get_msg_frame(mpt_base_index, ioc)) == NULL) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_WARN_FMT \"%s, no msg frames!!\\n\",\n\t\t    ioc->name, __func__));\n\t\treturn -1;\n\t}\n\n\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Sending EventAck\\n\", ioc->name));\n\n\tpAck->Function     = MPI_FUNCTION_EVENT_ACK;\n\tpAck->ChainOffset  = 0;\n\tpAck->Reserved[0]  = pAck->Reserved[1] = 0;\n\tpAck->MsgFlags     = 0;\n\tpAck->Reserved1[0] = pAck->Reserved1[1] = pAck->Reserved1[2] = 0;\n\tpAck->Event        = evnp->Event;\n\tpAck->EventContext = evnp->EventContext;\n\n\tmpt_put_msg_frame(mpt_base_index, ioc, (MPT_FRAME_HDR *)pAck);\n\n\treturn 0;\n}\n\n \n \nint\nmpt_config(MPT_ADAPTER *ioc, CONFIGPARMS *pCfg)\n{\n\tConfig_t\t*pReq;\n\tConfigReply_t\t*pReply;\n\tConfigExtendedPageHeader_t  *pExtHdr = NULL;\n\tMPT_FRAME_HDR\t*mf;\n\tint\t\t ii;\n\tint\t\t flagsLength;\n\tlong\t\t timeout;\n\tint\t\t ret;\n\tu8\t\t page_type = 0, extend_page;\n\tunsigned long \t timeleft;\n\tunsigned long\t flags;\n\tu8\t\t issue_hard_reset = 0;\n\tu8\t\t retry_count = 0;\n\n\tmight_sleep();\n\n\t \n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: busy with host reset\\n\", ioc->name, __func__));\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\treturn -EBUSY;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\t \n\tif (!ioc->active ||\n\t    mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_OPERATIONAL) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: ioc not operational, %d, %xh\\n\",\n\t\t    ioc->name, __func__, ioc->active,\n\t\t    mpt_GetIocState(ioc, 0)));\n\t\treturn -EFAULT;\n\t}\n\n retry_config:\n\tmutex_lock(&ioc->mptbase_cmds.mutex);\n\t \n\tmemset(ioc->mptbase_cmds.reply, 0 , MPT_DEFAULT_FRAME_SIZE);\n\tINITIALIZE_MGMT_STATUS(ioc->mptbase_cmds.status)\n\n\t \n\tif ((mf = mpt_get_msg_frame(mpt_base_index, ioc)) == NULL) {\n\t\tdcprintk(ioc, printk(MYIOC_s_WARN_FMT\n\t\t\"mpt_config: no msg frames!\\n\", ioc->name));\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tpReq = (Config_t *)mf;\n\tpReq->Action = pCfg->action;\n\tpReq->Reserved = 0;\n\tpReq->ChainOffset = 0;\n\tpReq->Function = MPI_FUNCTION_CONFIG;\n\n\t \n\tpReq->ExtPageLength = 0;\n\tpReq->ExtPageType = 0;\n\tpReq->MsgFlags = 0;\n\n\tfor (ii=0; ii < 8; ii++)\n\t\tpReq->Reserved2[ii] = 0;\n\n\tpReq->Header.PageVersion = pCfg->cfghdr.hdr->PageVersion;\n\tpReq->Header.PageLength = pCfg->cfghdr.hdr->PageLength;\n\tpReq->Header.PageNumber = pCfg->cfghdr.hdr->PageNumber;\n\tpReq->Header.PageType = (pCfg->cfghdr.hdr->PageType & MPI_CONFIG_PAGETYPE_MASK);\n\n\tif ((pCfg->cfghdr.hdr->PageType & MPI_CONFIG_PAGETYPE_MASK) == MPI_CONFIG_PAGETYPE_EXTENDED) {\n\t\tpExtHdr = (ConfigExtendedPageHeader_t *)pCfg->cfghdr.ehdr;\n\t\tpReq->ExtPageLength = cpu_to_le16(pExtHdr->ExtPageLength);\n\t\tpReq->ExtPageType = pExtHdr->ExtPageType;\n\t\tpReq->Header.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\n\n\t\t \n\t\tpReq->Header.PageLength = 0;\n\t}\n\n\tpReq->PageAddress = cpu_to_le32(pCfg->pageAddr);\n\n\t \n\tif (pCfg->dir)\n\t\tflagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;\n\telse\n\t\tflagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;\n\n\tif ((pCfg->cfghdr.hdr->PageType & MPI_CONFIG_PAGETYPE_MASK) ==\n\t    MPI_CONFIG_PAGETYPE_EXTENDED) {\n\t\tflagsLength |= pExtHdr->ExtPageLength * 4;\n\t\tpage_type = pReq->ExtPageType;\n\t\textend_page = 1;\n\t} else {\n\t\tflagsLength |= pCfg->cfghdr.hdr->PageLength * 4;\n\t\tpage_type = pReq->Header.PageType;\n\t\textend_page = 0;\n\t}\n\n\tdcprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"Sending Config request type 0x%x, page 0x%x and action %d\\n\",\n\t    ioc->name, page_type, pReq->Header.PageNumber, pReq->Action));\n\n\tioc->add_sge((char *)&pReq->PageBufferSGE, flagsLength, pCfg->physAddr);\n\ttimeout = (pCfg->timeout < 15) ? HZ*15 : HZ*pCfg->timeout;\n\tmpt_put_msg_frame(mpt_base_index, ioc, mf);\n\ttimeleft = wait_for_completion_timeout(&ioc->mptbase_cmds.done,\n\t\ttimeout);\n\tif (!(ioc->mptbase_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tret = -ETIME;\n\t\tdfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"Failed Sending Config request type 0x%x, page 0x%x,\"\n\t\t    \" action %d, status %xh, time left %ld\\n\\n\",\n\t\t\tioc->name, page_type, pReq->Header.PageNumber,\n\t\t\tpReq->Action, ioc->mptbase_cmds.status, timeleft));\n\t\tif (ioc->mptbase_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\n\t\t\tgoto out;\n\t\tif (!timeleft) {\n\t\t\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\t\t\tif (ioc->ioc_reset_in_progress) {\n\t\t\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock,\n\t\t\t\t\tflags);\n\t\t\t\tprintk(MYIOC_s_INFO_FMT \"%s: host reset in\"\n\t\t\t\t\t\" progress mpt_config timed out.!!\\n\",\n\t\t\t\t\t__func__, ioc->name);\n\t\t\t\tmutex_unlock(&ioc->mptbase_cmds.mutex);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\t\tissue_hard_reset = 1;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (!(ioc->mptbase_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tpReply = (ConfigReply_t\t*)ioc->mptbase_cmds.reply;\n\tret = le16_to_cpu(pReply->IOCStatus) & MPI_IOCSTATUS_MASK;\n\tif (ret == MPI_IOCSTATUS_SUCCESS) {\n\t\tif (extend_page) {\n\t\t\tpCfg->cfghdr.ehdr->ExtPageLength =\n\t\t\t    le16_to_cpu(pReply->ExtPageLength);\n\t\t\tpCfg->cfghdr.ehdr->ExtPageType =\n\t\t\t    pReply->ExtPageType;\n\t\t}\n\t\tpCfg->cfghdr.hdr->PageVersion = pReply->Header.PageVersion;\n\t\tpCfg->cfghdr.hdr->PageLength = pReply->Header.PageLength;\n\t\tpCfg->cfghdr.hdr->PageNumber = pReply->Header.PageNumber;\n\t\tpCfg->cfghdr.hdr->PageType = pReply->Header.PageType;\n\n\t}\n\n\tif (retry_count)\n\t\tprintk(MYIOC_s_INFO_FMT \"Retry completed \"\n\t\t    \"ret=0x%x timeleft=%ld\\n\",\n\t\t    ioc->name, ret, timeleft);\n\n\tdcprintk(ioc, printk(KERN_DEBUG \"IOCStatus=%04xh, IOCLogInfo=%08xh\\n\",\n\t     ret, le32_to_cpu(pReply->IOCLogInfo)));\n\nout:\n\n\tCLEAR_MGMT_STATUS(ioc->mptbase_cmds.status)\n\tmutex_unlock(&ioc->mptbase_cmds.mutex);\n\tif (issue_hard_reset) {\n\t\tissue_hard_reset = 0;\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t       \"Issuing Reset from %s!!, doorbell=0x%08x\\n\",\n\t\t       ioc->name, __func__, mpt_GetIocState(ioc, 0));\n\t\tif (retry_count == 0) {\n\t\t\tif (mpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP) != 0)\n\t\t\t\tretry_count++;\n\t\t} else\n\t\t\tmpt_HardResetHandler(ioc, CAN_SLEEP);\n\n\t\tmpt_free_msg_frame(ioc, mf);\n\t\t \n\t\tif (retry_count < 2) {\n\t\t\tprintk(MYIOC_s_INFO_FMT\n\t\t\t    \"Attempting Retry Config request\"\n\t\t\t    \" type 0x%x, page 0x%x,\"\n\t\t\t    \" action %d\\n\", ioc->name, page_type,\n\t\t\t    pCfg->cfghdr.hdr->PageNumber, pCfg->action);\n\t\t\tretry_count++;\n\t\t\tgoto retry_config;\n\t\t}\n\t}\n\treturn ret;\n\n}\n\n \n \nstatic int\nmpt_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\n{\n\tswitch (reset_phase) {\n\tcase MPT_IOC_SETUP_RESET:\n\t\tioc->taskmgmt_quiesce_io = 1;\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_SETUP_RESET\\n\", ioc->name, __func__));\n\t\tbreak;\n\tcase MPT_IOC_PRE_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_PRE_RESET\\n\", ioc->name, __func__));\n\t\tbreak;\n\tcase MPT_IOC_POST_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_POST_RESET\\n\",  ioc->name, __func__));\n \n\t\tif (ioc->mptbase_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\t\tioc->mptbase_cmds.status |=\n\t\t\t    MPT_MGMT_STATUS_DID_IOCRESET;\n\t\t\tcomplete(&ioc->mptbase_cmds.done);\n\t\t}\n \n\t\tif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\t\tioc->taskmgmt_cmds.status |=\n\t\t\t\tMPT_MGMT_STATUS_DID_IOCRESET;\n\t\t\tcomplete(&ioc->taskmgmt_cmds.done);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 1;\t\t \n}\n\n\n#ifdef CONFIG_PROC_FS\t\t \n \n \n \n \nstatic int\nprocmpt_create(void)\n{\n\tmpt_proc_root_dir = proc_mkdir(MPT_PROCFS_MPTBASEDIR, NULL);\n\tif (mpt_proc_root_dir == NULL)\n\t\treturn -ENOTDIR;\n\n\tproc_create_single(\"summary\", S_IRUGO, mpt_proc_root_dir,\n\t\t\tmpt_summary_proc_show);\n\tproc_create_single(\"version\", S_IRUGO, mpt_proc_root_dir,\n\t\t\tmpt_version_proc_show);\n\treturn 0;\n}\n\n \n \nstatic void\nprocmpt_destroy(void)\n{\n\tremove_proc_entry(\"version\", mpt_proc_root_dir);\n\tremove_proc_entry(\"summary\", mpt_proc_root_dir);\n\tremove_proc_entry(MPT_PROCFS_MPTBASEDIR, NULL);\n}\n\n \n \nstatic void seq_mpt_print_ioc_summary(MPT_ADAPTER *ioc, struct seq_file *m, int showlan);\n\nstatic int mpt_summary_proc_show(struct seq_file *m, void *v)\n{\n\tMPT_ADAPTER *ioc = m->private;\n\n\tif (ioc) {\n\t\tseq_mpt_print_ioc_summary(ioc, m, 1);\n\t} else {\n\t\tlist_for_each_entry(ioc, &ioc_list, list) {\n\t\t\tseq_mpt_print_ioc_summary(ioc, m, 1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mpt_version_proc_show(struct seq_file *m, void *v)\n{\n\tu8\t cb_idx;\n\tint\t scsi, fc, sas, lan, ctl, targ;\n\tchar\t*drvname;\n\n\tseq_printf(m, \"%s-%s\\n\", \"mptlinux\", MPT_LINUX_VERSION_COMMON);\n\tseq_printf(m, \"  Fusion MPT base driver\\n\");\n\n\tscsi = fc = sas = lan = ctl = targ = 0;\n\tfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\n\t\tdrvname = NULL;\n\t\tif (MptCallbacks[cb_idx]) {\n\t\t\tswitch (MptDriverClass[cb_idx]) {\n\t\t\tcase MPTSPI_DRIVER:\n\t\t\t\tif (!scsi++) drvname = \"SPI host\";\n\t\t\t\tbreak;\n\t\t\tcase MPTFC_DRIVER:\n\t\t\t\tif (!fc++) drvname = \"FC host\";\n\t\t\t\tbreak;\n\t\t\tcase MPTSAS_DRIVER:\n\t\t\t\tif (!sas++) drvname = \"SAS host\";\n\t\t\t\tbreak;\n\t\t\tcase MPTLAN_DRIVER:\n\t\t\t\tif (!lan++) drvname = \"LAN\";\n\t\t\t\tbreak;\n\t\t\tcase MPTSTM_DRIVER:\n\t\t\t\tif (!targ++) drvname = \"SCSI target\";\n\t\t\t\tbreak;\n\t\t\tcase MPTCTL_DRIVER:\n\t\t\t\tif (!ctl++) drvname = \"ioctl\";\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (drvname)\n\t\t\t\tseq_printf(m, \"  Fusion MPT %s driver\\n\", drvname);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mpt_iocinfo_proc_show(struct seq_file *m, void *v)\n{\n\tMPT_ADAPTER\t*ioc = m->private;\n\tchar\t\t expVer[32];\n\tint\t\t sz;\n\tint\t\t p;\n\n\tmpt_get_fw_exp_ver(expVer, ioc);\n\n\tseq_printf(m, \"%s:\", ioc->name);\n\tif (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT)\n\t\tseq_printf(m, \"  (f/w download boot flag set)\");\n\n\n\n\tseq_printf(m, \"\\n  ProductID = 0x%04x (%s)\\n\",\n\t\t\tioc->facts.ProductID,\n\t\t\tioc->prod_name);\n\tseq_printf(m, \"  FWVersion = 0x%08x%s\", ioc->facts.FWVersion.Word, expVer);\n\tif (ioc->facts.FWImageSize)\n\t\tseq_printf(m, \" (fw_size=%d)\", ioc->facts.FWImageSize);\n\tseq_printf(m, \"\\n  MsgVersion = 0x%04x\\n\", ioc->facts.MsgVersion);\n\tseq_printf(m, \"  FirstWhoInit = 0x%02x\\n\", ioc->FirstWhoInit);\n\tseq_printf(m, \"  EventState = 0x%02x\\n\", ioc->facts.EventState);\n\n\tseq_printf(m, \"  CurrentHostMfaHighAddr = 0x%08x\\n\",\n\t\t\tioc->facts.CurrentHostMfaHighAddr);\n\tseq_printf(m, \"  CurrentSenseBufferHighAddr = 0x%08x\\n\",\n\t\t\tioc->facts.CurrentSenseBufferHighAddr);\n\n\tseq_printf(m, \"  MaxChainDepth = 0x%02x frames\\n\", ioc->facts.MaxChainDepth);\n\tseq_printf(m, \"  MinBlockSize = 0x%02x bytes\\n\", 4*ioc->facts.BlockSize);\n\n\tseq_printf(m, \"  RequestFrames @ 0x%p (Dma @ 0x%p)\\n\",\n\t\t\t\t\t(void *)ioc->req_frames, (void *)(ulong)ioc->req_frames_dma);\n\t \n\tsz = (ioc->req_sz * ioc->req_depth) + 128;\n\tsz = ((sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;\n\tseq_printf(m, \"    {CurReqSz=%d} x {CurReqDepth=%d} = %d bytes ^= 0x%x\\n\",\n\t\t\t\t\tioc->req_sz, ioc->req_depth, ioc->req_sz*ioc->req_depth, sz);\n\tseq_printf(m, \"    {MaxReqSz=%d}   {MaxReqDepth=%d}\\n\",\n\t\t\t\t\t4*ioc->facts.RequestFrameSize,\n\t\t\t\t\tioc->facts.GlobalCredits);\n\n\tseq_printf(m, \"  Frames   @ 0x%p (Dma @ 0x%p)\\n\",\n\t\t\t\t\t(void *)ioc->alloc, (void *)(ulong)ioc->alloc_dma);\n\tsz = (ioc->reply_sz * ioc->reply_depth) + 128;\n\tseq_printf(m, \"    {CurRepSz=%d} x {CurRepDepth=%d} = %d bytes ^= 0x%x\\n\",\n\t\t\t\t\tioc->reply_sz, ioc->reply_depth, ioc->reply_sz*ioc->reply_depth, sz);\n\tseq_printf(m, \"    {MaxRepSz=%d}   {MaxRepDepth=%d}\\n\",\n\t\t\t\t\tioc->facts.CurReplyFrameSize,\n\t\t\t\t\tioc->facts.ReplyQueueDepth);\n\n\tseq_printf(m, \"  MaxDevices = %d\\n\",\n\t\t\t(ioc->facts.MaxDevices==0) ? 255 : ioc->facts.MaxDevices);\n\tseq_printf(m, \"  MaxBuses = %d\\n\", ioc->facts.MaxBuses);\n\n\t \n\tfor (p=0; p < ioc->facts.NumberOfPorts; p++) {\n\t\tseq_printf(m, \"  PortNumber = %d (of %d)\\n\",\n\t\t\t\tp+1,\n\t\t\t\tioc->facts.NumberOfPorts);\n\t\tif (ioc->bus_type == FC) {\n\t\t\tif (ioc->pfacts[p].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) {\n\t\t\t\tu8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\n\t\t\t\tseq_printf(m, \"    LanAddr = %pMR\\n\", a);\n\t\t\t}\n\t\t\tseq_printf(m, \"    WWN = %08X%08X:%08X%08X\\n\",\n\t\t\t\t\tioc->fc_port_page0[p].WWNN.High,\n\t\t\t\t\tioc->fc_port_page0[p].WWNN.Low,\n\t\t\t\t\tioc->fc_port_page0[p].WWPN.High,\n\t\t\t\t\tioc->fc_port_page0[p].WWPN.Low);\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\t\t \n\n \nstatic void\nmpt_get_fw_exp_ver(char *buf, MPT_ADAPTER *ioc)\n{\n\tbuf[0] ='\\0';\n\tif ((ioc->facts.FWVersion.Word >> 24) == 0x0E) {\n\t\tsprintf(buf, \" (Exp %02d%02d)\",\n\t\t\t(ioc->facts.FWVersion.Word >> 16) & 0x00FF,\t \n\t\t\t(ioc->facts.FWVersion.Word >> 8) & 0x1F);\t \n\n\t\t \n\t\tif ((ioc->facts.FWVersion.Word >> 8) & 0x80)\n\t\t\tstrcat(buf, \" [MDBG]\");\n\t}\n}\n\n \n \nvoid\nmpt_print_ioc_summary(MPT_ADAPTER *ioc, char *buffer, int *size, int len, int showlan)\n{\n\tchar expVer[32];\n\tint y;\n\n\tmpt_get_fw_exp_ver(expVer, ioc);\n\n\t \n\ty = sprintf(buffer+len, \"%s: %s, %s%08xh%s, Ports=%d, MaxQ=%d\",\n\t\t\tioc->name,\n\t\t\tioc->prod_name,\n\t\t\tMPT_FW_REV_MAGIC_ID_STRING,\t \n\t\t\tioc->facts.FWVersion.Word,\n\t\t\texpVer,\n\t\t\tioc->facts.NumberOfPorts,\n\t\t\tioc->req_depth);\n\n\tif (showlan && (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN)) {\n\t\tu8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\n\t\ty += sprintf(buffer+len+y, \", LanAddr=%pMR\", a);\n\t}\n\n\ty += sprintf(buffer+len+y, \", IRQ=%d\", ioc->pci_irq);\n\n\tif (!ioc->active)\n\t\ty += sprintf(buffer+len+y, \" (disabled)\");\n\n\ty += sprintf(buffer+len+y, \"\\n\");\n\n\t*size = y;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void seq_mpt_print_ioc_summary(MPT_ADAPTER *ioc, struct seq_file *m, int showlan)\n{\n\tchar expVer[32];\n\n\tmpt_get_fw_exp_ver(expVer, ioc);\n\n\t \n\tseq_printf(m, \"%s: %s, %s%08xh%s, Ports=%d, MaxQ=%d\",\n\t\t\tioc->name,\n\t\t\tioc->prod_name,\n\t\t\tMPT_FW_REV_MAGIC_ID_STRING,\t \n\t\t\tioc->facts.FWVersion.Word,\n\t\t\texpVer,\n\t\t\tioc->facts.NumberOfPorts,\n\t\t\tioc->req_depth);\n\n\tif (showlan && (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN)) {\n\t\tu8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\n\t\tseq_printf(m, \", LanAddr=%pMR\", a);\n\t}\n\n\tseq_printf(m, \", IRQ=%d\", ioc->pci_irq);\n\n\tif (!ioc->active)\n\t\tseq_printf(m, \" (disabled)\");\n\n\tseq_putc(m, '\\n');\n}\n#endif\n\n \nint\nmpt_set_taskmgmt_in_progress_flag(MPT_ADAPTER *ioc)\n{\n\tunsigned long\t flags;\n\tint\t\t retval;\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress || ioc->taskmgmt_in_progress ||\n\t    (ioc->alt_ioc && ioc->alt_ioc->taskmgmt_in_progress)) {\n\t\tretval = -1;\n\t\tgoto out;\n\t}\n\tretval = 0;\n\tioc->taskmgmt_in_progress = 1;\n\tioc->taskmgmt_quiesce_io = 1;\n\tif (ioc->alt_ioc) {\n\t\tioc->alt_ioc->taskmgmt_in_progress = 1;\n\t\tioc->alt_ioc->taskmgmt_quiesce_io = 1;\n\t}\n out:\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\treturn retval;\n}\nEXPORT_SYMBOL(mpt_set_taskmgmt_in_progress_flag);\n\n \nvoid\nmpt_clear_taskmgmt_in_progress_flag(MPT_ADAPTER *ioc)\n{\n\tunsigned long\t flags;\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tioc->taskmgmt_in_progress = 0;\n\tioc->taskmgmt_quiesce_io = 0;\n\tif (ioc->alt_ioc) {\n\t\tioc->alt_ioc->taskmgmt_in_progress = 0;\n\t\tioc->alt_ioc->taskmgmt_quiesce_io = 0;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n}\nEXPORT_SYMBOL(mpt_clear_taskmgmt_in_progress_flag);\n\n\n \nvoid __noreturn\nmpt_halt_firmware(MPT_ADAPTER *ioc)\n{\n\tu32\t ioc_raw_state;\n\n\tioc_raw_state = mpt_GetIocState(ioc, 0);\n\n\tif ((ioc_raw_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_FAULT) {\n\t\tprintk(MYIOC_s_ERR_FMT \"IOC is in FAULT state (%04xh)!!!\\n\",\n\t\t\tioc->name, ioc_raw_state & MPI_DOORBELL_DATA_MASK);\n\t\tpanic(\"%s: IOC Fault (%04xh)!!!\\n\", ioc->name,\n\t\t\tioc_raw_state & MPI_DOORBELL_DATA_MASK);\n\t} else {\n\t\tCHIPREG_WRITE32(&ioc->chip->Doorbell, 0xC0FFEE00);\n\t\tpanic(\"%s: Firmware is halted due to command timeout\\n\",\n\t\t\tioc->name);\n\t}\n}\nEXPORT_SYMBOL(mpt_halt_firmware);\n\n \nstatic int\nmpt_SoftResetHandler(MPT_ADAPTER *ioc, int sleepFlag)\n{\n\tint\t\t rc;\n\tint\t\t ii;\n\tu8\t\t cb_idx;\n\tunsigned long\t flags;\n\tu32\t\t ioc_state;\n\tunsigned long\t time_count;\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"SoftResetHandler Entered!\\n\",\n\t\tioc->name));\n\n\tioc_state = mpt_GetIocState(ioc, 0) & MPI_IOC_STATE_MASK;\n\n\tif (mpt_fwfault_debug)\n\t\tmpt_halt_firmware(ioc);\n\n\tif (ioc_state == MPI_IOC_STATE_FAULT ||\n\t    ioc_state == MPI_IOC_STATE_RESET) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"skipping, either in FAULT or RESET state!\\n\", ioc->name));\n\t\treturn -1;\n\t}\n\n\tif (ioc->bus_type == FC) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"skipping, because the bus type is FC!\\n\", ioc->name));\n\t\treturn -1;\n\t}\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress) {\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\treturn -1;\n\t}\n\tioc->ioc_reset_in_progress = 1;\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\tfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\n\t\tif (MptResetHandlers[cb_idx])\n\t\t\tmpt_signal_reset(cb_idx, ioc, MPT_IOC_SETUP_RESET);\n\t}\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->taskmgmt_in_progress) {\n\t\tioc->ioc_reset_in_progress = 0;\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\treturn -1;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t \n\tCHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);\n\tioc->active = 0;\n\ttime_count = jiffies;\n\n\trc = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag);\n\n\tfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\n\t\tif (MptResetHandlers[cb_idx])\n\t\t\tmpt_signal_reset(cb_idx, ioc, MPT_IOC_PRE_RESET);\n\t}\n\n\tif (rc)\n\t\tgoto out;\n\n\tioc_state = mpt_GetIocState(ioc, 0) & MPI_IOC_STATE_MASK;\n\tif (ioc_state != MPI_IOC_STATE_READY)\n\t\tgoto out;\n\n\tfor (ii = 0; ii < 5; ii++) {\n\t\t \n\t\trc = GetIocFacts(ioc, sleepFlag,\n\t\t\tMPT_HOSTEVENT_IOC_RECOVER);\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t\tif (sleepFlag == CAN_SLEEP)\n\t\t\tmsleep(100);\n\t\telse\n\t\t\tmdelay(100);\n\t}\n\tif (ii == 5)\n\t\tgoto out;\n\n\trc = PrimeIocFifos(ioc);\n\tif (rc != 0)\n\t\tgoto out;\n\n\trc = SendIocInit(ioc, sleepFlag);\n\tif (rc != 0)\n\t\tgoto out;\n\n\trc = SendEventNotification(ioc, 1, sleepFlag);\n\tif (rc != 0)\n\t\tgoto out;\n\n\tif (ioc->hard_resets < -1)\n\t\tioc->hard_resets++;\n\n\t \n\n\tioc->active = 1;\n\tCHIPREG_WRITE32(&ioc->chip->IntMask, MPI_HIM_DIM);\n\n out:\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tioc->ioc_reset_in_progress = 0;\n\tioc->taskmgmt_quiesce_io = 0;\n\tioc->taskmgmt_in_progress = 0;\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\tif (ioc->active) {\t \n\t\tfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\n\t\t\tif (MptResetHandlers[cb_idx])\n\t\t\t\tmpt_signal_reset(cb_idx, ioc,\n\t\t\t\t\tMPT_IOC_POST_RESET);\n\t\t}\n\t}\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"SoftResetHandler: completed (%d seconds): %s\\n\",\n\t\tioc->name, jiffies_to_msecs(jiffies - time_count)/1000,\n\t\t((rc == 0) ? \"SUCCESS\" : \"FAILED\")));\n\n\treturn rc;\n}\n\n \nint\nmpt_Soft_Hard_ResetHandler(MPT_ADAPTER *ioc, int sleepFlag) {\n\tint ret = -1;\n\n\tret = mpt_SoftResetHandler(ioc, sleepFlag);\n\tif (ret == 0)\n\t\treturn ret;\n\tret = mpt_HardResetHandler(ioc, sleepFlag);\n\treturn ret;\n}\nEXPORT_SYMBOL(mpt_Soft_Hard_ResetHandler);\n\n \n \n \n \nint\nmpt_HardResetHandler(MPT_ADAPTER *ioc, int sleepFlag)\n{\n\tint\t rc;\n\tu8\t cb_idx;\n\tunsigned long\t flags;\n\tunsigned long\t time_count;\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"HardResetHandler Entered!\\n\", ioc->name));\n#ifdef MFCNT\n\tprintk(MYIOC_s_INFO_FMT \"HardResetHandler Entered!\\n\", ioc->name);\n\tprintk(\"MF count 0x%x !\\n\", ioc->mfcnt);\n#endif\n\tif (mpt_fwfault_debug)\n\t\tmpt_halt_firmware(ioc);\n\n\t \n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress) {\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\tioc->wait_on_reset_completion = 1;\n\t\tdo {\n\t\t\tssleep(1);\n\t\t} while (ioc->ioc_reset_in_progress == 1);\n\t\tioc->wait_on_reset_completion = 0;\n\t\treturn ioc->reset_status;\n\t}\n\tif (ioc->wait_on_reset_completion) {\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\trc = 0;\n\t\ttime_count = jiffies;\n\t\tgoto exit;\n\t}\n\tioc->ioc_reset_in_progress = 1;\n\tif (ioc->alt_ioc)\n\t\tioc->alt_ioc->ioc_reset_in_progress = 1;\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\n\t \n\tfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\n\t\tif (MptResetHandlers[cb_idx]) {\n\t\t\tmpt_signal_reset(cb_idx, ioc, MPT_IOC_SETUP_RESET);\n\t\t\tif (ioc->alt_ioc)\n\t\t\t\tmpt_signal_reset(cb_idx, ioc->alt_ioc,\n\t\t\t\t\tMPT_IOC_SETUP_RESET);\n\t\t}\n\t}\n\n\ttime_count = jiffies;\n\trc = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_RECOVER, sleepFlag);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING MYNAM\n\t\t       \": WARNING - (%d) Cannot recover %s, doorbell=0x%08x\\n\",\n\t\t       rc, ioc->name, mpt_GetIocState(ioc, 0));\n\t} else {\n\t\tif (ioc->hard_resets < -1)\n\t\t\tioc->hard_resets++;\n\t}\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tioc->ioc_reset_in_progress = 0;\n\tioc->taskmgmt_quiesce_io = 0;\n\tioc->taskmgmt_in_progress = 0;\n\tioc->reset_status = rc;\n\tif (ioc->alt_ioc) {\n\t\tioc->alt_ioc->ioc_reset_in_progress = 0;\n\t\tioc->alt_ioc->taskmgmt_quiesce_io = 0;\n\t\tioc->alt_ioc->taskmgmt_in_progress = 0;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\tfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\n\t\tif (MptResetHandlers[cb_idx]) {\n\t\t\tmpt_signal_reset(cb_idx, ioc, MPT_IOC_POST_RESET);\n\t\t\tif (ioc->alt_ioc)\n\t\t\t\tmpt_signal_reset(cb_idx,\n\t\t\t\t\tioc->alt_ioc, MPT_IOC_POST_RESET);\n\t\t}\n\t}\nexit:\n\tdtmprintk(ioc,\n\t    printk(MYIOC_s_DEBUG_FMT\n\t\t\"HardResetHandler: completed (%d seconds): %s\\n\", ioc->name,\n\t\tjiffies_to_msecs(jiffies - time_count)/1000, ((rc == 0) ?\n\t\t\"SUCCESS\" : \"FAILED\")));\n\n\treturn rc;\n}\n\n#ifdef CONFIG_FUSION_LOGGING\nstatic void\nmpt_display_event_info(MPT_ADAPTER *ioc, EventNotificationReply_t *pEventReply)\n{\n\tchar *ds = NULL;\n\tu32 evData0;\n\tint ii;\n\tu8 event;\n\tchar *evStr = ioc->evStr;\n\n\tevent = le32_to_cpu(pEventReply->Event) & 0xFF;\n\tevData0 = le32_to_cpu(pEventReply->Data[0]);\n\n\tswitch(event) {\n\tcase MPI_EVENT_NONE:\n\t\tds = \"None\";\n\t\tbreak;\n\tcase MPI_EVENT_LOG_DATA:\n\t\tds = \"Log Data\";\n\t\tbreak;\n\tcase MPI_EVENT_STATE_CHANGE:\n\t\tds = \"State Change\";\n\t\tbreak;\n\tcase MPI_EVENT_UNIT_ATTENTION:\n\t\tds = \"Unit Attention\";\n\t\tbreak;\n\tcase MPI_EVENT_IOC_BUS_RESET:\n\t\tds = \"IOC Bus Reset\";\n\t\tbreak;\n\tcase MPI_EVENT_EXT_BUS_RESET:\n\t\tds = \"External Bus Reset\";\n\t\tbreak;\n\tcase MPI_EVENT_RESCAN:\n\t\tds = \"Bus Rescan Event\";\n\t\tbreak;\n\tcase MPI_EVENT_LINK_STATUS_CHANGE:\n\t\tif (evData0 == MPI_EVENT_LINK_STATUS_FAILURE)\n\t\t\tds = \"Link Status(FAILURE) Change\";\n\t\telse\n\t\t\tds = \"Link Status(ACTIVE) Change\";\n\t\tbreak;\n\tcase MPI_EVENT_LOOP_STATE_CHANGE:\n\t\tif (evData0 == MPI_EVENT_LOOP_STATE_CHANGE_LIP)\n\t\t\tds = \"Loop State(LIP) Change\";\n\t\telse if (evData0 == MPI_EVENT_LOOP_STATE_CHANGE_LPE)\n\t\t\tds = \"Loop State(LPE) Change\";\n\t\telse\n\t\t\tds = \"Loop State(LPB) Change\";\n\t\tbreak;\n\tcase MPI_EVENT_LOGOUT:\n\t\tds = \"Logout\";\n\t\tbreak;\n\tcase MPI_EVENT_EVENT_CHANGE:\n\t\tif (evData0)\n\t\t\tds = \"Events ON\";\n\t\telse\n\t\t\tds = \"Events OFF\";\n\t\tbreak;\n\tcase MPI_EVENT_INTEGRATED_RAID:\n\t{\n\t\tu8 ReasonCode = (u8)(evData0 >> 16);\n\t\tswitch (ReasonCode) {\n\t\tcase MPI_EVENT_RAID_RC_VOLUME_CREATED :\n\t\t\tds = \"Integrated Raid: Volume Created\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_RAID_RC_VOLUME_DELETED :\n\t\t\tds = \"Integrated Raid: Volume Deleted\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_RAID_RC_VOLUME_SETTINGS_CHANGED :\n\t\t\tds = \"Integrated Raid: Volume Settings Changed\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_RAID_RC_VOLUME_STATUS_CHANGED :\n\t\t\tds = \"Integrated Raid: Volume Status Changed\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_RAID_RC_VOLUME_PHYSDISK_CHANGED :\n\t\t\tds = \"Integrated Raid: Volume Physdisk Changed\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_RAID_RC_PHYSDISK_CREATED :\n\t\t\tds = \"Integrated Raid: Physdisk Created\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_RAID_RC_PHYSDISK_DELETED :\n\t\t\tds = \"Integrated Raid: Physdisk Deleted\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_RAID_RC_PHYSDISK_SETTINGS_CHANGED :\n\t\t\tds = \"Integrated Raid: Physdisk Settings Changed\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_RAID_RC_PHYSDISK_STATUS_CHANGED :\n\t\t\tds = \"Integrated Raid: Physdisk Status Changed\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED :\n\t\t\tds = \"Integrated Raid: Domain Validation Needed\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_RAID_RC_SMART_DATA :\n\t\t\tds = \"Integrated Raid; Smart Data\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_RAID_RC_REPLACE_ACTION_STARTED :\n\t\t\tds = \"Integrated Raid: Replace Action Started\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tds = \"Integrated Raid\";\n\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE:\n\t\tds = \"SCSI Device Status Change\";\n\t\tbreak;\n\tcase MPI_EVENT_SAS_DEVICE_STATUS_CHANGE:\n\t{\n\t\tu8 id = (u8)(evData0);\n\t\tu8 channel = (u8)(evData0 >> 8);\n\t\tu8 ReasonCode = (u8)(evData0 >> 16);\n\t\tswitch (ReasonCode) {\n\t\tcase MPI_EVENT_SAS_DEV_STAT_RC_ADDED:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS Device Status Change: Added: \"\n\t\t\t    \"id=%d channel=%d\", id, channel);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS Device Status Change: Deleted: \"\n\t\t\t    \"id=%d channel=%d\", id, channel);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_DEV_STAT_RC_SMART_DATA:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS Device Status Change: SMART Data: \"\n\t\t\t    \"id=%d channel=%d\", id, channel);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_DEV_STAT_RC_NO_PERSIST_ADDED:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS Device Status Change: No Persistency: \"\n\t\t\t    \"id=%d channel=%d\", id, channel);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_DEV_STAT_RC_UNSUPPORTED:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS Device Status Change: Unsupported Device \"\n\t\t\t    \"Discovered : id=%d channel=%d\", id, channel);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS Device Status Change: Internal Device \"\n\t\t\t    \"Reset : id=%d channel=%d\", id, channel);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_DEV_STAT_RC_TASK_ABORT_INTERNAL:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS Device Status Change: Internal Task \"\n\t\t\t    \"Abort : id=%d channel=%d\", id, channel);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_DEV_STAT_RC_ABORT_TASK_SET_INTERNAL:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS Device Status Change: Internal Abort \"\n\t\t\t    \"Task Set : id=%d channel=%d\", id, channel);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_DEV_STAT_RC_CLEAR_TASK_SET_INTERNAL:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS Device Status Change: Internal Clear \"\n\t\t\t    \"Task Set : id=%d channel=%d\", id, channel);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_DEV_STAT_RC_QUERY_TASK_INTERNAL:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS Device Status Change: Internal Query \"\n\t\t\t    \"Task : id=%d channel=%d\", id, channel);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS Device Status Change: Unknown: \"\n\t\t\t    \"id=%d channel=%d\", id, channel);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MPI_EVENT_ON_BUS_TIMER_EXPIRED:\n\t\tds = \"Bus Timer Expired\";\n\t\tbreak;\n\tcase MPI_EVENT_QUEUE_FULL:\n\t{\n\t\tu16 curr_depth = (u16)(evData0 >> 16);\n\t\tu8 channel = (u8)(evData0 >> 8);\n\t\tu8 id = (u8)(evData0);\n\n\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t   \"Queue Full: channel=%d id=%d depth=%d\",\n\t\t   channel, id, curr_depth);\n\t\tbreak;\n\t}\n\tcase MPI_EVENT_SAS_SES:\n\t\tds = \"SAS SES Event\";\n\t\tbreak;\n\tcase MPI_EVENT_PERSISTENT_TABLE_FULL:\n\t\tds = \"Persistent Table Full\";\n\t\tbreak;\n\tcase MPI_EVENT_SAS_PHY_LINK_STATUS:\n\t{\n\t\tu8 LinkRates = (u8)(evData0 >> 8);\n\t\tu8 PhyNumber = (u8)(evData0);\n\t\tLinkRates = (LinkRates & MPI_EVENT_SAS_PLS_LR_CURRENT_MASK) >>\n\t\t\tMPI_EVENT_SAS_PLS_LR_CURRENT_SHIFT;\n\t\tswitch (LinkRates) {\n\t\tcase MPI_EVENT_SAS_PLS_LR_RATE_UNKNOWN:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t   \"SAS PHY Link Status: Phy=%d:\"\n\t\t\t   \" Rate Unknown\",PhyNumber);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_PLS_LR_RATE_PHY_DISABLED:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t   \"SAS PHY Link Status: Phy=%d:\"\n\t\t\t   \" Phy Disabled\",PhyNumber);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_PLS_LR_RATE_FAILED_SPEED_NEGOTIATION:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t   \"SAS PHY Link Status: Phy=%d:\"\n\t\t\t   \" Failed Speed Nego\",PhyNumber);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_PLS_LR_RATE_SATA_OOB_COMPLETE:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t   \"SAS PHY Link Status: Phy=%d:\"\n\t\t\t   \" Sata OOB Completed\",PhyNumber);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_PLS_LR_RATE_1_5:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t   \"SAS PHY Link Status: Phy=%d:\"\n\t\t\t   \" Rate 1.5 Gbps\",PhyNumber);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_PLS_LR_RATE_3_0:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t   \"SAS PHY Link Status: Phy=%d:\"\n\t\t\t   \" Rate 3.0 Gbps\", PhyNumber);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_PLS_LR_RATE_6_0:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t   \"SAS PHY Link Status: Phy=%d:\"\n\t\t\t   \" Rate 6.0 Gbps\", PhyNumber);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t   \"SAS PHY Link Status: Phy=%d\", PhyNumber);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MPI_EVENT_SAS_DISCOVERY_ERROR:\n\t\tds = \"SAS Discovery Error\";\n\t\tbreak;\n\tcase MPI_EVENT_IR_RESYNC_UPDATE:\n\t{\n\t\tu8 resync_complete = (u8)(evData0 >> 16);\n\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t    \"IR Resync Update: Complete = %d:\",resync_complete);\n\t\tbreak;\n\t}\n\tcase MPI_EVENT_IR2:\n\t{\n\t\tu8 id = (u8)(evData0);\n\t\tu8 channel = (u8)(evData0 >> 8);\n\t\tu8 phys_num = (u8)(evData0 >> 24);\n\t\tu8 ReasonCode = (u8)(evData0 >> 16);\n\n\t\tswitch (ReasonCode) {\n\t\tcase MPI_EVENT_IR2_RC_LD_STATE_CHANGED:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"IR2: LD State Changed: \"\n\t\t\t    \"id=%d channel=%d phys_num=%d\",\n\t\t\t    id, channel, phys_num);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_IR2_RC_PD_STATE_CHANGED:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"IR2: PD State Changed \"\n\t\t\t    \"id=%d channel=%d phys_num=%d\",\n\t\t\t    id, channel, phys_num);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_IR2_RC_BAD_BLOCK_TABLE_FULL:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"IR2: Bad Block Table Full: \"\n\t\t\t    \"id=%d channel=%d phys_num=%d\",\n\t\t\t    id, channel, phys_num);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_IR2_RC_PD_INSERTED:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"IR2: PD Inserted: \"\n\t\t\t    \"id=%d channel=%d phys_num=%d\",\n\t\t\t    id, channel, phys_num);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_IR2_RC_PD_REMOVED:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"IR2: PD Removed: \"\n\t\t\t    \"id=%d channel=%d phys_num=%d\",\n\t\t\t    id, channel, phys_num);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_IR2_RC_FOREIGN_CFG_DETECTED:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"IR2: Foreign CFG Detected: \"\n\t\t\t    \"id=%d channel=%d phys_num=%d\",\n\t\t\t    id, channel, phys_num);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_IR2_RC_REBUILD_MEDIUM_ERROR:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"IR2: Rebuild Medium Error: \"\n\t\t\t    \"id=%d channel=%d phys_num=%d\",\n\t\t\t    id, channel, phys_num);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_IR2_RC_DUAL_PORT_ADDED:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"IR2: Dual Port Added: \"\n\t\t\t    \"id=%d channel=%d phys_num=%d\",\n\t\t\t    id, channel, phys_num);\n\t\t\tbreak;\n\t\tcase MPI_EVENT_IR2_RC_DUAL_PORT_REMOVED:\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"IR2: Dual Port Removed: \"\n\t\t\t    \"id=%d channel=%d phys_num=%d\",\n\t\t\t    id, channel, phys_num);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tds = \"IR2\";\n\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MPI_EVENT_SAS_DISCOVERY:\n\t{\n\t\tif (evData0)\n\t\t\tds = \"SAS Discovery: Start\";\n\t\telse\n\t\t\tds = \"SAS Discovery: Stop\";\n\t\tbreak;\n\t}\n\tcase MPI_EVENT_LOG_ENTRY_ADDED:\n\t\tds = \"SAS Log Entry Added\";\n\t\tbreak;\n\n\tcase MPI_EVENT_SAS_BROADCAST_PRIMITIVE:\n\t{\n\t\tu8 phy_num = (u8)(evData0);\n\t\tu8 port_num = (u8)(evData0 >> 8);\n\t\tu8 port_width = (u8)(evData0 >> 16);\n\t\tu8 primitive = (u8)(evData0 >> 24);\n\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t    \"SAS Broadcast Primitive: phy=%d port=%d \"\n\t\t    \"width=%d primitive=0x%02x\",\n\t\t    phy_num, port_num, port_width, primitive);\n\t\tbreak;\n\t}\n\n\tcase MPI_EVENT_SAS_INIT_DEVICE_STATUS_CHANGE:\n\t{\n\t\tu8 reason = (u8)(evData0);\n\n\t\tswitch (reason) {\n\t\tcase MPI_EVENT_SAS_INIT_RC_ADDED:\n\t\t\tds = \"SAS Initiator Status Change: Added\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_INIT_RC_REMOVED:\n\t\t\tds = \"SAS Initiator Status Change: Deleted\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tds = \"SAS Initiator Status Change\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase MPI_EVENT_SAS_INIT_TABLE_OVERFLOW:\n\t{\n\t\tu8 max_init = (u8)(evData0);\n\t\tu8 current_init = (u8)(evData0 >> 8);\n\n\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t    \"SAS Initiator Device Table Overflow: max initiators=%02d \"\n\t\t    \"current initiators=%02d\",\n\t\t    max_init, current_init);\n\t\tbreak;\n\t}\n\tcase MPI_EVENT_SAS_SMP_ERROR:\n\t{\n\t\tu8 status = (u8)(evData0);\n\t\tu8 port_num = (u8)(evData0 >> 8);\n\t\tu8 result = (u8)(evData0 >> 16);\n\n\t\tif (status == MPI_EVENT_SAS_SMP_FUNCTION_RESULT_VALID)\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS SMP Error: port=%d result=0x%02x\",\n\t\t\t    port_num, result);\n\t\telse if (status == MPI_EVENT_SAS_SMP_CRC_ERROR)\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS SMP Error: port=%d : CRC Error\",\n\t\t\t    port_num);\n\t\telse if (status == MPI_EVENT_SAS_SMP_TIMEOUT)\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS SMP Error: port=%d : Timeout\",\n\t\t\t    port_num);\n\t\telse if (status == MPI_EVENT_SAS_SMP_NO_DESTINATION)\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS SMP Error: port=%d : No Destination\",\n\t\t\t    port_num);\n\t\telse if (status == MPI_EVENT_SAS_SMP_BAD_DESTINATION)\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS SMP Error: port=%d : Bad Destination\",\n\t\t\t    port_num);\n\t\telse\n\t\t\tsnprintf(evStr, EVENT_DESCR_STR_SZ,\n\t\t\t    \"SAS SMP Error: port=%d : status=0x%02x\",\n\t\t\t    port_num, status);\n\t\tbreak;\n\t}\n\n\tcase MPI_EVENT_SAS_EXPANDER_STATUS_CHANGE:\n\t{\n\t\tu8 reason = (u8)(evData0);\n\n\t\tswitch (reason) {\n\t\tcase MPI_EVENT_SAS_EXP_RC_ADDED:\n\t\t\tds = \"Expander Status Change: Added\";\n\t\t\tbreak;\n\t\tcase MPI_EVENT_SAS_EXP_RC_NOT_RESPONDING:\n\t\t\tds = \"Expander Status Change: Deleted\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tds = \"Expander Status Change\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tdefault:\n\t\tds = \"Unknown\";\n\t\tbreak;\n\t}\n\tif (ds)\n\t\tstrscpy(evStr, ds, EVENT_DESCR_STR_SZ);\n\n\n\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"MPT event:(%02Xh) : %s\\n\",\n\t    ioc->name, event, evStr));\n\n\tdevtverboseprintk(ioc, printk(KERN_DEBUG MYNAM\n\t    \": Event data:\\n\"));\n\tfor (ii = 0; ii < le16_to_cpu(pEventReply->EventDataLength); ii++)\n\t\tdevtverboseprintk(ioc, printk(\" %08x\",\n\t\t    le32_to_cpu(pEventReply->Data[ii])));\n\tdevtverboseprintk(ioc, printk(KERN_DEBUG \"\\n\"));\n}\n#endif\n \n \nstatic int\nProcessEventNotification(MPT_ADAPTER *ioc, EventNotificationReply_t *pEventReply, int *evHandlers)\n{\n\tu16 evDataLen;\n\tu32 evData0 = 0;\n\tint ii;\n\tu8 cb_idx;\n\tint r = 0;\n\tint handlers = 0;\n\tu8 event;\n\n\t \n\tevent = le32_to_cpu(pEventReply->Event) & 0xFF;\n\tevDataLen = le16_to_cpu(pEventReply->EventDataLength);\n\tif (evDataLen) {\n\t\tevData0 = le32_to_cpu(pEventReply->Data[0]);\n\t}\n\n#ifdef CONFIG_FUSION_LOGGING\n\tif (evDataLen)\n\t\tmpt_display_event_info(ioc, pEventReply);\n#endif\n\n\t \n\tswitch(event) {\n\tcase MPI_EVENT_EVENT_CHANGE:\t\t \n\t\tif (evDataLen) {\n\t\t\tu8 evState = evData0 & 0xFF;\n\n\t\t\t \n\n\t\t\t \n\t\t\tif (ioc->facts.Function) {\n\t\t\t\tioc->facts.EventState = evState;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MPI_EVENT_INTEGRATED_RAID:\n\t\tmptbase_raid_process_event_data(ioc,\n\t\t    (MpiEventDataRaid_t *)pEventReply->Data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (ioc->events && (ioc->eventTypes & ( 1 << event))) {\n\t\tint idx;\n\n\t\tidx = ioc->eventContext % MPTCTL_EVENT_LOG_SIZE;\n\n\t\tioc->events[idx].event = event;\n\t\tioc->events[idx].eventContext = ioc->eventContext;\n\n\t\tfor (ii = 0; ii < 2; ii++) {\n\t\t\tif (ii < evDataLen)\n\t\t\t\tioc->events[idx].data[ii] = le32_to_cpu(pEventReply->Data[ii]);\n\t\t\telse\n\t\t\t\tioc->events[idx].data[ii] =  0;\n\t\t}\n\n\t\tioc->eventContext++;\n\t}\n\n\n\t \n\tfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\n\t\tif (MptEvHandlers[cb_idx]) {\n\t\t\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t    \"Routing Event to event handler #%d\\n\",\n\t\t\t    ioc->name, cb_idx));\n\t\t\tr += (*(MptEvHandlers[cb_idx]))(ioc, pEventReply);\n\t\t\thandlers++;\n\t\t}\n\t}\n\t \n\n\t \n\tif (pEventReply->AckRequired == MPI_EVENT_NOTIFICATION_ACK_REQUIRED) {\n\t\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"EventAck required\\n\",ioc->name));\n\t\tif ((ii = SendEventAck(ioc, pEventReply)) != 0) {\n\t\t\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"SendEventAck returned %d\\n\",\n\t\t\t\t\tioc->name, ii));\n\t\t}\n\t}\n\n\t*evHandlers = handlers;\n\treturn r;\n}\n\n \n \nstatic void\nmpt_fc_log_info(MPT_ADAPTER *ioc, u32 log_info)\n{\n\tchar *desc = \"unknown\";\n\n\tswitch (log_info & 0xFF000000) {\n\tcase MPI_IOCLOGINFO_FC_INIT_BASE:\n\t\tdesc = \"FCP Initiator\";\n\t\tbreak;\n\tcase MPI_IOCLOGINFO_FC_TARGET_BASE:\n\t\tdesc = \"FCP Target\";\n\t\tbreak;\n\tcase MPI_IOCLOGINFO_FC_LAN_BASE:\n\t\tdesc = \"LAN\";\n\t\tbreak;\n\tcase MPI_IOCLOGINFO_FC_MSG_BASE:\n\t\tdesc = \"MPI Message Layer\";\n\t\tbreak;\n\tcase MPI_IOCLOGINFO_FC_LINK_BASE:\n\t\tdesc = \"FC Link\";\n\t\tbreak;\n\tcase MPI_IOCLOGINFO_FC_CTX_BASE:\n\t\tdesc = \"Context Manager\";\n\t\tbreak;\n\tcase MPI_IOCLOGINFO_FC_INVALID_FIELD_BYTE_OFFSET:\n\t\tdesc = \"Invalid Field Offset\";\n\t\tbreak;\n\tcase MPI_IOCLOGINFO_FC_STATE_CHANGE:\n\t\tdesc = \"State Change Info\";\n\t\tbreak;\n\t}\n\n\tprintk(MYIOC_s_INFO_FMT \"LogInfo(0x%08x): SubClass={%s}, Value=(0x%06x)\\n\",\n\t\t\tioc->name, log_info, desc, (log_info & 0xFFFFFF));\n}\n\n \n \nstatic void\nmpt_spi_log_info(MPT_ADAPTER *ioc, u32 log_info)\n{\n\tu32 info = log_info & 0x00FF0000;\n\tchar *desc = \"unknown\";\n\n\tswitch (info) {\n\tcase 0x00010000:\n\t\tdesc = \"bug! MID not found\";\n\t\tbreak;\n\n\tcase 0x00020000:\n\t\tdesc = \"Parity Error\";\n\t\tbreak;\n\n\tcase 0x00030000:\n\t\tdesc = \"ASYNC Outbound Overrun\";\n\t\tbreak;\n\n\tcase 0x00040000:\n\t\tdesc = \"SYNC Offset Error\";\n\t\tbreak;\n\n\tcase 0x00050000:\n\t\tdesc = \"BM Change\";\n\t\tbreak;\n\n\tcase 0x00060000:\n\t\tdesc = \"Msg In Overflow\";\n\t\tbreak;\n\n\tcase 0x00070000:\n\t\tdesc = \"DMA Error\";\n\t\tbreak;\n\n\tcase 0x00080000:\n\t\tdesc = \"Outbound DMA Overrun\";\n\t\tbreak;\n\n\tcase 0x00090000:\n\t\tdesc = \"Task Management\";\n\t\tbreak;\n\n\tcase 0x000A0000:\n\t\tdesc = \"Device Problem\";\n\t\tbreak;\n\n\tcase 0x000B0000:\n\t\tdesc = \"Invalid Phase Change\";\n\t\tbreak;\n\n\tcase 0x000C0000:\n\t\tdesc = \"Untagged Table Size\";\n\t\tbreak;\n\n\t}\n\n\tprintk(MYIOC_s_INFO_FMT \"LogInfo(0x%08x): F/W: %s\\n\", ioc->name, log_info, desc);\n}\n\n \n\tstatic char *originator_str[] = {\n\t\t\"IOP\",\t\t\t\t\t\t \n\t\t\"PL\",\t\t\t\t\t\t \n\t\t\"IR\"\t\t\t\t\t\t \n\t};\n\tstatic char *iop_code_str[] = {\n\t\tNULL,\t\t\t\t\t\t \n\t\t\"Invalid SAS Address\",\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\t\"Invalid Page\",\t\t\t\t\t \n\t\t\"Diag Message Error\",\t\t\t\t \n\t\t\"Task Terminated\",\t\t\t\t \n\t\t\"Enclosure Management\",\t\t\t\t \n\t\t\"Target Mode\"\t\t\t\t\t \n\t};\n\tstatic char *pl_code_str[] = {\n\t\tNULL,\t\t\t\t\t\t \n\t\t\"Open Failure\",\t\t\t\t\t \n\t\t\"Invalid Scatter Gather List\",\t\t\t \n\t\t\"Wrong Relative Offset or Frame Length\",\t \n\t\t\"Frame Transfer Error\",\t\t\t\t \n\t\t\"Transmit Frame Connected Low\",\t\t\t \n\t\t\"SATA Non-NCQ RW Error Bit Set\",\t\t \n\t\t\"SATA Read Log Receive Data Error\",\t\t \n\t\t\"SATA NCQ Fail All Commands After Error\",\t \n\t\t\"SATA Error in Receive Set Device Bit FIS\",\t \n\t\t\"Receive Frame Invalid Message\",\t\t \n\t\t\"Receive Context Message Valid Error\",\t\t \n\t\t\"Receive Frame Current Frame Error\",\t\t \n\t\t\"SATA Link Down\",\t\t\t\t \n\t\t\"Discovery SATA Init W IOS\",\t\t\t \n\t\t\"Config Invalid Page\",\t\t\t\t \n\t\t\"Discovery SATA Init Timeout\",\t\t\t \n\t\t\"Reset\",\t\t\t\t\t \n\t\t\"Abort\",\t\t\t\t\t \n\t\t\"IO Not Yet Executed\",\t\t\t\t \n\t\t\"IO Executed\",\t\t\t\t\t \n\t\t\"Persistent Reservation Out Not Affiliation \"\n\t\t    \"Owner\", \t\t\t\t\t \n\t\t\"Open Transmit DMA Abort\",\t\t\t \n\t\t\"IO Device Missing Delay Retry\",\t\t \n\t\t\"IO Cancelled Due to Receive Error\",\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\t\"Enclosure Management\"\t\t\t\t \n\t};\n\tstatic char *ir_code_str[] = {\n\t\t\"Raid Action Error\",\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL\t\t\t\t\t\t \n\t};\n\tstatic char *raid_sub_code_str[] = {\n\t\tNULL, \t\t\t\t\t\t \n\t\t\"Volume Creation Failed: Data Passed too \"\n\t\t    \"Large\", \t\t\t\t\t \n\t\t\"Volume Creation Failed: Duplicate Volumes \"\n\t\t    \"Attempted\", \t\t\t\t \n\t\t\"Volume Creation Failed: Max Number \"\n\t\t    \"Supported Volumes Exceeded\",\t\t \n\t\t\"Volume Creation Failed: DMA Error\",\t\t \n\t\t\"Volume Creation Failed: Invalid Volume Type\",\t \n\t\t\"Volume Creation Failed: Error Reading \"\n\t\t    \"MFG Page 4\", \t\t\t\t \n\t\t\"Volume Creation Failed: Creating Internal \"\n\t\t    \"Structures\", \t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\t\"Activation failed: Already Active Volume\", \t \n\t\t\"Activation failed: Unsupported Volume Type\", \t \n\t\t\"Activation failed: Too Many Active Volumes\", \t \n\t\t\"Activation failed: Volume ID in Use\", \t\t \n\t\t\"Activation failed: Reported Failure\", \t\t \n\t\t\"Activation failed: Importing a Volume\", \t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\t\"Phys Disk failed: Too Many Phys Disks\", \t \n\t\t\"Phys Disk failed: Data Passed too Large\",\t \n\t\t\"Phys Disk failed: DMA Error\", \t\t\t \n\t\t\"Phys Disk failed: Invalid <channel:id>\", \t \n\t\t\"Phys Disk failed: Creating Phys Disk Config \"\n\t\t    \"Page\", \t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\tNULL,\t\t\t\t\t\t \n\t\t\"Compatibility Error: IR Disabled\",\t\t \n\t\t\"Compatibility Error: Inquiry Command Failed\",\t \n\t\t\"Compatibility Error: Device not Direct Access \"\n\t\t    \"Device \",\t\t\t\t\t \n\t\t\"Compatibility Error: Removable Device Found\",\t \n\t\t\"Compatibility Error: Device SCSI Version not \"\n\t\t    \"2 or Higher\", \t\t\t\t \n\t\t\"Compatibility Error: SATA Device, 48 BIT LBA \"\n\t\t    \"not Supported\", \t\t\t\t \n\t\t\"Compatibility Error: Device doesn't have \"\n\t\t    \"512 Byte Block Sizes\", \t\t\t \n\t\t\"Compatibility Error: Volume Type Check Failed\",  \n\t\t\"Compatibility Error: Volume Type is \"\n\t\t    \"Unsupported by FW\", \t\t\t \n\t\t\"Compatibility Error: Disk Drive too Small for \"\n\t\t    \"use in Volume\", \t\t\t\t \n\t\t\"Compatibility Error: Phys Disk for Create \"\n\t\t    \"Volume not Found\", \t\t\t \n\t\t\"Compatibility Error: Too Many or too Few \"\n\t\t    \"Disks for Volume Type\", \t\t\t \n\t\t\"Compatibility Error: Disk stripe Sizes \"\n\t\t    \"Must be 64KB\", \t\t\t\t \n\t\t\"Compatibility Error: IME Size Limited to < 2TB\",  \n\t};\n\n \n \nstatic void\nmpt_sas_log_info(MPT_ADAPTER *ioc, u32 log_info, u8 cb_idx)\n{\n\tunion loginfo_type {\n\t\tu32\tloginfo;\n\t\tstruct {\n\t\t\tu32\tsubcode:16;\n\t\t\tu32\tcode:8;\n\t\t\tu32\toriginator:4;\n\t\t\tu32\tbus_type:4;\n\t\t} dw;\n\t};\n\tunion loginfo_type sas_loginfo;\n\tchar *originator_desc = NULL;\n\tchar *code_desc = NULL;\n\tchar *sub_code_desc = NULL;\n\n\tsas_loginfo.loginfo = log_info;\n\tif ((sas_loginfo.dw.bus_type != 3  ) &&\n\t    (sas_loginfo.dw.originator < ARRAY_SIZE(originator_str)))\n\t\treturn;\n\n\toriginator_desc = originator_str[sas_loginfo.dw.originator];\n\n\tswitch (sas_loginfo.dw.originator) {\n\n\t\tcase 0:   \n\t\t\tif (sas_loginfo.dw.code <\n\t\t\t    ARRAY_SIZE(iop_code_str))\n\t\t\t\tcode_desc = iop_code_str[sas_loginfo.dw.code];\n\t\t\tbreak;\n\t\tcase 1:   \n\t\t\tif (sas_loginfo.dw.code <\n\t\t\t    ARRAY_SIZE(pl_code_str))\n\t\t\t\tcode_desc = pl_code_str[sas_loginfo.dw.code];\n\t\t\tbreak;\n\t\tcase 2:   \n\t\t\tif (sas_loginfo.dw.code >=\n\t\t\t    ARRAY_SIZE(ir_code_str))\n\t\t\t\tbreak;\n\t\t\tcode_desc = ir_code_str[sas_loginfo.dw.code];\n\t\t\tif (sas_loginfo.dw.subcode >=\n\t\t\t    ARRAY_SIZE(raid_sub_code_str))\n\t\t\t\tbreak;\n\t\t\tif (sas_loginfo.dw.code == 0)\n\t\t\t\tsub_code_desc =\n\t\t\t\t    raid_sub_code_str[sas_loginfo.dw.subcode];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\n\tif (sub_code_desc != NULL)\n\t\tprintk(MYIOC_s_INFO_FMT\n\t\t\t\"LogInfo(0x%08x): Originator={%s}, Code={%s},\"\n\t\t\t\" SubCode={%s} cb_idx %s\\n\",\n\t\t\tioc->name, log_info, originator_desc, code_desc,\n\t\t\tsub_code_desc, MptCallbacksName[cb_idx]);\n\telse if (code_desc != NULL)\n\t\tprintk(MYIOC_s_INFO_FMT\n\t\t\t\"LogInfo(0x%08x): Originator={%s}, Code={%s},\"\n\t\t\t\" SubCode(0x%04x) cb_idx %s\\n\",\n\t\t\tioc->name, log_info, originator_desc, code_desc,\n\t\t\tsas_loginfo.dw.subcode, MptCallbacksName[cb_idx]);\n\telse\n\t\tprintk(MYIOC_s_INFO_FMT\n\t\t\t\"LogInfo(0x%08x): Originator={%s}, Code=(0x%02x),\"\n\t\t\t\" SubCode(0x%04x) cb_idx %s\\n\",\n\t\t\tioc->name, log_info, originator_desc,\n\t\t\tsas_loginfo.dw.code, sas_loginfo.dw.subcode,\n\t\t\tMptCallbacksName[cb_idx]);\n}\n\n \n \nstatic void\nmpt_iocstatus_info_config(MPT_ADAPTER *ioc, u32 ioc_status, MPT_FRAME_HDR *mf)\n{\n\tConfig_t *pReq = (Config_t *)mf;\n\tchar extend_desc[EVENT_DESCR_STR_SZ];\n\tchar *desc = NULL;\n\tu32 form;\n\tu8 page_type;\n\n\tif (pReq->Header.PageType == MPI_CONFIG_PAGETYPE_EXTENDED)\n\t\tpage_type = pReq->ExtPageType;\n\telse\n\t\tpage_type = pReq->Header.PageType;\n\n\t \n\tform = le32_to_cpu(pReq->PageAddress);\n\tif (ioc_status == MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {\n\t\tif (page_type == MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE ||\n\t\t    page_type == MPI_CONFIG_EXTPAGETYPE_SAS_EXPANDER ||\n\t\t    page_type == MPI_CONFIG_EXTPAGETYPE_ENCLOSURE) {\n\t\t\tif ((form >> MPI_SAS_DEVICE_PGAD_FORM_SHIFT) ==\n\t\t\t\tMPI_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE)\n\t\t\t\treturn;\n\t\t}\n\t\tif (page_type == MPI_CONFIG_PAGETYPE_FC_DEVICE)\n\t\t\tif ((form & MPI_FC_DEVICE_PGAD_FORM_MASK) ==\n\t\t\t\tMPI_FC_DEVICE_PGAD_FORM_NEXT_DID)\n\t\t\t\treturn;\n\t}\n\n\tsnprintf(extend_desc, EVENT_DESCR_STR_SZ,\n\t    \"type=%02Xh, page=%02Xh, action=%02Xh, form=%08Xh\",\n\t    page_type, pReq->Header.PageNumber, pReq->Action, form);\n\n\tswitch (ioc_status) {\n\n\tcase MPI_IOCSTATUS_CONFIG_INVALID_ACTION:  \n\t\tdesc = \"Config Page Invalid Action\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_CONFIG_INVALID_TYPE:    \n\t\tdesc = \"Config Page Invalid Type\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_CONFIG_INVALID_PAGE:    \n\t\tdesc = \"Config Page Invalid Page\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_CONFIG_INVALID_DATA:    \n\t\tdesc = \"Config Page Invalid Data\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_CONFIG_NO_DEFAULTS:     \n\t\tdesc = \"Config Page No Defaults\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_CONFIG_CANT_COMMIT:     \n\t\tdesc = \"Config Page Can't Commit\";\n\t\tbreak;\n\t}\n\n\tif (!desc)\n\t\treturn;\n\n\tdreplyprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"IOCStatus(0x%04X): %s: %s\\n\",\n\t    ioc->name, ioc_status, desc, extend_desc));\n}\n\n \nstatic void\nmpt_iocstatus_info(MPT_ADAPTER *ioc, u32 ioc_status, MPT_FRAME_HDR *mf)\n{\n\tu32 status = ioc_status & MPI_IOCSTATUS_MASK;\n\tchar *desc = NULL;\n\n\tswitch (status) {\n\n \n \n \n\n\tcase MPI_IOCSTATUS_INVALID_FUNCTION:  \n\t\tdesc = \"Invalid Function\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_BUSY:  \n\t\tdesc = \"Busy\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_INVALID_SGL:  \n\t\tdesc = \"Invalid SGL\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_INTERNAL_ERROR:  \n\t\tdesc = \"Internal Error\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_RESERVED:  \n\t\tdesc = \"Reserved\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_INSUFFICIENT_RESOURCES:  \n\t\tdesc = \"Insufficient Resources\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_INVALID_FIELD:  \n\t\tdesc = \"Invalid Field\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_INVALID_STATE:  \n\t\tdesc = \"Invalid State\";\n\t\tbreak;\n\n \n \n \n\n\tcase MPI_IOCSTATUS_CONFIG_INVALID_ACTION:  \n\tcase MPI_IOCSTATUS_CONFIG_INVALID_TYPE:    \n\tcase MPI_IOCSTATUS_CONFIG_INVALID_PAGE:    \n\tcase MPI_IOCSTATUS_CONFIG_INVALID_DATA:    \n\tcase MPI_IOCSTATUS_CONFIG_NO_DEFAULTS:     \n\tcase MPI_IOCSTATUS_CONFIG_CANT_COMMIT:     \n\t\tmpt_iocstatus_info_config(ioc, status, mf);\n\t\tbreak;\n\n \n \n \n \n \n \n\n\tcase MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:  \n\tcase MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:  \n\tcase MPI_IOCSTATUS_SCSI_INVALID_BUS:  \n\tcase MPI_IOCSTATUS_SCSI_INVALID_TARGETID:  \n\tcase MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:  \n\tcase MPI_IOCSTATUS_SCSI_DATA_OVERRUN:  \n\tcase MPI_IOCSTATUS_SCSI_IO_DATA_ERROR:  \n\tcase MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:  \n\tcase MPI_IOCSTATUS_SCSI_TASK_TERMINATED:  \n\tcase MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:  \n\tcase MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED:  \n\tcase MPI_IOCSTATUS_SCSI_IOC_TERMINATED:  \n\tcase MPI_IOCSTATUS_SCSI_EXT_TERMINATED:  \n\t\tbreak;\n\n \n \n \n\n\tcase MPI_IOCSTATUS_TARGET_PRIORITY_IO:  \n\t\tdesc = \"Target: Priority IO\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_TARGET_INVALID_PORT:  \n\t\tdesc = \"Target: Invalid Port\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_TARGET_INVALID_IO_INDEX:  \n\t\tdesc = \"Target Invalid IO Index:\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_TARGET_ABORTED:  \n\t\tdesc = \"Target: Aborted\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_TARGET_NO_CONN_RETRYABLE:  \n\t\tdesc = \"Target: No Conn Retryable\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_TARGET_NO_CONNECTION:  \n\t\tdesc = \"Target: No Connection\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH:  \n\t\tdesc = \"Target: Transfer Count Mismatch\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_TARGET_STS_DATA_NOT_SENT:  \n\t\tdesc = \"Target: STS Data not Sent\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_TARGET_DATA_OFFSET_ERROR:  \n\t\tdesc = \"Target: Data Offset Error\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA:  \n\t\tdesc = \"Target: Too Much Write Data\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_TARGET_IU_TOO_SHORT:  \n\t\tdesc = \"Target: IU Too Short\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_TARGET_ACK_NAK_TIMEOUT:  \n\t\tdesc = \"Target: ACK NAK Timeout\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_TARGET_NAK_RECEIVED:  \n\t\tdesc = \"Target: Nak Received\";\n\t\tbreak;\n\n \n \n \n\n\tcase MPI_IOCSTATUS_FC_ABORTED:  \n\t\tdesc = \"FC: Aborted\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_FC_RX_ID_INVALID:  \n\t\tdesc = \"FC: RX ID Invalid\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_FC_DID_INVALID:  \n\t\tdesc = \"FC: DID Invalid\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_FC_NODE_LOGGED_OUT:  \n\t\tdesc = \"FC: Node Logged Out\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_FC_EXCHANGE_CANCELED:  \n\t\tdesc = \"FC: Exchange Canceled\";\n\t\tbreak;\n\n \n \n \n\n\tcase MPI_IOCSTATUS_LAN_DEVICE_NOT_FOUND:  \n\t\tdesc = \"LAN: Device not Found\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_LAN_DEVICE_FAILURE:  \n\t\tdesc = \"LAN: Device Failure\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_LAN_TRANSMIT_ERROR:  \n\t\tdesc = \"LAN: Transmit Error\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_LAN_TRANSMIT_ABORTED:  \n\t\tdesc = \"LAN: Transmit Aborted\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_LAN_RECEIVE_ERROR:  \n\t\tdesc = \"LAN: Receive Error\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_LAN_RECEIVE_ABORTED:  \n\t\tdesc = \"LAN: Receive Aborted\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_LAN_PARTIAL_PACKET:  \n\t\tdesc = \"LAN: Partial Packet\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_LAN_CANCELED:  \n\t\tdesc = \"LAN: Canceled\";\n\t\tbreak;\n\n \n \n \n\n\tcase MPI_IOCSTATUS_SAS_SMP_REQUEST_FAILED:  \n\t\tdesc = \"SAS: SMP Request Failed\";\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_SAS_SMP_DATA_OVERRUN:  \n\t\tdesc = \"SAS: SMP Data Overrun\";\n\t\tbreak;\n\n\tdefault:\n\t\tdesc = \"Others\";\n\t\tbreak;\n\t}\n\n\tif (!desc)\n\t\treturn;\n\n\tdreplyprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"IOCStatus(0x%04X): %s\\n\",\n\t    ioc->name, status, desc));\n}\n\n \nEXPORT_SYMBOL(mpt_attach);\nEXPORT_SYMBOL(mpt_detach);\n#ifdef CONFIG_PM\nEXPORT_SYMBOL(mpt_resume);\nEXPORT_SYMBOL(mpt_suspend);\n#endif\nEXPORT_SYMBOL(ioc_list);\nEXPORT_SYMBOL(mpt_register);\nEXPORT_SYMBOL(mpt_deregister);\nEXPORT_SYMBOL(mpt_event_register);\nEXPORT_SYMBOL(mpt_event_deregister);\nEXPORT_SYMBOL(mpt_reset_register);\nEXPORT_SYMBOL(mpt_reset_deregister);\nEXPORT_SYMBOL(mpt_device_driver_register);\nEXPORT_SYMBOL(mpt_device_driver_deregister);\nEXPORT_SYMBOL(mpt_get_msg_frame);\nEXPORT_SYMBOL(mpt_put_msg_frame);\nEXPORT_SYMBOL(mpt_put_msg_frame_hi_pri);\nEXPORT_SYMBOL(mpt_free_msg_frame);\nEXPORT_SYMBOL(mpt_send_handshake_request);\nEXPORT_SYMBOL(mpt_verify_adapter);\nEXPORT_SYMBOL(mpt_GetIocState);\nEXPORT_SYMBOL(mpt_print_ioc_summary);\nEXPORT_SYMBOL(mpt_HardResetHandler);\nEXPORT_SYMBOL(mpt_config);\nEXPORT_SYMBOL(mpt_findImVolumes);\nEXPORT_SYMBOL(mpt_alloc_fw_memory);\nEXPORT_SYMBOL(mpt_free_fw_memory);\nEXPORT_SYMBOL(mptbase_sas_persist_operation);\nEXPORT_SYMBOL(mpt_raid_phys_disk_pg0);\n\n \n \nstatic int __init\nfusion_init(void)\n{\n\tu8 cb_idx;\n\n\tshow_mptmod_ver(my_NAME, my_VERSION);\n\tprintk(KERN_INFO COPYRIGHT \"\\n\");\n\n\tfor (cb_idx = 0; cb_idx < MPT_MAX_PROTOCOL_DRIVERS; cb_idx++) {\n\t\tMptCallbacks[cb_idx] = NULL;\n\t\tMptDriverClass[cb_idx] = MPTUNKNOWN_DRIVER;\n\t\tMptEvHandlers[cb_idx] = NULL;\n\t\tMptResetHandlers[cb_idx] = NULL;\n\t}\n\n\t \n\tmpt_base_index = mpt_register(mptbase_reply, MPTBASE_DRIVER,\n\t    \"mptbase_reply\");\n\n\t \n\tmpt_reset_register(mpt_base_index, mpt_ioc_reset);\n\n#ifdef CONFIG_PROC_FS\n\t(void) procmpt_create();\n#endif\n\treturn 0;\n}\n\n \n \nstatic void __exit\nfusion_exit(void)\n{\n\n\tmpt_reset_deregister(mpt_base_index);\n\n#ifdef CONFIG_PROC_FS\n\tprocmpt_destroy();\n#endif\n}\n\nmodule_init(fusion_init);\nmodule_exit(fusion_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}