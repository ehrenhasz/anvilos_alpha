{
  "module_name": "mptfc.c",
  "hash_id": "14fa0e24837567caa0673475bee7d3e7852054e73c68e321ce9ca999ce689936",
  "original_prompt": "Ingested from linux-6.6.14/drivers/message/fusion/mptfc.c",
  "human_readable_source": " \n \n \n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/kdev_t.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\t \n#include <linux/interrupt.h>\n#include <linux/reboot.h>\t \n#include <linux/workqueue.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport_fc.h>\n\n#include \"mptbase.h\"\n#include \"mptscsih.h\"\n\n \n#define my_NAME\t\t\"Fusion MPT FC Host driver\"\n#define my_VERSION\tMPT_LINUX_VERSION_COMMON\n#define MYNAM\t\t\"mptfc\"\n\nMODULE_AUTHOR(MODULEAUTHOR);\nMODULE_DESCRIPTION(my_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(my_VERSION);\n\n \n#define MPTFC_DEV_LOSS_TMO (60)\nstatic int mptfc_dev_loss_tmo = MPTFC_DEV_LOSS_TMO;\t \nmodule_param(mptfc_dev_loss_tmo, int, 0);\nMODULE_PARM_DESC(mptfc_dev_loss_tmo, \" Initial time the driver programs the \"\n    \t\t\t\t     \" transport to wait for an rport to \"\n\t\t\t\t     \" return following a device loss event.\"\n\t\t\t\t     \"  Default=60.\");\n\n \n#define MPTFC_MAX_LUN (16895)\nstatic int max_lun = MPTFC_MAX_LUN;\nmodule_param(max_lun, int, 0);\nMODULE_PARM_DESC(max_lun, \" max lun, default=16895 \");\n\nstatic u8\tmptfcDoneCtx = MPT_MAX_PROTOCOL_DRIVERS;\nstatic u8\tmptfcTaskCtx = MPT_MAX_PROTOCOL_DRIVERS;\nstatic u8\tmptfcInternalCtx = MPT_MAX_PROTOCOL_DRIVERS;\n\nstatic int mptfc_target_alloc(struct scsi_target *starget);\nstatic int mptfc_slave_alloc(struct scsi_device *sdev);\nstatic int mptfc_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *SCpnt);\nstatic void mptfc_target_destroy(struct scsi_target *starget);\nstatic void mptfc_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout);\nstatic void mptfc_remove(struct pci_dev *pdev);\nstatic int mptfc_abort(struct scsi_cmnd *SCpnt);\nstatic int mptfc_dev_reset(struct scsi_cmnd *SCpnt);\nstatic int mptfc_bus_reset(struct scsi_cmnd *SCpnt);\n\nstatic const struct scsi_host_template mptfc_driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.proc_name\t\t\t= \"mptfc\",\n\t.show_info\t\t\t= mptscsih_show_info,\n\t.name\t\t\t\t= \"MPT FC Host\",\n\t.info\t\t\t\t= mptscsih_info,\n\t.queuecommand\t\t\t= mptfc_qcmd,\n\t.target_alloc\t\t\t= mptfc_target_alloc,\n\t.slave_alloc\t\t\t= mptfc_slave_alloc,\n\t.slave_configure\t\t= mptscsih_slave_configure,\n\t.target_destroy\t\t\t= mptfc_target_destroy,\n\t.slave_destroy\t\t\t= mptscsih_slave_destroy,\n\t.change_queue_depth \t\t= mptscsih_change_queue_depth,\n\t.eh_timed_out\t\t\t= fc_eh_timed_out,\n\t.eh_abort_handler\t\t= mptfc_abort,\n\t.eh_device_reset_handler\t= mptfc_dev_reset,\n\t.eh_bus_reset_handler\t\t= mptfc_bus_reset,\n\t.eh_host_reset_handler\t\t= mptscsih_host_reset,\n\t.bios_param\t\t\t= mptscsih_bios_param,\n\t.can_queue\t\t\t= MPT_FC_CAN_QUEUE,\n\t.this_id\t\t\t= -1,\n\t.sg_tablesize\t\t\t= MPT_SCSI_SG_DEPTH,\n\t.max_sectors\t\t\t= 8192,\n\t.cmd_per_lun\t\t\t= 7,\n\t.shost_groups\t\t\t= mptscsih_host_attr_groups,\n};\n\n \n\nstatic struct pci_device_id mptfc_pci_table[] = {\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVICEID_FC909,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVICEID_FC919,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVICEID_FC929,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVICEID_FC919X,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVICEID_FC929X,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVICEID_FC939X,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVICEID_FC949X,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVICEID_FC949E,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_BROCADE, MPI_MANUFACTPAGE_DEVICEID_FC949E,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{0}\t \n};\nMODULE_DEVICE_TABLE(pci, mptfc_pci_table);\n\nstatic struct scsi_transport_template *mptfc_transport_template = NULL;\n\nstatic struct fc_function_template mptfc_transport_functions = {\n\t.dd_fcrport_size = 8,\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_port_id = 1,\n\t.show_rport_supported_classes = 1,\n\t.show_starget_node_name = 1,\n\t.show_starget_port_name = 1,\n\t.show_starget_port_id = 1,\n\t.set_rport_dev_loss_tmo = mptfc_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\t.show_host_speed = 1,\n\t.show_host_fabric_name = 1,\n\t.show_host_port_type = 1,\n\t.show_host_port_state = 1,\n\t.show_host_symbolic_name = 1,\n};\n\nstatic int\nmptfc_block_error_handler(struct scsi_cmnd *SCpnt,\n\t\t\t  int (*func)(struct scsi_cmnd *SCpnt),\n\t\t\t  const char *caller)\n{\n\tMPT_SCSI_HOST\t\t*hd;\n\tstruct scsi_device\t*sdev = SCpnt->device;\n\tstruct Scsi_Host\t*shost = sdev->host;\n\tstruct fc_rport\t\t*rport = starget_to_rport(scsi_target(sdev));\n\tunsigned long\t\tflags;\n\tint\t\t\tready;\n\tMPT_ADAPTER \t\t*ioc;\n\tint\t\t\tloops = 40;\t \n\n\thd = shost_priv(SCpnt->device->host);\n\tioc = hd->ioc;\n\tspin_lock_irqsave(shost->host_lock, flags);\n\twhile ((ready = fc_remote_port_chkready(rport) >> 16) == DID_IMM_RETRY\n\t || (loops > 0 && ioc->active == 0)) {\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\tdfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"mptfc_block_error_handler.%d: %d:%llu, port status is \"\n\t\t\t\"%x, active flag %d, deferring %s recovery.\\n\",\n\t\t\tioc->name, ioc->sh->host_no,\n\t\t\tSCpnt->device->id, SCpnt->device->lun,\n\t\t\tready, ioc->active, caller));\n\t\tmsleep(1000);\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\tloops --;\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tif (ready == DID_NO_CONNECT || !SCpnt->device->hostdata\n\t || ioc->active == 0) {\n\t\tdfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"%s.%d: %d:%llu, failing recovery, \"\n\t\t\t\"port state %x, active %d, vdevice %p.\\n\", caller,\n\t\t\tioc->name, ioc->sh->host_no,\n\t\t\tSCpnt->device->id, SCpnt->device->lun, ready,\n\t\t\tioc->active, SCpnt->device->hostdata));\n\t\treturn FAILED;\n\t}\n\tdfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"%s.%d: %d:%llu, executing recovery.\\n\", caller,\n\t\tioc->name, ioc->sh->host_no,\n\t\tSCpnt->device->id, SCpnt->device->lun));\n\treturn (*func)(SCpnt);\n}\n\nstatic int\nmptfc_abort(struct scsi_cmnd *SCpnt)\n{\n\treturn\n\t    mptfc_block_error_handler(SCpnt, mptscsih_abort, __func__);\n}\n\nstatic int\nmptfc_dev_reset(struct scsi_cmnd *SCpnt)\n{\n\treturn\n\t    mptfc_block_error_handler(SCpnt, mptscsih_dev_reset, __func__);\n}\n\nstatic int\nmptfc_bus_reset(struct scsi_cmnd *SCpnt)\n{\n\treturn\n\t    mptfc_block_error_handler(SCpnt, mptscsih_bus_reset, __func__);\n}\n\nstatic void\nmptfc_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout)\n{\n\tif (timeout > 0)\n\t\trport->dev_loss_tmo = timeout;\n\telse\n\t\trport->dev_loss_tmo = mptfc_dev_loss_tmo;\n}\n\nstatic int\nmptfc_FcDevPage0_cmp_func(const void *a, const void *b)\n{\n\tFCDevicePage0_t **aa = (FCDevicePage0_t **)a;\n\tFCDevicePage0_t **bb = (FCDevicePage0_t **)b;\n\n\tif ((*aa)->CurrentBus == (*bb)->CurrentBus) {\n\t\tif ((*aa)->CurrentTargetID == (*bb)->CurrentTargetID)\n\t\t\treturn 0;\n\t\tif ((*aa)->CurrentTargetID < (*bb)->CurrentTargetID)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\tif ((*aa)->CurrentBus < (*bb)->CurrentBus)\n\t\treturn -1;\n\treturn 1;\n}\n\nstatic int\nmptfc_GetFcDevPage0(MPT_ADAPTER *ioc, int ioc_port,\n\tvoid(*func)(MPT_ADAPTER *ioc,int channel, FCDevicePage0_t *arg))\n{\n\tConfigPageHeader_t\t hdr;\n\tCONFIGPARMS\t\t cfg;\n\tFCDevicePage0_t\t\t*ppage0_alloc, *fc;\n\tdma_addr_t\t\t page0_dma;\n\tint\t\t\t data_sz;\n\tint\t\t\t ii;\n\n\tFCDevicePage0_t\t\t*p0_array=NULL, *p_p0;\n\tFCDevicePage0_t\t\t**pp0_array=NULL, **p_pp0;\n\n\tint\t\t\t rc = -ENOMEM;\n\tU32\t\t\t port_id = 0xffffff;\n\tint\t\t\t num_targ = 0;\n\tint\t\t\t max_bus = ioc->facts.MaxBuses;\n\tint\t\t\t max_targ;\n\n\tmax_targ = (ioc->facts.MaxDevices == 0) ? 256 : ioc->facts.MaxDevices;\n\n\tdata_sz = sizeof(FCDevicePage0_t) * max_bus * max_targ;\n\tp_p0 = p0_array =  kzalloc(data_sz, GFP_KERNEL);\n\tif (!p0_array)\n\t\tgoto out;\n\n\tdata_sz = sizeof(FCDevicePage0_t *) * max_bus * max_targ;\n\tp_pp0 = pp0_array = kzalloc(data_sz, GFP_KERNEL);\n\tif (!pp0_array)\n\t\tgoto out;\n\n\tdo {\n\t\t \n\t\thdr.PageVersion = 0;\n\t\thdr.PageLength = 0;\n\t\thdr.PageNumber = 0;\n\t\thdr.PageType = MPI_CONFIG_PAGETYPE_FC_DEVICE;\n\t\tcfg.cfghdr.hdr = &hdr;\n\t\tcfg.physAddr = -1;\n\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\t\tcfg.dir = 0;\n\t\tcfg.pageAddr = port_id;\n\t\tcfg.timeout = 0;\n\n\t\tif ((rc = mpt_config(ioc, &cfg)) != 0)\n\t\t\tbreak;\n\n\t\tif (hdr.PageLength <= 0)\n\t\t\tbreak;\n\n\t\tdata_sz = hdr.PageLength * 4;\n\t\tppage0_alloc = dma_alloc_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t\t\t  &page0_dma, GFP_KERNEL);\n\t\trc = -ENOMEM;\n\t\tif (!ppage0_alloc)\n\t\t\tbreak;\n\n\t\tcfg.physAddr = page0_dma;\n\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\t\tif ((rc = mpt_config(ioc, &cfg)) == 0) {\n\t\t\tppage0_alloc->PortIdentifier =\n\t\t\t\tle32_to_cpu(ppage0_alloc->PortIdentifier);\n\n\t\t\tppage0_alloc->WWNN.Low =\n\t\t\t\tle32_to_cpu(ppage0_alloc->WWNN.Low);\n\n\t\t\tppage0_alloc->WWNN.High =\n\t\t\t\tle32_to_cpu(ppage0_alloc->WWNN.High);\n\n\t\t\tppage0_alloc->WWPN.Low =\n\t\t\t\tle32_to_cpu(ppage0_alloc->WWPN.Low);\n\n\t\t\tppage0_alloc->WWPN.High =\n\t\t\t\tle32_to_cpu(ppage0_alloc->WWPN.High);\n\n\t\t\tppage0_alloc->BBCredit =\n\t\t\t\tle16_to_cpu(ppage0_alloc->BBCredit);\n\n\t\t\tppage0_alloc->MaxRxFrameSize =\n\t\t\t\tle16_to_cpu(ppage0_alloc->MaxRxFrameSize);\n\n\t\t\tport_id = ppage0_alloc->PortIdentifier;\n\t\t\tnum_targ++;\n\t\t\t*p_p0 = *ppage0_alloc;\t \n\t\t\t*p_pp0++ = p_p0++;\t \n\t\t}\n\t\tdma_free_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t  ppage0_alloc, page0_dma);\n\t\tif (rc != 0)\n\t\t\tbreak;\n\n\t} while (port_id <= 0xff0000);\n\n\tif (num_targ) {\n\t\t \n\t\tif (num_targ > 1)\n\t\t\tsort (pp0_array, num_targ, sizeof(FCDevicePage0_t *),\n\t\t\t\tmptfc_FcDevPage0_cmp_func, NULL);\n\t\t \n\t\tfor (ii = 0; ii < num_targ;  ii++) {\n\t\t\tfc = *(pp0_array+ii);\n\t\t\tfunc(ioc, ioc_port, fc);\n\t\t}\n\t}\n\n out:\n\tkfree(pp0_array);\n\tkfree(p0_array);\n\treturn rc;\n}\n\nstatic int\nmptfc_generate_rport_ids(FCDevicePage0_t *pg0, struct fc_rport_identifiers *rid)\n{\n\t \n\tif (pg0->Flags & (MPI_FC_DEVICE_PAGE0_FLAGS_PLOGI_INVALID |\n\t\t\t  MPI_FC_DEVICE_PAGE0_FLAGS_PRLI_INVALID))\n\t\treturn -1;\n\n\tif (!(pg0->Flags & MPI_FC_DEVICE_PAGE0_FLAGS_TARGETID_BUS_VALID))\n\t\treturn -1;\n\n\tif (!(pg0->Protocol & MPI_FC_DEVICE_PAGE0_PROT_FCP_TARGET))\n\t\treturn -1;\n\n\t \n\trid->node_name = ((u64)pg0->WWNN.High) << 32 | (u64)pg0->WWNN.Low;\n\trid->port_name = ((u64)pg0->WWPN.High) << 32 | (u64)pg0->WWPN.Low;\n\trid->port_id =   pg0->PortIdentifier;\n\trid->roles = FC_RPORT_ROLE_UNKNOWN;\n\n\treturn 0;\n}\n\nstatic void\nmptfc_register_dev(MPT_ADAPTER *ioc, int channel, FCDevicePage0_t *pg0)\n{\n\tstruct fc_rport_identifiers rport_ids;\n\tstruct fc_rport\t\t*rport;\n\tstruct mptfc_rport_info\t*ri;\n\tint\t\t\tnew_ri = 1;\n\tu64\t\t\tpn, nn;\n\tVirtTarget\t\t*vtarget;\n\tu32\t\t\troles = FC_RPORT_ROLE_UNKNOWN;\n\n\tif (mptfc_generate_rport_ids(pg0, &rport_ids) < 0)\n\t\treturn;\n\n\troles |= FC_RPORT_ROLE_FCP_TARGET;\n\tif (pg0->Protocol & MPI_FC_DEVICE_PAGE0_PROT_FCP_INITIATOR)\n\t\troles |= FC_RPORT_ROLE_FCP_INITIATOR;\n\n\t \n\tlist_for_each_entry(ri, &ioc->fc_rports, list) {\n\t\tpn = (u64)ri->pg0.WWPN.High << 32 | (u64)ri->pg0.WWPN.Low;\n\t\tif (pn == rport_ids.port_name) {\t \n\t\t\tlist_move_tail(&ri->list, &ioc->fc_rports);\n\t\t\tnew_ri = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (new_ri) {\t \n\t\tri = kzalloc(sizeof(struct mptfc_rport_info), GFP_KERNEL);\n\t\tif (!ri)\n\t\t\treturn;\n\t\tlist_add_tail(&ri->list, &ioc->fc_rports);\n\t}\n\n\tri->pg0 = *pg0;\t \n\tri->flags &= ~MPT_RPORT_INFO_FLAGS_MISSING;\n\n\t \n\tif (!(ri->flags & MPT_RPORT_INFO_FLAGS_REGISTERED)) {\n\t\tri->flags |= MPT_RPORT_INFO_FLAGS_REGISTERED;\n\t\trport = fc_remote_port_add(ioc->sh, channel, &rport_ids);\n\t\tif (rport) {\n\t\t\tri->rport = rport;\n\t\t\tif (new_ri)  \n\t\t\t\trport->dev_loss_tmo = mptfc_dev_loss_tmo;\n\t\t\t \n\t\t\tif (ri->starget) {\n\t\t\t\tvtarget = ri->starget->hostdata;\n\t\t\t\tif (vtarget) {\n\t\t\t\t\tvtarget->id = pg0->CurrentTargetID;\n\t\t\t\t\tvtarget->channel = pg0->CurrentBus;\n\t\t\t\t\tvtarget->deleted = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*((struct mptfc_rport_info **)rport->dd_data) = ri;\n\t\t\t \n\t\t\tfc_remote_port_rolechg(rport,roles);\n\n\t\t\tpn = (u64)ri->pg0.WWPN.High << 32 | (u64)ri->pg0.WWPN.Low;\n\t\t\tnn = (u64)ri->pg0.WWNN.High << 32 | (u64)ri->pg0.WWNN.Low;\n\t\t\tdfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\"mptfc_reg_dev.%d: %x, %llx / %llx, tid %d, \"\n\t\t\t\t\"rport tid %d, tmo %d\\n\",\n\t\t\t\t\tioc->name,\n\t\t\t\t\tioc->sh->host_no,\n\t\t\t\t\tpg0->PortIdentifier,\n\t\t\t\t\t(unsigned long long)nn,\n\t\t\t\t\t(unsigned long long)pn,\n\t\t\t\t\tpg0->CurrentTargetID,\n\t\t\t\t\tri->rport->scsi_target_id,\n\t\t\t\t\tri->rport->dev_loss_tmo));\n\t\t} else {\n\t\t\tlist_del(&ri->list);\n\t\t\tkfree(ri);\n\t\t\tri = NULL;\n\t\t}\n\t}\n}\n\n \nstatic void\nmptfc_target_destroy(struct scsi_target *starget)\n{\n\tstruct fc_rport\t\t*rport;\n\tstruct mptfc_rport_info *ri;\n\n\trport = starget_to_rport(starget);\n\tif (rport) {\n\t\tri = *((struct mptfc_rport_info **)rport->dd_data);\n\t\tif (ri)\t \n\t\t\tri->starget = NULL;\n\t}\n\tkfree(starget->hostdata);\n\tstarget->hostdata = NULL;\n}\n\n \nstatic int\nmptfc_target_alloc(struct scsi_target *starget)\n{\n\tVirtTarget\t\t*vtarget;\n\tstruct fc_rport\t\t*rport;\n\tstruct mptfc_rport_info *ri;\n\tint\t\t\trc;\n\n\tvtarget = kzalloc(sizeof(VirtTarget), GFP_KERNEL);\n\tif (!vtarget)\n\t\treturn -ENOMEM;\n\tstarget->hostdata = vtarget;\n\n\trc = -ENODEV;\n\trport = starget_to_rport(starget);\n\tif (rport) {\n\t\tri = *((struct mptfc_rport_info **)rport->dd_data);\n\t\tif (ri) {\t \n\t\t\tvtarget->id = ri->pg0.CurrentTargetID;\n\t\t\tvtarget->channel = ri->pg0.CurrentBus;\n\t\t\tri->starget = starget;\n\t\t\trc = 0;\n\t\t}\n\t}\n\tif (rc != 0) {\n\t\tkfree(vtarget);\n\t\tstarget->hostdata = NULL;\n\t}\n\n\treturn rc;\n}\n \nstatic void\nmptfc_dump_lun_info(MPT_ADAPTER *ioc, struct fc_rport *rport, struct scsi_device *sdev,\n\t\tVirtTarget *vtarget)\n{\n\tu64 nn, pn;\n\tstruct mptfc_rport_info *ri;\n\n\tri = *((struct mptfc_rport_info **)rport->dd_data);\n\tpn = (u64)ri->pg0.WWPN.High << 32 | (u64)ri->pg0.WWPN.Low;\n\tnn = (u64)ri->pg0.WWNN.High << 32 | (u64)ri->pg0.WWNN.Low;\n\tdfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"mptfc_slv_alloc.%d: num_luns %d, sdev.id %d, \"\n\t\t\"CurrentTargetID %d, %x %llx %llx\\n\",\n\t\tioc->name,\n\t\tsdev->host->host_no,\n\t\tvtarget->num_luns,\n\t\tsdev->id, ri->pg0.CurrentTargetID,\n\t\tri->pg0.PortIdentifier,\n\t\t(unsigned long long)pn,\n\t\t(unsigned long long)nn));\n}\n\n\n \nstatic int\nmptfc_slave_alloc(struct scsi_device *sdev)\n{\n\tMPT_SCSI_HOST\t\t*hd;\n\tVirtTarget\t\t*vtarget;\n\tVirtDevice\t\t*vdevice;\n\tstruct scsi_target\t*starget;\n\tstruct fc_rport\t\t*rport;\n\tMPT_ADAPTER \t\t*ioc;\n\n\tstarget = scsi_target(sdev);\n\trport = starget_to_rport(starget);\n\n\tif (!rport || fc_remote_port_chkready(rport))\n\t\treturn -ENXIO;\n\n\thd = shost_priv(sdev->host);\n\tioc = hd->ioc;\n\n\tvdevice = kzalloc(sizeof(VirtDevice), GFP_KERNEL);\n\tif (!vdevice) {\n\t\tprintk(MYIOC_s_ERR_FMT \"slave_alloc kmalloc(%zd) FAILED!\\n\",\n\t\t\t\tioc->name, sizeof(VirtDevice));\n\t\treturn -ENOMEM;\n\t}\n\n\n\tsdev->hostdata = vdevice;\n\tvtarget = starget->hostdata;\n\n\tif (vtarget->num_luns == 0) {\n\t\tvtarget->ioc_id = ioc->id;\n\t\tvtarget->tflags = MPT_TARGET_FLAGS_Q_YES;\n\t}\n\n\tvdevice->vtarget = vtarget;\n\tvdevice->lun = sdev->lun;\n\n\tvtarget->num_luns++;\n\n\n\tmptfc_dump_lun_info(ioc, rport, sdev, vtarget);\n\n\treturn 0;\n}\n\nstatic int\nmptfc_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *SCpnt)\n{\n\tstruct mptfc_rport_info\t*ri;\n\tstruct fc_rport\t*rport = starget_to_rport(scsi_target(SCpnt->device));\n\tint\t\terr;\n\tVirtDevice\t*vdevice = SCpnt->device->hostdata;\n\n\tif (!vdevice || !vdevice->vtarget) {\n\t\tSCpnt->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(SCpnt);\n\t\treturn 0;\n\t}\n\n\terr = fc_remote_port_chkready(rport);\n\tif (unlikely(err)) {\n\t\tSCpnt->result = err;\n\t\tscsi_done(SCpnt);\n\t\treturn 0;\n\t}\n\n\t \n\tri = *((struct mptfc_rport_info **)rport->dd_data);\n\tif (unlikely(!ri)) {\n\t\tSCpnt->result = DID_IMM_RETRY << 16;\n\t\tscsi_done(SCpnt);\n\t\treturn 0;\n\t}\n\n\treturn mptscsih_qcmd(SCpnt);\n}\n\n \nstatic void\nmptfc_display_port_link_speed(MPT_ADAPTER *ioc, int portnum, FCPortPage0_t *pp0dest)\n{\n\tu8\told_speed, new_speed, state;\n\tchar\t*old, *new;\n\n\tif (portnum >= 2)\n\t\treturn;\n\n\told_speed = ioc->fc_link_speed[portnum];\n\tnew_speed = pp0dest->CurrentSpeed;\n\tstate = pp0dest->PortState;\n\n\tif (state != MPI_FCPORTPAGE0_PORTSTATE_OFFLINE &&\n\t    new_speed != MPI_FCPORTPAGE0_CURRENT_SPEED_UNKNOWN) {\n\n\t\told = old_speed == MPI_FCPORTPAGE0_CURRENT_SPEED_1GBIT ? \"1 Gbps\" :\n\t\t       old_speed == MPI_FCPORTPAGE0_CURRENT_SPEED_2GBIT ? \"2 Gbps\" :\n\t\t\told_speed == MPI_FCPORTPAGE0_CURRENT_SPEED_4GBIT ? \"4 Gbps\" :\n\t\t\t \"Unknown\";\n\t\tnew = new_speed == MPI_FCPORTPAGE0_CURRENT_SPEED_1GBIT ? \"1 Gbps\" :\n\t\t       new_speed == MPI_FCPORTPAGE0_CURRENT_SPEED_2GBIT ? \"2 Gbps\" :\n\t\t\tnew_speed == MPI_FCPORTPAGE0_CURRENT_SPEED_4GBIT ? \"4 Gbps\" :\n\t\t\t \"Unknown\";\n\t\tif (old_speed == 0)\n\t\t\tprintk(MYIOC_s_NOTE_FMT\n\t\t\t\t\"FC Link Established, Speed = %s\\n\",\n\t\t\t\tioc->name, new);\n\t\telse if (old_speed != new_speed)\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\t\"FC Link Speed Change, Old Speed = %s, New Speed = %s\\n\",\n\t\t\t\tioc->name, old, new);\n\n\t\tioc->fc_link_speed[portnum] = new_speed;\n\t}\n}\n\n \nstatic int\nmptfc_GetFcPortPage0(MPT_ADAPTER *ioc, int portnum)\n{\n\tConfigPageHeader_t\t hdr;\n\tCONFIGPARMS\t\t cfg;\n\tFCPortPage0_t\t\t*ppage0_alloc;\n\tFCPortPage0_t\t\t*pp0dest;\n\tdma_addr_t\t\t page0_dma;\n\tint\t\t\t data_sz;\n\tint\t\t\t copy_sz;\n\tint\t\t\t rc;\n\tint\t\t\t count = 400;\n\n\tif (portnum > 1)\n\t\treturn -EINVAL;\n\n\t \n\thdr.PageVersion = 0;\n\thdr.PageLength = 0;\n\thdr.PageNumber = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_FC_PORT;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.pageAddr = portnum;\n\tcfg.timeout = 0;\n\n\tif ((rc = mpt_config(ioc, &cfg)) != 0)\n\t\treturn rc;\n\n\tif (hdr.PageLength == 0)\n\t\treturn 0;\n\n\tdata_sz = hdr.PageLength * 4;\n\trc = -ENOMEM;\n\tppage0_alloc = dma_alloc_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t\t  &page0_dma, GFP_KERNEL);\n\tif (ppage0_alloc) {\n\n try_again:\n\t\tmemset((u8 *)ppage0_alloc, 0, data_sz);\n\t\tcfg.physAddr = page0_dma;\n\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\t\tif ((rc = mpt_config(ioc, &cfg)) == 0) {\n\t\t\t \n\t\t\tpp0dest = &ioc->fc_port_page0[portnum];\n\t\t\tcopy_sz = min_t(int, sizeof(FCPortPage0_t), data_sz);\n\t\t\tmemcpy(pp0dest, ppage0_alloc, copy_sz);\n\n\t\t\t \n\t\t\tpp0dest->Flags = le32_to_cpu(pp0dest->Flags);\n\t\t\tpp0dest->PortIdentifier = le32_to_cpu(pp0dest->PortIdentifier);\n\t\t\tpp0dest->WWNN.Low = le32_to_cpu(pp0dest->WWNN.Low);\n\t\t\tpp0dest->WWNN.High = le32_to_cpu(pp0dest->WWNN.High);\n\t\t\tpp0dest->WWPN.Low = le32_to_cpu(pp0dest->WWPN.Low);\n\t\t\tpp0dest->WWPN.High = le32_to_cpu(pp0dest->WWPN.High);\n\t\t\tpp0dest->SupportedServiceClass = le32_to_cpu(pp0dest->SupportedServiceClass);\n\t\t\tpp0dest->SupportedSpeeds = le32_to_cpu(pp0dest->SupportedSpeeds);\n\t\t\tpp0dest->CurrentSpeed = le32_to_cpu(pp0dest->CurrentSpeed);\n\t\t\tpp0dest->MaxFrameSize = le32_to_cpu(pp0dest->MaxFrameSize);\n\t\t\tpp0dest->FabricWWNN.Low = le32_to_cpu(pp0dest->FabricWWNN.Low);\n\t\t\tpp0dest->FabricWWNN.High = le32_to_cpu(pp0dest->FabricWWNN.High);\n\t\t\tpp0dest->FabricWWPN.Low = le32_to_cpu(pp0dest->FabricWWPN.Low);\n\t\t\tpp0dest->FabricWWPN.High = le32_to_cpu(pp0dest->FabricWWPN.High);\n\t\t\tpp0dest->DiscoveredPortsCount = le32_to_cpu(pp0dest->DiscoveredPortsCount);\n\t\t\tpp0dest->MaxInitiators = le32_to_cpu(pp0dest->MaxInitiators);\n\n\t\t\t \n\t\t\tif ((pp0dest->PortState == MPI_FCPORTPAGE0_PORTSTATE_UNKNOWN) ||\n\t\t\t    (pp0dest->PortState == MPI_FCPORTPAGE0_PORTSTATE_ONLINE &&\n\t\t\t     (pp0dest->Flags & MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK)\n\t\t\t      == MPI_FCPORTPAGE0_FLAGS_ATTACH_NO_INIT)) {\n\t\t\t\tif (count-- > 0) {\n\t\t\t\t\tmsleep(100);\n\t\t\t\t\tgoto try_again;\n\t\t\t\t}\n\t\t\t\tprintk(MYIOC_s_INFO_FMT \"Firmware discovery not\"\n\t\t\t\t\t\t\t\" complete.\\n\",\n\t\t\t\t\t\tioc->name);\n\t\t\t}\n\t\t\tmptfc_display_port_link_speed(ioc, portnum, pp0dest);\n\t\t}\n\n\t\tdma_free_coherent(&ioc->pcidev->dev, data_sz, ppage0_alloc,\n\t\t\t\t  page0_dma);\n\t}\n\n\treturn rc;\n}\n\nstatic int\nmptfc_WriteFcPortPage1(MPT_ADAPTER *ioc, int portnum)\n{\n\tConfigPageHeader_t\t hdr;\n\tCONFIGPARMS\t\t cfg;\n\tint\t\t\t rc;\n\n\tif (portnum > 1)\n\t\treturn -EINVAL;\n\n\tif (!(ioc->fc_data.fc_port_page1[portnum].data))\n\t\treturn -EINVAL;\n\n\t \n\thdr.PageVersion = 0;\n\thdr.PageLength = 0;\n\thdr.PageNumber = 1;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_FC_PORT;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.pageAddr = portnum;\n\tcfg.timeout = 0;\n\n\tif ((rc = mpt_config(ioc, &cfg)) != 0)\n\t\treturn rc;\n\n\tif (hdr.PageLength == 0)\n\t\treturn -ENODEV;\n\n\tif (hdr.PageLength*4 != ioc->fc_data.fc_port_page1[portnum].pg_sz)\n\t\treturn -EINVAL;\n\n\tcfg.physAddr = ioc->fc_data.fc_port_page1[portnum].dma;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;\n\tcfg.dir = 1;\n\n\trc = mpt_config(ioc, &cfg);\n\n\treturn rc;\n}\n\nstatic int\nmptfc_GetFcPortPage1(MPT_ADAPTER *ioc, int portnum)\n{\n\tConfigPageHeader_t\t hdr;\n\tCONFIGPARMS\t\t cfg;\n\tFCPortPage1_t\t\t*page1_alloc;\n\tdma_addr_t\t\t page1_dma;\n\tint\t\t\t data_sz;\n\tint\t\t\t rc;\n\n\tif (portnum > 1)\n\t\treturn -EINVAL;\n\n\t \n\thdr.PageVersion = 0;\n\thdr.PageLength = 0;\n\thdr.PageNumber = 1;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_FC_PORT;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.pageAddr = portnum;\n\tcfg.timeout = 0;\n\n\tif ((rc = mpt_config(ioc, &cfg)) != 0)\n\t\treturn rc;\n\n\tif (hdr.PageLength == 0)\n\t\treturn -ENODEV;\n\nstart_over:\n\n\tif (ioc->fc_data.fc_port_page1[portnum].data == NULL) {\n\t\tdata_sz = hdr.PageLength * 4;\n\t\tif (data_sz < sizeof(FCPortPage1_t))\n\t\t\tdata_sz = sizeof(FCPortPage1_t);\n\n\t\tpage1_alloc = dma_alloc_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t\t\t &page1_dma, GFP_KERNEL);\n\t\tif (!page1_alloc)\n\t\t\treturn -ENOMEM;\n\t}\n\telse {\n\t\tpage1_alloc = ioc->fc_data.fc_port_page1[portnum].data;\n\t\tpage1_dma = ioc->fc_data.fc_port_page1[portnum].dma;\n\t\tdata_sz = ioc->fc_data.fc_port_page1[portnum].pg_sz;\n\t\tif (hdr.PageLength * 4 > data_sz) {\n\t\t\tioc->fc_data.fc_port_page1[portnum].data = NULL;\n\t\t\tdma_free_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t\t  page1_alloc, page1_dma);\n\t\t\tgoto start_over;\n\t\t}\n\t}\n\n\tcfg.physAddr = page1_dma;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\tif ((rc = mpt_config(ioc, &cfg)) == 0) {\n\t\tioc->fc_data.fc_port_page1[portnum].data = page1_alloc;\n\t\tioc->fc_data.fc_port_page1[portnum].pg_sz = data_sz;\n\t\tioc->fc_data.fc_port_page1[portnum].dma = page1_dma;\n\t}\n\telse {\n\t\tioc->fc_data.fc_port_page1[portnum].data = NULL;\n\t\tdma_free_coherent(&ioc->pcidev->dev, data_sz, page1_alloc,\n\t\t\t\t  page1_dma);\n\t}\n\n\treturn rc;\n}\n\nstatic void\nmptfc_SetFcPortPage1_defaults(MPT_ADAPTER *ioc)\n{\n\tint\t\tii;\n\tFCPortPage1_t\t*pp1;\n\n\t#define MPTFC_FW_DEVICE_TIMEOUT\t(1)\n\t#define MPTFC_FW_IO_PEND_TIMEOUT (1)\n\t#define ON_FLAGS  (MPI_FCPORTPAGE1_FLAGS_IMMEDIATE_ERROR_REPLY)\n\t#define OFF_FLAGS (MPI_FCPORTPAGE1_FLAGS_VERBOSE_RESCAN_EVENTS)\n\n\tfor (ii=0; ii<ioc->facts.NumberOfPorts; ii++) {\n\t\tif (mptfc_GetFcPortPage1(ioc, ii) != 0)\n\t\t\tcontinue;\n\t\tpp1 = ioc->fc_data.fc_port_page1[ii].data;\n\t\tif ((pp1->InitiatorDeviceTimeout == MPTFC_FW_DEVICE_TIMEOUT)\n\t\t && (pp1->InitiatorIoPendTimeout == MPTFC_FW_IO_PEND_TIMEOUT)\n\t\t && ((pp1->Flags & ON_FLAGS) == ON_FLAGS)\n\t\t && ((pp1->Flags & OFF_FLAGS) == 0))\n\t\t\tcontinue;\n\t\tpp1->InitiatorDeviceTimeout = MPTFC_FW_DEVICE_TIMEOUT;\n\t\tpp1->InitiatorIoPendTimeout = MPTFC_FW_IO_PEND_TIMEOUT;\n\t\tpp1->Flags &= ~OFF_FLAGS;\n\t\tpp1->Flags |= ON_FLAGS;\n\t\tmptfc_WriteFcPortPage1(ioc, ii);\n\t}\n}\n\n\nstatic void\nmptfc_init_host_attr(MPT_ADAPTER *ioc,int portnum)\n{\n\tunsigned\tclass = 0;\n\tunsigned\tcos = 0;\n\tunsigned\tspeed;\n\tunsigned\tport_type;\n\tunsigned\tport_state;\n\tFCPortPage0_t\t*pp0;\n\tstruct Scsi_Host *sh;\n\tchar\t\t*sn;\n\n\t \n\tif (portnum != 0)\n\t\treturn;\n\n\tpp0 = &ioc->fc_port_page0[portnum];\n\tsh = ioc->sh;\n\n\tsn = fc_host_symbolic_name(sh);\n\tsnprintf(sn, FC_SYMBOLIC_NAME_SIZE, \"%s %s%08xh\",\n\t    ioc->prod_name,\n\t    MPT_FW_REV_MAGIC_ID_STRING,\n\t    ioc->facts.FWVersion.Word);\n\n\tfc_host_tgtid_bind_type(sh) = FC_TGTID_BIND_BY_WWPN;\n\n\tfc_host_maxframe_size(sh) = pp0->MaxFrameSize;\n\n\tfc_host_node_name(sh) =\n\t    \t(u64)pp0->WWNN.High << 32 | (u64)pp0->WWNN.Low;\n\n\tfc_host_port_name(sh) =\n\t    \t(u64)pp0->WWPN.High << 32 | (u64)pp0->WWPN.Low;\n\n\tfc_host_port_id(sh) = pp0->PortIdentifier;\n\n\tclass = pp0->SupportedServiceClass;\n\tif (class & MPI_FCPORTPAGE0_SUPPORT_CLASS_1)\n\t\tcos |= FC_COS_CLASS1;\n\tif (class & MPI_FCPORTPAGE0_SUPPORT_CLASS_2)\n\t\tcos |= FC_COS_CLASS2;\n\tif (class & MPI_FCPORTPAGE0_SUPPORT_CLASS_3)\n\t\tcos |= FC_COS_CLASS3;\n\tfc_host_supported_classes(sh) = cos;\n\n\tif (pp0->CurrentSpeed == MPI_FCPORTPAGE0_CURRENT_SPEED_1GBIT)\n\t\tspeed = FC_PORTSPEED_1GBIT;\n\telse if (pp0->CurrentSpeed == MPI_FCPORTPAGE0_CURRENT_SPEED_2GBIT)\n\t\tspeed = FC_PORTSPEED_2GBIT;\n\telse if (pp0->CurrentSpeed == MPI_FCPORTPAGE0_CURRENT_SPEED_4GBIT)\n\t\tspeed = FC_PORTSPEED_4GBIT;\n\telse if (pp0->CurrentSpeed == MPI_FCPORTPAGE0_CURRENT_SPEED_10GBIT)\n\t\tspeed = FC_PORTSPEED_10GBIT;\n\telse\n\t\tspeed = FC_PORTSPEED_UNKNOWN;\n\tfc_host_speed(sh) = speed;\n\n\tspeed = 0;\n\tif (pp0->SupportedSpeeds & MPI_FCPORTPAGE0_SUPPORT_1GBIT_SPEED)\n\t\tspeed |= FC_PORTSPEED_1GBIT;\n\tif (pp0->SupportedSpeeds & MPI_FCPORTPAGE0_SUPPORT_2GBIT_SPEED)\n\t\tspeed |= FC_PORTSPEED_2GBIT;\n\tif (pp0->SupportedSpeeds & MPI_FCPORTPAGE0_SUPPORT_4GBIT_SPEED)\n\t\tspeed |= FC_PORTSPEED_4GBIT;\n\tif (pp0->SupportedSpeeds & MPI_FCPORTPAGE0_SUPPORT_10GBIT_SPEED)\n\t\tspeed |= FC_PORTSPEED_10GBIT;\n\tfc_host_supported_speeds(sh) = speed;\n\n\tport_state = FC_PORTSTATE_UNKNOWN;\n\tif (pp0->PortState == MPI_FCPORTPAGE0_PORTSTATE_ONLINE)\n\t\tport_state = FC_PORTSTATE_ONLINE;\n\telse if (pp0->PortState == MPI_FCPORTPAGE0_PORTSTATE_OFFLINE)\n\t\tport_state = FC_PORTSTATE_LINKDOWN;\n\tfc_host_port_state(sh) = port_state;\n\n\tport_type = FC_PORTTYPE_UNKNOWN;\n\tif (pp0->Flags & MPI_FCPORTPAGE0_FLAGS_ATTACH_POINT_TO_POINT)\n\t\tport_type = FC_PORTTYPE_PTP;\n\telse if (pp0->Flags & MPI_FCPORTPAGE0_FLAGS_ATTACH_PRIVATE_LOOP)\n\t\tport_type = FC_PORTTYPE_LPORT;\n\telse if (pp0->Flags & MPI_FCPORTPAGE0_FLAGS_ATTACH_PUBLIC_LOOP)\n\t\tport_type = FC_PORTTYPE_NLPORT;\n\telse if (pp0->Flags & MPI_FCPORTPAGE0_FLAGS_ATTACH_FABRIC_DIRECT)\n\t\tport_type = FC_PORTTYPE_NPORT;\n\tfc_host_port_type(sh) = port_type;\n\n\tfc_host_fabric_name(sh) =\n\t    (pp0->Flags & MPI_FCPORTPAGE0_FLAGS_FABRIC_WWN_VALID) ?\n\t\t(u64) pp0->FabricWWNN.High << 32 | (u64) pp0->FabricWWPN.Low :\n\t\t(u64)pp0->WWNN.High << 32 | (u64)pp0->WWNN.Low;\n\n}\n\nstatic void\nmptfc_link_status_change(struct work_struct *work)\n{\n\tMPT_ADAPTER             *ioc =\n\t\tcontainer_of(work, MPT_ADAPTER, fc_rescan_work);\n\tint ii;\n\n\tfor (ii=0; ii < ioc->facts.NumberOfPorts; ii++)\n\t\t(void) mptfc_GetFcPortPage0(ioc, ii);\n\n}\n\nstatic void\nmptfc_setup_reset(struct work_struct *work)\n{\n\tMPT_ADAPTER\t\t*ioc =\n\t\tcontainer_of(work, MPT_ADAPTER, fc_setup_reset_work);\n\tu64\t\t\tpn;\n\tstruct mptfc_rport_info *ri;\n\tstruct scsi_target      *starget;\n\tVirtTarget              *vtarget;\n\n\t \n\tlist_for_each_entry(ri, &ioc->fc_rports, list) {\n\t\tif (ri->flags & MPT_RPORT_INFO_FLAGS_REGISTERED) {\n\t\t\tri->flags &= ~MPT_RPORT_INFO_FLAGS_REGISTERED;\n\t\t\tfc_remote_port_delete(ri->rport);\t \n\t\t\tri->rport = NULL;\n\t\t\tstarget = ri->starget;\n\t\t\tif (starget) {\n\t\t\t\tvtarget = starget->hostdata;\n\t\t\t\tif (vtarget)\n\t\t\t\t\tvtarget->deleted = 1;\n\t\t\t}\n\n\t\t\tpn = (u64)ri->pg0.WWPN.High << 32 |\n\t\t\t     (u64)ri->pg0.WWPN.Low;\n\t\t\tdfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\"mptfc_setup_reset.%d: %llx deleted\\n\",\n\t\t\t\tioc->name,\n\t\t\t\tioc->sh->host_no,\n\t\t\t\t(unsigned long long)pn));\n\t\t}\n\t}\n}\n\nstatic void\nmptfc_rescan_devices(struct work_struct *work)\n{\n\tMPT_ADAPTER\t\t*ioc =\n\t\tcontainer_of(work, MPT_ADAPTER, fc_rescan_work);\n\tint\t\t\tii;\n\tu64\t\t\tpn;\n\tstruct mptfc_rport_info *ri;\n\tstruct scsi_target      *starget;\n\tVirtTarget              *vtarget;\n\n\t \n\tlist_for_each_entry(ri, &ioc->fc_rports, list) {\n\t\tif (ri->flags & MPT_RPORT_INFO_FLAGS_REGISTERED) {\n\t\t\tri->flags |= MPT_RPORT_INFO_FLAGS_MISSING;\n\t\t}\n\t}\n\n\t \n\tfor (ii=0; ii < ioc->facts.NumberOfPorts; ii++) {\n\t\t(void) mptfc_GetFcPortPage0(ioc, ii);\n\t\tmptfc_init_host_attr(ioc, ii);\t \n\t\tmptfc_GetFcDevPage0(ioc, ii, mptfc_register_dev);\n\t}\n\n\t \n\tlist_for_each_entry(ri, &ioc->fc_rports, list) {\n\t\t \n\t\tif (ri->flags & MPT_RPORT_INFO_FLAGS_MISSING) {\n\n\t\t\tri->flags &= ~(MPT_RPORT_INFO_FLAGS_REGISTERED|\n\t\t\t\t       MPT_RPORT_INFO_FLAGS_MISSING);\n\t\t\tfc_remote_port_delete(ri->rport);\t \n\t\t\tri->rport = NULL;\n\t\t\tstarget = ri->starget;\n\t\t\tif (starget) {\n\t\t\t\tvtarget = starget->hostdata;\n\t\t\t\tif (vtarget)\n\t\t\t\t\tvtarget->deleted = 1;\n\t\t\t}\n\n\t\t\tpn = (u64)ri->pg0.WWPN.High << 32 |\n\t\t\t     (u64)ri->pg0.WWPN.Low;\n\t\t\tdfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\"mptfc_rescan.%d: %llx deleted\\n\",\n\t\t\t\tioc->name,\n\t\t\t\tioc->sh->host_no,\n\t\t\t\t(unsigned long long)pn));\n\t\t}\n\t}\n}\n\nstatic int\nmptfc_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct Scsi_Host\t*sh;\n\tMPT_SCSI_HOST\t\t*hd;\n\tMPT_ADAPTER \t\t*ioc;\n\tunsigned long\t\t flags;\n\tint\t\t\t ii;\n\tint\t\t\t numSGE = 0;\n\tint\t\t\t scale;\n\tint\t\t\t ioc_cap;\n\tint\t\t\terror=0;\n\tint\t\t\tr;\n\n\tif ((r = mpt_attach(pdev,id)) != 0)\n\t\treturn r;\n\n\tioc = pci_get_drvdata(pdev);\n\tioc->DoneCtx = mptfcDoneCtx;\n\tioc->TaskCtx = mptfcTaskCtx;\n\tioc->InternalCtx = mptfcInternalCtx;\n\n\t \n\tif (ioc->last_state != MPI_IOC_STATE_OPERATIONAL) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t  \"Skipping because it's not operational!\\n\",\n\t\t  ioc->name);\n\t\terror = -ENODEV;\n\t\tgoto out_mptfc_probe;\n\t}\n\n\tif (!ioc->active) {\n\t\tprintk(MYIOC_s_WARN_FMT \"Skipping because it's disabled!\\n\",\n\t\t  ioc->name);\n\t\terror = -ENODEV;\n\t\tgoto out_mptfc_probe;\n\t}\n\n\t \n\tioc_cap = 0;\n\tfor (ii=0; ii < ioc->facts.NumberOfPorts; ii++) {\n\t\tif (ioc->pfacts[ii].ProtocolFlags &\n\t\t    MPI_PORTFACTS_PROTOCOL_INITIATOR)\n\t\t\tioc_cap ++;\n\t}\n\n\tif (!ioc_cap) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\"Skipping ioc=%p because SCSI Initiator mode is NOT enabled!\\n\",\n\t\t\tioc->name, ioc);\n\t\treturn 0;\n\t}\n\n\tsh = scsi_host_alloc(&mptfc_driver_template, sizeof(MPT_SCSI_HOST));\n\n\tif (!sh) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\"Unable to register controller with SCSI subsystem\\n\",\n\t\t\tioc->name);\n\t\terror = -1;\n\t\tgoto out_mptfc_probe;\n        }\n\n\tspin_lock_init(&ioc->fc_rescan_work_lock);\n\tINIT_WORK(&ioc->fc_rescan_work, mptfc_rescan_devices);\n\tINIT_WORK(&ioc->fc_setup_reset_work, mptfc_setup_reset);\n\tINIT_WORK(&ioc->fc_lsc_work, mptfc_link_status_change);\n\n\tspin_lock_irqsave(&ioc->FreeQlock, flags);\n\n\t \n\tioc->sh = sh;\n\n\tsh->io_port = 0;\n\tsh->n_io_port = 0;\n\tsh->irq = 0;\n\n\t \n\tsh->max_cmd_len = 16;\n\n\tsh->max_id = ioc->pfacts->MaxDevices;\n\tsh->max_lun = max_lun;\n\n\t \n\tsh->unique_id = ioc->id;\n\n\t \n\tscale = ioc->req_sz/ioc->SGE_size;\n\tif (ioc->sg_addr_size == sizeof(u64)) {\n\t\tnumSGE = (scale - 1) *\n\t\t  (ioc->facts.MaxChainDepth-1) + scale +\n\t\t  (ioc->req_sz - 60) / ioc->SGE_size;\n\t} else {\n\t\tnumSGE = 1 + (scale - 1) *\n\t\t  (ioc->facts.MaxChainDepth-1) + scale +\n\t\t  (ioc->req_sz - 64) / ioc->SGE_size;\n\t}\n\n\tif (numSGE < sh->sg_tablesize) {\n\t\t \n\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t  \"Resetting sg_tablesize to %d from %d\\n\",\n\t\t  ioc->name, numSGE, sh->sg_tablesize));\n\t\tsh->sg_tablesize = numSGE;\n\t}\n\n\tspin_unlock_irqrestore(&ioc->FreeQlock, flags);\n\n\thd = shost_priv(sh);\n\thd->ioc = ioc;\n\n\t \n\tioc->ScsiLookup = kcalloc(ioc->req_depth, sizeof(void *), GFP_KERNEL);\n\tif (!ioc->ScsiLookup) {\n\t\terror = -ENOMEM;\n\t\tgoto out_mptfc_probe;\n\t}\n\tspin_lock_init(&ioc->scsi_lookup_lock);\n\n\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"ScsiLookup @ %p\\n\",\n\t\t ioc->name, ioc->ScsiLookup));\n\n\thd->last_queue_full = 0;\n\n\tsh->transportt = mptfc_transport_template;\n\terror = scsi_add_host (sh, &ioc->pcidev->dev);\n\tif(error) {\n\t\tdprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t  \"scsi_add_host failed\\n\", ioc->name));\n\t\tgoto out_mptfc_probe;\n\t}\n\n\t \n\n\tsnprintf(ioc->fc_rescan_work_q_name, sizeof(ioc->fc_rescan_work_q_name),\n\t\t \"mptfc_wq_%d\", sh->host_no);\n\tioc->fc_rescan_work_q =\n\t\talloc_ordered_workqueue(ioc->fc_rescan_work_q_name,\n\t\t\t\t\tWQ_MEM_RECLAIM);\n\tif (!ioc->fc_rescan_work_q) {\n\t\terror = -ENOMEM;\n\t\tgoto out_mptfc_host;\n\t}\n\n\t \n\tfor (ii=0; ii < ioc->facts.NumberOfPorts; ii++) {\n\t\t(void) mptfc_GetFcPortPage0(ioc, ii);\n\t}\n\tmptfc_SetFcPortPage1_defaults(ioc);\n\n\t \n\n\tqueue_work(ioc->fc_rescan_work_q, &ioc->fc_rescan_work);\n\tflush_workqueue(ioc->fc_rescan_work_q);\n\n\treturn 0;\n\nout_mptfc_host:\n\tscsi_remove_host(sh);\n\nout_mptfc_probe:\n\n\tmptscsih_remove(pdev);\n\treturn error;\n}\n\nstatic struct pci_driver mptfc_driver = {\n\t.name\t\t= \"mptfc\",\n\t.id_table\t= mptfc_pci_table,\n\t.probe\t\t= mptfc_probe,\n\t.remove\t\t= mptfc_remove,\n\t.shutdown\t= mptscsih_shutdown,\n#ifdef CONFIG_PM\n\t.suspend\t= mptscsih_suspend,\n\t.resume\t\t= mptscsih_resume,\n#endif\n};\n\nstatic int\nmptfc_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)\n{\n\tMPT_SCSI_HOST *hd;\n\tu8 event = le32_to_cpu(pEvReply->Event) & 0xFF;\n\tunsigned long flags;\n\tint rc=1;\n\n\tif (ioc->bus_type != FC)\n\t\treturn 0;\n\n\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"MPT event (=%02Xh) routed to SCSI host driver!\\n\",\n\t\t\tioc->name, event));\n\n\tif (ioc->sh == NULL ||\n\t\t((hd = shost_priv(ioc->sh)) == NULL))\n\t\treturn 1;\n\n\tswitch (event) {\n\tcase MPI_EVENT_RESCAN:\n\t\tspin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);\n\t\tif (ioc->fc_rescan_work_q) {\n\t\t\tqueue_work(ioc->fc_rescan_work_q,\n\t\t\t\t   &ioc->fc_rescan_work);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->fc_rescan_work_lock, flags);\n\t\tbreak;\n\tcase MPI_EVENT_LINK_STATUS_CHANGE:\n\t\tspin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);\n\t\tif (ioc->fc_rescan_work_q) {\n\t\t\tqueue_work(ioc->fc_rescan_work_q,\n\t\t\t\t   &ioc->fc_lsc_work);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->fc_rescan_work_lock, flags);\n\t\tbreak;\n\tdefault:\n\t\trc = mptscsih_event_process(ioc,pEvReply);\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic int\nmptfc_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\n{\n\tint\t\trc;\n\tunsigned long\tflags;\n\n\trc = mptscsih_ioc_reset(ioc,reset_phase);\n\tif ((ioc->bus_type != FC) || (!rc))\n\t\treturn rc;\n\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\": IOC %s_reset routed to FC host driver!\\n\",ioc->name,\n\t\treset_phase==MPT_IOC_SETUP_RESET ? \"setup\" : (\n\t\treset_phase==MPT_IOC_PRE_RESET ? \"pre\" : \"post\")));\n\n\tif (reset_phase == MPT_IOC_SETUP_RESET) {\n\t\tspin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);\n\t\tif (ioc->fc_rescan_work_q) {\n\t\t\tqueue_work(ioc->fc_rescan_work_q,\n\t\t\t\t   &ioc->fc_setup_reset_work);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->fc_rescan_work_lock, flags);\n\t}\n\n\telse if (reset_phase == MPT_IOC_PRE_RESET) {\n\t}\n\n\telse {\t \n\t\tmptfc_SetFcPortPage1_defaults(ioc);\n\t\tspin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);\n\t\tif (ioc->fc_rescan_work_q) {\n\t\t\tqueue_work(ioc->fc_rescan_work_q,\n\t\t\t\t   &ioc->fc_rescan_work);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->fc_rescan_work_lock, flags);\n\t}\n\treturn 1;\n}\n\n \n \nstatic int __init\nmptfc_init(void)\n{\n\tint error;\n\n\tshow_mptmod_ver(my_NAME, my_VERSION);\n\n\t \n\tif (mptfc_dev_loss_tmo <= 0)\n\t\tmptfc_dev_loss_tmo = MPTFC_DEV_LOSS_TMO;\n\n\tmptfc_transport_template =\n\t\tfc_attach_transport(&mptfc_transport_functions);\n\n\tif (!mptfc_transport_template)\n\t\treturn -ENODEV;\n\n\tmptfcDoneCtx = mpt_register(mptscsih_io_done, MPTFC_DRIVER,\n\t    \"mptscsih_scandv_complete\");\n\tmptfcTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTFC_DRIVER,\n\t    \"mptscsih_scandv_complete\");\n\tmptfcInternalCtx = mpt_register(mptscsih_scandv_complete, MPTFC_DRIVER,\n\t    \"mptscsih_scandv_complete\");\n\n\tmpt_event_register(mptfcDoneCtx, mptfc_event_process);\n\tmpt_reset_register(mptfcDoneCtx, mptfc_ioc_reset);\n\n\terror = pci_register_driver(&mptfc_driver);\n\tif (error)\n\t\tfc_release_transport(mptfc_transport_template);\n\n\treturn error;\n}\n\n \n \nstatic void mptfc_remove(struct pci_dev *pdev)\n{\n\tMPT_ADAPTER\t\t*ioc = pci_get_drvdata(pdev);\n\tstruct mptfc_rport_info\t*p, *n;\n\tstruct workqueue_struct *work_q;\n\tunsigned long\t\tflags;\n\tint\t\t\tii;\n\n\t \n\tif ((work_q=ioc->fc_rescan_work_q)) {\n\t\tspin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);\n\t\tioc->fc_rescan_work_q = NULL;\n\t\tspin_unlock_irqrestore(&ioc->fc_rescan_work_lock, flags);\n\t\tdestroy_workqueue(work_q);\n\t}\n\n\tfc_remove_host(ioc->sh);\n\n\tlist_for_each_entry_safe(p, n, &ioc->fc_rports, list) {\n\t\tlist_del(&p->list);\n\t\tkfree(p);\n\t}\n\n\tfor (ii=0; ii<ioc->facts.NumberOfPorts; ii++) {\n\t\tif (ioc->fc_data.fc_port_page1[ii].data) {\n\t\t\tdma_free_coherent(&ioc->pcidev->dev,\n\t\t\t\t\t  ioc->fc_data.fc_port_page1[ii].pg_sz,\n\t\t\t\t\t  ioc->fc_data.fc_port_page1[ii].data,\n\t\t\t\t\t  ioc->fc_data.fc_port_page1[ii].dma);\n\t\t\tioc->fc_data.fc_port_page1[ii].data = NULL;\n\t\t}\n\t}\n\n\tscsi_remove_host(ioc->sh);\n\n\tmptscsih_remove(pdev);\n}\n\n \n \n \nstatic void __exit\nmptfc_exit(void)\n{\n\tpci_unregister_driver(&mptfc_driver);\n\tfc_release_transport(mptfc_transport_template);\n\n\tmpt_reset_deregister(mptfcDoneCtx);\n\tmpt_event_deregister(mptfcDoneCtx);\n\n\tmpt_deregister(mptfcInternalCtx);\n\tmpt_deregister(mptfcTaskCtx);\n\tmpt_deregister(mptfcDoneCtx);\n}\n\nmodule_init(mptfc_init);\nmodule_exit(mptfc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}