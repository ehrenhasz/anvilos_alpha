{
  "module_name": "mptctl.c",
  "hash_id": "e9fb816e7e665260c4bc576d33fab3e9c3f666cd262bd28b757b0c9621896b6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/message/fusion/mptctl.c",
  "human_readable_source": " \n \n \n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\t \n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/compat.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n#define COPYRIGHT\t\"Copyright (c) 1999-2008 LSI Corporation\"\n#define MODULEAUTHOR\t\"LSI Corporation\"\n#include \"mptbase.h\"\n#include \"mptctl.h\"\n\n \n#define my_NAME\t\t\"Fusion MPT misc device (ioctl) driver\"\n#define my_VERSION\tMPT_LINUX_VERSION_COMMON\n#define MYNAM\t\t\"mptctl\"\n\nMODULE_AUTHOR(MODULEAUTHOR);\nMODULE_DESCRIPTION(my_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(my_VERSION);\n\n \n\nstatic DEFINE_MUTEX(mpctl_mutex);\nstatic u8 mptctl_id = MPT_MAX_PROTOCOL_DRIVERS;\nstatic u8 mptctl_taskmgmt_id = MPT_MAX_PROTOCOL_DRIVERS;\n\nstatic DECLARE_WAIT_QUEUE_HEAD ( mptctl_wait );\n\n \n\nstruct buflist {\n\tu8\t*kptr;\n\tint\t len;\n};\n\n \nstatic int mptctl_fw_download(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_getiocinfo(MPT_ADAPTER *iocp, unsigned long arg, unsigned int cmd);\nstatic int mptctl_gettargetinfo(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_readtest(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_mpt_command(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_eventquery(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_eventenable(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_eventreport(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_replace_fw(MPT_ADAPTER *iocp, unsigned long arg);\n\nstatic int mptctl_do_reset(MPT_ADAPTER *iocp, unsigned long arg);\nstatic int mptctl_hp_hostinfo(MPT_ADAPTER *iocp, unsigned long arg, unsigned int cmd);\nstatic int mptctl_hp_targetinfo(MPT_ADAPTER *iocp, unsigned long arg);\n\nstatic int  mptctl_probe(struct pci_dev *);\nstatic void mptctl_remove(struct pci_dev *);\n\n#ifdef CONFIG_COMPAT\nstatic long compat_mpctl_ioctl(struct file *f, unsigned cmd, unsigned long arg);\n#endif\n \nstatic int mptctl_do_mpt_command(MPT_ADAPTER *iocp, struct mpt_ioctl_command karg, void __user *mfPtr);\nstatic int mptctl_do_fw_download(MPT_ADAPTER *iocp, char __user *ufwbuf, size_t fwlen);\nstatic MptSge_t *kbuf_alloc_2_sgl(int bytes, u32 dir, int sge_offset, int *frags,\n\t\tstruct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc);\nstatic void kfree_sgl(MptSge_t *sgl, dma_addr_t sgl_dma,\n\t\tstruct buflist *buflist, MPT_ADAPTER *ioc);\n\n \nstatic int  mptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase);\n\n \nstatic int mptctl_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply);\nstatic struct fasync_struct *async_queue=NULL;\n\n \n \n\n#define MAX_FRAGS_SPILL1\t9\n#define MAX_FRAGS_SPILL2\t15\n#define FRAGS_PER_BUCKET\t(MAX_FRAGS_SPILL2 + 1)\n\n\n\n#define MAX_CHAIN_FRAGS\t\t(4 * MAX_FRAGS_SPILL2 + 1)\n\n\n\n\n#define MAX_SGL_BYTES\t\t((MAX_FRAGS_SPILL1 + 1 + (4 * FRAGS_PER_BUCKET)) * 8)\n\n \n#define MAX_KMALLOC_SZ\t\t(128*1024)\n\n#define MPT_IOCTL_DEFAULT_TIMEOUT 10\t \n\n \n \nstatic inline int\nmptctl_syscall_down(MPT_ADAPTER *ioc, int nonblock)\n{\n\tint rc = 0;\n\n\tif (nonblock) {\n\t\tif (!mutex_trylock(&ioc->ioctl_cmds.mutex))\n\t\t\trc = -EAGAIN;\n\t} else {\n\t\tif (mutex_lock_interruptible(&ioc->ioctl_cmds.mutex))\n\t\t\trc = -ERESTARTSYS;\n\t}\n\treturn rc;\n}\n\n \n \nstatic int\nmptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply)\n{\n\tchar\t*sense_data;\n\tint\treq_index;\n\tint\tsz;\n\n\tif (!req)\n\t\treturn 0;\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"completing mpi function \"\n\t    \"(0x%02X), req=%p, reply=%p\\n\", ioc->name,  req->u.hdr.Function,\n\t    req, reply));\n\n\t \n\tif (ioc->ioctl_cmds.msg_context != req->u.hdr.MsgContext)\n\t\tgoto out_continuation;\n\n\tioc->ioctl_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\n\n\tif (!reply)\n\t\tgoto out;\n\n\tioc->ioctl_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\n\tsz = min(ioc->reply_sz, 4*reply->u.reply.MsgLength);\n\tmemcpy(ioc->ioctl_cmds.reply, reply, sz);\n\n\tif (reply->u.reply.IOCStatus || reply->u.reply.IOCLogInfo)\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"iocstatus (0x%04X), loginfo (0x%08X)\\n\", ioc->name,\n\t\t    le16_to_cpu(reply->u.reply.IOCStatus),\n\t\t    le32_to_cpu(reply->u.reply.IOCLogInfo)));\n\n\tif ((req->u.hdr.Function == MPI_FUNCTION_SCSI_IO_REQUEST) ||\n\t\t(req->u.hdr.Function ==\n\t\t MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {\n\n\t\tif (reply->u.sreply.SCSIStatus || reply->u.sreply.SCSIState)\n\t\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"scsi_status (0x%02x), scsi_state (0x%02x), \"\n\t\t\t\"tag = (0x%04x), transfer_count (0x%08x)\\n\", ioc->name,\n\t\t\treply->u.sreply.SCSIStatus,\n\t\t\treply->u.sreply.SCSIState,\n\t\t\tle16_to_cpu(reply->u.sreply.TaskTag),\n\t\t\tle32_to_cpu(reply->u.sreply.TransferCount)));\n\n\t\tif (reply->u.sreply.SCSIState &\n\t\t\tMPI_SCSI_STATE_AUTOSENSE_VALID) {\n\t\t\tsz = req->u.scsireq.SenseBufferLength;\n\t\t\treq_index =\n\t\t\t    le16_to_cpu(req->u.frame.hwhdr.msgctxu.fld.req_idx);\n\t\t\tsense_data = ((u8 *)ioc->sense_buf_pool +\n\t\t\t     (req_index * MPT_SENSE_BUFFER_ALLOC));\n\t\t\tmemcpy(ioc->ioctl_cmds.sense, sense_data, sz);\n\t\t\tioc->ioctl_cmds.status |= MPT_MGMT_STATUS_SENSE_VALID;\n\t\t}\n\t}\n\n out:\n\t \n\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\tif (req->u.hdr.Function == MPI_FUNCTION_SCSI_TASK_MGMT) {\n\t\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\t\tioc->ioctl_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\t\tcomplete(&ioc->ioctl_cmds.done);\n\t\t\tif (ioc->bus_type == SAS)\n\t\t\t\tioc->schedule_target_reset(ioc);\n\t\t} else {\n\t\t\tioc->ioctl_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\t\tcomplete(&ioc->ioctl_cmds.done);\n\t\t}\n\t}\n\n out_continuation:\n\tif (reply && (reply->u.reply.MsgFlags &\n\t    MPI_MSGFLAGS_CONTINUATION_REPLY))\n\t\treturn 0;\n\treturn 1;\n}\n\n\nstatic int\nmptctl_taskmgmt_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)\n{\n\tif (!mf)\n\t\treturn 0;\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"TaskMgmt completed (mf=%p, mr=%p)\\n\",\n\t\tioc->name, mf, mr));\n\n\tioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\n\n\tif (!mr)\n\t\tgoto out;\n\n\tioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\n\tmemcpy(ioc->taskmgmt_cmds.reply, mr,\n\t    min(MPT_DEFAULT_FRAME_SIZE, 4 * mr->u.reply.MsgLength));\n out:\n\tif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\tioc->taskmgmt_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\tcomplete(&ioc->taskmgmt_cmds.done);\n\t\tif (ioc->bus_type == SAS)\n\t\t\tioc->schedule_target_reset(ioc);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\nmptctl_do_taskmgmt(MPT_ADAPTER *ioc, u8 tm_type, u8 bus_id, u8 target_id)\n{\n\tMPT_FRAME_HDR\t*mf;\n\tSCSITaskMgmt_t\t*pScsiTm;\n\tSCSITaskMgmtReply_t *pScsiTmReply;\n\tint\t\t ii;\n\tint\t\t retval;\n\tunsigned long\t timeout;\n\tu16\t\t iocstatus;\n\n\n\tmutex_lock(&ioc->taskmgmt_cmds.mutex);\n\tif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {\n\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\treturn -EPERM;\n\t}\n\n\tretval = 0;\n\n\tmf = mpt_get_msg_frame(mptctl_taskmgmt_id, ioc);\n\tif (mf == NULL) {\n\t\tdtmprintk(ioc,\n\t\t\tprintk(MYIOC_s_WARN_FMT \"TaskMgmt, no msg frames!!\\n\",\n\t\t\tioc->name));\n\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\tretval = -ENOMEM;\n\t\tgoto tm_done;\n\t}\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"TaskMgmt request (mf=%p)\\n\",\n\t\tioc->name, mf));\n\n\tpScsiTm = (SCSITaskMgmt_t *) mf;\n\tmemset(pScsiTm, 0, sizeof(SCSITaskMgmt_t));\n\tpScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;\n\tpScsiTm->TaskType = tm_type;\n\tif ((tm_type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS) &&\n\t\t(ioc->bus_type == FC))\n\t\tpScsiTm->MsgFlags =\n\t\t\t\tMPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION;\n\tpScsiTm->TargetID = target_id;\n\tpScsiTm->Bus = bus_id;\n\tpScsiTm->ChainOffset = 0;\n\tpScsiTm->Reserved = 0;\n\tpScsiTm->Reserved1 = 0;\n\tpScsiTm->TaskMsgContext = 0;\n\tfor (ii= 0; ii < 8; ii++)\n\t\tpScsiTm->LUN[ii] = 0;\n\tfor (ii=0; ii < 7; ii++)\n\t\tpScsiTm->Reserved2[ii] = 0;\n\n\tswitch (ioc->bus_type) {\n\tcase FC:\n\t\ttimeout = 40;\n\t\tbreak;\n\tcase SAS:\n\t\ttimeout = 30;\n\t\tbreak;\n\tcase SPI:\n\t\tdefault:\n\t\ttimeout = 10;\n\t\tbreak;\n\t}\n\n\tdtmprintk(ioc,\n\t\tprintk(MYIOC_s_DEBUG_FMT \"TaskMgmt type=%d timeout=%ld\\n\",\n\t\tioc->name, tm_type, timeout));\n\n\tINITIALIZE_MGMT_STATUS(ioc->taskmgmt_cmds.status)\n\tif ((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q) &&\n\t    (ioc->facts.MsgVersion >= MPI_VERSION_01_05))\n\t\tmpt_put_msg_frame_hi_pri(mptctl_taskmgmt_id, ioc, mf);\n\telse {\n\t\tretval = mpt_send_handshake_request(mptctl_taskmgmt_id, ioc,\n\t\t    sizeof(SCSITaskMgmt_t), (u32 *)pScsiTm, CAN_SLEEP);\n\t\tif (retval != 0) {\n\t\t\tdfailprintk(ioc,\n\t\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t\t\"TaskMgmt send_handshake FAILED!\"\n\t\t\t\t\" (ioc %p, mf %p, rc=%d) \\n\", ioc->name,\n\t\t\t\tioc, mf, retval));\n\t\t\tmpt_free_msg_frame(ioc, mf);\n\t\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\t\tgoto tm_done;\n\t\t}\n\t}\n\n\t \n\tii = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done, timeout*HZ);\n\n\tif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"TaskMgmt failed\\n\", ioc->name));\n\t\tmpt_free_msg_frame(ioc, mf);\n\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\tif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\n\t\t\tretval = 0;\n\t\telse\n\t\t\tretval = -1;  \n\t\tgoto tm_done;\n\t}\n\n\tif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"TaskMgmt failed\\n\", ioc->name));\n\t\tretval = -1;  \n\t\tgoto tm_done;\n\t}\n\n\tpScsiTmReply = (SCSITaskMgmtReply_t *) ioc->taskmgmt_cmds.reply;\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"TaskMgmt fw_channel = %d, fw_id = %d, task_type=0x%02X, \"\n\t    \"iocstatus=0x%04X\\n\\tloginfo=0x%08X, response_code=0x%02X, \"\n\t    \"term_cmnds=%d\\n\", ioc->name, pScsiTmReply->Bus,\n\t    pScsiTmReply->TargetID, tm_type,\n\t    le16_to_cpu(pScsiTmReply->IOCStatus),\n\t    le32_to_cpu(pScsiTmReply->IOCLogInfo),\n\t    pScsiTmReply->ResponseCode,\n\t    le32_to_cpu(pScsiTmReply->TerminationCount)));\n\n\tiocstatus = le16_to_cpu(pScsiTmReply->IOCStatus) & MPI_IOCSTATUS_MASK;\n\n\tif (iocstatus == MPI_IOCSTATUS_SCSI_TASK_TERMINATED ||\n\t   iocstatus == MPI_IOCSTATUS_SCSI_IOC_TERMINATED ||\n\t   iocstatus == MPI_IOCSTATUS_SUCCESS)\n\t\tretval = 0;\n\telse {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"TaskMgmt failed\\n\", ioc->name));\n\t\tretval = -1;  \n\t}\n\n tm_done:\n\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\tCLEAR_MGMT_STATUS(ioc->taskmgmt_cmds.status)\n\treturn retval;\n}\n\n \n \nstatic void\nmptctl_timeout_expired(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)\n{\n\tunsigned long flags;\n\tint ret_val = -1;\n\tSCSIIORequest_t *scsi_req = (SCSIIORequest_t *) mf;\n\tu8 function = mf->u.hdr.Function;\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \": %s\\n\",\n\t\tioc->name, __func__));\n\n\tif (mpt_fwfault_debug)\n\t\tmpt_halt_firmware(ioc);\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress) {\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\tCLEAR_MGMT_PENDING_STATUS(ioc->ioctl_cmds.status)\n\t\tmpt_free_msg_frame(ioc, mf);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\n\tCLEAR_MGMT_PENDING_STATUS(ioc->ioctl_cmds.status)\n\n\tif (ioc->bus_type == SAS) {\n\t\tif (function == MPI_FUNCTION_SCSI_IO_REQUEST)\n\t\t\tret_val = mptctl_do_taskmgmt(ioc,\n\t\t\t\tMPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET,\n\t\t\t\tscsi_req->Bus, scsi_req->TargetID);\n\t\telse if (function == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)\n\t\t\tret_val = mptctl_do_taskmgmt(ioc,\n\t\t\t\tMPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,\n\t\t\t\tscsi_req->Bus, 0);\n\t\tif (!ret_val)\n\t\t\treturn;\n\t} else {\n\t\tif ((function == MPI_FUNCTION_SCSI_IO_REQUEST) ||\n\t\t\t(function == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH))\n\t\t\tret_val = mptctl_do_taskmgmt(ioc,\n\t\t\t\tMPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,\n\t\t\t\tscsi_req->Bus, 0);\n\t\tif (!ret_val)\n\t\t\treturn;\n\t}\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Calling Reset! \\n\",\n\t\t ioc->name));\n\tmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\n\tmpt_free_msg_frame(ioc, mf);\n}\n\n\n \n \nstatic int\nmptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\n{\n\tswitch(reset_phase) {\n\tcase MPT_IOC_SETUP_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_SETUP_RESET\\n\", ioc->name, __func__));\n\t\tbreak;\n\tcase MPT_IOC_PRE_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_PRE_RESET\\n\", ioc->name, __func__));\n\t\tbreak;\n\tcase MPT_IOC_POST_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_POST_RESET\\n\", ioc->name, __func__));\n\t\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\t\tioc->ioctl_cmds.status |= MPT_MGMT_STATUS_DID_IOCRESET;\n\t\t\tcomplete(&ioc->ioctl_cmds.done);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\n \n \nstatic int\nmptctl_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)\n{\n\tu8 event;\n\n\tevent = le32_to_cpu(pEvReply->Event) & 0xFF;\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"%s() called\\n\",\n\t    ioc->name, __func__));\n\tif(async_queue == NULL)\n\t\treturn 1;\n\n\t \n\tif (event == 0x21) {\n\t\tioc->aen_event_read_flag=1;\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Raised SIGIO to application\\n\",\n\t\t    ioc->name));\n\t\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"Raised SIGIO to application\\n\", ioc->name));\n\t\tkill_fasync(&async_queue, SIGIO, POLL_IN);\n\t\treturn 1;\n\t }\n\n\t \n\tif(ioc->aen_event_read_flag)\n\t\treturn 1;\n\n\t \n\tif (ioc->events && (ioc->eventTypes & ( 1 << event))) {\n\t\tioc->aen_event_read_flag=1;\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"Raised SIGIO to application\\n\", ioc->name));\n\t\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"Raised SIGIO to application\\n\", ioc->name));\n\t\tkill_fasync(&async_queue, SIGIO, POLL_IN);\n\t}\n\treturn 1;\n}\n\nstatic int\nmptctl_fasync(int fd, struct file *filep, int mode)\n{\n\tMPT_ADAPTER\t*ioc;\n\tint ret;\n\n\tmutex_lock(&mpctl_mutex);\n\tlist_for_each_entry(ioc, &ioc_list, list)\n\t\tioc->aen_event_read_flag=0;\n\n\tret = fasync_helper(fd, filep, mode, &async_queue);\n\tmutex_unlock(&mpctl_mutex);\n\treturn ret;\n}\n\n \n \nstatic long\n__mptctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tmpt_ioctl_header __user *uhdr = (void __user *) arg;\n\tmpt_ioctl_header\t khdr;\n\tunsigned iocnumX;\n\tint nonblock = (file->f_flags & O_NONBLOCK);\n\tint ret;\n\tMPT_ADAPTER *iocp = NULL;\n\n\tif (copy_from_user(&khdr, uhdr, sizeof(khdr))) {\n\t\tprintk(KERN_ERR MYNAM \"%s::mptctl_ioctl() @%d - \"\n\t\t\t\t\"Unable to copy mpt_ioctl_header data @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uhdr);\n\t\treturn -EFAULT;\n\t}\n\tret = -ENXIO;\t\t\t\t \n\n\t \n\tiocnumX = khdr.iocnum & 0xFF;\n\tif ((mpt_verify_adapter(iocnumX, &iocp) < 0) || (iocp == NULL))\n\t\treturn -ENODEV;\n\n\tif (!iocp->active) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_ioctl() @%d - Controller disabled.\\n\",\n\t\t\t\t__FILE__, __LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tif ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {\n\t\treturn mptctl_getiocinfo(iocp, arg, _IOC_SIZE(cmd));\n\t} else if (cmd == MPTTARGETINFO) {\n\t\treturn mptctl_gettargetinfo(iocp, arg);\n\t} else if (cmd == MPTTEST) {\n\t\treturn mptctl_readtest(iocp, arg);\n\t} else if (cmd == MPTEVENTQUERY) {\n\t\treturn mptctl_eventquery(iocp, arg);\n\t} else if (cmd == MPTEVENTENABLE) {\n\t\treturn mptctl_eventenable(iocp, arg);\n\t} else if (cmd == MPTEVENTREPORT) {\n\t\treturn mptctl_eventreport(iocp, arg);\n\t} else if (cmd == MPTFWREPLACE) {\n\t\treturn mptctl_replace_fw(iocp, arg);\n\t}\n\n\t \n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tif (cmd == MPTFWDOWNLOAD)\n\t\tret = mptctl_fw_download(iocp, arg);\n\telse if (cmd == MPTCOMMAND)\n\t\tret = mptctl_mpt_command(iocp, arg);\n\telse if (cmd == MPTHARDRESET)\n\t\tret = mptctl_do_reset(iocp, arg);\n\telse if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))\n\t\tret = mptctl_hp_hostinfo(iocp, arg, _IOC_SIZE(cmd));\n\telse if (cmd == HP_GETTARGETINFO)\n\t\tret = mptctl_hp_targetinfo(iocp, arg);\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}\n\nstatic long\nmptctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\tmutex_lock(&mpctl_mutex);\n\tret = __mptctl_ioctl(file, cmd, arg);\n\tmutex_unlock(&mpctl_mutex);\n\treturn ret;\n}\n\nstatic int mptctl_do_reset(MPT_ADAPTER *iocp, unsigned long arg)\n{\n\tstruct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;\n\tstruct mpt_ioctl_diag_reset krinfo;\n\n\tif (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_do_reset - \"\n\t\t\t\t\"Unable to copy mpt_ioctl_diag_reset struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, urinfo);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"mptctl_do_reset called.\\n\",\n\t    iocp->name));\n\n\tif (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) {\n\t\tprintk (MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_reset - reset failed.\\n\",\n\t\t\tiocp->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic int\nmptctl_fw_download(MPT_ADAPTER *iocp, unsigned long arg)\n{\n\tstruct mpt_fw_xfer __user *ufwdl = (void __user *) arg;\n\tstruct mpt_fw_xfer\t kfwdl;\n\n\tif (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::_ioctl_fwdl - \"\n\t\t\t\t\"Unable to copy mpt_fw_xfer struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, ufwdl);\n\t\treturn -EFAULT;\n\t}\n\n\treturn mptctl_do_fw_download(iocp, kfwdl.bufp, kfwdl.fwlen);\n}\n\n \n \nstatic int\nmptctl_do_fw_download(MPT_ADAPTER *iocp, char __user *ufwbuf, size_t fwlen)\n{\n\tFWDownload_t\t\t*dlmsg;\n\tMPT_FRAME_HDR\t\t*mf;\n\tFWDownloadTCSGE_t\t*ptsge;\n\tMptSge_t\t\t*sgl, *sgIn;\n\tchar\t\t\t*sgOut;\n\tstruct buflist\t\t*buflist;\n\tstruct buflist\t\t*bl;\n\tdma_addr_t\t\t sgl_dma;\n\tint\t\t\t ret;\n\tint\t\t\t numfrags = 0;\n\tint\t\t\t maxfrags;\n\tint\t\t\t n = 0;\n\tu32\t\t\t sgdir;\n\tu32\t\t\t nib;\n\tint\t\t\t fw_bytes_copied = 0;\n\tint\t\t\t i;\n\tint\t\t\t sge_offset = 0;\n\tu16\t\t\t iocstat;\n\tpFWDownloadReply_t\t ReplyMsg = NULL;\n\tunsigned long\t\t timeleft;\n\n\t \n\tif ((mf = mpt_get_msg_frame(mptctl_id, iocp)) == NULL)\n\t\treturn -EAGAIN;\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT\n\t    \"mptctl_do_fwdl called. mptctl_id = %xh.\\n\", iocp->name, mptctl_id));\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"DbG: kfwdl.bufp  = %p\\n\",\n\t    iocp->name, ufwbuf));\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"DbG: kfwdl.fwlen = %d\\n\",\n\t    iocp->name, (int)fwlen));\n\n\tdlmsg = (FWDownload_t*) mf;\n\tptsge = (FWDownloadTCSGE_t *) &dlmsg->SGL;\n\tsgOut = (char *) (ptsge + 1);\n\n\t \n\tdlmsg->ImageType = MPI_FW_DOWNLOAD_ITYPE_FW;\n\tdlmsg->Reserved = 0;\n\tdlmsg->ChainOffset = 0;\n\tdlmsg->Function = MPI_FUNCTION_FW_DOWNLOAD;\n\tdlmsg->Reserved1[0] = dlmsg->Reserved1[1] = dlmsg->Reserved1[2] = 0;\n\tif (iocp->facts.MsgVersion >= MPI_VERSION_01_05)\n\t\tdlmsg->MsgFlags = MPI_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT;\n\telse\n\t\tdlmsg->MsgFlags = 0;\n\n\n\t \n\tptsge->Reserved = 0;\n\tptsge->ContextSize = 0;\n\tptsge->DetailsLength = 12;\n\tptsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;\n\tptsge->Reserved_0100_Checksum = 0;\n\tptsge->ImageOffset = 0;\n\tptsge->ImageSize = cpu_to_le32(fwlen);\n\n\t \n\n\t \n\tsgdir = 0x04000000;\t\t \n\tsge_offset = sizeof(MPIHeader_t) + sizeof(FWDownloadTCSGE_t);\n\tif ((sgl = kbuf_alloc_2_sgl(fwlen, sgdir, sge_offset,\n\t\t\t\t    &numfrags, &buflist, &sgl_dma, iocp)) == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tmaxfrags = (iocp->req_sz - sizeof(MPIHeader_t) -\n\t\t\tsizeof(FWDownloadTCSGE_t))\n\t\t\t/ iocp->SGE_size;\n\tif (numfrags > maxfrags) {\n\t\tret = -EMLINK;\n\t\tgoto fwdl_out;\n\t}\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"DbG: sgl buffer = %p, sgfrags = %d\\n\",\n\t    iocp->name, sgl, numfrags));\n\n\t \n\tret = -EFAULT;\n\tsgIn = sgl;\n\tbl = buflist;\n\tfor (i=0; i < numfrags; i++) {\n\n\t\t \n\t\tnib = (sgIn->FlagsLength & 0x30000000) >> 28;\n\t\tif (nib == 0 || nib == 3) {\n\t\t\t;\n\t\t} else if (sgIn->Address) {\n\t\t\tiocp->add_sge(sgOut, sgIn->FlagsLength, sgIn->Address);\n\t\t\tn++;\n\t\t\tif (copy_from_user(bl->kptr, ufwbuf+fw_bytes_copied, bl->len)) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::_ioctl_fwdl - \"\n\t\t\t\t\t\"Unable to copy f/w buffer hunk#%d @ %p\\n\",\n\t\t\t\t\tiocp->name, __FILE__, __LINE__, n, ufwbuf);\n\t\t\t\tgoto fwdl_out;\n\t\t\t}\n\t\t\tfw_bytes_copied += bl->len;\n\t\t}\n\t\tsgIn++;\n\t\tbl++;\n\t\tsgOut += iocp->SGE_size;\n\t}\n\n\tDBG_DUMP_FW_DOWNLOAD(iocp, (u32 *)mf, numfrags);\n\n\t \n\tReplyMsg = NULL;\n\tSET_MGMT_MSG_CONTEXT(iocp->ioctl_cmds.msg_context, dlmsg->MsgContext);\n\tINITIALIZE_MGMT_STATUS(iocp->ioctl_cmds.status)\n\tmpt_put_msg_frame(mptctl_id, iocp, mf);\n\n\t \nretry_wait:\n\ttimeleft = wait_for_completion_timeout(&iocp->ioctl_cmds.done, HZ*60);\n\tif (!(iocp->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tret = -ETIME;\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: failed\\n\", iocp->name, __func__);\n\t\tif (iocp->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\n\t\t\tmpt_free_msg_frame(iocp, mf);\n\t\t\tgoto fwdl_out;\n\t\t}\n\t\tif (!timeleft) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t       \"FW download timeout, doorbell=0x%08x\\n\",\n\t\t\t       iocp->name, mpt_GetIocState(iocp, 0));\n\t\t\tmptctl_timeout_expired(iocp, mf);\n\t\t} else\n\t\t\tgoto retry_wait;\n\t\tgoto fwdl_out;\n\t}\n\n\tif (!(iocp->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: failed\\n\", iocp->name, __func__);\n\t\tmpt_free_msg_frame(iocp, mf);\n\t\tret = -ENODATA;\n\t\tgoto fwdl_out;\n\t}\n\n\tif (sgl)\n\t\tkfree_sgl(sgl, sgl_dma, buflist, iocp);\n\n\tReplyMsg = (pFWDownloadReply_t)iocp->ioctl_cmds.reply;\n\tiocstat = le16_to_cpu(ReplyMsg->IOCStatus) & MPI_IOCSTATUS_MASK;\n\tif (iocstat == MPI_IOCSTATUS_SUCCESS) {\n\t\tprintk(MYIOC_s_INFO_FMT \"F/W update successful!\\n\", iocp->name);\n\t\treturn 0;\n\t} else if (iocstat == MPI_IOCSTATUS_INVALID_FUNCTION) {\n\t\tprintk(MYIOC_s_WARN_FMT \"Hmmm...  F/W download not supported!?!\\n\",\n\t\t\tiocp->name);\n\t\tprintk(MYIOC_s_WARN_FMT \"(time to go bang on somebodies door)\\n\",\n\t\t\tiocp->name);\n\t\treturn -EBADRQC;\n\t} else if (iocstat == MPI_IOCSTATUS_BUSY) {\n\t\tprintk(MYIOC_s_WARN_FMT \"IOC_BUSY!\\n\", iocp->name);\n\t\tprintk(MYIOC_s_WARN_FMT \"(try again later?)\\n\", iocp->name);\n\t\treturn -EBUSY;\n\t} else {\n\t\tprintk(MYIOC_s_WARN_FMT \"ioctl_fwdl() returned [bad] status = %04xh\\n\",\n\t\t\tiocp->name, iocstat);\n\t\tprintk(MYIOC_s_WARN_FMT \"(bad VooDoo)\\n\", iocp->name);\n\t\treturn -ENOMSG;\n\t}\n\treturn 0;\n\nfwdl_out:\n\n\tCLEAR_MGMT_STATUS(iocp->ioctl_cmds.status);\n\tSET_MGMT_MSG_CONTEXT(iocp->ioctl_cmds.msg_context, 0);\n        kfree_sgl(sgl, sgl_dma, buflist, iocp);\n\treturn ret;\n}\n\n \n \nstatic MptSge_t *\nkbuf_alloc_2_sgl(int bytes, u32 sgdir, int sge_offset, int *frags,\n\t\t struct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc)\n{\n\tMptSge_t\t*sglbuf = NULL;\t\t \n\t\t\t\t\t\t \n\tstruct buflist\t*buflist = NULL;\t \n\tMptSge_t\t*sgl;\n\tint\t\t numfrags = 0;\n\tint\t\t fragcnt = 0;\n\tint\t\t alloc_sz = min(bytes,MAX_KMALLOC_SZ);\t\n\tint\t\t bytes_allocd = 0;\n\tint\t\t this_alloc;\n\tdma_addr_t\t pa;\t\t\t\t\t\n\tint\t\t i, buflist_ent;\n\tint\t\t sg_spill = MAX_FRAGS_SPILL1;\n\tint\t\t dir;\n\n\tif (bytes < 0)\n\t\treturn NULL;\n\n\t \n\t*frags = 0;\n\t*blp = NULL;\n\n\t \n\ti = MAX_SGL_BYTES / 8;\n\tbuflist = kzalloc(i, GFP_USER);\n\tif (!buflist)\n\t\treturn NULL;\n\tbuflist_ent = 0;\n\n\t \n\tsglbuf = dma_alloc_coherent(&ioc->pcidev->dev, MAX_SGL_BYTES,\n\t\t\t\t    sglbuf_dma, GFP_KERNEL);\n\tif (sglbuf == NULL)\n\t\tgoto free_and_fail;\n\n\tif (sgdir & 0x04000000)\n\t\tdir = DMA_TO_DEVICE;\n\telse\n\t\tdir = DMA_FROM_DEVICE;\n\n\t \n\tsgl = sglbuf;\n\tsg_spill = ((ioc->req_sz - sge_offset)/ioc->SGE_size) - 1;\n\twhile (bytes_allocd < bytes) {\n\t\tthis_alloc = min(alloc_sz, bytes-bytes_allocd);\n\t\tbuflist[buflist_ent].len = this_alloc;\n\t\tbuflist[buflist_ent].kptr = dma_alloc_coherent(&ioc->pcidev->dev,\n\t\t\t\t\t\t\t       this_alloc,\n\t\t\t\t\t\t\t       &pa, GFP_KERNEL);\n\t\tif (buflist[buflist_ent].kptr == NULL) {\n\t\t\talloc_sz = alloc_sz / 2;\n\t\t\tif (alloc_sz == 0) {\n\t\t\t\tprintk(MYIOC_s_WARN_FMT \"-SG: No can do - \"\n\t\t\t\t    \"not enough memory!   :-(\\n\", ioc->name);\n\t\t\t\tprintk(MYIOC_s_WARN_FMT \"-SG: (freeing %d frags)\\n\",\n\t\t\t\t\tioc->name, numfrags);\n\t\t\t\tgoto free_and_fail;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tdma_addr_t dma_addr;\n\n\t\t\tbytes_allocd += this_alloc;\n\t\t\tsgl->FlagsLength = (0x10000000|sgdir|this_alloc);\n\t\t\tdma_addr = dma_map_single(&ioc->pcidev->dev,\n\t\t\t\t\t\t  buflist[buflist_ent].kptr,\n\t\t\t\t\t\t  this_alloc, dir);\n\t\t\tsgl->Address = dma_addr;\n\n\t\t\tfragcnt++;\n\t\t\tnumfrags++;\n\t\t\tsgl++;\n\t\t\tbuflist_ent++;\n\t\t}\n\n\t\tif (bytes_allocd >= bytes)\n\t\t\tbreak;\n\n\t\t \n\t\tif (fragcnt == sg_spill) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t    \"-SG: No can do - \" \"Chain required!   :-(\\n\", ioc->name);\n\t\t\tprintk(MYIOC_s_WARN_FMT \"(freeing %d frags)\\n\", ioc->name, numfrags);\n\t\t\tgoto free_and_fail;\n\t\t}\n\n\t\t \n\t\tif (numfrags*8 > MAX_SGL_BYTES){\n\t\t\t \n\t\t\tprintk(MYIOC_s_WARN_FMT \"-SG: No can do - \"\n\t\t\t\t\"too many SG frags!   :-(\\n\", ioc->name);\n\t\t\tprintk(MYIOC_s_WARN_FMT \"-SG: (freeing %d frags)\\n\",\n\t\t\t\tioc->name, numfrags);\n\t\t\tgoto free_and_fail;\n\t\t}\n\t}\n\n\t \n\tsgl[-1].FlagsLength |= 0xC1000000;\n\n\t*frags = numfrags;\n\t*blp = buflist;\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"-SG: kbuf_alloc_2_sgl() - \"\n\t   \"%d SG frags generated!\\n\", ioc->name, numfrags));\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"-SG: kbuf_alloc_2_sgl() - \"\n\t   \"last (big) alloc_sz=%d\\n\", ioc->name, alloc_sz));\n\n\treturn sglbuf;\n\nfree_and_fail:\n\tif (sglbuf != NULL) {\n\t\tfor (i = 0; i < numfrags; i++) {\n\t\t\tdma_addr_t dma_addr;\n\t\t\tu8 *kptr;\n\t\t\tint len;\n\n\t\t\tif ((sglbuf[i].FlagsLength >> 24) == 0x30)\n\t\t\t\tcontinue;\n\n\t\t\tdma_addr = sglbuf[i].Address;\n\t\t\tkptr = buflist[i].kptr;\n\t\t\tlen = buflist[i].len;\n\n\t\t\tdma_free_coherent(&ioc->pcidev->dev, len, kptr,\n\t\t\t\t\t  dma_addr);\n\t\t}\n\t\tdma_free_coherent(&ioc->pcidev->dev, MAX_SGL_BYTES, sglbuf,\n\t\t\t\t  *sglbuf_dma);\n\t}\n\tkfree(buflist);\n\treturn NULL;\n}\n\n \n \nstatic void\nkfree_sgl(MptSge_t *sgl, dma_addr_t sgl_dma, struct buflist *buflist, MPT_ADAPTER *ioc)\n{\n\tMptSge_t\t*sg = sgl;\n\tstruct buflist\t*bl = buflist;\n\tu32\t\t nib;\n\tint\t\t dir;\n\tint\t\t n = 0;\n\n\tif (sg->FlagsLength & 0x04000000)\n\t\tdir = DMA_TO_DEVICE;\n\telse\n\t\tdir = DMA_FROM_DEVICE;\n\n\tnib = (sg->FlagsLength & 0xF0000000) >> 28;\n\twhile (! (nib & 0x4)) {  \n\t\t \n\t\tif (nib == 0 || nib == 3) {\n\t\t\t;\n\t\t} else if (sg->Address) {\n\t\t\tdma_addr_t dma_addr;\n\t\t\tvoid *kptr;\n\t\t\tint len;\n\n\t\t\tdma_addr = sg->Address;\n\t\t\tkptr = bl->kptr;\n\t\t\tlen = bl->len;\n\t\t\tdma_unmap_single(&ioc->pcidev->dev, dma_addr, len,\n\t\t\t\t\t dir);\n\t\t\tdma_free_coherent(&ioc->pcidev->dev, len, kptr,\n\t\t\t\t\t  dma_addr);\n\t\t\tn++;\n\t\t}\n\t\tsg++;\n\t\tbl++;\n\t\tnib = (le32_to_cpu(sg->FlagsLength) & 0xF0000000) >> 28;\n\t}\n\n\t \n\tif (sg->Address) {\n\t\tdma_addr_t dma_addr;\n\t\tvoid *kptr;\n\t\tint len;\n\n\t\tdma_addr = sg->Address;\n\t\tkptr = bl->kptr;\n\t\tlen = bl->len;\n\t\tdma_unmap_single(&ioc->pcidev->dev, dma_addr, len, dir);\n\t\tdma_free_coherent(&ioc->pcidev->dev, len, kptr, dma_addr);\n\t\tn++;\n\t}\n\n\tdma_free_coherent(&ioc->pcidev->dev, MAX_SGL_BYTES, sgl, sgl_dma);\n\tkfree(buflist);\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"-SG: Free'd 1 SGL buf + %d kbufs!\\n\",\n\t    ioc->name, n));\n}\n\n \n \nstatic int\nmptctl_getiocinfo (MPT_ADAPTER *ioc, unsigned long arg, unsigned int data_size)\n{\n\tstruct mpt_ioctl_iocinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_iocinfo *karg;\n\tstruct pci_dev\t\t*pdev;\n\tunsigned int\t\tport;\n\tint\t\t\tcim_rev;\n\tstruct scsi_device \t*sdev;\n\tVirtDevice\t\t*vdevice;\n\n\t \n\tif (data_size == sizeof(struct mpt_ioctl_iocinfo_rev0))\n\t\tcim_rev = 0;\n\telse if (data_size == sizeof(struct mpt_ioctl_iocinfo_rev1))\n\t\tcim_rev = 1;\n\telse if (data_size == sizeof(struct mpt_ioctl_iocinfo))\n\t\tcim_rev = 2;\n\telse if (data_size == (sizeof(struct mpt_ioctl_iocinfo_rev0)+12))\n\t\tcim_rev = 0;\t \n\telse\n\t\treturn -EFAULT;\n\n\tkarg = memdup_user(uarg, data_size);\n\tif (IS_ERR(karg)) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mpt_ioctl_iocinfo() - memdup_user returned error [%ld]\\n\",\n\t\t\t\t__FILE__, __LINE__, PTR_ERR(karg));\n\t\treturn PTR_ERR(karg);\n\t}\n\n\t \n\tif (karg->hdr.maxDataSize != data_size) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_getiocinfo - \"\n\t\t\t\"Structure size mismatch. Command not completed.\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\tkfree(karg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_getiocinfo called.\\n\",\n\t    ioc->name));\n\n\t \n\tif (ioc->bus_type == SAS)\n\t\tkarg->adapterType = MPT_IOCTL_INTERFACE_SAS;\n\telse if (ioc->bus_type == FC)\n\t\tkarg->adapterType = MPT_IOCTL_INTERFACE_FC;\n\telse\n\t\tkarg->adapterType = MPT_IOCTL_INTERFACE_SCSI;\n\n\tif (karg->hdr.port > 1) {\n\t\tkfree(karg);\n\t\treturn -EINVAL;\n\t}\n\tport = karg->hdr.port;\n\n\tkarg->port = port;\n\tpdev = (struct pci_dev *) ioc->pcidev;\n\n\tkarg->pciId = pdev->device;\n\tkarg->hwRev = pdev->revision;\n\tkarg->subSystemDevice = pdev->subsystem_device;\n\tkarg->subSystemVendor = pdev->subsystem_vendor;\n\n\tif (cim_rev == 1) {\n\t\t \n\t\tkarg->pciInfo.u.bits.busNumber = pdev->bus->number;\n\t\tkarg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );\n\t\tkarg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );\n\t} else if (cim_rev == 2) {\n\t\t \n\t\tkarg->pciInfo.u.bits.busNumber = pdev->bus->number;\n\t\tkarg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );\n\t\tkarg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );\n\t\tkarg->pciInfo.segmentID = pci_domain_nr(pdev->bus);\n\t}\n\n\t \n\tkarg->numDevices = 0;\n\tif (ioc->sh) {\n\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\tvdevice = sdev->hostdata;\n\t\t\tif (vdevice == NULL || vdevice->vtarget == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (vdevice->vtarget->tflags &\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\t\t\tcontinue;\n\t\t\tkarg->numDevices++;\n\t\t}\n\t}\n\n\t \n\tkarg->FWVersion = ioc->facts.FWVersion.Word;\n\tkarg->BIOSVersion = ioc->biosVersion;\n\n\t \n\tstrncpy (karg->driverVersion, MPT_LINUX_PACKAGE_NAME, MPT_IOCTL_VERSION_LENGTH);\n\tkarg->driverVersion[MPT_IOCTL_VERSION_LENGTH-1]='\\0';\n\n\tkarg->busChangeEvent = 0;\n\tkarg->hostId = ioc->pfacts[port].PortSCSIID;\n\tkarg->rsvd[0] = karg->rsvd[1] = 0;\n\n\t \n\tif (copy_to_user((char __user *)arg, karg, data_size)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_getiocinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_iocinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\tkfree(karg);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(karg);\n\treturn 0;\n}\n\n \n \nstatic int\nmptctl_gettargetinfo (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_targetinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_targetinfo karg;\n\tVirtDevice\t\t*vdevice;\n\tchar\t\t\t*pmem;\n\tint\t\t\t*pdata;\n\tint\t\t\tnumDevices = 0;\n\tint\t\t\tlun;\n\tint\t\t\tmaxWordsLeft;\n\tint\t\t\tnumBytes;\n\tstruct scsi_device \t*sdev;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_targetinfo))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to read in mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_gettargetinfo called.\\n\",\n\t    ioc->name));\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxWordsLeft = numBytes/sizeof(int);\n\n\tif (maxWordsLeft <= 0) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo() - no memory available!\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\n\t \n\tpmem = kzalloc(numBytes, GFP_KERNEL);\n\tif (!pmem) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo() - no memory available!\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\tpdata =  (int *) pmem;\n\n\t \n\tif (ioc->sh){\n\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\tif (!maxWordsLeft)\n\t\t\t\tcontinue;\n\t\t\tvdevice = sdev->hostdata;\n\t\t\tif (vdevice == NULL || vdevice->vtarget == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (vdevice->vtarget->tflags &\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\t\t\tcontinue;\n\t\t\tlun = (vdevice->vtarget->raidVolume) ? 0x80 : vdevice->lun;\n\t\t\t*pdata = (((u8)lun << 16) + (vdevice->vtarget->channel << 8) +\n\t\t\t    (vdevice->vtarget->id ));\n\t\t\tpdata++;\n\t\t\tnumDevices++;\n\t\t\t--maxWordsLeft;\n\t\t}\n\t}\n\tkarg.numDevices = numDevices;\n\n\t \n\tif (copy_to_user((char __user *)arg, &karg,\n\t\t\t\tsizeof(struct mpt_ioctl_targetinfo))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\tkfree(pmem);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (copy_to_user(uarg->targetInfo, pmem, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, pdata);\n\t\tkfree(pmem);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(pmem);\n\n\treturn 0;\n}\n\n \n \nstatic int\nmptctl_readtest (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n\t \n\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;\n#else\n\tkarg.chip_type = ioc->pcidev->device;\n#endif\n\tstrncpy (karg.name, ioc->name, MPT_MAX_NAME);\n\tkarg.name[MPT_MAX_NAME-1]='\\0';\n\tstrncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);\n\tkarg.product[MPT_PRODUCT_LENGTH-1]='\\0';\n\n\t \n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to write out mpt_ioctl_test struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic int\nmptctl_eventquery (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventquery\t karg;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventquery called.\\n\",\n\t    ioc->name));\n\tkarg.eventEntries = MPTCTL_EVENT_LOG_SIZE;\n\tkarg.eventTypes = ioc->eventTypes;\n\n\t \n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nmptctl_eventenable (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventenable\t karg;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventenable - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventenable struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventenable called.\\n\",\n\t    ioc->name));\n\tif (ioc->events == NULL) {\n\t\t \n\t\tint sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);\n\t\tioc->events = kzalloc(sz, GFP_KERNEL);\n\t\tif (!ioc->events) {\n\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t    \": ERROR - Insufficient memory to add adapter!\\n\",\n\t\t\t    ioc->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tioc->alloc_total += sz;\n\n\t\tioc->eventContext = 0;\n        }\n\n\t \n\tioc->eventTypes = karg.eventTypes;\n\n\treturn 0;\n}\n\n \nstatic int\nmptctl_eventreport (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_eventreport __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventreport\t karg;\n\tint\t\t\t numBytes, maxEvents, max;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventreport))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventreport called.\\n\",\n\t    ioc->name));\n\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxEvents = numBytes/sizeof(MPT_IOCTL_EVENTS);\n\n\n\tmax = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents;\n\n\t \n\tif ((max < 1) || !ioc->events)\n\t\treturn -ENODATA;\n\n\t \n\tioc->aen_event_read_flag=0;\n\n\t \n\tnumBytes = max * sizeof(MPT_IOCTL_EVENTS);\n\tif (copy_to_user(uarg->eventData, ioc->events, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, ioc->events);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmptctl_replace_fw (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_replace_fw\t karg;\n\tint\t\t\t newFwSize;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\"Unable to read in mpt_ioctl_replace_fw struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_replace_fw called.\\n\",\n\t    ioc->name));\n\t \n\tif (ioc->cached_fw == NULL)\n\t\treturn 0;\n\n\tmpt_free_fw_memory(ioc);\n\n\t \n\tnewFwSize = ALIGN(karg.newImageSize, 4);\n\n\tmpt_alloc_fw_memory(ioc, newFwSize);\n\tif (ioc->cached_fw == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tif (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\t\"Unable to read in mpt_ioctl_replace_fw image \"\n\t\t\t\t\"@ %p\\n\", ioc->name, __FILE__, __LINE__, uarg);\n\t\tmpt_free_fw_memory(ioc);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tioc->facts.FWImageSize = newFwSize;\n\treturn 0;\n}\n\n \n \nstatic int\nmptctl_mpt_command (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_command __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_command  karg;\n\tint\t\trc;\n\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_mpt_command - \"\n\t\t\t\"Unable to read in mpt_ioctl_command struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\trc = mptctl_do_mpt_command (ioc, karg, &uarg->MF);\n\n\treturn rc;\n}\n\n \n \nstatic int\nmptctl_do_mpt_command (MPT_ADAPTER *ioc, struct mpt_ioctl_command karg, void __user *mfPtr)\n{\n\tMPT_FRAME_HDR\t*mf = NULL;\n\tMPIHeader_t\t*hdr;\n\tchar\t\t*psge;\n\tstruct buflist\tbufIn;\t \n\tstruct buflist\tbufOut;  \n\tdma_addr_t\tdma_addr_in;\n\tdma_addr_t\tdma_addr_out;\n\tint\t\tsgSize = 0;\t \n\tint\t\tflagsLength;\n\tint\t\tsz, rc = 0;\n\tint\t\tmsgContext;\n\tu16\t\treq_idx;\n\tulong \t\ttimeout;\n\tunsigned long\ttimeleft;\n\tstruct scsi_device *sdev;\n\tunsigned long\t flags;\n\tu8\t\t function;\n\n\t \n\tbufIn.kptr = bufOut.kptr = NULL;\n\tbufIn.len = bufOut.len = 0;\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress) {\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\"Busy with diagnostic reset\\n\", __FILE__, __LINE__);\n\t\treturn -EBUSY;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\t \n\tif (karg.maxReplyBytes < 0 ||\n\t    karg.dataInSize < 0 ||\n\t    karg.dataOutSize < 0 ||\n\t    karg.dataSgeOffset < 0 ||\n\t    karg.maxSenseBytes < 0 ||\n\t    karg.dataSgeOffset > ioc->req_sz / 4)\n\t\treturn -EINVAL;\n\n\t \n\tsz = karg.dataSgeOffset * 4;\n\tif (karg.dataInSize > 0)\n\t\tsz += ioc->SGE_size;\n\tif (karg.dataOutSize > 0)\n\t\tsz += ioc->SGE_size;\n\n\tif (sz > ioc->req_sz) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\"Request frame too large (%d) maximum (%d)\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, sz, ioc->req_sz);\n\t\treturn -EFAULT;\n\t}\n\n\t \n        if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL)\n                return -EAGAIN;\n\n\thdr = (MPIHeader_t *) mf;\n\tmsgContext = le32_to_cpu(hdr->MsgContext);\n\treq_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\n\n\t \n\tif (copy_from_user(mf, mfPtr, karg.dataSgeOffset * 4)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\"Unable to read MF from mpt_ioctl_command struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, mfPtr);\n\t\tfunction = -1;\n\t\trc = -EFAULT;\n\t\tgoto done_free_mem;\n\t}\n\thdr->MsgContext = cpu_to_le32(msgContext);\n\tfunction = hdr->Function;\n\n\n\t \n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"sending mpi function (0x%02X), req=%p\\n\",\n\t    ioc->name, hdr->Function, mf));\n\n\tswitch (function) {\n\tcase MPI_FUNCTION_IOC_FACTS:\n\tcase MPI_FUNCTION_PORT_FACTS:\n\t\tkarg.dataOutSize  = karg.dataInSize = 0;\n\t\tbreak;\n\n\tcase MPI_FUNCTION_CONFIG:\n\t{\n\t\tConfig_t *config_frame;\n\t\tconfig_frame = (Config_t *)mf;\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"\\ttype=0x%02x ext_type=0x%02x \"\n\t\t    \"number=0x%02x action=0x%02x\\n\", ioc->name,\n\t\t    config_frame->Header.PageType,\n\t\t    config_frame->ExtPageType,\n\t\t    config_frame->Header.PageNumber,\n\t\t    config_frame->Action));\n\t\tbreak;\n\t}\n\n\tcase MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND:\n\tcase MPI_FUNCTION_FC_EX_LINK_SRVC_SEND:\n\tcase MPI_FUNCTION_FW_UPLOAD:\n\tcase MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:\n\tcase MPI_FUNCTION_FW_DOWNLOAD:\n\tcase MPI_FUNCTION_FC_PRIMITIVE_SEND:\n\tcase MPI_FUNCTION_TOOLBOX:\n\tcase MPI_FUNCTION_SAS_IO_UNIT_CONTROL:\n\t\tbreak;\n\n\tcase MPI_FUNCTION_SCSI_IO_REQUEST:\n\t\tif (ioc->sh) {\n\t\t\tSCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;\n\t\t\tint qtag = MPI_SCSIIO_CONTROL_UNTAGGED;\n\t\t\tint scsidir = 0;\n\t\t\tint dataSize;\n\t\t\tu32 id;\n\n\t\t\tid = (ioc->devices_per_bus == 0) ? 256 : ioc->devices_per_bus;\n\t\t\tif (pScsiReq->TargetID > id) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\t\"Target ID out of bounds. \\n\",\n\t\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\t\trc = -ENODEV;\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\n\t\t\tif (pScsiReq->Bus >= ioc->number_of_buses) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\t\"Target Bus out of bounds. \\n\",\n\t\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\t\trc = -ENODEV;\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\n\t\t\tpScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;\n\t\t\tpScsiReq->MsgFlags |= mpt_msg_flags(ioc);\n\n\n\t\t\t \n\t\t\tif (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)\n\t\t\t\tpScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;\n\t\t\telse\n\t\t\t\tpScsiReq->SenseBufferLength = karg.maxSenseBytes;\n\n\t\t\tpScsiReq->SenseBufferLowAddr =\n\t\t\t\tcpu_to_le32(ioc->sense_buf_low_dma\n\t\t\t\t   + (req_idx * MPT_SENSE_BUFFER_ALLOC));\n\n\t\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\t\tstruct scsi_target *starget = scsi_target(sdev);\n\t\t\t\tVirtTarget *vtarget = starget->hostdata;\n\n\t\t\t\tif (vtarget == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ((pScsiReq->TargetID == vtarget->id) &&\n\t\t\t\t    (pScsiReq->Bus == vtarget->channel) &&\n\t\t\t\t    (vtarget->tflags & MPT_TARGET_FLAGS_Q_YES))\n\t\t\t\t\tqtag = MPI_SCSIIO_CONTROL_SIMPLEQ;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (karg.dataOutSize > 0) {\n\t\t\t\tscsidir = MPI_SCSIIO_CONTROL_WRITE;\n\t\t\t\tdataSize = karg.dataOutSize;\n\t\t\t} else {\n\t\t\t\tscsidir = MPI_SCSIIO_CONTROL_READ;\n\t\t\t\tdataSize = karg.dataInSize;\n\t\t\t}\n\n\t\t\tpScsiReq->Control = cpu_to_le32(scsidir | qtag);\n\t\t\tpScsiReq->DataLength = cpu_to_le32(dataSize);\n\n\n\t\t} else {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"SCSI driver is not loaded. \\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\trc = -EFAULT;\n\t\t\tgoto done_free_mem;\n\t\t}\n\t\tbreak;\n\n\tcase MPI_FUNCTION_SMP_PASSTHROUGH:\n\t\t \n\t\tbreak;\n\n\tcase MPI_FUNCTION_SATA_PASSTHROUGH:\n\t\tif (!ioc->sh) {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"SCSI driver is not loaded. \\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\trc = -EFAULT;\n\t\t\tgoto done_free_mem;\n\t\t}\n\t\tbreak;\n\n\tcase MPI_FUNCTION_RAID_ACTION:\n\t\t \n\t\tbreak;\n\n\tcase MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:\n\t\tif (ioc->sh) {\n\t\t\tSCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;\n\t\t\tint qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;\n\t\t\tint scsidir = MPI_SCSIIO_CONTROL_READ;\n\t\t\tint dataSize;\n\n\t\t\tpScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;\n\t\t\tpScsiReq->MsgFlags |= mpt_msg_flags(ioc);\n\n\n\t\t\t \n\t\t\tif (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)\n\t\t\t\tpScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;\n\t\t\telse\n\t\t\t\tpScsiReq->SenseBufferLength = karg.maxSenseBytes;\n\n\t\t\tpScsiReq->SenseBufferLowAddr =\n\t\t\t\tcpu_to_le32(ioc->sense_buf_low_dma\n\t\t\t\t   + (req_idx * MPT_SENSE_BUFFER_ALLOC));\n\n\t\t\t \n\n\t\t\t \n\t\t\tif (karg.dataOutSize > 0) {\n\t\t\t\tscsidir = MPI_SCSIIO_CONTROL_WRITE;\n\t\t\t\tdataSize = karg.dataOutSize;\n\t\t\t} else {\n\t\t\t\tscsidir = MPI_SCSIIO_CONTROL_READ;\n\t\t\t\tdataSize = karg.dataInSize;\n\t\t\t}\n\n\t\t\tpScsiReq->Control = cpu_to_le32(scsidir | qtag);\n\t\t\tpScsiReq->DataLength = cpu_to_le32(dataSize);\n\n\t\t} else {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"SCSI driver is not loaded. \\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\trc = -EFAULT;\n\t\t\tgoto done_free_mem;\n\t\t}\n\t\tbreak;\n\n\tcase MPI_FUNCTION_SCSI_TASK_MGMT:\n\t{\n\t\tSCSITaskMgmt_t\t*pScsiTm;\n\t\tpScsiTm = (SCSITaskMgmt_t *)mf;\n\t\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"\\tTaskType=0x%x MsgFlags=0x%x \"\n\t\t\t\"TaskMsgContext=0x%x id=%d channel=%d\\n\",\n\t\t\tioc->name, pScsiTm->TaskType, le32_to_cpu\n\t\t\t(pScsiTm->TaskMsgContext), pScsiTm->MsgFlags,\n\t\t\tpScsiTm->TargetID, pScsiTm->Bus));\n\t\tbreak;\n\t}\n\n\tcase MPI_FUNCTION_IOC_INIT:\n\t\t{\n\t\t\tIOCInit_t\t*pInit = (IOCInit_t *) mf;\n\t\t\tu32\t\thigh_addr, sense_high;\n\n\t\t\t \n\t\t\tif (sizeof(dma_addr_t) == sizeof(u64)) {\n\t\t\t\thigh_addr = cpu_to_le32((u32)((u64)ioc->req_frames_dma >> 32));\n\t\t\t\tsense_high= cpu_to_le32((u32)((u64)ioc->sense_buf_pool_dma >> 32));\n\t\t\t} else {\n\t\t\t\thigh_addr = 0;\n\t\t\t\tsense_high= 0;\n\t\t\t}\n\n\t\t\tif ((pInit->Flags != 0) || (pInit->MaxDevices != ioc->facts.MaxDevices) ||\n\t\t\t\t(pInit->MaxBuses != ioc->facts.MaxBuses) ||\n\t\t\t\t(pInit->ReplyFrameSize != cpu_to_le16(ioc->reply_sz)) ||\n\t\t\t\t(pInit->HostMfaHighAddr != high_addr) ||\n\t\t\t\t(pInit->SenseBufferHighAddr != sense_high)) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\t\"IOC_INIT issued with 1 or more incorrect parameters. Rejected.\\n\",\n\t\t\t\t\tioc->name, __FILE__, __LINE__);\n\t\t\t\trc = -EFAULT;\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\n\t\t \n\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\"Illegal request (function 0x%x) \\n\",\n\t\t\tioc->name, __FILE__, __LINE__, hdr->Function);\n\t\trc = -EFAULT;\n\t\tgoto done_free_mem;\n\t}\n\n\t \n\tpsge = (char *) (((int *) mf) + karg.dataSgeOffset);\n\tflagsLength = 0;\n\n\tif (karg.dataOutSize > 0)\n\t\tsgSize ++;\n\n\tif (karg.dataInSize > 0)\n\t\tsgSize ++;\n\n\tif (sgSize > 0) {\n\n\t\t \n\t\tif (karg.dataOutSize > 0) {\n\t\t\tif (karg.dataInSize > 0) {\n\t\t\t\tflagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t\t\t\t\tMPI_SGE_FLAGS_END_OF_BUFFER |\n\t\t\t\t\t\tMPI_SGE_FLAGS_DIRECTION)\n\t\t\t\t\t\t<< MPI_SGE_FLAGS_SHIFT;\n\t\t\t} else {\n\t\t\t\tflagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;\n\t\t\t}\n\t\t\tflagsLength |= karg.dataOutSize;\n\t\t\tbufOut.len = karg.dataOutSize;\n\t\t\tbufOut.kptr = dma_alloc_coherent(&ioc->pcidev->dev,\n\t\t\t\t\t\t\t bufOut.len,\n\t\t\t\t\t\t\t &dma_addr_out, GFP_KERNEL);\n\n\t\t\tif (bufOut.kptr == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto done_free_mem;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tioc->add_sge(psge, flagsLength, dma_addr_out);\n\t\t\t\tpsge += ioc->SGE_size;\n\n\t\t\t\t \n\t\t\t\tif (copy_from_user(bufOut.kptr,\n\t\t\t\t\t\tkarg.dataOutBufPtr,\n\t\t\t\t\t\tbufOut.len)) {\n\t\t\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t\t\t\t\"%s@%d::mptctl_do_mpt_command - Unable \"\n\t\t\t\t\t\t\"to read user data \"\n\t\t\t\t\t\t\"struct @ %p\\n\",\n\t\t\t\t\t\tioc->name, __FILE__, __LINE__,karg.dataOutBufPtr);\n\t\t\t\t\trc =  -EFAULT;\n\t\t\t\t\tgoto done_free_mem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (karg.dataInSize > 0) {\n\t\t\tflagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;\n\t\t\tflagsLength |= karg.dataInSize;\n\n\t\t\tbufIn.len = karg.dataInSize;\n\t\t\tbufIn.kptr = dma_alloc_coherent(&ioc->pcidev->dev,\n\t\t\t\t\t\t\tbufIn.len,\n\t\t\t\t\t\t\t&dma_addr_in, GFP_KERNEL);\n\n\t\t\tif (bufIn.kptr == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto done_free_mem;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tioc->add_sge(psge, flagsLength, dma_addr_in);\n\t\t\t}\n\t\t}\n\t} else  {\n\t\t \n\t\tioc->add_sge(psge, flagsLength, (dma_addr_t) -1);\n\t}\n\n\tSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, hdr->MsgContext);\n\tINITIALIZE_MGMT_STATUS(ioc->ioctl_cmds.status)\n\tif (hdr->Function == MPI_FUNCTION_SCSI_TASK_MGMT) {\n\n\t\tmutex_lock(&ioc->taskmgmt_cmds.mutex);\n\t\tif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {\n\t\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\t\tgoto done_free_mem;\n\t\t}\n\n\t\tDBG_DUMP_TM_REQUEST_FRAME(ioc, (u32 *)mf);\n\n\t\tif ((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q) &&\n\t\t    (ioc->facts.MsgVersion >= MPI_VERSION_01_05))\n\t\t\tmpt_put_msg_frame_hi_pri(mptctl_id, ioc, mf);\n\t\telse {\n\t\t\trc =mpt_send_handshake_request(mptctl_id, ioc,\n\t\t\t\tsizeof(SCSITaskMgmt_t), (u32*)mf, CAN_SLEEP);\n\t\t\tif (rc != 0) {\n\t\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t    \"send_handshake FAILED! (ioc %p, mf %p)\\n\",\n\t\t\t\t    ioc->name, ioc, mf));\n\t\t\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\t\t\trc = -ENODATA;\n\t\t\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\t\t}\n\n\t} else\n\t\tmpt_put_msg_frame(mptctl_id, ioc, mf);\n\n\t \n\ttimeout = (karg.timeout > 0) ? karg.timeout : MPT_IOCTL_DEFAULT_TIMEOUT;\nretry_wait:\n\ttimeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done,\n\t\t\t\tHZ*timeout);\n\tif (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\trc = -ETIME;\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT \"%s: TIMED OUT!\\n\",\n\t\t    ioc->name, __func__));\n\t\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\n\t\t\tif (function == MPI_FUNCTION_SCSI_TASK_MGMT)\n\t\t\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\t\tgoto done_free_mem;\n\t\t}\n\t\tif (!timeleft) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t       \"mpt cmd timeout, doorbell=0x%08x\"\n\t\t\t       \" function=0x%x\\n\",\n\t\t\t       ioc->name, mpt_GetIocState(ioc, 0), function);\n\t\t\tif (function == MPI_FUNCTION_SCSI_TASK_MGMT)\n\t\t\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\t\tmptctl_timeout_expired(ioc, mf);\n\t\t\tmf = NULL;\n\t\t} else\n\t\t\tgoto retry_wait;\n\t\tgoto done_free_mem;\n\t}\n\n\tif (function == MPI_FUNCTION_SCSI_TASK_MGMT)\n\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\n\n\tmf = NULL;\n\n\t \n\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) {\n\t\tif (karg.maxReplyBytes < ioc->reply_sz) {\n\t\t\tsz = min(karg.maxReplyBytes,\n\t\t\t\t4*ioc->ioctl_cmds.reply[2]);\n\t\t} else {\n\t\t\t sz = min(ioc->reply_sz, 4*ioc->ioctl_cmds.reply[2]);\n\t\t}\n\t\tif (sz > 0) {\n\t\t\tif (copy_to_user(karg.replyFrameBufPtr,\n\t\t\t\t ioc->ioctl_cmds.reply, sz)){\n\t\t\t\t printk(MYIOC_s_ERR_FMT\n\t\t\t\t     \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t \"Unable to write out reply frame %p\\n\",\n\t\t\t\t ioc->name, __FILE__, __LINE__, karg.replyFrameBufPtr);\n\t\t\t\t rc =  -ENODATA;\n\t\t\t\t goto done_free_mem;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_SENSE_VALID) {\n\t\tsz = min(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);\n\t\tif (sz > 0) {\n\t\t\tif (copy_to_user(karg.senseDataPtr,\n\t\t\t\tioc->ioctl_cmds.sense, sz)) {\n\t\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"Unable to write sense data to user %p\\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__,\n\t\t\t\tkarg.senseDataPtr);\n\t\t\t\trc =  -ENODATA;\n\t\t\t\tgoto done_free_mem;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD) &&\n\t\t\t\t(karg.dataInSize > 0) && (bufIn.kptr)) {\n\n\t\tif (copy_to_user(karg.dataInBufPtr,\n\t\t\t\t bufIn.kptr, karg.dataInSize)) {\n\t\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_mpt_command - \"\n\t\t\t\t\"Unable to write data to user %p\\n\",\n\t\t\t\tioc->name, __FILE__, __LINE__,\n\t\t\t\tkarg.dataInBufPtr);\n\t\t\trc =  -ENODATA;\n\t\t}\n\t}\n\ndone_free_mem:\n\n\tCLEAR_MGMT_STATUS(ioc->ioctl_cmds.status)\n\tSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, 0);\n\n\t \n\tif (bufOut.kptr != NULL) {\n\t\tdma_free_coherent(&ioc->pcidev->dev, bufOut.len,\n\t\t\t\t  (void *)bufOut.kptr, dma_addr_out);\n\t}\n\n\tif (bufIn.kptr != NULL) {\n\t\tdma_free_coherent(&ioc->pcidev->dev, bufIn.len,\n\t\t\t\t  (void *)bufIn.kptr, dma_addr_in);\n\t}\n\n\t \n\tif (mf)\n\t\tmpt_free_msg_frame(ioc, mf);\n\n\treturn rc;\n}\n\n \n \nstatic int\nmptctl_hp_hostinfo(MPT_ADAPTER *ioc, unsigned long arg, unsigned int data_size)\n{\n\thp_host_info_t\t__user *uarg = (void __user *) arg;\n\tstruct pci_dev\t\t*pdev;\n\tchar                    *pbuf=NULL;\n\tdma_addr_t\t\tbuf_dma;\n\thp_host_info_t\t\tkarg;\n\tCONFIGPARMS\t\tcfg;\n\tConfigPageHeader_t\thdr;\n\tint\t\t\trc, cim_rev;\n\tToolboxIstwiReadWriteRequest_t\t*IstwiRWRequest;\n\tMPT_FRAME_HDR\t\t*mf = NULL;\n\tunsigned long\t\ttimeleft;\n\tu32\t\t\tmsgcontext;\n\n\t \n\tif (data_size == sizeof(hp_host_info_t))\n\t\tcim_rev = 1;\n\telse if (data_size == sizeof(hp_host_info_rev0_t))\n\t\tcim_rev = 0;\t \n\telse\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&karg, uarg, sizeof(hp_host_info_t))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_hp_host_info - \"\n\t\t\t\"Unable to read in hp_host_info struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \": mptctl_hp_hostinfo called.\\n\",\n\t    ioc->name));\n\n\t \n\tpdev = (struct pci_dev *) ioc->pcidev;\n\n\tkarg.vendor = pdev->vendor;\n\tkarg.device = pdev->device;\n\tkarg.subsystem_id = pdev->subsystem_device;\n\tkarg.subsystem_vendor = pdev->subsystem_vendor;\n\tkarg.devfn = pdev->devfn;\n\tkarg.bus = pdev->bus->number;\n\n\t \n\tif (ioc->sh != NULL)\n\t\tkarg.host_no = ioc->sh->host_no;\n\telse\n\t\tkarg.host_no =  -1;\n\n\t \n\tsnprintf(karg.fw_version, sizeof(karg.fw_version),\n\t\t \"%.2hhu.%.2hhu.%.2hhu.%.2hhu\",\n\t\t ioc->facts.FWVersion.Struct.Major,\n\t\t ioc->facts.FWVersion.Struct.Minor,\n\t\t ioc->facts.FWVersion.Struct.Unit,\n\t\t ioc->facts.FWVersion.Struct.Dev);\n\n\t \n\thdr.PageVersion = 0;\n\thdr.PageLength = 0;\n\thdr.PageNumber = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = 0;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\t \n\tcfg.timeout = 10;\n\n\tstrncpy(karg.serial_number, \" \", 24);\n\tif (mpt_config(ioc, &cfg) == 0) {\n\t\tif (cfg.cfghdr.hdr->PageLength > 0) {\n\t\t\t \n\t\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\t\t\tpbuf = dma_alloc_coherent(&ioc->pcidev->dev,\n\t\t\t\t\t\t  hdr.PageLength * 4,\n\t\t\t\t\t\t  &buf_dma, GFP_KERNEL);\n\t\t\tif (pbuf) {\n\t\t\t\tcfg.physAddr = buf_dma;\n\t\t\t\tif (mpt_config(ioc, &cfg) == 0) {\n\t\t\t\t\tManufacturingPage0_t *pdata = (ManufacturingPage0_t *) pbuf;\n\t\t\t\t\tif (strlen(pdata->BoardTracerNumber) > 1) {\n\t\t\t\t\t\tstrscpy(karg.serial_number,\n\t\t\t\t\t\t\tpdata->BoardTracerNumber, 24);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdma_free_coherent(&ioc->pcidev->dev,\n\t\t\t\t\t\t  hdr.PageLength * 4, pbuf,\n\t\t\t\t\t\t  buf_dma);\n\t\t\t\tpbuf = NULL;\n\t\t\t}\n\t\t}\n\t}\n\trc = mpt_GetIocState(ioc, 1);\n\tswitch (rc) {\n\tcase MPI_IOC_STATE_OPERATIONAL:\n\t\tkarg.ioc_status =  HP_STATUS_OK;\n\t\tbreak;\n\n\tcase MPI_IOC_STATE_FAULT:\n\t\tkarg.ioc_status =  HP_STATUS_FAILED;\n\t\tbreak;\n\n\tcase MPI_IOC_STATE_RESET:\n\tcase MPI_IOC_STATE_READY:\n\tdefault:\n\t\tkarg.ioc_status =  HP_STATUS_OTHER;\n\t\tbreak;\n\t}\n\n\tkarg.base_io_addr = pci_resource_start(pdev, 0);\n\n\tif ((ioc->bus_type == SAS) || (ioc->bus_type == FC))\n\t\tkarg.bus_phys_width = HP_BUS_WIDTH_UNK;\n\telse\n\t\tkarg.bus_phys_width = HP_BUS_WIDTH_16;\n\n\tkarg.hard_resets = 0;\n\tkarg.soft_resets = 0;\n\tkarg.timeouts = 0;\n\tif (ioc->sh != NULL) {\n\t\tMPT_SCSI_HOST *hd =  shost_priv(ioc->sh);\n\n\t\tif (hd && (cim_rev == 1)) {\n\t\t\tkarg.hard_resets = ioc->hard_resets;\n\t\t\tkarg.soft_resets = ioc->soft_resets;\n\t\t\tkarg.timeouts = ioc->timeouts;\n\t\t}\n\t}\n\n\t \n\tif ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_WARN_FMT\n\t\t\t\"%s, no msg frames!!\\n\", ioc->name, __func__));\n\t\tgoto out;\n\t}\n\n\tIstwiRWRequest = (ToolboxIstwiReadWriteRequest_t *)mf;\n\tmsgcontext = IstwiRWRequest->MsgContext;\n\tmemset(IstwiRWRequest,0,sizeof(ToolboxIstwiReadWriteRequest_t));\n\tIstwiRWRequest->MsgContext = msgcontext;\n\tIstwiRWRequest->Function = MPI_FUNCTION_TOOLBOX;\n\tIstwiRWRequest->Tool = MPI_TOOLBOX_ISTWI_READ_WRITE_TOOL;\n\tIstwiRWRequest->Flags = MPI_TB_ISTWI_FLAGS_READ;\n\tIstwiRWRequest->NumAddressBytes = 0x01;\n\tIstwiRWRequest->DataLength = cpu_to_le16(0x04);\n\tif (pdev->devfn & 1)\n\t\tIstwiRWRequest->DeviceAddr = 0xB2;\n\telse\n\t\tIstwiRWRequest->DeviceAddr = 0xB0;\n\n\tpbuf = dma_alloc_coherent(&ioc->pcidev->dev, 4, &buf_dma, GFP_KERNEL);\n\tif (!pbuf)\n\t\tgoto out;\n\tioc->add_sge((char *)&IstwiRWRequest->SGL,\n\t    (MPT_SGE_FLAGS_SSIMPLE_READ|4), buf_dma);\n\n\tSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context,\n\t\t\t\tIstwiRWRequest->MsgContext);\n\tINITIALIZE_MGMT_STATUS(ioc->ioctl_cmds.status)\n\tmpt_put_msg_frame(mptctl_id, ioc, mf);\n\nretry_wait:\n\ttimeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done,\n\t\t\tHZ*MPT_IOCTL_DEFAULT_TIMEOUT);\n\tif (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: failed\\n\", ioc->name, __func__);\n\t\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\n\t\t\tmpt_free_msg_frame(ioc, mf);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!timeleft) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t       \"HOST INFO command timeout, doorbell=0x%08x\\n\",\n\t\t\t       ioc->name, mpt_GetIocState(ioc, 0));\n\t\t\tmptctl_timeout_expired(ioc, mf);\n\t\t} else\n\t\t\tgoto retry_wait;\n\t\tgoto out;\n\t}\n\n\t \n\tif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID)\n\t\tkarg.rsvd = *(u32 *)pbuf;\n\n out:\n\tCLEAR_MGMT_STATUS(ioc->ioctl_cmds.status)\n\tSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, 0);\n\n\tif (pbuf)\n\t\tdma_free_coherent(&ioc->pcidev->dev, 4, pbuf, buf_dma);\n\n\t \n\tif (copy_to_user((char __user *)arg, &karg, sizeof(hp_host_info_t))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_hpgethostinfo - \"\n\t\t\t\"Unable to write out hp_host_info @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n\n}\n\n \n \nstatic int\nmptctl_hp_targetinfo(MPT_ADAPTER *ioc, unsigned long arg)\n{\n\thp_target_info_t __user *uarg = (void __user *) arg;\n\tSCSIDevicePage0_t\t*pg0_alloc;\n\tSCSIDevicePage3_t\t*pg3_alloc;\n\tMPT_SCSI_HOST \t\t*hd = NULL;\n\thp_target_info_t\tkarg;\n\tint\t\t\tdata_sz;\n\tdma_addr_t\t\tpage_dma;\n\tCONFIGPARMS\t \tcfg;\n\tConfigPageHeader_t\thdr;\n\tint\t\t\ttmp, np, rc = 0;\n\n\tif (copy_from_user(&karg, uarg, sizeof(hp_target_info_t))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_hp_targetinfo - \"\n\t\t\t\"Unable to read in hp_host_targetinfo struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (karg.hdr.id >= MPT_MAX_FC_DEVICES)\n\t\treturn -EINVAL;\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_hp_targetinfo called.\\n\",\n\t    ioc->name));\n\n\t \n\tif ((ioc->bus_type == SAS) || (ioc->bus_type == FC))\n\t\treturn 0;\n\n\tif ((ioc->spi_data.sdp0length == 0) || (ioc->sh == NULL))\n\t\treturn 0;\n\n\tif (ioc->sh->host_no != karg.hdr.host)\n\t\treturn -ENODEV;\n\n        \n\tdata_sz = ioc->spi_data.sdp0length * 4;\n\tpg0_alloc = dma_alloc_coherent(&ioc->pcidev->dev, data_sz, &page_dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (pg0_alloc) {\n\t\thdr.PageVersion = ioc->spi_data.sdp0version;\n\t\thdr.PageLength = data_sz;\n\t\thdr.PageNumber = 0;\n\t\thdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\n\n\t\tcfg.cfghdr.hdr = &hdr;\n\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\t\tcfg.dir = 0;\n\t\tcfg.timeout = 0;\n\t\tcfg.physAddr = page_dma;\n\n\t\tcfg.pageAddr = (karg.hdr.channel << 8) | karg.hdr.id;\n\n\t\tif ((rc = mpt_config(ioc, &cfg)) == 0) {\n\t\t\tnp = le32_to_cpu(pg0_alloc->NegotiatedParameters);\n\t\t\tkarg.negotiated_width = np & MPI_SCSIDEVPAGE0_NP_WIDE ?\n\t\t\t\t\tHP_BUS_WIDTH_16 : HP_BUS_WIDTH_8;\n\n\t\t\tif (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK) {\n\t\t\t\ttmp = (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK) >> 8;\n\t\t\t\tif (tmp < 0x09)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ULTRA320;\n\t\t\t\telse if (tmp <= 0x09)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ULTRA160;\n\t\t\t\telse if (tmp <= 0x0A)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ULTRA2;\n\t\t\t\telse if (tmp <= 0x0C)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ULTRA;\n\t\t\t\telse if (tmp <= 0x25)\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_FAST;\n\t\t\t\telse\n\t\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ASYNC;\n\t\t\t} else\n\t\t\t\tkarg.negotiated_speed = HP_DEV_SPEED_ASYNC;\n\t\t}\n\n\t\tdma_free_coherent(&ioc->pcidev->dev, data_sz, (u8 *)pg0_alloc,\n\t\t\t\t  page_dma);\n\t}\n\n\t \n\tkarg.message_rejects = -1;\n\tkarg.phase_errors = -1;\n\tkarg.parity_errors = -1;\n\tkarg.select_timeouts = -1;\n\n\t \n\thdr.PageVersion = 0;\n\thdr.PageLength = 0;\n\thdr.PageNumber = 3;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\n\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\n\tcfg.timeout = 0;\n\tcfg.physAddr = -1;\n\tif ((mpt_config(ioc, &cfg) == 0) && (cfg.cfghdr.hdr->PageLength > 0)) {\n\t\t \n\t\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\t\tdata_sz = (int) cfg.cfghdr.hdr->PageLength * 4;\n\t\tpg3_alloc = dma_alloc_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t\t       &page_dma, GFP_KERNEL);\n\t\tif (pg3_alloc) {\n\t\t\tcfg.physAddr = page_dma;\n\t\t\tcfg.pageAddr = (karg.hdr.channel << 8) | karg.hdr.id;\n\t\t\tif ((rc = mpt_config(ioc, &cfg)) == 0) {\n\t\t\t\tkarg.message_rejects = (u32) le16_to_cpu(pg3_alloc->MsgRejectCount);\n\t\t\t\tkarg.phase_errors = (u32) le16_to_cpu(pg3_alloc->PhaseErrorCount);\n\t\t\t\tkarg.parity_errors = (u32) le16_to_cpu(pg3_alloc->ParityErrorCount);\n\t\t\t}\n\t\t\tdma_free_coherent(&ioc->pcidev->dev, data_sz,\n\t\t\t\t\t  (u8 *)pg3_alloc, page_dma);\n\t\t}\n\t}\n\thd = shost_priv(ioc->sh);\n\tif (hd != NULL)\n\t\tkarg.select_timeouts = hd->sel_timeout[karg.hdr.id];\n\n\t \n\tif (copy_to_user((char __user *)arg, &karg, sizeof(hp_target_info_t))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_hp_target_info - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct file_operations mptctl_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.fasync = \tmptctl_fasync,\n\t.unlocked_ioctl = mptctl_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = compat_mpctl_ioctl,\n#endif\n};\n\nstatic struct miscdevice mptctl_miscdev = {\n\tMPT_MINOR,\n\tMYNAM,\n\t&mptctl_fops\n};\n\n \n\n#ifdef CONFIG_COMPAT\n\nstatic int\ncompat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_fw_xfer32 kfw32;\n\tstruct mpt_fw_xfer kfw;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\n\n\tif (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))\n\t\treturn -EFAULT;\n\n\t \n\tiocnumX = kfw32.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mptfwxfer_ioctl @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\\n\",\n\t    iocp->name));\n\tkfw.iocnum = iocnum;\n\tkfw.fwlen = kfw32.fwlen;\n\tkfw.bufp = compat_ptr(kfw32.bufp);\n\n\tret = mptctl_do_fw_download(iocp, kfw.bufp, kfw.fwlen);\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}\n\nstatic int\ncompat_mpt_command(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_ioctl_command32 karg32;\n\tstruct mpt_ioctl_command32 __user *uarg = (struct mpt_ioctl_command32 __user *) arg;\n\tstruct mpt_ioctl_command karg;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\n\tif (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32)))\n\t\treturn -EFAULT;\n\n\t \n\tiocnumX = karg32.hdr.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mpt_command @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mpt_command() called\\n\",\n\t    iocp->name));\n\t \n\tkarg.hdr.iocnum = karg32.hdr.iocnum;\n\tkarg.hdr.port = karg32.hdr.port;\n\tkarg.timeout = karg32.timeout;\n\tkarg.maxReplyBytes = karg32.maxReplyBytes;\n\n\tkarg.dataInSize = karg32.dataInSize;\n\tkarg.dataOutSize = karg32.dataOutSize;\n\tkarg.maxSenseBytes = karg32.maxSenseBytes;\n\tkarg.dataSgeOffset = karg32.dataSgeOffset;\n\n\tkarg.replyFrameBufPtr = (char __user *)(unsigned long)karg32.replyFrameBufPtr;\n\tkarg.dataInBufPtr = (char __user *)(unsigned long)karg32.dataInBufPtr;\n\tkarg.dataOutBufPtr = (char __user *)(unsigned long)karg32.dataOutBufPtr;\n\tkarg.senseDataPtr = (char __user *)(unsigned long)karg32.senseDataPtr;\n\n\t \n\tret = mptctl_do_mpt_command (iocp, karg, &uarg->MF);\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}\n\nstatic long compat_mpctl_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\tmutex_lock(&mpctl_mutex);\n\tswitch (cmd) {\n\tcase MPTIOCINFO:\n\tcase MPTIOCINFO1:\n\tcase MPTIOCINFO2:\n\tcase MPTTARGETINFO:\n\tcase MPTEVENTQUERY:\n\tcase MPTEVENTENABLE:\n\tcase MPTEVENTREPORT:\n\tcase MPTHARDRESET:\n\tcase HP_GETHOSTINFO:\n\tcase HP_GETTARGETINFO:\n\tcase MPTTEST:\n\t\tret = __mptctl_ioctl(f, cmd, arg);\n\t\tbreak;\n\tcase MPTCOMMAND32:\n\t\tret = compat_mpt_command(f, cmd, arg);\n\t\tbreak;\n\tcase MPTFWDOWNLOAD32:\n\t\tret = compat_mptfwxfer_ioctl(f, cmd, arg);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mpctl_mutex);\n\treturn ret;\n}\n\n#endif\n\n\n \n \n\nstatic int\nmptctl_probe(struct pci_dev *pdev)\n{\n\tMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\n\n\tmutex_init(&ioc->ioctl_cmds.mutex);\n\tinit_completion(&ioc->ioctl_cmds.done);\n\treturn 0;\n}\n\n \n \nstatic void\nmptctl_remove(struct pci_dev *pdev)\n{\n}\n\nstatic struct mpt_pci_driver mptctl_driver = {\n  .probe\t\t= mptctl_probe,\n  .remove\t\t= mptctl_remove,\n};\n\n \nstatic int __init mptctl_init(void)\n{\n\tint err;\n\n\tshow_mptmod_ver(my_NAME, my_VERSION);\n\n\tmpt_device_driver_register(&mptctl_driver, MPTCTL_DRIVER);\n\n\t \n\terr = misc_register(&mptctl_miscdev);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR MYNAM \": Can't register misc device [minor=%d].\\n\", MPT_MINOR);\n\t\tgoto out_fail;\n\t}\n\tprintk(KERN_INFO MYNAM \": Registered with Fusion MPT base driver\\n\");\n\tprintk(KERN_INFO MYNAM \": /dev/%s @ (major,minor=%d,%d)\\n\",\n\t\t\t mptctl_miscdev.name, MISC_MAJOR, mptctl_miscdev.minor);\n\n\t \n\tmptctl_id = mpt_register(mptctl_reply, MPTCTL_DRIVER,\n\t    \"mptctl_reply\");\n\tif (!mptctl_id || mptctl_id >= MPT_MAX_PROTOCOL_DRIVERS) {\n\t\tprintk(KERN_ERR MYNAM \": ERROR: Failed to register with Fusion MPT base driver\\n\");\n\t\tmisc_deregister(&mptctl_miscdev);\n\t\terr = -EBUSY;\n\t\tgoto out_fail;\n\t}\n\n\tmptctl_taskmgmt_id = mpt_register(mptctl_taskmgmt_reply, MPTCTL_DRIVER,\n\t    \"mptctl_taskmgmt_reply\");\n\tif (!mptctl_taskmgmt_id || mptctl_taskmgmt_id >= MPT_MAX_PROTOCOL_DRIVERS) {\n\t\tprintk(KERN_ERR MYNAM \": ERROR: Failed to register with Fusion MPT base driver\\n\");\n\t\tmpt_deregister(mptctl_id);\n\t\tmisc_deregister(&mptctl_miscdev);\n\t\terr = -EBUSY;\n\t\tgoto out_fail;\n\t}\n\n\tmpt_reset_register(mptctl_id, mptctl_ioc_reset);\n\tmpt_event_register(mptctl_id, mptctl_event_process);\n\n\treturn 0;\n\nout_fail:\n\n\tmpt_device_driver_deregister(MPTCTL_DRIVER);\n\n\treturn err;\n}\n\n \nstatic void mptctl_exit(void)\n{\n\tmisc_deregister(&mptctl_miscdev);\n\tprintk(KERN_INFO MYNAM \": Deregistered /dev/%s @ (major,minor=%d,%d)\\n\",\n\t\t\t mptctl_miscdev.name, MISC_MAJOR, mptctl_miscdev.minor);\n\n\t \n\tmpt_event_deregister(mptctl_id);\n\n\t \n\tmpt_reset_deregister(mptctl_id);\n\n\t \n\tmpt_deregister(mptctl_taskmgmt_id);\n\tmpt_deregister(mptctl_id);\n\n        mpt_device_driver_deregister(MPTCTL_DRIVER);\n\n}\n\n \n\nmodule_init(mptctl_init);\nmodule_exit(mptctl_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}