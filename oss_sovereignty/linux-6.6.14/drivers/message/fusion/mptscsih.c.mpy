{
  "module_name": "mptscsih.c",
  "hash_id": "1dedfc8db4ff698b2cc4b3399484b6e4c0442c14523af01869f432494484520a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/message/fusion/mptscsih.c",
  "human_readable_source": " \n \n \n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/kdev_t.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\t \n#include <linux/interrupt.h>\n#include <linux/reboot.h>\t \n#include <linux/workqueue.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_dbg.h>\n\n#include \"mptbase.h\"\n#include \"mptscsih.h\"\n#include \"lsi/mpi_log_sas.h\"\n\n \n#define my_NAME\t\t\"Fusion MPT SCSI Host driver\"\n#define my_VERSION\tMPT_LINUX_VERSION_COMMON\n#define MYNAM\t\t\"mptscsih\"\n\nMODULE_AUTHOR(MODULEAUTHOR);\nMODULE_DESCRIPTION(my_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(my_VERSION);\n\n \n \nstruct scsi_cmnd\t*mptscsih_get_scsi_lookup(MPT_ADAPTER *ioc, int i);\nstatic struct scsi_cmnd * mptscsih_getclear_scsi_lookup(MPT_ADAPTER *ioc, int i);\nstatic void\tmptscsih_set_scsi_lookup(MPT_ADAPTER *ioc, int i, struct scsi_cmnd *scmd);\nstatic int\tSCPNT_TO_LOOKUP_IDX(MPT_ADAPTER *ioc, struct scsi_cmnd *scmd);\nint\t\tmptscsih_io_done(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r);\nstatic void\tmptscsih_report_queue_full(struct scsi_cmnd *sc, SCSIIOReply_t *pScsiReply, SCSIIORequest_t *pScsiReq);\nint\t\tmptscsih_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r);\n\nstatic int\tmptscsih_AddSGE(MPT_ADAPTER *ioc, struct scsi_cmnd *SCpnt,\n\t\t\t\t SCSIIORequest_t *pReq, int req_idx);\nstatic void\tmptscsih_freeChainBuffers(MPT_ADAPTER *ioc, int req_idx);\nstatic void\tmptscsih_copy_sense_data(struct scsi_cmnd *sc, MPT_SCSI_HOST *hd, MPT_FRAME_HDR *mf, SCSIIOReply_t *pScsiReply);\n\nint\tmptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 channel, u8 id,\n\t\tu64 lun, int ctx2abort, ulong timeout);\n\nint\t\tmptscsih_ioc_reset(MPT_ADAPTER *ioc, int post_reset);\nint\t\tmptscsih_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply);\n\nvoid\nmptscsih_taskmgmt_response_code(MPT_ADAPTER *ioc, u8 response_code);\nstatic int\tmptscsih_get_completion_code(MPT_ADAPTER *ioc,\n\t\tMPT_FRAME_HDR *req, MPT_FRAME_HDR *reply);\nint\t\tmptscsih_scandv_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r);\nstatic int\tmptscsih_do_cmd(MPT_SCSI_HOST *hd, INTERNAL_CMD *iocmd);\nstatic void\tmptscsih_synchronize_cache(MPT_SCSI_HOST *hd, VirtDevice *vdevice);\n\nstatic int\nmptscsih_taskmgmt_reply(MPT_ADAPTER *ioc, u8 type,\n\t\t\t\tSCSITaskMgmtReply_t *pScsiTmReply);\nvoid \t\tmptscsih_remove(struct pci_dev *);\nvoid \t\tmptscsih_shutdown(struct pci_dev *);\n#ifdef CONFIG_PM\nint \t\tmptscsih_suspend(struct pci_dev *pdev, pm_message_t state);\nint \t\tmptscsih_resume(struct pci_dev *pdev);\n#endif\n\n\n \n \nstatic inline int\nmptscsih_getFreeChainBuffer(MPT_ADAPTER *ioc, int *retIndex)\n{\n\tMPT_FRAME_HDR *chainBuf;\n\tunsigned long flags;\n\tint rc;\n\tint chain_idx;\n\n\tdsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"getFreeChainBuffer called\\n\",\n\t    ioc->name));\n\tspin_lock_irqsave(&ioc->FreeQlock, flags);\n\tif (!list_empty(&ioc->FreeChainQ)) {\n\t\tint offset;\n\n\t\tchainBuf = list_entry(ioc->FreeChainQ.next, MPT_FRAME_HDR,\n\t\t\t\tu.frame.linkage.list);\n\t\tlist_del(&chainBuf->u.frame.linkage.list);\n\t\toffset = (u8 *)chainBuf - (u8 *)ioc->ChainBuffer;\n\t\tchain_idx = offset / ioc->req_sz;\n\t\trc = SUCCESS;\n\t\tdsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"getFreeChainBuffer chainBuf=%p ChainBuffer=%p offset=%d chain_idx=%d\\n\",\n\t\t    ioc->name, chainBuf, ioc->ChainBuffer, offset, chain_idx));\n\t} else {\n\t\trc = FAILED;\n\t\tchain_idx = MPT_HOST_NO_CHAIN;\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT \"getFreeChainBuffer failed\\n\",\n\t\t    ioc->name));\n\t}\n\tspin_unlock_irqrestore(&ioc->FreeQlock, flags);\n\n\t*retIndex = chain_idx;\n\treturn rc;\n}  \n\n \n \nstatic int\nmptscsih_AddSGE(MPT_ADAPTER *ioc, struct scsi_cmnd *SCpnt,\n\t\tSCSIIORequest_t *pReq, int req_idx)\n{\n\tchar \t*psge;\n\tchar\t*chainSge;\n\tstruct scatterlist *sg;\n\tint\t frm_sz;\n\tint\t sges_left, sg_done;\n\tint\t chain_idx = MPT_HOST_NO_CHAIN;\n\tint\t sgeOffset;\n\tint\t numSgeSlots, numSgeThisFrame;\n\tu32\t sgflags, sgdir, thisxfer = 0;\n\tint\t chain_dma_off = 0;\n\tint\t newIndex;\n\tint\t ii;\n\tdma_addr_t v2;\n\tu32\tRequestNB;\n\n\tsgdir = le32_to_cpu(pReq->Control) & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK;\n\tif (sgdir == MPI_SCSIIO_CONTROL_WRITE)  {\n\t\tsgdir = MPT_TRANSFER_HOST_TO_IOC;\n\t} else {\n\t\tsgdir = MPT_TRANSFER_IOC_TO_HOST;\n\t}\n\n\tpsge = (char *) &pReq->SGL;\n\tfrm_sz = ioc->req_sz;\n\n\t \n\tsges_left = scsi_dma_map(SCpnt);\n\tif (sges_left < 0)\n\t\treturn FAILED;\n\n\t \n\tsg = scsi_sglist(SCpnt);\n\tsg_done  = 0;\n\tsgeOffset = sizeof(SCSIIORequest_t) - sizeof(SGE_IO_UNION);\n\tchainSge = NULL;\n\n\t \n\nnextSGEset:\n\tnumSgeSlots = ((frm_sz - sgeOffset) / ioc->SGE_size);\n\tnumSgeThisFrame = (sges_left < numSgeSlots) ? sges_left : numSgeSlots;\n\n\tsgflags = MPT_SGE_FLAGS_SIMPLE_ELEMENT | sgdir;\n\n\t \n\tfor (ii=0; ii < (numSgeThisFrame-1); ii++) {\n\t\tthisxfer = sg_dma_len(sg);\n\t\tif (thisxfer == 0) {\n\t\t\t \n\t\t\tsg = sg_next(sg);\n\t\t\tsg_done++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tv2 = sg_dma_address(sg);\n\t\tioc->add_sge(psge, sgflags | thisxfer, v2);\n\n\t\t \n\t\tsg = sg_next(sg);\n\t\tpsge += ioc->SGE_size;\n\t\tsgeOffset += ioc->SGE_size;\n\t\tsg_done++;\n\t}\n\n\tif (numSgeThisFrame == sges_left) {\n\t\t \n\t\tsgflags |= MPT_SGE_FLAGS_LAST_ELEMENT |\n\t\t\t\tMPT_SGE_FLAGS_END_OF_BUFFER |\n\t\t\t\tMPT_SGE_FLAGS_END_OF_LIST;\n\n\t\t \n\t\tthisxfer = sg_dma_len(sg);\n\n\t\tv2 = sg_dma_address(sg);\n\t\tioc->add_sge(psge, sgflags | thisxfer, v2);\n\t\tsgeOffset += ioc->SGE_size;\n\t\tsg_done++;\n\n\t\tif (chainSge) {\n\t\t\t \n\t\t\tioc->add_chain((char *)chainSge, 0, sgeOffset,\n\t\t\t\tioc->ChainBufferDMA + chain_dma_off);\n\t\t} else {\n\t\t\t \n\t\t\tpReq->ChainOffset = 0;\n\t\t\tRequestNB = (((sgeOffset - 1) >> ioc->NBShiftFactor)  + 1) & 0x03;\n\t\t\tdsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t    \"Single Buffer RequestNB=%x, sgeOffset=%d\\n\", ioc->name, RequestNB, sgeOffset));\n\t\t\tioc->RequestNB[req_idx] = RequestNB;\n\t\t}\n\t} else {\n\t\t \n\n\t\tdsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"SG: Chain Required! sg done %d\\n\",\n\t\t\t\tioc->name, sg_done));\n\n\t\t \n\t\tif (sg_done) {\n\t\t\tu32 *ptmp = (u32 *) (psge - ioc->SGE_size);\n\t\t\tsgflags = le32_to_cpu(*ptmp);\n\t\t\tsgflags |= MPT_SGE_FLAGS_LAST_ELEMENT;\n\t\t\t*ptmp = cpu_to_le32(sgflags);\n\t\t}\n\n\t\tif (chainSge) {\n\t\t\t \n\t\t\tu8 nextChain = (u8) (sgeOffset >> 2);\n\t\t\tsgeOffset += ioc->SGE_size;\n\t\t\tioc->add_chain((char *)chainSge, nextChain, sgeOffset,\n\t\t\t\t\t ioc->ChainBufferDMA + chain_dma_off);\n\t\t} else {\n\t\t\t \n\t\t\tpReq->ChainOffset = (u8) (sgeOffset >> 2);\n\t\t\tRequestNB = (((sgeOffset - 1) >> ioc->NBShiftFactor)  + 1) & 0x03;\n\t\t\tdsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Chain Buffer Needed, RequestNB=%x sgeOffset=%d\\n\", ioc->name, RequestNB, sgeOffset));\n\t\t\tioc->RequestNB[req_idx] = RequestNB;\n\t\t}\n\n\t\tsges_left -= sg_done;\n\n\n\t\t \n\t\tif ((mptscsih_getFreeChainBuffer(ioc, &newIndex)) == FAILED) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t    \"getFreeChainBuffer FAILED SCSI cmd=%02x (%p)\\n\",\n \t\t\t    ioc->name, pReq->CDB[0], SCpnt));\n\t\t\treturn FAILED;\n\t\t}\n\n\t\t \n\t\tif (chainSge) {\n\t\t\tioc->ChainToChain[chain_idx] = newIndex;\n\t\t} else {\n\t\t\tioc->ReqToChain[req_idx] = newIndex;\n\t\t}\n\t\tchain_idx = newIndex;\n\t\tchain_dma_off = ioc->req_sz * chain_idx;\n\n\t\t \n\t\tchainSge = (char *) psge;\n\t\tdsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"  Current buff @ %p (index 0x%x)\",\n\t\t    ioc->name, psge, req_idx));\n\n\t\t \n\t\tpsge = (char *) (ioc->ChainBuffer + chain_dma_off);\n\t\tsgeOffset = 0;\n\t\tsg_done = 0;\n\n\t\tdsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"  Chain buff @ %p (index 0x%x)\\n\",\n\t\t    ioc->name, psge, chain_idx));\n\n\t\t \n\n\t\tgoto nextSGEset;\n\t}\n\n\treturn SUCCESS;\n}  \n\nstatic void\nmptscsih_issue_sep_command(MPT_ADAPTER *ioc, VirtTarget *vtarget,\n    U32 SlotStatus)\n{\n\tMPT_FRAME_HDR *mf;\n\tSEPRequest_t \t *SEPMsg;\n\n\tif (ioc->bus_type != SAS)\n\t\treturn;\n\n\t \n\tif (vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\treturn;\n\n\tif ((mf = mpt_get_msg_frame(ioc->InternalCtx, ioc)) == NULL) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_WARN_FMT \"%s: no msg frames!!\\n\",\n\t\t    ioc->name,__func__));\n\t\treturn;\n\t}\n\n\tSEPMsg = (SEPRequest_t *)mf;\n\tSEPMsg->Function = MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR;\n\tSEPMsg->Bus = vtarget->channel;\n\tSEPMsg->TargetID = vtarget->id;\n\tSEPMsg->Action = MPI_SEP_REQ_ACTION_WRITE_STATUS;\n\tSEPMsg->SlotStatus = SlotStatus;\n\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"Sending SEP cmd=%x channel=%d id=%d\\n\",\n\t    ioc->name, SlotStatus, SEPMsg->Bus, SEPMsg->TargetID));\n\tmpt_put_msg_frame(ioc->DoneCtx, ioc, mf);\n}\n\n#ifdef CONFIG_FUSION_LOGGING\n \nstatic void\nmptscsih_info_scsiio(MPT_ADAPTER *ioc, struct scsi_cmnd *sc, SCSIIOReply_t * pScsiReply)\n{\n\tchar\t*desc = NULL;\n\tchar\t*desc1 = NULL;\n\tu16\tioc_status;\n\tu8\tskey, asc, ascq;\n\n\tioc_status = le16_to_cpu(pScsiReply->IOCStatus) & MPI_IOCSTATUS_MASK;\n\n\tswitch (ioc_status) {\n\n\tcase MPI_IOCSTATUS_SUCCESS:\n\t\tdesc = \"success\";\n\t\tbreak;\n\tcase MPI_IOCSTATUS_SCSI_INVALID_BUS:\n\t\tdesc = \"invalid bus\";\n\t\tbreak;\n\tcase MPI_IOCSTATUS_SCSI_INVALID_TARGETID:\n\t\tdesc = \"invalid target_id\";\n\t\tbreak;\n\tcase MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\n\t\tdesc = \"device not there\";\n\t\tbreak;\n\tcase MPI_IOCSTATUS_SCSI_DATA_OVERRUN:\n\t\tdesc = \"data overrun\";\n\t\tbreak;\n\tcase MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:\n\t\tdesc = \"data underrun\";\n\t\tbreak;\n\tcase MPI_IOCSTATUS_SCSI_IO_DATA_ERROR:\n\t\tdesc = \"I/O data error\";\n\t\tbreak;\n\tcase MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:\n\t\tdesc = \"protocol error\";\n\t\tbreak;\n\tcase MPI_IOCSTATUS_SCSI_TASK_TERMINATED:\n\t\tdesc = \"task terminated\";\n\t\tbreak;\n\tcase MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\n\t\tdesc = \"residual mismatch\";\n\t\tbreak;\n\tcase MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\n\t\tdesc = \"task management failed\";\n\t\tbreak;\n\tcase MPI_IOCSTATUS_SCSI_IOC_TERMINATED:\n\t\tdesc = \"IOC terminated\";\n\t\tbreak;\n\tcase MPI_IOCSTATUS_SCSI_EXT_TERMINATED:\n\t\tdesc = \"ext terminated\";\n\t\tbreak;\n\tdefault:\n\t\tdesc = \"\";\n\t\tbreak;\n\t}\n\n\tswitch (pScsiReply->SCSIStatus)\n\t{\n\n\tcase MPI_SCSI_STATUS_SUCCESS:\n\t\tdesc1 = \"success\";\n\t\tbreak;\n\tcase MPI_SCSI_STATUS_CHECK_CONDITION:\n\t\tdesc1 = \"check condition\";\n\t\tbreak;\n\tcase MPI_SCSI_STATUS_CONDITION_MET:\n\t\tdesc1 = \"condition met\";\n\t\tbreak;\n\tcase MPI_SCSI_STATUS_BUSY:\n\t\tdesc1 = \"busy\";\n\t\tbreak;\n\tcase MPI_SCSI_STATUS_INTERMEDIATE:\n\t\tdesc1 = \"intermediate\";\n\t\tbreak;\n\tcase MPI_SCSI_STATUS_INTERMEDIATE_CONDMET:\n\t\tdesc1 = \"intermediate condmet\";\n\t\tbreak;\n\tcase MPI_SCSI_STATUS_RESERVATION_CONFLICT:\n\t\tdesc1 = \"reservation conflict\";\n\t\tbreak;\n\tcase MPI_SCSI_STATUS_COMMAND_TERMINATED:\n\t\tdesc1 = \"command terminated\";\n\t\tbreak;\n\tcase MPI_SCSI_STATUS_TASK_SET_FULL:\n\t\tdesc1 = \"task set full\";\n\t\tbreak;\n\tcase MPI_SCSI_STATUS_ACA_ACTIVE:\n\t\tdesc1 = \"aca active\";\n\t\tbreak;\n\tcase MPI_SCSI_STATUS_FCPEXT_DEVICE_LOGGED_OUT:\n\t\tdesc1 = \"fcpext device logged out\";\n\t\tbreak;\n\tcase MPI_SCSI_STATUS_FCPEXT_NO_LINK:\n\t\tdesc1 = \"fcpext no link\";\n\t\tbreak;\n\tcase MPI_SCSI_STATUS_FCPEXT_UNASSIGNED:\n\t\tdesc1 = \"fcpext unassigned\";\n\t\tbreak;\n\tdefault:\n\t\tdesc1 = \"\";\n\t\tbreak;\n\t}\n\n\tscsi_print_command(sc);\n\tprintk(MYIOC_s_DEBUG_FMT \"\\tfw_channel = %d, fw_id = %d, lun = %llu\\n\",\n\t    ioc->name, pScsiReply->Bus, pScsiReply->TargetID, sc->device->lun);\n\tprintk(MYIOC_s_DEBUG_FMT \"\\trequest_len = %d, underflow = %d, \"\n\t    \"resid = %d\\n\", ioc->name, scsi_bufflen(sc), sc->underflow,\n\t    scsi_get_resid(sc));\n\tprintk(MYIOC_s_DEBUG_FMT \"\\ttag = %d, transfer_count = %d, \"\n\t    \"sc->result = %08X\\n\", ioc->name, le16_to_cpu(pScsiReply->TaskTag),\n\t    le32_to_cpu(pScsiReply->TransferCount), sc->result);\n\n\tprintk(MYIOC_s_DEBUG_FMT \"\\tiocstatus = %s (0x%04x), \"\n\t    \"scsi_status = %s (0x%02x), scsi_state = (0x%02x)\\n\",\n\t    ioc->name, desc, ioc_status, desc1, pScsiReply->SCSIStatus,\n\t    pScsiReply->SCSIState);\n\n\tif (pScsiReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID) {\n\t\tskey = sc->sense_buffer[2] & 0x0F;\n\t\tasc = sc->sense_buffer[12];\n\t\tascq = sc->sense_buffer[13];\n\n\t\tprintk(MYIOC_s_DEBUG_FMT \"\\t[sense_key,asc,ascq]: \"\n\t\t    \"[0x%02x,0x%02x,0x%02x]\\n\", ioc->name, skey, asc, ascq);\n\t}\n\n\t \n\tif (pScsiReply->SCSIState & MPI_SCSI_STATE_RESPONSE_INFO_VALID &&\n\t    pScsiReply->ResponseInfo)\n\t\tprintk(MYIOC_s_DEBUG_FMT \"response_info = %08xh\\n\",\n\t\t    ioc->name, le32_to_cpu(pScsiReply->ResponseInfo));\n}\n#endif\n\n \n \nint\nmptscsih_io_done(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)\n{\n\tstruct scsi_cmnd\t*sc;\n\tMPT_SCSI_HOST\t*hd;\n\tSCSIIORequest_t\t*pScsiReq;\n\tSCSIIOReply_t\t*pScsiReply;\n\tu16\t\t req_idx, req_idx_MR;\n\tVirtDevice\t *vdevice;\n\tVirtTarget\t *vtarget;\n\n\thd = shost_priv(ioc->sh);\n\treq_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\n\treq_idx_MR = (mr != NULL) ?\n\t    le16_to_cpu(mr->u.frame.hwhdr.msgctxu.fld.req_idx) : req_idx;\n\n\t \n\tif ((req_idx != req_idx_MR) ||\n\t    (le32_to_cpu(mf->u.frame.linkage.arg1) == 0xdeadbeaf))\n\t\treturn 0;\n\n\tsc = mptscsih_getclear_scsi_lookup(ioc, req_idx);\n\tif (sc == NULL) {\n\t\tMPIHeader_t *hdr = (MPIHeader_t *)mf;\n\n\t\t \n\t\tif (hdr->Function == MPI_FUNCTION_SCSI_IO_REQUEST)\n\t\t\tprintk(MYIOC_s_ERR_FMT \"NULL ScsiCmd ptr!\\n\",\n\t\t\tioc->name);\n\n\t\tmptscsih_freeChainBuffers(ioc, req_idx);\n\t\treturn 1;\n\t}\n\n\tif ((unsigned char *)mf != sc->host_scribble) {\n\t\tmptscsih_freeChainBuffers(ioc, req_idx);\n\t\treturn 1;\n\t}\n\n\tif (ioc->bus_type == SAS) {\n\t\tVirtDevice *vdevice = sc->device->hostdata;\n\n\t\tif (!vdevice || !vdevice->vtarget ||\n\t\t    vdevice->vtarget->deleted) {\n\t\t\tsc->result = DID_NO_CONNECT << 16;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsc->host_scribble = NULL;\n\tsc->result = DID_OK << 16;\t\t \n\tpScsiReq = (SCSIIORequest_t *) mf;\n\tpScsiReply = (SCSIIOReply_t *) mr;\n\n\tif((ioc->facts.MsgVersion >= MPI_VERSION_01_05) && pScsiReply){\n\t\tdmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"ScsiDone (mf=%p,mr=%p,sc=%p,idx=%d,task-tag=%d)\\n\",\n\t\t\tioc->name, mf, mr, sc, req_idx, pScsiReply->TaskTag));\n\t}else{\n\t\tdmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"ScsiDone (mf=%p,mr=%p,sc=%p,idx=%d)\\n\",\n\t\t\tioc->name, mf, mr, sc, req_idx));\n\t}\n\n\tif (pScsiReply == NULL) {\n\t\t \n\t\t;\n\t} else {\n\t\tu32\t xfer_cnt;\n\t\tu16\t status;\n\t\tu8\t scsi_state, scsi_status;\n\t\tu32\t log_info;\n\n\t\tstatus = le16_to_cpu(pScsiReply->IOCStatus) & MPI_IOCSTATUS_MASK;\n\n\t\tscsi_state = pScsiReply->SCSIState;\n\t\tscsi_status = pScsiReply->SCSIStatus;\n\t\txfer_cnt = le32_to_cpu(pScsiReply->TransferCount);\n\t\tscsi_set_resid(sc, scsi_bufflen(sc) - xfer_cnt);\n\t\tlog_info = le32_to_cpu(pScsiReply->IOCLogInfo);\n\n\t\t \n\t\tif (status == MPI_IOCSTATUS_SCSI_DATA_UNDERRUN && xfer_cnt == 0 &&\n\t\t    (scsi_status == MPI_SCSI_STATUS_BUSY ||\n\t\t     scsi_status == MPI_SCSI_STATUS_RESERVATION_CONFLICT ||\n\t\t     scsi_status == MPI_SCSI_STATUS_TASK_SET_FULL)) {\n\t\t\tstatus = MPI_IOCSTATUS_SUCCESS;\n\t\t}\n\n\t\tif (scsi_state & MPI_SCSI_STATE_AUTOSENSE_VALID)\n\t\t\tmptscsih_copy_sense_data(sc, hd, mf, pScsiReply);\n\n\t\t \n\t\tif (scsi_state & MPI_SCSI_STATE_RESPONSE_INFO_VALID &&\n\t\t    pScsiReply->ResponseInfo) {\n\t\t\tprintk(MYIOC_s_NOTE_FMT \"[%d:%d:%d:%llu] \"\n\t\t\t\"FCP_ResponseInfo=%08xh\\n\", ioc->name,\n\t\t\tsc->device->host->host_no, sc->device->channel,\n\t\t\tsc->device->id, sc->device->lun,\n\t\t\tle32_to_cpu(pScsiReply->ResponseInfo));\n\t\t}\n\n\t\tswitch(status) {\n\t\tcase MPI_IOCSTATUS_BUSY:\t\t\t \n\t\tcase MPI_IOCSTATUS_INSUFFICIENT_RESOURCES:\t \n\t\t\t \n\t\t\tsc->result = SAM_STAT_BUSY;\n\t\t\tbreak;\n\n\t\tcase MPI_IOCSTATUS_SCSI_INVALID_BUS:\t\t \n\t\tcase MPI_IOCSTATUS_SCSI_INVALID_TARGETID:\t \n\t\t\tsc->result = DID_BAD_TARGET << 16;\n\t\t\tbreak;\n\n\t\tcase MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\t \n\t\t\t \n\t\t\tif (ioc->bus_type != FC)\n\t\t\t\tsc->result = DID_NO_CONNECT << 16;\n\t\t\t \n\t\t\telse\n\t\t\t\tsc->result = DID_REQUEUE << 16;\n\n\t\t\tif (hd->sel_timeout[pScsiReq->TargetID] < 0xFFFF)\n\t\t\t\thd->sel_timeout[pScsiReq->TargetID]++;\n\n\t\t\tvdevice = sc->device->hostdata;\n\t\t\tif (!vdevice)\n\t\t\t\tbreak;\n\t\t\tvtarget = vdevice->vtarget;\n\t\t\tif (vtarget->tflags & MPT_TARGET_FLAGS_LED_ON) {\n\t\t\t\tmptscsih_issue_sep_command(ioc, vtarget,\n\t\t\t\t    MPI_SEP_REQ_SLOTSTATUS_UNCONFIGURED);\n\t\t\t\tvtarget->tflags &= ~MPT_TARGET_FLAGS_LED_ON;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MPI_IOCSTATUS_SCSI_IOC_TERMINATED:\t\t \n\t\t\tif ( ioc->bus_type == SAS ) {\n\t\t\t\tu16 ioc_status =\n\t\t\t\t    le16_to_cpu(pScsiReply->IOCStatus);\n\t\t\t\tif ((ioc_status &\n\t\t\t\t\tMPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE)\n\t\t\t\t\t&&\n\t\t\t\t\t((log_info & SAS_LOGINFO_MASK) ==\n\t\t\t\t\tSAS_LOGINFO_NEXUS_LOSS)) {\n\t\t\t\t\t\tVirtDevice *vdevice =\n\t\t\t\t\t\tsc->device->hostdata;\n\n\t\t\t\t\t     \n\t\t\t\t\t\tif (vdevice && vdevice->\n\t\t\t\t\t\t\tvtarget &&\n\t\t\t\t\t\t\tvdevice->vtarget->\n\t\t\t\t\t\t\traidVolume)\n\t\t\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t\t\t\"Skipping Raid Volume\"\n\t\t\t\t\t\t\t\"for inDMD\\n\");\n\t\t\t\t\t\telse if (vdevice &&\n\t\t\t\t\t\t\tvdevice->vtarget)\n\t\t\t\t\t\t\tvdevice->vtarget->\n\t\t\t\t\t\t\t\tinDMD = 1;\n\n\t\t\t\t\t    sc->result =\n\t\t\t\t\t\t    (DID_TRANSPORT_DISRUPTED\n\t\t\t\t\t\t    << 16);\n\t\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t} else if (ioc->bus_type == FC) {\n\t\t\t\t \n\t\t\t\tsc->result = DID_ERROR << 16;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tfallthrough;\n\n\t\tcase MPI_IOCSTATUS_SCSI_TASK_TERMINATED:\t \n\t\t\t \n\t\t\tsc->result = DID_RESET << 16;\n\t\t\tbreak;\n\n\t\tcase MPI_IOCSTATUS_SCSI_EXT_TERMINATED:\t\t \n\t\t\tif (ioc->bus_type == FC)\n\t\t\t\tsc->result = DID_ERROR << 16;\n\t\t\telse\n\t\t\t\tsc->result = DID_RESET << 16;\n\t\t\tbreak;\n\n\t\tcase MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\t \n\t\t\tscsi_set_resid(sc, scsi_bufflen(sc) - xfer_cnt);\n\t\t\tif((xfer_cnt==0)||(sc->underflow > xfer_cnt))\n\t\t\t\tsc->result=DID_SOFT_ERROR << 16;\n\t\t\telse  \n\t\t\t\tsc->result = (DID_OK << 16) | scsi_status;\n\t\t\tdreplyprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t    \"RESIDUAL_MISMATCH: result=%x on channel=%d id=%d\\n\",\n\t\t\t    ioc->name, sc->result, sc->device->channel, sc->device->id));\n\t\t\tbreak;\n\n\t\tcase MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:\t\t \n\t\t\t \n\t\t\tsc->result = (DID_OK << 16) | scsi_status;\n\t\t\tif (!(scsi_state & MPI_SCSI_STATE_AUTOSENSE_VALID)) {\n\n\t\t\t\t \n\t\t\t\tif (ioc->bus_type == SPI) {\n\t\t\t\t\tif ((pScsiReq->CDB[0] == READ_6  && ((pScsiReq->CDB[1] & 0x02) == 0)) ||\n\t\t\t\t\t    pScsiReq->CDB[0] == READ_10 ||\n\t\t\t\t\t    pScsiReq->CDB[0] == READ_12 ||\n\t\t\t\t\t\t(pScsiReq->CDB[0] == READ_16 &&\n\t\t\t\t\t\t((pScsiReq->CDB[1] & 0x02) == 0)) ||\n\t\t\t\t\t    pScsiReq->CDB[0] == VERIFY  ||\n\t\t\t\t\t    pScsiReq->CDB[0] == VERIFY_16) {\n\t\t\t\t\t\tif (scsi_bufflen(sc) !=\n\t\t\t\t\t\t\txfer_cnt) {\n\t\t\t\t\t\t\tsc->result =\n\t\t\t\t\t\t\tDID_SOFT_ERROR << 16;\n\t\t\t\t\t\t    printk(KERN_WARNING \"Errata\"\n\t\t\t\t\t\t    \"on LSI53C1030 occurred.\"\n\t\t\t\t\t\t    \"sc->req_bufflen=0x%02x,\"\n\t\t\t\t\t\t    \"xfer_cnt=0x%02x\\n\",\n\t\t\t\t\t\t    scsi_bufflen(sc),\n\t\t\t\t\t\t    xfer_cnt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (xfer_cnt < sc->underflow) {\n\t\t\t\t\tif (scsi_status == SAM_STAT_BUSY)\n\t\t\t\t\t\tsc->result = SAM_STAT_BUSY;\n\t\t\t\t\telse\n\t\t\t\t\t\tsc->result = DID_SOFT_ERROR << 16;\n\t\t\t\t}\n\t\t\t\tif (scsi_state & (MPI_SCSI_STATE_AUTOSENSE_FAILED | MPI_SCSI_STATE_NO_SCSI_STATUS)) {\n\t\t\t\t\t \n\t\t\t\t\tsc->result = DID_SOFT_ERROR << 16;\n\t\t\t\t}\n\t\t\t\telse if (scsi_state & MPI_SCSI_STATE_TERMINATED) {\n\t\t\t\t\t \n\t\t\t\t\tsc->result = DID_RESET << 16;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tdreplyprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t    \"  sc->underflow={report ERR if < %02xh bytes xfer'd}\\n\",\n\t\t\t    ioc->name, sc->underflow));\n\t\t\tdreplyprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t    \"  ActBytesXferd=%02xh\\n\", ioc->name, xfer_cnt));\n\n\t\t\t \n\t\t\tif (scsi_status == MPI_SCSI_STATUS_TASK_SET_FULL)\n\t\t\t\tmptscsih_report_queue_full(sc, pScsiReply, pScsiReq);\n\n\t\t\tbreak;\n\n\t\tcase MPI_IOCSTATUS_SCSI_DATA_OVERRUN:\t\t \n\t\t\tscsi_set_resid(sc, 0);\n\t\t\tfallthrough;\n\t\tcase MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:\t \n\t\tcase MPI_IOCSTATUS_SUCCESS:\t\t\t \n\t\t\tsc->result = (DID_OK << 16) | scsi_status;\n\t\t\tif (scsi_state == 0) {\n\t\t\t\t;\n\t\t\t} else if (scsi_state &\n\t\t\t    MPI_SCSI_STATE_AUTOSENSE_VALID) {\n\n\t\t\t\t \n\t\t\t\tif ((ioc->bus_type == SPI) &&\n\t\t\t\t\t(sc->sense_buffer[2] & 0x20)) {\n\t\t\t\t\tu32\t difftransfer;\n\t\t\t\t\tdifftransfer =\n\t\t\t\t\tsc->sense_buffer[3] << 24 |\n\t\t\t\t\tsc->sense_buffer[4] << 16 |\n\t\t\t\t\tsc->sense_buffer[5] << 8 |\n\t\t\t\t\tsc->sense_buffer[6];\n\t\t\t\t\tif (((sc->sense_buffer[3] & 0x80) ==\n\t\t\t\t\t\t0x80) && (scsi_bufflen(sc)\n\t\t\t\t\t\t!= xfer_cnt)) {\n\t\t\t\t\t\tsc->sense_buffer[2] =\n\t\t\t\t\t\t    MEDIUM_ERROR;\n\t\t\t\t\t\tsc->sense_buffer[12] = 0xff;\n\t\t\t\t\t\tsc->sense_buffer[13] = 0xff;\n\t\t\t\t\t\tprintk(KERN_WARNING\"Errata\"\n\t\t\t\t\t\t\"on LSI53C1030 occurred.\"\n\t\t\t\t\t\t\"sc->req_bufflen=0x%02x,\"\n\t\t\t\t\t\t\"xfer_cnt=0x%02x\\n\" ,\n\t\t\t\t\t\tscsi_bufflen(sc),\n\t\t\t\t\t\txfer_cnt);\n\t\t\t\t\t}\n\t\t\t\t\tif (((sc->sense_buffer[3] & 0x80)\n\t\t\t\t\t\t!= 0x80) &&\n\t\t\t\t\t\t(scsi_bufflen(sc) !=\n\t\t\t\t\t\txfer_cnt + difftransfer)) {\n\t\t\t\t\t\tsc->sense_buffer[2] =\n\t\t\t\t\t\t\tMEDIUM_ERROR;\n\t\t\t\t\t\tsc->sense_buffer[12] = 0xff;\n\t\t\t\t\t\tsc->sense_buffer[13] = 0xff;\n\t\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\t\"Errata on LSI53C1030 occurred\"\n\t\t\t\t\t\t\"sc->req_bufflen=0x%02x,\"\n\t\t\t\t\t\t\" xfer_cnt=0x%02x,\"\n\t\t\t\t\t\t\"difftransfer=0x%02x\\n\",\n\t\t\t\t\t\tscsi_bufflen(sc),\n\t\t\t\t\t\txfer_cnt,\n\t\t\t\t\t\tdifftransfer);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (pScsiReply->SCSIStatus == MPI_SCSI_STATUS_TASK_SET_FULL)\n\t\t\t\t\tmptscsih_report_queue_full(sc, pScsiReply, pScsiReq);\n\n\t\t\t}\n\t\t\telse if (scsi_state &\n\t\t\t         (MPI_SCSI_STATE_AUTOSENSE_FAILED | MPI_SCSI_STATE_NO_SCSI_STATUS)\n\t\t\t   ) {\n\t\t\t\t \n\t\t\t\tsc->result = DID_SOFT_ERROR << 16;\n\t\t\t}\n\t\t\telse if (scsi_state & MPI_SCSI_STATE_TERMINATED) {\n\t\t\t\t \n\t\t\t\tsc->result = DID_RESET << 16;\n\t\t\t}\n\t\t\telse if (scsi_state & MPI_SCSI_STATE_QUEUE_TAG_REJECTED) {\n\t\t\t\t \n\t\t\t}\n\n\t\t\tif (sc->result == MPI_SCSI_STATUS_TASK_SET_FULL)\n\t\t\t\tmptscsih_report_queue_full(sc, pScsiReply, pScsiReq);\n\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:\t\t \n\t\t\tsc->result = DID_SOFT_ERROR << 16;\n\t\t\tbreak;\n\n\t\tcase MPI_IOCSTATUS_INVALID_FUNCTION:\t\t \n\t\tcase MPI_IOCSTATUS_INVALID_SGL:\t\t\t \n\t\tcase MPI_IOCSTATUS_INTERNAL_ERROR:\t\t \n\t\tcase MPI_IOCSTATUS_RESERVED:\t\t\t \n\t\tcase MPI_IOCSTATUS_INVALID_FIELD:\t\t \n\t\tcase MPI_IOCSTATUS_INVALID_STATE:\t\t \n\t\tcase MPI_IOCSTATUS_SCSI_IO_DATA_ERROR:\t\t \n\t\tcase MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\t \n\t\tdefault:\n\t\t\t \n\t\t\tsc->result = DID_SOFT_ERROR << 16;\n\t\t\tbreak;\n\n\t\t}\t \n\n#ifdef CONFIG_FUSION_LOGGING\n\t\tif (sc->result && (ioc->debug_level & MPT_DEBUG_REPLY))\n\t\t\tmptscsih_info_scsiio(ioc, sc, pScsiReply);\n#endif\n\n\t}  \nout:\n\t \n\tscsi_dma_unmap(sc);\n\n\tscsi_done(sc);\t\t\t \n\n\t \n\tmptscsih_freeChainBuffers(ioc, req_idx);\n\treturn 1;\n}\n\n \nvoid\nmptscsih_flush_running_cmds(MPT_SCSI_HOST *hd)\n{\n\tMPT_ADAPTER *ioc = hd->ioc;\n\tstruct scsi_cmnd *sc;\n\tSCSIIORequest_t\t*mf = NULL;\n\tint\t\t ii;\n\tint\t\t channel, id;\n\n\tfor (ii= 0; ii < ioc->req_depth; ii++) {\n\t\tsc = mptscsih_getclear_scsi_lookup(ioc, ii);\n\t\tif (!sc)\n\t\t\tcontinue;\n\t\tmf = (SCSIIORequest_t *)MPT_INDEX_2_MFPTR(ioc, ii);\n\t\tif (!mf)\n\t\t\tcontinue;\n\t\tchannel = mf->Bus;\n\t\tid = mf->TargetID;\n\t\tmptscsih_freeChainBuffers(ioc, ii);\n\t\tmpt_free_msg_frame(ioc, (MPT_FRAME_HDR *)mf);\n\t\tif ((unsigned char *)mf != sc->host_scribble)\n\t\t\tcontinue;\n\t\tscsi_dma_unmap(sc);\n\t\tsc->result = DID_RESET << 16;\n\t\tsc->host_scribble = NULL;\n\t\tdtmprintk(ioc, sdev_printk(KERN_INFO, sc->device, MYIOC_s_FMT\n\t\t    \"completing cmds: fw_channel %d, fw_id %d, sc=%p, mf = %p, \"\n\t\t    \"idx=%x\\n\", ioc->name, channel, id, sc, mf, ii));\n\t\tscsi_done(sc);\n\t}\n}\nEXPORT_SYMBOL(mptscsih_flush_running_cmds);\n\n \nstatic void\nmptscsih_search_running_cmds(MPT_SCSI_HOST *hd, VirtDevice *vdevice)\n{\n\tSCSIIORequest_t\t*mf = NULL;\n\tint\t\t ii;\n\tstruct scsi_cmnd *sc;\n\tstruct scsi_lun  lun;\n\tMPT_ADAPTER *ioc = hd->ioc;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tfor (ii = 0; ii < ioc->req_depth; ii++) {\n\t\tif ((sc = ioc->ScsiLookup[ii]) != NULL) {\n\n\t\t\tmf = (SCSIIORequest_t *)MPT_INDEX_2_MFPTR(ioc, ii);\n\t\t\tif (mf == NULL)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (vdevice->vtarget->tflags &\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT && mf->Function !=\n\t\t\t    MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)\n\t\t\t\tcontinue;\n\n\t\t\tint_to_scsilun(vdevice->lun, &lun);\n\t\t\tif ((mf->Bus != vdevice->vtarget->channel) ||\n\t\t\t    (mf->TargetID != vdevice->vtarget->id) ||\n\t\t\t    memcmp(lun.scsi_lun, mf->LUN, 8))\n\t\t\t\tcontinue;\n\n\t\t\tif ((unsigned char *)mf != sc->host_scribble)\n\t\t\t\tcontinue;\n\t\t\tioc->ScsiLookup[ii] = NULL;\n\t\t\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\t\t\tmptscsih_freeChainBuffers(ioc, ii);\n\t\t\tmpt_free_msg_frame(ioc, (MPT_FRAME_HDR *)mf);\n\t\t\tscsi_dma_unmap(sc);\n\t\t\tsc->host_scribble = NULL;\n\t\t\tsc->result = DID_NO_CONNECT << 16;\n\t\t\tdtmprintk(ioc, sdev_printk(KERN_INFO, sc->device,\n\t\t\t   MYIOC_s_FMT \"completing cmds: fw_channel %d, \"\n\t\t\t   \"fw_id %d, sc=%p, mf = %p, idx=%x\\n\", ioc->name,\n\t\t\t   vdevice->vtarget->channel, vdevice->vtarget->id,\n\t\t\t   sc, mf, ii));\n\t\t\tscsi_done(sc);\n\t\t\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\treturn;\n}\n\n \n\n \n \nstatic void\nmptscsih_report_queue_full(struct scsi_cmnd *sc, SCSIIOReply_t *pScsiReply, SCSIIORequest_t *pScsiReq)\n{\n\tlong time = jiffies;\n\tMPT_SCSI_HOST\t\t*hd;\n\tMPT_ADAPTER\t*ioc;\n\n\tif (sc->device == NULL)\n\t\treturn;\n\tif (sc->device->host == NULL)\n\t\treturn;\n\tif ((hd = shost_priv(sc->device->host)) == NULL)\n\t\treturn;\n\tioc = hd->ioc;\n\tif (time - hd->last_queue_full > 10 * HZ) {\n\t\tdprintk(ioc, printk(MYIOC_s_WARN_FMT \"Device (%d:%d:%llu) reported QUEUE_FULL!\\n\",\n\t\t\t\tioc->name, 0, sc->device->id, sc->device->lun));\n\t\thd->last_queue_full = time;\n\t}\n}\n\n \n \nvoid\nmptscsih_remove(struct pci_dev *pdev)\n{\n\tMPT_ADAPTER \t\t*ioc = pci_get_drvdata(pdev);\n\tstruct Scsi_Host \t*host = ioc->sh;\n\tMPT_SCSI_HOST\t\t*hd;\n\tint sz1;\n\n\tif (host == NULL)\n\t\thd = NULL;\n\telse\n\t\thd = shost_priv(host);\n\n\tmptscsih_shutdown(pdev);\n\n\tsz1=0;\n\n\tif (ioc->ScsiLookup != NULL) {\n\t\tsz1 = ioc->req_depth * sizeof(void *);\n\t\tkfree(ioc->ScsiLookup);\n\t\tioc->ScsiLookup = NULL;\n\t}\n\n\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"Free'd ScsiLookup (%d) memory\\n\",\n\t    ioc->name, sz1));\n\n\tif (hd)\n\t\tkfree(hd->info_kbuf);\n\n\t \n\tioc->sh = NULL;\n\n\tif (host)\n\t\tscsi_host_put(host);\n\tmpt_detach(pdev);\n\n}\n\n \n \nvoid\nmptscsih_shutdown(struct pci_dev *pdev)\n{\n}\n\n#ifdef CONFIG_PM\n \n \nint\nmptscsih_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tMPT_ADAPTER \t\t*ioc = pci_get_drvdata(pdev);\n\n\tscsi_block_requests(ioc->sh);\n\tmptscsih_shutdown(pdev);\n\treturn mpt_suspend(pdev,state);\n}\n\n \n \nint\nmptscsih_resume(struct pci_dev *pdev)\n{\n\tMPT_ADAPTER \t\t*ioc = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = mpt_resume(pdev);\n\tscsi_unblock_requests(ioc->sh);\n\treturn rc;\n}\n\n#endif\n\n \n \nconst char *\nmptscsih_info(struct Scsi_Host *SChost)\n{\n\tMPT_SCSI_HOST *h;\n\tint size = 0;\n\n\th = shost_priv(SChost);\n\n\tif (h->info_kbuf == NULL)\n\t\tif ((h->info_kbuf = kmalloc(0x1000  , GFP_KERNEL)) == NULL)\n\t\t\treturn h->info_kbuf;\n\th->info_kbuf[0] = '\\0';\n\n\tmpt_print_ioc_summary(h->ioc, h->info_kbuf, &size, 0, 0);\n\th->info_kbuf[size-1] = '\\0';\n\n\treturn h->info_kbuf;\n}\n\nint mptscsih_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER\t*ioc = hd->ioc;\n\n\tseq_printf(m, \"%s: %s, \", ioc->name, ioc->prod_name);\n\tseq_printf(m, \"%s%08xh, \", MPT_FW_REV_MAGIC_ID_STRING, ioc->facts.FWVersion.Word);\n\tseq_printf(m, \"Ports=%d, \", ioc->facts.NumberOfPorts);\n\tseq_printf(m, \"MaxQ=%d\\n\", ioc->req_depth);\n\n\treturn 0;\n}\n\n \n#define ADD_INDEX_LOG(req_ent)\tdo { } while(0)\n\n \n \nint\nmptscsih_qcmd(struct scsi_cmnd *SCpnt)\n{\n\tMPT_SCSI_HOST\t\t*hd;\n\tMPT_FRAME_HDR\t\t*mf;\n\tSCSIIORequest_t\t\t*pScsiReq;\n\tVirtDevice\t\t*vdevice = SCpnt->device->hostdata;\n\tu32\t datalen;\n\tu32\t scsictl;\n\tu32\t scsidir;\n\tu32\t cmd_len;\n\tint\t my_idx;\n\tint\t ii;\n\tMPT_ADAPTER *ioc;\n\n\thd = shost_priv(SCpnt->device->host);\n\tioc = hd->ioc;\n\n\tdmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"qcmd: SCpnt=%p\\n\",\n\t\tioc->name, SCpnt));\n\n\tif (ioc->taskmgmt_quiesce_io)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t \n\tif ((mf = mpt_get_msg_frame(ioc->DoneCtx, ioc)) == NULL) {\n\t\tdprintk(ioc, printk(MYIOC_s_WARN_FMT \"QueueCmd, no msg frames!!\\n\",\n\t\t\t\tioc->name));\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tpScsiReq = (SCSIIORequest_t *) mf;\n\n\tmy_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\n\n\tADD_INDEX_LOG(my_idx);\n\n\t \n\tif (SCpnt->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tdatalen = scsi_bufflen(SCpnt);\n\t\tscsidir = MPI_SCSIIO_CONTROL_READ;\t \n\t} else if (SCpnt->sc_data_direction == DMA_TO_DEVICE) {\n\t\tdatalen = scsi_bufflen(SCpnt);\n\t\tscsidir = MPI_SCSIIO_CONTROL_WRITE;\t \n\t} else {\n\t\tdatalen = 0;\n\t\tscsidir = MPI_SCSIIO_CONTROL_NODATATRANSFER;\n\t}\n\n\t \n\tif ((vdevice->vtarget->tflags & MPT_TARGET_FLAGS_Q_YES) &&\n\t    SCpnt->device->tagged_supported)\n\t\tscsictl = scsidir | MPI_SCSIIO_CONTROL_SIMPLEQ;\n\telse\n\t\tscsictl = scsidir | MPI_SCSIIO_CONTROL_UNTAGGED;\n\n\n\t \n\tpScsiReq->TargetID = (u8) vdevice->vtarget->id;\n\tpScsiReq->Bus = vdevice->vtarget->channel;\n\tpScsiReq->ChainOffset = 0;\n\tif (vdevice->vtarget->tflags &  MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\tpScsiReq->Function = MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH;\n\telse\n\t\tpScsiReq->Function = MPI_FUNCTION_SCSI_IO_REQUEST;\n\tpScsiReq->CDBLength = SCpnt->cmd_len;\n\tpScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;\n\tpScsiReq->Reserved = 0;\n\tpScsiReq->MsgFlags = mpt_msg_flags(ioc);\n\tint_to_scsilun(SCpnt->device->lun, (struct scsi_lun *)pScsiReq->LUN);\n\tpScsiReq->Control = cpu_to_le32(scsictl);\n\n\t \n\tcmd_len = SCpnt->cmd_len;\n\tfor (ii=0; ii < cmd_len; ii++)\n\t\tpScsiReq->CDB[ii] = SCpnt->cmnd[ii];\n\n\tfor (ii=cmd_len; ii < 16; ii++)\n\t\tpScsiReq->CDB[ii] = 0;\n\n\t \n\tpScsiReq->DataLength = cpu_to_le32(datalen);\n\n\t \n\tpScsiReq->SenseBufferLowAddr = cpu_to_le32(ioc->sense_buf_low_dma\n\t\t\t\t\t   + (my_idx * MPT_SENSE_BUFFER_ALLOC));\n\n\t \n\tif (datalen == 0) {\n\t\t \n\t\tioc->add_sge((char *)&pScsiReq->SGL,\n\t\t\tMPT_SGE_FLAGS_SSIMPLE_READ | 0,\n\t\t\t(dma_addr_t) -1);\n\t} else {\n\t\t \n\t\tif (mptscsih_AddSGE(ioc, SCpnt, pScsiReq, my_idx) != SUCCESS)\n\t\t\tgoto fail;\n\t}\n\n\tSCpnt->host_scribble = (unsigned char *)mf;\n\tmptscsih_set_scsi_lookup(ioc, my_idx, SCpnt);\n\n\tmpt_put_msg_frame(ioc->DoneCtx, ioc, mf);\n\tdmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Issued SCSI cmd (%p) mf=%p idx=%d\\n\",\n\t\t\tioc->name, SCpnt, mf, my_idx));\n\tDBG_DUMP_REQUEST_FRAME(ioc, (u32 *)mf);\n\treturn 0;\n\n fail:\n\tmptscsih_freeChainBuffers(ioc, my_idx);\n\tmpt_free_msg_frame(ioc, mf);\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\n \n \nstatic void\nmptscsih_freeChainBuffers(MPT_ADAPTER *ioc, int req_idx)\n{\n\tMPT_FRAME_HDR *chain;\n\tunsigned long flags;\n\tint chain_idx;\n\tint next;\n\n\t \n\tchain_idx = ioc->ReqToChain[req_idx];\n\tioc->ReqToChain[req_idx] = MPT_HOST_NO_CHAIN;\n\n\twhile (chain_idx != MPT_HOST_NO_CHAIN) {\n\n\t\t \n\t\tnext = ioc->ChainToChain[chain_idx];\n\n\t\t \n\t\tioc->ChainToChain[chain_idx] = MPT_HOST_NO_CHAIN;\n\n\t\tchain = (MPT_FRAME_HDR *) (ioc->ChainBuffer\n\t\t\t\t\t+ (chain_idx * ioc->req_sz));\n\n\t\tspin_lock_irqsave(&ioc->FreeQlock, flags);\n\t\tlist_add_tail(&chain->u.frame.linkage.list, &ioc->FreeChainQ);\n\t\tspin_unlock_irqrestore(&ioc->FreeQlock, flags);\n\n\t\tdmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"FreeChainBuffers (index %d)\\n\",\n\t\t\t\tioc->name, chain_idx));\n\n\t\t \n\t\tchain_idx = next;\n\t}\n\treturn;\n}\n\n \n \n\n \n \nint\nmptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 channel, u8 id, u64 lun,\n\tint ctx2abort, ulong timeout)\n{\n\tMPT_FRAME_HDR\t*mf;\n\tSCSITaskMgmt_t\t*pScsiTm;\n\tint\t\t ii;\n\tint\t\t retval;\n\tMPT_ADAPTER \t*ioc = hd->ioc;\n\tu8\t\t issue_hard_reset;\n\tu32\t\t ioc_raw_state;\n\tunsigned long\t time_count;\n\n\tissue_hard_reset = 0;\n\tioc_raw_state = mpt_GetIocState(ioc, 0);\n\n\tif ((ioc_raw_state & MPI_IOC_STATE_MASK) != MPI_IOC_STATE_OPERATIONAL) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\"TaskMgmt type=%x: IOC Not operational (0x%x)!\\n\",\n\t\t\tioc->name, type, ioc_raw_state);\n\t\tprintk(MYIOC_s_WARN_FMT \"Issuing HardReset from %s!!\\n\",\n\t\t    ioc->name, __func__);\n\t\tif (mpt_HardResetHandler(ioc, CAN_SLEEP) < 0)\n\t\t\tprintk(MYIOC_s_WARN_FMT \"TaskMgmt HardReset \"\n\t\t\t    \"FAILED!!\\n\", ioc->name);\n\t\treturn 0;\n\t}\n\n\t \n\n\tif (!((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q)\n\t\t && (ioc->facts.MsgVersion >= MPI_VERSION_01_05)) &&\n\t\t(ioc_raw_state & MPI_DOORBELL_ACTIVE)) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\"TaskMgmt type=%x: ioc_state: \"\n\t\t\t\"DOORBELL_ACTIVE (0x%x)!\\n\",\n\t\t\tioc->name, type, ioc_raw_state);\n\t\treturn FAILED;\n\t}\n\n\tmutex_lock(&ioc->taskmgmt_cmds.mutex);\n\tif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {\n\t\tmf = NULL;\n\t\tretval = FAILED;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((mf = mpt_get_msg_frame(ioc->TaskCtx, ioc)) == NULL) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\"TaskMgmt no msg frames!!\\n\", ioc->name));\n\t\tretval = FAILED;\n\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\tgoto out;\n\t}\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"TaskMgmt request (mf=%p)\\n\",\n\t\t\tioc->name, mf));\n\n\t \n\tpScsiTm = (SCSITaskMgmt_t *) mf;\n\tpScsiTm->TargetID = id;\n\tpScsiTm->Bus = channel;\n\tpScsiTm->ChainOffset = 0;\n\tpScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;\n\n\tpScsiTm->Reserved = 0;\n\tpScsiTm->TaskType = type;\n\tpScsiTm->Reserved1 = 0;\n\tpScsiTm->MsgFlags = (type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS)\n                    ? MPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION : 0;\n\n\tint_to_scsilun(lun, (struct scsi_lun *)pScsiTm->LUN);\n\n\tfor (ii=0; ii < 7; ii++)\n\t\tpScsiTm->Reserved2[ii] = 0;\n\n\tpScsiTm->TaskMsgContext = ctx2abort;\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"TaskMgmt: ctx2abort (0x%08x) \"\n\t\t\"task_type = 0x%02X, timeout = %ld\\n\", ioc->name, ctx2abort,\n\t\ttype, timeout));\n\n\tDBG_DUMP_TM_REQUEST_FRAME(ioc, (u32 *)pScsiTm);\n\n\tINITIALIZE_MGMT_STATUS(ioc->taskmgmt_cmds.status)\n\ttime_count = jiffies;\n\tif ((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q) &&\n\t    (ioc->facts.MsgVersion >= MPI_VERSION_01_05))\n\t\tmpt_put_msg_frame_hi_pri(ioc->TaskCtx, ioc, mf);\n\telse {\n\t\tretval = mpt_send_handshake_request(ioc->TaskCtx, ioc,\n\t\t\tsizeof(SCSITaskMgmt_t), (u32*)pScsiTm, CAN_SLEEP);\n\t\tif (retval) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t\"TaskMgmt handshake FAILED!(mf=%p, rc=%d) \\n\",\n\t\t\t\tioc->name, mf, retval));\n\t\t\tmpt_free_msg_frame(ioc, mf);\n\t\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twait_for_completion_timeout(&ioc->taskmgmt_cmds.done,\n\t\ttimeout*HZ);\n\tif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tretval = FAILED;\n\t\tdtmprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t    \"TaskMgmt TIMED OUT!(mf=%p)\\n\", ioc->name, mf));\n\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\tif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\n\t\t\tgoto out;\n\t\tissue_hard_reset = 1;\n\t\tgoto out;\n\t}\n\n\tretval = mptscsih_taskmgmt_reply(ioc, type,\n\t    (SCSITaskMgmtReply_t *) ioc->taskmgmt_cmds.reply);\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"TaskMgmt completed (%d seconds)\\n\",\n\t    ioc->name, jiffies_to_msecs(jiffies - time_count)/1000));\n\n out:\n\n\tCLEAR_MGMT_STATUS(ioc->taskmgmt_cmds.status)\n\tif (issue_hard_reset) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t       \"Issuing Reset from %s!! doorbell=0x%08x\\n\",\n\t\t       ioc->name, __func__, mpt_GetIocState(ioc, 0));\n\t\tretval = (ioc->bus_type == SAS) ?\n\t\t\tmpt_HardResetHandler(ioc, CAN_SLEEP) :\n\t\t\tmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\n\t\tmpt_free_msg_frame(ioc, mf);\n\t}\n\n\tretval = (retval == 0) ? 0 : FAILED;\n\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\treturn retval;\n}\nEXPORT_SYMBOL(mptscsih_IssueTaskMgmt);\n\nstatic int\nmptscsih_get_tm_timeout(MPT_ADAPTER *ioc)\n{\n\tswitch (ioc->bus_type) {\n\tcase FC:\n\t\treturn 40;\n\tcase SAS:\n\t\treturn 30;\n\tcase SPI:\n\tdefault:\n\t\treturn 10;\n\t}\n}\n\n \n \nint\nmptscsih_abort(struct scsi_cmnd * SCpnt)\n{\n\tMPT_SCSI_HOST\t*hd;\n\tMPT_FRAME_HDR\t*mf;\n\tu32\t\t ctx2abort;\n\tint\t\t scpnt_idx;\n\tint\t\t retval;\n\tVirtDevice\t *vdevice;\n\tMPT_ADAPTER\t*ioc;\n\n\t \n\tif ((hd = shost_priv(SCpnt->device->host)) == NULL) {\n\t\tSCpnt->result = DID_RESET << 16;\n\t\tscsi_done(SCpnt);\n\t\tprintk(KERN_ERR MYNAM \": task abort: \"\n\t\t    \"can't locate host! (sc=%p)\\n\", SCpnt);\n\t\treturn FAILED;\n\t}\n\n\tioc = hd->ioc;\n\tprintk(MYIOC_s_INFO_FMT \"attempting task abort! (sc=%p)\\n\",\n\t       ioc->name, SCpnt);\n\tscsi_print_command(SCpnt);\n\n\tvdevice = SCpnt->device->hostdata;\n\tif (!vdevice || !vdevice->vtarget) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"task abort: device has been deleted (sc=%p)\\n\",\n\t\t    ioc->name, SCpnt));\n\t\tSCpnt->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(SCpnt);\n\t\tretval = SUCCESS;\n\t\tgoto out;\n\t}\n\n\t \n\tif (vdevice->vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"task abort: hidden raid component (sc=%p)\\n\",\n\t\t    ioc->name, SCpnt));\n\t\tSCpnt->result = DID_RESET << 16;\n\t\tretval = FAILED;\n\t\tgoto out;\n\t}\n\n\t \n\tif (vdevice->vtarget->raidVolume) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"task abort: raid volume (sc=%p)\\n\",\n\t\t    ioc->name, SCpnt));\n\t\tSCpnt->result = DID_RESET << 16;\n\t\tretval = FAILED;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(ioc, SCpnt)) < 0) {\n\t\t \n\t\tSCpnt->result = DID_RESET << 16;\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"task abort: \"\n\t\t   \"Command not in the active list! (sc=%p)\\n\", ioc->name,\n\t\t   SCpnt));\n\t\tretval = SUCCESS;\n\t\tgoto out;\n\t}\n\n\tif (ioc->timeouts < -1)\n\t\tioc->timeouts++;\n\n\tif (mpt_fwfault_debug)\n\t\tmpt_halt_firmware(ioc);\n\n\t \n\tmf = MPT_INDEX_2_MFPTR(ioc, scpnt_idx);\n\tctx2abort = mf->u.frame.hwhdr.msgctxu.MsgContext;\n\tretval = mptscsih_IssueTaskMgmt(hd,\n\t\t\t MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK,\n\t\t\t vdevice->vtarget->channel,\n\t\t\t vdevice->vtarget->id, vdevice->lun,\n\t\t\t ctx2abort, mptscsih_get_tm_timeout(ioc));\n\n\tif (SCPNT_TO_LOOKUP_IDX(ioc, SCpnt) == scpnt_idx) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"task abort: command still in active list! (sc=%p)\\n\",\n\t\t    ioc->name, SCpnt));\n\t\tretval = FAILED;\n\t} else {\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"task abort: command cleared from active list! (sc=%p)\\n\",\n\t\t    ioc->name, SCpnt));\n\t\tretval = SUCCESS;\n\t}\n\n out:\n\tprintk(MYIOC_s_INFO_FMT \"task abort: %s (rv=%04x) (sc=%p)\\n\",\n\t    ioc->name, ((retval == SUCCESS) ? \"SUCCESS\" : \"FAILED\"), retval,\n\t    SCpnt);\n\n\treturn retval;\n}\n\n \n \nint\nmptscsih_dev_reset(struct scsi_cmnd * SCpnt)\n{\n\tMPT_SCSI_HOST\t*hd;\n\tint\t\t retval;\n\tVirtDevice\t *vdevice;\n\tMPT_ADAPTER\t*ioc;\n\n\t \n\tif ((hd = shost_priv(SCpnt->device->host)) == NULL){\n\t\tprintk(KERN_ERR MYNAM \": target reset: \"\n\t\t   \"Can't locate host! (sc=%p)\\n\", SCpnt);\n\t\treturn FAILED;\n\t}\n\n\tioc = hd->ioc;\n\tprintk(MYIOC_s_INFO_FMT \"attempting target reset! (sc=%p)\\n\",\n\t       ioc->name, SCpnt);\n\tscsi_print_command(SCpnt);\n\n\tvdevice = SCpnt->device->hostdata;\n\tif (!vdevice || !vdevice->vtarget) {\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (vdevice->vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT) {\n\t\tretval = FAILED;\n\t\tgoto out;\n\t}\n\n\tretval = mptscsih_IssueTaskMgmt(hd,\n\t\t\t\tMPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET,\n\t\t\t\tvdevice->vtarget->channel,\n\t\t\t\tvdevice->vtarget->id, 0, 0,\n\t\t\t\tmptscsih_get_tm_timeout(ioc));\n\n out:\n\tprintk (MYIOC_s_INFO_FMT \"target reset: %s (sc=%p)\\n\",\n\t    ioc->name, ((retval == 0) ? \"SUCCESS\" : \"FAILED\" ), SCpnt);\n\n\tif (retval == 0)\n\t\treturn SUCCESS;\n\telse\n\t\treturn FAILED;\n}\n\n\n \n \nint\nmptscsih_bus_reset(struct scsi_cmnd * SCpnt)\n{\n\tMPT_SCSI_HOST\t*hd;\n\tint\t\t retval;\n\tVirtDevice\t *vdevice;\n\tMPT_ADAPTER\t*ioc;\n\n\t \n\tif ((hd = shost_priv(SCpnt->device->host)) == NULL){\n\t\tprintk(KERN_ERR MYNAM \": bus reset: \"\n\t\t   \"Can't locate host! (sc=%p)\\n\", SCpnt);\n\t\treturn FAILED;\n\t}\n\n\tioc = hd->ioc;\n\tprintk(MYIOC_s_INFO_FMT \"attempting bus reset! (sc=%p)\\n\",\n\t       ioc->name, SCpnt);\n\tscsi_print_command(SCpnt);\n\n\tif (ioc->timeouts < -1)\n\t\tioc->timeouts++;\n\n\tvdevice = SCpnt->device->hostdata;\n\tif (!vdevice || !vdevice->vtarget)\n\t\treturn SUCCESS;\n\tretval = mptscsih_IssueTaskMgmt(hd,\n\t\t\t\t\tMPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,\n\t\t\t\t\tvdevice->vtarget->channel, 0, 0, 0,\n\t\t\t\t\tmptscsih_get_tm_timeout(ioc));\n\n\tprintk(MYIOC_s_INFO_FMT \"bus reset: %s (sc=%p)\\n\",\n\t    ioc->name, ((retval == 0) ? \"SUCCESS\" : \"FAILED\" ), SCpnt);\n\n\tif (retval == 0)\n\t\treturn SUCCESS;\n\telse\n\t\treturn FAILED;\n}\n\n \n \nint\nmptscsih_host_reset(struct scsi_cmnd *SCpnt)\n{\n\tMPT_SCSI_HOST *  hd;\n\tint              status = SUCCESS;\n\tMPT_ADAPTER\t*ioc;\n\tint\t\tretval;\n\n\t \n\tif ((hd = shost_priv(SCpnt->device->host)) == NULL){\n\t\tprintk(KERN_ERR MYNAM \": host reset: \"\n\t\t    \"Can't locate host! (sc=%p)\\n\", SCpnt);\n\t\treturn FAILED;\n\t}\n\n\t \n\tmptscsih_flush_running_cmds(hd);\n\n\tioc = hd->ioc;\n\tprintk(MYIOC_s_INFO_FMT \"attempting host reset! (sc=%p)\\n\",\n\t    ioc->name, SCpnt);\n\n\t \n\tretval = mpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\n\tif (retval < 0)\n\t\tstatus = FAILED;\n\telse\n\t\tstatus = SUCCESS;\n\n\tprintk(MYIOC_s_INFO_FMT \"host reset: %s (sc=%p)\\n\",\n\t    ioc->name, ((retval == 0) ? \"SUCCESS\" : \"FAILED\" ), SCpnt);\n\n\treturn status;\n}\n\nstatic int\nmptscsih_taskmgmt_reply(MPT_ADAPTER *ioc, u8 type,\n\tSCSITaskMgmtReply_t *pScsiTmReply)\n{\n\tu16\t\t\t iocstatus;\n\tu32\t\t\t termination_count;\n\tint\t\t\t retval;\n\n\tif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\n\t\tretval = FAILED;\n\t\tgoto out;\n\t}\n\n\tDBG_DUMP_TM_REPLY_FRAME(ioc, (u32 *)pScsiTmReply);\n\n\tiocstatus = le16_to_cpu(pScsiTmReply->IOCStatus) & MPI_IOCSTATUS_MASK;\n\ttermination_count = le32_to_cpu(pScsiTmReply->TerminationCount);\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"TaskMgmt fw_channel = %d, fw_id = %d, task_type = 0x%02X,\\n\"\n\t    \"\\tiocstatus = 0x%04X, loginfo = 0x%08X, response_code = 0x%02X,\\n\"\n\t    \"\\tterm_cmnds = %d\\n\", ioc->name, pScsiTmReply->Bus,\n\t    pScsiTmReply->TargetID, type, le16_to_cpu(pScsiTmReply->IOCStatus),\n\t    le32_to_cpu(pScsiTmReply->IOCLogInfo), pScsiTmReply->ResponseCode,\n\t    termination_count));\n\n\tif (ioc->facts.MsgVersion >= MPI_VERSION_01_05 &&\n\t    pScsiTmReply->ResponseCode)\n\t\tmptscsih_taskmgmt_response_code(ioc,\n\t\t    pScsiTmReply->ResponseCode);\n\n\tif (iocstatus == MPI_IOCSTATUS_SUCCESS) {\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\n\tretval = FAILED;\n\tif (type == MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK) {\n\t\tif (termination_count == 1)\n\t\t\tretval = 0;\n\t\tgoto out;\n\t}\n\n\tif (iocstatus == MPI_IOCSTATUS_SCSI_TASK_TERMINATED ||\n\t   iocstatus == MPI_IOCSTATUS_SCSI_IOC_TERMINATED)\n\t\tretval = 0;\n\n out:\n\treturn retval;\n}\n\n \nvoid\nmptscsih_taskmgmt_response_code(MPT_ADAPTER *ioc, u8 response_code)\n{\n\tchar *desc;\n\n\tswitch (response_code) {\n\tcase MPI_SCSITASKMGMT_RSP_TM_COMPLETE:\n\t\tdesc = \"The task completed.\";\n\t\tbreak;\n\tcase MPI_SCSITASKMGMT_RSP_INVALID_FRAME:\n\t\tdesc = \"The IOC received an invalid frame status.\";\n\t\tbreak;\n\tcase MPI_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED:\n\t\tdesc = \"The task type is not supported.\";\n\t\tbreak;\n\tcase MPI_SCSITASKMGMT_RSP_TM_FAILED:\n\t\tdesc = \"The requested task failed.\";\n\t\tbreak;\n\tcase MPI_SCSITASKMGMT_RSP_TM_SUCCEEDED:\n\t\tdesc = \"The task completed successfully.\";\n\t\tbreak;\n\tcase MPI_SCSITASKMGMT_RSP_TM_INVALID_LUN:\n\t\tdesc = \"The LUN request is invalid.\";\n\t\tbreak;\n\tcase MPI_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC:\n\t\tdesc = \"The task is in the IOC queue and has not been sent to target.\";\n\t\tbreak;\n\tdefault:\n\t\tdesc = \"unknown\";\n\t\tbreak;\n\t}\n\tprintk(MYIOC_s_INFO_FMT \"Response Code(0x%08x): F/W: %s\\n\",\n\t\tioc->name, response_code, desc);\n}\nEXPORT_SYMBOL(mptscsih_taskmgmt_response_code);\n\n \n \nint\nmptscsih_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf,\n\tMPT_FRAME_HDR *mr)\n{\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"TaskMgmt completed (mf=%p, mr=%p)\\n\", ioc->name, mf, mr));\n\n\tioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\n\n\tif (!mr)\n\t\tgoto out;\n\n\tioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\n\tmemcpy(ioc->taskmgmt_cmds.reply, mr,\n\t    min(MPT_DEFAULT_FRAME_SIZE, 4 * mr->u.reply.MsgLength));\n out:\n\tif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\t\tioc->taskmgmt_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\tcomplete(&ioc->taskmgmt_cmds.done);\n\t\tif (ioc->bus_type == SAS)\n\t\t\tioc->schedule_target_reset(ioc);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n \nint\nmptscsih_bios_param(struct scsi_device * sdev, struct block_device *bdev,\n\t\tsector_t capacity, int geom[])\n{\n\tint\t\theads;\n\tint\t\tsectors;\n\tsector_t\tcylinders;\n\tulong \t\tdummy;\n\n\theads = 64;\n\tsectors = 32;\n\n\tdummy = heads * sectors;\n\tcylinders = capacity;\n\tsector_div(cylinders,dummy);\n\n\t \n\tif ((ulong)capacity >= 0x200000) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\tdummy = heads * sectors;\n\t\tcylinders = capacity;\n\t\tsector_div(cylinders,dummy);\n\t}\n\n\t \n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\n\treturn 0;\n}\n\n \nint\nmptscsih_is_phys_disk(MPT_ADAPTER *ioc, u8 channel, u8 id)\n{\n\tstruct inactive_raid_component_info *component_info;\n\tint i, j;\n\tRaidPhysDiskPage1_t *phys_disk;\n\tint rc = 0;\n\tint num_paths;\n\n\tif (!ioc->raid_data.pIocPg3)\n\t\tgoto out;\n\tfor (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++) {\n\t\tif ((id == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskID) &&\n\t\t    (channel == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskBus)) {\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ioc->bus_type != SAS)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++) {\n\t\tnum_paths = mpt_raid_phys_disk_get_num_paths(ioc,\n\t\t    ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum);\n\t\tif (num_paths < 2)\n\t\t\tcontinue;\n\t\tphys_disk = kzalloc(offsetof(RaidPhysDiskPage1_t, Path) +\n\t\t   (num_paths * sizeof(RAID_PHYS_DISK1_PATH)), GFP_KERNEL);\n\t\tif (!phys_disk)\n\t\t\tcontinue;\n\t\tif ((mpt_raid_phys_disk_pg1(ioc,\n\t\t    ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum,\n\t\t    phys_disk))) {\n\t\t\tkfree(phys_disk);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < num_paths; j++) {\n\t\t\tif ((phys_disk->Path[j].Flags &\n\t\t\t    MPI_RAID_PHYSDISK1_FLAG_INVALID))\n\t\t\t\tcontinue;\n\t\t\tif ((phys_disk->Path[j].Flags &\n\t\t\t    MPI_RAID_PHYSDISK1_FLAG_BROKEN))\n\t\t\t\tcontinue;\n\t\t\tif ((id == phys_disk->Path[j].PhysDiskID) &&\n\t\t\t    (channel == phys_disk->Path[j].PhysDiskBus)) {\n\t\t\t\trc = 1;\n\t\t\t\tkfree(phys_disk);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tkfree(phys_disk);\n\t}\n\n\n\t \n\tif (list_empty(&ioc->raid_data.inactive_list))\n\t\tgoto out;\n\n\tmutex_lock(&ioc->raid_data.inactive_list_mutex);\n\tlist_for_each_entry(component_info, &ioc->raid_data.inactive_list,\n\t    list) {\n\t\tif ((component_info->d.PhysDiskID == id) &&\n\t\t    (component_info->d.PhysDiskBus == channel))\n\t\t\trc = 1;\n\t}\n\tmutex_unlock(&ioc->raid_data.inactive_list_mutex);\n\n out:\n\treturn rc;\n}\nEXPORT_SYMBOL(mptscsih_is_phys_disk);\n\nu8\nmptscsih_raid_id_to_num(MPT_ADAPTER *ioc, u8 channel, u8 id)\n{\n\tstruct inactive_raid_component_info *component_info;\n\tint i, j;\n\tRaidPhysDiskPage1_t *phys_disk;\n\tint rc = -ENXIO;\n\tint num_paths;\n\n\tif (!ioc->raid_data.pIocPg3)\n\t\tgoto out;\n\tfor (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++) {\n\t\tif ((id == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskID) &&\n\t\t    (channel == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskBus)) {\n\t\t\trc = ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ioc->bus_type != SAS)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++) {\n\t\tnum_paths = mpt_raid_phys_disk_get_num_paths(ioc,\n\t\t    ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum);\n\t\tif (num_paths < 2)\n\t\t\tcontinue;\n\t\tphys_disk = kzalloc(offsetof(RaidPhysDiskPage1_t, Path) +\n\t\t   (num_paths * sizeof(RAID_PHYS_DISK1_PATH)), GFP_KERNEL);\n\t\tif (!phys_disk)\n\t\t\tcontinue;\n\t\tif ((mpt_raid_phys_disk_pg1(ioc,\n\t\t    ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum,\n\t\t    phys_disk))) {\n\t\t\tkfree(phys_disk);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < num_paths; j++) {\n\t\t\tif ((phys_disk->Path[j].Flags &\n\t\t\t    MPI_RAID_PHYSDISK1_FLAG_INVALID))\n\t\t\t\tcontinue;\n\t\t\tif ((phys_disk->Path[j].Flags &\n\t\t\t    MPI_RAID_PHYSDISK1_FLAG_BROKEN))\n\t\t\t\tcontinue;\n\t\t\tif ((id == phys_disk->Path[j].PhysDiskID) &&\n\t\t\t    (channel == phys_disk->Path[j].PhysDiskBus)) {\n\t\t\t\trc = phys_disk->PhysDiskNum;\n\t\t\t\tkfree(phys_disk);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tkfree(phys_disk);\n\t}\n\n\t \n\tif (list_empty(&ioc->raid_data.inactive_list))\n\t\tgoto out;\n\n\tmutex_lock(&ioc->raid_data.inactive_list_mutex);\n\tlist_for_each_entry(component_info, &ioc->raid_data.inactive_list,\n\t    list) {\n\t\tif ((component_info->d.PhysDiskID == id) &&\n\t\t    (component_info->d.PhysDiskBus == channel))\n\t\t\trc = component_info->d.PhysDiskNum;\n\t}\n\tmutex_unlock(&ioc->raid_data.inactive_list_mutex);\n\n out:\n\treturn rc;\n}\nEXPORT_SYMBOL(mptscsih_raid_id_to_num);\n\n \nvoid\nmptscsih_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host\t*host = sdev->host;\n\tMPT_SCSI_HOST\t\t*hd = shost_priv(host);\n\tVirtTarget\t\t*vtarget;\n\tVirtDevice\t\t*vdevice;\n\tstruct scsi_target \t*starget;\n\n\tstarget = scsi_target(sdev);\n\tvtarget = starget->hostdata;\n\tvdevice = sdev->hostdata;\n\tif (!vdevice)\n\t\treturn;\n\n\tmptscsih_search_running_cmds(hd, vdevice);\n\tvtarget->num_luns--;\n\tmptscsih_synchronize_cache(hd, vdevice);\n\tkfree(vdevice);\n\tsdev->hostdata = NULL;\n}\n\n \n \nint\nmptscsih_change_queue_depth(struct scsi_device *sdev, int qdepth)\n{\n\tMPT_SCSI_HOST\t\t*hd = shost_priv(sdev->host);\n\tVirtTarget \t\t*vtarget;\n\tstruct scsi_target \t*starget;\n\tint\t\t\tmax_depth;\n\tMPT_ADAPTER\t\t*ioc = hd->ioc;\n\n\tstarget = scsi_target(sdev);\n\tvtarget = starget->hostdata;\n\n\tif (ioc->bus_type == SPI) {\n\t\tif (!(vtarget->tflags & MPT_TARGET_FLAGS_Q_YES))\n\t\t\tmax_depth = 1;\n\t\telse if (sdev->type == TYPE_DISK &&\n\t\t\t vtarget->minSyncFactor <= MPT_ULTRA160)\n\t\t\tmax_depth = MPT_SCSI_CMD_PER_DEV_HIGH;\n\t\telse\n\t\t\tmax_depth = MPT_SCSI_CMD_PER_DEV_LOW;\n\t} else\n\t\t max_depth = ioc->sh->can_queue;\n\n\tif (!sdev->tagged_supported)\n\t\tmax_depth = 1;\n\n\tif (qdepth > max_depth)\n\t\tqdepth = max_depth;\n\n\treturn scsi_change_queue_depth(sdev, qdepth);\n}\n\n \nint\nmptscsih_slave_configure(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host\t*sh = sdev->host;\n\tVirtTarget\t\t*vtarget;\n\tVirtDevice\t\t*vdevice;\n\tstruct scsi_target \t*starget;\n\tMPT_SCSI_HOST\t\t*hd = shost_priv(sh);\n\tMPT_ADAPTER\t\t*ioc = hd->ioc;\n\n\tstarget = scsi_target(sdev);\n\tvtarget = starget->hostdata;\n\tvdevice = sdev->hostdata;\n\n\tdsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"device @ %p, channel=%d, id=%d, lun=%llu\\n\",\n\t\tioc->name, sdev, sdev->channel, sdev->id, sdev->lun));\n\tif (ioc->bus_type == SPI)\n\t\tdsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"sdtr %d wdtr %d ppr %d inq length=%d\\n\",\n\t\t    ioc->name, sdev->sdtr, sdev->wdtr,\n\t\t    sdev->ppr, sdev->inquiry_len));\n\n\tvdevice->configured_lun = 1;\n\n\tdsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"Queue depth=%d, tflags=%x\\n\",\n\t\tioc->name, sdev->queue_depth, vtarget->tflags));\n\n\tif (ioc->bus_type == SPI)\n\t\tdsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"negoFlags=%x, maxOffset=%x, SyncFactor=%x\\n\",\n\t\t    ioc->name, vtarget->negoFlags, vtarget->maxOffset,\n\t\t    vtarget->minSyncFactor));\n\n\tmptscsih_change_queue_depth(sdev, MPT_SCSI_CMD_PER_DEV_HIGH);\n\tdsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"tagged %d, simple %d\\n\",\n\t\tioc->name,sdev->tagged_supported, sdev->simple_tags));\n\n\tblk_queue_dma_alignment (sdev->request_queue, 512 - 1);\n\n\treturn 0;\n}\n\n \n \n\n \n \nstatic void\nmptscsih_copy_sense_data(struct scsi_cmnd *sc, MPT_SCSI_HOST *hd, MPT_FRAME_HDR *mf, SCSIIOReply_t *pScsiReply)\n{\n\tVirtDevice\t*vdevice;\n\tSCSIIORequest_t\t*pReq;\n\tu32\t\t sense_count = le32_to_cpu(pScsiReply->SenseCount);\n\tMPT_ADAPTER \t*ioc = hd->ioc;\n\n\t \n\tpReq = (SCSIIORequest_t *) mf;\n\tvdevice = sc->device->hostdata;\n\n\tif (sense_count) {\n\t\tu8 *sense_data;\n\t\tint req_index;\n\n\t\t \n\t\treq_index = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\n\t\tsense_data = ((u8 *)ioc->sense_buf_pool + (req_index * MPT_SENSE_BUFFER_ALLOC));\n\t\tmemcpy(sc->sense_buffer, sense_data, MPT_SENSE_BUFFER_ALLOC);\n\n\t\t \n\t\tif ((ioc->events) && (ioc->eventTypes & (1 << MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE))) {\n\t\t\tif ((sense_data[12] == 0x5D) && (vdevice->vtarget->raidVolume == 0)) {\n\t\t\t\tint idx;\n\n\t\t\t\tidx = ioc->eventContext % MPTCTL_EVENT_LOG_SIZE;\n\t\t\t\tioc->events[idx].event = MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE;\n\t\t\t\tioc->events[idx].eventContext = ioc->eventContext;\n\n\t\t\t\tioc->events[idx].data[0] = (pReq->LUN[1] << 24) |\n\t\t\t\t\t(MPI_EVENT_SCSI_DEV_STAT_RC_SMART_DATA << 16) |\n\t\t\t\t\t(sc->device->channel << 8) | sc->device->id;\n\n\t\t\t\tioc->events[idx].data[1] = (sense_data[13] << 8) | sense_data[12];\n\n\t\t\t\tioc->eventContext++;\n\t\t\t\tif (ioc->pcidev->vendor ==\n\t\t\t\t    PCI_VENDOR_ID_IBM) {\n\t\t\t\t\tmptscsih_issue_sep_command(ioc,\n\t\t\t\t\t    vdevice->vtarget, MPI_SEP_REQ_SLOTSTATUS_PREDICTED_FAULT);\n\t\t\t\t\tvdevice->vtarget->tflags |=\n\t\t\t\t\t    MPT_TARGET_FLAGS_LED_ON;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Hmmm... SenseData len=0! (?)\\n\",\n\t\t\t\tioc->name));\n\t}\n}\n\n \nstruct scsi_cmnd *\nmptscsih_get_scsi_lookup(MPT_ADAPTER *ioc, int i)\n{\n\tunsigned long\tflags;\n\tstruct scsi_cmnd *scmd;\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tscmd = ioc->ScsiLookup[i];\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\n\treturn scmd;\n}\nEXPORT_SYMBOL(mptscsih_get_scsi_lookup);\n\n \nstatic struct scsi_cmnd *\nmptscsih_getclear_scsi_lookup(MPT_ADAPTER *ioc, int i)\n{\n\tunsigned long\tflags;\n\tstruct scsi_cmnd *scmd;\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tscmd = ioc->ScsiLookup[i];\n\tioc->ScsiLookup[i] = NULL;\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\n\treturn scmd;\n}\n\n \nstatic void\nmptscsih_set_scsi_lookup(MPT_ADAPTER *ioc, int i, struct scsi_cmnd *scmd)\n{\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tioc->ScsiLookup[i] = scmd;\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n}\n\n \nstatic int\nSCPNT_TO_LOOKUP_IDX(MPT_ADAPTER *ioc, struct scsi_cmnd *sc)\n{\n\tunsigned long\tflags;\n\tint i, index=-1;\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tfor (i = 0; i < ioc->req_depth; i++) {\n\t\tif (ioc->ScsiLookup[i] == sc) {\n\t\t\tindex = i;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\treturn index;\n}\n\n \nint\nmptscsih_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\n{\n\tMPT_SCSI_HOST\t*hd;\n\n\tif (ioc->sh == NULL || shost_priv(ioc->sh) == NULL)\n\t\treturn 0;\n\n\thd = shost_priv(ioc->sh);\n\tswitch (reset_phase) {\n\tcase MPT_IOC_SETUP_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_SETUP_RESET\\n\", ioc->name, __func__));\n\t\tbreak;\n\tcase MPT_IOC_PRE_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_PRE_RESET\\n\", ioc->name, __func__));\n\t\tmptscsih_flush_running_cmds(hd);\n\t\tbreak;\n\tcase MPT_IOC_POST_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_POST_RESET\\n\", ioc->name, __func__));\n\t\tif (ioc->internal_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\t\tioc->internal_cmds.status |=\n\t\t\t\tMPT_MGMT_STATUS_DID_IOCRESET;\n\t\t\tcomplete(&ioc->internal_cmds.done);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 1;\t\t \n}\n\n \nint\nmptscsih_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)\n{\n\tu8 event = le32_to_cpu(pEvReply->Event) & 0xFF;\n\n\tdevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"MPT event (=%02Xh) routed to SCSI host driver!\\n\",\n\t\tioc->name, event));\n\n\tif ((event == MPI_EVENT_IOC_BUS_RESET ||\n\t    event == MPI_EVENT_EXT_BUS_RESET) &&\n\t    (ioc->bus_type == SPI) && (ioc->soft_resets < -1))\n\t\t\tioc->soft_resets++;\n\n\treturn 1;\t\t \n}\n\n \n \n\n \n \nint\nmptscsih_scandv_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req,\n\t\t\t\tMPT_FRAME_HDR *reply)\n{\n\tSCSIIORequest_t *pReq;\n\tSCSIIOReply_t\t*pReply;\n\tu8\t\t cmd;\n\tu16\t\t req_idx;\n\tu8\t*sense_data;\n\tint\t\t sz;\n\n\tioc->internal_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\n\tioc->internal_cmds.completion_code = MPT_SCANDV_GOOD;\n\tif (!reply)\n\t\tgoto out;\n\n\tpReply = (SCSIIOReply_t *) reply;\n\tpReq = (SCSIIORequest_t *) req;\n\tioc->internal_cmds.completion_code =\n\t    mptscsih_get_completion_code(ioc, req, reply);\n\tioc->internal_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\n\tmemcpy(ioc->internal_cmds.reply, reply,\n\t    min(MPT_DEFAULT_FRAME_SIZE, 4 * reply->u.reply.MsgLength));\n\tcmd = reply->u.hdr.Function;\n\tif (((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) ||\n\t    (cmd == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) &&\n\t    (pReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID)) {\n\t\treq_idx = le16_to_cpu(req->u.frame.hwhdr.msgctxu.fld.req_idx);\n\t\tsense_data = ((u8 *)ioc->sense_buf_pool +\n\t\t    (req_idx * MPT_SENSE_BUFFER_ALLOC));\n\t\tsz = min_t(int, pReq->SenseBufferLength,\n\t\t    MPT_SENSE_BUFFER_ALLOC);\n\t\tmemcpy(ioc->internal_cmds.sense, sense_data, sz);\n\t}\n out:\n\tif (!(ioc->internal_cmds.status & MPT_MGMT_STATUS_PENDING))\n\t\treturn 0;\n\tioc->internal_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\tcomplete(&ioc->internal_cmds.done);\n\treturn 1;\n}\n\n\n \nstatic int\nmptscsih_get_completion_code(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req,\n\t\t\t\tMPT_FRAME_HDR *reply)\n{\n\tSCSIIOReply_t\t*pReply;\n\tMpiRaidActionReply_t *pr;\n\tu8\t\t scsi_status;\n\tu16\t\t status;\n\tint\t\t completion_code;\n\n\tpReply = (SCSIIOReply_t *)reply;\n\tstatus = le16_to_cpu(pReply->IOCStatus) & MPI_IOCSTATUS_MASK;\n\tscsi_status = pReply->SCSIStatus;\n\n\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"IOCStatus=%04xh, SCSIState=%02xh, SCSIStatus=%02xh,\"\n\t    \"IOCLogInfo=%08xh\\n\", ioc->name, status, pReply->SCSIState,\n\t    scsi_status, le32_to_cpu(pReply->IOCLogInfo)));\n\n\tswitch (status) {\n\n\tcase MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\t \n\t\tcompletion_code = MPT_SCANDV_SELECTION_TIMEOUT;\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_SCSI_IO_DATA_ERROR:\t\t \n\tcase MPI_IOCSTATUS_SCSI_TASK_TERMINATED:\t \n\tcase MPI_IOCSTATUS_SCSI_IOC_TERMINATED:\t\t \n\tcase MPI_IOCSTATUS_SCSI_EXT_TERMINATED:\t\t \n\t\tcompletion_code = MPT_SCANDV_DID_RESET;\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_BUSY:\n\tcase MPI_IOCSTATUS_INSUFFICIENT_RESOURCES:\n\t\tcompletion_code = MPT_SCANDV_BUSY;\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:\t\t \n\tcase MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:\t \n\tcase MPI_IOCSTATUS_SUCCESS:\t\t\t \n\t\tif (pReply->Function == MPI_FUNCTION_CONFIG) {\n\t\t\tcompletion_code = MPT_SCANDV_GOOD;\n\t\t} else if (pReply->Function == MPI_FUNCTION_RAID_ACTION) {\n\t\t\tpr = (MpiRaidActionReply_t *)reply;\n\t\t\tif (le16_to_cpu(pr->ActionStatus) ==\n\t\t\t\tMPI_RAID_ACTION_ASTATUS_SUCCESS)\n\t\t\t\tcompletion_code = MPT_SCANDV_GOOD;\n\t\t\telse\n\t\t\t\tcompletion_code = MPT_SCANDV_SOME_ERROR;\n\t\t} else if (pReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID)\n\t\t\tcompletion_code = MPT_SCANDV_SENSE;\n\t\telse if (pReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_FAILED) {\n\t\t\tif (req->u.scsireq.CDB[0] == INQUIRY)\n\t\t\t\tcompletion_code = MPT_SCANDV_ISSUE_SENSE;\n\t\t\telse\n\t\t\t\tcompletion_code = MPT_SCANDV_DID_RESET;\n\t\t} else if (pReply->SCSIState & MPI_SCSI_STATE_NO_SCSI_STATUS)\n\t\t\tcompletion_code = MPT_SCANDV_DID_RESET;\n\t\telse if (pReply->SCSIState & MPI_SCSI_STATE_TERMINATED)\n\t\t\tcompletion_code = MPT_SCANDV_DID_RESET;\n\t\telse if (scsi_status == MPI_SCSI_STATUS_BUSY)\n\t\t\tcompletion_code = MPT_SCANDV_BUSY;\n\t\telse\n\t\t\tcompletion_code = MPT_SCANDV_GOOD;\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:\t\t \n\t\tif (pReply->SCSIState & MPI_SCSI_STATE_TERMINATED)\n\t\t\tcompletion_code = MPT_SCANDV_DID_RESET;\n\t\telse\n\t\t\tcompletion_code = MPT_SCANDV_SOME_ERROR;\n\t\tbreak;\n\tdefault:\n\t\tcompletion_code = MPT_SCANDV_SOME_ERROR;\n\t\tbreak;\n\n\t}\t \n\n\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"  completionCode set to %08xh\\n\", ioc->name, completion_code));\n\treturn completion_code;\n}\n\n \n \nstatic int\nmptscsih_do_cmd(MPT_SCSI_HOST *hd, INTERNAL_CMD *io)\n{\n\tMPT_FRAME_HDR\t*mf;\n\tSCSIIORequest_t\t*pScsiReq;\n\tint\t\t my_idx, ii, dir;\n\tint\t\t timeout;\n\tchar\t\t cmdLen;\n\tchar\t\t CDB[]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n\tu8\t\t cmd = io->cmd;\n\tMPT_ADAPTER *ioc = hd->ioc;\n\tint\t\t ret = 0;\n\tunsigned long\t timeleft;\n\tunsigned long\t flags;\n\n\t \n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress) {\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\tdfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"%s: busy with host reset\\n\", ioc->name, __func__));\n\t\treturn MPT_SCANDV_BUSY;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\tmutex_lock(&ioc->internal_cmds.mutex);\n\n\t \n\tswitch (cmd) {\n\tcase INQUIRY:\n\t\tcmdLen = 6;\n\t\tdir = MPI_SCSIIO_CONTROL_READ;\n\t\tCDB[0] = cmd;\n\t\tCDB[4] = io->size;\n\t\ttimeout = 10;\n\t\tbreak;\n\n\tcase TEST_UNIT_READY:\n\t\tcmdLen = 6;\n\t\tdir = MPI_SCSIIO_CONTROL_READ;\n\t\ttimeout = 10;\n\t\tbreak;\n\n\tcase START_STOP:\n\t\tcmdLen = 6;\n\t\tdir = MPI_SCSIIO_CONTROL_READ;\n\t\tCDB[0] = cmd;\n\t\tCDB[4] = 1;\t \n\t\ttimeout = 15;\n\t\tbreak;\n\n\tcase REQUEST_SENSE:\n\t\tcmdLen = 6;\n\t\tCDB[0] = cmd;\n\t\tCDB[4] = io->size;\n\t\tdir = MPI_SCSIIO_CONTROL_READ;\n\t\ttimeout = 10;\n\t\tbreak;\n\n\tcase READ_BUFFER:\n\t\tcmdLen = 10;\n\t\tdir = MPI_SCSIIO_CONTROL_READ;\n\t\tCDB[0] = cmd;\n\t\tif (io->flags & MPT_ICFLAG_ECHO) {\n\t\t\tCDB[1] = 0x0A;\n\t\t} else {\n\t\t\tCDB[1] = 0x02;\n\t\t}\n\n\t\tif (io->flags & MPT_ICFLAG_BUF_CAP) {\n\t\t\tCDB[1] |= 0x01;\n\t\t}\n\t\tCDB[6] = (io->size >> 16) & 0xFF;\n\t\tCDB[7] = (io->size >>  8) & 0xFF;\n\t\tCDB[8] = io->size & 0xFF;\n\t\ttimeout = 10;\n\t\tbreak;\n\n\tcase WRITE_BUFFER:\n\t\tcmdLen = 10;\n\t\tdir = MPI_SCSIIO_CONTROL_WRITE;\n\t\tCDB[0] = cmd;\n\t\tif (io->flags & MPT_ICFLAG_ECHO) {\n\t\t\tCDB[1] = 0x0A;\n\t\t} else {\n\t\t\tCDB[1] = 0x02;\n\t\t}\n\t\tCDB[6] = (io->size >> 16) & 0xFF;\n\t\tCDB[7] = (io->size >>  8) & 0xFF;\n\t\tCDB[8] = io->size & 0xFF;\n\t\ttimeout = 10;\n\t\tbreak;\n\n\tcase RESERVE:\n\t\tcmdLen = 6;\n\t\tdir = MPI_SCSIIO_CONTROL_READ;\n\t\tCDB[0] = cmd;\n\t\ttimeout = 10;\n\t\tbreak;\n\n\tcase RELEASE:\n\t\tcmdLen = 6;\n\t\tdir = MPI_SCSIIO_CONTROL_READ;\n\t\tCDB[0] = cmd;\n\t\ttimeout = 10;\n\t\tbreak;\n\n\tcase SYNCHRONIZE_CACHE:\n\t\tcmdLen = 10;\n\t\tdir = MPI_SCSIIO_CONTROL_READ;\n\t\tCDB[0] = cmd;\n \n\t\ttimeout = 10;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((mf = mpt_get_msg_frame(ioc->InternalCtx, ioc)) == NULL) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_WARN_FMT \"%s: No msg frames!\\n\",\n\t\t    ioc->name, __func__));\n\t\tret = MPT_SCANDV_BUSY;\n\t\tgoto out;\n\t}\n\n\tpScsiReq = (SCSIIORequest_t *) mf;\n\n\t \n\tmy_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\n\tADD_INDEX_LOG(my_idx);  \n\n\tif (io->flags & MPT_ICFLAG_PHYS_DISK) {\n\t\tpScsiReq->TargetID = io->physDiskNum;\n\t\tpScsiReq->Bus = 0;\n\t\tpScsiReq->ChainOffset = 0;\n\t\tpScsiReq->Function = MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH;\n\t} else {\n\t\tpScsiReq->TargetID = io->id;\n\t\tpScsiReq->Bus = io->channel;\n\t\tpScsiReq->ChainOffset = 0;\n\t\tpScsiReq->Function = MPI_FUNCTION_SCSI_IO_REQUEST;\n\t}\n\n\tpScsiReq->CDBLength = cmdLen;\n\tpScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;\n\n\tpScsiReq->Reserved = 0;\n\n\tpScsiReq->MsgFlags = mpt_msg_flags(ioc);\n\t \n\n\tint_to_scsilun(io->lun, (struct scsi_lun *)pScsiReq->LUN);\n\n\tif (io->flags & MPT_ICFLAG_TAGGED_CMD)\n\t\tpScsiReq->Control = cpu_to_le32(dir | MPI_SCSIIO_CONTROL_SIMPLEQ);\n\telse\n\t\tpScsiReq->Control = cpu_to_le32(dir | MPI_SCSIIO_CONTROL_UNTAGGED);\n\n\tif (cmd == REQUEST_SENSE) {\n\t\tpScsiReq->Control = cpu_to_le32(dir | MPI_SCSIIO_CONTROL_UNTAGGED);\n\t\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: Untagged! 0x%02x\\n\", ioc->name, __func__, cmd));\n\t}\n\n\tfor (ii = 0; ii < 16; ii++)\n\t\tpScsiReq->CDB[ii] = CDB[ii];\n\n\tpScsiReq->DataLength = cpu_to_le32(io->size);\n\tpScsiReq->SenseBufferLowAddr = cpu_to_le32(ioc->sense_buf_low_dma\n\t\t\t\t\t   + (my_idx * MPT_SENSE_BUFFER_ALLOC));\n\n\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"%s: Sending Command 0x%02x for fw_channel=%d fw_id=%d lun=%llu\\n\",\n\t    ioc->name, __func__, cmd, io->channel, io->id, io->lun));\n\n\tif (dir == MPI_SCSIIO_CONTROL_READ)\n\t\tioc->add_sge((char *) &pScsiReq->SGL,\n\t\t    MPT_SGE_FLAGS_SSIMPLE_READ | io->size, io->data_dma);\n\telse\n\t\tioc->add_sge((char *) &pScsiReq->SGL,\n\t\t    MPT_SGE_FLAGS_SSIMPLE_WRITE | io->size, io->data_dma);\n\n\tINITIALIZE_MGMT_STATUS(ioc->internal_cmds.status)\n\tmpt_put_msg_frame(ioc->InternalCtx, ioc, mf);\n\ttimeleft = wait_for_completion_timeout(&ioc->internal_cmds.done,\n\t    timeout*HZ);\n\tif (!(ioc->internal_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tret = MPT_SCANDV_DID_RESET;\n\t\tdfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: TIMED OUT for cmd=0x%02x\\n\", ioc->name, __func__,\n\t\t    cmd));\n\t\tif (ioc->internal_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\n\t\t\tmpt_free_msg_frame(ioc, mf);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!timeleft) {\n\t\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t       \"Issuing Reset from %s!! doorbell=0x%08xh\"\n\t\t\t       \" cmd=0x%02x\\n\",\n\t\t\t       ioc->name, __func__, mpt_GetIocState(ioc, 0),\n\t\t\t       cmd);\n\t\t\tmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\n\t\t\tmpt_free_msg_frame(ioc, mf);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tret = ioc->internal_cmds.completion_code;\n\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"%s: success, rc=0x%02x\\n\",\n\t\t\tioc->name, __func__, ret));\n\n out:\n\tCLEAR_MGMT_STATUS(ioc->internal_cmds.status)\n\tmutex_unlock(&ioc->internal_cmds.mutex);\n\treturn ret;\n}\n\n \n \nstatic void\nmptscsih_synchronize_cache(MPT_SCSI_HOST *hd, VirtDevice *vdevice)\n{\n\tINTERNAL_CMD\t\t iocmd;\n\n\t \n\tif (vdevice->vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\treturn;\n\n\tif (vdevice->vtarget->type != TYPE_DISK || vdevice->vtarget->deleted ||\n\t    !vdevice->configured_lun)\n\t\treturn;\n\n\t \n\tiocmd.cmd = SYNCHRONIZE_CACHE;\n\tiocmd.flags = 0;\n\tiocmd.physDiskNum = -1;\n\tiocmd.data = NULL;\n\tiocmd.data_dma = -1;\n\tiocmd.size = 0;\n\tiocmd.rsvd = iocmd.rsvd2 = 0;\n\tiocmd.channel = vdevice->vtarget->channel;\n\tiocmd.id = vdevice->vtarget->id;\n\tiocmd.lun = vdevice->lun;\n\n\tmptscsih_do_cmd(hd, &iocmd);\n}\n\nstatic ssize_t\nmptscsih_version_fw_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%02d.%02d.%02d.%02d\\n\",\n\t    (ioc->facts.FWVersion.Word & 0xFF000000) >> 24,\n\t    (ioc->facts.FWVersion.Word & 0x00FF0000) >> 16,\n\t    (ioc->facts.FWVersion.Word & 0x0000FF00) >> 8,\n\t    ioc->facts.FWVersion.Word & 0x000000FF);\n}\nstatic DEVICE_ATTR(version_fw, S_IRUGO, mptscsih_version_fw_show, NULL);\n\nstatic ssize_t\nmptscsih_version_bios_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%02x.%02x.%02x.%02x\\n\",\n\t    (ioc->biosVersion & 0xFF000000) >> 24,\n\t    (ioc->biosVersion & 0x00FF0000) >> 16,\n\t    (ioc->biosVersion & 0x0000FF00) >> 8,\n\t    ioc->biosVersion & 0x000000FF);\n}\nstatic DEVICE_ATTR(version_bios, S_IRUGO, mptscsih_version_bios_show, NULL);\n\nstatic ssize_t\nmptscsih_version_mpi_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%03x\\n\", ioc->facts.MsgVersion);\n}\nstatic DEVICE_ATTR(version_mpi, S_IRUGO, mptscsih_version_mpi_show, NULL);\n\nstatic ssize_t\nmptscsih_version_product_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\nchar *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", ioc->prod_name);\n}\nstatic DEVICE_ATTR(version_product, S_IRUGO,\n    mptscsih_version_product_show, NULL);\n\nstatic ssize_t\nmptscsih_version_nvdata_persistent_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%02xh\\n\",\n\t    ioc->nvdata_version_persistent);\n}\nstatic DEVICE_ATTR(version_nvdata_persistent, S_IRUGO,\n    mptscsih_version_nvdata_persistent_show, NULL);\n\nstatic ssize_t\nmptscsih_version_nvdata_default_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%02xh\\n\",ioc->nvdata_version_default);\n}\nstatic DEVICE_ATTR(version_nvdata_default, S_IRUGO,\n    mptscsih_version_nvdata_default_show, NULL);\n\nstatic ssize_t\nmptscsih_board_name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", ioc->board_name);\n}\nstatic DEVICE_ATTR(board_name, S_IRUGO, mptscsih_board_name_show, NULL);\n\nstatic ssize_t\nmptscsih_board_assembly_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", ioc->board_assembly);\n}\nstatic DEVICE_ATTR(board_assembly, S_IRUGO,\n    mptscsih_board_assembly_show, NULL);\n\nstatic ssize_t\nmptscsih_board_tracer_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", ioc->board_tracer);\n}\nstatic DEVICE_ATTR(board_tracer, S_IRUGO,\n    mptscsih_board_tracer_show, NULL);\n\nstatic ssize_t\nmptscsih_io_delay_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%02d\\n\", ioc->io_missing_delay);\n}\nstatic DEVICE_ATTR(io_delay, S_IRUGO,\n    mptscsih_io_delay_show, NULL);\n\nstatic ssize_t\nmptscsih_device_delay_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%02d\\n\", ioc->device_missing_delay);\n}\nstatic DEVICE_ATTR(device_delay, S_IRUGO,\n    mptscsih_device_delay_show, NULL);\n\nstatic ssize_t\nmptscsih_debug_level_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%08xh\\n\", ioc->debug_level);\n}\nstatic ssize_t\nmptscsih_debug_level_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\tint val = 0;\n\n\tif (sscanf(buf, \"%x\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tioc->debug_level = val;\n\tprintk(MYIOC_s_INFO_FMT \"debug_level=%08xh\\n\",\n\t\t\t\tioc->name, ioc->debug_level);\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR(debug_level, S_IRUGO | S_IWUSR,\n\tmptscsih_debug_level_show, mptscsih_debug_level_store);\n\nstatic struct attribute *mptscsih_host_attrs[] = {\n\t&dev_attr_version_fw.attr,\n\t&dev_attr_version_bios.attr,\n\t&dev_attr_version_mpi.attr,\n\t&dev_attr_version_product.attr,\n\t&dev_attr_version_nvdata_persistent.attr,\n\t&dev_attr_version_nvdata_default.attr,\n\t&dev_attr_board_name.attr,\n\t&dev_attr_board_assembly.attr,\n\t&dev_attr_board_tracer.attr,\n\t&dev_attr_io_delay.attr,\n\t&dev_attr_device_delay.attr,\n\t&dev_attr_debug_level.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mptscsih_host_attr_group = {\n\t.attrs = mptscsih_host_attrs\n};\n\nconst struct attribute_group *mptscsih_host_attr_groups[] = {\n\t&mptscsih_host_attr_group,\n\tNULL\n};\nEXPORT_SYMBOL(mptscsih_host_attr_groups);\n\nEXPORT_SYMBOL(mptscsih_remove);\nEXPORT_SYMBOL(mptscsih_shutdown);\n#ifdef CONFIG_PM\nEXPORT_SYMBOL(mptscsih_suspend);\nEXPORT_SYMBOL(mptscsih_resume);\n#endif\nEXPORT_SYMBOL(mptscsih_show_info);\nEXPORT_SYMBOL(mptscsih_info);\nEXPORT_SYMBOL(mptscsih_qcmd);\nEXPORT_SYMBOL(mptscsih_slave_destroy);\nEXPORT_SYMBOL(mptscsih_slave_configure);\nEXPORT_SYMBOL(mptscsih_abort);\nEXPORT_SYMBOL(mptscsih_dev_reset);\nEXPORT_SYMBOL(mptscsih_bus_reset);\nEXPORT_SYMBOL(mptscsih_host_reset);\nEXPORT_SYMBOL(mptscsih_bios_param);\nEXPORT_SYMBOL(mptscsih_io_done);\nEXPORT_SYMBOL(mptscsih_taskmgmt_complete);\nEXPORT_SYMBOL(mptscsih_scandv_complete);\nEXPORT_SYMBOL(mptscsih_event_process);\nEXPORT_SYMBOL(mptscsih_ioc_reset);\nEXPORT_SYMBOL(mptscsih_change_queue_depth);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}