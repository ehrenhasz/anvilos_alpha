{
  "module_name": "mptsas.c",
  "hash_id": "79c0aebb360bbcac7a0a2667fa8f923b2e77d8f202c7498869b075e21de48a9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/message/fusion/mptsas.c",
  "human_readable_source": " \n \n \n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\t \n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_sas.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_dbg.h>\n\n#include \"mptbase.h\"\n#include \"mptscsih.h\"\n#include \"mptsas.h\"\n\n\n#define my_NAME\t\t\"Fusion MPT SAS Host driver\"\n#define my_VERSION\tMPT_LINUX_VERSION_COMMON\n#define MYNAM\t\t\"mptsas\"\n\n \n#define MPTSAS_RAID_CHANNEL\t1\n\n#define SAS_CONFIG_PAGE_TIMEOUT\t\t30\nMODULE_AUTHOR(MODULEAUTHOR);\nMODULE_DESCRIPTION(my_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(my_VERSION);\n\nstatic int mpt_pt_clear;\nmodule_param(mpt_pt_clear, int, 0);\nMODULE_PARM_DESC(mpt_pt_clear,\n\t\t\" Clear persistency table: enable=1  \"\n\t\t\"(default=MPTSCSIH_PT_CLEAR=0)\");\n\n \n#define MPTSAS_MAX_LUN (16895)\nstatic int max_lun = MPTSAS_MAX_LUN;\nmodule_param(max_lun, int, 0);\nMODULE_PARM_DESC(max_lun, \" max lun, default=16895 \");\n\nstatic int mpt_loadtime_max_sectors = 8192;\nmodule_param(mpt_loadtime_max_sectors, int, 0);\nMODULE_PARM_DESC(mpt_loadtime_max_sectors,\n\t\t\" Maximum sector define for Host Bus Adaptor.Range 64 to 8192 default=8192\");\n\nstatic u8\tmptsasDoneCtx = MPT_MAX_PROTOCOL_DRIVERS;\nstatic u8\tmptsasTaskCtx = MPT_MAX_PROTOCOL_DRIVERS;\nstatic u8\tmptsasInternalCtx = MPT_MAX_PROTOCOL_DRIVERS;  \nstatic u8\tmptsasMgmtCtx = MPT_MAX_PROTOCOL_DRIVERS;\nstatic u8\tmptsasDeviceResetCtx = MPT_MAX_PROTOCOL_DRIVERS;\n\nstatic void mptsas_firmware_event_work(struct work_struct *work);\nstatic void mptsas_send_sas_event(struct fw_event_work *fw_event);\nstatic void mptsas_send_raid_event(struct fw_event_work *fw_event);\nstatic void mptsas_send_ir2_event(struct fw_event_work *fw_event);\nstatic void mptsas_parse_device_info(struct sas_identify *identify,\n\t\tstruct mptsas_devinfo *device_info);\nstatic inline void mptsas_set_rphy(MPT_ADAPTER *ioc,\n\t\tstruct mptsas_phyinfo *phy_info, struct sas_rphy *rphy);\nstatic struct mptsas_phyinfo\t*mptsas_find_phyinfo_by_sas_address\n\t\t(MPT_ADAPTER *ioc, u64 sas_address);\nstatic int mptsas_sas_device_pg0(MPT_ADAPTER *ioc,\n\tstruct mptsas_devinfo *device_info, u32 form, u32 form_specific);\nstatic int mptsas_sas_enclosure_pg0(MPT_ADAPTER *ioc,\n\tstruct mptsas_enclosure *enclosure, u32 form, u32 form_specific);\nstatic int mptsas_add_end_device(MPT_ADAPTER *ioc,\n\tstruct mptsas_phyinfo *phy_info);\nstatic void mptsas_del_end_device(MPT_ADAPTER *ioc,\n\tstruct mptsas_phyinfo *phy_info);\nstatic void mptsas_send_link_status_event(struct fw_event_work *fw_event);\nstatic struct mptsas_portinfo\t*mptsas_find_portinfo_by_sas_address\n\t\t(MPT_ADAPTER *ioc, u64 sas_address);\nstatic void mptsas_expander_delete(MPT_ADAPTER *ioc,\n\t\tstruct mptsas_portinfo *port_info, u8 force);\nstatic void mptsas_send_expander_event(struct fw_event_work *fw_event);\nstatic void mptsas_not_responding_devices(MPT_ADAPTER *ioc);\nstatic void mptsas_scan_sas_topology(MPT_ADAPTER *ioc);\nstatic void mptsas_broadcast_primitive_work(struct fw_event_work *fw_event);\nstatic void mptsas_handle_queue_full_event(struct fw_event_work *fw_event);\nstatic void mptsas_volume_delete(MPT_ADAPTER *ioc, u8 id);\nvoid\tmptsas_schedule_target_reset(void *ioc);\n\nstatic void mptsas_print_phy_data(MPT_ADAPTER *ioc,\n\t\t\t\t\tMPI_SAS_IO_UNIT0_PHY_DATA *phy_data)\n{\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"---- IO UNIT PAGE 0 ------------\\n\", ioc->name));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Handle=0x%X\\n\",\n\t    ioc->name, le16_to_cpu(phy_data->AttachedDeviceHandle)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Controller Handle=0x%X\\n\",\n\t    ioc->name, le16_to_cpu(phy_data->ControllerDevHandle)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Port=0x%X\\n\",\n\t    ioc->name, phy_data->Port));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Port Flags=0x%X\\n\",\n\t    ioc->name, phy_data->PortFlags));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"PHY Flags=0x%X\\n\",\n\t    ioc->name, phy_data->PhyFlags));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Negotiated Link Rate=0x%X\\n\",\n\t    ioc->name, phy_data->NegotiatedLinkRate));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"Controller PHY Device Info=0x%X\\n\", ioc->name,\n\t    le32_to_cpu(phy_data->ControllerPhyDeviceInfo)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"DiscoveryStatus=0x%X\\n\\n\",\n\t    ioc->name, le32_to_cpu(phy_data->DiscoveryStatus)));\n}\n\nstatic void mptsas_print_phy_pg0(MPT_ADAPTER *ioc, SasPhyPage0_t *pg0)\n{\n\t__le64 sas_address;\n\n\tmemcpy(&sas_address, &pg0->SASAddress, sizeof(__le64));\n\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"---- SAS PHY PAGE 0 ------------\\n\", ioc->name));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"Attached Device Handle=0x%X\\n\", ioc->name,\n\t    le16_to_cpu(pg0->AttachedDevHandle)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"SAS Address=0x%llX\\n\",\n\t    ioc->name, (unsigned long long)le64_to_cpu(sas_address)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"Attached PHY Identifier=0x%X\\n\", ioc->name,\n\t    pg0->AttachedPhyIdentifier));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Attached Device Info=0x%X\\n\",\n\t    ioc->name, le32_to_cpu(pg0->AttachedDeviceInfo)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Programmed Link Rate=0x%X\\n\",\n\t    ioc->name,  pg0->ProgrammedLinkRate));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Change Count=0x%X\\n\",\n\t    ioc->name, pg0->ChangeCount));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"PHY Info=0x%X\\n\\n\",\n\t    ioc->name, le32_to_cpu(pg0->PhyInfo)));\n}\n\nstatic void mptsas_print_phy_pg1(MPT_ADAPTER *ioc, SasPhyPage1_t *pg1)\n{\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"---- SAS PHY PAGE 1 ------------\\n\", ioc->name));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Invalid Dword Count=0x%x\\n\",\n\t    ioc->name,  pg1->InvalidDwordCount));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"Running Disparity Error Count=0x%x\\n\", ioc->name,\n\t    pg1->RunningDisparityErrorCount));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"Loss Dword Synch Count=0x%x\\n\", ioc->name,\n\t    pg1->LossDwordSynchCount));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"PHY Reset Problem Count=0x%x\\n\\n\", ioc->name,\n\t    pg1->PhyResetProblemCount));\n}\n\nstatic void mptsas_print_device_pg0(MPT_ADAPTER *ioc, SasDevicePage0_t *pg0)\n{\n\t__le64 sas_address;\n\n\tmemcpy(&sas_address, &pg0->SASAddress, sizeof(__le64));\n\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"---- SAS DEVICE PAGE 0 ---------\\n\", ioc->name));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Handle=0x%X\\n\",\n\t    ioc->name, le16_to_cpu(pg0->DevHandle)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Parent Handle=0x%X\\n\",\n\t    ioc->name, le16_to_cpu(pg0->ParentDevHandle)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Enclosure Handle=0x%X\\n\",\n\t    ioc->name, le16_to_cpu(pg0->EnclosureHandle)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Slot=0x%X\\n\",\n\t    ioc->name, le16_to_cpu(pg0->Slot)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"SAS Address=0x%llX\\n\",\n\t    ioc->name, (unsigned long long)le64_to_cpu(sas_address)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Target ID=0x%X\\n\",\n\t    ioc->name, pg0->TargetID));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Bus=0x%X\\n\",\n\t    ioc->name, pg0->Bus));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Parent Phy Num=0x%X\\n\",\n\t    ioc->name, pg0->PhyNum));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Access Status=0x%X\\n\",\n\t    ioc->name, le16_to_cpu(pg0->AccessStatus)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Device Info=0x%X\\n\",\n\t    ioc->name, le32_to_cpu(pg0->DeviceInfo)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Flags=0x%X\\n\",\n\t    ioc->name, le16_to_cpu(pg0->Flags)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Physical Port=0x%X\\n\\n\",\n\t    ioc->name, pg0->PhysicalPort));\n}\n\nstatic void mptsas_print_expander_pg1(MPT_ADAPTER *ioc, SasExpanderPage1_t *pg1)\n{\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"---- SAS EXPANDER PAGE 1 ------------\\n\", ioc->name));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Physical Port=0x%X\\n\",\n\t    ioc->name, pg1->PhysicalPort));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"PHY Identifier=0x%X\\n\",\n\t    ioc->name, pg1->PhyIdentifier));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Negotiated Link Rate=0x%X\\n\",\n\t    ioc->name, pg1->NegotiatedLinkRate));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Programmed Link Rate=0x%X\\n\",\n\t    ioc->name, pg1->ProgrammedLinkRate));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Hardware Link Rate=0x%X\\n\",\n\t    ioc->name, pg1->HwLinkRate));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Owner Device Handle=0x%X\\n\",\n\t    ioc->name, le16_to_cpu(pg1->OwnerDevHandle)));\n\tdsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"Attached Device Handle=0x%X\\n\\n\", ioc->name,\n\t    le16_to_cpu(pg1->AttachedDevHandle)));\n}\n\n \nstatic void\nmptsas_fw_event_off(MPT_ADAPTER *ioc)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tioc->fw_events_off = 1;\n\tioc->sas_discovery_quiesce_io = 0;\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n\n}\n\n \nstatic void\nmptsas_fw_event_on(MPT_ADAPTER *ioc)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tioc->fw_events_off = 0;\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\n \nstatic void\nmptsas_add_fw_event(MPT_ADAPTER *ioc, struct fw_event_work *fw_event,\n    unsigned long delay)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tlist_add_tail(&fw_event->list, &ioc->fw_event_list);\n\tfw_event->users = 1;\n\tINIT_DELAYED_WORK(&fw_event->work, mptsas_firmware_event_work);\n\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"%s: add (fw_event=0x%p)\"\n\t\t\"on cpuid %d\\n\", ioc->name, __func__,\n\t\tfw_event, smp_processor_id()));\n\tqueue_delayed_work_on(smp_processor_id(), ioc->fw_event_q,\n\t    &fw_event->work, delay);\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\n \nstatic void\nmptsas_requeue_fw_event(MPT_ADAPTER *ioc, struct fw_event_work *fw_event,\n    unsigned long delay)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"%s: reschedule task \"\n\t    \"(fw_event=0x%p)on cpuid %d\\n\", ioc->name, __func__,\n\t\tfw_event, smp_processor_id()));\n\tfw_event->retries++;\n\tqueue_delayed_work_on(smp_processor_id(), ioc->fw_event_q,\n\t    &fw_event->work, msecs_to_jiffies(delay));\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\nstatic void __mptsas_free_fw_event(MPT_ADAPTER *ioc,\n\t\t\t\t   struct fw_event_work *fw_event)\n{\n\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"%s: kfree (fw_event=0x%p)\\n\",\n\t    ioc->name, __func__, fw_event));\n\tlist_del(&fw_event->list);\n\tkfree(fw_event);\n}\n\n \nstatic void\nmptsas_free_fw_event(MPT_ADAPTER *ioc, struct fw_event_work *fw_event)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tfw_event->users--;\n\tif (!fw_event->users)\n\t\t__mptsas_free_fw_event(ioc, fw_event);\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\n \nstatic void\nmptsas_cleanup_fw_event_q(MPT_ADAPTER *ioc)\n{\n\tstruct fw_event_work *fw_event;\n\tstruct mptsas_target_reset_event *target_reset_list, *n;\n\tMPT_SCSI_HOST\t*hd = shost_priv(ioc->sh);\n\tunsigned long flags;\n\n\t \n\tif (!list_empty(&hd->target_reset_list)) {\n\t\tlist_for_each_entry_safe(target_reset_list, n,\n\t\t    &hd->target_reset_list, list) {\n\t\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t    \"%s: removing target reset for id=%d\\n\",\n\t\t\t    ioc->name, __func__,\n\t\t\t   target_reset_list->sas_event_data.TargetID));\n\t\t\tlist_del(&target_reset_list->list);\n\t\t\tkfree(target_reset_list);\n\t\t}\n\t}\n\n\tif (list_empty(&ioc->fw_event_list) || !ioc->fw_event_q)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\n\twhile (!list_empty(&ioc->fw_event_list)) {\n\t\tbool canceled = false;\n\n\t\tfw_event = list_first_entry(&ioc->fw_event_list,\n\t\t\t\t\t    struct fw_event_work, list);\n\t\tfw_event->users++;\n\t\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n\t\tif (cancel_delayed_work_sync(&fw_event->work))\n\t\t\tcanceled = true;\n\n\t\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\t\tif (canceled)\n\t\t\tfw_event->users--;\n\t\tfw_event->users--;\n\t\tWARN_ON_ONCE(fw_event->users);\n\t\t__mptsas_free_fw_event(ioc, fw_event);\n\t}\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\n\nstatic inline MPT_ADAPTER *phy_to_ioc(struct sas_phy *phy)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\treturn ((MPT_SCSI_HOST *)shost->hostdata)->ioc;\n}\n\nstatic inline MPT_ADAPTER *rphy_to_ioc(struct sas_rphy *rphy)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(rphy->dev.parent->parent);\n\treturn ((MPT_SCSI_HOST *)shost->hostdata)->ioc;\n}\n\n \nstatic struct mptsas_portinfo *\nmptsas_find_portinfo_by_handle(MPT_ADAPTER *ioc, u16 handle)\n{\n\tstruct mptsas_portinfo *port_info, *rc=NULL;\n\tint i;\n\n\tlist_for_each_entry(port_info, &ioc->sas_topology, list)\n\t\tfor (i = 0; i < port_info->num_phys; i++)\n\t\t\tif (port_info->phy_info[i].identify.handle == handle) {\n\t\t\t\trc = port_info;\n\t\t\t\tgoto out;\n\t\t\t}\n out:\n\treturn rc;\n}\n\n \nstatic struct mptsas_portinfo *\nmptsas_find_portinfo_by_sas_address(MPT_ADAPTER *ioc, u64 sas_address)\n{\n\tstruct mptsas_portinfo *port_info, *rc = NULL;\n\tint i;\n\n\tif (sas_address >= ioc->hba_port_sas_addr &&\n\t    sas_address < (ioc->hba_port_sas_addr +\n\t    ioc->hba_port_num_phy))\n\t\treturn ioc->hba_port_info;\n\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_for_each_entry(port_info, &ioc->sas_topology, list)\n\t\tfor (i = 0; i < port_info->num_phys; i++)\n\t\t\tif (port_info->phy_info[i].identify.sas_address ==\n\t\t\t    sas_address) {\n\t\t\t\trc = port_info;\n\t\t\t\tgoto out;\n\t\t\t}\n out:\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\treturn rc;\n}\n\n \nstatic inline int\nmptsas_is_end_device(struct mptsas_devinfo * attached)\n{\n\tif ((attached->sas_address) &&\n\t    (attached->device_info &\n\t    MPI_SAS_DEVICE_INFO_END_DEVICE) &&\n\t    ((attached->device_info &\n\t    MPI_SAS_DEVICE_INFO_SSP_TARGET) |\n\t    (attached->device_info &\n\t    MPI_SAS_DEVICE_INFO_STP_TARGET) |\n\t    (attached->device_info &\n\t    MPI_SAS_DEVICE_INFO_SATA_DEVICE)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic void\nmptsas_port_delete(MPT_ADAPTER *ioc, struct mptsas_portinfo_details * port_details)\n{\n\tstruct mptsas_portinfo *port_info;\n\tstruct mptsas_phyinfo *phy_info;\n\tu8\ti;\n\n\tif (!port_details)\n\t\treturn;\n\n\tport_info = port_details->port_info;\n\tphy_info = port_info->phy_info;\n\n\tdsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"%s: [%p]: num_phys=%02d \"\n\t    \"bitmask=0x%016llX\\n\", ioc->name, __func__, port_details,\n\t    port_details->num_phys, (unsigned long long)\n\t    port_details->phy_bitmask));\n\n\tfor (i = 0; i < port_info->num_phys; i++, phy_info++) {\n\t\tif(phy_info->port_details != port_details)\n\t\t\tcontinue;\n\t\tmemset(&phy_info->attached, 0, sizeof(struct mptsas_devinfo));\n\t\tmptsas_set_rphy(ioc, phy_info, NULL);\n\t\tphy_info->port_details = NULL;\n\t}\n\tkfree(port_details);\n}\n\nstatic inline struct sas_rphy *\nmptsas_get_rphy(struct mptsas_phyinfo *phy_info)\n{\n\tif (phy_info->port_details)\n\t\treturn phy_info->port_details->rphy;\n\telse\n\t\treturn NULL;\n}\n\nstatic inline void\nmptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy)\n{\n\tif (phy_info->port_details) {\n\t\tphy_info->port_details->rphy = rphy;\n\t\tdsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"sas_rphy_add: rphy=%p\\n\",\n\t\t    ioc->name, rphy));\n\t}\n\n\tif (rphy) {\n\t\tdsaswideprintk(ioc, dev_printk(KERN_DEBUG,\n\t\t    &rphy->dev, MYIOC_s_FMT \"add:\", ioc->name));\n\t\tdsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"rphy=%p release=%p\\n\",\n\t\t    ioc->name, rphy, rphy->dev.release));\n\t}\n}\n\nstatic inline struct sas_port *\nmptsas_get_port(struct mptsas_phyinfo *phy_info)\n{\n\tif (phy_info->port_details)\n\t\treturn phy_info->port_details->port;\n\telse\n\t\treturn NULL;\n}\n\nstatic inline void\nmptsas_set_port(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_port *port)\n{\n\tif (phy_info->port_details)\n\t\tphy_info->port_details->port = port;\n\n\tif (port) {\n\t\tdsaswideprintk(ioc, dev_printk(KERN_DEBUG,\n\t\t    &port->dev, MYIOC_s_FMT \"add:\", ioc->name));\n\t\tdsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"port=%p release=%p\\n\",\n\t\t    ioc->name, port, port->dev.release));\n\t}\n}\n\nstatic inline struct scsi_target *\nmptsas_get_starget(struct mptsas_phyinfo *phy_info)\n{\n\tif (phy_info->port_details)\n\t\treturn phy_info->port_details->starget;\n\telse\n\t\treturn NULL;\n}\n\nstatic inline void\nmptsas_set_starget(struct mptsas_phyinfo *phy_info, struct scsi_target *\nstarget)\n{\n\tif (phy_info->port_details)\n\t\tphy_info->port_details->starget = starget;\n}\n\n \nstatic void\nmptsas_add_device_component(MPT_ADAPTER *ioc, u8 channel, u8 id,\n\tu64 sas_address, u32 device_info, u16 slot, u64 enclosure_logical_id)\n{\n\tstruct mptsas_device_info\t*sas_info, *next;\n\tstruct scsi_device\t*sdev;\n\tstruct scsi_target\t*starget;\n\tstruct sas_rphy\t*rphy;\n\n\t \n\tmutex_lock(&ioc->sas_device_info_mutex);\n\tlist_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,\n\t    list) {\n\t\tif (!sas_info->is_logical_volume &&\n\t\t    (sas_info->sas_address == sas_address ||\n\t\t    (sas_info->fw.channel == channel &&\n\t\t     sas_info->fw.id == id))) {\n\t\t\tlist_del(&sas_info->list);\n\t\t\tkfree(sas_info);\n\t\t}\n\t}\n\n\tsas_info = kzalloc(sizeof(struct mptsas_device_info), GFP_KERNEL);\n\tif (!sas_info)\n\t\tgoto out;\n\n\t \n\tsas_info->fw.id = id;\n\tsas_info->fw.channel = channel;\n\n\tsas_info->sas_address = sas_address;\n\tsas_info->device_info = device_info;\n\tsas_info->slot = slot;\n\tsas_info->enclosure_logical_id = enclosure_logical_id;\n\tINIT_LIST_HEAD(&sas_info->list);\n\tlist_add_tail(&sas_info->list, &ioc->sas_device_info_list);\n\n\t \n\tshost_for_each_device(sdev, ioc->sh) {\n\t\tstarget = scsi_target(sdev);\n\t\trphy = dev_to_rphy(starget->dev.parent);\n\t\tif (rphy->identify.sas_address == sas_address) {\n\t\t\tsas_info->os.id = starget->id;\n\t\t\tsas_info->os.channel = starget->channel;\n\t\t}\n\t}\n\n out:\n\tmutex_unlock(&ioc->sas_device_info_mutex);\n\treturn;\n}\n\n \nstatic void\nmptsas_add_device_component_by_fw(MPT_ADAPTER *ioc, u8 channel, u8 id)\n{\n\tstruct mptsas_devinfo sas_device;\n\tstruct mptsas_enclosure enclosure_info;\n\tint rc;\n\n\trc = mptsas_sas_device_pg0(ioc, &sas_device,\n\t    (MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<\n\t     MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\n\t    (channel << 8) + id);\n\tif (rc)\n\t\treturn;\n\n\tmemset(&enclosure_info, 0, sizeof(struct mptsas_enclosure));\n\tmptsas_sas_enclosure_pg0(ioc, &enclosure_info,\n\t    (MPI_SAS_ENCLOS_PGAD_FORM_HANDLE <<\n\t     MPI_SAS_ENCLOS_PGAD_FORM_SHIFT),\n\t     sas_device.handle_enclosure);\n\n\tmptsas_add_device_component(ioc, sas_device.channel,\n\t    sas_device.id, sas_device.sas_address, sas_device.device_info,\n\t    sas_device.slot, enclosure_info.enclosure_logical_id);\n}\n\n \nstatic void\nmptsas_add_device_component_starget_ir(MPT_ADAPTER *ioc,\n\t\tstruct scsi_target *starget)\n{\n\tCONFIGPARMS\t\t\tcfg;\n\tConfigPageHeader_t\t\thdr;\n\tdma_addr_t\t\t\tdma_handle;\n\tpRaidVolumePage0_t\t\tbuffer = NULL;\n\tint\t\t\t\ti;\n\tRaidPhysDiskPage0_t \t\tphys_disk;\n\tstruct mptsas_device_info\t*sas_info, *next;\n\n\tmemset(&cfg, 0 , sizeof(CONFIGPARMS));\n\tmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\n\thdr.PageType = MPI_CONFIG_PAGETYPE_RAID_VOLUME;\n\t \n\tcfg.pageAddr = starget->id;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\n\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\tgoto out;\n\n\tif (!hdr.PageLength)\n\t\tgoto out;\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\n\tif (!buffer)\n\t\tgoto out;\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\tgoto out;\n\n\tif (!buffer->NumPhysDisks)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < buffer->NumPhysDisks; i++) {\n\n\t\tif (mpt_raid_phys_disk_pg0(ioc,\n\t\t    buffer->PhysDisk[i].PhysDiskNum, &phys_disk) != 0)\n\t\t\tcontinue;\n\n\t\tmptsas_add_device_component_by_fw(ioc, phys_disk.PhysDiskBus,\n\t\t    phys_disk.PhysDiskID);\n\n\t\tmutex_lock(&ioc->sas_device_info_mutex);\n\t\tlist_for_each_entry(sas_info, &ioc->sas_device_info_list,\n\t\t    list) {\n\t\t\tif (!sas_info->is_logical_volume &&\n\t\t\t    (sas_info->fw.channel == phys_disk.PhysDiskBus &&\n\t\t\t    sas_info->fw.id == phys_disk.PhysDiskID)) {\n\t\t\t\tsas_info->is_hidden_raid_component = 1;\n\t\t\t\tsas_info->volume_id = starget->id;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ioc->sas_device_info_mutex);\n\n\t}\n\n\t \n\tmutex_lock(&ioc->sas_device_info_mutex);\n\tlist_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,\n\t    list) {\n\t\tif (sas_info->is_logical_volume && sas_info->fw.id ==\n\t\t    starget->id) {\n\t\t\tlist_del(&sas_info->list);\n\t\t\tkfree(sas_info);\n\t\t}\n\t}\n\n\tsas_info = kzalloc(sizeof(struct mptsas_device_info), GFP_KERNEL);\n\tif (sas_info) {\n\t\tsas_info->fw.id = starget->id;\n\t\tsas_info->os.id = starget->id;\n\t\tsas_info->os.channel = starget->channel;\n\t\tsas_info->is_logical_volume = 1;\n\t\tINIT_LIST_HEAD(&sas_info->list);\n\t\tlist_add_tail(&sas_info->list, &ioc->sas_device_info_list);\n\t}\n\tmutex_unlock(&ioc->sas_device_info_mutex);\n\n out:\n\tif (buffer)\n\t\tdma_free_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t  buffer, dma_handle);\n}\n\n \nstatic void\nmptsas_add_device_component_starget(MPT_ADAPTER *ioc,\n\tstruct scsi_target *starget)\n{\n\tstruct sas_rphy\t*rphy;\n\tstruct mptsas_phyinfo\t*phy_info = NULL;\n\tstruct mptsas_enclosure\tenclosure_info;\n\n\trphy = dev_to_rphy(starget->dev.parent);\n\tphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\n\t\t\trphy->identify.sas_address);\n\tif (!phy_info)\n\t\treturn;\n\n\tmemset(&enclosure_info, 0, sizeof(struct mptsas_enclosure));\n\tmptsas_sas_enclosure_pg0(ioc, &enclosure_info,\n\t\t(MPI_SAS_ENCLOS_PGAD_FORM_HANDLE <<\n\t\tMPI_SAS_ENCLOS_PGAD_FORM_SHIFT),\n\t\tphy_info->attached.handle_enclosure);\n\n\tmptsas_add_device_component(ioc, phy_info->attached.channel,\n\t\tphy_info->attached.id, phy_info->attached.sas_address,\n\t\tphy_info->attached.device_info,\n\t\tphy_info->attached.slot, enclosure_info.enclosure_logical_id);\n}\n\n \nstatic void\nmptsas_del_device_component_by_os(MPT_ADAPTER *ioc, u8 channel, u8 id)\n{\n\tstruct mptsas_device_info\t*sas_info, *next;\n\n\t \n\tlist_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,\n\t\tlist) {\n\t\tif (sas_info->os.channel == channel && sas_info->os.id == id)\n\t\t\tsas_info->is_cached = 1;\n\t}\n}\n\n \nstatic void\nmptsas_del_device_components(MPT_ADAPTER *ioc)\n{\n\tstruct mptsas_device_info\t*sas_info, *next;\n\n\tmutex_lock(&ioc->sas_device_info_mutex);\n\tlist_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,\n\t\tlist) {\n\t\tlist_del(&sas_info->list);\n\t\tkfree(sas_info);\n\t}\n\tmutex_unlock(&ioc->sas_device_info_mutex);\n}\n\n\n \nstatic void\nmptsas_setup_wide_ports(MPT_ADAPTER *ioc, struct mptsas_portinfo *port_info)\n{\n\tstruct mptsas_portinfo_details * port_details;\n\tstruct mptsas_phyinfo *phy_info, *phy_info_cmp;\n\tu64\tsas_address;\n\tint\ti, j;\n\n\tmutex_lock(&ioc->sas_topology_mutex);\n\n\tphy_info = port_info->phy_info;\n\tfor (i = 0 ; i < port_info->num_phys ; i++, phy_info++) {\n\t\tif (phy_info->attached.handle)\n\t\t\tcontinue;\n\t\tport_details = phy_info->port_details;\n\t\tif (!port_details)\n\t\t\tcontinue;\n\t\tif (port_details->num_phys < 2)\n\t\t\tcontinue;\n\t\t \n\t\tdsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: [%p]: deleting phy = %d\\n\",\n\t\t    ioc->name, __func__, port_details, i));\n\t\tport_details->num_phys--;\n\t\tport_details->phy_bitmask &= ~ (1 << phy_info->phy_id);\n\t\tmemset(&phy_info->attached, 0, sizeof(struct mptsas_devinfo));\n\t\tif (phy_info->phy) {\n\t\t\tdevtprintk(ioc, dev_printk(KERN_DEBUG,\n\t\t\t\t&phy_info->phy->dev, MYIOC_s_FMT\n\t\t\t\t\"delete phy %d, phy-obj (0x%p)\\n\", ioc->name,\n\t\t\t\tphy_info->phy_id, phy_info->phy));\n\t\t\tsas_port_delete_phy(port_details->port, phy_info->phy);\n\t\t}\n\t\tphy_info->port_details = NULL;\n\t}\n\n\t \n\tphy_info = port_info->phy_info;\n\tfor (i = 0 ; i < port_info->num_phys ; i++, phy_info++) {\n\t\tsas_address = phy_info->attached.sas_address;\n\t\tdsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"phy_id=%d sas_address=0x%018llX\\n\",\n\t\t    ioc->name, i, (unsigned long long)sas_address));\n\t\tif (!sas_address)\n\t\t\tcontinue;\n\t\tport_details = phy_info->port_details;\n\t\t \n\t\tif (!port_details) {\n\t\t\tport_details = kzalloc(sizeof(struct\n\t\t\t\tmptsas_portinfo_details), GFP_KERNEL);\n\t\t\tif (!port_details)\n\t\t\t\tgoto out;\n\t\t\tport_details->num_phys = 1;\n\t\t\tport_details->port_info = port_info;\n\t\t\tif (phy_info->phy_id < 64 )\n\t\t\t\tport_details->phy_bitmask |=\n\t\t\t\t    (1 << phy_info->phy_id);\n\t\t\tphy_info->sas_port_add_phy=1;\n\t\t\tdsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"\\t\\tForming port\\n\\t\\t\"\n\t\t\t    \"phy_id=%d sas_address=0x%018llX\\n\",\n\t\t\t    ioc->name, i, (unsigned long long)sas_address));\n\t\t\tphy_info->port_details = port_details;\n\t\t}\n\n\t\tif (i == port_info->num_phys - 1)\n\t\t\tcontinue;\n\t\tphy_info_cmp = &port_info->phy_info[i + 1];\n\t\tfor (j = i + 1 ; j < port_info->num_phys ; j++,\n\t\t    phy_info_cmp++) {\n\t\t\tif (!phy_info_cmp->attached.sas_address)\n\t\t\t\tcontinue;\n\t\t\tif (sas_address != phy_info_cmp->attached.sas_address)\n\t\t\t\tcontinue;\n\t\t\tif (phy_info_cmp->port_details == port_details )\n\t\t\t\tcontinue;\n\t\t\tdsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t    \"\\t\\tphy_id=%d sas_address=0x%018llX\\n\",\n\t\t\t    ioc->name, j, (unsigned long long)\n\t\t\t    phy_info_cmp->attached.sas_address));\n\t\t\tif (phy_info_cmp->port_details) {\n\t\t\t\tport_details->rphy =\n\t\t\t\t    mptsas_get_rphy(phy_info_cmp);\n\t\t\t\tport_details->port =\n\t\t\t\t    mptsas_get_port(phy_info_cmp);\n\t\t\t\tport_details->starget =\n\t\t\t\t    mptsas_get_starget(phy_info_cmp);\n\t\t\t\tport_details->num_phys =\n\t\t\t\t\tphy_info_cmp->port_details->num_phys;\n\t\t\t\tif (!phy_info_cmp->port_details->num_phys)\n\t\t\t\t\tkfree(phy_info_cmp->port_details);\n\t\t\t} else\n\t\t\t\tphy_info_cmp->sas_port_add_phy=1;\n\t\t\t \n\t\t\tphy_info_cmp->port_details = port_details;\n\t\t\tif (phy_info_cmp->phy_id < 64 )\n\t\t\t\tport_details->phy_bitmask |=\n\t\t\t\t(1 << phy_info_cmp->phy_id);\n\t\t\tport_details->num_phys++;\n\t\t}\n\t}\n\n out:\n\n\tfor (i = 0; i < port_info->num_phys; i++) {\n\t\tport_details = port_info->phy_info[i].port_details;\n\t\tif (!port_details)\n\t\t\tcontinue;\n\t\tdsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: [%p]: phy_id=%02d num_phys=%02d \"\n\t\t    \"bitmask=0x%016llX\\n\", ioc->name, __func__,\n\t\t    port_details, i, port_details->num_phys,\n\t\t    (unsigned long long)port_details->phy_bitmask));\n\t\tdsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"\\t\\tport = %p rphy=%p\\n\",\n\t\t    ioc->name, port_details->port, port_details->rphy));\n\t}\n\tdsaswideprintk(ioc, printk(\"\\n\"));\n\tmutex_unlock(&ioc->sas_topology_mutex);\n}\n\n \nstatic VirtTarget *\nmptsas_find_vtarget(MPT_ADAPTER *ioc, u8 channel, u8 id)\n{\n\tstruct scsi_device \t\t*sdev;\n\tVirtDevice\t\t\t*vdevice;\n\tVirtTarget \t\t\t*vtarget = NULL;\n\n\tshost_for_each_device(sdev, ioc->sh) {\n\t\tvdevice = sdev->hostdata;\n\t\tif ((vdevice == NULL) ||\n\t\t\t(vdevice->vtarget == NULL))\n\t\t\tcontinue;\n\t\tif ((vdevice->vtarget->tflags &\n\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT ||\n\t\t    vdevice->vtarget->raidVolume))\n\t\t\tcontinue;\n\t\tif (vdevice->vtarget->id == id &&\n\t\t\tvdevice->vtarget->channel == channel)\n\t\t\tvtarget = vdevice->vtarget;\n\t}\n\treturn vtarget;\n}\n\nstatic void\nmptsas_queue_device_delete(MPT_ADAPTER *ioc,\n\tMpiEventDataSasDeviceStatusChange_t *sas_event_data)\n{\n\tstruct fw_event_work *fw_event;\n\n\tfw_event = kzalloc(sizeof(*fw_event) +\n\t\t\t   sizeof(MpiEventDataSasDeviceStatusChange_t),\n\t\t\t   GFP_ATOMIC);\n\tif (!fw_event) {\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: failed at (line=%d)\\n\",\n\t\t    ioc->name, __func__, __LINE__);\n\t\treturn;\n\t}\n\tmemcpy(fw_event->event_data, sas_event_data,\n\t    sizeof(MpiEventDataSasDeviceStatusChange_t));\n\tfw_event->event = MPI_EVENT_SAS_DEVICE_STATUS_CHANGE;\n\tfw_event->ioc = ioc;\n\tmptsas_add_fw_event(ioc, fw_event, msecs_to_jiffies(1));\n}\n\nstatic void\nmptsas_queue_rescan(MPT_ADAPTER *ioc)\n{\n\tstruct fw_event_work *fw_event;\n\n\tfw_event = kzalloc(sizeof(*fw_event), GFP_ATOMIC);\n\tif (!fw_event) {\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: failed at (line=%d)\\n\",\n\t\t    ioc->name, __func__, __LINE__);\n\t\treturn;\n\t}\n\tfw_event->event = -1;\n\tfw_event->ioc = ioc;\n\tmptsas_add_fw_event(ioc, fw_event, msecs_to_jiffies(1));\n}\n\n\n \nstatic int\nmptsas_target_reset(MPT_ADAPTER *ioc, u8 channel, u8 id)\n{\n\tMPT_FRAME_HDR\t*mf;\n\tSCSITaskMgmt_t\t*pScsiTm;\n\tif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0)\n\t\treturn 0;\n\n\n\tmf = mpt_get_msg_frame(mptsasDeviceResetCtx, ioc);\n\tif (mf == NULL) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_WARN_FMT\n\t\t\t\"%s, no msg frames @%d!!\\n\", ioc->name,\n\t\t\t__func__, __LINE__));\n\t\tgoto out_fail;\n\t}\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"TaskMgmt request (mf=%p)\\n\",\n\t\tioc->name, mf));\n\n\t \n\tpScsiTm = (SCSITaskMgmt_t *) mf;\n\tmemset (pScsiTm, 0, sizeof(SCSITaskMgmt_t));\n\tpScsiTm->TargetID = id;\n\tpScsiTm->Bus = channel;\n\tpScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;\n\tpScsiTm->TaskType = MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET;\n\tpScsiTm->MsgFlags = MPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION;\n\n\tDBG_DUMP_TM_REQUEST_FRAME(ioc, (u32 *)mf);\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t   \"TaskMgmt type=%d (sas device delete) fw_channel = %d fw_id = %d)\\n\",\n\t   ioc->name, MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET, channel, id));\n\n\tmpt_put_msg_frame_hi_pri(mptsasDeviceResetCtx, ioc, mf);\n\n\treturn 1;\n\n out_fail:\n\n\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\treturn 0;\n}\n\nstatic void\nmptsas_block_io_sdev(struct scsi_device *sdev, void *data)\n{\n\tscsi_device_set_state(sdev, SDEV_BLOCK);\n}\n\nstatic void\nmptsas_block_io_starget(struct scsi_target *starget)\n{\n\tif (starget)\n\t\tstarget_for_each_device(starget, NULL, mptsas_block_io_sdev);\n}\n\n \nstatic void\nmptsas_target_reset_queue(MPT_ADAPTER *ioc,\n    EVENT_DATA_SAS_DEVICE_STATUS_CHANGE *sas_event_data)\n{\n\tMPT_SCSI_HOST\t*hd = shost_priv(ioc->sh);\n\tVirtTarget *vtarget = NULL;\n\tstruct mptsas_target_reset_event *target_reset_list;\n\tu8\t\tid, channel;\n\n\tid = sas_event_data->TargetID;\n\tchannel = sas_event_data->Bus;\n\n\tvtarget = mptsas_find_vtarget(ioc, channel, id);\n\tif (vtarget) {\n\t\tmptsas_block_io_starget(vtarget->starget);\n\t\tvtarget->deleted = 1;  \n\t}\n\n\ttarget_reset_list = kzalloc(sizeof(struct mptsas_target_reset_event),\n\t    GFP_ATOMIC);\n\tif (!target_reset_list) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_WARN_FMT\n\t\t\t\"%s, failed to allocate mem @%d..!!\\n\",\n\t\t\tioc->name, __func__, __LINE__));\n\t\treturn;\n\t}\n\n\tmemcpy(&target_reset_list->sas_event_data, sas_event_data,\n\t\tsizeof(*sas_event_data));\n\tlist_add_tail(&target_reset_list->list, &hd->target_reset_list);\n\n\ttarget_reset_list->time_count = jiffies;\n\n\tif (mptsas_target_reset(ioc, channel, id)) {\n\t\ttarget_reset_list->target_reset_issued = 1;\n\t}\n}\n\n \n\nvoid\nmptsas_schedule_target_reset(void *iocp)\n{\n\tMPT_ADAPTER *ioc = (MPT_ADAPTER *)(iocp);\n\tMPT_SCSI_HOST\t*hd = shost_priv(ioc->sh);\n\tstruct list_head *head = &hd->target_reset_list;\n\tstruct mptsas_target_reset_event\t*target_reset_list;\n\tu8\t\tid, channel;\n\t \n\n\tif (list_empty(head))\n\t\treturn;\n\n\ttarget_reset_list = list_entry(head->next,\n\t\tstruct mptsas_target_reset_event, list);\n\n\tid = target_reset_list->sas_event_data.TargetID;\n\tchannel = target_reset_list->sas_event_data.Bus;\n\ttarget_reset_list->time_count = jiffies;\n\n\tif (mptsas_target_reset(ioc, channel, id))\n\t\ttarget_reset_list->target_reset_issued = 1;\n\treturn;\n}\n\n\n \nstatic int\nmptsas_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)\n{\n\tMPT_SCSI_HOST\t*hd = shost_priv(ioc->sh);\n        struct list_head *head = &hd->target_reset_list;\n\tu8\t\tid, channel;\n\tstruct mptsas_target_reset_event\t*target_reset_list;\n\tSCSITaskMgmtReply_t *pScsiTmReply;\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"TaskMgmt completed: \"\n\t    \"(mf = %p, mr = %p)\\n\", ioc->name, mf, mr));\n\n\tpScsiTmReply = (SCSITaskMgmtReply_t *)mr;\n\tif (!pScsiTmReply)\n\t\treturn 0;\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"\\tTaskMgmt completed: fw_channel = %d, fw_id = %d,\\n\"\n\t    \"\\ttask_type = 0x%02X, iocstatus = 0x%04X \"\n\t    \"loginfo = 0x%08X,\\n\\tresponse_code = 0x%02X, \"\n\t    \"term_cmnds = %d\\n\", ioc->name,\n\t    pScsiTmReply->Bus, pScsiTmReply->TargetID,\n\t    pScsiTmReply->TaskType,\n\t    le16_to_cpu(pScsiTmReply->IOCStatus),\n\t    le32_to_cpu(pScsiTmReply->IOCLogInfo),\n\t    pScsiTmReply->ResponseCode,\n\t    le32_to_cpu(pScsiTmReply->TerminationCount)));\n\n\tif (pScsiTmReply->ResponseCode)\n\t\tmptscsih_taskmgmt_response_code(ioc,\n\t\tpScsiTmReply->ResponseCode);\n\n\tif (pScsiTmReply->TaskType ==\n\t    MPI_SCSITASKMGMT_TASKTYPE_QUERY_TASK || pScsiTmReply->TaskType ==\n\t     MPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET) {\n\t\tioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\n\t\tioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\n\t\tmemcpy(ioc->taskmgmt_cmds.reply, mr,\n\t\t    min(MPT_DEFAULT_FRAME_SIZE, 4 * mr->u.reply.MsgLength));\n\t\tif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_PENDING) {\n\t\t\tioc->taskmgmt_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\t\tcomplete(&ioc->taskmgmt_cmds.done);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\n\tif (list_empty(head))\n\t\treturn 1;\n\n\ttarget_reset_list = list_entry(head->next,\n\t    struct mptsas_target_reset_event, list);\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"TaskMgmt: completed (%d seconds)\\n\",\n\t    ioc->name, jiffies_to_msecs(jiffies -\n\t    target_reset_list->time_count)/1000));\n\n\tid = pScsiTmReply->TargetID;\n\tchannel = pScsiTmReply->Bus;\n\ttarget_reset_list->time_count = jiffies;\n\n\t \n\tif (!target_reset_list->target_reset_issued) {\n\t\tif (mptsas_target_reset(ioc, channel, id))\n\t\t\ttarget_reset_list->target_reset_issued = 1;\n\t\treturn 1;\n\t}\n\n\t \n\tlist_del(&target_reset_list->list);\n\tif (!ioc->fw_events_off)\n\t\tmptsas_queue_device_delete(ioc,\n\t\t\t&target_reset_list->sas_event_data);\n\n\n\tioc->schedule_target_reset(ioc);\n\n\treturn 1;\n}\n\n \nstatic int\nmptsas_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\n{\n\tMPT_SCSI_HOST\t*hd;\n\tint rc;\n\n\trc = mptscsih_ioc_reset(ioc, reset_phase);\n\tif ((ioc->bus_type != SAS) || (!rc))\n\t\treturn rc;\n\n\thd = shost_priv(ioc->sh);\n\tif (!hd->ioc)\n\t\tgoto out;\n\n\tswitch (reset_phase) {\n\tcase MPT_IOC_SETUP_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_SETUP_RESET\\n\", ioc->name, __func__));\n\t\tmptsas_fw_event_off(ioc);\n\t\tbreak;\n\tcase MPT_IOC_PRE_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_PRE_RESET\\n\", ioc->name, __func__));\n\t\tbreak;\n\tcase MPT_IOC_POST_RESET:\n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"%s: MPT_IOC_POST_RESET\\n\", ioc->name, __func__));\n\t\tif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_PENDING) {\n\t\t\tioc->sas_mgmt.status |= MPT_MGMT_STATUS_DID_IOCRESET;\n\t\t\tcomplete(&ioc->sas_mgmt.done);\n\t\t}\n\t\tmptsas_cleanup_fw_event_q(ioc);\n\t\tmptsas_queue_rescan(ioc);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n out:\n\treturn rc;\n}\n\n\n \nenum device_state{\n\tDEVICE_RETRY,\n\tDEVICE_ERROR,\n\tDEVICE_READY,\n};\n\nstatic int\nmptsas_sas_enclosure_pg0(MPT_ADAPTER *ioc, struct mptsas_enclosure *enclosure,\n\t\tu32 form, u32 form_specific)\n{\n\tConfigExtendedPageHeader_t hdr;\n\tCONFIGPARMS cfg;\n\tSasEnclosurePage0_t *buffer;\n\tdma_addr_t dma_handle;\n\tint error;\n\t__le64 le_identifier;\n\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.PageVersion = MPI_SASENCLOSURE0_PAGEVERSION;\n\thdr.PageNumber = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\n\thdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_ENCLOSURE;\n\n\tcfg.cfghdr.ehdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = form + form_specific;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\t \n\tcfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\n\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\tgoto out;\n\tif (!hdr.ExtPageLength) {\n\t\terror = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\tgoto out_free_consistent;\n\n\t \n\tmemcpy(&le_identifier, &buffer->EnclosureLogicalID, sizeof(__le64));\n\tenclosure->enclosure_logical_id = le64_to_cpu(le_identifier);\n\tenclosure->enclosure_handle = le16_to_cpu(buffer->EnclosureHandle);\n\tenclosure->flags = le16_to_cpu(buffer->Flags);\n\tenclosure->num_slot = le16_to_cpu(buffer->NumSlots);\n\tenclosure->start_slot = le16_to_cpu(buffer->StartSlot);\n\tenclosure->start_id = buffer->StartTargetID;\n\tenclosure->start_channel = buffer->StartBus;\n\tenclosure->sep_id = buffer->SEPTargetID;\n\tenclosure->sep_channel = buffer->SEPBus;\n\n out_free_consistent:\n\tdma_free_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4, buffer,\n\t\t\t  dma_handle);\n out:\n\treturn error;\n}\n\n \nstatic int\nmptsas_add_end_device(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info)\n{\n\tstruct sas_rphy *rphy;\n\tstruct sas_port *port;\n\tstruct sas_identify identify;\n\tchar *ds = NULL;\n\tu8 fw_id;\n\n\tif (!phy_info) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\"%s: exit at line=%d\\n\", ioc->name,\n\t\t\t __func__, __LINE__));\n\t\treturn 1;\n\t}\n\n\tfw_id = phy_info->attached.id;\n\n\tif (mptsas_get_rphy(phy_info)) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t __func__, fw_id, __LINE__));\n\t\treturn 2;\n\t}\n\n\tport = mptsas_get_port(phy_info);\n\tif (!port) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t __func__, fw_id, __LINE__));\n\t\treturn 3;\n\t}\n\n\tif (phy_info->attached.device_info &\n\t    MPI_SAS_DEVICE_INFO_SSP_TARGET)\n\t\tds = \"ssp\";\n\tif (phy_info->attached.device_info &\n\t    MPI_SAS_DEVICE_INFO_STP_TARGET)\n\t\tds = \"stp\";\n\tif (phy_info->attached.device_info &\n\t    MPI_SAS_DEVICE_INFO_SATA_DEVICE)\n\t\tds = \"sata\";\n\n\tprintk(MYIOC_s_INFO_FMT \"attaching %s device: fw_channel %d, fw_id %d,\"\n\t    \" phy %d, sas_addr 0x%llx\\n\", ioc->name, ds,\n\t    phy_info->attached.channel, phy_info->attached.id,\n\t    phy_info->attached.phy_id, (unsigned long long)\n\t    phy_info->attached.sas_address);\n\n\tmptsas_parse_device_info(&identify, &phy_info->attached);\n\trphy = sas_end_device_alloc(port);\n\tif (!rphy) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t __func__, fw_id, __LINE__));\n\t\treturn 5;  \n\t}\n\n\trphy->identify = identify;\n\tif (sas_rphy_add(rphy)) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t __func__, fw_id, __LINE__));\n\t\tsas_rphy_free(rphy);\n\t\treturn 6;\n\t}\n\tmptsas_set_rphy(ioc, phy_info, rphy);\n\treturn 0;\n}\n\n \nstatic void\nmptsas_del_end_device(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info)\n{\n\tstruct sas_rphy *rphy;\n\tstruct sas_port *port;\n\tstruct mptsas_portinfo *port_info;\n\tstruct mptsas_phyinfo *phy_info_parent;\n\tint i;\n\tchar *ds = NULL;\n\tu8 fw_id;\n\tu64 sas_address;\n\n\tif (!phy_info)\n\t\treturn;\n\n\tfw_id = phy_info->attached.id;\n\tsas_address = phy_info->attached.sas_address;\n\n\tif (!phy_info->port_details) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t __func__, fw_id, __LINE__));\n\t\treturn;\n\t}\n\trphy = mptsas_get_rphy(phy_info);\n\tif (!rphy) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t __func__, fw_id, __LINE__));\n\t\treturn;\n\t}\n\n\tif (phy_info->attached.device_info & MPI_SAS_DEVICE_INFO_SSP_INITIATOR\n\t\t|| phy_info->attached.device_info\n\t\t\t& MPI_SAS_DEVICE_INFO_SMP_INITIATOR\n\t\t|| phy_info->attached.device_info\n\t\t\t& MPI_SAS_DEVICE_INFO_STP_INITIATOR)\n\t\tds = \"initiator\";\n\tif (phy_info->attached.device_info &\n\t    MPI_SAS_DEVICE_INFO_SSP_TARGET)\n\t\tds = \"ssp\";\n\tif (phy_info->attached.device_info &\n\t    MPI_SAS_DEVICE_INFO_STP_TARGET)\n\t\tds = \"stp\";\n\tif (phy_info->attached.device_info &\n\t    MPI_SAS_DEVICE_INFO_SATA_DEVICE)\n\t\tds = \"sata\";\n\n\tdev_printk(KERN_DEBUG, &rphy->dev, MYIOC_s_FMT\n\t    \"removing %s device: fw_channel %d, fw_id %d, phy %d,\"\n\t    \"sas_addr 0x%llx\\n\", ioc->name, ds, phy_info->attached.channel,\n\t    phy_info->attached.id, phy_info->attached.phy_id,\n\t    (unsigned long long) sas_address);\n\n\tport = mptsas_get_port(phy_info);\n\tif (!port) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t __func__, fw_id, __LINE__));\n\t\treturn;\n\t}\n\tport_info = phy_info->portinfo;\n\tphy_info_parent = port_info->phy_info;\n\tfor (i = 0; i < port_info->num_phys; i++, phy_info_parent++) {\n\t\tif (!phy_info_parent->phy)\n\t\t\tcontinue;\n\t\tif (phy_info_parent->attached.sas_address !=\n\t\t    sas_address)\n\t\t\tcontinue;\n\t\tdev_printk(KERN_DEBUG, &phy_info_parent->phy->dev,\n\t\t    MYIOC_s_FMT \"delete phy %d, phy-obj (0x%p)\\n\",\n\t\t    ioc->name, phy_info_parent->phy_id,\n\t\t    phy_info_parent->phy);\n\t\tsas_port_delete_phy(port, phy_info_parent->phy);\n\t}\n\n\tdev_printk(KERN_DEBUG, &port->dev, MYIOC_s_FMT\n\t    \"delete port %d, sas_addr (0x%llx)\\n\", ioc->name,\n\t     port->port_identifier, (unsigned long long)sas_address);\n\tsas_port_delete(port);\n\tmptsas_set_port(ioc, phy_info, NULL);\n\tmptsas_port_delete(ioc, phy_info->port_details);\n}\n\nstatic struct mptsas_phyinfo *\nmptsas_refreshing_device_handles(MPT_ADAPTER *ioc,\n\tstruct mptsas_devinfo *sas_device)\n{\n\tstruct mptsas_phyinfo *phy_info;\n\tstruct mptsas_portinfo *port_info;\n\tint i;\n\n\tphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\n\t    sas_device->sas_address);\n\tif (!phy_info)\n\t\tgoto out;\n\tport_info = phy_info->portinfo;\n\tif (!port_info)\n\t\tgoto out;\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tfor (i = 0; i < port_info->num_phys; i++) {\n\t\tif (port_info->phy_info[i].attached.sas_address !=\n\t\t\tsas_device->sas_address)\n\t\t\tcontinue;\n\t\tport_info->phy_info[i].attached.channel = sas_device->channel;\n\t\tport_info->phy_info[i].attached.id = sas_device->id;\n\t\tport_info->phy_info[i].attached.sas_address =\n\t\t    sas_device->sas_address;\n\t\tport_info->phy_info[i].attached.handle = sas_device->handle;\n\t\tport_info->phy_info[i].attached.handle_parent =\n\t\t    sas_device->handle_parent;\n\t\tport_info->phy_info[i].attached.handle_enclosure =\n\t\t    sas_device->handle_enclosure;\n\t}\n\tmutex_unlock(&ioc->sas_topology_mutex);\n out:\n\treturn phy_info;\n}\n\n \nstatic void\nmptsas_firmware_event_work(struct work_struct *work)\n{\n\tstruct fw_event_work *fw_event =\n\t\tcontainer_of(work, struct fw_event_work, work.work);\n\tMPT_ADAPTER *ioc = fw_event->ioc;\n\n\t \n\tif (fw_event->event == -1) {\n\t\tif (ioc->in_rescan) {\n\t\t\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\"%s: rescan ignored as it is in progress\\n\",\n\t\t\t\tioc->name, __func__));\n\t\t\treturn;\n\t\t}\n\t\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"%s: rescan after \"\n\t\t    \"reset\\n\", ioc->name, __func__));\n\t\tioc->in_rescan = 1;\n\t\tmptsas_not_responding_devices(ioc);\n\t\tmptsas_scan_sas_topology(ioc);\n\t\tioc->in_rescan = 0;\n\t\tmptsas_free_fw_event(ioc, fw_event);\n\t\tmptsas_fw_event_on(ioc);\n\t\treturn;\n\t}\n\n\t \n\tif (ioc->fw_events_off) {\n\t\tmptsas_free_fw_event(ioc, fw_event);\n\t\treturn;\n\t}\n\n\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"%s: fw_event=(0x%p), \"\n\t    \"event = (0x%02x)\\n\", ioc->name, __func__, fw_event,\n\t    (fw_event->event & 0xFF)));\n\n\tswitch (fw_event->event) {\n\tcase MPI_EVENT_SAS_DEVICE_STATUS_CHANGE:\n\t\tmptsas_send_sas_event(fw_event);\n\t\tbreak;\n\tcase MPI_EVENT_INTEGRATED_RAID:\n\t\tmptsas_send_raid_event(fw_event);\n\t\tbreak;\n\tcase MPI_EVENT_IR2:\n\t\tmptsas_send_ir2_event(fw_event);\n\t\tbreak;\n\tcase MPI_EVENT_PERSISTENT_TABLE_FULL:\n\t\tmptbase_sas_persist_operation(ioc,\n\t\t    MPI_SAS_OP_CLEAR_NOT_PRESENT);\n\t\tmptsas_free_fw_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI_EVENT_SAS_BROADCAST_PRIMITIVE:\n\t\tmptsas_broadcast_primitive_work(fw_event);\n\t\tbreak;\n\tcase MPI_EVENT_SAS_EXPANDER_STATUS_CHANGE:\n\t\tmptsas_send_expander_event(fw_event);\n\t\tbreak;\n\tcase MPI_EVENT_SAS_PHY_LINK_STATUS:\n\t\tmptsas_send_link_status_event(fw_event);\n\t\tbreak;\n\tcase MPI_EVENT_QUEUE_FULL:\n\t\tmptsas_handle_queue_full_event(fw_event);\n\t\tbreak;\n\t}\n}\n\n\n\nstatic int\nmptsas_slave_configure(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host\t*host = sdev->host;\n\tMPT_SCSI_HOST\t*hd = shost_priv(host);\n\tMPT_ADAPTER\t*ioc = hd->ioc;\n\tVirtDevice\t*vdevice = sdev->hostdata;\n\n\tif (vdevice->vtarget->deleted) {\n\t\tsdev_printk(KERN_INFO, sdev, \"clearing deleted flag\\n\");\n\t\tvdevice->vtarget->deleted = 0;\n\t}\n\n\t \n\tif (sdev->channel == MPTSAS_RAID_CHANNEL) {\n\t\tmptsas_add_device_component_starget_ir(ioc, scsi_target(sdev));\n\t\tgoto out;\n\t}\n\n\tsas_read_port_mode_page(sdev);\n\n\tmptsas_add_device_component_starget(ioc, scsi_target(sdev));\n\n out:\n\treturn mptscsih_slave_configure(sdev);\n}\n\nstatic int\nmptsas_target_alloc(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *host = dev_to_shost(&starget->dev);\n\tMPT_SCSI_HOST\t\t*hd = shost_priv(host);\n\tVirtTarget\t\t*vtarget;\n\tu8\t\t\tid, channel;\n\tstruct sas_rphy\t\t*rphy;\n\tstruct mptsas_portinfo\t*p;\n\tint \t\t\t i;\n\tMPT_ADAPTER\t\t*ioc = hd->ioc;\n\n\tvtarget = kzalloc(sizeof(VirtTarget), GFP_KERNEL);\n\tif (!vtarget)\n\t\treturn -ENOMEM;\n\n\tvtarget->starget = starget;\n\tvtarget->ioc_id = ioc->id;\n\tvtarget->tflags = MPT_TARGET_FLAGS_Q_YES;\n\tid = starget->id;\n\tchannel = 0;\n\n\t \n\tif (starget->channel == MPTSAS_RAID_CHANNEL) {\n\t\tif (!ioc->raid_data.pIocPg2) {\n\t\t\tkfree(vtarget);\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tfor (i = 0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {\n\t\t\tif (id == ioc->raid_data.pIocPg2->\n\t\t\t\t\tRaidVolume[i].VolumeID) {\n\t\t\t\tchannel = ioc->raid_data.pIocPg2->\n\t\t\t\t\tRaidVolume[i].VolumeBus;\n\t\t\t}\n\t\t}\n\t\tvtarget->raidVolume = 1;\n\t\tgoto out;\n\t}\n\n\trphy = dev_to_rphy(starget->dev.parent);\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_for_each_entry(p, &ioc->sas_topology, list) {\n\t\tfor (i = 0; i < p->num_phys; i++) {\n\t\t\tif (p->phy_info[i].attached.sas_address !=\n\t\t\t\t\trphy->identify.sas_address)\n\t\t\t\tcontinue;\n\t\t\tid = p->phy_info[i].attached.id;\n\t\t\tchannel = p->phy_info[i].attached.channel;\n\t\t\tmptsas_set_starget(&p->phy_info[i], starget);\n\n\t\t\t \n\t\t\tif (mptscsih_is_phys_disk(ioc, channel, id)) {\n\t\t\t\tid = mptscsih_raid_id_to_num(ioc,\n\t\t\t\t\t\tchannel, id);\n\t\t\t\tvtarget->tflags |=\n\t\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT;\n\t\t\t\tp->phy_info[i].attached.phys_disk_num = id;\n\t\t\t}\n\t\t\tmutex_unlock(&ioc->sas_topology_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\n\tkfree(vtarget);\n\treturn -ENXIO;\n\n out:\n\tvtarget->id = id;\n\tvtarget->channel = channel;\n\tstarget->hostdata = vtarget;\n\treturn 0;\n}\n\nstatic void\nmptsas_target_destroy(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *host = dev_to_shost(&starget->dev);\n\tMPT_SCSI_HOST\t\t*hd = shost_priv(host);\n\tstruct sas_rphy\t\t*rphy;\n\tstruct mptsas_portinfo\t*p;\n\tint \t\t\t i;\n\tMPT_ADAPTER\t*ioc = hd->ioc;\n\tVirtTarget\t*vtarget;\n\n\tif (!starget->hostdata)\n\t\treturn;\n\n\tvtarget = starget->hostdata;\n\n\tmptsas_del_device_component_by_os(ioc, starget->channel,\n\t    starget->id);\n\n\n\tif (starget->channel == MPTSAS_RAID_CHANNEL)\n\t\tgoto out;\n\n\trphy = dev_to_rphy(starget->dev.parent);\n\tlist_for_each_entry(p, &ioc->sas_topology, list) {\n\t\tfor (i = 0; i < p->num_phys; i++) {\n\t\t\tif (p->phy_info[i].attached.sas_address !=\n\t\t\t\t\trphy->identify.sas_address)\n\t\t\t\tcontinue;\n\n\t\t\tstarget_printk(KERN_INFO, starget, MYIOC_s_FMT\n\t\t\t\"delete device: fw_channel %d, fw_id %d, phy %d, \"\n\t\t\t\"sas_addr 0x%llx\\n\", ioc->name,\n\t\t\tp->phy_info[i].attached.channel,\n\t\t\tp->phy_info[i].attached.id,\n\t\t\tp->phy_info[i].attached.phy_id, (unsigned long long)\n\t\t\tp->phy_info[i].attached.sas_address);\n\n\t\t\tmptsas_set_starget(&p->phy_info[i], NULL);\n\t\t}\n\t}\n\n out:\n\tvtarget->starget = NULL;\n\tkfree(starget->hostdata);\n\tstarget->hostdata = NULL;\n}\n\n\nstatic int\nmptsas_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host\t*host = sdev->host;\n\tMPT_SCSI_HOST\t\t*hd = shost_priv(host);\n\tstruct sas_rphy\t\t*rphy;\n\tstruct mptsas_portinfo\t*p;\n\tVirtDevice\t\t*vdevice;\n\tstruct scsi_target \t*starget;\n\tint \t\t\ti;\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\tvdevice = kzalloc(sizeof(VirtDevice), GFP_KERNEL);\n\tif (!vdevice) {\n\t\tprintk(MYIOC_s_ERR_FMT \"slave_alloc kzalloc(%zd) FAILED!\\n\",\n\t\t\t\tioc->name, sizeof(VirtDevice));\n\t\treturn -ENOMEM;\n\t}\n\tstarget = scsi_target(sdev);\n\tvdevice->vtarget = starget->hostdata;\n\n\tif (sdev->channel == MPTSAS_RAID_CHANNEL)\n\t\tgoto out;\n\n\trphy = dev_to_rphy(sdev->sdev_target->dev.parent);\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_for_each_entry(p, &ioc->sas_topology, list) {\n\t\tfor (i = 0; i < p->num_phys; i++) {\n\t\t\tif (p->phy_info[i].attached.sas_address !=\n\t\t\t\t\trphy->identify.sas_address)\n\t\t\t\tcontinue;\n\t\t\tvdevice->lun = sdev->lun;\n\t\t\t \n\t\t\tif (mptscsih_is_phys_disk(ioc,\n\t\t\t    p->phy_info[i].attached.channel,\n\t\t\t    p->phy_info[i].attached.id))\n\t\t\t\tsdev->no_uld_attach = 1;\n\t\t\tmutex_unlock(&ioc->sas_topology_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\n\tkfree(vdevice);\n\treturn -ENXIO;\n\n out:\n\tvdevice->vtarget->num_luns++;\n\tsdev->hostdata = vdevice;\n\treturn 0;\n}\n\nstatic int\nmptsas_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *SCpnt)\n{\n\tMPT_SCSI_HOST\t*hd;\n\tMPT_ADAPTER\t*ioc;\n\tVirtDevice\t*vdevice = SCpnt->device->hostdata;\n\n\tif (!vdevice || !vdevice->vtarget || vdevice->vtarget->deleted) {\n\t\tSCpnt->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(SCpnt);\n\t\treturn 0;\n\t}\n\n\thd = shost_priv(shost);\n\tioc = hd->ioc;\n\n\tif (ioc->sas_discovery_quiesce_io)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tif (ioc->debug_level & MPT_DEBUG_SCSI)\n\t\tscsi_print_command(SCpnt);\n\n\treturn mptscsih_qcmd(SCpnt);\n}\n\n \nstatic enum scsi_timeout_action mptsas_eh_timed_out(struct scsi_cmnd *sc)\n{\n\tMPT_SCSI_HOST *hd;\n\tMPT_ADAPTER   *ioc;\n\tVirtDevice    *vdevice;\n\tenum scsi_timeout_action rc = SCSI_EH_NOT_HANDLED;\n\n\thd = shost_priv(sc->device->host);\n\tif (hd == NULL) {\n\t\tprintk(KERN_ERR MYNAM \": %s: Can't locate host! (sc=%p)\\n\",\n\t\t    __func__, sc);\n\t\tgoto done;\n\t}\n\n\tioc = hd->ioc;\n\tif (ioc->bus_type != SAS) {\n\t\tprintk(KERN_ERR MYNAM \": %s: Wrong bus type (sc=%p)\\n\",\n\t\t    __func__, sc);\n\t\tgoto done;\n\t}\n\n\t \n\tif (ioc->ioc_reset_in_progress) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_WARN_FMT \": %s: ioc is in reset,\"\n\t\t    \"SML need to reset the timer (sc=%p)\\n\",\n\t\t    ioc->name, __func__, sc));\n\t\trc = SCSI_EH_RESET_TIMER;\n\t}\n\tvdevice = sc->device->hostdata;\n\tif (vdevice && vdevice->vtarget && (vdevice->vtarget->inDMD\n\t\t|| vdevice->vtarget->deleted)) {\n\t\tdtmprintk(ioc, printk(MYIOC_s_WARN_FMT \": %s: target removed \"\n\t\t    \"or in device removal delay (sc=%p)\\n\",\n\t\t    ioc->name, __func__, sc));\n\t\trc = SCSI_EH_RESET_TIMER;\n\t\tgoto done;\n\t}\n\ndone:\n\treturn rc;\n}\n\n\nstatic const struct scsi_host_template mptsas_driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.proc_name\t\t\t= \"mptsas\",\n\t.show_info\t\t\t= mptscsih_show_info,\n\t.name\t\t\t\t= \"MPT SAS Host\",\n\t.info\t\t\t\t= mptscsih_info,\n\t.queuecommand\t\t\t= mptsas_qcmd,\n\t.target_alloc\t\t\t= mptsas_target_alloc,\n\t.slave_alloc\t\t\t= mptsas_slave_alloc,\n\t.slave_configure\t\t= mptsas_slave_configure,\n\t.target_destroy\t\t\t= mptsas_target_destroy,\n\t.slave_destroy\t\t\t= mptscsih_slave_destroy,\n\t.change_queue_depth \t\t= mptscsih_change_queue_depth,\n\t.eh_timed_out\t\t\t= mptsas_eh_timed_out,\n\t.eh_abort_handler\t\t= mptscsih_abort,\n\t.eh_device_reset_handler\t= mptscsih_dev_reset,\n\t.eh_host_reset_handler\t\t= mptscsih_host_reset,\n\t.bios_param\t\t\t= mptscsih_bios_param,\n\t.can_queue\t\t\t= MPT_SAS_CAN_QUEUE,\n\t.this_id\t\t\t= -1,\n\t.sg_tablesize\t\t\t= MPT_SCSI_SG_DEPTH,\n\t.max_sectors\t\t\t= 8192,\n\t.cmd_per_lun\t\t\t= 7,\n\t.shost_groups\t\t\t= mptscsih_host_attr_groups,\n\t.no_write_same\t\t\t= 1,\n};\n\nstatic int mptsas_get_linkerrors(struct sas_phy *phy)\n{\n\tMPT_ADAPTER *ioc = phy_to_ioc(phy);\n\tConfigExtendedPageHeader_t hdr;\n\tCONFIGPARMS cfg;\n\tSasPhyPage1_t *buffer;\n\tdma_addr_t dma_handle;\n\tint error;\n\n\t \n\tif (!scsi_is_sas_phy_local(phy))\n\t\treturn -EINVAL;\n\n\thdr.PageVersion = MPI_SASPHY1_PAGEVERSION;\n\thdr.ExtPageLength = 0;\n\thdr.PageNumber = 1  ;\n\thdr.Reserved1 = 0;\n\thdr.Reserved2 = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\n\thdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_PHY;\n\n\tcfg.cfghdr.ehdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = phy->identify.phy_identifier;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;     \n\tcfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\n\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\treturn error;\n\tif (!hdr.ExtPageLength)\n\t\treturn -ENXIO;\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\tgoto out_free_consistent;\n\n\tmptsas_print_phy_pg1(ioc, buffer);\n\n\tphy->invalid_dword_count = le32_to_cpu(buffer->InvalidDwordCount);\n\tphy->running_disparity_error_count =\n\t\tle32_to_cpu(buffer->RunningDisparityErrorCount);\n\tphy->loss_of_dword_sync_count =\n\t\tle32_to_cpu(buffer->LossDwordSynchCount);\n\tphy->phy_reset_problem_count =\n\t\tle32_to_cpu(buffer->PhyResetProblemCount);\n\n out_free_consistent:\n\tdma_free_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4, buffer,\n\t\t\t  dma_handle);\n\treturn error;\n}\n\nstatic int mptsas_mgmt_done(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req,\n\t\tMPT_FRAME_HDR *reply)\n{\n\tioc->sas_mgmt.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\n\tif (reply != NULL) {\n\t\tioc->sas_mgmt.status |= MPT_MGMT_STATUS_RF_VALID;\n\t\tmemcpy(ioc->sas_mgmt.reply, reply,\n\t\t    min(ioc->reply_sz, 4 * reply->u.reply.MsgLength));\n\t}\n\n\tif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_PENDING) {\n\t\tioc->sas_mgmt.status &= ~MPT_MGMT_STATUS_PENDING;\n\t\tcomplete(&ioc->sas_mgmt.done);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int mptsas_phy_reset(struct sas_phy *phy, int hard_reset)\n{\n\tMPT_ADAPTER *ioc = phy_to_ioc(phy);\n\tSasIoUnitControlRequest_t *req;\n\tSasIoUnitControlReply_t *reply;\n\tMPT_FRAME_HDR *mf;\n\tMPIHeader_t *hdr;\n\tunsigned long timeleft;\n\tint error = -ERESTARTSYS;\n\n\t \n\tif (!scsi_is_sas_phy_local(phy))\n\t\treturn -EINVAL;\n\n\t \n\tif (phy->identify.target_port_protocols & SAS_PROTOCOL_SMP)\n\t\treturn -ENXIO;\n\n\tif (mutex_lock_interruptible(&ioc->sas_mgmt.mutex))\n\t\tgoto out;\n\n\tmf = mpt_get_msg_frame(mptsasMgmtCtx, ioc);\n\tif (!mf) {\n\t\terror = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\thdr = (MPIHeader_t *) mf;\n\treq = (SasIoUnitControlRequest_t *)mf;\n\tmemset(req, 0, sizeof(SasIoUnitControlRequest_t));\n\treq->Function = MPI_FUNCTION_SAS_IO_UNIT_CONTROL;\n\treq->MsgContext = hdr->MsgContext;\n\treq->Operation = hard_reset ?\n\t\tMPI_SAS_OP_PHY_HARD_RESET : MPI_SAS_OP_PHY_LINK_RESET;\n\treq->PhyNum = phy->identify.phy_identifier;\n\n\tINITIALIZE_MGMT_STATUS(ioc->sas_mgmt.status)\n\tmpt_put_msg_frame(mptsasMgmtCtx, ioc, mf);\n\n\ttimeleft = wait_for_completion_timeout(&ioc->sas_mgmt.done,\n\t\t\t10 * HZ);\n\tif (!(ioc->sas_mgmt.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\terror = -ETIME;\n\t\tmpt_free_msg_frame(ioc, mf);\n\t\tif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_DID_IOCRESET)\n\t\t\tgoto out_unlock;\n\t\tif (!timeleft)\n\t\t\tmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif ((ioc->sas_mgmt.status &\n\t    MPT_MGMT_STATUS_RF_VALID) == 0) {\n\t\terror = -ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\treply = (SasIoUnitControlReply_t *)ioc->sas_mgmt.reply;\n\tif (reply->IOCStatus != MPI_IOCSTATUS_SUCCESS) {\n\t\tprintk(MYIOC_s_INFO_FMT \"%s: IOCStatus=0x%X IOCLogInfo=0x%X\\n\",\n\t\t    ioc->name, __func__, reply->IOCStatus, reply->IOCLogInfo);\n\t\terror = -ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\terror = 0;\n\n out_unlock:\n\tCLEAR_MGMT_STATUS(ioc->sas_mgmt.status)\n\tmutex_unlock(&ioc->sas_mgmt.mutex);\n out:\n\treturn error;\n}\n\nstatic int\nmptsas_get_enclosure_identifier(struct sas_rphy *rphy, u64 *identifier)\n{\n\tMPT_ADAPTER *ioc = rphy_to_ioc(rphy);\n\tint i, error;\n\tstruct mptsas_portinfo *p;\n\tstruct mptsas_enclosure enclosure_info;\n\tu64 enclosure_handle;\n\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_for_each_entry(p, &ioc->sas_topology, list) {\n\t\tfor (i = 0; i < p->num_phys; i++) {\n\t\t\tif (p->phy_info[i].attached.sas_address ==\n\t\t\t    rphy->identify.sas_address) {\n\t\t\t\tenclosure_handle = p->phy_info[i].\n\t\t\t\t\tattached.handle_enclosure;\n\t\t\t\tgoto found_info;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\treturn -ENXIO;\n\n found_info:\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\tmemset(&enclosure_info, 0, sizeof(struct mptsas_enclosure));\n\terror = mptsas_sas_enclosure_pg0(ioc, &enclosure_info,\n\t\t\t(MPI_SAS_ENCLOS_PGAD_FORM_HANDLE <<\n\t\t\t MPI_SAS_ENCLOS_PGAD_FORM_SHIFT), enclosure_handle);\n\tif (!error)\n\t\t*identifier = enclosure_info.enclosure_logical_id;\n\treturn error;\n}\n\nstatic int\nmptsas_get_bay_identifier(struct sas_rphy *rphy)\n{\n\tMPT_ADAPTER *ioc = rphy_to_ioc(rphy);\n\tstruct mptsas_portinfo *p;\n\tint i, rc;\n\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_for_each_entry(p, &ioc->sas_topology, list) {\n\t\tfor (i = 0; i < p->num_phys; i++) {\n\t\t\tif (p->phy_info[i].attached.sas_address ==\n\t\t\t    rphy->identify.sas_address) {\n\t\t\t\trc = p->phy_info[i].attached.slot;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\trc = -ENXIO;\n out:\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\treturn rc;\n}\n\nstatic void mptsas_smp_handler(struct bsg_job *job, struct Scsi_Host *shost,\n\t\tstruct sas_rphy *rphy)\n{\n\tMPT_ADAPTER *ioc = ((MPT_SCSI_HOST *) shost->hostdata)->ioc;\n\tMPT_FRAME_HDR *mf;\n\tSmpPassthroughRequest_t *smpreq;\n\tint flagsLength;\n\tunsigned long timeleft;\n\tchar *psge;\n\tu64 sas_address = 0;\n\tunsigned int reslen = 0;\n\tint ret = -EINVAL;\n\n\t \n\tif (job->request_payload.sg_cnt > 1 ||\n\t    job->reply_payload.sg_cnt > 1) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s: multiple segments req %u, rsp %u\\n\",\n\t\t    ioc->name, __func__, job->request_payload.payload_len,\n\t\t    job->reply_payload.payload_len);\n\t\tgoto out;\n\t}\n\n\tret = mutex_lock_interruptible(&ioc->sas_mgmt.mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tmf = mpt_get_msg_frame(mptsasMgmtCtx, ioc);\n\tif (!mf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tsmpreq = (SmpPassthroughRequest_t *)mf;\n\tmemset(smpreq, 0, sizeof(*smpreq));\n\n\tsmpreq->RequestDataLength =\n\t\tcpu_to_le16(job->request_payload.payload_len - 4);\n\tsmpreq->Function = MPI_FUNCTION_SMP_PASSTHROUGH;\n\n\tif (rphy)\n\t\tsas_address = rphy->identify.sas_address;\n\telse {\n\t\tstruct mptsas_portinfo *port_info;\n\n\t\tmutex_lock(&ioc->sas_topology_mutex);\n\t\tport_info = ioc->hba_port_info;\n\t\tif (port_info && port_info->phy_info)\n\t\t\tsas_address =\n\t\t\t\tport_info->phy_info[0].phy->identify.sas_address;\n\t\tmutex_unlock(&ioc->sas_topology_mutex);\n\t}\n\n\t*((u64 *)&smpreq->SASAddress) = cpu_to_le64(sas_address);\n\n\tpsge = (char *)\n\t\t(((int *) mf) + (offsetof(SmpPassthroughRequest_t, SGL) / 4));\n\n\t \n\tflagsLength = (MPI_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t       MPI_SGE_FLAGS_END_OF_BUFFER |\n\t\t       MPI_SGE_FLAGS_DIRECTION)\n\t\t       << MPI_SGE_FLAGS_SHIFT;\n\n\tif (!dma_map_sg(&ioc->pcidev->dev, job->request_payload.sg_list,\n\t\t\t1, DMA_BIDIRECTIONAL))\n\t\tgoto put_mf;\n\n\tflagsLength |= (sg_dma_len(job->request_payload.sg_list) - 4);\n\tioc->add_sge(psge, flagsLength,\n\t\t\tsg_dma_address(job->request_payload.sg_list));\n\tpsge += ioc->SGE_size;\n\n\t \n\tflagsLength = MPI_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\tMPI_SGE_FLAGS_SYSTEM_ADDRESS |\n\t\tMPI_SGE_FLAGS_IOC_TO_HOST |\n\t\tMPI_SGE_FLAGS_END_OF_BUFFER;\n\n\tflagsLength = flagsLength << MPI_SGE_FLAGS_SHIFT;\n\n\tif (!dma_map_sg(&ioc->pcidev->dev, job->reply_payload.sg_list,\n\t\t\t1, DMA_BIDIRECTIONAL))\n\t\tgoto unmap_out;\n\tflagsLength |= sg_dma_len(job->reply_payload.sg_list) + 4;\n\tioc->add_sge(psge, flagsLength,\n\t\t\tsg_dma_address(job->reply_payload.sg_list));\n\n\tINITIALIZE_MGMT_STATUS(ioc->sas_mgmt.status)\n\tmpt_put_msg_frame(mptsasMgmtCtx, ioc, mf);\n\n\ttimeleft = wait_for_completion_timeout(&ioc->sas_mgmt.done, 10 * HZ);\n\tif (!(ioc->sas_mgmt.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tret = -ETIME;\n\t\tmpt_free_msg_frame(ioc, mf);\n\t\tmf = NULL;\n\t\tif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_DID_IOCRESET)\n\t\t\tgoto unmap_in;\n\t\tif (!timeleft)\n\t\t\tmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\n\t\tgoto unmap_in;\n\t}\n\tmf = NULL;\n\n\tif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_RF_VALID) {\n\t\tSmpPassthroughReply_t *smprep;\n\n\t\tsmprep = (SmpPassthroughReply_t *)ioc->sas_mgmt.reply;\n\t\tmemcpy(job->reply, smprep, sizeof(*smprep));\n\t\tjob->reply_len = sizeof(*smprep);\n\t\treslen = smprep->ResponseDataLength;\n\t} else {\n\t\tprintk(MYIOC_s_ERR_FMT\n\t\t    \"%s: smp passthru reply failed to be returned\\n\",\n\t\t    ioc->name, __func__);\n\t\tret = -ENXIO;\n\t}\n\nunmap_in:\n\tdma_unmap_sg(&ioc->pcidev->dev, job->reply_payload.sg_list, 1,\n\t\t\tDMA_BIDIRECTIONAL);\nunmap_out:\n\tdma_unmap_sg(&ioc->pcidev->dev, job->request_payload.sg_list, 1,\n\t\t\tDMA_BIDIRECTIONAL);\nput_mf:\n\tif (mf)\n\t\tmpt_free_msg_frame(ioc, mf);\nout_unlock:\n\tCLEAR_MGMT_STATUS(ioc->sas_mgmt.status)\n\tmutex_unlock(&ioc->sas_mgmt.mutex);\nout:\n\tbsg_job_done(job, ret, reslen);\n}\n\nstatic struct sas_function_template mptsas_transport_functions = {\n\t.get_linkerrors\t\t= mptsas_get_linkerrors,\n\t.get_enclosure_identifier = mptsas_get_enclosure_identifier,\n\t.get_bay_identifier\t= mptsas_get_bay_identifier,\n\t.phy_reset\t\t= mptsas_phy_reset,\n\t.smp_handler\t\t= mptsas_smp_handler,\n};\n\nstatic struct scsi_transport_template *mptsas_transport_template;\n\nstatic int\nmptsas_sas_io_unit_pg0(MPT_ADAPTER *ioc, struct mptsas_portinfo *port_info)\n{\n\tConfigExtendedPageHeader_t hdr;\n\tCONFIGPARMS cfg;\n\tSasIOUnitPage0_t *buffer;\n\tdma_addr_t dma_handle;\n\tint error, i;\n\n\thdr.PageVersion = MPI_SASIOUNITPAGE0_PAGEVERSION;\n\thdr.ExtPageLength = 0;\n\thdr.PageNumber = 0;\n\thdr.Reserved1 = 0;\n\thdr.Reserved2 = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\n\thdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT;\n\n\tcfg.cfghdr.ehdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = 0;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\t \n\tcfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\n\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\tgoto out;\n\tif (!hdr.ExtPageLength) {\n\t\terror = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\tgoto out_free_consistent;\n\n\tport_info->num_phys = buffer->NumPhys;\n\tport_info->phy_info = kcalloc(port_info->num_phys,\n\t\tsizeof(struct mptsas_phyinfo), GFP_KERNEL);\n\tif (!port_info->phy_info) {\n\t\terror = -ENOMEM;\n\t\tgoto out_free_consistent;\n\t}\n\n\tioc->nvdata_version_persistent =\n\t    le16_to_cpu(buffer->NvdataVersionPersistent);\n\tioc->nvdata_version_default =\n\t    le16_to_cpu(buffer->NvdataVersionDefault);\n\n\tfor (i = 0; i < port_info->num_phys; i++) {\n\t\tmptsas_print_phy_data(ioc, &buffer->PhyData[i]);\n\t\tport_info->phy_info[i].phy_id = i;\n\t\tport_info->phy_info[i].port_id =\n\t\t    buffer->PhyData[i].Port;\n\t\tport_info->phy_info[i].negotiated_link_rate =\n\t\t    buffer->PhyData[i].NegotiatedLinkRate;\n\t\tport_info->phy_info[i].portinfo = port_info;\n\t\tport_info->phy_info[i].handle =\n\t\t    le16_to_cpu(buffer->PhyData[i].ControllerDevHandle);\n\t}\n\n out_free_consistent:\n\tdma_free_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4, buffer,\n\t\t\t  dma_handle);\n out:\n\treturn error;\n}\n\nstatic int\nmptsas_sas_io_unit_pg1(MPT_ADAPTER *ioc)\n{\n\tConfigExtendedPageHeader_t hdr;\n\tCONFIGPARMS cfg;\n\tSasIOUnitPage1_t *buffer;\n\tdma_addr_t dma_handle;\n\tint error;\n\tu8 device_missing_delay;\n\n\tmemset(&hdr, 0, sizeof(ConfigExtendedPageHeader_t));\n\tmemset(&cfg, 0, sizeof(CONFIGPARMS));\n\n\tcfg.cfghdr.ehdr = &hdr;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\n\tcfg.cfghdr.ehdr->PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\n\tcfg.cfghdr.ehdr->ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT;\n\tcfg.cfghdr.ehdr->PageVersion = MPI_SASIOUNITPAGE1_PAGEVERSION;\n\tcfg.cfghdr.ehdr->PageNumber = 1;\n\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\tgoto out;\n\tif (!hdr.ExtPageLength) {\n\t\terror = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\tgoto out_free_consistent;\n\n\tioc->io_missing_delay  =\n\t    le16_to_cpu(buffer->IODeviceMissingDelay);\n\tdevice_missing_delay = buffer->ReportDeviceMissingDelay;\n\tioc->device_missing_delay = (device_missing_delay & MPI_SAS_IOUNIT1_REPORT_MISSING_UNIT_16) ?\n\t    (device_missing_delay & MPI_SAS_IOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16 :\n\t    device_missing_delay & MPI_SAS_IOUNIT1_REPORT_MISSING_TIMEOUT_MASK;\n\n out_free_consistent:\n\tdma_free_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4, buffer,\n\t\t\t  dma_handle);\n out:\n\treturn error;\n}\n\nstatic int\nmptsas_sas_phy_pg0(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info,\n\t\tu32 form, u32 form_specific)\n{\n\tConfigExtendedPageHeader_t hdr;\n\tCONFIGPARMS cfg;\n\tSasPhyPage0_t *buffer;\n\tdma_addr_t dma_handle;\n\tint error;\n\n\thdr.PageVersion = MPI_SASPHY0_PAGEVERSION;\n\thdr.ExtPageLength = 0;\n\thdr.PageNumber = 0;\n\thdr.Reserved1 = 0;\n\thdr.Reserved2 = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\n\thdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_PHY;\n\n\tcfg.cfghdr.ehdr = &hdr;\n\tcfg.dir = 0;\t \n\tcfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\n\n\t \n\tcfg.physAddr = -1;\n\tcfg.pageAddr = form + form_specific;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\tgoto out;\n\n\tif (!hdr.ExtPageLength) {\n\t\terror = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\tgoto out_free_consistent;\n\n\tmptsas_print_phy_pg0(ioc, buffer);\n\n\tphy_info->hw_link_rate = buffer->HwLinkRate;\n\tphy_info->programmed_link_rate = buffer->ProgrammedLinkRate;\n\tphy_info->identify.handle = le16_to_cpu(buffer->OwnerDevHandle);\n\tphy_info->attached.handle = le16_to_cpu(buffer->AttachedDevHandle);\n\n out_free_consistent:\n\tdma_free_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4, buffer,\n\t\t\t  dma_handle);\n out:\n\treturn error;\n}\n\nstatic int\nmptsas_sas_device_pg0(MPT_ADAPTER *ioc, struct mptsas_devinfo *device_info,\n\t\tu32 form, u32 form_specific)\n{\n\tConfigExtendedPageHeader_t hdr;\n\tCONFIGPARMS cfg;\n\tSasDevicePage0_t *buffer;\n\tdma_addr_t dma_handle;\n\t__le64 sas_address;\n\tint error=0;\n\n\thdr.PageVersion = MPI_SASDEVICE0_PAGEVERSION;\n\thdr.ExtPageLength = 0;\n\thdr.PageNumber = 0;\n\thdr.Reserved1 = 0;\n\thdr.Reserved2 = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\n\thdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE;\n\n\tcfg.cfghdr.ehdr = &hdr;\n\tcfg.pageAddr = form + form_specific;\n\tcfg.physAddr = -1;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\t \n\tcfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\n\n\tmemset(device_info, 0, sizeof(struct mptsas_devinfo));\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\tgoto out;\n\tif (!hdr.ExtPageLength) {\n\t\terror = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\terror = mpt_config(ioc, &cfg);\n\n\tif (error == MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {\n\t\terror = -ENODEV;\n\t\tgoto out_free_consistent;\n\t}\n\n\tif (error)\n\t\tgoto out_free_consistent;\n\n\tmptsas_print_device_pg0(ioc, buffer);\n\n\tmemset(device_info, 0, sizeof(struct mptsas_devinfo));\n\tdevice_info->handle = le16_to_cpu(buffer->DevHandle);\n\tdevice_info->handle_parent = le16_to_cpu(buffer->ParentDevHandle);\n\tdevice_info->handle_enclosure =\n\t    le16_to_cpu(buffer->EnclosureHandle);\n\tdevice_info->slot = le16_to_cpu(buffer->Slot);\n\tdevice_info->phy_id = buffer->PhyNum;\n\tdevice_info->port_id = buffer->PhysicalPort;\n\tdevice_info->id = buffer->TargetID;\n\tdevice_info->phys_disk_num = ~0;\n\tdevice_info->channel = buffer->Bus;\n\tmemcpy(&sas_address, &buffer->SASAddress, sizeof(__le64));\n\tdevice_info->sas_address = le64_to_cpu(sas_address);\n\tdevice_info->device_info =\n\t    le32_to_cpu(buffer->DeviceInfo);\n\tdevice_info->flags = le16_to_cpu(buffer->Flags);\n\n out_free_consistent:\n\tdma_free_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4, buffer,\n\t\t\t  dma_handle);\n out:\n\treturn error;\n}\n\nstatic int\nmptsas_sas_expander_pg0(MPT_ADAPTER *ioc, struct mptsas_portinfo *port_info,\n\t\tu32 form, u32 form_specific)\n{\n\tConfigExtendedPageHeader_t hdr;\n\tCONFIGPARMS cfg;\n\tSasExpanderPage0_t *buffer;\n\tdma_addr_t dma_handle;\n\tint i, error;\n\t__le64 sas_address;\n\n\tmemset(port_info, 0, sizeof(struct mptsas_portinfo));\n\thdr.PageVersion = MPI_SASEXPANDER0_PAGEVERSION;\n\thdr.ExtPageLength = 0;\n\thdr.PageNumber = 0;\n\thdr.Reserved1 = 0;\n\thdr.Reserved2 = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\n\thdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_EXPANDER;\n\n\tcfg.cfghdr.ehdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = form + form_specific;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\t \n\tcfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\n\n\tmemset(port_info, 0, sizeof(struct mptsas_portinfo));\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\tgoto out;\n\n\tif (!hdr.ExtPageLength) {\n\t\terror = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\terror = mpt_config(ioc, &cfg);\n\tif (error == MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {\n\t\terror = -ENODEV;\n\t\tgoto out_free_consistent;\n\t}\n\n\tif (error)\n\t\tgoto out_free_consistent;\n\n\t \n\tport_info->num_phys = (buffer->NumPhys) ? buffer->NumPhys : 1;\n\tport_info->phy_info = kcalloc(port_info->num_phys,\n\t\tsizeof(struct mptsas_phyinfo), GFP_KERNEL);\n\tif (!port_info->phy_info) {\n\t\terror = -ENOMEM;\n\t\tgoto out_free_consistent;\n\t}\n\n\tmemcpy(&sas_address, &buffer->SASAddress, sizeof(__le64));\n\tfor (i = 0; i < port_info->num_phys; i++) {\n\t\tport_info->phy_info[i].portinfo = port_info;\n\t\tport_info->phy_info[i].handle =\n\t\t    le16_to_cpu(buffer->DevHandle);\n\t\tport_info->phy_info[i].identify.sas_address =\n\t\t    le64_to_cpu(sas_address);\n\t\tport_info->phy_info[i].identify.handle_parent =\n\t\t    le16_to_cpu(buffer->ParentDevHandle);\n\t}\n\n out_free_consistent:\n\tdma_free_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4, buffer,\n\t\t\t  dma_handle);\n out:\n\treturn error;\n}\n\nstatic int\nmptsas_sas_expander_pg1(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info,\n\t\tu32 form, u32 form_specific)\n{\n\tConfigExtendedPageHeader_t hdr;\n\tCONFIGPARMS cfg;\n\tSasExpanderPage1_t *buffer;\n\tdma_addr_t dma_handle;\n\tint error=0;\n\n\thdr.PageVersion = MPI_SASEXPANDER1_PAGEVERSION;\n\thdr.ExtPageLength = 0;\n\thdr.PageNumber = 1;\n\thdr.Reserved1 = 0;\n\thdr.Reserved2 = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\n\thdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_EXPANDER;\n\n\tcfg.cfghdr.ehdr = &hdr;\n\tcfg.physAddr = -1;\n\tcfg.pageAddr = form + form_specific;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.dir = 0;\t \n\tcfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\n\n\terror = mpt_config(ioc, &cfg);\n\tif (error)\n\t\tgoto out;\n\n\tif (!hdr.ExtPageLength) {\n\t\terror = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\terror = mpt_config(ioc, &cfg);\n\n\tif (error == MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {\n\t\terror = -ENODEV;\n\t\tgoto out_free_consistent;\n\t}\n\n\tif (error)\n\t\tgoto out_free_consistent;\n\n\n\tmptsas_print_expander_pg1(ioc, buffer);\n\n\t \n\tphy_info->phy_id = buffer->PhyIdentifier;\n\tphy_info->port_id = buffer->PhysicalPort;\n\tphy_info->negotiated_link_rate = buffer->NegotiatedLinkRate;\n\tphy_info->programmed_link_rate = buffer->ProgrammedLinkRate;\n\tphy_info->hw_link_rate = buffer->HwLinkRate;\n\tphy_info->identify.handle = le16_to_cpu(buffer->OwnerDevHandle);\n\tphy_info->attached.handle = le16_to_cpu(buffer->AttachedDevHandle);\n\n out_free_consistent:\n\tdma_free_coherent(&ioc->pcidev->dev, hdr.ExtPageLength * 4, buffer,\n\t\t\t  dma_handle);\n out:\n\treturn error;\n}\n\nstruct rep_manu_request{\n\tu8 smp_frame_type;\n\tu8 function;\n\tu8 reserved;\n\tu8 request_length;\n};\n\nstruct rep_manu_reply{\n\tu8 smp_frame_type;  \n\tu8 function;  \n\tu8 function_result;\n\tu8 response_length;\n\tu16 expander_change_count;\n\tu8 reserved0[2];\n\tu8 sas_format:1;\n\tu8 reserved1:7;\n\tu8 reserved2[3];\n\tu8 vendor_id[SAS_EXPANDER_VENDOR_ID_LEN];\n\tu8 product_id[SAS_EXPANDER_PRODUCT_ID_LEN];\n\tu8 product_rev[SAS_EXPANDER_PRODUCT_REV_LEN];\n\tu8 component_vendor_id[SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN];\n\tu16 component_id;\n\tu8 component_revision_id;\n\tu8 reserved3;\n\tu8 vendor_specific[8];\n};\n\n \nstatic int\nmptsas_exp_repmanufacture_info(MPT_ADAPTER *ioc,\n\tu64 sas_address, struct sas_expander_device *edev)\n{\n\tMPT_FRAME_HDR *mf;\n\tSmpPassthroughRequest_t *smpreq;\n\tSmpPassthroughReply_t *smprep;\n\tstruct rep_manu_reply *manufacture_reply;\n\tstruct rep_manu_request *manufacture_request;\n\tint ret;\n\tint flagsLength;\n\tunsigned long timeleft;\n\tchar *psge;\n\tunsigned long flags;\n\tvoid *data_out = NULL;\n\tdma_addr_t data_out_dma = 0;\n\tu32 sz;\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress) {\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\tprintk(MYIOC_s_INFO_FMT \"%s: host reset in progress!\\n\",\n\t\t\t__func__, ioc->name);\n\t\treturn -EFAULT;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\tret = mutex_lock_interruptible(&ioc->sas_mgmt.mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tmf = mpt_get_msg_frame(mptsasMgmtCtx, ioc);\n\tif (!mf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tsmpreq = (SmpPassthroughRequest_t *)mf;\n\tmemset(smpreq, 0, sizeof(*smpreq));\n\n\tsz = sizeof(struct rep_manu_request) + sizeof(struct rep_manu_reply);\n\n\tdata_out = dma_alloc_coherent(&ioc->pcidev->dev, sz, &data_out_dma,\n\t\t\t\t      GFP_KERNEL);\n\tif (!data_out) {\n\t\tprintk(KERN_ERR \"Memory allocation failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tret = -ENOMEM;\n\t\tgoto put_mf;\n\t}\n\n\tmanufacture_request = data_out;\n\tmanufacture_request->smp_frame_type = 0x40;\n\tmanufacture_request->function = 1;\n\tmanufacture_request->reserved = 0;\n\tmanufacture_request->request_length = 0;\n\n\tsmpreq->Function = MPI_FUNCTION_SMP_PASSTHROUGH;\n\tsmpreq->PhysicalPort = 0xFF;\n\t*((u64 *)&smpreq->SASAddress) = cpu_to_le64(sas_address);\n\tsmpreq->RequestDataLength = sizeof(struct rep_manu_request);\n\n\tpsge = (char *)\n\t\t(((int *) mf) + (offsetof(SmpPassthroughRequest_t, SGL) / 4));\n\n\tflagsLength = MPI_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\tMPI_SGE_FLAGS_SYSTEM_ADDRESS |\n\t\tMPI_SGE_FLAGS_HOST_TO_IOC |\n\t\tMPI_SGE_FLAGS_END_OF_BUFFER;\n\tflagsLength = flagsLength << MPI_SGE_FLAGS_SHIFT;\n\tflagsLength |= sizeof(struct rep_manu_request);\n\n\tioc->add_sge(psge, flagsLength, data_out_dma);\n\tpsge += ioc->SGE_size;\n\n\tflagsLength = MPI_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\tMPI_SGE_FLAGS_SYSTEM_ADDRESS |\n\t\tMPI_SGE_FLAGS_IOC_TO_HOST |\n\t\tMPI_SGE_FLAGS_END_OF_BUFFER;\n\tflagsLength = flagsLength << MPI_SGE_FLAGS_SHIFT;\n\tflagsLength |= sizeof(struct rep_manu_reply);\n\tioc->add_sge(psge, flagsLength, data_out_dma +\n\tsizeof(struct rep_manu_request));\n\n\tINITIALIZE_MGMT_STATUS(ioc->sas_mgmt.status)\n\tmpt_put_msg_frame(mptsasMgmtCtx, ioc, mf);\n\n\ttimeleft = wait_for_completion_timeout(&ioc->sas_mgmt.done, 10 * HZ);\n\tif (!(ioc->sas_mgmt.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tret = -ETIME;\n\t\tmpt_free_msg_frame(ioc, mf);\n\t\tmf = NULL;\n\t\tif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_DID_IOCRESET)\n\t\t\tgoto out_free;\n\t\tif (!timeleft)\n\t\t\tmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\n\t\tgoto out_free;\n\t}\n\n\tmf = NULL;\n\n\tif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_RF_VALID) {\n\t\tu8 *tmp;\n\n\t\tsmprep = (SmpPassthroughReply_t *)ioc->sas_mgmt.reply;\n\t\tif (le16_to_cpu(smprep->ResponseDataLength) !=\n\t\t    sizeof(struct rep_manu_reply))\n\t\t\tgoto out_free;\n\n\t\tmanufacture_reply = data_out + sizeof(struct rep_manu_request);\n\t\tstrncpy(edev->vendor_id, manufacture_reply->vendor_id,\n\t\t\tSAS_EXPANDER_VENDOR_ID_LEN);\n\t\tstrncpy(edev->product_id, manufacture_reply->product_id,\n\t\t\tSAS_EXPANDER_PRODUCT_ID_LEN);\n\t\tstrncpy(edev->product_rev, manufacture_reply->product_rev,\n\t\t\tSAS_EXPANDER_PRODUCT_REV_LEN);\n\t\tedev->level = manufacture_reply->sas_format;\n\t\tif (manufacture_reply->sas_format) {\n\t\t\tstrncpy(edev->component_vendor_id,\n\t\t\t\tmanufacture_reply->component_vendor_id,\n\t\t\t\tSAS_EXPANDER_COMPONENT_VENDOR_ID_LEN);\n\t\t\ttmp = (u8 *)&manufacture_reply->component_id;\n\t\t\tedev->component_id = tmp[0] << 8 | tmp[1];\n\t\t\tedev->component_revision_id =\n\t\t\t\tmanufacture_reply->component_revision_id;\n\t\t}\n\t} else {\n\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t\"%s: smp passthru reply failed to be returned\\n\",\n\t\t\tioc->name, __func__);\n\t\tret = -ENXIO;\n\t}\nout_free:\n\tif (data_out_dma)\n\t\tdma_free_coherent(&ioc->pcidev->dev, sz, data_out,\n\t\t\t\t  data_out_dma);\nput_mf:\n\tif (mf)\n\t\tmpt_free_msg_frame(ioc, mf);\nout_unlock:\n\tCLEAR_MGMT_STATUS(ioc->sas_mgmt.status)\n\tmutex_unlock(&ioc->sas_mgmt.mutex);\nout:\n\treturn ret;\n}\n\nstatic void\nmptsas_parse_device_info(struct sas_identify *identify,\n\t\tstruct mptsas_devinfo *device_info)\n{\n\tu16 protocols;\n\n\tidentify->sas_address = device_info->sas_address;\n\tidentify->phy_identifier = device_info->phy_id;\n\n\t \n\tprotocols = device_info->device_info & 0x78;\n\tidentify->initiator_port_protocols = 0;\n\tif (protocols & MPI_SAS_DEVICE_INFO_SSP_INITIATOR)\n\t\tidentify->initiator_port_protocols |= SAS_PROTOCOL_SSP;\n\tif (protocols & MPI_SAS_DEVICE_INFO_STP_INITIATOR)\n\t\tidentify->initiator_port_protocols |= SAS_PROTOCOL_STP;\n\tif (protocols & MPI_SAS_DEVICE_INFO_SMP_INITIATOR)\n\t\tidentify->initiator_port_protocols |= SAS_PROTOCOL_SMP;\n\tif (protocols & MPI_SAS_DEVICE_INFO_SATA_HOST)\n\t\tidentify->initiator_port_protocols |= SAS_PROTOCOL_SATA;\n\n\t \n\tprotocols = device_info->device_info & 0x780;\n\tidentify->target_port_protocols = 0;\n\tif (protocols & MPI_SAS_DEVICE_INFO_SSP_TARGET)\n\t\tidentify->target_port_protocols |= SAS_PROTOCOL_SSP;\n\tif (protocols & MPI_SAS_DEVICE_INFO_STP_TARGET)\n\t\tidentify->target_port_protocols |= SAS_PROTOCOL_STP;\n\tif (protocols & MPI_SAS_DEVICE_INFO_SMP_TARGET)\n\t\tidentify->target_port_protocols |= SAS_PROTOCOL_SMP;\n\tif (protocols & MPI_SAS_DEVICE_INFO_SATA_DEVICE)\n\t\tidentify->target_port_protocols |= SAS_PROTOCOL_SATA;\n\n\t \n\tswitch (device_info->device_info &\n\t\t\tMPI_SAS_DEVICE_INFO_MASK_DEVICE_TYPE) {\n\tcase MPI_SAS_DEVICE_INFO_NO_DEVICE:\n\t\tidentify->device_type = SAS_PHY_UNUSED;\n\t\tbreak;\n\tcase MPI_SAS_DEVICE_INFO_END_DEVICE:\n\t\tidentify->device_type = SAS_END_DEVICE;\n\t\tbreak;\n\tcase MPI_SAS_DEVICE_INFO_EDGE_EXPANDER:\n\t\tidentify->device_type = SAS_EDGE_EXPANDER_DEVICE;\n\t\tbreak;\n\tcase MPI_SAS_DEVICE_INFO_FANOUT_EXPANDER:\n\t\tidentify->device_type = SAS_FANOUT_EXPANDER_DEVICE;\n\t\tbreak;\n\t}\n}\n\nstatic int mptsas_probe_one_phy(struct device *dev,\n\t\tstruct mptsas_phyinfo *phy_info, int index, int local)\n{\n\tMPT_ADAPTER *ioc;\n\tstruct sas_phy *phy;\n\tstruct sas_port *port;\n\tint error = 0;\n\tVirtTarget *vtarget;\n\n\tif (!dev) {\n\t\terror = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!phy_info->phy) {\n\t\tphy = sas_phy_alloc(dev, index);\n\t\tif (!phy) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tphy = phy_info->phy;\n\n\tmptsas_parse_device_info(&phy->identify, &phy_info->identify);\n\n\t \n\tswitch (phy_info->negotiated_link_rate) {\n\tcase MPI_SAS_IOUNIT0_RATE_PHY_DISABLED:\n\t\tphy->negotiated_linkrate = SAS_PHY_DISABLED;\n\t\tbreak;\n\tcase MPI_SAS_IOUNIT0_RATE_FAILED_SPEED_NEGOTIATION:\n\t\tphy->negotiated_linkrate = SAS_LINK_RATE_FAILED;\n\t\tbreak;\n\tcase MPI_SAS_IOUNIT0_RATE_1_5:\n\t\tphy->negotiated_linkrate = SAS_LINK_RATE_1_5_GBPS;\n\t\tbreak;\n\tcase MPI_SAS_IOUNIT0_RATE_3_0:\n\t\tphy->negotiated_linkrate = SAS_LINK_RATE_3_0_GBPS;\n\t\tbreak;\n\tcase MPI_SAS_IOUNIT0_RATE_6_0:\n\t\tphy->negotiated_linkrate = SAS_LINK_RATE_6_0_GBPS;\n\t\tbreak;\n\tcase MPI_SAS_IOUNIT0_RATE_SATA_OOB_COMPLETE:\n\tcase MPI_SAS_IOUNIT0_RATE_UNKNOWN:\n\tdefault:\n\t\tphy->negotiated_linkrate = SAS_LINK_RATE_UNKNOWN;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (phy_info->hw_link_rate & MPI_SAS_PHY0_PRATE_MAX_RATE_MASK) {\n\tcase MPI_SAS_PHY0_HWRATE_MAX_RATE_1_5:\n\t\tphy->maximum_linkrate_hw = SAS_LINK_RATE_1_5_GBPS;\n\t\tbreak;\n\tcase MPI_SAS_PHY0_PRATE_MAX_RATE_3_0:\n\t\tphy->maximum_linkrate_hw = SAS_LINK_RATE_3_0_GBPS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (phy_info->programmed_link_rate &\n\t\t\tMPI_SAS_PHY0_PRATE_MAX_RATE_MASK) {\n\tcase MPI_SAS_PHY0_PRATE_MAX_RATE_1_5:\n\t\tphy->maximum_linkrate = SAS_LINK_RATE_1_5_GBPS;\n\t\tbreak;\n\tcase MPI_SAS_PHY0_PRATE_MAX_RATE_3_0:\n\t\tphy->maximum_linkrate = SAS_LINK_RATE_3_0_GBPS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (phy_info->hw_link_rate & MPI_SAS_PHY0_HWRATE_MIN_RATE_MASK) {\n\tcase MPI_SAS_PHY0_HWRATE_MIN_RATE_1_5:\n\t\tphy->minimum_linkrate_hw = SAS_LINK_RATE_1_5_GBPS;\n\t\tbreak;\n\tcase MPI_SAS_PHY0_PRATE_MIN_RATE_3_0:\n\t\tphy->minimum_linkrate_hw = SAS_LINK_RATE_3_0_GBPS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (phy_info->programmed_link_rate &\n\t\t\tMPI_SAS_PHY0_PRATE_MIN_RATE_MASK) {\n\tcase MPI_SAS_PHY0_PRATE_MIN_RATE_1_5:\n\t\tphy->minimum_linkrate = SAS_LINK_RATE_1_5_GBPS;\n\t\tbreak;\n\tcase MPI_SAS_PHY0_PRATE_MIN_RATE_3_0:\n\t\tphy->minimum_linkrate = SAS_LINK_RATE_3_0_GBPS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!phy_info->phy) {\n\n\t\terror = sas_phy_add(phy);\n\t\tif (error) {\n\t\t\tsas_phy_free(phy);\n\t\t\tgoto out;\n\t\t}\n\t\tphy_info->phy = phy;\n\t}\n\n\tif (!phy_info->attached.handle ||\n\t\t\t!phy_info->port_details)\n\t\tgoto out;\n\n\tport = mptsas_get_port(phy_info);\n\tioc = phy_to_ioc(phy_info->phy);\n\n\tif (phy_info->sas_port_add_phy) {\n\n\t\tif (!port) {\n\t\t\tport = sas_port_alloc_num(dev);\n\t\t\tif (!port) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terror = sas_port_add(port);\n\t\t\tif (error) {\n\t\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t\t\"%s: exit at line=%d\\n\", ioc->name,\n\t\t\t\t\t__func__, __LINE__));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmptsas_set_port(ioc, phy_info, port);\n\t\t\tdevtprintk(ioc, dev_printk(KERN_DEBUG, &port->dev,\n\t\t\t    MYIOC_s_FMT \"add port %d, sas_addr (0x%llx)\\n\",\n\t\t\t    ioc->name, port->port_identifier,\n\t\t\t    (unsigned long long)phy_info->\n\t\t\t    attached.sas_address));\n\t\t}\n\t\tdsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"sas_port_add_phy: phy_id=%d\\n\",\n\t\t\tioc->name, phy_info->phy_id));\n\t\tsas_port_add_phy(port, phy_info->phy);\n\t\tphy_info->sas_port_add_phy = 0;\n\t\tdevtprintk(ioc, dev_printk(KERN_DEBUG, &phy_info->phy->dev,\n\t\t    MYIOC_s_FMT \"add phy %d, phy-obj (0x%p)\\n\", ioc->name,\n\t\t     phy_info->phy_id, phy_info->phy));\n\t}\n\tif (!mptsas_get_rphy(phy_info) && port && !port->rphy) {\n\n\t\tstruct sas_rphy *rphy;\n\t\tstruct device *parent;\n\t\tstruct sas_identify identify;\n\n\t\tparent = dev->parent->parent;\n\t\t \n\t\tif (mptsas_is_end_device(&phy_info->attached) &&\n\t\t    phy_info->attached.handle_parent) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tmptsas_parse_device_info(&identify, &phy_info->attached);\n\t\tif (scsi_is_host_device(parent)) {\n\t\t\tstruct mptsas_portinfo *port_info;\n\t\t\tint i;\n\n\t\t\tport_info = ioc->hba_port_info;\n\n\t\t\tfor (i = 0; i < port_info->num_phys; i++)\n\t\t\t\tif (port_info->phy_info[i].identify.sas_address ==\n\t\t\t\t    identify.sas_address) {\n\t\t\t\t\tsas_port_mark_backlink(port);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t} else if (scsi_is_sas_rphy(parent)) {\n\t\t\tstruct sas_rphy *parent_rphy = dev_to_rphy(parent);\n\t\t\tif (identify.sas_address ==\n\t\t\t    parent_rphy->identify.sas_address) {\n\t\t\t\tsas_port_mark_backlink(port);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tswitch (identify.device_type) {\n\t\tcase SAS_END_DEVICE:\n\t\t\trphy = sas_end_device_alloc(port);\n\t\t\tbreak;\n\t\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\t\trphy = sas_expander_alloc(port, identify.device_type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trphy = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (!rphy) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t\"%s: exit at line=%d\\n\", ioc->name,\n\t\t\t\t__func__, __LINE__));\n\t\t\tgoto out;\n\t\t}\n\n\t\trphy->identify = identify;\n\t\terror = sas_rphy_add(rphy);\n\t\tif (error) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t\"%s: exit at line=%d\\n\", ioc->name,\n\t\t\t\t__func__, __LINE__));\n\t\t\tsas_rphy_free(rphy);\n\t\t\tgoto out;\n\t\t}\n\t\tmptsas_set_rphy(ioc, phy_info, rphy);\n\t\tif (identify.device_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\tidentify.device_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\tmptsas_exp_repmanufacture_info(ioc,\n\t\t\t\t\tidentify.sas_address,\n\t\t\t\t\trphy_to_expander_device(rphy));\n\t}\n\n\t \n\tvtarget = mptsas_find_vtarget(ioc,\n\t    phy_info->attached.channel,\n\t    phy_info->attached.id);\n\tif (vtarget && vtarget->inDMD) {\n\t\tprintk(KERN_INFO \"Device returned, unsetting inDMD\\n\");\n\t\tvtarget->inDMD = 0;\n\t}\n\n out:\n\treturn error;\n}\n\nstatic int\nmptsas_probe_hba_phys(MPT_ADAPTER *ioc)\n{\n\tstruct mptsas_portinfo *port_info, *hba;\n\tint error = -ENOMEM, i;\n\n\thba = kzalloc(sizeof(struct mptsas_portinfo), GFP_KERNEL);\n\tif (! hba)\n\t\tgoto out;\n\n\terror = mptsas_sas_io_unit_pg0(ioc, hba);\n\tif (error)\n\t\tgoto out_free_port_info;\n\n\tmptsas_sas_io_unit_pg1(ioc);\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tport_info = ioc->hba_port_info;\n\tif (!port_info) {\n\t\tioc->hba_port_info = port_info = hba;\n\t\tioc->hba_port_num_phy = port_info->num_phys;\n\t\tlist_add_tail(&port_info->list, &ioc->sas_topology);\n\t} else {\n\t\tfor (i = 0; i < hba->num_phys; i++) {\n\t\t\tport_info->phy_info[i].negotiated_link_rate =\n\t\t\t\thba->phy_info[i].negotiated_link_rate;\n\t\t\tport_info->phy_info[i].handle =\n\t\t\t\thba->phy_info[i].handle;\n\t\t\tport_info->phy_info[i].port_id =\n\t\t\t\thba->phy_info[i].port_id;\n\t\t}\n\t\tkfree(hba->phy_info);\n\t\tkfree(hba);\n\t\thba = NULL;\n\t}\n\tmutex_unlock(&ioc->sas_topology_mutex);\n#if defined(CPQ_CIM)\n\tioc->num_ports = port_info->num_phys;\n#endif\n\tfor (i = 0; i < port_info->num_phys; i++) {\n\t\tmptsas_sas_phy_pg0(ioc, &port_info->phy_info[i],\n\t\t\t(MPI_SAS_PHY_PGAD_FORM_PHY_NUMBER <<\n\t\t\t MPI_SAS_PHY_PGAD_FORM_SHIFT), i);\n\t\tport_info->phy_info[i].identify.handle =\n\t\t    port_info->phy_info[i].handle;\n\t\tmptsas_sas_device_pg0(ioc, &port_info->phy_info[i].identify,\n\t\t\t(MPI_SAS_DEVICE_PGAD_FORM_HANDLE <<\n\t\t\t MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\n\t\t\t port_info->phy_info[i].identify.handle);\n\t\tif (!ioc->hba_port_sas_addr)\n\t\t\tioc->hba_port_sas_addr =\n\t\t\t    port_info->phy_info[i].identify.sas_address;\n\t\tport_info->phy_info[i].identify.phy_id =\n\t\t    port_info->phy_info[i].phy_id = i;\n\t\tif (port_info->phy_info[i].attached.handle)\n\t\t\tmptsas_sas_device_pg0(ioc,\n\t\t\t\t&port_info->phy_info[i].attached,\n\t\t\t\t(MPI_SAS_DEVICE_PGAD_FORM_HANDLE <<\n\t\t\t\t MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\n\t\t\t\tport_info->phy_info[i].attached.handle);\n\t}\n\n\tmptsas_setup_wide_ports(ioc, port_info);\n\n\tfor (i = 0; i < port_info->num_phys; i++, ioc->sas_index++)\n\t\tmptsas_probe_one_phy(&ioc->sh->shost_gendev,\n\t\t    &port_info->phy_info[i], ioc->sas_index, 1);\n\n\treturn 0;\n\n out_free_port_info:\n\tkfree(hba);\n out:\n\treturn error;\n}\n\nstatic void\nmptsas_expander_refresh(MPT_ADAPTER *ioc, struct mptsas_portinfo *port_info)\n{\n\tstruct mptsas_portinfo *parent;\n\tstruct device *parent_dev;\n\tstruct sas_rphy\t*rphy;\n\tint\t\ti;\n\tu64\t\tsas_address;  \n\tu32\t\thandle;\n\n\thandle = port_info->phy_info[0].handle;\n\tsas_address = port_info->phy_info[0].identify.sas_address;\n\tfor (i = 0; i < port_info->num_phys; i++) {\n\t\tmptsas_sas_expander_pg1(ioc, &port_info->phy_info[i],\n\t\t    (MPI_SAS_EXPAND_PGAD_FORM_HANDLE_PHY_NUM <<\n\t\t    MPI_SAS_EXPAND_PGAD_FORM_SHIFT), (i << 16) + handle);\n\n\t\tmptsas_sas_device_pg0(ioc,\n\t\t    &port_info->phy_info[i].identify,\n\t\t    (MPI_SAS_DEVICE_PGAD_FORM_HANDLE <<\n\t\t    MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\n\t\t    port_info->phy_info[i].identify.handle);\n\t\tport_info->phy_info[i].identify.phy_id =\n\t\t    port_info->phy_info[i].phy_id;\n\n\t\tif (port_info->phy_info[i].attached.handle) {\n\t\t\tmptsas_sas_device_pg0(ioc,\n\t\t\t    &port_info->phy_info[i].attached,\n\t\t\t    (MPI_SAS_DEVICE_PGAD_FORM_HANDLE <<\n\t\t\t     MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\n\t\t\t    port_info->phy_info[i].attached.handle);\n\t\t\tport_info->phy_info[i].attached.phy_id =\n\t\t\t    port_info->phy_info[i].phy_id;\n\t\t}\n\t}\n\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tparent = mptsas_find_portinfo_by_handle(ioc,\n\t    port_info->phy_info[0].identify.handle_parent);\n\tif (!parent) {\n\t\tmutex_unlock(&ioc->sas_topology_mutex);\n\t\treturn;\n\t}\n\tfor (i = 0, parent_dev = NULL; i < parent->num_phys && !parent_dev;\n\t    i++) {\n\t\tif (parent->phy_info[i].attached.sas_address == sas_address) {\n\t\t\trphy = mptsas_get_rphy(&parent->phy_info[i]);\n\t\t\tparent_dev = &rphy->dev;\n\t\t}\n\t}\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\n\tmptsas_setup_wide_ports(ioc, port_info);\n\tfor (i = 0; i < port_info->num_phys; i++, ioc->sas_index++)\n\t\tmptsas_probe_one_phy(parent_dev, &port_info->phy_info[i],\n\t\t    ioc->sas_index, 0);\n}\n\nstatic void\nmptsas_expander_event_add(MPT_ADAPTER *ioc,\n    MpiEventDataSasExpanderStatusChange_t *expander_data)\n{\n\tstruct mptsas_portinfo *port_info;\n\tint i;\n\t__le64 sas_address;\n\n\tport_info = kzalloc(sizeof(struct mptsas_portinfo), GFP_KERNEL);\n\tBUG_ON(!port_info);\n\tport_info->num_phys = (expander_data->NumPhys) ?\n\t    expander_data->NumPhys : 1;\n\tport_info->phy_info = kcalloc(port_info->num_phys,\n\t    sizeof(struct mptsas_phyinfo), GFP_KERNEL);\n\tBUG_ON(!port_info->phy_info);\n\tmemcpy(&sas_address, &expander_data->SASAddress, sizeof(__le64));\n\tfor (i = 0; i < port_info->num_phys; i++) {\n\t\tport_info->phy_info[i].portinfo = port_info;\n\t\tport_info->phy_info[i].handle =\n\t\t    le16_to_cpu(expander_data->DevHandle);\n\t\tport_info->phy_info[i].identify.sas_address =\n\t\t    le64_to_cpu(sas_address);\n\t\tport_info->phy_info[i].identify.handle_parent =\n\t\t    le16_to_cpu(expander_data->ParentDevHandle);\n\t}\n\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_add_tail(&port_info->list, &ioc->sas_topology);\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\n\tprintk(MYIOC_s_INFO_FMT \"add expander: num_phys %d, \"\n\t    \"sas_addr (0x%llx)\\n\", ioc->name, port_info->num_phys,\n\t    (unsigned long long)sas_address);\n\n\tmptsas_expander_refresh(ioc, port_info);\n}\n\n \nstatic void\nmptsas_delete_expander_siblings(MPT_ADAPTER *ioc, struct mptsas_portinfo\n    *parent, struct mptsas_portinfo *expander)\n{\n\tstruct mptsas_phyinfo *phy_info;\n\tstruct mptsas_portinfo *port_info;\n\tstruct sas_rphy *rphy;\n\tint i;\n\n\tphy_info = expander->phy_info;\n\tfor (i = 0; i < expander->num_phys; i++, phy_info++) {\n\t\trphy = mptsas_get_rphy(phy_info);\n\t\tif (!rphy)\n\t\t\tcontinue;\n\t\tif (rphy->identify.device_type == SAS_END_DEVICE)\n\t\t\tmptsas_del_end_device(ioc, phy_info);\n\t}\n\n\tphy_info = expander->phy_info;\n\tfor (i = 0; i < expander->num_phys; i++, phy_info++) {\n\t\trphy = mptsas_get_rphy(phy_info);\n\t\tif (!rphy)\n\t\t\tcontinue;\n\t\tif (rphy->identify.device_type ==\n\t\t    MPI_SAS_DEVICE_INFO_EDGE_EXPANDER ||\n\t\t    rphy->identify.device_type ==\n\t\t    MPI_SAS_DEVICE_INFO_FANOUT_EXPANDER) {\n\t\t\tport_info = mptsas_find_portinfo_by_sas_address(ioc,\n\t\t\t    rphy->identify.sas_address);\n\t\t\tif (!port_info)\n\t\t\t\tcontinue;\n\t\t\tif (port_info == parent)  \n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tmptsas_expander_delete(ioc, port_info, 1);\n\t\t}\n\t}\n}\n\n\n \n\nstatic void mptsas_expander_delete(MPT_ADAPTER *ioc,\n\t\tstruct mptsas_portinfo *port_info, u8 force)\n{\n\n\tstruct mptsas_portinfo *parent;\n\tint\t\ti;\n\tu64\t\texpander_sas_address;\n\tstruct mptsas_phyinfo *phy_info;\n\tstruct mptsas_portinfo buffer;\n\tstruct mptsas_portinfo_details *port_details;\n\tstruct sas_port *port;\n\n\tif (!port_info)\n\t\treturn;\n\n\t \n\tmptsas_sas_expander_pg0(ioc, &buffer,\n\t    (MPI_SAS_EXPAND_PGAD_FORM_HANDLE <<\n\t    MPI_SAS_EXPAND_PGAD_FORM_SHIFT),\n\t    port_info->phy_info[0].identify.handle);\n\n\tif (buffer.num_phys) {\n\t\tkfree(buffer.phy_info);\n\t\tif (!force)\n\t\t\treturn;\n\t}\n\n\n\t \n\tport_details = NULL;\n\texpander_sas_address =\n\t    port_info->phy_info[0].identify.sas_address;\n\tparent = mptsas_find_portinfo_by_handle(ioc,\n\t    port_info->phy_info[0].identify.handle_parent);\n\tmptsas_delete_expander_siblings(ioc, parent, port_info);\n\tif (!parent)\n\t\tgoto out;\n\n\t \n\tphy_info = parent->phy_info;\n\tport = NULL;\n\tfor (i = 0; i < parent->num_phys; i++, phy_info++) {\n\t\tif (!phy_info->phy)\n\t\t\tcontinue;\n\t\tif (phy_info->attached.sas_address !=\n\t\t    expander_sas_address)\n\t\t\tcontinue;\n\t\tif (!port) {\n\t\t\tport = mptsas_get_port(phy_info);\n\t\t\tport_details = phy_info->port_details;\n\t\t}\n\t\tdev_printk(KERN_DEBUG, &phy_info->phy->dev,\n\t\t    MYIOC_s_FMT \"delete phy %d, phy-obj (0x%p)\\n\", ioc->name,\n\t\t    phy_info->phy_id, phy_info->phy);\n\t\tsas_port_delete_phy(port, phy_info->phy);\n\t}\n\tif (port) {\n\t\tdev_printk(KERN_DEBUG, &port->dev,\n\t\t    MYIOC_s_FMT \"delete port %d, sas_addr (0x%llx)\\n\",\n\t\t    ioc->name, port->port_identifier,\n\t\t    (unsigned long long)expander_sas_address);\n\t\tsas_port_delete(port);\n\t\tmptsas_port_delete(ioc, port_details);\n\t}\n out:\n\n\tprintk(MYIOC_s_INFO_FMT \"delete expander: num_phys %d, \"\n\t    \"sas_addr (0x%llx)\\n\",  ioc->name, port_info->num_phys,\n\t    (unsigned long long)expander_sas_address);\n\n\t \n\tlist_del(&port_info->list);\n\tkfree(port_info->phy_info);\n\tkfree(port_info);\n}\n\n\n \nstatic void\nmptsas_send_expander_event(struct fw_event_work *fw_event)\n{\n\tMPT_ADAPTER *ioc;\n\tMpiEventDataSasExpanderStatusChange_t *expander_data;\n\tstruct mptsas_portinfo *port_info;\n\t__le64 sas_address;\n\tint i;\n\n\tioc = fw_event->ioc;\n\texpander_data = (MpiEventDataSasExpanderStatusChange_t *)\n\t    fw_event->event_data;\n\tmemcpy(&sas_address, &expander_data->SASAddress, sizeof(__le64));\n\tsas_address = le64_to_cpu(sas_address);\n\tport_info = mptsas_find_portinfo_by_sas_address(ioc, sas_address);\n\n\tif (expander_data->ReasonCode == MPI_EVENT_SAS_EXP_RC_ADDED) {\n\t\tif (port_info) {\n\t\t\tfor (i = 0; i < port_info->num_phys; i++) {\n\t\t\t\tport_info->phy_info[i].portinfo = port_info;\n\t\t\t\tport_info->phy_info[i].handle =\n\t\t\t\t    le16_to_cpu(expander_data->DevHandle);\n\t\t\t\tport_info->phy_info[i].identify.sas_address =\n\t\t\t\t    le64_to_cpu(sas_address);\n\t\t\t\tport_info->phy_info[i].identify.handle_parent =\n\t\t\t\t    le16_to_cpu(expander_data->ParentDevHandle);\n\t\t\t}\n\t\t\tmptsas_expander_refresh(ioc, port_info);\n\t\t} else if (!port_info && expander_data->NumPhys)\n\t\t\tmptsas_expander_event_add(ioc, expander_data);\n\t} else if (expander_data->ReasonCode ==\n\t    MPI_EVENT_SAS_EXP_RC_NOT_RESPONDING)\n\t\tmptsas_expander_delete(ioc, port_info, 0);\n\n\tmptsas_free_fw_event(ioc, fw_event);\n}\n\n\n \nstatic struct mptsas_portinfo *\nmptsas_expander_add(MPT_ADAPTER *ioc, u16 handle)\n{\n\tstruct mptsas_portinfo buffer, *port_info;\n\tint i;\n\n\tif ((mptsas_sas_expander_pg0(ioc, &buffer,\n\t    (MPI_SAS_EXPAND_PGAD_FORM_HANDLE <<\n\t    MPI_SAS_EXPAND_PGAD_FORM_SHIFT), handle)))\n\t\treturn NULL;\n\n\tport_info = kzalloc(sizeof(struct mptsas_portinfo), GFP_KERNEL);\n\tif (!port_info) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\"%s: exit at line=%d\\n\", ioc->name,\n\t\t__func__, __LINE__));\n\t\treturn NULL;\n\t}\n\tport_info->num_phys = buffer.num_phys;\n\tport_info->phy_info = buffer.phy_info;\n\tfor (i = 0; i < port_info->num_phys; i++)\n\t\tport_info->phy_info[i].portinfo = port_info;\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_add_tail(&port_info->list, &ioc->sas_topology);\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\tprintk(MYIOC_s_INFO_FMT \"add expander: num_phys %d, \"\n\t    \"sas_addr (0x%llx)\\n\", ioc->name, port_info->num_phys,\n\t    (unsigned long long)buffer.phy_info[0].identify.sas_address);\n\tmptsas_expander_refresh(ioc, port_info);\n\treturn port_info;\n}\n\nstatic void\nmptsas_send_link_status_event(struct fw_event_work *fw_event)\n{\n\tMPT_ADAPTER *ioc;\n\tMpiEventDataSasPhyLinkStatus_t *link_data;\n\tstruct mptsas_portinfo *port_info;\n\tstruct mptsas_phyinfo *phy_info = NULL;\n\t__le64 sas_address;\n\tu8 phy_num;\n\tu8 link_rate;\n\n\tioc = fw_event->ioc;\n\tlink_data = (MpiEventDataSasPhyLinkStatus_t *)fw_event->event_data;\n\n\tmemcpy(&sas_address, &link_data->SASAddress, sizeof(__le64));\n\tsas_address = le64_to_cpu(sas_address);\n\tlink_rate = link_data->LinkRates >> 4;\n\tphy_num = link_data->PhyNum;\n\n\tport_info = mptsas_find_portinfo_by_sas_address(ioc, sas_address);\n\tif (port_info) {\n\t\tphy_info = &port_info->phy_info[phy_num];\n\t\tif (phy_info)\n\t\t\tphy_info->negotiated_link_rate = link_rate;\n\t}\n\n\tif (link_rate == MPI_SAS_IOUNIT0_RATE_1_5 ||\n\t    link_rate == MPI_SAS_IOUNIT0_RATE_3_0 ||\n\t    link_rate == MPI_SAS_IOUNIT0_RATE_6_0) {\n\n\t\tif (!port_info) {\n\t\t\tif (ioc->old_sas_discovery_protocal) {\n\t\t\t\tport_info = mptsas_expander_add(ioc,\n\t\t\t\t\tle16_to_cpu(link_data->DevHandle));\n\t\t\t\tif (port_info)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (port_info == ioc->hba_port_info)\n\t\t\tmptsas_probe_hba_phys(ioc);\n\t\telse\n\t\t\tmptsas_expander_refresh(ioc, port_info);\n\t} else if (phy_info && phy_info->phy) {\n\t\tif (link_rate ==  MPI_SAS_IOUNIT0_RATE_PHY_DISABLED)\n\t\t\tphy_info->phy->negotiated_linkrate =\n\t\t\t    SAS_PHY_DISABLED;\n\t\telse if (link_rate ==\n\t\t    MPI_SAS_IOUNIT0_RATE_FAILED_SPEED_NEGOTIATION)\n\t\t\tphy_info->phy->negotiated_linkrate =\n\t\t\t    SAS_LINK_RATE_FAILED;\n\t\telse {\n\t\t\tphy_info->phy->negotiated_linkrate =\n\t\t\t    SAS_LINK_RATE_UNKNOWN;\n\t\t\tif (ioc->device_missing_delay &&\n\t\t\t    mptsas_is_end_device(&phy_info->attached)) {\n\t\t\t\tstruct scsi_device\t\t*sdev;\n\t\t\t\tVirtDevice\t\t\t*vdevice;\n\t\t\t\tu8\tchannel, id;\n\t\t\t\tid = phy_info->attached.id;\n\t\t\t\tchannel = phy_info->attached.channel;\n\t\t\t\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\"Link down for fw_id %d:fw_channel %d\\n\",\n\t\t\t\t    ioc->name, phy_info->attached.id,\n\t\t\t\t    phy_info->attached.channel));\n\n\t\t\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\t\t\tvdevice = sdev->hostdata;\n\t\t\t\t\tif ((vdevice == NULL) ||\n\t\t\t\t\t\t(vdevice->vtarget == NULL))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif ((vdevice->vtarget->tflags &\n\t\t\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT ||\n\t\t\t\t\t    vdevice->vtarget->raidVolume))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (vdevice->vtarget->id == id &&\n\t\t\t\t\t\tvdevice->vtarget->channel ==\n\t\t\t\t\t\tchannel)\n\t\t\t\t\t\tdevtprintk(ioc,\n\t\t\t\t\t\tprintk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\t\"SDEV OUTSTANDING CMDS\"\n\t\t\t\t\t\t\"%d\\n\", ioc->name,\n\t\t\t\t\t\tscsi_device_busy(sdev)));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n out:\n\tmptsas_free_fw_event(ioc, fw_event);\n}\n\nstatic void\nmptsas_not_responding_devices(MPT_ADAPTER *ioc)\n{\n\tstruct mptsas_portinfo buffer, *port_info;\n\tstruct mptsas_device_info\t*sas_info;\n\tstruct mptsas_devinfo sas_device;\n\tu32\thandle;\n\tVirtTarget *vtarget = NULL;\n\tstruct mptsas_phyinfo *phy_info;\n\tu8 found_expander;\n\tint retval, retry_count;\n\tunsigned long flags;\n\n\tmpt_findImVolumes(ioc);\n\n\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\tif (ioc->ioc_reset_in_progress) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t   \"%s: exiting due to a parallel reset \\n\", ioc->name,\n\t\t    __func__));\n\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\n\n\t \n\tmutex_lock(&ioc->sas_device_info_mutex);\n redo_device_scan:\n\tlist_for_each_entry(sas_info, &ioc->sas_device_info_list, list) {\n\t\tif (sas_info->is_cached)\n\t\t\tcontinue;\n\t\tif (!sas_info->is_logical_volume) {\n\t\t\tsas_device.handle = 0;\n\t\t\tretry_count = 0;\nretry_page:\n\t\t\tretval = mptsas_sas_device_pg0(ioc, &sas_device,\n\t\t\t\t(MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID\n\t\t\t\t<< MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\n\t\t\t\t(sas_info->fw.channel << 8) +\n\t\t\t\tsas_info->fw.id);\n\n\t\t\tif (sas_device.handle)\n\t\t\t\tcontinue;\n\t\t\tif (retval == -EBUSY) {\n\t\t\t\tspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\n\t\t\t\tif (ioc->ioc_reset_in_progress) {\n\t\t\t\t\tdfailprintk(ioc,\n\t\t\t\t\tprintk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\"%s: exiting due to reset\\n\",\n\t\t\t\t\tioc->name, __func__));\n\t\t\t\t\tspin_unlock_irqrestore\n\t\t\t\t\t(&ioc->taskmgmt_lock, flags);\n\t\t\t\t\tmutex_unlock(&ioc->\n\t\t\t\t\tsas_device_info_mutex);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&ioc->taskmgmt_lock,\n\t\t\t\tflags);\n\t\t\t}\n\n\t\t\tif (retval && (retval != -ENODEV)) {\n\t\t\t\tif (retry_count < 10) {\n\t\t\t\t\tretry_count++;\n\t\t\t\t\tgoto retry_page;\n\t\t\t\t} else {\n\t\t\t\t\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\"%s: Config page retry exceeded retry \"\n\t\t\t\t\t\"count deleting device 0x%llx\\n\",\n\t\t\t\t\tioc->name, __func__,\n\t\t\t\t\tsas_info->sas_address));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tvtarget = mptsas_find_vtarget(ioc,\n\t\t\t\tsas_info->fw.channel, sas_info->fw.id);\n\n\t\t\tif (vtarget)\n\t\t\t\tvtarget->deleted = 1;\n\n\t\t\tphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\n\t\t\t\t\tsas_info->sas_address);\n\n\t\t\tmptsas_del_end_device(ioc, phy_info);\n\t\t\tgoto redo_device_scan;\n\t\t} else\n\t\t\tmptsas_volume_delete(ioc, sas_info->fw.id);\n\t}\n\tmutex_unlock(&ioc->sas_device_info_mutex);\n\n\t \n\tmutex_lock(&ioc->sas_topology_mutex);\n redo_expander_scan:\n\tlist_for_each_entry(port_info, &ioc->sas_topology, list) {\n\n\t\tif (!(port_info->phy_info[0].identify.device_info &\n\t\t    MPI_SAS_DEVICE_INFO_SMP_TARGET))\n\t\t\tcontinue;\n\t\tfound_expander = 0;\n\t\thandle = 0xFFFF;\n\t\twhile (!mptsas_sas_expander_pg0(ioc, &buffer,\n\t\t    (MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE <<\n\t\t     MPI_SAS_EXPAND_PGAD_FORM_SHIFT), handle) &&\n\t\t    !found_expander) {\n\n\t\t\thandle = buffer.phy_info[0].handle;\n\t\t\tif (buffer.phy_info[0].identify.sas_address ==\n\t\t\t    port_info->phy_info[0].identify.sas_address) {\n\t\t\t\tfound_expander = 1;\n\t\t\t}\n\t\t\tkfree(buffer.phy_info);\n\t\t}\n\n\t\tif (!found_expander) {\n\t\t\tmptsas_expander_delete(ioc, port_info, 0);\n\t\t\tgoto redo_expander_scan;\n\t\t}\n\t}\n\tmutex_unlock(&ioc->sas_topology_mutex);\n}\n\n \nstatic void\nmptsas_probe_expanders(MPT_ADAPTER *ioc)\n{\n\tstruct mptsas_portinfo buffer, *port_info;\n\tu32 \t\t\thandle;\n\tint i;\n\n\thandle = 0xFFFF;\n\twhile (!mptsas_sas_expander_pg0(ioc, &buffer,\n\t    (MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE <<\n\t     MPI_SAS_EXPAND_PGAD_FORM_SHIFT), handle)) {\n\n\t\thandle = buffer.phy_info[0].handle;\n\t\tport_info = mptsas_find_portinfo_by_sas_address(ioc,\n\t\t    buffer.phy_info[0].identify.sas_address);\n\n\t\tif (port_info) {\n\t\t\t \n\t\t\tfor (i = 0; i < buffer.num_phys; i++) {\n\t\t\t\tport_info->phy_info[i].handle = handle;\n\t\t\t\tport_info->phy_info[i].identify.handle_parent =\n\t\t\t\t    buffer.phy_info[0].identify.handle_parent;\n\t\t\t}\n\t\t\tmptsas_expander_refresh(ioc, port_info);\n\t\t\tkfree(buffer.phy_info);\n\t\t\tcontinue;\n\t\t}\n\n\t\tport_info = kzalloc(sizeof(struct mptsas_portinfo), GFP_KERNEL);\n\t\tif (!port_info) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\"%s: exit at line=%d\\n\", ioc->name,\n\t\t\t__func__, __LINE__));\n\t\t\treturn;\n\t\t}\n\t\tport_info->num_phys = buffer.num_phys;\n\t\tport_info->phy_info = buffer.phy_info;\n\t\tfor (i = 0; i < port_info->num_phys; i++)\n\t\t\tport_info->phy_info[i].portinfo = port_info;\n\t\tmutex_lock(&ioc->sas_topology_mutex);\n\t\tlist_add_tail(&port_info->list, &ioc->sas_topology);\n\t\tmutex_unlock(&ioc->sas_topology_mutex);\n\t\tprintk(MYIOC_s_INFO_FMT \"add expander: num_phys %d, \"\n\t\t    \"sas_addr (0x%llx)\\n\", ioc->name, port_info->num_phys,\n\t    (unsigned long long)buffer.phy_info[0].identify.sas_address);\n\t\tmptsas_expander_refresh(ioc, port_info);\n\t}\n}\n\nstatic void\nmptsas_probe_devices(MPT_ADAPTER *ioc)\n{\n\tu16 handle;\n\tstruct mptsas_devinfo sas_device;\n\tstruct mptsas_phyinfo *phy_info;\n\n\thandle = 0xFFFF;\n\twhile (!(mptsas_sas_device_pg0(ioc, &sas_device,\n\t    MPI_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\n\n\t\thandle = sas_device.handle;\n\n\t\tif ((sas_device.device_info &\n\t\t     (MPI_SAS_DEVICE_INFO_SSP_TARGET |\n\t\t      MPI_SAS_DEVICE_INFO_STP_TARGET |\n\t\t      MPI_SAS_DEVICE_INFO_SATA_DEVICE)) == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!(sas_device.flags & MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)\n\t\t\t|| !(sas_device.flags &\n\t\t\tMPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED))\n\t\t\tcontinue;\n\n\t\tphy_info = mptsas_refreshing_device_handles(ioc, &sas_device);\n\t\tif (!phy_info)\n\t\t\tcontinue;\n\n\t\tif (mptsas_get_rphy(phy_info))\n\t\t\tcontinue;\n\n\t\tmptsas_add_end_device(ioc, phy_info);\n\t}\n}\n\n \nstatic void\nmptsas_scan_sas_topology(MPT_ADAPTER *ioc)\n{\n\tstruct scsi_device *sdev;\n\tint i;\n\n\tmptsas_probe_hba_phys(ioc);\n\tmptsas_probe_expanders(ioc);\n\tmptsas_probe_devices(ioc);\n\n\t \n\tif (!ioc->ir_firmware || !ioc->raid_data.pIocPg2 ||\n\t    !ioc->raid_data.pIocPg2->NumActiveVolumes)\n\t\treturn;\n\tfor (i = 0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {\n\t\tsdev = scsi_device_lookup(ioc->sh, MPTSAS_RAID_CHANNEL,\n\t\t    ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID, 0);\n\t\tif (sdev) {\n\t\t\tscsi_device_put(sdev);\n\t\t\tcontinue;\n\t\t}\n\t\tprintk(MYIOC_s_INFO_FMT \"attaching raid volume, channel %d, \"\n\t\t    \"id %d\\n\", ioc->name, MPTSAS_RAID_CHANNEL,\n\t\t    ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID);\n\t\tscsi_add_device(ioc->sh, MPTSAS_RAID_CHANNEL,\n\t\t    ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID, 0);\n\t}\n}\n\n\nstatic void\nmptsas_handle_queue_full_event(struct fw_event_work *fw_event)\n{\n\tMPT_ADAPTER *ioc;\n\tEventDataQueueFull_t *qfull_data;\n\tstruct mptsas_device_info *sas_info;\n\tstruct scsi_device\t*sdev;\n\tint depth;\n\tint id = -1;\n\tint channel = -1;\n\tint fw_id, fw_channel;\n\tu16 current_depth;\n\n\n\tioc = fw_event->ioc;\n\tqfull_data = (EventDataQueueFull_t *)fw_event->event_data;\n\tfw_id = qfull_data->TargetID;\n\tfw_channel = qfull_data->Bus;\n\tcurrent_depth = le16_to_cpu(qfull_data->CurrentDepth);\n\n\t \n\tmutex_lock(&ioc->sas_device_info_mutex);\n\tif (mptscsih_is_phys_disk(ioc, fw_channel, fw_id)) {\n\t\tlist_for_each_entry(sas_info, &ioc->sas_device_info_list,\n\t\t    list) {\n\t\t\tif (sas_info->is_cached ||\n\t\t\t    sas_info->is_logical_volume)\n\t\t\t\tcontinue;\n\t\t\tif (sas_info->is_hidden_raid_component &&\n\t\t\t    (sas_info->fw.channel == fw_channel &&\n\t\t\t    sas_info->fw.id == fw_id)) {\n\t\t\t\tid = sas_info->volume_id;\n\t\t\t\tchannel = MPTSAS_RAID_CHANNEL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlist_for_each_entry(sas_info, &ioc->sas_device_info_list,\n\t\t    list) {\n\t\t\tif (sas_info->is_cached ||\n\t\t\t    sas_info->is_hidden_raid_component ||\n\t\t\t    sas_info->is_logical_volume)\n\t\t\t\tcontinue;\n\t\t\tif (sas_info->fw.channel == fw_channel &&\n\t\t\t    sas_info->fw.id == fw_id) {\n\t\t\t\tid = sas_info->os.id;\n\t\t\t\tchannel = sas_info->os.channel;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t}\n\n out:\n\tmutex_unlock(&ioc->sas_device_info_mutex);\n\n\tif (id != -1) {\n\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\tif (sdev->id == id && sdev->channel == channel) {\n\t\t\t\tif (current_depth > sdev->queue_depth) {\n\t\t\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t    \"strange observation, the queue \"\n\t\t\t\t\t    \"depth is (%d) meanwhile fw queue \"\n\t\t\t\t\t    \"depth (%d)\\n\", sdev->queue_depth,\n\t\t\t\t\t    current_depth);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdepth = scsi_track_queue_full(sdev,\n\t\t\t\t\tsdev->queue_depth - 1);\n\t\t\t\tif (depth > 0)\n\t\t\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t\"Queue depth reduced to (%d)\\n\",\n\t\t\t\t\t   depth);\n\t\t\t\telse if (depth < 0)\n\t\t\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t\"Tagged Command Queueing is being \"\n\t\t\t\t\t\"disabled\\n\");\n\t\t\t\telse if (depth == 0)\n\t\t\t\t\tsdev_printk(KERN_DEBUG, sdev,\n\t\t\t\t\t\"Queue depth not changed yet\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tmptsas_free_fw_event(ioc, fw_event);\n}\n\n\nstatic struct mptsas_phyinfo *\nmptsas_find_phyinfo_by_sas_address(MPT_ADAPTER *ioc, u64 sas_address)\n{\n\tstruct mptsas_portinfo *port_info;\n\tstruct mptsas_phyinfo *phy_info = NULL;\n\tint i;\n\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_for_each_entry(port_info, &ioc->sas_topology, list) {\n\t\tfor (i = 0; i < port_info->num_phys; i++) {\n\t\t\tif (!mptsas_is_end_device(\n\t\t\t\t&port_info->phy_info[i].attached))\n\t\t\t\tcontinue;\n\t\t\tif (port_info->phy_info[i].attached.sas_address\n\t\t\t    != sas_address)\n\t\t\t\tcontinue;\n\t\t\tphy_info = &port_info->phy_info[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\treturn phy_info;\n}\n\n \nstatic struct mptsas_phyinfo *\nmptsas_find_phyinfo_by_phys_disk_num(MPT_ADAPTER *ioc, u8 phys_disk_num,\n\tu8 channel, u8 id)\n{\n\tstruct mptsas_phyinfo *phy_info = NULL;\n\tstruct mptsas_portinfo *port_info;\n\tRaidPhysDiskPage1_t *phys_disk = NULL;\n\tint num_paths;\n\tu64 sas_address = 0;\n\tint i;\n\n\tphy_info = NULL;\n\tif (!ioc->raid_data.pIocPg3)\n\t\treturn NULL;\n\t \n\tnum_paths = mpt_raid_phys_disk_get_num_paths(ioc, phys_disk_num);\n\tif (!num_paths)\n\t\tgoto out;\n\tphys_disk = kzalloc(offsetof(RaidPhysDiskPage1_t, Path) +\n\t   (num_paths * sizeof(RAID_PHYS_DISK1_PATH)), GFP_KERNEL);\n\tif (!phys_disk)\n\t\tgoto out;\n\tmpt_raid_phys_disk_pg1(ioc, phys_disk_num, phys_disk);\n\tfor (i = 0; i < num_paths; i++) {\n\t\tif ((phys_disk->Path[i].Flags & 1) != 0)\n\t\t\t \n\t\t\tcontinue;\n\t\tif ((id == phys_disk->Path[i].PhysDiskID) &&\n\t\t    (channel == phys_disk->Path[i].PhysDiskBus)) {\n\t\t\tmemcpy(&sas_address, &phys_disk->Path[i].WWID,\n\t\t\t\tsizeof(u64));\n\t\t\tphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\n\t\t\t\t\tsas_address);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\tkfree(phys_disk);\n\tif (phy_info)\n\t\treturn phy_info;\n\n\t \n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_for_each_entry(port_info, &ioc->sas_topology, list) {\n\t\tfor (i = 0; i < port_info->num_phys && !phy_info; i++) {\n\t\t\tif (!mptsas_is_end_device(\n\t\t\t\t&port_info->phy_info[i].attached))\n\t\t\t\tcontinue;\n\t\t\tif (port_info->phy_info[i].attached.phys_disk_num == ~0)\n\t\t\t\tcontinue;\n\t\t\tif ((port_info->phy_info[i].attached.phys_disk_num ==\n\t\t\t    phys_disk_num) &&\n\t\t\t    (port_info->phy_info[i].attached.id == id) &&\n\t\t\t    (port_info->phy_info[i].attached.channel ==\n\t\t\t     channel))\n\t\t\t\tphy_info = &port_info->phy_info[i];\n\t\t}\n\t}\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\treturn phy_info;\n}\n\nstatic void\nmptsas_reprobe_lun(struct scsi_device *sdev, void *data)\n{\n\tint rc;\n\n\tsdev->no_uld_attach = data ? 1 : 0;\n\trc = scsi_device_reprobe(sdev);\n}\n\nstatic void\nmptsas_reprobe_target(struct scsi_target *starget, int uld_attach)\n{\n\tstarget_for_each_device(starget, uld_attach ? (void *)1 : NULL,\n\t\t\tmptsas_reprobe_lun);\n}\n\nstatic void\nmptsas_adding_inactive_raid_components(MPT_ADAPTER *ioc, u8 channel, u8 id)\n{\n\tCONFIGPARMS\t\t\tcfg;\n\tConfigPageHeader_t\t\thdr;\n\tdma_addr_t\t\t\tdma_handle;\n\tpRaidVolumePage0_t\t\tbuffer = NULL;\n\tRaidPhysDiskPage0_t \t\tphys_disk;\n\tint\t\t\t\ti;\n\tstruct mptsas_phyinfo\t*phy_info;\n\tstruct mptsas_devinfo\t\tsas_device;\n\n\tmemset(&cfg, 0 , sizeof(CONFIGPARMS));\n\tmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\n\thdr.PageType = MPI_CONFIG_PAGETYPE_RAID_VOLUME;\n\tcfg.pageAddr = (channel << 8) + id;\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\n\tcfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\n\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\tgoto out;\n\n\tif (!hdr.PageLength)\n\t\tgoto out;\n\n\tbuffer = dma_alloc_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t    &dma_handle, GFP_KERNEL);\n\n\tif (!buffer)\n\t\tgoto out;\n\n\tcfg.physAddr = dma_handle;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\n\tif (mpt_config(ioc, &cfg) != 0)\n\t\tgoto out;\n\n\tif (!(buffer->VolumeStatus.Flags &\n\t    MPI_RAIDVOL0_STATUS_FLAG_VOLUME_INACTIVE))\n\t\tgoto out;\n\n\tif (!buffer->NumPhysDisks)\n\t\tgoto out;\n\n\tfor (i = 0; i < buffer->NumPhysDisks; i++) {\n\n\t\tif (mpt_raid_phys_disk_pg0(ioc,\n\t\t    buffer->PhysDisk[i].PhysDiskNum, &phys_disk) != 0)\n\t\t\tcontinue;\n\n\t\tif (mptsas_sas_device_pg0(ioc, &sas_device,\n\t\t    (MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<\n\t\t     MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\n\t\t\t(phys_disk.PhysDiskBus << 8) +\n\t\t\tphys_disk.PhysDiskID))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!(sas_device.flags & MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)\n\t\t\t|| !(sas_device.flags &\n\t\t\tMPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED))\n\t\t\tcontinue;\n\n\n\t\tphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\n\t\t    sas_device.sas_address);\n\t\tmptsas_add_end_device(ioc, phy_info);\n\t}\n\n out:\n\tif (buffer)\n\t\tdma_free_coherent(&ioc->pcidev->dev, hdr.PageLength * 4,\n\t\t\t\t  buffer, dma_handle);\n}\n \nstatic void\nmptsas_hotplug_work(MPT_ADAPTER *ioc, struct fw_event_work *fw_event,\n    struct mptsas_hotplug_event *hot_plug_info)\n{\n\tstruct mptsas_phyinfo *phy_info;\n\tstruct scsi_target * starget;\n\tstruct mptsas_devinfo sas_device;\n\tVirtTarget *vtarget;\n\tint i;\n\tstruct mptsas_portinfo *port_info;\n\n\tswitch (hot_plug_info->event_type) {\n\n\tcase MPTSAS_ADD_PHYSDISK:\n\n\t\tif (!ioc->raid_data.pIocPg2)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {\n\t\t\tif (ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID ==\n\t\t\t    hot_plug_info->id) {\n\t\t\t\tprintk(MYIOC_s_WARN_FMT \"firmware bug: unable \"\n\t\t\t\t    \"to add hidden disk - target_id matches \"\n\t\t\t\t    \"volume_id\\n\", ioc->name);\n\t\t\t\tmptsas_free_fw_event(ioc, fw_event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmpt_findImVolumes(ioc);\n\t\tfallthrough;\n\n\tcase MPTSAS_ADD_DEVICE:\n\t\tmemset(&sas_device, 0, sizeof(struct mptsas_devinfo));\n\t\tmptsas_sas_device_pg0(ioc, &sas_device,\n\t\t    (MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<\n\t\t    MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\n\t\t    (hot_plug_info->channel << 8) +\n\t\t    hot_plug_info->id);\n\n\t\t \n\t\tif (!(sas_device.flags & MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)\n\t\t\t|| !(sas_device.flags &\n\t\t\tMPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED))\n\t\t\tbreak;\n\n\t\tif (!sas_device.handle)\n\t\t\treturn;\n\n\t\tphy_info = mptsas_refreshing_device_handles(ioc, &sas_device);\n\t\t \n\t\tif (!phy_info) {\n\t\t\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\"%s %d HOT PLUG: \"\n\t\t\t\t\"parent handle of device %x\\n\", ioc->name,\n\t\t\t\t__func__, __LINE__, sas_device.handle_parent));\n\t\t\tport_info = mptsas_find_portinfo_by_handle(ioc,\n\t\t\t\tsas_device.handle_parent);\n\n\t\t\tif (port_info == ioc->hba_port_info)\n\t\t\t\tmptsas_probe_hba_phys(ioc);\n\t\t\telse if (port_info)\n\t\t\t\tmptsas_expander_refresh(ioc, port_info);\n\t\t\telse {\n\t\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t\t\"%s %d port info is NULL\\n\",\n\t\t\t\t\tioc->name, __func__, __LINE__));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tphy_info = mptsas_refreshing_device_handles\n\t\t\t\t(ioc, &sas_device);\n\t\t}\n\n\t\tif (!phy_info) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t\"%s %d phy info is NULL\\n\",\n\t\t\t\tioc->name, __func__, __LINE__));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mptsas_get_rphy(phy_info))\n\t\t\tbreak;\n\n\t\tmptsas_add_end_device(ioc, phy_info);\n\t\tbreak;\n\n\tcase MPTSAS_DEL_DEVICE:\n\t\tphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\n\t\t    hot_plug_info->sas_address);\n\t\tmptsas_del_end_device(ioc, phy_info);\n\t\tbreak;\n\n\tcase MPTSAS_DEL_PHYSDISK:\n\n\t\tmpt_findImVolumes(ioc);\n\n\t\tphy_info = mptsas_find_phyinfo_by_phys_disk_num(\n\t\t\t\tioc, hot_plug_info->phys_disk_num,\n\t\t\t\thot_plug_info->channel,\n\t\t\t\thot_plug_info->id);\n\t\tmptsas_del_end_device(ioc, phy_info);\n\t\tbreak;\n\n\tcase MPTSAS_ADD_PHYSDISK_REPROBE:\n\n\t\tif (mptsas_sas_device_pg0(ioc, &sas_device,\n\t\t    (MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<\n\t\t     MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\n\t\t    (hot_plug_info->channel << 8) + hot_plug_info->id)) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t\t __func__, hot_plug_info->id, __LINE__));\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!(sas_device.flags & MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)\n\t\t\t|| !(sas_device.flags &\n\t\t\tMPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED))\n\t\t\tbreak;\n\n\t\tphy_info = mptsas_find_phyinfo_by_sas_address(\n\t\t    ioc, sas_device.sas_address);\n\n\t\tif (!phy_info) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t\"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t\t __func__, hot_plug_info->id, __LINE__));\n\t\t\tbreak;\n\t\t}\n\n\t\tstarget = mptsas_get_starget(phy_info);\n\t\tif (!starget) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t\"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t\t __func__, hot_plug_info->id, __LINE__));\n\t\t\tbreak;\n\t\t}\n\n\t\tvtarget = starget->hostdata;\n\t\tif (!vtarget) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t\"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t\t __func__, hot_plug_info->id, __LINE__));\n\t\t\tbreak;\n\t\t}\n\n\t\tmpt_findImVolumes(ioc);\n\n\t\tstarget_printk(KERN_INFO, starget, MYIOC_s_FMT \"RAID Hidding: \"\n\t\t    \"fw_channel=%d, fw_id=%d, physdsk %d, sas_addr 0x%llx\\n\",\n\t\t    ioc->name, hot_plug_info->channel, hot_plug_info->id,\n\t\t    hot_plug_info->phys_disk_num, (unsigned long long)\n\t\t    sas_device.sas_address);\n\n\t\tvtarget->id = hot_plug_info->phys_disk_num;\n\t\tvtarget->tflags |= MPT_TARGET_FLAGS_RAID_COMPONENT;\n\t\tphy_info->attached.phys_disk_num = hot_plug_info->phys_disk_num;\n\t\tmptsas_reprobe_target(starget, 1);\n\t\tbreak;\n\n\tcase MPTSAS_DEL_PHYSDISK_REPROBE:\n\n\t\tif (mptsas_sas_device_pg0(ioc, &sas_device,\n\t\t    (MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<\n\t\t     MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\n\t\t\t(hot_plug_info->channel << 8) + hot_plug_info->id)) {\n\t\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t\t    \"%s: fw_id=%d exit at line=%d\\n\",\n\t\t\t\t    ioc->name, __func__,\n\t\t\t\t    hot_plug_info->id, __LINE__));\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!(sas_device.flags & MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)\n\t\t\t|| !(sas_device.flags &\n\t\t\tMPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED))\n\t\t\tbreak;\n\n\t\tphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\n\t\t\t\tsas_device.sas_address);\n\t\tif (!phy_info) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t    \"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t __func__, hot_plug_info->id, __LINE__));\n\t\t\tbreak;\n\t\t}\n\n\t\tstarget = mptsas_get_starget(phy_info);\n\t\tif (!starget) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t    \"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t __func__, hot_plug_info->id, __LINE__));\n\t\t\tbreak;\n\t\t}\n\n\t\tvtarget = starget->hostdata;\n\t\tif (!vtarget) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t    \"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t __func__, hot_plug_info->id, __LINE__));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT)) {\n\t\t\tdfailprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t\t    \"%s: fw_id=%d exit at line=%d\\n\", ioc->name,\n\t\t\t __func__, hot_plug_info->id, __LINE__));\n\t\t\tbreak;\n\t\t}\n\n\t\tmpt_findImVolumes(ioc);\n\n\t\tstarget_printk(KERN_INFO, starget, MYIOC_s_FMT \"RAID Exposing:\"\n\t\t    \" fw_channel=%d, fw_id=%d, physdsk %d, sas_addr 0x%llx\\n\",\n\t\t    ioc->name, hot_plug_info->channel, hot_plug_info->id,\n\t\t    hot_plug_info->phys_disk_num, (unsigned long long)\n\t\t    sas_device.sas_address);\n\n\t\tvtarget->tflags &= ~MPT_TARGET_FLAGS_RAID_COMPONENT;\n\t\tvtarget->id = hot_plug_info->id;\n\t\tphy_info->attached.phys_disk_num = ~0;\n\t\tmptsas_reprobe_target(starget, 0);\n\t\tmptsas_add_device_component_by_fw(ioc,\n\t\t    hot_plug_info->channel, hot_plug_info->id);\n\t\tbreak;\n\n\tcase MPTSAS_ADD_RAID:\n\n\t\tmpt_findImVolumes(ioc);\n\t\tprintk(MYIOC_s_INFO_FMT \"attaching raid volume, channel %d, \"\n\t\t    \"id %d\\n\", ioc->name, MPTSAS_RAID_CHANNEL,\n\t\t    hot_plug_info->id);\n\t\tscsi_add_device(ioc->sh, MPTSAS_RAID_CHANNEL,\n\t\t    hot_plug_info->id, 0);\n\t\tbreak;\n\n\tcase MPTSAS_DEL_RAID:\n\n\t\tmpt_findImVolumes(ioc);\n\t\tprintk(MYIOC_s_INFO_FMT \"removing raid volume, channel %d, \"\n\t\t    \"id %d\\n\", ioc->name, MPTSAS_RAID_CHANNEL,\n\t\t    hot_plug_info->id);\n\t\tscsi_remove_device(hot_plug_info->sdev);\n\t\tscsi_device_put(hot_plug_info->sdev);\n\t\tbreak;\n\n\tcase MPTSAS_ADD_INACTIVE_VOLUME:\n\n\t\tmpt_findImVolumes(ioc);\n\t\tmptsas_adding_inactive_raid_components(ioc,\n\t\t    hot_plug_info->channel, hot_plug_info->id);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmptsas_free_fw_event(ioc, fw_event);\n}\n\nstatic void\nmptsas_send_sas_event(struct fw_event_work *fw_event)\n{\n\tMPT_ADAPTER *ioc;\n\tstruct mptsas_hotplug_event hot_plug_info;\n\tEVENT_DATA_SAS_DEVICE_STATUS_CHANGE *sas_event_data;\n\tu32 device_info;\n\tu64 sas_address;\n\n\tioc = fw_event->ioc;\n\tsas_event_data = (EVENT_DATA_SAS_DEVICE_STATUS_CHANGE *)\n\t    fw_event->event_data;\n\tdevice_info = le32_to_cpu(sas_event_data->DeviceInfo);\n\n\tif ((device_info &\n\t\t(MPI_SAS_DEVICE_INFO_SSP_TARGET |\n\t\tMPI_SAS_DEVICE_INFO_STP_TARGET |\n\t\tMPI_SAS_DEVICE_INFO_SATA_DEVICE)) == 0) {\n\t\tmptsas_free_fw_event(ioc, fw_event);\n\t\treturn;\n\t}\n\n\tif (sas_event_data->ReasonCode ==\n\t\tMPI_EVENT_SAS_DEV_STAT_RC_NO_PERSIST_ADDED) {\n\t\tmptbase_sas_persist_operation(ioc,\n\t\tMPI_SAS_OP_CLEAR_NOT_PRESENT);\n\t\tmptsas_free_fw_event(ioc, fw_event);\n\t\treturn;\n\t}\n\n\tswitch (sas_event_data->ReasonCode) {\n\tcase MPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING:\n\tcase MPI_EVENT_SAS_DEV_STAT_RC_ADDED:\n\t\tmemset(&hot_plug_info, 0, sizeof(struct mptsas_hotplug_event));\n\t\thot_plug_info.handle = le16_to_cpu(sas_event_data->DevHandle);\n\t\thot_plug_info.channel = sas_event_data->Bus;\n\t\thot_plug_info.id = sas_event_data->TargetID;\n\t\thot_plug_info.phy_id = sas_event_data->PhyNum;\n\t\tmemcpy(&sas_address, &sas_event_data->SASAddress,\n\t\t    sizeof(u64));\n\t\thot_plug_info.sas_address = le64_to_cpu(sas_address);\n\t\thot_plug_info.device_info = device_info;\n\t\tif (sas_event_data->ReasonCode &\n\t\t    MPI_EVENT_SAS_DEV_STAT_RC_ADDED)\n\t\t\thot_plug_info.event_type = MPTSAS_ADD_DEVICE;\n\t\telse\n\t\t\thot_plug_info.event_type = MPTSAS_DEL_DEVICE;\n\t\tmptsas_hotplug_work(ioc, fw_event, &hot_plug_info);\n\t\tbreak;\n\n\tcase MPI_EVENT_SAS_DEV_STAT_RC_NO_PERSIST_ADDED:\n\t\tmptbase_sas_persist_operation(ioc,\n\t\t    MPI_SAS_OP_CLEAR_NOT_PRESENT);\n\t\tmptsas_free_fw_event(ioc, fw_event);\n\t\tbreak;\n\n\tcase MPI_EVENT_SAS_DEV_STAT_RC_SMART_DATA:\n\t \n\tcase MPI_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET:\n\t \n\tdefault:\n\t\tmptsas_free_fw_event(ioc, fw_event);\n\t\tbreak;\n\t}\n}\n\nstatic void\nmptsas_send_raid_event(struct fw_event_work *fw_event)\n{\n\tMPT_ADAPTER *ioc;\n\tEVENT_DATA_RAID *raid_event_data;\n\tstruct mptsas_hotplug_event hot_plug_info;\n\tint status;\n\tint state;\n\tstruct scsi_device *sdev = NULL;\n\tVirtDevice *vdevice = NULL;\n\tRaidPhysDiskPage0_t phys_disk;\n\n\tioc = fw_event->ioc;\n\traid_event_data = (EVENT_DATA_RAID *)fw_event->event_data;\n\tstatus = le32_to_cpu(raid_event_data->SettingsStatus);\n\tstate = (status >> 8) & 0xff;\n\n\tmemset(&hot_plug_info, 0, sizeof(struct mptsas_hotplug_event));\n\thot_plug_info.id = raid_event_data->VolumeID;\n\thot_plug_info.channel = raid_event_data->VolumeBus;\n\thot_plug_info.phys_disk_num = raid_event_data->PhysDiskNum;\n\n\tif (raid_event_data->ReasonCode == MPI_EVENT_RAID_RC_VOLUME_DELETED ||\n\t    raid_event_data->ReasonCode == MPI_EVENT_RAID_RC_VOLUME_CREATED ||\n\t    raid_event_data->ReasonCode ==\n\t    MPI_EVENT_RAID_RC_VOLUME_STATUS_CHANGED) {\n\t\tsdev = scsi_device_lookup(ioc->sh, MPTSAS_RAID_CHANNEL,\n\t\t    hot_plug_info.id, 0);\n\t\thot_plug_info.sdev = sdev;\n\t\tif (sdev)\n\t\t\tvdevice = sdev->hostdata;\n\t}\n\n\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Entering %s: \"\n\t    \"ReasonCode=%02x\\n\", ioc->name, __func__,\n\t    raid_event_data->ReasonCode));\n\n\tswitch (raid_event_data->ReasonCode) {\n\tcase MPI_EVENT_RAID_RC_PHYSDISK_DELETED:\n\t\thot_plug_info.event_type = MPTSAS_DEL_PHYSDISK_REPROBE;\n\t\tbreak;\n\tcase MPI_EVENT_RAID_RC_PHYSDISK_CREATED:\n\t\thot_plug_info.event_type = MPTSAS_ADD_PHYSDISK_REPROBE;\n\t\tbreak;\n\tcase MPI_EVENT_RAID_RC_PHYSDISK_STATUS_CHANGED:\n\t\tswitch (state) {\n\t\tcase MPI_PD_STATE_ONLINE:\n\t\tcase MPI_PD_STATE_NOT_COMPATIBLE:\n\t\t\tmpt_raid_phys_disk_pg0(ioc,\n\t\t\t    raid_event_data->PhysDiskNum, &phys_disk);\n\t\t\thot_plug_info.id = phys_disk.PhysDiskID;\n\t\t\thot_plug_info.channel = phys_disk.PhysDiskBus;\n\t\t\thot_plug_info.event_type = MPTSAS_ADD_PHYSDISK;\n\t\t\tbreak;\n\t\tcase MPI_PD_STATE_FAILED:\n\t\tcase MPI_PD_STATE_MISSING:\n\t\tcase MPI_PD_STATE_OFFLINE_AT_HOST_REQUEST:\n\t\tcase MPI_PD_STATE_FAILED_AT_HOST_REQUEST:\n\t\tcase MPI_PD_STATE_OFFLINE_FOR_ANOTHER_REASON:\n\t\t\thot_plug_info.event_type = MPTSAS_DEL_PHYSDISK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MPI_EVENT_RAID_RC_VOLUME_DELETED:\n\t\tif (!sdev)\n\t\t\tbreak;\n\t\tvdevice->vtarget->deleted = 1;  \n\t\thot_plug_info.event_type = MPTSAS_DEL_RAID;\n\t\tbreak;\n\tcase MPI_EVENT_RAID_RC_VOLUME_CREATED:\n\t\tif (sdev) {\n\t\t\tscsi_device_put(sdev);\n\t\t\tbreak;\n\t\t}\n\t\thot_plug_info.event_type = MPTSAS_ADD_RAID;\n\t\tbreak;\n\tcase MPI_EVENT_RAID_RC_VOLUME_STATUS_CHANGED:\n\t\tif (!(status & MPI_RAIDVOL0_STATUS_FLAG_ENABLED)) {\n\t\t\tif (!sdev)\n\t\t\t\tbreak;\n\t\t\tvdevice->vtarget->deleted = 1;  \n\t\t\thot_plug_info.event_type = MPTSAS_DEL_RAID;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (state) {\n\t\tcase MPI_RAIDVOL0_STATUS_STATE_FAILED:\n\t\tcase MPI_RAIDVOL0_STATUS_STATE_MISSING:\n\t\t\tif (!sdev)\n\t\t\t\tbreak;\n\t\t\tvdevice->vtarget->deleted = 1;  \n\t\t\thot_plug_info.event_type = MPTSAS_DEL_RAID;\n\t\t\tbreak;\n\t\tcase MPI_RAIDVOL0_STATUS_STATE_OPTIMAL:\n\t\tcase MPI_RAIDVOL0_STATUS_STATE_DEGRADED:\n\t\t\tif (sdev) {\n\t\t\t\tscsi_device_put(sdev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thot_plug_info.event_type = MPTSAS_ADD_RAID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (hot_plug_info.event_type != MPTSAS_IGNORE_EVENT)\n\t\tmptsas_hotplug_work(ioc, fw_event, &hot_plug_info);\n\telse\n\t\tmptsas_free_fw_event(ioc, fw_event);\n}\n\n \nstatic int\nmptsas_issue_tm(MPT_ADAPTER *ioc, u8 type, u8 channel, u8 id, u64 lun,\n\tint task_context, ulong timeout, u8 *issue_reset)\n{\n\tMPT_FRAME_HDR\t*mf;\n\tSCSITaskMgmt_t\t*pScsiTm;\n\tint\t\t retval;\n\tunsigned long\t timeleft;\n\n\t*issue_reset = 0;\n\tmf = mpt_get_msg_frame(mptsasDeviceResetCtx, ioc);\n\tif (mf == NULL) {\n\t\tretval = -1;  \n\t\tdtmprintk(ioc, printk(MYIOC_s_WARN_FMT \"TaskMgmt request: no \"\n\t\t    \"msg frames!!\\n\", ioc->name));\n\t\tgoto out;\n\t}\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"TaskMgmt request: mr = %p, \"\n\t    \"task_type = 0x%02X,\\n\\t timeout = %ld, fw_channel = %d, \"\n\t    \"fw_id = %d, lun = %lld,\\n\\t task_context = 0x%x\\n\", ioc->name, mf,\n\t     type, timeout, channel, id, (unsigned long long)lun,\n\t     task_context));\n\n\tpScsiTm = (SCSITaskMgmt_t *) mf;\n\tmemset(pScsiTm, 0, sizeof(SCSITaskMgmt_t));\n\tpScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;\n\tpScsiTm->TaskType = type;\n\tpScsiTm->MsgFlags = 0;\n\tpScsiTm->TargetID = id;\n\tpScsiTm->Bus = channel;\n\tpScsiTm->ChainOffset = 0;\n\tpScsiTm->Reserved = 0;\n\tpScsiTm->Reserved1 = 0;\n\tpScsiTm->TaskMsgContext = task_context;\n\tint_to_scsilun(lun, (struct scsi_lun *)pScsiTm->LUN);\n\n\tINITIALIZE_MGMT_STATUS(ioc->taskmgmt_cmds.status)\n\tCLEAR_MGMT_STATUS(ioc->internal_cmds.status)\n\tretval = 0;\n\tmpt_put_msg_frame_hi_pri(mptsasDeviceResetCtx, ioc, mf);\n\n\t \n\ttimeleft = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done,\n\t    timeout*HZ);\n\tif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tretval = -1;  \n\t\tdtmprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t    \"TaskMgmt request: TIMED OUT!(mr=%p)\\n\", ioc->name, mf));\n\t\tmpt_free_msg_frame(ioc, mf);\n\t\tif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\n\t\t\tgoto out;\n\t\t*issue_reset = 1;\n\t\tgoto out;\n\t}\n\n\tif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\n\t\tretval = -1;  \n\t\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"TaskMgmt request: failed with no reply\\n\", ioc->name));\n\t\tgoto out;\n\t}\n\n out:\n\tCLEAR_MGMT_STATUS(ioc->taskmgmt_cmds.status)\n\treturn retval;\n}\n\n \nstatic void\nmptsas_broadcast_primitive_work(struct fw_event_work *fw_event)\n{\n\tMPT_ADAPTER *ioc = fw_event->ioc;\n\tMPT_FRAME_HDR\t*mf;\n\tVirtDevice\t*vdevice;\n\tint\t\t\tii;\n\tstruct scsi_cmnd\t*sc;\n\tSCSITaskMgmtReply_t\t*pScsiTmReply;\n\tu8\t\t\tissue_reset;\n\tint\t\t\ttask_context;\n\tu8\t\t\tchannel, id;\n\tint\t\t\t lun;\n\tu32\t\t\t termination_count;\n\tu32\t\t\t query_count;\n\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"%s - enter\\n\", ioc->name, __func__));\n\n\tmutex_lock(&ioc->taskmgmt_cmds.mutex);\n\tif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {\n\t\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\t\tmptsas_requeue_fw_event(ioc, fw_event, 1000);\n\t\treturn;\n\t}\n\n\tissue_reset = 0;\n\ttermination_count = 0;\n\tquery_count = 0;\n\tmpt_findImVolumes(ioc);\n\tpScsiTmReply = (SCSITaskMgmtReply_t *) ioc->taskmgmt_cmds.reply;\n\n\tfor (ii = 0; ii < ioc->req_depth; ii++) {\n\t\tif (ioc->fw_events_off)\n\t\t\tgoto out;\n\t\tsc = mptscsih_get_scsi_lookup(ioc, ii);\n\t\tif (!sc)\n\t\t\tcontinue;\n\t\tmf = MPT_INDEX_2_MFPTR(ioc, ii);\n\t\tif (!mf)\n\t\t\tcontinue;\n\t\ttask_context = mf->u.frame.hwhdr.msgctxu.MsgContext;\n\t\tvdevice = sc->device->hostdata;\n\t\tif (!vdevice || !vdevice->vtarget)\n\t\t\tcontinue;\n\t\tif (vdevice->vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\t\tcontinue;  \n\t\tif (vdevice->vtarget->raidVolume)\n\t\t\tcontinue;  \n\t\tchannel = vdevice->vtarget->channel;\n\t\tid = vdevice->vtarget->id;\n\t\tlun = vdevice->lun;\n\t\tif (mptsas_issue_tm(ioc, MPI_SCSITASKMGMT_TASKTYPE_QUERY_TASK,\n\t\t    channel, id, (u64)lun, task_context, 30, &issue_reset))\n\t\t\tgoto out;\n\t\tquery_count++;\n\t\ttermination_count +=\n\t\t    le32_to_cpu(pScsiTmReply->TerminationCount);\n\t\tif ((pScsiTmReply->IOCStatus == MPI_IOCSTATUS_SUCCESS) &&\n\t\t    (pScsiTmReply->ResponseCode ==\n\t\t    MPI_SCSITASKMGMT_RSP_TM_SUCCEEDED ||\n\t\t    pScsiTmReply->ResponseCode ==\n\t\t    MPI_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC))\n\t\t\tcontinue;\n\t\tif (mptsas_issue_tm(ioc,\n\t\t    MPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET,\n\t\t    channel, id, (u64)lun, 0, 30, &issue_reset))\n\t\t\tgoto out;\n\t\ttermination_count +=\n\t\t    le32_to_cpu(pScsiTmReply->TerminationCount);\n\t}\n\n out:\n\tdtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t    \"%s - exit, query_count = %d termination_count = %d\\n\",\n\t    ioc->name, __func__, query_count, termination_count));\n\n\tioc->broadcast_aen_busy = 0;\n\tmpt_clear_taskmgmt_in_progress_flag(ioc);\n\tmutex_unlock(&ioc->taskmgmt_cmds.mutex);\n\n\tif (issue_reset) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t       \"Issuing Reset from %s!! doorbell=0x%08x\\n\",\n\t\t       ioc->name, __func__, mpt_GetIocState(ioc, 0));\n\t\tmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\n\t}\n\tmptsas_free_fw_event(ioc, fw_event);\n}\n\n \nstatic void\nmptsas_send_ir2_event(struct fw_event_work *fw_event)\n{\n\tMPT_ADAPTER\t*ioc;\n\tstruct mptsas_hotplug_event hot_plug_info;\n\tMPI_EVENT_DATA_IR2\t*ir2_data;\n\tu8 reasonCode;\n\tRaidPhysDiskPage0_t phys_disk;\n\n\tioc = fw_event->ioc;\n\tir2_data = (MPI_EVENT_DATA_IR2 *)fw_event->event_data;\n\treasonCode = ir2_data->ReasonCode;\n\n\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"Entering %s: \"\n\t    \"ReasonCode=%02x\\n\", ioc->name, __func__, reasonCode));\n\n\tmemset(&hot_plug_info, 0, sizeof(struct mptsas_hotplug_event));\n\thot_plug_info.id = ir2_data->TargetID;\n\thot_plug_info.channel = ir2_data->Bus;\n\tswitch (reasonCode) {\n\tcase MPI_EVENT_IR2_RC_FOREIGN_CFG_DETECTED:\n\t\thot_plug_info.event_type = MPTSAS_ADD_INACTIVE_VOLUME;\n\t\tbreak;\n\tcase MPI_EVENT_IR2_RC_DUAL_PORT_REMOVED:\n\t\thot_plug_info.phys_disk_num = ir2_data->PhysDiskNum;\n\t\thot_plug_info.event_type = MPTSAS_DEL_PHYSDISK;\n\t\tbreak;\n\tcase MPI_EVENT_IR2_RC_DUAL_PORT_ADDED:\n\t\thot_plug_info.phys_disk_num = ir2_data->PhysDiskNum;\n\t\tmpt_raid_phys_disk_pg0(ioc,\n\t\t    ir2_data->PhysDiskNum, &phys_disk);\n\t\thot_plug_info.id = phys_disk.PhysDiskID;\n\t\thot_plug_info.event_type = MPTSAS_ADD_PHYSDISK;\n\t\tbreak;\n\tdefault:\n\t\tmptsas_free_fw_event(ioc, fw_event);\n\t\treturn;\n\t}\n\tmptsas_hotplug_work(ioc, fw_event, &hot_plug_info);\n}\n\nstatic int\nmptsas_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *reply)\n{\n\tu32 event = le32_to_cpu(reply->Event);\n\tint event_data_sz;\n\tstruct fw_event_work *fw_event;\n\tunsigned long delay;\n\n\tif (ioc->bus_type != SAS)\n\t\treturn 0;\n\n\t \n\tif (ioc->fw_events_off)\n\t\treturn 0;\n\n\tdelay = msecs_to_jiffies(1);\n\tswitch (event) {\n\tcase MPI_EVENT_SAS_BROADCAST_PRIMITIVE:\n\t{\n\t\tEVENT_DATA_SAS_BROADCAST_PRIMITIVE *broadcast_event_data =\n\t\t    (EVENT_DATA_SAS_BROADCAST_PRIMITIVE *)reply->Data;\n\t\tif (broadcast_event_data->Primitive !=\n\t\t    MPI_EVENT_PRIMITIVE_ASYNCHRONOUS_EVENT)\n\t\t\treturn 0;\n\t\tif (ioc->broadcast_aen_busy)\n\t\t\treturn 0;\n\t\tioc->broadcast_aen_busy = 1;\n\t\tbreak;\n\t}\n\tcase MPI_EVENT_SAS_DEVICE_STATUS_CHANGE:\n\t{\n\t\tEVENT_DATA_SAS_DEVICE_STATUS_CHANGE *sas_event_data =\n\t\t    (EVENT_DATA_SAS_DEVICE_STATUS_CHANGE *)reply->Data;\n\t\tu16\tioc_stat;\n\t\tioc_stat = le16_to_cpu(reply->IOCStatus);\n\n\t\tif (sas_event_data->ReasonCode ==\n\t\t    MPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING) {\n\t\t\tmptsas_target_reset_queue(ioc, sas_event_data);\n\t\t\treturn 0;\n\t\t}\n\t\tif (sas_event_data->ReasonCode ==\n\t\t\tMPI_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET &&\n\t\t\tioc->device_missing_delay &&\n\t\t\t(ioc_stat & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE)) {\n\t\t\tVirtTarget *vtarget = NULL;\n\t\t\tu8\t\tid, channel;\n\n\t\t\tid = sas_event_data->TargetID;\n\t\t\tchannel = sas_event_data->Bus;\n\n\t\t\tvtarget = mptsas_find_vtarget(ioc, channel, id);\n\t\t\tif (vtarget) {\n\t\t\t\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t    \"LogInfo (0x%x) available for \"\n\t\t\t\t   \"INTERNAL_DEVICE_RESET\"\n\t\t\t\t   \"fw_id %d fw_channel %d\\n\", ioc->name,\n\t\t\t\t   le32_to_cpu(reply->IOCLogInfo),\n\t\t\t\t   id, channel));\n\t\t\t\tif (vtarget->raidVolume) {\n\t\t\t\t\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\"Skipping Raid Volume for inDMD\\n\",\n\t\t\t\t\tioc->name));\n\t\t\t\t} else {\n\t\t\t\t\tdevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\t\t\"Setting device flag inDMD\\n\",\n\t\t\t\t\tioc->name));\n\t\t\t\t\tvtarget->inDMD = 1;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase MPI_EVENT_SAS_EXPANDER_STATUS_CHANGE:\n\t{\n\t\tMpiEventDataSasExpanderStatusChange_t *expander_data =\n\t\t    (MpiEventDataSasExpanderStatusChange_t *)reply->Data;\n\n\t\tif (ioc->old_sas_discovery_protocal)\n\t\t\treturn 0;\n\n\t\tif (expander_data->ReasonCode ==\n\t\t    MPI_EVENT_SAS_EXP_RC_NOT_RESPONDING &&\n\t\t    ioc->device_missing_delay)\n\t\t\tdelay = HZ * ioc->device_missing_delay;\n\t\tbreak;\n\t}\n\tcase MPI_EVENT_SAS_DISCOVERY:\n\t{\n\t\tu32 discovery_status;\n\t\tEventDataSasDiscovery_t *discovery_data =\n\t\t    (EventDataSasDiscovery_t *)reply->Data;\n\n\t\tdiscovery_status = le32_to_cpu(discovery_data->DiscoveryStatus);\n\t\tioc->sas_discovery_quiesce_io = discovery_status ? 1 : 0;\n\t\tif (ioc->old_sas_discovery_protocal && !discovery_status)\n\t\t\tmptsas_queue_rescan(ioc);\n\t\treturn 0;\n\t}\n\tcase MPI_EVENT_INTEGRATED_RAID:\n\tcase MPI_EVENT_PERSISTENT_TABLE_FULL:\n\tcase MPI_EVENT_IR2:\n\tcase MPI_EVENT_SAS_PHY_LINK_STATUS:\n\tcase MPI_EVENT_QUEUE_FULL:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tevent_data_sz = ((reply->MsgLength * 4) -\n\t    offsetof(EventNotificationReply_t, Data));\n\tfw_event = kzalloc(sizeof(*fw_event) + event_data_sz, GFP_ATOMIC);\n\tif (!fw_event) {\n\t\tprintk(MYIOC_s_WARN_FMT \"%s: failed at (line=%d)\\n\", ioc->name,\n\t\t __func__, __LINE__);\n\t\treturn 0;\n\t}\n\tmemcpy(fw_event->event_data, reply->Data, event_data_sz);\n\tfw_event->event = event;\n\tfw_event->ioc = ioc;\n\tmptsas_add_fw_event(ioc, fw_event, delay);\n\treturn 0;\n}\n\n \nstatic void mptsas_volume_delete(MPT_ADAPTER *ioc, u8 id)\n{\n\tstruct scsi_device *sdev;\n\tint i;\n\n\tsdev = scsi_device_lookup(ioc->sh, MPTSAS_RAID_CHANNEL, id, 0);\n\tif (!sdev)\n\t\treturn;\n\tif (!ioc->raid_data.pIocPg2)\n\t\tgoto out;\n\tif (!ioc->raid_data.pIocPg2->NumActiveVolumes)\n\t\tgoto out;\n\tfor (i = 0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++)\n\t\tif (ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID == id)\n\t\t\tgoto release_sdev;\n out:\n\tprintk(MYIOC_s_INFO_FMT \"removing raid volume, channel %d, \"\n\t    \"id %d\\n\", ioc->name, MPTSAS_RAID_CHANNEL, id);\n\tscsi_remove_device(sdev);\n release_sdev:\n\tscsi_device_put(sdev);\n}\n\nstatic int\nmptsas_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct Scsi_Host\t*sh;\n\tMPT_SCSI_HOST\t\t*hd;\n\tMPT_ADAPTER \t\t*ioc;\n\tunsigned long\t\t flags;\n\tint\t\t\t ii;\n\tint\t\t\t numSGE = 0;\n\tint\t\t\t scale;\n\tint\t\t\t ioc_cap;\n\tint\t\t\terror=0;\n\tint\t\t\tr;\n\n\tr = mpt_attach(pdev,id);\n\tif (r)\n\t\treturn r;\n\n\tioc = pci_get_drvdata(pdev);\n\tmptsas_fw_event_off(ioc);\n\tioc->DoneCtx = mptsasDoneCtx;\n\tioc->TaskCtx = mptsasTaskCtx;\n\tioc->InternalCtx = mptsasInternalCtx;\n\tioc->schedule_target_reset = &mptsas_schedule_target_reset;\n\tioc->schedule_dead_ioc_flush_running_cmds =\n\t\t\t\t&mptscsih_flush_running_cmds;\n\t \n\tif (ioc->last_state != MPI_IOC_STATE_OPERATIONAL) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t  \"Skipping because it's not operational!\\n\",\n\t\t  ioc->name);\n\t\terror = -ENODEV;\n\t\tgoto out_mptsas_probe;\n\t}\n\n\tif (!ioc->active) {\n\t\tprintk(MYIOC_s_WARN_FMT \"Skipping because it's disabled!\\n\",\n\t\t  ioc->name);\n\t\terror = -ENODEV;\n\t\tgoto out_mptsas_probe;\n\t}\n\n\t \n\tioc_cap = 0;\n\tfor (ii = 0; ii < ioc->facts.NumberOfPorts; ii++) {\n\t\tif (ioc->pfacts[ii].ProtocolFlags &\n\t\t\t\tMPI_PORTFACTS_PROTOCOL_INITIATOR)\n\t\t\tioc_cap++;\n\t}\n\n\tif (!ioc_cap) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\"Skipping ioc=%p because SCSI Initiator mode \"\n\t\t\t\"is NOT enabled!\\n\", ioc->name, ioc);\n\t\treturn 0;\n\t}\n\n\tsh = scsi_host_alloc(&mptsas_driver_template, sizeof(MPT_SCSI_HOST));\n\tif (!sh) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\"Unable to register controller with SCSI subsystem\\n\",\n\t\t\tioc->name);\n\t\terror = -1;\n\t\tgoto out_mptsas_probe;\n        }\n\n\tspin_lock_irqsave(&ioc->FreeQlock, flags);\n\n\t \n\tioc->sh = sh;\n\n\tsh->io_port = 0;\n\tsh->n_io_port = 0;\n\tsh->irq = 0;\n\n\t \n\tsh->max_cmd_len = 16;\n\tsh->can_queue = min_t(int, ioc->req_depth - 10, sh->can_queue);\n\tsh->max_id = -1;\n\tsh->max_lun = max_lun;\n\tsh->transportt = mptsas_transport_template;\n\n\t \n\tsh->unique_id = ioc->id;\n\n\tINIT_LIST_HEAD(&ioc->sas_topology);\n\tmutex_init(&ioc->sas_topology_mutex);\n\tmutex_init(&ioc->sas_discovery_mutex);\n\tmutex_init(&ioc->sas_mgmt.mutex);\n\tinit_completion(&ioc->sas_mgmt.done);\n\n\t \n\tscale = ioc->req_sz/ioc->SGE_size;\n\tif (ioc->sg_addr_size == sizeof(u64)) {\n\t\tnumSGE = (scale - 1) *\n\t\t  (ioc->facts.MaxChainDepth-1) + scale +\n\t\t  (ioc->req_sz - 60) / ioc->SGE_size;\n\t} else {\n\t\tnumSGE = 1 + (scale - 1) *\n\t\t  (ioc->facts.MaxChainDepth-1) + scale +\n\t\t  (ioc->req_sz - 64) / ioc->SGE_size;\n\t}\n\n\tif (numSGE < sh->sg_tablesize) {\n\t\t \n\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t  \"Resetting sg_tablesize to %d from %d\\n\",\n\t\t  ioc->name, numSGE, sh->sg_tablesize));\n\t\tsh->sg_tablesize = numSGE;\n\t}\n\n\tif (mpt_loadtime_max_sectors) {\n\t\tif (mpt_loadtime_max_sectors < 64 ||\n\t\t\tmpt_loadtime_max_sectors > 8192) {\n\t\t\tprintk(MYIOC_s_INFO_FMT \"Invalid value passed for\"\n\t\t\t\t\"mpt_loadtime_max_sectors %d.\"\n\t\t\t\t\"Range from 64 to 8192\\n\", ioc->name,\n\t\t\t\tmpt_loadtime_max_sectors);\n\t\t}\n\t\tmpt_loadtime_max_sectors &=  0xFFFFFFFE;\n\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"Resetting max sector to %d from %d\\n\",\n\t\t  ioc->name, mpt_loadtime_max_sectors, sh->max_sectors));\n\t\tsh->max_sectors = mpt_loadtime_max_sectors;\n\t}\n\n\thd = shost_priv(sh);\n\thd->ioc = ioc;\n\n\t \n\tioc->ScsiLookup = kcalloc(ioc->req_depth, sizeof(void *), GFP_ATOMIC);\n\tif (!ioc->ScsiLookup) {\n\t\terror = -ENOMEM;\n\t\tspin_unlock_irqrestore(&ioc->FreeQlock, flags);\n\t\tgoto out_mptsas_probe;\n\t}\n\tspin_lock_init(&ioc->scsi_lookup_lock);\n\n\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"ScsiLookup @ %p\\n\",\n\t\t ioc->name, ioc->ScsiLookup));\n\n\tioc->sas_data.ptClear = mpt_pt_clear;\n\n\thd->last_queue_full = 0;\n\tINIT_LIST_HEAD(&hd->target_reset_list);\n\tINIT_LIST_HEAD(&ioc->sas_device_info_list);\n\tmutex_init(&ioc->sas_device_info_mutex);\n\n\tspin_unlock_irqrestore(&ioc->FreeQlock, flags);\n\n\tif (ioc->sas_data.ptClear==1) {\n\t\tmptbase_sas_persist_operation(\n\t\t    ioc, MPI_SAS_OP_CLEAR_ALL_PERSISTENT);\n\t}\n\n\terror = scsi_add_host(sh, &ioc->pcidev->dev);\n\tif (error) {\n\t\tdprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t  \"scsi_add_host failed\\n\", ioc->name));\n\t\tgoto out_mptsas_probe;\n\t}\n\n\t \n\tif ((ioc->facts.HeaderVersion >> 8) < 0xE)\n\t\tioc->old_sas_discovery_protocal = 1;\n\tmptsas_scan_sas_topology(ioc);\n\tmptsas_fw_event_on(ioc);\n\treturn 0;\n\n out_mptsas_probe:\n\n\tmptscsih_remove(pdev);\n\treturn error;\n}\n\nstatic void\nmptsas_shutdown(struct pci_dev *pdev)\n{\n\tMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\n\n\tmptsas_fw_event_off(ioc);\n\tmptsas_cleanup_fw_event_q(ioc);\n}\n\nstatic void mptsas_remove(struct pci_dev *pdev)\n{\n\tMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\n\tstruct mptsas_portinfo *p, *n;\n\tint i;\n\n\tif (!ioc->sh) {\n\t\tprintk(MYIOC_s_INFO_FMT \"IOC is in Target mode\\n\", ioc->name);\n\t\tmpt_detach(pdev);\n\t\treturn;\n\t}\n\n\tmptsas_shutdown(pdev);\n\n\tmptsas_del_device_components(ioc);\n\n\tioc->sas_discovery_ignore_events = 1;\n\tsas_remove_host(ioc->sh);\n\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_for_each_entry_safe(p, n, &ioc->sas_topology, list) {\n\t\tlist_del(&p->list);\n\t\tfor (i = 0 ; i < p->num_phys ; i++)\n\t\t\tmptsas_port_delete(ioc, p->phy_info[i].port_details);\n\n\t\tkfree(p->phy_info);\n\t\tkfree(p);\n\t}\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\tioc->hba_port_info = NULL;\n\tmptscsih_remove(pdev);\n}\n\nstatic struct pci_device_id mptsas_pci_table[] = {\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVID_SAS1064,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVID_SAS1068,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVID_SAS1064E,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVID_SAS1068E,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVID_SAS1078,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVID_SAS1068_820XELP,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{0}\t \n};\nMODULE_DEVICE_TABLE(pci, mptsas_pci_table);\n\n\nstatic struct pci_driver mptsas_driver = {\n\t.name\t\t= \"mptsas\",\n\t.id_table\t= mptsas_pci_table,\n\t.probe\t\t= mptsas_probe,\n\t.remove\t\t= mptsas_remove,\n\t.shutdown\t= mptsas_shutdown,\n#ifdef CONFIG_PM\n\t.suspend\t= mptscsih_suspend,\n\t.resume\t\t= mptscsih_resume,\n#endif\n};\n\nstatic int __init\nmptsas_init(void)\n{\n\tint error;\n\n\tshow_mptmod_ver(my_NAME, my_VERSION);\n\n\tmptsas_transport_template =\n\t    sas_attach_transport(&mptsas_transport_functions);\n\tif (!mptsas_transport_template)\n\t\treturn -ENODEV;\n\n\tmptsasDoneCtx = mpt_register(mptscsih_io_done, MPTSAS_DRIVER,\n\t    \"mptscsih_io_done\");\n\tmptsasTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTSAS_DRIVER,\n\t    \"mptscsih_taskmgmt_complete\");\n\tmptsasInternalCtx =\n\t\tmpt_register(mptscsih_scandv_complete, MPTSAS_DRIVER,\n\t\t    \"mptscsih_scandv_complete\");\n\tmptsasMgmtCtx = mpt_register(mptsas_mgmt_done, MPTSAS_DRIVER,\n\t    \"mptsas_mgmt_done\");\n\tmptsasDeviceResetCtx =\n\t\tmpt_register(mptsas_taskmgmt_complete, MPTSAS_DRIVER,\n\t\t    \"mptsas_taskmgmt_complete\");\n\n\tmpt_event_register(mptsasDoneCtx, mptsas_event_process);\n\tmpt_reset_register(mptsasDoneCtx, mptsas_ioc_reset);\n\n\terror = pci_register_driver(&mptsas_driver);\n\tif (error)\n\t\tsas_release_transport(mptsas_transport_template);\n\n\treturn error;\n}\n\nstatic void __exit\nmptsas_exit(void)\n{\n\tpci_unregister_driver(&mptsas_driver);\n\tsas_release_transport(mptsas_transport_template);\n\n\tmpt_reset_deregister(mptsasDoneCtx);\n\tmpt_event_deregister(mptsasDoneCtx);\n\n\tmpt_deregister(mptsasMgmtCtx);\n\tmpt_deregister(mptsasInternalCtx);\n\tmpt_deregister(mptsasTaskCtx);\n\tmpt_deregister(mptsasDoneCtx);\n\tmpt_deregister(mptsasDeviceResetCtx);\n}\n\nmodule_init(mptsas_init);\nmodule_exit(mptsas_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}