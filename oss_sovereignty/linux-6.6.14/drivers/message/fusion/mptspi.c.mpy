{
  "module_name": "mptspi.c",
  "hash_id": "46e453aefad031d774a75d62d567a748ccd382092fa8ecdcfd6d7d22cca18a37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/message/fusion/mptspi.c",
  "human_readable_source": " \n \n \n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/kdev_t.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\t \n#include <linux/interrupt.h>\n#include <linux/reboot.h>\t \n#include <linux/workqueue.h>\n#include <linux/raid_class.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_spi.h>\n#include <scsi/scsi_dbg.h>\n\n#include \"mptbase.h\"\n#include \"mptscsih.h\"\n\n \n#define my_NAME\t\t\"Fusion MPT SPI Host driver\"\n#define my_VERSION\tMPT_LINUX_VERSION_COMMON\n#define MYNAM\t\t\"mptspi\"\n\nMODULE_AUTHOR(MODULEAUTHOR);\nMODULE_DESCRIPTION(my_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(my_VERSION);\n\n \nstatic int mpt_saf_te = MPTSCSIH_SAF_TE;\nmodule_param(mpt_saf_te, int, 0);\nMODULE_PARM_DESC(mpt_saf_te, \" Force enabling SEP Processor: enable=1  (default=MPTSCSIH_SAF_TE=0)\");\n\nstatic void mptspi_write_offset(struct scsi_target *, int);\nstatic void mptspi_write_width(struct scsi_target *, int);\nstatic int mptspi_write_spi_device_pg1(struct scsi_target *,\n\t\t\t\t       struct _CONFIG_PAGE_SCSI_DEVICE_1 *);\n\nstatic struct scsi_transport_template *mptspi_transport_template = NULL;\n\nstatic u8\tmptspiDoneCtx = MPT_MAX_PROTOCOL_DRIVERS;\nstatic u8\tmptspiTaskCtx = MPT_MAX_PROTOCOL_DRIVERS;\nstatic u8\tmptspiInternalCtx = MPT_MAX_PROTOCOL_DRIVERS;  \n\n \nstatic void\nmptspi_setTargetNegoParms(MPT_SCSI_HOST *hd, VirtTarget *target,\n\t\t\t    struct scsi_device *sdev)\n{\n\tMPT_ADAPTER *ioc = hd->ioc;\n\tSpiCfgData *pspi_data = &ioc->spi_data;\n\tint  id = (int) target->id;\n\tint  nvram;\n\tu8 width = MPT_NARROW;\n\tu8 factor = MPT_ASYNC;\n\tu8 offset = 0;\n\tu8 nfactor;\n\tu8 noQas = 1;\n\n\ttarget->negoFlags = pspi_data->noQas;\n\n\tif (sdev->scsi_level < SCSI_2) {\n\t\twidth = 0;\n\t\tfactor = MPT_ULTRA2;\n\t\toffset = pspi_data->maxSyncOffset;\n\t\ttarget->tflags &= ~MPT_TARGET_FLAGS_Q_YES;\n\t} else {\n\t\tif (scsi_device_wide(sdev))\n\t\t\twidth = 1;\n\n\t\tif (scsi_device_sync(sdev)) {\n\t\t\tfactor = pspi_data->minSyncFactor;\n\t\t\tif (!scsi_device_dt(sdev))\n\t\t\t\t\tfactor = MPT_ULTRA2;\n\t\t\telse {\n\t\t\t\tif (!scsi_device_ius(sdev) &&\n\t\t\t\t    !scsi_device_qas(sdev))\n\t\t\t\t\tfactor = MPT_ULTRA160;\n\t\t\t\telse {\n\t\t\t\t\tfactor = MPT_ULTRA320;\n\t\t\t\t\tif (scsi_device_qas(sdev)) {\n\t\t\t\t\t\tddvprintk(ioc,\n\t\t\t\t\t\tprintk(MYIOC_s_DEBUG_FMT \"Enabling QAS due to \"\n\t\t\t\t\t\t\"byte56=%02x on id=%d!\\n\", ioc->name,\n\t\t\t\t\t\tscsi_device_qas(sdev), id));\n\t\t\t\t\t\tnoQas = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (sdev->type == TYPE_TAPE &&\n\t\t\t\t\t    scsi_device_ius(sdev))\n\t\t\t\t\t\ttarget->negoFlags |= MPT_TAPE_NEGO_IDP;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = pspi_data->maxSyncOffset;\n\n\t\t\t \n\t\t\tif (target->raidVolume == 1)\n\t\t\t\tnoQas = 0;\n\t\t} else {\n\t\t\tfactor = MPT_ASYNC;\n\t\t\toffset = 0;\n\t\t}\n\t}\n\n\tif (!sdev->tagged_supported)\n\t\ttarget->tflags &= ~MPT_TARGET_FLAGS_Q_YES;\n\n\t \n\tif (pspi_data->nvram && (pspi_data->nvram[id] != MPT_HOST_NVRAM_INVALID)) {\n\t\tnvram = pspi_data->nvram[id];\n\t\tnfactor = (nvram & MPT_NVRAM_SYNC_MASK) >> 8;\n\n\t\tif (width)\n\t\t\twidth = nvram & MPT_NVRAM_WIDE_DISABLE ? 0 : 1;\n\n\t\tif (offset > 0) {\n\t\t\t \n\t\t\tif (nfactor) {\n\t\t\t\tif (nfactor < pspi_data->minSyncFactor )\n\t\t\t\t\tnfactor = pspi_data->minSyncFactor;\n\n\t\t\t\tfactor = max(factor, nfactor);\n\t\t\t\tif (factor == MPT_ASYNC)\n\t\t\t\t\toffset = 0;\n\t\t\t} else {\n\t\t\t\toffset = 0;\n\t\t\t\tfactor = MPT_ASYNC;\n\t\t}\n\t\t} else {\n\t\t\tfactor = MPT_ASYNC;\n\t\t}\n\t}\n\n\t \n\tif ((!width) && (factor < MPT_ULTRA2))\n\t\tfactor = MPT_ULTRA2;\n\n\t \n\ttarget->minSyncFactor = factor;\n\ttarget->maxOffset = offset;\n\ttarget->maxWidth = width;\n\n\tspi_min_period(scsi_target(sdev)) = factor;\n\tspi_max_offset(scsi_target(sdev)) = offset;\n\tspi_max_width(scsi_target(sdev)) = width;\n\n\ttarget->tflags |= MPT_TARGET_FLAGS_VALID_NEGO;\n\n\t \n\tif (!width)\n\t\ttarget->negoFlags |= MPT_TARGET_NO_NEGO_WIDE;\n\n\tif (!offset)\n\t\ttarget->negoFlags |= MPT_TARGET_NO_NEGO_SYNC;\n\n\tif ( factor > MPT_ULTRA320 )\n\t\tnoQas = 0;\n\n\tif (noQas && (pspi_data->noQas == 0)) {\n\t\tpspi_data->noQas |= MPT_TARGET_NO_NEGO_QAS;\n\t\ttarget->negoFlags |= MPT_TARGET_NO_NEGO_QAS;\n\n\t\t \n\n\t\tddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\t\"Disabling QAS due to noQas=%02x on id=%d!\\n\", ioc->name, noQas, id));\n\t}\n}\n\n \nstatic int\nmptspi_writeIOCPage4(MPT_SCSI_HOST *hd, u8 channel , u8 id)\n{\n\tMPT_ADAPTER\t\t*ioc = hd->ioc;\n\tConfig_t\t\t*pReq;\n\tIOCPage4_t\t\t*IOCPage4Ptr;\n\tMPT_FRAME_HDR\t\t*mf;\n\tdma_addr_t\t\t dataDma;\n\tu32\t\t\t flagsLength;\n\tint\t\t\t ii;\n\n\t \n\tif ((mf = mpt_get_msg_frame(ioc->DoneCtx, ioc)) == NULL) {\n\t\tdfailprintk(ioc, printk(MYIOC_s_WARN_FMT\n\t\t\t\t\"writeIOCPage4 : no msg frames!\\n\",ioc->name));\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tpReq = (Config_t *)mf;\n\n\t \n\tpReq->Action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;\n\tpReq->Reserved = 0;\n\tpReq->ChainOffset = 0;\n\tpReq->Function = MPI_FUNCTION_CONFIG;\n\tpReq->ExtPageLength = 0;\n\tpReq->ExtPageType = 0;\n\tpReq->MsgFlags = 0;\n\tfor (ii=0; ii < 8; ii++) {\n\t\tpReq->Reserved2[ii] = 0;\n\t}\n\n\tIOCPage4Ptr = ioc->spi_data.pIocPg4;\n\tdataDma = ioc->spi_data.IocPg4_dma;\n\tii = IOCPage4Ptr->ActiveSEP++;\n\tIOCPage4Ptr->SEP[ii].SEPTargetID = id;\n\tIOCPage4Ptr->SEP[ii].SEPBus = channel;\n\tpReq->Header = IOCPage4Ptr->Header;\n\tpReq->PageAddress = cpu_to_le32(id | (channel << 8 ));\n\n\t \n\tflagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE |\n\t\t(IOCPage4Ptr->Header.PageLength + ii) * 4;\n\n\tioc->add_sge((char *)&pReq->PageBufferSGE, flagsLength, dataDma);\n\n\tddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"writeIOCPage4: MaxSEP=%d ActiveSEP=%d id=%d bus=%d\\n\",\n\t\tioc->name, IOCPage4Ptr->MaxSEP, IOCPage4Ptr->ActiveSEP, id, channel));\n\n\tmpt_put_msg_frame(ioc->DoneCtx, ioc, mf);\n\n\treturn 0;\n}\n\n \nstatic void\nmptspi_initTarget(MPT_SCSI_HOST *hd, VirtTarget *vtarget,\n\t\t    struct scsi_device *sdev)\n{\n\n\t \n\tif (sdev->inq_periph_qual != 0)\n\t\treturn;\n\n\tif (vtarget == NULL)\n\t\treturn;\n\n\tvtarget->type = sdev->type;\n\n\tif ((sdev->type == TYPE_PROCESSOR) && (hd->ioc->spi_data.Saf_Te)) {\n\t\t \n\t\tvtarget->tflags |= MPT_TARGET_FLAGS_SAF_TE_ISSUED;\n\t\tmptspi_writeIOCPage4(hd, vtarget->channel, vtarget->id);\n\t}else if ((sdev->type == TYPE_PROCESSOR) &&\n\t\t!(vtarget->tflags & MPT_TARGET_FLAGS_SAF_TE_ISSUED )) {\n\t\tif (sdev->inquiry_len > 49 ) {\n\t\t\tif (sdev->inquiry[44] == 'S' &&\n\t\t\t    sdev->inquiry[45] == 'A' &&\n\t\t\t    sdev->inquiry[46] == 'F' &&\n\t\t\t    sdev->inquiry[47] == '-' &&\n\t\t\t    sdev->inquiry[48] == 'T' &&\n\t\t\t    sdev->inquiry[49] == 'E' ) {\n\t\t\t\tvtarget->tflags |= MPT_TARGET_FLAGS_SAF_TE_ISSUED;\n\t\t\t\tmptspi_writeIOCPage4(hd, vtarget->channel, vtarget->id);\n\t\t\t}\n\t\t}\n\t}\n\tmptspi_setTargetNegoParms(hd, vtarget, sdev);\n}\n\n \nstatic int\nmptspi_is_raid(struct _MPT_SCSI_HOST *hd, u32 id)\n{\n\tint i, rc = 0;\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\tif (!ioc->raid_data.pIocPg2)\n\t\tgoto out;\n\n\tif (!ioc->raid_data.pIocPg2->NumActiveVolumes)\n\t\tgoto out;\n\tfor (i=0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {\n\t\tif (ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID == id) {\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\treturn rc;\n}\n\nstatic int mptspi_target_alloc(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tstruct _MPT_SCSI_HOST *hd = shost_priv(shost);\n\tVirtTarget\t\t*vtarget;\n\tMPT_ADAPTER *ioc;\n\n\tif (hd == NULL)\n\t\treturn -ENODEV;\n\n\tioc = hd->ioc;\n\tvtarget = kzalloc(sizeof(VirtTarget), GFP_KERNEL);\n\tif (!vtarget)\n\t\treturn -ENOMEM;\n\n\tvtarget->ioc_id = ioc->id;\n\tvtarget->tflags = MPT_TARGET_FLAGS_Q_YES;\n\tvtarget->id = (u8)starget->id;\n\tvtarget->channel = (u8)starget->channel;\n\tvtarget->starget = starget;\n\tstarget->hostdata = vtarget;\n\n\tif (starget->channel == 1) {\n\t\tif (mptscsih_is_phys_disk(ioc, 0, starget->id) == 0)\n\t\t\treturn 0;\n\t\tvtarget->tflags |= MPT_TARGET_FLAGS_RAID_COMPONENT;\n\t\t \n\t\tvtarget->channel = 0;\n\t\t \n\t\tvtarget->id = mptscsih_raid_id_to_num(ioc, 0,\n\t\t    starget->id);\n\t}\n\n\tif (starget->channel == 0 &&\n\t    mptspi_is_raid(hd, starget->id)) {\n\t\tvtarget->raidVolume = 1;\n\t\tddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t    \"RAID Volume @ channel=%d id=%d\\n\", ioc->name, starget->channel,\n\t\t    starget->id));\n\t}\n\n\tif (ioc->spi_data.nvram &&\n\t    ioc->spi_data.nvram[starget->id] != MPT_HOST_NVRAM_INVALID) {\n\t\tu32 nvram = ioc->spi_data.nvram[starget->id];\n\t\tspi_min_period(starget) = (nvram & MPT_NVRAM_SYNC_MASK) >> MPT_NVRAM_SYNC_SHIFT;\n\t\tspi_max_width(starget) = nvram & MPT_NVRAM_WIDE_DISABLE ? 0 : 1;\n\t} else {\n\t\tspi_min_period(starget) = ioc->spi_data.minSyncFactor;\n\t\tspi_max_width(starget) = ioc->spi_data.maxBusWidth;\n\t}\n\tspi_max_offset(starget) = ioc->spi_data.maxSyncOffset;\n\n\tspi_offset(starget) = 0;\n\tspi_period(starget) = 0xFF;\n\tmptspi_write_width(starget, 0);\n\n\treturn 0;\n}\n\nstatic void\nmptspi_target_destroy(struct scsi_target *starget)\n{\n\tkfree(starget->hostdata);\n\tstarget->hostdata = NULL;\n}\n\n \nstatic void\nmptspi_print_write_nego(struct _MPT_SCSI_HOST *hd, struct scsi_target *starget, u32 ii)\n{\n\tddvprintk(hd->ioc, printk(MYIOC_s_DEBUG_FMT \"id=%d Requested = 0x%08x\"\n\t    \" ( %s factor = 0x%02x @ offset = 0x%02x %s%s%s%s%s%s%s%s)\\n\",\n\t    hd->ioc->name, starget->id, ii,\n\t    ii & MPI_SCSIDEVPAGE0_NP_WIDE ? \"Wide \": \"\",\n\t    ((ii >> 8) & 0xFF), ((ii >> 16) & 0xFF),\n\t    ii & MPI_SCSIDEVPAGE0_NP_IU ? \"IU \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_DT ? \"DT \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_QAS ? \"QAS \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_HOLD_MCS ? \"HOLDMCS \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_WR_FLOW ? \"WRFLOW \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_RD_STRM ? \"RDSTRM \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_RTI ? \"RTI \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_PCOMP_EN ? \"PCOMP \": \"\"));\n}\n\n \nstatic void\nmptspi_print_read_nego(struct _MPT_SCSI_HOST *hd, struct scsi_target *starget, u32 ii)\n{\n\tddvprintk(hd->ioc, printk(MYIOC_s_DEBUG_FMT \"id=%d Read = 0x%08x\"\n\t    \" ( %s factor = 0x%02x @ offset = 0x%02x %s%s%s%s%s%s%s%s)\\n\",\n\t    hd->ioc->name, starget->id, ii,\n\t    ii & MPI_SCSIDEVPAGE0_NP_WIDE ? \"Wide \": \"\",\n\t    ((ii >> 8) & 0xFF), ((ii >> 16) & 0xFF),\n\t    ii & MPI_SCSIDEVPAGE0_NP_IU ? \"IU \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_DT ? \"DT \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_QAS ? \"QAS \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_HOLD_MCS ? \"HOLDMCS \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_WR_FLOW ? \"WRFLOW \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_RD_STRM ? \"RDSTRM \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_RTI ? \"RTI \": \"\",\n\t    ii & MPI_SCSIDEVPAGE0_NP_PCOMP_EN ? \"PCOMP \": \"\"));\n}\n\nstatic int mptspi_read_spi_device_pg0(struct scsi_target *starget,\n\t\t\t     struct _CONFIG_PAGE_SCSI_DEVICE_0 *pass_pg0)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tstruct _MPT_SCSI_HOST *hd = shost_priv(shost);\n\tstruct _MPT_ADAPTER *ioc = hd->ioc;\n\tstruct _CONFIG_PAGE_SCSI_DEVICE_0 *spi_dev_pg0;\n\tdma_addr_t spi_dev_pg0_dma;\n\tint size;\n\tstruct _x_config_parms cfg;\n\tstruct _CONFIG_PAGE_HEADER hdr;\n\tint err = -EBUSY;\n\n\t \n\tif (starget->channel == 0 &&\n\t    mptspi_is_raid(hd, starget->id))\n\t\treturn -1;\n\n\tsize = ioc->spi_data.sdp0length * 4;\n\t \n\n\tspi_dev_pg0 = dma_alloc_coherent(&ioc->pcidev->dev, size, &spi_dev_pg0_dma, GFP_KERNEL);\n\tif (spi_dev_pg0 == NULL) {\n\t\tstarget_printk(KERN_ERR, starget, MYIOC_s_FMT\n\t\t    \"dma_alloc_coherent for parameters failed\\n\", ioc->name);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&hdr, 0, sizeof(hdr));\n\n\thdr.PageVersion = ioc->spi_data.sdp0version;\n\thdr.PageLength = ioc->spi_data.sdp0length;\n\thdr.PageNumber = 0;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = spi_dev_pg0_dma;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\n\tcfg.dir = 0;\n\tcfg.pageAddr = starget->id;\n\tcfg.timeout = 60;\n\n\tif (mpt_config(ioc, &cfg)) {\n\t\tstarget_printk(KERN_ERR, starget, MYIOC_s_FMT \"mpt_config failed\\n\", ioc->name);\n\t\tgoto out_free;\n\t}\n\terr = 0;\n\tmemcpy(pass_pg0, spi_dev_pg0, size);\n\n\tmptspi_print_read_nego(hd, starget, le32_to_cpu(spi_dev_pg0->NegotiatedParameters));\n\n out_free:\n\tdma_free_coherent(&ioc->pcidev->dev, size, spi_dev_pg0, spi_dev_pg0_dma);\n\treturn err;\n}\n\nstatic u32 mptspi_getRP(struct scsi_target *starget)\n{\n\tu32 nego = 0;\n\n\tnego |= spi_iu(starget) ? MPI_SCSIDEVPAGE1_RP_IU : 0;\n\tnego |= spi_dt(starget) ? MPI_SCSIDEVPAGE1_RP_DT : 0;\n\tnego |= spi_qas(starget) ? MPI_SCSIDEVPAGE1_RP_QAS : 0;\n\tnego |= spi_hold_mcs(starget) ? MPI_SCSIDEVPAGE1_RP_HOLD_MCS : 0;\n\tnego |= spi_wr_flow(starget) ? MPI_SCSIDEVPAGE1_RP_WR_FLOW : 0;\n\tnego |= spi_rd_strm(starget) ? MPI_SCSIDEVPAGE1_RP_RD_STRM : 0;\n\tnego |= spi_rti(starget) ? MPI_SCSIDEVPAGE1_RP_RTI : 0;\n\tnego |= spi_pcomp_en(starget) ? MPI_SCSIDEVPAGE1_RP_PCOMP_EN : 0;\n\n\tnego |= (spi_period(starget) <<  MPI_SCSIDEVPAGE1_RP_SHIFT_MIN_SYNC_PERIOD) & MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK;\n\tnego |= (spi_offset(starget) << MPI_SCSIDEVPAGE1_RP_SHIFT_MAX_SYNC_OFFSET) & MPI_SCSIDEVPAGE1_RP_MAX_SYNC_OFFSET_MASK;\n\tnego |= spi_width(starget) ?  MPI_SCSIDEVPAGE1_RP_WIDE : 0;\n\n\treturn nego;\n}\n\nstatic void mptspi_read_parameters(struct scsi_target *starget)\n{\n\tint nego;\n\tstruct _CONFIG_PAGE_SCSI_DEVICE_0 spi_dev_pg0;\n\n\tmptspi_read_spi_device_pg0(starget, &spi_dev_pg0);\n\n\tnego = le32_to_cpu(spi_dev_pg0.NegotiatedParameters);\n\n\tspi_iu(starget) = (nego & MPI_SCSIDEVPAGE0_NP_IU) ? 1 : 0;\n\tspi_dt(starget) = (nego & MPI_SCSIDEVPAGE0_NP_DT) ? 1 : 0;\n\tspi_qas(starget) = (nego & MPI_SCSIDEVPAGE0_NP_QAS) ? 1 : 0;\n\tspi_wr_flow(starget) = (nego & MPI_SCSIDEVPAGE0_NP_WR_FLOW) ? 1 : 0;\n\tspi_rd_strm(starget) = (nego & MPI_SCSIDEVPAGE0_NP_RD_STRM) ? 1 : 0;\n\tspi_rti(starget) = (nego & MPI_SCSIDEVPAGE0_NP_RTI) ? 1 : 0;\n\tspi_pcomp_en(starget) = (nego & MPI_SCSIDEVPAGE0_NP_PCOMP_EN) ? 1 : 0;\n\tspi_hold_mcs(starget) = (nego & MPI_SCSIDEVPAGE0_NP_HOLD_MCS) ? 1 : 0;\n\tspi_period(starget) = (nego & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK) >> MPI_SCSIDEVPAGE0_NP_SHIFT_SYNC_PERIOD;\n\tspi_offset(starget) = (nego & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK) >> MPI_SCSIDEVPAGE0_NP_SHIFT_SYNC_OFFSET;\n\tspi_width(starget) = (nego & MPI_SCSIDEVPAGE0_NP_WIDE) ? 1 : 0;\n}\n\nstatic int\nmptscsih_quiesce_raid(MPT_SCSI_HOST *hd, int quiesce, u8 channel, u8 id)\n{\n\tMPT_ADAPTER\t*ioc = hd->ioc;\n\tMpiRaidActionRequest_t\t*pReq;\n\tMPT_FRAME_HDR\t\t*mf;\n\tint\t\t\tret;\n\tunsigned long \t \ttimeleft;\n\n\tmutex_lock(&ioc->internal_cmds.mutex);\n\n\t \n\tif ((mf = mpt_get_msg_frame(ioc->InternalCtx, ioc)) == NULL) {\n\t\tdfailprintk(hd->ioc, printk(MYIOC_s_WARN_FMT\n\t\t\t\"%s: no msg frames!\\n\", ioc->name, __func__));\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\tpReq = (MpiRaidActionRequest_t *)mf;\n\tif (quiesce)\n\t\tpReq->Action = MPI_RAID_ACTION_QUIESCE_PHYS_IO;\n\telse\n\t\tpReq->Action = MPI_RAID_ACTION_ENABLE_PHYS_IO;\n\tpReq->Reserved1 = 0;\n\tpReq->ChainOffset = 0;\n\tpReq->Function = MPI_FUNCTION_RAID_ACTION;\n\tpReq->VolumeID = id;\n\tpReq->VolumeBus = channel;\n\tpReq->PhysDiskNum = 0;\n\tpReq->MsgFlags = 0;\n\tpReq->Reserved2 = 0;\n\tpReq->ActionDataWord = 0;  \n\n\tioc->add_sge((char *)&pReq->ActionDataSGE,\n\t\tMPT_SGE_FLAGS_SSIMPLE_READ | 0, (dma_addr_t) -1);\n\n\tddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"RAID Volume action=%x channel=%d id=%d\\n\",\n\t\t\tioc->name, pReq->Action, channel, id));\n\n\tINITIALIZE_MGMT_STATUS(ioc->internal_cmds.status)\n\tmpt_put_msg_frame(ioc->InternalCtx, ioc, mf);\n\ttimeleft = wait_for_completion_timeout(&ioc->internal_cmds.done, 10*HZ);\n\tif (!(ioc->internal_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\n\t\tret = -ETIME;\n\t\tdfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"%s: TIMED OUT!\\n\",\n\t\t    ioc->name, __func__));\n\t\tif (ioc->internal_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\n\t\t\tgoto out;\n\t\tif (!timeleft) {\n\t\t\tprintk(MYIOC_s_WARN_FMT \"Issuing Reset from %s!!\\n\",\n\t\t\t    ioc->name, __func__);\n\t\t\tmpt_HardResetHandler(ioc, CAN_SLEEP);\n\t\t\tmpt_free_msg_frame(ioc, mf);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tret = ioc->internal_cmds.completion_code;\n\n out:\n\tCLEAR_MGMT_STATUS(ioc->internal_cmds.status)\n\tmutex_unlock(&ioc->internal_cmds.mutex);\n\treturn ret;\n}\n\nstatic void mptspi_dv_device(struct _MPT_SCSI_HOST *hd,\n\t\t\t     struct scsi_device *sdev)\n{\n\tVirtTarget *vtarget = scsi_target(sdev)->hostdata;\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\t \n\tif (sdev->channel == 0 &&\n\t    mptspi_is_raid(hd, sdev->id))\n\t\treturn;\n\n\t \n\tif (sdev->channel == 1 &&\n\t    mptscsih_quiesce_raid(hd, 1, vtarget->channel, vtarget->id) < 0) {\n\t\tstarget_printk(KERN_ERR, scsi_target(sdev), MYIOC_s_FMT\n\t\t    \"Integrated RAID quiesce failed\\n\", ioc->name);\n\t\treturn;\n\t}\n\n\thd->spi_pending |= (1 << sdev->id);\n\tspi_dv_device(sdev);\n\thd->spi_pending &= ~(1 << sdev->id);\n\n\tif (sdev->channel == 1 &&\n\t    mptscsih_quiesce_raid(hd, 0, vtarget->channel, vtarget->id) < 0)\n\t\tstarget_printk(KERN_ERR, scsi_target(sdev), MYIOC_s_FMT\n\t\t    \"Integrated RAID resume failed\\n\", ioc->name);\n\n\tmptspi_read_parameters(sdev->sdev_target);\n\tspi_display_xfer_agreement(sdev->sdev_target);\n\tmptspi_read_parameters(sdev->sdev_target);\n}\n\nstatic int mptspi_slave_alloc(struct scsi_device *sdev)\n{\n\tMPT_SCSI_HOST *hd = shost_priv(sdev->host);\n\tVirtTarget\t\t*vtarget;\n\tVirtDevice\t\t*vdevice;\n\tstruct scsi_target \t*starget;\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\tif (sdev->channel == 1 &&\n\t\tmptscsih_is_phys_disk(ioc, 0, sdev->id) == 0)\n\t\t\treturn -ENXIO;\n\n\tvdevice = kzalloc(sizeof(VirtDevice), GFP_KERNEL);\n\tif (!vdevice) {\n\t\tprintk(MYIOC_s_ERR_FMT \"slave_alloc kmalloc(%zd) FAILED!\\n\",\n\t\t\t\tioc->name, sizeof(VirtDevice));\n\t\treturn -ENOMEM;\n\t}\n\n\tvdevice->lun = sdev->lun;\n\tsdev->hostdata = vdevice;\n\n\tstarget = scsi_target(sdev);\n\tvtarget = starget->hostdata;\n\tvdevice->vtarget = vtarget;\n\tvtarget->num_luns++;\n\n\tif (sdev->channel == 1)\n\t\tsdev->no_uld_attach = 1;\n\n\treturn 0;\n}\n\nstatic int mptspi_slave_configure(struct scsi_device *sdev)\n{\n\tstruct _MPT_SCSI_HOST *hd = shost_priv(sdev->host);\n\tVirtTarget *vtarget = scsi_target(sdev)->hostdata;\n\tint ret;\n\n\tmptspi_initTarget(hd, vtarget, sdev);\n\n\tret = mptscsih_slave_configure(sdev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tddvprintk(hd->ioc, printk(MYIOC_s_DEBUG_FMT \"id=%d min_period=0x%02x\"\n\t\t\" max_offset=0x%02x max_width=%d\\n\", hd->ioc->name,\n\t\tsdev->id, spi_min_period(scsi_target(sdev)),\n\t\tspi_max_offset(scsi_target(sdev)),\n\t\tspi_max_width(scsi_target(sdev))));\n\n\tif ((sdev->channel == 1 ||\n\t     !(mptspi_is_raid(hd, sdev->id))) &&\n\t    !spi_initial_dv(sdev->sdev_target))\n\t\tmptspi_dv_device(hd, sdev);\n\n\treturn 0;\n}\n\nstatic int\nmptspi_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *SCpnt)\n{\n\tstruct _MPT_SCSI_HOST *hd = shost_priv(shost);\n\tVirtDevice\t*vdevice = SCpnt->device->hostdata;\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\tif (!vdevice || !vdevice->vtarget) {\n\t\tSCpnt->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(SCpnt);\n\t\treturn 0;\n\t}\n\n\tif (SCpnt->device->channel == 1 &&\n\t\tmptscsih_is_phys_disk(ioc, 0, SCpnt->device->id) == 0) {\n\t\tSCpnt->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(SCpnt);\n\t\treturn 0;\n\t}\n\n\tif (spi_dv_pending(scsi_target(SCpnt->device)))\n\t\tddvprintk(ioc, scsi_print_command(SCpnt));\n\n\treturn mptscsih_qcmd(SCpnt);\n}\n\nstatic void mptspi_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct scsi_target *starget = scsi_target(sdev);\n\tVirtTarget *vtarget = starget->hostdata;\n\tVirtDevice *vdevice = sdev->hostdata;\n\n\t \n\tif (vtarget->num_luns == 1 && vdevice->configured_lun) {\n\t\tstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\n\n\t\t \n\t\tpg1.RequestedParameters = 0;\n\t\tpg1.Reserved = 0;\n\t\tpg1.Configuration = 0;\n\n\t\tmptspi_write_spi_device_pg1(starget, &pg1);\n\t}\n\n\tmptscsih_slave_destroy(sdev);\n}\n\nstatic const struct scsi_host_template mptspi_driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.proc_name\t\t\t= \"mptspi\",\n\t.show_info\t\t\t= mptscsih_show_info,\n\t.name\t\t\t\t= \"MPT SPI Host\",\n\t.info\t\t\t\t= mptscsih_info,\n\t.queuecommand\t\t\t= mptspi_qcmd,\n\t.target_alloc\t\t\t= mptspi_target_alloc,\n\t.slave_alloc\t\t\t= mptspi_slave_alloc,\n\t.slave_configure\t\t= mptspi_slave_configure,\n\t.target_destroy\t\t\t= mptspi_target_destroy,\n\t.slave_destroy\t\t\t= mptspi_slave_destroy,\n\t.change_queue_depth \t\t= mptscsih_change_queue_depth,\n\t.eh_abort_handler\t\t= mptscsih_abort,\n\t.eh_device_reset_handler\t= mptscsih_dev_reset,\n\t.eh_bus_reset_handler\t\t= mptscsih_bus_reset,\n\t.eh_host_reset_handler\t\t= mptscsih_host_reset,\n\t.bios_param\t\t\t= mptscsih_bios_param,\n\t.can_queue\t\t\t= MPT_SCSI_CAN_QUEUE,\n\t.this_id\t\t\t= -1,\n\t.sg_tablesize\t\t\t= MPT_SCSI_SG_DEPTH,\n\t.max_sectors\t\t\t= 8192,\n\t.cmd_per_lun\t\t\t= 7,\n\t.shost_groups\t\t\t= mptscsih_host_attr_groups,\n};\n\nstatic int mptspi_write_spi_device_pg1(struct scsi_target *starget,\n\t\t\t       struct _CONFIG_PAGE_SCSI_DEVICE_1 *pass_pg1)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tstruct _MPT_SCSI_HOST *hd = shost_priv(shost);\n\tstruct _MPT_ADAPTER *ioc = hd->ioc;\n\tstruct _CONFIG_PAGE_SCSI_DEVICE_1 *pg1;\n\tdma_addr_t pg1_dma;\n\tint size;\n\tstruct _x_config_parms cfg;\n\tstruct _CONFIG_PAGE_HEADER hdr;\n\tint err = -EBUSY;\n\tu32 nego_parms;\n\tu32 period;\n\tstruct scsi_device *sdev;\n\tint i;\n\n\t \n\tif (starget->channel == 0 &&\n\t    mptspi_is_raid(hd, starget->id))\n\t\treturn -1;\n\n\tsize = ioc->spi_data.sdp1length * 4;\n\n\tpg1 = dma_alloc_coherent(&ioc->pcidev->dev, size, &pg1_dma, GFP_KERNEL);\n\tif (pg1 == NULL) {\n\t\tstarget_printk(KERN_ERR, starget, MYIOC_s_FMT\n\t\t    \"dma_alloc_coherent for parameters failed\\n\", ioc->name);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&hdr, 0, sizeof(hdr));\n\n\thdr.PageVersion = ioc->spi_data.sdp1version;\n\thdr.PageLength = ioc->spi_data.sdp1length;\n\thdr.PageNumber = 1;\n\thdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\n\tcfg.cfghdr.hdr = &hdr;\n\tcfg.physAddr = pg1_dma;\n\tcfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;\n\tcfg.dir = 1;\n\tcfg.pageAddr = starget->id;\n\n\tmemcpy(pg1, pass_pg1, size);\n\n\tpg1->Header.PageVersion = hdr.PageVersion;\n\tpg1->Header.PageLength = hdr.PageLength;\n\tpg1->Header.PageNumber = hdr.PageNumber;\n\tpg1->Header.PageType = hdr.PageType;\n\n\tnego_parms = le32_to_cpu(pg1->RequestedParameters);\n\tperiod = (nego_parms & MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK) >>\n\t\tMPI_SCSIDEVPAGE1_RP_SHIFT_MIN_SYNC_PERIOD;\n\tif (period == 8) {\n\t\t \n\t\tfor (i = 0 ; i < 16; i++) {\n\t\t\tsdev = scsi_device_lookup_by_target(starget, i);\n\t\t\tif (sdev && sdev->type == TYPE_TAPE) {\n\t\t\t\tsdev_printk(KERN_DEBUG, sdev, MYIOC_s_FMT\n\t\t\t\t\t    \"IDP:ON\\n\", ioc->name);\n\t\t\t\tnego_parms |= MPI_SCSIDEVPAGE1_RP_IDP;\n\t\t\t\tpg1->RequestedParameters =\n\t\t\t\t    cpu_to_le32(nego_parms);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmptspi_print_write_nego(hd, starget, le32_to_cpu(pg1->RequestedParameters));\n\n\tif (mpt_config(ioc, &cfg)) {\n\t\tstarget_printk(KERN_ERR, starget, MYIOC_s_FMT\n\t\t    \"mpt_config failed\\n\", ioc->name);\n\t\tgoto out_free;\n\t}\n\terr = 0;\n\n out_free:\n\tdma_free_coherent(&ioc->pcidev->dev, size, pg1, pg1_dma);\n\treturn err;\n}\n\nstatic void mptspi_write_offset(struct scsi_target *starget, int offset)\n{\n\tstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\n\tu32 nego;\n\n\tif (offset < 0)\n\t\toffset = 0;\n\n\tif (offset > 255)\n\t\toffset = 255;\n\n\tif (spi_offset(starget) == -1)\n\t\tmptspi_read_parameters(starget);\n\n\tspi_offset(starget) = offset;\n\n\tnego = mptspi_getRP(starget);\n\n\tpg1.RequestedParameters = cpu_to_le32(nego);\n\tpg1.Reserved = 0;\n\tpg1.Configuration = 0;\n\n\tmptspi_write_spi_device_pg1(starget, &pg1);\n}\n\nstatic void mptspi_write_period(struct scsi_target *starget, int period)\n{\n\tstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\n\tu32 nego;\n\n\tif (period < 8)\n\t\tperiod = 8;\n\n\tif (period > 255)\n\t\tperiod = 255;\n\n\tif (spi_period(starget) == -1)\n\t\tmptspi_read_parameters(starget);\n\n\tif (period == 8) {\n\t\tspi_iu(starget) = 1;\n\t\tspi_dt(starget) = 1;\n\t} else if (period == 9) {\n\t\tspi_dt(starget) = 1;\n\t}\n\n\tspi_period(starget) = period;\n\n\tnego = mptspi_getRP(starget);\n\n\tpg1.RequestedParameters = cpu_to_le32(nego);\n\tpg1.Reserved = 0;\n\tpg1.Configuration = 0;\n\n\tmptspi_write_spi_device_pg1(starget, &pg1);\n}\n\nstatic void mptspi_write_dt(struct scsi_target *starget, int dt)\n{\n\tstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\n\tu32 nego;\n\n\tif (spi_period(starget) == -1)\n\t\tmptspi_read_parameters(starget);\n\n\tif (!dt && spi_period(starget) < 10)\n\t\tspi_period(starget) = 10;\n\n\tspi_dt(starget) = dt;\n\n\tnego = mptspi_getRP(starget);\n\n\n\tpg1.RequestedParameters = cpu_to_le32(nego);\n\tpg1.Reserved = 0;\n\tpg1.Configuration = 0;\n\n\tmptspi_write_spi_device_pg1(starget, &pg1);\n}\n\nstatic void mptspi_write_iu(struct scsi_target *starget, int iu)\n{\n\tstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\n\tu32 nego;\n\n\tif (spi_period(starget) == -1)\n\t\tmptspi_read_parameters(starget);\n\n\tif (!iu && spi_period(starget) < 9)\n\t\tspi_period(starget) = 9;\n\n\tspi_iu(starget) = iu;\n\n\tnego = mptspi_getRP(starget);\n\n\tpg1.RequestedParameters = cpu_to_le32(nego);\n\tpg1.Reserved = 0;\n\tpg1.Configuration = 0;\n\n\tmptspi_write_spi_device_pg1(starget, &pg1);\n}\n\n#define MPTSPI_SIMPLE_TRANSPORT_PARM(parm) \t\t\t\t\\\nstatic void mptspi_write_##parm(struct scsi_target *starget, int parm)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\t\t\t\t\\\n\tu32 nego;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tspi_##parm(starget) = parm;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tnego = mptspi_getRP(starget);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tpg1.RequestedParameters = cpu_to_le32(nego);\t\t\t\\\n\tpg1.Reserved = 0;\t\t\t\t\t\t\\\n\tpg1.Configuration = 0;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmptspi_write_spi_device_pg1(starget, &pg1);\t\t\t\t\\\n}\n\nMPTSPI_SIMPLE_TRANSPORT_PARM(rd_strm)\nMPTSPI_SIMPLE_TRANSPORT_PARM(wr_flow)\nMPTSPI_SIMPLE_TRANSPORT_PARM(rti)\nMPTSPI_SIMPLE_TRANSPORT_PARM(hold_mcs)\nMPTSPI_SIMPLE_TRANSPORT_PARM(pcomp_en)\n\nstatic void mptspi_write_qas(struct scsi_target *starget, int qas)\n{\n\tstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tstruct _MPT_SCSI_HOST *hd = shost_priv(shost);\n\tVirtTarget *vtarget = starget->hostdata;\n\tu32 nego;\n\n\tif ((vtarget->negoFlags & MPT_TARGET_NO_NEGO_QAS) ||\n\t    hd->ioc->spi_data.noQas)\n\t\tspi_qas(starget) = 0;\n\telse\n\t\tspi_qas(starget) = qas;\n\n\tnego = mptspi_getRP(starget);\n\n\tpg1.RequestedParameters = cpu_to_le32(nego);\n\tpg1.Reserved = 0;\n\tpg1.Configuration = 0;\n\n\tmptspi_write_spi_device_pg1(starget, &pg1);\n}\n\nstatic void mptspi_write_width(struct scsi_target *starget, int width)\n{\n\tstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\n\tu32 nego;\n\n\tif (!width) {\n\t\tspi_dt(starget) = 0;\n\t\tif (spi_period(starget) < 10)\n\t\t\tspi_period(starget) = 10;\n\t}\n\n\tspi_width(starget) = width;\n\n\tnego = mptspi_getRP(starget);\n\n\tpg1.RequestedParameters = cpu_to_le32(nego);\n\tpg1.Reserved = 0;\n\tpg1.Configuration = 0;\n\n\tmptspi_write_spi_device_pg1(starget, &pg1);\n}\n\nstruct work_queue_wrapper {\n\tstruct work_struct\twork;\n\tstruct _MPT_SCSI_HOST\t*hd;\n\tint\t\t\tdisk;\n};\n\nstatic void mpt_work_wrapper(struct work_struct *work)\n{\n\tstruct work_queue_wrapper *wqw =\n\t\tcontainer_of(work, struct work_queue_wrapper, work);\n\tstruct _MPT_SCSI_HOST *hd = wqw->hd;\n\tMPT_ADAPTER *ioc = hd->ioc;\n\tstruct Scsi_Host *shost = ioc->sh;\n\tstruct scsi_device *sdev;\n\tint disk = wqw->disk;\n\tstruct _CONFIG_PAGE_IOC_3 *pg3;\n\n\tkfree(wqw);\n\n\tmpt_findImVolumes(ioc);\n\tpg3 = ioc->raid_data.pIocPg3;\n\tif (!pg3)\n\t\treturn;\n\n\tshost_for_each_device(sdev,shost) {\n\t\tstruct scsi_target *starget = scsi_target(sdev);\n\t\tVirtTarget *vtarget = starget->hostdata;\n\n\t\t \n\t\tif (sdev->channel != 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tif(vtarget->id != disk)\n\t\t\tcontinue;\n\n\t\tstarget_printk(KERN_INFO, vtarget->starget, MYIOC_s_FMT\n\t\t    \"Integrated RAID requests DV of new device\\n\", ioc->name);\n\t\tmptspi_dv_device(hd, sdev);\n\t}\n\tshost_printk(KERN_INFO, shost, MYIOC_s_FMT\n\t    \"Integrated RAID detects new device %d\\n\", ioc->name, disk);\n\tscsi_scan_target(&ioc->sh->shost_gendev, 1, disk, 0, SCSI_SCAN_RESCAN);\n}\n\n\nstatic void mpt_dv_raid(struct _MPT_SCSI_HOST *hd, int disk)\n{\n\tstruct work_queue_wrapper *wqw = kmalloc(sizeof(*wqw), GFP_ATOMIC);\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\tif (!wqw) {\n\t\tshost_printk(KERN_ERR, ioc->sh, MYIOC_s_FMT\n\t\t    \"Failed to act on RAID event for physical disk %d\\n\",\n\t\t    ioc->name, disk);\n\t\treturn;\n\t}\n\tINIT_WORK(&wqw->work, mpt_work_wrapper);\n\twqw->hd = hd;\n\twqw->disk = disk;\n\n\tschedule_work(&wqw->work);\n}\n\nstatic int\nmptspi_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)\n{\n\tu8 event = le32_to_cpu(pEvReply->Event) & 0xFF;\n\tstruct _MPT_SCSI_HOST *hd = shost_priv(ioc->sh);\n\n\tif (ioc->bus_type != SPI)\n\t\treturn 0;\n\n\tif (hd && event ==  MPI_EVENT_INTEGRATED_RAID) {\n\t\tint reason\n\t\t\t= (le32_to_cpu(pEvReply->Data[0]) & 0x00FF0000) >> 16;\n\n\t\tif (reason == MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED) {\n\t\t\tint disk = (le32_to_cpu(pEvReply->Data[0]) & 0xFF000000) >> 24;\n\t\t\tmpt_dv_raid(hd, disk);\n\t\t}\n\t}\n\treturn mptscsih_event_process(ioc, pEvReply);\n}\n\nstatic int\nmptspi_deny_binding(struct scsi_target *starget)\n{\n\tstruct _MPT_SCSI_HOST *hd =\n\t\t(struct _MPT_SCSI_HOST *)dev_to_shost(starget->dev.parent)->hostdata;\n\treturn ((mptspi_is_raid(hd, starget->id)) &&\n\t\tstarget->channel == 0) ? 1 : 0;\n}\n\nstatic struct spi_function_template mptspi_transport_functions = {\n\t.get_offset\t= mptspi_read_parameters,\n\t.set_offset\t= mptspi_write_offset,\n\t.show_offset\t= 1,\n\t.get_period\t= mptspi_read_parameters,\n\t.set_period\t= mptspi_write_period,\n\t.show_period\t= 1,\n\t.get_width\t= mptspi_read_parameters,\n\t.set_width\t= mptspi_write_width,\n\t.show_width\t= 1,\n\t.get_iu\t\t= mptspi_read_parameters,\n\t.set_iu\t\t= mptspi_write_iu,\n\t.show_iu\t= 1,\n\t.get_dt\t\t= mptspi_read_parameters,\n\t.set_dt\t\t= mptspi_write_dt,\n\t.show_dt\t= 1,\n\t.get_qas\t= mptspi_read_parameters,\n\t.set_qas\t= mptspi_write_qas,\n\t.show_qas\t= 1,\n\t.get_wr_flow\t= mptspi_read_parameters,\n\t.set_wr_flow\t= mptspi_write_wr_flow,\n\t.show_wr_flow\t= 1,\n\t.get_rd_strm\t= mptspi_read_parameters,\n\t.set_rd_strm\t= mptspi_write_rd_strm,\n\t.show_rd_strm\t= 1,\n\t.get_rti\t= mptspi_read_parameters,\n\t.set_rti\t= mptspi_write_rti,\n\t.show_rti\t= 1,\n\t.get_pcomp_en\t= mptspi_read_parameters,\n\t.set_pcomp_en\t= mptspi_write_pcomp_en,\n\t.show_pcomp_en\t= 1,\n\t.get_hold_mcs\t= mptspi_read_parameters,\n\t.set_hold_mcs\t= mptspi_write_hold_mcs,\n\t.show_hold_mcs\t= 1,\n\t.deny_binding\t= mptspi_deny_binding,\n};\n\n \n\nstatic struct pci_device_id mptspi_pci_table[] = {\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVID_53C1030,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_ATTO, MPI_MANUFACTPAGE_DEVID_53C1030,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVID_53C1035,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{0}\t \n};\nMODULE_DEVICE_TABLE(pci, mptspi_pci_table);\n\n\n \nstatic void\nmptspi_dv_renegotiate_work(struct work_struct *work)\n{\n\tstruct work_queue_wrapper *wqw =\n\t\tcontainer_of(work, struct work_queue_wrapper, work);\n\tstruct _MPT_SCSI_HOST *hd = wqw->hd;\n\tstruct scsi_device *sdev;\n\tstruct scsi_target *starget;\n\tstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\n\tu32 nego;\n\tMPT_ADAPTER *ioc = hd->ioc;\n\n\tkfree(wqw);\n\n\tif (hd->spi_pending) {\n\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\tif  (hd->spi_pending & (1 << sdev->id))\n\t\t\t\tcontinue;\n\t\t\tstarget = scsi_target(sdev);\n\t\t\tnego = mptspi_getRP(starget);\n\t\t\tpg1.RequestedParameters = cpu_to_le32(nego);\n\t\t\tpg1.Reserved = 0;\n\t\t\tpg1.Configuration = 0;\n\t\t\tmptspi_write_spi_device_pg1(starget, &pg1);\n\t\t}\n\t} else {\n\t\tshost_for_each_device(sdev, ioc->sh)\n\t\t\tmptspi_dv_device(hd, sdev);\n\t}\n}\n\nstatic void\nmptspi_dv_renegotiate(struct _MPT_SCSI_HOST *hd)\n{\n\tstruct work_queue_wrapper *wqw = kmalloc(sizeof(*wqw), GFP_ATOMIC);\n\n\tif (!wqw)\n\t\treturn;\n\n\tINIT_WORK(&wqw->work, mptspi_dv_renegotiate_work);\n\twqw->hd = hd;\n\n\tschedule_work(&wqw->work);\n}\n\n \nstatic int\nmptspi_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\n{\n\tint rc;\n\n\trc = mptscsih_ioc_reset(ioc, reset_phase);\n\tif ((ioc->bus_type != SPI) || (!rc))\n\t\treturn rc;\n\n\t \n\tif (reset_phase == MPT_IOC_POST_RESET &&\n\t    ioc->sh) {\n\t\tstruct _MPT_SCSI_HOST *hd = shost_priv(ioc->sh);\n\n\t\tmptspi_dv_renegotiate(hd);\n\t}\n\n\treturn rc;\n}\n\n#ifdef CONFIG_PM\n \nstatic int\nmptspi_resume(struct pci_dev *pdev)\n{\n\tMPT_ADAPTER \t*ioc = pci_get_drvdata(pdev);\n\tstruct _MPT_SCSI_HOST *hd = shost_priv(ioc->sh);\n\tint rc;\n\n\trc = mptscsih_resume(pdev);\n\tmptspi_dv_renegotiate(hd);\n\n\treturn rc;\n}\n#endif\n\n \n \n \nstatic int\nmptspi_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct Scsi_Host\t*sh;\n\tMPT_SCSI_HOST\t\t*hd;\n\tMPT_ADAPTER \t\t*ioc;\n\tunsigned long\t\t flags;\n\tint\t\t\t ii;\n\tint\t\t\t numSGE = 0;\n\tint\t\t\t scale;\n\tint\t\t\t ioc_cap;\n\tint\t\t\terror=0;\n\tint\t\t\tr;\n\n\tif ((r = mpt_attach(pdev,id)) != 0)\n\t\treturn r;\n\n\tioc = pci_get_drvdata(pdev);\n\tioc->DoneCtx = mptspiDoneCtx;\n\tioc->TaskCtx = mptspiTaskCtx;\n\tioc->InternalCtx = mptspiInternalCtx;\n\n\t \n\tif (ioc->last_state != MPI_IOC_STATE_OPERATIONAL) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t  \"Skipping because it's not operational!\\n\",\n\t\t  ioc->name);\n\t\terror = -ENODEV;\n\t\tgoto out_mptspi_probe;\n\t}\n\n\tif (!ioc->active) {\n\t\tprintk(MYIOC_s_WARN_FMT \"Skipping because it's disabled!\\n\",\n\t\t  ioc->name);\n\t\terror = -ENODEV;\n\t\tgoto out_mptspi_probe;\n\t}\n\n\t \n\tioc_cap = 0;\n\tfor (ii=0; ii < ioc->facts.NumberOfPorts; ii++) {\n\t\tif (ioc->pfacts[ii].ProtocolFlags &\n\t\t    MPI_PORTFACTS_PROTOCOL_INITIATOR)\n\t\t\tioc_cap ++;\n\t}\n\n\tif (!ioc_cap) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\"Skipping ioc=%p because SCSI Initiator mode is NOT enabled!\\n\",\n\t\t\tioc->name, ioc);\n\t\treturn 0;\n\t}\n\n\tsh = scsi_host_alloc(&mptspi_driver_template, sizeof(MPT_SCSI_HOST));\n\n\tif (!sh) {\n\t\tprintk(MYIOC_s_WARN_FMT\n\t\t\t\"Unable to register controller with SCSI subsystem\\n\",\n\t\t\tioc->name);\n\t\terror = -1;\n\t\tgoto out_mptspi_probe;\n        }\n\n\t \n\tif (pdev->subsystem_vendor == 0x15AD)\n\t\tsh->no_write_same = 1;\n\n\tspin_lock_irqsave(&ioc->FreeQlock, flags);\n\n\t \n\tioc->sh = sh;\n\n\tsh->io_port = 0;\n\tsh->n_io_port = 0;\n\tsh->irq = 0;\n\n\t \n\tsh->max_cmd_len = 16;\n\n\t \n\tsh->max_id = ioc->devices_per_bus;\n\n\tsh->max_lun = MPT_LAST_LUN + 1;\n\t \n\tif (ioc->ir_firmware)\n\t\tsh->max_channel = 1;\n\telse\n\t\tsh->max_channel = 0;\n\tsh->this_id = ioc->pfacts[0].PortSCSIID;\n\n\t \n\tsh->unique_id = ioc->id;\n\n\t \n\tscale = ioc->req_sz/ioc->SGE_size;\n\tif (ioc->sg_addr_size == sizeof(u64)) {\n\t\tnumSGE = (scale - 1) *\n\t\t  (ioc->facts.MaxChainDepth-1) + scale +\n\t\t  (ioc->req_sz - 60) / ioc->SGE_size;\n\t} else {\n\t\tnumSGE = 1 + (scale - 1) *\n\t\t  (ioc->facts.MaxChainDepth-1) + scale +\n\t\t  (ioc->req_sz - 64) / ioc->SGE_size;\n\t}\n\n\tif (numSGE < sh->sg_tablesize) {\n\t\t \n\t\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t  \"Resetting sg_tablesize to %d from %d\\n\",\n\t\t  ioc->name, numSGE, sh->sg_tablesize));\n\t\tsh->sg_tablesize = numSGE;\n\t}\n\n\tspin_unlock_irqrestore(&ioc->FreeQlock, flags);\n\n\thd = shost_priv(sh);\n\thd->ioc = ioc;\n\n\t \n\tioc->ScsiLookup = kcalloc(ioc->req_depth, sizeof(void *), GFP_KERNEL);\n\tif (!ioc->ScsiLookup) {\n\t\terror = -ENOMEM;\n\t\tgoto out_mptspi_probe;\n\t}\n\tspin_lock_init(&ioc->scsi_lookup_lock);\n\n\tdprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"ScsiLookup @ %p\\n\",\n\t\t ioc->name, ioc->ScsiLookup));\n\n\tioc->spi_data.Saf_Te = mpt_saf_te;\n\tddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\n\t\t\"saf_te %x\\n\",\n\t\tioc->name,\n\t\tmpt_saf_te));\n\tioc->spi_data.noQas = 0;\n\n\thd->last_queue_full = 0;\n\thd->spi_pending = 0;\n\n\t \n\tif (ioc->spi_data.sdp0length != 0)\n\t\tsh->transportt = mptspi_transport_template;\n\n\terror = scsi_add_host (sh, &ioc->pcidev->dev);\n\tif(error) {\n\t\tdprintk(ioc, printk(MYIOC_s_ERR_FMT\n\t\t  \"scsi_add_host failed\\n\", ioc->name));\n\t\tgoto out_mptspi_probe;\n\t}\n\n\t \n\tif (ioc->spi_data.bus_reset)\n\t\tmptscsih_IssueTaskMgmt(hd,\n\t\t    MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,\n\t\t    0, 0, 0, 0, 5);\n\n\tscsi_scan_host(sh);\n\treturn 0;\n\nout_mptspi_probe:\n\n\tmptscsih_remove(pdev);\n\treturn error;\n}\n\nstatic void mptspi_remove(struct pci_dev *pdev)\n{\n\tMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\n\n\tscsi_remove_host(ioc->sh);\n\tmptscsih_remove(pdev);\n}\n\nstatic struct pci_driver mptspi_driver = {\n\t.name\t\t= \"mptspi\",\n\t.id_table\t= mptspi_pci_table,\n\t.probe\t\t= mptspi_probe,\n\t.remove\t\t= mptspi_remove,\n\t.shutdown\t= mptscsih_shutdown,\n#ifdef CONFIG_PM\n\t.suspend\t= mptscsih_suspend,\n\t.resume\t\t= mptspi_resume,\n#endif\n};\n\n \n \nstatic int __init\nmptspi_init(void)\n{\n\tint error;\n\n\tshow_mptmod_ver(my_NAME, my_VERSION);\n\n\tmptspi_transport_template = spi_attach_transport(&mptspi_transport_functions);\n\tif (!mptspi_transport_template)\n\t\treturn -ENODEV;\n\n\tmptspiDoneCtx = mpt_register(mptscsih_io_done, MPTSPI_DRIVER,\n\t    \"mptscsih_io_done\");\n\tmptspiTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTSPI_DRIVER,\n\t    \"mptscsih_taskmgmt_complete\");\n\tmptspiInternalCtx = mpt_register(mptscsih_scandv_complete,\n\t    MPTSPI_DRIVER, \"mptscsih_scandv_complete\");\n\n\tmpt_event_register(mptspiDoneCtx, mptspi_event_process);\n\tmpt_reset_register(mptspiDoneCtx, mptspi_ioc_reset);\n\n\terror = pci_register_driver(&mptspi_driver);\n\tif (error)\n\t\tspi_release_transport(mptspi_transport_template);\n\n\treturn error;\n}\n\n \n \n \nstatic void __exit\nmptspi_exit(void)\n{\n\tpci_unregister_driver(&mptspi_driver);\n\n\tmpt_reset_deregister(mptspiDoneCtx);\n\tmpt_event_deregister(mptspiDoneCtx);\n\n\tmpt_deregister(mptspiInternalCtx);\n\tmpt_deregister(mptspiTaskCtx);\n\tmpt_deregister(mptspiDoneCtx);\n\tspi_release_transport(mptspi_transport_template);\n}\n\nmodule_init(mptspi_init);\nmodule_exit(mptspi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}