{
  "module_name": "mptbase.h",
  "hash_id": "d531ccd1ad339645c0289497dee97344cc26d976db348693170786fd841669c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/message/fusion/mptbase.h",
  "human_readable_source": " \n \n \n\n#ifndef MPTBASE_H_INCLUDED\n#define MPTBASE_H_INCLUDED\n \n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n\n#include \"lsi/mpi_type.h\"\n#include \"lsi/mpi.h\"\t\t \n#include \"lsi/mpi_ioc.h\"\t \n#include \"lsi/mpi_cnfg.h\"\t \n#include \"lsi/mpi_init.h\"\t \n#include \"lsi/mpi_lan.h\"\t \n#include \"lsi/mpi_raid.h\"\t \n\n#include \"lsi/mpi_fc.h\"\t\t \n#include \"lsi/mpi_targ.h\"\t \n#include \"lsi/mpi_tool.h\"\t \n#include \"lsi/mpi_sas.h\"\t \n\n \n\n#ifndef MODULEAUTHOR\n#define MODULEAUTHOR\t\"LSI Corporation\"\n#endif\n\n#ifndef COPYRIGHT\n#define COPYRIGHT\t\"Copyright (c) 1999-2008 \" MODULEAUTHOR\n#endif\n\n#define MPT_LINUX_VERSION_COMMON\t\"3.04.20\"\n#define MPT_LINUX_PACKAGE_NAME\t\t\"@(#)mptlinux-3.04.20\"\n#define WHAT_MAGIC_STRING\t\t\"@\" \"(\" \"#\" \")\"\n\n#define show_mptmod_ver(s,ver)  \\\n\tprintk(KERN_INFO \"%s %s\\n\", s, ver);\n\n \n \n#define MPT_MAX_ADAPTERS\t\t18\n#define MPT_MAX_PROTOCOL_DRIVERS\t16\n#define MPT_MAX_CALLBACKNAME_LEN\t49\n#define MPT_MAX_BUS\t\t\t1\t \n#define MPT_MAX_FC_DEVICES\t\t255\n#define MPT_MAX_SCSI_DEVICES\t\t16\n#define MPT_LAST_LUN\t\t\t255\n#define MPT_SENSE_BUFFER_ALLOC\t\t64\n\t \n#if MPT_SENSE_BUFFER_ALLOC >= 256\n#\tundef MPT_SENSE_BUFFER_ALLOC\n#\tdefine MPT_SENSE_BUFFER_ALLOC\t256\n#\tdefine MPT_SENSE_BUFFER_SIZE\t255\n#else\n#\tdefine MPT_SENSE_BUFFER_SIZE\tMPT_SENSE_BUFFER_ALLOC\n#endif\n\n#define MPT_NAME_LENGTH\t\t\t32\n#define MPT_KOBJ_NAME_LEN\t\t20\n\n#define MPT_PROCFS_MPTBASEDIR\t\t\"mpt\"\n\t\t\t\t\t\t \n#define MPT_PROCFS_SUMMARY_ALL_NODE\t\tMPT_PROCFS_MPTBASEDIR \"/summary\"\n#define MPT_PROCFS_SUMMARY_ALL_PATHNAME\t\t\"/proc/\" MPT_PROCFS_SUMMARY_ALL_NODE\n#define MPT_FW_REV_MAGIC_ID_STRING\t\t\"FwRev=\"\n\n#define  MPT_MAX_REQ_DEPTH\t\t1023\n#define  MPT_DEFAULT_REQ_DEPTH\t\t256\n#define  MPT_MIN_REQ_DEPTH\t\t128\n\n#define  MPT_MAX_REPLY_DEPTH\t\tMPT_MAX_REQ_DEPTH\n#define  MPT_DEFAULT_REPLY_DEPTH\t128\n#define  MPT_MIN_REPLY_DEPTH\t\t8\n#define  MPT_MAX_REPLIES_PER_ISR\t32\n\n#define  MPT_MAX_FRAME_SIZE\t\t128\n#define  MPT_DEFAULT_FRAME_SIZE\t\t128\n\n#define  MPT_REPLY_FRAME_SIZE\t\t0x50   \n\n#define  MPT_SG_REQ_128_SCALE\t\t1\n#define  MPT_SG_REQ_96_SCALE\t\t2\n#define  MPT_SG_REQ_64_SCALE\t\t4\n\n#define\t CAN_SLEEP\t\t\t1\n#define  NO_SLEEP\t\t\t0\n\n#define MPT_COALESCING_TIMEOUT\t\t0x10\n\n\n \n#define MPT_ULTRA320\t\t\t0x08\n#define MPT_ULTRA160\t\t\t0x09\n#define MPT_ULTRA2\t\t\t0x0A\n#define MPT_ULTRA\t\t\t0x0C\n#define MPT_FAST\t\t\t0x19\n#define MPT_SCSI\t\t\t0x32\n#define MPT_ASYNC\t\t\t0xFF\n\n#define MPT_NARROW\t\t\t0\n#define MPT_WIDE\t\t\t1\n\n#define C0_1030\t\t\t\t0x08\n#define XL_929\t\t\t\t0x01\n\n\n \n#define MPT_FC_CAN_QUEUE\t1024\n#define MPT_SCSI_CAN_QUEUE\t127\n#define MPT_SAS_CAN_QUEUE\t127\n\n \n#ifdef CONFIG_FUSION_MAX_SGE\n#if CONFIG_FUSION_MAX_SGE  < 16\n#define MPT_SCSI_SG_DEPTH\t16\n#elif CONFIG_FUSION_MAX_SGE  > 128\n#define MPT_SCSI_SG_DEPTH\t128\n#else\n#define MPT_SCSI_SG_DEPTH\tCONFIG_FUSION_MAX_SGE\n#endif\n#else\n#define MPT_SCSI_SG_DEPTH\t40\n#endif\n\n#ifdef CONFIG_FUSION_MAX_FC_SGE\n#if CONFIG_FUSION_MAX_FC_SGE  < 16\n#define MPT_SCSI_FC_SG_DEPTH\t16\n#elif CONFIG_FUSION_MAX_FC_SGE  > 256\n#define MPT_SCSI_FC_SG_DEPTH\t256\n#else\n#define MPT_SCSI_FC_SG_DEPTH\tCONFIG_FUSION_MAX_FC_SGE\n#endif\n#else\n#define MPT_SCSI_FC_SG_DEPTH\t40\n#endif\n\n \n# define EVENT_DESCR_STR_SZ             100\n\n#define MPT_POLLING_INTERVAL\t\t1000\t \n\n#ifdef __KERNEL__\t \n \n\n#include <linux/proc_fs.h>\n\n \n \n#define MYIOC_s_FMT\t\t\tMYNAM \": %s: \"\n#define MYIOC_s_DEBUG_FMT\t\tKERN_DEBUG MYNAM \": %s: \"\n#define MYIOC_s_INFO_FMT\t\tKERN_INFO MYNAM \": %s: \"\n#define MYIOC_s_NOTE_FMT\t\tKERN_NOTICE MYNAM \": %s: \"\n#define MYIOC_s_WARN_FMT\t\tKERN_WARNING MYNAM \": %s: WARNING - \"\n#define MYIOC_s_ERR_FMT\t\t\tKERN_ERR MYNAM \": %s: ERROR - \"\n\n \n \n#define ATTOFLAG_DISC     0x0001\n#define ATTOFLAG_TAGGED   0x0002\n#define ATTOFLAG_WIDE_ENB 0x0008\n#define ATTOFLAG_ID_ENB   0x0010\n#define ATTOFLAG_LUN_ENB  0x0060\n\ntypedef struct _ATTO_DEVICE_INFO\n{\n\tu8\tOffset;\t\t\t\t\t \n\tu8\tPeriod;\t\t\t\t\t \n\tu16\tATTOFlags;\t\t\t\t \n} ATTO_DEVICE_INFO, MPI_POINTER PTR_ATTO_DEVICE_INFO,\n  ATTODeviceInfo_t, MPI_POINTER pATTODeviceInfo_t;\n\ntypedef struct _ATTO_CONFIG_PAGE_SCSI_PORT_2\n{\n\tCONFIG_PAGE_HEADER\tHeader;\t\t\t \n\tu16\t\t\tPortFlags;\t\t \n\tu16\t\t\tUnused1;\t\t \n\tu32\t\t\tUnused2;\t\t \n\tATTO_DEVICE_INFO\tDeviceSettings[16];\t \n} fATTO_CONFIG_PAGE_SCSI_PORT_2, MPI_POINTER PTR_ATTO_CONFIG_PAGE_SCSI_PORT_2,\n  ATTO_SCSIPortPage2_t, MPI_POINTER pATTO_SCSIPortPage2_t;\n\n\n \n \ntypedef enum {\n\tMPTBASE_DRIVER,\t\t \n\tMPTCTL_DRIVER,\t\t \n\tMPTSPI_DRIVER,\t\t \n\tMPTFC_DRIVER,\t\t \n\tMPTSAS_DRIVER,\t\t \n\tMPTLAN_DRIVER,\t\t \n\tMPTSTM_DRIVER,\t\t \n\tMPTUNKNOWN_DRIVER\n} MPT_DRIVER_CLASS;\n\nstruct mpt_pci_driver{\n\tint  (*probe) (struct pci_dev *dev);\n\tvoid (*remove) (struct pci_dev *dev);\n};\n\n \n\ntypedef union _MPT_FRAME_TRACKER {\n\tstruct {\n\t\tstruct list_head\tlist;\n\t\tu32\t\t\t arg1;\n\t\tu32\t\t\t pad;\n\t\tvoid\t\t\t*argp1;\n\t} linkage;\n\t \n\tstruct {\n\t\tu32 __hdr[2];\n\t\t \n\t\tunion {\n\t\t\tu32\t\t MsgContext;\n\t\t\tstruct {\n\t\t\t\tu16\t req_idx;\t \n\t\t\t\tu8\t cb_idx;\t \n\t\t\t\tu8\t rsvd;\n\t\t\t} fld;\n\t\t} msgctxu;\n\t} hwhdr;\n\t \n} MPT_FRAME_TRACKER;\n\n \ntypedef struct _MPT_FRAME_HDR {\n\tunion {\n\t\tMPIHeader_t\t\thdr;\n\t\tSCSIIORequest_t\t\tscsireq;\n\t\tSCSIIOReply_t\t\tsreply;\n\t\tConfigReply_t\t\tconfigreply;\n\t\tMPIDefaultReply_t\treply;\n\t\tMPT_FRAME_TRACKER\tframe;\n\t} u;\n} MPT_FRAME_HDR;\n\n#define MPT_REQ_MSGFLAGS_DROPME\t\t0x80\n\ntypedef struct _MPT_SGL_HDR {\n\tSGESimple32_t\t sge[1];\n} MPT_SGL_HDR;\n\ntypedef struct _MPT_SGL64_HDR {\n\tSGESimple64_t\t sge[1];\n} MPT_SGL64_HDR;\n\n \n\ntypedef struct _SYSIF_REGS\n{\n\tu32\tDoorbell;\t \n\tu32\tWriteSequence;\t \n\tu32\tDiagnostic;\t \n\tu32\tTestBase;\t \n\tu32\tDiagRwData;\t \n\tu32\tDiagRwAddress;\t \n\tu32\tReserved1[6];\t \n\tu32\tIntStatus;\t \n\tu32\tIntMask;\t \n\tu32\tReserved2[2];\t \n\tu32\tRequestFifo;\t \n\tu32\tReplyFifo;\t \n\tu32\tRequestHiPriFifo;  \n\tu32\tReserved3;\t \n\tu32\tHostIndex;\t \n\tu32\tReserved4[15];\t \n\tu32\tFubar;\t\t \n\tu32\tReserved5[1050]; \n\tu32\tReset_1078;\t \n} SYSIF_REGS;\n\n \n\n\n \n\n \n#define MPT_TARGET_NO_NEGO_WIDE\t\t0x01\n#define MPT_TARGET_NO_NEGO_SYNC\t\t0x02\n#define MPT_TARGET_NO_NEGO_QAS\t\t0x04\n#define MPT_TAPE_NEGO_IDP     \t\t0x08\n\n \ntypedef struct _VirtTarget {\n\tstruct scsi_target\t*starget;\n\tu8\t\t\t tflags;\n\tu8\t\t\t ioc_id;\n\tu8\t\t\t id;\n\tu8\t\t\t channel;\n\tu8\t\t\t minSyncFactor;\t \n\tu8\t\t\t maxOffset;\t \n\tu8\t\t\t maxWidth;\t \n\tu8\t\t\t negoFlags;\t \n\tu8\t\t\t raidVolume;\t \n\tu8\t\t\t type;\t\t \n\tu8\t\t\t deleted;\t \n\tu8\t\t\t inDMD;\t\t \n\tu32\t\t\t num_luns;\n} VirtTarget;\n\ntypedef struct _VirtDevice {\n\tVirtTarget\t\t*vtarget;\n\tu8\t\t\t configured_lun;\n\tu64\t\t\t lun;\n} VirtDevice;\n\n \n#define MPT_TARGET_DEFAULT_DV_STATUS\t0x00\n#define MPT_TARGET_FLAGS_VALID_NEGO\t0x01\n#define MPT_TARGET_FLAGS_VALID_INQUIRY\t0x02\n#define MPT_TARGET_FLAGS_Q_YES\t\t0x08\n#define MPT_TARGET_FLAGS_VALID_56\t0x10\n#define MPT_TARGET_FLAGS_SAF_TE_ISSUED\t0x20\n#define MPT_TARGET_FLAGS_RAID_COMPONENT\t0x40\n#define MPT_TARGET_FLAGS_LED_ON\t\t0x80\n\n \n\n#define MPTCTL_RESET_OK\t\t\t0x01\t \n\n#define MPT_MGMT_STATUS_RF_VALID\t0x01\t \n#define MPT_MGMT_STATUS_COMMAND_GOOD\t0x02\t \n#define MPT_MGMT_STATUS_PENDING\t\t0x04\t \n#define MPT_MGMT_STATUS_DID_IOCRESET\t0x08\t \n#define MPT_MGMT_STATUS_SENSE_VALID\t0x10\t \n#define MPT_MGMT_STATUS_TIMER_ACTIVE\t0x20\t \n#define MPT_MGMT_STATUS_FREE_MF\t\t0x40\t \n\n#define INITIALIZE_MGMT_STATUS(status) \\\n\tstatus = MPT_MGMT_STATUS_PENDING;\n#define CLEAR_MGMT_STATUS(status) \\\n\tstatus = 0;\n#define CLEAR_MGMT_PENDING_STATUS(status) \\\n\tstatus &= ~MPT_MGMT_STATUS_PENDING;\n#define SET_MGMT_MSG_CONTEXT(msg_context, value) \\\n\tmsg_context = value;\n\ntypedef struct _MPT_MGMT {\n\tstruct mutex\t\t mutex;\n\tstruct completion\t done;\n\tu8\t\t\t reply[MPT_DEFAULT_FRAME_SIZE];  \n\tu8\t\t\t sense[MPT_SENSE_BUFFER_ALLOC];\n\tu8\t\t\t status;\t \n\tint\t\t\t completion_code;\n\tu32\t\t\t msg_context;\n} MPT_MGMT;\n\n \n#define MPTCTL_EVENT_LOG_SIZE\t\t(0x000000032)\ntypedef struct _mpt_ioctl_events {\n\tu32\tevent;\t\t \n\tu32\teventContext;\t \n\tu32\tdata[2];\t \n} MPT_IOCTL_EVENTS;\n\n \n#define MPT_CONFIG_GOOD\t\tMPI_IOCSTATUS_SUCCESS\n#define MPT_CONFIG_ERROR\t0x002F\n\n \n\t\t\t\t\t\t \n#define MPT_SCSICFG_USE_NVRAM\t\t0x01\t \n#define MPT_SCSICFG_ALL_IDS\t\t0x02\t \n \n\ntypedef\tstruct _SpiCfgData {\n\tu32\t\t PortFlags;\n\tint\t\t*nvram;\t\t\t \n\tIOCPage4_t\t*pIocPg4;\t\t \n\tdma_addr_t\t IocPg4_dma;\t\t \n\tint\t\t IocPg4Sz;\t\t \n\tu8\t\t minSyncFactor;\t\t \n\tu8\t\t maxSyncOffset;\t\t \n\tu8\t\t maxBusWidth;\t\t \n\tu8\t\t busType;\t\t \n\tu8\t\t sdp1version;\t\t \n\tu8\t\t sdp1length;\t\t \n\tu8\t\t sdp0version;\t\t \n\tu8\t\t sdp0length;\t\t \n\tu8\t\t dvScheduled;\t\t \n\tu8\t\t noQas;\t\t\t \n\tu8\t\t Saf_Te;\t\t \n\tu8\t\t bus_reset;\t\t \n\tu8\t\t rsvd[1];\n}SpiCfgData;\n\ntypedef\tstruct _SasCfgData {\n\tu8\t\t ptClear;\t\t \n}SasCfgData;\n\n \nstruct inactive_raid_component_info {\n\tstruct \t list_head list;\n\tu8\t\t volumeID;\t\t \n\tu8\t\t volumeBus;\t\t \n\tIOC_3_PHYS_DISK\t d;\t\t\t \n};\n\ntypedef\tstruct _RaidCfgData {\n\tIOCPage2_t\t*pIocPg2;\t\t \n\tIOCPage3_t\t*pIocPg3;\t\t \n\tstruct mutex\tinactive_list_mutex;\n\tstruct list_head\tinactive_list;  \n}RaidCfgData;\n\ntypedef struct _FcCfgData {\n\t \n\tstruct {\n\t\tFCPortPage1_t\t*data;\n\t\tdma_addr_t\t dma;\n\t\tint\t\t pg_sz;\n\t}\t\t\t fc_port_page1[2];\n} FcCfgData;\n\n#define MPT_RPORT_INFO_FLAGS_REGISTERED\t0x01\t \n#define MPT_RPORT_INFO_FLAGS_MISSING\t0x02\t \n\n \nstruct mptfc_rport_info\n{\n\tstruct list_head list;\n\tstruct fc_rport *rport;\n\tstruct scsi_target *starget;\n\tFCDevicePage0_t pg0;\n\tu8\t\tflags;\n};\n\n \n\n \n\n#define MPT_HOST_BUS_UNKNOWN\t\t(0xFF)\n#define MPT_HOST_TOO_MANY_TM\t\t(0x05)\n#define MPT_HOST_NVRAM_INVALID\t\t(0xFFFFFFFF)\n#define MPT_HOST_NO_CHAIN\t\t(0xFFFFFFFF)\n#define MPT_NVRAM_MASK_TIMEOUT\t\t(0x000000FF)\n#define MPT_NVRAM_SYNC_MASK\t\t(0x0000FF00)\n#define MPT_NVRAM_SYNC_SHIFT\t\t(8)\n#define MPT_NVRAM_DISCONNECT_ENABLE\t(0x00010000)\n#define MPT_NVRAM_ID_SCAN_ENABLE\t(0x00020000)\n#define MPT_NVRAM_LUN_SCAN_ENABLE\t(0x00040000)\n#define MPT_NVRAM_TAG_QUEUE_ENABLE\t(0x00080000)\n#define MPT_NVRAM_WIDE_DISABLE\t\t(0x00100000)\n#define MPT_NVRAM_BOOT_CHOICE\t\t(0x00200000)\n\ntypedef enum {\n\tFC,\n\tSPI,\n\tSAS\n} BUS_TYPE;\n\ntypedef struct _MPT_SCSI_HOST {\n\tstruct _MPT_ADAPTER\t\t *ioc;\n\tushort\t\t\t  sel_timeout[MPT_MAX_FC_DEVICES];\n\tchar\t\t\t  *info_kbuf;\n\tlong\t\t\t  last_queue_full;\n\tu16\t\t\t  spi_pending;\n\tstruct list_head\t  target_reset_list;\n} MPT_SCSI_HOST;\n\ntypedef void (*MPT_ADD_SGE)(void *pAddr, u32 flagslength, dma_addr_t dma_addr);\ntypedef void (*MPT_ADD_CHAIN)(void *pAddr, u8 next, u16 length,\n\t\tdma_addr_t dma_addr);\ntypedef void (*MPT_SCHEDULE_TARGET_RESET)(void *ioc);\ntypedef void (*MPT_FLUSH_RUNNING_CMDS)(MPT_SCSI_HOST *hd);\n\n \ntypedef struct _MPT_ADAPTER\n{\n\tint\t\t\t id;\t\t \n\tint\t\t\t pci_irq;\t \n\tchar\t\t\t name[MPT_NAME_LENGTH];\t \n\tconst char\t\t *prod_name;\t \n#ifdef CONFIG_FUSION_LOGGING\n\t \n\tchar\t\t\t evStr[EVENT_DESCR_STR_SZ];\n#endif\n\tchar\t\t\t board_name[16];\n\tchar\t\t\t board_assembly[16];\n\tchar\t\t\t board_tracer[16];\n\tu16\t\t\t nvdata_version_persistent;\n\tu16\t\t\t nvdata_version_default;\n\tint\t\t\t debug_level;\n\tu8\t\t\t io_missing_delay;\n\tu16\t\t\t device_missing_delay;\n\tSYSIF_REGS __iomem\t*chip;\t\t \n\tSYSIF_REGS __iomem\t*pio_chip;\t \n\tu8\t\t\t bus_type;\n\tu32\t\t\t mem_phys;\t \n\tu32\t\t\t pio_mem_phys;\t \n\tint\t\t\t mem_size;\t \n\tint\t\t\t number_of_buses;\n\tint\t\t\t devices_per_bus;\n\tint\t\t\t alloc_total;\n\tu32\t\t\t last_state;\n\tint\t\t\t active;\n\tu8\t\t\t*alloc;\t\t \n\tdma_addr_t\t\t alloc_dma;\n\tu32\t\t\t alloc_sz;\n\tMPT_FRAME_HDR\t\t*reply_frames;\t \n\tu32\t\t\t reply_frames_low_dma;\n\tint\t\t\t reply_depth;\t \n\tint\t\t\t reply_sz;\t \n\tint\t\t\t num_chain;\t \n\tMPT_ADD_SGE              add_sge;        \n\tMPT_ADD_CHAIN\t\t add_chain;\t \n\t\t \n\tint\t\t\t*ReqToChain;\n\tint\t\t\t*RequestNB;\n\tint\t\t\t*ChainToChain;\n\tu8\t\t\t*ChainBuffer;\n\tdma_addr_t\t\t ChainBufferDMA;\n\tstruct list_head\t FreeChainQ;\n\tspinlock_t\t\t FreeChainQlock;\n\t\t \n\tdma_addr_t\t\t req_frames_dma;\n\tMPT_FRAME_HDR\t\t*req_frames;\t \n\tu32\t\t\t req_frames_low_dma;\n\tint\t\t\t req_depth;\t \n\tint\t\t\t req_sz;\t \n\tspinlock_t\t\t FreeQlock;\n\tstruct list_head\t FreeQ;\n\t\t \n\tu8\t\t\t*sense_buf_pool;\n\tdma_addr_t\t\t sense_buf_pool_dma;\n\tu32\t\t\t sense_buf_low_dma;\n\tu8\t\t\t*HostPageBuffer;  \n\tu32\t\t\tHostPageBuffer_sz;\n\tdma_addr_t\t\tHostPageBuffer_dma;\n\tstruct pci_dev\t\t*pcidev;\t \n\tint\t\t\tbars;\t\t \n\tint\t\t\tmsi_enable;\n\tu8\t\t\t__iomem *memmap;\t \n\tstruct Scsi_Host\t*sh;\t\t \n\tSpiCfgData\t\tspi_data;\t \n\tRaidCfgData\t\traid_data;\t \n\tSasCfgData\t\tsas_data;\t \n\tFcCfgData\t\tfc_data;\t \n\tstruct proc_dir_entry\t*ioc_dentry;\n\tstruct _MPT_ADAPTER\t*alt_ioc;\t \n\tu32\t\t\t biosVersion;\t \n\tint\t\t\t eventTypes;\t \n\tint\t\t\t eventContext;\t \n\tint\t\t\t eventLogSize;\t \n\tstruct _mpt_ioctl_events *events;\t \n\tu8\t\t\t*cached_fw;\t \n\tdma_addr_t\t \tcached_fw_dma;\n\tint\t\t\t hs_reply_idx;\n#ifndef MFCNT\n\tu32\t\t\t pad0;\n#else\n\tu32\t\t\t mfcnt;\n#endif\n\tu32\t\t\t NB_for_64_byte_frame;\n\tu32\t\t\t hs_req[MPT_MAX_FRAME_SIZE/sizeof(u32)];\n\tu16\t\t\t hs_reply[MPT_MAX_FRAME_SIZE/sizeof(u16)];\n\tIOCFactsReply_t\t\t facts;\n\tPortFactsReply_t\t pfacts[2];\n\tFCPortPage0_t\t\t fc_port_page0[2];\n\tLANPage0_t\t\t lan_cnfg_page0;\n\tLANPage1_t\t\t lan_cnfg_page1;\n\n\tu8\t\t\t ir_firmware;  \n\t \n\tint\t\t\t errata_flag_1064;\n\tint\t\t\t aen_event_read_flag;  \n\tu8\t\t\t FirstWhoInit;\n\tu8\t\t\t upload_fw;\t \n\tu8\t\t\t NBShiftFactor;   \n\tu8\t\t\t pad1[4];\n\tu8\t\t\t DoneCtx;\n\tu8\t\t\t TaskCtx;\n\tu8\t\t\t InternalCtx;\n\tstruct list_head\t list;\n\tstruct net_device\t*netdev;\n\tstruct list_head\t sas_topology;\n\tstruct mutex\t\t sas_topology_mutex;\n\n\tstruct workqueue_struct\t*fw_event_q;\n\tstruct list_head\t fw_event_list;\n\tspinlock_t\t\t fw_event_lock;\n\tu8\t\t\t fw_events_off;  \n\tchar \t\t\t fw_event_q_name[MPT_KOBJ_NAME_LEN];\n\n\tstruct mutex\t\t sas_discovery_mutex;\n\tu8\t\t\t sas_discovery_runtime;\n\tu8\t\t\t sas_discovery_ignore_events;\n\n\t \n\tstruct mptsas_portinfo\t*hba_port_info;\n\tu64\t\t\t hba_port_sas_addr;\n\tu16\t\t\t hba_port_num_phy;\n\tstruct list_head\t sas_device_info_list;\n\tstruct mutex\t\t sas_device_info_mutex;\n\tu8\t\t\t old_sas_discovery_protocal;\n\tu8\t\t\t sas_discovery_quiesce_io;\n\tint\t\t\t sas_index;  \n\tMPT_MGMT\t\t sas_mgmt;\n\tMPT_MGMT\t\t mptbase_cmds;  \n\tMPT_MGMT\t\t internal_cmds;\n\tMPT_MGMT\t\t taskmgmt_cmds;\n\tMPT_MGMT\t\t ioctl_cmds;\n\tspinlock_t\t\t taskmgmt_lock;  \n\tint\t\t\t taskmgmt_in_progress;\n\tu8\t\t\t taskmgmt_quiesce_io;\n\tu8\t\t\t ioc_reset_in_progress;\n\tu8\t\t\t reset_status;\n\tu8\t\t\t wait_on_reset_completion;\n\tMPT_SCHEDULE_TARGET_RESET schedule_target_reset;\n\tMPT_FLUSH_RUNNING_CMDS schedule_dead_ioc_flush_running_cmds;\n\n\tstruct work_struct\t fc_setup_reset_work;\n\tstruct list_head\t fc_rports;\n\tstruct work_struct\t fc_lsc_work;\n\tu8\t\t\t fc_link_speed[2];\n\tspinlock_t\t\t fc_rescan_work_lock;\n\tstruct work_struct\t fc_rescan_work;\n\tchar\t\t\t fc_rescan_work_q_name[MPT_KOBJ_NAME_LEN];\n\tstruct workqueue_struct *fc_rescan_work_q;\n\n\t \n\tunsigned long\t\t  hard_resets;\n\t \n\tunsigned long\t\t  soft_resets;\n\t \n\tunsigned long\t\t  timeouts;\n\n\tstruct scsi_cmnd\t**ScsiLookup;\n\tspinlock_t\t\t  scsi_lookup_lock;\n\tu64\t\t\tdma_mask;\n\tu32\t\t\t  broadcast_aen_busy;\n\tchar\t\t\t reset_work_q_name[MPT_KOBJ_NAME_LEN];\n\tstruct workqueue_struct *reset_work_q;\n\tstruct delayed_work\t fault_reset_work;\n\n\tu8\t\t\tsg_addr_size;\n\tu8\t\t\tin_rescan;\n\tu8\t\t\tSGE_size;\n\n} MPT_ADAPTER;\n\n \ntypedef int (*MPT_CALLBACK)(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply);\ntypedef int (*MPT_EVHANDLER)(MPT_ADAPTER *ioc, EventNotificationReply_t *evReply);\ntypedef int (*MPT_RESETHANDLER)(MPT_ADAPTER *ioc, int reset_phase);\n \n#define MPT_IOC_PRE_RESET\t\t0\n#define MPT_IOC_POST_RESET\t\t1\n#define MPT_IOC_SETUP_RESET\t\t2\n\n \ntypedef struct _MPT_HOST_EVENT {\n\tEventNotificationReply_t\t MpiEvent;\t \n\tu32\t\t\t\t pad[6];\n\tvoid\t\t\t\t*next;\n} MPT_HOST_EVENT;\n\n#define MPT_HOSTEVENT_IOC_BRINGUP\t0x91\n#define MPT_HOSTEVENT_IOC_RECOVER\t0x92\n\n \ntypedef struct _mpt_sge {\n\tu32\t\tFlagsLength;\n\tdma_addr_t\tAddress;\n} MptSge_t;\n\n\n#define mpt_msg_flags(ioc) \\\n\t(ioc->sg_addr_size == sizeof(u64)) ?\t\t\\\n\tMPI_SCSIIO_MSGFLGS_SENSE_WIDTH_64 : \t\t\\\n\tMPI_SCSIIO_MSGFLGS_SENSE_WIDTH_32\n\n#define MPT_SGE_FLAGS_64_BIT_ADDRESSING \\\n\t(MPI_SGE_FLAGS_64_BIT_ADDRESSING << MPI_SGE_FLAGS_SHIFT)\n\n \n \n#include \"mptdebug.h\"\n\n#define MPT_INDEX_2_MFPTR(ioc,idx) \\\n\t(MPT_FRAME_HDR*)( (u8*)(ioc)->req_frames + (ioc)->req_sz * (idx) )\n\n#define MFPTR_2_MPT_INDEX(ioc,mf) \\\n\t(int)( ((u8*)mf - (u8*)(ioc)->req_frames) / (ioc)->req_sz )\n\n#define MPT_INDEX_2_RFPTR(ioc,idx) \\\n\t(MPT_FRAME_HDR*)( (u8*)(ioc)->reply_frames + (ioc)->req_sz * (idx) )\n\n \n\n#define SCSI_STD_SENSE_BYTES    18\n#define SCSI_STD_INQUIRY_BYTES  36\n#define SCSI_MAX_INQUIRY_BYTES  96\n\n \n \ntypedef struct _MPT_LOCAL_REPLY {\n\tConfigPageHeader_t header;\n\tint\tcompletion;\n\tu8\tsense[SCSI_STD_SENSE_BYTES];\n\tu8\tscsiStatus;\n\tu8\tskip;\n\tu32\tpad;\n} MPT_LOCAL_REPLY;\n\n\n \n#define TM_STATE_NONE          (0)\n#define\tTM_STATE_IN_PROGRESS   (1)\n#define\tTM_STATE_ERROR\t       (2)\n\n \n \n\n \nstruct scsi_cmnd;\n\n \n \ntypedef struct _x_config_parms {\n\tunion {\n\t\tConfigExtendedPageHeader_t\t*ehdr;\n\t\tConfigPageHeader_t\t*hdr;\n\t} cfghdr;\n\tdma_addr_t\t\t physAddr;\n\tu32\t\t\t pageAddr;\t \n\tu16\t\t\t status;\n\tu8\t\t\t action;\n\tu8\t\t\t dir;\n\tu8\t\t\t timeout;\t \n} CONFIGPARMS;\n\n \n \nextern int\t mpt_attach(struct pci_dev *pdev, const struct pci_device_id *id);\nextern void\t mpt_detach(struct pci_dev *pdev);\n#ifdef CONFIG_PM\nextern int\t mpt_suspend(struct pci_dev *pdev, pm_message_t state);\nextern int\t mpt_resume(struct pci_dev *pdev);\n#endif\nextern u8\t mpt_register(MPT_CALLBACK cbfunc, MPT_DRIVER_CLASS dclass,\n\t\tchar *func_name);\nextern void\t mpt_deregister(u8 cb_idx);\nextern int\t mpt_event_register(u8 cb_idx, MPT_EVHANDLER ev_cbfunc);\nextern void\t mpt_event_deregister(u8 cb_idx);\nextern int\t mpt_reset_register(u8 cb_idx, MPT_RESETHANDLER reset_func);\nextern void\t mpt_reset_deregister(u8 cb_idx);\nextern int\t mpt_device_driver_register(struct mpt_pci_driver * dd_cbfunc, u8 cb_idx);\nextern void\t mpt_device_driver_deregister(u8 cb_idx);\nextern MPT_FRAME_HDR\t*mpt_get_msg_frame(u8 cb_idx, MPT_ADAPTER *ioc);\nextern void\t mpt_free_msg_frame(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf);\nextern void\t mpt_put_msg_frame(u8 cb_idx, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf);\nextern void\t mpt_put_msg_frame_hi_pri(u8 cb_idx, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf);\n\nextern int\t mpt_send_handshake_request(u8 cb_idx, MPT_ADAPTER *ioc, int reqBytes, u32 *req, int sleepFlag);\nextern int\t mpt_verify_adapter(int iocid, MPT_ADAPTER **iocpp);\nextern u32\t mpt_GetIocState(MPT_ADAPTER *ioc, int cooked);\nextern void\t mpt_print_ioc_summary(MPT_ADAPTER *ioc, char *buf, int *size, int len, int showlan);\nextern int\t mpt_HardResetHandler(MPT_ADAPTER *ioc, int sleepFlag);\nextern int\t mpt_Soft_Hard_ResetHandler(MPT_ADAPTER *ioc, int sleepFlag);\nextern int\t mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS *cfg);\nextern int\t mpt_alloc_fw_memory(MPT_ADAPTER *ioc, int size);\nextern void\t mpt_free_fw_memory(MPT_ADAPTER *ioc);\nextern int\t mpt_findImVolumes(MPT_ADAPTER *ioc);\nextern int\t mptbase_sas_persist_operation(MPT_ADAPTER *ioc, u8 persist_opcode);\nextern int\t mpt_raid_phys_disk_pg0(MPT_ADAPTER *ioc, u8 phys_disk_num, pRaidPhysDiskPage0_t phys_disk);\nextern int\tmpt_raid_phys_disk_pg1(MPT_ADAPTER *ioc, u8 phys_disk_num,\n\t\tpRaidPhysDiskPage1_t phys_disk);\nextern int\tmpt_raid_phys_disk_get_num_paths(MPT_ADAPTER *ioc,\n\t\tu8 phys_disk_num);\nextern int\t mpt_set_taskmgmt_in_progress_flag(MPT_ADAPTER *ioc);\nextern void\t mpt_clear_taskmgmt_in_progress_flag(MPT_ADAPTER *ioc);\nextern void __noreturn mpt_halt_firmware(MPT_ADAPTER *ioc);\n\n\n \nextern struct list_head\t  ioc_list;\nextern int mpt_fwfault_debug;\n\n \n#endif\t\t \n\n#ifdef CONFIG_64BIT\n#define CAST_U32_TO_PTR(x)\t((void *)(u64)x)\n#define CAST_PTR_TO_U32(x)\t((u32)(u64)x)\n#else\n#define CAST_U32_TO_PTR(x)\t((void *)x)\n#define CAST_PTR_TO_U32(x)\t((u32)x)\n#endif\n\n#define MPT_PROTOCOL_FLAGS_c_c_c_c(pflags) \\\n\t((pflags) & MPI_PORTFACTS_PROTOCOL_INITIATOR)\t? 'I' : 'i',\t\\\n\t((pflags) & MPI_PORTFACTS_PROTOCOL_TARGET)\t? 'T' : 't',\t\\\n\t((pflags) & MPI_PORTFACTS_PROTOCOL_LAN)\t\t? 'L' : 'l',\t\\\n\t((pflags) & MPI_PORTFACTS_PROTOCOL_LOGBUSADDR)\t? 'B' : 'b'\n\n \n#define MPT_TRANSFER_IOC_TO_HOST\t\t(0x00000000)\n#define MPT_TRANSFER_HOST_TO_IOC\t\t(0x04000000)\n#define MPT_SGE_FLAGS_LAST_ELEMENT\t\t(0x80000000)\n#define MPT_SGE_FLAGS_END_OF_BUFFER\t\t(0x40000000)\n#define MPT_SGE_FLAGS_LOCAL_ADDRESS\t\t(0x08000000)\n#define MPT_SGE_FLAGS_DIRECTION\t\t\t(0x04000000)\n#define MPT_SGE_FLAGS_END_OF_LIST\t\t(0x01000000)\n\n#define MPT_SGE_FLAGS_TRANSACTION_ELEMENT\t(0x00000000)\n#define MPT_SGE_FLAGS_SIMPLE_ELEMENT\t\t(0x10000000)\n#define MPT_SGE_FLAGS_CHAIN_ELEMENT\t\t(0x30000000)\n#define MPT_SGE_FLAGS_ELEMENT_MASK\t\t(0x30000000)\n\n#define MPT_SGE_FLAGS_SSIMPLE_READ \\\n\t(MPT_SGE_FLAGS_LAST_ELEMENT |\t\\\n\t MPT_SGE_FLAGS_END_OF_BUFFER |\t\\\n\t MPT_SGE_FLAGS_END_OF_LIST |\t\\\n\t MPT_SGE_FLAGS_SIMPLE_ELEMENT |\t\\\n\t MPT_TRANSFER_IOC_TO_HOST)\n#define MPT_SGE_FLAGS_SSIMPLE_WRITE \\\n\t(MPT_SGE_FLAGS_LAST_ELEMENT |\t\\\n\t MPT_SGE_FLAGS_END_OF_BUFFER |\t\\\n\t MPT_SGE_FLAGS_END_OF_LIST |\t\\\n\t MPT_SGE_FLAGS_SIMPLE_ELEMENT |\t\\\n\t MPT_TRANSFER_HOST_TO_IOC)\n\n \n#endif\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}