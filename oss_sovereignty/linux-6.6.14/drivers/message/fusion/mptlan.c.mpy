{
  "module_name": "mptlan.c",
  "hash_id": "1d67785a633c6208963766caa0cc92b09f537fe8942784e1c1a21e28a4003ecf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/message/fusion/mptlan.c",
  "human_readable_source": " \n \n \n\n \n \n\n\n \n\n#include \"mptlan.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define my_VERSION\tMPT_LINUX_VERSION_COMMON\n#define MYNAM\t\t\"mptlan\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(my_VERSION);\n\n \n \n#define MPT_LAN_RECEIVE_POST_REQUEST_SIZE \\\n\t(sizeof(LANReceivePostRequest_t) - sizeof(SGE_MPI_UNION))\n\n \n\nstruct BufferControl {\n\tstruct sk_buff\t*skb;\n\tdma_addr_t\tdma;\n\tunsigned int\tlen;\n};\n\nstruct mpt_lan_priv {\n\tMPT_ADAPTER *mpt_dev;\n\tu8 pnum;  \n\n\tatomic_t buckets_out;\t\t \n\tint bucketthresh;\t\t \n\n\tint *mpt_txfidx;  \n\tint mpt_txfidx_tail;\n\tspinlock_t txfidx_lock;\n\n\tint *mpt_rxfidx;  \n\tint mpt_rxfidx_tail;\n\tspinlock_t rxfidx_lock;\n\n\tstruct BufferControl *RcvCtl;\t \n\tstruct BufferControl *SendCtl;\t \n\n\tint max_buckets_out;\t\t \n\tint tx_max_out;\t\t\t \n\n\tu32 total_posted;\n\tu32 total_received;\n\n\tstruct delayed_work post_buckets_task;\n\tstruct net_device *dev;\n\tunsigned long post_buckets_active;\n};\n\nstruct mpt_lan_ohdr {\n\tu16\tdtype;\n\tu8\tdaddr[FC_ALEN];\n\tu16\tstype;\n\tu8\tsaddr[FC_ALEN];\n};\n\n \n\n \nstatic int  lan_reply (MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf,\n\t\t       MPT_FRAME_HDR *reply);\nstatic int  mpt_lan_open(struct net_device *dev);\nstatic int  mpt_lan_reset(struct net_device *dev);\nstatic int  mpt_lan_close(struct net_device *dev);\nstatic void mpt_lan_post_receive_buckets(struct mpt_lan_priv *priv);\nstatic void mpt_lan_wake_post_buckets_task(struct net_device *dev,\n\t\t\t\t\t   int priority);\nstatic int  mpt_lan_receive_post_turbo(struct net_device *dev, u32 tmsg);\nstatic int  mpt_lan_receive_post_reply(struct net_device *dev,\n\t\t\t\t       LANReceivePostReply_t *pRecvRep);\nstatic int  mpt_lan_send_turbo(struct net_device *dev, u32 tmsg);\nstatic int  mpt_lan_send_reply(struct net_device *dev,\n\t\t\t       LANSendReply_t *pSendRep);\nstatic int  mpt_lan_ioc_reset(MPT_ADAPTER *ioc, int reset_phase);\nstatic int  mpt_lan_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply);\nstatic unsigned short mpt_lan_type_trans(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev);\n\n \n \nstatic u8 LanCtx = MPT_MAX_PROTOCOL_DRIVERS;\n\nstatic u32 max_buckets_out = 127;\nstatic u32 tx_max_out_p = 127 - 16;\n\n \n \nstatic int\nlan_reply (MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *reply)\n{\n\tstruct net_device *dev = ioc->netdev;\n\tint FreeReqFrame = 0;\n\n\tdioprintk((KERN_INFO MYNAM \": %s/%s: Got reply.\\n\",\n\t\t  IOC_AND_NETDEV_NAMES_s_s(dev)));\n\n \n \n\n\tif (mf == NULL) {\n\t\tu32 tmsg = CAST_PTR_TO_U32(reply);\n\n\t\tdioprintk((KERN_INFO MYNAM \": %s/%s: @lan_reply, tmsg %08x\\n\",\n\t\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t\t\ttmsg));\n\n\t\tswitch (GET_LAN_FORM(tmsg)) {\n\n\t\t \n\t\t \n\t\t \n#if 0\n\t\tcase LAN_REPLY_FORM_MESSAGE_CONTEXT:\n \n \n\t\t\tFreeReqFrame = 1;\n\t\t\tbreak;\n#endif\n\n\t\tcase LAN_REPLY_FORM_SEND_SINGLE:\n \n \n\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t\n\n\t\t\t(void) mpt_lan_send_turbo(dev, tmsg);\n\t\t\tFreeReqFrame = 0;\n\n\t\t\tbreak;\n\n\t\tcase LAN_REPLY_FORM_RECEIVE_SINGLE:\n\n\n\t\t\tmpt_lan_receive_post_turbo(dev, tmsg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk (KERN_ERR MYNAM \"/lan_reply: Got a turbo reply \"\n\t\t\t\t\"that I don't know what to do with\\n\");\n\n\t\t\t \n\n\t\t\tbreak;\n\t\t}\n\n\t\treturn FreeReqFrame;\n\t}\n\n\n\n\n\n\n\n\n\tswitch (reply->u.hdr.Function) {\n\n\tcase MPI_FUNCTION_LAN_SEND:\n\t{\n\t\tLANSendReply_t *pSendRep;\n\n\t\tpSendRep = (LANSendReply_t *) reply;\n\t\tFreeReqFrame = mpt_lan_send_reply(dev, pSendRep);\n\t\tbreak;\n\t}\n\n\tcase MPI_FUNCTION_LAN_RECEIVE:\n\t{\n\t\tLANReceivePostReply_t *pRecvRep;\n\n\t\tpRecvRep = (LANReceivePostReply_t *) reply;\n\t\tif (pRecvRep->NumberOfContexts) {\n\t\t\tmpt_lan_receive_post_reply(dev, pRecvRep);\n\t\t\tif (!(pRecvRep->MsgFlags & MPI_MSGFLAGS_CONTINUATION_REPLY))\n\t\t\t\tFreeReqFrame = 1;\n\t\t} else\n\t\t\tdioprintk((KERN_INFO MYNAM \"@lan_reply: zero context \"\n\t\t\t\t  \"ReceivePostReply received.\\n\"));\n\t\tbreak;\n\t}\n\n\tcase MPI_FUNCTION_LAN_RESET:\n\t\t \n\t\tFreeReqFrame = 1;\n\t\tbreak;\n\n\tcase MPI_FUNCTION_EVENT_NOTIFICATION:\n\tcase MPI_FUNCTION_EVENT_ACK:\n\t\t \n\t\tFreeReqFrame = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk (KERN_ERR MYNAM \"/lan_reply: Got a non-turbo \"\n\t\t\t\"reply that I don't know what to do with\\n\");\n\n\t\t \n\t\tFreeReqFrame = 1;\n\n\t\tbreak;\n\t}\n\n\treturn FreeReqFrame;\n}\n\n \nstatic int\nmpt_lan_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\n{\n\tstruct net_device *dev = ioc->netdev;\n\tstruct mpt_lan_priv *priv;\n\n\tif (dev == NULL)\n\t\treturn(1);\n\telse\n\t\tpriv = netdev_priv(dev);\n\n\tdlprintk((KERN_INFO MYNAM \": IOC %s_reset routed to LAN driver!\\n\",\n\t\t\treset_phase==MPT_IOC_SETUP_RESET ? \"setup\" : (\n\t\t\treset_phase==MPT_IOC_PRE_RESET ? \"pre\" : \"post\")));\n\n\tif (priv->mpt_rxfidx == NULL)\n\t\treturn (1);\n\n\tif (reset_phase == MPT_IOC_SETUP_RESET) {\n\t\t;\n\t} else if (reset_phase == MPT_IOC_PRE_RESET) {\n\t\tint i;\n\t\tunsigned long flags;\n\n\t\tnetif_stop_queue(dev);\n\n\t\tdlprintk ((KERN_INFO \"mptlan/ioc_reset: called netif_stop_queue for %s.\\n\", dev->name));\n\n\t\tatomic_set(&priv->buckets_out, 0);\n\n\t\t \n\t\tspin_lock_irqsave(&priv->rxfidx_lock, flags);\n\t\tpriv->mpt_rxfidx_tail = -1;\n\t\tfor (i = 0; i < priv->max_buckets_out; i++)\n\t\t\tpriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = i;\n\t\tspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\n\t} else {\n\t\tmpt_lan_post_receive_buckets(priv);\n\t\tnetif_wake_queue(dev);\n\t}\n\n\treturn 1;\n}\n\n \nstatic int\nmpt_lan_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)\n{\n\tdlprintk((KERN_INFO MYNAM \": MPT event routed to LAN driver!\\n\"));\n\n\tswitch (le32_to_cpu(pEvReply->Event)) {\n\tcase MPI_EVENT_NONE:\t\t\t\t \n\tcase MPI_EVENT_LOG_DATA:\t\t\t \n\tcase MPI_EVENT_STATE_CHANGE:\t\t\t \n\tcase MPI_EVENT_UNIT_ATTENTION:\t\t\t \n\tcase MPI_EVENT_IOC_BUS_RESET:\t\t\t \n\tcase MPI_EVENT_EXT_BUS_RESET:\t\t\t \n\tcase MPI_EVENT_RESCAN:\t\t\t\t \n\t\t \n\tcase MPI_EVENT_LINK_STATUS_CHANGE:\t\t \n\tcase MPI_EVENT_LOOP_STATE_CHANGE:\t\t \n\tcase MPI_EVENT_LOGOUT:\t\t\t\t \n\tcase MPI_EVENT_EVENT_CHANGE:\t\t\t \n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\n\treturn 1;\n}\n\n \nstatic int\nmpt_lan_open(struct net_device *dev)\n{\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\tint i;\n\n\tif (mpt_lan_reset(dev) != 0) {\n\t\tMPT_ADAPTER *mpt_dev = priv->mpt_dev;\n\n\t\tprintk (KERN_WARNING MYNAM \"/lan_open: lan_reset failed.\");\n\n\t\tif (mpt_dev->active)\n\t\t\tprintk (\"The ioc is active. Perhaps it needs to be\"\n\t\t\t\t\" reset?\\n\");\n\t\telse\n\t\t\tprintk (\"The ioc in inactive, most likely in the \"\n\t\t\t\t\"process of being reset. Please try again in \"\n\t\t\t\t\"a moment.\\n\");\n\t}\n\n\tpriv->mpt_txfidx = kmalloc_array(priv->tx_max_out, sizeof(int),\n\t\t\t\t\t GFP_KERNEL);\n\tif (priv->mpt_txfidx == NULL)\n\t\tgoto out;\n\tpriv->mpt_txfidx_tail = -1;\n\n\tpriv->SendCtl = kcalloc(priv->tx_max_out, sizeof(struct BufferControl),\n\t\t\t\tGFP_KERNEL);\n\tif (priv->SendCtl == NULL)\n\t\tgoto out_mpt_txfidx;\n\tfor (i = 0; i < priv->tx_max_out; i++)\n\t\tpriv->mpt_txfidx[++priv->mpt_txfidx_tail] = i;\n\n\tdlprintk((KERN_INFO MYNAM \"@lo: Finished initializing SendCtl\\n\"));\n\n\tpriv->mpt_rxfidx = kmalloc_array(priv->max_buckets_out, sizeof(int),\n\t\t\t\t\t GFP_KERNEL);\n\tif (priv->mpt_rxfidx == NULL)\n\t\tgoto out_SendCtl;\n\tpriv->mpt_rxfidx_tail = -1;\n\n\tpriv->RcvCtl = kcalloc(priv->max_buckets_out,\n\t\t\t       sizeof(struct BufferControl),\n\t\t\t       GFP_KERNEL);\n\tif (priv->RcvCtl == NULL)\n\t\tgoto out_mpt_rxfidx;\n\tfor (i = 0; i < priv->max_buckets_out; i++)\n\t\tpriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = i;\n\n \tdlprintk((KERN_INFO MYNAM \"/lo: txfidx contains - \"));\n \tfor (i = 0; i < priv->tx_max_out; i++)\n \t\tdlprintk((\" %xh\", priv->mpt_txfidx[i]));\n \tdlprintk((\"\\n\"));\n\n\tdlprintk((KERN_INFO MYNAM \"/lo: Finished initializing RcvCtl\\n\"));\n\n\tmpt_lan_post_receive_buckets(priv);\n\tprintk(KERN_INFO MYNAM \": %s/%s: interface up & active\\n\",\n\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev));\n\n\tif (mpt_event_register(LanCtx, mpt_lan_event_process) != 0) {\n\t\tprintk (KERN_WARNING MYNAM \"/lo: Unable to register for Event\"\n\t\t\t\" Notifications. This is a bad thing! We're not going \"\n\t\t\t\"to go ahead, but I'd be leery of system stability at \"\n\t\t\t\"this point.\\n\");\n\t}\n\n\tnetif_start_queue(dev);\n\tdlprintk((KERN_INFO MYNAM \"/lo: Done.\\n\"));\n\n\treturn 0;\nout_mpt_rxfidx:\n\tkfree(priv->mpt_rxfidx);\n\tpriv->mpt_rxfidx = NULL;\nout_SendCtl:\n\tkfree(priv->SendCtl);\n\tpriv->SendCtl = NULL;\nout_mpt_txfidx:\n\tkfree(priv->mpt_txfidx);\n\tpriv->mpt_txfidx = NULL;\nout:\treturn -ENOMEM;\n}\n\n \n \nstatic int\nmpt_lan_reset(struct net_device *dev)\n{\n\tMPT_FRAME_HDR *mf;\n\tLANResetRequest_t *pResetReq;\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\n\tmf = mpt_get_msg_frame(LanCtx, priv->mpt_dev);\n\n\tif (mf == NULL) {\n \n\t\treturn -1;\n\t}\n\n\tpResetReq = (LANResetRequest_t *) mf;\n\n\tpResetReq->Function\t= MPI_FUNCTION_LAN_RESET;\n\tpResetReq->ChainOffset\t= 0;\n\tpResetReq->Reserved\t= 0;\n\tpResetReq->PortNumber\t= priv->pnum;\n\tpResetReq->MsgFlags\t= 0;\n\tpResetReq->Reserved2\t= 0;\n\n\tmpt_put_msg_frame(LanCtx, priv->mpt_dev, mf);\n\n\treturn 0;\n}\n\n \nstatic int\nmpt_lan_close(struct net_device *dev)\n{\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\tMPT_ADAPTER *mpt_dev = priv->mpt_dev;\n\tunsigned long timeout;\n\tint i;\n\n\tdlprintk((KERN_INFO MYNAM \": mpt_lan_close called\\n\"));\n\n\tmpt_event_deregister(LanCtx);\n\n\tdlprintk((KERN_INFO MYNAM \":lan_close: Posted %d buckets \"\n\t\t  \"since driver was loaded, %d still out\\n\",\n\t\t  priv->total_posted,atomic_read(&priv->buckets_out)));\n\n\tnetif_stop_queue(dev);\n\n\tmpt_lan_reset(dev);\n\n\ttimeout = jiffies + 2 * HZ;\n\twhile (atomic_read(&priv->buckets_out) && time_before(jiffies, timeout))\n\t\tschedule_timeout_interruptible(1);\n\n\tfor (i = 0; i < priv->max_buckets_out; i++) {\n\t\tif (priv->RcvCtl[i].skb != NULL) {\n \t\t\tdlprintk((KERN_INFO MYNAM \"/lan_close: bucket %05x \"\n \t\t\t\t  \"is still out\\n\", i));\n\t\t\tdma_unmap_single(&mpt_dev->pcidev->dev,\n\t\t\t\t\t priv->RcvCtl[i].dma,\n\t\t\t\t\t priv->RcvCtl[i].len, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(priv->RcvCtl[i].skb);\n\t\t}\n\t}\n\n\tkfree(priv->RcvCtl);\n\tkfree(priv->mpt_rxfidx);\n\n\tfor (i = 0; i < priv->tx_max_out; i++) {\n\t\tif (priv->SendCtl[i].skb != NULL) {\n\t\t\tdma_unmap_single(&mpt_dev->pcidev->dev,\n\t\t\t\t\t priv->SendCtl[i].dma,\n\t\t\t\t\t priv->SendCtl[i].len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(priv->SendCtl[i].skb);\n\t\t}\n\t}\n\n\tkfree(priv->SendCtl);\n\tkfree(priv->mpt_txfidx);\n\n\tatomic_set(&priv->buckets_out, 0);\n\n\tprintk(KERN_INFO MYNAM \": %s/%s: interface down & inactive\\n\",\n\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev));\n\n\treturn 0;\n}\n\n \n \nstatic void\nmpt_lan_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\tMPT_ADAPTER *mpt_dev = priv->mpt_dev;\n\n\tif (mpt_dev->active) {\n\t\tdlprintk ((\"mptlan/tx_timeout: calling netif_wake_queue for %s.\\n\", dev->name));\n\t\tnetif_wake_queue(dev);\n\t}\n}\n\n \n\nstatic int\nmpt_lan_send_turbo(struct net_device *dev, u32 tmsg)\n{\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\tMPT_ADAPTER *mpt_dev = priv->mpt_dev;\n\tstruct sk_buff *sent;\n\tunsigned long flags;\n\tu32 ctx;\n\n\tctx = GET_LAN_BUFFER_CONTEXT(tmsg);\n\tsent = priv->SendCtl[ctx].skb;\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += sent->len;\n\n\tdioprintk((KERN_INFO MYNAM \": %s/%s: @%s, skb %p sent.\\n\",\n\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t\t__func__, sent));\n\n\tpriv->SendCtl[ctx].skb = NULL;\n\tdma_unmap_single(&mpt_dev->pcidev->dev, priv->SendCtl[ctx].dma,\n\t\t\t priv->SendCtl[ctx].len, DMA_TO_DEVICE);\n\tdev_kfree_skb_irq(sent);\n\n\tspin_lock_irqsave(&priv->txfidx_lock, flags);\n\tpriv->mpt_txfidx[++priv->mpt_txfidx_tail] = ctx;\n\tspin_unlock_irqrestore(&priv->txfidx_lock, flags);\n\n\tnetif_wake_queue(dev);\n\treturn 0;\n}\n\n \nstatic int\nmpt_lan_send_reply(struct net_device *dev, LANSendReply_t *pSendRep)\n{\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\tMPT_ADAPTER *mpt_dev = priv->mpt_dev;\n\tstruct sk_buff *sent;\n\tunsigned long flags;\n\tint FreeReqFrame = 0;\n\tu32 *pContext;\n\tu32 ctx;\n\tu8 count;\n\n\tcount = pSendRep->NumberOfContexts;\n\n\tdioprintk((KERN_INFO MYNAM \": send_reply: IOCStatus: %04x\\n\",\n\t\t le16_to_cpu(pSendRep->IOCStatus)));\n\n\t \n\n\tswitch (le16_to_cpu(pSendRep->IOCStatus) & MPI_IOCSTATUS_MASK) {\n\tcase MPI_IOCSTATUS_SUCCESS:\n\t\tdev->stats.tx_packets += count;\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_LAN_CANCELED:\n\tcase MPI_IOCSTATUS_LAN_TRANSMIT_ABORTED:\n\t\tbreak;\n\n\tcase MPI_IOCSTATUS_INVALID_SGL:\n\t\tdev->stats.tx_errors += count;\n\t\tprintk (KERN_ERR MYNAM \": %s/%s: ERROR - Invalid SGL sent to IOC!\\n\",\n\t\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev));\n\t\tgoto out;\n\n\tdefault:\n\t\tdev->stats.tx_errors += count;\n\t\tbreak;\n\t}\n\n\tpContext = &pSendRep->BufferContext;\n\n\tspin_lock_irqsave(&priv->txfidx_lock, flags);\n\twhile (count > 0) {\n\t\tctx = GET_LAN_BUFFER_CONTEXT(le32_to_cpu(*pContext));\n\n\t\tsent = priv->SendCtl[ctx].skb;\n\t\tdev->stats.tx_bytes += sent->len;\n\n\t\tdioprintk((KERN_INFO MYNAM \": %s/%s: @%s, skb %p sent.\\n\",\n\t\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t\t\t__func__, sent));\n\n\t\tpriv->SendCtl[ctx].skb = NULL;\n\t\tdma_unmap_single(&mpt_dev->pcidev->dev,\n\t\t\t\t priv->SendCtl[ctx].dma,\n\t\t\t\t priv->SendCtl[ctx].len, DMA_TO_DEVICE);\n\t\tdev_kfree_skb_irq(sent);\n\n\t\tpriv->mpt_txfidx[++priv->mpt_txfidx_tail] = ctx;\n\n\t\tpContext++;\n\t\tcount--;\n\t}\n\tspin_unlock_irqrestore(&priv->txfidx_lock, flags);\n\nout:\n\tif (!(pSendRep->MsgFlags & MPI_MSGFLAGS_CONTINUATION_REPLY))\n\t\tFreeReqFrame = 1;\n\n\tnetif_wake_queue(dev);\n\treturn FreeReqFrame;\n}\n\n \nstatic netdev_tx_t\nmpt_lan_sdu_send (struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\tMPT_ADAPTER *mpt_dev = priv->mpt_dev;\n\tMPT_FRAME_HDR *mf;\n\tLANSendRequest_t *pSendReq;\n\tSGETransaction32_t *pTrans;\n\tSGESimple64_t *pSimple;\n\tconst unsigned char *mac;\n\tdma_addr_t dma;\n\tunsigned long flags;\n\tint ctx;\n\tu16 cur_naa = 0x1000;\n\n\tdioprintk((KERN_INFO MYNAM \": %s called, skb_addr = %p\\n\",\n\t\t\t__func__, skb));\n\n\tspin_lock_irqsave(&priv->txfidx_lock, flags);\n\tif (priv->mpt_txfidx_tail < 0) {\n\t\tnetif_stop_queue(dev);\n\t\tspin_unlock_irqrestore(&priv->txfidx_lock, flags);\n\n\t\tprintk (KERN_ERR \"%s: no tx context available: %u\\n\",\n\t\t\t__func__, priv->mpt_txfidx_tail);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tmf = mpt_get_msg_frame(LanCtx, mpt_dev);\n\tif (mf == NULL) {\n\t\tnetif_stop_queue(dev);\n\t\tspin_unlock_irqrestore(&priv->txfidx_lock, flags);\n\n\t\tprintk (KERN_ERR \"%s: Unable to alloc request frame\\n\",\n\t\t\t__func__);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tctx = priv->mpt_txfidx[priv->mpt_txfidx_tail--];\n\tspin_unlock_irqrestore(&priv->txfidx_lock, flags);\n\n\n\n\n\tpSendReq = (LANSendRequest_t *) mf;\n\n\t \n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, 12);\n\n\tdma = dma_map_single(&mpt_dev->pcidev->dev, skb->data, skb->len,\n\t\t\t     DMA_TO_DEVICE);\n\n\tpriv->SendCtl[ctx].skb = skb;\n\tpriv->SendCtl[ctx].dma = dma;\n\tpriv->SendCtl[ctx].len = skb->len;\n\n\t \n\tpSendReq->Reserved    = 0;\n\tpSendReq->Function    = MPI_FUNCTION_LAN_SEND;\n\tpSendReq->ChainOffset = 0;\n\tpSendReq->Reserved2   = 0;\n\tpSendReq->MsgFlags    = 0;\n\tpSendReq->PortNumber  = priv->pnum;\n\n\t \n\tpTrans = (SGETransaction32_t *) pSendReq->SG_List;\n\n\t \n\tpTrans->ContextSize   = sizeof(u32);\n\tpTrans->DetailsLength = 2 * sizeof(u32);\n\tpTrans->Flags         = 0;\n\tpTrans->TransactionContext = cpu_to_le32(ctx);\n\n \n \n \n\n\tmac = skb_mac_header(skb);\n\n\tpTrans->TransactionDetails[0] = cpu_to_le32((cur_naa         << 16) |\n\t\t\t\t\t\t    (mac[0] <<  8) |\n\t\t\t\t\t\t    (mac[1] <<  0));\n\tpTrans->TransactionDetails[1] = cpu_to_le32((mac[2] << 24) |\n\t\t\t\t\t\t    (mac[3] << 16) |\n\t\t\t\t\t\t    (mac[4] <<  8) |\n\t\t\t\t\t\t    (mac[5] <<  0));\n\n\tpSimple = (SGESimple64_t *) &pTrans->TransactionDetails[2];\n\n\t \n\tpSimple->FlagsLength = cpu_to_le32(\n\t\t\t((MPI_SGE_FLAGS_LAST_ELEMENT |\n\t\t\t  MPI_SGE_FLAGS_END_OF_BUFFER |\n\t\t\t  MPI_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t\t  MPI_SGE_FLAGS_SYSTEM_ADDRESS |\n\t\t\t  MPI_SGE_FLAGS_HOST_TO_IOC |\n\t\t\t  MPI_SGE_FLAGS_64_BIT_ADDRESSING |\n\t\t\t  MPI_SGE_FLAGS_END_OF_LIST) << MPI_SGE_FLAGS_SHIFT) |\n\t\t\tskb->len);\n\tpSimple->Address.Low = cpu_to_le32((u32) dma);\n\tif (sizeof(dma_addr_t) > sizeof(u32))\n\t\tpSimple->Address.High = cpu_to_le32((u32) ((u64) dma >> 32));\n\telse\n\t\tpSimple->Address.High = 0;\n\n\tmpt_put_msg_frame (LanCtx, mpt_dev, mf);\n\tnetif_trans_update(dev);\n\n\tdioprintk((KERN_INFO MYNAM \": %s/%s: Sending packet. FlagsLength = %08x.\\n\",\n\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t\tle32_to_cpu(pSimple->FlagsLength)));\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void\nmpt_lan_wake_post_buckets_task(struct net_device *dev, int priority)\n \n{\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\t\n\tif (test_and_set_bit(0, &priv->post_buckets_active) == 0) {\n\t\tif (priority) {\n\t\t\tschedule_delayed_work(&priv->post_buckets_task, 0);\n\t\t} else {\n\t\t\tschedule_delayed_work(&priv->post_buckets_task, 1);\n\t\t\tdioprintk((KERN_INFO MYNAM \": post_buckets queued on \"\n\t\t\t\t   \"timer.\\n\"));\n\t\t}\n\t        dioprintk((KERN_INFO MYNAM \": %s/%s: Queued post_buckets task.\\n\",\n\t\t\t   IOC_AND_NETDEV_NAMES_s_s(dev) ));\n\t}\n}\n\n \nstatic int\nmpt_lan_receive_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\n\tskb->protocol = mpt_lan_type_trans(skb, dev);\n\n\tdioprintk((KERN_INFO MYNAM \": %s/%s: Incoming packet (%d bytes) \"\n\t\t \"delivered to upper level.\\n\",\n\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev), skb->len));\n\n\tdev->stats.rx_bytes += skb->len;\n\tdev->stats.rx_packets++;\n\n\tskb->dev = dev;\n\tnetif_rx(skb);\n\n\tdioprintk((MYNAM \"/receive_skb: %d buckets remaining\\n\",\n\t\t atomic_read(&priv->buckets_out)));\n\n\tif (atomic_read(&priv->buckets_out) < priv->bucketthresh)\n\t\tmpt_lan_wake_post_buckets_task(dev, 1);\n\n\tdioprintk((KERN_INFO MYNAM \"/receive_post_reply: %d buckets \"\n\t\t  \"remaining, %d received back since sod\\n\",\n\t\t  atomic_read(&priv->buckets_out), priv->total_received));\n\n\treturn 0;\n}\n\n \n \nstatic int\nmpt_lan_receive_post_turbo(struct net_device *dev, u32 tmsg)\n{\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\tMPT_ADAPTER *mpt_dev = priv->mpt_dev;\n\tstruct sk_buff *skb, *old_skb;\n\tunsigned long flags;\n\tu32 ctx, len;\n\n\tctx = GET_LAN_BUCKET_CONTEXT(tmsg);\n\tskb = priv->RcvCtl[ctx].skb;\n\n\tlen = GET_LAN_PACKET_LENGTH(tmsg);\n\n\tif (len < MPT_LAN_RX_COPYBREAK) {\n\t\told_skb = skb;\n\n\t\tskb = (struct sk_buff *)dev_alloc_skb(len);\n\t\tif (!skb) {\n\t\t\tprintk (KERN_ERR MYNAM \": %s/%s: ERROR - Can't allocate skb! (%s@%d)\\n\",\n\t\t\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t\t\t\t__FILE__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdma_sync_single_for_cpu(&mpt_dev->pcidev->dev,\n\t\t\t\t\tpriv->RcvCtl[ctx].dma,\n\t\t\t\t\tpriv->RcvCtl[ctx].len,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\tskb_copy_from_linear_data(old_skb, skb_put(skb, len), len);\n\n\t\tdma_sync_single_for_device(&mpt_dev->pcidev->dev,\n\t\t\t\t\t   priv->RcvCtl[ctx].dma,\n\t\t\t\t\t   priv->RcvCtl[ctx].len,\n\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\tgoto out;\n\t}\n\n\tskb_put(skb, len);\n\n\tpriv->RcvCtl[ctx].skb = NULL;\n\n\tdma_unmap_single(&mpt_dev->pcidev->dev, priv->RcvCtl[ctx].dma,\n\t\t\t priv->RcvCtl[ctx].len, DMA_FROM_DEVICE);\n\nout:\n\tspin_lock_irqsave(&priv->rxfidx_lock, flags);\n\tpriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;\n\tspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\n\n\tatomic_dec(&priv->buckets_out);\n\tpriv->total_received++;\n\n\treturn mpt_lan_receive_skb(dev, skb);\n}\n\n \nstatic int\nmpt_lan_receive_post_free(struct net_device *dev,\n\t\t\t  LANReceivePostReply_t *pRecvRep)\n{\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\tMPT_ADAPTER *mpt_dev = priv->mpt_dev;\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tu32 ctx;\n\tint count;\n\tint i;\n\n\tcount = pRecvRep->NumberOfContexts;\n\n \tdlprintk((KERN_INFO MYNAM \"/receive_post_reply: \"\n\t\t  \"IOC returned %d buckets, freeing them...\\n\", count));\n\n\tspin_lock_irqsave(&priv->rxfidx_lock, flags);\n\tfor (i = 0; i < count; i++) {\n\t\tctx = le32_to_cpu(pRecvRep->BucketContext[i]);\n\n\t\tskb = priv->RcvCtl[ctx].skb;\n\n \n \n \n \n \n\n\t\tpriv->RcvCtl[ctx].skb = NULL;\n\t\tdma_unmap_single(&mpt_dev->pcidev->dev, priv->RcvCtl[ctx].dma,\n\t\t\t\t priv->RcvCtl[ctx].len, DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\n\t\tpriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;\n\t}\n\tspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\n\n\tatomic_sub(count, &priv->buckets_out);\n\n \n \n \n \n\n \n \tdlprintk((KERN_INFO MYNAM \"@receive_post_reply: %d buckets \"\n \t\t  \"remaining, %d received back since sod.\\n\",\n \t\t  atomic_read(&priv->buckets_out), priv->total_received));\n\treturn 0;\n}\n\n \nstatic int\nmpt_lan_receive_post_reply(struct net_device *dev,\n\t\t\t   LANReceivePostReply_t *pRecvRep)\n{\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\tMPT_ADAPTER *mpt_dev = priv->mpt_dev;\n\tstruct sk_buff *skb, *old_skb;\n\tunsigned long flags;\n\tu32 len, ctx, offset;\n\tu32 remaining = le32_to_cpu(pRecvRep->BucketsRemaining);\n\tint count;\n\tint i, l;\n\n\tdioprintk((KERN_INFO MYNAM \": mpt_lan_receive_post_reply called\\n\"));\n\tdioprintk((KERN_INFO MYNAM \": receive_post_reply: IOCStatus: %04x\\n\",\n\t\t le16_to_cpu(pRecvRep->IOCStatus)));\n\n\tif ((le16_to_cpu(pRecvRep->IOCStatus) & MPI_IOCSTATUS_MASK) ==\n\t\t\t\t\t\tMPI_IOCSTATUS_LAN_CANCELED)\n\t\treturn mpt_lan_receive_post_free(dev, pRecvRep);\n\n\tlen = le32_to_cpu(pRecvRep->PacketLength);\n\tif (len == 0) {\n\t\tprintk (KERN_ERR MYNAM \": %s/%s: ERROR - Got a non-TURBO \"\n\t\t\t\"ReceivePostReply w/ PacketLength zero!\\n\",\n\t\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev));\n\t\tprintk (KERN_ERR MYNAM \": MsgFlags = %02x, IOCStatus = %04x\\n\",\n\t\t\t\tpRecvRep->MsgFlags, le16_to_cpu(pRecvRep->IOCStatus));\n\t\treturn -1;\n\t}\n\n\tctx    = le32_to_cpu(pRecvRep->BucketContext[0]);\n\tcount  = pRecvRep->NumberOfContexts;\n\tskb    = priv->RcvCtl[ctx].skb;\n\n\toffset = le32_to_cpu(pRecvRep->PacketOffset);\n \n \n \n \n \n \n\n\tdioprintk((KERN_INFO MYNAM \": %s/%s: @rpr, offset = %d, len = %d\\n\",\n\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t\toffset, len));\n\n\tif (count > 1) {\n\t\tint szrem = len;\n\n \n \n \n\n\t\tskb = (struct sk_buff *)dev_alloc_skb(len);\n\t\tif (!skb) {\n\t\t\tprintk (KERN_ERR MYNAM \": %s/%s: ERROR - Can't allocate skb! (%s@%d)\\n\",\n\t\t\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t\t\t\t__FILE__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tspin_lock_irqsave(&priv->rxfidx_lock, flags);\n\t\tfor (i = 0; i < count; i++) {\n\n\t\t\tctx = le32_to_cpu(pRecvRep->BucketContext[i]);\n\t\t\told_skb = priv->RcvCtl[ctx].skb;\n\n\t\t\tl = priv->RcvCtl[ctx].len;\n\t\t\tif (szrem < l)\n\t\t\t\tl = szrem;\n\n \n \n \n\n\t\t\tdma_sync_single_for_cpu(&mpt_dev->pcidev->dev,\n\t\t\t\t\t\tpriv->RcvCtl[ctx].dma,\n\t\t\t\t\t\tpriv->RcvCtl[ctx].len,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\tskb_copy_from_linear_data(old_skb, skb_put(skb, l), l);\n\n\t\t\tdma_sync_single_for_device(&mpt_dev->pcidev->dev,\n\t\t\t\t\t\t   priv->RcvCtl[ctx].dma,\n\t\t\t\t\t\t   priv->RcvCtl[ctx].len,\n\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\t\tpriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;\n\t\t\tszrem -= l;\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\n\n\t} else if (len < MPT_LAN_RX_COPYBREAK) {\n\n\t\told_skb = skb;\n\n\t\tskb = (struct sk_buff *)dev_alloc_skb(len);\n\t\tif (!skb) {\n\t\t\tprintk (KERN_ERR MYNAM \": %s/%s: ERROR - Can't allocate skb! (%s@%d)\\n\",\n\t\t\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t\t\t\t__FILE__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdma_sync_single_for_cpu(&mpt_dev->pcidev->dev,\n\t\t\t\t\tpriv->RcvCtl[ctx].dma,\n\t\t\t\t\tpriv->RcvCtl[ctx].len,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\tskb_copy_from_linear_data(old_skb, skb_put(skb, len), len);\n\n\t\tdma_sync_single_for_device(&mpt_dev->pcidev->dev,\n\t\t\t\t\t   priv->RcvCtl[ctx].dma,\n\t\t\t\t\t   priv->RcvCtl[ctx].len,\n\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\tspin_lock_irqsave(&priv->rxfidx_lock, flags);\n\t\tpriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;\n\t\tspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\n\n\t} else {\n\t\tspin_lock_irqsave(&priv->rxfidx_lock, flags);\n\n\t\tpriv->RcvCtl[ctx].skb = NULL;\n\n\t\tdma_unmap_single(&mpt_dev->pcidev->dev, priv->RcvCtl[ctx].dma,\n\t\t\t\t priv->RcvCtl[ctx].len, DMA_FROM_DEVICE);\n\t\tpriv->RcvCtl[ctx].dma = 0;\n\n\t\tpriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;\n\t\tspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\n\n\t\tskb_put(skb,len);\n\t}\n\n\tatomic_sub(count, &priv->buckets_out);\n\tpriv->total_received += count;\n\n\tif (priv->mpt_rxfidx_tail >= MPT_LAN_MAX_BUCKETS_OUT) {\n\t\tprintk (KERN_ERR MYNAM \": %s/%s: Yoohoo! mpt_rxfidx_tail = %d, \"\n\t\t\t\"MPT_LAN_MAX_BUCKETS_OUT = %d\\n\",\n\t\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t\t\tpriv->mpt_rxfidx_tail,\n\t\t\t\tMPT_LAN_MAX_BUCKETS_OUT);\n\n\t\treturn -1;\n\t}\n\n\tif (remaining == 0)\n\t\tprintk (KERN_WARNING MYNAM \": %s/%s: WARNING - IOC out of buckets! \"\n\t\t\t\"(priv->buckets_out = %d)\\n\",\n\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t\tatomic_read(&priv->buckets_out));\n\telse if (remaining < 10)\n\t\tprintk (KERN_INFO MYNAM \": %s/%s: IOC says %d buckets left. \"\n\t\t\t\"(priv->buckets_out = %d)\\n\",\n\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t\tremaining, atomic_read(&priv->buckets_out));\n\t\n\tif ((remaining < priv->bucketthresh) &&\n\t    ((atomic_read(&priv->buckets_out) - remaining) >\n\t     MPT_LAN_BUCKETS_REMAIN_MISMATCH_THRESH)) {\n\t\t\n\t\tprintk (KERN_WARNING MYNAM \" Mismatch between driver's \"\n\t\t\t\"buckets_out count and fw's BucketsRemaining \"\n\t\t\t\"count has crossed the threshold, issuing a \"\n\t\t\t\"LanReset to clear the fw's hashtable. You may \"\n\t\t\t\"want to check your /var/log/messages for \\\"CRC \"\n\t\t\t\"error\\\" event notifications.\\n\");\n\t\t\n\t\tmpt_lan_reset(dev);\n\t\tmpt_lan_wake_post_buckets_task(dev, 0);\n\t}\n\t\n\treturn mpt_lan_receive_skb(dev, skb);\n}\n\n \n \n\nstatic void\nmpt_lan_post_receive_buckets(struct mpt_lan_priv *priv)\n{\n\tstruct net_device *dev = priv->dev;\n\tMPT_ADAPTER *mpt_dev = priv->mpt_dev;\n\tMPT_FRAME_HDR *mf;\n\tLANReceivePostRequest_t *pRecvReq;\n\tSGETransaction32_t *pTrans;\n\tSGESimple64_t *pSimple;\n\tstruct sk_buff *skb;\n\tdma_addr_t dma;\n\tu32 curr, buckets, count, max;\n\tu32 len = (dev->mtu + dev->hard_header_len + 4);\n\tunsigned long flags;\n\tint i;\n\n\tcurr = atomic_read(&priv->buckets_out);\n\tbuckets = (priv->max_buckets_out - curr);\n\n\tdioprintk((KERN_INFO MYNAM \": %s/%s: @%s, Start_buckets = %u, buckets_out = %u\\n\",\n\t\t\tIOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t\t__func__, buckets, curr));\n\n\tmax = (mpt_dev->req_sz - MPT_LAN_RECEIVE_POST_REQUEST_SIZE) /\n\t\t\t(sizeof(SGETransaction32_t) + sizeof(SGESimple64_t));\n\n\twhile (buckets) {\n\t\tmf = mpt_get_msg_frame(LanCtx, mpt_dev);\n\t\tif (mf == NULL) {\n\t\t\tprintk (KERN_ERR \"%s: Unable to alloc request frame\\n\",\n\t\t\t\t__func__);\n\t\t\tdioprintk((KERN_ERR \"%s: %u buckets remaining\\n\",\n\t\t\t\t __func__, buckets));\n\t\t\tgoto out;\n\t\t}\n\t\tpRecvReq = (LANReceivePostRequest_t *) mf;\n\n\t\ti = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\n\t\tmpt_dev->RequestNB[i] = 0;\n\t\tcount = buckets;\n\t\tif (count > max)\n\t\t\tcount = max;\n\n\t\tpRecvReq->Function    = MPI_FUNCTION_LAN_RECEIVE;\n\t\tpRecvReq->ChainOffset = 0;\n\t\tpRecvReq->MsgFlags    = 0;\n\t\tpRecvReq->PortNumber  = priv->pnum;\n\n\t\tpTrans = (SGETransaction32_t *) pRecvReq->SG_List;\n\t\tpSimple = NULL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint ctx;\n\n\t\t\tspin_lock_irqsave(&priv->rxfidx_lock, flags);\n\t\t\tif (priv->mpt_rxfidx_tail < 0) {\n\t\t\t\tprintk (KERN_ERR \"%s: Can't alloc context\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tspin_unlock_irqrestore(&priv->rxfidx_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tctx = priv->mpt_rxfidx[priv->mpt_rxfidx_tail--];\n\n\t\t\tskb = priv->RcvCtl[ctx].skb;\n\t\t\tif (skb && (priv->RcvCtl[ctx].len != len)) {\n\t\t\t\tdma_unmap_single(&mpt_dev->pcidev->dev,\n\t\t\t\t\t\t priv->RcvCtl[ctx].dma,\n\t\t\t\t\t\t priv->RcvCtl[ctx].len,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb(priv->RcvCtl[ctx].skb);\n\t\t\t\tskb = priv->RcvCtl[ctx].skb = NULL;\n\t\t\t}\n\n\t\t\tif (skb == NULL) {\n\t\t\t\tskb = dev_alloc_skb(len);\n\t\t\t\tif (skb == NULL) {\n\t\t\t\t\tprintk (KERN_WARNING\n\t\t\t\t\t\tMYNAM \"/%s: Can't alloc skb\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\t\tpriv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;\n\t\t\t\t\tspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdma = dma_map_single(&mpt_dev->pcidev->dev,\n\t\t\t\t\t\t     skb->data, len,\n\t\t\t\t\t\t     DMA_FROM_DEVICE);\n\n\t\t\t\tpriv->RcvCtl[ctx].skb = skb;\n\t\t\t\tpriv->RcvCtl[ctx].dma = dma;\n\t\t\t\tpriv->RcvCtl[ctx].len = len;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&priv->rxfidx_lock, flags);\n\n\t\t\tpTrans->ContextSize   = sizeof(u32);\n\t\t\tpTrans->DetailsLength = 0;\n\t\t\tpTrans->Flags         = 0;\n\t\t\tpTrans->TransactionContext = cpu_to_le32(ctx);\n\n\t\t\tpSimple = (SGESimple64_t *) pTrans->TransactionDetails;\n\n\t\t\tpSimple->FlagsLength = cpu_to_le32(\n\t\t\t\t((MPI_SGE_FLAGS_END_OF_BUFFER |\n\t\t\t\t  MPI_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t\t\t  MPI_SGE_FLAGS_64_BIT_ADDRESSING) << MPI_SGE_FLAGS_SHIFT) | len);\n\t\t\tpSimple->Address.Low = cpu_to_le32((u32) priv->RcvCtl[ctx].dma);\n\t\t\tif (sizeof(dma_addr_t) > sizeof(u32))\n\t\t\t\tpSimple->Address.High = cpu_to_le32((u32) ((u64) priv->RcvCtl[ctx].dma >> 32));\n\t\t\telse\n\t\t\t\tpSimple->Address.High = 0;\n\n\t\t\tpTrans = (SGETransaction32_t *) (pSimple + 1);\n\t\t}\n\n\t\tif (pSimple == NULL) {\n \t\t\tprintk (KERN_WARNING MYNAM \"/%s: No buckets posted\\n\",\n \t\t\t\t__func__);\n\t\t\tmpt_free_msg_frame(mpt_dev, mf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpSimple->FlagsLength |= cpu_to_le32(MPI_SGE_FLAGS_END_OF_LIST << MPI_SGE_FLAGS_SHIFT);\n\n\t\tpRecvReq->BucketCount = cpu_to_le32(i);\n\n \n\n\t\tmpt_put_msg_frame(LanCtx, mpt_dev, mf);\n\n\t\tpriv->total_posted += i;\n\t\tbuckets -= i;\n\t\tatomic_add(i, &priv->buckets_out);\n\t}\n\nout:\n\tdioprintk((KERN_INFO MYNAM \"/%s: End_buckets = %u, priv->buckets_out = %u\\n\",\n\t\t  __func__, buckets, atomic_read(&priv->buckets_out)));\n\tdioprintk((KERN_INFO MYNAM \"/%s: Posted %u buckets and received %u back\\n\",\n\t__func__, priv->total_posted, priv->total_received));\n\n\tclear_bit(0, &priv->post_buckets_active);\n}\n\nstatic void\nmpt_lan_post_receive_buckets_work(struct work_struct *work)\n{\n\tmpt_lan_post_receive_buckets(container_of(work, struct mpt_lan_priv,\n\t\t\t\t\t\t  post_buckets_task.work));\n}\n\nstatic const struct net_device_ops mpt_netdev_ops = {\n\t.ndo_open       = mpt_lan_open,\n\t.ndo_stop       = mpt_lan_close,\n\t.ndo_start_xmit = mpt_lan_sdu_send,\n\t.ndo_tx_timeout = mpt_lan_tx_timeout,\n};\n\n \nstatic struct net_device *\nmpt_register_lan_device (MPT_ADAPTER *mpt_dev, int pnum)\n{\n\tstruct net_device *dev;\n\tstruct mpt_lan_priv *priv;\n\tu8 HWaddr[FC_ALEN], *a;\n\n\tdev = alloc_fcdev(sizeof(struct mpt_lan_priv));\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev->mtu = MPT_LAN_MTU;\n\n\tpriv = netdev_priv(dev);\n\n\tpriv->dev = dev;\n\tpriv->mpt_dev = mpt_dev;\n\tpriv->pnum = pnum;\n\n\tINIT_DELAYED_WORK(&priv->post_buckets_task,\n\t\t\t  mpt_lan_post_receive_buckets_work);\n\tpriv->post_buckets_active = 0;\n\n\tdlprintk((KERN_INFO MYNAM \"@%d: bucketlen = %d\\n\",\n\t\t\t__LINE__, dev->mtu + dev->hard_header_len + 4));\n\n\tatomic_set(&priv->buckets_out, 0);\n\tpriv->total_posted = 0;\n\tpriv->total_received = 0;\n\tpriv->max_buckets_out = max_buckets_out;\n\tif (mpt_dev->pfacts[0].MaxLanBuckets < max_buckets_out)\n\t\tpriv->max_buckets_out = mpt_dev->pfacts[0].MaxLanBuckets;\n\n\tdlprintk((KERN_INFO MYNAM \"@%d: MaxLanBuckets=%d, max_buckets_out/priv=%d/%d\\n\",\n\t\t\t__LINE__,\n\t\t\tmpt_dev->pfacts[0].MaxLanBuckets,\n\t\t\tmax_buckets_out,\n\t\t\tpriv->max_buckets_out));\n\n\tpriv->bucketthresh = priv->max_buckets_out * 2 / 3;\n\tspin_lock_init(&priv->txfidx_lock);\n\tspin_lock_init(&priv->rxfidx_lock);\n\n\t \n\ta = (u8 *) &mpt_dev->lan_cnfg_page1.HardwareAddressLow;\n\n\tHWaddr[0] = a[5];\n\tHWaddr[1] = a[4];\n\tHWaddr[2] = a[3];\n\tHWaddr[3] = a[2];\n\tHWaddr[4] = a[1];\n\tHWaddr[5] = a[0];\n\n\tdev->addr_len = FC_ALEN;\n\tdev_addr_set(dev, HWaddr);\n\tmemset(dev->broadcast, 0xff, FC_ALEN);\n\n\t \n\tpriv->tx_max_out = (tx_max_out_p <= MPT_TX_MAX_OUT_LIM) ?\n\t\t\t    tx_max_out_p : MPT_TX_MAX_OUT_LIM;\n\n\tdev->netdev_ops = &mpt_netdev_ops;\n\tdev->watchdog_timeo = MPT_LAN_TX_TIMEOUT;\n\n\t \n\tdev->min_mtu = MPT_LAN_MIN_MTU;\n\tdev->max_mtu = MPT_LAN_MAX_MTU;\n\n\tdlprintk((KERN_INFO MYNAM \": Finished registering dev \"\n\t\t\"and setting initial values\\n\"));\n\n\tif (register_netdev(dev) != 0) {\n\t\tfree_netdev(dev);\n\t\tdev = NULL;\n\t}\n\treturn dev;\n}\n\nstatic int\nmptlan_probe(struct pci_dev *pdev)\n{\n\tMPT_ADAPTER \t\t*ioc = pci_get_drvdata(pdev);\n\tstruct net_device\t*dev;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < ioc->facts.NumberOfPorts; i++) {\n\t\tprintk(KERN_INFO MYNAM \": %s: PortNum=%x, \"\n\t\t       \"ProtocolFlags=%02Xh (%c%c%c%c)\\n\",\n\t\t       ioc->name, ioc->pfacts[i].PortNumber,\n\t\t       ioc->pfacts[i].ProtocolFlags,\n\t\t       MPT_PROTOCOL_FLAGS_c_c_c_c(\n\t\t\t       ioc->pfacts[i].ProtocolFlags));\n\n\t\tif (!(ioc->pfacts[i].ProtocolFlags &\n\t\t\t\t\tMPI_PORTFACTS_PROTOCOL_LAN)) {\n\t\t\tprintk(KERN_INFO MYNAM \": %s: Hmmm... LAN protocol \"\n\t\t\t       \"seems to be disabled on this adapter port!\\n\",\n\t\t\t       ioc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev = mpt_register_lan_device(ioc, i);\n\t\tif (!dev) {\n\t\t\tprintk(KERN_ERR MYNAM \": %s: Unable to register \"\n\t\t\t       \"port%d as a LAN device\\n\", ioc->name,\n\t\t\t       ioc->pfacts[i].PortNumber);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tprintk(KERN_INFO MYNAM \": %s: Fusion MPT LAN device \"\n\t\t       \"registered as '%s'\\n\", ioc->name, dev->name);\n\t\tprintk(KERN_INFO MYNAM \": %s/%s: \"\n\t\t       \"LanAddr = %pM\\n\",\n\t\t       IOC_AND_NETDEV_NAMES_s_s(dev),\n\t\t       dev->dev_addr);\n\t\n\t\tioc->netdev = dev;\n\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic void\nmptlan_remove(struct pci_dev *pdev)\n{\n\tMPT_ADAPTER \t\t*ioc = pci_get_drvdata(pdev);\n\tstruct net_device\t*dev = ioc->netdev;\n\tstruct mpt_lan_priv *priv = netdev_priv(dev);\n\n\tcancel_delayed_work_sync(&priv->post_buckets_task);\n\tif(dev != NULL) {\n\t\tunregister_netdev(dev);\n\t\tfree_netdev(dev);\n\t}\n}\n\nstatic struct mpt_pci_driver mptlan_driver = {\n\t.probe\t\t= mptlan_probe,\n\t.remove\t\t= mptlan_remove,\n};\n\nstatic int __init mpt_lan_init (void)\n{\n\tshow_mptmod_ver(LANAME, LANVER);\n\n\tLanCtx = mpt_register(lan_reply, MPTLAN_DRIVER,\n\t\t\t\t\"lan_reply\");\n\tif (LanCtx <= 0) {\n\t\tprintk (KERN_ERR MYNAM \": Failed to register with MPT base driver\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tdlprintk((KERN_INFO MYNAM \": assigned context of %d\\n\", LanCtx));\n\n\tif (mpt_reset_register(LanCtx, mpt_lan_ioc_reset)) {\n\t\tprintk(KERN_ERR MYNAM \": Eieee! unable to register a reset \"\n\t\t       \"handler with mptbase! The world is at an end! \"\n\t\t       \"Everything is fading to black! Goodbye.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tdlprintk((KERN_INFO MYNAM \": Registered for IOC reset notifications\\n\"));\n\t\n\tmpt_device_driver_register(&mptlan_driver, MPTLAN_DRIVER);\n\treturn 0;\n}\n\nstatic void __exit mpt_lan_exit(void)\n{\n\tmpt_device_driver_deregister(MPTLAN_DRIVER);\n\tmpt_reset_deregister(LanCtx);\n\n\tif (LanCtx) {\n\t\tmpt_deregister(LanCtx);\n\t\tLanCtx = MPT_MAX_PROTOCOL_DRIVERS;\n\t}\n}\n\nmodule_init(mpt_lan_init);\nmodule_exit(mpt_lan_exit);\n\n \nstatic unsigned short\nmpt_lan_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct mpt_lan_ohdr *fch = (struct mpt_lan_ohdr *)skb->data;\n\tstruct fcllc *fcllc;\n\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, sizeof(struct mpt_lan_ohdr));\n\n\tif (fch->dtype == htons(0xffff)) {\n\t\tu32 *p = (u32 *) fch;\n\n\t\tswab32s(p + 0);\n\t\tswab32s(p + 1);\n\t\tswab32s(p + 2);\n\t\tswab32s(p + 3);\n\n\t\tprintk (KERN_WARNING MYNAM \": %s: WARNING - Broadcast swap F/W bug detected!\\n\",\n\t\t\t\tNETDEV_PTR_TO_IOC_NAME_s(dev));\n\t\tprintk (KERN_WARNING MYNAM \": Please update sender @ MAC_addr = %pM\\n\",\n\t\t\t\tfch->saddr);\n\t}\n\n\tif (*fch->daddr & 1) {\n\t\tif (!memcmp(fch->daddr, dev->broadcast, FC_ALEN)) {\n\t\t\tskb->pkt_type = PACKET_BROADCAST;\n\t\t} else {\n\t\t\tskb->pkt_type = PACKET_MULTICAST;\n\t\t}\n\t} else {\n\t\tif (memcmp(fch->daddr, dev->dev_addr, FC_ALEN)) {\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t} else {\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\t}\n\t}\n\n\tfcllc = (struct fcllc *)skb->data;\n\n\t \n\tif (fcllc->dsap == EXTENDED_SAP &&\n\t\t(fcllc->ethertype == htons(ETH_P_IP) ||\n\t\t fcllc->ethertype == htons(ETH_P_ARP))) {\n\t\tskb_pull(skb, sizeof(struct fcllc));\n\t\treturn fcllc->ethertype;\n\t}\n\n\treturn htons(ETH_P_802_2);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}