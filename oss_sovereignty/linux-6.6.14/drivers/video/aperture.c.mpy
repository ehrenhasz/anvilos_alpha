{
  "module_name": "aperture.c",
  "hash_id": "272b4294b3cf1a1bfb0fd84fcbef8c6ce2f97ce67cc16adf088b4f30f68d0c66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/aperture.c",
  "human_readable_source": "\n\n#include <linux/aperture.h>\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sysfb.h>\n#include <linux/types.h>\n#include <linux/vgaarb.h>\n\n#include <video/vga.h>\n\n \n\nstruct aperture_range {\n\tstruct device *dev;\n\tresource_size_t base;\n\tresource_size_t size;\n\tstruct list_head lh;\n\tvoid (*detach)(struct device *dev);\n};\n\nstatic LIST_HEAD(apertures);\nstatic DEFINE_MUTEX(apertures_lock);\n\nstatic bool overlap(resource_size_t base1, resource_size_t end1,\n\t\t    resource_size_t base2, resource_size_t end2)\n{\n\treturn (base1 < end2) && (end1 > base2);\n}\n\nstatic void devm_aperture_acquire_release(void *data)\n{\n\tstruct aperture_range *ap = data;\n\tbool detached = !ap->dev;\n\n\tif (detached)\n\t\treturn;\n\n\tmutex_lock(&apertures_lock);\n\tlist_del(&ap->lh);\n\tmutex_unlock(&apertures_lock);\n}\n\nstatic int devm_aperture_acquire(struct device *dev,\n\t\t\t\t resource_size_t base, resource_size_t size,\n\t\t\t\t void (*detach)(struct device *))\n{\n\tsize_t end = base + size;\n\tstruct list_head *pos;\n\tstruct aperture_range *ap;\n\n\tmutex_lock(&apertures_lock);\n\n\tlist_for_each(pos, &apertures) {\n\t\tap = container_of(pos, struct aperture_range, lh);\n\t\tif (overlap(base, end, ap->base, ap->base + ap->size)) {\n\t\t\tmutex_unlock(&apertures_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tap = devm_kzalloc(dev, sizeof(*ap), GFP_KERNEL);\n\tif (!ap) {\n\t\tmutex_unlock(&apertures_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tap->dev = dev;\n\tap->base = base;\n\tap->size = size;\n\tap->detach = detach;\n\tINIT_LIST_HEAD(&ap->lh);\n\n\tlist_add(&ap->lh, &apertures);\n\n\tmutex_unlock(&apertures_lock);\n\n\treturn devm_add_action_or_reset(dev, devm_aperture_acquire_release, ap);\n}\n\nstatic void aperture_detach_platform_device(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\t \n\tplatform_device_unregister(pdev);\n}\n\n \nint devm_aperture_acquire_for_platform_device(struct platform_device *pdev,\n\t\t\t\t\t      resource_size_t base,\n\t\t\t\t\t      resource_size_t size)\n{\n\treturn devm_aperture_acquire(&pdev->dev, base, size, aperture_detach_platform_device);\n}\nEXPORT_SYMBOL(devm_aperture_acquire_for_platform_device);\n\nstatic void aperture_detach_devices(resource_size_t base, resource_size_t size)\n{\n\tresource_size_t end = base + size;\n\tstruct list_head *pos, *n;\n\n\tmutex_lock(&apertures_lock);\n\n\tlist_for_each_safe(pos, n, &apertures) {\n\t\tstruct aperture_range *ap = container_of(pos, struct aperture_range, lh);\n\t\tstruct device *dev = ap->dev;\n\n\t\tif (WARN_ON_ONCE(!dev))\n\t\t\tcontinue;\n\n\t\tif (!overlap(base, end, ap->base, ap->base + ap->size))\n\t\t\tcontinue;\n\n\t\tap->dev = NULL;  \n\t\tlist_del(&ap->lh);\n\n\t\tap->detach(dev);\n\t}\n\n\tmutex_unlock(&apertures_lock);\n}\n\n \nint aperture_remove_conflicting_devices(resource_size_t base, resource_size_t size,\n\t\t\t\t\tconst char *name)\n{\n\t \n\tsysfb_disable();\n\n\taperture_detach_devices(base, size);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(aperture_remove_conflicting_devices);\n\n \nint __aperture_remove_legacy_vga_devices(struct pci_dev *pdev)\n{\n\t \n\taperture_detach_devices(VGA_FB_PHYS_BASE, VGA_FB_PHYS_SIZE);\n\n\t \n\treturn vga_remove_vgacon(pdev);\n}\nEXPORT_SYMBOL(__aperture_remove_legacy_vga_devices);\n\n \nint aperture_remove_conflicting_pci_devices(struct pci_dev *pdev, const char *name)\n{\n\tbool primary = false;\n\tresource_size_t base, size;\n\tint bar, ret = 0;\n\n\tif (pdev == vga_default_device())\n\t\tprimary = true;\n\n\tif (primary)\n\t\tsysfb_disable();\n\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; ++bar) {\n\t\tif (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM))\n\t\t\tcontinue;\n\n\t\tbase = pci_resource_start(pdev, bar);\n\t\tsize = pci_resource_len(pdev, bar);\n\t\taperture_detach_devices(base, size);\n\t}\n\n\t \n\tif (primary)\n\t\tret = __aperture_remove_legacy_vga_devices(pdev);\n\n\treturn ret;\n\n}\nEXPORT_SYMBOL(aperture_remove_conflicting_pci_devices);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}