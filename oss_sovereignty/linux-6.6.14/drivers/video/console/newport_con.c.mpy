{
  "module_name": "newport_con.c",
  "hash_id": "faa551ec35064b294d73b251c19304b82767e5f173fecd19cba30eb665a23567",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/console/newport_con.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/kd.h>\n#include <linux/selection.h>\n#include <linux/console.h>\n#include <linux/vt_kern.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <asm/page.h>\n#include <asm/gio_device.h>\n\n#include <video/newport.h>\n\n#include <linux/linux_logo.h>\n#include <linux/font.h>\n\n#define NEWPORT_LEN\t0x10000\n\n#define FONT_DATA ((unsigned char *)font_vga_8x16.data)\n\nstatic unsigned char *font_data[MAX_NR_CONSOLES];\n\nstatic struct newport_regs *npregs;\nstatic unsigned long newport_addr;\n\nstatic int logo_active;\nstatic int topscan;\nstatic int xcurs_correction = 29;\nstatic int newport_xsize;\nstatic int newport_ysize;\nstatic int newport_has_init;\n\nstatic int newport_set_def_font(int unit, struct console_font *op);\n\n#define BMASK(c) (c << 24)\n\n#define RENDER(regs, cp) do { \\\n(regs)->go.zpattern = BMASK((cp)[0x0]); (regs)->go.zpattern = BMASK((cp)[0x1]); \\\n(regs)->go.zpattern = BMASK((cp)[0x2]); (regs)->go.zpattern = BMASK((cp)[0x3]); \\\n(regs)->go.zpattern = BMASK((cp)[0x4]); (regs)->go.zpattern = BMASK((cp)[0x5]); \\\n(regs)->go.zpattern = BMASK((cp)[0x6]); (regs)->go.zpattern = BMASK((cp)[0x7]); \\\n(regs)->go.zpattern = BMASK((cp)[0x8]); (regs)->go.zpattern = BMASK((cp)[0x9]); \\\n(regs)->go.zpattern = BMASK((cp)[0xa]); (regs)->go.zpattern = BMASK((cp)[0xb]); \\\n(regs)->go.zpattern = BMASK((cp)[0xc]); (regs)->go.zpattern = BMASK((cp)[0xd]); \\\n(regs)->go.zpattern = BMASK((cp)[0xe]); (regs)->go.zpattern = BMASK((cp)[0xf]); \\\n} while(0)\n\n#define TESTVAL 0xdeadbeef\n#define XSTI_TO_FXSTART(val) (((val) & 0xffff) << 11)\n\nstatic inline void newport_render_background(int xstart, int ystart,\n\t\t\t\t\t     int xend, int yend, int ci)\n{\n\tnewport_wait(npregs);\n\tnpregs->set.wrmask = 0xffffffff;\n\tnpregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |\n\t\t\t\t NPORT_DMODE0_DOSETUP | NPORT_DMODE0_STOPX\n\t\t\t\t | NPORT_DMODE0_STOPY);\n\tnpregs->set.colori = ci;\n\tnpregs->set.xystarti =\n\t    (xstart << 16) | ((ystart + topscan) & 0x3ff);\n\tnpregs->go.xyendi =\n\t    ((xend + 7) << 16) | ((yend + topscan + 15) & 0x3ff);\n}\n\nstatic inline void newport_init_cmap(void)\n{\n\tunsigned short i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tnewport_bfwait(npregs);\n\t\tnewport_cmap_setaddr(npregs, color_table[i]);\n\t\tnewport_cmap_setrgb(npregs,\n\t\t\t\t    default_red[i],\n\t\t\t\t    default_grn[i], default_blu[i]);\n\t}\n}\n\nstatic const struct linux_logo *newport_show_logo(void)\n{\n#ifdef CONFIG_LOGO_SGI_CLUT224\n\tconst struct linux_logo *logo = fb_find_logo(8);\n\tconst unsigned char *clut;\n\tconst unsigned char *data;\n\tunsigned long i;\n\n\tif (!logo)\n\t\treturn NULL;\n\tclut = logo->clut;\n\tdata = logo->data;\n\n\tfor (i = 0; i < logo->clutsize; i++) {\n\t\tnewport_bfwait(npregs);\n\t\tnewport_cmap_setaddr(npregs, i + 0x20);\n\t\tnewport_cmap_setrgb(npregs, clut[0], clut[1], clut[2]);\n\t\tclut += 3;\n\t}\n\n\tnewport_wait(npregs);\n\tnpregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |\n\t\t\t\t NPORT_DMODE0_CHOST);\n\n\tnpregs->set.xystarti = ((newport_xsize - logo->width) << 16) | (0);\n\tnpregs->set.xyendi = ((newport_xsize - 1) << 16);\n\tnewport_wait(npregs);\n\n\tfor (i = 0; i < logo->width*logo->height; i++)\n\t\tnpregs->go.hostrw0 = *data++ << 24;\n\n\treturn logo;\n#else\n\treturn NULL;\n#endif  \n}\n\nstatic inline void newport_clear_screen(int xstart, int ystart, int xend,\n\t\t\t\t\tint yend, int ci)\n{\n\tif (logo_active)\n\t\treturn;\n\n\tnewport_wait(npregs);\n\tnpregs->set.wrmask = 0xffffffff;\n\tnpregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |\n\t\t\t\t NPORT_DMODE0_DOSETUP | NPORT_DMODE0_STOPX\n\t\t\t\t | NPORT_DMODE0_STOPY);\n\tnpregs->set.colori = ci;\n\tnpregs->set.xystarti = (xstart << 16) | ystart;\n\tnpregs->go.xyendi = (xend << 16) | yend;\n}\n\nstatic inline void newport_clear_lines(int ystart, int yend, int ci)\n{\n\tystart = ((ystart << 4) + topscan) & 0x3ff;\n\tyend = ((yend << 4) + topscan + 15) & 0x3ff;\n\tnewport_clear_screen(0, ystart, 1280 + 63, yend, ci);\n}\n\nstatic void newport_reset(void)\n{\n\tunsigned short treg;\n\tint i;\n\n\tnewport_wait(npregs);\n\ttreg = newport_vc2_get(npregs, VC2_IREG_CONTROL);\n\tnewport_vc2_set(npregs, VC2_IREG_CONTROL,\n\t\t\t(treg | VC2_CTRL_EVIDEO));\n\n\ttreg = newport_vc2_get(npregs, VC2_IREG_CENTRY);\n\tnewport_vc2_set(npregs, VC2_IREG_RADDR, treg);\n\tnpregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |\n\t\t\t       NPORT_DMODE_W2 | VC2_PROTOCOL);\n\tfor (i = 0; i < 128; i++) {\n\t\tnewport_bfwait(npregs);\n\t\tif (i == 92 || i == 94)\n\t\t\tnpregs->set.dcbdata0.byshort.s1 = 0xff00;\n\t\telse\n\t\t\tnpregs->set.dcbdata0.byshort.s1 = 0x0000;\n\t}\n\n\tnewport_init_cmap();\n\n\t \n\tnpregs->set.dcbmode = (DCB_XMAP0 | R_DCB_XMAP9_PROTOCOL |\n\t\t\t       XM9_CRS_CONFIG | NPORT_DMODE_W1);\n\tnpregs->set.dcbdata0.bybytes.b3 &= ~XM9_PUPMODE;\n\tnpregs->set.dcbmode = (DCB_XMAP1 | R_DCB_XMAP9_PROTOCOL |\n\t\t\t       XM9_CRS_CONFIG | NPORT_DMODE_W1);\n\tnpregs->set.dcbdata0.bybytes.b3 &= ~XM9_PUPMODE;\n\n\ttopscan = 0;\n\tnpregs->cset.topscan = 0x3ff;\n\tnpregs->cset.xywin = (4096 << 16) | 4096;\n\n\t \n\tnewport_clear_screen(0, 0, 1280 + 63, 1024, 0);\n}\n\n \nstatic void newport_get_screensize(void)\n{\n\tint i, cols;\n\tunsigned short ventry, treg;\n\tunsigned short linetable[128];\t \n\n\tventry = newport_vc2_get(npregs, VC2_IREG_VENTRY);\n\tnewport_vc2_set(npregs, VC2_IREG_RADDR, ventry);\n\tnpregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |\n\t\t\t       NPORT_DMODE_W2 | VC2_PROTOCOL);\n\tfor (i = 0; i < 128; i++) {\n\t\tnewport_bfwait(npregs);\n\t\tlinetable[i] = npregs->set.dcbdata0.byshort.s1;\n\t}\n\n\tnewport_xsize = newport_ysize = 0;\n\tfor (i = 0; i < ARRAY_SIZE(linetable) - 1 && linetable[i + 1]; i += 2) {\n\t\tcols = 0;\n\t\tnewport_vc2_set(npregs, VC2_IREG_RADDR, linetable[i]);\n\t\tnpregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |\n\t\t\t\t       NPORT_DMODE_W2 | VC2_PROTOCOL);\n\t\tdo {\n\t\t\tnewport_bfwait(npregs);\n\t\t\ttreg = npregs->set.dcbdata0.byshort.s1;\n\t\t\tif ((treg & 1) == 0)\n\t\t\t\tcols += (treg >> 7) & 0xfe;\n\t\t\tif ((treg & 0x80) == 0) {\n\t\t\t\tnewport_bfwait(npregs);\n\t\t\t\ttreg = npregs->set.dcbdata0.byshort.s1;\n\t\t\t}\n\t\t} while ((treg & 0x8000) == 0);\n\t\tif (cols) {\n\t\t\tif (cols > newport_xsize)\n\t\t\t\tnewport_xsize = cols;\n\t\t\tnewport_ysize += linetable[i + 1];\n\t\t}\n\t}\n\tprintk(\"NG1: Screensize %dx%d\\n\", newport_xsize, newport_ysize);\n}\n\nstatic void newport_get_revisions(void)\n{\n\tunsigned int tmp;\n\tunsigned int board_rev;\n\tunsigned int rex3_rev;\n\tunsigned int vc2_rev;\n\tunsigned int cmap_rev;\n\tunsigned int xmap9_rev;\n\tunsigned int bt445_rev;\n\tunsigned int bitplanes;\n\n\trex3_rev = npregs->cset.status & NPORT_STAT_VERS;\n\n\tnpregs->set.dcbmode = (DCB_CMAP0 | NCMAP_PROTOCOL |\n\t\t\t       NCMAP_REGADDR_RREG | NPORT_DMODE_W1);\n\ttmp = npregs->set.dcbdata0.bybytes.b3;\n\tcmap_rev = tmp & 7;\n\tboard_rev = (tmp >> 4) & 7;\n\tbitplanes = ((board_rev > 1) && (tmp & 0x80)) ? 8 : 24;\n\n\tnpregs->set.dcbmode = (DCB_CMAP1 | NCMAP_PROTOCOL |\n\t\t\t       NCMAP_REGADDR_RREG | NPORT_DMODE_W1);\n\ttmp = npregs->set.dcbdata0.bybytes.b3;\n\tif ((tmp & 7) < cmap_rev)\n\t\tcmap_rev = (tmp & 7);\n\n\tvc2_rev = (newport_vc2_get(npregs, VC2_IREG_CONFIG) >> 5) & 7;\n\n\tnpregs->set.dcbmode = (DCB_XMAP0 | R_DCB_XMAP9_PROTOCOL |\n\t\t\t       XM9_CRS_REVISION | NPORT_DMODE_W1);\n\txmap9_rev = npregs->set.dcbdata0.bybytes.b3 & 7;\n\n\tnpregs->set.dcbmode = (DCB_BT445 | BT445_PROTOCOL |\n\t\t\t       BT445_CSR_ADDR_REG | NPORT_DMODE_W1);\n\tnpregs->set.dcbdata0.bybytes.b3 = BT445_REVISION_REG;\n\tnpregs->set.dcbmode = (DCB_BT445 | BT445_PROTOCOL |\n\t\t\t       BT445_CSR_REVISION | NPORT_DMODE_W1);\n\tbt445_rev = (npregs->set.dcbdata0.bybytes.b3 >> 4) - 0x0a;\n\n#define L(a)     (char)('A'+(a))\n\tprintk\n\t    (\"NG1: Revision %d, %d bitplanes, REX3 revision %c, VC2 revision %c, xmap9 revision %c, cmap revision %c, bt445 revision %c\\n\",\n\t     board_rev, bitplanes, L(rex3_rev), L(vc2_rev), L(xmap9_rev),\n\t     L(cmap_rev ? (cmap_rev + 1) : 0), L(bt445_rev));\n#undef L\n\n\tif (board_rev == 3)\t \n\t\txcurs_correction = 21;\n}\n\nstatic void newport_exit(void)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < MAX_NR_CONSOLES; i++)\n\t\tnewport_set_def_font(i, NULL);\n}\n\n \nstatic const char *newport_startup(void)\n{\n\tint i;\n\n\tnpregs->cset.config = NPORT_CFG_GD0;\n\n\tif (newport_wait(npregs))\n\t\tgoto out_unmap;\n\n\tnpregs->set.xstarti = TESTVAL;\n\tif (npregs->set._xstart.word != XSTI_TO_FXSTART(TESTVAL))\n\t\tgoto out_unmap;\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++)\n\t\tfont_data[i] = FONT_DATA;\n\n\tnewport_reset();\n\tnewport_get_revisions();\n\tnewport_get_screensize();\n\tnewport_has_init = 1;\n\n\treturn \"SGI Newport\";\n\nout_unmap:\n\treturn NULL;\n}\n\nstatic void newport_init(struct vc_data *vc, int init)\n{\n\tint cols, rows;\n\n\tcols = newport_xsize / 8;\n\trows = newport_ysize / 16;\n\tvc->vc_can_do_color = 1;\n\tif (init) {\n\t\tvc->vc_cols = cols;\n\t\tvc->vc_rows = rows;\n\t} else\n\t\tvc_resize(vc, cols, rows);\n}\n\nstatic void newport_deinit(struct vc_data *c)\n{\n\tif (!con_is_bound(&newport_con) && newport_has_init) {\n\t\tnewport_exit();\n\t\tnewport_has_init = 0;\n\t}\n}\n\nstatic void newport_clear(struct vc_data *vc, int sy, int sx, int height,\n\t\t\t  int width)\n{\n\tint xend = ((sx + width) << 3) - 1;\n\tint ystart = ((sy << 4) + topscan) & 0x3ff;\n\tint yend = (((sy + height) << 4) + topscan - 1) & 0x3ff;\n\n\tif (logo_active)\n\t\treturn;\n\n\tif (ystart < yend) {\n\t\tnewport_clear_screen(sx << 3, ystart, xend, yend,\n\t\t\t\t     (vc->state.color & 0xf0) >> 4);\n\t} else {\n\t\tnewport_clear_screen(sx << 3, ystart, xend, 1023,\n\t\t\t\t     (vc->state.color & 0xf0) >> 4);\n\t\tnewport_clear_screen(sx << 3, 0, xend, yend,\n\t\t\t\t     (vc->state.color & 0xf0) >> 4);\n\t}\n}\n\nstatic void newport_putc(struct vc_data *vc, int charattr, int ypos,\n\t\t\t int xpos)\n{\n\tunsigned char *p;\n\n\tp = &font_data[vc->vc_num][(charattr & 0xff) << 4];\n\tcharattr = (charattr >> 8) & 0xff;\n\txpos <<= 3;\n\typos <<= 4;\n\n\tnewport_render_background(xpos, ypos, xpos, ypos,\n\t\t\t\t  (charattr & 0xf0) >> 4);\n\n\t \n\tnewport_wait(npregs);\n\tnpregs->set.colori = charattr & 0xf;\n\tnpregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |\n\t\t\t\t NPORT_DMODE0_STOPX | NPORT_DMODE0_ZPENAB |\n\t\t\t\t NPORT_DMODE0_L32);\n\n\t \n\tnpregs->set.xystarti = (xpos << 16) | ((ypos + topscan) & 0x3ff);\n\tnpregs->set.xyendi = ((xpos + 7) << 16);\n\tnewport_wait(npregs);\n\n\t \n\tRENDER(npregs, p);\n}\n\nstatic void newport_putcs(struct vc_data *vc, const unsigned short *s,\n\t\t\t  int count, int ypos, int xpos)\n{\n\tint i;\n\tint charattr;\n\tunsigned char *p;\n\n\tcharattr = (scr_readw(s) >> 8) & 0xff;\n\n\txpos <<= 3;\n\typos <<= 4;\n\n\tif (!logo_active)\n\t\t \n\t\tnewport_render_background(xpos, ypos,\n\t\t\t\t\t  xpos + ((count - 1) << 3), ypos,\n\t\t\t\t\t  (charattr & 0xf0) >> 4);\n\n\tnewport_wait(npregs);\n\n\t \n\tnpregs->set.colori = charattr & 0xf;\n\tnpregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |\n\t\t\t\t NPORT_DMODE0_STOPX | NPORT_DMODE0_ZPENAB |\n\t\t\t\t NPORT_DMODE0_L32);\n\n\tfor (i = 0; i < count; i++, xpos += 8) {\n\t\tp = &font_data[vc->vc_num][(scr_readw(s++) & 0xff) << 4];\n\n\t\tnewport_wait(npregs);\n\n\t\t \n\t\tnpregs->set.xystarti =\n\t\t    (xpos << 16) | ((ypos + topscan) & 0x3ff);\n\t\tnpregs->set.xyendi = ((xpos + 7) << 16);\n\n\t\t \n\t\tRENDER(npregs, p);\n\t}\n}\n\nstatic void newport_cursor(struct vc_data *vc, int mode)\n{\n\tunsigned short treg;\n\tint xcurs, ycurs;\n\n\tswitch (mode) {\n\tcase CM_ERASE:\n\t\ttreg = newport_vc2_get(npregs, VC2_IREG_CONTROL);\n\t\tnewport_vc2_set(npregs, VC2_IREG_CONTROL,\n\t\t\t\t(treg & ~(VC2_CTRL_ECDISP)));\n\t\tbreak;\n\n\tcase CM_MOVE:\n\tcase CM_DRAW:\n\t\ttreg = newport_vc2_get(npregs, VC2_IREG_CONTROL);\n\t\tnewport_vc2_set(npregs, VC2_IREG_CONTROL,\n\t\t\t\t(treg | VC2_CTRL_ECDISP));\n\t\txcurs = (vc->vc_pos - vc->vc_visible_origin) / 2;\n\t\tycurs = ((xcurs / vc->vc_cols) << 4) + 31;\n\t\txcurs = ((xcurs % vc->vc_cols) << 3) + xcurs_correction;\n\t\tnewport_vc2_set(npregs, VC2_IREG_CURSX, xcurs);\n\t\tnewport_vc2_set(npregs, VC2_IREG_CURSY, ycurs);\n\t}\n}\n\nstatic int newport_switch(struct vc_data *vc)\n{\n\tstatic int logo_drawn = 0;\n\n\ttopscan = 0;\n\tnpregs->cset.topscan = 0x3ff;\n\n\tif (!logo_drawn) {\n\t\tif (newport_show_logo()) {\n\t\t\tlogo_drawn = 1;\n\t\t\tlogo_active = 1;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int newport_blank(struct vc_data *c, int blank, int mode_switch)\n{\n\tunsigned short treg;\n\n\tif (blank == 0) {\n\t\t \n\t\ttreg = newport_vc2_get(npregs, VC2_IREG_CONTROL);\n\t\tnewport_vc2_set(npregs, VC2_IREG_CONTROL,\n\t\t\t\t(treg | VC2_CTRL_EDISP));\n\t} else {\n\t\t \n\t\ttreg = newport_vc2_get(npregs, VC2_IREG_CONTROL);\n\t\tnewport_vc2_set(npregs, VC2_IREG_CONTROL,\n\t\t\t\t(treg & ~(VC2_CTRL_EDISP)));\n\t}\n\treturn 1;\n}\n\nstatic int newport_set_font(int unit, struct console_font *op, unsigned int vpitch)\n{\n\tint w = op->width;\n\tint h = op->height;\n\tint size = h * op->charcount;\n\tint i;\n\tunsigned char *new_data, *data = op->data, *p;\n\n\t \n\tif ((w != 8) || (h != 16) || (vpitch != 32)\n\t    || (op->charcount != 256 && op->charcount != 512))\n\t\treturn -EINVAL;\n\n\tif (!(new_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size,\n\t     GFP_USER))) return -ENOMEM;\n\n\tnew_data += FONT_EXTRA_WORDS * sizeof(int);\n\tFNTSIZE(new_data) = size;\n\tFNTCHARCNT(new_data) = op->charcount;\n\tREFCOUNT(new_data) = 0;\t \n\tFNTSUM(new_data) = 0;\n\n\tp = new_data;\n\tfor (i = 0; i < op->charcount; i++) {\n\t\tmemcpy(p, data, h);\n\t\tdata += 32;\n\t\tp += h;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\tif (font_data[i] != FONT_DATA\n\t\t    && FNTSIZE(font_data[i]) == size\n\t\t    && !memcmp(font_data[i], new_data, size)) {\n\t\t\tkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\n\t\t\t \n\t\t\tif (i == unit)\n\t\t\t\treturn 0;\n\t\t\tnew_data = font_data[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (font_data[unit] != FONT_DATA) {\n\t\tif (--REFCOUNT(font_data[unit]) == 0)\n\t\t\tkfree(font_data[unit] -\n\t\t\t      FONT_EXTRA_WORDS * sizeof(int));\n\t}\n\tREFCOUNT(new_data)++;\n\tfont_data[unit] = new_data;\n\n\treturn 0;\n}\n\nstatic int newport_set_def_font(int unit, struct console_font *op)\n{\n\tif (font_data[unit] != FONT_DATA) {\n\t\tif (--REFCOUNT(font_data[unit]) == 0)\n\t\t\tkfree(font_data[unit] -\n\t\t\t      FONT_EXTRA_WORDS * sizeof(int));\n\t\tfont_data[unit] = FONT_DATA;\n\t}\n\n\treturn 0;\n}\n\nstatic int newport_font_default(struct vc_data *vc, struct console_font *op, char *name)\n{\n\treturn newport_set_def_font(vc->vc_num, op);\n}\n\nstatic int newport_font_set(struct vc_data *vc, struct console_font *font,\n\t\t\t    unsigned int vpitch, unsigned int flags)\n{\n\treturn newport_set_font(vc->vc_num, font, vpitch);\n}\n\nstatic bool newport_scroll(struct vc_data *vc, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tint count, x, y;\n\tunsigned short *s, *d;\n\tunsigned short chattr;\n\n\tlogo_active = 0;\t \n\n\tif (t == 0 && b == vc->vc_rows) {\n\t\tif (dir == SM_UP) {\n\t\t\ttopscan = (topscan + (lines << 4)) & 0x3ff;\n\t\t\tnewport_clear_lines(vc->vc_rows - lines,\n\t\t\t\t\t    vc->vc_rows - 1,\n\t\t\t\t\t    (vc->state.color & 0xf0) >> 4);\n\t\t} else {\n\t\t\ttopscan = (topscan + (-lines << 4)) & 0x3ff;\n\t\t\tnewport_clear_lines(0, lines - 1,\n\t\t\t\t\t    (vc->state.color & 0xf0) >> 4);\n\t\t}\n\t\tnpregs->cset.topscan = (topscan - 1) & 0x3ff;\n\t\treturn false;\n\t}\n\n\tcount = (b - t - lines) * vc->vc_cols;\n\tif (dir == SM_UP) {\n\t\tx = 0;\n\t\ty = t;\n\t\ts = (unsigned short *) (vc->vc_origin +\n\t\t\t\t\tvc->vc_size_row * (t + lines));\n\t\td = (unsigned short *) (vc->vc_origin +\n\t\t\t\t\tvc->vc_size_row * t);\n\t\twhile (count--) {\n\t\t\tchattr = scr_readw(s++);\n\t\t\tif (chattr != scr_readw(d)) {\n\t\t\t\tnewport_putc(vc, chattr, y, x);\n\t\t\t\tscr_writew(chattr, d);\n\t\t\t}\n\t\t\td++;\n\t\t\tif (++x == vc->vc_cols) {\n\t\t\t\tx = 0;\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t\td = (unsigned short *) (vc->vc_origin +\n\t\t\t\t\tvc->vc_size_row * (b - lines));\n\t\tx = 0;\n\t\ty = b - lines;\n\t\tfor (count = 0; count < (lines * vc->vc_cols); count++) {\n\t\t\tif (scr_readw(d) != vc->vc_video_erase_char) {\n\t\t\t\tnewport_putc(vc, vc->vc_video_erase_char,\n\t\t\t\t\t     y, x);\n\t\t\t\tscr_writew(vc->vc_video_erase_char, d);\n\t\t\t}\n\t\t\td++;\n\t\t\tif (++x == vc->vc_cols) {\n\t\t\t\tx = 0;\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tx = vc->vc_cols - 1;\n\t\ty = b - 1;\n\t\ts = (unsigned short *) (vc->vc_origin +\n\t\t\t\t\tvc->vc_size_row * (b - lines) - 2);\n\t\td = (unsigned short *) (vc->vc_origin +\n\t\t\t\t\tvc->vc_size_row * b - 2);\n\t\twhile (count--) {\n\t\t\tchattr = scr_readw(s--);\n\t\t\tif (chattr != scr_readw(d)) {\n\t\t\t\tnewport_putc(vc, chattr, y, x);\n\t\t\t\tscr_writew(chattr, d);\n\t\t\t}\n\t\t\td--;\n\t\t\tif (x-- == 0) {\n\t\t\t\tx = vc->vc_cols - 1;\n\t\t\t\ty--;\n\t\t\t}\n\t\t}\n\t\td = (unsigned short *) (vc->vc_origin +\n\t\t\t\t\tvc->vc_size_row * t);\n\t\tx = 0;\n\t\ty = t;\n\t\tfor (count = 0; count < (lines * vc->vc_cols); count++) {\n\t\t\tif (scr_readw(d) != vc->vc_video_erase_char) {\n\t\t\t\tnewport_putc(vc, vc->vc_video_erase_char,\n\t\t\t\t\t     y, x);\n\t\t\t\tscr_writew(vc->vc_video_erase_char, d);\n\t\t\t}\n\t\t\td++;\n\t\t\tif (++x == vc->vc_cols) {\n\t\t\t\tx = 0;\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void newport_save_screen(struct vc_data *vc) { }\n\nconst struct consw newport_con = {\n\t.owner\t\t  = THIS_MODULE,\n\t.con_startup\t  = newport_startup,\n\t.con_init\t  = newport_init,\n\t.con_deinit\t  = newport_deinit,\n\t.con_clear\t  = newport_clear,\n\t.con_putc\t  = newport_putc,\n\t.con_putcs\t  = newport_putcs,\n\t.con_cursor\t  = newport_cursor,\n\t.con_scroll\t  = newport_scroll,\n\t.con_switch\t  = newport_switch,\n\t.con_blank\t  = newport_blank,\n\t.con_font_set\t  = newport_font_set,\n\t.con_font_default = newport_font_default,\n\t.con_save_screen  = newport_save_screen\n};\n\nstatic int newport_probe(struct gio_device *dev,\n\t\t\t const struct gio_device_id *id)\n{\n\tint err;\n\n\tif (!dev->resource.start)\n\t\treturn -EINVAL;\n\n\tif (npregs)\n\t\treturn -EBUSY;  \n\n\tnewport_addr = dev->resource.start + 0xF0000;\n\tif (!request_mem_region(newport_addr, NEWPORT_LEN, \"Newport\"))\n\t\treturn -ENODEV;\n\n\tnpregs = (struct newport_regs *) \n\t\tioremap(newport_addr, sizeof(struct newport_regs));\n\tconsole_lock();\n\terr = do_take_over_console(&newport_con, 0, MAX_NR_CONSOLES - 1, 1);\n\tconsole_unlock();\n\n\tif (err) {\n\t\tiounmap((void *)npregs);\n\t\trelease_mem_region(newport_addr, NEWPORT_LEN);\n\t}\n\treturn err;\n}\n\nstatic void newport_remove(struct gio_device *dev)\n{\n\tgive_up_console(&newport_con);\n\tiounmap((void *)npregs);\n\trelease_mem_region(newport_addr, NEWPORT_LEN);\n}\n\nstatic struct gio_device_id newport_ids[] = {\n\t{ .id = 0x7e },\n\t{ .id = 0xff }\n};\n\nMODULE_ALIAS(\"gio:7e\");\n\nstatic struct gio_driver newport_driver = {\n\t.name = \"newport\",\n\t.id_table = newport_ids,\n\t.probe = newport_probe,\n\t.remove = newport_remove,\n};\nmodule_driver(newport_driver, gio_register_driver, gio_unregister_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}