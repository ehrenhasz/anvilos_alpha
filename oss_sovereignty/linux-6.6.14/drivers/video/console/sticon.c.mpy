{
  "module_name": "sticon.c",
  "hash_id": "e22737a0a70a7ba1576c72b845028e7d3cb30dd7cf050e757e307425981682bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/console/sticon.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/console.h>\n#include <linux/errno.h>\n#include <linux/vt_kern.h>\n#include <linux/kd.h>\n#include <linux/selection.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/font.h>\n#include <linux/crc32.h>\n#include <linux/fb.h>\n\n#include <asm/io.h>\n\n#include <video/sticore.h>\n\n \n#define BLANK 0\nstatic int vga_is_gfx;\n\n#define STI_DEF_FONT\tsticon_sti->font\n\n \n#define FNTREFCOUNT(fd)\t(fd->refcount)\n#define FNTCRC(fd)\t(fd->crc)\nstatic struct sti_cooked_font *font_data[MAX_NR_CONSOLES];\n\n \nstatic struct sti_struct *sticon_sti;\n\nstatic const char *sticon_startup(void)\n{\n    return \"STI console\";\n}\n\nstatic void sticon_putc(struct vc_data *conp, int c, int ypos, int xpos)\n{\n    if (vga_is_gfx || console_blanked)\n\t    return;\n\n    if (conp->vc_mode != KD_TEXT)\n    \t    return;\n\n    sti_putc(sticon_sti, c, ypos, xpos, font_data[conp->vc_num]);\n}\n\nstatic void sticon_putcs(struct vc_data *conp, const unsigned short *s,\n\t\t\t int count, int ypos, int xpos)\n{\n    if (vga_is_gfx || console_blanked)\n\t    return;\n\n    if (conp->vc_mode != KD_TEXT)\n    \t    return;\n\n    while (count--) {\n\tsti_putc(sticon_sti, scr_readw(s++), ypos, xpos++,\n\t\t font_data[conp->vc_num]);\n    }\n}\n\nstatic void sticon_cursor(struct vc_data *conp, int mode)\n{\n    unsigned short car1;\n\n     \n    if (vga_is_gfx || console_blanked)\n\treturn;\n\n    car1 = conp->vc_screenbuf[conp->state.x + conp->state.y * conp->vc_cols];\n    switch (mode) {\n    case CM_ERASE:\n\tsti_putc(sticon_sti, car1, conp->state.y, conp->state.x,\n\t\t font_data[conp->vc_num]);\n\tbreak;\n    case CM_MOVE:\n    case CM_DRAW:\n\tswitch (CUR_SIZE(conp->vc_cursor_type)) {\n\tcase CUR_UNDERLINE:\n\tcase CUR_LOWER_THIRD:\n\tcase CUR_LOWER_HALF:\n\tcase CUR_TWO_THIRDS:\n\tcase CUR_BLOCK:\n\t    sti_putc(sticon_sti, (car1 & 255) + (0 << 8) + (7 << 11),\n\t\t     conp->state.y, conp->state.x, font_data[conp->vc_num]);\n\t    break;\n\t}\n\tbreak;\n    }\n}\n\nstatic bool sticon_scroll(struct vc_data *conp, unsigned int t,\n\t\tunsigned int b, enum con_scroll dir, unsigned int count)\n{\n    struct sti_struct *sti = sticon_sti;\n\n    if (vga_is_gfx)\n        return false;\n\n    sticon_cursor(conp, CM_ERASE);\n\n    switch (dir) {\n    case SM_UP:\n\tsti_bmove(sti, t + count, 0, t, 0, b - t - count, conp->vc_cols,\n\t\t  font_data[conp->vc_num]);\n\tsti_clear(sti, b - count, 0, count, conp->vc_cols,\n\t\t  conp->vc_video_erase_char, font_data[conp->vc_num]);\n\tbreak;\n\n    case SM_DOWN:\n\tsti_bmove(sti, t, 0, t + count, 0, b - t - count, conp->vc_cols,\n\t\t  font_data[conp->vc_num]);\n\tsti_clear(sti, t, 0, count, conp->vc_cols,\n\t\t  conp->vc_video_erase_char, font_data[conp->vc_num]);\n\tbreak;\n    }\n\n    return false;\n}\n\nstatic void sticon_set_def_font(int unit)\n{\n\tif (font_data[unit] != STI_DEF_FONT) {\n\t\tif (--FNTREFCOUNT(font_data[unit]) == 0) {\n\t\t\tkfree(font_data[unit]->raw_ptr);\n\t\t\tkfree(font_data[unit]);\n\t\t}\n\t\tfont_data[unit] = STI_DEF_FONT;\n\t}\n}\n\nstatic int sticon_set_font(struct vc_data *vc, struct console_font *op,\n\t\t\t   unsigned int vpitch)\n{\n\tstruct sti_struct *sti = sticon_sti;\n\tint vc_cols, vc_rows, vc_old_cols, vc_old_rows;\n\tint unit = vc->vc_num;\n\tint w = op->width;\n\tint h = op->height;\n\tint size, i, bpc, pitch;\n\tstruct sti_rom_font *new_font;\n\tstruct sti_cooked_font *cooked_font;\n\tunsigned char *data = op->data, *p;\n\n\tif ((w < 6) || (h < 6) || (w > 32) || (h > 32) || (vpitch != 32)\n\t    || (op->charcount != 256 && op->charcount != 512))\n\t\treturn -EINVAL;\n\tpitch = ALIGN(w, 8) / 8;\n\tbpc = pitch * h;\n\tsize = bpc * op->charcount;\n\n\tnew_font = kmalloc(sizeof(*new_font) + size, STI_LOWMEM);\n\tif (!new_font)\n\t\treturn -ENOMEM;\n\n\tnew_font->first_char = 0;\n\tnew_font->last_char = op->charcount - 1;\n\tnew_font->width = w;\n\tnew_font->height = h;\n\tnew_font->font_type = STI_FONT_HPROMAN8;\n\tnew_font->bytes_per_char = bpc;\n\tnew_font->underline_height = 0;\n\tnew_font->underline_pos = 0;\n\n\tcooked_font = kzalloc(sizeof(*cooked_font), GFP_KERNEL);\n\tif (!cooked_font) {\n\t\tkfree(new_font);\n\t\treturn -ENOMEM;\n\t}\n\tcooked_font->raw = new_font;\n\tcooked_font->raw_ptr = new_font;\n\tcooked_font->width = w;\n\tcooked_font->height = h;\n\tFNTREFCOUNT(cooked_font) = 0;\t \n\n\tp = (unsigned char *) new_font;\n\tp += sizeof(*new_font);\n\tfor (i = 0; i < op->charcount; i++) {\n\t\tmemcpy(p, data, bpc);\n\t\tdata += pitch*32;\n\t\tp += bpc;\n\t}\n\tFNTCRC(cooked_font) = crc32(0, new_font, size + sizeof(*new_font));\n\tsti_font_convert_bytemode(sti, cooked_font);\n\tnew_font = cooked_font->raw_ptr;\n\n\t \n\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\tif (font_data[i] != STI_DEF_FONT\n\t\t    && (FNTCRC(font_data[i]) == FNTCRC(cooked_font))) {\n\t\t\tkfree(new_font);\n\t\t\tkfree(cooked_font);\n\t\t\t \n\t\t\tif (i == unit)\n\t\t\t\treturn 0;\n\t\t\tcooked_font = font_data[i];\n\t\t\tnew_font = cooked_font->raw_ptr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tvc_old_rows = vc->vc_rows;\n\tvc_old_cols = vc->vc_cols;\n\tsti_clear(sticon_sti, 0, 0, vc_old_rows, vc_old_cols,\n\t\t  vc->vc_video_erase_char, font_data[vc->vc_num]);\n\n\t \n\tsticon_set_def_font(unit);\n\n\tFNTREFCOUNT(cooked_font)++;\n\tfont_data[unit] = cooked_font;\n\n\tvc_cols = sti_onscreen_x(sti) / cooked_font->width;\n\tvc_rows = sti_onscreen_y(sti) / cooked_font->height;\n\tvc_resize(vc, vc_cols, vc_rows);\n\n\t \n\tif (vc_cols == vc_old_cols && vc_rows == vc_old_rows)\n\t\tupdate_screen(vc);\n\n\treturn 0;\n}\n\nstatic int sticon_font_default(struct vc_data *vc, struct console_font *op, char *name)\n{\n\tsticon_set_def_font(vc->vc_num);\n\n\treturn 0;\n}\n\nstatic int sticon_font_set(struct vc_data *vc, struct console_font *font,\n\t\t\t   unsigned int vpitch, unsigned int flags)\n{\n\treturn sticon_set_font(vc, font, vpitch);\n}\n\nstatic void sticon_init(struct vc_data *c, int init)\n{\n    struct sti_struct *sti = sticon_sti;\n    int vc_cols, vc_rows;\n\n    sti_set(sti, 0, 0, sti_onscreen_y(sti), sti_onscreen_x(sti), 0);\n    vc_cols = sti_onscreen_x(sti) / sti->font->width;\n    vc_rows = sti_onscreen_y(sti) / sti->font->height;\n    c->vc_can_do_color = 1;\n\n    if (init) {\n\tc->vc_cols = vc_cols;\n\tc->vc_rows = vc_rows;\n    } else {\n\tvc_resize(c, vc_cols, vc_rows);\n    }\n}\n\nstatic void sticon_deinit(struct vc_data *c)\n{\n    int i;\n\n     \n    for (i = 0; i < MAX_NR_CONSOLES; i++)\n\tsticon_set_def_font(i);\n}\n\nstatic void sticon_clear(struct vc_data *conp, int sy, int sx, int height,\n\t\t\t int width)\n{\n    if (!height || !width)\n\treturn;\n\n    sti_clear(sticon_sti, sy, sx, height, width,\n\t      conp->vc_video_erase_char, font_data[conp->vc_num]);\n}\n\nstatic int sticon_switch(struct vc_data *conp)\n{\n    return 1;\t \n}\n\nstatic int sticon_blank(struct vc_data *c, int blank, int mode_switch)\n{\n    if (blank == 0) {\n\tif (mode_switch)\n\t    vga_is_gfx = 0;\n\treturn 1;\n    }\n    sti_clear(sticon_sti, 0, 0, c->vc_rows, c->vc_cols, BLANK,\n\t      font_data[c->vc_num]);\n    if (mode_switch)\n\tvga_is_gfx = 1;\n    return 1;\n}\n\nstatic u8 sticon_build_attr(struct vc_data *conp, u8 color,\n\t\t\t    enum vc_intensity intens,\n\t\t\t    bool blink, bool underline, bool reverse,\n\t\t\t    bool italic)\n{\n\tu8 fg = color & 7;\n\tu8 bg = (color & 0x70) >> 4;\n\n\tif (reverse)\n\t\treturn (fg << 3) | bg;\n\telse\n\t\treturn (bg << 3) | fg;\n}\n\nstatic void sticon_invert_region(struct vc_data *conp, u16 *p, int count)\n{\n    int col = 1;  \n\n    while (count--) {\n\tu16 a = scr_readw(p);\n\n\tif (col)\n\t\ta = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) | (((a) & 0x0700) << 4);\n\telse\n\t\ta = ((a & 0x0700) == 0x0100) ? 0x7000 : 0x7700;\n\n\tscr_writew(a, p++);\n    }\n}\n\nstatic const struct consw sti_con = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.con_startup\t\t= sticon_startup,\n\t.con_init\t\t= sticon_init,\n\t.con_deinit\t\t= sticon_deinit,\n\t.con_clear\t\t= sticon_clear,\n\t.con_putc\t\t= sticon_putc,\n\t.con_putcs\t\t= sticon_putcs,\n\t.con_cursor\t\t= sticon_cursor,\n\t.con_scroll\t\t= sticon_scroll,\n\t.con_switch\t\t= sticon_switch,\n\t.con_blank\t\t= sticon_blank,\n\t.con_font_set\t\t= sticon_font_set,\n\t.con_font_default\t= sticon_font_default,\n\t.con_build_attr\t\t= sticon_build_attr,\n\t.con_invert_region\t= sticon_invert_region,\n};\n\n\n\nstatic int __init sticonsole_init(void)\n{\n    int err, i;\n\n     \n    if (sticon_sti)\n\t return 0;\n\n    sticon_sti = sti_get_rom(0);\n    if (!sticon_sti)\n\treturn -ENODEV;\n\n    for (i = 0; i < MAX_NR_CONSOLES; i++)\n\tfont_data[i] = STI_DEF_FONT;\n\n    pr_info(\"sticon: Initializing STI text console on %s at [%s]\\n\",\n\tsticon_sti->sti_data->inq_outptr.dev_name,\n\tsticon_sti->pa_path);\n    console_lock();\n    err = do_take_over_console(&sti_con, 0, MAX_NR_CONSOLES - 1,\n\t\tPAGE0->mem_cons.cl_class != CL_DUPLEX);\n    console_unlock();\n\n    return err;\n}\n\nmodule_init(sticonsole_init);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}