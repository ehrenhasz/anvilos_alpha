{
  "module_name": "mdacon.c",
  "hash_id": "e2bc7377058176e18f5ca3ca6ccc0c2913e3f0d0dd2f8e04e23907e4d98a3154",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/console/mdacon.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/string.h>\n#include <linux/kd.h>\n#include <linux/vt_kern.h>\n#include <linux/vt_buffer.h>\n#include <linux/selection.h>\n#include <linux/spinlock.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n\n#include <asm/io.h>\n#include <asm/vga.h>\n\nstatic DEFINE_SPINLOCK(mda_lock);\n\n \n\nstatic u16\t\t*mda_vram_base;\t\t \nstatic unsigned long\tmda_vram_len;\t\t \nstatic unsigned int\tmda_num_columns;\t \nstatic unsigned int\tmda_num_lines;\t\t \n\nstatic unsigned int\tmda_index_port;\t\t \nstatic unsigned int\tmda_value_port;\t\t \nstatic unsigned int\tmda_mode_port;\t\t \nstatic unsigned int\tmda_status_port;\t \nstatic unsigned int\tmda_gfx_port;\t\t \n\n \n\nstatic int\tmda_cursor_loc=-1;\nstatic int\tmda_cursor_size_from=-1;\nstatic int\tmda_cursor_size_to=-1;\n\nstatic enum { TYPE_MDA, TYPE_HERC, TYPE_HERCPLUS, TYPE_HERCCOLOR } mda_type;\nstatic char *mda_type_name;\n\n \n\nstatic int\tmda_first_vc = 13;\nstatic int\tmda_last_vc  = 16;\n\nstatic struct vc_data\t*mda_display_fg = NULL;\n\nmodule_param(mda_first_vc, int, 0);\nMODULE_PARM_DESC(mda_first_vc, \"First virtual console. Default: 13\");\nmodule_param(mda_last_vc, int, 0);\nMODULE_PARM_DESC(mda_last_vc, \"Last virtual console. Default: 16\");\n\n \n\n#define MDA_CURSOR_BLINKING\t0x00\n#define MDA_CURSOR_OFF\t\t0x20\n#define MDA_CURSOR_SLOWBLINK\t0x60\n\n#define MDA_MODE_GRAPHICS\t0x02\n#define MDA_MODE_VIDEO_EN\t0x08\n#define MDA_MODE_BLINK_EN\t0x20\n#define MDA_MODE_GFX_PAGE1\t0x80\n\n#define MDA_STATUS_HSYNC\t0x01\n#define MDA_STATUS_VSYNC\t0x80\n#define MDA_STATUS_VIDEO\t0x08\n\n#define MDA_CONFIG_COL132\t0x08\n#define MDA_GFX_MODE_EN\t\t0x01\n#define MDA_GFX_PAGE_EN\t\t0x02\n\n\n \n\nstatic void write_mda_b(unsigned int val, unsigned char reg)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mda_lock, flags);\t\n\n\toutb_p(reg, mda_index_port); \n\toutb_p(val, mda_value_port);\n\n\tspin_unlock_irqrestore(&mda_lock, flags);\n}\n\nstatic void write_mda_w(unsigned int val, unsigned char reg)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mda_lock, flags);\n\n\toutb_p(reg,   mda_index_port); outb_p(val >> 8,   mda_value_port);\n\toutb_p(reg+1, mda_index_port); outb_p(val & 0xff, mda_value_port);\n\n\tspin_unlock_irqrestore(&mda_lock, flags);\n}\n\n#ifdef TEST_MDA_B\nstatic int test_mda_b(unsigned char val, unsigned char reg)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mda_lock, flags);\n\n\toutb_p(reg, mda_index_port); \n\toutb  (val, mda_value_port);\n\n\tudelay(20); val = (inb_p(mda_value_port) == val);\n\n\tspin_unlock_irqrestore(&mda_lock, flags);\n\treturn val;\n}\n#endif\n\nstatic inline void mda_set_cursor(unsigned int location) \n{\n\tif (mda_cursor_loc == location)\n\t\treturn;\n\n\twrite_mda_w(location >> 1, 0x0e);\n\n\tmda_cursor_loc = location;\n}\n\nstatic inline void mda_set_cursor_size(int from, int to)\n{\n\tif (mda_cursor_size_from==from && mda_cursor_size_to==to)\n\t\treturn;\n\t\n\tif (from > to) {\n\t\twrite_mda_b(MDA_CURSOR_OFF, 0x0a);\t \n\t} else {\n\t\twrite_mda_b(from, 0x0a);\t \n\t\twrite_mda_b(to,   0x0b);\t \n\t}\n\n\tmda_cursor_size_from = from;\n\tmda_cursor_size_to   = to;\n}\n\n\n#ifndef MODULE\nstatic int __init mdacon_setup(char *str)\n{\n\t \n\n\tint ints[3];\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\n\tif (ints[0] < 2)\n\t\treturn 0;\n\n\tif (ints[1] < 1 || ints[1] > MAX_NR_CONSOLES || \n\t    ints[2] < 1 || ints[2] > MAX_NR_CONSOLES)\n\t\treturn 0;\n\n\tmda_first_vc = ints[1];\n\tmda_last_vc  = ints[2];\n\treturn 1;\n}\n\n__setup(\"mdacon=\", mdacon_setup);\n#endif\n\nstatic int mda_detect(void)\n{\n\tint count=0;\n\tu16 *p, p_save;\n\tu16 *q, q_save;\n\n\t \n\n\tp = mda_vram_base;\n\tq = mda_vram_base + 0x01000 / 2;\n\n\tp_save = scr_readw(p);\n\tq_save = scr_readw(q);\n\n\tscr_writew(0xAA55, p);\n\tif (scr_readw(p) == 0xAA55)\n\t\tcount++;\n\n\tscr_writew(0x55AA, p);\n\tif (scr_readw(p) == 0x55AA)\n\t\tcount++;\n\n\tscr_writew(p_save, p);\n\n\tif (count != 2) {\n\t\treturn 0;\n\t}\n\n\t \n\n\tscr_writew(0xA55A, q);\n\tscr_writew(0x0000, p);\n\tif (scr_readw(q) == 0xA55A)\n\t\tcount++;\n\t\n\tscr_writew(0x5AA5, q);\n\tscr_writew(0x0000, p);\n\tif (scr_readw(q) == 0x5AA5)\n\t\tcount++;\n\n\tscr_writew(p_save, p);\n\tscr_writew(q_save, q);\n\t\n\tif (count == 4) {\n\t\tmda_vram_len = 0x02000;\n\t}\n\t\n\t \n\n#ifdef TEST_MDA_B\n\t \n\n\t \n\tif (!test_mda_b(0x66, 0x0f))\n\t\treturn 0;\n\n\t \n\tif (!test_mda_b(0x99, 0x0f))\n\t\treturn 0;\n#endif\n\n\t \n\t\n\tp_save = q_save = inb_p(mda_status_port) & MDA_STATUS_VSYNC;\n\n\tfor (count = 0; count < 50000 && p_save == q_save; count++) {\n\t\tq_save = inb(mda_status_port) & MDA_STATUS_VSYNC;\n\t\tudelay(2);\n\t}\n\n\tif (p_save != q_save) {\n\t\tswitch (inb_p(mda_status_port) & 0x70) {\n\t\tcase 0x10:\n\t\t\tmda_type = TYPE_HERCPLUS;\n\t\t\tmda_type_name = \"HerculesPlus\";\n\t\t\tbreak;\n\t\tcase 0x50:\n\t\t\tmda_type = TYPE_HERCCOLOR;\n\t\t\tmda_type_name = \"HerculesColor\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmda_type = TYPE_HERC;\n\t\t\tmda_type_name = \"Hercules\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic void mda_initialize(void)\n{\n\twrite_mda_b(97, 0x00);\t\t \n\twrite_mda_b(80, 0x01);\t\t \n\twrite_mda_b(82, 0x02);\t\t \n\twrite_mda_b(15, 0x03);\t\t \n\n\twrite_mda_b(25, 0x04);\t\t \n\twrite_mda_b(6,  0x05);\t\t \n\twrite_mda_b(25, 0x06);\t\t \n\twrite_mda_b(25, 0x07);\t\t \n\n\twrite_mda_b(2,  0x08);\t\t \n\twrite_mda_b(13, 0x09);\t\t \n\twrite_mda_b(12, 0x0a);\t\t \n\twrite_mda_b(13, 0x0b);\t\t \n\n\twrite_mda_w(0x0000, 0x0c);\t \n\twrite_mda_w(0x0000, 0x0e);\t \n\n\toutb_p(MDA_MODE_VIDEO_EN | MDA_MODE_BLINK_EN, mda_mode_port);\n\toutb_p(0x00, mda_status_port);\n\toutb_p(0x00, mda_gfx_port);\n}\n\nstatic const char *mdacon_startup(void)\n{\n\tmda_num_columns = 80;\n\tmda_num_lines   = 25;\n\n\tmda_vram_len  = 0x01000;\n\tmda_vram_base = (u16 *)VGA_MAP_MEM(0xb0000, mda_vram_len);\n\n\tmda_index_port  = 0x3b4;\n\tmda_value_port  = 0x3b5;\n\tmda_mode_port   = 0x3b8;\n\tmda_status_port = 0x3ba;\n\tmda_gfx_port    = 0x3bf;\n\n\tmda_type = TYPE_MDA;\n\tmda_type_name = \"MDA\";\n\n\tif (! mda_detect()) {\n\t\tprintk(\"mdacon: MDA card not detected.\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (mda_type != TYPE_MDA) {\n\t\tmda_initialize();\n\t}\n\n\t \n\tmda_set_cursor(mda_vram_len - 1);\n\n\tprintk(\"mdacon: %s with %ldK of memory detected.\\n\",\n\t\tmda_type_name, mda_vram_len/1024);\n\n\treturn \"MDA-2\";\n}\n\nstatic void mdacon_init(struct vc_data *c, int init)\n{\n\tc->vc_complement_mask = 0x0800;\t  \n\tc->vc_display_fg = &mda_display_fg;\n\n\tif (init) {\n\t\tc->vc_cols = mda_num_columns;\n\t\tc->vc_rows = mda_num_lines;\n\t} else\n\t\tvc_resize(c, mda_num_columns, mda_num_lines);\n\n\t \n\n\tif (mda_display_fg == NULL)\n\t\tmda_display_fg = c;\n}\n\nstatic void mdacon_deinit(struct vc_data *c)\n{\n\t \n\n\tif (mda_display_fg == c)\n\t\tmda_display_fg = NULL;\n}\n\nstatic inline u16 mda_convert_attr(u16 ch)\n{\n\tu16 attr = 0x0700;\n\n\t \n\n\tif (ch & 0x0800)\tattr = 0x7000;\t \n\telse if (ch & 0x0400)\tattr = 0x0100;\t \n\n\treturn ((ch & 0x0200) << 2) | \t\t  \n\t\t(ch & 0x8000) |\t\t\t  \n\t\t(ch & 0x00ff) | attr;\n}\n\nstatic u8 mdacon_build_attr(struct vc_data *c, u8 color,\n\t\t\t    enum vc_intensity intensity,\n\t\t\t    bool blink, bool underline, bool reverse,\n\t\t\t    bool italic)\n{\n\t \n\n\treturn (intensity & VCI_MASK) |\n\t\t(underline << 2) |\n\t\t(reverse << 3) |\n\t\t(italic << 4) |\n\t\t(blink << 7);\n}\n\nstatic void mdacon_invert_region(struct vc_data *c, u16 *p, int count)\n{\n\tfor (; count > 0; count--) {\n\t\tscr_writew(scr_readw(p) ^ 0x0800, p);\n\t\tp++;\n\t}\n}\n\nstatic inline u16 *mda_addr(unsigned int x, unsigned int y)\n{\n\treturn mda_vram_base + y * mda_num_columns + x;\n}\n\nstatic void mdacon_putc(struct vc_data *c, int ch, int y, int x)\n{\n\tscr_writew(mda_convert_attr(ch), mda_addr(x, y));\n}\n\nstatic void mdacon_putcs(struct vc_data *c, const unsigned short *s,\n\t\t         int count, int y, int x)\n{\n\tu16 *dest = mda_addr(x, y);\n\n\tfor (; count > 0; count--) {\n\t\tscr_writew(mda_convert_attr(scr_readw(s++)), dest++);\n\t}\n}\n\nstatic void mdacon_clear(struct vc_data *c, int y, int x, \n\t\t\t  int height, int width)\n{\n\tu16 *dest = mda_addr(x, y);\n\tu16 eattr = mda_convert_attr(c->vc_video_erase_char);\n\n\tif (width <= 0 || height <= 0)\n\t\treturn;\n\n\tif (x==0 && width==mda_num_columns) {\n\t\tscr_memsetw(dest, eattr, height*width*2);\n\t} else {\n\t\tfor (; height > 0; height--, dest+=mda_num_columns)\n\t\t\tscr_memsetw(dest, eattr, width*2);\n\t}\n}\n                        \nstatic int mdacon_switch(struct vc_data *c)\n{\n\treturn 1;\t \n}\n\nstatic int mdacon_blank(struct vc_data *c, int blank, int mode_switch)\n{\n\tif (mda_type == TYPE_MDA) {\n\t\tif (blank) \n\t\t\tscr_memsetw(mda_vram_base,\n\t\t\t\tmda_convert_attr(c->vc_video_erase_char),\n\t\t\t\tc->vc_screenbuf_size);\n\t\t \n\t\treturn 1;\n\t} else {\n\t\tif (blank)\n\t\t\toutb_p(0x00, mda_mode_port);\t \n\t\telse\n\t\t\toutb_p(MDA_MODE_VIDEO_EN | MDA_MODE_BLINK_EN, \n\t\t\t\tmda_mode_port);\n\t\treturn 0;\n\t}\n}\n\nstatic void mdacon_cursor(struct vc_data *c, int mode)\n{\n\tif (mode == CM_ERASE) {\n\t\tmda_set_cursor(mda_vram_len - 1);\n\t\treturn;\n\t}\n\n\tmda_set_cursor(c->state.y * mda_num_columns * 2 + c->state.x * 2);\n\n\tswitch (CUR_SIZE(c->vc_cursor_type)) {\n\n\t\tcase CUR_LOWER_THIRD:\tmda_set_cursor_size(10, 13); break;\n\t\tcase CUR_LOWER_HALF:\tmda_set_cursor_size(7,  13); break;\n\t\tcase CUR_TWO_THIRDS:\tmda_set_cursor_size(4,  13); break;\n\t\tcase CUR_BLOCK:\t\tmda_set_cursor_size(1,  13); break;\n\t\tcase CUR_NONE:\t\tmda_set_cursor_size(14, 13); break;\n\t\tdefault:\t\tmda_set_cursor_size(12, 13); break;\n\t}\n}\n\nstatic bool mdacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tu16 eattr = mda_convert_attr(c->vc_video_erase_char);\n\n\tif (!lines)\n\t\treturn false;\n\n\tif (lines > c->vc_rows)    \n\t\tlines = c->vc_rows;\n\n\tswitch (dir) {\n\n\tcase SM_UP:\n\t\tscr_memmovew(mda_addr(0, t), mda_addr(0, t + lines),\n\t\t\t\t(b-t-lines)*mda_num_columns*2);\n\t\tscr_memsetw(mda_addr(0, b - lines), eattr,\n\t\t\t\tlines*mda_num_columns*2);\n\t\tbreak;\n\n\tcase SM_DOWN:\n\t\tscr_memmovew(mda_addr(0, t + lines), mda_addr(0, t),\n\t\t\t\t(b-t-lines)*mda_num_columns*2);\n\t\tscr_memsetw(mda_addr(0, t), eattr, lines*mda_num_columns*2);\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n\n \n\nstatic const struct consw mda_con = {\n\t.owner =\t\tTHIS_MODULE,\n\t.con_startup =\t\tmdacon_startup,\n\t.con_init =\t\tmdacon_init,\n\t.con_deinit =\t\tmdacon_deinit,\n\t.con_clear =\t\tmdacon_clear,\n\t.con_putc =\t\tmdacon_putc,\n\t.con_putcs =\t\tmdacon_putcs,\n\t.con_cursor =\t\tmdacon_cursor,\n\t.con_scroll =\t\tmdacon_scroll,\n\t.con_switch =\t\tmdacon_switch,\n\t.con_blank =\t\tmdacon_blank,\n\t.con_build_attr =\tmdacon_build_attr,\n\t.con_invert_region =\tmdacon_invert_region,\n};\n\nint __init mda_console_init(void)\n{\n\tint err;\n\n\tif (mda_first_vc > mda_last_vc)\n\t\treturn 1;\n\tconsole_lock();\n\terr = do_take_over_console(&mda_con, mda_first_vc-1, mda_last_vc-1, 0);\n\tconsole_unlock();\n\treturn err;\n}\n\nstatic void __exit mda_console_exit(void)\n{\n\tgive_up_console(&mda_con);\n}\n\nmodule_init(mda_console_init);\nmodule_exit(mda_console_exit);\n\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}