{
  "module_name": "vgacon.c",
  "hash_id": "b1696c60385dc47bb09f6954358ce612542cb8e4157d467e5b56d994a5cad22b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/console/vgacon.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/console.h>\n#include <linux/string.h>\n#include <linux/kd.h>\n#include <linux/slab.h>\n#include <linux/vt_kern.h>\n#include <linux/sched.h>\n#include <linux/selection.h>\n#include <linux/spinlock.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/screen_info.h>\n#include <video/vga.h>\n#include <asm/io.h>\n\nstatic DEFINE_RAW_SPINLOCK(vga_lock);\nstatic int cursor_size_lastfrom;\nstatic int cursor_size_lastto;\nstatic u32 vgacon_xres;\nstatic u32 vgacon_yres;\nstatic struct vgastate vgastate;\n\n#define BLANK 0x0020\n\n#define VGA_FONTWIDTH       8    \n \n\nstatic int vgacon_set_origin(struct vc_data *c);\n\nstatic struct uni_pagedict *vgacon_uni_pagedir;\nstatic int vgacon_refcount;\n\n \nstatic unsigned long\tvga_vram_base\t\t__read_mostly;\t \nstatic unsigned long\tvga_vram_end\t\t__read_mostly;\t \nstatic unsigned int\tvga_vram_size\t\t__read_mostly;\t \nstatic u16\t\tvga_video_port_reg\t__read_mostly;\t \nstatic u16\t\tvga_video_port_val\t__read_mostly;\t \nstatic unsigned int\tvga_video_num_columns;\t\t\t \nstatic unsigned int\tvga_video_num_lines;\t\t\t \nstatic bool\t\tvga_can_do_color;\t\t\t \nstatic unsigned int\tvga_default_font_height __read_mostly;\t \nstatic unsigned char\tvga_video_type\t\t__read_mostly;\t \nstatic int\t\tvga_vesa_blanked;\nstatic bool \t\tvga_palette_blanked;\nstatic bool \t\tvga_is_gfx;\nstatic bool \t\tvga_512_chars;\nstatic int \t\tvga_video_font_height;\nstatic int \t\tvga_scan_lines\t\t__read_mostly;\nstatic unsigned int \tvga_rolled_over;  \n\nstatic bool vga_hardscroll_enabled;\nstatic bool vga_hardscroll_user_enable = true;\n\nstatic int __init no_scroll(char *str)\n{\n\t \n\tvga_hardscroll_user_enable = vga_hardscroll_enabled = false;\n\treturn 1;\n}\n\n__setup(\"no-scroll\", no_scroll);\n\n \nstatic inline void write_vga(unsigned char reg, unsigned int val)\n{\n\tunsigned int v1, v2;\n\tunsigned long flags;\n\n\t \n\traw_spin_lock_irqsave(&vga_lock, flags);\n\tv1 = reg + (val & 0xff00);\n\tv2 = reg + 1 + ((val << 8) & 0xff00);\n\toutw(v1, vga_video_port_reg);\n\toutw(v2, vga_video_port_reg);\n\traw_spin_unlock_irqrestore(&vga_lock, flags);\n}\n\nstatic inline void vga_set_mem_top(struct vc_data *c)\n{\n\twrite_vga(12, (c->vc_visible_origin - vga_vram_base) / 2);\n}\n\nstatic void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tvc_scrolldelta_helper(c, lines, vga_rolled_over, (void *)vga_vram_base,\n\t\t\tvga_vram_size);\n\tvga_set_mem_top(c);\n}\n\nstatic void vgacon_restore_screen(struct vc_data *c)\n{\n\tif (c->vc_origin != c->vc_visible_origin)\n\t\tvgacon_scrolldelta(c, 0);\n}\n\nstatic const char *vgacon_startup(void)\n{\n\tconst char *display_desc = NULL;\n\tu16 saved1, saved2;\n\tvolatile u16 *p;\n\n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\n\t    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\n\t      no_vga:\n#ifdef CONFIG_DUMMY_CONSOLE\n\t\tconswitchp = &dummy_con;\n\t\treturn conswitchp->con_startup();\n#else\n\t\treturn NULL;\n#endif\n\t}\n\n\t \n\tif ((screen_info.orig_video_lines == 0) ||\n\t    (screen_info.orig_video_cols  == 0))\n\t\tgoto no_vga;\n\n\t \n\tif ((screen_info.orig_video_mode == 0x0D) ||\t \n\t    (screen_info.orig_video_mode == 0x0E) ||\t \n\t    (screen_info.orig_video_mode == 0x10) ||\t \n\t    (screen_info.orig_video_mode == 0x12) ||\t \n\t    (screen_info.orig_video_mode == 0x6A))\t \n\t\tgoto no_vga;\n\n\tvga_video_num_lines = screen_info.orig_video_lines;\n\tvga_video_num_columns = screen_info.orig_video_cols;\n\tvgastate.vgabase = NULL;\n\n\tif (screen_info.orig_video_mode == 7) {\n\t\t \n\t\tvga_vram_base = 0xb0000;\n\t\tvga_video_port_reg = VGA_CRT_IM;\n\t\tvga_video_port_val = VGA_CRT_DM;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tstatic struct resource ega_console_resource =\n\t\t\t    { .name\t= \"ega\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_EGAM;\n\t\t\tvga_vram_size = 0x8000;\n\t\t\tdisplay_desc = \"EGA+\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &ega_console_resource);\n\t\t} else {\n\t\t\tstatic struct resource mda1_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BB };\n\t\t\tstatic struct resource mda2_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3BF,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_MDA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda1_console_resource);\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda2_console_resource);\n\t\t\tvga_video_font_height = 14;\n\t\t}\n\t} else {\n\t\t \n\t\tvga_can_do_color = true;\n\t\tvga_vram_base = 0xb8000;\n\t\tvga_video_port_reg = VGA_CRT_IC;\n\t\tvga_video_port_val = VGA_CRT_DC;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tint i;\n\n\t\t\tvga_vram_size = 0x8000;\n\n\t\t\tif (!screen_info.orig_video_isVGA) {\n\t\t\t\tstatic struct resource ega_console_resource =\n\t\t\t\t    { .name\t= \"ega\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_EGAC;\n\t\t\t\tdisplay_desc = \"EGA\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &ega_console_resource);\n\t\t\t} else {\n\t\t\t\tstatic struct resource vga_console_resource =\n\t\t\t\t    { .name\t= \"vga+\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_VGAC;\n\t\t\t\tdisplay_desc = \"VGA+\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &vga_console_resource);\n\n\t\t\t\t \n\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tinb_p(VGA_IS1_RC);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t}\n\t\t\t\toutb_p(0x20, VGA_ATT_W);\n\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\toutb_p(color_table[i], VGA_PEL_IW);\n\t\t\t\t\toutb_p(default_red[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_grn[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_blu[i], VGA_PEL_D);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatic struct resource cga_console_resource =\n\t\t\t    { .name\t= \"cga\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3D4,\n\t\t\t      .end\t= 0x3D5 };\n\t\t\tvga_video_type = VIDEO_TYPE_CGA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &cga_console_resource);\n\t\t\tvga_video_font_height = 8;\n\t\t}\n\t}\n\n\tvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\n\tvga_vram_end = vga_vram_base + vga_vram_size;\n\n\t \n\tp = (volatile u16 *) vga_vram_base;\n\tsaved1 = scr_readw(p);\n\tsaved2 = scr_readw(p + 1);\n\tscr_writew(0xAA55, p);\n\tscr_writew(0x55AA, p + 1);\n\tif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(0x55AA, p);\n\tscr_writew(0xAA55, p + 1);\n\tif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(saved1, p);\n\tscr_writew(saved2, p + 1);\n\n\tif (vga_video_type == VIDEO_TYPE_EGAC\n\t    || vga_video_type == VIDEO_TYPE_VGAC\n\t    || vga_video_type == VIDEO_TYPE_EGAM) {\n\t\tvga_hardscroll_enabled = vga_hardscroll_user_enable;\n\t\tvga_default_font_height = screen_info.orig_video_points;\n\t\tvga_video_font_height = screen_info.orig_video_points;\n\t\t \n\t\tvga_scan_lines =\n\t\t    vga_video_font_height * vga_video_num_lines;\n\t}\n\n\tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n\tvgacon_yres = vga_scan_lines;\n\n\treturn display_desc;\n}\n\nstatic void vgacon_init(struct vc_data *c, int init)\n{\n\tstruct uni_pagedict *p;\n\n\t \n\tc->vc_can_do_color = vga_can_do_color;\n\tc->vc_scan_lines = vga_scan_lines;\n\tc->vc_font.height = c->vc_cell_height = vga_video_font_height;\n\n\t \n\tif (init) {\n\t\tc->vc_cols = vga_video_num_columns;\n\t\tc->vc_rows = vga_video_num_lines;\n\t} else\n\t\tvc_resize(c, vga_video_num_columns, vga_video_num_lines);\n\n\tc->vc_complement_mask = 0x7700;\n\tif (vga_512_chars)\n\t\tc->vc_hi_font_mask = 0x0800;\n\tp = *c->uni_pagedict_loc;\n\tif (c->uni_pagedict_loc != &vgacon_uni_pagedir) {\n\t\tcon_free_unimap(c);\n\t\tc->uni_pagedict_loc = &vgacon_uni_pagedir;\n\t\tvgacon_refcount++;\n\t}\n\tif (!vgacon_uni_pagedir && p)\n\t\tcon_set_default_unimap(c);\n\n\t \n\tif (global_cursor_default == -1)\n\t\tglobal_cursor_default =\n\t\t\t!(screen_info.flags & VIDEO_FLAGS_NOCURSOR);\n}\n\nstatic void vgacon_deinit(struct vc_data *c)\n{\n\t \n\tif (con_is_visible(c)) {\n\t\tc->vc_visible_origin = vga_vram_base;\n\t\tvga_set_mem_top(c);\n\t}\n\n\tif (!--vgacon_refcount)\n\t\tcon_free_unimap(c);\n\tc->uni_pagedict_loc = &c->uni_pagedict;\n\tcon_set_default_unimap(c);\n}\n\nstatic u8 vgacon_build_attr(struct vc_data *c, u8 color,\n\t\t\t    enum vc_intensity intensity,\n\t\t\t    bool blink, bool underline, bool reverse,\n\t\t\t    bool italic)\n{\n\tu8 attr = color;\n\n\tif (vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF0) | c->vc_itcolor;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf0) | c->vc_ulcolor;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | c->vc_halfcolor;\n\t}\n\tif (reverse)\n\t\tattr =\n\t\t    ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) &\n\t\t\t\t       0x77);\n\tif (blink)\n\t\tattr ^= 0x80;\n\tif (intensity == VCI_BOLD)\n\t\tattr ^= 0x08;\n\tif (!vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF8) | 0x02;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf8) | 0x01;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | 0x08;\n\t}\n\treturn attr;\n}\n\nstatic void vgacon_invert_region(struct vc_data *c, u16 * p, int count)\n{\n\tconst bool col = vga_can_do_color;\n\n\twhile (count--) {\n\t\tu16 a = scr_readw(p);\n\t\tif (col)\n\t\t\ta = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) |\n\t\t\t    (((a) & 0x0700) << 4);\n\t\telse\n\t\t\ta ^= ((a & 0x0700) == 0x0100) ? 0x7000 : 0x7700;\n\t\tscr_writew(a, p++);\n\t}\n}\n\nstatic void vgacon_set_cursor_size(int from, int to)\n{\n\tunsigned long flags;\n\tint curs, cure;\n\n\tif ((from == cursor_size_lastfrom) && (to == cursor_size_lastto))\n\t\treturn;\n\tcursor_size_lastfrom = from;\n\tcursor_size_lastto = to;\n\n\traw_spin_lock_irqsave(&vga_lock, flags);\n\tif (vga_video_type >= VIDEO_TYPE_VGAC) {\n\t\toutb_p(VGA_CRTC_CURSOR_START, vga_video_port_reg);\n\t\tcurs = inb_p(vga_video_port_val);\n\t\toutb_p(VGA_CRTC_CURSOR_END, vga_video_port_reg);\n\t\tcure = inb_p(vga_video_port_val);\n\t} else {\n\t\tcurs = 0;\n\t\tcure = 0;\n\t}\n\n\tcurs = (curs & 0xc0) | from;\n\tcure = (cure & 0xe0) | to;\n\n\toutb_p(VGA_CRTC_CURSOR_START, vga_video_port_reg);\n\toutb_p(curs, vga_video_port_val);\n\toutb_p(VGA_CRTC_CURSOR_END, vga_video_port_reg);\n\toutb_p(cure, vga_video_port_val);\n\traw_spin_unlock_irqrestore(&vga_lock, flags);\n}\n\nstatic void vgacon_cursor(struct vc_data *c, int mode)\n{\n\tunsigned int c_height;\n\n\tif (c->vc_mode != KD_TEXT)\n\t\treturn;\n\n\tvgacon_restore_screen(c);\n\n\tc_height = c->vc_cell_height;\n\n\tswitch (mode) {\n\tcase CM_ERASE:\n\t\twrite_vga(14, (c->vc_pos - vga_vram_base) / 2);\n\t        if (vga_video_type >= VIDEO_TYPE_VGAC)\n\t\t\tvgacon_set_cursor_size(31, 30);\n\t\telse\n\t\t\tvgacon_set_cursor_size(31, 31);\n\t\tbreak;\n\n\tcase CM_MOVE:\n\tcase CM_DRAW:\n\t\twrite_vga(14, (c->vc_pos - vga_vram_base) / 2);\n\t\tswitch (CUR_SIZE(c->vc_cursor_type)) {\n\t\tcase CUR_UNDERLINE:\n\t\t\tvgacon_set_cursor_size(c_height -\n\t\t\t\t\t       (c_height < 10 ? 2 : 3),\n\t\t\t\t\t       c_height -\n\t\t\t\t\t       (c_height < 10 ? 1 : 2));\n\t\t\tbreak;\n\t\tcase CUR_TWO_THIRDS:\n\t\t\tvgacon_set_cursor_size(c_height / 3, c_height -\n\t\t\t\t\t       (c_height < 10 ? 1 : 2));\n\t\t\tbreak;\n\t\tcase CUR_LOWER_THIRD:\n\t\t\tvgacon_set_cursor_size(c_height * 2 / 3, c_height -\n\t\t\t\t\t       (c_height < 10 ? 1 : 2));\n\t\t\tbreak;\n\t\tcase CUR_LOWER_HALF:\n\t\t\tvgacon_set_cursor_size(c_height / 2, c_height -\n\t\t\t\t\t       (c_height < 10 ? 1 : 2));\n\t\t\tbreak;\n\t\tcase CUR_NONE:\n\t\t\tif (vga_video_type >= VIDEO_TYPE_VGAC)\n\t\t\t\tvgacon_set_cursor_size(31, 30);\n\t\t\telse\n\t\t\t\tvgacon_set_cursor_size(31, 31);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvgacon_set_cursor_size(1, c_height);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void vgacon_doresize(struct vc_data *c,\n\t\tunsigned int width, unsigned int height)\n{\n\tunsigned long flags;\n\tunsigned int scanlines = height * c->vc_cell_height;\n\tu8 scanlines_lo = 0, r7 = 0, vsync_end = 0, mode, max_scan;\n\n\traw_spin_lock_irqsave(&vga_lock, flags);\n\n\tvgacon_xres = width * VGA_FONTWIDTH;\n\tvgacon_yres = height * c->vc_cell_height;\n\tif (vga_video_type >= VIDEO_TYPE_VGAC) {\n\t\toutb_p(VGA_CRTC_MAX_SCAN, vga_video_port_reg);\n\t\tmax_scan = inb_p(vga_video_port_val);\n\n\t\tif (max_scan & 0x80)\n\t\t\tscanlines <<= 1;\n\n\t\toutb_p(VGA_CRTC_MODE, vga_video_port_reg);\n\t\tmode = inb_p(vga_video_port_val);\n\n\t\tif (mode & 0x04)\n\t\t\tscanlines >>= 1;\n\n\t\tscanlines -= 1;\n\t\tscanlines_lo = scanlines & 0xff;\n\n\t\toutb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);\n\t\tr7 = inb_p(vga_video_port_val) & ~0x42;\n\n\t\tif (scanlines & 0x100)\n\t\t\tr7 |= 0x02;\n\t\tif (scanlines & 0x200)\n\t\t\tr7 |= 0x40;\n\n\t\t \n\t\toutb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);\n\t\tvsync_end = inb_p(vga_video_port_val);\n\t\toutb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);\n\t\toutb_p(vsync_end & ~0x80, vga_video_port_val);\n\t}\n\n\toutb_p(VGA_CRTC_H_DISP, vga_video_port_reg);\n\toutb_p(width - 1, vga_video_port_val);\n\toutb_p(VGA_CRTC_OFFSET, vga_video_port_reg);\n\toutb_p(width >> 1, vga_video_port_val);\n\n\tif (vga_video_type >= VIDEO_TYPE_VGAC) {\n\t\toutb_p(VGA_CRTC_V_DISP_END, vga_video_port_reg);\n\t\toutb_p(scanlines_lo, vga_video_port_val);\n\t\toutb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);\n\t\toutb_p(r7,vga_video_port_val);\n\n\t\t \n\t\toutb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);\n\t\toutb_p(vsync_end, vga_video_port_val);\n\t}\n\n\traw_spin_unlock_irqrestore(&vga_lock, flags);\n}\n\nstatic int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_cell_height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_cell_height;\n\t \n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\t \n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\treturn 0;\t\t \n}\n\nstatic void vga_set_palette(struct vc_data *vc, const unsigned char *table)\n{\n\tint i, j;\n\n\tvga_w(vgastate.vgabase, VGA_PEL_MSK, 0xff);\n\tfor (i = j = 0; i < 16; i++) {\n\t\tvga_w(vgastate.vgabase, VGA_PEL_IW, table[i]);\n\t\tvga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);\n\t\tvga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);\n\t\tvga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);\n\t}\n}\n\nstatic void vgacon_set_palette(struct vc_data *vc, const unsigned char *table)\n{\n\tif (vga_video_type != VIDEO_TYPE_VGAC || vga_palette_blanked\n\t    || !con_is_visible(vc))\n\t\treturn;\n\tvga_set_palette(vc, table);\n}\n\n \nstatic struct {\n\tunsigned char SeqCtrlIndex;\t \n\tunsigned char CrtCtrlIndex;\t \n\tunsigned char CrtMiscIO;\t \n\tunsigned char HorizontalTotal;\t \n\tunsigned char HorizDisplayEnd;\t \n\tunsigned char StartHorizRetrace;\t \n\tunsigned char EndHorizRetrace;\t \n\tunsigned char Overflow;\t \n\tunsigned char StartVertRetrace;\t \n\tunsigned char EndVertRetrace;\t \n\tunsigned char ModeControl;\t \n\tunsigned char ClockingMode;\t \n} vga_state;\n\nstatic void vga_vesa_blank(struct vgastate *state, int mode)\n{\n\t \n\tif (!vga_vesa_blanked) {\n\t\traw_spin_lock_irq(&vga_lock);\n\t\tvga_state.SeqCtrlIndex = vga_r(state->vgabase, VGA_SEQ_I);\n\t\tvga_state.CrtCtrlIndex = inb_p(vga_video_port_reg);\n\t\tvga_state.CrtMiscIO = vga_r(state->vgabase, VGA_MIS_R);\n\t\traw_spin_unlock_irq(&vga_lock);\n\n\t\toutb_p(0x00, vga_video_port_reg);\t \n\t\tvga_state.HorizontalTotal = inb_p(vga_video_port_val);\n\t\toutb_p(0x01, vga_video_port_reg);\t \n\t\tvga_state.HorizDisplayEnd = inb_p(vga_video_port_val);\n\t\toutb_p(0x04, vga_video_port_reg);\t \n\t\tvga_state.StartHorizRetrace = inb_p(vga_video_port_val);\n\t\toutb_p(0x05, vga_video_port_reg);\t \n\t\tvga_state.EndHorizRetrace = inb_p(vga_video_port_val);\n\t\toutb_p(0x07, vga_video_port_reg);\t \n\t\tvga_state.Overflow = inb_p(vga_video_port_val);\n\t\toutb_p(0x10, vga_video_port_reg);\t \n\t\tvga_state.StartVertRetrace = inb_p(vga_video_port_val);\n\t\toutb_p(0x11, vga_video_port_reg);\t \n\t\tvga_state.EndVertRetrace = inb_p(vga_video_port_val);\n\t\toutb_p(0x17, vga_video_port_reg);\t \n\t\tvga_state.ModeControl = inb_p(vga_video_port_val);\n\t\tvga_state.ClockingMode = vga_rseq(state->vgabase, VGA_SEQ_CLOCK_MODE);\n\t}\n\n\t \n\t \n\traw_spin_lock_irq(&vga_lock);\n\tvga_wseq(state->vgabase, VGA_SEQ_CLOCK_MODE, vga_state.ClockingMode | 0x20);\n\n\t \n\tif ((vga_state.CrtMiscIO & 0x80) == 0x80)\n\t\tvga_w(state->vgabase, VGA_MIS_W, vga_state.CrtMiscIO & 0xEF);\n\n\t \n\tif (mode & VESA_VSYNC_SUSPEND) {\n\t\toutb_p(0x10, vga_video_port_reg);\t \n\t\toutb_p(0xff, vga_video_port_val);\t \n\t\toutb_p(0x11, vga_video_port_reg);\t \n\t\toutb_p(0x40, vga_video_port_val);\t \n\t\toutb_p(0x07, vga_video_port_reg);\t \n\t\toutb_p(vga_state.Overflow | 0x84, vga_video_port_val);\t \n\t}\n\n\tif (mode & VESA_HSYNC_SUSPEND) {\n\t\t \n\t\toutb_p(0x04, vga_video_port_reg);\t \n\t\toutb_p(0xff, vga_video_port_val);\t \n\t\toutb_p(0x05, vga_video_port_reg);\t \n\t\toutb_p(0x00, vga_video_port_val);\t \n\t}\n\n\t \n\tvga_w(state->vgabase, VGA_SEQ_I, vga_state.SeqCtrlIndex);\n\toutb_p(vga_state.CrtCtrlIndex, vga_video_port_reg);\n\traw_spin_unlock_irq(&vga_lock);\n}\n\nstatic void vga_vesa_unblank(struct vgastate *state)\n{\n\t \n\traw_spin_lock_irq(&vga_lock);\n\tvga_w(state->vgabase, VGA_MIS_W, vga_state.CrtMiscIO);\n\n\toutb_p(0x00, vga_video_port_reg);\t \n\toutb_p(vga_state.HorizontalTotal, vga_video_port_val);\n\toutb_p(0x01, vga_video_port_reg);\t \n\toutb_p(vga_state.HorizDisplayEnd, vga_video_port_val);\n\toutb_p(0x04, vga_video_port_reg);\t \n\toutb_p(vga_state.StartHorizRetrace, vga_video_port_val);\n\toutb_p(0x05, vga_video_port_reg);\t \n\toutb_p(vga_state.EndHorizRetrace, vga_video_port_val);\n\toutb_p(0x07, vga_video_port_reg);\t \n\toutb_p(vga_state.Overflow, vga_video_port_val);\n\toutb_p(0x10, vga_video_port_reg);\t \n\toutb_p(vga_state.StartVertRetrace, vga_video_port_val);\n\toutb_p(0x11, vga_video_port_reg);\t \n\toutb_p(vga_state.EndVertRetrace, vga_video_port_val);\n\toutb_p(0x17, vga_video_port_reg);\t \n\toutb_p(vga_state.ModeControl, vga_video_port_val);\n\t \n\tvga_wseq(state->vgabase, VGA_SEQ_CLOCK_MODE, vga_state.ClockingMode);\n\n\t \n\tvga_w(state->vgabase, VGA_SEQ_I, vga_state.SeqCtrlIndex);\n\toutb_p(vga_state.CrtCtrlIndex, vga_video_port_reg);\n\traw_spin_unlock_irq(&vga_lock);\n}\n\nstatic void vga_pal_blank(struct vgastate *state)\n{\n\tint i;\n\n\tvga_w(state->vgabase, VGA_PEL_MSK, 0xff);\n\tfor (i = 0; i < 16; i++) {\n\t\tvga_w(state->vgabase, VGA_PEL_IW, i);\n\t\tvga_w(state->vgabase, VGA_PEL_D, 0);\n\t\tvga_w(state->vgabase, VGA_PEL_D, 0);\n\t\tvga_w(state->vgabase, VGA_PEL_D, 0);\n\t}\n}\n\nstatic int vgacon_blank(struct vc_data *c, int blank, int mode_switch)\n{\n\tswitch (blank) {\n\tcase 0:\t\t \n\t\tif (vga_vesa_blanked) {\n\t\t\tvga_vesa_unblank(&vgastate);\n\t\t\tvga_vesa_blanked = 0;\n\t\t}\n\t\tif (vga_palette_blanked) {\n\t\t\tvga_set_palette(c, color_table);\n\t\t\tvga_palette_blanked = false;\n\t\t\treturn 0;\n\t\t}\n\t\tvga_is_gfx = false;\n\t\t \n\t\treturn 1;\n\tcase 1:\t\t \n\tcase -1:\t \n\t\tif (!mode_switch && vga_video_type == VIDEO_TYPE_VGAC) {\n\t\t\tvga_pal_blank(&vgastate);\n\t\t\tvga_palette_blanked = true;\n\t\t\treturn 0;\n\t\t}\n\t\tvgacon_set_origin(c);\n\t\tscr_memsetw((void *) vga_vram_base, BLANK,\n\t\t\t    c->vc_screenbuf_size);\n\t\tif (mode_switch)\n\t\t\tvga_is_gfx = true;\n\t\treturn 1;\n\tdefault:\t\t \n\t\tif (vga_video_type == VIDEO_TYPE_VGAC) {\n\t\t\tvga_vesa_blank(&vgastate, blank - 1);\n\t\t\tvga_vesa_blanked = blank;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\n \n\n#define colourmap 0xa0000\n \n#define blackwmap 0xa0000\n#define cmapsz 8192\n\nstatic int vgacon_do_font_op(struct vgastate *state, char *arg, int set,\n\t\tbool ch512)\n{\n\tunsigned short video_port_status = vga_video_port_reg + 6;\n\tint font_select = 0x00, beg, i;\n\tchar *charmap;\n\tbool clear_attribs = false;\n\tif (vga_video_type != VIDEO_TYPE_EGAM) {\n\t\tcharmap = (char *) VGA_MAP_MEM(colourmap, 0);\n\t\tbeg = 0x0e;\n\t} else {\n\t\tcharmap = (char *) VGA_MAP_MEM(blackwmap, 0);\n\t\tbeg = 0x0a;\n\t}\n\n\t \n\n\tif (!arg)\n\t\treturn -EINVAL;\t \n\n\tfont_select = ch512 ? 0x04 : 0x00;\n\n\traw_spin_lock_irq(&vga_lock);\n\t \n\tvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x1);\n\t \n\tvga_wseq(state->vgabase, VGA_SEQ_PLANE_WRITE, 0x04);\t\n\t \n\tvga_wseq(state->vgabase, VGA_SEQ_MEMORY_MODE, 0x07);\t\n\t \n\tvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x03);\n\n\t \n\tvga_wgfx(state->vgabase, VGA_GFX_PLANE_READ, 0x02);\t\t\n\t \n\tvga_wgfx(state->vgabase, VGA_GFX_MODE, 0x00);\n\t \n\tvga_wgfx(state->vgabase, VGA_GFX_MISC, 0x00);\n\traw_spin_unlock_irq(&vga_lock);\n\n\tif (arg) {\n\t\tif (set)\n\t\t\tfor (i = 0; i < cmapsz; i++) {\n\t\t\t\tvga_writeb(arg[i], charmap + i);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\telse\n\t\t\tfor (i = 0; i < cmapsz; i++) {\n\t\t\t\targ[i] = vga_readb(charmap + i);\n\t\t\t\tcond_resched();\n\t\t\t}\n\n\t\t \n\n\t\tif (ch512) {\n\t\t\tcharmap += 2 * cmapsz;\n\t\t\targ += cmapsz;\n\t\t\tif (set)\n\t\t\t\tfor (i = 0; i < cmapsz; i++) {\n\t\t\t\t\tvga_writeb(arg[i], charmap + i);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tfor (i = 0; i < cmapsz; i++) {\n\t\t\t\t\targ[i] = vga_readb(charmap + i);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t}\n\t}\n\n\traw_spin_lock_irq(&vga_lock);\n\t \n\tvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x01);\t\n\t \n\tvga_wseq(state->vgabase, VGA_SEQ_PLANE_WRITE, 0x03);\n\t \n\tvga_wseq(state->vgabase, VGA_SEQ_MEMORY_MODE, 0x03);\n\t \n\tif (set)\n\t\tvga_wseq(state->vgabase, VGA_SEQ_CHARACTER_MAP, font_select);\n\t \n\tvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x03);\n\n\t \n\tvga_wgfx(state->vgabase, VGA_GFX_PLANE_READ, 0x00);\n\t \n\tvga_wgfx(state->vgabase, VGA_GFX_MODE, 0x10);\n\t \n\tvga_wgfx(state->vgabase, VGA_GFX_MISC, beg);\n\n\t \n\tif ((set) && (ch512 != vga_512_chars)) {\n\t\tvga_512_chars = ch512;\n\t\t \n\t\tinb_p(video_port_status);\t \n\t\t \n\t\tvga_wattr(state->vgabase, VGA_ATC_PLANE_ENABLE, ch512 ? 0x07 : 0x0f);\n\t\t \n\t\tinb_p(video_port_status);\n\t\tvga_wattr(state->vgabase, VGA_AR_ENABLE_DISPLAY, 0);\t\n\t\tclear_attribs = true;\n\t}\n\traw_spin_unlock_irq(&vga_lock);\n\n\tif (clear_attribs) {\n\t\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\t\tstruct vc_data *c = vc_cons[i].d;\n\t\t\tif (c && c->vc_sw == &vga_con) {\n\t\t\t\t \n\t\t\t\tc->vc_hi_font_mask = 0x00;\n\t\t\t\tclear_buffer_attributes(c);\n\t\t\t\tc->vc_hi_font_mask = ch512 ? 0x0800 : 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int vgacon_adjust_height(struct vc_data *vc, unsigned fontheight)\n{\n\tunsigned char ovr, vde, fsr;\n\tint rows, maxscan, i;\n\n\trows = vc->vc_scan_lines / fontheight;\t \n\tmaxscan = rows * fontheight - 1;\t \n\n\t \n\n\traw_spin_lock_irq(&vga_lock);\n\toutb_p(0x07, vga_video_port_reg);\t \n\tovr = inb_p(vga_video_port_val);\n\toutb_p(0x09, vga_video_port_reg);\t \n\tfsr = inb_p(vga_video_port_val);\n\traw_spin_unlock_irq(&vga_lock);\n\n\tvde = maxscan & 0xff;\t \n\tovr = (ovr & 0xbd) +\t \n\t    ((maxscan & 0x100) >> 7) + ((maxscan & 0x200) >> 3);\n\tfsr = (fsr & 0xe0) + (fontheight - 1);\t \n\n\traw_spin_lock_irq(&vga_lock);\n\toutb_p(0x07, vga_video_port_reg);\t \n\toutb_p(ovr, vga_video_port_val);\n\toutb_p(0x09, vga_video_port_reg);\t \n\toutb_p(fsr, vga_video_port_val);\n\toutb_p(0x12, vga_video_port_reg);\t \n\toutb_p(vde, vga_video_port_val);\n\traw_spin_unlock_irq(&vga_lock);\n\tvga_video_font_height = fontheight;\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\tstruct vc_data *c = vc_cons[i].d;\n\n\t\tif (c && c->vc_sw == &vga_con) {\n\t\t\tif (con_is_visible(c)) {\n\t\t\t         \n\t\t\t\tcursor_size_lastfrom = 0;\n\t\t\t\tcursor_size_lastto = 0;\n\t\t\t\tc->vc_sw->con_cursor(c, CM_DRAW);\n\t\t\t}\n\t\t\tc->vc_font.height = c->vc_cell_height = fontheight;\n\t\t\tvc_resize(c, 0, rows);\t \n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vgacon_font_set(struct vc_data *c, struct console_font *font,\n\t\t\t   unsigned int vpitch, unsigned int flags)\n{\n\tunsigned charcount = font->charcount;\n\tint rc;\n\n\tif (vga_video_type < VIDEO_TYPE_EGAM)\n\t\treturn -EINVAL;\n\n\tif (font->width != VGA_FONTWIDTH || font->height > 32 || vpitch != 32 ||\n\t    (charcount != 256 && charcount != 512))\n\t\treturn -EINVAL;\n\n\trc = vgacon_do_font_op(&vgastate, font->data, 1, charcount == 512);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!(flags & KD_FONT_FLAG_DONT_RECALC))\n\t\trc = vgacon_adjust_height(c, font->height);\n\treturn rc;\n}\n\nstatic int vgacon_font_get(struct vc_data *c, struct console_font *font, unsigned int vpitch)\n{\n\tif (vga_video_type < VIDEO_TYPE_EGAM || vpitch != 32)\n\t\treturn -EINVAL;\n\n\tfont->width = VGA_FONTWIDTH;\n\tfont->height = c->vc_font.height;\n\tfont->charcount = vga_512_chars ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\treturn vgacon_do_font_op(&vgastate, font->data, 0, vga_512_chars);\n}\n\nstatic int vgacon_resize(struct vc_data *c, unsigned int width,\n\t\t\t unsigned int height, unsigned int user)\n{\n\tif ((width << 1) * height > vga_vram_size)\n\t\treturn -EINVAL;\n\n\tif (user) {\n\t\t \n\t\tscreen_info.orig_video_cols = width;\n\t\tscreen_info.orig_video_lines = height;\n\t\tvga_default_font_height = c->vc_cell_height;\n\t\treturn 0;\n\t}\n\tif (width % 2 || width > screen_info.orig_video_cols ||\n\t    height > (screen_info.orig_video_lines * vga_default_font_height)/\n\t    c->vc_cell_height)\n\t\treturn -EINVAL;\n\n\tif (con_is_visible(c) && !vga_is_gfx)  \n\t\tvgacon_doresize(c, width, height);\n\treturn 0;\n}\n\nstatic int vgacon_set_origin(struct vc_data *c)\n{\n\tif (vga_is_gfx ||\t \n\t    (console_blanked && !vga_palette_blanked))\t \n\t\treturn 0;\n\tc->vc_origin = c->vc_visible_origin = vga_vram_base;\n\tvga_set_mem_top(c);\n\tvga_rolled_over = 0;\n\treturn 1;\n}\n\nstatic void vgacon_save_screen(struct vc_data *c)\n{\n\tstatic int vga_bootup_console = 0;\n\n\tif (!vga_bootup_console) {\n\t\t \n\t\tvga_bootup_console = 1;\n\t\tc->state.x = screen_info.orig_x;\n\t\tc->state.y = screen_info.orig_y;\n\t}\n\n\t \n\n\tif (!vga_is_gfx)\n\t\tscr_memcpyw((u16 *) c->vc_screenbuf, (u16 *) c->vc_origin,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ? vga_vram_size : c->vc_screenbuf_size);\n}\n\nstatic bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tunsigned long oldo;\n\tunsigned int delta;\n\n\tif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\n\t\treturn false;\n\n\tif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\n\t\treturn false;\n\n\tvgacon_restore_screen(c);\n\toldo = c->vc_origin;\n\tdelta = lines * c->vc_size_row;\n\tif (dir == SM_UP) {\n\t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n\t\t\tscr_memcpyw((u16 *) vga_vram_base,\n\t\t\t\t    (u16 *) (oldo + delta),\n\t\t\t\t    c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_base;\n\t\t\tvga_rolled_over = oldo - vga_vram_base;\n\t\t} else\n\t\t\tc->vc_origin += delta;\n\t\tscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\n\t\t\t\t     delta), c->vc_video_erase_char,\n\t\t\t    delta);\n\t} else {\n\t\tif (oldo - delta < vga_vram_base) {\n\t\t\tscr_memmovew((u16 *) (vga_vram_end -\n\t\t\t\t\t      c->vc_screenbuf_size +\n\t\t\t\t\t      delta), (u16 *) oldo,\n\t\t\t\t     c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\n\t\t\tvga_rolled_over = 0;\n\t\t} else\n\t\t\tc->vc_origin -= delta;\n\t\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\t\tscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\n\t\t\t    delta);\n\t}\n\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\tc->vc_visible_origin = c->vc_origin;\n\tvga_set_mem_top(c);\n\tc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\n\treturn true;\n}\n\n \n\nstatic void vgacon_clear(struct vc_data *vc, int sy, int sx, int height,\n\t\t\t int width) { }\nstatic void vgacon_putc(struct vc_data *vc, int c, int ypos, int xpos) { }\nstatic void vgacon_putcs(struct vc_data *vc, const unsigned short *s,\n\t\t\t int count, int ypos, int xpos) { }\n\nconst struct consw vga_con = {\n\t.owner = THIS_MODULE,\n\t.con_startup = vgacon_startup,\n\t.con_init = vgacon_init,\n\t.con_deinit = vgacon_deinit,\n\t.con_clear = vgacon_clear,\n\t.con_putc = vgacon_putc,\n\t.con_putcs = vgacon_putcs,\n\t.con_cursor = vgacon_cursor,\n\t.con_scroll = vgacon_scroll,\n\t.con_switch = vgacon_switch,\n\t.con_blank = vgacon_blank,\n\t.con_font_set = vgacon_font_set,\n\t.con_font_get = vgacon_font_get,\n\t.con_resize = vgacon_resize,\n\t.con_set_palette = vgacon_set_palette,\n\t.con_scrolldelta = vgacon_scrolldelta,\n\t.con_set_origin = vgacon_set_origin,\n\t.con_save_screen = vgacon_save_screen,\n\t.con_build_attr = vgacon_build_attr,\n\t.con_invert_region = vgacon_invert_region,\n};\nEXPORT_SYMBOL(vga_con);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}