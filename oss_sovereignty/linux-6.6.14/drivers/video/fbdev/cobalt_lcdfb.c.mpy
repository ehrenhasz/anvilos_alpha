{
  "module_name": "cobalt_lcdfb.c",
  "hash_id": "99fa6f5dabcbf5bca2177061d909f6d34bf09560e49753fd1a4793634d9f0e76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/cobalt_lcdfb.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/uaccess.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n\n \n#define LCD_DATA_REG_OFFSET\t0x10\n#define LCD_XRES_MAX\t\t16\n#define LCD_YRES_MAX\t\t2\n#define LCD_CHARS_MAX\t\t32\n\n#define LCD_CLEAR\t\t0x01\n#define LCD_CURSOR_MOVE_HOME\t0x02\n#define LCD_RESET\t\t0x06\n#define LCD_OFF\t\t\t0x08\n#define LCD_CURSOR_OFF\t\t0x0c\n#define LCD_CURSOR_BLINK_OFF\t0x0e\n#define LCD_CURSOR_ON\t\t0x0f\n#define LCD_ON\t\t\tLCD_CURSOR_ON\n#define LCD_CURSOR_MOVE_LEFT\t0x10\n#define LCD_CURSOR_MOVE_RIGHT\t0x14\n#define LCD_DISPLAY_LEFT\t0x18\n#define LCD_DISPLAY_RIGHT\t0x1c\n#define LCD_PRERESET\t\t0x3f\t \n#define LCD_BUSY\t\t0x80\n\n#define LCD_GRAPHIC_MODE\t0x40\n#define LCD_TEXT_MODE\t\t0x80\n#define LCD_CUR_POS_MASK\t0x7f\n\n#define LCD_CUR_POS(x)\t\t((x) & LCD_CUR_POS_MASK)\n#define LCD_TEXT_POS(x)\t\t((x) | LCD_TEXT_MODE)\n\nstatic inline void lcd_write_control(struct fb_info *info, u8 control)\n{\n\twritel((u32)control << 24, info->screen_base);\n}\n\nstatic inline u8 lcd_read_control(struct fb_info *info)\n{\n\treturn readl(info->screen_base) >> 24;\n}\n\nstatic inline void lcd_write_data(struct fb_info *info, u8 data)\n{\n\twritel((u32)data << 24, info->screen_base + LCD_DATA_REG_OFFSET);\n}\n\nstatic inline u8 lcd_read_data(struct fb_info *info)\n{\n\treturn readl(info->screen_base + LCD_DATA_REG_OFFSET) >> 24;\n}\n\nstatic int lcd_busy_wait(struct fb_info *info)\n{\n\tu8 val = 0;\n\tint timeout = 10, retval = 0;\n\n\tdo {\n\t\tval = lcd_read_control(info);\n\t\tval &= LCD_BUSY;\n\t\tif (val != LCD_BUSY)\n\t\t\tbreak;\n\n\t\tif (msleep_interruptible(1))\n\t\t\treturn -EINTR;\n\n\t\ttimeout--;\n\t} while (timeout);\n\n\tif (val == LCD_BUSY)\n\t\tretval = -EBUSY;\n\n\treturn retval;\n}\n\nstatic void lcd_clear(struct fb_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tudelay(150);\n\n\t\tlcd_write_control(info, LCD_PRERESET);\n\t}\n\n\tudelay(150);\n\n\tlcd_write_control(info, LCD_CLEAR);\n\n\tudelay(150);\n\n\tlcd_write_control(info, LCD_RESET);\n}\n\nstatic const struct fb_fix_screeninfo cobalt_lcdfb_fix = {\n\t.id\t\t= \"cobalt-lcd\",\n\t.type\t\t= FB_TYPE_TEXT,\n\t.type_aux\t= FB_AUX_TEXT_MDA,\n\t.visual\t\t= FB_VISUAL_MONO01,\n\t.line_length\t= LCD_XRES_MAX,\n\t.accel\t\t= FB_ACCEL_NONE,\n};\n\nstatic ssize_t cobalt_lcdfb_read(struct fb_info *info, char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tchar src[LCD_CHARS_MAX];\n\tunsigned long pos;\n\tint len, retval = 0;\n\n\tif (!info->screen_base)\n\t\treturn -ENODEV;\n\n\tpos = *ppos;\n\tif (pos >= LCD_CHARS_MAX || count == 0)\n\t\treturn 0;\n\n\tif (count > LCD_CHARS_MAX)\n\t\tcount = LCD_CHARS_MAX;\n\n\tif (pos + count > LCD_CHARS_MAX)\n\t\tcount = LCD_CHARS_MAX - pos;\n\n\tfor (len = 0; len < count; len++) {\n\t\tretval = lcd_busy_wait(info);\n\t\tif (retval < 0)\n\t\t\tbreak;\n\n\t\tlcd_write_control(info, LCD_TEXT_POS(pos));\n\n\t\tretval = lcd_busy_wait(info);\n\t\tif (retval < 0)\n\t\t\tbreak;\n\n\t\tsrc[len] = lcd_read_data(info);\n\t\tif (pos == 0x0f)\n\t\t\tpos = 0x40;\n\t\telse\n\t\t\tpos++;\n\t}\n\n\tif (retval < 0 && signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tif (copy_to_user(buf, src, len))\n\t\treturn -EFAULT;\n\n\t*ppos += len;\n\n\treturn len;\n}\n\nstatic ssize_t cobalt_lcdfb_write(struct fb_info *info, const char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tchar dst[LCD_CHARS_MAX];\n\tunsigned long pos;\n\tint len, retval = 0;\n\n\tif (!info->screen_base)\n\t\treturn -ENODEV;\n\n\tpos = *ppos;\n\tif (pos >= LCD_CHARS_MAX || count == 0)\n\t\treturn 0;\n\n\tif (count > LCD_CHARS_MAX)\n\t\tcount = LCD_CHARS_MAX;\n\n\tif (pos + count > LCD_CHARS_MAX)\n\t\tcount = LCD_CHARS_MAX - pos;\n\n\tif (copy_from_user(dst, buf, count))\n\t\treturn -EFAULT;\n\n\tfor (len = 0; len < count; len++) {\n\t\tretval = lcd_busy_wait(info);\n\t\tif (retval < 0)\n\t\t\tbreak;\n\n\t\tlcd_write_control(info, LCD_TEXT_POS(pos));\n\n\t\tretval = lcd_busy_wait(info);\n\t\tif (retval < 0)\n\t\t\tbreak;\n\n\t\tlcd_write_data(info, dst[len]);\n\t\tif (pos == 0x0f)\n\t\t\tpos = 0x40;\n\t\telse\n\t\t\tpos++;\n\t}\n\n\tif (retval < 0 && signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\t*ppos += len;\n\n\treturn len;\n}\n\nstatic int cobalt_lcdfb_blank(int blank_mode, struct fb_info *info)\n{\n\tint retval;\n\n\tretval = lcd_busy_wait(info);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\tlcd_write_control(info, LCD_ON);\n\t\tbreak;\n\tdefault:\n\t\tlcd_write_control(info, LCD_OFF);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cobalt_lcdfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\tu32 x, y;\n\tint retval;\n\n\tswitch (cursor->set) {\n\tcase FB_CUR_SETPOS:\n\t\tx = cursor->image.dx;\n\t\ty = cursor->image.dy;\n\t\tif (x >= LCD_XRES_MAX || y >= LCD_YRES_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tretval = lcd_busy_wait(info);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tlcd_write_control(info,\n\t\t\t\t  LCD_TEXT_POS(info->fix.line_length * y + x));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tretval = lcd_busy_wait(info);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif (cursor->enable)\n\t\tlcd_write_control(info, LCD_CURSOR_ON);\n\telse\n\t\tlcd_write_control(info, LCD_CURSOR_OFF);\n\n\treturn 0;\n}\n\nstatic const struct fb_ops cobalt_lcd_fbops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_read\t= cobalt_lcdfb_read,\n\t.fb_write\t= cobalt_lcdfb_write,\n\t.fb_blank\t= cobalt_lcdfb_blank,\n\t.fb_cursor\t= cobalt_lcdfb_cursor,\n};\n\nstatic int cobalt_lcdfb_probe(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\tstruct resource *res;\n\tint retval;\n\n\tinfo = framebuffer_alloc(0, &dev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tframebuffer_release(info);\n\t\treturn -EBUSY;\n\t}\n\n\tinfo->screen_size = resource_size(res);\n\tinfo->screen_base = devm_ioremap(&dev->dev, res->start,\n\t\t\t\t\t info->screen_size);\n\tif (!info->screen_base) {\n\t\tframebuffer_release(info);\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo->fbops = &cobalt_lcd_fbops;\n\tinfo->fix = cobalt_lcdfb_fix;\n\tinfo->fix.smem_start = res->start;\n\tinfo->fix.smem_len = info->screen_size;\n\tinfo->pseudo_palette = NULL;\n\tinfo->par = NULL;\n\n\tretval = register_framebuffer(info);\n\tif (retval < 0) {\n\t\tframebuffer_release(info);\n\t\treturn retval;\n\t}\n\n\tplatform_set_drvdata(dev, info);\n\n\tlcd_clear(info);\n\n\tfb_info(info, \"Cobalt server LCD frame buffer device\\n\");\n\n\treturn 0;\n}\n\nstatic void cobalt_lcdfb_remove(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\n\tinfo = platform_get_drvdata(dev);\n\tif (info) {\n\t\tunregister_framebuffer(info);\n\t\tframebuffer_release(info);\n\t}\n}\n\nstatic struct platform_driver cobalt_lcdfb_driver = {\n\t.probe\t= cobalt_lcdfb_probe,\n\t.remove_new = cobalt_lcdfb_remove,\n\t.driver\t= {\n\t\t.name\t= \"cobalt-lcd\",\n\t},\n};\nmodule_platform_driver(cobalt_lcdfb_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Yoichi Yuasa\");\nMODULE_DESCRIPTION(\"Cobalt server LCD frame buffer driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}