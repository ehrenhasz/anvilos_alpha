{
  "module_name": "ssd1307fb.c",
  "hash_id": "ee56fd19572eecb607f25720939ac0cd06c6b24390b6ebbc2ab99b966a5dbe61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/ssd1307fb.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/pwm.h>\n#include <linux/uaccess.h>\n#include <linux/regulator/consumer.h>\n\n#define SSD1307FB_DATA\t\t\t0x40\n#define SSD1307FB_COMMAND\t\t0x80\n\n#define SSD1307FB_SET_ADDRESS_MODE\t0x20\n#define SSD1307FB_SET_ADDRESS_MODE_HORIZONTAL\t(0x00)\n#define SSD1307FB_SET_ADDRESS_MODE_VERTICAL\t(0x01)\n#define SSD1307FB_SET_ADDRESS_MODE_PAGE\t\t(0x02)\n#define SSD1307FB_SET_COL_RANGE\t\t0x21\n#define SSD1307FB_SET_PAGE_RANGE\t0x22\n#define SSD1307FB_CONTRAST\t\t0x81\n#define SSD1307FB_SET_LOOKUP_TABLE\t0x91\n#define\tSSD1307FB_CHARGE_PUMP\t\t0x8d\n#define SSD1307FB_SEG_REMAP_ON\t\t0xa1\n#define SSD1307FB_DISPLAY_OFF\t\t0xae\n#define SSD1307FB_SET_MULTIPLEX_RATIO\t0xa8\n#define SSD1307FB_DISPLAY_ON\t\t0xaf\n#define SSD1307FB_START_PAGE_ADDRESS\t0xb0\n#define SSD1307FB_SET_DISPLAY_OFFSET\t0xd3\n#define\tSSD1307FB_SET_CLOCK_FREQ\t0xd5\n#define\tSSD1307FB_SET_AREA_COLOR_MODE\t0xd8\n#define\tSSD1307FB_SET_PRECHARGE_PERIOD\t0xd9\n#define\tSSD1307FB_SET_COM_PINS_CONFIG\t0xda\n#define\tSSD1307FB_SET_VCOMH\t\t0xdb\n\n#define MAX_CONTRAST 255\n\n#define REFRESHRATE 1\n\nstatic u_int refreshrate = REFRESHRATE;\nmodule_param(refreshrate, uint, 0);\n\nstruct ssd1307fb_deviceinfo {\n\tu32 default_vcomh;\n\tu32 default_dclk_div;\n\tu32 default_dclk_frq;\n\tbool need_pwm;\n\tbool need_chargepump;\n};\n\nstruct ssd1307fb_par {\n\tunsigned area_color_enable : 1;\n\tunsigned com_invdir : 1;\n\tunsigned com_lrremap : 1;\n\tunsigned com_seq : 1;\n\tunsigned lookup_table_set : 1;\n\tunsigned low_power : 1;\n\tunsigned seg_remap : 1;\n\tu32 com_offset;\n\tu32 contrast;\n\tu32 dclk_div;\n\tu32 dclk_frq;\n\tconst struct ssd1307fb_deviceinfo *device_info;\n\tstruct i2c_client *client;\n\tu32 height;\n\tstruct fb_info *info;\n\tu8 lookup_table[4];\n\tu32 page_offset;\n\tu32 col_offset;\n\tu32 prechargep1;\n\tu32 prechargep2;\n\tstruct pwm_device *pwm;\n\tstruct gpio_desc *reset;\n\tstruct regulator *vbat_reg;\n\tu32 vcomh;\n\tu32 width;\n\t \n\tu8 col_start;\n\tu8 col_end;\n\tu8 page_start;\n\tu8 page_end;\n};\n\nstruct ssd1307fb_array {\n\tu8\ttype;\n\tu8\tdata[];\n};\n\nstatic const struct fb_fix_screeninfo ssd1307fb_fix = {\n\t.id\t\t= \"Solomon SSD1307\",\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.visual\t\t= FB_VISUAL_MONO10,\n\t.xpanstep\t= 0,\n\t.ypanstep\t= 0,\n\t.ywrapstep\t= 0,\n\t.accel\t\t= FB_ACCEL_NONE,\n};\n\nstatic const struct fb_var_screeninfo ssd1307fb_var = {\n\t.bits_per_pixel\t= 1,\n\t.red = { .length = 1 },\n\t.green = { .length = 1 },\n\t.blue = { .length = 1 },\n};\n\nstatic struct ssd1307fb_array *ssd1307fb_alloc_array(u32 len, u8 type)\n{\n\tstruct ssd1307fb_array *array;\n\n\tarray = kzalloc(sizeof(struct ssd1307fb_array) + len, GFP_KERNEL);\n\tif (!array)\n\t\treturn NULL;\n\n\tarray->type = type;\n\n\treturn array;\n}\n\nstatic int ssd1307fb_write_array(struct i2c_client *client,\n\t\t\t\t struct ssd1307fb_array *array, u32 len)\n{\n\tint ret;\n\n\tlen += sizeof(struct ssd1307fb_array);\n\n\tret = i2c_master_send(client, (u8 *)array, len);\n\tif (ret != len) {\n\t\tdev_err(&client->dev, \"Couldn't send I2C command.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int ssd1307fb_write_cmd(struct i2c_client *client, u8 cmd)\n{\n\tstruct ssd1307fb_array *array;\n\tint ret;\n\n\tarray = ssd1307fb_alloc_array(1, SSD1307FB_COMMAND);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tarray->data[0] = cmd;\n\n\tret = ssd1307fb_write_array(client, array, 1);\n\tkfree(array);\n\n\treturn ret;\n}\n\nstatic int ssd1307fb_set_col_range(struct ssd1307fb_par *par, u8 col_start,\n\t\t\t\t   u8 cols)\n{\n\tu8 col_end = col_start + cols - 1;\n\tint ret;\n\n\tif (col_start == par->col_start && col_end == par->col_end)\n\t\treturn 0;\n\n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_SET_COL_RANGE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ssd1307fb_write_cmd(par->client, col_start);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ssd1307fb_write_cmd(par->client, col_end);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpar->col_start = col_start;\n\tpar->col_end = col_end;\n\treturn 0;\n}\n\nstatic int ssd1307fb_set_page_range(struct ssd1307fb_par *par, u8 page_start,\n\t\t\t\t    u8 pages)\n{\n\tu8 page_end = page_start + pages - 1;\n\tint ret;\n\n\tif (page_start == par->page_start && page_end == par->page_end)\n\t\treturn 0;\n\n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_SET_PAGE_RANGE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ssd1307fb_write_cmd(par->client, page_start);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ssd1307fb_write_cmd(par->client, page_end);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpar->page_start = page_start;\n\tpar->page_end = page_end;\n\treturn 0;\n}\n\nstatic int ssd1307fb_update_rect(struct ssd1307fb_par *par, unsigned int x,\n\t\t\t\t unsigned int y, unsigned int width,\n\t\t\t\t unsigned int height)\n{\n\tstruct ssd1307fb_array *array;\n\tu8 *vmem = par->info->screen_buffer;\n\tunsigned int line_length = par->info->fix.line_length;\n\tunsigned int pages = DIV_ROUND_UP(y % 8 + height, 8);\n\tu32 array_idx = 0;\n\tint ret, i, j, k;\n\n\tarray = ssd1307fb_alloc_array(width * pages, SSD1307FB_DATA);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\t \n\n\tret = ssd1307fb_set_col_range(par, par->col_offset + x, width);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tret = ssd1307fb_set_page_range(par, par->page_offset + y / 8, pages);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tfor (i = y / 8; i < y / 8 + pages; i++) {\n\t\tint m = 8;\n\n\t\t \n\t\tif (8 * (i + 1) > par->height)\n\t\t\tm = par->height % 8;\n\t\tfor (j = x; j < x + width; j++) {\n\t\t\tu8 data = 0;\n\n\t\t\tfor (k = 0; k < m; k++) {\n\t\t\t\tu8 byte = vmem[(8 * i + k) * line_length +\n\t\t\t\t\t       j / 8];\n\t\t\t\tu8 bit = (byte >> (j % 8)) & 1;\n\t\t\t\tdata |= bit << k;\n\t\t\t}\n\t\t\tarray->data[array_idx++] = data;\n\t\t}\n\t}\n\n\tret = ssd1307fb_write_array(par->client, array, width * pages);\n\nout_free:\n\tkfree(array);\n\treturn ret;\n}\n\nstatic int ssd1307fb_update_display(struct ssd1307fb_par *par)\n{\n\treturn ssd1307fb_update_rect(par, 0, 0, par->width, par->height);\n}\n\nstatic int ssd1307fb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct ssd1307fb_par *par = info->par;\n\n\tif (blank_mode != FB_BLANK_UNBLANK)\n\t\treturn ssd1307fb_write_cmd(par->client, SSD1307FB_DISPLAY_OFF);\n\telse\n\t\treturn ssd1307fb_write_cmd(par->client, SSD1307FB_DISPLAY_ON);\n}\n\nstatic void ssd1307fb_defio_damage_range(struct fb_info *info, off_t off, size_t len)\n{\n\tstruct ssd1307fb_par *par = info->par;\n\n\tssd1307fb_update_display(par);\n}\n\nstatic void ssd1307fb_defio_damage_area(struct fb_info *info, u32 x, u32 y,\n\t\t\t\t\tu32 width, u32 height)\n{\n\tstruct ssd1307fb_par *par = info->par;\n\n\tssd1307fb_update_rect(par, x, y, width, height);\n}\n\nFB_GEN_DEFAULT_DEFERRED_SYSMEM_OPS(ssd1307fb,\n\t\t\t\t   ssd1307fb_defio_damage_range,\n\t\t\t\t   ssd1307fb_defio_damage_area)\n\nstatic const struct fb_ops ssd1307fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_DEFERRED_OPS(ssd1307fb),\n\t.fb_blank\t= ssd1307fb_blank,\n};\n\nstatic void ssd1307fb_deferred_io(struct fb_info *info, struct list_head *pagereflist)\n{\n\tssd1307fb_update_display(info->par);\n}\n\nstatic int ssd1307fb_init(struct ssd1307fb_par *par)\n{\n\tstruct pwm_state pwmstate;\n\tint ret;\n\tu32 precharge, dclk, com_invdir, compins;\n\n\tif (par->device_info->need_pwm) {\n\t\tpar->pwm = pwm_get(&par->client->dev, NULL);\n\t\tif (IS_ERR(par->pwm)) {\n\t\t\tdev_err(&par->client->dev, \"Could not get PWM from device tree!\\n\");\n\t\t\treturn PTR_ERR(par->pwm);\n\t\t}\n\n\t\tpwm_init_state(par->pwm, &pwmstate);\n\t\tpwm_set_relative_duty_cycle(&pwmstate, 50, 100);\n\t\tpwm_apply_state(par->pwm, &pwmstate);\n\n\t\t \n\t\tpwm_enable(par->pwm);\n\n\t\tdev_dbg(&par->client->dev, \"Using PWM %s with a %lluns period.\\n\",\n\t\t\tpar->pwm->label, pwm_get_period(par->pwm));\n\t}\n\n\t \n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_CONTRAST);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ssd1307fb_write_cmd(par->client, par->contrast);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (par->seg_remap) {\n\t\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_SEG_REMAP_ON);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tcom_invdir = 0xc0 | par->com_invdir << 3;\n\tret = ssd1307fb_write_cmd(par->client,  com_invdir);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_SET_MULTIPLEX_RATIO);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ssd1307fb_write_cmd(par->client, par->height - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_SET_DISPLAY_OFFSET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ssd1307fb_write_cmd(par->client, par->com_offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_SET_CLOCK_FREQ);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdclk = ((par->dclk_div - 1) & 0xf) | (par->dclk_frq & 0xf) << 4;\n\tret = ssd1307fb_write_cmd(par->client, dclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (par->area_color_enable || par->low_power) {\n\t\tu32 mode;\n\n\t\tret = ssd1307fb_write_cmd(par->client,\n\t\t\t\t\t  SSD1307FB_SET_AREA_COLOR_MODE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmode = (par->area_color_enable ? 0x30 : 0) |\n\t\t\t(par->low_power ? 5 : 0);\n\t\tret = ssd1307fb_write_cmd(par->client, mode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_SET_PRECHARGE_PERIOD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tprecharge = (par->prechargep1 & 0xf) | (par->prechargep2 & 0xf) << 4;\n\tret = ssd1307fb_write_cmd(par->client, precharge);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_SET_COM_PINS_CONFIG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcompins = 0x02 | !par->com_seq << 4 | par->com_lrremap << 5;\n\tret = ssd1307fb_write_cmd(par->client, compins);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_SET_VCOMH);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ssd1307fb_write_cmd(par->client, par->vcomh);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_CHARGE_PUMP);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ssd1307fb_write_cmd(par->client,\n\t\tBIT(4) | (par->device_info->need_chargepump ? BIT(2) : 0));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (par->lookup_table_set) {\n\t\tint i;\n\n\t\tret = ssd1307fb_write_cmd(par->client,\n\t\t\t\t\t  SSD1307FB_SET_LOOKUP_TABLE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(par->lookup_table); ++i) {\n\t\t\tu8 val = par->lookup_table[i];\n\n\t\t\tif (val < 31 || val > 63)\n\t\t\t\tdev_warn(&par->client->dev,\n\t\t\t\t\t \"lookup table index %d value out of range 31 <= %d <= 63\\n\",\n\t\t\t\t\t i, val);\n\t\t\tret = ssd1307fb_write_cmd(par->client, val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_SET_ADDRESS_MODE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ssd1307fb_write_cmd(par->client,\n\t\t\t\t  SSD1307FB_SET_ADDRESS_MODE_HORIZONTAL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ssd1307fb_update_display(par);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_DISPLAY_ON);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ssd1307fb_update_bl(struct backlight_device *bdev)\n{\n\tstruct ssd1307fb_par *par = bl_get_data(bdev);\n\tint ret;\n\tint brightness = bdev->props.brightness;\n\n\tpar->contrast = brightness;\n\n\tret = ssd1307fb_write_cmd(par->client, SSD1307FB_CONTRAST);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ssd1307fb_write_cmd(par->client, par->contrast);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int ssd1307fb_get_brightness(struct backlight_device *bdev)\n{\n\tstruct ssd1307fb_par *par = bl_get_data(bdev);\n\n\treturn par->contrast;\n}\n\nstatic int ssd1307fb_check_fb(struct backlight_device *bdev,\n\t\t\t\t   struct fb_info *info)\n{\n\treturn (info->bl_dev == bdev);\n}\n\nstatic const struct backlight_ops ssd1307fb_bl_ops = {\n\t.options\t= BL_CORE_SUSPENDRESUME,\n\t.update_status\t= ssd1307fb_update_bl,\n\t.get_brightness\t= ssd1307fb_get_brightness,\n\t.check_fb\t= ssd1307fb_check_fb,\n};\n\nstatic struct ssd1307fb_deviceinfo ssd1307fb_ssd1305_deviceinfo = {\n\t.default_vcomh = 0x34,\n\t.default_dclk_div = 1,\n\t.default_dclk_frq = 7,\n};\n\nstatic struct ssd1307fb_deviceinfo ssd1307fb_ssd1306_deviceinfo = {\n\t.default_vcomh = 0x20,\n\t.default_dclk_div = 1,\n\t.default_dclk_frq = 8,\n\t.need_chargepump = 1,\n};\n\nstatic struct ssd1307fb_deviceinfo ssd1307fb_ssd1307_deviceinfo = {\n\t.default_vcomh = 0x20,\n\t.default_dclk_div = 2,\n\t.default_dclk_frq = 12,\n\t.need_pwm = 1,\n};\n\nstatic struct ssd1307fb_deviceinfo ssd1307fb_ssd1309_deviceinfo = {\n\t.default_vcomh = 0x34,\n\t.default_dclk_div = 1,\n\t.default_dclk_frq = 10,\n};\n\nstatic const struct of_device_id ssd1307fb_of_match[] = {\n\t{\n\t\t.compatible = \"solomon,ssd1305fb-i2c\",\n\t\t.data = (void *)&ssd1307fb_ssd1305_deviceinfo,\n\t},\n\t{\n\t\t.compatible = \"solomon,ssd1306fb-i2c\",\n\t\t.data = (void *)&ssd1307fb_ssd1306_deviceinfo,\n\t},\n\t{\n\t\t.compatible = \"solomon,ssd1307fb-i2c\",\n\t\t.data = (void *)&ssd1307fb_ssd1307_deviceinfo,\n\t},\n\t{\n\t\t.compatible = \"solomon,ssd1309fb-i2c\",\n\t\t.data = (void *)&ssd1307fb_ssd1309_deviceinfo,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ssd1307fb_of_match);\n\nstatic int ssd1307fb_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct backlight_device *bl;\n\tchar bl_name[12];\n\tstruct fb_info *info;\n\tstruct fb_deferred_io *ssd1307fb_defio;\n\tu32 vmem_size;\n\tstruct ssd1307fb_par *par;\n\tvoid *vmem;\n\tint ret;\n\n\tinfo = framebuffer_alloc(sizeof(struct ssd1307fb_par), dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tpar->info = info;\n\tpar->client = client;\n\n\tpar->device_info = device_get_match_data(dev);\n\n\tpar->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(par->reset)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(par->reset),\n\t\t\t\t    \"failed to get reset gpio\\n\");\n\t\tgoto fb_alloc_error;\n\t}\n\n\tpar->vbat_reg = devm_regulator_get_optional(dev, \"vbat\");\n\tif (IS_ERR(par->vbat_reg)) {\n\t\tret = PTR_ERR(par->vbat_reg);\n\t\tif (ret == -ENODEV) {\n\t\t\tpar->vbat_reg = NULL;\n\t\t} else {\n\t\t\tdev_err_probe(dev, ret, \"failed to get VBAT regulator\\n\");\n\t\t\tgoto fb_alloc_error;\n\t\t}\n\t}\n\n\tif (device_property_read_u32(dev, \"solomon,width\", &par->width))\n\t\tpar->width = 96;\n\n\tif (device_property_read_u32(dev, \"solomon,height\", &par->height))\n\t\tpar->height = 16;\n\n\tif (device_property_read_u32(dev, \"solomon,page-offset\", &par->page_offset))\n\t\tpar->page_offset = 1;\n\n\tif (device_property_read_u32(dev, \"solomon,col-offset\", &par->col_offset))\n\t\tpar->col_offset = 0;\n\n\tif (device_property_read_u32(dev, \"solomon,com-offset\", &par->com_offset))\n\t\tpar->com_offset = 0;\n\n\tif (device_property_read_u32(dev, \"solomon,prechargep1\", &par->prechargep1))\n\t\tpar->prechargep1 = 2;\n\n\tif (device_property_read_u32(dev, \"solomon,prechargep2\", &par->prechargep2))\n\t\tpar->prechargep2 = 2;\n\n\tif (!device_property_read_u8_array(dev, \"solomon,lookup-table\",\n\t\t\t\t\t   par->lookup_table,\n\t\t\t\t\t   ARRAY_SIZE(par->lookup_table)))\n\t\tpar->lookup_table_set = 1;\n\n\tpar->seg_remap = !device_property_read_bool(dev, \"solomon,segment-no-remap\");\n\tpar->com_seq = device_property_read_bool(dev, \"solomon,com-seq\");\n\tpar->com_lrremap = device_property_read_bool(dev, \"solomon,com-lrremap\");\n\tpar->com_invdir = device_property_read_bool(dev, \"solomon,com-invdir\");\n\tpar->area_color_enable =\n\t\tdevice_property_read_bool(dev, \"solomon,area-color-enable\");\n\tpar->low_power = device_property_read_bool(dev, \"solomon,low-power\");\n\n\tpar->contrast = 127;\n\tpar->vcomh = par->device_info->default_vcomh;\n\n\t \n\tif (device_property_read_u32(dev, \"solomon,dclk-div\", &par->dclk_div))\n\t\tpar->dclk_div = par->device_info->default_dclk_div;\n\tif (device_property_read_u32(dev, \"solomon,dclk-frq\", &par->dclk_frq))\n\t\tpar->dclk_frq = par->device_info->default_dclk_frq;\n\n\tvmem_size = DIV_ROUND_UP(par->width, 8) * par->height;\n\n\tvmem = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\tget_order(vmem_size));\n\tif (!vmem) {\n\t\tdev_err(dev, \"Couldn't allocate graphical memory.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fb_alloc_error;\n\t}\n\n\tssd1307fb_defio = devm_kzalloc(dev, sizeof(*ssd1307fb_defio),\n\t\t\t\t       GFP_KERNEL);\n\tif (!ssd1307fb_defio) {\n\t\tdev_err(dev, \"Couldn't allocate deferred io.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fb_alloc_error;\n\t}\n\n\tssd1307fb_defio->delay = HZ / refreshrate;\n\tssd1307fb_defio->deferred_io = ssd1307fb_deferred_io;\n\n\tinfo->fbops = &ssd1307fb_ops;\n\tinfo->fix = ssd1307fb_fix;\n\tinfo->fix.line_length = DIV_ROUND_UP(par->width, 8);\n\tinfo->fbdefio = ssd1307fb_defio;\n\n\tinfo->var = ssd1307fb_var;\n\tinfo->var.xres = par->width;\n\tinfo->var.xres_virtual = par->width;\n\tinfo->var.yres = par->height;\n\tinfo->var.yres_virtual = par->height;\n\n\tinfo->screen_buffer = vmem;\n\tinfo->fix.smem_start = __pa(vmem);\n\tinfo->fix.smem_len = vmem_size;\n\n\tfb_deferred_io_init(info);\n\n\ti2c_set_clientdata(client, info);\n\n\tif (par->reset) {\n\t\t \n\t\tgpiod_set_value_cansleep(par->reset, 1);\n\t\tudelay(4);\n\t\tgpiod_set_value_cansleep(par->reset, 0);\n\t\tudelay(4);\n\t}\n\n\tif (par->vbat_reg) {\n\t\tret = regulator_enable(par->vbat_reg);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable VBAT: %d\\n\", ret);\n\t\t\tgoto reset_oled_error;\n\t\t}\n\t}\n\n\tret = ssd1307fb_init(par);\n\tif (ret)\n\t\tgoto regulator_enable_error;\n\n\tret = register_framebuffer(info);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't register the framebuffer\\n\");\n\t\tgoto panel_init_error;\n\t}\n\n\tsnprintf(bl_name, sizeof(bl_name), \"ssd1307fb%d\", info->node);\n\tbl = backlight_device_register(bl_name, dev, par, &ssd1307fb_bl_ops,\n\t\t\t\t       NULL);\n\tif (IS_ERR(bl)) {\n\t\tret = PTR_ERR(bl);\n\t\tdev_err(dev, \"unable to register backlight device: %d\\n\", ret);\n\t\tgoto bl_init_error;\n\t}\n\n\tbl->props.brightness = par->contrast;\n\tbl->props.max_brightness = MAX_CONTRAST;\n\tinfo->bl_dev = bl;\n\n\tdev_info(dev, \"fb%d: %s framebuffer device registered, using %d bytes of video memory\\n\", info->node, info->fix.id, vmem_size);\n\n\treturn 0;\n\nbl_init_error:\n\tunregister_framebuffer(info);\npanel_init_error:\n\tpwm_disable(par->pwm);\n\tpwm_put(par->pwm);\nregulator_enable_error:\n\tif (par->vbat_reg)\n\t\tregulator_disable(par->vbat_reg);\nreset_oled_error:\n\tfb_deferred_io_cleanup(info);\nfb_alloc_error:\n\tframebuffer_release(info);\n\treturn ret;\n}\n\nstatic void ssd1307fb_remove(struct i2c_client *client)\n{\n\tstruct fb_info *info = i2c_get_clientdata(client);\n\tstruct ssd1307fb_par *par = info->par;\n\n\tssd1307fb_write_cmd(par->client, SSD1307FB_DISPLAY_OFF);\n\n\tbacklight_device_unregister(info->bl_dev);\n\n\tunregister_framebuffer(info);\n\tpwm_disable(par->pwm);\n\tpwm_put(par->pwm);\n\tif (par->vbat_reg)\n\t\tregulator_disable(par->vbat_reg);\n\tfb_deferred_io_cleanup(info);\n\t__free_pages(__va(info->fix.smem_start), get_order(info->fix.smem_len));\n\tframebuffer_release(info);\n}\n\nstatic const struct i2c_device_id ssd1307fb_i2c_id[] = {\n\t{ \"ssd1305fb\", 0 },\n\t{ \"ssd1306fb\", 0 },\n\t{ \"ssd1307fb\", 0 },\n\t{ \"ssd1309fb\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ssd1307fb_i2c_id);\n\nstatic struct i2c_driver ssd1307fb_driver = {\n\t.probe = ssd1307fb_probe,\n\t.remove = ssd1307fb_remove,\n\t.id_table = ssd1307fb_i2c_id,\n\t.driver = {\n\t\t.name = \"ssd1307fb\",\n\t\t.of_match_table = ssd1307fb_of_match,\n\t},\n};\n\nmodule_i2c_driver(ssd1307fb_driver);\n\nMODULE_DESCRIPTION(\"FB driver for the Solomon SSD1307 OLED controller\");\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}