{
  "module_name": "pvr2fb.c",
  "hash_id": "f337fe2937de69a35de1b4aee85cb50321fd5cd6907c9f5de93d93b27730aacd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/pvr2fb.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n\n#ifdef CONFIG_SH_DREAMCAST\n#include <asm/machvec.h>\n#include <mach-dreamcast/mach/sysasic.h>\n#endif\n\n#ifdef CONFIG_PVR2_DMA\n#include <linux/pagemap.h>\n#include <mach/dma.h>\n#include <asm/dma.h>\n#endif\n\n#ifdef CONFIG_SH_STORE_QUEUES\n#include <linux/uaccess.h>\n#include <cpu/sq.h>\n#endif\n\n#ifndef PCI_DEVICE_ID_NEC_NEON250\n#  define PCI_DEVICE_ID_NEC_NEON250\t0x0067\n#endif\n\n \n#define DISP_BASE\tpar->mmio_base\n#define DISP_BRDRCOLR (DISP_BASE + 0x40)\n#define DISP_DIWMODE (DISP_BASE + 0x44)\n#define DISP_DIWADDRL (DISP_BASE + 0x50)\n#define DISP_DIWADDRS (DISP_BASE + 0x54)\n#define DISP_DIWSIZE (DISP_BASE + 0x5c)\n#define DISP_SYNCCONF (DISP_BASE + 0xd0)\n#define DISP_BRDRHORZ (DISP_BASE + 0xd4)\n#define DISP_SYNCSIZE (DISP_BASE + 0xd8)\n#define DISP_BRDRVERT (DISP_BASE + 0xdc)\n#define DISP_DIWCONF (DISP_BASE + 0xe8)\n#define DISP_DIWHSTRT (DISP_BASE + 0xec)\n#define DISP_DIWVSTRT (DISP_BASE + 0xf0)\n#define DISP_PIXDEPTH (DISP_BASE + 0x108)\n\n \n#define TV_CLK 74239\n#define VGA_CLK 37119\n\n \n#define PAL_HTOTAL 863\n#define PAL_VTOTAL 312\n#define NTSC_HTOTAL 857\n#define NTSC_VTOTAL 262\n\n \nenum { CT_VGA, CT_NONE, CT_RGB, CT_COMPOSITE };\n\n \nenum { VO_PAL, VO_NTSC, VO_VGA };\n\n \nenum { PAL_ARGB1555, PAL_RGB565, PAL_ARGB4444, PAL_ARGB8888 };\n\nstruct pvr2_params { unsigned int val; char *name; };\nstatic struct pvr2_params cables[] = {\n\t{ CT_VGA, \"VGA\" }, { CT_RGB, \"RGB\" }, { CT_COMPOSITE, \"COMPOSITE\" },\n};\n\nstatic struct pvr2_params outputs[] = {\n\t{ VO_PAL, \"PAL\" }, { VO_NTSC, \"NTSC\" }, { VO_VGA, \"VGA\" },\n};\n\n \n\nstatic struct pvr2fb_par {\n\tunsigned int hsync_total;\t \n\tunsigned int vsync_total;\t \n\tunsigned int borderstart_h;\n\tunsigned int borderstop_h;\n\tunsigned int borderstart_v;\n\tunsigned int borderstop_v;\n\tunsigned int diwstart_h;\t \n\tunsigned int diwstart_v;\t \n\tunsigned long disp_start;\t \n\tunsigned char is_interlaced;\t \n\tunsigned char is_doublescan;\t \n\tunsigned char is_lowres;\t \n\n\tvoid __iomem *mmio_base;\t \n\tu32 palette[16];\n} *currentpar;\n\nstatic struct fb_info *fb_info;\n\nstatic struct fb_fix_screeninfo pvr2_fix = {\n\t.id =\t\t\"NEC PowerVR2\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_TRUECOLOR,\n\t.ypanstep =\t1,\n\t.ywrapstep =\t1,\n\t.accel =\tFB_ACCEL_NONE,\n};\n\nstatic const struct fb_var_screeninfo pvr2_var = {\n\t.xres =\t\t640,\n\t.yres =\t\t480,\n\t.xres_virtual =\t640,\n\t.yres_virtual = 480,\n\t.bits_per_pixel\t=16,\n\t.red =\t\t{ 11, 5, 0 },\n\t.green =\t{  5, 6, 0 },\n\t.blue =\t\t{  0, 5, 0 },\n\t.activate =\tFB_ACTIVATE_NOW,\n\t.height =\t-1,\n\t.width =\t-1,\n\t.vmode =\tFB_VMODE_NONINTERLACED,\n};\n\nstatic int cable_type = CT_VGA;\nstatic int video_output = VO_VGA;\n\nstatic int nopan = 0;\nstatic int nowrap = 1;\n\n \nstatic unsigned int do_vmode_full = 0;\t \nstatic unsigned int do_vmode_pan = 0;\t \nstatic short do_blank = 0;\t\t \n\nstatic unsigned int is_blanked = 0;\t\t \n\n#ifdef CONFIG_SH_STORE_QUEUES\nstatic unsigned long pvr2fb_map;\n#endif\n\n#ifdef CONFIG_PVR2_DMA\nstatic unsigned int shdma = PVR2_CASCADE_CHAN;\nstatic unsigned int pvr2dma = ONCHIP_NR_DMA_CHANNELS;\n#endif\n\nstatic struct fb_videomode pvr2_modedb[] = {\n     \n\n    {\n\t \n\t\"ntsc_640x480i\", 60, 640, 480, TV_CLK, 38, 33, 0, 18, 146, 26,\n\tFB_SYNC_BROADCAST, FB_VMODE_INTERLACED | FB_VMODE_YWRAP\n    }, {\n\t \n\t \n\t\"ntsc_640x240\", 60, 640, 240, TV_CLK, 38, 33, 0, 0, 146, 22,\n\tFB_SYNC_BROADCAST, FB_VMODE_YWRAP\n    }, {\n\t \n\t\"vga_640x480\", 60, 640, 480, VGA_CLK, 38, 33, 0, 18, 146, 26,\n\t0, FB_VMODE_YWRAP\n    },\n};\n\n#define NUM_TOTAL_MODES  ARRAY_SIZE(pvr2_modedb)\n\n#define DEFMODE_NTSC\t0\n#define DEFMODE_PAL\t0\n#define DEFMODE_VGA\t2\n\nstatic int defmode = DEFMODE_NTSC;\nstatic char *mode_option = NULL;\n\nstatic inline void pvr2fb_set_pal_type(unsigned int type)\n{\n\tstruct pvr2fb_par *par = (struct pvr2fb_par *)fb_info->par;\n\n\tfb_writel(type, par->mmio_base + 0x108);\n}\n\nstatic inline void pvr2fb_set_pal_entry(struct pvr2fb_par *par,\n\t\t\t\t\tunsigned int regno,\n\t\t\t\t\tunsigned int val)\n{\n\tfb_writel(val, par->mmio_base + 0x1000 + (4 * regno));\n}\n\nstatic int pvr2fb_blank(int blank, struct fb_info *info)\n{\n\tdo_blank = blank ? blank : -1;\n\treturn 0;\n}\n\nstatic inline unsigned long get_line_length(int xres_virtual, int bpp)\n{\n\treturn (unsigned long)((((xres_virtual*bpp)+31)&~31) >> 3);\n}\n\nstatic void set_color_bitfields(struct fb_var_screeninfo *var)\n{\n\tswitch (var->bits_per_pixel) {\n\t    case 16:         \n\t\tpvr2fb_set_pal_type(PAL_RGB565);\n\t\tvar->red.offset = 11;    var->red.length = 5;\n\t\tvar->green.offset = 5;   var->green.length = 6;\n\t\tvar->blue.offset = 0;    var->blue.length = 5;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\t    case 24:         \n\t\tvar->red.offset = 16;    var->red.length = 8;\n\t\tvar->green.offset = 8;   var->green.length = 8;\n\t\tvar->blue.offset = 0;    var->blue.length = 8;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\t    case 32:         \n\t\tpvr2fb_set_pal_type(PAL_ARGB8888);\n\t\tvar->red.offset = 16;    var->red.length = 8;\n\t\tvar->green.offset = 8;   var->green.length = 8;\n\t\tvar->blue.offset = 0;    var->blue.length = 8;\n\t\tvar->transp.offset = 24; var->transp.length = 8;\n\t\tbreak;\n\t}\n}\n\nstatic int pvr2fb_setcolreg(unsigned int regno, unsigned int red,\n\t\t\t    unsigned int green, unsigned int blue,\n                            unsigned int transp, struct fb_info *info)\n{\n\tstruct pvr2fb_par *par = (struct pvr2fb_par *)info->par;\n\tunsigned int tmp;\n\n\tif (regno > info->cmap.len)\n\t\treturn 1;\n\n\t \n\tswitch (info->var.bits_per_pixel) {\n\t    case 16:  \n\t\ttmp =  (red   & 0xf800)       |\n\t\t      ((green & 0xfc00) >> 5) |\n\t\t      ((blue  & 0xf800) >> 11);\n\n\t\tpvr2fb_set_pal_entry(par, regno, tmp);\n\t\tbreak;\n\t    case 24:  \n\t\tred >>= 8; green >>= 8; blue >>= 8;\n\t\ttmp = (red << 16) | (green << 8) | blue;\n\t\tbreak;\n\t    case 32:  \n\t\tred >>= 8; green >>= 8; blue >>= 8;\n\t\ttmp = (transp << 24) | (red << 16) | (green << 8) | blue;\n\n\t\tpvr2fb_set_pal_entry(par, regno, tmp);\n\t\tbreak;\n\t    default:\n\t\tpr_debug(\"Invalid bit depth %d?!?\\n\", info->var.bits_per_pixel);\n\t\treturn 1;\n\t}\n\n\tif (regno < 16)\n\t\t((u32*)(info->pseudo_palette))[regno] = tmp;\n\n\treturn 0;\n}\n\n \n\n#define PCTRA ((void __iomem *)0xff80002c)\n#define PDTRA ((void __iomem *)0xff800030)\n#define VOUTC ((void __iomem *)0xa0702c00)\n\nstatic int pvr2_init_cable(void)\n{\n\tif (cable_type < 0) {\n\t\tfb_writel((fb_readl(PCTRA) & 0xfff0ffff) | 0x000a0000,\n\t                  PCTRA);\n\t\tcable_type = (fb_readw(PDTRA) >> 8) & 3;\n\t}\n\n\t \n\t \n\tif (cable_type == CT_COMPOSITE)\n\t\tfb_writel(3 << 8, VOUTC);\n\telse if (cable_type == CT_RGB)\n\t\tfb_writel(1 << 9, VOUTC);\n\telse\n\t\tfb_writel(0, VOUTC);\n\n\treturn cable_type;\n}\n\nstatic int pvr2fb_set_par(struct fb_info *info)\n{\n\tstruct pvr2fb_par *par = (struct pvr2fb_par *)info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tunsigned long line_length;\n\tunsigned int vtotal;\n\n\t \n\tcable_type = pvr2_init_cable();\n\tif (cable_type == CT_VGA && video_output != VO_VGA)\n\t\tvideo_output = VO_VGA;\n\n\tvar->vmode &= FB_VMODE_MASK;\n\tif (var->vmode & FB_VMODE_INTERLACED && video_output != VO_VGA)\n\t\tpar->is_interlaced = 1;\n\t \n\tif (var->vmode & FB_VMODE_DOUBLE && video_output == VO_VGA)\n\t\tpar->is_doublescan = 1;\n\n\tpar->hsync_total = var->left_margin + var->xres + var->right_margin +\n\t                   var->hsync_len;\n\tpar->vsync_total = var->upper_margin + var->yres + var->lower_margin +\n\t                   var->vsync_len;\n\n\tif (var->sync & FB_SYNC_BROADCAST) {\n\t\tvtotal = par->vsync_total;\n\t\tif (par->is_interlaced)\n\t\t\tvtotal /= 2;\n\t\tif (vtotal > (PAL_VTOTAL + NTSC_VTOTAL)/2) {\n\t\t\t \n\t\t\t \n\t\t\tpar->borderstart_h = 116;\n\t\t\tpar->borderstart_v = 44;\n\t\t} else {\n\t\t\t \n\t\t\tpar->borderstart_h = 126;\n\t\t\tpar->borderstart_v = 18;\n\t\t}\n\t} else {\n\t\t \n\t\t \n\t\t \n\t\tpar->borderstart_h = 126;\n\t\tpar->borderstart_v = 40;\n\t}\n\n\t \n\tpar->diwstart_h = par->borderstart_h + var->left_margin;\n\tpar->diwstart_v = par->borderstart_v + var->upper_margin;\n\tpar->borderstop_h = par->diwstart_h + var->xres +\n\t\t\t    var->right_margin;\n\tpar->borderstop_v = par->diwstart_v + var->yres +\n\t\t\t    var->lower_margin;\n\n\tif (!par->is_interlaced)\n\t\tpar->borderstop_v /= 2;\n\tif (info->var.xres < 640)\n\t\tpar->is_lowres = 1;\n\n\tline_length = get_line_length(var->xres_virtual, var->bits_per_pixel);\n\tpar->disp_start = info->fix.smem_start + (line_length * var->yoffset) * line_length;\n\tinfo->fix.line_length = line_length;\n\treturn 0;\n}\n\nstatic int pvr2fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct pvr2fb_par *par = (struct pvr2fb_par *)info->par;\n\tunsigned int vtotal, hsync_total;\n\tunsigned long line_length;\n\n\tif (var->pixclock != TV_CLK && var->pixclock != VGA_CLK) {\n\t\tpr_debug(\"Invalid pixclock value %d\\n\", var->pixclock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->xres < 320)\n\t\tvar->xres = 320;\n\tif (var->yres < 240)\n\t\tvar->yres = 240;\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres_virtual = var->yres;\n\n\tif (var->bits_per_pixel <= 16)\n\t\tvar->bits_per_pixel = 16;\n\telse if (var->bits_per_pixel <= 24)\n\t\tvar->bits_per_pixel = 24;\n\telse if (var->bits_per_pixel <= 32)\n\t\tvar->bits_per_pixel = 32;\n\n\tset_color_bitfields(var);\n\n\tif (var->vmode & FB_VMODE_YWRAP) {\n\t\tif (var->xoffset || var->yoffset >= var->yres_virtual) {\n\t\t\tvar->xoffset = var->yoffset = 0;\n\t\t} else {\n\t\t\tif (var->xoffset > var->xres_virtual - var->xres ||\n\t\t\t    var->yoffset > var->yres_virtual - var->yres)\n\t\t\t\tvar->xoffset = var->yoffset = 0;\n\t\t}\n\t} else {\n\t\tvar->xoffset = var->yoffset = 0;\n\t}\n\n\t \n\tif (var->yres < 480 && video_output == VO_VGA)\n\t\tvar->vmode |= FB_VMODE_DOUBLE;\n\n\tif (video_output != VO_VGA) {\n\t\tvar->sync |= FB_SYNC_BROADCAST;\n\t\tvar->vmode |= FB_VMODE_INTERLACED;\n\t} else {\n\t\tvar->sync &= ~FB_SYNC_BROADCAST;\n\t\tvar->vmode &= ~FB_VMODE_INTERLACED;\n\t\tvar->vmode |= FB_VMODE_NONINTERLACED;\n\t}\n\n\tif ((var->activate & FB_ACTIVATE_MASK) != FB_ACTIVATE_TEST) {\n\t\tvar->right_margin = par->borderstop_h -\n\t\t\t\t   (par->diwstart_h + var->xres);\n\t\tvar->left_margin  = par->diwstart_h - par->borderstart_h;\n\t\tvar->hsync_len    = par->borderstart_h +\n\t\t                   (par->hsync_total - par->borderstop_h);\n\n\t\tvar->upper_margin = par->diwstart_v - par->borderstart_v;\n\t\tvar->lower_margin = par->borderstop_v -\n\t\t\t\t   (par->diwstart_v + var->yres);\n\t\tvar->vsync_len    = par->borderstop_v +\n\t\t\t\t   (par->vsync_total - par->borderstop_v);\n\t}\n\n\thsync_total = var->left_margin + var->xres + var->right_margin +\n\t\t      var->hsync_len;\n\tvtotal = var->upper_margin + var->yres + var->lower_margin +\n\t\t var->vsync_len;\n\n\tif (var->sync & FB_SYNC_BROADCAST) {\n\t\tif (var->vmode & FB_VMODE_INTERLACED)\n\t\t\tvtotal /= 2;\n\t\tif (vtotal > (PAL_VTOTAL + NTSC_VTOTAL)/2) {\n\t\t\t \n\t\t\t \n\t\t\tif (hsync_total != PAL_HTOTAL) {\n\t\t\t\tpr_debug(\"invalid hsync total for PAL\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (hsync_total != NTSC_HTOTAL) {\n\t\t\t\tpr_debug(\"invalid hsync total for NTSC\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tline_length = get_line_length(var->xres_virtual, var->bits_per_pixel);\n\tif (line_length * var->yres_virtual > info->fix.smem_len)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void pvr2_update_display(struct fb_info *info)\n{\n\tstruct pvr2fb_par *par = (struct pvr2fb_par *) info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\n\t \n\tfb_writel(par->disp_start, DISP_DIWADDRL);\n\tfb_writel(par->disp_start +\n\t\t  get_line_length(var->xoffset+var->xres, var->bits_per_pixel),\n\t          DISP_DIWADDRS);\n}\n\n \n\nstatic void pvr2_init_display(struct fb_info *info)\n{\n\tstruct pvr2fb_par *par = (struct pvr2fb_par *) info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tunsigned int diw_height, diw_width, diw_modulo = 1;\n\tunsigned int bytesperpixel = var->bits_per_pixel >> 3;\n\n\t \n\tfb_writel((par->vsync_total << 16) | par->hsync_total, DISP_SYNCSIZE);\n\n\t \n\t \n\tif (video_output != VO_VGA && par->is_interlaced)\n\t\tdiw_modulo += info->fix.line_length / 4;\n\tdiw_height = (par->is_interlaced ? var->yres / 2 : var->yres);\n\tdiw_width = get_line_length(var->xres, var->bits_per_pixel) / 4;\n\tfb_writel((diw_modulo << 20) | (--diw_height << 10) | --diw_width,\n\t          DISP_DIWSIZE);\n\n\t \n\tfb_writel(par->disp_start, DISP_DIWADDRL);\n\tfb_writel(par->disp_start +\n\t          get_line_length(var->xoffset+var->xres, var->bits_per_pixel),\n\t          DISP_DIWADDRS);\n\n\t \n\tfb_writel((par->borderstart_h << 16) | par->borderstop_h, DISP_BRDRHORZ);\n\tfb_writel((par->borderstart_v << 16) | par->borderstop_v, DISP_BRDRVERT);\n\tfb_writel(0, DISP_BRDRCOLR);\n\n\t \n\tfb_writel(par->diwstart_h, DISP_DIWHSTRT);\n\tfb_writel((par->diwstart_v << 16) | par->diwstart_v, DISP_DIWVSTRT);\n\n\t \n\tfb_writel((0x16 << 16) | par->is_lowres, DISP_DIWCONF);\n\n\t \n\tfb_writel(((video_output == VO_VGA) << 23) |\n\t          (par->is_doublescan << 1) | 1, DISP_DIWMODE);\n\n\t \n\tfb_writel(fb_readl(DISP_DIWMODE) | (--bytesperpixel << 2), DISP_DIWMODE);\n\tfb_writel(bytesperpixel << 2, DISP_PIXDEPTH);\n\n\t \n\tfb_writel(0x100 | ((par->is_interlaced  ) << 4), DISP_SYNCCONF);\n}\n\n \n\n#define BLANK_BIT (1<<3)\n\nstatic void pvr2_do_blank(void)\n{\n\tstruct pvr2fb_par *par = currentpar;\n\tunsigned long diwconf;\n\n\tdiwconf = fb_readl(DISP_DIWCONF);\n\tif (do_blank > 0)\n\t\tfb_writel(diwconf | BLANK_BIT, DISP_DIWCONF);\n\telse\n\t\tfb_writel(diwconf & ~BLANK_BIT, DISP_DIWCONF);\n\n\tis_blanked = do_blank > 0 ? do_blank : 0;\n}\n\nstatic irqreturn_t __maybe_unused pvr2fb_interrupt(int irq, void *dev_id)\n{\n\tstruct fb_info *info = dev_id;\n\n\tif (do_vmode_pan || do_vmode_full)\n\t\tpvr2_update_display(info);\n\tif (do_vmode_full)\n\t\tpvr2_init_display(info);\n\tif (do_vmode_pan)\n\t\tdo_vmode_pan = 0;\n\tif (do_vmode_full)\n\t\tdo_vmode_full = 0;\n\tif (do_blank) {\n\t\tpvr2_do_blank();\n\t\tdo_blank = 0;\n\t}\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_PVR2_DMA\nstatic ssize_t pvr2fb_write(struct fb_info *info, const char *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tunsigned long dst, start, end, len;\n\tunsigned int nr_pages;\n\tstruct page **pages;\n\tint ret, i;\n\n\tif (!info->screen_base)\n\t\treturn -ENODEV;\n\n\tnr_pages = (count + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\tpages = kmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tret = pin_user_pages_fast((unsigned long)buf, nr_pages, FOLL_WRITE, pages);\n\tif (ret < nr_pages) {\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tnr_pages = 0;\n\t\t} else {\n\t\t\tnr_pages = ret;\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto out_unmap;\n\t}\n\n\tdma_configure_channel(shdma, 0x12c1);\n\n\tdst   = (unsigned long)fb_info->screen_base + *ppos;\n\tstart = (unsigned long)page_address(pages[0]);\n\tend   = (unsigned long)page_address(pages[nr_pages]);\n\tlen   = nr_pages << PAGE_SHIFT;\n\n\t \n\tif (start + len == end) {\n\t\t \n\t\tif ((*ppos + len) > fb_info->fix.smem_len) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\tdma_write(shdma, start, 0, len);\n\t\tdma_write(pvr2dma, 0, dst, len);\n\t\tdma_wait_for_completion(pvr2dma);\n\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < nr_pages; i++, dst += PAGE_SIZE) {\n\t\tif ((*ppos + (i << PAGE_SHIFT)) > fb_info->fix.smem_len) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\tdma_write_page(shdma, (unsigned long)page_address(pages[i]), 0);\n\t\tdma_write_page(pvr2dma, 0, dst);\n\t\tdma_wait_for_completion(pvr2dma);\n\t}\n\nout:\n\t*ppos += count;\n\tret = count;\n\nout_unmap:\n\tunpin_user_pages(pages, nr_pages);\n\tkfree(pages);\n\n\treturn ret;\n}\n#endif  \n\nstatic const struct fb_ops pvr2fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_setcolreg\t= pvr2fb_setcolreg,\n\t.fb_blank\t= pvr2fb_blank,\n\t.fb_check_var\t= pvr2fb_check_var,\n\t.fb_set_par\t= pvr2fb_set_par,\n#ifdef CONFIG_PVR2_DMA\n\t.fb_write\t= pvr2fb_write,\n#endif\n\t.fb_fillrect\t= cfb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n};\n\n#ifndef MODULE\nstatic int pvr2_get_param_val(const struct pvr2_params *p, const char *s,\n\t\t\t      int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (!strncasecmp(p[i].name, s, strlen(s)))\n\t\t\treturn p[i].val;\n\t}\n\treturn -1;\n}\n#endif\n\nstatic char *pvr2_get_param_name(const struct pvr2_params *p, int val,\n\t\t\t  int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (p[i].val == val)\n\t\t\treturn p[i].name;\n\t}\n\treturn NULL;\n}\n\n \nstatic int __maybe_unused pvr2fb_common_init(void)\n{\n\tstruct pvr2fb_par *par = currentpar;\n\tunsigned long modememused, rev;\n\n\tfb_info->screen_base = ioremap(pvr2_fix.smem_start,\n\t\t\t\t\t       pvr2_fix.smem_len);\n\n\tif (!fb_info->screen_base) {\n\t\tprintk(KERN_ERR \"pvr2fb: Failed to remap smem space\\n\");\n\t\tgoto out_err;\n\t}\n\n\tpar->mmio_base = ioremap(pvr2_fix.mmio_start,\n\t\t\t\t\t pvr2_fix.mmio_len);\n\tif (!par->mmio_base) {\n\t\tprintk(KERN_ERR \"pvr2fb: Failed to remap mmio space\\n\");\n\t\tgoto out_err;\n\t}\n\n\tfb_memset_io(fb_info->screen_base, 0, pvr2_fix.smem_len);\n\n\tpvr2_fix.ypanstep\t= nopan  ? 0 : 1;\n\tpvr2_fix.ywrapstep\t= nowrap ? 0 : 1;\n\n\tfb_info->fbops\t\t= &pvr2fb_ops;\n\tfb_info->fix\t\t= pvr2_fix;\n\tfb_info->par\t\t= currentpar;\n\tfb_info->pseudo_palette\t= currentpar->palette;\n\tfb_info->flags\t\t= FBINFO_HWACCEL_YPAN;\n\n\tif (video_output == VO_VGA)\n\t\tdefmode = DEFMODE_VGA;\n\n\tif (!mode_option)\n\t\tmode_option = \"640x480@60\";\n\n\tif (!fb_find_mode(&fb_info->var, fb_info, mode_option, pvr2_modedb,\n\t                  NUM_TOTAL_MODES, &pvr2_modedb[defmode], 16))\n\t\tfb_info->var = pvr2_var;\n\n\tfb_alloc_cmap(&fb_info->cmap, 256, 0);\n\n\tif (register_framebuffer(fb_info) < 0)\n\t\tgoto out_err;\n\t \n\tpvr2_init_display(fb_info);\n\n\tmodememused = get_line_length(fb_info->var.xres_virtual,\n\t\t\t\t      fb_info->var.bits_per_pixel);\n\tmodememused *= fb_info->var.yres_virtual;\n\n\trev = fb_readl(par->mmio_base + 0x04);\n\n\tfb_info(fb_info, \"%s (rev %ld.%ld) frame buffer device, using %ldk/%ldk of video memory\\n\",\n\t\tfb_info->fix.id, (rev >> 4) & 0x0f, rev & 0x0f,\n\t\tmodememused >> 10,\n\t\t(unsigned long)(fb_info->fix.smem_len >> 10));\n\tfb_info(fb_info, \"Mode %dx%d-%d pitch = %ld cable: %s video output: %s\\n\",\n\t\tfb_info->var.xres, fb_info->var.yres,\n\t\tfb_info->var.bits_per_pixel,\n\t\tget_line_length(fb_info->var.xres, fb_info->var.bits_per_pixel),\n\t\tpvr2_get_param_name(cables, cable_type, 3),\n\t\tpvr2_get_param_name(outputs, video_output, 3));\n\n#ifdef CONFIG_SH_STORE_QUEUES\n\tfb_notice(fb_info, \"registering with SQ API\\n\");\n\n\tpvr2fb_map = sq_remap(fb_info->fix.smem_start, fb_info->fix.smem_len,\n\t\t\t      fb_info->fix.id, PAGE_SHARED);\n\n\tfb_notice(fb_info, \"Mapped video memory to SQ addr 0x%lx\\n\",\n\t\t  pvr2fb_map);\n#endif\n\n\treturn 0;\n\nout_err:\n\tif (fb_info->screen_base)\n\t\tiounmap(fb_info->screen_base);\n\tif (par->mmio_base)\n\t\tiounmap(par->mmio_base);\n\n\treturn -ENXIO;\n}\n\n#ifdef CONFIG_SH_DREAMCAST\nstatic int __init pvr2fb_dc_init(void)\n{\n\tif (!mach_is_dreamcast())\n\t\treturn -ENXIO;\n\n\t \n\tif (pvr2_init_cable() == CT_VGA) {\n\t\tfb_info->monspecs.hfmin = 30000;\n\t\tfb_info->monspecs.hfmax = 70000;\n\t\tfb_info->monspecs.vfmin = 60;\n\t\tfb_info->monspecs.vfmax = 60;\n\t} else {\n\t\t \n\t\tfb_info->monspecs.hfmin = 15469;\n\t\tfb_info->monspecs.hfmax = 15781;\n\t\tfb_info->monspecs.vfmin = 49;\n\t\tfb_info->monspecs.vfmax = 51;\n\t}\n\n\t \n\tif (video_output < 0) {\n\t\tif (cable_type == CT_VGA) {\n\t\t\tvideo_output = VO_VGA;\n\t\t} else {\n\t\t\tvideo_output = VO_NTSC;\n\t\t}\n\t}\n\n\t \n\tpvr2_fix.smem_start\t= 0xa5000000;\t \n\tpvr2_fix.smem_len\t= 8 << 20;\n\n\tpvr2_fix.mmio_start\t= 0xa05f8000;\t \n\tpvr2_fix.mmio_len\t= 0x2000;\n\n\tif (request_irq(HW_EVENT_VSYNC, pvr2fb_interrupt, IRQF_SHARED,\n\t                \"pvr2 VBL handler\", fb_info)) {\n\t\treturn -EBUSY;\n\t}\n\n#ifdef CONFIG_PVR2_DMA\n\tif (request_dma(pvr2dma, \"pvr2\") != 0) {\n\t\tfree_irq(HW_EVENT_VSYNC, fb_info);\n\t\treturn -EBUSY;\n\t}\n#endif\n\n\treturn pvr2fb_common_init();\n}\n\nstatic void pvr2fb_dc_exit(void)\n{\n\tif (fb_info->screen_base) {\n\t\tiounmap(fb_info->screen_base);\n\t\tfb_info->screen_base = NULL;\n\t}\n\tif (currentpar->mmio_base) {\n\t\tiounmap(currentpar->mmio_base);\n\t\tcurrentpar->mmio_base = NULL;\n\t}\n\n\tfree_irq(HW_EVENT_VSYNC, fb_info);\n#ifdef CONFIG_PVR2_DMA\n\tfree_dma(pvr2dma);\n#endif\n}\n#endif  \n\n#ifdef CONFIG_PCI\nstatic int pvr2fb_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tint ret;\n\n\tret = aperture_remove_conflicting_pci_devices(pdev, \"pvrfb\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"pvr2fb: PCI enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pci_request_regions(pdev, \"pvr2fb\");\n\tif (ret) {\n\t\tprintk(KERN_ERR \"pvr2fb: PCI request regions failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpvr2_fix.smem_start\t= pci_resource_start(pdev, 0);\n\tpvr2_fix.smem_len\t= pci_resource_len(pdev, 0);\n\n\tpvr2_fix.mmio_start\t= pci_resource_start(pdev, 1);\n\tpvr2_fix.mmio_len\t= pci_resource_len(pdev, 1);\n\n\tfb_info->device\t\t= &pdev->dev;\n\n\treturn pvr2fb_common_init();\n}\n\nstatic void pvr2fb_pci_remove(struct pci_dev *pdev)\n{\n\tif (fb_info->screen_base) {\n\t\tiounmap(fb_info->screen_base);\n\t\tfb_info->screen_base = NULL;\n\t}\n\tif (currentpar->mmio_base) {\n\t\tiounmap(currentpar->mmio_base);\n\t\tcurrentpar->mmio_base = NULL;\n\t}\n\n\tpci_release_regions(pdev);\n}\n\nstatic const struct pci_device_id pvr2fb_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_NEC, PCI_DEVICE_ID_NEC_NEON250,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0, },\n};\n\nMODULE_DEVICE_TABLE(pci, pvr2fb_pci_tbl);\n\nstatic struct pci_driver pvr2fb_pci_driver = {\n\t.name\t\t= \"pvr2fb\",\n\t.id_table\t= pvr2fb_pci_tbl,\n\t.probe\t\t= pvr2fb_pci_probe,\n\t.remove\t\t= pvr2fb_pci_remove,\n};\n\nstatic int __init pvr2fb_pci_init(void)\n{\n\treturn pci_register_driver(&pvr2fb_pci_driver);\n}\n\nstatic void pvr2fb_pci_exit(void)\n{\n\tpci_unregister_driver(&pvr2fb_pci_driver);\n}\n#endif  \n\n \n\n#ifndef MODULE\nstatic int __init pvr2fb_setup(char *options)\n{\n\tchar *this_opt;\n\tchar cable_arg[80];\n\tchar output_arg[80];\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\tcable_arg[0] = output_arg[0] = 0;\n\n\twhile ((this_opt = strsep(&options, \",\"))) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\t\tif (!strcmp(this_opt, \"inverse\")) {\n\t\t\tfb_invert_cmaps();\n\t\t} else if (!strncmp(this_opt, \"cable:\", 6)) {\n\t\t\tstrcpy(cable_arg, this_opt + 6);\n\t\t} else if (!strncmp(this_opt, \"output:\", 7)) {\n\t\t\tstrcpy(output_arg, this_opt + 7);\n\t\t} else if (!strncmp(this_opt, \"nopan\", 5)) {\n\t\t\tnopan = 1;\n\t\t} else if (!strncmp(this_opt, \"nowrap\", 6)) {\n\t\t\tnowrap = 1;\n\t\t} else {\n\t\t\tmode_option = this_opt;\n\t\t}\n\t}\n\n\tif (*cable_arg)\n\t\tcable_type = pvr2_get_param_val(cables, cable_arg, 3);\n\tif (*output_arg)\n\t\tvideo_output = pvr2_get_param_val(outputs, output_arg, 3);\n\n\treturn 0;\n}\n#endif\n\nstatic struct pvr2_board {\n\tint (*init)(void);\n\tvoid (*exit)(void);\n\tchar name[16];\n} board_driver[] __refdata = {\n#ifdef CONFIG_SH_DREAMCAST\n\t{ pvr2fb_dc_init, pvr2fb_dc_exit, \"Sega DC PVR2\" },\n#endif\n#ifdef CONFIG_PCI\n\t{ pvr2fb_pci_init, pvr2fb_pci_exit, \"PCI PVR2\" },\n#endif\n\t{ 0, },\n};\n\nstatic int __init pvr2fb_init(void)\n{\n\tint i, ret = -ENODEV;\n\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"pvr2fb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"pvr2fb\", &option))\n\t\treturn -ENODEV;\n\tpvr2fb_setup(option);\n#endif\n\n\tfb_info = framebuffer_alloc(sizeof(struct pvr2fb_par), NULL);\n\tif (!fb_info)\n\t\treturn -ENOMEM;\n\n\tcurrentpar = fb_info->par;\n\n\tfor (i = 0; i < ARRAY_SIZE(board_driver); i++) {\n\t\tstruct pvr2_board *pvr_board = board_driver + i;\n\n\t\tif (!pvr_board->init)\n\t\t\tcontinue;\n\n\t\tret = pvr_board->init();\n\n\t\tif (ret != 0) {\n\t\t\tprintk(KERN_ERR \"pvr2fb: Failed init of %s device\\n\",\n\t\t\t\tpvr_board->name);\n\t\t\tframebuffer_release(fb_info);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit pvr2fb_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(board_driver); i++) {\n\t\tstruct pvr2_board *pvr_board = board_driver + i;\n\n\t\tif (pvr_board->exit)\n\t\t\tpvr_board->exit();\n\t}\n\n#ifdef CONFIG_SH_STORE_QUEUES\n\tsq_unmap(pvr2fb_map);\n#endif\n\n\tunregister_framebuffer(fb_info);\n\tframebuffer_release(fb_info);\n}\n\nmodule_init(pvr2fb_init);\nmodule_exit(pvr2fb_exit);\n\nMODULE_AUTHOR(\"Paul Mundt <lethal@linux-sh.org>, M. R. Brown <mrbrown@0xd6.org>\");\nMODULE_DESCRIPTION(\"Framebuffer driver for NEC PowerVR 2 based graphics boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}