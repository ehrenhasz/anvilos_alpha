{
  "module_name": "wmt_ge_rops.c",
  "hash_id": "8f49ea8cdb4c0d832a700274636b0c50dccc8df5516021e43327660d05551ce9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/wmt_ge_rops.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fb.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n\n#include \"core/fb_draw.h\"\n#include \"wmt_ge_rops.h\"\n\n#define GE_COMMAND_OFF\t\t0x00\n#define GE_DEPTH_OFF\t\t0x04\n#define GE_HIGHCOLOR_OFF\t0x08\n#define GE_ROPCODE_OFF\t\t0x14\n#define GE_FIRE_OFF\t\t0x18\n#define GE_SRCBASE_OFF\t\t0x20\n#define GE_SRCDISPW_OFF\t\t0x24\n#define GE_SRCDISPH_OFF\t\t0x28\n#define GE_SRCAREAX_OFF\t\t0x2c\n#define GE_SRCAREAY_OFF\t\t0x30\n#define GE_SRCAREAW_OFF\t\t0x34\n#define GE_SRCAREAH_OFF\t\t0x38\n#define GE_DESTBASE_OFF\t\t0x3c\n#define GE_DESTDISPW_OFF\t0x40\n#define GE_DESTDISPH_OFF\t0x44\n#define GE_DESTAREAX_OFF\t0x48\n#define GE_DESTAREAY_OFF\t0x4c\n#define GE_DESTAREAW_OFF\t0x50\n#define GE_DESTAREAH_OFF\t0x54\n#define GE_PAT0C_OFF\t\t0x88\t \n#define GE_ENABLE_OFF\t\t0xec\n#define GE_INTEN_OFF\t\t0xf0\n#define GE_STATUS_OFF\t\t0xf8\n\nstatic void __iomem *regbase;\n\nvoid wmt_ge_fillrect(struct fb_info *p, const struct fb_fillrect *rect)\n{\n\tunsigned long fg, pat;\n\n\tif (p->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\n\tif (p->fix.visual == FB_VISUAL_TRUECOLOR ||\n\t    p->fix.visual == FB_VISUAL_DIRECTCOLOR)\n\t\tfg = ((u32 *) (p->pseudo_palette))[rect->color];\n\telse\n\t\tfg = rect->color;\n\n\tpat = pixel_to_pat(p->var.bits_per_pixel, fg);\n\n\tif (p->fbops->fb_sync)\n\t\tp->fbops->fb_sync(p);\n\n\twritel(p->var.bits_per_pixel == 32 ? 3 :\n\t      (p->var.bits_per_pixel == 8 ? 0 : 1), regbase + GE_DEPTH_OFF);\n\twritel(p->var.bits_per_pixel == 15 ? 1 : 0, regbase + GE_HIGHCOLOR_OFF);\n\twritel(p->fix.smem_start, regbase + GE_DESTBASE_OFF);\n\twritel(p->var.xres_virtual - 1, regbase + GE_DESTDISPW_OFF);\n\twritel(p->var.yres_virtual - 1, regbase + GE_DESTDISPH_OFF);\n\twritel(rect->dx, regbase + GE_DESTAREAX_OFF);\n\twritel(rect->dy, regbase + GE_DESTAREAY_OFF);\n\twritel(rect->width - 1, regbase + GE_DESTAREAW_OFF);\n\twritel(rect->height - 1, regbase + GE_DESTAREAH_OFF);\n\n\twritel(pat, regbase + GE_PAT0C_OFF);\n\twritel(1, regbase + GE_COMMAND_OFF);\n\twritel(rect->rop == ROP_XOR ? 0x5a : 0xf0, regbase + GE_ROPCODE_OFF);\n\twritel(1, regbase + GE_FIRE_OFF);\n}\nEXPORT_SYMBOL_GPL(wmt_ge_fillrect);\n\nvoid wmt_ge_copyarea(struct fb_info *p, const struct fb_copyarea *area)\n{\n\tif (p->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\n\tif (p->fbops->fb_sync)\n\t\tp->fbops->fb_sync(p);\n\n\twritel(p->var.bits_per_pixel > 16 ? 3 :\n\t      (p->var.bits_per_pixel > 8 ? 1 : 0), regbase + GE_DEPTH_OFF);\n\n\twritel(p->fix.smem_start, regbase + GE_SRCBASE_OFF);\n\twritel(p->var.xres_virtual - 1, regbase + GE_SRCDISPW_OFF);\n\twritel(p->var.yres_virtual - 1, regbase + GE_SRCDISPH_OFF);\n\twritel(area->sx, regbase + GE_SRCAREAX_OFF);\n\twritel(area->sy, regbase + GE_SRCAREAY_OFF);\n\twritel(area->width - 1, regbase + GE_SRCAREAW_OFF);\n\twritel(area->height - 1, regbase + GE_SRCAREAH_OFF);\n\n\twritel(p->fix.smem_start, regbase + GE_DESTBASE_OFF);\n\twritel(p->var.xres_virtual - 1, regbase + GE_DESTDISPW_OFF);\n\twritel(p->var.yres_virtual - 1, regbase + GE_DESTDISPH_OFF);\n\twritel(area->dx, regbase + GE_DESTAREAX_OFF);\n\twritel(area->dy, regbase + GE_DESTAREAY_OFF);\n\twritel(area->width - 1, regbase + GE_DESTAREAW_OFF);\n\twritel(area->height - 1, regbase + GE_DESTAREAH_OFF);\n\n\twritel(0xcc, regbase + GE_ROPCODE_OFF);\n\twritel(1, regbase + GE_COMMAND_OFF);\n\twritel(1, regbase + GE_FIRE_OFF);\n}\nEXPORT_SYMBOL_GPL(wmt_ge_copyarea);\n\nint wmt_ge_sync(struct fb_info *p)\n{\n\tint loops = 5000000;\n\twhile ((readl(regbase + GE_STATUS_OFF) & 4) && --loops)\n\t\tcpu_relax();\n\treturn loops > 0 ? 0 : -EBUSY;\n}\nEXPORT_SYMBOL_GPL(wmt_ge_sync);\n\nstatic int wmt_ge_rops_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"no I/O memory resource defined\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (unlikely(regbase)) {\n\t\tWARN_ON(1);\n\t\treturn -EBUSY;\n\t}\n\n\tregbase = ioremap(res->start, resource_size(res));\n\tif (regbase == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to map I/O memory\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\twritel(1, regbase + GE_ENABLE_OFF);\n\tprintk(KERN_INFO \"Enabled support for WMT GE raster acceleration\\n\");\n\n\treturn 0;\n}\n\nstatic void wmt_ge_rops_remove(struct platform_device *pdev)\n{\n\tiounmap(regbase);\n}\n\nstatic const struct of_device_id wmt_dt_ids[] = {\n\t{ .compatible = \"wm,prizm-ge-rops\", },\n\t{   }\n};\n\nstatic struct platform_driver wmt_ge_rops_driver = {\n\t.probe\t\t= wmt_ge_rops_probe,\n\t.remove_new\t= wmt_ge_rops_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"wmt_ge_rops\",\n\t\t.of_match_table = wmt_dt_ids,\n\t},\n};\n\nmodule_platform_driver(wmt_ge_rops_driver);\n\nMODULE_AUTHOR(\"Alexey Charkov <alchark@gmail.com>\");\nMODULE_DESCRIPTION(\"Accelerators for raster operations using \"\n\t\t   \"WonderMedia Graphics Engine\");\nMODULE_DEVICE_TABLE(of, wmt_dt_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}