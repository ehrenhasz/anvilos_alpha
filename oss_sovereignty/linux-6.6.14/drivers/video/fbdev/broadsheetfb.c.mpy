{
  "module_name": "broadsheetfb.c",
  "hash_id": "e2b860ffdedc71f5fe5cfeb01c1922091355959d3887767dc730f74ed0032d28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/broadsheetfb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/list.h>\n#include <linux/firmware.h>\n#include <linux/uaccess.h>\n\n#include <video/broadsheetfb.h>\n\n \nstruct panel_info {\n\tint w;\n\tint h;\n\tu16 sdcfg;\n\tu16 gdcfg;\n\tu16 lutfmt;\n\tu16 fsynclen;\n\tu16 fendfbegin;\n\tu16 lsynclen;\n\tu16 lendlbegin;\n\tu16 pixclk;\n};\n\n \nstatic struct panel_info panel_table[] = {\n\t{\t \n\t\t.w = 800,\n\t\t.h = 600,\n\t\t.sdcfg = (100 | (1 << 8) | (1 << 9)),\n\t\t.gdcfg = 2,\n\t\t.lutfmt = (4 | (1 << 7)),\n\t\t.fsynclen = 4,\n\t\t.fendfbegin = (10 << 8) | 4,\n\t\t.lsynclen = 10,\n\t\t.lendlbegin = (100 << 8) | 4,\n\t\t.pixclk = 6,\n\t},\n\t{\t \n\t\t.w = 320,\n\t\t.h = 240,\n\t\t.sdcfg = (67 | (0 << 8) | (0 << 9) | (0 << 10) | (0 << 12)),\n\t\t.gdcfg = 3,\n\t\t.lutfmt = (4 | (1 << 7)),\n\t\t.fsynclen = 0,\n\t\t.fendfbegin = (80 << 8) | 4,\n\t\t.lsynclen = 10,\n\t\t.lendlbegin = (80 << 8) | 20,\n\t\t.pixclk = 14,\n\t},\n\t{\t \n\t\t.w = 1200,\n\t\t.h = 825,\n\t\t.sdcfg = (100 | (1 << 8) | (1 << 9) | (0 << 10) | (0 << 12)),\n\t\t.gdcfg = 2,\n\t\t.lutfmt = (4 | (1 << 7)),\n\t\t.fsynclen = 0,\n\t\t.fendfbegin = (4 << 8) | 4,\n\t\t.lsynclen = 4,\n\t\t.lendlbegin = (60 << 8) | 10,\n\t\t.pixclk = 3,\n\t},\n};\n\n#define DPY_W 800\n#define DPY_H 600\n\nstatic struct fb_fix_screeninfo broadsheetfb_fix = {\n\t.id =\t\t\"broadsheetfb\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_STATIC_PSEUDOCOLOR,\n\t.xpanstep =\t0,\n\t.ypanstep =\t0,\n\t.ywrapstep =\t0,\n\t.line_length =\tDPY_W,\n\t.accel =\tFB_ACCEL_NONE,\n};\n\nstatic struct fb_var_screeninfo broadsheetfb_var = {\n\t.xres\t\t= DPY_W,\n\t.yres\t\t= DPY_H,\n\t.xres_virtual\t= DPY_W,\n\t.yres_virtual\t= DPY_H,\n\t.bits_per_pixel\t= 8,\n\t.grayscale\t= 1,\n\t.red =\t\t{ 0, 4, 0 },\n\t.green =\t{ 0, 4, 0 },\n\t.blue =\t\t{ 0, 4, 0 },\n\t.transp =\t{ 0, 0, 0 },\n};\n\n \nstatic void broadsheet_gpio_issue_data(struct broadsheetfb_par *par, u16 data)\n{\n\tpar->board->set_ctl(par, BS_WR, 0);\n\tpar->board->set_hdb(par, data);\n\tpar->board->set_ctl(par, BS_WR, 1);\n}\n\nstatic void broadsheet_gpio_issue_cmd(struct broadsheetfb_par *par, u16 data)\n{\n\tpar->board->set_ctl(par, BS_DC, 0);\n\tbroadsheet_gpio_issue_data(par, data);\n}\n\nstatic void broadsheet_gpio_send_command(struct broadsheetfb_par *par, u16 data)\n{\n\tpar->board->wait_for_rdy(par);\n\n\tpar->board->set_ctl(par, BS_CS, 0);\n\tbroadsheet_gpio_issue_cmd(par, data);\n\tpar->board->set_ctl(par, BS_DC, 1);\n\tpar->board->set_ctl(par, BS_CS, 1);\n}\n\nstatic void broadsheet_gpio_send_cmdargs(struct broadsheetfb_par *par, u16 cmd,\n\t\t\t\t\tint argc, u16 *argv)\n{\n\tint i;\n\n\tpar->board->wait_for_rdy(par);\n\n\tpar->board->set_ctl(par, BS_CS, 0);\n\tbroadsheet_gpio_issue_cmd(par, cmd);\n\tpar->board->set_ctl(par, BS_DC, 1);\n\n\tfor (i = 0; i < argc; i++)\n\t\tbroadsheet_gpio_issue_data(par, argv[i]);\n\tpar->board->set_ctl(par, BS_CS, 1);\n}\n\nstatic void broadsheet_mmio_send_cmdargs(struct broadsheetfb_par *par, u16 cmd,\n\t\t\t\t    int argc, u16 *argv)\n{\n\tint i;\n\n\tpar->board->mmio_write(par, BS_MMIO_CMD, cmd);\n\n\tfor (i = 0; i < argc; i++)\n\t\tpar->board->mmio_write(par, BS_MMIO_DATA, argv[i]);\n}\n\nstatic void broadsheet_send_command(struct broadsheetfb_par *par, u16 data)\n{\n\tif (par->board->mmio_write)\n\t\tpar->board->mmio_write(par, BS_MMIO_CMD, data);\n\telse\n\t\tbroadsheet_gpio_send_command(par, data);\n}\n\nstatic void broadsheet_send_cmdargs(struct broadsheetfb_par *par, u16 cmd,\n\t\t\t\t    int argc, u16 *argv)\n{\n\tif (par->board->mmio_write)\n\t\tbroadsheet_mmio_send_cmdargs(par, cmd, argc, argv);\n\telse\n\t\tbroadsheet_gpio_send_cmdargs(par, cmd, argc, argv);\n}\n\nstatic void broadsheet_gpio_burst_write(struct broadsheetfb_par *par, int size,\n\t\t\t\t\tu16 *data)\n{\n\tint i;\n\tu16 tmp;\n\n\tpar->board->set_ctl(par, BS_CS, 0);\n\tpar->board->set_ctl(par, BS_DC, 1);\n\n\tfor (i = 0; i < size; i++) {\n\t\tpar->board->set_ctl(par, BS_WR, 0);\n\t\ttmp = (data[i] & 0x0F) << 4;\n\t\ttmp |= (data[i] & 0x0F00) << 4;\n\t\tpar->board->set_hdb(par, tmp);\n\t\tpar->board->set_ctl(par, BS_WR, 1);\n\t}\n\n\tpar->board->set_ctl(par, BS_CS, 1);\n}\n\nstatic void broadsheet_mmio_burst_write(struct broadsheetfb_par *par, int size,\n\t\t\t\t   u16 *data)\n{\n\tint i;\n\tu16 tmp;\n\n\tfor (i = 0; i < size; i++) {\n\t\ttmp = (data[i] & 0x0F) << 4;\n\t\ttmp |= (data[i] & 0x0F00) << 4;\n\t\tpar->board->mmio_write(par, BS_MMIO_DATA, tmp);\n\t}\n\n}\n\nstatic void broadsheet_burst_write(struct broadsheetfb_par *par, int size,\n\t\t\t\t   u16 *data)\n{\n\tif (par->board->mmio_write)\n\t\tbroadsheet_mmio_burst_write(par, size, data);\n\telse\n\t\tbroadsheet_gpio_burst_write(par, size, data);\n}\n\nstatic u16 broadsheet_gpio_get_data(struct broadsheetfb_par *par)\n{\n\tu16 res;\n\t \n\tpar->board->wait_for_rdy(par);\n\n\t \n\tpar->board->set_ctl(par, BS_DC, 1);\n\tpar->board->set_ctl(par, BS_CS, 0);\n\tpar->board->set_ctl(par, BS_WR, 0);\n\n\tres = par->board->get_hdb(par);\n\n\t \n\tpar->board->set_ctl(par, BS_WR, 1);\n\tpar->board->set_ctl(par, BS_CS, 1);\n\n\treturn res;\n}\n\n\nstatic u16 broadsheet_get_data(struct broadsheetfb_par *par)\n{\n\tif (par->board->mmio_read)\n\t\treturn par->board->mmio_read(par);\n\telse\n\t\treturn broadsheet_gpio_get_data(par);\n}\n\nstatic void broadsheet_gpio_write_reg(struct broadsheetfb_par *par, u16 reg,\n\t\t\t\t\tu16 data)\n{\n\t \n\tpar->board->wait_for_rdy(par);\n\n\t \n\tpar->board->set_ctl(par, BS_CS, 0);\n\n\tbroadsheet_gpio_issue_cmd(par, BS_CMD_WR_REG);\n\n\tpar->board->set_ctl(par, BS_DC, 1);\n\n\tbroadsheet_gpio_issue_data(par, reg);\n\tbroadsheet_gpio_issue_data(par, data);\n\n\tpar->board->set_ctl(par, BS_CS, 1);\n}\n\nstatic void broadsheet_mmio_write_reg(struct broadsheetfb_par *par, u16 reg,\n\t\t\t\t u16 data)\n{\n\tpar->board->mmio_write(par, BS_MMIO_CMD, BS_CMD_WR_REG);\n\tpar->board->mmio_write(par, BS_MMIO_DATA, reg);\n\tpar->board->mmio_write(par, BS_MMIO_DATA, data);\n\n}\n\nstatic void broadsheet_write_reg(struct broadsheetfb_par *par, u16 reg,\n\t\t\t\t\tu16 data)\n{\n\tif (par->board->mmio_write)\n\t\tbroadsheet_mmio_write_reg(par, reg, data);\n\telse\n\t\tbroadsheet_gpio_write_reg(par, reg, data);\n}\n\nstatic void broadsheet_write_reg32(struct broadsheetfb_par *par, u16 reg,\n\t\t\t\t\tu32 data)\n{\n\tbroadsheet_write_reg(par, reg, cpu_to_le32(data) & 0xFFFF);\n\tbroadsheet_write_reg(par, reg + 2, (cpu_to_le32(data) >> 16) & 0xFFFF);\n}\n\n\nstatic u16 broadsheet_read_reg(struct broadsheetfb_par *par, u16 reg)\n{\n\tbroadsheet_send_cmdargs(par, BS_CMD_RD_REG, 1, &reg);\n\tpar->board->wait_for_rdy(par);\n\treturn broadsheet_get_data(par);\n}\n\n \nstatic int is_broadsheet_pll_locked(struct broadsheetfb_par *par)\n{\n\treturn broadsheet_read_reg(par, 0x000A) & 0x0001;\n}\n\nstatic int broadsheet_setup_plls(struct broadsheetfb_par *par)\n{\n\tint retry_count = 0;\n\tu16 tmp;\n\n\t \n\tbroadsheet_write_reg(par, 0x0006, 0x0000);\n\n\tbroadsheet_write_reg(par, 0x0010, 0x0004);\n\tbroadsheet_write_reg(par, 0x0012, 0x5949);\n\tbroadsheet_write_reg(par, 0x0014, 0x0040);\n\tbroadsheet_write_reg(par, 0x0016, 0x0000);\n\n\tdo {\n\t\tif (retry_count++ > 100)\n\t\t\treturn -ETIMEDOUT;\n\t\tmdelay(1);\n\t} while (!is_broadsheet_pll_locked(par));\n\n\ttmp = broadsheet_read_reg(par, 0x0006);\n\ttmp &= ~0x1;\n\tbroadsheet_write_reg(par, 0x0006, tmp);\n\n\treturn 0;\n}\n\nstatic int broadsheet_setup_spi(struct broadsheetfb_par *par)\n{\n\n\tbroadsheet_write_reg(par, 0x0204, ((3 << 3) | 1));\n\tbroadsheet_write_reg(par, 0x0208, 0x0001);\n\n\treturn 0;\n}\n\nstatic int broadsheet_setup_spiflash(struct broadsheetfb_par *par,\n\t\t\t\t\t\tu16 *orig_sfmcd)\n{\n\n\t*orig_sfmcd = broadsheet_read_reg(par, 0x0204);\n\tbroadsheet_write_reg(par, 0x0208, 0);\n\tbroadsheet_write_reg(par, 0x0204, 0);\n\tbroadsheet_write_reg(par, 0x0204, ((3 << 3) | 1));\n\n\treturn 0;\n}\n\nstatic int broadsheet_spiflash_wait_for_bit(struct broadsheetfb_par *par,\n\t\t\t\t\t\tu16 reg, int bitnum, int val,\n\t\t\t\t\t\tint timeout)\n{\n\tu16 tmp;\n\n\tdo {\n\t\ttmp = broadsheet_read_reg(par, reg);\n\t\tif (((tmp >> bitnum) & 1) == val)\n\t\t\treturn 0;\n\t\tmdelay(1);\n\t} while (timeout--);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int broadsheet_spiflash_write_byte(struct broadsheetfb_par *par, u8 data)\n{\n\tbroadsheet_write_reg(par, 0x0202, (data | 0x100));\n\n\treturn broadsheet_spiflash_wait_for_bit(par, 0x0206, 3, 0, 100);\n}\n\nstatic int broadsheet_spiflash_read_byte(struct broadsheetfb_par *par, u8 *data)\n{\n\tint err;\n\tu16 tmp;\n\n\tbroadsheet_write_reg(par, 0x0202, 0);\n\n\terr = broadsheet_spiflash_wait_for_bit(par, 0x0206, 3, 0, 100);\n\tif (err)\n\t\treturn err;\n\n\ttmp = broadsheet_read_reg(par, 0x200);\n\n\t*data = tmp & 0xFF;\n\n\treturn 0;\n}\n\nstatic int broadsheet_spiflash_wait_for_status(struct broadsheetfb_par *par,\n\t\t\t\t\t\t\t\tint timeout)\n{\n\tu8 tmp;\n\tint err;\n\n\tdo {\n\t\tbroadsheet_write_reg(par, 0x0208, 1);\n\n\t\terr = broadsheet_spiflash_write_byte(par, 0x05);\n\t\tif (err)\n\t\t\tgoto failout;\n\n\t\terr = broadsheet_spiflash_read_byte(par, &tmp);\n\t\tif (err)\n\t\t\tgoto failout;\n\n\t\tbroadsheet_write_reg(par, 0x0208, 0);\n\n\t\tif (!(tmp & 0x1))\n\t\t\treturn 0;\n\n\t\tmdelay(5);\n\t} while (timeout--);\n\n\tdev_err(par->info->device, \"Timed out waiting for spiflash status\\n\");\n\treturn -ETIMEDOUT;\n\nfailout:\n\tbroadsheet_write_reg(par, 0x0208, 0);\n\treturn err;\n}\n\nstatic int broadsheet_spiflash_op_on_address(struct broadsheetfb_par *par,\n\t\t\t\t\t\t\tu8 op, u32 addr)\n{\n\tint i;\n\tu8 tmp;\n\tint err;\n\n\tbroadsheet_write_reg(par, 0x0208, 1);\n\n\terr = broadsheet_spiflash_write_byte(par, op);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 2; i >= 0; i--) {\n\t\ttmp = ((addr >> (i * 8)) & 0xFF);\n\t\terr = broadsheet_spiflash_write_byte(par, tmp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int broadsheet_verify_spiflash(struct broadsheetfb_par *par,\n\t\t\t\t\t\tint *flash_type)\n{\n\tint err = 0;\n\tu8 sig;\n\n\terr = broadsheet_spiflash_op_on_address(par, 0xAB, 0x00000000);\n\tif (err)\n\t\tgoto failout;\n\n\terr = broadsheet_spiflash_read_byte(par, &sig);\n\tif (err)\n\t\tgoto failout;\n\n\tif ((sig != 0x10) && (sig != 0x11)) {\n\t\tdev_err(par->info->device, \"Unexpected flash type\\n\");\n\t\terr = -EINVAL;\n\t\tgoto failout;\n\t}\n\n\t*flash_type = sig;\n\nfailout:\n\tbroadsheet_write_reg(par, 0x0208, 0);\n\treturn err;\n}\n\nstatic int broadsheet_setup_for_wfm_write(struct broadsheetfb_par *par,\n\t\t\t\t\tu16 *initial_sfmcd, int *flash_type)\n\n{\n\tint err;\n\n\terr = broadsheet_setup_plls(par);\n\tif (err)\n\t\treturn err;\n\n\tbroadsheet_write_reg(par, 0x0106, 0x0203);\n\n\terr = broadsheet_setup_spi(par);\n\tif (err)\n\t\treturn err;\n\n\terr = broadsheet_setup_spiflash(par, initial_sfmcd);\n\tif (err)\n\t\treturn err;\n\n\treturn broadsheet_verify_spiflash(par, flash_type);\n}\n\nstatic int broadsheet_spiflash_write_control(struct broadsheetfb_par *par,\n\t\t\t\t\t\tint mode)\n{\n\tint err;\n\n\tbroadsheet_write_reg(par, 0x0208, 1);\n\tif (mode)\n\t\terr = broadsheet_spiflash_write_byte(par, 0x06);\n\telse\n\t\terr = broadsheet_spiflash_write_byte(par, 0x04);\n\n\tbroadsheet_write_reg(par, 0x0208, 0);\n\treturn err;\n}\n\nstatic int broadsheet_spiflash_erase_sector(struct broadsheetfb_par *par,\n\t\t\t\t\t\tint addr)\n{\n\tint err;\n\n\tbroadsheet_spiflash_write_control(par, 1);\n\n\terr = broadsheet_spiflash_op_on_address(par, 0xD8, addr);\n\n\tbroadsheet_write_reg(par, 0x0208, 0);\n\n\tif (err)\n\t\treturn err;\n\n\terr = broadsheet_spiflash_wait_for_status(par, 1000);\n\n\treturn err;\n}\n\nstatic int broadsheet_spiflash_read_range(struct broadsheetfb_par *par,\n\t\t\t\t\t\tint addr, int size, char *data)\n{\n\tint err;\n\tint i;\n\n\terr = broadsheet_spiflash_op_on_address(par, 0x03, addr);\n\tif (err)\n\t\tgoto failout;\n\n\tfor (i = 0; i < size; i++) {\n\t\terr = broadsheet_spiflash_read_byte(par, &data[i]);\n\t\tif (err)\n\t\t\tgoto failout;\n\t}\n\nfailout:\n\tbroadsheet_write_reg(par, 0x0208, 0);\n\treturn err;\n}\n\n#define BS_SPIFLASH_PAGE_SIZE 256\nstatic int broadsheet_spiflash_write_page(struct broadsheetfb_par *par,\n\t\t\t\t\t\tint addr, const char *data)\n{\n\tint err;\n\tint i;\n\n\tbroadsheet_spiflash_write_control(par, 1);\n\n\terr = broadsheet_spiflash_op_on_address(par, 0x02, addr);\n\tif (err)\n\t\tgoto failout;\n\n\tfor (i = 0; i < BS_SPIFLASH_PAGE_SIZE; i++) {\n\t\terr = broadsheet_spiflash_write_byte(par, data[i]);\n\t\tif (err)\n\t\t\tgoto failout;\n\t}\n\n\tbroadsheet_write_reg(par, 0x0208, 0);\n\n\terr = broadsheet_spiflash_wait_for_status(par, 100);\n\nfailout:\n\treturn err;\n}\n\nstatic int broadsheet_spiflash_write_sector(struct broadsheetfb_par *par,\n\t\t\t\tint addr, const char *data, int sector_size)\n{\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < sector_size; i += BS_SPIFLASH_PAGE_SIZE) {\n\t\terr = broadsheet_spiflash_write_page(par, addr + i, &data[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int broadsheet_spiflash_rewrite_sector(struct broadsheetfb_par *par,\n\t\t\t\t\tint sector_size, int data_start_addr,\n\t\t\t\t\tint data_len, const char *data)\n{\n\tint err;\n\tchar *sector_buffer;\n\tint tail_start_addr;\n\tint start_sector_addr;\n\n\tsector_buffer = kzalloc(sector_size, GFP_KERNEL);\n\tif (!sector_buffer)\n\t\treturn -ENOMEM;\n\n\t \n\tstart_sector_addr = (data_start_addr / sector_size) * sector_size;\n\n\t \n\tif (data_start_addr != start_sector_addr) {\n\t\t \n\t\terr = broadsheet_spiflash_read_range(par, start_sector_addr,\n\t\t\t\t\t\tdata_start_addr, sector_buffer);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(sector_buffer + data_start_addr, data, data_len);\n\n\t \n\ttail_start_addr = (data_start_addr + data_len) % sector_size;\n\n\tif (tail_start_addr) {\n\t\tint tail_len;\n\n\t\ttail_len = sector_size - tail_start_addr;\n\n\t\t \n\t\terr = broadsheet_spiflash_read_range(par, tail_start_addr,\n\t\t\ttail_len, sector_buffer + tail_start_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\n\t \n\terr = broadsheet_spiflash_erase_sector(par, start_sector_addr);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = broadsheet_spiflash_write_sector(par, start_sector_addr,\n\t\t\t\t\tsector_buffer, sector_size);\nout:\n\tkfree(sector_buffer);\n\treturn err;\n}\n\nstatic int broadsheet_write_spiflash(struct broadsheetfb_par *par, u32 wfm_addr,\n\t\t\t\tconst u8 *wfm, int bytecount, int flash_type)\n{\n\tint sector_size;\n\tint err;\n\tint cur_addr;\n\tint writecount;\n\tint maxlen;\n\tint offset = 0;\n\n\tswitch (flash_type) {\n\tcase 0x10:\n\t\tsector_size = 32*1024;\n\t\tbreak;\n\tcase 0x11:\n\tdefault:\n\t\tsector_size = 64*1024;\n\t\tbreak;\n\t}\n\n\twhile (bytecount) {\n\t\tcur_addr = wfm_addr + offset;\n\t\tmaxlen = roundup(cur_addr, sector_size) - cur_addr;\n\t\twritecount = min(bytecount, maxlen);\n\n\t\terr = broadsheet_spiflash_rewrite_sector(par, sector_size,\n\t\t\t\tcur_addr, writecount, wfm + offset);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\toffset += writecount;\n\t\tbytecount -= writecount;\n\t}\n\n\treturn 0;\n}\n\nstatic int broadsheet_store_waveform_to_spiflash(struct broadsheetfb_par *par,\n\t\t\t\t\t\tconst u8 *wfm, size_t wfm_size)\n{\n\tint err = 0;\n\tu16 initial_sfmcd = 0;\n\tint flash_type = 0;\n\n\terr = broadsheet_setup_for_wfm_write(par, &initial_sfmcd, &flash_type);\n\tif (err)\n\t\tgoto failout;\n\n\terr = broadsheet_write_spiflash(par, 0x886, wfm, wfm_size, flash_type);\n\nfailout:\n\tbroadsheet_write_reg(par, 0x0204, initial_sfmcd);\n\treturn err;\n}\n\nstatic ssize_t broadsheet_loadstore_waveform(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t len)\n{\n\tint err;\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct broadsheetfb_par *par = info->par;\n\tconst struct firmware *fw_entry;\n\n\tif (len < 1)\n\t\treturn -EINVAL;\n\n\terr = request_firmware(&fw_entry, \"broadsheet.wbf\", dev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Failed to get broadsheet waveform\\n\");\n\t\tgoto err_failed;\n\t}\n\n\t \n\tif ((fw_entry->size < 8*1024) || (fw_entry->size > 64*1024)) {\n\t\tdev_err(dev, \"Invalid waveform\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_fw;\n\t}\n\n\tmutex_lock(&(par->io_lock));\n\terr = broadsheet_store_waveform_to_spiflash(par, fw_entry->data,\n\t\t\t\t\t\t\tfw_entry->size);\n\n\tmutex_unlock(&(par->io_lock));\n\tif (err < 0) {\n\t\tdev_err(dev, \"Failed to store broadsheet waveform\\n\");\n\t\tgoto err_fw;\n\t}\n\n\tdev_info(dev, \"Stored broadsheet waveform, size %zd\\n\", fw_entry->size);\n\n\terr = len;\n\nerr_fw:\n\trelease_firmware(fw_entry);\nerr_failed:\n\treturn err;\n}\nstatic DEVICE_ATTR(loadstore_waveform, S_IWUSR, NULL,\n\t\t\tbroadsheet_loadstore_waveform);\n\n \nstatic void broadsheet_init_display(struct broadsheetfb_par *par)\n{\n\tu16 args[5];\n\tint xres = par->info->var.xres;\n\tint yres = par->info->var.yres;\n\n\targs[0] = panel_table[par->panel_index].w;\n\targs[1] = panel_table[par->panel_index].h;\n\targs[2] = panel_table[par->panel_index].sdcfg;\n\targs[3] = panel_table[par->panel_index].gdcfg;\n\targs[4] = panel_table[par->panel_index].lutfmt;\n\tbroadsheet_send_cmdargs(par, BS_CMD_INIT_DSPE_CFG, 5, args);\n\n\t \n\tbroadsheet_send_cmdargs(par, BS_CMD_INIT_DSPE_CFG, 5, args);\n\n\targs[0] = panel_table[par->panel_index].fsynclen;\n\targs[1] = panel_table[par->panel_index].fendfbegin;\n\targs[2] = panel_table[par->panel_index].lsynclen;\n\targs[3] = panel_table[par->panel_index].lendlbegin;\n\targs[4] = panel_table[par->panel_index].pixclk;\n\tbroadsheet_send_cmdargs(par, BS_CMD_INIT_DSPE_TMG, 5, args);\n\n\tbroadsheet_write_reg32(par, 0x310, xres*yres*2);\n\n\t \n\targs[0] = 0x886;\n\targs[1] = 0;\n\tbroadsheet_send_cmdargs(par, BS_CMD_RD_WFM_INFO, 2, args);\n\n\tbroadsheet_send_command(par, BS_CMD_UPD_GDRV_CLR);\n\n\tbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_TRG);\n\n\tbroadsheet_write_reg(par, 0x330, 0x84);\n\n\tbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_TRG);\n\n\targs[0] = (0x3 << 4);\n\tbroadsheet_send_cmdargs(par, BS_CMD_LD_IMG, 1, args);\n\n\targs[0] = 0x154;\n\tbroadsheet_send_cmdargs(par, BS_CMD_WR_REG, 1, args);\n\n\tbroadsheet_burst_write(par, (panel_table[par->panel_index].w *\n\t\t\t\t\tpanel_table[par->panel_index].h)/2,\n\t\t\t\t\t(u16 *)par->info->screen_buffer);\n\n\tbroadsheet_send_command(par, BS_CMD_LD_IMG_END);\n\n\targs[0] = 0x4300;\n\tbroadsheet_send_cmdargs(par, BS_CMD_UPD_FULL, 1, args);\n\n\tbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_TRG);\n\n\tbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_FREND);\n\n\tpar->board->wait_for_rdy(par);\n}\n\nstatic void broadsheet_identify(struct broadsheetfb_par *par)\n{\n\tu16 rev, prc;\n\tstruct device *dev = par->info->device;\n\n\trev = broadsheet_read_reg(par, BS_REG_REV);\n\tprc = broadsheet_read_reg(par, BS_REG_PRC);\n\tdev_info(dev, \"Broadsheet Rev 0x%x, Product Code 0x%x\\n\", rev, prc);\n\n\tif (prc != 0x0047)\n\t\tdev_warn(dev, \"Unrecognized Broadsheet Product Code\\n\");\n\tif (rev != 0x0100)\n\t\tdev_warn(dev, \"Unrecognized Broadsheet Revision\\n\");\n}\n\nstatic void broadsheet_init(struct broadsheetfb_par *par)\n{\n\tbroadsheet_send_command(par, BS_CMD_INIT_SYS_RUN);\n\t \n\tmsleep(1000);\n\tbroadsheet_init_display(par);\n}\n\nstatic void broadsheetfb_dpy_update_pages(struct broadsheetfb_par *par,\n\t\t\t\t\t\tu16 y1, u16 y2)\n{\n\tu16 args[5];\n\tunsigned char *buf = par->info->screen_buffer;\n\n\tmutex_lock(&(par->io_lock));\n\t \n\ty1 &= 0xFFFC;\n\t \n\ty2 |= 0x0003;\n\n\targs[0] = 0x3 << 4;\n\targs[1] = 0;\n\targs[2] = y1;\n\targs[3] = cpu_to_le16(par->info->var.xres);\n\targs[4] = y2;\n\tbroadsheet_send_cmdargs(par, BS_CMD_LD_IMG_AREA, 5, args);\n\n\targs[0] = 0x154;\n\tbroadsheet_send_cmdargs(par, BS_CMD_WR_REG, 1, args);\n\n\tbuf += y1 * par->info->var.xres;\n\tbroadsheet_burst_write(par, ((1 + y2 - y1) * par->info->var.xres)/2,\n\t\t\t\t(u16 *) buf);\n\n\tbroadsheet_send_command(par, BS_CMD_LD_IMG_END);\n\n\targs[0] = 0x4300;\n\tbroadsheet_send_cmdargs(par, BS_CMD_UPD_FULL, 1, args);\n\n\tbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_TRG);\n\n\tbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_FREND);\n\n\tpar->board->wait_for_rdy(par);\n\tmutex_unlock(&(par->io_lock));\n\n}\n\nstatic void broadsheetfb_dpy_update(struct broadsheetfb_par *par)\n{\n\tu16 args[5];\n\n\tmutex_lock(&(par->io_lock));\n\targs[0] = 0x3 << 4;\n\tbroadsheet_send_cmdargs(par, BS_CMD_LD_IMG, 1, args);\n\n\targs[0] = 0x154;\n\tbroadsheet_send_cmdargs(par, BS_CMD_WR_REG, 1, args);\n\tbroadsheet_burst_write(par, (panel_table[par->panel_index].w *\n\t\t\t\t\tpanel_table[par->panel_index].h)/2,\n\t\t\t\t\t(u16 *)par->info->screen_buffer);\n\n\tbroadsheet_send_command(par, BS_CMD_LD_IMG_END);\n\n\targs[0] = 0x4300;\n\tbroadsheet_send_cmdargs(par, BS_CMD_UPD_FULL, 1, args);\n\n\tbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_TRG);\n\n\tbroadsheet_send_command(par, BS_CMD_WAIT_DSPE_FREND);\n\n\tpar->board->wait_for_rdy(par);\n\tmutex_unlock(&(par->io_lock));\n}\n\n \nstatic void broadsheetfb_dpy_deferred_io(struct fb_info *info, struct list_head *pagereflist)\n{\n\tu16 y1 = 0, h = 0;\n\tunsigned long prev_offset = ULONG_MAX;\n\tstruct fb_deferred_io_pageref *pageref;\n\tint h_inc;\n\tu16 yres = info->var.yres;\n\tu16 xres = info->var.xres;\n\n\t \n\th_inc = DIV_ROUND_UP(PAGE_SIZE , xres);\n\n\t \n\tlist_for_each_entry(pageref, pagereflist, list) {\n\t\tif (prev_offset == ULONG_MAX) {\n\t\t\t \n\t\t\ty1 = pageref->offset / xres;\n\t\t\th = h_inc;\n\t\t} else if ((prev_offset + PAGE_SIZE) == pageref->offset) {\n\t\t\t \n\t\t\th += h_inc;\n\t\t} else {\n\t\t\t \n\t\t\tbroadsheetfb_dpy_update_pages(info->par, y1, y1 + h);\n\t\t\t \n\t\t\ty1 = pageref->offset / xres;\n\t\t\th = h_inc;\n\t\t}\n\t\tprev_offset = pageref->offset;\n\t}\n\n\t \n\tif (h >= yres) {\n\t\t \n\t\tbroadsheetfb_dpy_update(info->par);\n\t} else {\n\t\tbroadsheetfb_dpy_update_pages(info->par, y1,\n\t\t\t\t\t\tmin((u16) (y1 + h), yres));\n\t}\n}\n\nstatic void broadsheetfb_defio_damage_range(struct fb_info *info, off_t off, size_t len)\n{\n\tstruct broadsheetfb_par *par = info->par;\n\n\tbroadsheetfb_dpy_update(par);\n}\n\nstatic void broadsheetfb_defio_damage_area(struct fb_info *info, u32 x, u32 y,\n\t\t\t\t\t   u32 width, u32 height)\n{\n\tstruct broadsheetfb_par *par = info->par;\n\n\tbroadsheetfb_dpy_update(par);\n}\n\nFB_GEN_DEFAULT_DEFERRED_SYSMEM_OPS(broadsheetfb,\n\t\t\t\t   broadsheetfb_defio_damage_range,\n\t\t\t\t   broadsheetfb_defio_damage_area)\n\nstatic const struct fb_ops broadsheetfb_ops = {\n\t.owner\t= THIS_MODULE,\n\tFB_DEFAULT_DEFERRED_OPS(broadsheetfb),\n};\n\nstatic struct fb_deferred_io broadsheetfb_defio = {\n\t.delay\t\t\t= HZ/4,\n\t.sort_pagereflist\t= true,\n\t.deferred_io\t\t= broadsheetfb_dpy_deferred_io,\n};\n\nstatic int broadsheetfb_probe(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\tstruct broadsheet_board *board;\n\tint retval = -ENOMEM;\n\tint videomemorysize;\n\tunsigned char *videomemory;\n\tstruct broadsheetfb_par *par;\n\tint i;\n\tint dpyw, dpyh;\n\tint panel_index;\n\n\t \n\tboard = dev->dev.platform_data;\n\tif (!board)\n\t\treturn -EINVAL;\n\n\t \n\tif (!try_module_get(board->owner))\n\t\treturn -ENODEV;\n\n\tinfo = framebuffer_alloc(sizeof(struct broadsheetfb_par), &dev->dev);\n\tif (!info)\n\t\tgoto err;\n\n\tswitch (board->get_panel_type()) {\n\tcase 37:\n\t\tpanel_index = 1;\n\t\tbreak;\n\tcase 97:\n\t\tpanel_index = 2;\n\t\tbreak;\n\tcase 6:\n\tdefault:\n\t\tpanel_index = 0;\n\t\tbreak;\n\t}\n\n\tdpyw = panel_table[panel_index].w;\n\tdpyh = panel_table[panel_index].h;\n\n\tvideomemorysize = roundup((dpyw*dpyh), PAGE_SIZE);\n\n\tvideomemory = vzalloc(videomemorysize);\n\tif (!videomemory)\n\t\tgoto err_fb_rel;\n\n\tinfo->screen_buffer = videomemory;\n\tinfo->fbops = &broadsheetfb_ops;\n\n\tbroadsheetfb_var.xres = dpyw;\n\tbroadsheetfb_var.yres = dpyh;\n\tbroadsheetfb_var.xres_virtual = dpyw;\n\tbroadsheetfb_var.yres_virtual = dpyh;\n\tinfo->var = broadsheetfb_var;\n\n\tbroadsheetfb_fix.line_length = dpyw;\n\tinfo->fix = broadsheetfb_fix;\n\tinfo->fix.smem_len = videomemorysize;\n\tpar = info->par;\n\tpar->panel_index = panel_index;\n\tpar->info = info;\n\tpar->board = board;\n\tpar->write_reg = broadsheet_write_reg;\n\tpar->read_reg = broadsheet_read_reg;\n\tinit_waitqueue_head(&par->waitq);\n\n\tmutex_init(&par->io_lock);\n\n\tinfo->flags = FBINFO_VIRTFB;\n\n\tinfo->fbdefio = &broadsheetfb_defio;\n\tfb_deferred_io_init(info);\n\n\tretval = fb_alloc_cmap(&info->cmap, 16, 0);\n\tif (retval < 0) {\n\t\tdev_err(&dev->dev, \"Failed to allocate colormap\\n\");\n\t\tgoto err_vfree;\n\t}\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tinfo->cmap.red[i] = (((2*i)+1)*(0xFFFF))/32;\n\tmemcpy(info->cmap.green, info->cmap.red, sizeof(u16)*16);\n\tmemcpy(info->cmap.blue, info->cmap.red, sizeof(u16)*16);\n\n\tretval = par->board->setup_irq(info);\n\tif (retval < 0)\n\t\tgoto err_cmap;\n\n\t \n\tretval = board->init(par);\n\tif (retval < 0)\n\t\tgoto err_free_irq;\n\n\tbroadsheet_identify(par);\n\n\tbroadsheet_init(par);\n\n\tretval = register_framebuffer(info);\n\tif (retval < 0)\n\t\tgoto err_free_irq;\n\n\tplatform_set_drvdata(dev, info);\n\n\tretval = device_create_file(&dev->dev, &dev_attr_loadstore_waveform);\n\tif (retval < 0)\n\t\tgoto err_unreg_fb;\n\n\tfb_info(info, \"Broadsheet frame buffer, using %dK of video memory\\n\",\n\t\tvideomemorysize >> 10);\n\n\n\treturn 0;\n\nerr_unreg_fb:\n\tunregister_framebuffer(info);\nerr_free_irq:\n\tboard->cleanup(par);\nerr_cmap:\n\tfb_dealloc_cmap(&info->cmap);\nerr_vfree:\n\tvfree(videomemory);\nerr_fb_rel:\n\tframebuffer_release(info);\nerr:\n\tmodule_put(board->owner);\n\treturn retval;\n\n}\n\nstatic void broadsheetfb_remove(struct platform_device *dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\n\tif (info) {\n\t\tstruct broadsheetfb_par *par = info->par;\n\n\t\tdevice_remove_file(info->device, &dev_attr_loadstore_waveform);\n\t\tunregister_framebuffer(info);\n\t\tfb_deferred_io_cleanup(info);\n\t\tpar->board->cleanup(par);\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\tvfree(info->screen_buffer);\n\t\tmodule_put(par->board->owner);\n\t\tframebuffer_release(info);\n\t}\n}\n\nstatic struct platform_driver broadsheetfb_driver = {\n\t.probe\t= broadsheetfb_probe,\n\t.remove_new = broadsheetfb_remove,\n\t.driver\t= {\n\t\t.name\t= \"broadsheetfb\",\n\t},\n};\nmodule_platform_driver(broadsheetfb_driver);\n\nMODULE_DESCRIPTION(\"fbdev driver for Broadsheet controller\");\nMODULE_AUTHOR(\"Jaya Kumar\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(\"broadsheet.wbf\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}