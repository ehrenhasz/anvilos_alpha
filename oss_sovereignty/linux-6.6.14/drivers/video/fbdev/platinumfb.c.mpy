{
  "module_name": "platinumfb.c",
  "hash_id": "4a0f966b6374427519dbcca60459b9c447ea867d8ad6ca62c170daf4e58eb705",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/platinumfb.c",
  "human_readable_source": " \n\n#undef DEBUG\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n\n#include \"macmodes.h\"\n#include \"platinumfb.h\"\n\nstatic int default_vmode = VMODE_NVRAM;\nstatic int default_cmode = CMODE_NVRAM;\n\nstruct fb_info_platinum {\n\tstruct fb_info\t\t\t*info;\n\n\tint\t\t\t\tvmode, cmode;\n\tint\t\t\t\txres, yres;\n\tint\t\t\t\tvxres, vyres;\n\tint\t\t\t\txoffset, yoffset;\n\n\tstruct {\n\t\t__u8 red, green, blue;\n\t}\t\t\t\tpalette[256];\n\tu32\t\t\t\tpseudo_palette[16];\n\n\tvolatile struct cmap_regs\t__iomem *cmap_regs;\n\tunsigned long\t\t\tcmap_regs_phys;\n\n\tvolatile struct platinum_regs\t__iomem *platinum_regs;\n\tunsigned long\t\t\tplatinum_regs_phys;\n\n\t__u8\t\t\t\t__iomem *frame_buffer;\n\tvolatile __u8\t\t\t__iomem *base_frame_buffer;\n\tunsigned long\t\t\tframe_buffer_phys;\n\n\tunsigned long\t\t\ttotal_vram;\n\tint\t\t\t\tclktype;\n\tint\t\t\t\tdactype;\n\n\tstruct resource\t\t\trsrc_fb, rsrc_reg;\n};\n\n \n\nstatic int platinumfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\tu_int transp, struct fb_info *info);\nstatic int platinumfb_blank(int blank_mode, struct fb_info *info);\nstatic int platinumfb_set_par (struct fb_info *info);\nstatic int platinumfb_check_var (struct fb_var_screeninfo *var, struct fb_info *info);\n\n \n\nstatic inline int platinum_vram_reqd(int video_mode, int color_mode);\nstatic int read_platinum_sense(struct fb_info_platinum *pinfo);\nstatic void set_platinum_clock(struct fb_info_platinum *pinfo);\nstatic void platinum_set_hardware(struct fb_info_platinum *pinfo);\nstatic int platinum_var_to_par(struct fb_var_screeninfo *var,\n\t\t\t       struct fb_info_platinum *pinfo,\n\t\t\t       int check_only);\n\n \n\nstatic const struct fb_ops platinumfb_ops = {\n\t.owner =\tTHIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= platinumfb_check_var,\n\t.fb_set_par\t= platinumfb_set_par,\n\t.fb_setcolreg\t= platinumfb_setcolreg,\n\t.fb_blank\t= platinumfb_blank,\n};\n\n \nstatic int platinumfb_check_var (struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\treturn platinum_var_to_par(var, info->par, 1);\n}\n\n \nstatic int platinumfb_set_par (struct fb_info *info)\n{\n\tstruct fb_info_platinum *pinfo = info->par;\n\tstruct platinum_regvals *init;\n\tint err, offset = 0x20;\n\n\tif((err = platinum_var_to_par(&info->var, pinfo, 0))) {\n\t\tprintk (KERN_ERR \"platinumfb_set_par: error calling\"\n\t\t\t\t \" platinum_var_to_par: %d.\\n\", err);\n\t\treturn err;\n\t}\n\n\tplatinum_set_hardware(pinfo);\n\n\tinit = platinum_reg_init[pinfo->vmode-1];\n\n \tif ((pinfo->vmode == VMODE_832_624_75) && (pinfo->cmode > CMODE_8))\n  \t\toffset = 0x10;\n\n\tinfo->screen_base = pinfo->frame_buffer + init->fb_offset + offset;\n\tmutex_lock(&info->mm_lock);\n\tinfo->fix.smem_start = (pinfo->frame_buffer_phys) + init->fb_offset + offset;\n\tmutex_unlock(&info->mm_lock);\n\tinfo->fix.visual = (pinfo->cmode == CMODE_8) ?\n\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\n \tinfo->fix.line_length = vmode_attrs[pinfo->vmode-1].hres * (1<<pinfo->cmode)\n\t\t+ offset;\n\tprintk(\"line_length: %x\\n\", info->fix.line_length);\n\treturn 0;\n}\n\nstatic int platinumfb_blank(int blank,  struct fb_info *fb)\n{\n \n \n \n \n\treturn 0;\n}\n\nstatic int platinumfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t      u_int transp, struct fb_info *info)\n{\n\tstruct fb_info_platinum *pinfo = info->par;\n\tvolatile struct cmap_regs __iomem *cmap_regs = pinfo->cmap_regs;\n\n\tif (regno > 255)\n\t\treturn 1;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\tpinfo->palette[regno].red = red;\n\tpinfo->palette[regno].green = green;\n\tpinfo->palette[regno].blue = blue;\n\n\tout_8(&cmap_regs->addr, regno);\t\t \n\tout_8(&cmap_regs->lut, red);\t\t \n\tout_8(&cmap_regs->lut, green);\t\t \n\tout_8(&cmap_regs->lut, blue);\n\n\tif (regno < 16) {\n\t\tint i;\n\t\tu32 *pal = info->pseudo_palette;\n\t\tswitch (pinfo->cmode) {\n\t\tcase CMODE_16:\n\t\t\tpal[regno] = (regno << 10) | (regno << 5) | regno;\n\t\t\tbreak;\n\t\tcase CMODE_32:\n\t\t\ti = (regno << 8) | regno;\n\t\t\tpal[regno] = (i << 16) | i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int platinum_vram_reqd(int video_mode, int color_mode)\n{\n\tint baseval = vmode_attrs[video_mode-1].hres * (1<<color_mode);\n\n\tif ((video_mode == VMODE_832_624_75) && (color_mode > CMODE_8))\n\t\tbaseval += 0x10;\n\telse\n\t\tbaseval += 0x20;\n\n\treturn vmode_attrs[video_mode-1].vres * baseval + 0x1000;\n}\n\n#define STORE_D2(a, d) { \\\n\tout_8(&cmap_regs->addr, (a+32)); \\\n\tout_8(&cmap_regs->d2, (d)); \\\n}\n\nstatic void set_platinum_clock(struct fb_info_platinum *pinfo)\n{\n\tvolatile struct cmap_regs __iomem *cmap_regs = pinfo->cmap_regs;\n\tstruct platinum_regvals\t*init;\n\n\tinit = platinum_reg_init[pinfo->vmode-1];\n\n\tSTORE_D2(6, 0xc6);\n\tout_8(&cmap_regs->addr,3+32);\n\n\tif (in_8(&cmap_regs->d2) == 2) {\n\t\tSTORE_D2(7, init->clock_params[pinfo->clktype][0]);\n\t\tSTORE_D2(8, init->clock_params[pinfo->clktype][1]);\n\t\tSTORE_D2(3, 3);\n\t} else {\n\t\tSTORE_D2(4, init->clock_params[pinfo->clktype][0]);\n\t\tSTORE_D2(5, init->clock_params[pinfo->clktype][1]);\n\t\tSTORE_D2(3, 2);\n\t}\n\n\t__delay(5000);\n\tSTORE_D2(9, 0xa6);\n}\n\n\n \n \nstatic void platinum_set_hardware(struct fb_info_platinum *pinfo)\n{\n\tvolatile struct platinum_regs\t__iomem *platinum_regs = pinfo->platinum_regs;\n\tvolatile struct cmap_regs\t__iomem *cmap_regs = pinfo->cmap_regs;\n\tstruct platinum_regvals\t\t*init;\n\tint\t\t\t\ti;\n\tint\t\t\t\tvmode, cmode;\n\n\tvmode = pinfo->vmode;\n\tcmode = pinfo->cmode;\n\n\tinit = platinum_reg_init[vmode - 1];\n\n\t \n\tout_be32(&platinum_regs->reg[24].r, 7);\t \n\n\tfor (i = 0; i < 26; ++i)\n\t\tout_be32(&platinum_regs->reg[i+32].r, init->regs[i]);\n\n\tout_be32(&platinum_regs->reg[26+32].r, (pinfo->total_vram == 0x100000 ?\n\t\t\t\t\t\tinit->offset[cmode] + 4 - cmode :\n\t\t\t\t\t\tinit->offset[cmode]));\n\tout_be32(&platinum_regs->reg[16].r, (unsigned) pinfo->frame_buffer_phys+init->fb_offset+0x10);\n\tout_be32(&platinum_regs->reg[18].r, init->pitch[cmode]);\n\tout_be32(&platinum_regs->reg[19].r, (pinfo->total_vram == 0x100000 ?\n\t\t\t\t\t     init->mode[cmode+1] :\n\t\t\t\t\t     init->mode[cmode]));\n\tout_be32(&platinum_regs->reg[20].r, (pinfo->total_vram == 0x100000 ? 0x11 : 0x1011));\n\tout_be32(&platinum_regs->reg[21].r, 0x100);\n\tout_be32(&platinum_regs->reg[22].r, 1);\n\tout_be32(&platinum_regs->reg[23].r, 1);\n\tout_be32(&platinum_regs->reg[26].r, 0xc00);\n\tout_be32(&platinum_regs->reg[27].r, 0x235);\n\t \n\n\tSTORE_D2(0, (pinfo->total_vram == 0x100000 ?\n\t\t     init->dacula_ctrl[cmode] & 0xf :\n\t\t     init->dacula_ctrl[cmode]));\n\tSTORE_D2(1, 4);\n\tSTORE_D2(2, 0);\n\n\tset_platinum_clock(pinfo);\n\n\tout_be32(&platinum_regs->reg[24].r, 0);\t \n}\n\n \nstatic void platinum_init_info(struct fb_info *info,\n\t\t\t       struct fb_info_platinum *pinfo)\n{\n\t \n\tinfo->fbops = &platinumfb_ops;\n\tinfo->pseudo_palette = pinfo->pseudo_palette;\n\tinfo->screen_base = pinfo->frame_buffer + 0x20;\n\n\tfb_alloc_cmap(&info->cmap, 256, 0);\n\n\t \n\tstrcpy(info->fix.id, \"platinum\");\n\tinfo->fix.mmio_start = pinfo->platinum_regs_phys;\n\tinfo->fix.mmio_len = 0x1000;\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.smem_start = pinfo->frame_buffer_phys + 0x20;  \n\tinfo->fix.smem_len = pinfo->total_vram - 0x20;\n        info->fix.ywrapstep = 0;\n\tinfo->fix.xpanstep = 0;\n\tinfo->fix.ypanstep = 0;\n        info->fix.type_aux = 0;\n        info->fix.accel = FB_ACCEL_NONE;\n}\n\n\nstatic int platinum_init_fb(struct fb_info *info)\n{\n\tstruct fb_info_platinum *pinfo = info->par;\n\tstruct fb_var_screeninfo var;\n\tint sense, rc;\n\n\tsense = read_platinum_sense(pinfo);\n\tprintk(KERN_INFO \"platinumfb: Monitor sense value = 0x%x, \", sense);\n\n\tif (IS_REACHABLE(CONFIG_NVRAM) && default_vmode == VMODE_NVRAM)\n\t\tdefault_vmode = nvram_read_byte(NV_VMODE);\n\tif (default_vmode <= 0 || default_vmode > VMODE_MAX ||\n\t    !platinum_reg_init[default_vmode - 1]) {\n\t\tdefault_vmode = mac_map_monitor_sense(sense);\n\t\tif (!platinum_reg_init[default_vmode - 1])\n\t\t\tdefault_vmode = VMODE_640_480_60;\n\t}\n\n\tif (IS_REACHABLE(CONFIG_NVRAM) && default_cmode == CMODE_NVRAM)\n\t\tdefault_cmode = nvram_read_byte(NV_CMODE);\n\tif (default_cmode < CMODE_8 || default_cmode > CMODE_32)\n\t\tdefault_cmode = CMODE_8;\n\t \n\twhile(default_cmode > CMODE_8 &&\n\t      platinum_vram_reqd(default_vmode, default_cmode) > pinfo->total_vram)\n\t\tdefault_cmode--;\n\n\tprintk(\"platinumfb:  Using video mode %d and color mode %d.\\n\", default_vmode, default_cmode);\n\n\t \n\tif (mac_vmode_to_var(default_vmode, default_cmode, &var) < 0) {\n\t\t \n\t\tprintk(\"mac_vmode_to_var(%d, %d,) failed\\n\", default_vmode, default_cmode);\ntry_again:\n\t\tdefault_vmode = VMODE_640_480_60;\n\t\tdefault_cmode = CMODE_8;\n\t\tif (mac_vmode_to_var(default_vmode, default_cmode, &var) < 0) {\n\t\t\tprintk(KERN_ERR \"platinumfb: mac_vmode_to_var() failed\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\t \n\tplatinum_init_info(info, pinfo);\n\n\t \n\tinfo->var = var;\n\tvar.activate = FB_ACTIVATE_NOW;\n\trc = fb_set_var(info, &var);\n\tif (rc && (default_vmode != VMODE_640_480_60 || default_cmode != CMODE_8))\n\t\tgoto try_again;\n\n\t \n\trc = register_framebuffer(info);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tfb_info(info, \"Apple Platinum frame buffer device\\n\");\n\n\treturn 0;\n}\n\n \nstatic int read_platinum_sense(struct fb_info_platinum *info)\n{\n\tvolatile struct platinum_regs __iomem *platinum_regs = info->platinum_regs;\n\tint sense;\n\n\tout_be32(&platinum_regs->reg[23].r, 7);\t \n\t__delay(2000);\n\tsense = (~in_be32(&platinum_regs->reg[23].r) & 7) << 8;\n\n\t \n\tout_be32(&platinum_regs->reg[23].r, 3);\t \n\t__delay(2000);\n\tsense |= (~in_be32(&platinum_regs->reg[23].r) & 3) << 4;\n\tout_be32(&platinum_regs->reg[23].r, 5);\t \n\t__delay(2000);\n\tsense |= (~in_be32(&platinum_regs->reg[23].r) & 4) << 1;\n\tsense |= (~in_be32(&platinum_regs->reg[23].r) & 1) << 2;\n\tout_be32(&platinum_regs->reg[23].r, 6);\t \n\t__delay(2000);\n\tsense |= (~in_be32(&platinum_regs->reg[23].r) & 6) >> 1;\n\n\tout_be32(&platinum_regs->reg[23].r, 7);\t \n\n\treturn sense;\n}\n\n \nstatic int platinum_var_to_par(struct fb_var_screeninfo *var,\n\t\t\t       struct fb_info_platinum *pinfo,\n\t\t\t       int check_only)\n{\n\tint vmode, cmode;\n\n\tif (mac_var_to_vmode(var, &vmode, &cmode) != 0) {\n\t\tprintk(KERN_ERR \"platinum_var_to_par: mac_var_to_vmode unsuccessful.\\n\");\n\t\tprintk(KERN_ERR \"platinum_var_to_par: var->xres = %d\\n\", var->xres);\n\t\tprintk(KERN_ERR \"platinum_var_to_par: var->yres = %d\\n\", var->yres);\n\t\tprintk(KERN_ERR \"platinum_var_to_par: var->xres_virtual = %d\\n\", var->xres_virtual);\n\t\tprintk(KERN_ERR \"platinum_var_to_par: var->yres_virtual = %d\\n\", var->yres_virtual);\n\t\tprintk(KERN_ERR \"platinum_var_to_par: var->bits_per_pixel = %d\\n\", var->bits_per_pixel);\n\t\tprintk(KERN_ERR \"platinum_var_to_par: var->pixclock = %d\\n\", var->pixclock);\n\t\tprintk(KERN_ERR \"platinum_var_to_par: var->vmode = %d\\n\", var->vmode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!platinum_reg_init[vmode-1]) {\n\t\tprintk(KERN_ERR \"platinum_var_to_par, vmode %d not valid.\\n\", vmode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (platinum_vram_reqd(vmode, cmode) > pinfo->total_vram) {\n\t\tprintk(KERN_ERR \"platinum_var_to_par, not enough ram for vmode %d, cmode %d.\\n\", vmode, cmode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mac_vmode_to_var(vmode, cmode, var))\n\t\treturn -EINVAL;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tpinfo->vmode = vmode;\n\tpinfo->cmode = cmode;\n\tpinfo->xres = vmode_attrs[vmode-1].hres;\n\tpinfo->yres = vmode_attrs[vmode-1].vres;\n\tpinfo->xoffset = 0;\n\tpinfo->yoffset = 0;\n\tpinfo->vxres = pinfo->xres;\n\tpinfo->vyres = pinfo->yres;\n\n\treturn 0;\n}\n\n\n \nstatic int __init platinumfb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!strncmp(this_opt, \"vmode:\", 6)) {\n\t    \t\tint vmode = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\tif (vmode > 0 && vmode <= VMODE_MAX)\n\t\t\t\tdefault_vmode = vmode;\n\t\t} else if (!strncmp(this_opt, \"cmode:\", 6)) {\n\t\t\tint depth = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\tswitch (depth) {\n\t\t\t case 0:\n\t\t\t case 8:\n\t\t\t    default_cmode = CMODE_8;\n\t\t\t    break;\n\t\t\t case 15:\n\t\t\t case 16:\n\t\t\t    default_cmode = CMODE_16;\n\t\t\t    break;\n\t\t\t case 24:\n\t\t\t case 32:\n\t\t\t    default_cmode = CMODE_32;\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n#ifdef __powerpc__\n#define invalidate_cache(addr) \\\n\tasm volatile(\"eieio; dcbf 0,%1\" \\\n\t: \"=m\" (*(addr)) : \"r\" (addr) : \"memory\");\n#else\n#define invalidate_cache(addr)\n#endif\n\nstatic int platinumfb_probe(struct platform_device* odev)\n{\n\tstruct device_node\t*dp = odev->dev.of_node;\n\tstruct fb_info\t\t*info;\n\tstruct fb_info_platinum\t*pinfo;\n\tvolatile __u8\t\t*fbuffer;\n\tint\t\t\tbank0, bank1, bank2, bank3, rc;\n\n\tdev_info(&odev->dev, \"Found Apple Platinum video hardware\\n\");\n\n\tinfo = framebuffer_alloc(sizeof(*pinfo), &odev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpinfo = info->par;\n\n\tif (of_address_to_resource(dp, 0, &pinfo->rsrc_reg) ||\n\t    of_address_to_resource(dp, 1, &pinfo->rsrc_fb)) {\n\t\tdev_err(&odev->dev, \"Can't get resources\\n\");\n\t\tframebuffer_release(info);\n\t\treturn -ENXIO;\n\t}\n\tdev_dbg(&odev->dev, \" registers  : 0x%llx...0x%llx\\n\",\n\t\t(unsigned long long)pinfo->rsrc_reg.start,\n\t\t(unsigned long long)pinfo->rsrc_reg.end);\n\tdev_dbg(&odev->dev, \" framebuffer: 0x%llx...0x%llx\\n\",\n\t\t(unsigned long long)pinfo->rsrc_fb.start,\n\t\t(unsigned long long)pinfo->rsrc_fb.end);\n\n\t \n\tif (!request_mem_region(pinfo->rsrc_fb.start,\n\t\t\t\tresource_size(&pinfo->rsrc_fb),\n\t\t\t\t\"platinumfb framebuffer\")) {\n\t\tprintk(KERN_ERR \"platinumfb: Can't request framebuffer !\\n\");\n\t\tframebuffer_release(info);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tpinfo->frame_buffer_phys = pinfo->rsrc_fb.start;\n\tpinfo->frame_buffer = ioremap_wt(pinfo->rsrc_fb.start, 0x400000);\n\tpinfo->base_frame_buffer = pinfo->frame_buffer;\n\n\t \n\tpinfo->platinum_regs_phys = pinfo->rsrc_reg.start;\n\tpinfo->platinum_regs = ioremap(pinfo->rsrc_reg.start, 0x1000);\n\n\tpinfo->cmap_regs_phys = 0xf301b000;\t \n\trequest_mem_region(pinfo->cmap_regs_phys, 0x1000, \"platinumfb cmap\");\n\tpinfo->cmap_regs = ioremap(pinfo->cmap_regs_phys, 0x1000);\n\n\t \n\tout_be32(&pinfo->platinum_regs->reg[16].r, (unsigned)pinfo->frame_buffer_phys);\n\tout_be32(&pinfo->platinum_regs->reg[20].r, 0x1011);\t \n\tout_be32(&pinfo->platinum_regs->reg[24].r, 0);\t \n\n\tfbuffer = pinfo->base_frame_buffer;\n\tfbuffer[0x100000] = 0x34;\n\tfbuffer[0x100008] = 0x0;\n\tinvalidate_cache(&fbuffer[0x100000]);\n\tfbuffer[0x200000] = 0x56;\n\tfbuffer[0x200008] = 0x0;\n\tinvalidate_cache(&fbuffer[0x200000]);\n\tfbuffer[0x300000] = 0x78;\n\tfbuffer[0x300008] = 0x0;\n\tinvalidate_cache(&fbuffer[0x300000]);\n\tbank0 = 1;  \n\tbank1 = fbuffer[0x100000] == 0x34;\n\tbank2 = fbuffer[0x200000] == 0x56;\n\tbank3 = fbuffer[0x300000] == 0x78;\n\tpinfo->total_vram = (bank0 + bank1 + bank2 + bank3) * 0x100000;\n\tprintk(KERN_INFO \"platinumfb: Total VRAM = %dMB (%d%d%d%d)\\n\",\n\t       (unsigned int) (pinfo->total_vram / 1024 / 1024),\n\t       bank3, bank2, bank1, bank0);\n\n\t \n\tout_8(&pinfo->cmap_regs->addr, 0x40);\n\tpinfo->dactype = in_8(&pinfo->cmap_regs->d2);\n\tswitch (pinfo->dactype) {\n\tcase 0x3c:\n\t\tpinfo->clktype = 1;\n\t\tprintk(KERN_INFO \"platinumfb: DACula type 0x3c\\n\");\n\t\tbreak;\n\tcase 0x84:\n\t\tpinfo->clktype = 0;\n\t\tprintk(KERN_INFO \"platinumfb: DACula type 0x84\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpinfo->clktype = 0;\n\t\tprintk(KERN_INFO \"platinumfb: Unknown DACula type: %x\\n\", pinfo->dactype);\n\t\tbreak;\n\t}\n\tdev_set_drvdata(&odev->dev, info);\n\n\trc = platinum_init_fb(info);\n\tif (rc != 0) {\n\t\tiounmap(pinfo->frame_buffer);\n\t\tiounmap(pinfo->platinum_regs);\n\t\tiounmap(pinfo->cmap_regs);\n\t\tframebuffer_release(info);\n\t}\n\n\treturn rc;\n}\n\nstatic void platinumfb_remove(struct platform_device* odev)\n{\n\tstruct fb_info\t\t*info = dev_get_drvdata(&odev->dev);\n\tstruct fb_info_platinum\t*pinfo = info->par;\n\n        unregister_framebuffer (info);\n\n\t \n\tiounmap(pinfo->frame_buffer);\n\tiounmap(pinfo->platinum_regs);\n\tiounmap(pinfo->cmap_regs);\n\n\trelease_mem_region(pinfo->rsrc_fb.start,\n\t\t\t   resource_size(&pinfo->rsrc_fb));\n\n\trelease_mem_region(pinfo->cmap_regs_phys, 0x1000);\n\n\tframebuffer_release(info);\n}\n\nstatic struct of_device_id platinumfb_match[] =\n{\n\t{\n\t.name \t\t= \"platinum\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver platinum_driver =\n{\n\t.driver = {\n\t\t.name = \"platinumfb\",\n\t\t.of_match_table = platinumfb_match,\n\t},\n\t.probe\t\t= platinumfb_probe,\n\t.remove_new\t= platinumfb_remove,\n};\n\nstatic int __init platinumfb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"platinumfb\", &option))\n\t\treturn -ENODEV;\n\tplatinumfb_setup(option);\n#endif\n\tplatform_driver_register(&platinum_driver);\n\n\treturn 0;\n}\n\nstatic void __exit platinumfb_exit(void)\n{\n\tplatform_driver_unregister(&platinum_driver);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"framebuffer driver for Apple Platinum video\");\nmodule_init(platinumfb_init);\n\n#ifdef MODULE\nmodule_exit(platinumfb_exit);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}