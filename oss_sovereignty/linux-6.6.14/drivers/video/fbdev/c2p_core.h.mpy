{
  "module_name": "c2p_core.h",
  "hash_id": "7430caabcc6a541e4440a2022a86c563fa5198f219a0a97fafabf0e13d587c26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/c2p_core.h",
  "human_readable_source": " \n\n#include <linux/build_bug.h>\n\n\n     \n\nstatic inline void _transp(u32 d[], unsigned int i1, unsigned int i2,\n\t\t\t   unsigned int shift, u32 mask)\n{\n\tu32 t = (d[i1] ^ (d[i2] >> shift)) & mask;\n\n\td[i1] ^= t;\n\td[i2] ^= t << shift;\n}\n\n\nstatic __always_inline u32 get_mask(unsigned int n)\n{\n\tswitch (n) {\n\tcase 1:\n\t\treturn 0x55555555;\n\n\tcase 2:\n\t\treturn 0x33333333;\n\n\tcase 4:\n\t\treturn 0x0f0f0f0f;\n\n\tcase 8:\n\t\treturn 0x00ff00ff;\n\n\tcase 16:\n\t\treturn 0x0000ffff;\n\t}\n\n\tBUILD_BUG();\n\treturn 0;\n}\n\n\n     \n\nstatic __always_inline void transp8(u32 d[], unsigned int n, unsigned int m)\n{\n\tu32 mask = get_mask(n);\n\n\tswitch (m) {\n\tcase 1:\n\t\t \n\t\t_transp(d, 0, 1, n, mask);\n\t\t \n\t\t_transp(d, 2, 3, n, mask);\n\t\t \n\t\t_transp(d, 4, 5, n, mask);\n\t\t \n\t\t_transp(d, 6, 7, n, mask);\n\t\treturn;\n\n\tcase 2:\n\t\t \n\t\t_transp(d, 0, 2, n, mask);\n\t\t_transp(d, 1, 3, n, mask);\n\t\t \n\t\t_transp(d, 4, 6, n, mask);\n\t\t_transp(d, 5, 7, n, mask);\n\t\treturn;\n\n\tcase 4:\n\t\t \n\t\t_transp(d, 0, 4, n, mask);\n\t\t_transp(d, 1, 5, n, mask);\n\t\t_transp(d, 2, 6, n, mask);\n\t\t_transp(d, 3, 7, n, mask);\n\t\treturn;\n\t}\n\n\tBUILD_BUG();\n}\n\n\n     \n\nstatic __always_inline void transp4(u32 d[], unsigned int n, unsigned int m)\n{\n\tu32 mask = get_mask(n);\n\n\tswitch (m) {\n\tcase 1:\n\t\t \n\t\t_transp(d, 0, 1, n, mask);\n\t\t \n\t\t_transp(d, 2, 3, n, mask);\n\t\treturn;\n\n\tcase 2:\n\t\t \n\t\t_transp(d, 0, 2, n, mask);\n\t\t_transp(d, 1, 3, n, mask);\n\t\treturn;\n\t}\n\n\tBUILD_BUG();\n}\n\n\n     \n\nstatic __always_inline void transp4x(u32 d[], unsigned int n, unsigned int m)\n{\n\tu32 mask = get_mask(n);\n\n\tswitch (m) {\n\tcase 2:\n\t\t \n\t\t_transp(d, 2, 0, n, mask);\n\t\t_transp(d, 3, 1, n, mask);\n\t\treturn;\n\t}\n\n\tBUILD_BUG();\n}\n\n\n     \n\nstatic inline u32 comp(u32 a, u32 b, u32 mask)\n{\n\treturn ((a ^ b) & mask) ^ b;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}