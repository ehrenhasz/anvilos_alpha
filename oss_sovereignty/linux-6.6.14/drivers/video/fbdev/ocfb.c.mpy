{
  "module_name": "ocfb.c",
  "hash_id": "5647d5347493959f917e19254d1d3cdec689684eef048d2adaa2151760906e87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/ocfb.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n \n#define OCFB_CTRL\t0x000\n#define OCFB_STAT\t0x004\n#define OCFB_HTIM\t0x008\n#define OCFB_VTIM\t0x00c\n#define OCFB_HVLEN\t0x010\n#define OCFB_VBARA\t0x014\n#define OCFB_PALETTE\t0x800\n\n#define OCFB_CTRL_VEN\t0x00000001  \n#define OCFB_CTRL_HIE\t0x00000002  \n#define OCFB_CTRL_PC\t0x00000800  \n#define OCFB_CTRL_CD8\t0x00000000  \n#define OCFB_CTRL_CD16\t0x00000200  \n#define OCFB_CTRL_CD24\t0x00000400  \n#define OCFB_CTRL_CD32\t0x00000600  \n#define OCFB_CTRL_VBL1\t0x00000000  \n#define OCFB_CTRL_VBL2\t0x00000080  \n#define OCFB_CTRL_VBL4\t0x00000100  \n#define OCFB_CTRL_VBL8\t0x00000180  \n\n#define PALETTE_SIZE\t256\n\n#define OCFB_NAME\t\"OC VGA/LCD\"\n\nstatic char *mode_option;\n\nstatic const struct fb_videomode default_mode = {\n\t \n\tNULL, 60, 640, 480, 39721, 40, 24, 32, 11, 96, 2,\n\t0, FB_VMODE_NONINTERLACED\n};\n\nstruct ocfb_dev {\n\tstruct fb_info info;\n\tvoid __iomem *regs;\n\t \n\tint little_endian;\n\t \n\tdma_addr_t fb_phys;\n\tvoid __iomem *fb_virt;\n\tu32 pseudo_palette[PALETTE_SIZE];\n};\n\n#ifndef MODULE\nstatic int __init ocfb_setup(char *options)\n{\n\tchar *curr_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((curr_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*curr_opt)\n\t\t\tcontinue;\n\t\tmode_option = curr_opt;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic inline u32 ocfb_readreg(struct ocfb_dev *fbdev, loff_t offset)\n{\n\tif (fbdev->little_endian)\n\t\treturn ioread32(fbdev->regs + offset);\n\telse\n\t\treturn ioread32be(fbdev->regs + offset);\n}\n\nstatic void ocfb_writereg(struct ocfb_dev *fbdev, loff_t offset, u32 data)\n{\n\tif (fbdev->little_endian)\n\t\tiowrite32(data, fbdev->regs + offset);\n\telse\n\t\tiowrite32be(data, fbdev->regs + offset);\n}\n\nstatic int ocfb_setupfb(struct ocfb_dev *fbdev)\n{\n\tunsigned long bpp_config;\n\tstruct fb_var_screeninfo *var = &fbdev->info.var;\n\tstruct device *dev = fbdev->info.device;\n\tu32 hlen;\n\tu32 vlen;\n\n\t \n\tocfb_writereg(fbdev, OCFB_CTRL, 0);\n\n\t \n\tfbdev->little_endian = 0;\n\tocfb_writereg(fbdev, OCFB_VBARA, fbdev->fb_phys);\n\n\t \n\tif (ocfb_readreg(fbdev, OCFB_VBARA) != fbdev->fb_phys) {\n\t\tfbdev->little_endian = 1;\n\t\tocfb_writereg(fbdev, OCFB_VBARA, fbdev->fb_phys);\n\t}\n\n\t \n\tocfb_writereg(fbdev, OCFB_HTIM, (var->hsync_len - 1) << 24 |\n\t\t      (var->left_margin - 1) << 16 | (var->xres - 1));\n\n\t \n\tocfb_writereg(fbdev, OCFB_VTIM, (var->vsync_len - 1) << 24 |\n\t\t      (var->upper_margin - 1) << 16 | (var->yres - 1));\n\n\t \n\thlen = var->left_margin + var->right_margin + var->hsync_len +\n\t\tvar->xres;\n\n\tvlen = var->upper_margin + var->lower_margin + var->vsync_len +\n\t\tvar->yres;\n\n\tocfb_writereg(fbdev, OCFB_HVLEN, (hlen - 1) << 16 | (vlen - 1));\n\n\tbpp_config = OCFB_CTRL_CD8;\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tif (!var->grayscale)\n\t\t\tbpp_config |= OCFB_CTRL_PC;   \n\t\tbreak;\n\n\tcase 16:\n\t\tbpp_config |= OCFB_CTRL_CD16;\n\t\tbreak;\n\n\tcase 24:\n\t\tbpp_config |= OCFB_CTRL_CD24;\n\t\tbreak;\n\n\tcase 32:\n\t\tbpp_config |= OCFB_CTRL_CD32;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"no bpp specified\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tbpp_config |= OCFB_CTRL_VBL8;\n\n\t \n\tocfb_writereg(fbdev, OCFB_CTRL, (OCFB_CTRL_VEN | bpp_config));\n\n\treturn 0;\n}\n\nstatic int ocfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t  unsigned blue, unsigned transp,\n\t\t\t  struct fb_info *info)\n{\n\tstruct ocfb_dev *fbdev = (struct ocfb_dev *)info->par;\n\tu32 color;\n\n\tif (regno >= info->cmap.len) {\n\t\tdev_err(info->device, \"regno >= cmap.len\\n\");\n\t\treturn 1;\n\t}\n\n\tif (info->var.grayscale) {\n\t\t \n\t\tred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n\t}\n\n\tred >>= (16 - info->var.red.length);\n\tgreen >>= (16 - info->var.green.length);\n\tblue >>= (16 - info->var.blue.length);\n\ttransp >>= (16 - info->var.transp.length);\n\n\tif (info->var.bits_per_pixel == 8 && !info->var.grayscale) {\n\t\tregno <<= 2;\n\t\tcolor = (red << 16) | (green << 8) | blue;\n\t\tocfb_writereg(fbdev, OCFB_PALETTE + regno, color);\n\t} else {\n\t\t((u32 *)(info->pseudo_palette))[regno] =\n\t\t\t(red << info->var.red.offset) |\n\t\t\t(green << info->var.green.offset) |\n\t\t\t(blue << info->var.blue.offset) |\n\t\t\t(transp << info->var.transp.offset);\n\t}\n\n\treturn 0;\n}\n\nstatic int ocfb_init_fix(struct ocfb_dev *fbdev)\n{\n\tstruct fb_var_screeninfo *var = &fbdev->info.var;\n\tstruct fb_fix_screeninfo *fix = &fbdev->info.fix;\n\n\tstrcpy(fix->id, OCFB_NAME);\n\n\tfix->line_length = var->xres * var->bits_per_pixel/8;\n\tfix->smem_len = fix->line_length * var->yres;\n\tfix->type = FB_TYPE_PACKED_PIXELS;\n\n\tif (var->bits_per_pixel == 8 && !var->grayscale)\n\t\tfix->visual = FB_VISUAL_PSEUDOCOLOR;\n\telse\n\t\tfix->visual = FB_VISUAL_TRUECOLOR;\n\n\treturn 0;\n}\n\nstatic int ocfb_init_var(struct ocfb_dev *fbdev)\n{\n\tstruct fb_var_screeninfo *var = &fbdev->info.var;\n\n\tvar->accel_flags = FB_ACCEL_NONE;\n\tvar->activate = FB_ACTIVATE_NOW;\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = var->yres;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\n\tcase 16:\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tvar->red.offset = 11;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length  = 5;\n\t\tbreak;\n\n\tcase 24:\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct fb_ops ocfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_setcolreg\t= ocfb_setcolreg,\n};\n\nstatic int ocfb_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tstruct ocfb_dev *fbdev;\n\tint fbsize;\n\n\tfbdev = devm_kzalloc(&pdev->dev, sizeof(*fbdev), GFP_KERNEL);\n\tif (!fbdev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, fbdev);\n\n\tfbdev->info.fbops = &ocfb_ops;\n\tfbdev->info.device = &pdev->dev;\n\tfbdev->info.par = fbdev;\n\n\t \n\tif (!fb_find_mode(&fbdev->info.var, &fbdev->info, mode_option,\n\t\t\t  NULL, 0, &default_mode, 16)) {\n\t\tdev_err(&pdev->dev, \"No valid video modes found\\n\");\n\t\treturn -EINVAL;\n\t}\n\tocfb_init_var(fbdev);\n\tocfb_init_fix(fbdev);\n\n\tfbdev->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(fbdev->regs))\n\t\treturn PTR_ERR(fbdev->regs);\n\n\t \n\tfbsize = fbdev->info.fix.smem_len;\n\tfbdev->fb_virt = dma_alloc_coherent(&pdev->dev, PAGE_ALIGN(fbsize),\n\t\t\t\t\t    &fbdev->fb_phys, GFP_KERNEL);\n\tif (!fbdev->fb_virt) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Frame buffer memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tfbdev->info.fix.smem_start = fbdev->fb_phys;\n\tfbdev->info.screen_base = fbdev->fb_virt;\n\tfbdev->info.pseudo_palette = fbdev->pseudo_palette;\n\n\t \n\tmemset_io(fbdev->fb_virt, 0, fbsize);\n\n\t \n\tocfb_setupfb(fbdev);\n\n\tif (fbdev->little_endian)\n\t\tfbdev->info.flags |= FBINFO_FOREIGN_ENDIAN;\n\n\t \n\tret = fb_alloc_cmap(&fbdev->info.cmap, PALETTE_SIZE, 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Color map allocation failed\\n\");\n\t\tgoto err_dma_free;\n\t}\n\n\t \n\tret = register_framebuffer(&fbdev->info);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Framebuffer registration failed\\n\");\n\t\tgoto err_dealloc_cmap;\n\t}\n\n\treturn 0;\n\nerr_dealloc_cmap:\n\tfb_dealloc_cmap(&fbdev->info.cmap);\n\nerr_dma_free:\n\tdma_free_coherent(&pdev->dev, PAGE_ALIGN(fbsize), fbdev->fb_virt,\n\t\t\t  fbdev->fb_phys);\n\n\treturn ret;\n}\n\nstatic void ocfb_remove(struct platform_device *pdev)\n{\n\tstruct ocfb_dev *fbdev = platform_get_drvdata(pdev);\n\n\tunregister_framebuffer(&fbdev->info);\n\tfb_dealloc_cmap(&fbdev->info.cmap);\n\tdma_free_coherent(&pdev->dev, PAGE_ALIGN(fbdev->info.fix.smem_len),\n\t\t\t  fbdev->fb_virt, fbdev->fb_phys);\n\n\t \n\tocfb_writereg(fbdev, OCFB_CTRL, 0);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic const struct of_device_id ocfb_match[] = {\n\t{ .compatible = \"opencores,ocfb\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ocfb_match);\n\nstatic struct platform_driver ocfb_driver = {\n\t.probe  = ocfb_probe,\n\t.remove_new = ocfb_remove,\n\t.driver = {\n\t\t.name = \"ocfb_fb\",\n\t\t.of_match_table = ocfb_match,\n\t}\n};\n\n \nstatic int __init ocfb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"ocfb\", &option))\n\t\treturn -ENODEV;\n\tocfb_setup(option);\n#endif\n\treturn platform_driver_register(&ocfb_driver);\n}\n\nstatic void __exit ocfb_exit(void)\n{\n\tplatform_driver_unregister(&ocfb_driver);\n}\n\nmodule_init(ocfb_init);\nmodule_exit(ocfb_exit);\n\nMODULE_AUTHOR(\"Stefan Kristiansson <stefan.kristiansson@saunalahti.fi>\");\nMODULE_DESCRIPTION(\"OpenCores VGA/LCD 2.0 frame buffer driver\");\nMODULE_LICENSE(\"GPL v2\");\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Video mode ('<xres>x<yres>[-<bpp>][@refresh]')\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}