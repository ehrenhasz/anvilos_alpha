{
  "module_name": "vesafb.c",
  "hash_id": "642bb42eef577cb620682ae52663dd8388b255b277f1846a1850c900bfa12c4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/vesafb.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/screen_info.h>\n#include <linux/io.h>\n\n#include <video/vga.h>\n\n#define dac_reg\t(0x3c8)\n#define dac_val\t(0x3c9)\n\n \n\nstruct vesafb_par {\n\tu32 pseudo_palette[256];\n\tresource_size_t base;\n\tresource_size_t size;\n\tint wc_cookie;\n\tstruct resource *region;\n};\n\nstatic struct fb_var_screeninfo vesafb_defined = {\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.right_margin\t= 32,\n\t.upper_margin\t= 16,\n\t.lower_margin\t= 4,\n\t.vsync_len\t= 4,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\nstatic struct fb_fix_screeninfo vesafb_fix = {\n\t.id\t= \"VESA VGA\",\n\t.type\t= FB_TYPE_PACKED_PIXELS,\n\t.accel\t= FB_ACCEL_NONE,\n};\n\nstatic int   inverse    __read_mostly;\nstatic int   mtrr       __read_mostly;\t\t \nstatic int   vram_remap;\t\t\t \nstatic int   vram_total;\t\t\t \nstatic int   pmi_setpal __read_mostly = 1;\t \nstatic int   ypan       __read_mostly;\t\t \nstatic void  (*pmi_start)(void) __read_mostly;\nstatic void  (*pmi_pal)  (void) __read_mostly;\nstatic int   depth      __read_mostly;\nstatic int   vga_compat __read_mostly;\n \n\nstatic int vesafb_pan_display(struct fb_var_screeninfo *var,\n                              struct fb_info *info)\n{\n#ifdef __i386__\n\tint offset;\n\n\toffset = (var->yoffset * info->fix.line_length + var->xoffset) / 4;\n\n        __asm__ __volatile__(\n                \"call *(%%edi)\"\n                :  \n                : \"a\" (0x4f07),          \n                  \"b\" (0),               \n                  \"c\" (offset),          \n                  \"d\" (offset >> 16),    \n                  \"D\" (&pmi_start));     \n#endif\n\treturn 0;\n}\n\nstatic int vesa_setpalette(int regno, unsigned red, unsigned green,\n\t\t\t    unsigned blue)\n{\n\tint shift = 16 - depth;\n\tint err = -EINVAL;\n\n \n\tif (vga_compat) {\n\t\toutb_p(regno,       dac_reg);\n\t\toutb_p(red   >> shift, dac_val);\n\t\toutb_p(green >> shift, dac_val);\n\t\toutb_p(blue  >> shift, dac_val);\n\t\terr = 0;\n\t}\n\n#ifdef __i386__\n \n\tif (err && pmi_setpal) {\n\t\tstruct { u_char blue, green, red, pad; } entry;\n\n\t\tentry.red   = red   >> shift;\n\t\tentry.green = green >> shift;\n\t\tentry.blue  = blue  >> shift;\n\t\tentry.pad   = 0;\n\t        __asm__ __volatile__(\n                \"call *(%%esi)\"\n                :  \n                : \"a\" (0x4f09),          \n                  \"b\" (0),               \n                  \"c\" (1),               \n                  \"d\" (regno),           \n                  \"D\" (&entry),          \n                  \"S\" (&pmi_pal));       \n\t\terr = 0;\n\t}\n#endif\n\n\treturn err;\n}\n\nstatic int vesafb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t    unsigned blue, unsigned transp,\n\t\t\t    struct fb_info *info)\n{\n\tint err = 0;\n\n\t \n\n\tif (regno >= info->cmap.len)\n\t\treturn 1;\n\n\tif (info->var.bits_per_pixel == 8)\n\t\terr = vesa_setpalette(regno,red,green,blue);\n\telse if (regno < 16) {\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 16:\n\t\t\tif (info->var.red.offset == 10) {\n\t\t\t\t \n\t\t\t\t((u32*) (info->pseudo_palette))[regno] =\n\t\t\t\t\t((red   & 0xf800) >>  1) |\n\t\t\t\t\t((green & 0xf800) >>  6) |\n\t\t\t\t\t((blue  & 0xf800) >> 11);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t((u32*) (info->pseudo_palette))[regno] =\n\t\t\t\t\t((red   & 0xf800)      ) |\n\t\t\t\t\t((green & 0xfc00) >>  5) |\n\t\t\t\t\t((blue  & 0xf800) >> 11);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tred   >>= 8;\n\t\t\tgreen >>= 8;\n\t\t\tblue  >>= 8;\n\t\t\t((u32 *)(info->pseudo_palette))[regno] =\n\t\t\t\t(red   << info->var.red.offset)   |\n\t\t\t\t(green << info->var.green.offset) |\n\t\t\t\t(blue  << info->var.blue.offset);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic void vesafb_destroy(struct fb_info *info)\n{\n\tstruct vesafb_par *par = info->par;\n\n\tfb_dealloc_cmap(&info->cmap);\n\tarch_phys_wc_del(par->wc_cookie);\n\tif (info->screen_base)\n\t\tiounmap(info->screen_base);\n\trelease_mem_region(par->base, par->size);\n\n\tframebuffer_release(info);\n}\n\nstatic struct fb_ops vesafb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_destroy     = vesafb_destroy,\n\t.fb_setcolreg\t= vesafb_setcolreg,\n\t.fb_pan_display\t= vesafb_pan_display,\n};\n\nstatic int vesafb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt) continue;\n\n\t\tif (! strcmp(this_opt, \"inverse\"))\n\t\t\tinverse=1;\n\t\telse if (! strcmp(this_opt, \"redraw\"))\n\t\t\typan=0;\n\t\telse if (! strcmp(this_opt, \"ypan\"))\n\t\t\typan=1;\n\t\telse if (! strcmp(this_opt, \"ywrap\"))\n\t\t\typan=2;\n\t\telse if (! strcmp(this_opt, \"vgapal\"))\n\t\t\tpmi_setpal=0;\n\t\telse if (! strcmp(this_opt, \"pmipal\"))\n\t\t\tpmi_setpal=1;\n\t\telse if (! strncmp(this_opt, \"mtrr:\", 5))\n\t\t\tmtrr = simple_strtoul(this_opt+5, NULL, 0);\n\t\telse if (! strcmp(this_opt, \"nomtrr\"))\n\t\t\tmtrr=0;\n\t\telse if (! strncmp(this_opt, \"vtotal:\", 7))\n\t\t\tvram_total = simple_strtoul(this_opt+7, NULL, 0);\n\t\telse if (! strncmp(this_opt, \"vremap:\", 7))\n\t\t\tvram_remap = simple_strtoul(this_opt+7, NULL, 0);\n\t}\n\treturn 0;\n}\n\nstatic int vesafb_probe(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\tstruct vesafb_par *par;\n\tint i, err;\n\tunsigned int size_vmode;\n\tunsigned int size_remap;\n\tunsigned int size_total;\n\tchar *option = NULL;\n\n\t \n\tfb_get_options(\"vesafb\", &option);\n\tvesafb_setup(option);\n\n\tif (screen_info.orig_video_isVGA != VIDEO_TYPE_VLFB)\n\t\treturn -ENODEV;\n\n\tvga_compat = (screen_info.capabilities & 2) ? 0 : 1;\n\tvesafb_fix.smem_start = screen_info.lfb_base;\n\tvesafb_defined.bits_per_pixel = screen_info.lfb_depth;\n\tif (15 == vesafb_defined.bits_per_pixel)\n\t\tvesafb_defined.bits_per_pixel = 16;\n\tvesafb_defined.xres = screen_info.lfb_width;\n\tvesafb_defined.yres = screen_info.lfb_height;\n\tvesafb_fix.line_length = screen_info.lfb_linelength;\n\tvesafb_fix.visual   = (vesafb_defined.bits_per_pixel == 8) ?\n\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\n\t \n\tsize_vmode = vesafb_defined.yres * vesafb_fix.line_length;\n\n\t \n\tsize_total = screen_info.lfb_size * 65536;\n\tif (vram_total)\n\t\tsize_total = vram_total * 1024 * 1024;\n\tif (size_total < size_vmode)\n\t\tsize_total = size_vmode;\n\n\t \n\tsize_remap  = size_vmode * 2;\n\tif (vram_remap)\n\t\tsize_remap = vram_remap * 1024 * 1024;\n\tif (size_remap < size_vmode)\n\t\tsize_remap = size_vmode;\n\tif (size_remap > size_total)\n\t\tsize_remap = size_total;\n\tvesafb_fix.smem_len = size_remap;\n\n#ifndef __i386__\n\tscreen_info.vesapm_seg = 0;\n#endif\n\n\tif (!request_mem_region(vesafb_fix.smem_start, size_total, \"vesafb\")) {\n\t\tprintk(KERN_WARNING\n\t\t       \"vesafb: cannot reserve video memory at 0x%lx\\n\",\n\t\t\tvesafb_fix.smem_start);\n\t\t \n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct vesafb_par), &dev->dev);\n\tif (!info) {\n\t\trelease_mem_region(vesafb_fix.smem_start, size_total);\n\t\treturn -ENOMEM;\n\t}\n\tplatform_set_drvdata(dev, info);\n\tpar = info->par;\n\tinfo->pseudo_palette = par->pseudo_palette;\n\n\tpar->base = screen_info.lfb_base;\n\tpar->size = size_total;\n\n\tprintk(KERN_INFO \"vesafb: mode is %dx%dx%d, linelength=%d, pages=%d\\n\",\n\t       vesafb_defined.xres, vesafb_defined.yres, vesafb_defined.bits_per_pixel, vesafb_fix.line_length, screen_info.pages);\n\n\tif (screen_info.vesapm_seg) {\n\t\tprintk(KERN_INFO \"vesafb: protected mode interface info at %04x:%04x\\n\",\n\t\t       screen_info.vesapm_seg,screen_info.vesapm_off);\n\t}\n\n\tif (screen_info.vesapm_seg < 0xc000)\n\t\typan = pmi_setpal = 0;  \n\n\tif (ypan || pmi_setpal) {\n\t\tunsigned short *pmi_base;\n\t\tpmi_base  = (unsigned short*)phys_to_virt(((unsigned long)screen_info.vesapm_seg << 4) + screen_info.vesapm_off);\n\t\tpmi_start = (void*)((char*)pmi_base + pmi_base[1]);\n\t\tpmi_pal   = (void*)((char*)pmi_base + pmi_base[2]);\n\t\tprintk(KERN_INFO \"vesafb: pmi: set display start = %p, set palette = %p\\n\",pmi_start,pmi_pal);\n\t\tif (pmi_base[3]) {\n\t\t\tprintk(KERN_INFO \"vesafb: pmi: ports = \");\n\t\t\tfor (i = pmi_base[3]/2; pmi_base[i] != 0xffff; i++)\n\t\t\t\tprintk(\"%x \", pmi_base[i]);\n\t\t\tprintk(\"\\n\");\n\t\t\tif (pmi_base[i] != 0xffff) {\n\t\t\t\t \n\t\t\t\tprintk(KERN_INFO \"vesafb: can't handle memory requests, pmi disabled\\n\");\n\t\t\t\typan = pmi_setpal = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vesafb_defined.bits_per_pixel == 8 && !pmi_setpal && !vga_compat) {\n\t\tprintk(KERN_WARNING \"vesafb: hardware palette is unchangeable,\\n\"\n\t\t                    \"        colors may be incorrect\\n\");\n\t\tvesafb_fix.visual = FB_VISUAL_STATIC_PSEUDOCOLOR;\n\t}\n\n\tvesafb_defined.xres_virtual = vesafb_defined.xres;\n\tvesafb_defined.yres_virtual = vesafb_fix.smem_len / vesafb_fix.line_length;\n\tif (ypan && vesafb_defined.yres_virtual > vesafb_defined.yres) {\n\t\tprintk(KERN_INFO \"vesafb: scrolling: %s using protected mode interface, yres_virtual=%d\\n\",\n\t\t       (ypan > 1) ? \"ywrap\" : \"ypan\",vesafb_defined.yres_virtual);\n\t} else {\n\t\tprintk(KERN_INFO \"vesafb: scrolling: redraw\\n\");\n\t\tvesafb_defined.yres_virtual = vesafb_defined.yres;\n\t\typan = 0;\n\t}\n\n\t \n\tvesafb_defined.pixclock     = 10000000 / vesafb_defined.xres * 1000 / vesafb_defined.yres;\n\tvesafb_defined.left_margin  = (vesafb_defined.xres / 8) & 0xf8;\n\tvesafb_defined.hsync_len    = (vesafb_defined.xres / 8) & 0xf8;\n\n\tvesafb_defined.red.offset    = screen_info.red_pos;\n\tvesafb_defined.red.length    = screen_info.red_size;\n\tvesafb_defined.green.offset  = screen_info.green_pos;\n\tvesafb_defined.green.length  = screen_info.green_size;\n\tvesafb_defined.blue.offset   = screen_info.blue_pos;\n\tvesafb_defined.blue.length   = screen_info.blue_size;\n\tvesafb_defined.transp.offset = screen_info.rsvd_pos;\n\tvesafb_defined.transp.length = screen_info.rsvd_size;\n\n\tif (vesafb_defined.bits_per_pixel <= 8) {\n\t\tdepth = vesafb_defined.green.length;\n\t\tvesafb_defined.red.length =\n\t\tvesafb_defined.green.length =\n\t\tvesafb_defined.blue.length =\n\t\tvesafb_defined.bits_per_pixel;\n\t}\n\n\tprintk(KERN_INFO \"vesafb: %s: \"\n\t       \"size=%d:%d:%d:%d, shift=%d:%d:%d:%d\\n\",\n\t       (vesafb_defined.bits_per_pixel > 8) ?\n\t       \"Truecolor\" : (vga_compat || pmi_setpal) ?\n\t       \"Pseudocolor\" : \"Static Pseudocolor\",\n\t       screen_info.rsvd_size,\n\t       screen_info.red_size,\n\t       screen_info.green_size,\n\t       screen_info.blue_size,\n\t       screen_info.rsvd_pos,\n\t       screen_info.red_pos,\n\t       screen_info.green_pos,\n\t       screen_info.blue_pos);\n\n\tvesafb_fix.ypanstep  = ypan     ? 1 : 0;\n\tvesafb_fix.ywrapstep = (ypan>1) ? 1 : 0;\n\n\t \n\tpar->region = request_region(0x3c0, 32, \"vesafb\");\n\n\tif (mtrr == 3) {\n\t\tunsigned int temp_size = size_total;\n\n\t\t \n\t\ttemp_size = roundup_pow_of_two(temp_size);\n\n\t\t \n\t\tdo {\n\t\t\tpar->wc_cookie =\n\t\t\t\tarch_phys_wc_add(vesafb_fix.smem_start,\n\t\t\t\t\t\t temp_size);\n\t\t\ttemp_size >>= 1;\n\t\t} while (temp_size >= PAGE_SIZE && par->wc_cookie < 0);\n\n\t\tinfo->screen_base = ioremap_wc(vesafb_fix.smem_start, vesafb_fix.smem_len);\n\t} else {\n\t\tif (mtrr && mtrr != 3)\n\t\t\tWARN_ONCE(1, \"Only MTRR_TYPE_WRCOMB (3) make sense\\n\");\n\t\tinfo->screen_base = ioremap(vesafb_fix.smem_start, vesafb_fix.smem_len);\n\t}\n\n\tif (!info->screen_base) {\n\t\tprintk(KERN_ERR\n\t\t       \"vesafb: abort, cannot ioremap video memory 0x%x @ 0x%lx\\n\",\n\t\t\tvesafb_fix.smem_len, vesafb_fix.smem_start);\n\t\terr = -EIO;\n\t\tgoto err_release_region;\n\t}\n\n\tprintk(KERN_INFO \"vesafb: framebuffer at 0x%lx, mapped to 0x%p, \"\n\t       \"using %dk, total %dk\\n\",\n\t       vesafb_fix.smem_start, info->screen_base,\n\t       size_remap/1024, size_total/1024);\n\n\tif (!ypan)\n\t\tvesafb_ops.fb_pan_display = NULL;\n\n\tinfo->fbops = &vesafb_ops;\n\tinfo->var = vesafb_defined;\n\tinfo->fix = vesafb_fix;\n\tinfo->flags = (ypan ? FBINFO_HWACCEL_YPAN : 0);\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release_region;\n\t}\n\terr = devm_aperture_acquire_for_platform_device(dev, par->base, par->size);\n\tif (err)\n\t\tgoto err_fb_dealloc_cmap;\n\tif (register_framebuffer(info)<0) {\n\t\terr = -EINVAL;\n\t\tgoto err_fb_dealloc_cmap;\n\t}\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\treturn 0;\nerr_fb_dealloc_cmap:\n\tfb_dealloc_cmap(&info->cmap);\nerr_release_region:\n\tarch_phys_wc_del(par->wc_cookie);\n\tif (info->screen_base)\n\t\tiounmap(info->screen_base);\n\tif (par->region)\n\t\trelease_region(0x3c0, 32);\n\tframebuffer_release(info);\n\trelease_mem_region(vesafb_fix.smem_start, size_total);\n\treturn err;\n}\n\nstatic void vesafb_remove(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\n\tif (((struct vesafb_par *)(info->par))->region)\n\t\trelease_region(0x3c0, 32);\n\n\t \n\tunregister_framebuffer(info);\n}\n\nstatic struct platform_driver vesafb_driver = {\n\t.driver = {\n\t\t.name = \"vesa-framebuffer\",\n\t},\n\t.probe = vesafb_probe,\n\t.remove_new = vesafb_remove,\n};\n\nmodule_platform_driver(vesafb_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}