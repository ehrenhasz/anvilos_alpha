{
  "module_name": "savagefb_driver.c",
  "hash_id": "5692800f705b3fcb588c3e37576c285092c8289b19d5c49a24d7c197a481d5e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/savage/savagefb_driver.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/console.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n\n#include \"savagefb.h\"\n\n\n#define SAVAGEFB_VERSION \"0.4.0_2.6\"\n\n \n\n\nstatic char *mode_option = NULL;\n\n#ifdef MODULE\n\nMODULE_AUTHOR(\"(c) 2001-2002  Denis Oliver Kropp <dok@directfb.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"FBDev driver for S3 Savage PCI/AGP Chips\");\n\n#endif\n\n\n \n\nstatic void vgaHWSeqReset(struct savagefb_par *par, int start)\n{\n\tif (start)\n\t\tVGAwSEQ(0x00, 0x01, par);\t \n\telse\n\t\tVGAwSEQ(0x00, 0x03, par);\t \n}\n\nstatic void vgaHWProtect(struct savagefb_par *par, int on)\n{\n\tunsigned char tmp;\n\n\tif (on) {\n\t\t \n\t\ttmp = VGArSEQ(0x01, par);\n\n\t\tvgaHWSeqReset(par, 1);\t         \n\t\tVGAwSEQ(0x01, tmp | 0x20, par); \n\n\t\tVGAenablePalette(par);\n\t} else {\n\t\t \n\n\t\ttmp = VGArSEQ(0x01, par);\n\n\t\tVGAwSEQ(0x01, tmp & ~0x20, par); \n\t\tvgaHWSeqReset(par, 0);\t         \n\n\t\tVGAdisablePalette(par);\n\t}\n}\n\nstatic void vgaHWRestore(struct savagefb_par  *par, struct savage_reg *reg)\n{\n\tint i;\n\n\tVGAwMISC(reg->MiscOutReg, par);\n\n\tfor (i = 1; i < 5; i++)\n\t\tVGAwSEQ(i, reg->Sequencer[i], par);\n\n\t \n\tVGAwCR(17, reg->CRTC[17] & ~0x80, par);\n\n\tfor (i = 0; i < 25; i++)\n\t\tVGAwCR(i, reg->CRTC[i], par);\n\n\tfor (i = 0; i < 9; i++)\n\t\tVGAwGR(i, reg->Graphics[i], par);\n\n\tVGAenablePalette(par);\n\n\tfor (i = 0; i < 21; i++)\n\t\tVGAwATTR(i, reg->Attribute[i], par);\n\n\tVGAdisablePalette(par);\n}\n\nstatic void vgaHWInit(struct fb_var_screeninfo *var,\n\t\t      struct savagefb_par            *par,\n\t\t      struct xtimings                *timings,\n\t\t      struct savage_reg              *reg)\n{\n\treg->MiscOutReg = 0x23;\n\n\tif (!(timings->sync & FB_SYNC_HOR_HIGH_ACT))\n\t\treg->MiscOutReg |= 0x40;\n\n\tif (!(timings->sync & FB_SYNC_VERT_HIGH_ACT))\n\t\treg->MiscOutReg |= 0x80;\n\n\t \n\treg->Sequencer[0x00] = 0x00;\n\treg->Sequencer[0x01] = 0x01;\n\treg->Sequencer[0x02] = 0x0F;\n\treg->Sequencer[0x03] = 0x00;           \n\treg->Sequencer[0x04] = 0x0E;           \n\n\t \n\treg->CRTC[0x00] = (timings->HTotal >> 3) - 5;\n\treg->CRTC[0x01] = (timings->HDisplay >> 3) - 1;\n\treg->CRTC[0x02] = (timings->HSyncStart >> 3) - 1;\n\treg->CRTC[0x03] = (((timings->HSyncEnd >> 3)  - 1) & 0x1f) | 0x80;\n\treg->CRTC[0x04] = (timings->HSyncStart >> 3);\n\treg->CRTC[0x05] = ((((timings->HSyncEnd >> 3) - 1) & 0x20) << 2) |\n\t\t(((timings->HSyncEnd >> 3)) & 0x1f);\n\treg->CRTC[0x06] = (timings->VTotal - 2) & 0xFF;\n\treg->CRTC[0x07] = (((timings->VTotal - 2) & 0x100) >> 8) |\n\t\t(((timings->VDisplay - 1) & 0x100) >> 7) |\n\t\t((timings->VSyncStart & 0x100) >> 6) |\n\t\t(((timings->VSyncStart - 1) & 0x100) >> 5) |\n\t\t0x10 |\n\t\t(((timings->VTotal - 2) & 0x200) >> 4) |\n\t\t(((timings->VDisplay - 1) & 0x200) >> 3) |\n\t\t((timings->VSyncStart & 0x200) >> 2);\n\treg->CRTC[0x08] = 0x00;\n\treg->CRTC[0x09] = (((timings->VSyncStart - 1) & 0x200) >> 4) | 0x40;\n\n\tif (timings->dblscan)\n\t\treg->CRTC[0x09] |= 0x80;\n\n\treg->CRTC[0x0a] = 0x00;\n\treg->CRTC[0x0b] = 0x00;\n\treg->CRTC[0x0c] = 0x00;\n\treg->CRTC[0x0d] = 0x00;\n\treg->CRTC[0x0e] = 0x00;\n\treg->CRTC[0x0f] = 0x00;\n\treg->CRTC[0x10] = timings->VSyncStart & 0xff;\n\treg->CRTC[0x11] = (timings->VSyncEnd & 0x0f) | 0x20;\n\treg->CRTC[0x12] = (timings->VDisplay - 1) & 0xff;\n\treg->CRTC[0x13] = var->xres_virtual >> 4;\n\treg->CRTC[0x14] = 0x00;\n\treg->CRTC[0x15] = (timings->VSyncStart - 1) & 0xff;\n\treg->CRTC[0x16] = (timings->VSyncEnd - 1) & 0xff;\n\treg->CRTC[0x17] = 0xc3;\n\treg->CRTC[0x18] = 0xff;\n\n\t \n\n\t \n\treg->Graphics[0x00] = 0x00;\n\treg->Graphics[0x01] = 0x00;\n\treg->Graphics[0x02] = 0x00;\n\treg->Graphics[0x03] = 0x00;\n\treg->Graphics[0x04] = 0x00;\n\treg->Graphics[0x05] = 0x40;\n\treg->Graphics[0x06] = 0x05;    \n\treg->Graphics[0x07] = 0x0F;\n\treg->Graphics[0x08] = 0xFF;\n\n\n\treg->Attribute[0x00]  = 0x00;  \n\treg->Attribute[0x01]  = 0x01;\n\treg->Attribute[0x02]  = 0x02;\n\treg->Attribute[0x03]  = 0x03;\n\treg->Attribute[0x04]  = 0x04;\n\treg->Attribute[0x05]  = 0x05;\n\treg->Attribute[0x06]  = 0x06;\n\treg->Attribute[0x07]  = 0x07;\n\treg->Attribute[0x08]  = 0x08;\n\treg->Attribute[0x09]  = 0x09;\n\treg->Attribute[0x0a] = 0x0A;\n\treg->Attribute[0x0b] = 0x0B;\n\treg->Attribute[0x0c] = 0x0C;\n\treg->Attribute[0x0d] = 0x0D;\n\treg->Attribute[0x0e] = 0x0E;\n\treg->Attribute[0x0f] = 0x0F;\n\treg->Attribute[0x10] = 0x41;\n\treg->Attribute[0x11] = 0xFF;\n\treg->Attribute[0x12] = 0x0F;\n\treg->Attribute[0x13] = 0x00;\n\treg->Attribute[0x14] = 0x00;\n}\n\n \n\n \n\n \nstatic void\nsavage3D_waitfifo(struct savagefb_par *par, int space)\n{\n\tint slots = MAXFIFO - space;\n\n\twhile ((savage_in32(0x48C00, par) & 0x0000ffff) > slots);\n}\n\nstatic void\nsavage4_waitfifo(struct savagefb_par *par, int space)\n{\n\tint slots = MAXFIFO - space;\n\n\twhile ((savage_in32(0x48C60, par) & 0x001fffff) > slots);\n}\n\nstatic void\nsavage2000_waitfifo(struct savagefb_par *par, int space)\n{\n\tint slots = MAXFIFO - space;\n\n\twhile ((savage_in32(0x48C60, par) & 0x0000ffff) > slots);\n}\n\n \nstatic void\nsavage3D_waitidle(struct savagefb_par *par)\n{\n\twhile ((savage_in32(0x48C00, par) & 0x0008ffff) != 0x80000);\n}\n\nstatic void\nsavage4_waitidle(struct savagefb_par *par)\n{\n\twhile ((savage_in32(0x48C60, par) & 0x00a00000) != 0x00a00000);\n}\n\nstatic void\nsavage2000_waitidle(struct savagefb_par *par)\n{\n\twhile ((savage_in32(0x48C60, par) & 0x009fffff));\n}\n\n#ifdef CONFIG_FB_SAVAGE_ACCEL\nstatic void\nSavageSetup2DEngine(struct savagefb_par  *par)\n{\n\tunsigned long GlobalBitmapDescriptor;\n\n\tGlobalBitmapDescriptor = 1 | 8 | BCI_BD_BW_DISABLE;\n\tBCI_BD_SET_BPP(GlobalBitmapDescriptor, par->depth);\n\tBCI_BD_SET_STRIDE(GlobalBitmapDescriptor, par->vwidth);\n\n\tswitch(par->chip) {\n\tcase S3_SAVAGE3D:\n\tcase S3_SAVAGE_MX:\n\t\t \n\t\tsavage_out32(0x48C18, savage_in32(0x48C18, par) & 0x3FF0, par);\n\t\t \n\t\tsavage_out32(0x48C14,\n\t\t\t     (par->cob_offset >> 11) | (par->cob_index << 29),\n\t\t\t     par);\n\t\t \n\t\tsavage_out32(0x48C10, 0x78207220, par);\n\t\tsavage_out32(0x48C0C, 0, par);\n\t\t \n\t\tsavage_out32(0x48C18, savage_in32(0x48C18, par) | 0x0C, par);\n\t\tbreak;\n\tcase S3_SAVAGE4:\n\tcase S3_TWISTER:\n\tcase S3_PROSAVAGE:\n\tcase S3_PROSAVAGEDDR:\n\tcase S3_SUPERSAVAGE:\n\t\t \n\t\tsavage_out32(0x48C18, savage_in32(0x48C18, par) & 0x3FF0, par);\n\t\t \n\t\tsavage_out32(0x48C10, 0x00700040, par);\n\t\tsavage_out32(0x48C0C, 0, par);\n\t\t \n\t\tsavage_out32(0x48C18, savage_in32(0x48C18, par) | 0x08, par);\n\t\tbreak;\n\tcase S3_SAVAGE2000:\n\t\t \n\t\tsavage_out32(0x48C18, 0, par);\n\t\t \n\t\tsavage_out32(0x48C18,\n\t\t\t     (par->cob_offset >> 7) | (par->cob_index),\n\t\t\t     par);\n\t\t \n\t\tsavage_out32(0x48A30, 0, par);\n\t\t \n\t\tsavage_out32(0x48C18, savage_in32(0x48C18, par) | 0x00280000,\n\t\t\t     par);\n\t\tbreak;\n\t    default:\n\t\tbreak;\n\t}\n\t \n\tvga_out8(0x3d4, 0x31, par);\n\tvga_out8(0x3d5, 0x0c, par);\n\n\t \n\tvga_out8(0x3d4, 0x50, par);\n\tvga_out8(0x3d5, vga_in8(0x3d5, par) | 0xC1, par);\n\n\t \n\tvga_out8(0x3d4, 0x40, par);\n\tvga_out8(0x3d5, 0x01, par);\n\n\tsavage_out32(MONO_PAT_0, ~0, par);\n\tsavage_out32(MONO_PAT_1, ~0, par);\n\n\t \n\tsavage_out32(0x8128, ~0, par);  \n\tsavage_out32(0x812C, ~0, par);  \n\tsavage_out16(0x8134, 0x27, par);\n\tsavage_out16(0x8136, 0x07, par);\n\n\t \n\tpar->bci_ptr = 0;\n\tpar->SavageWaitFifo(par, 4);\n\n\tBCI_SEND(BCI_CMD_SETREG | (1 << 16) | BCI_GBD1);\n\tBCI_SEND(0);\n\tBCI_SEND(BCI_CMD_SETREG | (1 << 16) | BCI_GBD2);\n\tBCI_SEND(GlobalBitmapDescriptor);\n\n\t \n\tpar->bci_ptr = 0;\n\tpar->SavageWaitFifo(par, 4);\n\n\tBCI_SEND(BCI_CMD_SETREG | (1 << 16) | BCI_GBD1);\n\tBCI_SEND(0);\n\tBCI_SEND(BCI_CMD_SETREG | (1 << 16) | BCI_GBD2);\n\tBCI_SEND(GlobalBitmapDescriptor);\n}\n\nstatic void savagefb_set_clip(struct fb_info *info)\n{\n\tstruct savagefb_par *par = info->par;\n\tint cmd;\n\n\tcmd = BCI_CMD_NOP | BCI_CMD_CLIP_NEW;\n\tpar->bci_ptr = 0;\n\tpar->SavageWaitFifo(par,3);\n\tBCI_SEND(cmd);\n\tBCI_SEND(BCI_CLIP_TL(0, 0));\n\tBCI_SEND(BCI_CLIP_BR(0xfff, 0xfff));\n}\n#else\nstatic void SavageSetup2DEngine(struct savagefb_par  *par) {}\n\n#endif\n\nstatic void SavageCalcClock(long freq, int min_m, int min_n1, int max_n1,\n\t\t\t    int min_n2, int max_n2, long freq_min,\n\t\t\t    long freq_max, unsigned int *mdiv,\n\t\t\t    unsigned int *ndiv, unsigned int *r)\n{\n\tlong diff, best_diff;\n\tunsigned int m;\n\tunsigned char n1, n2, best_n1=16+2, best_n2=2, best_m=125+2;\n\n\tif (freq < freq_min / (1 << max_n2)) {\n\t\tprintk(KERN_ERR \"invalid frequency %ld Khz\\n\", freq);\n\t\tfreq = freq_min / (1 << max_n2);\n\t}\n\tif (freq > freq_max / (1 << min_n2)) {\n\t\tprintk(KERN_ERR \"invalid frequency %ld Khz\\n\", freq);\n\t\tfreq = freq_max / (1 << min_n2);\n\t}\n\n\t \n\tbest_diff = freq;\n\n\tfor (n2=min_n2; n2<=max_n2; n2++) {\n\t\tfor (n1=min_n1+2; n1<=max_n1+2; n1++) {\n\t\t\tm = (freq * n1 * (1 << n2) + HALF_BASE_FREQ) /\n\t\t\t\tBASE_FREQ;\n\t\t\tif (m < min_m+2 || m > 127+2)\n\t\t\t\tcontinue;\n\t\t\tif ((m * BASE_FREQ >= freq_min * n1) &&\n\t\t\t    (m * BASE_FREQ <= freq_max * n1)) {\n\t\t\t\tdiff = freq * (1 << n2) * n1 - BASE_FREQ * m;\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tdiff = -diff;\n\t\t\t\tif (diff < best_diff) {\n\t\t\t\t\tbest_diff = diff;\n\t\t\t\t\tbest_m = m;\n\t\t\t\t\tbest_n1 = n1;\n\t\t\t\t\tbest_n2 = n2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*ndiv = best_n1 - 2;\n\t*r = best_n2;\n\t*mdiv = best_m - 2;\n}\n\nstatic int common_calc_clock(long freq, int min_m, int min_n1, int max_n1,\n\t\t\t     int min_n2, int max_n2, long freq_min,\n\t\t\t     long freq_max, unsigned char *mdiv,\n\t\t\t     unsigned char *ndiv)\n{\n\tlong diff, best_diff;\n\tunsigned int m;\n\tunsigned char n1, n2;\n\tunsigned char best_n1 = 16+2, best_n2 = 2, best_m = 125+2;\n\n\tbest_diff = freq;\n\n\tfor (n2 = min_n2; n2 <= max_n2; n2++) {\n\t\tfor (n1 = min_n1+2; n1 <= max_n1+2; n1++) {\n\t\t\tm = (freq * n1 * (1 << n2) + HALF_BASE_FREQ) /\n\t\t\t\tBASE_FREQ;\n\t\t\tif (m < min_m + 2 || m > 127+2)\n\t\t\t\tcontinue;\n\t\t\tif ((m * BASE_FREQ >= freq_min * n1) &&\n\t\t\t    (m * BASE_FREQ <= freq_max * n1)) {\n\t\t\t\tdiff = freq * (1 << n2) * n1 - BASE_FREQ * m;\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tdiff = -diff;\n\t\t\t\tif (diff < best_diff) {\n\t\t\t\t\tbest_diff = diff;\n\t\t\t\t\tbest_m = m;\n\t\t\t\t\tbest_n1 = n1;\n\t\t\t\t\tbest_n2 = n2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (max_n1 == 63)\n\t\t*ndiv = (best_n1 - 2) | (best_n2 << 6);\n\telse\n\t\t*ndiv = (best_n1 - 2) | (best_n2 << 5);\n\n\t*mdiv = best_m - 2;\n\n\treturn 0;\n}\n\n#ifdef SAVAGEFB_DEBUG\n \n\nstatic void SavagePrintRegs(struct savagefb_par *par)\n{\n\tunsigned char i;\n\tint vgaCRIndex = 0x3d4;\n\tint vgaCRReg = 0x3d5;\n\n\tprintk(KERN_DEBUG \"SR    x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE \"\n\t       \"xF\");\n\n\tfor (i = 0; i < 0x70; i++) {\n\t\tif (!(i % 16))\n\t\t\tprintk(KERN_DEBUG \"\\nSR%xx \", i >> 4);\n\t\tvga_out8(0x3c4, i, par);\n\t\tprintk(KERN_DEBUG \" %02x\", vga_in8(0x3c5, par));\n\t}\n\n\tprintk(KERN_DEBUG \"\\n\\nCR    x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC \"\n\t       \"xD xE xF\");\n\n\tfor (i = 0; i < 0xB7; i++) {\n\t\tif (!(i % 16))\n\t\t\tprintk(KERN_DEBUG \"\\nCR%xx \", i >> 4);\n\t\tvga_out8(vgaCRIndex, i, par);\n\t\tprintk(KERN_DEBUG \" %02x\", vga_in8(vgaCRReg, par));\n\t}\n\n\tprintk(KERN_DEBUG \"\\n\\n\");\n}\n#endif\n\n \n\nstatic void savage_get_default_par(struct savagefb_par *par, struct savage_reg *reg)\n{\n\tunsigned char cr3a, cr53, cr66;\n\n\tvga_out16(0x3d4, 0x4838, par);\n\tvga_out16(0x3d4, 0xa039, par);\n\tvga_out16(0x3c4, 0x0608, par);\n\n\tvga_out8(0x3d4, 0x66, par);\n\tcr66 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr66 | 0x80, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\tcr3a = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr3a | 0x80, par);\n\tvga_out8(0x3d4, 0x53, par);\n\tcr53 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr53 & 0x7f, par);\n\n\tvga_out8(0x3d4, 0x66, par);\n\tvga_out8(0x3d5, cr66, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\tvga_out8(0x3d5, cr3a, par);\n\n\tvga_out8(0x3d4, 0x66, par);\n\tvga_out8(0x3d5, cr66, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\tvga_out8(0x3d5, cr3a, par);\n\n\t \n\tvga_out8(0x3c4, 0x08, par);\n\treg->SR08 = vga_in8(0x3c5, par);\n\tvga_out8(0x3c5, 0x06, par);\n\n\t \n\tvga_out8(0x3d4, 0x31, par);\n\treg->CR31 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x32, par);\n\treg->CR32 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x34, par);\n\treg->CR34 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x36, par);\n\treg->CR36 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\treg->CR3A = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x40, par);\n\treg->CR40 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x42, par);\n\treg->CR42 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x45, par);\n\treg->CR45 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x50, par);\n\treg->CR50 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x51, par);\n\treg->CR51 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x53, par);\n\treg->CR53 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x58, par);\n\treg->CR58 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x60, par);\n\treg->CR60 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x66, par);\n\treg->CR66 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x67, par);\n\treg->CR67 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x68, par);\n\treg->CR68 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x69, par);\n\treg->CR69 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x6f, par);\n\treg->CR6F = vga_in8(0x3d5, par);\n\n\tvga_out8(0x3d4, 0x33, par);\n\treg->CR33 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x86, par);\n\treg->CR86 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x88, par);\n\treg->CR88 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x90, par);\n\treg->CR90 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x91, par);\n\treg->CR91 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0xb0, par);\n\treg->CRB0 = vga_in8(0x3d5, par) | 0x80;\n\n\t \n\tvga_out8(0x3d4, 0x3b, par);\n\treg->CR3B = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x3c, par);\n\treg->CR3C = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x43, par);\n\treg->CR43 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x5d, par);\n\treg->CR5D = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x5e, par);\n\treg->CR5E = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x65, par);\n\treg->CR65 = vga_in8(0x3d5, par);\n\n\t \n\tvga_out8(0x3c4, 0x0e, par);\n\treg->SR0E = vga_in8(0x3c5, par);\n\tvga_out8(0x3c4, 0x0f, par);\n\treg->SR0F = vga_in8(0x3c5, par);\n\tvga_out8(0x3c4, 0x10, par);\n\treg->SR10 = vga_in8(0x3c5, par);\n\tvga_out8(0x3c4, 0x11, par);\n\treg->SR11 = vga_in8(0x3c5, par);\n\tvga_out8(0x3c4, 0x12, par);\n\treg->SR12 = vga_in8(0x3c5, par);\n\tvga_out8(0x3c4, 0x13, par);\n\treg->SR13 = vga_in8(0x3c5, par);\n\tvga_out8(0x3c4, 0x29, par);\n\treg->SR29 = vga_in8(0x3c5, par);\n\n\tvga_out8(0x3c4, 0x15, par);\n\treg->SR15 = vga_in8(0x3c5, par);\n\tvga_out8(0x3c4, 0x30, par);\n\treg->SR30 = vga_in8(0x3c5, par);\n\tvga_out8(0x3c4, 0x18, par);\n\treg->SR18 = vga_in8(0x3c5, par);\n\n\t \n\tif (par->chip == S3_SAVAGE_MX) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tvga_out8(0x3c4, 0x54+i, par);\n\t\t\treg->SR54[i] = vga_in8(0x3c5, par);\n\t\t}\n\t}\n\n\tvga_out8(0x3d4, 0x66, par);\n\tcr66 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr66 | 0x80, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\tcr3a = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr3a | 0x80, par);\n\n\t \n\tif (par->chip != S3_SAVAGE_MX) {\n\t\treg->MMPR0 = savage_in32(FIFO_CONTROL_REG, par);\n\t\treg->MMPR1 = savage_in32(MIU_CONTROL_REG, par);\n\t\treg->MMPR2 = savage_in32(STREAMS_TIMEOUT_REG, par);\n\t\treg->MMPR3 = savage_in32(MISC_TIMEOUT_REG, par);\n\t}\n\n\tvga_out8(0x3d4, 0x3a, par);\n\tvga_out8(0x3d5, cr3a, par);\n\tvga_out8(0x3d4, 0x66, par);\n\tvga_out8(0x3d5, cr66, par);\n}\n\nstatic void savage_set_default_par(struct savagefb_par *par,\n\t\t\t\tstruct savage_reg *reg)\n{\n\tunsigned char cr3a, cr53, cr66;\n\n\tvga_out16(0x3d4, 0x4838, par);\n\tvga_out16(0x3d4, 0xa039, par);\n\tvga_out16(0x3c4, 0x0608, par);\n\n\tvga_out8(0x3d4, 0x66, par);\n\tcr66 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr66 | 0x80, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\tcr3a = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr3a | 0x80, par);\n\tvga_out8(0x3d4, 0x53, par);\n\tcr53 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr53 & 0x7f, par);\n\n\tvga_out8(0x3d4, 0x66, par);\n\tvga_out8(0x3d5, cr66, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\tvga_out8(0x3d5, cr3a, par);\n\n\tvga_out8(0x3d4, 0x66, par);\n\tvga_out8(0x3d5, cr66, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\tvga_out8(0x3d5, cr3a, par);\n\n\t \n\tvga_out8(0x3c4, 0x08, par);\n\tvga_out8(0x3c5, reg->SR08, par);\n\tvga_out8(0x3c5, 0x06, par);\n\n\t \n\tvga_out8(0x3d4, 0x31, par);\n\tvga_out8(0x3d5, reg->CR31, par);\n\tvga_out8(0x3d4, 0x32, par);\n\tvga_out8(0x3d5, reg->CR32, par);\n\tvga_out8(0x3d4, 0x34, par);\n\tvga_out8(0x3d5, reg->CR34, par);\n\tvga_out8(0x3d4, 0x36, par);\n\tvga_out8(0x3d5,reg->CR36, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\tvga_out8(0x3d5, reg->CR3A, par);\n\tvga_out8(0x3d4, 0x40, par);\n\tvga_out8(0x3d5, reg->CR40, par);\n\tvga_out8(0x3d4, 0x42, par);\n\tvga_out8(0x3d5, reg->CR42, par);\n\tvga_out8(0x3d4, 0x45, par);\n\tvga_out8(0x3d5, reg->CR45, par);\n\tvga_out8(0x3d4, 0x50, par);\n\tvga_out8(0x3d5, reg->CR50, par);\n\tvga_out8(0x3d4, 0x51, par);\n\tvga_out8(0x3d5, reg->CR51, par);\n\tvga_out8(0x3d4, 0x53, par);\n\tvga_out8(0x3d5, reg->CR53, par);\n\tvga_out8(0x3d4, 0x58, par);\n\tvga_out8(0x3d5, reg->CR58, par);\n\tvga_out8(0x3d4, 0x60, par);\n\tvga_out8(0x3d5, reg->CR60, par);\n\tvga_out8(0x3d4, 0x66, par);\n\tvga_out8(0x3d5, reg->CR66, par);\n\tvga_out8(0x3d4, 0x67, par);\n\tvga_out8(0x3d5, reg->CR67, par);\n\tvga_out8(0x3d4, 0x68, par);\n\tvga_out8(0x3d5, reg->CR68, par);\n\tvga_out8(0x3d4, 0x69, par);\n\tvga_out8(0x3d5, reg->CR69, par);\n\tvga_out8(0x3d4, 0x6f, par);\n\tvga_out8(0x3d5, reg->CR6F, par);\n\n\tvga_out8(0x3d4, 0x33, par);\n\tvga_out8(0x3d5, reg->CR33, par);\n\tvga_out8(0x3d4, 0x86, par);\n\tvga_out8(0x3d5, reg->CR86, par);\n\tvga_out8(0x3d4, 0x88, par);\n\tvga_out8(0x3d5, reg->CR88, par);\n\tvga_out8(0x3d4, 0x90, par);\n\tvga_out8(0x3d5, reg->CR90, par);\n\tvga_out8(0x3d4, 0x91, par);\n\tvga_out8(0x3d5, reg->CR91, par);\n\tvga_out8(0x3d4, 0xb0, par);\n\tvga_out8(0x3d5, reg->CRB0, par);\n\n\t \n\tvga_out8(0x3d4, 0x3b, par);\n\tvga_out8(0x3d5, reg->CR3B, par);\n\tvga_out8(0x3d4, 0x3c, par);\n\tvga_out8(0x3d5, reg->CR3C, par);\n\tvga_out8(0x3d4, 0x43, par);\n\tvga_out8(0x3d5, reg->CR43, par);\n\tvga_out8(0x3d4, 0x5d, par);\n\tvga_out8(0x3d5, reg->CR5D, par);\n\tvga_out8(0x3d4, 0x5e, par);\n\tvga_out8(0x3d5, reg->CR5E, par);\n\tvga_out8(0x3d4, 0x65, par);\n\tvga_out8(0x3d5, reg->CR65, par);\n\n\t \n\tvga_out8(0x3c4, 0x0e, par);\n\tvga_out8(0x3c5, reg->SR0E, par);\n\tvga_out8(0x3c4, 0x0f, par);\n\tvga_out8(0x3c5, reg->SR0F, par);\n\tvga_out8(0x3c4, 0x10, par);\n\tvga_out8(0x3c5, reg->SR10, par);\n\tvga_out8(0x3c4, 0x11, par);\n\tvga_out8(0x3c5, reg->SR11, par);\n\tvga_out8(0x3c4, 0x12, par);\n\tvga_out8(0x3c5, reg->SR12, par);\n\tvga_out8(0x3c4, 0x13, par);\n\tvga_out8(0x3c5, reg->SR13, par);\n\tvga_out8(0x3c4, 0x29, par);\n\tvga_out8(0x3c5, reg->SR29, par);\n\n\tvga_out8(0x3c4, 0x15, par);\n\tvga_out8(0x3c5, reg->SR15, par);\n\tvga_out8(0x3c4, 0x30, par);\n\tvga_out8(0x3c5, reg->SR30, par);\n\tvga_out8(0x3c4, 0x18, par);\n\tvga_out8(0x3c5, reg->SR18, par);\n\n\t \n\tif (par->chip == S3_SAVAGE_MX) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tvga_out8(0x3c4, 0x54+i, par);\n\t\t\tvga_out8(0x3c5, reg->SR54[i], par);\n\t\t}\n\t}\n\n\tvga_out8(0x3d4, 0x66, par);\n\tcr66 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr66 | 0x80, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\tcr3a = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr3a | 0x80, par);\n\n\t \n\tif (par->chip != S3_SAVAGE_MX) {\n\t\tsavage_out32(FIFO_CONTROL_REG, reg->MMPR0, par);\n\t\tsavage_out32(MIU_CONTROL_REG, reg->MMPR1, par);\n\t\tsavage_out32(STREAMS_TIMEOUT_REG, reg->MMPR2, par);\n\t\tsavage_out32(MISC_TIMEOUT_REG, reg->MMPR3, par);\n\t}\n\n\tvga_out8(0x3d4, 0x3a, par);\n\tvga_out8(0x3d5, cr3a, par);\n\tvga_out8(0x3d4, 0x66, par);\n\tvga_out8(0x3d5, cr66, par);\n}\n\nstatic void savage_update_var(struct fb_var_screeninfo *var,\n\t\t\t      const struct fb_videomode *modedb)\n{\n\tvar->xres = var->xres_virtual = modedb->xres;\n\tvar->yres = modedb->yres;\n        if (var->yres_virtual < var->yres)\n\t    var->yres_virtual = var->yres;\n        var->xoffset = var->yoffset = 0;\n        var->pixclock = modedb->pixclock;\n        var->left_margin = modedb->left_margin;\n        var->right_margin = modedb->right_margin;\n        var->upper_margin = modedb->upper_margin;\n        var->lower_margin = modedb->lower_margin;\n        var->hsync_len = modedb->hsync_len;\n        var->vsync_len = modedb->vsync_len;\n        var->sync = modedb->sync;\n        var->vmode = modedb->vmode;\n}\n\nstatic int savagefb_check_var(struct fb_var_screeninfo   *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct savagefb_par *par = info->par;\n\tint memlen, vramlen, mode_valid = 0;\n\n\tDBG(\"savagefb_check_var\");\n\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset = var->green.offset =\n\t\t\tvar->blue.offset = 0;\n\t\tvar->red.length = var->green.length =\n\t\t\tvar->blue.length = var->bits_per_pixel;\n\t\tbreak;\n\tcase 16:\n\t\tvar->red.offset = 11;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->monspecs.hfmax || !info->monspecs.vfmax ||\n\t    !info->monspecs.dclkmax || !fb_validate_mode(var, info))\n\t\tmode_valid = 1;\n\n\t \n\tif (!mode_valid && info->monspecs.gtf) {\n\t\tif (!fb_get_mode(FB_MAXTIMINGS, 0, var, info))\n\t\t\tmode_valid = 1;\n\t}\n\n\tif (!mode_valid) {\n\t\tconst struct fb_videomode *mode;\n\n\t\tmode = fb_find_best_mode(var, &info->modelist);\n\t\tif (mode) {\n\t\t\tsavage_update_var(var, mode);\n\t\t\tmode_valid = 1;\n\t\t}\n\t}\n\n\tif (!mode_valid && info->monspecs.modedb_len)\n\t\treturn -EINVAL;\n\n\t \n\tif (par->SavagePanelWidth &&\n\t    (var->xres > par->SavagePanelWidth ||\n\t     var->yres > par->SavagePanelHeight)) {\n\t\tprintk(KERN_INFO \"Mode (%dx%d) larger than the LCD panel \"\n\t\t       \"(%dx%d)\\n\", var->xres,  var->yres,\n\t\t       par->SavagePanelWidth,\n\t\t       par->SavagePanelHeight);\n\t\treturn -1;\n\t}\n\n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres_virtual = var->yres;\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\n\tvramlen = info->fix.smem_len;\n\n\tmemlen = var->xres_virtual * var->bits_per_pixel *\n\t\tvar->yres_virtual / 8;\n\tif (memlen > vramlen) {\n\t\tvar->yres_virtual = vramlen * 8 /\n\t\t\t(var->xres_virtual * var->bits_per_pixel);\n\t\tmemlen = var->xres_virtual * var->bits_per_pixel *\n\t\t\tvar->yres_virtual / 8;\n\t}\n\n\t \n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres = var->yres_virtual;\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres = var->xres_virtual;\n\tif (var->xoffset + var->xres > var->xres_virtual)\n\t\tvar->xoffset = var->xres_virtual - var->xres;\n\tif (var->yoffset + var->yres > var->yres_virtual)\n\t\tvar->yoffset = var->yres_virtual - var->yres;\n\n\treturn 0;\n}\n\n\nstatic int savagefb_decode_var(struct fb_var_screeninfo   *var,\n\t\t\t       struct savagefb_par        *par,\n\t\t\t       struct savage_reg          *reg)\n{\n\tstruct xtimings timings;\n\tint width, dclk, i, j;  \n\tunsigned int m, n, r;\n\tunsigned char tmp = 0;\n\tunsigned int pixclock = var->pixclock;\n\n\tDBG(\"savagefb_decode_var\");\n\n\tmemset(&timings, 0, sizeof(timings));\n\n\tif (!pixclock) pixclock = 10000;\t \n\ttimings.Clock = 1000000000 / pixclock;\n\tif (timings.Clock < 1) timings.Clock = 1;\n\ttimings.dblscan = var->vmode & FB_VMODE_DOUBLE;\n\ttimings.interlaced = var->vmode & FB_VMODE_INTERLACED;\n\ttimings.HDisplay = var->xres;\n\ttimings.HSyncStart = timings.HDisplay + var->right_margin;\n\ttimings.HSyncEnd = timings.HSyncStart + var->hsync_len;\n\ttimings.HTotal = timings.HSyncEnd + var->left_margin;\n\ttimings.VDisplay = var->yres;\n\ttimings.VSyncStart = timings.VDisplay + var->lower_margin;\n\ttimings.VSyncEnd = timings.VSyncStart + var->vsync_len;\n\ttimings.VTotal = timings.VSyncEnd + var->upper_margin;\n\ttimings.sync = var->sync;\n\n\n\tpar->depth  = var->bits_per_pixel;\n\tpar->vwidth = var->xres_virtual;\n\n\tif (var->bits_per_pixel == 16  &&  par->chip == S3_SAVAGE3D) {\n\t\ttimings.HDisplay *= 2;\n\t\ttimings.HSyncStart *= 2;\n\t\ttimings.HSyncEnd *= 2;\n\t\ttimings.HTotal *= 2;\n\t}\n\n\t \n\tvgaHWInit(var, par, &timings, reg);\n\n\t \n\n\tdclk = timings.Clock;\n\treg->CR67 = 0x00;\n\n\tswitch(var->bits_per_pixel) {\n\tcase 8:\n\t\tif ((par->chip == S3_SAVAGE2000) && (dclk >= 230000))\n\t\t\treg->CR67 = 0x10;\t \n\t\telse\n\t\t\treg->CR67 = 0x00;\t \n\t\tbreak;\n\tcase 15:\n\t\tif (S3_SAVAGE_MOBILE_SERIES(par->chip) ||\n\t\t    ((par->chip == S3_SAVAGE2000) && (dclk >= 230000)))\n\t\t\treg->CR67 = 0x30;\t \n\t\telse\n\t\t\treg->CR67 = 0x20;\t \n\t\tbreak;\n\tcase 16:\n\t\tif (S3_SAVAGE_MOBILE_SERIES(par->chip) ||\n\t\t   ((par->chip == S3_SAVAGE2000) && (dclk >= 230000)))\n\t\t\treg->CR67 = 0x50;\t \n\t\telse\n\t\t\treg->CR67 = 0x40;\t \n\t\tbreak;\n\tcase 24:\n\t\treg->CR67 = 0x70;\n\t\tbreak;\n\tcase 32:\n\t\treg->CR67 = 0xd0;\n\t\tbreak;\n\t}\n\n\t \n\n\tvga_out8(0x3d4, 0x3a, par);\n\ttmp = vga_in8(0x3d5, par);\n\tif (1  )\n\t\treg->CR3A = (tmp & 0x7f) | 0x15;\n\telse\n\t\treg->CR3A = tmp | 0x95;\n\n\treg->CR53 = 0x00;\n\treg->CR31 = 0x8c;\n\treg->CR66 = 0x89;\n\n\tvga_out8(0x3d4, 0x58, par);\n\treg->CR58 = vga_in8(0x3d5, par) & 0x80;\n\treg->CR58 |= 0x13;\n\n\treg->SR15 = 0x03 | 0x80;\n\treg->SR18 = 0x00;\n\treg->CR43 = reg->CR45 = reg->CR65 = 0x00;\n\n\tvga_out8(0x3d4, 0x40, par);\n\treg->CR40 = vga_in8(0x3d5, par) & ~0x01;\n\n\treg->MMPR0 = 0x010400;\n\treg->MMPR1 = 0x00;\n\treg->MMPR2 = 0x0808;\n\treg->MMPR3 = 0x08080810;\n\n\tSavageCalcClock(dclk, 1, 1, 127, 0, 4, 180000, 360000, &m, &n, &r);\n\t \n\n\tif (par->MCLK <= 0) {\n\t\treg->SR10 = 255;\n\t\treg->SR11 = 255;\n\t} else {\n\t\tcommon_calc_clock(par->MCLK, 1, 1, 31, 0, 3, 135000, 270000,\n\t\t\t\t   &reg->SR11, &reg->SR10);\n\t\t \n\t\t \n\t}\n\n\treg->SR12 = (r << 6) | (n & 0x3f);\n\treg->SR13 = m & 0xff;\n\treg->SR29 = (r & 4) | (m & 0x100) >> 5 | (n & 0x40) >> 2;\n\n\tif (var->bits_per_pixel < 24)\n\t\treg->MMPR0 -= 0x8000;\n\telse\n\t\treg->MMPR0 -= 0x4000;\n\n\tif (timings.interlaced)\n\t\treg->CR42 = 0x20;\n\telse\n\t\treg->CR42 = 0x00;\n\n\treg->CR34 = 0x10;  \n\n\ti = ((((timings.HTotal >> 3) - 5) & 0x100) >> 8) |\n\t\t((((timings.HDisplay >> 3) - 1) & 0x100) >> 7) |\n\t\t((((timings.HSyncStart >> 3) - 1) & 0x100) >> 6) |\n\t\t((timings.HSyncStart & 0x800) >> 7);\n\n\tif ((timings.HSyncEnd >> 3) - (timings.HSyncStart >> 3) > 64)\n\t\ti |= 0x08;\n\tif ((timings.HSyncEnd >> 3) - (timings.HSyncStart >> 3) > 32)\n\t\ti |= 0x20;\n\n\tj = (reg->CRTC[0] + ((i & 0x01) << 8) +\n\t     reg->CRTC[4] + ((i & 0x10) << 4) + 1) / 2;\n\n\tif (j - (reg->CRTC[4] + ((i & 0x10) << 4)) < 4) {\n\t\tif (reg->CRTC[4] + ((i & 0x10) << 4) + 4 <=\n\t\t    reg->CRTC[0] + ((i & 0x01) << 8))\n\t\t\tj = reg->CRTC[4] + ((i & 0x10) << 4) + 4;\n\t\telse\n\t\t\tj = reg->CRTC[0] + ((i & 0x01) << 8) + 1;\n\t}\n\n\treg->CR3B = j & 0xff;\n\ti |= (j & 0x100) >> 2;\n\treg->CR3C = (reg->CRTC[0] + ((i & 0x01) << 8)) / 2;\n\treg->CR5D = i;\n\treg->CR5E = (((timings.VTotal - 2) & 0x400) >> 10) |\n\t\t(((timings.VDisplay - 1) & 0x400) >> 9) |\n\t\t(((timings.VSyncStart) & 0x400) >> 8) |\n\t\t(((timings.VSyncStart) & 0x400) >> 6) | 0x40;\n\twidth = (var->xres_virtual * ((var->bits_per_pixel+7) / 8)) >> 3;\n\treg->CR91 = reg->CRTC[19] = 0xff & width;\n\treg->CR51 = (0x300 & width) >> 4;\n\treg->CR90 = 0x80 | (width >> 8);\n\treg->MiscOutReg |= 0x0c;\n\n\t \n\n\tif (var->bits_per_pixel <= 8)\n\t\treg->CR50 = 0;\n\telse if (var->bits_per_pixel <= 16)\n\t\treg->CR50 = 0x10;\n\telse\n\t\treg->CR50 = 0x30;\n\n\tif (var->xres_virtual <= 640)\n\t\treg->CR50 |= 0x40;\n\telse if (var->xres_virtual == 800)\n\t\treg->CR50 |= 0x80;\n\telse if (var->xres_virtual == 1024)\n\t\treg->CR50 |= 0x00;\n\telse if (var->xres_virtual == 1152)\n\t\treg->CR50 |= 0x01;\n\telse if (var->xres_virtual == 1280)\n\t\treg->CR50 |= 0xc0;\n\telse if (var->xres_virtual == 1600)\n\t\treg->CR50 |= 0x81;\n\telse\n\t\treg->CR50 |= 0xc1;\t \n\n\tif (par->chip == S3_SAVAGE2000)\n\t\treg->CR33 = 0x08;\n\telse\n\t\treg->CR33 = 0x20;\n\n\treg->CRTC[0x17] = 0xeb;\n\n\treg->CR67 |= 1;\n\n\tvga_out8(0x3d4, 0x36, par);\n\treg->CR36 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x68, par);\n\treg->CR68 = vga_in8(0x3d5, par);\n\treg->CR69 = 0;\n\tvga_out8(0x3d4, 0x6f, par);\n\treg->CR6F = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x86, par);\n\treg->CR86 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d4, 0x88, par);\n\treg->CR88 = vga_in8(0x3d5, par) | 0x08;\n\tvga_out8(0x3d4, 0xb0, par);\n\treg->CRB0 = vga_in8(0x3d5, par) | 0x80;\n\n\treturn 0;\n}\n\n \n\n \nstatic int savagefb_setcolreg(unsigned        regno,\n\t\t\t      unsigned        red,\n\t\t\t      unsigned        green,\n\t\t\t      unsigned        blue,\n\t\t\t      unsigned        transp,\n\t\t\t      struct fb_info *info)\n{\n\tstruct savagefb_par *par = info->par;\n\n\tif (regno >= NR_PALETTE)\n\t\treturn -EINVAL;\n\n\tpar->palette[regno].red    = red;\n\tpar->palette[regno].green  = green;\n\tpar->palette[regno].blue   = blue;\n\tpar->palette[regno].transp = transp;\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tvga_out8(0x3c8, regno, par);\n\n\t\tvga_out8(0x3c9, red   >> 10, par);\n\t\tvga_out8(0x3c9, green >> 10, par);\n\t\tvga_out8(0x3c9, blue  >> 10, par);\n\t\tbreak;\n\n\tcase 16:\n\t\tif (regno < 16)\n\t\t\t((u32 *)info->pseudo_palette)[regno] =\n\t\t\t\t((red   & 0xf800)      ) |\n\t\t\t\t((green & 0xfc00) >>  5) |\n\t\t\t\t((blue  & 0xf800) >> 11);\n\t\tbreak;\n\n\tcase 24:\n\t\tif (regno < 16)\n\t\t\t((u32 *)info->pseudo_palette)[regno] =\n\t\t\t\t((red    & 0xff00) <<  8) |\n\t\t\t\t((green  & 0xff00)      ) |\n\t\t\t\t((blue   & 0xff00) >>  8);\n\t\tbreak;\n\tcase 32:\n\t\tif (regno < 16)\n\t\t\t((u32 *)info->pseudo_palette)[regno] =\n\t\t\t\t((transp & 0xff00) << 16) |\n\t\t\t\t((red    & 0xff00) <<  8) |\n\t\t\t\t((green  & 0xff00)      ) |\n\t\t\t\t((blue   & 0xff00) >>  8);\n\t\tbreak;\n\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void savagefb_set_par_int(struct savagefb_par  *par, struct savage_reg *reg)\n{\n\tunsigned char tmp, cr3a, cr66, cr67;\n\n\tDBG(\"savagefb_set_par_int\");\n\n\tpar->SavageWaitIdle(par);\n\n\tvga_out8(0x3c2, 0x23, par);\n\n\tvga_out16(0x3d4, 0x4838, par);\n\tvga_out16(0x3d4, 0xa539, par);\n\tvga_out16(0x3c4, 0x0608, par);\n\n\tvgaHWProtect(par, 1);\n\n\t \n\n\tVerticalRetraceWait(par);\n\tvga_out8(0x3d4, 0x67, par);\n\tcr67 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr67  & ~0x0c, par);  \n\n\tvga_out8(0x3d4, 0x23, par);\n\tvga_out8(0x3d5, 0x00, par);\n\tvga_out8(0x3d4, 0x26, par);\n\tvga_out8(0x3d5, 0x00, par);\n\n\t \n\tvga_out8(0x3d4, 0x66, par);\n\tvga_out8(0x3d5, reg->CR66, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\tvga_out8(0x3d5, reg->CR3A, par);\n\tvga_out8(0x3d4, 0x31, par);\n\tvga_out8(0x3d5, reg->CR31, par);\n\tvga_out8(0x3d4, 0x32, par);\n\tvga_out8(0x3d5, reg->CR32, par);\n\tvga_out8(0x3d4, 0x58, par);\n\tvga_out8(0x3d5, reg->CR58, par);\n\tvga_out8(0x3d4, 0x53, par);\n\tvga_out8(0x3d5, reg->CR53 & 0x7f, par);\n\n\tvga_out16(0x3c4, 0x0608, par);\n\n\t \n\n\tvga_out8(0x3c4, 0x0e, par);\n\tvga_out8(0x3c5, reg->SR0E, par);\n\tvga_out8(0x3c4, 0x0f, par);\n\tvga_out8(0x3c5, reg->SR0F, par);\n\tvga_out8(0x3c4, 0x29, par);\n\tvga_out8(0x3c5, reg->SR29, par);\n\tvga_out8(0x3c4, 0x15, par);\n\tvga_out8(0x3c5, reg->SR15, par);\n\n\t \n\tif (par->chip == S3_SAVAGE_MX) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tvga_out8(0x3c4, 0x54+i, par);\n\t\t\tvga_out8(0x3c5, reg->SR54[i], par);\n\t\t}\n\t}\n\n\tvgaHWRestore (par, reg);\n\n\t \n\tvga_out8(0x3d4, 0x53, par);\n\tvga_out8(0x3d5, reg->CR53, par);\n\tvga_out8(0x3d4, 0x5d, par);\n\tvga_out8(0x3d5, reg->CR5D, par);\n\tvga_out8(0x3d4, 0x5e, par);\n\tvga_out8(0x3d5, reg->CR5E, par);\n\tvga_out8(0x3d4, 0x3b, par);\n\tvga_out8(0x3d5, reg->CR3B, par);\n\tvga_out8(0x3d4, 0x3c, par);\n\tvga_out8(0x3d5, reg->CR3C, par);\n\tvga_out8(0x3d4, 0x43, par);\n\tvga_out8(0x3d5, reg->CR43, par);\n\tvga_out8(0x3d4, 0x65, par);\n\tvga_out8(0x3d5, reg->CR65, par);\n\n\t \n\tvga_out8(0x3d4, 0x67, par);\n\t \n\tcr67 = vga_in8(0x3d5, par) & 0xf;\n\tvga_out8(0x3d5, 0x50 | cr67, par);\n\tmdelay(10);\n\tvga_out8(0x3d4, 0x67, par);\n\t \n\tvga_out8(0x3d5, reg->CR67 & ~0x0c, par);\n\n\t \n\tvga_out8(0x3d4, 0x34, par);\n\tvga_out8(0x3d5, reg->CR34, par);\n\tvga_out8(0x3d4, 0x40, par);\n\tvga_out8(0x3d5, reg->CR40, par);\n\tvga_out8(0x3d4, 0x42, par);\n\tvga_out8(0x3d5, reg->CR42, par);\n\tvga_out8(0x3d4, 0x45, par);\n\tvga_out8(0x3d5, reg->CR45, par);\n\tvga_out8(0x3d4, 0x50, par);\n\tvga_out8(0x3d5, reg->CR50, par);\n\tvga_out8(0x3d4, 0x51, par);\n\tvga_out8(0x3d5, reg->CR51, par);\n\n\t \n\tvga_out8(0x3d4, 0x36, par);\n\tvga_out8(0x3d5, reg->CR36, par);\n\tvga_out8(0x3d4, 0x60, par);\n\tvga_out8(0x3d5, reg->CR60, par);\n\tvga_out8(0x3d4, 0x68, par);\n\tvga_out8(0x3d5, reg->CR68, par);\n\tvga_out8(0x3d4, 0x69, par);\n\tvga_out8(0x3d5, reg->CR69, par);\n\tvga_out8(0x3d4, 0x6f, par);\n\tvga_out8(0x3d5, reg->CR6F, par);\n\n\tvga_out8(0x3d4, 0x33, par);\n\tvga_out8(0x3d5, reg->CR33, par);\n\tvga_out8(0x3d4, 0x86, par);\n\tvga_out8(0x3d5, reg->CR86, par);\n\tvga_out8(0x3d4, 0x88, par);\n\tvga_out8(0x3d5, reg->CR88, par);\n\tvga_out8(0x3d4, 0x90, par);\n\tvga_out8(0x3d5, reg->CR90, par);\n\tvga_out8(0x3d4, 0x91, par);\n\tvga_out8(0x3d5, reg->CR91, par);\n\n\tif (par->chip == S3_SAVAGE4) {\n\t\tvga_out8(0x3d4, 0xb0, par);\n\t\tvga_out8(0x3d5, reg->CRB0, par);\n\t}\n\n\tvga_out8(0x3d4, 0x32, par);\n\tvga_out8(0x3d5, reg->CR32, par);\n\n\t \n\tvga_out8(0x3c4, 0x08, par);\n\tvga_out8(0x3c5, 0x06, par);\n\n\t \n\tif (reg->SR10 != 255) {\n\t\tvga_out8(0x3c4, 0x10, par);\n\t\tvga_out8(0x3c5, reg->SR10, par);\n\t\tvga_out8(0x3c4, 0x11, par);\n\t\tvga_out8(0x3c5, reg->SR11, par);\n\t}\n\n\t \n\tvga_out8(0x3c4, 0x0e, par);\n\tvga_out8(0x3c5, reg->SR0E, par);\n\tvga_out8(0x3c4, 0x0f, par);\n\tvga_out8(0x3c5, reg->SR0F, par);\n\tvga_out8(0x3c4, 0x12, par);\n\tvga_out8(0x3c5, reg->SR12, par);\n\tvga_out8(0x3c4, 0x13, par);\n\tvga_out8(0x3c5, reg->SR13, par);\n\tvga_out8(0x3c4, 0x29, par);\n\tvga_out8(0x3c5, reg->SR29, par);\n\tvga_out8(0x3c4, 0x18, par);\n\tvga_out8(0x3c5, reg->SR18, par);\n\n\t \n\tvga_out8(0x3c4, 0x15, par);\n\ttmp = vga_in8(0x3c5, par) & ~0x21;\n\n\tvga_out8(0x3c5, tmp | 0x03, par);\n\tvga_out8(0x3c5, tmp | 0x23, par);\n\tvga_out8(0x3c5, tmp | 0x03, par);\n\tvga_out8(0x3c5, reg->SR15, par);\n\tudelay(100);\n\n\tvga_out8(0x3c4, 0x30, par);\n\tvga_out8(0x3c5, reg->SR30, par);\n\tvga_out8(0x3c4, 0x08, par);\n\tvga_out8(0x3c5, reg->SR08, par);\n\n\t \n\tVerticalRetraceWait(par);\n\tvga_out8(0x3d4, 0x67, par);\n\tvga_out8(0x3d5, reg->CR67, par);\n\n\tvga_out8(0x3d4, 0x66, par);\n\tcr66 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr66 | 0x80, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\tcr3a = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr3a | 0x80, par);\n\n\tif (par->chip != S3_SAVAGE_MX) {\n\t\tVerticalRetraceWait(par);\n\t\tsavage_out32(FIFO_CONTROL_REG, reg->MMPR0, par);\n\t\tpar->SavageWaitIdle(par);\n\t\tsavage_out32(MIU_CONTROL_REG, reg->MMPR1, par);\n\t\tpar->SavageWaitIdle(par);\n\t\tsavage_out32(STREAMS_TIMEOUT_REG, reg->MMPR2, par);\n\t\tpar->SavageWaitIdle(par);\n\t\tsavage_out32(MISC_TIMEOUT_REG, reg->MMPR3, par);\n\t}\n\n\tvga_out8(0x3d4, 0x66, par);\n\tvga_out8(0x3d5, cr66, par);\n\tvga_out8(0x3d4, 0x3a, par);\n\tvga_out8(0x3d5, cr3a, par);\n\n\tSavageSetup2DEngine(par);\n\tvgaHWProtect(par, 0);\n}\n\nstatic void savagefb_update_start(struct savagefb_par *par, int base)\n{\n\t \n\tvga_out16(0x3d4, (base & 0x00ff00) | 0x0c, par);\n\tvga_out16(0x3d4, ((base & 0x00ff) << 8) | 0x0d, par);\n\tvga_out8(0x3d4, 0x69, par);\n\tvga_out8(0x3d5, (base & 0x7f0000) >> 16, par);\n}\n\n\nstatic void savagefb_set_fix(struct fb_info *info)\n{\n\tinfo->fix.line_length = info->var.xres_virtual *\n\t\tinfo->var.bits_per_pixel / 8;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tinfo->fix.visual      = FB_VISUAL_PSEUDOCOLOR;\n\t\tinfo->fix.xpanstep    = 4;\n\t} else {\n\t\tinfo->fix.visual      = FB_VISUAL_TRUECOLOR;\n\t\tinfo->fix.xpanstep    = 2;\n\t}\n\n}\n\nstatic int savagefb_set_par(struct fb_info *info)\n{\n\tstruct savagefb_par *par = info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tint err;\n\n\tDBG(\"savagefb_set_par\");\n\terr = savagefb_decode_var(var, par, &par->state);\n\tif (err)\n\t\treturn err;\n\n\tif (par->dacSpeedBpp <= 0) {\n\t\tif (var->bits_per_pixel > 24)\n\t\t\tpar->dacSpeedBpp = par->clock[3];\n\t\telse if (var->bits_per_pixel >= 24)\n\t\t\tpar->dacSpeedBpp = par->clock[2];\n\t\telse if ((var->bits_per_pixel > 8) && (var->bits_per_pixel < 24))\n\t\t\tpar->dacSpeedBpp = par->clock[1];\n\t\telse if (var->bits_per_pixel <= 8)\n\t\t\tpar->dacSpeedBpp = par->clock[0];\n\t}\n\n\t \n\tpar->maxClock = par->dacSpeedBpp;\n\tpar->minClock = 10000;\n\n\tsavagefb_set_par_int(par, &par->state);\n\tfb_set_cmap(&info->cmap, info);\n\tsavagefb_set_fix(info);\n\tsavagefb_set_clip(info);\n\n\tSavagePrintRegs(par);\n\treturn 0;\n}\n\n \nstatic int savagefb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info           *info)\n{\n\tstruct savagefb_par *par = info->par;\n\tint base;\n\n\tbase = (var->yoffset * info->fix.line_length\n\t     + (var->xoffset & ~1) * ((info->var.bits_per_pixel+7) / 8)) >> 2;\n\n\tsavagefb_update_start(par, base);\n\treturn 0;\n}\n\nstatic int savagefb_blank(int blank, struct fb_info *info)\n{\n\tstruct savagefb_par *par = info->par;\n\tu8 sr8 = 0, srd = 0;\n\n\tif (par->display_type == DISP_CRT) {\n\t\tvga_out8(0x3c4, 0x08, par);\n\t\tsr8 = vga_in8(0x3c5, par);\n\t\tsr8 |= 0x06;\n\t\tvga_out8(0x3c5, sr8, par);\n\t\tvga_out8(0x3c4, 0x0d, par);\n\t\tsrd = vga_in8(0x3c5, par);\n\t\tsrd &= 0x50;\n\n\t\tswitch (blank) {\n\t\tcase FB_BLANK_UNBLANK:\n\t\tcase FB_BLANK_NORMAL:\n\t\t\tbreak;\n\t\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\t\tsrd |= 0x10;\n\t\t\tbreak;\n\t\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\t\tsrd |= 0x40;\n\t\t\tbreak;\n\t\tcase FB_BLANK_POWERDOWN:\n\t\t\tsrd |= 0x50;\n\t\t\tbreak;\n\t\t}\n\n\t\tvga_out8(0x3c4, 0x0d, par);\n\t\tvga_out8(0x3c5, srd, par);\n\t}\n\n\tif (par->display_type == DISP_LCD ||\n\t    par->display_type == DISP_DFP) {\n\t\tswitch(blank) {\n\t\tcase FB_BLANK_UNBLANK:\n\t\tcase FB_BLANK_NORMAL:\n\t\t\tvga_out8(0x3c4, 0x31, par);  \n\t\t\tvga_out8(0x3c5, vga_in8(0x3c5, par) | 0x10, par);\n\t\t\tbreak;\n\t\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tcase FB_BLANK_POWERDOWN:\n\t\t\tvga_out8(0x3c4, 0x31, par);  \n\t\t\tvga_out8(0x3c5, vga_in8(0x3c5, par) & ~0x10, par);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (blank == FB_BLANK_NORMAL) ? 1 : 0;\n}\n\nstatic int savagefb_open(struct fb_info *info, int user)\n{\n\tstruct savagefb_par *par = info->par;\n\n\tmutex_lock(&par->open_lock);\n\n\tif (!par->open_count) {\n\t\tmemset(&par->vgastate, 0, sizeof(par->vgastate));\n\t\tpar->vgastate.flags = VGA_SAVE_CMAP | VGA_SAVE_FONTS |\n\t\t\tVGA_SAVE_MODE;\n\t\tpar->vgastate.vgabase = par->mmio.vbase + 0x8000;\n\t\tsave_vga(&par->vgastate);\n\t\tsavage_get_default_par(par, &par->initial);\n\t}\n\n\tpar->open_count++;\n\tmutex_unlock(&par->open_lock);\n\treturn 0;\n}\n\nstatic int savagefb_release(struct fb_info *info, int user)\n{\n\tstruct savagefb_par *par = info->par;\n\n\tmutex_lock(&par->open_lock);\n\n\tif (par->open_count == 1) {\n\t\tsavage_set_default_par(par, &par->initial);\n\t\trestore_vga(&par->vgastate);\n\t}\n\n\tpar->open_count--;\n\tmutex_unlock(&par->open_lock);\n\treturn 0;\n}\n\nstatic const struct fb_ops savagefb_ops = {\n\t.owner          = THIS_MODULE,\n\t.fb_open        = savagefb_open,\n\t.fb_release     = savagefb_release,\n\t.fb_check_var   = savagefb_check_var,\n\t.fb_set_par     = savagefb_set_par,\n\t.fb_setcolreg   = savagefb_setcolreg,\n\t.fb_pan_display = savagefb_pan_display,\n\t.fb_blank       = savagefb_blank,\n#if defined(CONFIG_FB_SAVAGE_ACCEL)\n\t.fb_fillrect    = savagefb_fillrect,\n\t.fb_copyarea    = savagefb_copyarea,\n\t.fb_imageblit   = savagefb_imageblit,\n\t.fb_sync        = savagefb_sync,\n#else\n\t.fb_fillrect    = cfb_fillrect,\n\t.fb_copyarea    = cfb_copyarea,\n\t.fb_imageblit   = cfb_imageblit,\n#endif\n};\n\n \n\nstatic const struct fb_var_screeninfo savagefb_var800x600x8 = {\n\t.accel_flags =\tFB_ACCELF_TEXT,\n\t.xres =\t\t800,\n\t.yres =\t\t600,\n\t.xres_virtual =  800,\n\t.yres_virtual =  600,\n\t.bits_per_pixel = 8,\n\t.pixclock =\t25000,\n\t.left_margin =\t88,\n\t.right_margin =\t40,\n\t.upper_margin =\t23,\n\t.lower_margin =\t1,\n\t.hsync_len =\t128,\n\t.vsync_len =\t4,\n\t.sync =\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t.vmode =\tFB_VMODE_NONINTERLACED\n};\n\nstatic void savage_enable_mmio(struct savagefb_par *par)\n{\n\tunsigned char val;\n\n\tDBG(\"savage_enable_mmio\\n\");\n\n\tval = vga_in8(0x3c3, par);\n\tvga_out8(0x3c3, val | 0x01, par);\n\tval = vga_in8(0x3cc, par);\n\tvga_out8(0x3c2, val | 0x01, par);\n\n\tif (par->chip >= S3_SAVAGE4) {\n\t\tvga_out8(0x3d4, 0x40, par);\n\t\tval = vga_in8(0x3d5, par);\n\t\tvga_out8(0x3d5, val | 1, par);\n\t}\n}\n\n\nstatic void savage_disable_mmio(struct savagefb_par *par)\n{\n\tunsigned char val;\n\n\tDBG(\"savage_disable_mmio\\n\");\n\n\tif (par->chip >= S3_SAVAGE4) {\n\t\tvga_out8(0x3d4, 0x40, par);\n\t\tval = vga_in8(0x3d5, par);\n\t\tvga_out8(0x3d5, val | 1, par);\n\t}\n}\n\n\nstatic int savage_map_mmio(struct fb_info *info)\n{\n\tstruct savagefb_par *par = info->par;\n\tDBG(\"savage_map_mmio\");\n\n\tif (S3_SAVAGE3D_SERIES(par->chip))\n\t\tpar->mmio.pbase = pci_resource_start(par->pcidev, 0) +\n\t\t\tSAVAGE_NEWMMIO_REGBASE_S3;\n\telse\n\t\tpar->mmio.pbase = pci_resource_start(par->pcidev, 0) +\n\t\t\tSAVAGE_NEWMMIO_REGBASE_S4;\n\n\tpar->mmio.len = SAVAGE_NEWMMIO_REGSIZE;\n\n\tpar->mmio.vbase = ioremap(par->mmio.pbase, par->mmio.len);\n\tif (!par->mmio.vbase) {\n\t\tprintk(\"savagefb: unable to map memory mapped IO\\n\");\n\t\treturn -ENOMEM;\n\t} else\n\t\tprintk(KERN_INFO \"savagefb: mapped io at %p\\n\",\n\t\t\tpar->mmio.vbase);\n\n\tinfo->fix.mmio_start = par->mmio.pbase;\n\tinfo->fix.mmio_len   = par->mmio.len;\n\n\tpar->bci_base = (u32 __iomem *)(par->mmio.vbase + BCI_BUFFER_OFFSET);\n\tpar->bci_ptr  = 0;\n\n\tsavage_enable_mmio(par);\n\n\treturn 0;\n}\n\nstatic void savage_unmap_mmio(struct fb_info *info)\n{\n\tstruct savagefb_par *par = info->par;\n\tDBG(\"savage_unmap_mmio\");\n\n\tsavage_disable_mmio(par);\n\n\tif (par->mmio.vbase) {\n\t\tiounmap(par->mmio.vbase);\n\t\tpar->mmio.vbase = NULL;\n\t}\n}\n\nstatic int savage_map_video(struct fb_info *info, int video_len)\n{\n\tstruct savagefb_par *par = info->par;\n\tint resource;\n\n\tDBG(\"savage_map_video\");\n\n\tif (S3_SAVAGE3D_SERIES(par->chip))\n\t\tresource = 0;\n\telse\n\t\tresource = 1;\n\n\tpar->video.pbase = pci_resource_start(par->pcidev, resource);\n\tpar->video.len   = video_len;\n\tpar->video.vbase = ioremap_wc(par->video.pbase, par->video.len);\n\n\tif (!par->video.vbase) {\n\t\tprintk(\"savagefb: unable to map screen memory\\n\");\n\t\treturn -ENOMEM;\n\t} else\n\t\tprintk(KERN_INFO \"savagefb: mapped framebuffer at %p, \"\n\t\t       \"pbase == %x\\n\", par->video.vbase, par->video.pbase);\n\n\tinfo->fix.smem_start = par->video.pbase;\n\tinfo->fix.smem_len   = par->video.len - par->cob_size;\n\tinfo->screen_base    = par->video.vbase;\n\tpar->video.wc_cookie = arch_phys_wc_add(par->video.pbase, video_len);\n\n\t \n\tmemset_io(par->video.vbase, 0, par->video.len);\n\n\treturn 0;\n}\n\nstatic void savage_unmap_video(struct fb_info *info)\n{\n\tstruct savagefb_par *par = info->par;\n\n\tDBG(\"savage_unmap_video\");\n\n\tif (par->video.vbase) {\n\t\tarch_phys_wc_del(par->video.wc_cookie);\n\t\tiounmap(par->video.vbase);\n\t\tpar->video.vbase = NULL;\n\t\tinfo->screen_base = NULL;\n\t}\n}\n\nstatic int savage_init_hw(struct savagefb_par *par)\n{\n\tunsigned char config1, m, n, n1, n2, sr8, cr3f, cr66 = 0, tmp;\n\n\tstatic unsigned char RamSavage3D[] = { 8, 4, 4, 2 };\n\tstatic unsigned char RamSavage4[] =  { 2, 4, 8, 12, 16, 32, 64, 32 };\n\tstatic unsigned char RamSavageMX[] = { 2, 8, 4, 16, 8, 16, 4, 16 };\n\tstatic unsigned char RamSavageNB[] = { 0, 2, 4, 8, 16, 32, 2, 2 };\n\tint videoRam, videoRambytes, dvi;\n\n\tDBG(\"savage_init_hw\");\n\n\t \n\tvga_out8(0x3d4, 0x11, par);\n\ttmp = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, tmp & 0x7f, par);\n\n\t \n\tvga_out16(0x3d4, 0x4838, par);\n\tvga_out16(0x3d4, 0xa039, par);\n\tvga_out16(0x3c4, 0x0608, par);\n\n\tvga_out8(0x3d4, 0x40, par);\n\ttmp = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, tmp & ~0x01, par);\n\n\t \n\tvga_out8(0x3d4, 0x38, par);\n\tvga_out8(0x3d5, 0x48, par);\n\n\t \n\tvga_out16(0x3d4, 0x4838, par);\n\n\t \n\n\tvga_out8(0x3d4, 0x36, par);             \n\tconfig1 = vga_in8(0x3d5, par);     \n\n\t \n\n\tswitch  (par->chip) {\n\tcase S3_SAVAGE3D:\n\t\tvideoRam = RamSavage3D[(config1 & 0xC0) >> 6 ] * 1024;\n\t\tbreak;\n\n\tcase S3_SAVAGE4:\n\t\t \n\t\tvga_out8(0x3d4, 0x68, par);\t \n\t\tif ((vga_in8(0x3d5, par) & 0xC0) == (0x01 << 6))\n\t\t\tRamSavage4[1] = 8;\n\t\tfallthrough;\n\n\tcase S3_SAVAGE2000:\n\t\tvideoRam = RamSavage4[(config1 & 0xE0) >> 5] * 1024;\n\t\tbreak;\n\n\tcase S3_SAVAGE_MX:\n\tcase S3_SUPERSAVAGE:\n\t\tvideoRam = RamSavageMX[(config1 & 0x0E) >> 1] * 1024;\n\t\tbreak;\n\n\tcase S3_PROSAVAGE:\n\tcase S3_PROSAVAGEDDR:\n\tcase S3_TWISTER:\n\t\tvideoRam = RamSavageNB[(config1 & 0xE0) >> 5] * 1024;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tvideoRam = 0;\n\t\tbreak;\n\t}\n\n\tvideoRambytes = videoRam * 1024;\n\n\tprintk(KERN_INFO \"savagefb: probed videoram:  %dk\\n\", videoRam);\n\n\t \n\tvga_out8(0x3d4, 0x66, par);\n\tcr66 = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr66 | 0x02, par);\n\tusleep_range(10000, 11000);\n\n\tvga_out8(0x3d4, 0x66, par);\n\tvga_out8(0x3d5, cr66 & ~0x02, par);\t \n\tusleep_range(10000, 11000);\n\n\n\t \n\tvga_out8(0x3d4, 0x3f, par);\n\tcr3f = vga_in8(0x3d5, par);\n\tvga_out8(0x3d5, cr3f | 0x08, par);\n\tusleep_range(10000, 11000);\n\n\tvga_out8(0x3d4, 0x3f, par);\n\tvga_out8(0x3d5, cr3f & ~0x08, par);\t \n\tusleep_range(10000, 11000);\n\n\t \n\tpar->numClocks = 4;\n\tpar->clock[0] = 250000;\n\tpar->clock[1] = 250000;\n\tpar->clock[2] = 220000;\n\tpar->clock[3] = 220000;\n\n\t \n\tvga_out8(0x3c4, 0x08, par);\n\tsr8 = vga_in8(0x3c5, par);\n\tvga_out8(0x3c5, 0x06, par);\n\tvga_out8(0x3c4, 0x10, par);\n\tn = vga_in8(0x3c5, par);\n\tvga_out8(0x3c4, 0x11, par);\n\tm = vga_in8(0x3c5, par);\n\tvga_out8(0x3c4, 0x08, par);\n\tvga_out8(0x3c5, sr8, par);\n\tm &= 0x7f;\n\tn1 = n & 0x1f;\n\tn2 = (n >> 5) & 0x03;\n\tpar->MCLK = ((1431818 * (m+2)) / (n1+2) / (1 << n2) + 50) / 100;\n\tprintk(KERN_INFO \"savagefb: Detected current MCLK value of %d kHz\\n\",\n\t\tpar->MCLK);\n\n\t \n\tdvi = 0;\n\n\tif (par->chip == S3_SAVAGE4) {\n\t\tunsigned char sr30 = 0x00;\n\n\t\tvga_out8(0x3c4, 0x30, par);\n\t\t \n\t\tvga_out8(0x3c5, vga_in8(0x3c5, par) & ~0x02, par);\n\t\tsr30 = vga_in8(0x3c5, par);\n\t\tif (sr30 & 0x02  ) {\n\t\t\tdvi = 1;\n\t\t\tprintk(\"savagefb: Digital Flat Panel Detected\\n\");\n\t\t}\n\t}\n\n\tif ((S3_SAVAGE_MOBILE_SERIES(par->chip) ||\n\t     S3_MOBILE_TWISTER_SERIES(par->chip)) && !par->crtonly)\n\t\tpar->display_type = DISP_LCD;\n\telse if (dvi || (par->chip == S3_SAVAGE4 && par->dvi))\n\t\tpar->display_type = DISP_DFP;\n\telse\n\t\tpar->display_type = DISP_CRT;\n\n\t \n\n\tif (par->display_type == DISP_LCD) {\n\t\tunsigned char cr6b = VGArCR(0x6b, par);\n\n\t\tint panelX = (VGArSEQ(0x61, par) +\n\t\t\t      ((VGArSEQ(0x66, par) & 0x02) << 7) + 1) * 8;\n\t\tint panelY = (VGArSEQ(0x69, par) +\n\t\t\t      ((VGArSEQ(0x6e, par) & 0x70) << 4) + 1);\n\n\t\tchar * sTechnology = \"Unknown\";\n\n\t\t \n\n\t\tenum ACTIVE_DISPLAYS {  \n\t\t\tActiveCRT = 0x01,\n\t\t\tActiveLCD = 0x02,\n\t\t\tActiveTV = 0x04,\n\t\t\tActiveCRT2 = 0x20,\n\t\t\tActiveDUO = 0x80\n\t\t};\n\n\t\tif ((VGArSEQ(0x39, par) & 0x03) == 0) {\n\t\t\tsTechnology = \"TFT\";\n\t\t} else if ((VGArSEQ(0x30, par) & 0x01) == 0) {\n\t\t\tsTechnology = \"DSTN\";\n\t\t} else \t{\n\t\t\tsTechnology = \"STN\";\n\t\t}\n\n\t\tprintk(KERN_INFO \"savagefb: %dx%d %s LCD panel detected %s\\n\",\n\t\t       panelX, panelY, sTechnology,\n\t\t       cr6b & ActiveLCD ? \"and active\" : \"but not active\");\n\n\t\tif (cr6b & ActiveLCD) \t{\n\t\t\t \n\n\t\t\tprintk(KERN_INFO \"savagefb: Limiting video mode to \"\n\t\t\t\t\"%dx%d\\n\", panelX, panelY);\n\n\t\t\tpar->SavagePanelWidth = panelX;\n\t\t\tpar->SavagePanelHeight = panelY;\n\n\t\t} else\n\t\t\tpar->display_type = DISP_CRT;\n\t}\n\n\tsavage_get_default_par(par, &par->state);\n\tpar->save = par->state;\n\n\tif (S3_SAVAGE4_SERIES(par->chip)) {\n\t\t \n\t\tpar->cob_index = 2;\n\t\tpar->cob_size = 0x8000 << par->cob_index;\n\t\tpar->cob_offset = videoRambytes;\n\t} else {\n\t\t \n\n\t\tpar->cob_index  = 7;\n\t\tpar->cob_size   = 0x400 << par->cob_index;\n\t\tpar->cob_offset = videoRambytes - par->cob_size;\n\t}\n\n\treturn videoRambytes;\n}\n\nstatic int savage_init_fb_info(struct fb_info *info, struct pci_dev *dev,\n\t\t\t       const struct pci_device_id *id)\n{\n\tstruct savagefb_par *par = info->par;\n\tint err = 0;\n\n\tpar->pcidev  = dev;\n\n\tinfo->fix.type\t   = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.type_aux\t   = 0;\n\tinfo->fix.ypanstep\t   = 1;\n\tinfo->fix.ywrapstep   = 0;\n\tinfo->fix.accel       = id->driver_data;\n\n\tswitch (info->fix.accel) {\n\tcase FB_ACCEL_SUPERSAVAGE:\n\t\tpar->chip = S3_SUPERSAVAGE;\n\t\tsnprintf(info->fix.id, 16, \"SuperSavage\");\n\t\tbreak;\n\tcase FB_ACCEL_SAVAGE4:\n\t\tpar->chip = S3_SAVAGE4;\n\t\tsnprintf(info->fix.id, 16, \"Savage4\");\n\t\tbreak;\n\tcase FB_ACCEL_SAVAGE3D:\n\t\tpar->chip = S3_SAVAGE3D;\n\t\tsnprintf(info->fix.id, 16, \"Savage3D\");\n\t\tbreak;\n\tcase FB_ACCEL_SAVAGE3D_MV:\n\t\tpar->chip = S3_SAVAGE3D;\n\t\tsnprintf(info->fix.id, 16, \"Savage3D-MV\");\n\t\tbreak;\n\tcase FB_ACCEL_SAVAGE2000:\n\t\tpar->chip = S3_SAVAGE2000;\n\t\tsnprintf(info->fix.id, 16, \"Savage2000\");\n\t\tbreak;\n\tcase FB_ACCEL_SAVAGE_MX_MV:\n\t\tpar->chip = S3_SAVAGE_MX;\n\t\tsnprintf(info->fix.id, 16, \"Savage/MX-MV\");\n\t\tbreak;\n\tcase FB_ACCEL_SAVAGE_MX:\n\t\tpar->chip = S3_SAVAGE_MX;\n\t\tsnprintf(info->fix.id, 16, \"Savage/MX\");\n\t\tbreak;\n\tcase FB_ACCEL_SAVAGE_IX_MV:\n\t\tpar->chip = S3_SAVAGE_MX;\n\t\tsnprintf(info->fix.id, 16, \"Savage/IX-MV\");\n\t\tbreak;\n\tcase FB_ACCEL_SAVAGE_IX:\n\t\tpar->chip = S3_SAVAGE_MX;\n\t\tsnprintf(info->fix.id, 16, \"Savage/IX\");\n\t\tbreak;\n\tcase FB_ACCEL_PROSAVAGE_PM:\n\t\tpar->chip = S3_PROSAVAGE;\n\t\tsnprintf(info->fix.id, 16, \"ProSavagePM\");\n\t\tbreak;\n\tcase FB_ACCEL_PROSAVAGE_KM:\n\t\tpar->chip = S3_PROSAVAGE;\n\t\tsnprintf(info->fix.id, 16, \"ProSavageKM\");\n\t\tbreak;\n\tcase FB_ACCEL_S3TWISTER_P:\n\t\tpar->chip = S3_TWISTER;\n\t\tsnprintf(info->fix.id, 16, \"TwisterP\");\n\t\tbreak;\n\tcase FB_ACCEL_S3TWISTER_K:\n\t\tpar->chip = S3_TWISTER;\n\t\tsnprintf(info->fix.id, 16, \"TwisterK\");\n\t\tbreak;\n\tcase FB_ACCEL_PROSAVAGE_DDR:\n\t\tpar->chip = S3_PROSAVAGEDDR;\n\t\tsnprintf(info->fix.id, 16, \"ProSavageDDR\");\n\t\tbreak;\n\tcase FB_ACCEL_PROSAVAGE_DDRK:\n\t\tpar->chip = S3_PROSAVAGEDDR;\n\t\tsnprintf(info->fix.id, 16, \"ProSavage8\");\n\t\tbreak;\n\t}\n\n\tif (S3_SAVAGE3D_SERIES(par->chip)) {\n\t\tpar->SavageWaitIdle = savage3D_waitidle;\n\t\tpar->SavageWaitFifo = savage3D_waitfifo;\n\t} else if (S3_SAVAGE4_SERIES(par->chip) ||\n\t\t   S3_SUPERSAVAGE == par->chip) {\n\t\tpar->SavageWaitIdle = savage4_waitidle;\n\t\tpar->SavageWaitFifo = savage4_waitfifo;\n\t} else {\n\t\tpar->SavageWaitIdle = savage2000_waitidle;\n\t\tpar->SavageWaitFifo = savage2000_waitfifo;\n\t}\n\n\tinfo->var.nonstd      = 0;\n\tinfo->var.activate    = FB_ACTIVATE_NOW;\n\tinfo->var.width       = -1;\n\tinfo->var.height      = -1;\n\tinfo->var.accel_flags = 0;\n\n\tinfo->fbops          = &savagefb_ops;\n\tinfo->flags          = FBINFO_HWACCEL_YPAN |\n\t\t               FBINFO_HWACCEL_XPAN;\n\n\tinfo->pseudo_palette = par->pseudo_palette;\n\n#if defined(CONFIG_FB_SAVAGE_ACCEL)\n\t \n\tinfo->pixmap.addr = kcalloc(8, 1024, GFP_KERNEL);\n\n\terr = -ENOMEM;\n\tif (info->pixmap.addr) {\n\t\tinfo->pixmap.size = 8*1024;\n\t\tinfo->pixmap.scan_align = 4;\n\t\tinfo->pixmap.buf_align = 4;\n\t\tinfo->pixmap.access_align = 32;\n\n\t\terr = fb_alloc_cmap(&info->cmap, NR_PALETTE, 0);\n\t\tif (!err)\n\t\t\tinfo->flags |= FBINFO_HWACCEL_COPYAREA |\n\t\t\t\t       FBINFO_HWACCEL_FILLRECT |\n\t\t\t\t       FBINFO_HWACCEL_IMAGEBLIT;\n\t\telse\n\t\t\tkfree(info->pixmap.addr);\n\t}\n#endif\n\treturn err;\n}\n\n \n\nstatic int savagefb_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct fb_info *info;\n\tstruct savagefb_par *par;\n\tu_int h_sync, v_sync;\n\tunsigned char __maybe_unused *edid;\n\tint err, lpitch;\n\tint video_len;\n\n\tDBG(\"savagefb_probe\");\n\n\terr = aperture_remove_conflicting_pci_devices(dev, \"savagefb\");\n\tif (err)\n\t\treturn err;\n\n\tinfo = framebuffer_alloc(sizeof(struct savagefb_par), &dev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tpar = info->par;\n\tmutex_init(&par->open_lock);\n\terr = pci_enable_device(dev);\n\tif (err)\n\t\tgoto failed_enable;\n\n\tif ((err = pci_request_regions(dev, \"savagefb\"))) {\n\t\tprintk(KERN_ERR \"cannot request PCI regions\\n\");\n\t\tgoto failed_enable;\n\t}\n\n\terr = -ENOMEM;\n\n\tif ((err = savage_init_fb_info(info, dev, id)))\n\t\tgoto failed_init;\n\n\terr = savage_map_mmio(info);\n\tif (err)\n\t\tgoto failed_mmio;\n\n\tvideo_len = savage_init_hw(par);\n\t \n\tif (video_len < 0) {\n\t\terr = video_len;\n\t\tgoto failed_mmio;\n\t}\n\n\terr = savage_map_video(info, video_len);\n\tif (err)\n\t\tgoto failed_video;\n\n\tINIT_LIST_HEAD(&info->modelist);\n#if defined(CONFIG_FB_SAVAGE_I2C)\n\tsavagefb_create_i2c_busses(info);\n\tsavagefb_probe_i2c_connector(info, &edid);\n\tfb_edid_to_monspecs(edid, &info->monspecs);\n\tkfree(edid);\n\tfb_videomode_to_modelist(info->monspecs.modedb,\n\t\t\t\t info->monspecs.modedb_len,\n\t\t\t\t &info->modelist);\n#endif\n\tinfo->var = savagefb_var800x600x8;\n\t \n\tif (par->SavagePanelWidth) {\n\t\tstruct fb_videomode cvt_mode;\n\n\t\tmemset(&cvt_mode, 0, sizeof(cvt_mode));\n\t\tcvt_mode.xres = par->SavagePanelWidth;\n\t\tcvt_mode.yres = par->SavagePanelHeight;\n\t\tcvt_mode.refresh = 60;\n\t\t \n\t\tif (fb_find_mode_cvt(&cvt_mode, 0, 0))\n\t\t\tprintk(KERN_WARNING \"No CVT mode found for panel\\n\");\n\t\telse if (fb_find_mode(&info->var, info, NULL, NULL, 0,\n\t\t\t\t      &cvt_mode, 0) != 3)\n\t\t\tinfo->var = savagefb_var800x600x8;\n\t}\n\n\tif (mode_option) {\n\t\tfb_find_mode(&info->var, info, mode_option,\n\t\t\t     info->monspecs.modedb, info->monspecs.modedb_len,\n\t\t\t     NULL, 8);\n\t} else if (info->monspecs.modedb != NULL) {\n\t\tconst struct fb_videomode *mode;\n\n\t\tmode = fb_find_best_display(&info->monspecs, &info->modelist);\n\t\tsavage_update_var(&info->var, mode);\n\t}\n\n\t \n\tlpitch = info->var.xres_virtual*((info->var.bits_per_pixel + 7) >> 3);\n\tinfo->var.yres_virtual = info->fix.smem_len/lpitch;\n\n\tif (info->var.yres_virtual < info->var.yres) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n#if defined(CONFIG_FB_SAVAGE_ACCEL)\n\t \n\tif (info->var.yres_virtual > 0x1000)\n\t\tinfo->var.yres_virtual = 0x1000;\n\n\tif (info->var.xres_virtual > 0x1000)\n\t\tinfo->var.xres_virtual = 0x1000;\n#endif\n\tsavagefb_check_var(&info->var, info);\n\tsavagefb_set_fix(info);\n\n\t \n\th_sync = 1953125000 / info->var.pixclock;\n\th_sync = h_sync * 512 / (info->var.xres + info->var.left_margin +\n\t\t\t\t info->var.right_margin +\n\t\t\t\t info->var.hsync_len);\n\tv_sync = h_sync / (info->var.yres + info->var.upper_margin +\n\t\t\t   info->var.lower_margin + info->var.vsync_len);\n\n\tprintk(KERN_INFO \"savagefb v\" SAVAGEFB_VERSION \": \"\n\t       \"%dkB VRAM, using %dx%d, %d.%03dkHz, %dHz\\n\",\n\t       info->fix.smem_len >> 10,\n\t       info->var.xres, info->var.yres,\n\t       h_sync / 1000, h_sync % 1000, v_sync);\n\n\n\tfb_destroy_modedb(info->monspecs.modedb);\n\tinfo->monspecs.modedb = NULL;\n\n\terr = register_framebuffer(info);\n\tif (err < 0)\n\t\tgoto failed;\n\n\tprintk(KERN_INFO \"fb: S3 %s frame buffer device\\n\",\n\t       info->fix.id);\n\n\t \n\tpci_set_drvdata(dev, info);\n\n\treturn 0;\n\n failed:\n#ifdef CONFIG_FB_SAVAGE_I2C\n\tsavagefb_delete_i2c_busses(info);\n#endif\n\tfb_alloc_cmap(&info->cmap, 0, 0);\n\tsavage_unmap_video(info);\n failed_video:\n\tsavage_unmap_mmio(info);\n failed_mmio:\n\tkfree(info->pixmap.addr);\n failed_init:\n\tpci_release_regions(dev);\n failed_enable:\n\tframebuffer_release(info);\n\n\treturn err;\n}\n\nstatic void savagefb_remove(struct pci_dev *dev)\n{\n\tstruct fb_info *info = pci_get_drvdata(dev);\n\n\tDBG(\"savagefb_remove\");\n\n\tif (info) {\n\t\tunregister_framebuffer(info);\n\n#ifdef CONFIG_FB_SAVAGE_I2C\n\t\tsavagefb_delete_i2c_busses(info);\n#endif\n\t\tfb_alloc_cmap(&info->cmap, 0, 0);\n\t\tsavage_unmap_video(info);\n\t\tsavage_unmap_mmio(info);\n\t\tkfree(info->pixmap.addr);\n\t\tpci_release_regions(dev);\n\t\tframebuffer_release(info);\n\t}\n}\n\nstatic int savagefb_suspend_late(struct device *dev, pm_message_t mesg)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct savagefb_par *par = info->par;\n\n\tDBG(\"savagefb_suspend\");\n\n\tif (mesg.event == PM_EVENT_PRETHAW)\n\t\tmesg.event = PM_EVENT_FREEZE;\n\tpar->pm_state = mesg.event;\n\tdev->power.power_state = mesg;\n\n\t \n\tif (mesg.event == PM_EVENT_FREEZE)\n\t\treturn 0;\n\n\tconsole_lock();\n\tfb_set_suspend(info, 1);\n\n\tif (info->fbops->fb_sync)\n\t\tinfo->fbops->fb_sync(info);\n\n\tsavagefb_blank(FB_BLANK_POWERDOWN, info);\n\tsavage_set_default_par(par, &par->save);\n\tsavage_disable_mmio(par);\n\tconsole_unlock();\n\n\treturn 0;\n}\n\nstatic int __maybe_unused savagefb_suspend(struct device *dev)\n{\n\treturn savagefb_suspend_late(dev, PMSG_SUSPEND);\n}\n\nstatic int __maybe_unused savagefb_hibernate(struct device *dev)\n{\n\treturn savagefb_suspend_late(dev, PMSG_HIBERNATE);\n}\n\nstatic int __maybe_unused savagefb_freeze(struct device *dev)\n{\n\treturn savagefb_suspend_late(dev, PMSG_FREEZE);\n}\n\nstatic int __maybe_unused savagefb_resume(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct savagefb_par *par = info->par;\n\tint cur_state = par->pm_state;\n\n\tDBG(\"savage_resume\");\n\n\tpar->pm_state = PM_EVENT_ON;\n\n\t \n\tif (cur_state == PM_EVENT_FREEZE)\n\t\treturn 0;\n\n\tconsole_lock();\n\n\tsavage_enable_mmio(par);\n\tsavage_init_hw(par);\n\tsavagefb_set_par(info);\n\tfb_set_suspend(info, 0);\n\tsavagefb_blank(FB_BLANK_UNBLANK, info);\n\tconsole_unlock();\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops savagefb_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= savagefb_suspend,\n\t.resume\t\t= savagefb_resume,\n\t.freeze\t\t= savagefb_freeze,\n\t.thaw\t\t= savagefb_resume,\n\t.poweroff\t= savagefb_hibernate,\n\t.restore\t= savagefb_resume,\n#endif\n};\n\nstatic const struct pci_device_id savagefb_devices[] = {\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SUPSAV_MX128,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SUPERSAVAGE},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SUPSAV_MX64,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SUPERSAVAGE},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SUPSAV_MX64C,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SUPERSAVAGE},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SUPSAV_IX128SDR,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SUPERSAVAGE},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SUPSAV_IX128DDR,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SUPERSAVAGE},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SUPSAV_IX64SDR,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SUPERSAVAGE},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SUPSAV_IX64DDR,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SUPERSAVAGE},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SUPSAV_IXCSDR,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SUPERSAVAGE},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SUPSAV_IXCDDR,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SUPERSAVAGE},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SAVAGE4,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SAVAGE4},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SAVAGE3D,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SAVAGE3D},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SAVAGE3D_MV,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SAVAGE3D_MV},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SAVAGE2000,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SAVAGE2000},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SAVAGE_MX_MV,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SAVAGE_MX_MV},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SAVAGE_MX,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SAVAGE_MX},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SAVAGE_IX_MV,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SAVAGE_IX_MV},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_SAVAGE_IX,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_SAVAGE_IX},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_PROSAVAGE_PM,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_PROSAVAGE_PM},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_PROSAVAGE_KM,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_PROSAVAGE_KM},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_S3TWISTER_P,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_S3TWISTER_P},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_S3TWISTER_K,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_S3TWISTER_K},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_PROSAVAGE_DDR,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_PROSAVAGE_DDR},\n\n\t{PCI_VENDOR_ID_S3, PCI_CHIP_PROSAVAGE_DDRK,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_PROSAVAGE_DDRK},\n\n\t{0, 0, 0, 0, 0, 0, 0}\n};\n\nMODULE_DEVICE_TABLE(pci, savagefb_devices);\n\nstatic struct pci_driver savagefb_driver = {\n\t.name =     \"savagefb\",\n\t.id_table = savagefb_devices,\n\t.probe =    savagefb_probe,\n\t.driver.pm = &savagefb_pm_ops,\n\t.remove =   savagefb_remove,\n};\n\n \n\nstatic void __exit savage_done(void)\n{\n\tDBG(\"savage_done\");\n\tpci_unregister_driver(&savagefb_driver);\n}\n\n\n \n\nstatic int __init savagefb_setup(char *options)\n{\n#ifndef MODULE\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tmode_option = this_opt;\n\t}\n#endif  \n\treturn 0;\n}\n\nstatic int __init savagefb_init(void)\n{\n\tchar *option;\n\n\tDBG(\"savagefb_init\");\n\n\tif (fb_modesetting_disabled(\"savagefb\"))\n\t\treturn -ENODEV;\n\n\tif (fb_get_options(\"savagefb\", &option))\n\t\treturn -ENODEV;\n\n\tsavagefb_setup(option);\n\treturn pci_register_driver(&savagefb_driver);\n\n}\n\nmodule_init(savagefb_init);\nmodule_exit(savage_done);\n\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Specify initial video mode\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}