{
  "module_name": "savagefb_accel.c",
  "hash_id": "9e5aa0a3563968cd78be48df3d4ebfa2c3ad842a7fcf73f0ebadf9cbc501cf3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/savage/savagefb_accel.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fb.h>\n#include <linux/module.h>\n\n#include \"savagefb.h\"\n\nstatic u32 savagefb_rop[] = {\n\t0xCC,  \n\t0x5A   \n};\n\nint savagefb_sync(struct fb_info *info)\n{\n\tstruct savagefb_par *par = info->par;\n\n\tpar->SavageWaitIdle(par);\n\treturn 0;\n}\n\nvoid savagefb_copyarea(struct fb_info *info, const struct fb_copyarea *region)\n{\n\tstruct savagefb_par *par = info->par;\n\tint sx = region->sx, dx = region->dx;\n\tint sy = region->sy, dy = region->dy;\n\tint cmd;\n\n\tif (!region->width || !region->height)\n\t\treturn;\n\tpar->bci_ptr = 0;\n\tcmd = BCI_CMD_RECT | BCI_CMD_DEST_GBD | BCI_CMD_SRC_GBD;\n\tBCI_CMD_SET_ROP(cmd, savagefb_rop[0]);\n\n\tif (dx <= sx) {\n\t\tcmd |= BCI_CMD_RECT_XP;\n\t} else {\n\t\tsx += region->width - 1;\n\t\tdx += region->width - 1;\n\t}\n\n\tif (dy <= sy) {\n\t\tcmd |= BCI_CMD_RECT_YP;\n\t} else {\n\t\tsy += region->height - 1;\n\t\tdy += region->height - 1;\n\t}\n\n\tpar->SavageWaitFifo(par,4);\n\tBCI_SEND(cmd);\n\tBCI_SEND(BCI_X_Y(sx, sy));\n\tBCI_SEND(BCI_X_Y(dx, dy));\n\tBCI_SEND(BCI_W_H(region->width, region->height));\n}\n\nvoid savagefb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct savagefb_par *par = info->par;\n\tint cmd, color;\n\n\tif (!rect->width || !rect->height)\n\t\treturn;\n\n\tif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR)\n\t\tcolor = rect->color;\n\telse\n\t\tcolor = ((u32 *)info->pseudo_palette)[rect->color];\n\n\tcmd = BCI_CMD_RECT | BCI_CMD_RECT_XP | BCI_CMD_RECT_YP |\n\t      BCI_CMD_DEST_GBD | BCI_CMD_SRC_SOLID |\n\t      BCI_CMD_SEND_COLOR;\n\n\tpar->bci_ptr = 0;\n\tBCI_CMD_SET_ROP(cmd, savagefb_rop[rect->rop]);\n\n\tpar->SavageWaitFifo(par,4);\n\tBCI_SEND(cmd);\n\tBCI_SEND(color);\n\tBCI_SEND( BCI_X_Y(rect->dx, rect->dy) );\n\tBCI_SEND( BCI_W_H(rect->width, rect->height) );\n}\n\nvoid savagefb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct savagefb_par *par = info->par;\n\tint fg, bg, size, i, width;\n\tint cmd;\n\tu32 *src = (u32 *) image->data;\n\n\tif (!image->width || !image->height)\n\t\treturn;\n\n\tif (image->depth != 1) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\n\tif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR) {\n\t\tfg = image->fg_color;\n\t\tbg = image->bg_color;\n\t} else {\n\t\tfg = ((u32 *)info->pseudo_palette)[image->fg_color];\n\t\tbg = ((u32 *)info->pseudo_palette)[image->bg_color];\n\t}\n\n\tcmd = BCI_CMD_RECT | BCI_CMD_RECT_XP | BCI_CMD_RECT_YP |\n\t      BCI_CMD_CLIP_LR | BCI_CMD_DEST_GBD | BCI_CMD_SRC_MONO |\n\t      BCI_CMD_SEND_COLOR;\n\n\tpar->bci_ptr = 0;\n\tBCI_CMD_SET_ROP(cmd, savagefb_rop[0]);\n\n\twidth = (image->width + 31) & ~31;\n\tsize = (width * image->height)/8;\n\tsize >>= 2;\n\n\tpar->SavageWaitFifo(par, size + 5);\n\tBCI_SEND(cmd);\n\tBCI_SEND(BCI_CLIP_LR(image->dx, image->dx + image->width - 1));\n\tBCI_SEND(fg);\n\tBCI_SEND(bg);\n\tBCI_SEND(BCI_X_Y(image->dx, image->dy));\n\tBCI_SEND(BCI_W_H(width, image->height));\n\tfor (i = 0; i < size; i++)\n\t\tBCI_SEND(src[i]);\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}