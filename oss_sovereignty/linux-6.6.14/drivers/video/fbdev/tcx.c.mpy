{
  "module_name": "tcx.c",
  "hash_id": "fcbc4ba2c295930196e791b5407be54b9772f3cb506e83030b5a5ac7e4ff5902",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/tcx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/fb.h>\n#include <linux/mm.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <asm/io.h>\n#include <asm/fbio.h>\n\n#include \"sbuslib.h\"\n\n \n\nstatic int tcx_setcolreg(unsigned, unsigned, unsigned, unsigned,\n\t\t\t unsigned, struct fb_info *);\nstatic int tcx_blank(int, struct fb_info *);\n\nstatic int tcx_mmap(struct fb_info *, struct vm_area_struct *);\nstatic int tcx_ioctl(struct fb_info *, unsigned int, unsigned long);\nstatic int tcx_pan_display(struct fb_var_screeninfo *, struct fb_info *);\n\n \n\nstatic const struct fb_ops tcx_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_setcolreg\t\t= tcx_setcolreg,\n\t.fb_blank\t\t= tcx_blank,\n\t.fb_pan_display\t\t= tcx_pan_display,\n\t.fb_fillrect\t\t= cfb_fillrect,\n\t.fb_copyarea\t\t= cfb_copyarea,\n\t.fb_imageblit\t\t= cfb_imageblit,\n\t.fb_mmap\t\t= tcx_mmap,\n\t.fb_ioctl\t\t= tcx_ioctl,\n#ifdef CONFIG_COMPAT\n\t.fb_compat_ioctl\t= sbusfb_compat_ioctl,\n#endif\n};\n\n \n#define TCX_THC_MISC_REV_SHIFT       16\n#define TCX_THC_MISC_REV_MASK        15\n#define TCX_THC_MISC_VSYNC_DIS       (1 << 25)\n#define TCX_THC_MISC_HSYNC_DIS       (1 << 24)\n#define TCX_THC_MISC_RESET           (1 << 12)\n#define TCX_THC_MISC_VIDEO           (1 << 10)\n#define TCX_THC_MISC_SYNC            (1 << 9)\n#define TCX_THC_MISC_VSYNC           (1 << 8)\n#define TCX_THC_MISC_SYNC_ENAB       (1 << 7)\n#define TCX_THC_MISC_CURS_RES        (1 << 6)\n#define TCX_THC_MISC_INT_ENAB        (1 << 5)\n#define TCX_THC_MISC_INT             (1 << 4)\n#define TCX_THC_MISC_INIT            0x9f\n#define TCX_THC_REV_REV_SHIFT        20\n#define TCX_THC_REV_REV_MASK         15\n#define TCX_THC_REV_MINREV_SHIFT     28\n#define TCX_THC_REV_MINREV_MASK      15\n\n \nstruct tcx_tec {\n\tu32 tec_matrix;\n\tu32 tec_clip;\n\tu32 tec_vdc;\n};\n\nstruct tcx_thc {\n\tu32 thc_rev;\n\tu32 thc_pad0[511];\n\tu32 thc_hs;\t\t \n\tu32 thc_hsdvs;\n\tu32 thc_hd;\n\tu32 thc_vs;\t\t \n\tu32 thc_vd;\n\tu32 thc_refresh;\n\tu32 thc_misc;\n\tu32 thc_pad1[56];\n\tu32 thc_cursxy;\t \n\tu32 thc_cursmask[32];\t \n\tu32 thc_cursbits[32];\t \n};\n\nstruct bt_regs {\n\tu32 addr;\n\tu32 color_map;\n\tu32 control;\n\tu32 cursor;\n};\n\n#define TCX_MMAP_ENTRIES 14\n\nstruct tcx_par {\n\tspinlock_t\t\tlock;\n\tstruct bt_regs\t\t__iomem *bt;\n\tstruct tcx_thc\t\t__iomem *thc;\n\tstruct tcx_tec\t\t__iomem *tec;\n\tu32\t\t\t__iomem *cplane;\n\n\tu32\t\t\tflags;\n#define TCX_FLAG_BLANKED\t0x00000001\n\n\tunsigned long\t\twhich_io;\n\n\tstruct sbus_mmap_map\tmmap_map[TCX_MMAP_ENTRIES];\n\tint\t\t\tlowdepth;\n};\n\n \nstatic void __tcx_set_control_plane(struct fb_info *info)\n{\n\tstruct tcx_par *par = info->par;\n\tu32 __iomem *p, *pend;\n\n\tif (par->lowdepth)\n\t\treturn;\n\n\tp = par->cplane;\n\tif (p == NULL)\n\t\treturn;\n\tfor (pend = p + info->fix.smem_len; p < pend; p++) {\n\t\tu32 tmp = sbus_readl(p);\n\n\t\ttmp &= 0xffffff;\n\t\tsbus_writel(tmp, p);\n\t}\n}\n\nstatic void tcx_reset(struct fb_info *info)\n{\n\tstruct tcx_par *par = (struct tcx_par *) info->par;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\t__tcx_set_control_plane(info);\n\tspin_unlock_irqrestore(&par->lock, flags);\n}\n\nstatic int tcx_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\ttcx_reset(info);\n\treturn 0;\n}\n\n \nstatic int tcx_setcolreg(unsigned regno,\n\t\t\t unsigned red, unsigned green, unsigned blue,\n\t\t\t unsigned transp, struct fb_info *info)\n{\n\tstruct tcx_par *par = (struct tcx_par *) info->par;\n\tstruct bt_regs __iomem *bt = par->bt;\n\tunsigned long flags;\n\n\tif (regno >= 256)\n\t\treturn 1;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tsbus_writel(regno << 24, &bt->addr);\n\tsbus_writel(red << 24, &bt->color_map);\n\tsbus_writel(green << 24, &bt->color_map);\n\tsbus_writel(blue << 24, &bt->color_map);\n\n\tspin_unlock_irqrestore(&par->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int\ntcx_blank(int blank, struct fb_info *info)\n{\n\tstruct tcx_par *par = (struct tcx_par *) info->par;\n\tstruct tcx_thc __iomem *thc = par->thc;\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tval = sbus_readl(&thc->thc_misc);\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:  \n\t\tval &= ~(TCX_THC_MISC_VSYNC_DIS |\n\t\t\t TCX_THC_MISC_HSYNC_DIS);\n\t\tval |= TCX_THC_MISC_VIDEO;\n\t\tpar->flags &= ~TCX_FLAG_BLANKED;\n\t\tbreak;\n\n\tcase FB_BLANK_NORMAL:  \n\t\tval &= ~TCX_THC_MISC_VIDEO;\n\t\tpar->flags |= TCX_FLAG_BLANKED;\n\t\tbreak;\n\n\tcase FB_BLANK_VSYNC_SUSPEND:  \n\t\tval |= TCX_THC_MISC_VSYNC_DIS;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:  \n\t\tval |= TCX_THC_MISC_HSYNC_DIS;\n\t\tbreak;\n\n\tcase FB_BLANK_POWERDOWN:  \n\t\tbreak;\n\t}\n\n\tsbus_writel(val, &thc->thc_misc);\n\n\tspin_unlock_irqrestore(&par->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct sbus_mmap_map __tcx_mmap_map[TCX_MMAP_ENTRIES] = {\n\t{\n\t\t.voff\t= TCX_RAM8BIT,\n\t\t.size\t= SBUS_MMAP_FBSIZE(1)\n\t},\n\t{\n\t\t.voff\t= TCX_RAM24BIT,\n\t\t.size\t= SBUS_MMAP_FBSIZE(4)\n\t},\n\t{\n\t\t.voff\t= TCX_UNK3,\n\t\t.size\t= SBUS_MMAP_FBSIZE(8)\n\t},\n\t{\n\t\t.voff\t= TCX_UNK4,\n\t\t.size\t= SBUS_MMAP_FBSIZE(8)\n\t},\n\t{\n\t\t.voff\t= TCX_CONTROLPLANE,\n\t\t.size\t= SBUS_MMAP_FBSIZE(4)\n\t},\n\t{\n\t\t.voff\t= TCX_UNK6,\n\t\t.size\t= SBUS_MMAP_FBSIZE(8)\n\t},\n\t{\n\t\t.voff\t= TCX_UNK7,\n\t\t.size\t= SBUS_MMAP_FBSIZE(8)\n\t},\n\t{\n\t\t.voff\t= TCX_TEC,\n\t\t.size\t= PAGE_SIZE\n\t},\n\t{\n\t\t.voff\t= TCX_BTREGS,\n\t\t.size\t= PAGE_SIZE\n\t},\n\t{\n\t\t.voff\t= TCX_THC,\n\t\t.size\t= PAGE_SIZE\n\t},\n\t{\n\t\t.voff\t= TCX_DHC,\n\t\t.size\t= PAGE_SIZE\n\t},\n\t{\n\t\t.voff\t= TCX_ALT,\n\t\t.size\t= PAGE_SIZE\n\t},\n\t{\n\t\t.voff\t= TCX_UNK2,\n\t\t.size\t= 0x20000\n\t},\n\t{ .size = 0 }\n};\n\nstatic int tcx_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct tcx_par *par = (struct tcx_par *)info->par;\n\n\treturn sbusfb_mmap_helper(par->mmap_map,\n\t\t\t\t  info->fix.smem_start, info->fix.smem_len,\n\t\t\t\t  par->which_io, vma);\n}\n\nstatic int tcx_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t     unsigned long arg)\n{\n\tstruct tcx_par *par = (struct tcx_par *) info->par;\n\n\treturn sbusfb_ioctl_helper(cmd, arg, info,\n\t\t\t\t   FBTYPE_TCXCOLOR,\n\t\t\t\t   (par->lowdepth ? 8 : 24),\n\t\t\t\t   info->fix.smem_len);\n}\n\n \n\nstatic void\ntcx_init_fix(struct fb_info *info, int linebytes)\n{\n\tstruct tcx_par *par = (struct tcx_par *)info->par;\n\tconst char *tcx_name;\n\n\tif (par->lowdepth)\n\t\ttcx_name = \"TCX8\";\n\telse\n\t\ttcx_name = \"TCX24\";\n\n\tstrscpy(info->fix.id, tcx_name, sizeof(info->fix.id));\n\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\n\tinfo->fix.line_length = linebytes;\n\n\tinfo->fix.accel = FB_ACCEL_SUN_TCX;\n}\n\nstatic void tcx_unmap_regs(struct platform_device *op, struct fb_info *info,\n\t\t\t   struct tcx_par *par)\n{\n\tif (par->tec)\n\t\tof_iounmap(&op->resource[7],\n\t\t\t   par->tec, sizeof(struct tcx_tec));\n\tif (par->thc)\n\t\tof_iounmap(&op->resource[9],\n\t\t\t   par->thc, sizeof(struct tcx_thc));\n\tif (par->bt)\n\t\tof_iounmap(&op->resource[8],\n\t\t\t   par->bt, sizeof(struct bt_regs));\n\tif (par->cplane)\n\t\tof_iounmap(&op->resource[4],\n\t\t\t   par->cplane, info->fix.smem_len * sizeof(u32));\n\tif (info->screen_base)\n\t\tof_iounmap(&op->resource[0],\n\t\t\t   info->screen_base, info->fix.smem_len);\n}\n\nstatic int tcx_probe(struct platform_device *op)\n{\n\tstruct device_node *dp = op->dev.of_node;\n\tstruct fb_info *info;\n\tstruct tcx_par *par;\n\tint linebytes, i, err;\n\n\tinfo = framebuffer_alloc(sizeof(struct tcx_par), &op->dev);\n\n\terr = -ENOMEM;\n\tif (!info)\n\t\tgoto out_err;\n\tpar = info->par;\n\n\tspin_lock_init(&par->lock);\n\n\tpar->lowdepth = of_property_read_bool(dp, \"tcx-8-bit\");\n\n\tsbusfb_fill_var(&info->var, dp, 8);\n\tinfo->var.red.length = 8;\n\tinfo->var.green.length = 8;\n\tinfo->var.blue.length = 8;\n\n\tlinebytes = of_getintprop_default(dp, \"linebytes\",\n\t\t\t\t\t  info->var.xres);\n\tinfo->fix.smem_len = PAGE_ALIGN(linebytes * info->var.yres);\n\n\tpar->tec = of_ioremap(&op->resource[7], 0,\n\t\t\t\t  sizeof(struct tcx_tec), \"tcx tec\");\n\tpar->thc = of_ioremap(&op->resource[9], 0,\n\t\t\t\t  sizeof(struct tcx_thc), \"tcx thc\");\n\tpar->bt = of_ioremap(&op->resource[8], 0,\n\t\t\t\t sizeof(struct bt_regs), \"tcx dac\");\n\tinfo->screen_base = of_ioremap(&op->resource[0], 0,\n\t\t\t\t\t   info->fix.smem_len, \"tcx ram\");\n\tif (!par->tec || !par->thc ||\n\t    !par->bt || !info->screen_base)\n\t\tgoto out_unmap_regs;\n\n\tmemcpy(&par->mmap_map, &__tcx_mmap_map, sizeof(par->mmap_map));\n\tif (!par->lowdepth) {\n\t\tpar->cplane = of_ioremap(&op->resource[4], 0,\n\t\t\t\t\t     info->fix.smem_len * sizeof(u32),\n\t\t\t\t\t     \"tcx cplane\");\n\t\tif (!par->cplane)\n\t\t\tgoto out_unmap_regs;\n\t} else {\n\t\tpar->mmap_map[1].size = SBUS_MMAP_EMPTY;\n\t\tpar->mmap_map[4].size = SBUS_MMAP_EMPTY;\n\t\tpar->mmap_map[5].size = SBUS_MMAP_EMPTY;\n\t\tpar->mmap_map[6].size = SBUS_MMAP_EMPTY;\n\t}\n\n\tinfo->fix.smem_start = op->resource[0].start;\n\tpar->which_io = op->resource[0].flags & IORESOURCE_BITS;\n\n\tfor (i = 0; i < TCX_MMAP_ENTRIES; i++) {\n\t\tint j;\n\n\t\tswitch (i) {\n\t\tcase 10:\n\t\t\tj = 12;\n\t\t\tbreak;\n\n\t\tcase 11: case 12:\n\t\t\tj = i - 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tj = i;\n\t\t\tbreak;\n\t\t}\n\t\tpar->mmap_map[i].poff = op->resource[j].start;\n\t}\n\n\tinfo->fbops = &tcx_ops;\n\n\t \n\tsbus_writel(0x04 << 24, &par->bt->addr);          \n\tsbus_writel(0xff << 24, &par->bt->control);\n\tsbus_writel(0x05 << 24, &par->bt->addr);\n\tsbus_writel(0x00 << 24, &par->bt->control);\n\tsbus_writel(0x06 << 24, &par->bt->addr);          \n\tsbus_writel(0x73 << 24, &par->bt->control);\n\tsbus_writel(0x07 << 24, &par->bt->addr);\n\tsbus_writel(0x00 << 24, &par->bt->control);\n\n\ttcx_reset(info);\n\n\ttcx_blank(FB_BLANK_UNBLANK, info);\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0))\n\t\tgoto out_unmap_regs;\n\n\tfb_set_cmap(&info->cmap, info);\n\ttcx_init_fix(info, linebytes);\n\n\terr = register_framebuffer(info);\n\tif (err < 0)\n\t\tgoto out_dealloc_cmap;\n\n\tdev_set_drvdata(&op->dev, info);\n\n\tprintk(KERN_INFO \"%pOF: TCX at %lx:%lx, %s\\n\",\n\t       dp,\n\t       par->which_io,\n\t       info->fix.smem_start,\n\t       par->lowdepth ? \"8-bit only\" : \"24-bit depth\");\n\n\treturn 0;\n\nout_dealloc_cmap:\n\tfb_dealloc_cmap(&info->cmap);\n\nout_unmap_regs:\n\ttcx_unmap_regs(op, info, par);\n\tframebuffer_release(info);\n\nout_err:\n\treturn err;\n}\n\nstatic void tcx_remove(struct platform_device *op)\n{\n\tstruct fb_info *info = dev_get_drvdata(&op->dev);\n\tstruct tcx_par *par = info->par;\n\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\n\ttcx_unmap_regs(op, info, par);\n\n\tframebuffer_release(info);\n}\n\nstatic const struct of_device_id tcx_match[] = {\n\t{\n\t\t.name = \"SUNW,tcx\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tcx_match);\n\nstatic struct platform_driver tcx_driver = {\n\t.driver = {\n\t\t.name = \"tcx\",\n\t\t.of_match_table = tcx_match,\n\t},\n\t.probe\t\t= tcx_probe,\n\t.remove_new\t= tcx_remove,\n};\n\nstatic int __init tcx_init(void)\n{\n\tif (fb_get_options(\"tcxfb\", NULL))\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&tcx_driver);\n}\n\nstatic void __exit tcx_exit(void)\n{\n\tplatform_driver_unregister(&tcx_driver);\n}\n\nmodule_init(tcx_init);\nmodule_exit(tcx_exit);\n\nMODULE_DESCRIPTION(\"framebuffer driver for TCX chipsets\");\nMODULE_AUTHOR(\"David S. Miller <davem@davemloft.net>\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}