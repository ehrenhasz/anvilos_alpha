{
  "module_name": "efifb.c",
  "hash_id": "b93b1f4f8ef46461105bebce58a7eaec2ad6035c9c3614784d171fc1526c1c09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/efifb.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/kernel.h>\n#include <linux/efi.h>\n#include <linux/efi-bgrt.h>\n#include <linux/errno.h>\n#include <linux/fb.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/screen_info.h>\n#include <linux/pm_runtime.h>\n#include <video/vga.h>\n#include <asm/efi.h>\n#include <drm/drm_utils.h>  \n#include <drm/drm_connector.h>   \n\nstruct bmp_file_header {\n\tu16 id;\n\tu32 file_size;\n\tu32 reserved;\n\tu32 bitmap_offset;\n} __packed;\n\nstruct bmp_dib_header {\n\tu32 dib_header_size;\n\ts32 width;\n\ts32 height;\n\tu16 planes;\n\tu16 bpp;\n\tu32 compression;\n\tu32 bitmap_size;\n\tu32 horz_resolution;\n\tu32 vert_resolution;\n\tu32 colors_used;\n\tu32 colors_important;\n} __packed;\n\nstatic bool use_bgrt = true;\nstatic bool request_mem_succeeded = false;\nstatic u64 mem_flags = EFI_MEMORY_WC | EFI_MEMORY_UC;\n\nstatic struct pci_dev *efifb_pci_dev;\t \n\nstruct efifb_par {\n\tu32 pseudo_palette[16];\n\tresource_size_t base;\n\tresource_size_t size;\n};\n\nstatic struct fb_var_screeninfo efifb_defined = {\n\t.activate\t\t= FB_ACTIVATE_NOW,\n\t.height\t\t\t= -1,\n\t.width\t\t\t= -1,\n\t.right_margin\t\t= 32,\n\t.upper_margin\t\t= 16,\n\t.lower_margin\t\t= 4,\n\t.vsync_len\t\t= 4,\n\t.vmode\t\t\t= FB_VMODE_NONINTERLACED,\n};\n\nstatic struct fb_fix_screeninfo efifb_fix = {\n\t.id\t\t\t= \"EFI VGA\",\n\t.type\t\t\t= FB_TYPE_PACKED_PIXELS,\n\t.accel\t\t\t= FB_ACCEL_NONE,\n\t.visual\t\t\t= FB_VISUAL_TRUECOLOR,\n};\n\nstatic int efifb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t   unsigned blue, unsigned transp,\n\t\t\t   struct fb_info *info)\n{\n\t \n\n\tif (regno >= info->cmap.len)\n\t\treturn 1;\n\n\tif (regno < 16) {\n\t\tred   >>= 16 - info->var.red.length;\n\t\tgreen >>= 16 - info->var.green.length;\n\t\tblue  >>= 16 - info->var.blue.length;\n\t\t((u32 *)(info->pseudo_palette))[regno] =\n\t\t\t(red   << info->var.red.offset)   |\n\t\t\t(green << info->var.green.offset) |\n\t\t\t(blue  << info->var.blue.offset);\n\t}\n\treturn 0;\n}\n\n \n#if defined CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER && \\\n    defined CONFIG_ACPI_BGRT\nstatic void efifb_copy_bmp(u8 *src, u32 *dst, int width, struct screen_info *si)\n{\n\tu8 r, g, b;\n\n\twhile (width--) {\n\t\tb = *src++;\n\t\tg = *src++;\n\t\tr = *src++;\n\t\t*dst++ = (r << si->red_pos)   |\n\t\t\t (g << si->green_pos) |\n\t\t\t (b << si->blue_pos);\n\t}\n}\n\n#ifdef CONFIG_X86\n \nstatic bool efifb_bgrt_sanity_check(struct screen_info *si, u32 bmp_width)\n{\n\t \n\tu32 expected_xoffset = (si->lfb_width - bmp_width) / 2;\n\n\treturn bgrt_tab.image_offset_x == expected_xoffset;\n}\n#else\nstatic bool efifb_bgrt_sanity_check(struct screen_info *si, u32 bmp_width)\n{\n\treturn true;\n}\n#endif\n\nstatic void efifb_show_boot_graphics(struct fb_info *info)\n{\n\tu32 bmp_width, bmp_height, bmp_pitch, dst_x, y, src_y;\n\tstruct screen_info *si = &screen_info;\n\tstruct bmp_file_header *file_header;\n\tstruct bmp_dib_header *dib_header;\n\tvoid *bgrt_image = NULL;\n\tu8 *dst = info->screen_base;\n\n\tif (!use_bgrt)\n\t\treturn;\n\n\tif (!bgrt_tab.image_address) {\n\t\tpr_info(\"efifb: No BGRT, not showing boot graphics\\n\");\n\t\treturn;\n\t}\n\n\tif (bgrt_tab.status & 0x06) {\n\t\tpr_info(\"efifb: BGRT rotation bits set, not showing boot graphics\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (console_loglevel > CONSOLE_LOGLEVEL_QUIET)\n\t\treturn;\n\n\t \n\n\tif (si->lfb_depth != 32) {\n\t\tpr_info(\"efifb: not 32 bits, not showing boot graphics\\n\");\n\t\treturn;\n\t}\n\n\tbgrt_image = memremap(bgrt_tab.image_address, bgrt_image_size,\n\t\t\t      MEMREMAP_WB);\n\tif (!bgrt_image) {\n\t\tpr_warn(\"efifb: Ignoring BGRT: failed to map image memory\\n\");\n\t\treturn;\n\t}\n\n\tif (bgrt_image_size < (sizeof(*file_header) + sizeof(*dib_header)))\n\t\tgoto error;\n\n\tfile_header = bgrt_image;\n\tif (file_header->id != 0x4d42 || file_header->reserved != 0)\n\t\tgoto error;\n\n\tdib_header = bgrt_image + sizeof(*file_header);\n\tif (dib_header->dib_header_size != 40 || dib_header->width < 0 ||\n\t    dib_header->planes != 1 || dib_header->bpp != 24 ||\n\t    dib_header->compression != 0)\n\t\tgoto error;\n\n\tbmp_width = dib_header->width;\n\tbmp_height = abs(dib_header->height);\n\tbmp_pitch = round_up(3 * bmp_width, 4);\n\n\tif ((file_header->bitmap_offset + bmp_pitch * bmp_height) >\n\t\t\t\tbgrt_image_size)\n\t\tgoto error;\n\n\tif ((bgrt_tab.image_offset_x + bmp_width) > si->lfb_width ||\n\t    (bgrt_tab.image_offset_y + bmp_height) > si->lfb_height)\n\t\tgoto error;\n\n\tif (!efifb_bgrt_sanity_check(si, bmp_width))\n\t\tgoto error;\n\n\tpr_info(\"efifb: showing boot graphics\\n\");\n\n\tfor (y = 0; y < si->lfb_height; y++, dst += si->lfb_linelength) {\n\t\t \n\t\tif (y < bgrt_tab.image_offset_y ||\n\t\t    y >= (bgrt_tab.image_offset_y + bmp_height)) {\n\t\t\tmemset(dst, 0, 4 * si->lfb_width);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc_y = y - bgrt_tab.image_offset_y;\n\t\t \n\t\tif (dib_header->height > 0)\n\t\t\tsrc_y = (bmp_height - 1) - src_y;\n\n\t\tmemset(dst, 0, bgrt_tab.image_offset_x * 4);\n\t\tdst_x = bgrt_tab.image_offset_x;\n\t\tefifb_copy_bmp(bgrt_image + file_header->bitmap_offset +\n\t\t\t\t\t    src_y * bmp_pitch,\n\t\t\t       (u32 *)dst + dst_x, bmp_width, si);\n\t\tdst_x += bmp_width;\n\t\tmemset((u32 *)dst + dst_x, 0, (si->lfb_width - dst_x) * 4);\n\t}\n\n\tmemunmap(bgrt_image);\n\treturn;\n\nerror:\n\tmemunmap(bgrt_image);\n\tpr_warn(\"efifb: Ignoring BGRT: unexpected or invalid BMP data\\n\");\n}\n#else\nstatic inline void efifb_show_boot_graphics(struct fb_info *info) {}\n#endif\n\n \nstatic void efifb_destroy(struct fb_info *info)\n{\n\tstruct efifb_par *par = info->par;\n\n\tif (efifb_pci_dev)\n\t\tpm_runtime_put(&efifb_pci_dev->dev);\n\n\tif (info->screen_base) {\n\t\tif (mem_flags & (EFI_MEMORY_UC | EFI_MEMORY_WC))\n\t\t\tiounmap(info->screen_base);\n\t\telse\n\t\t\tmemunmap(info->screen_base);\n\t}\n\n\tif (request_mem_succeeded)\n\t\trelease_mem_region(par->base, par->size);\n\tfb_dealloc_cmap(&info->cmap);\n\n\tframebuffer_release(info);\n}\n\nstatic const struct fb_ops efifb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_destroy\t= efifb_destroy,\n\t.fb_setcolreg\t= efifb_setcolreg,\n};\n\nstatic int efifb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (options && *options) {\n\t\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\t\tif (!*this_opt) continue;\n\n\t\t\tefifb_setup_from_dmi(&screen_info, this_opt);\n\n\t\t\tif (!strncmp(this_opt, \"base:\", 5))\n\t\t\t\tscreen_info.lfb_base = simple_strtoul(this_opt+5, NULL, 0);\n\t\t\telse if (!strncmp(this_opt, \"stride:\", 7))\n\t\t\t\tscreen_info.lfb_linelength = simple_strtoul(this_opt+7, NULL, 0) * 4;\n\t\t\telse if (!strncmp(this_opt, \"height:\", 7))\n\t\t\t\tscreen_info.lfb_height = simple_strtoul(this_opt+7, NULL, 0);\n\t\t\telse if (!strncmp(this_opt, \"width:\", 6))\n\t\t\t\tscreen_info.lfb_width = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\telse if (!strcmp(this_opt, \"nowc\"))\n\t\t\t\tmem_flags &= ~EFI_MEMORY_WC;\n\t\t\telse if (!strcmp(this_opt, \"nobgrt\"))\n\t\t\t\tuse_bgrt = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool fb_base_is_valid(void)\n{\n\tif (screen_info.lfb_base)\n\t\treturn true;\n\n\tif (!(screen_info.capabilities & VIDEO_CAPABILITY_64BIT_BASE))\n\t\treturn false;\n\n\tif (screen_info.ext_lfb_base)\n\t\treturn true;\n\n\treturn false;\n}\n\n#define efifb_attr_decl(name, fmt)\t\t\t\t\t\\\nstatic ssize_t name##_show(struct device *dev,\t\t\t\t\\\n\t\t\t   struct device_attribute *attr,\t\t\\\n\t\t\t   char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, fmt \"\\n\", (screen_info.lfb_##name));\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name)\n\nefifb_attr_decl(base, \"0x%x\");\nefifb_attr_decl(linelength, \"%u\");\nefifb_attr_decl(height, \"%u\");\nefifb_attr_decl(width, \"%u\");\nefifb_attr_decl(depth, \"%u\");\n\nstatic struct attribute *efifb_attrs[] = {\n\t&dev_attr_base.attr,\n\t&dev_attr_linelength.attr,\n\t&dev_attr_width.attr,\n\t&dev_attr_height.attr,\n\t&dev_attr_depth.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(efifb);\n\nstatic bool pci_dev_disabled;\t \n\nstatic struct resource *bar_resource;\nstatic u64 bar_offset;\n\nstatic int efifb_probe(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\tstruct efifb_par *par;\n\tint err, orientation;\n\tunsigned int size_vmode;\n\tunsigned int size_remap;\n\tunsigned int size_total;\n\tchar *option = NULL;\n\tefi_memory_desc_t md;\n\n\tif (screen_info.orig_video_isVGA != VIDEO_TYPE_EFI || pci_dev_disabled)\n\t\treturn -ENODEV;\n\n\tif (fb_get_options(\"efifb\", &option))\n\t\treturn -ENODEV;\n\tefifb_setup(option);\n\n\t \n\tif (!screen_info.lfb_linelength)\n\t\treturn -ENODEV;\n\n\tif (!screen_info.lfb_depth)\n\t\tscreen_info.lfb_depth = 32;\n\tif (!screen_info.pages)\n\t\tscreen_info.pages = 1;\n\tif (!fb_base_is_valid()) {\n\t\tprintk(KERN_DEBUG \"efifb: invalid framebuffer address\\n\");\n\t\treturn -ENODEV;\n\t}\n\tprintk(KERN_INFO \"efifb: probing for efifb\\n\");\n\n\t \n\tif (!screen_info.blue_size) {\n\t\tscreen_info.blue_size = 8;\n\t\tscreen_info.blue_pos = 0;\n\t\tscreen_info.green_size = 8;\n\t\tscreen_info.green_pos = 8;\n\t\tscreen_info.red_size = 8;\n\t\tscreen_info.red_pos = 16;\n\t\tscreen_info.rsvd_size = 8;\n\t\tscreen_info.rsvd_pos = 24;\n\t}\n\n\tefifb_fix.smem_start = screen_info.lfb_base;\n\n\tif (screen_info.capabilities & VIDEO_CAPABILITY_64BIT_BASE) {\n\t\tu64 ext_lfb_base;\n\n\t\text_lfb_base = (u64)(unsigned long)screen_info.ext_lfb_base << 32;\n\t\tefifb_fix.smem_start |= ext_lfb_base;\n\t}\n\n\tif (bar_resource &&\n\t    bar_resource->start + bar_offset != efifb_fix.smem_start) {\n\t\tdev_info(&efifb_pci_dev->dev,\n\t\t\t \"BAR has moved, updating efifb address\\n\");\n\t\tefifb_fix.smem_start = bar_resource->start + bar_offset;\n\t}\n\n\tefifb_defined.bits_per_pixel = screen_info.lfb_depth;\n\tefifb_defined.xres = screen_info.lfb_width;\n\tefifb_defined.yres = screen_info.lfb_height;\n\tefifb_fix.line_length = screen_info.lfb_linelength;\n\n\t \n\tsize_vmode = efifb_defined.yres * efifb_fix.line_length;\n\n\t \n\tsize_total = screen_info.lfb_size;\n\tif (size_total < size_vmode)\n\t\tsize_total = size_vmode;\n\n\t \n\tsize_remap  = size_vmode * 2;\n\tif (size_remap > size_total)\n\t\tsize_remap = size_total;\n\tif (size_remap % PAGE_SIZE)\n\t\tsize_remap += PAGE_SIZE - (size_remap % PAGE_SIZE);\n\tefifb_fix.smem_len = size_remap;\n\n\tif (request_mem_region(efifb_fix.smem_start, size_remap, \"efifb\")) {\n\t\trequest_mem_succeeded = true;\n\t} else {\n\t\t \n\t\tpr_warn(\"efifb: cannot reserve video memory at 0x%lx\\n\",\n\t\t\tefifb_fix.smem_start);\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(*par), &dev->dev);\n\tif (!info) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release_mem;\n\t}\n\tplatform_set_drvdata(dev, info);\n\tpar = info->par;\n\tinfo->pseudo_palette = par->pseudo_palette;\n\n\tpar->base = efifb_fix.smem_start;\n\tpar->size = size_remap;\n\n\tif (efi_enabled(EFI_MEMMAP) &&\n\t    !efi_mem_desc_lookup(efifb_fix.smem_start, &md)) {\n\t\tif ((efifb_fix.smem_start + efifb_fix.smem_len) >\n\t\t    (md.phys_addr + (md.num_pages << EFI_PAGE_SHIFT))) {\n\t\t\tpr_err(\"efifb: video memory @ 0x%lx spans multiple EFI memory regions\\n\",\n\t\t\t       efifb_fix.smem_start);\n\t\t\terr = -EIO;\n\t\t\tgoto err_release_fb;\n\t\t}\n\t\t \n\t\tmd.attribute &= EFI_MEMORY_UC | EFI_MEMORY_WC |\n\t\t\t\tEFI_MEMORY_WT | EFI_MEMORY_WB;\n\t\tif (md.attribute) {\n\t\t\tmem_flags |= EFI_MEMORY_WT | EFI_MEMORY_WB;\n\t\t\tmem_flags &= md.attribute;\n\t\t}\n\t}\n\tif (mem_flags & EFI_MEMORY_WC)\n\t\tinfo->screen_base = ioremap_wc(efifb_fix.smem_start,\n\t\t\t\t\t       efifb_fix.smem_len);\n\telse if (mem_flags & EFI_MEMORY_UC)\n\t\tinfo->screen_base = ioremap(efifb_fix.smem_start,\n\t\t\t\t\t    efifb_fix.smem_len);\n\telse if (mem_flags & EFI_MEMORY_WT)\n\t\tinfo->screen_base = memremap(efifb_fix.smem_start,\n\t\t\t\t\t     efifb_fix.smem_len, MEMREMAP_WT);\n\telse if (mem_flags & EFI_MEMORY_WB)\n\t\tinfo->screen_base = memremap(efifb_fix.smem_start,\n\t\t\t\t\t     efifb_fix.smem_len, MEMREMAP_WB);\n\tif (!info->screen_base) {\n\t\tpr_err(\"efifb: abort, cannot remap video memory 0x%x @ 0x%lx\\n\",\n\t\t\tefifb_fix.smem_len, efifb_fix.smem_start);\n\t\terr = -EIO;\n\t\tgoto err_release_fb;\n\t}\n\n\tefifb_show_boot_graphics(info);\n\n\tpr_info(\"efifb: framebuffer at 0x%lx, using %dk, total %dk\\n\",\n\t       efifb_fix.smem_start, size_remap/1024, size_total/1024);\n\tpr_info(\"efifb: mode is %dx%dx%d, linelength=%d, pages=%d\\n\",\n\t       efifb_defined.xres, efifb_defined.yres,\n\t       efifb_defined.bits_per_pixel, efifb_fix.line_length,\n\t       screen_info.pages);\n\n\tefifb_defined.xres_virtual = efifb_defined.xres;\n\tefifb_defined.yres_virtual = efifb_fix.smem_len /\n\t\t\t\t\tefifb_fix.line_length;\n\tpr_info(\"efifb: scrolling: redraw\\n\");\n\tefifb_defined.yres_virtual = efifb_defined.yres;\n\n\t \n\tefifb_defined.pixclock     = 10000000 / efifb_defined.xres *\n\t\t\t\t\t1000 / efifb_defined.yres;\n\tefifb_defined.left_margin  = (efifb_defined.xres / 8) & 0xf8;\n\tefifb_defined.hsync_len    = (efifb_defined.xres / 8) & 0xf8;\n\n\tefifb_defined.red.offset    = screen_info.red_pos;\n\tefifb_defined.red.length    = screen_info.red_size;\n\tefifb_defined.green.offset  = screen_info.green_pos;\n\tefifb_defined.green.length  = screen_info.green_size;\n\tefifb_defined.blue.offset   = screen_info.blue_pos;\n\tefifb_defined.blue.length   = screen_info.blue_size;\n\tefifb_defined.transp.offset = screen_info.rsvd_pos;\n\tefifb_defined.transp.length = screen_info.rsvd_size;\n\n\tpr_info(\"efifb: %s: \"\n\t       \"size=%d:%d:%d:%d, shift=%d:%d:%d:%d\\n\",\n\t       \"Truecolor\",\n\t       screen_info.rsvd_size,\n\t       screen_info.red_size,\n\t       screen_info.green_size,\n\t       screen_info.blue_size,\n\t       screen_info.rsvd_pos,\n\t       screen_info.red_pos,\n\t       screen_info.green_pos,\n\t       screen_info.blue_pos);\n\n\tefifb_fix.ypanstep  = 0;\n\tefifb_fix.ywrapstep = 0;\n\n\tinfo->fbops = &efifb_ops;\n\tinfo->var = efifb_defined;\n\tinfo->fix = efifb_fix;\n\n\torientation = drm_get_panel_orientation_quirk(efifb_defined.xres,\n\t\t\t\t\t\t      efifb_defined.yres);\n\tswitch (orientation) {\n\tdefault:\n\t\tinfo->fbcon_rotate_hint = FB_ROTATE_UR;\n\t\tbreak;\n\tcase DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP:\n\t\tinfo->fbcon_rotate_hint = FB_ROTATE_UD;\n\t\tbreak;\n\tcase DRM_MODE_PANEL_ORIENTATION_LEFT_UP:\n\t\tinfo->fbcon_rotate_hint = FB_ROTATE_CCW;\n\t\tbreak;\n\tcase DRM_MODE_PANEL_ORIENTATION_RIGHT_UP:\n\t\tinfo->fbcon_rotate_hint = FB_ROTATE_CW;\n\t\tbreak;\n\t}\n\n\terr = sysfs_create_groups(&dev->dev.kobj, efifb_groups);\n\tif (err) {\n\t\tpr_err(\"efifb: cannot add sysfs attrs\\n\");\n\t\tgoto err_unmap;\n\t}\n\terr = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (err < 0) {\n\t\tpr_err(\"efifb: cannot allocate colormap\\n\");\n\t\tgoto err_groups;\n\t}\n\n\tif (efifb_pci_dev)\n\t\tWARN_ON(pm_runtime_get_sync(&efifb_pci_dev->dev) < 0);\n\n\terr = devm_aperture_acquire_for_platform_device(dev, par->base, par->size);\n\tif (err) {\n\t\tpr_err(\"efifb: cannot acquire aperture\\n\");\n\t\tgoto err_put_rpm_ref;\n\t}\n\terr = register_framebuffer(info);\n\tif (err < 0) {\n\t\tpr_err(\"efifb: cannot register framebuffer\\n\");\n\t\tgoto err_put_rpm_ref;\n\t}\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\treturn 0;\n\nerr_put_rpm_ref:\n\tif (efifb_pci_dev)\n\t\tpm_runtime_put(&efifb_pci_dev->dev);\n\n\tfb_dealloc_cmap(&info->cmap);\nerr_groups:\n\tsysfs_remove_groups(&dev->dev.kobj, efifb_groups);\nerr_unmap:\n\tif (mem_flags & (EFI_MEMORY_UC | EFI_MEMORY_WC))\n\t\tiounmap(info->screen_base);\n\telse\n\t\tmemunmap(info->screen_base);\nerr_release_fb:\n\tframebuffer_release(info);\nerr_release_mem:\n\tif (request_mem_succeeded)\n\t\trelease_mem_region(efifb_fix.smem_start, size_total);\n\treturn err;\n}\n\nstatic void efifb_remove(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\n\t \n\tunregister_framebuffer(info);\n\tsysfs_remove_groups(&pdev->dev.kobj, efifb_groups);\n}\n\nstatic struct platform_driver efifb_driver = {\n\t.driver = {\n\t\t.name = \"efi-framebuffer\",\n\t},\n\t.probe = efifb_probe,\n\t.remove_new = efifb_remove,\n};\n\nbuiltin_platform_driver(efifb_driver);\n\n#if defined(CONFIG_PCI)\n\nstatic void record_efifb_bar_resource(struct pci_dev *dev, int idx, u64 offset)\n{\n\tu16 word;\n\n\tefifb_pci_dev = dev;\n\n\tpci_read_config_word(dev, PCI_COMMAND, &word);\n\tif (!(word & PCI_COMMAND_MEMORY)) {\n\t\tpci_dev_disabled = true;\n\t\tdev_err(&dev->dev,\n\t\t\t\"BAR %d: assigned to efifb but device is disabled!\\n\",\n\t\t\tidx);\n\t\treturn;\n\t}\n\n\tbar_resource = &dev->resource[idx];\n\tbar_offset = offset;\n\n\tdev_info(&dev->dev, \"BAR %d: assigned to efifb\\n\", idx);\n}\n\nstatic void efifb_fixup_resources(struct pci_dev *dev)\n{\n\tu64 base = screen_info.lfb_base;\n\tu64 size = screen_info.lfb_size;\n\tint i;\n\n\tif (efifb_pci_dev || screen_info.orig_video_isVGA != VIDEO_TYPE_EFI)\n\t\treturn;\n\n\tif (screen_info.capabilities & VIDEO_CAPABILITY_64BIT_BASE)\n\t\tbase |= (u64)screen_info.ext_lfb_base << 32;\n\n\tif (!base)\n\t\treturn;\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tstruct resource *res = &dev->resource[i];\n\n\t\tif (!(res->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\n\t\tif (res->start <= base && res->end >= base + size - 1) {\n\t\t\trecord_efifb_bar_resource(dev, i, base - res->start);\n\t\t\tbreak;\n\t\t}\n\t}\n}\nDECLARE_PCI_FIXUP_CLASS_HEADER(PCI_ANY_ID, PCI_ANY_ID, PCI_BASE_CLASS_DISPLAY,\n\t\t\t       16, efifb_fixup_resources);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}