{
  "module_name": "atmel_lcdfb.c",
  "hash_id": "0ec56cce80d9ff8746a1bb21262bc19812bcae1aa214f9aa795b0e73726fdb5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/atmel_lcdfb.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/backlight.h>\n#include <linux/gfp.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <video/of_videomode.h>\n#include <video/of_display_timing.h>\n#include <linux/regulator/consumer.h>\n#include <video/videomode.h>\n\n#include <video/atmel_lcdc.h>\n\nstruct atmel_lcdfb_config {\n\tbool have_alt_pixclock;\n\tbool have_hozval;\n\tbool have_intensity_bit;\n};\n\n  \nstruct atmel_lcdfb_info {\n\tspinlock_t\t\tlock;\n\tstruct fb_info\t\t*info;\n\tvoid __iomem\t\t*mmio;\n\tint\t\t\tirq_base;\n\tstruct work_struct\ttask;\n\n\tunsigned int\t\tsmem_len;\n\tstruct platform_device\t*pdev;\n\tstruct clk\t\t*bus_clk;\n\tstruct clk\t\t*lcdc_clk;\n\n\tstruct backlight_device\t*backlight;\n\tu8\t\t\tsaved_lcdcon;\n\n\tu32\t\t\tpseudo_palette[16];\n\tbool\t\t\thave_intensity_bit;\n\n\tstruct atmel_lcdfb_pdata pdata;\n\n\tstruct atmel_lcdfb_config *config;\n\tstruct regulator\t*reg_lcd;\n};\n\nstruct atmel_lcdfb_power_ctrl_gpio {\n\tstruct gpio_desc *gpiod;\n\n\tstruct list_head list;\n};\n\n#define lcdc_readl(sinfo, reg)\t\t__raw_readl((sinfo)->mmio+(reg))\n#define lcdc_writel(sinfo, reg, val)\t__raw_writel((val), (sinfo)->mmio+(reg))\n\n \n#define ATMEL_LCDC_CVAL_DEFAULT\t\t0xc8\n#define ATMEL_LCDC_DMA_BURST_LEN\t8\t \n#define ATMEL_LCDC_FIFO_SIZE\t\t512\t \n\nstatic struct atmel_lcdfb_config at91sam9261_config = {\n\t.have_hozval\t\t= true,\n\t.have_intensity_bit\t= true,\n};\n\nstatic struct atmel_lcdfb_config at91sam9263_config = {\n\t.have_intensity_bit\t= true,\n};\n\nstatic struct atmel_lcdfb_config at91sam9g10_config = {\n\t.have_hozval\t\t= true,\n};\n\nstatic struct atmel_lcdfb_config at91sam9g45_config = {\n\t.have_alt_pixclock\t= true,\n};\n\nstatic struct atmel_lcdfb_config at91sam9g45es_config = {\n};\n\nstatic struct atmel_lcdfb_config at91sam9rl_config = {\n\t.have_intensity_bit\t= true,\n};\n\nstatic u32 contrast_ctr = ATMEL_LCDC_PS_DIV8\n\t\t| ATMEL_LCDC_POL_POSITIVE\n\t\t| ATMEL_LCDC_ENA_PWMENABLE;\n\n#ifdef CONFIG_BACKLIGHT_ATMEL_LCDC\n\n \nstatic int atmel_bl_update_status(struct backlight_device *bl)\n{\n\tstruct atmel_lcdfb_info *sinfo = bl_get_data(bl);\n\tint\t\t\tbrightness = backlight_get_brightness(bl);\n\n\tlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, brightness);\n\tif (contrast_ctr & ATMEL_LCDC_POL_POSITIVE)\n\t\tlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR,\n\t\t\tbrightness ? contrast_ctr : 0);\n\telse\n\t\tlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, contrast_ctr);\n\n\treturn 0;\n}\n\nstatic int atmel_bl_get_brightness(struct backlight_device *bl)\n{\n\tstruct atmel_lcdfb_info *sinfo = bl_get_data(bl);\n\n\treturn lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);\n}\n\nstatic const struct backlight_ops atmel_lcdc_bl_ops = {\n\t.update_status = atmel_bl_update_status,\n\t.get_brightness = atmel_bl_get_brightness,\n};\n\nstatic void init_backlight(struct atmel_lcdfb_info *sinfo)\n{\n\tstruct backlight_properties props;\n\tstruct backlight_device\t*bl;\n\n\tif (sinfo->backlight)\n\t\treturn;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = 0xff;\n\tbl = backlight_device_register(\"backlight\", &sinfo->pdev->dev, sinfo,\n\t\t\t\t       &atmel_lcdc_bl_ops, &props);\n\tif (IS_ERR(bl)) {\n\t\tdev_err(&sinfo->pdev->dev, \"error %ld on backlight register\\n\",\n\t\t\t\tPTR_ERR(bl));\n\t\treturn;\n\t}\n\tsinfo->backlight = bl;\n\n\tbl->props.power = FB_BLANK_UNBLANK;\n\tbl->props.fb_blank = FB_BLANK_UNBLANK;\n\tbl->props.brightness = atmel_bl_get_brightness(bl);\n}\n\nstatic void exit_backlight(struct atmel_lcdfb_info *sinfo)\n{\n\tif (!sinfo->backlight)\n\t\treturn;\n\n\tif (sinfo->backlight->ops) {\n\t\tsinfo->backlight->props.power = FB_BLANK_POWERDOWN;\n\t\tsinfo->backlight->ops->update_status(sinfo->backlight);\n\t}\n\tbacklight_device_unregister(sinfo->backlight);\n}\n\n#else\n\nstatic void init_backlight(struct atmel_lcdfb_info *sinfo)\n{\n\tdev_warn(&sinfo->pdev->dev, \"backlight control is not available\\n\");\n}\n\nstatic void exit_backlight(struct atmel_lcdfb_info *sinfo)\n{\n}\n\n#endif\n\nstatic void init_contrast(struct atmel_lcdfb_info *sinfo)\n{\n\tstruct atmel_lcdfb_pdata *pdata = &sinfo->pdata;\n\n\t \n\tif (pdata->lcdcon_pol_negative)\n\t\tcontrast_ctr &= ~(ATMEL_LCDC_POL_POSITIVE);\n\n\t \n\tlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, contrast_ctr);\n\tlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, ATMEL_LCDC_CVAL_DEFAULT);\n\n\tif (pdata->lcdcon_is_backlight)\n\t\tinit_backlight(sinfo);\n}\n\nstatic inline void atmel_lcdfb_power_control(struct atmel_lcdfb_info *sinfo, int on)\n{\n\tint ret;\n\tstruct atmel_lcdfb_pdata *pdata = &sinfo->pdata;\n\n\tif (pdata->atmel_lcdfb_power_control)\n\t\tpdata->atmel_lcdfb_power_control(pdata, on);\n\telse if (sinfo->reg_lcd) {\n\t\tif (on) {\n\t\t\tret = regulator_enable(sinfo->reg_lcd);\n\t\t\tif (ret)\n\t\t\t\tdev_err(&sinfo->pdev->dev,\n\t\t\t\t\t\"lcd regulator enable failed:\t%d\\n\", ret);\n\t\t} else {\n\t\t\tret = regulator_disable(sinfo->reg_lcd);\n\t\t\tif (ret)\n\t\t\t\tdev_err(&sinfo->pdev->dev,\n\t\t\t\t\t\"lcd regulator disable failed: %d\\n\", ret);\n\t\t}\n\t}\n}\n\nstatic const struct fb_fix_screeninfo atmel_lcdfb_fix __initconst = {\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.visual\t\t= FB_VISUAL_TRUECOLOR,\n\t.xpanstep\t= 0,\n\t.ypanstep\t= 1,\n\t.ywrapstep\t= 0,\n\t.accel\t\t= FB_ACCEL_NONE,\n};\n\nstatic unsigned long compute_hozval(struct atmel_lcdfb_info *sinfo,\n\t\t\t\t\t\t\tunsigned long xres)\n{\n\tunsigned long lcdcon2;\n\tunsigned long value;\n\n\tif (!sinfo->config->have_hozval)\n\t\treturn xres;\n\n\tlcdcon2 = lcdc_readl(sinfo, ATMEL_LCDC_LCDCON2);\n\tvalue = xres;\n\tif ((lcdcon2 & ATMEL_LCDC_DISTYPE) != ATMEL_LCDC_DISTYPE_TFT) {\n\t\t \n\t\tif ((lcdcon2 & ATMEL_LCDC_DISTYPE) == ATMEL_LCDC_DISTYPE_STNCOLOR) {\n\t\t\tvalue *= 3;\n\t\t}\n\t\tif ( (lcdcon2 & ATMEL_LCDC_IFWIDTH) == ATMEL_LCDC_IFWIDTH_4\n\t\t   || ( (lcdcon2 & ATMEL_LCDC_IFWIDTH) == ATMEL_LCDC_IFWIDTH_8\n\t\t      && (lcdcon2 & ATMEL_LCDC_SCANMOD) == ATMEL_LCDC_SCANMOD_DUAL ))\n\t\t\tvalue = DIV_ROUND_UP(value, 4);\n\t\telse\n\t\t\tvalue = DIV_ROUND_UP(value, 8);\n\t}\n\n\treturn value;\n}\n\nstatic void atmel_lcdfb_stop_nowait(struct atmel_lcdfb_info *sinfo)\n{\n\tstruct atmel_lcdfb_pdata *pdata = &sinfo->pdata;\n\n\t \n\tlcdc_writel(sinfo, ATMEL_LCDC_PWRCON,\n\t\t\tpdata->guard_time << ATMEL_LCDC_GUARDT_OFFSET);\n\n\t \n\twhile (lcdc_readl(sinfo, ATMEL_LCDC_PWRCON) & ATMEL_LCDC_BUSY)\n\t\tmsleep(10);\n\n\tlcdc_writel(sinfo, ATMEL_LCDC_DMACON, 0);\n}\n\nstatic void atmel_lcdfb_stop(struct atmel_lcdfb_info *sinfo)\n{\n\tatmel_lcdfb_stop_nowait(sinfo);\n\n\t \n\twhile (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)\n\t\tmsleep(10);\n}\n\nstatic void atmel_lcdfb_start(struct atmel_lcdfb_info *sinfo)\n{\n\tstruct atmel_lcdfb_pdata *pdata = &sinfo->pdata;\n\n\tlcdc_writel(sinfo, ATMEL_LCDC_DMACON, pdata->default_dmacon);\n\tlcdc_writel(sinfo, ATMEL_LCDC_PWRCON,\n\t\t(pdata->guard_time << ATMEL_LCDC_GUARDT_OFFSET)\n\t\t| ATMEL_LCDC_PWR);\n}\n\nstatic void atmel_lcdfb_update_dma(struct fb_info *info,\n\t\t\t       struct fb_var_screeninfo *var)\n{\n\tstruct atmel_lcdfb_info *sinfo = info->par;\n\tstruct fb_fix_screeninfo *fix = &info->fix;\n\tunsigned long dma_addr;\n\n\tdma_addr = (fix->smem_start + var->yoffset * fix->line_length\n\t\t    + var->xoffset * info->var.bits_per_pixel / 8);\n\n\tdma_addr &= ~3UL;\n\n\t \n\tlcdc_writel(sinfo, ATMEL_LCDC_DMABADDR1, dma_addr);\n}\n\nstatic inline void atmel_lcdfb_free_video_memory(struct atmel_lcdfb_info *sinfo)\n{\n\tstruct fb_info *info = sinfo->info;\n\n\tdma_free_wc(info->device, info->fix.smem_len, info->screen_base,\n\t\t    info->fix.smem_start);\n}\n\n \nstatic int atmel_lcdfb_alloc_video_memory(struct atmel_lcdfb_info *sinfo)\n{\n\tstruct fb_info *info = sinfo->info;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tunsigned int smem_len;\n\n\tsmem_len = (var->xres_virtual * var->yres_virtual\n\t\t    * ((var->bits_per_pixel + 7) / 8));\n\tinfo->fix.smem_len = max(smem_len, sinfo->smem_len);\n\n\tinfo->screen_base = dma_alloc_wc(info->device, info->fix.smem_len,\n\t\t\t\t\t (dma_addr_t *)&info->fix.smem_start,\n\t\t\t\t\t GFP_KERNEL);\n\n\tif (!info->screen_base) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(info->screen_base, 0, info->fix.smem_len);\n\n\treturn 0;\n}\n\nstatic const struct fb_videomode *atmel_lcdfb_choose_mode(struct fb_var_screeninfo *var,\n\t\t\t\t\t\t     struct fb_info *info)\n{\n\tstruct fb_videomode varfbmode;\n\tconst struct fb_videomode *fbmode = NULL;\n\n\tfb_var_to_videomode(&varfbmode, var);\n\tfbmode = fb_find_nearest_mode(&varfbmode, &info->modelist);\n\tif (fbmode)\n\t\tfb_videomode_to_var(var, fbmode);\n\treturn fbmode;\n}\n\n\n \nstatic int atmel_lcdfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tstruct device *dev = info->device;\n\tstruct atmel_lcdfb_info *sinfo = info->par;\n\tstruct atmel_lcdfb_pdata *pdata = &sinfo->pdata;\n\tunsigned long clk_value_khz;\n\n\tclk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;\n\n\tdev_dbg(dev, \"%s:\\n\", __func__);\n\n\tif (!(var->pixclock && var->bits_per_pixel)) {\n\t\t \n\t\tif (!atmel_lcdfb_choose_mode(var, info)) {\n\t\t\tdev_err(dev, \"needed value not specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"  resolution: %ux%u\\n\", var->xres, var->yres);\n\tdev_dbg(dev, \"  pixclk:     %lu KHz\\n\", PICOS2KHZ(var->pixclock));\n\tdev_dbg(dev, \"  bpp:        %u\\n\", var->bits_per_pixel);\n\tdev_dbg(dev, \"  clk:        %lu KHz\\n\", clk_value_khz);\n\n\tif (PICOS2KHZ(var->pixclock) > clk_value_khz) {\n\t\tdev_err(dev, \"%lu KHz pixel clock is too fast\\n\", PICOS2KHZ(var->pixclock));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\n\t \n\tvar->xres = (var->xres + 3) & ~3UL;\n\tvar->xres_virtual = (var->xres_virtual + 3) & ~3UL;\n\n\tvar->red.msb_right = var->green.msb_right = var->blue.msb_right = 0;\n\tvar->transp.msb_right = 0;\n\tvar->transp.offset = var->transp.length = 0;\n\tvar->xoffset = var->yoffset = 0;\n\n\tif (info->fix.smem_len) {\n\t\tunsigned int smem_len = (var->xres_virtual * var->yres_virtual\n\t\t\t\t\t * ((var->bits_per_pixel + 7) / 8));\n\t\tif (smem_len > info->fix.smem_len) {\n\t\t\tdev_err(dev, \"Frame buffer is too small (%u) for screen size (need at least %u)\\n\",\n\t\t\t\tinfo->fix.smem_len, smem_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tvar->vsync_len = min_t(u32, var->vsync_len,\n\t\t\t(ATMEL_LCDC_VPW >> ATMEL_LCDC_VPW_OFFSET) + 1);\n\tvar->upper_margin = min_t(u32, var->upper_margin,\n\t\t\tATMEL_LCDC_VBP >> ATMEL_LCDC_VBP_OFFSET);\n\tvar->lower_margin = min_t(u32, var->lower_margin,\n\t\t\tATMEL_LCDC_VFP);\n\tvar->right_margin = min_t(u32, var->right_margin,\n\t\t\t(ATMEL_LCDC_HFP >> ATMEL_LCDC_HFP_OFFSET) + 1);\n\tvar->hsync_len = min_t(u32, var->hsync_len,\n\t\t\t(ATMEL_LCDC_HPW >> ATMEL_LCDC_HPW_OFFSET) + 1);\n\tvar->left_margin = min_t(u32, var->left_margin,\n\t\t\tATMEL_LCDC_HBP + 1);\n\n\t \n\tvar->vsync_len = max_t(u32, var->vsync_len, 1);\n\tvar->right_margin = max_t(u32, var->right_margin, 1);\n\tvar->hsync_len = max_t(u32, var->hsync_len, 1);\n\tvar->left_margin = max_t(u32, var->left_margin, 1);\n\n\tswitch (var->bits_per_pixel) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\t\tvar->red.offset = var->green.offset = var->blue.offset = 0;\n\t\tvar->red.length = var->green.length = var->blue.length\n\t\t\t= var->bits_per_pixel;\n\t\tbreak;\n\tcase 16:\n\t\t \n\t\tif (sinfo->config->have_intensity_bit)\n\t\t\tvar->green.length = 5;\n\t\telse\n\t\t\tvar->green.length = 6;\n\n\t\tif (pdata->lcd_wiring_mode == ATMEL_LCDC_WIRING_RGB) {\n\t\t\t \n\t\t\tvar->red.offset = var->green.length + 5;\n\t\t\tvar->blue.offset = 0;\n\t\t} else {\n\t\t\t \n\t\t\tvar->red.offset = 0;\n\t\t\tvar->blue.offset = var->green.length + 5;\n\t\t}\n\t\tvar->green.offset = 5;\n\t\tvar->red.length = var->blue.length = 5;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tfallthrough;\n\tcase 24:\n\t\tif (pdata->lcd_wiring_mode == ATMEL_LCDC_WIRING_RGB) {\n\t\t\t \n\t\t\tvar->red.offset = 16;\n\t\t\tvar->blue.offset = 0;\n\t\t} else {\n\t\t\t \n\t\t\tvar->red.offset = 0;\n\t\t\tvar->blue.offset = 16;\n\t\t}\n\t\tvar->green.offset = 8;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"color depth %d not supported\\n\",\n\t\t\t\t\tvar->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void atmel_lcdfb_reset(struct atmel_lcdfb_info *sinfo)\n{\n\tmight_sleep();\n\n\tatmel_lcdfb_stop(sinfo);\n\tatmel_lcdfb_start(sinfo);\n}\n\n \nstatic int atmel_lcdfb_set_par(struct fb_info *info)\n{\n\tstruct atmel_lcdfb_info *sinfo = info->par;\n\tstruct atmel_lcdfb_pdata *pdata = &sinfo->pdata;\n\tunsigned long hozval_linesz;\n\tunsigned long value;\n\tunsigned long clk_value_khz;\n\tunsigned long bits_per_line;\n\tunsigned long pix_factor = 2;\n\n\tmight_sleep();\n\n\tdev_dbg(info->device, \"%s:\\n\", __func__);\n\tdev_dbg(info->device, \"  * resolution: %ux%u (%ux%u virtual)\\n\",\n\t\t info->var.xres, info->var.yres,\n\t\t info->var.xres_virtual, info->var.yres_virtual);\n\n\tatmel_lcdfb_stop_nowait(sinfo);\n\n\tif (info->var.bits_per_pixel == 1)\n\t\tinfo->fix.visual = FB_VISUAL_MONO01;\n\telse if (info->var.bits_per_pixel <= 8)\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\telse\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\n\tbits_per_line = info->var.xres_virtual * info->var.bits_per_pixel;\n\tinfo->fix.line_length = DIV_ROUND_UP(bits_per_line, 8);\n\n\t \n\tdev_dbg(info->device, \"  * update DMA engine\\n\");\n\tatmel_lcdfb_update_dma(info, &info->var);\n\n\t \n\tvalue = (info->var.yres * info->var.xres * info->var.bits_per_pixel) / 32;\n\tvalue |= ((ATMEL_LCDC_DMA_BURST_LEN - 1) << ATMEL_LCDC_BLENGTH_OFFSET);\n\tlcdc_writel(sinfo, ATMEL_LCDC_DMAFRMCFG, value);\n\n\t \n\n\t \n\tif (sinfo->config->have_alt_pixclock)\n\t\tpix_factor = 1;\n\n\tclk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;\n\n\tvalue = DIV_ROUND_UP(clk_value_khz, PICOS2KHZ(info->var.pixclock));\n\n\tif (value < pix_factor) {\n\t\tdev_notice(info->device, \"Bypassing pixel clock divider\\n\");\n\t\tlcdc_writel(sinfo, ATMEL_LCDC_LCDCON1, ATMEL_LCDC_BYPASS);\n\t} else {\n\t\tvalue = (value / pix_factor) - 1;\n\t\tdev_dbg(info->device, \"  * programming CLKVAL = 0x%08lx\\n\",\n\t\t\t\tvalue);\n\t\tlcdc_writel(sinfo, ATMEL_LCDC_LCDCON1,\n\t\t\t\tvalue << ATMEL_LCDC_CLKVAL_OFFSET);\n\t\tinfo->var.pixclock =\n\t\t\tKHZ2PICOS(clk_value_khz / (pix_factor * (value + 1)));\n\t\tdev_dbg(info->device, \"  updated pixclk:     %lu KHz\\n\",\n\t\t\t\t\tPICOS2KHZ(info->var.pixclock));\n\t}\n\n\n\t \n\tvalue = pdata->default_lcdcon2;\n\n\tif (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))\n\t\tvalue |= ATMEL_LCDC_INVLINE_INVERTED;\n\tif (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))\n\t\tvalue |= ATMEL_LCDC_INVFRAME_INVERTED;\n\n\tswitch (info->var.bits_per_pixel) {\n\t\tcase 1:\tvalue |= ATMEL_LCDC_PIXELSIZE_1; break;\n\t\tcase 2: value |= ATMEL_LCDC_PIXELSIZE_2; break;\n\t\tcase 4: value |= ATMEL_LCDC_PIXELSIZE_4; break;\n\t\tcase 8: value |= ATMEL_LCDC_PIXELSIZE_8; break;\n\t\tcase 15: fallthrough;\n\t\tcase 16: value |= ATMEL_LCDC_PIXELSIZE_16; break;\n\t\tcase 24: value |= ATMEL_LCDC_PIXELSIZE_24; break;\n\t\tcase 32: value |= ATMEL_LCDC_PIXELSIZE_32; break;\n\t\tdefault: BUG(); break;\n\t}\n\tdev_dbg(info->device, \"  * LCDCON2 = %08lx\\n\", value);\n\tlcdc_writel(sinfo, ATMEL_LCDC_LCDCON2, value);\n\n\t \n\tvalue = (info->var.vsync_len - 1) << ATMEL_LCDC_VPW_OFFSET;\n\tvalue |= info->var.upper_margin << ATMEL_LCDC_VBP_OFFSET;\n\tvalue |= info->var.lower_margin;\n\tdev_dbg(info->device, \"  * LCDTIM1 = %08lx\\n\", value);\n\tlcdc_writel(sinfo, ATMEL_LCDC_TIM1, value);\n\n\t \n\tvalue = (info->var.right_margin - 1) << ATMEL_LCDC_HFP_OFFSET;\n\tvalue |= (info->var.hsync_len - 1) << ATMEL_LCDC_HPW_OFFSET;\n\tvalue |= (info->var.left_margin - 1);\n\tdev_dbg(info->device, \"  * LCDTIM2 = %08lx\\n\", value);\n\tlcdc_writel(sinfo, ATMEL_LCDC_TIM2, value);\n\n\t \n\thozval_linesz = compute_hozval(sinfo, info->var.xres);\n\n\t \n\tvalue = (hozval_linesz - 1) << ATMEL_LCDC_HOZVAL_OFFSET;\n\tvalue |= info->var.yres - 1;\n\tdev_dbg(info->device, \"  * LCDFRMCFG = %08lx\\n\", value);\n\tlcdc_writel(sinfo, ATMEL_LCDC_LCDFRMCFG, value);\n\n\t \n\tvalue = ATMEL_LCDC_FIFO_SIZE - (2 * ATMEL_LCDC_DMA_BURST_LEN + 3);\n\tlcdc_writel(sinfo, ATMEL_LCDC_FIFO, value);\n\n\t \n\tlcdc_writel(sinfo, ATMEL_LCDC_MVAL, 0);\n\n\t \n\tlcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0U);\n\t \n\tlcdc_writel(sinfo, ATMEL_LCDC_IER, ATMEL_LCDC_UFLWI | ATMEL_LCDC_OWRI | ATMEL_LCDC_MERI);\n\n\t \n\twhile (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)\n\t\tmsleep(10);\n\n\tatmel_lcdfb_start(sinfo);\n\n\tdev_dbg(info->device, \"  * DONE\\n\");\n\n\treturn 0;\n}\n\nstatic inline unsigned int chan_to_field(unsigned int chan, const struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\n \nstatic int atmel_lcdfb_setcolreg(unsigned int regno, unsigned int red,\n\t\t\t     unsigned int green, unsigned int blue,\n\t\t\t     unsigned int transp, struct fb_info *info)\n{\n\tstruct atmel_lcdfb_info *sinfo = info->par;\n\tstruct atmel_lcdfb_pdata *pdata = &sinfo->pdata;\n\tunsigned int val;\n\tu32 *pal;\n\tint ret = 1;\n\n\tif (info->var.grayscale)\n\t\tred = green = blue = (19595 * red + 38470 * green\n\t\t\t\t      + 7471 * blue) >> 16;\n\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\tif (regno < 16) {\n\t\t\tpal = info->pseudo_palette;\n\n\t\t\tval  = chan_to_field(red, &info->var.red);\n\t\t\tval |= chan_to_field(green, &info->var.green);\n\t\t\tval |= chan_to_field(blue, &info->var.blue);\n\n\t\t\tpal[regno] = val;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tif (regno < 256) {\n\t\t\tif (sinfo->config->have_intensity_bit) {\n\t\t\t\t \n\t\t\t\tval  = ((red   >> 11) & 0x001f);\n\t\t\t\tval |= ((green >>  6) & 0x03e0);\n\t\t\t\tval |= ((blue  >>  1) & 0x7c00);\n\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (pdata->lcd_wiring_mode == ATMEL_LCDC_WIRING_RGB) {\n\t\t\t\t\tval  = ((blue >> 11) & 0x001f);\n\t\t\t\t\tval |= ((red  >>  0) & 0xf800);\n\t\t\t\t} else {\n\t\t\t\t\tval  = ((red  >> 11) & 0x001f);\n\t\t\t\t\tval |= ((blue >>  0) & 0xf800);\n\t\t\t\t}\n\n\t\t\t\tval |= ((green >>  5) & 0x07e0);\n\t\t\t}\n\n\t\t\tlcdc_writel(sinfo, ATMEL_LCDC_LUT(regno), val);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FB_VISUAL_MONO01:\n\t\tif (regno < 2) {\n\t\t\tval = (regno == 0) ? 0x00 : 0x1F;\n\t\t\tlcdc_writel(sinfo, ATMEL_LCDC_LUT(regno), val);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\t}\n\n\treturn ret;\n}\n\nstatic int atmel_lcdfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t       struct fb_info *info)\n{\n\tdev_dbg(info->device, \"%s\\n\", __func__);\n\n\tatmel_lcdfb_update_dma(info, var);\n\n\treturn 0;\n}\n\nstatic int atmel_lcdfb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct atmel_lcdfb_info *sinfo = info->par;\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\tcase FB_BLANK_NORMAL:\n\t\tatmel_lcdfb_start(sinfo);\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tatmel_lcdfb_stop(sinfo);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn ((blank_mode == FB_BLANK_NORMAL) ? 1 : 0);\n}\n\nstatic const struct fb_ops atmel_lcdfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= atmel_lcdfb_check_var,\n\t.fb_set_par\t= atmel_lcdfb_set_par,\n\t.fb_setcolreg\t= atmel_lcdfb_setcolreg,\n\t.fb_blank\t= atmel_lcdfb_blank,\n\t.fb_pan_display\t= atmel_lcdfb_pan_display,\n};\n\nstatic irqreturn_t atmel_lcdfb_interrupt(int irq, void *dev_id)\n{\n\tstruct fb_info *info = dev_id;\n\tstruct atmel_lcdfb_info *sinfo = info->par;\n\tu32 status;\n\n\tstatus = lcdc_readl(sinfo, ATMEL_LCDC_ISR);\n\tif (status & ATMEL_LCDC_UFLWI) {\n\t\tdev_warn(info->device, \"FIFO underflow %#x\\n\", status);\n\t\t \n\t\tschedule_work(&sinfo->task);\n\t}\n\tlcdc_writel(sinfo, ATMEL_LCDC_ICR, status);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void atmel_lcdfb_task(struct work_struct *work)\n{\n\tstruct atmel_lcdfb_info *sinfo =\n\t\tcontainer_of(work, struct atmel_lcdfb_info, task);\n\n\tatmel_lcdfb_reset(sinfo);\n}\n\nstatic int __init atmel_lcdfb_init_fbinfo(struct atmel_lcdfb_info *sinfo)\n{\n\tstruct fb_info *info = sinfo->info;\n\tint ret = 0;\n\n\tinfo->var.activate |= FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW;\n\n\tdev_info(info->device,\n\t       \"%luKiB frame buffer at %08lx (mapped at %p)\\n\",\n\t       (unsigned long)info->fix.smem_len / 1024,\n\t       (unsigned long)info->fix.smem_start,\n\t       info->screen_base);\n\n\t \n\tret = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (ret < 0)\n\t\tdev_err(info->device, \"Alloc color map failed\\n\");\n\n\treturn ret;\n}\n\nstatic void atmel_lcdfb_start_clock(struct atmel_lcdfb_info *sinfo)\n{\n\tclk_prepare_enable(sinfo->bus_clk);\n\tclk_prepare_enable(sinfo->lcdc_clk);\n}\n\nstatic void atmel_lcdfb_stop_clock(struct atmel_lcdfb_info *sinfo)\n{\n\tclk_disable_unprepare(sinfo->bus_clk);\n\tclk_disable_unprepare(sinfo->lcdc_clk);\n}\n\nstatic const struct of_device_id atmel_lcdfb_dt_ids[] = {\n\t{ .compatible = \"atmel,at91sam9261-lcdc\" , .data = &at91sam9261_config, },\n\t{ .compatible = \"atmel,at91sam9263-lcdc\" , .data = &at91sam9263_config, },\n\t{ .compatible = \"atmel,at91sam9g10-lcdc\" , .data = &at91sam9g10_config, },\n\t{ .compatible = \"atmel,at91sam9g45-lcdc\" , .data = &at91sam9g45_config, },\n\t{ .compatible = \"atmel,at91sam9g45es-lcdc\" , .data = &at91sam9g45es_config, },\n\t{ .compatible = \"atmel,at91sam9rl-lcdc\" , .data = &at91sam9rl_config, },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, atmel_lcdfb_dt_ids);\n\nstatic const char *atmel_lcdfb_wiring_modes[] = {\n\t[ATMEL_LCDC_WIRING_BGR]\t= \"BRG\",\n\t[ATMEL_LCDC_WIRING_RGB]\t= \"RGB\",\n};\n\nstatic int atmel_lcdfb_get_of_wiring_modes(struct device_node *np)\n{\n\tconst char *mode;\n\tint err, i;\n\n\terr = of_property_read_string(np, \"atmel,lcd-wiring-mode\", &mode);\n\tif (err < 0)\n\t\treturn ATMEL_LCDC_WIRING_BGR;\n\n\tfor (i = 0; i < ARRAY_SIZE(atmel_lcdfb_wiring_modes); i++)\n\t\tif (!strcasecmp(mode, atmel_lcdfb_wiring_modes[i]))\n\t\t\treturn i;\n\n\treturn -ENODEV;\n}\n\nstatic void atmel_lcdfb_power_control_gpio(struct atmel_lcdfb_pdata *pdata, int on)\n{\n\tstruct atmel_lcdfb_power_ctrl_gpio *og;\n\n\tlist_for_each_entry(og, &pdata->pwr_gpios, list)\n\t\tgpiod_set_value(og->gpiod, on);\n}\n\nstatic int atmel_lcdfb_of_init(struct atmel_lcdfb_info *sinfo)\n{\n\tstruct fb_info *info = sinfo->info;\n\tstruct atmel_lcdfb_pdata *pdata = &sinfo->pdata;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tstruct device *dev = &sinfo->pdev->dev;\n\tstruct device_node *np =dev->of_node;\n\tstruct device_node *display_np;\n\tstruct atmel_lcdfb_power_ctrl_gpio *og;\n\tbool is_gpio_power = false;\n\tstruct fb_videomode fb_vm;\n\tstruct gpio_desc *gpiod;\n\tstruct videomode vm;\n\tint ret;\n\tint i;\n\n\tsinfo->config = (struct atmel_lcdfb_config*)\n\t\tof_match_device(atmel_lcdfb_dt_ids, dev)->data;\n\n\tdisplay_np = of_parse_phandle(np, \"display\", 0);\n\tif (!display_np) {\n\t\tdev_err(dev, \"failed to find display phandle\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tret = of_property_read_u32(display_np, \"bits-per-pixel\", &var->bits_per_pixel);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get property bits-per-pixel\\n\");\n\t\tgoto put_display_node;\n\t}\n\n\tret = of_property_read_u32(display_np, \"atmel,guard-time\", &pdata->guard_time);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get property atmel,guard-time\\n\");\n\t\tgoto put_display_node;\n\t}\n\n\tret = of_property_read_u32(display_np, \"atmel,lcdcon2\", &pdata->default_lcdcon2);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get property atmel,lcdcon2\\n\");\n\t\tgoto put_display_node;\n\t}\n\n\tret = of_property_read_u32(display_np, \"atmel,dmacon\", &pdata->default_dmacon);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get property bits-per-pixel\\n\");\n\t\tgoto put_display_node;\n\t}\n\n\tINIT_LIST_HEAD(&pdata->pwr_gpios);\n\tfor (i = 0; i < gpiod_count(dev, \"atmel,power-control\"); i++) {\n\t\tret = -ENOMEM;\n\t\tgpiod = devm_gpiod_get_index(dev, \"atmel,power-control\",\n\t\t\t\t\t     i, GPIOD_ASIS);\n\t\tif (IS_ERR(gpiod))\n\t\t\tcontinue;\n\n\t\tog = devm_kzalloc(dev, sizeof(*og), GFP_KERNEL);\n\t\tif (!og)\n\t\t\tgoto put_display_node;\n\n\t\tog->gpiod = gpiod;\n\t\tis_gpio_power = true;\n\n\t\tret = gpiod_direction_output(gpiod, gpiod_is_active_low(gpiod));\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"set direction output gpio atmel,power-control[%d] failed\\n\", i);\n\t\t\tgoto put_display_node;\n\t\t}\n\t\tlist_add(&og->list, &pdata->pwr_gpios);\n\t}\n\n\tif (is_gpio_power)\n\t\tpdata->atmel_lcdfb_power_control = atmel_lcdfb_power_control_gpio;\n\n\tret = atmel_lcdfb_get_of_wiring_modes(display_np);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"invalid atmel,lcd-wiring-mode\\n\");\n\t\tgoto put_display_node;\n\t}\n\tpdata->lcd_wiring_mode = ret;\n\n\tpdata->lcdcon_is_backlight = of_property_read_bool(display_np, \"atmel,lcdcon-backlight\");\n\tpdata->lcdcon_pol_negative = of_property_read_bool(display_np, \"atmel,lcdcon-backlight-inverted\");\n\n\tret = of_get_videomode(display_np, &vm, OF_USE_NATIVE_MODE);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get videomode from DT\\n\");\n\t\tgoto put_display_node;\n\t}\n\n\tret = fb_videomode_from_videomode(&vm, &fb_vm);\n\tif (ret < 0)\n\t\tgoto put_display_node;\n\n\tfb_add_videomode(&fb_vm, &info->modelist);\n\nput_display_node:\n\tof_node_put(display_np);\n\treturn ret;\n}\n\nstatic int __init atmel_lcdfb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fb_info *info;\n\tstruct atmel_lcdfb_info *sinfo;\n\tstruct resource *regs = NULL;\n\tstruct resource *map = NULL;\n\tstruct fb_modelist *modelist;\n\tint ret;\n\n\tdev_dbg(dev, \"%s BEGIN\\n\", __func__);\n\n\tret = -ENOMEM;\n\tinfo = framebuffer_alloc(sizeof(struct atmel_lcdfb_info), dev);\n\tif (!info)\n\t\tgoto out;\n\n\tsinfo = info->par;\n\tsinfo->pdev = pdev;\n\tsinfo->info = info;\n\n\tINIT_LIST_HEAD(&info->modelist);\n\n\tif (!pdev->dev.of_node) {\n\t\tdev_err(dev, \"cannot get default configuration\\n\");\n\t\tgoto free_info;\n\t}\n\n\tret = atmel_lcdfb_of_init(sinfo);\n\tif (ret)\n\t\tgoto free_info;\n\n\tret = -ENODEV;\n\tif (!sinfo->config)\n\t\tgoto free_info;\n\n\tsinfo->reg_lcd = devm_regulator_get(&pdev->dev, \"lcd\");\n\tif (IS_ERR(sinfo->reg_lcd))\n\t\tsinfo->reg_lcd = NULL;\n\n\tinfo->flags = FBINFO_PARTIAL_PAN_OK |\n\t\t      FBINFO_HWACCEL_YPAN;\n\tinfo->pseudo_palette = sinfo->pseudo_palette;\n\tinfo->fbops = &atmel_lcdfb_ops;\n\n\tinfo->fix = atmel_lcdfb_fix;\n\tstrcpy(info->fix.id, sinfo->pdev->name);\n\n\t \n\tsinfo->bus_clk = clk_get(dev, \"hclk\");\n\tif (IS_ERR(sinfo->bus_clk)) {\n\t\tret = PTR_ERR(sinfo->bus_clk);\n\t\tgoto free_info;\n\t}\n\tsinfo->lcdc_clk = clk_get(dev, \"lcdc_clk\");\n\tif (IS_ERR(sinfo->lcdc_clk)) {\n\t\tret = PTR_ERR(sinfo->lcdc_clk);\n\t\tgoto put_bus_clk;\n\t}\n\tatmel_lcdfb_start_clock(sinfo);\n\n\tmodelist = list_first_entry(&info->modelist,\n\t\t\tstruct fb_modelist, list);\n\tfb_videomode_to_var(&info->var, &modelist->mode);\n\n\tatmel_lcdfb_check_var(&info->var, info);\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs) {\n\t\tdev_err(dev, \"resources unusable\\n\");\n\t\tret = -ENXIO;\n\t\tgoto stop_clk;\n\t}\n\n\tsinfo->irq_base = platform_get_irq(pdev, 0);\n\tif (sinfo->irq_base < 0) {\n\t\tret = sinfo->irq_base;\n\t\tgoto stop_clk;\n\t}\n\n\t \n\tmap = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (map) {\n\t\t \n\t\tinfo->fix.smem_start = map->start;\n\t\tinfo->fix.smem_len = resource_size(map);\n\t\tif (!request_mem_region(info->fix.smem_start,\n\t\t\t\t\tinfo->fix.smem_len, pdev->name)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto stop_clk;\n\t\t}\n\n\t\tinfo->screen_base = ioremap_wc(info->fix.smem_start,\n\t\t\t\t\t       info->fix.smem_len);\n\t\tif (!info->screen_base) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto release_intmem;\n\t\t}\n\n\t\t \n\t} else {\n\t\t \n\t\tret = atmel_lcdfb_alloc_video_memory(sinfo);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"cannot allocate framebuffer: %d\\n\", ret);\n\t\t\tgoto stop_clk;\n\t\t}\n\t}\n\n\t \n\tinfo->fix.mmio_start = regs->start;\n\tinfo->fix.mmio_len = resource_size(regs);\n\n\tif (!request_mem_region(info->fix.mmio_start,\n\t\t\t\tinfo->fix.mmio_len, pdev->name)) {\n\t\tret = -EBUSY;\n\t\tgoto free_fb;\n\t}\n\n\tsinfo->mmio = ioremap(info->fix.mmio_start, info->fix.mmio_len);\n\tif (!sinfo->mmio) {\n\t\tdev_err(dev, \"cannot map LCDC registers\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto release_mem;\n\t}\n\n\t \n\tinit_contrast(sinfo);\n\n\t \n\tret = request_irq(sinfo->irq_base, atmel_lcdfb_interrupt, 0, pdev->name, info);\n\tif (ret) {\n\t\tdev_err(dev, \"request_irq failed: %d\\n\", ret);\n\t\tgoto unmap_mmio;\n\t}\n\n\t \n\tINIT_WORK(&sinfo->task, atmel_lcdfb_task);\n\n\tret = atmel_lcdfb_init_fbinfo(sinfo);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"init fbinfo failed: %d\\n\", ret);\n\t\tgoto unregister_irqs;\n\t}\n\n\tret = atmel_lcdfb_set_par(info);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"set par failed: %d\\n\", ret);\n\t\tgoto unregister_irqs;\n\t}\n\n\tdev_set_drvdata(dev, info);\n\n\t \n\tret = register_framebuffer(info);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register framebuffer device: %d\\n\", ret);\n\t\tgoto reset_drvdata;\n\t}\n\n\t \n\tatmel_lcdfb_power_control(sinfo, 1);\n\n\tdev_info(dev, \"fb%d: Atmel LCDC at 0x%08lx (mapped at %p), irq %d\\n\",\n\t\t       info->node, info->fix.mmio_start, sinfo->mmio, sinfo->irq_base);\n\n\treturn 0;\n\nreset_drvdata:\n\tdev_set_drvdata(dev, NULL);\n\tfb_dealloc_cmap(&info->cmap);\nunregister_irqs:\n\tcancel_work_sync(&sinfo->task);\n\tfree_irq(sinfo->irq_base, info);\nunmap_mmio:\n\texit_backlight(sinfo);\n\tiounmap(sinfo->mmio);\nrelease_mem:\n \trelease_mem_region(info->fix.mmio_start, info->fix.mmio_len);\nfree_fb:\n\tif (map)\n\t\tiounmap(info->screen_base);\n\telse\n\t\tatmel_lcdfb_free_video_memory(sinfo);\n\nrelease_intmem:\n\tif (map)\n\t\trelease_mem_region(info->fix.smem_start, info->fix.smem_len);\nstop_clk:\n\tatmel_lcdfb_stop_clock(sinfo);\n\tclk_put(sinfo->lcdc_clk);\nput_bus_clk:\n\tclk_put(sinfo->bus_clk);\nfree_info:\n\tframebuffer_release(info);\nout:\n\tdev_dbg(dev, \"%s FAILED\\n\", __func__);\n\treturn ret;\n}\n\nstatic int __exit atmel_lcdfb_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct atmel_lcdfb_info *sinfo;\n\n\tif (!info || !info->par)\n\t\treturn 0;\n\tsinfo = info->par;\n\n\tcancel_work_sync(&sinfo->task);\n\texit_backlight(sinfo);\n\tatmel_lcdfb_power_control(sinfo, 0);\n\tunregister_framebuffer(info);\n\tatmel_lcdfb_stop_clock(sinfo);\n\tclk_put(sinfo->lcdc_clk);\n\tclk_put(sinfo->bus_clk);\n\tfb_dealloc_cmap(&info->cmap);\n\tfree_irq(sinfo->irq_base, info);\n\tiounmap(sinfo->mmio);\n \trelease_mem_region(info->fix.mmio_start, info->fix.mmio_len);\n\tif (platform_get_resource(pdev, IORESOURCE_MEM, 1)) {\n\t\tiounmap(info->screen_base);\n\t\trelease_mem_region(info->fix.smem_start, info->fix.smem_len);\n\t} else {\n\t\tatmel_lcdfb_free_video_memory(sinfo);\n\t}\n\n\tframebuffer_release(info);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic int atmel_lcdfb_suspend(struct platform_device *pdev, pm_message_t mesg)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\tstruct atmel_lcdfb_info *sinfo = info->par;\n\n\t \n\tlcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0U);\n\n\tsinfo->saved_lcdcon = lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_CTR);\n\tlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, 0);\n\tatmel_lcdfb_power_control(sinfo, 0);\n\tatmel_lcdfb_stop(sinfo);\n\tatmel_lcdfb_stop_clock(sinfo);\n\n\treturn 0;\n}\n\nstatic int atmel_lcdfb_resume(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\tstruct atmel_lcdfb_info *sinfo = info->par;\n\n\tatmel_lcdfb_start_clock(sinfo);\n\tatmel_lcdfb_start(sinfo);\n\tatmel_lcdfb_power_control(sinfo, 1);\n\tlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, sinfo->saved_lcdcon);\n\n\t \n\tlcdc_writel(sinfo, ATMEL_LCDC_IER, ATMEL_LCDC_UFLWI\n\t\t\t| ATMEL_LCDC_OWRI | ATMEL_LCDC_MERI);\n\n\treturn 0;\n}\n\n#else\n#define atmel_lcdfb_suspend\tNULL\n#define atmel_lcdfb_resume\tNULL\n#endif\n\nstatic struct platform_driver atmel_lcdfb_driver = {\n\t.remove\t\t= __exit_p(atmel_lcdfb_remove),\n\t.suspend\t= atmel_lcdfb_suspend,\n\t.resume\t\t= atmel_lcdfb_resume,\n\t.driver\t\t= {\n\t\t.name\t= \"atmel_lcdfb\",\n\t\t.of_match_table\t= atmel_lcdfb_dt_ids,\n\t},\n};\n\nmodule_platform_driver_probe(atmel_lcdfb_driver, atmel_lcdfb_probe);\n\nMODULE_DESCRIPTION(\"AT91 LCD Controller framebuffer driver\");\nMODULE_AUTHOR(\"Nicolas Ferre <nicolas.ferre@atmel.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}