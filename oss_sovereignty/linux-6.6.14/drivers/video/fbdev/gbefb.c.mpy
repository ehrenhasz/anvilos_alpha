{
  "module_name": "gbefb.c",
  "hash_id": "64eaa30f786d5326987fc5769523c6f4a72ca0d702bd5ee14d22f18bbd656c1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/gbefb.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/gfp.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/io.h>\n\n#ifdef CONFIG_MIPS\n#include <asm/addrspace.h>\n#endif\n#include <asm/byteorder.h>\n#include <asm/tlbflush.h>\n\n#include <video/gbe.h>\n\nstatic struct sgi_gbe *gbe;\n\nstruct gbefb_par {\n\tstruct fb_var_screeninfo var;\n\tstruct gbe_timing_info timing;\n\tint wc_cookie;\n\tint valid;\n};\n\n#define GBE_BASE\t0x16000000  \n\n \n#ifdef CONFIG_MIPS\n#ifdef CONFIG_CPU_R10000\n#define pgprot_fb(_prot) (((_prot) & (~_CACHE_MASK)) | _CACHE_UNCACHED_ACCELERATED)\n#else\n#define pgprot_fb(_prot) (((_prot) & (~_CACHE_MASK)) | _CACHE_CACHABLE_NO_WA)\n#endif\n#endif\n\n \n#if CONFIG_FB_GBE_MEM > 8\n#error GBE Framebuffer cannot use more than 8MB of memory\n#endif\n\n#define TILE_SHIFT 16\n#define TILE_SIZE (1 << TILE_SHIFT)\n#define TILE_MASK (TILE_SIZE - 1)\n\nstatic unsigned int gbe_mem_size = CONFIG_FB_GBE_MEM * 1024*1024;\nstatic void *gbe_mem;\nstatic dma_addr_t gbe_dma_addr;\nstatic unsigned long gbe_mem_phys;\n\nstatic struct {\n\tuint16_t *cpu;\n\tdma_addr_t dma;\n} gbe_tiles;\n\nstatic int gbe_revision;\n\nstatic int ypan, ywrap;\n\nstatic uint32_t pseudo_palette[16];\nstatic uint32_t gbe_cmap[256];\nstatic int gbe_turned_on;  \n\nstatic char *mode_option = NULL;\n\n \nstatic struct fb_var_screeninfo default_var_CRT = {\n\t \n\t.xres\t\t= 640,\n\t.yres\t\t= 480,\n\t.xres_virtual\t= 640,\n\t.yres_virtual\t= 480,\n\t.xoffset\t= 0,\n\t.yoffset\t= 0,\n\t.bits_per_pixel\t= 8,\n\t.grayscale\t= 0,\n\t.red\t\t= { 0, 8, 0 },\n\t.green\t\t= { 0, 8, 0 },\n\t.blue\t\t= { 0, 8, 0 },\n\t.transp\t\t= { 0, 0, 0 },\n\t.nonstd\t\t= 0,\n\t.activate\t= 0,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.accel_flags\t= 0,\n\t.pixclock\t= 39722,\t \n\t.left_margin\t= 48,\n\t.right_margin\t= 16,\n\t.upper_margin\t= 33,\n\t.lower_margin\t= 10,\n\t.hsync_len\t= 96,\n\t.vsync_len\t= 2,\n\t.sync\t\t= 0,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\n \nstatic struct fb_var_screeninfo default_var_LCD = {\n\t \n\t.xres\t\t= 1600,\n\t.yres\t\t= 1024,\n\t.xres_virtual\t= 1600,\n\t.yres_virtual\t= 1024,\n\t.xoffset\t= 0,\n\t.yoffset\t= 0,\n\t.bits_per_pixel\t= 8,\n\t.grayscale\t= 0,\n\t.red\t\t= { 0, 8, 0 },\n\t.green\t\t= { 0, 8, 0 },\n\t.blue\t\t= { 0, 8, 0 },\n\t.transp\t\t= { 0, 0, 0 },\n\t.nonstd\t\t= 0,\n\t.activate\t= 0,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.accel_flags\t= 0,\n\t.pixclock\t= 9353,\n\t.left_margin\t= 20,\n\t.right_margin\t= 30,\n\t.upper_margin\t= 37,\n\t.lower_margin\t= 3,\n\t.hsync_len\t= 20,\n\t.vsync_len\t= 3,\n\t.sync\t\t= 0,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED\n};\n\n \n \nstatic struct fb_videomode default_mode_CRT = {\n\t.refresh\t= 60,\n\t.xres\t\t= 640,\n\t.yres\t\t= 480,\n\t.pixclock\t= 39722,\n\t.left_margin\t= 48,\n\t.right_margin\t= 16,\n\t.upper_margin\t= 33,\n\t.lower_margin\t= 10,\n\t.hsync_len\t= 96,\n\t.vsync_len\t= 2,\n\t.sync\t\t= 0,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n \nstatic struct fb_videomode default_mode_LCD = {\n\t \n\t.xres\t\t= 1600,\n\t.yres\t\t= 1024,\n\t.pixclock\t= 9353,\n\t.left_margin\t= 20,\n\t.right_margin\t= 30,\n\t.upper_margin\t= 37,\n\t.lower_margin\t= 3,\n\t.hsync_len\t= 20,\n\t.vsync_len\t= 3,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\nstatic struct fb_videomode *default_mode = &default_mode_CRT;\nstatic struct fb_var_screeninfo *default_var = &default_var_CRT;\n\nstatic int flat_panel_enabled = 0;\n\nstatic void gbe_reset(void)\n{\n\t \n\tgbe->ctrlstat = 0x300aa000;\n}\n\n\n \n\nstatic void gbe_turn_off(void)\n{\n\tint i;\n\tunsigned int val, y, vpixen_off;\n\n\tgbe_turned_on = 0;\n\n\t \n\tval = gbe->vt_xy;\n\tif (GET_GBE_FIELD(VT_XY, FREEZE, val) == 1)\n\t\treturn;\n\n\t \n\tval = gbe->ovr_control;\n\tSET_GBE_FIELD(OVR_CONTROL, OVR_DMA_ENABLE, val, 0);\n\tgbe->ovr_control = val;\n\tudelay(1000);\n\tval = gbe->frm_control;\n\tSET_GBE_FIELD(FRM_CONTROL, FRM_DMA_ENABLE, val, 0);\n\tgbe->frm_control = val;\n\tudelay(1000);\n\tval = gbe->did_control;\n\tSET_GBE_FIELD(DID_CONTROL, DID_DMA_ENABLE, val, 0);\n\tgbe->did_control = val;\n\tudelay(1000);\n\n\t \n\tfor (i = 0; i < 10000; i++) {\n\t\tval = gbe->frm_inhwctrl;\n\t\tif (GET_GBE_FIELD(FRM_INHWCTRL, FRM_DMA_ENABLE, val)) {\n\t\t\tudelay(10);\n\t\t} else {\n\t\t\tval = gbe->ovr_inhwctrl;\n\t\t\tif (GET_GBE_FIELD(OVR_INHWCTRL, OVR_DMA_ENABLE, val)) {\n\t\t\t\tudelay(10);\n\t\t\t} else {\n\t\t\t\tval = gbe->did_inhwctrl;\n\t\t\t\tif (GET_GBE_FIELD(DID_INHWCTRL, DID_DMA_ENABLE, val)) {\n\t\t\t\t\tudelay(10);\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (i == 10000)\n\t\tprintk(KERN_ERR \"gbefb: turn off DMA timed out\\n\");\n\n\t \n\tval = gbe->vt_vpixen;\n\tvpixen_off = GET_GBE_FIELD(VT_VPIXEN, VPIXEN_OFF, val);\n\n\tfor (i = 0; i < 100000; i++) {\n\t\tval = gbe->vt_xy;\n\t\ty = GET_GBE_FIELD(VT_XY, Y, val);\n\t\tif (y < vpixen_off)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i == 100000)\n\t\tprintk(KERN_ERR\n\t\t       \"gbefb: wait for vpixen_off timed out\\n\");\n\tfor (i = 0; i < 10000; i++) {\n\t\tval = gbe->vt_xy;\n\t\ty = GET_GBE_FIELD(VT_XY, Y, val);\n\t\tif (y > vpixen_off)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i == 10000)\n\t\tprintk(KERN_ERR \"gbefb: wait for vpixen_off timed out\\n\");\n\n\t \n\tval = 0;\n\tSET_GBE_FIELD(VT_XY, FREEZE, val, 1);\n\tgbe->vt_xy = val;\n\tmdelay(10);\n\tfor (i = 0; i < 10000; i++) {\n\t\tval = gbe->vt_xy;\n\t\tif (GET_GBE_FIELD(VT_XY, FREEZE, val) != 1)\n\t\t\tudelay(10);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (i == 10000)\n\t\tprintk(KERN_ERR \"gbefb: turn off pixel clock timed out\\n\");\n\n\t \n\tval = gbe->dotclock;\n\tSET_GBE_FIELD(DOTCLK, RUN, val, 0);\n\tgbe->dotclock = val;\n\tmdelay(10);\n\tfor (i = 0; i < 10000; i++) {\n\t\tval = gbe->dotclock;\n\t\tif (GET_GBE_FIELD(DOTCLK, RUN, val))\n\t\t\tudelay(10);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (i == 10000)\n\t\tprintk(KERN_ERR \"gbefb: turn off dotclock timed out\\n\");\n\n\t \n\tval = gbe->frm_size_tile;\n\tSET_GBE_FIELD(FRM_SIZE_TILE, FRM_FIFO_RESET, val, 1);\n\tgbe->frm_size_tile = val;\n\tSET_GBE_FIELD(FRM_SIZE_TILE, FRM_FIFO_RESET, val, 0);\n\tgbe->frm_size_tile = val;\n}\n\nstatic void gbe_turn_on(void)\n{\n\tunsigned int val, i;\n\n\t \n\tif (gbe_revision < 2) {\n\t\tval = gbe->vt_xy;\n\t\tif (GET_GBE_FIELD(VT_XY, FREEZE, val) == 0)\n\t\t\treturn;\n\t}\n\n\t \n\tval = gbe->dotclock;\n\tSET_GBE_FIELD(DOTCLK, RUN, val, 1);\n\tgbe->dotclock = val;\n\tmdelay(10);\n\tfor (i = 0; i < 10000; i++) {\n\t\tval = gbe->dotclock;\n\t\tif (GET_GBE_FIELD(DOTCLK, RUN, val) != 1)\n\t\t\tudelay(10);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (i == 10000)\n\t\tprintk(KERN_ERR \"gbefb: turn on dotclock timed out\\n\");\n\n\t \n\tval = 0;\n\tSET_GBE_FIELD(VT_XY, FREEZE, val, 0);\n\tgbe->vt_xy = val;\n\tmdelay(10);\n\tfor (i = 0; i < 10000; i++) {\n\t\tval = gbe->vt_xy;\n\t\tif (GET_GBE_FIELD(VT_XY, FREEZE, val))\n\t\t\tudelay(10);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (i == 10000)\n\t\tprintk(KERN_ERR \"gbefb: turn on pixel clock timed out\\n\");\n\n\t \n\tval = gbe->frm_control;\n\tSET_GBE_FIELD(FRM_CONTROL, FRM_DMA_ENABLE, val, 1);\n\tgbe->frm_control = val;\n\tudelay(1000);\n\tfor (i = 0; i < 10000; i++) {\n\t\tval = gbe->frm_inhwctrl;\n\t\tif (GET_GBE_FIELD(FRM_INHWCTRL, FRM_DMA_ENABLE, val) != 1)\n\t\t\tudelay(10);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (i == 10000)\n\t\tprintk(KERN_ERR \"gbefb: turn on DMA timed out\\n\");\n\n\tgbe_turned_on = 1;\n}\n\nstatic void gbe_loadcmap(void)\n{\n\tint i, j;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tfor (j = 0; j < 1000 && gbe->cm_fifo >= 63; j++)\n\t\t\tudelay(10);\n\t\tif (j == 1000)\n\t\t\tprintk(KERN_ERR \"gbefb: cmap FIFO timeout\\n\");\n\n\t\tgbe->cmap[i] = gbe_cmap[i];\n\t}\n}\n\n \nstatic int gbefb_blank(int blank, struct fb_info *info)\n{\n\t \n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\t\t \n\t\tgbe_turn_on();\n\t\tgbe_loadcmap();\n\t\tbreak;\n\n\tcase FB_BLANK_NORMAL:\t\t \n\t\tgbe_turn_off();\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic void gbefb_setup_flatpanel(struct gbe_timing_info *timing)\n{\n\tint fp_wid, fp_hgt, fp_vbs, fp_vbe;\n\tu32 outputVal = 0;\n\n\tSET_GBE_FIELD(VT_FLAGS, HDRV_INVERT, outputVal,\n\t\t(timing->flags & FB_SYNC_HOR_HIGH_ACT) ? 0 : 1);\n\tSET_GBE_FIELD(VT_FLAGS, VDRV_INVERT, outputVal,\n\t\t(timing->flags & FB_SYNC_VERT_HIGH_ACT) ? 0 : 1);\n\tgbe->vt_flags = outputVal;\n\n\t \n\tfp_wid = 1600;\n\tfp_hgt = 1024;\n\tfp_vbs = 0;\n\tfp_vbe = 1600;\n\ttiming->pll_m = 4;\n\ttiming->pll_n = 1;\n\ttiming->pll_p = 0;\n\n\toutputVal = 0;\n\tSET_GBE_FIELD(FP_DE, ON, outputVal, fp_vbs);\n\tSET_GBE_FIELD(FP_DE, OFF, outputVal, fp_vbe);\n\tgbe->fp_de = outputVal;\n\toutputVal = 0;\n\tSET_GBE_FIELD(FP_HDRV, OFF, outputVal, fp_wid);\n\tgbe->fp_hdrv = outputVal;\n\toutputVal = 0;\n\tSET_GBE_FIELD(FP_VDRV, ON, outputVal, 1);\n\tSET_GBE_FIELD(FP_VDRV, OFF, outputVal, fp_hgt + 1);\n\tgbe->fp_vdrv = outputVal;\n}\n\nstruct gbe_pll_info {\n\tint clock_rate;\n\tint fvco_min;\n\tint fvco_max;\n};\n\nstatic struct gbe_pll_info gbe_pll_table[2] = {\n\t{ 20, 80, 220 },\n\t{ 27, 80, 220 },\n};\n\nstatic int compute_gbe_timing(struct fb_var_screeninfo *var,\n\t\t\t      struct gbe_timing_info *timing)\n{\n\tint pll_m, pll_n, pll_p, error, best_m, best_n, best_p, best_error;\n\tint pixclock;\n\tstruct gbe_pll_info *gbe_pll;\n\n\tif (gbe_revision < 2)\n\t\tgbe_pll = &gbe_pll_table[0];\n\telse\n\t\tgbe_pll = &gbe_pll_table[1];\n\n\t \n\tbest_error = 1000000000;\n\tbest_n = best_m = best_p = 0;\n\tfor (pll_p = 0; pll_p < 4; pll_p++)\n\t\tfor (pll_m = 1; pll_m < 256; pll_m++)\n\t\t\tfor (pll_n = 1; pll_n < 64; pll_n++) {\n\t\t\t\tpixclock = (1000000 / gbe_pll->clock_rate) *\n\t\t\t\t\t\t(pll_n << pll_p) / pll_m;\n\n\t\t\t\terror = var->pixclock - pixclock;\n\n\t\t\t\tif (error < 0)\n\t\t\t\t\terror = -error;\n\n\t\t\t\tif (error < best_error &&\n\t\t\t\t    pll_m / pll_n >\n\t\t\t\t    gbe_pll->fvco_min / gbe_pll->clock_rate &&\n \t\t\t\t    pll_m / pll_n <\n\t\t\t\t    gbe_pll->fvco_max / gbe_pll->clock_rate) {\n\t\t\t\t\tbest_error = error;\n\t\t\t\t\tbest_m = pll_m;\n\t\t\t\t\tbest_n = pll_n;\n\t\t\t\t\tbest_p = pll_p;\n\t\t\t\t}\n\t\t\t}\n\n\tif (!best_n || !best_m)\n\t\treturn -EINVAL;\t \n\n\tpixclock = (1000000 / gbe_pll->clock_rate) *\n\t\t(best_n << best_p) / best_m;\n\n\t \n\tif (timing) {\n\t\ttiming->width = var->xres;\n\t\ttiming->height = var->yres;\n\t\ttiming->pll_m = best_m;\n\t\ttiming->pll_n = best_n;\n\t\ttiming->pll_p = best_p;\n\t\ttiming->cfreq = gbe_pll->clock_rate * 1000 * timing->pll_m /\n\t\t\t(timing->pll_n << timing->pll_p);\n\t\ttiming->htotal = var->left_margin + var->xres +\n\t\t\t\tvar->right_margin + var->hsync_len;\n\t\ttiming->vtotal = var->upper_margin + var->yres +\n\t\t\t\tvar->lower_margin + var->vsync_len;\n\t\ttiming->fields_sec = 1000 * timing->cfreq / timing->htotal *\n\t\t\t\t1000 / timing->vtotal;\n\t\ttiming->hblank_start = var->xres;\n\t\ttiming->vblank_start = var->yres;\n\t\ttiming->hblank_end = timing->htotal;\n\t\ttiming->hsync_start = var->xres + var->right_margin + 1;\n\t\ttiming->hsync_end = timing->hsync_start + var->hsync_len;\n\t\ttiming->vblank_end = timing->vtotal;\n\t\ttiming->vsync_start = var->yres + var->lower_margin + 1;\n\t\ttiming->vsync_end = timing->vsync_start + var->vsync_len;\n\t}\n\n\treturn pixclock;\n}\n\nstatic void gbe_set_timing_info(struct gbe_timing_info *timing)\n{\n\tint temp;\n\tunsigned int val;\n\n\t \n\tval = 0;\n\tSET_GBE_FIELD(DOTCLK, M, val, timing->pll_m - 1);\n\tSET_GBE_FIELD(DOTCLK, N, val, timing->pll_n - 1);\n\tSET_GBE_FIELD(DOTCLK, P, val, timing->pll_p);\n\tSET_GBE_FIELD(DOTCLK, RUN, val, 0);\t \n\tgbe->dotclock = val;\n\tmdelay(10);\n\n\t \n\tval = 0;\n\tSET_GBE_FIELD(VT_XYMAX, MAXX, val, timing->htotal);\n\tSET_GBE_FIELD(VT_XYMAX, MAXY, val, timing->vtotal);\n\tgbe->vt_xymax = val;\n\n\t \n\tval = 0;\n\tSET_GBE_FIELD(VT_VSYNC, VSYNC_ON, val, timing->vsync_start);\n\tSET_GBE_FIELD(VT_VSYNC, VSYNC_OFF, val, timing->vsync_end);\n\tgbe->vt_vsync = val;\n\tval = 0;\n\tSET_GBE_FIELD(VT_HSYNC, HSYNC_ON, val, timing->hsync_start);\n\tSET_GBE_FIELD(VT_HSYNC, HSYNC_OFF, val, timing->hsync_end);\n\tgbe->vt_hsync = val;\n\tval = 0;\n\tSET_GBE_FIELD(VT_VBLANK, VBLANK_ON, val, timing->vblank_start);\n\tSET_GBE_FIELD(VT_VBLANK, VBLANK_OFF, val, timing->vblank_end);\n\tgbe->vt_vblank = val;\n\tval = 0;\n\tSET_GBE_FIELD(VT_HBLANK, HBLANK_ON, val,\n\t\t      timing->hblank_start - 5);\n\tSET_GBE_FIELD(VT_HBLANK, HBLANK_OFF, val,\n\t\t      timing->hblank_end - 3);\n\tgbe->vt_hblank = val;\n\n\t \n\tval = 0;\n\tSET_GBE_FIELD(VT_VCMAP, VCMAP_ON, val, timing->vblank_start);\n\tSET_GBE_FIELD(VT_VCMAP, VCMAP_OFF, val, timing->vblank_end);\n\tgbe->vt_vcmap = val;\n\tval = 0;\n\tSET_GBE_FIELD(VT_HCMAP, HCMAP_ON, val, timing->hblank_start);\n\tSET_GBE_FIELD(VT_HCMAP, HCMAP_OFF, val, timing->hblank_end);\n\tgbe->vt_hcmap = val;\n\n\tval = 0;\n\ttemp = timing->vblank_start - timing->vblank_end - 1;\n\tif (temp > 0)\n\t\ttemp = -temp;\n\n\tif (flat_panel_enabled)\n\t\tgbefb_setup_flatpanel(timing);\n\n\tSET_GBE_FIELD(DID_START_XY, DID_STARTY, val, (u32) temp);\n\tif (timing->hblank_end >= 20)\n\t\tSET_GBE_FIELD(DID_START_XY, DID_STARTX, val,\n\t\t\t      timing->hblank_end - 20);\n\telse\n\t\tSET_GBE_FIELD(DID_START_XY, DID_STARTX, val,\n\t\t\t      timing->htotal - (20 - timing->hblank_end));\n\tgbe->did_start_xy = val;\n\n\tval = 0;\n\tSET_GBE_FIELD(CRS_START_XY, CRS_STARTY, val, (u32) (temp + 1));\n\tif (timing->hblank_end >= GBE_CRS_MAGIC)\n\t\tSET_GBE_FIELD(CRS_START_XY, CRS_STARTX, val,\n\t\t\t      timing->hblank_end - GBE_CRS_MAGIC);\n\telse\n\t\tSET_GBE_FIELD(CRS_START_XY, CRS_STARTX, val,\n\t\t\t      timing->htotal - (GBE_CRS_MAGIC -\n\t\t\t\t\t\ttiming->hblank_end));\n\tgbe->crs_start_xy = val;\n\n\tval = 0;\n\tSET_GBE_FIELD(VC_START_XY, VC_STARTY, val, (u32) temp);\n\tSET_GBE_FIELD(VC_START_XY, VC_STARTX, val, timing->hblank_end - 4);\n\tgbe->vc_start_xy = val;\n\n\tval = 0;\n\ttemp = timing->hblank_end - GBE_PIXEN_MAGIC_ON;\n\tif (temp < 0)\n\t\ttemp += timing->htotal;\t \n\n\tSET_GBE_FIELD(VT_HPIXEN, HPIXEN_ON, val, temp);\n\tSET_GBE_FIELD(VT_HPIXEN, HPIXEN_OFF, val,\n\t\t      ((temp + timing->width -\n\t\t\tGBE_PIXEN_MAGIC_OFF) % timing->htotal));\n\tgbe->vt_hpixen = val;\n\n\tval = 0;\n\tSET_GBE_FIELD(VT_VPIXEN, VPIXEN_ON, val, timing->vblank_end);\n\tSET_GBE_FIELD(VT_VPIXEN, VPIXEN_OFF, val, timing->vblank_start);\n\tgbe->vt_vpixen = val;\n\n\t \n\tval = 0;\n\tSET_GBE_FIELD(VT_FLAGS, SYNC_LOW, val, 1);\n\tgbe->vt_flags = val;\n}\n\n \n\nstatic int gbefb_set_par(struct fb_info *info)\n{\n\tint i;\n\tunsigned int val;\n\tint wholeTilesX, partTilesX, maxPixelsPerTileX;\n\tint height_pix;\n\tint xpmax, ypmax;\t \n\tint bytesPerPixel;\t \n\tstruct gbefb_par *par = (struct gbefb_par *) info->par;\n\n\tcompute_gbe_timing(&info->var, &par->timing);\n\n\tbytesPerPixel = info->var.bits_per_pixel / 8;\n\tinfo->fix.line_length = info->var.xres_virtual * bytesPerPixel;\n\txpmax = par->timing.width;\n\typmax = par->timing.height;\n\n\t \n\tgbe_turn_off();\n\n\t \n\tgbe_set_timing_info(&par->timing);\n\n\t \n\tval = 0;\n\tswitch (bytesPerPixel) {\n\tcase 1:\n\t\tSET_GBE_FIELD(WID, TYP, val, GBE_CMODE_I8);\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\tcase 2:\n\t\tSET_GBE_FIELD(WID, TYP, val, GBE_CMODE_ARGB5);\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\tcase 4:\n\t\tSET_GBE_FIELD(WID, TYP, val, GBE_CMODE_RGB8);\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\t}\n\tSET_GBE_FIELD(WID, BUF, val, GBE_BMODE_BOTH);\n\n\tfor (i = 0; i < 32; i++)\n\t\tgbe->mode_regs[i] = val;\n\n\t \n\tgbe->vt_intr01 = 0xffffffff;\n\tgbe->vt_intr23 = 0xffffffff;\n\n\t \n\n\t \n\t \n\t \n\t \n\tval = 0;\n\tSET_GBE_FIELD(FRM_CONTROL, FRM_TILE_PTR, val, gbe_tiles.dma >> 9);\n\tSET_GBE_FIELD(FRM_CONTROL, FRM_DMA_ENABLE, val, 0);  \n\tSET_GBE_FIELD(FRM_CONTROL, FRM_LINEAR, val, 0);\n\tgbe->frm_control = val;\n\n\tmaxPixelsPerTileX = 512 / bytesPerPixel;\n\twholeTilesX = 1;\n\tpartTilesX = 0;\n\n\t \n\tval = 0;\n\tSET_GBE_FIELD(FRM_SIZE_TILE, FRM_WIDTH_TILE, val, wholeTilesX);\n\tSET_GBE_FIELD(FRM_SIZE_TILE, FRM_RHS, val, partTilesX);\n\n\tswitch (bytesPerPixel) {\n\tcase 1:\n\t\tSET_GBE_FIELD(FRM_SIZE_TILE, FRM_DEPTH, val,\n\t\t\t      GBE_FRM_DEPTH_8);\n\t\tbreak;\n\tcase 2:\n\t\tSET_GBE_FIELD(FRM_SIZE_TILE, FRM_DEPTH, val,\n\t\t\t      GBE_FRM_DEPTH_16);\n\t\tbreak;\n\tcase 4:\n\t\tSET_GBE_FIELD(FRM_SIZE_TILE, FRM_DEPTH, val,\n\t\t\t      GBE_FRM_DEPTH_32);\n\t\tbreak;\n\t}\n\tgbe->frm_size_tile = val;\n\n\t \n\theight_pix = xpmax * ypmax / maxPixelsPerTileX;\n\n\tval = 0;\n\tSET_GBE_FIELD(FRM_SIZE_PIXEL, FB_HEIGHT_PIX, val, height_pix);\n\tgbe->frm_size_pixel = val;\n\n\t \n\tgbe->did_control = 0;\n\tgbe->ovr_width_tile = 0;\n\n\t \n\tgbe->crs_ctl = 0;\n\n\t \n\tgbe_turn_on();\n\n\t \n\tudelay(10);\n\tfor (i = 0; i < 256; i++)\n\t\tgbe->gmap[i] = (i << 24) | (i << 16) | (i << 8);\n\n\t \n\tfor (i = 0; i < 256; i++)\n\t\tgbe_cmap[i] = (i << 8) | (i << 16) | (i << 24);\n\n\tgbe_loadcmap();\n\n\treturn 0;\n}\n\nstatic void gbefb_encode_fix(struct fb_fix_screeninfo *fix,\n\t\t\t     struct fb_var_screeninfo *var)\n{\n\tmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\n\tstrcpy(fix->id, \"SGI GBE\");\n\tfix->smem_start = (unsigned long) gbe_mem;\n\tfix->smem_len = gbe_mem_size;\n\tfix->type = FB_TYPE_PACKED_PIXELS;\n\tfix->type_aux = 0;\n\tfix->accel = FB_ACCEL_NONE;\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tfix->visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\tdefault:\n\t\tfix->visual = FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\t}\n\tfix->ywrapstep = 0;\n\tfix->xpanstep = 0;\n\tfix->ypanstep = 0;\n\tfix->line_length = var->xres_virtual * var->bits_per_pixel / 8;\n\tfix->mmio_start = GBE_BASE;\n\tfix->mmio_len = sizeof(struct sgi_gbe);\n}\n\n \n\nstatic int gbefb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t     unsigned blue, unsigned transp,\n\t\t\t     struct fb_info *info)\n{\n\tint i;\n\n\tif (regno > 255)\n\t\treturn 1;\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\tif (info->var.bits_per_pixel <= 8) {\n\t\tgbe_cmap[regno] = (red << 24) | (green << 16) | (blue << 8);\n\t\tif (gbe_turned_on) {\n\t\t\t \n\t\t\tfor (i = 0; i < 1000 && gbe->cm_fifo >= 63; i++)\n\t\t\t\tudelay(10);\n\t\t\tif (i == 1000) {\n\t\t\t\tprintk(KERN_ERR \"gbefb: cmap FIFO timeout\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tgbe->cmap[regno] = gbe_cmap[regno];\n\t\t}\n\t} else if (regno < 16) {\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 15:\n\t\tcase 16:\n\t\t\tred >>= 3;\n\t\t\tgreen >>= 3;\n\t\t\tblue >>= 3;\n\t\t\tpseudo_palette[regno] =\n\t\t\t\t(red << info->var.red.offset) |\n\t\t\t\t(green << info->var.green.offset) |\n\t\t\t\t(blue << info->var.blue.offset);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tpseudo_palette[regno] =\n\t\t\t\t(red << info->var.red.offset) |\n\t\t\t\t(green << info->var.green.offset) |\n\t\t\t\t(blue << info->var.blue.offset);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int gbefb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tunsigned int line_length;\n\tstruct gbe_timing_info timing;\n\tint ret;\n\n\t \n\tif (var->bits_per_pixel <= 8)\n\t\tvar->bits_per_pixel = 8;\n\telse if (var->bits_per_pixel <= 16)\n\t\tvar->bits_per_pixel = 16;\n\telse if (var->bits_per_pixel <= 32)\n\t\tvar->bits_per_pixel = 32;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\t \n\tif ((var->xres * var->yres * var->bits_per_pixel) & 4095)\n\t\treturn -EINVAL;\n\n\tvar->grayscale = 0;\t \n\n\tret = compute_gbe_timing(var, &timing);\n\tvar->pixclock = ret;\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (var->xres > var->xres_virtual || (!ywrap && !ypan))\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres > var->yres_virtual || (!ywrap && !ypan))\n\t\tvar->yres_virtual = var->yres;\n\n\tif (var->vmode & FB_VMODE_CONUPDATE) {\n\t\tvar->vmode |= FB_VMODE_YWRAP;\n\t\tvar->xoffset = info->var.xoffset;\n\t\tvar->yoffset = info->var.yoffset;\n\t}\n\n\t \n\tvar->grayscale = 0;\n\n\t \n\tline_length = var->xres_virtual * var->bits_per_pixel / 8;\n\tif (line_length * var->yres_virtual > gbe_mem_size)\n\t\treturn -ENOMEM;\t \n\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 16:\t\t \n\t\tvar->red.offset = 10;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 5;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 32:\t\t \n\t\tvar->red.offset = 24;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 16;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 8;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 8;\n\t\tbreak;\n\t}\n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.msb_right = 0;\n\tvar->transp.msb_right = 0;\n\n\tvar->left_margin = timing.htotal - timing.hsync_end;\n\tvar->right_margin = timing.hsync_start - timing.width;\n\tvar->upper_margin = timing.vtotal - timing.vsync_end;\n\tvar->lower_margin = timing.vsync_start - timing.height;\n\tvar->hsync_len = timing.hsync_end - timing.hsync_start;\n\tvar->vsync_len = timing.vsync_end - timing.vsync_start;\n\n\treturn 0;\n}\n\nstatic int gbefb_mmap(struct fb_info *info,\n\t\t\tstruct vm_area_struct *vma)\n{\n\tunsigned long size = vma->vm_end - vma->vm_start;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\tunsigned long addr;\n\tunsigned long phys_addr, phys_size;\n\tu16 *tile;\n\n\t \n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\tif (size > gbe_mem_size)\n\t\treturn -EINVAL;\n\tif (offset > gbe_mem_size - size)\n\t\treturn -EINVAL;\n\n\t \n\t \n#ifdef CONFIG_MIPS\n\tpgprot_val(vma->vm_page_prot) =\n\t\tpgprot_fb(pgprot_val(vma->vm_page_prot));\n#endif\n\t \n\n\t \n\ttile = &gbe_tiles.cpu[offset >> TILE_SHIFT];\n\taddr = vma->vm_start;\n\toffset &= TILE_MASK;\n\n\t \n\tdo {\n\t\tphys_addr = (((unsigned long) (*tile)) << TILE_SHIFT) + offset;\n\t\tif ((offset + size) < TILE_SIZE)\n\t\t\tphys_size = size;\n\t\telse\n\t\t\tphys_size = TILE_SIZE - offset;\n\n\t\tif (remap_pfn_range(vma, addr, phys_addr >> PAGE_SHIFT,\n\t\t\t\t\t\tphys_size, vma->vm_page_prot))\n\t\t\treturn -EAGAIN;\n\n\t\toffset = 0;\n\t\tsize -= phys_size;\n\t\taddr += phys_size;\n\t\ttile++;\n\t} while (size);\n\n\treturn 0;\n}\n\nstatic const struct fb_ops gbefb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= gbefb_check_var,\n\t.fb_set_par\t= gbefb_set_par,\n\t.fb_setcolreg\t= gbefb_setcolreg,\n\t.fb_mmap\t= gbefb_mmap,\n\t.fb_blank\t= gbefb_blank,\n\t.fb_fillrect\t= cfb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n};\n\n \n\nstatic ssize_t gbefb_show_memsize(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", gbe_mem_size);\n}\n\nstatic DEVICE_ATTR(size, S_IRUGO, gbefb_show_memsize, NULL);\n\nstatic ssize_t gbefb_show_rev(struct device *device, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", gbe_revision);\n}\n\nstatic DEVICE_ATTR(revision, S_IRUGO, gbefb_show_rev, NULL);\n\nstatic struct attribute *gbefb_attrs[] = {\n\t&dev_attr_size.attr,\n\t&dev_attr_revision.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(gbefb);\n\n \n\nstatic int gbefb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!strncmp(this_opt, \"monitor:\", 8)) {\n\t\t\tif (!strncmp(this_opt + 8, \"crt\", 3)) {\n\t\t\t\tflat_panel_enabled = 0;\n\t\t\t\tdefault_var = &default_var_CRT;\n\t\t\t\tdefault_mode = &default_mode_CRT;\n\t\t\t} else if (!strncmp(this_opt + 8, \"1600sw\", 6) ||\n\t\t\t\t   !strncmp(this_opt + 8, \"lcd\", 3)) {\n\t\t\t\tflat_panel_enabled = 1;\n\t\t\t\tdefault_var = &default_var_LCD;\n\t\t\t\tdefault_mode = &default_mode_LCD;\n\t\t\t}\n\t\t} else if (!strncmp(this_opt, \"mem:\", 4)) {\n\t\t\tgbe_mem_size = memparse(this_opt + 4, &this_opt);\n\t\t\tif (gbe_mem_size > CONFIG_FB_GBE_MEM * 1024 * 1024)\n\t\t\t\tgbe_mem_size = CONFIG_FB_GBE_MEM * 1024 * 1024;\n\t\t\tif (gbe_mem_size < TILE_SIZE)\n\t\t\t\tgbe_mem_size = TILE_SIZE;\n\t\t} else\n\t\t\tmode_option = this_opt;\n\t}\n\treturn 0;\n}\n\nstatic int gbefb_probe(struct platform_device *p_dev)\n{\n\tint i, ret = 0;\n\tstruct fb_info *info;\n\tstruct gbefb_par *par;\n#ifndef MODULE\n\tchar *options = NULL;\n#endif\n\n\tinfo = framebuffer_alloc(sizeof(struct gbefb_par), &p_dev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n#ifndef MODULE\n\tif (fb_get_options(\"gbefb\", &options)) {\n\t\tret = -ENODEV;\n\t\tgoto out_release_framebuffer;\n\t}\n\tgbefb_setup(options);\n#endif\n\n\tif (!request_mem_region(GBE_BASE, sizeof(struct sgi_gbe), \"GBE\")) {\n\t\tprintk(KERN_ERR \"gbefb: couldn't reserve mmio region\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_release_framebuffer;\n\t}\n\n\tgbe = (struct sgi_gbe *) devm_ioremap(&p_dev->dev, GBE_BASE,\n\t\t\t\t\t      sizeof(struct sgi_gbe));\n\tif (!gbe) {\n\t\tprintk(KERN_ERR \"gbefb: couldn't map mmio region\\n\");\n\t\tret = -ENXIO;\n\t\tgoto out_release_mem_region;\n\t}\n\tgbe_revision = gbe->ctrlstat & 15;\n\n\tgbe_tiles.cpu = dmam_alloc_coherent(&p_dev->dev,\n\t\t\t\tGBE_TLB_SIZE * sizeof(uint16_t),\n\t\t\t\t&gbe_tiles.dma, GFP_KERNEL);\n\tif (!gbe_tiles.cpu) {\n\t\tprintk(KERN_ERR \"gbefb: couldn't allocate tiles table\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_release_mem_region;\n\t}\n\n\tif (gbe_mem_phys) {\n\t\t \n\t\tgbe_mem = devm_ioremap_wc(&p_dev->dev, gbe_mem_phys,\n\t\t\t\t\t  gbe_mem_size);\n\t\tif (!gbe_mem) {\n\t\t\tprintk(KERN_ERR \"gbefb: couldn't map framebuffer\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_release_mem_region;\n\t\t}\n\n\t\tgbe_dma_addr = 0;\n\t} else {\n\t\t \n\t\tgbe_mem = dmam_alloc_attrs(&p_dev->dev, gbe_mem_size,\n\t\t\t\t&gbe_dma_addr, GFP_KERNEL,\n\t\t\t\tDMA_ATTR_WRITE_COMBINE);\n\t\tif (!gbe_mem) {\n\t\t\tprintk(KERN_ERR \"gbefb: couldn't allocate framebuffer memory\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_release_mem_region;\n\t\t}\n\n\t\tgbe_mem_phys = (unsigned long) gbe_dma_addr;\n\t}\n\n\tpar = info->par;\n\tpar->wc_cookie = arch_phys_wc_add(gbe_mem_phys, gbe_mem_size);\n\n\t \n\tfor (i = 0; i < (gbe_mem_size >> TILE_SHIFT); i++)\n\t\tgbe_tiles.cpu[i] = (gbe_mem_phys >> TILE_SHIFT) + i;\n\n\tinfo->fbops = &gbefb_ops;\n\tinfo->pseudo_palette = pseudo_palette;\n\tinfo->screen_base = gbe_mem;\n\tfb_alloc_cmap(&info->cmap, 256, 0);\n\n\t \n\tgbe_reset();\n\n\t \n\tif (fb_find_mode(&par->var, info, mode_option, NULL, 0,\n\t\t\t default_mode, 8) == 0)\n\t\tpar->var = *default_var;\n\tinfo->var = par->var;\n\tgbefb_check_var(&par->var, info);\n\tgbefb_encode_fix(&info->fix, &info->var);\n\n\tif (register_framebuffer(info) < 0) {\n\t\tprintk(KERN_ERR \"gbefb: couldn't register framebuffer\\n\");\n\t\tret = -ENXIO;\n\t\tgoto out_gbe_unmap;\n\t}\n\n\tplatform_set_drvdata(p_dev, info);\n\n\tfb_info(info, \"%s rev %d @ 0x%08x using %dkB memory\\n\",\n\t\tinfo->fix.id, gbe_revision, (unsigned)GBE_BASE,\n\t\tgbe_mem_size >> 10);\n\n\treturn 0;\n\nout_gbe_unmap:\n\tarch_phys_wc_del(par->wc_cookie);\nout_release_mem_region:\n\trelease_mem_region(GBE_BASE, sizeof(struct sgi_gbe));\nout_release_framebuffer:\n\tframebuffer_release(info);\n\n\treturn ret;\n}\n\nstatic void gbefb_remove(struct platform_device* p_dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(p_dev);\n\tstruct gbefb_par *par = info->par;\n\n\tunregister_framebuffer(info);\n\tgbe_turn_off();\n\tarch_phys_wc_del(par->wc_cookie);\n\trelease_mem_region(GBE_BASE, sizeof(struct sgi_gbe));\n\tframebuffer_release(info);\n}\n\nstatic struct platform_driver gbefb_driver = {\n\t.probe = gbefb_probe,\n\t.remove_new = gbefb_remove,\n\t.driver\t= {\n\t\t.name = \"gbefb\",\n\t\t.dev_groups\t= gbefb_groups,\n\t},\n};\n\nstatic struct platform_device *gbefb_device;\n\nstatic int __init gbefb_init(void)\n{\n\tint ret = platform_driver_register(&gbefb_driver);\n\tif (IS_ENABLED(CONFIG_SGI_IP32) && !ret) {\n\t\tgbefb_device = platform_device_alloc(\"gbefb\", 0);\n\t\tif (gbefb_device) {\n\t\t\tret = platform_device_add(gbefb_device);\n\t\t} else {\n\t\t\tret = -ENOMEM;\n\t\t}\n\t\tif (ret) {\n\t\t\tplatform_device_put(gbefb_device);\n\t\t\tplatform_driver_unregister(&gbefb_driver);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void __exit gbefb_exit(void)\n{\n\tplatform_device_unregister(gbefb_device);\n\tplatform_driver_unregister(&gbefb_driver);\n}\n\nmodule_init(gbefb_init);\nmodule_exit(gbefb_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}