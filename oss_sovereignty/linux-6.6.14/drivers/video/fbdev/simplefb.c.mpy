{
  "module_name": "simplefb.c",
  "hash_id": "3cbc0de8333df9461b1cdfa49e8495f963f88f3af0da058e1232a92d35d24403",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/simplefb.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/errno.h>\n#include <linux/fb.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_data/simplefb.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_clk.h>\n#include <linux/of_platform.h>\n#include <linux/parser.h>\n#include <linux/regulator/consumer.h>\n\nstatic const struct fb_fix_screeninfo simplefb_fix = {\n\t.id\t\t= \"simple\",\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.visual\t\t= FB_VISUAL_TRUECOLOR,\n\t.accel\t\t= FB_ACCEL_NONE,\n};\n\nstatic const struct fb_var_screeninfo simplefb_var = {\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\n#define PSEUDO_PALETTE_SIZE 16\n\nstatic int simplefb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t      u_int transp, struct fb_info *info)\n{\n\tu32 *pal = info->pseudo_palette;\n\tu32 cr = red >> (16 - info->var.red.length);\n\tu32 cg = green >> (16 - info->var.green.length);\n\tu32 cb = blue >> (16 - info->var.blue.length);\n\tu32 value;\n\n\tif (regno >= PSEUDO_PALETTE_SIZE)\n\t\treturn -EINVAL;\n\n\tvalue = (cr << info->var.red.offset) |\n\t\t(cg << info->var.green.offset) |\n\t\t(cb << info->var.blue.offset);\n\tif (info->var.transp.length > 0) {\n\t\tu32 mask = (1 << info->var.transp.length) - 1;\n\t\tmask <<= info->var.transp.offset;\n\t\tvalue |= mask;\n\t}\n\tpal[regno] = value;\n\n\treturn 0;\n}\n\nstruct simplefb_par {\n\tu32 palette[PSEUDO_PALETTE_SIZE];\n\tresource_size_t base;\n\tresource_size_t size;\n\tstruct resource *mem;\n#if defined CONFIG_OF && defined CONFIG_COMMON_CLK\n\tbool clks_enabled;\n\tunsigned int clk_count;\n\tstruct clk **clks;\n#endif\n#if defined CONFIG_OF && defined CONFIG_REGULATOR\n\tbool regulators_enabled;\n\tu32 regulator_count;\n\tstruct regulator **regulators;\n#endif\n};\n\nstatic void simplefb_clocks_destroy(struct simplefb_par *par);\nstatic void simplefb_regulators_destroy(struct simplefb_par *par);\n\n \nstatic void simplefb_destroy(struct fb_info *info)\n{\n\tstruct simplefb_par *par = info->par;\n\tstruct resource *mem = par->mem;\n\n\tsimplefb_regulators_destroy(info->par);\n\tsimplefb_clocks_destroy(info->par);\n\tif (info->screen_base)\n\t\tiounmap(info->screen_base);\n\n\tframebuffer_release(info);\n\n\tif (mem)\n\t\trelease_mem_region(mem->start, resource_size(mem));\n}\n\nstatic const struct fb_ops simplefb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_destroy\t= simplefb_destroy,\n\t.fb_setcolreg\t= simplefb_setcolreg,\n};\n\nstatic struct simplefb_format simplefb_formats[] = SIMPLEFB_FORMATS;\n\nstruct simplefb_params {\n\tu32 width;\n\tu32 height;\n\tu32 stride;\n\tstruct simplefb_format *format;\n};\n\nstatic int simplefb_parse_dt(struct platform_device *pdev,\n\t\t\t   struct simplefb_params *params)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret;\n\tconst char *format;\n\tint i;\n\n\tret = of_property_read_u32(np, \"width\", &params->width);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't parse width property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"height\", &params->height);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't parse height property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"stride\", &params->stride);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't parse stride property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_string(np, \"format\", &format);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't parse format property\\n\");\n\t\treturn ret;\n\t}\n\tparams->format = NULL;\n\tfor (i = 0; i < ARRAY_SIZE(simplefb_formats); i++) {\n\t\tif (strcmp(format, simplefb_formats[i].name))\n\t\t\tcontinue;\n\t\tparams->format = &simplefb_formats[i];\n\t\tbreak;\n\t}\n\tif (!params->format) {\n\t\tdev_err(&pdev->dev, \"Invalid format value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int simplefb_parse_pd(struct platform_device *pdev,\n\t\t\t     struct simplefb_params *params)\n{\n\tstruct simplefb_platform_data *pd = dev_get_platdata(&pdev->dev);\n\tint i;\n\n\tparams->width = pd->width;\n\tparams->height = pd->height;\n\tparams->stride = pd->stride;\n\n\tparams->format = NULL;\n\tfor (i = 0; i < ARRAY_SIZE(simplefb_formats); i++) {\n\t\tif (strcmp(pd->format, simplefb_formats[i].name))\n\t\t\tcontinue;\n\n\t\tparams->format = &simplefb_formats[i];\n\t\tbreak;\n\t}\n\n\tif (!params->format) {\n\t\tdev_err(&pdev->dev, \"Invalid format value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#if defined CONFIG_OF && defined CONFIG_COMMON_CLK\n \nstatic int simplefb_clocks_get(struct simplefb_par *par,\n\t\t\t       struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct clk *clock;\n\tint i;\n\n\tif (dev_get_platdata(&pdev->dev) || !np)\n\t\treturn 0;\n\n\tpar->clk_count = of_clk_get_parent_count(np);\n\tif (!par->clk_count)\n\t\treturn 0;\n\n\tpar->clks = kcalloc(par->clk_count, sizeof(struct clk *), GFP_KERNEL);\n\tif (!par->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < par->clk_count; i++) {\n\t\tclock = of_clk_get(np, i);\n\t\tif (IS_ERR(clock)) {\n\t\t\tif (PTR_ERR(clock) == -EPROBE_DEFER) {\n\t\t\t\twhile (--i >= 0) {\n\t\t\t\t\tclk_put(par->clks[i]);\n\t\t\t\t}\n\t\t\t\tkfree(par->clks);\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\t}\n\t\t\tdev_err(&pdev->dev, \"%s: clock %d not found: %ld\\n\",\n\t\t\t\t__func__, i, PTR_ERR(clock));\n\t\t\tcontinue;\n\t\t}\n\t\tpar->clks[i] = clock;\n\t}\n\n\treturn 0;\n}\n\nstatic void simplefb_clocks_enable(struct simplefb_par *par,\n\t\t\t\t   struct platform_device *pdev)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < par->clk_count; i++) {\n\t\tif (par->clks[i]) {\n\t\t\tret = clk_prepare_enable(par->clks[i]);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"%s: failed to enable clock %d: %d\\n\",\n\t\t\t\t\t__func__, i, ret);\n\t\t\t\tclk_put(par->clks[i]);\n\t\t\t\tpar->clks[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tpar->clks_enabled = true;\n}\n\nstatic void simplefb_clocks_destroy(struct simplefb_par *par)\n{\n\tint i;\n\n\tif (!par->clks)\n\t\treturn;\n\n\tfor (i = 0; i < par->clk_count; i++) {\n\t\tif (par->clks[i]) {\n\t\t\tif (par->clks_enabled)\n\t\t\t\tclk_disable_unprepare(par->clks[i]);\n\t\t\tclk_put(par->clks[i]);\n\t\t}\n\t}\n\n\tkfree(par->clks);\n}\n#else\nstatic int simplefb_clocks_get(struct simplefb_par *par,\n\tstruct platform_device *pdev) { return 0; }\nstatic void simplefb_clocks_enable(struct simplefb_par *par,\n\tstruct platform_device *pdev) { }\nstatic void simplefb_clocks_destroy(struct simplefb_par *par) { }\n#endif\n\n#if defined CONFIG_OF && defined CONFIG_REGULATOR\n\n#define SUPPLY_SUFFIX \"-supply\"\n\n \nstatic int simplefb_regulators_get(struct simplefb_par *par,\n\t\t\t\t   struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct property *prop;\n\tstruct regulator *regulator;\n\tconst char *p;\n\tint count = 0, i = 0;\n\n\tif (dev_get_platdata(&pdev->dev) || !np)\n\t\treturn 0;\n\n\t \n\tfor_each_property_of_node(np, prop) {\n\t\tp = strstr(prop->name, SUPPLY_SUFFIX);\n\t\tif (p && p != prop->name)\n\t\t\tcount++;\n\t}\n\n\tif (!count)\n\t\treturn 0;\n\n\tpar->regulators = devm_kcalloc(&pdev->dev, count,\n\t\t\t\t       sizeof(struct regulator *), GFP_KERNEL);\n\tif (!par->regulators)\n\t\treturn -ENOMEM;\n\n\t \n\tfor_each_property_of_node(np, prop) {\n\t\tchar name[32];  \n\n\t\tp = strstr(prop->name, SUPPLY_SUFFIX);\n\t\tif (!p || p == prop->name)\n\t\t\tcontinue;\n\n\t\tstrscpy(name, prop->name,\n\t\t\tstrlen(prop->name) - strlen(SUPPLY_SUFFIX) + 1);\n\t\tregulator = devm_regulator_get_optional(&pdev->dev, name);\n\t\tif (IS_ERR(regulator)) {\n\t\t\tif (PTR_ERR(regulator) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\tdev_err(&pdev->dev, \"regulator %s not found: %ld\\n\",\n\t\t\t\tname, PTR_ERR(regulator));\n\t\t\tcontinue;\n\t\t}\n\t\tpar->regulators[i++] = regulator;\n\t}\n\tpar->regulator_count = i;\n\n\treturn 0;\n}\n\nstatic void simplefb_regulators_enable(struct simplefb_par *par,\n\t\t\t\t       struct platform_device *pdev)\n{\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < par->regulator_count; i++) {\n\t\tret = regulator_enable(par->regulators[i]);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to enable regulator %d: %d\\n\",\n\t\t\t\ti, ret);\n\t\t\tdevm_regulator_put(par->regulators[i]);\n\t\t\tpar->regulators[i] = NULL;\n\t\t}\n\t}\n\tpar->regulators_enabled = true;\n}\n\nstatic void simplefb_regulators_destroy(struct simplefb_par *par)\n{\n\tint i;\n\n\tif (!par->regulators || !par->regulators_enabled)\n\t\treturn;\n\n\tfor (i = 0; i < par->regulator_count; i++)\n\t\tif (par->regulators[i])\n\t\t\tregulator_disable(par->regulators[i]);\n}\n#else\nstatic int simplefb_regulators_get(struct simplefb_par *par,\n\tstruct platform_device *pdev) { return 0; }\nstatic void simplefb_regulators_enable(struct simplefb_par *par,\n\tstruct platform_device *pdev) { }\nstatic void simplefb_regulators_destroy(struct simplefb_par *par) { }\n#endif\n\nstatic int simplefb_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct simplefb_params params;\n\tstruct fb_info *info;\n\tstruct simplefb_par *par;\n\tstruct resource *res, *mem;\n\n\tif (fb_get_options(\"simplefb\", NULL))\n\t\treturn -ENODEV;\n\n\tret = -ENODEV;\n\tif (dev_get_platdata(&pdev->dev))\n\t\tret = simplefb_parse_pd(pdev, &params);\n\telse if (pdev->dev.of_node)\n\t\tret = simplefb_parse_dt(pdev, &params);\n\n\tif (ret)\n\t\treturn ret;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"No memory resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmem = request_mem_region(res->start, resource_size(res), \"simplefb\");\n\tif (!mem) {\n\t\t \n\t\tdev_warn(&pdev->dev, \"simplefb: cannot reserve video memory at %pR\\n\", res);\n\t\tmem = res;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct simplefb_par), &pdev->dev);\n\tif (!info) {\n\t\tret = -ENOMEM;\n\t\tgoto error_release_mem_region;\n\t}\n\tplatform_set_drvdata(pdev, info);\n\n\tpar = info->par;\n\n\tinfo->fix = simplefb_fix;\n\tinfo->fix.smem_start = mem->start;\n\tinfo->fix.smem_len = resource_size(mem);\n\tinfo->fix.line_length = params.stride;\n\n\tinfo->var = simplefb_var;\n\tinfo->var.xres = params.width;\n\tinfo->var.yres = params.height;\n\tinfo->var.xres_virtual = params.width;\n\tinfo->var.yres_virtual = params.height;\n\tinfo->var.bits_per_pixel = params.format->bits_per_pixel;\n\tinfo->var.red = params.format->red;\n\tinfo->var.green = params.format->green;\n\tinfo->var.blue = params.format->blue;\n\tinfo->var.transp = params.format->transp;\n\n\tpar->base = info->fix.smem_start;\n\tpar->size = info->fix.smem_len;\n\n\tinfo->fbops = &simplefb_ops;\n\tinfo->screen_base = ioremap_wc(info->fix.smem_start,\n\t\t\t\t       info->fix.smem_len);\n\tif (!info->screen_base) {\n\t\tret = -ENOMEM;\n\t\tgoto error_fb_release;\n\t}\n\tinfo->pseudo_palette = par->palette;\n\n\tret = simplefb_clocks_get(par, pdev);\n\tif (ret < 0)\n\t\tgoto error_unmap;\n\n\tret = simplefb_regulators_get(par, pdev);\n\tif (ret < 0)\n\t\tgoto error_clocks;\n\n\tsimplefb_clocks_enable(par, pdev);\n\tsimplefb_regulators_enable(par, pdev);\n\n\tdev_info(&pdev->dev, \"framebuffer at 0x%lx, 0x%x bytes\\n\",\n\t\t\t     info->fix.smem_start, info->fix.smem_len);\n\tdev_info(&pdev->dev, \"format=%s, mode=%dx%dx%d, linelength=%d\\n\",\n\t\t\t     params.format->name,\n\t\t\t     info->var.xres, info->var.yres,\n\t\t\t     info->var.bits_per_pixel, info->fix.line_length);\n\n\tif (mem != res)\n\t\tpar->mem = mem;  \n\n\tret = devm_aperture_acquire_for_platform_device(pdev, par->base, par->size);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to acquire aperture: %d\\n\", ret);\n\t\tgoto error_regulators;\n\t}\n\tret = register_framebuffer(info);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Unable to register simplefb: %d\\n\", ret);\n\t\tgoto error_regulators;\n\t}\n\n\tdev_info(&pdev->dev, \"fb%d: simplefb registered!\\n\", info->node);\n\n\treturn 0;\n\nerror_regulators:\n\tsimplefb_regulators_destroy(par);\nerror_clocks:\n\tsimplefb_clocks_destroy(par);\nerror_unmap:\n\tiounmap(info->screen_base);\nerror_fb_release:\n\tframebuffer_release(info);\nerror_release_mem_region:\n\tif (mem != res)\n\t\trelease_mem_region(mem->start, resource_size(mem));\n\treturn ret;\n}\n\nstatic void simplefb_remove(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\n\t \n\tunregister_framebuffer(info);\n}\n\nstatic const struct of_device_id simplefb_of_match[] = {\n\t{ .compatible = \"simple-framebuffer\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, simplefb_of_match);\n\nstatic struct platform_driver simplefb_driver = {\n\t.driver = {\n\t\t.name = \"simple-framebuffer\",\n\t\t.of_match_table = simplefb_of_match,\n\t},\n\t.probe = simplefb_probe,\n\t.remove_new = simplefb_remove,\n};\n\nmodule_platform_driver(simplefb_driver);\n\nMODULE_AUTHOR(\"Stephen Warren <swarren@wwwdotorg.org>\");\nMODULE_DESCRIPTION(\"Simple framebuffer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}