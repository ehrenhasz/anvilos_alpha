{
  "module_name": "lcdc.c",
  "hash_id": "5c145b3cebfc7f97d2dfb06e92ba7e84c4f884b5a3455b9954d556042d1aca14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap/lcdc.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/dma-mapping.h>\n#include <linux/vmalloc.h>\n#include <linux/clk.h>\n#include <linux/gfp.h>\n\n#include <linux/soc/ti/omap1-io.h>\n#include <linux/soc/ti/omap1-soc.h>\n#include <linux/omap-dma.h>\n\n#include <asm/mach-types.h>\n\n#include \"omapfb.h\"\n\n#include \"lcdc.h\"\n#include \"lcd_dma.h\"\n\n#define MODULE_NAME\t\t\t\"lcdc\"\n\n#define MAX_PALETTE_SIZE\t\tPAGE_SIZE\n\nenum lcdc_load_mode {\n\tOMAP_LCDC_LOAD_PALETTE,\n\tOMAP_LCDC_LOAD_FRAME,\n\tOMAP_LCDC_LOAD_PALETTE_AND_FRAME\n};\n\nstatic struct omap_lcd_controller {\n\tenum omapfb_update_mode\tupdate_mode;\n\tint\t\t\text_mode;\n\n\tunsigned long\t\tframe_offset;\n\tint\t\t\tscreen_width;\n\tint\t\t\txres;\n\tint\t\t\tyres;\n\n\tenum omapfb_color_format\tcolor_mode;\n\tint\t\t\tbpp;\n\tvoid\t\t\t*palette_virt;\n\tdma_addr_t\t\tpalette_phys;\n\tint\t\t\tpalette_code;\n\tint\t\t\tpalette_size;\n\n\tunsigned int\t\tirq_mask;\n\tstruct completion\tlast_frame_complete;\n\tstruct completion\tpalette_load_complete;\n\tstruct clk\t\t*lcd_ck;\n\tstruct omapfb_device\t*fbdev;\n\n\tvoid\t\t\t(*dma_callback)(void *data);\n\tvoid\t\t\t*dma_callback_data;\n\n\tdma_addr_t\t\tvram_phys;\n\tvoid\t\t\t*vram_virt;\n\tunsigned long\t\tvram_size;\n} lcdc;\n\nstatic inline void enable_irqs(int mask)\n{\n\tlcdc.irq_mask |= mask;\n}\n\nstatic inline void disable_irqs(int mask)\n{\n\tlcdc.irq_mask &= ~mask;\n}\n\nstatic void set_load_mode(enum lcdc_load_mode mode)\n{\n\tu32 l;\n\n\tl = omap_readl(OMAP_LCDC_CONTROL);\n\tl &= ~(3 << 20);\n\tswitch (mode) {\n\tcase OMAP_LCDC_LOAD_PALETTE:\n\t\tl |= 1 << 20;\n\t\tbreak;\n\tcase OMAP_LCDC_LOAD_FRAME:\n\t\tl |= 2 << 20;\n\t\tbreak;\n\tcase OMAP_LCDC_LOAD_PALETTE_AND_FRAME:\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tomap_writel(l, OMAP_LCDC_CONTROL);\n}\n\nstatic void enable_controller(void)\n{\n\tu32 l;\n\n\tl = omap_readl(OMAP_LCDC_CONTROL);\n\tl |= OMAP_LCDC_CTRL_LCD_EN;\n\tl &= ~OMAP_LCDC_IRQ_MASK;\n\tl |= lcdc.irq_mask | OMAP_LCDC_IRQ_DONE;\t \n\tomap_writel(l, OMAP_LCDC_CONTROL);\n}\n\nstatic void disable_controller_async(void)\n{\n\tu32 l;\n\tu32 mask;\n\n\tl = omap_readl(OMAP_LCDC_CONTROL);\n\tmask = OMAP_LCDC_CTRL_LCD_EN | OMAP_LCDC_IRQ_MASK;\n\t \n\tmask &= ~OMAP_LCDC_IRQ_DONE;\n\tl &= ~mask;\n\tomap_writel(l, OMAP_LCDC_CONTROL);\n}\n\nstatic void disable_controller(void)\n{\n\tinit_completion(&lcdc.last_frame_complete);\n\tdisable_controller_async();\n\tif (!wait_for_completion_timeout(&lcdc.last_frame_complete,\n\t\t\t\tmsecs_to_jiffies(500)))\n\t\tdev_err(lcdc.fbdev->dev, \"timeout waiting for FRAME DONE\\n\");\n}\n\nstatic void reset_controller(u32 status)\n{\n\tstatic unsigned long reset_count;\n\tstatic unsigned long last_jiffies;\n\n\tdisable_controller_async();\n\treset_count++;\n\tif (reset_count == 1 || time_after(jiffies, last_jiffies + HZ)) {\n\t\tdev_err(lcdc.fbdev->dev,\n\t\t\t  \"resetting (status %#010x,reset count %lu)\\n\",\n\t\t\t  status, reset_count);\n\t\tlast_jiffies = jiffies;\n\t}\n\tif (reset_count < 100) {\n\t\tenable_controller();\n\t} else {\n\t\treset_count = 0;\n\t\tdev_err(lcdc.fbdev->dev,\n\t\t\t\"too many reset attempts, giving up.\\n\");\n\t}\n}\n\n \nstatic void setup_lcd_dma(void)\n{\n\tstatic const int dma_elem_type[] = {\n\t\t0,\n\t\tOMAP_DMA_DATA_TYPE_S8,\n\t\tOMAP_DMA_DATA_TYPE_S16,\n\t\t0,\n\t\tOMAP_DMA_DATA_TYPE_S32,\n\t};\n\tstruct omapfb_plane_struct *plane = lcdc.fbdev->fb_info[0]->par;\n\tstruct fb_var_screeninfo *var = &lcdc.fbdev->fb_info[0]->var;\n\tunsigned long\tsrc;\n\tint\t\tesize, xelem, yelem;\n\n\tsrc = lcdc.vram_phys + lcdc.frame_offset;\n\n\tswitch (var->rotate) {\n\tcase 0:\n\t\tif (plane->info.mirror || (src & 3) ||\n\t\t    lcdc.color_mode == OMAPFB_COLOR_YUV420 ||\n\t\t    (lcdc.xres & 1))\n\t\t\tesize = 2;\n\t\telse\n\t\t\tesize = 4;\n\t\txelem = lcdc.xres * lcdc.bpp / 8 / esize;\n\t\tyelem = lcdc.yres;\n\t\tbreak;\n\tcase 90:\n\tcase 180:\n\tcase 270:\n\t\tif (cpu_is_omap15xx()) {\n\t\t\tBUG();\n\t\t}\n\t\tesize = 2;\n\t\txelem = lcdc.yres * lcdc.bpp / 16;\n\t\tyelem = lcdc.xres;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n#ifdef VERBOSE\n\tdev_dbg(lcdc.fbdev->dev,\n\t\t \"setup_dma: src %#010lx esize %d xelem %d yelem %d\\n\",\n\t\t src, esize, xelem, yelem);\n#endif\n\tomap_set_lcd_dma_b1(src, xelem, yelem, dma_elem_type[esize]);\n\tif (!cpu_is_omap15xx()) {\n\t\tint bpp = lcdc.bpp;\n\n\t\t \n\t\tif (lcdc.color_mode == OMAPFB_COLOR_YUV420)\n\t\t\tbpp = 16;\n\t\t \n\t\tomap_set_lcd_dma_b1_vxres(\n\t\t\tlcdc.screen_width * bpp / 8 / esize);\n\t\t \n\t\tomap_set_lcd_dma_b1_rotation(var->rotate);\n\t\tomap_set_lcd_dma_b1_mirror(plane->info.mirror);\n\t}\n\tomap_setup_lcd_dma();\n}\n\nstatic irqreturn_t lcdc_irq_handler(int irq, void *dev_id)\n{\n\tu32 status;\n\n\tstatus = omap_readl(OMAP_LCDC_STATUS);\n\n\tif (status & (OMAP_LCDC_STAT_FUF | OMAP_LCDC_STAT_SYNC_LOST))\n\t\treset_controller(status);\n\telse {\n\t\tif (status & OMAP_LCDC_STAT_DONE) {\n\t\t\tu32 l;\n\n\t\t\t \n\t\t\tl = omap_readl(OMAP_LCDC_CONTROL);\n\t\t\tl &= ~OMAP_LCDC_IRQ_DONE;\n\t\t\tomap_writel(l, OMAP_LCDC_CONTROL);\n\t\t\tcomplete(&lcdc.last_frame_complete);\n\t\t}\n\t\tif (status & OMAP_LCDC_STAT_LOADED_PALETTE) {\n\t\t\tdisable_controller_async();\n\t\t\tcomplete(&lcdc.palette_load_complete);\n\t\t}\n\t}\n\n\t \n\tstatus &= ~(OMAP_LCDC_STAT_VSYNC |\n\t\t    OMAP_LCDC_STAT_LOADED_PALETTE |\n\t\t    OMAP_LCDC_STAT_ABC |\n\t\t    OMAP_LCDC_STAT_LINE_INT);\n\tomap_writel(status, OMAP_LCDC_STATUS);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int omap_lcdc_setup_plane(int plane, int channel_out,\n\t\t\t\t unsigned long offset, int screen_width,\n\t\t\t\t int pos_x, int pos_y, int width, int height,\n\t\t\t\t int color_mode)\n{\n\tstruct fb_var_screeninfo *var = &lcdc.fbdev->fb_info[0]->var;\n\tstruct lcd_panel *panel = lcdc.fbdev->panel;\n\tint rot_x, rot_y;\n\n\tif (var->rotate == 0) {\n\t\trot_x = panel->x_res;\n\t\trot_y = panel->y_res;\n\t} else {\n\t\trot_x = panel->y_res;\n\t\trot_y = panel->x_res;\n\t}\n\tif (plane != 0 || channel_out != 0 || pos_x != 0 || pos_y != 0 ||\n\t    width > rot_x || height > rot_y) {\n#ifdef VERBOSE\n\t\tdev_dbg(lcdc.fbdev->dev,\n\t\t\t\"invalid plane params plane %d pos_x %d pos_y %d \"\n\t\t\t\"w %d h %d\\n\", plane, pos_x, pos_y, width, height);\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\tlcdc.frame_offset = offset;\n\tlcdc.xres = width;\n\tlcdc.yres = height;\n\tlcdc.screen_width = screen_width;\n\tlcdc.color_mode = color_mode;\n\n\tswitch (color_mode) {\n\tcase OMAPFB_COLOR_CLUT_8BPP:\n\t\tlcdc.bpp = 8;\n\t\tlcdc.palette_code = 0x3000;\n\t\tlcdc.palette_size = 512;\n\t\tbreak;\n\tcase OMAPFB_COLOR_RGB565:\n\t\tlcdc.bpp = 16;\n\t\tlcdc.palette_code = 0x4000;\n\t\tlcdc.palette_size = 32;\n\t\tbreak;\n\tcase OMAPFB_COLOR_RGB444:\n\t\tlcdc.bpp = 16;\n\t\tlcdc.palette_code = 0x4000;\n\t\tlcdc.palette_size = 32;\n\t\tbreak;\n\tcase OMAPFB_COLOR_YUV420:\n\t\tif (lcdc.ext_mode) {\n\t\t\tlcdc.bpp = 12;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase OMAPFB_COLOR_YUV422:\n\t\tif (lcdc.ext_mode) {\n\t\t\tlcdc.bpp = 16;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tdev_dbg(lcdc.fbdev->dev, \"invalid color mode %d\\n\", color_mode);\n\t\tBUG();\n\t\treturn -1;\n\t}\n\n\tif (lcdc.ext_mode) {\n\t\tsetup_lcd_dma();\n\t\treturn 0;\n\t}\n\n\tif (lcdc.update_mode == OMAPFB_AUTO_UPDATE) {\n\t\tdisable_controller();\n\t\tomap_stop_lcd_dma();\n\t\tsetup_lcd_dma();\n\t\tenable_controller();\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_lcdc_enable_plane(int plane, int enable)\n{\n\tdev_dbg(lcdc.fbdev->dev,\n\t\t\"plane %d enable %d update_mode %d ext_mode %d\\n\",\n\t\tplane, enable, lcdc.update_mode, lcdc.ext_mode);\n\tif (plane != OMAPFB_PLANE_GFX)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic void load_palette(void)\n{\n\tu16\t*palette;\n\n\tpalette = (u16 *)lcdc.palette_virt;\n\n\t*(u16 *)palette &= 0x0fff;\n\t*(u16 *)palette |= lcdc.palette_code;\n\n\tomap_set_lcd_dma_b1(lcdc.palette_phys,\n\t\tlcdc.palette_size / 4 + 1, 1, OMAP_DMA_DATA_TYPE_S32);\n\n\tomap_set_lcd_dma_single_transfer(1);\n\tomap_setup_lcd_dma();\n\n\tinit_completion(&lcdc.palette_load_complete);\n\tenable_irqs(OMAP_LCDC_IRQ_LOADED_PALETTE);\n\tset_load_mode(OMAP_LCDC_LOAD_PALETTE);\n\tenable_controller();\n\tif (!wait_for_completion_timeout(&lcdc.palette_load_complete,\n\t\t\t\tmsecs_to_jiffies(500)))\n\t\tdev_err(lcdc.fbdev->dev, \"timeout waiting for FRAME DONE\\n\");\n\t \n\tdisable_irqs(OMAP_LCDC_IRQ_LOADED_PALETTE);\n\tomap_stop_lcd_dma();\n\n\tomap_set_lcd_dma_single_transfer(lcdc.ext_mode);\n}\n\n \nstatic int omap_lcdc_setcolreg(u_int regno, u16 red, u16 green, u16 blue,\n\t\t\t       u16 transp, int update_hw_pal)\n{\n\tu16 *palette;\n\n\tif (lcdc.color_mode != OMAPFB_COLOR_CLUT_8BPP || regno > 255)\n\t\treturn -EINVAL;\n\n\tpalette = (u16 *)lcdc.palette_virt;\n\n\tpalette[regno] &= ~0x0fff;\n\tpalette[regno] |= ((red >> 12) << 8) | ((green >> 12) << 4 ) |\n\t\t\t   (blue >> 12);\n\n\tif (update_hw_pal) {\n\t\tdisable_controller();\n\t\tomap_stop_lcd_dma();\n\t\tload_palette();\n\t\tsetup_lcd_dma();\n\t\tset_load_mode(OMAP_LCDC_LOAD_FRAME);\n\t\tenable_controller();\n\t}\n\n\treturn 0;\n}\n\nstatic void calc_ck_div(int is_tft, int pck, int *pck_div)\n{\n\tunsigned long lck;\n\n\tpck = max(1, pck);\n\tlck = clk_get_rate(lcdc.lcd_ck);\n\t*pck_div = (lck + pck - 1) / pck;\n\tif (is_tft)\n\t\t*pck_div = max(2, *pck_div);\n\telse\n\t\t*pck_div = max(3, *pck_div);\n\tif (*pck_div > 255) {\n\t\t \n\t\t*pck_div = 255;\n\t\tdev_warn(lcdc.fbdev->dev, \"pixclock %d kHz too low.\\n\",\n\t\t\t pck / 1000);\n\t}\n}\n\nstatic inline void setup_regs(void)\n{\n\tu32 l;\n\tstruct lcd_panel *panel = lcdc.fbdev->panel;\n\tint is_tft = panel->config & OMAP_LCDC_PANEL_TFT;\n\tunsigned long lck;\n\tint pcd;\n\n\tl = omap_readl(OMAP_LCDC_CONTROL);\n\tl &= ~OMAP_LCDC_CTRL_LCD_TFT;\n\tl |= is_tft ? OMAP_LCDC_CTRL_LCD_TFT : 0;\n#ifdef CONFIG_MACH_OMAP_PALMTE\n \n\t\t \n\t\tl |= (is_tft && panel->bpp == 8) ? 0x810000 : 0;\n \n#endif\n\tomap_writel(l, OMAP_LCDC_CONTROL);\n\n\tl = omap_readl(OMAP_LCDC_TIMING2);\n\tl &= ~(((1 << 6) - 1) << 20);\n\tl |= (panel->config & OMAP_LCDC_SIGNAL_MASK) << 20;\n\tomap_writel(l, OMAP_LCDC_TIMING2);\n\n\tl = panel->x_res - 1;\n\tl |= (panel->hsw - 1) << 10;\n\tl |= (panel->hfp - 1) << 16;\n\tl |= (panel->hbp - 1) << 24;\n\tomap_writel(l, OMAP_LCDC_TIMING0);\n\n\tl = panel->y_res - 1;\n\tl |= (panel->vsw - 1) << 10;\n\tl |= panel->vfp << 16;\n\tl |= panel->vbp << 24;\n\tomap_writel(l, OMAP_LCDC_TIMING1);\n\n\tl = omap_readl(OMAP_LCDC_TIMING2);\n\tl &= ~0xff;\n\n\tlck = clk_get_rate(lcdc.lcd_ck);\n\n\tif (!panel->pcd)\n\t\tcalc_ck_div(is_tft, panel->pixel_clock * 1000, &pcd);\n\telse {\n\t\tdev_warn(lcdc.fbdev->dev,\n\t\t    \"Pixel clock divider value is obsolete.\\n\"\n\t\t    \"Try to set pixel_clock to %lu and pcd to 0 \"\n\t\t    \"in drivers/video/omap/lcd_%s.c and submit a patch.\\n\",\n\t\t\tlck / panel->pcd / 1000, panel->name);\n\n\t\tpcd = panel->pcd;\n\t}\n\tl |= pcd & 0xff;\n\tl |= panel->acb << 8;\n\tomap_writel(l, OMAP_LCDC_TIMING2);\n\n\t \n\tpanel->pixel_clock = lck / pcd / 1000;\n}\n\n \nstatic int omap_lcdc_set_update_mode(enum omapfb_update_mode mode)\n{\n\tint r = 0;\n\n\tif (mode != lcdc.update_mode) {\n\t\tswitch (mode) {\n\t\tcase OMAPFB_AUTO_UPDATE:\n\t\t\tsetup_regs();\n\t\t\tload_palette();\n\n\t\t\t \n\t\t\tsetup_lcd_dma();\n\n\t\t\tset_load_mode(OMAP_LCDC_LOAD_FRAME);\n\t\t\tenable_irqs(OMAP_LCDC_IRQ_DONE);\n\t\t\t \n\t\t\tenable_controller();\n\t\t\tlcdc.update_mode = mode;\n\t\t\tbreak;\n\t\tcase OMAPFB_UPDATE_DISABLED:\n\t\t\tdisable_controller();\n\t\t\tomap_stop_lcd_dma();\n\t\t\tlcdc.update_mode = mode;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr = -EINVAL;\n\t\t}\n\t}\n\n\treturn r;\n}\n\nstatic enum omapfb_update_mode omap_lcdc_get_update_mode(void)\n{\n\treturn lcdc.update_mode;\n}\n\n \nstatic void omap_lcdc_suspend(void)\n{\n\tomap_lcdc_set_update_mode(OMAPFB_UPDATE_DISABLED);\n}\n\nstatic void omap_lcdc_resume(void)\n{\n\tomap_lcdc_set_update_mode(OMAPFB_AUTO_UPDATE);\n}\n\nstatic void omap_lcdc_get_caps(int plane, struct omapfb_caps *caps)\n{\n\treturn;\n}\n\nint omap_lcdc_set_dma_callback(void (*callback)(void *data), void *data)\n{\n\tBUG_ON(callback == NULL);\n\n\tif (lcdc.dma_callback)\n\t\treturn -EBUSY;\n\telse {\n\t\tlcdc.dma_callback = callback;\n\t\tlcdc.dma_callback_data = data;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(omap_lcdc_set_dma_callback);\n\nvoid omap_lcdc_free_dma_callback(void)\n{\n\tlcdc.dma_callback = NULL;\n}\nEXPORT_SYMBOL(omap_lcdc_free_dma_callback);\n\nstatic void lcdc_dma_handler(u16 status, void *data)\n{\n\tif (lcdc.dma_callback)\n\t\tlcdc.dma_callback(lcdc.dma_callback_data);\n}\n\nstatic int alloc_palette_ram(void)\n{\n\tlcdc.palette_virt = dma_alloc_wc(lcdc.fbdev->dev, MAX_PALETTE_SIZE,\n\t\t\t\t\t &lcdc.palette_phys, GFP_KERNEL);\n\tif (lcdc.palette_virt == NULL) {\n\t\tdev_err(lcdc.fbdev->dev, \"failed to alloc palette memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(lcdc.palette_virt, 0, MAX_PALETTE_SIZE);\n\n\treturn 0;\n}\n\nstatic void free_palette_ram(void)\n{\n\tdma_free_wc(lcdc.fbdev->dev, MAX_PALETTE_SIZE, lcdc.palette_virt,\n\t\t    lcdc.palette_phys);\n}\n\nstatic int alloc_fbmem(struct omapfb_mem_region *region)\n{\n\tint bpp;\n\tint frame_size;\n\tstruct lcd_panel *panel = lcdc.fbdev->panel;\n\n\tbpp = panel->bpp;\n\tif (bpp == 12)\n\t\tbpp = 16;\n\tframe_size = PAGE_ALIGN(panel->x_res * bpp / 8 * panel->y_res);\n\tif (region->size > frame_size)\n\t\tframe_size = region->size;\n\tlcdc.vram_size = frame_size;\n\tlcdc.vram_virt = dma_alloc_wc(lcdc.fbdev->dev, lcdc.vram_size,\n\t\t\t\t      &lcdc.vram_phys, GFP_KERNEL);\n\tif (lcdc.vram_virt == NULL) {\n\t\tdev_err(lcdc.fbdev->dev, \"unable to allocate FB DMA memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tregion->size = frame_size;\n\tregion->paddr = lcdc.vram_phys;\n\tregion->vaddr = lcdc.vram_virt;\n\tregion->alloc = 1;\n\n\tmemset(lcdc.vram_virt, 0, lcdc.vram_size);\n\n\treturn 0;\n}\n\nstatic void free_fbmem(void)\n{\n\tdma_free_wc(lcdc.fbdev->dev, lcdc.vram_size, lcdc.vram_virt,\n\t\t    lcdc.vram_phys);\n}\n\nstatic int setup_fbmem(struct omapfb_mem_desc *req_md)\n{\n\tif (!req_md->region_cnt) {\n\t\tdev_err(lcdc.fbdev->dev, \"no memory regions defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (req_md->region_cnt > 1) {\n\t\tdev_err(lcdc.fbdev->dev, \"only one plane is supported\\n\");\n\t\treq_md->region_cnt = 1;\n\t}\n\n\treturn alloc_fbmem(&req_md->region[0]);\n}\n\nstatic int omap_lcdc_init(struct omapfb_device *fbdev, int ext_mode,\n\t\t\t  struct omapfb_mem_desc *req_vram)\n{\n\tint r;\n\tu32 l;\n\tint rate;\n\tstruct clk *tc_ck;\n\n\tlcdc.irq_mask = 0;\n\n\tlcdc.fbdev = fbdev;\n\tlcdc.ext_mode = ext_mode;\n\n\tl = 0;\n\tomap_writel(l, OMAP_LCDC_CONTROL);\n\n\t \n\tlcdc.lcd_ck = clk_get(fbdev->dev, \"lcd_ck\");\n\tif (IS_ERR(lcdc.lcd_ck)) {\n\t\tdev_err(fbdev->dev, \"unable to access LCD clock\\n\");\n\t\tr = PTR_ERR(lcdc.lcd_ck);\n\t\tgoto fail0;\n\t}\n\n\ttc_ck = clk_get(fbdev->dev, \"tc_ck\");\n\tif (IS_ERR(tc_ck)) {\n\t\tdev_err(fbdev->dev, \"unable to access TC clock\\n\");\n\t\tr = PTR_ERR(tc_ck);\n\t\tgoto fail1;\n\t}\n\n\trate = clk_get_rate(tc_ck);\n\tclk_put(tc_ck);\n\n\tif (machine_is_ams_delta())\n\t\trate /= 4;\n\tr = clk_set_rate(lcdc.lcd_ck, rate);\n\tif (r) {\n\t\tdev_err(fbdev->dev, \"failed to adjust LCD rate\\n\");\n\t\tgoto fail1;\n\t}\n\tclk_prepare_enable(lcdc.lcd_ck);\n\n\tr = request_irq(fbdev->int_irq, lcdc_irq_handler, 0, MODULE_NAME, fbdev);\n\tif (r) {\n\t\tdev_err(fbdev->dev, \"unable to get IRQ\\n\");\n\t\tgoto fail2;\n\t}\n\n\tr = omap_request_lcd_dma(lcdc_dma_handler, NULL);\n\tif (r) {\n\t\tdev_err(fbdev->dev, \"unable to get LCD DMA\\n\");\n\t\tgoto fail3;\n\t}\n\n\tomap_set_lcd_dma_single_transfer(ext_mode);\n\tomap_set_lcd_dma_ext_controller(ext_mode);\n\n\tif (!ext_mode)\n\t\tif ((r = alloc_palette_ram()) < 0)\n\t\t\tgoto fail4;\n\n\tif ((r = setup_fbmem(req_vram)) < 0)\n\t\tgoto fail5;\n\n\tpr_info(\"omapfb: LCDC initialized\\n\");\n\n\treturn 0;\nfail5:\n\tif (!ext_mode)\n\t\tfree_palette_ram();\nfail4:\n\tomap_free_lcd_dma();\nfail3:\n\tfree_irq(fbdev->int_irq, lcdc.fbdev);\nfail2:\n\tclk_disable_unprepare(lcdc.lcd_ck);\nfail1:\n\tclk_put(lcdc.lcd_ck);\nfail0:\n\treturn r;\n}\n\nstatic void omap_lcdc_cleanup(void)\n{\n\tif (!lcdc.ext_mode)\n\t\tfree_palette_ram();\n\tfree_fbmem();\n\tomap_free_lcd_dma();\n\tfree_irq(lcdc.fbdev->int_irq, lcdc.fbdev);\n\tclk_disable_unprepare(lcdc.lcd_ck);\n\tclk_put(lcdc.lcd_ck);\n}\n\nconst struct lcd_ctrl omap1_int_ctrl = {\n\t.name\t\t\t= \"internal\",\n\t.init\t\t\t= omap_lcdc_init,\n\t.cleanup\t\t= omap_lcdc_cleanup,\n\t.get_caps\t\t= omap_lcdc_get_caps,\n\t.set_update_mode\t= omap_lcdc_set_update_mode,\n\t.get_update_mode\t= omap_lcdc_get_update_mode,\n\t.update_window\t\t= NULL,\n\t.suspend\t\t= omap_lcdc_suspend,\n\t.resume\t\t\t= omap_lcdc_resume,\n\t.setup_plane\t\t= omap_lcdc_setup_plane,\n\t.enable_plane\t\t= omap_lcdc_enable_plane,\n\t.setcolreg\t\t= omap_lcdc_setcolreg,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}