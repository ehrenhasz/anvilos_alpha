{
  "module_name": "sossi.c",
  "hash_id": "d8d05925b631bdb130781be0f883013b21858afc74be13947f8a15bdb499565c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap/sossi.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/clk.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n\n#include <linux/omap-dma.h>\n#include <linux/soc/ti/omap1-io.h>\n\n#include \"omapfb.h\"\n#include \"lcd_dma.h\"\n#include \"lcdc.h\"\n\n#define MODULE_NAME\t\t\"omapfb-sossi\"\n\n#define OMAP_SOSSI_BASE         0xfffbac00\n#define SOSSI_ID_REG\t\t0x00\n#define SOSSI_INIT1_REG\t\t0x04\n#define SOSSI_INIT2_REG\t\t0x08\n#define SOSSI_INIT3_REG\t\t0x0c\n#define SOSSI_FIFO_REG\t\t0x10\n#define SOSSI_REOTABLE_REG\t0x14\n#define SOSSI_TEARING_REG\t0x18\n#define SOSSI_INIT1B_REG\t0x1c\n#define SOSSI_FIFOB_REG\t\t0x20\n\n#define DMA_GSCR          0xfffedc04\n#define DMA_LCD_CCR       0xfffee3c2\n#define DMA_LCD_CTRL      0xfffee3c4\n#define DMA_LCD_LCH_CTRL  0xfffee3ea\n\n#define CONF_SOSSI_RESET_R      (1 << 23)\n\n#define RD_ACCESS\t\t0\n#define WR_ACCESS\t\t1\n\n#define SOSSI_MAX_XMIT_BYTES\t(512 * 1024)\n\nstatic struct {\n\tvoid __iomem\t*base;\n\tstruct clk\t*fck;\n\tunsigned long\tfck_hz;\n\tspinlock_t\tlock;\n\tint\t\tbus_pick_count;\n\tint\t\tbus_pick_width;\n\tint\t\ttearsync_mode;\n\tint\t\ttearsync_line;\n\tvoid\t\t(*lcdc_callback)(void *data);\n\tvoid\t\t*lcdc_callback_data;\n\tint\t\tvsync_dma_pending;\n\t \n\tint\t\tclk_div;\n\tu8\t\tclk_tw0[2];\n\tu8\t\tclk_tw1[2];\n\t \n\tint\t\tlast_access;\n\n\tstruct omapfb_device\t*fbdev;\n} sossi;\n\nstatic inline u32 sossi_read_reg(int reg)\n{\n\treturn readl(sossi.base + reg);\n}\n\nstatic inline u16 sossi_read_reg16(int reg)\n{\n\treturn readw(sossi.base + reg);\n}\n\nstatic inline u8 sossi_read_reg8(int reg)\n{\n\treturn readb(sossi.base + reg);\n}\n\nstatic inline void sossi_write_reg(int reg, u32 value)\n{\n\twritel(value, sossi.base + reg);\n}\n\nstatic inline void sossi_write_reg16(int reg, u16 value)\n{\n\twritew(value, sossi.base + reg);\n}\n\nstatic inline void sossi_write_reg8(int reg, u8 value)\n{\n\twriteb(value, sossi.base + reg);\n}\n\nstatic void sossi_set_bits(int reg, u32 bits)\n{\n\tsossi_write_reg(reg, sossi_read_reg(reg) | bits);\n}\n\nstatic void sossi_clear_bits(int reg, u32 bits)\n{\n\tsossi_write_reg(reg, sossi_read_reg(reg) & ~bits);\n}\n\n#define HZ_TO_PS(x)\t(1000000000 / (x / 1000))\n\nstatic u32 ps_to_sossi_ticks(u32 ps, int div)\n{\n\tu32 clk_period = HZ_TO_PS(sossi.fck_hz) * div;\n\treturn (clk_period + ps - 1) / clk_period;\n}\n\nstatic int calc_rd_timings(struct extif_timings *t)\n{\n\tu32 tw0, tw1;\n\tint reon, reoff, recyc, actim;\n\tint div = t->clk_div;\n\n\t \n\treon = ps_to_sossi_ticks(t->re_on_time, div);\n\t \n\tif (reon > 1)\n\t\treturn -1;\n\n\treoff = ps_to_sossi_ticks(t->re_off_time, div);\n\n\tif (reoff <= reon)\n\t\treoff = reon + 1;\n\n\ttw0 = reoff - reon;\n\tif (tw0 > 0x10)\n\t\treturn -1;\n\n\trecyc = ps_to_sossi_ticks(t->re_cycle_time, div);\n\tif (recyc <= reoff)\n\t\trecyc = reoff + 1;\n\n\ttw1 = recyc - tw0;\n\t \n\tif (tw1 < 3)\n\t\ttw1 = 3;\n\tif (tw1 > 0x40)\n\t\treturn -1;\n\n\tactim = ps_to_sossi_ticks(t->access_time, div);\n\tif (actim < reoff)\n\t\tactim++;\n\t \n\tif (actim - reoff > 1)\n\t\treturn -1;\n\n\tt->tim[0] = tw0 - 1;\n\tt->tim[1] = tw1 - 1;\n\n\treturn 0;\n}\n\nstatic int calc_wr_timings(struct extif_timings *t)\n{\n\tu32 tw0, tw1;\n\tint weon, weoff, wecyc;\n\tint div = t->clk_div;\n\n\t \n\tweon = ps_to_sossi_ticks(t->we_on_time, div);\n\t \n\tif (weon > 1)\n\t\treturn -1;\n\n\tweoff = ps_to_sossi_ticks(t->we_off_time, div);\n\tif (weoff <= weon)\n\t\tweoff = weon + 1;\n\ttw0 = weoff - weon;\n\tif (tw0 > 0x10)\n\t\treturn -1;\n\n\twecyc = ps_to_sossi_ticks(t->we_cycle_time, div);\n\tif (wecyc <= weoff)\n\t\twecyc = weoff + 1;\n\n\ttw1 = wecyc - tw0;\n\t \n\tif (tw1 < 3)\n\t\ttw1 = 3;\n\tif (tw1 > 0x40)\n\t\treturn -1;\n\n\tt->tim[2] = tw0 - 1;\n\tt->tim[3] = tw1 - 1;\n\n\treturn 0;\n}\n\nstatic void _set_timing(int div, int tw0, int tw1)\n{\n\tu32 l;\n\n#ifdef VERBOSE\n\tdev_dbg(sossi.fbdev->dev, \"Using TW0 = %d, TW1 = %d, div = %d\\n\",\n\t\t tw0 + 1, tw1 + 1, div);\n#endif\n\n\tclk_set_rate(sossi.fck, sossi.fck_hz / div);\n\tclk_enable(sossi.fck);\n\tl = sossi_read_reg(SOSSI_INIT1_REG);\n\tl &= ~((0x0f << 20) | (0x3f << 24));\n\tl |= (tw0 << 20) | (tw1 << 24);\n\tsossi_write_reg(SOSSI_INIT1_REG, l);\n\tclk_disable(sossi.fck);\n}\n\nstatic void _set_bits_per_cycle(int bus_pick_count, int bus_pick_width)\n{\n\tu32 l;\n\n\tl = sossi_read_reg(SOSSI_INIT3_REG);\n\tl &= ~0x3ff;\n\tl |= ((bus_pick_count - 1) << 5) | ((bus_pick_width - 1) & 0x1f);\n\tsossi_write_reg(SOSSI_INIT3_REG, l);\n}\n\nstatic void _set_tearsync_mode(int mode, unsigned line)\n{\n\tu32 l;\n\n\tl = sossi_read_reg(SOSSI_TEARING_REG);\n\tl &= ~(((1 << 11) - 1) << 15);\n\tl |= line << 15;\n\tl &= ~(0x3 << 26);\n\tl |= mode << 26;\n\tsossi_write_reg(SOSSI_TEARING_REG, l);\n\tif (mode)\n\t\tsossi_set_bits(SOSSI_INIT2_REG, 1 << 6);\t \n\telse\n\t\tsossi_clear_bits(SOSSI_INIT2_REG, 1 << 6);\n}\n\nstatic inline void set_timing(int access)\n{\n\tif (access != sossi.last_access) {\n\t\tsossi.last_access = access;\n\t\t_set_timing(sossi.clk_div,\n\t\t\t    sossi.clk_tw0[access], sossi.clk_tw1[access]);\n\t}\n}\n\nstatic void sossi_start_transfer(void)\n{\n\t \n\tsossi_clear_bits(SOSSI_INIT2_REG, 1 << 4);\n\t \n\tsossi_clear_bits(SOSSI_INIT1_REG, 1 << 30);\n}\n\nstatic void sossi_stop_transfer(void)\n{\n\t \n\tsossi_set_bits(SOSSI_INIT2_REG, 1 << 4);\n\t \n\tsossi_set_bits(SOSSI_INIT1_REG, 1 << 30);\n}\n\nstatic void wait_end_of_write(void)\n{\n\t \n\twhile (!(sossi_read_reg(SOSSI_INIT2_REG) & (1 << 3)));\n}\n\nstatic void send_data(const void *data, unsigned int len)\n{\n\twhile (len >= 4) {\n\t\tsossi_write_reg(SOSSI_FIFO_REG, *(const u32 *) data);\n\t\tlen -= 4;\n\t\tdata += 4;\n\t}\n\twhile (len >= 2) {\n\t\tsossi_write_reg16(SOSSI_FIFO_REG, *(const u16 *) data);\n\t\tlen -= 2;\n\t\tdata += 2;\n\t}\n\twhile (len) {\n\t\tsossi_write_reg8(SOSSI_FIFO_REG, *(const u8 *) data);\n\t\tlen--;\n\t\tdata++;\n\t}\n}\n\nstatic void set_cycles(unsigned int len)\n{\n\tunsigned long nr_cycles = len / (sossi.bus_pick_width / 8);\n\n\tBUG_ON((nr_cycles - 1) & ~0x3ffff);\n\n\tsossi_clear_bits(SOSSI_INIT1_REG, 0x3ffff);\n\tsossi_set_bits(SOSSI_INIT1_REG, (nr_cycles - 1) & 0x3ffff);\n}\n\nstatic int sossi_convert_timings(struct extif_timings *t)\n{\n\tint r = 0;\n\tint div = t->clk_div;\n\n\tt->converted = 0;\n\n\tif (div <= 0 || div > 8)\n\t\treturn -1;\n\n\t \n\tif ((r = calc_rd_timings(t)) < 0)\n\t\treturn r;\n\n\tif ((r = calc_wr_timings(t)) < 0)\n\t\treturn r;\n\n\tt->tim[4] = div;\n\n\tt->converted = 1;\n\n\treturn 0;\n}\n\nstatic void sossi_set_timings(const struct extif_timings *t)\n{\n\tBUG_ON(!t->converted);\n\n\tsossi.clk_tw0[RD_ACCESS] = t->tim[0];\n\tsossi.clk_tw1[RD_ACCESS] = t->tim[1];\n\n\tsossi.clk_tw0[WR_ACCESS] = t->tim[2];\n\tsossi.clk_tw1[WR_ACCESS] = t->tim[3];\n\n\tsossi.clk_div = t->tim[4];\n}\n\nstatic void sossi_get_clk_info(u32 *clk_period, u32 *max_clk_div)\n{\n\t*clk_period = HZ_TO_PS(sossi.fck_hz);\n\t*max_clk_div = 8;\n}\n\nstatic void sossi_set_bits_per_cycle(int bpc)\n{\n\tint bus_pick_count, bus_pick_width;\n\n\t \n\tswitch (bpc) {\n\tcase 8:\n\t\tbus_pick_count = 4;\n\t\tbus_pick_width = 8;\n\t\tbreak;\n\tcase 16:\n\t\tbus_pick_count = 2;\n\t\tbus_pick_width = 16;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\tsossi.bus_pick_width = bus_pick_width;\n\tsossi.bus_pick_count = bus_pick_count;\n}\n\nstatic int sossi_setup_tearsync(unsigned pin_cnt,\n\t\t\t\tunsigned hs_pulse_time, unsigned vs_pulse_time,\n\t\t\t\tint hs_pol_inv, int vs_pol_inv, int div)\n{\n\tint hs, vs;\n\tu32 l;\n\n\tif (pin_cnt != 1 || div < 1 || div > 8)\n\t\treturn -EINVAL;\n\n\ths = ps_to_sossi_ticks(hs_pulse_time, div);\n\tvs = ps_to_sossi_ticks(vs_pulse_time, div);\n\tif (vs < 8 || vs <= hs || vs >= (1 << 12))\n\t\treturn -EDOM;\n\tvs /= 8;\n\tvs--;\n\tif (hs > 8)\n\t\ths = 8;\n\tif (hs)\n\t\ths--;\n\n\tdev_dbg(sossi.fbdev->dev,\n\t\t\"setup_tearsync: hs %d vs %d hs_inv %d vs_inv %d\\n\",\n\t\ths, vs, hs_pol_inv, vs_pol_inv);\n\n\tclk_enable(sossi.fck);\n\tl = sossi_read_reg(SOSSI_TEARING_REG);\n\tl &= ~((1 << 15) - 1);\n\tl |= vs << 3;\n\tl |= hs;\n\tif (hs_pol_inv)\n\t\tl |= 1 << 29;\n\telse\n\t\tl &= ~(1 << 29);\n\tif (vs_pol_inv)\n\t\tl |= 1 << 28;\n\telse\n\t\tl &= ~(1 << 28);\n\tsossi_write_reg(SOSSI_TEARING_REG, l);\n\tclk_disable(sossi.fck);\n\n\treturn 0;\n}\n\nstatic int sossi_enable_tearsync(int enable, unsigned line)\n{\n\tint mode;\n\n\tdev_dbg(sossi.fbdev->dev, \"tearsync %d line %d\\n\", enable, line);\n\tif (line >= 1 << 11)\n\t\treturn -EINVAL;\n\tif (enable) {\n\t\tif (line)\n\t\t\tmode = 2;\t\t \n\t\telse\n\t\t\tmode = 3;\t\t \n\t} else\n\t\tmode = 0;\n\tsossi.tearsync_line = line;\n\tsossi.tearsync_mode = mode;\n\n\treturn 0;\n}\n\nstatic void sossi_write_command(const void *data, unsigned int len)\n{\n\tclk_enable(sossi.fck);\n\tset_timing(WR_ACCESS);\n\t_set_bits_per_cycle(sossi.bus_pick_count, sossi.bus_pick_width);\n\t \n\tsossi_clear_bits(SOSSI_INIT1_REG, 1 << 18);\n\tset_cycles(len);\n\tsossi_start_transfer();\n\tsend_data(data, len);\n\tsossi_stop_transfer();\n\twait_end_of_write();\n\tclk_disable(sossi.fck);\n}\n\nstatic void sossi_write_data(const void *data, unsigned int len)\n{\n\tclk_enable(sossi.fck);\n\tset_timing(WR_ACCESS);\n\t_set_bits_per_cycle(sossi.bus_pick_count, sossi.bus_pick_width);\n\t \n\tsossi_set_bits(SOSSI_INIT1_REG, 1 << 18);\n\tset_cycles(len);\n\tsossi_start_transfer();\n\tsend_data(data, len);\n\tsossi_stop_transfer();\n\twait_end_of_write();\n\tclk_disable(sossi.fck);\n}\n\nstatic void sossi_transfer_area(int width, int height,\n\t\t\t\tvoid (callback)(void *data), void *data)\n{\n\tBUG_ON(callback == NULL);\n\n\tsossi.lcdc_callback = callback;\n\tsossi.lcdc_callback_data = data;\n\n\tclk_enable(sossi.fck);\n\tset_timing(WR_ACCESS);\n\t_set_bits_per_cycle(sossi.bus_pick_count, sossi.bus_pick_width);\n\t_set_tearsync_mode(sossi.tearsync_mode, sossi.tearsync_line);\n\t \n\tsossi_set_bits(SOSSI_INIT1_REG, 1 << 18);\n\tset_cycles(width * height * sossi.bus_pick_width / 8);\n\n\tsossi_start_transfer();\n\tif (sossi.tearsync_mode) {\n\t\t \n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&sossi.lock, flags);\n\t\tsossi.vsync_dma_pending++;\n\t\tspin_unlock_irqrestore(&sossi.lock, flags);\n\t} else\n\t\t \n\t\tomap_enable_lcd_dma();\n}\n\nstatic void sossi_dma_callback(void *data)\n{\n\tomap_stop_lcd_dma();\n\tsossi_stop_transfer();\n\tclk_disable(sossi.fck);\n\tsossi.lcdc_callback(sossi.lcdc_callback_data);\n}\n\nstatic void sossi_read_data(void *data, unsigned int len)\n{\n\tclk_enable(sossi.fck);\n\tset_timing(RD_ACCESS);\n\t_set_bits_per_cycle(sossi.bus_pick_count, sossi.bus_pick_width);\n\t \n\tsossi_set_bits(SOSSI_INIT1_REG, 1 << 18);\n\tset_cycles(len);\n\tsossi_start_transfer();\n\twhile (len >= 4) {\n\t\t*(u32 *) data = sossi_read_reg(SOSSI_FIFO_REG);\n\t\tlen -= 4;\n\t\tdata += 4;\n\t}\n\twhile (len >= 2) {\n\t\t*(u16 *) data = sossi_read_reg16(SOSSI_FIFO_REG);\n\t\tlen -= 2;\n\t\tdata += 2;\n\t}\n\twhile (len) {\n\t\t*(u8 *) data = sossi_read_reg8(SOSSI_FIFO_REG);\n\t\tlen--;\n\t\tdata++;\n\t}\n\tsossi_stop_transfer();\n\tclk_disable(sossi.fck);\n}\n\nstatic irqreturn_t sossi_match_irq(int irq, void *data)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sossi.lock, flags);\n\tif (sossi.vsync_dma_pending) {\n\t\tsossi.vsync_dma_pending--;\n\t\tomap_enable_lcd_dma();\n\t}\n\tspin_unlock_irqrestore(&sossi.lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic int sossi_init(struct omapfb_device *fbdev)\n{\n\tu32 l, k;\n\tstruct clk *fck;\n\tstruct clk *dpll1out_ck;\n\tint r;\n\n\tsossi.base = ioremap(OMAP_SOSSI_BASE, SZ_1K);\n\tif (!sossi.base) {\n\t\tdev_err(fbdev->dev, \"can't ioremap SoSSI\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsossi.fbdev = fbdev;\n\tspin_lock_init(&sossi.lock);\n\n\tdpll1out_ck = clk_get(fbdev->dev, \"ck_dpll1out\");\n\tif (IS_ERR(dpll1out_ck)) {\n\t\tdev_err(fbdev->dev, \"can't get DPLL1OUT clock\\n\");\n\t\treturn PTR_ERR(dpll1out_ck);\n\t}\n\t \n\tsossi.fck_hz = clk_get_rate(dpll1out_ck);\n\tclk_put(dpll1out_ck);\n\n\tfck = clk_get(fbdev->dev, \"ck_sossi\");\n\tif (IS_ERR(fck)) {\n\t\tdev_err(fbdev->dev, \"can't get SoSSI functional clock\\n\");\n\t\treturn PTR_ERR(fck);\n\t}\n\tsossi.fck = fck;\n\n\t \n\tl = omap_readl(MOD_CONF_CTRL_1);\n\tl |= CONF_SOSSI_RESET_R;\n\tomap_writel(l, MOD_CONF_CTRL_1);\n\tl &= ~CONF_SOSSI_RESET_R;\n\tomap_writel(l, MOD_CONF_CTRL_1);\n\n\tclk_prepare_enable(sossi.fck);\n\tl = omap_readl(ARM_IDLECT2);\n\tl &= ~(1 << 8);\t\t\t \n\tomap_writel(l, ARM_IDLECT2);\n\n\tl = sossi_read_reg(SOSSI_INIT2_REG);\n\t \n\tl |= (1 << 0) | (1 << 1);\n\tsossi_write_reg(SOSSI_INIT2_REG, l);\n\t \n\tl &= ~(1 << 1);\n\tsossi_write_reg(SOSSI_INIT2_REG, l);\n\n\tsossi_write_reg(SOSSI_ID_REG, 0);\n\tl = sossi_read_reg(SOSSI_ID_REG);\n\tk = sossi_read_reg(SOSSI_ID_REG);\n\n\tif (l != 0x55555555 || k != 0xaaaaaaaa) {\n\t\tdev_err(fbdev->dev,\n\t\t\t\"invalid SoSSI sync pattern: %08x, %08x\\n\", l, k);\n\t\tr = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tif ((r = omap_lcdc_set_dma_callback(sossi_dma_callback, NULL)) < 0) {\n\t\tdev_err(fbdev->dev, \"can't get LCDC IRQ\\n\");\n\t\tr = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tl = sossi_read_reg(SOSSI_ID_REG);  \n\tl = sossi_read_reg(SOSSI_ID_REG);\n\tdev_info(fbdev->dev, \"SoSSI version %d.%d initialized\\n\",\n\t\tl >> 16, l & 0xffff);\n\n\tl = sossi_read_reg(SOSSI_INIT1_REG);\n\tl |= (1 << 19);  \n\tl &= ~(1 << 31);  \n\tsossi_write_reg(SOSSI_INIT1_REG, l);\n\n\tif ((r = request_irq(fbdev->ext_irq, sossi_match_irq,\n\t\t\t     IRQ_TYPE_EDGE_FALLING,\n\t     \"sossi_match\", sossi.fbdev->dev)) < 0) {\n\t\tdev_err(sossi.fbdev->dev, \"can't get SoSSI match IRQ\\n\");\n\t\tgoto err;\n\t}\n\n\tclk_disable(sossi.fck);\n\treturn 0;\n\nerr:\n\tclk_disable_unprepare(sossi.fck);\n\tclk_put(sossi.fck);\n\treturn r;\n}\n\nstatic void sossi_cleanup(void)\n{\n\tomap_lcdc_free_dma_callback();\n\tclk_unprepare(sossi.fck);\n\tclk_put(sossi.fck);\n\tiounmap(sossi.base);\n}\n\nstruct lcd_ctrl_extif omap1_ext_if = {\n\t.init\t\t\t= sossi_init,\n\t.cleanup\t\t= sossi_cleanup,\n\t.get_clk_info\t\t= sossi_get_clk_info,\n\t.convert_timings\t= sossi_convert_timings,\n\t.set_timings\t\t= sossi_set_timings,\n\t.set_bits_per_cycle\t= sossi_set_bits_per_cycle,\n\t.setup_tearsync\t\t= sossi_setup_tearsync,\n\t.enable_tearsync\t= sossi_enable_tearsync,\n\t.write_command\t\t= sossi_write_command,\n\t.read_data\t\t= sossi_read_data,\n\t.write_data\t\t= sossi_write_data,\n\t.transfer_area\t\t= sossi_transfer_area,\n\n\t.max_transmit_size\t= SOSSI_MAX_XMIT_BYTES,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}