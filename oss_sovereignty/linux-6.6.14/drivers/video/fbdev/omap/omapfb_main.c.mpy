{
  "module_name": "omapfb_main.c",
  "hash_id": "a2da6ac77fbba1ab2a75c3764f9212d1e5be7957b819c9a1ea0a0e4f066e23a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap/omapfb_main.c",
  "human_readable_source": "\n \n#include <linux/platform_device.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/sysfs.h>\n\n#include <linux/omap-dma.h>\n\n#include <linux/soc/ti/omap1-soc.h>\n#include \"omapfb.h\"\n#include \"lcdc.h\"\n\n#define MODULE_NAME\t\"omapfb\"\n\nstatic unsigned int\tdef_accel;\nstatic unsigned long\tdef_vram[OMAPFB_PLANE_NUM];\nstatic unsigned int\tdef_vram_cnt;\nstatic unsigned long\tdef_vxres;\nstatic unsigned long\tdef_vyres;\nstatic unsigned int\tdef_rotate;\nstatic unsigned int\tdef_mirror;\n\nstatic bool\tmanual_update = IS_BUILTIN(CONFIG_FB_OMAP_MANUAL_UPDATE);\n\nstatic struct platform_device\t*fbdev_pdev;\nstatic struct lcd_panel\t\t*fbdev_panel;\nstatic struct omapfb_device\t*omapfb_dev;\n\nstruct caps_table_struct {\n\tunsigned long flag;\n\tconst char *name;\n};\n\nstatic const struct caps_table_struct ctrl_caps[] = {\n\t{ OMAPFB_CAPS_MANUAL_UPDATE,  \"manual update\" },\n\t{ OMAPFB_CAPS_TEARSYNC,       \"tearing synchronization\" },\n\t{ OMAPFB_CAPS_PLANE_RELOCATE_MEM, \"relocate plane memory\" },\n\t{ OMAPFB_CAPS_PLANE_SCALE,    \"scale plane\" },\n\t{ OMAPFB_CAPS_WINDOW_PIXEL_DOUBLE, \"pixel double window\" },\n\t{ OMAPFB_CAPS_WINDOW_SCALE,   \"scale window\" },\n\t{ OMAPFB_CAPS_WINDOW_OVERLAY, \"overlay window\" },\n\t{ OMAPFB_CAPS_WINDOW_ROTATE,  \"rotate window\" },\n\t{ OMAPFB_CAPS_SET_BACKLIGHT,  \"backlight setting\" },\n};\n\nstatic const struct caps_table_struct color_caps[] = {\n\t{ 1 << OMAPFB_COLOR_RGB565,\t\"RGB565\", },\n\t{ 1 << OMAPFB_COLOR_YUV422,\t\"YUV422\", },\n\t{ 1 << OMAPFB_COLOR_YUV420,\t\"YUV420\", },\n\t{ 1 << OMAPFB_COLOR_CLUT_8BPP,\t\"CLUT8\", },\n\t{ 1 << OMAPFB_COLOR_CLUT_4BPP,\t\"CLUT4\", },\n\t{ 1 << OMAPFB_COLOR_CLUT_2BPP,\t\"CLUT2\", },\n\t{ 1 << OMAPFB_COLOR_CLUT_1BPP,\t\"CLUT1\", },\n\t{ 1 << OMAPFB_COLOR_RGB444,\t\"RGB444\", },\n\t{ 1 << OMAPFB_COLOR_YUY422,\t\"YUY422\", },\n};\n\nstatic void omapdss_release(struct device *dev)\n{\n}\n\n \nstatic struct platform_device omapdss_device = {\n\t.name\t\t= \"omapdss_dss\",\n\t.id\t\t= -1,\n\t.dev            = {\n\t\t.release = omapdss_release,\n\t},\n};\n\n \nextern struct lcd_ctrl hwa742_ctrl;\n\nstatic const struct lcd_ctrl *ctrls[] = {\n\t&omap1_int_ctrl,\n\n#ifdef CONFIG_FB_OMAP_LCDC_HWA742\n\t&hwa742_ctrl,\n#endif\n};\n\n#ifdef CONFIG_FB_OMAP_LCDC_EXTERNAL\nextern struct lcd_ctrl_extif omap1_ext_if;\n#endif\n\nstatic void omapfb_rqueue_lock(struct omapfb_device *fbdev)\n{\n\tmutex_lock(&fbdev->rqueue_mutex);\n}\n\nstatic void omapfb_rqueue_unlock(struct omapfb_device *fbdev)\n{\n\tmutex_unlock(&fbdev->rqueue_mutex);\n}\n\n \n \nstatic int ctrl_init(struct omapfb_device *fbdev)\n{\n\tint r;\n\tint i;\n\n\t \n\tif (def_vram_cnt) {\n\t\tfor (i = 0; i < def_vram_cnt; i++)\n\t\t\tfbdev->mem_desc.region[i].size =\n\t\t\t\tPAGE_ALIGN(def_vram[i]);\n\t\tfbdev->mem_desc.region_cnt = i;\n\t}\n\n\tif (!fbdev->mem_desc.region_cnt) {\n\t\tstruct lcd_panel *panel = fbdev->panel;\n\t\tint def_size;\n\t\tint bpp = panel->bpp;\n\n\t\t \n\t\tif (bpp == 12)\n\t\t\tbpp = 16;\n\t\tdef_size = def_vxres * def_vyres * bpp / 8;\n\t\tfbdev->mem_desc.region_cnt = 1;\n\t\tfbdev->mem_desc.region[0].size = PAGE_ALIGN(def_size);\n\t}\n\tr = fbdev->ctrl->init(fbdev, 0, &fbdev->mem_desc);\n\tif (r < 0) {\n\t\tdev_err(fbdev->dev, \"controller initialization failed (%d)\\n\",\n\t\t\tr);\n\t\treturn r;\n\t}\n\n#ifdef DEBUG\n\tfor (i = 0; i < fbdev->mem_desc.region_cnt; i++) {\n\t\tdev_dbg(fbdev->dev, \"region%d phys %08x virt %p size=%lu\\n\",\n\t\t\t i,\n\t\t\t fbdev->mem_desc.region[i].paddr,\n\t\t\t fbdev->mem_desc.region[i].vaddr,\n\t\t\t fbdev->mem_desc.region[i].size);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic void ctrl_cleanup(struct omapfb_device *fbdev)\n{\n\tfbdev->ctrl->cleanup();\n}\n\n \nstatic int ctrl_change_mode(struct fb_info *fbi)\n{\n\tint r;\n\tunsigned long offset;\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tstruct fb_var_screeninfo *var = &fbi->var;\n\n\toffset = var->yoffset * fbi->fix.line_length +\n\t\t var->xoffset * var->bits_per_pixel / 8;\n\n\tif (fbdev->ctrl->sync)\n\t\tfbdev->ctrl->sync();\n\tr = fbdev->ctrl->setup_plane(plane->idx, plane->info.channel_out,\n\t\t\t\t offset, var->xres_virtual,\n\t\t\t\t plane->info.pos_x, plane->info.pos_y,\n\t\t\t\t var->xres, var->yres, plane->color_mode);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (fbdev->ctrl->set_rotate != NULL) {\n\t\tr = fbdev->ctrl->set_rotate(var->rotate);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (fbdev->ctrl->set_scale != NULL)\n\t\tr = fbdev->ctrl->set_scale(plane->idx,\n\t\t\t\t   var->xres, var->yres,\n\t\t\t\t   plane->info.out_width,\n\t\t\t\t   plane->info.out_height);\n\n\treturn r;\n}\n\n \n \nstatic int omapfb_open(struct fb_info *info, int user)\n{\n\treturn 0;\n}\n\nstatic void omapfb_sync(struct fb_info *info);\n\n \nstatic int omapfb_release(struct fb_info *info, int user)\n{\n\tomapfb_sync(info);\n\treturn 0;\n}\n\n \nstatic int _setcolreg(struct fb_info *info, u_int regno, u_int red, u_int green,\n\t\t\tu_int blue, u_int transp, int update_hw_pal)\n{\n\tstruct omapfb_plane_struct *plane = info->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tint r = 0;\n\n\tswitch (plane->color_mode) {\n\tcase OMAPFB_COLOR_YUV422:\n\tcase OMAPFB_COLOR_YUV420:\n\tcase OMAPFB_COLOR_YUY422:\n\t\tr = -EINVAL;\n\t\tbreak;\n\tcase OMAPFB_COLOR_CLUT_8BPP:\n\tcase OMAPFB_COLOR_CLUT_4BPP:\n\tcase OMAPFB_COLOR_CLUT_2BPP:\n\tcase OMAPFB_COLOR_CLUT_1BPP:\n\t\tif (fbdev->ctrl->setcolreg)\n\t\t\tr = fbdev->ctrl->setcolreg(regno, red, green, blue,\n\t\t\t\t\t\t\ttransp, update_hw_pal);\n\t\tfallthrough;\n\tcase OMAPFB_COLOR_RGB565:\n\tcase OMAPFB_COLOR_RGB444:\n\t\tif (r != 0)\n\t\t\tbreak;\n\n\t\tif (regno < 16) {\n\t\t\tu16 pal;\n\t\t\tpal = ((red >> (16 - var->red.length)) <<\n\t\t\t\t\tvar->red.offset) |\n\t\t\t      ((green >> (16 - var->green.length)) <<\n\t\t\t\t\tvar->green.offset) |\n\t\t\t      (blue >> (16 - var->blue.length));\n\t\t\t((u32 *)(info->pseudo_palette))[regno] = pal;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn r;\n}\n\nstatic int omapfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t    u_int transp, struct fb_info *info)\n{\n\treturn _setcolreg(info, regno, red, green, blue, transp, 1);\n}\n\nstatic int omapfb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tint count, index, r;\n\tu16 *red, *green, *blue, *transp;\n\tu16 trans = 0xffff;\n\n\tred     = cmap->red;\n\tgreen   = cmap->green;\n\tblue    = cmap->blue;\n\ttransp  = cmap->transp;\n\tindex   = cmap->start;\n\n\tfor (count = 0; count < cmap->len; count++) {\n\t\tif (transp)\n\t\t\ttrans = *transp++;\n\t\tr = _setcolreg(info, index++, *red++, *green++, *blue++, trans,\n\t\t\t\tcount == cmap->len - 1);\n\t\tif (r != 0)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int omapfb_update_full_screen(struct fb_info *fbi);\n\nstatic int omapfb_blank(int blank, struct fb_info *fbi)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tint do_update = 0;\n\tint r = 0;\n\n\tomapfb_rqueue_lock(fbdev);\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\n\t\tif (fbdev->state == OMAPFB_SUSPENDED) {\n\t\t\tif (fbdev->ctrl->resume)\n\t\t\t\tfbdev->ctrl->resume();\n\t\t\tif (fbdev->panel->enable)\n\t\t\t\tfbdev->panel->enable(fbdev->panel);\n\t\t\tfbdev->state = OMAPFB_ACTIVE;\n\t\t\tif (fbdev->ctrl->get_update_mode() ==\n\t\t\t\t\tOMAPFB_MANUAL_UPDATE)\n\t\t\t\tdo_update = 1;\n\t\t}\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tif (fbdev->state == OMAPFB_ACTIVE) {\n\t\t\tif (fbdev->panel->disable)\n\t\t\t\tfbdev->panel->disable(fbdev->panel);\n\t\t\tif (fbdev->ctrl->suspend)\n\t\t\t\tfbdev->ctrl->suspend();\n\t\t\tfbdev->state = OMAPFB_SUSPENDED;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t}\n\tomapfb_rqueue_unlock(fbdev);\n\n\tif (r == 0 && do_update)\n\t\tr = omapfb_update_full_screen(fbi);\n\n\treturn r;\n}\n\nstatic void omapfb_sync(struct fb_info *fbi)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\n\tomapfb_rqueue_lock(fbdev);\n\tif (fbdev->ctrl->sync)\n\t\tfbdev->ctrl->sync();\n\tomapfb_rqueue_unlock(fbdev);\n}\n\n \nstatic void set_fb_fix(struct fb_info *fbi, int from_init)\n{\n\tstruct fb_fix_screeninfo *fix = &fbi->fix;\n\tstruct fb_var_screeninfo *var = &fbi->var;\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_mem_region *rg;\n\tint bpp;\n\n\trg = &plane->fbdev->mem_desc.region[plane->idx];\n\tfbi->screen_base\t= rg->vaddr;\n\n\tif (!from_init) {\n\t\tmutex_lock(&fbi->mm_lock);\n\t\tfix->smem_start\t\t= rg->paddr;\n\t\tfix->smem_len\t\t= rg->size;\n\t\tmutex_unlock(&fbi->mm_lock);\n\t} else {\n\t\tfix->smem_start\t\t= rg->paddr;\n\t\tfix->smem_len\t\t= rg->size;\n\t}\n\n\tfix->type = FB_TYPE_PACKED_PIXELS;\n\tbpp = var->bits_per_pixel;\n\tif (var->nonstd)\n\t\tfix->visual = FB_VISUAL_PSEUDOCOLOR;\n\telse switch (var->bits_per_pixel) {\n\tcase 16:\n\tcase 12:\n\t\tfix->visual = FB_VISUAL_TRUECOLOR;\n\t\t \n\t\tbpp = 16;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\t\tfix->visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\t}\n\tfix->accel\t\t= FB_ACCEL_OMAP1610;\n\tfix->line_length\t= var->xres_virtual * bpp / 8;\n}\n\nstatic int set_color_mode(struct omapfb_plane_struct *plane,\n\t\t\t  struct fb_var_screeninfo *var)\n{\n\tswitch (var->nonstd) {\n\tcase 0:\n\t\tbreak;\n\tcase OMAPFB_COLOR_YUV422:\n\t\tvar->bits_per_pixel = 16;\n\t\tplane->color_mode = var->nonstd;\n\t\treturn 0;\n\tcase OMAPFB_COLOR_YUV420:\n\t\tvar->bits_per_pixel = 12;\n\t\tplane->color_mode = var->nonstd;\n\t\treturn 0;\n\tcase OMAPFB_COLOR_YUY422:\n\t\tvar->bits_per_pixel = 16;\n\t\tplane->color_mode = var->nonstd;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (var->bits_per_pixel) {\n\tcase 1:\n\t\tplane->color_mode = OMAPFB_COLOR_CLUT_1BPP;\n\t\treturn 0;\n\tcase 2:\n\t\tplane->color_mode = OMAPFB_COLOR_CLUT_2BPP;\n\t\treturn 0;\n\tcase 4:\n\t\tplane->color_mode = OMAPFB_COLOR_CLUT_4BPP;\n\t\treturn 0;\n\tcase 8:\n\t\tplane->color_mode = OMAPFB_COLOR_CLUT_8BPP;\n\t\treturn 0;\n\tcase 12:\n\t\tvar->bits_per_pixel = 16;\n\t\tfallthrough;\n\tcase 16:\n\t\tif (plane->fbdev->panel->bpp == 12)\n\t\t\tplane->color_mode = OMAPFB_COLOR_RGB444;\n\t\telse\n\t\t\tplane->color_mode = OMAPFB_COLOR_RGB565;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int set_fb_var(struct fb_info *fbi,\n\t\t      struct fb_var_screeninfo *var)\n{\n\tint\t\tbpp;\n\tunsigned long\tmax_frame_size;\n\tunsigned long\tline_size;\n\tint\t\txres_min, xres_max;\n\tint\t\tyres_min, yres_max;\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tstruct lcd_panel *panel = fbdev->panel;\n\n\tif (set_color_mode(plane, var) < 0)\n\t\treturn -EINVAL;\n\n\tbpp = var->bits_per_pixel;\n\tif (plane->color_mode == OMAPFB_COLOR_RGB444)\n\t\tbpp = 16;\n\n\tswitch (var->rotate) {\n\tcase 0:\n\tcase 180:\n\t\txres_min = OMAPFB_PLANE_XRES_MIN;\n\t\txres_max = panel->x_res;\n\t\tyres_min = OMAPFB_PLANE_YRES_MIN;\n\t\tyres_max = panel->y_res;\n\t\tif (cpu_is_omap15xx()) {\n\t\t\tvar->xres = panel->x_res;\n\t\t\tvar->yres = panel->y_res;\n\t\t}\n\t\tbreak;\n\tcase 90:\n\tcase 270:\n\t\txres_min = OMAPFB_PLANE_YRES_MIN;\n\t\txres_max = panel->y_res;\n\t\tyres_min = OMAPFB_PLANE_XRES_MIN;\n\t\tyres_max = panel->x_res;\n\t\tif (cpu_is_omap15xx()) {\n\t\t\tvar->xres = panel->y_res;\n\t\t\tvar->yres = panel->x_res;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->xres < xres_min)\n\t\tvar->xres = xres_min;\n\tif (var->yres < yres_min)\n\t\tvar->yres = yres_min;\n\tif (var->xres > xres_max)\n\t\tvar->xres = xres_max;\n\tif (var->yres > yres_max)\n\t\tvar->yres = yres_max;\n\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres_virtual = var->yres;\n\tmax_frame_size = fbdev->mem_desc.region[plane->idx].size;\n\tline_size = var->xres_virtual * bpp / 8;\n\tif (line_size * var->yres_virtual > max_frame_size) {\n\t\t \n\t\tline_size = max_frame_size / var->yres_virtual;\n\t\tvar->xres_virtual = line_size * 8 / bpp;\n\t\tif (var->xres_virtual < var->xres) {\n\t\t\t \n\t\t\tvar->xres_virtual = var->xres;\n\t\t\tline_size = var->xres * bpp / 8;\n\t\t\tvar->yres_virtual = max_frame_size / line_size;\n\t\t}\n\t\t \n\t\tif (var->xres_virtual < var->xres)\n\t\t\tvar->xres = var->xres_virtual;\n\t\tif (var->yres_virtual < var->yres)\n\t\t\tvar->yres = var->yres_virtual;\n\t\tif (var->xres < xres_min || var->yres < yres_min)\n\t\t\treturn -EINVAL;\n\t}\n\tif (var->xres + var->xoffset > var->xres_virtual)\n\t\tvar->xoffset = var->xres_virtual - var->xres;\n\tif (var->yres + var->yoffset > var->yres_virtual)\n\t\tvar->yoffset = var->yres_virtual - var->yres;\n\n\tif (plane->color_mode == OMAPFB_COLOR_RGB444) {\n\t\tvar->red.offset\t\t= 8;\n\t\tvar->red.length\t\t= 4;\n\t\tvar->red.msb_right\t= 0;\n\t\tvar->green.offset\t= 4;\n\t\tvar->green.length\t= 4;\n\t\tvar->green.msb_right\t= 0;\n\t\tvar->blue.offset\t= 0;\n\t\tvar->blue.length\t= 4;\n\t\tvar->blue.msb_right\t= 0;\n\t} else {\n\t\tvar->red.offset\t\t= 11;\n\t\tvar->red.length\t\t= 5;\n\t\tvar->red.msb_right\t= 0;\n\t\tvar->green.offset\t= 5;\n\t\tvar->green.length\t= 6;\n\t\tvar->green.msb_right\t= 0;\n\t\tvar->blue.offset\t= 0;\n\t\tvar->blue.length\t= 5;\n\t\tvar->blue.msb_right\t= 0;\n\t}\n\n\tvar->height\t\t= -1;\n\tvar->width\t\t= -1;\n\tvar->grayscale\t\t= 0;\n\n\t \n\tvar->pixclock\t\t= 10000000 / (panel->pixel_clock / 100);\n\tvar->left_margin\t= panel->hfp;\n\tvar->right_margin\t= panel->hbp;\n\tvar->upper_margin\t= panel->vfp;\n\tvar->lower_margin\t= panel->vbp;\n\tvar->hsync_len\t\t= panel->hsw;\n\tvar->vsync_len\t\t= panel->vsw;\n\n\t \n\tvar->vmode\t\t= FB_VMODE_NONINTERLACED;\n\tvar->sync\t\t= 0;\n\n\treturn 0;\n}\n\n\n \nstatic int omapfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t       struct fb_info *fbi)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tint r = 0;\n\n\tomapfb_rqueue_lock(fbdev);\n\tif (var->xoffset != fbi->var.xoffset ||\n\t    var->yoffset != fbi->var.yoffset) {\n\t\tstruct fb_var_screeninfo *new_var = &fbdev->new_var;\n\n\t\tmemcpy(new_var, &fbi->var, sizeof(*new_var));\n\t\tnew_var->xoffset = var->xoffset;\n\t\tnew_var->yoffset = var->yoffset;\n\t\tif (set_fb_var(fbi, new_var))\n\t\t\tr = -EINVAL;\n\t\telse {\n\t\t\tmemcpy(&fbi->var, new_var, sizeof(*new_var));\n\t\t\tctrl_change_mode(fbi);\n\t\t}\n\t}\n\tomapfb_rqueue_unlock(fbdev);\n\n\treturn r;\n}\n\n \nstatic int omapfb_mirror(struct fb_info *fbi, int mirror)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tint r = 0;\n\n\tomapfb_rqueue_lock(fbdev);\n\tmirror = mirror ? 1 : 0;\n\tif (cpu_is_omap15xx())\n\t\tr = -EINVAL;\n\telse if (mirror != plane->info.mirror) {\n\t\tplane->info.mirror = mirror;\n\t\tr = ctrl_change_mode(fbi);\n\t}\n\tomapfb_rqueue_unlock(fbdev);\n\n\treturn r;\n}\n\n \nstatic int omapfb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tint r;\n\n\tomapfb_rqueue_lock(fbdev);\n\tif (fbdev->ctrl->sync != NULL)\n\t\tfbdev->ctrl->sync();\n\tr = set_fb_var(fbi, var);\n\tomapfb_rqueue_unlock(fbdev);\n\n\treturn r;\n}\n\n \nstatic int omapfb_set_par(struct fb_info *fbi)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tint r = 0;\n\n\tomapfb_rqueue_lock(fbdev);\n\tset_fb_fix(fbi, 0);\n\tr = ctrl_change_mode(fbi);\n\tomapfb_rqueue_unlock(fbdev);\n\n\treturn r;\n}\n\nstatic int omapfb_update_window_async(struct fb_info *fbi,\n\t\t\t\tstruct omapfb_update_window *win,\n\t\t\t\tvoid (*callback)(void *),\n\t\t\t\tvoid *callback_data)\n{\n\tint xres, yres;\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tstruct fb_var_screeninfo *var = &fbi->var;\n\n\tswitch (var->rotate) {\n\tcase 0:\n\tcase 180:\n\t\txres = fbdev->panel->x_res;\n\t\tyres = fbdev->panel->y_res;\n\t\tbreak;\n\tcase 90:\n\tcase 270:\n\t\txres = fbdev->panel->y_res;\n\t\tyres = fbdev->panel->x_res;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (win->x >= xres || win->y >= yres ||\n\t    win->out_x > xres || win->out_y > yres)\n\t\treturn -EINVAL;\n\n\tif (!fbdev->ctrl->update_window ||\n\t    fbdev->ctrl->get_update_mode() != OMAPFB_MANUAL_UPDATE)\n\t\treturn -ENODEV;\n\n\tif (win->x + win->width > xres)\n\t\twin->width = xres - win->x;\n\tif (win->y + win->height > yres)\n\t\twin->height = yres - win->y;\n\tif (win->out_x + win->out_width > xres)\n\t\twin->out_width = xres - win->out_x;\n\tif (win->out_y + win->out_height > yres)\n\t\twin->out_height = yres - win->out_y;\n\tif (!win->width || !win->height || !win->out_width || !win->out_height)\n\t\treturn 0;\n\n\treturn fbdev->ctrl->update_window(fbi, win, callback, callback_data);\n}\n\nstatic int omapfb_update_win(struct fb_info *fbi,\n\t\t\t\tstruct omapfb_update_window *win)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tint ret;\n\n\tomapfb_rqueue_lock(plane->fbdev);\n\tret = omapfb_update_window_async(fbi, win, NULL, NULL);\n\tomapfb_rqueue_unlock(plane->fbdev);\n\n\treturn ret;\n}\n\nstatic int omapfb_update_full_screen(struct fb_info *fbi)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tstruct omapfb_update_window win;\n\tint r;\n\n\tif (!fbdev->ctrl->update_window ||\n\t    fbdev->ctrl->get_update_mode() != OMAPFB_MANUAL_UPDATE)\n\t\treturn -ENODEV;\n\n\twin.x = 0;\n\twin.y = 0;\n\twin.width = fbi->var.xres;\n\twin.height = fbi->var.yres;\n\twin.out_x = 0;\n\twin.out_y = 0;\n\twin.out_width = fbi->var.xres;\n\twin.out_height = fbi->var.yres;\n\twin.format = 0;\n\n\tomapfb_rqueue_lock(fbdev);\n\tr = fbdev->ctrl->update_window(fbi, &win, NULL, NULL);\n\tomapfb_rqueue_unlock(fbdev);\n\n\treturn r;\n}\n\nstatic int omapfb_setup_plane(struct fb_info *fbi, struct omapfb_plane_info *pi)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tstruct lcd_panel *panel = fbdev->panel;\n\tstruct omapfb_plane_info old_info;\n\tint r = 0;\n\n\tif (pi->pos_x + pi->out_width > panel->x_res ||\n\t    pi->pos_y + pi->out_height > panel->y_res)\n\t\treturn -EINVAL;\n\n\tomapfb_rqueue_lock(fbdev);\n\tif (pi->enabled && !fbdev->mem_desc.region[plane->idx].size) {\n\t\t \n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\told_info = plane->info;\n\tplane->info = *pi;\n\tif (pi->enabled) {\n\t\tr = ctrl_change_mode(fbi);\n\t\tif (r < 0) {\n\t\t\tplane->info = old_info;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tr = fbdev->ctrl->enable_plane(plane->idx, pi->enabled);\n\tif (r < 0) {\n\t\tplane->info = old_info;\n\t\tgoto out;\n\t}\nout:\n\tomapfb_rqueue_unlock(fbdev);\n\treturn r;\n}\n\nstatic int omapfb_query_plane(struct fb_info *fbi, struct omapfb_plane_info *pi)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\n\t*pi = plane->info;\n\treturn 0;\n}\n\nstatic int omapfb_setup_mem(struct fb_info *fbi, struct omapfb_mem_info *mi)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tstruct omapfb_mem_region *rg = &fbdev->mem_desc.region[plane->idx];\n\tsize_t size;\n\tint r = 0;\n\n\tif (fbdev->ctrl->setup_mem == NULL)\n\t\treturn -ENODEV;\n\tif (mi->type != OMAPFB_MEMTYPE_SDRAM)\n\t\treturn -EINVAL;\n\n\tsize = PAGE_ALIGN(mi->size);\n\tomapfb_rqueue_lock(fbdev);\n\tif (plane->info.enabled) {\n\t\tr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (rg->size != size || rg->type != mi->type) {\n\t\tstruct fb_var_screeninfo *new_var = &fbdev->new_var;\n\t\tunsigned long old_size = rg->size;\n\t\tu8\t      old_type = rg->type;\n\t\tunsigned long paddr;\n\n\t\trg->size = size;\n\t\trg->type = mi->type;\n\t\t \n\t\tif (old_size != size && size) {\n\t\t\tif (size) {\n\t\t\t\tmemcpy(new_var, &fbi->var, sizeof(*new_var));\n\t\t\t\tr = set_fb_var(fbi, new_var);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (fbdev->ctrl->sync)\n\t\t\tfbdev->ctrl->sync();\n\t\tr = fbdev->ctrl->setup_mem(plane->idx, size, mi->type, &paddr);\n\t\tif (r < 0) {\n\t\t\t \n\t\t\trg->size = old_size;\n\t\t\trg->type = old_type;\n\t\t\tgoto out;\n\t\t}\n\t\trg->paddr = paddr;\n\n\t\tif (old_size != size) {\n\t\t\tif (size) {\n\t\t\t\tmemcpy(&fbi->var, new_var, sizeof(fbi->var));\n\t\t\t\tset_fb_fix(fbi, 0);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmutex_lock(&fbi->mm_lock);\n\t\t\t\tfbi->fix.smem_start = 0;\n\t\t\t\tfbi->fix.smem_len = 0;\n\t\t\t\tmutex_unlock(&fbi->mm_lock);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tomapfb_rqueue_unlock(fbdev);\n\n\treturn r;\n}\n\nstatic int omapfb_query_mem(struct fb_info *fbi, struct omapfb_mem_info *mi)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tstruct omapfb_mem_region *rg;\n\n\trg = &fbdev->mem_desc.region[plane->idx];\n\tmemset(mi, 0, sizeof(*mi));\n\tmi->size = rg->size;\n\tmi->type = rg->type;\n\n\treturn 0;\n}\n\nstatic int omapfb_set_color_key(struct omapfb_device *fbdev,\n\t\t\t\tstruct omapfb_color_key *ck)\n{\n\tint r;\n\n\tif (!fbdev->ctrl->set_color_key)\n\t\treturn -ENODEV;\n\n\tomapfb_rqueue_lock(fbdev);\n\tr = fbdev->ctrl->set_color_key(ck);\n\tomapfb_rqueue_unlock(fbdev);\n\n\treturn r;\n}\n\nstatic int omapfb_get_color_key(struct omapfb_device *fbdev,\n\t\t\t\tstruct omapfb_color_key *ck)\n{\n\tint r;\n\n\tif (!fbdev->ctrl->get_color_key)\n\t\treturn -ENODEV;\n\n\tomapfb_rqueue_lock(fbdev);\n\tr = fbdev->ctrl->get_color_key(ck);\n\tomapfb_rqueue_unlock(fbdev);\n\n\treturn r;\n}\n\nstatic struct blocking_notifier_head omapfb_client_list[OMAPFB_PLANE_NUM];\nstatic int notifier_inited;\n\nstatic void omapfb_init_notifier(void)\n{\n\tint i;\n\n\tfor (i = 0; i < OMAPFB_PLANE_NUM; i++)\n\t\tBLOCKING_INIT_NOTIFIER_HEAD(&omapfb_client_list[i]);\n}\n\nint omapfb_register_client(struct omapfb_notifier_block *omapfb_nb,\n\t\t\t\tomapfb_notifier_callback_t callback,\n\t\t\t\tvoid *callback_data)\n{\n\tint r;\n\n\tif ((unsigned)omapfb_nb->plane_idx >= OMAPFB_PLANE_NUM)\n\t\treturn -EINVAL;\n\n\tif (!notifier_inited) {\n\t\tomapfb_init_notifier();\n\t\tnotifier_inited = 1;\n\t}\n\n\tomapfb_nb->nb.notifier_call = (int (*)(struct notifier_block *,\n\t\t\t\t\tunsigned long, void *))callback;\n\tomapfb_nb->data = callback_data;\n\tr = blocking_notifier_chain_register(\n\t\t\t\t&omapfb_client_list[omapfb_nb->plane_idx],\n\t\t\t\t&omapfb_nb->nb);\n\tif (r)\n\t\treturn r;\n\tif (omapfb_dev != NULL &&\n\t    omapfb_dev->ctrl && omapfb_dev->ctrl->bind_client) {\n\t\tomapfb_dev->ctrl->bind_client(omapfb_nb);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(omapfb_register_client);\n\nint omapfb_unregister_client(struct omapfb_notifier_block *omapfb_nb)\n{\n\treturn blocking_notifier_chain_unregister(\n\t\t&omapfb_client_list[omapfb_nb->plane_idx], &omapfb_nb->nb);\n}\nEXPORT_SYMBOL(omapfb_unregister_client);\n\nvoid omapfb_notify_clients(struct omapfb_device *fbdev, unsigned long event)\n{\n\tint i;\n\n\tif (!notifier_inited)\n\t\t \n\t\treturn;\n\n\tfor (i = 0; i < OMAPFB_PLANE_NUM; i++)\n\t\tblocking_notifier_call_chain(&omapfb_client_list[i], event,\n\t\t\t\t    fbdev->fb_info[i]);\n}\nEXPORT_SYMBOL(omapfb_notify_clients);\n\nstatic int omapfb_set_update_mode(struct omapfb_device *fbdev,\n\t\t\t\t   enum omapfb_update_mode mode)\n{\n\tint r;\n\n\tomapfb_rqueue_lock(fbdev);\n\tr = fbdev->ctrl->set_update_mode(mode);\n\tomapfb_rqueue_unlock(fbdev);\n\n\treturn r;\n}\n\nstatic enum omapfb_update_mode omapfb_get_update_mode(struct omapfb_device *fbdev)\n{\n\tint r;\n\n\tomapfb_rqueue_lock(fbdev);\n\tr = fbdev->ctrl->get_update_mode();\n\tomapfb_rqueue_unlock(fbdev);\n\n\treturn r;\n}\n\nstatic void omapfb_get_caps(struct omapfb_device *fbdev, int plane,\n\t\t\t\t     struct omapfb_caps *caps)\n{\n\tmemset(caps, 0, sizeof(*caps));\n\tfbdev->ctrl->get_caps(plane, caps);\n\tif (fbdev->panel->get_caps)\n\t\tcaps->ctrl |= fbdev->panel->get_caps(fbdev->panel);\n}\n\n \nvoid omapfb_write_first_pixel(struct omapfb_device *fbdev, u16 pixval)\n{\n\tomapfb_rqueue_lock(fbdev);\n\t*(u16 *)fbdev->mem_desc.region[0].vaddr = pixval;\n\tif (fbdev->ctrl->get_update_mode() == OMAPFB_MANUAL_UPDATE) {\n\t\tstruct omapfb_update_window win;\n\n\t\tmemset(&win, 0, sizeof(win));\n\t\twin.width = 2;\n\t\twin.height = 2;\n\t\twin.out_width = 2;\n\t\twin.out_height = 2;\n\t\tfbdev->ctrl->update_window(fbdev->fb_info[0], &win, NULL, NULL);\n\t}\n\tomapfb_rqueue_unlock(fbdev);\n}\nEXPORT_SYMBOL(omapfb_write_first_pixel);\n\n \nstatic int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct omapfb_plane_struct *plane = fbi->par;\n\tstruct omapfb_device\t*fbdev = plane->fbdev;\n\tconst struct fb_ops *ops = fbi->fbops;\n\tunion {\n\t\tstruct omapfb_update_window\tupdate_window;\n\t\tstruct omapfb_plane_info\tplane_info;\n\t\tstruct omapfb_mem_info\t\tmem_info;\n\t\tstruct omapfb_color_key\t\tcolor_key;\n\t\tenum omapfb_update_mode\t\tupdate_mode;\n\t\tstruct omapfb_caps\t\tcaps;\n\t\tunsigned int\t\tmirror;\n\t\tint\t\t\tplane_out;\n\t\tint\t\t\tenable_plane;\n\t} p;\n\tint r = 0;\n\n\tBUG_ON(!ops);\n\tswitch (cmd) {\n\tcase OMAPFB_MIRROR:\n\t\tif (get_user(p.mirror, (int __user *)arg))\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tomapfb_mirror(fbi, p.mirror);\n\t\tbreak;\n\tcase OMAPFB_SYNC_GFX:\n\t\tomapfb_sync(fbi);\n\t\tbreak;\n\tcase OMAPFB_VSYNC:\n\t\tbreak;\n\tcase OMAPFB_SET_UPDATE_MODE:\n\t\tif (get_user(p.update_mode, (int __user *)arg))\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tr = omapfb_set_update_mode(fbdev, p.update_mode);\n\t\tbreak;\n\tcase OMAPFB_GET_UPDATE_MODE:\n\t\tp.update_mode = omapfb_get_update_mode(fbdev);\n\t\tif (put_user(p.update_mode,\n\t\t\t\t\t(enum omapfb_update_mode __user *)arg))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\tcase OMAPFB_UPDATE_WINDOW_OLD:\n\t\tif (copy_from_user(&p.update_window, (void __user *)arg,\n\t\t\t\t   sizeof(struct omapfb_update_window_old)))\n\t\t\tr = -EFAULT;\n\t\telse {\n\t\t\tstruct omapfb_update_window *u = &p.update_window;\n\t\t\tu->out_x = u->x;\n\t\t\tu->out_y = u->y;\n\t\t\tu->out_width = u->width;\n\t\t\tu->out_height = u->height;\n\t\t\tmemset(u->reserved, 0, sizeof(u->reserved));\n\t\t\tr = omapfb_update_win(fbi, u);\n\t\t}\n\t\tbreak;\n\tcase OMAPFB_UPDATE_WINDOW:\n\t\tif (copy_from_user(&p.update_window, (void __user *)arg,\n\t\t\t\t   sizeof(p.update_window)))\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tr = omapfb_update_win(fbi, &p.update_window);\n\t\tbreak;\n\tcase OMAPFB_SETUP_PLANE:\n\t\tif (copy_from_user(&p.plane_info, (void __user *)arg,\n\t\t\t\t   sizeof(p.plane_info)))\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tr = omapfb_setup_plane(fbi, &p.plane_info);\n\t\tbreak;\n\tcase OMAPFB_QUERY_PLANE:\n\t\tif ((r = omapfb_query_plane(fbi, &p.plane_info)) < 0)\n\t\t\tbreak;\n\t\tif (copy_to_user((void __user *)arg, &p.plane_info,\n\t\t\t\t   sizeof(p.plane_info)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\tcase OMAPFB_SETUP_MEM:\n\t\tif (copy_from_user(&p.mem_info, (void __user *)arg,\n\t\t\t\t   sizeof(p.mem_info)))\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tr = omapfb_setup_mem(fbi, &p.mem_info);\n\t\tbreak;\n\tcase OMAPFB_QUERY_MEM:\n\t\tif ((r = omapfb_query_mem(fbi, &p.mem_info)) < 0)\n\t\t\tbreak;\n\t\tif (copy_to_user((void __user *)arg, &p.mem_info,\n\t\t\t\t   sizeof(p.mem_info)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\tcase OMAPFB_SET_COLOR_KEY:\n\t\tif (copy_from_user(&p.color_key, (void __user *)arg,\n\t\t\t\t   sizeof(p.color_key)))\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tr = omapfb_set_color_key(fbdev, &p.color_key);\n\t\tbreak;\n\tcase OMAPFB_GET_COLOR_KEY:\n\t\tif ((r = omapfb_get_color_key(fbdev, &p.color_key)) < 0)\n\t\t\tbreak;\n\t\tif (copy_to_user((void __user *)arg, &p.color_key,\n\t\t\t\t sizeof(p.color_key)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\tcase OMAPFB_GET_CAPS:\n\t\tomapfb_get_caps(fbdev, plane->idx, &p.caps);\n\t\tif (copy_to_user((void __user *)arg, &p.caps, sizeof(p.caps)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\tcase OMAPFB_LCD_TEST:\n\t\t{\n\t\t\tint test_num;\n\n\t\t\tif (get_user(test_num, (int __user *)arg)) {\n\t\t\t\tr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!fbdev->panel->run_test) {\n\t\t\t\tr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = fbdev->panel->run_test(fbdev->panel, test_num);\n\t\t\tbreak;\n\t\t}\n\tcase OMAPFB_CTRL_TEST:\n\t\t{\n\t\t\tint test_num;\n\n\t\t\tif (get_user(test_num, (int __user *)arg)) {\n\t\t\t\tr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!fbdev->ctrl->run_test) {\n\t\t\t\tr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = fbdev->ctrl->run_test(test_num);\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\n\n\treturn r;\n}\n\nstatic int omapfb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct omapfb_plane_struct *plane = info->par;\n\tstruct omapfb_device *fbdev = plane->fbdev;\n\tint r;\n\n\tomapfb_rqueue_lock(fbdev);\n\tr = fbdev->ctrl->mmap(info, vma);\n\tomapfb_rqueue_unlock(fbdev);\n\n\treturn r;\n}\n\n \nstatic struct fb_ops omapfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_open        = omapfb_open,\n\t.fb_release     = omapfb_release,\n\t.fb_setcolreg\t= omapfb_setcolreg,\n\t.fb_setcmap\t= omapfb_setcmap,\n\t.fb_blank       = omapfb_blank,\n\t.fb_ioctl\t= omapfb_ioctl,\n\t.fb_check_var\t= omapfb_check_var,\n\t.fb_set_par\t= omapfb_set_par,\n\t.fb_pan_display = omapfb_pan_display,\n};\n\n \n \nstatic ssize_t omapfb_show_caps_num(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct omapfb_device *fbdev = dev_get_drvdata(dev);\n\tint plane;\n\tsize_t size;\n\tstruct omapfb_caps caps;\n\n\tplane = 0;\n\tsize = 0;\n\twhile (size < PAGE_SIZE && plane < OMAPFB_PLANE_NUM) {\n\t\tomapfb_get_caps(fbdev, plane, &caps);\n\t\tsize += scnprintf(&buf[size], PAGE_SIZE - size,\n\t\t\t\"plane#%d %#010x %#010x %#010x\\n\",\n\t\t\tplane, caps.ctrl, caps.plane_color, caps.wnd_color);\n\t\tplane++;\n\t}\n\treturn size;\n}\n\nstatic ssize_t omapfb_show_caps_text(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct omapfb_device *fbdev = dev_get_drvdata(dev);\n\tint i;\n\tstruct omapfb_caps caps;\n\tint plane;\n\tsize_t size;\n\n\tplane = 0;\n\tsize = 0;\n\twhile (size < PAGE_SIZE && plane < OMAPFB_PLANE_NUM) {\n\t\tomapfb_get_caps(fbdev, plane, &caps);\n\t\tsize += scnprintf(&buf[size], PAGE_SIZE - size,\n\t\t\t\t \"plane#%d:\\n\", plane);\n\t\tfor (i = 0; i < ARRAY_SIZE(ctrl_caps) &&\n\t\t     size < PAGE_SIZE; i++) {\n\t\t\tif (ctrl_caps[i].flag & caps.ctrl)\n\t\t\t\tsize += scnprintf(&buf[size], PAGE_SIZE - size,\n\t\t\t\t\t\" %s\\n\", ctrl_caps[i].name);\n\t\t}\n\t\tsize += scnprintf(&buf[size], PAGE_SIZE - size,\n\t\t\t\t \" plane colors:\\n\");\n\t\tfor (i = 0; i < ARRAY_SIZE(color_caps) &&\n\t\t     size < PAGE_SIZE; i++) {\n\t\t\tif (color_caps[i].flag & caps.plane_color)\n\t\t\t\tsize += scnprintf(&buf[size], PAGE_SIZE - size,\n\t\t\t\t\t\"  %s\\n\", color_caps[i].name);\n\t\t}\n\t\tsize += scnprintf(&buf[size], PAGE_SIZE - size,\n\t\t\t\t \" window colors:\\n\");\n\t\tfor (i = 0; i < ARRAY_SIZE(color_caps) &&\n\t\t     size < PAGE_SIZE; i++) {\n\t\t\tif (color_caps[i].flag & caps.wnd_color)\n\t\t\t\tsize += scnprintf(&buf[size], PAGE_SIZE - size,\n\t\t\t\t\t\"  %s\\n\", color_caps[i].name);\n\t\t}\n\n\t\tplane++;\n\t}\n\treturn size;\n}\n\nstatic DEVICE_ATTR(caps_num, 0444, omapfb_show_caps_num, NULL);\nstatic DEVICE_ATTR(caps_text, 0444, omapfb_show_caps_text, NULL);\n\n \nstatic ssize_t omapfb_show_panel_name(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct omapfb_device *fbdev = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", fbdev->panel->name);\n}\n\nstatic ssize_t omapfb_show_bklight_level(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct omapfb_device *fbdev = dev_get_drvdata(dev);\n\tint r;\n\n\tif (fbdev->panel->get_bklight_level) {\n\t\tr = sysfs_emit(buf, \"%d\\n\",\n\t\t\t       fbdev->panel->get_bklight_level(fbdev->panel));\n\t} else\n\t\tr = -ENODEV;\n\treturn r;\n}\n\nstatic ssize_t omapfb_store_bklight_level(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t size)\n{\n\tstruct omapfb_device *fbdev = dev_get_drvdata(dev);\n\tint r;\n\n\tif (fbdev->panel->set_bklight_level) {\n\t\tunsigned int level;\n\n\t\tif (sscanf(buf, \"%10d\", &level) == 1) {\n\t\t\tr = fbdev->panel->set_bklight_level(fbdev->panel,\n\t\t\t\t\t\t\t    level);\n\t\t} else\n\t\t\tr = -EINVAL;\n\t} else\n\t\tr = -ENODEV;\n\treturn r ? r : size;\n}\n\nstatic ssize_t omapfb_show_bklight_max(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct omapfb_device *fbdev = dev_get_drvdata(dev);\n\tint r;\n\n\tif (fbdev->panel->get_bklight_level) {\n\t\tr = sysfs_emit(buf, \"%d\\n\",\n\t\t\t       fbdev->panel->get_bklight_max(fbdev->panel));\n\t} else\n\t\tr = -ENODEV;\n\treturn r;\n}\n\nstatic struct device_attribute dev_attr_panel_name =\n\t__ATTR(name, 0444, omapfb_show_panel_name, NULL);\nstatic DEVICE_ATTR(backlight_level, 0664,\n\t\t   omapfb_show_bklight_level, omapfb_store_bklight_level);\nstatic DEVICE_ATTR(backlight_max, 0444, omapfb_show_bklight_max, NULL);\n\nstatic struct attribute *panel_attrs[] = {\n\t&dev_attr_panel_name.attr,\n\t&dev_attr_backlight_level.attr,\n\t&dev_attr_backlight_max.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group panel_attr_grp = {\n\t.name  = \"panel\",\n\t.attrs = panel_attrs,\n};\n\n \nstatic ssize_t omapfb_show_ctrl_name(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct omapfb_device *fbdev = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", fbdev->ctrl->name);\n}\n\nstatic struct device_attribute dev_attr_ctrl_name =\n\t__ATTR(name, 0444, omapfb_show_ctrl_name, NULL);\n\nstatic struct attribute *ctrl_attrs[] = {\n\t&dev_attr_ctrl_name.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ctrl_attr_grp = {\n\t.name  = \"ctrl\",\n\t.attrs = ctrl_attrs,\n};\n\nstatic int omapfb_register_sysfs(struct omapfb_device *fbdev)\n{\n\tint r;\n\n\tif ((r = device_create_file(fbdev->dev, &dev_attr_caps_num)))\n\t\tgoto fail0;\n\n\tif ((r = device_create_file(fbdev->dev, &dev_attr_caps_text)))\n\t\tgoto fail1;\n\n\tif ((r = sysfs_create_group(&fbdev->dev->kobj, &panel_attr_grp)))\n\t\tgoto fail2;\n\n\tif ((r = sysfs_create_group(&fbdev->dev->kobj, &ctrl_attr_grp)))\n\t\tgoto fail3;\n\n\treturn 0;\nfail3:\n\tsysfs_remove_group(&fbdev->dev->kobj, &panel_attr_grp);\nfail2:\n\tdevice_remove_file(fbdev->dev, &dev_attr_caps_text);\nfail1:\n\tdevice_remove_file(fbdev->dev, &dev_attr_caps_num);\nfail0:\n\tdev_err(fbdev->dev, \"unable to register sysfs interface\\n\");\n\treturn r;\n}\n\nstatic void omapfb_unregister_sysfs(struct omapfb_device *fbdev)\n{\n\tsysfs_remove_group(&fbdev->dev->kobj, &ctrl_attr_grp);\n\tsysfs_remove_group(&fbdev->dev->kobj, &panel_attr_grp);\n\tdevice_remove_file(fbdev->dev, &dev_attr_caps_num);\n\tdevice_remove_file(fbdev->dev, &dev_attr_caps_text);\n}\n\n \n \nstatic int fbinfo_init(struct omapfb_device *fbdev, struct fb_info *info)\n{\n\tstruct fb_var_screeninfo\t*var = &info->var;\n\tstruct fb_fix_screeninfo\t*fix = &info->fix;\n\tint\t\t\t\tr = 0;\n\n\tinfo->fbops = &omapfb_ops;\n\n\tstrscpy(fix->id, MODULE_NAME, sizeof(fix->id));\n\n\tinfo->pseudo_palette = fbdev->pseudo_palette;\n\n\tvar->accel_flags  = def_accel ? FB_ACCELF_TEXT : 0;\n\tvar->xres = def_vxres;\n\tvar->yres = def_vyres;\n\tvar->xres_virtual = def_vxres;\n\tvar->yres_virtual = def_vyres;\n\tvar->rotate\t  = def_rotate;\n\tvar->bits_per_pixel = fbdev->panel->bpp;\n\n\tset_fb_var(info, var);\n\tset_fb_fix(info, 1);\n\n\tr = fb_alloc_cmap(&info->cmap, 16, 0);\n\tif (r != 0)\n\t\tdev_err(fbdev->dev, \"unable to allocate color map memory\\n\");\n\n\treturn r;\n}\n\n \nstatic void fbinfo_cleanup(struct omapfb_device *fbdev, struct fb_info *fbi)\n{\n\tfb_dealloc_cmap(&fbi->cmap);\n}\n\nstatic void planes_cleanup(struct omapfb_device *fbdev)\n{\n\tint i;\n\n\tfor (i = 0; i < fbdev->mem_desc.region_cnt; i++) {\n\t\tif (fbdev->fb_info[i] == NULL)\n\t\t\tbreak;\n\t\tfbinfo_cleanup(fbdev, fbdev->fb_info[i]);\n\t\tframebuffer_release(fbdev->fb_info[i]);\n\t}\n}\n\nstatic int planes_init(struct omapfb_device *fbdev)\n{\n\tstruct fb_info *fbi;\n\tint i;\n\tint r;\n\n\tfor (i = 0; i < fbdev->mem_desc.region_cnt; i++) {\n\t\tstruct omapfb_plane_struct *plane;\n\t\tfbi = framebuffer_alloc(sizeof(struct omapfb_plane_struct),\n\t\t\t\t\tfbdev->dev);\n\t\tif (fbi == NULL) {\n\t\t\tplanes_cleanup(fbdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tplane = fbi->par;\n\t\tplane->idx = i;\n\t\tplane->fbdev = fbdev;\n\t\tplane->info.mirror = def_mirror;\n\t\tfbdev->fb_info[i] = fbi;\n\n\t\tif ((r = fbinfo_init(fbdev, fbi)) < 0) {\n\t\t\tframebuffer_release(fbi);\n\t\t\tplanes_cleanup(fbdev);\n\t\t\treturn r;\n\t\t}\n\t\tplane->info.out_width = fbi->var.xres;\n\t\tplane->info.out_height = fbi->var.yres;\n\t}\n\treturn 0;\n}\n\n \nstatic void omapfb_free_resources(struct omapfb_device *fbdev, int state)\n{\n\tint i;\n\n\tswitch (state) {\n\tcase OMAPFB_ACTIVE:\n\t\tfor (i = 0; i < fbdev->mem_desc.region_cnt; i++)\n\t\t\tunregister_framebuffer(fbdev->fb_info[i]);\n\t\tfallthrough;\n\tcase 7:\n\t\tomapfb_unregister_sysfs(fbdev);\n\t\tfallthrough;\n\tcase 6:\n\t\tif (fbdev->panel->disable)\n\t\t\tfbdev->panel->disable(fbdev->panel);\n\t\tfallthrough;\n\tcase 5:\n\t\tomapfb_set_update_mode(fbdev, OMAPFB_UPDATE_DISABLED);\n\t\tfallthrough;\n\tcase 4:\n\t\tplanes_cleanup(fbdev);\n\t\tfallthrough;\n\tcase 3:\n\t\tctrl_cleanup(fbdev);\n\t\tfallthrough;\n\tcase 2:\n\t\tif (fbdev->panel->cleanup)\n\t\t\tfbdev->panel->cleanup(fbdev->panel);\n\t\tfallthrough;\n\tcase 1:\n\t\tdev_set_drvdata(fbdev->dev, NULL);\n\t\tkfree(fbdev);\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic int omapfb_find_ctrl(struct omapfb_device *fbdev)\n{\n\tstruct omapfb_platform_data *conf;\n\tchar name[17];\n\tint i;\n\n\tconf = dev_get_platdata(fbdev->dev);\n\n\tfbdev->ctrl = NULL;\n\n\tstrscpy(name, conf->lcd.ctrl_name, sizeof(name));\n\n\tif (strcmp(name, \"internal\") == 0) {\n\t\tfbdev->ctrl = fbdev->int_ctrl;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ctrls); i++) {\n\t\tdev_dbg(fbdev->dev, \"ctrl %s\\n\", ctrls[i]->name);\n\t\tif (strcmp(ctrls[i]->name, name) == 0) {\n\t\t\tfbdev->ctrl = ctrls[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fbdev->ctrl == NULL) {\n\t\tdev_dbg(fbdev->dev, \"ctrl %s not supported\\n\", name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int omapfb_do_probe(struct platform_device *pdev,\n\t\t\t\tstruct lcd_panel *panel)\n{\n\tstruct omapfb_device\t*fbdev = NULL;\n\tint\t\t\tinit_state;\n\tunsigned long\t\tphz, hhz, vhz;\n\tunsigned long\t\tvram;\n\tint\t\t\ti;\n\tint\t\t\tr = 0;\n\n\tinit_state = 0;\n\n\tif (pdev->num_resources != 2) {\n\t\tdev_err(&pdev->dev, \"probed for an unknown device\\n\");\n\t\tr = -ENODEV;\n\t\tgoto cleanup;\n\t}\n\n\tif (dev_get_platdata(&pdev->dev) == NULL) {\n\t\tdev_err(&pdev->dev, \"missing platform data\\n\");\n\t\tr = -ENOENT;\n\t\tgoto cleanup;\n\t}\n\n\tfbdev = kzalloc(sizeof(*fbdev), GFP_KERNEL);\n\tif (fbdev == NULL) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"unable to allocate memory for device info\\n\");\n\t\tr = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tfbdev->int_irq = platform_get_irq(pdev, 0);\n\tif (fbdev->int_irq < 0) {\n\t\tr = -ENXIO;\n\t\tgoto cleanup;\n\t}\n\n\tfbdev->ext_irq = platform_get_irq(pdev, 1);\n\tif (fbdev->ext_irq < 0) {\n\t\tr = -ENXIO;\n\t\tgoto cleanup;\n\t}\n\n\tinit_state++;\n\n\tfbdev->dev = &pdev->dev;\n\tfbdev->panel = panel;\n\tfbdev->dssdev = &omapdss_device;\n\tplatform_set_drvdata(pdev, fbdev);\n\n\tmutex_init(&fbdev->rqueue_mutex);\n\n\tfbdev->int_ctrl = &omap1_int_ctrl;\n#ifdef CONFIG_FB_OMAP_LCDC_EXTERNAL\n\tfbdev->ext_if = &omap1_ext_if;\n#endif\n\tif (omapfb_find_ctrl(fbdev) < 0) {\n\t\tdev_err(fbdev->dev,\n\t\t\t\"LCD controller not found, board not supported\\n\");\n\t\tr = -ENODEV;\n\t\tgoto cleanup;\n\t}\n\n\tif (fbdev->panel->init) {\n\t\tr = fbdev->panel->init(fbdev->panel, fbdev);\n\t\tif (r)\n\t\t\tgoto cleanup;\n\t}\n\n\tpr_info(\"omapfb: configured for panel %s\\n\", fbdev->panel->name);\n\n\tdef_vxres = def_vxres ? def_vxres : fbdev->panel->x_res;\n\tdef_vyres = def_vyres ? def_vyres : fbdev->panel->y_res;\n\n\tinit_state++;\n\n\tr = ctrl_init(fbdev);\n\tif (r)\n\t\tgoto cleanup;\n\tif (fbdev->ctrl->mmap != NULL)\n\t\tomapfb_ops.fb_mmap = omapfb_mmap;\n\tinit_state++;\n\n\tr = planes_init(fbdev);\n\tif (r)\n\t\tgoto cleanup;\n\tinit_state++;\n\n#ifdef CONFIG_FB_OMAP_DMA_TUNE\n\t \n\tomap_set_dma_priority(0, OMAP_DMA_PORT_EMIFF, 15);\n#endif\n\n\tr = ctrl_change_mode(fbdev->fb_info[0]);\n\tif (r) {\n\t\tdev_err(fbdev->dev, \"mode setting failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\tr = fbdev->ctrl->enable_plane(OMAPFB_PLANE_GFX, 1);\n\tif (r)\n\t\tgoto cleanup;\n\n\tomapfb_set_update_mode(fbdev, manual_update ?\n\t\t\t\t   OMAPFB_MANUAL_UPDATE : OMAPFB_AUTO_UPDATE);\n\tinit_state++;\n\n\tif (fbdev->panel->enable) {\n\t\tr = fbdev->panel->enable(fbdev->panel);\n\t\tif (r)\n\t\t\tgoto cleanup;\n\t}\n\tinit_state++;\n\n\tr = omapfb_register_sysfs(fbdev);\n\tif (r)\n\t\tgoto cleanup;\n\tinit_state++;\n\n\tvram = 0;\n\tfor (i = 0; i < fbdev->mem_desc.region_cnt; i++) {\n\t\tr = register_framebuffer(fbdev->fb_info[i]);\n\t\tif (r != 0) {\n\t\t\tdev_err(fbdev->dev,\n\t\t\t\t\"registering framebuffer %d failed\\n\", i);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tvram += fbdev->mem_desc.region[i].size;\n\t}\n\n\tfbdev->state = OMAPFB_ACTIVE;\n\n\tpanel = fbdev->panel;\n\tphz = panel->pixel_clock * 1000;\n\thhz = phz * 10 / (panel->hfp + panel->x_res + panel->hbp + panel->hsw);\n\tvhz = hhz / (panel->vfp + panel->y_res + panel->vbp + panel->vsw);\n\n\tomapfb_dev = fbdev;\n\n\tpr_info(\"omapfb: Framebuffer initialized. Total vram %lu planes %d\\n\",\n\t\t\tvram, fbdev->mem_desc.region_cnt);\n\tpr_info(\"omapfb: Pixclock %lu kHz hfreq %lu.%lu kHz \"\n\t\t\t\"vfreq %lu.%lu Hz\\n\",\n\t\t\tphz / 1000, hhz / 10000, hhz % 10, vhz / 10, vhz % 10);\n\n\treturn 0;\n\ncleanup:\n\tomapfb_free_resources(fbdev, init_state);\n\n\treturn r;\n}\n\nstatic int omapfb_probe(struct platform_device *pdev)\n{\n\tint r;\n\n\tBUG_ON(fbdev_pdev != NULL);\n\n\tr = platform_device_register(&omapdss_device);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"can't register omapdss device\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tfbdev_pdev = pdev;\n\tif (fbdev_panel != NULL)\n\t\tomapfb_do_probe(fbdev_pdev, fbdev_panel);\n\treturn 0;\n}\n\nvoid omapfb_register_panel(struct lcd_panel *panel)\n{\n\tBUG_ON(fbdev_panel != NULL);\n\n\tfbdev_panel = panel;\n\tif (fbdev_pdev != NULL)\n\t\tomapfb_do_probe(fbdev_pdev, fbdev_panel);\n}\nEXPORT_SYMBOL_GPL(omapfb_register_panel);\n\n \nstatic void omapfb_remove(struct platform_device *pdev)\n{\n\tstruct omapfb_device *fbdev = platform_get_drvdata(pdev);\n\tenum omapfb_state saved_state = fbdev->state;\n\n\t \n\n\tfbdev->state = OMAPFB_DISABLED;\n\tomapfb_free_resources(fbdev, saved_state);\n\n\tplatform_device_unregister(&omapdss_device);\n\tfbdev->dssdev = NULL;\n}\n\n \nstatic int omapfb_suspend(struct platform_device *pdev, pm_message_t mesg)\n{\n\tstruct omapfb_device *fbdev = platform_get_drvdata(pdev);\n\n\tif (fbdev != NULL)\n\t\tomapfb_blank(FB_BLANK_POWERDOWN, fbdev->fb_info[0]);\n\treturn 0;\n}\n\n \nstatic int omapfb_resume(struct platform_device *pdev)\n{\n\tstruct omapfb_device *fbdev = platform_get_drvdata(pdev);\n\n\tif (fbdev != NULL)\n\t\tomapfb_blank(FB_BLANK_UNBLANK, fbdev->fb_info[0]);\n\treturn 0;\n}\n\nstatic struct platform_driver omapfb_driver = {\n\t.probe\t\t= omapfb_probe,\n\t.remove_new\t= omapfb_remove,\n\t.suspend\t= omapfb_suspend,\n\t.resume\t\t= omapfb_resume,\n\t.driver\t\t= {\n\t\t.name\t= MODULE_NAME,\n\t},\n};\n\n#ifndef MODULE\n\n \nstatic int __init omapfb_setup(char *options)\n{\n\tchar *this_opt = NULL;\n\tint r = 0;\n\n\tpr_debug(\"omapfb: options %s\\n\", options);\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile (!r && (this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!strncmp(this_opt, \"accel\", 5))\n\t\t\tdef_accel = 1;\n\t\telse if (!strncmp(this_opt, \"vram:\", 5)) {\n\t\t\tchar *suffix;\n\t\t\tunsigned long vram;\n\t\t\tvram = (simple_strtoul(this_opt + 5, &suffix, 0));\n\t\t\tswitch (suffix[0]) {\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\tcase 'M':\n\t\t\t\tvram *= 1024;\n\t\t\t\tfallthrough;\n\t\t\tcase 'k':\n\t\t\tcase 'K':\n\t\t\t\tvram *= 1024;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_debug(\"omapfb: invalid vram suffix %c\\n\",\n\t\t\t\t\t suffix[0]);\n\t\t\t\tr = -1;\n\t\t\t}\n\t\t\tdef_vram[def_vram_cnt++] = vram;\n\t\t}\n\t\telse if (!strncmp(this_opt, \"vxres:\", 6))\n\t\t\tdef_vxres = simple_strtoul(this_opt + 6, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"vyres:\", 6))\n\t\t\tdef_vyres = simple_strtoul(this_opt + 6, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"rotate:\", 7))\n\t\t\tdef_rotate = (simple_strtoul(this_opt + 7, NULL, 0));\n\t\telse if (!strncmp(this_opt, \"mirror:\", 7))\n\t\t\tdef_mirror = (simple_strtoul(this_opt + 7, NULL, 0));\n\t\telse if (!strncmp(this_opt, \"manual_update\", 13))\n\t\t\tmanual_update = 1;\n\t\telse {\n\t\t\tpr_debug(\"omapfb: invalid option\\n\");\n\t\t\tr = -1;\n\t\t}\n\t}\n\n\treturn r;\n}\n\n#endif\n\n \nstatic int __init omapfb_init(void)\n{\n#ifndef MODULE\n\tchar *option;\n\n\tif (fb_get_options(\"omapfb\", &option))\n\t\treturn -ENODEV;\n\tomapfb_setup(option);\n#endif\n\t \n\tif (platform_driver_register(&omapfb_driver)) {\n\t\tpr_debug(\"failed to register omapfb driver\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit omapfb_cleanup(void)\n{\n\tplatform_driver_unregister(&omapfb_driver);\n}\n\nmodule_param_named(accel, def_accel, uint, 0664);\nmodule_param_array_named(vram, def_vram, ulong, &def_vram_cnt, 0664);\nmodule_param_named(vxres, def_vxres, long, 0664);\nmodule_param_named(vyres, def_vyres, long, 0664);\nmodule_param_named(rotate, def_rotate, uint, 0664);\nmodule_param_named(mirror, def_mirror, uint, 0664);\nmodule_param_named(manual_update, manual_update, bool, 0664);\n\nmodule_init(omapfb_init);\nmodule_exit(omapfb_cleanup);\n\nMODULE_DESCRIPTION(\"TI OMAP framebuffer driver\");\nMODULE_AUTHOR(\"Imre Deak <imre.deak@nokia.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}