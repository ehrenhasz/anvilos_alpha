{
  "module_name": "lcd_mipid.c",
  "hash_id": "726968851074836fd5e1e5a5ec99e2acb05c934ef924a2d152bd40724225aabe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap/lcd_mipid.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n\n#include <linux/platform_data/lcd-mipid.h>\n\n#include \"omapfb.h\"\n\n#define MIPID_MODULE_NAME\t\t\"lcd_mipid\"\n\n#define MIPID_CMD_READ_DISP_ID\t\t0x04\n#define MIPID_CMD_READ_RED\t\t0x06\n#define MIPID_CMD_READ_GREEN\t\t0x07\n#define MIPID_CMD_READ_BLUE\t\t0x08\n#define MIPID_CMD_READ_DISP_STATUS\t0x09\n#define MIPID_CMD_RDDSDR\t\t0x0F\n#define MIPID_CMD_SLEEP_IN\t\t0x10\n#define MIPID_CMD_SLEEP_OUT\t\t0x11\n#define MIPID_CMD_DISP_OFF\t\t0x28\n#define MIPID_CMD_DISP_ON\t\t0x29\n\n#define MIPID_ESD_CHECK_PERIOD\t\tmsecs_to_jiffies(5000)\n\n#define to_mipid_device(p)\t\tcontainer_of(p, struct mipid_device, \\\n\t\t\t\t\t\tpanel)\nstruct mipid_device {\n\tint\t\tenabled;\n\tint\t\trevision;\n\tunsigned int\tsaved_bklight_level;\n\tunsigned long\thw_guard_end;\t\t \n\tunsigned long\thw_guard_wait;\t\t \n\tstruct gpio_desc\t*reset;\n\n\tstruct omapfb_device\t*fbdev;\n\tstruct spi_device\t*spi;\n\tstruct mutex\t\tmutex;\n\tstruct lcd_panel\tpanel;\n\n\tstruct delayed_work\tesd_work;\n\tvoid\t\t\t(*esd_check)(struct mipid_device *m);\n};\n\nstatic void mipid_transfer(struct mipid_device *md, int cmd, const u8 *wbuf,\n\t\t\t   int wlen, u8 *rbuf, int rlen)\n{\n\tstruct spi_message\tm;\n\tstruct spi_transfer\t*x, xfer[4];\n\tu16\t\t\tw;\n\tint\t\t\tr;\n\n\tBUG_ON(md->spi == NULL);\n\n\tspi_message_init(&m);\n\n\tmemset(xfer, 0, sizeof(xfer));\n\tx = &xfer[0];\n\n\tcmd &=  0xff;\n\tx->tx_buf\t\t= &cmd;\n\tx->bits_per_word\t= 9;\n\tx->len\t\t\t= 2;\n\tspi_message_add_tail(x, &m);\n\n\tif (wlen) {\n\t\tx++;\n\t\tx->tx_buf\t\t= wbuf;\n\t\tx->len\t\t\t= wlen;\n\t\tx->bits_per_word\t= 9;\n\t\tspi_message_add_tail(x, &m);\n\t}\n\n\tif (rlen) {\n\t\tx++;\n\t\tx->rx_buf\t= &w;\n\t\tx->len\t\t= 1;\n\t\tspi_message_add_tail(x, &m);\n\n\t\tif (rlen > 1) {\n\t\t\t \n\t\t\tx->bits_per_word = 9;\n\t\t\tx->len\t\t = 2;\n\n\t\t\tx++;\n\t\t\tx->rx_buf\t = &rbuf[1];\n\t\t\tx->len\t\t = rlen - 1;\n\t\t\tspi_message_add_tail(x, &m);\n\t\t}\n\t}\n\n\tr = spi_sync(md->spi, &m);\n\tif (r < 0)\n\t\tdev_dbg(&md->spi->dev, \"spi_sync %d\\n\", r);\n\n\tif (rlen)\n\t\trbuf[0] = w & 0xff;\n}\n\nstatic inline void mipid_cmd(struct mipid_device *md, int cmd)\n{\n\tmipid_transfer(md, cmd, NULL, 0, NULL, 0);\n}\n\nstatic inline void mipid_write(struct mipid_device *md,\n\t\t\t       int reg, const u8 *buf, int len)\n{\n\tmipid_transfer(md, reg, buf, len, NULL, 0);\n}\n\nstatic inline void mipid_read(struct mipid_device *md,\n\t\t\t      int reg, u8 *buf, int len)\n{\n\tmipid_transfer(md, reg, NULL, 0, buf, len);\n}\n\nstatic void set_data_lines(struct mipid_device *md, int data_lines)\n{\n\tu16 par;\n\n\tswitch (data_lines) {\n\tcase 16:\n\t\tpar = 0x150;\n\t\tbreak;\n\tcase 18:\n\t\tpar = 0x160;\n\t\tbreak;\n\tcase 24:\n\t\tpar = 0x170;\n\t\tbreak;\n\t}\n\tmipid_write(md, 0x3a, (u8 *)&par, 2);\n}\n\nstatic void send_init_string(struct mipid_device *md)\n{\n\tu16 initpar[] = { 0x0102, 0x0100, 0x0100 };\n\n\tmipid_write(md, 0xc2, (u8 *)initpar, sizeof(initpar));\n\tset_data_lines(md, md->panel.data_lines);\n}\n\nstatic void hw_guard_start(struct mipid_device *md, int guard_msec)\n{\n\tmd->hw_guard_wait = msecs_to_jiffies(guard_msec);\n\tmd->hw_guard_end = jiffies + md->hw_guard_wait;\n}\n\nstatic void hw_guard_wait(struct mipid_device *md)\n{\n\tunsigned long wait = md->hw_guard_end - jiffies;\n\n\tif ((long)wait > 0 && time_before_eq(wait,  md->hw_guard_wait)) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(wait);\n\t}\n}\n\nstatic void set_sleep_mode(struct mipid_device *md, int on)\n{\n\tint cmd, sleep_time = 50;\n\n\tif (on)\n\t\tcmd = MIPID_CMD_SLEEP_IN;\n\telse\n\t\tcmd = MIPID_CMD_SLEEP_OUT;\n\thw_guard_wait(md);\n\tmipid_cmd(md, cmd);\n\thw_guard_start(md, 120);\n\t \n\tif (!on)\n\t\tsleep_time = 120;\n\tmsleep(sleep_time);\n}\n\nstatic void set_display_state(struct mipid_device *md, int enabled)\n{\n\tint cmd = enabled ? MIPID_CMD_DISP_ON : MIPID_CMD_DISP_OFF;\n\n\tmipid_cmd(md, cmd);\n}\n\nstatic int mipid_set_bklight_level(struct lcd_panel *panel, unsigned int level)\n{\n\tstruct mipid_device *md = to_mipid_device(panel);\n\tstruct mipid_platform_data *pd = md->spi->dev.platform_data;\n\n\tif (pd->get_bklight_max == NULL || pd->set_bklight_level == NULL)\n\t\treturn -ENODEV;\n\tif (level > pd->get_bklight_max(pd))\n\t\treturn -EINVAL;\n\tif (!md->enabled) {\n\t\tmd->saved_bklight_level = level;\n\t\treturn 0;\n\t}\n\tpd->set_bklight_level(pd, level);\n\n\treturn 0;\n}\n\nstatic unsigned int mipid_get_bklight_level(struct lcd_panel *panel)\n{\n\tstruct mipid_device *md = to_mipid_device(panel);\n\tstruct mipid_platform_data *pd = md->spi->dev.platform_data;\n\n\tif (pd->get_bklight_level == NULL)\n\t\treturn -ENODEV;\n\treturn pd->get_bklight_level(pd);\n}\n\nstatic unsigned int mipid_get_bklight_max(struct lcd_panel *panel)\n{\n\tstruct mipid_device *md = to_mipid_device(panel);\n\tstruct mipid_platform_data *pd = md->spi->dev.platform_data;\n\n\tif (pd->get_bklight_max == NULL)\n\t\treturn -ENODEV;\n\n\treturn pd->get_bklight_max(pd);\n}\n\nstatic unsigned long mipid_get_caps(struct lcd_panel *panel)\n{\n\treturn OMAPFB_CAPS_SET_BACKLIGHT;\n}\n\nstatic u16 read_first_pixel(struct mipid_device *md)\n{\n\tu16 pixel;\n\tu8 red, green, blue;\n\n\tmutex_lock(&md->mutex);\n\tmipid_read(md, MIPID_CMD_READ_RED, &red, 1);\n\tmipid_read(md, MIPID_CMD_READ_GREEN, &green, 1);\n\tmipid_read(md, MIPID_CMD_READ_BLUE, &blue, 1);\n\tmutex_unlock(&md->mutex);\n\n\tswitch (md->panel.data_lines) {\n\tcase 16:\n\t\tpixel = ((red >> 1) << 11) | (green << 5) | (blue >> 1);\n\t\tbreak;\n\tcase 24:\n\t\t \n\t\tpixel = ((red >> 3) << 11) | ((green >> 2) << 5) |\n\t\t\t(blue >> 3);\n\t\tbreak;\n\tdefault:\n\t\tpixel = 0;\n\t\tBUG();\n\t}\n\n\treturn pixel;\n}\n\nstatic int mipid_run_test(struct lcd_panel *panel, int test_num)\n{\n\tstruct mipid_device *md = to_mipid_device(panel);\n\tstatic const u16 test_values[4] = {\n\t\t0x0000, 0xffff, 0xaaaa, 0x5555,\n\t};\n\tint i;\n\n\tif (test_num != MIPID_TEST_RGB_LINES)\n\t\treturn MIPID_TEST_INVALID;\n\n\tfor (i = 0; i < ARRAY_SIZE(test_values); i++) {\n\t\tint delay;\n\t\tunsigned long tmo;\n\n\t\tomapfb_write_first_pixel(md->fbdev, test_values[i]);\n\t\ttmo = jiffies + msecs_to_jiffies(100);\n\t\tdelay = 25;\n\t\twhile (1) {\n\t\t\tu16 pixel;\n\n\t\t\tmsleep(delay);\n\t\t\tpixel = read_first_pixel(md);\n\t\t\tif (pixel == test_values[i])\n\t\t\t\tbreak;\n\t\t\tif (time_after(jiffies, tmo)) {\n\t\t\t\tdev_err(&md->spi->dev,\n\t\t\t\t\t\"MIPI LCD RGB I/F test failed: \"\n\t\t\t\t\t\"expecting %04x, got %04x\\n\",\n\t\t\t\t\ttest_values[i], pixel);\n\t\t\t\treturn MIPID_TEST_FAILED;\n\t\t\t}\n\t\t\tdelay = 10;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ls041y3_esd_recover(struct mipid_device *md)\n{\n\tdev_err(&md->spi->dev, \"performing LCD ESD recovery\\n\");\n\tset_sleep_mode(md, 1);\n\tset_sleep_mode(md, 0);\n}\n\nstatic void ls041y3_esd_check_mode1(struct mipid_device *md)\n{\n\tu8 state1, state2;\n\n\tmipid_read(md, MIPID_CMD_RDDSDR, &state1, 1);\n\tset_sleep_mode(md, 0);\n\tmipid_read(md, MIPID_CMD_RDDSDR, &state2, 1);\n\tdev_dbg(&md->spi->dev, \"ESD mode 1 state1 %02x state2 %02x\\n\",\n\t\tstate1, state2);\n\t \n\tif (!((state1 ^ state2) & (1 << 6)))\n\t\tls041y3_esd_recover(md);\n}\n\nstatic void ls041y3_esd_check_mode2(struct mipid_device *md)\n{\n\tint i;\n\tu8 rbuf[2];\n\tstatic const struct {\n\t\tint\tcmd;\n\t\tint\twlen;\n\t\tu16\twbuf[3];\n\t} *rd, rd_ctrl[7] = {\n\t\t{ 0xb0, 4, { 0x0101, 0x01fe, } },\n\t\t{ 0xb1, 4, { 0x01de, 0x0121, } },\n\t\t{ 0xc2, 4, { 0x0100, 0x0100, } },\n\t\t{ 0xbd, 2, { 0x0100, } },\n\t\t{ 0xc2, 4, { 0x01fc, 0x0103, } },\n\t\t{ 0xb4, 0, },\n\t\t{ 0x00, 0, },\n\t};\n\n\trd = rd_ctrl;\n\tfor (i = 0; i < 3; i++, rd++)\n\t\tmipid_write(md, rd->cmd, (u8 *)rd->wbuf, rd->wlen);\n\n\tudelay(10);\n\tmipid_read(md, rd->cmd, rbuf, 2);\n\trd++;\n\n\tfor (i = 0; i < 3; i++, rd++) {\n\t\tudelay(10);\n\t\tmipid_write(md, rd->cmd, (u8 *)rd->wbuf, rd->wlen);\n\t}\n\n\tdev_dbg(&md->spi->dev, \"ESD mode 2 state %02x\\n\", rbuf[1]);\n\tif (rbuf[1] == 0x00)\n\t\tls041y3_esd_recover(md);\n}\n\nstatic void ls041y3_esd_check(struct mipid_device *md)\n{\n\tls041y3_esd_check_mode1(md);\n\tif (md->revision >= 0x88)\n\t\tls041y3_esd_check_mode2(md);\n}\n\nstatic void mipid_esd_start_check(struct mipid_device *md)\n{\n\tif (md->esd_check != NULL)\n\t\tschedule_delayed_work(&md->esd_work,\n\t\t\t\t   MIPID_ESD_CHECK_PERIOD);\n}\n\nstatic void mipid_esd_stop_check(struct mipid_device *md)\n{\n\tif (md->esd_check != NULL)\n\t\tcancel_delayed_work_sync(&md->esd_work);\n}\n\nstatic void mipid_esd_work(struct work_struct *work)\n{\n\tstruct mipid_device *md = container_of(work, struct mipid_device,\n\t\t\t\t\t       esd_work.work);\n\n\tmutex_lock(&md->mutex);\n\tmd->esd_check(md);\n\tmutex_unlock(&md->mutex);\n\tmipid_esd_start_check(md);\n}\n\nstatic int mipid_enable(struct lcd_panel *panel)\n{\n\tstruct mipid_device *md = to_mipid_device(panel);\n\n\tmutex_lock(&md->mutex);\n\n\tif (md->enabled) {\n\t\tmutex_unlock(&md->mutex);\n\t\treturn 0;\n\t}\n\tset_sleep_mode(md, 0);\n\tmd->enabled = 1;\n\tsend_init_string(md);\n\tset_display_state(md, 1);\n\tmipid_set_bklight_level(panel, md->saved_bklight_level);\n\tmipid_esd_start_check(md);\n\n\tmutex_unlock(&md->mutex);\n\treturn 0;\n}\n\nstatic void mipid_disable(struct lcd_panel *panel)\n{\n\tstruct mipid_device *md = to_mipid_device(panel);\n\n\t \n\tmipid_esd_stop_check(md);\n\tmutex_lock(&md->mutex);\n\n\tif (!md->enabled) {\n\t\tmutex_unlock(&md->mutex);\n\t\treturn;\n\t}\n\tmd->saved_bklight_level = mipid_get_bklight_level(panel);\n\tmipid_set_bklight_level(panel, 0);\n\tset_display_state(md, 0);\n\tset_sleep_mode(md, 1);\n\tmd->enabled = 0;\n\n\tmutex_unlock(&md->mutex);\n}\n\nstatic int panel_enabled(struct mipid_device *md)\n{\n\tu32 disp_status;\n\tint enabled;\n\n\tmipid_read(md, MIPID_CMD_READ_DISP_STATUS, (u8 *)&disp_status, 4);\n\tdisp_status = __be32_to_cpu(disp_status);\n\tenabled = (disp_status & (1 << 17)) && (disp_status & (1 << 10));\n\tdev_dbg(&md->spi->dev,\n\t\t\"LCD panel %senabled by bootloader (status 0x%04x)\\n\",\n\t\tenabled ? \"\" : \"not \", disp_status);\n\treturn enabled;\n}\n\nstatic int mipid_init(struct lcd_panel *panel,\n\t\t\t    struct omapfb_device *fbdev)\n{\n\tstruct mipid_device *md = to_mipid_device(panel);\n\n\tmd->fbdev = fbdev;\n\tINIT_DELAYED_WORK(&md->esd_work, mipid_esd_work);\n\tmutex_init(&md->mutex);\n\n\tmd->enabled = panel_enabled(md);\n\n\tif (md->enabled)\n\t\tmipid_esd_start_check(md);\n\telse\n\t\tmd->saved_bklight_level = mipid_get_bklight_level(panel);\n\n\treturn 0;\n}\n\nstatic void mipid_cleanup(struct lcd_panel *panel)\n{\n\tstruct mipid_device *md = to_mipid_device(panel);\n\n\tif (md->enabled)\n\t\tmipid_esd_stop_check(md);\n}\n\nstatic const struct lcd_panel mipid_panel = {\n\t.config\t\t= OMAP_LCDC_PANEL_TFT,\n\n\t.bpp\t\t= 16,\n\t.x_res\t\t= 800,\n\t.y_res\t\t= 480,\n\t.pixel_clock\t= 21940,\n\t.hsw\t\t= 50,\n\t.hfp\t\t= 20,\n\t.hbp\t\t= 15,\n\t.vsw\t\t= 2,\n\t.vfp\t\t= 1,\n\t.vbp\t\t= 3,\n\n\t.init\t\t\t= mipid_init,\n\t.cleanup\t\t= mipid_cleanup,\n\t.enable\t\t\t= mipid_enable,\n\t.disable\t\t= mipid_disable,\n\t.get_caps\t\t= mipid_get_caps,\n\t.set_bklight_level\t= mipid_set_bklight_level,\n\t.get_bklight_level\t= mipid_get_bklight_level,\n\t.get_bklight_max\t= mipid_get_bklight_max,\n\t.run_test\t\t= mipid_run_test,\n};\n\nstatic int mipid_detect(struct mipid_device *md)\n{\n\tstruct mipid_platform_data *pdata;\n\tu8 display_id[3];\n\n\tpdata = md->spi->dev.platform_data;\n\tif (pdata == NULL) {\n\t\tdev_err(&md->spi->dev, \"missing platform data\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tmipid_read(md, MIPID_CMD_READ_DISP_ID, display_id, 3);\n\tdev_dbg(&md->spi->dev, \"MIPI display ID: %02x%02x%02x\\n\",\n\t\tdisplay_id[0], display_id[1], display_id[2]);\n\n\tswitch (display_id[0]) {\n\tcase 0x45:\n\t\tmd->panel.name = \"lph8923\";\n\t\tbreak;\n\tcase 0x83:\n\t\tmd->panel.name = \"ls041y3\";\n\t\tmd->esd_check = ls041y3_esd_check;\n\t\tbreak;\n\tdefault:\n\t\tmd->panel.name = \"unknown\";\n\t\tdev_err(&md->spi->dev, \"invalid display ID\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmd->revision = display_id[1];\n\tmd->panel.data_lines = pdata->data_lines;\n\tpr_info(\"omapfb: %s rev %02x LCD detected, %d data lines\\n\",\n\t\t\tmd->panel.name, md->revision, md->panel.data_lines);\n\n\treturn 0;\n}\n\nstatic int mipid_spi_probe(struct spi_device *spi)\n{\n\tstruct mipid_device *md;\n\tint r;\n\n\tmd = kzalloc(sizeof(*md), GFP_KERNEL);\n\tif (md == NULL) {\n\t\tdev_err(&spi->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmd->reset = gpiod_get(&spi->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(md->reset))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(md->reset),\n\t\t\t\t     \"no reset GPIO line\\n\");\n\n\tspi->mode = SPI_MODE_0;\n\tmd->spi = spi;\n\tdev_set_drvdata(&spi->dev, md);\n\tmd->panel = mipid_panel;\n\n\tr = mipid_detect(md);\n\tif (r < 0)\n\t\tgoto free_md;\n\n\tomapfb_register_panel(&md->panel);\n\n\treturn 0;\n\nfree_md:\n\tkfree(md);\n\treturn r;\n}\n\nstatic void mipid_spi_remove(struct spi_device *spi)\n{\n\tstruct mipid_device *md = dev_get_drvdata(&spi->dev);\n\n\t \n\tgpiod_set_value(md->reset, 1);\n\tmipid_disable(&md->panel);\n\tkfree(md);\n}\n\nstatic struct spi_driver mipid_spi_driver = {\n\t.driver = {\n\t\t.name\t= MIPID_MODULE_NAME,\n\t},\n\t.probe\t= mipid_spi_probe,\n\t.remove\t= mipid_spi_remove,\n};\n\nmodule_spi_driver(mipid_spi_driver);\n\nMODULE_DESCRIPTION(\"MIPI display driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}