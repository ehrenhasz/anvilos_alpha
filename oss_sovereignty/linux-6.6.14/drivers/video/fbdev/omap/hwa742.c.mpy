{
  "module_name": "hwa742.c",
  "hash_id": "30f46859d38a703528ff2acb3bd1bfaaf6e36ca93866884aa76914deab151ca3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap/hwa742.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n\n#include \"omapfb.h\"\n\n#define HWA742_REV_CODE_REG       0x0\n#define HWA742_CONFIG_REG         0x2\n#define HWA742_PLL_DIV_REG        0x4\n#define HWA742_PLL_0_REG          0x6\n#define HWA742_PLL_1_REG          0x8\n#define HWA742_PLL_2_REG          0xa\n#define HWA742_PLL_3_REG          0xc\n#define HWA742_PLL_4_REG          0xe\n#define HWA742_CLK_SRC_REG        0x12\n#define HWA742_PANEL_TYPE_REG     0x14\n#define HWA742_H_DISP_REG         0x16\n#define HWA742_H_NDP_REG          0x18\n#define HWA742_V_DISP_1_REG       0x1a\n#define HWA742_V_DISP_2_REG       0x1c\n#define HWA742_V_NDP_REG          0x1e\n#define HWA742_HS_W_REG           0x20\n#define HWA742_HP_S_REG           0x22\n#define HWA742_VS_W_REG           0x24\n#define HWA742_VP_S_REG           0x26\n#define HWA742_PCLK_POL_REG       0x28\n#define HWA742_INPUT_MODE_REG     0x2a\n#define HWA742_TRANSL_MODE_REG1   0x2e\n#define HWA742_DISP_MODE_REG      0x34\n#define HWA742_WINDOW_TYPE        0x36\n#define HWA742_WINDOW_X_START_0   0x38\n#define HWA742_WINDOW_X_START_1   0x3a\n#define HWA742_WINDOW_Y_START_0   0x3c\n#define HWA742_WINDOW_Y_START_1   0x3e\n#define HWA742_WINDOW_X_END_0     0x40\n#define HWA742_WINDOW_X_END_1     0x42\n#define HWA742_WINDOW_Y_END_0     0x44\n#define HWA742_WINDOW_Y_END_1     0x46\n#define HWA742_MEMORY_WRITE_LSB   0x48\n#define HWA742_MEMORY_WRITE_MSB   0x49\n#define HWA742_MEMORY_READ_0      0x4a\n#define HWA742_MEMORY_READ_1      0x4c\n#define HWA742_MEMORY_READ_2      0x4e\n#define HWA742_POWER_SAVE         0x56\n#define HWA742_NDP_CTRL           0x58\n\n#define HWA742_AUTO_UPDATE_TIME\t\t(HZ / 20)\n\n \n#define REQ_POOL_SIZE\t\t\t24\n#define IRQ_REQ_POOL_SIZE\t\t4\n\n#define REQ_FROM_IRQ_POOL 0x01\n\n#define REQ_COMPLETE\t0\n#define REQ_PENDING\t1\n\nstruct update_param {\n\tint\tx, y, width, height;\n\tint\tcolor_mode;\n\tint\tflags;\n};\n\nstruct hwa742_request {\n\tstruct list_head entry;\n\tunsigned int\t flags;\n\n\tint\t\t (*handler)(struct hwa742_request *req);\n\tvoid\t\t (*complete)(void *data);\n\tvoid\t\t *complete_data;\n\n\tunion {\n\t\tstruct update_param\tupdate;\n\t\tstruct completion\t*sync;\n\t} par;\n};\n\nstruct {\n\tenum omapfb_update_mode\tupdate_mode;\n\tenum omapfb_update_mode\tupdate_mode_before_suspend;\n\n\tstruct timer_list\tauto_update_timer;\n\tint\t\t\tstop_auto_update;\n\tstruct omapfb_update_window\tauto_update_window;\n\tunsigned\t\tte_connected:1;\n\tunsigned\t\tvsync_only:1;\n\n\tstruct hwa742_request\treq_pool[REQ_POOL_SIZE];\n\tstruct list_head\tpending_req_list;\n\tstruct list_head\tfree_req_list;\n\n\t \n\tstruct semaphore\treq_sema;\n\tspinlock_t\t\treq_lock;\n\n\tstruct extif_timings\treg_timings, lut_timings;\n\n\tint\t\t\tprev_color_mode;\n\tint\t\t\tprev_flags;\n\tint\t\t\twindow_type;\n\n\tu32\t\t\tmax_transmit_size;\n\tu32\t\t\textif_clk_period;\n\tunsigned long\t\tpix_tx_time;\n\tunsigned long\t\tline_upd_time;\n\n\n\tstruct omapfb_device\t*fbdev;\n\tstruct lcd_ctrl_extif\t*extif;\n\tconst struct lcd_ctrl\t*int_ctrl;\n\n\tstruct clk\t\t*sys_ck;\n} hwa742;\n\nstruct lcd_ctrl hwa742_ctrl;\n\nstatic u8 hwa742_read_reg(u8 reg)\n{\n\tu8 data;\n\n\thwa742.extif->set_bits_per_cycle(8);\n\thwa742.extif->write_command(&reg, 1);\n\thwa742.extif->read_data(&data, 1);\n\n\treturn data;\n}\n\nstatic void hwa742_write_reg(u8 reg, u8 data)\n{\n\thwa742.extif->set_bits_per_cycle(8);\n\thwa742.extif->write_command(&reg, 1);\n\thwa742.extif->write_data(&data, 1);\n}\n\nstatic void set_window_regs(int x_start, int y_start, int x_end, int y_end)\n{\n\tu8 tmp[8];\n\tu8 cmd;\n\n\tx_end--;\n\ty_end--;\n\ttmp[0] = x_start;\n\ttmp[1] = x_start >> 8;\n\ttmp[2] = y_start;\n\ttmp[3] = y_start >> 8;\n\ttmp[4] = x_end;\n\ttmp[5] = x_end >> 8;\n\ttmp[6] = y_end;\n\ttmp[7] = y_end >> 8;\n\n\thwa742.extif->set_bits_per_cycle(8);\n\tcmd = HWA742_WINDOW_X_START_0;\n\n\thwa742.extif->write_command(&cmd, 1);\n\n\thwa742.extif->write_data(tmp, 8);\n}\n\nstatic void set_format_regs(int conv, int transl, int flags)\n{\n\tif (flags & OMAPFB_FORMAT_FLAG_DOUBLE) {\n\t\thwa742.window_type = ((hwa742.window_type & 0xfc) | 0x01);\n#ifdef VERBOSE\n\t\tdev_dbg(hwa742.fbdev->dev, \"hwa742: enabled pixel doubling\\n\");\n#endif\n\t} else {\n\t\thwa742.window_type = (hwa742.window_type & 0xfc);\n#ifdef VERBOSE\n\t\tdev_dbg(hwa742.fbdev->dev, \"hwa742: disabled pixel doubling\\n\");\n#endif\n\t}\n\n\thwa742_write_reg(HWA742_INPUT_MODE_REG, conv);\n\thwa742_write_reg(HWA742_TRANSL_MODE_REG1, transl);\n\thwa742_write_reg(HWA742_WINDOW_TYPE, hwa742.window_type);\n}\n\nstatic void enable_tearsync(int y, int width, int height, int screen_height,\n\t\t\t    int force_vsync)\n{\n\tu8 b;\n\n\tb = hwa742_read_reg(HWA742_NDP_CTRL);\n\tb |= 1 << 2;\n\thwa742_write_reg(HWA742_NDP_CTRL, b);\n\n\tif (likely(hwa742.vsync_only || force_vsync)) {\n\t\thwa742.extif->enable_tearsync(1, 0);\n\t\treturn;\n\t}\n\n\tif (width * hwa742.pix_tx_time < hwa742.line_upd_time) {\n\t\thwa742.extif->enable_tearsync(1, 0);\n\t\treturn;\n\t}\n\n\tif ((width * hwa742.pix_tx_time / 1000) * height <\n\t    (y + height) * (hwa742.line_upd_time / 1000)) {\n\t\thwa742.extif->enable_tearsync(1, 0);\n\t\treturn;\n\t}\n\n\thwa742.extif->enable_tearsync(1, y + 1);\n}\n\nstatic void disable_tearsync(void)\n{\n\tu8 b;\n\n\thwa742.extif->enable_tearsync(0, 0);\n\n\tb = hwa742_read_reg(HWA742_NDP_CTRL);\n\tb &= ~(1 << 2);\n\thwa742_write_reg(HWA742_NDP_CTRL, b);\n}\n\nstatic inline struct hwa742_request *alloc_req(bool can_sleep)\n{\n\tunsigned long flags;\n\tstruct hwa742_request *req;\n\tint req_flags = 0;\n\n\tif (can_sleep)\n\t\tdown(&hwa742.req_sema);\n\telse\n\t\treq_flags = REQ_FROM_IRQ_POOL;\n\n\tspin_lock_irqsave(&hwa742.req_lock, flags);\n\tBUG_ON(list_empty(&hwa742.free_req_list));\n\treq = list_entry(hwa742.free_req_list.next,\n\t\t\t struct hwa742_request, entry);\n\tlist_del(&req->entry);\n\tspin_unlock_irqrestore(&hwa742.req_lock, flags);\n\n\tINIT_LIST_HEAD(&req->entry);\n\treq->flags = req_flags;\n\n\treturn req;\n}\n\nstatic inline void free_req(struct hwa742_request *req)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hwa742.req_lock, flags);\n\n\tlist_move(&req->entry, &hwa742.free_req_list);\n\tif (!(req->flags & REQ_FROM_IRQ_POOL))\n\t\tup(&hwa742.req_sema);\n\n\tspin_unlock_irqrestore(&hwa742.req_lock, flags);\n}\n\nstatic void process_pending_requests(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hwa742.req_lock, flags);\n\n\twhile (!list_empty(&hwa742.pending_req_list)) {\n\t\tstruct hwa742_request *req;\n\t\tvoid (*complete)(void *);\n\t\tvoid *complete_data;\n\n\t\treq = list_entry(hwa742.pending_req_list.next,\n\t\t\t\t struct hwa742_request, entry);\n\t\tspin_unlock_irqrestore(&hwa742.req_lock, flags);\n\n\t\tif (req->handler(req) == REQ_PENDING)\n\t\t\treturn;\n\n\t\tcomplete = req->complete;\n\t\tcomplete_data = req->complete_data;\n\t\tfree_req(req);\n\n\t\tif (complete)\n\t\t\tcomplete(complete_data);\n\n\t\tspin_lock_irqsave(&hwa742.req_lock, flags);\n\t}\n\n\tspin_unlock_irqrestore(&hwa742.req_lock, flags);\n}\n\nstatic void submit_req_list(struct list_head *head)\n{\n\tunsigned long flags;\n\tint process = 1;\n\n\tspin_lock_irqsave(&hwa742.req_lock, flags);\n\tif (likely(!list_empty(&hwa742.pending_req_list)))\n\t\tprocess = 0;\n\tlist_splice_init(head, hwa742.pending_req_list.prev);\n\tspin_unlock_irqrestore(&hwa742.req_lock, flags);\n\n\tif (process)\n\t\tprocess_pending_requests();\n}\n\nstatic void request_complete(void *data)\n{\n\tstruct hwa742_request\t*req = (struct hwa742_request *)data;\n\tvoid\t\t\t(*complete)(void *);\n\tvoid\t\t\t*complete_data;\n\n\tcomplete = req->complete;\n\tcomplete_data = req->complete_data;\n\n\tfree_req(req);\n\n\tif (complete)\n\t\tcomplete(complete_data);\n\n\tprocess_pending_requests();\n}\n\nstatic int send_frame_handler(struct hwa742_request *req)\n{\n\tstruct update_param *par = &req->par.update;\n\tint x = par->x;\n\tint y = par->y;\n\tint w = par->width;\n\tint h = par->height;\n\tint bpp;\n\tint conv, transl;\n\tunsigned long offset;\n\tint color_mode = par->color_mode;\n\tint flags = par->flags;\n\tint scr_width = hwa742.fbdev->panel->x_res;\n\tint scr_height = hwa742.fbdev->panel->y_res;\n\n#ifdef VERBOSE\n\tdev_dbg(hwa742.fbdev->dev, \"x %d y %d w %d h %d scr_width %d \"\n\t\t\"color_mode %d flags %d\\n\",\n\t\tx, y, w, h, scr_width, color_mode, flags);\n#endif\n\n\tswitch (color_mode) {\n\tcase OMAPFB_COLOR_YUV422:\n\t\tbpp = 16;\n\t\tconv = 0x08;\n\t\ttransl = 0x25;\n\t\tbreak;\n\tcase OMAPFB_COLOR_YUV420:\n\t\tbpp = 12;\n\t\tconv = 0x09;\n\t\ttransl = 0x25;\n\t\tbreak;\n\tcase OMAPFB_COLOR_RGB565:\n\t\tbpp = 16;\n\t\tconv = 0x01;\n\t\ttransl = 0x05;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (hwa742.prev_flags != flags ||\n\t    hwa742.prev_color_mode != color_mode) {\n\t\tset_format_regs(conv, transl, flags);\n\t\thwa742.prev_color_mode = color_mode;\n\t\thwa742.prev_flags = flags;\n\t}\n\tflags = req->par.update.flags;\n\tif (flags & OMAPFB_FORMAT_FLAG_TEARSYNC)\n\t\tenable_tearsync(y, scr_width, h, scr_height,\n\t\t\t\tflags & OMAPFB_FORMAT_FLAG_FORCE_VSYNC);\n\telse\n\t\tdisable_tearsync();\n\n\tset_window_regs(x, y, x + w, y + h);\n\n\toffset = (scr_width * y + x) * bpp / 8;\n\n\thwa742.int_ctrl->setup_plane(OMAPFB_PLANE_GFX,\n\t\t\tOMAPFB_CHANNEL_OUT_LCD, offset, scr_width, 0, 0, w, h,\n\t\t\tcolor_mode);\n\n\thwa742.extif->set_bits_per_cycle(16);\n\n\thwa742.int_ctrl->enable_plane(OMAPFB_PLANE_GFX, 1);\n\thwa742.extif->transfer_area(w, h, request_complete, req);\n\n\treturn REQ_PENDING;\n}\n\nstatic void send_frame_complete(void *data)\n{\n\thwa742.int_ctrl->enable_plane(OMAPFB_PLANE_GFX, 0);\n}\n\n#define ADD_PREQ(_x, _y, _w, _h, can_sleep) do {\\\n\treq = alloc_req(can_sleep);\t\t\\\n\treq->handler\t= send_frame_handler;\t\\\n\treq->complete\t= send_frame_complete;\t\\\n\treq->par.update.x = _x;\t\t\t\\\n\treq->par.update.y = _y;\t\t\t\\\n\treq->par.update.width  = _w;\t\t\\\n\treq->par.update.height = _h;\t\t\\\n\treq->par.update.color_mode = color_mode;\\\n\treq->par.update.flags\t  = flags;\t\\\n\tlist_add_tail(&req->entry, req_head);\t\\\n} while(0)\n\nstatic void create_req_list(struct omapfb_update_window *win,\n\t\t\t    struct list_head *req_head,\n\t\t\t    bool can_sleep)\n{\n\tstruct hwa742_request *req;\n\tint x = win->x;\n\tint y = win->y;\n\tint width = win->width;\n\tint height = win->height;\n\tint color_mode;\n\tint flags;\n\n\tflags = win->format & ~OMAPFB_FORMAT_MASK;\n\tcolor_mode = win->format & OMAPFB_FORMAT_MASK;\n\n\tif (x & 1) {\n\t\tADD_PREQ(x, y, 1, height, can_sleep);\n\t\twidth--;\n\t\tx++;\n\t\tflags &= ~OMAPFB_FORMAT_FLAG_TEARSYNC;\n\t}\n\tif (width & ~1) {\n\t\tunsigned int xspan = width & ~1;\n\t\tunsigned int ystart = y;\n\t\tunsigned int yspan = height;\n\n\t\tif (xspan * height * 2 > hwa742.max_transmit_size) {\n\t\t\tyspan = hwa742.max_transmit_size / (xspan * 2);\n\t\t\tADD_PREQ(x, ystart, xspan, yspan, can_sleep);\n\t\t\tystart += yspan;\n\t\t\tyspan = height - yspan;\n\t\t\tflags &= ~OMAPFB_FORMAT_FLAG_TEARSYNC;\n\t\t}\n\n\t\tADD_PREQ(x, ystart, xspan, yspan, can_sleep);\n\t\tx += xspan;\n\t\twidth -= xspan;\n\t\tflags &= ~OMAPFB_FORMAT_FLAG_TEARSYNC;\n\t}\n\tif (width)\n\t\tADD_PREQ(x, y, 1, height, can_sleep);\n}\n\nstatic void auto_update_complete(void *data)\n{\n\tif (!hwa742.stop_auto_update)\n\t\tmod_timer(&hwa742.auto_update_timer,\n\t\t\t  jiffies + HWA742_AUTO_UPDATE_TIME);\n}\n\nstatic void __hwa742_update_window_auto(bool can_sleep)\n{\n\tLIST_HEAD(req_list);\n\tstruct hwa742_request *last;\n\n\tcreate_req_list(&hwa742.auto_update_window, &req_list, can_sleep);\n\tlast = list_entry(req_list.prev, struct hwa742_request, entry);\n\n\tlast->complete = auto_update_complete;\n\tlast->complete_data = NULL;\n\n\tsubmit_req_list(&req_list);\n}\n\nstatic void hwa742_update_window_auto(struct timer_list *unused)\n{\n\t__hwa742_update_window_auto(false);\n}\n\nstatic int hwa742_update_window_async(struct fb_info *fbi,\n\t\t\t\t struct omapfb_update_window *win,\n\t\t\t\t void (*complete_callback)(void *arg),\n\t\t\t\t void *complete_callback_data)\n{\n\tLIST_HEAD(req_list);\n\tstruct hwa742_request *last;\n\tint r = 0;\n\n\tif (hwa742.update_mode != OMAPFB_MANUAL_UPDATE) {\n\t\tdev_dbg(hwa742.fbdev->dev, \"invalid update mode\\n\");\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (unlikely(win->format &\n\t    ~(0x03 | OMAPFB_FORMAT_FLAG_DOUBLE |\n\t    OMAPFB_FORMAT_FLAG_TEARSYNC | OMAPFB_FORMAT_FLAG_FORCE_VSYNC))) {\n\t\tdev_dbg(hwa742.fbdev->dev, \"invalid window flag\\n\");\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcreate_req_list(win, &req_list, true);\n\tlast = list_entry(req_list.prev, struct hwa742_request, entry);\n\n\tlast->complete = complete_callback;\n\tlast->complete_data = (void *)complete_callback_data;\n\n\tsubmit_req_list(&req_list);\n\nout:\n\treturn r;\n}\n\nstatic int hwa742_setup_plane(int plane, int channel_out,\n\t\t\t\t  unsigned long offset, int screen_width,\n\t\t\t\t  int pos_x, int pos_y, int width, int height,\n\t\t\t\t  int color_mode)\n{\n\tif (plane != OMAPFB_PLANE_GFX ||\n\t    channel_out != OMAPFB_CHANNEL_OUT_LCD)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hwa742_enable_plane(int plane, int enable)\n{\n\tif (plane != 0)\n\t\treturn -EINVAL;\n\n\thwa742.int_ctrl->enable_plane(plane, enable);\n\n\treturn 0;\n}\n\nstatic int sync_handler(struct hwa742_request *req)\n{\n\tcomplete(req->par.sync);\n\treturn REQ_COMPLETE;\n}\n\nstatic void hwa742_sync(void)\n{\n\tLIST_HEAD(req_list);\n\tstruct hwa742_request *req;\n\tstruct completion comp;\n\n\treq = alloc_req(true);\n\n\treq->handler = sync_handler;\n\treq->complete = NULL;\n\tinit_completion(&comp);\n\treq->par.sync = &comp;\n\n\tlist_add(&req->entry, &req_list);\n\tsubmit_req_list(&req_list);\n\n\twait_for_completion(&comp);\n}\n\nstatic void hwa742_bind_client(struct omapfb_notifier_block *nb)\n{\n\tdev_dbg(hwa742.fbdev->dev, \"update_mode %d\\n\", hwa742.update_mode);\n\tif (hwa742.update_mode == OMAPFB_MANUAL_UPDATE) {\n\t\tomapfb_notify_clients(hwa742.fbdev, OMAPFB_EVENT_READY);\n\t}\n}\n\nstatic int hwa742_set_update_mode(enum omapfb_update_mode mode)\n{\n\tif (mode != OMAPFB_MANUAL_UPDATE && mode != OMAPFB_AUTO_UPDATE &&\n\t    mode != OMAPFB_UPDATE_DISABLED)\n\t\treturn -EINVAL;\n\n\tif (mode == hwa742.update_mode)\n\t\treturn 0;\n\n\tdev_info(hwa742.fbdev->dev, \"HWA742: setting update mode to %s\\n\",\n\t\t\tmode == OMAPFB_UPDATE_DISABLED ? \"disabled\" :\n\t\t\t(mode == OMAPFB_AUTO_UPDATE ? \"auto\" : \"manual\"));\n\n\tswitch (hwa742.update_mode) {\n\tcase OMAPFB_MANUAL_UPDATE:\n\t\tomapfb_notify_clients(hwa742.fbdev, OMAPFB_EVENT_DISABLED);\n\t\tbreak;\n\tcase OMAPFB_AUTO_UPDATE:\n\t\thwa742.stop_auto_update = 1;\n\t\tdel_timer_sync(&hwa742.auto_update_timer);\n\t\tbreak;\n\tcase OMAPFB_UPDATE_DISABLED:\n\t\tbreak;\n\t}\n\n\thwa742.update_mode = mode;\n\thwa742_sync();\n\thwa742.stop_auto_update = 0;\n\n\tswitch (mode) {\n\tcase OMAPFB_MANUAL_UPDATE:\n\t\tomapfb_notify_clients(hwa742.fbdev, OMAPFB_EVENT_READY);\n\t\tbreak;\n\tcase OMAPFB_AUTO_UPDATE:\n\t\t__hwa742_update_window_auto(true);\n\t\tbreak;\n\tcase OMAPFB_UPDATE_DISABLED:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic enum omapfb_update_mode hwa742_get_update_mode(void)\n{\n\treturn hwa742.update_mode;\n}\n\nstatic unsigned long round_to_extif_ticks(unsigned long ps, int div)\n{\n\tint bus_tick = hwa742.extif_clk_period * div;\n\treturn (ps + bus_tick - 1) / bus_tick * bus_tick;\n}\n\nstatic int calc_reg_timing(unsigned long sysclk, int div)\n{\n\tstruct extif_timings *t;\n\tunsigned long systim;\n\n\t \n\tsystim = 1000000000 / (sysclk / 1000);\n\tdev_dbg(hwa742.fbdev->dev, \"HWA742 systim %lu ps extif_clk_period %u ps\"\n\t\t  \"extif_clk_div %d\\n\", systim, hwa742.extif_clk_period, div);\n\n\tt = &hwa742.reg_timings;\n\tmemset(t, 0, sizeof(*t));\n\tt->clk_div = div;\n\tt->cs_on_time = 0;\n\tt->we_on_time = round_to_extif_ticks(t->cs_on_time + 2000, div);\n\tt->re_on_time = round_to_extif_ticks(t->cs_on_time + 2000, div);\n\tt->access_time = round_to_extif_ticks(t->re_on_time + 12200, div);\n\tt->we_off_time = round_to_extif_ticks(t->we_on_time + 1000, div);\n\tt->re_off_time = round_to_extif_ticks(t->re_on_time + 16000, div);\n\tt->cs_off_time = round_to_extif_ticks(t->re_off_time + 1000, div);\n\tt->we_cycle_time = round_to_extif_ticks(2 * systim + 2000, div);\n\tif (t->we_cycle_time < t->we_off_time)\n\t\tt->we_cycle_time = t->we_off_time;\n\tt->re_cycle_time = round_to_extif_ticks(2 * systim + 2000, div);\n\tif (t->re_cycle_time < t->re_off_time)\n\t\tt->re_cycle_time = t->re_off_time;\n\tt->cs_pulse_width = 0;\n\n\tdev_dbg(hwa742.fbdev->dev, \"[reg]cson %d csoff %d reon %d reoff %d\\n\",\n\t\t t->cs_on_time, t->cs_off_time, t->re_on_time, t->re_off_time);\n\tdev_dbg(hwa742.fbdev->dev, \"[reg]weon %d weoff %d recyc %d wecyc %d\\n\",\n\t\t t->we_on_time, t->we_off_time, t->re_cycle_time,\n\t\t t->we_cycle_time);\n\tdev_dbg(hwa742.fbdev->dev, \"[reg]rdaccess %d cspulse %d\\n\",\n\t\t t->access_time, t->cs_pulse_width);\n\n\treturn hwa742.extif->convert_timings(t);\n}\n\nstatic int calc_lut_timing(unsigned long sysclk, int div)\n{\n\tstruct extif_timings *t;\n\tunsigned long systim;\n\n\t \n\tsystim = 1000000000 / (sysclk / 1000);\n\tdev_dbg(hwa742.fbdev->dev, \"HWA742 systim %lu ps extif_clk_period %u ps\"\n\t\t  \"extif_clk_div %d\\n\", systim, hwa742.extif_clk_period, div);\n\n\tt = &hwa742.lut_timings;\n\tmemset(t, 0, sizeof(*t));\n\n\tt->clk_div = div;\n\n\tt->cs_on_time = 0;\n\tt->we_on_time = round_to_extif_ticks(t->cs_on_time + 2000, div);\n\tt->re_on_time = round_to_extif_ticks(t->cs_on_time + 2000, div);\n\tt->access_time = round_to_extif_ticks(t->re_on_time + 4 * systim +\n\t\t\t\t\t      26000, div);\n\tt->we_off_time = round_to_extif_ticks(t->we_on_time + 1000, div);\n\tt->re_off_time = round_to_extif_ticks(t->re_on_time + 4 * systim +\n\t\t\t\t\t      26000, div);\n\tt->cs_off_time = round_to_extif_ticks(t->re_off_time + 1000, div);\n\tt->we_cycle_time = round_to_extif_ticks(2 * systim + 2000, div);\n\tif (t->we_cycle_time < t->we_off_time)\n\t\tt->we_cycle_time = t->we_off_time;\n\tt->re_cycle_time = round_to_extif_ticks(2000 + 4 * systim + 26000, div);\n\tif (t->re_cycle_time < t->re_off_time)\n\t\tt->re_cycle_time = t->re_off_time;\n\tt->cs_pulse_width = 0;\n\n\tdev_dbg(hwa742.fbdev->dev, \"[lut]cson %d csoff %d reon %d reoff %d\\n\",\n\t\t t->cs_on_time, t->cs_off_time, t->re_on_time, t->re_off_time);\n\tdev_dbg(hwa742.fbdev->dev, \"[lut]weon %d weoff %d recyc %d wecyc %d\\n\",\n\t\t t->we_on_time, t->we_off_time, t->re_cycle_time,\n\t\t t->we_cycle_time);\n\tdev_dbg(hwa742.fbdev->dev, \"[lut]rdaccess %d cspulse %d\\n\",\n\t\t t->access_time, t->cs_pulse_width);\n\n\treturn hwa742.extif->convert_timings(t);\n}\n\nstatic int calc_extif_timings(unsigned long sysclk, int *extif_mem_div)\n{\n\tint max_clk_div;\n\tint div;\n\n\thwa742.extif->get_clk_info(&hwa742.extif_clk_period, &max_clk_div);\n\tfor (div = 1; div < max_clk_div; div++) {\n\t\tif (calc_reg_timing(sysclk, div) == 0)\n\t\t\tbreak;\n\t}\n\tif (div >= max_clk_div)\n\t\tgoto err;\n\n\t*extif_mem_div = div;\n\n\tfor (div = 1; div < max_clk_div; div++) {\n\t\tif (calc_lut_timing(sysclk, div) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (div >= max_clk_div)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdev_err(hwa742.fbdev->dev, \"can't setup timings\\n\");\n\treturn -1;\n}\n\nstatic void calc_hwa742_clk_rates(unsigned long ext_clk,\n\t\t\t\tunsigned long *sys_clk, unsigned long *pix_clk)\n{\n\tint pix_clk_src;\n\tint sys_div = 0, sys_mul = 0;\n\tint pix_div;\n\n\tpix_clk_src = hwa742_read_reg(HWA742_CLK_SRC_REG);\n\tpix_div = ((pix_clk_src >> 3) & 0x1f) + 1;\n\tif ((pix_clk_src & (0x3 << 1)) == 0) {\n\t\t \n\t\tsys_div = (hwa742_read_reg(HWA742_PLL_DIV_REG) & 0x3f) + 1;\n\t\tsys_mul = (hwa742_read_reg(HWA742_PLL_4_REG) & 0x7f) + 1;\n\t\t*sys_clk = ext_clk * sys_mul / sys_div;\n\t} else\t \n\t\t*sys_clk = ext_clk;\n\n\t*pix_clk = *sys_clk / pix_div;\t\t\t \n\tdev_dbg(hwa742.fbdev->dev,\n\t\t\"ext_clk %ld pix_src %d pix_div %d sys_div %d sys_mul %d\\n\",\n\t\text_clk, pix_clk_src & (0x3 << 1), pix_div, sys_div, sys_mul);\n\tdev_dbg(hwa742.fbdev->dev, \"sys_clk %ld pix_clk %ld\\n\",\n\t\t*sys_clk, *pix_clk);\n}\n\n\nstatic int setup_tearsync(unsigned long pix_clk, int extif_div)\n{\n\tint hdisp, vdisp;\n\tint hndp, vndp;\n\tint hsw, vsw;\n\tint hs, vs;\n\tint hs_pol_inv, vs_pol_inv;\n\tint use_hsvs, use_ndp;\n\tu8  b;\n\n\thsw = hwa742_read_reg(HWA742_HS_W_REG);\n\tvsw = hwa742_read_reg(HWA742_VS_W_REG);\n\ths_pol_inv = !(hsw & 0x80);\n\tvs_pol_inv = !(vsw & 0x80);\n\thsw = hsw & 0x7f;\n\tvsw = vsw & 0x3f;\n\n\thdisp = (hwa742_read_reg(HWA742_H_DISP_REG) & 0x7f) * 8;\n\tvdisp = hwa742_read_reg(HWA742_V_DISP_1_REG) +\n\t\t((hwa742_read_reg(HWA742_V_DISP_2_REG) & 0x3) << 8);\n\n\thndp = hwa742_read_reg(HWA742_H_NDP_REG) & 0x7f;\n\tvndp = hwa742_read_reg(HWA742_V_NDP_REG);\n\n\t \n\thwa742.pix_tx_time = hwa742.reg_timings.we_cycle_time;\n\tif (hwa742.extif->get_max_tx_rate != NULL) {\n\t\t \n\t\tunsigned long min_tx_time;\n\t\tunsigned long max_tx_rate = hwa742.extif->get_max_tx_rate();\n\n\t\tdev_dbg(hwa742.fbdev->dev, \"max_tx_rate %ld HZ\\n\",\n\t\t\tmax_tx_rate);\n\t\tmin_tx_time = 1000000000 / (max_tx_rate / 1000);   \n\t\tif (hwa742.pix_tx_time < min_tx_time)\n\t\t\thwa742.pix_tx_time = min_tx_time;\n\t}\n\n\t \n\thwa742.line_upd_time = (hdisp + hndp) * 1000000 / (pix_clk / 1000);\n\thwa742.line_upd_time *= 1000;\n\tif (hdisp * hwa742.pix_tx_time > hwa742.line_upd_time)\n\t\t \n\t\tuse_hsvs = 1;\n\telse\n\t\t \n\t\tuse_hsvs = 0;\n\n\tif (use_hsvs && (hs_pol_inv || vs_pol_inv)) {\n\t\t \n\t\tuse_ndp = 1;\n\t\ths_pol_inv = 0;\n\t\tvs_pol_inv = 0;\n\t\ths = hndp;\n\t\tvs = vndp;\n\t} else {\n\t\t \n\t\tuse_ndp = 0;\n\t\ths = hsw;\n\t\tvs = vsw;\n\t\tif (!use_hsvs) {\n\t\t\ths_pol_inv = 0;\n\t\t\tvs_pol_inv = 0;\n\t\t}\n\t}\n\n\ths = hs * 1000000 / (pix_clk / 1000);\t\t\t \n\ths *= 1000;\n\n\tvs = vs * (hdisp + hndp) * 1000000 / (pix_clk / 1000);\t \n\tvs *= 1000;\n\n\tif (vs <= hs)\n\t\treturn -EDOM;\n\t \n\tvs = hs * 12 / 10;\n\t \n\ths = 10000;\n\n\tb = hwa742_read_reg(HWA742_NDP_CTRL);\n\tb &= ~0x3;\n\tb |= use_hsvs ? 1 : 0;\n\tb |= (use_ndp && use_hsvs) ? 0 : 2;\n\thwa742_write_reg(HWA742_NDP_CTRL, b);\n\n\thwa742.vsync_only = !use_hsvs;\n\n\tdev_dbg(hwa742.fbdev->dev,\n\t\t\"pix_clk %ld HZ pix_tx_time %ld ps line_upd_time %ld ps\\n\",\n\t\tpix_clk, hwa742.pix_tx_time, hwa742.line_upd_time);\n\tdev_dbg(hwa742.fbdev->dev,\n\t\t\"hs %d ps vs %d ps mode %d vsync_only %d\\n\",\n\t\ths, vs, (b & 0x3), !use_hsvs);\n\n\treturn hwa742.extif->setup_tearsync(1, hs, vs,\n\t\t\t\t\t    hs_pol_inv, vs_pol_inv, extif_div);\n}\n\nstatic void hwa742_get_caps(int plane, struct omapfb_caps *caps)\n{\n\thwa742.int_ctrl->get_caps(plane, caps);\n\tcaps->ctrl |= OMAPFB_CAPS_MANUAL_UPDATE |\n\t\t      OMAPFB_CAPS_WINDOW_PIXEL_DOUBLE;\n\tif (hwa742.te_connected)\n\t\tcaps->ctrl |= OMAPFB_CAPS_TEARSYNC;\n\tcaps->wnd_color |= (1 << OMAPFB_COLOR_RGB565) |\n\t\t\t   (1 << OMAPFB_COLOR_YUV420);\n}\n\nstatic void hwa742_suspend(void)\n{\n\thwa742.update_mode_before_suspend = hwa742.update_mode;\n\thwa742_set_update_mode(OMAPFB_UPDATE_DISABLED);\n\t \n\thwa742_write_reg(HWA742_POWER_SAVE, 1 << 1);\n\tclk_disable(hwa742.sys_ck);\n}\n\nstatic void hwa742_resume(void)\n{\n\tclk_enable(hwa742.sys_ck);\n\n\t \n\thwa742_write_reg(HWA742_POWER_SAVE, 0);\n\twhile (1) {\n\t\t \n\t\tif (hwa742_read_reg(HWA742_PLL_DIV_REG) & (1 << 7))\n\t\t\tbreak;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(msecs_to_jiffies(5));\n\t}\n\thwa742_set_update_mode(hwa742.update_mode_before_suspend);\n}\n\nstatic int hwa742_init(struct omapfb_device *fbdev, int ext_mode,\n\t\t       struct omapfb_mem_desc *req_vram)\n{\n\tint r = 0, i;\n\tu8 rev, conf;\n\tunsigned long ext_clk;\n\tunsigned long sys_clk, pix_clk;\n\tint extif_mem_div;\n\tstruct omapfb_platform_data *omapfb_conf;\n\n\tBUG_ON(!fbdev->ext_if || !fbdev->int_ctrl);\n\n\thwa742.fbdev = fbdev;\n\thwa742.extif = fbdev->ext_if;\n\thwa742.int_ctrl = fbdev->int_ctrl;\n\n\tomapfb_conf = dev_get_platdata(fbdev->dev);\n\n\thwa742.sys_ck = clk_get(NULL, \"hwa_sys_ck\");\n\n\tspin_lock_init(&hwa742.req_lock);\n\n\tif ((r = hwa742.int_ctrl->init(fbdev, 1, req_vram)) < 0)\n\t\tgoto err1;\n\n\tif ((r = hwa742.extif->init(fbdev)) < 0)\n\t\tgoto err2;\n\n\text_clk = clk_get_rate(hwa742.sys_ck);\n\tif ((r = calc_extif_timings(ext_clk, &extif_mem_div)) < 0)\n\t\tgoto err3;\n\thwa742.extif->set_timings(&hwa742.reg_timings);\n\tclk_prepare_enable(hwa742.sys_ck);\n\n\tcalc_hwa742_clk_rates(ext_clk, &sys_clk, &pix_clk);\n\tif ((r = calc_extif_timings(sys_clk, &extif_mem_div)) < 0)\n\t\tgoto err4;\n\thwa742.extif->set_timings(&hwa742.reg_timings);\n\n\trev = hwa742_read_reg(HWA742_REV_CODE_REG);\n\tif ((rev & 0xfc) != 0x80) {\n\t\tdev_err(fbdev->dev, \"HWA742: invalid revision %02x\\n\", rev);\n\t\tr = -ENODEV;\n\t\tgoto err4;\n\t}\n\n\n\tif (!(hwa742_read_reg(HWA742_PLL_DIV_REG) & 0x80)) {\n\t\tdev_err(fbdev->dev,\n\t\t      \"HWA742: controller not initialized by the bootloader\\n\");\n\t\tr = -ENODEV;\n\t\tgoto err4;\n\t}\n\n\tif ((r = setup_tearsync(pix_clk, extif_mem_div)) < 0) {\n\t\tdev_err(hwa742.fbdev->dev,\n\t\t\t\"HWA742: can't setup tearing synchronization\\n\");\n\t\tgoto err4;\n\t}\n\thwa742.te_connected = 1;\n\n\thwa742.max_transmit_size = hwa742.extif->max_transmit_size;\n\n\thwa742.update_mode = OMAPFB_UPDATE_DISABLED;\n\n\thwa742.auto_update_window.x = 0;\n\thwa742.auto_update_window.y = 0;\n\thwa742.auto_update_window.width = fbdev->panel->x_res;\n\thwa742.auto_update_window.height = fbdev->panel->y_res;\n\thwa742.auto_update_window.format = 0;\n\n\ttimer_setup(&hwa742.auto_update_timer, hwa742_update_window_auto, 0);\n\n\thwa742.prev_color_mode = -1;\n\thwa742.prev_flags = 0;\n\n\thwa742.fbdev = fbdev;\n\n\tINIT_LIST_HEAD(&hwa742.free_req_list);\n\tINIT_LIST_HEAD(&hwa742.pending_req_list);\n\tfor (i = 0; i < ARRAY_SIZE(hwa742.req_pool); i++)\n\t\tlist_add(&hwa742.req_pool[i].entry, &hwa742.free_req_list);\n\tBUG_ON(i <= IRQ_REQ_POOL_SIZE);\n\tsema_init(&hwa742.req_sema, i - IRQ_REQ_POOL_SIZE);\n\n\tconf = hwa742_read_reg(HWA742_CONFIG_REG);\n\tdev_info(fbdev->dev, \": Epson HWA742 LCD controller rev %d \"\n\t\t\t\"initialized (CNF pins %x)\\n\", rev & 0x03, conf & 0x07);\n\n\treturn 0;\nerr4:\n\tclk_disable_unprepare(hwa742.sys_ck);\nerr3:\n\thwa742.extif->cleanup();\nerr2:\n\thwa742.int_ctrl->cleanup();\nerr1:\n\treturn r;\n}\n\nstatic void hwa742_cleanup(void)\n{\n\thwa742_set_update_mode(OMAPFB_UPDATE_DISABLED);\n\thwa742.extif->cleanup();\n\thwa742.int_ctrl->cleanup();\n\tclk_disable_unprepare(hwa742.sys_ck);\n}\n\nstruct lcd_ctrl hwa742_ctrl = {\n\t.name\t\t\t= \"hwa742\",\n\t.init\t\t\t= hwa742_init,\n\t.cleanup\t\t= hwa742_cleanup,\n\t.bind_client\t\t= hwa742_bind_client,\n\t.get_caps\t\t= hwa742_get_caps,\n\t.set_update_mode\t= hwa742_set_update_mode,\n\t.get_update_mode\t= hwa742_get_update_mode,\n\t.setup_plane\t\t= hwa742_setup_plane,\n\t.enable_plane\t\t= hwa742_enable_plane,\n\t.update_window\t\t= hwa742_update_window_async,\n\t.sync\t\t\t= hwa742_sync,\n\t.suspend\t\t= hwa742_suspend,\n\t.resume\t\t\t= hwa742_resume,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}