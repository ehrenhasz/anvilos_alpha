{
  "module_name": "lcd_dma.c",
  "hash_id": "44e9e09cb70f8d84f51a5a8f14e957597264bb609f2a7266acc04c3270eefc2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap/lcd_dma.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n\n#include <linux/omap-dma.h>\n\n#include <linux/soc/ti/omap1-soc.h>\n#include <linux/soc/ti/omap1-io.h>\n\n#include \"lcdc.h\"\n#include \"lcd_dma.h\"\n\nint omap_lcd_dma_running(void)\n{\n\t \n\tif (cpu_is_omap15xx())\n\t\tif (omap_readw(OMAP_LCDC_CONTROL) & OMAP_LCDC_CTRL_LCD_EN)\n\t\t\treturn 1;\n\n\t \n\tif (cpu_is_omap16xx())\n\t\tif (omap_readw(OMAP1610_DMA_LCD_CCR) & OMAP_DMA_CCR_EN)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct lcd_dma_info {\n\tspinlock_t lock;\n\tint reserved;\n\tvoid (*callback)(u16 status, void *data);\n\tvoid *cb_data;\n\n\tint active;\n\tunsigned long addr;\n\tint rotate, data_type, xres, yres;\n\tint vxres;\n\tint mirror;\n\tint xscale, yscale;\n\tint ext_ctrl;\n\tint src_port;\n\tint single_transfer;\n} lcd_dma;\n\nvoid omap_set_lcd_dma_b1(unsigned long addr, u16 fb_xres, u16 fb_yres,\n\t\t\t int data_type)\n{\n\tlcd_dma.addr = addr;\n\tlcd_dma.data_type = data_type;\n\tlcd_dma.xres = fb_xres;\n\tlcd_dma.yres = fb_yres;\n}\nEXPORT_SYMBOL(omap_set_lcd_dma_b1);\n\nvoid omap_set_lcd_dma_ext_controller(int external)\n{\n\tlcd_dma.ext_ctrl = external;\n}\nEXPORT_SYMBOL(omap_set_lcd_dma_ext_controller);\n\nvoid omap_set_lcd_dma_single_transfer(int single)\n{\n\tlcd_dma.single_transfer = single;\n}\nEXPORT_SYMBOL(omap_set_lcd_dma_single_transfer);\n\nvoid omap_set_lcd_dma_b1_rotation(int rotate)\n{\n\tif (cpu_is_omap15xx()) {\n\t\tprintk(KERN_ERR \"DMA rotation is not supported in 1510 mode\\n\");\n\t\tBUG();\n\t\treturn;\n\t}\n\tlcd_dma.rotate = rotate;\n}\nEXPORT_SYMBOL(omap_set_lcd_dma_b1_rotation);\n\nvoid omap_set_lcd_dma_b1_mirror(int mirror)\n{\n\tif (cpu_is_omap15xx()) {\n\t\tprintk(KERN_ERR \"DMA mirror is not supported in 1510 mode\\n\");\n\t\tBUG();\n\t}\n\tlcd_dma.mirror = mirror;\n}\nEXPORT_SYMBOL(omap_set_lcd_dma_b1_mirror);\n\nvoid omap_set_lcd_dma_b1_vxres(unsigned long vxres)\n{\n\tif (cpu_is_omap15xx()) {\n\t\tpr_err(\"DMA virtual resolution is not supported in 1510 mode\\n\");\n\t\tBUG();\n\t}\n\tlcd_dma.vxres = vxres;\n}\nEXPORT_SYMBOL(omap_set_lcd_dma_b1_vxres);\n\nvoid omap_set_lcd_dma_b1_scale(unsigned int xscale, unsigned int yscale)\n{\n\tif (cpu_is_omap15xx()) {\n\t\tprintk(KERN_ERR \"DMA scale is not supported in 1510 mode\\n\");\n\t\tBUG();\n\t}\n\tlcd_dma.xscale = xscale;\n\tlcd_dma.yscale = yscale;\n}\nEXPORT_SYMBOL(omap_set_lcd_dma_b1_scale);\n\nstatic void set_b1_regs(void)\n{\n\tunsigned long top, bottom;\n\tint es;\n\tu16 w;\n\tunsigned long en, fn;\n\tlong ei, fi;\n\tunsigned long vxres;\n\tunsigned int xscale, yscale;\n\n\tswitch (lcd_dma.data_type) {\n\tcase OMAP_DMA_DATA_TYPE_S8:\n\t\tes = 1;\n\t\tbreak;\n\tcase OMAP_DMA_DATA_TYPE_S16:\n\t\tes = 2;\n\t\tbreak;\n\tcase OMAP_DMA_DATA_TYPE_S32:\n\t\tes = 4;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tvxres = lcd_dma.vxres ? lcd_dma.vxres : lcd_dma.xres;\n\txscale = lcd_dma.xscale ? lcd_dma.xscale : 1;\n\tyscale = lcd_dma.yscale ? lcd_dma.yscale : 1;\n\tBUG_ON(vxres < lcd_dma.xres);\n\n#define PIXADDR(x, y) (lcd_dma.addr +\t\t\t\t\t\\\n\t\t((y) * vxres * yscale + (x) * xscale) * es)\n#define PIXSTEP(sx, sy, dx, dy) (PIXADDR(dx, dy) - PIXADDR(sx, sy) - es + 1)\n\n\tswitch (lcd_dma.rotate) {\n\tcase 0:\n\t\tif (!lcd_dma.mirror) {\n\t\t\ttop = PIXADDR(0, 0);\n\t\t\tbottom = PIXADDR(lcd_dma.xres - 1, lcd_dma.yres - 1);\n\t\t\t \n\t\t\tif (cpu_is_omap15xx() &&\n\t\t\t\tlcd_dma.data_type == OMAP_DMA_DATA_TYPE_S32)\n\t\t\t\t\tbottom += 2;\n\t\t\tei = PIXSTEP(0, 0, 1, 0);\n\t\t\tfi = PIXSTEP(lcd_dma.xres - 1, 0, 0, 1);\n\t\t} else {\n\t\t\ttop = PIXADDR(lcd_dma.xres - 1, 0);\n\t\t\tbottom = PIXADDR(0, lcd_dma.yres - 1);\n\t\t\tei = PIXSTEP(1, 0, 0, 0);\n\t\t\tfi = PIXSTEP(0, 0, lcd_dma.xres - 1, 1);\n\t\t}\n\t\ten = lcd_dma.xres;\n\t\tfn = lcd_dma.yres;\n\t\tbreak;\n\tcase 90:\n\t\tif (!lcd_dma.mirror) {\n\t\t\ttop = PIXADDR(0, lcd_dma.yres - 1);\n\t\t\tbottom = PIXADDR(lcd_dma.xres - 1, 0);\n\t\t\tei = PIXSTEP(0, 1, 0, 0);\n\t\t\tfi = PIXSTEP(0, 0, 1, lcd_dma.yres - 1);\n\t\t} else {\n\t\t\ttop = PIXADDR(lcd_dma.xres - 1, lcd_dma.yres - 1);\n\t\t\tbottom = PIXADDR(0, 0);\n\t\t\tei = PIXSTEP(0, 1, 0, 0);\n\t\t\tfi = PIXSTEP(1, 0, 0, lcd_dma.yres - 1);\n\t\t}\n\t\ten = lcd_dma.yres;\n\t\tfn = lcd_dma.xres;\n\t\tbreak;\n\tcase 180:\n\t\tif (!lcd_dma.mirror) {\n\t\t\ttop = PIXADDR(lcd_dma.xres - 1, lcd_dma.yres - 1);\n\t\t\tbottom = PIXADDR(0, 0);\n\t\t\tei = PIXSTEP(1, 0, 0, 0);\n\t\t\tfi = PIXSTEP(0, 1, lcd_dma.xres - 1, 0);\n\t\t} else {\n\t\t\ttop = PIXADDR(0, lcd_dma.yres - 1);\n\t\t\tbottom = PIXADDR(lcd_dma.xres - 1, 0);\n\t\t\tei = PIXSTEP(0, 0, 1, 0);\n\t\t\tfi = PIXSTEP(lcd_dma.xres - 1, 1, 0, 0);\n\t\t}\n\t\ten = lcd_dma.xres;\n\t\tfn = lcd_dma.yres;\n\t\tbreak;\n\tcase 270:\n\t\tif (!lcd_dma.mirror) {\n\t\t\ttop = PIXADDR(lcd_dma.xres - 1, 0);\n\t\t\tbottom = PIXADDR(0, lcd_dma.yres - 1);\n\t\t\tei = PIXSTEP(0, 0, 0, 1);\n\t\t\tfi = PIXSTEP(1, lcd_dma.yres - 1, 0, 0);\n\t\t} else {\n\t\t\ttop = PIXADDR(0, 0);\n\t\t\tbottom = PIXADDR(lcd_dma.xres - 1, lcd_dma.yres - 1);\n\t\t\tei = PIXSTEP(0, 0, 0, 1);\n\t\t\tfi = PIXSTEP(0, lcd_dma.yres - 1, 1, 0);\n\t\t}\n\t\ten = lcd_dma.yres;\n\t\tfn = lcd_dma.xres;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\t \n\t}\n\n\tif (cpu_is_omap15xx()) {\n\t\tomap_writew(top >> 16, OMAP1510_DMA_LCD_TOP_F1_U);\n\t\tomap_writew(top, OMAP1510_DMA_LCD_TOP_F1_L);\n\t\tomap_writew(bottom >> 16, OMAP1510_DMA_LCD_BOT_F1_U);\n\t\tomap_writew(bottom, OMAP1510_DMA_LCD_BOT_F1_L);\n\n\t\treturn;\n\t}\n\n\t \n\tomap_writew(top >> 16, OMAP1610_DMA_LCD_TOP_B1_U);\n\tomap_writew(top, OMAP1610_DMA_LCD_TOP_B1_L);\n\tomap_writew(bottom >> 16, OMAP1610_DMA_LCD_BOT_B1_U);\n\tomap_writew(bottom, OMAP1610_DMA_LCD_BOT_B1_L);\n\n\tomap_writew(en, OMAP1610_DMA_LCD_SRC_EN_B1);\n\tomap_writew(fn, OMAP1610_DMA_LCD_SRC_FN_B1);\n\n\tw = omap_readw(OMAP1610_DMA_LCD_CSDP);\n\tw &= ~0x03;\n\tw |= lcd_dma.data_type;\n\tomap_writew(w, OMAP1610_DMA_LCD_CSDP);\n\n\tw = omap_readw(OMAP1610_DMA_LCD_CTRL);\n\t \n\tw &= ~(0x03 << 6);\n\tif (lcd_dma.callback != NULL)\n\t\tw |= 1 << 1;\t\t \n\telse\n\t\tw &= ~(1 << 1);\n\tomap_writew(w, OMAP1610_DMA_LCD_CTRL);\n\n\tif (!(lcd_dma.rotate || lcd_dma.mirror ||\n\t      lcd_dma.vxres || lcd_dma.xscale || lcd_dma.yscale))\n\t\treturn;\n\n\tw = omap_readw(OMAP1610_DMA_LCD_CCR);\n\t \n\tw |= (0x03 << 12);\n\tomap_writew(w, OMAP1610_DMA_LCD_CCR);\n\n\tomap_writew(ei, OMAP1610_DMA_LCD_SRC_EI_B1);\n\tomap_writew(fi >> 16, OMAP1610_DMA_LCD_SRC_FI_B1_U);\n\tomap_writew(fi, OMAP1610_DMA_LCD_SRC_FI_B1_L);\n}\n\nstatic irqreturn_t lcd_dma_irq_handler(int irq, void *dev_id)\n{\n\tu16 w;\n\n\tw = omap_readw(OMAP1610_DMA_LCD_CTRL);\n\tif (unlikely(!(w & (1 << 3)))) {\n\t\tprintk(KERN_WARNING \"Spurious LCD DMA IRQ\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\t \n\tw |= (1 << 3);\n\tomap_writew(w, OMAP1610_DMA_LCD_CTRL);\n\tlcd_dma.active = 0;\n\tif (lcd_dma.callback != NULL)\n\t\tlcd_dma.callback(w, lcd_dma.cb_data);\n\n\treturn IRQ_HANDLED;\n}\n\nint omap_request_lcd_dma(void (*callback)(u16 status, void *data),\n\t\t\t void *data)\n{\n\tspin_lock_irq(&lcd_dma.lock);\n\tif (lcd_dma.reserved) {\n\t\tspin_unlock_irq(&lcd_dma.lock);\n\t\tprintk(KERN_ERR \"LCD DMA channel already reserved\\n\");\n\t\tBUG();\n\t\treturn -EBUSY;\n\t}\n\tlcd_dma.reserved = 1;\n\tspin_unlock_irq(&lcd_dma.lock);\n\tlcd_dma.callback = callback;\n\tlcd_dma.cb_data = data;\n\tlcd_dma.active = 0;\n\tlcd_dma.single_transfer = 0;\n\tlcd_dma.rotate = 0;\n\tlcd_dma.vxres = 0;\n\tlcd_dma.mirror = 0;\n\tlcd_dma.xscale = 0;\n\tlcd_dma.yscale = 0;\n\tlcd_dma.ext_ctrl = 0;\n\tlcd_dma.src_port = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(omap_request_lcd_dma);\n\nvoid omap_free_lcd_dma(void)\n{\n\tspin_lock(&lcd_dma.lock);\n\tif (!lcd_dma.reserved) {\n\t\tspin_unlock(&lcd_dma.lock);\n\t\tprintk(KERN_ERR \"LCD DMA is not reserved\\n\");\n\t\tBUG();\n\t\treturn;\n\t}\n\tif (!cpu_is_omap15xx())\n\t\tomap_writew(omap_readw(OMAP1610_DMA_LCD_CCR) & ~1,\n\t\t\t    OMAP1610_DMA_LCD_CCR);\n\tlcd_dma.reserved = 0;\n\tspin_unlock(&lcd_dma.lock);\n}\nEXPORT_SYMBOL(omap_free_lcd_dma);\n\nvoid omap_enable_lcd_dma(void)\n{\n\tu16 w;\n\n\t \n\tif (cpu_is_omap15xx() || !lcd_dma.ext_ctrl)\n\t\treturn;\n\n\tw = omap_readw(OMAP1610_DMA_LCD_CTRL);\n\tw |= 1 << 8;\n\tomap_writew(w, OMAP1610_DMA_LCD_CTRL);\n\n\tlcd_dma.active = 1;\n\n\tw = omap_readw(OMAP1610_DMA_LCD_CCR);\n\tw |= 1 << 7;\n\tomap_writew(w, OMAP1610_DMA_LCD_CCR);\n}\nEXPORT_SYMBOL(omap_enable_lcd_dma);\n\nvoid omap_setup_lcd_dma(void)\n{\n\tBUG_ON(lcd_dma.active);\n\tif (!cpu_is_omap15xx()) {\n\t\t \n\t\tomap_writew(0x5440, OMAP1610_DMA_LCD_CCR);\n\t\tomap_writew(0x9102, OMAP1610_DMA_LCD_CSDP);\n\t\tomap_writew(0x0004, OMAP1610_DMA_LCD_LCH_CTRL);\n\t}\n\tset_b1_regs();\n\tif (!cpu_is_omap15xx()) {\n\t\tu16 w;\n\n\t\tw = omap_readw(OMAP1610_DMA_LCD_CCR);\n\t\t \n\t\tw |= 1 << 11;\t\t \n\t\tif (!lcd_dma.single_transfer)\n\t\t\tw |= (3 << 8);\t \n\t\tomap_writew(w, OMAP1610_DMA_LCD_CCR);\n\t}\n}\nEXPORT_SYMBOL(omap_setup_lcd_dma);\n\nvoid omap_stop_lcd_dma(void)\n{\n\tu16 w;\n\n\tlcd_dma.active = 0;\n\tif (cpu_is_omap15xx() || !lcd_dma.ext_ctrl)\n\t\treturn;\n\n\tw = omap_readw(OMAP1610_DMA_LCD_CCR);\n\tw &= ~(1 << 7);\n\tomap_writew(w, OMAP1610_DMA_LCD_CCR);\n\n\tw = omap_readw(OMAP1610_DMA_LCD_CTRL);\n\tw &= ~(1 << 8);\n\tomap_writew(w, OMAP1610_DMA_LCD_CTRL);\n}\nEXPORT_SYMBOL(omap_stop_lcd_dma);\n\nstatic int __init omap_init_lcd_dma(void)\n{\n\tint r;\n\n\tif (!cpu_class_is_omap1())\n\t\treturn -ENODEV;\n\n\tif (cpu_is_omap16xx()) {\n\t\tu16 w;\n\n\t\t \n\t\tw = omap_readw(OMAP1610_DMA_LCD_CTRL);\n\t\tw &= ~(1 << 8);\n\t\tomap_writew(w, OMAP1610_DMA_LCD_CTRL);\n\t}\n\n\tspin_lock_init(&lcd_dma.lock);\n\n\tr = request_irq(INT_DMA_LCD, lcd_dma_irq_handler, 0,\n\t\t\t\"LCD DMA\", NULL);\n\tif (r != 0)\n\t\tpr_err(\"unable to request IRQ for LCD DMA (error %d)\\n\", r);\n\n\treturn r;\n}\n\narch_initcall(omap_init_lcd_dma);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}