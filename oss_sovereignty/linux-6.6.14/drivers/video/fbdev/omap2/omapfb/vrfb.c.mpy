{
  "module_name": "vrfb.c",
  "hash_id": "d091dda10dc18f217cac7681ce6a038a282349b344af0c2aef7de9ce971164aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/vrfb.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/bitops.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n\n#include <video/omapvrfb.h>\n\n#ifdef DEBUG\n#define DBG(format, ...) pr_debug(\"VRFB: \" format, ## __VA_ARGS__)\n#else\n#define DBG(format, ...)\n#endif\n\n#define SMS_ROT_CONTROL(context)\t(0x0 + 0x10 * context)\n#define SMS_ROT_SIZE(context)\t\t(0x4 + 0x10 * context)\n#define SMS_ROT_PHYSICAL_BA(context)\t(0x8 + 0x10 * context)\n#define SMS_ROT_VIRT_BASE(rot)\t\t(0x1000000 * (rot))\n\n#define OMAP_VRFB_SIZE\t\t\t(2048 * 2048 * 4)\n\n#define VRFB_PAGE_WIDTH_EXP\t5  \n#define VRFB_PAGE_HEIGHT_EXP\t5  \n#define VRFB_PAGE_WIDTH\t\t(1 << VRFB_PAGE_WIDTH_EXP)\n#define VRFB_PAGE_HEIGHT\t(1 << VRFB_PAGE_HEIGHT_EXP)\n#define SMS_IMAGEHEIGHT_OFFSET\t16\n#define SMS_IMAGEWIDTH_OFFSET\t0\n#define SMS_PH_OFFSET\t\t8\n#define SMS_PW_OFFSET\t\t4\n#define SMS_PS_OFFSET\t\t0\n\n \nstatic unsigned long ctx_map;\n\nstruct vrfb_ctx {\n\tu32 base;\n\tu32 physical_ba;\n\tu32 control;\n\tu32 size;\n};\n\nstatic DEFINE_MUTEX(ctx_lock);\n\n \n\nstatic void __iomem *vrfb_base;\n\nstatic int num_ctxs;\nstatic struct vrfb_ctx *ctxs;\n\nstatic bool vrfb_loaded;\n\nstatic void omap2_sms_write_rot_control(u32 val, unsigned ctx)\n{\n\t__raw_writel(val, vrfb_base + SMS_ROT_CONTROL(ctx));\n}\n\nstatic void omap2_sms_write_rot_size(u32 val, unsigned ctx)\n{\n\t__raw_writel(val, vrfb_base + SMS_ROT_SIZE(ctx));\n}\n\nstatic void omap2_sms_write_rot_physical_ba(u32 val, unsigned ctx)\n{\n\t__raw_writel(val, vrfb_base + SMS_ROT_PHYSICAL_BA(ctx));\n}\n\nstatic inline void restore_hw_context(int ctx)\n{\n\tomap2_sms_write_rot_control(ctxs[ctx].control, ctx);\n\tomap2_sms_write_rot_size(ctxs[ctx].size, ctx);\n\tomap2_sms_write_rot_physical_ba(ctxs[ctx].physical_ba, ctx);\n}\n\nstatic u32 get_image_width_roundup(u16 width, u8 bytespp)\n{\n\tunsigned long stride = width * bytespp;\n\tunsigned long ceil_pages_per_stride = (stride / VRFB_PAGE_WIDTH) +\n\t\t(stride % VRFB_PAGE_WIDTH != 0);\n\n\treturn ceil_pages_per_stride * VRFB_PAGE_WIDTH / bytespp;\n}\n\n \nstatic inline u32 get_extra_physical_size(u16 image_width_roundup, u8 bytespp)\n{\n\treturn (OMAP_VRFB_LINE_LEN - image_width_roundup) * VRFB_PAGE_HEIGHT *\n\t\tbytespp;\n}\n\nvoid omap_vrfb_restore_context(void)\n{\n\tint i;\n\tunsigned long map = ctx_map;\n\n\tfor (i = ffs(map); i; i = ffs(map)) {\n\t\t \n\t\ti--;\n\t\tmap &= ~(1 << i);\n\t\trestore_hw_context(i);\n\t}\n}\n\nvoid omap_vrfb_adjust_size(u16 *width, u16 *height,\n\t\tu8 bytespp)\n{\n\t*width = ALIGN(*width * bytespp, VRFB_PAGE_WIDTH) / bytespp;\n\t*height = ALIGN(*height, VRFB_PAGE_HEIGHT);\n}\nEXPORT_SYMBOL(omap_vrfb_adjust_size);\n\nu32 omap_vrfb_min_phys_size(u16 width, u16 height, u8 bytespp)\n{\n\tunsigned long image_width_roundup = get_image_width_roundup(width,\n\t\tbytespp);\n\n\tif (image_width_roundup > OMAP_VRFB_LINE_LEN)\n\t\treturn 0;\n\n\treturn (width * height * bytespp) + get_extra_physical_size(\n\t\timage_width_roundup, bytespp);\n}\nEXPORT_SYMBOL(omap_vrfb_min_phys_size);\n\nu16 omap_vrfb_max_height(u32 phys_size, u16 width, u8 bytespp)\n{\n\tunsigned long image_width_roundup = get_image_width_roundup(width,\n\t\tbytespp);\n\tunsigned long height;\n\tunsigned long extra;\n\n\tif (image_width_roundup > OMAP_VRFB_LINE_LEN)\n\t\treturn 0;\n\n\textra = get_extra_physical_size(image_width_roundup, bytespp);\n\n\tif (phys_size < extra)\n\t\treturn 0;\n\n\theight = (phys_size - extra) / (width * bytespp);\n\n\t \n\treturn min_t(unsigned long, height, 2048);\n}\nEXPORT_SYMBOL(omap_vrfb_max_height);\n\nvoid omap_vrfb_setup(struct vrfb *vrfb, unsigned long paddr,\n\t\tu16 width, u16 height,\n\t\tunsigned bytespp, bool yuv_mode)\n{\n\tunsigned pixel_size_exp;\n\tu16 vrfb_width;\n\tu16 vrfb_height;\n\tu8 ctx = vrfb->context;\n\tu32 size;\n\tu32 control;\n\n\tDBG(\"omapfb_set_vrfb(%d, %lx, %dx%d, %d, %d)\\n\", ctx, paddr,\n\t\t\twidth, height, bytespp, yuv_mode);\n\n\t \n\tif (yuv_mode) {\n\t\tbytespp *= 2;\n\t\twidth /= 2;\n\t}\n\n\tif (bytespp == 4)\n\t\tpixel_size_exp = 2;\n\telse if (bytespp == 2)\n\t\tpixel_size_exp = 1;\n\telse {\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tvrfb_width = ALIGN(width * bytespp, VRFB_PAGE_WIDTH) / bytespp;\n\tvrfb_height = ALIGN(height, VRFB_PAGE_HEIGHT);\n\n\tDBG(\"vrfb w %u, h %u bytespp %d\\n\", vrfb_width, vrfb_height, bytespp);\n\n\tsize  = vrfb_width << SMS_IMAGEWIDTH_OFFSET;\n\tsize |= vrfb_height << SMS_IMAGEHEIGHT_OFFSET;\n\n\tcontrol  = pixel_size_exp << SMS_PS_OFFSET;\n\tcontrol |= VRFB_PAGE_WIDTH_EXP  << SMS_PW_OFFSET;\n\tcontrol |= VRFB_PAGE_HEIGHT_EXP << SMS_PH_OFFSET;\n\n\tctxs[ctx].physical_ba = paddr;\n\tctxs[ctx].size = size;\n\tctxs[ctx].control = control;\n\n\tomap2_sms_write_rot_physical_ba(paddr, ctx);\n\tomap2_sms_write_rot_size(size, ctx);\n\tomap2_sms_write_rot_control(control, ctx);\n\n\tDBG(\"vrfb offset pixels %d, %d\\n\",\n\t\t\tvrfb_width - width, vrfb_height - height);\n\n\tvrfb->xres = width;\n\tvrfb->yres = height;\n\tvrfb->xoffset = vrfb_width - width;\n\tvrfb->yoffset = vrfb_height - height;\n\tvrfb->bytespp = bytespp;\n\tvrfb->yuv_mode = yuv_mode;\n}\nEXPORT_SYMBOL(omap_vrfb_setup);\n\nint omap_vrfb_map_angle(struct vrfb *vrfb, u16 height, u8 rot)\n{\n\tunsigned long size = height * OMAP_VRFB_LINE_LEN * vrfb->bytespp;\n\n\tvrfb->vaddr[rot] = ioremap_wc(vrfb->paddr[rot], size);\n\n\tif (!vrfb->vaddr[rot]) {\n\t\tprintk(KERN_ERR \"vrfb: ioremap failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tDBG(\"ioremapped vrfb area %d of size %lu into %p\\n\", rot, size,\n\t\tvrfb->vaddr[rot]);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(omap_vrfb_map_angle);\n\nvoid omap_vrfb_release_ctx(struct vrfb *vrfb)\n{\n\tint rot;\n\tint ctx = vrfb->context;\n\n\tif (ctx == 0xff)\n\t\treturn;\n\n\tDBG(\"release ctx %d\\n\", ctx);\n\n\tmutex_lock(&ctx_lock);\n\n\tBUG_ON(!(ctx_map & (1 << ctx)));\n\n\tclear_bit(ctx, &ctx_map);\n\n\tfor (rot = 0; rot < 4; ++rot) {\n\t\tif (vrfb->paddr[rot]) {\n\t\t\trelease_mem_region(vrfb->paddr[rot], OMAP_VRFB_SIZE);\n\t\t\tvrfb->paddr[rot] = 0;\n\t\t}\n\t}\n\n\tvrfb->context = 0xff;\n\n\tmutex_unlock(&ctx_lock);\n}\nEXPORT_SYMBOL(omap_vrfb_release_ctx);\n\nint omap_vrfb_request_ctx(struct vrfb *vrfb)\n{\n\tint rot;\n\tu32 paddr;\n\tu8 ctx;\n\tint r;\n\n\tDBG(\"request ctx\\n\");\n\n\tmutex_lock(&ctx_lock);\n\n\tfor (ctx = 0; ctx < num_ctxs; ++ctx)\n\t\tif ((ctx_map & (1 << ctx)) == 0)\n\t\t\tbreak;\n\n\tif (ctx == num_ctxs) {\n\t\tpr_err(\"vrfb: no free contexts\\n\");\n\t\tr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tDBG(\"found free ctx %d\\n\", ctx);\n\n\tset_bit(ctx, &ctx_map);\n\n\tmemset(vrfb, 0, sizeof(*vrfb));\n\n\tvrfb->context = ctx;\n\n\tfor (rot = 0; rot < 4; ++rot) {\n\t\tpaddr = ctxs[ctx].base + SMS_ROT_VIRT_BASE(rot);\n\t\tif (!request_mem_region(paddr, OMAP_VRFB_SIZE, \"vrfb\")) {\n\t\t\tpr_err(\"vrfb: failed to reserve VRFB \"\n\t\t\t\t\t\"area for ctx %d, rotation %d\\n\",\n\t\t\t\t\tctx, rot * 90);\n\t\t\tomap_vrfb_release_ctx(vrfb);\n\t\t\tr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tvrfb->paddr[rot] = paddr;\n\n\t\tDBG(\"VRFB %d/%d: %lx\\n\", ctx, rot*90, vrfb->paddr[rot]);\n\t}\n\n\tr = 0;\nout:\n\tmutex_unlock(&ctx_lock);\n\treturn r;\n}\nEXPORT_SYMBOL(omap_vrfb_request_ctx);\n\nbool omap_vrfb_supported(void)\n{\n\treturn vrfb_loaded;\n}\nEXPORT_SYMBOL(omap_vrfb_supported);\n\nstatic int __init vrfb_probe(struct platform_device *pdev)\n{\n\tstruct resource *mem;\n\tint i;\n\n\t \n\tvrfb_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(vrfb_base))\n\t\treturn PTR_ERR(vrfb_base);\n\n\tnum_ctxs = pdev->num_resources - 1;\n\n\tctxs = devm_kcalloc(&pdev->dev,\n\t\t\tnum_ctxs, sizeof(struct vrfb_ctx),\n\t\t\tGFP_KERNEL);\n\n\tif (!ctxs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_ctxs; ++i) {\n\t\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 1 + i);\n\t\tif (!mem) {\n\t\t\tdev_err(&pdev->dev, \"can't get vrfb ctx %d address\\n\",\n\t\t\t\t\ti);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tctxs[i].base = mem->start;\n\t}\n\n\tvrfb_loaded = true;\n\n\treturn 0;\n}\n\nstatic void __exit vrfb_remove(struct platform_device *pdev)\n{\n\tvrfb_loaded = false;\n}\n\nstatic struct platform_driver vrfb_driver = {\n\t.driver.name\t= \"omapvrfb\",\n\t.remove\t\t= __exit_p(vrfb_remove),\n};\n\nmodule_platform_driver_probe(vrfb_driver, vrfb_probe);\n\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ti.com>\");\nMODULE_DESCRIPTION(\"OMAP VRFB\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}