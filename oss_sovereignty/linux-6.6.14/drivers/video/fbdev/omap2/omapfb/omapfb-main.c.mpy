{
  "module_name": "omapfb-main.c",
  "hash_id": "9a89b32daef2e979d40c4ab1e8595e4b212accf69e3e4d7cc9c7acddc379d42c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/omapfb-main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/fb.h>\n#include <linux/dma-mapping.h>\n#include <linux/vmalloc.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/omapfb.h>\n\n#include <video/omapfb_dss.h>\n#include <video/omapvrfb.h>\n\n#include \"omapfb.h\"\n\n#define MODULE_NAME     \"omapfb\"\n\n#define OMAPFB_PLANE_XRES_MIN\t\t8\n#define OMAPFB_PLANE_YRES_MIN\t\t8\n\nstatic char *def_mode;\nstatic char *def_vram;\nstatic bool def_vrfb;\nstatic int def_rotate;\nstatic bool def_mirror;\nstatic bool auto_update;\nstatic unsigned int auto_update_freq;\nmodule_param(auto_update, bool, 0);\nmodule_param(auto_update_freq, uint, 0644);\n\n#ifdef DEBUG\nbool omapfb_debug;\nmodule_param_named(debug, omapfb_debug, bool, 0644);\nstatic bool omapfb_test_pattern;\nmodule_param_named(test, omapfb_test_pattern, bool, 0644);\n#endif\n\nstatic int omapfb_fb_init(struct omapfb2_device *fbdev, struct fb_info *fbi);\nstatic int omapfb_get_recommended_bpp(struct omapfb2_device *fbdev,\n\t\tstruct omap_dss_device *dssdev);\n\n#ifdef DEBUG\nstatic void draw_pixel(struct fb_info *fbi, int x, int y, unsigned color)\n{\n\tstruct fb_var_screeninfo *var = &fbi->var;\n\tstruct fb_fix_screeninfo *fix = &fbi->fix;\n\tvoid __iomem *addr = fbi->screen_base;\n\tconst unsigned bytespp = var->bits_per_pixel >> 3;\n\tconst unsigned line_len = fix->line_length / bytespp;\n\n\tint r = (color >> 16) & 0xff;\n\tint g = (color >> 8) & 0xff;\n\tint b = (color >> 0) & 0xff;\n\n\tif (var->bits_per_pixel == 16) {\n\t\tu16 __iomem *p = (u16 __iomem *)addr;\n\t\tp += y * line_len + x;\n\n\t\tr = r * 32 / 256;\n\t\tg = g * 64 / 256;\n\t\tb = b * 32 / 256;\n\n\t\t__raw_writew((r << 11) | (g << 5) | (b << 0), p);\n\t} else if (var->bits_per_pixel == 24) {\n\t\tu8 __iomem *p = (u8 __iomem *)addr;\n\t\tp += (y * line_len + x) * 3;\n\n\t\t__raw_writeb(b, p + 0);\n\t\t__raw_writeb(g, p + 1);\n\t\t__raw_writeb(r, p + 2);\n\t} else if (var->bits_per_pixel == 32) {\n\t\tu32 __iomem *p = (u32 __iomem *)addr;\n\t\tp += y * line_len + x;\n\t\t__raw_writel(color, p);\n\t}\n}\n\nstatic void fill_fb(struct fb_info *fbi)\n{\n\tstruct fb_var_screeninfo *var = &fbi->var;\n\tconst short w = var->xres_virtual;\n\tconst short h = var->yres_virtual;\n\tvoid __iomem *addr = fbi->screen_base;\n\tint y, x;\n\n\tif (!addr)\n\t\treturn;\n\n\tDBG(\"fill_fb %dx%d, line_len %d bytes\\n\", w, h, fbi->fix.line_length);\n\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tif (x < 20 && y < 20)\n\t\t\t\tdraw_pixel(fbi, x, y, 0xffffff);\n\t\t\telse if (x < 20 && (y > 20 && y < h - 20))\n\t\t\t\tdraw_pixel(fbi, x, y, 0xff);\n\t\t\telse if (y < 20 && (x > 20 && x < w - 20))\n\t\t\t\tdraw_pixel(fbi, x, y, 0xff00);\n\t\t\telse if (x > w - 20 && (y > 20 && y < h - 20))\n\t\t\t\tdraw_pixel(fbi, x, y, 0xff0000);\n\t\t\telse if (y > h - 20 && (x > 20 && x < w - 20))\n\t\t\t\tdraw_pixel(fbi, x, y, 0xffff00);\n\t\t\telse if (x == 20 || x == w - 20 ||\n\t\t\t\t\ty == 20 || y == h - 20)\n\t\t\t\tdraw_pixel(fbi, x, y, 0xffffff);\n\t\t\telse if (x == y || w - x == h - y)\n\t\t\t\tdraw_pixel(fbi, x, y, 0xff00ff);\n\t\t\telse if (w - x == y || x == h - y)\n\t\t\t\tdraw_pixel(fbi, x, y, 0x00ffff);\n\t\t\telse if (x > 20 && y > 20 && x < w - 20 && y < h - 20) {\n\t\t\t\tint t = x * 3 / w;\n\t\t\t\tunsigned r = 0, g = 0, b = 0;\n\t\t\t\tunsigned c;\n\t\t\t\tif (var->bits_per_pixel == 16) {\n\t\t\t\t\tif (t == 0)\n\t\t\t\t\t\tb = (y % 32) * 256 / 32;\n\t\t\t\t\telse if (t == 1)\n\t\t\t\t\t\tg = (y % 64) * 256 / 64;\n\t\t\t\t\telse if (t == 2)\n\t\t\t\t\t\tr = (y % 32) * 256 / 32;\n\t\t\t\t} else {\n\t\t\t\t\tif (t == 0)\n\t\t\t\t\t\tb = (y % 256);\n\t\t\t\t\telse if (t == 1)\n\t\t\t\t\t\tg = (y % 256);\n\t\t\t\t\telse if (t == 2)\n\t\t\t\t\t\tr = (y % 256);\n\t\t\t\t}\n\t\t\t\tc = (r << 16) | (g << 8) | (b << 0);\n\t\t\t\tdraw_pixel(fbi, x, y, c);\n\t\t\t} else {\n\t\t\t\tdraw_pixel(fbi, x, y, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n#endif\n\nstatic unsigned omapfb_get_vrfb_offset(const struct omapfb_info *ofbi, int rot)\n{\n\tconst struct vrfb *vrfb = &ofbi->region->vrfb;\n\tunsigned offset;\n\n\tswitch (rot) {\n\tcase FB_ROTATE_UR:\n\t\toffset = 0;\n\t\tbreak;\n\tcase FB_ROTATE_CW:\n\t\toffset = vrfb->yoffset;\n\t\tbreak;\n\tcase FB_ROTATE_UD:\n\t\toffset = vrfb->yoffset * OMAP_VRFB_LINE_LEN + vrfb->xoffset;\n\t\tbreak;\n\tcase FB_ROTATE_CCW:\n\t\toffset = vrfb->xoffset * OMAP_VRFB_LINE_LEN;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\toffset *= vrfb->bytespp;\n\n\treturn offset;\n}\n\nstatic u32 omapfb_get_region_rot_paddr(const struct omapfb_info *ofbi, int rot)\n{\n\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\n\t\treturn ofbi->region->vrfb.paddr[rot]\n\t\t\t+ omapfb_get_vrfb_offset(ofbi, rot);\n\t} else {\n\t\treturn ofbi->region->paddr;\n\t}\n}\n\nstatic u32 omapfb_get_region_paddr(const struct omapfb_info *ofbi)\n{\n\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)\n\t\treturn ofbi->region->vrfb.paddr[0];\n\telse\n\t\treturn ofbi->region->paddr;\n}\n\nstatic void __iomem *omapfb_get_region_vaddr(const struct omapfb_info *ofbi)\n{\n\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)\n\t\treturn ofbi->region->vrfb.vaddr[0];\n\telse\n\t\treturn ofbi->region->vaddr;\n}\n\nstatic struct omapfb_colormode omapfb_colormodes[] = {\n\t{\n\t\t.dssmode = OMAP_DSS_COLOR_UYVY,\n\t\t.bits_per_pixel = 16,\n\t\t.nonstd = OMAPFB_COLOR_YUV422,\n\t}, {\n\t\t.dssmode = OMAP_DSS_COLOR_YUV2,\n\t\t.bits_per_pixel = 16,\n\t\t.nonstd = OMAPFB_COLOR_YUY422,\n\t}, {\n\t\t.dssmode = OMAP_DSS_COLOR_ARGB16,\n\t\t.bits_per_pixel = 16,\n\t\t.red\t= { .length = 4, .offset = 8, .msb_right = 0 },\n\t\t.green\t= { .length = 4, .offset = 4, .msb_right = 0 },\n\t\t.blue\t= { .length = 4, .offset = 0, .msb_right = 0 },\n\t\t.transp\t= { .length = 4, .offset = 12, .msb_right = 0 },\n\t}, {\n\t\t.dssmode = OMAP_DSS_COLOR_RGB16,\n\t\t.bits_per_pixel = 16,\n\t\t.red\t= { .length = 5, .offset = 11, .msb_right = 0 },\n\t\t.green\t= { .length = 6, .offset = 5, .msb_right = 0 },\n\t\t.blue\t= { .length = 5, .offset = 0, .msb_right = 0 },\n\t\t.transp\t= { .length = 0, .offset = 0, .msb_right = 0 },\n\t}, {\n\t\t.dssmode = OMAP_DSS_COLOR_RGB24P,\n\t\t.bits_per_pixel = 24,\n\t\t.red\t= { .length = 8, .offset = 16, .msb_right = 0 },\n\t\t.green\t= { .length = 8, .offset = 8, .msb_right = 0 },\n\t\t.blue\t= { .length = 8, .offset = 0, .msb_right = 0 },\n\t\t.transp\t= { .length = 0, .offset = 0, .msb_right = 0 },\n\t}, {\n\t\t.dssmode = OMAP_DSS_COLOR_RGB24U,\n\t\t.bits_per_pixel = 32,\n\t\t.red\t= { .length = 8, .offset = 16, .msb_right = 0 },\n\t\t.green\t= { .length = 8, .offset = 8, .msb_right = 0 },\n\t\t.blue\t= { .length = 8, .offset = 0, .msb_right = 0 },\n\t\t.transp\t= { .length = 0, .offset = 0, .msb_right = 0 },\n\t}, {\n\t\t.dssmode = OMAP_DSS_COLOR_ARGB32,\n\t\t.bits_per_pixel = 32,\n\t\t.red\t= { .length = 8, .offset = 16, .msb_right = 0 },\n\t\t.green\t= { .length = 8, .offset = 8, .msb_right = 0 },\n\t\t.blue\t= { .length = 8, .offset = 0, .msb_right = 0 },\n\t\t.transp\t= { .length = 8, .offset = 24, .msb_right = 0 },\n\t}, {\n\t\t.dssmode = OMAP_DSS_COLOR_RGBA32,\n\t\t.bits_per_pixel = 32,\n\t\t.red\t= { .length = 8, .offset = 24, .msb_right = 0 },\n\t\t.green\t= { .length = 8, .offset = 16, .msb_right = 0 },\n\t\t.blue\t= { .length = 8, .offset = 8, .msb_right = 0 },\n\t\t.transp\t= { .length = 8, .offset = 0, .msb_right = 0 },\n\t}, {\n\t\t.dssmode = OMAP_DSS_COLOR_RGBX32,\n\t\t.bits_per_pixel = 32,\n\t\t.red\t= { .length = 8, .offset = 24, .msb_right = 0 },\n\t\t.green\t= { .length = 8, .offset = 16, .msb_right = 0 },\n\t\t.blue\t= { .length = 8, .offset = 8, .msb_right = 0 },\n\t\t.transp\t= { .length = 0, .offset = 0, .msb_right = 0 },\n\t},\n};\n\nstatic bool cmp_component(struct fb_bitfield *f1, struct fb_bitfield *f2)\n{\n\treturn f1->length == f2->length &&\n\t\tf1->offset == f2->offset &&\n\t\tf1->msb_right == f2->msb_right;\n}\n\nstatic bool cmp_var_to_colormode(struct fb_var_screeninfo *var,\n\t\tstruct omapfb_colormode *color)\n{\n\tif (var->bits_per_pixel == 0 ||\n\t\t\tvar->red.length == 0 ||\n\t\t\tvar->blue.length == 0 ||\n\t\t\tvar->green.length == 0)\n\t\treturn false;\n\n\treturn var->bits_per_pixel == color->bits_per_pixel &&\n\t\tcmp_component(&var->red, &color->red) &&\n\t\tcmp_component(&var->green, &color->green) &&\n\t\tcmp_component(&var->blue, &color->blue) &&\n\t\tcmp_component(&var->transp, &color->transp);\n}\n\nstatic void assign_colormode_to_var(struct fb_var_screeninfo *var,\n\t\tstruct omapfb_colormode *color)\n{\n\tvar->bits_per_pixel = color->bits_per_pixel;\n\tvar->nonstd = color->nonstd;\n\tvar->red = color->red;\n\tvar->green = color->green;\n\tvar->blue = color->blue;\n\tvar->transp = color->transp;\n}\n\nstatic int fb_mode_to_dss_mode(struct fb_var_screeninfo *var,\n\t\tenum omap_color_mode *mode)\n{\n\tenum omap_color_mode dssmode;\n\tint i;\n\n\t \n\tif (var->nonstd) {\n\t\tfor (i = 0; i < ARRAY_SIZE(omapfb_colormodes); ++i) {\n\t\t\tstruct omapfb_colormode *m = &omapfb_colormodes[i];\n\t\t\tif (var->nonstd == m->nonstd) {\n\t\t\t\tassign_colormode_to_var(var, m);\n\t\t\t\t*mode = m->dssmode;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(omapfb_colormodes); ++i) {\n\t\tstruct omapfb_colormode *m = &omapfb_colormodes[i];\n\t\tif (cmp_var_to_colormode(var, m)) {\n\t\t\tassign_colormode_to_var(var, m);\n\t\t\t*mode = m->dssmode;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tswitch (var->bits_per_pixel) {\n\tcase 1:\n\t\tdssmode = OMAP_DSS_COLOR_CLUT1;\n\t\tbreak;\n\tcase 2:\n\t\tdssmode = OMAP_DSS_COLOR_CLUT2;\n\t\tbreak;\n\tcase 4:\n\t\tdssmode = OMAP_DSS_COLOR_CLUT4;\n\t\tbreak;\n\tcase 8:\n\t\tdssmode = OMAP_DSS_COLOR_CLUT8;\n\t\tbreak;\n\tcase 12:\n\t\tdssmode = OMAP_DSS_COLOR_RGB12U;\n\t\tbreak;\n\tcase 16:\n\t\tdssmode = OMAP_DSS_COLOR_RGB16;\n\t\tbreak;\n\tcase 24:\n\t\tdssmode = OMAP_DSS_COLOR_RGB24P;\n\t\tbreak;\n\tcase 32:\n\t\tdssmode = OMAP_DSS_COLOR_RGB24U;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(omapfb_colormodes); ++i) {\n\t\tstruct omapfb_colormode *m = &omapfb_colormodes[i];\n\t\tif (dssmode == m->dssmode) {\n\t\t\tassign_colormode_to_var(var, m);\n\t\t\t*mode = m->dssmode;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int check_fb_res_bounds(struct fb_var_screeninfo *var)\n{\n\tint xres_min = OMAPFB_PLANE_XRES_MIN;\n\tint xres_max = 2048;\n\tint yres_min = OMAPFB_PLANE_YRES_MIN;\n\tint yres_max = 2048;\n\n\t \n\tif (var->xres_virtual == 0)\n\t\tvar->xres_virtual = var->xres;\n\n\tif (var->yres_virtual == 0)\n\t\tvar->yres_virtual = var->yres;\n\n\tif (var->xres_virtual < xres_min || var->yres_virtual < yres_min)\n\t\treturn -EINVAL;\n\n\tif (var->xres < xres_min)\n\t\tvar->xres = xres_min;\n\tif (var->yres < yres_min)\n\t\tvar->yres = yres_min;\n\tif (var->xres > xres_max)\n\t\tvar->xres = xres_max;\n\tif (var->yres > yres_max)\n\t\tvar->yres = yres_max;\n\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres = var->xres_virtual;\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres = var->yres_virtual;\n\n\treturn 0;\n}\n\nstatic void shrink_height(unsigned long max_frame_size,\n\t\tstruct fb_var_screeninfo *var)\n{\n\tDBG(\"can't fit FB into memory, reducing y\\n\");\n\tvar->yres_virtual = max_frame_size /\n\t\t(var->xres_virtual * var->bits_per_pixel >> 3);\n\n\tif (var->yres_virtual < OMAPFB_PLANE_YRES_MIN)\n\t\tvar->yres_virtual = OMAPFB_PLANE_YRES_MIN;\n\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres = var->yres_virtual;\n}\n\nstatic void shrink_width(unsigned long max_frame_size,\n\t\tstruct fb_var_screeninfo *var)\n{\n\tDBG(\"can't fit FB into memory, reducing x\\n\");\n\tvar->xres_virtual = max_frame_size / var->yres_virtual /\n\t\t(var->bits_per_pixel >> 3);\n\n\tif (var->xres_virtual < OMAPFB_PLANE_XRES_MIN)\n\t\tvar->xres_virtual = OMAPFB_PLANE_XRES_MIN;\n\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres = var->xres_virtual;\n}\n\nstatic int check_vrfb_fb_size(unsigned long region_size,\n\t\tconst struct fb_var_screeninfo *var)\n{\n\tunsigned long min_phys_size = omap_vrfb_min_phys_size(var->xres_virtual,\n\t\tvar->yres_virtual, var->bits_per_pixel >> 3);\n\n\treturn min_phys_size > region_size ? -EINVAL : 0;\n}\n\nstatic int check_fb_size(const struct omapfb_info *ofbi,\n\t\tstruct fb_var_screeninfo *var)\n{\n\tunsigned long max_frame_size = ofbi->region->size;\n\tint bytespp = var->bits_per_pixel >> 3;\n\tunsigned long line_size = var->xres_virtual * bytespp;\n\n\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\n\t\t \n\t\tif (check_vrfb_fb_size(max_frame_size, var))\n\t\t\tshrink_height(omap_vrfb_max_height(\n\t\t\t\tmax_frame_size, var->xres_virtual, bytespp) *\n\t\t\t\tline_size, var);\n\n\t\tif (check_vrfb_fb_size(max_frame_size, var)) {\n\t\t\tDBG(\"cannot fit FB to memory\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tDBG(\"max frame size %lu, line size %lu\\n\", max_frame_size, line_size);\n\n\tif (line_size * var->yres_virtual > max_frame_size)\n\t\tshrink_height(max_frame_size, var);\n\n\tif (line_size * var->yres_virtual > max_frame_size) {\n\t\tshrink_width(max_frame_size, var);\n\t\tline_size = var->xres_virtual * bytespp;\n\t}\n\n\tif (line_size * var->yres_virtual > max_frame_size) {\n\t\tDBG(\"cannot fit FB to memory\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int setup_vrfb_rotation(struct fb_info *fbi)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_mem_region *rg = ofbi->region;\n\tstruct vrfb *vrfb = &rg->vrfb;\n\tstruct fb_var_screeninfo *var = &fbi->var;\n\tstruct fb_fix_screeninfo *fix = &fbi->fix;\n\tunsigned bytespp;\n\tbool yuv_mode;\n\tenum omap_color_mode mode;\n\tint r;\n\tbool reconf;\n\n\tif (!rg->size || ofbi->rotation_type != OMAP_DSS_ROT_VRFB)\n\t\treturn 0;\n\n\tDBG(\"setup_vrfb_rotation\\n\");\n\n\tr = fb_mode_to_dss_mode(var, &mode);\n\tif (r)\n\t\treturn r;\n\n\tbytespp = var->bits_per_pixel >> 3;\n\n\tyuv_mode = mode == OMAP_DSS_COLOR_YUV2 || mode == OMAP_DSS_COLOR_UYVY;\n\n\t \n\n\t \n\n\treconf = false;\n\n\tif (yuv_mode != vrfb->yuv_mode)\n\t\treconf = true;\n\telse if (bytespp != vrfb->bytespp)\n\t\treconf = true;\n\telse if (vrfb->xres != var->xres_virtual ||\n\t\t\tvrfb->yres != var->yres_virtual)\n\t\treconf = true;\n\n\tif (vrfb->vaddr[0] && reconf) {\n\t\tfbi->screen_base = NULL;\n\t\tfix->smem_start = 0;\n\t\tfix->smem_len = 0;\n\t\tiounmap(vrfb->vaddr[0]);\n\t\tvrfb->vaddr[0] = NULL;\n\t\tDBG(\"setup_vrfb_rotation: reset fb\\n\");\n\t}\n\n\tif (vrfb->vaddr[0])\n\t\treturn 0;\n\n\tomap_vrfb_setup(&rg->vrfb, rg->paddr,\n\t\t\tvar->xres_virtual,\n\t\t\tvar->yres_virtual,\n\t\t\tbytespp, yuv_mode);\n\n\t \n\tr = omap_vrfb_map_angle(vrfb, var->yres_virtual, 0);\n\tif (r)\n\t\treturn r;\n\n\t \n\tfbi->screen_base = ofbi->region->vrfb.vaddr[0];\n\n\tfix->smem_start = ofbi->region->vrfb.paddr[0];\n\n\tswitch (var->nonstd) {\n\tcase OMAPFB_COLOR_YUV422:\n\tcase OMAPFB_COLOR_YUY422:\n\t\tfix->line_length =\n\t\t\t(OMAP_VRFB_LINE_LEN * var->bits_per_pixel) >> 2;\n\t\tbreak;\n\tdefault:\n\t\tfix->line_length =\n\t\t\t(OMAP_VRFB_LINE_LEN * var->bits_per_pixel) >> 3;\n\t\tbreak;\n\t}\n\n\tfix->smem_len = var->yres_virtual * fix->line_length;\n\n\treturn 0;\n}\n\nint dss_mode_to_fb_mode(enum omap_color_mode dssmode,\n\t\t\tstruct fb_var_screeninfo *var)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(omapfb_colormodes); ++i) {\n\t\tstruct omapfb_colormode *mode = &omapfb_colormodes[i];\n\t\tif (dssmode == mode->dssmode) {\n\t\t\tassign_colormode_to_var(var, mode);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\nvoid set_fb_fix(struct fb_info *fbi)\n{\n\tstruct fb_fix_screeninfo *fix = &fbi->fix;\n\tstruct fb_var_screeninfo *var = &fbi->var;\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_mem_region *rg = ofbi->region;\n\n\tDBG(\"set_fb_fix\\n\");\n\n\t \n\tfbi->screen_base = (char __iomem *)omapfb_get_region_vaddr(ofbi);\n\n\t \n\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\n\t\tswitch (var->nonstd) {\n\t\tcase OMAPFB_COLOR_YUV422:\n\t\tcase OMAPFB_COLOR_YUY422:\n\t\t\tfix->line_length =\n\t\t\t\t(OMAP_VRFB_LINE_LEN * var->bits_per_pixel) >> 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfix->line_length =\n\t\t\t\t(OMAP_VRFB_LINE_LEN * var->bits_per_pixel) >> 3;\n\t\t\tbreak;\n\t\t}\n\n\t\tfix->smem_len = var->yres_virtual * fix->line_length;\n\t} else {\n\t\tfix->line_length =\n\t\t\t(var->xres_virtual * var->bits_per_pixel) >> 3;\n\t\tfix->smem_len = rg->size;\n\t}\n\n\tfix->smem_start = omapfb_get_region_paddr(ofbi);\n\n\tfix->type = FB_TYPE_PACKED_PIXELS;\n\n\tif (var->nonstd)\n\t\tfix->visual = FB_VISUAL_PSEUDOCOLOR;\n\telse {\n\t\tswitch (var->bits_per_pixel) {\n\t\tcase 32:\n\t\tcase 24:\n\t\tcase 16:\n\t\tcase 12:\n\t\t\tfix->visual = FB_VISUAL_TRUECOLOR;\n\t\t\t \n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tfix->visual = FB_VISUAL_PSEUDOCOLOR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfix->accel = FB_ACCEL_NONE;\n\n\tfix->xpanstep = 1;\n\tfix->ypanstep = 1;\n}\n\n \nint check_fb_var(struct fb_info *fbi, struct fb_var_screeninfo *var)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omap_dss_device *display = fb2display(fbi);\n\tenum omap_color_mode mode = 0;\n\tint i;\n\tint r;\n\n\tDBG(\"check_fb_var %d\\n\", ofbi->id);\n\n\tWARN_ON(!atomic_read(&ofbi->region->lock_count));\n\n\tr = fb_mode_to_dss_mode(var, &mode);\n\tif (r) {\n\t\tDBG(\"cannot convert var to omap dss mode\\n\");\n\t\treturn r;\n\t}\n\n\tfor (i = 0; i < ofbi->num_overlays; ++i) {\n\t\tif ((ofbi->overlays[i]->supported_modes & mode) == 0) {\n\t\t\tDBG(\"invalid mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (var->rotate > 3)\n\t\treturn -EINVAL;\n\n\tif (check_fb_res_bounds(var))\n\t\treturn -EINVAL;\n\n\t \n\tif (ofbi->region->size != 0 && check_fb_size(ofbi, var))\n\t\treturn -EINVAL;\n\n\tif (var->xres + var->xoffset > var->xres_virtual)\n\t\tvar->xoffset = var->xres_virtual - var->xres;\n\tif (var->yres + var->yoffset > var->yres_virtual)\n\t\tvar->yoffset = var->yres_virtual - var->yres;\n\n\tDBG(\"xres = %d, yres = %d, vxres = %d, vyres = %d\\n\",\n\t\t\tvar->xres, var->yres,\n\t\t\tvar->xres_virtual, var->yres_virtual);\n\n\tif (display && display->driver->get_dimensions) {\n\t\tu32 w, h;\n\t\tdisplay->driver->get_dimensions(display, &w, &h);\n\t\tvar->width = DIV_ROUND_CLOSEST(w, 1000);\n\t\tvar->height = DIV_ROUND_CLOSEST(h, 1000);\n\t} else {\n\t\tvar->height = -1;\n\t\tvar->width = -1;\n\t}\n\n\tvar->grayscale          = 0;\n\n\tif (display && display->driver->get_timings) {\n\t\tstruct omap_video_timings timings;\n\t\tdisplay->driver->get_timings(display, &timings);\n\n\t\t \n\t\tvar->pixclock = timings.pixelclock != 0 ?\n\t\t\tKHZ2PICOS(timings.pixelclock / 1000) :\n\t\t\t0;\n\t\tvar->left_margin = timings.hbp;\n\t\tvar->right_margin = timings.hfp;\n\t\tvar->upper_margin = timings.vbp;\n\t\tvar->lower_margin = timings.vfp;\n\t\tvar->hsync_len = timings.hsw;\n\t\tvar->vsync_len = timings.vsw;\n\t\tvar->sync |= timings.hsync_level == OMAPDSS_SIG_ACTIVE_HIGH ?\n\t\t\t\tFB_SYNC_HOR_HIGH_ACT : 0;\n\t\tvar->sync |= timings.vsync_level == OMAPDSS_SIG_ACTIVE_HIGH ?\n\t\t\t\tFB_SYNC_VERT_HIGH_ACT : 0;\n\t\tvar->vmode = timings.interlace ?\n\t\t\t\tFB_VMODE_INTERLACED : FB_VMODE_NONINTERLACED;\n\t} else {\n\t\tvar->pixclock = 0;\n\t\tvar->left_margin = 0;\n\t\tvar->right_margin = 0;\n\t\tvar->upper_margin = 0;\n\t\tvar->lower_margin = 0;\n\t\tvar->hsync_len = 0;\n\t\tvar->vsync_len = 0;\n\t\tvar->sync = 0;\n\t\tvar->vmode = FB_VMODE_NONINTERLACED;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int omapfb_open(struct fb_info *fbi, int user)\n{\n\treturn 0;\n}\n\nstatic int omapfb_release(struct fb_info *fbi, int user)\n{\n\treturn 0;\n}\n\nstatic unsigned calc_rotation_offset_dma(const struct fb_var_screeninfo *var,\n\t\tconst struct fb_fix_screeninfo *fix, int rotation)\n{\n\tunsigned offset;\n\n\toffset = var->yoffset * fix->line_length +\n\t\tvar->xoffset * (var->bits_per_pixel >> 3);\n\n\treturn offset;\n}\n\nstatic unsigned calc_rotation_offset_vrfb(const struct fb_var_screeninfo *var,\n\t\tconst struct fb_fix_screeninfo *fix, int rotation)\n{\n\tunsigned offset;\n\n\tif (rotation == FB_ROTATE_UD)\n\t\toffset = (var->yres_virtual - var->yres) *\n\t\t\tfix->line_length;\n\telse if (rotation == FB_ROTATE_CW)\n\t\toffset = (var->yres_virtual - var->yres) *\n\t\t\t(var->bits_per_pixel >> 3);\n\telse\n\t\toffset = 0;\n\n\tif (rotation == FB_ROTATE_UR)\n\t\toffset += var->yoffset * fix->line_length +\n\t\t\tvar->xoffset * (var->bits_per_pixel >> 3);\n\telse if (rotation == FB_ROTATE_UD)\n\t\toffset -= var->yoffset * fix->line_length +\n\t\t\tvar->xoffset * (var->bits_per_pixel >> 3);\n\telse if (rotation == FB_ROTATE_CW)\n\t\toffset -= var->xoffset * fix->line_length +\n\t\t\tvar->yoffset * (var->bits_per_pixel >> 3);\n\telse if (rotation == FB_ROTATE_CCW)\n\t\toffset += var->xoffset * fix->line_length +\n\t\t\tvar->yoffset * (var->bits_per_pixel >> 3);\n\n\treturn offset;\n}\n\nstatic void omapfb_calc_addr(const struct omapfb_info *ofbi,\n\t\t\t     const struct fb_var_screeninfo *var,\n\t\t\t     const struct fb_fix_screeninfo *fix,\n\t\t\t     int rotation, u32 *paddr)\n{\n\tu32 data_start_p;\n\tint offset;\n\n\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)\n\t\tdata_start_p = omapfb_get_region_rot_paddr(ofbi, rotation);\n\telse\n\t\tdata_start_p = omapfb_get_region_paddr(ofbi);\n\n\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)\n\t\toffset = calc_rotation_offset_vrfb(var, fix, rotation);\n\telse\n\t\toffset = calc_rotation_offset_dma(var, fix, rotation);\n\n\tdata_start_p += offset;\n\n\tif (offset)\n\t\tDBG(\"offset %d, %d = %d\\n\",\n\t\t    var->xoffset, var->yoffset, offset);\n\n\tDBG(\"paddr %x\\n\", data_start_p);\n\n\t*paddr = data_start_p;\n}\n\n \nint omapfb_setup_overlay(struct fb_info *fbi, struct omap_overlay *ovl,\n\t\tu16 posx, u16 posy, u16 outw, u16 outh)\n{\n\tint r = 0;\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct fb_var_screeninfo *var = &fbi->var;\n\tstruct fb_fix_screeninfo *fix = &fbi->fix;\n\tenum omap_color_mode mode = 0;\n\tu32 data_start_p = 0;\n\tstruct omap_overlay_info info;\n\tint xres, yres;\n\tint screen_width;\n\tint mirror;\n\tint rotation = var->rotate;\n\tint i;\n\n\tWARN_ON(!atomic_read(&ofbi->region->lock_count));\n\n\tfor (i = 0; i < ofbi->num_overlays; i++) {\n\t\tif (ovl != ofbi->overlays[i])\n\t\t\tcontinue;\n\n\t\trotation = (rotation + ofbi->rotation[i]) % 4;\n\t\tbreak;\n\t}\n\n\tDBG(\"setup_overlay %d, posx %d, posy %d, outw %d, outh %d\\n\", ofbi->id,\n\t\t\tposx, posy, outw, outh);\n\n\tif (rotation == FB_ROTATE_CW || rotation == FB_ROTATE_CCW) {\n\t\txres = var->yres;\n\t\tyres = var->xres;\n\t} else {\n\t\txres = var->xres;\n\t\tyres = var->yres;\n\t}\n\n\tif (ofbi->region->size)\n\t\tomapfb_calc_addr(ofbi, var, fix, rotation, &data_start_p);\n\n\tr = fb_mode_to_dss_mode(var, &mode);\n\tif (r) {\n\t\tDBG(\"fb_mode_to_dss_mode failed\");\n\t\tgoto err;\n\t}\n\n\tswitch (var->nonstd) {\n\tcase OMAPFB_COLOR_YUV422:\n\tcase OMAPFB_COLOR_YUY422:\n\t\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\n\t\t\tscreen_width = fix->line_length\n\t\t\t\t/ (var->bits_per_pixel >> 2);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tscreen_width = fix->line_length / (var->bits_per_pixel >> 3);\n\t\tbreak;\n\t}\n\n\tovl->get_overlay_info(ovl, &info);\n\n\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)\n\t\tmirror = 0;\n\telse\n\t\tmirror = ofbi->mirror;\n\n\tinfo.paddr = data_start_p;\n\tinfo.screen_width = screen_width;\n\tinfo.width = xres;\n\tinfo.height = yres;\n\tinfo.color_mode = mode;\n\tinfo.rotation_type = ofbi->rotation_type;\n\tinfo.rotation = rotation;\n\tinfo.mirror = mirror;\n\n\tinfo.pos_x = posx;\n\tinfo.pos_y = posy;\n\tinfo.out_width = outw;\n\tinfo.out_height = outh;\n\n\tr = ovl->set_overlay_info(ovl, &info);\n\tif (r) {\n\t\tDBG(\"ovl->setup_overlay_info failed\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tDBG(\"setup_overlay failed\\n\");\n\treturn r;\n}\n\n \nint omapfb_apply_changes(struct fb_info *fbi, int init)\n{\n\tint r = 0;\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct fb_var_screeninfo *var = &fbi->var;\n\tstruct omap_overlay *ovl;\n\tu16 posx, posy;\n\tu16 outw, outh;\n\tint i;\n\n#ifdef DEBUG\n\tif (omapfb_test_pattern)\n\t\tfill_fb(fbi);\n#endif\n\n\tWARN_ON(!atomic_read(&ofbi->region->lock_count));\n\n\tfor (i = 0; i < ofbi->num_overlays; i++) {\n\t\tovl = ofbi->overlays[i];\n\n\t\tDBG(\"apply_changes, fb %d, ovl %d\\n\", ofbi->id, ovl->id);\n\n\t\tif (ofbi->region->size == 0) {\n\t\t\t \n\t\t\tomapfb_overlay_enable(ovl, 0);\n\t\t\tif (!init && ovl->manager)\n\t\t\t\tovl->manager->apply(ovl->manager);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (init || (ovl->caps & OMAP_DSS_OVL_CAP_SCALE) == 0) {\n\t\t\tint rotation = (var->rotate + ofbi->rotation[i]) % 4;\n\t\t\tif (rotation == FB_ROTATE_CW ||\n\t\t\t\t\trotation == FB_ROTATE_CCW) {\n\t\t\t\toutw = var->yres;\n\t\t\t\touth = var->xres;\n\t\t\t} else {\n\t\t\t\toutw = var->xres;\n\t\t\t\touth = var->yres;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct omap_overlay_info info;\n\t\t\tovl->get_overlay_info(ovl, &info);\n\t\t\toutw = info.out_width;\n\t\t\touth = info.out_height;\n\t\t}\n\n\t\tif (init) {\n\t\t\tposx = 0;\n\t\t\tposy = 0;\n\t\t} else {\n\t\t\tstruct omap_overlay_info info;\n\t\t\tovl->get_overlay_info(ovl, &info);\n\t\t\tposx = info.pos_x;\n\t\t\tposy = info.pos_y;\n\t\t}\n\n\t\tr = omapfb_setup_overlay(fbi, ovl, posx, posy, outw, outh);\n\t\tif (r)\n\t\t\tgoto err;\n\n\t\tif (!init && ovl->manager)\n\t\t\tovl->manager->apply(ovl->manager);\n\t}\n\treturn 0;\nerr:\n\tDBG(\"apply_changes failed\\n\");\n\treturn r;\n}\n\n \nstatic int omapfb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tint r;\n\n\tDBG(\"check_var(%d)\\n\", FB2OFB(fbi)->id);\n\n\tomapfb_get_mem_region(ofbi->region);\n\n\tr = check_fb_var(fbi, var);\n\n\tomapfb_put_mem_region(ofbi->region);\n\n\treturn r;\n}\n\n \nstatic int omapfb_set_par(struct fb_info *fbi)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tint r;\n\n\tDBG(\"set_par(%d)\\n\", FB2OFB(fbi)->id);\n\n\tomapfb_get_mem_region(ofbi->region);\n\n\tset_fb_fix(fbi);\n\n\tr = setup_vrfb_rotation(fbi);\n\tif (r)\n\t\tgoto out;\n\n\tr = omapfb_apply_changes(fbi, 0);\n\n out:\n\tomapfb_put_mem_region(ofbi->region);\n\n\treturn r;\n}\n\nstatic int omapfb_pan_display(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *fbi)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct fb_var_screeninfo new_var;\n\tint r;\n\n\tDBG(\"pan_display(%d)\\n\", FB2OFB(fbi)->id);\n\n\tif (var->xoffset == fbi->var.xoffset &&\n\t    var->yoffset == fbi->var.yoffset)\n\t\treturn 0;\n\n\tnew_var = fbi->var;\n\tnew_var.xoffset = var->xoffset;\n\tnew_var.yoffset = var->yoffset;\n\n\tfbi->var = new_var;\n\n\tomapfb_get_mem_region(ofbi->region);\n\n\tr = omapfb_apply_changes(fbi, 0);\n\n\tomapfb_put_mem_region(ofbi->region);\n\n\treturn r;\n}\n\nstatic void mmap_user_open(struct vm_area_struct *vma)\n{\n\tstruct omapfb2_mem_region *rg = vma->vm_private_data;\n\n\tomapfb_get_mem_region(rg);\n\tatomic_inc(&rg->map_count);\n\tomapfb_put_mem_region(rg);\n}\n\nstatic void mmap_user_close(struct vm_area_struct *vma)\n{\n\tstruct omapfb2_mem_region *rg = vma->vm_private_data;\n\n\tomapfb_get_mem_region(rg);\n\tatomic_dec(&rg->map_count);\n\tomapfb_put_mem_region(rg);\n}\n\nstatic const struct vm_operations_struct mmap_user_ops = {\n\t.open = mmap_user_open,\n\t.close = mmap_user_close,\n};\n\nstatic int omapfb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct fb_fix_screeninfo *fix = &fbi->fix;\n\tstruct omapfb2_mem_region *rg;\n\tunsigned long start;\n\tu32 len;\n\tint r;\n\n\trg = omapfb_get_mem_region(ofbi->region);\n\n\tstart = omapfb_get_region_paddr(ofbi);\n\tlen = fix->smem_len;\n\n\tDBG(\"user mmap region start %lx, len %d, off %lx\\n\", start, len,\n\t\t\tvma->vm_pgoff << PAGE_SHIFT);\n\n\tvma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);\n\tvma->vm_ops = &mmap_user_ops;\n\tvma->vm_private_data = rg;\n\n\tr = vm_iomap_memory(vma, start, len);\n\tif (r)\n\t\tgoto error;\n\n\t \n\tatomic_inc(&rg->map_count);\n\n\tomapfb_put_mem_region(rg);\n\n\treturn 0;\n\nerror:\n\tomapfb_put_mem_region(ofbi->region);\n\n\treturn r;\n}\n\n \nstatic int _setcolreg(struct fb_info *fbi, u_int regno, u_int red, u_int green,\n\t\tu_int blue, u_int transp, int update_hw_pal)\n{\n\t \n\t \n\tstruct fb_var_screeninfo *var = &fbi->var;\n\tint r = 0;\n\n\tenum omapfb_color_format mode = OMAPFB_COLOR_RGB24U;  \n\n\t \n\tswitch (mode) {\n\tcase OMAPFB_COLOR_YUV422:\n\tcase OMAPFB_COLOR_YUV420:\n\tcase OMAPFB_COLOR_YUY422:\n\t\tr = -EINVAL;\n\t\tbreak;\n\tcase OMAPFB_COLOR_CLUT_8BPP:\n\tcase OMAPFB_COLOR_CLUT_4BPP:\n\tcase OMAPFB_COLOR_CLUT_2BPP:\n\tcase OMAPFB_COLOR_CLUT_1BPP:\n\t\t \n\t\tr = -EINVAL;\n\t\tbreak;\n\tcase OMAPFB_COLOR_RGB565:\n\tcase OMAPFB_COLOR_RGB444:\n\tcase OMAPFB_COLOR_RGB24P:\n\tcase OMAPFB_COLOR_RGB24U:\n\t\tif (regno < 16) {\n\t\t\tu32 pal;\n\t\t\tpal = ((red >> (16 - var->red.length)) <<\n\t\t\t\t\tvar->red.offset) |\n\t\t\t\t((green >> (16 - var->green.length)) <<\n\t\t\t\t var->green.offset) |\n\t\t\t\t(blue >> (16 - var->blue.length));\n\t\t\t((u32 *)(fbi->pseudo_palette))[regno] = pal;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn r;\n}\n\nstatic int omapfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\tu_int transp, struct fb_info *info)\n{\n\tDBG(\"setcolreg\\n\");\n\n\treturn _setcolreg(info, regno, red, green, blue, transp, 1);\n}\n\nstatic int omapfb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tint count, index, r;\n\tu16 *red, *green, *blue, *transp;\n\tu16 trans = 0xffff;\n\n\tDBG(\"setcmap\\n\");\n\n\tred     = cmap->red;\n\tgreen   = cmap->green;\n\tblue    = cmap->blue;\n\ttransp  = cmap->transp;\n\tindex   = cmap->start;\n\n\tfor (count = 0; count < cmap->len; count++) {\n\t\tif (transp)\n\t\t\ttrans = *transp++;\n\t\tr = _setcolreg(info, index++, *red++, *green++, *blue++, trans,\n\t\t\t\tcount == cmap->len - 1);\n\t\tif (r != 0)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int omapfb_blank(int blank, struct fb_info *fbi)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omap_dss_device *display = fb2display(fbi);\n\tstruct omapfb_display_data *d;\n\tint r = 0;\n\n\tif (!display)\n\t\treturn -EINVAL;\n\n\tomapfb_lock(fbdev);\n\n\td = get_display_data(fbdev, display);\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\n\t\tif (display->state == OMAP_DSS_DISPLAY_ACTIVE)\n\t\t\tgoto exit;\n\n\t\tr = display->driver->enable(display);\n\n\t\tif ((display->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE) &&\n\t\t\t\td->update_mode == OMAPFB_AUTO_UPDATE &&\n\t\t\t\t!d->auto_update_work_enabled)\n\t\t\tomapfb_start_auto_update(fbdev, display);\n\n\t\tbreak;\n\n\tcase FB_BLANK_NORMAL:\n\t\t \n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_POWERDOWN:\n\t\tif (display->state != OMAP_DSS_DISPLAY_ACTIVE)\n\t\t\tgoto exit;\n\n\t\tif (d->auto_update_work_enabled)\n\t\t\tomapfb_stop_auto_update(fbdev, display);\n\n\t\tdisplay->driver->disable(display);\n\n\t\tbreak;\n\n\tdefault:\n\t\tr = -EINVAL;\n\t}\n\nexit:\n\tomapfb_unlock(fbdev);\n\n\treturn r;\n}\n\n#if 0\n \nssize_t omapfb_write(struct fb_info *info, const char __user *buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tDBG(\"omapfb_write %d, %lu\\n\", count, (unsigned long)*ppos);\n\t \n\treturn count;\n}\n#endif\n\nstatic const struct fb_ops omapfb_ops = {\n\t.owner          = THIS_MODULE,\n\t.fb_open        = omapfb_open,\n\t.fb_release     = omapfb_release,\n\t.fb_fillrect    = cfb_fillrect,\n\t.fb_copyarea    = cfb_copyarea,\n\t.fb_imageblit   = cfb_imageblit,\n\t.fb_blank       = omapfb_blank,\n\t.fb_ioctl       = omapfb_ioctl,\n\t.fb_check_var   = omapfb_check_var,\n\t.fb_set_par     = omapfb_set_par,\n\t.fb_pan_display = omapfb_pan_display,\n\t.fb_mmap\t= omapfb_mmap,\n\t.fb_setcolreg\t= omapfb_setcolreg,\n\t.fb_setcmap\t= omapfb_setcmap,\n\t \n};\n\nstatic void omapfb_free_fbmem(struct fb_info *fbi)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omapfb2_mem_region *rg;\n\n\trg = ofbi->region;\n\n\tif (rg->token == NULL)\n\t\treturn;\n\n\tWARN_ON(atomic_read(&rg->map_count));\n\n\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\n\t\t \n\t\tif (rg->vrfb.vaddr[0]) {\n\t\t\tiounmap(rg->vrfb.vaddr[0]);\n\t\t\trg->vrfb.vaddr[0] = NULL;\n\t\t}\n\n\t\tomap_vrfb_release_ctx(&rg->vrfb);\n\t}\n\n\tdma_free_attrs(fbdev->dev, rg->size, rg->token, rg->dma_handle,\n\t\t\trg->attrs);\n\n\trg->token = NULL;\n\trg->vaddr = NULL;\n\trg->paddr = 0;\n\trg->alloc = 0;\n\trg->size = 0;\n}\n\nstatic void clear_fb_info(struct fb_info *fbi)\n{\n\tmemset(&fbi->var, 0, sizeof(fbi->var));\n\tmemset(&fbi->fix, 0, sizeof(fbi->fix));\n\tstrscpy(fbi->fix.id, MODULE_NAME, sizeof(fbi->fix.id));\n}\n\nstatic int omapfb_free_all_fbmem(struct omapfb2_device *fbdev)\n{\n\tint i;\n\n\tDBG(\"free all fbmem\\n\");\n\n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\tstruct fb_info *fbi = fbdev->fbs[i];\n\t\tomapfb_free_fbmem(fbi);\n\t\tclear_fb_info(fbi);\n\t}\n\n\treturn 0;\n}\n\nstatic int omapfb_alloc_fbmem(struct fb_info *fbi, unsigned long size,\n\t\tunsigned long paddr)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omapfb2_mem_region *rg;\n\tvoid *token;\n\tunsigned long attrs;\n\tdma_addr_t dma_handle;\n\tint r;\n\n\trg = ofbi->region;\n\n\trg->paddr = 0;\n\trg->vaddr = NULL;\n\tmemset(&rg->vrfb, 0, sizeof rg->vrfb);\n\trg->size = 0;\n\trg->type = 0;\n\trg->alloc = false;\n\trg->map = false;\n\n\tsize = PAGE_ALIGN(size);\n\n\tattrs = DMA_ATTR_WRITE_COMBINE;\n\n\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)\n\t\tattrs |= DMA_ATTR_NO_KERNEL_MAPPING;\n\n\tDBG(\"allocating %lu bytes for fb %d\\n\", size, ofbi->id);\n\n\ttoken = dma_alloc_attrs(fbdev->dev, size, &dma_handle,\n\t\t\tGFP_KERNEL, attrs);\n\n\tif (token == NULL) {\n\t\tdev_err(fbdev->dev, \"failed to allocate framebuffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tDBG(\"allocated VRAM paddr %lx, vaddr %p\\n\",\n\t\t\t(unsigned long)dma_handle, token);\n\n\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\n\t\tr = omap_vrfb_request_ctx(&rg->vrfb);\n\t\tif (r) {\n\t\t\tdma_free_attrs(fbdev->dev, size, token, dma_handle,\n\t\t\t\t\tattrs);\n\t\t\tdev_err(fbdev->dev, \"vrfb create ctx failed\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\trg->attrs = attrs;\n\trg->token = token;\n\trg->dma_handle = dma_handle;\n\n\trg->paddr = (unsigned long)dma_handle;\n\trg->vaddr = (void __iomem *)token;\n\trg->size = size;\n\trg->alloc = 1;\n\n\treturn 0;\n}\n\n \nstatic int omapfb_alloc_fbmem_display(struct fb_info *fbi, unsigned long size,\n\t\tunsigned long paddr)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omap_dss_device *display;\n\tint bytespp;\n\n\tdisplay =  fb2display(fbi);\n\n\tif (!display)\n\t\treturn 0;\n\n\tswitch (omapfb_get_recommended_bpp(fbdev, display)) {\n\tcase 16:\n\t\tbytespp = 2;\n\t\tbreak;\n\tcase 24:\n\t\tbytespp = 4;\n\t\tbreak;\n\tdefault:\n\t\tbytespp = 4;\n\t\tbreak;\n\t}\n\n\tif (!size) {\n\t\tu16 w, h;\n\n\t\tdisplay->driver->get_resolution(display, &w, &h);\n\n\t\tif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\n\t\t\tsize = max(omap_vrfb_min_phys_size(w, h, bytespp),\n\t\t\t\t\tomap_vrfb_min_phys_size(h, w, bytespp));\n\n\t\t\tDBG(\"adjusting fb mem size for VRFB, %u -> %lu\\n\",\n\t\t\t\t\tw * h * bytespp, size);\n\t\t} else {\n\t\t\tsize = w * h * bytespp;\n\t\t}\n\t}\n\n\tif (!size)\n\t\treturn 0;\n\n\treturn omapfb_alloc_fbmem(fbi, size, paddr);\n}\n\nstatic int omapfb_parse_vram_param(const char *param, int max_entries,\n\t\tunsigned long *sizes, unsigned long *paddrs)\n{\n\tunsigned int fbnum;\n\tunsigned long size;\n\tunsigned long paddr = 0;\n\tchar *p, *start;\n\n\tstart = (char *)param;\n\n\twhile (1) {\n\t\tp = start;\n\n\t\tfbnum = simple_strtoul(p, &p, 10);\n\n\t\tif (p == start)\n\t\t\treturn -EINVAL;\n\n\t\tif (*p != ':')\n\t\t\treturn -EINVAL;\n\n\t\tif (fbnum >= max_entries)\n\t\t\treturn -EINVAL;\n\n\t\tsize = memparse(p + 1, &p);\n\n\t\tif (!size)\n\t\t\treturn -EINVAL;\n\n\t\tpaddr = 0;\n\n\t\tif (*p == '@') {\n\t\t\tpaddr = simple_strtoul(p + 1, &p, 16);\n\n\t\t\tif (!paddr)\n\t\t\t\treturn -EINVAL;\n\n\t\t}\n\n\t\tWARN_ONCE(paddr,\n\t\t\t\"reserving memory at predefined address not supported\\n\");\n\n\t\tpaddrs[fbnum] = paddr;\n\t\tsizes[fbnum] = size;\n\n\t\tif (*p == 0)\n\t\t\tbreak;\n\n\t\tif (*p != ',')\n\t\t\treturn -EINVAL;\n\n\t\t++p;\n\n\t\tstart = p;\n\t}\n\n\treturn 0;\n}\n\nstatic int omapfb_allocate_all_fbs(struct omapfb2_device *fbdev)\n{\n\tint i, r;\n\tunsigned long vram_sizes[10];\n\tunsigned long vram_paddrs[10];\n\n\tmemset(&vram_sizes, 0, sizeof(vram_sizes));\n\tmemset(&vram_paddrs, 0, sizeof(vram_paddrs));\n\n\tif (def_vram &&\tomapfb_parse_vram_param(def_vram, 10,\n\t\t\t\tvram_sizes, vram_paddrs)) {\n\t\tdev_err(fbdev->dev, \"failed to parse vram parameter\\n\");\n\n\t\tmemset(&vram_sizes, 0, sizeof(vram_sizes));\n\t\tmemset(&vram_paddrs, 0, sizeof(vram_paddrs));\n\t}\n\n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\t \n\t\tif (i == 0 || vram_sizes[i] != 0) {\n\t\t\tr = omapfb_alloc_fbmem_display(fbdev->fbs[i],\n\t\t\t\t\tvram_sizes[i], vram_paddrs[i]);\n\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\tstruct omapfb_info *ofbi = FB2OFB(fbdev->fbs[i]);\n\t\tstruct omapfb2_mem_region *rg;\n\t\trg = ofbi->region;\n\n\t\tDBG(\"region%d phys %08x virt %p size=%lu\\n\",\n\t\t\t\ti,\n\t\t\t\trg->paddr,\n\t\t\t\trg->vaddr,\n\t\t\t\trg->size);\n\t}\n\n\treturn 0;\n}\n\nstatic void omapfb_clear_fb(struct fb_info *fbi)\n{\n\tconst struct fb_fillrect rect = {\n\t\t.dx = 0,\n\t\t.dy = 0,\n\t\t.width = fbi->var.xres_virtual,\n\t\t.height = fbi->var.yres_virtual,\n\t\t.color = 0,\n\t\t.rop = ROP_COPY,\n\t};\n\n\tcfb_fillrect(fbi, &rect);\n}\n\nint omapfb_realloc_fbmem(struct fb_info *fbi, unsigned long size, int type)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omapfb2_mem_region *rg = ofbi->region;\n\tunsigned long old_size = rg->size;\n\tunsigned long old_paddr = rg->paddr;\n\tint old_type = rg->type;\n\tint r;\n\n\tif (type != OMAPFB_MEMTYPE_SDRAM)\n\t\treturn -EINVAL;\n\n\tsize = PAGE_ALIGN(size);\n\n\tif (old_size == size && old_type == type)\n\t\treturn 0;\n\n\tomapfb_free_fbmem(fbi);\n\n\tif (size == 0) {\n\t\tclear_fb_info(fbi);\n\t\treturn 0;\n\t}\n\n\tr = omapfb_alloc_fbmem(fbi, size, 0);\n\n\tif (r) {\n\t\tif (old_size)\n\t\t\tomapfb_alloc_fbmem(fbi, old_size, old_paddr);\n\n\t\tif (rg->size == 0)\n\t\t\tclear_fb_info(fbi);\n\n\t\treturn r;\n\t}\n\n\tif (old_size == size)\n\t\treturn 0;\n\n\tif (old_size == 0) {\n\t\tDBG(\"initializing fb %d\\n\", ofbi->id);\n\t\tr = omapfb_fb_init(fbdev, fbi);\n\t\tif (r) {\n\t\t\tDBG(\"omapfb_fb_init failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tr = omapfb_apply_changes(fbi, 1);\n\t\tif (r) {\n\t\t\tDBG(\"omapfb_apply_changes failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tstruct fb_var_screeninfo new_var;\n\t\tmemcpy(&new_var, &fbi->var, sizeof(new_var));\n\t\tr = check_fb_var(fbi, &new_var);\n\t\tif (r)\n\t\t\tgoto err;\n\t\tmemcpy(&fbi->var, &new_var, sizeof(fbi->var));\n\t\tset_fb_fix(fbi);\n\t\tr = setup_vrfb_rotation(fbi);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tomapfb_clear_fb(fbi);\n\n\treturn 0;\nerr:\n\tomapfb_free_fbmem(fbi);\n\tclear_fb_info(fbi);\n\treturn r;\n}\n\nstatic void omapfb_auto_update_work(struct work_struct *work)\n{\n\tstruct omap_dss_device *dssdev;\n\tstruct omap_dss_driver *dssdrv;\n\tstruct omapfb_display_data *d;\n\tu16 w, h;\n\tunsigned int freq;\n\tstruct omapfb2_device *fbdev;\n\n\td = container_of(work, struct omapfb_display_data,\n\t\t\tauto_update_work.work);\n\n\tdssdev = d->dssdev;\n\tdssdrv = dssdev->driver;\n\tfbdev = d->fbdev;\n\n\tif (!dssdrv || !dssdrv->update)\n\t\treturn;\n\n\tif (dssdrv->sync)\n\t\tdssdrv->sync(dssdev);\n\n\tdssdrv->get_resolution(dssdev, &w, &h);\n\tdssdrv->update(dssdev, 0, 0, w, h);\n\n\tfreq = auto_update_freq;\n\tif (freq == 0)\n\t\tfreq = 20;\n\tqueue_delayed_work(fbdev->auto_update_wq,\n\t\t\t&d->auto_update_work, HZ / freq);\n}\n\nvoid omapfb_start_auto_update(struct omapfb2_device *fbdev,\n\t\tstruct omap_dss_device *display)\n{\n\tstruct omapfb_display_data *d;\n\n\tif (fbdev->auto_update_wq == NULL) {\n\t\tstruct workqueue_struct *wq;\n\n\t\twq = create_singlethread_workqueue(\"omapfb_auto_update\");\n\n\t\tif (wq == NULL) {\n\t\t\tdev_err(fbdev->dev, \"Failed to create workqueue for \"\n\t\t\t\t\t\"auto-update\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tfbdev->auto_update_wq = wq;\n\t}\n\n\td = get_display_data(fbdev, display);\n\n\tINIT_DELAYED_WORK(&d->auto_update_work, omapfb_auto_update_work);\n\n\td->auto_update_work_enabled = true;\n\n\tomapfb_auto_update_work(&d->auto_update_work.work);\n}\n\nvoid omapfb_stop_auto_update(struct omapfb2_device *fbdev,\n\t\tstruct omap_dss_device *display)\n{\n\tstruct omapfb_display_data *d;\n\n\td = get_display_data(fbdev, display);\n\n\tcancel_delayed_work_sync(&d->auto_update_work);\n\n\td->auto_update_work_enabled = false;\n}\n\n \nstatic int omapfb_fb_init(struct omapfb2_device *fbdev, struct fb_info *fbi)\n{\n\tstruct fb_var_screeninfo *var = &fbi->var;\n\tstruct omap_dss_device *display = fb2display(fbi);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tint r = 0;\n\n\tfbi->fbops = &omapfb_ops;\n\tfbi->pseudo_palette = fbdev->pseudo_palette;\n\n\tif (ofbi->region->size == 0) {\n\t\tclear_fb_info(fbi);\n\t\treturn 0;\n\t}\n\n\tvar->nonstd = 0;\n\tvar->bits_per_pixel = 0;\n\n\tvar->rotate = def_rotate;\n\n\tif (display) {\n\t\tu16 w, h;\n\t\tint rotation = (var->rotate + ofbi->rotation[0]) % 4;\n\n\t\tdisplay->driver->get_resolution(display, &w, &h);\n\n\t\tif (rotation == FB_ROTATE_CW ||\n\t\t\t\trotation == FB_ROTATE_CCW) {\n\t\t\tvar->xres = h;\n\t\t\tvar->yres = w;\n\t\t} else {\n\t\t\tvar->xres = w;\n\t\t\tvar->yres = h;\n\t\t}\n\n\t\tvar->xres_virtual = var->xres;\n\t\tvar->yres_virtual = var->yres;\n\n\t\tif (!var->bits_per_pixel) {\n\t\t\tswitch (omapfb_get_recommended_bpp(fbdev, display)) {\n\t\t\tcase 16:\n\t\t\t\tvar->bits_per_pixel = 16;\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tvar->bits_per_pixel = 32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(fbdev->dev, \"illegal display \"\n\t\t\t\t\t\t\"bpp\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tvar->xres = 320;\n\t\tvar->yres = 240;\n\t\tvar->xres_virtual = var->xres;\n\t\tvar->yres_virtual = var->yres;\n\t\tif (!var->bits_per_pixel)\n\t\t\tvar->bits_per_pixel = 16;\n\t}\n\n\tr = check_fb_var(fbi, var);\n\tif (r)\n\t\tgoto err;\n\n\tset_fb_fix(fbi);\n\tr = setup_vrfb_rotation(fbi);\n\tif (r)\n\t\tgoto err;\n\n\tr = fb_alloc_cmap(&fbi->cmap, 256, 0);\n\tif (r)\n\t\tdev_err(fbdev->dev, \"unable to allocate color map memory\\n\");\n\nerr:\n\treturn r;\n}\n\nstatic void fbinfo_cleanup(struct omapfb2_device *fbdev, struct fb_info *fbi)\n{\n\tfb_dealloc_cmap(&fbi->cmap);\n}\n\n\nstatic void omapfb_free_resources(struct omapfb2_device *fbdev)\n{\n\tint i;\n\n\tDBG(\"free_resources\\n\");\n\n\tif (fbdev == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < fbdev->num_overlays; i++) {\n\t\tstruct omap_overlay *ovl = fbdev->overlays[i];\n\n\t\tovl->disable(ovl);\n\n\t\tif (ovl->manager)\n\t\t\tovl->unset_manager(ovl);\n\t}\n\n\tfor (i = 0; i < fbdev->num_fbs; i++)\n\t\tunregister_framebuffer(fbdev->fbs[i]);\n\n\t \n\tomapfb_free_all_fbmem(fbdev);\n\n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\tfbinfo_cleanup(fbdev, fbdev->fbs[i]);\n\t\tframebuffer_release(fbdev->fbs[i]);\n\t}\n\n\tfor (i = 0; i < fbdev->num_displays; i++) {\n\t\tstruct omap_dss_device *dssdev = fbdev->displays[i].dssdev;\n\n\t\tif (fbdev->displays[i].auto_update_work_enabled)\n\t\t\tomapfb_stop_auto_update(fbdev, dssdev);\n\n\t\tif (dssdev->state != OMAP_DSS_DISPLAY_DISABLED)\n\t\t\tdssdev->driver->disable(dssdev);\n\n\t\tdssdev->driver->disconnect(dssdev);\n\n\t\tomap_dss_put_device(dssdev);\n\t}\n\n\tif (fbdev->auto_update_wq != NULL) {\n\t\tdestroy_workqueue(fbdev->auto_update_wq);\n\t\tfbdev->auto_update_wq = NULL;\n\t}\n\n\tdev_set_drvdata(fbdev->dev, NULL);\n}\n\nstatic int omapfb_create_framebuffers(struct omapfb2_device *fbdev)\n{\n\tint r, i;\n\n\tfbdev->num_fbs = 0;\n\n\tDBG(\"create %d framebuffers\\n\",\tCONFIG_FB_OMAP2_NUM_FBS);\n\n\t \n\tfor (i = 0; i < CONFIG_FB_OMAP2_NUM_FBS; i++) {\n\t\tstruct fb_info *fbi;\n\t\tstruct omapfb_info *ofbi;\n\n\t\tfbi = framebuffer_alloc(sizeof(struct omapfb_info),\n\t\t\t\tfbdev->dev);\n\t\tif (!fbi)\n\t\t\treturn -ENOMEM;\n\n\t\tclear_fb_info(fbi);\n\n\t\tfbdev->fbs[i] = fbi;\n\n\t\tofbi = FB2OFB(fbi);\n\t\tofbi->fbdev = fbdev;\n\t\tofbi->id = i;\n\n\t\tofbi->region = &fbdev->regions[i];\n\t\tofbi->region->id = i;\n\t\tinit_rwsem(&ofbi->region->lock);\n\n\t\t \n\t\tofbi->rotation_type = def_vrfb ? OMAP_DSS_ROT_VRFB :\n\t\t\tOMAP_DSS_ROT_DMA;\n\t\tofbi->mirror = def_mirror;\n\n\t\tfbdev->num_fbs++;\n\t}\n\n\tDBG(\"fb_infos allocated\\n\");\n\n\t \n\tfor (i = 0; i < min(fbdev->num_fbs, fbdev->num_overlays); i++) {\n\t\tstruct omapfb_info *ofbi = FB2OFB(fbdev->fbs[i]);\n\n\t\tofbi->overlays[0] = fbdev->overlays[i];\n\t\tofbi->num_overlays = 1;\n\t}\n\n\t \n\tr = omapfb_allocate_all_fbs(fbdev);\n\tif (r) {\n\t\tdev_err(fbdev->dev, \"failed to allocate fbmem\\n\");\n\t\treturn r;\n\t}\n\n\tDBG(\"fbmems allocated\\n\");\n\n\t \n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\tstruct fb_info *fbi = fbdev->fbs[i];\n\t\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\n\t\tomapfb_get_mem_region(ofbi->region);\n\t\tr = omapfb_fb_init(fbdev, fbi);\n\t\tomapfb_put_mem_region(ofbi->region);\n\n\t\tif (r) {\n\t\t\tdev_err(fbdev->dev, \"failed to setup fb_info\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\tstruct fb_info *fbi = fbdev->fbs[i];\n\t\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\n\t\tif (ofbi->region->size == 0)\n\t\t\tcontinue;\n\n\t\tomapfb_clear_fb(fbi);\n\t}\n\n\tDBG(\"fb_infos initialized\\n\");\n\n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\tr = register_framebuffer(fbdev->fbs[i]);\n\t\tif (r != 0) {\n\t\t\tdev_err(fbdev->dev,\n\t\t\t\t\"registering framebuffer %d failed\\n\", i);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tDBG(\"framebuffers registered\\n\");\n\n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\tstruct fb_info *fbi = fbdev->fbs[i];\n\t\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\n\t\tomapfb_get_mem_region(ofbi->region);\n\t\tr = omapfb_apply_changes(fbi, 1);\n\t\tomapfb_put_mem_region(ofbi->region);\n\n\t\tif (r) {\n\t\t\tdev_err(fbdev->dev, \"failed to change mode\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\t \n\tif (fbdev->num_fbs > 0) {\n\t\tstruct omapfb_info *ofbi = FB2OFB(fbdev->fbs[0]);\n\n\t\tif (ofbi->num_overlays > 0) {\n\t\t\tstruct omap_overlay *ovl = ofbi->overlays[0];\n\n\t\t\tovl->manager->apply(ovl->manager);\n\n\t\t\tr = omapfb_overlay_enable(ovl, 1);\n\n\t\t\tif (r) {\n\t\t\t\tdev_err(fbdev->dev,\n\t\t\t\t\t\t\"failed to enable overlay\\n\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\n\tDBG(\"create_framebuffers done\\n\");\n\n\treturn 0;\n}\n\nstatic int omapfb_mode_to_timings(const char *mode_str,\n\t\tstruct omap_dss_device *display,\n\t\tstruct omap_video_timings *timings, u8 *bpp)\n{\n\tstruct fb_info *fbi;\n\tstruct fb_var_screeninfo *var;\n\tstruct fb_ops *fbops;\n\tint r;\n\n#ifdef CONFIG_OMAP2_DSS_VENC\n\tif (strcmp(mode_str, \"pal\") == 0) {\n\t\t*timings = omap_dss_pal_timings;\n\t\t*bpp = 24;\n\t\treturn 0;\n\t} else if (strcmp(mode_str, \"ntsc\") == 0) {\n\t\t*timings = omap_dss_ntsc_timings;\n\t\t*bpp = 24;\n\t\treturn 0;\n\t}\n#endif\n\n\t \n\n\t*bpp = 0;\n\tfbi = NULL;\n\tvar = NULL;\n\tfbops = NULL;\n\n\tfbi = kzalloc(sizeof(*fbi), GFP_KERNEL);\n\tif (fbi == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tvar = kzalloc(sizeof(*var), GFP_KERNEL);\n\tif (var == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfbops = kzalloc(sizeof(*fbops), GFP_KERNEL);\n\tif (fbops == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfbi->fbops = fbops;\n\n\tr = fb_find_mode(var, fbi, mode_str, NULL, 0, NULL, 24);\n\tif (r == 0) {\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (display->driver->get_timings) {\n\t\tdisplay->driver->get_timings(display, timings);\n\t} else {\n\t\ttimings->data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\n\t\ttimings->de_level = OMAPDSS_SIG_ACTIVE_HIGH;\n\t\ttimings->sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE;\n\t}\n\n\ttimings->pixelclock = PICOS2KHZ(var->pixclock) * 1000;\n\ttimings->hbp = var->left_margin;\n\ttimings->hfp = var->right_margin;\n\ttimings->vbp = var->upper_margin;\n\ttimings->vfp = var->lower_margin;\n\ttimings->hsw = var->hsync_len;\n\ttimings->vsw = var->vsync_len;\n\ttimings->x_res = var->xres;\n\ttimings->y_res = var->yres;\n\ttimings->hsync_level = var->sync & FB_SYNC_HOR_HIGH_ACT ?\n\t\t\t\tOMAPDSS_SIG_ACTIVE_HIGH :\n\t\t\t\tOMAPDSS_SIG_ACTIVE_LOW;\n\ttimings->vsync_level = var->sync & FB_SYNC_VERT_HIGH_ACT ?\n\t\t\t\tOMAPDSS_SIG_ACTIVE_HIGH :\n\t\t\t\tOMAPDSS_SIG_ACTIVE_LOW;\n\ttimings->interlace = var->vmode & FB_VMODE_INTERLACED;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 16:\n\t\t*bpp = 16;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\tdefault:\n\t\t*bpp = 24;\n\t\tbreak;\n\t}\n\n\tr = 0;\n\nerr:\n\tkfree(fbi);\n\tkfree(var);\n\tkfree(fbops);\n\n\treturn r;\n}\n\nstatic int omapfb_set_def_mode(struct omapfb2_device *fbdev,\n\t\tstruct omap_dss_device *display, char *mode_str)\n{\n\tint r;\n\tu8 bpp;\n\tstruct omap_video_timings timings, temp_timings;\n\tstruct omapfb_display_data *d;\n\n\tr = omapfb_mode_to_timings(mode_str, display, &timings, &bpp);\n\tif (r)\n\t\treturn r;\n\n\td = get_display_data(fbdev, display);\n\td->bpp_override = bpp;\n\n\tif (display->driver->check_timings) {\n\t\tr = display->driver->check_timings(display, &timings);\n\t\tif (r)\n\t\t\treturn r;\n\t} else {\n\t\t \n\t\tif (display->driver->get_timings) {\n\t\t\tdisplay->driver->get_timings(display, &temp_timings);\n\n\t\t\tif (temp_timings.x_res != timings.x_res ||\n\t\t\t\ttemp_timings.y_res != timings.y_res)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (display->driver->set_timings)\n\t\t\tdisplay->driver->set_timings(display, &timings);\n\n\treturn 0;\n}\n\nstatic int omapfb_get_recommended_bpp(struct omapfb2_device *fbdev,\n\t\tstruct omap_dss_device *dssdev)\n{\n\tstruct omapfb_display_data *d;\n\n\tBUG_ON(dssdev->driver->get_recommended_bpp == NULL);\n\n\td = get_display_data(fbdev, dssdev);\n\n\tif (d->bpp_override != 0)\n\t\treturn d->bpp_override;\n\n\treturn dssdev->driver->get_recommended_bpp(dssdev);\n}\n\nstatic int omapfb_parse_def_modes(struct omapfb2_device *fbdev)\n{\n\tchar *str, *options, *this_opt;\n\tint r = 0;\n\n\tstr = kstrdup(def_mode, GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\toptions = str;\n\n\twhile (!r && (this_opt = strsep(&options, \",\")) != NULL) {\n\t\tchar *p, *display_str, *mode_str;\n\t\tstruct omap_dss_device *display;\n\t\tint i;\n\n\t\tp = strchr(this_opt, ':');\n\t\tif (!p) {\n\t\t\tr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t*p = 0;\n\t\tdisplay_str = this_opt;\n\t\tmode_str = p + 1;\n\n\t\tdisplay = NULL;\n\t\tfor (i = 0; i < fbdev->num_displays; ++i) {\n\t\t\tif (strcmp(fbdev->displays[i].dssdev->name,\n\t\t\t\t\t\tdisplay_str) == 0) {\n\t\t\t\tdisplay = fbdev->displays[i].dssdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!display) {\n\t\t\tr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = omapfb_set_def_mode(fbdev, display, mode_str);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\tkfree(str);\n\n\treturn r;\n}\n\nstatic void fb_videomode_to_omap_timings(struct fb_videomode *m,\n\t\tstruct omap_dss_device *display,\n\t\tstruct omap_video_timings *t)\n{\n\tif (display->driver->get_timings) {\n\t\tdisplay->driver->get_timings(display, t);\n\t} else {\n\t\tt->data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\n\t\tt->de_level = OMAPDSS_SIG_ACTIVE_HIGH;\n\t\tt->sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE;\n\t}\n\n\tt->x_res = m->xres;\n\tt->y_res = m->yres;\n\tt->pixelclock = PICOS2KHZ(m->pixclock) * 1000;\n\tt->hsw = m->hsync_len;\n\tt->hfp = m->right_margin;\n\tt->hbp = m->left_margin;\n\tt->vsw = m->vsync_len;\n\tt->vfp = m->lower_margin;\n\tt->vbp = m->upper_margin;\n\tt->hsync_level = m->sync & FB_SYNC_HOR_HIGH_ACT ?\n\t\t\t\tOMAPDSS_SIG_ACTIVE_HIGH :\n\t\t\t\tOMAPDSS_SIG_ACTIVE_LOW;\n\tt->vsync_level = m->sync & FB_SYNC_VERT_HIGH_ACT ?\n\t\t\t\tOMAPDSS_SIG_ACTIVE_HIGH :\n\t\t\t\tOMAPDSS_SIG_ACTIVE_LOW;\n\tt->interlace = m->vmode & FB_VMODE_INTERLACED;\n}\n\nstatic int omapfb_find_best_mode(struct omap_dss_device *display,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct fb_monspecs *specs;\n\tu8 *edid;\n\tint r, i, best_idx, len;\n\n\tif (!display->driver->read_edid)\n\t\treturn -ENODEV;\n\n\tlen = 0x80 * 2;\n\tedid = kmalloc(len, GFP_KERNEL);\n\tif (edid == NULL)\n\t\treturn -ENOMEM;\n\n\tr = display->driver->read_edid(display, edid, len);\n\tif (r < 0)\n\t\tgoto err1;\n\n\tspecs = kzalloc(sizeof(*specs), GFP_KERNEL);\n\tif (specs == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\tfb_edid_to_monspecs(edid, specs);\n\n\tbest_idx = -1;\n\n\tfor (i = 0; i < specs->modedb_len; ++i) {\n\t\tstruct fb_videomode *m;\n\t\tstruct omap_video_timings t;\n\n\t\tm = &specs->modedb[i];\n\n\t\tif (m->pixclock == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (m->xres == 2880 || m->xres == 1440)\n\t\t\tcontinue;\n\n\t\tif (m->vmode & FB_VMODE_INTERLACED ||\n\t\t\t\tm->vmode & FB_VMODE_DOUBLE)\n\t\t\tcontinue;\n\n\t\tfb_videomode_to_omap_timings(m, display, &t);\n\n\t\tr = display->driver->check_timings(display, &t);\n\t\tif (r == 0) {\n\t\t\tbest_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (best_idx == -1) {\n\t\tr = -ENOENT;\n\t\tgoto err2;\n\t}\n\n\tfb_videomode_to_omap_timings(&specs->modedb[best_idx], display,\n\t\ttimings);\n\n\tr = 0;\n\nerr2:\n\tfb_destroy_modedb(specs->modedb);\n\tkfree(specs);\nerr1:\n\tkfree(edid);\n\n\treturn r;\n}\n\nstatic int omapfb_init_display(struct omapfb2_device *fbdev,\n\t\tstruct omap_dss_device *dssdev)\n{\n\tstruct omap_dss_driver *dssdrv = dssdev->driver;\n\tstruct omapfb_display_data *d;\n\tint r;\n\n\tr = dssdrv->enable(dssdev);\n\tif (r) {\n\t\tdev_warn(fbdev->dev, \"Failed to enable display '%s'\\n\",\n\t\t\t\tdssdev->name);\n\t\treturn r;\n\t}\n\n\td = get_display_data(fbdev, dssdev);\n\n\td->fbdev = fbdev;\n\n\tif (dssdev->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE) {\n\t\tu16 w, h;\n\n\t\tif (auto_update) {\n\t\t\tomapfb_start_auto_update(fbdev, dssdev);\n\t\t\td->update_mode = OMAPFB_AUTO_UPDATE;\n\t\t} else {\n\t\t\td->update_mode = OMAPFB_MANUAL_UPDATE;\n\t\t}\n\n\t\tif (dssdrv->enable_te) {\n\t\t\tr = dssdrv->enable_te(dssdev, 1);\n\t\t\tif (r) {\n\t\t\t\tdev_err(fbdev->dev, \"Failed to set TE\\n\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tdssdrv->get_resolution(dssdev, &w, &h);\n\t\tr = dssdrv->update(dssdev, 0, 0, w, h);\n\t\tif (r) {\n\t\t\tdev_err(fbdev->dev,\n\t\t\t\t\t\"Failed to update display\\n\");\n\t\t\treturn r;\n\t\t}\n\t} else {\n\t\td->update_mode = OMAPFB_AUTO_UPDATE;\n\t}\n\n\treturn 0;\n}\n\nstatic int omapfb_init_connections(struct omapfb2_device *fbdev,\n\t\tstruct omap_dss_device *def_dssdev)\n{\n\tint i, r;\n\tstruct omap_overlay_manager *mgr;\n\n\tr = def_dssdev->driver->connect(def_dssdev);\n\tif (r) {\n\t\tdev_err(fbdev->dev, \"failed to connect default display\\n\");\n\t\treturn r;\n\t}\n\n\tfor (i = 0; i < fbdev->num_displays; ++i) {\n\t\tstruct omap_dss_device *dssdev = fbdev->displays[i].dssdev;\n\n\t\tif (dssdev == def_dssdev)\n\t\t\tcontinue;\n\n\t\t \n\t\tdssdev->driver->connect(dssdev);\n\t}\n\n\tmgr = omapdss_find_mgr_from_display(def_dssdev);\n\n\tif (!mgr) {\n\t\tdev_err(fbdev->dev, \"no ovl manager for the default display\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < fbdev->num_overlays; i++) {\n\t\tstruct omap_overlay *ovl = fbdev->overlays[i];\n\n\t\tif (ovl->manager)\n\t\t\tovl->unset_manager(ovl);\n\n\t\tr = ovl->set_manager(ovl, mgr);\n\t\tif (r)\n\t\t\tdev_warn(fbdev->dev,\n\t\t\t\t\t\"failed to connect overlay %s to manager %s\\n\",\n\t\t\t\t\tovl->name, mgr->name);\n\t}\n\n\treturn 0;\n}\n\nstatic struct omap_dss_device *\nomapfb_find_default_display(struct omapfb2_device *fbdev)\n{\n\tconst char *def_name;\n\tint i;\n\n\t \n\n\tdef_name = omapdss_get_default_display_name();\n\n\tif (def_name) {\n\t\tfor (i = 0; i < fbdev->num_displays; ++i) {\n\t\t\tstruct omap_dss_device *dssdev;\n\n\t\t\tdssdev = fbdev->displays[i].dssdev;\n\n\t\t\tif (dssdev->name && strcmp(def_name, dssdev->name) == 0)\n\t\t\t\treturn dssdev;\n\n\t\t\tif (strcmp(def_name, dssdev->alias) == 0)\n\t\t\t\treturn dssdev;\n\t\t}\n\n\t\t \n\t\treturn NULL;\n\t}\n\n\t \n\tfor (i = 0; i < fbdev->num_displays; ++i) {\n\t\tstruct omap_dss_device *dssdev;\n\t\tint id;\n\n\t\tdssdev = fbdev->displays[i].dssdev;\n\n\t\tif (dssdev->dev->of_node == NULL)\n\t\t\tcontinue;\n\n\t\tid = of_alias_get_id(dssdev->dev->of_node, \"display\");\n\t\tif (id == 0)\n\t\t\treturn dssdev;\n\t}\n\n\t \n\treturn fbdev->displays[0].dssdev;\n}\n\nstatic int omapfb_probe(struct platform_device *pdev)\n{\n\tstruct omapfb2_device *fbdev = NULL;\n\tint r = 0;\n\tint i;\n\tstruct omap_dss_device *def_display;\n\tstruct omap_dss_device *dssdev;\n\n\tDBG(\"omapfb_probe\\n\");\n\n\tif (omapdss_is_initialized() == false)\n\t\treturn -EPROBE_DEFER;\n\n\tif (pdev->num_resources != 0) {\n\t\tdev_err(&pdev->dev, \"probed for an unknown device\\n\");\n\t\tr = -ENODEV;\n\t\tgoto err0;\n\t}\n\n\tfbdev = devm_kzalloc(&pdev->dev, sizeof(struct omapfb2_device),\n\t\t\tGFP_KERNEL);\n\tif (fbdev == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto err0;\n\t}\n\n\tif (def_vrfb && !omap_vrfb_supported()) {\n\t\tdef_vrfb = 0;\n\t\tdev_warn(&pdev->dev, \"VRFB is not supported on this hardware, \"\n\t\t\t\t\"ignoring the module parameter vrfb=y\\n\");\n\t}\n\n\tr = omapdss_compat_init();\n\tif (r)\n\t\tgoto err0;\n\n\tmutex_init(&fbdev->mtx);\n\n\tfbdev->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, fbdev);\n\n\tfbdev->num_displays = 0;\n\tdssdev = NULL;\n\tfor_each_dss_dev(dssdev) {\n\t\tstruct omapfb_display_data *d;\n\n\t\tomap_dss_get_device(dssdev);\n\n\t\tif (!dssdev->driver) {\n\t\t\tdev_warn(&pdev->dev, \"no driver for display: %s\\n\",\n\t\t\t\tdssdev->name);\n\t\t\tomap_dss_put_device(dssdev);\n\t\t\tcontinue;\n\t\t}\n\n\t\td = &fbdev->displays[fbdev->num_displays++];\n\t\td->dssdev = dssdev;\n\t\tif (dssdev->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE)\n\t\t\td->update_mode = OMAPFB_MANUAL_UPDATE;\n\t\telse\n\t\t\td->update_mode = OMAPFB_AUTO_UPDATE;\n\t}\n\n\tif (fbdev->num_displays == 0) {\n\t\tdev_err(&pdev->dev, \"no displays\\n\");\n\t\tr = -EPROBE_DEFER;\n\t\tgoto cleanup;\n\t}\n\n\tfbdev->num_overlays = omap_dss_get_num_overlays();\n\tfor (i = 0; i < fbdev->num_overlays; i++)\n\t\tfbdev->overlays[i] = omap_dss_get_overlay(i);\n\n\tfbdev->num_managers = omap_dss_get_num_overlay_managers();\n\tfor (i = 0; i < fbdev->num_managers; i++)\n\t\tfbdev->managers[i] = omap_dss_get_overlay_manager(i);\n\n\tdef_display = omapfb_find_default_display(fbdev);\n\tif (def_display == NULL) {\n\t\tdev_err(fbdev->dev, \"failed to find default display\\n\");\n\t\tr = -EPROBE_DEFER;\n\t\tgoto cleanup;\n\t}\n\n\tr = omapfb_init_connections(fbdev, def_display);\n\tif (r) {\n\t\tdev_err(fbdev->dev, \"failed to init overlay connections\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tif (def_mode && strlen(def_mode) > 0) {\n\t\tif (omapfb_parse_def_modes(fbdev))\n\t\t\tdev_warn(&pdev->dev, \"cannot parse default modes\\n\");\n\t} else if (def_display && def_display->driver->set_timings &&\n\t\t\tdef_display->driver->check_timings) {\n\t\tstruct omap_video_timings t;\n\n\t\tr = omapfb_find_best_mode(def_display, &t);\n\n\t\tif (r == 0)\n\t\t\tdef_display->driver->set_timings(def_display, &t);\n\t}\n\n\tr = omapfb_create_framebuffers(fbdev);\n\tif (r)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < fbdev->num_managers; i++) {\n\t\tstruct omap_overlay_manager *mgr;\n\t\tmgr = fbdev->managers[i];\n\t\tr = mgr->apply(mgr);\n\t\tif (r)\n\t\t\tdev_warn(fbdev->dev, \"failed to apply dispc config\\n\");\n\t}\n\n\tDBG(\"mgr->apply'ed\\n\");\n\n\tif (def_display) {\n\t\tr = omapfb_init_display(fbdev, def_display);\n\t\tif (r) {\n\t\t\tdev_err(fbdev->dev,\n\t\t\t\t\t\"failed to initialize default \"\n\t\t\t\t\t\"display\\n\");\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tDBG(\"create sysfs for fbs\\n\");\n\tr = omapfb_create_sysfs(fbdev);\n\tif (r) {\n\t\tdev_err(fbdev->dev, \"failed to create sysfs entries\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tif (def_display) {\n\t\tu16 w, h;\n\n\t\tdef_display->driver->get_resolution(def_display, &w, &h);\n\n\t\tdev_info(fbdev->dev, \"using display '%s' mode %dx%d\\n\",\n\t\t\tdef_display->name, w, h);\n\t}\n\n\treturn 0;\n\ncleanup:\n\tomapfb_free_resources(fbdev);\n\tomapdss_compat_uninit();\nerr0:\n\tdev_err(&pdev->dev, \"failed to setup omapfb\\n\");\n\treturn r;\n}\n\nstatic void omapfb_remove(struct platform_device *pdev)\n{\n\tstruct omapfb2_device *fbdev = platform_get_drvdata(pdev);\n\n\t \n\n\tomapfb_remove_sysfs(fbdev);\n\n\tomapfb_free_resources(fbdev);\n\n\tomapdss_compat_uninit();\n}\n\nstatic struct platform_driver omapfb_driver = {\n\t.probe\t\t= omapfb_probe,\n\t.remove_new     = omapfb_remove,\n\t.driver         = {\n\t\t.name   = \"omapfb\",\n\t},\n};\n\nmodule_param_named(mode, def_mode, charp, 0);\nmodule_param_named(vram, def_vram, charp, 0);\nmodule_param_named(rotate, def_rotate, int, 0);\nmodule_param_named(vrfb, def_vrfb, bool, 0);\nmodule_param_named(mirror, def_mirror, bool, 0);\n\nmodule_platform_driver(omapfb_driver);\n\nMODULE_ALIAS(\"platform:omapfb\");\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@nokia.com>\");\nMODULE_DESCRIPTION(\"OMAP2/3 Framebuffer\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}