{
  "module_name": "omapfb-ioctl.c",
  "hash_id": "31543a00c6e602f5ac8eeff5593504fb993f4efb00d7a1c2c55f2207cf91d611",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/omapfb-ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/fb.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/platform_device.h>\n#include <linux/mm.h>\n#include <linux/omapfb.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/sizes.h>\n\n#include <video/omapfb_dss.h>\n#include <video/omapvrfb.h>\n\n#include \"omapfb.h\"\n\nstatic u8 get_mem_idx(struct omapfb_info *ofbi)\n{\n\tif (ofbi->id == ofbi->region->id)\n\t\treturn 0;\n\n\treturn OMAPFB_MEM_IDX_ENABLED | ofbi->region->id;\n}\n\nstatic struct omapfb2_mem_region *get_mem_region(struct omapfb_info *ofbi,\n\t\t\t\t\t\t u8 mem_idx)\n{\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\n\tif (mem_idx & OMAPFB_MEM_IDX_ENABLED)\n\t\tmem_idx &= OMAPFB_MEM_IDX_MASK;\n\telse\n\t\tmem_idx = ofbi->id;\n\n\tif (mem_idx >= fbdev->num_fbs)\n\t\treturn NULL;\n\n\treturn &fbdev->regions[mem_idx];\n}\n\nstatic int omapfb_setup_plane(struct fb_info *fbi, struct omapfb_plane_info *pi)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omap_overlay *ovl;\n\tstruct omap_overlay_info old_info;\n\tstruct omapfb2_mem_region *old_rg, *new_rg;\n\tint r = 0;\n\n\tDBG(\"omapfb_setup_plane\\n\");\n\n\tif (ofbi->num_overlays == 0) {\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tovl = ofbi->overlays[0];\n\n\told_rg = ofbi->region;\n\tnew_rg = get_mem_region(ofbi, pi->mem_idx);\n\tif (!new_rg) {\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (old_rg->id < new_rg->id) {\n\t\tomapfb_get_mem_region(old_rg);\n\t\tomapfb_get_mem_region(new_rg);\n\t} else if (new_rg->id < old_rg->id) {\n\t\tomapfb_get_mem_region(new_rg);\n\t\tomapfb_get_mem_region(old_rg);\n\t} else\n\t\tomapfb_get_mem_region(old_rg);\n\n\tif (pi->enabled && !new_rg->size) {\n\t\t \n\t\tr = -EINVAL;\n\t\tgoto put_mem;\n\t}\n\n\tovl->get_overlay_info(ovl, &old_info);\n\n\tif (old_rg != new_rg) {\n\t\tofbi->region = new_rg;\n\t\tset_fb_fix(fbi);\n\t}\n\n\tif (!pi->enabled) {\n\t\tr = ovl->disable(ovl);\n\t\tif (r)\n\t\t\tgoto undo;\n\t}\n\n\tif (pi->enabled) {\n\t\tr = omapfb_setup_overlay(fbi, ovl, pi->pos_x, pi->pos_y,\n\t\t\tpi->out_width, pi->out_height);\n\t\tif (r)\n\t\t\tgoto undo;\n\t} else {\n\t\tstruct omap_overlay_info info;\n\n\t\tovl->get_overlay_info(ovl, &info);\n\n\t\tinfo.pos_x = pi->pos_x;\n\t\tinfo.pos_y = pi->pos_y;\n\t\tinfo.out_width = pi->out_width;\n\t\tinfo.out_height = pi->out_height;\n\n\t\tr = ovl->set_overlay_info(ovl, &info);\n\t\tif (r)\n\t\t\tgoto undo;\n\t}\n\n\tif (ovl->manager) {\n\t\tr = ovl->manager->apply(ovl->manager);\n\t\tif (r)\n\t\t\tgoto undo;\n\t}\n\n\tif (pi->enabled) {\n\t\tr = ovl->enable(ovl);\n\t\tif (r)\n\t\t\tgoto undo;\n\t}\n\n\t \n\tif (old_rg->id > new_rg->id) {\n\t\tomapfb_put_mem_region(old_rg);\n\t\tomapfb_put_mem_region(new_rg);\n\t} else if (new_rg->id > old_rg->id) {\n\t\tomapfb_put_mem_region(new_rg);\n\t\tomapfb_put_mem_region(old_rg);\n\t} else\n\t\tomapfb_put_mem_region(old_rg);\n\n\treturn 0;\n\n undo:\n\tif (old_rg != new_rg) {\n\t\tofbi->region = old_rg;\n\t\tset_fb_fix(fbi);\n\t}\n\n\tovl->set_overlay_info(ovl, &old_info);\n put_mem:\n\t \n\tif (old_rg->id > new_rg->id) {\n\t\tomapfb_put_mem_region(old_rg);\n\t\tomapfb_put_mem_region(new_rg);\n\t} else if (new_rg->id > old_rg->id) {\n\t\tomapfb_put_mem_region(new_rg);\n\t\tomapfb_put_mem_region(old_rg);\n\t} else\n\t\tomapfb_put_mem_region(old_rg);\n out:\n\tdev_err(fbdev->dev, \"setup_plane failed\\n\");\n\n\treturn r;\n}\n\nstatic int omapfb_query_plane(struct fb_info *fbi, struct omapfb_plane_info *pi)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\n\tif (ofbi->num_overlays == 0) {\n\t\tmemset(pi, 0, sizeof(*pi));\n\t} else {\n\t\tstruct omap_overlay *ovl;\n\t\tstruct omap_overlay_info ovli;\n\n\t\tovl = ofbi->overlays[0];\n\t\tovl->get_overlay_info(ovl, &ovli);\n\n\t\tpi->pos_x = ovli.pos_x;\n\t\tpi->pos_y = ovli.pos_y;\n\t\tpi->enabled = ovl->is_enabled(ovl);\n\t\tpi->channel_out = 0;  \n\t\tpi->mirror = 0;\n\t\tpi->mem_idx = get_mem_idx(ofbi);\n\t\tpi->out_width = ovli.out_width;\n\t\tpi->out_height = ovli.out_height;\n\t}\n\n\treturn 0;\n}\n\nstatic int omapfb_setup_mem(struct fb_info *fbi, struct omapfb_mem_info *mi)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omap_dss_device *display = fb2display(fbi);\n\tstruct omapfb2_mem_region *rg;\n\tint r = 0, i;\n\tsize_t size;\n\n\tif (mi->type != OMAPFB_MEMTYPE_SDRAM)\n\t\treturn -EINVAL;\n\n\tsize = PAGE_ALIGN(mi->size);\n\n\tif (display && display->driver->sync)\n\t\tdisplay->driver->sync(display);\n\n\trg = ofbi->region;\n\n\tdown_write_nested(&rg->lock, rg->id);\n\tatomic_inc(&rg->lock_count);\n\n\tif (rg->size == size && rg->type == mi->type)\n\t\tgoto out;\n\n\tif (atomic_read(&rg->map_count)) {\n\t\tr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\tstruct omapfb_info *ofbi2 = FB2OFB(fbdev->fbs[i]);\n\t\tint j;\n\n\t\tif (ofbi2->region != rg)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ofbi2->num_overlays; j++) {\n\t\t\tstruct omap_overlay *ovl;\n\t\t\tovl = ofbi2->overlays[j];\n\t\t\tif (ovl->is_enabled(ovl)) {\n\t\t\t\tr = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tr = omapfb_realloc_fbmem(fbi, size, mi->type);\n\tif (r) {\n\t\tdev_err(fbdev->dev, \"realloc fbmem failed\\n\");\n\t\tgoto out;\n\t}\n\n out:\n\tatomic_dec(&rg->lock_count);\n\tup_write(&rg->lock);\n\n\treturn r;\n}\n\nstatic int omapfb_query_mem(struct fb_info *fbi, struct omapfb_mem_info *mi)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_mem_region *rg;\n\n\trg = omapfb_get_mem_region(ofbi->region);\n\tmemset(mi, 0, sizeof(*mi));\n\n\tmi->size = rg->size;\n\tmi->type = rg->type;\n\n\tomapfb_put_mem_region(rg);\n\n\treturn 0;\n}\n\nstatic int omapfb_update_window(struct fb_info *fbi,\n\t\tu32 x, u32 y, u32 w, u32 h)\n{\n\tstruct omap_dss_device *display = fb2display(fbi);\n\tu16 dw, dh;\n\n\tif (!display)\n\t\treturn 0;\n\n\tif (w == 0 || h == 0)\n\t\treturn 0;\n\n\tdisplay->driver->get_resolution(display, &dw, &dh);\n\n\tif (x + w > dw || y + h > dh)\n\t\treturn -EINVAL;\n\n\treturn display->driver->update(display, x, y, w, h);\n}\n\nint omapfb_set_update_mode(struct fb_info *fbi,\n\t\t\t\t   enum omapfb_update_mode mode)\n{\n\tstruct omap_dss_device *display = fb2display(fbi);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omapfb_display_data *d;\n\tint r;\n\n\tif (!display)\n\t\treturn -EINVAL;\n\n\tif (mode != OMAPFB_AUTO_UPDATE && mode != OMAPFB_MANUAL_UPDATE)\n\t\treturn -EINVAL;\n\n\tomapfb_lock(fbdev);\n\n\td = get_display_data(fbdev, display);\n\n\tif (d->update_mode == mode) {\n\t\tomapfb_unlock(fbdev);\n\t\treturn 0;\n\t}\n\n\tr = 0;\n\n\tif (display->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE) {\n\t\tif (mode == OMAPFB_AUTO_UPDATE)\n\t\t\tomapfb_start_auto_update(fbdev, display);\n\t\telse  \n\t\t\tomapfb_stop_auto_update(fbdev, display);\n\n\t\td->update_mode = mode;\n\t} else {  \n\t\tif (mode == OMAPFB_MANUAL_UPDATE)\n\t\t\tr = -EINVAL;\n\t}\n\n\tomapfb_unlock(fbdev);\n\n\treturn r;\n}\n\nint omapfb_get_update_mode(struct fb_info *fbi,\n\t\tenum omapfb_update_mode *mode)\n{\n\tstruct omap_dss_device *display = fb2display(fbi);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omapfb_display_data *d;\n\n\tif (!display)\n\t\treturn -EINVAL;\n\n\tomapfb_lock(fbdev);\n\n\td = get_display_data(fbdev, display);\n\n\t*mode = d->update_mode;\n\n\tomapfb_unlock(fbdev);\n\n\treturn 0;\n}\n\n \nstatic struct omapfb_color_key omapfb_color_keys[2];\n\nstatic int _omapfb_set_color_key(struct omap_overlay_manager *mgr,\n\t\tstruct omapfb_color_key *ck)\n{\n\tstruct omap_overlay_manager_info info;\n\tenum omap_dss_trans_key_type kt;\n\tint r;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\tif (ck->key_type == OMAPFB_COLOR_KEY_DISABLED) {\n\t\tinfo.trans_enabled = false;\n\t\tomapfb_color_keys[mgr->id] = *ck;\n\n\t\tr = mgr->set_manager_info(mgr, &info);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = mgr->apply(mgr);\n\n\t\treturn r;\n\t}\n\n\tswitch (ck->key_type) {\n\tcase OMAPFB_COLOR_KEY_GFX_DST:\n\t\tkt = OMAP_DSS_COLOR_KEY_GFX_DST;\n\t\tbreak;\n\tcase OMAPFB_COLOR_KEY_VID_SRC:\n\t\tkt = OMAP_DSS_COLOR_KEY_VID_SRC;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tinfo.default_color = ck->background;\n\tinfo.trans_key = ck->trans_key;\n\tinfo.trans_key_type = kt;\n\tinfo.trans_enabled = true;\n\n\tomapfb_color_keys[mgr->id] = *ck;\n\n\tr = mgr->set_manager_info(mgr, &info);\n\tif (r)\n\t\treturn r;\n\n\tr = mgr->apply(mgr);\n\n\treturn r;\n}\n\nstatic int omapfb_set_color_key(struct fb_info *fbi,\n\t\tstruct omapfb_color_key *ck)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tint r;\n\tint i;\n\tstruct omap_overlay_manager *mgr = NULL;\n\n\tomapfb_lock(fbdev);\n\n\tfor (i = 0; i < ofbi->num_overlays; i++) {\n\t\tif (ofbi->overlays[i]->manager) {\n\t\t\tmgr = ofbi->overlays[i]->manager;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!mgr) {\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tr = _omapfb_set_color_key(mgr, ck);\nerr:\n\tomapfb_unlock(fbdev);\n\n\treturn r;\n}\n\nstatic int omapfb_get_color_key(struct fb_info *fbi,\n\t\tstruct omapfb_color_key *ck)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omap_overlay_manager *mgr = NULL;\n\tint r = 0;\n\tint i;\n\n\tomapfb_lock(fbdev);\n\n\tfor (i = 0; i < ofbi->num_overlays; i++) {\n\t\tif (ofbi->overlays[i]->manager) {\n\t\t\tmgr = ofbi->overlays[i]->manager;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!mgr) {\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t*ck = omapfb_color_keys[mgr->id];\nerr:\n\tomapfb_unlock(fbdev);\n\n\treturn r;\n}\n\nstatic int omapfb_memory_read(struct fb_info *fbi,\n\t\tstruct omapfb_memory_read *mr)\n{\n\tstruct omap_dss_device *display = fb2display(fbi);\n\tvoid *buf;\n\tint r;\n\n\tif (!display || !display->driver->memory_read)\n\t\treturn -ENOENT;\n\n\tif (mr->w > 4096 || mr->h > 4096)\n\t\treturn -EINVAL;\n\n\tif (mr->w * mr->h * 3 > mr->buffer_size)\n\t\treturn -EINVAL;\n\n\tbuf = vmalloc(mr->buffer_size);\n\tif (!buf) {\n\t\tDBG(\"vmalloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tr = display->driver->memory_read(display, buf, mr->buffer_size,\n\t\t\tmr->x, mr->y, mr->w, mr->h);\n\n\tif (r > 0) {\n\t\tif (copy_to_user(mr->buffer, buf, r))\n\t\t\tr = -EFAULT;\n\t}\n\n\tvfree(buf);\n\n\treturn r;\n}\n\nstatic int omapfb_get_ovl_colormode(struct omapfb2_device *fbdev,\n\t\t\t     struct omapfb_ovl_colormode *mode)\n{\n\tint ovl_idx = mode->overlay_idx;\n\tint mode_idx = mode->mode_idx;\n\tstruct omap_overlay *ovl;\n\tenum omap_color_mode supported_modes;\n\tstruct fb_var_screeninfo var;\n\tint i;\n\n\tif (ovl_idx >= fbdev->num_overlays)\n\t\treturn -ENODEV;\n\tovl = fbdev->overlays[ovl_idx];\n\tsupported_modes = ovl->supported_modes;\n\n\tmode_idx = mode->mode_idx;\n\n\tfor (i = 0; i < sizeof(supported_modes) * 8; i++) {\n\t\tif (!(supported_modes & (1 << i)))\n\t\t\tcontinue;\n\t\t \n\t\tif (dss_mode_to_fb_mode(1 << i, &var) < 0)\n\t\t\tcontinue;\n\n\t\tmode_idx--;\n\t\tif (mode_idx < 0)\n\t\t\tbreak;\n\t}\n\n\tif (i == sizeof(supported_modes) * 8)\n\t\treturn -ENOENT;\n\n\tmode->bits_per_pixel = var.bits_per_pixel;\n\tmode->nonstd = var.nonstd;\n\tmode->red = var.red;\n\tmode->green = var.green;\n\tmode->blue = var.blue;\n\tmode->transp = var.transp;\n\n\treturn 0;\n}\n\nstatic int omapfb_wait_for_go(struct fb_info *fbi)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tint r = 0;\n\tint i;\n\n\tfor (i = 0; i < ofbi->num_overlays; ++i) {\n\t\tstruct omap_overlay *ovl = ofbi->overlays[i];\n\t\tr = ovl->wait_for_go(ovl);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nint omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)\n{\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omap_dss_device *display = fb2display(fbi);\n\tstruct omap_overlay_manager *mgr;\n\n\tunion {\n\t\tstruct omapfb_update_window_old\tuwnd_o;\n\t\tstruct omapfb_update_window\tuwnd;\n\t\tstruct omapfb_plane_info\tplane_info;\n\t\tstruct omapfb_caps\t\tcaps;\n\t\tstruct omapfb_mem_info          mem_info;\n\t\tstruct omapfb_color_key\t\tcolor_key;\n\t\tstruct omapfb_ovl_colormode\tovl_colormode;\n\t\tenum omapfb_update_mode\t\tupdate_mode;\n\t\tint test_num;\n\t\tstruct omapfb_memory_read\tmemory_read;\n\t\tstruct omapfb_vram_info\t\tvram_info;\n\t\tstruct omapfb_tearsync_info\ttearsync_info;\n\t\tstruct omapfb_display_info\tdisplay_info;\n\t\tu32\t\t\t\tcrt;\n\t} p;\n\n\tint r = 0;\n\n\tmemset(&p, 0, sizeof(p));\n\n\tswitch (cmd) {\n\tcase OMAPFB_SYNC_GFX:\n\t\tDBG(\"ioctl SYNC_GFX\\n\");\n\t\tif (!display || !display->driver->sync) {\n\t\t\t \n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tr = display->driver->sync(display);\n\t\tbreak;\n\n\tcase OMAPFB_UPDATE_WINDOW_OLD:\n\t\tDBG(\"ioctl UPDATE_WINDOW_OLD\\n\");\n\t\tif (!display || !display->driver->update) {\n\t\t\tr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_user(&p.uwnd_o,\n\t\t\t\t\t(void __user *)arg,\n\t\t\t\t\tsizeof(p.uwnd_o))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = omapfb_update_window(fbi, p.uwnd_o.x, p.uwnd_o.y,\n\t\t\t\tp.uwnd_o.width, p.uwnd_o.height);\n\t\tbreak;\n\n\tcase OMAPFB_UPDATE_WINDOW:\n\t\tDBG(\"ioctl UPDATE_WINDOW\\n\");\n\t\tif (!display || !display->driver->update) {\n\t\t\tr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_user(&p.uwnd, (void __user *)arg,\n\t\t\t\t\tsizeof(p.uwnd))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = omapfb_update_window(fbi, p.uwnd.x, p.uwnd.y,\n\t\t\t\tp.uwnd.width, p.uwnd.height);\n\t\tbreak;\n\n\tcase OMAPFB_SETUP_PLANE:\n\t\tDBG(\"ioctl SETUP_PLANE\\n\");\n\t\tif (copy_from_user(&p.plane_info, (void __user *)arg,\n\t\t\t\t\tsizeof(p.plane_info)))\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tr = omapfb_setup_plane(fbi, &p.plane_info);\n\t\tbreak;\n\n\tcase OMAPFB_QUERY_PLANE:\n\t\tDBG(\"ioctl QUERY_PLANE\\n\");\n\t\tr = omapfb_query_plane(fbi, &p.plane_info);\n\t\tif (r < 0)\n\t\t\tbreak;\n\t\tif (copy_to_user((void __user *)arg, &p.plane_info,\n\t\t\t\t\tsizeof(p.plane_info)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\n\tcase OMAPFB_SETUP_MEM:\n\t\tDBG(\"ioctl SETUP_MEM\\n\");\n\t\tif (copy_from_user(&p.mem_info, (void __user *)arg,\n\t\t\t\t\tsizeof(p.mem_info)))\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tr = omapfb_setup_mem(fbi, &p.mem_info);\n\t\tbreak;\n\n\tcase OMAPFB_QUERY_MEM:\n\t\tDBG(\"ioctl QUERY_MEM\\n\");\n\t\tr = omapfb_query_mem(fbi, &p.mem_info);\n\t\tif (r < 0)\n\t\t\tbreak;\n\t\tif (copy_to_user((void __user *)arg, &p.mem_info,\n\t\t\t\t\tsizeof(p.mem_info)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\n\tcase OMAPFB_GET_CAPS:\n\t\tDBG(\"ioctl GET_CAPS\\n\");\n\t\tif (!display) {\n\t\t\tr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&p.caps, 0, sizeof(p.caps));\n\t\tif (display->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE)\n\t\t\tp.caps.ctrl |= OMAPFB_CAPS_MANUAL_UPDATE;\n\t\tif (display->caps & OMAP_DSS_DISPLAY_CAP_TEAR_ELIM)\n\t\t\tp.caps.ctrl |= OMAPFB_CAPS_TEARSYNC;\n\n\t\tif (copy_to_user((void __user *)arg, &p.caps, sizeof(p.caps)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\n\tcase OMAPFB_GET_OVERLAY_COLORMODE:\n\t\tDBG(\"ioctl GET_OVERLAY_COLORMODE\\n\");\n\t\tif (copy_from_user(&p.ovl_colormode, (void __user *)arg,\n\t\t\t\t   sizeof(p.ovl_colormode))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tr = omapfb_get_ovl_colormode(fbdev, &p.ovl_colormode);\n\t\tif (r < 0)\n\t\t\tbreak;\n\t\tif (copy_to_user((void __user *)arg, &p.ovl_colormode,\n\t\t\t\t sizeof(p.ovl_colormode)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\n\tcase OMAPFB_SET_UPDATE_MODE:\n\t\tDBG(\"ioctl SET_UPDATE_MODE\\n\");\n\t\tif (get_user(p.update_mode, (int __user *)arg))\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tr = omapfb_set_update_mode(fbi, p.update_mode);\n\t\tbreak;\n\n\tcase OMAPFB_GET_UPDATE_MODE:\n\t\tDBG(\"ioctl GET_UPDATE_MODE\\n\");\n\t\tr = omapfb_get_update_mode(fbi, &p.update_mode);\n\t\tif (r)\n\t\t\tbreak;\n\t\tif (put_user(p.update_mode,\n\t\t\t\t\t(enum omapfb_update_mode __user *)arg))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\n\tcase OMAPFB_SET_COLOR_KEY:\n\t\tDBG(\"ioctl SET_COLOR_KEY\\n\");\n\t\tif (copy_from_user(&p.color_key, (void __user *)arg,\n\t\t\t\t   sizeof(p.color_key)))\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tr = omapfb_set_color_key(fbi, &p.color_key);\n\t\tbreak;\n\n\tcase OMAPFB_GET_COLOR_KEY:\n\t\tDBG(\"ioctl GET_COLOR_KEY\\n\");\n\t\tr = omapfb_get_color_key(fbi, &p.color_key);\n\t\tif (r)\n\t\t\tbreak;\n\t\tif (copy_to_user((void __user *)arg, &p.color_key,\n\t\t\t\t sizeof(p.color_key)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\n\tcase FBIO_WAITFORVSYNC:\n\t\tif (get_user(p.crt, (__u32 __user *)arg)) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (p.crt != 0) {\n\t\t\tr = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tcase OMAPFB_WAITFORVSYNC:\n\t\tDBG(\"ioctl WAITFORVSYNC\\n\");\n\n\t\tif (!display) {\n\t\t\tr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmgr = omapdss_find_mgr_from_display(display);\n\t\tif (!mgr) {\n\t\t\tr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = mgr->wait_for_vsync(mgr);\n\t\tbreak;\n\n\tcase OMAPFB_WAITFORGO:\n\t\tDBG(\"ioctl WAITFORGO\\n\");\n\t\tif (!display) {\n\t\t\tr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = omapfb_wait_for_go(fbi);\n\t\tbreak;\n\n\t \n\tcase OMAPFB_LCD_TEST:\n\t\tDBG(\"ioctl LCD_TEST\\n\");\n\t\tif (get_user(p.test_num, (int __user *)arg)) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!display || !display->driver->run_test) {\n\t\t\tr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = display->driver->run_test(display, p.test_num);\n\n\t\tbreak;\n\n\tcase OMAPFB_CTRL_TEST:\n\t\tDBG(\"ioctl CTRL_TEST\\n\");\n\t\tif (get_user(p.test_num, (int __user *)arg)) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!display || !display->driver->run_test) {\n\t\t\tr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = display->driver->run_test(display, p.test_num);\n\n\t\tbreak;\n\n\tcase OMAPFB_MEMORY_READ:\n\t\tDBG(\"ioctl MEMORY_READ\\n\");\n\n\t\tif (copy_from_user(&p.memory_read, (void __user *)arg,\n\t\t\t\t\tsizeof(p.memory_read))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = omapfb_memory_read(fbi, &p.memory_read);\n\n\t\tbreak;\n\n\tcase OMAPFB_GET_VRAM_INFO: {\n\t\tDBG(\"ioctl GET_VRAM_INFO\\n\");\n\n\t\t \n\t\tp.vram_info.total = SZ_1M * 64;\n\t\tp.vram_info.free = SZ_1M * 64;\n\t\tp.vram_info.largest_free_block = SZ_1M * 64;\n\n\t\tif (copy_to_user((void __user *)arg, &p.vram_info,\n\t\t\t\t\tsizeof(p.vram_info)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\t}\n\n\tcase OMAPFB_SET_TEARSYNC: {\n\t\tDBG(\"ioctl SET_TEARSYNC\\n\");\n\n\t\tif (copy_from_user(&p.tearsync_info, (void __user *)arg,\n\t\t\t\t\tsizeof(p.tearsync_info))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!display || !display->driver->enable_te) {\n\t\t\tr = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = display->driver->enable_te(display,\n\t\t\t\t!!p.tearsync_info.enabled);\n\n\t\tbreak;\n\t}\n\n\tcase OMAPFB_GET_DISPLAY_INFO: {\n\t\tu16 xres, yres;\n\n\t\tDBG(\"ioctl GET_DISPLAY_INFO\\n\");\n\n\t\tif (display == NULL) {\n\t\t\tr = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tdisplay->driver->get_resolution(display, &xres, &yres);\n\n\t\tp.display_info.xres = xres;\n\t\tp.display_info.yres = yres;\n\n\t\tif (display->driver->get_dimensions) {\n\t\t\tu32 w, h;\n\t\t\tdisplay->driver->get_dimensions(display, &w, &h);\n\t\t\tp.display_info.width = w;\n\t\t\tp.display_info.height = h;\n\t\t} else {\n\t\t\tp.display_info.width = 0;\n\t\t\tp.display_info.height = 0;\n\t\t}\n\n\t\tif (copy_to_user((void __user *)arg, &p.display_info,\n\t\t\t\t\tsizeof(p.display_info)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tdev_err(fbdev->dev, \"Unknown ioctl 0x%x\\n\", cmd);\n\t\tr = -EINVAL;\n\t}\n\n\tif (r < 0)\n\t\tDBG(\"ioctl failed: %d\\n\", r);\n\n\treturn r;\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}