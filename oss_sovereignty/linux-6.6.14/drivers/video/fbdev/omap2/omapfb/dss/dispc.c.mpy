{
  "module_name": "dispc.c",
  "hash_id": "39f55757d4d04b5ad910909d9bb1bea0697b1948324178fa9ba0468317c77b34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/dispc.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"DISPC\"\n\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/hardirq.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/sizes.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n#include <linux/component.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"dss_features.h\"\n#include \"dispc.h\"\n\n \n#define DISPC_SZ_REGS\t\t\tSZ_4K\n\nenum omap_burst_size {\n\tBURST_SIZE_X2 = 0,\n\tBURST_SIZE_X4 = 1,\n\tBURST_SIZE_X8 = 2,\n};\n\n#define REG_GET(idx, start, end) \\\n\tFLD_GET(dispc_read_reg(idx), start, end)\n\n#define REG_FLD_MOD(idx, val, start, end)\t\t\t\t\\\n\tdispc_write_reg(idx, FLD_MOD(dispc_read_reg(idx), val, start, end))\n\nstruct dispc_features {\n\tu8 sw_start;\n\tu8 fp_start;\n\tu8 bp_start;\n\tu16 sw_max;\n\tu16 vp_max;\n\tu16 hp_max;\n\tu8 mgr_width_start;\n\tu8 mgr_height_start;\n\tu16 mgr_width_max;\n\tu16 mgr_height_max;\n\tunsigned long max_lcd_pclk;\n\tunsigned long max_tv_pclk;\n\tint (*calc_scaling) (unsigned long pclk, unsigned long lclk,\n\t\tconst struct omap_video_timings *mgr_timings,\n\t\tu16 width, u16 height, u16 out_width, u16 out_height,\n\t\tenum omap_color_mode color_mode, bool *five_taps,\n\t\tint *x_predecim, int *y_predecim, int *decim_x, int *decim_y,\n\t\tu16 pos_x, unsigned long *core_clk, bool mem_to_mem);\n\tunsigned long (*calc_core_clk) (unsigned long pclk,\n\t\tu16 width, u16 height, u16 out_width, u16 out_height,\n\t\tbool mem_to_mem);\n\tu8 num_fifos;\n\n\t \n\tbool gfx_fifo_workaround:1;\n\n\t \n\tbool no_framedone_tv:1;\n\n\t \n\tbool mstandby_workaround:1;\n\n\tbool set_max_preload:1;\n\n\t \n\tbool last_pixel_inc_missing:1;\n\n\t \n\tbool supports_sync_align:1;\n\n\tbool has_writeback:1;\n};\n\n#define DISPC_MAX_NR_FIFOS 5\n\nstatic struct {\n\tstruct platform_device *pdev;\n\tvoid __iomem    *base;\n\n\tint irq;\n\tirq_handler_t user_handler;\n\tvoid *user_data;\n\n\tunsigned long core_clk_rate;\n\tunsigned long tv_pclk_rate;\n\n\tu32 fifo_size[DISPC_MAX_NR_FIFOS];\n\t \n\tint fifo_assignment[DISPC_MAX_NR_FIFOS];\n\n\tbool\t\tctx_valid;\n\tu32\t\tctx[DISPC_SZ_REGS / sizeof(u32)];\n\n\tconst struct dispc_features *feat;\n\n\tbool is_enabled;\n\n\tstruct regmap *syscon_pol;\n\tu32 syscon_pol_offset;\n\n\t \n\tspinlock_t control_lock;\n} dispc;\n\nenum omap_color_component {\n\t \n\tDISPC_COLOR_COMPONENT_RGB_Y\t\t= 1 << 0,\n\t \n\tDISPC_COLOR_COMPONENT_UV\t\t= 1 << 1,\n};\n\nenum mgr_reg_fields {\n\tDISPC_MGR_FLD_ENABLE,\n\tDISPC_MGR_FLD_STNTFT,\n\tDISPC_MGR_FLD_GO,\n\tDISPC_MGR_FLD_TFTDATALINES,\n\tDISPC_MGR_FLD_STALLMODE,\n\tDISPC_MGR_FLD_TCKENABLE,\n\tDISPC_MGR_FLD_TCKSELECTION,\n\tDISPC_MGR_FLD_CPR,\n\tDISPC_MGR_FLD_FIFOHANDCHECK,\n\t \n\tDISPC_MGR_FLD_NUM,\n};\n\nstruct dispc_reg_field {\n\tu16 reg;\n\tu8 high;\n\tu8 low;\n};\n\nstatic const struct {\n\tconst char *name;\n\tu32 vsync_irq;\n\tu32 framedone_irq;\n\tu32 sync_lost_irq;\n\tstruct dispc_reg_field reg_desc[DISPC_MGR_FLD_NUM];\n} mgr_desc[] = {\n\t[OMAP_DSS_CHANNEL_LCD] = {\n\t\t.name\t\t= \"LCD\",\n\t\t.vsync_irq\t= DISPC_IRQ_VSYNC,\n\t\t.framedone_irq\t= DISPC_IRQ_FRAMEDONE,\n\t\t.sync_lost_irq\t= DISPC_IRQ_SYNC_LOST,\n\t\t.reg_desc\t= {\n\t\t\t[DISPC_MGR_FLD_ENABLE]\t\t= { DISPC_CONTROL,  0,  0 },\n\t\t\t[DISPC_MGR_FLD_STNTFT]\t\t= { DISPC_CONTROL,  3,  3 },\n\t\t\t[DISPC_MGR_FLD_GO]\t\t= { DISPC_CONTROL,  5,  5 },\n\t\t\t[DISPC_MGR_FLD_TFTDATALINES]\t= { DISPC_CONTROL,  9,  8 },\n\t\t\t[DISPC_MGR_FLD_STALLMODE]\t= { DISPC_CONTROL, 11, 11 },\n\t\t\t[DISPC_MGR_FLD_TCKENABLE]\t= { DISPC_CONFIG,  10, 10 },\n\t\t\t[DISPC_MGR_FLD_TCKSELECTION]\t= { DISPC_CONFIG,  11, 11 },\n\t\t\t[DISPC_MGR_FLD_CPR]\t\t= { DISPC_CONFIG,  15, 15 },\n\t\t\t[DISPC_MGR_FLD_FIFOHANDCHECK]\t= { DISPC_CONFIG,  16, 16 },\n\t\t},\n\t},\n\t[OMAP_DSS_CHANNEL_DIGIT] = {\n\t\t.name\t\t= \"DIGIT\",\n\t\t.vsync_irq\t= DISPC_IRQ_EVSYNC_ODD | DISPC_IRQ_EVSYNC_EVEN,\n\t\t.framedone_irq\t= DISPC_IRQ_FRAMEDONETV,\n\t\t.sync_lost_irq\t= DISPC_IRQ_SYNC_LOST_DIGIT,\n\t\t.reg_desc\t= {\n\t\t\t[DISPC_MGR_FLD_ENABLE]\t\t= { DISPC_CONTROL,  1,  1 },\n\t\t\t[DISPC_MGR_FLD_STNTFT]\t\t= { },\n\t\t\t[DISPC_MGR_FLD_GO]\t\t= { DISPC_CONTROL,  6,  6 },\n\t\t\t[DISPC_MGR_FLD_TFTDATALINES]\t= { },\n\t\t\t[DISPC_MGR_FLD_STALLMODE]\t= { },\n\t\t\t[DISPC_MGR_FLD_TCKENABLE]\t= { DISPC_CONFIG,  12, 12 },\n\t\t\t[DISPC_MGR_FLD_TCKSELECTION]\t= { DISPC_CONFIG,  13, 13 },\n\t\t\t[DISPC_MGR_FLD_CPR]\t\t= { },\n\t\t\t[DISPC_MGR_FLD_FIFOHANDCHECK]\t= { DISPC_CONFIG,  16, 16 },\n\t\t},\n\t},\n\t[OMAP_DSS_CHANNEL_LCD2] = {\n\t\t.name\t\t= \"LCD2\",\n\t\t.vsync_irq\t= DISPC_IRQ_VSYNC2,\n\t\t.framedone_irq\t= DISPC_IRQ_FRAMEDONE2,\n\t\t.sync_lost_irq\t= DISPC_IRQ_SYNC_LOST2,\n\t\t.reg_desc\t= {\n\t\t\t[DISPC_MGR_FLD_ENABLE]\t\t= { DISPC_CONTROL2,  0,  0 },\n\t\t\t[DISPC_MGR_FLD_STNTFT]\t\t= { DISPC_CONTROL2,  3,  3 },\n\t\t\t[DISPC_MGR_FLD_GO]\t\t= { DISPC_CONTROL2,  5,  5 },\n\t\t\t[DISPC_MGR_FLD_TFTDATALINES]\t= { DISPC_CONTROL2,  9,  8 },\n\t\t\t[DISPC_MGR_FLD_STALLMODE]\t= { DISPC_CONTROL2, 11, 11 },\n\t\t\t[DISPC_MGR_FLD_TCKENABLE]\t= { DISPC_CONFIG2,  10, 10 },\n\t\t\t[DISPC_MGR_FLD_TCKSELECTION]\t= { DISPC_CONFIG2,  11, 11 },\n\t\t\t[DISPC_MGR_FLD_CPR]\t\t= { DISPC_CONFIG2,  15, 15 },\n\t\t\t[DISPC_MGR_FLD_FIFOHANDCHECK]\t= { DISPC_CONFIG2,  16, 16 },\n\t\t},\n\t},\n\t[OMAP_DSS_CHANNEL_LCD3] = {\n\t\t.name\t\t= \"LCD3\",\n\t\t.vsync_irq\t= DISPC_IRQ_VSYNC3,\n\t\t.framedone_irq\t= DISPC_IRQ_FRAMEDONE3,\n\t\t.sync_lost_irq\t= DISPC_IRQ_SYNC_LOST3,\n\t\t.reg_desc\t= {\n\t\t\t[DISPC_MGR_FLD_ENABLE]\t\t= { DISPC_CONTROL3,  0,  0 },\n\t\t\t[DISPC_MGR_FLD_STNTFT]\t\t= { DISPC_CONTROL3,  3,  3 },\n\t\t\t[DISPC_MGR_FLD_GO]\t\t= { DISPC_CONTROL3,  5,  5 },\n\t\t\t[DISPC_MGR_FLD_TFTDATALINES]\t= { DISPC_CONTROL3,  9,  8 },\n\t\t\t[DISPC_MGR_FLD_STALLMODE]\t= { DISPC_CONTROL3, 11, 11 },\n\t\t\t[DISPC_MGR_FLD_TCKENABLE]\t= { DISPC_CONFIG3,  10, 10 },\n\t\t\t[DISPC_MGR_FLD_TCKSELECTION]\t= { DISPC_CONFIG3,  11, 11 },\n\t\t\t[DISPC_MGR_FLD_CPR]\t\t= { DISPC_CONFIG3,  15, 15 },\n\t\t\t[DISPC_MGR_FLD_FIFOHANDCHECK]\t= { DISPC_CONFIG3,  16, 16 },\n\t\t},\n\t},\n};\n\nstruct color_conv_coef {\n\tint ry, rcr, rcb, gy, gcr, gcb, by, bcr, bcb;\n\tint full_range;\n};\n\nstatic unsigned long dispc_fclk_rate(void);\nstatic unsigned long dispc_core_clk_rate(void);\nstatic unsigned long dispc_mgr_lclk_rate(enum omap_channel channel);\nstatic unsigned long dispc_mgr_pclk_rate(enum omap_channel channel);\n\nstatic unsigned long dispc_plane_pclk_rate(enum omap_plane plane);\nstatic unsigned long dispc_plane_lclk_rate(enum omap_plane plane);\n\nstatic inline void dispc_write_reg(const u16 idx, u32 val)\n{\n\t__raw_writel(val, dispc.base + idx);\n}\n\nstatic inline u32 dispc_read_reg(const u16 idx)\n{\n\treturn __raw_readl(dispc.base + idx);\n}\n\nstatic u32 mgr_fld_read(enum omap_channel channel, enum mgr_reg_fields regfld)\n{\n\tconst struct dispc_reg_field rfld = mgr_desc[channel].reg_desc[regfld];\n\treturn REG_GET(rfld.reg, rfld.high, rfld.low);\n}\n\nstatic void mgr_fld_write(enum omap_channel channel,\n\t\t\t\t\tenum mgr_reg_fields regfld, int val) {\n\tconst struct dispc_reg_field rfld = mgr_desc[channel].reg_desc[regfld];\n\tconst bool need_lock = rfld.reg == DISPC_CONTROL || rfld.reg == DISPC_CONFIG;\n\tunsigned long flags;\n\n\tif (need_lock)\n\t\tspin_lock_irqsave(&dispc.control_lock, flags);\n\n\tREG_FLD_MOD(rfld.reg, val, rfld.high, rfld.low);\n\n\tif (need_lock)\n\t\tspin_unlock_irqrestore(&dispc.control_lock, flags);\n}\n\n#define SR(reg) \\\n\tdispc.ctx[DISPC_##reg / sizeof(u32)] = dispc_read_reg(DISPC_##reg)\n#define RR(reg) \\\n\tdispc_write_reg(DISPC_##reg, dispc.ctx[DISPC_##reg / sizeof(u32)])\n\nstatic void dispc_save_context(void)\n{\n\tint i, j;\n\n\tDSSDBG(\"dispc_save_context\\n\");\n\n\tSR(IRQENABLE);\n\tSR(CONTROL);\n\tSR(CONFIG);\n\tSR(LINE_NUMBER);\n\tif (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||\n\t\t\tdss_has_feature(FEAT_ALPHA_FREE_ZORDER))\n\t\tSR(GLOBAL_ALPHA);\n\tif (dss_has_feature(FEAT_MGR_LCD2)) {\n\t\tSR(CONTROL2);\n\t\tSR(CONFIG2);\n\t}\n\tif (dss_has_feature(FEAT_MGR_LCD3)) {\n\t\tSR(CONTROL3);\n\t\tSR(CONFIG3);\n\t}\n\n\tfor (i = 0; i < dss_feat_get_num_mgrs(); i++) {\n\t\tSR(DEFAULT_COLOR(i));\n\t\tSR(TRANS_COLOR(i));\n\t\tSR(SIZE_MGR(i));\n\t\tif (i == OMAP_DSS_CHANNEL_DIGIT)\n\t\t\tcontinue;\n\t\tSR(TIMING_H(i));\n\t\tSR(TIMING_V(i));\n\t\tSR(POL_FREQ(i));\n\t\tSR(DIVISORo(i));\n\n\t\tSR(DATA_CYCLE1(i));\n\t\tSR(DATA_CYCLE2(i));\n\t\tSR(DATA_CYCLE3(i));\n\n\t\tif (dss_has_feature(FEAT_CPR)) {\n\t\t\tSR(CPR_COEF_R(i));\n\t\t\tSR(CPR_COEF_G(i));\n\t\t\tSR(CPR_COEF_B(i));\n\t\t}\n\t}\n\n\tfor (i = 0; i < dss_feat_get_num_ovls(); i++) {\n\t\tSR(OVL_BA0(i));\n\t\tSR(OVL_BA1(i));\n\t\tSR(OVL_POSITION(i));\n\t\tSR(OVL_SIZE(i));\n\t\tSR(OVL_ATTRIBUTES(i));\n\t\tSR(OVL_FIFO_THRESHOLD(i));\n\t\tSR(OVL_ROW_INC(i));\n\t\tSR(OVL_PIXEL_INC(i));\n\t\tif (dss_has_feature(FEAT_PRELOAD))\n\t\t\tSR(OVL_PRELOAD(i));\n\t\tif (i == OMAP_DSS_GFX) {\n\t\t\tSR(OVL_WINDOW_SKIP(i));\n\t\t\tSR(OVL_TABLE_BA(i));\n\t\t\tcontinue;\n\t\t}\n\t\tSR(OVL_FIR(i));\n\t\tSR(OVL_PICTURE_SIZE(i));\n\t\tSR(OVL_ACCU0(i));\n\t\tSR(OVL_ACCU1(i));\n\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tSR(OVL_FIR_COEF_H(i, j));\n\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tSR(OVL_FIR_COEF_HV(i, j));\n\n\t\tfor (j = 0; j < 5; j++)\n\t\t\tSR(OVL_CONV_COEF(i, j));\n\n\t\tif (dss_has_feature(FEAT_FIR_COEF_V)) {\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tSR(OVL_FIR_COEF_V(i, j));\n\t\t}\n\n\t\tif (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {\n\t\t\tSR(OVL_BA0_UV(i));\n\t\t\tSR(OVL_BA1_UV(i));\n\t\t\tSR(OVL_FIR2(i));\n\t\t\tSR(OVL_ACCU2_0(i));\n\t\t\tSR(OVL_ACCU2_1(i));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tSR(OVL_FIR_COEF_H2(i, j));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tSR(OVL_FIR_COEF_HV2(i, j));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tSR(OVL_FIR_COEF_V2(i, j));\n\t\t}\n\t\tif (dss_has_feature(FEAT_ATTR2))\n\t\t\tSR(OVL_ATTRIBUTES2(i));\n\t}\n\n\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n\t\tSR(DIVISOR);\n\n\tdispc.ctx_valid = true;\n\n\tDSSDBG(\"context saved\\n\");\n}\n\nstatic void dispc_restore_context(void)\n{\n\tint i, j;\n\n\tDSSDBG(\"dispc_restore_context\\n\");\n\n\tif (!dispc.ctx_valid)\n\t\treturn;\n\n\t \n\t \n\tRR(CONFIG);\n\tRR(LINE_NUMBER);\n\tif (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||\n\t\t\tdss_has_feature(FEAT_ALPHA_FREE_ZORDER))\n\t\tRR(GLOBAL_ALPHA);\n\tif (dss_has_feature(FEAT_MGR_LCD2))\n\t\tRR(CONFIG2);\n\tif (dss_has_feature(FEAT_MGR_LCD3))\n\t\tRR(CONFIG3);\n\n\tfor (i = 0; i < dss_feat_get_num_mgrs(); i++) {\n\t\tRR(DEFAULT_COLOR(i));\n\t\tRR(TRANS_COLOR(i));\n\t\tRR(SIZE_MGR(i));\n\t\tif (i == OMAP_DSS_CHANNEL_DIGIT)\n\t\t\tcontinue;\n\t\tRR(TIMING_H(i));\n\t\tRR(TIMING_V(i));\n\t\tRR(POL_FREQ(i));\n\t\tRR(DIVISORo(i));\n\n\t\tRR(DATA_CYCLE1(i));\n\t\tRR(DATA_CYCLE2(i));\n\t\tRR(DATA_CYCLE3(i));\n\n\t\tif (dss_has_feature(FEAT_CPR)) {\n\t\t\tRR(CPR_COEF_R(i));\n\t\t\tRR(CPR_COEF_G(i));\n\t\t\tRR(CPR_COEF_B(i));\n\t\t}\n\t}\n\n\tfor (i = 0; i < dss_feat_get_num_ovls(); i++) {\n\t\tRR(OVL_BA0(i));\n\t\tRR(OVL_BA1(i));\n\t\tRR(OVL_POSITION(i));\n\t\tRR(OVL_SIZE(i));\n\t\tRR(OVL_ATTRIBUTES(i));\n\t\tRR(OVL_FIFO_THRESHOLD(i));\n\t\tRR(OVL_ROW_INC(i));\n\t\tRR(OVL_PIXEL_INC(i));\n\t\tif (dss_has_feature(FEAT_PRELOAD))\n\t\t\tRR(OVL_PRELOAD(i));\n\t\tif (i == OMAP_DSS_GFX) {\n\t\t\tRR(OVL_WINDOW_SKIP(i));\n\t\t\tRR(OVL_TABLE_BA(i));\n\t\t\tcontinue;\n\t\t}\n\t\tRR(OVL_FIR(i));\n\t\tRR(OVL_PICTURE_SIZE(i));\n\t\tRR(OVL_ACCU0(i));\n\t\tRR(OVL_ACCU1(i));\n\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tRR(OVL_FIR_COEF_H(i, j));\n\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tRR(OVL_FIR_COEF_HV(i, j));\n\n\t\tfor (j = 0; j < 5; j++)\n\t\t\tRR(OVL_CONV_COEF(i, j));\n\n\t\tif (dss_has_feature(FEAT_FIR_COEF_V)) {\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tRR(OVL_FIR_COEF_V(i, j));\n\t\t}\n\n\t\tif (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {\n\t\t\tRR(OVL_BA0_UV(i));\n\t\t\tRR(OVL_BA1_UV(i));\n\t\t\tRR(OVL_FIR2(i));\n\t\t\tRR(OVL_ACCU2_0(i));\n\t\t\tRR(OVL_ACCU2_1(i));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tRR(OVL_FIR_COEF_H2(i, j));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tRR(OVL_FIR_COEF_HV2(i, j));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tRR(OVL_FIR_COEF_V2(i, j));\n\t\t}\n\t\tif (dss_has_feature(FEAT_ATTR2))\n\t\t\tRR(OVL_ATTRIBUTES2(i));\n\t}\n\n\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n\t\tRR(DIVISOR);\n\n\t \n\tRR(CONTROL);\n\tif (dss_has_feature(FEAT_MGR_LCD2))\n\t\tRR(CONTROL2);\n\tif (dss_has_feature(FEAT_MGR_LCD3))\n\t\tRR(CONTROL3);\n\t \n\tdispc_clear_irqstatus(DISPC_IRQ_SYNC_LOST_DIGIT);\n\n\t \n\tRR(IRQENABLE);\n\n\tDSSDBG(\"context restored\\n\");\n}\n\n#undef SR\n#undef RR\n\nint dispc_runtime_get(void)\n{\n\tint r;\n\n\tDSSDBG(\"dispc_runtime_get\\n\");\n\n\tr = pm_runtime_resume_and_get(&dispc.pdev->dev);\n\tif (WARN_ON(r < 0))\n\t\treturn r;\n\treturn 0;\n}\nEXPORT_SYMBOL(dispc_runtime_get);\n\nvoid dispc_runtime_put(void)\n{\n\tint r;\n\n\tDSSDBG(\"dispc_runtime_put\\n\");\n\n\tr = pm_runtime_put_sync(&dispc.pdev->dev);\n\tWARN_ON(r < 0 && r != -ENOSYS);\n}\nEXPORT_SYMBOL(dispc_runtime_put);\n\nu32 dispc_mgr_get_vsync_irq(enum omap_channel channel)\n{\n\treturn mgr_desc[channel].vsync_irq;\n}\nEXPORT_SYMBOL(dispc_mgr_get_vsync_irq);\n\nu32 dispc_mgr_get_framedone_irq(enum omap_channel channel)\n{\n\tif (channel == OMAP_DSS_CHANNEL_DIGIT && dispc.feat->no_framedone_tv)\n\t\treturn 0;\n\n\treturn mgr_desc[channel].framedone_irq;\n}\nEXPORT_SYMBOL(dispc_mgr_get_framedone_irq);\n\nu32 dispc_mgr_get_sync_lost_irq(enum omap_channel channel)\n{\n\treturn mgr_desc[channel].sync_lost_irq;\n}\nEXPORT_SYMBOL(dispc_mgr_get_sync_lost_irq);\n\nbool dispc_mgr_go_busy(enum omap_channel channel)\n{\n\treturn mgr_fld_read(channel, DISPC_MGR_FLD_GO) == 1;\n}\nEXPORT_SYMBOL(dispc_mgr_go_busy);\n\nvoid dispc_mgr_go(enum omap_channel channel)\n{\n\tWARN_ON(!dispc_mgr_is_enabled(channel));\n\tWARN_ON(dispc_mgr_go_busy(channel));\n\n\tDSSDBG(\"GO %s\\n\", mgr_desc[channel].name);\n\n\tmgr_fld_write(channel, DISPC_MGR_FLD_GO, 1);\n}\nEXPORT_SYMBOL(dispc_mgr_go);\n\nstatic void dispc_ovl_write_firh_reg(enum omap_plane plane, int reg, u32 value)\n{\n\tdispc_write_reg(DISPC_OVL_FIR_COEF_H(plane, reg), value);\n}\n\nstatic void dispc_ovl_write_firhv_reg(enum omap_plane plane, int reg, u32 value)\n{\n\tdispc_write_reg(DISPC_OVL_FIR_COEF_HV(plane, reg), value);\n}\n\nstatic void dispc_ovl_write_firv_reg(enum omap_plane plane, int reg, u32 value)\n{\n\tdispc_write_reg(DISPC_OVL_FIR_COEF_V(plane, reg), value);\n}\n\nstatic void dispc_ovl_write_firh2_reg(enum omap_plane plane, int reg, u32 value)\n{\n\tBUG_ON(plane == OMAP_DSS_GFX);\n\n\tdispc_write_reg(DISPC_OVL_FIR_COEF_H2(plane, reg), value);\n}\n\nstatic void dispc_ovl_write_firhv2_reg(enum omap_plane plane, int reg,\n\t\tu32 value)\n{\n\tBUG_ON(plane == OMAP_DSS_GFX);\n\n\tdispc_write_reg(DISPC_OVL_FIR_COEF_HV2(plane, reg), value);\n}\n\nstatic void dispc_ovl_write_firv2_reg(enum omap_plane plane, int reg, u32 value)\n{\n\tBUG_ON(plane == OMAP_DSS_GFX);\n\n\tdispc_write_reg(DISPC_OVL_FIR_COEF_V2(plane, reg), value);\n}\n\nstatic void dispc_ovl_set_scale_coef(enum omap_plane plane, int fir_hinc,\n\t\t\t\tint fir_vinc, int five_taps,\n\t\t\t\tenum omap_color_component color_comp)\n{\n\tconst struct dispc_coef *h_coef, *v_coef;\n\tint i;\n\n\th_coef = dispc_ovl_get_scale_coef(fir_hinc, true);\n\tv_coef = dispc_ovl_get_scale_coef(fir_vinc, five_taps);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tu32 h, hv;\n\n\t\th = FLD_VAL(h_coef[i].hc0_vc00, 7, 0)\n\t\t\t| FLD_VAL(h_coef[i].hc1_vc0, 15, 8)\n\t\t\t| FLD_VAL(h_coef[i].hc2_vc1, 23, 16)\n\t\t\t| FLD_VAL(h_coef[i].hc3_vc2, 31, 24);\n\t\thv = FLD_VAL(h_coef[i].hc4_vc22, 7, 0)\n\t\t\t| FLD_VAL(v_coef[i].hc1_vc0, 15, 8)\n\t\t\t| FLD_VAL(v_coef[i].hc2_vc1, 23, 16)\n\t\t\t| FLD_VAL(v_coef[i].hc3_vc2, 31, 24);\n\n\t\tif (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {\n\t\t\tdispc_ovl_write_firh_reg(plane, i, h);\n\t\t\tdispc_ovl_write_firhv_reg(plane, i, hv);\n\t\t} else {\n\t\t\tdispc_ovl_write_firh2_reg(plane, i, h);\n\t\t\tdispc_ovl_write_firhv2_reg(plane, i, hv);\n\t\t}\n\n\t}\n\n\tif (five_taps) {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tu32 v;\n\t\t\tv = FLD_VAL(v_coef[i].hc0_vc00, 7, 0)\n\t\t\t\t| FLD_VAL(v_coef[i].hc4_vc22, 15, 8);\n\t\t\tif (color_comp == DISPC_COLOR_COMPONENT_RGB_Y)\n\t\t\t\tdispc_ovl_write_firv_reg(plane, i, v);\n\t\t\telse\n\t\t\t\tdispc_ovl_write_firv2_reg(plane, i, v);\n\t\t}\n\t}\n}\n\n\nstatic void dispc_ovl_write_color_conv_coef(enum omap_plane plane,\n\t\tconst struct color_conv_coef *ct)\n{\n#define CVAL(x, y) (FLD_VAL(x, 26, 16) | FLD_VAL(y, 10, 0))\n\n\tdispc_write_reg(DISPC_OVL_CONV_COEF(plane, 0), CVAL(ct->rcr, ct->ry));\n\tdispc_write_reg(DISPC_OVL_CONV_COEF(plane, 1), CVAL(ct->gy,  ct->rcb));\n\tdispc_write_reg(DISPC_OVL_CONV_COEF(plane, 2), CVAL(ct->gcb, ct->gcr));\n\tdispc_write_reg(DISPC_OVL_CONV_COEF(plane, 3), CVAL(ct->bcr, ct->by));\n\tdispc_write_reg(DISPC_OVL_CONV_COEF(plane, 4), CVAL(0, ct->bcb));\n\n\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), ct->full_range, 11, 11);\n\n#undef CVAL\n}\n\nstatic void dispc_setup_color_conv_coef(void)\n{\n\tint i;\n\tint num_ovl = dss_feat_get_num_ovls();\n\tconst struct color_conv_coef ctbl_bt601_5_ovl = {\n\t\t \n\t\t298, 409, 0, 298, -208, -100, 298, 0, 517, 0,\n\t};\n\tconst struct color_conv_coef ctbl_bt601_5_wb = {\n\t\t \n\t\t66, 129, 25, 112, -94, -18, -38, -74, 112, 0,\n\t};\n\n\tfor (i = 1; i < num_ovl; i++)\n\t\tdispc_ovl_write_color_conv_coef(i, &ctbl_bt601_5_ovl);\n\n\tif (dispc.feat->has_writeback)\n\t\tdispc_ovl_write_color_conv_coef(OMAP_DSS_WB, &ctbl_bt601_5_wb);\n}\n\nstatic void dispc_ovl_set_ba0(enum omap_plane plane, u32 paddr)\n{\n\tdispc_write_reg(DISPC_OVL_BA0(plane), paddr);\n}\n\nstatic void dispc_ovl_set_ba1(enum omap_plane plane, u32 paddr)\n{\n\tdispc_write_reg(DISPC_OVL_BA1(plane), paddr);\n}\n\nstatic void dispc_ovl_set_ba0_uv(enum omap_plane plane, u32 paddr)\n{\n\tdispc_write_reg(DISPC_OVL_BA0_UV(plane), paddr);\n}\n\nstatic void dispc_ovl_set_ba1_uv(enum omap_plane plane, u32 paddr)\n{\n\tdispc_write_reg(DISPC_OVL_BA1_UV(plane), paddr);\n}\n\nstatic void dispc_ovl_set_pos(enum omap_plane plane,\n\t\tenum omap_overlay_caps caps, int x, int y)\n{\n\tu32 val;\n\n\tif ((caps & OMAP_DSS_OVL_CAP_POS) == 0)\n\t\treturn;\n\n\tval = FLD_VAL(y, 26, 16) | FLD_VAL(x, 10, 0);\n\n\tdispc_write_reg(DISPC_OVL_POSITION(plane), val);\n}\n\nstatic void dispc_ovl_set_input_size(enum omap_plane plane, int width,\n\t\tint height)\n{\n\tu32 val = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);\n\n\tif (plane == OMAP_DSS_GFX || plane == OMAP_DSS_WB)\n\t\tdispc_write_reg(DISPC_OVL_SIZE(plane), val);\n\telse\n\t\tdispc_write_reg(DISPC_OVL_PICTURE_SIZE(plane), val);\n}\n\nstatic void dispc_ovl_set_output_size(enum omap_plane plane, int width,\n\t\tint height)\n{\n\tu32 val;\n\n\tBUG_ON(plane == OMAP_DSS_GFX);\n\n\tval = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);\n\n\tif (plane == OMAP_DSS_WB)\n\t\tdispc_write_reg(DISPC_OVL_PICTURE_SIZE(plane), val);\n\telse\n\t\tdispc_write_reg(DISPC_OVL_SIZE(plane), val);\n}\n\nstatic void dispc_ovl_set_zorder(enum omap_plane plane,\n\t\tenum omap_overlay_caps caps, u8 zorder)\n{\n\tif ((caps & OMAP_DSS_OVL_CAP_ZORDER) == 0)\n\t\treturn;\n\n\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), zorder, 27, 26);\n}\n\nstatic void dispc_ovl_enable_zorder_planes(void)\n{\n\tint i;\n\n\tif (!dss_has_feature(FEAT_ALPHA_FREE_ZORDER))\n\t\treturn;\n\n\tfor (i = 0; i < dss_feat_get_num_ovls(); i++)\n\t\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(i), 1, 25, 25);\n}\n\nstatic void dispc_ovl_set_pre_mult_alpha(enum omap_plane plane,\n\t\tenum omap_overlay_caps caps, bool enable)\n{\n\tif ((caps & OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA) == 0)\n\t\treturn;\n\n\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 28, 28);\n}\n\nstatic void dispc_ovl_setup_global_alpha(enum omap_plane plane,\n\t\tenum omap_overlay_caps caps, u8 global_alpha)\n{\n\tstatic const unsigned shifts[] = { 0, 8, 16, 24, };\n\tint shift;\n\n\tif ((caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA) == 0)\n\t\treturn;\n\n\tshift = shifts[plane];\n\tREG_FLD_MOD(DISPC_GLOBAL_ALPHA, global_alpha, shift + 7, shift);\n}\n\nstatic void dispc_ovl_set_pix_inc(enum omap_plane plane, s32 inc)\n{\n\tdispc_write_reg(DISPC_OVL_PIXEL_INC(plane), inc);\n}\n\nstatic void dispc_ovl_set_row_inc(enum omap_plane plane, s32 inc)\n{\n\tdispc_write_reg(DISPC_OVL_ROW_INC(plane), inc);\n}\n\nstatic void dispc_ovl_set_color_mode(enum omap_plane plane,\n\t\tenum omap_color_mode color_mode)\n{\n\tu32 m = 0;\n\tif (plane != OMAP_DSS_GFX) {\n\t\tswitch (color_mode) {\n\t\tcase OMAP_DSS_COLOR_NV12:\n\t\t\tm = 0x0; break;\n\t\tcase OMAP_DSS_COLOR_RGBX16:\n\t\t\tm = 0x1; break;\n\t\tcase OMAP_DSS_COLOR_RGBA16:\n\t\t\tm = 0x2; break;\n\t\tcase OMAP_DSS_COLOR_RGB12U:\n\t\t\tm = 0x4; break;\n\t\tcase OMAP_DSS_COLOR_ARGB16:\n\t\t\tm = 0x5; break;\n\t\tcase OMAP_DSS_COLOR_RGB16:\n\t\t\tm = 0x6; break;\n\t\tcase OMAP_DSS_COLOR_ARGB16_1555:\n\t\t\tm = 0x7; break;\n\t\tcase OMAP_DSS_COLOR_RGB24U:\n\t\t\tm = 0x8; break;\n\t\tcase OMAP_DSS_COLOR_RGB24P:\n\t\t\tm = 0x9; break;\n\t\tcase OMAP_DSS_COLOR_YUV2:\n\t\t\tm = 0xa; break;\n\t\tcase OMAP_DSS_COLOR_UYVY:\n\t\t\tm = 0xb; break;\n\t\tcase OMAP_DSS_COLOR_ARGB32:\n\t\t\tm = 0xc; break;\n\t\tcase OMAP_DSS_COLOR_RGBA32:\n\t\t\tm = 0xd; break;\n\t\tcase OMAP_DSS_COLOR_RGBX32:\n\t\t\tm = 0xe; break;\n\t\tcase OMAP_DSS_COLOR_XRGB16_1555:\n\t\t\tm = 0xf; break;\n\t\tdefault:\n\t\t\tBUG(); return;\n\t\t}\n\t} else {\n\t\tswitch (color_mode) {\n\t\tcase OMAP_DSS_COLOR_CLUT1:\n\t\t\tm = 0x0; break;\n\t\tcase OMAP_DSS_COLOR_CLUT2:\n\t\t\tm = 0x1; break;\n\t\tcase OMAP_DSS_COLOR_CLUT4:\n\t\t\tm = 0x2; break;\n\t\tcase OMAP_DSS_COLOR_CLUT8:\n\t\t\tm = 0x3; break;\n\t\tcase OMAP_DSS_COLOR_RGB12U:\n\t\t\tm = 0x4; break;\n\t\tcase OMAP_DSS_COLOR_ARGB16:\n\t\t\tm = 0x5; break;\n\t\tcase OMAP_DSS_COLOR_RGB16:\n\t\t\tm = 0x6; break;\n\t\tcase OMAP_DSS_COLOR_ARGB16_1555:\n\t\t\tm = 0x7; break;\n\t\tcase OMAP_DSS_COLOR_RGB24U:\n\t\t\tm = 0x8; break;\n\t\tcase OMAP_DSS_COLOR_RGB24P:\n\t\t\tm = 0x9; break;\n\t\tcase OMAP_DSS_COLOR_RGBX16:\n\t\t\tm = 0xa; break;\n\t\tcase OMAP_DSS_COLOR_RGBA16:\n\t\t\tm = 0xb; break;\n\t\tcase OMAP_DSS_COLOR_ARGB32:\n\t\t\tm = 0xc; break;\n\t\tcase OMAP_DSS_COLOR_RGBA32:\n\t\t\tm = 0xd; break;\n\t\tcase OMAP_DSS_COLOR_RGBX32:\n\t\t\tm = 0xe; break;\n\t\tcase OMAP_DSS_COLOR_XRGB16_1555:\n\t\t\tm = 0xf; break;\n\t\tdefault:\n\t\t\tBUG(); return;\n\t\t}\n\t}\n\n\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);\n}\n\nstatic void dispc_ovl_configure_burst_type(enum omap_plane plane,\n\t\tenum omap_dss_rotation_type rotation_type)\n{\n\tif (!dss_has_feature(FEAT_BURST_2D))\n\t\treturn;\n\n\tif (rotation_type == OMAP_DSS_ROT_TILER)\n\t\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), 1, 29, 29);\n\telse\n\t\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), 0, 29, 29);\n}\n\nvoid dispc_ovl_set_channel_out(enum omap_plane plane, enum omap_channel channel)\n{\n\tint shift;\n\tu32 val;\n\tint chan = 0, chan2 = 0;\n\n\tswitch (plane) {\n\tcase OMAP_DSS_GFX:\n\t\tshift = 8;\n\t\tbreak;\n\tcase OMAP_DSS_VIDEO1:\n\tcase OMAP_DSS_VIDEO2:\n\tcase OMAP_DSS_VIDEO3:\n\t\tshift = 16;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tval = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));\n\tif (dss_has_feature(FEAT_MGR_LCD2)) {\n\t\tswitch (channel) {\n\t\tcase OMAP_DSS_CHANNEL_LCD:\n\t\t\tchan = 0;\n\t\t\tchan2 = 0;\n\t\t\tbreak;\n\t\tcase OMAP_DSS_CHANNEL_DIGIT:\n\t\t\tchan = 1;\n\t\t\tchan2 = 0;\n\t\t\tbreak;\n\t\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\t\tchan = 0;\n\t\t\tchan2 = 1;\n\t\t\tbreak;\n\t\tcase OMAP_DSS_CHANNEL_LCD3:\n\t\t\tif (dss_has_feature(FEAT_MGR_LCD3)) {\n\t\t\t\tchan = 0;\n\t\t\t\tchan2 = 2;\n\t\t\t} else {\n\t\t\t\tBUG();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OMAP_DSS_CHANNEL_WB:\n\t\t\tchan = 0;\n\t\t\tchan2 = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn;\n\t\t}\n\n\t\tval = FLD_MOD(val, chan, shift, shift);\n\t\tval = FLD_MOD(val, chan2, 31, 30);\n\t} else {\n\t\tval = FLD_MOD(val, channel, shift, shift);\n\t}\n\tdispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);\n}\nEXPORT_SYMBOL(dispc_ovl_set_channel_out);\n\nstatic enum omap_channel dispc_ovl_get_channel_out(enum omap_plane plane)\n{\n\tint shift;\n\tu32 val;\n\n\tswitch (plane) {\n\tcase OMAP_DSS_GFX:\n\t\tshift = 8;\n\t\tbreak;\n\tcase OMAP_DSS_VIDEO1:\n\tcase OMAP_DSS_VIDEO2:\n\tcase OMAP_DSS_VIDEO3:\n\t\tshift = 16;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\tval = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));\n\n\tif (FLD_GET(val, shift, shift) == 1)\n\t\treturn OMAP_DSS_CHANNEL_DIGIT;\n\n\tif (!dss_has_feature(FEAT_MGR_LCD2))\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\n\tswitch (FLD_GET(val, 31, 30)) {\n\tcase 0:\n\tdefault:\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\tcase 1:\n\t\treturn OMAP_DSS_CHANNEL_LCD2;\n\tcase 2:\n\t\treturn OMAP_DSS_CHANNEL_LCD3;\n\tcase 3:\n\t\treturn OMAP_DSS_CHANNEL_WB;\n\t}\n}\n\nstatic void dispc_ovl_set_burst_size(enum omap_plane plane,\n\t\tenum omap_burst_size burst_size)\n{\n\tstatic const unsigned shifts[] = { 6, 14, 14, 14, 14, };\n\tint shift;\n\n\tshift = shifts[plane];\n\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), burst_size, shift + 1, shift);\n}\n\nstatic void dispc_configure_burst_sizes(void)\n{\n\tint i;\n\tconst int burst_size = BURST_SIZE_X8;\n\n\t \n\tfor (i = 0; i < dss_feat_get_num_ovls(); ++i)\n\t\tdispc_ovl_set_burst_size(i, burst_size);\n\tif (dispc.feat->has_writeback)\n\t\tdispc_ovl_set_burst_size(OMAP_DSS_WB, burst_size);\n}\n\nstatic u32 dispc_ovl_get_burst_size(enum omap_plane plane)\n{\n\tunsigned unit = dss_feat_get_burst_size_unit();\n\t \n\treturn unit * 8;\n}\n\nvoid dispc_enable_gamma_table(bool enable)\n{\n\t \n\tif (enable) {\n\t\tDSSWARN(\"Gamma table enabling for TV not yet supported\");\n\t\treturn;\n\t}\n\n\tREG_FLD_MOD(DISPC_CONFIG, enable, 9, 9);\n}\n\nstatic void dispc_mgr_enable_cpr(enum omap_channel channel, bool enable)\n{\n\tif (channel == OMAP_DSS_CHANNEL_DIGIT)\n\t\treturn;\n\n\tmgr_fld_write(channel, DISPC_MGR_FLD_CPR, enable);\n}\n\nstatic void dispc_mgr_set_cpr_coef(enum omap_channel channel,\n\t\tconst struct omap_dss_cpr_coefs *coefs)\n{\n\tu32 coef_r, coef_g, coef_b;\n\n\tif (!dss_mgr_is_lcd(channel))\n\t\treturn;\n\n\tcoef_r = FLD_VAL(coefs->rr, 31, 22) | FLD_VAL(coefs->rg, 20, 11) |\n\t\tFLD_VAL(coefs->rb, 9, 0);\n\tcoef_g = FLD_VAL(coefs->gr, 31, 22) | FLD_VAL(coefs->gg, 20, 11) |\n\t\tFLD_VAL(coefs->gb, 9, 0);\n\tcoef_b = FLD_VAL(coefs->br, 31, 22) | FLD_VAL(coefs->bg, 20, 11) |\n\t\tFLD_VAL(coefs->bb, 9, 0);\n\n\tdispc_write_reg(DISPC_CPR_COEF_R(channel), coef_r);\n\tdispc_write_reg(DISPC_CPR_COEF_G(channel), coef_g);\n\tdispc_write_reg(DISPC_CPR_COEF_B(channel), coef_b);\n}\n\nstatic void dispc_ovl_set_vid_color_conv(enum omap_plane plane, bool enable)\n{\n\tu32 val;\n\n\tBUG_ON(plane == OMAP_DSS_GFX);\n\n\tval = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));\n\tval = FLD_MOD(val, enable, 9, 9);\n\tdispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);\n}\n\nstatic void dispc_ovl_enable_replication(enum omap_plane plane,\n\t\tenum omap_overlay_caps caps, bool enable)\n{\n\tstatic const unsigned shifts[] = { 5, 10, 10, 10 };\n\tint shift;\n\n\tif ((caps & OMAP_DSS_OVL_CAP_REPLICATION) == 0)\n\t\treturn;\n\n\tshift = shifts[plane];\n\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable, shift, shift);\n}\n\nstatic void dispc_mgr_set_size(enum omap_channel channel, u16 width,\n\t\tu16 height)\n{\n\tu32 val;\n\n\tval = FLD_VAL(height - 1, dispc.feat->mgr_height_start, 16) |\n\t\tFLD_VAL(width - 1, dispc.feat->mgr_width_start, 0);\n\n\tdispc_write_reg(DISPC_SIZE_MGR(channel), val);\n}\n\nstatic void dispc_init_fifos(void)\n{\n\tu32 size;\n\tint fifo;\n\tu8 start, end;\n\tu32 unit;\n\tint i;\n\n\tunit = dss_feat_get_buffer_size_unit();\n\n\tdss_feat_get_reg_field(FEAT_REG_FIFOSIZE, &start, &end);\n\n\tfor (fifo = 0; fifo < dispc.feat->num_fifos; ++fifo) {\n\t\tsize = REG_GET(DISPC_OVL_FIFO_SIZE_STATUS(fifo), start, end);\n\t\tsize *= unit;\n\t\tdispc.fifo_size[fifo] = size;\n\n\t\t \n\t\tdispc.fifo_assignment[fifo] = fifo;\n\t}\n\n\t \n\tif (dispc.feat->gfx_fifo_workaround) {\n\t\tu32 v;\n\n\t\tv = dispc_read_reg(DISPC_GLOBAL_BUFFER);\n\n\t\tv = FLD_MOD(v, 4, 2, 0);  \n\t\tv = FLD_MOD(v, 4, 5, 3);  \n\t\tv = FLD_MOD(v, 0, 26, 24);  \n\t\tv = FLD_MOD(v, 0, 29, 27);  \n\n\t\tdispc_write_reg(DISPC_GLOBAL_BUFFER, v);\n\n\t\tdispc.fifo_assignment[OMAP_DSS_GFX] = OMAP_DSS_WB;\n\t\tdispc.fifo_assignment[OMAP_DSS_WB] = OMAP_DSS_GFX;\n\t}\n\n\t \n\tfor (i = 0; i < dss_feat_get_num_ovls(); ++i) {\n\t\tu32 low, high;\n\t\tconst bool use_fifomerge = false;\n\t\tconst bool manual_update = false;\n\n\t\tdispc_ovl_compute_fifo_thresholds(i, &low, &high,\n\t\t\tuse_fifomerge, manual_update);\n\n\t\tdispc_ovl_set_fifo_threshold(i, low, high);\n\t}\n\n\tif (dispc.feat->has_writeback) {\n\t\tu32 low, high;\n\t\tconst bool use_fifomerge = false;\n\t\tconst bool manual_update = false;\n\n\t\tdispc_ovl_compute_fifo_thresholds(OMAP_DSS_WB, &low, &high,\n\t\t\tuse_fifomerge, manual_update);\n\n\t\tdispc_ovl_set_fifo_threshold(OMAP_DSS_WB, low, high);\n\t}\n}\n\nstatic u32 dispc_ovl_get_fifo_size(enum omap_plane plane)\n{\n\tint fifo;\n\tu32 size = 0;\n\n\tfor (fifo = 0; fifo < dispc.feat->num_fifos; ++fifo) {\n\t\tif (dispc.fifo_assignment[fifo] == plane)\n\t\t\tsize += dispc.fifo_size[fifo];\n\t}\n\n\treturn size;\n}\n\nvoid dispc_ovl_set_fifo_threshold(enum omap_plane plane, u32 low, u32 high)\n{\n\tu8 hi_start, hi_end, lo_start, lo_end;\n\tu32 unit;\n\n\tunit = dss_feat_get_buffer_size_unit();\n\n\tWARN_ON(low % unit != 0);\n\tWARN_ON(high % unit != 0);\n\n\tlow /= unit;\n\thigh /= unit;\n\n\tdss_feat_get_reg_field(FEAT_REG_FIFOHIGHTHRESHOLD, &hi_start, &hi_end);\n\tdss_feat_get_reg_field(FEAT_REG_FIFOLOWTHRESHOLD, &lo_start, &lo_end);\n\n\tDSSDBG(\"fifo(%d) threshold (bytes), old %u/%u, new %u/%u\\n\",\n\t\t\tplane,\n\t\t\tREG_GET(DISPC_OVL_FIFO_THRESHOLD(plane),\n\t\t\t\tlo_start, lo_end) * unit,\n\t\t\tREG_GET(DISPC_OVL_FIFO_THRESHOLD(plane),\n\t\t\t\thi_start, hi_end) * unit,\n\t\t\tlow * unit, high * unit);\n\n\tdispc_write_reg(DISPC_OVL_FIFO_THRESHOLD(plane),\n\t\t\tFLD_VAL(high, hi_start, hi_end) |\n\t\t\tFLD_VAL(low, lo_start, lo_end));\n\n\t \n\tif (dss_has_feature(FEAT_PRELOAD) && dispc.feat->set_max_preload &&\n\t\t\tplane != OMAP_DSS_WB)\n\t\tdispc_write_reg(DISPC_OVL_PRELOAD(plane), min(high, 0xfffu));\n}\n\nvoid dispc_enable_fifomerge(bool enable)\n{\n\tif (!dss_has_feature(FEAT_FIFO_MERGE)) {\n\t\tWARN_ON(enable);\n\t\treturn;\n\t}\n\n\tDSSDBG(\"FIFO merge %s\\n\", enable ? \"enabled\" : \"disabled\");\n\tREG_FLD_MOD(DISPC_CONFIG, enable ? 1 : 0, 14, 14);\n}\n\nvoid dispc_ovl_compute_fifo_thresholds(enum omap_plane plane,\n\t\tu32 *fifo_low, u32 *fifo_high, bool use_fifomerge,\n\t\tbool manual_update)\n{\n\t \n\n\tunsigned buf_unit = dss_feat_get_buffer_size_unit();\n\tunsigned ovl_fifo_size, total_fifo_size, burst_size;\n\tint i;\n\n\tburst_size = dispc_ovl_get_burst_size(plane);\n\tovl_fifo_size = dispc_ovl_get_fifo_size(plane);\n\n\tif (use_fifomerge) {\n\t\ttotal_fifo_size = 0;\n\t\tfor (i = 0; i < dss_feat_get_num_ovls(); ++i)\n\t\t\ttotal_fifo_size += dispc_ovl_get_fifo_size(i);\n\t} else {\n\t\ttotal_fifo_size = ovl_fifo_size;\n\t}\n\n\t \n\n\tif (manual_update && dss_has_feature(FEAT_OMAP3_DSI_FIFO_BUG)) {\n\t\t*fifo_low = ovl_fifo_size - burst_size * 2;\n\t\t*fifo_high = total_fifo_size - burst_size;\n\t} else if (plane == OMAP_DSS_WB) {\n\t\t \n\t\t*fifo_low = 0;\n\t\t*fifo_high = burst_size;\n\t} else {\n\t\t*fifo_low = ovl_fifo_size - burst_size;\n\t\t*fifo_high = total_fifo_size - buf_unit;\n\t}\n}\n\nstatic void dispc_ovl_set_mflag(enum omap_plane plane, bool enable)\n{\n\tint bit;\n\n\tif (plane == OMAP_DSS_GFX)\n\t\tbit = 14;\n\telse\n\t\tbit = 23;\n\n\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable, bit, bit);\n}\n\nstatic void dispc_ovl_set_mflag_threshold(enum omap_plane plane,\n\tint low, int high)\n{\n\tdispc_write_reg(DISPC_OVL_MFLAG_THRESHOLD(plane),\n\t\tFLD_VAL(high, 31, 16) |\tFLD_VAL(low, 15, 0));\n}\n\nstatic void dispc_init_mflag(void)\n{\n\tint i;\n\n\t \n\tdispc_write_reg(DISPC_GLOBAL_MFLAG_ATTRIBUTE,\n\t\t(1 << 0) |\t \n\t\t(0 << 2));\t \n\n\tfor (i = 0; i < dss_feat_get_num_ovls(); ++i) {\n\t\tu32 size = dispc_ovl_get_fifo_size(i);\n\t\tu32 unit = dss_feat_get_buffer_size_unit();\n\t\tu32 low, high;\n\n\t\tdispc_ovl_set_mflag(i, true);\n\n\t\t \n\n\t\tlow = size * 4 / 8 / unit;\n\t\thigh = size * 5 / 8 / unit;\n\n\t\tdispc_ovl_set_mflag_threshold(i, low, high);\n\t}\n\n\tif (dispc.feat->has_writeback) {\n\t\tu32 size = dispc_ovl_get_fifo_size(OMAP_DSS_WB);\n\t\tu32 unit = dss_feat_get_buffer_size_unit();\n\t\tu32 low, high;\n\n\t\tdispc_ovl_set_mflag(OMAP_DSS_WB, true);\n\n\t\t \n\n\t\tlow = size * 4 / 8 / unit;\n\t\thigh = size * 5 / 8 / unit;\n\n\t\tdispc_ovl_set_mflag_threshold(OMAP_DSS_WB, low, high);\n\t}\n}\n\nstatic void dispc_ovl_set_fir(enum omap_plane plane,\n\t\t\t\tint hinc, int vinc,\n\t\t\t\tenum omap_color_component color_comp)\n{\n\tu32 val;\n\n\tif (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {\n\t\tu8 hinc_start, hinc_end, vinc_start, vinc_end;\n\n\t\tdss_feat_get_reg_field(FEAT_REG_FIRHINC,\n\t\t\t\t\t&hinc_start, &hinc_end);\n\t\tdss_feat_get_reg_field(FEAT_REG_FIRVINC,\n\t\t\t\t\t&vinc_start, &vinc_end);\n\t\tval = FLD_VAL(vinc, vinc_start, vinc_end) |\n\t\t\t\tFLD_VAL(hinc, hinc_start, hinc_end);\n\n\t\tdispc_write_reg(DISPC_OVL_FIR(plane), val);\n\t} else {\n\t\tval = FLD_VAL(vinc, 28, 16) | FLD_VAL(hinc, 12, 0);\n\t\tdispc_write_reg(DISPC_OVL_FIR2(plane), val);\n\t}\n}\n\nstatic void dispc_ovl_set_vid_accu0(enum omap_plane plane, int haccu, int vaccu)\n{\n\tu32 val;\n\tu8 hor_start, hor_end, vert_start, vert_end;\n\n\tdss_feat_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);\n\tdss_feat_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);\n\n\tval = FLD_VAL(vaccu, vert_start, vert_end) |\n\t\t\tFLD_VAL(haccu, hor_start, hor_end);\n\n\tdispc_write_reg(DISPC_OVL_ACCU0(plane), val);\n}\n\nstatic void dispc_ovl_set_vid_accu1(enum omap_plane plane, int haccu, int vaccu)\n{\n\tu32 val;\n\tu8 hor_start, hor_end, vert_start, vert_end;\n\n\tdss_feat_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);\n\tdss_feat_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);\n\n\tval = FLD_VAL(vaccu, vert_start, vert_end) |\n\t\t\tFLD_VAL(haccu, hor_start, hor_end);\n\n\tdispc_write_reg(DISPC_OVL_ACCU1(plane), val);\n}\n\nstatic void dispc_ovl_set_vid_accu2_0(enum omap_plane plane, int haccu,\n\t\tint vaccu)\n{\n\tu32 val;\n\n\tval = FLD_VAL(vaccu, 26, 16) | FLD_VAL(haccu, 10, 0);\n\tdispc_write_reg(DISPC_OVL_ACCU2_0(plane), val);\n}\n\nstatic void dispc_ovl_set_vid_accu2_1(enum omap_plane plane, int haccu,\n\t\tint vaccu)\n{\n\tu32 val;\n\n\tval = FLD_VAL(vaccu, 26, 16) | FLD_VAL(haccu, 10, 0);\n\tdispc_write_reg(DISPC_OVL_ACCU2_1(plane), val);\n}\n\nstatic void dispc_ovl_set_scale_param(enum omap_plane plane,\n\t\tu16 orig_width, u16 orig_height,\n\t\tu16 out_width, u16 out_height,\n\t\tbool five_taps, u8 rotation,\n\t\tenum omap_color_component color_comp)\n{\n\tint fir_hinc, fir_vinc;\n\n\tfir_hinc = 1024 * orig_width / out_width;\n\tfir_vinc = 1024 * orig_height / out_height;\n\n\tdispc_ovl_set_scale_coef(plane, fir_hinc, fir_vinc, five_taps,\n\t\t\t\tcolor_comp);\n\tdispc_ovl_set_fir(plane, fir_hinc, fir_vinc, color_comp);\n}\n\nstatic void dispc_ovl_set_accu_uv(enum omap_plane plane,\n\t\tu16 orig_width,\tu16 orig_height, u16 out_width, u16 out_height,\n\t\tbool ilace, enum omap_color_mode color_mode, u8 rotation)\n{\n\tint h_accu2_0, h_accu2_1;\n\tint v_accu2_0, v_accu2_1;\n\tint chroma_hinc, chroma_vinc;\n\tint idx;\n\n\tstruct accu {\n\t\ts8 h0_m, h0_n;\n\t\ts8 h1_m, h1_n;\n\t\ts8 v0_m, v0_n;\n\t\ts8 v1_m, v1_n;\n\t};\n\n\tconst struct accu *accu_table;\n\tconst struct accu *accu_val;\n\n\tstatic const struct accu accu_nv12[4] = {\n\t\t{  0, 1,  0, 1 , -1, 2, 0, 1 },\n\t\t{  1, 2, -3, 4 ,  0, 1, 0, 1 },\n\t\t{ -1, 1,  0, 1 , -1, 2, 0, 1 },\n\t\t{ -1, 2, -1, 2 , -1, 1, 0, 1 },\n\t};\n\n\tstatic const struct accu accu_nv12_ilace[4] = {\n\t\t{  0, 1,  0, 1 , -3, 4, -1, 4 },\n\t\t{ -1, 4, -3, 4 ,  0, 1,  0, 1 },\n\t\t{ -1, 1,  0, 1 , -1, 4, -3, 4 },\n\t\t{ -3, 4, -3, 4 , -1, 1,  0, 1 },\n\t};\n\n\tstatic const struct accu accu_yuv[4] = {\n\t\t{  0, 1, 0, 1,  0, 1, 0, 1 },\n\t\t{  0, 1, 0, 1,  0, 1, 0, 1 },\n\t\t{ -1, 1, 0, 1,  0, 1, 0, 1 },\n\t\t{  0, 1, 0, 1, -1, 1, 0, 1 },\n\t};\n\n\tswitch (rotation) {\n\tcase OMAP_DSS_ROT_0:\n\t\tidx = 0;\n\t\tbreak;\n\tcase OMAP_DSS_ROT_90:\n\t\tidx = 1;\n\t\tbreak;\n\tcase OMAP_DSS_ROT_180:\n\t\tidx = 2;\n\t\tbreak;\n\tcase OMAP_DSS_ROT_270:\n\t\tidx = 3;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tswitch (color_mode) {\n\tcase OMAP_DSS_COLOR_NV12:\n\t\tif (ilace)\n\t\t\taccu_table = accu_nv12_ilace;\n\t\telse\n\t\t\taccu_table = accu_nv12;\n\t\tbreak;\n\tcase OMAP_DSS_COLOR_YUV2:\n\tcase OMAP_DSS_COLOR_UYVY:\n\t\taccu_table = accu_yuv;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\taccu_val = &accu_table[idx];\n\n\tchroma_hinc = 1024 * orig_width / out_width;\n\tchroma_vinc = 1024 * orig_height / out_height;\n\n\th_accu2_0 = (accu_val->h0_m * chroma_hinc / accu_val->h0_n) % 1024;\n\th_accu2_1 = (accu_val->h1_m * chroma_hinc / accu_val->h1_n) % 1024;\n\tv_accu2_0 = (accu_val->v0_m * chroma_vinc / accu_val->v0_n) % 1024;\n\tv_accu2_1 = (accu_val->v1_m * chroma_vinc / accu_val->v1_n) % 1024;\n\n\tdispc_ovl_set_vid_accu2_0(plane, h_accu2_0, v_accu2_0);\n\tdispc_ovl_set_vid_accu2_1(plane, h_accu2_1, v_accu2_1);\n}\n\nstatic void dispc_ovl_set_scaling_common(enum omap_plane plane,\n\t\tu16 orig_width, u16 orig_height,\n\t\tu16 out_width, u16 out_height,\n\t\tbool ilace, bool five_taps,\n\t\tbool fieldmode, enum omap_color_mode color_mode,\n\t\tu8 rotation)\n{\n\tint accu0 = 0;\n\tint accu1 = 0;\n\tu32 l;\n\n\tdispc_ovl_set_scale_param(plane, orig_width, orig_height,\n\t\t\t\tout_width, out_height, five_taps,\n\t\t\t\trotation, DISPC_COLOR_COMPONENT_RGB_Y);\n\tl = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));\n\n\t \n\tl &= ~((0x3 << 5) | (0x1 << 21));\n\tl |= (orig_width != out_width) ? (1 << 5) : 0;\n\tl |= (orig_height != out_height) ? (1 << 6) : 0;\n\tl |= five_taps ? (1 << 21) : 0;\n\n\t \n\tif (dss_has_feature(FEAT_RESIZECONF)) {\n\t\tl &= ~(0x3 << 7);\n\t\tl |= (orig_width <= out_width) ? 0 : (1 << 7);\n\t\tl |= (orig_height <= out_height) ? 0 : (1 << 8);\n\t}\n\n\t \n\tif (dss_has_feature(FEAT_LINEBUFFERSPLIT)) {\n\t\tl &= ~(0x1 << 22);\n\t\tl |= five_taps ? (1 << 22) : 0;\n\t}\n\n\tdispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), l);\n\n\t \n\tif (ilace && !fieldmode) {\n\t\taccu1 = 0;\n\t\taccu0 = ((1024 * orig_height / out_height) / 2) & 0x3ff;\n\t\tif (accu0 >= 1024/2) {\n\t\t\taccu1 = 1024/2;\n\t\t\taccu0 -= accu1;\n\t\t}\n\t}\n\n\tdispc_ovl_set_vid_accu0(plane, 0, accu0);\n\tdispc_ovl_set_vid_accu1(plane, 0, accu1);\n}\n\nstatic void dispc_ovl_set_scaling_uv(enum omap_plane plane,\n\t\tu16 orig_width, u16 orig_height,\n\t\tu16 out_width, u16 out_height,\n\t\tbool ilace, bool five_taps,\n\t\tbool fieldmode, enum omap_color_mode color_mode,\n\t\tu8 rotation)\n{\n\tint scale_x = out_width != orig_width;\n\tint scale_y = out_height != orig_height;\n\tbool chroma_upscale = plane != OMAP_DSS_WB;\n\n\tif (!dss_has_feature(FEAT_HANDLE_UV_SEPARATE))\n\t\treturn;\n\tif ((color_mode != OMAP_DSS_COLOR_YUV2 &&\n\t\t\tcolor_mode != OMAP_DSS_COLOR_UYVY &&\n\t\t\tcolor_mode != OMAP_DSS_COLOR_NV12)) {\n\t\t \n\t\tif (plane != OMAP_DSS_WB)\n\t\t\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), 0, 8, 8);\n\t\treturn;\n\t}\n\n\tdispc_ovl_set_accu_uv(plane, orig_width, orig_height, out_width,\n\t\t\tout_height, ilace, color_mode, rotation);\n\n\tswitch (color_mode) {\n\tcase OMAP_DSS_COLOR_NV12:\n\t\tif (chroma_upscale) {\n\t\t\t \n\t\t\torig_height >>= 1;\n\t\t\torig_width >>= 1;\n\t\t} else {\n\t\t\t \n\t\t\torig_height <<= 1;\n\t\t\torig_width <<= 1;\n\t\t}\n\n\t\tbreak;\n\tcase OMAP_DSS_COLOR_YUV2:\n\tcase OMAP_DSS_COLOR_UYVY:\n\t\t \n\t\tif (rotation == OMAP_DSS_ROT_0 ||\n\t\t\t\trotation == OMAP_DSS_ROT_180) {\n\t\t\tif (chroma_upscale)\n\t\t\t\t \n\t\t\t\torig_width >>= 1;\n\t\t\telse\n\t\t\t\t \n\t\t\t\torig_width <<= 1;\n\t\t}\n\n\t\t \n\t\tif (rotation != OMAP_DSS_ROT_0)\n\t\t\tscale_x = scale_y = true;\n\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tif (out_width != orig_width)\n\t\tscale_x = true;\n\tif (out_height != orig_height)\n\t\tscale_y = true;\n\n\tdispc_ovl_set_scale_param(plane, orig_width, orig_height,\n\t\t\tout_width, out_height, five_taps,\n\t\t\t\trotation, DISPC_COLOR_COMPONENT_UV);\n\n\tif (plane != OMAP_DSS_WB)\n\t\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane),\n\t\t\t(scale_x || scale_y) ? 1 : 0, 8, 8);\n\n\t \n\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), scale_x ? 1 : 0, 5, 5);\n\t \n\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), scale_y ? 1 : 0, 6, 6);\n}\n\nstatic void dispc_ovl_set_scaling(enum omap_plane plane,\n\t\tu16 orig_width, u16 orig_height,\n\t\tu16 out_width, u16 out_height,\n\t\tbool ilace, bool five_taps,\n\t\tbool fieldmode, enum omap_color_mode color_mode,\n\t\tu8 rotation)\n{\n\tBUG_ON(plane == OMAP_DSS_GFX);\n\n\tdispc_ovl_set_scaling_common(plane,\n\t\t\torig_width, orig_height,\n\t\t\tout_width, out_height,\n\t\t\tilace, five_taps,\n\t\t\tfieldmode, color_mode,\n\t\t\trotation);\n\n\tdispc_ovl_set_scaling_uv(plane,\n\t\torig_width, orig_height,\n\t\tout_width, out_height,\n\t\tilace, five_taps,\n\t\tfieldmode, color_mode,\n\t\trotation);\n}\n\nstatic void dispc_ovl_set_rotation_attrs(enum omap_plane plane, u8 rotation,\n\t\tenum omap_dss_rotation_type rotation_type,\n\t\tbool mirroring, enum omap_color_mode color_mode)\n{\n\tbool row_repeat = false;\n\tint vidrot = 0;\n\n\tif (color_mode == OMAP_DSS_COLOR_YUV2 ||\n\t\t\tcolor_mode == OMAP_DSS_COLOR_UYVY) {\n\n\t\tif (mirroring) {\n\t\t\tswitch (rotation) {\n\t\t\tcase OMAP_DSS_ROT_0:\n\t\t\t\tvidrot = 2;\n\t\t\t\tbreak;\n\t\t\tcase OMAP_DSS_ROT_90:\n\t\t\t\tvidrot = 1;\n\t\t\t\tbreak;\n\t\t\tcase OMAP_DSS_ROT_180:\n\t\t\t\tvidrot = 0;\n\t\t\t\tbreak;\n\t\t\tcase OMAP_DSS_ROT_270:\n\t\t\t\tvidrot = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (rotation) {\n\t\t\tcase OMAP_DSS_ROT_0:\n\t\t\t\tvidrot = 0;\n\t\t\t\tbreak;\n\t\t\tcase OMAP_DSS_ROT_90:\n\t\t\t\tvidrot = 1;\n\t\t\t\tbreak;\n\t\t\tcase OMAP_DSS_ROT_180:\n\t\t\t\tvidrot = 2;\n\t\t\t\tbreak;\n\t\t\tcase OMAP_DSS_ROT_270:\n\t\t\t\tvidrot = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (rotation == OMAP_DSS_ROT_90 || rotation == OMAP_DSS_ROT_270)\n\t\t\trow_repeat = true;\n\t\telse\n\t\t\trow_repeat = false;\n\t}\n\n\t \n\tif (color_mode == OMAP_DSS_COLOR_NV12 &&\n\t\t\trotation_type != OMAP_DSS_ROT_TILER)\n\t\tvidrot = 1;\n\n\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), vidrot, 13, 12);\n\tif (dss_has_feature(FEAT_ROWREPEATENABLE))\n\t\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane),\n\t\t\trow_repeat ? 1 : 0, 18, 18);\n\n\tif (color_mode == OMAP_DSS_COLOR_NV12) {\n\t\tbool doublestride = (rotation_type == OMAP_DSS_ROT_TILER) &&\n\t\t\t\t\t(rotation == OMAP_DSS_ROT_0 ||\n\t\t\t\t\trotation == OMAP_DSS_ROT_180);\n\t\t \n\t\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), doublestride, 22, 22);\n\t}\n\n}\n\nstatic int color_mode_to_bpp(enum omap_color_mode color_mode)\n{\n\tswitch (color_mode) {\n\tcase OMAP_DSS_COLOR_CLUT1:\n\t\treturn 1;\n\tcase OMAP_DSS_COLOR_CLUT2:\n\t\treturn 2;\n\tcase OMAP_DSS_COLOR_CLUT4:\n\t\treturn 4;\n\tcase OMAP_DSS_COLOR_CLUT8:\n\tcase OMAP_DSS_COLOR_NV12:\n\t\treturn 8;\n\tcase OMAP_DSS_COLOR_RGB12U:\n\tcase OMAP_DSS_COLOR_RGB16:\n\tcase OMAP_DSS_COLOR_ARGB16:\n\tcase OMAP_DSS_COLOR_YUV2:\n\tcase OMAP_DSS_COLOR_UYVY:\n\tcase OMAP_DSS_COLOR_RGBA16:\n\tcase OMAP_DSS_COLOR_RGBX16:\n\tcase OMAP_DSS_COLOR_ARGB16_1555:\n\tcase OMAP_DSS_COLOR_XRGB16_1555:\n\t\treturn 16;\n\tcase OMAP_DSS_COLOR_RGB24P:\n\t\treturn 24;\n\tcase OMAP_DSS_COLOR_RGB24U:\n\tcase OMAP_DSS_COLOR_ARGB32:\n\tcase OMAP_DSS_COLOR_RGBA32:\n\tcase OMAP_DSS_COLOR_RGBX32:\n\t\treturn 32;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}\n\nstatic s32 pixinc(int pixels, u8 ps)\n{\n\tif (pixels == 1)\n\t\treturn 1;\n\telse if (pixels > 1)\n\t\treturn 1 + (pixels - 1) * ps;\n\telse if (pixels < 0)\n\t\treturn 1 - (-pixels + 1) * ps;\n\telse\n\t\tBUG();\n\treturn 0;\n}\n\nstatic void calc_vrfb_rotation_offset(u8 rotation, bool mirror,\n\t\tu16 screen_width,\n\t\tu16 width, u16 height,\n\t\tenum omap_color_mode color_mode, bool fieldmode,\n\t\tunsigned int field_offset,\n\t\tunsigned *offset0, unsigned *offset1,\n\t\ts32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)\n{\n\tu8 ps;\n\n\t \n\tswitch (color_mode) {\n\tcase OMAP_DSS_COLOR_CLUT1:\n\tcase OMAP_DSS_COLOR_CLUT2:\n\tcase OMAP_DSS_COLOR_CLUT4:\n\tcase OMAP_DSS_COLOR_CLUT8:\n\t\tBUG();\n\t\treturn;\n\tcase OMAP_DSS_COLOR_YUV2:\n\tcase OMAP_DSS_COLOR_UYVY:\n\t\tps = 4;\n\t\tbreak;\n\tdefault:\n\t\tps = color_mode_to_bpp(color_mode) / 8;\n\t\tbreak;\n\t}\n\n\tDSSDBG(\"calc_rot(%d): scrw %d, %dx%d\\n\", rotation, screen_width,\n\t\t\twidth, height);\n\n\t \n\tswitch (rotation + mirror * 4) {\n\tcase OMAP_DSS_ROT_0:\n\tcase OMAP_DSS_ROT_180:\n\t\t \n\t\tif (color_mode == OMAP_DSS_COLOR_YUV2 ||\n\t\t\tcolor_mode == OMAP_DSS_COLOR_UYVY)\n\t\t\twidth = width >> 1;\n\t\tfallthrough;\n\tcase OMAP_DSS_ROT_90:\n\tcase OMAP_DSS_ROT_270:\n\t\t*offset1 = 0;\n\t\tif (field_offset)\n\t\t\t*offset0 = field_offset * screen_width * ps;\n\t\telse\n\t\t\t*offset0 = 0;\n\n\t\t*row_inc = pixinc(1 +\n\t\t\t(y_predecim * screen_width - x_predecim * width) +\n\t\t\t(fieldmode ? screen_width : 0), ps);\n\t\t*pix_inc = pixinc(x_predecim, ps);\n\t\tbreak;\n\n\tcase OMAP_DSS_ROT_0 + 4:\n\tcase OMAP_DSS_ROT_180 + 4:\n\t\t \n\t\tif (color_mode == OMAP_DSS_COLOR_YUV2 ||\n\t\t\tcolor_mode == OMAP_DSS_COLOR_UYVY)\n\t\t\twidth = width >> 1;\n\t\tfallthrough;\n\tcase OMAP_DSS_ROT_90 + 4:\n\tcase OMAP_DSS_ROT_270 + 4:\n\t\t*offset1 = 0;\n\t\tif (field_offset)\n\t\t\t*offset0 = field_offset * screen_width * ps;\n\t\telse\n\t\t\t*offset0 = 0;\n\t\t*row_inc = pixinc(1 -\n\t\t\t(y_predecim * screen_width + x_predecim * width) -\n\t\t\t(fieldmode ? screen_width : 0), ps);\n\t\t*pix_inc = pixinc(x_predecim, ps);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n}\n\nstatic void calc_dma_rotation_offset(u8 rotation, bool mirror,\n\t\tu16 screen_width,\n\t\tu16 width, u16 height,\n\t\tenum omap_color_mode color_mode, bool fieldmode,\n\t\tunsigned int field_offset,\n\t\tunsigned *offset0, unsigned *offset1,\n\t\ts32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)\n{\n\tu8 ps;\n\tu16 fbw, fbh;\n\n\t \n\tswitch (color_mode) {\n\tcase OMAP_DSS_COLOR_CLUT1:\n\tcase OMAP_DSS_COLOR_CLUT2:\n\tcase OMAP_DSS_COLOR_CLUT4:\n\tcase OMAP_DSS_COLOR_CLUT8:\n\t\tBUG();\n\t\treturn;\n\tdefault:\n\t\tps = color_mode_to_bpp(color_mode) / 8;\n\t\tbreak;\n\t}\n\n\tDSSDBG(\"calc_rot(%d): scrw %d, %dx%d\\n\", rotation, screen_width,\n\t\t\twidth, height);\n\n\t \n\n\tif (rotation == OMAP_DSS_ROT_0 || rotation == OMAP_DSS_ROT_180) {\n\t\tfbw = width;\n\t\tfbh = height;\n\t} else {\n\t\tfbw = height;\n\t\tfbh = width;\n\t}\n\n\t \n\tswitch (rotation + mirror * 4) {\n\tcase OMAP_DSS_ROT_0:\n\t\t*offset1 = 0;\n\t\tif (field_offset)\n\t\t\t*offset0 = *offset1 + field_offset * screen_width * ps;\n\t\telse\n\t\t\t*offset0 = *offset1;\n\t\t*row_inc = pixinc(1 +\n\t\t\t(y_predecim * screen_width - fbw * x_predecim) +\n\t\t\t(fieldmode ? screen_width : 0),\tps);\n\t\tif (color_mode == OMAP_DSS_COLOR_YUV2 ||\n\t\t\tcolor_mode == OMAP_DSS_COLOR_UYVY)\n\t\t\t*pix_inc = pixinc(x_predecim, 2 * ps);\n\t\telse\n\t\t\t*pix_inc = pixinc(x_predecim, ps);\n\t\tbreak;\n\tcase OMAP_DSS_ROT_90:\n\t\t*offset1 = screen_width * (fbh - 1) * ps;\n\t\tif (field_offset)\n\t\t\t*offset0 = *offset1 + field_offset * ps;\n\t\telse\n\t\t\t*offset0 = *offset1;\n\t\t*row_inc = pixinc(screen_width * (fbh * x_predecim - 1) +\n\t\t\t\ty_predecim + (fieldmode ? 1 : 0), ps);\n\t\t*pix_inc = pixinc(-x_predecim * screen_width, ps);\n\t\tbreak;\n\tcase OMAP_DSS_ROT_180:\n\t\t*offset1 = (screen_width * (fbh - 1) + fbw - 1) * ps;\n\t\tif (field_offset)\n\t\t\t*offset0 = *offset1 - field_offset * screen_width * ps;\n\t\telse\n\t\t\t*offset0 = *offset1;\n\t\t*row_inc = pixinc(-1 -\n\t\t\t(y_predecim * screen_width - fbw * x_predecim) -\n\t\t\t(fieldmode ? screen_width : 0),\tps);\n\t\tif (color_mode == OMAP_DSS_COLOR_YUV2 ||\n\t\t\tcolor_mode == OMAP_DSS_COLOR_UYVY)\n\t\t\t*pix_inc = pixinc(-x_predecim, 2 * ps);\n\t\telse\n\t\t\t*pix_inc = pixinc(-x_predecim, ps);\n\t\tbreak;\n\tcase OMAP_DSS_ROT_270:\n\t\t*offset1 = (fbw - 1) * ps;\n\t\tif (field_offset)\n\t\t\t*offset0 = *offset1 - field_offset * ps;\n\t\telse\n\t\t\t*offset0 = *offset1;\n\t\t*row_inc = pixinc(-screen_width * (fbh * x_predecim - 1) -\n\t\t\t\ty_predecim - (fieldmode ? 1 : 0), ps);\n\t\t*pix_inc = pixinc(x_predecim * screen_width, ps);\n\t\tbreak;\n\n\t \n\tcase OMAP_DSS_ROT_0 + 4:\n\t\t*offset1 = (fbw - 1) * ps;\n\t\tif (field_offset)\n\t\t\t*offset0 = *offset1 + field_offset * screen_width * ps;\n\t\telse\n\t\t\t*offset0 = *offset1;\n\t\t*row_inc = pixinc(y_predecim * screen_width * 2 - 1 +\n\t\t\t\t(fieldmode ? screen_width : 0),\n\t\t\t\tps);\n\t\tif (color_mode == OMAP_DSS_COLOR_YUV2 ||\n\t\t\tcolor_mode == OMAP_DSS_COLOR_UYVY)\n\t\t\t*pix_inc = pixinc(-x_predecim, 2 * ps);\n\t\telse\n\t\t\t*pix_inc = pixinc(-x_predecim, ps);\n\t\tbreak;\n\n\tcase OMAP_DSS_ROT_90 + 4:\n\t\t*offset1 = 0;\n\t\tif (field_offset)\n\t\t\t*offset0 = *offset1 + field_offset * ps;\n\t\telse\n\t\t\t*offset0 = *offset1;\n\t\t*row_inc = pixinc(-screen_width * (fbh * x_predecim - 1) +\n\t\t\t\ty_predecim + (fieldmode ? 1 : 0),\n\t\t\t\tps);\n\t\t*pix_inc = pixinc(x_predecim * screen_width, ps);\n\t\tbreak;\n\n\tcase OMAP_DSS_ROT_180 + 4:\n\t\t*offset1 = screen_width * (fbh - 1) * ps;\n\t\tif (field_offset)\n\t\t\t*offset0 = *offset1 - field_offset * screen_width * ps;\n\t\telse\n\t\t\t*offset0 = *offset1;\n\t\t*row_inc = pixinc(1 - y_predecim * screen_width * 2 -\n\t\t\t\t(fieldmode ? screen_width : 0),\n\t\t\t\tps);\n\t\tif (color_mode == OMAP_DSS_COLOR_YUV2 ||\n\t\t\tcolor_mode == OMAP_DSS_COLOR_UYVY)\n\t\t\t*pix_inc = pixinc(x_predecim, 2 * ps);\n\t\telse\n\t\t\t*pix_inc = pixinc(x_predecim, ps);\n\t\tbreak;\n\n\tcase OMAP_DSS_ROT_270 + 4:\n\t\t*offset1 = (screen_width * (fbh - 1) + fbw - 1) * ps;\n\t\tif (field_offset)\n\t\t\t*offset0 = *offset1 - field_offset * ps;\n\t\telse\n\t\t\t*offset0 = *offset1;\n\t\t*row_inc = pixinc(screen_width * (fbh * x_predecim - 1) -\n\t\t\t\ty_predecim - (fieldmode ? 1 : 0),\n\t\t\t\tps);\n\t\t*pix_inc = pixinc(-x_predecim * screen_width, ps);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n}\n\nstatic void calc_tiler_rotation_offset(u16 screen_width, u16 width,\n\t\tenum omap_color_mode color_mode, bool fieldmode,\n\t\tunsigned int field_offset, unsigned *offset0, unsigned *offset1,\n\t\ts32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)\n{\n\tu8 ps;\n\n\tswitch (color_mode) {\n\tcase OMAP_DSS_COLOR_CLUT1:\n\tcase OMAP_DSS_COLOR_CLUT2:\n\tcase OMAP_DSS_COLOR_CLUT4:\n\tcase OMAP_DSS_COLOR_CLUT8:\n\t\tBUG();\n\t\treturn;\n\tdefault:\n\t\tps = color_mode_to_bpp(color_mode) / 8;\n\t\tbreak;\n\t}\n\n\tDSSDBG(\"scrw %d, width %d\\n\", screen_width, width);\n\n\t \n\t*offset1 = 0;\n\tif (field_offset)\n\t\t*offset0 = *offset1 + field_offset * screen_width * ps;\n\telse\n\t\t*offset0 = *offset1;\n\t*row_inc = pixinc(1 + (y_predecim * screen_width - width * x_predecim) +\n\t\t\t(fieldmode ? screen_width : 0), ps);\n\tif (color_mode == OMAP_DSS_COLOR_YUV2 ||\n\t\tcolor_mode == OMAP_DSS_COLOR_UYVY)\n\t\t*pix_inc = pixinc(x_predecim, 2 * ps);\n\telse\n\t\t*pix_inc = pixinc(x_predecim, ps);\n}\n\n \nstatic int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,\n\t\tconst struct omap_video_timings *t, u16 pos_x,\n\t\tu16 width, u16 height, u16 out_width, u16 out_height,\n\t\tbool five_taps)\n{\n\tconst int ds = DIV_ROUND_UP(height, out_height);\n\tunsigned long nonactive;\n\tstatic const u8 limits[3] = { 8, 10, 20 };\n\tu64 val, blank;\n\tint i;\n\n\tnonactive = t->x_res + t->hfp + t->hsw + t->hbp - out_width;\n\n\ti = 0;\n\tif (out_height < height)\n\t\ti++;\n\tif (out_width < width)\n\t\ti++;\n\tblank = div_u64((u64)(t->hbp + t->hsw + t->hfp) * lclk, pclk);\n\tDSSDBG(\"blanking period + ppl = %llu (limit = %u)\\n\", blank, limits[i]);\n\tif (blank <= limits[i])\n\t\treturn -EINVAL;\n\n\t \n\tif (!five_taps)\n\t\treturn 0;\n\n\t \n\tval = div_u64((u64)(nonactive - pos_x) * lclk, pclk);\n\tDSSDBG(\"(nonactive - pos_x) * pcd = %llu max(0, DS - 2) * width = %d\\n\",\n\t\tval, max(0, ds - 2) * width);\n\tif (val < max(0, ds - 2) * width)\n\t\treturn -EINVAL;\n\n\t \n\tval =  div_u64((u64)nonactive * lclk, pclk);\n\tDSSDBG(\"nonactive * pcd  = %llu, max(0, DS - 1) * width = %d\\n\",\n\t\tval, max(0, ds - 1) * width);\n\tif (val < max(0, ds - 1) * width)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic unsigned long calc_core_clk_five_taps(unsigned long pclk,\n\t\tconst struct omap_video_timings *mgr_timings, u16 width,\n\t\tu16 height, u16 out_width, u16 out_height,\n\t\tenum omap_color_mode color_mode)\n{\n\tu32 core_clk = 0;\n\tu64 tmp;\n\n\tif (height <= out_height && width <= out_width)\n\t\treturn (unsigned long) pclk;\n\n\tif (height > out_height) {\n\t\tunsigned int ppl = mgr_timings->x_res;\n\n\t\ttmp = (u64)pclk * height * out_width;\n\t\tdo_div(tmp, 2 * out_height * ppl);\n\t\tcore_clk = tmp;\n\n\t\tif (height > 2 * out_height) {\n\t\t\tif (ppl == out_width)\n\t\t\t\treturn 0;\n\n\t\t\ttmp = (u64)pclk * (height - 2 * out_height) * out_width;\n\t\t\tdo_div(tmp, 2 * out_height * (ppl - out_width));\n\t\t\tcore_clk = max_t(u32, core_clk, tmp);\n\t\t}\n\t}\n\n\tif (width > out_width) {\n\t\ttmp = (u64)pclk * width;\n\t\tdo_div(tmp, out_width);\n\t\tcore_clk = max_t(u32, core_clk, tmp);\n\n\t\tif (color_mode == OMAP_DSS_COLOR_RGB24U)\n\t\t\tcore_clk <<= 1;\n\t}\n\n\treturn core_clk;\n}\n\nstatic unsigned long calc_core_clk_24xx(unsigned long pclk, u16 width,\n\t\tu16 height, u16 out_width, u16 out_height, bool mem_to_mem)\n{\n\tif (height > out_height && width > out_width)\n\t\treturn pclk * 4;\n\telse\n\t\treturn pclk * 2;\n}\n\nstatic unsigned long calc_core_clk_34xx(unsigned long pclk, u16 width,\n\t\tu16 height, u16 out_width, u16 out_height, bool mem_to_mem)\n{\n\tunsigned int hf, vf;\n\n\t \n\n\tif (width > 3 * out_width)\n\t\thf = 4;\n\telse if (width > 2 * out_width)\n\t\thf = 3;\n\telse if (width > out_width)\n\t\thf = 2;\n\telse\n\t\thf = 1;\n\tif (height > out_height)\n\t\tvf = 2;\n\telse\n\t\tvf = 1;\n\n\treturn pclk * vf * hf;\n}\n\nstatic unsigned long calc_core_clk_44xx(unsigned long pclk, u16 width,\n\t\tu16 height, u16 out_width, u16 out_height, bool mem_to_mem)\n{\n\t \n\tif (mem_to_mem)\n\t\treturn 1;\n\n\tif (width > out_width)\n\t\treturn DIV_ROUND_UP(pclk, out_width) * width;\n\telse\n\t\treturn pclk;\n}\n\nstatic int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,\n\t\tconst struct omap_video_timings *mgr_timings,\n\t\tu16 width, u16 height, u16 out_width, u16 out_height,\n\t\tenum omap_color_mode color_mode, bool *five_taps,\n\t\tint *x_predecim, int *y_predecim, int *decim_x, int *decim_y,\n\t\tu16 pos_x, unsigned long *core_clk, bool mem_to_mem)\n{\n\tint error;\n\tu16 in_width, in_height;\n\tint min_factor = min(*decim_x, *decim_y);\n\tconst int maxsinglelinewidth =\n\t\t\tdss_feat_get_param_max(FEAT_PARAM_LINEWIDTH);\n\n\t*five_taps = false;\n\n\tdo {\n\t\tin_height = height / *decim_y;\n\t\tin_width = width / *decim_x;\n\t\t*core_clk = dispc.feat->calc_core_clk(pclk, in_width,\n\t\t\t\tin_height, out_width, out_height, mem_to_mem);\n\t\terror = (in_width > maxsinglelinewidth || !*core_clk ||\n\t\t\t*core_clk > dispc_core_clk_rate());\n\t\tif (error) {\n\t\t\tif (*decim_x == *decim_y) {\n\t\t\t\t*decim_x = min_factor;\n\t\t\t\t++*decim_y;\n\t\t\t} else {\n\t\t\t\tswap(*decim_x, *decim_y);\n\t\t\t\tif (*decim_x < *decim_y)\n\t\t\t\t\t++*decim_x;\n\t\t\t}\n\t\t}\n\t} while (*decim_x <= *x_predecim && *decim_y <= *y_predecim && error);\n\n\tif (error) {\n\t\tDSSERR(\"failed to find scaling settings\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (in_width > maxsinglelinewidth) {\n\t\tDSSERR(\"Cannot scale max input width exceeded\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,\n\t\tconst struct omap_video_timings *mgr_timings,\n\t\tu16 width, u16 height, u16 out_width, u16 out_height,\n\t\tenum omap_color_mode color_mode, bool *five_taps,\n\t\tint *x_predecim, int *y_predecim, int *decim_x, int *decim_y,\n\t\tu16 pos_x, unsigned long *core_clk, bool mem_to_mem)\n{\n\tint error;\n\tu16 in_width, in_height;\n\tconst int maxsinglelinewidth =\n\t\t\tdss_feat_get_param_max(FEAT_PARAM_LINEWIDTH);\n\n\tdo {\n\t\tin_height = height / *decim_y;\n\t\tin_width = width / *decim_x;\n\t\t*five_taps = in_height > out_height;\n\n\t\tif (in_width > maxsinglelinewidth)\n\t\t\tif (in_height > out_height &&\n\t\t\t\t\t\tin_height < out_height * 2)\n\t\t\t\t*five_taps = false;\nagain:\n\t\tif (*five_taps)\n\t\t\t*core_clk = calc_core_clk_five_taps(pclk, mgr_timings,\n\t\t\t\t\t\tin_width, in_height, out_width,\n\t\t\t\t\t\tout_height, color_mode);\n\t\telse\n\t\t\t*core_clk = dispc.feat->calc_core_clk(pclk, in_width,\n\t\t\t\t\tin_height, out_width, out_height,\n\t\t\t\t\tmem_to_mem);\n\n\t\terror = check_horiz_timing_omap3(pclk, lclk, mgr_timings,\n\t\t\t\tpos_x, in_width, in_height, out_width,\n\t\t\t\tout_height, *five_taps);\n\t\tif (error && *five_taps) {\n\t\t\t*five_taps = false;\n\t\t\tgoto again;\n\t\t}\n\n\t\terror = (error || in_width > maxsinglelinewidth * 2 ||\n\t\t\t(in_width > maxsinglelinewidth && *five_taps) ||\n\t\t\t!*core_clk || *core_clk > dispc_core_clk_rate());\n\n\t\tif (!error) {\n\t\t\t \n\t\t\tif (in_width / 4 > out_width)\n\t\t\t\t\terror = 1;\n\n\t\t\tif (*five_taps) {\n\t\t\t\tif (in_height / 4 > out_height)\n\t\t\t\t\terror = 1;\n\t\t\t} else {\n\t\t\t\tif (in_height / 2 > out_height)\n\t\t\t\t\terror = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (error)\n\t\t\t++*decim_y;\n\t} while (*decim_x <= *x_predecim && *decim_y <= *y_predecim && error);\n\n\tif (error) {\n\t\tDSSERR(\"failed to find scaling settings\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (check_horiz_timing_omap3(pclk, lclk, mgr_timings, pos_x, in_width,\n\t\t\t\tin_height, out_width, out_height, *five_taps)) {\n\t\t\tDSSERR(\"horizontal timing too tight\\n\");\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (in_width > (maxsinglelinewidth * 2)) {\n\t\tDSSERR(\"Cannot setup scaling\");\n\t\tDSSERR(\"width exceeds maximum width possible\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (in_width > maxsinglelinewidth && *five_taps) {\n\t\tDSSERR(\"cannot setup scaling with five taps\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,\n\t\tconst struct omap_video_timings *mgr_timings,\n\t\tu16 width, u16 height, u16 out_width, u16 out_height,\n\t\tenum omap_color_mode color_mode, bool *five_taps,\n\t\tint *x_predecim, int *y_predecim, int *decim_x, int *decim_y,\n\t\tu16 pos_x, unsigned long *core_clk, bool mem_to_mem)\n{\n\tu16 in_width, in_width_max;\n\tint decim_x_min = *decim_x;\n\tu16 in_height = height / *decim_y;\n\tconst int maxsinglelinewidth =\n\t\t\t\tdss_feat_get_param_max(FEAT_PARAM_LINEWIDTH);\n\tconst int maxdownscale = dss_feat_get_param_max(FEAT_PARAM_DOWNSCALE);\n\n\tif (mem_to_mem) {\n\t\tin_width_max = out_width * maxdownscale;\n\t} else {\n\t\tin_width_max = dispc_core_clk_rate() /\n\t\t\t\t\tDIV_ROUND_UP(pclk, out_width);\n\t}\n\n\t*decim_x = DIV_ROUND_UP(width, in_width_max);\n\n\t*decim_x = *decim_x > decim_x_min ? *decim_x : decim_x_min;\n\tif (*decim_x > *x_predecim)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tin_width = width / *decim_x;\n\t} while (*decim_x <= *x_predecim &&\n\t\t\tin_width > maxsinglelinewidth && ++*decim_x);\n\n\tif (in_width > maxsinglelinewidth) {\n\t\tDSSERR(\"Cannot scale width exceeds max line width\");\n\t\treturn -EINVAL;\n\t}\n\n\t*core_clk = dispc.feat->calc_core_clk(pclk, in_width, in_height,\n\t\t\t\tout_width, out_height, mem_to_mem);\n\treturn 0;\n}\n\n#define DIV_FRAC(dividend, divisor) \\\n\t((dividend) * 100 / (divisor) - ((dividend) / (divisor) * 100))\n\nstatic int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,\n\t\tenum omap_overlay_caps caps,\n\t\tconst struct omap_video_timings *mgr_timings,\n\t\tu16 width, u16 height, u16 out_width, u16 out_height,\n\t\tenum omap_color_mode color_mode, bool *five_taps,\n\t\tint *x_predecim, int *y_predecim, u16 pos_x,\n\t\tenum omap_dss_rotation_type rotation_type, bool mem_to_mem)\n{\n\tconst int maxdownscale = dss_feat_get_param_max(FEAT_PARAM_DOWNSCALE);\n\tconst int max_decim_limit = 16;\n\tunsigned long core_clk = 0;\n\tint decim_x, decim_y, ret;\n\n\tif (width == out_width && height == out_height)\n\t\treturn 0;\n\n\tif (!mem_to_mem && (pclk == 0 || mgr_timings->pixelclock == 0)) {\n\t\tDSSERR(\"cannot calculate scaling settings: pclk is zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((caps & OMAP_DSS_OVL_CAP_SCALE) == 0)\n\t\treturn -EINVAL;\n\n\tif (mem_to_mem) {\n\t\t*x_predecim = *y_predecim = 1;\n\t} else {\n\t\t*x_predecim = max_decim_limit;\n\t\t*y_predecim = (rotation_type == OMAP_DSS_ROT_TILER &&\n\t\t\t\tdss_has_feature(FEAT_BURST_2D)) ?\n\t\t\t\t2 : max_decim_limit;\n\t}\n\n\tif (color_mode == OMAP_DSS_COLOR_CLUT1 ||\n\t    color_mode == OMAP_DSS_COLOR_CLUT2 ||\n\t    color_mode == OMAP_DSS_COLOR_CLUT4 ||\n\t    color_mode == OMAP_DSS_COLOR_CLUT8) {\n\t\t*x_predecim = 1;\n\t\t*y_predecim = 1;\n\t\t*five_taps = false;\n\t\treturn 0;\n\t}\n\n\tdecim_x = DIV_ROUND_UP(DIV_ROUND_UP(width, out_width), maxdownscale);\n\tdecim_y = DIV_ROUND_UP(DIV_ROUND_UP(height, out_height), maxdownscale);\n\n\tif (decim_x > *x_predecim || out_width > width * 8)\n\t\treturn -EINVAL;\n\n\tif (decim_y > *y_predecim || out_height > height * 8)\n\t\treturn -EINVAL;\n\n\tret = dispc.feat->calc_scaling(pclk, lclk, mgr_timings, width, height,\n\t\tout_width, out_height, color_mode, five_taps,\n\t\tx_predecim, y_predecim, &decim_x, &decim_y, pos_x, &core_clk,\n\t\tmem_to_mem);\n\tif (ret)\n\t\treturn ret;\n\n\tDSSDBG(\"%dx%d -> %dx%d (%d.%02d x %d.%02d), decim %dx%d %dx%d (%d.%02d x %d.%02d), taps %d, req clk %lu, cur clk %lu\\n\",\n\t\twidth, height,\n\t\tout_width, out_height,\n\t\tout_width / width, DIV_FRAC(out_width, width),\n\t\tout_height / height, DIV_FRAC(out_height, height),\n\n\t\tdecim_x, decim_y,\n\t\twidth / decim_x, height / decim_y,\n\t\tout_width / (width / decim_x), DIV_FRAC(out_width, width / decim_x),\n\t\tout_height / (height / decim_y), DIV_FRAC(out_height, height / decim_y),\n\n\t\t*five_taps ? 5 : 3,\n\t\tcore_clk, dispc_core_clk_rate());\n\n\tif (!core_clk || core_clk > dispc_core_clk_rate()) {\n\t\tDSSERR(\"failed to set up scaling, \"\n\t\t\t\"required core clk rate = %lu Hz, \"\n\t\t\t\"current core clk rate = %lu Hz\\n\",\n\t\t\tcore_clk, dispc_core_clk_rate());\n\t\treturn -EINVAL;\n\t}\n\n\t*x_predecim = decim_x;\n\t*y_predecim = decim_y;\n\treturn 0;\n}\n\nint dispc_ovl_check(enum omap_plane plane, enum omap_channel channel,\n\t\tconst struct omap_overlay_info *oi,\n\t\tconst struct omap_video_timings *timings,\n\t\tint *x_predecim, int *y_predecim)\n{\n\tenum omap_overlay_caps caps = dss_feat_get_overlay_caps(plane);\n\tbool five_taps = true;\n\tbool fieldmode = false;\n\tu16 in_height = oi->height;\n\tu16 in_width = oi->width;\n\tbool ilace = timings->interlace;\n\tu16 out_width, out_height;\n\tint pos_x = oi->pos_x;\n\tunsigned long pclk = dispc_mgr_pclk_rate(channel);\n\tunsigned long lclk = dispc_mgr_lclk_rate(channel);\n\n\tout_width = oi->out_width == 0 ? oi->width : oi->out_width;\n\tout_height = oi->out_height == 0 ? oi->height : oi->out_height;\n\n\tif (ilace && oi->height == out_height)\n\t\tfieldmode = true;\n\n\tif (ilace) {\n\t\tif (fieldmode)\n\t\t\tin_height /= 2;\n\t\tout_height /= 2;\n\n\t\tDSSDBG(\"adjusting for ilace: height %d, out_height %d\\n\",\n\t\t\t\tin_height, out_height);\n\t}\n\n\tif (!dss_feat_color_mode_supported(plane, oi->color_mode))\n\t\treturn -EINVAL;\n\n\treturn dispc_ovl_calc_scaling(pclk, lclk, caps, timings, in_width,\n\t\t\tin_height, out_width, out_height, oi->color_mode,\n\t\t\t&five_taps, x_predecim, y_predecim, pos_x,\n\t\t\toi->rotation_type, false);\n}\nEXPORT_SYMBOL(dispc_ovl_check);\n\nstatic int dispc_ovl_setup_common(enum omap_plane plane,\n\t\tenum omap_overlay_caps caps, u32 paddr, u32 p_uv_addr,\n\t\tu16 screen_width, int pos_x, int pos_y, u16 width, u16 height,\n\t\tu16 out_width, u16 out_height, enum omap_color_mode color_mode,\n\t\tu8 rotation, bool mirror, u8 zorder, u8 pre_mult_alpha,\n\t\tu8 global_alpha, enum omap_dss_rotation_type rotation_type,\n\t\tbool replication, const struct omap_video_timings *mgr_timings,\n\t\tbool mem_to_mem)\n{\n\tbool five_taps = true;\n\tbool fieldmode = false;\n\tint r, cconv = 0;\n\tunsigned offset0, offset1;\n\ts32 row_inc;\n\ts32 pix_inc;\n\tu16 frame_width, frame_height;\n\tunsigned int field_offset = 0;\n\tu16 in_height = height;\n\tu16 in_width = width;\n\tint x_predecim = 1, y_predecim = 1;\n\tbool ilace = mgr_timings->interlace;\n\tunsigned long pclk = dispc_plane_pclk_rate(plane);\n\tunsigned long lclk = dispc_plane_lclk_rate(plane);\n\n\tif (paddr == 0 && rotation_type != OMAP_DSS_ROT_TILER)\n\t\treturn -EINVAL;\n\n\tswitch (color_mode) {\n\tcase OMAP_DSS_COLOR_YUV2:\n\tcase OMAP_DSS_COLOR_UYVY:\n\tcase OMAP_DSS_COLOR_NV12:\n\t\tif (in_width & 1) {\n\t\t\tDSSERR(\"input width %d is not even for YUV format\\n\",\n\t\t\t\tin_width);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tout_width = out_width == 0 ? width : out_width;\n\tout_height = out_height == 0 ? height : out_height;\n\n\tif (ilace && height == out_height)\n\t\tfieldmode = true;\n\n\tif (ilace) {\n\t\tif (fieldmode)\n\t\t\tin_height /= 2;\n\t\tpos_y /= 2;\n\t\tout_height /= 2;\n\n\t\tDSSDBG(\"adjusting for ilace: height %d, pos_y %d, \"\n\t\t\t\"out_height %d\\n\", in_height, pos_y,\n\t\t\tout_height);\n\t}\n\n\tif (!dss_feat_color_mode_supported(plane, color_mode))\n\t\treturn -EINVAL;\n\n\tr = dispc_ovl_calc_scaling(pclk, lclk, caps, mgr_timings, in_width,\n\t\t\tin_height, out_width, out_height, color_mode,\n\t\t\t&five_taps, &x_predecim, &y_predecim, pos_x,\n\t\t\trotation_type, mem_to_mem);\n\tif (r)\n\t\treturn r;\n\n\tin_width = in_width / x_predecim;\n\tin_height = in_height / y_predecim;\n\n\tif (x_predecim > 1 || y_predecim > 1)\n\t\tDSSDBG(\"predecimation %d x %x, new input size %d x %d\\n\",\n\t\t\tx_predecim, y_predecim, in_width, in_height);\n\n\tswitch (color_mode) {\n\tcase OMAP_DSS_COLOR_YUV2:\n\tcase OMAP_DSS_COLOR_UYVY:\n\tcase OMAP_DSS_COLOR_NV12:\n\t\tif (in_width & 1) {\n\t\t\tDSSDBG(\"predecimated input width is not even for YUV format\\n\");\n\t\t\tDSSDBG(\"adjusting input width %d -> %d\\n\",\n\t\t\t\tin_width, in_width & ~1);\n\n\t\t\tin_width &= ~1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (color_mode == OMAP_DSS_COLOR_YUV2 ||\n\t\t\tcolor_mode == OMAP_DSS_COLOR_UYVY ||\n\t\t\tcolor_mode == OMAP_DSS_COLOR_NV12)\n\t\tcconv = 1;\n\n\tif (ilace && !fieldmode) {\n\t\t \n\t\tif (!in_height || in_height == out_height)\n\t\t\tfield_offset = 0;\n\t\telse\n\t\t\tfield_offset = in_height / out_height / 2;\n\t}\n\n\t \n\tif (fieldmode)\n\t\tfield_offset = 1;\n\n\toffset0 = 0;\n\toffset1 = 0;\n\trow_inc = 0;\n\tpix_inc = 0;\n\n\tif (plane == OMAP_DSS_WB) {\n\t\tframe_width = out_width;\n\t\tframe_height = out_height;\n\t} else {\n\t\tframe_width = in_width;\n\t\tframe_height = height;\n\t}\n\n\tif (rotation_type == OMAP_DSS_ROT_TILER)\n\t\tcalc_tiler_rotation_offset(screen_width, frame_width,\n\t\t\t\tcolor_mode, fieldmode, field_offset,\n\t\t\t\t&offset0, &offset1, &row_inc, &pix_inc,\n\t\t\t\tx_predecim, y_predecim);\n\telse if (rotation_type == OMAP_DSS_ROT_DMA)\n\t\tcalc_dma_rotation_offset(rotation, mirror, screen_width,\n\t\t\t\tframe_width, frame_height,\n\t\t\t\tcolor_mode, fieldmode, field_offset,\n\t\t\t\t&offset0, &offset1, &row_inc, &pix_inc,\n\t\t\t\tx_predecim, y_predecim);\n\telse\n\t\tcalc_vrfb_rotation_offset(rotation, mirror,\n\t\t\t\tscreen_width, frame_width, frame_height,\n\t\t\t\tcolor_mode, fieldmode, field_offset,\n\t\t\t\t&offset0, &offset1, &row_inc, &pix_inc,\n\t\t\t\tx_predecim, y_predecim);\n\n\tDSSDBG(\"offset0 %u, offset1 %u, row_inc %d, pix_inc %d\\n\",\n\t\t\toffset0, offset1, row_inc, pix_inc);\n\n\tdispc_ovl_set_color_mode(plane, color_mode);\n\n\tdispc_ovl_configure_burst_type(plane, rotation_type);\n\n\tdispc_ovl_set_ba0(plane, paddr + offset0);\n\tdispc_ovl_set_ba1(plane, paddr + offset1);\n\n\tif (OMAP_DSS_COLOR_NV12 == color_mode) {\n\t\tdispc_ovl_set_ba0_uv(plane, p_uv_addr + offset0);\n\t\tdispc_ovl_set_ba1_uv(plane, p_uv_addr + offset1);\n\t}\n\n\tif (dispc.feat->last_pixel_inc_missing)\n\t\trow_inc += pix_inc - 1;\n\n\tdispc_ovl_set_row_inc(plane, row_inc);\n\tdispc_ovl_set_pix_inc(plane, pix_inc);\n\n\tDSSDBG(\"%d,%d %dx%d -> %dx%d\\n\", pos_x, pos_y, in_width,\n\t\t\tin_height, out_width, out_height);\n\n\tdispc_ovl_set_pos(plane, caps, pos_x, pos_y);\n\n\tdispc_ovl_set_input_size(plane, in_width, in_height);\n\n\tif (caps & OMAP_DSS_OVL_CAP_SCALE) {\n\t\tdispc_ovl_set_scaling(plane, in_width, in_height, out_width,\n\t\t\t\t   out_height, ilace, five_taps, fieldmode,\n\t\t\t\t   color_mode, rotation);\n\t\tdispc_ovl_set_output_size(plane, out_width, out_height);\n\t\tdispc_ovl_set_vid_color_conv(plane, cconv);\n\t}\n\n\tdispc_ovl_set_rotation_attrs(plane, rotation, rotation_type, mirror,\n\t\t\tcolor_mode);\n\n\tdispc_ovl_set_zorder(plane, caps, zorder);\n\tdispc_ovl_set_pre_mult_alpha(plane, caps, pre_mult_alpha);\n\tdispc_ovl_setup_global_alpha(plane, caps, global_alpha);\n\n\tdispc_ovl_enable_replication(plane, caps, replication);\n\n\treturn 0;\n}\n\nint dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,\n\t\tbool replication, const struct omap_video_timings *mgr_timings,\n\t\tbool mem_to_mem)\n{\n\tint r;\n\tenum omap_overlay_caps caps = dss_feat_get_overlay_caps(plane);\n\tenum omap_channel channel;\n\n\tchannel = dispc_ovl_get_channel_out(plane);\n\n\tDSSDBG(\"dispc_ovl_setup %d, pa %pad, pa_uv %pad, sw %d, %d,%d, %dx%d ->\"\n\t\t\" %dx%d, cmode %x, rot %d, mir %d, chan %d repl %d\\n\",\n\t\tplane, &oi->paddr, &oi->p_uv_addr, oi->screen_width, oi->pos_x,\n\t\toi->pos_y, oi->width, oi->height, oi->out_width, oi->out_height,\n\t\toi->color_mode, oi->rotation, oi->mirror, channel, replication);\n\n\tr = dispc_ovl_setup_common(plane, caps, oi->paddr, oi->p_uv_addr,\n\t\toi->screen_width, oi->pos_x, oi->pos_y, oi->width, oi->height,\n\t\toi->out_width, oi->out_height, oi->color_mode, oi->rotation,\n\t\toi->mirror, oi->zorder, oi->pre_mult_alpha, oi->global_alpha,\n\t\toi->rotation_type, replication, mgr_timings, mem_to_mem);\n\n\treturn r;\n}\nEXPORT_SYMBOL(dispc_ovl_setup);\n\nint dispc_ovl_enable(enum omap_plane plane, bool enable)\n{\n\tDSSDBG(\"dispc_enable_plane %d, %d\\n\", plane, enable);\n\n\tREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 0, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dispc_ovl_enable);\n\nbool dispc_ovl_enabled(enum omap_plane plane)\n{\n\treturn REG_GET(DISPC_OVL_ATTRIBUTES(plane), 0, 0);\n}\nEXPORT_SYMBOL(dispc_ovl_enabled);\n\nvoid dispc_mgr_enable(enum omap_channel channel, bool enable)\n{\n\tmgr_fld_write(channel, DISPC_MGR_FLD_ENABLE, enable);\n\t \n\tmgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);\n}\nEXPORT_SYMBOL(dispc_mgr_enable);\n\nbool dispc_mgr_is_enabled(enum omap_channel channel)\n{\n\treturn !!mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);\n}\nEXPORT_SYMBOL(dispc_mgr_is_enabled);\n\nstatic void dispc_lcd_enable_signal_polarity(bool act_high)\n{\n\tif (!dss_has_feature(FEAT_LCDENABLEPOL))\n\t\treturn;\n\n\tREG_FLD_MOD(DISPC_CONTROL, act_high ? 1 : 0, 29, 29);\n}\n\nvoid dispc_lcd_enable_signal(bool enable)\n{\n\tif (!dss_has_feature(FEAT_LCDENABLESIGNAL))\n\t\treturn;\n\n\tREG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 28, 28);\n}\n\nvoid dispc_pck_free_enable(bool enable)\n{\n\tif (!dss_has_feature(FEAT_PCKFREEENABLE))\n\t\treturn;\n\n\tREG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 27, 27);\n}\n\nstatic void dispc_mgr_enable_fifohandcheck(enum omap_channel channel, bool enable)\n{\n\tmgr_fld_write(channel, DISPC_MGR_FLD_FIFOHANDCHECK, enable);\n}\n\n\nstatic void dispc_mgr_set_lcd_type_tft(enum omap_channel channel)\n{\n\tmgr_fld_write(channel, DISPC_MGR_FLD_STNTFT, 1);\n}\n\nstatic void dispc_set_loadmode(enum omap_dss_load_mode mode)\n{\n\tREG_FLD_MOD(DISPC_CONFIG, mode, 2, 1);\n}\n\n\nstatic void dispc_mgr_set_default_color(enum omap_channel channel, u32 color)\n{\n\tdispc_write_reg(DISPC_DEFAULT_COLOR(channel), color);\n}\n\nstatic void dispc_mgr_set_trans_key(enum omap_channel ch,\n\t\tenum omap_dss_trans_key_type type,\n\t\tu32 trans_key)\n{\n\tmgr_fld_write(ch, DISPC_MGR_FLD_TCKSELECTION, type);\n\n\tdispc_write_reg(DISPC_TRANS_COLOR(ch), trans_key);\n}\n\nstatic void dispc_mgr_enable_trans_key(enum omap_channel ch, bool enable)\n{\n\tmgr_fld_write(ch, DISPC_MGR_FLD_TCKENABLE, enable);\n}\n\nstatic void dispc_mgr_enable_alpha_fixed_zorder(enum omap_channel ch,\n\t\tbool enable)\n{\n\tif (!dss_has_feature(FEAT_ALPHA_FIXED_ZORDER))\n\t\treturn;\n\n\tif (ch == OMAP_DSS_CHANNEL_LCD)\n\t\tREG_FLD_MOD(DISPC_CONFIG, enable, 18, 18);\n\telse if (ch == OMAP_DSS_CHANNEL_DIGIT)\n\t\tREG_FLD_MOD(DISPC_CONFIG, enable, 19, 19);\n}\n\nvoid dispc_mgr_setup(enum omap_channel channel,\n\t\tconst struct omap_overlay_manager_info *info)\n{\n\tdispc_mgr_set_default_color(channel, info->default_color);\n\tdispc_mgr_set_trans_key(channel, info->trans_key_type, info->trans_key);\n\tdispc_mgr_enable_trans_key(channel, info->trans_enabled);\n\tdispc_mgr_enable_alpha_fixed_zorder(channel,\n\t\t\tinfo->partial_alpha_enabled);\n\tif (dss_has_feature(FEAT_CPR)) {\n\t\tdispc_mgr_enable_cpr(channel, info->cpr_enable);\n\t\tdispc_mgr_set_cpr_coef(channel, &info->cpr_coefs);\n\t}\n}\nEXPORT_SYMBOL(dispc_mgr_setup);\n\nstatic void dispc_mgr_set_tft_data_lines(enum omap_channel channel, u8 data_lines)\n{\n\tint code;\n\n\tswitch (data_lines) {\n\tcase 12:\n\t\tcode = 0;\n\t\tbreak;\n\tcase 16:\n\t\tcode = 1;\n\t\tbreak;\n\tcase 18:\n\t\tcode = 2;\n\t\tbreak;\n\tcase 24:\n\t\tcode = 3;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tmgr_fld_write(channel, DISPC_MGR_FLD_TFTDATALINES, code);\n}\n\nstatic void dispc_mgr_set_io_pad_mode(enum dss_io_pad_mode mode)\n{\n\tu32 l;\n\tint gpout0, gpout1;\n\n\tswitch (mode) {\n\tcase DSS_IO_PAD_MODE_RESET:\n\t\tgpout0 = 0;\n\t\tgpout1 = 0;\n\t\tbreak;\n\tcase DSS_IO_PAD_MODE_RFBI:\n\t\tgpout0 = 1;\n\t\tgpout1 = 0;\n\t\tbreak;\n\tcase DSS_IO_PAD_MODE_BYPASS:\n\t\tgpout0 = 1;\n\t\tgpout1 = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tl = dispc_read_reg(DISPC_CONTROL);\n\tl = FLD_MOD(l, gpout0, 15, 15);\n\tl = FLD_MOD(l, gpout1, 16, 16);\n\tdispc_write_reg(DISPC_CONTROL, l);\n}\n\nstatic void dispc_mgr_enable_stallmode(enum omap_channel channel, bool enable)\n{\n\tmgr_fld_write(channel, DISPC_MGR_FLD_STALLMODE, enable);\n}\n\nvoid dispc_mgr_set_lcd_config(enum omap_channel channel,\n\t\tconst struct dss_lcd_mgr_config *config)\n{\n\tdispc_mgr_set_io_pad_mode(config->io_pad_mode);\n\n\tdispc_mgr_enable_stallmode(channel, config->stallmode);\n\tdispc_mgr_enable_fifohandcheck(channel, config->fifohandcheck);\n\n\tdispc_mgr_set_clock_div(channel, &config->clock_info);\n\n\tdispc_mgr_set_tft_data_lines(channel, config->video_port_width);\n\n\tdispc_lcd_enable_signal_polarity(config->lcden_sig_polarity);\n\n\tdispc_mgr_set_lcd_type_tft(channel);\n}\nEXPORT_SYMBOL(dispc_mgr_set_lcd_config);\n\nstatic bool _dispc_mgr_size_ok(u16 width, u16 height)\n{\n\treturn width <= dispc.feat->mgr_width_max &&\n\t\theight <= dispc.feat->mgr_height_max;\n}\n\nstatic bool _dispc_lcd_timings_ok(int hsw, int hfp, int hbp,\n\t\tint vsw, int vfp, int vbp)\n{\n\tif (hsw < 1 || hsw > dispc.feat->sw_max ||\n\t\t\thfp < 1 || hfp > dispc.feat->hp_max ||\n\t\t\thbp < 1 || hbp > dispc.feat->hp_max ||\n\t\t\tvsw < 1 || vsw > dispc.feat->sw_max ||\n\t\t\tvfp < 0 || vfp > dispc.feat->vp_max ||\n\t\t\tvbp < 0 || vbp > dispc.feat->vp_max)\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool _dispc_mgr_pclk_ok(enum omap_channel channel,\n\t\tunsigned long pclk)\n{\n\tif (dss_mgr_is_lcd(channel))\n\t\treturn pclk <= dispc.feat->max_lcd_pclk;\n\telse\n\t\treturn pclk <= dispc.feat->max_tv_pclk;\n}\n\nbool dispc_mgr_timings_ok(enum omap_channel channel,\n\t\tconst struct omap_video_timings *timings)\n{\n\tif (!_dispc_mgr_size_ok(timings->x_res, timings->y_res))\n\t\treturn false;\n\n\tif (!_dispc_mgr_pclk_ok(channel, timings->pixelclock))\n\t\treturn false;\n\n\tif (dss_mgr_is_lcd(channel)) {\n\t\t \n\t\tif (timings->interlace)\n\t\t\treturn false;\n\n\t\tif (!_dispc_lcd_timings_ok(timings->hsw, timings->hfp,\n\t\t\t\ttimings->hbp, timings->vsw, timings->vfp,\n\t\t\t\ttimings->vbp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void _dispc_mgr_set_lcd_timings(enum omap_channel channel, int hsw,\n\t\tint hfp, int hbp, int vsw, int vfp, int vbp,\n\t\tenum omap_dss_signal_level vsync_level,\n\t\tenum omap_dss_signal_level hsync_level,\n\t\tenum omap_dss_signal_edge data_pclk_edge,\n\t\tenum omap_dss_signal_level de_level,\n\t\tenum omap_dss_signal_edge sync_pclk_edge)\n\n{\n\tu32 timing_h, timing_v, l;\n\tbool onoff, rf, ipc, vs, hs, de;\n\n\ttiming_h = FLD_VAL(hsw-1, dispc.feat->sw_start, 0) |\n\t\t\tFLD_VAL(hfp-1, dispc.feat->fp_start, 8) |\n\t\t\tFLD_VAL(hbp-1, dispc.feat->bp_start, 20);\n\ttiming_v = FLD_VAL(vsw-1, dispc.feat->sw_start, 0) |\n\t\t\tFLD_VAL(vfp, dispc.feat->fp_start, 8) |\n\t\t\tFLD_VAL(vbp, dispc.feat->bp_start, 20);\n\n\tdispc_write_reg(DISPC_TIMING_H(channel), timing_h);\n\tdispc_write_reg(DISPC_TIMING_V(channel), timing_v);\n\n\tswitch (vsync_level) {\n\tcase OMAPDSS_SIG_ACTIVE_LOW:\n\t\tvs = true;\n\t\tbreak;\n\tcase OMAPDSS_SIG_ACTIVE_HIGH:\n\t\tvs = false;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tswitch (hsync_level) {\n\tcase OMAPDSS_SIG_ACTIVE_LOW:\n\t\ths = true;\n\t\tbreak;\n\tcase OMAPDSS_SIG_ACTIVE_HIGH:\n\t\ths = false;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tswitch (de_level) {\n\tcase OMAPDSS_SIG_ACTIVE_LOW:\n\t\tde = true;\n\t\tbreak;\n\tcase OMAPDSS_SIG_ACTIVE_HIGH:\n\t\tde = false;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tswitch (data_pclk_edge) {\n\tcase OMAPDSS_DRIVE_SIG_RISING_EDGE:\n\t\tipc = false;\n\t\tbreak;\n\tcase OMAPDSS_DRIVE_SIG_FALLING_EDGE:\n\t\tipc = true;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t \n\tonoff = true;\n\n\tswitch (sync_pclk_edge) {\n\tcase OMAPDSS_DRIVE_SIG_FALLING_EDGE:\n\t\trf = false;\n\t\tbreak;\n\tcase OMAPDSS_DRIVE_SIG_RISING_EDGE:\n\t\trf = true;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tl = FLD_VAL(onoff, 17, 17) |\n\t\tFLD_VAL(rf, 16, 16) |\n\t\tFLD_VAL(de, 15, 15) |\n\t\tFLD_VAL(ipc, 14, 14) |\n\t\tFLD_VAL(hs, 13, 13) |\n\t\tFLD_VAL(vs, 12, 12);\n\n\t \n\tif (dispc.feat->supports_sync_align)\n\t\tl |= (1 << 18);\n\n\tdispc_write_reg(DISPC_POL_FREQ(channel), l);\n\n\tif (dispc.syscon_pol) {\n\t\tconst int shifts[] = {\n\t\t\t[OMAP_DSS_CHANNEL_LCD] = 0,\n\t\t\t[OMAP_DSS_CHANNEL_LCD2] = 1,\n\t\t\t[OMAP_DSS_CHANNEL_LCD3] = 2,\n\t\t};\n\n\t\tu32 mask, val;\n\n\t\tmask = (1 << 0) | (1 << 3) | (1 << 6);\n\t\tval = (rf << 0) | (ipc << 3) | (onoff << 6);\n\n\t\tmask <<= 16 + shifts[channel];\n\t\tval <<= 16 + shifts[channel];\n\n\t\tregmap_update_bits(dispc.syscon_pol, dispc.syscon_pol_offset,\n\t\t\tmask, val);\n\t}\n}\n\n \nvoid dispc_mgr_set_timings(enum omap_channel channel,\n\t\tconst struct omap_video_timings *timings)\n{\n\tunsigned xtot, ytot;\n\tunsigned long ht, vt;\n\tstruct omap_video_timings t = *timings;\n\n\tDSSDBG(\"channel %d xres %u yres %u\\n\", channel, t.x_res, t.y_res);\n\n\tif (!dispc_mgr_timings_ok(channel, &t)) {\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tif (dss_mgr_is_lcd(channel)) {\n\t\t_dispc_mgr_set_lcd_timings(channel, t.hsw, t.hfp, t.hbp, t.vsw,\n\t\t\t\tt.vfp, t.vbp, t.vsync_level, t.hsync_level,\n\t\t\t\tt.data_pclk_edge, t.de_level, t.sync_pclk_edge);\n\n\t\txtot = t.x_res + t.hfp + t.hsw + t.hbp;\n\t\tytot = t.y_res + t.vfp + t.vsw + t.vbp;\n\n\t\tht = timings->pixelclock / xtot;\n\t\tvt = timings->pixelclock / xtot / ytot;\n\n\t\tDSSDBG(\"pck %u\\n\", timings->pixelclock);\n\t\tDSSDBG(\"hsw %d hfp %d hbp %d vsw %d vfp %d vbp %d\\n\",\n\t\t\tt.hsw, t.hfp, t.hbp, t.vsw, t.vfp, t.vbp);\n\t\tDSSDBG(\"vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\\n\",\n\t\t\tt.vsync_level, t.hsync_level, t.data_pclk_edge,\n\t\t\tt.de_level, t.sync_pclk_edge);\n\n\t\tDSSDBG(\"hsync %luHz, vsync %luHz\\n\", ht, vt);\n\t} else {\n\t\tif (t.interlace)\n\t\t\tt.y_res /= 2;\n\t}\n\n\tdispc_mgr_set_size(channel, t.x_res, t.y_res);\n}\nEXPORT_SYMBOL(dispc_mgr_set_timings);\n\nstatic void dispc_mgr_set_lcd_divisor(enum omap_channel channel, u16 lck_div,\n\t\tu16 pck_div)\n{\n\tBUG_ON(lck_div < 1);\n\tBUG_ON(pck_div < 1);\n\n\tdispc_write_reg(DISPC_DIVISORo(channel),\n\t\t\tFLD_VAL(lck_div, 23, 16) | FLD_VAL(pck_div, 7, 0));\n\n\tif (!dss_has_feature(FEAT_CORE_CLK_DIV) &&\n\t\t\tchannel == OMAP_DSS_CHANNEL_LCD)\n\t\tdispc.core_clk_rate = dispc_fclk_rate() / lck_div;\n}\n\nstatic void dispc_mgr_get_lcd_divisor(enum omap_channel channel, int *lck_div,\n\t\tint *pck_div)\n{\n\tu32 l;\n\tl = dispc_read_reg(DISPC_DIVISORo(channel));\n\t*lck_div = FLD_GET(l, 23, 16);\n\t*pck_div = FLD_GET(l, 7, 0);\n}\n\nstatic unsigned long dispc_fclk_rate(void)\n{\n\tstruct dss_pll *pll;\n\tunsigned long r = 0;\n\n\tswitch (dss_get_dispc_clk_source()) {\n\tcase OMAP_DSS_CLK_SRC_FCK:\n\t\tr = dss_get_dispc_clk_rate();\n\t\tbreak;\n\tcase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:\n\t\tpll = dss_pll_find(\"dsi0\");\n\t\tif (!pll)\n\t\t\tpll = dss_pll_find(\"video0\");\n\n\t\tr = pll->cinfo.clkout[0];\n\t\tbreak;\n\tcase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:\n\t\tpll = dss_pll_find(\"dsi1\");\n\t\tif (!pll)\n\t\t\tpll = dss_pll_find(\"video1\");\n\n\t\tr = pll->cinfo.clkout[0];\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\treturn r;\n}\n\nstatic unsigned long dispc_mgr_lclk_rate(enum omap_channel channel)\n{\n\tstruct dss_pll *pll;\n\tint lcd;\n\tunsigned long r;\n\tu32 l;\n\n\tif (dss_mgr_is_lcd(channel)) {\n\t\tl = dispc_read_reg(DISPC_DIVISORo(channel));\n\n\t\tlcd = FLD_GET(l, 23, 16);\n\n\t\tswitch (dss_get_lcd_clk_source(channel)) {\n\t\tcase OMAP_DSS_CLK_SRC_FCK:\n\t\t\tr = dss_get_dispc_clk_rate();\n\t\t\tbreak;\n\t\tcase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:\n\t\t\tpll = dss_pll_find(\"dsi0\");\n\t\t\tif (!pll)\n\t\t\t\tpll = dss_pll_find(\"video0\");\n\n\t\t\tr = pll->cinfo.clkout[0];\n\t\t\tbreak;\n\t\tcase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:\n\t\t\tpll = dss_pll_find(\"dsi1\");\n\t\t\tif (!pll)\n\t\t\t\tpll = dss_pll_find(\"video1\");\n\n\t\t\tr = pll->cinfo.clkout[0];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn r / lcd;\n\t} else {\n\t\treturn dispc_fclk_rate();\n\t}\n}\n\nstatic unsigned long dispc_mgr_pclk_rate(enum omap_channel channel)\n{\n\tunsigned long r;\n\n\tif (dss_mgr_is_lcd(channel)) {\n\t\tint pcd;\n\t\tu32 l;\n\n\t\tl = dispc_read_reg(DISPC_DIVISORo(channel));\n\n\t\tpcd = FLD_GET(l, 7, 0);\n\n\t\tr = dispc_mgr_lclk_rate(channel);\n\n\t\treturn r / pcd;\n\t} else {\n\t\treturn dispc.tv_pclk_rate;\n\t}\n}\n\nvoid dispc_set_tv_pclk(unsigned long pclk)\n{\n\tdispc.tv_pclk_rate = pclk;\n}\n\nstatic unsigned long dispc_core_clk_rate(void)\n{\n\treturn dispc.core_clk_rate;\n}\n\nstatic unsigned long dispc_plane_pclk_rate(enum omap_plane plane)\n{\n\tenum omap_channel channel;\n\n\tif (plane == OMAP_DSS_WB)\n\t\treturn 0;\n\n\tchannel = dispc_ovl_get_channel_out(plane);\n\n\treturn dispc_mgr_pclk_rate(channel);\n}\n\nstatic unsigned long dispc_plane_lclk_rate(enum omap_plane plane)\n{\n\tenum omap_channel channel;\n\n\tif (plane == OMAP_DSS_WB)\n\t\treturn 0;\n\n\tchannel\t= dispc_ovl_get_channel_out(plane);\n\n\treturn dispc_mgr_lclk_rate(channel);\n}\n\nstatic void dispc_dump_clocks_channel(struct seq_file *s, enum omap_channel channel)\n{\n\tint lcd, pcd;\n\tenum omap_dss_clk_source lcd_clk_src;\n\n\tseq_printf(s, \"- %s -\\n\", mgr_desc[channel].name);\n\n\tlcd_clk_src = dss_get_lcd_clk_source(channel);\n\n\tseq_printf(s, \"%s clk source = %s (%s)\\n\", mgr_desc[channel].name,\n\t\tdss_get_generic_clk_source_name(lcd_clk_src),\n\t\tdss_feat_get_clk_source_name(lcd_clk_src));\n\n\tdispc_mgr_get_lcd_divisor(channel, &lcd, &pcd);\n\n\tseq_printf(s, \"lck\\t\\t%-16lulck div\\t%u\\n\",\n\t\tdispc_mgr_lclk_rate(channel), lcd);\n\tseq_printf(s, \"pck\\t\\t%-16lupck div\\t%u\\n\",\n\t\tdispc_mgr_pclk_rate(channel), pcd);\n}\n\nvoid dispc_dump_clocks(struct seq_file *s)\n{\n\tint lcd;\n\tu32 l;\n\tenum omap_dss_clk_source dispc_clk_src = dss_get_dispc_clk_source();\n\n\tif (dispc_runtime_get())\n\t\treturn;\n\n\tseq_printf(s, \"- DISPC -\\n\");\n\n\tseq_printf(s, \"dispc fclk source = %s (%s)\\n\",\n\t\t\tdss_get_generic_clk_source_name(dispc_clk_src),\n\t\t\tdss_feat_get_clk_source_name(dispc_clk_src));\n\n\tseq_printf(s, \"fck\\t\\t%-16lu\\n\", dispc_fclk_rate());\n\n\tif (dss_has_feature(FEAT_CORE_CLK_DIV)) {\n\t\tseq_printf(s, \"- DISPC-CORE-CLK -\\n\");\n\t\tl = dispc_read_reg(DISPC_DIVISOR);\n\t\tlcd = FLD_GET(l, 23, 16);\n\n\t\tseq_printf(s, \"lck\\t\\t%-16lulck div\\t%u\\n\",\n\t\t\t\t(dispc_fclk_rate()/lcd), lcd);\n\t}\n\n\tdispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD);\n\n\tif (dss_has_feature(FEAT_MGR_LCD2))\n\t\tdispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD2);\n\tif (dss_has_feature(FEAT_MGR_LCD3))\n\t\tdispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD3);\n\n\tdispc_runtime_put();\n}\n\nstatic void dispc_dump_regs(struct seq_file *s)\n{\n\tint i, j;\n\tconst char *mgr_names[] = {\n\t\t[OMAP_DSS_CHANNEL_LCD]\t\t= \"LCD\",\n\t\t[OMAP_DSS_CHANNEL_DIGIT]\t= \"TV\",\n\t\t[OMAP_DSS_CHANNEL_LCD2]\t\t= \"LCD2\",\n\t\t[OMAP_DSS_CHANNEL_LCD3]\t\t= \"LCD3\",\n\t};\n\tconst char *ovl_names[] = {\n\t\t[OMAP_DSS_GFX]\t\t= \"GFX\",\n\t\t[OMAP_DSS_VIDEO1]\t= \"VID1\",\n\t\t[OMAP_DSS_VIDEO2]\t= \"VID2\",\n\t\t[OMAP_DSS_VIDEO3]\t= \"VID3\",\n\t\t[OMAP_DSS_WB]\t\t= \"WB\",\n\t};\n\tconst char **p_names;\n\n#define DUMPREG(r) seq_printf(s, \"%-50s %08x\\n\", #r, dispc_read_reg(r))\n\n\tif (dispc_runtime_get())\n\t\treturn;\n\n\t \n\tDUMPREG(DISPC_REVISION);\n\tDUMPREG(DISPC_SYSCONFIG);\n\tDUMPREG(DISPC_SYSSTATUS);\n\tDUMPREG(DISPC_IRQSTATUS);\n\tDUMPREG(DISPC_IRQENABLE);\n\tDUMPREG(DISPC_CONTROL);\n\tDUMPREG(DISPC_CONFIG);\n\tDUMPREG(DISPC_CAPABLE);\n\tDUMPREG(DISPC_LINE_STATUS);\n\tDUMPREG(DISPC_LINE_NUMBER);\n\tif (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||\n\t\t\tdss_has_feature(FEAT_ALPHA_FREE_ZORDER))\n\t\tDUMPREG(DISPC_GLOBAL_ALPHA);\n\tif (dss_has_feature(FEAT_MGR_LCD2)) {\n\t\tDUMPREG(DISPC_CONTROL2);\n\t\tDUMPREG(DISPC_CONFIG2);\n\t}\n\tif (dss_has_feature(FEAT_MGR_LCD3)) {\n\t\tDUMPREG(DISPC_CONTROL3);\n\t\tDUMPREG(DISPC_CONFIG3);\n\t}\n\tif (dss_has_feature(FEAT_MFLAG))\n\t\tDUMPREG(DISPC_GLOBAL_MFLAG_ATTRIBUTE);\n\n#undef DUMPREG\n\n#define DISPC_REG(i, name) name(i)\n#define DUMPREG(i, r) seq_printf(s, \"%s(%s)%*s %08x\\n\", #r, p_names[i], \\\n\t(int)(48 - strlen(#r) - strlen(p_names[i])), \" \", \\\n\tdispc_read_reg(DISPC_REG(i, r)))\n\n\tp_names = mgr_names;\n\n\t \n\tfor (i = 0; i < dss_feat_get_num_mgrs(); i++) {\n\t\tDUMPREG(i, DISPC_DEFAULT_COLOR);\n\t\tDUMPREG(i, DISPC_TRANS_COLOR);\n\t\tDUMPREG(i, DISPC_SIZE_MGR);\n\n\t\tif (i == OMAP_DSS_CHANNEL_DIGIT)\n\t\t\tcontinue;\n\n\t\tDUMPREG(i, DISPC_TIMING_H);\n\t\tDUMPREG(i, DISPC_TIMING_V);\n\t\tDUMPREG(i, DISPC_POL_FREQ);\n\t\tDUMPREG(i, DISPC_DIVISORo);\n\n\t\tDUMPREG(i, DISPC_DATA_CYCLE1);\n\t\tDUMPREG(i, DISPC_DATA_CYCLE2);\n\t\tDUMPREG(i, DISPC_DATA_CYCLE3);\n\n\t\tif (dss_has_feature(FEAT_CPR)) {\n\t\t\tDUMPREG(i, DISPC_CPR_COEF_R);\n\t\t\tDUMPREG(i, DISPC_CPR_COEF_G);\n\t\t\tDUMPREG(i, DISPC_CPR_COEF_B);\n\t\t}\n\t}\n\n\tp_names = ovl_names;\n\n\tfor (i = 0; i < dss_feat_get_num_ovls(); i++) {\n\t\tDUMPREG(i, DISPC_OVL_BA0);\n\t\tDUMPREG(i, DISPC_OVL_BA1);\n\t\tDUMPREG(i, DISPC_OVL_POSITION);\n\t\tDUMPREG(i, DISPC_OVL_SIZE);\n\t\tDUMPREG(i, DISPC_OVL_ATTRIBUTES);\n\t\tDUMPREG(i, DISPC_OVL_FIFO_THRESHOLD);\n\t\tDUMPREG(i, DISPC_OVL_FIFO_SIZE_STATUS);\n\t\tDUMPREG(i, DISPC_OVL_ROW_INC);\n\t\tDUMPREG(i, DISPC_OVL_PIXEL_INC);\n\n\t\tif (dss_has_feature(FEAT_PRELOAD))\n\t\t\tDUMPREG(i, DISPC_OVL_PRELOAD);\n\t\tif (dss_has_feature(FEAT_MFLAG))\n\t\t\tDUMPREG(i, DISPC_OVL_MFLAG_THRESHOLD);\n\n\t\tif (i == OMAP_DSS_GFX) {\n\t\t\tDUMPREG(i, DISPC_OVL_WINDOW_SKIP);\n\t\t\tDUMPREG(i, DISPC_OVL_TABLE_BA);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDUMPREG(i, DISPC_OVL_FIR);\n\t\tDUMPREG(i, DISPC_OVL_PICTURE_SIZE);\n\t\tDUMPREG(i, DISPC_OVL_ACCU0);\n\t\tDUMPREG(i, DISPC_OVL_ACCU1);\n\t\tif (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {\n\t\t\tDUMPREG(i, DISPC_OVL_BA0_UV);\n\t\t\tDUMPREG(i, DISPC_OVL_BA1_UV);\n\t\t\tDUMPREG(i, DISPC_OVL_FIR2);\n\t\t\tDUMPREG(i, DISPC_OVL_ACCU2_0);\n\t\t\tDUMPREG(i, DISPC_OVL_ACCU2_1);\n\t\t}\n\t\tif (dss_has_feature(FEAT_ATTR2))\n\t\t\tDUMPREG(i, DISPC_OVL_ATTRIBUTES2);\n\t}\n\n\tif (dispc.feat->has_writeback) {\n\t\ti = OMAP_DSS_WB;\n\t\tDUMPREG(i, DISPC_OVL_BA0);\n\t\tDUMPREG(i, DISPC_OVL_BA1);\n\t\tDUMPREG(i, DISPC_OVL_SIZE);\n\t\tDUMPREG(i, DISPC_OVL_ATTRIBUTES);\n\t\tDUMPREG(i, DISPC_OVL_FIFO_THRESHOLD);\n\t\tDUMPREG(i, DISPC_OVL_FIFO_SIZE_STATUS);\n\t\tDUMPREG(i, DISPC_OVL_ROW_INC);\n\t\tDUMPREG(i, DISPC_OVL_PIXEL_INC);\n\n\t\tif (dss_has_feature(FEAT_MFLAG))\n\t\t\tDUMPREG(i, DISPC_OVL_MFLAG_THRESHOLD);\n\n\t\tDUMPREG(i, DISPC_OVL_FIR);\n\t\tDUMPREG(i, DISPC_OVL_PICTURE_SIZE);\n\t\tDUMPREG(i, DISPC_OVL_ACCU0);\n\t\tDUMPREG(i, DISPC_OVL_ACCU1);\n\t\tif (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {\n\t\t\tDUMPREG(i, DISPC_OVL_BA0_UV);\n\t\t\tDUMPREG(i, DISPC_OVL_BA1_UV);\n\t\t\tDUMPREG(i, DISPC_OVL_FIR2);\n\t\t\tDUMPREG(i, DISPC_OVL_ACCU2_0);\n\t\t\tDUMPREG(i, DISPC_OVL_ACCU2_1);\n\t\t}\n\t\tif (dss_has_feature(FEAT_ATTR2))\n\t\t\tDUMPREG(i, DISPC_OVL_ATTRIBUTES2);\n\t}\n\n#undef DISPC_REG\n#undef DUMPREG\n\n#define DISPC_REG(plane, name, i) name(plane, i)\n#define DUMPREG(plane, name, i) \\\n\tseq_printf(s, \"%s_%d(%s)%*s %08x\\n\", #name, i, p_names[plane], \\\n\t(int)(46 - strlen(#name) - strlen(p_names[plane])), \" \", \\\n\tdispc_read_reg(DISPC_REG(plane, name, i)))\n\n\t \n\n\t \n\tfor (i = 1; i < dss_feat_get_num_ovls(); i++) {\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tDUMPREG(i, DISPC_OVL_FIR_COEF_H, j);\n\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tDUMPREG(i, DISPC_OVL_FIR_COEF_HV, j);\n\n\t\tfor (j = 0; j < 5; j++)\n\t\t\tDUMPREG(i, DISPC_OVL_CONV_COEF, j);\n\n\t\tif (dss_has_feature(FEAT_FIR_COEF_V)) {\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tDUMPREG(i, DISPC_OVL_FIR_COEF_V, j);\n\t\t}\n\n\t\tif (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tDUMPREG(i, DISPC_OVL_FIR_COEF_H2, j);\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tDUMPREG(i, DISPC_OVL_FIR_COEF_HV2, j);\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tDUMPREG(i, DISPC_OVL_FIR_COEF_V2, j);\n\t\t}\n\t}\n\n\tdispc_runtime_put();\n\n#undef DISPC_REG\n#undef DUMPREG\n}\n\n \nint dispc_calc_clock_rates(unsigned long dispc_fclk_rate,\n\t\tstruct dispc_clock_info *cinfo)\n{\n\tif (cinfo->lck_div > 255 || cinfo->lck_div == 0)\n\t\treturn -EINVAL;\n\tif (cinfo->pck_div < 1 || cinfo->pck_div > 255)\n\t\treturn -EINVAL;\n\n\tcinfo->lck = dispc_fclk_rate / cinfo->lck_div;\n\tcinfo->pck = cinfo->lck / cinfo->pck_div;\n\n\treturn 0;\n}\n\nbool dispc_div_calc(unsigned long dispc,\n\t\tunsigned long pck_min, unsigned long pck_max,\n\t\tdispc_div_calc_func func, void *data)\n{\n\tint lckd, lckd_start, lckd_stop;\n\tint pckd, pckd_start, pckd_stop;\n\tunsigned long pck, lck;\n\tunsigned long lck_max;\n\tunsigned long pckd_hw_min, pckd_hw_max;\n\tunsigned min_fck_per_pck;\n\tunsigned long fck;\n\n#ifdef CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK\n\tmin_fck_per_pck = CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK;\n#else\n\tmin_fck_per_pck = 0;\n#endif\n\n\tpckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\n\tpckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\n\n\tlck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n\n\tpck_min = pck_min ? pck_min : 1;\n\tpck_max = pck_max ? pck_max : ULONG_MAX;\n\n\tlckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);\n\tlckd_stop = min(dispc / pck_min, 255ul);\n\n\tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n\t\tlck = dispc / lckd;\n\n\t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n\t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n\n\t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n\t\t\tpck = lck / pckd;\n\n\t\t\t \n\t\t\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n\t\t\t\tfck = dispc_core_clk_rate();\n\t\t\telse\n\t\t\t\tfck = lck;\n\n\t\t\tif (fck < pck * min_fck_per_pck)\n\t\t\t\tcontinue;\n\n\t\t\tif (func(lckd, pckd, lck, pck, data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid dispc_mgr_set_clock_div(enum omap_channel channel,\n\t\tconst struct dispc_clock_info *cinfo)\n{\n\tDSSDBG(\"lck = %lu (%u)\\n\", cinfo->lck, cinfo->lck_div);\n\tDSSDBG(\"pck = %lu (%u)\\n\", cinfo->pck, cinfo->pck_div);\n\n\tdispc_mgr_set_lcd_divisor(channel, cinfo->lck_div, cinfo->pck_div);\n}\n\nint dispc_mgr_get_clock_div(enum omap_channel channel,\n\t\tstruct dispc_clock_info *cinfo)\n{\n\tunsigned long fck;\n\n\tfck = dispc_fclk_rate();\n\n\tcinfo->lck_div = REG_GET(DISPC_DIVISORo(channel), 23, 16);\n\tcinfo->pck_div = REG_GET(DISPC_DIVISORo(channel), 7, 0);\n\n\tcinfo->lck = fck / cinfo->lck_div;\n\tcinfo->pck = cinfo->lck / cinfo->pck_div;\n\n\treturn 0;\n}\n\nu32 dispc_read_irqstatus(void)\n{\n\treturn dispc_read_reg(DISPC_IRQSTATUS);\n}\nEXPORT_SYMBOL(dispc_read_irqstatus);\n\nvoid dispc_clear_irqstatus(u32 mask)\n{\n\tdispc_write_reg(DISPC_IRQSTATUS, mask);\n}\nEXPORT_SYMBOL(dispc_clear_irqstatus);\n\nu32 dispc_read_irqenable(void)\n{\n\treturn dispc_read_reg(DISPC_IRQENABLE);\n}\nEXPORT_SYMBOL(dispc_read_irqenable);\n\nvoid dispc_write_irqenable(u32 mask)\n{\n\tu32 old_mask = dispc_read_reg(DISPC_IRQENABLE);\n\n\t \n\tdispc_clear_irqstatus((mask ^ old_mask) & mask);\n\n\tdispc_write_reg(DISPC_IRQENABLE, mask);\n}\nEXPORT_SYMBOL(dispc_write_irqenable);\n\nvoid dispc_enable_sidle(void)\n{\n\tREG_FLD_MOD(DISPC_SYSCONFIG, 2, 4, 3);\t \n}\n\nvoid dispc_disable_sidle(void)\n{\n\tREG_FLD_MOD(DISPC_SYSCONFIG, 1, 4, 3);\t \n}\n\nstatic void _omap_dispc_initial_config(void)\n{\n\tu32 l;\n\n\t \n\tif (dss_has_feature(FEAT_CORE_CLK_DIV)) {\n\t\tl = dispc_read_reg(DISPC_DIVISOR);\n\t\t \n\t\tl = FLD_MOD(l, 1, 0, 0);\n\t\tl = FLD_MOD(l, 1, 23, 16);\n\t\tdispc_write_reg(DISPC_DIVISOR, l);\n\n\t\tdispc.core_clk_rate = dispc_fclk_rate();\n\t}\n\n\t \n\tif (dss_has_feature(FEAT_FUNCGATED))\n\t\tREG_FLD_MOD(DISPC_CONFIG, 1, 9, 9);\n\n\tdispc_setup_color_conv_coef();\n\n\tdispc_set_loadmode(OMAP_DSS_LOAD_FRAME_ONLY);\n\n\tdispc_init_fifos();\n\n\tdispc_configure_burst_sizes();\n\n\tdispc_ovl_enable_zorder_planes();\n\n\tif (dispc.feat->mstandby_workaround)\n\t\tREG_FLD_MOD(DISPC_MSTANDBY_CTRL, 1, 0, 0);\n\n\tif (dss_has_feature(FEAT_MFLAG))\n\t\tdispc_init_mflag();\n}\n\nstatic const struct dispc_features omap24xx_dispc_feats = {\n\t.sw_start\t\t=\t5,\n\t.fp_start\t\t=\t15,\n\t.bp_start\t\t=\t27,\n\t.sw_max\t\t\t=\t64,\n\t.vp_max\t\t\t=\t255,\n\t.hp_max\t\t\t=\t256,\n\t.mgr_width_start\t=\t10,\n\t.mgr_height_start\t=\t26,\n\t.mgr_width_max\t\t=\t2048,\n\t.mgr_height_max\t\t=\t2048,\n\t.max_lcd_pclk\t\t=\t66500000,\n\t.calc_scaling\t\t=\tdispc_ovl_calc_scaling_24xx,\n\t.calc_core_clk\t\t=\tcalc_core_clk_24xx,\n\t.num_fifos\t\t=\t3,\n\t.no_framedone_tv\t=\ttrue,\n\t.set_max_preload\t=\tfalse,\n\t.last_pixel_inc_missing\t=\ttrue,\n};\n\nstatic const struct dispc_features omap34xx_rev1_0_dispc_feats = {\n\t.sw_start\t\t=\t5,\n\t.fp_start\t\t=\t15,\n\t.bp_start\t\t=\t27,\n\t.sw_max\t\t\t=\t64,\n\t.vp_max\t\t\t=\t255,\n\t.hp_max\t\t\t=\t256,\n\t.mgr_width_start\t=\t10,\n\t.mgr_height_start\t=\t26,\n\t.mgr_width_max\t\t=\t2048,\n\t.mgr_height_max\t\t=\t2048,\n\t.max_lcd_pclk\t\t=\t173000000,\n\t.max_tv_pclk\t\t=\t59000000,\n\t.calc_scaling\t\t=\tdispc_ovl_calc_scaling_34xx,\n\t.calc_core_clk\t\t=\tcalc_core_clk_34xx,\n\t.num_fifos\t\t=\t3,\n\t.no_framedone_tv\t=\ttrue,\n\t.set_max_preload\t=\tfalse,\n\t.last_pixel_inc_missing\t=\ttrue,\n};\n\nstatic const struct dispc_features omap34xx_rev3_0_dispc_feats = {\n\t.sw_start\t\t=\t7,\n\t.fp_start\t\t=\t19,\n\t.bp_start\t\t=\t31,\n\t.sw_max\t\t\t=\t256,\n\t.vp_max\t\t\t=\t4095,\n\t.hp_max\t\t\t=\t4096,\n\t.mgr_width_start\t=\t10,\n\t.mgr_height_start\t=\t26,\n\t.mgr_width_max\t\t=\t2048,\n\t.mgr_height_max\t\t=\t2048,\n\t.max_lcd_pclk\t\t=\t173000000,\n\t.max_tv_pclk\t\t=\t59000000,\n\t.calc_scaling\t\t=\tdispc_ovl_calc_scaling_34xx,\n\t.calc_core_clk\t\t=\tcalc_core_clk_34xx,\n\t.num_fifos\t\t=\t3,\n\t.no_framedone_tv\t=\ttrue,\n\t.set_max_preload\t=\tfalse,\n\t.last_pixel_inc_missing\t=\ttrue,\n};\n\nstatic const struct dispc_features omap44xx_dispc_feats = {\n\t.sw_start\t\t=\t7,\n\t.fp_start\t\t=\t19,\n\t.bp_start\t\t=\t31,\n\t.sw_max\t\t\t=\t256,\n\t.vp_max\t\t\t=\t4095,\n\t.hp_max\t\t\t=\t4096,\n\t.mgr_width_start\t=\t10,\n\t.mgr_height_start\t=\t26,\n\t.mgr_width_max\t\t=\t2048,\n\t.mgr_height_max\t\t=\t2048,\n\t.max_lcd_pclk\t\t=\t170000000,\n\t.max_tv_pclk\t\t=\t185625000,\n\t.calc_scaling\t\t=\tdispc_ovl_calc_scaling_44xx,\n\t.calc_core_clk\t\t=\tcalc_core_clk_44xx,\n\t.num_fifos\t\t=\t5,\n\t.gfx_fifo_workaround\t=\ttrue,\n\t.set_max_preload\t=\ttrue,\n\t.supports_sync_align\t=\ttrue,\n\t.has_writeback\t\t=\ttrue,\n};\n\nstatic const struct dispc_features omap54xx_dispc_feats = {\n\t.sw_start\t\t=\t7,\n\t.fp_start\t\t=\t19,\n\t.bp_start\t\t=\t31,\n\t.sw_max\t\t\t=\t256,\n\t.vp_max\t\t\t=\t4095,\n\t.hp_max\t\t\t=\t4096,\n\t.mgr_width_start\t=\t11,\n\t.mgr_height_start\t=\t27,\n\t.mgr_width_max\t\t=\t4096,\n\t.mgr_height_max\t\t=\t4096,\n\t.max_lcd_pclk\t\t=\t170000000,\n\t.max_tv_pclk\t\t=\t186000000,\n\t.calc_scaling\t\t=\tdispc_ovl_calc_scaling_44xx,\n\t.calc_core_clk\t\t=\tcalc_core_clk_44xx,\n\t.num_fifos\t\t=\t5,\n\t.gfx_fifo_workaround\t=\ttrue,\n\t.mstandby_workaround\t=\ttrue,\n\t.set_max_preload\t=\ttrue,\n\t.supports_sync_align\t=\ttrue,\n\t.has_writeback\t\t=\ttrue,\n};\n\nstatic const struct dispc_features *dispc_get_features(void)\n{\n\tswitch (omapdss_get_version()) {\n\tcase OMAPDSS_VER_OMAP24xx:\n\t\treturn &omap24xx_dispc_feats;\n\n\tcase OMAPDSS_VER_OMAP34xx_ES1:\n\t\treturn &omap34xx_rev1_0_dispc_feats;\n\n\tcase OMAPDSS_VER_OMAP34xx_ES3:\n\tcase OMAPDSS_VER_OMAP3630:\n\tcase OMAPDSS_VER_AM35xx:\n\tcase OMAPDSS_VER_AM43xx:\n\t\treturn &omap34xx_rev3_0_dispc_feats;\n\n\tcase OMAPDSS_VER_OMAP4430_ES1:\n\tcase OMAPDSS_VER_OMAP4430_ES2:\n\tcase OMAPDSS_VER_OMAP4:\n\t\treturn &omap44xx_dispc_feats;\n\n\tcase OMAPDSS_VER_OMAP5:\n\tcase OMAPDSS_VER_DRA7xx:\n\t\treturn &omap54xx_dispc_feats;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic irqreturn_t dispc_irq_handler(int irq, void *arg)\n{\n\tif (!dispc.is_enabled)\n\t\treturn IRQ_NONE;\n\n\treturn dispc.user_handler(irq, dispc.user_data);\n}\n\nint dispc_request_irq(irq_handler_t handler, void *dev_id)\n{\n\tint r;\n\n\tif (dispc.user_handler != NULL)\n\t\treturn -EBUSY;\n\n\tdispc.user_handler = handler;\n\tdispc.user_data = dev_id;\n\n\t \n\tsmp_wmb();\n\n\tr = devm_request_irq(&dispc.pdev->dev, dispc.irq, dispc_irq_handler,\n\t\t\t     IRQF_SHARED, \"OMAP DISPC\", &dispc);\n\tif (r) {\n\t\tdispc.user_handler = NULL;\n\t\tdispc.user_data = NULL;\n\t}\n\n\treturn r;\n}\nEXPORT_SYMBOL(dispc_request_irq);\n\nvoid dispc_free_irq(void *dev_id)\n{\n\tdevm_free_irq(&dispc.pdev->dev, dispc.irq, &dispc);\n\n\tdispc.user_handler = NULL;\n\tdispc.user_data = NULL;\n}\nEXPORT_SYMBOL(dispc_free_irq);\n\n \nstatic int dispc_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tu32 rev;\n\tint r = 0;\n\tstruct resource *dispc_mem;\n\tstruct device_node *np = pdev->dev.of_node;\n\n\tdispc.pdev = pdev;\n\n\tspin_lock_init(&dispc.control_lock);\n\n\tdispc.feat = dispc_get_features();\n\tif (!dispc.feat)\n\t\treturn -ENODEV;\n\n\tdispc_mem = platform_get_resource(dispc.pdev, IORESOURCE_MEM, 0);\n\tif (!dispc_mem) {\n\t\tDSSERR(\"can't get IORESOURCE_MEM DISPC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdispc.base = devm_ioremap(&pdev->dev, dispc_mem->start,\n\t\t\t\t  resource_size(dispc_mem));\n\tif (!dispc.base) {\n\t\tDSSERR(\"can't ioremap DISPC\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdispc.irq = platform_get_irq(dispc.pdev, 0);\n\tif (dispc.irq < 0) {\n\t\tDSSERR(\"platform_get_irq failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (np && of_property_read_bool(np, \"syscon-pol\")) {\n\t\tdispc.syscon_pol = syscon_regmap_lookup_by_phandle(np, \"syscon-pol\");\n\t\tif (IS_ERR(dispc.syscon_pol)) {\n\t\t\tdev_err(&pdev->dev, \"failed to get syscon-pol regmap\\n\");\n\t\t\treturn PTR_ERR(dispc.syscon_pol);\n\t\t}\n\n\t\tif (of_property_read_u32_index(np, \"syscon-pol\", 1,\n\t\t\t\t&dispc.syscon_pol_offset)) {\n\t\t\tdev_err(&pdev->dev, \"failed to get syscon-pol offset\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tr = dispc_runtime_get();\n\tif (r)\n\t\tgoto err_runtime_get;\n\n\t_omap_dispc_initial_config();\n\n\trev = dispc_read_reg(DISPC_REVISION);\n\tdev_dbg(&pdev->dev, \"OMAP DISPC rev %d.%d\\n\",\n\t       FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));\n\n\tdispc_runtime_put();\n\n\tdss_init_overlay_managers();\n\n\tdss_debugfs_create_file(\"dispc\", dispc_dump_regs);\n\n\treturn 0;\n\nerr_runtime_get:\n\tpm_runtime_disable(&pdev->dev);\n\treturn r;\n}\n\nstatic void dispc_unbind(struct device *dev, struct device *master,\n\t\t\t       void *data)\n{\n\tpm_runtime_disable(dev);\n\n\tdss_uninit_overlay_managers();\n}\n\nstatic const struct component_ops dispc_component_ops = {\n\t.bind\t= dispc_bind,\n\t.unbind\t= dispc_unbind,\n};\n\nstatic int dispc_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &dispc_component_ops);\n}\n\nstatic void dispc_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &dispc_component_ops);\n}\n\nstatic int dispc_runtime_suspend(struct device *dev)\n{\n\tdispc.is_enabled = false;\n\t \n\tsmp_wmb();\n\t \n\tsynchronize_irq(dispc.irq);\n\n\tdispc_save_context();\n\n\treturn 0;\n}\n\nstatic int dispc_runtime_resume(struct device *dev)\n{\n\t \n\tif (REG_GET(DISPC_CONFIG, 2, 1) != OMAP_DSS_LOAD_FRAME_ONLY) {\n\t\t_omap_dispc_initial_config();\n\n\t\tdispc_restore_context();\n\t}\n\n\tdispc.is_enabled = true;\n\t \n\tsmp_wmb();\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dispc_pm_ops = {\n\t.runtime_suspend = dispc_runtime_suspend,\n\t.runtime_resume = dispc_runtime_resume,\n};\n\nstatic const struct of_device_id dispc_of_match[] = {\n\t{ .compatible = \"ti,omap2-dispc\", },\n\t{ .compatible = \"ti,omap3-dispc\", },\n\t{ .compatible = \"ti,omap4-dispc\", },\n\t{ .compatible = \"ti,omap5-dispc\", },\n\t{ .compatible = \"ti,dra7-dispc\", },\n\t{},\n};\n\nstatic struct platform_driver omap_dispchw_driver = {\n\t.probe\t\t= dispc_probe,\n\t.remove_new     = dispc_remove,\n\t.driver         = {\n\t\t.name   = \"omapdss_dispc\",\n\t\t.pm\t= &dispc_pm_ops,\n\t\t.of_match_table = dispc_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nint __init dispc_init_platform_driver(void)\n{\n\treturn platform_driver_register(&omap_dispchw_driver);\n}\n\nvoid dispc_uninit_platform_driver(void)\n{\n\tplatform_driver_unregister(&omap_dispchw_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}