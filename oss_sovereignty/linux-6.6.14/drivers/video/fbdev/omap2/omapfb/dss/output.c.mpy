{
  "module_name": "output.c",
  "hash_id": "c10460c299e98f48f4646d8b726208f613df4b860bc50e9d1c49b235864373e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/output.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n\nstatic LIST_HEAD(output_list);\nstatic DEFINE_MUTEX(output_lock);\n\nint omapdss_output_set_device(struct omap_dss_device *out,\n\t\tstruct omap_dss_device *dssdev)\n{\n\tint r;\n\n\tmutex_lock(&output_lock);\n\n\tif (out->dst) {\n\t\tDSSERR(\"output already has device %s connected to it\\n\",\n\t\t\tout->dst->name);\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (out->output_type != dssdev->type) {\n\t\tDSSERR(\"output type and display type don't match\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tout->dst = dssdev;\n\tdssdev->src = out;\n\n\tmutex_unlock(&output_lock);\n\n\treturn 0;\nerr:\n\tmutex_unlock(&output_lock);\n\n\treturn r;\n}\nEXPORT_SYMBOL(omapdss_output_set_device);\n\nint omapdss_output_unset_device(struct omap_dss_device *out)\n{\n\tint r;\n\n\tmutex_lock(&output_lock);\n\n\tif (!out->dst) {\n\t\tDSSERR(\"output doesn't have a device connected to it\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (out->dst->state != OMAP_DSS_DISPLAY_DISABLED) {\n\t\tDSSERR(\"device %s is not disabled, cannot unset device\\n\",\n\t\t\t\tout->dst->name);\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tout->dst->src = NULL;\n\tout->dst = NULL;\n\n\tmutex_unlock(&output_lock);\n\n\treturn 0;\nerr:\n\tmutex_unlock(&output_lock);\n\n\treturn r;\n}\nEXPORT_SYMBOL(omapdss_output_unset_device);\n\nint omapdss_register_output(struct omap_dss_device *out)\n{\n\tlist_add_tail(&out->list, &output_list);\n\treturn 0;\n}\nEXPORT_SYMBOL(omapdss_register_output);\n\nvoid omapdss_unregister_output(struct omap_dss_device *out)\n{\n\tlist_del(&out->list);\n}\nEXPORT_SYMBOL(omapdss_unregister_output);\n\nstruct omap_dss_device *omap_dss_get_output(enum omap_dss_output_id id)\n{\n\tstruct omap_dss_device *out;\n\n\tlist_for_each_entry(out, &output_list, list) {\n\t\tif (out->id == id)\n\t\t\treturn out;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(omap_dss_get_output);\n\nstruct omap_dss_device *omap_dss_find_output(const char *name)\n{\n\tstruct omap_dss_device *out;\n\n\tlist_for_each_entry(out, &output_list, list) {\n\t\tif (strcmp(out->name, name) == 0)\n\t\t\treturn omap_dss_get_device(out);\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(omap_dss_find_output);\n\nstruct omap_dss_device *omap_dss_find_output_by_port_node(struct device_node *port)\n{\n\tstruct device_node *src_node;\n\tstruct omap_dss_device *out;\n\tu32 reg;\n\n\tsrc_node = dss_of_port_get_parent_device(port);\n\tif (!src_node)\n\t\treturn NULL;\n\n\treg = dss_of_port_get_port_number(port);\n\n\tlist_for_each_entry(out, &output_list, list) {\n\t\tif (out->dev->of_node == src_node && out->port_num == reg) {\n\t\t\tof_node_put(src_node);\n\t\t\treturn omap_dss_get_device(out);\n\t\t}\n\t}\n\n\tof_node_put(src_node);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(omap_dss_find_output_by_port_node);\n\nstruct omap_dss_device *omapdss_find_output_from_display(struct omap_dss_device *dssdev)\n{\n\twhile (dssdev->src)\n\t\tdssdev = dssdev->src;\n\n\tif (dssdev->id != 0)\n\t\treturn omap_dss_get_device(dssdev);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(omapdss_find_output_from_display);\n\nstruct omap_overlay_manager *omapdss_find_mgr_from_display(struct omap_dss_device *dssdev)\n{\n\tstruct omap_dss_device *out;\n\tstruct omap_overlay_manager *mgr;\n\n\tout = omapdss_find_output_from_display(dssdev);\n\n\tif (out == NULL)\n\t\treturn NULL;\n\n\tmgr = out->manager;\n\n\tomap_dss_put_device(out);\n\n\treturn mgr;\n}\nEXPORT_SYMBOL(omapdss_find_mgr_from_display);\n\nstatic const struct dss_mgr_ops *dss_mgr_ops;\n\nint dss_install_mgr_ops(const struct dss_mgr_ops *mgr_ops)\n{\n\tif (dss_mgr_ops)\n\t\treturn -EBUSY;\n\n\tdss_mgr_ops = mgr_ops;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dss_install_mgr_ops);\n\nvoid dss_uninstall_mgr_ops(void)\n{\n\tdss_mgr_ops = NULL;\n}\nEXPORT_SYMBOL(dss_uninstall_mgr_ops);\n\nint dss_mgr_connect(struct omap_overlay_manager *mgr,\n\t\tstruct omap_dss_device *dst)\n{\n\treturn dss_mgr_ops->connect(mgr, dst);\n}\nEXPORT_SYMBOL(dss_mgr_connect);\n\nvoid dss_mgr_disconnect(struct omap_overlay_manager *mgr,\n\t\tstruct omap_dss_device *dst)\n{\n\tdss_mgr_ops->disconnect(mgr, dst);\n}\nEXPORT_SYMBOL(dss_mgr_disconnect);\n\nvoid dss_mgr_set_timings(struct omap_overlay_manager *mgr,\n\t\tconst struct omap_video_timings *timings)\n{\n\tdss_mgr_ops->set_timings(mgr, timings);\n}\nEXPORT_SYMBOL(dss_mgr_set_timings);\n\nvoid dss_mgr_set_lcd_config(struct omap_overlay_manager *mgr,\n\t\tconst struct dss_lcd_mgr_config *config)\n{\n\tdss_mgr_ops->set_lcd_config(mgr, config);\n}\nEXPORT_SYMBOL(dss_mgr_set_lcd_config);\n\nint dss_mgr_enable(struct omap_overlay_manager *mgr)\n{\n\treturn dss_mgr_ops->enable(mgr);\n}\nEXPORT_SYMBOL(dss_mgr_enable);\n\nvoid dss_mgr_disable(struct omap_overlay_manager *mgr)\n{\n\tdss_mgr_ops->disable(mgr);\n}\nEXPORT_SYMBOL(dss_mgr_disable);\n\nvoid dss_mgr_start_update(struct omap_overlay_manager *mgr)\n{\n\tdss_mgr_ops->start_update(mgr);\n}\nEXPORT_SYMBOL(dss_mgr_start_update);\n\nint dss_mgr_register_framedone_handler(struct omap_overlay_manager *mgr,\n\t\tvoid (*handler)(void *), void *data)\n{\n\treturn dss_mgr_ops->register_framedone_handler(mgr, handler, data);\n}\nEXPORT_SYMBOL(dss_mgr_register_framedone_handler);\n\nvoid dss_mgr_unregister_framedone_handler(struct omap_overlay_manager *mgr,\n\t\tvoid (*handler)(void *), void *data)\n{\n\tdss_mgr_ops->unregister_framedone_handler(mgr, handler, data);\n}\nEXPORT_SYMBOL(dss_mgr_unregister_framedone_handler);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}