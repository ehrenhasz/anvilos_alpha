{
  "module_name": "overlay-sysfs.c",
  "hash_id": "c7cee330cafac2a6419f8664b7cfc75ea8bfe6f1009c8636e4840525dfd8be86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/overlay-sysfs.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"OVERLAY\"\n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/kstrtox.h>\n#include <linux/platform_device.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"dss_features.h\"\n\nstatic ssize_t overlay_name_show(struct omap_overlay *ovl, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", ovl->name);\n}\n\nstatic ssize_t overlay_manager_show(struct omap_overlay *ovl, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\tovl->manager ? ovl->manager->name : \"<none>\");\n}\n\nstatic ssize_t overlay_manager_store(struct omap_overlay *ovl, const char *buf,\n\t\tsize_t size)\n{\n\tint i, r;\n\tstruct omap_overlay_manager *mgr = NULL;\n\tstruct omap_overlay_manager *old_mgr;\n\tint len = size;\n\n\tif (buf[size-1] == '\\n')\n\t\t--len;\n\n\tif (len > 0) {\n\t\tfor (i = 0; i < omap_dss_get_num_overlay_managers(); ++i) {\n\t\t\tmgr = omap_dss_get_overlay_manager(i);\n\n\t\t\tif (sysfs_streq(buf, mgr->name))\n\t\t\t\tbreak;\n\n\t\t\tmgr = NULL;\n\t\t}\n\t}\n\n\tif (len > 0 && mgr == NULL)\n\t\treturn -EINVAL;\n\n\tif (mgr)\n\t\tDSSDBG(\"manager %s found\\n\", mgr->name);\n\n\tif (mgr == ovl->manager)\n\t\treturn size;\n\n\told_mgr = ovl->manager;\n\n\tr = dispc_runtime_get();\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (old_mgr) {\n\t\tr = ovl->unset_manager(ovl);\n\t\tif (r) {\n\t\t\tDSSERR(\"detach failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tr = old_mgr->apply(old_mgr);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tif (mgr) {\n\t\tr = ovl->set_manager(ovl, mgr);\n\t\tif (r) {\n\t\t\tDSSERR(\"Failed to attach overlay\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tr = mgr->apply(mgr);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tdispc_runtime_put();\n\n\treturn size;\n\nerr:\n\tdispc_runtime_put();\n\treturn r;\n}\n\nstatic ssize_t overlay_input_size_show(struct omap_overlay *ovl, char *buf)\n{\n\tstruct omap_overlay_info info;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\treturn sysfs_emit(buf, \"%d,%d\\n\",\n\t\t\tinfo.width, info.height);\n}\n\nstatic ssize_t overlay_screen_width_show(struct omap_overlay *ovl, char *buf)\n{\n\tstruct omap_overlay_info info;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\treturn sysfs_emit(buf, \"%d\\n\", info.screen_width);\n}\n\nstatic ssize_t overlay_position_show(struct omap_overlay *ovl, char *buf)\n{\n\tstruct omap_overlay_info info;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\treturn sysfs_emit(buf, \"%d,%d\\n\",\n\t\t\tinfo.pos_x, info.pos_y);\n}\n\nstatic ssize_t overlay_position_store(struct omap_overlay *ovl,\n\t\tconst char *buf, size_t size)\n{\n\tint r;\n\tchar *last;\n\tstruct omap_overlay_info info;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\tinfo.pos_x = simple_strtoul(buf, &last, 10);\n\t++last;\n\tif (last - buf >= size)\n\t\treturn -EINVAL;\n\n\tinfo.pos_y = simple_strtoul(last, &last, 10);\n\n\tr = ovl->set_overlay_info(ovl, &info);\n\tif (r)\n\t\treturn r;\n\n\tif (ovl->manager) {\n\t\tr = ovl->manager->apply(ovl->manager);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t overlay_output_size_show(struct omap_overlay *ovl, char *buf)\n{\n\tstruct omap_overlay_info info;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\treturn sysfs_emit(buf, \"%d,%d\\n\",\n\t\t\tinfo.out_width, info.out_height);\n}\n\nstatic ssize_t overlay_output_size_store(struct omap_overlay *ovl,\n\t\tconst char *buf, size_t size)\n{\n\tint r;\n\tchar *last;\n\tstruct omap_overlay_info info;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\tinfo.out_width = simple_strtoul(buf, &last, 10);\n\t++last;\n\tif (last - buf >= size)\n\t\treturn -EINVAL;\n\n\tinfo.out_height = simple_strtoul(last, &last, 10);\n\n\tr = ovl->set_overlay_info(ovl, &info);\n\tif (r)\n\t\treturn r;\n\n\tif (ovl->manager) {\n\t\tr = ovl->manager->apply(ovl->manager);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t overlay_enabled_show(struct omap_overlay *ovl, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ovl->is_enabled(ovl));\n}\n\nstatic ssize_t overlay_enabled_store(struct omap_overlay *ovl, const char *buf,\n\t\tsize_t size)\n{\n\tint r;\n\tbool enable;\n\n\tr = kstrtobool(buf, &enable);\n\tif (r)\n\t\treturn r;\n\n\tif (enable)\n\t\tr = ovl->enable(ovl);\n\telse\n\t\tr = ovl->disable(ovl);\n\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstatic ssize_t overlay_global_alpha_show(struct omap_overlay *ovl, char *buf)\n{\n\tstruct omap_overlay_info info;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\tinfo.global_alpha);\n}\n\nstatic ssize_t overlay_global_alpha_store(struct omap_overlay *ovl,\n\t\tconst char *buf, size_t size)\n{\n\tint r;\n\tu8 alpha;\n\tstruct omap_overlay_info info;\n\n\tif ((ovl->caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA) == 0)\n\t\treturn -ENODEV;\n\n\tr = kstrtou8(buf, 0, &alpha);\n\tif (r)\n\t\treturn r;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\tinfo.global_alpha = alpha;\n\n\tr = ovl->set_overlay_info(ovl, &info);\n\tif (r)\n\t\treturn r;\n\n\tif (ovl->manager) {\n\t\tr = ovl->manager->apply(ovl->manager);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t overlay_pre_mult_alpha_show(struct omap_overlay *ovl,\n\t\tchar *buf)\n{\n\tstruct omap_overlay_info info;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\tinfo.pre_mult_alpha);\n}\n\nstatic ssize_t overlay_pre_mult_alpha_store(struct omap_overlay *ovl,\n\t\tconst char *buf, size_t size)\n{\n\tint r;\n\tu8 alpha;\n\tstruct omap_overlay_info info;\n\n\tif ((ovl->caps & OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA) == 0)\n\t\treturn -ENODEV;\n\n\tr = kstrtou8(buf, 0, &alpha);\n\tif (r)\n\t\treturn r;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\tinfo.pre_mult_alpha = alpha;\n\n\tr = ovl->set_overlay_info(ovl, &info);\n\tif (r)\n\t\treturn r;\n\n\tif (ovl->manager) {\n\t\tr = ovl->manager->apply(ovl->manager);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t overlay_zorder_show(struct omap_overlay *ovl, char *buf)\n{\n\tstruct omap_overlay_info info;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\treturn sysfs_emit(buf, \"%d\\n\", info.zorder);\n}\n\nstatic ssize_t overlay_zorder_store(struct omap_overlay *ovl,\n\t\tconst char *buf, size_t size)\n{\n\tint r;\n\tu8 zorder;\n\tstruct omap_overlay_info info;\n\n\tif ((ovl->caps & OMAP_DSS_OVL_CAP_ZORDER) == 0)\n\t\treturn -ENODEV;\n\n\tr = kstrtou8(buf, 0, &zorder);\n\tif (r)\n\t\treturn r;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\tinfo.zorder = zorder;\n\n\tr = ovl->set_overlay_info(ovl, &info);\n\tif (r)\n\t\treturn r;\n\n\tif (ovl->manager) {\n\t\tr = ovl->manager->apply(ovl->manager);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn size;\n}\n\nstruct overlay_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct omap_overlay *, char *);\n\tssize_t\t(*store)(struct omap_overlay *, const char *, size_t);\n};\n\n#define OVERLAY_ATTR(_name, _mode, _show, _store) \\\n\tstruct overlay_attribute overlay_attr_##_name = \\\n\t__ATTR(_name, _mode, _show, _store)\n\nstatic OVERLAY_ATTR(name, S_IRUGO, overlay_name_show, NULL);\nstatic OVERLAY_ATTR(manager, S_IRUGO|S_IWUSR,\n\t\toverlay_manager_show, overlay_manager_store);\nstatic OVERLAY_ATTR(input_size, S_IRUGO, overlay_input_size_show, NULL);\nstatic OVERLAY_ATTR(screen_width, S_IRUGO, overlay_screen_width_show, NULL);\nstatic OVERLAY_ATTR(position, S_IRUGO|S_IWUSR,\n\t\toverlay_position_show, overlay_position_store);\nstatic OVERLAY_ATTR(output_size, S_IRUGO|S_IWUSR,\n\t\toverlay_output_size_show, overlay_output_size_store);\nstatic OVERLAY_ATTR(enabled, S_IRUGO|S_IWUSR,\n\t\toverlay_enabled_show, overlay_enabled_store);\nstatic OVERLAY_ATTR(global_alpha, S_IRUGO|S_IWUSR,\n\t\toverlay_global_alpha_show, overlay_global_alpha_store);\nstatic OVERLAY_ATTR(pre_mult_alpha, S_IRUGO|S_IWUSR,\n\t\toverlay_pre_mult_alpha_show,\n\t\toverlay_pre_mult_alpha_store);\nstatic OVERLAY_ATTR(zorder, S_IRUGO|S_IWUSR,\n\t\toverlay_zorder_show, overlay_zorder_store);\n\nstatic struct attribute *overlay_sysfs_attrs[] = {\n\t&overlay_attr_name.attr,\n\t&overlay_attr_manager.attr,\n\t&overlay_attr_input_size.attr,\n\t&overlay_attr_screen_width.attr,\n\t&overlay_attr_position.attr,\n\t&overlay_attr_output_size.attr,\n\t&overlay_attr_enabled.attr,\n\t&overlay_attr_global_alpha.attr,\n\t&overlay_attr_pre_mult_alpha.attr,\n\t&overlay_attr_zorder.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(overlay_sysfs);\n\nstatic ssize_t overlay_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\tchar *buf)\n{\n\tstruct omap_overlay *overlay;\n\tstruct overlay_attribute *overlay_attr;\n\n\toverlay = container_of(kobj, struct omap_overlay, kobj);\n\toverlay_attr = container_of(attr, struct overlay_attribute, attr);\n\n\tif (!overlay_attr->show)\n\t\treturn -ENOENT;\n\n\treturn overlay_attr->show(overlay, buf);\n}\n\nstatic ssize_t overlay_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\tconst char *buf, size_t size)\n{\n\tstruct omap_overlay *overlay;\n\tstruct overlay_attribute *overlay_attr;\n\n\toverlay = container_of(kobj, struct omap_overlay, kobj);\n\toverlay_attr = container_of(attr, struct overlay_attribute, attr);\n\n\tif (!overlay_attr->store)\n\t\treturn -ENOENT;\n\n\treturn overlay_attr->store(overlay, buf, size);\n}\n\nstatic const struct sysfs_ops overlay_sysfs_ops = {\n\t.show = overlay_attr_show,\n\t.store = overlay_attr_store,\n};\n\nstatic struct kobj_type overlay_ktype = {\n\t.sysfs_ops = &overlay_sysfs_ops,\n\t.default_groups = overlay_sysfs_groups,\n};\n\nint dss_overlay_kobj_init(struct omap_overlay *ovl,\n\t\tstruct platform_device *pdev)\n{\n\treturn kobject_init_and_add(&ovl->kobj, &overlay_ktype,\n\t\t\t&pdev->dev.kobj, \"overlay%d\", ovl->id);\n}\n\nvoid dss_overlay_kobj_uninit(struct omap_overlay *ovl)\n{\n\tkobject_del(&ovl->kobj);\n\tkobject_put(&ovl->kobj);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}