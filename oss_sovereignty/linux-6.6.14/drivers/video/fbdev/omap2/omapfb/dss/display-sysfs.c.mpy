{
  "module_name": "display-sysfs.c",
  "hash_id": "6999e77ef9fa62abd527e76a6ee5357d1c0bd4d0b26f9acd37ad5555e5e2d617",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/display-sysfs.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"DISPLAY\"\n\n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/sysfs.h>\n\n#include <video/omapfb_dss.h>\n#include \"dss.h\"\n\nstatic ssize_t display_name_show(struct omap_dss_device *dssdev, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\tdssdev->name ?\n\t\t\tdssdev->name : \"\");\n}\n\nstatic ssize_t display_enabled_show(struct omap_dss_device *dssdev, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\tomapdss_device_is_enabled(dssdev));\n}\n\nstatic ssize_t display_enabled_store(struct omap_dss_device *dssdev,\n\t\tconst char *buf, size_t size)\n{\n\tint r;\n\tbool enable;\n\n\tr = kstrtobool(buf, &enable);\n\tif (r)\n\t\treturn r;\n\n\tif (enable == omapdss_device_is_enabled(dssdev))\n\t\treturn size;\n\n\tif (omapdss_device_is_connected(dssdev) == false)\n\t\treturn -ENODEV;\n\n\tif (enable) {\n\t\tr = dssdev->driver->enable(dssdev);\n\t\tif (r)\n\t\t\treturn r;\n\t} else {\n\t\tdssdev->driver->disable(dssdev);\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t display_tear_show(struct omap_dss_device *dssdev, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\tdssdev->driver->get_te ?\n\t\t\tdssdev->driver->get_te(dssdev) : 0);\n}\n\nstatic ssize_t display_tear_store(struct omap_dss_device *dssdev,\n\tconst char *buf, size_t size)\n{\n\tint r;\n\tbool te;\n\n\tif (!dssdev->driver->enable_te || !dssdev->driver->get_te)\n\t\treturn -ENOENT;\n\n\tr = kstrtobool(buf, &te);\n\tif (r)\n\t\treturn r;\n\n\tr = dssdev->driver->enable_te(dssdev, te);\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstatic ssize_t display_timings_show(struct omap_dss_device *dssdev, char *buf)\n{\n\tstruct omap_video_timings t;\n\n\tif (!dssdev->driver->get_timings)\n\t\treturn -ENOENT;\n\n\tdssdev->driver->get_timings(dssdev, &t);\n\n\treturn sysfs_emit(buf, \"%u,%u/%u/%u/%u,%u/%u/%u/%u\\n\",\n\t\t\tt.pixelclock,\n\t\t\tt.x_res, t.hfp, t.hbp, t.hsw,\n\t\t\tt.y_res, t.vfp, t.vbp, t.vsw);\n}\n\nstatic ssize_t display_timings_store(struct omap_dss_device *dssdev,\n\tconst char *buf, size_t size)\n{\n\tstruct omap_video_timings t = dssdev->panel.timings;\n\tint r, found;\n\n\tif (!dssdev->driver->set_timings || !dssdev->driver->check_timings)\n\t\treturn -ENOENT;\n\n\tfound = 0;\n#ifdef CONFIG_FB_OMAP2_DSS_VENC\n\tif (strncmp(\"pal\", buf, 3) == 0) {\n\t\tt = omap_dss_pal_timings;\n\t\tfound = 1;\n\t} else if (strncmp(\"ntsc\", buf, 4) == 0) {\n\t\tt = omap_dss_ntsc_timings;\n\t\tfound = 1;\n\t}\n#endif\n\tif (!found && sscanf(buf, \"%u,%hu/%hu/%hu/%hu,%hu/%hu/%hu/%hu\",\n\t\t\t\t&t.pixelclock,\n\t\t\t\t&t.x_res, &t.hfp, &t.hbp, &t.hsw,\n\t\t\t\t&t.y_res, &t.vfp, &t.vbp, &t.vsw) != 9)\n\t\treturn -EINVAL;\n\n\tr = dssdev->driver->check_timings(dssdev, &t);\n\tif (r)\n\t\treturn r;\n\n\tdssdev->driver->disable(dssdev);\n\tdssdev->driver->set_timings(dssdev, &t);\n\tr = dssdev->driver->enable(dssdev);\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstatic ssize_t display_rotate_show(struct omap_dss_device *dssdev, char *buf)\n{\n\tint rotate;\n\tif (!dssdev->driver->get_rotate)\n\t\treturn -ENOENT;\n\trotate = dssdev->driver->get_rotate(dssdev);\n\treturn sysfs_emit(buf, \"%u\\n\", rotate);\n}\n\nstatic ssize_t display_rotate_store(struct omap_dss_device *dssdev,\n\tconst char *buf, size_t size)\n{\n\tint rot, r;\n\n\tif (!dssdev->driver->set_rotate || !dssdev->driver->get_rotate)\n\t\treturn -ENOENT;\n\n\tr = kstrtoint(buf, 0, &rot);\n\tif (r)\n\t\treturn r;\n\n\tr = dssdev->driver->set_rotate(dssdev, rot);\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstatic ssize_t display_mirror_show(struct omap_dss_device *dssdev, char *buf)\n{\n\tint mirror;\n\tif (!dssdev->driver->get_mirror)\n\t\treturn -ENOENT;\n\tmirror = dssdev->driver->get_mirror(dssdev);\n\treturn sysfs_emit(buf, \"%u\\n\", mirror);\n}\n\nstatic ssize_t display_mirror_store(struct omap_dss_device *dssdev,\n\tconst char *buf, size_t size)\n{\n\tint r;\n\tbool mirror;\n\n\tif (!dssdev->driver->set_mirror || !dssdev->driver->get_mirror)\n\t\treturn -ENOENT;\n\n\tr = kstrtobool(buf, &mirror);\n\tif (r)\n\t\treturn r;\n\n\tr = dssdev->driver->set_mirror(dssdev, mirror);\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstatic ssize_t display_wss_show(struct omap_dss_device *dssdev, char *buf)\n{\n\tunsigned int wss;\n\n\tif (!dssdev->driver->get_wss)\n\t\treturn -ENOENT;\n\n\twss = dssdev->driver->get_wss(dssdev);\n\n\treturn sysfs_emit(buf, \"0x%05x\\n\", wss);\n}\n\nstatic ssize_t display_wss_store(struct omap_dss_device *dssdev,\n\tconst char *buf, size_t size)\n{\n\tu32 wss;\n\tint r;\n\n\tif (!dssdev->driver->get_wss || !dssdev->driver->set_wss)\n\t\treturn -ENOENT;\n\n\tr = kstrtou32(buf, 0, &wss);\n\tif (r)\n\t\treturn r;\n\n\tif (wss > 0xfffff)\n\t\treturn -EINVAL;\n\n\tr = dssdev->driver->set_wss(dssdev, wss);\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstruct display_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct omap_dss_device *, char *);\n\tssize_t\t(*store)(struct omap_dss_device *, const char *, size_t);\n};\n\n#define DISPLAY_ATTR(_name, _mode, _show, _store) \\\n\tstruct display_attribute display_attr_##_name = \\\n\t__ATTR(_name, _mode, _show, _store)\n\nstatic DISPLAY_ATTR(name, S_IRUGO, display_name_show, NULL);\nstatic DISPLAY_ATTR(display_name, S_IRUGO, display_name_show, NULL);\nstatic DISPLAY_ATTR(enabled, S_IRUGO|S_IWUSR,\n\t\tdisplay_enabled_show, display_enabled_store);\nstatic DISPLAY_ATTR(tear_elim, S_IRUGO|S_IWUSR,\n\t\tdisplay_tear_show, display_tear_store);\nstatic DISPLAY_ATTR(timings, S_IRUGO|S_IWUSR,\n\t\tdisplay_timings_show, display_timings_store);\nstatic DISPLAY_ATTR(rotate, S_IRUGO|S_IWUSR,\n\t\tdisplay_rotate_show, display_rotate_store);\nstatic DISPLAY_ATTR(mirror, S_IRUGO|S_IWUSR,\n\t\tdisplay_mirror_show, display_mirror_store);\nstatic DISPLAY_ATTR(wss, S_IRUGO|S_IWUSR,\n\t\tdisplay_wss_show, display_wss_store);\n\nstatic struct attribute *display_sysfs_attrs[] = {\n\t&display_attr_name.attr,\n\t&display_attr_display_name.attr,\n\t&display_attr_enabled.attr,\n\t&display_attr_tear_elim.attr,\n\t&display_attr_timings.attr,\n\t&display_attr_rotate.attr,\n\t&display_attr_mirror.attr,\n\t&display_attr_wss.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(display_sysfs);\n\nstatic ssize_t display_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\tchar *buf)\n{\n\tstruct omap_dss_device *dssdev;\n\tstruct display_attribute *display_attr;\n\n\tdssdev = container_of(kobj, struct omap_dss_device, kobj);\n\tdisplay_attr = container_of(attr, struct display_attribute, attr);\n\n\tif (!display_attr->show)\n\t\treturn -ENOENT;\n\n\treturn display_attr->show(dssdev, buf);\n}\n\nstatic ssize_t display_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\tconst char *buf, size_t size)\n{\n\tstruct omap_dss_device *dssdev;\n\tstruct display_attribute *display_attr;\n\n\tdssdev = container_of(kobj, struct omap_dss_device, kobj);\n\tdisplay_attr = container_of(attr, struct display_attribute, attr);\n\n\tif (!display_attr->store)\n\t\treturn -ENOENT;\n\n\treturn display_attr->store(dssdev, buf, size);\n}\n\nstatic const struct sysfs_ops display_sysfs_ops = {\n\t.show = display_attr_show,\n\t.store = display_attr_store,\n};\n\nstatic struct kobj_type display_ktype = {\n\t.sysfs_ops = &display_sysfs_ops,\n\t.default_groups = display_sysfs_groups,\n};\n\nint display_init_sysfs(struct platform_device *pdev)\n{\n\tstruct omap_dss_device *dssdev = NULL;\n\tint r;\n\n\tfor_each_dss_dev(dssdev) {\n\t\tr = kobject_init_and_add(&dssdev->kobj, &display_ktype,\n\t\t\t&pdev->dev.kobj, \"%s\", dssdev->alias);\n\t\tif (r) {\n\t\t\tDSSERR(\"failed to create sysfs files\\n\");\n\t\t\tomap_dss_put_device(dssdev);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tdisplay_uninit_sysfs(pdev);\n\n\treturn r;\n}\n\nvoid display_uninit_sysfs(struct platform_device *pdev)\n{\n\tstruct omap_dss_device *dssdev = NULL;\n\n\tfor_each_dss_dev(dssdev) {\n\t\tif (kobject_name(&dssdev->kobj) == NULL)\n\t\t\tcontinue;\n\n\t\tkobject_del(&dssdev->kobj);\n\t\tkobject_put(&dssdev->kobj);\n\n\t\tmemset(&dssdev->kobj, 0, sizeof(dssdev->kobj));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}