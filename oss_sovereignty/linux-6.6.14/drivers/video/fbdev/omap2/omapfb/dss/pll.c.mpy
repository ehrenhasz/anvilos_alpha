{
  "module_name": "pll.c",
  "hash_id": "e179717157c631a7efe5efb9719dc6b65b33e85c6d247e142559b39fb6c2ee9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/pll.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"PLL\"\n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sched.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n\n#define PLL_CONTROL\t\t\t0x0000\n#define PLL_STATUS\t\t\t0x0004\n#define PLL_GO\t\t\t\t0x0008\n#define PLL_CONFIGURATION1\t\t0x000C\n#define PLL_CONFIGURATION2\t\t0x0010\n#define PLL_CONFIGURATION3\t\t0x0014\n#define PLL_SSC_CONFIGURATION1\t\t0x0018\n#define PLL_SSC_CONFIGURATION2\t\t0x001C\n#define PLL_CONFIGURATION4\t\t0x0020\n\nstatic struct dss_pll *dss_plls[4];\n\nint dss_pll_register(struct dss_pll *pll)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dss_plls); ++i) {\n\t\tif (!dss_plls[i]) {\n\t\t\tdss_plls[i] = pll;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EBUSY;\n}\n\nvoid dss_pll_unregister(struct dss_pll *pll)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dss_plls); ++i) {\n\t\tif (dss_plls[i] == pll) {\n\t\t\tdss_plls[i] = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstruct dss_pll *dss_pll_find(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dss_plls); ++i) {\n\t\tif (dss_plls[i] && strcmp(dss_plls[i]->name, name) == 0)\n\t\t\treturn dss_plls[i];\n\t}\n\n\treturn NULL;\n}\n\nint dss_pll_enable(struct dss_pll *pll)\n{\n\tint r;\n\n\tr = clk_prepare_enable(pll->clkin);\n\tif (r)\n\t\treturn r;\n\n\tif (pll->regulator) {\n\t\tr = regulator_enable(pll->regulator);\n\t\tif (r)\n\t\t\tgoto err_reg;\n\t}\n\n\tr = pll->ops->enable(pll);\n\tif (r)\n\t\tgoto err_enable;\n\n\treturn 0;\n\nerr_enable:\n\tif (pll->regulator)\n\t\tregulator_disable(pll->regulator);\nerr_reg:\n\tclk_disable_unprepare(pll->clkin);\n\treturn r;\n}\n\nvoid dss_pll_disable(struct dss_pll *pll)\n{\n\tpll->ops->disable(pll);\n\n\tif (pll->regulator)\n\t\tregulator_disable(pll->regulator);\n\n\tclk_disable_unprepare(pll->clkin);\n\n\tmemset(&pll->cinfo, 0, sizeof(pll->cinfo));\n}\n\nint dss_pll_set_config(struct dss_pll *pll, const struct dss_pll_clock_info *cinfo)\n{\n\tint r;\n\n\tr = pll->ops->set_config(pll, cinfo);\n\tif (r)\n\t\treturn r;\n\n\tpll->cinfo = *cinfo;\n\n\treturn 0;\n}\n\nbool dss_pll_hsdiv_calc(const struct dss_pll *pll, unsigned long clkdco,\n\t\tunsigned long out_min, unsigned long out_max,\n\t\tdss_hsdiv_calc_func func, void *data)\n{\n\tconst struct dss_pll_hw *hw = pll->hw;\n\tint m, m_start, m_stop;\n\tunsigned long out;\n\n\tout_min = out_min ? out_min : 1;\n\tout_max = out_max ? out_max : ULONG_MAX;\n\n\tm_start = max(DIV_ROUND_UP(clkdco, out_max), 1ul);\n\n\tm_stop = min((unsigned)(clkdco / out_min), hw->mX_max);\n\n\tfor (m = m_start; m <= m_stop; ++m) {\n\t\tout = clkdco / m;\n\n\t\tif (func(m, out, data))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool dss_pll_calc(const struct dss_pll *pll, unsigned long clkin,\n\t\tunsigned long pll_min, unsigned long pll_max,\n\t\tdss_pll_calc_func func, void *data)\n{\n\tconst struct dss_pll_hw *hw = pll->hw;\n\tint n, n_start, n_stop;\n\tint m, m_start, m_stop;\n\tunsigned long fint, clkdco;\n\tunsigned long pll_hw_max;\n\tunsigned long fint_hw_min, fint_hw_max;\n\n\tpll_hw_max = hw->clkdco_max;\n\n\tfint_hw_min = hw->fint_min;\n\tfint_hw_max = hw->fint_max;\n\n\tn_start = max(DIV_ROUND_UP(clkin, fint_hw_max), 1ul);\n\tn_stop = min((unsigned)(clkin / fint_hw_min), hw->n_max);\n\n\tpll_max = pll_max ? pll_max : ULONG_MAX;\n\n\tfor (n = n_start; n <= n_stop; ++n) {\n\t\tfint = clkin / n;\n\n\t\tm_start = max(DIV_ROUND_UP(DIV_ROUND_UP(pll_min, fint), 2),\n\t\t\t\t1ul);\n\t\tm_stop = min3((unsigned)(pll_max / fint / 2),\n\t\t\t\t(unsigned)(pll_hw_max / fint / 2),\n\t\t\t\thw->m_max);\n\n\t\tfor (m = m_start; m <= m_stop; ++m) {\n\t\t\tclkdco = 2 * m * fint;\n\n\t\t\tif (func(n, m, fint, clkdco, data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int wait_for_bit_change(void __iomem *reg, int bitnum, int value)\n{\n\tunsigned long timeout;\n\tktime_t wait;\n\tint t;\n\n\t \n\tt = 100;\n\twhile (t-- > 0) {\n\t\tif (FLD_GET(readl_relaxed(reg), bitnum, bitnum) == value)\n\t\t\treturn value;\n\t}\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile (time_before(jiffies, timeout)) {\n\t\tif (FLD_GET(readl_relaxed(reg), bitnum, bitnum) == value)\n\t\t\treturn value;\n\n\t\twait = ns_to_ktime(1000 * 1000);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_hrtimeout(&wait, HRTIMER_MODE_REL);\n\t}\n\n\treturn !value;\n}\n\nint dss_pll_wait_reset_done(struct dss_pll *pll)\n{\n\tvoid __iomem *base = pll->base;\n\n\tif (wait_for_bit_change(base + PLL_STATUS, 0, 1) != 1)\n\t\treturn -ETIMEDOUT;\n\telse\n\t\treturn 0;\n}\n\nstatic int dss_wait_hsdiv_ack(struct dss_pll *pll, u32 hsdiv_ack_mask)\n{\n\tint t = 100;\n\n\twhile (t-- > 0) {\n\t\tu32 v = readl_relaxed(pll->base + PLL_STATUS);\n\t\tv &= hsdiv_ack_mask;\n\t\tif (v == hsdiv_ack_mask)\n\t\t\treturn 0;\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nint dss_pll_write_config_type_a(struct dss_pll *pll,\n\t\tconst struct dss_pll_clock_info *cinfo)\n{\n\tconst struct dss_pll_hw *hw = pll->hw;\n\tvoid __iomem *base = pll->base;\n\tint r = 0;\n\tu32 l;\n\n\tl = 0;\n\tif (hw->has_stopmode)\n\t\tl = FLD_MOD(l, 1, 0, 0);\t\t \n\tl = FLD_MOD(l, cinfo->n - 1, hw->n_msb, hw->n_lsb);\t \n\tl = FLD_MOD(l, cinfo->m, hw->m_msb, hw->m_lsb);\t\t \n\t \n\tl = FLD_MOD(l, cinfo->mX[0] ? cinfo->mX[0] - 1 : 0,\n\t\t\thw->mX_msb[0], hw->mX_lsb[0]);\n\t \n\tl = FLD_MOD(l, cinfo->mX[1] ? cinfo->mX[1] - 1 : 0,\n\t\t\thw->mX_msb[1], hw->mX_lsb[1]);\n\twritel_relaxed(l, base + PLL_CONFIGURATION1);\n\n\tl = 0;\n\t \n\tl = FLD_MOD(l, cinfo->mX[2] ? cinfo->mX[2] - 1 : 0,\n\t\t\thw->mX_msb[2], hw->mX_lsb[2]);\n\t \n\tl = FLD_MOD(l, cinfo->mX[3] ? cinfo->mX[3] - 1 : 0,\n\t\t\thw->mX_msb[3], hw->mX_lsb[3]);\n\twritel_relaxed(l, base + PLL_CONFIGURATION3);\n\n\tl = readl_relaxed(base + PLL_CONFIGURATION2);\n\tif (hw->has_freqsel) {\n\t\tu32 f = cinfo->fint < 1000000 ? 0x3 :\n\t\t\tcinfo->fint < 1250000 ? 0x4 :\n\t\t\tcinfo->fint < 1500000 ? 0x5 :\n\t\t\tcinfo->fint < 1750000 ? 0x6 :\n\t\t\t0x7;\n\n\t\tl = FLD_MOD(l, f, 4, 1);\t \n\t} else if (hw->has_selfreqdco) {\n\t\tu32 f = cinfo->clkdco < hw->clkdco_low ? 0x2 : 0x4;\n\n\t\tl = FLD_MOD(l, f, 3, 1);\t \n\t}\n\tl = FLD_MOD(l, 1, 13, 13);\t\t \n\tl = FLD_MOD(l, 0, 14, 14);\t\t \n\tl = FLD_MOD(l, 0, 16, 16);\t\t \n\tl = FLD_MOD(l, 0, 18, 18);\t\t \n\tl = FLD_MOD(l, 1, 20, 20);\t\t \n\tif (hw->has_refsel)\n\t\tl = FLD_MOD(l, 3, 22, 21);\t \n\tl = FLD_MOD(l, 0, 23, 23);\t\t \n\tl = FLD_MOD(l, 0, 25, 25);\t\t \n\twritel_relaxed(l, base + PLL_CONFIGURATION2);\n\n\twritel_relaxed(1, base + PLL_GO);\t \n\n\tif (wait_for_bit_change(base + PLL_GO, 0, 0) != 0) {\n\t\tDSSERR(\"DSS DPLL GO bit not going down.\\n\");\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (wait_for_bit_change(base + PLL_STATUS, 1, 1) != 1) {\n\t\tDSSERR(\"cannot lock DSS DPLL\\n\");\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\n\tl = readl_relaxed(base + PLL_CONFIGURATION2);\n\tl = FLD_MOD(l, 1, 14, 14);\t\t\t \n\tl = FLD_MOD(l, cinfo->mX[0] ? 1 : 0, 16, 16);\t \n\tl = FLD_MOD(l, cinfo->mX[1] ? 1 : 0, 18, 18);\t \n\tl = FLD_MOD(l, 0, 20, 20);\t\t\t \n\tl = FLD_MOD(l, cinfo->mX[2] ? 1 : 0, 23, 23);\t \n\tl = FLD_MOD(l, cinfo->mX[3] ? 1 : 0, 25, 25);\t \n\twritel_relaxed(l, base + PLL_CONFIGURATION2);\n\n\tr = dss_wait_hsdiv_ack(pll,\n\t\t(cinfo->mX[0] ? BIT(7) : 0) |\n\t\t(cinfo->mX[1] ? BIT(8) : 0) |\n\t\t(cinfo->mX[2] ? BIT(10) : 0) |\n\t\t(cinfo->mX[3] ? BIT(11) : 0));\n\tif (r) {\n\t\tDSSERR(\"failed to enable HSDIV clocks\\n\");\n\t\tgoto err;\n\t}\n\nerr:\n\treturn r;\n}\n\nint dss_pll_write_config_type_b(struct dss_pll *pll,\n\t\tconst struct dss_pll_clock_info *cinfo)\n{\n\tconst struct dss_pll_hw *hw = pll->hw;\n\tvoid __iomem *base = pll->base;\n\tu32 l;\n\n\tl = 0;\n\tl = FLD_MOD(l, cinfo->m, 20, 9);\t \n\tl = FLD_MOD(l, cinfo->n - 1, 8, 1);\t \n\twritel_relaxed(l, base + PLL_CONFIGURATION1);\n\n\tl = readl_relaxed(base + PLL_CONFIGURATION2);\n\tl = FLD_MOD(l, 0x0, 12, 12);\t \n\tl = FLD_MOD(l, 0x1, 13, 13);\t \n\tl = FLD_MOD(l, 0x0, 14, 14);\t \n\tif (hw->has_refsel)\n\t\tl = FLD_MOD(l, 0x3, 22, 21);\t \n\n\t \n\tif (cinfo->clkdco > hw->clkdco_low)\n\t\tl = FLD_MOD(l, 0x4, 3, 1);\n\telse\n\t\tl = FLD_MOD(l, 0x2, 3, 1);\n\twritel_relaxed(l, base + PLL_CONFIGURATION2);\n\n\tl = readl_relaxed(base + PLL_CONFIGURATION3);\n\tl = FLD_MOD(l, cinfo->sd, 17, 10);\t \n\twritel_relaxed(l, base + PLL_CONFIGURATION3);\n\n\tl = readl_relaxed(base + PLL_CONFIGURATION4);\n\tl = FLD_MOD(l, cinfo->mX[0], 24, 18);\t \n\tl = FLD_MOD(l, cinfo->mf, 17, 0);\t \n\twritel_relaxed(l, base + PLL_CONFIGURATION4);\n\n\twritel_relaxed(1, base + PLL_GO);\t \n\n\tif (wait_for_bit_change(base + PLL_GO, 0, 0) != 0) {\n\t\tDSSERR(\"DSS DPLL GO bit not going down.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (wait_for_bit_change(base + PLL_STATUS, 1, 1) != 1) {\n\t\tDSSERR(\"cannot lock DSS DPLL\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}