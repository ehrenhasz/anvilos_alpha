{
  "module_name": "omapdss-boot-init.c",
  "hash_id": "b5352b6e4b3d2a5af3885ec4d503e16b4996b5ed93de81016c5d47b0a190bed0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/omapdss-boot-init.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n\nstatic struct list_head dss_conv_list __initdata;\n\nstatic const char prefix[] __initconst = \"omapdss,\";\n\nstruct dss_conv_node {\n\tstruct list_head list;\n\tstruct device_node *node;\n\tbool root;\n};\n\nstatic int __init omapdss_count_strings(const struct property *prop)\n{\n\tconst char *p = prop->value;\n\tint l = 0, total = 0;\n\tint i;\n\n\tfor (i = 0; total < prop->length; total += l, p += l, i++)\n\t\tl = strlen(p) + 1;\n\n\treturn i;\n}\n\nstatic void __init omapdss_update_prop(struct device_node *node, char *compat,\n\tint len)\n{\n\tstruct property *prop;\n\n\tprop = kzalloc(sizeof(*prop), GFP_KERNEL);\n\tif (!prop)\n\t\treturn;\n\n\tprop->name = \"compatible\";\n\tprop->value = compat;\n\tprop->length = len;\n\n\tof_update_property(node, prop);\n}\n\nstatic void __init omapdss_prefix_strcpy(char *dst, int dst_len,\n\tconst char *src, int src_len)\n{\n\tsize_t total = 0;\n\n\twhile (total < src_len) {\n\t\tsize_t l = strlen(src) + 1;\n\n\t\tstrcpy(dst, prefix);\n\t\tdst += strlen(prefix);\n\n\t\tstrcpy(dst, src);\n\t\tdst += l;\n\n\t\tsrc += l;\n\t\ttotal += l;\n\t}\n}\n\n \nstatic void __init omapdss_omapify_node(struct device_node *node)\n{\n\tstruct property *prop;\n\tchar *new_compat;\n\tint num_strs;\n\tint new_len;\n\n\tprop = of_find_property(node, \"compatible\", NULL);\n\n\tif (!prop || !prop->value)\n\t\treturn;\n\n\tif (strnlen(prop->value, prop->length) >= prop->length)\n\t\treturn;\n\n\t \n\tif (strncmp(prefix, prop->value, strlen(prefix)) == 0)\n\t\treturn;\n\n\tnum_strs = omapdss_count_strings(prop);\n\n\tnew_len = prop->length + strlen(prefix) * num_strs;\n\tnew_compat = kmalloc(new_len, GFP_KERNEL);\n\tif (!new_compat)\n\t\treturn;\n\n\tomapdss_prefix_strcpy(new_compat, new_len, prop->value, prop->length);\n\n\tomapdss_update_prop(node, new_compat, new_len);\n}\n\nstatic void __init omapdss_add_to_list(struct device_node *node, bool root)\n{\n\tstruct dss_conv_node *n = kmalloc(sizeof(struct dss_conv_node),\n\t\tGFP_KERNEL);\n\tif (n) {\n\t\tn->node = node;\n\t\tn->root = root;\n\t\tlist_add(&n->list, &dss_conv_list);\n\t}\n}\n\nstatic bool __init omapdss_list_contains(const struct device_node *node)\n{\n\tstruct dss_conv_node *n;\n\n\tlist_for_each_entry(n, &dss_conv_list, list) {\n\t\tif (n->node == node)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void __init omapdss_walk_device(struct device_node *node, bool root)\n{\n\tstruct device_node *n;\n\n\tomapdss_add_to_list(node, root);\n\n\t \n\tn = of_get_child_by_name(node, \"ports\");\n\tif (!n)\n\t\tn = of_get_child_by_name(node, \"port\");\n\tif (!n)\n\t\treturn;\n\n\tof_node_put(n);\n\n\tn = NULL;\n\twhile ((n = of_graph_get_next_endpoint(node, n)) != NULL) {\n\t\tstruct device_node *pn;\n\n\t\tpn = of_graph_get_remote_port_parent(n);\n\n\t\tif (!pn)\n\t\t\tcontinue;\n\n\t\tif (!of_device_is_available(pn) || omapdss_list_contains(pn)) {\n\t\t\tof_node_put(pn);\n\t\t\tcontinue;\n\t\t}\n\n\t\tomapdss_walk_device(pn, false);\n\t}\n}\n\nstatic const struct of_device_id omapdss_of_match[] __initconst = {\n\t{ .compatible = \"ti,omap2-dss\", },\n\t{ .compatible = \"ti,omap3-dss\", },\n\t{ .compatible = \"ti,omap4-dss\", },\n\t{ .compatible = \"ti,omap5-dss\", },\n\t{ .compatible = \"ti,dra7-dss\", },\n\t{},\n};\n\nstatic int __init omapdss_boot_init(void)\n{\n\tstruct device_node *dss, *child;\n\n\tINIT_LIST_HEAD(&dss_conv_list);\n\n\tdss = of_find_matching_node(NULL, omapdss_of_match);\n\n\tif (dss == NULL || !of_device_is_available(dss)) {\n\t\tof_node_put(dss);\n\t\treturn 0;\n\t}\n\n\tomapdss_walk_device(dss, true);\n\n\tfor_each_available_child_of_node(dss, child) {\n\t\tif (!of_property_present(child, \"compatible\"))\n\t\t\tcontinue;\n\n\t\tomapdss_walk_device(child, true);\n\t}\n\n\twhile (!list_empty(&dss_conv_list)) {\n\t\tstruct dss_conv_node *n;\n\n\t\tn = list_first_entry(&dss_conv_list, struct dss_conv_node,\n\t\t\tlist);\n\n\t\tif (!n->root)\n\t\t\tomapdss_omapify_node(n->node);\n\n\t\tlist_del(&n->list);\n\t\tof_node_put(n->node);\n\t\tkfree(n);\n\t}\n\n\treturn 0;\n}\n\nsubsys_initcall(omapdss_boot_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}