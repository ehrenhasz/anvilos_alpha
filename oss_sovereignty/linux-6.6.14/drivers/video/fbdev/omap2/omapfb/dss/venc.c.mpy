{
  "module_name": "venc.c",
  "hash_id": "e57b7c829dfefbdca7928dc5db799cbb9f01f954d06991805b9fadb9382712ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/venc.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"VENC\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/mutex.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/component.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"dss_features.h\"\n\n \n#define VENC_REV_ID\t\t\t\t0x00\n#define VENC_STATUS\t\t\t\t0x04\n#define VENC_F_CONTROL\t\t\t\t0x08\n#define VENC_VIDOUT_CTRL\t\t\t0x10\n#define VENC_SYNC_CTRL\t\t\t\t0x14\n#define VENC_LLEN\t\t\t\t0x1C\n#define VENC_FLENS\t\t\t\t0x20\n#define VENC_HFLTR_CTRL\t\t\t\t0x24\n#define VENC_CC_CARR_WSS_CARR\t\t\t0x28\n#define VENC_C_PHASE\t\t\t\t0x2C\n#define VENC_GAIN_U\t\t\t\t0x30\n#define VENC_GAIN_V\t\t\t\t0x34\n#define VENC_GAIN_Y\t\t\t\t0x38\n#define VENC_BLACK_LEVEL\t\t\t0x3C\n#define VENC_BLANK_LEVEL\t\t\t0x40\n#define VENC_X_COLOR\t\t\t\t0x44\n#define VENC_M_CONTROL\t\t\t\t0x48\n#define VENC_BSTAMP_WSS_DATA\t\t\t0x4C\n#define VENC_S_CARR\t\t\t\t0x50\n#define VENC_LINE21\t\t\t\t0x54\n#define VENC_LN_SEL\t\t\t\t0x58\n#define VENC_L21__WC_CTL\t\t\t0x5C\n#define VENC_HTRIGGER_VTRIGGER\t\t\t0x60\n#define VENC_SAVID__EAVID\t\t\t0x64\n#define VENC_FLEN__FAL\t\t\t\t0x68\n#define VENC_LAL__PHASE_RESET\t\t\t0x6C\n#define VENC_HS_INT_START_STOP_X\t\t0x70\n#define VENC_HS_EXT_START_STOP_X\t\t0x74\n#define VENC_VS_INT_START_X\t\t\t0x78\n#define VENC_VS_INT_STOP_X__VS_INT_START_Y\t0x7C\n#define VENC_VS_INT_STOP_Y__VS_EXT_START_X\t0x80\n#define VENC_VS_EXT_STOP_X__VS_EXT_START_Y\t0x84\n#define VENC_VS_EXT_STOP_Y\t\t\t0x88\n#define VENC_AVID_START_STOP_X\t\t\t0x90\n#define VENC_AVID_START_STOP_Y\t\t\t0x94\n#define VENC_FID_INT_START_X__FID_INT_START_Y\t0xA0\n#define VENC_FID_INT_OFFSET_Y__FID_EXT_START_X\t0xA4\n#define VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y\t0xA8\n#define VENC_TVDETGP_INT_START_STOP_X\t\t0xB0\n#define VENC_TVDETGP_INT_START_STOP_Y\t\t0xB4\n#define VENC_GEN_CTRL\t\t\t\t0xB8\n#define VENC_OUTPUT_CONTROL\t\t\t0xC4\n#define VENC_OUTPUT_TEST\t\t\t0xC8\n#define VENC_DAC_B__DAC_C\t\t\t0xC8\n\nstruct venc_config {\n\tu32 f_control;\n\tu32 vidout_ctrl;\n\tu32 sync_ctrl;\n\tu32 llen;\n\tu32 flens;\n\tu32 hfltr_ctrl;\n\tu32 cc_carr_wss_carr;\n\tu32 c_phase;\n\tu32 gain_u;\n\tu32 gain_v;\n\tu32 gain_y;\n\tu32 black_level;\n\tu32 blank_level;\n\tu32 x_color;\n\tu32 m_control;\n\tu32 bstamp_wss_data;\n\tu32 s_carr;\n\tu32 line21;\n\tu32 ln_sel;\n\tu32 l21__wc_ctl;\n\tu32 htrigger_vtrigger;\n\tu32 savid__eavid;\n\tu32 flen__fal;\n\tu32 lal__phase_reset;\n\tu32 hs_int_start_stop_x;\n\tu32 hs_ext_start_stop_x;\n\tu32 vs_int_start_x;\n\tu32 vs_int_stop_x__vs_int_start_y;\n\tu32 vs_int_stop_y__vs_ext_start_x;\n\tu32 vs_ext_stop_x__vs_ext_start_y;\n\tu32 vs_ext_stop_y;\n\tu32 avid_start_stop_x;\n\tu32 avid_start_stop_y;\n\tu32 fid_int_start_x__fid_int_start_y;\n\tu32 fid_int_offset_y__fid_ext_start_x;\n\tu32 fid_ext_start_y__fid_ext_offset_y;\n\tu32 tvdetgp_int_start_stop_x;\n\tu32 tvdetgp_int_start_stop_y;\n\tu32 gen_ctrl;\n};\n\n \nstatic const struct venc_config venc_config_pal_trm = {\n\t.f_control\t\t\t\t= 0,\n\t.vidout_ctrl\t\t\t\t= 1,\n\t.sync_ctrl\t\t\t\t= 0x40,\n\t.llen\t\t\t\t\t= 0x35F,  \n\t.flens\t\t\t\t\t= 0x270,  \n\t.hfltr_ctrl\t\t\t\t= 0,\n\t.cc_carr_wss_carr\t\t\t= 0x2F7225ED,\n\t.c_phase\t\t\t\t= 0,\n\t.gain_u\t\t\t\t\t= 0x111,\n\t.gain_v\t\t\t\t\t= 0x181,\n\t.gain_y\t\t\t\t\t= 0x140,\n\t.black_level\t\t\t\t= 0x3B,\n\t.blank_level\t\t\t\t= 0x3B,\n\t.x_color\t\t\t\t= 0x7,\n\t.m_control\t\t\t\t= 0x2,\n\t.bstamp_wss_data\t\t\t= 0x3F,\n\t.s_carr\t\t\t\t\t= 0x2A098ACB,\n\t.line21\t\t\t\t\t= 0,\n\t.ln_sel\t\t\t\t\t= 0x01290015,\n\t.l21__wc_ctl\t\t\t\t= 0x0000F603,\n\t.htrigger_vtrigger\t\t\t= 0,\n\n\t.savid__eavid\t\t\t\t= 0x06A70108,\n\t.flen__fal\t\t\t\t= 0x00180270,\n\t.lal__phase_reset\t\t\t= 0x00040135,\n\t.hs_int_start_stop_x\t\t\t= 0x00880358,\n\t.hs_ext_start_stop_x\t\t\t= 0x000F035F,\n\t.vs_int_start_x\t\t\t\t= 0x01A70000,\n\t.vs_int_stop_x__vs_int_start_y\t\t= 0x000001A7,\n\t.vs_int_stop_y__vs_ext_start_x\t\t= 0x01AF0000,\n\t.vs_ext_stop_x__vs_ext_start_y\t\t= 0x000101AF,\n\t.vs_ext_stop_y\t\t\t\t= 0x00000025,\n\t.avid_start_stop_x\t\t\t= 0x03530083,\n\t.avid_start_stop_y\t\t\t= 0x026C002E,\n\t.fid_int_start_x__fid_int_start_y\t= 0x0001008A,\n\t.fid_int_offset_y__fid_ext_start_x\t= 0x002E0138,\n\t.fid_ext_start_y__fid_ext_offset_y\t= 0x01380001,\n\n\t.tvdetgp_int_start_stop_x\t\t= 0x00140001,\n\t.tvdetgp_int_start_stop_y\t\t= 0x00010001,\n\t.gen_ctrl\t\t\t\t= 0x00FF0000,\n};\n\n \nstatic const struct venc_config venc_config_ntsc_trm = {\n\t.f_control\t\t\t\t= 0,\n\t.vidout_ctrl\t\t\t\t= 1,\n\t.sync_ctrl\t\t\t\t= 0x8040,\n\t.llen\t\t\t\t\t= 0x359,\n\t.flens\t\t\t\t\t= 0x20C,\n\t.hfltr_ctrl\t\t\t\t= 0,\n\t.cc_carr_wss_carr\t\t\t= 0x043F2631,\n\t.c_phase\t\t\t\t= 0,\n\t.gain_u\t\t\t\t\t= 0x102,\n\t.gain_v\t\t\t\t\t= 0x16C,\n\t.gain_y\t\t\t\t\t= 0x12F,\n\t.black_level\t\t\t\t= 0x43,\n\t.blank_level\t\t\t\t= 0x38,\n\t.x_color\t\t\t\t= 0x7,\n\t.m_control\t\t\t\t= 0x1,\n\t.bstamp_wss_data\t\t\t= 0x38,\n\t.s_carr\t\t\t\t\t= 0x21F07C1F,\n\t.line21\t\t\t\t\t= 0,\n\t.ln_sel\t\t\t\t\t= 0x01310011,\n\t.l21__wc_ctl\t\t\t\t= 0x0000F003,\n\t.htrigger_vtrigger\t\t\t= 0,\n\n\t.savid__eavid\t\t\t\t= 0x069300F4,\n\t.flen__fal\t\t\t\t= 0x0016020C,\n\t.lal__phase_reset\t\t\t= 0x00060107,\n\t.hs_int_start_stop_x\t\t\t= 0x008E0350,\n\t.hs_ext_start_stop_x\t\t\t= 0x000F0359,\n\t.vs_int_start_x\t\t\t\t= 0x01A00000,\n\t.vs_int_stop_x__vs_int_start_y\t\t= 0x020701A0,\n\t.vs_int_stop_y__vs_ext_start_x\t\t= 0x01AC0024,\n\t.vs_ext_stop_x__vs_ext_start_y\t\t= 0x020D01AC,\n\t.vs_ext_stop_y\t\t\t\t= 0x00000006,\n\t.avid_start_stop_x\t\t\t= 0x03480078,\n\t.avid_start_stop_y\t\t\t= 0x02060024,\n\t.fid_int_start_x__fid_int_start_y\t= 0x0001008A,\n\t.fid_int_offset_y__fid_ext_start_x\t= 0x01AC0106,\n\t.fid_ext_start_y__fid_ext_offset_y\t= 0x01060006,\n\n\t.tvdetgp_int_start_stop_x\t\t= 0x00140001,\n\t.tvdetgp_int_start_stop_y\t\t= 0x00010001,\n\t.gen_ctrl\t\t\t\t= 0x00F90000,\n};\n\nconst struct omap_video_timings omap_dss_pal_timings = {\n\t.x_res\t\t= 720,\n\t.y_res\t\t= 574,\n\t.pixelclock\t= 13500000,\n\t.hsw\t\t= 64,\n\t.hfp\t\t= 12,\n\t.hbp\t\t= 68,\n\t.vsw\t\t= 5,\n\t.vfp\t\t= 5,\n\t.vbp\t\t= 41,\n\n\t.interlace\t= true,\n};\nEXPORT_SYMBOL(omap_dss_pal_timings);\n\nconst struct omap_video_timings omap_dss_ntsc_timings = {\n\t.x_res\t\t= 720,\n\t.y_res\t\t= 482,\n\t.pixelclock\t= 13500000,\n\t.hsw\t\t= 64,\n\t.hfp\t\t= 16,\n\t.hbp\t\t= 58,\n\t.vsw\t\t= 6,\n\t.vfp\t\t= 6,\n\t.vbp\t\t= 31,\n\n\t.interlace\t= true,\n};\nEXPORT_SYMBOL(omap_dss_ntsc_timings);\n\nstatic struct {\n\tstruct platform_device *pdev;\n\tvoid __iomem *base;\n\tstruct mutex venc_lock;\n\tu32 wss_data;\n\tstruct regulator *vdda_dac_reg;\n\n\tstruct clk\t*tv_dac_clk;\n\n\tstruct omap_video_timings timings;\n\tenum omap_dss_venc_type type;\n\tbool invert_polarity;\n\n\tstruct omap_dss_device output;\n} venc;\n\nstatic inline void venc_write_reg(int idx, u32 val)\n{\n\t__raw_writel(val, venc.base + idx);\n}\n\nstatic inline u32 venc_read_reg(int idx)\n{\n\tu32 l = __raw_readl(venc.base + idx);\n\treturn l;\n}\n\nstatic void venc_write_config(const struct venc_config *config)\n{\n\tDSSDBG(\"write venc conf\\n\");\n\n\tvenc_write_reg(VENC_LLEN, config->llen);\n\tvenc_write_reg(VENC_FLENS, config->flens);\n\tvenc_write_reg(VENC_CC_CARR_WSS_CARR, config->cc_carr_wss_carr);\n\tvenc_write_reg(VENC_C_PHASE, config->c_phase);\n\tvenc_write_reg(VENC_GAIN_U, config->gain_u);\n\tvenc_write_reg(VENC_GAIN_V, config->gain_v);\n\tvenc_write_reg(VENC_GAIN_Y, config->gain_y);\n\tvenc_write_reg(VENC_BLACK_LEVEL, config->black_level);\n\tvenc_write_reg(VENC_BLANK_LEVEL, config->blank_level);\n\tvenc_write_reg(VENC_M_CONTROL, config->m_control);\n\tvenc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |\n\t\t\tvenc.wss_data);\n\tvenc_write_reg(VENC_S_CARR, config->s_carr);\n\tvenc_write_reg(VENC_L21__WC_CTL, config->l21__wc_ctl);\n\tvenc_write_reg(VENC_SAVID__EAVID, config->savid__eavid);\n\tvenc_write_reg(VENC_FLEN__FAL, config->flen__fal);\n\tvenc_write_reg(VENC_LAL__PHASE_RESET, config->lal__phase_reset);\n\tvenc_write_reg(VENC_HS_INT_START_STOP_X, config->hs_int_start_stop_x);\n\tvenc_write_reg(VENC_HS_EXT_START_STOP_X, config->hs_ext_start_stop_x);\n\tvenc_write_reg(VENC_VS_INT_START_X, config->vs_int_start_x);\n\tvenc_write_reg(VENC_VS_INT_STOP_X__VS_INT_START_Y,\n\t\t       config->vs_int_stop_x__vs_int_start_y);\n\tvenc_write_reg(VENC_VS_INT_STOP_Y__VS_EXT_START_X,\n\t\t       config->vs_int_stop_y__vs_ext_start_x);\n\tvenc_write_reg(VENC_VS_EXT_STOP_X__VS_EXT_START_Y,\n\t\t       config->vs_ext_stop_x__vs_ext_start_y);\n\tvenc_write_reg(VENC_VS_EXT_STOP_Y, config->vs_ext_stop_y);\n\tvenc_write_reg(VENC_AVID_START_STOP_X, config->avid_start_stop_x);\n\tvenc_write_reg(VENC_AVID_START_STOP_Y, config->avid_start_stop_y);\n\tvenc_write_reg(VENC_FID_INT_START_X__FID_INT_START_Y,\n\t\t       config->fid_int_start_x__fid_int_start_y);\n\tvenc_write_reg(VENC_FID_INT_OFFSET_Y__FID_EXT_START_X,\n\t\t       config->fid_int_offset_y__fid_ext_start_x);\n\tvenc_write_reg(VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y,\n\t\t       config->fid_ext_start_y__fid_ext_offset_y);\n\n\tvenc_write_reg(VENC_DAC_B__DAC_C,  venc_read_reg(VENC_DAC_B__DAC_C));\n\tvenc_write_reg(VENC_VIDOUT_CTRL, config->vidout_ctrl);\n\tvenc_write_reg(VENC_HFLTR_CTRL, config->hfltr_ctrl);\n\tvenc_write_reg(VENC_X_COLOR, config->x_color);\n\tvenc_write_reg(VENC_LINE21, config->line21);\n\tvenc_write_reg(VENC_LN_SEL, config->ln_sel);\n\tvenc_write_reg(VENC_HTRIGGER_VTRIGGER, config->htrigger_vtrigger);\n\tvenc_write_reg(VENC_TVDETGP_INT_START_STOP_X,\n\t\t       config->tvdetgp_int_start_stop_x);\n\tvenc_write_reg(VENC_TVDETGP_INT_START_STOP_Y,\n\t\t       config->tvdetgp_int_start_stop_y);\n\tvenc_write_reg(VENC_GEN_CTRL, config->gen_ctrl);\n\tvenc_write_reg(VENC_F_CONTROL, config->f_control);\n\tvenc_write_reg(VENC_SYNC_CTRL, config->sync_ctrl);\n}\n\nstatic void venc_reset(void)\n{\n\tint t = 1000;\n\n\tvenc_write_reg(VENC_F_CONTROL, 1<<8);\n\twhile (venc_read_reg(VENC_F_CONTROL) & (1<<8)) {\n\t\tif (--t == 0) {\n\t\t\tDSSERR(\"Failed to reset venc\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n#ifdef CONFIG_FB_OMAP2_DSS_SLEEP_AFTER_VENC_RESET\n\t \n\t \n\tmsleep(20);\n#endif\n}\n\nstatic int venc_runtime_get(void)\n{\n\tint r;\n\n\tDSSDBG(\"venc_runtime_get\\n\");\n\n\tr = pm_runtime_resume_and_get(&venc.pdev->dev);\n\tif (WARN_ON(r < 0))\n\t\treturn r;\n\treturn 0;\n}\n\nstatic void venc_runtime_put(void)\n{\n\tint r;\n\n\tDSSDBG(\"venc_runtime_put\\n\");\n\n\tr = pm_runtime_put_sync(&venc.pdev->dev);\n\tWARN_ON(r < 0 && r != -ENOSYS);\n}\n\nstatic const struct venc_config *venc_timings_to_config(\n\t\tstruct omap_video_timings *timings)\n{\n\tif (memcmp(&omap_dss_pal_timings, timings, sizeof(*timings)) == 0)\n\t\treturn &venc_config_pal_trm;\n\n\tif (memcmp(&omap_dss_ntsc_timings, timings, sizeof(*timings)) == 0)\n\t\treturn &venc_config_ntsc_trm;\n\n\tBUG();\n\treturn NULL;\n}\n\nstatic int venc_power_on(struct omap_dss_device *dssdev)\n{\n\tstruct omap_overlay_manager *mgr = venc.output.manager;\n\tu32 l;\n\tint r;\n\n\tr = venc_runtime_get();\n\tif (r)\n\t\tgoto err0;\n\n\tvenc_reset();\n\tvenc_write_config(venc_timings_to_config(&venc.timings));\n\n\tdss_set_venc_output(venc.type);\n\tdss_set_dac_pwrdn_bgz(1);\n\n\tl = 0;\n\n\tif (venc.type == OMAP_DSS_VENC_TYPE_COMPOSITE)\n\t\tl |= 1 << 1;\n\telse  \n\t\tl |= (1 << 0) | (1 << 2);\n\n\tif (venc.invert_polarity == false)\n\t\tl |= 1 << 3;\n\n\tvenc_write_reg(VENC_OUTPUT_CONTROL, l);\n\n\tdss_mgr_set_timings(mgr, &venc.timings);\n\n\tr = regulator_enable(venc.vdda_dac_reg);\n\tif (r)\n\t\tgoto err1;\n\n\tr = dss_mgr_enable(mgr);\n\tif (r)\n\t\tgoto err2;\n\n\treturn 0;\n\nerr2:\n\tregulator_disable(venc.vdda_dac_reg);\nerr1:\n\tvenc_write_reg(VENC_OUTPUT_CONTROL, 0);\n\tdss_set_dac_pwrdn_bgz(0);\n\n\tvenc_runtime_put();\nerr0:\n\treturn r;\n}\n\nstatic void venc_power_off(struct omap_dss_device *dssdev)\n{\n\tstruct omap_overlay_manager *mgr = venc.output.manager;\n\n\tvenc_write_reg(VENC_OUTPUT_CONTROL, 0);\n\tdss_set_dac_pwrdn_bgz(0);\n\n\tdss_mgr_disable(mgr);\n\n\tregulator_disable(venc.vdda_dac_reg);\n\n\tvenc_runtime_put();\n}\n\nstatic int venc_display_enable(struct omap_dss_device *dssdev)\n{\n\tstruct omap_dss_device *out = &venc.output;\n\tint r;\n\n\tDSSDBG(\"venc_display_enable\\n\");\n\n\tmutex_lock(&venc.venc_lock);\n\n\tif (out->manager == NULL) {\n\t\tDSSERR(\"Failed to enable display: no output/manager\\n\");\n\t\tr = -ENODEV;\n\t\tgoto err0;\n\t}\n\n\tr = venc_power_on(dssdev);\n\tif (r)\n\t\tgoto err0;\n\n\tvenc.wss_data = 0;\n\n\tmutex_unlock(&venc.venc_lock);\n\n\treturn 0;\nerr0:\n\tmutex_unlock(&venc.venc_lock);\n\treturn r;\n}\n\nstatic void venc_display_disable(struct omap_dss_device *dssdev)\n{\n\tDSSDBG(\"venc_display_disable\\n\");\n\n\tmutex_lock(&venc.venc_lock);\n\n\tvenc_power_off(dssdev);\n\n\tmutex_unlock(&venc.venc_lock);\n}\n\nstatic void venc_set_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tDSSDBG(\"venc_set_timings\\n\");\n\n\tmutex_lock(&venc.venc_lock);\n\n\t \n\tif (memcmp(&venc.timings, timings, sizeof(*timings)))\n\t\tvenc.wss_data = 0;\n\n\tvenc.timings = *timings;\n\n\tdispc_set_tv_pclk(13500000);\n\n\tmutex_unlock(&venc.venc_lock);\n}\n\nstatic int venc_check_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tDSSDBG(\"venc_check_timings\\n\");\n\n\tif (memcmp(&omap_dss_pal_timings, timings, sizeof(*timings)) == 0)\n\t\treturn 0;\n\n\tif (memcmp(&omap_dss_ntsc_timings, timings, sizeof(*timings)) == 0)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic void venc_get_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tmutex_lock(&venc.venc_lock);\n\n\t*timings = venc.timings;\n\n\tmutex_unlock(&venc.venc_lock);\n}\n\nstatic u32 venc_get_wss(struct omap_dss_device *dssdev)\n{\n\t \n\treturn (venc.wss_data >> 8) ^ 0xfffff;\n}\n\nstatic int venc_set_wss(struct omap_dss_device *dssdev, u32 wss)\n{\n\tconst struct venc_config *config;\n\tint r;\n\n\tDSSDBG(\"venc_set_wss\\n\");\n\n\tmutex_lock(&venc.venc_lock);\n\n\tconfig = venc_timings_to_config(&venc.timings);\n\n\t \n\tvenc.wss_data = (wss ^ 0xfffff) << 8;\n\n\tr = venc_runtime_get();\n\tif (r)\n\t\tgoto err;\n\n\tvenc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |\n\t\t\tvenc.wss_data);\n\n\tvenc_runtime_put();\n\nerr:\n\tmutex_unlock(&venc.venc_lock);\n\n\treturn r;\n}\n\nstatic void venc_set_type(struct omap_dss_device *dssdev,\n\t\tenum omap_dss_venc_type type)\n{\n\tmutex_lock(&venc.venc_lock);\n\n\tvenc.type = type;\n\n\tmutex_unlock(&venc.venc_lock);\n}\n\nstatic void venc_invert_vid_out_polarity(struct omap_dss_device *dssdev,\n\t\tbool invert_polarity)\n{\n\tmutex_lock(&venc.venc_lock);\n\n\tvenc.invert_polarity = invert_polarity;\n\n\tmutex_unlock(&venc.venc_lock);\n}\n\nstatic int venc_init_regulator(void)\n{\n\tstruct regulator *vdda_dac;\n\n\tif (venc.vdda_dac_reg != NULL)\n\t\treturn 0;\n\n\tif (venc.pdev->dev.of_node)\n\t\tvdda_dac = devm_regulator_get(&venc.pdev->dev, \"vdda\");\n\telse\n\t\tvdda_dac = devm_regulator_get(&venc.pdev->dev, \"vdda_dac\");\n\n\tif (IS_ERR(vdda_dac)) {\n\t\tif (PTR_ERR(vdda_dac) != -EPROBE_DEFER)\n\t\t\tDSSERR(\"can't get VDDA_DAC regulator\\n\");\n\t\treturn PTR_ERR(vdda_dac);\n\t}\n\n\tvenc.vdda_dac_reg = vdda_dac;\n\n\treturn 0;\n}\n\nstatic void venc_dump_regs(struct seq_file *s)\n{\n#define DUMPREG(r) seq_printf(s, \"%-35s %08x\\n\", #r, venc_read_reg(r))\n\n\tif (venc_runtime_get())\n\t\treturn;\n\n\tDUMPREG(VENC_F_CONTROL);\n\tDUMPREG(VENC_VIDOUT_CTRL);\n\tDUMPREG(VENC_SYNC_CTRL);\n\tDUMPREG(VENC_LLEN);\n\tDUMPREG(VENC_FLENS);\n\tDUMPREG(VENC_HFLTR_CTRL);\n\tDUMPREG(VENC_CC_CARR_WSS_CARR);\n\tDUMPREG(VENC_C_PHASE);\n\tDUMPREG(VENC_GAIN_U);\n\tDUMPREG(VENC_GAIN_V);\n\tDUMPREG(VENC_GAIN_Y);\n\tDUMPREG(VENC_BLACK_LEVEL);\n\tDUMPREG(VENC_BLANK_LEVEL);\n\tDUMPREG(VENC_X_COLOR);\n\tDUMPREG(VENC_M_CONTROL);\n\tDUMPREG(VENC_BSTAMP_WSS_DATA);\n\tDUMPREG(VENC_S_CARR);\n\tDUMPREG(VENC_LINE21);\n\tDUMPREG(VENC_LN_SEL);\n\tDUMPREG(VENC_L21__WC_CTL);\n\tDUMPREG(VENC_HTRIGGER_VTRIGGER);\n\tDUMPREG(VENC_SAVID__EAVID);\n\tDUMPREG(VENC_FLEN__FAL);\n\tDUMPREG(VENC_LAL__PHASE_RESET);\n\tDUMPREG(VENC_HS_INT_START_STOP_X);\n\tDUMPREG(VENC_HS_EXT_START_STOP_X);\n\tDUMPREG(VENC_VS_INT_START_X);\n\tDUMPREG(VENC_VS_INT_STOP_X__VS_INT_START_Y);\n\tDUMPREG(VENC_VS_INT_STOP_Y__VS_EXT_START_X);\n\tDUMPREG(VENC_VS_EXT_STOP_X__VS_EXT_START_Y);\n\tDUMPREG(VENC_VS_EXT_STOP_Y);\n\tDUMPREG(VENC_AVID_START_STOP_X);\n\tDUMPREG(VENC_AVID_START_STOP_Y);\n\tDUMPREG(VENC_FID_INT_START_X__FID_INT_START_Y);\n\tDUMPREG(VENC_FID_INT_OFFSET_Y__FID_EXT_START_X);\n\tDUMPREG(VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y);\n\tDUMPREG(VENC_TVDETGP_INT_START_STOP_X);\n\tDUMPREG(VENC_TVDETGP_INT_START_STOP_Y);\n\tDUMPREG(VENC_GEN_CTRL);\n\tDUMPREG(VENC_OUTPUT_CONTROL);\n\tDUMPREG(VENC_OUTPUT_TEST);\n\n\tvenc_runtime_put();\n\n#undef DUMPREG\n}\n\nstatic int venc_get_clocks(struct platform_device *pdev)\n{\n\tstruct clk *clk;\n\n\tif (dss_has_feature(FEAT_VENC_REQUIRES_TV_DAC_CLK)) {\n\t\tclk = devm_clk_get(&pdev->dev, \"tv_dac_clk\");\n\t\tif (IS_ERR(clk)) {\n\t\t\tDSSERR(\"can't get tv_dac_clk\\n\");\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\t} else {\n\t\tclk = NULL;\n\t}\n\n\tvenc.tv_dac_clk = clk;\n\n\treturn 0;\n}\n\nstatic int venc_connect(struct omap_dss_device *dssdev,\n\t\tstruct omap_dss_device *dst)\n{\n\tstruct omap_overlay_manager *mgr;\n\tint r;\n\n\tr = venc_init_regulator();\n\tif (r)\n\t\treturn r;\n\n\tmgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);\n\tif (!mgr)\n\t\treturn -ENODEV;\n\n\tr = dss_mgr_connect(mgr, dssdev);\n\tif (r)\n\t\treturn r;\n\n\tr = omapdss_output_set_device(dssdev, dst);\n\tif (r) {\n\t\tDSSERR(\"failed to connect output to new device: %s\\n\",\n\t\t\t\tdst->name);\n\t\tdss_mgr_disconnect(mgr, dssdev);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void venc_disconnect(struct omap_dss_device *dssdev,\n\t\tstruct omap_dss_device *dst)\n{\n\tWARN_ON(dst != dssdev->dst);\n\n\tif (dst != dssdev->dst)\n\t\treturn;\n\n\tomapdss_output_unset_device(dssdev);\n\n\tif (dssdev->manager)\n\t\tdss_mgr_disconnect(dssdev->manager, dssdev);\n}\n\nstatic const struct omapdss_atv_ops venc_ops = {\n\t.connect = venc_connect,\n\t.disconnect = venc_disconnect,\n\n\t.enable = venc_display_enable,\n\t.disable = venc_display_disable,\n\n\t.check_timings = venc_check_timings,\n\t.set_timings = venc_set_timings,\n\t.get_timings = venc_get_timings,\n\n\t.set_type = venc_set_type,\n\t.invert_vid_out_polarity = venc_invert_vid_out_polarity,\n\n\t.set_wss = venc_set_wss,\n\t.get_wss = venc_get_wss,\n};\n\nstatic void venc_init_output(struct platform_device *pdev)\n{\n\tstruct omap_dss_device *out = &venc.output;\n\n\tout->dev = &pdev->dev;\n\tout->id = OMAP_DSS_OUTPUT_VENC;\n\tout->output_type = OMAP_DISPLAY_TYPE_VENC;\n\tout->name = \"venc.0\";\n\tout->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;\n\tout->ops.atv = &venc_ops;\n\tout->owner = THIS_MODULE;\n\n\tomapdss_register_output(out);\n}\n\nstatic void venc_uninit_output(struct platform_device *pdev)\n{\n\tstruct omap_dss_device *out = &venc.output;\n\n\tomapdss_unregister_output(out);\n}\n\nstatic int venc_probe_of(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device_node *ep;\n\tu32 channels;\n\tint r;\n\n\tep = omapdss_of_get_first_endpoint(node);\n\tif (!ep)\n\t\treturn 0;\n\n\tvenc.invert_polarity = of_property_read_bool(ep, \"ti,invert-polarity\");\n\n\tr = of_property_read_u32(ep, \"ti,channels\", &channels);\n\tif (r) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to read property 'ti,channels': %d\\n\", r);\n\t\tgoto err;\n\t}\n\n\tswitch (channels) {\n\tcase 1:\n\t\tvenc.type = OMAP_DSS_VENC_TYPE_COMPOSITE;\n\t\tbreak;\n\tcase 2:\n\t\tvenc.type = OMAP_DSS_VENC_TYPE_SVIDEO;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"bad channel property '%d'\\n\", channels);\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tof_node_put(ep);\n\n\treturn 0;\nerr:\n\tof_node_put(ep);\n\n\treturn 0;\n}\n\n \nstatic int venc_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tu8 rev_id;\n\tstruct resource *venc_mem;\n\tint r;\n\n\tvenc.pdev = pdev;\n\n\tmutex_init(&venc.venc_lock);\n\n\tvenc.wss_data = 0;\n\n\tvenc_mem = platform_get_resource(venc.pdev, IORESOURCE_MEM, 0);\n\tif (!venc_mem) {\n\t\tDSSERR(\"can't get IORESOURCE_MEM VENC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvenc.base = devm_ioremap(&pdev->dev, venc_mem->start,\n\t\t\t\t resource_size(venc_mem));\n\tif (!venc.base) {\n\t\tDSSERR(\"can't ioremap VENC\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tr = venc_get_clocks(pdev);\n\tif (r)\n\t\treturn r;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tr = venc_runtime_get();\n\tif (r)\n\t\tgoto err_runtime_get;\n\n\trev_id = (u8)(venc_read_reg(VENC_REV_ID) & 0xff);\n\tdev_dbg(&pdev->dev, \"OMAP VENC rev %d\\n\", rev_id);\n\n\tvenc_runtime_put();\n\n\tif (pdev->dev.of_node) {\n\t\tr = venc_probe_of(pdev);\n\t\tif (r) {\n\t\t\tDSSERR(\"Invalid DT data\\n\");\n\t\t\tgoto err_probe_of;\n\t\t}\n\t}\n\n\tdss_debugfs_create_file(\"venc\", venc_dump_regs);\n\n\tvenc_init_output(pdev);\n\n\treturn 0;\n\nerr_probe_of:\nerr_runtime_get:\n\tpm_runtime_disable(&pdev->dev);\n\treturn r;\n}\n\nstatic void venc_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tvenc_uninit_output(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct component_ops venc_component_ops = {\n\t.bind\t= venc_bind,\n\t.unbind\t= venc_unbind,\n};\n\nstatic int venc_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &venc_component_ops);\n}\n\nstatic void venc_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &venc_component_ops);\n}\n\nstatic int venc_runtime_suspend(struct device *dev)\n{\n\tclk_disable_unprepare(venc.tv_dac_clk);\n\n\tdispc_runtime_put();\n\n\treturn 0;\n}\n\nstatic int venc_runtime_resume(struct device *dev)\n{\n\tint r;\n\n\tr = dispc_runtime_get();\n\tif (r < 0)\n\t\treturn r;\n\n\tclk_prepare_enable(venc.tv_dac_clk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops venc_pm_ops = {\n\t.runtime_suspend = venc_runtime_suspend,\n\t.runtime_resume = venc_runtime_resume,\n};\n\nstatic const struct of_device_id venc_of_match[] = {\n\t{ .compatible = \"ti,omap2-venc\", },\n\t{ .compatible = \"ti,omap3-venc\", },\n\t{ .compatible = \"ti,omap4-venc\", },\n\t{},\n};\n\nstatic struct platform_driver omap_venchw_driver = {\n\t.probe\t\t= venc_probe,\n\t.remove_new\t= venc_remove,\n\t.driver         = {\n\t\t.name   = \"omapdss_venc\",\n\t\t.pm\t= &venc_pm_ops,\n\t\t.of_match_table = venc_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nint __init venc_init_platform_driver(void)\n{\n\treturn platform_driver_register(&omap_venchw_driver);\n}\n\nvoid venc_uninit_platform_driver(void)\n{\n\tplatform_driver_unregister(&omap_venchw_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}