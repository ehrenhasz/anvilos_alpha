{
  "module_name": "manager-sysfs.c",
  "hash_id": "c797e09e76dc33d15b9153e6960216d88a136d0c162a7cdd0b86ed5778762f0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/manager-sysfs.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"MANAGER\"\n\n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/jiffies.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"dss_features.h\"\n\nstatic ssize_t manager_name_show(struct omap_overlay_manager *mgr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", mgr->name);\n}\n\nstatic ssize_t manager_display_show(struct omap_overlay_manager *mgr, char *buf)\n{\n\tstruct omap_dss_device *dssdev = mgr->get_device(mgr);\n\n\treturn sysfs_emit(buf, \"%s\\n\", dssdev ?\n\t\t\tdssdev->name : \"<none>\");\n}\n\nstatic int manager_display_match(struct omap_dss_device *dssdev, void *data)\n{\n\tconst char *str = data;\n\n\treturn sysfs_streq(dssdev->name, str);\n}\n\nstatic ssize_t manager_display_store(struct omap_overlay_manager *mgr,\n\t\tconst char *buf, size_t size)\n{\n\tint r = 0;\n\tsize_t len = size;\n\tstruct omap_dss_device *dssdev = NULL;\n\tstruct omap_dss_device *old_dssdev;\n\n\tif (buf[size-1] == '\\n')\n\t\t--len;\n\n\tif (len > 0)\n\t\tdssdev = omap_dss_find_device((void *)buf,\n\t\t\tmanager_display_match);\n\n\tif (len > 0 && dssdev == NULL)\n\t\treturn -EINVAL;\n\n\tif (dssdev) {\n\t\tDSSDBG(\"display %s found\\n\", dssdev->name);\n\n\t\tif (omapdss_device_is_connected(dssdev)) {\n\t\t\tDSSERR(\"new display is already connected\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto put_device;\n\t\t}\n\n\t\tif (omapdss_device_is_enabled(dssdev)) {\n\t\t\tDSSERR(\"new display is not disabled\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto put_device;\n\t\t}\n\t}\n\n\told_dssdev = mgr->get_device(mgr);\n\tif (old_dssdev) {\n\t\tif (omapdss_device_is_enabled(old_dssdev)) {\n\t\t\tDSSERR(\"old display is not disabled\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto put_device;\n\t\t}\n\n\t\told_dssdev->driver->disconnect(old_dssdev);\n\t}\n\n\tif (dssdev) {\n\t\tr = dssdev->driver->connect(dssdev);\n\t\tif (r) {\n\t\t\tDSSERR(\"failed to connect new device\\n\");\n\t\t\tgoto put_device;\n\t\t}\n\n\t\told_dssdev = mgr->get_device(mgr);\n\t\tif (old_dssdev != dssdev) {\n\t\t\tDSSERR(\"failed to connect device to this manager\\n\");\n\t\t\tdssdev->driver->disconnect(dssdev);\n\t\t\tgoto put_device;\n\t\t}\n\n\t\tr = mgr->apply(mgr);\n\t\tif (r) {\n\t\t\tDSSERR(\"failed to apply dispc config\\n\");\n\t\t\tgoto put_device;\n\t\t}\n\t}\n\nput_device:\n\tif (dssdev)\n\t\tomap_dss_put_device(dssdev);\n\n\treturn r ? r : size;\n}\n\nstatic ssize_t manager_default_color_show(struct omap_overlay_manager *mgr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct omap_overlay_manager_info info;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\treturn sysfs_emit(buf, \"%#x\\n\", info.default_color);\n}\n\nstatic ssize_t manager_default_color_store(struct omap_overlay_manager *mgr,\n\t\t\t\t\t   const char *buf, size_t size)\n{\n\tstruct omap_overlay_manager_info info;\n\tu32 color;\n\tint r;\n\n\tr = kstrtouint(buf, 0, &color);\n\tif (r)\n\t\treturn r;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\tinfo.default_color = color;\n\n\tr = mgr->set_manager_info(mgr, &info);\n\tif (r)\n\t\treturn r;\n\n\tr = mgr->apply(mgr);\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstatic const char *trans_key_type_str[] = {\n\t\"gfx-destination\",\n\t\"video-source\",\n};\n\nstatic ssize_t manager_trans_key_type_show(struct omap_overlay_manager *mgr,\n\t\t\t\t\t   char *buf)\n{\n\tenum omap_dss_trans_key_type key_type;\n\tstruct omap_overlay_manager_info info;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\tkey_type = info.trans_key_type;\n\tBUG_ON(key_type >= ARRAY_SIZE(trans_key_type_str));\n\n\treturn sysfs_emit(buf, \"%s\\n\", trans_key_type_str[key_type]);\n}\n\nstatic ssize_t manager_trans_key_type_store(struct omap_overlay_manager *mgr,\n\t\t\t\t\t    const char *buf, size_t size)\n{\n\tstruct omap_overlay_manager_info info;\n\tint r;\n\n\tr = sysfs_match_string(trans_key_type_str, buf);\n\tif (r < 0)\n\t\treturn r;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\tinfo.trans_key_type = r;\n\n\tr = mgr->set_manager_info(mgr, &info);\n\tif (r)\n\t\treturn r;\n\n\tr = mgr->apply(mgr);\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstatic ssize_t manager_trans_key_value_show(struct omap_overlay_manager *mgr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct omap_overlay_manager_info info;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\treturn sysfs_emit(buf, \"%#x\\n\", info.trans_key);\n}\n\nstatic ssize_t manager_trans_key_value_store(struct omap_overlay_manager *mgr,\n\t\t\t\t\t     const char *buf, size_t size)\n{\n\tstruct omap_overlay_manager_info info;\n\tu32 key_value;\n\tint r;\n\n\tr = kstrtouint(buf, 0, &key_value);\n\tif (r)\n\t\treturn r;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\tinfo.trans_key = key_value;\n\n\tr = mgr->set_manager_info(mgr, &info);\n\tif (r)\n\t\treturn r;\n\n\tr = mgr->apply(mgr);\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstatic ssize_t manager_trans_key_enabled_show(struct omap_overlay_manager *mgr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct omap_overlay_manager_info info;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\treturn sysfs_emit(buf, \"%d\\n\", info.trans_enabled);\n}\n\nstatic ssize_t manager_trans_key_enabled_store(struct omap_overlay_manager *mgr,\n\t\t\t\t\t       const char *buf, size_t size)\n{\n\tstruct omap_overlay_manager_info info;\n\tbool enable;\n\tint r;\n\n\tr = kstrtobool(buf, &enable);\n\tif (r)\n\t\treturn r;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\tinfo.trans_enabled = enable;\n\n\tr = mgr->set_manager_info(mgr, &info);\n\tif (r)\n\t\treturn r;\n\n\tr = mgr->apply(mgr);\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstatic ssize_t manager_alpha_blending_enabled_show(\n\t\tstruct omap_overlay_manager *mgr, char *buf)\n{\n\tstruct omap_overlay_manager_info info;\n\n\tif(!dss_has_feature(FEAT_ALPHA_FIXED_ZORDER))\n\t\treturn -ENODEV;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\tinfo.partial_alpha_enabled);\n}\n\nstatic ssize_t manager_alpha_blending_enabled_store(\n\t\tstruct omap_overlay_manager *mgr,\n\t\tconst char *buf, size_t size)\n{\n\tstruct omap_overlay_manager_info info;\n\tbool enable;\n\tint r;\n\n\tif(!dss_has_feature(FEAT_ALPHA_FIXED_ZORDER))\n\t\treturn -ENODEV;\n\n\tr = kstrtobool(buf, &enable);\n\tif (r)\n\t\treturn r;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\tinfo.partial_alpha_enabled = enable;\n\n\tr = mgr->set_manager_info(mgr, &info);\n\tif (r)\n\t\treturn r;\n\n\tr = mgr->apply(mgr);\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstatic ssize_t manager_cpr_enable_show(struct omap_overlay_manager *mgr,\n\t\tchar *buf)\n{\n\tstruct omap_overlay_manager_info info;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\treturn sysfs_emit(buf, \"%d\\n\", info.cpr_enable);\n}\n\nstatic ssize_t manager_cpr_enable_store(struct omap_overlay_manager *mgr,\n\t\tconst char *buf, size_t size)\n{\n\tstruct omap_overlay_manager_info info;\n\tint r;\n\tbool enable;\n\n\tif (!dss_has_feature(FEAT_CPR))\n\t\treturn -ENODEV;\n\n\tr = kstrtobool(buf, &enable);\n\tif (r)\n\t\treturn r;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\tif (info.cpr_enable == enable)\n\t\treturn size;\n\n\tinfo.cpr_enable = enable;\n\n\tr = mgr->set_manager_info(mgr, &info);\n\tif (r)\n\t\treturn r;\n\n\tr = mgr->apply(mgr);\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstatic ssize_t manager_cpr_coef_show(struct omap_overlay_manager *mgr,\n\t\tchar *buf)\n{\n\tstruct omap_overlay_manager_info info;\n\n\tmgr->get_manager_info(mgr, &info);\n\n\treturn sysfs_emit(buf,\n\t\t\t\"%d %d %d %d %d %d %d %d %d\\n\",\n\t\t\tinfo.cpr_coefs.rr,\n\t\t\tinfo.cpr_coefs.rg,\n\t\t\tinfo.cpr_coefs.rb,\n\t\t\tinfo.cpr_coefs.gr,\n\t\t\tinfo.cpr_coefs.gg,\n\t\t\tinfo.cpr_coefs.gb,\n\t\t\tinfo.cpr_coefs.br,\n\t\t\tinfo.cpr_coefs.bg,\n\t\t\tinfo.cpr_coefs.bb);\n}\n\nstatic ssize_t manager_cpr_coef_store(struct omap_overlay_manager *mgr,\n\t\tconst char *buf, size_t size)\n{\n\tstruct omap_overlay_manager_info info;\n\tstruct omap_dss_cpr_coefs coefs;\n\tint r, i;\n\ts16 *arr;\n\n\tif (!dss_has_feature(FEAT_CPR))\n\t\treturn -ENODEV;\n\n\tif (sscanf(buf, \"%hd %hd %hd %hd %hd %hd %hd %hd %hd\",\n\t\t\t\t&coefs.rr, &coefs.rg, &coefs.rb,\n\t\t\t\t&coefs.gr, &coefs.gg, &coefs.gb,\n\t\t\t\t&coefs.br, &coefs.bg, &coefs.bb) != 9)\n\t\treturn -EINVAL;\n\n\tarr = (s16[]){ coefs.rr, coefs.rg, coefs.rb,\n\t\tcoefs.gr, coefs.gg, coefs.gb,\n\t\tcoefs.br, coefs.bg, coefs.bb };\n\n\tfor (i = 0; i < 9; ++i) {\n\t\tif (arr[i] < -512 || arr[i] > 511)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmgr->get_manager_info(mgr, &info);\n\n\tinfo.cpr_coefs = coefs;\n\n\tr = mgr->set_manager_info(mgr, &info);\n\tif (r)\n\t\treturn r;\n\n\tr = mgr->apply(mgr);\n\tif (r)\n\t\treturn r;\n\n\treturn size;\n}\n\nstruct manager_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct omap_overlay_manager *, char *);\n\tssize_t\t(*store)(struct omap_overlay_manager *, const char *, size_t);\n};\n\n#define MANAGER_ATTR(_name, _mode, _show, _store) \\\n\tstruct manager_attribute manager_attr_##_name = \\\n\t__ATTR(_name, _mode, _show, _store)\n\nstatic MANAGER_ATTR(name, S_IRUGO, manager_name_show, NULL);\nstatic MANAGER_ATTR(display, S_IRUGO|S_IWUSR,\n\t\tmanager_display_show, manager_display_store);\nstatic MANAGER_ATTR(default_color, S_IRUGO|S_IWUSR,\n\t\tmanager_default_color_show, manager_default_color_store);\nstatic MANAGER_ATTR(trans_key_type, S_IRUGO|S_IWUSR,\n\t\tmanager_trans_key_type_show, manager_trans_key_type_store);\nstatic MANAGER_ATTR(trans_key_value, S_IRUGO|S_IWUSR,\n\t\tmanager_trans_key_value_show, manager_trans_key_value_store);\nstatic MANAGER_ATTR(trans_key_enabled, S_IRUGO|S_IWUSR,\n\t\tmanager_trans_key_enabled_show,\n\t\tmanager_trans_key_enabled_store);\nstatic MANAGER_ATTR(alpha_blending_enabled, S_IRUGO|S_IWUSR,\n\t\tmanager_alpha_blending_enabled_show,\n\t\tmanager_alpha_blending_enabled_store);\nstatic MANAGER_ATTR(cpr_enable, S_IRUGO|S_IWUSR,\n\t\tmanager_cpr_enable_show,\n\t\tmanager_cpr_enable_store);\nstatic MANAGER_ATTR(cpr_coef, S_IRUGO|S_IWUSR,\n\t\tmanager_cpr_coef_show,\n\t\tmanager_cpr_coef_store);\n\n\nstatic struct attribute *manager_sysfs_attrs[] = {\n\t&manager_attr_name.attr,\n\t&manager_attr_display.attr,\n\t&manager_attr_default_color.attr,\n\t&manager_attr_trans_key_type.attr,\n\t&manager_attr_trans_key_value.attr,\n\t&manager_attr_trans_key_enabled.attr,\n\t&manager_attr_alpha_blending_enabled.attr,\n\t&manager_attr_cpr_enable.attr,\n\t&manager_attr_cpr_coef.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(manager_sysfs);\n\nstatic ssize_t manager_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\tchar *buf)\n{\n\tstruct omap_overlay_manager *manager;\n\tstruct manager_attribute *manager_attr;\n\n\tmanager = container_of(kobj, struct omap_overlay_manager, kobj);\n\tmanager_attr = container_of(attr, struct manager_attribute, attr);\n\n\tif (!manager_attr->show)\n\t\treturn -ENOENT;\n\n\treturn manager_attr->show(manager, buf);\n}\n\nstatic ssize_t manager_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\tconst char *buf, size_t size)\n{\n\tstruct omap_overlay_manager *manager;\n\tstruct manager_attribute *manager_attr;\n\n\tmanager = container_of(kobj, struct omap_overlay_manager, kobj);\n\tmanager_attr = container_of(attr, struct manager_attribute, attr);\n\n\tif (!manager_attr->store)\n\t\treturn -ENOENT;\n\n\treturn manager_attr->store(manager, buf, size);\n}\n\nstatic const struct sysfs_ops manager_sysfs_ops = {\n\t.show = manager_attr_show,\n\t.store = manager_attr_store,\n};\n\nstatic struct kobj_type manager_ktype = {\n\t.sysfs_ops = &manager_sysfs_ops,\n\t.default_groups = manager_sysfs_groups,\n};\n\nint dss_manager_kobj_init(struct omap_overlay_manager *mgr,\n\t\tstruct platform_device *pdev)\n{\n\treturn kobject_init_and_add(&mgr->kobj, &manager_ktype,\n\t\t\t&pdev->dev.kobj, \"manager%d\", mgr->id);\n}\n\nvoid dss_manager_kobj_uninit(struct omap_overlay_manager *mgr)\n{\n\tkobject_del(&mgr->kobj);\n\tkobject_put(&mgr->kobj);\n\n\tmemset(&mgr->kobj, 0, sizeof(mgr->kobj));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}