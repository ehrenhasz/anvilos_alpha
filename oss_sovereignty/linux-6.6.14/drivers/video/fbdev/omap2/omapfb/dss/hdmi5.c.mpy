{
  "module_name": "hdmi5.c",
  "hash_id": "660a71ee41f1cf9a9dd38a572ebabdd2cc6b8ac0869312fbc58e5bd752a85f31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/hdmi5.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"HDMI\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/component.h>\n#include <video/omapfb_dss.h>\n#include <sound/omap-hdmi-audio.h>\n\n#include \"hdmi5_core.h\"\n#include \"dss.h\"\n#include \"dss_features.h\"\n\nstatic struct omap_hdmi hdmi;\n\nstatic int hdmi_runtime_get(void)\n{\n\tint r;\n\n\tDSSDBG(\"hdmi_runtime_get\\n\");\n\n\tr = pm_runtime_resume_and_get(&hdmi.pdev->dev);\n\tif (WARN_ON(r < 0))\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic void hdmi_runtime_put(void)\n{\n\tint r;\n\n\tDSSDBG(\"hdmi_runtime_put\\n\");\n\n\tr = pm_runtime_put_sync(&hdmi.pdev->dev);\n\tWARN_ON(r < 0 && r != -ENOSYS);\n}\n\nstatic irqreturn_t hdmi_irq_handler(int irq, void *data)\n{\n\tstruct hdmi_wp_data *wp = data;\n\tu32 irqstatus;\n\n\tirqstatus = hdmi_wp_get_irqstatus(wp);\n\thdmi_wp_set_irqstatus(wp, irqstatus);\n\n\tif ((irqstatus & HDMI_IRQ_LINK_CONNECT) &&\n\t\t\tirqstatus & HDMI_IRQ_LINK_DISCONNECT) {\n\t\tu32 v;\n\t\t \n\n\t\thdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_OFF);\n\n\t\t \n\t\tv = hdmi_read_reg(hdmi.phy.base, HDMI_TXPHY_PAD_CFG_CTRL);\n\t\tv = FLD_MOD(v, 1, 15, 15);  \n\t\tv = FLD_MOD(v, 0, 14, 7);  \n\t\thdmi_write_reg(hdmi.phy.base, HDMI_TXPHY_PAD_CFG_CTRL, v);\n\n\t\thdmi_wp_set_irqstatus(wp, HDMI_IRQ_LINK_CONNECT |\n\t\t\t\tHDMI_IRQ_LINK_DISCONNECT);\n\n\t\thdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_LDOON);\n\n\t\tREG_FLD_MOD(hdmi.phy.base, HDMI_TXPHY_PAD_CFG_CTRL, 0, 15, 15);\n\n\t} else if (irqstatus & HDMI_IRQ_LINK_CONNECT) {\n\t\thdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_TXON);\n\t} else if (irqstatus & HDMI_IRQ_LINK_DISCONNECT) {\n\t\thdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_LDOON);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int hdmi_init_regulator(void)\n{\n\tstruct regulator *reg;\n\n\tif (hdmi.vdda_reg != NULL)\n\t\treturn 0;\n\n\treg = devm_regulator_get(&hdmi.pdev->dev, \"vdda\");\n\tif (IS_ERR(reg)) {\n\t\tDSSERR(\"can't get VDDA regulator\\n\");\n\t\treturn PTR_ERR(reg);\n\t}\n\n\thdmi.vdda_reg = reg;\n\n\treturn 0;\n}\n\nstatic int hdmi_power_on_core(struct omap_dss_device *dssdev)\n{\n\tint r;\n\n\tr = regulator_enable(hdmi.vdda_reg);\n\tif (r)\n\t\treturn r;\n\n\tr = hdmi_runtime_get();\n\tif (r)\n\t\tgoto err_runtime_get;\n\n\t \n\tdss_select_hdmi_venc_clk_source(DSS_HDMI_M_PCLK);\n\n\thdmi.core_enabled = true;\n\n\treturn 0;\n\nerr_runtime_get:\n\tregulator_disable(hdmi.vdda_reg);\n\n\treturn r;\n}\n\nstatic void hdmi_power_off_core(struct omap_dss_device *dssdev)\n{\n\thdmi.core_enabled = false;\n\n\thdmi_runtime_put();\n\tregulator_disable(hdmi.vdda_reg);\n}\n\nstatic int hdmi_power_on_full(struct omap_dss_device *dssdev)\n{\n\tint r;\n\tstruct omap_video_timings *p;\n\tstruct omap_overlay_manager *mgr = hdmi.output.manager;\n\tstruct dss_pll_clock_info hdmi_cinfo = { 0 };\n\n\tr = hdmi_power_on_core(dssdev);\n\tif (r)\n\t\treturn r;\n\n\tp = &hdmi.cfg.timings;\n\n\tDSSDBG(\"hdmi_power_on x_res= %d y_res = %d\\n\", p->x_res, p->y_res);\n\n\thdmi_pll_compute(&hdmi.pll, p->pixelclock, &hdmi_cinfo);\n\n\t \n\thdmi_wp_clear_irqenable(&hdmi.wp, 0xffffffff);\n\thdmi_wp_set_irqstatus(&hdmi.wp,\n\t\t\thdmi_wp_get_irqstatus(&hdmi.wp));\n\n\tr = dss_pll_enable(&hdmi.pll.pll);\n\tif (r) {\n\t\tDSSERR(\"Failed to enable PLL\\n\");\n\t\tgoto err_pll_enable;\n\t}\n\n\tr = dss_pll_set_config(&hdmi.pll.pll, &hdmi_cinfo);\n\tif (r) {\n\t\tDSSERR(\"Failed to configure PLL\\n\");\n\t\tgoto err_pll_cfg;\n\t}\n\n\tr = hdmi_phy_configure(&hdmi.phy, hdmi_cinfo.clkdco,\n\t\thdmi_cinfo.clkout[0]);\n\tif (r) {\n\t\tDSSDBG(\"Failed to start PHY\\n\");\n\t\tgoto err_phy_cfg;\n\t}\n\n\tr = hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_LDOON);\n\tif (r)\n\t\tgoto err_phy_pwr;\n\n\thdmi5_configure(&hdmi.core, &hdmi.wp, &hdmi.cfg);\n\n\t \n\tdispc_enable_gamma_table(0);\n\n\t \n\tdss_mgr_set_timings(mgr, p);\n\n\tr = hdmi_wp_video_start(&hdmi.wp);\n\tif (r)\n\t\tgoto err_vid_enable;\n\n\tr = dss_mgr_enable(mgr);\n\tif (r)\n\t\tgoto err_mgr_enable;\n\n\thdmi_wp_set_irqenable(&hdmi.wp,\n\t\t\tHDMI_IRQ_LINK_CONNECT | HDMI_IRQ_LINK_DISCONNECT);\n\n\treturn 0;\n\nerr_mgr_enable:\n\thdmi_wp_video_stop(&hdmi.wp);\nerr_vid_enable:\n\thdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);\nerr_phy_pwr:\nerr_phy_cfg:\nerr_pll_cfg:\n\tdss_pll_disable(&hdmi.pll.pll);\nerr_pll_enable:\n\thdmi_power_off_core(dssdev);\n\treturn -EIO;\n}\n\nstatic void hdmi_power_off_full(struct omap_dss_device *dssdev)\n{\n\tstruct omap_overlay_manager *mgr = hdmi.output.manager;\n\n\thdmi_wp_clear_irqenable(&hdmi.wp, 0xffffffff);\n\n\tdss_mgr_disable(mgr);\n\n\thdmi_wp_video_stop(&hdmi.wp);\n\n\thdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);\n\n\tdss_pll_disable(&hdmi.pll.pll);\n\n\thdmi_power_off_core(dssdev);\n}\n\nstatic int hdmi_display_check_timing(struct omap_dss_device *dssdev,\n\t\t\t\t\tstruct omap_video_timings *timings)\n{\n\tstruct omap_dss_device *out = &hdmi.output;\n\n\t \n\tif (timings->interlace)\n\t\treturn -EINVAL;\n\n\tif (!dispc_mgr_timings_ok(out->dispc_channel, timings))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void hdmi_display_set_timing(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tmutex_lock(&hdmi.lock);\n\n\thdmi.cfg.timings = *timings;\n\n\tdispc_set_tv_pclk(timings->pixelclock);\n\n\tmutex_unlock(&hdmi.lock);\n}\n\nstatic void hdmi_display_get_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\t*timings = hdmi.cfg.timings;\n}\n\nstatic void hdmi_dump_regs(struct seq_file *s)\n{\n\tmutex_lock(&hdmi.lock);\n\n\tif (hdmi_runtime_get()) {\n\t\tmutex_unlock(&hdmi.lock);\n\t\treturn;\n\t}\n\n\thdmi_wp_dump(&hdmi.wp, s);\n\thdmi_pll_dump(&hdmi.pll, s);\n\thdmi_phy_dump(&hdmi.phy, s);\n\thdmi5_core_dump(&hdmi.core, s);\n\n\thdmi_runtime_put();\n\tmutex_unlock(&hdmi.lock);\n}\n\nstatic int read_edid(u8 *buf, int len)\n{\n\tint r;\n\tint idlemode;\n\n\tmutex_lock(&hdmi.lock);\n\n\tr = hdmi_runtime_get();\n\tBUG_ON(r);\n\n\tidlemode = REG_GET(hdmi.wp.base, HDMI_WP_SYSCONFIG, 3, 2);\n\t \n\tREG_FLD_MOD(hdmi.wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);\n\n\tr = hdmi5_read_edid(&hdmi.core,  buf, len);\n\n\tREG_FLD_MOD(hdmi.wp.base, HDMI_WP_SYSCONFIG, idlemode, 3, 2);\n\n\thdmi_runtime_put();\n\tmutex_unlock(&hdmi.lock);\n\n\treturn r;\n}\n\nstatic void hdmi_start_audio_stream(struct omap_hdmi *hd)\n{\n\tREG_FLD_MOD(hdmi.wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);\n\thdmi_wp_audio_enable(&hd->wp, true);\n\thdmi_wp_audio_core_req_enable(&hd->wp, true);\n}\n\nstatic void hdmi_stop_audio_stream(struct omap_hdmi *hd)\n{\n\thdmi_wp_audio_core_req_enable(&hd->wp, false);\n\thdmi_wp_audio_enable(&hd->wp, false);\n\tREG_FLD_MOD(hd->wp.base, HDMI_WP_SYSCONFIG, hd->wp_idlemode, 3, 2);\n}\n\nstatic int hdmi_display_enable(struct omap_dss_device *dssdev)\n{\n\tstruct omap_dss_device *out = &hdmi.output;\n\tunsigned long flags;\n\tint r = 0;\n\n\tDSSDBG(\"ENTER hdmi_display_enable\\n\");\n\n\tmutex_lock(&hdmi.lock);\n\n\tif (out->manager == NULL) {\n\t\tDSSERR(\"failed to enable display: no output/manager\\n\");\n\t\tr = -ENODEV;\n\t\tgoto err0;\n\t}\n\n\tr = hdmi_power_on_full(dssdev);\n\tif (r) {\n\t\tDSSERR(\"failed to power on device\\n\");\n\t\tgoto err0;\n\t}\n\n\tif (hdmi.audio_configured) {\n\t\tr = hdmi5_audio_config(&hdmi.core, &hdmi.wp, &hdmi.audio_config,\n\t\t\t\t       hdmi.cfg.timings.pixelclock);\n\t\tif (r) {\n\t\t\tDSSERR(\"Error restoring audio configuration: %d\", r);\n\t\t\thdmi.audio_abort_cb(&hdmi.pdev->dev);\n\t\t\thdmi.audio_configured = false;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&hdmi.audio_playing_lock, flags);\n\tif (hdmi.audio_configured && hdmi.audio_playing)\n\t\thdmi_start_audio_stream(&hdmi);\n\thdmi.display_enabled = true;\n\tspin_unlock_irqrestore(&hdmi.audio_playing_lock, flags);\n\n\tmutex_unlock(&hdmi.lock);\n\treturn 0;\n\nerr0:\n\tmutex_unlock(&hdmi.lock);\n\treturn r;\n}\n\nstatic void hdmi_display_disable(struct omap_dss_device *dssdev)\n{\n\tunsigned long flags;\n\n\tDSSDBG(\"Enter hdmi_display_disable\\n\");\n\n\tmutex_lock(&hdmi.lock);\n\n\tspin_lock_irqsave(&hdmi.audio_playing_lock, flags);\n\thdmi_stop_audio_stream(&hdmi);\n\thdmi.display_enabled = false;\n\tspin_unlock_irqrestore(&hdmi.audio_playing_lock, flags);\n\n\thdmi_power_off_full(dssdev);\n\n\tmutex_unlock(&hdmi.lock);\n}\n\nstatic int hdmi_core_enable(struct omap_dss_device *dssdev)\n{\n\tint r = 0;\n\n\tDSSDBG(\"ENTER omapdss_hdmi_core_enable\\n\");\n\n\tmutex_lock(&hdmi.lock);\n\n\tr = hdmi_power_on_core(dssdev);\n\tif (r) {\n\t\tDSSERR(\"failed to power on device\\n\");\n\t\tgoto err0;\n\t}\n\n\tmutex_unlock(&hdmi.lock);\n\treturn 0;\n\nerr0:\n\tmutex_unlock(&hdmi.lock);\n\treturn r;\n}\n\nstatic void hdmi_core_disable(struct omap_dss_device *dssdev)\n{\n\tDSSDBG(\"Enter omapdss_hdmi_core_disable\\n\");\n\n\tmutex_lock(&hdmi.lock);\n\n\thdmi_power_off_core(dssdev);\n\n\tmutex_unlock(&hdmi.lock);\n}\n\nstatic int hdmi_connect(struct omap_dss_device *dssdev,\n\t\tstruct omap_dss_device *dst)\n{\n\tstruct omap_overlay_manager *mgr;\n\tint r;\n\n\tr = hdmi_init_regulator();\n\tif (r)\n\t\treturn r;\n\n\tmgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);\n\tif (!mgr)\n\t\treturn -ENODEV;\n\n\tr = dss_mgr_connect(mgr, dssdev);\n\tif (r)\n\t\treturn r;\n\n\tr = omapdss_output_set_device(dssdev, dst);\n\tif (r) {\n\t\tDSSERR(\"failed to connect output to new device: %s\\n\",\n\t\t\t\tdst->name);\n\t\tdss_mgr_disconnect(mgr, dssdev);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void hdmi_disconnect(struct omap_dss_device *dssdev,\n\t\tstruct omap_dss_device *dst)\n{\n\tWARN_ON(dst != dssdev->dst);\n\n\tif (dst != dssdev->dst)\n\t\treturn;\n\n\tomapdss_output_unset_device(dssdev);\n\n\tif (dssdev->manager)\n\t\tdss_mgr_disconnect(dssdev->manager, dssdev);\n}\n\nstatic int hdmi_read_edid(struct omap_dss_device *dssdev,\n\t\tu8 *edid, int len)\n{\n\tbool need_enable;\n\tint r;\n\n\tneed_enable = hdmi.core_enabled == false;\n\n\tif (need_enable) {\n\t\tr = hdmi_core_enable(dssdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = read_edid(edid, len);\n\n\tif (need_enable)\n\t\thdmi_core_disable(dssdev);\n\n\treturn r;\n}\n\nstatic int hdmi_set_infoframe(struct omap_dss_device *dssdev,\n\t\tconst struct hdmi_avi_infoframe *avi)\n{\n\thdmi.cfg.infoframe = *avi;\n\treturn 0;\n}\n\nstatic int hdmi_set_hdmi_mode(struct omap_dss_device *dssdev,\n\t\tbool hdmi_mode)\n{\n\thdmi.cfg.hdmi_dvi_mode = hdmi_mode ? HDMI_HDMI : HDMI_DVI;\n\treturn 0;\n}\n\nstatic const struct omapdss_hdmi_ops hdmi_ops = {\n\t.connect\t\t= hdmi_connect,\n\t.disconnect\t\t= hdmi_disconnect,\n\n\t.enable\t\t\t= hdmi_display_enable,\n\t.disable\t\t= hdmi_display_disable,\n\n\t.check_timings\t\t= hdmi_display_check_timing,\n\t.set_timings\t\t= hdmi_display_set_timing,\n\t.get_timings\t\t= hdmi_display_get_timings,\n\n\t.read_edid\t\t= hdmi_read_edid,\n\t.set_infoframe\t\t= hdmi_set_infoframe,\n\t.set_hdmi_mode\t\t= hdmi_set_hdmi_mode,\n};\n\nstatic void hdmi_init_output(struct platform_device *pdev)\n{\n\tstruct omap_dss_device *out = &hdmi.output;\n\n\tout->dev = &pdev->dev;\n\tout->id = OMAP_DSS_OUTPUT_HDMI;\n\tout->output_type = OMAP_DISPLAY_TYPE_HDMI;\n\tout->name = \"hdmi.0\";\n\tout->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;\n\tout->ops.hdmi = &hdmi_ops;\n\tout->owner = THIS_MODULE;\n\n\tomapdss_register_output(out);\n}\n\nstatic void hdmi_uninit_output(struct platform_device *pdev)\n{\n\tstruct omap_dss_device *out = &hdmi.output;\n\n\tomapdss_unregister_output(out);\n}\n\nstatic int hdmi_probe_of(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device_node *ep;\n\tint r;\n\n\tep = omapdss_of_get_first_endpoint(node);\n\tif (!ep)\n\t\treturn 0;\n\n\tr = hdmi_parse_lanes_of(pdev, ep, &hdmi.phy);\n\tif (r)\n\t\tgoto err;\n\n\tof_node_put(ep);\n\treturn 0;\n\nerr:\n\tof_node_put(ep);\n\treturn r;\n}\n\n \nstatic int hdmi_audio_startup(struct device *dev,\n\t\t\t      void (*abort_cb)(struct device *dev))\n{\n\tstruct omap_hdmi *hd = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tmutex_lock(&hd->lock);\n\n\tif (!hdmi_mode_has_audio(&hd->cfg) || !hd->display_enabled) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\thd->audio_abort_cb = abort_cb;\n\nout:\n\tmutex_unlock(&hd->lock);\n\n\treturn ret;\n}\n\nstatic int hdmi_audio_shutdown(struct device *dev)\n{\n\tstruct omap_hdmi *hd = dev_get_drvdata(dev);\n\n\tmutex_lock(&hd->lock);\n\thd->audio_abort_cb = NULL;\n\thd->audio_configured = false;\n\thd->audio_playing = false;\n\tmutex_unlock(&hd->lock);\n\n\treturn 0;\n}\n\nstatic int hdmi_audio_start(struct device *dev)\n{\n\tstruct omap_hdmi *hd = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tWARN_ON(!hdmi_mode_has_audio(&hd->cfg));\n\n\tspin_lock_irqsave(&hd->audio_playing_lock, flags);\n\n\tif (hd->display_enabled)\n\t\thdmi_start_audio_stream(hd);\n\thd->audio_playing = true;\n\n\tspin_unlock_irqrestore(&hd->audio_playing_lock, flags);\n\treturn 0;\n}\n\nstatic void hdmi_audio_stop(struct device *dev)\n{\n\tstruct omap_hdmi *hd = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tWARN_ON(!hdmi_mode_has_audio(&hd->cfg));\n\n\tspin_lock_irqsave(&hd->audio_playing_lock, flags);\n\n\tif (hd->display_enabled)\n\t\thdmi_stop_audio_stream(hd);\n\thd->audio_playing = false;\n\n\tspin_unlock_irqrestore(&hd->audio_playing_lock, flags);\n}\n\nstatic int hdmi_audio_config(struct device *dev,\n\t\t\t     struct omap_dss_audio *dss_audio)\n{\n\tstruct omap_hdmi *hd = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&hd->lock);\n\n\tif (!hdmi_mode_has_audio(&hd->cfg) || !hd->display_enabled) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tret = hdmi5_audio_config(&hd->core, &hd->wp, dss_audio,\n\t\t\t\t hd->cfg.timings.pixelclock);\n\n\tif (!ret) {\n\t\thd->audio_configured = true;\n\t\thd->audio_config = *dss_audio;\n\t}\nout:\n\tmutex_unlock(&hd->lock);\n\n\treturn ret;\n}\n\nstatic const struct omap_hdmi_audio_ops hdmi_audio_ops = {\n\t.audio_startup = hdmi_audio_startup,\n\t.audio_shutdown = hdmi_audio_shutdown,\n\t.audio_start = hdmi_audio_start,\n\t.audio_stop = hdmi_audio_stop,\n\t.audio_config = hdmi_audio_config,\n};\n\nstatic int hdmi_audio_register(struct device *dev)\n{\n\tstruct omap_hdmi_audio_pdata pdata = {\n\t\t.dev = dev,\n\t\t.version = 5,\n\t\t.audio_dma_addr = hdmi_wp_get_audio_dma_addr(&hdmi.wp),\n\t\t.ops = &hdmi_audio_ops,\n\t};\n\n\thdmi.audio_pdev = platform_device_register_data(\n\t\tdev, \"omap-hdmi-audio\", PLATFORM_DEVID_AUTO,\n\t\t&pdata, sizeof(pdata));\n\n\tif (IS_ERR(hdmi.audio_pdev))\n\t\treturn PTR_ERR(hdmi.audio_pdev);\n\n\thdmi_runtime_get();\n\thdmi.wp_idlemode =\n\t\tREG_GET(hdmi.wp.base, HDMI_WP_SYSCONFIG, 3, 2);\n\thdmi_runtime_put();\n\n\treturn 0;\n}\n\n \nstatic int hdmi5_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint r;\n\tint irq;\n\n\thdmi.pdev = pdev;\n\tplatform_set_drvdata(pdev, &hdmi);\n\n\tmutex_init(&hdmi.lock);\n\tspin_lock_init(&hdmi.audio_playing_lock);\n\n\tif (pdev->dev.of_node) {\n\t\tr = hdmi_probe_of(pdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = hdmi_wp_init(pdev, &hdmi.wp);\n\tif (r)\n\t\treturn r;\n\n\tr = hdmi_pll_init(pdev, &hdmi.pll, &hdmi.wp);\n\tif (r)\n\t\treturn r;\n\n\tr = hdmi_phy_init(pdev, &hdmi.phy);\n\tif (r)\n\t\tgoto err;\n\n\tr = hdmi5_core_init(pdev, &hdmi.core);\n\tif (r)\n\t\tgoto err;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tDSSERR(\"platform_get_irq failed\\n\");\n\t\tr = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tr = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\tNULL, hdmi_irq_handler,\n\t\t\tIRQF_ONESHOT, \"OMAP HDMI\", &hdmi.wp);\n\tif (r) {\n\t\tDSSERR(\"HDMI IRQ request failed\\n\");\n\t\tgoto err;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\thdmi_init_output(pdev);\n\n\tr = hdmi_audio_register(&pdev->dev);\n\tif (r) {\n\t\tDSSERR(\"Registering HDMI audio failed %d\\n\", r);\n\t\thdmi_uninit_output(pdev);\n\t\tpm_runtime_disable(&pdev->dev);\n\t\treturn r;\n\t}\n\n\tdss_debugfs_create_file(\"hdmi\", hdmi_dump_regs);\n\n\treturn 0;\nerr:\n\thdmi_pll_uninit(&hdmi.pll);\n\treturn r;\n}\n\nstatic void hdmi5_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tif (hdmi.audio_pdev)\n\t\tplatform_device_unregister(hdmi.audio_pdev);\n\n\thdmi_uninit_output(pdev);\n\n\thdmi_pll_uninit(&hdmi.pll);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct component_ops hdmi5_component_ops = {\n\t.bind\t= hdmi5_bind,\n\t.unbind\t= hdmi5_unbind,\n};\n\nstatic int hdmi5_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &hdmi5_component_ops);\n}\n\nstatic void hdmi5_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &hdmi5_component_ops);\n}\n\nstatic int hdmi_runtime_suspend(struct device *dev)\n{\n\tdispc_runtime_put();\n\n\treturn 0;\n}\n\nstatic int hdmi_runtime_resume(struct device *dev)\n{\n\tint r;\n\n\tr = dispc_runtime_get();\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops hdmi_pm_ops = {\n\t.runtime_suspend = hdmi_runtime_suspend,\n\t.runtime_resume = hdmi_runtime_resume,\n};\n\nstatic const struct of_device_id hdmi_of_match[] = {\n\t{ .compatible = \"ti,omap5-hdmi\", },\n\t{ .compatible = \"ti,dra7-hdmi\", },\n\t{},\n};\n\nstatic struct platform_driver omapdss_hdmihw_driver = {\n\t.probe\t\t= hdmi5_probe,\n\t.remove_new\t= hdmi5_remove,\n\t.driver         = {\n\t\t.name   = \"omapdss_hdmi5\",\n\t\t.pm\t= &hdmi_pm_ops,\n\t\t.of_match_table = hdmi_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nint __init hdmi5_init_platform_driver(void)\n{\n\treturn platform_driver_register(&omapdss_hdmihw_driver);\n}\n\nvoid hdmi5_uninit_platform_driver(void)\n{\n\tplatform_driver_unregister(&omapdss_hdmihw_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}