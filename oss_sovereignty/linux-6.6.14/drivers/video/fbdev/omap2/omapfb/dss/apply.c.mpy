{
  "module_name": "apply.c",
  "hash_id": "c2a40ac37bf09a365a81b878b8fff08d074ad97adcd02e4a8626ca517a01535e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/apply.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"APPLY\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/jiffies.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"dss_features.h\"\n#include \"dispc-compat.h\"\n\n \n\nstruct ovl_priv_data {\n\n\tbool user_info_dirty;\n\tstruct omap_overlay_info user_info;\n\n\tbool info_dirty;\n\tstruct omap_overlay_info info;\n\n\tbool shadow_info_dirty;\n\n\tbool extra_info_dirty;\n\tbool shadow_extra_info_dirty;\n\n\tbool enabled;\n\tu32 fifo_low, fifo_high;\n\n\t \n\tbool enabling;\n};\n\nstruct mgr_priv_data {\n\n\tbool user_info_dirty;\n\tstruct omap_overlay_manager_info user_info;\n\n\tbool info_dirty;\n\tstruct omap_overlay_manager_info info;\n\n\tbool shadow_info_dirty;\n\n\t \n\tbool busy;\n\n\t \n\tbool updating;\n\n\t \n\tbool enabled;\n\n\tbool extra_info_dirty;\n\tbool shadow_extra_info_dirty;\n\n\tstruct omap_video_timings timings;\n\tstruct dss_lcd_mgr_config lcd_config;\n\n\tvoid (*framedone_handler)(void *);\n\tvoid *framedone_handler_data;\n};\n\nstatic struct {\n\tstruct ovl_priv_data ovl_priv_data_array[MAX_DSS_OVERLAYS];\n\tstruct mgr_priv_data mgr_priv_data_array[MAX_DSS_MANAGERS];\n\n\tbool irq_enabled;\n} dss_data;\n\n \nstatic DEFINE_SPINLOCK(data_lock);\n \nstatic DEFINE_MUTEX(apply_lock);\nstatic DECLARE_COMPLETION(extra_updated_completion);\n\nstatic void dss_register_vsync_isr(void);\n\nstatic struct ovl_priv_data *get_ovl_priv(struct omap_overlay *ovl)\n{\n\treturn &dss_data.ovl_priv_data_array[ovl->id];\n}\n\nstatic struct mgr_priv_data *get_mgr_priv(struct omap_overlay_manager *mgr)\n{\n\treturn &dss_data.mgr_priv_data_array[mgr->id];\n}\n\nstatic void apply_init_priv(void)\n{\n\tconst int num_ovls = dss_feat_get_num_ovls();\n\tstruct mgr_priv_data *mp;\n\tint i;\n\n\tfor (i = 0; i < num_ovls; ++i) {\n\t\tstruct ovl_priv_data *op;\n\n\t\top = &dss_data.ovl_priv_data_array[i];\n\n\t\top->info.color_mode = OMAP_DSS_COLOR_RGB16;\n\t\top->info.rotation_type = OMAP_DSS_ROT_DMA;\n\n\t\top->info.global_alpha = 255;\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\top->info.zorder = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\top->info.zorder =\n\t\t\t\tdss_has_feature(FEAT_ALPHA_FREE_ZORDER) ? 3 : 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\top->info.zorder =\n\t\t\t\tdss_has_feature(FEAT_ALPHA_FREE_ZORDER) ? 2 : 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\top->info.zorder =\n\t\t\t\tdss_has_feature(FEAT_ALPHA_FREE_ZORDER) ? 1 : 0;\n\t\t\tbreak;\n\t\t}\n\n\t\top->user_info = op->info;\n\t}\n\n\t \n\tmp = &dss_data.mgr_priv_data_array[OMAP_DSS_CHANNEL_DIGIT];\n\n\tmp->lcd_config.video_port_width = 24;\n\tmp->lcd_config.clock_info.lck_div = 1;\n\tmp->lcd_config.clock_info.pck_div = 1;\n}\n\n \nstatic bool ovl_manual_update(struct omap_overlay *ovl)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(ovl->manager);\n\n\treturn mp->lcd_config.stallmode;\n}\n\nstatic bool mgr_manual_update(struct omap_overlay_manager *mgr)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\n\treturn mp->lcd_config.stallmode;\n}\n\nstatic int dss_check_settings_low(struct omap_overlay_manager *mgr,\n\t\tbool applying)\n{\n\tstruct omap_overlay_info *oi;\n\tstruct omap_overlay_manager_info *mi;\n\tstruct omap_overlay *ovl;\n\tstruct omap_overlay_info *ois[MAX_DSS_OVERLAYS];\n\tstruct ovl_priv_data *op;\n\tstruct mgr_priv_data *mp;\n\n\tmp = get_mgr_priv(mgr);\n\n\tif (!mp->enabled)\n\t\treturn 0;\n\n\tif (applying && mp->user_info_dirty)\n\t\tmi = &mp->user_info;\n\telse\n\t\tmi = &mp->info;\n\n\t \n\tlist_for_each_entry(ovl, &mgr->overlays, list) {\n\t\top = get_ovl_priv(ovl);\n\n\t\tif (!op->enabled && !op->enabling)\n\t\t\toi = NULL;\n\t\telse if (applying && op->user_info_dirty)\n\t\t\toi = &op->user_info;\n\t\telse\n\t\t\toi = &op->info;\n\n\t\tois[ovl->id] = oi;\n\t}\n\n\treturn dss_mgr_check(mgr, mi, &mp->timings, &mp->lcd_config, ois);\n}\n\n \nstatic int dss_check_settings(struct omap_overlay_manager *mgr)\n{\n\treturn dss_check_settings_low(mgr, false);\n}\n\n \nstatic int dss_check_settings_apply(struct omap_overlay_manager *mgr)\n{\n\treturn dss_check_settings_low(mgr, true);\n}\n\nstatic bool need_isr(void)\n{\n\tconst int num_mgrs = dss_feat_get_num_mgrs();\n\tint i;\n\n\tfor (i = 0; i < num_mgrs; ++i) {\n\t\tstruct omap_overlay_manager *mgr;\n\t\tstruct mgr_priv_data *mp;\n\t\tstruct omap_overlay *ovl;\n\n\t\tmgr = omap_dss_get_overlay_manager(i);\n\t\tmp = get_mgr_priv(mgr);\n\n\t\tif (!mp->enabled)\n\t\t\tcontinue;\n\n\t\tif (mgr_manual_update(mgr)) {\n\t\t\t \n\t\t\tif (mp->updating)\n\t\t\t\treturn true;\n\t\t} else {\n\t\t\t \n\t\t\tif (mp->busy)\n\t\t\t\treturn true;\n\n\t\t\t \n\t\t\tif (mp->info_dirty)\n\t\t\t\treturn true;\n\n\t\t\t \n\t\t\tif (mp->shadow_info_dirty)\n\t\t\t\treturn true;\n\n\t\t\t \n\n\t\t\t \n\t\t\tif (mp->extra_info_dirty)\n\t\t\t\treturn true;\n\n\t\t\t \n\t\t\tif (mp->shadow_extra_info_dirty)\n\t\t\t\treturn true;\n\n\t\t\tlist_for_each_entry(ovl, &mgr->overlays, list) {\n\t\t\t\tstruct ovl_priv_data *op;\n\n\t\t\t\top = get_ovl_priv(ovl);\n\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tif (op->extra_info_dirty)\n\t\t\t\t\treturn true;\n\n\t\t\t\t \n\t\t\t\tif (op->shadow_extra_info_dirty)\n\t\t\t\t\treturn true;\n\n\t\t\t\tif (!op->enabled)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tif (op->info_dirty)\n\t\t\t\t\treturn true;\n\n\t\t\t\t \n\t\t\t\tif (op->shadow_info_dirty)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool need_go(struct omap_overlay_manager *mgr)\n{\n\tstruct omap_overlay *ovl;\n\tstruct mgr_priv_data *mp;\n\tstruct ovl_priv_data *op;\n\n\tmp = get_mgr_priv(mgr);\n\n\tif (mp->shadow_info_dirty || mp->shadow_extra_info_dirty)\n\t\treturn true;\n\n\tlist_for_each_entry(ovl, &mgr->overlays, list) {\n\t\top = get_ovl_priv(ovl);\n\t\tif (op->shadow_info_dirty || op->shadow_extra_info_dirty)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool extra_info_update_ongoing(void)\n{\n\tconst int num_mgrs = dss_feat_get_num_mgrs();\n\tint i;\n\n\tfor (i = 0; i < num_mgrs; ++i) {\n\t\tstruct omap_overlay_manager *mgr;\n\t\tstruct omap_overlay *ovl;\n\t\tstruct mgr_priv_data *mp;\n\n\t\tmgr = omap_dss_get_overlay_manager(i);\n\t\tmp = get_mgr_priv(mgr);\n\n\t\tif (!mp->enabled)\n\t\t\tcontinue;\n\n\t\tif (!mp->updating)\n\t\t\tcontinue;\n\n\t\tif (mp->extra_info_dirty || mp->shadow_extra_info_dirty)\n\t\t\treturn true;\n\n\t\tlist_for_each_entry(ovl, &mgr->overlays, list) {\n\t\t\tstruct ovl_priv_data *op = get_ovl_priv(ovl);\n\n\t\t\tif (op->extra_info_dirty || op->shadow_extra_info_dirty)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic void wait_pending_extra_info_updates(void)\n{\n\tbool updating;\n\tunsigned long flags;\n\tunsigned long t;\n\tint r;\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tupdating = extra_info_update_ongoing();\n\n\tif (!updating) {\n\t\tspin_unlock_irqrestore(&data_lock, flags);\n\t\treturn;\n\t}\n\n\tinit_completion(&extra_updated_completion);\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\tt = msecs_to_jiffies(500);\n\tr = wait_for_completion_timeout(&extra_updated_completion, t);\n\tif (r == 0)\n\t\tDSSWARN(\"timeout in wait_pending_extra_info_updates\\n\");\n}\n\nstatic struct omap_dss_device *dss_mgr_get_device(struct omap_overlay_manager *mgr)\n{\n\tstruct omap_dss_device *dssdev;\n\n\tdssdev = mgr->output;\n\tif (dssdev == NULL)\n\t\treturn NULL;\n\n\twhile (dssdev->dst)\n\t\tdssdev = dssdev->dst;\n\n\tif (dssdev->driver)\n\t\treturn dssdev;\n\telse\n\t\treturn NULL;\n}\n\nstatic struct omap_dss_device *dss_ovl_get_device(struct omap_overlay *ovl)\n{\n\treturn ovl->manager ? dss_mgr_get_device(ovl->manager) : NULL;\n}\n\nstatic int dss_mgr_wait_for_vsync(struct omap_overlay_manager *mgr)\n{\n\tunsigned long timeout = msecs_to_jiffies(500);\n\tu32 irq;\n\tint r;\n\n\tif (mgr->output == NULL)\n\t\treturn -ENODEV;\n\n\tr = dispc_runtime_get();\n\tif (r)\n\t\treturn r;\n\n\tswitch (mgr->output->id) {\n\tcase OMAP_DSS_OUTPUT_VENC:\n\t\tirq = DISPC_IRQ_EVSYNC_ODD;\n\t\tbreak;\n\tcase OMAP_DSS_OUTPUT_HDMI:\n\t\tirq = DISPC_IRQ_EVSYNC_EVEN;\n\t\tbreak;\n\tdefault:\n\t\tirq = dispc_mgr_get_vsync_irq(mgr->id);\n\t\tbreak;\n\t}\n\n\tr = omap_dispc_wait_for_irq_interruptible_timeout(irq, timeout);\n\n\tdispc_runtime_put();\n\n\treturn r;\n}\n\nstatic int dss_mgr_wait_for_go(struct omap_overlay_manager *mgr)\n{\n\tunsigned long timeout = msecs_to_jiffies(500);\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\tu32 irq;\n\tunsigned long flags;\n\tint r;\n\tint i;\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tif (mgr_manual_update(mgr)) {\n\t\tspin_unlock_irqrestore(&data_lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (!mp->enabled) {\n\t\tspin_unlock_irqrestore(&data_lock, flags);\n\t\treturn 0;\n\t}\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\tr = dispc_runtime_get();\n\tif (r)\n\t\treturn r;\n\n\tirq = dispc_mgr_get_vsync_irq(mgr->id);\n\n\ti = 0;\n\twhile (1) {\n\t\tbool shadow_dirty, dirty;\n\n\t\tspin_lock_irqsave(&data_lock, flags);\n\t\tdirty = mp->info_dirty;\n\t\tshadow_dirty = mp->shadow_info_dirty;\n\t\tspin_unlock_irqrestore(&data_lock, flags);\n\n\t\tif (!dirty && !shadow_dirty) {\n\t\t\tr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i++ == 3) {\n\t\t\tDSSERR(\"mgr(%d)->wait_for_go() not finishing\\n\",\n\t\t\t\t\tmgr->id);\n\t\t\tr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = omap_dispc_wait_for_irq_interruptible_timeout(irq, timeout);\n\t\tif (r == -ERESTARTSYS)\n\t\t\tbreak;\n\n\t\tif (r) {\n\t\t\tDSSERR(\"mgr(%d)->wait_for_go() timeout\\n\", mgr->id);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdispc_runtime_put();\n\n\treturn r;\n}\n\nstatic int dss_mgr_wait_for_go_ovl(struct omap_overlay *ovl)\n{\n\tunsigned long timeout = msecs_to_jiffies(500);\n\tstruct ovl_priv_data *op;\n\tstruct mgr_priv_data *mp;\n\tu32 irq;\n\tunsigned long flags;\n\tint r;\n\tint i;\n\n\tif (!ovl->manager)\n\t\treturn 0;\n\n\tmp = get_mgr_priv(ovl->manager);\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tif (ovl_manual_update(ovl)) {\n\t\tspin_unlock_irqrestore(&data_lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (!mp->enabled) {\n\t\tspin_unlock_irqrestore(&data_lock, flags);\n\t\treturn 0;\n\t}\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\tr = dispc_runtime_get();\n\tif (r)\n\t\treturn r;\n\n\tirq = dispc_mgr_get_vsync_irq(ovl->manager->id);\n\n\top = get_ovl_priv(ovl);\n\ti = 0;\n\twhile (1) {\n\t\tbool shadow_dirty, dirty;\n\n\t\tspin_lock_irqsave(&data_lock, flags);\n\t\tdirty = op->info_dirty;\n\t\tshadow_dirty = op->shadow_info_dirty;\n\t\tspin_unlock_irqrestore(&data_lock, flags);\n\n\t\tif (!dirty && !shadow_dirty) {\n\t\t\tr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i++ == 3) {\n\t\t\tDSSERR(\"ovl(%d)->wait_for_go() not finishing\\n\",\n\t\t\t\t\tovl->id);\n\t\t\tr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = omap_dispc_wait_for_irq_interruptible_timeout(irq, timeout);\n\t\tif (r == -ERESTARTSYS)\n\t\t\tbreak;\n\n\t\tif (r) {\n\t\t\tDSSERR(\"ovl(%d)->wait_for_go() timeout\\n\", ovl->id);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdispc_runtime_put();\n\n\treturn r;\n}\n\nstatic void dss_ovl_write_regs(struct omap_overlay *ovl)\n{\n\tstruct ovl_priv_data *op = get_ovl_priv(ovl);\n\tstruct omap_overlay_info *oi;\n\tbool replication;\n\tstruct mgr_priv_data *mp;\n\tint r;\n\n\tDSSDBG(\"writing ovl %d regs\\n\", ovl->id);\n\n\tif (!op->enabled || !op->info_dirty)\n\t\treturn;\n\n\toi = &op->info;\n\n\tmp = get_mgr_priv(ovl->manager);\n\n\treplication = dss_ovl_use_replication(mp->lcd_config, oi->color_mode);\n\n\tr = dispc_ovl_setup(ovl->id, oi, replication, &mp->timings, false);\n\tif (r) {\n\t\t \n\t\tDSSERR(\"dispc_ovl_setup failed for ovl %d\\n\", ovl->id);\n\n\t\t \n\t\top->enabled = false;\n\t\tdispc_ovl_enable(ovl->id, false);\n\t\treturn;\n\t}\n\n\top->info_dirty = false;\n\tif (mp->updating)\n\t\top->shadow_info_dirty = true;\n}\n\nstatic void dss_ovl_write_regs_extra(struct omap_overlay *ovl)\n{\n\tstruct ovl_priv_data *op = get_ovl_priv(ovl);\n\tstruct mgr_priv_data *mp;\n\n\tDSSDBG(\"writing ovl %d regs extra\\n\", ovl->id);\n\n\tif (!op->extra_info_dirty)\n\t\treturn;\n\n\t \n\n\tdispc_ovl_enable(ovl->id, op->enabled);\n\tdispc_ovl_set_fifo_threshold(ovl->id, op->fifo_low, op->fifo_high);\n\n\tmp = get_mgr_priv(ovl->manager);\n\n\top->extra_info_dirty = false;\n\tif (mp->updating)\n\t\top->shadow_extra_info_dirty = true;\n}\n\nstatic void dss_mgr_write_regs(struct omap_overlay_manager *mgr)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\tstruct omap_overlay *ovl;\n\n\tDSSDBG(\"writing mgr %d regs\\n\", mgr->id);\n\n\tif (!mp->enabled)\n\t\treturn;\n\n\tWARN_ON(mp->busy);\n\n\t \n\tlist_for_each_entry(ovl, &mgr->overlays, list) {\n\t\tdss_ovl_write_regs(ovl);\n\t\tdss_ovl_write_regs_extra(ovl);\n\t}\n\n\tif (mp->info_dirty) {\n\t\tdispc_mgr_setup(mgr->id, &mp->info);\n\n\t\tmp->info_dirty = false;\n\t\tif (mp->updating)\n\t\t\tmp->shadow_info_dirty = true;\n\t}\n}\n\nstatic void dss_mgr_write_regs_extra(struct omap_overlay_manager *mgr)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\n\tDSSDBG(\"writing mgr %d regs extra\\n\", mgr->id);\n\n\tif (!mp->extra_info_dirty)\n\t\treturn;\n\n\tdispc_mgr_set_timings(mgr->id, &mp->timings);\n\n\t \n\tif (dss_mgr_is_lcd(mgr->id))\n\t\tdispc_mgr_set_lcd_config(mgr->id, &mp->lcd_config);\n\n\tmp->extra_info_dirty = false;\n\tif (mp->updating)\n\t\tmp->shadow_extra_info_dirty = true;\n}\n\nstatic void dss_write_regs(void)\n{\n\tconst int num_mgrs = omap_dss_get_num_overlay_managers();\n\tint i;\n\n\tfor (i = 0; i < num_mgrs; ++i) {\n\t\tstruct omap_overlay_manager *mgr;\n\t\tstruct mgr_priv_data *mp;\n\t\tint r;\n\n\t\tmgr = omap_dss_get_overlay_manager(i);\n\t\tmp = get_mgr_priv(mgr);\n\n\t\tif (!mp->enabled || mgr_manual_update(mgr) || mp->busy)\n\t\t\tcontinue;\n\n\t\tr = dss_check_settings(mgr);\n\t\tif (r) {\n\t\t\tDSSERR(\"cannot write registers for manager %s: \"\n\t\t\t\t\t\"illegal configuration\\n\", mgr->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdss_mgr_write_regs(mgr);\n\t\tdss_mgr_write_regs_extra(mgr);\n\t}\n}\n\nstatic void dss_set_go_bits(void)\n{\n\tconst int num_mgrs = omap_dss_get_num_overlay_managers();\n\tint i;\n\n\tfor (i = 0; i < num_mgrs; ++i) {\n\t\tstruct omap_overlay_manager *mgr;\n\t\tstruct mgr_priv_data *mp;\n\n\t\tmgr = omap_dss_get_overlay_manager(i);\n\t\tmp = get_mgr_priv(mgr);\n\n\t\tif (!mp->enabled || mgr_manual_update(mgr) || mp->busy)\n\t\t\tcontinue;\n\n\t\tif (!need_go(mgr))\n\t\t\tcontinue;\n\n\t\tmp->busy = true;\n\n\t\tif (!dss_data.irq_enabled && need_isr())\n\t\t\tdss_register_vsync_isr();\n\n\t\tdispc_mgr_go(mgr->id);\n\t}\n\n}\n\nstatic void mgr_clear_shadow_dirty(struct omap_overlay_manager *mgr)\n{\n\tstruct omap_overlay *ovl;\n\tstruct mgr_priv_data *mp;\n\tstruct ovl_priv_data *op;\n\n\tmp = get_mgr_priv(mgr);\n\tmp->shadow_info_dirty = false;\n\tmp->shadow_extra_info_dirty = false;\n\n\tlist_for_each_entry(ovl, &mgr->overlays, list) {\n\t\top = get_ovl_priv(ovl);\n\t\top->shadow_info_dirty = false;\n\t\top->shadow_extra_info_dirty = false;\n\t}\n}\n\nstatic int dss_mgr_connect_compat(struct omap_overlay_manager *mgr,\n\t\tstruct omap_dss_device *dst)\n{\n\treturn mgr->set_output(mgr, dst);\n}\n\nstatic void dss_mgr_disconnect_compat(struct omap_overlay_manager *mgr,\n\t\tstruct omap_dss_device *dst)\n{\n\tmgr->unset_output(mgr);\n}\n\nstatic void dss_mgr_start_update_compat(struct omap_overlay_manager *mgr)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tWARN_ON(mp->updating);\n\n\tr = dss_check_settings(mgr);\n\tif (r) {\n\t\tDSSERR(\"cannot start manual update: illegal configuration\\n\");\n\t\tspin_unlock_irqrestore(&data_lock, flags);\n\t\treturn;\n\t}\n\n\tdss_mgr_write_regs(mgr);\n\tdss_mgr_write_regs_extra(mgr);\n\n\tmp->updating = true;\n\n\tif (!dss_data.irq_enabled && need_isr())\n\t\tdss_register_vsync_isr();\n\n\tdispc_mgr_enable_sync(mgr->id);\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n}\n\nstatic void dss_apply_irq_handler(void *data, u32 mask);\n\nstatic void dss_register_vsync_isr(void)\n{\n\tconst int num_mgrs = dss_feat_get_num_mgrs();\n\tu32 mask;\n\tint r, i;\n\n\tmask = 0;\n\tfor (i = 0; i < num_mgrs; ++i)\n\t\tmask |= dispc_mgr_get_vsync_irq(i);\n\n\tfor (i = 0; i < num_mgrs; ++i)\n\t\tmask |= dispc_mgr_get_framedone_irq(i);\n\n\tr = omap_dispc_register_isr(dss_apply_irq_handler, NULL, mask);\n\tWARN_ON(r);\n\n\tdss_data.irq_enabled = true;\n}\n\nstatic void dss_unregister_vsync_isr(void)\n{\n\tconst int num_mgrs = dss_feat_get_num_mgrs();\n\tu32 mask;\n\tint r, i;\n\n\tmask = 0;\n\tfor (i = 0; i < num_mgrs; ++i)\n\t\tmask |= dispc_mgr_get_vsync_irq(i);\n\n\tfor (i = 0; i < num_mgrs; ++i)\n\t\tmask |= dispc_mgr_get_framedone_irq(i);\n\n\tr = omap_dispc_unregister_isr(dss_apply_irq_handler, NULL, mask);\n\tWARN_ON(r);\n\n\tdss_data.irq_enabled = false;\n}\n\nstatic void dss_apply_irq_handler(void *data, u32 mask)\n{\n\tconst int num_mgrs = dss_feat_get_num_mgrs();\n\tint i;\n\tbool extra_updating;\n\n\tspin_lock(&data_lock);\n\n\t \n\tfor (i = 0; i < num_mgrs; i++) {\n\t\tstruct omap_overlay_manager *mgr;\n\t\tstruct mgr_priv_data *mp;\n\n\t\tmgr = omap_dss_get_overlay_manager(i);\n\t\tmp = get_mgr_priv(mgr);\n\n\t\tif (!mp->enabled)\n\t\t\tcontinue;\n\n\t\tmp->updating = dispc_mgr_is_enabled(i);\n\n\t\tif (!mgr_manual_update(mgr)) {\n\t\t\tbool was_busy = mp->busy;\n\t\t\tmp->busy = dispc_mgr_go_busy(i);\n\n\t\t\tif (was_busy && !mp->busy)\n\t\t\t\tmgr_clear_shadow_dirty(mgr);\n\t\t}\n\t}\n\n\tdss_write_regs();\n\tdss_set_go_bits();\n\n\textra_updating = extra_info_update_ongoing();\n\tif (!extra_updating)\n\t\tcomplete_all(&extra_updated_completion);\n\n\t \n\tfor (i = 0; i < num_mgrs; i++) {\n\t\tstruct omap_overlay_manager *mgr;\n\t\tstruct mgr_priv_data *mp;\n\n\t\tmgr = omap_dss_get_overlay_manager(i);\n\t\tmp = get_mgr_priv(mgr);\n\n\t\tif (!mgr_manual_update(mgr) || !mp->framedone_handler)\n\t\t\tcontinue;\n\n\t\tif (mask & dispc_mgr_get_framedone_irq(i))\n\t\t\tmp->framedone_handler(mp->framedone_handler_data);\n\t}\n\n\tif (!need_isr())\n\t\tdss_unregister_vsync_isr();\n\n\tspin_unlock(&data_lock);\n}\n\nstatic void omap_dss_mgr_apply_ovl(struct omap_overlay *ovl)\n{\n\tstruct ovl_priv_data *op;\n\n\top = get_ovl_priv(ovl);\n\n\tif (!op->user_info_dirty)\n\t\treturn;\n\n\top->user_info_dirty = false;\n\top->info_dirty = true;\n\top->info = op->user_info;\n}\n\nstatic void omap_dss_mgr_apply_mgr(struct omap_overlay_manager *mgr)\n{\n\tstruct mgr_priv_data *mp;\n\n\tmp = get_mgr_priv(mgr);\n\n\tif (!mp->user_info_dirty)\n\t\treturn;\n\n\tmp->user_info_dirty = false;\n\tmp->info_dirty = true;\n\tmp->info = mp->user_info;\n}\n\nstatic int omap_dss_mgr_apply(struct omap_overlay_manager *mgr)\n{\n\tunsigned long flags;\n\tstruct omap_overlay *ovl;\n\tint r;\n\n\tDSSDBG(\"omap_dss_mgr_apply(%s)\\n\", mgr->name);\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tr = dss_check_settings_apply(mgr);\n\tif (r) {\n\t\tspin_unlock_irqrestore(&data_lock, flags);\n\t\tDSSERR(\"failed to apply settings: illegal configuration.\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tlist_for_each_entry(ovl, &mgr->overlays, list)\n\t\tomap_dss_mgr_apply_ovl(ovl);\n\n\t \n\tomap_dss_mgr_apply_mgr(mgr);\n\n\tdss_write_regs();\n\tdss_set_go_bits();\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\treturn 0;\n}\n\nstatic void dss_apply_ovl_enable(struct omap_overlay *ovl, bool enable)\n{\n\tstruct ovl_priv_data *op;\n\n\top = get_ovl_priv(ovl);\n\n\tif (op->enabled == enable)\n\t\treturn;\n\n\top->enabled = enable;\n\top->extra_info_dirty = true;\n}\n\nstatic void dss_apply_ovl_fifo_thresholds(struct omap_overlay *ovl,\n\t\tu32 fifo_low, u32 fifo_high)\n{\n\tstruct ovl_priv_data *op = get_ovl_priv(ovl);\n\n\tif (op->fifo_low == fifo_low && op->fifo_high == fifo_high)\n\t\treturn;\n\n\top->fifo_low = fifo_low;\n\top->fifo_high = fifo_high;\n\top->extra_info_dirty = true;\n}\n\nstatic void dss_ovl_setup_fifo(struct omap_overlay *ovl)\n{\n\tstruct ovl_priv_data *op = get_ovl_priv(ovl);\n\tu32 fifo_low, fifo_high;\n\tbool use_fifo_merge = false;\n\n\tif (!op->enabled && !op->enabling)\n\t\treturn;\n\n\tdispc_ovl_compute_fifo_thresholds(ovl->id, &fifo_low, &fifo_high,\n\t\t\tuse_fifo_merge, ovl_manual_update(ovl));\n\n\tdss_apply_ovl_fifo_thresholds(ovl, fifo_low, fifo_high);\n}\n\nstatic void dss_mgr_setup_fifos(struct omap_overlay_manager *mgr)\n{\n\tstruct omap_overlay *ovl;\n\tstruct mgr_priv_data *mp;\n\n\tmp = get_mgr_priv(mgr);\n\n\tif (!mp->enabled)\n\t\treturn;\n\n\tlist_for_each_entry(ovl, &mgr->overlays, list)\n\t\tdss_ovl_setup_fifo(ovl);\n}\n\nstatic void dss_setup_fifos(void)\n{\n\tconst int num_mgrs = omap_dss_get_num_overlay_managers();\n\tstruct omap_overlay_manager *mgr;\n\tint i;\n\n\tfor (i = 0; i < num_mgrs; ++i) {\n\t\tmgr = omap_dss_get_overlay_manager(i);\n\t\tdss_mgr_setup_fifos(mgr);\n\t}\n}\n\nstatic int dss_mgr_enable_compat(struct omap_overlay_manager *mgr)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\tunsigned long flags;\n\tint r;\n\n\tmutex_lock(&apply_lock);\n\n\tif (mp->enabled)\n\t\tgoto out;\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tmp->enabled = true;\n\n\tr = dss_check_settings(mgr);\n\tif (r) {\n\t\tDSSERR(\"failed to enable manager %d: check_settings failed\\n\",\n\t\t\t\tmgr->id);\n\t\tgoto err;\n\t}\n\n\tdss_setup_fifos();\n\n\tdss_write_regs();\n\tdss_set_go_bits();\n\n\tif (!mgr_manual_update(mgr))\n\t\tmp->updating = true;\n\n\tif (!dss_data.irq_enabled && need_isr())\n\t\tdss_register_vsync_isr();\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\tif (!mgr_manual_update(mgr))\n\t\tdispc_mgr_enable_sync(mgr->id);\n\nout:\n\tmutex_unlock(&apply_lock);\n\n\treturn 0;\n\nerr:\n\tmp->enabled = false;\n\tspin_unlock_irqrestore(&data_lock, flags);\n\tmutex_unlock(&apply_lock);\n\treturn r;\n}\n\nstatic void dss_mgr_disable_compat(struct omap_overlay_manager *mgr)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\tunsigned long flags;\n\n\tmutex_lock(&apply_lock);\n\n\tif (!mp->enabled)\n\t\tgoto out;\n\n\twait_pending_extra_info_updates();\n\n\tif (!mgr_manual_update(mgr))\n\t\tdispc_mgr_disable_sync(mgr->id);\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tmp->updating = false;\n\tmp->enabled = false;\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\nout:\n\tmutex_unlock(&apply_lock);\n}\n\nstatic int dss_mgr_set_info(struct omap_overlay_manager *mgr,\n\t\tstruct omap_overlay_manager_info *info)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\tunsigned long flags;\n\tint r;\n\n\tr = dss_mgr_simple_check(mgr, info);\n\tif (r)\n\t\treturn r;\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tmp->user_info = *info;\n\tmp->user_info_dirty = true;\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\treturn 0;\n}\n\nstatic void dss_mgr_get_info(struct omap_overlay_manager *mgr,\n\t\tstruct omap_overlay_manager_info *info)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\t*info = mp->user_info;\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n}\n\nstatic int dss_mgr_set_output(struct omap_overlay_manager *mgr,\n\t\tstruct omap_dss_device *output)\n{\n\tint r;\n\n\tmutex_lock(&apply_lock);\n\n\tif (mgr->output) {\n\t\tDSSERR(\"manager %s is already connected to an output\\n\",\n\t\t\tmgr->name);\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif ((mgr->supported_outputs & output->id) == 0) {\n\t\tDSSERR(\"output does not support manager %s\\n\",\n\t\t\tmgr->name);\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\toutput->manager = mgr;\n\tmgr->output = output;\n\n\tmutex_unlock(&apply_lock);\n\n\treturn 0;\nerr:\n\tmutex_unlock(&apply_lock);\n\treturn r;\n}\n\nstatic int dss_mgr_unset_output(struct omap_overlay_manager *mgr)\n{\n\tint r;\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\tunsigned long flags;\n\n\tmutex_lock(&apply_lock);\n\n\tif (!mgr->output) {\n\t\tDSSERR(\"failed to unset output, output not set\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tif (mp->enabled) {\n\t\tDSSERR(\"output can't be unset when manager is enabled\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err1;\n\t}\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\tmgr->output->manager = NULL;\n\tmgr->output = NULL;\n\n\tmutex_unlock(&apply_lock);\n\n\treturn 0;\nerr1:\n\tspin_unlock_irqrestore(&data_lock, flags);\nerr:\n\tmutex_unlock(&apply_lock);\n\n\treturn r;\n}\n\nstatic void dss_apply_mgr_timings(struct omap_overlay_manager *mgr,\n\t\tconst struct omap_video_timings *timings)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\n\tmp->timings = *timings;\n\tmp->extra_info_dirty = true;\n}\n\nstatic void dss_mgr_set_timings_compat(struct omap_overlay_manager *mgr,\n\t\tconst struct omap_video_timings *timings)\n{\n\tunsigned long flags;\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tif (mp->updating) {\n\t\tDSSERR(\"cannot set timings for %s: manager needs to be disabled\\n\",\n\t\t\tmgr->name);\n\t\tgoto out;\n\t}\n\n\tdss_apply_mgr_timings(mgr, timings);\nout:\n\tspin_unlock_irqrestore(&data_lock, flags);\n}\n\nstatic void dss_apply_mgr_lcd_config(struct omap_overlay_manager *mgr,\n\t\tconst struct dss_lcd_mgr_config *config)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\n\tmp->lcd_config = *config;\n\tmp->extra_info_dirty = true;\n}\n\nstatic void dss_mgr_set_lcd_config_compat(struct omap_overlay_manager *mgr,\n\t\tconst struct dss_lcd_mgr_config *config)\n{\n\tunsigned long flags;\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tif (mp->enabled) {\n\t\tDSSERR(\"cannot apply lcd config for %s: manager needs to be disabled\\n\",\n\t\t\tmgr->name);\n\t\tgoto out;\n\t}\n\n\tdss_apply_mgr_lcd_config(mgr, config);\nout:\n\tspin_unlock_irqrestore(&data_lock, flags);\n}\n\nstatic int dss_ovl_set_info(struct omap_overlay *ovl,\n\t\tstruct omap_overlay_info *info)\n{\n\tstruct ovl_priv_data *op = get_ovl_priv(ovl);\n\tunsigned long flags;\n\tint r;\n\n\tr = dss_ovl_simple_check(ovl, info);\n\tif (r)\n\t\treturn r;\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\top->user_info = *info;\n\top->user_info_dirty = true;\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\treturn 0;\n}\n\nstatic void dss_ovl_get_info(struct omap_overlay *ovl,\n\t\tstruct omap_overlay_info *info)\n{\n\tstruct ovl_priv_data *op = get_ovl_priv(ovl);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\t*info = op->user_info;\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n}\n\nstatic int dss_ovl_set_manager(struct omap_overlay *ovl,\n\t\tstruct omap_overlay_manager *mgr)\n{\n\tstruct ovl_priv_data *op = get_ovl_priv(ovl);\n\tunsigned long flags;\n\tint r;\n\n\tif (!mgr)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&apply_lock);\n\n\tif (ovl->manager) {\n\t\tDSSERR(\"overlay '%s' already has a manager '%s'\\n\",\n\t\t\t\tovl->name, ovl->manager->name);\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tr = dispc_runtime_get();\n\tif (r)\n\t\tgoto err;\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tif (op->enabled) {\n\t\tspin_unlock_irqrestore(&data_lock, flags);\n\t\tDSSERR(\"overlay has to be disabled to change the manager\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err1;\n\t}\n\n\tdispc_ovl_set_channel_out(ovl->id, mgr->id);\n\n\tovl->manager = mgr;\n\tlist_add_tail(&ovl->list, &mgr->overlays);\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\tdispc_runtime_put();\n\n\tmutex_unlock(&apply_lock);\n\n\treturn 0;\n\nerr1:\n\tdispc_runtime_put();\nerr:\n\tmutex_unlock(&apply_lock);\n\treturn r;\n}\n\nstatic int dss_ovl_unset_manager(struct omap_overlay *ovl)\n{\n\tstruct ovl_priv_data *op = get_ovl_priv(ovl);\n\tunsigned long flags;\n\tint r;\n\n\tmutex_lock(&apply_lock);\n\n\tif (!ovl->manager) {\n\t\tDSSERR(\"failed to detach overlay: manager not set\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tif (op->enabled) {\n\t\tspin_unlock_irqrestore(&data_lock, flags);\n\t\tDSSERR(\"overlay has to be disabled to unset the manager\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\t \n\twait_pending_extra_info_updates();\n\n\t \n\tspin_lock_irqsave(&data_lock, flags);\n\n\tif (ovl_manual_update(ovl) && op->extra_info_dirty) {\n\t\tspin_unlock_irqrestore(&data_lock, flags);\n\t\tDSSERR(\"need an update to change the manager\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tovl->manager = NULL;\n\tlist_del(&ovl->list);\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\tmutex_unlock(&apply_lock);\n\n\treturn 0;\nerr:\n\tmutex_unlock(&apply_lock);\n\treturn r;\n}\n\nstatic bool dss_ovl_is_enabled(struct omap_overlay *ovl)\n{\n\tstruct ovl_priv_data *op = get_ovl_priv(ovl);\n\tunsigned long flags;\n\tbool e;\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\te = op->enabled;\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\treturn e;\n}\n\nstatic int dss_ovl_enable(struct omap_overlay *ovl)\n{\n\tstruct ovl_priv_data *op = get_ovl_priv(ovl);\n\tunsigned long flags;\n\tint r;\n\n\tmutex_lock(&apply_lock);\n\n\tif (op->enabled) {\n\t\tr = 0;\n\t\tgoto err1;\n\t}\n\n\tif (ovl->manager == NULL || ovl->manager->output == NULL) {\n\t\tr = -EINVAL;\n\t\tgoto err1;\n\t}\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\top->enabling = true;\n\n\tr = dss_check_settings(ovl->manager);\n\tif (r) {\n\t\tDSSERR(\"failed to enable overlay %d: check_settings failed\\n\",\n\t\t\t\tovl->id);\n\t\tgoto err2;\n\t}\n\n\tdss_setup_fifos();\n\n\top->enabling = false;\n\tdss_apply_ovl_enable(ovl, true);\n\n\tdss_write_regs();\n\tdss_set_go_bits();\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\tmutex_unlock(&apply_lock);\n\n\treturn 0;\nerr2:\n\top->enabling = false;\n\tspin_unlock_irqrestore(&data_lock, flags);\nerr1:\n\tmutex_unlock(&apply_lock);\n\treturn r;\n}\n\nstatic int dss_ovl_disable(struct omap_overlay *ovl)\n{\n\tstruct ovl_priv_data *op = get_ovl_priv(ovl);\n\tunsigned long flags;\n\tint r;\n\n\tmutex_lock(&apply_lock);\n\n\tif (!op->enabled) {\n\t\tr = 0;\n\t\tgoto err;\n\t}\n\n\tif (ovl->manager == NULL || ovl->manager->output == NULL) {\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irqsave(&data_lock, flags);\n\n\tdss_apply_ovl_enable(ovl, false);\n\tdss_write_regs();\n\tdss_set_go_bits();\n\n\tspin_unlock_irqrestore(&data_lock, flags);\n\n\tmutex_unlock(&apply_lock);\n\n\treturn 0;\n\nerr:\n\tmutex_unlock(&apply_lock);\n\treturn r;\n}\n\nstatic int dss_mgr_register_framedone_handler_compat(struct omap_overlay_manager *mgr,\n\t\tvoid (*handler)(void *), void *data)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\n\tif (mp->framedone_handler)\n\t\treturn -EBUSY;\n\n\tmp->framedone_handler = handler;\n\tmp->framedone_handler_data = data;\n\n\treturn 0;\n}\n\nstatic void dss_mgr_unregister_framedone_handler_compat(struct omap_overlay_manager *mgr,\n\t\tvoid (*handler)(void *), void *data)\n{\n\tstruct mgr_priv_data *mp = get_mgr_priv(mgr);\n\n\tWARN_ON(mp->framedone_handler != handler ||\n\t\t\tmp->framedone_handler_data != data);\n\n\tmp->framedone_handler = NULL;\n\tmp->framedone_handler_data = NULL;\n}\n\nstatic const struct dss_mgr_ops apply_mgr_ops = {\n\t.connect = dss_mgr_connect_compat,\n\t.disconnect = dss_mgr_disconnect_compat,\n\t.start_update = dss_mgr_start_update_compat,\n\t.enable = dss_mgr_enable_compat,\n\t.disable = dss_mgr_disable_compat,\n\t.set_timings = dss_mgr_set_timings_compat,\n\t.set_lcd_config = dss_mgr_set_lcd_config_compat,\n\t.register_framedone_handler = dss_mgr_register_framedone_handler_compat,\n\t.unregister_framedone_handler = dss_mgr_unregister_framedone_handler_compat,\n};\n\nstatic int compat_refcnt;\nstatic DEFINE_MUTEX(compat_init_lock);\n\nint omapdss_compat_init(void)\n{\n\tstruct platform_device *pdev = dss_get_core_pdev();\n\tint i, r;\n\n\tmutex_lock(&compat_init_lock);\n\n\tif (compat_refcnt++ > 0)\n\t\tgoto out;\n\n\tapply_init_priv();\n\n\tdss_init_overlay_managers_sysfs(pdev);\n\tdss_init_overlays(pdev);\n\n\tfor (i = 0; i < omap_dss_get_num_overlay_managers(); i++) {\n\t\tstruct omap_overlay_manager *mgr;\n\n\t\tmgr = omap_dss_get_overlay_manager(i);\n\n\t\tmgr->set_output = &dss_mgr_set_output;\n\t\tmgr->unset_output = &dss_mgr_unset_output;\n\t\tmgr->apply = &omap_dss_mgr_apply;\n\t\tmgr->set_manager_info = &dss_mgr_set_info;\n\t\tmgr->get_manager_info = &dss_mgr_get_info;\n\t\tmgr->wait_for_go = &dss_mgr_wait_for_go;\n\t\tmgr->wait_for_vsync = &dss_mgr_wait_for_vsync;\n\t\tmgr->get_device = &dss_mgr_get_device;\n\t}\n\n\tfor (i = 0; i < omap_dss_get_num_overlays(); i++) {\n\t\tstruct omap_overlay *ovl = omap_dss_get_overlay(i);\n\n\t\tovl->is_enabled = &dss_ovl_is_enabled;\n\t\tovl->enable = &dss_ovl_enable;\n\t\tovl->disable = &dss_ovl_disable;\n\t\tovl->set_manager = &dss_ovl_set_manager;\n\t\tovl->unset_manager = &dss_ovl_unset_manager;\n\t\tovl->set_overlay_info = &dss_ovl_set_info;\n\t\tovl->get_overlay_info = &dss_ovl_get_info;\n\t\tovl->wait_for_go = &dss_mgr_wait_for_go_ovl;\n\t\tovl->get_device = &dss_ovl_get_device;\n\t}\n\n\tr = dss_install_mgr_ops(&apply_mgr_ops);\n\tif (r)\n\t\tgoto err_mgr_ops;\n\n\tr = display_init_sysfs(pdev);\n\tif (r)\n\t\tgoto err_disp_sysfs;\n\n\tdispc_runtime_get();\n\n\tr = dss_dispc_initialize_irq();\n\tif (r)\n\t\tgoto err_init_irq;\n\n\tdispc_runtime_put();\n\nout:\n\tmutex_unlock(&compat_init_lock);\n\n\treturn 0;\n\nerr_init_irq:\n\tdispc_runtime_put();\n\tdisplay_uninit_sysfs(pdev);\n\nerr_disp_sysfs:\n\tdss_uninstall_mgr_ops();\n\nerr_mgr_ops:\n\tdss_uninit_overlay_managers_sysfs(pdev);\n\tdss_uninit_overlays(pdev);\n\n\tcompat_refcnt--;\n\n\tmutex_unlock(&compat_init_lock);\n\n\treturn r;\n}\nEXPORT_SYMBOL(omapdss_compat_init);\n\nvoid omapdss_compat_uninit(void)\n{\n\tstruct platform_device *pdev = dss_get_core_pdev();\n\n\tmutex_lock(&compat_init_lock);\n\n\tif (--compat_refcnt > 0)\n\t\tgoto out;\n\n\tdss_dispc_uninitialize_irq();\n\n\tdisplay_uninit_sysfs(pdev);\n\n\tdss_uninstall_mgr_ops();\n\n\tdss_uninit_overlay_managers_sysfs(pdev);\n\tdss_uninit_overlays(pdev);\nout:\n\tmutex_unlock(&compat_init_lock);\n}\nEXPORT_SYMBOL(omapdss_compat_uninit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}