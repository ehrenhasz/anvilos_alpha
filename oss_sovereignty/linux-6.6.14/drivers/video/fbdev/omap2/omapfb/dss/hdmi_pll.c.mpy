{
  "module_name": "hdmi_pll.c",
  "hash_id": "1bd58612a01e285d32e2a952b732da668878eed559f81c37ab8d934c466a54ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/hdmi_pll.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"HDMIPLL\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/seq_file.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"hdmi.h\"\n\nvoid hdmi_pll_dump(struct hdmi_pll_data *pll, struct seq_file *s)\n{\n#define DUMPPLL(r) seq_printf(s, \"%-35s %08x\\n\", #r,\\\n\t\thdmi_read_reg(pll->base, r))\n\n\tDUMPPLL(PLLCTRL_PLL_CONTROL);\n\tDUMPPLL(PLLCTRL_PLL_STATUS);\n\tDUMPPLL(PLLCTRL_PLL_GO);\n\tDUMPPLL(PLLCTRL_CFG1);\n\tDUMPPLL(PLLCTRL_CFG2);\n\tDUMPPLL(PLLCTRL_CFG3);\n\tDUMPPLL(PLLCTRL_SSC_CFG1);\n\tDUMPPLL(PLLCTRL_SSC_CFG2);\n\tDUMPPLL(PLLCTRL_CFG4);\n}\n\nvoid hdmi_pll_compute(struct hdmi_pll_data *pll,\n\tunsigned long target_tmds, struct dss_pll_clock_info *pi)\n{\n\tunsigned long fint, clkdco, clkout;\n\tunsigned long target_bitclk, target_clkdco;\n\tunsigned long min_dco;\n\tunsigned n, m, mf, m2, sd;\n\tunsigned long clkin;\n\tconst struct dss_pll_hw *hw = pll->pll.hw;\n\n\tclkin = clk_get_rate(pll->pll.clkin);\n\n\tDSSDBG(\"clkin %lu, target tmds %lu\\n\", clkin, target_tmds);\n\n\ttarget_bitclk = target_tmds * 10;\n\n\t \n\tn = DIV_ROUND_UP(clkin, hw->fint_max);\n\tfint = clkin / n;\n\n\t \n\tmin_dco = roundup(hw->clkdco_min, fint);\n\tm2 = DIV_ROUND_UP(min_dco, target_bitclk);\n\tif (m2 == 0)\n\t\tm2 = 1;\n\n\ttarget_clkdco = target_bitclk * m2;\n\tm = target_clkdco / fint;\n\n\tclkdco = fint * m;\n\n\t \n\tif (WARN_ON(target_clkdco - clkdco > fint))\n\t\tmf = 0;\n\telse\n\t\tmf = (u32)div_u64(262144ull * (target_clkdco - clkdco), fint);\n\n\tif (mf > 0)\n\t\tclkdco += (u32)div_u64((u64)mf * fint, 262144);\n\n\tclkout = clkdco / m2;\n\n\t \n\tsd = DIV_ROUND_UP(fint * m, 250000000);\n\n\tDSSDBG(\"N = %u, M = %u, M.f = %u, M2 = %u, SD = %u\\n\",\n\t\tn, m, mf, m2, sd);\n\tDSSDBG(\"Fint %lu, clkdco %lu, clkout %lu\\n\", fint, clkdco, clkout);\n\n\tpi->n = n;\n\tpi->m = m;\n\tpi->mf = mf;\n\tpi->mX[0] = m2;\n\tpi->sd = sd;\n\n\tpi->fint = fint;\n\tpi->clkdco = clkdco;\n\tpi->clkout[0] = clkout;\n}\n\nstatic int hdmi_pll_enable(struct dss_pll *dsspll)\n{\n\tstruct hdmi_pll_data *pll = container_of(dsspll, struct hdmi_pll_data, pll);\n\tstruct hdmi_wp_data *wp = pll->wp;\n\n\tdss_ctrl_pll_enable(DSS_PLL_HDMI, true);\n\n\treturn hdmi_wp_set_pll_pwr(wp, HDMI_PLLPWRCMD_BOTHON_ALLCLKS);\n}\n\nstatic void hdmi_pll_disable(struct dss_pll *dsspll)\n{\n\tstruct hdmi_pll_data *pll = container_of(dsspll, struct hdmi_pll_data, pll);\n\tstruct hdmi_wp_data *wp = pll->wp;\n\n\thdmi_wp_set_pll_pwr(wp, HDMI_PLLPWRCMD_ALLOFF);\n\n\tdss_ctrl_pll_enable(DSS_PLL_HDMI, false);\n}\n\nstatic const struct dss_pll_ops dsi_pll_ops = {\n\t.enable = hdmi_pll_enable,\n\t.disable = hdmi_pll_disable,\n\t.set_config = dss_pll_write_config_type_b,\n};\n\nstatic const struct dss_pll_hw dss_omap4_hdmi_pll_hw = {\n\t.n_max = 255,\n\t.m_min = 20,\n\t.m_max = 4095,\n\t.mX_max = 127,\n\t.fint_min = 500000,\n\t.fint_max = 2500000,\n\n\t.clkdco_min = 500000000,\n\t.clkdco_low = 1000000000,\n\t.clkdco_max = 2000000000,\n\n\t.n_msb = 8,\n\t.n_lsb = 1,\n\t.m_msb = 20,\n\t.m_lsb = 9,\n\n\t.mX_msb[0] = 24,\n\t.mX_lsb[0] = 18,\n\n\t.has_selfreqdco = true,\n};\n\nstatic const struct dss_pll_hw dss_omap5_hdmi_pll_hw = {\n\t.n_max = 255,\n\t.m_min = 20,\n\t.m_max = 2045,\n\t.mX_max = 127,\n\t.fint_min = 620000,\n\t.fint_max = 2500000,\n\n\t.clkdco_min = 750000000,\n\t.clkdco_low = 1500000000,\n\t.clkdco_max = 2500000000UL,\n\n\t.n_msb = 8,\n\t.n_lsb = 1,\n\t.m_msb = 20,\n\t.m_lsb = 9,\n\n\t.mX_msb[0] = 24,\n\t.mX_lsb[0] = 18,\n\n\t.has_selfreqdco = true,\n\t.has_refsel = true,\n};\n\nstatic int dsi_init_pll_data(struct platform_device *pdev, struct hdmi_pll_data *hpll)\n{\n\tstruct dss_pll *pll = &hpll->pll;\n\tstruct clk *clk;\n\n\tclk = devm_clk_get(&pdev->dev, \"sys_clk\");\n\tif (IS_ERR(clk)) {\n\t\tDSSERR(\"can't get sys_clk\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tpll->name = \"hdmi\";\n\tpll->id = DSS_PLL_HDMI;\n\tpll->base = hpll->base;\n\tpll->clkin = clk;\n\n\tswitch (omapdss_get_version()) {\n\tcase OMAPDSS_VER_OMAP4430_ES1:\n\tcase OMAPDSS_VER_OMAP4430_ES2:\n\tcase OMAPDSS_VER_OMAP4:\n\t\tpll->hw = &dss_omap4_hdmi_pll_hw;\n\t\tbreak;\n\n\tcase OMAPDSS_VER_OMAP5:\n\tcase OMAPDSS_VER_DRA7xx:\n\t\tpll->hw = &dss_omap5_hdmi_pll_hw;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tpll->ops = &dsi_pll_ops;\n\treturn dss_pll_register(pll);\n}\n\nint hdmi_pll_init(struct platform_device *pdev, struct hdmi_pll_data *pll,\n\tstruct hdmi_wp_data *wp)\n{\n\tint r;\n\n\tpll->wp = wp;\n\n\tpll->base = devm_platform_ioremap_resource_byname(pdev, \"pll\");\n\tif (IS_ERR(pll->base)) {\n\t\tDSSERR(\"can't ioremap PLLCTRL\\n\");\n\t\treturn PTR_ERR(pll->base);\n\t}\n\n\tr = dsi_init_pll_data(pdev, pll);\n\tif (r) {\n\t\tDSSERR(\"failed to init HDMI PLL\\n\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nvoid hdmi_pll_uninit(struct hdmi_pll_data *hpll)\n{\n\tstruct dss_pll *pll = &hpll->pll;\n\n\tdss_pll_unregister(pll);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}