{
  "module_name": "dss.c",
  "hash_id": "88e56e8be5f6c7a431f077f936b9b5646511f3f34cdfe897b17e2ea74ff8f5fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/dss.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"DSS\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/seq_file.h>\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/gfp.h>\n#include <linux/sizes.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/suspend.h>\n#include <linux/component.h>\n#include <linux/pinctrl/consumer.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"dss_features.h\"\n\n#define DSS_SZ_REGS\t\t\tSZ_512\n\nstruct dss_reg {\n\tu16 idx;\n};\n\n#define DSS_REG(idx)\t\t\t((const struct dss_reg) { idx })\n\n#define DSS_REVISION\t\t\tDSS_REG(0x0000)\n#define DSS_SYSCONFIG\t\t\tDSS_REG(0x0010)\n#define DSS_SYSSTATUS\t\t\tDSS_REG(0x0014)\n#define DSS_CONTROL\t\t\tDSS_REG(0x0040)\n#define DSS_SDI_CONTROL\t\t\tDSS_REG(0x0044)\n#define DSS_PLL_CONTROL\t\t\tDSS_REG(0x0048)\n#define DSS_SDI_STATUS\t\t\tDSS_REG(0x005C)\n\n#define REG_GET(idx, start, end) \\\n\tFLD_GET(dss_read_reg(idx), start, end)\n\n#define REG_FLD_MOD(idx, val, start, end) \\\n\tdss_write_reg(idx, FLD_MOD(dss_read_reg(idx), val, start, end))\n\nstruct dss_features {\n\tu8 fck_div_max;\n\tu8 dss_fck_multiplier;\n\tconst char *parent_clk_name;\n\tconst enum omap_display_type *ports;\n\tint num_ports;\n\tint (*dpi_select_source)(int port, enum omap_channel channel);\n};\n\nstatic struct {\n\tstruct platform_device *pdev;\n\tvoid __iomem    *base;\n\tstruct regmap\t*syscon_pll_ctrl;\n\tu32\t\tsyscon_pll_ctrl_offset;\n\n\tstruct clk\t*parent_clk;\n\tstruct clk\t*dss_clk;\n\tunsigned long\tdss_clk_rate;\n\n\tunsigned long\tcache_req_pck;\n\tunsigned long\tcache_prate;\n\tstruct dispc_clock_info cache_dispc_cinfo;\n\n\tenum omap_dss_clk_source dsi_clk_source[MAX_NUM_DSI];\n\tenum omap_dss_clk_source dispc_clk_source;\n\tenum omap_dss_clk_source lcd_clk_source[MAX_DSS_LCD_MANAGERS];\n\n\tbool\t\tctx_valid;\n\tu32\t\tctx[DSS_SZ_REGS / sizeof(u32)];\n\n\tconst struct dss_features *feat;\n\n\tstruct dss_pll\t*video1_pll;\n\tstruct dss_pll\t*video2_pll;\n} dss;\n\nstatic const char * const dss_generic_clk_source_names[] = {\n\t[OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC]\t= \"DSI_PLL_HSDIV_DISPC\",\n\t[OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI]\t= \"DSI_PLL_HSDIV_DSI\",\n\t[OMAP_DSS_CLK_SRC_FCK]\t\t\t= \"DSS_FCK\",\n\t[OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC]\t= \"DSI_PLL2_HSDIV_DISPC\",\n\t[OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI]\t= \"DSI_PLL2_HSDIV_DSI\",\n};\n\nstatic bool dss_initialized;\n\nbool omapdss_is_initialized(void)\n{\n\treturn dss_initialized;\n}\nEXPORT_SYMBOL(omapdss_is_initialized);\n\nstatic inline void dss_write_reg(const struct dss_reg idx, u32 val)\n{\n\t__raw_writel(val, dss.base + idx.idx);\n}\n\nstatic inline u32 dss_read_reg(const struct dss_reg idx)\n{\n\treturn __raw_readl(dss.base + idx.idx);\n}\n\n#define SR(reg) \\\n\tdss.ctx[(DSS_##reg).idx / sizeof(u32)] = dss_read_reg(DSS_##reg)\n#define RR(reg) \\\n\tdss_write_reg(DSS_##reg, dss.ctx[(DSS_##reg).idx / sizeof(u32)])\n\nstatic void dss_save_context(void)\n{\n\tDSSDBG(\"dss_save_context\\n\");\n\n\tSR(CONTROL);\n\n\tif (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &\n\t\t\tOMAP_DISPLAY_TYPE_SDI) {\n\t\tSR(SDI_CONTROL);\n\t\tSR(PLL_CONTROL);\n\t}\n\n\tdss.ctx_valid = true;\n\n\tDSSDBG(\"context saved\\n\");\n}\n\nstatic void dss_restore_context(void)\n{\n\tDSSDBG(\"dss_restore_context\\n\");\n\n\tif (!dss.ctx_valid)\n\t\treturn;\n\n\tRR(CONTROL);\n\n\tif (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &\n\t\t\tOMAP_DISPLAY_TYPE_SDI) {\n\t\tRR(SDI_CONTROL);\n\t\tRR(PLL_CONTROL);\n\t}\n\n\tDSSDBG(\"context restored\\n\");\n}\n\n#undef SR\n#undef RR\n\nvoid dss_ctrl_pll_enable(enum dss_pll_id pll_id, bool enable)\n{\n\tunsigned shift;\n\tunsigned val;\n\n\tif (!dss.syscon_pll_ctrl)\n\t\treturn;\n\n\tval = !enable;\n\n\tswitch (pll_id) {\n\tcase DSS_PLL_VIDEO1:\n\t\tshift = 0;\n\t\tbreak;\n\tcase DSS_PLL_VIDEO2:\n\t\tshift = 1;\n\t\tbreak;\n\tcase DSS_PLL_HDMI:\n\t\tshift = 2;\n\t\tbreak;\n\tdefault:\n\t\tDSSERR(\"illegal DSS PLL ID %d\\n\", pll_id);\n\t\treturn;\n\t}\n\n\tregmap_update_bits(dss.syscon_pll_ctrl, dss.syscon_pll_ctrl_offset,\n\t\t1 << shift, val << shift);\n}\n\nvoid dss_ctrl_pll_set_control_mux(enum dss_pll_id pll_id,\n\tenum omap_channel channel)\n{\n\tunsigned shift, val;\n\n\tif (!dss.syscon_pll_ctrl)\n\t\treturn;\n\n\tswitch (channel) {\n\tcase OMAP_DSS_CHANNEL_LCD:\n\t\tshift = 3;\n\n\t\tswitch (pll_id) {\n\t\tcase DSS_PLL_VIDEO1:\n\t\t\tval = 0; break;\n\t\tcase DSS_PLL_HDMI:\n\t\t\tval = 1; break;\n\t\tdefault:\n\t\t\tDSSERR(\"error in PLL mux config for LCD\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\tshift = 5;\n\n\t\tswitch (pll_id) {\n\t\tcase DSS_PLL_VIDEO1:\n\t\t\tval = 0; break;\n\t\tcase DSS_PLL_VIDEO2:\n\t\t\tval = 1; break;\n\t\tcase DSS_PLL_HDMI:\n\t\t\tval = 2; break;\n\t\tdefault:\n\t\t\tDSSERR(\"error in PLL mux config for LCD2\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\tcase OMAP_DSS_CHANNEL_LCD3:\n\t\tshift = 7;\n\n\t\tswitch (pll_id) {\n\t\tcase DSS_PLL_VIDEO1:\n\t\t\tval = 1; break;\n\t\tcase DSS_PLL_VIDEO2:\n\t\t\tval = 0; break;\n\t\tcase DSS_PLL_HDMI:\n\t\t\tval = 2; break;\n\t\tdefault:\n\t\t\tDSSERR(\"error in PLL mux config for LCD3\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tDSSERR(\"error in PLL mux config\\n\");\n\t\treturn;\n\t}\n\n\tregmap_update_bits(dss.syscon_pll_ctrl, dss.syscon_pll_ctrl_offset,\n\t\t0x3 << shift, val << shift);\n}\n\nvoid dss_sdi_init(int datapairs)\n{\n\tu32 l;\n\n\tBUG_ON(datapairs > 3 || datapairs < 1);\n\n\tl = dss_read_reg(DSS_SDI_CONTROL);\n\tl = FLD_MOD(l, 0xf, 19, 15);\t\t \n\tl = FLD_MOD(l, datapairs-1, 3, 2);\t \n\tl = FLD_MOD(l, 2, 1, 0);\t\t \n\tdss_write_reg(DSS_SDI_CONTROL, l);\n\n\tl = dss_read_reg(DSS_PLL_CONTROL);\n\tl = FLD_MOD(l, 0x7, 25, 22);\t \n\tl = FLD_MOD(l, 0xb, 16, 11);\t \n\tl = FLD_MOD(l, 0xb4, 10, 1);\t \n\tdss_write_reg(DSS_PLL_CONTROL, l);\n}\n\nint dss_sdi_enable(void)\n{\n\tunsigned long timeout;\n\n\tdispc_pck_free_enable(1);\n\n\t \n\tREG_FLD_MOD(DSS_PLL_CONTROL, 1, 18, 18);  \n\tudelay(1);\t \n\n\t \n\tREG_FLD_MOD(DSS_PLL_CONTROL, 1, 28, 28);  \n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile (dss_read_reg(DSS_SDI_STATUS) & (1 << 6)) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tDSSERR(\"PLL lock request timed out\\n\");\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\t \n\tREG_FLD_MOD(DSS_PLL_CONTROL, 0, 28, 28);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 5))) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tDSSERR(\"PLL lock timed out\\n\");\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tdispc_lcd_enable_signal(1);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 2))) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tDSSERR(\"SDI reset timed out\\n\");\n\t\t\tgoto err2;\n\t\t}\n\t}\n\n\treturn 0;\n\n err2:\n\tdispc_lcd_enable_signal(0);\n err1:\n\t \n\tREG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18);  \n\n\tdispc_pck_free_enable(0);\n\n\treturn -ETIMEDOUT;\n}\n\nvoid dss_sdi_disable(void)\n{\n\tdispc_lcd_enable_signal(0);\n\n\tdispc_pck_free_enable(0);\n\n\t \n\tREG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18);  \n}\n\nconst char *dss_get_generic_clk_source_name(enum omap_dss_clk_source clk_src)\n{\n\treturn dss_generic_clk_source_names[clk_src];\n}\n\nvoid dss_dump_clocks(struct seq_file *s)\n{\n\tconst char *fclk_name, *fclk_real_name;\n\tunsigned long fclk_rate;\n\n\tif (dss_runtime_get())\n\t\treturn;\n\n\tseq_printf(s, \"- DSS -\\n\");\n\n\tfclk_name = dss_get_generic_clk_source_name(OMAP_DSS_CLK_SRC_FCK);\n\tfclk_real_name = dss_feat_get_clk_source_name(OMAP_DSS_CLK_SRC_FCK);\n\tfclk_rate = clk_get_rate(dss.dss_clk);\n\n\tseq_printf(s, \"%s (%s) = %lu\\n\",\n\t\t\tfclk_name, fclk_real_name,\n\t\t\tfclk_rate);\n\n\tdss_runtime_put();\n}\n\nstatic void dss_dump_regs(struct seq_file *s)\n{\n#define DUMPREG(r) seq_printf(s, \"%-35s %08x\\n\", #r, dss_read_reg(r))\n\n\tif (dss_runtime_get())\n\t\treturn;\n\n\tDUMPREG(DSS_REVISION);\n\tDUMPREG(DSS_SYSCONFIG);\n\tDUMPREG(DSS_SYSSTATUS);\n\tDUMPREG(DSS_CONTROL);\n\n\tif (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &\n\t\t\tOMAP_DISPLAY_TYPE_SDI) {\n\t\tDUMPREG(DSS_SDI_CONTROL);\n\t\tDUMPREG(DSS_PLL_CONTROL);\n\t\tDUMPREG(DSS_SDI_STATUS);\n\t}\n\n\tdss_runtime_put();\n#undef DUMPREG\n}\n\nstatic void dss_select_dispc_clk_source(enum omap_dss_clk_source clk_src)\n{\n\tint b;\n\tu8 start, end;\n\n\tswitch (clk_src) {\n\tcase OMAP_DSS_CLK_SRC_FCK:\n\t\tb = 0;\n\t\tbreak;\n\tcase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:\n\t\tb = 1;\n\t\tbreak;\n\tcase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:\n\t\tb = 2;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tdss_feat_get_reg_field(FEAT_REG_DISPC_CLK_SWITCH, &start, &end);\n\n\tREG_FLD_MOD(DSS_CONTROL, b, start, end);\t \n\n\tdss.dispc_clk_source = clk_src;\n}\n\nvoid dss_select_dsi_clk_source(int dsi_module,\n\t\tenum omap_dss_clk_source clk_src)\n{\n\tint b, pos;\n\n\tswitch (clk_src) {\n\tcase OMAP_DSS_CLK_SRC_FCK:\n\t\tb = 0;\n\t\tbreak;\n\tcase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI:\n\t\tBUG_ON(dsi_module != 0);\n\t\tb = 1;\n\t\tbreak;\n\tcase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI:\n\t\tBUG_ON(dsi_module != 1);\n\t\tb = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tpos = dsi_module == 0 ? 1 : 10;\n\tREG_FLD_MOD(DSS_CONTROL, b, pos, pos);\t \n\n\tdss.dsi_clk_source[dsi_module] = clk_src;\n}\n\nvoid dss_select_lcd_clk_source(enum omap_channel channel,\n\t\tenum omap_dss_clk_source clk_src)\n{\n\tint b, ix, pos;\n\n\tif (!dss_has_feature(FEAT_LCD_CLK_SRC)) {\n\t\tdss_select_dispc_clk_source(clk_src);\n\t\treturn;\n\t}\n\n\tswitch (clk_src) {\n\tcase OMAP_DSS_CLK_SRC_FCK:\n\t\tb = 0;\n\t\tbreak;\n\tcase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:\n\t\tBUG_ON(channel != OMAP_DSS_CHANNEL_LCD);\n\t\tb = 1;\n\t\tbreak;\n\tcase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:\n\t\tBUG_ON(channel != OMAP_DSS_CHANNEL_LCD2 &&\n\t\t       channel != OMAP_DSS_CHANNEL_LCD3);\n\t\tb = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tpos = channel == OMAP_DSS_CHANNEL_LCD ? 0 :\n\t     (channel == OMAP_DSS_CHANNEL_LCD2 ? 12 : 19);\n\tREG_FLD_MOD(DSS_CONTROL, b, pos, pos);\t \n\n\tix = channel == OMAP_DSS_CHANNEL_LCD ? 0 :\n\t    (channel == OMAP_DSS_CHANNEL_LCD2 ? 1 : 2);\n\tdss.lcd_clk_source[ix] = clk_src;\n}\n\nenum omap_dss_clk_source dss_get_dispc_clk_source(void)\n{\n\treturn dss.dispc_clk_source;\n}\n\nenum omap_dss_clk_source dss_get_dsi_clk_source(int dsi_module)\n{\n\treturn dss.dsi_clk_source[dsi_module];\n}\n\nenum omap_dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel)\n{\n\tif (dss_has_feature(FEAT_LCD_CLK_SRC)) {\n\t\tint ix = channel == OMAP_DSS_CHANNEL_LCD ? 0 :\n\t\t\t(channel == OMAP_DSS_CHANNEL_LCD2 ? 1 : 2);\n\t\treturn dss.lcd_clk_source[ix];\n\t} else {\n\t\t \n\t\treturn dss.dispc_clk_source;\n\t}\n}\n\nbool dss_div_calc(unsigned long pck, unsigned long fck_min,\n\t\tdss_div_calc_func func, void *data)\n{\n\tint fckd, fckd_start, fckd_stop;\n\tunsigned long fck;\n\tunsigned long fck_hw_max;\n\tunsigned long fckd_hw_max;\n\tunsigned long prate;\n\tunsigned m;\n\n\tfck_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n\n\tif (dss.parent_clk == NULL) {\n\t\tunsigned pckd;\n\n\t\tpckd = fck_hw_max / pck;\n\n\t\tfck = pck * pckd;\n\n\t\tfck = clk_round_rate(dss.dss_clk, fck);\n\n\t\treturn func(fck, data);\n\t}\n\n\tfckd_hw_max = dss.feat->fck_div_max;\n\n\tm = dss.feat->dss_fck_multiplier;\n\tprate = clk_get_rate(dss.parent_clk);\n\n\tfck_min = fck_min ? fck_min : 1;\n\n\tfckd_start = min(prate * m / fck_min, fckd_hw_max);\n\tfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\n\n\tfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\n\t\tfck = DIV_ROUND_UP(prate, fckd) * m;\n\n\t\tif (func(fck, data))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint dss_set_fck_rate(unsigned long rate)\n{\n\tint r;\n\n\tDSSDBG(\"set fck to %lu\\n\", rate);\n\n\tr = clk_set_rate(dss.dss_clk, rate);\n\tif (r)\n\t\treturn r;\n\n\tdss.dss_clk_rate = clk_get_rate(dss.dss_clk);\n\n\tWARN_ONCE(dss.dss_clk_rate != rate,\n\t\t\t\"clk rate mismatch: %lu != %lu\", dss.dss_clk_rate,\n\t\t\trate);\n\n\treturn 0;\n}\n\nunsigned long dss_get_dispc_clk_rate(void)\n{\n\treturn dss.dss_clk_rate;\n}\n\nstatic int dss_setup_default_clock(void)\n{\n\tunsigned long max_dss_fck, prate;\n\tunsigned long fck;\n\tunsigned fck_div;\n\tint r;\n\n\tmax_dss_fck = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n\n\tif (dss.parent_clk == NULL) {\n\t\tfck = clk_round_rate(dss.dss_clk, max_dss_fck);\n\t} else {\n\t\tprate = clk_get_rate(dss.parent_clk);\n\n\t\tfck_div = DIV_ROUND_UP(prate * dss.feat->dss_fck_multiplier,\n\t\t\t\tmax_dss_fck);\n\t\tfck = DIV_ROUND_UP(prate, fck_div) * dss.feat->dss_fck_multiplier;\n\t}\n\n\tr = dss_set_fck_rate(fck);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nvoid dss_set_venc_output(enum omap_dss_venc_type type)\n{\n\tint l = 0;\n\n\tif (type == OMAP_DSS_VENC_TYPE_COMPOSITE)\n\t\tl = 0;\n\telse if (type == OMAP_DSS_VENC_TYPE_SVIDEO)\n\t\tl = 1;\n\telse\n\t\tBUG();\n\n\t \n\tREG_FLD_MOD(DSS_CONTROL, l, 6, 6);\n}\n\nvoid dss_set_dac_pwrdn_bgz(bool enable)\n{\n\tREG_FLD_MOD(DSS_CONTROL, enable, 5, 5);\t \n}\n\nvoid dss_select_hdmi_venc_clk_source(enum dss_hdmi_venc_clk_source_select src)\n{\n\tenum omap_display_type dp;\n\tdp = dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_DIGIT);\n\n\t \n\tWARN_ON((src == DSS_VENC_TV_CLK) && !(dp & OMAP_DISPLAY_TYPE_VENC));\n\tWARN_ON((src == DSS_HDMI_M_PCLK) && !(dp & OMAP_DISPLAY_TYPE_HDMI));\n\n\t \n\tif ((dp & OMAP_DISPLAY_TYPE_VENC) && (dp & OMAP_DISPLAY_TYPE_HDMI))\n\t\tREG_FLD_MOD(DSS_CONTROL, src, 15, 15);\t \n}\n\nenum dss_hdmi_venc_clk_source_select dss_get_hdmi_venc_clk_source(void)\n{\n\tenum omap_display_type displays;\n\n\tdisplays = dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_DIGIT);\n\tif ((displays & OMAP_DISPLAY_TYPE_HDMI) == 0)\n\t\treturn DSS_VENC_TV_CLK;\n\n\tif ((displays & OMAP_DISPLAY_TYPE_VENC) == 0)\n\t\treturn DSS_HDMI_M_PCLK;\n\n\treturn REG_GET(DSS_CONTROL, 15, 15);\n}\n\nstatic int dss_dpi_select_source_omap2_omap3(int port, enum omap_channel channel)\n{\n\tif (channel != OMAP_DSS_CHANNEL_LCD)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int dss_dpi_select_source_omap4(int port, enum omap_channel channel)\n{\n\tint val;\n\n\tswitch (channel) {\n\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\tval = 0;\n\t\tbreak;\n\tcase OMAP_DSS_CHANNEL_DIGIT:\n\t\tval = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tREG_FLD_MOD(DSS_CONTROL, val, 17, 17);\n\n\treturn 0;\n}\n\nstatic int dss_dpi_select_source_omap5(int port, enum omap_channel channel)\n{\n\tint val;\n\n\tswitch (channel) {\n\tcase OMAP_DSS_CHANNEL_LCD:\n\t\tval = 1;\n\t\tbreak;\n\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\tval = 2;\n\t\tbreak;\n\tcase OMAP_DSS_CHANNEL_LCD3:\n\t\tval = 3;\n\t\tbreak;\n\tcase OMAP_DSS_CHANNEL_DIGIT:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tREG_FLD_MOD(DSS_CONTROL, val, 17, 16);\n\n\treturn 0;\n}\n\nstatic int dss_dpi_select_source_dra7xx(int port, enum omap_channel channel)\n{\n\tswitch (port) {\n\tcase 0:\n\t\treturn dss_dpi_select_source_omap5(port, channel);\n\tcase 1:\n\t\tif (channel != OMAP_DSS_CHANNEL_LCD2)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase 2:\n\t\tif (channel != OMAP_DSS_CHANNEL_LCD3)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint dss_dpi_select_source(int port, enum omap_channel channel)\n{\n\treturn dss.feat->dpi_select_source(port, channel);\n}\n\nstatic int dss_get_clocks(void)\n{\n\tstruct clk *clk;\n\n\tclk = devm_clk_get(&dss.pdev->dev, \"fck\");\n\tif (IS_ERR(clk)) {\n\t\tDSSERR(\"can't get clock fck\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tdss.dss_clk = clk;\n\n\tif (dss.feat->parent_clk_name) {\n\t\tclk = clk_get(NULL, dss.feat->parent_clk_name);\n\t\tif (IS_ERR(clk)) {\n\t\t\tDSSERR(\"Failed to get %s\\n\", dss.feat->parent_clk_name);\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\t} else {\n\t\tclk = NULL;\n\t}\n\n\tdss.parent_clk = clk;\n\n\treturn 0;\n}\n\nstatic void dss_put_clocks(void)\n{\n\tif (dss.parent_clk)\n\t\tclk_put(dss.parent_clk);\n}\n\nint dss_runtime_get(void)\n{\n\tint r;\n\n\tDSSDBG(\"dss_runtime_get\\n\");\n\n\tr = pm_runtime_resume_and_get(&dss.pdev->dev);\n\tif (WARN_ON(r < 0))\n\t\treturn r;\n\treturn 0;\n}\n\nvoid dss_runtime_put(void)\n{\n\tint r;\n\n\tDSSDBG(\"dss_runtime_put\\n\");\n\n\tr = pm_runtime_put_sync(&dss.pdev->dev);\n\tWARN_ON(r < 0 && r != -ENOSYS && r != -EBUSY);\n}\n\n \n#if defined(CONFIG_FB_OMAP2_DSS_DEBUGFS)\nvoid dss_debug_dump_clocks(struct seq_file *s)\n{\n\tdss_dump_clocks(s);\n\tdispc_dump_clocks(s);\n#ifdef CONFIG_FB_OMAP2_DSS_DSI\n\tdsi_dump_clocks(s);\n#endif\n}\n#endif\n\n\nstatic const enum omap_display_type omap2plus_ports[] = {\n\tOMAP_DISPLAY_TYPE_DPI,\n};\n\nstatic const enum omap_display_type omap34xx_ports[] = {\n\tOMAP_DISPLAY_TYPE_DPI,\n\tOMAP_DISPLAY_TYPE_SDI,\n};\n\nstatic const enum omap_display_type dra7xx_ports[] = {\n\tOMAP_DISPLAY_TYPE_DPI,\n\tOMAP_DISPLAY_TYPE_DPI,\n\tOMAP_DISPLAY_TYPE_DPI,\n};\n\nstatic const struct dss_features omap24xx_dss_feats = {\n\t \n\t.fck_div_max\t\t=\t6,\n\t.dss_fck_multiplier\t=\t2,\n\t.parent_clk_name\t=\t\"core_ck\",\n\t.dpi_select_source\t=\t&dss_dpi_select_source_omap2_omap3,\n\t.ports\t\t\t=\tomap2plus_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(omap2plus_ports),\n};\n\nstatic const struct dss_features omap34xx_dss_feats = {\n\t.fck_div_max\t\t=\t16,\n\t.dss_fck_multiplier\t=\t2,\n\t.parent_clk_name\t=\t\"dpll4_ck\",\n\t.dpi_select_source\t=\t&dss_dpi_select_source_omap2_omap3,\n\t.ports\t\t\t=\tomap34xx_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(omap34xx_ports),\n};\n\nstatic const struct dss_features omap3630_dss_feats = {\n\t.fck_div_max\t\t=\t31,\n\t.dss_fck_multiplier\t=\t1,\n\t.parent_clk_name\t=\t\"dpll4_ck\",\n\t.dpi_select_source\t=\t&dss_dpi_select_source_omap2_omap3,\n\t.ports\t\t\t=\tomap2plus_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(omap2plus_ports),\n};\n\nstatic const struct dss_features omap44xx_dss_feats = {\n\t.fck_div_max\t\t=\t32,\n\t.dss_fck_multiplier\t=\t1,\n\t.parent_clk_name\t=\t\"dpll_per_x2_ck\",\n\t.dpi_select_source\t=\t&dss_dpi_select_source_omap4,\n\t.ports\t\t\t=\tomap2plus_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(omap2plus_ports),\n};\n\nstatic const struct dss_features omap54xx_dss_feats = {\n\t.fck_div_max\t\t=\t64,\n\t.dss_fck_multiplier\t=\t1,\n\t.parent_clk_name\t=\t\"dpll_per_x2_ck\",\n\t.dpi_select_source\t=\t&dss_dpi_select_source_omap5,\n\t.ports\t\t\t=\tomap2plus_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(omap2plus_ports),\n};\n\nstatic const struct dss_features am43xx_dss_feats = {\n\t.fck_div_max\t\t=\t0,\n\t.dss_fck_multiplier\t=\t0,\n\t.parent_clk_name\t=\tNULL,\n\t.dpi_select_source\t=\t&dss_dpi_select_source_omap2_omap3,\n\t.ports\t\t\t=\tomap2plus_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(omap2plus_ports),\n};\n\nstatic const struct dss_features dra7xx_dss_feats = {\n\t.fck_div_max\t\t=\t64,\n\t.dss_fck_multiplier\t=\t1,\n\t.parent_clk_name\t=\t\"dpll_per_x2_ck\",\n\t.dpi_select_source\t=\t&dss_dpi_select_source_dra7xx,\n\t.ports\t\t\t=\tdra7xx_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(dra7xx_ports),\n};\n\nstatic const struct dss_features *dss_get_features(void)\n{\n\tswitch (omapdss_get_version()) {\n\tcase OMAPDSS_VER_OMAP24xx:\n\t\treturn &omap24xx_dss_feats;\n\n\tcase OMAPDSS_VER_OMAP34xx_ES1:\n\tcase OMAPDSS_VER_OMAP34xx_ES3:\n\tcase OMAPDSS_VER_AM35xx:\n\t\treturn &omap34xx_dss_feats;\n\n\tcase OMAPDSS_VER_OMAP3630:\n\t\treturn &omap3630_dss_feats;\n\n\tcase OMAPDSS_VER_OMAP4430_ES1:\n\tcase OMAPDSS_VER_OMAP4430_ES2:\n\tcase OMAPDSS_VER_OMAP4:\n\t\treturn &omap44xx_dss_feats;\n\n\tcase OMAPDSS_VER_OMAP5:\n\t\treturn &omap54xx_dss_feats;\n\n\tcase OMAPDSS_VER_AM43xx:\n\t\treturn &am43xx_dss_feats;\n\n\tcase OMAPDSS_VER_DRA7xx:\n\t\treturn &dra7xx_dss_feats;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic void dss_uninit_ports(struct platform_device *pdev);\n\nstatic int dss_init_ports(struct platform_device *pdev)\n{\n\tstruct device_node *parent = pdev->dev.of_node;\n\tstruct device_node *port;\n\tint r, ret = 0;\n\n\tif (parent == NULL)\n\t\treturn 0;\n\n\tport = omapdss_of_get_next_port(parent, NULL);\n\tif (!port)\n\t\treturn 0;\n\n\tif (dss.feat->num_ports == 0)\n\t\treturn 0;\n\n\tdo {\n\t\tenum omap_display_type port_type;\n\t\tu32 reg;\n\n\t\tr = of_property_read_u32(port, \"reg\", &reg);\n\t\tif (r)\n\t\t\treg = 0;\n\n\t\tif (reg >= dss.feat->num_ports)\n\t\t\tcontinue;\n\n\t\tport_type = dss.feat->ports[reg];\n\n\t\tswitch (port_type) {\n\t\tcase OMAP_DISPLAY_TYPE_DPI:\n\t\t\tret = dpi_init_port(pdev, port);\n\t\t\tbreak;\n\t\tcase OMAP_DISPLAY_TYPE_SDI:\n\t\t\tret = sdi_init_port(pdev, port);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while (!ret &&\n\t\t (port = omapdss_of_get_next_port(parent, port)) != NULL);\n\n\tif (ret)\n\t\tdss_uninit_ports(pdev);\n\n\treturn ret;\n}\n\nstatic void dss_uninit_ports(struct platform_device *pdev)\n{\n\tstruct device_node *parent = pdev->dev.of_node;\n\tstruct device_node *port;\n\n\tif (parent == NULL)\n\t\treturn;\n\n\tport = omapdss_of_get_next_port(parent, NULL);\n\tif (!port)\n\t\treturn;\n\n\tif (dss.feat->num_ports == 0)\n\t\treturn;\n\n\tdo {\n\t\tenum omap_display_type port_type;\n\t\tu32 reg;\n\t\tint r;\n\n\t\tr = of_property_read_u32(port, \"reg\", &reg);\n\t\tif (r)\n\t\t\treg = 0;\n\n\t\tif (reg >= dss.feat->num_ports)\n\t\t\tcontinue;\n\n\t\tport_type = dss.feat->ports[reg];\n\n\t\tswitch (port_type) {\n\t\tcase OMAP_DISPLAY_TYPE_DPI:\n\t\t\tdpi_uninit_port(port);\n\t\t\tbreak;\n\t\tcase OMAP_DISPLAY_TYPE_SDI:\n\t\t\tsdi_uninit_port(port);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while ((port = omapdss_of_get_next_port(parent, port)) != NULL);\n}\n\nstatic int dss_video_pll_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct regulator *pll_regulator;\n\tint r;\n\n\tif (!np)\n\t\treturn 0;\n\n\tif (of_property_read_bool(np, \"syscon-pll-ctrl\")) {\n\t\tdss.syscon_pll_ctrl = syscon_regmap_lookup_by_phandle(np,\n\t\t\t\"syscon-pll-ctrl\");\n\t\tif (IS_ERR(dss.syscon_pll_ctrl)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to get syscon-pll-ctrl regmap\\n\");\n\t\t\treturn PTR_ERR(dss.syscon_pll_ctrl);\n\t\t}\n\n\t\tif (of_property_read_u32_index(np, \"syscon-pll-ctrl\", 1,\n\t\t\t\t&dss.syscon_pll_ctrl_offset)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to get syscon-pll-ctrl offset\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpll_regulator = devm_regulator_get(&pdev->dev, \"vdda_video\");\n\tif (IS_ERR(pll_regulator)) {\n\t\tr = PTR_ERR(pll_regulator);\n\n\t\tswitch (r) {\n\t\tcase -ENOENT:\n\t\t\tpll_regulator = NULL;\n\t\t\tbreak;\n\n\t\tcase -EPROBE_DEFER:\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tdefault:\n\t\t\tDSSERR(\"can't get DPLL VDDA regulator\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (of_property_match_string(np, \"reg-names\", \"pll1\") >= 0) {\n\t\tdss.video1_pll = dss_video_pll_init(pdev, 0, pll_regulator);\n\t\tif (IS_ERR(dss.video1_pll))\n\t\t\treturn PTR_ERR(dss.video1_pll);\n\t}\n\n\tif (of_property_match_string(np, \"reg-names\", \"pll2\") >= 0) {\n\t\tdss.video2_pll = dss_video_pll_init(pdev, 1, pll_regulator);\n\t\tif (IS_ERR(dss.video2_pll)) {\n\t\t\tdss_video_pll_uninit(dss.video1_pll);\n\t\t\treturn PTR_ERR(dss.video2_pll);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dss_bind(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct resource *dss_mem;\n\tu32 rev;\n\tint r;\n\n\tdss.pdev = pdev;\n\n\tdss.feat = dss_get_features();\n\tif (!dss.feat)\n\t\treturn -ENODEV;\n\n\tdss_mem = platform_get_resource(dss.pdev, IORESOURCE_MEM, 0);\n\tif (!dss_mem) {\n\t\tDSSERR(\"can't get IORESOURCE_MEM DSS\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdss.base = devm_ioremap(&pdev->dev, dss_mem->start,\n\t\t\t\tresource_size(dss_mem));\n\tif (!dss.base) {\n\t\tDSSERR(\"can't ioremap DSS\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tr = dss_get_clocks();\n\tif (r)\n\t\treturn r;\n\n\tr = dss_setup_default_clock();\n\tif (r)\n\t\tgoto err_setup_clocks;\n\n\tr = dss_video_pll_probe(pdev);\n\tif (r)\n\t\tgoto err_pll_init;\n\n\tr = dss_init_ports(pdev);\n\tif (r)\n\t\tgoto err_init_ports;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tr = dss_runtime_get();\n\tif (r)\n\t\tgoto err_runtime_get;\n\n\tdss.dss_clk_rate = clk_get_rate(dss.dss_clk);\n\n\t \n\tREG_FLD_MOD(DSS_CONTROL, 0, 0, 0);\n\n\tdss_select_dispc_clk_source(OMAP_DSS_CLK_SRC_FCK);\n\n#ifdef CONFIG_FB_OMAP2_DSS_VENC\n\tREG_FLD_MOD(DSS_CONTROL, 1, 4, 4);\t \n\tREG_FLD_MOD(DSS_CONTROL, 1, 3, 3);\t \n\tREG_FLD_MOD(DSS_CONTROL, 0, 2, 2);\t \n#endif\n\tdss.dsi_clk_source[0] = OMAP_DSS_CLK_SRC_FCK;\n\tdss.dsi_clk_source[1] = OMAP_DSS_CLK_SRC_FCK;\n\tdss.dispc_clk_source = OMAP_DSS_CLK_SRC_FCK;\n\tdss.lcd_clk_source[0] = OMAP_DSS_CLK_SRC_FCK;\n\tdss.lcd_clk_source[1] = OMAP_DSS_CLK_SRC_FCK;\n\n\trev = dss_read_reg(DSS_REVISION);\n\tprintk(KERN_INFO \"OMAP DSS rev %d.%d\\n\",\n\t\t\tFLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));\n\n\tdss_runtime_put();\n\n\tr = component_bind_all(&pdev->dev, NULL);\n\tif (r)\n\t\tgoto err_component;\n\n\tdss_debugfs_create_file(\"dss\", dss_dump_regs);\n\n\tpm_set_vt_switch(0);\n\n\tdss_initialized = true;\n\n\treturn 0;\n\nerr_component:\nerr_runtime_get:\n\tpm_runtime_disable(&pdev->dev);\n\tdss_uninit_ports(pdev);\nerr_init_ports:\n\tif (dss.video1_pll)\n\t\tdss_video_pll_uninit(dss.video1_pll);\n\n\tif (dss.video2_pll)\n\t\tdss_video_pll_uninit(dss.video2_pll);\nerr_pll_init:\nerr_setup_clocks:\n\tdss_put_clocks();\n\treturn r;\n}\n\nstatic void dss_unbind(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tdss_initialized = false;\n\n\tcomponent_unbind_all(&pdev->dev, NULL);\n\n\tif (dss.video1_pll)\n\t\tdss_video_pll_uninit(dss.video1_pll);\n\n\tif (dss.video2_pll)\n\t\tdss_video_pll_uninit(dss.video2_pll);\n\n\tdss_uninit_ports(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tdss_put_clocks();\n}\n\nstatic const struct component_master_ops dss_component_ops = {\n\t.bind = dss_bind,\n\t.unbind = dss_unbind,\n};\n\nstatic int dss_add_child_component(struct device *dev, void *data)\n{\n\tstruct component_match **match = data;\n\n\t \n\tif (strstr(dev_name(dev), \"rfbi\"))\n\t\treturn 0;\n\n\tcomponent_match_add(dev->parent, match, component_compare_dev, dev);\n\n\treturn 0;\n}\n\nstatic int dss_probe(struct platform_device *pdev)\n{\n\tstruct component_match *match = NULL;\n\tint r;\n\n\t \n\tdevice_for_each_child(&pdev->dev, &match, dss_add_child_component);\n\n\tr = component_master_add_with_match(&pdev->dev, &dss_component_ops, match);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic void dss_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &dss_component_ops);\n}\n\nstatic int dss_runtime_suspend(struct device *dev)\n{\n\tdss_save_context();\n\tdss_set_min_bus_tput(dev, 0);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int dss_runtime_resume(struct device *dev)\n{\n\tint r;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\t \n\n\tr = dss_set_min_bus_tput(dev, 1000000000);\n\tif (r)\n\t\treturn r;\n\n\tdss_restore_context();\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dss_pm_ops = {\n\t.runtime_suspend = dss_runtime_suspend,\n\t.runtime_resume = dss_runtime_resume,\n};\n\nstatic const struct of_device_id dss_of_match[] = {\n\t{ .compatible = \"ti,omap2-dss\", },\n\t{ .compatible = \"ti,omap3-dss\", },\n\t{ .compatible = \"ti,omap4-dss\", },\n\t{ .compatible = \"ti,omap5-dss\", },\n\t{ .compatible = \"ti,dra7-dss\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, dss_of_match);\n\nstatic struct platform_driver omap_dsshw_driver = {\n\t.probe\t\t= dss_probe,\n\t.remove_new\t= dss_remove,\n\t.driver         = {\n\t\t.name   = \"omapdss_dss\",\n\t\t.pm\t= &dss_pm_ops,\n\t\t.of_match_table = dss_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nint __init dss_init_platform_driver(void)\n{\n\treturn platform_driver_register(&omap_dsshw_driver);\n}\n\nvoid dss_uninit_platform_driver(void)\n{\n\tplatform_driver_unregister(&omap_dsshw_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}