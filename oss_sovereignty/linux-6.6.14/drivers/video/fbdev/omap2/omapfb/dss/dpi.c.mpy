{
  "module_name": "dpi.c",
  "hash_id": "a4d892655e744d64ca88b0bd9e22baf7bc42dbe396415e73590252d0724fdd96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/dpi.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"DPI\"\n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/string.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"dss_features.h\"\n\n#define HSDIV_DISPC\t0\n\nstruct dpi_data {\n\tstruct platform_device *pdev;\n\n\tstruct regulator *vdds_dsi_reg;\n\tstruct dss_pll *pll;\n\n\tstruct mutex lock;\n\n\tstruct omap_video_timings timings;\n\tstruct dss_lcd_mgr_config mgr_config;\n\tint data_lines;\n\n\tstruct omap_dss_device output;\n\n\tbool port_initialized;\n};\n\nstatic struct dpi_data *dpi_get_data_from_dssdev(struct omap_dss_device *dssdev)\n{\n\treturn container_of(dssdev, struct dpi_data, output);\n}\n\n \nstatic struct dpi_data *dpi_get_data_from_pdev(struct platform_device *pdev)\n{\n\treturn platform_get_drvdata(pdev);\n}\n\nstatic struct dss_pll *dpi_get_pll(enum omap_channel channel)\n{\n\t \n\tswitch (omapdss_get_version()) {\n\tcase OMAPDSS_VER_OMAP24xx:\n\tcase OMAPDSS_VER_OMAP34xx_ES1:\n\tcase OMAPDSS_VER_OMAP34xx_ES3:\n\tcase OMAPDSS_VER_OMAP3630:\n\tcase OMAPDSS_VER_AM35xx:\n\tcase OMAPDSS_VER_AM43xx:\n\t\treturn NULL;\n\n\tcase OMAPDSS_VER_OMAP4430_ES1:\n\tcase OMAPDSS_VER_OMAP4430_ES2:\n\tcase OMAPDSS_VER_OMAP4:\n\t\tswitch (channel) {\n\t\tcase OMAP_DSS_CHANNEL_LCD:\n\t\t\treturn dss_pll_find(\"dsi0\");\n\t\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\t\treturn dss_pll_find(\"dsi1\");\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\n\tcase OMAPDSS_VER_OMAP5:\n\t\tswitch (channel) {\n\t\tcase OMAP_DSS_CHANNEL_LCD:\n\t\t\treturn dss_pll_find(\"dsi0\");\n\t\tcase OMAP_DSS_CHANNEL_LCD3:\n\t\t\treturn dss_pll_find(\"dsi1\");\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\n\tcase OMAPDSS_VER_DRA7xx:\n\t\tswitch (channel) {\n\t\tcase OMAP_DSS_CHANNEL_LCD:\n\t\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\t\treturn dss_pll_find(\"video0\");\n\t\tcase OMAP_DSS_CHANNEL_LCD3:\n\t\t\treturn dss_pll_find(\"video1\");\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic enum omap_dss_clk_source dpi_get_alt_clk_src(enum omap_channel channel)\n{\n\tswitch (channel) {\n\tcase OMAP_DSS_CHANNEL_LCD:\n\t\treturn OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC;\n\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\treturn OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC;\n\tcase OMAP_DSS_CHANNEL_LCD3:\n\t\treturn OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC;\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\treturn OMAP_DSS_CLK_SRC_FCK;\n\t}\n}\n\nstruct dpi_clk_calc_ctx {\n\tstruct dss_pll *pll;\n\n\t \n\n\tunsigned long pck_min, pck_max;\n\n\t \n\n\tstruct dss_pll_clock_info dsi_cinfo;\n\tunsigned long fck;\n\tstruct dispc_clock_info dispc_cinfo;\n};\n\nstatic bool dpi_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\n\t\tunsigned long pck, void *data)\n{\n\tstruct dpi_clk_calc_ctx *ctx = data;\n\n\t \n\tif (ctx->pck_min >= 100000000) {\n\t\tif (lckd > 1 && lckd % 2 != 0)\n\t\t\treturn false;\n\n\t\tif (pckd > 1 && pckd % 2 != 0)\n\t\t\treturn false;\n\t}\n\n\tctx->dispc_cinfo.lck_div = lckd;\n\tctx->dispc_cinfo.pck_div = pckd;\n\tctx->dispc_cinfo.lck = lck;\n\tctx->dispc_cinfo.pck = pck;\n\n\treturn true;\n}\n\n\nstatic bool dpi_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n\t\tvoid *data)\n{\n\tstruct dpi_clk_calc_ctx *ctx = data;\n\n\t \n\tif (m_dispc > 1 && m_dispc % 2 != 0 && ctx->pck_min >= 100000000)\n\t\treturn false;\n\n\tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n\tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n\n\treturn dispc_div_calc(dispc, ctx->pck_min, ctx->pck_max,\n\t\t\tdpi_calc_dispc_cb, ctx);\n}\n\n\nstatic bool dpi_calc_pll_cb(int n, int m, unsigned long fint,\n\t\tunsigned long clkdco,\n\t\tvoid *data)\n{\n\tstruct dpi_clk_calc_ctx *ctx = data;\n\n\tctx->dsi_cinfo.n = n;\n\tctx->dsi_cinfo.m = m;\n\tctx->dsi_cinfo.fint = fint;\n\tctx->dsi_cinfo.clkdco = clkdco;\n\n\treturn dss_pll_hsdiv_calc(ctx->pll, clkdco,\n\t\tctx->pck_min, dss_feat_get_param_max(FEAT_PARAM_DSS_FCK),\n\t\tdpi_calc_hsdiv_cb, ctx);\n}\n\nstatic bool dpi_calc_dss_cb(unsigned long fck, void *data)\n{\n\tstruct dpi_clk_calc_ctx *ctx = data;\n\n\tctx->fck = fck;\n\n\treturn dispc_div_calc(fck, ctx->pck_min, ctx->pck_max,\n\t\t\tdpi_calc_dispc_cb, ctx);\n}\n\nstatic bool dpi_dsi_clk_calc(struct dpi_data *dpi, unsigned long pck,\n\t\tstruct dpi_clk_calc_ctx *ctx)\n{\n\tunsigned long clkin;\n\tunsigned long pll_min, pll_max;\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->pll = dpi->pll;\n\tctx->pck_min = pck - 1000;\n\tctx->pck_max = pck + 1000;\n\n\tpll_min = 0;\n\tpll_max = 0;\n\n\tclkin = clk_get_rate(ctx->pll->clkin);\n\n\treturn dss_pll_calc(ctx->pll, clkin,\n\t\t\tpll_min, pll_max,\n\t\t\tdpi_calc_pll_cb, ctx);\n}\n\nstatic bool dpi_dss_clk_calc(unsigned long pck, struct dpi_clk_calc_ctx *ctx)\n{\n\tint i;\n\n\t \n\n\tfor (i = 0; i < 25; ++i) {\n\t\tbool ok;\n\n\t\tmemset(ctx, 0, sizeof(*ctx));\n\t\tif (pck > 1000 * i * i * i)\n\t\t\tctx->pck_min = max(pck - 1000 * i * i * i, 0lu);\n\t\telse\n\t\t\tctx->pck_min = 0;\n\t\tctx->pck_max = pck + 1000 * i * i * i;\n\n\t\tok = dss_div_calc(pck, ctx->pck_min, dpi_calc_dss_cb, ctx);\n\t\tif (ok)\n\t\t\treturn ok;\n\t}\n\n\treturn false;\n}\n\n\n\nstatic int dpi_set_dsi_clk(struct dpi_data *dpi, enum omap_channel channel,\n\t\tunsigned long pck_req, unsigned long *fck, int *lck_div,\n\t\tint *pck_div)\n{\n\tstruct dpi_clk_calc_ctx ctx;\n\tint r;\n\tbool ok;\n\n\tok = dpi_dsi_clk_calc(dpi, pck_req, &ctx);\n\tif (!ok)\n\t\treturn -EINVAL;\n\n\tr = dss_pll_set_config(dpi->pll, &ctx.dsi_cinfo);\n\tif (r)\n\t\treturn r;\n\n\tdss_select_lcd_clk_source(channel,\n\t\t\tdpi_get_alt_clk_src(channel));\n\n\tdpi->mgr_config.clock_info = ctx.dispc_cinfo;\n\n\t*fck = ctx.dsi_cinfo.clkout[HSDIV_DISPC];\n\t*lck_div = ctx.dispc_cinfo.lck_div;\n\t*pck_div = ctx.dispc_cinfo.pck_div;\n\n\treturn 0;\n}\n\nstatic int dpi_set_dispc_clk(struct dpi_data *dpi, unsigned long pck_req,\n\t\tunsigned long *fck, int *lck_div, int *pck_div)\n{\n\tstruct dpi_clk_calc_ctx ctx;\n\tint r;\n\tbool ok;\n\n\tok = dpi_dss_clk_calc(pck_req, &ctx);\n\tif (!ok)\n\t\treturn -EINVAL;\n\n\tr = dss_set_fck_rate(ctx.fck);\n\tif (r)\n\t\treturn r;\n\n\tdpi->mgr_config.clock_info = ctx.dispc_cinfo;\n\n\t*fck = ctx.fck;\n\t*lck_div = ctx.dispc_cinfo.lck_div;\n\t*pck_div = ctx.dispc_cinfo.pck_div;\n\n\treturn 0;\n}\n\nstatic int dpi_set_mode(struct dpi_data *dpi)\n{\n\tstruct omap_dss_device *out = &dpi->output;\n\tstruct omap_overlay_manager *mgr = out->manager;\n\tstruct omap_video_timings *t = &dpi->timings;\n\tint lck_div = 0, pck_div = 0;\n\tunsigned long fck = 0;\n\tunsigned long pck;\n\tint r = 0;\n\n\tif (dpi->pll)\n\t\tr = dpi_set_dsi_clk(dpi, mgr->id, t->pixelclock, &fck,\n\t\t\t\t&lck_div, &pck_div);\n\telse\n\t\tr = dpi_set_dispc_clk(dpi, t->pixelclock, &fck,\n\t\t\t\t&lck_div, &pck_div);\n\tif (r)\n\t\treturn r;\n\n\tpck = fck / lck_div / pck_div;\n\n\tif (pck != t->pixelclock) {\n\t\tDSSWARN(\"Could not find exact pixel clock. Requested %d Hz, got %lu Hz\\n\",\n\t\t\tt->pixelclock, pck);\n\n\t\tt->pixelclock = pck;\n\t}\n\n\tdss_mgr_set_timings(mgr, t);\n\n\treturn 0;\n}\n\nstatic void dpi_config_lcd_manager(struct dpi_data *dpi)\n{\n\tstruct omap_dss_device *out = &dpi->output;\n\tstruct omap_overlay_manager *mgr = out->manager;\n\n\tdpi->mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\n\n\tdpi->mgr_config.stallmode = false;\n\tdpi->mgr_config.fifohandcheck = false;\n\n\tdpi->mgr_config.video_port_width = dpi->data_lines;\n\n\tdpi->mgr_config.lcden_sig_polarity = 0;\n\n\tdss_mgr_set_lcd_config(mgr, &dpi->mgr_config);\n}\n\nstatic int dpi_display_enable(struct omap_dss_device *dssdev)\n{\n\tstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\n\tstruct omap_dss_device *out = &dpi->output;\n\tint r;\n\n\tmutex_lock(&dpi->lock);\n\n\tif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI) && !dpi->vdds_dsi_reg) {\n\t\tDSSERR(\"no VDSS_DSI regulator\\n\");\n\t\tr = -ENODEV;\n\t\tgoto err_no_reg;\n\t}\n\n\tif (out->manager == NULL) {\n\t\tDSSERR(\"failed to enable display: no output/manager\\n\");\n\t\tr = -ENODEV;\n\t\tgoto err_no_out_mgr;\n\t}\n\n\tif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI)) {\n\t\tr = regulator_enable(dpi->vdds_dsi_reg);\n\t\tif (r)\n\t\t\tgoto err_reg_enable;\n\t}\n\n\tr = dispc_runtime_get();\n\tif (r)\n\t\tgoto err_get_dispc;\n\n\tr = dss_dpi_select_source(out->port_num, out->manager->id);\n\tif (r)\n\t\tgoto err_src_sel;\n\n\tif (dpi->pll) {\n\t\tr = dss_pll_enable(dpi->pll);\n\t\tif (r)\n\t\t\tgoto err_dsi_pll_init;\n\t}\n\n\tr = dpi_set_mode(dpi);\n\tif (r)\n\t\tgoto err_set_mode;\n\n\tdpi_config_lcd_manager(dpi);\n\n\tmdelay(2);\n\n\tr = dss_mgr_enable(out->manager);\n\tif (r)\n\t\tgoto err_mgr_enable;\n\n\tmutex_unlock(&dpi->lock);\n\n\treturn 0;\n\nerr_mgr_enable:\nerr_set_mode:\n\tif (dpi->pll)\n\t\tdss_pll_disable(dpi->pll);\nerr_dsi_pll_init:\nerr_src_sel:\n\tdispc_runtime_put();\nerr_get_dispc:\n\tif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI))\n\t\tregulator_disable(dpi->vdds_dsi_reg);\nerr_reg_enable:\nerr_no_out_mgr:\nerr_no_reg:\n\tmutex_unlock(&dpi->lock);\n\treturn r;\n}\n\nstatic void dpi_display_disable(struct omap_dss_device *dssdev)\n{\n\tstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\n\tstruct omap_overlay_manager *mgr = dpi->output.manager;\n\n\tmutex_lock(&dpi->lock);\n\n\tdss_mgr_disable(mgr);\n\n\tif (dpi->pll) {\n\t\tdss_select_lcd_clk_source(mgr->id, OMAP_DSS_CLK_SRC_FCK);\n\t\tdss_pll_disable(dpi->pll);\n\t}\n\n\tdispc_runtime_put();\n\n\tif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI))\n\t\tregulator_disable(dpi->vdds_dsi_reg);\n\n\tmutex_unlock(&dpi->lock);\n}\n\nstatic void dpi_set_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\n\n\tDSSDBG(\"dpi_set_timings\\n\");\n\n\tmutex_lock(&dpi->lock);\n\n\tdpi->timings = *timings;\n\n\tmutex_unlock(&dpi->lock);\n}\n\nstatic void dpi_get_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\n\n\tmutex_lock(&dpi->lock);\n\n\t*timings = dpi->timings;\n\n\tmutex_unlock(&dpi->lock);\n}\n\nstatic int dpi_check_timings(struct omap_dss_device *dssdev,\n\t\t\tstruct omap_video_timings *timings)\n{\n\tstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\n\tstruct omap_overlay_manager *mgr = dpi->output.manager;\n\tint lck_div, pck_div;\n\tunsigned long fck;\n\tunsigned long pck;\n\tstruct dpi_clk_calc_ctx ctx;\n\tbool ok;\n\n\tif (mgr && !dispc_mgr_timings_ok(mgr->id, timings))\n\t\treturn -EINVAL;\n\n\tif (timings->pixelclock == 0)\n\t\treturn -EINVAL;\n\n\tif (dpi->pll) {\n\t\tok = dpi_dsi_clk_calc(dpi, timings->pixelclock, &ctx);\n\t\tif (!ok)\n\t\t\treturn -EINVAL;\n\n\t\tfck = ctx.dsi_cinfo.clkout[HSDIV_DISPC];\n\t} else {\n\t\tok = dpi_dss_clk_calc(timings->pixelclock, &ctx);\n\t\tif (!ok)\n\t\t\treturn -EINVAL;\n\n\t\tfck = ctx.fck;\n\t}\n\n\tlck_div = ctx.dispc_cinfo.lck_div;\n\tpck_div = ctx.dispc_cinfo.pck_div;\n\n\tpck = fck / lck_div / pck_div;\n\n\ttimings->pixelclock = pck;\n\n\treturn 0;\n}\n\nstatic void dpi_set_data_lines(struct omap_dss_device *dssdev, int data_lines)\n{\n\tstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\n\n\tmutex_lock(&dpi->lock);\n\n\tdpi->data_lines = data_lines;\n\n\tmutex_unlock(&dpi->lock);\n}\n\nstatic int dpi_verify_dsi_pll(struct dss_pll *pll)\n{\n\tint r;\n\n\t \n\n\tr = dss_pll_enable(pll);\n\tif (r)\n\t\treturn r;\n\n\tdss_pll_disable(pll);\n\n\treturn 0;\n}\n\nstatic int dpi_init_regulator(struct dpi_data *dpi)\n{\n\tstruct regulator *vdds_dsi;\n\n\tif (!dss_has_feature(FEAT_DPI_USES_VDDS_DSI))\n\t\treturn 0;\n\n\tif (dpi->vdds_dsi_reg)\n\t\treturn 0;\n\n\tvdds_dsi = devm_regulator_get(&dpi->pdev->dev, \"vdds_dsi\");\n\tif (IS_ERR(vdds_dsi)) {\n\t\tif (PTR_ERR(vdds_dsi) != -EPROBE_DEFER)\n\t\t\tDSSERR(\"can't get VDDS_DSI regulator\\n\");\n\t\treturn PTR_ERR(vdds_dsi);\n\t}\n\n\tdpi->vdds_dsi_reg = vdds_dsi;\n\n\treturn 0;\n}\n\nstatic void dpi_init_pll(struct dpi_data *dpi)\n{\n\tstruct dss_pll *pll;\n\n\tif (dpi->pll)\n\t\treturn;\n\n\tpll = dpi_get_pll(dpi->output.dispc_channel);\n\tif (!pll)\n\t\treturn;\n\n\t \n\tif (omapdss_get_version() == OMAPDSS_VER_DRA7xx)\n\t\tdss_ctrl_pll_set_control_mux(pll->id, dpi->output.dispc_channel);\n\n\tif (dpi_verify_dsi_pll(pll)) {\n\t\tDSSWARN(\"DSI PLL not operational\\n\");\n\t\treturn;\n\t}\n\n\tdpi->pll = pll;\n}\n\n \nstatic enum omap_channel dpi_get_channel(int port_num)\n{\n\tswitch (omapdss_get_version()) {\n\tcase OMAPDSS_VER_OMAP24xx:\n\tcase OMAPDSS_VER_OMAP34xx_ES1:\n\tcase OMAPDSS_VER_OMAP34xx_ES3:\n\tcase OMAPDSS_VER_OMAP3630:\n\tcase OMAPDSS_VER_AM35xx:\n\tcase OMAPDSS_VER_AM43xx:\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\n\tcase OMAPDSS_VER_DRA7xx:\n\t\tswitch (port_num) {\n\t\tcase 2:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD3;\n\t\tcase 1:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD2;\n\t\tcase 0:\n\t\tdefault:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t\t}\n\n\tcase OMAPDSS_VER_OMAP4430_ES1:\n\tcase OMAPDSS_VER_OMAP4430_ES2:\n\tcase OMAPDSS_VER_OMAP4:\n\t\treturn OMAP_DSS_CHANNEL_LCD2;\n\n\tcase OMAPDSS_VER_OMAP5:\n\t\treturn OMAP_DSS_CHANNEL_LCD3;\n\n\tdefault:\n\t\tDSSWARN(\"unsupported DSS version\\n\");\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t}\n}\n\nstatic int dpi_connect(struct omap_dss_device *dssdev,\n\t\tstruct omap_dss_device *dst)\n{\n\tstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\n\tstruct omap_overlay_manager *mgr;\n\tint r;\n\n\tr = dpi_init_regulator(dpi);\n\tif (r)\n\t\treturn r;\n\n\tdpi_init_pll(dpi);\n\n\tmgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);\n\tif (!mgr)\n\t\treturn -ENODEV;\n\n\tr = dss_mgr_connect(mgr, dssdev);\n\tif (r)\n\t\treturn r;\n\n\tr = omapdss_output_set_device(dssdev, dst);\n\tif (r) {\n\t\tDSSERR(\"failed to connect output to new device: %s\\n\",\n\t\t\t\tdst->name);\n\t\tdss_mgr_disconnect(mgr, dssdev);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void dpi_disconnect(struct omap_dss_device *dssdev,\n\t\tstruct omap_dss_device *dst)\n{\n\tWARN_ON(dst != dssdev->dst);\n\n\tif (dst != dssdev->dst)\n\t\treturn;\n\n\tomapdss_output_unset_device(dssdev);\n\n\tif (dssdev->manager)\n\t\tdss_mgr_disconnect(dssdev->manager, dssdev);\n}\n\nstatic const struct omapdss_dpi_ops dpi_ops = {\n\t.connect = dpi_connect,\n\t.disconnect = dpi_disconnect,\n\n\t.enable = dpi_display_enable,\n\t.disable = dpi_display_disable,\n\n\t.check_timings = dpi_check_timings,\n\t.set_timings = dpi_set_timings,\n\t.get_timings = dpi_get_timings,\n\n\t.set_data_lines = dpi_set_data_lines,\n};\n\nstatic void dpi_init_output(struct platform_device *pdev)\n{\n\tstruct dpi_data *dpi = dpi_get_data_from_pdev(pdev);\n\tstruct omap_dss_device *out = &dpi->output;\n\n\tout->dev = &pdev->dev;\n\tout->id = OMAP_DSS_OUTPUT_DPI;\n\tout->output_type = OMAP_DISPLAY_TYPE_DPI;\n\tout->name = \"dpi.0\";\n\tout->dispc_channel = dpi_get_channel(0);\n\tout->ops.dpi = &dpi_ops;\n\tout->owner = THIS_MODULE;\n\n\tomapdss_register_output(out);\n}\n\nstatic void dpi_uninit_output(struct platform_device *pdev)\n{\n\tstruct dpi_data *dpi = dpi_get_data_from_pdev(pdev);\n\tstruct omap_dss_device *out = &dpi->output;\n\n\tomapdss_unregister_output(out);\n}\n\nstatic void dpi_init_output_port(struct platform_device *pdev,\n\tstruct device_node *port)\n{\n\tstruct dpi_data *dpi = port->data;\n\tstruct omap_dss_device *out = &dpi->output;\n\tint r;\n\tu32 port_num;\n\n\tr = of_property_read_u32(port, \"reg\", &port_num);\n\tif (r)\n\t\tport_num = 0;\n\n\tswitch (port_num) {\n\tcase 2:\n\t\tout->name = \"dpi.2\";\n\t\tbreak;\n\tcase 1:\n\t\tout->name = \"dpi.1\";\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tout->name = \"dpi.0\";\n\t\tbreak;\n\t}\n\n\tout->dev = &pdev->dev;\n\tout->id = OMAP_DSS_OUTPUT_DPI;\n\tout->output_type = OMAP_DISPLAY_TYPE_DPI;\n\tout->dispc_channel = dpi_get_channel(port_num);\n\tout->port_num = port_num;\n\tout->ops.dpi = &dpi_ops;\n\tout->owner = THIS_MODULE;\n\n\tomapdss_register_output(out);\n}\n\nstatic void dpi_uninit_output_port(struct device_node *port)\n{\n\tstruct dpi_data *dpi = port->data;\n\tstruct omap_dss_device *out = &dpi->output;\n\n\tomapdss_unregister_output(out);\n}\n\nstatic int dpi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct dpi_data *dpi;\n\n\tdpi = devm_kzalloc(&pdev->dev, sizeof(*dpi), GFP_KERNEL);\n\tif (!dpi)\n\t\treturn -ENOMEM;\n\n\tdpi->pdev = pdev;\n\n\tplatform_set_drvdata(pdev, dpi);\n\n\tmutex_init(&dpi->lock);\n\n\tdpi_init_output(pdev);\n\n\treturn 0;\n}\n\nstatic void dpi_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tdpi_uninit_output(pdev);\n}\n\nstatic const struct component_ops dpi_component_ops = {\n\t.bind\t= dpi_bind,\n\t.unbind\t= dpi_unbind,\n};\n\nstatic int dpi_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &dpi_component_ops);\n}\n\nstatic void dpi_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &dpi_component_ops);\n}\n\nstatic struct platform_driver omap_dpi_driver = {\n\t.probe\t\t= dpi_probe,\n\t.remove_new\t= dpi_remove,\n\t.driver         = {\n\t\t.name   = \"omapdss_dpi\",\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nint __init dpi_init_platform_driver(void)\n{\n\treturn platform_driver_register(&omap_dpi_driver);\n}\n\nvoid dpi_uninit_platform_driver(void)\n{\n\tplatform_driver_unregister(&omap_dpi_driver);\n}\n\nint dpi_init_port(struct platform_device *pdev, struct device_node *port)\n{\n\tstruct dpi_data *dpi;\n\tstruct device_node *ep;\n\tu32 datalines;\n\tint r;\n\n\tdpi = devm_kzalloc(&pdev->dev, sizeof(*dpi), GFP_KERNEL);\n\tif (!dpi)\n\t\treturn -ENOMEM;\n\n\tep = omapdss_of_get_next_endpoint(port, NULL);\n\tif (!ep)\n\t\treturn 0;\n\n\tr = of_property_read_u32(ep, \"data-lines\", &datalines);\n\tif (r) {\n\t\tDSSERR(\"failed to parse datalines\\n\");\n\t\tgoto err_datalines;\n\t}\n\n\tdpi->data_lines = datalines;\n\n\tof_node_put(ep);\n\n\tdpi->pdev = pdev;\n\tport->data = dpi;\n\n\tmutex_init(&dpi->lock);\n\n\tdpi_init_output_port(pdev, port);\n\n\tdpi->port_initialized = true;\n\n\treturn 0;\n\nerr_datalines:\n\tof_node_put(ep);\n\n\treturn r;\n}\n\nvoid dpi_uninit_port(struct device_node *port)\n{\n\tstruct dpi_data *dpi = port->data;\n\n\tif (!dpi->port_initialized)\n\t\treturn;\n\n\tdpi_uninit_output_port(port);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}