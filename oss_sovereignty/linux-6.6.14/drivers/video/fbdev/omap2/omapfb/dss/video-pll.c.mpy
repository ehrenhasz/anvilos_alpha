{
  "module_name": "video-pll.c",
  "hash_id": "bef4294755852f8deb0a0429d5be94eee11fa68c922d1372a6657e5f2aa59cca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/video-pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"dss_features.h\"\n\nstruct dss_video_pll {\n\tstruct dss_pll pll;\n\n\tstruct device *dev;\n\n\tvoid __iomem *clkctrl_base;\n};\n\n#define REG_MOD(reg, val, start, end) \\\n\twritel_relaxed(FLD_MOD(readl_relaxed(reg), val, start, end), reg)\n\nstatic void dss_dpll_enable_scp_clk(struct dss_video_pll *vpll)\n{\n\tREG_MOD(vpll->clkctrl_base, 1, 14, 14);  \n}\n\nstatic void dss_dpll_disable_scp_clk(struct dss_video_pll *vpll)\n{\n\tREG_MOD(vpll->clkctrl_base, 0, 14, 14);  \n}\n\nstatic void dss_dpll_power_enable(struct dss_video_pll *vpll)\n{\n\tREG_MOD(vpll->clkctrl_base, 2, 31, 30);  \n\n\t \n\tmsleep(1);\n}\n\nstatic void dss_dpll_power_disable(struct dss_video_pll *vpll)\n{\n\tREG_MOD(vpll->clkctrl_base, 0, 31, 30);\t \n}\n\nstatic int dss_video_pll_enable(struct dss_pll *pll)\n{\n\tstruct dss_video_pll *vpll = container_of(pll, struct dss_video_pll, pll);\n\tint r;\n\n\tr = dss_runtime_get();\n\tif (r)\n\t\treturn r;\n\n\tdss_ctrl_pll_enable(pll->id, true);\n\n\tdss_dpll_enable_scp_clk(vpll);\n\n\tr = dss_pll_wait_reset_done(pll);\n\tif (r)\n\t\tgoto err_reset;\n\n\tdss_dpll_power_enable(vpll);\n\n\treturn 0;\n\nerr_reset:\n\tdss_dpll_disable_scp_clk(vpll);\n\tdss_ctrl_pll_enable(pll->id, false);\n\tdss_runtime_put();\n\n\treturn r;\n}\n\nstatic void dss_video_pll_disable(struct dss_pll *pll)\n{\n\tstruct dss_video_pll *vpll = container_of(pll, struct dss_video_pll, pll);\n\n\tdss_dpll_power_disable(vpll);\n\n\tdss_dpll_disable_scp_clk(vpll);\n\n\tdss_ctrl_pll_enable(pll->id, false);\n\n\tdss_runtime_put();\n}\n\nstatic const struct dss_pll_ops dss_pll_ops = {\n\t.enable = dss_video_pll_enable,\n\t.disable = dss_video_pll_disable,\n\t.set_config = dss_pll_write_config_type_a,\n};\n\nstatic const struct dss_pll_hw dss_dra7_video_pll_hw = {\n\t.n_max = (1 << 8) - 1,\n\t.m_max = (1 << 12) - 1,\n\t.mX_max = (1 << 5) - 1,\n\t.fint_min = 500000,\n\t.fint_max = 2500000,\n\t.clkdco_max = 1800000000,\n\n\t.n_msb = 8,\n\t.n_lsb = 1,\n\t.m_msb = 20,\n\t.m_lsb = 9,\n\n\t.mX_msb[0] = 25,\n\t.mX_lsb[0] = 21,\n\t.mX_msb[1] = 30,\n\t.mX_lsb[1] = 26,\n\n\t.has_refsel = true,\n};\n\nstruct dss_pll *dss_video_pll_init(struct platform_device *pdev, int id,\n\tstruct regulator *regulator)\n{\n\tconst char * const reg_name[] = { \"pll1\", \"pll2\" };\n\tconst char * const clkctrl_name[] = { \"pll1_clkctrl\", \"pll2_clkctrl\" };\n\tconst char * const clkin_name[] = { \"video1_clk\", \"video2_clk\" };\n\n\tstruct dss_video_pll *vpll;\n\tvoid __iomem *pll_base, *clkctrl_base;\n\tstruct clk *clk;\n\tstruct dss_pll *pll;\n\tint r;\n\n\t \n\n\tpll_base = devm_platform_ioremap_resource_byname(pdev, reg_name[id]);\n\tif (IS_ERR(pll_base)) {\n\t\tdev_err(&pdev->dev, \"failed to ioremap pll%d reg_name\\n\", id);\n\t\treturn ERR_CAST(pll_base);\n\t}\n\n\t \n\n\tclkctrl_base = devm_platform_ioremap_resource_byname(pdev, clkctrl_name[id]);\n\tif (IS_ERR(clkctrl_base)) {\n\t\tdev_err(&pdev->dev, \"failed to ioremap pll%d clkctrl\\n\", id);\n\t\treturn ERR_CAST(clkctrl_base);\n\t}\n\n\t \n\n\tclk = devm_clk_get(&pdev->dev, clkin_name[id]);\n\tif (IS_ERR(clk)) {\n\t\tDSSERR(\"can't get video pll clkin\\n\");\n\t\treturn ERR_CAST(clk);\n\t}\n\n\tvpll = devm_kzalloc(&pdev->dev, sizeof(*vpll), GFP_KERNEL);\n\tif (!vpll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvpll->dev = &pdev->dev;\n\tvpll->clkctrl_base = clkctrl_base;\n\n\tpll = &vpll->pll;\n\n\tpll->name = id == 0 ? \"video0\" : \"video1\";\n\tpll->id = id == 0 ? DSS_PLL_VIDEO1 : DSS_PLL_VIDEO2;\n\tpll->clkin = clk;\n\tpll->regulator = regulator;\n\tpll->base = pll_base;\n\tpll->hw = &dss_dra7_video_pll_hw;\n\tpll->ops = &dss_pll_ops;\n\n\tr = dss_pll_register(pll);\n\tif (r)\n\t\treturn ERR_PTR(r);\n\n\treturn pll;\n}\n\nvoid dss_video_pll_uninit(struct dss_pll *pll)\n{\n\tdss_pll_unregister(pll);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}