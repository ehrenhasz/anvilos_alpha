{
  "module_name": "dss-of.c",
  "hash_id": "3888230c055e467fc51547219b1525b0cf2c99e98c5c9e5790d58059f5d3945b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/dss-of.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/seq_file.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n\nstruct device_node *\nomapdss_of_get_next_port(const struct device_node *parent,\n\t\t\t struct device_node *prev)\n{\n\tstruct device_node *port = NULL;\n\n\tif (!parent)\n\t\treturn NULL;\n\n\tif (!prev) {\n\t\tstruct device_node *ports;\n\t\t \n\t\tports = of_get_child_by_name(parent, \"ports\");\n\t\tif (ports)\n\t\t\tparent = ports;\n\n\t\tport = of_get_child_by_name(parent, \"port\");\n\n\t\t \n\t\tof_node_put(ports);\n\t} else {\n\t\tstruct device_node *ports;\n\n\t\tports = of_get_parent(prev);\n\t\tif (!ports)\n\t\t\treturn NULL;\n\n\t\tdo {\n\t\t\tport = of_get_next_child(ports, prev);\n\t\t\tif (!port) {\n\t\t\t\tof_node_put(ports);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tprev = port;\n\t\t} while (!of_node_name_eq(port, \"port\"));\n\n\t\tof_node_put(ports);\n\t}\n\n\treturn port;\n}\nEXPORT_SYMBOL_GPL(omapdss_of_get_next_port);\n\nstruct device_node *\nomapdss_of_get_next_endpoint(const struct device_node *parent,\n\t\t\t     struct device_node *prev)\n{\n\tstruct device_node *ep = NULL;\n\n\tif (!parent)\n\t\treturn NULL;\n\n\tdo {\n\t\tep = of_get_next_child(parent, prev);\n\t\tif (!ep)\n\t\t\treturn NULL;\n\t\tprev = ep;\n\t} while (!of_node_name_eq(ep, \"endpoint\"));\n\n\treturn ep;\n}\nEXPORT_SYMBOL_GPL(omapdss_of_get_next_endpoint);\n\nstruct device_node *dss_of_port_get_parent_device(struct device_node *port)\n{\n\tstruct device_node *np;\n\tint i;\n\n\tif (!port)\n\t\treturn NULL;\n\n\tnp = of_get_parent(port);\n\n\tfor (i = 0; i < 2 && np; ++i) {\n\t\tstruct property *prop;\n\n\t\tprop = of_find_property(np, \"compatible\", NULL);\n\n\t\tif (prop)\n\t\t\treturn np;\n\n\t\tnp = of_get_next_parent(np);\n\t}\n\n\treturn NULL;\n}\n\nu32 dss_of_port_get_port_number(struct device_node *port)\n{\n\tint r;\n\tu32 reg;\n\n\tr = of_property_read_u32(port, \"reg\", &reg);\n\tif (r)\n\t\treg = 0;\n\n\treturn reg;\n}\n\nstatic struct device_node *omapdss_of_get_remote_port(const struct device_node *node)\n{\n\tstruct device_node *np;\n\n\tnp = of_graph_get_remote_endpoint(node);\n\tif (!np)\n\t\treturn NULL;\n\n\tnp = of_get_next_parent(np);\n\n\treturn np;\n}\n\nstruct device_node *\nomapdss_of_get_first_endpoint(const struct device_node *parent)\n{\n\tstruct device_node *port, *ep;\n\n\tport = omapdss_of_get_next_port(parent, NULL);\n\n\tif (!port)\n\t\treturn NULL;\n\n\tep = omapdss_of_get_next_endpoint(port, NULL);\n\n\tof_node_put(port);\n\n\treturn ep;\n}\nEXPORT_SYMBOL_GPL(omapdss_of_get_first_endpoint);\n\nstruct omap_dss_device *\nomapdss_of_find_source_for_first_ep(struct device_node *node)\n{\n\tstruct device_node *ep;\n\tstruct device_node *src_port;\n\tstruct omap_dss_device *src;\n\n\tep = omapdss_of_get_first_endpoint(node);\n\tif (!ep)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsrc_port = omapdss_of_get_remote_port(ep);\n\tif (!src_port) {\n\t\tof_node_put(ep);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tof_node_put(ep);\n\n\tsrc = omap_dss_find_output_by_port_node(src_port);\n\n\tof_node_put(src_port);\n\n\treturn src ? src : ERR_PTR(-EPROBE_DEFER);\n}\nEXPORT_SYMBOL_GPL(omapdss_of_find_source_for_first_ep);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}