{
  "module_name": "manager.c",
  "hash_id": "c16b5e66c08ffac9bfabcea6eaaa0d33982a0299e9f1d110c74f194aac964c6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/manager.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"MANAGER\"\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/jiffies.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"dss_features.h\"\n\nstatic int num_managers;\nstatic struct omap_overlay_manager *managers;\n\nint dss_init_overlay_managers(void)\n{\n\tint i;\n\n\tnum_managers = dss_feat_get_num_mgrs();\n\n\tmanagers = kcalloc(num_managers, sizeof(struct omap_overlay_manager),\n\t\t\t   GFP_KERNEL);\n\n\tBUG_ON(managers == NULL);\n\n\tfor (i = 0; i < num_managers; ++i) {\n\t\tstruct omap_overlay_manager *mgr = &managers[i];\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tmgr->name = \"lcd\";\n\t\t\tmgr->id = OMAP_DSS_CHANNEL_LCD;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmgr->name = \"tv\";\n\t\t\tmgr->id = OMAP_DSS_CHANNEL_DIGIT;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmgr->name = \"lcd2\";\n\t\t\tmgr->id = OMAP_DSS_CHANNEL_LCD2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmgr->name = \"lcd3\";\n\t\t\tmgr->id = OMAP_DSS_CHANNEL_LCD3;\n\t\t\tbreak;\n\t\t}\n\n\t\tmgr->supported_displays =\n\t\t\tdss_feat_get_supported_displays(mgr->id);\n\t\tmgr->supported_outputs =\n\t\t\tdss_feat_get_supported_outputs(mgr->id);\n\n\t\tINIT_LIST_HEAD(&mgr->overlays);\n\t}\n\n\treturn 0;\n}\n\nint dss_init_overlay_managers_sysfs(struct platform_device *pdev)\n{\n\tint i, r;\n\n\tfor (i = 0; i < num_managers; ++i) {\n\t\tstruct omap_overlay_manager *mgr = &managers[i];\n\n\t\tr = dss_manager_kobj_init(mgr, pdev);\n\t\tif (r)\n\t\t\tDSSERR(\"failed to create sysfs file\\n\");\n\t}\n\n\treturn 0;\n}\n\nvoid dss_uninit_overlay_managers(void)\n{\n\tkfree(managers);\n\tmanagers = NULL;\n\tnum_managers = 0;\n}\n\nvoid dss_uninit_overlay_managers_sysfs(struct platform_device *pdev)\n{\n\tint i;\n\n\tfor (i = 0; i < num_managers; ++i) {\n\t\tstruct omap_overlay_manager *mgr = &managers[i];\n\n\t\tdss_manager_kobj_uninit(mgr);\n\t}\n}\n\nint omap_dss_get_num_overlay_managers(void)\n{\n\treturn num_managers;\n}\nEXPORT_SYMBOL(omap_dss_get_num_overlay_managers);\n\nstruct omap_overlay_manager *omap_dss_get_overlay_manager(int num)\n{\n\tif (num >= num_managers)\n\t\treturn NULL;\n\n\treturn &managers[num];\n}\nEXPORT_SYMBOL(omap_dss_get_overlay_manager);\n\nint dss_mgr_simple_check(struct omap_overlay_manager *mgr,\n\t\tconst struct omap_overlay_manager_info *info)\n{\n\tif (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER)) {\n\t\t \n\t\tif (info->partial_alpha_enabled && info->trans_enabled\n\t\t\t&& info->trans_key_type != OMAP_DSS_COLOR_KEY_GFX_DST) {\n\t\t\tDSSERR(\"check_manager: illegal transparency key\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dss_mgr_check_zorder(struct omap_overlay_manager *mgr,\n\t\tstruct omap_overlay_info **overlay_infos)\n{\n\tstruct omap_overlay *ovl1, *ovl2;\n\tstruct omap_overlay_info *info1, *info2;\n\n\tlist_for_each_entry(ovl1, &mgr->overlays, list) {\n\t\tinfo1 = overlay_infos[ovl1->id];\n\n\t\tif (info1 == NULL)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(ovl2, &mgr->overlays, list) {\n\t\t\tif (ovl1 == ovl2)\n\t\t\t\tcontinue;\n\n\t\t\tinfo2 = overlay_infos[ovl2->id];\n\n\t\t\tif (info2 == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (info1->zorder == info2->zorder) {\n\t\t\t\tDSSERR(\"overlays %d and %d have the same \"\n\t\t\t\t\t\t\"zorder %d\\n\",\n\t\t\t\t\tovl1->id, ovl2->id, info1->zorder);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint dss_mgr_check_timings(struct omap_overlay_manager *mgr,\n\t\tconst struct omap_video_timings *timings)\n{\n\tif (!dispc_mgr_timings_ok(mgr->id, timings)) {\n\t\tDSSERR(\"check_manager: invalid timings\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dss_mgr_check_lcd_config(struct omap_overlay_manager *mgr,\n\t\tconst struct dss_lcd_mgr_config *config)\n{\n\tstruct dispc_clock_info cinfo = config->clock_info;\n\tint dl = config->video_port_width;\n\tbool stallmode = config->stallmode;\n\tbool fifohandcheck = config->fifohandcheck;\n\n\tif (cinfo.lck_div < 1 || cinfo.lck_div > 255)\n\t\treturn -EINVAL;\n\n\tif (cinfo.pck_div < 1 || cinfo.pck_div > 255)\n\t\treturn -EINVAL;\n\n\tif (dl != 12 && dl != 16 && dl != 18 && dl != 24)\n\t\treturn -EINVAL;\n\n\t \n\tif (!stallmode && fifohandcheck)\n\t\treturn -EINVAL;\n\n\t \n\n\treturn 0;\n}\n\nint dss_mgr_check(struct omap_overlay_manager *mgr,\n\t\tstruct omap_overlay_manager_info *info,\n\t\tconst struct omap_video_timings *mgr_timings,\n\t\tconst struct dss_lcd_mgr_config *lcd_config,\n\t\tstruct omap_overlay_info **overlay_infos)\n{\n\tstruct omap_overlay *ovl;\n\tint r;\n\n\tif (dss_has_feature(FEAT_ALPHA_FREE_ZORDER)) {\n\t\tr = dss_mgr_check_zorder(mgr, overlay_infos);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = dss_mgr_check_timings(mgr, mgr_timings);\n\tif (r)\n\t\treturn r;\n\n\tr = dss_mgr_check_lcd_config(mgr, lcd_config);\n\tif (r)\n\t\treturn r;\n\n\tlist_for_each_entry(ovl, &mgr->overlays, list) {\n\t\tstruct omap_overlay_info *oi;\n\t\tint r;\n\n\t\toi = overlay_infos[ovl->id];\n\n\t\tif (oi == NULL)\n\t\t\tcontinue;\n\n\t\tr = dss_ovl_check(ovl, oi, mgr_timings);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}