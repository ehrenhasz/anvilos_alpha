{
  "module_name": "sdi.c",
  "hash_id": "a101d6d55c38f68709fd1ab3db59ffe14d99c85b2b3a49ff048a516d8ec478a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/sdi.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"SDI\"\n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/regulator/consumer.h>\n#include <linux/export.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <linux/of.h>\n#include <linux/component.h>\n\n#include <video/omapfb_dss.h>\n#include \"dss.h\"\n\nstatic struct {\n\tstruct platform_device *pdev;\n\n\tbool update_enabled;\n\tstruct regulator *vdds_sdi_reg;\n\n\tstruct dss_lcd_mgr_config mgr_config;\n\tstruct omap_video_timings timings;\n\tint datapairs;\n\n\tstruct omap_dss_device output;\n\n\tbool port_initialized;\n} sdi;\n\nstruct sdi_clk_calc_ctx {\n\tunsigned long pck_min, pck_max;\n\n\tunsigned long fck;\n\tstruct dispc_clock_info dispc_cinfo;\n};\n\nstatic bool dpi_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\n\t\tunsigned long pck, void *data)\n{\n\tstruct sdi_clk_calc_ctx *ctx = data;\n\n\tctx->dispc_cinfo.lck_div = lckd;\n\tctx->dispc_cinfo.pck_div = pckd;\n\tctx->dispc_cinfo.lck = lck;\n\tctx->dispc_cinfo.pck = pck;\n\n\treturn true;\n}\n\nstatic bool dpi_calc_dss_cb(unsigned long fck, void *data)\n{\n\tstruct sdi_clk_calc_ctx *ctx = data;\n\n\tctx->fck = fck;\n\n\treturn dispc_div_calc(fck, ctx->pck_min, ctx->pck_max,\n\t\t\tdpi_calc_dispc_cb, ctx);\n}\n\nstatic int sdi_calc_clock_div(unsigned long pclk,\n\t\tunsigned long *fck,\n\t\tstruct dispc_clock_info *dispc_cinfo)\n{\n\tint i;\n\tstruct sdi_clk_calc_ctx ctx;\n\n\t \n\n\tfor (i = 0; i < 10; ++i) {\n\t\tbool ok;\n\n\t\tmemset(&ctx, 0, sizeof(ctx));\n\t\tif (pclk > 1000 * i * i * i)\n\t\t\tctx.pck_min = max(pclk - 1000 * i * i * i, 0lu);\n\t\telse\n\t\t\tctx.pck_min = 0;\n\t\tctx.pck_max = pclk + 1000 * i * i * i;\n\n\t\tok = dss_div_calc(pclk, ctx.pck_min, dpi_calc_dss_cb, &ctx);\n\t\tif (ok) {\n\t\t\t*fck = ctx.fck;\n\t\t\t*dispc_cinfo = ctx.dispc_cinfo;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void sdi_config_lcd_manager(struct omap_dss_device *dssdev)\n{\n\tstruct omap_overlay_manager *mgr = sdi.output.manager;\n\n\tsdi.mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\n\n\tsdi.mgr_config.stallmode = false;\n\tsdi.mgr_config.fifohandcheck = false;\n\n\tsdi.mgr_config.video_port_width = 24;\n\tsdi.mgr_config.lcden_sig_polarity = 1;\n\n\tdss_mgr_set_lcd_config(mgr, &sdi.mgr_config);\n}\n\nstatic int sdi_display_enable(struct omap_dss_device *dssdev)\n{\n\tstruct omap_dss_device *out = &sdi.output;\n\tstruct omap_video_timings *t = &sdi.timings;\n\tunsigned long fck;\n\tstruct dispc_clock_info dispc_cinfo;\n\tunsigned long pck;\n\tint r;\n\n\tif (out->manager == NULL) {\n\t\tDSSERR(\"failed to enable display: no output/manager\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tr = regulator_enable(sdi.vdds_sdi_reg);\n\tif (r)\n\t\tgoto err_reg_enable;\n\n\tr = dispc_runtime_get();\n\tif (r)\n\t\tgoto err_get_dispc;\n\n\t \n\tt->data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\n\tt->sync_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\n\n\tr = sdi_calc_clock_div(t->pixelclock, &fck, &dispc_cinfo);\n\tif (r)\n\t\tgoto err_calc_clock_div;\n\n\tsdi.mgr_config.clock_info = dispc_cinfo;\n\n\tpck = fck / dispc_cinfo.lck_div / dispc_cinfo.pck_div;\n\n\tif (pck != t->pixelclock) {\n\t\tDSSWARN(\"Could not find exact pixel clock. Requested %d Hz, got %lu Hz\\n\",\n\t\t\tt->pixelclock, pck);\n\n\t\tt->pixelclock = pck;\n\t}\n\n\n\tdss_mgr_set_timings(out->manager, t);\n\n\tr = dss_set_fck_rate(fck);\n\tif (r)\n\t\tgoto err_set_dss_clock_div;\n\n\tsdi_config_lcd_manager(dssdev);\n\n\t \n\tdispc_mgr_set_clock_div(out->manager->id, &sdi.mgr_config.clock_info);\n\n\tdss_sdi_init(sdi.datapairs);\n\tr = dss_sdi_enable();\n\tif (r)\n\t\tgoto err_sdi_enable;\n\tmdelay(2);\n\n\tr = dss_mgr_enable(out->manager);\n\tif (r)\n\t\tgoto err_mgr_enable;\n\n\treturn 0;\n\nerr_mgr_enable:\n\tdss_sdi_disable();\nerr_sdi_enable:\nerr_set_dss_clock_div:\nerr_calc_clock_div:\n\tdispc_runtime_put();\nerr_get_dispc:\n\tregulator_disable(sdi.vdds_sdi_reg);\nerr_reg_enable:\n\treturn r;\n}\n\nstatic void sdi_display_disable(struct omap_dss_device *dssdev)\n{\n\tstruct omap_overlay_manager *mgr = sdi.output.manager;\n\n\tdss_mgr_disable(mgr);\n\n\tdss_sdi_disable();\n\n\tdispc_runtime_put();\n\n\tregulator_disable(sdi.vdds_sdi_reg);\n}\n\nstatic void sdi_set_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tsdi.timings = *timings;\n}\n\nstatic void sdi_get_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\t*timings = sdi.timings;\n}\n\nstatic int sdi_check_timings(struct omap_dss_device *dssdev,\n\t\t\tstruct omap_video_timings *timings)\n{\n\tstruct omap_overlay_manager *mgr = sdi.output.manager;\n\n\tif (mgr && !dispc_mgr_timings_ok(mgr->id, timings))\n\t\treturn -EINVAL;\n\n\tif (timings->pixelclock == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void sdi_set_datapairs(struct omap_dss_device *dssdev, int datapairs)\n{\n\tsdi.datapairs = datapairs;\n}\n\nstatic int sdi_init_regulator(void)\n{\n\tstruct regulator *vdds_sdi;\n\n\tif (sdi.vdds_sdi_reg)\n\t\treturn 0;\n\n\tvdds_sdi = devm_regulator_get(&sdi.pdev->dev, \"vdds_sdi\");\n\tif (IS_ERR(vdds_sdi)) {\n\t\tif (PTR_ERR(vdds_sdi) != -EPROBE_DEFER)\n\t\t\tDSSERR(\"can't get VDDS_SDI regulator\\n\");\n\t\treturn PTR_ERR(vdds_sdi);\n\t}\n\n\tsdi.vdds_sdi_reg = vdds_sdi;\n\n\treturn 0;\n}\n\nstatic int sdi_connect(struct omap_dss_device *dssdev,\n\t\tstruct omap_dss_device *dst)\n{\n\tstruct omap_overlay_manager *mgr;\n\tint r;\n\n\tr = sdi_init_regulator();\n\tif (r)\n\t\treturn r;\n\n\tmgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);\n\tif (!mgr)\n\t\treturn -ENODEV;\n\n\tr = dss_mgr_connect(mgr, dssdev);\n\tif (r)\n\t\treturn r;\n\n\tr = omapdss_output_set_device(dssdev, dst);\n\tif (r) {\n\t\tDSSERR(\"failed to connect output to new device: %s\\n\",\n\t\t\t\tdst->name);\n\t\tdss_mgr_disconnect(mgr, dssdev);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void sdi_disconnect(struct omap_dss_device *dssdev,\n\t\tstruct omap_dss_device *dst)\n{\n\tWARN_ON(dst != dssdev->dst);\n\n\tif (dst != dssdev->dst)\n\t\treturn;\n\n\tomapdss_output_unset_device(dssdev);\n\n\tif (dssdev->manager)\n\t\tdss_mgr_disconnect(dssdev->manager, dssdev);\n}\n\nstatic const struct omapdss_sdi_ops sdi_ops = {\n\t.connect = sdi_connect,\n\t.disconnect = sdi_disconnect,\n\n\t.enable = sdi_display_enable,\n\t.disable = sdi_display_disable,\n\n\t.check_timings = sdi_check_timings,\n\t.set_timings = sdi_set_timings,\n\t.get_timings = sdi_get_timings,\n\n\t.set_datapairs = sdi_set_datapairs,\n};\n\nstatic void sdi_init_output(struct platform_device *pdev)\n{\n\tstruct omap_dss_device *out = &sdi.output;\n\n\tout->dev = &pdev->dev;\n\tout->id = OMAP_DSS_OUTPUT_SDI;\n\tout->output_type = OMAP_DISPLAY_TYPE_SDI;\n\tout->name = \"sdi.0\";\n\tout->dispc_channel = OMAP_DSS_CHANNEL_LCD;\n\t \n\tout->port_num = 1;\n\tout->ops.sdi = &sdi_ops;\n\tout->owner = THIS_MODULE;\n\n\tomapdss_register_output(out);\n}\n\nstatic void sdi_uninit_output(struct platform_device *pdev)\n{\n\tstruct omap_dss_device *out = &sdi.output;\n\n\tomapdss_unregister_output(out);\n}\n\nstatic int sdi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tsdi.pdev = pdev;\n\n\tsdi_init_output(pdev);\n\n\treturn 0;\n}\n\nstatic void sdi_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tsdi_uninit_output(pdev);\n}\n\nstatic const struct component_ops sdi_component_ops = {\n\t.bind\t= sdi_bind,\n\t.unbind\t= sdi_unbind,\n};\n\nstatic int sdi_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &sdi_component_ops);\n}\n\nstatic void sdi_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &sdi_component_ops);\n}\n\nstatic struct platform_driver omap_sdi_driver = {\n\t.probe\t\t= sdi_probe,\n\t.remove_new     = sdi_remove,\n\t.driver         = {\n\t\t.name   = \"omapdss_sdi\",\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nint __init sdi_init_platform_driver(void)\n{\n\treturn platform_driver_register(&omap_sdi_driver);\n}\n\nvoid sdi_uninit_platform_driver(void)\n{\n\tplatform_driver_unregister(&omap_sdi_driver);\n}\n\nint sdi_init_port(struct platform_device *pdev, struct device_node *port)\n{\n\tstruct device_node *ep;\n\tu32 datapairs;\n\tint r;\n\n\tep = omapdss_of_get_next_endpoint(port, NULL);\n\tif (!ep)\n\t\treturn 0;\n\n\tr = of_property_read_u32(ep, \"datapairs\", &datapairs);\n\tif (r) {\n\t\tDSSERR(\"failed to parse datapairs\\n\");\n\t\tgoto err_datapairs;\n\t}\n\n\tsdi.datapairs = datapairs;\n\n\tof_node_put(ep);\n\n\tsdi.pdev = pdev;\n\n\tsdi_init_output(pdev);\n\n\tsdi.port_initialized = true;\n\n\treturn 0;\n\nerr_datapairs:\n\tof_node_put(ep);\n\n\treturn r;\n}\n\nvoid sdi_uninit_port(struct device_node *port)\n{\n\tif (!sdi.port_initialized)\n\t\treturn;\n\n\tsdi_uninit_output(sdi.pdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}