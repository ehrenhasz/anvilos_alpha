{
  "module_name": "dss.h",
  "hash_id": "fcba3da4a63bd323514a62ef98e03b40af3b3ab025ed8f69c4a767955e334963",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/dss.h",
  "human_readable_source": " \n \n\n#ifndef __OMAP2_DSS_H\n#define __OMAP2_DSS_H\n\n#include <linux/interrupt.h>\n\n#ifdef pr_fmt\n#undef pr_fmt\n#endif\n\n#ifdef DSS_SUBSYS_NAME\n#define pr_fmt(fmt) DSS_SUBSYS_NAME \": \" fmt\n#else\n#define pr_fmt(fmt) fmt\n#endif\n\n#define DSSDBG(format, ...) \\\n\tpr_debug(format, ## __VA_ARGS__)\n\n#ifdef DSS_SUBSYS_NAME\n#define DSSERR(format, ...) \\\n\tprintk(KERN_ERR \"omapdss \" DSS_SUBSYS_NAME \" error: \" format, \\\n\t## __VA_ARGS__)\n#else\n#define DSSERR(format, ...) \\\n\tprintk(KERN_ERR \"omapdss error: \" format, ## __VA_ARGS__)\n#endif\n\n#ifdef DSS_SUBSYS_NAME\n#define DSSINFO(format, ...) \\\n\tprintk(KERN_INFO \"omapdss \" DSS_SUBSYS_NAME \": \" format, \\\n\t## __VA_ARGS__)\n#else\n#define DSSINFO(format, ...) \\\n\tprintk(KERN_INFO \"omapdss: \" format, ## __VA_ARGS__)\n#endif\n\n#ifdef DSS_SUBSYS_NAME\n#define DSSWARN(format, ...) \\\n\tprintk(KERN_WARNING \"omapdss \" DSS_SUBSYS_NAME \": \" format, \\\n\t## __VA_ARGS__)\n#else\n#define DSSWARN(format, ...) \\\n\tprintk(KERN_WARNING \"omapdss: \" format, ## __VA_ARGS__)\n#endif\n\n \n#define FLD_MASK(start, end)\t(((1 << ((start) - (end) + 1)) - 1) << (end))\n#define FLD_VAL(val, start, end) (((val) << (end)) & FLD_MASK(start, end))\n#define FLD_GET(val, start, end) (((val) & FLD_MASK(start, end)) >> (end))\n#define FLD_MOD(orig, val, start, end) \\\n\t(((orig) & ~FLD_MASK(start, end)) | FLD_VAL(val, start, end))\n\nenum omap_dss_clk_source {\n\tOMAP_DSS_CLK_SRC_FCK = 0,\t\t \n\tOMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC,\t \n\tOMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI,\t \n\tOMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC,\t \n\tOMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI,\t \n};\n\nenum dss_io_pad_mode {\n\tDSS_IO_PAD_MODE_RESET,\n\tDSS_IO_PAD_MODE_RFBI,\n\tDSS_IO_PAD_MODE_BYPASS,\n};\n\nenum dss_hdmi_venc_clk_source_select {\n\tDSS_VENC_TV_CLK = 0,\n\tDSS_HDMI_M_PCLK = 1,\n};\n\nenum dss_dsi_content_type {\n\tDSS_DSI_CONTENT_DCS,\n\tDSS_DSI_CONTENT_GENERIC,\n};\n\nenum dss_pll_id {\n\tDSS_PLL_DSI1,\n\tDSS_PLL_DSI2,\n\tDSS_PLL_HDMI,\n\tDSS_PLL_VIDEO1,\n\tDSS_PLL_VIDEO2,\n};\n\nstruct dss_pll;\n\n#define DSS_PLL_MAX_HSDIVS 4\n\n \nstruct dss_pll_clock_info {\n\t \n\tunsigned long fint;\n\tunsigned long clkdco;\n\tunsigned long clkout[DSS_PLL_MAX_HSDIVS];\n\n\t \n\tu16 n;\n\tu16 m;\n\tu32 mf;\n\tu16 mX[DSS_PLL_MAX_HSDIVS];\n\tu16 sd;\n};\n\nstruct dss_pll_ops {\n\tint (*enable)(struct dss_pll *pll);\n\tvoid (*disable)(struct dss_pll *pll);\n\tint (*set_config)(struct dss_pll *pll,\n\t\tconst struct dss_pll_clock_info *cinfo);\n};\n\nstruct dss_pll_hw {\n\tunsigned n_max;\n\tunsigned m_min;\n\tunsigned m_max;\n\tunsigned mX_max;\n\n\tunsigned long fint_min, fint_max;\n\tunsigned long clkdco_min, clkdco_low, clkdco_max;\n\n\tu8 n_msb, n_lsb;\n\tu8 m_msb, m_lsb;\n\tu8 mX_msb[DSS_PLL_MAX_HSDIVS], mX_lsb[DSS_PLL_MAX_HSDIVS];\n\n\tbool has_stopmode;\n\tbool has_freqsel;\n\tbool has_selfreqdco;\n\tbool has_refsel;\n};\n\nstruct dss_pll {\n\tconst char *name;\n\tenum dss_pll_id id;\n\n\tstruct clk *clkin;\n\tstruct regulator *regulator;\n\n\tvoid __iomem *base;\n\n\tconst struct dss_pll_hw *hw;\n\n\tconst struct dss_pll_ops *ops;\n\n\tstruct dss_pll_clock_info cinfo;\n};\n\nstruct dispc_clock_info {\n\t \n\tunsigned long lck;\n\tunsigned long pck;\n\n\t \n\tu16 lck_div;\n\tu16 pck_div;\n};\n\nstruct dss_lcd_mgr_config {\n\tenum dss_io_pad_mode io_pad_mode;\n\n\tbool stallmode;\n\tbool fifohandcheck;\n\n\tstruct dispc_clock_info clock_info;\n\n\tint video_port_width;\n\n\tint lcden_sig_polarity;\n};\n\nstruct seq_file;\nstruct platform_device;\n\n \nstruct platform_device *dss_get_core_pdev(void);\nint dss_dsi_enable_pads(int dsi_id, unsigned lane_mask);\nvoid dss_dsi_disable_pads(int dsi_id, unsigned lane_mask);\nint dss_set_min_bus_tput(struct device *dev, unsigned long tput);\nvoid dss_debugfs_create_file(const char *name, void (*write)(struct seq_file *));\n\n \nint dss_suspend_all_devices(void);\nint dss_resume_all_devices(void);\nvoid dss_disable_all_devices(void);\n\nint display_init_sysfs(struct platform_device *pdev);\nvoid display_uninit_sysfs(struct platform_device *pdev);\n\n \nint dss_init_overlay_managers(void);\nvoid dss_uninit_overlay_managers(void);\nint dss_init_overlay_managers_sysfs(struct platform_device *pdev);\nvoid dss_uninit_overlay_managers_sysfs(struct platform_device *pdev);\nint dss_mgr_simple_check(struct omap_overlay_manager *mgr,\n\t\tconst struct omap_overlay_manager_info *info);\nint dss_mgr_check_timings(struct omap_overlay_manager *mgr,\n\t\tconst struct omap_video_timings *timings);\nint dss_mgr_check(struct omap_overlay_manager *mgr,\n\t\tstruct omap_overlay_manager_info *info,\n\t\tconst struct omap_video_timings *mgr_timings,\n\t\tconst struct dss_lcd_mgr_config *config,\n\t\tstruct omap_overlay_info **overlay_infos);\n\nstatic inline bool dss_mgr_is_lcd(enum omap_channel id)\n{\n\tif (id == OMAP_DSS_CHANNEL_LCD || id == OMAP_DSS_CHANNEL_LCD2 ||\n\t\t\tid == OMAP_DSS_CHANNEL_LCD3)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint dss_manager_kobj_init(struct omap_overlay_manager *mgr,\n\t\tstruct platform_device *pdev);\nvoid dss_manager_kobj_uninit(struct omap_overlay_manager *mgr);\n\n \nvoid dss_init_overlays(struct platform_device *pdev);\nvoid dss_uninit_overlays(struct platform_device *pdev);\nvoid dss_overlay_setup_dispc_manager(struct omap_overlay_manager *mgr);\nint dss_ovl_simple_check(struct omap_overlay *ovl,\n\t\tconst struct omap_overlay_info *info);\nint dss_ovl_check(struct omap_overlay *ovl, struct omap_overlay_info *info,\n\t\tconst struct omap_video_timings *mgr_timings);\nbool dss_ovl_use_replication(struct dss_lcd_mgr_config config,\n\t\tenum omap_color_mode mode);\nint dss_overlay_kobj_init(struct omap_overlay *ovl,\n\t\tstruct platform_device *pdev);\nvoid dss_overlay_kobj_uninit(struct omap_overlay *ovl);\n\n \nint dss_init_platform_driver(void) __init;\nvoid dss_uninit_platform_driver(void);\n\nint dss_runtime_get(void);\nvoid dss_runtime_put(void);\n\nunsigned long dss_get_dispc_clk_rate(void);\nint dss_dpi_select_source(int port, enum omap_channel channel);\nvoid dss_select_hdmi_venc_clk_source(enum dss_hdmi_venc_clk_source_select);\nenum dss_hdmi_venc_clk_source_select dss_get_hdmi_venc_clk_source(void);\nconst char *dss_get_generic_clk_source_name(enum omap_dss_clk_source clk_src);\nvoid dss_dump_clocks(struct seq_file *s);\n\n \nstruct dss_pll *dss_video_pll_init(struct platform_device *pdev, int id,\n\tstruct regulator *regulator);\nvoid dss_video_pll_uninit(struct dss_pll *pll);\n\n \nstruct device_node *dss_of_port_get_parent_device(struct device_node *port);\nu32 dss_of_port_get_port_number(struct device_node *port);\n\n#if defined(CONFIG_FB_OMAP2_DSS_DEBUGFS)\nvoid dss_debug_dump_clocks(struct seq_file *s);\n#endif\n\nvoid dss_ctrl_pll_enable(enum dss_pll_id pll_id, bool enable);\nvoid dss_ctrl_pll_set_control_mux(enum dss_pll_id pll_id,\n\tenum omap_channel channel);\n\nvoid dss_sdi_init(int datapairs);\nint dss_sdi_enable(void);\nvoid dss_sdi_disable(void);\n\nvoid dss_select_dsi_clk_source(int dsi_module,\n\t\tenum omap_dss_clk_source clk_src);\nvoid dss_select_lcd_clk_source(enum omap_channel channel,\n\t\tenum omap_dss_clk_source clk_src);\nenum omap_dss_clk_source dss_get_dispc_clk_source(void);\nenum omap_dss_clk_source dss_get_dsi_clk_source(int dsi_module);\nenum omap_dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel);\n\nvoid dss_set_venc_output(enum omap_dss_venc_type type);\nvoid dss_set_dac_pwrdn_bgz(bool enable);\n\nint dss_set_fck_rate(unsigned long rate);\n\ntypedef bool (*dss_div_calc_func)(unsigned long fck, void *data);\nbool dss_div_calc(unsigned long pck, unsigned long fck_min,\n\t\tdss_div_calc_func func, void *data);\n\n \nint sdi_init_platform_driver(void) __init;\nvoid sdi_uninit_platform_driver(void);\n\n#ifdef CONFIG_FB_OMAP2_DSS_SDI\nint sdi_init_port(struct platform_device *pdev, struct device_node *port);\nvoid sdi_uninit_port(struct device_node *port);\n#else\nstatic inline int sdi_init_port(struct platform_device *pdev,\n\t\tstruct device_node *port)\n{\n\treturn 0;\n}\nstatic inline void sdi_uninit_port(struct device_node *port)\n{\n}\n#endif\n\n \n\n#ifdef CONFIG_FB_OMAP2_DSS_DSI\n\nstruct dentry;\nstruct file_operations;\n\nint dsi_init_platform_driver(void) __init;\nvoid dsi_uninit_platform_driver(void);\n\nvoid dsi_dump_clocks(struct seq_file *s);\n\nvoid dsi_irq_handler(void);\nu8 dsi_get_pixel_size(enum omap_dss_dsi_pixel_format fmt);\n\n#else\nstatic inline u8 dsi_get_pixel_size(enum omap_dss_dsi_pixel_format fmt)\n{\n\tWARN(1, \"%s: DSI not compiled in, returning pixel_size as 0\\n\",\n\t     __func__);\n\treturn 0;\n}\n#endif\n\n \nint dpi_init_platform_driver(void) __init;\nvoid dpi_uninit_platform_driver(void);\n\n#ifdef CONFIG_FB_OMAP2_DSS_DPI\nint dpi_init_port(struct platform_device *pdev, struct device_node *port);\nvoid dpi_uninit_port(struct device_node *port);\n#else\nstatic inline int dpi_init_port(struct platform_device *pdev,\n\t\tstruct device_node *port)\n{\n\treturn 0;\n}\nstatic inline void dpi_uninit_port(struct device_node *port)\n{\n}\n#endif\n\n \nint dispc_init_platform_driver(void) __init;\nvoid dispc_uninit_platform_driver(void);\nvoid dispc_dump_clocks(struct seq_file *s);\n\nvoid dispc_enable_sidle(void);\nvoid dispc_disable_sidle(void);\n\nvoid dispc_lcd_enable_signal(bool enable);\nvoid dispc_pck_free_enable(bool enable);\nvoid dispc_enable_fifomerge(bool enable);\nvoid dispc_enable_gamma_table(bool enable);\n\ntypedef bool (*dispc_div_calc_func)(int lckd, int pckd, unsigned long lck,\n\t\tunsigned long pck, void *data);\nbool dispc_div_calc(unsigned long dispc,\n\t\tunsigned long pck_min, unsigned long pck_max,\n\t\tdispc_div_calc_func func, void *data);\n\nbool dispc_mgr_timings_ok(enum omap_channel channel,\n\t\tconst struct omap_video_timings *timings);\nint dispc_calc_clock_rates(unsigned long dispc_fclk_rate,\n\t\tstruct dispc_clock_info *cinfo);\n\n\nvoid dispc_ovl_set_fifo_threshold(enum omap_plane plane, u32 low, u32 high);\nvoid dispc_ovl_compute_fifo_thresholds(enum omap_plane plane,\n\t\tu32 *fifo_low, u32 *fifo_high, bool use_fifomerge,\n\t\tbool manual_update);\n\nvoid dispc_mgr_set_clock_div(enum omap_channel channel,\n\t\tconst struct dispc_clock_info *cinfo);\nint dispc_mgr_get_clock_div(enum omap_channel channel,\n\t\tstruct dispc_clock_info *cinfo);\nvoid dispc_set_tv_pclk(unsigned long pclk);\n\nu32 dispc_read_irqstatus(void);\nvoid dispc_clear_irqstatus(u32 mask);\nu32 dispc_read_irqenable(void);\nvoid dispc_write_irqenable(u32 mask);\n\nint dispc_request_irq(irq_handler_t handler, void *dev_id);\nvoid dispc_free_irq(void *dev_id);\n\nint dispc_runtime_get(void);\nvoid dispc_runtime_put(void);\n\nvoid dispc_mgr_enable(enum omap_channel channel, bool enable);\nbool dispc_mgr_is_enabled(enum omap_channel channel);\nu32 dispc_mgr_get_vsync_irq(enum omap_channel channel);\nu32 dispc_mgr_get_framedone_irq(enum omap_channel channel);\nu32 dispc_mgr_get_sync_lost_irq(enum omap_channel channel);\nbool dispc_mgr_go_busy(enum omap_channel channel);\nvoid dispc_mgr_go(enum omap_channel channel);\nvoid dispc_mgr_set_lcd_config(enum omap_channel channel,\n\t\tconst struct dss_lcd_mgr_config *config);\nvoid dispc_mgr_set_timings(enum omap_channel channel,\n\t\tconst struct omap_video_timings *timings);\nvoid dispc_mgr_setup(enum omap_channel channel,\n\t\tconst struct omap_overlay_manager_info *info);\n\nint dispc_ovl_check(enum omap_plane plane, enum omap_channel channel,\n\t\tconst struct omap_overlay_info *oi,\n\t\tconst struct omap_video_timings *timings,\n\t\tint *x_predecim, int *y_predecim);\n\nint dispc_ovl_enable(enum omap_plane plane, bool enable);\nbool dispc_ovl_enabled(enum omap_plane plane);\nvoid dispc_ovl_set_channel_out(enum omap_plane plane,\n\t\tenum omap_channel channel);\nint dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,\n\t\tbool replication, const struct omap_video_timings *mgr_timings,\n\t\tbool mem_to_mem);\n\n \nint venc_init_platform_driver(void) __init;\nvoid venc_uninit_platform_driver(void);\n\n \nint hdmi4_init_platform_driver(void) __init;\nvoid hdmi4_uninit_platform_driver(void);\n\nint hdmi5_init_platform_driver(void) __init;\nvoid hdmi5_uninit_platform_driver(void);\n\n\n#ifdef CONFIG_FB_OMAP2_DSS_COLLECT_IRQ_STATS\nstatic inline void dss_collect_irq_stats(u32 irqstatus, unsigned *irq_arr)\n{\n\tint b;\n\tfor (b = 0; b < 32; ++b) {\n\t\tif (irqstatus & (1 << b))\n\t\t\tirq_arr[b]++;\n\t}\n}\n#endif\n\n \ntypedef bool (*dss_pll_calc_func)(int n, int m, unsigned long fint,\n\t\tunsigned long clkdco, void *data);\ntypedef bool (*dss_hsdiv_calc_func)(int m_dispc, unsigned long dispc,\n\t\tvoid *data);\n\nint dss_pll_register(struct dss_pll *pll);\nvoid dss_pll_unregister(struct dss_pll *pll);\nstruct dss_pll *dss_pll_find(const char *name);\nint dss_pll_enable(struct dss_pll *pll);\nvoid dss_pll_disable(struct dss_pll *pll);\nint dss_pll_set_config(struct dss_pll *pll,\n\t\tconst struct dss_pll_clock_info *cinfo);\n\nbool dss_pll_hsdiv_calc(const struct dss_pll *pll, unsigned long clkdco,\n\t\tunsigned long out_min, unsigned long out_max,\n\t\tdss_hsdiv_calc_func func, void *data);\nbool dss_pll_calc(const struct dss_pll *pll, unsigned long clkin,\n\t\tunsigned long pll_min, unsigned long pll_max,\n\t\tdss_pll_calc_func func, void *data);\nint dss_pll_write_config_type_a(struct dss_pll *pll,\n\t\tconst struct dss_pll_clock_info *cinfo);\nint dss_pll_write_config_type_b(struct dss_pll *pll,\n\t\tconst struct dss_pll_clock_info *cinfo);\nint dss_pll_wait_reset_done(struct dss_pll *pll);\n\n \n\nstruct dss_mgr_ops {\n\tint (*connect)(struct omap_overlay_manager *mgr,\n\t\tstruct omap_dss_device *dst);\n\tvoid (*disconnect)(struct omap_overlay_manager *mgr,\n\t\tstruct omap_dss_device *dst);\n\n\tvoid (*start_update)(struct omap_overlay_manager *mgr);\n\tint (*enable)(struct omap_overlay_manager *mgr);\n\tvoid (*disable)(struct omap_overlay_manager *mgr);\n\tvoid (*set_timings)(struct omap_overlay_manager *mgr,\n\t\t\tconst struct omap_video_timings *timings);\n\tvoid (*set_lcd_config)(struct omap_overlay_manager *mgr,\n\t\t\tconst struct dss_lcd_mgr_config *config);\n\tint (*register_framedone_handler)(struct omap_overlay_manager *mgr,\n\t\t\tvoid (*handler)(void *), void *data);\n\tvoid (*unregister_framedone_handler)(struct omap_overlay_manager *mgr,\n\t\t\tvoid (*handler)(void *), void *data);\n};\n\nint dss_install_mgr_ops(const struct dss_mgr_ops *mgr_ops);\nvoid dss_uninstall_mgr_ops(void);\n\nint dss_mgr_connect(struct omap_overlay_manager *mgr,\n\t\tstruct omap_dss_device *dst);\nvoid dss_mgr_disconnect(struct omap_overlay_manager *mgr,\n\t\tstruct omap_dss_device *dst);\nvoid dss_mgr_set_timings(struct omap_overlay_manager *mgr,\n\t\tconst struct omap_video_timings *timings);\nvoid dss_mgr_set_lcd_config(struct omap_overlay_manager *mgr,\n\t\tconst struct dss_lcd_mgr_config *config);\nint dss_mgr_enable(struct omap_overlay_manager *mgr);\nvoid dss_mgr_disable(struct omap_overlay_manager *mgr);\nvoid dss_mgr_start_update(struct omap_overlay_manager *mgr);\nint dss_mgr_register_framedone_handler(struct omap_overlay_manager *mgr,\n\t\tvoid (*handler)(void *), void *data);\nvoid dss_mgr_unregister_framedone_handler(struct omap_overlay_manager *mgr,\n\t\tvoid (*handler)(void *), void *data);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}