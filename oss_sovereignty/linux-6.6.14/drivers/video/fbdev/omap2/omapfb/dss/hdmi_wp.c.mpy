{
  "module_name": "hdmi_wp.c",
  "hash_id": "728846472f2fe5e4c140ed135b875b1bc137dff9415aabf0bb4a3f76fafcec58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/hdmi_wp.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"HDMIWP\"\n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"hdmi.h\"\n\nvoid hdmi_wp_dump(struct hdmi_wp_data *wp, struct seq_file *s)\n{\n#define DUMPREG(r) seq_printf(s, \"%-35s %08x\\n\", #r, hdmi_read_reg(wp->base, r))\n\n\tDUMPREG(HDMI_WP_REVISION);\n\tDUMPREG(HDMI_WP_SYSCONFIG);\n\tDUMPREG(HDMI_WP_IRQSTATUS_RAW);\n\tDUMPREG(HDMI_WP_IRQSTATUS);\n\tDUMPREG(HDMI_WP_IRQENABLE_SET);\n\tDUMPREG(HDMI_WP_IRQENABLE_CLR);\n\tDUMPREG(HDMI_WP_IRQWAKEEN);\n\tDUMPREG(HDMI_WP_PWR_CTRL);\n\tDUMPREG(HDMI_WP_DEBOUNCE);\n\tDUMPREG(HDMI_WP_VIDEO_CFG);\n\tDUMPREG(HDMI_WP_VIDEO_SIZE);\n\tDUMPREG(HDMI_WP_VIDEO_TIMING_H);\n\tDUMPREG(HDMI_WP_VIDEO_TIMING_V);\n\tDUMPREG(HDMI_WP_CLK);\n\tDUMPREG(HDMI_WP_AUDIO_CFG);\n\tDUMPREG(HDMI_WP_AUDIO_CFG2);\n\tDUMPREG(HDMI_WP_AUDIO_CTRL);\n\tDUMPREG(HDMI_WP_AUDIO_DATA);\n}\n\nu32 hdmi_wp_get_irqstatus(struct hdmi_wp_data *wp)\n{\n\treturn hdmi_read_reg(wp->base, HDMI_WP_IRQSTATUS);\n}\n\nvoid hdmi_wp_set_irqstatus(struct hdmi_wp_data *wp, u32 irqstatus)\n{\n\thdmi_write_reg(wp->base, HDMI_WP_IRQSTATUS, irqstatus);\n\t \n\thdmi_read_reg(wp->base, HDMI_WP_IRQSTATUS);\n}\n\nvoid hdmi_wp_set_irqenable(struct hdmi_wp_data *wp, u32 mask)\n{\n\thdmi_write_reg(wp->base, HDMI_WP_IRQENABLE_SET, mask);\n}\n\nvoid hdmi_wp_clear_irqenable(struct hdmi_wp_data *wp, u32 mask)\n{\n\thdmi_write_reg(wp->base, HDMI_WP_IRQENABLE_CLR, mask);\n}\n\n \nint hdmi_wp_set_phy_pwr(struct hdmi_wp_data *wp, enum hdmi_phy_pwr val)\n{\n\t \n\tif (REG_GET(wp->base, HDMI_WP_PWR_CTRL, 5, 4) == val)\n\t\treturn 0;\n\n\t \n\tREG_FLD_MOD(wp->base, HDMI_WP_PWR_CTRL, val, 7, 6);\n\n\t \n\tif (hdmi_wait_for_bit_change(wp->base, HDMI_WP_PWR_CTRL, 5, 4, val)\n\t\t\t!= val) {\n\t\tDSSERR(\"Failed to set PHY power mode to %d\\n\", val);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n \nint hdmi_wp_set_pll_pwr(struct hdmi_wp_data *wp, enum hdmi_pll_pwr val)\n{\n\t \n\tREG_FLD_MOD(wp->base, HDMI_WP_PWR_CTRL, val, 3, 2);\n\n\t \n\tif (hdmi_wait_for_bit_change(wp->base, HDMI_WP_PWR_CTRL, 1, 0, val)\n\t\t\t!= val) {\n\t\tDSSERR(\"Failed to set PLL_PWR_STATUS\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nint hdmi_wp_video_start(struct hdmi_wp_data *wp)\n{\n\tREG_FLD_MOD(wp->base, HDMI_WP_VIDEO_CFG, true, 31, 31);\n\n\treturn 0;\n}\n\nvoid hdmi_wp_video_stop(struct hdmi_wp_data *wp)\n{\n\tint i;\n\n\thdmi_write_reg(wp->base, HDMI_WP_IRQSTATUS, HDMI_IRQ_VIDEO_FRAME_DONE);\n\n\tREG_FLD_MOD(wp->base, HDMI_WP_VIDEO_CFG, false, 31, 31);\n\n\tfor (i = 0; i < 50; ++i) {\n\t\tu32 v;\n\n\t\tmsleep(20);\n\n\t\tv = hdmi_read_reg(wp->base, HDMI_WP_IRQSTATUS_RAW);\n\t\tif (v & HDMI_IRQ_VIDEO_FRAME_DONE)\n\t\t\treturn;\n\t}\n\n\tDSSERR(\"no HDMI FRAMEDONE when disabling output\\n\");\n}\n\nvoid hdmi_wp_video_config_format(struct hdmi_wp_data *wp,\n\t\tstruct hdmi_video_format *video_fmt)\n{\n\tu32 l = 0;\n\n\tREG_FLD_MOD(wp->base, HDMI_WP_VIDEO_CFG, video_fmt->packing_mode,\n\t\t10, 8);\n\n\tl |= FLD_VAL(video_fmt->y_res, 31, 16);\n\tl |= FLD_VAL(video_fmt->x_res, 15, 0);\n\thdmi_write_reg(wp->base, HDMI_WP_VIDEO_SIZE, l);\n}\n\nvoid hdmi_wp_video_config_interface(struct hdmi_wp_data *wp,\n\t\tstruct omap_video_timings *timings)\n{\n\tu32 r;\n\tbool vsync_pol, hsync_pol;\n\tDSSDBG(\"Enter hdmi_wp_video_config_interface\\n\");\n\n\tvsync_pol = timings->vsync_level == OMAPDSS_SIG_ACTIVE_HIGH;\n\thsync_pol = timings->hsync_level == OMAPDSS_SIG_ACTIVE_HIGH;\n\n\tr = hdmi_read_reg(wp->base, HDMI_WP_VIDEO_CFG);\n\tr = FLD_MOD(r, vsync_pol, 7, 7);\n\tr = FLD_MOD(r, hsync_pol, 6, 6);\n\tr = FLD_MOD(r, timings->interlace, 3, 3);\n\tr = FLD_MOD(r, 1, 1, 0);  \n\thdmi_write_reg(wp->base, HDMI_WP_VIDEO_CFG, r);\n}\n\nvoid hdmi_wp_video_config_timing(struct hdmi_wp_data *wp,\n\t\tstruct omap_video_timings *timings)\n{\n\tu32 timing_h = 0;\n\tu32 timing_v = 0;\n\n\tDSSDBG(\"Enter hdmi_wp_video_config_timing\\n\");\n\n\ttiming_h |= FLD_VAL(timings->hbp, 31, 20);\n\ttiming_h |= FLD_VAL(timings->hfp, 19, 8);\n\ttiming_h |= FLD_VAL(timings->hsw, 7, 0);\n\thdmi_write_reg(wp->base, HDMI_WP_VIDEO_TIMING_H, timing_h);\n\n\ttiming_v |= FLD_VAL(timings->vbp, 31, 20);\n\ttiming_v |= FLD_VAL(timings->vfp, 19, 8);\n\ttiming_v |= FLD_VAL(timings->vsw, 7, 0);\n\thdmi_write_reg(wp->base, HDMI_WP_VIDEO_TIMING_V, timing_v);\n}\n\nvoid hdmi_wp_init_vid_fmt_timings(struct hdmi_video_format *video_fmt,\n\t\tstruct omap_video_timings *timings, struct hdmi_config *param)\n{\n\tDSSDBG(\"Enter hdmi_wp_video_init_format\\n\");\n\n\tvideo_fmt->packing_mode = HDMI_PACK_10b_RGB_YUV444;\n\tvideo_fmt->y_res = param->timings.y_res;\n\tvideo_fmt->x_res = param->timings.x_res;\n\tif (param->timings.interlace)\n\t\tvideo_fmt->y_res /= 2;\n\n\ttimings->hbp = param->timings.hbp;\n\ttimings->hfp = param->timings.hfp;\n\ttimings->hsw = param->timings.hsw;\n\ttimings->vbp = param->timings.vbp;\n\ttimings->vfp = param->timings.vfp;\n\ttimings->vsw = param->timings.vsw;\n\ttimings->vsync_level = param->timings.vsync_level;\n\ttimings->hsync_level = param->timings.hsync_level;\n\ttimings->interlace = param->timings.interlace;\n}\n\nvoid hdmi_wp_audio_config_format(struct hdmi_wp_data *wp,\n\t\tstruct hdmi_audio_format *aud_fmt)\n{\n\tu32 r;\n\n\tDSSDBG(\"Enter hdmi_wp_audio_config_format\\n\");\n\n\tr = hdmi_read_reg(wp->base, HDMI_WP_AUDIO_CFG);\n\tif (omapdss_get_version() == OMAPDSS_VER_OMAP4430_ES1 ||\n\t    omapdss_get_version() == OMAPDSS_VER_OMAP4430_ES2 ||\n\t    omapdss_get_version() == OMAPDSS_VER_OMAP4) {\n\t\tr = FLD_MOD(r, aud_fmt->stereo_channels, 26, 24);\n\t\tr = FLD_MOD(r, aud_fmt->active_chnnls_msk, 23, 16);\n\t}\n\tr = FLD_MOD(r, aud_fmt->en_sig_blk_strt_end, 5, 5);\n\tr = FLD_MOD(r, aud_fmt->type, 4, 4);\n\tr = FLD_MOD(r, aud_fmt->justification, 3, 3);\n\tr = FLD_MOD(r, aud_fmt->sample_order, 2, 2);\n\tr = FLD_MOD(r, aud_fmt->samples_per_word, 1, 1);\n\tr = FLD_MOD(r, aud_fmt->sample_size, 0, 0);\n\thdmi_write_reg(wp->base, HDMI_WP_AUDIO_CFG, r);\n}\n\nvoid hdmi_wp_audio_config_dma(struct hdmi_wp_data *wp,\n\t\tstruct hdmi_audio_dma *aud_dma)\n{\n\tu32 r;\n\n\tDSSDBG(\"Enter hdmi_wp_audio_config_dma\\n\");\n\n\tr = hdmi_read_reg(wp->base, HDMI_WP_AUDIO_CFG2);\n\tr = FLD_MOD(r, aud_dma->transfer_size, 15, 8);\n\tr = FLD_MOD(r, aud_dma->block_size, 7, 0);\n\thdmi_write_reg(wp->base, HDMI_WP_AUDIO_CFG2, r);\n\n\tr = hdmi_read_reg(wp->base, HDMI_WP_AUDIO_CTRL);\n\tr = FLD_MOD(r, aud_dma->mode, 9, 9);\n\tr = FLD_MOD(r, aud_dma->fifo_threshold, 8, 0);\n\thdmi_write_reg(wp->base, HDMI_WP_AUDIO_CTRL, r);\n}\n\nint hdmi_wp_audio_enable(struct hdmi_wp_data *wp, bool enable)\n{\n\tREG_FLD_MOD(wp->base, HDMI_WP_AUDIO_CTRL, enable, 31, 31);\n\n\treturn 0;\n}\n\nint hdmi_wp_audio_core_req_enable(struct hdmi_wp_data *wp, bool enable)\n{\n\tREG_FLD_MOD(wp->base, HDMI_WP_AUDIO_CTRL, enable, 30, 30);\n\n\treturn 0;\n}\n\nint hdmi_wp_init(struct platform_device *pdev, struct hdmi_wp_data *wp)\n{\n\tstruct resource *res;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"wp\");\n\tif (!res) {\n\t\tDSSERR(\"can't get WP mem resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\twp->phys_base = res->start;\n\n\twp->base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(wp->base)) {\n\t\tDSSERR(\"can't ioremap HDMI WP\\n\");\n\t\treturn PTR_ERR(wp->base);\n\t}\n\n\treturn 0;\n}\n\nphys_addr_t hdmi_wp_get_audio_dma_addr(struct hdmi_wp_data *wp)\n{\n\treturn wp->phys_base + HDMI_WP_AUDIO_DATA;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}