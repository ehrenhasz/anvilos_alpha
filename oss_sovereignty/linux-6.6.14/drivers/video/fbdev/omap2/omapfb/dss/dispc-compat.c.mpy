{
  "module_name": "dispc-compat.c",
  "hash_id": "444f20f6f2e8fad77503b435b4e54a2331f2be3a394fac67ba0a493648f71030",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/dispc-compat.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"APPLY\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"dss_features.h\"\n#include \"dispc-compat.h\"\n\n#define DISPC_IRQ_MASK_ERROR            (DISPC_IRQ_GFX_FIFO_UNDERFLOW | \\\n\t\t\t\t\t DISPC_IRQ_OCP_ERR | \\\n\t\t\t\t\t DISPC_IRQ_VID1_FIFO_UNDERFLOW | \\\n\t\t\t\t\t DISPC_IRQ_VID2_FIFO_UNDERFLOW | \\\n\t\t\t\t\t DISPC_IRQ_SYNC_LOST | \\\n\t\t\t\t\t DISPC_IRQ_SYNC_LOST_DIGIT)\n\n#define DISPC_MAX_NR_ISRS\t\t8\n\nstruct omap_dispc_isr_data {\n\tomap_dispc_isr_t\tisr;\n\tvoid\t\t\t*arg;\n\tu32\t\t\tmask;\n};\n\nstruct dispc_irq_stats {\n\tunsigned long last_reset;\n\tunsigned irq_count;\n\tunsigned irqs[32];\n};\n\nstatic struct {\n\tspinlock_t irq_lock;\n\tu32 irq_error_mask;\n\tstruct omap_dispc_isr_data registered_isr[DISPC_MAX_NR_ISRS];\n\tu32 error_irqs;\n\tstruct work_struct error_work;\n\n#ifdef CONFIG_FB_OMAP2_DSS_COLLECT_IRQ_STATS\n\tspinlock_t irq_stats_lock;\n\tstruct dispc_irq_stats irq_stats;\n#endif\n} dispc_compat;\n\n\n#ifdef CONFIG_FB_OMAP2_DSS_COLLECT_IRQ_STATS\nstatic void dispc_dump_irqs(struct seq_file *s)\n{\n\tunsigned long flags;\n\tstruct dispc_irq_stats stats;\n\n\tspin_lock_irqsave(&dispc_compat.irq_stats_lock, flags);\n\n\tstats = dispc_compat.irq_stats;\n\tmemset(&dispc_compat.irq_stats, 0, sizeof(dispc_compat.irq_stats));\n\tdispc_compat.irq_stats.last_reset = jiffies;\n\n\tspin_unlock_irqrestore(&dispc_compat.irq_stats_lock, flags);\n\n\tseq_printf(s, \"period %u ms\\n\",\n\t\t\tjiffies_to_msecs(jiffies - stats.last_reset));\n\n\tseq_printf(s, \"irqs %d\\n\", stats.irq_count);\n#define PIS(x) \\\n\tseq_printf(s, \"%-20s %10d\\n\", #x, stats.irqs[ffs(DISPC_IRQ_##x)-1])\n\n\tPIS(FRAMEDONE);\n\tPIS(VSYNC);\n\tPIS(EVSYNC_EVEN);\n\tPIS(EVSYNC_ODD);\n\tPIS(ACBIAS_COUNT_STAT);\n\tPIS(PROG_LINE_NUM);\n\tPIS(GFX_FIFO_UNDERFLOW);\n\tPIS(GFX_END_WIN);\n\tPIS(PAL_GAMMA_MASK);\n\tPIS(OCP_ERR);\n\tPIS(VID1_FIFO_UNDERFLOW);\n\tPIS(VID1_END_WIN);\n\tPIS(VID2_FIFO_UNDERFLOW);\n\tPIS(VID2_END_WIN);\n\tif (dss_feat_get_num_ovls() > 3) {\n\t\tPIS(VID3_FIFO_UNDERFLOW);\n\t\tPIS(VID3_END_WIN);\n\t}\n\tPIS(SYNC_LOST);\n\tPIS(SYNC_LOST_DIGIT);\n\tPIS(WAKEUP);\n\tif (dss_has_feature(FEAT_MGR_LCD2)) {\n\t\tPIS(FRAMEDONE2);\n\t\tPIS(VSYNC2);\n\t\tPIS(ACBIAS_COUNT_STAT2);\n\t\tPIS(SYNC_LOST2);\n\t}\n\tif (dss_has_feature(FEAT_MGR_LCD3)) {\n\t\tPIS(FRAMEDONE3);\n\t\tPIS(VSYNC3);\n\t\tPIS(ACBIAS_COUNT_STAT3);\n\t\tPIS(SYNC_LOST3);\n\t}\n#undef PIS\n}\n#endif\n\n \nstatic void _omap_dispc_set_irqs(void)\n{\n\tu32 mask;\n\tint i;\n\tstruct omap_dispc_isr_data *isr_data;\n\n\tmask = dispc_compat.irq_error_mask;\n\n\tfor (i = 0; i < DISPC_MAX_NR_ISRS; i++) {\n\t\tisr_data = &dispc_compat.registered_isr[i];\n\n\t\tif (isr_data->isr == NULL)\n\t\t\tcontinue;\n\n\t\tmask |= isr_data->mask;\n\t}\n\n\tdispc_write_irqenable(mask);\n}\n\nint omap_dispc_register_isr(omap_dispc_isr_t isr, void *arg, u32 mask)\n{\n\tint i;\n\tint ret;\n\tunsigned long flags;\n\tstruct omap_dispc_isr_data *isr_data;\n\n\tif (isr == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dispc_compat.irq_lock, flags);\n\n\t \n\tfor (i = 0; i < DISPC_MAX_NR_ISRS; i++) {\n\t\tisr_data = &dispc_compat.registered_isr[i];\n\t\tif (isr_data->isr == isr && isr_data->arg == arg &&\n\t\t\t\tisr_data->mask == mask) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tisr_data = NULL;\n\tret = -EBUSY;\n\n\tfor (i = 0; i < DISPC_MAX_NR_ISRS; i++) {\n\t\tisr_data = &dispc_compat.registered_isr[i];\n\n\t\tif (isr_data->isr != NULL)\n\t\t\tcontinue;\n\n\t\tisr_data->isr = isr;\n\t\tisr_data->arg = arg;\n\t\tisr_data->mask = mask;\n\t\tret = 0;\n\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tgoto err;\n\n\t_omap_dispc_set_irqs();\n\n\tspin_unlock_irqrestore(&dispc_compat.irq_lock, flags);\n\n\treturn 0;\nerr:\n\tspin_unlock_irqrestore(&dispc_compat.irq_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(omap_dispc_register_isr);\n\nint omap_dispc_unregister_isr(omap_dispc_isr_t isr, void *arg, u32 mask)\n{\n\tint i;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\tstruct omap_dispc_isr_data *isr_data;\n\n\tspin_lock_irqsave(&dispc_compat.irq_lock, flags);\n\n\tfor (i = 0; i < DISPC_MAX_NR_ISRS; i++) {\n\t\tisr_data = &dispc_compat.registered_isr[i];\n\t\tif (isr_data->isr != isr || isr_data->arg != arg ||\n\t\t\t\tisr_data->mask != mask)\n\t\t\tcontinue;\n\n\t\t \n\n\t\tisr_data->isr = NULL;\n\t\tisr_data->arg = NULL;\n\t\tisr_data->mask = 0;\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\tif (ret == 0)\n\t\t_omap_dispc_set_irqs();\n\n\tspin_unlock_irqrestore(&dispc_compat.irq_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(omap_dispc_unregister_isr);\n\nstatic void print_irq_status(u32 status)\n{\n\tif ((status & dispc_compat.irq_error_mask) == 0)\n\t\treturn;\n\n#define PIS(x) (status & DISPC_IRQ_##x) ? (#x \" \") : \"\"\n\n\tpr_debug(\"DISPC IRQ: 0x%x: %s%s%s%s%s%s%s%s%s\\n\",\n\t\tstatus,\n\t\tPIS(OCP_ERR),\n\t\tPIS(GFX_FIFO_UNDERFLOW),\n\t\tPIS(VID1_FIFO_UNDERFLOW),\n\t\tPIS(VID2_FIFO_UNDERFLOW),\n\t\tdss_feat_get_num_ovls() > 3 ? PIS(VID3_FIFO_UNDERFLOW) : \"\",\n\t\tPIS(SYNC_LOST),\n\t\tPIS(SYNC_LOST_DIGIT),\n\t\tdss_has_feature(FEAT_MGR_LCD2) ? PIS(SYNC_LOST2) : \"\",\n\t\tdss_has_feature(FEAT_MGR_LCD3) ? PIS(SYNC_LOST3) : \"\");\n#undef PIS\n}\n\n \nstatic irqreturn_t omap_dispc_irq_handler(int irq, void *arg)\n{\n\tint i;\n\tu32 irqstatus, irqenable;\n\tu32 handledirqs = 0;\n\tu32 unhandled_errors;\n\tstruct omap_dispc_isr_data *isr_data;\n\tstruct omap_dispc_isr_data registered_isr[DISPC_MAX_NR_ISRS];\n\n\tspin_lock(&dispc_compat.irq_lock);\n\n\tirqstatus = dispc_read_irqstatus();\n\tirqenable = dispc_read_irqenable();\n\n\t \n\tif (!(irqstatus & irqenable)) {\n\t\tspin_unlock(&dispc_compat.irq_lock);\n\t\treturn IRQ_NONE;\n\t}\n\n#ifdef CONFIG_FB_OMAP2_DSS_COLLECT_IRQ_STATS\n\tspin_lock(&dispc_compat.irq_stats_lock);\n\tdispc_compat.irq_stats.irq_count++;\n\tdss_collect_irq_stats(irqstatus, dispc_compat.irq_stats.irqs);\n\tspin_unlock(&dispc_compat.irq_stats_lock);\n#endif\n\n\tprint_irq_status(irqstatus);\n\n\t \n\tdispc_clear_irqstatus(irqstatus);\n\t \n\tdispc_read_irqstatus();\n\n\t \n\tmemcpy(registered_isr, dispc_compat.registered_isr,\n\t\t\tsizeof(registered_isr));\n\n\tspin_unlock(&dispc_compat.irq_lock);\n\n\tfor (i = 0; i < DISPC_MAX_NR_ISRS; i++) {\n\t\tisr_data = &registered_isr[i];\n\n\t\tif (!isr_data->isr)\n\t\t\tcontinue;\n\n\t\tif (isr_data->mask & irqstatus) {\n\t\t\tisr_data->isr(isr_data->arg, irqstatus);\n\t\t\thandledirqs |= isr_data->mask;\n\t\t}\n\t}\n\n\tspin_lock(&dispc_compat.irq_lock);\n\n\tunhandled_errors = irqstatus & ~handledirqs & dispc_compat.irq_error_mask;\n\n\tif (unhandled_errors) {\n\t\tdispc_compat.error_irqs |= unhandled_errors;\n\n\t\tdispc_compat.irq_error_mask &= ~unhandled_errors;\n\t\t_omap_dispc_set_irqs();\n\n\t\tschedule_work(&dispc_compat.error_work);\n\t}\n\n\tspin_unlock(&dispc_compat.irq_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void dispc_error_worker(struct work_struct *work)\n{\n\tint i;\n\tu32 errors;\n\tunsigned long flags;\n\tstatic const unsigned fifo_underflow_bits[] = {\n\t\tDISPC_IRQ_GFX_FIFO_UNDERFLOW,\n\t\tDISPC_IRQ_VID1_FIFO_UNDERFLOW,\n\t\tDISPC_IRQ_VID2_FIFO_UNDERFLOW,\n\t\tDISPC_IRQ_VID3_FIFO_UNDERFLOW,\n\t};\n\n\tspin_lock_irqsave(&dispc_compat.irq_lock, flags);\n\terrors = dispc_compat.error_irqs;\n\tdispc_compat.error_irqs = 0;\n\tspin_unlock_irqrestore(&dispc_compat.irq_lock, flags);\n\n\tdispc_runtime_get();\n\n\tfor (i = 0; i < omap_dss_get_num_overlays(); ++i) {\n\t\tstruct omap_overlay *ovl;\n\t\tunsigned bit;\n\n\t\tovl = omap_dss_get_overlay(i);\n\t\tbit = fifo_underflow_bits[i];\n\n\t\tif (bit & errors) {\n\t\t\tDSSERR(\"FIFO UNDERFLOW on %s, disabling the overlay\\n\",\n\t\t\t\t\tovl->name);\n\t\t\tovl->disable(ovl);\n\t\t\tmsleep(50);\n\t\t}\n\t}\n\n\tfor (i = 0; i < omap_dss_get_num_overlay_managers(); ++i) {\n\t\tstruct omap_overlay_manager *mgr;\n\t\tunsigned bit;\n\n\t\tmgr = omap_dss_get_overlay_manager(i);\n\t\tbit = dispc_mgr_get_sync_lost_irq(i);\n\n\t\tif (bit & errors) {\n\t\t\tint j;\n\n\t\t\tDSSERR(\"SYNC_LOST on channel %s, restarting the output \"\n\t\t\t\t\t\"with video overlays disabled\\n\",\n\t\t\t\t\tmgr->name);\n\n\t\t\tdss_mgr_disable(mgr);\n\n\t\t\tfor (j = 0; j < omap_dss_get_num_overlays(); ++j) {\n\t\t\t\tstruct omap_overlay *ovl;\n\t\t\t\tovl = omap_dss_get_overlay(j);\n\n\t\t\t\tif (ovl->id != OMAP_DSS_GFX &&\n\t\t\t\t\t\tovl->manager == mgr)\n\t\t\t\t\tovl->disable(ovl);\n\t\t\t}\n\n\t\t\tdss_mgr_enable(mgr);\n\t\t}\n\t}\n\n\tif (errors & DISPC_IRQ_OCP_ERR) {\n\t\tDSSERR(\"OCP_ERR\\n\");\n\t\tfor (i = 0; i < omap_dss_get_num_overlay_managers(); ++i) {\n\t\t\tstruct omap_overlay_manager *mgr;\n\n\t\t\tmgr = omap_dss_get_overlay_manager(i);\n\t\t\tdss_mgr_disable(mgr);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&dispc_compat.irq_lock, flags);\n\tdispc_compat.irq_error_mask |= errors;\n\t_omap_dispc_set_irqs();\n\tspin_unlock_irqrestore(&dispc_compat.irq_lock, flags);\n\n\tdispc_runtime_put();\n}\n\nint dss_dispc_initialize_irq(void)\n{\n\tint r;\n\n#ifdef CONFIG_FB_OMAP2_DSS_COLLECT_IRQ_STATS\n\tspin_lock_init(&dispc_compat.irq_stats_lock);\n\tdispc_compat.irq_stats.last_reset = jiffies;\n\tdss_debugfs_create_file(\"dispc_irq\", dispc_dump_irqs);\n#endif\n\n\tspin_lock_init(&dispc_compat.irq_lock);\n\n\tmemset(dispc_compat.registered_isr, 0,\n\t\t\tsizeof(dispc_compat.registered_isr));\n\n\tdispc_compat.irq_error_mask = DISPC_IRQ_MASK_ERROR;\n\tif (dss_has_feature(FEAT_MGR_LCD2))\n\t\tdispc_compat.irq_error_mask |= DISPC_IRQ_SYNC_LOST2;\n\tif (dss_has_feature(FEAT_MGR_LCD3))\n\t\tdispc_compat.irq_error_mask |= DISPC_IRQ_SYNC_LOST3;\n\tif (dss_feat_get_num_ovls() > 3)\n\t\tdispc_compat.irq_error_mask |= DISPC_IRQ_VID3_FIFO_UNDERFLOW;\n\n\t \n\tdispc_clear_irqstatus(dispc_read_irqstatus());\n\n\tINIT_WORK(&dispc_compat.error_work, dispc_error_worker);\n\n\t_omap_dispc_set_irqs();\n\n\tr = dispc_request_irq(omap_dispc_irq_handler, &dispc_compat);\n\tif (r) {\n\t\tDSSERR(\"dispc_request_irq failed\\n\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nvoid dss_dispc_uninitialize_irq(void)\n{\n\tdispc_free_irq(&dispc_compat);\n}\n\nstatic void dispc_mgr_disable_isr(void *data, u32 mask)\n{\n\tstruct completion *compl = data;\n\tcomplete(compl);\n}\n\nstatic void dispc_mgr_enable_lcd_out(enum omap_channel channel)\n{\n\tdispc_mgr_enable(channel, true);\n}\n\nstatic void dispc_mgr_disable_lcd_out(enum omap_channel channel)\n{\n\tDECLARE_COMPLETION_ONSTACK(framedone_compl);\n\tint r;\n\tu32 irq;\n\n\tif (!dispc_mgr_is_enabled(channel))\n\t\treturn;\n\n\t \n\n\tirq = dispc_mgr_get_framedone_irq(channel);\n\n\tr = omap_dispc_register_isr(dispc_mgr_disable_isr, &framedone_compl,\n\t\t\tirq);\n\tif (r)\n\t\tDSSERR(\"failed to register FRAMEDONE isr\\n\");\n\n\tdispc_mgr_enable(channel, false);\n\n\t \n\tif (r) {\n\t\tmsleep(100);\n\t\treturn;\n\t}\n\n\tif (!wait_for_completion_timeout(&framedone_compl,\n\t\t\t\tmsecs_to_jiffies(100)))\n\t\tDSSERR(\"timeout waiting for FRAME DONE\\n\");\n\n\tr = omap_dispc_unregister_isr(dispc_mgr_disable_isr, &framedone_compl,\n\t\t\tirq);\n\tif (r)\n\t\tDSSERR(\"failed to unregister FRAMEDONE isr\\n\");\n}\n\nstatic void dispc_digit_out_enable_isr(void *data, u32 mask)\n{\n\tstruct completion *compl = data;\n\n\t \n\tif (mask & (DISPC_IRQ_EVSYNC_EVEN | DISPC_IRQ_EVSYNC_ODD))\n\t\tcomplete(compl);\n}\n\nstatic void dispc_mgr_enable_digit_out(void)\n{\n\tDECLARE_COMPLETION_ONSTACK(vsync_compl);\n\tint r;\n\tu32 irq_mask;\n\n\tif (dispc_mgr_is_enabled(OMAP_DSS_CHANNEL_DIGIT))\n\t\treturn;\n\n\t \n\n\tirq_mask = dispc_mgr_get_vsync_irq(OMAP_DSS_CHANNEL_DIGIT) |\n\t\tdispc_mgr_get_sync_lost_irq(OMAP_DSS_CHANNEL_DIGIT);\n\n\tr = omap_dispc_register_isr(dispc_digit_out_enable_isr, &vsync_compl,\n\t\t\tirq_mask);\n\tif (r) {\n\t\tDSSERR(\"failed to register %x isr\\n\", irq_mask);\n\t\treturn;\n\t}\n\n\tdispc_mgr_enable(OMAP_DSS_CHANNEL_DIGIT, true);\n\n\t \n\tif (!wait_for_completion_timeout(&vsync_compl, msecs_to_jiffies(100)))\n\t\tDSSERR(\"timeout waiting for digit out to start\\n\");\n\n\tr = omap_dispc_unregister_isr(dispc_digit_out_enable_isr, &vsync_compl,\n\t\t\tirq_mask);\n\tif (r)\n\t\tDSSERR(\"failed to unregister %x isr\\n\", irq_mask);\n}\n\nstatic void dispc_mgr_disable_digit_out(void)\n{\n\tDECLARE_COMPLETION_ONSTACK(framedone_compl);\n\tint r, i;\n\tu32 irq_mask;\n\tint num_irqs;\n\n\tif (!dispc_mgr_is_enabled(OMAP_DSS_CHANNEL_DIGIT))\n\t\treturn;\n\n\t \n\n\tirq_mask = dispc_mgr_get_framedone_irq(OMAP_DSS_CHANNEL_DIGIT);\n\tnum_irqs = 1;\n\n\tif (!irq_mask) {\n\t\t \n\n\t\tirq_mask = dispc_mgr_get_vsync_irq(OMAP_DSS_CHANNEL_DIGIT);\n\t\t \n\t\tnum_irqs = 2;\n\t}\n\n\tr = omap_dispc_register_isr(dispc_mgr_disable_isr, &framedone_compl,\n\t\t\tirq_mask);\n\tif (r)\n\t\tDSSERR(\"failed to register %x isr\\n\", irq_mask);\n\n\tdispc_mgr_enable(OMAP_DSS_CHANNEL_DIGIT, false);\n\n\t \n\tif (r) {\n\t\tmsleep(100);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < num_irqs; ++i) {\n\t\tif (!wait_for_completion_timeout(&framedone_compl,\n\t\t\t\t\tmsecs_to_jiffies(100)))\n\t\t\tDSSERR(\"timeout waiting for digit out to stop\\n\");\n\t}\n\n\tr = omap_dispc_unregister_isr(dispc_mgr_disable_isr, &framedone_compl,\n\t\t\tirq_mask);\n\tif (r)\n\t\tDSSERR(\"failed to unregister %x isr\\n\", irq_mask);\n}\n\nvoid dispc_mgr_enable_sync(enum omap_channel channel)\n{\n\tif (dss_mgr_is_lcd(channel))\n\t\tdispc_mgr_enable_lcd_out(channel);\n\telse if (channel == OMAP_DSS_CHANNEL_DIGIT)\n\t\tdispc_mgr_enable_digit_out();\n\telse\n\t\tWARN_ON(1);\n}\n\nvoid dispc_mgr_disable_sync(enum omap_channel channel)\n{\n\tif (dss_mgr_is_lcd(channel))\n\t\tdispc_mgr_disable_lcd_out(channel);\n\telse if (channel == OMAP_DSS_CHANNEL_DIGIT)\n\t\tdispc_mgr_disable_digit_out();\n\telse\n\t\tWARN_ON(1);\n}\n\nstatic inline void dispc_irq_wait_handler(void *data, u32 mask)\n{\n\tcomplete((struct completion *)data);\n}\n\nint omap_dispc_wait_for_irq_interruptible_timeout(u32 irqmask,\n\t\tunsigned long timeout)\n{\n\n\tint r;\n\tlong time_left;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\n\tr = omap_dispc_register_isr(dispc_irq_wait_handler, &completion,\n\t\t\tirqmask);\n\n\tif (r)\n\t\treturn r;\n\n\ttime_left = wait_for_completion_interruptible_timeout(&completion,\n\t\t\ttimeout);\n\n\tomap_dispc_unregister_isr(dispc_irq_wait_handler, &completion, irqmask);\n\n\tif (time_left == 0)\n\t\treturn -ETIMEDOUT;\n\n\tif (time_left == -ERESTARTSYS)\n\t\treturn -ERESTARTSYS;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}