{
  "module_name": "dsi.c",
  "hash_id": "729fa5f5c31b63a771e11c73767957d8d8813d0bc41fa73bc5dd42637edead17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/dsi.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"DSI\"\n\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/semaphore.h>\n#include <linux/seq_file.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/component.h>\n\n#include <video/omapfb_dss.h>\n#include <video/mipi_display.h>\n\n#include \"dss.h\"\n#include \"dss_features.h\"\n\n#define DSI_CATCH_MISSING_TE\n\nstruct dsi_reg { u16 module; u16 idx; };\n\n#define DSI_REG(mod, idx)\t\t((const struct dsi_reg) { mod, idx })\n\n \n\n#define DSI_PROTO\t\t\t0\n#define DSI_PROTO_SZ\t\t\t0x200\n\n#define DSI_REVISION\t\t\tDSI_REG(DSI_PROTO, 0x0000)\n#define DSI_SYSCONFIG\t\t\tDSI_REG(DSI_PROTO, 0x0010)\n#define DSI_SYSSTATUS\t\t\tDSI_REG(DSI_PROTO, 0x0014)\n#define DSI_IRQSTATUS\t\t\tDSI_REG(DSI_PROTO, 0x0018)\n#define DSI_IRQENABLE\t\t\tDSI_REG(DSI_PROTO, 0x001C)\n#define DSI_CTRL\t\t\tDSI_REG(DSI_PROTO, 0x0040)\n#define DSI_GNQ\t\t\t\tDSI_REG(DSI_PROTO, 0x0044)\n#define DSI_COMPLEXIO_CFG1\t\tDSI_REG(DSI_PROTO, 0x0048)\n#define DSI_COMPLEXIO_IRQ_STATUS\tDSI_REG(DSI_PROTO, 0x004C)\n#define DSI_COMPLEXIO_IRQ_ENABLE\tDSI_REG(DSI_PROTO, 0x0050)\n#define DSI_CLK_CTRL\t\t\tDSI_REG(DSI_PROTO, 0x0054)\n#define DSI_TIMING1\t\t\tDSI_REG(DSI_PROTO, 0x0058)\n#define DSI_TIMING2\t\t\tDSI_REG(DSI_PROTO, 0x005C)\n#define DSI_VM_TIMING1\t\t\tDSI_REG(DSI_PROTO, 0x0060)\n#define DSI_VM_TIMING2\t\t\tDSI_REG(DSI_PROTO, 0x0064)\n#define DSI_VM_TIMING3\t\t\tDSI_REG(DSI_PROTO, 0x0068)\n#define DSI_CLK_TIMING\t\t\tDSI_REG(DSI_PROTO, 0x006C)\n#define DSI_TX_FIFO_VC_SIZE\t\tDSI_REG(DSI_PROTO, 0x0070)\n#define DSI_RX_FIFO_VC_SIZE\t\tDSI_REG(DSI_PROTO, 0x0074)\n#define DSI_COMPLEXIO_CFG2\t\tDSI_REG(DSI_PROTO, 0x0078)\n#define DSI_RX_FIFO_VC_FULLNESS\t\tDSI_REG(DSI_PROTO, 0x007C)\n#define DSI_VM_TIMING4\t\t\tDSI_REG(DSI_PROTO, 0x0080)\n#define DSI_TX_FIFO_VC_EMPTINESS\tDSI_REG(DSI_PROTO, 0x0084)\n#define DSI_VM_TIMING5\t\t\tDSI_REG(DSI_PROTO, 0x0088)\n#define DSI_VM_TIMING6\t\t\tDSI_REG(DSI_PROTO, 0x008C)\n#define DSI_VM_TIMING7\t\t\tDSI_REG(DSI_PROTO, 0x0090)\n#define DSI_STOPCLK_TIMING\t\tDSI_REG(DSI_PROTO, 0x0094)\n#define DSI_VC_CTRL(n)\t\t\tDSI_REG(DSI_PROTO, 0x0100 + (n * 0x20))\n#define DSI_VC_TE(n)\t\t\tDSI_REG(DSI_PROTO, 0x0104 + (n * 0x20))\n#define DSI_VC_LONG_PACKET_HEADER(n)\tDSI_REG(DSI_PROTO, 0x0108 + (n * 0x20))\n#define DSI_VC_LONG_PACKET_PAYLOAD(n)\tDSI_REG(DSI_PROTO, 0x010C + (n * 0x20))\n#define DSI_VC_SHORT_PACKET_HEADER(n)\tDSI_REG(DSI_PROTO, 0x0110 + (n * 0x20))\n#define DSI_VC_IRQSTATUS(n)\t\tDSI_REG(DSI_PROTO, 0x0118 + (n * 0x20))\n#define DSI_VC_IRQENABLE(n)\t\tDSI_REG(DSI_PROTO, 0x011C + (n * 0x20))\n\n \n\n#define DSI_PHY\t\t\t\t1\n#define DSI_PHY_OFFSET\t\t\t0x200\n#define DSI_PHY_SZ\t\t\t0x40\n\n#define DSI_DSIPHY_CFG0\t\t\tDSI_REG(DSI_PHY, 0x0000)\n#define DSI_DSIPHY_CFG1\t\t\tDSI_REG(DSI_PHY, 0x0004)\n#define DSI_DSIPHY_CFG2\t\t\tDSI_REG(DSI_PHY, 0x0008)\n#define DSI_DSIPHY_CFG5\t\t\tDSI_REG(DSI_PHY, 0x0014)\n#define DSI_DSIPHY_CFG10\t\tDSI_REG(DSI_PHY, 0x0028)\n\n \n\n#define DSI_PLL\t\t\t\t2\n#define DSI_PLL_OFFSET\t\t\t0x300\n#define DSI_PLL_SZ\t\t\t0x20\n\n#define DSI_PLL_CONTROL\t\t\tDSI_REG(DSI_PLL, 0x0000)\n#define DSI_PLL_STATUS\t\t\tDSI_REG(DSI_PLL, 0x0004)\n#define DSI_PLL_GO\t\t\tDSI_REG(DSI_PLL, 0x0008)\n#define DSI_PLL_CONFIGURATION1\t\tDSI_REG(DSI_PLL, 0x000C)\n#define DSI_PLL_CONFIGURATION2\t\tDSI_REG(DSI_PLL, 0x0010)\n\n#define REG_GET(dsidev, idx, start, end) \\\n\tFLD_GET(dsi_read_reg(dsidev, idx), start, end)\n\n#define REG_FLD_MOD(dsidev, idx, val, start, end) \\\n\tdsi_write_reg(dsidev, idx, FLD_MOD(dsi_read_reg(dsidev, idx), val, start, end))\n\n \n#define DSI_IRQ_VC0\t\t(1 << 0)\n#define DSI_IRQ_VC1\t\t(1 << 1)\n#define DSI_IRQ_VC2\t\t(1 << 2)\n#define DSI_IRQ_VC3\t\t(1 << 3)\n#define DSI_IRQ_WAKEUP\t\t(1 << 4)\n#define DSI_IRQ_RESYNC\t\t(1 << 5)\n#define DSI_IRQ_PLL_LOCK\t(1 << 7)\n#define DSI_IRQ_PLL_UNLOCK\t(1 << 8)\n#define DSI_IRQ_PLL_RECALL\t(1 << 9)\n#define DSI_IRQ_COMPLEXIO_ERR\t(1 << 10)\n#define DSI_IRQ_HS_TX_TIMEOUT\t(1 << 14)\n#define DSI_IRQ_LP_RX_TIMEOUT\t(1 << 15)\n#define DSI_IRQ_TE_TRIGGER\t(1 << 16)\n#define DSI_IRQ_ACK_TRIGGER\t(1 << 17)\n#define DSI_IRQ_SYNC_LOST\t(1 << 18)\n#define DSI_IRQ_LDO_POWER_GOOD\t(1 << 19)\n#define DSI_IRQ_TA_TIMEOUT\t(1 << 20)\n#define DSI_IRQ_ERROR_MASK \\\n\t(DSI_IRQ_HS_TX_TIMEOUT | DSI_IRQ_LP_RX_TIMEOUT | DSI_IRQ_SYNC_LOST | \\\n\tDSI_IRQ_TA_TIMEOUT)\n#define DSI_IRQ_CHANNEL_MASK\t0xf\n\n \n#define DSI_VC_IRQ_CS\t\t(1 << 0)\n#define DSI_VC_IRQ_ECC_CORR\t(1 << 1)\n#define DSI_VC_IRQ_PACKET_SENT\t(1 << 2)\n#define DSI_VC_IRQ_FIFO_TX_OVF\t(1 << 3)\n#define DSI_VC_IRQ_FIFO_RX_OVF\t(1 << 4)\n#define DSI_VC_IRQ_BTA\t\t(1 << 5)\n#define DSI_VC_IRQ_ECC_NO_CORR\t(1 << 6)\n#define DSI_VC_IRQ_FIFO_TX_UDF\t(1 << 7)\n#define DSI_VC_IRQ_PP_BUSY_CHANGE (1 << 8)\n#define DSI_VC_IRQ_ERROR_MASK \\\n\t(DSI_VC_IRQ_CS | DSI_VC_IRQ_ECC_CORR | DSI_VC_IRQ_FIFO_TX_OVF | \\\n\tDSI_VC_IRQ_FIFO_RX_OVF | DSI_VC_IRQ_ECC_NO_CORR | \\\n\tDSI_VC_IRQ_FIFO_TX_UDF)\n\n \n#define DSI_CIO_IRQ_ERRSYNCESC1\t\t(1 << 0)\n#define DSI_CIO_IRQ_ERRSYNCESC2\t\t(1 << 1)\n#define DSI_CIO_IRQ_ERRSYNCESC3\t\t(1 << 2)\n#define DSI_CIO_IRQ_ERRSYNCESC4\t\t(1 << 3)\n#define DSI_CIO_IRQ_ERRSYNCESC5\t\t(1 << 4)\n#define DSI_CIO_IRQ_ERRESC1\t\t(1 << 5)\n#define DSI_CIO_IRQ_ERRESC2\t\t(1 << 6)\n#define DSI_CIO_IRQ_ERRESC3\t\t(1 << 7)\n#define DSI_CIO_IRQ_ERRESC4\t\t(1 << 8)\n#define DSI_CIO_IRQ_ERRESC5\t\t(1 << 9)\n#define DSI_CIO_IRQ_ERRCONTROL1\t\t(1 << 10)\n#define DSI_CIO_IRQ_ERRCONTROL2\t\t(1 << 11)\n#define DSI_CIO_IRQ_ERRCONTROL3\t\t(1 << 12)\n#define DSI_CIO_IRQ_ERRCONTROL4\t\t(1 << 13)\n#define DSI_CIO_IRQ_ERRCONTROL5\t\t(1 << 14)\n#define DSI_CIO_IRQ_STATEULPS1\t\t(1 << 15)\n#define DSI_CIO_IRQ_STATEULPS2\t\t(1 << 16)\n#define DSI_CIO_IRQ_STATEULPS3\t\t(1 << 17)\n#define DSI_CIO_IRQ_STATEULPS4\t\t(1 << 18)\n#define DSI_CIO_IRQ_STATEULPS5\t\t(1 << 19)\n#define DSI_CIO_IRQ_ERRCONTENTIONLP0_1\t(1 << 20)\n#define DSI_CIO_IRQ_ERRCONTENTIONLP1_1\t(1 << 21)\n#define DSI_CIO_IRQ_ERRCONTENTIONLP0_2\t(1 << 22)\n#define DSI_CIO_IRQ_ERRCONTENTIONLP1_2\t(1 << 23)\n#define DSI_CIO_IRQ_ERRCONTENTIONLP0_3\t(1 << 24)\n#define DSI_CIO_IRQ_ERRCONTENTIONLP1_3\t(1 << 25)\n#define DSI_CIO_IRQ_ERRCONTENTIONLP0_4\t(1 << 26)\n#define DSI_CIO_IRQ_ERRCONTENTIONLP1_4\t(1 << 27)\n#define DSI_CIO_IRQ_ERRCONTENTIONLP0_5\t(1 << 28)\n#define DSI_CIO_IRQ_ERRCONTENTIONLP1_5\t(1 << 29)\n#define DSI_CIO_IRQ_ULPSACTIVENOT_ALL0\t(1 << 30)\n#define DSI_CIO_IRQ_ULPSACTIVENOT_ALL1\t(1 << 31)\n#define DSI_CIO_IRQ_ERROR_MASK \\\n\t(DSI_CIO_IRQ_ERRSYNCESC1 | DSI_CIO_IRQ_ERRSYNCESC2 | \\\n\t DSI_CIO_IRQ_ERRSYNCESC3 | DSI_CIO_IRQ_ERRSYNCESC4 | \\\n\t DSI_CIO_IRQ_ERRSYNCESC5 | \\\n\t DSI_CIO_IRQ_ERRESC1 | DSI_CIO_IRQ_ERRESC2 | \\\n\t DSI_CIO_IRQ_ERRESC3 | DSI_CIO_IRQ_ERRESC4 | \\\n\t DSI_CIO_IRQ_ERRESC5 | \\\n\t DSI_CIO_IRQ_ERRCONTROL1 | DSI_CIO_IRQ_ERRCONTROL2 | \\\n\t DSI_CIO_IRQ_ERRCONTROL3 | DSI_CIO_IRQ_ERRCONTROL4 | \\\n\t DSI_CIO_IRQ_ERRCONTROL5 | \\\n\t DSI_CIO_IRQ_ERRCONTENTIONLP0_1 | DSI_CIO_IRQ_ERRCONTENTIONLP1_1 | \\\n\t DSI_CIO_IRQ_ERRCONTENTIONLP0_2 | DSI_CIO_IRQ_ERRCONTENTIONLP1_2 | \\\n\t DSI_CIO_IRQ_ERRCONTENTIONLP0_3 | DSI_CIO_IRQ_ERRCONTENTIONLP1_3 | \\\n\t DSI_CIO_IRQ_ERRCONTENTIONLP0_4 | DSI_CIO_IRQ_ERRCONTENTIONLP1_4 | \\\n\t DSI_CIO_IRQ_ERRCONTENTIONLP0_5 | DSI_CIO_IRQ_ERRCONTENTIONLP1_5)\n\ntypedef void (*omap_dsi_isr_t) (void *arg, u32 mask);\n\nstatic int dsi_display_init_dispc(struct platform_device *dsidev,\n\tstruct omap_overlay_manager *mgr);\nstatic void dsi_display_uninit_dispc(struct platform_device *dsidev,\n\tstruct omap_overlay_manager *mgr);\n\nstatic int dsi_vc_send_null(struct omap_dss_device *dssdev, int channel);\n\n \n#define HSDIV_DISPC\t0\n#define HSDIV_DSI\t1\n\n#define DSI_MAX_NR_ISRS                2\n#define DSI_MAX_NR_LANES\t5\n\nenum dsi_lane_function {\n\tDSI_LANE_UNUSED\t= 0,\n\tDSI_LANE_CLK,\n\tDSI_LANE_DATA1,\n\tDSI_LANE_DATA2,\n\tDSI_LANE_DATA3,\n\tDSI_LANE_DATA4,\n};\n\nstruct dsi_lane_config {\n\tenum dsi_lane_function function;\n\tu8 polarity;\n};\n\nstruct dsi_isr_data {\n\tomap_dsi_isr_t\tisr;\n\tvoid\t\t*arg;\n\tu32\t\tmask;\n};\n\nenum fifo_size {\n\tDSI_FIFO_SIZE_0\t\t= 0,\n\tDSI_FIFO_SIZE_32\t= 1,\n\tDSI_FIFO_SIZE_64\t= 2,\n\tDSI_FIFO_SIZE_96\t= 3,\n\tDSI_FIFO_SIZE_128\t= 4,\n};\n\nenum dsi_vc_source {\n\tDSI_VC_SOURCE_L4 = 0,\n\tDSI_VC_SOURCE_VP,\n};\n\nstruct dsi_irq_stats {\n\tunsigned long last_reset;\n\tunsigned irq_count;\n\tunsigned dsi_irqs[32];\n\tunsigned vc_irqs[4][32];\n\tunsigned cio_irqs[32];\n};\n\nstruct dsi_isr_tables {\n\tstruct dsi_isr_data isr_table[DSI_MAX_NR_ISRS];\n\tstruct dsi_isr_data isr_table_vc[4][DSI_MAX_NR_ISRS];\n\tstruct dsi_isr_data isr_table_cio[DSI_MAX_NR_ISRS];\n};\n\nstruct dsi_clk_calc_ctx {\n\tstruct platform_device *dsidev;\n\tstruct dss_pll *pll;\n\n\t \n\n\tconst struct omap_dss_dsi_config *config;\n\n\tunsigned long req_pck_min, req_pck_nom, req_pck_max;\n\n\t \n\n\tstruct dss_pll_clock_info dsi_cinfo;\n\tstruct dispc_clock_info dispc_cinfo;\n\n\tstruct omap_video_timings dispc_vm;\n\tstruct omap_dss_dsi_videomode_timings dsi_vm;\n};\n\nstruct dsi_lp_clock_info {\n\tunsigned long lp_clk;\n\tu16 lp_clk_div;\n};\n\nstruct dsi_data {\n\tstruct platform_device *pdev;\n\tvoid __iomem *proto_base;\n\tvoid __iomem *phy_base;\n\tvoid __iomem *pll_base;\n\n\tint module_id;\n\n\tint irq;\n\n\tbool is_enabled;\n\n\tstruct clk *dss_clk;\n\n\tstruct dispc_clock_info user_dispc_cinfo;\n\tstruct dss_pll_clock_info user_dsi_cinfo;\n\n\tstruct dsi_lp_clock_info user_lp_cinfo;\n\tstruct dsi_lp_clock_info current_lp_cinfo;\n\n\tstruct dss_pll pll;\n\n\tbool vdds_dsi_enabled;\n\tstruct regulator *vdds_dsi_reg;\n\n\tstruct {\n\t\tenum dsi_vc_source source;\n\t\tstruct omap_dss_device *dssdev;\n\t\tenum fifo_size tx_fifo_size;\n\t\tenum fifo_size rx_fifo_size;\n\t\tint vc_id;\n\t} vc[4];\n\n\tstruct mutex lock;\n\tstruct semaphore bus_lock;\n\n\tspinlock_t irq_lock;\n\tstruct dsi_isr_tables isr_tables;\n\t \n\tstruct dsi_isr_tables isr_tables_copy;\n\n\tint update_channel;\n#ifdef DSI_PERF_MEASURE\n\tunsigned update_bytes;\n#endif\n\n\tbool te_enabled;\n\tbool ulps_enabled;\n\n\tvoid (*framedone_callback)(int, void *);\n\tvoid *framedone_data;\n\n\tstruct delayed_work framedone_timeout_work;\n\n#ifdef DSI_CATCH_MISSING_TE\n\tstruct timer_list te_timer;\n#endif\n\n\tunsigned long cache_req_pck;\n\tunsigned long cache_clk_freq;\n\tstruct dss_pll_clock_info cache_cinfo;\n\n\tu32\t\terrors;\n\tspinlock_t\terrors_lock;\n#ifdef DSI_PERF_MEASURE\n\tktime_t perf_setup_time;\n\tktime_t perf_start_time;\n#endif\n\tint debug_read;\n\tint debug_write;\n\n#ifdef CONFIG_FB_OMAP2_DSS_COLLECT_IRQ_STATS\n\tspinlock_t irq_stats_lock;\n\tstruct dsi_irq_stats irq_stats;\n#endif\n\n\tunsigned num_lanes_supported;\n\tunsigned line_buffer_size;\n\n\tstruct dsi_lane_config lanes[DSI_MAX_NR_LANES];\n\tunsigned num_lanes_used;\n\n\tunsigned scp_clk_refcount;\n\n\tstruct dss_lcd_mgr_config mgr_config;\n\tstruct omap_video_timings timings;\n\tenum omap_dss_dsi_pixel_format pix_fmt;\n\tenum omap_dss_dsi_mode mode;\n\tstruct omap_dss_dsi_videomode_timings vm_timings;\n\n\tstruct omap_dss_device output;\n};\n\nstruct dsi_packet_sent_handler_data {\n\tstruct platform_device *dsidev;\n\tstruct completion *completion;\n};\n\nstruct dsi_module_id_data {\n\tu32 address;\n\tint id;\n};\n\nstatic const struct of_device_id dsi_of_match[];\n\n#ifdef DSI_PERF_MEASURE\nstatic bool dsi_perf;\nmodule_param(dsi_perf, bool, 0644);\n#endif\n\nstatic inline struct dsi_data *dsi_get_dsidrv_data(struct platform_device *dsidev)\n{\n\treturn platform_get_drvdata(dsidev);\n}\n\nstatic inline struct platform_device *dsi_get_dsidev_from_dssdev(struct omap_dss_device *dssdev)\n{\n\treturn to_platform_device(dssdev->dev);\n}\n\nstatic struct platform_device *dsi_get_dsidev_from_id(int module)\n{\n\tstruct omap_dss_device *out;\n\tenum omap_dss_output_id\tid;\n\n\tswitch (module) {\n\tcase 0:\n\t\tid = OMAP_DSS_OUTPUT_DSI1;\n\t\tbreak;\n\tcase 1:\n\t\tid = OMAP_DSS_OUTPUT_DSI2;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tout = omap_dss_get_output(id);\n\n\treturn out ? to_platform_device(out->dev) : NULL;\n}\n\nstatic inline void dsi_write_reg(struct platform_device *dsidev,\n\t\tconst struct dsi_reg idx, u32 val)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tvoid __iomem *base;\n\n\tswitch(idx.module) {\n\t\tcase DSI_PROTO: base = dsi->proto_base; break;\n\t\tcase DSI_PHY: base = dsi->phy_base; break;\n\t\tcase DSI_PLL: base = dsi->pll_base; break;\n\t\tdefault: return;\n\t}\n\n\t__raw_writel(val, base + idx.idx);\n}\n\nstatic inline u32 dsi_read_reg(struct platform_device *dsidev,\n\t\tconst struct dsi_reg idx)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tvoid __iomem *base;\n\n\tswitch(idx.module) {\n\t\tcase DSI_PROTO: base = dsi->proto_base; break;\n\t\tcase DSI_PHY: base = dsi->phy_base; break;\n\t\tcase DSI_PLL: base = dsi->pll_base; break;\n\t\tdefault: return 0;\n\t}\n\n\treturn __raw_readl(base + idx.idx);\n}\n\nstatic void dsi_bus_lock(struct omap_dss_device *dssdev)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tdown(&dsi->bus_lock);\n}\n\nstatic void dsi_bus_unlock(struct omap_dss_device *dssdev)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tup(&dsi->bus_lock);\n}\n\nstatic bool dsi_bus_is_locked(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\treturn dsi->bus_lock.count == 0;\n}\n\nstatic void dsi_completion_handler(void *data, u32 mask)\n{\n\tcomplete((struct completion *)data);\n}\n\nstatic inline int wait_for_bit_change(struct platform_device *dsidev,\n\t\tconst struct dsi_reg idx, int bitnum, int value)\n{\n\tunsigned long timeout;\n\tktime_t wait;\n\tint t;\n\n\t \n\tt = 100;\n\twhile (t-- > 0) {\n\t\tif (REG_GET(dsidev, idx, bitnum, bitnum) == value)\n\t\t\treturn value;\n\t}\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile (time_before(jiffies, timeout)) {\n\t\tif (REG_GET(dsidev, idx, bitnum, bitnum) == value)\n\t\t\treturn value;\n\n\t\twait = ns_to_ktime(1000 * 1000);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_hrtimeout(&wait, HRTIMER_MODE_REL);\n\t}\n\n\treturn !value;\n}\n\nu8 dsi_get_pixel_size(enum omap_dss_dsi_pixel_format fmt)\n{\n\tswitch (fmt) {\n\tcase OMAP_DSS_DSI_FMT_RGB888:\n\tcase OMAP_DSS_DSI_FMT_RGB666:\n\t\treturn 24;\n\tcase OMAP_DSS_DSI_FMT_RGB666_PACKED:\n\t\treturn 18;\n\tcase OMAP_DSS_DSI_FMT_RGB565:\n\t\treturn 16;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}\n\n#ifdef DSI_PERF_MEASURE\nstatic void dsi_perf_mark_setup(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tdsi->perf_setup_time = ktime_get();\n}\n\nstatic void dsi_perf_mark_start(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tdsi->perf_start_time = ktime_get();\n}\n\nstatic void dsi_perf_show(struct platform_device *dsidev, const char *name)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tktime_t t, setup_time, trans_time;\n\tu32 total_bytes;\n\tu32 setup_us, trans_us, total_us;\n\n\tif (!dsi_perf)\n\t\treturn;\n\n\tt = ktime_get();\n\n\tsetup_time = ktime_sub(dsi->perf_start_time, dsi->perf_setup_time);\n\tsetup_us = (u32)ktime_to_us(setup_time);\n\tif (setup_us == 0)\n\t\tsetup_us = 1;\n\n\ttrans_time = ktime_sub(t, dsi->perf_start_time);\n\ttrans_us = (u32)ktime_to_us(trans_time);\n\tif (trans_us == 0)\n\t\ttrans_us = 1;\n\n\ttotal_us = setup_us + trans_us;\n\n\ttotal_bytes = dsi->update_bytes;\n\n\tprintk(KERN_INFO \"DSI(%s): %u us + %u us = %u us (%uHz), \"\n\t\t\t\"%u bytes, %u kbytes/sec\\n\",\n\t\t\tname,\n\t\t\tsetup_us,\n\t\t\ttrans_us,\n\t\t\ttotal_us,\n\t\t\t1000*1000 / total_us,\n\t\t\ttotal_bytes,\n\t\t\ttotal_bytes * 1000 / total_us);\n}\n#else\nstatic inline void dsi_perf_mark_setup(struct platform_device *dsidev)\n{\n}\n\nstatic inline void dsi_perf_mark_start(struct platform_device *dsidev)\n{\n}\n\nstatic inline void dsi_perf_show(struct platform_device *dsidev,\n\t\tconst char *name)\n{\n}\n#endif\n\nstatic int verbose_irq;\n\nstatic void print_irq_status(u32 status)\n{\n\tif (status == 0)\n\t\treturn;\n\n\tif (!verbose_irq && (status & ~DSI_IRQ_CHANNEL_MASK) == 0)\n\t\treturn;\n\n#define PIS(x) (status & DSI_IRQ_##x) ? (#x \" \") : \"\"\n\n\tpr_debug(\"DSI IRQ: 0x%x: %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n\",\n\t\tstatus,\n\t\tverbose_irq ? PIS(VC0) : \"\",\n\t\tverbose_irq ? PIS(VC1) : \"\",\n\t\tverbose_irq ? PIS(VC2) : \"\",\n\t\tverbose_irq ? PIS(VC3) : \"\",\n\t\tPIS(WAKEUP),\n\t\tPIS(RESYNC),\n\t\tPIS(PLL_LOCK),\n\t\tPIS(PLL_UNLOCK),\n\t\tPIS(PLL_RECALL),\n\t\tPIS(COMPLEXIO_ERR),\n\t\tPIS(HS_TX_TIMEOUT),\n\t\tPIS(LP_RX_TIMEOUT),\n\t\tPIS(TE_TRIGGER),\n\t\tPIS(ACK_TRIGGER),\n\t\tPIS(SYNC_LOST),\n\t\tPIS(LDO_POWER_GOOD),\n\t\tPIS(TA_TIMEOUT));\n#undef PIS\n}\n\nstatic void print_irq_status_vc(int channel, u32 status)\n{\n\tif (status == 0)\n\t\treturn;\n\n\tif (!verbose_irq && (status & ~DSI_VC_IRQ_PACKET_SENT) == 0)\n\t\treturn;\n\n#define PIS(x) (status & DSI_VC_IRQ_##x) ? (#x \" \") : \"\"\n\n\tpr_debug(\"DSI VC(%d) IRQ 0x%x: %s%s%s%s%s%s%s%s%s\\n\",\n\t\tchannel,\n\t\tstatus,\n\t\tPIS(CS),\n\t\tPIS(ECC_CORR),\n\t\tPIS(ECC_NO_CORR),\n\t\tverbose_irq ? PIS(PACKET_SENT) : \"\",\n\t\tPIS(BTA),\n\t\tPIS(FIFO_TX_OVF),\n\t\tPIS(FIFO_RX_OVF),\n\t\tPIS(FIFO_TX_UDF),\n\t\tPIS(PP_BUSY_CHANGE));\n#undef PIS\n}\n\nstatic void print_irq_status_cio(u32 status)\n{\n\tif (status == 0)\n\t\treturn;\n\n#define PIS(x) (status & DSI_CIO_IRQ_##x) ? (#x \" \") : \"\"\n\n\tpr_debug(\"DSI CIO IRQ 0x%x: %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n\",\n\t\tstatus,\n\t\tPIS(ERRSYNCESC1),\n\t\tPIS(ERRSYNCESC2),\n\t\tPIS(ERRSYNCESC3),\n\t\tPIS(ERRESC1),\n\t\tPIS(ERRESC2),\n\t\tPIS(ERRESC3),\n\t\tPIS(ERRCONTROL1),\n\t\tPIS(ERRCONTROL2),\n\t\tPIS(ERRCONTROL3),\n\t\tPIS(STATEULPS1),\n\t\tPIS(STATEULPS2),\n\t\tPIS(STATEULPS3),\n\t\tPIS(ERRCONTENTIONLP0_1),\n\t\tPIS(ERRCONTENTIONLP1_1),\n\t\tPIS(ERRCONTENTIONLP0_2),\n\t\tPIS(ERRCONTENTIONLP1_2),\n\t\tPIS(ERRCONTENTIONLP0_3),\n\t\tPIS(ERRCONTENTIONLP1_3),\n\t\tPIS(ULPSACTIVENOT_ALL0),\n\t\tPIS(ULPSACTIVENOT_ALL1));\n#undef PIS\n}\n\n#ifdef CONFIG_FB_OMAP2_DSS_COLLECT_IRQ_STATS\nstatic void dsi_collect_irq_stats(struct platform_device *dsidev, u32 irqstatus,\n\t\tu32 *vcstatus, u32 ciostatus)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint i;\n\n\tspin_lock(&dsi->irq_stats_lock);\n\n\tdsi->irq_stats.irq_count++;\n\tdss_collect_irq_stats(irqstatus, dsi->irq_stats.dsi_irqs);\n\n\tfor (i = 0; i < 4; ++i)\n\t\tdss_collect_irq_stats(vcstatus[i], dsi->irq_stats.vc_irqs[i]);\n\n\tdss_collect_irq_stats(ciostatus, dsi->irq_stats.cio_irqs);\n\n\tspin_unlock(&dsi->irq_stats_lock);\n}\n#else\n#define dsi_collect_irq_stats(dsidev, irqstatus, vcstatus, ciostatus)\n#endif\n\nstatic int debug_irq;\n\nstatic void dsi_handle_irq_errors(struct platform_device *dsidev, u32 irqstatus,\n\t\tu32 *vcstatus, u32 ciostatus)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint i;\n\n\tif (irqstatus & DSI_IRQ_ERROR_MASK) {\n\t\tDSSERR(\"DSI error, irqstatus %x\\n\", irqstatus);\n\t\tprint_irq_status(irqstatus);\n\t\tspin_lock(&dsi->errors_lock);\n\t\tdsi->errors |= irqstatus & DSI_IRQ_ERROR_MASK;\n\t\tspin_unlock(&dsi->errors_lock);\n\t} else if (debug_irq) {\n\t\tprint_irq_status(irqstatus);\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (vcstatus[i] & DSI_VC_IRQ_ERROR_MASK) {\n\t\t\tDSSERR(\"DSI VC(%d) error, vc irqstatus %x\\n\",\n\t\t\t\t       i, vcstatus[i]);\n\t\t\tprint_irq_status_vc(i, vcstatus[i]);\n\t\t} else if (debug_irq) {\n\t\t\tprint_irq_status_vc(i, vcstatus[i]);\n\t\t}\n\t}\n\n\tif (ciostatus & DSI_CIO_IRQ_ERROR_MASK) {\n\t\tDSSERR(\"DSI CIO error, cio irqstatus %x\\n\", ciostatus);\n\t\tprint_irq_status_cio(ciostatus);\n\t} else if (debug_irq) {\n\t\tprint_irq_status_cio(ciostatus);\n\t}\n}\n\nstatic void dsi_call_isrs(struct dsi_isr_data *isr_array,\n\t\tunsigned isr_array_size, u32 irqstatus)\n{\n\tstruct dsi_isr_data *isr_data;\n\tint i;\n\n\tfor (i = 0; i < isr_array_size; i++) {\n\t\tisr_data = &isr_array[i];\n\t\tif (isr_data->isr && isr_data->mask & irqstatus)\n\t\t\tisr_data->isr(isr_data->arg, irqstatus);\n\t}\n}\n\nstatic void dsi_handle_isrs(struct dsi_isr_tables *isr_tables,\n\t\tu32 irqstatus, u32 *vcstatus, u32 ciostatus)\n{\n\tint i;\n\n\tdsi_call_isrs(isr_tables->isr_table,\n\t\t\tARRAY_SIZE(isr_tables->isr_table),\n\t\t\tirqstatus);\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (vcstatus[i] == 0)\n\t\t\tcontinue;\n\t\tdsi_call_isrs(isr_tables->isr_table_vc[i],\n\t\t\t\tARRAY_SIZE(isr_tables->isr_table_vc[i]),\n\t\t\t\tvcstatus[i]);\n\t}\n\n\tif (ciostatus != 0)\n\t\tdsi_call_isrs(isr_tables->isr_table_cio,\n\t\t\t\tARRAY_SIZE(isr_tables->isr_table_cio),\n\t\t\t\tciostatus);\n}\n\nstatic irqreturn_t omap_dsi_irq_handler(int irq, void *arg)\n{\n\tstruct platform_device *dsidev;\n\tstruct dsi_data *dsi;\n\tu32 irqstatus, vcstatus[4], ciostatus;\n\tint i;\n\n\tdsidev = (struct platform_device *) arg;\n\tdsi = dsi_get_dsidrv_data(dsidev);\n\n\tif (!dsi->is_enabled)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&dsi->irq_lock);\n\n\tirqstatus = dsi_read_reg(dsidev, DSI_IRQSTATUS);\n\n\t \n\tif (!irqstatus) {\n\t\tspin_unlock(&dsi->irq_lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tdsi_write_reg(dsidev, DSI_IRQSTATUS, irqstatus & ~DSI_IRQ_CHANNEL_MASK);\n\t \n\tdsi_read_reg(dsidev, DSI_IRQSTATUS);\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif ((irqstatus & (1 << i)) == 0) {\n\t\t\tvcstatus[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvcstatus[i] = dsi_read_reg(dsidev, DSI_VC_IRQSTATUS(i));\n\n\t\tdsi_write_reg(dsidev, DSI_VC_IRQSTATUS(i), vcstatus[i]);\n\t\t \n\t\tdsi_read_reg(dsidev, DSI_VC_IRQSTATUS(i));\n\t}\n\n\tif (irqstatus & DSI_IRQ_COMPLEXIO_ERR) {\n\t\tciostatus = dsi_read_reg(dsidev, DSI_COMPLEXIO_IRQ_STATUS);\n\n\t\tdsi_write_reg(dsidev, DSI_COMPLEXIO_IRQ_STATUS, ciostatus);\n\t\t \n\t\tdsi_read_reg(dsidev, DSI_COMPLEXIO_IRQ_STATUS);\n\t} else {\n\t\tciostatus = 0;\n\t}\n\n#ifdef DSI_CATCH_MISSING_TE\n\tif (irqstatus & DSI_IRQ_TE_TRIGGER)\n\t\tdel_timer(&dsi->te_timer);\n#endif\n\n\t \n\tmemcpy(&dsi->isr_tables_copy, &dsi->isr_tables,\n\t\tsizeof(dsi->isr_tables));\n\n\tspin_unlock(&dsi->irq_lock);\n\n\tdsi_handle_isrs(&dsi->isr_tables_copy, irqstatus, vcstatus, ciostatus);\n\n\tdsi_handle_irq_errors(dsidev, irqstatus, vcstatus, ciostatus);\n\n\tdsi_collect_irq_stats(dsidev, irqstatus, vcstatus, ciostatus);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void _omap_dsi_configure_irqs(struct platform_device *dsidev,\n\t\tstruct dsi_isr_data *isr_array,\n\t\tunsigned isr_array_size, u32 default_mask,\n\t\tconst struct dsi_reg enable_reg,\n\t\tconst struct dsi_reg status_reg)\n{\n\tstruct dsi_isr_data *isr_data;\n\tu32 mask;\n\tu32 old_mask;\n\tint i;\n\n\tmask = default_mask;\n\n\tfor (i = 0; i < isr_array_size; i++) {\n\t\tisr_data = &isr_array[i];\n\n\t\tif (isr_data->isr == NULL)\n\t\t\tcontinue;\n\n\t\tmask |= isr_data->mask;\n\t}\n\n\told_mask = dsi_read_reg(dsidev, enable_reg);\n\t \n\tdsi_write_reg(dsidev, status_reg, (mask ^ old_mask) & mask);\n\tdsi_write_reg(dsidev, enable_reg, mask);\n\n\t \n\tdsi_read_reg(dsidev, enable_reg);\n\tdsi_read_reg(dsidev, status_reg);\n}\n\n \nstatic void _omap_dsi_set_irqs(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tu32 mask = DSI_IRQ_ERROR_MASK;\n#ifdef DSI_CATCH_MISSING_TE\n\tmask |= DSI_IRQ_TE_TRIGGER;\n#endif\n\t_omap_dsi_configure_irqs(dsidev, dsi->isr_tables.isr_table,\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table), mask,\n\t\t\tDSI_IRQENABLE, DSI_IRQSTATUS);\n}\n\n \nstatic void _omap_dsi_set_irqs_vc(struct platform_device *dsidev, int vc)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\t_omap_dsi_configure_irqs(dsidev, dsi->isr_tables.isr_table_vc[vc],\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table_vc[vc]),\n\t\t\tDSI_VC_IRQ_ERROR_MASK,\n\t\t\tDSI_VC_IRQENABLE(vc), DSI_VC_IRQSTATUS(vc));\n}\n\n \nstatic void _omap_dsi_set_irqs_cio(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\t_omap_dsi_configure_irqs(dsidev, dsi->isr_tables.isr_table_cio,\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table_cio),\n\t\t\tDSI_CIO_IRQ_ERROR_MASK,\n\t\t\tDSI_COMPLEXIO_IRQ_ENABLE, DSI_COMPLEXIO_IRQ_STATUS);\n}\n\nstatic void _dsi_initialize_irq(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tunsigned long flags;\n\tint vc;\n\n\tspin_lock_irqsave(&dsi->irq_lock, flags);\n\n\tmemset(&dsi->isr_tables, 0, sizeof(dsi->isr_tables));\n\n\t_omap_dsi_set_irqs(dsidev);\n\tfor (vc = 0; vc < 4; ++vc)\n\t\t_omap_dsi_set_irqs_vc(dsidev, vc);\n\t_omap_dsi_set_irqs_cio(dsidev);\n\n\tspin_unlock_irqrestore(&dsi->irq_lock, flags);\n}\n\nstatic int _dsi_register_isr(omap_dsi_isr_t isr, void *arg, u32 mask,\n\t\tstruct dsi_isr_data *isr_array, unsigned isr_array_size)\n{\n\tstruct dsi_isr_data *isr_data;\n\tint free_idx;\n\tint i;\n\n\tBUG_ON(isr == NULL);\n\n\t \n\tfree_idx = -1;\n\tfor (i = 0; i < isr_array_size; i++) {\n\t\tisr_data = &isr_array[i];\n\n\t\tif (isr_data->isr == isr && isr_data->arg == arg &&\n\t\t\t\tisr_data->mask == mask) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (isr_data->isr == NULL && free_idx == -1)\n\t\t\tfree_idx = i;\n\t}\n\n\tif (free_idx == -1)\n\t\treturn -EBUSY;\n\n\tisr_data = &isr_array[free_idx];\n\tisr_data->isr = isr;\n\tisr_data->arg = arg;\n\tisr_data->mask = mask;\n\n\treturn 0;\n}\n\nstatic int _dsi_unregister_isr(omap_dsi_isr_t isr, void *arg, u32 mask,\n\t\tstruct dsi_isr_data *isr_array, unsigned isr_array_size)\n{\n\tstruct dsi_isr_data *isr_data;\n\tint i;\n\n\tfor (i = 0; i < isr_array_size; i++) {\n\t\tisr_data = &isr_array[i];\n\t\tif (isr_data->isr != isr || isr_data->arg != arg ||\n\t\t\t\tisr_data->mask != mask)\n\t\t\tcontinue;\n\n\t\tisr_data->isr = NULL;\n\t\tisr_data->arg = NULL;\n\t\tisr_data->mask = 0;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int dsi_register_isr(struct platform_device *dsidev, omap_dsi_isr_t isr,\n\t\tvoid *arg, u32 mask)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&dsi->irq_lock, flags);\n\n\tr = _dsi_register_isr(isr, arg, mask, dsi->isr_tables.isr_table,\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table));\n\n\tif (r == 0)\n\t\t_omap_dsi_set_irqs(dsidev);\n\n\tspin_unlock_irqrestore(&dsi->irq_lock, flags);\n\n\treturn r;\n}\n\nstatic int dsi_unregister_isr(struct platform_device *dsidev,\n\t\tomap_dsi_isr_t isr, void *arg, u32 mask)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&dsi->irq_lock, flags);\n\n\tr = _dsi_unregister_isr(isr, arg, mask, dsi->isr_tables.isr_table,\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table));\n\n\tif (r == 0)\n\t\t_omap_dsi_set_irqs(dsidev);\n\n\tspin_unlock_irqrestore(&dsi->irq_lock, flags);\n\n\treturn r;\n}\n\nstatic int dsi_register_isr_vc(struct platform_device *dsidev, int channel,\n\t\tomap_dsi_isr_t isr, void *arg, u32 mask)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&dsi->irq_lock, flags);\n\n\tr = _dsi_register_isr(isr, arg, mask,\n\t\t\tdsi->isr_tables.isr_table_vc[channel],\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table_vc[channel]));\n\n\tif (r == 0)\n\t\t_omap_dsi_set_irqs_vc(dsidev, channel);\n\n\tspin_unlock_irqrestore(&dsi->irq_lock, flags);\n\n\treturn r;\n}\n\nstatic int dsi_unregister_isr_vc(struct platform_device *dsidev, int channel,\n\t\tomap_dsi_isr_t isr, void *arg, u32 mask)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&dsi->irq_lock, flags);\n\n\tr = _dsi_unregister_isr(isr, arg, mask,\n\t\t\tdsi->isr_tables.isr_table_vc[channel],\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table_vc[channel]));\n\n\tif (r == 0)\n\t\t_omap_dsi_set_irqs_vc(dsidev, channel);\n\n\tspin_unlock_irqrestore(&dsi->irq_lock, flags);\n\n\treturn r;\n}\n\nstatic int dsi_register_isr_cio(struct platform_device *dsidev,\n\t\tomap_dsi_isr_t isr, void *arg, u32 mask)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&dsi->irq_lock, flags);\n\n\tr = _dsi_register_isr(isr, arg, mask, dsi->isr_tables.isr_table_cio,\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table_cio));\n\n\tif (r == 0)\n\t\t_omap_dsi_set_irqs_cio(dsidev);\n\n\tspin_unlock_irqrestore(&dsi->irq_lock, flags);\n\n\treturn r;\n}\n\nstatic int dsi_unregister_isr_cio(struct platform_device *dsidev,\n\t\tomap_dsi_isr_t isr, void *arg, u32 mask)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&dsi->irq_lock, flags);\n\n\tr = _dsi_unregister_isr(isr, arg, mask, dsi->isr_tables.isr_table_cio,\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table_cio));\n\n\tif (r == 0)\n\t\t_omap_dsi_set_irqs_cio(dsidev);\n\n\tspin_unlock_irqrestore(&dsi->irq_lock, flags);\n\n\treturn r;\n}\n\nstatic u32 dsi_get_errors(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tunsigned long flags;\n\tu32 e;\n\tspin_lock_irqsave(&dsi->errors_lock, flags);\n\te = dsi->errors;\n\tdsi->errors = 0;\n\tspin_unlock_irqrestore(&dsi->errors_lock, flags);\n\treturn e;\n}\n\nstatic int dsi_runtime_get(struct platform_device *dsidev)\n{\n\tint r;\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tDSSDBG(\"dsi_runtime_get\\n\");\n\n\tr = pm_runtime_resume_and_get(&dsi->pdev->dev);\n\tif (WARN_ON(r < 0))\n\t\treturn r;\n\treturn 0;\n}\n\nstatic void dsi_runtime_put(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint r;\n\n\tDSSDBG(\"dsi_runtime_put\\n\");\n\n\tr = pm_runtime_put_sync(&dsi->pdev->dev);\n\tWARN_ON(r < 0 && r != -ENOSYS);\n}\n\nstatic int dsi_regulator_init(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstruct regulator *vdds_dsi;\n\n\tif (dsi->vdds_dsi_reg != NULL)\n\t\treturn 0;\n\n\tvdds_dsi = devm_regulator_get(&dsi->pdev->dev, \"vdd\");\n\n\tif (IS_ERR(vdds_dsi)) {\n\t\tif (PTR_ERR(vdds_dsi) != -EPROBE_DEFER)\n\t\t\tDSSERR(\"can't get DSI VDD regulator\\n\");\n\t\treturn PTR_ERR(vdds_dsi);\n\t}\n\n\tdsi->vdds_dsi_reg = vdds_dsi;\n\n\treturn 0;\n}\n\nstatic void _dsi_print_reset_status(struct platform_device *dsidev)\n{\n\tint b0, b1, b2;\n\n\t \n\tdsi_read_reg(dsidev, DSI_DSIPHY_CFG5);\n\n\tif (dss_has_feature(FEAT_DSI_REVERSE_TXCLKESC)) {\n\t\tb0 = 28;\n\t\tb1 = 27;\n\t\tb2 = 26;\n\t} else {\n\t\tb0 = 24;\n\t\tb1 = 25;\n\t\tb2 = 26;\n\t}\n\n#define DSI_FLD_GET(fld, start, end)\\\n\tFLD_GET(dsi_read_reg(dsidev, DSI_##fld), start, end)\n\n\tpr_debug(\"DSI resets: PLL (%d) CIO (%d) PHY (%x%x%x, %d, %d, %d)\\n\",\n\t\tDSI_FLD_GET(PLL_STATUS, 0, 0),\n\t\tDSI_FLD_GET(COMPLEXIO_CFG1, 29, 29),\n\t\tDSI_FLD_GET(DSIPHY_CFG5, b0, b0),\n\t\tDSI_FLD_GET(DSIPHY_CFG5, b1, b1),\n\t\tDSI_FLD_GET(DSIPHY_CFG5, b2, b2),\n\t\tDSI_FLD_GET(DSIPHY_CFG5, 29, 29),\n\t\tDSI_FLD_GET(DSIPHY_CFG5, 30, 30),\n\t\tDSI_FLD_GET(DSIPHY_CFG5, 31, 31));\n\n#undef DSI_FLD_GET\n}\n\nstatic inline int dsi_if_enable(struct platform_device *dsidev, bool enable)\n{\n\tDSSDBG(\"dsi_if_enable(%d)\\n\", enable);\n\n\tenable = enable ? 1 : 0;\n\tREG_FLD_MOD(dsidev, DSI_CTRL, enable, 0, 0);  \n\n\tif (wait_for_bit_change(dsidev, DSI_CTRL, 0, enable) != enable) {\n\t\t\tDSSERR(\"Failed to set dsi_if_enable to %d\\n\", enable);\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long dsi_get_pll_hsdiv_dispc_rate(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\treturn dsi->pll.cinfo.clkout[HSDIV_DISPC];\n}\n\nstatic unsigned long dsi_get_pll_hsdiv_dsi_rate(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\treturn dsi->pll.cinfo.clkout[HSDIV_DSI];\n}\n\nstatic unsigned long dsi_get_txbyteclkhs(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\treturn dsi->pll.cinfo.clkdco / 16;\n}\n\nstatic unsigned long dsi_fclk_rate(struct platform_device *dsidev)\n{\n\tunsigned long r;\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tif (dss_get_dsi_clk_source(dsi->module_id) == OMAP_DSS_CLK_SRC_FCK) {\n\t\t \n\t\tr = clk_get_rate(dsi->dss_clk);\n\t} else {\n\t\t \n\t\tr = dsi_get_pll_hsdiv_dsi_rate(dsidev);\n\t}\n\n\treturn r;\n}\n\nstatic int dsi_lp_clock_calc(unsigned long dsi_fclk,\n\t\tunsigned long lp_clk_min, unsigned long lp_clk_max,\n\t\tstruct dsi_lp_clock_info *lp_cinfo)\n{\n\tunsigned lp_clk_div;\n\tunsigned long lp_clk;\n\n\tlp_clk_div = DIV_ROUND_UP(dsi_fclk, lp_clk_max * 2);\n\tlp_clk = dsi_fclk / 2 / lp_clk_div;\n\n\tif (lp_clk < lp_clk_min || lp_clk > lp_clk_max)\n\t\treturn -EINVAL;\n\n\tlp_cinfo->lp_clk_div = lp_clk_div;\n\tlp_cinfo->lp_clk = lp_clk;\n\n\treturn 0;\n}\n\nstatic int dsi_set_lp_clk_divisor(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tunsigned long dsi_fclk;\n\tunsigned lp_clk_div;\n\tunsigned long lp_clk;\n\tunsigned lpdiv_max = dss_feat_get_param_max(FEAT_PARAM_DSIPLL_LPDIV);\n\n\n\tlp_clk_div = dsi->user_lp_cinfo.lp_clk_div;\n\n\tif (lp_clk_div == 0 || lp_clk_div > lpdiv_max)\n\t\treturn -EINVAL;\n\n\tdsi_fclk = dsi_fclk_rate(dsidev);\n\n\tlp_clk = dsi_fclk / 2 / lp_clk_div;\n\n\tDSSDBG(\"LP_CLK_DIV %u, LP_CLK %lu\\n\", lp_clk_div, lp_clk);\n\tdsi->current_lp_cinfo.lp_clk = lp_clk;\n\tdsi->current_lp_cinfo.lp_clk_div = lp_clk_div;\n\n\t \n\tREG_FLD_MOD(dsidev, DSI_CLK_CTRL, lp_clk_div, 12, 0);\n\n\t \n\tREG_FLD_MOD(dsidev, DSI_CLK_CTRL, dsi_fclk > 30000000 ? 1 : 0, 21, 21);\n\n\treturn 0;\n}\n\nstatic void dsi_enable_scp_clk(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tif (dsi->scp_clk_refcount++ == 0)\n\t\tREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 1, 14, 14);  \n}\n\nstatic void dsi_disable_scp_clk(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tWARN_ON(dsi->scp_clk_refcount == 0);\n\tif (--dsi->scp_clk_refcount == 0)\n\t\tREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 0, 14, 14);  \n}\n\nenum dsi_pll_power_state {\n\tDSI_PLL_POWER_OFF\t= 0x0,\n\tDSI_PLL_POWER_ON_HSCLK\t= 0x1,\n\tDSI_PLL_POWER_ON_ALL\t= 0x2,\n\tDSI_PLL_POWER_ON_DIV\t= 0x3,\n};\n\nstatic int dsi_pll_power(struct platform_device *dsidev,\n\t\tenum dsi_pll_power_state state)\n{\n\tint t = 0;\n\n\t \n\tif (dss_has_feature(FEAT_DSI_PLL_PWR_BUG) &&\n\t\t\tstate == DSI_PLL_POWER_ON_DIV)\n\t\tstate = DSI_PLL_POWER_ON_ALL;\n\n\t \n\tREG_FLD_MOD(dsidev, DSI_CLK_CTRL, state, 31, 30);\n\n\t \n\twhile (FLD_GET(dsi_read_reg(dsidev, DSI_CLK_CTRL), 29, 28) != state) {\n\t\tif (++t > 1000) {\n\t\t\tDSSERR(\"Failed to set DSI PLL power mode to %d\\n\",\n\t\t\t\t\tstate);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void dsi_pll_calc_dsi_fck(struct dss_pll_clock_info *cinfo)\n{\n\tunsigned long max_dsi_fck;\n\n\tmax_dsi_fck = dss_feat_get_param_max(FEAT_PARAM_DSI_FCK);\n\n\tcinfo->mX[HSDIV_DSI] = DIV_ROUND_UP(cinfo->clkdco, max_dsi_fck);\n\tcinfo->clkout[HSDIV_DSI] = cinfo->clkdco / cinfo->mX[HSDIV_DSI];\n}\n\nstatic int dsi_pll_enable(struct dss_pll *pll)\n{\n\tstruct dsi_data *dsi = container_of(pll, struct dsi_data, pll);\n\tstruct platform_device *dsidev = dsi->pdev;\n\tint r = 0;\n\n\tDSSDBG(\"PLL init\\n\");\n\n\tr = dsi_regulator_init(dsidev);\n\tif (r)\n\t\treturn r;\n\n\tr = dsi_runtime_get(dsidev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tdsi_enable_scp_clk(dsidev);\n\n\tif (!dsi->vdds_dsi_enabled) {\n\t\tr = regulator_enable(dsi->vdds_dsi_reg);\n\t\tif (r)\n\t\t\tgoto err0;\n\t\tdsi->vdds_dsi_enabled = true;\n\t}\n\n\t \n\tdispc_pck_free_enable(1);\n\n\tif (wait_for_bit_change(dsidev, DSI_PLL_STATUS, 0, 1) != 1) {\n\t\tDSSERR(\"PLL not coming out of reset.\\n\");\n\t\tr = -ENODEV;\n\t\tdispc_pck_free_enable(0);\n\t\tgoto err1;\n\t}\n\n\t \n\tdispc_pck_free_enable(0);\n\n\tr = dsi_pll_power(dsidev, DSI_PLL_POWER_ON_ALL);\n\n\tif (r)\n\t\tgoto err1;\n\n\tDSSDBG(\"PLL init done\\n\");\n\n\treturn 0;\nerr1:\n\tif (dsi->vdds_dsi_enabled) {\n\t\tregulator_disable(dsi->vdds_dsi_reg);\n\t\tdsi->vdds_dsi_enabled = false;\n\t}\nerr0:\n\tdsi_disable_scp_clk(dsidev);\n\tdsi_runtime_put(dsidev);\n\treturn r;\n}\n\nstatic void dsi_pll_uninit(struct platform_device *dsidev, bool disconnect_lanes)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tdsi_pll_power(dsidev, DSI_PLL_POWER_OFF);\n\tif (disconnect_lanes) {\n\t\tWARN_ON(!dsi->vdds_dsi_enabled);\n\t\tregulator_disable(dsi->vdds_dsi_reg);\n\t\tdsi->vdds_dsi_enabled = false;\n\t}\n\n\tdsi_disable_scp_clk(dsidev);\n\tdsi_runtime_put(dsidev);\n\n\tDSSDBG(\"PLL uninit done\\n\");\n}\n\nstatic void dsi_pll_disable(struct dss_pll *pll)\n{\n\tstruct dsi_data *dsi = container_of(pll, struct dsi_data, pll);\n\tstruct platform_device *dsidev = dsi->pdev;\n\n\tdsi_pll_uninit(dsidev, true);\n}\n\nstatic void dsi_dump_dsidev_clocks(struct platform_device *dsidev,\n\t\tstruct seq_file *s)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstruct dss_pll_clock_info *cinfo = &dsi->pll.cinfo;\n\tenum omap_dss_clk_source dispc_clk_src, dsi_clk_src;\n\tint dsi_module = dsi->module_id;\n\tstruct dss_pll *pll = &dsi->pll;\n\n\tdispc_clk_src = dss_get_dispc_clk_source();\n\tdsi_clk_src = dss_get_dsi_clk_source(dsi_module);\n\n\tif (dsi_runtime_get(dsidev))\n\t\treturn;\n\n\tseq_printf(s,\t\"- DSI%d PLL -\\n\", dsi_module + 1);\n\n\tseq_printf(s,\t\"dsi pll clkin\\t%lu\\n\", clk_get_rate(pll->clkin));\n\n\tseq_printf(s,\t\"Fint\\t\\t%-16lun %u\\n\", cinfo->fint, cinfo->n);\n\n\tseq_printf(s,\t\"CLKIN4DDR\\t%-16lum %u\\n\",\n\t\t\tcinfo->clkdco, cinfo->m);\n\n\tseq_printf(s,\t\"DSI_PLL_HSDIV_DISPC (%s)\\t%-16lum_dispc %u\\t(%s)\\n\",\n\t\t\tdss_feat_get_clk_source_name(dsi_module == 0 ?\n\t\t\t\tOMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC :\n\t\t\t\tOMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC),\n\t\t\tcinfo->clkout[HSDIV_DISPC],\n\t\t\tcinfo->mX[HSDIV_DISPC],\n\t\t\tdispc_clk_src == OMAP_DSS_CLK_SRC_FCK ?\n\t\t\t\"off\" : \"on\");\n\n\tseq_printf(s,\t\"DSI_PLL_HSDIV_DSI (%s)\\t%-16lum_dsi %u\\t(%s)\\n\",\n\t\t\tdss_feat_get_clk_source_name(dsi_module == 0 ?\n\t\t\t\tOMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI :\n\t\t\t\tOMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI),\n\t\t\tcinfo->clkout[HSDIV_DSI],\n\t\t\tcinfo->mX[HSDIV_DSI],\n\t\t\tdsi_clk_src == OMAP_DSS_CLK_SRC_FCK ?\n\t\t\t\"off\" : \"on\");\n\n\tseq_printf(s,\t\"- DSI%d -\\n\", dsi_module + 1);\n\n\tseq_printf(s,\t\"dsi fclk source = %s (%s)\\n\",\n\t\t\tdss_get_generic_clk_source_name(dsi_clk_src),\n\t\t\tdss_feat_get_clk_source_name(dsi_clk_src));\n\n\tseq_printf(s,\t\"DSI_FCLK\\t%lu\\n\", dsi_fclk_rate(dsidev));\n\n\tseq_printf(s,\t\"DDR_CLK\\t\\t%lu\\n\",\n\t\t\tcinfo->clkdco / 4);\n\n\tseq_printf(s,\t\"TxByteClkHS\\t%lu\\n\", dsi_get_txbyteclkhs(dsidev));\n\n\tseq_printf(s,\t\"LP_CLK\\t\\t%lu\\n\", dsi->current_lp_cinfo.lp_clk);\n\n\tdsi_runtime_put(dsidev);\n}\n\nvoid dsi_dump_clocks(struct seq_file *s)\n{\n\tstruct platform_device *dsidev;\n\tint i;\n\n\tfor  (i = 0; i < MAX_NUM_DSI; i++) {\n\t\tdsidev = dsi_get_dsidev_from_id(i);\n\t\tif (dsidev)\n\t\t\tdsi_dump_dsidev_clocks(dsidev, s);\n\t}\n}\n\n#ifdef CONFIG_FB_OMAP2_DSS_COLLECT_IRQ_STATS\nstatic void dsi_dump_dsidev_irqs(struct platform_device *dsidev,\n\t\tstruct seq_file *s)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tunsigned long flags;\n\tstruct dsi_irq_stats *stats;\n\n\tstats = kzalloc(sizeof(*stats), GFP_KERNEL);\n\tif (!stats) {\n\t\tseq_printf(s, \"out of memory\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&dsi->irq_stats_lock, flags);\n\n\t*stats = dsi->irq_stats;\n\tmemset(&dsi->irq_stats, 0, sizeof(dsi->irq_stats));\n\tdsi->irq_stats.last_reset = jiffies;\n\n\tspin_unlock_irqrestore(&dsi->irq_stats_lock, flags);\n\n\tseq_printf(s, \"period %u ms\\n\",\n\t\t\tjiffies_to_msecs(jiffies - stats->last_reset));\n\n\tseq_printf(s, \"irqs %d\\n\", stats->irq_count);\n#define PIS(x) \\\n\tseq_printf(s, \"%-20s %10d\\n\", #x, stats->dsi_irqs[ffs(DSI_IRQ_##x)-1])\n\n\tseq_printf(s, \"-- DSI%d interrupts --\\n\", dsi->module_id + 1);\n\tPIS(VC0);\n\tPIS(VC1);\n\tPIS(VC2);\n\tPIS(VC3);\n\tPIS(WAKEUP);\n\tPIS(RESYNC);\n\tPIS(PLL_LOCK);\n\tPIS(PLL_UNLOCK);\n\tPIS(PLL_RECALL);\n\tPIS(COMPLEXIO_ERR);\n\tPIS(HS_TX_TIMEOUT);\n\tPIS(LP_RX_TIMEOUT);\n\tPIS(TE_TRIGGER);\n\tPIS(ACK_TRIGGER);\n\tPIS(SYNC_LOST);\n\tPIS(LDO_POWER_GOOD);\n\tPIS(TA_TIMEOUT);\n#undef PIS\n\n#define PIS(x) \\\n\tseq_printf(s, \"%-20s %10d %10d %10d %10d\\n\", #x, \\\n\t\t\tstats->vc_irqs[0][ffs(DSI_VC_IRQ_##x)-1], \\\n\t\t\tstats->vc_irqs[1][ffs(DSI_VC_IRQ_##x)-1], \\\n\t\t\tstats->vc_irqs[2][ffs(DSI_VC_IRQ_##x)-1], \\\n\t\t\tstats->vc_irqs[3][ffs(DSI_VC_IRQ_##x)-1]);\n\n\tseq_printf(s, \"-- VC interrupts --\\n\");\n\tPIS(CS);\n\tPIS(ECC_CORR);\n\tPIS(PACKET_SENT);\n\tPIS(FIFO_TX_OVF);\n\tPIS(FIFO_RX_OVF);\n\tPIS(BTA);\n\tPIS(ECC_NO_CORR);\n\tPIS(FIFO_TX_UDF);\n\tPIS(PP_BUSY_CHANGE);\n#undef PIS\n\n#define PIS(x) \\\n\tseq_printf(s, \"%-20s %10d\\n\", #x, \\\n\t\t\tstats->cio_irqs[ffs(DSI_CIO_IRQ_##x)-1]);\n\n\tseq_printf(s, \"-- CIO interrupts --\\n\");\n\tPIS(ERRSYNCESC1);\n\tPIS(ERRSYNCESC2);\n\tPIS(ERRSYNCESC3);\n\tPIS(ERRESC1);\n\tPIS(ERRESC2);\n\tPIS(ERRESC3);\n\tPIS(ERRCONTROL1);\n\tPIS(ERRCONTROL2);\n\tPIS(ERRCONTROL3);\n\tPIS(STATEULPS1);\n\tPIS(STATEULPS2);\n\tPIS(STATEULPS3);\n\tPIS(ERRCONTENTIONLP0_1);\n\tPIS(ERRCONTENTIONLP1_1);\n\tPIS(ERRCONTENTIONLP0_2);\n\tPIS(ERRCONTENTIONLP1_2);\n\tPIS(ERRCONTENTIONLP0_3);\n\tPIS(ERRCONTENTIONLP1_3);\n\tPIS(ULPSACTIVENOT_ALL0);\n\tPIS(ULPSACTIVENOT_ALL1);\n#undef PIS\n\n\tkfree(stats);\n}\n\nstatic void dsi1_dump_irqs(struct seq_file *s)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_id(0);\n\n\tdsi_dump_dsidev_irqs(dsidev, s);\n}\n\nstatic void dsi2_dump_irqs(struct seq_file *s)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_id(1);\n\n\tdsi_dump_dsidev_irqs(dsidev, s);\n}\n#endif\n\nstatic void dsi_dump_dsidev_regs(struct platform_device *dsidev,\n\t\tstruct seq_file *s)\n{\n#define DUMPREG(r) seq_printf(s, \"%-35s %08x\\n\", #r, dsi_read_reg(dsidev, r))\n\n\tif (dsi_runtime_get(dsidev))\n\t\treturn;\n\tdsi_enable_scp_clk(dsidev);\n\n\tDUMPREG(DSI_REVISION);\n\tDUMPREG(DSI_SYSCONFIG);\n\tDUMPREG(DSI_SYSSTATUS);\n\tDUMPREG(DSI_IRQSTATUS);\n\tDUMPREG(DSI_IRQENABLE);\n\tDUMPREG(DSI_CTRL);\n\tDUMPREG(DSI_COMPLEXIO_CFG1);\n\tDUMPREG(DSI_COMPLEXIO_IRQ_STATUS);\n\tDUMPREG(DSI_COMPLEXIO_IRQ_ENABLE);\n\tDUMPREG(DSI_CLK_CTRL);\n\tDUMPREG(DSI_TIMING1);\n\tDUMPREG(DSI_TIMING2);\n\tDUMPREG(DSI_VM_TIMING1);\n\tDUMPREG(DSI_VM_TIMING2);\n\tDUMPREG(DSI_VM_TIMING3);\n\tDUMPREG(DSI_CLK_TIMING);\n\tDUMPREG(DSI_TX_FIFO_VC_SIZE);\n\tDUMPREG(DSI_RX_FIFO_VC_SIZE);\n\tDUMPREG(DSI_COMPLEXIO_CFG2);\n\tDUMPREG(DSI_RX_FIFO_VC_FULLNESS);\n\tDUMPREG(DSI_VM_TIMING4);\n\tDUMPREG(DSI_TX_FIFO_VC_EMPTINESS);\n\tDUMPREG(DSI_VM_TIMING5);\n\tDUMPREG(DSI_VM_TIMING6);\n\tDUMPREG(DSI_VM_TIMING7);\n\tDUMPREG(DSI_STOPCLK_TIMING);\n\n\tDUMPREG(DSI_VC_CTRL(0));\n\tDUMPREG(DSI_VC_TE(0));\n\tDUMPREG(DSI_VC_LONG_PACKET_HEADER(0));\n\tDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(0));\n\tDUMPREG(DSI_VC_SHORT_PACKET_HEADER(0));\n\tDUMPREG(DSI_VC_IRQSTATUS(0));\n\tDUMPREG(DSI_VC_IRQENABLE(0));\n\n\tDUMPREG(DSI_VC_CTRL(1));\n\tDUMPREG(DSI_VC_TE(1));\n\tDUMPREG(DSI_VC_LONG_PACKET_HEADER(1));\n\tDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(1));\n\tDUMPREG(DSI_VC_SHORT_PACKET_HEADER(1));\n\tDUMPREG(DSI_VC_IRQSTATUS(1));\n\tDUMPREG(DSI_VC_IRQENABLE(1));\n\n\tDUMPREG(DSI_VC_CTRL(2));\n\tDUMPREG(DSI_VC_TE(2));\n\tDUMPREG(DSI_VC_LONG_PACKET_HEADER(2));\n\tDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(2));\n\tDUMPREG(DSI_VC_SHORT_PACKET_HEADER(2));\n\tDUMPREG(DSI_VC_IRQSTATUS(2));\n\tDUMPREG(DSI_VC_IRQENABLE(2));\n\n\tDUMPREG(DSI_VC_CTRL(3));\n\tDUMPREG(DSI_VC_TE(3));\n\tDUMPREG(DSI_VC_LONG_PACKET_HEADER(3));\n\tDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(3));\n\tDUMPREG(DSI_VC_SHORT_PACKET_HEADER(3));\n\tDUMPREG(DSI_VC_IRQSTATUS(3));\n\tDUMPREG(DSI_VC_IRQENABLE(3));\n\n\tDUMPREG(DSI_DSIPHY_CFG0);\n\tDUMPREG(DSI_DSIPHY_CFG1);\n\tDUMPREG(DSI_DSIPHY_CFG2);\n\tDUMPREG(DSI_DSIPHY_CFG5);\n\n\tDUMPREG(DSI_PLL_CONTROL);\n\tDUMPREG(DSI_PLL_STATUS);\n\tDUMPREG(DSI_PLL_GO);\n\tDUMPREG(DSI_PLL_CONFIGURATION1);\n\tDUMPREG(DSI_PLL_CONFIGURATION2);\n\n\tdsi_disable_scp_clk(dsidev);\n\tdsi_runtime_put(dsidev);\n#undef DUMPREG\n}\n\nstatic void dsi1_dump_regs(struct seq_file *s)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_id(0);\n\n\tdsi_dump_dsidev_regs(dsidev, s);\n}\n\nstatic void dsi2_dump_regs(struct seq_file *s)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_id(1);\n\n\tdsi_dump_dsidev_regs(dsidev, s);\n}\n\nenum dsi_cio_power_state {\n\tDSI_COMPLEXIO_POWER_OFF\t\t= 0x0,\n\tDSI_COMPLEXIO_POWER_ON\t\t= 0x1,\n\tDSI_COMPLEXIO_POWER_ULPS\t= 0x2,\n};\n\nstatic int dsi_cio_power(struct platform_device *dsidev,\n\t\tenum dsi_cio_power_state state)\n{\n\tint t = 0;\n\n\t \n\tREG_FLD_MOD(dsidev, DSI_COMPLEXIO_CFG1, state, 28, 27);\n\n\t \n\twhile (FLD_GET(dsi_read_reg(dsidev, DSI_COMPLEXIO_CFG1),\n\t\t\t26, 25) != state) {\n\t\tif (++t > 1000) {\n\t\t\tDSSERR(\"failed to set complexio power state to \"\n\t\t\t\t\t\"%d\\n\", state);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned dsi_get_line_buf_size(struct platform_device *dsidev)\n{\n\tint val;\n\n\t \n\t \n\tif (!dss_has_feature(FEAT_DSI_GNQ))\n\t\treturn 1023 * 3;\n\n\tval = REG_GET(dsidev, DSI_GNQ, 14, 12);  \n\n\tswitch (val) {\n\tcase 1:\n\t\treturn 512 * 3;\t\t \n\tcase 2:\n\t\treturn 682 * 3;\t\t \n\tcase 3:\n\t\treturn 853 * 3;\t\t \n\tcase 4:\n\t\treturn 1024 * 3;\t \n\tcase 5:\n\t\treturn 1194 * 3;\t \n\tcase 6:\n\t\treturn 1365 * 3;\t \n\tcase 7:\n\t\treturn 1920 * 3;\t \n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}\n\nstatic int dsi_set_lane_config(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstatic const u8 offsets[] = { 0, 4, 8, 12, 16 };\n\tstatic const enum dsi_lane_function functions[] = {\n\t\tDSI_LANE_CLK,\n\t\tDSI_LANE_DATA1,\n\t\tDSI_LANE_DATA2,\n\t\tDSI_LANE_DATA3,\n\t\tDSI_LANE_DATA4,\n\t};\n\tu32 r;\n\tint i;\n\n\tr = dsi_read_reg(dsidev, DSI_COMPLEXIO_CFG1);\n\n\tfor (i = 0; i < dsi->num_lanes_used; ++i) {\n\t\tunsigned offset = offsets[i];\n\t\tunsigned polarity, lane_number;\n\t\tunsigned t;\n\n\t\tfor (t = 0; t < dsi->num_lanes_supported; ++t)\n\t\t\tif (dsi->lanes[t].function == functions[i])\n\t\t\t\tbreak;\n\n\t\tif (t == dsi->num_lanes_supported)\n\t\t\treturn -EINVAL;\n\n\t\tlane_number = t;\n\t\tpolarity = dsi->lanes[t].polarity;\n\n\t\tr = FLD_MOD(r, lane_number + 1, offset + 2, offset);\n\t\tr = FLD_MOD(r, polarity, offset + 3, offset + 3);\n\t}\n\n\t \n\tfor (; i < dsi->num_lanes_supported; ++i) {\n\t\tunsigned offset = offsets[i];\n\n\t\tr = FLD_MOD(r, 0, offset + 2, offset);\n\t\tr = FLD_MOD(r, 0, offset + 3, offset + 3);\n\t}\n\n\tdsi_write_reg(dsidev, DSI_COMPLEXIO_CFG1, r);\n\n\treturn 0;\n}\n\nstatic inline unsigned ns2ddr(struct platform_device *dsidev, unsigned ns)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\t \n\tunsigned long ddr_clk = dsi->pll.cinfo.clkdco / 4;\n\treturn (ns * (ddr_clk / 1000 / 1000) + 999) / 1000;\n}\n\nstatic inline unsigned ddr2ns(struct platform_device *dsidev, unsigned ddr)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tunsigned long ddr_clk = dsi->pll.cinfo.clkdco / 4;\n\treturn ddr * 1000 * 1000 / (ddr_clk / 1000);\n}\n\nstatic void dsi_cio_timings(struct platform_device *dsidev)\n{\n\tu32 r;\n\tu32 ths_prepare, ths_prepare_ths_zero, ths_trail, ths_exit;\n\tu32 tlpx_half, tclk_trail, tclk_zero;\n\tu32 tclk_prepare;\n\n\t \n\n\t \n\n\t \n\tths_prepare = ns2ddr(dsidev, 70) + 2;\n\n\t \n\tths_prepare_ths_zero = ns2ddr(dsidev, 175) + 2;\n\n\t \n\tths_trail = ns2ddr(dsidev, 60) + 5;\n\n\t \n\tths_exit = ns2ddr(dsidev, 145);\n\n\t \n\ttlpx_half = ns2ddr(dsidev, 25);\n\n\t \n\ttclk_trail = ns2ddr(dsidev, 60) + 2;\n\n\t \n\ttclk_prepare = ns2ddr(dsidev, 65);\n\n\t \n\ttclk_zero = ns2ddr(dsidev, 260);\n\n\tDSSDBG(\"ths_prepare %u (%uns), ths_prepare_ths_zero %u (%uns)\\n\",\n\t\tths_prepare, ddr2ns(dsidev, ths_prepare),\n\t\tths_prepare_ths_zero, ddr2ns(dsidev, ths_prepare_ths_zero));\n\tDSSDBG(\"ths_trail %u (%uns), ths_exit %u (%uns)\\n\",\n\t\t\tths_trail, ddr2ns(dsidev, ths_trail),\n\t\t\tths_exit, ddr2ns(dsidev, ths_exit));\n\n\tDSSDBG(\"tlpx_half %u (%uns), tclk_trail %u (%uns), \"\n\t\t\t\"tclk_zero %u (%uns)\\n\",\n\t\t\ttlpx_half, ddr2ns(dsidev, tlpx_half),\n\t\t\ttclk_trail, ddr2ns(dsidev, tclk_trail),\n\t\t\ttclk_zero, ddr2ns(dsidev, tclk_zero));\n\tDSSDBG(\"tclk_prepare %u (%uns)\\n\",\n\t\t\ttclk_prepare, ddr2ns(dsidev, tclk_prepare));\n\n\t \n\n\tr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG0);\n\tr = FLD_MOD(r, ths_prepare, 31, 24);\n\tr = FLD_MOD(r, ths_prepare_ths_zero, 23, 16);\n\tr = FLD_MOD(r, ths_trail, 15, 8);\n\tr = FLD_MOD(r, ths_exit, 7, 0);\n\tdsi_write_reg(dsidev, DSI_DSIPHY_CFG0, r);\n\n\tr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG1);\n\tr = FLD_MOD(r, tlpx_half, 20, 16);\n\tr = FLD_MOD(r, tclk_trail, 15, 8);\n\tr = FLD_MOD(r, tclk_zero, 7, 0);\n\n\tif (dss_has_feature(FEAT_DSI_PHY_DCC)) {\n\t\tr = FLD_MOD(r, 0, 21, 21);\t \n\t\tr = FLD_MOD(r, 1, 22, 22);\t \n\t\tr = FLD_MOD(r, 1, 23, 23);\t \n\t}\n\n\tdsi_write_reg(dsidev, DSI_DSIPHY_CFG1, r);\n\n\tr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG2);\n\tr = FLD_MOD(r, tclk_prepare, 7, 0);\n\tdsi_write_reg(dsidev, DSI_DSIPHY_CFG2, r);\n}\n\n \nstatic void dsi_cio_enable_lane_override(struct platform_device *dsidev,\n\t\tunsigned mask_p, unsigned mask_n)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint i;\n\tu32 l;\n\tu8 lptxscp_start = dsi->num_lanes_supported == 3 ? 22 : 26;\n\n\tl = 0;\n\n\tfor (i = 0; i < dsi->num_lanes_supported; ++i) {\n\t\tunsigned p = dsi->lanes[i].polarity;\n\n\t\tif (mask_p & (1 << i))\n\t\t\tl |= 1 << (i * 2 + (p ? 0 : 1));\n\n\t\tif (mask_n & (1 << i))\n\t\t\tl |= 1 << (i * 2 + (p ? 1 : 0));\n\t}\n\n\t \n\n\t \n\n\t \n\tREG_FLD_MOD(dsidev, DSI_DSIPHY_CFG10, l, lptxscp_start, 17);\n\n\t \n\n\t \n\tREG_FLD_MOD(dsidev, DSI_DSIPHY_CFG10, 1, 27, 27);\n}\n\nstatic void dsi_cio_disable_lane_override(struct platform_device *dsidev)\n{\n\t \n\tREG_FLD_MOD(dsidev, DSI_DSIPHY_CFG10, 0, 27, 27);  \n\t \n\t \n\tREG_FLD_MOD(dsidev, DSI_DSIPHY_CFG10, 0, 22, 17);\n}\n\nstatic int dsi_cio_wait_tx_clk_esc_reset(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint t, i;\n\tbool in_use[DSI_MAX_NR_LANES];\n\tstatic const u8 offsets_old[] = { 28, 27, 26 };\n\tstatic const u8 offsets_new[] = { 24, 25, 26, 27, 28 };\n\tconst u8 *offsets;\n\n\tif (dss_has_feature(FEAT_DSI_REVERSE_TXCLKESC))\n\t\toffsets = offsets_old;\n\telse\n\t\toffsets = offsets_new;\n\n\tfor (i = 0; i < dsi->num_lanes_supported; ++i)\n\t\tin_use[i] = dsi->lanes[i].function != DSI_LANE_UNUSED;\n\n\tt = 100000;\n\twhile (true) {\n\t\tu32 l;\n\t\tint ok;\n\n\t\tl = dsi_read_reg(dsidev, DSI_DSIPHY_CFG5);\n\n\t\tok = 0;\n\t\tfor (i = 0; i < dsi->num_lanes_supported; ++i) {\n\t\t\tif (!in_use[i] || (l & (1 << offsets[i])))\n\t\t\t\tok++;\n\t\t}\n\n\t\tif (ok == dsi->num_lanes_supported)\n\t\t\tbreak;\n\n\t\tif (--t == 0) {\n\t\t\tfor (i = 0; i < dsi->num_lanes_supported; ++i) {\n\t\t\t\tif (!in_use[i] || (l & (1 << offsets[i])))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tDSSERR(\"CIO TXCLKESC%d domain not coming \" \\\n\t\t\t\t\t\t\"out of reset\\n\", i);\n\t\t\t}\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic unsigned dsi_get_lane_mask(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tunsigned mask = 0;\n\tint i;\n\n\tfor (i = 0; i < dsi->num_lanes_supported; ++i) {\n\t\tif (dsi->lanes[i].function != DSI_LANE_UNUSED)\n\t\t\tmask |= 1 << i;\n\t}\n\n\treturn mask;\n}\n\nstatic int dsi_cio_init(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint r;\n\tu32 l;\n\n\tDSSDBG(\"DSI CIO init starts\");\n\n\tr = dss_dsi_enable_pads(dsi->module_id, dsi_get_lane_mask(dsidev));\n\tif (r)\n\t\treturn r;\n\n\tdsi_enable_scp_clk(dsidev);\n\n\t \n\tdsi_read_reg(dsidev, DSI_DSIPHY_CFG5);\n\n\tif (wait_for_bit_change(dsidev, DSI_DSIPHY_CFG5, 30, 1) != 1) {\n\t\tDSSERR(\"CIO SCP Clock domain not coming out of reset.\\n\");\n\t\tr = -EIO;\n\t\tgoto err_scp_clk_dom;\n\t}\n\n\tr = dsi_set_lane_config(dsidev);\n\tif (r)\n\t\tgoto err_scp_clk_dom;\n\n\t \n\tl = dsi_read_reg(dsidev, DSI_TIMING1);\n\tl = FLD_MOD(l, 1, 15, 15);\t \n\tl = FLD_MOD(l, 1, 14, 14);\t \n\tl = FLD_MOD(l, 1, 13, 13);\t \n\tl = FLD_MOD(l, 0x1fff, 12, 0);\t \n\tdsi_write_reg(dsidev, DSI_TIMING1, l);\n\n\tif (dsi->ulps_enabled) {\n\t\tunsigned mask_p;\n\t\tint i;\n\n\t\tDSSDBG(\"manual ulps exit\\n\");\n\n\t\t \n\n\t\tmask_p = 0;\n\n\t\tfor (i = 0; i < dsi->num_lanes_supported; ++i) {\n\t\t\tif (dsi->lanes[i].function == DSI_LANE_UNUSED)\n\t\t\t\tcontinue;\n\t\t\tmask_p |= 1 << i;\n\t\t}\n\n\t\tdsi_cio_enable_lane_override(dsidev, mask_p, 0);\n\t}\n\n\tr = dsi_cio_power(dsidev, DSI_COMPLEXIO_POWER_ON);\n\tif (r)\n\t\tgoto err_cio_pwr;\n\n\tif (wait_for_bit_change(dsidev, DSI_COMPLEXIO_CFG1, 29, 1) != 1) {\n\t\tDSSERR(\"CIO PWR clock domain not coming out of reset.\\n\");\n\t\tr = -ENODEV;\n\t\tgoto err_cio_pwr_dom;\n\t}\n\n\tdsi_if_enable(dsidev, true);\n\tdsi_if_enable(dsidev, false);\n\tREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 1, 20, 20);  \n\n\tr = dsi_cio_wait_tx_clk_esc_reset(dsidev);\n\tif (r)\n\t\tgoto err_tx_clk_esc_rst;\n\n\tif (dsi->ulps_enabled) {\n\t\t \n\t\tktime_t wait = ns_to_ktime(1000 * 1000);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_hrtimeout(&wait, HRTIMER_MODE_REL);\n\n\t\t \n\t\tdsi_cio_disable_lane_override(dsidev);\n\t}\n\n\t \n\tREG_FLD_MOD(dsidev, DSI_TIMING1, 0, 15, 15);\n\n\tdsi_cio_timings(dsidev);\n\n\tif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\n\t\t \n\t\tREG_FLD_MOD(dsidev, DSI_CLK_CTRL,\n\t\t\tdsi->vm_timings.ddr_clk_always_on, 13, 13);\n\t}\n\n\tdsi->ulps_enabled = false;\n\n\tDSSDBG(\"CIO init done\\n\");\n\n\treturn 0;\n\nerr_tx_clk_esc_rst:\n\tREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 0, 20, 20);  \nerr_cio_pwr_dom:\n\tdsi_cio_power(dsidev, DSI_COMPLEXIO_POWER_OFF);\nerr_cio_pwr:\n\tif (dsi->ulps_enabled)\n\t\tdsi_cio_disable_lane_override(dsidev);\nerr_scp_clk_dom:\n\tdsi_disable_scp_clk(dsidev);\n\tdss_dsi_disable_pads(dsi->module_id, dsi_get_lane_mask(dsidev));\n\treturn r;\n}\n\nstatic void dsi_cio_uninit(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\t \n\tREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 0, 13, 13);\n\n\tdsi_cio_power(dsidev, DSI_COMPLEXIO_POWER_OFF);\n\tdsi_disable_scp_clk(dsidev);\n\tdss_dsi_disable_pads(dsi->module_id, dsi_get_lane_mask(dsidev));\n}\n\nstatic void dsi_config_tx_fifo(struct platform_device *dsidev,\n\t\tenum fifo_size size1, enum fifo_size size2,\n\t\tenum fifo_size size3, enum fifo_size size4)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tu32 r = 0;\n\tint add = 0;\n\tint i;\n\n\tdsi->vc[0].tx_fifo_size = size1;\n\tdsi->vc[1].tx_fifo_size = size2;\n\tdsi->vc[2].tx_fifo_size = size3;\n\tdsi->vc[3].tx_fifo_size = size4;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu8 v;\n\t\tint size = dsi->vc[i].tx_fifo_size;\n\n\t\tif (add + size > 4) {\n\t\t\tDSSERR(\"Illegal FIFO configuration\\n\");\n\t\t\tBUG();\n\t\t\treturn;\n\t\t}\n\n\t\tv = FLD_VAL(add, 2, 0) | FLD_VAL(size, 7, 4);\n\t\tr |= v << (8 * i);\n\t\t \n\t\tadd += size;\n\t}\n\n\tdsi_write_reg(dsidev, DSI_TX_FIFO_VC_SIZE, r);\n}\n\nstatic void dsi_config_rx_fifo(struct platform_device *dsidev,\n\t\tenum fifo_size size1, enum fifo_size size2,\n\t\tenum fifo_size size3, enum fifo_size size4)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tu32 r = 0;\n\tint add = 0;\n\tint i;\n\n\tdsi->vc[0].rx_fifo_size = size1;\n\tdsi->vc[1].rx_fifo_size = size2;\n\tdsi->vc[2].rx_fifo_size = size3;\n\tdsi->vc[3].rx_fifo_size = size4;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu8 v;\n\t\tint size = dsi->vc[i].rx_fifo_size;\n\n\t\tif (add + size > 4) {\n\t\t\tDSSERR(\"Illegal FIFO configuration\\n\");\n\t\t\tBUG();\n\t\t\treturn;\n\t\t}\n\n\t\tv = FLD_VAL(add, 2, 0) | FLD_VAL(size, 7, 4);\n\t\tr |= v << (8 * i);\n\t\t \n\t\tadd += size;\n\t}\n\n\tdsi_write_reg(dsidev, DSI_RX_FIFO_VC_SIZE, r);\n}\n\nstatic int dsi_force_tx_stop_mode_io(struct platform_device *dsidev)\n{\n\tu32 r;\n\n\tr = dsi_read_reg(dsidev, DSI_TIMING1);\n\tr = FLD_MOD(r, 1, 15, 15);\t \n\tdsi_write_reg(dsidev, DSI_TIMING1, r);\n\n\tif (wait_for_bit_change(dsidev, DSI_TIMING1, 15, 0) != 0) {\n\t\tDSSERR(\"TX_STOP bit not going down\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic bool dsi_vc_is_enabled(struct platform_device *dsidev, int channel)\n{\n\treturn REG_GET(dsidev, DSI_VC_CTRL(channel), 0, 0);\n}\n\nstatic void dsi_packet_sent_handler_vp(void *data, u32 mask)\n{\n\tstruct dsi_packet_sent_handler_data *vp_data =\n\t\t(struct dsi_packet_sent_handler_data *) data;\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(vp_data->dsidev);\n\tconst int channel = dsi->update_channel;\n\tu8 bit = dsi->te_enabled ? 30 : 31;\n\n\tif (REG_GET(vp_data->dsidev, DSI_VC_TE(channel), bit, bit) == 0)\n\t\tcomplete(vp_data->completion);\n}\n\nstatic int dsi_sync_vc_vp(struct platform_device *dsidev, int channel)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tstruct dsi_packet_sent_handler_data vp_data = {\n\t\t.dsidev = dsidev,\n\t\t.completion = &completion\n\t};\n\tint r = 0;\n\tu8 bit;\n\n\tbit = dsi->te_enabled ? 30 : 31;\n\n\tr = dsi_register_isr_vc(dsidev, channel, dsi_packet_sent_handler_vp,\n\t\t&vp_data, DSI_VC_IRQ_PACKET_SENT);\n\tif (r)\n\t\tgoto err0;\n\n\t \n\tif (REG_GET(dsidev, DSI_VC_TE(channel), bit, bit)) {\n\t\tif (wait_for_completion_timeout(&completion,\n\t\t\t\tmsecs_to_jiffies(10)) == 0) {\n\t\t\tDSSERR(\"Failed to complete previous frame transfer\\n\");\n\t\t\tr = -EIO;\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tdsi_unregister_isr_vc(dsidev, channel, dsi_packet_sent_handler_vp,\n\t\t&vp_data, DSI_VC_IRQ_PACKET_SENT);\n\n\treturn 0;\nerr1:\n\tdsi_unregister_isr_vc(dsidev, channel, dsi_packet_sent_handler_vp,\n\t\t&vp_data, DSI_VC_IRQ_PACKET_SENT);\nerr0:\n\treturn r;\n}\n\nstatic void dsi_packet_sent_handler_l4(void *data, u32 mask)\n{\n\tstruct dsi_packet_sent_handler_data *l4_data =\n\t\t(struct dsi_packet_sent_handler_data *) data;\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(l4_data->dsidev);\n\tconst int channel = dsi->update_channel;\n\n\tif (REG_GET(l4_data->dsidev, DSI_VC_CTRL(channel), 5, 5) == 0)\n\t\tcomplete(l4_data->completion);\n}\n\nstatic int dsi_sync_vc_l4(struct platform_device *dsidev, int channel)\n{\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tstruct dsi_packet_sent_handler_data l4_data = {\n\t\t.dsidev = dsidev,\n\t\t.completion = &completion\n\t};\n\tint r = 0;\n\n\tr = dsi_register_isr_vc(dsidev, channel, dsi_packet_sent_handler_l4,\n\t\t&l4_data, DSI_VC_IRQ_PACKET_SENT);\n\tif (r)\n\t\tgoto err0;\n\n\t \n\tif (REG_GET(dsidev, DSI_VC_CTRL(channel), 5, 5)) {\n\t\tif (wait_for_completion_timeout(&completion,\n\t\t\t\tmsecs_to_jiffies(10)) == 0) {\n\t\t\tDSSERR(\"Failed to complete previous l4 transfer\\n\");\n\t\t\tr = -EIO;\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tdsi_unregister_isr_vc(dsidev, channel, dsi_packet_sent_handler_l4,\n\t\t&l4_data, DSI_VC_IRQ_PACKET_SENT);\n\n\treturn 0;\nerr1:\n\tdsi_unregister_isr_vc(dsidev, channel, dsi_packet_sent_handler_l4,\n\t\t&l4_data, DSI_VC_IRQ_PACKET_SENT);\nerr0:\n\treturn r;\n}\n\nstatic int dsi_sync_vc(struct platform_device *dsidev, int channel)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tWARN_ON(!dsi_bus_is_locked(dsidev));\n\n\tif (!dsi_vc_is_enabled(dsidev, channel))\n\t\treturn 0;\n\n\tswitch (dsi->vc[channel].source) {\n\tcase DSI_VC_SOURCE_VP:\n\t\treturn dsi_sync_vc_vp(dsidev, channel);\n\tcase DSI_VC_SOURCE_L4:\n\t\treturn dsi_sync_vc_l4(dsidev, channel);\n\tdefault:\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int dsi_vc_enable(struct platform_device *dsidev, int channel,\n\t\tbool enable)\n{\n\tDSSDBG(\"dsi_vc_enable channel %d, enable %d\\n\",\n\t\t\tchannel, enable);\n\n\tenable = enable ? 1 : 0;\n\n\tREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), enable, 0, 0);\n\n\tif (wait_for_bit_change(dsidev, DSI_VC_CTRL(channel),\n\t\t0, enable) != enable) {\n\t\t\tDSSERR(\"Failed to set dsi_vc_enable to %d\\n\", enable);\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void dsi_vc_initial_config(struct platform_device *dsidev, int channel)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tu32 r;\n\n\tDSSDBG(\"Initial config of virtual channel %d\", channel);\n\n\tr = dsi_read_reg(dsidev, DSI_VC_CTRL(channel));\n\n\tif (FLD_GET(r, 15, 15))  \n\t\tDSSERR(\"VC(%d) busy when trying to configure it!\\n\",\n\t\t\t\tchannel);\n\n\tr = FLD_MOD(r, 0, 1, 1);  \n\tr = FLD_MOD(r, 0, 2, 2);  \n\tr = FLD_MOD(r, 0, 3, 3);  \n\tr = FLD_MOD(r, 0, 4, 4);  \n\tr = FLD_MOD(r, 1, 7, 7);  \n\tr = FLD_MOD(r, 1, 8, 8);  \n\tr = FLD_MOD(r, 0, 9, 9);  \n\tif (dss_has_feature(FEAT_DSI_VC_OCP_WIDTH))\n\t\tr = FLD_MOD(r, 3, 11, 10);\t \n\n\tr = FLD_MOD(r, 4, 29, 27);  \n\tr = FLD_MOD(r, 4, 23, 21);  \n\n\tdsi_write_reg(dsidev, DSI_VC_CTRL(channel), r);\n\n\tdsi->vc[channel].source = DSI_VC_SOURCE_L4;\n}\n\nstatic int dsi_vc_config_source(struct platform_device *dsidev, int channel,\n\t\tenum dsi_vc_source source)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tif (dsi->vc[channel].source == source)\n\t\treturn 0;\n\n\tDSSDBG(\"Source config of virtual channel %d\", channel);\n\n\tdsi_sync_vc(dsidev, channel);\n\n\tdsi_vc_enable(dsidev, channel, 0);\n\n\t \n\tif (wait_for_bit_change(dsidev, DSI_VC_CTRL(channel), 15, 0) != 0) {\n\t\tDSSERR(\"vc(%d) busy when trying to config for VP\\n\", channel);\n\t\treturn -EIO;\n\t}\n\n\t \n\tREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), source, 1, 1);\n\n\t \n\tif (dss_has_feature(FEAT_DSI_DCS_CMD_CONFIG_VC)) {\n\t\tbool enable = source == DSI_VC_SOURCE_VP;\n\t\tREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), enable, 30, 30);\n\t}\n\n\tdsi_vc_enable(dsidev, channel, 1);\n\n\tdsi->vc[channel].source = source;\n\n\treturn 0;\n}\n\nstatic void dsi_vc_enable_hs(struct omap_dss_device *dssdev, int channel,\n\t\tbool enable)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tDSSDBG(\"dsi_vc_enable_hs(%d, %d)\\n\", channel, enable);\n\n\tWARN_ON(!dsi_bus_is_locked(dsidev));\n\n\tdsi_vc_enable(dsidev, channel, 0);\n\tdsi_if_enable(dsidev, 0);\n\n\tREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), enable, 9, 9);\n\n\tdsi_vc_enable(dsidev, channel, 1);\n\tdsi_if_enable(dsidev, 1);\n\n\tdsi_force_tx_stop_mode_io(dsidev);\n\n\t \n\tif (dsi->vm_timings.ddr_clk_always_on && enable)\n\t\tdsi_vc_send_null(dssdev, channel);\n}\n\nstatic void dsi_vc_flush_long_data(struct platform_device *dsidev, int channel)\n{\n\twhile (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {\n\t\tu32 val;\n\t\tval = dsi_read_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel));\n\t\tDSSDBG(\"\\t\\tb1 %#02x b2 %#02x b3 %#02x b4 %#02x\\n\",\n\t\t\t\t(val >> 0) & 0xff,\n\t\t\t\t(val >> 8) & 0xff,\n\t\t\t\t(val >> 16) & 0xff,\n\t\t\t\t(val >> 24) & 0xff);\n\t}\n}\n\nstatic void dsi_show_rx_ack_with_err(u16 err)\n{\n\tDSSERR(\"\\tACK with ERROR (%#x):\\n\", err);\n\tif (err & (1 << 0))\n\t\tDSSERR(\"\\t\\tSoT Error\\n\");\n\tif (err & (1 << 1))\n\t\tDSSERR(\"\\t\\tSoT Sync Error\\n\");\n\tif (err & (1 << 2))\n\t\tDSSERR(\"\\t\\tEoT Sync Error\\n\");\n\tif (err & (1 << 3))\n\t\tDSSERR(\"\\t\\tEscape Mode Entry Command Error\\n\");\n\tif (err & (1 << 4))\n\t\tDSSERR(\"\\t\\tLP Transmit Sync Error\\n\");\n\tif (err & (1 << 5))\n\t\tDSSERR(\"\\t\\tHS Receive Timeout Error\\n\");\n\tif (err & (1 << 6))\n\t\tDSSERR(\"\\t\\tFalse Control Error\\n\");\n\tif (err & (1 << 7))\n\t\tDSSERR(\"\\t\\t(reserved7)\\n\");\n\tif (err & (1 << 8))\n\t\tDSSERR(\"\\t\\tECC Error, single-bit (corrected)\\n\");\n\tif (err & (1 << 9))\n\t\tDSSERR(\"\\t\\tECC Error, multi-bit (not corrected)\\n\");\n\tif (err & (1 << 10))\n\t\tDSSERR(\"\\t\\tChecksum Error\\n\");\n\tif (err & (1 << 11))\n\t\tDSSERR(\"\\t\\tData type not recognized\\n\");\n\tif (err & (1 << 12))\n\t\tDSSERR(\"\\t\\tInvalid VC ID\\n\");\n\tif (err & (1 << 13))\n\t\tDSSERR(\"\\t\\tInvalid Transmission Length\\n\");\n\tif (err & (1 << 14))\n\t\tDSSERR(\"\\t\\t(reserved14)\\n\");\n\tif (err & (1 << 15))\n\t\tDSSERR(\"\\t\\tDSI Protocol Violation\\n\");\n}\n\nstatic u16 dsi_vc_flush_receive_data(struct platform_device *dsidev,\n\t\tint channel)\n{\n\t \n\twhile (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {\n\t\tu32 val;\n\t\tu8 dt;\n\t\tval = dsi_read_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel));\n\t\tDSSERR(\"\\trawval %#08x\\n\", val);\n\t\tdt = FLD_GET(val, 5, 0);\n\t\tif (dt == MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT) {\n\t\t\tu16 err = FLD_GET(val, 23, 8);\n\t\t\tdsi_show_rx_ack_with_err(err);\n\t\t} else if (dt == MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE) {\n\t\t\tDSSERR(\"\\tDCS short response, 1 byte: %#x\\n\",\n\t\t\t\t\tFLD_GET(val, 23, 8));\n\t\t} else if (dt == MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE) {\n\t\t\tDSSERR(\"\\tDCS short response, 2 byte: %#x\\n\",\n\t\t\t\t\tFLD_GET(val, 23, 8));\n\t\t} else if (dt == MIPI_DSI_RX_DCS_LONG_READ_RESPONSE) {\n\t\t\tDSSERR(\"\\tDCS long response, len %d\\n\",\n\t\t\t\t\tFLD_GET(val, 23, 8));\n\t\t\tdsi_vc_flush_long_data(dsidev, channel);\n\t\t} else {\n\t\t\tDSSERR(\"\\tunknown datatype 0x%02x\\n\", dt);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dsi_vc_send_bta(struct platform_device *dsidev, int channel)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tif (dsi->debug_write || dsi->debug_read)\n\t\tDSSDBG(\"dsi_vc_send_bta %d\\n\", channel);\n\n\tWARN_ON(!dsi_bus_is_locked(dsidev));\n\n\t \n\tif (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {\n\t\tDSSERR(\"rx fifo not empty when sending BTA, dumping data:\\n\");\n\t\tdsi_vc_flush_receive_data(dsidev, channel);\n\t}\n\n\tREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), 1, 6, 6);  \n\n\t \n\tdsi_read_reg(dsidev, DSI_VC_CTRL(channel));\n\n\treturn 0;\n}\n\nstatic int dsi_vc_send_bta_sync(struct omap_dss_device *dssdev, int channel)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tint r = 0;\n\tu32 err;\n\n\tr = dsi_register_isr_vc(dsidev, channel, dsi_completion_handler,\n\t\t\t&completion, DSI_VC_IRQ_BTA);\n\tif (r)\n\t\tgoto err0;\n\n\tr = dsi_register_isr(dsidev, dsi_completion_handler, &completion,\n\t\t\tDSI_IRQ_ERROR_MASK);\n\tif (r)\n\t\tgoto err1;\n\n\tr = dsi_vc_send_bta(dsidev, channel);\n\tif (r)\n\t\tgoto err2;\n\n\tif (wait_for_completion_timeout(&completion,\n\t\t\t\tmsecs_to_jiffies(500)) == 0) {\n\t\tDSSERR(\"Failed to receive BTA\\n\");\n\t\tr = -EIO;\n\t\tgoto err2;\n\t}\n\n\terr = dsi_get_errors(dsidev);\n\tif (err) {\n\t\tDSSERR(\"Error while sending BTA: %x\\n\", err);\n\t\tr = -EIO;\n\t\tgoto err2;\n\t}\nerr2:\n\tdsi_unregister_isr(dsidev, dsi_completion_handler, &completion,\n\t\t\tDSI_IRQ_ERROR_MASK);\nerr1:\n\tdsi_unregister_isr_vc(dsidev, channel, dsi_completion_handler,\n\t\t\t&completion, DSI_VC_IRQ_BTA);\nerr0:\n\treturn r;\n}\n\nstatic inline void dsi_vc_write_long_header(struct platform_device *dsidev,\n\t\tint channel, u8 data_type, u16 len, u8 ecc)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tu32 val;\n\tu8 data_id;\n\n\tWARN_ON(!dsi_bus_is_locked(dsidev));\n\n\tdata_id = data_type | dsi->vc[channel].vc_id << 6;\n\n\tval = FLD_VAL(data_id, 7, 0) | FLD_VAL(len, 23, 8) |\n\t\tFLD_VAL(ecc, 31, 24);\n\n\tdsi_write_reg(dsidev, DSI_VC_LONG_PACKET_HEADER(channel), val);\n}\n\nstatic inline void dsi_vc_write_long_payload(struct platform_device *dsidev,\n\t\tint channel, u8 b1, u8 b2, u8 b3, u8 b4)\n{\n\tu32 val;\n\n\tval = b4 << 24 | b3 << 16 | b2 << 8  | b1 << 0;\n\n \n\n\tdsi_write_reg(dsidev, DSI_VC_LONG_PACKET_PAYLOAD(channel), val);\n}\n\nstatic int dsi_vc_send_long(struct platform_device *dsidev, int channel,\n\t\tu8 data_type, u8 *data, u16 len, u8 ecc)\n{\n\t \n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint i;\n\tu8 *p;\n\tint r = 0;\n\tu8 b1, b2, b3, b4;\n\n\tif (dsi->debug_write)\n\t\tDSSDBG(\"dsi_vc_send_long, %d bytes\\n\", len);\n\n\t \n\tif (dsi->vc[channel].tx_fifo_size * 32 * 4 < len + 4) {\n\t\tDSSERR(\"unable to send long packet: packet too long.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdsi_vc_config_source(dsidev, channel, DSI_VC_SOURCE_L4);\n\n\tdsi_vc_write_long_header(dsidev, channel, data_type, len, ecc);\n\n\tp = data;\n\tfor (i = 0; i < len >> 2; i++) {\n\t\tif (dsi->debug_write)\n\t\t\tDSSDBG(\"\\tsending full packet %d\\n\", i);\n\n\t\tb1 = *p++;\n\t\tb2 = *p++;\n\t\tb3 = *p++;\n\t\tb4 = *p++;\n\n\t\tdsi_vc_write_long_payload(dsidev, channel, b1, b2, b3, b4);\n\t}\n\n\ti = len % 4;\n\tif (i) {\n\t\tb1 = 0; b2 = 0; b3 = 0;\n\n\t\tif (dsi->debug_write)\n\t\t\tDSSDBG(\"\\tsending remainder bytes %d\\n\", i);\n\n\t\tswitch (i) {\n\t\tcase 3:\n\t\t\tb1 = *p++;\n\t\t\tb2 = *p++;\n\t\t\tb3 = *p++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tb1 = *p++;\n\t\t\tb2 = *p++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tb1 = *p++;\n\t\t\tbreak;\n\t\t}\n\n\t\tdsi_vc_write_long_payload(dsidev, channel, b1, b2, b3, 0);\n\t}\n\n\treturn r;\n}\n\nstatic int dsi_vc_send_short(struct platform_device *dsidev, int channel,\n\t\tu8 data_type, u16 data, u8 ecc)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tu32 r;\n\tu8 data_id;\n\n\tWARN_ON(!dsi_bus_is_locked(dsidev));\n\n\tif (dsi->debug_write)\n\t\tDSSDBG(\"dsi_vc_send_short(ch%d, dt %#x, b1 %#x, b2 %#x)\\n\",\n\t\t\t\tchannel,\n\t\t\t\tdata_type, data & 0xff, (data >> 8) & 0xff);\n\n\tdsi_vc_config_source(dsidev, channel, DSI_VC_SOURCE_L4);\n\n\tif (FLD_GET(dsi_read_reg(dsidev, DSI_VC_CTRL(channel)), 16, 16)) {\n\t\tDSSERR(\"ERROR FIFO FULL, aborting transfer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata_id = data_type | dsi->vc[channel].vc_id << 6;\n\n\tr = (data_id << 0) | (data << 8) | (ecc << 24);\n\n\tdsi_write_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel), r);\n\n\treturn 0;\n}\n\nstatic int dsi_vc_send_null(struct omap_dss_device *dssdev, int channel)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\n\treturn dsi_vc_send_long(dsidev, channel, MIPI_DSI_NULL_PACKET, NULL,\n\t\t0, 0);\n}\n\nstatic int dsi_vc_write_nosync_common(struct platform_device *dsidev,\n\t\tint channel, u8 *data, int len, enum dss_dsi_content_type type)\n{\n\tint r;\n\n\tif (len == 0) {\n\t\tBUG_ON(type == DSS_DSI_CONTENT_DCS);\n\t\tr = dsi_vc_send_short(dsidev, channel,\n\t\t\t\tMIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM, 0, 0);\n\t} else if (len == 1) {\n\t\tr = dsi_vc_send_short(dsidev, channel,\n\t\t\t\ttype == DSS_DSI_CONTENT_GENERIC ?\n\t\t\t\tMIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM :\n\t\t\t\tMIPI_DSI_DCS_SHORT_WRITE, data[0], 0);\n\t} else if (len == 2) {\n\t\tr = dsi_vc_send_short(dsidev, channel,\n\t\t\t\ttype == DSS_DSI_CONTENT_GENERIC ?\n\t\t\t\tMIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM :\n\t\t\t\tMIPI_DSI_DCS_SHORT_WRITE_PARAM,\n\t\t\t\tdata[0] | (data[1] << 8), 0);\n\t} else {\n\t\tr = dsi_vc_send_long(dsidev, channel,\n\t\t\t\ttype == DSS_DSI_CONTENT_GENERIC ?\n\t\t\t\tMIPI_DSI_GENERIC_LONG_WRITE :\n\t\t\t\tMIPI_DSI_DCS_LONG_WRITE, data, len, 0);\n\t}\n\n\treturn r;\n}\n\nstatic int dsi_vc_dcs_write_nosync(struct omap_dss_device *dssdev, int channel,\n\t\tu8 *data, int len)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\n\treturn dsi_vc_write_nosync_common(dsidev, channel, data, len,\n\t\t\tDSS_DSI_CONTENT_DCS);\n}\n\nstatic int dsi_vc_generic_write_nosync(struct omap_dss_device *dssdev, int channel,\n\t\tu8 *data, int len)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\n\treturn dsi_vc_write_nosync_common(dsidev, channel, data, len,\n\t\t\tDSS_DSI_CONTENT_GENERIC);\n}\n\nstatic int dsi_vc_write_common(struct omap_dss_device *dssdev, int channel,\n\t\tu8 *data, int len, enum dss_dsi_content_type type)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tint r;\n\n\tr = dsi_vc_write_nosync_common(dsidev, channel, data, len, type);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsi_vc_send_bta_sync(dssdev, channel);\n\tif (r)\n\t\tgoto err;\n\n\t \n\tif (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {\n\t\tDSSERR(\"rx fifo not empty after write, dumping data:\\n\");\n\t\tdsi_vc_flush_receive_data(dsidev, channel);\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tDSSERR(\"dsi_vc_write_common(ch %d, cmd 0x%02x, len %d) failed\\n\",\n\t\t\tchannel, data[0], len);\n\treturn r;\n}\n\nstatic int dsi_vc_dcs_write(struct omap_dss_device *dssdev, int channel, u8 *data,\n\t\tint len)\n{\n\treturn dsi_vc_write_common(dssdev, channel, data, len,\n\t\t\tDSS_DSI_CONTENT_DCS);\n}\n\nstatic int dsi_vc_generic_write(struct omap_dss_device *dssdev, int channel, u8 *data,\n\t\tint len)\n{\n\treturn dsi_vc_write_common(dssdev, channel, data, len,\n\t\t\tDSS_DSI_CONTENT_GENERIC);\n}\n\nstatic int dsi_vc_dcs_send_read_request(struct platform_device *dsidev,\n\t\tint channel, u8 dcs_cmd)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint r;\n\n\tif (dsi->debug_read)\n\t\tDSSDBG(\"dsi_vc_dcs_send_read_request(ch%d, dcs_cmd %x)\\n\",\n\t\t\tchannel, dcs_cmd);\n\n\tr = dsi_vc_send_short(dsidev, channel, MIPI_DSI_DCS_READ, dcs_cmd, 0);\n\tif (r) {\n\t\tDSSERR(\"dsi_vc_dcs_send_read_request(ch %d, cmd 0x%02x)\"\n\t\t\t\" failed\\n\", channel, dcs_cmd);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int dsi_vc_generic_send_read_request(struct platform_device *dsidev,\n\t\tint channel, u8 *reqdata, int reqlen)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tu16 data;\n\tu8 data_type;\n\tint r;\n\n\tif (dsi->debug_read)\n\t\tDSSDBG(\"dsi_vc_generic_send_read_request(ch %d, reqlen %d)\\n\",\n\t\t\tchannel, reqlen);\n\n\tif (reqlen == 0) {\n\t\tdata_type = MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM;\n\t\tdata = 0;\n\t} else if (reqlen == 1) {\n\t\tdata_type = MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM;\n\t\tdata = reqdata[0];\n\t} else if (reqlen == 2) {\n\t\tdata_type = MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM;\n\t\tdata = reqdata[0] | (reqdata[1] << 8);\n\t} else {\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\n\tr = dsi_vc_send_short(dsidev, channel, data_type, data, 0);\n\tif (r) {\n\t\tDSSERR(\"dsi_vc_generic_send_read_request(ch %d, reqlen %d)\"\n\t\t\t\" failed\\n\", channel, reqlen);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int dsi_vc_read_rx_fifo(struct platform_device *dsidev, int channel,\n\t\tu8 *buf, int buflen, enum dss_dsi_content_type type)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tu32 val;\n\tu8 dt;\n\tint r;\n\n\t \n\tif (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20) == 0) {\n\t\tDSSERR(\"RX fifo empty when trying to read.\\n\");\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\n\tval = dsi_read_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel));\n\tif (dsi->debug_read)\n\t\tDSSDBG(\"\\theader: %08x\\n\", val);\n\tdt = FLD_GET(val, 5, 0);\n\tif (dt == MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT) {\n\t\tu16 err = FLD_GET(val, 23, 8);\n\t\tdsi_show_rx_ack_with_err(err);\n\t\tr = -EIO;\n\t\tgoto err;\n\n\t} else if (dt == (type == DSS_DSI_CONTENT_GENERIC ?\n\t\t\tMIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE :\n\t\t\tMIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE)) {\n\t\tu8 data = FLD_GET(val, 15, 8);\n\t\tif (dsi->debug_read)\n\t\t\tDSSDBG(\"\\t%s short response, 1 byte: %02x\\n\",\n\t\t\t\ttype == DSS_DSI_CONTENT_GENERIC ? \"GENERIC\" :\n\t\t\t\t\"DCS\", data);\n\n\t\tif (buflen < 1) {\n\t\t\tr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\tbuf[0] = data;\n\n\t\treturn 1;\n\t} else if (dt == (type == DSS_DSI_CONTENT_GENERIC ?\n\t\t\tMIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE :\n\t\t\tMIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE)) {\n\t\tu16 data = FLD_GET(val, 23, 8);\n\t\tif (dsi->debug_read)\n\t\t\tDSSDBG(\"\\t%s short response, 2 byte: %04x\\n\",\n\t\t\t\ttype == DSS_DSI_CONTENT_GENERIC ? \"GENERIC\" :\n\t\t\t\t\"DCS\", data);\n\n\t\tif (buflen < 2) {\n\t\t\tr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\tbuf[0] = data & 0xff;\n\t\tbuf[1] = (data >> 8) & 0xff;\n\n\t\treturn 2;\n\t} else if (dt == (type == DSS_DSI_CONTENT_GENERIC ?\n\t\t\tMIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE :\n\t\t\tMIPI_DSI_RX_DCS_LONG_READ_RESPONSE)) {\n\t\tint w;\n\t\tint len = FLD_GET(val, 23, 8);\n\t\tif (dsi->debug_read)\n\t\t\tDSSDBG(\"\\t%s long response, len %d\\n\",\n\t\t\t\ttype == DSS_DSI_CONTENT_GENERIC ? \"GENERIC\" :\n\t\t\t\t\"DCS\", len);\n\n\t\tif (len > buflen) {\n\t\t\tr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tfor (w = 0; w < len + 2;) {\n\t\t\tint b;\n\t\t\tval = dsi_read_reg(dsidev,\n\t\t\t\tDSI_VC_SHORT_PACKET_HEADER(channel));\n\t\t\tif (dsi->debug_read)\n\t\t\t\tDSSDBG(\"\\t\\t%02x %02x %02x %02x\\n\",\n\t\t\t\t\t\t(val >> 0) & 0xff,\n\t\t\t\t\t\t(val >> 8) & 0xff,\n\t\t\t\t\t\t(val >> 16) & 0xff,\n\t\t\t\t\t\t(val >> 24) & 0xff);\n\n\t\t\tfor (b = 0; b < 4; ++b) {\n\t\t\t\tif (w < len)\n\t\t\t\t\tbuf[w] = (val >> (b * 8)) & 0xff;\n\t\t\t\t \n\t\t\t\t++w;\n\t\t\t}\n\t\t}\n\n\t\treturn len;\n\t} else {\n\t\tDSSERR(\"\\tunknown datatype 0x%02x\\n\", dt);\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\nerr:\n\tDSSERR(\"dsi_vc_read_rx_fifo(ch %d type %s) failed\\n\", channel,\n\t\ttype == DSS_DSI_CONTENT_GENERIC ? \"GENERIC\" : \"DCS\");\n\n\treturn r;\n}\n\nstatic int dsi_vc_dcs_read(struct omap_dss_device *dssdev, int channel, u8 dcs_cmd,\n\t\tu8 *buf, int buflen)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tint r;\n\n\tr = dsi_vc_dcs_send_read_request(dsidev, channel, dcs_cmd);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsi_vc_send_bta_sync(dssdev, channel);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsi_vc_read_rx_fifo(dsidev, channel, buf, buflen,\n\t\tDSS_DSI_CONTENT_DCS);\n\tif (r < 0)\n\t\tgoto err;\n\n\tif (r != buflen) {\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tDSSERR(\"dsi_vc_dcs_read(ch %d, cmd 0x%02x) failed\\n\", channel, dcs_cmd);\n\treturn r;\n}\n\nstatic int dsi_vc_generic_read(struct omap_dss_device *dssdev, int channel,\n\t\tu8 *reqdata, int reqlen, u8 *buf, int buflen)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tint r;\n\n\tr = dsi_vc_generic_send_read_request(dsidev, channel, reqdata, reqlen);\n\tif (r)\n\t\treturn r;\n\n\tr = dsi_vc_send_bta_sync(dssdev, channel);\n\tif (r)\n\t\treturn r;\n\n\tr = dsi_vc_read_rx_fifo(dsidev, channel, buf, buflen,\n\t\tDSS_DSI_CONTENT_GENERIC);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (r != buflen) {\n\t\tr = -EIO;\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int dsi_vc_set_max_rx_packet_size(struct omap_dss_device *dssdev, int channel,\n\t\tu16 len)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\n\treturn dsi_vc_send_short(dsidev, channel,\n\t\t\tMIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE, len, 0);\n}\n\nstatic int dsi_enter_ulps(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tint r, i;\n\tunsigned mask;\n\n\tDSSDBG(\"Entering ULPS\");\n\n\tWARN_ON(!dsi_bus_is_locked(dsidev));\n\n\tWARN_ON(dsi->ulps_enabled);\n\n\tif (dsi->ulps_enabled)\n\t\treturn 0;\n\n\t \n\tif (REG_GET(dsidev, DSI_CLK_CTRL, 13, 13)) {\n\t\tdsi_if_enable(dsidev, 0);\n\t\tREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 0, 13, 13);\n\t\tdsi_if_enable(dsidev, 1);\n\t}\n\n\tdsi_sync_vc(dsidev, 0);\n\tdsi_sync_vc(dsidev, 1);\n\tdsi_sync_vc(dsidev, 2);\n\tdsi_sync_vc(dsidev, 3);\n\n\tdsi_force_tx_stop_mode_io(dsidev);\n\n\tdsi_vc_enable(dsidev, 0, false);\n\tdsi_vc_enable(dsidev, 1, false);\n\tdsi_vc_enable(dsidev, 2, false);\n\tdsi_vc_enable(dsidev, 3, false);\n\n\tif (REG_GET(dsidev, DSI_COMPLEXIO_CFG2, 16, 16)) {\t \n\t\tDSSERR(\"HS busy when enabling ULPS\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (REG_GET(dsidev, DSI_COMPLEXIO_CFG2, 17, 17)) {\t \n\t\tDSSERR(\"LP busy when enabling ULPS\\n\");\n\t\treturn -EIO;\n\t}\n\n\tr = dsi_register_isr_cio(dsidev, dsi_completion_handler, &completion,\n\t\t\tDSI_CIO_IRQ_ULPSACTIVENOT_ALL0);\n\tif (r)\n\t\treturn r;\n\n\tmask = 0;\n\n\tfor (i = 0; i < dsi->num_lanes_supported; ++i) {\n\t\tif (dsi->lanes[i].function == DSI_LANE_UNUSED)\n\t\t\tcontinue;\n\t\tmask |= 1 << i;\n\t}\n\t \n\t \n\tREG_FLD_MOD(dsidev, DSI_COMPLEXIO_CFG2, mask, 9, 5);\n\n\t \n\tdsi_read_reg(dsidev, DSI_COMPLEXIO_CFG2);\n\n\tif (wait_for_completion_timeout(&completion,\n\t\t\t\tmsecs_to_jiffies(1000)) == 0) {\n\t\tDSSERR(\"ULPS enable timeout\\n\");\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\n\tdsi_unregister_isr_cio(dsidev, dsi_completion_handler, &completion,\n\t\t\tDSI_CIO_IRQ_ULPSACTIVENOT_ALL0);\n\n\t \n\tREG_FLD_MOD(dsidev, DSI_COMPLEXIO_CFG2, 0, 9, 5);\n\n\t \n\tdsi_read_reg(dsidev, DSI_COMPLEXIO_CFG2);\n\n\tdsi_cio_power(dsidev, DSI_COMPLEXIO_POWER_ULPS);\n\n\tdsi_if_enable(dsidev, false);\n\n\tdsi->ulps_enabled = true;\n\n\treturn 0;\n\nerr:\n\tdsi_unregister_isr_cio(dsidev, dsi_completion_handler, &completion,\n\t\t\tDSI_CIO_IRQ_ULPSACTIVENOT_ALL0);\n\treturn r;\n}\n\nstatic void dsi_set_lp_rx_timeout(struct platform_device *dsidev,\n\t\tunsigned ticks, bool x4, bool x16)\n{\n\tunsigned long fck;\n\tunsigned long total_ticks;\n\tu32 r;\n\n\tBUG_ON(ticks > 0x1fff);\n\n\t \n\tfck = dsi_fclk_rate(dsidev);\n\n\tr = dsi_read_reg(dsidev, DSI_TIMING2);\n\tr = FLD_MOD(r, 1, 15, 15);\t \n\tr = FLD_MOD(r, x16 ? 1 : 0, 14, 14);\t \n\tr = FLD_MOD(r, x4 ? 1 : 0, 13, 13);\t \n\tr = FLD_MOD(r, ticks, 12, 0);\t \n\tdsi_write_reg(dsidev, DSI_TIMING2, r);\n\n\ttotal_ticks = ticks * (x16 ? 16 : 1) * (x4 ? 4 : 1);\n\n\tDSSDBG(\"LP_RX_TO %lu ticks (%#x%s%s) = %lu ns\\n\",\n\t\t\ttotal_ticks,\n\t\t\tticks, x4 ? \" x4\" : \"\", x16 ? \" x16\" : \"\",\n\t\t\t(total_ticks * 1000) / (fck / 1000 / 1000));\n}\n\nstatic void dsi_set_ta_timeout(struct platform_device *dsidev, unsigned ticks,\n\t\tbool x8, bool x16)\n{\n\tunsigned long fck;\n\tunsigned long total_ticks;\n\tu32 r;\n\n\tBUG_ON(ticks > 0x1fff);\n\n\t \n\tfck = dsi_fclk_rate(dsidev);\n\n\tr = dsi_read_reg(dsidev, DSI_TIMING1);\n\tr = FLD_MOD(r, 1, 31, 31);\t \n\tr = FLD_MOD(r, x16 ? 1 : 0, 30, 30);\t \n\tr = FLD_MOD(r, x8 ? 1 : 0, 29, 29);\t \n\tr = FLD_MOD(r, ticks, 28, 16);\t \n\tdsi_write_reg(dsidev, DSI_TIMING1, r);\n\n\ttotal_ticks = ticks * (x16 ? 16 : 1) * (x8 ? 8 : 1);\n\n\tDSSDBG(\"TA_TO %lu ticks (%#x%s%s) = %lu ns\\n\",\n\t\t\ttotal_ticks,\n\t\t\tticks, x8 ? \" x8\" : \"\", x16 ? \" x16\" : \"\",\n\t\t\t(total_ticks * 1000) / (fck / 1000 / 1000));\n}\n\nstatic void dsi_set_stop_state_counter(struct platform_device *dsidev,\n\t\tunsigned ticks, bool x4, bool x16)\n{\n\tunsigned long fck;\n\tunsigned long total_ticks;\n\tu32 r;\n\n\tBUG_ON(ticks > 0x1fff);\n\n\t \n\tfck = dsi_fclk_rate(dsidev);\n\n\tr = dsi_read_reg(dsidev, DSI_TIMING1);\n\tr = FLD_MOD(r, 1, 15, 15);\t \n\tr = FLD_MOD(r, x16 ? 1 : 0, 14, 14);\t \n\tr = FLD_MOD(r, x4 ? 1 : 0, 13, 13);\t \n\tr = FLD_MOD(r, ticks, 12, 0);\t \n\tdsi_write_reg(dsidev, DSI_TIMING1, r);\n\n\ttotal_ticks = ticks * (x16 ? 16 : 1) * (x4 ? 4 : 1);\n\n\tDSSDBG(\"STOP_STATE_COUNTER %lu ticks (%#x%s%s) = %lu ns\\n\",\n\t\t\ttotal_ticks,\n\t\t\tticks, x4 ? \" x4\" : \"\", x16 ? \" x16\" : \"\",\n\t\t\t(total_ticks * 1000) / (fck / 1000 / 1000));\n}\n\nstatic void dsi_set_hs_tx_timeout(struct platform_device *dsidev,\n\t\tunsigned ticks, bool x4, bool x16)\n{\n\tunsigned long fck;\n\tunsigned long total_ticks;\n\tu32 r;\n\n\tBUG_ON(ticks > 0x1fff);\n\n\t \n\tfck = dsi_get_txbyteclkhs(dsidev);\n\n\tr = dsi_read_reg(dsidev, DSI_TIMING2);\n\tr = FLD_MOD(r, 1, 31, 31);\t \n\tr = FLD_MOD(r, x16 ? 1 : 0, 30, 30);\t \n\tr = FLD_MOD(r, x4 ? 1 : 0, 29, 29);\t \n\tr = FLD_MOD(r, ticks, 28, 16);\t \n\tdsi_write_reg(dsidev, DSI_TIMING2, r);\n\n\ttotal_ticks = ticks * (x16 ? 16 : 1) * (x4 ? 4 : 1);\n\n\tDSSDBG(\"HS_TX_TO %lu ticks (%#x%s%s) = %lu ns\\n\",\n\t\t\ttotal_ticks,\n\t\t\tticks, x4 ? \" x4\" : \"\", x16 ? \" x16\" : \"\",\n\t\t\t(total_ticks * 1000) / (fck / 1000 / 1000));\n}\n\nstatic void dsi_config_vp_num_line_buffers(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint num_line_buffers;\n\n\tif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\n\t\tint bpp = dsi_get_pixel_size(dsi->pix_fmt);\n\t\tstruct omap_video_timings *timings = &dsi->timings;\n\t\t \n\t\tif (dsi->line_buffer_size <= timings->x_res * bpp / 8)\n\t\t\tnum_line_buffers = 0;\n\t\telse\n\t\t\tnum_line_buffers = 2;\n\t} else {\n\t\t \n\t\tnum_line_buffers = 2;\n\t}\n\n\t \n\tREG_FLD_MOD(dsidev, DSI_CTRL, num_line_buffers, 13, 12);\n}\n\nstatic void dsi_config_vp_sync_events(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tbool sync_end;\n\tu32 r;\n\n\tif (dsi->vm_timings.trans_mode == OMAP_DSS_DSI_PULSE_MODE)\n\t\tsync_end = true;\n\telse\n\t\tsync_end = false;\n\n\tr = dsi_read_reg(dsidev, DSI_CTRL);\n\tr = FLD_MOD(r, 1, 9, 9);\t\t \n\tr = FLD_MOD(r, 1, 10, 10);\t\t \n\tr = FLD_MOD(r, 1, 11, 11);\t\t \n\tr = FLD_MOD(r, 1, 15, 15);\t\t \n\tr = FLD_MOD(r, sync_end, 16, 16);\t \n\tr = FLD_MOD(r, 1, 17, 17);\t\t \n\tr = FLD_MOD(r, sync_end, 18, 18);\t \n\tdsi_write_reg(dsidev, DSI_CTRL, r);\n}\n\nstatic void dsi_config_blanking_modes(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint blanking_mode = dsi->vm_timings.blanking_mode;\n\tint hfp_blanking_mode = dsi->vm_timings.hfp_blanking_mode;\n\tint hbp_blanking_mode = dsi->vm_timings.hbp_blanking_mode;\n\tint hsa_blanking_mode = dsi->vm_timings.hsa_blanking_mode;\n\tu32 r;\n\n\t \n\tr = dsi_read_reg(dsidev, DSI_CTRL);\n\tr = FLD_MOD(r, blanking_mode, 20, 20);\t\t \n\tr = FLD_MOD(r, hfp_blanking_mode, 21, 21);\t \n\tr = FLD_MOD(r, hbp_blanking_mode, 22, 22);\t \n\tr = FLD_MOD(r, hsa_blanking_mode, 23, 23);\t \n\tdsi_write_reg(dsidev, DSI_CTRL, r);\n}\n\n \nstatic int dsi_compute_interleave_hs(int blank, bool ddr_alwon, int enter_hs,\n\t\tint exit_hs, int exiths_clk, int ddr_pre, int ddr_post)\n{\n\tint transition;\n\n\t \n\tif (ddr_alwon) {\n\t\ttransition = enter_hs + exit_hs + max(enter_hs, 2) + 1;\n\t} else {\n\t\tint trans1, trans2;\n\t\ttrans1 = ddr_pre + enter_hs + exit_hs + max(enter_hs, 2) + 1;\n\t\ttrans2 = ddr_pre + enter_hs + exiths_clk + ddr_post + ddr_pre +\n\t\t\t\tenter_hs + 1;\n\t\ttransition = max(trans1, trans2);\n\t}\n\n\treturn blank > transition ? blank - transition : 0;\n}\n\n \nstatic int dsi_compute_interleave_lp(int blank, int enter_hs, int exit_hs,\n\t\tint lp_clk_div, int tdsi_fclk)\n{\n\tint trans_lp;\t \n\tint tlp_avail;\t \n\tint ttxclkesc;\t \n\tint thsbyte_clk = 16;\t \n\tint lp_inter;\t \n\n\t \n\ttrans_lp = exit_hs + max(enter_hs, 2) + 1;\n\n\t \n\ttlp_avail = thsbyte_clk * (blank - trans_lp);\n\n\tttxclkesc = tdsi_fclk * lp_clk_div;\n\n\tlp_inter = ((tlp_avail - 8 * thsbyte_clk - 5 * tdsi_fclk) / ttxclkesc -\n\t\t\t26) / 16;\n\n\treturn max(lp_inter, 0);\n}\n\nstatic void dsi_config_cmd_mode_interleaving(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint blanking_mode;\n\tint hfp_blanking_mode, hbp_blanking_mode, hsa_blanking_mode;\n\tint hsa, hfp, hbp, width_bytes, bllp, lp_clk_div;\n\tint ddr_clk_pre, ddr_clk_post, enter_hs_mode_lat, exit_hs_mode_lat;\n\tint tclk_trail, ths_exit, exiths_clk;\n\tbool ddr_alwon;\n\tstruct omap_video_timings *timings = &dsi->timings;\n\tint bpp = dsi_get_pixel_size(dsi->pix_fmt);\n\tint ndl = dsi->num_lanes_used - 1;\n\tint dsi_fclk_hsdiv = dsi->user_dsi_cinfo.mX[HSDIV_DSI] + 1;\n\tint hsa_interleave_hs = 0, hsa_interleave_lp = 0;\n\tint hfp_interleave_hs = 0, hfp_interleave_lp = 0;\n\tint hbp_interleave_hs = 0, hbp_interleave_lp = 0;\n\tint bl_interleave_hs = 0, bl_interleave_lp = 0;\n\tu32 r;\n\n\tr = dsi_read_reg(dsidev, DSI_CTRL);\n\tblanking_mode = FLD_GET(r, 20, 20);\n\thfp_blanking_mode = FLD_GET(r, 21, 21);\n\thbp_blanking_mode = FLD_GET(r, 22, 22);\n\thsa_blanking_mode = FLD_GET(r, 23, 23);\n\n\tr = dsi_read_reg(dsidev, DSI_VM_TIMING1);\n\thbp = FLD_GET(r, 11, 0);\n\thfp = FLD_GET(r, 23, 12);\n\thsa = FLD_GET(r, 31, 24);\n\n\tr = dsi_read_reg(dsidev, DSI_CLK_TIMING);\n\tddr_clk_post = FLD_GET(r, 7, 0);\n\tddr_clk_pre = FLD_GET(r, 15, 8);\n\n\tr = dsi_read_reg(dsidev, DSI_VM_TIMING7);\n\texit_hs_mode_lat = FLD_GET(r, 15, 0);\n\tenter_hs_mode_lat = FLD_GET(r, 31, 16);\n\n\tr = dsi_read_reg(dsidev, DSI_CLK_CTRL);\n\tlp_clk_div = FLD_GET(r, 12, 0);\n\tddr_alwon = FLD_GET(r, 13, 13);\n\n\tr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG0);\n\tths_exit = FLD_GET(r, 7, 0);\n\n\tr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG1);\n\ttclk_trail = FLD_GET(r, 15, 8);\n\n\texiths_clk = ths_exit + tclk_trail;\n\n\twidth_bytes = DIV_ROUND_UP(timings->x_res * bpp, 8);\n\tbllp = hbp + hfp + hsa + DIV_ROUND_UP(width_bytes + 6, ndl);\n\n\tif (!hsa_blanking_mode) {\n\t\thsa_interleave_hs = dsi_compute_interleave_hs(hsa, ddr_alwon,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\texiths_clk, ddr_clk_pre, ddr_clk_post);\n\t\thsa_interleave_lp = dsi_compute_interleave_lp(hsa,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\tlp_clk_div, dsi_fclk_hsdiv);\n\t}\n\n\tif (!hfp_blanking_mode) {\n\t\thfp_interleave_hs = dsi_compute_interleave_hs(hfp, ddr_alwon,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\texiths_clk, ddr_clk_pre, ddr_clk_post);\n\t\thfp_interleave_lp = dsi_compute_interleave_lp(hfp,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\tlp_clk_div, dsi_fclk_hsdiv);\n\t}\n\n\tif (!hbp_blanking_mode) {\n\t\thbp_interleave_hs = dsi_compute_interleave_hs(hbp, ddr_alwon,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\texiths_clk, ddr_clk_pre, ddr_clk_post);\n\n\t\thbp_interleave_lp = dsi_compute_interleave_lp(hbp,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\tlp_clk_div, dsi_fclk_hsdiv);\n\t}\n\n\tif (!blanking_mode) {\n\t\tbl_interleave_hs = dsi_compute_interleave_hs(bllp, ddr_alwon,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\texiths_clk, ddr_clk_pre, ddr_clk_post);\n\n\t\tbl_interleave_lp = dsi_compute_interleave_lp(bllp,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\tlp_clk_div, dsi_fclk_hsdiv);\n\t}\n\n\tDSSDBG(\"DSI HS interleaving(TXBYTECLKHS) HSA %d, HFP %d, HBP %d, BLLP %d\\n\",\n\t\thsa_interleave_hs, hfp_interleave_hs, hbp_interleave_hs,\n\t\tbl_interleave_hs);\n\n\tDSSDBG(\"DSI LP interleaving(bytes) HSA %d, HFP %d, HBP %d, BLLP %d\\n\",\n\t\thsa_interleave_lp, hfp_interleave_lp, hbp_interleave_lp,\n\t\tbl_interleave_lp);\n\n\tr = dsi_read_reg(dsidev, DSI_VM_TIMING4);\n\tr = FLD_MOD(r, hsa_interleave_hs, 23, 16);\n\tr = FLD_MOD(r, hfp_interleave_hs, 15, 8);\n\tr = FLD_MOD(r, hbp_interleave_hs, 7, 0);\n\tdsi_write_reg(dsidev, DSI_VM_TIMING4, r);\n\n\tr = dsi_read_reg(dsidev, DSI_VM_TIMING5);\n\tr = FLD_MOD(r, hsa_interleave_lp, 23, 16);\n\tr = FLD_MOD(r, hfp_interleave_lp, 15, 8);\n\tr = FLD_MOD(r, hbp_interleave_lp, 7, 0);\n\tdsi_write_reg(dsidev, DSI_VM_TIMING5, r);\n\n\tr = dsi_read_reg(dsidev, DSI_VM_TIMING6);\n\tr = FLD_MOD(r, bl_interleave_hs, 31, 15);\n\tr = FLD_MOD(r, bl_interleave_lp, 16, 0);\n\tdsi_write_reg(dsidev, DSI_VM_TIMING6, r);\n}\n\nstatic int dsi_proto_config(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tu32 r;\n\tint buswidth = 0;\n\n\tdsi_config_tx_fifo(dsidev, DSI_FIFO_SIZE_32,\n\t\t\tDSI_FIFO_SIZE_32,\n\t\t\tDSI_FIFO_SIZE_32,\n\t\t\tDSI_FIFO_SIZE_32);\n\n\tdsi_config_rx_fifo(dsidev, DSI_FIFO_SIZE_32,\n\t\t\tDSI_FIFO_SIZE_32,\n\t\t\tDSI_FIFO_SIZE_32,\n\t\t\tDSI_FIFO_SIZE_32);\n\n\t \n\tdsi_set_stop_state_counter(dsidev, 0x1000, false, false);\n\tdsi_set_ta_timeout(dsidev, 0x1fff, true, true);\n\tdsi_set_lp_rx_timeout(dsidev, 0x1fff, true, true);\n\tdsi_set_hs_tx_timeout(dsidev, 0x1fff, true, true);\n\n\tswitch (dsi_get_pixel_size(dsi->pix_fmt)) {\n\tcase 16:\n\t\tbuswidth = 0;\n\t\tbreak;\n\tcase 18:\n\t\tbuswidth = 1;\n\t\tbreak;\n\tcase 24:\n\t\tbuswidth = 2;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\n\tr = dsi_read_reg(dsidev, DSI_CTRL);\n\tr = FLD_MOD(r, 1, 1, 1);\t \n\tr = FLD_MOD(r, 1, 2, 2);\t \n\tr = FLD_MOD(r, 1, 3, 3);\t \n\tr = FLD_MOD(r, 1, 4, 4);\t \n\tr = FLD_MOD(r, buswidth, 7, 6);  \n\tr = FLD_MOD(r, 0, 8, 8);\t \n\tr = FLD_MOD(r, 1, 14, 14);\t \n\tr = FLD_MOD(r, 1, 19, 19);\t \n\tif (!dss_has_feature(FEAT_DSI_DCS_CMD_CONFIG_VC)) {\n\t\tr = FLD_MOD(r, 1, 24, 24);\t \n\t\t \n\t\tr = FLD_MOD(r, 0, 25, 25);\n\t}\n\n\tdsi_write_reg(dsidev, DSI_CTRL, r);\n\n\tdsi_config_vp_num_line_buffers(dsidev);\n\n\tif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\n\t\tdsi_config_vp_sync_events(dsidev);\n\t\tdsi_config_blanking_modes(dsidev);\n\t\tdsi_config_cmd_mode_interleaving(dsidev);\n\t}\n\n\tdsi_vc_initial_config(dsidev, 0);\n\tdsi_vc_initial_config(dsidev, 1);\n\tdsi_vc_initial_config(dsidev, 2);\n\tdsi_vc_initial_config(dsidev, 3);\n\n\treturn 0;\n}\n\nstatic void dsi_proto_timings(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tunsigned tlpx, tclk_zero, tclk_prepare;\n\tunsigned tclk_pre, tclk_post;\n\tunsigned ths_prepare, ths_prepare_ths_zero, ths_zero;\n\tunsigned ths_trail, ths_exit;\n\tunsigned ddr_clk_pre, ddr_clk_post;\n\tunsigned enter_hs_mode_lat, exit_hs_mode_lat;\n\tunsigned ths_eot;\n\tint ndl = dsi->num_lanes_used - 1;\n\tu32 r;\n\n\tr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG0);\n\tths_prepare = FLD_GET(r, 31, 24);\n\tths_prepare_ths_zero = FLD_GET(r, 23, 16);\n\tths_zero = ths_prepare_ths_zero - ths_prepare;\n\tths_trail = FLD_GET(r, 15, 8);\n\tths_exit = FLD_GET(r, 7, 0);\n\n\tr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG1);\n\ttlpx = FLD_GET(r, 20, 16) * 2;\n\ttclk_zero = FLD_GET(r, 7, 0);\n\n\tr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG2);\n\ttclk_prepare = FLD_GET(r, 7, 0);\n\n\t \n\ttclk_pre = 20;\n\t \n\ttclk_post = ns2ddr(dsidev, 60) + 26;\n\n\tths_eot = DIV_ROUND_UP(4, ndl);\n\n\tddr_clk_pre = DIV_ROUND_UP(tclk_pre + tlpx + tclk_zero + tclk_prepare,\n\t\t\t4);\n\tddr_clk_post = DIV_ROUND_UP(tclk_post + ths_trail, 4) + ths_eot;\n\n\tBUG_ON(ddr_clk_pre == 0 || ddr_clk_pre > 255);\n\tBUG_ON(ddr_clk_post == 0 || ddr_clk_post > 255);\n\n\tr = dsi_read_reg(dsidev, DSI_CLK_TIMING);\n\tr = FLD_MOD(r, ddr_clk_pre, 15, 8);\n\tr = FLD_MOD(r, ddr_clk_post, 7, 0);\n\tdsi_write_reg(dsidev, DSI_CLK_TIMING, r);\n\n\tDSSDBG(\"ddr_clk_pre %u, ddr_clk_post %u\\n\",\n\t\t\tddr_clk_pre,\n\t\t\tddr_clk_post);\n\n\tenter_hs_mode_lat = 1 + DIV_ROUND_UP(tlpx, 4) +\n\t\tDIV_ROUND_UP(ths_prepare, 4) +\n\t\tDIV_ROUND_UP(ths_zero + 3, 4);\n\n\texit_hs_mode_lat = DIV_ROUND_UP(ths_trail + ths_exit, 4) + 1 + ths_eot;\n\n\tr = FLD_VAL(enter_hs_mode_lat, 31, 16) |\n\t\tFLD_VAL(exit_hs_mode_lat, 15, 0);\n\tdsi_write_reg(dsidev, DSI_VM_TIMING7, r);\n\n\tDSSDBG(\"enter_hs_mode_lat %u, exit_hs_mode_lat %u\\n\",\n\t\t\tenter_hs_mode_lat, exit_hs_mode_lat);\n\n\t if (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\n\t\t \n\t\tint hsa = dsi->vm_timings.hsa;\n\t\tint hfp = dsi->vm_timings.hfp;\n\t\tint hbp = dsi->vm_timings.hbp;\n\t\tint vsa = dsi->vm_timings.vsa;\n\t\tint vfp = dsi->vm_timings.vfp;\n\t\tint vbp = dsi->vm_timings.vbp;\n\t\tint window_sync = dsi->vm_timings.window_sync;\n\t\tbool hsync_end;\n\t\tstruct omap_video_timings *timings = &dsi->timings;\n\t\tint bpp = dsi_get_pixel_size(dsi->pix_fmt);\n\t\tint tl, t_he, width_bytes;\n\n\t\thsync_end = dsi->vm_timings.trans_mode == OMAP_DSS_DSI_PULSE_MODE;\n\t\tt_he = hsync_end ?\n\t\t\t((hsa == 0 && ndl == 3) ? 1 : DIV_ROUND_UP(4, ndl)) : 0;\n\n\t\twidth_bytes = DIV_ROUND_UP(timings->x_res * bpp, 8);\n\n\t\t \n\t\ttl = DIV_ROUND_UP(4, ndl) + (hsync_end ? hsa : 0) + t_he + hfp +\n\t\t\tDIV_ROUND_UP(width_bytes + 6, ndl) + hbp;\n\n\t\tDSSDBG(\"HBP: %d, HFP: %d, HSA: %d, TL: %d TXBYTECLKHS\\n\", hbp,\n\t\t\thfp, hsync_end ? hsa : 0, tl);\n\t\tDSSDBG(\"VBP: %d, VFP: %d, VSA: %d, VACT: %d lines\\n\", vbp, vfp,\n\t\t\tvsa, timings->y_res);\n\n\t\tr = dsi_read_reg(dsidev, DSI_VM_TIMING1);\n\t\tr = FLD_MOD(r, hbp, 11, 0);\t \n\t\tr = FLD_MOD(r, hfp, 23, 12);\t \n\t\tr = FLD_MOD(r, hsync_end ? hsa : 0, 31, 24);\t \n\t\tdsi_write_reg(dsidev, DSI_VM_TIMING1, r);\n\n\t\tr = dsi_read_reg(dsidev, DSI_VM_TIMING2);\n\t\tr = FLD_MOD(r, vbp, 7, 0);\t \n\t\tr = FLD_MOD(r, vfp, 15, 8);\t \n\t\tr = FLD_MOD(r, vsa, 23, 16);\t \n\t\tr = FLD_MOD(r, window_sync, 27, 24);\t \n\t\tdsi_write_reg(dsidev, DSI_VM_TIMING2, r);\n\n\t\tr = dsi_read_reg(dsidev, DSI_VM_TIMING3);\n\t\tr = FLD_MOD(r, timings->y_res, 14, 0);\t \n\t\tr = FLD_MOD(r, tl, 31, 16);\t\t \n\t\tdsi_write_reg(dsidev, DSI_VM_TIMING3, r);\n\t}\n}\n\nstatic int dsi_configure_pins(struct omap_dss_device *dssdev,\n\t\tconst struct omap_dsi_pin_config *pin_cfg)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint num_pins;\n\tconst int *pins;\n\tstruct dsi_lane_config lanes[DSI_MAX_NR_LANES];\n\tint num_lanes;\n\tint i;\n\n\tstatic const enum dsi_lane_function functions[] = {\n\t\tDSI_LANE_CLK,\n\t\tDSI_LANE_DATA1,\n\t\tDSI_LANE_DATA2,\n\t\tDSI_LANE_DATA3,\n\t\tDSI_LANE_DATA4,\n\t};\n\n\tnum_pins = pin_cfg->num_pins;\n\tpins = pin_cfg->pins;\n\n\tif (num_pins < 4 || num_pins > dsi->num_lanes_supported * 2\n\t\t\t|| num_pins % 2 != 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < DSI_MAX_NR_LANES; ++i)\n\t\tlanes[i].function = DSI_LANE_UNUSED;\n\n\tnum_lanes = 0;\n\n\tfor (i = 0; i < num_pins; i += 2) {\n\t\tu8 lane, pol;\n\t\tint dx, dy;\n\n\t\tdx = pins[i];\n\t\tdy = pins[i + 1];\n\n\t\tif (dx < 0 || dx >= dsi->num_lanes_supported * 2)\n\t\t\treturn -EINVAL;\n\n\t\tif (dy < 0 || dy >= dsi->num_lanes_supported * 2)\n\t\t\treturn -EINVAL;\n\n\t\tif (dx & 1) {\n\t\t\tif (dy != dx - 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tpol = 1;\n\t\t} else {\n\t\t\tif (dy != dx + 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tpol = 0;\n\t\t}\n\n\t\tlane = dx / 2;\n\n\t\tlanes[lane].function = functions[i / 2];\n\t\tlanes[lane].polarity = pol;\n\t\tnum_lanes++;\n\t}\n\n\tmemcpy(dsi->lanes, lanes, sizeof(dsi->lanes));\n\tdsi->num_lanes_used = num_lanes;\n\n\treturn 0;\n}\n\nstatic int dsi_enable_video_output(struct omap_dss_device *dssdev, int channel)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstruct omap_overlay_manager *mgr = dsi->output.manager;\n\tint bpp = dsi_get_pixel_size(dsi->pix_fmt);\n\tstruct omap_dss_device *out = &dsi->output;\n\tu8 data_type;\n\tu16 word_count;\n\tint r;\n\n\tif (out->manager == NULL) {\n\t\tDSSERR(\"failed to enable display: no output/manager\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tr = dsi_display_init_dispc(dsidev, mgr);\n\tif (r)\n\t\tgoto err_init_dispc;\n\n\tif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\n\t\tswitch (dsi->pix_fmt) {\n\t\tcase OMAP_DSS_DSI_FMT_RGB888:\n\t\t\tdata_type = MIPI_DSI_PACKED_PIXEL_STREAM_24;\n\t\t\tbreak;\n\t\tcase OMAP_DSS_DSI_FMT_RGB666:\n\t\t\tdata_type = MIPI_DSI_PIXEL_STREAM_3BYTE_18;\n\t\t\tbreak;\n\t\tcase OMAP_DSS_DSI_FMT_RGB666_PACKED:\n\t\t\tdata_type = MIPI_DSI_PACKED_PIXEL_STREAM_18;\n\t\t\tbreak;\n\t\tcase OMAP_DSS_DSI_FMT_RGB565:\n\t\t\tdata_type = MIPI_DSI_PACKED_PIXEL_STREAM_16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr = -EINVAL;\n\t\t\tgoto err_pix_fmt;\n\t\t}\n\n\t\tdsi_if_enable(dsidev, false);\n\t\tdsi_vc_enable(dsidev, channel, false);\n\n\t\t \n\t\tREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), 1, 4, 4);\n\n\t\tword_count = DIV_ROUND_UP(dsi->timings.x_res * bpp, 8);\n\n\t\tdsi_vc_write_long_header(dsidev, channel, data_type,\n\t\t\t\tword_count, 0);\n\n\t\tdsi_vc_enable(dsidev, channel, true);\n\t\tdsi_if_enable(dsidev, true);\n\t}\n\n\tr = dss_mgr_enable(mgr);\n\tif (r)\n\t\tgoto err_mgr_enable;\n\n\treturn 0;\n\nerr_mgr_enable:\n\tif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\n\t\tdsi_if_enable(dsidev, false);\n\t\tdsi_vc_enable(dsidev, channel, false);\n\t}\nerr_pix_fmt:\n\tdsi_display_uninit_dispc(dsidev, mgr);\nerr_init_dispc:\n\treturn r;\n}\n\nstatic void dsi_disable_video_output(struct omap_dss_device *dssdev, int channel)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstruct omap_overlay_manager *mgr = dsi->output.manager;\n\n\tif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\n\t\tdsi_if_enable(dsidev, false);\n\t\tdsi_vc_enable(dsidev, channel, false);\n\n\t\t \n\t\tREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), 0, 4, 4);\n\n\t\tdsi_vc_enable(dsidev, channel, true);\n\t\tdsi_if_enable(dsidev, true);\n\t}\n\n\tdss_mgr_disable(mgr);\n\n\tdsi_display_uninit_dispc(dsidev, mgr);\n}\n\nstatic void dsi_update_screen_dispc(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstruct omap_overlay_manager *mgr = dsi->output.manager;\n\tunsigned bytespp;\n\tunsigned bytespl;\n\tunsigned bytespf;\n\tunsigned total_len;\n\tunsigned packet_payload;\n\tunsigned packet_len;\n\tu32 l;\n\tint r;\n\tconst unsigned channel = dsi->update_channel;\n\tconst unsigned line_buf_size = dsi->line_buffer_size;\n\tu16 w = dsi->timings.x_res;\n\tu16 h = dsi->timings.y_res;\n\n\tDSSDBG(\"dsi_update_screen_dispc(%dx%d)\\n\", w, h);\n\n\tdsi_vc_config_source(dsidev, channel, DSI_VC_SOURCE_VP);\n\n\tbytespp\t= dsi_get_pixel_size(dsi->pix_fmt) / 8;\n\tbytespl = w * bytespp;\n\tbytespf = bytespl * h;\n\n\t \n\n\tif (bytespf < line_buf_size)\n\t\tpacket_payload = bytespf;\n\telse\n\t\tpacket_payload = (line_buf_size) / bytespl * bytespl;\n\n\tpacket_len = packet_payload + 1;\t \n\ttotal_len = (bytespf / packet_payload) * packet_len;\n\n\tif (bytespf % packet_payload)\n\t\ttotal_len += (bytespf % packet_payload) + 1;\n\n\tl = FLD_VAL(total_len, 23, 0);  \n\tdsi_write_reg(dsidev, DSI_VC_TE(channel), l);\n\n\tdsi_vc_write_long_header(dsidev, channel, MIPI_DSI_DCS_LONG_WRITE,\n\t\tpacket_len, 0);\n\n\tif (dsi->te_enabled)\n\t\tl = FLD_MOD(l, 1, 30, 30);  \n\telse\n\t\tl = FLD_MOD(l, 1, 31, 31);  \n\tdsi_write_reg(dsidev, DSI_VC_TE(channel), l);\n\n\t \n\tdispc_disable_sidle();\n\n\tdsi_perf_mark_start(dsidev);\n\n\tr = schedule_delayed_work(&dsi->framedone_timeout_work,\n\t\tmsecs_to_jiffies(250));\n\tBUG_ON(r == 0);\n\n\tdss_mgr_set_timings(mgr, &dsi->timings);\n\n\tdss_mgr_start_update(mgr);\n\n\tif (dsi->te_enabled) {\n\t\t \n\t\tREG_FLD_MOD(dsidev, DSI_TIMING2, 0, 15, 15);  \n\n\t\tdsi_vc_send_bta(dsidev, channel);\n\n#ifdef DSI_CATCH_MISSING_TE\n\t\tmod_timer(&dsi->te_timer, jiffies + msecs_to_jiffies(250));\n#endif\n\t}\n}\n\n#ifdef DSI_CATCH_MISSING_TE\nstatic void dsi_te_timeout(struct timer_list *unused)\n{\n\tDSSERR(\"TE not received for 250ms!\\n\");\n}\n#endif\n\nstatic void dsi_handle_framedone(struct platform_device *dsidev, int error)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\t \n\tdispc_enable_sidle();\n\n\tif (dsi->te_enabled) {\n\t\t \n\t\tREG_FLD_MOD(dsidev, DSI_TIMING2, 1, 15, 15);  \n\t}\n\n\tdsi->framedone_callback(error, dsi->framedone_data);\n\n\tif (!error)\n\t\tdsi_perf_show(dsidev, \"DISPC\");\n}\n\nstatic void dsi_framedone_timeout_work_callback(struct work_struct *work)\n{\n\tstruct dsi_data *dsi = container_of(work, struct dsi_data,\n\t\t\tframedone_timeout_work.work);\n\t \n\n\tDSSERR(\"Framedone not received for 250ms!\\n\");\n\n\tdsi_handle_framedone(dsi->pdev, -ETIMEDOUT);\n}\n\nstatic void dsi_framedone_irq_callback(void *data)\n{\n\tstruct platform_device *dsidev = (struct platform_device *) data;\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\t \n\n\tcancel_delayed_work(&dsi->framedone_timeout_work);\n\n\tdsi_handle_framedone(dsidev, 0);\n}\n\nstatic int dsi_update(struct omap_dss_device *dssdev, int channel,\n\t\tvoid (*callback)(int, void *), void *data)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tdsi_perf_mark_setup(dsidev);\n\n\tdsi->update_channel = channel;\n\n\tdsi->framedone_callback = callback;\n\tdsi->framedone_data = data;\n\n#ifdef DSI_PERF_MEASURE\n\tdsi->update_bytes = dsi->timings.x_res * dsi->timings.y_res *\n\t\tdsi_get_pixel_size(dsi->pix_fmt) / 8;\n#endif\n\tdsi_update_screen_dispc(dsidev);\n\n\treturn 0;\n}\n\n \n\nstatic int dsi_configure_dispc_clocks(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstruct dispc_clock_info dispc_cinfo;\n\tint r;\n\tunsigned long fck;\n\n\tfck = dsi_get_pll_hsdiv_dispc_rate(dsidev);\n\n\tdispc_cinfo.lck_div = dsi->user_dispc_cinfo.lck_div;\n\tdispc_cinfo.pck_div = dsi->user_dispc_cinfo.pck_div;\n\n\tr = dispc_calc_clock_rates(fck, &dispc_cinfo);\n\tif (r) {\n\t\tDSSERR(\"Failed to calc dispc clocks\\n\");\n\t\treturn r;\n\t}\n\n\tdsi->mgr_config.clock_info = dispc_cinfo;\n\n\treturn 0;\n}\n\nstatic int dsi_display_init_dispc(struct platform_device *dsidev,\n\t\tstruct omap_overlay_manager *mgr)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint r;\n\n\tdss_select_lcd_clk_source(mgr->id, dsi->module_id == 0 ?\n\t\t\tOMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC :\n\t\t\tOMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC);\n\n\tif (dsi->mode == OMAP_DSS_DSI_CMD_MODE) {\n\t\tr = dss_mgr_register_framedone_handler(mgr,\n\t\t\t\tdsi_framedone_irq_callback, dsidev);\n\t\tif (r) {\n\t\t\tDSSERR(\"can't register FRAMEDONE handler\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tdsi->mgr_config.stallmode = true;\n\t\tdsi->mgr_config.fifohandcheck = true;\n\t} else {\n\t\tdsi->mgr_config.stallmode = false;\n\t\tdsi->mgr_config.fifohandcheck = false;\n\t}\n\n\t \n\tdsi->timings.interlace = false;\n\tdsi->timings.hsync_level = OMAPDSS_SIG_ACTIVE_HIGH;\n\tdsi->timings.vsync_level = OMAPDSS_SIG_ACTIVE_HIGH;\n\tdsi->timings.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\n\tdsi->timings.de_level = OMAPDSS_SIG_ACTIVE_HIGH;\n\tdsi->timings.sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE;\n\n\tdss_mgr_set_timings(mgr, &dsi->timings);\n\n\tr = dsi_configure_dispc_clocks(dsidev);\n\tif (r)\n\t\tgoto err1;\n\n\tdsi->mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\n\tdsi->mgr_config.video_port_width =\n\t\t\tdsi_get_pixel_size(dsi->pix_fmt);\n\tdsi->mgr_config.lcden_sig_polarity = 0;\n\n\tdss_mgr_set_lcd_config(mgr, &dsi->mgr_config);\n\n\treturn 0;\nerr1:\n\tif (dsi->mode == OMAP_DSS_DSI_CMD_MODE)\n\t\tdss_mgr_unregister_framedone_handler(mgr,\n\t\t\t\tdsi_framedone_irq_callback, dsidev);\nerr:\n\tdss_select_lcd_clk_source(mgr->id, OMAP_DSS_CLK_SRC_FCK);\n\treturn r;\n}\n\nstatic void dsi_display_uninit_dispc(struct platform_device *dsidev,\n\t\tstruct omap_overlay_manager *mgr)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tif (dsi->mode == OMAP_DSS_DSI_CMD_MODE)\n\t\tdss_mgr_unregister_framedone_handler(mgr,\n\t\t\t\tdsi_framedone_irq_callback, dsidev);\n\n\tdss_select_lcd_clk_source(mgr->id, OMAP_DSS_CLK_SRC_FCK);\n}\n\nstatic int dsi_configure_dsi_clocks(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstruct dss_pll_clock_info cinfo;\n\tint r;\n\n\tcinfo = dsi->user_dsi_cinfo;\n\n\tr = dss_pll_set_config(&dsi->pll, &cinfo);\n\tif (r) {\n\t\tDSSERR(\"Failed to set dsi clocks\\n\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int dsi_display_init_dsi(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint r;\n\n\tr = dss_pll_enable(&dsi->pll);\n\tif (r)\n\t\tgoto err0;\n\n\tr = dsi_configure_dsi_clocks(dsidev);\n\tif (r)\n\t\tgoto err1;\n\n\tdss_select_dsi_clk_source(dsi->module_id, dsi->module_id == 0 ?\n\t\t\tOMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI :\n\t\t\tOMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI);\n\n\tDSSDBG(\"PLL OK\\n\");\n\n\tr = dsi_cio_init(dsidev);\n\tif (r)\n\t\tgoto err2;\n\n\t_dsi_print_reset_status(dsidev);\n\n\tdsi_proto_timings(dsidev);\n\tdsi_set_lp_clk_divisor(dsidev);\n\n\tif (1)\n\t\t_dsi_print_reset_status(dsidev);\n\n\tr = dsi_proto_config(dsidev);\n\tif (r)\n\t\tgoto err3;\n\n\t \n\tdsi_vc_enable(dsidev, 0, 1);\n\tdsi_vc_enable(dsidev, 1, 1);\n\tdsi_vc_enable(dsidev, 2, 1);\n\tdsi_vc_enable(dsidev, 3, 1);\n\tdsi_if_enable(dsidev, 1);\n\tdsi_force_tx_stop_mode_io(dsidev);\n\n\treturn 0;\nerr3:\n\tdsi_cio_uninit(dsidev);\nerr2:\n\tdss_select_dsi_clk_source(dsi->module_id, OMAP_DSS_CLK_SRC_FCK);\nerr1:\n\tdss_pll_disable(&dsi->pll);\nerr0:\n\treturn r;\n}\n\nstatic void dsi_display_uninit_dsi(struct platform_device *dsidev,\n\t\tbool disconnect_lanes, bool enter_ulps)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tif (enter_ulps && !dsi->ulps_enabled)\n\t\tdsi_enter_ulps(dsidev);\n\n\t \n\tdsi_if_enable(dsidev, 0);\n\tdsi_vc_enable(dsidev, 0, 0);\n\tdsi_vc_enable(dsidev, 1, 0);\n\tdsi_vc_enable(dsidev, 2, 0);\n\tdsi_vc_enable(dsidev, 3, 0);\n\n\tdss_select_dsi_clk_source(dsi->module_id, OMAP_DSS_CLK_SRC_FCK);\n\tdsi_cio_uninit(dsidev);\n\tdsi_pll_uninit(dsidev, disconnect_lanes);\n}\n\nstatic int dsi_display_enable(struct omap_dss_device *dssdev)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint r = 0;\n\n\tDSSDBG(\"dsi_display_enable\\n\");\n\n\tWARN_ON(!dsi_bus_is_locked(dsidev));\n\n\tmutex_lock(&dsi->lock);\n\n\tr = dsi_runtime_get(dsidev);\n\tif (r)\n\t\tgoto err_get_dsi;\n\n\t_dsi_initialize_irq(dsidev);\n\n\tr = dsi_display_init_dsi(dsidev);\n\tif (r)\n\t\tgoto err_init_dsi;\n\n\tmutex_unlock(&dsi->lock);\n\n\treturn 0;\n\nerr_init_dsi:\n\tdsi_runtime_put(dsidev);\nerr_get_dsi:\n\tmutex_unlock(&dsi->lock);\n\tDSSDBG(\"dsi_display_enable FAILED\\n\");\n\treturn r;\n}\n\nstatic void dsi_display_disable(struct omap_dss_device *dssdev,\n\t\tbool disconnect_lanes, bool enter_ulps)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tDSSDBG(\"dsi_display_disable\\n\");\n\n\tWARN_ON(!dsi_bus_is_locked(dsidev));\n\n\tmutex_lock(&dsi->lock);\n\n\tdsi_sync_vc(dsidev, 0);\n\tdsi_sync_vc(dsidev, 1);\n\tdsi_sync_vc(dsidev, 2);\n\tdsi_sync_vc(dsidev, 3);\n\n\tdsi_display_uninit_dsi(dsidev, disconnect_lanes, enter_ulps);\n\n\tdsi_runtime_put(dsidev);\n\n\tmutex_unlock(&dsi->lock);\n}\n\nstatic int dsi_enable_te(struct omap_dss_device *dssdev, bool enable)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tdsi->te_enabled = enable;\n\treturn 0;\n}\n\n#ifdef PRINT_VERBOSE_VM_TIMINGS\nstatic void print_dsi_vm(const char *str,\n\t\tconst struct omap_dss_dsi_videomode_timings *t)\n{\n\tunsigned long byteclk = t->hsclk / 4;\n\tint bl, wc, pps, tot;\n\n\twc = DIV_ROUND_UP(t->hact * t->bitspp, 8);\n\tpps = DIV_ROUND_UP(wc + 6, t->ndl);  \n\tbl = t->hss + t->hsa + t->hse + t->hbp + t->hfp;\n\ttot = bl + pps;\n\n#define TO_DSI_T(x) ((u32)div64_u64((u64)x * 1000000000llu, byteclk))\n\n\tpr_debug(\"%s bck %lu, %u/%u/%u/%u/%u/%u = %u+%u = %u, \"\n\t\t\t\"%u/%u/%u/%u/%u/%u = %u + %u = %u\\n\",\n\t\t\tstr,\n\t\t\tbyteclk,\n\t\t\tt->hss, t->hsa, t->hse, t->hbp, pps, t->hfp,\n\t\t\tbl, pps, tot,\n\t\t\tTO_DSI_T(t->hss),\n\t\t\tTO_DSI_T(t->hsa),\n\t\t\tTO_DSI_T(t->hse),\n\t\t\tTO_DSI_T(t->hbp),\n\t\t\tTO_DSI_T(pps),\n\t\t\tTO_DSI_T(t->hfp),\n\n\t\t\tTO_DSI_T(bl),\n\t\t\tTO_DSI_T(pps),\n\n\t\t\tTO_DSI_T(tot));\n#undef TO_DSI_T\n}\n\nstatic void print_dispc_vm(const char *str, const struct omap_video_timings *t)\n{\n\tunsigned long pck = t->pixelclock;\n\tint hact, bl, tot;\n\n\thact = t->x_res;\n\tbl = t->hsw + t->hbp + t->hfp;\n\ttot = hact + bl;\n\n#define TO_DISPC_T(x) ((u32)div64_u64((u64)x * 1000000000llu, pck))\n\n\tpr_debug(\"%s pck %lu, %u/%u/%u/%u = %u+%u = %u, \"\n\t\t\t\"%u/%u/%u/%u = %u + %u = %u\\n\",\n\t\t\tstr,\n\t\t\tpck,\n\t\t\tt->hsw, t->hbp, hact, t->hfp,\n\t\t\tbl, hact, tot,\n\t\t\tTO_DISPC_T(t->hsw),\n\t\t\tTO_DISPC_T(t->hbp),\n\t\t\tTO_DISPC_T(hact),\n\t\t\tTO_DISPC_T(t->hfp),\n\t\t\tTO_DISPC_T(bl),\n\t\t\tTO_DISPC_T(hact),\n\t\t\tTO_DISPC_T(tot));\n#undef TO_DISPC_T\n}\n\n \nstatic void print_dsi_dispc_vm(const char *str,\n\t\tconst struct omap_dss_dsi_videomode_timings *t)\n{\n\tstruct omap_video_timings vm = { 0 };\n\tunsigned long byteclk = t->hsclk / 4;\n\tunsigned long pck;\n\tu64 dsi_tput;\n\tint dsi_hact, dsi_htot;\n\n\tdsi_tput = (u64)byteclk * t->ndl * 8;\n\tpck = (u32)div64_u64(dsi_tput, t->bitspp);\n\tdsi_hact = DIV_ROUND_UP(DIV_ROUND_UP(t->hact * t->bitspp, 8) + 6, t->ndl);\n\tdsi_htot = t->hss + t->hsa + t->hse + t->hbp + dsi_hact + t->hfp;\n\n\tvm.pixelclock = pck;\n\tvm.hsw = div64_u64((u64)(t->hsa + t->hse) * pck, byteclk);\n\tvm.hbp = div64_u64((u64)t->hbp * pck, byteclk);\n\tvm.hfp = div64_u64((u64)t->hfp * pck, byteclk);\n\tvm.x_res = t->hact;\n\n\tprint_dispc_vm(str, &vm);\n}\n#endif  \n\nstatic bool dsi_cm_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\n\t\tunsigned long pck, void *data)\n{\n\tstruct dsi_clk_calc_ctx *ctx = data;\n\tstruct omap_video_timings *t = &ctx->dispc_vm;\n\n\tctx->dispc_cinfo.lck_div = lckd;\n\tctx->dispc_cinfo.pck_div = pckd;\n\tctx->dispc_cinfo.lck = lck;\n\tctx->dispc_cinfo.pck = pck;\n\n\t*t = *ctx->config->timings;\n\tt->pixelclock = pck;\n\tt->x_res = ctx->config->timings->x_res;\n\tt->y_res = ctx->config->timings->y_res;\n\tt->hsw = t->hfp = t->hbp = t->vsw = 1;\n\tt->vfp = t->vbp = 0;\n\n\treturn true;\n}\n\nstatic bool dsi_cm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n\t\tvoid *data)\n{\n\tstruct dsi_clk_calc_ctx *ctx = data;\n\n\tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n\tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n\n\treturn dispc_div_calc(dispc, ctx->req_pck_min, ctx->req_pck_max,\n\t\t\tdsi_cm_calc_dispc_cb, ctx);\n}\n\nstatic bool dsi_cm_calc_pll_cb(int n, int m, unsigned long fint,\n\t\tunsigned long clkdco, void *data)\n{\n\tstruct dsi_clk_calc_ctx *ctx = data;\n\n\tctx->dsi_cinfo.n = n;\n\tctx->dsi_cinfo.m = m;\n\tctx->dsi_cinfo.fint = fint;\n\tctx->dsi_cinfo.clkdco = clkdco;\n\n\treturn dss_pll_hsdiv_calc(ctx->pll, clkdco, ctx->req_pck_min,\n\t\t\tdss_feat_get_param_max(FEAT_PARAM_DSS_FCK),\n\t\t\tdsi_cm_calc_hsdiv_cb, ctx);\n}\n\nstatic bool dsi_cm_calc(struct dsi_data *dsi,\n\t\tconst struct omap_dss_dsi_config *cfg,\n\t\tstruct dsi_clk_calc_ctx *ctx)\n{\n\tunsigned long clkin;\n\tint bitspp, ndl;\n\tunsigned long pll_min, pll_max;\n\tunsigned long pck, txbyteclk;\n\n\tclkin = clk_get_rate(dsi->pll.clkin);\n\tbitspp = dsi_get_pixel_size(cfg->pixel_format);\n\tndl = dsi->num_lanes_used - 1;\n\n\t \n\tpck = cfg->timings->pixelclock;\n\tpck = pck * 3 / 2;\n\ttxbyteclk = pck * bitspp / 8 / ndl;\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->dsidev = dsi->pdev;\n\tctx->pll = &dsi->pll;\n\tctx->config = cfg;\n\tctx->req_pck_min = pck;\n\tctx->req_pck_nom = pck;\n\tctx->req_pck_max = pck * 3 / 2;\n\n\tpll_min = max(cfg->hs_clk_min * 4, txbyteclk * 4 * 4);\n\tpll_max = cfg->hs_clk_max * 4;\n\n\treturn dss_pll_calc(ctx->pll, clkin,\n\t\t\tpll_min, pll_max,\n\t\t\tdsi_cm_calc_pll_cb, ctx);\n}\n\nstatic bool dsi_vm_calc_blanking(struct dsi_clk_calc_ctx *ctx)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(ctx->dsidev);\n\tconst struct omap_dss_dsi_config *cfg = ctx->config;\n\tint bitspp = dsi_get_pixel_size(cfg->pixel_format);\n\tint ndl = dsi->num_lanes_used - 1;\n\tunsigned long hsclk = ctx->dsi_cinfo.clkdco / 4;\n\tunsigned long byteclk = hsclk / 4;\n\n\tunsigned long dispc_pck, req_pck_min, req_pck_nom, req_pck_max;\n\tint xres;\n\tint panel_htot, panel_hbl;  \n\tint dispc_htot, dispc_hbl;  \n\tint dsi_htot, dsi_hact, dsi_hbl, hss, hse;  \n\tint hfp, hsa, hbp;\n\tconst struct omap_video_timings *req_vm;\n\tstruct omap_video_timings *dispc_vm;\n\tstruct omap_dss_dsi_videomode_timings *dsi_vm;\n\tu64 dsi_tput, dispc_tput;\n\n\tdsi_tput = (u64)byteclk * ndl * 8;\n\n\treq_vm = cfg->timings;\n\treq_pck_min = ctx->req_pck_min;\n\treq_pck_max = ctx->req_pck_max;\n\treq_pck_nom = ctx->req_pck_nom;\n\n\tdispc_pck = ctx->dispc_cinfo.pck;\n\tdispc_tput = (u64)dispc_pck * bitspp;\n\n\txres = req_vm->x_res;\n\n\tpanel_hbl = req_vm->hfp + req_vm->hbp + req_vm->hsw;\n\tpanel_htot = xres + panel_hbl;\n\n\tdsi_hact = DIV_ROUND_UP(DIV_ROUND_UP(xres * bitspp, 8) + 6, ndl);\n\n\t \n\tif (dsi->line_buffer_size < xres * bitspp / 8) {\n\t\tif (dispc_tput != dsi_tput)\n\t\t\treturn false;\n\t} else {\n\t\tif (dispc_tput < dsi_tput)\n\t\t\treturn false;\n\t}\n\n\t \n\tif (dsi_tput < (u64)bitspp * req_pck_min)\n\t\treturn false;\n\n\t \n\tif (cfg->trans_mode != OMAP_DSS_DSI_BURST_MODE) {\n\t\tif (dsi_tput > (u64)bitspp * req_pck_max)\n\t\t\treturn false;\n\t}\n\n\thss = DIV_ROUND_UP(4, ndl);\n\n\tif (cfg->trans_mode == OMAP_DSS_DSI_PULSE_MODE) {\n\t\tif (ndl == 3 && req_vm->hsw == 0)\n\t\t\thse = 1;\n\t\telse\n\t\t\thse = DIV_ROUND_UP(4, ndl);\n\t} else {\n\t\thse = 0;\n\t}\n\n\t \n\tdsi_htot = div64_u64((u64)panel_htot * byteclk, req_pck_nom);\n\n\t \n\tif (dsi_htot < hss + hse + dsi_hact)\n\t\treturn false;\n\n\t \n\tdsi_hbl = dsi_htot - dsi_hact;\n\n\t \n\tdispc_htot = div64_u64((u64)dsi_htot * dispc_pck, byteclk);\n\n\t \n\tif ((u64)dsi_htot * dispc_pck != (u64)dispc_htot * byteclk)\n\t\treturn false;\n\n\tdispc_hbl = dispc_htot - xres;\n\n\t \n\n\tdsi_vm = &ctx->dsi_vm;\n\tmemset(dsi_vm, 0, sizeof(*dsi_vm));\n\n\tdsi_vm->hsclk = hsclk;\n\n\tdsi_vm->ndl = ndl;\n\tdsi_vm->bitspp = bitspp;\n\n\tif (cfg->trans_mode != OMAP_DSS_DSI_PULSE_MODE) {\n\t\thsa = 0;\n\t} else if (ndl == 3 && req_vm->hsw == 0) {\n\t\thsa = 0;\n\t} else {\n\t\thsa = div64_u64((u64)req_vm->hsw * byteclk, req_pck_nom);\n\t\thsa = max(hsa - hse, 1);\n\t}\n\n\thbp = div64_u64((u64)req_vm->hbp * byteclk, req_pck_nom);\n\thbp = max(hbp, 1);\n\n\thfp = dsi_hbl - (hss + hsa + hse + hbp);\n\tif (hfp < 1) {\n\t\tint t;\n\t\t \n\n\t\tt = 1 - hfp;\n\t\thbp = max(hbp - t, 1);\n\t\thfp = dsi_hbl - (hss + hsa + hse + hbp);\n\n\t\tif (hfp < 1 && hsa > 0) {\n\t\t\t \n\t\t\tt = 1 - hfp;\n\t\t\thsa = max(hsa - t, 1);\n\t\t\thfp = dsi_hbl - (hss + hsa + hse + hbp);\n\t\t}\n\t}\n\n\tif (hfp < 1)\n\t\treturn false;\n\n\tdsi_vm->hss = hss;\n\tdsi_vm->hsa = hsa;\n\tdsi_vm->hse = hse;\n\tdsi_vm->hbp = hbp;\n\tdsi_vm->hact = xres;\n\tdsi_vm->hfp = hfp;\n\n\tdsi_vm->vsa = req_vm->vsw;\n\tdsi_vm->vbp = req_vm->vbp;\n\tdsi_vm->vact = req_vm->y_res;\n\tdsi_vm->vfp = req_vm->vfp;\n\n\tdsi_vm->trans_mode = cfg->trans_mode;\n\n\tdsi_vm->blanking_mode = 0;\n\tdsi_vm->hsa_blanking_mode = 1;\n\tdsi_vm->hfp_blanking_mode = 1;\n\tdsi_vm->hbp_blanking_mode = 1;\n\n\tdsi_vm->ddr_clk_always_on = cfg->ddr_clk_always_on;\n\tdsi_vm->window_sync = 4;\n\n\t \n\n\tdispc_vm = &ctx->dispc_vm;\n\t*dispc_vm = *req_vm;\n\tdispc_vm->pixelclock = dispc_pck;\n\n\tif (cfg->trans_mode == OMAP_DSS_DSI_PULSE_MODE) {\n\t\thsa = div64_u64((u64)req_vm->hsw * dispc_pck,\n\t\t\t\treq_pck_nom);\n\t\thsa = max(hsa, 1);\n\t} else {\n\t\thsa = 1;\n\t}\n\n\thbp = div64_u64((u64)req_vm->hbp * dispc_pck, req_pck_nom);\n\thbp = max(hbp, 1);\n\n\thfp = dispc_hbl - hsa - hbp;\n\tif (hfp < 1) {\n\t\tint t;\n\t\t \n\n\t\tt = 1 - hfp;\n\t\thbp = max(hbp - t, 1);\n\t\thfp = dispc_hbl - hsa - hbp;\n\n\t\tif (hfp < 1) {\n\t\t\t \n\t\t\tt = 1 - hfp;\n\t\t\thsa = max(hsa - t, 1);\n\t\t\thfp = dispc_hbl - hsa - hbp;\n\t\t}\n\t}\n\n\tif (hfp < 1)\n\t\treturn false;\n\n\tdispc_vm->hfp = hfp;\n\tdispc_vm->hsw = hsa;\n\tdispc_vm->hbp = hbp;\n\n\treturn true;\n}\n\n\nstatic bool dsi_vm_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\n\t\tunsigned long pck, void *data)\n{\n\tstruct dsi_clk_calc_ctx *ctx = data;\n\n\tctx->dispc_cinfo.lck_div = lckd;\n\tctx->dispc_cinfo.pck_div = pckd;\n\tctx->dispc_cinfo.lck = lck;\n\tctx->dispc_cinfo.pck = pck;\n\n\tif (dsi_vm_calc_blanking(ctx) == false)\n\t\treturn false;\n\n#ifdef PRINT_VERBOSE_VM_TIMINGS\n\tprint_dispc_vm(\"dispc\", &ctx->dispc_vm);\n\tprint_dsi_vm(\"dsi  \", &ctx->dsi_vm);\n\tprint_dispc_vm(\"req  \", ctx->config->timings);\n\tprint_dsi_dispc_vm(\"act  \", &ctx->dsi_vm);\n#endif\n\n\treturn true;\n}\n\nstatic bool dsi_vm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n\t\tvoid *data)\n{\n\tstruct dsi_clk_calc_ctx *ctx = data;\n\tunsigned long pck_max;\n\n\tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n\tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n\n\t \n\n\tif (ctx->config->trans_mode == OMAP_DSS_DSI_BURST_MODE)\n\t\tpck_max = ctx->req_pck_max + 10000000;\n\telse\n\t\tpck_max = ctx->req_pck_max;\n\n\treturn dispc_div_calc(dispc, ctx->req_pck_min, pck_max,\n\t\t\tdsi_vm_calc_dispc_cb, ctx);\n}\n\nstatic bool dsi_vm_calc_pll_cb(int n, int m, unsigned long fint,\n\t\tunsigned long clkdco, void *data)\n{\n\tstruct dsi_clk_calc_ctx *ctx = data;\n\n\tctx->dsi_cinfo.n = n;\n\tctx->dsi_cinfo.m = m;\n\tctx->dsi_cinfo.fint = fint;\n\tctx->dsi_cinfo.clkdco = clkdco;\n\n\treturn dss_pll_hsdiv_calc(ctx->pll, clkdco, ctx->req_pck_min,\n\t\t\tdss_feat_get_param_max(FEAT_PARAM_DSS_FCK),\n\t\t\tdsi_vm_calc_hsdiv_cb, ctx);\n}\n\nstatic bool dsi_vm_calc(struct dsi_data *dsi,\n\t\tconst struct omap_dss_dsi_config *cfg,\n\t\tstruct dsi_clk_calc_ctx *ctx)\n{\n\tconst struct omap_video_timings *t = cfg->timings;\n\tunsigned long clkin;\n\tunsigned long pll_min;\n\tunsigned long pll_max;\n\tint ndl = dsi->num_lanes_used - 1;\n\tint bitspp = dsi_get_pixel_size(cfg->pixel_format);\n\tunsigned long byteclk_min;\n\n\tclkin = clk_get_rate(dsi->pll.clkin);\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->dsidev = dsi->pdev;\n\tctx->pll = &dsi->pll;\n\tctx->config = cfg;\n\n\t \n\tctx->req_pck_min = t->pixelclock - 1000;\n\tctx->req_pck_nom = t->pixelclock;\n\tctx->req_pck_max = t->pixelclock + 1000;\n\n\tbyteclk_min = div64_u64((u64)ctx->req_pck_min * bitspp, ndl * 8);\n\tpll_min = max(cfg->hs_clk_min * 4, byteclk_min * 4 * 4);\n\n\tif (cfg->trans_mode == OMAP_DSS_DSI_BURST_MODE) {\n\t\tpll_max = cfg->hs_clk_max * 4;\n\t} else {\n\t\tunsigned long byteclk_max;\n\t\tbyteclk_max = div64_u64((u64)ctx->req_pck_max * bitspp,\n\t\t\t\tndl * 8);\n\n\t\tpll_max = byteclk_max * 4 * 4;\n\t}\n\n\treturn dss_pll_calc(ctx->pll, clkin,\n\t\t\tpll_min, pll_max,\n\t\t\tdsi_vm_calc_pll_cb, ctx);\n}\n\nstatic int dsi_set_config(struct omap_dss_device *dssdev,\n\t\tconst struct omap_dss_dsi_config *config)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstruct dsi_clk_calc_ctx ctx;\n\tbool ok;\n\tint r;\n\n\tmutex_lock(&dsi->lock);\n\n\tdsi->pix_fmt = config->pixel_format;\n\tdsi->mode = config->mode;\n\n\tif (config->mode == OMAP_DSS_DSI_VIDEO_MODE)\n\t\tok = dsi_vm_calc(dsi, config, &ctx);\n\telse\n\t\tok = dsi_cm_calc(dsi, config, &ctx);\n\n\tif (!ok) {\n\t\tDSSERR(\"failed to find suitable DSI clock settings\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdsi_pll_calc_dsi_fck(&ctx.dsi_cinfo);\n\n\tr = dsi_lp_clock_calc(ctx.dsi_cinfo.clkout[HSDIV_DSI],\n\t\tconfig->lp_clk_min, config->lp_clk_max, &dsi->user_lp_cinfo);\n\tif (r) {\n\t\tDSSERR(\"failed to find suitable DSI LP clock settings\\n\");\n\t\tgoto err;\n\t}\n\n\tdsi->user_dsi_cinfo = ctx.dsi_cinfo;\n\tdsi->user_dispc_cinfo = ctx.dispc_cinfo;\n\n\tdsi->timings = ctx.dispc_vm;\n\tdsi->vm_timings = ctx.dsi_vm;\n\n\tmutex_unlock(&dsi->lock);\n\n\treturn 0;\nerr:\n\tmutex_unlock(&dsi->lock);\n\n\treturn r;\n}\n\n \nstatic enum omap_channel dsi_get_channel(int module_id)\n{\n\tswitch (omapdss_get_version()) {\n\tcase OMAPDSS_VER_OMAP24xx:\n\tcase OMAPDSS_VER_AM43xx:\n\t\tDSSWARN(\"DSI not supported\\n\");\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\n\tcase OMAPDSS_VER_OMAP34xx_ES1:\n\tcase OMAPDSS_VER_OMAP34xx_ES3:\n\tcase OMAPDSS_VER_OMAP3630:\n\tcase OMAPDSS_VER_AM35xx:\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\n\tcase OMAPDSS_VER_OMAP4430_ES1:\n\tcase OMAPDSS_VER_OMAP4430_ES2:\n\tcase OMAPDSS_VER_OMAP4:\n\t\tswitch (module_id) {\n\t\tcase 0:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t\tcase 1:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD2;\n\t\tdefault:\n\t\t\tDSSWARN(\"unsupported module id\\n\");\n\t\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t\t}\n\n\tcase OMAPDSS_VER_OMAP5:\n\t\tswitch (module_id) {\n\t\tcase 0:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t\tcase 1:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD3;\n\t\tdefault:\n\t\t\tDSSWARN(\"unsupported module id\\n\");\n\t\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t\t}\n\n\tdefault:\n\t\tDSSWARN(\"unsupported DSS version\\n\");\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t}\n}\n\nstatic int dsi_request_vc(struct omap_dss_device *dssdev, int *channel)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dsi->vc); i++) {\n\t\tif (!dsi->vc[i].dssdev) {\n\t\t\tdsi->vc[i].dssdev = dssdev;\n\t\t\t*channel = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tDSSERR(\"cannot get VC for display %s\", dssdev->name);\n\treturn -ENOSPC;\n}\n\nstatic int dsi_set_vc_id(struct omap_dss_device *dssdev, int channel, int vc_id)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tif (vc_id < 0 || vc_id > 3) {\n\t\tDSSERR(\"VC ID out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (channel < 0 || channel > 3) {\n\t\tDSSERR(\"Virtual Channel out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dsi->vc[channel].dssdev != dssdev) {\n\t\tDSSERR(\"Virtual Channel not allocated to display %s\\n\",\n\t\t\tdssdev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tdsi->vc[channel].vc_id = vc_id;\n\n\treturn 0;\n}\n\nstatic void dsi_release_vc(struct omap_dss_device *dssdev, int channel)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tif ((channel >= 0 && channel <= 3) &&\n\t\tdsi->vc[channel].dssdev == dssdev) {\n\t\tdsi->vc[channel].dssdev = NULL;\n\t\tdsi->vc[channel].vc_id = 0;\n\t}\n}\n\n\nstatic int dsi_get_clocks(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstruct clk *clk;\n\n\tclk = devm_clk_get(&dsidev->dev, \"fck\");\n\tif (IS_ERR(clk)) {\n\t\tDSSERR(\"can't get fck\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tdsi->dss_clk = clk;\n\n\treturn 0;\n}\n\nstatic int dsi_connect(struct omap_dss_device *dssdev,\n\t\tstruct omap_dss_device *dst)\n{\n\tstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\n\tstruct omap_overlay_manager *mgr;\n\tint r;\n\n\tr = dsi_regulator_init(dsidev);\n\tif (r)\n\t\treturn r;\n\n\tmgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);\n\tif (!mgr)\n\t\treturn -ENODEV;\n\n\tr = dss_mgr_connect(mgr, dssdev);\n\tif (r)\n\t\treturn r;\n\n\tr = omapdss_output_set_device(dssdev, dst);\n\tif (r) {\n\t\tDSSERR(\"failed to connect output to new device: %s\\n\",\n\t\t\t\tdssdev->name);\n\t\tdss_mgr_disconnect(mgr, dssdev);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void dsi_disconnect(struct omap_dss_device *dssdev,\n\t\tstruct omap_dss_device *dst)\n{\n\tWARN_ON(dst != dssdev->dst);\n\n\tif (dst != dssdev->dst)\n\t\treturn;\n\n\tomapdss_output_unset_device(dssdev);\n\n\tif (dssdev->manager)\n\t\tdss_mgr_disconnect(dssdev->manager, dssdev);\n}\n\nstatic const struct omapdss_dsi_ops dsi_ops = {\n\t.connect = dsi_connect,\n\t.disconnect = dsi_disconnect,\n\n\t.bus_lock = dsi_bus_lock,\n\t.bus_unlock = dsi_bus_unlock,\n\n\t.enable = dsi_display_enable,\n\t.disable = dsi_display_disable,\n\n\t.enable_hs = dsi_vc_enable_hs,\n\n\t.configure_pins = dsi_configure_pins,\n\t.set_config = dsi_set_config,\n\n\t.enable_video_output = dsi_enable_video_output,\n\t.disable_video_output = dsi_disable_video_output,\n\n\t.update = dsi_update,\n\n\t.enable_te = dsi_enable_te,\n\n\t.request_vc = dsi_request_vc,\n\t.set_vc_id = dsi_set_vc_id,\n\t.release_vc = dsi_release_vc,\n\n\t.dcs_write = dsi_vc_dcs_write,\n\t.dcs_write_nosync = dsi_vc_dcs_write_nosync,\n\t.dcs_read = dsi_vc_dcs_read,\n\n\t.gen_write = dsi_vc_generic_write,\n\t.gen_write_nosync = dsi_vc_generic_write_nosync,\n\t.gen_read = dsi_vc_generic_read,\n\n\t.bta_sync = dsi_vc_send_bta_sync,\n\n\t.set_max_rx_packet_size = dsi_vc_set_max_rx_packet_size,\n};\n\nstatic void dsi_init_output(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstruct omap_dss_device *out = &dsi->output;\n\n\tout->dev = &dsidev->dev;\n\tout->id = dsi->module_id == 0 ?\n\t\t\tOMAP_DSS_OUTPUT_DSI1 : OMAP_DSS_OUTPUT_DSI2;\n\n\tout->output_type = OMAP_DISPLAY_TYPE_DSI;\n\tout->name = dsi->module_id == 0 ? \"dsi.0\" : \"dsi.1\";\n\tout->dispc_channel = dsi_get_channel(dsi->module_id);\n\tout->ops.dsi = &dsi_ops;\n\tout->owner = THIS_MODULE;\n\n\tomapdss_register_output(out);\n}\n\nstatic void dsi_uninit_output(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstruct omap_dss_device *out = &dsi->output;\n\n\tomapdss_unregister_output(out);\n}\n\nstatic int dsi_probe_of(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(pdev);\n\tstruct property *prop;\n\tu32 lane_arr[10];\n\tint len, num_pins;\n\tint r, i;\n\tstruct device_node *ep;\n\tstruct omap_dsi_pin_config pin_cfg;\n\n\tep = omapdss_of_get_first_endpoint(node);\n\tif (!ep)\n\t\treturn 0;\n\n\tprop = of_find_property(ep, \"lanes\", &len);\n\tif (prop == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to find lane data\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tnum_pins = len / sizeof(u32);\n\n\tif (num_pins < 4 || num_pins % 2 != 0 ||\n\t\tnum_pins > dsi->num_lanes_supported * 2) {\n\t\tdev_err(&pdev->dev, \"bad number of lanes\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tr = of_property_read_u32_array(ep, \"lanes\", lane_arr, num_pins);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"failed to read lane data\\n\");\n\t\tgoto err;\n\t}\n\n\tpin_cfg.num_pins = num_pins;\n\tfor (i = 0; i < num_pins; ++i)\n\t\tpin_cfg.pins[i] = (int)lane_arr[i];\n\n\tr = dsi_configure_pins(&dsi->output, &pin_cfg);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"failed to configure pins\");\n\t\tgoto err;\n\t}\n\n\tof_node_put(ep);\n\n\treturn 0;\n\nerr:\n\tof_node_put(ep);\n\treturn r;\n}\n\nstatic const struct dss_pll_ops dsi_pll_ops = {\n\t.enable = dsi_pll_enable,\n\t.disable = dsi_pll_disable,\n\t.set_config = dss_pll_write_config_type_a,\n};\n\nstatic const struct dss_pll_hw dss_omap3_dsi_pll_hw = {\n\t.n_max = (1 << 7) - 1,\n\t.m_max = (1 << 11) - 1,\n\t.mX_max = (1 << 4) - 1,\n\t.fint_min = 750000,\n\t.fint_max = 2100000,\n\t.clkdco_low = 1000000000,\n\t.clkdco_max = 1800000000,\n\n\t.n_msb = 7,\n\t.n_lsb = 1,\n\t.m_msb = 18,\n\t.m_lsb = 8,\n\n\t.mX_msb[0] = 22,\n\t.mX_lsb[0] = 19,\n\t.mX_msb[1] = 26,\n\t.mX_lsb[1] = 23,\n\n\t.has_stopmode = true,\n\t.has_freqsel = true,\n\t.has_selfreqdco = false,\n\t.has_refsel = false,\n};\n\nstatic const struct dss_pll_hw dss_omap4_dsi_pll_hw = {\n\t.n_max = (1 << 8) - 1,\n\t.m_max = (1 << 12) - 1,\n\t.mX_max = (1 << 5) - 1,\n\t.fint_min = 500000,\n\t.fint_max = 2500000,\n\t.clkdco_low = 1000000000,\n\t.clkdco_max = 1800000000,\n\n\t.n_msb = 8,\n\t.n_lsb = 1,\n\t.m_msb = 20,\n\t.m_lsb = 9,\n\n\t.mX_msb[0] = 25,\n\t.mX_lsb[0] = 21,\n\t.mX_msb[1] = 30,\n\t.mX_lsb[1] = 26,\n\n\t.has_stopmode = true,\n\t.has_freqsel = false,\n\t.has_selfreqdco = false,\n\t.has_refsel = false,\n};\n\nstatic const struct dss_pll_hw dss_omap5_dsi_pll_hw = {\n\t.n_max = (1 << 8) - 1,\n\t.m_max = (1 << 12) - 1,\n\t.mX_max = (1 << 5) - 1,\n\t.fint_min = 150000,\n\t.fint_max = 52000000,\n\t.clkdco_low = 1000000000,\n\t.clkdco_max = 1800000000,\n\n\t.n_msb = 8,\n\t.n_lsb = 1,\n\t.m_msb = 20,\n\t.m_lsb = 9,\n\n\t.mX_msb[0] = 25,\n\t.mX_lsb[0] = 21,\n\t.mX_msb[1] = 30,\n\t.mX_lsb[1] = 26,\n\n\t.has_stopmode = true,\n\t.has_freqsel = false,\n\t.has_selfreqdco = true,\n\t.has_refsel = true,\n};\n\nstatic int dsi_init_pll_data(struct platform_device *dsidev)\n{\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\tstruct dss_pll *pll = &dsi->pll;\n\tstruct clk *clk;\n\tint r;\n\n\tclk = devm_clk_get(&dsidev->dev, \"sys_clk\");\n\tif (IS_ERR(clk)) {\n\t\tDSSERR(\"can't get sys_clk\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tpll->name = dsi->module_id == 0 ? \"dsi0\" : \"dsi1\";\n\tpll->id = dsi->module_id == 0 ? DSS_PLL_DSI1 : DSS_PLL_DSI2;\n\tpll->clkin = clk;\n\tpll->base = dsi->pll_base;\n\n\tswitch (omapdss_get_version()) {\n\tcase OMAPDSS_VER_OMAP34xx_ES1:\n\tcase OMAPDSS_VER_OMAP34xx_ES3:\n\tcase OMAPDSS_VER_OMAP3630:\n\tcase OMAPDSS_VER_AM35xx:\n\t\tpll->hw = &dss_omap3_dsi_pll_hw;\n\t\tbreak;\n\n\tcase OMAPDSS_VER_OMAP4430_ES1:\n\tcase OMAPDSS_VER_OMAP4430_ES2:\n\tcase OMAPDSS_VER_OMAP4:\n\t\tpll->hw = &dss_omap4_dsi_pll_hw;\n\t\tbreak;\n\n\tcase OMAPDSS_VER_OMAP5:\n\t\tpll->hw = &dss_omap5_dsi_pll_hw;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tpll->ops = &dsi_pll_ops;\n\n\tr = dss_pll_register(pll);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\n \nstatic int dsi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *dsidev = to_platform_device(dev);\n\tu32 rev;\n\tint r, i;\n\tstruct dsi_data *dsi;\n\tstruct resource *dsi_mem;\n\tstruct resource *res;\n\tstruct resource temp_res;\n\n\tdsi = devm_kzalloc(&dsidev->dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\n\tdsi->pdev = dsidev;\n\tplatform_set_drvdata(dsidev, dsi);\n\n\tspin_lock_init(&dsi->irq_lock);\n\tspin_lock_init(&dsi->errors_lock);\n\tdsi->errors = 0;\n\n#ifdef CONFIG_FB_OMAP2_DSS_COLLECT_IRQ_STATS\n\tspin_lock_init(&dsi->irq_stats_lock);\n\tdsi->irq_stats.last_reset = jiffies;\n#endif\n\n\tmutex_init(&dsi->lock);\n\tsema_init(&dsi->bus_lock, 1);\n\n\tINIT_DEFERRABLE_WORK(&dsi->framedone_timeout_work,\n\t\t\t     dsi_framedone_timeout_work_callback);\n\n#ifdef DSI_CATCH_MISSING_TE\n\ttimer_setup(&dsi->te_timer, dsi_te_timeout, 0);\n#endif\n\n\tres = platform_get_resource_byname(dsidev, IORESOURCE_MEM, \"proto\");\n\tif (!res) {\n\t\tres = platform_get_resource(dsidev, IORESOURCE_MEM, 0);\n\t\tif (!res) {\n\t\t\tDSSERR(\"can't get IORESOURCE_MEM DSI\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttemp_res.start = res->start;\n\t\ttemp_res.end = temp_res.start + DSI_PROTO_SZ - 1;\n\t\tres = &temp_res;\n\t}\n\n\tdsi_mem = res;\n\n\tdsi->proto_base = devm_ioremap(&dsidev->dev, res->start,\n\t\tresource_size(res));\n\tif (!dsi->proto_base) {\n\t\tDSSERR(\"can't ioremap DSI protocol engine\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tres = platform_get_resource_byname(dsidev, IORESOURCE_MEM, \"phy\");\n\tif (!res) {\n\t\tres = platform_get_resource(dsidev, IORESOURCE_MEM, 0);\n\t\tif (!res) {\n\t\t\tDSSERR(\"can't get IORESOURCE_MEM DSI\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttemp_res.start = res->start + DSI_PHY_OFFSET;\n\t\ttemp_res.end = temp_res.start + DSI_PHY_SZ - 1;\n\t\tres = &temp_res;\n\t}\n\n\tdsi->phy_base = devm_ioremap(&dsidev->dev, res->start,\n\t\tresource_size(res));\n\tif (!dsi->phy_base) {\n\t\tDSSERR(\"can't ioremap DSI PHY\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tres = platform_get_resource_byname(dsidev, IORESOURCE_MEM, \"pll\");\n\tif (!res) {\n\t\tres = platform_get_resource(dsidev, IORESOURCE_MEM, 0);\n\t\tif (!res) {\n\t\t\tDSSERR(\"can't get IORESOURCE_MEM DSI\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttemp_res.start = res->start + DSI_PLL_OFFSET;\n\t\ttemp_res.end = temp_res.start + DSI_PLL_SZ - 1;\n\t\tres = &temp_res;\n\t}\n\n\tdsi->pll_base = devm_ioremap(&dsidev->dev, res->start,\n\t\tresource_size(res));\n\tif (!dsi->pll_base) {\n\t\tDSSERR(\"can't ioremap DSI PLL\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdsi->irq = platform_get_irq(dsi->pdev, 0);\n\tif (dsi->irq < 0) {\n\t\tDSSERR(\"platform_get_irq failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tr = devm_request_irq(&dsidev->dev, dsi->irq, omap_dsi_irq_handler,\n\t\t\t     IRQF_SHARED, dev_name(&dsidev->dev), dsi->pdev);\n\tif (r < 0) {\n\t\tDSSERR(\"request_irq failed\\n\");\n\t\treturn r;\n\t}\n\n\tif (dsidev->dev.of_node) {\n\t\tconst struct of_device_id *match;\n\t\tconst struct dsi_module_id_data *d;\n\n\t\tmatch = of_match_node(dsi_of_match, dsidev->dev.of_node);\n\t\tif (!match) {\n\t\t\tDSSERR(\"unsupported DSI module\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\td = match->data;\n\n\t\twhile (d->address != 0 && d->address != dsi_mem->start)\n\t\t\td++;\n\n\t\tif (d->address == 0) {\n\t\t\tDSSERR(\"unsupported DSI module\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tdsi->module_id = d->id;\n\t} else {\n\t\tdsi->module_id = dsidev->id;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dsi->vc); i++) {\n\t\tdsi->vc[i].source = DSI_VC_SOURCE_L4;\n\t\tdsi->vc[i].dssdev = NULL;\n\t\tdsi->vc[i].vc_id = 0;\n\t}\n\n\tr = dsi_get_clocks(dsidev);\n\tif (r)\n\t\treturn r;\n\n\tdsi_init_pll_data(dsidev);\n\n\tpm_runtime_enable(&dsidev->dev);\n\n\tr = dsi_runtime_get(dsidev);\n\tif (r)\n\t\tgoto err_runtime_get;\n\n\trev = dsi_read_reg(dsidev, DSI_REVISION);\n\tdev_dbg(&dsidev->dev, \"OMAP DSI rev %d.%d\\n\",\n\t       FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));\n\n\t \n\tif (dss_has_feature(FEAT_DSI_GNQ))\n\t\t \n\t\tdsi->num_lanes_supported = 1 + REG_GET(dsidev, DSI_GNQ, 11, 9);\n\telse\n\t\tdsi->num_lanes_supported = 3;\n\n\tdsi->line_buffer_size = dsi_get_line_buf_size(dsidev);\n\n\tdsi_init_output(dsidev);\n\n\tif (dsidev->dev.of_node) {\n\t\tr = dsi_probe_of(dsidev);\n\t\tif (r) {\n\t\t\tDSSERR(\"Invalid DSI DT data\\n\");\n\t\t\tgoto err_probe_of;\n\t\t}\n\n\t\tr = of_platform_populate(dsidev->dev.of_node, NULL, NULL,\n\t\t\t&dsidev->dev);\n\t\tif (r)\n\t\t\tDSSERR(\"Failed to populate DSI child devices: %d\\n\", r);\n\t}\n\n\tdsi_runtime_put(dsidev);\n\n\tif (dsi->module_id == 0)\n\t\tdss_debugfs_create_file(\"dsi1_regs\", dsi1_dump_regs);\n\telse if (dsi->module_id == 1)\n\t\tdss_debugfs_create_file(\"dsi2_regs\", dsi2_dump_regs);\n\n#ifdef CONFIG_FB_OMAP2_DSS_COLLECT_IRQ_STATS\n\tif (dsi->module_id == 0)\n\t\tdss_debugfs_create_file(\"dsi1_irqs\", dsi1_dump_irqs);\n\telse if (dsi->module_id == 1)\n\t\tdss_debugfs_create_file(\"dsi2_irqs\", dsi2_dump_irqs);\n#endif\n\n\treturn 0;\n\nerr_probe_of:\n\tdsi_uninit_output(dsidev);\n\tdsi_runtime_put(dsidev);\n\nerr_runtime_get:\n\tpm_runtime_disable(&dsidev->dev);\n\treturn r;\n}\n\nstatic void dsi_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *dsidev = to_platform_device(dev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\n\n\tof_platform_depopulate(&dsidev->dev);\n\n\tWARN_ON(dsi->scp_clk_refcount > 0);\n\n\tdss_pll_unregister(&dsi->pll);\n\n\tdsi_uninit_output(dsidev);\n\n\tpm_runtime_disable(&dsidev->dev);\n\n\tif (dsi->vdds_dsi_reg != NULL && dsi->vdds_dsi_enabled) {\n\t\tregulator_disable(dsi->vdds_dsi_reg);\n\t\tdsi->vdds_dsi_enabled = false;\n\t}\n}\n\nstatic const struct component_ops dsi_component_ops = {\n\t.bind\t= dsi_bind,\n\t.unbind\t= dsi_unbind,\n};\n\nstatic int dsi_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &dsi_component_ops);\n}\n\nstatic void dsi_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &dsi_component_ops);\n}\n\nstatic int dsi_runtime_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(pdev);\n\n\tdsi->is_enabled = false;\n\t \n\tsmp_wmb();\n\t \n\tsynchronize_irq(dsi->irq);\n\n\tdispc_runtime_put();\n\n\treturn 0;\n}\n\nstatic int dsi_runtime_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct dsi_data *dsi = dsi_get_dsidrv_data(pdev);\n\tint r;\n\n\tr = dispc_runtime_get();\n\tif (r)\n\t\treturn r;\n\n\tdsi->is_enabled = true;\n\t \n\tsmp_wmb();\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dsi_pm_ops = {\n\t.runtime_suspend = dsi_runtime_suspend,\n\t.runtime_resume = dsi_runtime_resume,\n};\n\nstatic const struct dsi_module_id_data dsi_of_data_omap3[] = {\n\t{ .address = 0x4804fc00, .id = 0, },\n\t{ },\n};\n\nstatic const struct dsi_module_id_data dsi_of_data_omap4[] = {\n\t{ .address = 0x58004000, .id = 0, },\n\t{ .address = 0x58005000, .id = 1, },\n\t{ },\n};\n\nstatic const struct dsi_module_id_data dsi_of_data_omap5[] = {\n\t{ .address = 0x58004000, .id = 0, },\n\t{ .address = 0x58009000, .id = 1, },\n\t{ },\n};\n\nstatic const struct of_device_id dsi_of_match[] = {\n\t{ .compatible = \"ti,omap3-dsi\", .data = dsi_of_data_omap3, },\n\t{ .compatible = \"ti,omap4-dsi\", .data = dsi_of_data_omap4, },\n\t{ .compatible = \"ti,omap5-dsi\", .data = dsi_of_data_omap5, },\n\t{},\n};\n\nstatic struct platform_driver omap_dsihw_driver = {\n\t.probe\t\t= dsi_probe,\n\t.remove_new\t= dsi_remove,\n\t.driver         = {\n\t\t.name   = \"omapdss_dsi\",\n\t\t.pm\t= &dsi_pm_ops,\n\t\t.of_match_table = dsi_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nint __init dsi_init_platform_driver(void)\n{\n\treturn platform_driver_register(&omap_dsihw_driver);\n}\n\nvoid dsi_uninit_platform_driver(void)\n{\n\tplatform_driver_unregister(&omap_dsihw_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}