{
  "module_name": "display.c",
  "hash_id": "47addaea76dc8f52052dde3a31540d1969e1f94bc5f90a7ad48afd128792e6a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/display.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"DISPLAY\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n\n#include <video/omapfb_dss.h>\n#include \"dss.h\"\n#include \"dss_features.h\"\n\nvoid omapdss_default_get_resolution(struct omap_dss_device *dssdev,\n\t\t\tu16 *xres, u16 *yres)\n{\n\t*xres = dssdev->panel.timings.x_res;\n\t*yres = dssdev->panel.timings.y_res;\n}\nEXPORT_SYMBOL(omapdss_default_get_resolution);\n\nint omapdss_default_get_recommended_bpp(struct omap_dss_device *dssdev)\n{\n\tswitch (dssdev->type) {\n\tcase OMAP_DISPLAY_TYPE_DPI:\n\t\tif (dssdev->phy.dpi.data_lines == 24)\n\t\t\treturn 24;\n\t\telse\n\t\t\treturn 16;\n\n\tcase OMAP_DISPLAY_TYPE_DBI:\n\t\tif (dssdev->ctrl.pixel_size == 24)\n\t\t\treturn 24;\n\t\telse\n\t\t\treturn 16;\n\tcase OMAP_DISPLAY_TYPE_DSI:\n\t\tif (dsi_get_pixel_size(dssdev->panel.dsi_pix_fmt) > 16)\n\t\t\treturn 24;\n\t\telse\n\t\t\treturn 16;\n\tcase OMAP_DISPLAY_TYPE_VENC:\n\tcase OMAP_DISPLAY_TYPE_SDI:\n\tcase OMAP_DISPLAY_TYPE_HDMI:\n\tcase OMAP_DISPLAY_TYPE_DVI:\n\t\treturn 24;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(omapdss_default_get_recommended_bpp);\n\nvoid omapdss_default_get_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\t*timings = dssdev->panel.timings;\n}\nEXPORT_SYMBOL(omapdss_default_get_timings);\n\nint dss_suspend_all_devices(void)\n{\n\tstruct omap_dss_device *dssdev = NULL;\n\n\tfor_each_dss_dev(dssdev) {\n\t\tif (!dssdev->driver)\n\t\t\tcontinue;\n\n\t\tif (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE) {\n\t\t\tdssdev->driver->disable(dssdev);\n\t\t\tdssdev->activate_after_resume = true;\n\t\t} else {\n\t\t\tdssdev->activate_after_resume = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint dss_resume_all_devices(void)\n{\n\tstruct omap_dss_device *dssdev = NULL;\n\n\tfor_each_dss_dev(dssdev) {\n\t\tif (!dssdev->driver)\n\t\t\tcontinue;\n\n\t\tif (dssdev->activate_after_resume) {\n\t\t\tdssdev->driver->enable(dssdev);\n\t\t\tdssdev->activate_after_resume = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid dss_disable_all_devices(void)\n{\n\tstruct omap_dss_device *dssdev = NULL;\n\n\tfor_each_dss_dev(dssdev) {\n\t\tif (!dssdev->driver)\n\t\t\tcontinue;\n\n\t\tif (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)\n\t\t\tdssdev->driver->disable(dssdev);\n\t}\n}\n\nstatic LIST_HEAD(panel_list);\nstatic DEFINE_MUTEX(panel_list_mutex);\nstatic int disp_num_counter;\n\nint omapdss_register_display(struct omap_dss_device *dssdev)\n{\n\tstruct omap_dss_driver *drv = dssdev->driver;\n\tint id;\n\n\t \n\n\tif (dssdev->dev->of_node) {\n\t\tid = of_alias_get_id(dssdev->dev->of_node, \"display\");\n\n\t\tif (id < 0)\n\t\t\tid = disp_num_counter++;\n\t} else {\n\t\tid = disp_num_counter++;\n\t}\n\n\tsnprintf(dssdev->alias, sizeof(dssdev->alias), \"display%d\", id);\n\n\t \n\tif (dssdev->dev->of_node)\n\t\tof_property_read_string(dssdev->dev->of_node, \"label\",\n\t\t\t&dssdev->name);\n\n\tif (dssdev->name == NULL)\n\t\tdssdev->name = dssdev->alias;\n\n\tif (drv && drv->get_resolution == NULL)\n\t\tdrv->get_resolution = omapdss_default_get_resolution;\n\tif (drv && drv->get_recommended_bpp == NULL)\n\t\tdrv->get_recommended_bpp = omapdss_default_get_recommended_bpp;\n\tif (drv && drv->get_timings == NULL)\n\t\tdrv->get_timings = omapdss_default_get_timings;\n\n\tmutex_lock(&panel_list_mutex);\n\tlist_add_tail(&dssdev->panel_list, &panel_list);\n\tmutex_unlock(&panel_list_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(omapdss_register_display);\n\nvoid omapdss_unregister_display(struct omap_dss_device *dssdev)\n{\n\tmutex_lock(&panel_list_mutex);\n\tlist_del(&dssdev->panel_list);\n\tmutex_unlock(&panel_list_mutex);\n}\nEXPORT_SYMBOL(omapdss_unregister_display);\n\nstruct omap_dss_device *omap_dss_get_device(struct omap_dss_device *dssdev)\n{\n\tif (!try_module_get(dssdev->owner))\n\t\treturn NULL;\n\n\tif (get_device(dssdev->dev) == NULL) {\n\t\tmodule_put(dssdev->owner);\n\t\treturn NULL;\n\t}\n\n\treturn dssdev;\n}\nEXPORT_SYMBOL(omap_dss_get_device);\n\nvoid omap_dss_put_device(struct omap_dss_device *dssdev)\n{\n\tput_device(dssdev->dev);\n\tmodule_put(dssdev->owner);\n}\nEXPORT_SYMBOL(omap_dss_put_device);\n\n \nstruct omap_dss_device *omap_dss_get_next_device(struct omap_dss_device *from)\n{\n\tstruct list_head *l;\n\tstruct omap_dss_device *dssdev;\n\n\tmutex_lock(&panel_list_mutex);\n\n\tif (list_empty(&panel_list)) {\n\t\tdssdev = NULL;\n\t\tgoto out;\n\t}\n\n\tif (from == NULL) {\n\t\tdssdev = list_first_entry(&panel_list, struct omap_dss_device,\n\t\t\t\tpanel_list);\n\t\tomap_dss_get_device(dssdev);\n\t\tgoto out;\n\t}\n\n\tomap_dss_put_device(from);\n\n\tlist_for_each(l, &panel_list) {\n\t\tdssdev = list_entry(l, struct omap_dss_device, panel_list);\n\t\tif (dssdev == from) {\n\t\t\tif (list_is_last(l, &panel_list)) {\n\t\t\t\tdssdev = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdssdev = list_entry(l->next, struct omap_dss_device,\n\t\t\t\t\tpanel_list);\n\t\t\tomap_dss_get_device(dssdev);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tWARN(1, \"'from' dssdev not found\\n\");\n\n\tdssdev = NULL;\nout:\n\tmutex_unlock(&panel_list_mutex);\n\treturn dssdev;\n}\nEXPORT_SYMBOL(omap_dss_get_next_device);\n\nstruct omap_dss_device *omap_dss_find_device(void *data,\n\t\tint (*match)(struct omap_dss_device *dssdev, void *data))\n{\n\tstruct omap_dss_device *dssdev = NULL;\n\n\twhile ((dssdev = omap_dss_get_next_device(dssdev)) != NULL) {\n\t\tif (match(dssdev, data))\n\t\t\treturn dssdev;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(omap_dss_find_device);\n\nvoid videomode_to_omap_video_timings(const struct videomode *vm,\n\t\tstruct omap_video_timings *ovt)\n{\n\tmemset(ovt, 0, sizeof(*ovt));\n\n\tovt->pixelclock = vm->pixelclock;\n\tovt->x_res = vm->hactive;\n\tovt->hbp = vm->hback_porch;\n\tovt->hfp = vm->hfront_porch;\n\tovt->hsw = vm->hsync_len;\n\tovt->y_res = vm->vactive;\n\tovt->vbp = vm->vback_porch;\n\tovt->vfp = vm->vfront_porch;\n\tovt->vsw = vm->vsync_len;\n\n\tovt->vsync_level = vm->flags & DISPLAY_FLAGS_VSYNC_HIGH ?\n\t\tOMAPDSS_SIG_ACTIVE_HIGH :\n\t\tOMAPDSS_SIG_ACTIVE_LOW;\n\tovt->hsync_level = vm->flags & DISPLAY_FLAGS_HSYNC_HIGH ?\n\t\tOMAPDSS_SIG_ACTIVE_HIGH :\n\t\tOMAPDSS_SIG_ACTIVE_LOW;\n\tovt->de_level = vm->flags & DISPLAY_FLAGS_DE_HIGH ?\n\t\tOMAPDSS_SIG_ACTIVE_HIGH :\n\t\tOMAPDSS_SIG_ACTIVE_LOW;\n\tovt->data_pclk_edge = vm->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE ?\n\t\tOMAPDSS_DRIVE_SIG_RISING_EDGE :\n\t\tOMAPDSS_DRIVE_SIG_FALLING_EDGE;\n\n\tovt->sync_pclk_edge = ovt->data_pclk_edge;\n}\nEXPORT_SYMBOL(videomode_to_omap_video_timings);\n\nvoid omap_video_timings_to_videomode(const struct omap_video_timings *ovt,\n\t\tstruct videomode *vm)\n{\n\tmemset(vm, 0, sizeof(*vm));\n\n\tvm->pixelclock = ovt->pixelclock;\n\n\tvm->hactive = ovt->x_res;\n\tvm->hback_porch = ovt->hbp;\n\tvm->hfront_porch = ovt->hfp;\n\tvm->hsync_len = ovt->hsw;\n\tvm->vactive = ovt->y_res;\n\tvm->vback_porch = ovt->vbp;\n\tvm->vfront_porch = ovt->vfp;\n\tvm->vsync_len = ovt->vsw;\n\n\tif (ovt->hsync_level == OMAPDSS_SIG_ACTIVE_HIGH)\n\t\tvm->flags |= DISPLAY_FLAGS_HSYNC_HIGH;\n\telse\n\t\tvm->flags |= DISPLAY_FLAGS_HSYNC_LOW;\n\n\tif (ovt->vsync_level == OMAPDSS_SIG_ACTIVE_HIGH)\n\t\tvm->flags |= DISPLAY_FLAGS_VSYNC_HIGH;\n\telse\n\t\tvm->flags |= DISPLAY_FLAGS_VSYNC_LOW;\n\n\tif (ovt->de_level == OMAPDSS_SIG_ACTIVE_HIGH)\n\t\tvm->flags |= DISPLAY_FLAGS_DE_HIGH;\n\telse\n\t\tvm->flags |= DISPLAY_FLAGS_DE_LOW;\n\n\tif (ovt->data_pclk_edge == OMAPDSS_DRIVE_SIG_RISING_EDGE)\n\t\tvm->flags |= DISPLAY_FLAGS_PIXDATA_POSEDGE;\n\telse\n\t\tvm->flags |= DISPLAY_FLAGS_PIXDATA_NEGEDGE;\n}\nEXPORT_SYMBOL(omap_video_timings_to_videomode);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}