{
  "module_name": "hdmi_phy.c",
  "hash_id": "a8a838cc1bfe74632b7949e6cdc04097cb010507372de6e5ef26d7e709aade72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/dss/hdmi_phy.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"dss.h\"\n#include \"hdmi.h\"\n\nstruct hdmi_phy_features {\n\tbool bist_ctrl;\n\tbool ldo_voltage;\n\tunsigned long max_phy;\n};\n\nstatic const struct hdmi_phy_features *phy_feat;\n\nvoid hdmi_phy_dump(struct hdmi_phy_data *phy, struct seq_file *s)\n{\n#define DUMPPHY(r) seq_printf(s, \"%-35s %08x\\n\", #r,\\\n\t\thdmi_read_reg(phy->base, r))\n\n\tDUMPPHY(HDMI_TXPHY_TX_CTRL);\n\tDUMPPHY(HDMI_TXPHY_DIGITAL_CTRL);\n\tDUMPPHY(HDMI_TXPHY_POWER_CTRL);\n\tDUMPPHY(HDMI_TXPHY_PAD_CFG_CTRL);\n\tif (phy_feat->bist_ctrl)\n\t\tDUMPPHY(HDMI_TXPHY_BIST_CONTROL);\n}\n\nint hdmi_phy_parse_lanes(struct hdmi_phy_data *phy, const u32 *lanes)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i += 2) {\n\t\tu8 lane, pol;\n\t\tint dx, dy;\n\n\t\tdx = lanes[i];\n\t\tdy = lanes[i + 1];\n\n\t\tif (dx < 0 || dx >= 8)\n\t\t\treturn -EINVAL;\n\n\t\tif (dy < 0 || dy >= 8)\n\t\t\treturn -EINVAL;\n\n\t\tif (dx & 1) {\n\t\t\tif (dy != dx - 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tpol = 1;\n\t\t} else {\n\t\t\tif (dy != dx + 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tpol = 0;\n\t\t}\n\n\t\tlane = dx / 2;\n\n\t\tphy->lane_function[lane] = i / 2;\n\t\tphy->lane_polarity[lane] = pol;\n\t}\n\n\treturn 0;\n}\n\nstatic void hdmi_phy_configure_lanes(struct hdmi_phy_data *phy)\n{\n\tstatic const u16 pad_cfg_list[] = {\n\t\t0x0123,\n\t\t0x0132,\n\t\t0x0312,\n\t\t0x0321,\n\t\t0x0231,\n\t\t0x0213,\n\t\t0x1023,\n\t\t0x1032,\n\t\t0x3012,\n\t\t0x3021,\n\t\t0x2031,\n\t\t0x2013,\n\t\t0x1203,\n\t\t0x1302,\n\t\t0x3102,\n\t\t0x3201,\n\t\t0x2301,\n\t\t0x2103,\n\t\t0x1230,\n\t\t0x1320,\n\t\t0x3120,\n\t\t0x3210,\n\t\t0x2310,\n\t\t0x2130,\n\t};\n\n\tu16 lane_cfg = 0;\n\tint i;\n\tunsigned lane_cfg_val;\n\tu16 pol_val = 0;\n\n\tfor (i = 0; i < 4; ++i)\n\t\tlane_cfg |= phy->lane_function[i] << ((3 - i) * 4);\n\n\tpol_val |= phy->lane_polarity[0] << 0;\n\tpol_val |= phy->lane_polarity[1] << 3;\n\tpol_val |= phy->lane_polarity[2] << 2;\n\tpol_val |= phy->lane_polarity[3] << 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(pad_cfg_list); ++i)\n\t\tif (pad_cfg_list[i] == lane_cfg)\n\t\t\tbreak;\n\n\tif (WARN_ON(i == ARRAY_SIZE(pad_cfg_list)))\n\t\ti = 0;\n\n\tlane_cfg_val = i;\n\n\tREG_FLD_MOD(phy->base, HDMI_TXPHY_PAD_CFG_CTRL, lane_cfg_val, 26, 22);\n\tREG_FLD_MOD(phy->base, HDMI_TXPHY_PAD_CFG_CTRL, pol_val, 30, 27);\n}\n\nint hdmi_phy_configure(struct hdmi_phy_data *phy, unsigned long hfbitclk,\n\tunsigned long lfbitclk)\n{\n\tu8 freqout;\n\n\t \n\thdmi_read_reg(phy->base, HDMI_TXPHY_TX_CTRL);\n\n\t \n\tif (phy_feat->bist_ctrl)\n\t\tREG_FLD_MOD(phy->base, HDMI_TXPHY_BIST_CONTROL, 1, 11, 11);\n\n\t \n\tif (hfbitclk != lfbitclk)\n\t\tfreqout = 0;\n\telse if (hfbitclk / 10 < phy_feat->max_phy)\n\t\tfreqout = 1;\n\telse\n\t\tfreqout = 2;\n\n\t \n\tREG_FLD_MOD(phy->base, HDMI_TXPHY_TX_CTRL, freqout, 31, 30);\n\n\t \n\thdmi_write_reg(phy->base, HDMI_TXPHY_DIGITAL_CTRL, 0xF0000000);\n\n\t \n\tif (phy_feat->ldo_voltage)\n\t\tREG_FLD_MOD(phy->base, HDMI_TXPHY_POWER_CTRL, 0xB, 3, 0);\n\n\thdmi_phy_configure_lanes(phy);\n\n\treturn 0;\n}\n\nstatic const struct hdmi_phy_features omap44xx_phy_feats = {\n\t.bist_ctrl\t=\tfalse,\n\t.ldo_voltage\t=\ttrue,\n\t.max_phy\t=\t185675000,\n};\n\nstatic const struct hdmi_phy_features omap54xx_phy_feats = {\n\t.bist_ctrl\t=\ttrue,\n\t.ldo_voltage\t=\tfalse,\n\t.max_phy\t=\t186000000,\n};\n\nstatic const struct hdmi_phy_features *hdmi_phy_get_features(void)\n{\n\tswitch (omapdss_get_version()) {\n\tcase OMAPDSS_VER_OMAP4430_ES1:\n\tcase OMAPDSS_VER_OMAP4430_ES2:\n\tcase OMAPDSS_VER_OMAP4:\n\t\treturn &omap44xx_phy_feats;\n\n\tcase OMAPDSS_VER_OMAP5:\n\tcase OMAPDSS_VER_DRA7xx:\n\t\treturn &omap54xx_phy_feats;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nint hdmi_phy_init(struct platform_device *pdev, struct hdmi_phy_data *phy)\n{\n\tphy_feat = hdmi_phy_get_features();\n\tif (!phy_feat)\n\t\treturn -ENODEV;\n\n\tphy->base = devm_platform_ioremap_resource_byname(pdev, \"phy\");\n\tif (IS_ERR(phy->base)) {\n\t\tDSSERR(\"can't ioremap TX PHY\\n\");\n\t\treturn PTR_ERR(phy->base);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}