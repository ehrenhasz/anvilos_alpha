{
  "module_name": "omapfb-sysfs.c",
  "hash_id": "e460d64a7dde91c4887a58e15c4c6114bb71f80d1d8f7983785577d3bccee5aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/omapfb-sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/fb.h>\n#include <linux/sysfs.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/mm.h>\n#include <linux/omapfb.h>\n\n#include <video/omapfb_dss.h>\n#include <video/omapvrfb.h>\n\n#include \"omapfb.h\"\n\nstatic ssize_t show_rotate_type(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ofbi->rotation_type);\n}\n\nstatic ssize_t store_rotate_type(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_mem_region *rg;\n\tint rot_type;\n\tint r;\n\n\tr = kstrtoint(buf, 0, &rot_type);\n\tif (r)\n\t\treturn r;\n\n\tif (rot_type != OMAP_DSS_ROT_DMA && rot_type != OMAP_DSS_ROT_VRFB)\n\t\treturn -EINVAL;\n\n\tlock_fb_info(fbi);\n\n\tr = 0;\n\tif (rot_type == ofbi->rotation_type)\n\t\tgoto out;\n\n\trg = omapfb_get_mem_region(ofbi->region);\n\n\tif (rg->size) {\n\t\tr = -EBUSY;\n\t\tgoto put_region;\n\t}\n\n\tofbi->rotation_type = rot_type;\n\n\t \nput_region:\n\tomapfb_put_mem_region(rg);\nout:\n\tunlock_fb_info(fbi);\n\n\treturn r ? r : count;\n}\n\n\nstatic ssize_t show_mirror(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ofbi->mirror);\n}\n\nstatic ssize_t store_mirror(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tbool mirror;\n\tint r;\n\tstruct fb_var_screeninfo new_var;\n\n\tr = kstrtobool(buf, &mirror);\n\tif (r)\n\t\treturn r;\n\n\tlock_fb_info(fbi);\n\n\tofbi->mirror = mirror;\n\n\tomapfb_get_mem_region(ofbi->region);\n\n\tmemcpy(&new_var, &fbi->var, sizeof(new_var));\n\tr = check_fb_var(fbi, &new_var);\n\tif (r)\n\t\tgoto out;\n\tmemcpy(&fbi->var, &new_var, sizeof(fbi->var));\n\n\tset_fb_fix(fbi);\n\n\tr = omapfb_apply_changes(fbi, 0);\n\tif (r)\n\t\tgoto out;\n\n\tr = count;\nout:\n\tomapfb_put_mem_region(ofbi->region);\n\n\tunlock_fb_info(fbi);\n\n\treturn r;\n}\n\nstatic ssize_t show_overlays(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tssize_t l = 0;\n\tint t;\n\n\tlock_fb_info(fbi);\n\tomapfb_lock(fbdev);\n\n\tfor (t = 0; t < ofbi->num_overlays; t++) {\n\t\tstruct omap_overlay *ovl = ofbi->overlays[t];\n\t\tint ovlnum;\n\n\t\tfor (ovlnum = 0; ovlnum < fbdev->num_overlays; ++ovlnum)\n\t\t\tif (ovl == fbdev->overlays[ovlnum])\n\t\t\t\tbreak;\n\n\t\tl += scnprintf(buf + l, PAGE_SIZE - l, \"%s%d\",\n\t\t\t\tt == 0 ? \"\" : \",\", ovlnum);\n\t}\n\n\tl += scnprintf(buf + l, PAGE_SIZE - l, \"\\n\");\n\n\tomapfb_unlock(fbdev);\n\tunlock_fb_info(fbi);\n\n\treturn l;\n}\n\nstatic struct omapfb_info *get_overlay_fb(struct omapfb2_device *fbdev,\n\t\tstruct omap_overlay *ovl)\n{\n\tint i, t;\n\n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\tstruct omapfb_info *ofbi = FB2OFB(fbdev->fbs[i]);\n\n\t\tfor (t = 0; t < ofbi->num_overlays; t++) {\n\t\t\tif (ofbi->overlays[t] == ovl)\n\t\t\t\treturn ofbi;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic ssize_t store_overlays(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omap_overlay *ovls[OMAPFB_MAX_OVL_PER_FB];\n\tstruct omap_overlay *ovl;\n\tint num_ovls, r, i;\n\tint len;\n\tbool added = false;\n\n\tnum_ovls = 0;\n\n\tlen = strlen(buf);\n\tif (buf[len - 1] == '\\n')\n\t\tlen = len - 1;\n\n\tlock_fb_info(fbi);\n\tomapfb_lock(fbdev);\n\n\tif (len > 0) {\n\t\tchar *p = (char *)buf;\n\t\tint ovlnum;\n\n\t\twhile (p < buf + len) {\n\t\t\tint found;\n\t\t\tif (num_ovls == OMAPFB_MAX_OVL_PER_FB) {\n\t\t\t\tr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tovlnum = simple_strtoul(p, &p, 0);\n\t\t\tif (ovlnum > fbdev->num_overlays) {\n\t\t\t\tr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfound = 0;\n\t\t\tfor (i = 0; i < num_ovls; ++i) {\n\t\t\t\tif (ovls[i] == fbdev->overlays[ovlnum]) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!found)\n\t\t\t\tovls[num_ovls++] = fbdev->overlays[ovlnum];\n\n\t\t\tp++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_ovls; ++i) {\n\t\tstruct omapfb_info *ofbi2 = get_overlay_fb(fbdev, ovls[i]);\n\t\tif (ofbi2 && ofbi2 != ofbi) {\n\t\t\tdev_err(fbdev->dev, \"overlay already in use\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ofbi->num_overlays; ++i) {\n\t\tint t, found;\n\n\t\tovl = ofbi->overlays[i];\n\n\t\tfound = 0;\n\n\t\tfor (t = 0; t < num_ovls; ++t) {\n\t\t\tif (ovl == ovls[t]) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\tDBG(\"detaching %d\\n\", ofbi->overlays[i]->id);\n\n\t\tomapfb_get_mem_region(ofbi->region);\n\n\t\tomapfb_overlay_enable(ovl, 0);\n\n\t\tif (ovl->manager)\n\t\t\tovl->manager->apply(ovl->manager);\n\n\t\tomapfb_put_mem_region(ofbi->region);\n\n\t\tfor (t = i + 1; t < ofbi->num_overlays; t++) {\n\t\t\tofbi->rotation[t-1] = ofbi->rotation[t];\n\t\t\tofbi->overlays[t-1] = ofbi->overlays[t];\n\t\t}\n\n\t\tofbi->num_overlays--;\n\t\ti--;\n\t}\n\n\tfor (i = 0; i < num_ovls; ++i) {\n\t\tint t, found;\n\n\t\tovl = ovls[i];\n\n\t\tfound = 0;\n\n\t\tfor (t = 0; t < ofbi->num_overlays; ++t) {\n\t\t\tif (ovl == ofbi->overlays[t]) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found)\n\t\t\tcontinue;\n\t\tofbi->rotation[ofbi->num_overlays] = 0;\n\t\tofbi->overlays[ofbi->num_overlays++] = ovl;\n\n\t\tadded = true;\n\t}\n\n\tif (added) {\n\t\tomapfb_get_mem_region(ofbi->region);\n\n\t\tr = omapfb_apply_changes(fbi, 0);\n\n\t\tomapfb_put_mem_region(ofbi->region);\n\n\t\tif (r)\n\t\t\tgoto out;\n\t}\n\n\tr = count;\nout:\n\tomapfb_unlock(fbdev);\n\tunlock_fb_info(fbi);\n\n\treturn r;\n}\n\nstatic ssize_t show_overlays_rotate(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tssize_t l = 0;\n\tint t;\n\n\tlock_fb_info(fbi);\n\n\tfor (t = 0; t < ofbi->num_overlays; t++) {\n\t\tl += scnprintf(buf + l, PAGE_SIZE - l, \"%s%d\",\n\t\t\t\tt == 0 ? \"\" : \",\", ofbi->rotation[t]);\n\t}\n\n\tl += scnprintf(buf + l, PAGE_SIZE - l, \"\\n\");\n\n\tunlock_fb_info(fbi);\n\n\treturn l;\n}\n\nstatic ssize_t store_overlays_rotate(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tint num_ovls = 0, r, i;\n\tint len;\n\tbool changed = false;\n\tu8 rotation[OMAPFB_MAX_OVL_PER_FB];\n\n\tlen = strlen(buf);\n\tif (buf[len - 1] == '\\n')\n\t\tlen = len - 1;\n\n\tlock_fb_info(fbi);\n\n\tif (len > 0) {\n\t\tchar *p = (char *)buf;\n\n\t\twhile (p < buf + len) {\n\t\t\tint rot;\n\n\t\t\tif (num_ovls == ofbi->num_overlays) {\n\t\t\t\tr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trot = simple_strtoul(p, &p, 0);\n\t\t\tif (rot < 0 || rot > 3) {\n\t\t\t\tr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (ofbi->rotation[num_ovls] != rot)\n\t\t\t\tchanged = true;\n\n\t\t\trotation[num_ovls++] = rot;\n\n\t\t\tp++;\n\t\t}\n\t}\n\n\tif (num_ovls != ofbi->num_overlays) {\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (changed) {\n\t\tfor (i = 0; i < num_ovls; ++i)\n\t\t\tofbi->rotation[i] = rotation[i];\n\n\t\tomapfb_get_mem_region(ofbi->region);\n\n\t\tr = omapfb_apply_changes(fbi, 0);\n\n\t\tomapfb_put_mem_region(ofbi->region);\n\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\t \n\t}\n\n\tr = count;\nout:\n\tunlock_fb_info(fbi);\n\n\treturn r;\n}\n\nstatic ssize_t show_size(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", ofbi->region->size);\n}\n\nstatic ssize_t store_size(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\tstruct omapfb2_device *fbdev = ofbi->fbdev;\n\tstruct omap_dss_device *display = fb2display(fbi);\n\tstruct omapfb2_mem_region *rg;\n\tunsigned long size;\n\tint r;\n\tint i;\n\n\tr = kstrtoul(buf, 0, &size);\n\tif (r)\n\t\treturn r;\n\n\tsize = PAGE_ALIGN(size);\n\n\tlock_fb_info(fbi);\n\n\tif (display && display->driver->sync)\n\t\tdisplay->driver->sync(display);\n\n\trg = ofbi->region;\n\n\tdown_write_nested(&rg->lock, rg->id);\n\tatomic_inc(&rg->lock_count);\n\n\tif (atomic_read(&rg->map_count)) {\n\t\tr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\tstruct omapfb_info *ofbi2 = FB2OFB(fbdev->fbs[i]);\n\t\tint j;\n\n\t\tif (ofbi2->region != rg)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ofbi2->num_overlays; j++) {\n\t\t\tstruct omap_overlay *ovl;\n\t\t\tovl = ofbi2->overlays[j];\n\t\t\tif (ovl->is_enabled(ovl)) {\n\t\t\t\tr = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (size != ofbi->region->size) {\n\t\tr = omapfb_realloc_fbmem(fbi, size, ofbi->region->type);\n\t\tif (r) {\n\t\t\tdev_err(dev, \"realloc fbmem failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tr = count;\nout:\n\tatomic_dec(&rg->lock_count);\n\tup_write(&rg->lock);\n\n\tunlock_fb_info(fbi);\n\n\treturn r;\n}\n\nstatic ssize_t show_phys(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\n\treturn sysfs_emit(buf, \"%0x\\n\", ofbi->region->paddr);\n}\n\nstatic ssize_t show_virt(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct omapfb_info *ofbi = FB2OFB(fbi);\n\n\treturn sysfs_emit(buf, \"%p\\n\", ofbi->region->vaddr);\n}\n\nstatic ssize_t show_upd_mode(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tenum omapfb_update_mode mode;\n\tint r;\n\n\tr = omapfb_get_update_mode(fbi, &mode);\n\n\tif (r)\n\t\treturn r;\n\n\treturn sysfs_emit(buf, \"%u\\n\", (unsigned int)mode);\n}\n\nstatic ssize_t store_upd_mode(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tunsigned mode;\n\tint r;\n\n\tr = kstrtouint(buf, 0, &mode);\n\tif (r)\n\t\treturn r;\n\n\tr = omapfb_set_update_mode(fbi, mode);\n\tif (r)\n\t\treturn r;\n\n\treturn count;\n}\n\nstatic struct device_attribute omapfb_attrs[] = {\n\t__ATTR(rotate_type, S_IRUGO | S_IWUSR, show_rotate_type,\n\t\t\tstore_rotate_type),\n\t__ATTR(mirror, S_IRUGO | S_IWUSR, show_mirror, store_mirror),\n\t__ATTR(size, S_IRUGO | S_IWUSR, show_size, store_size),\n\t__ATTR(overlays, S_IRUGO | S_IWUSR, show_overlays, store_overlays),\n\t__ATTR(overlays_rotate, S_IRUGO | S_IWUSR, show_overlays_rotate,\n\t\t\tstore_overlays_rotate),\n\t__ATTR(phys_addr, S_IRUGO, show_phys, NULL),\n\t__ATTR(virt_addr, S_IRUGO, show_virt, NULL),\n\t__ATTR(update_mode, S_IRUGO | S_IWUSR, show_upd_mode, store_upd_mode),\n};\n\nint omapfb_create_sysfs(struct omapfb2_device *fbdev)\n{\n\tint i;\n\tint r;\n\n\tDBG(\"create sysfs for fbs\\n\");\n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\tint t;\n\t\tfor (t = 0; t < ARRAY_SIZE(omapfb_attrs); t++) {\n\t\t\tr = device_create_file(fbdev->fbs[i]->dev,\n\t\t\t\t\t&omapfb_attrs[t]);\n\n\t\t\tif (r) {\n\t\t\t\tdev_err(fbdev->dev, \"failed to create sysfs \"\n\t\t\t\t\t\t\"file\\n\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid omapfb_remove_sysfs(struct omapfb2_device *fbdev)\n{\n\tint i, t;\n\n\tDBG(\"remove sysfs for fbs\\n\");\n\tfor (i = 0; i < fbdev->num_fbs; i++) {\n\t\tfor (t = 0; t < ARRAY_SIZE(omapfb_attrs); t++)\n\t\t\tdevice_remove_file(fbdev->fbs[i]->dev,\n\t\t\t\t\t&omapfb_attrs[t]);\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}