{
  "module_name": "panel-sharp-ls037v7dw01.c",
  "hash_id": "bf15bc5f87bfcabbf4e8ae37344621566eca418ea4489c279451fb9dd0cfe1bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/displays/panel-sharp-ls037v7dw01.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/regulator/consumer.h>\n#include <video/omapfb_dss.h>\n\nstruct panel_drv_data {\n\tstruct omap_dss_device dssdev;\n\tstruct omap_dss_device *in;\n\tstruct regulator *vcc;\n\n\tint data_lines;\n\n\tstruct omap_video_timings videomode;\n\n\tstruct gpio_desc *resb_gpio;\t \n\tstruct gpio_desc *ini_gpio;\t \n\tstruct gpio_desc *mo_gpio;\t \n\tstruct gpio_desc *lr_gpio;\t \n\tstruct gpio_desc *ud_gpio;\t \n};\n\nstatic const struct omap_video_timings sharp_ls_timings = {\n\t.x_res = 480,\n\t.y_res = 640,\n\n\t.pixelclock\t= 19200000,\n\n\t.hsw\t\t= 2,\n\t.hfp\t\t= 1,\n\t.hbp\t\t= 28,\n\n\t.vsw\t\t= 1,\n\t.vfp\t\t= 1,\n\t.vbp\t\t= 1,\n\n\t.vsync_level\t= OMAPDSS_SIG_ACTIVE_LOW,\n\t.hsync_level\t= OMAPDSS_SIG_ACTIVE_LOW,\n\t.data_pclk_edge\t= OMAPDSS_DRIVE_SIG_RISING_EDGE,\n\t.de_level\t= OMAPDSS_SIG_ACTIVE_HIGH,\n\t.sync_pclk_edge\t= OMAPDSS_DRIVE_SIG_FALLING_EDGE,\n};\n\n#define to_panel_data(p) container_of(p, struct panel_drv_data, dssdev)\n\nstatic int sharp_ls_connect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (omapdss_device_is_connected(dssdev))\n\t\treturn 0;\n\n\treturn in->ops.dpi->connect(in, dssdev);\n}\n\nstatic void sharp_ls_disconnect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (!omapdss_device_is_connected(dssdev))\n\t\treturn;\n\n\tin->ops.dpi->disconnect(in, dssdev);\n}\n\nstatic int sharp_ls_enable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tif (!omapdss_device_is_connected(dssdev))\n\t\treturn -ENODEV;\n\n\tif (omapdss_device_is_enabled(dssdev))\n\t\treturn 0;\n\n\tif (ddata->data_lines)\n\t\tin->ops.dpi->set_data_lines(in, ddata->data_lines);\n\tin->ops.dpi->set_timings(in, &ddata->videomode);\n\n\tif (ddata->vcc) {\n\t\tr = regulator_enable(ddata->vcc);\n\t\tif (r != 0)\n\t\t\treturn r;\n\t}\n\n\tr = in->ops.dpi->enable(in);\n\tif (r) {\n\t\tregulator_disable(ddata->vcc);\n\t\treturn r;\n\t}\n\n\t \n\tmsleep(50);\n\n\tif (ddata->resb_gpio)\n\t\tgpiod_set_value_cansleep(ddata->resb_gpio, 1);\n\n\tif (ddata->ini_gpio)\n\t\tgpiod_set_value_cansleep(ddata->ini_gpio, 1);\n\n\tdssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\n\n\treturn 0;\n}\n\nstatic void sharp_ls_disable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (!omapdss_device_is_enabled(dssdev))\n\t\treturn;\n\n\tif (ddata->ini_gpio)\n\t\tgpiod_set_value_cansleep(ddata->ini_gpio, 0);\n\n\tif (ddata->resb_gpio)\n\t\tgpiod_set_value_cansleep(ddata->resb_gpio, 0);\n\n\t \n\n\tmsleep(100);\n\n\tin->ops.dpi->disable(in);\n\n\tif (ddata->vcc)\n\t\tregulator_disable(ddata->vcc);\n\n\tdssdev->state = OMAP_DSS_DISPLAY_DISABLED;\n}\n\nstatic void sharp_ls_set_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tddata->videomode = *timings;\n\tdssdev->panel.timings = *timings;\n\n\tin->ops.dpi->set_timings(in, timings);\n}\n\nstatic void sharp_ls_get_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\n\t*timings = ddata->videomode;\n}\n\nstatic int sharp_ls_check_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\treturn in->ops.dpi->check_timings(in, timings);\n}\n\nstatic struct omap_dss_driver sharp_ls_ops = {\n\t.connect\t= sharp_ls_connect,\n\t.disconnect\t= sharp_ls_disconnect,\n\n\t.enable\t\t= sharp_ls_enable,\n\t.disable\t= sharp_ls_disable,\n\n\t.set_timings\t= sharp_ls_set_timings,\n\t.get_timings\t= sharp_ls_get_timings,\n\t.check_timings\t= sharp_ls_check_timings,\n\n\t.get_resolution\t= omapdss_default_get_resolution,\n};\n\nstatic  int sharp_ls_get_gpio_of(struct device *dev, int index, int val,\n\tconst char *desc, struct gpio_desc **gpiod)\n{\n\tstruct gpio_desc *gd;\n\n\t*gpiod = NULL;\n\n\tgd = devm_gpiod_get_index(dev, desc, index, GPIOD_OUT_LOW);\n\tif (IS_ERR(gd))\n\t\treturn PTR_ERR(gd);\n\n\t*gpiod = gd;\n\treturn 0;\n}\n\nstatic int sharp_ls_probe_of(struct platform_device *pdev)\n{\n\tstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct omap_dss_device *in;\n\tint r;\n\n\tddata->vcc = devm_regulator_get(&pdev->dev, \"envdd\");\n\tif (IS_ERR(ddata->vcc))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(ddata->vcc),\n\t\t\t\t     \"failed to get regulator\\n\");\n\n\t \n\tr = sharp_ls_get_gpio_of(&pdev->dev, 0, 0, \"enable\", &ddata->ini_gpio);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = sharp_ls_get_gpio_of(&pdev->dev, 0, 0, \"reset\", &ddata->resb_gpio);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = sharp_ls_get_gpio_of(&pdev->dev, 0, 0, \"mode\", &ddata->mo_gpio);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = sharp_ls_get_gpio_of(&pdev->dev, 1, 1, \"mode\", &ddata->lr_gpio);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = sharp_ls_get_gpio_of(&pdev->dev, 2, 1, \"mode\", &ddata->ud_gpio);\n\tif (r)\n\t\treturn r;\n\n\tin = omapdss_of_find_source_for_first_ep(node);\n\tif (IS_ERR(in)) {\n\t\tdev_err(&pdev->dev, \"failed to find video source\\n\");\n\t\treturn PTR_ERR(in);\n\t}\n\n\tddata->in = in;\n\n\treturn 0;\n}\n\nstatic int sharp_ls_probe(struct platform_device *pdev)\n{\n\tstruct panel_drv_data *ddata;\n\tstruct omap_dss_device *dssdev;\n\tint r;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (ddata == NULL)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ddata);\n\n\tr = sharp_ls_probe_of(pdev);\n\tif (r)\n\t\treturn r;\n\n\tddata->videomode = sharp_ls_timings;\n\n\tdssdev = &ddata->dssdev;\n\tdssdev->dev = &pdev->dev;\n\tdssdev->driver = &sharp_ls_ops;\n\tdssdev->type = OMAP_DISPLAY_TYPE_DPI;\n\tdssdev->owner = THIS_MODULE;\n\tdssdev->panel.timings = ddata->videomode;\n\tdssdev->phy.dpi.data_lines = ddata->data_lines;\n\n\tr = omapdss_register_display(dssdev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"Failed to register panel\\n\");\n\t\tgoto err_reg;\n\t}\n\n\treturn 0;\n\nerr_reg:\n\tomap_dss_put_device(ddata->in);\n\treturn r;\n}\n\nstatic int __exit sharp_ls_remove(struct platform_device *pdev)\n{\n\tstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\n\tstruct omap_dss_device *dssdev = &ddata->dssdev;\n\tstruct omap_dss_device *in = ddata->in;\n\n\tomapdss_unregister_display(dssdev);\n\n\tsharp_ls_disable(dssdev);\n\tsharp_ls_disconnect(dssdev);\n\n\tomap_dss_put_device(in);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sharp_ls_of_match[] = {\n\t{ .compatible = \"omapdss,sharp,ls037v7dw01\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, sharp_ls_of_match);\n\nstatic struct platform_driver sharp_ls_driver = {\n\t.probe = sharp_ls_probe,\n\t.remove = __exit_p(sharp_ls_remove),\n\t.driver = {\n\t\t.name = \"panel-sharp-ls037v7dw01\",\n\t\t.of_match_table = sharp_ls_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nmodule_platform_driver(sharp_ls_driver);\n\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ti.com>\");\nMODULE_DESCRIPTION(\"Sharp LS037V7DW01 Panel Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}