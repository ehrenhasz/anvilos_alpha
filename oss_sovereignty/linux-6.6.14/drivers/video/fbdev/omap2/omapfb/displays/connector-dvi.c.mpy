{
  "module_name": "connector-dvi.c",
  "hash_id": "838ba070b018e716fe62d5c2f39dbc76a45f6d726914508f4721bd04f93d20ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/displays/connector-dvi.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <drm/drm_edid.h>\n\n#include <video/omapfb_dss.h>\n\nstatic const struct omap_video_timings dvic_default_timings = {\n\t.x_res\t\t= 640,\n\t.y_res\t\t= 480,\n\n\t.pixelclock\t= 23500000,\n\n\t.hfp\t\t= 48,\n\t.hsw\t\t= 32,\n\t.hbp\t\t= 80,\n\n\t.vfp\t\t= 3,\n\t.vsw\t\t= 4,\n\t.vbp\t\t= 7,\n\n\t.vsync_level\t= OMAPDSS_SIG_ACTIVE_HIGH,\n\t.hsync_level\t= OMAPDSS_SIG_ACTIVE_HIGH,\n\t.data_pclk_edge\t= OMAPDSS_DRIVE_SIG_RISING_EDGE,\n\t.de_level\t= OMAPDSS_SIG_ACTIVE_HIGH,\n\t.sync_pclk_edge\t= OMAPDSS_DRIVE_SIG_FALLING_EDGE,\n};\n\nstruct panel_drv_data {\n\tstruct omap_dss_device dssdev;\n\tstruct omap_dss_device *in;\n\n\tstruct omap_video_timings timings;\n\n\tstruct i2c_adapter *i2c_adapter;\n};\n\n#define to_panel_data(x) container_of(x, struct panel_drv_data, dssdev)\n\nstatic int dvic_connect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (omapdss_device_is_connected(dssdev))\n\t\treturn 0;\n\n\treturn in->ops.dvi->connect(in, dssdev);\n}\n\nstatic void dvic_disconnect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (!omapdss_device_is_connected(dssdev))\n\t\treturn;\n\n\tin->ops.dvi->disconnect(in, dssdev);\n}\n\nstatic int dvic_enable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tif (!omapdss_device_is_connected(dssdev))\n\t\treturn -ENODEV;\n\n\tif (omapdss_device_is_enabled(dssdev))\n\t\treturn 0;\n\n\tin->ops.dvi->set_timings(in, &ddata->timings);\n\n\tr = in->ops.dvi->enable(in);\n\tif (r)\n\t\treturn r;\n\n\tdssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\n\n\treturn 0;\n}\n\nstatic void dvic_disable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (!omapdss_device_is_enabled(dssdev))\n\t\treturn;\n\n\tin->ops.dvi->disable(in);\n\n\tdssdev->state = OMAP_DSS_DISPLAY_DISABLED;\n}\n\nstatic void dvic_set_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tddata->timings = *timings;\n\tdssdev->panel.timings = *timings;\n\n\tin->ops.dvi->set_timings(in, timings);\n}\n\nstatic void dvic_get_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\n\t*timings = ddata->timings;\n}\n\nstatic int dvic_check_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\treturn in->ops.dvi->check_timings(in, timings);\n}\n\nstatic int dvic_ddc_read(struct i2c_adapter *adapter,\n\t\tunsigned char *buf, u16 count, u8 offset)\n{\n\tint r, retries;\n\n\tfor (retries = 3; retries > 0; retries--) {\n\t\tstruct i2c_msg msgs[] = {\n\t\t\t{\n\t\t\t\t.addr   = DDC_ADDR,\n\t\t\t\t.flags  = 0,\n\t\t\t\t.len    = 1,\n\t\t\t\t.buf    = &offset,\n\t\t\t}, {\n\t\t\t\t.addr   = DDC_ADDR,\n\t\t\t\t.flags  = I2C_M_RD,\n\t\t\t\t.len    = count,\n\t\t\t\t.buf    = buf,\n\t\t\t}\n\t\t};\n\n\t\tr = i2c_transfer(adapter, msgs, 2);\n\t\tif (r == 2)\n\t\t\treturn 0;\n\n\t\tif (r != -EAGAIN)\n\t\t\tbreak;\n\t}\n\n\treturn r < 0 ? r : -EIO;\n}\n\nstatic int dvic_read_edid(struct omap_dss_device *dssdev,\n\t\tu8 *edid, int len)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tint r, l, bytes_read;\n\n\tif (!ddata->i2c_adapter)\n\t\treturn -ENODEV;\n\n\tl = min(EDID_LENGTH, len);\n\tr = dvic_ddc_read(ddata->i2c_adapter, edid, l, 0);\n\tif (r)\n\t\treturn r;\n\n\tbytes_read = l;\n\n\t \n\tif (len > EDID_LENGTH && edid[0x7e] > 0) {\n\t\tl = min(EDID_LENGTH, len - EDID_LENGTH);\n\n\t\tr = dvic_ddc_read(ddata->i2c_adapter, edid + EDID_LENGTH,\n\t\t\t\tl, EDID_LENGTH);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tbytes_read += l;\n\t}\n\n\treturn bytes_read;\n}\n\nstatic bool dvic_detect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tunsigned char out;\n\tint r;\n\n\tif (!ddata->i2c_adapter)\n\t\treturn true;\n\n\tr = dvic_ddc_read(ddata->i2c_adapter, &out, 1, 0);\n\n\treturn r == 0;\n}\n\nstatic struct omap_dss_driver dvic_driver = {\n\t.connect\t= dvic_connect,\n\t.disconnect\t= dvic_disconnect,\n\n\t.enable\t\t= dvic_enable,\n\t.disable\t= dvic_disable,\n\n\t.set_timings\t= dvic_set_timings,\n\t.get_timings\t= dvic_get_timings,\n\t.check_timings\t= dvic_check_timings,\n\n\t.get_resolution\t= omapdss_default_get_resolution,\n\n\t.read_edid\t= dvic_read_edid,\n\t.detect\t\t= dvic_detect,\n};\n\nstatic int dvic_probe_of(struct platform_device *pdev)\n{\n\tstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct omap_dss_device *in;\n\tstruct device_node *adapter_node;\n\tstruct i2c_adapter *adapter;\n\n\tin = omapdss_of_find_source_for_first_ep(node);\n\tif (IS_ERR(in)) {\n\t\tdev_err(&pdev->dev, \"failed to find video source\\n\");\n\t\treturn PTR_ERR(in);\n\t}\n\n\tddata->in = in;\n\n\tadapter_node = of_parse_phandle(node, \"ddc-i2c-bus\", 0);\n\tif (adapter_node) {\n\t\tadapter = of_get_i2c_adapter_by_node(adapter_node);\n\t\tof_node_put(adapter_node);\n\t\tif (adapter == NULL) {\n\t\t\tdev_err(&pdev->dev, \"failed to parse ddc-i2c-bus\\n\");\n\t\t\tomap_dss_put_device(ddata->in);\n\t\t\treturn -EPROBE_DEFER;\n\t\t}\n\n\t\tddata->i2c_adapter = adapter;\n\t}\n\n\treturn 0;\n}\n\nstatic int dvic_probe(struct platform_device *pdev)\n{\n\tstruct panel_drv_data *ddata;\n\tstruct omap_dss_device *dssdev;\n\tint r;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ddata);\n\n\tr = dvic_probe_of(pdev);\n\tif (r)\n\t\treturn r;\n\n\tddata->timings = dvic_default_timings;\n\n\tdssdev = &ddata->dssdev;\n\tdssdev->driver = &dvic_driver;\n\tdssdev->dev = &pdev->dev;\n\tdssdev->type = OMAP_DISPLAY_TYPE_DVI;\n\tdssdev->owner = THIS_MODULE;\n\tdssdev->panel.timings = dvic_default_timings;\n\n\tr = omapdss_register_display(dssdev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"Failed to register panel\\n\");\n\t\tgoto err_reg;\n\t}\n\n\treturn 0;\n\nerr_reg:\n\tomap_dss_put_device(ddata->in);\n\n\ti2c_put_adapter(ddata->i2c_adapter);\n\n\treturn r;\n}\n\nstatic int __exit dvic_remove(struct platform_device *pdev)\n{\n\tstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\n\tstruct omap_dss_device *dssdev = &ddata->dssdev;\n\tstruct omap_dss_device *in = ddata->in;\n\n\tomapdss_unregister_display(&ddata->dssdev);\n\n\tdvic_disable(dssdev);\n\tdvic_disconnect(dssdev);\n\n\tomap_dss_put_device(in);\n\n\ti2c_put_adapter(ddata->i2c_adapter);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id dvic_of_match[] = {\n\t{ .compatible = \"omapdss,dvi-connector\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, dvic_of_match);\n\nstatic struct platform_driver dvi_connector_driver = {\n\t.probe\t= dvic_probe,\n\t.remove\t= __exit_p(dvic_remove),\n\t.driver\t= {\n\t\t.name\t= \"connector-dvi\",\n\t\t.of_match_table = dvic_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nmodule_platform_driver(dvi_connector_driver);\n\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ti.com>\");\nMODULE_DESCRIPTION(\"Generic DVI Connector driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}