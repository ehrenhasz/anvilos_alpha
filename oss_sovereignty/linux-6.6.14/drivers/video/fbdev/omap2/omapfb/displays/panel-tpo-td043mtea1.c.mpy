{
  "module_name": "panel-tpo-td043mtea1.c",
  "hash_id": "bff14b139c0fd72bfd7e2360a5cd4736ae75ceb247ffa85bf9051786146eafaa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n\n#include <video/omapfb_dss.h>\n\n#define TPO_R02_MODE(x)\t\t((x) & 7)\n#define TPO_R02_MODE_800x480\t7\n#define TPO_R02_NCLK_RISING\tBIT(3)\n#define TPO_R02_HSYNC_HIGH\tBIT(4)\n#define TPO_R02_VSYNC_HIGH\tBIT(5)\n\n#define TPO_R03_NSTANDBY\tBIT(0)\n#define TPO_R03_EN_CP_CLK\tBIT(1)\n#define TPO_R03_EN_VGL_PUMP\tBIT(2)\n#define TPO_R03_EN_PWM\t\tBIT(3)\n#define TPO_R03_DRIVING_CAP_100\tBIT(4)\n#define TPO_R03_EN_PRE_CHARGE\tBIT(6)\n#define TPO_R03_SOFTWARE_CTL\tBIT(7)\n\n#define TPO_R04_NFLIP_H\t\tBIT(0)\n#define TPO_R04_NFLIP_V\t\tBIT(1)\n#define TPO_R04_CP_CLK_FREQ_1H\tBIT(2)\n#define TPO_R04_VGL_FREQ_1H\tBIT(4)\n\n#define TPO_R03_VAL_NORMAL (TPO_R03_NSTANDBY | TPO_R03_EN_CP_CLK | \\\n\t\t\tTPO_R03_EN_VGL_PUMP |  TPO_R03_EN_PWM | \\\n\t\t\tTPO_R03_DRIVING_CAP_100 | TPO_R03_EN_PRE_CHARGE | \\\n\t\t\tTPO_R03_SOFTWARE_CTL)\n\n#define TPO_R03_VAL_STANDBY (TPO_R03_DRIVING_CAP_100 | \\\n\t\t\tTPO_R03_EN_PRE_CHARGE | TPO_R03_SOFTWARE_CTL)\n\nstatic const u16 tpo_td043_def_gamma[12] = {\n\t105, 315, 381, 431, 490, 537, 579, 686, 780, 837, 880, 1023\n};\n\nstruct panel_drv_data {\n\tstruct omap_dss_device\tdssdev;\n\tstruct omap_dss_device *in;\n\n\tstruct omap_video_timings videomode;\n\n\tint data_lines;\n\n\tstruct spi_device *spi;\n\tstruct regulator *vcc_reg;\n\tstruct gpio_desc *reset_gpio;\n\tu16 gamma[12];\n\tu32 mode;\n\tu32 hmirror:1;\n\tu32 vmirror:1;\n\tu32 powered_on:1;\n\tu32 spi_suspended:1;\n\tu32 power_on_resume:1;\n};\n\nstatic const struct omap_video_timings tpo_td043_timings = {\n\t.x_res\t\t= 800,\n\t.y_res\t\t= 480,\n\n\t.pixelclock\t= 36000000,\n\n\t.hsw\t\t= 1,\n\t.hfp\t\t= 68,\n\t.hbp\t\t= 214,\n\n\t.vsw\t\t= 1,\n\t.vfp\t\t= 39,\n\t.vbp\t\t= 34,\n\n\t.vsync_level\t= OMAPDSS_SIG_ACTIVE_LOW,\n\t.hsync_level\t= OMAPDSS_SIG_ACTIVE_LOW,\n\t.data_pclk_edge\t= OMAPDSS_DRIVE_SIG_FALLING_EDGE,\n\t.de_level\t= OMAPDSS_SIG_ACTIVE_HIGH,\n\t.sync_pclk_edge\t= OMAPDSS_DRIVE_SIG_RISING_EDGE,\n};\n\n#define to_panel_data(p) container_of(p, struct panel_drv_data, dssdev)\n\nstatic int tpo_td043_write(struct spi_device *spi, u8 addr, u8 data)\n{\n\tstruct spi_message\tm;\n\tstruct spi_transfer\txfer;\n\tu16\t\t\tw;\n\tint\t\t\tr;\n\n\tspi_message_init(&m);\n\n\tmemset(&xfer, 0, sizeof(xfer));\n\n\tw = ((u16)addr << 10) | (1 << 8) | data;\n\txfer.tx_buf = &w;\n\txfer.bits_per_word = 16;\n\txfer.len = 2;\n\tspi_message_add_tail(&xfer, &m);\n\n\tr = spi_sync(spi, &m);\n\tif (r < 0)\n\t\tdev_warn(&spi->dev, \"failed to write to LCD reg (%d)\\n\", r);\n\treturn r;\n}\n\nstatic void tpo_td043_write_gamma(struct spi_device *spi, u16 gamma[12])\n{\n\tu8 i, val;\n\n\t \n\tfor (val = i = 0; i < 4; i++)\n\t\tval |= (gamma[i] & 0x300) >> ((i + 1) * 2);\n\ttpo_td043_write(spi, 0x11, val);\n\n\tfor (val = i = 0; i < 4; i++)\n\t\tval |= (gamma[i+4] & 0x300) >> ((i + 1) * 2);\n\ttpo_td043_write(spi, 0x12, val);\n\n\tfor (val = i = 0; i < 4; i++)\n\t\tval |= (gamma[i+8] & 0x300) >> ((i + 1) * 2);\n\ttpo_td043_write(spi, 0x13, val);\n\n\t \n\tfor (val = i = 0; i < 12; i++)\n\t\ttpo_td043_write(spi, 0x14 + i, gamma[i] & 0xff);\n}\n\nstatic int tpo_td043_write_mirror(struct spi_device *spi, bool h, bool v)\n{\n\tu8 reg4 = TPO_R04_NFLIP_H | TPO_R04_NFLIP_V |\n\t\tTPO_R04_CP_CLK_FREQ_1H | TPO_R04_VGL_FREQ_1H;\n\tif (h)\n\t\treg4 &= ~TPO_R04_NFLIP_H;\n\tif (v)\n\t\treg4 &= ~TPO_R04_NFLIP_V;\n\n\treturn tpo_td043_write(spi, 4, reg4);\n}\n\nstatic int tpo_td043_set_hmirror(struct omap_dss_device *dssdev, bool enable)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dssdev->dev);\n\n\tddata->hmirror = enable;\n\treturn tpo_td043_write_mirror(ddata->spi, ddata->hmirror,\n\t\t\tddata->vmirror);\n}\n\nstatic bool tpo_td043_get_hmirror(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dssdev->dev);\n\n\treturn ddata->hmirror;\n}\n\nstatic ssize_t tpo_td043_vmirror_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ddata->vmirror);\n}\n\nstatic ssize_t tpo_td043_vmirror_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tint val;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = !!val;\n\n\tret = tpo_td043_write_mirror(ddata->spi, ddata->hmirror, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tddata->vmirror = val;\n\n\treturn count;\n}\n\nstatic ssize_t tpo_td043_mode_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ddata->mode);\n}\n\nstatic ssize_t tpo_td043_mode_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tlong val;\n\tint ret;\n\n\tret = kstrtol(buf, 0, &val);\n\tif (ret != 0 || val & ~7)\n\t\treturn -EINVAL;\n\n\tddata->mode = val;\n\n\tval |= TPO_R02_NCLK_RISING;\n\ttpo_td043_write(ddata->spi, 2, val);\n\n\treturn count;\n}\n\nstatic ssize_t tpo_td043_gamma_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tssize_t len = 0;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ddata->gamma); i++) {\n\t\tret = snprintf(buf + len, PAGE_SIZE - len, \"%u \",\n\t\t\t\tddata->gamma[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tlen += ret;\n\t}\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t tpo_td043_gamma_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tunsigned int g[12];\n\tint ret;\n\tint i;\n\n\tret = sscanf(buf, \"%u %u %u %u %u %u %u %u %u %u %u %u\",\n\t\t\t&g[0], &g[1], &g[2], &g[3], &g[4], &g[5],\n\t\t\t&g[6], &g[7], &g[8], &g[9], &g[10], &g[11]);\n\n\tif (ret != 12)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 12; i++)\n\t\tddata->gamma[i] = g[i];\n\n\ttpo_td043_write_gamma(ddata->spi, ddata->gamma);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(vmirror, S_IRUGO | S_IWUSR,\n\t\ttpo_td043_vmirror_show, tpo_td043_vmirror_store);\nstatic DEVICE_ATTR(mode, S_IRUGO | S_IWUSR,\n\t\ttpo_td043_mode_show, tpo_td043_mode_store);\nstatic DEVICE_ATTR(gamma, S_IRUGO | S_IWUSR,\n\t\ttpo_td043_gamma_show, tpo_td043_gamma_store);\n\nstatic struct attribute *tpo_td043_attrs[] = {\n\t&dev_attr_vmirror.attr,\n\t&dev_attr_mode.attr,\n\t&dev_attr_gamma.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group tpo_td043_attr_group = {\n\t.attrs = tpo_td043_attrs,\n};\n\nstatic int tpo_td043_power_on(struct panel_drv_data *ddata)\n{\n\tint r;\n\n\tif (ddata->powered_on)\n\t\treturn 0;\n\n\tr = regulator_enable(ddata->vcc_reg);\n\tif (r != 0)\n\t\treturn r;\n\n\t \n\tmsleep(160);\n\n\tgpiod_set_value_cansleep(ddata->reset_gpio, 0);\n\n\ttpo_td043_write(ddata->spi, 2,\n\t\t\tTPO_R02_MODE(ddata->mode) | TPO_R02_NCLK_RISING);\n\ttpo_td043_write(ddata->spi, 3, TPO_R03_VAL_NORMAL);\n\ttpo_td043_write(ddata->spi, 0x20, 0xf0);\n\ttpo_td043_write(ddata->spi, 0x21, 0xf0);\n\ttpo_td043_write_mirror(ddata->spi, ddata->hmirror,\n\t\t\tddata->vmirror);\n\ttpo_td043_write_gamma(ddata->spi, ddata->gamma);\n\n\tddata->powered_on = 1;\n\treturn 0;\n}\n\nstatic void tpo_td043_power_off(struct panel_drv_data *ddata)\n{\n\tif (!ddata->powered_on)\n\t\treturn;\n\n\ttpo_td043_write(ddata->spi, 3,\n\t\t\tTPO_R03_VAL_STANDBY | TPO_R03_EN_PWM);\n\n\tgpiod_set_value_cansleep(ddata->reset_gpio, 1);\n\n\t \n\tmsleep(50);\n\n\ttpo_td043_write(ddata->spi, 3, TPO_R03_VAL_STANDBY);\n\n\tregulator_disable(ddata->vcc_reg);\n\n\tddata->powered_on = 0;\n}\n\nstatic int tpo_td043_connect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (omapdss_device_is_connected(dssdev))\n\t\treturn 0;\n\n\treturn in->ops.dpi->connect(in, dssdev);\n}\n\nstatic void tpo_td043_disconnect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (!omapdss_device_is_connected(dssdev))\n\t\treturn;\n\n\tin->ops.dpi->disconnect(in, dssdev);\n}\n\nstatic int tpo_td043_enable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tif (!omapdss_device_is_connected(dssdev))\n\t\treturn -ENODEV;\n\n\tif (omapdss_device_is_enabled(dssdev))\n\t\treturn 0;\n\n\tif (ddata->data_lines)\n\t\tin->ops.dpi->set_data_lines(in, ddata->data_lines);\n\tin->ops.dpi->set_timings(in, &ddata->videomode);\n\n\tr = in->ops.dpi->enable(in);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (!ddata->spi_suspended) {\n\t\tr = tpo_td043_power_on(ddata);\n\t\tif (r) {\n\t\t\tin->ops.dpi->disable(in);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tdssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\n\n\treturn 0;\n}\n\nstatic void tpo_td043_disable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (!omapdss_device_is_enabled(dssdev))\n\t\treturn;\n\n\tin->ops.dpi->disable(in);\n\n\tif (!ddata->spi_suspended)\n\t\ttpo_td043_power_off(ddata);\n\n\tdssdev->state = OMAP_DSS_DISPLAY_DISABLED;\n}\n\nstatic void tpo_td043_set_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tddata->videomode = *timings;\n\tdssdev->panel.timings = *timings;\n\n\tin->ops.dpi->set_timings(in, timings);\n}\n\nstatic void tpo_td043_get_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\n\t*timings = ddata->videomode;\n}\n\nstatic int tpo_td043_check_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\treturn in->ops.dpi->check_timings(in, timings);\n}\n\nstatic struct omap_dss_driver tpo_td043_ops = {\n\t.connect\t= tpo_td043_connect,\n\t.disconnect\t= tpo_td043_disconnect,\n\n\t.enable\t\t= tpo_td043_enable,\n\t.disable\t= tpo_td043_disable,\n\n\t.set_timings\t= tpo_td043_set_timings,\n\t.get_timings\t= tpo_td043_get_timings,\n\t.check_timings\t= tpo_td043_check_timings,\n\n\t.set_mirror\t= tpo_td043_set_hmirror,\n\t.get_mirror\t= tpo_td043_get_hmirror,\n\n\t.get_resolution\t= omapdss_default_get_resolution,\n};\n\nstatic int tpo_td043_probe(struct spi_device *spi)\n{\n\tstruct panel_drv_data *ddata;\n\tstruct omap_dss_device *dssdev;\n\tint r;\n\n\tdev_dbg(&spi->dev, \"%s\\n\", __func__);\n\n\tif (!spi->dev.of_node)\n\t\treturn -ENODEV;\n\n\tspi->bits_per_word = 16;\n\tspi->mode = SPI_MODE_0;\n\n\tr = spi_setup(spi);\n\tif (r < 0) {\n\t\tdev_err(&spi->dev, \"spi_setup failed: %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (ddata == NULL)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&spi->dev, ddata);\n\n\tddata->spi = spi;\n\n\tddata->in = omapdss_of_find_source_for_first_ep(spi->dev.of_node);\n\tr = PTR_ERR_OR_ZERO(ddata->in);\n\tif (r) {\n\t\tdev_err(&spi->dev, \"failed to find video source: %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tddata->mode = TPO_R02_MODE_800x480;\n\tmemcpy(ddata->gamma, tpo_td043_def_gamma, sizeof(ddata->gamma));\n\n\tddata->vcc_reg = devm_regulator_get(&spi->dev, \"vcc\");\n\tif (IS_ERR(ddata->vcc_reg)) {\n\t\tr = dev_err_probe(&spi->dev, PTR_ERR(ddata->vcc_reg),\n\t\t\t\t  \"failed to get LCD VCC regulator\\n\");\n\t\tgoto err_regulator;\n\t}\n\n\tddata->reset_gpio = devm_gpiod_get(&spi->dev, \"reset\", GPIOD_OUT_HIGH);\n\tr = PTR_ERR_OR_ZERO(ddata->reset_gpio);\n\tif (r) {\n\t\tdev_err(&spi->dev, \"couldn't request reset GPIO\\n\");\n\t\tgoto err_gpio_req;\n\t}\n\n\tgpiod_set_consumer_name(ddata->reset_gpio, \"lcd reset\");\n\n\tr = sysfs_create_group(&spi->dev.kobj, &tpo_td043_attr_group);\n\tif (r) {\n\t\tdev_err(&spi->dev, \"failed to create sysfs files\\n\");\n\t\tgoto err_sysfs;\n\t}\n\n\tddata->videomode = tpo_td043_timings;\n\n\tdssdev = &ddata->dssdev;\n\tdssdev->dev = &spi->dev;\n\tdssdev->driver = &tpo_td043_ops;\n\tdssdev->type = OMAP_DISPLAY_TYPE_DPI;\n\tdssdev->owner = THIS_MODULE;\n\tdssdev->panel.timings = ddata->videomode;\n\n\tr = omapdss_register_display(dssdev);\n\tif (r) {\n\t\tdev_err(&spi->dev, \"Failed to register panel\\n\");\n\t\tgoto err_reg;\n\t}\n\n\treturn 0;\n\nerr_reg:\n\tsysfs_remove_group(&spi->dev.kobj, &tpo_td043_attr_group);\nerr_sysfs:\nerr_gpio_req:\nerr_regulator:\n\tomap_dss_put_device(ddata->in);\n\treturn r;\n}\n\nstatic void tpo_td043_remove(struct spi_device *spi)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);\n\tstruct omap_dss_device *dssdev = &ddata->dssdev;\n\tstruct omap_dss_device *in = ddata->in;\n\n\tdev_dbg(&ddata->spi->dev, \"%s\\n\", __func__);\n\n\tomapdss_unregister_display(dssdev);\n\n\ttpo_td043_disable(dssdev);\n\ttpo_td043_disconnect(dssdev);\n\n\tomap_dss_put_device(in);\n\n\tsysfs_remove_group(&spi->dev.kobj, &tpo_td043_attr_group);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tpo_td043_spi_suspend(struct device *dev)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"tpo_td043_spi_suspend, tpo %p\\n\", ddata);\n\n\tddata->power_on_resume = ddata->powered_on;\n\ttpo_td043_power_off(ddata);\n\tddata->spi_suspended = 1;\n\n\treturn 0;\n}\n\nstatic int tpo_td043_spi_resume(struct device *dev)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(dev, \"tpo_td043_spi_resume\\n\");\n\n\tif (ddata->power_on_resume) {\n\t\tret = tpo_td043_power_on(ddata);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tddata->spi_suspended = 0;\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(tpo_td043_spi_pm,\n\ttpo_td043_spi_suspend, tpo_td043_spi_resume);\n\nstatic const struct of_device_id tpo_td043_of_match[] = {\n\t{ .compatible = \"omapdss,tpo,td043mtea1\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, tpo_td043_of_match);\n\nstatic struct spi_driver tpo_td043_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"panel-tpo-td043mtea1\",\n\t\t.pm\t= &tpo_td043_spi_pm,\n\t\t.of_match_table = tpo_td043_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t= tpo_td043_probe,\n\t.remove\t= tpo_td043_remove,\n};\n\nmodule_spi_driver(tpo_td043_spi_driver);\n\nMODULE_ALIAS(\"spi:tpo,td043mtea1\");\nMODULE_AUTHOR(\"Gra\u017evydas Ignotas <notasas@gmail.com>\");\nMODULE_DESCRIPTION(\"TPO TD043MTEA1 LCD Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}