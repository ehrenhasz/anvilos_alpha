{
  "module_name": "connector-analog-tv.c",
  "hash_id": "f132e3efe2883acbb485e9e405241fd0540cb25320eaa39c6dc1618a151e4567",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/displays/connector-analog-tv.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n\n#include <video/omapfb_dss.h>\n\nstruct panel_drv_data {\n\tstruct omap_dss_device dssdev;\n\tstruct omap_dss_device *in;\n\n\tstruct device *dev;\n\n\tstruct omap_video_timings timings;\n\n\tbool invert_polarity;\n};\n\nstatic const struct omap_video_timings tvc_pal_timings = {\n\t.x_res\t\t= 720,\n\t.y_res\t\t= 574,\n\t.pixelclock\t= 13500000,\n\t.hsw\t\t= 64,\n\t.hfp\t\t= 12,\n\t.hbp\t\t= 68,\n\t.vsw\t\t= 5,\n\t.vfp\t\t= 5,\n\t.vbp\t\t= 41,\n\n\t.interlace\t= true,\n};\n\nstatic const struct of_device_id tvc_of_match[];\n\n#define to_panel_data(x) container_of(x, struct panel_drv_data, dssdev)\n\nstatic int tvc_connect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tdev_dbg(ddata->dev, \"connect\\n\");\n\n\tif (omapdss_device_is_connected(dssdev))\n\t\treturn 0;\n\n\treturn in->ops.atv->connect(in, dssdev);\n}\n\nstatic void tvc_disconnect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tdev_dbg(ddata->dev, \"disconnect\\n\");\n\n\tif (!omapdss_device_is_connected(dssdev))\n\t\treturn;\n\n\tin->ops.atv->disconnect(in, dssdev);\n}\n\nstatic int tvc_enable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tdev_dbg(ddata->dev, \"enable\\n\");\n\n\tif (!omapdss_device_is_connected(dssdev))\n\t\treturn -ENODEV;\n\n\tif (omapdss_device_is_enabled(dssdev))\n\t\treturn 0;\n\n\tin->ops.atv->set_timings(in, &ddata->timings);\n\n\tif (!ddata->dev->of_node) {\n\t\tin->ops.atv->set_type(in, OMAP_DSS_VENC_TYPE_COMPOSITE);\n\n\t\tin->ops.atv->invert_vid_out_polarity(in,\n\t\t\tddata->invert_polarity);\n\t}\n\n\tr = in->ops.atv->enable(in);\n\tif (r)\n\t\treturn r;\n\n\tdssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\n\n\treturn r;\n}\n\nstatic void tvc_disable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tdev_dbg(ddata->dev, \"disable\\n\");\n\n\tif (!omapdss_device_is_enabled(dssdev))\n\t\treturn;\n\n\tin->ops.atv->disable(in);\n\n\tdssdev->state = OMAP_DSS_DISPLAY_DISABLED;\n}\n\nstatic void tvc_set_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tddata->timings = *timings;\n\tdssdev->panel.timings = *timings;\n\n\tin->ops.atv->set_timings(in, timings);\n}\n\nstatic void tvc_get_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\n\t*timings = ddata->timings;\n}\n\nstatic int tvc_check_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\treturn in->ops.atv->check_timings(in, timings);\n}\n\nstatic u32 tvc_get_wss(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\treturn in->ops.atv->get_wss(in);\n}\n\nstatic int tvc_set_wss(struct omap_dss_device *dssdev, u32 wss)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\treturn in->ops.atv->set_wss(in, wss);\n}\n\nstatic struct omap_dss_driver tvc_driver = {\n\t.connect\t\t= tvc_connect,\n\t.disconnect\t\t= tvc_disconnect,\n\n\t.enable\t\t\t= tvc_enable,\n\t.disable\t\t= tvc_disable,\n\n\t.set_timings\t\t= tvc_set_timings,\n\t.get_timings\t\t= tvc_get_timings,\n\t.check_timings\t\t= tvc_check_timings,\n\n\t.get_resolution\t\t= omapdss_default_get_resolution,\n\n\t.get_wss\t\t= tvc_get_wss,\n\t.set_wss\t\t= tvc_set_wss,\n};\n\nstatic int tvc_probe(struct platform_device *pdev)\n{\n\tstruct panel_drv_data *ddata;\n\tstruct omap_dss_device *dssdev;\n\tint r;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ddata);\n\tddata->dev = &pdev->dev;\n\n\tddata->in = omapdss_of_find_source_for_first_ep(pdev->dev.of_node);\n\tr = PTR_ERR_OR_ZERO(ddata->in);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"failed to find video source\\n\");\n\t\treturn r;\n\t}\n\n\tddata->timings = tvc_pal_timings;\n\n\tdssdev = &ddata->dssdev;\n\tdssdev->driver = &tvc_driver;\n\tdssdev->dev = &pdev->dev;\n\tdssdev->type = OMAP_DISPLAY_TYPE_VENC;\n\tdssdev->owner = THIS_MODULE;\n\tdssdev->panel.timings = tvc_pal_timings;\n\n\tr = omapdss_register_display(dssdev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"Failed to register panel\\n\");\n\t\tgoto err_reg;\n\t}\n\n\treturn 0;\nerr_reg:\n\tomap_dss_put_device(ddata->in);\n\treturn r;\n}\n\nstatic int __exit tvc_remove(struct platform_device *pdev)\n{\n\tstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\n\tstruct omap_dss_device *dssdev = &ddata->dssdev;\n\tstruct omap_dss_device *in = ddata->in;\n\n\tomapdss_unregister_display(&ddata->dssdev);\n\n\ttvc_disable(dssdev);\n\ttvc_disconnect(dssdev);\n\n\tomap_dss_put_device(in);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tvc_of_match[] = {\n\t{ .compatible = \"omapdss,svideo-connector\", },\n\t{ .compatible = \"omapdss,composite-video-connector\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, tvc_of_match);\n\nstatic struct platform_driver tvc_connector_driver = {\n\t.probe\t= tvc_probe,\n\t.remove\t= __exit_p(tvc_remove),\n\t.driver\t= {\n\t\t.name\t= \"connector-analog-tv\",\n\t\t.of_match_table = tvc_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nmodule_platform_driver(tvc_connector_driver);\n\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ti.com>\");\nMODULE_DESCRIPTION(\"Analog TV Connector driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}