{
  "module_name": "encoder-tpd12s015.c",
  "hash_id": "2e4500754ad065957af8da6e9d41982c61fd23191423c7f0d3db583b34cc0389",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/displays/encoder-tpd12s015.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n\n#include <video/omapfb_dss.h>\n\nstruct panel_drv_data {\n\tstruct omap_dss_device dssdev;\n\tstruct omap_dss_device *in;\n\n\tstruct gpio_desc *ct_cp_hpd_gpio;\n\tstruct gpio_desc *ls_oe_gpio;\n\tstruct gpio_desc *hpd_gpio;\n\n\tstruct omap_video_timings timings;\n};\n\n#define to_panel_data(x) container_of(x, struct panel_drv_data, dssdev)\n\nstatic int tpd_connect(struct omap_dss_device *dssdev,\n\t\tstruct omap_dss_device *dst)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tr = in->ops.hdmi->connect(in, dssdev);\n\tif (r)\n\t\treturn r;\n\n\tdst->src = dssdev;\n\tdssdev->dst = dst;\n\n\tif (ddata->ct_cp_hpd_gpio) {\n\t\tgpiod_set_value_cansleep(ddata->ct_cp_hpd_gpio, 1);\n\t\t \n\t\tudelay(300);\n\t}\n\n\treturn 0;\n}\n\nstatic void tpd_disconnect(struct omap_dss_device *dssdev,\n\t\tstruct omap_dss_device *dst)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tWARN_ON(dst != dssdev->dst);\n\n\tif (dst != dssdev->dst)\n\t\treturn;\n\n\tgpiod_set_value_cansleep(ddata->ct_cp_hpd_gpio, 0);\n\n\tdst->src = NULL;\n\tdssdev->dst = NULL;\n\n\tin->ops.hdmi->disconnect(in, &ddata->dssdev);\n}\n\nstatic int tpd_enable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tif (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)\n\t\treturn 0;\n\n\tin->ops.hdmi->set_timings(in, &ddata->timings);\n\n\tr = in->ops.hdmi->enable(in);\n\tif (r)\n\t\treturn r;\n\n\tdssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\n\n\treturn r;\n}\n\nstatic void tpd_disable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE)\n\t\treturn;\n\n\tin->ops.hdmi->disable(in);\n\n\tdssdev->state = OMAP_DSS_DISPLAY_DISABLED;\n}\n\nstatic void tpd_set_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tddata->timings = *timings;\n\tdssdev->panel.timings = *timings;\n\n\tin->ops.hdmi->set_timings(in, timings);\n}\n\nstatic void tpd_get_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\n\t*timings = ddata->timings;\n}\n\nstatic int tpd_check_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tr = in->ops.hdmi->check_timings(in, timings);\n\n\treturn r;\n}\n\nstatic int tpd_read_edid(struct omap_dss_device *dssdev,\n\t\tu8 *edid, int len)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tif (!gpiod_get_value_cansleep(ddata->hpd_gpio))\n\t\treturn -ENODEV;\n\n\tgpiod_set_value_cansleep(ddata->ls_oe_gpio, 1);\n\n\tr = in->ops.hdmi->read_edid(in, edid, len);\n\n\tgpiod_set_value_cansleep(ddata->ls_oe_gpio, 0);\n\n\treturn r;\n}\n\nstatic bool tpd_detect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\n\treturn gpiod_get_value_cansleep(ddata->hpd_gpio);\n}\n\nstatic int tpd_set_infoframe(struct omap_dss_device *dssdev,\n\t\tconst struct hdmi_avi_infoframe *avi)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\treturn in->ops.hdmi->set_infoframe(in, avi);\n}\n\nstatic int tpd_set_hdmi_mode(struct omap_dss_device *dssdev,\n\t\tbool hdmi_mode)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\treturn in->ops.hdmi->set_hdmi_mode(in, hdmi_mode);\n}\n\nstatic const struct omapdss_hdmi_ops tpd_hdmi_ops = {\n\t.connect\t\t= tpd_connect,\n\t.disconnect\t\t= tpd_disconnect,\n\n\t.enable\t\t\t= tpd_enable,\n\t.disable\t\t= tpd_disable,\n\n\t.check_timings\t\t= tpd_check_timings,\n\t.set_timings\t\t= tpd_set_timings,\n\t.get_timings\t\t= tpd_get_timings,\n\n\t.read_edid\t\t= tpd_read_edid,\n\t.detect\t\t\t= tpd_detect,\n\t.set_infoframe\t\t= tpd_set_infoframe,\n\t.set_hdmi_mode\t\t= tpd_set_hdmi_mode,\n};\n\nstatic int tpd_probe_of(struct platform_device *pdev)\n{\n\tstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct omap_dss_device *in;\n\n\tin = omapdss_of_find_source_for_first_ep(node);\n\tif (IS_ERR(in)) {\n\t\tdev_err(&pdev->dev, \"failed to find video source\\n\");\n\t\treturn PTR_ERR(in);\n\t}\n\n\tddata->in = in;\n\n\treturn 0;\n}\n\nstatic int tpd_probe(struct platform_device *pdev)\n{\n\tstruct omap_dss_device *dssdev;\n\tstruct panel_drv_data *ddata;\n\tint r;\n\tstruct gpio_desc *gpio;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ddata);\n\n\tif (pdev->dev.of_node) {\n\t\tr = tpd_probe_of(pdev);\n\t\tif (r)\n\t\t\treturn r;\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\tgpio = devm_gpiod_get_index_optional(&pdev->dev, NULL, 0,\n\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(gpio)) {\n\t\tr = PTR_ERR(gpio);\n\t\tgoto err_gpio;\n\t}\n\n\tddata->ct_cp_hpd_gpio = gpio;\n\n\tgpio = devm_gpiod_get_index_optional(&pdev->dev, NULL, 1,\n\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(gpio)) {\n\t\tr = PTR_ERR(gpio);\n\t\tgoto err_gpio;\n\t}\n\n\tddata->ls_oe_gpio = gpio;\n\n\tgpio = devm_gpiod_get_index(&pdev->dev, NULL, 2,\n\t\tGPIOD_IN);\n\tif (IS_ERR(gpio)) {\n\t\tr = PTR_ERR(gpio);\n\t\tgoto err_gpio;\n\t}\n\n\tddata->hpd_gpio = gpio;\n\n\tdssdev = &ddata->dssdev;\n\tdssdev->ops.hdmi = &tpd_hdmi_ops;\n\tdssdev->dev = &pdev->dev;\n\tdssdev->type = OMAP_DISPLAY_TYPE_HDMI;\n\tdssdev->output_type = OMAP_DISPLAY_TYPE_HDMI;\n\tdssdev->owner = THIS_MODULE;\n\tdssdev->port_num = 1;\n\n\tr = omapdss_register_output(dssdev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"Failed to register output\\n\");\n\t\tgoto err_reg;\n\t}\n\n\treturn 0;\nerr_reg:\nerr_gpio:\n\tomap_dss_put_device(ddata->in);\n\treturn r;\n}\n\nstatic int __exit tpd_remove(struct platform_device *pdev)\n{\n\tstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\n\tstruct omap_dss_device *dssdev = &ddata->dssdev;\n\tstruct omap_dss_device *in = ddata->in;\n\n\tomapdss_unregister_output(&ddata->dssdev);\n\n\tWARN_ON(omapdss_device_is_enabled(dssdev));\n\tif (omapdss_device_is_enabled(dssdev))\n\t\ttpd_disable(dssdev);\n\n\tWARN_ON(omapdss_device_is_connected(dssdev));\n\tif (omapdss_device_is_connected(dssdev))\n\t\ttpd_disconnect(dssdev, dssdev->dst);\n\n\tomap_dss_put_device(in);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tpd_of_match[] = {\n\t{ .compatible = \"omapdss,ti,tpd12s015\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, tpd_of_match);\n\nstatic struct platform_driver tpd_driver = {\n\t.probe\t= tpd_probe,\n\t.remove\t= __exit_p(tpd_remove),\n\t.driver\t= {\n\t\t.name\t= \"tpd12s015\",\n\t\t.of_match_table = tpd_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nmodule_platform_driver(tpd_driver);\n\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ti.com>\");\nMODULE_DESCRIPTION(\"TPD12S015 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}