{
  "module_name": "panel-sony-acx565akm.c",
  "hash_id": "ca3e810a71ca939a8d3684d363cebd3804c6e5e5b6c6fa2313f62303b6cbbb88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/spi/spi.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/backlight.h>\n#include <linux/fb.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n\n#include <video/omapfb_dss.h>\n\n#define MIPID_CMD_READ_DISP_ID\t\t0x04\n#define MIPID_CMD_READ_RED\t\t0x06\n#define MIPID_CMD_READ_GREEN\t\t0x07\n#define MIPID_CMD_READ_BLUE\t\t0x08\n#define MIPID_CMD_READ_DISP_STATUS\t0x09\n#define MIPID_CMD_RDDSDR\t\t0x0F\n#define MIPID_CMD_SLEEP_IN\t\t0x10\n#define MIPID_CMD_SLEEP_OUT\t\t0x11\n#define MIPID_CMD_DISP_OFF\t\t0x28\n#define MIPID_CMD_DISP_ON\t\t0x29\n#define MIPID_CMD_WRITE_DISP_BRIGHTNESS\t0x51\n#define MIPID_CMD_READ_DISP_BRIGHTNESS\t0x52\n#define MIPID_CMD_WRITE_CTRL_DISP\t0x53\n\n#define CTRL_DISP_BRIGHTNESS_CTRL_ON\t(1 << 5)\n#define CTRL_DISP_AMBIENT_LIGHT_CTRL_ON\t(1 << 4)\n#define CTRL_DISP_BACKLIGHT_ON\t\t(1 << 2)\n#define CTRL_DISP_AUTO_BRIGHTNESS_ON\t(1 << 1)\n\n#define MIPID_CMD_READ_CTRL_DISP\t0x54\n#define MIPID_CMD_WRITE_CABC\t\t0x55\n#define MIPID_CMD_READ_CABC\t\t0x56\n\n#define MIPID_VER_LPH8923\t\t3\n#define MIPID_VER_LS041Y3\t\t4\n#define MIPID_VER_L4F00311\t\t8\n#define MIPID_VER_ACX565AKM\t\t9\n\nstruct panel_drv_data {\n\tstruct omap_dss_device\tdssdev;\n\tstruct omap_dss_device *in;\n\n\tstruct gpio_desc *reset_gpio;\n\n\tint datapairs;\n\n\tstruct omap_video_timings videomode;\n\n\tchar\t\t*name;\n\tint\t\tenabled;\n\tint\t\tmodel;\n\tint\t\trevision;\n\tu8\t\tdisplay_id[3];\n\tunsigned\thas_bc:1;\n\tunsigned\thas_cabc:1;\n\tunsigned\tcabc_mode;\n\tunsigned long\thw_guard_end;\t\t \n\tunsigned long\thw_guard_wait;\t\t \n\n\tstruct spi_device\t*spi;\n\tstruct mutex\t\tmutex;\n\n\tstruct backlight_device *bl_dev;\n};\n\nstatic const struct omap_video_timings acx565akm_panel_timings = {\n\t.x_res\t\t= 800,\n\t.y_res\t\t= 480,\n\t.pixelclock\t= 24000000,\n\t.hfp\t\t= 28,\n\t.hsw\t\t= 4,\n\t.hbp\t\t= 24,\n\t.vfp\t\t= 3,\n\t.vsw\t\t= 3,\n\t.vbp\t\t= 4,\n\n\t.vsync_level\t= OMAPDSS_SIG_ACTIVE_LOW,\n\t.hsync_level\t= OMAPDSS_SIG_ACTIVE_LOW,\n\n\t.data_pclk_edge\t= OMAPDSS_DRIVE_SIG_RISING_EDGE,\n\t.de_level\t= OMAPDSS_SIG_ACTIVE_HIGH,\n\t.sync_pclk_edge\t= OMAPDSS_DRIVE_SIG_FALLING_EDGE,\n};\n\n#define to_panel_data(p) container_of(p, struct panel_drv_data, dssdev)\n\nstatic void acx565akm_transfer(struct panel_drv_data *ddata, int cmd,\n\t\t\t      const u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct spi_message\tm;\n\tstruct spi_transfer\t*x, xfer[5];\n\tint\t\t\tr;\n\n\tBUG_ON(ddata->spi == NULL);\n\n\tspi_message_init(&m);\n\n\tmemset(xfer, 0, sizeof(xfer));\n\tx = &xfer[0];\n\n\tcmd &=  0xff;\n\tx->tx_buf = &cmd;\n\tx->bits_per_word = 9;\n\tx->len = 2;\n\n\tif (rlen > 1 && wlen == 0) {\n\t\t \n\t\tx->bits_per_word = 10;\n\t\tcmd <<= 1;\n\t}\n\tspi_message_add_tail(x, &m);\n\n\tif (wlen) {\n\t\tx++;\n\t\tx->tx_buf = wbuf;\n\t\tx->len = wlen;\n\t\tx->bits_per_word = 9;\n\t\tspi_message_add_tail(x, &m);\n\t}\n\n\tif (rlen) {\n\t\tx++;\n\t\tx->rx_buf\t= rbuf;\n\t\tx->len\t\t= rlen;\n\t\tspi_message_add_tail(x, &m);\n\t}\n\n\tr = spi_sync(ddata->spi, &m);\n\tif (r < 0)\n\t\tdev_dbg(&ddata->spi->dev, \"spi_sync %d\\n\", r);\n}\n\nstatic inline void acx565akm_cmd(struct panel_drv_data *ddata, int cmd)\n{\n\tacx565akm_transfer(ddata, cmd, NULL, 0, NULL, 0);\n}\n\nstatic inline void acx565akm_write(struct panel_drv_data *ddata,\n\t\t\t       int reg, const u8 *buf, int len)\n{\n\tacx565akm_transfer(ddata, reg, buf, len, NULL, 0);\n}\n\nstatic inline void acx565akm_read(struct panel_drv_data *ddata,\n\t\t\t      int reg, u8 *buf, int len)\n{\n\tacx565akm_transfer(ddata, reg, NULL, 0, buf, len);\n}\n\nstatic void hw_guard_start(struct panel_drv_data *ddata, int guard_msec)\n{\n\tddata->hw_guard_wait = msecs_to_jiffies(guard_msec);\n\tddata->hw_guard_end = jiffies + ddata->hw_guard_wait;\n}\n\nstatic void hw_guard_wait(struct panel_drv_data *ddata)\n{\n\tunsigned long wait = ddata->hw_guard_end - jiffies;\n\n\tif ((long)wait > 0 && wait <= ddata->hw_guard_wait) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(wait);\n\t}\n}\n\nstatic void set_sleep_mode(struct panel_drv_data *ddata, int on)\n{\n\tint cmd;\n\n\tif (on)\n\t\tcmd = MIPID_CMD_SLEEP_IN;\n\telse\n\t\tcmd = MIPID_CMD_SLEEP_OUT;\n\t \n\thw_guard_wait(ddata);\n\tacx565akm_cmd(ddata, cmd);\n\thw_guard_start(ddata, 120);\n}\n\nstatic void set_display_state(struct panel_drv_data *ddata, int enabled)\n{\n\tint cmd = enabled ? MIPID_CMD_DISP_ON : MIPID_CMD_DISP_OFF;\n\n\tacx565akm_cmd(ddata, cmd);\n}\n\nstatic int panel_enabled(struct panel_drv_data *ddata)\n{\n\tu32 disp_status;\n\tint enabled;\n\n\tacx565akm_read(ddata, MIPID_CMD_READ_DISP_STATUS,\n\t\t\t(u8 *)&disp_status, 4);\n\tdisp_status = __be32_to_cpu(disp_status);\n\tenabled = (disp_status & (1 << 17)) && (disp_status & (1 << 10));\n\tdev_dbg(&ddata->spi->dev,\n\t\t\"LCD panel %senabled by bootloader (status 0x%04x)\\n\",\n\t\tenabled ? \"\" : \"not \", disp_status);\n\treturn enabled;\n}\n\nstatic int panel_detect(struct panel_drv_data *ddata)\n{\n\tacx565akm_read(ddata, MIPID_CMD_READ_DISP_ID, ddata->display_id, 3);\n\tdev_dbg(&ddata->spi->dev, \"MIPI display ID: %02x%02x%02x\\n\",\n\t\tddata->display_id[0],\n\t\tddata->display_id[1],\n\t\tddata->display_id[2]);\n\n\tswitch (ddata->display_id[0]) {\n\tcase 0x10:\n\t\tddata->model = MIPID_VER_ACX565AKM;\n\t\tddata->name = \"acx565akm\";\n\t\tddata->has_bc = 1;\n\t\tddata->has_cabc = 1;\n\t\tbreak;\n\tcase 0x29:\n\t\tddata->model = MIPID_VER_L4F00311;\n\t\tddata->name = \"l4f00311\";\n\t\tbreak;\n\tcase 0x45:\n\t\tddata->model = MIPID_VER_LPH8923;\n\t\tddata->name = \"lph8923\";\n\t\tbreak;\n\tcase 0x83:\n\t\tddata->model = MIPID_VER_LS041Y3;\n\t\tddata->name = \"ls041y3\";\n\t\tbreak;\n\tdefault:\n\t\tddata->name = \"unknown\";\n\t\tdev_err(&ddata->spi->dev, \"invalid display ID\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tddata->revision = ddata->display_id[1];\n\n\tdev_info(&ddata->spi->dev, \"omapfb: %s rev %02x LCD detected\\n\",\n\t\t\tddata->name, ddata->revision);\n\n\treturn 0;\n}\n\n \n\nstatic void enable_backlight_ctrl(struct panel_drv_data *ddata, int enable)\n{\n\tu16 ctrl;\n\n\tacx565akm_read(ddata, MIPID_CMD_READ_CTRL_DISP, (u8 *)&ctrl, 1);\n\tif (enable) {\n\t\tctrl |= CTRL_DISP_BRIGHTNESS_CTRL_ON |\n\t\t\tCTRL_DISP_BACKLIGHT_ON;\n\t} else {\n\t\tctrl &= ~(CTRL_DISP_BRIGHTNESS_CTRL_ON |\n\t\t\t  CTRL_DISP_BACKLIGHT_ON);\n\t}\n\n\tctrl |= 1 << 8;\n\tacx565akm_write(ddata, MIPID_CMD_WRITE_CTRL_DISP, (u8 *)&ctrl, 2);\n}\n\nstatic void set_cabc_mode(struct panel_drv_data *ddata, unsigned mode)\n{\n\tu16 cabc_ctrl;\n\n\tddata->cabc_mode = mode;\n\tif (!ddata->enabled)\n\t\treturn;\n\tcabc_ctrl = 0;\n\tacx565akm_read(ddata, MIPID_CMD_READ_CABC, (u8 *)&cabc_ctrl, 1);\n\tcabc_ctrl &= ~3;\n\tcabc_ctrl |= (1 << 8) | (mode & 3);\n\tacx565akm_write(ddata, MIPID_CMD_WRITE_CABC, (u8 *)&cabc_ctrl, 2);\n}\n\nstatic unsigned get_cabc_mode(struct panel_drv_data *ddata)\n{\n\treturn ddata->cabc_mode;\n}\n\nstatic unsigned get_hw_cabc_mode(struct panel_drv_data *ddata)\n{\n\tu8 cabc_ctrl;\n\n\tacx565akm_read(ddata, MIPID_CMD_READ_CABC, &cabc_ctrl, 1);\n\treturn cabc_ctrl & 3;\n}\n\nstatic void acx565akm_set_brightness(struct panel_drv_data *ddata, int level)\n{\n\tint bv;\n\n\tbv = level | (1 << 8);\n\tacx565akm_write(ddata, MIPID_CMD_WRITE_DISP_BRIGHTNESS, (u8 *)&bv, 2);\n\n\tif (level)\n\t\tenable_backlight_ctrl(ddata, 1);\n\telse\n\t\tenable_backlight_ctrl(ddata, 0);\n}\n\nstatic int acx565akm_get_actual_brightness(struct panel_drv_data *ddata)\n{\n\tu8 bv;\n\n\tacx565akm_read(ddata, MIPID_CMD_READ_DISP_BRIGHTNESS, &bv, 1);\n\n\treturn bv;\n}\n\n\nstatic int acx565akm_bl_update_status(struct backlight_device *dev)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);\n\tint level;\n\n\tdev_dbg(&ddata->spi->dev, \"%s\\n\", __func__);\n\n\tif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\n\t\t\tdev->props.power == FB_BLANK_UNBLANK)\n\t\tlevel = dev->props.brightness;\n\telse\n\t\tlevel = 0;\n\n\tif (ddata->has_bc)\n\t\tacx565akm_set_brightness(ddata, level);\n\telse\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int acx565akm_bl_get_intensity(struct backlight_device *dev)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);\n\n\tdev_dbg(&dev->dev, \"%s\\n\", __func__);\n\n\tif (!ddata->has_bc)\n\t\treturn -ENODEV;\n\n\tif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\n\t\t\tdev->props.power == FB_BLANK_UNBLANK) {\n\t\tif (ddata->has_bc)\n\t\t\treturn acx565akm_get_actual_brightness(ddata);\n\t\telse\n\t\t\treturn dev->props.brightness;\n\t}\n\n\treturn 0;\n}\n\nstatic int acx565akm_bl_update_status_locked(struct backlight_device *dev)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);\n\tint r;\n\n\tmutex_lock(&ddata->mutex);\n\tr = acx565akm_bl_update_status(dev);\n\tmutex_unlock(&ddata->mutex);\n\n\treturn r;\n}\n\nstatic int acx565akm_bl_get_intensity_locked(struct backlight_device *dev)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);\n\tint r;\n\n\tmutex_lock(&ddata->mutex);\n\tr = acx565akm_bl_get_intensity(dev);\n\tmutex_unlock(&ddata->mutex);\n\n\treturn r;\n}\n\nstatic const struct backlight_ops acx565akm_bl_ops = {\n\t.get_brightness = acx565akm_bl_get_intensity_locked,\n\t.update_status  = acx565akm_bl_update_status_locked,\n};\n\n \n\nstatic const char * const cabc_modes[] = {\n\t\"off\",\t\t \n\t\"ui\",\n\t\"still-image\",\n\t\"moving-image\",\n};\n\nstatic ssize_t show_cabc_mode(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tconst char *mode_str;\n\tint mode;\n\tint len;\n\n\tif (!ddata->has_cabc)\n\t\tmode = 0;\n\telse\n\t\tmode = get_cabc_mode(ddata);\n\tmode_str = \"unknown\";\n\tif (mode >= 0 && mode < ARRAY_SIZE(cabc_modes))\n\t\tmode_str = cabc_modes[mode];\n\tlen = snprintf(buf, PAGE_SIZE, \"%s\\n\", mode_str);\n\n\treturn len < PAGE_SIZE - 1 ? len : PAGE_SIZE - 1;\n}\n\nstatic ssize_t store_cabc_mode(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cabc_modes); i++) {\n\t\tconst char *mode_str = cabc_modes[i];\n\t\tint cmp_len = strlen(mode_str);\n\n\t\tif (count > 0 && buf[count - 1] == '\\n')\n\t\t\tcount--;\n\t\tif (count != cmp_len)\n\t\t\tcontinue;\n\n\t\tif (strncmp(buf, mode_str, cmp_len) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(cabc_modes))\n\t\treturn -EINVAL;\n\n\tif (!ddata->has_cabc && i != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ddata->mutex);\n\tset_cabc_mode(ddata, i);\n\tmutex_unlock(&ddata->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t show_cabc_available_modes(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tint len;\n\tint i;\n\n\tif (!ddata->has_cabc)\n\t\treturn sysfs_emit(buf, \"%s\\n\", cabc_modes[0]);\n\n\tfor (i = 0, len = 0;\n\t     len < PAGE_SIZE && i < ARRAY_SIZE(cabc_modes); i++)\n\t\tlen += snprintf(&buf[len], PAGE_SIZE - len, \"%s%s%s\",\n\t\t\ti ? \" \" : \"\", cabc_modes[i],\n\t\t\ti == ARRAY_SIZE(cabc_modes) - 1 ? \"\\n\" : \"\");\n\n\treturn len < PAGE_SIZE ? len : PAGE_SIZE - 1;\n}\n\nstatic DEVICE_ATTR(cabc_mode, S_IRUGO | S_IWUSR,\n\t\tshow_cabc_mode, store_cabc_mode);\nstatic DEVICE_ATTR(cabc_available_modes, S_IRUGO,\n\t\tshow_cabc_available_modes, NULL);\n\nstatic struct attribute *bldev_attrs[] = {\n\t&dev_attr_cabc_mode.attr,\n\t&dev_attr_cabc_available_modes.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group bldev_attr_group = {\n\t.attrs = bldev_attrs,\n};\n\nstatic int acx565akm_connect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (omapdss_device_is_connected(dssdev))\n\t\treturn 0;\n\n\treturn in->ops.sdi->connect(in, dssdev);\n}\n\nstatic void acx565akm_disconnect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (!omapdss_device_is_connected(dssdev))\n\t\treturn;\n\n\tin->ops.sdi->disconnect(in, dssdev);\n}\n\nstatic int acx565akm_panel_power_on(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tdev_dbg(&ddata->spi->dev, \"%s\\n\", __func__);\n\n\tin->ops.sdi->set_timings(in, &ddata->videomode);\n\n\tif (ddata->datapairs > 0)\n\t\tin->ops.sdi->set_datapairs(in, ddata->datapairs);\n\n\tr = in->ops.sdi->enable(in);\n\tif (r) {\n\t\tpr_err(\"%s sdi enable failed\\n\", __func__);\n\t\treturn r;\n\t}\n\n\t \n\tmsleep(50);\n\n\t \n\tif (ddata->reset_gpio)\n\t\tgpiod_set_value_cansleep(ddata->reset_gpio, 1);\n\n\tif (ddata->enabled) {\n\t\tdev_dbg(&ddata->spi->dev, \"panel already enabled\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tmsleep(120);\n\n\tset_sleep_mode(ddata, 0);\n\tddata->enabled = 1;\n\n\t \n\tusleep_range(5000, 10000);\n\tset_display_state(ddata, 1);\n\tset_cabc_mode(ddata, ddata->cabc_mode);\n\n\treturn acx565akm_bl_update_status(ddata->bl_dev);\n}\n\nstatic void acx565akm_panel_power_off(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tdev_dbg(dssdev->dev, \"%s\\n\", __func__);\n\n\tif (!ddata->enabled)\n\t\treturn;\n\n\tset_display_state(ddata, 0);\n\tset_sleep_mode(ddata, 1);\n\tddata->enabled = 0;\n\t \n\tmsleep(50);\n\n\t \n\tif (ddata->reset_gpio)\n\t\tgpiod_set_value_cansleep(ddata->reset_gpio, 0);\n\n\t \n\tmsleep(100);\n\n\tin->ops.sdi->disable(in);\n}\n\nstatic int acx565akm_enable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tint r;\n\n\tdev_dbg(dssdev->dev, \"%s\\n\", __func__);\n\n\tif (!omapdss_device_is_connected(dssdev))\n\t\treturn -ENODEV;\n\n\tif (omapdss_device_is_enabled(dssdev))\n\t\treturn 0;\n\n\tmutex_lock(&ddata->mutex);\n\tr = acx565akm_panel_power_on(dssdev);\n\tmutex_unlock(&ddata->mutex);\n\tif (r)\n\t\treturn r;\n\n\tdssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\n\n\treturn 0;\n}\n\nstatic void acx565akm_disable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\n\tdev_dbg(dssdev->dev, \"%s\\n\", __func__);\n\n\tif (!omapdss_device_is_enabled(dssdev))\n\t\treturn;\n\n\tmutex_lock(&ddata->mutex);\n\tacx565akm_panel_power_off(dssdev);\n\tmutex_unlock(&ddata->mutex);\n\n\tdssdev->state = OMAP_DSS_DISPLAY_DISABLED;\n}\n\nstatic void acx565akm_set_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tddata->videomode = *timings;\n\tdssdev->panel.timings = *timings;\n\n\tin->ops.sdi->set_timings(in, timings);\n}\n\nstatic void acx565akm_get_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\n\t*timings = ddata->videomode;\n}\n\nstatic int acx565akm_check_timings(struct omap_dss_device *dssdev,\n\t\tstruct omap_video_timings *timings)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\treturn in->ops.sdi->check_timings(in, timings);\n}\n\nstatic struct omap_dss_driver acx565akm_ops = {\n\t.connect\t= acx565akm_connect,\n\t.disconnect\t= acx565akm_disconnect,\n\n\t.enable\t\t= acx565akm_enable,\n\t.disable\t= acx565akm_disable,\n\n\t.set_timings\t= acx565akm_set_timings,\n\t.get_timings\t= acx565akm_get_timings,\n\t.check_timings\t= acx565akm_check_timings,\n\n\t.get_resolution\t= omapdss_default_get_resolution,\n};\n\nstatic int acx565akm_probe(struct spi_device *spi)\n{\n\tstruct panel_drv_data *ddata;\n\tstruct omap_dss_device *dssdev;\n\tstruct backlight_device *bldev;\n\tint max_brightness, brightness;\n\tstruct backlight_properties props;\n\tint r;\n\n\tdev_dbg(&spi->dev, \"%s\\n\", __func__);\n\n\tif (!spi->dev.of_node)\n\t\treturn -ENODEV;\n\n\tspi->mode = SPI_MODE_3;\n\n\tddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (ddata == NULL)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&spi->dev, ddata);\n\n\tddata->spi = spi;\n\n\tmutex_init(&ddata->mutex);\n\n\tddata->in = omapdss_of_find_source_for_first_ep(spi->dev.of_node);\n\tr = PTR_ERR_OR_ZERO(ddata->in);\n\tif (r) {\n\t\tdev_err(&spi->dev, \"failed to find video source\\n\");\n\t\treturn r;\n\t}\n\n\tddata->reset_gpio = devm_gpiod_get_optional(&spi->dev, \"reset\",\n\t\t\t\t\t\t    GPIOD_OUT_LOW);\n\tr = PTR_ERR_OR_ZERO(ddata->reset_gpio);\n\tif (r)\n\t\tgoto err_gpio;\n\n\tif (ddata->reset_gpio) {\n\t\tgpiod_set_consumer_name(ddata->reset_gpio, \"lcd reset\");\n\n\t\t \n\t\tgpiod_set_value_cansleep(ddata->reset_gpio, 1);\n\t}\n\n\t \n\tusleep_range(5000, 10000);\n\n\tddata->enabled = panel_enabled(ddata);\n\n\tr = panel_detect(ddata);\n\n\tif (!ddata->enabled && ddata->reset_gpio)\n\t\tgpiod_set_value_cansleep(ddata->reset_gpio, 0);\n\n\tif (r) {\n\t\tdev_err(&spi->dev, \"%s panel detect error\\n\", __func__);\n\t\tgoto err_detect;\n\t}\n\n\tmemset(&props, 0, sizeof(props));\n\tprops.fb_blank = FB_BLANK_UNBLANK;\n\tprops.power = FB_BLANK_UNBLANK;\n\tprops.type = BACKLIGHT_RAW;\n\n\tbldev = backlight_device_register(\"acx565akm\", &ddata->spi->dev,\n\t\t\tddata, &acx565akm_bl_ops, &props);\n\tif (IS_ERR(bldev)) {\n\t\tr = PTR_ERR(bldev);\n\t\tgoto err_reg_bl;\n\t}\n\tddata->bl_dev = bldev;\n\tif (ddata->has_cabc) {\n\t\tr = sysfs_create_group(&bldev->dev.kobj, &bldev_attr_group);\n\t\tif (r) {\n\t\t\tdev_err(&bldev->dev,\n\t\t\t\t\"%s failed to create sysfs files\\n\", __func__);\n\t\t\tgoto err_sysfs;\n\t\t}\n\t\tddata->cabc_mode = get_hw_cabc_mode(ddata);\n\t}\n\n\tmax_brightness = 255;\n\n\tif (ddata->has_bc)\n\t\tbrightness = acx565akm_get_actual_brightness(ddata);\n\telse\n\t\tbrightness = 0;\n\n\tbldev->props.max_brightness = max_brightness;\n\tbldev->props.brightness = brightness;\n\n\tacx565akm_bl_update_status(bldev);\n\n\n\tddata->videomode = acx565akm_panel_timings;\n\n\tdssdev = &ddata->dssdev;\n\tdssdev->dev = &spi->dev;\n\tdssdev->driver = &acx565akm_ops;\n\tdssdev->type = OMAP_DISPLAY_TYPE_SDI;\n\tdssdev->owner = THIS_MODULE;\n\tdssdev->panel.timings = ddata->videomode;\n\n\tr = omapdss_register_display(dssdev);\n\tif (r) {\n\t\tdev_err(&spi->dev, \"Failed to register panel\\n\");\n\t\tgoto err_reg;\n\t}\n\n\treturn 0;\n\nerr_reg:\n\tsysfs_remove_group(&bldev->dev.kobj, &bldev_attr_group);\nerr_sysfs:\n\tbacklight_device_unregister(bldev);\nerr_reg_bl:\nerr_detect:\nerr_gpio:\n\tomap_dss_put_device(ddata->in);\n\treturn r;\n}\n\nstatic void acx565akm_remove(struct spi_device *spi)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);\n\tstruct omap_dss_device *dssdev = &ddata->dssdev;\n\tstruct omap_dss_device *in = ddata->in;\n\n\tdev_dbg(&ddata->spi->dev, \"%s\\n\", __func__);\n\n\tsysfs_remove_group(&ddata->bl_dev->dev.kobj, &bldev_attr_group);\n\tbacklight_device_unregister(ddata->bl_dev);\n\n\tomapdss_unregister_display(dssdev);\n\n\tacx565akm_disable(dssdev);\n\tacx565akm_disconnect(dssdev);\n\n\tomap_dss_put_device(in);\n}\n\nstatic const struct of_device_id acx565akm_of_match[] = {\n\t{ .compatible = \"omapdss,sony,acx565akm\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, acx565akm_of_match);\n\nstatic struct spi_driver acx565akm_driver = {\n\t.driver = {\n\t\t.name\t= \"acx565akm\",\n\t\t.of_match_table = acx565akm_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t= acx565akm_probe,\n\t.remove\t= acx565akm_remove,\n};\n\nmodule_spi_driver(acx565akm_driver);\n\nMODULE_AUTHOR(\"Nokia Corporation\");\nMODULE_DESCRIPTION(\"acx565akm LCD Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}