{
  "module_name": "panel-dsi-cm.c",
  "hash_id": "aa6a8382be0f5d008422dbce3570fad790b9a29d318a8d1a98632c5cb147eac1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/omap2/omapfb/displays/panel-dsi-cm.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/fb.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include <video/omapfb_dss.h>\n#include <video/mipi_display.h>\n\n \n#define TCH 0\n\n#define DCS_READ_NUM_ERRORS\t0x05\n#define DCS_BRIGHTNESS\t\t0x51\n#define DCS_CTRL_DISPLAY\t0x53\n#define DCS_GET_ID1\t\t0xda\n#define DCS_GET_ID2\t\t0xdb\n#define DCS_GET_ID3\t\t0xdc\n\nstruct panel_drv_data {\n\tstruct omap_dss_device dssdev;\n\tstruct omap_dss_device *in;\n\n\tstruct omap_video_timings timings;\n\n\tstruct platform_device *pdev;\n\n\tstruct mutex lock;\n\n\tstruct backlight_device *bldev;\n\n\tunsigned long\thw_guard_end;\t \n\tunsigned long\thw_guard_wait;\t \n\n\t \n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *ext_te_gpio;\n\n\tbool use_dsi_backlight;\n\n\tstruct omap_dsi_pin_config pin_config;\n\n\t \n\tbool enabled;\n\n\tbool te_enabled;\n\n\tatomic_t do_update;\n\tint channel;\n\n\tstruct delayed_work te_timeout_work;\n\n\tbool intro_printed;\n\n\tbool ulps_enabled;\n\tunsigned ulps_timeout;\n\tstruct delayed_work ulps_work;\n};\n\n#define to_panel_data(p) container_of(p, struct panel_drv_data, dssdev)\n\nstatic irqreturn_t dsicm_te_isr(int irq, void *data);\nstatic void dsicm_te_timeout_work_callback(struct work_struct *work);\nstatic int _dsicm_enable_te(struct panel_drv_data *ddata, bool enable);\n\nstatic int dsicm_panel_reset(struct panel_drv_data *ddata);\n\nstatic void dsicm_ulps_work(struct work_struct *work);\n\nstatic void hw_guard_start(struct panel_drv_data *ddata, int guard_msec)\n{\n\tddata->hw_guard_wait = msecs_to_jiffies(guard_msec);\n\tddata->hw_guard_end = jiffies + ddata->hw_guard_wait;\n}\n\nstatic void hw_guard_wait(struct panel_drv_data *ddata)\n{\n\tunsigned long wait = ddata->hw_guard_end - jiffies;\n\n\tif ((long)wait > 0 && time_before_eq(wait, ddata->hw_guard_wait)) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(wait);\n\t}\n}\n\nstatic int dsicm_dcs_read_1(struct panel_drv_data *ddata, u8 dcs_cmd, u8 *data)\n{\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\tu8 buf[1];\n\n\tr = in->ops.dsi->dcs_read(in, ddata->channel, dcs_cmd, buf, 1);\n\n\tif (r < 0)\n\t\treturn r;\n\n\t*data = buf[0];\n\n\treturn 0;\n}\n\nstatic int dsicm_dcs_write_0(struct panel_drv_data *ddata, u8 dcs_cmd)\n{\n\tstruct omap_dss_device *in = ddata->in;\n\treturn in->ops.dsi->dcs_write(in, ddata->channel, &dcs_cmd, 1);\n}\n\nstatic int dsicm_dcs_write_1(struct panel_drv_data *ddata, u8 dcs_cmd, u8 param)\n{\n\tstruct omap_dss_device *in = ddata->in;\n\tu8 buf[2] = { dcs_cmd, param };\n\n\treturn in->ops.dsi->dcs_write(in, ddata->channel, buf, 2);\n}\n\nstatic int dsicm_sleep_in(struct panel_drv_data *ddata)\n\n{\n\tstruct omap_dss_device *in = ddata->in;\n\tu8 cmd;\n\tint r;\n\n\thw_guard_wait(ddata);\n\n\tcmd = MIPI_DCS_ENTER_SLEEP_MODE;\n\tr = in->ops.dsi->dcs_write_nosync(in, ddata->channel, &cmd, 1);\n\tif (r)\n\t\treturn r;\n\n\thw_guard_start(ddata, 120);\n\n\tusleep_range(5000, 10000);\n\n\treturn 0;\n}\n\nstatic int dsicm_sleep_out(struct panel_drv_data *ddata)\n{\n\tint r;\n\n\thw_guard_wait(ddata);\n\n\tr = dsicm_dcs_write_0(ddata, MIPI_DCS_EXIT_SLEEP_MODE);\n\tif (r)\n\t\treturn r;\n\n\thw_guard_start(ddata, 120);\n\n\tusleep_range(5000, 10000);\n\n\treturn 0;\n}\n\nstatic int dsicm_get_id(struct panel_drv_data *ddata, u8 *id1, u8 *id2, u8 *id3)\n{\n\tint r;\n\n\tr = dsicm_dcs_read_1(ddata, DCS_GET_ID1, id1);\n\tif (r)\n\t\treturn r;\n\tr = dsicm_dcs_read_1(ddata, DCS_GET_ID2, id2);\n\tif (r)\n\t\treturn r;\n\tr = dsicm_dcs_read_1(ddata, DCS_GET_ID3, id3);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int dsicm_set_update_window(struct panel_drv_data *ddata,\n\t\tu16 x, u16 y, u16 w, u16 h)\n{\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\tu16 x1 = x;\n\tu16 x2 = x + w - 1;\n\tu16 y1 = y;\n\tu16 y2 = y + h - 1;\n\n\tu8 buf[5];\n\tbuf[0] = MIPI_DCS_SET_COLUMN_ADDRESS;\n\tbuf[1] = (x1 >> 8) & 0xff;\n\tbuf[2] = (x1 >> 0) & 0xff;\n\tbuf[3] = (x2 >> 8) & 0xff;\n\tbuf[4] = (x2 >> 0) & 0xff;\n\n\tr = in->ops.dsi->dcs_write_nosync(in, ddata->channel, buf, sizeof(buf));\n\tif (r)\n\t\treturn r;\n\n\tbuf[0] = MIPI_DCS_SET_PAGE_ADDRESS;\n\tbuf[1] = (y1 >> 8) & 0xff;\n\tbuf[2] = (y1 >> 0) & 0xff;\n\tbuf[3] = (y2 >> 8) & 0xff;\n\tbuf[4] = (y2 >> 0) & 0xff;\n\n\tr = in->ops.dsi->dcs_write_nosync(in, ddata->channel, buf, sizeof(buf));\n\tif (r)\n\t\treturn r;\n\n\tin->ops.dsi->bta_sync(in, ddata->channel);\n\n\treturn r;\n}\n\nstatic void dsicm_queue_ulps_work(struct panel_drv_data *ddata)\n{\n\tif (ddata->ulps_timeout > 0)\n\t\tschedule_delayed_work(&ddata->ulps_work,\n\t\t\t\tmsecs_to_jiffies(ddata->ulps_timeout));\n}\n\nstatic void dsicm_cancel_ulps_work(struct panel_drv_data *ddata)\n{\n\tcancel_delayed_work(&ddata->ulps_work);\n}\n\nstatic int dsicm_enter_ulps(struct panel_drv_data *ddata)\n{\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tif (ddata->ulps_enabled)\n\t\treturn 0;\n\n\tdsicm_cancel_ulps_work(ddata);\n\n\tr = _dsicm_enable_te(ddata, false);\n\tif (r)\n\t\tgoto err;\n\n\tif (ddata->ext_te_gpio)\n\t\tdisable_irq(gpiod_to_irq(ddata->ext_te_gpio));\n\n\tin->ops.dsi->disable(in, false, true);\n\n\tddata->ulps_enabled = true;\n\n\treturn 0;\n\nerr:\n\tdev_err(&ddata->pdev->dev, \"enter ULPS failed\");\n\tdsicm_panel_reset(ddata);\n\n\tddata->ulps_enabled = false;\n\n\tdsicm_queue_ulps_work(ddata);\n\n\treturn r;\n}\n\nstatic int dsicm_exit_ulps(struct panel_drv_data *ddata)\n{\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tif (!ddata->ulps_enabled)\n\t\treturn 0;\n\n\tr = in->ops.dsi->enable(in);\n\tif (r) {\n\t\tdev_err(&ddata->pdev->dev, \"failed to enable DSI\\n\");\n\t\tgoto err1;\n\t}\n\n\tin->ops.dsi->enable_hs(in, ddata->channel, true);\n\n\tr = _dsicm_enable_te(ddata, true);\n\tif (r) {\n\t\tdev_err(&ddata->pdev->dev, \"failed to re-enable TE\");\n\t\tgoto err2;\n\t}\n\n\tif (ddata->ext_te_gpio)\n\t\tenable_irq(gpiod_to_irq(ddata->ext_te_gpio));\n\n\tdsicm_queue_ulps_work(ddata);\n\n\tddata->ulps_enabled = false;\n\n\treturn 0;\n\nerr2:\n\tdev_err(&ddata->pdev->dev, \"failed to exit ULPS\");\n\n\tr = dsicm_panel_reset(ddata);\n\tif (!r) {\n\t\tif (ddata->ext_te_gpio)\n\t\t\tenable_irq(gpiod_to_irq(ddata->ext_te_gpio));\n\t\tddata->ulps_enabled = false;\n\t}\nerr1:\n\tdsicm_queue_ulps_work(ddata);\n\n\treturn r;\n}\n\nstatic int dsicm_wake_up(struct panel_drv_data *ddata)\n{\n\tif (ddata->ulps_enabled)\n\t\treturn dsicm_exit_ulps(ddata);\n\n\tdsicm_cancel_ulps_work(ddata);\n\tdsicm_queue_ulps_work(ddata);\n\treturn 0;\n}\n\nstatic int dsicm_bl_update_status(struct backlight_device *dev)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\tint level = backlight_get_brightness(dev);\n\n\tdev_dbg(&ddata->pdev->dev, \"update brightness to %d\\n\", level);\n\n\tmutex_lock(&ddata->lock);\n\n\tif (ddata->enabled) {\n\t\tin->ops.dsi->bus_lock(in);\n\n\t\tr = dsicm_wake_up(ddata);\n\t\tif (!r)\n\t\t\tr = dsicm_dcs_write_1(ddata, DCS_BRIGHTNESS, level);\n\n\t\tin->ops.dsi->bus_unlock(in);\n\t} else {\n\t\tr = 0;\n\t}\n\n\tmutex_unlock(&ddata->lock);\n\n\treturn r;\n}\n\nstatic int dsicm_bl_get_intensity(struct backlight_device *dev)\n{\n\tif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\n\t\t\tdev->props.power == FB_BLANK_UNBLANK)\n\t\treturn dev->props.brightness;\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops dsicm_bl_ops = {\n\t.get_brightness = dsicm_bl_get_intensity,\n\t.update_status  = dsicm_bl_update_status,\n};\n\nstatic void dsicm_get_resolution(struct omap_dss_device *dssdev,\n\t\tu16 *xres, u16 *yres)\n{\n\t*xres = dssdev->panel.timings.x_res;\n\t*yres = dssdev->panel.timings.y_res;\n}\n\nstatic ssize_t dsicm_num_errors_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tstruct omap_dss_device *in = ddata->in;\n\tu8 errors = 0;\n\tint r;\n\n\tmutex_lock(&ddata->lock);\n\n\tif (ddata->enabled) {\n\t\tin->ops.dsi->bus_lock(in);\n\n\t\tr = dsicm_wake_up(ddata);\n\t\tif (!r)\n\t\t\tr = dsicm_dcs_read_1(ddata, DCS_READ_NUM_ERRORS,\n\t\t\t\t\t&errors);\n\n\t\tin->ops.dsi->bus_unlock(in);\n\t} else {\n\t\tr = -ENODEV;\n\t}\n\n\tmutex_unlock(&ddata->lock);\n\n\tif (r)\n\t\treturn r;\n\n\treturn sysfs_emit(buf, \"%d\\n\", errors);\n}\n\nstatic ssize_t dsicm_hw_revision_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tstruct omap_dss_device *in = ddata->in;\n\tu8 id1, id2, id3;\n\tint r;\n\n\tmutex_lock(&ddata->lock);\n\n\tif (ddata->enabled) {\n\t\tin->ops.dsi->bus_lock(in);\n\n\t\tr = dsicm_wake_up(ddata);\n\t\tif (!r)\n\t\t\tr = dsicm_get_id(ddata, &id1, &id2, &id3);\n\n\t\tin->ops.dsi->bus_unlock(in);\n\t} else {\n\t\tr = -ENODEV;\n\t}\n\n\tmutex_unlock(&ddata->lock);\n\n\tif (r)\n\t\treturn r;\n\n\treturn sysfs_emit(buf, \"%02x.%02x.%02x\\n\", id1, id2, id3);\n}\n\nstatic ssize_t dsicm_store_ulps(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tstruct omap_dss_device *in = ddata->in;\n\tunsigned long t;\n\tint r;\n\n\tr = kstrtoul(buf, 0, &t);\n\tif (r)\n\t\treturn r;\n\n\tmutex_lock(&ddata->lock);\n\n\tif (ddata->enabled) {\n\t\tin->ops.dsi->bus_lock(in);\n\n\t\tif (t)\n\t\t\tr = dsicm_enter_ulps(ddata);\n\t\telse\n\t\t\tr = dsicm_wake_up(ddata);\n\n\t\tin->ops.dsi->bus_unlock(in);\n\t}\n\n\tmutex_unlock(&ddata->lock);\n\n\tif (r)\n\t\treturn r;\n\n\treturn count;\n}\n\nstatic ssize_t dsicm_show_ulps(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tunsigned t;\n\n\tmutex_lock(&ddata->lock);\n\tt = ddata->ulps_enabled;\n\tmutex_unlock(&ddata->lock);\n\n\treturn sysfs_emit(buf, \"%u\\n\", t);\n}\n\nstatic ssize_t dsicm_store_ulps_timeout(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tstruct omap_dss_device *in = ddata->in;\n\tunsigned long t;\n\tint r;\n\n\tr = kstrtoul(buf, 0, &t);\n\tif (r)\n\t\treturn r;\n\n\tmutex_lock(&ddata->lock);\n\tddata->ulps_timeout = t;\n\n\tif (ddata->enabled) {\n\t\t \n\t\tin->ops.dsi->bus_lock(in);\n\t\tr = dsicm_wake_up(ddata);\n\t\tin->ops.dsi->bus_unlock(in);\n\t}\n\n\tmutex_unlock(&ddata->lock);\n\n\tif (r)\n\t\treturn r;\n\n\treturn count;\n}\n\nstatic ssize_t dsicm_show_ulps_timeout(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct panel_drv_data *ddata = dev_get_drvdata(dev);\n\tunsigned t;\n\n\tmutex_lock(&ddata->lock);\n\tt = ddata->ulps_timeout;\n\tmutex_unlock(&ddata->lock);\n\n\treturn sysfs_emit(buf, \"%u\\n\", t);\n}\n\nstatic DEVICE_ATTR(num_dsi_errors, S_IRUGO, dsicm_num_errors_show, NULL);\nstatic DEVICE_ATTR(hw_revision, S_IRUGO, dsicm_hw_revision_show, NULL);\nstatic DEVICE_ATTR(ulps, S_IRUGO | S_IWUSR,\n\t\tdsicm_show_ulps, dsicm_store_ulps);\nstatic DEVICE_ATTR(ulps_timeout, S_IRUGO | S_IWUSR,\n\t\tdsicm_show_ulps_timeout, dsicm_store_ulps_timeout);\n\nstatic struct attribute *dsicm_attrs[] = {\n\t&dev_attr_num_dsi_errors.attr,\n\t&dev_attr_hw_revision.attr,\n\t&dev_attr_ulps.attr,\n\t&dev_attr_ulps_timeout.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group dsicm_attr_group = {\n\t.attrs = dsicm_attrs,\n};\n\nstatic void dsicm_hw_reset(struct panel_drv_data *ddata)\n{\n\t \n\tgpiod_set_value_cansleep(ddata->reset_gpio, 1);\n\tudelay(10);\n\t \n\tgpiod_set_value_cansleep(ddata->reset_gpio, 0);\n\t \n\tudelay(10);\n\t \n\tgpiod_set_value_cansleep(ddata->reset_gpio, 1);\n\t \n\tusleep_range(5000, 10000);\n}\n\nstatic int dsicm_power_on(struct panel_drv_data *ddata)\n{\n\tstruct omap_dss_device *in = ddata->in;\n\tu8 id1, id2, id3;\n\tint r;\n\tstruct omap_dss_dsi_config dsi_config = {\n\t\t.mode = OMAP_DSS_DSI_CMD_MODE,\n\t\t.pixel_format = OMAP_DSS_DSI_FMT_RGB888,\n\t\t.timings = &ddata->timings,\n\t\t.hs_clk_min = 150000000,\n\t\t.hs_clk_max = 300000000,\n\t\t.lp_clk_min = 7000000,\n\t\t.lp_clk_max = 10000000,\n\t};\n\n\tif (ddata->pin_config.num_pins > 0) {\n\t\tr = in->ops.dsi->configure_pins(in, &ddata->pin_config);\n\t\tif (r) {\n\t\t\tdev_err(&ddata->pdev->dev,\n\t\t\t\t\"failed to configure DSI pins\\n\");\n\t\t\tgoto err0;\n\t\t}\n\t}\n\n\tr = in->ops.dsi->set_config(in, &dsi_config);\n\tif (r) {\n\t\tdev_err(&ddata->pdev->dev, \"failed to configure DSI\\n\");\n\t\tgoto err0;\n\t}\n\n\tr = in->ops.dsi->enable(in);\n\tif (r) {\n\t\tdev_err(&ddata->pdev->dev, \"failed to enable DSI\\n\");\n\t\tgoto err0;\n\t}\n\n\tdsicm_hw_reset(ddata);\n\n\tin->ops.dsi->enable_hs(in, ddata->channel, false);\n\n\tr = dsicm_sleep_out(ddata);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsicm_get_id(ddata, &id1, &id2, &id3);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsicm_dcs_write_1(ddata, DCS_BRIGHTNESS, 0xff);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsicm_dcs_write_1(ddata, DCS_CTRL_DISPLAY,\n\t\t\t(1<<2) | (1<<5));\t \n\tif (r)\n\t\tgoto err;\n\n\tr = dsicm_dcs_write_1(ddata, MIPI_DCS_SET_PIXEL_FORMAT,\n\t\tMIPI_DCS_PIXEL_FMT_24BIT);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsicm_dcs_write_0(ddata, MIPI_DCS_SET_DISPLAY_ON);\n\tif (r)\n\t\tgoto err;\n\n\tr = _dsicm_enable_te(ddata, ddata->te_enabled);\n\tif (r)\n\t\tgoto err;\n\n\tr = in->ops.dsi->enable_video_output(in, ddata->channel);\n\tif (r)\n\t\tgoto err;\n\n\tddata->enabled = 1;\n\n\tif (!ddata->intro_printed) {\n\t\tdev_info(&ddata->pdev->dev, \"panel revision %02x.%02x.%02x\\n\",\n\t\t\tid1, id2, id3);\n\t\tddata->intro_printed = true;\n\t}\n\n\tin->ops.dsi->enable_hs(in, ddata->channel, true);\n\n\treturn 0;\nerr:\n\tdev_err(&ddata->pdev->dev, \"error while enabling panel, issuing HW reset\\n\");\n\n\tdsicm_hw_reset(ddata);\n\n\tin->ops.dsi->disable(in, true, false);\nerr0:\n\treturn r;\n}\n\nstatic void dsicm_power_off(struct panel_drv_data *ddata)\n{\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tin->ops.dsi->disable_video_output(in, ddata->channel);\n\n\tr = dsicm_dcs_write_0(ddata, MIPI_DCS_SET_DISPLAY_OFF);\n\tif (!r)\n\t\tr = dsicm_sleep_in(ddata);\n\n\tif (r) {\n\t\tdev_err(&ddata->pdev->dev,\n\t\t\t\t\"error disabling panel, issuing HW reset\\n\");\n\t\tdsicm_hw_reset(ddata);\n\t}\n\n\tin->ops.dsi->disable(in, true, false);\n\n\tddata->enabled = 0;\n}\n\nstatic int dsicm_panel_reset(struct panel_drv_data *ddata)\n{\n\tdev_err(&ddata->pdev->dev, \"performing LCD reset\\n\");\n\n\tdsicm_power_off(ddata);\n\tdsicm_hw_reset(ddata);\n\treturn dsicm_power_on(ddata);\n}\n\nstatic int dsicm_connect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tstruct device *dev = &ddata->pdev->dev;\n\tint r;\n\n\tif (omapdss_device_is_connected(dssdev))\n\t\treturn 0;\n\n\tr = in->ops.dsi->connect(in, dssdev);\n\tif (r) {\n\t\tdev_err(dev, \"Failed to connect to video source\\n\");\n\t\treturn r;\n\t}\n\n\tr = in->ops.dsi->request_vc(ddata->in, &ddata->channel);\n\tif (r) {\n\t\tdev_err(dev, \"failed to get virtual channel\\n\");\n\t\tgoto err_req_vc;\n\t}\n\n\tr = in->ops.dsi->set_vc_id(ddata->in, ddata->channel, TCH);\n\tif (r) {\n\t\tdev_err(dev, \"failed to set VC_ID\\n\");\n\t\tgoto err_vc_id;\n\t}\n\n\treturn 0;\n\nerr_vc_id:\n\tin->ops.dsi->release_vc(ddata->in, ddata->channel);\nerr_req_vc:\n\tin->ops.dsi->disconnect(in, dssdev);\n\treturn r;\n}\n\nstatic void dsicm_disconnect(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tif (!omapdss_device_is_connected(dssdev))\n\t\treturn;\n\n\tin->ops.dsi->release_vc(in, ddata->channel);\n\tin->ops.dsi->disconnect(in, dssdev);\n}\n\nstatic int dsicm_enable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tdev_dbg(&ddata->pdev->dev, \"enable\\n\");\n\n\tmutex_lock(&ddata->lock);\n\n\tif (!omapdss_device_is_connected(dssdev)) {\n\t\tr = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tif (omapdss_device_is_enabled(dssdev)) {\n\t\tr = 0;\n\t\tgoto err;\n\t}\n\n\tin->ops.dsi->bus_lock(in);\n\n\tr = dsicm_power_on(ddata);\n\n\tin->ops.dsi->bus_unlock(in);\n\n\tif (r)\n\t\tgoto err;\n\n\tdssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\n\n\tmutex_unlock(&ddata->lock);\n\n\treturn 0;\nerr:\n\tdev_dbg(&ddata->pdev->dev, \"enable failed\\n\");\n\tmutex_unlock(&ddata->lock);\n\treturn r;\n}\n\nstatic void dsicm_disable(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tdev_dbg(&ddata->pdev->dev, \"disable\\n\");\n\n\tmutex_lock(&ddata->lock);\n\n\tdsicm_cancel_ulps_work(ddata);\n\n\tin->ops.dsi->bus_lock(in);\n\n\tif (omapdss_device_is_enabled(dssdev)) {\n\t\tr = dsicm_wake_up(ddata);\n\t\tif (!r)\n\t\t\tdsicm_power_off(ddata);\n\t}\n\n\tin->ops.dsi->bus_unlock(in);\n\n\tdssdev->state = OMAP_DSS_DISPLAY_DISABLED;\n\n\tmutex_unlock(&ddata->lock);\n}\n\nstatic void dsicm_framedone_cb(int err, void *data)\n{\n\tstruct panel_drv_data *ddata = data;\n\tstruct omap_dss_device *in = ddata->in;\n\n\tdev_dbg(&ddata->pdev->dev, \"framedone, err %d\\n\", err);\n\tin->ops.dsi->bus_unlock(ddata->in);\n}\n\nstatic irqreturn_t dsicm_te_isr(int irq, void *data)\n{\n\tstruct panel_drv_data *ddata = data;\n\tstruct omap_dss_device *in = ddata->in;\n\tint old;\n\tint r;\n\n\told = atomic_cmpxchg(&ddata->do_update, 1, 0);\n\n\tif (old) {\n\t\tcancel_delayed_work(&ddata->te_timeout_work);\n\n\t\tr = in->ops.dsi->update(in, ddata->channel, dsicm_framedone_cb,\n\t\t\t\tddata);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\treturn IRQ_HANDLED;\nerr:\n\tdev_err(&ddata->pdev->dev, \"start update failed\\n\");\n\tin->ops.dsi->bus_unlock(in);\n\treturn IRQ_HANDLED;\n}\n\nstatic void dsicm_te_timeout_work_callback(struct work_struct *work)\n{\n\tstruct panel_drv_data *ddata = container_of(work, struct panel_drv_data,\n\t\t\t\t\tte_timeout_work.work);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tdev_err(&ddata->pdev->dev, \"TE not received for 250ms!\\n\");\n\n\tatomic_set(&ddata->do_update, 0);\n\tin->ops.dsi->bus_unlock(in);\n}\n\nstatic int dsicm_update(struct omap_dss_device *dssdev,\n\t\t\t\t    u16 x, u16 y, u16 w, u16 h)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tdev_dbg(&ddata->pdev->dev, \"update %d, %d, %d x %d\\n\", x, y, w, h);\n\n\tmutex_lock(&ddata->lock);\n\tin->ops.dsi->bus_lock(in);\n\n\tr = dsicm_wake_up(ddata);\n\tif (r)\n\t\tgoto err;\n\n\tif (!ddata->enabled) {\n\t\tr = 0;\n\t\tgoto err;\n\t}\n\n\t \n\tr = dsicm_set_update_window(ddata, 0, 0,\n\t\t\tdssdev->panel.timings.x_res,\n\t\t\tdssdev->panel.timings.y_res);\n\tif (r)\n\t\tgoto err;\n\n\tif (ddata->te_enabled && ddata->ext_te_gpio) {\n\t\tschedule_delayed_work(&ddata->te_timeout_work,\n\t\t\t\tmsecs_to_jiffies(250));\n\t\tatomic_set(&ddata->do_update, 1);\n\t} else {\n\t\tr = in->ops.dsi->update(in, ddata->channel, dsicm_framedone_cb,\n\t\t\t\tddata);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\t \n\tmutex_unlock(&ddata->lock);\n\treturn 0;\nerr:\n\tin->ops.dsi->bus_unlock(in);\n\tmutex_unlock(&ddata->lock);\n\treturn r;\n}\n\nstatic int dsicm_sync(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\n\tdev_dbg(&ddata->pdev->dev, \"sync\\n\");\n\n\tmutex_lock(&ddata->lock);\n\tin->ops.dsi->bus_lock(in);\n\tin->ops.dsi->bus_unlock(in);\n\tmutex_unlock(&ddata->lock);\n\n\tdev_dbg(&ddata->pdev->dev, \"sync done\\n\");\n\n\treturn 0;\n}\n\nstatic int _dsicm_enable_te(struct panel_drv_data *ddata, bool enable)\n{\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tif (enable)\n\t\tr = dsicm_dcs_write_1(ddata, MIPI_DCS_SET_TEAR_ON, 0);\n\telse\n\t\tr = dsicm_dcs_write_0(ddata, MIPI_DCS_SET_TEAR_OFF);\n\n\tif (!ddata->ext_te_gpio)\n\t\tin->ops.dsi->enable_te(in, enable);\n\n\t \n\tmsleep(100);\n\n\treturn r;\n}\n\nstatic int dsicm_enable_te(struct omap_dss_device *dssdev, bool enable)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\n\tmutex_lock(&ddata->lock);\n\n\tif (ddata->te_enabled == enable)\n\t\tgoto end;\n\n\tin->ops.dsi->bus_lock(in);\n\n\tif (ddata->enabled) {\n\t\tr = dsicm_wake_up(ddata);\n\t\tif (r)\n\t\t\tgoto err;\n\n\t\tr = _dsicm_enable_te(ddata, enable);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tddata->te_enabled = enable;\n\n\tin->ops.dsi->bus_unlock(in);\nend:\n\tmutex_unlock(&ddata->lock);\n\n\treturn 0;\nerr:\n\tin->ops.dsi->bus_unlock(in);\n\tmutex_unlock(&ddata->lock);\n\n\treturn r;\n}\n\nstatic int dsicm_get_te(struct omap_dss_device *dssdev)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tint r;\n\n\tmutex_lock(&ddata->lock);\n\tr = ddata->te_enabled;\n\tmutex_unlock(&ddata->lock);\n\n\treturn r;\n}\n\nstatic int dsicm_memory_read(struct omap_dss_device *dssdev,\n\t\tvoid *buf, size_t size,\n\t\tu16 x, u16 y, u16 w, u16 h)\n{\n\tstruct panel_drv_data *ddata = to_panel_data(dssdev);\n\tstruct omap_dss_device *in = ddata->in;\n\tint r;\n\tint first = 1;\n\tint plen;\n\tunsigned buf_used = 0;\n\n\tif (size < w * h * 3)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ddata->lock);\n\n\tif (!ddata->enabled) {\n\t\tr = -ENODEV;\n\t\tgoto err1;\n\t}\n\n\tsize = min(w * h * 3,\n\t\t\tdssdev->panel.timings.x_res *\n\t\t\tdssdev->panel.timings.y_res * 3);\n\n\tin->ops.dsi->bus_lock(in);\n\n\tr = dsicm_wake_up(ddata);\n\tif (r)\n\t\tgoto err2;\n\n\t \n\tif (size % 2)\n\t\tplen = 1;\n\telse\n\t\tplen = 2;\n\n\tdsicm_set_update_window(ddata, x, y, w, h);\n\n\tr = in->ops.dsi->set_max_rx_packet_size(in, ddata->channel, plen);\n\tif (r)\n\t\tgoto err2;\n\n\twhile (buf_used < size) {\n\t\tu8 dcs_cmd = first ? 0x2e : 0x3e;\n\t\tfirst = 0;\n\n\t\tr = in->ops.dsi->dcs_read(in, ddata->channel, dcs_cmd,\n\t\t\t\tbuf + buf_used, size - buf_used);\n\n\t\tif (r < 0) {\n\t\t\tdev_err(dssdev->dev, \"read error\\n\");\n\t\t\tgoto err3;\n\t\t}\n\n\t\tbuf_used += r;\n\n\t\tif (r < plen) {\n\t\t\tdev_err(&ddata->pdev->dev, \"short read\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tdev_err(&ddata->pdev->dev, \"signal pending, \"\n\t\t\t\t\t\"aborting memory read\\n\");\n\t\t\tr = -ERESTARTSYS;\n\t\t\tgoto err3;\n\t\t}\n\t}\n\n\tr = buf_used;\n\nerr3:\n\tin->ops.dsi->set_max_rx_packet_size(in, ddata->channel, 1);\nerr2:\n\tin->ops.dsi->bus_unlock(in);\nerr1:\n\tmutex_unlock(&ddata->lock);\n\treturn r;\n}\n\nstatic void dsicm_ulps_work(struct work_struct *work)\n{\n\tstruct panel_drv_data *ddata = container_of(work, struct panel_drv_data,\n\t\t\tulps_work.work);\n\tstruct omap_dss_device *dssdev = &ddata->dssdev;\n\tstruct omap_dss_device *in = ddata->in;\n\n\tmutex_lock(&ddata->lock);\n\n\tif (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE || !ddata->enabled) {\n\t\tmutex_unlock(&ddata->lock);\n\t\treturn;\n\t}\n\n\tin->ops.dsi->bus_lock(in);\n\n\tdsicm_enter_ulps(ddata);\n\n\tin->ops.dsi->bus_unlock(in);\n\tmutex_unlock(&ddata->lock);\n}\n\nstatic struct omap_dss_driver dsicm_ops = {\n\t.connect\t= dsicm_connect,\n\t.disconnect\t= dsicm_disconnect,\n\n\t.enable\t\t= dsicm_enable,\n\t.disable\t= dsicm_disable,\n\n\t.update\t\t= dsicm_update,\n\t.sync\t\t= dsicm_sync,\n\n\t.get_resolution\t= dsicm_get_resolution,\n\t.get_recommended_bpp = omapdss_default_get_recommended_bpp,\n\n\t.enable_te\t= dsicm_enable_te,\n\t.get_te\t\t= dsicm_get_te,\n\n\t.memory_read\t= dsicm_memory_read,\n};\n\nstatic int dsicm_probe(struct platform_device *pdev)\n{\n\tstruct backlight_properties props;\n\tstruct panel_drv_data *ddata;\n\tstruct backlight_device *bldev = NULL;\n\tstruct device *dev = &pdev->dev;\n\tstruct omap_dss_device *dssdev;\n\tint r;\n\n\tdev_dbg(dev, \"probe\\n\");\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tddata = devm_kzalloc(dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ddata);\n\tddata->pdev = pdev;\n\n\tddata->in = omapdss_of_find_source_for_first_ep(pdev->dev.of_node);\n\tr = PTR_ERR_OR_ZERO(ddata->in);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"failed to find video source: %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tddata->timings.x_res = 864;\n\tddata->timings.y_res = 480;\n\tddata->timings.pixelclock = 864 * 480 * 60;\n\n\tdssdev = &ddata->dssdev;\n\tdssdev->dev = dev;\n\tdssdev->driver = &dsicm_ops;\n\tdssdev->panel.timings = ddata->timings;\n\tdssdev->type = OMAP_DISPLAY_TYPE_DSI;\n\tdssdev->owner = THIS_MODULE;\n\n\tdssdev->panel.dsi_pix_fmt = OMAP_DSS_DSI_FMT_RGB888;\n\tdssdev->caps = OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE |\n\t\tOMAP_DSS_DISPLAY_CAP_TEAR_ELIM;\n\n\tr = omapdss_register_display(dssdev);\n\tif (r) {\n\t\tdev_err(dev, \"Failed to register panel\\n\");\n\t\tgoto err_reg;\n\t}\n\n\tmutex_init(&ddata->lock);\n\n\tatomic_set(&ddata->do_update, 0);\n\n\tddata->reset_gpio = devm_gpiod_get(&pdev->dev, \"reset\", GPIOD_OUT_LOW);\n\tr = PTR_ERR_OR_ZERO(ddata->reset_gpio);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"Failed to request reset gpio: %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tgpiod_set_consumer_name(ddata->reset_gpio, \"taal rst\");\n\n\tddata->ext_te_gpio = devm_gpiod_get_optional(&pdev->dev, \"te\",\n\t\t\t\t\t\t     GPIOD_IN);\n\tr = PTR_ERR_OR_ZERO(ddata->ext_te_gpio);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"Failed to request TE gpio: %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tif (ddata->ext_te_gpio) {\n\t\tgpiod_set_consumer_name(ddata->ext_te_gpio, \"taal irq\");\n\n\t\tr = devm_request_irq(dev, gpiod_to_irq(ddata->ext_te_gpio),\n\t\t\t\tdsicm_te_isr,\n\t\t\t\tIRQF_TRIGGER_RISING,\n\t\t\t\t\"taal vsync\", ddata);\n\n\t\tif (r) {\n\t\t\tdev_err(dev, \"IRQ request failed\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tINIT_DEFERRABLE_WORK(&ddata->te_timeout_work,\n\t\t\t\t\tdsicm_te_timeout_work_callback);\n\n\t\tdev_dbg(dev, \"Using GPIO TE\\n\");\n\t}\n\n\tINIT_DELAYED_WORK(&ddata->ulps_work, dsicm_ulps_work);\n\n\tdsicm_hw_reset(ddata);\n\n\tif (ddata->use_dsi_backlight) {\n\t\tmemset(&props, 0, sizeof(struct backlight_properties));\n\t\tprops.max_brightness = 255;\n\n\t\tprops.type = BACKLIGHT_RAW;\n\t\tbldev = backlight_device_register(dev_name(dev),\n\t\t\t\tdev, ddata, &dsicm_bl_ops, &props);\n\t\tif (IS_ERR(bldev)) {\n\t\t\tr = PTR_ERR(bldev);\n\t\t\tgoto err_reg;\n\t\t}\n\n\t\tddata->bldev = bldev;\n\n\t\tbldev->props.fb_blank = FB_BLANK_UNBLANK;\n\t\tbldev->props.power = FB_BLANK_UNBLANK;\n\t\tbldev->props.brightness = 255;\n\n\t\tdsicm_bl_update_status(bldev);\n\t}\n\n\tr = sysfs_create_group(&dev->kobj, &dsicm_attr_group);\n\tif (r) {\n\t\tdev_err(dev, \"failed to create sysfs files\\n\");\n\t\tgoto err_sysfs_create;\n\t}\n\n\treturn 0;\n\nerr_sysfs_create:\n\tif (bldev != NULL)\n\t\tbacklight_device_unregister(bldev);\nerr_reg:\n\treturn r;\n}\n\nstatic int __exit dsicm_remove(struct platform_device *pdev)\n{\n\tstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\n\tstruct omap_dss_device *dssdev = &ddata->dssdev;\n\tstruct backlight_device *bldev;\n\n\tdev_dbg(&pdev->dev, \"remove\\n\");\n\n\tomapdss_unregister_display(dssdev);\n\n\tdsicm_disable(dssdev);\n\tdsicm_disconnect(dssdev);\n\n\tsysfs_remove_group(&pdev->dev.kobj, &dsicm_attr_group);\n\n\tbldev = ddata->bldev;\n\tif (bldev != NULL) {\n\t\tbldev->props.power = FB_BLANK_POWERDOWN;\n\t\tdsicm_bl_update_status(bldev);\n\t\tbacklight_device_unregister(bldev);\n\t}\n\n\tomap_dss_put_device(ddata->in);\n\n\tdsicm_cancel_ulps_work(ddata);\n\n\t \n\tdsicm_hw_reset(ddata);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id dsicm_of_match[] = {\n\t{ .compatible = \"omapdss,panel-dsi-cm\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, dsicm_of_match);\n\nstatic struct platform_driver dsicm_driver = {\n\t.probe = dsicm_probe,\n\t.remove = __exit_p(dsicm_remove),\n\t.driver = {\n\t\t.name = \"panel-dsi-cm\",\n\t\t.of_match_table = dsicm_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nmodule_platform_driver(dsicm_driver);\n\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ti.com>\");\nMODULE_DESCRIPTION(\"Generic DSI Command Mode Panel Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}