{
  "module_name": "goldfishfb.c",
  "hash_id": "c3c32257a85786466097be1dbb18ff23d054296361ab5e58aa5bf26e05c3ef13",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/goldfishfb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/acpi.h>\n\nenum {\n\tFB_GET_WIDTH        = 0x00,\n\tFB_GET_HEIGHT       = 0x04,\n\tFB_INT_STATUS       = 0x08,\n\tFB_INT_ENABLE       = 0x0c,\n\tFB_SET_BASE         = 0x10,\n\tFB_SET_ROTATION     = 0x14,\n\tFB_SET_BLANK        = 0x18,\n\tFB_GET_PHYS_WIDTH   = 0x1c,\n\tFB_GET_PHYS_HEIGHT  = 0x20,\n\n\tFB_INT_VSYNC             = 1U << 0,\n\tFB_INT_BASE_UPDATE_DONE  = 1U << 1\n};\n\nstruct goldfish_fb {\n\tvoid __iomem *reg_base;\n\tint irq;\n\tspinlock_t lock;\n\twait_queue_head_t wait;\n\tint base_update_count;\n\tint rotation;\n\tstruct fb_info fb;\n\tu32 cmap[16];\n};\n\nstatic irqreturn_t goldfish_fb_interrupt(int irq, void *dev_id)\n{\n\tunsigned long irq_flags;\n\tstruct goldfish_fb *fb = dev_id;\n\tu32 status;\n\n\tspin_lock_irqsave(&fb->lock, irq_flags);\n\tstatus = readl(fb->reg_base + FB_INT_STATUS);\n\tif (status & FB_INT_BASE_UPDATE_DONE) {\n\t\tfb->base_update_count++;\n\t\twake_up(&fb->wait);\n\t}\n\tspin_unlock_irqrestore(&fb->lock, irq_flags);\n\treturn status ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic inline u32 convert_bitfield(int val, struct fb_bitfield *bf)\n{\n\tunsigned int mask = (1 << bf->length) - 1;\n\n\treturn (val >> (16 - bf->length) & mask) << bf->offset;\n}\n\nstatic int\ngoldfish_fb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,\n\t\t unsigned int blue, unsigned int transp, struct fb_info *info)\n{\n\tstruct goldfish_fb *fb = container_of(info, struct goldfish_fb, fb);\n\n\tif (regno < 16) {\n\t\tfb->cmap[regno] = convert_bitfield(transp, &fb->fb.var.transp) |\n\t\t\t\t  convert_bitfield(blue, &fb->fb.var.blue) |\n\t\t\t\t  convert_bitfield(green, &fb->fb.var.green) |\n\t\t\t\t  convert_bitfield(red, &fb->fb.var.red);\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n\nstatic int goldfish_fb_check_var(struct fb_var_screeninfo *var,\n\t\t\t\t\t\t\tstruct fb_info *info)\n{\n\tif ((var->rotate & 1) != (info->var.rotate & 1)) {\n\t\tif ((var->xres != info->var.yres) ||\n\t\t\t\t(var->yres != info->var.xres) ||\n\t\t\t\t(var->xres_virtual != info->var.yres) ||\n\t\t\t\t(var->yres_virtual > info->var.xres * 2) ||\n\t\t\t\t(var->yres_virtual < info->var.xres)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif ((var->xres != info->var.xres) ||\n\t\t   (var->yres != info->var.yres) ||\n\t\t   (var->xres_virtual != info->var.xres) ||\n\t\t   (var->yres_virtual > info->var.yres * 2) ||\n\t\t   (var->yres_virtual < info->var.yres)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif ((var->xoffset != info->var.xoffset) ||\n\t\t\t(var->bits_per_pixel != info->var.bits_per_pixel) ||\n\t\t\t(var->grayscale != info->var.grayscale)) {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int goldfish_fb_set_par(struct fb_info *info)\n{\n\tstruct goldfish_fb *fb = container_of(info, struct goldfish_fb, fb);\n\n\tif (fb->rotation != fb->fb.var.rotate) {\n\t\tinfo->fix.line_length = info->var.xres * 2;\n\t\tfb->rotation = fb->fb.var.rotate;\n\t\twritel(fb->rotation, fb->reg_base + FB_SET_ROTATION);\n\t}\n\treturn 0;\n}\n\n\nstatic int goldfish_fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\t\t\t\tstruct fb_info *info)\n{\n\tunsigned long irq_flags;\n\tint base_update_count;\n\tstruct goldfish_fb *fb = container_of(info, struct goldfish_fb, fb);\n\n\tspin_lock_irqsave(&fb->lock, irq_flags);\n\tbase_update_count = fb->base_update_count;\n\twritel(fb->fb.fix.smem_start + fb->fb.var.xres * 2 * var->yoffset,\n\t\t\t\t\t\tfb->reg_base + FB_SET_BASE);\n\tspin_unlock_irqrestore(&fb->lock, irq_flags);\n\twait_event_timeout(fb->wait,\n\t\t\tfb->base_update_count != base_update_count, HZ / 15);\n\tif (fb->base_update_count == base_update_count)\n\t\tpr_err(\"%s: timeout waiting for base update\\n\", __func__);\n\treturn 0;\n}\n\nstatic int goldfish_fb_blank(int blank, struct fb_info *info)\n{\n\tstruct goldfish_fb *fb = container_of(info, struct goldfish_fb, fb);\n\n\tswitch (blank) {\n\tcase FB_BLANK_NORMAL:\n\t\twritel(1, fb->reg_base + FB_SET_BLANK);\n\t\tbreak;\n\tcase FB_BLANK_UNBLANK:\n\t\twritel(0, fb->reg_base + FB_SET_BLANK);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct fb_ops goldfish_fb_ops = {\n\t.owner          = THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var   = goldfish_fb_check_var,\n\t.fb_set_par     = goldfish_fb_set_par,\n\t.fb_setcolreg   = goldfish_fb_setcolreg,\n\t.fb_pan_display = goldfish_fb_pan_display,\n\t.fb_blank\t= goldfish_fb_blank,\n};\n\n\nstatic int goldfish_fb_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct resource *r;\n\tstruct goldfish_fb *fb;\n\tsize_t framesize;\n\tu32 width, height;\n\tdma_addr_t fbpaddr;\n\n\tfb = kzalloc(sizeof(*fb), GFP_KERNEL);\n\tif (fb == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_fb_alloc_failed;\n\t}\n\tspin_lock_init(&fb->lock);\n\tinit_waitqueue_head(&fb->wait);\n\tplatform_set_drvdata(pdev, fb);\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (r == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto err_no_io_base;\n\t}\n\tfb->reg_base = ioremap(r->start, PAGE_SIZE);\n\tif (fb->reg_base == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_no_io_base;\n\t}\n\n\tfb->irq = platform_get_irq(pdev, 0);\n\tif (fb->irq < 0) {\n\t\tret = fb->irq;\n\t\tgoto err_no_irq;\n\t}\n\n\twidth = readl(fb->reg_base + FB_GET_WIDTH);\n\theight = readl(fb->reg_base + FB_GET_HEIGHT);\n\n\tfb->fb.fbops\t\t= &goldfish_fb_ops;\n\tfb->fb.pseudo_palette\t= fb->cmap;\n\tfb->fb.fix.type\t\t= FB_TYPE_PACKED_PIXELS;\n\tfb->fb.fix.visual = FB_VISUAL_TRUECOLOR;\n\tfb->fb.fix.line_length = width * 2;\n\tfb->fb.fix.accel\t= FB_ACCEL_NONE;\n\tfb->fb.fix.ypanstep = 1;\n\n\tfb->fb.var.xres\t\t= width;\n\tfb->fb.var.yres\t\t= height;\n\tfb->fb.var.xres_virtual\t= width;\n\tfb->fb.var.yres_virtual\t= height * 2;\n\tfb->fb.var.bits_per_pixel = 16;\n\tfb->fb.var.activate\t= FB_ACTIVATE_NOW;\n\tfb->fb.var.height\t= readl(fb->reg_base + FB_GET_PHYS_HEIGHT);\n\tfb->fb.var.width\t= readl(fb->reg_base + FB_GET_PHYS_WIDTH);\n\tfb->fb.var.pixclock\t= 0;\n\n\tfb->fb.var.red.offset = 11;\n\tfb->fb.var.red.length = 5;\n\tfb->fb.var.green.offset = 5;\n\tfb->fb.var.green.length = 6;\n\tfb->fb.var.blue.offset = 0;\n\tfb->fb.var.blue.length = 5;\n\n\tframesize = width * height * 2 * 2;\n\tfb->fb.screen_base = (char __force __iomem *)dma_alloc_coherent(\n\t\t\t\t\t\t&pdev->dev, framesize,\n\t\t\t\t\t\t&fbpaddr, GFP_KERNEL);\n\tpr_debug(\"allocating frame buffer %d * %d, got %p\\n\",\n\t\t\t\t\twidth, height, fb->fb.screen_base);\n\tif (fb->fb.screen_base == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_screen_base_failed;\n\t}\n\tfb->fb.fix.smem_start = fbpaddr;\n\tfb->fb.fix.smem_len = framesize;\n\n\tret = fb_set_var(&fb->fb, &fb->fb.var);\n\tif (ret)\n\t\tgoto err_fb_set_var_failed;\n\n\tret = request_irq(fb->irq, goldfish_fb_interrupt, IRQF_SHARED,\n\t\t\t\t\t\t\tpdev->name, fb);\n\tif (ret)\n\t\tgoto err_request_irq_failed;\n\n\twritel(FB_INT_BASE_UPDATE_DONE, fb->reg_base + FB_INT_ENABLE);\n\tgoldfish_fb_pan_display(&fb->fb.var, &fb->fb);  \n\n\tret = register_framebuffer(&fb->fb);\n\tif (ret)\n\t\tgoto err_register_framebuffer_failed;\n\treturn 0;\n\nerr_register_framebuffer_failed:\n\tfree_irq(fb->irq, fb);\nerr_request_irq_failed:\nerr_fb_set_var_failed:\n\tdma_free_coherent(&pdev->dev, framesize,\n\t\t\t\t(void *)fb->fb.screen_base,\n\t\t\t\tfb->fb.fix.smem_start);\nerr_alloc_screen_base_failed:\nerr_no_irq:\n\tiounmap(fb->reg_base);\nerr_no_io_base:\n\tkfree(fb);\nerr_fb_alloc_failed:\n\treturn ret;\n}\n\nstatic void goldfish_fb_remove(struct platform_device *pdev)\n{\n\tsize_t framesize;\n\tstruct goldfish_fb *fb = platform_get_drvdata(pdev);\n\n\tframesize = fb->fb.var.xres_virtual * fb->fb.var.yres_virtual * 2;\n\tunregister_framebuffer(&fb->fb);\n\tfree_irq(fb->irq, fb);\n\n\tdma_free_coherent(&pdev->dev, framesize, (void *)fb->fb.screen_base,\n\t\t\t\t\t\tfb->fb.fix.smem_start);\n\tiounmap(fb->reg_base);\n\tkfree(fb);\n}\n\nstatic const struct of_device_id goldfish_fb_of_match[] = {\n\t{ .compatible = \"google,goldfish-fb\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, goldfish_fb_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id goldfish_fb_acpi_match[] = {\n\t{ \"GFSH0004\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, goldfish_fb_acpi_match);\n#endif\n\nstatic struct platform_driver goldfish_fb_driver = {\n\t.probe\t\t= goldfish_fb_probe,\n\t.remove_new\t= goldfish_fb_remove,\n\t.driver = {\n\t\t.name = \"goldfish_fb\",\n\t\t.of_match_table = goldfish_fb_of_match,\n\t\t.acpi_match_table = ACPI_PTR(goldfish_fb_acpi_match),\n\t}\n};\n\nmodule_platform_driver(goldfish_fb_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}