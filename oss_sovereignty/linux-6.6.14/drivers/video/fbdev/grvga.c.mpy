{
  "module_name": "grvga.c",
  "hash_id": "626e008d2f85dcda1218ea0bac58808eedb43bc8a2417c99cd33b451db23b637",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/grvga.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/io.h>\n\nstruct grvga_regs {\n\tu32 status; \t\t \n\tu32 video_length; \t \n\tu32 front_porch;\t \n\tu32 sync_length;\t \n\tu32 line_length;\t \n\tu32 fb_pos;\t\t \n\tu32 clk_vector[4];\t \n\tu32 clut;\t         \n};\n\nstruct grvga_par {\n\tstruct grvga_regs *regs;\n\tu32 color_palette[16];   \n\tint clk_sel;\n\tint fb_alloced;          \n};\n\n\nstatic const struct fb_videomode grvga_modedb[] = {\n    {\n\t \n\tNULL, 60, 640, 480, 40000, 48, 16, 39, 11, 96, 2,\n\t0, FB_VMODE_NONINTERLACED\n    }, {\n\t \n\tNULL, 60, 800, 600, 25000, 88, 40, 23, 1, 128, 4,\n\t0, FB_VMODE_NONINTERLACED\n    }, {\n\t \n\tNULL, 72, 800, 600, 20000, 64, 56, 23, 37, 120, 6,\n\t0, FB_VMODE_NONINTERLACED\n    }, {\n\t \n\tNULL, 60, 1024, 768, 15385, 160, 24, 29, 3, 136, 6,\n\t0, FB_VMODE_NONINTERLACED\n    }\n };\n\nstatic const struct fb_fix_screeninfo grvga_fix = {\n\t.id =\t\t\"AG SVGACTRL\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =       FB_VISUAL_PSEUDOCOLOR,\n\t.xpanstep =\t0,\n\t.ypanstep =\t1,\n\t.ywrapstep =\t0,\n\t.accel =\tFB_ACCEL_NONE,\n};\n\nstatic int grvga_check_var(struct fb_var_screeninfo *var,\n\t\t\t   struct fb_info *info)\n{\n\tstruct grvga_par *par = info->par;\n\tint i;\n\n\tif (!var->xres)\n\t\tvar->xres = 1;\n\tif (!var->yres)\n\t\tvar->yres = 1;\n\tif (var->bits_per_pixel <= 8)\n\t\tvar->bits_per_pixel = 8;\n\telse if (var->bits_per_pixel <= 16)\n\t\tvar->bits_per_pixel = 16;\n\telse if (var->bits_per_pixel <= 24)\n\t\tvar->bits_per_pixel = 24;\n\telse if (var->bits_per_pixel <= 32)\n\t\tvar->bits_per_pixel = 32;\n\telse\n\t\treturn -EINVAL;\n\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = 2*var->yres;\n\n\tif (info->fix.smem_len) {\n\t\tif ((var->yres_virtual*var->xres_virtual*var->bits_per_pixel/8) > info->fix.smem_len)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i <= 3 ; i++) {\n\t\tif (var->pixclock == par->regs->clk_vector[i])\n\t\t\tbreak;\n\t}\n\tif (i <= 3)\n\t\tpar->clk_sel = i;\n\telse\n\t\treturn -EINVAL;\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tvar->red   = (struct fb_bitfield) {0, 8, 0};       \n\t\tvar->green = (struct fb_bitfield) {0, 8, 0};\n\t\tvar->blue  = (struct fb_bitfield) {0, 8, 0};\n\t\tvar->transp = (struct fb_bitfield) {0, 0, 0};\n\t\tbreak;\n\tcase 16:\n\t\tvar->red   = (struct fb_bitfield) {11, 5, 0};\n\t\tvar->green = (struct fb_bitfield) {5, 6, 0};\n\t\tvar->blue  = (struct fb_bitfield) {0, 5, 0};\n\t\tvar->transp = (struct fb_bitfield) {0, 0, 0};\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tvar->red   = (struct fb_bitfield) {16, 8, 0};\n\t\tvar->green = (struct fb_bitfield) {8, 8, 0};\n\t\tvar->blue  = (struct fb_bitfield) {0, 8, 0};\n\t\tvar->transp = (struct fb_bitfield) {24, 8, 0};\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int grvga_set_par(struct fb_info *info)\n{\n\n\tu32 func = 0;\n\tstruct grvga_par *par = info->par;\n\n\t__raw_writel(((info->var.yres - 1) << 16) | (info->var.xres - 1),\n\t\t     &par->regs->video_length);\n\n\t__raw_writel((info->var.lower_margin << 16) | (info->var.right_margin),\n\t\t     &par->regs->front_porch);\n\n\t__raw_writel((info->var.vsync_len << 16) | (info->var.hsync_len),\n\t\t     &par->regs->sync_length);\n\n\t__raw_writel(((info->var.yres + info->var.lower_margin + info->var.upper_margin + info->var.vsync_len - 1) << 16) |\n\t\t     (info->var.xres + info->var.right_margin + info->var.left_margin + info->var.hsync_len - 1),\n\t\t     &par->regs->line_length);\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tfunc = 1;\n\t\tbreak;\n\tcase 16:\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tfunc = 2;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tfunc = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t__raw_writel((par->clk_sel << 6) | (func << 4) | 1,\n\t\t     &par->regs->status);\n\n\tinfo->fix.line_length = (info->var.xres_virtual*info->var.bits_per_pixel)/8;\n\treturn 0;\n}\n\nstatic int grvga_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)\n{\n\tstruct grvga_par *par;\n\tpar = info->par;\n\n\tif (regno >= 256)\t \n\t\treturn -EINVAL;\n\n\tif (info->var.grayscale) {\n\t\t \n\t\tred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n\t}\n\n\n\n#define CNVT_TOHW(val, width) ((((val)<<(width))+0x7FFF-(val))>>16)\n\n\tred    = CNVT_TOHW(red,   info->var.red.length);\n\tgreen  = CNVT_TOHW(green, info->var.green.length);\n\tblue   = CNVT_TOHW(blue,  info->var.blue.length);\n\ttransp = CNVT_TOHW(transp, info->var.transp.length);\n\n#undef CNVT_TOHW\n\n\t \n\tif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR)\n\t\t__raw_writel((regno << 24) | (red << 16) | (green << 8) | blue,\n\t\t\t     &par->regs->clut);\n\n\t \n\telse if (info->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\tu32 v;\n\t\tif (regno >= 16)\n\t\t\treturn -EINVAL;\n\n\n\t\tv =     (red    << info->var.red.offset)   |\n\t\t\t(green  << info->var.green.offset) |\n\t\t\t(blue   << info->var.blue.offset)  |\n\t\t\t(transp << info->var.transp.offset);\n\n\t\t((u32 *) (info->pseudo_palette))[regno] = v;\n\t}\n\treturn 0;\n}\n\nstatic int grvga_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tstruct grvga_par *par = info->par;\n\tstruct fb_fix_screeninfo *fix = &info->fix;\n\tu32 base_addr;\n\n\tif (var->xoffset != 0)\n\t\treturn -EINVAL;\n\n\tbase_addr = fix->smem_start + (var->yoffset * fix->line_length);\n\tbase_addr &= ~3UL;\n\n\t \n\t__raw_writel(base_addr,\n\t\t     &par->regs->fb_pos);\n\n\treturn 0;\n}\n\nstatic const struct fb_ops grvga_ops = {\n\t.owner          = THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var   = grvga_check_var,\n\t.fb_set_par\t= grvga_set_par,\n\t.fb_setcolreg   = grvga_setcolreg,\n\t.fb_pan_display = grvga_pan_display,\n};\n\nstatic int grvga_parse_custom(char *options,\n\t\t\t      struct fb_var_screeninfo *screendata)\n{\n\tchar *this_opt;\n\tint count = 0;\n\tif (!options || !*options)\n\t\treturn -1;\n\n\twhile ((this_opt = strsep(&options, \" \")) != NULL) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\n\t\tswitch (count) {\n\t\tcase 0:\n\t\t\tscreendata->pixclock = simple_strtoul(this_opt, NULL, 0);\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscreendata->xres = screendata->xres_virtual = simple_strtoul(this_opt, NULL, 0);\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tscreendata->right_margin = simple_strtoul(this_opt, NULL, 0);\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tscreendata->hsync_len = simple_strtoul(this_opt, NULL, 0);\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tscreendata->left_margin = simple_strtoul(this_opt, NULL, 0);\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tscreendata->yres = screendata->yres_virtual = simple_strtoul(this_opt, NULL, 0);\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tscreendata->lower_margin = simple_strtoul(this_opt, NULL, 0);\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tscreendata->vsync_len = simple_strtoul(this_opt, NULL, 0);\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tscreendata->upper_margin = simple_strtoul(this_opt, NULL, 0);\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tscreendata->bits_per_pixel = simple_strtoul(this_opt, NULL, 0);\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\tscreendata->activate  = FB_ACTIVATE_NOW;\n\tscreendata->vmode     = FB_VMODE_NONINTERLACED;\n\treturn 0;\n}\n\nstatic int grvga_probe(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\tint retval = -ENOMEM;\n\tunsigned long virtual_start;\n\tunsigned long grvga_fix_addr = 0;\n\tunsigned long physical_start = 0;\n\tunsigned long grvga_mem_size = 0;\n\tstruct grvga_par *par = NULL;\n\tchar *options = NULL, *mode_opt = NULL;\n\n\tinfo = framebuffer_alloc(sizeof(struct grvga_par), &dev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\t \n\tif (fb_get_options(\"grvga\", &options)) {\n\t\tretval = -ENODEV;\n\t\tgoto free_fb;\n\t}\n\n\tif (!options || !*options)\n\t\toptions =  \"640x480-8@60\";\n\n\twhile (1) {\n\t\tchar *this_opt = strsep(&options, \",\");\n\n\t\tif (!this_opt)\n\t\t\tbreak;\n\n\t\tif (!strncmp(this_opt, \"custom\", 6)) {\n\t\t\tif (grvga_parse_custom(this_opt, &info->var) < 0) {\n\t\t\t\tdev_err(&dev->dev, \"Failed to parse custom mode (%s).\\n\", this_opt);\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto free_fb;\n\t\t\t}\n\t\t} else if (!strncmp(this_opt, \"addr\", 4))\n\t\t\tgrvga_fix_addr = simple_strtoul(this_opt + 5, NULL, 16);\n\t\telse if (!strncmp(this_opt, \"size\", 4))\n\t\t\tgrvga_mem_size = simple_strtoul(this_opt + 5, NULL, 0);\n\t\telse\n\t\t\tmode_opt = this_opt;\n\t}\n\n\tpar = info->par;\n\tinfo->fbops = &grvga_ops;\n\tinfo->fix = grvga_fix;\n\tinfo->pseudo_palette = par->color_palette;\n\tinfo->flags = FBINFO_PARTIAL_PAN_OK | FBINFO_HWACCEL_YPAN;\n\tinfo->fix.smem_len = grvga_mem_size;\n\n\tif (!devm_request_mem_region(&dev->dev, dev->resource[0].start,\n\t\t    resource_size(&dev->resource[0]), \"grlib-svgactrl regs\")) {\n\t\tdev_err(&dev->dev, \"registers already mapped\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto free_fb;\n\t}\n\n\tpar->regs = of_ioremap(&dev->resource[0], 0,\n\t\t\t       resource_size(&dev->resource[0]),\n\t\t\t       \"grlib-svgactrl regs\");\n\n\tif (!par->regs) {\n\t\tdev_err(&dev->dev, \"failed to map registers\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto free_fb;\n\t}\n\n\tretval = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (retval < 0) {\n\t\tdev_err(&dev->dev, \"failed to allocate mem with fb_alloc_cmap\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto unmap_regs;\n\t}\n\n\tif (mode_opt) {\n\t\tretval = fb_find_mode(&info->var, info, mode_opt,\n\t\t\t\t      grvga_modedb, sizeof(grvga_modedb), &grvga_modedb[0], 8);\n\t\tif (!retval || retval == 4) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto dealloc_cmap;\n\t\t}\n\t}\n\n\tif (!grvga_mem_size)\n\t\tgrvga_mem_size = info->var.xres_virtual * info->var.yres_virtual * info->var.bits_per_pixel/8;\n\n\tif (grvga_fix_addr) {\n\t\t \n\n\t\tphysical_start = grvga_fix_addr;\n\n\t\tif (!devm_request_mem_region(&dev->dev, physical_start,\n\t\t\t\t\t     grvga_mem_size, dev->name)) {\n\t\t\tdev_err(&dev->dev, \"failed to request memory region\\n\");\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto dealloc_cmap;\n\t\t}\n\n\t\tvirtual_start = (unsigned long) ioremap(physical_start, grvga_mem_size);\n\n\t\tif (!virtual_start) {\n\t\t\tdev_err(&dev->dev, \"error mapping framebuffer memory\\n\");\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto dealloc_cmap;\n\t\t}\n\t} else {\t \n\n\t\tunsigned long page;\n\n\t\tvirtual_start = (unsigned long) __get_free_pages(GFP_DMA,\n\t\t\t\t\t\t\t\t get_order(grvga_mem_size));\n\t\tif (!virtual_start) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"unable to allocate framebuffer memory (%lu bytes)\\n\",\n\t\t\t\tgrvga_mem_size);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto dealloc_cmap;\n\t\t}\n\n\t\tphysical_start = dma_map_single(&dev->dev, (void *)virtual_start, grvga_mem_size, DMA_TO_DEVICE);\n\n\t\t \n\t\tfor (page = virtual_start;\n\t\t     page < PAGE_ALIGN(virtual_start + grvga_mem_size);\n\t\t     page += PAGE_SIZE) {\n\t\t\tSetPageReserved(virt_to_page(page));\n\t\t}\n\n\t\tpar->fb_alloced = 1;\n\t}\n\n\tmemset((unsigned long *) virtual_start, 0, grvga_mem_size);\n\n\tinfo->screen_base = (char __iomem *) virtual_start;\n\tinfo->fix.smem_start = physical_start;\n\tinfo->fix.smem_len   = grvga_mem_size;\n\n\tdev_set_drvdata(&dev->dev, info);\n\n\tdev_info(&dev->dev,\n\t\t \"Aeroflex Gaisler framebuffer device (fb%d), %dx%d-%d, using %luK of video memory @ %p\\n\",\n\t\t info->node, info->var.xres, info->var.yres, info->var.bits_per_pixel,\n\t\t grvga_mem_size >> 10, info->screen_base);\n\n\tretval = register_framebuffer(info);\n\tif (retval < 0) {\n\t\tdev_err(&dev->dev, \"failed to register framebuffer\\n\");\n\t\tgoto free_mem;\n\t}\n\n\t__raw_writel(physical_start, &par->regs->fb_pos);\n\t__raw_writel(__raw_readl(&par->regs->status) | 1,   \n\t\t     &par->regs->status);\n\n\treturn 0;\n\nfree_mem:\n\tif (grvga_fix_addr)\n\t\tiounmap((void *)virtual_start);\n\telse\n\t\tkfree((void *)virtual_start);\ndealloc_cmap:\n\tfb_dealloc_cmap(&info->cmap);\nunmap_regs:\n\tof_iounmap(&dev->resource[0], par->regs,\n\t\t   resource_size(&dev->resource[0]));\nfree_fb:\n\tframebuffer_release(info);\n\n\treturn retval;\n}\n\nstatic void grvga_remove(struct platform_device *device)\n{\n\tstruct fb_info *info = dev_get_drvdata(&device->dev);\n\tstruct grvga_par *par;\n\n\tif (info) {\n\t\tpar = info->par;\n\t\tunregister_framebuffer(info);\n\t\tfb_dealloc_cmap(&info->cmap);\n\n\t\tof_iounmap(&device->resource[0], par->regs,\n\t\t\t   resource_size(&device->resource[0]));\n\n\t\tif (!par->fb_alloced)\n\t\t\tiounmap(info->screen_base);\n\t\telse\n\t\t\tkfree((void *)info->screen_base);\n\n\t\tframebuffer_release(info);\n\t}\n}\n\nstatic struct of_device_id svgactrl_of_match[] = {\n\t{\n\t\t.name = \"GAISLER_SVGACTRL\",\n\t},\n\t{\n\t\t.name = \"01_063\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, svgactrl_of_match);\n\nstatic struct platform_driver grvga_driver = {\n\t.driver = {\n\t\t.name = \"grlib-svgactrl\",\n\t\t.of_match_table = svgactrl_of_match,\n\t},\n\t.probe\t\t= grvga_probe,\n\t.remove_new\t= grvga_remove,\n};\n\nmodule_platform_driver(grvga_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Aeroflex Gaisler\");\nMODULE_DESCRIPTION(\"Aeroflex Gaisler framebuffer device driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}