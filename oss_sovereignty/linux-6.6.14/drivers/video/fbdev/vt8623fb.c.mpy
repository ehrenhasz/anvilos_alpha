{
  "module_name": "vt8623fb.c",
  "hash_id": "1ac039cfa9e3fc20166f0b28a61b7ca0918a13bf048333f0abba9c89f2990eb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/vt8623fb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/tty.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/svga.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/console.h>  \n#include <video/vga.h>\n\nstruct vt8623fb_info {\n\tchar __iomem *mmio_base;\n\tint wc_cookie;\n\tstruct vgastate state;\n\tstruct mutex open_lock;\n\tunsigned int ref_count;\n\tu32 pseudo_palette[16];\n};\n\n\n\n \n\nstatic const struct svga_fb_format vt8623fb_formats[] = {\n\t{ 0,  {0, 6, 0},  {0, 6, 0},  {0, 6, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_TEXT, FB_AUX_TEXT_SVGA_STEP8,\tFB_VISUAL_PSEUDOCOLOR, 16, 16},\n\t{ 4,  {0, 6, 0},  {0, 6, 0},  {0, 6, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_PSEUDOCOLOR, 16, 16},\n\t{ 4,  {0, 6, 0},  {0, 6, 0},  {0, 6, 0}, {0, 0, 0}, 1,\n\t\tFB_TYPE_INTERLEAVED_PLANES, 1,\t\tFB_VISUAL_PSEUDOCOLOR, 16, 16},\n\t{ 8,  {0, 6, 0},  {0, 6, 0},  {0, 6, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_PSEUDOCOLOR, 8, 8},\n \n\t{16,  {11, 5, 0}, {5, 6, 0},  {0, 5, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_TRUECOLOR, 4, 4},\n\t{32,  {16, 8, 0}, {8, 8, 0},  {0, 8, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_TRUECOLOR, 2, 2},\n\tSVGA_FORMAT_END\n};\n\nstatic const struct svga_pll vt8623_pll = {2, 127, 2, 7, 0, 3,\n\t60000, 300000, 14318};\n\n \n\nstatic const struct vga_regset vt8623_h_total_regs[]       = {{0x00, 0, 7}, {0x36, 3, 3}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_h_display_regs[]     = {{0x01, 0, 7}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_h_blank_start_regs[] = {{0x02, 0, 7}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_h_blank_end_regs[]   = {{0x03, 0, 4}, {0x05, 7, 7}, {0x33, 5, 5}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_h_sync_start_regs[]  = {{0x04, 0, 7}, {0x33, 4, 4}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_h_sync_end_regs[]    = {{0x05, 0, 4}, VGA_REGSET_END};\n\nstatic const struct vga_regset vt8623_v_total_regs[]       = {{0x06, 0, 7}, {0x07, 0, 0}, {0x07, 5, 5}, {0x35, 0, 0}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_v_display_regs[]     = {{0x12, 0, 7}, {0x07, 1, 1}, {0x07, 6, 6}, {0x35, 2, 2}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_v_blank_start_regs[] = {{0x15, 0, 7}, {0x07, 3, 3}, {0x09, 5, 5}, {0x35, 3, 3}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_v_blank_end_regs[]   = {{0x16, 0, 7}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_v_sync_start_regs[]  = {{0x10, 0, 7}, {0x07, 2, 2}, {0x07, 7, 7}, {0x35, 1, 1}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_v_sync_end_regs[]    = {{0x11, 0, 3}, VGA_REGSET_END};\n\nstatic const struct vga_regset vt8623_offset_regs[]        = {{0x13, 0, 7}, {0x35, 5, 7}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_line_compare_regs[]  = {{0x18, 0, 7}, {0x07, 4, 4}, {0x09, 6, 6}, {0x33, 0, 2}, {0x35, 4, 4}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_fetch_count_regs[]   = {{0x1C, 0, 7}, {0x1D, 0, 1}, VGA_REGSET_END};\nstatic const struct vga_regset vt8623_start_address_regs[] = {{0x0d, 0, 7}, {0x0c, 0, 7}, {0x34, 0, 7}, {0x48, 0, 1}, VGA_REGSET_END};\n\nstatic const struct svga_timing_regs vt8623_timing_regs     = {\n\tvt8623_h_total_regs, vt8623_h_display_regs, vt8623_h_blank_start_regs,\n\tvt8623_h_blank_end_regs, vt8623_h_sync_start_regs, vt8623_h_sync_end_regs,\n\tvt8623_v_total_regs, vt8623_v_display_regs, vt8623_v_blank_start_regs,\n\tvt8623_v_blank_end_regs, vt8623_v_sync_start_regs, vt8623_v_sync_end_regs,\n};\n\n\n \n\n\n \n\nstatic char *mode_option = \"640x480-8@60\";\nstatic int mtrr = 1;\n\nMODULE_AUTHOR(\"(c) 2006 Ondrej Zajicek <santiago@crfreenet.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"fbdev driver for integrated graphics core in VIA VT8623 [CLE266]\");\n\nmodule_param(mode_option, charp, 0644);\nMODULE_PARM_DESC(mode_option, \"Default video mode ('640x480-8@60', etc)\");\nmodule_param_named(mode, mode_option, charp, 0);\nMODULE_PARM_DESC(mode, \"Default video mode e.g. '648x480-8@60' (deprecated)\");\nmodule_param(mtrr, int, 0444);\nMODULE_PARM_DESC(mtrr, \"Enable write-combining with MTRR (1=enable, 0=disable, default=1)\");\n\n\n \n\nstatic void vt8623fb_tilecursor(struct fb_info *info, struct fb_tilecursor *cursor)\n{\n\tstruct vt8623fb_info *par = info->par;\n\n\tsvga_tilecursor(par->state.vgabase, info, cursor);\n}\n\nstatic struct fb_tile_ops vt8623fb_tile_ops = {\n\t.fb_settile\t= svga_settile,\n\t.fb_tilecopy\t= svga_tilecopy,\n\t.fb_tilefill    = svga_tilefill,\n\t.fb_tileblit    = svga_tileblit,\n\t.fb_tilecursor  = vt8623fb_tilecursor,\n\t.fb_get_tilemax = svga_get_tilemax,\n};\n\n\n \n\n\n \nstatic inline u32 expand_color(u32 c)\n{\n\treturn ((c & 1) | ((c & 2) << 7) | ((c & 4) << 14) | ((c & 8) << 21)) * 0xFF;\n}\n\n \nstatic void vt8623fb_iplan_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tu32 fg = expand_color(image->fg_color);\n\tu32 bg = expand_color(image->bg_color);\n\tconst u8 *src1, *src;\n\tu8 __iomem *dst1;\n\tu32 __iomem *dst;\n\tu32 val;\n\tint x, y;\n\n\tsrc1 = image->data;\n\tdst1 = info->screen_base + (image->dy * info->fix.line_length)\n\t\t + ((image->dx / 8) * 4);\n\n\tfor (y = 0; y < image->height; y++) {\n\t\tsrc = src1;\n\t\tdst = (u32 __iomem *) dst1;\n\t\tfor (x = 0; x < image->width; x += 8) {\n\t\t\tval = *(src++) * 0x01010101;\n\t\t\tval = (val & fg) | (~val & bg);\n\t\t\tfb_writel(val, dst++);\n\t\t}\n\t\tsrc1 += image->width / 8;\n\t\tdst1 += info->fix.line_length;\n\t}\n}\n\n \nstatic void vt8623fb_iplan_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tu32 fg = expand_color(rect->color);\n\tu8 __iomem *dst1;\n\tu32 __iomem *dst;\n\tint x, y;\n\n\tdst1 = info->screen_base + (rect->dy * info->fix.line_length)\n\t\t + ((rect->dx / 8) * 4);\n\n\tfor (y = 0; y < rect->height; y++) {\n\t\tdst = (u32 __iomem *) dst1;\n\t\tfor (x = 0; x < rect->width; x += 8) {\n\t\t\tfb_writel(fg, dst++);\n\t\t}\n\t\tdst1 += info->fix.line_length;\n\t}\n}\n\n\n \nstatic inline u32 expand_pixel(u32 c)\n{\n\treturn (((c &  1) << 24) | ((c &  2) << 27) | ((c &  4) << 14) | ((c &   8) << 17) |\n\t\t((c & 16) <<  4) | ((c & 32) <<  7) | ((c & 64) >>  6) | ((c & 128) >>  3)) * 0xF;\n}\n\n \nstatic void vt8623fb_cfb4_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tu32 fg = image->fg_color * 0x11111111;\n\tu32 bg = image->bg_color * 0x11111111;\n\tconst u8 *src1, *src;\n\tu8 __iomem *dst1;\n\tu32 __iomem *dst;\n\tu32 val;\n\tint x, y;\n\n\tsrc1 = image->data;\n\tdst1 = info->screen_base + (image->dy * info->fix.line_length)\n\t\t + ((image->dx / 8) * 4);\n\n\tfor (y = 0; y < image->height; y++) {\n\t\tsrc = src1;\n\t\tdst = (u32 __iomem *) dst1;\n\t\tfor (x = 0; x < image->width; x += 8) {\n\t\t\tval = expand_pixel(*(src++));\n\t\t\tval = (val & fg) | (~val & bg);\n\t\t\tfb_writel(val, dst++);\n\t\t}\n\t\tsrc1 += image->width / 8;\n\t\tdst1 += info->fix.line_length;\n\t}\n}\n\nstatic void vt8623fb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tif ((info->var.bits_per_pixel == 4) && (image->depth == 1)\n\t    && ((image->width % 8) == 0) && ((image->dx % 8) == 0)) {\n\t\tif (info->fix.type == FB_TYPE_INTERLEAVED_PLANES)\n\t\t\tvt8623fb_iplan_imageblit(info, image);\n\t\telse\n\t\t\tvt8623fb_cfb4_imageblit(info, image);\n\t} else\n\t\tcfb_imageblit(info, image);\n}\n\nstatic void vt8623fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tif ((info->var.bits_per_pixel == 4)\n\t    && ((rect->width % 8) == 0) && ((rect->dx % 8) == 0)\n\t    && (info->fix.type == FB_TYPE_INTERLEAVED_PLANES))\n\t\tvt8623fb_iplan_fillrect(info, rect);\n\t else\n\t\tcfb_fillrect(info, rect);\n}\n\n\n \n\n\nstatic void vt8623_set_pixclock(struct fb_info *info, u32 pixclock)\n{\n\tstruct vt8623fb_info *par = info->par;\n\tu16 m, n, r;\n\tu8 regval;\n\tint rv;\n\n\trv = svga_compute_pll(&vt8623_pll, 1000000000 / pixclock, &m, &n, &r, info->node);\n\tif (rv < 0) {\n\t\tfb_err(info, \"cannot set requested pixclock, keeping old value\\n\");\n\t\treturn;\n\t}\n\n\t \n\tregval = vga_r(par->state.vgabase, VGA_MIS_R);\n\tvga_w(par->state.vgabase, VGA_MIS_W, regval | VGA_MIS_ENB_PLL_LOAD);\n\n\t \n\tvga_wseq(par->state.vgabase, 0x46, (n  | (r << 6)));\n\tvga_wseq(par->state.vgabase, 0x47, m);\n\n\tudelay(1000);\n\n\t \n\tsvga_wseq_mask(par->state.vgabase, 0x40, 0x02, 0x02);\n\tsvga_wseq_mask(par->state.vgabase, 0x40, 0x00, 0x02);\n}\n\n\nstatic int vt8623fb_open(struct fb_info *info, int user)\n{\n\tstruct vt8623fb_info *par = info->par;\n\n\tmutex_lock(&(par->open_lock));\n\tif (par->ref_count == 0) {\n\t\tvoid __iomem *vgabase = par->state.vgabase;\n\n\t\tmemset(&(par->state), 0, sizeof(struct vgastate));\n\t\tpar->state.vgabase = vgabase;\n\t\tpar->state.flags = VGA_SAVE_MODE | VGA_SAVE_FONTS | VGA_SAVE_CMAP;\n\t\tpar->state.num_crtc = 0xA2;\n\t\tpar->state.num_seq = 0x50;\n\t\tsave_vga(&(par->state));\n\t}\n\n\tpar->ref_count++;\n\tmutex_unlock(&(par->open_lock));\n\n\treturn 0;\n}\n\nstatic int vt8623fb_release(struct fb_info *info, int user)\n{\n\tstruct vt8623fb_info *par = info->par;\n\n\tmutex_lock(&(par->open_lock));\n\tif (par->ref_count == 0) {\n\t\tmutex_unlock(&(par->open_lock));\n\t\treturn -EINVAL;\n\t}\n\n\tif (par->ref_count == 1)\n\t\trestore_vga(&(par->state));\n\n\tpar->ref_count--;\n\tmutex_unlock(&(par->open_lock));\n\n\treturn 0;\n}\n\nstatic int vt8623fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tint rv, mem, step;\n\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\t \n\trv = svga_match_format (vt8623fb_formats, var, NULL);\n\tif (rv < 0)\n\t{\n\t\tfb_err(info, \"unsupported mode requested\\n\");\n\t\treturn rv;\n\t}\n\n\t \n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\n\t \n\tstep = vt8623fb_formats[rv].xresstep - 1;\n\tvar->xres_virtual = (var->xres_virtual+step) & ~step;\n\n\t \n\tmem = ((var->bits_per_pixel * var->xres_virtual) >> 3) * var->yres_virtual;\n\tif (mem > info->screen_size)\n\t{\n\t\tfb_err(info, \"not enough framebuffer memory (%d kB requested, %d kB available)\\n\",\n\t\t       mem >> 10, (unsigned int) (info->screen_size >> 10));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((var->bits_per_pixel == 0) && (mem > (256*1024)))\n\t{\n\t\tfb_err(info, \"text framebuffer size too large (%d kB requested, 256 kB possible)\\n\",\n\t\t       mem >> 10);\n\t\treturn -EINVAL;\n\t}\n\n\trv = svga_check_timings (&vt8623_timing_regs, var, info->node);\n\tif (rv < 0)\n\t{\n\t\tfb_err(info, \"invalid timings requested\\n\");\n\t\treturn rv;\n\t}\n\n\t \n\tif (var->vmode & FB_VMODE_INTERLACED)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n\nstatic int vt8623fb_set_par(struct fb_info *info)\n{\n\tu32 mode, offset_value, fetch_value, screen_size;\n\tstruct vt8623fb_info *par = info->par;\n\tu32 bpp = info->var.bits_per_pixel;\n\n\tif (bpp != 0) {\n\t\tinfo->fix.ypanstep = 1;\n\t\tinfo->fix.line_length = (info->var.xres_virtual * bpp) / 8;\n\n\t\tinfo->flags &= ~FBINFO_MISC_TILEBLITTING;\n\t\tinfo->tileops = NULL;\n\n\t\t \n\t\tinfo->pixmap.blit_x = (bpp == 4) ? (1 << (8 - 1)) : (~(u32)0);\n\t\tinfo->pixmap.blit_y = ~(u32)0;\n\n\t\toffset_value = (info->var.xres_virtual * bpp) / 64;\n\t\tfetch_value  = ((info->var.xres * bpp) / 128) + 4;\n\n\t\tif (bpp == 4)\n\t\t\tfetch_value  = (info->var.xres / 8) + 8;  \n\n\t\tscreen_size  = info->var.yres_virtual * info->fix.line_length;\n\t} else {\n\t\tinfo->fix.ypanstep = 16;\n\t\tinfo->fix.line_length = 0;\n\n\t\tinfo->flags |= FBINFO_MISC_TILEBLITTING;\n\t\tinfo->tileops = &vt8623fb_tile_ops;\n\n\t\t \n\t\tinfo->pixmap.blit_x = 1 << (8 - 1);\n\t\tinfo->pixmap.blit_y = 1 << (16 - 1);\n\n\t\toffset_value = info->var.xres_virtual / 16;\n\t\tfetch_value  = (info->var.xres / 8) + 8;\n\t\tscreen_size  = (info->var.xres_virtual * info->var.yres_virtual) / 64;\n\t}\n\n\tinfo->var.xoffset = 0;\n\tinfo->var.yoffset = 0;\n\tinfo->var.activate = FB_ACTIVATE_NOW;\n\n\t \n\tsvga_wseq_mask(par->state.vgabase, 0x10, 0x01, 0x01);\n\tsvga_wcrt_mask(par->state.vgabase, 0x11, 0x00, 0x80);\n\tsvga_wcrt_mask(par->state.vgabase, 0x47, 0x00, 0x01);\n\n\t \n\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\tsvga_wcrt_mask(par->state.vgabase, 0x36, 0x30, 0x30);\n\tsvga_wcrt_mask(par->state.vgabase, 0x17, 0x00, 0x80);\n\n\t \n\tsvga_set_default_gfx_regs(par->state.vgabase);\n\tsvga_set_default_atc_regs(par->state.vgabase);\n\tsvga_set_default_seq_regs(par->state.vgabase);\n\tsvga_set_default_crt_regs(par->state.vgabase);\n\tsvga_wcrt_multi(par->state.vgabase, vt8623_line_compare_regs, 0xFFFFFFFF);\n\tsvga_wcrt_multi(par->state.vgabase, vt8623_start_address_regs, 0);\n\n\tsvga_wcrt_multi(par->state.vgabase, vt8623_offset_regs, offset_value);\n\tsvga_wseq_multi(par->state.vgabase, vt8623_fetch_count_regs, fetch_value);\n\n\t \n\tsvga_wcrt_mask(par->state.vgabase, 0x03, 0x00, 0x60);\n\tsvga_wcrt_mask(par->state.vgabase, 0x05, 0x00, 0x60);\n\n\tif (info->var.vmode & FB_VMODE_DOUBLE)\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x09, 0x80, 0x80);\n\telse\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x09, 0x00, 0x80);\n\n\tsvga_wseq_mask(par->state.vgabase, 0x1E, 0xF0, 0xF0);  \n\tsvga_wseq_mask(par->state.vgabase, 0x2A, 0x0F, 0x0F);  \n\tsvga_wseq_mask(par->state.vgabase, 0x16, 0x08, 0xBF);  \n\tvga_wseq(par->state.vgabase, 0x17, 0x1F);        \n\tvga_wseq(par->state.vgabase, 0x18, 0x4E);\n\tsvga_wseq_mask(par->state.vgabase, 0x1A, 0x08, 0x08);  \n\n\tvga_wcrt(par->state.vgabase, 0x32, 0x00);\n\tvga_wcrt(par->state.vgabase, 0x34, 0x00);\n\tvga_wcrt(par->state.vgabase, 0x6A, 0x80);\n\tvga_wcrt(par->state.vgabase, 0x6A, 0xC0);\n\n\tvga_wgfx(par->state.vgabase, 0x20, 0x00);\n\tvga_wgfx(par->state.vgabase, 0x21, 0x00);\n\tvga_wgfx(par->state.vgabase, 0x22, 0x00);\n\n\t \n\tmode = svga_match_format(vt8623fb_formats, &(info->var), &(info->fix));\n\tswitch (mode) {\n\tcase 0:\n\t\tfb_dbg(info, \"text mode\\n\");\n\t\tsvga_set_textmode_vga_regs(par->state.vgabase);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x15, 0x00, 0xFE);\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x11, 0x60, 0x70);\n\t\tbreak;\n\tcase 1:\n\t\tfb_dbg(info, \"4 bit pseudocolor\\n\");\n\t\tvga_wgfx(par->state.vgabase, VGA_GFX_MODE, 0x40);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x15, 0x20, 0xFE);\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x11, 0x00, 0x70);\n\t\tbreak;\n\tcase 2:\n\t\tfb_dbg(info, \"4 bit pseudocolor, planar\\n\");\n\t\tsvga_wseq_mask(par->state.vgabase, 0x15, 0x00, 0xFE);\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x11, 0x00, 0x70);\n\t\tbreak;\n\tcase 3:\n\t\tfb_dbg(info, \"8 bit pseudocolor\\n\");\n\t\tsvga_wseq_mask(par->state.vgabase, 0x15, 0x22, 0xFE);\n\t\tbreak;\n\tcase 4:\n\t\tfb_dbg(info, \"5/6/5 truecolor\\n\");\n\t\tsvga_wseq_mask(par->state.vgabase, 0x15, 0xB6, 0xFE);\n\t\tbreak;\n\tcase 5:\n\t\tfb_dbg(info, \"8/8/8 truecolor\\n\");\n\t\tsvga_wseq_mask(par->state.vgabase, 0x15, 0xAE, 0xFE);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"vt8623fb: unsupported mode - bug\\n\");\n\t\treturn (-EINVAL);\n\t}\n\n\tvt8623_set_pixclock(info, info->var.pixclock);\n\tsvga_set_timings(par->state.vgabase, &vt8623_timing_regs, &(info->var), 1, 1,\n\t\t\t (info->var.vmode & FB_VMODE_DOUBLE) ? 2 : 1, 1,\n\t\t\t 1, info->node);\n\n\tif (screen_size > info->screen_size)\n\t\tscreen_size = info->screen_size;\n\tmemset_io(info->screen_base, 0x00, screen_size);\n\n\t \n\tsvga_wcrt_mask(par->state.vgabase, 0x17, 0x80, 0x80);\n\tsvga_wcrt_mask(par->state.vgabase, 0x36, 0x00, 0x30);\n\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x00, 0x20);\n\n\treturn 0;\n}\n\n\nstatic int vt8623fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t\tu_int transp, struct fb_info *fb)\n{\n\tswitch (fb->var.bits_per_pixel) {\n\tcase 0:\n\tcase 4:\n\t\tif (regno >= 16)\n\t\t\treturn -EINVAL;\n\n\t\toutb(0x0F, VGA_PEL_MSK);\n\t\toutb(regno, VGA_PEL_IW);\n\t\toutb(red >> 10, VGA_PEL_D);\n\t\toutb(green >> 10, VGA_PEL_D);\n\t\toutb(blue >> 10, VGA_PEL_D);\n\t\tbreak;\n\tcase 8:\n\t\tif (regno >= 256)\n\t\t\treturn -EINVAL;\n\n\t\toutb(0xFF, VGA_PEL_MSK);\n\t\toutb(regno, VGA_PEL_IW);\n\t\toutb(red >> 10, VGA_PEL_D);\n\t\toutb(green >> 10, VGA_PEL_D);\n\t\toutb(blue >> 10, VGA_PEL_D);\n\t\tbreak;\n\tcase 16:\n\t\tif (regno >= 16)\n\t\t\treturn 0;\n\n\t\tif (fb->var.green.length == 5)\n\t\t\t((u32*)fb->pseudo_palette)[regno] = ((red & 0xF800) >> 1) |\n\t\t\t\t((green & 0xF800) >> 6) | ((blue & 0xF800) >> 11);\n\t\telse if (fb->var.green.length == 6)\n\t\t\t((u32*)fb->pseudo_palette)[regno] = (red & 0xF800) |\n\t\t\t\t((green & 0xFC00) >> 5) | ((blue & 0xF800) >> 11);\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tif (regno >= 16)\n\t\t\treturn 0;\n\n\t\t \n\t\t((u32*)fb->pseudo_palette)[regno] = ((red & 0xFF00) << 8) |\n\t\t\t(green & 0xFF00) | ((blue & 0xFF00) >> 8);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int vt8623fb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct vt8623fb_info *par = info->par;\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\tfb_dbg(info, \"unblank\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x36, 0x00, 0x30);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x00, 0x20);\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\tfb_dbg(info, \"blank\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x36, 0x00, 0x30);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tfb_dbg(info, \"DPMS standby (hsync off)\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x36, 0x10, 0x30);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tfb_dbg(info, \"DPMS suspend (vsync off)\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x36, 0x20, 0x30);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tfb_dbg(info, \"DPMS off (no sync)\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x36, 0x30, 0x30);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int vt8623fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct vt8623fb_info *par = info->par;\n\tunsigned int offset;\n\n\t \n\tif (info->var.bits_per_pixel == 0) {\n\t\toffset = (var->yoffset / 16) * info->var.xres_virtual\n\t\t       + var->xoffset;\n\t\toffset = offset >> 3;\n\t} else {\n\t\toffset = (var->yoffset * info->fix.line_length) +\n\t\t\t (var->xoffset * info->var.bits_per_pixel / 8);\n\t\toffset = offset >> ((info->var.bits_per_pixel == 4) ? 2 : 1);\n\t}\n\n\t \n\tsvga_wcrt_multi(par->state.vgabase, vt8623_start_address_regs, offset);\n\n\treturn 0;\n}\n\n\n \n\n\n \n\nstatic const struct fb_ops vt8623fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= vt8623fb_open,\n\t.fb_release\t= vt8623fb_release,\n\t.fb_check_var\t= vt8623fb_check_var,\n\t.fb_set_par\t= vt8623fb_set_par,\n\t.fb_setcolreg\t= vt8623fb_setcolreg,\n\t.fb_blank\t= vt8623fb_blank,\n\t.fb_pan_display\t= vt8623fb_pan_display,\n\t.fb_fillrect\t= vt8623fb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= vt8623fb_imageblit,\n\t.fb_get_caps    = svga_get_caps,\n};\n\n\n \n\nstatic int vt8623_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct pci_bus_region bus_reg;\n\tstruct resource vga_res;\n\tstruct fb_info *info;\n\tstruct vt8623fb_info *par;\n\tunsigned int memsize1, memsize2;\n\tint rc;\n\n\t \n\tif (! svga_primary_device(dev)) {\n\t\tdev_info(&(dev->dev), \"ignoring secondary device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trc = aperture_remove_conflicting_pci_devices(dev, \"vt8623fb\");\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tinfo = framebuffer_alloc(sizeof(struct vt8623fb_info), &(dev->dev));\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tmutex_init(&par->open_lock);\n\n\tinfo->flags = FBINFO_PARTIAL_PAN_OK | FBINFO_HWACCEL_YPAN;\n\tinfo->fbops = &vt8623fb_ops;\n\n\t \n\n\trc = pci_enable_device(dev);\n\tif (rc < 0) {\n\t\tdev_err(info->device, \"cannot enable PCI device\\n\");\n\t\tgoto err_enable_device;\n\t}\n\n\trc = pci_request_regions(dev, \"vt8623fb\");\n\tif (rc < 0) {\n\t\tdev_err(info->device, \"cannot reserve framebuffer region\\n\");\n\t\tgoto err_request_regions;\n\t}\n\n\tinfo->fix.smem_start = pci_resource_start(dev, 0);\n\tinfo->fix.smem_len = pci_resource_len(dev, 0);\n\tinfo->fix.mmio_start = pci_resource_start(dev, 1);\n\tinfo->fix.mmio_len = pci_resource_len(dev, 1);\n\n\t \n\tinfo->screen_base = pci_iomap_wc(dev, 0, 0);\n\tif (! info->screen_base) {\n\t\trc = -ENOMEM;\n\t\tdev_err(info->device, \"iomap for framebuffer failed\\n\");\n\t\tgoto err_iomap_1;\n\t}\n\n\tpar->mmio_base = pci_iomap(dev, 1, 0);\n\tif (! par->mmio_base) {\n\t\trc = -ENOMEM;\n\t\tdev_err(info->device, \"iomap for MMIO failed\\n\");\n\t\tgoto err_iomap_2;\n\t}\n\n\tbus_reg.start = 0;\n\tbus_reg.end = 64 * 1024;\n\n\tvga_res.flags = IORESOURCE_IO;\n\n\tpcibios_bus_to_resource(dev->bus, &vga_res, &bus_reg);\n\n\tpar->state.vgabase = (void __iomem *) (unsigned long) vga_res.start;\n\n\t \n\tmemsize1 = (vga_rseq(par->state.vgabase, 0x34) + 1) >> 1;\n\tmemsize2 = vga_rseq(par->state.vgabase, 0x39) << 2;\n\n\tif ((16 <= memsize1) && (memsize1 <= 64) && (memsize1 == memsize2))\n\t\tinfo->screen_size = memsize1 << 20;\n\telse {\n\t\tdev_err(info->device, \"memory size detection failed (%x %x), suppose 16 MB\\n\", memsize1, memsize2);\n\t\tinfo->screen_size = 16 << 20;\n\t}\n\n\tinfo->fix.smem_len = info->screen_size;\n\tstrcpy(info->fix.id, \"VIA VT8623\");\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\tinfo->fix.ypanstep = 0;\n\tinfo->fix.accel = FB_ACCEL_NONE;\n\tinfo->pseudo_palette = (void*)par->pseudo_palette;\n\n\t \n\n\tkernel_param_lock(THIS_MODULE);\n\trc = fb_find_mode(&(info->var), info, mode_option, NULL, 0, NULL, 8);\n\tkernel_param_unlock(THIS_MODULE);\n\tif (! ((rc == 1) || (rc == 2))) {\n\t\trc = -EINVAL;\n\t\tdev_err(info->device, \"mode %s not found\\n\", mode_option);\n\t\tgoto err_find_mode;\n\t}\n\n\trc = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (rc < 0) {\n\t\tdev_err(info->device, \"cannot allocate colormap\\n\");\n\t\tgoto err_alloc_cmap;\n\t}\n\n\trc = register_framebuffer(info);\n\tif (rc < 0) {\n\t\tdev_err(info->device, \"cannot register framebuffer\\n\");\n\t\tgoto err_reg_fb;\n\t}\n\n\tfb_info(info, \"%s on %s, %d MB RAM\\n\",\n\t\tinfo->fix.id, pci_name(dev), info->fix.smem_len >> 20);\n\n\t \n\tpci_set_drvdata(dev, info);\n\n\tif (mtrr)\n\t\tpar->wc_cookie = arch_phys_wc_add(info->fix.smem_start,\n\t\t\t\t\t\t  info->fix.smem_len);\n\n\treturn 0;\n\n\t \nerr_reg_fb:\n\tfb_dealloc_cmap(&info->cmap);\nerr_alloc_cmap:\nerr_find_mode:\n\tpci_iounmap(dev, par->mmio_base);\nerr_iomap_2:\n\tpci_iounmap(dev, info->screen_base);\nerr_iomap_1:\n\tpci_release_regions(dev);\nerr_request_regions:\n \nerr_enable_device:\n\tframebuffer_release(info);\n\treturn rc;\n}\n\n \n\nstatic void vt8623_pci_remove(struct pci_dev *dev)\n{\n\tstruct fb_info *info = pci_get_drvdata(dev);\n\n\tif (info) {\n\t\tstruct vt8623fb_info *par = info->par;\n\n\t\tarch_phys_wc_del(par->wc_cookie);\n\t\tunregister_framebuffer(info);\n\t\tfb_dealloc_cmap(&info->cmap);\n\n\t\tpci_iounmap(dev, info->screen_base);\n\t\tpci_iounmap(dev, par->mmio_base);\n\t\tpci_release_regions(dev);\n \n\n\t\tframebuffer_release(info);\n\t}\n}\n\n\n \n\nstatic int __maybe_unused vt8623_pci_suspend(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct vt8623fb_info *par = info->par;\n\n\tdev_info(info->device, \"suspend\\n\");\n\n\tconsole_lock();\n\tmutex_lock(&(par->open_lock));\n\n\tif (par->ref_count == 0) {\n\t\tmutex_unlock(&(par->open_lock));\n\t\tconsole_unlock();\n\t\treturn 0;\n\t}\n\n\tfb_set_suspend(info, 1);\n\n\tmutex_unlock(&(par->open_lock));\n\tconsole_unlock();\n\n\treturn 0;\n}\n\n\n \n\nstatic int __maybe_unused vt8623_pci_resume(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct vt8623fb_info *par = info->par;\n\n\tdev_info(info->device, \"resume\\n\");\n\n\tconsole_lock();\n\tmutex_lock(&(par->open_lock));\n\n\tif (par->ref_count == 0)\n\t\tgoto fail;\n\n\tvt8623fb_set_par(info);\n\tfb_set_suspend(info, 0);\n\nfail:\n\tmutex_unlock(&(par->open_lock));\n\tconsole_unlock();\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops vt8623_pci_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= vt8623_pci_suspend,\n\t.resume\t\t= vt8623_pci_resume,\n\t.freeze\t\t= NULL,\n\t.thaw\t\t= vt8623_pci_resume,\n\t.poweroff\t= vt8623_pci_suspend,\n\t.restore\t= vt8623_pci_resume,\n#endif  \n};\n\n \n\nstatic const struct pci_device_id vt8623_devices[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_VIA, 0x3122)},\n\t{0, 0, 0, 0, 0, 0, 0}\n};\n\nMODULE_DEVICE_TABLE(pci, vt8623_devices);\n\nstatic struct pci_driver vt8623fb_pci_driver = {\n\t.name\t\t= \"vt8623fb\",\n\t.id_table\t= vt8623_devices,\n\t.probe\t\t= vt8623_pci_probe,\n\t.remove\t\t= vt8623_pci_remove,\n\t.driver.pm\t= &vt8623_pci_pm_ops,\n};\n\n \n\nstatic void __exit vt8623fb_cleanup(void)\n{\n\tpr_debug(\"vt8623fb: cleaning up\\n\");\n\tpci_unregister_driver(&vt8623fb_pci_driver);\n}\n\n \n\nstatic int __init vt8623fb_init(void)\n{\n\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"vt8623fb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"vt8623fb\", &option))\n\t\treturn -ENODEV;\n\n\tif (option && *option)\n\t\tmode_option = option;\n#endif\n\n\tpr_debug(\"vt8623fb: initializing\\n\");\n\treturn pci_register_driver(&vt8623fb_pci_driver);\n}\n\n \n\n \n\nmodule_init(vt8623fb_init);\nmodule_exit(vt8623fb_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}