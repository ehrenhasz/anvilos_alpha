{
  "module_name": "cirrusfb.c",
  "hash_id": "3eb6647fd0568e40e704dc27ff67184a07c81cf8c37cfdaded2859013b92bec8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/cirrusfb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n\n#ifdef CONFIG_ZORRO\n#include <linux/zorro.h>\n#endif\n#ifdef CONFIG_PCI\n#include <linux/pci.h>\n#endif\n#ifdef CONFIG_AMIGA\n#include <asm/amigahw.h>\n#endif\n\n#include <video/vga.h>\n#include <video/cirrus.h>\n\n \n\n \n \n\n \n#ifndef CIRRUSFB_NDEBUG\n#define assert(expr) \\\n\tif (!(expr)) { \\\n\t\tprintk(\"Assertion failed! %s,%s,%s,line=%d\\n\", \\\n\t\t#expr, __FILE__, __func__, __LINE__); \\\n\t}\n#else\n#define assert(expr)\n#endif\n\n#define MB_ (1024 * 1024)\n\n \n\n \nenum cirrus_board {\n\tBT_NONE = 0,\n\tBT_SD64,\t \n\tBT_PICCOLO,\t \n\tBT_PICASSO,\t \n\tBT_SPECTRUM,\t \n\tBT_PICASSO4,\t \n\tBT_ALPINE,\t \n\tBT_GD5480,\n\tBT_LAGUNA,\t \n\tBT_LAGUNAB,\t \n};\n\n \nstatic const struct cirrusfb_board_info_rec {\n\tchar *name;\t\t \n\tlong maxclock[5];\t\t \n\t \n\tbool init_sr07 : 1;  \n\tbool init_sr1f : 1;  \n\t \n\tbool scrn_start_bit19 : 1;\n\n\t \n\tunsigned char sr07;\n\tunsigned char sr07_1bpp;\n\tunsigned char sr07_1bpp_mux;\n\tunsigned char sr07_8bpp;\n\tunsigned char sr07_8bpp_mux;\n\n\tunsigned char sr1f;\t \n} cirrusfb_board_info[] = {\n\t[BT_SD64] = {\n\t\t.name\t\t\t= \"CL SD64\",\n\t\t.maxclock\t\t= {\n\t\t\t \n\t\t\t \n\t\t\t135100, 135100, 85500, 85500, 0\n\t\t},\n\t\t.init_sr07\t\t= true,\n\t\t.init_sr1f\t\t= true,\n\t\t.scrn_start_bit19\t= true,\n\t\t.sr07\t\t\t= 0xF0,\n\t\t.sr07_1bpp\t\t= 0xF0,\n\t\t.sr07_1bpp_mux\t\t= 0xF6,\n\t\t.sr07_8bpp\t\t= 0xF1,\n\t\t.sr07_8bpp_mux\t\t= 0xF7,\n\t\t.sr1f\t\t\t= 0x1E\n\t},\n\t[BT_PICCOLO] = {\n\t\t.name\t\t\t= \"CL Piccolo\",\n\t\t.maxclock\t\t= {\n\t\t\t \n\t\t\t90000, 90000, 90000, 90000, 90000\n\t\t},\n\t\t.init_sr07\t\t= true,\n\t\t.init_sr1f\t\t= true,\n\t\t.scrn_start_bit19\t= false,\n\t\t.sr07\t\t\t= 0x80,\n\t\t.sr07_1bpp\t\t= 0x80,\n\t\t.sr07_8bpp\t\t= 0x81,\n\t\t.sr1f\t\t\t= 0x22\n\t},\n\t[BT_PICASSO] = {\n\t\t.name\t\t\t= \"CL Picasso\",\n\t\t.maxclock\t\t= {\n\t\t\t \n\t\t\t90000, 90000, 90000, 90000, 90000\n\t\t},\n\t\t.init_sr07\t\t= true,\n\t\t.init_sr1f\t\t= true,\n\t\t.scrn_start_bit19\t= false,\n\t\t.sr07\t\t\t= 0x20,\n\t\t.sr07_1bpp\t\t= 0x20,\n\t\t.sr07_8bpp\t\t= 0x21,\n\t\t.sr1f\t\t\t= 0x22\n\t},\n\t[BT_SPECTRUM] = {\n\t\t.name\t\t\t= \"CL Spectrum\",\n\t\t.maxclock\t\t= {\n\t\t\t \n\t\t\t90000, 90000, 90000, 90000, 90000\n\t\t},\n\t\t.init_sr07\t\t= true,\n\t\t.init_sr1f\t\t= true,\n\t\t.scrn_start_bit19\t= false,\n\t\t.sr07\t\t\t= 0x80,\n\t\t.sr07_1bpp\t\t= 0x80,\n\t\t.sr07_8bpp\t\t= 0x81,\n\t\t.sr1f\t\t\t= 0x22\n\t},\n\t[BT_PICASSO4] = {\n\t\t.name\t\t\t= \"CL Picasso4\",\n\t\t.maxclock\t\t= {\n\t\t\t135100, 135100, 85500, 85500, 0\n\t\t},\n\t\t.init_sr07\t\t= true,\n\t\t.init_sr1f\t\t= false,\n\t\t.scrn_start_bit19\t= true,\n\t\t.sr07\t\t\t= 0xA0,\n\t\t.sr07_1bpp\t\t= 0xA0,\n\t\t.sr07_1bpp_mux\t\t= 0xA6,\n\t\t.sr07_8bpp\t\t= 0xA1,\n\t\t.sr07_8bpp_mux\t\t= 0xA7,\n\t\t.sr1f\t\t\t= 0\n\t},\n\t[BT_ALPINE] = {\n\t\t.name\t\t\t= \"CL Alpine\",\n\t\t.maxclock\t\t= {\n\t\t\t \n\t\t\t85500, 85500, 50000, 28500, 0\n\t\t},\n\t\t.init_sr07\t\t= true,\n\t\t.init_sr1f\t\t= true,\n\t\t.scrn_start_bit19\t= true,\n\t\t.sr07\t\t\t= 0xA0,\n\t\t.sr07_1bpp\t\t= 0xA0,\n\t\t.sr07_1bpp_mux\t\t= 0xA6,\n\t\t.sr07_8bpp\t\t= 0xA1,\n\t\t.sr07_8bpp_mux\t\t= 0xA7,\n\t\t.sr1f\t\t\t= 0x1C\n\t},\n\t[BT_GD5480] = {\n\t\t.name\t\t\t= \"CL GD5480\",\n\t\t.maxclock\t\t= {\n\t\t\t135100, 200000, 200000, 135100, 135100\n\t\t},\n\t\t.init_sr07\t\t= true,\n\t\t.init_sr1f\t\t= true,\n\t\t.scrn_start_bit19\t= true,\n\t\t.sr07\t\t\t= 0x10,\n\t\t.sr07_1bpp\t\t= 0x11,\n\t\t.sr07_8bpp\t\t= 0x11,\n\t\t.sr1f\t\t\t= 0x1C\n\t},\n\t[BT_LAGUNA] = {\n\t\t.name\t\t\t= \"CL Laguna\",\n\t\t.maxclock\t\t= {\n\t\t\t \n\t\t\t170000, 170000, 170000, 170000, 135100,\n\t\t},\n\t\t.init_sr07\t\t= false,\n\t\t.init_sr1f\t\t= false,\n\t\t.scrn_start_bit19\t= true,\n\t},\n\t[BT_LAGUNAB] = {\n\t\t.name\t\t\t= \"CL Laguna AGP\",\n\t\t.maxclock\t\t= {\n\t\t\t \n\t\t\t170000, 250000, 170000, 170000, 135100,\n\t\t},\n\t\t.init_sr07\t\t= false,\n\t\t.init_sr1f\t\t= false,\n\t\t.scrn_start_bit19\t= true,\n\t}\n};\n\n#ifdef CONFIG_PCI\n#define CHIP(id, btype) \\\n\t{ PCI_VENDOR_ID_CIRRUS, id, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (btype) }\n\nstatic struct pci_device_id cirrusfb_pci_table[] = {\n\tCHIP(PCI_DEVICE_ID_CIRRUS_5436, BT_ALPINE),\n\tCHIP(PCI_DEVICE_ID_CIRRUS_5434_8, BT_SD64),\n\tCHIP(PCI_DEVICE_ID_CIRRUS_5434_4, BT_SD64),\n\tCHIP(PCI_DEVICE_ID_CIRRUS_5430, BT_ALPINE),  \n\tCHIP(PCI_DEVICE_ID_CIRRUS_7543, BT_ALPINE),\n\tCHIP(PCI_DEVICE_ID_CIRRUS_7548, BT_ALPINE),\n\tCHIP(PCI_DEVICE_ID_CIRRUS_5480, BT_GD5480),  \n\tCHIP(PCI_DEVICE_ID_CIRRUS_5446, BT_PICASSO4),  \n\tCHIP(PCI_DEVICE_ID_CIRRUS_5462, BT_LAGUNA),  \n\tCHIP(PCI_DEVICE_ID_CIRRUS_5464, BT_LAGUNA),  \n\tCHIP(PCI_DEVICE_ID_CIRRUS_5465, BT_LAGUNAB),  \n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, cirrusfb_pci_table);\n#undef CHIP\n#endif  \n\n#ifdef CONFIG_ZORRO\nstruct zorrocl {\n\tenum cirrus_board type;\t \n\tu32 regoffset;\t\t \n\tu32 ramsize;\t\t \n\t\t\t\t \n\tu32 ramoffset;\t\t \n\tzorro_id ramid;\t\t \n\tzorro_id ramid2;\t \n};\n\nstatic const struct zorrocl zcl_sd64 = {\n\t.type\t\t= BT_SD64,\n\t.ramid\t\t= ZORRO_PROD_HELFRICH_SD64_RAM,\n};\n\nstatic const struct zorrocl zcl_piccolo = {\n\t.type\t\t= BT_PICCOLO,\n\t.ramid\t\t= ZORRO_PROD_HELFRICH_PICCOLO_RAM,\n};\n\nstatic const struct zorrocl zcl_picasso = {\n\t.type\t\t= BT_PICASSO,\n\t.ramid\t\t= ZORRO_PROD_VILLAGE_TRONIC_PICASSO_II_II_PLUS_RAM,\n};\n\nstatic const struct zorrocl zcl_spectrum = {\n\t.type\t\t= BT_SPECTRUM,\n\t.ramid\t\t= ZORRO_PROD_GVP_EGS_28_24_SPECTRUM_RAM,\n};\n\nstatic const struct zorrocl zcl_picasso4_z3 = {\n\t.type\t\t= BT_PICASSO4,\n\t.regoffset\t= 0x00600000,\n\t.ramsize\t= 4 * MB_,\n\t.ramoffset\t= 0x01000000,\t \n};\n\nstatic const struct zorrocl zcl_picasso4_z2 = {\n\t.type\t\t= BT_PICASSO4,\n\t.regoffset\t= 0x10000,\n\t.ramid\t\t= ZORRO_PROD_VILLAGE_TRONIC_PICASSO_IV_Z2_RAM1,\n\t.ramid2\t\t= ZORRO_PROD_VILLAGE_TRONIC_PICASSO_IV_Z2_RAM2,\n};\n\n\nstatic const struct zorro_device_id cirrusfb_zorro_table[] = {\n\t{\n\t\t.id\t\t= ZORRO_PROD_HELFRICH_SD64_REG,\n\t\t.driver_data\t= (unsigned long)&zcl_sd64,\n\t}, {\n\t\t.id\t\t= ZORRO_PROD_HELFRICH_PICCOLO_REG,\n\t\t.driver_data\t= (unsigned long)&zcl_piccolo,\n\t}, {\n\t\t.id\t= ZORRO_PROD_VILLAGE_TRONIC_PICASSO_II_II_PLUS_REG,\n\t\t.driver_data\t= (unsigned long)&zcl_picasso,\n\t}, {\n\t\t.id\t\t= ZORRO_PROD_GVP_EGS_28_24_SPECTRUM_REG,\n\t\t.driver_data\t= (unsigned long)&zcl_spectrum,\n\t}, {\n\t\t.id\t\t= ZORRO_PROD_VILLAGE_TRONIC_PICASSO_IV_Z3,\n\t\t.driver_data\t= (unsigned long)&zcl_picasso4_z3,\n\t}, {\n\t\t.id\t\t= ZORRO_PROD_VILLAGE_TRONIC_PICASSO_IV_Z2_REG,\n\t\t.driver_data\t= (unsigned long)&zcl_picasso4_z2,\n\t},\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(zorro, cirrusfb_zorro_table);\n#endif  \n\n#ifdef CIRRUSFB_DEBUG\nenum cirrusfb_dbg_reg_class {\n\tCRT,\n\tSEQ\n};\n#endif\t\t \n\n \nstruct cirrusfb_info {\n\tu8 __iomem *regbase;\n\tu8 __iomem *laguna_mmio;\n\tenum cirrus_board btype;\n\tunsigned char SFR;\t \n\n\tint multiplexing;\n\tint doubleVCLK;\n\tint blank_mode;\n\tu32 pseudo_palette[16];\n\n\tvoid (*unmap)(struct fb_info *info);\n};\n\nstatic bool noaccel;\nstatic char *mode_option = \"640x480@60\";\n\n \n \n\n \nstatic int cirrusfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info);\n\n \nstatic void init_vgachip(struct fb_info *info);\nstatic void switch_monitor(struct cirrusfb_info *cinfo, int on);\nstatic void WGen(const struct cirrusfb_info *cinfo,\n\t\t int regnum, unsigned char val);\nstatic unsigned char RGen(const struct cirrusfb_info *cinfo, int regnum);\nstatic void AttrOn(const struct cirrusfb_info *cinfo);\nstatic void WHDR(const struct cirrusfb_info *cinfo, unsigned char val);\nstatic void WSFR(struct cirrusfb_info *cinfo, unsigned char val);\nstatic void WSFR2(struct cirrusfb_info *cinfo, unsigned char val);\nstatic void WClut(struct cirrusfb_info *cinfo, unsigned char regnum,\n\t\t  unsigned char red, unsigned char green, unsigned char blue);\n#if 0\nstatic void RClut(struct cirrusfb_info *cinfo, unsigned char regnum,\n\t\t  unsigned char *red, unsigned char *green,\n\t\t  unsigned char *blue);\n#endif\nstatic void cirrusfb_WaitBLT(u8 __iomem *regbase);\nstatic void cirrusfb_BitBLT(u8 __iomem *regbase, int bits_per_pixel,\n\t\t\t    u_short curx, u_short cury,\n\t\t\t    u_short destx, u_short desty,\n\t\t\t    u_short width, u_short height,\n\t\t\t    u_short line_length);\nstatic void cirrusfb_RectFill(u8 __iomem *regbase, int bits_per_pixel,\n\t\t\t      u_short x, u_short y,\n\t\t\t      u_short width, u_short height,\n\t\t\t      u32 fg_color, u32 bg_color,\n\t\t\t      u_short line_length, u_char blitmode);\n\nstatic void bestclock(long freq, int *nom, int *den, int *div);\n\n#ifdef CIRRUSFB_DEBUG\nstatic void cirrusfb_dbg_reg_dump(struct fb_info *info, caddr_t regbase);\nstatic void cirrusfb_dbg_print_regs(struct fb_info *info,\n\t\t\t\t    caddr_t regbase,\n\t\t\t\t    enum cirrusfb_dbg_reg_class reg_class, ...);\n#endif  \n\n \n \n \n\nstatic inline int is_laguna(const struct cirrusfb_info *cinfo)\n{\n\treturn cinfo->btype == BT_LAGUNA || cinfo->btype == BT_LAGUNAB;\n}\n\nstatic int opencount;\n\n \nstatic int cirrusfb_open(struct fb_info *info, int user)\n{\n\tif (opencount++ == 0)\n\t\tswitch_monitor(info->par, 1);\n\treturn 0;\n}\n\n \nstatic int cirrusfb_release(struct fb_info *info, int user)\n{\n\tif (--opencount == 0)\n\t\tswitch_monitor(info->par, 0);\n\treturn 0;\n}\n\n \n \n \n\n \nstatic int cirrusfb_check_mclk(struct fb_info *info, long freq)\n{\n\tstruct cirrusfb_info *cinfo = info->par;\n\tlong mclk = vga_rseq(cinfo->regbase, CL_SEQR1F) & 0x3f;\n\n\t \n\tmclk = (14318 * mclk) >> 3;\n\tdev_dbg(info->device, \"Read MCLK of %ld kHz\\n\", mclk);\n\n\t \n\n\tif (abs(freq - mclk) < 250) {\n\t\tdev_dbg(info->device, \"Using VCLK = MCLK\\n\");\n\t\treturn 1;\n\t} else if (abs(freq - (mclk / 2)) < 250) {\n\t\tdev_dbg(info->device, \"Using VCLK = MCLK/2\\n\");\n\t\treturn 2;\n\t}\n\n\treturn 0;\n}\n\nstatic int cirrusfb_check_pixclock(struct fb_var_screeninfo *var,\n\t\t\t\t   struct fb_info *info)\n{\n\tlong freq;\n\tlong maxclock;\n\tstruct cirrusfb_info *cinfo = info->par;\n\tunsigned maxclockidx = var->bits_per_pixel >> 3;\n\n\t \n\tfreq = PICOS2KHZ(var->pixclock ? : 1);\n\n\tmaxclock = cirrusfb_board_info[cinfo->btype].maxclock[maxclockidx];\n\tcinfo->multiplexing = 0;\n\n\t \n\tif (freq > maxclock) {\n\t\tvar->pixclock = KHZ2PICOS(maxclock);\n\n\t\twhile ((freq = PICOS2KHZ(var->pixclock)) > maxclock)\n\t\t\tvar->pixclock++;\n\t}\n\tdev_dbg(info->device, \"desired pixclock: %ld kHz\\n\", freq);\n\n\t \n\tif (var->bits_per_pixel == 8) {\n\t\tswitch (cinfo->btype) {\n\t\tcase BT_ALPINE:\n\t\tcase BT_SD64:\n\t\tcase BT_PICASSO4:\n\t\t\tif (freq > 85500)\n\t\t\t\tcinfo->multiplexing = 1;\n\t\t\tbreak;\n\t\tcase BT_GD5480:\n\t\t\tif (freq > 135100)\n\t\t\t\tcinfo->multiplexing = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tcinfo->doubleVCLK = 0;\n\tif (cinfo->btype == BT_SD64 && info->fix.smem_len <= MB_ &&\n\t    var->bits_per_pixel == 16) {\n\t\tcinfo->doubleVCLK = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int cirrusfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tint yres;\n\t \n\tunsigned int pixels;\n\tstruct cirrusfb_info *cinfo = info->par;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 1:\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 1;\n\t\tvar->green = var->red;\n\t\tvar->blue = var->red;\n\t\tbreak;\n\n\tcase 8:\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green = var->red;\n\t\tvar->blue = var->red;\n\t\tbreak;\n\n\tcase 16:\n\t\tvar->red.offset = 11;\n\t\tvar->green.offset = 5;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.length = 5;\n\t\tbreak;\n\n\tcase 24:\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(info->device,\n\t\t\t\"Unsupported bpp size: %d\\n\", var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\tpixels = info->screen_size * 8 / var->bits_per_pixel;\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\t \n\tif (var->yres_virtual == -1) {\n\t\tvar->yres_virtual = pixels / var->xres_virtual;\n\n\t\tdev_info(info->device,\n\t\t\t \"virtual resolution set to maximum of %dx%d\\n\",\n\t\t\t var->xres_virtual, var->yres_virtual);\n\t}\n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres_virtual = var->yres;\n\n\tif (var->xres_virtual * var->yres_virtual > pixels) {\n\t\tdev_err(info->device, \"mode %dx%dx%d rejected... \"\n\t\t      \"virtual resolution too high to fit into video memory!\\n\",\n\t\t\tvar->xres_virtual, var->yres_virtual,\n\t\t\tvar->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (var->xoffset > var->xres_virtual - var->xres)\n\t\tvar->xoffset = var->xres_virtual - var->xres - 1;\n\tif (var->yoffset > var->yres_virtual - var->yres)\n\t\tvar->yoffset = var->yres_virtual - var->yres - 1;\n\n\tvar->red.msb_right =\n\t    var->green.msb_right =\n\t    var->blue.msb_right =\n\t    var->transp.offset =\n\t    var->transp.length =\n\t    var->transp.msb_right = 0;\n\n\tyres = var->yres;\n\tif (var->vmode & FB_VMODE_DOUBLE)\n\t\tyres *= 2;\n\telse if (var->vmode & FB_VMODE_INTERLACED)\n\t\tyres = (yres + 1) / 2;\n\n\tif (yres >= 1280) {\n\t\tdev_err(info->device, \"ERROR: VerticalTotal >= 1280; \"\n\t\t\t\"special treatment required! (TODO)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cirrusfb_check_pixclock(var, info))\n\t\treturn -EINVAL;\n\n\tif (!is_laguna(cinfo))\n\t\tvar->accel_flags = FB_ACCELF_TEXT;\n\n\treturn 0;\n}\n\nstatic void cirrusfb_set_mclk_as_source(const struct fb_info *info, int div)\n{\n\tstruct cirrusfb_info *cinfo = info->par;\n\tunsigned char old1f, old1e;\n\n\tassert(cinfo != NULL);\n\told1f = vga_rseq(cinfo->regbase, CL_SEQR1F) & ~0x40;\n\n\tif (div) {\n\t\tdev_dbg(info->device, \"Set %s as pixclock source.\\n\",\n\t\t\t(div == 2) ? \"MCLK/2\" : \"MCLK\");\n\t\told1f |= 0x40;\n\t\told1e = vga_rseq(cinfo->regbase, CL_SEQR1E) & ~0x1;\n\t\tif (div == 2)\n\t\t\told1e |= 1;\n\n\t\tvga_wseq(cinfo->regbase, CL_SEQR1E, old1e);\n\t}\n\tvga_wseq(cinfo->regbase, CL_SEQR1F, old1f);\n}\n\n \nstatic int cirrusfb_set_par_foo(struct fb_info *info)\n{\n\tstruct cirrusfb_info *cinfo = info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tu8 __iomem *regbase = cinfo->regbase;\n\tunsigned char tmp;\n\tint pitch;\n\tconst struct cirrusfb_board_info_rec *bi;\n\tint hdispend, hsyncstart, hsyncend, htotal;\n\tint yres, vdispend, vsyncstart, vsyncend, vtotal;\n\tlong freq;\n\tint nom, den, div;\n\tunsigned int control = 0, format = 0, threshold = 0;\n\n\tdev_dbg(info->device, \"Requested mode: %dx%dx%d\\n\",\n\t       var->xres, var->yres, var->bits_per_pixel);\n\n\tswitch (var->bits_per_pixel) {\n\tcase 1:\n\t\tinfo->fix.line_length = var->xres_virtual / 8;\n\t\tinfo->fix.visual = FB_VISUAL_MONO10;\n\t\tbreak;\n\n\tcase 8:\n\t\tinfo->fix.line_length = var->xres_virtual;\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\n\tcase 16:\n\tcase 24:\n\t\tinfo->fix.line_length = var->xres_virtual *\n\t\t\t\t\tvar->bits_per_pixel >> 3;\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\t}\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\n\tinit_vgachip(info);\n\n\tbi = &cirrusfb_board_info[cinfo->btype];\n\n\thsyncstart = var->xres + var->right_margin;\n\thsyncend = hsyncstart + var->hsync_len;\n\thtotal = (hsyncend + var->left_margin) / 8;\n\thdispend = var->xres / 8;\n\thsyncstart = hsyncstart / 8;\n\thsyncend = hsyncend / 8;\n\n\tvdispend = var->yres;\n\tvsyncstart = vdispend + var->lower_margin;\n\tvsyncend = vsyncstart + var->vsync_len;\n\tvtotal = vsyncend + var->upper_margin;\n\n\tif (var->vmode & FB_VMODE_DOUBLE) {\n\t\tvdispend *= 2;\n\t\tvsyncstart *= 2;\n\t\tvsyncend *= 2;\n\t\tvtotal *= 2;\n\t} else if (var->vmode & FB_VMODE_INTERLACED) {\n\t\tvdispend = (vdispend + 1) / 2;\n\t\tvsyncstart = (vsyncstart + 1) / 2;\n\t\tvsyncend = (vsyncend + 1) / 2;\n\t\tvtotal = (vtotal + 1) / 2;\n\t}\n\tyres = vdispend;\n\tif (yres >= 1024) {\n\t\tvtotal /= 2;\n\t\tvsyncstart /= 2;\n\t\tvsyncend /= 2;\n\t\tvdispend /= 2;\n\t}\n\n\tvdispend -= 1;\n\tvsyncstart -= 1;\n\tvsyncend -= 1;\n\tvtotal -= 2;\n\n\tif (cinfo->multiplexing) {\n\t\thtotal /= 2;\n\t\thsyncstart /= 2;\n\t\thsyncend /= 2;\n\t\thdispend /= 2;\n\t}\n\n\thtotal -= 5;\n\thdispend -= 1;\n\thsyncstart += 1;\n\thsyncend += 1;\n\n\t \n\tvga_wcrt(regbase, VGA_CRTC_V_SYNC_END, 0x20);\t \n\n\t \n\tdev_dbg(info->device, \"CRT0: %d\\n\", htotal);\n\tvga_wcrt(regbase, VGA_CRTC_H_TOTAL, htotal);\n\n\tdev_dbg(info->device, \"CRT1: %d\\n\", hdispend);\n\tvga_wcrt(regbase, VGA_CRTC_H_DISP, hdispend);\n\n\tdev_dbg(info->device, \"CRT2: %d\\n\", var->xres / 8);\n\tvga_wcrt(regbase, VGA_CRTC_H_BLANK_START, var->xres / 8);\n\n\t \n\tdev_dbg(info->device, \"CRT3: 128+%d\\n\", (htotal + 5) % 32);\n\tvga_wcrt(regbase, VGA_CRTC_H_BLANK_END,\n\t\t 128 + ((htotal + 5) % 32));\n\n\tdev_dbg(info->device, \"CRT4: %d\\n\", hsyncstart);\n\tvga_wcrt(regbase, VGA_CRTC_H_SYNC_START, hsyncstart);\n\n\ttmp = hsyncend % 32;\n\tif ((htotal + 5) & 32)\n\t\ttmp += 128;\n\tdev_dbg(info->device, \"CRT5: %d\\n\", tmp);\n\tvga_wcrt(regbase, VGA_CRTC_H_SYNC_END, tmp);\n\n\tdev_dbg(info->device, \"CRT6: %d\\n\", vtotal & 0xff);\n\tvga_wcrt(regbase, VGA_CRTC_V_TOTAL, vtotal & 0xff);\n\n\ttmp = 16;\t\t \n\tif (vtotal & 256)\n\t\ttmp |= 1;\n\tif (vdispend & 256)\n\t\ttmp |= 2;\n\tif (vsyncstart & 256)\n\t\ttmp |= 4;\n\tif ((vdispend + 1) & 256)\n\t\ttmp |= 8;\n\tif (vtotal & 512)\n\t\ttmp |= 32;\n\tif (vdispend & 512)\n\t\ttmp |= 64;\n\tif (vsyncstart & 512)\n\t\ttmp |= 128;\n\tdev_dbg(info->device, \"CRT7: %d\\n\", tmp);\n\tvga_wcrt(regbase, VGA_CRTC_OVERFLOW, tmp);\n\n\ttmp = 0x40;\t\t \n\tif ((vdispend + 1) & 512)\n\t\ttmp |= 0x20;\n\tif (var->vmode & FB_VMODE_DOUBLE)\n\t\ttmp |= 0x80;\n\tdev_dbg(info->device, \"CRT9: %d\\n\", tmp);\n\tvga_wcrt(regbase, VGA_CRTC_MAX_SCAN, tmp);\n\n\tdev_dbg(info->device, \"CRT10: %d\\n\", vsyncstart & 0xff);\n\tvga_wcrt(regbase, VGA_CRTC_V_SYNC_START, vsyncstart & 0xff);\n\n\tdev_dbg(info->device, \"CRT11: 64+32+%d\\n\", vsyncend % 16);\n\tvga_wcrt(regbase, VGA_CRTC_V_SYNC_END, vsyncend % 16 + 64 + 32);\n\n\tdev_dbg(info->device, \"CRT12: %d\\n\", vdispend & 0xff);\n\tvga_wcrt(regbase, VGA_CRTC_V_DISP_END, vdispend & 0xff);\n\n\tdev_dbg(info->device, \"CRT15: %d\\n\", (vdispend + 1) & 0xff);\n\tvga_wcrt(regbase, VGA_CRTC_V_BLANK_START, (vdispend + 1) & 0xff);\n\n\tdev_dbg(info->device, \"CRT16: %d\\n\", vtotal & 0xff);\n\tvga_wcrt(regbase, VGA_CRTC_V_BLANK_END, vtotal & 0xff);\n\n\tdev_dbg(info->device, \"CRT18: 0xff\\n\");\n\tvga_wcrt(regbase, VGA_CRTC_LINE_COMPARE, 0xff);\n\n\ttmp = 0;\n\tif (var->vmode & FB_VMODE_INTERLACED)\n\t\ttmp |= 1;\n\tif ((htotal + 5) & 64)\n\t\ttmp |= 16;\n\tif ((htotal + 5) & 128)\n\t\ttmp |= 32;\n\tif (vtotal & 256)\n\t\ttmp |= 64;\n\tif (vtotal & 512)\n\t\ttmp |= 128;\n\n\tdev_dbg(info->device, \"CRT1a: %d\\n\", tmp);\n\tvga_wcrt(regbase, CL_CRT1A, tmp);\n\n\tfreq = PICOS2KHZ(var->pixclock);\n\tif (var->bits_per_pixel == 24)\n\t\tif (cinfo->btype == BT_ALPINE || cinfo->btype == BT_SD64)\n\t\t\tfreq *= 3;\n\tif (cinfo->multiplexing)\n\t\tfreq /= 2;\n\tif (cinfo->doubleVCLK)\n\t\tfreq *= 2;\n\n\tbestclock(freq, &nom, &den, &div);\n\n\tdev_dbg(info->device, \"VCLK freq: %ld kHz  nom: %d  den: %d  div: %d\\n\",\n\t\tfreq, nom, den, div);\n\n\t \n\t \n\t \n\t \n\n\tif (cinfo->btype == BT_ALPINE || cinfo->btype == BT_PICASSO4 ||\n\t    cinfo->btype == BT_SD64) {\n\t\t \n\t\tint divMCLK = cirrusfb_check_mclk(info, freq);\n\t\tif (divMCLK)\n\t\t\tnom = 0;\n\t\tcirrusfb_set_mclk_as_source(info, divMCLK);\n\t}\n\tif (is_laguna(cinfo)) {\n\t\tlong pcifc = fb_readl(cinfo->laguna_mmio + 0x3fc);\n\t\tunsigned char tile = fb_readb(cinfo->laguna_mmio + 0x407);\n\t\tunsigned short tile_control;\n\n\t\tif (cinfo->btype == BT_LAGUNAB) {\n\t\t\ttile_control = fb_readw(cinfo->laguna_mmio + 0x2c4);\n\t\t\ttile_control &= ~0x80;\n\t\t\tfb_writew(tile_control, cinfo->laguna_mmio + 0x2c4);\n\t\t}\n\n\t\tfb_writel(pcifc | 0x10000000l, cinfo->laguna_mmio + 0x3fc);\n\t\tfb_writeb(tile & 0x3f, cinfo->laguna_mmio + 0x407);\n\t\tcontrol = fb_readw(cinfo->laguna_mmio + 0x402);\n\t\tthreshold = fb_readw(cinfo->laguna_mmio + 0xea);\n\t\tcontrol &= ~0x6800;\n\t\tformat = 0;\n\t\tthreshold &= 0xffc0 & 0x3fbf;\n\t}\n\tif (nom) {\n\t\ttmp = den << 1;\n\t\tif (div != 0)\n\t\t\ttmp |= 1;\n\t\t \n\t\tif ((cinfo->btype == BT_SD64) ||\n\t\t    (cinfo->btype == BT_ALPINE) ||\n\t\t    (cinfo->btype == BT_GD5480))\n\t\t\ttmp |= 0x80;\n\n\t\t \n\t\tif (is_laguna(cinfo)) {\n\t\t\tvga_wseq(regbase, CL_SEQRE, tmp);\n\t\t\tvga_wseq(regbase, CL_SEQR1E, nom);\n\t\t} else {\n\t\t\tvga_wseq(regbase, CL_SEQRE, nom);\n\t\t\tvga_wseq(regbase, CL_SEQR1E, tmp);\n\t\t}\n\t}\n\n\tif (yres >= 1024)\n\t\t \n\t\tvga_wcrt(regbase, VGA_CRTC_MODE, 0xc7);\n\telse\n\t\t \n\t\tvga_wcrt(regbase, VGA_CRTC_MODE, 0xc3);\n\n\t \n\t \n\tif (var->vmode & FB_VMODE_INTERLACED)\n\t\tvga_wcrt(regbase, VGA_CRTC_REGS, htotal / 2);\n\telse\n\t\tvga_wcrt(regbase, VGA_CRTC_REGS, 0x00);\t \n\n\t \n\t \n\ttmp = 0x03 | 0xc;\n\tif (var->sync & FB_SYNC_HOR_HIGH_ACT)\n\t\ttmp |= 0x40;\n\tif (var->sync & FB_SYNC_VERT_HIGH_ACT)\n\t\ttmp |= 0x80;\n\tWGen(cinfo, VGA_MIS_W, tmp);\n\n\t \n\tvga_wcrt(regbase, VGA_CRTC_CURSOR_START, 0);\n\t \n\tvga_wcrt(regbase, VGA_CRTC_CURSOR_END, 31);\n\n\t \n\n\t \n\tif (var->bits_per_pixel == 1) {\n\t\tdev_dbg(info->device, \"preparing for 1 bit deep display\\n\");\n\t\tvga_wgfx(regbase, VGA_GFX_MODE, 0);\t \n\n\t\t \n\t\tswitch (cinfo->btype) {\n\t\tcase BT_SD64:\n\t\tcase BT_PICCOLO:\n\t\tcase BT_PICASSO:\n\t\tcase BT_SPECTRUM:\n\t\tcase BT_PICASSO4:\n\t\tcase BT_ALPINE:\n\t\tcase BT_GD5480:\n\t\t\tvga_wseq(regbase, CL_SEQR7,\n\t\t\t\t cinfo->multiplexing ?\n\t\t\t\t\tbi->sr07_1bpp_mux : bi->sr07_1bpp);\n\t\t\tbreak;\n\n\t\tcase BT_LAGUNA:\n\t\tcase BT_LAGUNAB:\n\t\t\tvga_wseq(regbase, CL_SEQR7,\n\t\t\t\tvga_rseq(regbase, CL_SEQR7) & ~0x01);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(info->device, \"unknown Board\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tswitch (cinfo->btype) {\n\n\t\tcase BT_PICCOLO:\n\t\tcase BT_SPECTRUM:\n\t\t\t \n\t\t\tvga_wseq(regbase, CL_SEQRF, 0xb0);\n\t\t\tbreak;\n\n\t\tcase BT_PICASSO:\n\t\t\t \n\t\t\tvga_wseq(regbase, CL_SEQRF, 0xd0);\n\t\t\tbreak;\n\n\t\tcase BT_SD64:\n\t\tcase BT_PICASSO4:\n\t\tcase BT_ALPINE:\n\t\tcase BT_GD5480:\n\t\tcase BT_LAGUNA:\n\t\tcase BT_LAGUNAB:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(info->device, \"unknown Board\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tWGen(cinfo, VGA_PEL_MSK, 0x01);\n\t\tif (cinfo->multiplexing)\n\t\t\t \n\t\t\tWHDR(cinfo, 0x4a);\n\t\telse\n\t\t\t \n\t\t\tWHDR(cinfo, 0);\n\t\t \n\t\tvga_wseq(regbase, VGA_SEQ_MEMORY_MODE, 0x06);\n\t\t \n\t\tvga_wseq(regbase, VGA_SEQ_PLANE_WRITE, 0x01);\n\t}\n\n\t \n\n\telse if (var->bits_per_pixel == 8) {\n\t\tdev_dbg(info->device, \"preparing for 8 bit deep display\\n\");\n\t\tswitch (cinfo->btype) {\n\t\tcase BT_SD64:\n\t\tcase BT_PICCOLO:\n\t\tcase BT_PICASSO:\n\t\tcase BT_SPECTRUM:\n\t\tcase BT_PICASSO4:\n\t\tcase BT_ALPINE:\n\t\tcase BT_GD5480:\n\t\t\tvga_wseq(regbase, CL_SEQR7,\n\t\t\t\t  cinfo->multiplexing ?\n\t\t\t\t\tbi->sr07_8bpp_mux : bi->sr07_8bpp);\n\t\t\tbreak;\n\n\t\tcase BT_LAGUNA:\n\t\tcase BT_LAGUNAB:\n\t\t\tvga_wseq(regbase, CL_SEQR7,\n\t\t\t\tvga_rseq(regbase, CL_SEQR7) | 0x01);\n\t\t\tthreshold |= 0x10;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(info->device, \"unknown Board\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (cinfo->btype) {\n\t\tcase BT_PICCOLO:\n\t\tcase BT_PICASSO:\n\t\tcase BT_SPECTRUM:\n\t\t\t \n\t\t\tvga_wseq(regbase, CL_SEQRF, 0xb0);\n\t\t\tbreak;\n\n\t\tcase BT_PICASSO4:\n#ifdef CONFIG_ZORRO\n\t\t\t \n\t\t\tvga_wseq(regbase, CL_SEQRF, 0xb8);\n#endif\n\t\tcase BT_ALPINE:\n\t\tcase BT_SD64:\n\t\tcase BT_GD5480:\n\t\tcase BT_LAGUNA:\n\t\tcase BT_LAGUNAB:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(info->device, \"unknown board\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tvga_wgfx(regbase, VGA_GFX_MODE, 64);\n\t\tif (cinfo->multiplexing)\n\t\t\t \n\t\t\tWHDR(cinfo, 0x4a);\n\t\telse\n\t\t\t \n\t\t\tWHDR(cinfo, 0);\n\t}\n\n\t \n\n\telse if (var->bits_per_pixel == 16) {\n\t\tdev_dbg(info->device, \"preparing for 16 bit deep display\\n\");\n\t\tswitch (cinfo->btype) {\n\t\tcase BT_PICCOLO:\n\t\tcase BT_SPECTRUM:\n\t\t\tvga_wseq(regbase, CL_SEQR7, 0x87);\n\t\t\t \n\t\t\tvga_wseq(regbase, CL_SEQRF, 0xb0);\n\t\t\tbreak;\n\n\t\tcase BT_PICASSO:\n\t\t\tvga_wseq(regbase, CL_SEQR7, 0x27);\n\t\t\t \n\t\t\tvga_wseq(regbase, CL_SEQRF, 0xb0);\n\t\t\tbreak;\n\n\t\tcase BT_SD64:\n\t\tcase BT_PICASSO4:\n\t\tcase BT_ALPINE:\n\t\t\t \n\t\t\tvga_wseq(regbase, CL_SEQR7,\n\t\t\t\t\tcinfo->doubleVCLK ? 0xa3 : 0xa7);\n\t\t\tbreak;\n\n\t\tcase BT_GD5480:\n\t\t\tvga_wseq(regbase, CL_SEQR7, 0x17);\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase BT_LAGUNA:\n\t\tcase BT_LAGUNAB:\n\t\t\tvga_wseq(regbase, CL_SEQR7,\n\t\t\t\tvga_rseq(regbase, CL_SEQR7) & ~0x01);\n\t\t\tcontrol |= 0x2000;\n\t\t\tformat |= 0x1400;\n\t\t\tthreshold |= 0x10;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(info->device, \"unknown Board\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tvga_wgfx(regbase, VGA_GFX_MODE, 64);\n#ifdef CONFIG_PCI\n\t\tWHDR(cinfo, cinfo->doubleVCLK ? 0xe1 : 0xc1);\n#elif defined(CONFIG_ZORRO)\n\t\t \n\t\tWHDR(cinfo, 0xa0);\t \n#endif\n\t}\n\n\t \n\n\telse if (var->bits_per_pixel == 24) {\n\t\tdev_dbg(info->device, \"preparing for 24 bit deep display\\n\");\n\t\tswitch (cinfo->btype) {\n\t\tcase BT_PICCOLO:\n\t\tcase BT_SPECTRUM:\n\t\t\tvga_wseq(regbase, CL_SEQR7, 0x85);\n\t\t\t \n\t\t\tvga_wseq(regbase, CL_SEQRF, 0xb0);\n\t\t\tbreak;\n\n\t\tcase BT_PICASSO:\n\t\t\tvga_wseq(regbase, CL_SEQR7, 0x25);\n\t\t\t \n\t\t\tvga_wseq(regbase, CL_SEQRF, 0xb0);\n\t\t\tbreak;\n\n\t\tcase BT_SD64:\n\t\tcase BT_PICASSO4:\n\t\tcase BT_ALPINE:\n\t\t\t \n\t\t\tvga_wseq(regbase, CL_SEQR7, 0xa5);\n\t\t\tbreak;\n\n\t\tcase BT_GD5480:\n\t\t\tvga_wseq(regbase, CL_SEQR7, 0x15);\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase BT_LAGUNA:\n\t\tcase BT_LAGUNAB:\n\t\t\tvga_wseq(regbase, CL_SEQR7,\n\t\t\t\tvga_rseq(regbase, CL_SEQR7) & ~0x01);\n\t\t\tcontrol |= 0x4000;\n\t\t\tformat |= 0x2400;\n\t\t\tthreshold |= 0x20;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(info->device, \"unknown Board\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tvga_wgfx(regbase, VGA_GFX_MODE, 64);\n\t\t \n\t\tWHDR(cinfo, 0xc5);\n\t}\n\n\t \n\n\telse\n\t\tdev_err(info->device,\n\t\t\t\"What's this? requested color depth == %d.\\n\",\n\t\t\tvar->bits_per_pixel);\n\n\tpitch = info->fix.line_length >> 3;\n\tvga_wcrt(regbase, VGA_CRTC_OFFSET, pitch & 0xff);\n\ttmp = 0x22;\n\tif (pitch & 0x100)\n\t\ttmp |= 0x10;\t \n\n\t \n\tvga_wcrt(regbase, CL_CRT1B, tmp);\n\n\t \n\tif (cirrusfb_board_info[cinfo->btype].scrn_start_bit19)\n\t\tvga_wcrt(regbase, CL_CRT1D, (pitch >> 9) & 1);\n\n\tif (is_laguna(cinfo)) {\n\t\ttmp = 0;\n\t\tif ((htotal + 5) & 256)\n\t\t\ttmp |= 128;\n\t\tif (hdispend & 256)\n\t\t\ttmp |= 64;\n\t\tif (hsyncstart & 256)\n\t\t\ttmp |= 48;\n\t\tif (vtotal & 1024)\n\t\t\ttmp |= 8;\n\t\tif (vdispend & 1024)\n\t\t\ttmp |= 4;\n\t\tif (vsyncstart & 1024)\n\t\t\ttmp |= 3;\n\n\t\tvga_wcrt(regbase, CL_CRT1E, tmp);\n\t\tdev_dbg(info->device, \"CRT1e: %d\\n\", tmp);\n\t}\n\n\t \n\tvga_wattr(regbase, CL_AR33, 0);\n\n\t \n\t \n\tAttrOn(cinfo);\n\n\tif (is_laguna(cinfo)) {\n\t\t \n\t\tfb_writew(control | 0x1000, cinfo->laguna_mmio + 0x402);\n\t\tfb_writew(format, cinfo->laguna_mmio + 0xc0);\n\t\tfb_writew(threshold, cinfo->laguna_mmio + 0xea);\n\t}\n\t \n\t \n\ttmp = 0x01;\n\n \n\n\tvga_wseq(regbase, VGA_SEQ_CLOCK_MODE, tmp);\n\tdev_dbg(info->device, \"CL_SEQR1: %d\\n\", tmp);\n\n#ifdef CIRRUSFB_DEBUG\n\tcirrusfb_dbg_reg_dump(info, NULL);\n#endif\n\n\treturn 0;\n}\n\n \nstatic int cirrusfb_set_par(struct fb_info *info)\n{\n\tcirrusfb_set_par_foo(info);\n\treturn cirrusfb_set_par_foo(info);\n}\n\nstatic int cirrusfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t      unsigned blue, unsigned transp,\n\t\t\t      struct fb_info *info)\n{\n\tstruct cirrusfb_info *cinfo = info->par;\n\n\tif (regno > 255)\n\t\treturn -EINVAL;\n\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\tu32 v;\n\t\tred >>= (16 - info->var.red.length);\n\t\tgreen >>= (16 - info->var.green.length);\n\t\tblue >>= (16 - info->var.blue.length);\n\n\t\tif (regno >= 16)\n\t\t\treturn 1;\n\t\tv = (red << info->var.red.offset) |\n\t\t    (green << info->var.green.offset) |\n\t\t    (blue << info->var.blue.offset);\n\n\t\tcinfo->pseudo_palette[regno] = v;\n\t\treturn 0;\n\t}\n\n\tif (info->var.bits_per_pixel == 8)\n\t\tWClut(cinfo, regno, red >> 10, green >> 10, blue >> 10);\n\n\treturn 0;\n\n}\n\n \nstatic int cirrusfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info)\n{\n\tint xoffset;\n\tunsigned long base;\n\tunsigned char tmp, xpix;\n\tstruct cirrusfb_info *cinfo = info->par;\n\n\t \n\t \n\tif (var->vmode & FB_VMODE_YWRAP)\n\t\treturn -EINVAL;\n\n\txoffset = var->xoffset * info->var.bits_per_pixel / 8;\n\n\tbase = var->yoffset * info->fix.line_length + xoffset;\n\n\tif (info->var.bits_per_pixel == 1) {\n\t\t \n\t\txpix = (unsigned char) (var->xoffset % 8);\n\t} else {\n\t\tbase /= 4;\n\t\txpix = (unsigned char) ((xoffset % 4) * 2);\n\t}\n\n\tif (!is_laguna(cinfo))\n\t\tcirrusfb_WaitBLT(cinfo->regbase);\n\n\t \n\tvga_wcrt(cinfo->regbase, VGA_CRTC_START_LO, base & 0xff);\n\tvga_wcrt(cinfo->regbase, VGA_CRTC_START_HI, (base >> 8) & 0xff);\n\n\t \n\ttmp = vga_rcrt(cinfo->regbase, CL_CRT1B) & 0xf2;\n\t \n\tif (base & 0x10000)\n\t\ttmp |= 0x01;\n\tif (base & 0x20000)\n\t\ttmp |= 0x04;\n\tif (base & 0x40000)\n\t\ttmp |= 0x08;\n\n\tvga_wcrt(cinfo->regbase, CL_CRT1B, tmp);\n\n\t \n\tif (cirrusfb_board_info[cinfo->btype].scrn_start_bit19) {\n\t\ttmp = vga_rcrt(cinfo->regbase, CL_CRT1D);\n\t\tif (is_laguna(cinfo))\n\t\t\ttmp = (tmp & ~0x18) | ((base >> 16) & 0x18);\n\t\telse\n\t\t\ttmp = (tmp & ~0x80) | ((base >> 12) & 0x80);\n\t\tvga_wcrt(cinfo->regbase, CL_CRT1D, tmp);\n\t}\n\n\t \n\tif (info->var.bits_per_pixel == 1)\n\t\tvga_wattr(cinfo->regbase, CL_AR33, xpix);\n\n\treturn 0;\n}\n\nstatic int cirrusfb_blank(int blank_mode, struct fb_info *info)\n{\n\t \n\tunsigned char val;\n\tstruct cirrusfb_info *cinfo = info->par;\n\tint current_mode = cinfo->blank_mode;\n\n\tdev_dbg(info->device, \"ENTER, blank mode = %d\\n\", blank_mode);\n\n\tif (info->state != FBINFO_STATE_RUNNING ||\n\t    current_mode == blank_mode) {\n\t\tdev_dbg(info->device, \"EXIT, returning 0\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (current_mode == FB_BLANK_NORMAL ||\n\t    current_mode == FB_BLANK_UNBLANK)\n\t\t \n\t\tval = 0;\n\telse\n\t\t \n\t\tval = 0x20;\n\n\tval |= vga_rseq(cinfo->regbase, VGA_SEQ_CLOCK_MODE) & 0xdf;\n\tvga_wseq(cinfo->regbase, VGA_SEQ_CLOCK_MODE, val);\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\tcase FB_BLANK_NORMAL:\n\t\tval = 0x00;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tval = 0x04;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tval = 0x02;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tval = 0x06;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(info->device, \"EXIT, returning 1\\n\");\n\t\treturn 1;\n\t}\n\n\tvga_wgfx(cinfo->regbase, CL_GRE, val);\n\n\tcinfo->blank_mode = blank_mode;\n\tdev_dbg(info->device, \"EXIT, returning 0\\n\");\n\n\t \n\treturn (blank_mode == FB_BLANK_NORMAL) ? 1 : 0;\n}\n\n \n \n \n\nstatic void init_vgachip(struct fb_info *info)\n{\n\tstruct cirrusfb_info *cinfo = info->par;\n\tconst struct cirrusfb_board_info_rec *bi;\n\n\tassert(cinfo != NULL);\n\n\tbi = &cirrusfb_board_info[cinfo->btype];\n\n\t \n\tswitch (cinfo->btype) {\n\tcase BT_PICCOLO:\n\t\tWSFR(cinfo, 0x01);\n\t\tudelay(500);\n\t\tWSFR(cinfo, 0x51);\n\t\tudelay(500);\n\t\tbreak;\n\tcase BT_PICASSO:\n\t\tWSFR2(cinfo, 0xff);\n\t\tudelay(500);\n\t\tbreak;\n\tcase BT_SD64:\n\tcase BT_SPECTRUM:\n\t\tWSFR(cinfo, 0x1f);\n\t\tudelay(500);\n\t\tWSFR(cinfo, 0x4f);\n\t\tudelay(500);\n\t\tbreak;\n\tcase BT_PICASSO4:\n\t\t \n\t\tvga_wcrt(cinfo->regbase, CL_CRT51, 0x00);\n\t\tmdelay(100);\n\t\t \n\t\tvga_wgfx(cinfo->regbase, CL_GR31, 0x00);\n\t\tfallthrough;\n\tcase BT_GD5480:\n\t\t \n\t\tvga_wgfx(cinfo->regbase, CL_GR2F, 0x00);\n\t\tfallthrough;\n\tcase BT_ALPINE:\n\t\t \n\t\tvga_wgfx(cinfo->regbase, CL_GR33, 0x00);\n\t\tbreak;\n\n\tcase BT_LAGUNA:\n\tcase BT_LAGUNAB:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(info->device, \"Warning: Unknown board type\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tassert(info->screen_size > 0);\n\n\t \n\t \n\t \n\n\tif (cinfo->btype != BT_PICASSO4) {\n\t\tWGen(cinfo, CL_VSSM, 0x10);\t \n\t\tWGen(cinfo, CL_POS102, 0x01);\n\t\tWGen(cinfo, CL_VSSM, 0x08);\t \n\n\t\tif (cinfo->btype != BT_SD64)\n\t\t\tWGen(cinfo, CL_VSSM2, 0x01);\n\n\t\t \n\t\tvga_wseq(cinfo->regbase, VGA_SEQ_RESET, 0x03);\n\n\t\t \n\t\tvga_wseq(cinfo->regbase, VGA_SEQ_CLOCK_MODE, 0x21);\n\n\t\t \n \n\t\t \n\t\tvga_wseq(cinfo->regbase, CL_SEQR6, 0x12);\n\n\t\tswitch (cinfo->btype) {\n\t\tcase BT_GD5480:\n\t\t\tvga_wseq(cinfo->regbase, CL_SEQRF, 0x98);\n\t\t\tbreak;\n\t\tcase BT_ALPINE:\n\t\tcase BT_LAGUNA:\n\t\tcase BT_LAGUNAB:\n\t\t\tbreak;\n\t\tcase BT_SD64:\n#ifdef CONFIG_ZORRO\n\t\t\tvga_wseq(cinfo->regbase, CL_SEQRF, 0xb8);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvga_wseq(cinfo->regbase, CL_SEQR16, 0x0f);\n\t\t\tvga_wseq(cinfo->regbase, CL_SEQRF, 0xb0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tvga_wseq(cinfo->regbase, VGA_SEQ_PLANE_WRITE, 0xff);\n\t \n\tvga_wseq(cinfo->regbase, VGA_SEQ_CHARACTER_MAP, 0x00);\n\t \n\tvga_wseq(cinfo->regbase, VGA_SEQ_MEMORY_MODE, 0x0a);\n\n\t \n\tif (bi->init_sr07)\n\t\tvga_wseq(cinfo->regbase, CL_SEQR7, bi->sr07);\n\n\t \n\t \n\n\t \n\tvga_wseq(cinfo->regbase, CL_SEQR10, 0x00);\n\t \n\tvga_wseq(cinfo->regbase, CL_SEQR11, 0x00);\n\t \n\tvga_wseq(cinfo->regbase, CL_SEQR12, 0x00);\n\t \n\tvga_wseq(cinfo->regbase, CL_SEQR13, 0x00);\n\n\t \n\tif (cinfo->btype != BT_PICASSO4) {\n\t\t \n\t\tvga_wseq(cinfo->regbase, CL_SEQR17, 0x00);\n\t\t \n\t\tvga_wseq(cinfo->regbase, CL_SEQR18, 0x02);\n\t}\n\n\t \n\tvga_wcrt(cinfo->regbase, VGA_CRTC_PRESET_ROW, 0x00);\n\t \n\tvga_wcrt(cinfo->regbase, VGA_CRTC_CURSOR_START, 0x20);\n\t \n\tvga_wcrt(cinfo->regbase, VGA_CRTC_CURSOR_END, 0x00);\n\t \n\tvga_wcrt(cinfo->regbase, VGA_CRTC_CURSOR_HI, 0x00);\n\t \n\tvga_wcrt(cinfo->regbase, VGA_CRTC_CURSOR_LO, 0x00);\n\n\t \n\tvga_wcrt(cinfo->regbase, VGA_CRTC_UNDERLINE, 0x00);\n\t \n\t \n\tvga_wcrt(cinfo->regbase, CL_CRT1B, 0x02);\n\n\t \n\tvga_wgfx(cinfo->regbase, VGA_GFX_SR_VALUE, 0x00);\n\t \n\tvga_wgfx(cinfo->regbase, VGA_GFX_SR_ENABLE, 0x00);\n\t \n\tvga_wgfx(cinfo->regbase, VGA_GFX_COMPARE_VALUE, 0x00);\n\t \n\tvga_wgfx(cinfo->regbase, VGA_GFX_DATA_ROTATE, 0x00);\n\t \n\tvga_wgfx(cinfo->regbase, VGA_GFX_PLANE_READ, 0x00);\n\t \n\tvga_wgfx(cinfo->regbase, VGA_GFX_MODE, 0x00);\n\t \n\tvga_wgfx(cinfo->regbase, VGA_GFX_MISC, 0x01);\n\t \n\tvga_wgfx(cinfo->regbase, VGA_GFX_COMPARE_MASK, 0x0f);\n\t \n\tvga_wgfx(cinfo->regbase, VGA_GFX_BIT_MASK, 0xff);\n\n\tif (cinfo->btype == BT_ALPINE || cinfo->btype == BT_SD64 ||\n\t    is_laguna(cinfo))\n\t\t \n\t\tvga_wgfx(cinfo->regbase, CL_GRB, 0x20);\n\telse\n\t \n\t\tvga_wgfx(cinfo->regbase, CL_GRB, 0x28);\n\n\tvga_wgfx(cinfo->regbase, CL_GRC, 0xff);\t \n\tvga_wgfx(cinfo->regbase, CL_GRD, 0x00);\t \n\tvga_wgfx(cinfo->regbase, CL_GRE, 0x00);\t \n\t \n\t \n\t \n\n\t \n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTE0, 0x00);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTE1, 0x01);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTE2, 0x02);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTE3, 0x03);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTE4, 0x04);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTE5, 0x05);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTE6, 0x06);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTE7, 0x07);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTE8, 0x08);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTE9, 0x09);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTEA, 0x0a);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTEB, 0x0b);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTEC, 0x0c);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTED, 0x0d);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTEE, 0x0e);\n\tvga_wattr(cinfo->regbase, VGA_ATC_PALETTEF, 0x0f);\n\n\t \n\tvga_wattr(cinfo->regbase, VGA_ATC_MODE, 0x01);\n\t \n\tvga_wattr(cinfo->regbase, VGA_ATC_OVERSCAN, 0x00);\n\t \n\tvga_wattr(cinfo->regbase, VGA_ATC_PLANE_ENABLE, 0x0f);\n\t \n\tvga_wattr(cinfo->regbase, VGA_ATC_COLOR_PAGE, 0x00);\n\n\tWGen(cinfo, VGA_PEL_MSK, 0xff);\t \n\n\t \n\tvga_wgfx(cinfo->regbase, CL_GR31, 0x04);\n\t \n\tvga_wgfx(cinfo->regbase, CL_GR31, 0x00);\n\n\t \n\tWHDR(cinfo, 0);\t \n\treturn;\n}\n\nstatic void switch_monitor(struct cirrusfb_info *cinfo, int on)\n{\n#ifdef CONFIG_ZORRO  \n\tstatic int IsOn = 0;\t \n\n\tif (cinfo->btype == BT_PICASSO4)\n\t\treturn;\t\t \n\tif (cinfo->btype == BT_ALPINE)\n\t\treturn;\t\t \n\tif (cinfo->btype == BT_GD5480)\n\t\treturn;\t\t \n\tif (cinfo->btype == BT_PICASSO) {\n\t\tif ((on && !IsOn) || (!on && IsOn))\n\t\t\tWSFR(cinfo, 0xff);\n\t\treturn;\n\t}\n\tif (on) {\n\t\tswitch (cinfo->btype) {\n\t\tcase BT_SD64:\n\t\t\tWSFR(cinfo, cinfo->SFR | 0x21);\n\t\t\tbreak;\n\t\tcase BT_PICCOLO:\n\t\t\tWSFR(cinfo, cinfo->SFR | 0x28);\n\t\t\tbreak;\n\t\tcase BT_SPECTRUM:\n\t\t\tWSFR(cinfo, 0x6f);\n\t\t\tbreak;\n\t\tdefault:   break;\n\t\t}\n\t} else {\n\t\tswitch (cinfo->btype) {\n\t\tcase BT_SD64:\n\t\t\tWSFR(cinfo, cinfo->SFR & 0xde);\n\t\t\tbreak;\n\t\tcase BT_PICCOLO:\n\t\t\tWSFR(cinfo, cinfo->SFR & 0xd7);\n\t\t\tbreak;\n\t\tcase BT_SPECTRUM:\n\t\t\tWSFR(cinfo, 0x4f);\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tbreak;\n\t\t}\n\t}\n#endif  \n}\n\n \n \n \n\nstatic int cirrusfb_sync(struct fb_info *info)\n{\n\tstruct cirrusfb_info *cinfo = info->par;\n\n\tif (!is_laguna(cinfo)) {\n\t\twhile (vga_rgfx(cinfo->regbase, CL_GR31) & 0x03)\n\t\t\tcpu_relax();\n\t}\n\treturn 0;\n}\n\nstatic void cirrusfb_fillrect(struct fb_info *info,\n\t\t\t      const struct fb_fillrect *region)\n{\n\tstruct fb_fillrect modded;\n\tint vxres, vyres;\n\tstruct cirrusfb_info *cinfo = info->par;\n\tint m = info->var.bits_per_pixel;\n\tu32 color = (info->fix.visual == FB_VISUAL_TRUECOLOR) ?\n\t\tcinfo->pseudo_palette[region->color] : region->color;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\tif (info->flags & FBINFO_HWACCEL_DISABLED) {\n\t\tcfb_fillrect(info, region);\n\t\treturn;\n\t}\n\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\n\tmemcpy(&modded, region, sizeof(struct fb_fillrect));\n\n\tif (!modded.width || !modded.height ||\n\t   modded.dx >= vxres || modded.dy >= vyres)\n\t\treturn;\n\n\tif (modded.dx + modded.width  > vxres)\n\t\tmodded.width  = vxres - modded.dx;\n\tif (modded.dy + modded.height > vyres)\n\t\tmodded.height = vyres - modded.dy;\n\n\tcirrusfb_RectFill(cinfo->regbase,\n\t\t\t  info->var.bits_per_pixel,\n\t\t\t  (region->dx * m) / 8, region->dy,\n\t\t\t  (region->width * m) / 8, region->height,\n\t\t\t  color, color,\n\t\t\t  info->fix.line_length, 0x40);\n}\n\nstatic void cirrusfb_copyarea(struct fb_info *info,\n\t\t\t      const struct fb_copyarea *area)\n{\n\tstruct fb_copyarea modded;\n\tu32 vxres, vyres;\n\tstruct cirrusfb_info *cinfo = info->par;\n\tint m = info->var.bits_per_pixel;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\tif (info->flags & FBINFO_HWACCEL_DISABLED) {\n\t\tcfb_copyarea(info, area);\n\t\treturn;\n\t}\n\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\tmemcpy(&modded, area, sizeof(struct fb_copyarea));\n\n\tif (!modded.width || !modded.height ||\n\t   modded.sx >= vxres || modded.sy >= vyres ||\n\t   modded.dx >= vxres || modded.dy >= vyres)\n\t\treturn;\n\n\tif (modded.sx + modded.width > vxres)\n\t\tmodded.width = vxres - modded.sx;\n\tif (modded.dx + modded.width > vxres)\n\t\tmodded.width = vxres - modded.dx;\n\tif (modded.sy + modded.height > vyres)\n\t\tmodded.height = vyres - modded.sy;\n\tif (modded.dy + modded.height > vyres)\n\t\tmodded.height = vyres - modded.dy;\n\n\tcirrusfb_BitBLT(cinfo->regbase, info->var.bits_per_pixel,\n\t\t\t(area->sx * m) / 8, area->sy,\n\t\t\t(area->dx * m) / 8, area->dy,\n\t\t\t(area->width * m) / 8, area->height,\n\t\t\tinfo->fix.line_length);\n\n}\n\nstatic void cirrusfb_imageblit(struct fb_info *info,\n\t\t\t       const struct fb_image *image)\n{\n\tstruct cirrusfb_info *cinfo = info->par;\n\tunsigned char op = (info->var.bits_per_pixel == 24) ? 0xc : 0x4;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\t \n\tif (info->flags & FBINFO_HWACCEL_DISABLED || image->depth != 1)\n\t\tcfb_imageblit(info, image);\n\telse if ((cinfo->btype == BT_ALPINE || cinfo->btype == BT_SD64) &&\n\t\t  op == 0xc)\n\t\tcfb_imageblit(info, image);\n\telse {\n\t\tunsigned size = ((image->width + 7) >> 3) * image->height;\n\t\tint m = info->var.bits_per_pixel;\n\t\tu32 fg, bg;\n\n\t\tif (info->var.bits_per_pixel == 8) {\n\t\t\tfg = image->fg_color;\n\t\t\tbg = image->bg_color;\n\t\t} else {\n\t\t\tfg = ((u32 *)(info->pseudo_palette))[image->fg_color];\n\t\t\tbg = ((u32 *)(info->pseudo_palette))[image->bg_color];\n\t\t}\n\t\tif (info->var.bits_per_pixel == 24) {\n\t\t\t \n\t\t\tcirrusfb_RectFill(cinfo->regbase,\n\t\t\t\t\t  info->var.bits_per_pixel,\n\t\t\t\t\t  (image->dx * m) / 8, image->dy,\n\t\t\t\t\t  (image->width * m) / 8,\n\t\t\t\t\t  image->height,\n\t\t\t\t\t  bg, bg,\n\t\t\t\t\t  info->fix.line_length, 0x40);\n\t\t}\n\t\tcirrusfb_RectFill(cinfo->regbase,\n\t\t\t\t  info->var.bits_per_pixel,\n\t\t\t\t  (image->dx * m) / 8, image->dy,\n\t\t\t\t  (image->width * m) / 8, image->height,\n\t\t\t\t  fg, bg,\n\t\t\t\t  info->fix.line_length, op);\n\t\tmemcpy(info->screen_base, image->data, size);\n\t}\n}\n\n#ifdef CONFIG_PCI\nstatic int release_io_ports;\n\n \nstatic unsigned int cirrusfb_get_memsize(struct fb_info *info,\n\t\t\t\t\t u8 __iomem *regbase)\n{\n\tunsigned long mem;\n\tstruct cirrusfb_info *cinfo = info->par;\n\n\tif (is_laguna(cinfo)) {\n\t\tunsigned char SR14 = vga_rseq(regbase, CL_SEQR14);\n\n\t\tmem = ((SR14 & 7) + 1) << 20;\n\t} else {\n\t\tunsigned char SRF = vga_rseq(regbase, CL_SEQRF);\n\t\tswitch ((SRF & 0x18)) {\n\t\tcase 0x08:\n\t\t\tmem = 512 * 1024;\n\t\t\tbreak;\n\t\tcase 0x10:\n\t\t\tmem = 1024 * 1024;\n\t\t\tbreak;\n\t\t \n\t\tcase 0x18:\n\t\t\tmem = 2048 * 1024;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(info->device, \"Unknown memory size!\\n\");\n\t\t\tmem = 1024 * 1024;\n\t\t}\n\t\t \n\t\tif (cinfo->btype != BT_ALPINE && (SRF & 0x80) != 0)\n\t\t\tmem *= 2;\n\t}\n\n\t \n\treturn mem;\n}\n\nstatic void get_pci_addrs(const struct pci_dev *pdev,\n\t\t\t  unsigned long *display, unsigned long *registers)\n{\n\tassert(pdev != NULL);\n\tassert(display != NULL);\n\tassert(registers != NULL);\n\n\t*display = 0;\n\t*registers = 0;\n\n\t \n\n\tif (pci_resource_flags(pdev, 0) & IORESOURCE_IO) {\n\t\t*display = pci_resource_start(pdev, 1);\n\t\t*registers = pci_resource_start(pdev, 0);\n\t} else {\n\t\t*display = pci_resource_start(pdev, 0);\n\t\t*registers = pci_resource_start(pdev, 1);\n\t}\n\n\tassert(*display != 0);\n}\n\nstatic void cirrusfb_pci_unmap(struct fb_info *info)\n{\n\tstruct pci_dev *pdev = to_pci_dev(info->device);\n\tstruct cirrusfb_info *cinfo = info->par;\n\n\tif (cinfo->laguna_mmio == NULL)\n\t\tiounmap(cinfo->laguna_mmio);\n\tiounmap(info->screen_base);\n#if 0  \n\trelease_mem_region(0xA0000, 65535);\n#endif\n\tif (release_io_ports)\n\t\trelease_region(0x3C0, 32);\n\tpci_release_regions(pdev);\n}\n#endif  \n\n#ifdef CONFIG_ZORRO\nstatic void cirrusfb_zorro_unmap(struct fb_info *info)\n{\n\tstruct cirrusfb_info *cinfo = info->par;\n\tstruct zorro_dev *zdev = to_zorro_dev(info->device);\n\n\tif (info->fix.smem_start > 16 * MB_)\n\t\tiounmap(info->screen_base);\n\tif (info->fix.mmio_start > 16 * MB_)\n\t\tiounmap(cinfo->regbase);\n\n\tzorro_release_device(zdev);\n}\n#endif  \n\n \nstatic const struct fb_ops cirrusfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= cirrusfb_open,\n\t.fb_release\t= cirrusfb_release,\n\t.fb_setcolreg\t= cirrusfb_setcolreg,\n\t.fb_check_var\t= cirrusfb_check_var,\n\t.fb_set_par\t= cirrusfb_set_par,\n\t.fb_pan_display = cirrusfb_pan_display,\n\t.fb_blank\t= cirrusfb_blank,\n\t.fb_fillrect\t= cirrusfb_fillrect,\n\t.fb_copyarea\t= cirrusfb_copyarea,\n\t.fb_sync\t= cirrusfb_sync,\n\t.fb_imageblit\t= cirrusfb_imageblit,\n};\n\nstatic int cirrusfb_set_fbinfo(struct fb_info *info)\n{\n\tstruct cirrusfb_info *cinfo = info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\n\tinfo->pseudo_palette = cinfo->pseudo_palette;\n\tinfo->flags = FBINFO_HWACCEL_XPAN\n\t\t    | FBINFO_HWACCEL_YPAN\n\t\t    | FBINFO_HWACCEL_FILLRECT\n\t\t    | FBINFO_HWACCEL_IMAGEBLIT\n\t\t    | FBINFO_HWACCEL_COPYAREA;\n\tif (noaccel || is_laguna(cinfo)) {\n\t\tinfo->flags |= FBINFO_HWACCEL_DISABLED;\n\t\tinfo->fix.accel = FB_ACCEL_NONE;\n\t} else\n\t\tinfo->fix.accel = FB_ACCEL_CIRRUS_ALPINE;\n\n\tinfo->fbops = &cirrusfb_ops;\n\n\tif (cinfo->btype == BT_GD5480) {\n\t\tif (var->bits_per_pixel == 16)\n\t\t\tinfo->screen_base += 1 * MB_;\n\t\tif (var->bits_per_pixel == 32)\n\t\t\tinfo->screen_base += 2 * MB_;\n\t}\n\n\t \n\tstrscpy(info->fix.id, cirrusfb_board_info[cinfo->btype].name,\n\t\tsizeof(info->fix.id));\n\n\t \n\t \n\tinfo->fix.smem_len   = info->screen_size;\n\tif (var->bits_per_pixel == 1)\n\t\tinfo->fix.smem_len /= 4;\n\tinfo->fix.type_aux   = 0;\n\tinfo->fix.xpanstep   = 1;\n\tinfo->fix.ypanstep   = 1;\n\tinfo->fix.ywrapstep  = 0;\n\n\t \n\tinfo->fix.mmio_len   = 0;\n\n\tfb_alloc_cmap(&info->cmap, 256, 0);\n\n\treturn 0;\n}\n\nstatic int cirrusfb_register(struct fb_info *info)\n{\n\tstruct cirrusfb_info *cinfo = info->par;\n\tint err;\n\n\t \n\tassert(cinfo->btype != BT_NONE);\n\n\t \n\tcirrusfb_set_fbinfo(info);\n\n\tdev_dbg(info->device, \"(RAM start set to: 0x%p)\\n\", info->screen_base);\n\n\terr = fb_find_mode(&info->var, info, mode_option, NULL, 0, NULL, 8);\n\tif (!err) {\n\t\tdev_dbg(info->device, \"wrong initial video mode\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_dealloc_cmap;\n\t}\n\n\tinfo->var.activate = FB_ACTIVATE_NOW;\n\n\terr = cirrusfb_check_var(&info->var, info);\n\tif (err < 0) {\n\t\t \n\t\tdev_dbg(info->device,\n\t\t\t\"choking on default var... umm, no good.\\n\");\n\t\tgoto err_dealloc_cmap;\n\t}\n\n\terr = register_framebuffer(info);\n\tif (err < 0) {\n\t\tdev_err(info->device,\n\t\t\t\"could not register fb device; err = %d!\\n\", err);\n\t\tgoto err_dealloc_cmap;\n\t}\n\n\treturn 0;\n\nerr_dealloc_cmap:\n\tfb_dealloc_cmap(&info->cmap);\n\treturn err;\n}\n\nstatic void cirrusfb_cleanup(struct fb_info *info)\n{\n\tstruct cirrusfb_info *cinfo = info->par;\n\n\tswitch_monitor(cinfo, 0);\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\tdev_dbg(info->device, \"Framebuffer unregistered\\n\");\n\tcinfo->unmap(info);\n\tframebuffer_release(info);\n}\n\n#ifdef CONFIG_PCI\nstatic int cirrusfb_pci_register(struct pci_dev *pdev,\n\t\t\t\t const struct pci_device_id *ent)\n{\n\tstruct cirrusfb_info *cinfo;\n\tstruct fb_info *info;\n\tunsigned long board_addr, board_size;\n\tint ret;\n\n\tret = aperture_remove_conflicting_pci_devices(pdev, \"cirrusfb\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"cirrusfb: Cannot enable PCI device\\n\");\n\t\tgoto err_out;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct cirrusfb_info), &pdev->dev);\n\tif (!info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tcinfo = info->par;\n\tcinfo->btype = (enum cirrus_board) ent->driver_data;\n\n\tdev_dbg(info->device,\n\t\t\" Found PCI device, base address 0 is 0x%Lx, btype set to %d\\n\",\n\t\t(unsigned long long)pdev->resource[0].start,  cinfo->btype);\n\tdev_dbg(info->device, \" base address 1 is 0x%Lx\\n\",\n\t\t(unsigned long long)pdev->resource[1].start);\n\n\tdev_dbg(info->device,\n\t\t\"Attempt to get PCI info for Cirrus Graphics Card\\n\");\n\tget_pci_addrs(pdev, &board_addr, &info->fix.mmio_start);\n\t \n\tcinfo->regbase = NULL;\n\tcinfo->laguna_mmio = ioremap(info->fix.mmio_start, 0x1000);\n\n\tdev_dbg(info->device, \"Board address: 0x%lx, register address: 0x%lx\\n\",\n\t\tboard_addr, info->fix.mmio_start);\n\n\tboard_size = (cinfo->btype == BT_GD5480) ?\n\t\t32 * MB_ : cirrusfb_get_memsize(info, cinfo->regbase);\n\n\tret = pci_request_regions(pdev, \"cirrusfb\");\n\tif (ret < 0) {\n\t\tdev_err(info->device, \"cannot reserve region 0x%lx, abort\\n\",\n\t\t\tboard_addr);\n\t\tgoto err_release_fb;\n\t}\n#if 0  \n\tif (!request_mem_region(0xA0000, 65535, \"cirrusfb\")) {\n\t\tdev_err(info->device, \"cannot reserve region 0x%lx, abort\\n\",\n\t\t\t0xA0000L);\n\t\tret = -EBUSY;\n\t\tgoto err_release_regions;\n\t}\n#endif\n\tif (request_region(0x3C0, 32, \"cirrusfb\"))\n\t\trelease_io_ports = 1;\n\n\tinfo->screen_base = ioremap(board_addr, board_size);\n\tif (!info->screen_base) {\n\t\tret = -EIO;\n\t\tgoto err_release_legacy;\n\t}\n\n\tinfo->fix.smem_start = board_addr;\n\tinfo->screen_size = board_size;\n\tcinfo->unmap = cirrusfb_pci_unmap;\n\n\tdev_info(info->device,\n\t\t \"Cirrus Logic chipset on PCI bus, RAM (%lu kB) at 0x%lx\\n\",\n\t\t info->screen_size >> 10, board_addr);\n\tpci_set_drvdata(pdev, info);\n\n\tret = cirrusfb_register(info);\n\tif (!ret)\n\t\treturn 0;\n\n\tiounmap(info->screen_base);\nerr_release_legacy:\n\tif (release_io_ports)\n\t\trelease_region(0x3C0, 32);\n#if 0\n\trelease_mem_region(0xA0000, 65535);\nerr_release_regions:\n#endif\n\tpci_release_regions(pdev);\nerr_release_fb:\n\tif (cinfo->laguna_mmio != NULL)\n\t\tiounmap(cinfo->laguna_mmio);\n\tframebuffer_release(info);\nerr_out:\n\treturn ret;\n}\n\nstatic void cirrusfb_pci_unregister(struct pci_dev *pdev)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\n\tcirrusfb_cleanup(info);\n}\n\nstatic struct pci_driver cirrusfb_pci_driver = {\n\t.name\t\t= \"cirrusfb\",\n\t.id_table\t= cirrusfb_pci_table,\n\t.probe\t\t= cirrusfb_pci_register,\n\t.remove\t\t= cirrusfb_pci_unregister,\n};\n#endif  \n\n#ifdef CONFIG_ZORRO\nstatic int cirrusfb_zorro_register(struct zorro_dev *z,\n\t\t\t\t   const struct zorro_device_id *ent)\n{\n\tstruct fb_info *info;\n\tint error;\n\tconst struct zorrocl *zcl;\n\tenum cirrus_board btype;\n\tunsigned long regbase, ramsize, rambase;\n\tstruct cirrusfb_info *cinfo;\n\n\tinfo = framebuffer_alloc(sizeof(struct cirrusfb_info), &z->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tzcl = (const struct zorrocl *)ent->driver_data;\n\tbtype = zcl->type;\n\tregbase = zorro_resource_start(z) + zcl->regoffset;\n\tramsize = zcl->ramsize;\n\tif (ramsize) {\n\t\trambase = zorro_resource_start(z) + zcl->ramoffset;\n\t\tif (zorro_resource_len(z) == 64 * MB_) {\n\t\t\t \n\t\t\trambase += zcl->ramoffset;\n\t\t}\n\t} else {\n\t\tstruct zorro_dev *ram = zorro_find_device(zcl->ramid, NULL);\n\t\tif (!ram || !zorro_resource_len(ram)) {\n\t\t\tdev_err(info->device, \"No video RAM found\\n\");\n\t\t\terror = -ENODEV;\n\t\t\tgoto err_release_fb;\n\t\t}\n\t\trambase = zorro_resource_start(ram);\n\t\tramsize = zorro_resource_len(ram);\n\t\tif (zcl->ramid2 &&\n\t\t    (ram = zorro_find_device(zcl->ramid2, NULL))) {\n\t\t\tif (zorro_resource_start(ram) != rambase + ramsize) {\n\t\t\t\tdev_warn(info->device,\n\t\t\t\t\t \"Skipping non-contiguous RAM at %pR\\n\",\n\t\t\t\t\t &ram->resource);\n\t\t\t} else {\n\t\t\t\tramsize += zorro_resource_len(ram);\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_info(info->device,\n\t\t \"%s board detected, REG at 0x%lx, %lu MiB RAM at 0x%lx\\n\",\n\t\t cirrusfb_board_info[btype].name, regbase, ramsize / MB_,\n\t\t rambase);\n\n\tif (!zorro_request_device(z, \"cirrusfb\")) {\n\t\tdev_err(info->device, \"Cannot reserve %pR\\n\", &z->resource);\n\t\terror = -EBUSY;\n\t\tgoto err_release_fb;\n\t}\n\n\tcinfo = info->par;\n\tcinfo->btype = btype;\n\n\tinfo->fix.mmio_start = regbase;\n\tcinfo->regbase = regbase > 16 * MB_ ? ioremap(regbase, 64 * 1024)\n\t\t\t\t\t    : ZTWO_VADDR(regbase);\n\tif (!cinfo->regbase) {\n\t\tdev_err(info->device, \"Cannot map registers\\n\");\n\t\terror = -EIO;\n\t\tgoto err_release_dev;\n\t}\n\n\tinfo->fix.smem_start = rambase;\n\tinfo->screen_size = ramsize;\n\tinfo->screen_base = rambase > 16 * MB_ ? ioremap(rambase, ramsize)\n\t\t\t\t\t       : ZTWO_VADDR(rambase);\n\tif (!info->screen_base) {\n\t\tdev_err(info->device, \"Cannot map video RAM\\n\");\n\t\terror = -EIO;\n\t\tgoto err_unmap_reg;\n\t}\n\n\tcinfo->unmap = cirrusfb_zorro_unmap;\n\n\tdev_info(info->device,\n\t\t \"Cirrus Logic chipset on Zorro bus, RAM (%lu MiB) at 0x%lx\\n\",\n\t\t ramsize / MB_, rambase);\n\n\t \n\tif (cirrusfb_board_info[btype].init_sr1f)\n\t\tvga_wseq(cinfo->regbase, CL_SEQR1F,\n\t\t\t cirrusfb_board_info[btype].sr1f);\n\n\terror = cirrusfb_register(info);\n\tif (error) {\n\t\tdev_err(info->device, \"Failed to register device, error %d\\n\",\n\t\t\terror);\n\t\tgoto err_unmap_ram;\n\t}\n\n\tzorro_set_drvdata(z, info);\n\treturn 0;\n\nerr_unmap_ram:\n\tif (rambase > 16 * MB_)\n\t\tiounmap(info->screen_base);\n\nerr_unmap_reg:\n\tif (regbase > 16 * MB_)\n\t\tiounmap(cinfo->regbase);\nerr_release_dev:\n\tzorro_release_device(z);\nerr_release_fb:\n\tframebuffer_release(info);\n\treturn error;\n}\n\nstatic void cirrusfb_zorro_unregister(struct zorro_dev *z)\n{\n\tstruct fb_info *info = zorro_get_drvdata(z);\n\n\tcirrusfb_cleanup(info);\n\tzorro_set_drvdata(z, NULL);\n}\n\nstatic struct zorro_driver cirrusfb_zorro_driver = {\n\t.name\t\t= \"cirrusfb\",\n\t.id_table\t= cirrusfb_zorro_table,\n\t.probe\t\t= cirrusfb_zorro_register,\n\t.remove\t\t= cirrusfb_zorro_unregister,\n};\n#endif  \n\n#ifndef MODULE\nstatic int __init cirrusfb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\n\t\tif (!strcmp(this_opt, \"noaccel\"))\n\t\t\tnoaccel = 1;\n\t\telse if (!strncmp(this_opt, \"mode:\", 5))\n\t\t\tmode_option = this_opt + 5;\n\t\telse\n\t\t\tmode_option = this_opt;\n\t}\n\treturn 0;\n}\n#endif\n\n     \n\nMODULE_AUTHOR(\"Copyright 1999,2000 Jeff Garzik <jgarzik@pobox.com>\");\nMODULE_DESCRIPTION(\"Accelerated FBDev driver for Cirrus Logic chips\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init cirrusfb_init(void)\n{\n\tint error = 0;\n\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"cirrusfb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"cirrusfb\", &option))\n\t\treturn -ENODEV;\n\tcirrusfb_setup(option);\n#endif\n\n#ifdef CONFIG_ZORRO\n\terror |= zorro_register_driver(&cirrusfb_zorro_driver);\n#endif\n#ifdef CONFIG_PCI\n\terror |= pci_register_driver(&cirrusfb_pci_driver);\n#endif\n\treturn error;\n}\n\nstatic void __exit cirrusfb_exit(void)\n{\n#ifdef CONFIG_PCI\n\tpci_unregister_driver(&cirrusfb_pci_driver);\n#endif\n#ifdef CONFIG_ZORRO\n\tzorro_unregister_driver(&cirrusfb_zorro_driver);\n#endif\n}\n\nmodule_init(cirrusfb_init);\n\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Initial video mode e.g. '648x480-8@60'\");\nmodule_param(noaccel, bool, 0);\nMODULE_PARM_DESC(noaccel, \"Disable acceleration\");\n\n#ifdef MODULE\nmodule_exit(cirrusfb_exit);\n#endif\n\n \n \n \n \n \n \n\n \nstatic void WGen(const struct cirrusfb_info *cinfo,\n\t\t  int regnum, unsigned char val)\n{\n\tunsigned long regofs = 0;\n\n\tif (cinfo->btype == BT_PICASSO) {\n\t\t \n \n\t\tif (regnum == VGA_PEL_IR || regnum == VGA_PEL_D)\n\t\t\tregofs = 0xfff;\n\t}\n\n\tvga_w(cinfo->regbase, regofs + regnum, val);\n}\n\n \nstatic unsigned char RGen(const struct cirrusfb_info *cinfo, int regnum)\n{\n\tunsigned long regofs = 0;\n\n\tif (cinfo->btype == BT_PICASSO) {\n\t\t \n \n\t\tif (regnum == VGA_PEL_IR || regnum == VGA_PEL_D)\n\t\t\tregofs = 0xfff;\n\t}\n\n\treturn vga_r(cinfo->regbase, regofs + regnum);\n}\n\n \nstatic void AttrOn(const struct cirrusfb_info *cinfo)\n{\n\tassert(cinfo != NULL);\n\n\tif (vga_rcrt(cinfo->regbase, CL_CRT24) & 0x80) {\n\t\t \n\t\t \n\t\tvga_w(cinfo->regbase, VGA_ATT_IW,\n\t\t      vga_r(cinfo->regbase, VGA_ATT_R));\n\t}\n\t \n \n\tvga_w(cinfo->regbase, VGA_ATT_IW, 0x33);\n\n\t \n\tvga_w(cinfo->regbase, VGA_ATT_IW, 0x00);\n}\n\n \n \nstatic void WHDR(const struct cirrusfb_info *cinfo, unsigned char val)\n{\n\tif (is_laguna(cinfo))\n\t\treturn;\n\tif (cinfo->btype == BT_PICASSO) {\n\t\t \n\t\t \n\t\tWGen(cinfo, VGA_PEL_MSK, 0x00);\n\t\tudelay(200);\n\t\t \n\t\tRGen(cinfo, VGA_PEL_IW);\n\t\tudelay(200);\n\t}\n\t \n\n\tRGen(cinfo, VGA_PEL_MSK);\n\tudelay(200);\n\tRGen(cinfo, VGA_PEL_MSK);\n\tudelay(200);\n\tRGen(cinfo, VGA_PEL_MSK);\n\tudelay(200);\n\tRGen(cinfo, VGA_PEL_MSK);\n\tudelay(200);\n\n\tWGen(cinfo, VGA_PEL_MSK, val);\n\tudelay(200);\n\n\tif (cinfo->btype == BT_PICASSO) {\n\t\t \n\t\tRGen(cinfo, VGA_PEL_IW);\n\t\tudelay(200);\n\n\t\t \n\t\t \n\t\tWGen(cinfo, VGA_PEL_MSK, 0xff);\n\t\tudelay(200);\n\t}\n}\n\n \nstatic void WSFR(struct cirrusfb_info *cinfo, unsigned char val)\n{\n#ifdef CONFIG_ZORRO\n\tassert(cinfo->regbase != NULL);\n\tcinfo->SFR = val;\n\tz_writeb(val, cinfo->regbase + 0x8000);\n#endif\n}\n\n \nstatic void WSFR2(struct cirrusfb_info *cinfo, unsigned char val)\n{\n#ifdef CONFIG_ZORRO\n\t \n\t \n\tassert(cinfo->regbase != NULL);\n\tcinfo->SFR = val;\n\tz_writeb(val, cinfo->regbase + 0x9000);\n#endif\n}\n\n \nstatic void WClut(struct cirrusfb_info *cinfo, unsigned char regnum, unsigned char red,\n\t    unsigned char green, unsigned char blue)\n{\n\tunsigned int data = VGA_PEL_D;\n\n\t \n\tvga_w(cinfo->regbase, VGA_PEL_IW, regnum);\n\n\tif (cinfo->btype == BT_PICASSO || cinfo->btype == BT_PICASSO4 ||\n\t    cinfo->btype == BT_ALPINE || cinfo->btype == BT_GD5480 ||\n\t    cinfo->btype == BT_SD64 || is_laguna(cinfo)) {\n\t\t \n\t\tif (cinfo->btype == BT_PICASSO)\n\t\t\tdata += 0xfff;\n\t\tvga_w(cinfo->regbase, data, red);\n\t\tvga_w(cinfo->regbase, data, green);\n\t\tvga_w(cinfo->regbase, data, blue);\n\t} else {\n\t\tvga_w(cinfo->regbase, data, blue);\n\t\tvga_w(cinfo->regbase, data, green);\n\t\tvga_w(cinfo->regbase, data, red);\n\t}\n}\n\n#if 0\n \nstatic void RClut(struct cirrusfb_info *cinfo, unsigned char regnum, unsigned char *red,\n\t    unsigned char *green, unsigned char *blue)\n{\n\tunsigned int data = VGA_PEL_D;\n\n\tvga_w(cinfo->regbase, VGA_PEL_IR, regnum);\n\n\tif (cinfo->btype == BT_PICASSO || cinfo->btype == BT_PICASSO4 ||\n\t    cinfo->btype == BT_ALPINE || cinfo->btype == BT_GD5480) {\n\t\tif (cinfo->btype == BT_PICASSO)\n\t\t\tdata += 0xfff;\n\t\t*red = vga_r(cinfo->regbase, data);\n\t\t*green = vga_r(cinfo->regbase, data);\n\t\t*blue = vga_r(cinfo->regbase, data);\n\t} else {\n\t\t*blue = vga_r(cinfo->regbase, data);\n\t\t*green = vga_r(cinfo->regbase, data);\n\t\t*red = vga_r(cinfo->regbase, data);\n\t}\n}\n#endif\n\n \n\n \nstatic void cirrusfb_WaitBLT(u8 __iomem *regbase)\n{\n\twhile (vga_rgfx(regbase, CL_GR31) & 0x08)\n\t\tcpu_relax();\n}\n\n \n\nstatic void cirrusfb_set_blitter(u8 __iomem *regbase,\n\t\t\t    u_short nwidth, u_short nheight,\n\t\t\t    u_long nsrc, u_long ndest,\n\t\t\t    u_short bltmode, u_short line_length)\n\n{\n\t \n\t \n\tvga_wgfx(regbase, CL_GR24, line_length & 0xff);\n\t \n\tvga_wgfx(regbase, CL_GR25, line_length >> 8);\n\t \n\tvga_wgfx(regbase, CL_GR26, line_length & 0xff);\n\t \n\tvga_wgfx(regbase, CL_GR27, line_length >> 8);\n\n\t \n\t \n\tvga_wgfx(regbase, CL_GR20, nwidth & 0xff);\n\t \n\tvga_wgfx(regbase, CL_GR21, nwidth >> 8);\n\n\t \n\t \n\tvga_wgfx(regbase, CL_GR22, nheight & 0xff);\n\t \n\tvga_wgfx(regbase, CL_GR23, nheight >> 8);\n\n\t \n\t \n\tvga_wgfx(regbase, CL_GR28, (u_char) (ndest & 0xff));\n\t \n\tvga_wgfx(regbase, CL_GR29, (u_char) (ndest >> 8));\n\t \n\tvga_wgfx(regbase, CL_GR2A, (u_char) (ndest >> 16));\n\n\t \n\t \n\tvga_wgfx(regbase, CL_GR2C, (u_char) (nsrc & 0xff));\n\t \n\tvga_wgfx(regbase, CL_GR2D, (u_char) (nsrc >> 8));\n\t \n\tvga_wgfx(regbase, CL_GR2E, (u_char) (nsrc >> 16));\n\n\t \n\tvga_wgfx(regbase, CL_GR30, bltmode);\t \n\n\t \n\tvga_wgfx(regbase, CL_GR32, 0x0d);\t \n\n\t \n\tvga_wgfx(regbase, CL_GR31, 0x02);\t \n}\n\n \n\nstatic void cirrusfb_BitBLT(u8 __iomem *regbase, int bits_per_pixel,\n\t\t\t    u_short curx, u_short cury,\n\t\t\t    u_short destx, u_short desty,\n\t\t\t    u_short width, u_short height,\n\t\t\t    u_short line_length)\n{\n\tu_short nwidth = width - 1;\n\tu_short nheight = height - 1;\n\tu_long nsrc, ndest;\n\tu_char bltmode;\n\n\tbltmode = 0x00;\n\t \n\tif (cury <= desty) {\n\t\tif (cury == desty) {\n\t\t\t \n\t\t\tif (curx < destx)\n\t\t\t\tbltmode |= 0x01;\n\t\t} else\n\t\t\tbltmode |= 0x01;\n\t}\n\t \n\tnsrc = (cury * line_length) + curx;\n\tndest = (desty * line_length) + destx;\n\tif (bltmode) {\n\t\t \n\t\tnsrc += nheight * line_length + nwidth;\n\t\tndest += nheight * line_length + nwidth;\n\t}\n\n\tcirrusfb_WaitBLT(regbase);\n\n\tcirrusfb_set_blitter(regbase, nwidth, nheight,\n\t\t\t    nsrc, ndest, bltmode, line_length);\n}\n\n \n\nstatic void cirrusfb_RectFill(u8 __iomem *regbase, int bits_per_pixel,\n\t\t     u_short x, u_short y, u_short width, u_short height,\n\t\t     u32 fg_color, u32 bg_color, u_short line_length,\n\t\t     u_char blitmode)\n{\n\tu_long ndest = (y * line_length) + x;\n\tu_char op;\n\n\tcirrusfb_WaitBLT(regbase);\n\n\t \n\t \n\tvga_wgfx(regbase, VGA_GFX_SR_VALUE, bg_color);\n\tvga_wgfx(regbase, VGA_GFX_SR_ENABLE, fg_color);\n\n\top = 0x80;\n\tif (bits_per_pixel >= 16) {\n\t\tvga_wgfx(regbase, CL_GR10, bg_color >> 8);\n\t\tvga_wgfx(regbase, CL_GR11, fg_color >> 8);\n\t\top = 0x90;\n\t}\n\tif (bits_per_pixel >= 24) {\n\t\tvga_wgfx(regbase, CL_GR12, bg_color >> 16);\n\t\tvga_wgfx(regbase, CL_GR13, fg_color >> 16);\n\t\top = 0xa0;\n\t}\n\tif (bits_per_pixel == 32) {\n\t\tvga_wgfx(regbase, CL_GR14, bg_color >> 24);\n\t\tvga_wgfx(regbase, CL_GR15, fg_color >> 24);\n\t\top = 0xb0;\n\t}\n\tcirrusfb_set_blitter(regbase, width - 1, height - 1,\n\t\t\t    0, ndest, op | blitmode, line_length);\n}\n\n \nstatic void bestclock(long freq, int *nom, int *den, int *div)\n{\n\tint n, d;\n\tlong h, diff;\n\n\tassert(nom != NULL);\n\tassert(den != NULL);\n\tassert(div != NULL);\n\n\t*nom = 0;\n\t*den = 0;\n\t*div = 0;\n\n\tif (freq < 8000)\n\t\tfreq = 8000;\n\n\tdiff = freq;\n\n\tfor (n = 32; n < 128; n++) {\n\t\tint s = 0;\n\n\t\td = (14318 * n) / freq;\n\t\tif ((d >= 7) && (d <= 63)) {\n\t\t\tint temp = d;\n\n\t\t\tif (temp > 31) {\n\t\t\t\ts = 1;\n\t\t\t\ttemp >>= 1;\n\t\t\t}\n\t\t\th = ((14318 * n) / temp) >> s;\n\t\t\th = h > freq ? h - freq : freq - h;\n\t\t\tif (h < diff) {\n\t\t\t\tdiff = h;\n\t\t\t\t*nom = n;\n\t\t\t\t*den = temp;\n\t\t\t\t*div = s;\n\t\t\t}\n\t\t}\n\t\td++;\n\t\tif ((d >= 7) && (d <= 63)) {\n\t\t\tif (d > 31) {\n\t\t\t\ts = 1;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\th = ((14318 * n) / d) >> s;\n\t\t\th = h > freq ? h - freq : freq - h;\n\t\t\tif (h < diff) {\n\t\t\t\tdiff = h;\n\t\t\t\t*nom = n;\n\t\t\t\t*den = d;\n\t\t\t\t*div = s;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n\n#ifdef CIRRUSFB_DEBUG\n\n \n\nstatic void cirrusfb_dbg_print_regs(struct fb_info *info,\n\t\t\t\t    caddr_t regbase,\n\t\t\t\t    enum cirrusfb_dbg_reg_class reg_class, ...)\n{\n\tva_list list;\n\tunsigned char val = 0;\n\tunsigned reg;\n\tchar *name;\n\n\tva_start(list, reg_class);\n\n\tname = va_arg(list, char *);\n\twhile (name != NULL) {\n\t\treg = va_arg(list, int);\n\n\t\tswitch (reg_class) {\n\t\tcase CRT:\n\t\t\tval = vga_rcrt(regbase, (unsigned char) reg);\n\t\t\tbreak;\n\t\tcase SEQ:\n\t\t\tval = vga_rseq(regbase, (unsigned char) reg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tassert(false);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(info->device, \"%8s = 0x%02X\\n\", name, val);\n\n\t\tname = va_arg(list, char *);\n\t}\n\n\tva_end(list);\n}\n\n \n\nstatic void cirrusfb_dbg_reg_dump(struct fb_info *info, caddr_t regbase)\n{\n\tdev_dbg(info->device, \"VGA CRTC register dump:\\n\");\n\n\tcirrusfb_dbg_print_regs(info, regbase, CRT,\n\t\t\t   \"CR00\", 0x00,\n\t\t\t   \"CR01\", 0x01,\n\t\t\t   \"CR02\", 0x02,\n\t\t\t   \"CR03\", 0x03,\n\t\t\t   \"CR04\", 0x04,\n\t\t\t   \"CR05\", 0x05,\n\t\t\t   \"CR06\", 0x06,\n\t\t\t   \"CR07\", 0x07,\n\t\t\t   \"CR08\", 0x08,\n\t\t\t   \"CR09\", 0x09,\n\t\t\t   \"CR0A\", 0x0A,\n\t\t\t   \"CR0B\", 0x0B,\n\t\t\t   \"CR0C\", 0x0C,\n\t\t\t   \"CR0D\", 0x0D,\n\t\t\t   \"CR0E\", 0x0E,\n\t\t\t   \"CR0F\", 0x0F,\n\t\t\t   \"CR10\", 0x10,\n\t\t\t   \"CR11\", 0x11,\n\t\t\t   \"CR12\", 0x12,\n\t\t\t   \"CR13\", 0x13,\n\t\t\t   \"CR14\", 0x14,\n\t\t\t   \"CR15\", 0x15,\n\t\t\t   \"CR16\", 0x16,\n\t\t\t   \"CR17\", 0x17,\n\t\t\t   \"CR18\", 0x18,\n\t\t\t   \"CR22\", 0x22,\n\t\t\t   \"CR24\", 0x24,\n\t\t\t   \"CR26\", 0x26,\n\t\t\t   \"CR2D\", 0x2D,\n\t\t\t   \"CR2E\", 0x2E,\n\t\t\t   \"CR2F\", 0x2F,\n\t\t\t   \"CR30\", 0x30,\n\t\t\t   \"CR31\", 0x31,\n\t\t\t   \"CR32\", 0x32,\n\t\t\t   \"CR33\", 0x33,\n\t\t\t   \"CR34\", 0x34,\n\t\t\t   \"CR35\", 0x35,\n\t\t\t   \"CR36\", 0x36,\n\t\t\t   \"CR37\", 0x37,\n\t\t\t   \"CR38\", 0x38,\n\t\t\t   \"CR39\", 0x39,\n\t\t\t   \"CR3A\", 0x3A,\n\t\t\t   \"CR3B\", 0x3B,\n\t\t\t   \"CR3C\", 0x3C,\n\t\t\t   \"CR3D\", 0x3D,\n\t\t\t   \"CR3E\", 0x3E,\n\t\t\t   \"CR3F\", 0x3F,\n\t\t\t   NULL);\n\n\tdev_dbg(info->device, \"\\n\");\n\n\tdev_dbg(info->device, \"VGA SEQ register dump:\\n\");\n\n\tcirrusfb_dbg_print_regs(info, regbase, SEQ,\n\t\t\t   \"SR00\", 0x00,\n\t\t\t   \"SR01\", 0x01,\n\t\t\t   \"SR02\", 0x02,\n\t\t\t   \"SR03\", 0x03,\n\t\t\t   \"SR04\", 0x04,\n\t\t\t   \"SR08\", 0x08,\n\t\t\t   \"SR09\", 0x09,\n\t\t\t   \"SR0A\", 0x0A,\n\t\t\t   \"SR0B\", 0x0B,\n\t\t\t   \"SR0D\", 0x0D,\n\t\t\t   \"SR10\", 0x10,\n\t\t\t   \"SR11\", 0x11,\n\t\t\t   \"SR12\", 0x12,\n\t\t\t   \"SR13\", 0x13,\n\t\t\t   \"SR14\", 0x14,\n\t\t\t   \"SR15\", 0x15,\n\t\t\t   \"SR16\", 0x16,\n\t\t\t   \"SR17\", 0x17,\n\t\t\t   \"SR18\", 0x18,\n\t\t\t   \"SR19\", 0x19,\n\t\t\t   \"SR1A\", 0x1A,\n\t\t\t   \"SR1B\", 0x1B,\n\t\t\t   \"SR1C\", 0x1C,\n\t\t\t   \"SR1D\", 0x1D,\n\t\t\t   \"SR1E\", 0x1E,\n\t\t\t   \"SR1F\", 0x1F,\n\t\t\t   NULL);\n\n\tdev_dbg(info->device, \"\\n\");\n}\n\n#endif\t\t\t\t \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}