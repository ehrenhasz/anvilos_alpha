{
  "module_name": "ps3fb.c",
  "hash_id": "42241a3b2a062c0981b8301fb1bc064f9941277747c5e7f9aa25fbda31afcf8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/ps3fb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/console.h>\n#include <linux/ioctl.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fb.h>\n#include <linux/fbcon.h>\n#include <linux/init.h>\n\n#include <asm/cell-regs.h>\n#include <asm/lv1call.h>\n#include <asm/ps3av.h>\n#include <asm/ps3fb.h>\n#include <asm/ps3.h>\n#include <asm/ps3gpu.h>\n\n\n#define DEVICE_NAME\t\t\"ps3fb\"\n\n#define GPU_CMD_BUF_SIZE\t\t\t(2 * 1024 * 1024)\n#define GPU_FB_START\t\t\t\t(64 * 1024)\n#define GPU_IOIF\t\t\t\t(0x0d000000UL)\n#define GPU_ALIGN_UP(x)\t\t\t\tALIGN((x), 64)\n#define GPU_MAX_LINE_LENGTH\t\t\t(65536 - 64)\n\n#define GPU_INTR_STATUS_VSYNC_0\t\t\t0\t \n#define GPU_INTR_STATUS_VSYNC_1\t\t\t1\t \n#define GPU_INTR_STATUS_FLIP_0\t\t\t3\t \n#define GPU_INTR_STATUS_FLIP_1\t\t\t4\t \n#define GPU_INTR_STATUS_QUEUE_0\t\t\t5\t \n#define GPU_INTR_STATUS_QUEUE_1\t\t\t6\t \n\n#define GPU_DRIVER_INFO_VERSION\t\t\t0x211\n\n \nstruct display_head {\n\tu64 be_time_stamp;\n\tu32 status;\n\tu32 offset;\n\tu32 res1;\n\tu32 res2;\n\tu32 field;\n\tu32 reserved1;\n\n\tu64 res3;\n\tu32 raster;\n\n\tu64 vblank_count;\n\tu32 field_vsync;\n\tu32 reserved2;\n};\n\nstruct gpu_irq {\n\tu32 irq_outlet;\n\tu32 status;\n\tu32 mask;\n\tu32 video_cause;\n\tu32 graph_cause;\n\tu32 user_cause;\n\n\tu32 res1;\n\tu64 res2;\n\n\tu32 reserved[4];\n};\n\nstruct gpu_driver_info {\n\tu32 version_driver;\n\tu32 version_gpu;\n\tu32 memory_size;\n\tu32 hardware_channel;\n\n\tu32 nvcore_frequency;\n\tu32 memory_frequency;\n\n\tu32 reserved[1063];\n\tstruct display_head display_head[8];\n\tstruct gpu_irq irq;\n};\n\nstruct ps3fb_priv {\n\tunsigned int irq_no;\n\n\tu64 context_handle, memory_handle;\n\tstruct gpu_driver_info *dinfo;\n\n\tu64 vblank_count;\t \n\twait_queue_head_t wait_vsync;\n\n\tatomic_t ext_flip;\t \n\tatomic_t f_count;\t \n\tint is_blanked;\n\tint is_kicked;\n\tstruct task_struct *task;\n};\nstatic struct ps3fb_priv ps3fb;\n\nstruct ps3fb_par {\n\tu32 pseudo_palette[16];\n\tint mode_id, new_mode_id;\n\tunsigned int num_frames;\t \n\tunsigned int width;\n\tunsigned int height;\n\tunsigned int ddr_line_length;\n\tunsigned int ddr_frame_size;\n\tunsigned int xdr_frame_size;\n\tunsigned int full_offset;\t \n\tunsigned int fb_offset;\t\t \n\tunsigned int pan_offset;\n};\n\n\n#define FIRST_NATIVE_MODE_INDEX\t10\n\nstatic const struct fb_videomode ps3fb_modedb[] = {\n     \n    {\n         \n        \"480i\", 60, 576, 384, 74074, 130, 89, 78, 57, 63, 6,\n        FB_SYNC_BROADCAST, FB_VMODE_INTERLACED\n    },    {\n         \n        \"480p\", 60, 576, 384, 37037, 130, 89, 78, 57, 63, 6,\n        FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED\n    },    {\n         \n        \"720p\", 60, 1124, 644, 13481, 298, 148, 57, 44, 80, 5,\n        FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED\n    },    {\n         \n        \"1080i\", 60, 1688, 964, 13481, 264, 160, 94, 62, 88, 5,\n        FB_SYNC_BROADCAST, FB_VMODE_INTERLACED\n    },    {\n         \n        \"1080p\", 60, 1688, 964, 6741, 264, 160, 94, 62, 88, 5,\n        FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED\n    },\n\n     \n    {\n         \n        \"576i\", 50, 576, 460, 74074, 142, 83, 97, 63, 63, 5,\n        FB_SYNC_BROADCAST, FB_VMODE_INTERLACED\n    },    {\n         \n        \"576p\", 50, 576, 460, 37037, 142, 83, 97, 63, 63, 5,\n        FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED\n    },    {\n         \n        \"720p\", 50, 1124, 644, 13468, 298, 478, 57, 44, 80, 5,\n        FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED\n    },    {\n         \n        \"1080i\", 50, 1688, 964, 13468, 264, 600, 94, 62, 88, 5,\n        FB_SYNC_BROADCAST, FB_VMODE_INTERLACED\n    },    {\n         \n        \"1080p\", 50, 1688, 964, 6734, 264, 600, 94, 62, 88, 5,\n        FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED\n    },\n\n    [FIRST_NATIVE_MODE_INDEX] =\n     \n    {\n\t \n\t\"480if\", 60, 720, 480, 74074, 58, 17, 30, 9, 63, 6,\n\tFB_SYNC_BROADCAST, FB_VMODE_INTERLACED\n    }, {\n\t \n\t\"480pf\", 60, 720, 480, 37037, 58, 17, 30, 9, 63, 6,\n\tFB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED\n    }, {\n\t \n\t\"720pf\", 60, 1280, 720, 13481, 220, 70, 19, 6, 80, 5,\n\tFB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED\n    }, {\n\t \n\t\"1080if\", 60, 1920, 1080, 13481, 148, 44, 36, 4, 88, 5,\n\tFB_SYNC_BROADCAST, FB_VMODE_INTERLACED\n    }, {\n\t \n\t\"1080pf\", 60, 1920, 1080, 6741, 148, 44, 36, 4, 88, 5,\n\tFB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED\n    },\n\n     \n    {\n\t \n\t\"576if\", 50, 720, 576, 74074, 70, 11, 39, 5, 63, 5,\n\tFB_SYNC_BROADCAST, FB_VMODE_INTERLACED\n    }, {\n\t \n\t\"576pf\", 50, 720, 576, 37037, 70, 11, 39, 5, 63, 5,\n\tFB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED\n    }, {\n\t \n\t\"720pf\", 50, 1280, 720, 13468, 220, 400, 19, 6, 80, 5,\n\tFB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED\n    }, {\n\t \n\t\"1080if\", 50, 1920, 1080, 13468, 148, 484, 36, 4, 88, 5,\n\tFB_SYNC_BROADCAST, FB_VMODE_INTERLACED\n    }, {\n\t \n\t\"1080pf\", 50, 1920, 1080, 6734, 148, 484, 36, 4, 88, 5,\n\tFB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED\n    },\n\n     \n    {\n\t \n\t\"wxga\", 60, 1280, 768, 12924, 160, 24, 29, 3, 136, 6,\n\t0, FB_VMODE_NONINTERLACED,\n\tFB_MODE_IS_VESA\n    }, {\n\t \n\t\"sxga\", 60, 1280, 1024, 9259, 248, 48, 38, 1, 112, 3,\n\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED,\n\tFB_MODE_IS_VESA\n    }, {\n\t \n\t\"wuxga\", 60, 1920, 1200, 6494, 80, 48, 26, 3, 32, 6,\n\tFB_SYNC_HOR_HIGH_ACT, FB_VMODE_NONINTERLACED,\n\tFB_MODE_IS_VESA\n    }\n};\n\n\n#define HEAD_A\n#define HEAD_B\n\n#define BPP\t\t4\t\t\t \n\n\nstatic int ps3fb_mode;\nmodule_param(ps3fb_mode, int, 0);\n\nstatic char *mode_option;\n\nstatic int ps3fb_cmp_mode(const struct fb_videomode *vmode,\n\t\t\t  const struct fb_var_screeninfo *var)\n{\n\tlong xres, yres, left_margin, right_margin, upper_margin, lower_margin;\n\tlong dx, dy;\n\n\t \n\tif (var->xres > vmode->xres || var->yres > vmode->yres ||\n\t    var->pixclock > vmode->pixclock ||\n\t    var->hsync_len > vmode->hsync_len ||\n\t    var->vsync_len > vmode->vsync_len)\n\t\treturn -1;\n\n\t \n\tif ((var->vmode & FB_VMODE_MASK) != vmode->vmode)\n\t\treturn -1;\n\n\t \n\txres = max(var->xres, 1U);\n\tyres = max(var->yres, 1U);\n\n\t \n\tleft_margin = max(var->left_margin, vmode->left_margin);\n\tright_margin = max(var->right_margin, vmode->right_margin);\n\tupper_margin = max(var->upper_margin, vmode->upper_margin);\n\tlower_margin = max(var->lower_margin, vmode->lower_margin);\n\n\t \n\tdx = ((long)vmode->left_margin + (long)vmode->xres +\n\t      (long)vmode->right_margin) -\n\t     (left_margin + xres + right_margin);\n\tif (dx < 0)\n\t\treturn -1;\n\n\tdy = ((long)vmode->upper_margin + (long)vmode->yres +\n\t      (long)vmode->lower_margin) -\n\t     (upper_margin + yres + lower_margin);\n\tif (dy < 0)\n\t\treturn -1;\n\n\t \n\tif (!dx && !dy)\n\t\treturn 0;\n\n\t \n\treturn (vmode->xres - xres) * (vmode->yres - yres);\n}\n\nstatic const struct fb_videomode *ps3fb_native_vmode(enum ps3av_mode_num id)\n{\n\treturn &ps3fb_modedb[FIRST_NATIVE_MODE_INDEX + id - 1];\n}\n\nstatic const struct fb_videomode *ps3fb_vmode(int id)\n{\n\tu32 mode = id & PS3AV_MODE_MASK;\n\n\tif (mode < PS3AV_MODE_480I || mode > PS3AV_MODE_WUXGA)\n\t\treturn NULL;\n\n\tif (mode <= PS3AV_MODE_1080P50 && !(id & PS3AV_MODE_FULL)) {\n\t\t \n\t\treturn &ps3fb_modedb[mode - 1];\n\t}\n\n\treturn ps3fb_native_vmode(mode);\n}\n\nstatic unsigned int ps3fb_find_mode(struct fb_var_screeninfo *var,\n\t\t\t\t    u32 *ddr_line_length, u32 *xdr_line_length)\n{\n\tunsigned int id, best_id;\n\tint diff, best_diff;\n\tconst struct fb_videomode *vmode;\n\tlong gap;\n\n\tbest_id = 0;\n\tbest_diff = INT_MAX;\n\tpr_debug(\"%s: wanted %u [%u] %u x %u [%u] %u\\n\", __func__,\n\t\t var->left_margin, var->xres, var->right_margin,\n\t\t var->upper_margin, var->yres, var->lower_margin);\n\tfor (id = PS3AV_MODE_480I; id <= PS3AV_MODE_WUXGA; id++) {\n\t\tvmode = ps3fb_native_vmode(id);\n\t\tdiff = ps3fb_cmp_mode(vmode, var);\n\t\tpr_debug(\"%s: mode %u: %u [%u] %u x %u [%u] %u: diff = %d\\n\",\n\t\t\t __func__, id, vmode->left_margin, vmode->xres,\n\t\t\t vmode->right_margin, vmode->upper_margin,\n\t\t\t vmode->yres, vmode->lower_margin, diff);\n\t\tif (diff < 0)\n\t\t\tcontinue;\n\t\tif (diff < best_diff) {\n\t\t\tbest_id = id;\n\t\t\tif (!diff)\n\t\t\t\tbreak;\n\t\t\tbest_diff = diff;\n\t\t}\n\t}\n\n\tif (!best_id) {\n\t\tpr_debug(\"%s: no suitable mode found\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tid = best_id;\n\tvmode = ps3fb_native_vmode(id);\n\n\t*ddr_line_length = vmode->xres * BPP;\n\n\t \n\tif (!var->xres)\n\t\tvar->xres = 1;\n\tif (!var->yres)\n\t\tvar->yres = 1;\n\n\t \n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres_virtual = var->yres;\n\n\t \n\tif (var->left_margin < vmode->left_margin)\n\t\tvar->left_margin = vmode->left_margin;\n\tif (var->right_margin < vmode->right_margin)\n\t\tvar->right_margin = vmode->right_margin;\n\tif (var->upper_margin < vmode->upper_margin)\n\t\tvar->upper_margin = vmode->upper_margin;\n\tif (var->lower_margin < vmode->lower_margin)\n\t\tvar->lower_margin = vmode->lower_margin;\n\n\t \n\tgap = ((long)vmode->left_margin + (long)vmode->xres +\n\t       (long)vmode->right_margin) -\n\t      ((long)var->left_margin + (long)var->xres +\n\t       (long)var->right_margin);\n\tif (gap > 0) {\n\t\tvar->left_margin += gap/2;\n\t\tvar->right_margin += (gap+1)/2;\n\t\tpr_debug(\"%s: rounded up H to %u [%u] %u\\n\", __func__,\n\t\t\t var->left_margin, var->xres, var->right_margin);\n\t}\n\n\tgap = ((long)vmode->upper_margin + (long)vmode->yres +\n\t       (long)vmode->lower_margin) -\n\t      ((long)var->upper_margin + (long)var->yres +\n\t       (long)var->lower_margin);\n\tif (gap > 0) {\n\t\tvar->upper_margin += gap/2;\n\t\tvar->lower_margin += (gap+1)/2;\n\t\tpr_debug(\"%s: rounded up V to %u [%u] %u\\n\", __func__,\n\t\t\t var->upper_margin, var->yres, var->lower_margin);\n\t}\n\n\t \n\tvar->pixclock = vmode->pixclock;\n\tvar->hsync_len = vmode->hsync_len;\n\tvar->vsync_len = vmode->vsync_len;\n\tvar->sync = vmode->sync;\n\n\tif (ps3_compare_firmware_version(1, 9, 0) >= 0) {\n\t\t*xdr_line_length = GPU_ALIGN_UP(var->xres_virtual * BPP);\n\t\tif (*xdr_line_length > GPU_MAX_LINE_LENGTH)\n\t\t\t*xdr_line_length = GPU_MAX_LINE_LENGTH;\n\t} else\n\t\t*xdr_line_length = *ddr_line_length;\n\n\tif (vmode->sync & FB_SYNC_BROADCAST) {\n\t\t \n\t\tif (vmode->xres == var->xres && vmode->yres == var->yres)\n\t\t\tid |= PS3AV_MODE_FULL;\n\t}\n\n\tpr_debug(\"%s: mode %u\\n\", __func__, id);\n\treturn id;\n}\n\nstatic void ps3fb_sync_image(struct device *dev, u64 frame_offset,\n\t\t\t     u64 dst_offset, u64 src_offset, u32 width,\n\t\t\t     u32 height, u32 dst_line_length,\n\t\t\t     u32 src_line_length)\n{\n\tint status;\n\tu64 line_length;\n\n\tline_length = dst_line_length;\n\tif (src_line_length != dst_line_length)\n\t\tline_length |= (u64)src_line_length << 32;\n\n\tsrc_offset += GPU_FB_START;\n\n\tmutex_lock(&ps3_gpu_mutex);\n\tstatus = lv1_gpu_fb_blit(ps3fb.context_handle, dst_offset,\n\t\t\t\t GPU_IOIF + src_offset,\n\t\t\t\t L1GPU_FB_BLIT_WAIT_FOR_COMPLETION |\n\t\t\t\t (width << 16) | height,\n\t\t\t\t line_length);\n\tmutex_unlock(&ps3_gpu_mutex);\n\n\tif (status)\n\t\tdev_err(dev, \"%s: lv1_gpu_fb_blit failed: %d\\n\", __func__,\n\t\t\tstatus);\n#ifdef HEAD_A\n\tstatus = lv1_gpu_display_flip(ps3fb.context_handle, 0, frame_offset);\n\tif (status)\n\t\tdev_err(dev, \"%s: lv1_gpu_display_flip failed: %d\\n\", __func__,\n\t\t\tstatus);\n#endif\n#ifdef HEAD_B\n\tstatus = lv1_gpu_display_flip(ps3fb.context_handle, 1, frame_offset);\n\tif (status)\n\t\tdev_err(dev, \"%s: lv1_gpu_display_flip failed: %d\\n\", __func__,\n\t\t\tstatus);\n#endif\n}\n\nstatic int ps3fb_sync(struct fb_info *info, u32 frame)\n{\n\tstruct ps3fb_par *par = info->par;\n\tint error = 0;\n\tu64 ddr_base, xdr_base;\n\n\tif (frame > par->num_frames - 1) {\n\t\tdev_dbg(info->device, \"%s: invalid frame number (%u)\\n\",\n\t\t\t__func__, frame);\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\txdr_base = frame * par->xdr_frame_size;\n\tddr_base = frame * par->ddr_frame_size;\n\n\tps3fb_sync_image(info->device, ddr_base + par->full_offset,\n\t\t\t ddr_base + par->fb_offset, xdr_base + par->pan_offset,\n\t\t\t par->width, par->height, par->ddr_line_length,\n\t\t\t info->fix.line_length);\n\nout:\n\treturn error;\n}\n\nstatic int ps3fb_open(struct fb_info *info, int user)\n{\n\tatomic_inc(&ps3fb.f_count);\n\treturn 0;\n}\n\nstatic int ps3fb_release(struct fb_info *info, int user)\n{\n\tif (atomic_dec_and_test(&ps3fb.f_count)) {\n\t\tif (atomic_read(&ps3fb.ext_flip)) {\n\t\t\tatomic_set(&ps3fb.ext_flip, 0);\n\t\t\tif (console_trylock()) {\n\t\t\t\tps3fb_sync(info, 0);\t \n\t\t\t\tconsole_unlock();\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n     \n\nstatic int ps3fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tu32 xdr_line_length, ddr_line_length;\n\tint mode;\n\n\tmode = ps3fb_find_mode(var, &ddr_line_length, &xdr_line_length);\n\tif (!mode)\n\t\treturn -EINVAL;\n\n\t \n\tif (var->xres_virtual > xdr_line_length / BPP) {\n\t\tdev_dbg(info->device,\n\t\t\t\"Horizontal virtual screen size too large\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->xoffset + var->xres > var->xres_virtual ||\n\t    var->yoffset + var->yres > var->yres_virtual) {\n\t\tdev_dbg(info->device, \"panning out-of-range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (var->bits_per_pixel > 32 || var->grayscale ||\n\t    var->red.offset > 16 || var->green.offset > 8 ||\n\t    var->blue.offset > 0 || var->transp.offset > 24 ||\n\t    var->red.length > 8 || var->green.length > 8 ||\n\t    var->blue.length > 8 || var->transp.length > 8 ||\n\t    var->red.msb_right || var->green.msb_right ||\n\t    var->blue.msb_right || var->transp.msb_right || var->nonstd) {\n\t\tdev_dbg(info->device, \"We support ARGB8888 only\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvar->bits_per_pixel = 32;\n\tvar->red.offset = 16;\n\tvar->green.offset = 8;\n\tvar->blue.offset = 0;\n\tvar->transp.offset = 24;\n\tvar->red.length = 8;\n\tvar->green.length = 8;\n\tvar->blue.length = 8;\n\tvar->transp.length = 8;\n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.msb_right = 0;\n\tvar->transp.msb_right = 0;\n\n\t \n\tif (var->rotate) {\n\t\tdev_dbg(info->device, \"Rotation is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (var->yres_virtual * xdr_line_length > info->fix.smem_len) {\n\t\tdev_dbg(info->device, \"Not enough memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tvar->height = -1;\n\tvar->width = -1;\n\n\treturn 0;\n}\n\n     \n\nstatic int ps3fb_set_par(struct fb_info *info)\n{\n\tstruct ps3fb_par *par = info->par;\n\tunsigned int mode, ddr_line_length, xdr_line_length, lines, maxlines;\n\tunsigned int ddr_xoff, ddr_yoff, offset;\n\tconst struct fb_videomode *vmode;\n\tu64 dst;\n\n\tmode = ps3fb_find_mode(&info->var, &ddr_line_length, &xdr_line_length);\n\tif (!mode)\n\t\treturn -EINVAL;\n\n\tvmode = ps3fb_native_vmode(mode & PS3AV_MODE_MASK);\n\n\tinfo->fix.xpanstep = info->var.xres_virtual > info->var.xres ? 1 : 0;\n\tinfo->fix.ypanstep = info->var.yres_virtual > info->var.yres ? 1 : 0;\n\tinfo->fix.line_length = xdr_line_length;\n\n\tpar->ddr_line_length = ddr_line_length;\n\tpar->ddr_frame_size = vmode->yres * ddr_line_length;\n\tpar->xdr_frame_size = info->var.yres_virtual * xdr_line_length;\n\n\tpar->num_frames = info->fix.smem_len /\n\t\t\t  max(par->ddr_frame_size, par->xdr_frame_size);\n\n\t \n\tpar->new_mode_id = (par->new_mode_id & ~PS3AV_MODE_MASK) | mode;\n\n\tpar->width = info->var.xres;\n\tpar->height = info->var.yres;\n\n\t \n\tddr_xoff = info->var.left_margin - vmode->left_margin;\n\tddr_yoff = info->var.upper_margin - vmode->upper_margin;\n\toffset = ddr_yoff * ddr_line_length + ddr_xoff * BPP;\n\n\tpar->fb_offset = GPU_ALIGN_UP(offset);\n\tpar->full_offset = par->fb_offset - offset;\n\tpar->pan_offset = info->var.yoffset * xdr_line_length +\n\t\t\t  info->var.xoffset * BPP;\n\n\tif (par->new_mode_id != par->mode_id) {\n\t\tif (ps3av_set_video_mode(par->new_mode_id)) {\n\t\t\tpar->new_mode_id = par->mode_id;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpar->mode_id = par->new_mode_id;\n\t}\n\n\t \n\tmemset(info->screen_buffer, 0, info->fix.smem_len);\n\n\t \n\tlines = vmode->yres * par->num_frames;\n\tif (par->full_offset)\n\t\tlines++;\n\tmaxlines = info->fix.smem_len / ddr_line_length;\n\tfor (dst = 0; lines; dst += maxlines * ddr_line_length) {\n\t\tunsigned int l = min(lines, maxlines);\n\t\tps3fb_sync_image(info->device, 0, dst, 0, vmode->xres, l,\n\t\t\t\t ddr_line_length, ddr_line_length);\n\t\tlines -= l;\n\t}\n\n\treturn 0;\n}\n\n     \n\nstatic int ps3fb_setcolreg(unsigned int regno, unsigned int red,\n\t\t\t   unsigned int green, unsigned int blue,\n\t\t\t   unsigned int transp, struct fb_info *info)\n{\n\tif (regno >= 16)\n\t\treturn 1;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\ttransp >>= 8;\n\n\t((u32 *)info->pseudo_palette)[regno] = transp << 24 | red << 16 |\n\t\t\t\t\t       green << 8 | blue;\n\treturn 0;\n}\n\nstatic int ps3fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tstruct ps3fb_par *par = info->par;\n\n\tpar->pan_offset = var->yoffset * info->fix.line_length +\n\t\t\t  var->xoffset * BPP;\n\treturn 0;\n}\n\n     \n\nstatic int ps3fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tint r;\n\n\tr = vm_iomap_memory(vma, info->fix.smem_start, info->fix.smem_len);\n\n\tdev_dbg(info->device, \"ps3fb: mmap framebuffer P(%lx)->V(%lx)\\n\",\n\t\tinfo->fix.smem_start + (vma->vm_pgoff << PAGE_SHIFT),\n\t\tvma->vm_start);\n\n\treturn r;\n}\n\n     \n\nstatic int ps3fb_blank(int blank, struct fb_info *info)\n{\n\tint retval;\n\n\tdev_dbg(info->device, \"%s: blank:%d\\n\", __func__, blank);\n\tswitch (blank) {\n\tcase FB_BLANK_POWERDOWN:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_NORMAL:\n\t\tretval = ps3av_video_mute(1);\t \n\t\tif (!retval)\n\t\t\tps3fb.is_blanked = 1;\n\t\tbreak;\n\n\tdefault:\t\t \n\t\tretval = ps3av_video_mute(0);\t \n\t\tif (!retval)\n\t\t\tps3fb.is_blanked = 0;\n\t\tbreak;\n\t}\n\treturn retval;\n}\n\nstatic int ps3fb_get_vblank(struct fb_vblank *vblank)\n{\n\tmemset(vblank, 0, sizeof(*vblank));\n\tvblank->flags = FB_VBLANK_HAVE_VSYNC;\n\treturn 0;\n}\n\nstatic int ps3fb_wait_for_vsync(u32 crtc)\n{\n\tint ret;\n\tu64 count;\n\n\tcount = ps3fb.vblank_count;\n\tret = wait_event_interruptible_timeout(ps3fb.wait_vsync,\n\t\t\t\t\t       count != ps3fb.vblank_count,\n\t\t\t\t\t       HZ / 10);\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n\n     \n\nstatic int ps3fb_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t       unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tu32 val;\n\tint retval = -EFAULT;\n\n\tswitch (cmd) {\n\tcase FBIOGET_VBLANK:\n\t\t{\n\t\t\tstruct fb_vblank vblank;\n\t\t\tdev_dbg(info->device, \"FBIOGET_VBLANK:\\n\");\n\t\t\tretval = ps3fb_get_vblank(&vblank);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\n\t\t\tif (copy_to_user(argp, &vblank, sizeof(vblank)))\n\t\t\t\tretval = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\tcase FBIO_WAITFORVSYNC:\n\t\t{\n\t\t\tu32 crt;\n\t\t\tdev_dbg(info->device, \"FBIO_WAITFORVSYNC:\\n\");\n\t\t\tif (get_user(crt, (u32 __user *) arg))\n\t\t\t\tbreak;\n\n\t\t\tretval = ps3fb_wait_for_vsync(crt);\n\t\t\tbreak;\n\t\t}\n\n\tcase PS3FB_IOCTL_SETMODE:\n\t\t{\n\t\t\tstruct ps3fb_par *par = info->par;\n\t\t\tconst struct fb_videomode *vmode;\n\t\t\tstruct fb_var_screeninfo var;\n\n\t\t\tif (copy_from_user(&val, argp, sizeof(val)))\n\t\t\t\tbreak;\n\n\t\t\tif (!(val & PS3AV_MODE_MASK)) {\n\t\t\t\tu32 id = ps3av_get_auto_mode();\n\t\t\t\tif (id > 0)\n\t\t\t\t\tval = (val & ~PS3AV_MODE_MASK) | id;\n\t\t\t}\n\t\t\tdev_dbg(info->device, \"PS3FB_IOCTL_SETMODE:%x\\n\", val);\n\t\t\tretval = -EINVAL;\n\t\t\tvmode = ps3fb_vmode(val);\n\t\t\tif (vmode) {\n\t\t\t\tvar = info->var;\n\t\t\t\tfb_videomode_to_var(&var, vmode);\n\t\t\t\tconsole_lock();\n\t\t\t\t \n\t\t\t\tvar.activate |= FB_ACTIVATE_FORCE;\n\t\t\t\tpar->new_mode_id = val;\n\t\t\t\tretval = fb_set_var(info, &var);\n\t\t\t\tif (!retval)\n\t\t\t\t\tfbcon_update_vcs(info, var.activate & FB_ACTIVATE_ALL);\n\t\t\t\tconsole_unlock();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\tcase PS3FB_IOCTL_GETMODE:\n\t\tval = ps3av_get_mode();\n\t\tdev_dbg(info->device, \"PS3FB_IOCTL_GETMODE:%x\\n\", val);\n\t\tif (!copy_to_user(argp, &val, sizeof(val)))\n\t\t\tretval = 0;\n\t\tbreak;\n\n\tcase PS3FB_IOCTL_SCREENINFO:\n\t\t{\n\t\t\tstruct ps3fb_par *par = info->par;\n\t\t\tstruct ps3fb_ioctl_res res;\n\t\t\tdev_dbg(info->device, \"PS3FB_IOCTL_SCREENINFO:\\n\");\n\t\t\tres.xres = info->fix.line_length / BPP;\n\t\t\tres.yres = info->var.yres_virtual;\n\t\t\tres.xoff = (res.xres - info->var.xres) / 2;\n\t\t\tres.yoff = (res.yres - info->var.yres) / 2;\n\t\t\tres.num_frames = par->num_frames;\n\t\t\tif (!copy_to_user(argp, &res, sizeof(res)))\n\t\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\n\tcase PS3FB_IOCTL_ON:\n\t\tdev_dbg(info->device, \"PS3FB_IOCTL_ON:\\n\");\n\t\tatomic_inc(&ps3fb.ext_flip);\n\t\tretval = 0;\n\t\tbreak;\n\n\tcase PS3FB_IOCTL_OFF:\n\t\tdev_dbg(info->device, \"PS3FB_IOCTL_OFF:\\n\");\n\t\tatomic_dec_if_positive(&ps3fb.ext_flip);\n\t\tretval = 0;\n\t\tbreak;\n\n\tcase PS3FB_IOCTL_FSEL:\n\t\tif (copy_from_user(&val, argp, sizeof(val)))\n\t\t\tbreak;\n\n\t\tdev_dbg(info->device, \"PS3FB_IOCTL_FSEL:%d\\n\", val);\n\t\tconsole_lock();\n\t\tretval = ps3fb_sync(info, val);\n\t\tconsole_unlock();\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\treturn retval;\n}\n\nstatic int ps3fbd(void *arg)\n{\n\tstruct fb_info *info = arg;\n\n\tset_freezable();\n\twhile (!kthread_should_stop()) {\n\t\ttry_to_freeze();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (ps3fb.is_kicked) {\n\t\t\tps3fb.is_kicked = 0;\n\t\t\tconsole_lock();\n\t\t\tps3fb_sync(info, 0);\t \n\t\t\tconsole_unlock();\n\t\t}\n\t\tschedule();\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t ps3fb_vsync_interrupt(int irq, void *ptr)\n{\n\tstruct device *dev = ptr;\n\tu64 v1;\n\tint status;\n\tstruct display_head *head = &ps3fb.dinfo->display_head[1];\n\n\tstatus = lv1_gpu_context_intr(ps3fb.context_handle, &v1);\n\tif (status) {\n\t\tdev_err(dev, \"%s: lv1_gpu_context_intr failed: %d\\n\", __func__,\n\t\t\tstatus);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (v1 & (1 << GPU_INTR_STATUS_VSYNC_1)) {\n\t\t \n\t\tps3fb.vblank_count = head->vblank_count;\n\t\tif (ps3fb.task && !ps3fb.is_blanked &&\n\t\t    !atomic_read(&ps3fb.ext_flip)) {\n\t\t\tps3fb.is_kicked = 1;\n\t\t\twake_up_process(ps3fb.task);\n\t\t}\n\t\twake_up_interruptible(&ps3fb.wait_vsync);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic const struct fb_ops ps3fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= ps3fb_open,\n\t.fb_release\t= ps3fb_release,\n\t.fb_read        = fb_sys_read,\n\t.fb_write       = fb_sys_write,\n\t.fb_check_var\t= ps3fb_check_var,\n\t.fb_set_par\t= ps3fb_set_par,\n\t.fb_setcolreg\t= ps3fb_setcolreg,\n\t.fb_pan_display\t= ps3fb_pan_display,\n\t.fb_fillrect\t= sys_fillrect,\n\t.fb_copyarea\t= sys_copyarea,\n\t.fb_imageblit\t= sys_imageblit,\n\t.fb_mmap\t= ps3fb_mmap,\n\t.fb_blank\t= ps3fb_blank,\n\t.fb_ioctl\t= ps3fb_ioctl,\n\t.fb_compat_ioctl = ps3fb_ioctl\n};\n\nstatic const struct fb_fix_screeninfo ps3fb_fix = {\n\t.id =\t\tDEVICE_NAME,\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_TRUECOLOR,\n\t.accel =\tFB_ACCEL_NONE,\n};\n\nstatic int ps3fb_probe(struct ps3_system_bus_device *dev)\n{\n\tstruct fb_info *info;\n\tstruct ps3fb_par *par;\n\tint retval;\n\tu64 ddr_lpar = 0;\n\tu64 lpar_dma_control = 0;\n\tu64 lpar_driver_info = 0;\n\tu64 lpar_reports = 0;\n\tu64 lpar_reports_size = 0;\n\tu64 xdr_lpar;\n\tstruct gpu_driver_info *dinfo;\n\tvoid *fb_start;\n\tint status;\n\tstruct task_struct *task;\n\tunsigned long max_ps3fb_size;\n\n\tif (ps3fb_videomemory.size < GPU_CMD_BUF_SIZE) {\n\t\tdev_err(&dev->core, \"%s: Not enough video memory\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tretval = ps3_open_hv_device(dev);\n\tif (retval) {\n\t\tdev_err(&dev->core, \"%s: ps3_open_hv_device failed\\n\",\n\t\t\t__func__);\n\t\tgoto err;\n\t}\n\n\tif (!ps3fb_mode)\n\t\tps3fb_mode = ps3av_get_mode();\n\tdev_dbg(&dev->core, \"ps3fb_mode: %d\\n\", ps3fb_mode);\n\n\tatomic_set(&ps3fb.f_count, -1);\t \n\tatomic_set(&ps3fb.ext_flip, 0);\t \n\tinit_waitqueue_head(&ps3fb.wait_vsync);\n\n#ifdef HEAD_A\n\tstatus = lv1_gpu_display_sync(0x0, 0, L1GPU_DISPLAY_SYNC_VSYNC);\n\tif (status) {\n\t\tdev_err(&dev->core, \"%s: lv1_gpu_display_sync failed: %d\\n\",\n\t\t\t__func__, status);\n\t\tretval = -ENODEV;\n\t\tgoto err_close_device;\n\t}\n#endif\n#ifdef HEAD_B\n\tstatus = lv1_gpu_display_sync(0x0, 1, L1GPU_DISPLAY_SYNC_VSYNC);\n\tif (status) {\n\t\tdev_err(&dev->core, \"%s: lv1_gpu_display_sync failed: %d\\n\",\n\t\t\t__func__, status);\n\t\tretval = -ENODEV;\n\t\tgoto err_close_device;\n\t}\n#endif\n\n\tmax_ps3fb_size = ALIGN(GPU_IOIF, 256*1024*1024) - GPU_IOIF;\n\tif (ps3fb_videomemory.size > max_ps3fb_size) {\n\t\tdev_info(&dev->core, \"Limiting ps3fb mem size to %lu bytes\\n\",\n\t\t\t max_ps3fb_size);\n\t\tps3fb_videomemory.size = max_ps3fb_size;\n\t}\n\n\t \n\tstatus = lv1_gpu_memory_allocate(ps3fb_videomemory.size, 0, 0, 0, 0,\n\t\t\t\t\t &ps3fb.memory_handle, &ddr_lpar);\n\tif (status) {\n\t\tdev_err(&dev->core, \"%s: lv1_gpu_memory_allocate failed: %d\\n\",\n\t\t\t__func__, status);\n\t\tretval = -ENOMEM;\n\t\tgoto err_close_device;\n\t}\n\tdev_dbg(&dev->core, \"ddr:lpar:0x%llx\\n\", ddr_lpar);\n\n\tstatus = lv1_gpu_context_allocate(ps3fb.memory_handle, 0,\n\t\t\t\t\t  &ps3fb.context_handle,\n\t\t\t\t\t  &lpar_dma_control, &lpar_driver_info,\n\t\t\t\t\t  &lpar_reports, &lpar_reports_size);\n\tif (status) {\n\t\tdev_err(&dev->core,\n\t\t\t\"%s: lv1_gpu_context_allocate failed: %d\\n\", __func__,\n\t\t\tstatus);\n\t\tretval = -ENOMEM;\n\t\tgoto err_gpu_memory_free;\n\t}\n\n\t \n\tdinfo = (void __force *)ioremap(lpar_driver_info, 128 * 1024);\n\tif (!dinfo) {\n\t\tdev_err(&dev->core, \"%s: ioremap failed\\n\", __func__);\n\t\tretval = -ENOMEM;\n\t\tgoto err_gpu_context_free;\n\t}\n\n\tps3fb.dinfo = dinfo;\n\tdev_dbg(&dev->core, \"version_driver:%x\\n\", dinfo->version_driver);\n\tdev_dbg(&dev->core, \"irq outlet:%x\\n\", dinfo->irq.irq_outlet);\n\tdev_dbg(&dev->core, \"version_gpu: %x memory_size: %x ch: %x \"\n\t\t\"core_freq: %d mem_freq:%d\\n\", dinfo->version_gpu,\n\t\tdinfo->memory_size, dinfo->hardware_channel,\n\t\tdinfo->nvcore_frequency/1000000,\n\t\tdinfo->memory_frequency/1000000);\n\n\tif (dinfo->version_driver != GPU_DRIVER_INFO_VERSION) {\n\t\tdev_err(&dev->core, \"%s: version_driver err:%x\\n\", __func__,\n\t\t\tdinfo->version_driver);\n\t\tretval = -EINVAL;\n\t\tgoto err_iounmap_dinfo;\n\t}\n\n\tretval = ps3_irq_plug_setup(PS3_BINDING_CPU_ANY, dinfo->irq.irq_outlet,\n\t\t\t\t    &ps3fb.irq_no);\n\tif (retval) {\n\t\tdev_err(&dev->core, \"%s: ps3_alloc_irq failed %d\\n\", __func__,\n\t\t\tretval);\n\t\tgoto err_iounmap_dinfo;\n\t}\n\n\tretval = request_irq(ps3fb.irq_no, ps3fb_vsync_interrupt,\n\t\t\t     0, DEVICE_NAME, &dev->core);\n\tif (retval) {\n\t\tdev_err(&dev->core, \"%s: request_irq failed %d\\n\", __func__,\n\t\t\tretval);\n\t\tgoto err_destroy_plug;\n\t}\n\n\tdinfo->irq.mask = (1 << GPU_INTR_STATUS_VSYNC_1) |\n\t\t\t  (1 << GPU_INTR_STATUS_FLIP_1);\n\n\t \n\tmemset(ps3fb_videomemory.address, 0, ps3fb_videomemory.size);\n\n\txdr_lpar = ps3_mm_phys_to_lpar(__pa(ps3fb_videomemory.address));\n\n\tstatus = lv1_gpu_context_iomap(ps3fb.context_handle, GPU_IOIF,\n\t\t\t\t       xdr_lpar, ps3fb_videomemory.size,\n\t\t\t\t       CBE_IOPTE_PP_W | CBE_IOPTE_PP_R |\n\t\t\t\t       CBE_IOPTE_M);\n\tif (status) {\n\t\tdev_err(&dev->core, \"%s: lv1_gpu_context_iomap failed: %d\\n\",\n\t\t\t__func__, status);\n\t\tretval =  -ENXIO;\n\t\tgoto err_free_irq;\n\t}\n\n\tdev_dbg(&dev->core, \"video:%p ioif:%lx lpar:%llx size:%lx\\n\",\n\t\tps3fb_videomemory.address, GPU_IOIF, xdr_lpar,\n\t\tps3fb_videomemory.size);\n\n\tstatus = lv1_gpu_fb_setup(ps3fb.context_handle, xdr_lpar,\n\t\t\t\t  GPU_CMD_BUF_SIZE, GPU_IOIF);\n\tif (status) {\n\t\tdev_err(&dev->core, \"%s: lv1_gpu_fb_setup failed: %d\\n\",\n\t\t\t__func__, status);\n\t\tretval = -ENXIO;\n\t\tgoto err_context_unmap;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct ps3fb_par), &dev->core);\n\tif (!info) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_context_fb_close;\n\t}\n\n\tpar = info->par;\n\tpar->mode_id = ~ps3fb_mode;\t \n\tpar->new_mode_id = ps3fb_mode;\n\tpar->num_frames = 1;\n\n\tinfo->fbops = &ps3fb_ops;\n\tinfo->fix = ps3fb_fix;\n\n\t \n\tfb_start = ps3fb_videomemory.address + GPU_FB_START;\n\tinfo->screen_buffer = fb_start;\n\tinfo->fix.smem_start = __pa(fb_start);\n\tinfo->fix.smem_len = ps3fb_videomemory.size - GPU_FB_START;\n\n\tinfo->pseudo_palette = par->pseudo_palette;\n\tinfo->flags = FBINFO_READS_FAST |\n\t\t      FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;\n\n\tretval = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (retval < 0)\n\t\tgoto err_framebuffer_release;\n\n\tif (!fb_find_mode(&info->var, info, mode_option, ps3fb_modedb,\n\t\t\t  ARRAY_SIZE(ps3fb_modedb),\n\t\t\t  ps3fb_vmode(par->new_mode_id), 32)) {\n\t\tretval = -EINVAL;\n\t\tgoto err_fb_dealloc;\n\t}\n\n\tfb_videomode_to_modelist(ps3fb_modedb, ARRAY_SIZE(ps3fb_modedb),\n\t\t\t\t &info->modelist);\n\n\tretval = register_framebuffer(info);\n\tif (retval < 0)\n\t\tgoto err_fb_dealloc;\n\n\tps3_system_bus_set_drvdata(dev, info);\n\n\tfb_info(info, \"using %u KiB of video memory\\n\", info->fix.smem_len >> 10);\n\n\ttask = kthread_run(ps3fbd, info, DEVICE_NAME);\n\tif (IS_ERR(task)) {\n\t\tretval = PTR_ERR(task);\n\t\tgoto err_unregister_framebuffer;\n\t}\n\n\tps3fb.task = task;\n\n\treturn 0;\n\nerr_unregister_framebuffer:\n\tunregister_framebuffer(info);\nerr_fb_dealloc:\n\tfb_dealloc_cmap(&info->cmap);\nerr_framebuffer_release:\n\tframebuffer_release(info);\nerr_context_fb_close:\n\tlv1_gpu_fb_close(ps3fb.context_handle);\nerr_context_unmap:\n\tlv1_gpu_context_iomap(ps3fb.context_handle, GPU_IOIF, xdr_lpar,\n\t\t\t      ps3fb_videomemory.size, CBE_IOPTE_M);\nerr_free_irq:\n\tfree_irq(ps3fb.irq_no, &dev->core);\nerr_destroy_plug:\n\tps3_irq_plug_destroy(ps3fb.irq_no);\nerr_iounmap_dinfo:\n\tiounmap((u8 __force __iomem *)ps3fb.dinfo);\nerr_gpu_context_free:\n\tlv1_gpu_context_free(ps3fb.context_handle);\nerr_gpu_memory_free:\n\tlv1_gpu_memory_free(ps3fb.memory_handle);\nerr_close_device:\n\tps3_close_hv_device(dev);\nerr:\n\treturn retval;\n}\n\nstatic void ps3fb_shutdown(struct ps3_system_bus_device *dev)\n{\n\tstruct fb_info *info = ps3_system_bus_get_drvdata(dev);\n\tu64 xdr_lpar = ps3_mm_phys_to_lpar(__pa(ps3fb_videomemory.address));\n\n\tdev_dbg(&dev->core, \" -> %s:%d\\n\", __func__, __LINE__);\n\n\tatomic_inc(&ps3fb.ext_flip);\t \n\tps3fb.dinfo->irq.mask = 0;\n\n\tif (ps3fb.task) {\n\t\tstruct task_struct *task = ps3fb.task;\n\t\tps3fb.task = NULL;\n\t\tkthread_stop(task);\n\t}\n\tif (ps3fb.irq_no) {\n\t\tfree_irq(ps3fb.irq_no, &dev->core);\n\t\tps3_irq_plug_destroy(ps3fb.irq_no);\n\t}\n\tif (info) {\n\t\tunregister_framebuffer(info);\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\tframebuffer_release(info);\n\t\tps3_system_bus_set_drvdata(dev, NULL);\n\t}\n\tiounmap((u8 __force __iomem *)ps3fb.dinfo);\n\tlv1_gpu_fb_close(ps3fb.context_handle);\n\tlv1_gpu_context_iomap(ps3fb.context_handle, GPU_IOIF, xdr_lpar,\n\t\t\t      ps3fb_videomemory.size, CBE_IOPTE_M);\n\tlv1_gpu_context_free(ps3fb.context_handle);\n\tlv1_gpu_memory_free(ps3fb.memory_handle);\n\tps3_close_hv_device(dev);\n\tdev_dbg(&dev->core, \" <- %s:%d\\n\", __func__, __LINE__);\n}\n\nstatic struct ps3_system_bus_driver ps3fb_driver = {\n\t.match_id\t= PS3_MATCH_ID_GPU,\n\t.match_sub_id\t= PS3_MATCH_SUB_ID_GPU_FB,\n\t.core.name\t= DEVICE_NAME,\n\t.core.owner\t= THIS_MODULE,\n\t.probe\t\t= ps3fb_probe,\n\t.remove\t\t= ps3fb_shutdown,\n\t.shutdown\t= ps3fb_shutdown,\n};\n\nstatic int __init ps3fb_setup(void)\n{\n\tchar *options;\n\n#ifdef MODULE\n\treturn 0;\n#endif\n\n\tif (fb_get_options(DEVICE_NAME, &options))\n\t\treturn -ENXIO;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile (1) {\n\t\tchar *this_opt = strsep(&options, \",\");\n\n\t\tif (!this_opt)\n\t\t\tbreak;\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\t\tif (!strncmp(this_opt, \"mode:\", 5))\n\t\t\tps3fb_mode = simple_strtoul(this_opt + 5, NULL, 0);\n\t\telse\n\t\t\tmode_option = this_opt;\n\t}\n\treturn 0;\n}\n\nstatic int __init ps3fb_init(void)\n{\n\tif (!ps3fb_videomemory.address ||  ps3fb_setup())\n\t\treturn -ENXIO;\n\n\treturn ps3_system_bus_driver_register(&ps3fb_driver);\n}\n\nstatic void __exit ps3fb_exit(void)\n{\n\tpr_debug(\" -> %s:%d\\n\", __func__, __LINE__);\n\tps3_system_bus_driver_unregister(&ps3fb_driver);\n\tpr_debug(\" <- %s:%d\\n\", __func__, __LINE__);\n}\n\nmodule_init(ps3fb_init);\nmodule_exit(ps3fb_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"PS3 GPU Frame Buffer Driver\");\nMODULE_AUTHOR(\"Sony Computer Entertainment Inc.\");\nMODULE_ALIAS(PS3_MODULE_ALIAS_GPU_FB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}