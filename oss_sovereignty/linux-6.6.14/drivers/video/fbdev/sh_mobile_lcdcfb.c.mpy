{
  "module_name": "sh_mobile_lcdcfb.c",
  "hash_id": "e56b018624220bd1dae45cc70487f98e76a19d887f56eccfeda262c48433d3d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/sh_mobile_lcdcfb.c",
  "human_readable_source": " \n\n#include <linux/atomic.h>\n#include <linux/backlight.h>\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/ctype.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/fbcon.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioctl.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/vmalloc.h>\n\n#include <video/sh_mobile_lcdc.h>\n\n#include \"sh_mobile_lcdcfb.h\"\n\n \n\n#define LDBCR\t\t\t0xb00\n#define LDBCR_UPC(n)\t\t(1 << ((n) + 16))\n#define LDBCR_UPF(n)\t\t(1 << ((n) + 8))\n#define LDBCR_UPD(n)\t\t(1 << ((n) + 0))\n#define LDBnBSIFR(n)\t\t(0xb20 + (n) * 0x20 + 0x00)\n#define LDBBSIFR_EN\t\t(1 << 31)\n#define LDBBSIFR_VS\t\t(1 << 29)\n#define LDBBSIFR_BRSEL\t\t(1 << 28)\n#define LDBBSIFR_MX\t\t(1 << 27)\n#define LDBBSIFR_MY\t\t(1 << 26)\n#define LDBBSIFR_CV3\t\t(3 << 24)\n#define LDBBSIFR_CV2\t\t(2 << 24)\n#define LDBBSIFR_CV1\t\t(1 << 24)\n#define LDBBSIFR_CV0\t\t(0 << 24)\n#define LDBBSIFR_CV_MASK\t(3 << 24)\n#define LDBBSIFR_LAY_MASK\t(0xff << 16)\n#define LDBBSIFR_LAY_SHIFT\t16\n#define LDBBSIFR_ROP3_MASK\t(0xff << 16)\n#define LDBBSIFR_ROP3_SHIFT\t16\n#define LDBBSIFR_AL_PL8\t\t(3 << 14)\n#define LDBBSIFR_AL_PL1\t\t(2 << 14)\n#define LDBBSIFR_AL_PK\t\t(1 << 14)\n#define LDBBSIFR_AL_1\t\t(0 << 14)\n#define LDBBSIFR_AL_MASK\t(3 << 14)\n#define LDBBSIFR_SWPL\t\t(1 << 10)\n#define LDBBSIFR_SWPW\t\t(1 << 9)\n#define LDBBSIFR_SWPB\t\t(1 << 8)\n#define LDBBSIFR_RY\t\t(1 << 7)\n#define LDBBSIFR_CHRR_420\t(2 << 0)\n#define LDBBSIFR_CHRR_422\t(1 << 0)\n#define LDBBSIFR_CHRR_444\t(0 << 0)\n#define LDBBSIFR_RPKF_ARGB32\t(0x00 << 0)\n#define LDBBSIFR_RPKF_RGB16\t(0x03 << 0)\n#define LDBBSIFR_RPKF_RGB24\t(0x0b << 0)\n#define LDBBSIFR_RPKF_MASK\t(0x1f << 0)\n#define LDBnBSSZR(n)\t\t(0xb20 + (n) * 0x20 + 0x04)\n#define LDBBSSZR_BVSS_MASK\t(0xfff << 16)\n#define LDBBSSZR_BVSS_SHIFT\t16\n#define LDBBSSZR_BHSS_MASK\t(0xfff << 0)\n#define LDBBSSZR_BHSS_SHIFT\t0\n#define LDBnBLOCR(n)\t\t(0xb20 + (n) * 0x20 + 0x08)\n#define LDBBLOCR_CVLC_MASK\t(0xfff << 16)\n#define LDBBLOCR_CVLC_SHIFT\t16\n#define LDBBLOCR_CHLC_MASK\t(0xfff << 0)\n#define LDBBLOCR_CHLC_SHIFT\t0\n#define LDBnBSMWR(n)\t\t(0xb20 + (n) * 0x20 + 0x0c)\n#define LDBBSMWR_BSMWA_MASK\t(0xffff << 16)\n#define LDBBSMWR_BSMWA_SHIFT\t16\n#define LDBBSMWR_BSMW_MASK\t(0xffff << 0)\n#define LDBBSMWR_BSMW_SHIFT\t0\n#define LDBnBSAYR(n)\t\t(0xb20 + (n) * 0x20 + 0x10)\n#define LDBBSAYR_FG1A_MASK\t(0xff << 24)\n#define LDBBSAYR_FG1A_SHIFT\t24\n#define LDBBSAYR_FG1R_MASK\t(0xff << 16)\n#define LDBBSAYR_FG1R_SHIFT\t16\n#define LDBBSAYR_FG1G_MASK\t(0xff << 8)\n#define LDBBSAYR_FG1G_SHIFT\t8\n#define LDBBSAYR_FG1B_MASK\t(0xff << 0)\n#define LDBBSAYR_FG1B_SHIFT\t0\n#define LDBnBSACR(n)\t\t(0xb20 + (n) * 0x20 + 0x14)\n#define LDBBSACR_FG2A_MASK\t(0xff << 24)\n#define LDBBSACR_FG2A_SHIFT\t24\n#define LDBBSACR_FG2R_MASK\t(0xff << 16)\n#define LDBBSACR_FG2R_SHIFT\t16\n#define LDBBSACR_FG2G_MASK\t(0xff << 8)\n#define LDBBSACR_FG2G_SHIFT\t8\n#define LDBBSACR_FG2B_MASK\t(0xff << 0)\n#define LDBBSACR_FG2B_SHIFT\t0\n#define LDBnBSAAR(n)\t\t(0xb20 + (n) * 0x20 + 0x18)\n#define LDBBSAAR_AP_MASK\t(0xff << 24)\n#define LDBBSAAR_AP_SHIFT\t24\n#define LDBBSAAR_R_MASK\t\t(0xff << 16)\n#define LDBBSAAR_R_SHIFT\t16\n#define LDBBSAAR_GY_MASK\t(0xff << 8)\n#define LDBBSAAR_GY_SHIFT\t8\n#define LDBBSAAR_B_MASK\t\t(0xff << 0)\n#define LDBBSAAR_B_SHIFT\t0\n#define LDBnBPPCR(n)\t\t(0xb20 + (n) * 0x20 + 0x1c)\n#define LDBBPPCR_AP_MASK\t(0xff << 24)\n#define LDBBPPCR_AP_SHIFT\t24\n#define LDBBPPCR_R_MASK\t\t(0xff << 16)\n#define LDBBPPCR_R_SHIFT\t16\n#define LDBBPPCR_GY_MASK\t(0xff << 8)\n#define LDBBPPCR_GY_SHIFT\t8\n#define LDBBPPCR_B_MASK\t\t(0xff << 0)\n#define LDBBPPCR_B_SHIFT\t0\n#define LDBnBBGCL(n)\t\t(0xb10 + (n) * 0x04)\n#define LDBBBGCL_BGA_MASK\t(0xff << 24)\n#define LDBBBGCL_BGA_SHIFT\t24\n#define LDBBBGCL_BGR_MASK\t(0xff << 16)\n#define LDBBBGCL_BGR_SHIFT\t16\n#define LDBBBGCL_BGG_MASK\t(0xff << 8)\n#define LDBBBGCL_BGG_SHIFT\t8\n#define LDBBBGCL_BGB_MASK\t(0xff << 0)\n#define LDBBBGCL_BGB_SHIFT\t0\n\n#define SIDE_B_OFFSET 0x1000\n#define MIRROR_OFFSET 0x2000\n\n#define MAX_XRES 1920\n#define MAX_YRES 1080\n\nenum sh_mobile_lcdc_overlay_mode {\n\tLCDC_OVERLAY_BLEND,\n\tLCDC_OVERLAY_ROP3,\n};\n\n \nstruct sh_mobile_lcdc_overlay {\n\tstruct sh_mobile_lcdc_chan *channel;\n\n\tconst struct sh_mobile_lcdc_overlay_cfg *cfg;\n\tstruct fb_info *info;\n\n\tunsigned int index;\n\tunsigned long base;\n\n\tbool enabled;\n\tenum sh_mobile_lcdc_overlay_mode mode;\n\tunsigned int alpha;\n\tunsigned int rop3;\n\n\tvoid *fb_mem;\n\tunsigned long fb_size;\n\n\tdma_addr_t dma_handle;\n\tunsigned long base_addr_y;\n\tunsigned long base_addr_c;\n\tunsigned long pan_y_offset;\n\n\tconst struct sh_mobile_lcdc_format_info *format;\n\tunsigned int xres;\n\tunsigned int xres_virtual;\n\tunsigned int yres;\n\tunsigned int yres_virtual;\n\tunsigned int pitch;\n\tint pos_x;\n\tint pos_y;\n};\n\nstruct sh_mobile_lcdc_priv {\n\tvoid __iomem *base;\n\tint irq;\n\tatomic_t hw_usecnt;\n\tstruct device *dev;\n\tstruct clk *dot_clk;\n\tunsigned long lddckr;\n\n\tstruct sh_mobile_lcdc_chan ch[2];\n\tstruct sh_mobile_lcdc_overlay overlays[4];\n\n\tint started;\n\tint forced_fourcc;  \n};\n\n \n\nstatic unsigned long lcdc_offs_mainlcd[NR_CH_REGS] = {\n\t[LDDCKPAT1R] = 0x400,\n\t[LDDCKPAT2R] = 0x404,\n\t[LDMT1R] = 0x418,\n\t[LDMT2R] = 0x41c,\n\t[LDMT3R] = 0x420,\n\t[LDDFR] = 0x424,\n\t[LDSM1R] = 0x428,\n\t[LDSM2R] = 0x42c,\n\t[LDSA1R] = 0x430,\n\t[LDSA2R] = 0x434,\n\t[LDMLSR] = 0x438,\n\t[LDHCNR] = 0x448,\n\t[LDHSYNR] = 0x44c,\n\t[LDVLNR] = 0x450,\n\t[LDVSYNR] = 0x454,\n\t[LDPMR] = 0x460,\n\t[LDHAJR] = 0x4a0,\n};\n\nstatic unsigned long lcdc_offs_sublcd[NR_CH_REGS] = {\n\t[LDDCKPAT1R] = 0x408,\n\t[LDDCKPAT2R] = 0x40c,\n\t[LDMT1R] = 0x600,\n\t[LDMT2R] = 0x604,\n\t[LDMT3R] = 0x608,\n\t[LDDFR] = 0x60c,\n\t[LDSM1R] = 0x610,\n\t[LDSM2R] = 0x614,\n\t[LDSA1R] = 0x618,\n\t[LDMLSR] = 0x620,\n\t[LDHCNR] = 0x624,\n\t[LDHSYNR] = 0x628,\n\t[LDVLNR] = 0x62c,\n\t[LDVSYNR] = 0x630,\n\t[LDPMR] = 0x63c,\n};\n\nstatic bool banked(int reg_nr)\n{\n\tswitch (reg_nr) {\n\tcase LDMT1R:\n\tcase LDMT2R:\n\tcase LDMT3R:\n\tcase LDDFR:\n\tcase LDSM1R:\n\tcase LDSA1R:\n\tcase LDSA2R:\n\tcase LDMLSR:\n\tcase LDHCNR:\n\tcase LDHSYNR:\n\tcase LDVLNR:\n\tcase LDVSYNR:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int lcdc_chan_is_sublcd(struct sh_mobile_lcdc_chan *chan)\n{\n\treturn chan->cfg->chan == LCDC_CHAN_SUBLCD;\n}\n\nstatic void lcdc_write_chan(struct sh_mobile_lcdc_chan *chan,\n\t\t\t    int reg_nr, unsigned long data)\n{\n\tiowrite32(data, chan->lcdc->base + chan->reg_offs[reg_nr]);\n\tif (banked(reg_nr))\n\t\tiowrite32(data, chan->lcdc->base + chan->reg_offs[reg_nr] +\n\t\t\t  SIDE_B_OFFSET);\n}\n\nstatic void lcdc_write_chan_mirror(struct sh_mobile_lcdc_chan *chan,\n\t\t\t    int reg_nr, unsigned long data)\n{\n\tiowrite32(data, chan->lcdc->base + chan->reg_offs[reg_nr] +\n\t\t  MIRROR_OFFSET);\n}\n\nstatic unsigned long lcdc_read_chan(struct sh_mobile_lcdc_chan *chan,\n\t\t\t\t    int reg_nr)\n{\n\treturn ioread32(chan->lcdc->base + chan->reg_offs[reg_nr]);\n}\n\nstatic void lcdc_write_overlay(struct sh_mobile_lcdc_overlay *ovl,\n\t\t\t       int reg, unsigned long data)\n{\n\tiowrite32(data, ovl->channel->lcdc->base + reg);\n\tiowrite32(data, ovl->channel->lcdc->base + reg + SIDE_B_OFFSET);\n}\n\nstatic void lcdc_write(struct sh_mobile_lcdc_priv *priv,\n\t\t       unsigned long reg_offs, unsigned long data)\n{\n\tiowrite32(data, priv->base + reg_offs);\n}\n\nstatic unsigned long lcdc_read(struct sh_mobile_lcdc_priv *priv,\n\t\t\t       unsigned long reg_offs)\n{\n\treturn ioread32(priv->base + reg_offs);\n}\n\nstatic void lcdc_wait_bit(struct sh_mobile_lcdc_priv *priv,\n\t\t\t  unsigned long reg_offs,\n\t\t\t  unsigned long mask, unsigned long until)\n{\n\twhile ((lcdc_read(priv, reg_offs) & mask) != until)\n\t\tcpu_relax();\n}\n\n \n\nstatic void sh_mobile_lcdc_clk_on(struct sh_mobile_lcdc_priv *priv)\n{\n\tif (atomic_inc_and_test(&priv->hw_usecnt)) {\n\t\tclk_prepare_enable(priv->dot_clk);\n\t\tpm_runtime_get_sync(priv->dev);\n\t}\n}\n\nstatic void sh_mobile_lcdc_clk_off(struct sh_mobile_lcdc_priv *priv)\n{\n\tif (atomic_sub_return(1, &priv->hw_usecnt) == -1) {\n\t\tpm_runtime_put(priv->dev);\n\t\tclk_disable_unprepare(priv->dot_clk);\n\t}\n}\n\nstatic int sh_mobile_lcdc_setup_clocks(struct sh_mobile_lcdc_priv *priv,\n\t\t\t\t       int clock_source)\n{\n\tstruct clk *clk;\n\tchar *str;\n\n\tswitch (clock_source) {\n\tcase LCDC_CLK_BUS:\n\t\tstr = \"bus_clk\";\n\t\tpriv->lddckr = LDDCKR_ICKSEL_BUS;\n\t\tbreak;\n\tcase LCDC_CLK_PERIPHERAL:\n\t\tstr = \"peripheral_clk\";\n\t\tpriv->lddckr = LDDCKR_ICKSEL_MIPI;\n\t\tbreak;\n\tcase LCDC_CLK_EXTERNAL:\n\t\tstr = NULL;\n\t\tpriv->lddckr = LDDCKR_ICKSEL_HDMI;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (str == NULL)\n\t\treturn 0;\n\n\tclk = clk_get(priv->dev, str);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(priv->dev, \"cannot get dot clock %s\\n\", str);\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tpriv->dot_clk = clk;\n\treturn 0;\n}\n\n \n\nstatic void lcdc_sys_write_index(void *handle, unsigned long data)\n{\n\tstruct sh_mobile_lcdc_chan *ch = handle;\n\n\tlcdc_write(ch->lcdc, _LDDWD0R, data | LDDWDxR_WDACT);\n\tlcdc_wait_bit(ch->lcdc, _LDSR, LDSR_AS, 0);\n\tlcdc_write(ch->lcdc, _LDDWAR, LDDWAR_WA |\n\t\t   (lcdc_chan_is_sublcd(ch) ? 2 : 0));\n\tlcdc_wait_bit(ch->lcdc, _LDSR, LDSR_AS, 0);\n}\n\nstatic void lcdc_sys_write_data(void *handle, unsigned long data)\n{\n\tstruct sh_mobile_lcdc_chan *ch = handle;\n\n\tlcdc_write(ch->lcdc, _LDDWD0R, data | LDDWDxR_WDACT | LDDWDxR_RSW);\n\tlcdc_wait_bit(ch->lcdc, _LDSR, LDSR_AS, 0);\n\tlcdc_write(ch->lcdc, _LDDWAR, LDDWAR_WA |\n\t\t   (lcdc_chan_is_sublcd(ch) ? 2 : 0));\n\tlcdc_wait_bit(ch->lcdc, _LDSR, LDSR_AS, 0);\n}\n\nstatic unsigned long lcdc_sys_read_data(void *handle)\n{\n\tstruct sh_mobile_lcdc_chan *ch = handle;\n\n\tlcdc_write(ch->lcdc, _LDDRDR, LDDRDR_RSR);\n\tlcdc_wait_bit(ch->lcdc, _LDSR, LDSR_AS, 0);\n\tlcdc_write(ch->lcdc, _LDDRAR, LDDRAR_RA |\n\t\t   (lcdc_chan_is_sublcd(ch) ? 2 : 0));\n\tudelay(1);\n\tlcdc_wait_bit(ch->lcdc, _LDSR, LDSR_AS, 0);\n\n\treturn lcdc_read(ch->lcdc, _LDDRDR) & LDDRDR_DRD_MASK;\n}\n\nstatic struct sh_mobile_lcdc_sys_bus_ops sh_mobile_lcdc_sys_bus_ops = {\n\t.write_index\t= lcdc_sys_write_index,\n\t.write_data\t= lcdc_sys_write_data,\n\t.read_data\t= lcdc_sys_read_data,\n};\n\nstatic int sh_mobile_lcdc_sginit(struct fb_info *info, struct list_head *pagereflist)\n{\n\tstruct sh_mobile_lcdc_chan *ch = info->par;\n\tunsigned int nr_pages_max = ch->fb_size >> PAGE_SHIFT;\n\tstruct fb_deferred_io_pageref *pageref;\n\tint nr_pages = 0;\n\n\tsg_init_table(ch->sglist, nr_pages_max);\n\n\tlist_for_each_entry(pageref, pagereflist, list) {\n\t\tsg_set_page(&ch->sglist[nr_pages++], pageref->page, PAGE_SIZE, 0);\n\t}\n\n\treturn nr_pages;\n}\n\nstatic void sh_mobile_lcdc_deferred_io(struct fb_info *info, struct list_head *pagereflist)\n{\n\tstruct sh_mobile_lcdc_chan *ch = info->par;\n\tconst struct sh_mobile_lcdc_panel_cfg *panel = &ch->cfg->panel_cfg;\n\n\t \n\tsh_mobile_lcdc_clk_on(ch->lcdc);\n\n\t \n\tif (!list_empty(pagereflist)) {\n\t\tunsigned int nr_pages = sh_mobile_lcdc_sginit(info, pagereflist);\n\n\t\t \n\t\tdma_map_sg(ch->lcdc->dev, ch->sglist, nr_pages, DMA_TO_DEVICE);\n\t\tif (panel->start_transfer)\n\t\t\tpanel->start_transfer(ch, &sh_mobile_lcdc_sys_bus_ops);\n\t\tlcdc_write_chan(ch, LDSM2R, LDSM2R_OSTRG);\n\t\tdma_unmap_sg(ch->lcdc->dev, ch->sglist, nr_pages,\n\t\t\t     DMA_TO_DEVICE);\n\t} else {\n\t\tif (panel->start_transfer)\n\t\t\tpanel->start_transfer(ch, &sh_mobile_lcdc_sys_bus_ops);\n\t\tlcdc_write_chan(ch, LDSM2R, LDSM2R_OSTRG);\n\t}\n}\n\nstatic void sh_mobile_lcdc_deferred_io_touch(struct fb_info *info)\n{\n\tstruct fb_deferred_io *fbdefio = info->fbdefio;\n\n\tif (fbdefio)\n\t\tschedule_delayed_work(&info->deferred_work, fbdefio->delay);\n}\n\nstatic void sh_mobile_lcdc_display_on(struct sh_mobile_lcdc_chan *ch)\n{\n\tconst struct sh_mobile_lcdc_panel_cfg *panel = &ch->cfg->panel_cfg;\n\n\tif (ch->tx_dev) {\n\t\tint ret;\n\n\t\tret = ch->tx_dev->ops->display_on(ch->tx_dev);\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\tif (ret == SH_MOBILE_LCDC_DISPLAY_DISCONNECTED)\n\t\t\tch->info->state = FBINFO_STATE_SUSPENDED;\n\t}\n\n\t \n\tif (panel->display_on)\n\t\tpanel->display_on();\n}\n\nstatic void sh_mobile_lcdc_display_off(struct sh_mobile_lcdc_chan *ch)\n{\n\tconst struct sh_mobile_lcdc_panel_cfg *panel = &ch->cfg->panel_cfg;\n\n\tif (panel->display_off)\n\t\tpanel->display_off();\n\n\tif (ch->tx_dev)\n\t\tch->tx_dev->ops->display_off(ch->tx_dev);\n}\n\n \n\nstruct sh_mobile_lcdc_format_info {\n\tu32 fourcc;\n\tunsigned int bpp;\n\tbool yuv;\n\tu32 lddfr;\n};\n\nstatic const struct sh_mobile_lcdc_format_info sh_mobile_format_infos[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_RGB565,\n\t\t.bpp = 16,\n\t\t.yuv = false,\n\t\t.lddfr = LDDFR_PKF_RGB16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_BGR24,\n\t\t.bpp = 24,\n\t\t.yuv = false,\n\t\t.lddfr = LDDFR_PKF_RGB24,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_BGR32,\n\t\t.bpp = 32,\n\t\t.yuv = false,\n\t\t.lddfr = LDDFR_PKF_ARGB32,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV12,\n\t\t.bpp = 12,\n\t\t.yuv = true,\n\t\t.lddfr = LDDFR_CC | LDDFR_YF_420,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV21,\n\t\t.bpp = 12,\n\t\t.yuv = true,\n\t\t.lddfr = LDDFR_CC | LDDFR_YF_420,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV16,\n\t\t.bpp = 16,\n\t\t.yuv = true,\n\t\t.lddfr = LDDFR_CC | LDDFR_YF_422,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV61,\n\t\t.bpp = 16,\n\t\t.yuv = true,\n\t\t.lddfr = LDDFR_CC | LDDFR_YF_422,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV24,\n\t\t.bpp = 24,\n\t\t.yuv = true,\n\t\t.lddfr = LDDFR_CC | LDDFR_YF_444,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV42,\n\t\t.bpp = 24,\n\t\t.yuv = true,\n\t\t.lddfr = LDDFR_CC | LDDFR_YF_444,\n\t},\n};\n\nstatic const struct sh_mobile_lcdc_format_info *\nsh_mobile_format_info(u32 fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sh_mobile_format_infos); ++i) {\n\t\tif (sh_mobile_format_infos[i].fourcc == fourcc)\n\t\t\treturn &sh_mobile_format_infos[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int sh_mobile_format_fourcc(const struct fb_var_screeninfo *var)\n{\n\tif (var->grayscale > 1)\n\t\treturn var->grayscale;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 16:\n\t\treturn V4L2_PIX_FMT_RGB565;\n\tcase 24:\n\t\treturn V4L2_PIX_FMT_BGR24;\n\tcase 32:\n\t\treturn V4L2_PIX_FMT_BGR32;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int sh_mobile_format_is_fourcc(const struct fb_var_screeninfo *var)\n{\n\treturn var->grayscale > 1;\n}\n\n \n\nstatic irqreturn_t sh_mobile_lcdc_irq(int irq, void *data)\n{\n\tstruct sh_mobile_lcdc_priv *priv = data;\n\tstruct sh_mobile_lcdc_chan *ch;\n\tunsigned long ldintr;\n\tint is_sub;\n\tint k;\n\n\t \n\tldintr = lcdc_read(priv, _LDINTR);\n\tlcdc_write(priv, _LDINTR, (ldintr ^ LDINTR_STATUS_MASK) & ~LDINTR_VEE);\n\n\t \n\tis_sub = (lcdc_read(priv, _LDSR) & LDSR_MSS) ? 1 : 0;\n\n\t \n\tfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\n\t\tch = &priv->ch[k];\n\n\t\tif (!ch->enabled)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ldintr & LDINTR_FS) {\n\t\t\tif (is_sub == lcdc_chan_is_sublcd(ch)) {\n\t\t\t\tch->frame_end = 1;\n\t\t\t\twake_up(&ch->frame_end_wait);\n\n\t\t\t\tsh_mobile_lcdc_clk_off(priv);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (ldintr & LDINTR_VES)\n\t\t\tcomplete(&ch->vsync_completion);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sh_mobile_lcdc_wait_for_vsync(struct sh_mobile_lcdc_chan *ch)\n{\n\tunsigned long ldintr;\n\tint ret;\n\n\t \n\tldintr = lcdc_read(ch->lcdc, _LDINTR);\n\tldintr |= LDINTR_VEE | LDINTR_STATUS_MASK;\n\tlcdc_write(ch->lcdc, _LDINTR, ldintr);\n\n\tret = wait_for_completion_interruptible_timeout(&ch->vsync_completion,\n\t\t\t\t\t\t\tmsecs_to_jiffies(100));\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void sh_mobile_lcdc_start_stop(struct sh_mobile_lcdc_priv *priv,\n\t\t\t\t      int start)\n{\n\tunsigned long tmp = lcdc_read(priv, _LDCNT2R);\n\tint k;\n\n\t \n\tif (start)\n\t\tlcdc_write(priv, _LDCNT2R, tmp | LDCNT2R_DO);\n\telse\n\t\tlcdc_write(priv, _LDCNT2R, tmp & ~LDCNT2R_DO);\n\n\t \n\tfor (k = 0; k < ARRAY_SIZE(priv->ch); k++)\n\t\tif (lcdc_read(priv, _LDCNT2R) & priv->ch[k].enabled)\n\t\t\twhile (1) {\n\t\t\t\ttmp = lcdc_read_chan(&priv->ch[k], LDPMR)\n\t\t\t\t    & LDPMR_LPS;\n\t\t\t\tif (start && tmp == LDPMR_LPS)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!start && tmp == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcpu_relax();\n\t\t\t}\n\n\tif (!start)\n\t\tlcdc_write(priv, _LDDCKSTPR, 1);  \n}\n\nstatic void sh_mobile_lcdc_geometry(struct sh_mobile_lcdc_chan *ch)\n{\n\tconst struct fb_var_screeninfo *var = &ch->info->var;\n\tconst struct fb_videomode *mode = &ch->display.mode;\n\tunsigned long h_total, hsync_pos, display_h_total;\n\tu32 tmp;\n\n\ttmp = ch->ldmt1r_value;\n\ttmp |= (var->sync & FB_SYNC_VERT_HIGH_ACT) ? 0 : LDMT1R_VPOL;\n\ttmp |= (var->sync & FB_SYNC_HOR_HIGH_ACT) ? 0 : LDMT1R_HPOL;\n\ttmp |= (ch->cfg->flags & LCDC_FLAGS_DWPOL) ? LDMT1R_DWPOL : 0;\n\ttmp |= (ch->cfg->flags & LCDC_FLAGS_DIPOL) ? LDMT1R_DIPOL : 0;\n\ttmp |= (ch->cfg->flags & LCDC_FLAGS_DAPOL) ? LDMT1R_DAPOL : 0;\n\ttmp |= (ch->cfg->flags & LCDC_FLAGS_HSCNT) ? LDMT1R_HSCNT : 0;\n\ttmp |= (ch->cfg->flags & LCDC_FLAGS_DWCNT) ? LDMT1R_DWCNT : 0;\n\tlcdc_write_chan(ch, LDMT1R, tmp);\n\n\t \n\tlcdc_write_chan(ch, LDMT2R, ch->cfg->sys_bus_cfg.ldmt2r);\n\tlcdc_write_chan(ch, LDMT3R, ch->cfg->sys_bus_cfg.ldmt3r);\n\n\t \n\th_total = mode->xres + mode->hsync_len + mode->left_margin\n\t\t+ mode->right_margin;\n\ttmp = h_total / 8;  \n\ttmp |= (min(mode->xres, ch->xres) / 8) << 16;  \n\tlcdc_write_chan(ch, LDHCNR, tmp);\n\n\thsync_pos = mode->xres + mode->right_margin;\n\ttmp = hsync_pos / 8;  \n\ttmp |= (mode->hsync_len / 8) << 16;  \n\tlcdc_write_chan(ch, LDHSYNR, tmp);\n\n\t \n\ttmp = mode->yres + mode->vsync_len + mode->upper_margin\n\t    + mode->lower_margin;  \n\ttmp |= min(mode->yres, ch->yres) << 16;  \n\tlcdc_write_chan(ch, LDVLNR, tmp);\n\n\ttmp = mode->yres + mode->lower_margin;  \n\ttmp |= mode->vsync_len << 16;  \n\tlcdc_write_chan(ch, LDVSYNR, tmp);\n\n\t \n\tdisplay_h_total = mode->xres + mode->hsync_len + mode->left_margin\n\t\t\t+ mode->right_margin;\n\ttmp = ((mode->xres & 7) << 24) | ((display_h_total & 7) << 16)\n\t    | ((mode->hsync_len & 7) << 8) | (hsync_pos & 7);\n\tlcdc_write_chan(ch, LDHAJR, tmp);\n\tlcdc_write_chan_mirror(ch, LDHAJR, tmp);\n}\n\nstatic void sh_mobile_lcdc_overlay_setup(struct sh_mobile_lcdc_overlay *ovl)\n{\n\tu32 format = 0;\n\n\tif (!ovl->enabled) {\n\t\tlcdc_write(ovl->channel->lcdc, LDBCR, LDBCR_UPC(ovl->index));\n\t\tlcdc_write_overlay(ovl, LDBnBSIFR(ovl->index), 0);\n\t\tlcdc_write(ovl->channel->lcdc, LDBCR,\n\t\t\t   LDBCR_UPF(ovl->index) | LDBCR_UPD(ovl->index));\n\t\treturn;\n\t}\n\n\tovl->base_addr_y = ovl->dma_handle;\n\tovl->base_addr_c = ovl->dma_handle\n\t\t\t + ovl->xres_virtual * ovl->yres_virtual;\n\n\tswitch (ovl->mode) {\n\tcase LCDC_OVERLAY_BLEND:\n\t\tformat = LDBBSIFR_EN | (ovl->alpha << LDBBSIFR_LAY_SHIFT);\n\t\tbreak;\n\n\tcase LCDC_OVERLAY_ROP3:\n\t\tformat = LDBBSIFR_EN | LDBBSIFR_BRSEL\n\t\t       | (ovl->rop3 << LDBBSIFR_ROP3_SHIFT);\n\t\tbreak;\n\t}\n\n\tswitch (ovl->format->fourcc) {\n\tcase V4L2_PIX_FMT_RGB565:\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_NV61:\n\tcase V4L2_PIX_FMT_NV42:\n\t\tformat |= LDBBSIFR_SWPL | LDBBSIFR_SWPW;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR24:\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV24:\n\t\tformat |= LDBBSIFR_SWPL | LDBBSIFR_SWPW | LDBBSIFR_SWPB;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\tdefault:\n\t\tformat |= LDBBSIFR_SWPL;\n\t\tbreak;\n\t}\n\n\tswitch (ovl->format->fourcc) {\n\tcase V4L2_PIX_FMT_RGB565:\n\t\tformat |= LDBBSIFR_AL_1 | LDBBSIFR_RY | LDBBSIFR_RPKF_RGB16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR24:\n\t\tformat |= LDBBSIFR_AL_1 | LDBBSIFR_RY | LDBBSIFR_RPKF_RGB24;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\t\tformat |= LDBBSIFR_AL_PK | LDBBSIFR_RY | LDBBSIFR_RPKF_ARGB32;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\tformat |= LDBBSIFR_AL_1 | LDBBSIFR_CHRR_420;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\t\tformat |= LDBBSIFR_AL_1 | LDBBSIFR_CHRR_422;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV24:\n\tcase V4L2_PIX_FMT_NV42:\n\t\tformat |= LDBBSIFR_AL_1 | LDBBSIFR_CHRR_444;\n\t\tbreak;\n\t}\n\n\tlcdc_write(ovl->channel->lcdc, LDBCR, LDBCR_UPC(ovl->index));\n\n\tlcdc_write_overlay(ovl, LDBnBSIFR(ovl->index), format);\n\n\tlcdc_write_overlay(ovl, LDBnBSSZR(ovl->index),\n\t\t(ovl->yres << LDBBSSZR_BVSS_SHIFT) |\n\t\t(ovl->xres << LDBBSSZR_BHSS_SHIFT));\n\tlcdc_write_overlay(ovl, LDBnBLOCR(ovl->index),\n\t\t(ovl->pos_y << LDBBLOCR_CVLC_SHIFT) |\n\t\t(ovl->pos_x << LDBBLOCR_CHLC_SHIFT));\n\tlcdc_write_overlay(ovl, LDBnBSMWR(ovl->index),\n\t\tovl->pitch << LDBBSMWR_BSMW_SHIFT);\n\n\tlcdc_write_overlay(ovl, LDBnBSAYR(ovl->index), ovl->base_addr_y);\n\tlcdc_write_overlay(ovl, LDBnBSACR(ovl->index), ovl->base_addr_c);\n\n\tlcdc_write(ovl->channel->lcdc, LDBCR,\n\t\t   LDBCR_UPF(ovl->index) | LDBCR_UPD(ovl->index));\n}\n\n \nstatic void __sh_mobile_lcdc_start(struct sh_mobile_lcdc_priv *priv)\n{\n\tstruct sh_mobile_lcdc_chan *ch;\n\tunsigned long tmp;\n\tint k, m;\n\n\t \n\tlcdc_write(priv, _LDCNT2R, priv->ch[0].enabled | priv->ch[1].enabled);\n\n\t \n\tsh_mobile_lcdc_start_stop(priv, 0);\n\tlcdc_write(priv, _LDINTR, 0);\n\n\t \n\ttmp = priv->lddckr;\n\tfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\n\t\tch = &priv->ch[k];\n\t\tif (!ch->enabled)\n\t\t\tcontinue;\n\n\t\t \n\t\tlcdc_write_chan(ch, LDPMR, 0);\n\n\t\tm = ch->cfg->clock_divider;\n\t\tif (!m)\n\t\t\tcontinue;\n\n\t\t \n\t\tlcdc_write_chan(ch, LDDCKPAT1R, 0);\n\t\tlcdc_write_chan(ch, LDDCKPAT2R, (1 << (m/2)) - 1);\n\n\t\tif (m == 1)\n\t\t\tm = LDDCKR_MOSEL;\n\t\ttmp |= m << (lcdc_chan_is_sublcd(ch) ? 8 : 0);\n\t}\n\n\tlcdc_write(priv, _LDDCKR, tmp);\n\tlcdc_write(priv, _LDDCKSTPR, 0);\n\tlcdc_wait_bit(priv, _LDDCKSTPR, ~0, 0);\n\n\t \n\tfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\n\t\tch = &priv->ch[k];\n\t\tif (!ch->enabled)\n\t\t\tcontinue;\n\n\t\tsh_mobile_lcdc_geometry(ch);\n\n\t\ttmp = ch->format->lddfr;\n\n\t\tif (ch->format->yuv) {\n\t\t\tswitch (ch->colorspace) {\n\t\t\tcase V4L2_COLORSPACE_REC709:\n\t\t\t\ttmp |= LDDFR_CF1;\n\t\t\t\tbreak;\n\t\t\tcase V4L2_COLORSPACE_JPEG:\n\t\t\t\ttmp |= LDDFR_CF0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlcdc_write_chan(ch, LDDFR, tmp);\n\t\tlcdc_write_chan(ch, LDMLSR, ch->line_size);\n\t\tlcdc_write_chan(ch, LDSA1R, ch->base_addr_y);\n\t\tif (ch->format->yuv)\n\t\t\tlcdc_write_chan(ch, LDSA2R, ch->base_addr_c);\n\n\t\t \n\t\tif (ch->ldmt1r_value & LDMT1R_IFM &&\n\t\t    ch->cfg->sys_bus_cfg.deferred_io_msec) {\n\t\t\tlcdc_write_chan(ch, LDSM1R, LDSM1R_OS);\n\t\t\tlcdc_write(priv, _LDINTR, LDINTR_FE);\n\t\t} else {\n\t\t\tlcdc_write_chan(ch, LDSM1R, 0);\n\t\t}\n\t}\n\n\t \n\tswitch (priv->ch[0].format->fourcc) {\n\tcase V4L2_PIX_FMT_RGB565:\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_NV61:\n\tcase V4L2_PIX_FMT_NV42:\n\t\ttmp = LDDDSR_LS | LDDDSR_WS;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR24:\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV24:\n\t\ttmp = LDDDSR_LS | LDDDSR_WS | LDDDSR_BS;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\tdefault:\n\t\ttmp = LDDDSR_LS;\n\t\tbreak;\n\t}\n\tlcdc_write(priv, _LDDDSR, tmp);\n\n\t \n\tlcdc_write(priv, _LDCNT1R, LDCNT1R_DE);\n\tsh_mobile_lcdc_start_stop(priv, 1);\n\tpriv->started = 1;\n}\n\nstatic int sh_mobile_lcdc_start(struct sh_mobile_lcdc_priv *priv)\n{\n\tstruct sh_mobile_lcdc_chan *ch;\n\tunsigned long tmp;\n\tint ret;\n\tint k;\n\n\t \n\tfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\n\t\tif (priv->ch[k].enabled)\n\t\t\tsh_mobile_lcdc_clk_on(priv);\n\t}\n\n\t \n\tlcdc_write(priv, _LDCNT2R, lcdc_read(priv, _LDCNT2R) | LDCNT2R_BR);\n\tlcdc_wait_bit(priv, _LDCNT2R, LDCNT2R_BR, 0);\n\n\tfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\n\t\tconst struct sh_mobile_lcdc_panel_cfg *panel;\n\n\t\tch = &priv->ch[k];\n\t\tif (!ch->enabled)\n\t\t\tcontinue;\n\n\t\tpanel = &ch->cfg->panel_cfg;\n\t\tif (panel->setup_sys) {\n\t\t\tret = panel->setup_sys(ch, &sh_mobile_lcdc_sys_bus_ops);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\n\t\tch = &priv->ch[k];\n\t\tif (!ch->enabled)\n\t\t\tcontinue;\n\n\t\tch->base_addr_y = ch->dma_handle;\n\t\tch->base_addr_c = ch->dma_handle\n\t\t\t\t+ ch->xres_virtual * ch->yres_virtual;\n\t\tch->line_size = ch->pitch;\n\t}\n\n\tfor (k = 0; k < ARRAY_SIZE(priv->overlays); ++k) {\n\t\tstruct sh_mobile_lcdc_overlay *ovl = &priv->overlays[k];\n\t\tsh_mobile_lcdc_overlay_setup(ovl);\n\t}\n\n\t \n\t__sh_mobile_lcdc_start(priv);\n\n\t \n\tfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\n\t\tch = &priv->ch[k];\n\t\tif (!ch->enabled)\n\t\t\tcontinue;\n\n\t\ttmp = ch->cfg->sys_bus_cfg.deferred_io_msec;\n\t\tif (ch->ldmt1r_value & LDMT1R_IFM && tmp) {\n\t\t\tch->defio.deferred_io = sh_mobile_lcdc_deferred_io;\n\t\t\tch->defio.delay = msecs_to_jiffies(tmp);\n\t\t\tch->info->fbdefio = &ch->defio;\n\t\t\tfb_deferred_io_init(ch->info);\n\t\t}\n\n\t\tsh_mobile_lcdc_display_on(ch);\n\n\t\tif (ch->bl) {\n\t\t\tch->bl->props.power = FB_BLANK_UNBLANK;\n\t\t\tbacklight_update_status(ch->bl);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void sh_mobile_lcdc_stop(struct sh_mobile_lcdc_priv *priv)\n{\n\tstruct sh_mobile_lcdc_chan *ch;\n\tint k;\n\n\t \n\tfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\n\t\tch = &priv->ch[k];\n\t\tif (!ch->enabled)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ch->info && ch->info->fbdefio) {\n\t\t\tch->frame_end = 0;\n\t\t\tschedule_delayed_work(&ch->info->deferred_work, 0);\n\t\t\twait_event(ch->frame_end_wait, ch->frame_end);\n\t\t\tfb_deferred_io_cleanup(ch->info);\n\t\t\tch->info->fbdefio = NULL;\n\t\t\tsh_mobile_lcdc_clk_on(priv);\n\t\t}\n\n\t\tif (ch->bl) {\n\t\t\tch->bl->props.power = FB_BLANK_POWERDOWN;\n\t\t\tbacklight_update_status(ch->bl);\n\t\t}\n\n\t\tsh_mobile_lcdc_display_off(ch);\n\t}\n\n\t \n\tif (priv->started) {\n\t\tsh_mobile_lcdc_start_stop(priv, 0);\n\t\tpriv->started = 0;\n\t}\n\n\t \n\tfor (k = 0; k < ARRAY_SIZE(priv->ch); k++)\n\t\tif (priv->ch[k].enabled)\n\t\t\tsh_mobile_lcdc_clk_off(priv);\n}\n\nstatic int __sh_mobile_lcdc_check_var(struct fb_var_screeninfo *var,\n\t\t\t\t      struct fb_info *info)\n{\n\tif (var->xres > MAX_XRES || var->yres > MAX_YRES)\n\t\treturn -EINVAL;\n\n\t \n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres_virtual = var->yres;\n\n\tif (sh_mobile_format_is_fourcc(var)) {\n\t\tconst struct sh_mobile_lcdc_format_info *format;\n\n\t\tformat = sh_mobile_format_info(var->grayscale);\n\t\tif (format == NULL)\n\t\t\treturn -EINVAL;\n\t\tvar->bits_per_pixel = format->bpp;\n\n\t\t \n\t\tif (!format->yuv)\n\t\t\tvar->colorspace = V4L2_COLORSPACE_SRGB;\n\t\telse if (var->colorspace != V4L2_COLORSPACE_REC709)\n\t\t\tvar->colorspace = V4L2_COLORSPACE_JPEG;\n\t} else {\n\t\tif (var->bits_per_pixel <= 16) {\t\t \n\t\t\tvar->bits_per_pixel = 16;\n\t\t\tvar->red.offset = 11;\n\t\t\tvar->red.length = 5;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->green.length = 6;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->blue.length = 5;\n\t\t\tvar->transp.offset = 0;\n\t\t\tvar->transp.length = 0;\n\t\t} else if (var->bits_per_pixel <= 24) {\t\t \n\t\t\tvar->bits_per_pixel = 24;\n\t\t\tvar->red.offset = 16;\n\t\t\tvar->red.length = 8;\n\t\t\tvar->green.offset = 8;\n\t\t\tvar->green.length = 8;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->blue.length = 8;\n\t\t\tvar->transp.offset = 0;\n\t\t\tvar->transp.length = 0;\n\t\t} else if (var->bits_per_pixel <= 32) {\t\t \n\t\t\tvar->bits_per_pixel = 32;\n\t\t\tvar->red.offset = 16;\n\t\t\tvar->red.length = 8;\n\t\t\tvar->green.offset = 8;\n\t\t\tvar->green.length = 8;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->blue.length = 8;\n\t\t\tvar->transp.offset = 24;\n\t\t\tvar->transp.length = 8;\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tvar->red.msb_right = 0;\n\t\tvar->green.msb_right = 0;\n\t\tvar->blue.msb_right = 0;\n\t\tvar->transp.msb_right = 0;\n\t}\n\n\t \n\tif (var->xres_virtual * var->yres_virtual * var->bits_per_pixel / 8 >\n\t    info->fix.smem_len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \n\nstatic ssize_t\noverlay_alpha_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\n\treturn sysfs_emit(buf, \"%u\\n\", ovl->alpha);\n}\n\nstatic ssize_t\noverlay_alpha_store(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\tunsigned int alpha;\n\tchar *endp;\n\n\talpha = simple_strtoul(buf, &endp, 10);\n\tif (isspace(*endp))\n\t\tendp++;\n\n\tif (endp - buf != count)\n\t\treturn -EINVAL;\n\n\tif (alpha > 255)\n\t\treturn -EINVAL;\n\n\tif (ovl->alpha != alpha) {\n\t\tovl->alpha = alpha;\n\n\t\tif (ovl->mode == LCDC_OVERLAY_BLEND && ovl->enabled)\n\t\t\tsh_mobile_lcdc_overlay_setup(ovl);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t\noverlay_mode_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\n\treturn sysfs_emit(buf, \"%u\\n\", ovl->mode);\n}\n\nstatic ssize_t\noverlay_mode_store(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\tunsigned int mode;\n\tchar *endp;\n\n\tmode = simple_strtoul(buf, &endp, 10);\n\tif (isspace(*endp))\n\t\tendp++;\n\n\tif (endp - buf != count)\n\t\treturn -EINVAL;\n\n\tif (mode != LCDC_OVERLAY_BLEND && mode != LCDC_OVERLAY_ROP3)\n\t\treturn -EINVAL;\n\n\tif (ovl->mode != mode) {\n\t\tovl->mode = mode;\n\n\t\tif (ovl->enabled)\n\t\t\tsh_mobile_lcdc_overlay_setup(ovl);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t\noverlay_position_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\n\treturn sysfs_emit(buf, \"%d,%d\\n\", ovl->pos_x, ovl->pos_y);\n}\n\nstatic ssize_t\noverlay_position_store(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\tchar *endp;\n\tint pos_x;\n\tint pos_y;\n\n\tpos_x = simple_strtol(buf, &endp, 10);\n\tif (*endp != ',')\n\t\treturn -EINVAL;\n\n\tpos_y = simple_strtol(endp + 1, &endp, 10);\n\tif (isspace(*endp))\n\t\tendp++;\n\n\tif (endp - buf != count)\n\t\treturn -EINVAL;\n\n\tif (ovl->pos_x != pos_x || ovl->pos_y != pos_y) {\n\t\tovl->pos_x = pos_x;\n\t\tovl->pos_y = pos_y;\n\n\t\tif (ovl->enabled)\n\t\t\tsh_mobile_lcdc_overlay_setup(ovl);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t\noverlay_rop3_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\n\treturn sysfs_emit(buf, \"%u\\n\", ovl->rop3);\n}\n\nstatic ssize_t\noverlay_rop3_store(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\tunsigned int rop3;\n\tchar *endp;\n\n\trop3 = simple_strtoul(buf, &endp, 10);\n\tif (isspace(*endp))\n\t\tendp++;\n\n\tif (endp - buf != count)\n\t\treturn -EINVAL;\n\n\tif (rop3 > 255)\n\t\treturn -EINVAL;\n\n\tif (ovl->rop3 != rop3) {\n\t\tovl->rop3 = rop3;\n\n\t\tif (ovl->mode == LCDC_OVERLAY_ROP3 && ovl->enabled)\n\t\t\tsh_mobile_lcdc_overlay_setup(ovl);\n\t}\n\n\treturn count;\n}\n\nstatic const struct device_attribute overlay_sysfs_attrs[] = {\n\t__ATTR(ovl_alpha, S_IRUGO|S_IWUSR,\n\t       overlay_alpha_show, overlay_alpha_store),\n\t__ATTR(ovl_mode, S_IRUGO|S_IWUSR,\n\t       overlay_mode_show, overlay_mode_store),\n\t__ATTR(ovl_position, S_IRUGO|S_IWUSR,\n\t       overlay_position_show, overlay_position_store),\n\t__ATTR(ovl_rop3, S_IRUGO|S_IWUSR,\n\t       overlay_rop3_show, overlay_rop3_store),\n};\n\nstatic const struct fb_fix_screeninfo sh_mobile_lcdc_overlay_fix  = {\n\t.id =\t\t\"SH Mobile LCDC\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_TRUECOLOR,\n\t.accel =\tFB_ACCEL_NONE,\n\t.xpanstep =\t1,\n\t.ypanstep =\t1,\n\t.ywrapstep =\t0,\n\t.capabilities =\tFB_CAP_FOURCC,\n};\n\nstatic int sh_mobile_lcdc_overlay_pan(struct fb_var_screeninfo *var,\n\t\t\t\t    struct fb_info *info)\n{\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\tunsigned long base_addr_y;\n\tunsigned long base_addr_c;\n\tunsigned long y_offset;\n\tunsigned long c_offset;\n\n\tif (!ovl->format->yuv) {\n\t\ty_offset = (var->yoffset * ovl->xres_virtual + var->xoffset)\n\t\t\t * ovl->format->bpp / 8;\n\t\tc_offset = 0;\n\t} else {\n\t\tunsigned int xsub = ovl->format->bpp < 24 ? 2 : 1;\n\t\tunsigned int ysub = ovl->format->bpp < 16 ? 2 : 1;\n\n\t\ty_offset = var->yoffset * ovl->xres_virtual + var->xoffset;\n\t\tc_offset = var->yoffset / ysub * ovl->xres_virtual * 2 / xsub\n\t\t\t + var->xoffset * 2 / xsub;\n\t}\n\n\t \n\tif (y_offset == ovl->pan_y_offset)\n\t\treturn 0;\n\n\t \n\tbase_addr_y = ovl->dma_handle + y_offset;\n\tbase_addr_c = ovl->dma_handle + ovl->xres_virtual * ovl->yres_virtual\n\t\t    + c_offset;\n\n\tovl->base_addr_y = base_addr_y;\n\tovl->base_addr_c = base_addr_c;\n\tovl->pan_y_offset = y_offset;\n\n\tlcdc_write(ovl->channel->lcdc, LDBCR, LDBCR_UPC(ovl->index));\n\n\tlcdc_write_overlay(ovl, LDBnBSAYR(ovl->index), ovl->base_addr_y);\n\tlcdc_write_overlay(ovl, LDBnBSACR(ovl->index), ovl->base_addr_c);\n\n\tlcdc_write(ovl->channel->lcdc, LDBCR,\n\t\t   LDBCR_UPF(ovl->index) | LDBCR_UPD(ovl->index));\n\n\treturn 0;\n}\n\nstatic int sh_mobile_lcdc_overlay_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\t\t      unsigned long arg)\n{\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\n\tswitch (cmd) {\n\tcase FBIO_WAITFORVSYNC:\n\t\treturn sh_mobile_lcdc_wait_for_vsync(ovl->channel);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic int sh_mobile_lcdc_overlay_check_var(struct fb_var_screeninfo *var,\n\t\t\t\t\t  struct fb_info *info)\n{\n\treturn __sh_mobile_lcdc_check_var(var, info);\n}\n\nstatic int sh_mobile_lcdc_overlay_set_par(struct fb_info *info)\n{\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\n\tovl->format =\n\t\tsh_mobile_format_info(sh_mobile_format_fourcc(&info->var));\n\n\tovl->xres = info->var.xres;\n\tovl->xres_virtual = info->var.xres_virtual;\n\tovl->yres = info->var.yres;\n\tovl->yres_virtual = info->var.yres_virtual;\n\n\tif (ovl->format->yuv)\n\t\tovl->pitch = info->var.xres_virtual;\n\telse\n\t\tovl->pitch = info->var.xres_virtual * ovl->format->bpp / 8;\n\n\tsh_mobile_lcdc_overlay_setup(ovl);\n\n\tinfo->fix.line_length = ovl->pitch;\n\n\tif (sh_mobile_format_is_fourcc(&info->var)) {\n\t\tinfo->fix.type = FB_TYPE_FOURCC;\n\t\tinfo->fix.visual = FB_VISUAL_FOURCC;\n\t} else {\n\t\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sh_mobile_lcdc_overlay_blank(int blank, struct fb_info *info)\n{\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\n\tovl->enabled = !blank;\n\tsh_mobile_lcdc_overlay_setup(ovl);\n\n\t \n\treturn 1;\n}\n\nstatic int\nsh_mobile_lcdc_overlay_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct sh_mobile_lcdc_overlay *ovl = info->par;\n\n\tif (info->fbdefio)\n\t\treturn fb_deferred_io_mmap(info, vma);\n\n\treturn dma_mmap_coherent(ovl->channel->lcdc->dev, vma, ovl->fb_mem,\n\t\t\t\t ovl->dma_handle, ovl->fb_size);\n}\n\nstatic const struct fb_ops sh_mobile_lcdc_overlay_ops = {\n\t.owner          = THIS_MODULE,\n\t.fb_read        = fb_sys_read,\n\t.fb_write       = fb_sys_write,\n\t.fb_fillrect\t= sys_fillrect,\n\t.fb_copyarea\t= sys_copyarea,\n\t.fb_imageblit\t= sys_imageblit,\n\t.fb_blank\t= sh_mobile_lcdc_overlay_blank,\n\t.fb_pan_display = sh_mobile_lcdc_overlay_pan,\n\t.fb_ioctl       = sh_mobile_lcdc_overlay_ioctl,\n\t.fb_check_var\t= sh_mobile_lcdc_overlay_check_var,\n\t.fb_set_par\t= sh_mobile_lcdc_overlay_set_par,\n\t.fb_mmap\t= sh_mobile_lcdc_overlay_mmap,\n};\n\nstatic void\nsh_mobile_lcdc_overlay_fb_unregister(struct sh_mobile_lcdc_overlay *ovl)\n{\n\tstruct fb_info *info = ovl->info;\n\n\tif (info == NULL || info->dev == NULL)\n\t\treturn;\n\n\tunregister_framebuffer(ovl->info);\n}\n\nstatic int\nsh_mobile_lcdc_overlay_fb_register(struct sh_mobile_lcdc_overlay *ovl)\n{\n\tstruct sh_mobile_lcdc_priv *lcdc = ovl->channel->lcdc;\n\tstruct fb_info *info = ovl->info;\n\tunsigned int i;\n\tint ret;\n\n\tif (info == NULL)\n\t\treturn 0;\n\n\tret = register_framebuffer(info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(lcdc->dev, \"registered %s/overlay %u as %dx%d %dbpp.\\n\",\n\t\t dev_name(lcdc->dev), ovl->index, info->var.xres,\n\t\t info->var.yres, info->var.bits_per_pixel);\n\n\tfor (i = 0; i < ARRAY_SIZE(overlay_sysfs_attrs); ++i) {\n\t\tret = device_create_file(info->dev, &overlay_sysfs_attrs[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nsh_mobile_lcdc_overlay_fb_cleanup(struct sh_mobile_lcdc_overlay *ovl)\n{\n\tstruct fb_info *info = ovl->info;\n\n\tif (info == NULL || info->device == NULL)\n\t\treturn;\n\n\tframebuffer_release(info);\n}\n\nstatic int\nsh_mobile_lcdc_overlay_fb_init(struct sh_mobile_lcdc_overlay *ovl)\n{\n\tstruct sh_mobile_lcdc_priv *priv = ovl->channel->lcdc;\n\tstruct fb_var_screeninfo *var;\n\tstruct fb_info *info;\n\n\t \n\tinfo = framebuffer_alloc(0, priv->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tovl->info = info;\n\n\tinfo->fbops = &sh_mobile_lcdc_overlay_ops;\n\tinfo->device = priv->dev;\n\tinfo->screen_buffer = ovl->fb_mem;\n\tinfo->par = ovl;\n\n\t \n\tinfo->fix = sh_mobile_lcdc_overlay_fix;\n\tsnprintf(info->fix.id, sizeof(info->fix.id),\n\t\t \"SH Mobile LCDC Overlay %u\", ovl->index);\n\tinfo->fix.smem_start = ovl->dma_handle;\n\tinfo->fix.smem_len = ovl->fb_size;\n\tinfo->fix.line_length = ovl->pitch;\n\n\tif (ovl->format->yuv)\n\t\tinfo->fix.visual = FB_VISUAL_FOURCC;\n\telse\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\n\tswitch (ovl->format->fourcc) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\tinfo->fix.ypanstep = 2;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\t\tinfo->fix.xpanstep = 2;\n\t}\n\n\t \n\tvar = &info->var;\n\tmemset(var, 0, sizeof(*var));\n\tvar->xres = ovl->xres;\n\tvar->yres = ovl->yres;\n\tvar->xres_virtual = ovl->xres_virtual;\n\tvar->yres_virtual = ovl->yres_virtual;\n\tvar->activate = FB_ACTIVATE_NOW;\n\n\t \n\tif (!ovl->format->yuv)\n\t\tvar->bits_per_pixel = ovl->format->bpp;\n\telse\n\t\tvar->grayscale = ovl->format->fourcc;\n\n\treturn sh_mobile_lcdc_overlay_check_var(var, info);\n}\n\n \n\nstatic int sh_mobile_lcdc_setcolreg(u_int regno,\n\t\t\t\t    u_int red, u_int green, u_int blue,\n\t\t\t\t    u_int transp, struct fb_info *info)\n{\n\tu32 *palette = info->pseudo_palette;\n\n\tif (regno >= PALETTE_NR)\n\t\treturn -EINVAL;\n\n\t \n\n\tred >>= 16 - info->var.red.length;\n\tgreen >>= 16 - info->var.green.length;\n\tblue >>= 16 - info->var.blue.length;\n\ttransp >>= 16 - info->var.transp.length;\n\n\tpalette[regno] = (red << info->var.red.offset) |\n\t  (green << info->var.green.offset) |\n\t  (blue << info->var.blue.offset) |\n\t  (transp << info->var.transp.offset);\n\n\treturn 0;\n}\n\nstatic const struct fb_fix_screeninfo sh_mobile_lcdc_fix  = {\n\t.id =\t\t\"SH Mobile LCDC\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_TRUECOLOR,\n\t.accel =\tFB_ACCEL_NONE,\n\t.xpanstep =\t1,\n\t.ypanstep =\t1,\n\t.ywrapstep =\t0,\n\t.capabilities =\tFB_CAP_FOURCC,\n};\n\nstatic void sh_mobile_lcdc_fillrect(struct fb_info *info,\n\t\t\t\t    const struct fb_fillrect *rect)\n{\n\tsys_fillrect(info, rect);\n\tsh_mobile_lcdc_deferred_io_touch(info);\n}\n\nstatic void sh_mobile_lcdc_copyarea(struct fb_info *info,\n\t\t\t\t    const struct fb_copyarea *area)\n{\n\tsys_copyarea(info, area);\n\tsh_mobile_lcdc_deferred_io_touch(info);\n}\n\nstatic void sh_mobile_lcdc_imageblit(struct fb_info *info,\n\t\t\t\t     const struct fb_image *image)\n{\n\tsys_imageblit(info, image);\n\tsh_mobile_lcdc_deferred_io_touch(info);\n}\n\nstatic int sh_mobile_lcdc_pan(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct sh_mobile_lcdc_chan *ch = info->par;\n\tstruct sh_mobile_lcdc_priv *priv = ch->lcdc;\n\tunsigned long ldrcntr;\n\tunsigned long base_addr_y, base_addr_c;\n\tunsigned long y_offset;\n\tunsigned long c_offset;\n\n\tif (!ch->format->yuv) {\n\t\ty_offset = (var->yoffset * ch->xres_virtual + var->xoffset)\n\t\t\t * ch->format->bpp / 8;\n\t\tc_offset = 0;\n\t} else {\n\t\tunsigned int xsub = ch->format->bpp < 24 ? 2 : 1;\n\t\tunsigned int ysub = ch->format->bpp < 16 ? 2 : 1;\n\n\t\ty_offset = var->yoffset * ch->xres_virtual + var->xoffset;\n\t\tc_offset = var->yoffset / ysub * ch->xres_virtual * 2 / xsub\n\t\t\t + var->xoffset * 2 / xsub;\n\t}\n\n\t \n\tif (y_offset == ch->pan_y_offset)\n\t\treturn 0;\n\n\t \n\tbase_addr_y = ch->dma_handle + y_offset;\n\tbase_addr_c = ch->dma_handle + ch->xres_virtual * ch->yres_virtual\n\t\t    + c_offset;\n\n\tch->base_addr_y = base_addr_y;\n\tch->base_addr_c = base_addr_c;\n\tch->pan_y_offset = y_offset;\n\n\tlcdc_write_chan_mirror(ch, LDSA1R, base_addr_y);\n\tif (ch->format->yuv)\n\t\tlcdc_write_chan_mirror(ch, LDSA2R, base_addr_c);\n\n\tldrcntr = lcdc_read(priv, _LDRCNTR);\n\tif (lcdc_chan_is_sublcd(ch))\n\t\tlcdc_write(ch->lcdc, _LDRCNTR, ldrcntr ^ LDRCNTR_SRS);\n\telse\n\t\tlcdc_write(ch->lcdc, _LDRCNTR, ldrcntr ^ LDRCNTR_MRS);\n\n\n\tsh_mobile_lcdc_deferred_io_touch(info);\n\n\treturn 0;\n}\n\nstatic int sh_mobile_lcdc_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct sh_mobile_lcdc_chan *ch = info->par;\n\tint retval;\n\n\tswitch (cmd) {\n\tcase FBIO_WAITFORVSYNC:\n\t\tretval = sh_mobile_lcdc_wait_for_vsync(ch);\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\treturn retval;\n}\n\nstatic void sh_mobile_fb_reconfig(struct fb_info *info)\n{\n\tstruct sh_mobile_lcdc_chan *ch = info->par;\n\tstruct fb_var_screeninfo var;\n\tstruct fb_videomode mode;\n\n\tif (ch->use_count > 1 || (ch->use_count == 1 && !info->fbcon_par))\n\t\t \n\t\treturn;\n\n\tfb_var_to_videomode(&mode, &info->var);\n\n\tif (fb_mode_is_equal(&ch->display.mode, &mode))\n\t\treturn;\n\n\t \n\tvar = info->var;\n\tfb_videomode_to_var(&var, &ch->display.mode);\n\tvar.width = ch->display.width;\n\tvar.height = ch->display.height;\n\tvar.activate = FB_ACTIVATE_NOW;\n\n\tif (fb_set_var(info, &var) < 0)\n\t\t \n\t\treturn;\n\n\tfbcon_update_vcs(info, true);\n}\n\n \nstatic int sh_mobile_lcdc_release(struct fb_info *info, int user)\n{\n\tstruct sh_mobile_lcdc_chan *ch = info->par;\n\n\tmutex_lock(&ch->open_lock);\n\tdev_dbg(info->dev, \"%s(): %d users\\n\", __func__, ch->use_count);\n\n\tch->use_count--;\n\n\t \n\tif (user) {\n\t\tconsole_lock();\n\t\tsh_mobile_fb_reconfig(info);\n\t\tconsole_unlock();\n\t}\n\n\tmutex_unlock(&ch->open_lock);\n\n\treturn 0;\n}\n\nstatic int sh_mobile_lcdc_open(struct fb_info *info, int user)\n{\n\tstruct sh_mobile_lcdc_chan *ch = info->par;\n\n\tmutex_lock(&ch->open_lock);\n\tch->use_count++;\n\n\tdev_dbg(info->dev, \"%s(): %d users\\n\", __func__, ch->use_count);\n\tmutex_unlock(&ch->open_lock);\n\n\treturn 0;\n}\n\nstatic int sh_mobile_lcdc_check_var(struct fb_var_screeninfo *var,\n\t\t\t\t    struct fb_info *info)\n{\n\tstruct sh_mobile_lcdc_chan *ch = info->par;\n\tstruct sh_mobile_lcdc_priv *p = ch->lcdc;\n\tunsigned int best_dist = (unsigned int)-1;\n\tunsigned int best_xres = 0;\n\tunsigned int best_yres = 0;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < ch->cfg->num_modes; ++i) {\n\t\tconst struct fb_videomode *mode = &ch->cfg->lcd_modes[i];\n\t\tunsigned int dist;\n\n\t\t \n\t\tif (var->xres > mode->xres || var->yres > mode->yres)\n\t\t\tcontinue;\n\n\t\tdist = var->xres * var->yres + mode->xres * mode->yres\n\t\t     - 2 * min(var->xres, mode->xres)\n\t\t\t * min(var->yres, mode->yres);\n\n\t\tif (dist < best_dist) {\n\t\t\tbest_xres = mode->xres;\n\t\t\tbest_yres = mode->yres;\n\t\t\tbest_dist = dist;\n\t\t}\n\t}\n\n\t \n\tif (ch->cfg->num_modes != 0) {\n\t\tif (best_dist == (unsigned int)-1)\n\t\t\treturn -EINVAL;\n\n\t\tvar->xres = best_xres;\n\t\tvar->yres = best_yres;\n\t}\n\n\tret = __sh_mobile_lcdc_check_var(var, info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (p->forced_fourcc &&\n\t    p->forced_fourcc != sh_mobile_format_fourcc(var))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sh_mobile_lcdc_set_par(struct fb_info *info)\n{\n\tstruct sh_mobile_lcdc_chan *ch = info->par;\n\tint ret;\n\n\tsh_mobile_lcdc_stop(ch->lcdc);\n\n\tch->format = sh_mobile_format_info(sh_mobile_format_fourcc(&info->var));\n\tch->colorspace = info->var.colorspace;\n\n\tch->xres = info->var.xres;\n\tch->xres_virtual = info->var.xres_virtual;\n\tch->yres = info->var.yres;\n\tch->yres_virtual = info->var.yres_virtual;\n\n\tif (ch->format->yuv)\n\t\tch->pitch = info->var.xres_virtual;\n\telse\n\t\tch->pitch = info->var.xres_virtual * ch->format->bpp / 8;\n\n\tret = sh_mobile_lcdc_start(ch->lcdc);\n\tif (ret < 0)\n\t\tdev_err(info->dev, \"%s: unable to restart LCDC\\n\", __func__);\n\n\tinfo->fix.line_length = ch->pitch;\n\n\tif (sh_mobile_format_is_fourcc(&info->var)) {\n\t\tinfo->fix.type = FB_TYPE_FOURCC;\n\t\tinfo->fix.visual = FB_VISUAL_FOURCC;\n\t} else {\n\t\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sh_mobile_lcdc_blank(int blank, struct fb_info *info)\n{\n\tstruct sh_mobile_lcdc_chan *ch = info->par;\n\tstruct sh_mobile_lcdc_priv *p = ch->lcdc;\n\n\t \n\tif (blank > FB_BLANK_UNBLANK && ch->blank_status == FB_BLANK_UNBLANK) {\n\t\tstruct fb_fillrect rect = {\n\t\t\t.width = ch->xres,\n\t\t\t.height = ch->yres,\n\t\t};\n\t\tsh_mobile_lcdc_fillrect(info, &rect);\n\t}\n\t \n\tif (blank <= FB_BLANK_NORMAL && ch->blank_status > FB_BLANK_NORMAL) {\n\t\tsh_mobile_lcdc_clk_on(p);\n\t}\n\t \n\tif (blank > FB_BLANK_NORMAL && ch->blank_status <= FB_BLANK_NORMAL) {\n\t\t \n\t\tif (!info->fbdefio) {\n\t\t\tsh_mobile_lcdc_wait_for_vsync(ch);\n\t\t\tsh_mobile_lcdc_wait_for_vsync(ch);\n\t\t}\n\t\tsh_mobile_lcdc_clk_off(p);\n\t}\n\n\tch->blank_status = blank;\n\treturn 0;\n}\n\nstatic int\nsh_mobile_lcdc_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct sh_mobile_lcdc_chan *ch = info->par;\n\n\tif (info->fbdefio)\n\t\treturn fb_deferred_io_mmap(info, vma);\n\n\treturn dma_mmap_coherent(ch->lcdc->dev, vma, ch->fb_mem,\n\t\t\t\t ch->dma_handle, ch->fb_size);\n}\n\nstatic const struct fb_ops sh_mobile_lcdc_ops = {\n\t.owner          = THIS_MODULE,\n\t.fb_setcolreg\t= sh_mobile_lcdc_setcolreg,\n\t.fb_read        = fb_sys_read,\n\t.fb_write       = fb_sys_write,\n\t.fb_fillrect\t= sh_mobile_lcdc_fillrect,\n\t.fb_copyarea\t= sh_mobile_lcdc_copyarea,\n\t.fb_imageblit\t= sh_mobile_lcdc_imageblit,\n\t.fb_blank\t= sh_mobile_lcdc_blank,\n\t.fb_pan_display = sh_mobile_lcdc_pan,\n\t.fb_ioctl       = sh_mobile_lcdc_ioctl,\n\t.fb_open\t= sh_mobile_lcdc_open,\n\t.fb_release\t= sh_mobile_lcdc_release,\n\t.fb_check_var\t= sh_mobile_lcdc_check_var,\n\t.fb_set_par\t= sh_mobile_lcdc_set_par,\n\t.fb_mmap\t= sh_mobile_lcdc_mmap,\n};\n\nstatic void\nsh_mobile_lcdc_channel_fb_unregister(struct sh_mobile_lcdc_chan *ch)\n{\n\tif (ch->info && ch->info->dev)\n\t\tunregister_framebuffer(ch->info);\n}\n\nstatic int\nsh_mobile_lcdc_channel_fb_register(struct sh_mobile_lcdc_chan *ch)\n{\n\tstruct fb_info *info = ch->info;\n\tint ret;\n\n\tif (info->fbdefio) {\n\t\tch->sglist = vmalloc(sizeof(struct scatterlist) *\n\t\t\t\t     ch->fb_size >> PAGE_SHIFT);\n\t\tif (!ch->sglist)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tinfo->bl_dev = ch->bl;\n\n\tret = register_framebuffer(info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(ch->lcdc->dev, \"registered %s/%s as %dx%d %dbpp.\\n\",\n\t\t dev_name(ch->lcdc->dev), (ch->cfg->chan == LCDC_CHAN_MAINLCD) ?\n\t\t \"mainlcd\" : \"sublcd\", info->var.xres, info->var.yres,\n\t\t info->var.bits_per_pixel);\n\n\t \n\tif (info->fbdefio || info->state == FBINFO_STATE_SUSPENDED)\n\t\tsh_mobile_lcdc_clk_off(ch->lcdc);\n\n\treturn ret;\n}\n\nstatic void\nsh_mobile_lcdc_channel_fb_cleanup(struct sh_mobile_lcdc_chan *ch)\n{\n\tstruct fb_info *info = ch->info;\n\n\tif (!info || !info->device)\n\t\treturn;\n\n\tvfree(ch->sglist);\n\n\tfb_dealloc_cmap(&info->cmap);\n\tframebuffer_release(info);\n}\n\nstatic int\nsh_mobile_lcdc_channel_fb_init(struct sh_mobile_lcdc_chan *ch,\n\t\t\t       const struct fb_videomode *modes,\n\t\t\t       unsigned int num_modes)\n{\n\tstruct sh_mobile_lcdc_priv *priv = ch->lcdc;\n\tstruct fb_var_screeninfo *var;\n\tstruct fb_info *info;\n\tint ret;\n\n\t \n\tinfo = framebuffer_alloc(0, priv->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tch->info = info;\n\n\tinfo->fbops = &sh_mobile_lcdc_ops;\n\tinfo->device = priv->dev;\n\tinfo->screen_buffer = ch->fb_mem;\n\tinfo->pseudo_palette = &ch->pseudo_palette;\n\tinfo->par = ch;\n\n\tfb_videomode_to_modelist(modes, num_modes, &info->modelist);\n\n\tret = fb_alloc_cmap(&info->cmap, PALETTE_NR, 0);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"unable to allocate cmap\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tinfo->fix = sh_mobile_lcdc_fix;\n\tinfo->fix.smem_start = ch->dma_handle;\n\tinfo->fix.smem_len = ch->fb_size;\n\tinfo->fix.line_length = ch->pitch;\n\n\tif (ch->format->yuv)\n\t\tinfo->fix.visual = FB_VISUAL_FOURCC;\n\telse\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\n\tswitch (ch->format->fourcc) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\tinfo->fix.ypanstep = 2;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\t\tinfo->fix.xpanstep = 2;\n\t}\n\n\t \n\tvar = &info->var;\n\tfb_videomode_to_var(var, modes);\n\tvar->width = ch->display.width;\n\tvar->height = ch->display.height;\n\tvar->xres_virtual = ch->xres_virtual;\n\tvar->yres_virtual = ch->yres_virtual;\n\tvar->activate = FB_ACTIVATE_NOW;\n\n\t \n\tif (!ch->format->yuv)\n\t\tvar->bits_per_pixel = ch->format->bpp;\n\telse\n\t\tvar->grayscale = ch->format->fourcc;\n\n\tret = sh_mobile_lcdc_check_var(var, info);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \n\nstatic int sh_mobile_lcdc_update_bl(struct backlight_device *bdev)\n{\n\tstruct sh_mobile_lcdc_chan *ch = bl_get_data(bdev);\n\tint brightness = bdev->props.brightness;\n\n\tif (bdev->props.power != FB_BLANK_UNBLANK ||\n\t    bdev->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK))\n\t\tbrightness = 0;\n\n\tch->bl_brightness = brightness;\n\treturn ch->cfg->bl_info.set_brightness(brightness);\n}\n\nstatic int sh_mobile_lcdc_get_brightness(struct backlight_device *bdev)\n{\n\tstruct sh_mobile_lcdc_chan *ch = bl_get_data(bdev);\n\n\treturn ch->bl_brightness;\n}\n\nstatic int sh_mobile_lcdc_check_fb(struct backlight_device *bdev,\n\t\t\t\t   struct fb_info *info)\n{\n\treturn (info->bl_dev == bdev);\n}\n\nstatic const struct backlight_ops sh_mobile_lcdc_bl_ops = {\n\t.options\t= BL_CORE_SUSPENDRESUME,\n\t.update_status\t= sh_mobile_lcdc_update_bl,\n\t.get_brightness\t= sh_mobile_lcdc_get_brightness,\n\t.check_fb\t= sh_mobile_lcdc_check_fb,\n};\n\nstatic struct backlight_device *sh_mobile_lcdc_bl_probe(struct device *parent,\n\t\t\t\t\t       struct sh_mobile_lcdc_chan *ch)\n{\n\tstruct backlight_device *bl;\n\n\tbl = backlight_device_register(ch->cfg->bl_info.name, parent, ch,\n\t\t\t\t       &sh_mobile_lcdc_bl_ops, NULL);\n\tif (IS_ERR(bl)) {\n\t\tdev_err(parent, \"unable to register backlight device: %ld\\n\",\n\t\t\tPTR_ERR(bl));\n\t\treturn NULL;\n\t}\n\n\tbl->props.max_brightness = ch->cfg->bl_info.max_brightness;\n\tbl->props.brightness = bl->props.max_brightness;\n\tbacklight_update_status(bl);\n\n\treturn bl;\n}\n\nstatic void sh_mobile_lcdc_bl_remove(struct backlight_device *bdev)\n{\n\tbacklight_device_unregister(bdev);\n}\n\n \n\nstatic int sh_mobile_lcdc_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tsh_mobile_lcdc_stop(platform_get_drvdata(pdev));\n\treturn 0;\n}\n\nstatic int sh_mobile_lcdc_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\treturn sh_mobile_lcdc_start(platform_get_drvdata(pdev));\n}\n\nstatic int sh_mobile_lcdc_runtime_suspend(struct device *dev)\n{\n\tstruct sh_mobile_lcdc_priv *priv = dev_get_drvdata(dev);\n\n\t \n\tlcdc_write(priv, _LDCNT1R, 0);\n\n\treturn 0;\n}\n\nstatic int sh_mobile_lcdc_runtime_resume(struct device *dev)\n{\n\tstruct sh_mobile_lcdc_priv *priv = dev_get_drvdata(dev);\n\n\t__sh_mobile_lcdc_start(priv);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops sh_mobile_lcdc_dev_pm_ops = {\n\t.suspend = sh_mobile_lcdc_suspend,\n\t.resume = sh_mobile_lcdc_resume,\n\t.runtime_suspend = sh_mobile_lcdc_runtime_suspend,\n\t.runtime_resume = sh_mobile_lcdc_runtime_resume,\n};\n\n \n\n \n\nstatic const struct fb_videomode default_720p = {\n\t.name = \"HDMI 720p\",\n\t.xres = 1280,\n\t.yres = 720,\n\n\t.left_margin = 220,\n\t.right_margin = 110,\n\t.hsync_len = 40,\n\n\t.upper_margin = 20,\n\t.lower_margin = 5,\n\t.vsync_len = 5,\n\n\t.pixclock = 13468,\n\t.refresh = 60,\n\t.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,\n};\n\nstatic void sh_mobile_lcdc_remove(struct platform_device *pdev)\n{\n\tstruct sh_mobile_lcdc_priv *priv = platform_get_drvdata(pdev);\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->overlays); i++)\n\t\tsh_mobile_lcdc_overlay_fb_unregister(&priv->overlays[i]);\n\tfor (i = 0; i < ARRAY_SIZE(priv->ch); i++)\n\t\tsh_mobile_lcdc_channel_fb_unregister(&priv->ch[i]);\n\n\tsh_mobile_lcdc_stop(priv);\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->overlays); i++) {\n\t\tstruct sh_mobile_lcdc_overlay *ovl = &priv->overlays[i];\n\n\t\tsh_mobile_lcdc_overlay_fb_cleanup(ovl);\n\n\t\tif (ovl->fb_mem)\n\t\t\tdma_free_coherent(&pdev->dev, ovl->fb_size,\n\t\t\t\t\t  ovl->fb_mem, ovl->dma_handle);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->ch); i++) {\n\t\tstruct sh_mobile_lcdc_chan *ch = &priv->ch[i];\n\n\t\tif (ch->tx_dev) {\n\t\t\tch->tx_dev->lcdc = NULL;\n\t\t\tmodule_put(ch->cfg->tx_dev->dev.driver->owner);\n\t\t}\n\n\t\tsh_mobile_lcdc_channel_fb_cleanup(ch);\n\n\t\tif (ch->fb_mem)\n\t\t\tdma_free_coherent(&pdev->dev, ch->fb_size,\n\t\t\t\t\t  ch->fb_mem, ch->dma_handle);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->ch); i++) {\n\t\tstruct sh_mobile_lcdc_chan *ch = &priv->ch[i];\n\n\t\tif (ch->bl)\n\t\t\tsh_mobile_lcdc_bl_remove(ch->bl);\n\t\tmutex_destroy(&ch->open_lock);\n\t}\n\n\tif (priv->dot_clk) {\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tclk_put(priv->dot_clk);\n\t}\n\n\tif (priv->base)\n\t\tiounmap(priv->base);\n\n\tif (priv->irq)\n\t\tfree_irq(priv->irq, priv);\n\tkfree(priv);\n}\n\nstatic int sh_mobile_lcdc_check_interface(struct sh_mobile_lcdc_chan *ch)\n{\n\tint interface_type = ch->cfg->interface_type;\n\n\tswitch (interface_type) {\n\tcase RGB8:\n\tcase RGB9:\n\tcase RGB12A:\n\tcase RGB12B:\n\tcase RGB16:\n\tcase RGB18:\n\tcase RGB24:\n\tcase SYS8A:\n\tcase SYS8B:\n\tcase SYS8C:\n\tcase SYS8D:\n\tcase SYS9:\n\tcase SYS12:\n\tcase SYS16A:\n\tcase SYS16B:\n\tcase SYS16C:\n\tcase SYS18:\n\tcase SYS24:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (lcdc_chan_is_sublcd(ch)) {\n\t\tif (!(interface_type & LDMT1R_IFM))\n\t\t\treturn -EINVAL;\n\n\t\tinterface_type &= ~LDMT1R_IFM;\n\t}\n\n\tch->ldmt1r_value = interface_type;\n\treturn 0;\n}\n\nstatic int\nsh_mobile_lcdc_overlay_init(struct sh_mobile_lcdc_overlay *ovl)\n{\n\tconst struct sh_mobile_lcdc_format_info *format;\n\tstruct device *dev = ovl->channel->lcdc->dev;\n\tint ret;\n\n\tif (ovl->cfg->fourcc == 0)\n\t\treturn 0;\n\n\t \n\tformat = sh_mobile_format_info(ovl->cfg->fourcc);\n\tif (format == NULL) {\n\t\tdev_err(dev, \"Invalid FOURCC %08x\\n\", ovl->cfg->fourcc);\n\t\treturn -EINVAL;\n\t}\n\n\tovl->enabled = false;\n\tovl->mode = LCDC_OVERLAY_BLEND;\n\tovl->alpha = 255;\n\tovl->rop3 = 0;\n\tovl->pos_x = 0;\n\tovl->pos_y = 0;\n\n\t \n\tovl->format = format;\n\tovl->xres = ovl->cfg->max_xres;\n\tovl->xres_virtual = ovl->xres;\n\tovl->yres = ovl->cfg->max_yres;\n\tovl->yres_virtual = ovl->yres * 2;\n\n\tif (!format->yuv)\n\t\tovl->pitch = ovl->xres_virtual * format->bpp / 8;\n\telse\n\t\tovl->pitch = ovl->xres_virtual;\n\n\t \n\tovl->fb_size = ovl->cfg->max_xres * ovl->cfg->max_yres\n\t\t       * format->bpp / 8 * 2;\n\tovl->fb_mem = dma_alloc_coherent(dev, ovl->fb_size, &ovl->dma_handle,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ovl->fb_mem) {\n\t\tdev_err(dev, \"unable to allocate buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = sh_mobile_lcdc_overlay_fb_init(ovl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nsh_mobile_lcdc_channel_init(struct sh_mobile_lcdc_chan *ch)\n{\n\tconst struct sh_mobile_lcdc_format_info *format;\n\tconst struct sh_mobile_lcdc_chan_cfg *cfg = ch->cfg;\n\tstruct device *dev = ch->lcdc->dev;\n\tconst struct fb_videomode *max_mode;\n\tconst struct fb_videomode *mode;\n\tunsigned int num_modes;\n\tunsigned int max_size;\n\tunsigned int i;\n\n\t \n\tformat = sh_mobile_format_info(cfg->fourcc);\n\tif (format == NULL) {\n\t\tdev_err(dev, \"Invalid FOURCC %08x.\\n\", cfg->fourcc);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmax_mode = NULL;\n\tmax_size = 0;\n\n\tfor (i = 0, mode = cfg->lcd_modes; i < cfg->num_modes; i++, mode++) {\n\t\tunsigned int size = mode->yres * mode->xres;\n\n\t\t \n\t\tif ((cfg->fourcc == V4L2_PIX_FMT_NV12 ||\n\t\t     cfg->fourcc == V4L2_PIX_FMT_NV21) && (mode->yres & 0x1)) {\n\t\t\tdev_err(dev, \"yres must be multiple of 2 for \"\n\t\t\t\t\"YCbCr420 mode.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (size > max_size) {\n\t\t\tmax_mode = mode;\n\t\t\tmax_size = size;\n\t\t}\n\t}\n\n\tif (!max_size)\n\t\tmax_size = MAX_XRES * MAX_YRES;\n\telse\n\t\tdev_dbg(dev, \"Found largest videomode %ux%u\\n\",\n\t\t\tmax_mode->xres, max_mode->yres);\n\n\tif (cfg->lcd_modes == NULL) {\n\t\tmode = &default_720p;\n\t\tnum_modes = 1;\n\t} else {\n\t\tmode = cfg->lcd_modes;\n\t\tnum_modes = cfg->num_modes;\n\t}\n\n\t \n\tch->format = format;\n\tch->xres = mode->xres;\n\tch->xres_virtual = mode->xres;\n\tch->yres = mode->yres;\n\tch->yres_virtual = mode->yres * 2;\n\n\tif (!format->yuv) {\n\t\tch->colorspace = V4L2_COLORSPACE_SRGB;\n\t\tch->pitch = ch->xres_virtual * format->bpp / 8;\n\t} else {\n\t\tch->colorspace = V4L2_COLORSPACE_REC709;\n\t\tch->pitch = ch->xres_virtual;\n\t}\n\n\tch->display.width = cfg->panel_cfg.width;\n\tch->display.height = cfg->panel_cfg.height;\n\tch->display.mode = *mode;\n\n\t \n\tch->fb_size = max_size * format->bpp / 8 * 2;\n\tch->fb_mem = dma_alloc_coherent(dev, ch->fb_size, &ch->dma_handle,\n\t\t\t\t\tGFP_KERNEL);\n\tif (ch->fb_mem == NULL) {\n\t\tdev_err(dev, \"unable to allocate buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (cfg->tx_dev) {\n\t\tif (!cfg->tx_dev->dev.driver ||\n\t\t    !try_module_get(cfg->tx_dev->dev.driver->owner)) {\n\t\t\tdev_warn(dev, \"unable to get transmitter device\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tch->tx_dev = platform_get_drvdata(cfg->tx_dev);\n\t\tch->tx_dev->lcdc = ch;\n\t\tch->tx_dev->def_mode = *mode;\n\t}\n\n\treturn sh_mobile_lcdc_channel_fb_init(ch, mode, num_modes);\n}\n\nstatic int sh_mobile_lcdc_probe(struct platform_device *pdev)\n{\n\tstruct sh_mobile_lcdc_info *pdata = pdev->dev.platform_data;\n\tstruct sh_mobile_lcdc_priv *priv;\n\tstruct resource *res;\n\tint num_channels;\n\tint error;\n\tint irq, i;\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"no platform data defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tirq = platform_get_irq(pdev, 0);\n\tif (!res || irq < 0) {\n\t\tdev_err(&pdev->dev, \"cannot get platform resources\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->ch); i++)\n\t\tmutex_init(&priv->ch[i].open_lock);\n\tplatform_set_drvdata(pdev, priv);\n\n\terror = request_irq(irq, sh_mobile_lcdc_irq, 0,\n\t\t\t    dev_name(&pdev->dev), priv);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"unable to request irq\\n\");\n\t\tgoto err1;\n\t}\n\n\tpriv->irq = irq;\n\tatomic_set(&priv->hw_usecnt, -1);\n\n\tfor (i = 0, num_channels = 0; i < ARRAY_SIZE(pdata->ch); i++) {\n\t\tstruct sh_mobile_lcdc_chan *ch = priv->ch + num_channels;\n\n\t\tch->lcdc = priv;\n\t\tch->cfg = &pdata->ch[i];\n\n\t\terror = sh_mobile_lcdc_check_interface(ch);\n\t\tif (error) {\n\t\t\tdev_err(&pdev->dev, \"unsupported interface type\\n\");\n\t\t\tgoto err1;\n\t\t}\n\t\tinit_waitqueue_head(&ch->frame_end_wait);\n\t\tinit_completion(&ch->vsync_completion);\n\n\t\t \n\t\tif (ch->cfg->bl_info.max_brightness)\n\t\t\tch->bl = sh_mobile_lcdc_bl_probe(&pdev->dev, ch);\n\n\t\tswitch (pdata->ch[i].chan) {\n\t\tcase LCDC_CHAN_MAINLCD:\n\t\t\tch->enabled = LDCNT2R_ME;\n\t\t\tch->reg_offs = lcdc_offs_mainlcd;\n\t\t\tnum_channels++;\n\t\t\tbreak;\n\t\tcase LCDC_CHAN_SUBLCD:\n\t\t\tch->enabled = LDCNT2R_SE;\n\t\t\tch->reg_offs = lcdc_offs_sublcd;\n\t\t\tnum_channels++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!num_channels) {\n\t\tdev_err(&pdev->dev, \"no channels defined\\n\");\n\t\terror = -EINVAL;\n\t\tgoto err1;\n\t}\n\n\t \n\tif (num_channels == 2)\n\t\tpriv->forced_fourcc = pdata->ch[0].fourcc;\n\n\tpriv->base = ioremap(res->start, resource_size(res));\n\tif (!priv->base) {\n\t\terror = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\terror = sh_mobile_lcdc_setup_clocks(priv, pdata->clock_source);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"unable to setup clocks\\n\");\n\t\tgoto err1;\n\t}\n\n\t \n\tpm_runtime_enable(&pdev->dev);\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tstruct sh_mobile_lcdc_chan *ch = &priv->ch[i];\n\n\t\terror = sh_mobile_lcdc_channel_init(ch);\n\t\tif (error)\n\t\t\tgoto err1;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pdata->overlays); i++) {\n\t\tstruct sh_mobile_lcdc_overlay *ovl = &priv->overlays[i];\n\n\t\tovl->cfg = &pdata->overlays[i];\n\t\tovl->channel = &priv->ch[0];\n\n\t\terror = sh_mobile_lcdc_overlay_init(ovl);\n\t\tif (error)\n\t\t\tgoto err1;\n\t}\n\n\terror = sh_mobile_lcdc_start(priv);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"unable to start hardware\\n\");\n\t\tgoto err1;\n\t}\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tstruct sh_mobile_lcdc_chan *ch = priv->ch + i;\n\n\t\terror = sh_mobile_lcdc_channel_fb_register(ch);\n\t\tif (error)\n\t\t\tgoto err1;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pdata->overlays); i++) {\n\t\tstruct sh_mobile_lcdc_overlay *ovl = &priv->overlays[i];\n\n\t\terror = sh_mobile_lcdc_overlay_fb_register(ovl);\n\t\tif (error)\n\t\t\tgoto err1;\n\t}\n\n\treturn 0;\nerr1:\n\tsh_mobile_lcdc_remove(pdev);\n\n\treturn error;\n}\n\nstatic struct platform_driver sh_mobile_lcdc_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"sh_mobile_lcdc_fb\",\n\t\t.pm\t\t= &sh_mobile_lcdc_dev_pm_ops,\n\t},\n\t.probe\t\t= sh_mobile_lcdc_probe,\n\t.remove_new\t= sh_mobile_lcdc_remove,\n};\n\nmodule_platform_driver(sh_mobile_lcdc_driver);\n\nMODULE_DESCRIPTION(\"SuperH Mobile LCDC Framebuffer driver\");\nMODULE_AUTHOR(\"Magnus Damm <damm@opensource.se>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}