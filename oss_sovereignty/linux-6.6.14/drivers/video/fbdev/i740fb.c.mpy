{
  "module_name": "i740fb.c",
  "hash_id": "260d95532ad06d7f145e122c8a16cc168f328f8d8bcf4faa876c53bd3c5a9035",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/i740fb.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/console.h>\n#include <video/vga.h>\n\n#include \"i740_reg.h\"\n\nstatic char *mode_option;\nstatic int mtrr = 1;\n\nstruct i740fb_par {\n\tunsigned char __iomem *regs;\n\tbool has_sgram;\n\tint wc_cookie;\n\tbool ddc_registered;\n\tstruct i2c_adapter ddc_adapter;\n\tstruct i2c_algo_bit_data ddc_algo;\n\tu32 pseudo_palette[16];\n\tstruct mutex open_lock;\n\tunsigned int ref_count;\n\n\tu8 crtc[VGA_CRT_C];\n\tu8 atc[VGA_ATT_C];\n\tu8 gdc[VGA_GFX_C];\n\tu8 seq[VGA_SEQ_C];\n\tu8 misc;\n\tu8 vss;\n\n\t \n\tu8 display_cntl;\n\tu8 pixelpipe_cfg0;\n\tu8 pixelpipe_cfg1;\n\tu8 pixelpipe_cfg2;\n\tu8 video_clk2_m;\n\tu8 video_clk2_n;\n\tu8 video_clk2_mn_msbs;\n\tu8 video_clk2_div_sel;\n\tu8 pll_cntl;\n\tu8 address_mapping;\n\tu8 io_cntl;\n\tu8 bitblt_cntl;\n\tu8 ext_vert_total;\n\tu8 ext_vert_disp_end;\n\tu8 ext_vert_sync_start;\n\tu8 ext_vert_blank_start;\n\tu8 ext_horiz_total;\n\tu8 ext_horiz_blank;\n\tu8 ext_offset;\n\tu8 interlace_cntl;\n\tu32 lmi_fifo_watermark;\n\tu8 ext_start_addr;\n\tu8 ext_start_addr_hi;\n};\n\n#define DACSPEED8\t203\n#define DACSPEED16\t163\n#define DACSPEED24_SG\t136\n#define DACSPEED24_SD\t128\n#define DACSPEED32\t86\n\nstatic const struct fb_fix_screeninfo i740fb_fix = {\n\t.id =\t\t\"i740fb\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_TRUECOLOR,\n\t.xpanstep =\t8,\n\t.ypanstep =\t1,\n\t.accel =\tFB_ACCEL_NONE,\n};\n\nstatic inline void i740outb(struct i740fb_par *par, u16 port, u8 val)\n{\n\tvga_mm_w(par->regs, port, val);\n}\nstatic inline u8 i740inb(struct i740fb_par *par, u16 port)\n{\n\treturn vga_mm_r(par->regs, port);\n}\nstatic inline void i740outreg(struct i740fb_par *par, u16 port, u8 reg, u8 val)\n{\n\tvga_mm_w_fast(par->regs, port, reg, val);\n}\nstatic inline u8 i740inreg(struct i740fb_par *par, u16 port, u8 reg)\n{\n\tvga_mm_w(par->regs, port, reg);\n\treturn vga_mm_r(par->regs, port+1);\n}\nstatic inline void i740outreg_mask(struct i740fb_par *par, u16 port, u8 reg,\n\t\t\t\t   u8 val, u8 mask)\n{\n\tvga_mm_w_fast(par->regs, port, reg, (val & mask)\n\t\t| (i740inreg(par, port, reg) & ~mask));\n}\n\n#define REG_DDC_DRIVE\t0x62\n#define REG_DDC_STATE\t0x63\n#define DDC_SCL\t\t(1 << 3)\n#define DDC_SDA\t\t(1 << 2)\n\nstatic void i740fb_ddc_setscl(void *data, int val)\n{\n\tstruct i740fb_par *par = data;\n\n\ti740outreg_mask(par, XRX, REG_DDC_DRIVE, DDC_SCL, DDC_SCL);\n\ti740outreg_mask(par, XRX, REG_DDC_STATE, val ? DDC_SCL : 0, DDC_SCL);\n}\n\nstatic void i740fb_ddc_setsda(void *data, int val)\n{\n\tstruct i740fb_par *par = data;\n\n\ti740outreg_mask(par, XRX, REG_DDC_DRIVE, DDC_SDA, DDC_SDA);\n\ti740outreg_mask(par, XRX, REG_DDC_STATE, val ? DDC_SDA : 0, DDC_SDA);\n}\n\nstatic int i740fb_ddc_getscl(void *data)\n{\n\tstruct i740fb_par *par = data;\n\n\ti740outreg_mask(par, XRX, REG_DDC_DRIVE, 0, DDC_SCL);\n\n\treturn !!(i740inreg(par, XRX, REG_DDC_STATE) & DDC_SCL);\n}\n\nstatic int i740fb_ddc_getsda(void *data)\n{\n\tstruct i740fb_par *par = data;\n\n\ti740outreg_mask(par, XRX, REG_DDC_DRIVE, 0, DDC_SDA);\n\n\treturn !!(i740inreg(par, XRX, REG_DDC_STATE) & DDC_SDA);\n}\n\nstatic int i740fb_setup_ddc_bus(struct fb_info *info)\n{\n\tstruct i740fb_par *par = info->par;\n\n\tstrscpy(par->ddc_adapter.name, info->fix.id,\n\t\tsizeof(par->ddc_adapter.name));\n\tpar->ddc_adapter.owner\t\t= THIS_MODULE;\n\tpar->ddc_adapter.class\t\t= I2C_CLASS_DDC;\n\tpar->ddc_adapter.algo_data\t= &par->ddc_algo;\n\tpar->ddc_adapter.dev.parent\t= info->device;\n\tpar->ddc_algo.setsda\t\t= i740fb_ddc_setsda;\n\tpar->ddc_algo.setscl\t\t= i740fb_ddc_setscl;\n\tpar->ddc_algo.getsda\t\t= i740fb_ddc_getsda;\n\tpar->ddc_algo.getscl\t\t= i740fb_ddc_getscl;\n\tpar->ddc_algo.udelay\t\t= 10;\n\tpar->ddc_algo.timeout\t\t= 20;\n\tpar->ddc_algo.data\t\t= par;\n\n\ti2c_set_adapdata(&par->ddc_adapter, par);\n\n\treturn i2c_bit_add_bus(&par->ddc_adapter);\n}\n\nstatic int i740fb_open(struct fb_info *info, int user)\n{\n\tstruct i740fb_par *par = info->par;\n\n\tmutex_lock(&(par->open_lock));\n\tpar->ref_count++;\n\tmutex_unlock(&(par->open_lock));\n\n\treturn 0;\n}\n\nstatic int i740fb_release(struct fb_info *info, int user)\n{\n\tstruct i740fb_par *par = info->par;\n\n\tmutex_lock(&(par->open_lock));\n\tif (par->ref_count == 0) {\n\t\tfb_err(info, \"release called with zero refcount\\n\");\n\t\tmutex_unlock(&(par->open_lock));\n\t\treturn -EINVAL;\n\t}\n\n\tpar->ref_count--;\n\tmutex_unlock(&(par->open_lock));\n\n\treturn 0;\n}\n\nstatic u32 i740_calc_fifo(struct i740fb_par *par, u32 freq, int bpp)\n{\n\t \n\n\tu32 wm;\n\n\tswitch (bpp) {\n\tcase 8:\n\t\tif\t(freq > 200)\n\t\t\twm = 0x18120000;\n\t\telse if (freq > 175)\n\t\t\twm = 0x16110000;\n\t\telse if (freq > 135)\n\t\t\twm = 0x120E0000;\n\t\telse\n\t\t\twm = 0x100D0000;\n\t\tbreak;\n\tcase 15:\n\tcase 16:\n\t\tif (par->has_sgram) {\n\t\t\tif\t(freq > 140)\n\t\t\t\twm = 0x2C1D0000;\n\t\t\telse if (freq > 120)\n\t\t\t\twm = 0x2C180000;\n\t\t\telse if (freq > 100)\n\t\t\t\twm = 0x24160000;\n\t\t\telse if (freq >  90)\n\t\t\t\twm = 0x18120000;\n\t\t\telse if (freq >  50)\n\t\t\t\twm = 0x16110000;\n\t\t\telse if (freq >  32)\n\t\t\t\twm = 0x13100000;\n\t\t\telse\n\t\t\t\twm = 0x120E0000;\n\t\t} else {\n\t\t\tif\t(freq > 160)\n\t\t\t\twm = 0x28200000;\n\t\t\telse if (freq > 140)\n\t\t\t\twm = 0x2A1E0000;\n\t\t\telse if (freq > 130)\n\t\t\t\twm = 0x2B1A0000;\n\t\t\telse if (freq > 120)\n\t\t\t\twm = 0x2C180000;\n\t\t\telse if (freq > 100)\n\t\t\t\twm = 0x24180000;\n\t\t\telse if (freq >  90)\n\t\t\t\twm = 0x18120000;\n\t\t\telse if (freq >  50)\n\t\t\t\twm = 0x16110000;\n\t\t\telse if (freq >  32)\n\t\t\t\twm = 0x13100000;\n\t\t\telse\n\t\t\t\twm = 0x120E0000;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tif (par->has_sgram) {\n\t\t\tif\t(freq > 130)\n\t\t\t\twm = 0x31200000;\n\t\t\telse if (freq > 120)\n\t\t\t\twm = 0x2E200000;\n\t\t\telse if (freq > 100)\n\t\t\t\twm = 0x2C1D0000;\n\t\t\telse if (freq >  80)\n\t\t\t\twm = 0x25180000;\n\t\t\telse if (freq >  64)\n\t\t\t\twm = 0x24160000;\n\t\t\telse if (freq >  49)\n\t\t\t\twm = 0x18120000;\n\t\t\telse if (freq >  32)\n\t\t\t\twm = 0x16110000;\n\t\t\telse\n\t\t\t\twm = 0x13100000;\n\t\t} else {\n\t\t\tif\t(freq > 120)\n\t\t\t\twm = 0x311F0000;\n\t\t\telse if (freq > 100)\n\t\t\t\twm = 0x2C1D0000;\n\t\t\telse if (freq >  80)\n\t\t\t\twm = 0x25180000;\n\t\t\telse if (freq >  64)\n\t\t\t\twm = 0x24160000;\n\t\t\telse if (freq >  49)\n\t\t\t\twm = 0x18120000;\n\t\t\telse if (freq >  32)\n\t\t\t\twm = 0x16110000;\n\t\t\telse\n\t\t\t\twm = 0x13100000;\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tif (par->has_sgram) {\n\t\t\tif\t(freq >  80)\n\t\t\t\twm = 0x2A200000;\n\t\t\telse if (freq >  60)\n\t\t\t\twm = 0x281A0000;\n\t\t\telse if (freq >  49)\n\t\t\t\twm = 0x25180000;\n\t\t\telse if (freq >  32)\n\t\t\t\twm = 0x18120000;\n\t\t\telse\n\t\t\t\twm = 0x16110000;\n\t\t} else {\n\t\t\tif\t(freq >  80)\n\t\t\t\twm = 0x29200000;\n\t\t\telse if (freq >  60)\n\t\t\t\twm = 0x281A0000;\n\t\t\telse if (freq >  49)\n\t\t\t\twm = 0x25180000;\n\t\t\telse if (freq >  32)\n\t\t\t\twm = 0x18120000;\n\t\t\telse\n\t\t\t\twm = 0x16110000;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn wm;\n}\n\n \n\n#define I740_RFREQ\t\t1000000\n#define TARGET_MAX_N\t\t30\n#define I740_FFIX\t\t(1 << 8)\n#define I740_RFREQ_FIX\t\t(I740_RFREQ / I740_FFIX)\n#define I740_REF_FREQ\t\t(6667 * I740_FFIX / 100)\t \n#define I740_MAX_VCO_FREQ\t(450 * I740_FFIX)\t\t \n\nstatic void i740_calc_vclk(u32 freq, struct i740fb_par *par)\n{\n\tconst u32 err_max    = freq / (200  * I740_RFREQ / I740_FFIX);\n\tconst u32 err_target = freq / (1000 * I740_RFREQ / I740_FFIX);\n\tu32 err_best = 512 * I740_FFIX;\n\tu32 f_err, f_vco;\n\tint m_best = 0, n_best = 0, p_best = 0;\n\tint m, n;\n\n\tp_best = min(15, ilog2(I740_MAX_VCO_FREQ / (freq / I740_RFREQ_FIX)));\n\tf_vco = (freq * (1 << p_best)) / I740_RFREQ_FIX;\n\tfreq = freq / I740_RFREQ_FIX;\n\n\tn = 2;\n\tdo {\n\t\tn++;\n\t\tm = ((f_vco * n) / I740_REF_FREQ + 2) / 4;\n\n\t\tif (m < 3)\n\t\t\tm = 3;\n\n\t\t{\n\t\t\tu32 f_out = (((m * I740_REF_FREQ * 4)\n\t\t\t\t / n) + ((1 << p_best) / 2)) / (1 << p_best);\n\n\t\t\tf_err = (freq - f_out);\n\n\t\t\tif (abs(f_err) < err_max) {\n\t\t\t\tm_best = m;\n\t\t\t\tn_best = n;\n\t\t\t\terr_best = f_err;\n\t\t\t}\n\t\t}\n\t} while ((abs(f_err) >= err_target) &&\n\t\t ((n <= TARGET_MAX_N) || (abs(err_best) > err_max)));\n\n\tif (abs(f_err) < err_target) {\n\t\tm_best = m;\n\t\tn_best = n;\n\t}\n\n\tpar->video_clk2_m = (m_best - 2) & 0xFF;\n\tpar->video_clk2_n = (n_best - 2) & 0xFF;\n\tpar->video_clk2_mn_msbs = ((((n_best - 2) >> 4) & VCO_N_MSBS)\n\t\t\t\t | (((m_best - 2) >> 8) & VCO_M_MSBS));\n\tpar->video_clk2_div_sel = ((p_best << 4) | REF_DIV_1);\n}\n\nstatic int i740fb_decode_var(const struct fb_var_screeninfo *var,\n\t\t\t     struct i740fb_par *par, struct fb_info *info)\n{\n\t \n\n\tu32 xres, right, hslen, left, xtotal;\n\tu32 yres, lower, vslen, upper, ytotal;\n\tu32 vxres, xoffset, vyres, yoffset;\n\tu32 bpp, base, dacspeed24, mem, freq;\n\tu8 r7;\n\tint i;\n\n\tdev_dbg(info->device, \"decode_var: xres: %i, yres: %i, xres_v: %i, xres_v: %i\\n\",\n\t\t  var->xres, var->yres, var->xres_virtual, var->xres_virtual);\n\tdev_dbg(info->device, \"\txoff: %i, yoff: %i, bpp: %i, graysc: %i\\n\",\n\t\t  var->xoffset, var->yoffset, var->bits_per_pixel,\n\t\t  var->grayscale);\n\tdev_dbg(info->device, \"\tactivate: %i, nonstd: %i, vmode: %i\\n\",\n\t\t  var->activate, var->nonstd, var->vmode);\n\tdev_dbg(info->device, \"\tpixclock: %i, hsynclen:%i, vsynclen:%i\\n\",\n\t\t  var->pixclock, var->hsync_len, var->vsync_len);\n\tdev_dbg(info->device, \"\tleft: %i, right: %i, up:%i, lower:%i\\n\",\n\t\t  var->left_margin, var->right_margin, var->upper_margin,\n\t\t  var->lower_margin);\n\n\n\tbpp = var->bits_per_pixel;\n\tswitch (bpp) {\n\tcase 1 ... 8:\n\t\tbpp = 8;\n\t\tif ((1000000 / var->pixclock) > DACSPEED8) {\n\t\t\tdev_err(info->device, \"requested pixclock %i MHz out of range (max. %i MHz at 8bpp)\\n\",\n\t\t\t\t1000000 / var->pixclock, DACSPEED8);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 9 ... 15:\n\t\tbpp = 15;\n\t\tfallthrough;\n\tcase 16:\n\t\tif ((1000000 / var->pixclock) > DACSPEED16) {\n\t\t\tdev_err(info->device, \"requested pixclock %i MHz out of range (max. %i MHz at 15/16bpp)\\n\",\n\t\t\t\t1000000 / var->pixclock, DACSPEED16);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 17 ... 24:\n\t\tbpp = 24;\n\t\tdacspeed24 = par->has_sgram ? DACSPEED24_SG : DACSPEED24_SD;\n\t\tif ((1000000 / var->pixclock) > dacspeed24) {\n\t\t\tdev_err(info->device, \"requested pixclock %i MHz out of range (max. %i MHz at 24bpp)\\n\",\n\t\t\t\t1000000 / var->pixclock, dacspeed24);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 25 ... 32:\n\t\tbpp = 32;\n\t\tif ((1000000 / var->pixclock) > DACSPEED32) {\n\t\t\tdev_err(info->device, \"requested pixclock %i MHz out of range (max. %i MHz at 32bpp)\\n\",\n\t\t\t\t1000000 / var->pixclock, DACSPEED32);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\txres = ALIGN(var->xres, 8);\n\tvxres = ALIGN(var->xres_virtual, 16);\n\tif (vxres < xres)\n\t\tvxres = xres;\n\n\txoffset = ALIGN(var->xoffset, 8);\n\tif (xres + xoffset > vxres)\n\t\txoffset = vxres - xres;\n\n\tleft = ALIGN(var->left_margin, 8);\n\tright = ALIGN(var->right_margin, 8);\n\thslen = ALIGN(var->hsync_len, 8);\n\n\tyres = var->yres;\n\tvyres = var->yres_virtual;\n\tif (yres > vyres)\n\t\tvyres = yres;\n\n\tyoffset = var->yoffset;\n\tif (yres + yoffset > vyres)\n\t\tyoffset = vyres - yres;\n\n\tlower = var->lower_margin;\n\tvslen = var->vsync_len;\n\tupper = var->upper_margin;\n\n\tmem = vxres * vyres * ((bpp + 1) / 8);\n\tif (mem > info->screen_size) {\n\t\tdev_err(info->device, \"not enough video memory (%d KB requested, %ld KB available)\\n\",\n\t\t\tmem >> 10, info->screen_size >> 10);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (yoffset + yres > vyres)\n\t\tyoffset = vyres - yres;\n\n\txtotal = xres + right + hslen + left;\n\tytotal = yres + lower + vslen + upper;\n\n\tpar->crtc[VGA_CRTC_H_TOTAL] = (xtotal >> 3) - 5;\n\tpar->crtc[VGA_CRTC_H_DISP] = (xres >> 3) - 1;\n\tpar->crtc[VGA_CRTC_H_BLANK_START] = ((xres + right) >> 3) - 1;\n\tpar->crtc[VGA_CRTC_H_SYNC_START] = (xres + right) >> 3;\n\tpar->crtc[VGA_CRTC_H_SYNC_END] = (((xres + right + hslen) >> 3) & 0x1F)\n\t\t| ((((xres + right + hslen) >> 3) & 0x20) << 2);\n\tpar->crtc[VGA_CRTC_H_BLANK_END] = ((xres + right + hslen) >> 3 & 0x1F)\n\t\t| 0x80;\n\n\tpar->crtc[VGA_CRTC_V_TOTAL] = ytotal - 2;\n\n\tr7 = 0x10;\t \n\tif (ytotal & 0x100)\n\t\tr7 |= 0x01;\n\tif (ytotal & 0x200)\n\t\tr7 |= 0x20;\n\n\tpar->crtc[VGA_CRTC_PRESET_ROW] = 0;\n\tpar->crtc[VGA_CRTC_MAX_SCAN] = 0x40;\t \n\tif (var->vmode & FB_VMODE_DOUBLE)\n\t\tpar->crtc[VGA_CRTC_MAX_SCAN] |= 0x80;\n\tpar->crtc[VGA_CRTC_CURSOR_START] = 0x00;\n\tpar->crtc[VGA_CRTC_CURSOR_END] = 0x00;\n\tpar->crtc[VGA_CRTC_CURSOR_HI] = 0x00;\n\tpar->crtc[VGA_CRTC_CURSOR_LO] = 0x00;\n\tpar->crtc[VGA_CRTC_V_DISP_END] = yres-1;\n\tif ((yres-1) & 0x100)\n\t\tr7 |= 0x02;\n\tif ((yres-1) & 0x200)\n\t\tr7 |= 0x40;\n\n\tpar->crtc[VGA_CRTC_V_BLANK_START] = yres + lower - 1;\n\tpar->crtc[VGA_CRTC_V_SYNC_START] = yres + lower - 1;\n\tif ((yres + lower - 1) & 0x100)\n\t\tr7 |= 0x0C;\n\tif ((yres + lower - 1) & 0x200) {\n\t\tpar->crtc[VGA_CRTC_MAX_SCAN] |= 0x20;\n\t\tr7 |= 0x80;\n\t}\n\n\t \n\tpar->crtc[VGA_CRTC_V_SYNC_END] =\n\t\t((yres + lower - 1 + vslen) & 0x0F) & ~0x10;\n\t \n\tpar->crtc[VGA_CRTC_V_BLANK_END] = (yres + lower - 1 + vslen) & 0xFF;\n\n\tpar->crtc[VGA_CRTC_UNDERLINE] = 0x00;\n\tpar->crtc[VGA_CRTC_MODE] = 0xC3 ;\n\tpar->crtc[VGA_CRTC_LINE_COMPARE] = 0xFF;\n\tpar->crtc[VGA_CRTC_OVERFLOW] = r7;\n\n\tpar->vss = 0x00;\t \n\n\tfor (i = 0x00; i < 0x10; i++)\n\t\tpar->atc[i] = i;\n\tpar->atc[VGA_ATC_MODE] = 0x81;\n\tpar->atc[VGA_ATC_OVERSCAN] = 0x00;\t \n\tpar->atc[VGA_ATC_PLANE_ENABLE] = 0x0F;\n\tpar->atc[VGA_ATC_COLOR_PAGE] = 0x00;\n\n\tpar->misc = 0xC3;\n\tif (var->sync & FB_SYNC_HOR_HIGH_ACT)\n\t\tpar->misc &= ~0x40;\n\tif (var->sync & FB_SYNC_VERT_HIGH_ACT)\n\t\tpar->misc &= ~0x80;\n\n\tpar->seq[VGA_SEQ_CLOCK_MODE] = 0x01;\n\tpar->seq[VGA_SEQ_PLANE_WRITE] = 0x0F;\n\tpar->seq[VGA_SEQ_CHARACTER_MAP] = 0x00;\n\tpar->seq[VGA_SEQ_MEMORY_MODE] = 0x06;\n\n\tpar->gdc[VGA_GFX_SR_VALUE] = 0x00;\n\tpar->gdc[VGA_GFX_SR_ENABLE] = 0x00;\n\tpar->gdc[VGA_GFX_COMPARE_VALUE] = 0x00;\n\tpar->gdc[VGA_GFX_DATA_ROTATE] = 0x00;\n\tpar->gdc[VGA_GFX_PLANE_READ] = 0;\n\tpar->gdc[VGA_GFX_MODE] = 0x02;\n\tpar->gdc[VGA_GFX_MISC] = 0x05;\n\tpar->gdc[VGA_GFX_COMPARE_MASK] = 0x0F;\n\tpar->gdc[VGA_GFX_BIT_MASK] = 0xFF;\n\n\tbase = (yoffset * vxres + (xoffset & ~7)) >> 2;\n\tswitch (bpp) {\n\tcase 8:\n\t\tpar->crtc[VGA_CRTC_OFFSET] = vxres >> 3;\n\t\tpar->ext_offset = vxres >> 11;\n\t\tpar->pixelpipe_cfg1 = DISPLAY_8BPP_MODE;\n\t\tpar->bitblt_cntl = COLEXP_8BPP;\n\t\tbreak;\n\tcase 15:  \n\tcase 16:  \n\t\tpar->pixelpipe_cfg1 = (var->green.length == 6) ?\n\t\t\tDISPLAY_16BPP_MODE : DISPLAY_15BPP_MODE;\n\t\tpar->crtc[VGA_CRTC_OFFSET] = vxres >> 2;\n\t\tpar->ext_offset = vxres >> 10;\n\t\tpar->bitblt_cntl = COLEXP_16BPP;\n\t\tbase *= 2;\n\t\tbreak;\n\tcase 24:\n\t\tpar->crtc[VGA_CRTC_OFFSET] = (vxres * 3) >> 3;\n\t\tpar->ext_offset = (vxres * 3) >> 11;\n\t\tpar->pixelpipe_cfg1 = DISPLAY_24BPP_MODE;\n\t\tpar->bitblt_cntl = COLEXP_24BPP;\n\t\tbase &= 0xFFFFFFFE;  \n\t\tbase *= 3;\n\t\tbreak;\n\tcase 32:\n\t\tpar->crtc[VGA_CRTC_OFFSET] = vxres >> 1;\n\t\tpar->ext_offset = vxres >> 9;\n\t\tpar->pixelpipe_cfg1 = DISPLAY_32BPP_MODE;\n\t\tpar->bitblt_cntl = COLEXP_RESERVED;  \n\t\tbase *= 4;\n\t\tbreak;\n\t}\n\n\tpar->crtc[VGA_CRTC_START_LO] = base & 0x000000FF;\n\tpar->crtc[VGA_CRTC_START_HI] = (base & 0x0000FF00) >>  8;\n\tpar->ext_start_addr =\n\t\t((base & 0x003F0000) >> 16) | EXT_START_ADDR_ENABLE;\n\tpar->ext_start_addr_hi = (base & 0x3FC00000) >> 22;\n\n\tpar->pixelpipe_cfg0 = DAC_8_BIT;\n\n\tpar->pixelpipe_cfg2 = DISPLAY_GAMMA_ENABLE | OVERLAY_GAMMA_ENABLE;\n\tpar->io_cntl = EXTENDED_CRTC_CNTL;\n\tpar->address_mapping = LINEAR_MODE_ENABLE | PAGE_MAPPING_ENABLE;\n\tpar->display_cntl = HIRES_MODE;\n\n\t \n\tpar->pll_cntl = PLL_MEMCLK_100000KHZ;  \n\n\t \n\tpar->ext_vert_total = (ytotal - 2) >> 8;\n\tpar->ext_vert_disp_end = (yres - 1) >> 8;\n\tpar->ext_vert_sync_start = (yres + lower) >> 8;\n\tpar->ext_vert_blank_start = (yres + lower) >> 8;\n\tpar->ext_horiz_total = ((xtotal >> 3) - 5) >> 8;\n\tpar->ext_horiz_blank = (((xres + right) >> 3) & 0x40) >> 6;\n\n\tpar->interlace_cntl = INTERLACE_DISABLE;\n\n\t \n\tpar->atc[VGA_ATC_OVERSCAN] = 0;\n\n\t \n\tfreq = (((u32)1e9) / var->pixclock) * (u32)(1e3);\n\tif (freq < I740_RFREQ_FIX) {\n\t\tfb_dbg(info, \"invalid pixclock\\n\");\n\t\tfreq = I740_RFREQ_FIX;\n\t}\n\ti740_calc_vclk(freq, par);\n\n\t \n\tpar->misc |= 0x0C;\n\n\t \n\tpar->lmi_fifo_watermark =\n\t\ti740_calc_fifo(par, 1000000 / var->pixclock, bpp);\n\n\treturn 0;\n}\n\nstatic int i740fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset\t= var->green.offset = var->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (var->green.length) {\n\t\tdefault:\n\t\tcase 5:\n\t\t\tvar->red.offset = 10;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length\t= 5;\n\t\t\tvar->green.length = 5;\n\t\t\tvar->blue.length = 5;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tvar->red.offset = 11;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length = var->blue.length = 5;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->transp.length = 8;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\n\tif (info->monspecs.hfmax && info->monspecs.vfmax &&\n\t    info->monspecs.dclkmax && fb_validate_mode(var, info) < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void vga_protect(struct i740fb_par *par)\n{\n\t \n\ti740outreg_mask(par, VGA_SEQ_I, VGA_SEQ_CLOCK_MODE, 0x20, 0x20);\n\n\ti740inb(par, 0x3DA);\n\ti740outb(par, VGA_ATT_W, 0x00);\t \n}\n\nstatic void vga_unprotect(struct i740fb_par *par)\n{\n\t \n\ti740outreg_mask(par, VGA_SEQ_I, VGA_SEQ_CLOCK_MODE, 0, 0x20);\n\n\ti740inb(par, 0x3DA);\n\ti740outb(par, VGA_ATT_W, 0x20);\t \n}\n\nstatic int i740fb_set_par(struct fb_info *info)\n{\n\tstruct i740fb_par *par = info->par;\n\tu32 itemp;\n\tint i;\n\n\ti = i740fb_decode_var(&info->var, par, info);\n\tif (i)\n\t\treturn i;\n\n\tmemset_io(info->screen_base, 0, info->screen_size);\n\n\tvga_protect(par);\n\n\ti740outreg(par, XRX, DRAM_EXT_CNTL, DRAM_REFRESH_DISABLE);\n\n\tmdelay(1);\n\n\ti740outreg(par, XRX, VCLK2_VCO_M, par->video_clk2_m);\n\ti740outreg(par, XRX, VCLK2_VCO_N, par->video_clk2_n);\n\ti740outreg(par, XRX, VCLK2_VCO_MN_MSBS, par->video_clk2_mn_msbs);\n\ti740outreg(par, XRX, VCLK2_VCO_DIV_SEL, par->video_clk2_div_sel);\n\n\ti740outreg_mask(par, XRX, PIXPIPE_CONFIG_0,\n\t\t\tpar->pixelpipe_cfg0 & DAC_8_BIT, 0x80);\n\n\ti740inb(par, 0x3DA);\n\ti740outb(par, 0x3C0, 0x00);\n\n\t \n\ti740outb(par, VGA_MIS_W, par->misc | 0x01);\n\n\t \n\ti740outreg(par, VGA_SEQ_I, VGA_SEQ_RESET, 0x01);\n\t \n\ti740outreg(par, VGA_SEQ_I, VGA_SEQ_CLOCK_MODE,\n\t\t\tpar->seq[VGA_SEQ_CLOCK_MODE] | 0x20);\n\tfor (i = 2; i < VGA_SEQ_C; i++)\n\t\ti740outreg(par, VGA_SEQ_I, i, par->seq[i]);\n\n\t \n\ti740outreg(par, VGA_SEQ_I, VGA_SEQ_RESET, 0x03);\n\n\t \n\ti740outreg(par, VGA_CRT_IC, VGA_CRTC_V_SYNC_END,\n\t\t\tpar->crtc[VGA_CRTC_V_SYNC_END]);\n\n\t \n\tfor (i = 0; i < VGA_CRT_C; i++)\n\t\ti740outreg(par, VGA_CRT_IC, i, par->crtc[i]);\n\n\t \n\tfor (i = 0; i < VGA_GFX_C; i++)\n\t\ti740outreg(par, VGA_GFX_I, i, par->gdc[i]);\n\n\t \n\tfor (i = 0; i < VGA_ATT_C; i++) {\n\t\ti740inb(par, VGA_IS1_RC);\t\t \n\t\ti740outb(par, VGA_ATT_IW, i);\n\t\ti740outb(par, VGA_ATT_IW, par->atc[i]);\n\t}\n\n\ti740inb(par, VGA_IS1_RC);\n\ti740outb(par, VGA_ATT_IW, 0x20);\n\n\ti740outreg(par, VGA_CRT_IC, EXT_VERT_TOTAL, par->ext_vert_total);\n\ti740outreg(par, VGA_CRT_IC, EXT_VERT_DISPLAY, par->ext_vert_disp_end);\n\ti740outreg(par, VGA_CRT_IC, EXT_VERT_SYNC_START,\n\t\t\tpar->ext_vert_sync_start);\n\ti740outreg(par, VGA_CRT_IC, EXT_VERT_BLANK_START,\n\t\t\tpar->ext_vert_blank_start);\n\ti740outreg(par, VGA_CRT_IC, EXT_HORIZ_TOTAL, par->ext_horiz_total);\n\ti740outreg(par, VGA_CRT_IC, EXT_HORIZ_BLANK, par->ext_horiz_blank);\n\ti740outreg(par, VGA_CRT_IC, EXT_OFFSET, par->ext_offset);\n\ti740outreg(par, VGA_CRT_IC, EXT_START_ADDR_HI, par->ext_start_addr_hi);\n\ti740outreg(par, VGA_CRT_IC, EXT_START_ADDR, par->ext_start_addr);\n\n\ti740outreg_mask(par, VGA_CRT_IC, INTERLACE_CNTL,\n\t\t\tpar->interlace_cntl, INTERLACE_ENABLE);\n\ti740outreg_mask(par, XRX, ADDRESS_MAPPING, par->address_mapping, 0x1F);\n\ti740outreg_mask(par, XRX, BITBLT_CNTL, par->bitblt_cntl, COLEXP_MODE);\n\ti740outreg_mask(par, XRX, DISPLAY_CNTL,\n\t\t\tpar->display_cntl, VGA_WRAP_MODE | GUI_MODE);\n\ti740outreg_mask(par, XRX, PIXPIPE_CONFIG_0, par->pixelpipe_cfg0, 0x9B);\n\ti740outreg_mask(par, XRX, PIXPIPE_CONFIG_2, par->pixelpipe_cfg2, 0x0C);\n\n\ti740outreg(par, XRX, PLL_CNTL, par->pll_cntl);\n\n\ti740outreg_mask(par, XRX, PIXPIPE_CONFIG_1,\n\t\t\tpar->pixelpipe_cfg1, DISPLAY_COLOR_MODE);\n\n\titemp = readl(par->regs + FWATER_BLC);\n\titemp &= ~(LMI_BURST_LENGTH | LMI_FIFO_WATERMARK);\n\titemp |= par->lmi_fifo_watermark;\n\twritel(itemp, par->regs + FWATER_BLC);\n\n\ti740outreg(par, XRX, DRAM_EXT_CNTL, DRAM_REFRESH_60HZ);\n\n\ti740outreg_mask(par, MRX, COL_KEY_CNTL_1, 0, BLANK_DISP_OVERLAY);\n\ti740outreg_mask(par, XRX, IO_CTNL,\n\t\t\tpar->io_cntl, EXTENDED_ATTR_CNTL | EXTENDED_CRTC_CNTL);\n\n\tif (par->pixelpipe_cfg1 != DISPLAY_8BPP_MODE) {\n\t\ti740outb(par, VGA_PEL_MSK, 0xFF);\n\t\ti740outb(par, VGA_PEL_IW, 0x00);\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\titemp = (par->pixelpipe_cfg0 & DAC_8_BIT) ? i : i >> 2;\n\t\t\ti740outb(par, VGA_PEL_D, itemp);\n\t\t\ti740outb(par, VGA_PEL_D, itemp);\n\t\t\ti740outb(par, VGA_PEL_D, itemp);\n\t\t}\n\t}\n\n\t \n\tmdelay(50);\n\tvga_unprotect(par);\n\n\tinfo->fix.line_length =\n\t\t\tinfo->var.xres_virtual * info->var.bits_per_pixel / 8;\n\tif (info->var.bits_per_pixel == 8)\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\telse\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\n\treturn 0;\n}\n\nstatic int i740fb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t   unsigned blue, unsigned transp,\n\t\t\t   struct fb_info *info)\n{\n\tu32 r, g, b;\n\n\tdev_dbg(info->device, \"setcolreg: regno: %i, red=%d, green=%d, blue=%d, transp=%d, bpp=%d\\n\",\n\t\tregno, red, green, blue, transp, info->var.bits_per_pixel);\n\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tif (regno >= 256)\n\t\t\treturn -EINVAL;\n\t\ti740outb(info->par, VGA_PEL_IW, regno);\n\t\ti740outb(info->par, VGA_PEL_D, red >> 8);\n\t\ti740outb(info->par, VGA_PEL_D, green >> 8);\n\t\ti740outb(info->par, VGA_PEL_D, blue >> 8);\n\t\tbreak;\n\tcase FB_VISUAL_TRUECOLOR:\n\t\tif (regno >= 16)\n\t\t\treturn -EINVAL;\n\t\tr = (red >> (16 - info->var.red.length))\n\t\t\t<< info->var.red.offset;\n\t\tb = (blue >> (16 - info->var.blue.length))\n\t\t\t<< info->var.blue.offset;\n\t\tg = (green >> (16 - info->var.green.length))\n\t\t\t<< info->var.green.offset;\n\t\t((u32 *) info->pseudo_palette)[regno] = r | g | b;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int i740fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\t struct fb_info *info)\n{\n\tstruct i740fb_par *par = info->par;\n\tu32 base = (var->yoffset * info->var.xres_virtual\n\t\t + (var->xoffset & ~7)) >> 2;\n\n\tdev_dbg(info->device, \"pan_display: xoffset: %i yoffset: %i base: %i\\n\",\n\t\tvar->xoffset, var->yoffset, base);\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tbreak;\n\tcase 15:\n\tcase 16:\n\t\tbase *= 2;\n\t\tbreak;\n\tcase 24:\n\t\t \n\t\tbase &= 0xFFFFFFFE;  \n\t\tbase *= 3;\n\t\tbreak;\n\tcase 32:\n\t\tbase *= 4;\n\t\tbreak;\n\t}\n\n\tpar->crtc[VGA_CRTC_START_LO] = base & 0x000000FF;\n\tpar->crtc[VGA_CRTC_START_HI] = (base & 0x0000FF00) >>  8;\n\tpar->ext_start_addr_hi = (base & 0x3FC00000) >> 22;\n\tpar->ext_start_addr =\n\t\t\t((base & 0x003F0000) >> 16) | EXT_START_ADDR_ENABLE;\n\n\ti740outreg(par, VGA_CRT_IC, VGA_CRTC_START_LO,  base & 0x000000FF);\n\ti740outreg(par, VGA_CRT_IC, VGA_CRTC_START_HI,\n\t\t\t(base & 0x0000FF00) >> 8);\n\ti740outreg(par, VGA_CRT_IC, EXT_START_ADDR_HI,\n\t\t\t(base & 0x3FC00000) >> 22);\n\ti740outreg(par, VGA_CRT_IC, EXT_START_ADDR,\n\t\t\t((base & 0x003F0000) >> 16) | EXT_START_ADDR_ENABLE);\n\n\treturn 0;\n}\n\nstatic int i740fb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct i740fb_par *par = info->par;\n\n\tunsigned char SEQ01;\n\tint DPMSSyncSelect;\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\tcase FB_BLANK_NORMAL:\n\t\tSEQ01 = 0x00;\n\t\tDPMSSyncSelect = HSYNC_ON | VSYNC_ON;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tSEQ01 = 0x20;\n\t\tDPMSSyncSelect = HSYNC_ON | VSYNC_OFF;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tSEQ01 = 0x20;\n\t\tDPMSSyncSelect = HSYNC_OFF | VSYNC_ON;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tSEQ01 = 0x20;\n\t\tDPMSSyncSelect = HSYNC_OFF | VSYNC_OFF;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t \n\ti740outb(par, SRX, 0x01);\n\tSEQ01 |= i740inb(par, SRX + 1) & ~0x20;\n\ti740outb(par, SRX, 0x01);\n\ti740outb(par, SRX + 1, SEQ01);\n\n\t \n\ti740outreg(par, XRX, DPMS_SYNC_SELECT, DPMSSyncSelect);\n\n\t \n\treturn (blank_mode == FB_BLANK_NORMAL) ? 1 : 0;\n}\n\nstatic const struct fb_ops i740fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= i740fb_open,\n\t.fb_release\t= i740fb_release,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= i740fb_check_var,\n\t.fb_set_par\t= i740fb_set_par,\n\t.fb_setcolreg\t= i740fb_setcolreg,\n\t.fb_blank\t= i740fb_blank,\n\t.fb_pan_display\t= i740fb_pan_display,\n};\n\n \n\nstatic int i740fb_probe(struct pci_dev *dev, const struct pci_device_id *ent)\n{\n\tstruct fb_info *info;\n\tstruct i740fb_par *par;\n\tint ret, tmp;\n\tbool found = false;\n\tu8 *edid;\n\n\tret = aperture_remove_conflicting_pci_devices(dev, \"i740fb\");\n\tif (ret)\n\t\treturn ret;\n\n\tinfo = framebuffer_alloc(sizeof(struct i740fb_par), &(dev->dev));\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tmutex_init(&par->open_lock);\n\n\tinfo->var.activate = FB_ACTIVATE_NOW;\n\tinfo->var.bits_per_pixel = 8;\n\tinfo->fbops = &i740fb_ops;\n\tinfo->pseudo_palette = par->pseudo_palette;\n\n\tret = pci_enable_device(dev);\n\tif (ret) {\n\t\tdev_err(info->device, \"cannot enable PCI device\\n\");\n\t\tgoto err_enable_device;\n\t}\n\n\tret = pci_request_regions(dev, info->fix.id);\n\tif (ret) {\n\t\tdev_err(info->device, \"error requesting regions\\n\");\n\t\tgoto err_request_regions;\n\t}\n\n\tinfo->screen_base = pci_ioremap_wc_bar(dev, 0);\n\tif (!info->screen_base) {\n\t\tdev_err(info->device, \"error remapping base\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_ioremap_1;\n\t}\n\n\tpar->regs = pci_ioremap_bar(dev, 1);\n\tif (!par->regs) {\n\t\tdev_err(info->device, \"error remapping MMIO\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_ioremap_2;\n\t}\n\n\t \n\tif ((i740inreg(par, XRX, DRAM_ROW_TYPE) & DRAM_ROW_1)\n\t\t\t\t\t\t\t== DRAM_ROW_1_SDRAM)\n\t\ti740outb(par, XRX, DRAM_ROW_BNDRY_1);\n\telse\n\t\ti740outb(par, XRX, DRAM_ROW_BNDRY_0);\n\tinfo->screen_size = i740inb(par, XRX + 1) * 1024 * 1024;\n\t \n\ttmp = i740inreg(par, XRX, DRAM_ROW_CNTL_LO);\n\tpar->has_sgram = !((tmp & DRAM_RAS_TIMING) ||\n\t\t\t   (tmp & DRAM_RAS_PRECHARGE));\n\n\tfb_info(info, \"Intel740 on %s, %ld KB %s\\n\",\n\t\tpci_name(dev), info->screen_size >> 10,\n\t\tpar->has_sgram ? \"SGRAM\" : \"SDRAM\");\n\n\tinfo->fix = i740fb_fix;\n\tinfo->fix.mmio_start = pci_resource_start(dev, 1);\n\tinfo->fix.mmio_len = pci_resource_len(dev, 1);\n\tinfo->fix.smem_start = pci_resource_start(dev, 0);\n\tinfo->fix.smem_len = info->screen_size;\n\tinfo->flags = FBINFO_HWACCEL_YPAN;\n\n\tif (i740fb_setup_ddc_bus(info) == 0) {\n\t\tpar->ddc_registered = true;\n\t\tedid = fb_ddc_read(&par->ddc_adapter);\n\t\tif (edid) {\n\t\t\tfb_edid_to_monspecs(edid, &info->monspecs);\n\t\t\tkfree(edid);\n\t\t\tif (!info->monspecs.modedb)\n\t\t\t\tdev_err(info->device,\n\t\t\t\t\t\"error getting mode database\\n\");\n\t\t\telse {\n\t\t\t\tconst struct fb_videomode *m;\n\n\t\t\t\tfb_videomode_to_modelist(\n\t\t\t\t\tinfo->monspecs.modedb,\n\t\t\t\t\tinfo->monspecs.modedb_len,\n\t\t\t\t\t&info->modelist);\n\t\t\t\tm = fb_find_best_display(&info->monspecs,\n\t\t\t\t\t\t\t &info->modelist);\n\t\t\t\tif (m) {\n\t\t\t\t\tfb_videomode_to_var(&info->var, m);\n\t\t\t\t\t \n\t\t\t\t\tif (!i740fb_check_var(&info->var, info))\n\t\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!mode_option && !found)\n\t\tmode_option = \"640x480-8@60\";\n\n\tif (mode_option) {\n\t\tret = fb_find_mode(&info->var, info, mode_option,\n\t\t\t\t   info->monspecs.modedb,\n\t\t\t\t   info->monspecs.modedb_len,\n\t\t\t\t   NULL, info->var.bits_per_pixel);\n\t\tif (!ret || ret == 4) {\n\t\t\tdev_err(info->device, \"mode %s not found\\n\",\n\t\t\t\tmode_option);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\n\tfb_destroy_modedb(info->monspecs.modedb);\n\tinfo->monspecs.modedb = NULL;\n\n\t \n\tinfo->var.yres_virtual = info->fix.smem_len * 8 /\n\t\t\t(info->var.bits_per_pixel * info->var.xres_virtual);\n\n\tif (ret == -EINVAL)\n\t\tgoto err_find_mode;\n\n\tret = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (ret) {\n\t\tdev_err(info->device, \"cannot allocate colormap\\n\");\n\t\tgoto err_alloc_cmap;\n\t}\n\n\tret = register_framebuffer(info);\n\tif (ret) {\n\t\tdev_err(info->device, \"error registering framebuffer\\n\");\n\t\tgoto err_reg_framebuffer;\n\t}\n\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\tpci_set_drvdata(dev, info);\n\tif (mtrr)\n\t\tpar->wc_cookie = arch_phys_wc_add(info->fix.smem_start,\n\t\t\t\t\t\t  info->fix.smem_len);\n\treturn 0;\n\nerr_reg_framebuffer:\n\tfb_dealloc_cmap(&info->cmap);\nerr_alloc_cmap:\nerr_find_mode:\n\tif (par->ddc_registered)\n\t\ti2c_del_adapter(&par->ddc_adapter);\n\tpci_iounmap(dev, par->regs);\nerr_ioremap_2:\n\tpci_iounmap(dev, info->screen_base);\nerr_ioremap_1:\n\tpci_release_regions(dev);\nerr_request_regions:\n \nerr_enable_device:\n\tframebuffer_release(info);\n\treturn ret;\n}\n\nstatic void i740fb_remove(struct pci_dev *dev)\n{\n\tstruct fb_info *info = pci_get_drvdata(dev);\n\n\tif (info) {\n\t\tstruct i740fb_par *par = info->par;\n\t\tarch_phys_wc_del(par->wc_cookie);\n\t\tunregister_framebuffer(info);\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\tif (par->ddc_registered)\n\t\t\ti2c_del_adapter(&par->ddc_adapter);\n\t\tpci_iounmap(dev, par->regs);\n\t\tpci_iounmap(dev, info->screen_base);\n\t\tpci_release_regions(dev);\n \n\t\tframebuffer_release(info);\n\t}\n}\n\nstatic int __maybe_unused i740fb_suspend(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct i740fb_par *par = info->par;\n\n\tconsole_lock();\n\tmutex_lock(&(par->open_lock));\n\n\t \n\tif (par->ref_count == 0) {\n\t\tmutex_unlock(&(par->open_lock));\n\t\tconsole_unlock();\n\t\treturn 0;\n\t}\n\n\tfb_set_suspend(info, 1);\n\n\tmutex_unlock(&(par->open_lock));\n\tconsole_unlock();\n\n\treturn 0;\n}\n\nstatic int __maybe_unused i740fb_resume(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct i740fb_par *par = info->par;\n\n\tconsole_lock();\n\tmutex_lock(&(par->open_lock));\n\n\tif (par->ref_count == 0)\n\t\tgoto fail;\n\n\ti740fb_set_par(info);\n\tfb_set_suspend(info, 0);\n\nfail:\n\tmutex_unlock(&(par->open_lock));\n\tconsole_unlock();\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops i740fb_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= i740fb_suspend,\n\t.resume\t\t= i740fb_resume,\n\t.freeze\t\t= NULL,\n\t.thaw\t\t= i740fb_resume,\n\t.poweroff\t= i740fb_suspend,\n\t.restore\t= i740fb_resume,\n#endif  \n};\n\n#define I740_ID_PCI 0x00d1\n#define I740_ID_AGP 0x7800\n\nstatic const struct pci_device_id i740fb_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, I740_ID_PCI) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, I740_ID_AGP) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, i740fb_id_table);\n\nstatic struct pci_driver i740fb_driver = {\n\t.name\t\t= \"i740fb\",\n\t.id_table\t= i740fb_id_table,\n\t.probe\t\t= i740fb_probe,\n\t.remove\t\t= i740fb_remove,\n\t.driver.pm\t= &i740fb_pm_ops,\n};\n\n#ifndef MODULE\nstatic int  __init i740fb_setup(char *options)\n{\n\tchar *opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*opt)\n\t\t\tcontinue;\n\t\telse if (!strncmp(opt, \"mtrr:\", 5))\n\t\t\tmtrr = simple_strtoul(opt + 5, NULL, 0);\n\t\telse\n\t\t\tmode_option = opt;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int __init i740fb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"i740fb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"i740fb\", &option))\n\t\treturn -ENODEV;\n\ti740fb_setup(option);\n#endif\n\n\treturn pci_register_driver(&i740fb_driver);\n}\n\nstatic void __exit i740fb_exit(void)\n{\n\tpci_unregister_driver(&i740fb_driver);\n}\n\nmodule_init(i740fb_init);\nmodule_exit(i740fb_exit);\n\nMODULE_AUTHOR(\"(c) 2011 Ondrej Zary <linux@rainbow-software.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"fbdev driver for Intel740\");\n\nmodule_param(mode_option, charp, 0444);\nMODULE_PARM_DESC(mode_option, \"Default video mode ('640x480-8@60', etc)\");\n\nmodule_param(mtrr, int, 0444);\nMODULE_PARM_DESC(mtrr, \"Enable write-combining with MTRR (1=enable, 0=disable, default=1)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}