{
  "module_name": "viafbdev.c",
  "hash_id": "63930988abf3d5b094dc5649e20ae28fa9a4d44632308ec88fada12c7229f09d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/via/viafbdev.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/via-core.h>\n#include <linux/via_i2c.h>\n\n#define _MASTER_FILE\n#include \"global.h\"\n\nstatic char *viafb_name = \"Via\";\nstatic u32 pseudo_pal[17];\n\n \nstatic char *viafb_mode;\nstatic char *viafb_mode1;\nstatic int viafb_bpp = 32;\nstatic int viafb_bpp1 = 32;\n\nstatic unsigned int viafb_second_offset;\nstatic int viafb_second_size;\n\nstatic int viafb_accel = 1;\n\n \nstatic char *viafb_active_dev;\n\n \nstatic char *viafb_lcd_port = \"\";\nstatic char *viafb_dvi_port = \"\";\n\nstatic void retrieve_device_setting(struct viafb_ioctl_setting\n\t*setting_info);\nstatic int viafb_pan_display(struct fb_var_screeninfo *var,\n\tstruct fb_info *info);\n\nstatic struct fb_ops viafb_ops;\n\n \nstatic const u32 supported_odev_map[] = {\n\t[UNICHROME_CLE266]\t= VIA_CRT | VIA_LDVP0 | VIA_LDVP1,\n\t[UNICHROME_K400]\t= VIA_CRT | VIA_DVP0 | VIA_DVP1 | VIA_LVDS1\n\t\t\t\t| VIA_LVDS2,\n\t[UNICHROME_K800]\t= VIA_CRT | VIA_DVP0 | VIA_DVP1 | VIA_LVDS1\n\t\t\t\t| VIA_LVDS2,\n\t[UNICHROME_PM800]\t= VIA_CRT | VIA_DVP0 | VIA_DVP1 | VIA_LVDS1\n\t\t\t\t| VIA_LVDS2,\n\t[UNICHROME_CN700]\t= VIA_CRT | VIA_DVP0 | VIA_DVP1 | VIA_LVDS1\n\t\t\t\t| VIA_LVDS2,\n\t[UNICHROME_CX700]\t= VIA_CRT | VIA_DVP1 | VIA_LVDS1 | VIA_LVDS2,\n\t[UNICHROME_CN750]\t= VIA_CRT | VIA_DVP1 | VIA_LVDS1 | VIA_LVDS2,\n\t[UNICHROME_K8M890]\t= VIA_CRT | VIA_DVP1 | VIA_LVDS1 | VIA_LVDS2,\n\t[UNICHROME_P4M890]\t= VIA_CRT | VIA_DVP1 | VIA_LVDS1 | VIA_LVDS2,\n\t[UNICHROME_P4M900]\t= VIA_CRT | VIA_DVP1 | VIA_LVDS1 | VIA_LVDS2,\n\t[UNICHROME_VX800]\t= VIA_CRT | VIA_DVP1 | VIA_LVDS1 | VIA_LVDS2,\n\t[UNICHROME_VX855]\t= VIA_CRT | VIA_DVP1 | VIA_LVDS1 | VIA_LVDS2,\n\t[UNICHROME_VX900]\t= VIA_CRT | VIA_DVP1 | VIA_LVDS1 | VIA_LVDS2,\n};\n\nstatic void viafb_fill_var_color_info(struct fb_var_screeninfo *var, u8 depth)\n{\n\tvar->grayscale = 0;\n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.msb_right = 0;\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\tvar->transp.msb_right = 0;\n\tvar->nonstd = 0;\n\tswitch (depth) {\n\tcase 8:\n\t\tvar->bits_per_pixel = 8;\n\t\tvar->red.offset = 0;\n\t\tvar->green.offset = 0;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\tcase 15:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 10;\n\t\tvar->green.offset = 5;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 5;\n\t\tvar->green.length = 5;\n\t\tvar->blue.length = 5;\n\t\tbreak;\n\tcase 16:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 11;\n\t\tvar->green.offset = 5;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.length = 5;\n\t\tbreak;\n\tcase 24:\n\t\tvar->bits_per_pixel = 32;\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\tcase 30:\n\t\tvar->bits_per_pixel = 32;\n\t\tvar->red.offset = 20;\n\t\tvar->green.offset = 10;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 10;\n\t\tvar->green.length = 10;\n\t\tvar->blue.length = 10;\n\t\tbreak;\n\t}\n}\n\nstatic void viafb_update_fix(struct fb_info *info)\n{\n\tu32 bpp = info->var.bits_per_pixel;\n\n\tinfo->fix.visual =\n\t\tbpp == 8 ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\tinfo->fix.line_length = ALIGN(info->var.xres_virtual * bpp / 8,\n\t\tVIA_PITCH_SIZE);\n}\n\nstatic void viafb_setup_fixinfo(struct fb_fix_screeninfo *fix,\n\tstruct viafb_par *viaparinfo)\n{\n\tmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\n\tstrcpy(fix->id, viafb_name);\n\n\tfix->smem_start = viaparinfo->fbmem;\n\tfix->smem_len = viaparinfo->fbmem_free;\n\n\tfix->type = FB_TYPE_PACKED_PIXELS;\n\tfix->type_aux = 0;\n\tfix->visual = FB_VISUAL_TRUECOLOR;\n\n\tfix->xpanstep = fix->ywrapstep = 0;\n\tfix->ypanstep = 1;\n\n\t \n\tviafbinfo->fix.accel = FB_ACCEL_VIA_UNICHROME;\n}\nstatic int viafb_open(struct fb_info *info, int user)\n{\n\tDEBUG_MSG(KERN_INFO \"viafb_open!\\n\");\n\treturn 0;\n}\n\nstatic int viafb_release(struct fb_info *info, int user)\n{\n\tDEBUG_MSG(KERN_INFO \"viafb_release!\\n\");\n\treturn 0;\n}\n\nstatic inline int get_var_refresh(struct fb_var_screeninfo *var)\n{\n\tu32 htotal, vtotal;\n\n\thtotal = var->left_margin + var->xres + var->right_margin\n\t\t+ var->hsync_len;\n\tvtotal = var->upper_margin + var->yres + var->lower_margin\n\t\t+ var->vsync_len;\n\treturn PICOS2KHZ(var->pixclock) * 1000 / (htotal * vtotal);\n}\n\nstatic int viafb_check_var(struct fb_var_screeninfo *var,\n\tstruct fb_info *info)\n{\n\tint depth, refresh;\n\tstruct viafb_par *ppar = info->par;\n\tu32 line;\n\n\tDEBUG_MSG(KERN_INFO \"viafb_check_var!\\n\");\n\t \n\t \n\tif (var->vmode & FB_VMODE_INTERLACED || var->vmode & FB_VMODE_DOUBLE)\n\t\treturn -EINVAL;\n\n\t \n\tif (!viafb_get_best_mode(var->xres, var->yres, 60)) {\n\t\tDEBUG_MSG(KERN_INFO\n\t\t\t  \"viafb: Mode %dx%dx%d not supported!!\\n\",\n\t\t\t  var->xres, var->yres, var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\tdepth = fb_get_color_depth(var, &info->fix);\n\tif (!depth)\n\t\tdepth = var->bits_per_pixel;\n\n\tif (depth < 0 || depth > 32)\n\t\treturn -EINVAL;\n\telse if (!depth)\n\t\tdepth = 24;\n\telse if (depth == 15 && viafb_dual_fb && ppar->iga_path == IGA1)\n\t\tdepth = 15;\n\telse if (depth == 30)\n\t\tdepth = 30;\n\telse if (depth <= 8)\n\t\tdepth = 8;\n\telse if (depth <= 16)\n\t\tdepth = 16;\n\telse\n\t\tdepth = 24;\n\n\tviafb_fill_var_color_info(var, depth);\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\n\tline = ALIGN(var->xres_virtual * var->bits_per_pixel / 8,\n\t\tVIA_PITCH_SIZE);\n\tif (line > VIA_PITCH_MAX || line * var->yres_virtual > ppar->memsize)\n\t\treturn -EINVAL;\n\n\t \n\trefresh = viafb_get_refresh(var->xres, var->yres,\n\t\tget_var_refresh(var));\n\n\t \n\tviafb_fill_var_timing_info(var,\n\t\tviafb_get_best_mode(var->xres, var->yres, refresh));\n\tif (var->accel_flags & FB_ACCELF_TEXT &&\n\t\t!ppar->shared->vdev->engine_mmio)\n\t\tvar->accel_flags = 0;\n\n\treturn 0;\n}\n\nstatic int viafb_set_par(struct fb_info *info)\n{\n\tstruct viafb_par *viapar = info->par;\n\tint refresh;\n\tDEBUG_MSG(KERN_INFO \"viafb_set_par!\\n\");\n\n\tviafb_update_fix(info);\n\tviapar->depth = fb_get_color_depth(&info->var, &info->fix);\n\tviafb_update_device_setting(viafbinfo->var.xres, viafbinfo->var.yres,\n\t\tviafbinfo->var.bits_per_pixel, 0);\n\n\tif (viafb_dual_fb) {\n\t\tviafb_update_device_setting(viafbinfo1->var.xres,\n\t\t\tviafbinfo1->var.yres, viafbinfo1->var.bits_per_pixel,\n\t\t\t1);\n\t} else if (viafb_SAMM_ON == 1) {\n\t\tDEBUG_MSG(KERN_INFO\n\t\t\"viafb_second_xres = %d, viafb_second_yres = %d, bpp = %d\\n\",\n\t\t\t  viafb_second_xres, viafb_second_yres, viafb_bpp1);\n\n\t\tviafb_update_device_setting(viafb_second_xres,\n\t\t\tviafb_second_yres, viafb_bpp1, 1);\n\t}\n\n\trefresh = get_var_refresh(&info->var);\n\tif (viafb_dual_fb && viapar->iga_path == IGA2) {\n\t\tviafb_bpp1 = info->var.bits_per_pixel;\n\t\tviafb_refresh1 = refresh;\n\t} else {\n\t\tviafb_bpp = info->var.bits_per_pixel;\n\t\tviafb_refresh = refresh;\n\t}\n\n\tif (info->var.accel_flags & FB_ACCELF_TEXT)\n\t\tinfo->flags &= ~FBINFO_HWACCEL_DISABLED;\n\telse\n\t\tinfo->flags |= FBINFO_HWACCEL_DISABLED;\n\tviafb_setmode();\n\tviafb_pan_display(&info->var, info);\n\n\treturn 0;\n}\n\n \nstatic int viafb_setcolreg(unsigned regno, unsigned red, unsigned green,\nunsigned blue, unsigned transp, struct fb_info *info)\n{\n\tstruct viafb_par *viapar = info->par;\n\tu32 r, g, b;\n\n\tif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR) {\n\t\tif (regno > 255)\n\t\t\treturn -EINVAL;\n\n\t\tif (!viafb_dual_fb || viapar->iga_path == IGA1)\n\t\t\tviafb_set_primary_color_register(regno, red >> 8,\n\t\t\t\tgreen >> 8, blue >> 8);\n\n\t\tif (!viafb_dual_fb || viapar->iga_path == IGA2)\n\t\t\tviafb_set_secondary_color_register(regno, red >> 8,\n\t\t\t\tgreen >> 8, blue >> 8);\n\t} else {\n\t\tif (regno > 15)\n\t\t\treturn -EINVAL;\n\n\t\tr = (red >> (16 - info->var.red.length))\n\t\t\t<< info->var.red.offset;\n\t\tb = (blue >> (16 - info->var.blue.length))\n\t\t\t<< info->var.blue.offset;\n\t\tg = (green >> (16 - info->var.green.length))\n\t\t\t<< info->var.green.offset;\n\t\t((u32 *) info->pseudo_palette)[regno] = r | g | b;\n\t}\n\n\treturn 0;\n}\n\nstatic int viafb_pan_display(struct fb_var_screeninfo *var,\n\tstruct fb_info *info)\n{\n\tstruct viafb_par *viapar = info->par;\n\tu32 vram_addr = viapar->vram_addr\n\t\t+ var->yoffset * info->fix.line_length\n\t\t+ var->xoffset * info->var.bits_per_pixel / 8;\n\n\tDEBUG_MSG(KERN_DEBUG \"viafb_pan_display, address = %d\\n\", vram_addr);\n\tif (!viafb_dual_fb) {\n\t\tvia_set_primary_address(vram_addr);\n\t\tvia_set_secondary_address(vram_addr);\n\t} else if (viapar->iga_path == IGA1)\n\t\tvia_set_primary_address(vram_addr);\n\telse\n\t\tvia_set_secondary_address(vram_addr);\n\n\treturn 0;\n}\n\nstatic int viafb_blank(int blank_mode, struct fb_info *info)\n{\n\tDEBUG_MSG(KERN_INFO \"viafb_blank!\\n\");\n\t \n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\t \n\t\t \n\t\tvia_set_state(VIA_CRT, VIA_STATE_ON);\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\t \n\t\t \n\t\tvia_set_state(VIA_CRT, VIA_STATE_STANDBY);\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\t \n\t\t \n\t\tvia_set_state(VIA_CRT, VIA_STATE_SUSPEND);\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\t \n\t\t \n\t\tvia_set_state(VIA_CRT, VIA_STATE_OFF);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int viafb_ioctl(struct fb_info *info, u_int cmd, u_long arg)\n{\n\tunion {\n\t\tstruct viafb_ioctl_mode viamode;\n\t\tstruct viafb_ioctl_samm viasamm;\n\t\tstruct viafb_driver_version driver_version;\n\t\tstruct fb_var_screeninfo sec_var;\n\t\tstruct _panel_size_pos_info panel_pos_size_para;\n\t\tstruct viafb_ioctl_setting viafb_setting;\n\t\tstruct device_t active_dev;\n\t} u;\n\tu32 state_info = 0;\n\tu32 *viafb_gamma_table;\n\tchar driver_name[] = \"viafb\";\n\n\tu32 __user *argp = (u32 __user *) arg;\n\tu32 gpu32;\n\n\tDEBUG_MSG(KERN_INFO \"viafb_ioctl: 0x%X !!\\n\", cmd);\n\tprintk(KERN_WARNING \"viafb_ioctl: Please avoid this interface as it is unstable and might change or vanish at any time!\\n\");\n\tmemset(&u, 0, sizeof(u));\n\n\tswitch (cmd) {\n\tcase VIAFB_GET_CHIP_INFO:\n\t\tif (copy_to_user(argp, viaparinfo->chip_info,\n\t\t\t\tsizeof(struct chip_information)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase VIAFB_GET_INFO_SIZE:\n\t\treturn put_user((u32)sizeof(struct viafb_ioctl_info), argp);\n\tcase VIAFB_GET_INFO:\n\t\treturn viafb_ioctl_get_viafb_info(arg);\n\tcase VIAFB_HOTPLUG:\n\t\treturn put_user(viafb_ioctl_hotplug(info->var.xres,\n\t\t\t\t\t      info->var.yres,\n\t\t\t\t\t      info->var.bits_per_pixel), argp);\n\tcase VIAFB_SET_HOTPLUG_FLAG:\n\t\tif (copy_from_user(&gpu32, argp, sizeof(gpu32)))\n\t\t\treturn -EFAULT;\n\t\tviafb_hotplug = (gpu32) ? 1 : 0;\n\t\tbreak;\n\tcase VIAFB_GET_RESOLUTION:\n\t\tu.viamode.xres = (u32) viafb_hotplug_Xres;\n\t\tu.viamode.yres = (u32) viafb_hotplug_Yres;\n\t\tu.viamode.refresh = (u32) viafb_hotplug_refresh;\n\t\tu.viamode.bpp = (u32) viafb_hotplug_bpp;\n\t\tif (viafb_SAMM_ON == 1) {\n\t\t\tu.viamode.xres_sec = viafb_second_xres;\n\t\t\tu.viamode.yres_sec = viafb_second_yres;\n\t\t\tu.viamode.virtual_xres_sec = viafb_dual_fb ? viafbinfo1->var.xres_virtual : viafbinfo->var.xres_virtual;\n\t\t\tu.viamode.virtual_yres_sec = viafb_dual_fb ? viafbinfo1->var.yres_virtual : viafbinfo->var.yres_virtual;\n\t\t\tu.viamode.refresh_sec = viafb_refresh1;\n\t\t\tu.viamode.bpp_sec = viafb_bpp1;\n\t\t} else {\n\t\t\tu.viamode.xres_sec = 0;\n\t\t\tu.viamode.yres_sec = 0;\n\t\t\tu.viamode.virtual_xres_sec = 0;\n\t\t\tu.viamode.virtual_yres_sec = 0;\n\t\t\tu.viamode.refresh_sec = 0;\n\t\t\tu.viamode.bpp_sec = 0;\n\t\t}\n\t\tif (copy_to_user(argp, &u.viamode, sizeof(u.viamode)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase VIAFB_GET_SAMM_INFO:\n\t\tu.viasamm.samm_status = viafb_SAMM_ON;\n\n\t\tif (viafb_SAMM_ON == 1) {\n\t\t\tif (viafb_dual_fb) {\n\t\t\t\tu.viasamm.size_prim = viaparinfo->fbmem_free;\n\t\t\t\tu.viasamm.size_sec = viaparinfo1->fbmem_free;\n\t\t\t} else {\n\t\t\t\tif (viafb_second_size) {\n\t\t\t\t\tu.viasamm.size_prim =\n\t\t\t\t\t    viaparinfo->fbmem_free -\n\t\t\t\t\t    viafb_second_size * 1024 * 1024;\n\t\t\t\t\tu.viasamm.size_sec =\n\t\t\t\t\t    viafb_second_size * 1024 * 1024;\n\t\t\t\t} else {\n\t\t\t\t\tu.viasamm.size_prim =\n\t\t\t\t\t    viaparinfo->fbmem_free >> 1;\n\t\t\t\t\tu.viasamm.size_sec =\n\t\t\t\t\t    (viaparinfo->fbmem_free >> 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tu.viasamm.mem_base = viaparinfo->fbmem;\n\t\t\tu.viasamm.offset_sec = viafb_second_offset;\n\t\t} else {\n\t\t\tu.viasamm.size_prim =\n\t\t\t    viaparinfo->memsize - viaparinfo->fbmem_used;\n\t\t\tu.viasamm.size_sec = 0;\n\t\t\tu.viasamm.mem_base = viaparinfo->fbmem;\n\t\t\tu.viasamm.offset_sec = 0;\n\t\t}\n\n\t\tif (copy_to_user(argp, &u.viasamm, sizeof(u.viasamm)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\tcase VIAFB_TURN_ON_OUTPUT_DEVICE:\n\t\tif (copy_from_user(&gpu32, argp, sizeof(gpu32)))\n\t\t\treturn -EFAULT;\n\t\tif (gpu32 & CRT_Device)\n\t\t\tvia_set_state(VIA_CRT, VIA_STATE_ON);\n\t\tif (gpu32 & DVI_Device)\n\t\t\tviafb_dvi_enable();\n\t\tif (gpu32 & LCD_Device)\n\t\t\tviafb_lcd_enable();\n\t\tbreak;\n\tcase VIAFB_TURN_OFF_OUTPUT_DEVICE:\n\t\tif (copy_from_user(&gpu32, argp, sizeof(gpu32)))\n\t\t\treturn -EFAULT;\n\t\tif (gpu32 & CRT_Device)\n\t\t\tvia_set_state(VIA_CRT, VIA_STATE_OFF);\n\t\tif (gpu32 & DVI_Device)\n\t\t\tviafb_dvi_disable();\n\t\tif (gpu32 & LCD_Device)\n\t\t\tviafb_lcd_disable();\n\t\tbreak;\n\tcase VIAFB_GET_DEVICE:\n\t\tu.active_dev.crt = viafb_CRT_ON;\n\t\tu.active_dev.dvi = viafb_DVI_ON;\n\t\tu.active_dev.lcd = viafb_LCD_ON;\n\t\tu.active_dev.samm = viafb_SAMM_ON;\n\t\tu.active_dev.primary_dev = viafb_primary_dev;\n\n\t\tu.active_dev.lcd_dsp_cent = viafb_lcd_dsp_method;\n\t\tu.active_dev.lcd_panel_id = viafb_lcd_panel_id;\n\t\tu.active_dev.lcd_mode = viafb_lcd_mode;\n\n\t\tu.active_dev.xres = viafb_hotplug_Xres;\n\t\tu.active_dev.yres = viafb_hotplug_Yres;\n\n\t\tu.active_dev.xres1 = viafb_second_xres;\n\t\tu.active_dev.yres1 = viafb_second_yres;\n\n\t\tu.active_dev.bpp = viafb_bpp;\n\t\tu.active_dev.bpp1 = viafb_bpp1;\n\t\tu.active_dev.refresh = viafb_refresh;\n\t\tu.active_dev.refresh1 = viafb_refresh1;\n\n\t\tu.active_dev.epia_dvi = viafb_platform_epia_dvi;\n\t\tu.active_dev.lcd_dual_edge = viafb_device_lcd_dualedge;\n\t\tu.active_dev.bus_width = viafb_bus_width;\n\n\t\tif (copy_to_user(argp, &u.active_dev, sizeof(u.active_dev)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase VIAFB_GET_DRIVER_VERSION:\n\t\tu.driver_version.iMajorNum = VERSION_MAJOR;\n\t\tu.driver_version.iKernelNum = VERSION_KERNEL;\n\t\tu.driver_version.iOSNum = VERSION_OS;\n\t\tu.driver_version.iMinorNum = VERSION_MINOR;\n\n\t\tif (copy_to_user(argp, &u.driver_version,\n\t\t\tsizeof(u.driver_version)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\tcase VIAFB_GET_DEVICE_INFO:\n\n\t\tretrieve_device_setting(&u.viafb_setting);\n\n\t\tif (copy_to_user(argp, &u.viafb_setting,\n\t\t\t\t sizeof(u.viafb_setting)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\tcase VIAFB_GET_DEVICE_SUPPORT:\n\t\tviafb_get_device_support_state(&state_info);\n\t\tif (put_user(state_info, argp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase VIAFB_GET_DEVICE_CONNECT:\n\t\tviafb_get_device_connect_state(&state_info);\n\t\tif (put_user(state_info, argp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase VIAFB_GET_PANEL_SUPPORT_EXPAND:\n\t\tstate_info =\n\t\t    viafb_lcd_get_support_expand_state(info->var.xres,\n\t\t\t\t\t\t info->var.yres);\n\t\tif (put_user(state_info, argp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase VIAFB_GET_DRIVER_NAME:\n\t\tif (copy_to_user(argp, driver_name, sizeof(driver_name)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase VIAFB_SET_GAMMA_LUT:\n\t\tviafb_gamma_table = memdup_user(argp, 256 * sizeof(u32));\n\t\tif (IS_ERR(viafb_gamma_table))\n\t\t\treturn PTR_ERR(viafb_gamma_table);\n\t\tviafb_set_gamma_table(viafb_bpp, viafb_gamma_table);\n\t\tkfree(viafb_gamma_table);\n\t\tbreak;\n\n\tcase VIAFB_GET_GAMMA_LUT:\n\t\tviafb_gamma_table = kmalloc_array(256, sizeof(u32),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!viafb_gamma_table)\n\t\t\treturn -ENOMEM;\n\t\tviafb_get_gamma_table(viafb_gamma_table);\n\t\tif (copy_to_user(argp, viafb_gamma_table,\n\t\t\t256 * sizeof(u32))) {\n\t\t\tkfree(viafb_gamma_table);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree(viafb_gamma_table);\n\t\tbreak;\n\n\tcase VIAFB_GET_GAMMA_SUPPORT_STATE:\n\t\tviafb_get_gamma_support_state(viafb_bpp, &state_info);\n\t\tif (put_user(state_info, argp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase VIAFB_SYNC_SURFACE:\n\t\tDEBUG_MSG(KERN_INFO \"lobo VIAFB_SYNC_SURFACE\\n\");\n\t\tbreak;\n\tcase VIAFB_GET_DRIVER_CAPS:\n\t\tbreak;\n\n\tcase VIAFB_GET_PANEL_MAX_SIZE:\n\t\tif (copy_from_user(&u.panel_pos_size_para, argp,\n\t\t\t\t   sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\tu.panel_pos_size_para.x = u.panel_pos_size_para.y = 0;\n\t\tif (copy_to_user(argp, &u.panel_pos_size_para,\n\t\t     sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase VIAFB_GET_PANEL_MAX_POSITION:\n\t\tif (copy_from_user(&u.panel_pos_size_para, argp,\n\t\t\t\t   sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\tu.panel_pos_size_para.x = u.panel_pos_size_para.y = 0;\n\t\tif (copy_to_user(argp, &u.panel_pos_size_para,\n\t\t\t\t sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase VIAFB_GET_PANEL_POSITION:\n\t\tif (copy_from_user(&u.panel_pos_size_para, argp,\n\t\t\t\t   sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\tu.panel_pos_size_para.x = u.panel_pos_size_para.y = 0;\n\t\tif (copy_to_user(argp, &u.panel_pos_size_para,\n\t\t\t\t sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase VIAFB_GET_PANEL_SIZE:\n\t\tif (copy_from_user(&u.panel_pos_size_para, argp,\n\t\t\t\t   sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\tu.panel_pos_size_para.x = u.panel_pos_size_para.y = 0;\n\t\tif (copy_to_user(argp, &u.panel_pos_size_para,\n\t\t\t\t sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase VIAFB_SET_PANEL_POSITION:\n\t\tif (copy_from_user(&u.panel_pos_size_para, argp,\n\t\t\t\t   sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase VIAFB_SET_PANEL_SIZE:\n\t\tif (copy_from_user(&u.panel_pos_size_para, argp,\n\t\t\t\t   sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void viafb_fillrect(struct fb_info *info,\n\tconst struct fb_fillrect *rect)\n{\n\tstruct viafb_par *viapar = info->par;\n\tstruct viafb_shared *shared = viapar->shared;\n\tu32 fg_color;\n\tu8 rop;\n\n\tif (info->flags & FBINFO_HWACCEL_DISABLED || !shared->hw_bitblt) {\n\t\tcfb_fillrect(info, rect);\n\t\treturn;\n\t}\n\n\tif (!rect->width || !rect->height)\n\t\treturn;\n\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR)\n\t\tfg_color = ((u32 *)info->pseudo_palette)[rect->color];\n\telse\n\t\tfg_color = rect->color;\n\n\tif (rect->rop == ROP_XOR)\n\t\trop = 0x5A;\n\telse\n\t\trop = 0xF0;\n\n\tDEBUG_MSG(KERN_DEBUG \"viafb 2D engine: fillrect\\n\");\n\tif (shared->hw_bitblt(shared->vdev->engine_mmio, VIA_BITBLT_FILL,\n\t\trect->width, rect->height, info->var.bits_per_pixel,\n\t\tviapar->vram_addr, info->fix.line_length, rect->dx, rect->dy,\n\t\tNULL, 0, 0, 0, 0, fg_color, 0, rop))\n\t\tcfb_fillrect(info, rect);\n}\n\nstatic void viafb_copyarea(struct fb_info *info,\n\tconst struct fb_copyarea *area)\n{\n\tstruct viafb_par *viapar = info->par;\n\tstruct viafb_shared *shared = viapar->shared;\n\n\tif (info->flags & FBINFO_HWACCEL_DISABLED || !shared->hw_bitblt) {\n\t\tcfb_copyarea(info, area);\n\t\treturn;\n\t}\n\n\tif (!area->width || !area->height)\n\t\treturn;\n\n\tDEBUG_MSG(KERN_DEBUG \"viafb 2D engine: copyarea\\n\");\n\tif (shared->hw_bitblt(shared->vdev->engine_mmio, VIA_BITBLT_COLOR,\n\t\tarea->width, area->height, info->var.bits_per_pixel,\n\t\tviapar->vram_addr, info->fix.line_length, area->dx, area->dy,\n\t\tNULL, viapar->vram_addr, info->fix.line_length,\n\t\tarea->sx, area->sy, 0, 0, 0))\n\t\tcfb_copyarea(info, area);\n}\n\nstatic void viafb_imageblit(struct fb_info *info,\n\tconst struct fb_image *image)\n{\n\tstruct viafb_par *viapar = info->par;\n\tstruct viafb_shared *shared = viapar->shared;\n\tu32 fg_color = 0, bg_color = 0;\n\tu8 op;\n\n\tif (info->flags & FBINFO_HWACCEL_DISABLED || !shared->hw_bitblt ||\n\t\t(image->depth != 1 && image->depth != viapar->depth)) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\n\tif (image->depth == 1) {\n\t\top = VIA_BITBLT_MONO;\n\t\tif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\t\tfg_color =\n\t\t\t\t((u32 *)info->pseudo_palette)[image->fg_color];\n\t\t\tbg_color =\n\t\t\t\t((u32 *)info->pseudo_palette)[image->bg_color];\n\t\t} else {\n\t\t\tfg_color = image->fg_color;\n\t\t\tbg_color = image->bg_color;\n\t\t}\n\t} else\n\t\top = VIA_BITBLT_COLOR;\n\n\tDEBUG_MSG(KERN_DEBUG \"viafb 2D engine: imageblit\\n\");\n\tif (shared->hw_bitblt(shared->vdev->engine_mmio, op,\n\t\timage->width, image->height, info->var.bits_per_pixel,\n\t\tviapar->vram_addr, info->fix.line_length, image->dx, image->dy,\n\t\t(u32 *)image->data, 0, 0, 0, 0, fg_color, bg_color, 0))\n\t\tcfb_imageblit(info, image);\n}\n\nstatic int viafb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\tstruct viafb_par *viapar = info->par;\n\tvoid __iomem *engine = viapar->shared->vdev->engine_mmio;\n\tu32 temp, xx, yy, bg_color = 0, fg_color = 0,\n\t\tchip_name = viapar->shared->chip_info.gfx_chip_name;\n\tint i, j = 0, cur_size = 64;\n\n\tif (info->flags & FBINFO_HWACCEL_DISABLED || info != viafbinfo)\n\t\treturn -ENODEV;\n\n\t \n\tif ((chip_name == UNICHROME_CLE266 && viapar->iga_path == IGA2) ||\n\t\tviafb_LCD_ON)\n\t\treturn -ENODEV;\n\n\tviafb_show_hw_cursor(info, HW_Cursor_OFF);\n\n\tif (cursor->set & FB_CUR_SETHOT) {\n\t\ttemp = (cursor->hot.x << 16) + cursor->hot.y;\n\t\twritel(temp, engine + VIA_REG_CURSOR_ORG);\n\t}\n\n\tif (cursor->set & FB_CUR_SETPOS) {\n\t\tyy = cursor->image.dy - info->var.yoffset;\n\t\txx = cursor->image.dx - info->var.xoffset;\n\t\ttemp = yy & 0xFFFF;\n\t\ttemp |= (xx << 16);\n\t\twritel(temp, engine + VIA_REG_CURSOR_POS);\n\t}\n\n\tif (cursor->image.width <= 32 && cursor->image.height <= 32)\n\t\tcur_size = 32;\n\telse if (cursor->image.width <= 64 && cursor->image.height <= 64)\n\t\tcur_size = 64;\n\telse {\n\t\tprintk(KERN_WARNING \"viafb_cursor: The cursor is too large \"\n\t\t\t\"%dx%d\", cursor->image.width, cursor->image.height);\n\t\treturn -ENXIO;\n\t}\n\n\tif (cursor->set & FB_CUR_SETSIZE) {\n\t\ttemp = readl(engine + VIA_REG_CURSOR_MODE);\n\t\tif (cur_size == 32)\n\t\t\ttemp |= 0x2;\n\t\telse\n\t\t\ttemp &= ~0x2;\n\n\t\twritel(temp, engine + VIA_REG_CURSOR_MODE);\n\t}\n\n\tif (cursor->set & FB_CUR_SETCMAP) {\n\t\tfg_color = cursor->image.fg_color;\n\t\tbg_color = cursor->image.bg_color;\n\t\tif (chip_name == UNICHROME_CX700 ||\n\t\t\tchip_name == UNICHROME_VX800 ||\n\t\t\tchip_name == UNICHROME_VX855 ||\n\t\t\tchip_name == UNICHROME_VX900) {\n\t\t\tfg_color =\n\t\t\t\t((info->cmap.red[fg_color] & 0xFFC0) << 14) |\n\t\t\t\t((info->cmap.green[fg_color] & 0xFFC0) << 4) |\n\t\t\t\t((info->cmap.blue[fg_color] & 0xFFC0) >> 6);\n\t\t\tbg_color =\n\t\t\t\t((info->cmap.red[bg_color] & 0xFFC0) << 14) |\n\t\t\t\t((info->cmap.green[bg_color] & 0xFFC0) << 4) |\n\t\t\t\t((info->cmap.blue[bg_color] & 0xFFC0) >> 6);\n\t\t} else {\n\t\t\tfg_color =\n\t\t\t\t((info->cmap.red[fg_color] & 0xFF00) << 8) |\n\t\t\t\t(info->cmap.green[fg_color] & 0xFF00) |\n\t\t\t\t((info->cmap.blue[fg_color] & 0xFF00) >> 8);\n\t\t\tbg_color =\n\t\t\t\t((info->cmap.red[bg_color] & 0xFF00) << 8) |\n\t\t\t\t(info->cmap.green[bg_color] & 0xFF00) |\n\t\t\t\t((info->cmap.blue[bg_color] & 0xFF00) >> 8);\n\t\t}\n\n\t\twritel(bg_color, engine + VIA_REG_CURSOR_BG);\n\t\twritel(fg_color, engine + VIA_REG_CURSOR_FG);\n\t}\n\n\tif (cursor->set & FB_CUR_SETSHAPE) {\n\t\tstruct {\n\t\t\tu8 data[CURSOR_SIZE];\n\t\t\tu32 bak[CURSOR_SIZE / 4];\n\t\t} *cr_data = kzalloc(sizeof(*cr_data), GFP_ATOMIC);\n\t\tint size = ((cursor->image.width + 7) >> 3) *\n\t\t\tcursor->image.height;\n\n\t\tif (!cr_data)\n\t\t\treturn -ENOMEM;\n\n\t\tif (cur_size == 32) {\n\t\t\tfor (i = 0; i < (CURSOR_SIZE / 4); i++) {\n\t\t\t\tcr_data->bak[i] = 0x0;\n\t\t\t\tcr_data->bak[i + 1] = 0xFFFFFFFF;\n\t\t\t\ti += 1;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < (CURSOR_SIZE / 4); i++) {\n\t\t\t\tcr_data->bak[i] = 0x0;\n\t\t\t\tcr_data->bak[i + 1] = 0x0;\n\t\t\t\tcr_data->bak[i + 2] = 0xFFFFFFFF;\n\t\t\t\tcr_data->bak[i + 3] = 0xFFFFFFFF;\n\t\t\t\ti += 3;\n\t\t\t}\n\t\t}\n\n\t\tswitch (cursor->rop) {\n\t\tcase ROP_XOR:\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\tcr_data->data[i] = cursor->mask[i];\n\t\t\tbreak;\n\t\tcase ROP_COPY:\n\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\tcr_data->data[i] = cursor->mask[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cur_size == 32) {\n\t\t\tfor (i = 0; i < size; i++) {\n\t\t\t\tcr_data->bak[j] = (u32) cr_data->data[i];\n\t\t\t\tcr_data->bak[j + 1] = ~cr_data->bak[j];\n\t\t\t\tj += 2;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < size; i++) {\n\t\t\t\tcr_data->bak[j] = (u32) cr_data->data[i];\n\t\t\t\tcr_data->bak[j + 1] = 0x0;\n\t\t\t\tcr_data->bak[j + 2] = ~cr_data->bak[j];\n\t\t\t\tcr_data->bak[j + 3] = ~cr_data->bak[j + 1];\n\t\t\t\tj += 4;\n\t\t\t}\n\t\t}\n\n\t\tmemcpy_toio(viafbinfo->screen_base + viapar->shared->\n\t\t\tcursor_vram_addr, cr_data->bak, CURSOR_SIZE);\n\t\tkfree(cr_data);\n\t}\n\n\tif (cursor->enable)\n\t\tviafb_show_hw_cursor(info, HW_Cursor_ON);\n\n\treturn 0;\n}\n\nstatic int viafb_sync(struct fb_info *info)\n{\n\tif (!(info->flags & FBINFO_HWACCEL_DISABLED))\n\t\tviafb_wait_engine_idle(info);\n\treturn 0;\n}\n\nstatic int get_primary_device(void)\n{\n\tint primary_device = 0;\n\t \n\tif (viafb_SAMM_ON) {\n\t\tif (viafb_CRT_ON) {\n\t\t\tif (viaparinfo->shared->iga1_devices & VIA_CRT) {\n\t\t\t\tDEBUG_MSG(KERN_INFO \"CRT IGA Path:%d\\n\", IGA1);\n\t\t\t\tprimary_device = CRT_Device;\n\t\t\t}\n\t\t}\n\t\tif (viafb_DVI_ON) {\n\t\t\tif (viaparinfo->tmds_setting_info->iga_path == IGA1) {\n\t\t\t\tDEBUG_MSG(KERN_INFO \"DVI IGA Path:%d\\n\",\n\t\t\t\t\tviaparinfo->\n\t\t\t\t\ttmds_setting_info->iga_path);\n\t\t\t\tprimary_device = DVI_Device;\n\t\t\t}\n\t\t}\n\t\tif (viafb_LCD_ON) {\n\t\t\tif (viaparinfo->lvds_setting_info->iga_path == IGA1) {\n\t\t\t\tDEBUG_MSG(KERN_INFO \"LCD IGA Path:%d\\n\",\n\t\t\t\t\tviaparinfo->\n\t\t\t\t\tlvds_setting_info->iga_path);\n\t\t\t\tprimary_device = LCD_Device;\n\t\t\t}\n\t\t}\n\t\tif (viafb_LCD2_ON) {\n\t\t\tif (viaparinfo->lvds_setting_info2->iga_path == IGA1) {\n\t\t\t\tDEBUG_MSG(KERN_INFO \"LCD2 IGA Path:%d\\n\",\n\t\t\t\t\tviaparinfo->\n\t\t\t\t\tlvds_setting_info2->iga_path);\n\t\t\t\tprimary_device = LCD2_Device;\n\t\t\t}\n\t\t}\n\t}\n\treturn primary_device;\n}\n\nstatic void retrieve_device_setting(struct viafb_ioctl_setting\n\t*setting_info)\n{\n\n\t \n\tif (viafb_CRT_ON == 1)\n\t\tsetting_info->device_status = CRT_Device;\n\tif (viafb_DVI_ON == 1)\n\t\tsetting_info->device_status |= DVI_Device;\n\tif (viafb_LCD_ON == 1)\n\t\tsetting_info->device_status |= LCD_Device;\n\tif (viafb_LCD2_ON == 1)\n\t\tsetting_info->device_status |= LCD2_Device;\n\n\tsetting_info->samm_status = viafb_SAMM_ON;\n\tsetting_info->primary_device = get_primary_device();\n\n\tsetting_info->first_dev_bpp = viafb_bpp;\n\tsetting_info->second_dev_bpp = viafb_bpp1;\n\n\tsetting_info->first_dev_refresh = viafb_refresh;\n\tsetting_info->second_dev_refresh = viafb_refresh1;\n\n\tsetting_info->first_dev_hor_res = viafb_hotplug_Xres;\n\tsetting_info->first_dev_ver_res = viafb_hotplug_Yres;\n\tsetting_info->second_dev_hor_res = viafb_second_xres;\n\tsetting_info->second_dev_ver_res = viafb_second_yres;\n\n\t \n\tsetting_info->lcd_attributes.display_center = viafb_lcd_dsp_method;\n\tsetting_info->lcd_attributes.panel_id = viafb_lcd_panel_id;\n\tsetting_info->lcd_attributes.lcd_mode = viafb_lcd_mode;\n}\n\nstatic int __init parse_active_dev(void)\n{\n\tviafb_CRT_ON = STATE_OFF;\n\tviafb_DVI_ON = STATE_OFF;\n\tviafb_LCD_ON = STATE_OFF;\n\tviafb_LCD2_ON = STATE_OFF;\n\t \n\t \n\t \n\tif (!viafb_active_dev) {\n\t\tif (machine_is_olpc()) {  \n\t\t\tviafb_LCD_ON = STATE_ON;\n\t\t\tviafb_SAMM_ON = STATE_OFF;\n\t\t} else {\n\t\t\tviafb_CRT_ON = STATE_ON;\n\t\t\tviafb_SAMM_ON = STATE_OFF;\n\t\t}\n\t} else if (!strcmp(viafb_active_dev, \"CRT+DVI\")) {\n\t\t \n\t\tviafb_CRT_ON = STATE_ON;\n\t\tviafb_DVI_ON = STATE_ON;\n\t\tviafb_primary_dev = CRT_Device;\n\t} else if (!strcmp(viafb_active_dev, \"DVI+CRT\")) {\n\t\t \n\t\tviafb_CRT_ON = STATE_ON;\n\t\tviafb_DVI_ON = STATE_ON;\n\t\tviafb_primary_dev = DVI_Device;\n\t} else if (!strcmp(viafb_active_dev, \"CRT+LCD\")) {\n\t\t \n\t\tviafb_CRT_ON = STATE_ON;\n\t\tviafb_LCD_ON = STATE_ON;\n\t\tviafb_primary_dev = CRT_Device;\n\t} else if (!strcmp(viafb_active_dev, \"LCD+CRT\")) {\n\t\t \n\t\tviafb_CRT_ON = STATE_ON;\n\t\tviafb_LCD_ON = STATE_ON;\n\t\tviafb_primary_dev = LCD_Device;\n\t} else if (!strcmp(viafb_active_dev, \"DVI+LCD\")) {\n\t\t \n\t\tviafb_DVI_ON = STATE_ON;\n\t\tviafb_LCD_ON = STATE_ON;\n\t\tviafb_primary_dev = DVI_Device;\n\t} else if (!strcmp(viafb_active_dev, \"LCD+DVI\")) {\n\t\t \n\t\tviafb_DVI_ON = STATE_ON;\n\t\tviafb_LCD_ON = STATE_ON;\n\t\tviafb_primary_dev = LCD_Device;\n\t} else if (!strcmp(viafb_active_dev, \"LCD+LCD2\")) {\n\t\tviafb_LCD_ON = STATE_ON;\n\t\tviafb_LCD2_ON = STATE_ON;\n\t\tviafb_primary_dev = LCD_Device;\n\t} else if (!strcmp(viafb_active_dev, \"LCD2+LCD\")) {\n\t\tviafb_LCD_ON = STATE_ON;\n\t\tviafb_LCD2_ON = STATE_ON;\n\t\tviafb_primary_dev = LCD2_Device;\n\t} else if (!strcmp(viafb_active_dev, \"CRT\")) {\n\t\t \n\t\tviafb_CRT_ON = STATE_ON;\n\t\tviafb_SAMM_ON = STATE_OFF;\n\t} else if (!strcmp(viafb_active_dev, \"DVI\")) {\n\t\t \n\t\tviafb_DVI_ON = STATE_ON;\n\t\tviafb_SAMM_ON = STATE_OFF;\n\t} else if (!strcmp(viafb_active_dev, \"LCD\")) {\n\t\t \n\t\tviafb_LCD_ON = STATE_ON;\n\t\tviafb_SAMM_ON = STATE_OFF;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int parse_port(char *opt_str, int *output_interface)\n{\n\tif (!strncmp(opt_str, \"DVP0\", 4))\n\t\t*output_interface = INTERFACE_DVP0;\n\telse if (!strncmp(opt_str, \"DVP1\", 4))\n\t\t*output_interface = INTERFACE_DVP1;\n\telse if (!strncmp(opt_str, \"DFP_HIGHLOW\", 11))\n\t\t*output_interface = INTERFACE_DFP;\n\telse if (!strncmp(opt_str, \"DFP_HIGH\", 8))\n\t\t*output_interface = INTERFACE_DFP_HIGH;\n\telse if (!strncmp(opt_str, \"DFP_LOW\", 7))\n\t\t*output_interface = INTERFACE_DFP_LOW;\n\telse\n\t\t*output_interface = INTERFACE_NONE;\n\treturn 0;\n}\n\nstatic void parse_lcd_port(void)\n{\n\tparse_port(viafb_lcd_port, &viaparinfo->chip_info->lvds_chip_info.\n\t\toutput_interface);\n\t \n\tviaparinfo->chip_info->lvds_chip_info2.output_interface =\n\tINTERFACE_NONE;\n\n\tDEBUG_MSG(KERN_INFO \"parse_lcd_port: viafb_lcd_port:%s,interface:%d\\n\",\n\t\t  viafb_lcd_port, viaparinfo->chip_info->lvds_chip_info.\n\t\t  output_interface);\n}\n\nstatic void parse_dvi_port(void)\n{\n\tparse_port(viafb_dvi_port, &viaparinfo->chip_info->tmds_chip_info.\n\t\toutput_interface);\n\n\tDEBUG_MSG(KERN_INFO \"parse_dvi_port: viafb_dvi_port:%s,interface:%d\\n\",\n\t\t  viafb_dvi_port, viaparinfo->chip_info->tmds_chip_info.\n\t\t  output_interface);\n}\n\n#ifdef CONFIG_FB_VIA_DIRECT_PROCFS\n\n \nstatic int viafb_dvp0_proc_show(struct seq_file *m, void *v)\n{\n\tu8 dvp0_data_dri = 0, dvp0_clk_dri = 0, dvp0 = 0;\n\tdvp0_data_dri =\n\t    (viafb_read_reg(VIASR, SR2A) & BIT5) >> 4 |\n\t    (viafb_read_reg(VIASR, SR1B) & BIT1) >> 1;\n\tdvp0_clk_dri =\n\t    (viafb_read_reg(VIASR, SR2A) & BIT4) >> 3 |\n\t    (viafb_read_reg(VIASR, SR1E) & BIT2) >> 2;\n\tdvp0 = viafb_read_reg(VIACR, CR96) & 0x0f;\n\tseq_printf(m, \"%x %x %x\\n\", dvp0, dvp0_data_dri, dvp0_clk_dri);\n\treturn 0;\n}\n\nstatic int viafb_dvp0_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, viafb_dvp0_proc_show, NULL);\n}\n\nstatic ssize_t viafb_dvp0_proc_write(struct file *file,\n\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar buf[20], *value, *pbuf;\n\tu8 reg_val = 0;\n\tunsigned long length, i;\n\tif (count < 1)\n\t\treturn -EINVAL;\n\tlength = count > 20 ? 20 : count;\n\tif (copy_from_user(&buf[0], buffer, length))\n\t\treturn -EFAULT;\n\tbuf[length - 1] = '\\0';\t \n\tpbuf = &buf[0];\n\tfor (i = 0; i < 3; i++) {\n\t\tvalue = strsep(&pbuf, \" \");\n\t\tif (value != NULL) {\n\t\t\tif (kstrtou8(value, 0, &reg_val) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tDEBUG_MSG(KERN_INFO \"DVP0:reg_val[%lu]=:%x\\n\", i,\n\t\t\t\t  reg_val);\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tviafb_write_reg_mask(CR96, VIACR,\n\t\t\t\t\treg_val, 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tviafb_write_reg_mask(SR2A, VIASR,\n\t\t\t\t\treg_val << 4, BIT5);\n\t\t\t\tviafb_write_reg_mask(SR1B, VIASR,\n\t\t\t\t\treg_val << 1, BIT1);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tviafb_write_reg_mask(SR2A, VIASR,\n\t\t\t\t\treg_val << 3, BIT4);\n\t\t\t\tviafb_write_reg_mask(SR1E, VIASR,\n\t\t\t\t\treg_val << 2, BIT2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic const struct proc_ops viafb_dvp0_proc_ops = {\n\t.proc_open\t= viafb_dvp0_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= viafb_dvp0_proc_write,\n};\n\nstatic int viafb_dvp1_proc_show(struct seq_file *m, void *v)\n{\n\tu8 dvp1 = 0, dvp1_data_dri = 0, dvp1_clk_dri = 0;\n\tdvp1 = viafb_read_reg(VIACR, CR9B) & 0x0f;\n\tdvp1_data_dri = (viafb_read_reg(VIASR, SR65) & 0x0c) >> 2;\n\tdvp1_clk_dri = viafb_read_reg(VIASR, SR65) & 0x03;\n\tseq_printf(m, \"%x %x %x\\n\", dvp1, dvp1_data_dri, dvp1_clk_dri);\n\treturn 0;\n}\n\nstatic int viafb_dvp1_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, viafb_dvp1_proc_show, NULL);\n}\n\nstatic ssize_t viafb_dvp1_proc_write(struct file *file,\n\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar buf[20], *value, *pbuf;\n\tu8 reg_val = 0;\n\tunsigned long length, i;\n\tif (count < 1)\n\t\treturn -EINVAL;\n\tlength = count > 20 ? 20 : count;\n\tif (copy_from_user(&buf[0], buffer, length))\n\t\treturn -EFAULT;\n\tbuf[length - 1] = '\\0';\t \n\tpbuf = &buf[0];\n\tfor (i = 0; i < 3; i++) {\n\t\tvalue = strsep(&pbuf, \" \");\n\t\tif (value != NULL) {\n\t\t\tif (kstrtou8(value, 0, &reg_val) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tviafb_write_reg_mask(CR9B, VIACR,\n\t\t\t\t\treg_val, 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tviafb_write_reg_mask(SR65, VIASR,\n\t\t\t\t\treg_val << 2, 0x0c);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tviafb_write_reg_mask(SR65, VIASR,\n\t\t\t\t\treg_val, 0x03);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic const struct proc_ops viafb_dvp1_proc_ops = {\n\t.proc_open\t= viafb_dvp1_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= viafb_dvp1_proc_write,\n};\n\nstatic int viafb_dfph_proc_show(struct seq_file *m, void *v)\n{\n\tu8 dfp_high = 0;\n\tdfp_high = viafb_read_reg(VIACR, CR97) & 0x0f;\n\tseq_printf(m, \"%x\\n\", dfp_high);\n\treturn 0;\n}\n\nstatic int viafb_dfph_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, viafb_dfph_proc_show, NULL);\n}\n\nstatic ssize_t viafb_dfph_proc_write(struct file *file,\n\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tint err;\n\tu8 reg_val;\n\terr = kstrtou8_from_user(buffer, count, 0, &reg_val);\n\tif (err)\n\t\treturn err;\n\n\tviafb_write_reg_mask(CR97, VIACR, reg_val, 0x0f);\n\treturn count;\n}\n\nstatic const struct proc_ops viafb_dfph_proc_ops = {\n\t.proc_open\t= viafb_dfph_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= viafb_dfph_proc_write,\n};\n\nstatic int viafb_dfpl_proc_show(struct seq_file *m, void *v)\n{\n\tu8 dfp_low = 0;\n\tdfp_low = viafb_read_reg(VIACR, CR99) & 0x0f;\n\tseq_printf(m, \"%x\\n\", dfp_low);\n\treturn 0;\n}\n\nstatic int viafb_dfpl_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, viafb_dfpl_proc_show, NULL);\n}\n\nstatic ssize_t viafb_dfpl_proc_write(struct file *file,\n\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tint err;\n\tu8 reg_val;\n\terr = kstrtou8_from_user(buffer, count, 0, &reg_val);\n\tif (err)\n\t\treturn err;\n\n\tviafb_write_reg_mask(CR99, VIACR, reg_val, 0x0f);\n\treturn count;\n}\n\nstatic const struct proc_ops viafb_dfpl_proc_ops = {\n\t.proc_open\t= viafb_dfpl_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= viafb_dfpl_proc_write,\n};\n\nstatic int viafb_vt1636_proc_show(struct seq_file *m, void *v)\n{\n\tu8 vt1636_08 = 0, vt1636_09 = 0;\n\tswitch (viaparinfo->chip_info->lvds_chip_info.lvds_chip_name) {\n\tcase VT1636_LVDS:\n\t\tvt1636_08 =\n\t\t    viafb_gpio_i2c_read_lvds(viaparinfo->lvds_setting_info,\n\t\t    &viaparinfo->chip_info->lvds_chip_info, 0x08) & 0x0f;\n\t\tvt1636_09 =\n\t\t    viafb_gpio_i2c_read_lvds(viaparinfo->lvds_setting_info,\n\t\t    &viaparinfo->chip_info->lvds_chip_info, 0x09) & 0x1f;\n\t\tseq_printf(m, \"%x %x\\n\", vt1636_08, vt1636_09);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name) {\n\tcase VT1636_LVDS:\n\t\tvt1636_08 =\n\t\t    viafb_gpio_i2c_read_lvds(viaparinfo->lvds_setting_info2,\n\t\t\t&viaparinfo->chip_info->lvds_chip_info2, 0x08) & 0x0f;\n\t\tvt1636_09 =\n\t\t    viafb_gpio_i2c_read_lvds(viaparinfo->lvds_setting_info2,\n\t\t\t&viaparinfo->chip_info->lvds_chip_info2, 0x09) & 0x1f;\n\t\tseq_printf(m, \" %x %x\\n\", vt1636_08, vt1636_09);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int viafb_vt1636_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, viafb_vt1636_proc_show, NULL);\n}\n\nstatic ssize_t viafb_vt1636_proc_write(struct file *file,\n\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar buf[30], *value, *pbuf;\n\tstruct IODATA reg_val;\n\tunsigned long length, i;\n\tif (count < 1)\n\t\treturn -EINVAL;\n\tlength = count > 30 ? 30 : count;\n\tif (copy_from_user(&buf[0], buffer, length))\n\t\treturn -EFAULT;\n\tbuf[length - 1] = '\\0';\t \n\tpbuf = &buf[0];\n\tswitch (viaparinfo->chip_info->lvds_chip_info.lvds_chip_name) {\n\tcase VT1636_LVDS:\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tvalue = strsep(&pbuf, \" \");\n\t\t\tif (value != NULL) {\n\t\t\t\tif (kstrtou8(value, 0, &reg_val.Data) < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\treg_val.Index = 0x08;\n\t\t\t\t\treg_val.Mask = 0x0f;\n\t\t\t\t\tviafb_gpio_i2c_write_mask_lvds\n\t\t\t\t\t    (viaparinfo->lvds_setting_info,\n\t\t\t\t\t    &viaparinfo->\n\t\t\t\t\t    chip_info->lvds_chip_info,\n\t\t\t\t\t     reg_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\treg_val.Index = 0x09;\n\t\t\t\t\treg_val.Mask = 0x1f;\n\t\t\t\t\tviafb_gpio_i2c_write_mask_lvds\n\t\t\t\t\t    (viaparinfo->lvds_setting_info,\n\t\t\t\t\t    &viaparinfo->\n\t\t\t\t\t    chip_info->lvds_chip_info,\n\t\t\t\t\t     reg_val);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name) {\n\tcase VT1636_LVDS:\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tvalue = strsep(&pbuf, \" \");\n\t\t\tif (value != NULL) {\n\t\t\t\tif (kstrtou8(value, 0, &reg_val.Data) < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\treg_val.Index = 0x08;\n\t\t\t\t\treg_val.Mask = 0x0f;\n\t\t\t\t\tviafb_gpio_i2c_write_mask_lvds\n\t\t\t\t\t    (viaparinfo->lvds_setting_info2,\n\t\t\t\t\t    &viaparinfo->\n\t\t\t\t\t    chip_info->lvds_chip_info2,\n\t\t\t\t\t     reg_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\treg_val.Index = 0x09;\n\t\t\t\t\treg_val.Mask = 0x1f;\n\t\t\t\t\tviafb_gpio_i2c_write_mask_lvds\n\t\t\t\t\t    (viaparinfo->lvds_setting_info2,\n\t\t\t\t\t    &viaparinfo->\n\t\t\t\t\t    chip_info->lvds_chip_info2,\n\t\t\t\t\t     reg_val);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn count;\n}\n\nstatic const struct proc_ops viafb_vt1636_proc_ops = {\n\t.proc_open\t= viafb_vt1636_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= viafb_vt1636_proc_write,\n};\n\n#endif  \n\nstatic int __maybe_unused viafb_sup_odev_proc_show(struct seq_file *m, void *v)\n{\n\tvia_odev_to_seq(m, supported_odev_map[\n\t\tviaparinfo->shared->chip_info.gfx_chip_name]);\n\treturn 0;\n}\n\nstatic ssize_t odev_update(const char __user *buffer, size_t count, u32 *odev)\n{\n\tchar buf[64], *ptr = buf;\n\tu32 devices;\n\tbool add, sub;\n\n\tif (count < 1 || count > 63)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&buf[0], buffer, count))\n\t\treturn -EFAULT;\n\tbuf[count] = '\\0';\n\tadd = buf[0] == '+';\n\tsub = buf[0] == '-';\n\tif (add || sub)\n\t\tptr++;\n\tdevices = via_parse_odev(ptr, &ptr);\n\tif (*ptr == '\\n')\n\t\tptr++;\n\tif (*ptr != 0)\n\t\treturn -EINVAL;\n\tif (add)\n\t\t*odev |= devices;\n\telse if (sub)\n\t\t*odev &= ~devices;\n\telse\n\t\t*odev = devices;\n\treturn count;\n}\n\nstatic int viafb_iga1_odev_proc_show(struct seq_file *m, void *v)\n{\n\tvia_odev_to_seq(m, viaparinfo->shared->iga1_devices);\n\treturn 0;\n}\n\nstatic int viafb_iga1_odev_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, viafb_iga1_odev_proc_show, NULL);\n}\n\nstatic ssize_t viafb_iga1_odev_proc_write(struct file *file,\n\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tu32 dev_on, dev_off, dev_old, dev_new;\n\tssize_t res;\n\n\tdev_old = dev_new = viaparinfo->shared->iga1_devices;\n\tres = odev_update(buffer, count, &dev_new);\n\tif (res != count)\n\t\treturn res;\n\tdev_off = dev_old & ~dev_new;\n\tdev_on = dev_new & ~dev_old;\n\tviaparinfo->shared->iga1_devices = dev_new;\n\tviaparinfo->shared->iga2_devices &= ~dev_new;\n\tvia_set_state(dev_off, VIA_STATE_OFF);\n\tvia_set_source(dev_new, IGA1);\n\tvia_set_state(dev_on, VIA_STATE_ON);\n\treturn res;\n}\n\nstatic const struct proc_ops viafb_iga1_odev_proc_ops = {\n\t.proc_open\t= viafb_iga1_odev_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= viafb_iga1_odev_proc_write,\n};\n\nstatic int viafb_iga2_odev_proc_show(struct seq_file *m, void *v)\n{\n\tvia_odev_to_seq(m, viaparinfo->shared->iga2_devices);\n\treturn 0;\n}\n\nstatic int viafb_iga2_odev_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, viafb_iga2_odev_proc_show, NULL);\n}\n\nstatic ssize_t viafb_iga2_odev_proc_write(struct file *file,\n\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tu32 dev_on, dev_off, dev_old, dev_new;\n\tssize_t res;\n\n\tdev_old = dev_new = viaparinfo->shared->iga2_devices;\n\tres = odev_update(buffer, count, &dev_new);\n\tif (res != count)\n\t\treturn res;\n\tdev_off = dev_old & ~dev_new;\n\tdev_on = dev_new & ~dev_old;\n\tviaparinfo->shared->iga2_devices = dev_new;\n\tviaparinfo->shared->iga1_devices &= ~dev_new;\n\tvia_set_state(dev_off, VIA_STATE_OFF);\n\tvia_set_source(dev_new, IGA2);\n\tvia_set_state(dev_on, VIA_STATE_ON);\n\treturn res;\n}\n\nstatic const struct proc_ops viafb_iga2_odev_proc_ops = {\n\t.proc_open\t= viafb_iga2_odev_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= viafb_iga2_odev_proc_write,\n};\n\n#define IS_VT1636(lvds_chip)\t((lvds_chip).lvds_chip_name == VT1636_LVDS)\nstatic void viafb_init_proc(struct viafb_shared *shared)\n{\n\tstruct proc_dir_entry *iga1_entry, *iga2_entry,\n\t\t*viafb_entry = proc_mkdir(\"viafb\", NULL);\n\n\tshared->proc_entry = viafb_entry;\n\tif (viafb_entry) {\n#ifdef CONFIG_FB_VIA_DIRECT_PROCFS\n\t\tproc_create(\"dvp0\", 0, viafb_entry, &viafb_dvp0_proc_ops);\n\t\tproc_create(\"dvp1\", 0, viafb_entry, &viafb_dvp1_proc_ops);\n\t\tproc_create(\"dfph\", 0, viafb_entry, &viafb_dfph_proc_ops);\n\t\tproc_create(\"dfpl\", 0, viafb_entry, &viafb_dfpl_proc_ops);\n\t\tif (IS_VT1636(shared->chip_info.lvds_chip_info)\n\t\t\t|| IS_VT1636(shared->chip_info.lvds_chip_info2))\n\t\t\tproc_create(\"vt1636\", 0, viafb_entry,\n\t\t\t\t    &viafb_vt1636_proc_ops);\n#endif  \n\n\t\tproc_create_single(\"supported_output_devices\", 0, viafb_entry,\n\t\t\tviafb_sup_odev_proc_show);\n\t\tiga1_entry = proc_mkdir(\"iga1\", viafb_entry);\n\t\tshared->iga1_proc_entry = iga1_entry;\n\t\tproc_create(\"output_devices\", 0, iga1_entry,\n\t\t\t    &viafb_iga1_odev_proc_ops);\n\t\tiga2_entry = proc_mkdir(\"iga2\", viafb_entry);\n\t\tshared->iga2_proc_entry = iga2_entry;\n\t\tproc_create(\"output_devices\", 0, iga2_entry,\n\t\t\t    &viafb_iga2_odev_proc_ops);\n\t}\n}\nstatic void viafb_remove_proc(struct viafb_shared *shared)\n{\n\tstruct proc_dir_entry *viafb_entry = shared->proc_entry;\n\n\tif (!viafb_entry)\n\t\treturn;\n\n\tremove_proc_entry(\"output_devices\", shared->iga2_proc_entry);\n\tremove_proc_entry(\"iga2\", viafb_entry);\n\tremove_proc_entry(\"output_devices\", shared->iga1_proc_entry);\n\tremove_proc_entry(\"iga1\", viafb_entry);\n\tremove_proc_entry(\"supported_output_devices\", viafb_entry);\n\n#ifdef CONFIG_FB_VIA_DIRECT_PROCFS\n\tremove_proc_entry(\"dvp0\", viafb_entry); \n\tremove_proc_entry(\"dvp1\", viafb_entry);\n\tremove_proc_entry(\"dfph\", viafb_entry);\n\tremove_proc_entry(\"dfpl\", viafb_entry);\n\tif (IS_VT1636(shared->chip_info.lvds_chip_info)\n\t\t|| IS_VT1636(shared->chip_info.lvds_chip_info2))\n\t\tremove_proc_entry(\"vt1636\", viafb_entry);\n#endif  \n\n\tremove_proc_entry(\"viafb\", NULL);\n}\n#undef IS_VT1636\n\nstatic int parse_mode(const char *str, u32 devices, u32 *xres, u32 *yres)\n{\n\tconst struct fb_videomode *mode = NULL;\n\tchar *ptr;\n\n\tif (!str) {\n\t\tif (devices == VIA_CRT)\n\t\t\tmode = via_aux_get_preferred_mode(\n\t\t\t\tviaparinfo->shared->i2c_26);\n\t\telse if (devices == VIA_DVP1)\n\t\t\tmode = via_aux_get_preferred_mode(\n\t\t\t\tviaparinfo->shared->i2c_31);\n\n\t\tif (mode) {\n\t\t\t*xres = mode->xres;\n\t\t\t*yres = mode->yres;\n\t\t} else if (machine_is_olpc()) {\n\t\t\t*xres = 1200;\n\t\t\t*yres = 900;\n\t\t} else {\n\t\t\t*xres = 640;\n\t\t\t*yres = 480;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t*xres = simple_strtoul(str, &ptr, 10);\n\tif (ptr[0] != 'x')\n\t\treturn -EINVAL;\n\n\t*yres = simple_strtoul(&ptr[1], &ptr, 10);\n\tif (ptr[0])\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n\n#ifdef CONFIG_PM\nstatic int viafb_suspend(void *unused)\n{\n\tconsole_lock();\n\tfb_set_suspend(viafbinfo, 1);\n\tviafb_sync(viafbinfo);\n\tconsole_unlock();\n\n\treturn 0;\n}\n\nstatic int viafb_resume(void *unused)\n{\n\tconsole_lock();\n\tif (viaparinfo->shared->vdev->engine_mmio)\n\t\tviafb_reset_engine(viaparinfo);\n\tviafb_set_par(viafbinfo);\n\tif (viafb_dual_fb)\n\t\tviafb_set_par(viafbinfo1);\n\tfb_set_suspend(viafbinfo, 0);\n\n\tconsole_unlock();\n\treturn 0;\n}\n\nstatic struct viafb_pm_hooks viafb_fb_pm_hooks = {\n\t.suspend = viafb_suspend,\n\t.resume = viafb_resume\n};\n\n#endif\n\nstatic void i2c_bus_probe(struct viafb_shared *shared)\n{\n\t \n\tprintk(KERN_INFO \"viafb: Probing I2C bus 0x26\\n\");\n\tshared->i2c_26 = via_aux_probe(viafb_find_i2c_adapter(VIA_PORT_26));\n\n\t \n\tprintk(KERN_INFO \"viafb: Probing I2C bus 0x31\\n\");\n\tshared->i2c_31 = via_aux_probe(viafb_find_i2c_adapter(VIA_PORT_31));\n\n\t \n\tif (!machine_is_olpc()) {\n\t\tprintk(KERN_INFO \"viafb: Probing I2C bus 0x2C\\n\");\n\t\tshared->i2c_2C = via_aux_probe(viafb_find_i2c_adapter(VIA_PORT_2C));\n\t}\n\n\tprintk(KERN_INFO \"viafb: Finished I2C bus probing\");\n}\n\nstatic void i2c_bus_free(struct viafb_shared *shared)\n{\n\tvia_aux_free(shared->i2c_26);\n\tvia_aux_free(shared->i2c_31);\n\tvia_aux_free(shared->i2c_2C);\n}\n\nint via_fb_pci_probe(struct viafb_dev *vdev)\n{\n\tu32 default_xres, default_yres;\n\tstruct fb_var_screeninfo default_var;\n\tint rc;\n\tu32 viafb_par_length;\n\n\tDEBUG_MSG(KERN_INFO \"VIAFB PCI Probe!!\\n\");\n\tmemset(&default_var, 0, sizeof(default_var));\n\tviafb_par_length = ALIGN(sizeof(struct viafb_par), BITS_PER_LONG/8);\n\n\t \n\tviafbinfo = framebuffer_alloc(viafb_par_length +\n\t\tALIGN(sizeof(struct viafb_shared), BITS_PER_LONG/8),\n\t\t&vdev->pdev->dev);\n\tif (!viafbinfo)\n\t\treturn -ENOMEM;\n\n\tviaparinfo = (struct viafb_par *)viafbinfo->par;\n\tviaparinfo->shared = viafbinfo->par + viafb_par_length;\n\tviaparinfo->shared->vdev = vdev;\n\tviaparinfo->vram_addr = 0;\n\tviaparinfo->tmds_setting_info = &viaparinfo->shared->tmds_setting_info;\n\tviaparinfo->lvds_setting_info = &viaparinfo->shared->lvds_setting_info;\n\tviaparinfo->lvds_setting_info2 =\n\t\t&viaparinfo->shared->lvds_setting_info2;\n\tviaparinfo->chip_info = &viaparinfo->shared->chip_info;\n\n\ti2c_bus_probe(viaparinfo->shared);\n\tif (viafb_dual_fb)\n\t\tviafb_SAMM_ON = 1;\n\tparse_lcd_port();\n\tparse_dvi_port();\n\n\tviafb_init_chip_info(vdev->chip_type);\n\t \n\tviaparinfo->fbmem = vdev->fbmem_start;\n\tviaparinfo->memsize = vdev->fbmem_len;\n\tviaparinfo->fbmem_free = viaparinfo->memsize;\n\tviaparinfo->fbmem_used = 0;\n\tviafbinfo->screen_base = vdev->fbmem;\n\n\tviafbinfo->fix.mmio_start = vdev->engine_start;\n\tviafbinfo->fix.mmio_len = vdev->engine_len;\n\tviafbinfo->node = 0;\n\tviafbinfo->fbops = &viafb_ops;\n\tviafbinfo->flags = FBINFO_HWACCEL_YPAN;\n\n\tviafbinfo->pseudo_palette = pseudo_pal;\n\tif (viafb_accel && !viafb_setup_engine(viafbinfo)) {\n\t\tviafbinfo->flags |= FBINFO_HWACCEL_COPYAREA |\n\t\t\tFBINFO_HWACCEL_FILLRECT |  FBINFO_HWACCEL_IMAGEBLIT;\n\t\tdefault_var.accel_flags = FB_ACCELF_TEXT;\n\t} else {\n\t\tviafbinfo->flags |= FBINFO_HWACCEL_DISABLED;\n\t\tdefault_var.accel_flags = 0;\n\t}\n\n\tif (viafb_second_size && (viafb_second_size < 8)) {\n\t\tviafb_second_offset = viaparinfo->fbmem_free -\n\t\t\tviafb_second_size * 1024 * 1024;\n\t} else {\n\t\tviafb_second_size = 8;\n\t\tviafb_second_offset = viaparinfo->fbmem_free -\n\t\t\tviafb_second_size * 1024 * 1024;\n\t}\n\n\tparse_mode(viafb_mode, viaparinfo->shared->iga1_devices,\n\t\t&default_xres, &default_yres);\n\tif (viafb_SAMM_ON == 1)\n\t\tparse_mode(viafb_mode1, viaparinfo->shared->iga2_devices,\n\t\t\t&viafb_second_xres, &viafb_second_yres);\n\n\tdefault_var.xres = default_xres;\n\tdefault_var.yres = default_yres;\n\tdefault_var.xres_virtual = default_xres;\n\tdefault_var.yres_virtual = default_yres;\n\tdefault_var.bits_per_pixel = viafb_bpp;\n\tviafb_fill_var_timing_info(&default_var, viafb_get_best_mode(\n\t\tdefault_var.xres, default_var.yres, viafb_refresh));\n\tviafb_setup_fixinfo(&viafbinfo->fix, viaparinfo);\n\tviafbinfo->var = default_var;\n\n\tif (viafb_dual_fb) {\n\t\tviafbinfo1 = framebuffer_alloc(viafb_par_length,\n\t\t\t\t&vdev->pdev->dev);\n\t\tif (!viafbinfo1) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fb_release;\n\t\t}\n\t\tviaparinfo1 = viafbinfo1->par;\n\t\tmemcpy(viaparinfo1, viaparinfo, viafb_par_length);\n\t\tviaparinfo1->vram_addr = viafb_second_offset;\n\t\tviaparinfo1->memsize = viaparinfo->memsize -\n\t\t\tviafb_second_offset;\n\t\tviaparinfo->memsize = viafb_second_offset;\n\t\tviaparinfo1->fbmem = viaparinfo->fbmem + viafb_second_offset;\n\n\t\tviaparinfo1->fbmem_used = viaparinfo->fbmem_used;\n\t\tviaparinfo1->fbmem_free = viaparinfo1->memsize -\n\t\t\tviaparinfo1->fbmem_used;\n\t\tviaparinfo->fbmem_free = viaparinfo->memsize;\n\t\tviaparinfo->fbmem_used = 0;\n\n\t\tviaparinfo->iga_path = IGA1;\n\t\tviaparinfo1->iga_path = IGA2;\n\t\tmemcpy(viafbinfo1, viafbinfo, sizeof(struct fb_info));\n\t\tviafbinfo1->par = viaparinfo1;\n\t\tviafbinfo1->screen_base = viafbinfo->screen_base +\n\t\t\tviafb_second_offset;\n\n\t\tdefault_var.xres = viafb_second_xres;\n\t\tdefault_var.yres = viafb_second_yres;\n\t\tdefault_var.xres_virtual = viafb_second_xres;\n\t\tdefault_var.yres_virtual = viafb_second_yres;\n\t\tdefault_var.bits_per_pixel = viafb_bpp1;\n\t\tviafb_fill_var_timing_info(&default_var, viafb_get_best_mode(\n\t\t\tdefault_var.xres, default_var.yres, viafb_refresh1));\n\n\t\tviafb_setup_fixinfo(&viafbinfo1->fix, viaparinfo1);\n\t\tviafb_check_var(&default_var, viafbinfo1);\n\t\tviafbinfo1->var = default_var;\n\t\tviafb_update_fix(viafbinfo1);\n\t\tviaparinfo1->depth = fb_get_color_depth(&viafbinfo1->var,\n\t\t\t&viafbinfo1->fix);\n\t}\n\n\tviafb_check_var(&viafbinfo->var, viafbinfo);\n\tviafb_update_fix(viafbinfo);\n\tviaparinfo->depth = fb_get_color_depth(&viafbinfo->var,\n\t\t&viafbinfo->fix);\n\tdefault_var.activate = FB_ACTIVATE_NOW;\n\trc = fb_alloc_cmap(&viafbinfo->cmap, 256, 0);\n\tif (rc)\n\t\tgoto out_fb1_release;\n\n\tif (viafb_dual_fb && (viafb_primary_dev == LCD_Device)\n\t    && (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)) {\n\t\trc = register_framebuffer(viafbinfo1);\n\t\tif (rc)\n\t\t\tgoto out_dealloc_cmap;\n\t}\n\trc = register_framebuffer(viafbinfo);\n\tif (rc)\n\t\tgoto out_fb1_unreg_lcd_cle266;\n\n\tif (viafb_dual_fb && ((viafb_primary_dev != LCD_Device)\n\t\t\t|| (viaparinfo->chip_info->gfx_chip_name !=\n\t\t\tUNICHROME_CLE266))) {\n\t\trc = register_framebuffer(viafbinfo1);\n\t\tif (rc)\n\t\t\tgoto out_fb_unreg;\n\t}\n\tDEBUG_MSG(KERN_INFO \"fb%d: %s frame buffer device %dx%d-%dbpp\\n\",\n\t\t  viafbinfo->node, viafbinfo->fix.id, default_var.xres,\n\t\t  default_var.yres, default_var.bits_per_pixel);\n\n\tviafb_init_proc(viaparinfo->shared);\n\tviafb_init_dac(IGA2);\n\n#ifdef CONFIG_PM\n\tviafb_pm_register(&viafb_fb_pm_hooks);\n#endif\n\treturn 0;\n\nout_fb_unreg:\n\tunregister_framebuffer(viafbinfo);\nout_fb1_unreg_lcd_cle266:\n\tif (viafb_dual_fb && (viafb_primary_dev == LCD_Device)\n\t    && (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266))\n\t\tunregister_framebuffer(viafbinfo1);\nout_dealloc_cmap:\n\tfb_dealloc_cmap(&viafbinfo->cmap);\nout_fb1_release:\n\tframebuffer_release(viafbinfo1);\nout_fb_release:\n\ti2c_bus_free(viaparinfo->shared);\n\tframebuffer_release(viafbinfo);\n\treturn rc;\n}\n\nvoid via_fb_pci_remove(struct pci_dev *pdev)\n{\n\tDEBUG_MSG(KERN_INFO \"via_pci_remove!\\n\");\n\tfb_dealloc_cmap(&viafbinfo->cmap);\n\tunregister_framebuffer(viafbinfo);\n\tif (viafb_dual_fb)\n\t\tunregister_framebuffer(viafbinfo1);\n\tviafb_remove_proc(viaparinfo->shared);\n\ti2c_bus_free(viaparinfo->shared);\n\tframebuffer_release(viafbinfo);\n\tif (viafb_dual_fb)\n\t\tframebuffer_release(viafbinfo1);\n}\n\n#ifndef MODULE\nstatic int __init viafb_setup(void)\n{\n\tchar *this_opt;\n\tchar *options;\n\n\tDEBUG_MSG(KERN_INFO \"viafb_setup!\\n\");\n\n\tif (fb_get_options(\"viafb\", &options))\n\t\treturn -ENODEV;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\n\t\tif (!strncmp(this_opt, \"viafb_mode1=\", 12)) {\n\t\t\tviafb_mode1 = kstrdup(this_opt + 12, GFP_KERNEL);\n\t\t\tif (!viafb_mode1)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!strncmp(this_opt, \"viafb_mode=\", 11)) {\n\t\t\tviafb_mode = kstrdup(this_opt + 11, GFP_KERNEL);\n\t\t\tif (!viafb_mode)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!strncmp(this_opt, \"viafb_bpp1=\", 11)) {\n\t\t\tif (kstrtouint(this_opt + 11, 0, &viafb_bpp1) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt, \"viafb_bpp=\", 10)) {\n\t\t\tif (kstrtouint(this_opt + 10, 0, &viafb_bpp) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt, \"viafb_refresh1=\", 15)) {\n\t\t\tif (kstrtoint(this_opt + 15, 0, &viafb_refresh1) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt, \"viafb_refresh=\", 14)) {\n\t\t\tif (kstrtoint(this_opt + 14, 0, &viafb_refresh) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt, \"viafb_lcd_dsp_method=\", 21)) {\n\t\t\tif (kstrtoint(this_opt + 21, 0,\n\t\t\t\t      &viafb_lcd_dsp_method) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt, \"viafb_lcd_panel_id=\", 19)) {\n\t\t\tif (kstrtoint(this_opt + 19, 0,\n\t\t\t\t      &viafb_lcd_panel_id) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt, \"viafb_accel=\", 12)) {\n\t\t\tif (kstrtoint(this_opt + 12, 0, &viafb_accel) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt, \"viafb_SAMM_ON=\", 14)) {\n\t\t\tif (kstrtoint(this_opt + 14, 0, &viafb_SAMM_ON) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt, \"viafb_active_dev=\", 17)) {\n\t\t\tviafb_active_dev = kstrdup(this_opt + 17, GFP_KERNEL);\n\t\t\tif (!viafb_active_dev)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!strncmp(this_opt,\n\t\t\t\"viafb_display_hardware_layout=\", 30)) {\n\t\t\tif (kstrtoint(this_opt + 30, 0,\n\t\t\t\t      &viafb_display_hardware_layout) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt, \"viafb_second_size=\", 18)) {\n\t\t\tif (kstrtoint(this_opt + 18, 0, &viafb_second_size) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt,\n\t\t\t\"viafb_platform_epia_dvi=\", 24)) {\n\t\t\tif (kstrtoint(this_opt + 24, 0,\n\t\t\t\t      &viafb_platform_epia_dvi) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt,\n\t\t\t\"viafb_device_lcd_dualedge=\", 26)) {\n\t\t\tif (kstrtoint(this_opt + 26, 0,\n\t\t\t\t      &viafb_device_lcd_dualedge) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt, \"viafb_bus_width=\", 16)) {\n\t\t\tif (kstrtoint(this_opt + 16, 0, &viafb_bus_width) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt, \"viafb_lcd_mode=\", 15)) {\n\t\t\tif (kstrtoint(this_opt + 15, 0, &viafb_lcd_mode) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(this_opt, \"viafb_lcd_port=\", 15)) {\n\t\t\tviafb_lcd_port = kstrdup(this_opt + 15, GFP_KERNEL);\n\t\t\tif (!viafb_lcd_port)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!strncmp(this_opt, \"viafb_dvi_port=\", 15)) {\n\t\t\tviafb_dvi_port = kstrdup(this_opt + 15, GFP_KERNEL);\n\t\t\tif (!viafb_dvi_port)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\n \nint __init viafb_init(void)\n{\n\tu32 dummy_x, dummy_y;\n\tint r = 0;\n\n\tif (machine_is_olpc())\n\t\t \n\t\tviafb_lcd_panel_id = 23;\n\n#ifndef MODULE\n\tr = viafb_setup();\n\tif (r < 0)\n\t\treturn r;\n#endif\n\tif (parse_mode(viafb_mode, 0, &dummy_x, &dummy_y)\n\t\t|| !viafb_get_best_mode(dummy_x, dummy_y, viafb_refresh)\n\t\t|| parse_mode(viafb_mode1, 0, &dummy_x, &dummy_y)\n\t\t|| !viafb_get_best_mode(dummy_x, dummy_y, viafb_refresh1)\n\t\t|| viafb_bpp < 0 || viafb_bpp > 32\n\t\t|| viafb_bpp1 < 0 || viafb_bpp1 > 32\n\t\t|| parse_active_dev())\n\t\treturn -EINVAL;\n\n\tprintk(KERN_INFO\n       \"VIA Graphics Integration Chipset framebuffer %d.%d initializing\\n\",\n\t       VERSION_MAJOR, VERSION_MINOR);\n\treturn r;\n}\n\nvoid __exit viafb_exit(void)\n{\n\tDEBUG_MSG(KERN_INFO \"viafb_exit!\\n\");\n}\n\nstatic struct fb_ops viafb_ops = {\n\t.owner = THIS_MODULE,\n\t.fb_open = viafb_open,\n\t.fb_release = viafb_release,\n\t.fb_check_var = viafb_check_var,\n\t.fb_set_par = viafb_set_par,\n\t.fb_setcolreg = viafb_setcolreg,\n\t.fb_pan_display = viafb_pan_display,\n\t.fb_blank = viafb_blank,\n\t.fb_fillrect = viafb_fillrect,\n\t.fb_copyarea = viafb_copyarea,\n\t.fb_imageblit = viafb_imageblit,\n\t.fb_cursor = viafb_cursor,\n\t.fb_ioctl = viafb_ioctl,\n\t.fb_sync = viafb_sync,\n};\n\n\n#ifdef MODULE\nmodule_param(viafb_mode, charp, S_IRUSR);\nMODULE_PARM_DESC(viafb_mode, \"Set resolution (default=640x480)\");\n\nmodule_param(viafb_mode1, charp, S_IRUSR);\nMODULE_PARM_DESC(viafb_mode1, \"Set resolution (default=640x480)\");\n\nmodule_param(viafb_bpp, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_bpp, \"Set color depth (default=32bpp)\");\n\nmodule_param(viafb_bpp1, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_bpp1, \"Set color depth (default=32bpp)\");\n\nmodule_param(viafb_refresh, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_refresh,\n\t\"Set CRT viafb_refresh rate (default = 60)\");\n\nmodule_param(viafb_refresh1, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_refresh1,\n\t\"Set CRT refresh rate (default = 60)\");\n\nmodule_param(viafb_lcd_panel_id, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_lcd_panel_id,\n\t\"Set Flat Panel type(Default=1024x768)\");\n\nmodule_param(viafb_lcd_dsp_method, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_lcd_dsp_method,\n\t\"Set Flat Panel display scaling method.(Default=Expansion)\");\n\nmodule_param(viafb_SAMM_ON, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_SAMM_ON,\n\t\"Turn on/off flag of SAMM(Default=OFF)\");\n\nmodule_param(viafb_accel, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_accel,\n\t\"Set 2D Hardware Acceleration: 0 = OFF, 1 = ON (default)\");\n\nmodule_param(viafb_active_dev, charp, S_IRUSR);\nMODULE_PARM_DESC(viafb_active_dev, \"Specify active devices.\");\n\nmodule_param(viafb_display_hardware_layout, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_display_hardware_layout,\n\t\"Display Hardware Layout (LCD Only, DVI Only...,etc)\");\n\nmodule_param(viafb_second_size, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_second_size,\n\t\"Set secondary device memory size\");\n\nmodule_param(viafb_dual_fb, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_dual_fb,\n\t\"Turn on/off flag of dual framebuffer devices.(Default = OFF)\");\n\nmodule_param(viafb_platform_epia_dvi, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_platform_epia_dvi,\n\t\"Turn on/off flag of DVI devices on EPIA board.(Default = OFF)\");\n\nmodule_param(viafb_device_lcd_dualedge, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_device_lcd_dualedge,\n\t\"Turn on/off flag of dual edge panel.(Default = OFF)\");\n\nmodule_param(viafb_bus_width, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_bus_width,\n\t\"Set bus width of panel.(Default = 12)\");\n\nmodule_param(viafb_lcd_mode, int, S_IRUSR);\nMODULE_PARM_DESC(viafb_lcd_mode,\n\t\"Set Flat Panel mode(Default=OPENLDI)\");\n\nmodule_param(viafb_lcd_port, charp, S_IRUSR);\nMODULE_PARM_DESC(viafb_lcd_port, \"Specify LCD output port.\");\n\nmodule_param(viafb_dvi_port, charp, S_IRUSR);\nMODULE_PARM_DESC(viafb_dvi_port, \"Specify DVI output port.\");\n\nMODULE_LICENSE(\"GPL\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}