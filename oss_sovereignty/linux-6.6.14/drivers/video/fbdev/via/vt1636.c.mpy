{
  "module_name": "vt1636.c",
  "hash_id": "a9637e1947e404cf329c0f7b652e0d258d462c1a24d441fe515b88da9f47de7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/via/vt1636.c",
  "human_readable_source": "\n \n\n#include <linux/via-core.h>\n#include <linux/via_i2c.h>\n#include \"global.h\"\n\nstatic const struct IODATA common_init_data[] = {\n \n\t \n\t{0x10, 0xC0, 0x00},\n\t \n\t{0x0B, 0xFF, 0x40},\n\t \n\t{0x0C, 0xFF, 0x31},\n\t \n\t{0x0D, 0xFF, 0x31},\n\t \n\t{0x0E, 0xFF, 0x68},\n\t \n\t{0x0F, 0xFF, 0x68},\n\t \n\t{0x09, 0xA0, 0xA0},\n\t \n\t{0x10, 0x33, 0x13}\n};\n\n \nstatic const struct IODATA dual_channel_enable_data = {0x08, 0xF0, 0xE0};\nstatic const struct IODATA single_channel_enable_data = {0x08, 0xF0, 0x00};\nstatic const struct IODATA dithering_enable_data = {0x0A, 0x70, 0x50};\nstatic const struct IODATA dithering_disable_data = {0x0A, 0x70, 0x00};\nstatic const struct IODATA vdd_on_data = {0x10, 0x20, 0x20};\nstatic const struct IODATA vdd_off_data = {0x10, 0x20, 0x00};\n\nu8 viafb_gpio_i2c_read_lvds(struct lvds_setting_information\n\t*plvds_setting_info, struct lvds_chip_information *plvds_chip_info,\n\tu8 index)\n{\n\tu8 data;\n\n\tviafb_i2c_readbyte(plvds_chip_info->i2c_port,\n\t\t\t   plvds_chip_info->lvds_chip_slave_addr, index, &data);\n\treturn data;\n}\n\nvoid viafb_gpio_i2c_write_mask_lvds(struct lvds_setting_information\n\t\t\t      *plvds_setting_info, struct lvds_chip_information\n\t\t\t      *plvds_chip_info, struct IODATA io_data)\n{\n\tint index, data;\n\n\tindex = io_data.Index;\n\tdata = viafb_gpio_i2c_read_lvds(plvds_setting_info, plvds_chip_info,\n\t\tindex);\n\tdata = (data & (~io_data.Mask)) | io_data.Data;\n\n\tviafb_i2c_writebyte(plvds_chip_info->i2c_port,\n\t\t\t    plvds_chip_info->lvds_chip_slave_addr, index, data);\n}\n\nvoid viafb_init_lvds_vt1636(struct lvds_setting_information\n\t*plvds_setting_info, struct lvds_chip_information *plvds_chip_info)\n{\n\tint reg_num, i;\n\n\t \n\treg_num = ARRAY_SIZE(common_init_data);\n\tfor (i = 0; i < reg_num; i++)\n\t\tviafb_gpio_i2c_write_mask_lvds(plvds_setting_info,\n\t\t\tplvds_chip_info, common_init_data[i]);\n\n\t \n\tif (plvds_setting_info->device_lcd_dualedge)\n\t\tviafb_gpio_i2c_write_mask_lvds(plvds_setting_info,\n\t\t\tplvds_chip_info, dual_channel_enable_data);\n\telse\n\t\tviafb_gpio_i2c_write_mask_lvds(plvds_setting_info,\n\t\t\tplvds_chip_info, single_channel_enable_data);\n\n\tif (plvds_setting_info->LCDDithering)\n\t\tviafb_gpio_i2c_write_mask_lvds(plvds_setting_info,\n\t\t\tplvds_chip_info, dithering_enable_data);\n\telse\n\t\tviafb_gpio_i2c_write_mask_lvds(plvds_setting_info,\n\t\t\tplvds_chip_info, dithering_disable_data);\n}\n\nvoid viafb_enable_lvds_vt1636(struct lvds_setting_information\n\t\t\t*plvds_setting_info,\n\t\t\tstruct lvds_chip_information *plvds_chip_info)\n{\n\tviafb_gpio_i2c_write_mask_lvds(plvds_setting_info, plvds_chip_info,\n\t\tvdd_on_data);\n}\n\nvoid viafb_disable_lvds_vt1636(struct lvds_setting_information\n\t\t\t *plvds_setting_info,\n\t\t\t struct lvds_chip_information *plvds_chip_info)\n{\n\tviafb_gpio_i2c_write_mask_lvds(plvds_setting_info, plvds_chip_info,\n\t\tvdd_off_data);\n}\n\nbool viafb_lvds_identify_vt1636(u8 i2c_adapter)\n{\n\tu8 Buffer[2];\n\n\tDEBUG_MSG(KERN_INFO \"viafb_lvds_identify_vt1636.\\n\");\n\n\t \n\tviaparinfo->chip_info->lvds_chip_info.lvds_chip_slave_addr =\n\t\tVT1636_LVDS_I2C_ADDR;\n\n\t \n\tif (viafb_i2c_readbyte(i2c_adapter, VT1636_LVDS_I2C_ADDR,\n\t\t\t\t\t0x00, &Buffer[0]))\n\t\treturn false;\n\tviafb_i2c_readbyte(i2c_adapter, VT1636_LVDS_I2C_ADDR, 0x01, &Buffer[1]);\n\n\tif (!((Buffer[0] == 0x06) && (Buffer[1] == 0x11)))\n\t\treturn false;\n\n\t \n\tviafb_i2c_readbyte(i2c_adapter, VT1636_LVDS_I2C_ADDR, 0x02, &Buffer[0]);\n\tviafb_i2c_readbyte(i2c_adapter, VT1636_LVDS_I2C_ADDR, 0x03, &Buffer[1]);\n\tif ((Buffer[0] == 0x45) && (Buffer[1] == 0x33)) {\n\t\tviaparinfo->chip_info->lvds_chip_info.lvds_chip_name =\n\t\t\tVT1636_LVDS;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int get_clk_range_index(u32 Clk)\n{\n\tif (Clk < DPA_CLK_30M)\n\t\treturn DPA_CLK_RANGE_30M;\n\telse if (Clk < DPA_CLK_50M)\n\t\treturn DPA_CLK_RANGE_30_50M;\n\telse if (Clk < DPA_CLK_70M)\n\t\treturn DPA_CLK_RANGE_50_70M;\n\telse if (Clk < DPA_CLK_100M)\n\t\treturn DPA_CLK_RANGE_70_100M;\n\telse if (Clk < DPA_CLK_150M)\n\t\treturn DPA_CLK_RANGE_100_150M;\n\telse\n\t\treturn DPA_CLK_RANGE_150M;\n}\n\nstatic void set_dpa_vt1636(struct lvds_setting_information\n\t*plvds_setting_info, struct lvds_chip_information *plvds_chip_info,\n\t\t    struct VT1636_DPA_SETTING *p_vt1636_dpa_setting)\n{\n\tstruct IODATA io_data;\n\n\tio_data.Index = 0x09;\n\tio_data.Mask = 0x1F;\n\tio_data.Data = p_vt1636_dpa_setting->CLK_SEL_ST1;\n\tviafb_gpio_i2c_write_mask_lvds(plvds_setting_info,\n\t\tplvds_chip_info, io_data);\n\n\tio_data.Index = 0x08;\n\tio_data.Mask = 0x0F;\n\tio_data.Data = p_vt1636_dpa_setting->CLK_SEL_ST2;\n\tviafb_gpio_i2c_write_mask_lvds(plvds_setting_info, plvds_chip_info,\n\t\tio_data);\n}\n\nvoid viafb_vt1636_patch_skew_on_vt3324(\n\tstruct lvds_setting_information *plvds_setting_info,\n\tstruct lvds_chip_information *plvds_chip_info)\n{\n\tstruct VT1636_DPA_SETTING dpa = {0x00, 0x00}, dpa_16x12 = {0x0B, 0x03},\n\t\t*pdpa;\n\tint index;\n\n\tDEBUG_MSG(KERN_INFO \"viafb_vt1636_patch_skew_on_vt3324.\\n\");\n\n\t \n\tindex = get_clk_range_index(plvds_setting_info->vclk);\n\tviafb_set_dpa_gfx(plvds_chip_info->output_interface,\n\t\t    &GFX_DPA_SETTING_TBL_VT3324[index]);\n\n\t \n\tif (plvds_setting_info->lcd_panel_hres == 1600 &&\n\t\tplvds_setting_info->lcd_panel_vres == 1200)\n\t\tpdpa = &dpa_16x12;\n\telse\n\t\tpdpa = &dpa;\n\n\tset_dpa_vt1636(plvds_setting_info, plvds_chip_info, pdpa);\n}\n\nvoid viafb_vt1636_patch_skew_on_vt3327(\n\tstruct lvds_setting_information *plvds_setting_info,\n\tstruct lvds_chip_information *plvds_chip_info)\n{\n\tstruct VT1636_DPA_SETTING dpa = {0x00, 0x00};\n\tint index;\n\n\tDEBUG_MSG(KERN_INFO \"viafb_vt1636_patch_skew_on_vt3327.\\n\");\n\n\t \n\tindex = get_clk_range_index(plvds_setting_info->vclk);\n\tviafb_set_dpa_gfx(plvds_chip_info->output_interface,\n\t\t    &GFX_DPA_SETTING_TBL_VT3327[index]);\n\n\t \n\tset_dpa_vt1636(plvds_setting_info, plvds_chip_info, &dpa);\n}\n\nvoid viafb_vt1636_patch_skew_on_vt3364(\n\tstruct lvds_setting_information *plvds_setting_info,\n\tstruct lvds_chip_information *plvds_chip_info)\n{\n\tint index;\n\n\tDEBUG_MSG(KERN_INFO \"viafb_vt1636_patch_skew_on_vt3364.\\n\");\n\n\t \n\tindex = get_clk_range_index(plvds_setting_info->vclk);\n\tviafb_set_dpa_gfx(plvds_chip_info->output_interface,\n\t\t    &GFX_DPA_SETTING_TBL_VT3364[index]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}