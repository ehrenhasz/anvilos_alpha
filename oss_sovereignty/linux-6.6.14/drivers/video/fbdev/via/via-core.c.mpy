{
  "module_name": "via-core.c",
  "hash_id": "4e11bbb938989c2988d9e55c9247d82994927e65f9268e179d5edee0cd7a3893",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/via/via-core.c",
  "human_readable_source": "\n \n\n \n#include <linux/aperture.h>\n#include <linux/via-core.h>\n#include <linux/via_i2c.h>\n#include \"via-gpio.h\"\n#include \"global.h\"\n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/list.h>\n#include <linux/pm.h>\n\n \nstatic struct via_port_cfg adap_configs[] = {\n\t[VIA_PORT_26]\t= { VIA_PORT_I2C,  VIA_MODE_I2C, VIASR, 0x26 },\n\t[VIA_PORT_31]\t= { VIA_PORT_I2C,  VIA_MODE_I2C, VIASR, 0x31 },\n\t[VIA_PORT_25]\t= { VIA_PORT_GPIO, VIA_MODE_GPIO, VIASR, 0x25 },\n\t[VIA_PORT_2C]\t= { VIA_PORT_GPIO, VIA_MODE_I2C, VIASR, 0x2c },\n\t[VIA_PORT_3D]\t= { VIA_PORT_GPIO, VIA_MODE_GPIO, VIASR, 0x3d },\n\t{ 0, 0, 0, 0 }\n};\n\n \nstatic struct via_port_cfg olpc_adap_configs[] = {\n\t[VIA_PORT_26]\t= { VIA_PORT_I2C,  VIA_MODE_I2C, VIASR, 0x26 },\n\t[VIA_PORT_31]\t= { VIA_PORT_I2C,  VIA_MODE_I2C, VIASR, 0x31 },\n\t[VIA_PORT_25]\t= { VIA_PORT_GPIO, VIA_MODE_GPIO, VIASR, 0x25 },\n\t[VIA_PORT_2C]\t= { VIA_PORT_GPIO, VIA_MODE_GPIO, VIASR, 0x2c },\n\t[VIA_PORT_3D]\t= { VIA_PORT_GPIO, VIA_MODE_GPIO, VIASR, 0x3d },\n\t{ 0, 0, 0, 0 }\n};\n\n \nstatic struct viafb_dev global_dev;\n\n\n \nstatic inline void viafb_mmio_write(int reg, u32 v)\n{\n\tiowrite32(v, global_dev.engine_mmio + reg);\n}\n\nstatic inline int viafb_mmio_read(int reg)\n{\n\treturn ioread32(global_dev.engine_mmio + reg);\n}\n\n \n \n\n \nstatic u32 viafb_enabled_ints;\n\nstatic void viafb_int_init(void)\n{\n\tviafb_enabled_ints = 0;\n\n\tviafb_mmio_write(VDE_INTERRUPT, 0);\n}\n\n \nvoid viafb_irq_enable(u32 mask)\n{\n\tviafb_enabled_ints |= mask;\n\tviafb_mmio_write(VDE_INTERRUPT, viafb_enabled_ints | VDE_I_ENABLE);\n}\nEXPORT_SYMBOL_GPL(viafb_irq_enable);\n\nvoid viafb_irq_disable(u32 mask)\n{\n\tviafb_enabled_ints &= ~mask;\n\tif (viafb_enabled_ints == 0)\n\t\tviafb_mmio_write(VDE_INTERRUPT, 0);   \n\telse\n\t\tviafb_mmio_write(VDE_INTERRUPT,\n\t\t\t\tviafb_enabled_ints | VDE_I_ENABLE);\n}\nEXPORT_SYMBOL_GPL(viafb_irq_disable);\n\n \n \n#if IS_ENABLED(CONFIG_VIDEO_VIA_CAMERA)\n \n\n \nstatic int viafb_dma_users;\nstatic DECLARE_COMPLETION(viafb_dma_completion);\n \nstatic DEFINE_MUTEX(viafb_dma_lock);\n\n \nstruct viafb_vx855_dma_descr {\n\tu32\taddr_low;\t \n\tu32\taddr_high;\t \n\tu32\tfb_offset;\t \n\tu32\tseg_size;\t \n\tu32\ttile_mode;\t \n\tu32\tnext_desc_low;\t \n\tu32\tnext_desc_high;\n\tu32\tpad;\t\t \n};\n\n \n#define VIAFB_DMA_MAGIC\t\t0x01   \n#define VIAFB_DMA_FINAL_SEGMENT 0x02   \n\n \nstatic irqreturn_t viafb_dma_irq(int irq, void *data)\n{\n\tint csr;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tspin_lock(&global_dev.reg_lock);\n\tcsr = viafb_mmio_read(VDMA_CSR0);\n\tif (csr & VDMA_C_DONE) {\n\t\tviafb_mmio_write(VDMA_CSR0, VDMA_C_DONE);\n\t\tcomplete(&viafb_dma_completion);\n\t\tret = IRQ_HANDLED;\n\t}\n\tspin_unlock(&global_dev.reg_lock);\n\treturn ret;\n}\n\n \nint viafb_request_dma(void)\n{\n\tint ret = 0;\n\n\t \n\tif (global_dev.chip_type != UNICHROME_VX855)\n\t\treturn -ENODEV;\n\t \n\tmutex_lock(&viafb_dma_lock);\n\tviafb_dma_users++;\n\tif (viafb_dma_users == 1) {\n\t\tret = request_irq(global_dev.pdev->irq, viafb_dma_irq,\n\t\t\t\tIRQF_SHARED, \"via-dma\", &viafb_dma_users);\n\t\tif (ret)\n\t\t\tviafb_dma_users--;\n\t\telse\n\t\t\tviafb_irq_enable(VDE_I_DMA0TDEN);\n\t}\n\tmutex_unlock(&viafb_dma_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(viafb_request_dma);\n\nvoid viafb_release_dma(void)\n{\n\tmutex_lock(&viafb_dma_lock);\n\tviafb_dma_users--;\n\tif (viafb_dma_users == 0) {\n\t\tviafb_irq_disable(VDE_I_DMA0TDEN);\n\t\tfree_irq(global_dev.pdev->irq, &viafb_dma_users);\n\t}\n\tmutex_unlock(&viafb_dma_lock);\n}\nEXPORT_SYMBOL_GPL(viafb_release_dma);\n\n \nint viafb_dma_copy_out_sg(unsigned int offset, struct scatterlist *sg, int nsg)\n{\n\tstruct viafb_vx855_dma_descr *descr;\n\tvoid *descrpages;\n\tdma_addr_t descr_handle;\n\tunsigned long flags;\n\tint i;\n\tstruct scatterlist *sgentry;\n\tdma_addr_t nextdesc;\n\n\t \n\tdescrpages = dma_alloc_coherent(&global_dev.pdev->dev,\n\t\t\tnsg*sizeof(struct viafb_vx855_dma_descr),\n\t\t\t&descr_handle, GFP_KERNEL);\n\tif (descrpages == NULL) {\n\t\tdev_err(&global_dev.pdev->dev, \"Unable to get descr page.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmutex_lock(&viafb_dma_lock);\n\t \n\tdescr = descrpages;\n\tnextdesc = descr_handle + sizeof(struct viafb_vx855_dma_descr);\n\tfor_each_sg(sg, sgentry, nsg, i) {\n\t\tdma_addr_t paddr = sg_dma_address(sgentry);\n\t\tdescr->addr_low = paddr & 0xfffffff0;\n\t\tdescr->addr_high = ((u64) paddr >> 32) & 0x0fff;\n\t\tdescr->fb_offset = offset;\n\t\tdescr->seg_size = sg_dma_len(sgentry) >> 4;\n\t\tdescr->tile_mode = 0;\n\t\tdescr->next_desc_low = (nextdesc&0xfffffff0) | VIAFB_DMA_MAGIC;\n\t\tdescr->next_desc_high = ((u64) nextdesc >> 32) & 0x0fff;\n\t\tdescr->pad = 0xffffffff;   \n\t\toffset += sg_dma_len(sgentry);\n\t\tnextdesc += sizeof(struct viafb_vx855_dma_descr);\n\t\tdescr++;\n\t}\n\tdescr[-1].next_desc_low = VIAFB_DMA_FINAL_SEGMENT|VIAFB_DMA_MAGIC;\n\t \n\tspin_lock_irqsave(&global_dev.reg_lock, flags);\n\tinit_completion(&viafb_dma_completion);\n\tviafb_mmio_write(VDMA_DQWCR0, 0);\n\tviafb_mmio_write(VDMA_CSR0, VDMA_C_ENABLE|VDMA_C_DONE);\n\tviafb_mmio_write(VDMA_MR0, VDMA_MR_TDIE | VDMA_MR_CHAIN);\n\tviafb_mmio_write(VDMA_DPRL0, descr_handle | VIAFB_DMA_MAGIC);\n\tviafb_mmio_write(VDMA_DPRH0,\n\t\t\t(((u64)descr_handle >> 32) & 0x0fff) | 0xf0000);\n\t(void) viafb_mmio_read(VDMA_CSR0);\n\tviafb_mmio_write(VDMA_CSR0, VDMA_C_ENABLE|VDMA_C_START);\n\tspin_unlock_irqrestore(&global_dev.reg_lock, flags);\n\t \n\twait_for_completion_timeout(&viafb_dma_completion, 1);\n\tmsleep(1);\n\tif ((viafb_mmio_read(VDMA_CSR0)&VDMA_C_DONE) == 0)\n\t\tprintk(KERN_ERR \"VIA DMA timeout!\\n\");\n\t \n\tviafb_mmio_write(VDMA_CSR0, VDMA_C_DONE);\n\tviafb_mmio_write(VDMA_MR0, 0);  \n\tmutex_unlock(&viafb_dma_lock);\n\tdma_free_coherent(&global_dev.pdev->dev,\n\t\t\tnsg*sizeof(struct viafb_vx855_dma_descr), descrpages,\n\t\t\tdescr_handle);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(viafb_dma_copy_out_sg);\n#endif  \n\n \n \nstatic u16 via_function3[] = {\n\tCLE266_FUNCTION3, KM400_FUNCTION3, CN400_FUNCTION3, CN700_FUNCTION3,\n\tCX700_FUNCTION3, KM800_FUNCTION3, KM890_FUNCTION3, P4M890_FUNCTION3,\n\tP4M900_FUNCTION3, VX800_FUNCTION3, VX855_FUNCTION3, VX900_FUNCTION3,\n};\n\n \nstatic int viafb_get_fb_size_from_pci(int chip_type)\n{\n\tint i;\n\tu8 offset = 0;\n\tu32 FBSize;\n\tu32 VideoMemSize;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(via_function3); i++) {\n\t\tstruct pci_dev *pdev;\n\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_VIA, via_function3[i],\n\t\t\t\t      NULL);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tDEBUG_MSG(KERN_INFO \"Device ID = %x\\n\", pdev->device);\n\n\t\tswitch (pdev->device) {\n\t\tcase CLE266_FUNCTION3:\n\t\tcase KM400_FUNCTION3:\n\t\t\toffset = 0xE0;\n\t\t\tbreak;\n\t\tcase CN400_FUNCTION3:\n\t\tcase CN700_FUNCTION3:\n\t\tcase CX700_FUNCTION3:\n\t\tcase KM800_FUNCTION3:\n\t\tcase KM890_FUNCTION3:\n\t\tcase P4M890_FUNCTION3:\n\t\tcase P4M900_FUNCTION3:\n\t\tcase VX800_FUNCTION3:\n\t\tcase VX855_FUNCTION3:\n\t\tcase VX900_FUNCTION3:\n\t\t \n\t\t\toffset = 0xA0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!offset)\n\t\t\tbreak;\n\n\t\tpci_read_config_dword(pdev, offset, &FBSize);\n\t\tpci_dev_put(pdev);\n\t}\n\n\tif (!offset) {\n\t\tprintk(KERN_ERR \"cannot determine framebuffer size\\n\");\n\t\treturn -EIO;\n\t}\n\n\tFBSize = FBSize & 0x00007000;\n\tDEBUG_MSG(KERN_INFO \"FB Size = %x\\n\", FBSize);\n\n\tif (chip_type < UNICHROME_CX700) {\n\t\tswitch (FBSize) {\n\t\tcase 0x00004000:\n\t\t\tVideoMemSize = (16 << 20);\t \n\t\t\tbreak;\n\n\t\tcase 0x00005000:\n\t\t\tVideoMemSize = (32 << 20);\t \n\t\t\tbreak;\n\n\t\tcase 0x00006000:\n\t\t\tVideoMemSize = (64 << 20);\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tVideoMemSize = (32 << 20);\t \n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (FBSize) {\n\t\tcase 0x00001000:\n\t\t\tVideoMemSize = (8 << 20);\t \n\t\t\tbreak;\n\n\t\tcase 0x00002000:\n\t\t\tVideoMemSize = (16 << 20);\t \n\t\t\tbreak;\n\n\t\tcase 0x00003000:\n\t\t\tVideoMemSize = (32 << 20);\t \n\t\t\tbreak;\n\n\t\tcase 0x00004000:\n\t\t\tVideoMemSize = (64 << 20);\t \n\t\t\tbreak;\n\n\t\tcase 0x00005000:\n\t\t\tVideoMemSize = (128 << 20);\t \n\t\t\tbreak;\n\n\t\tcase 0x00006000:\n\t\t\tVideoMemSize = (256 << 20);\t \n\t\t\tbreak;\n\n\t\tcase 0x00007000:\t \n\t\t\tVideoMemSize = (512 << 20);\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tVideoMemSize = (32 << 20);\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn VideoMemSize;\n}\n\n\n \nstatic int via_pci_setup_mmio(struct viafb_dev *vdev)\n{\n\tint ret;\n\t \n\tvdev->engine_start = pci_resource_start(vdev->pdev, 1);\n\tvdev->engine_len = pci_resource_len(vdev->pdev, 1);\n\tvdev->engine_mmio = ioremap(vdev->engine_start,\n\t\t\tvdev->engine_len);\n\tif (vdev->engine_mmio == NULL)\n\t\tdev_err(&vdev->pdev->dev,\n\t\t\t\t\"Unable to map engine MMIO; operation will be \"\n\t\t\t\t\"slow and crippled.\\n\");\n\t \n\tif (vdev->chip_type == UNICHROME_VX900)\n\t\tvdev->fbmem_start = pci_resource_start(vdev->pdev, 2);\n\telse\n\t\tvdev->fbmem_start = pci_resource_start(vdev->pdev, 0);\n\tret = vdev->fbmem_len = viafb_get_fb_size_from_pci(vdev->chip_type);\n\tif (ret < 0)\n\t\tgoto out_unmap;\n\n\t \n\tfor (; vdev->fbmem_len >= 8 << 20; vdev->fbmem_len /= 2) {\n\t\tvdev->fbmem = ioremap_wc(vdev->fbmem_start, vdev->fbmem_len);\n\t\tif (vdev->fbmem)\n\t\t\tbreak;\n\t}\n\n\tif (vdev->fbmem == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\treturn 0;\nout_unmap:\n\tiounmap(vdev->engine_mmio);\n\treturn ret;\n}\n\nstatic void via_pci_teardown_mmio(struct viafb_dev *vdev)\n{\n\tiounmap(vdev->fbmem);\n\tiounmap(vdev->engine_mmio);\n}\n\n \nstatic struct viafb_subdev_info {\n\tchar *name;\n\tstruct platform_device *platdev;\n} viafb_subdevs[] = {\n\t{\n\t\t.name = \"viafb-gpio\",\n\t},\n\t{\n\t\t.name = \"viafb-i2c\",\n\t},\n#if IS_ENABLED(CONFIG_VIDEO_VIA_CAMERA)\n\t{\n\t\t.name = \"viafb-camera\",\n\t},\n#endif\n};\n#define N_SUBDEVS ARRAY_SIZE(viafb_subdevs)\n\nstatic int via_create_subdev(struct viafb_dev *vdev,\n\t\t\t     struct viafb_subdev_info *info)\n{\n\tint ret;\n\n\tinfo->platdev = platform_device_alloc(info->name, -1);\n\tif (!info->platdev) {\n\t\tdev_err(&vdev->pdev->dev, \"Unable to allocate pdev %s\\n\",\n\t\t\tinfo->name);\n\t\treturn -ENOMEM;\n\t}\n\tinfo->platdev->dev.parent = &vdev->pdev->dev;\n\tinfo->platdev->dev.platform_data = vdev;\n\tret = platform_device_add(info->platdev);\n\tif (ret) {\n\t\tdev_err(&vdev->pdev->dev, \"Unable to add pdev %s\\n\",\n\t\t\t\tinfo->name);\n\t\tplatform_device_put(info->platdev);\n\t\tinfo->platdev = NULL;\n\t}\n\treturn ret;\n}\n\nstatic int via_setup_subdevs(struct viafb_dev *vdev)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < N_SUBDEVS; i++)\n\t\tvia_create_subdev(vdev, viafb_subdevs + i);\n\treturn 0;\n}\n\nstatic void via_teardown_subdevs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < N_SUBDEVS; i++)\n\t\tif (viafb_subdevs[i].platdev) {\n\t\t\tviafb_subdevs[i].platdev->dev.platform_data = NULL;\n\t\t\tplatform_device_unregister(viafb_subdevs[i].platdev);\n\t\t}\n}\n\n \nstatic __maybe_unused LIST_HEAD(viafb_pm_hooks);\nstatic __maybe_unused DEFINE_MUTEX(viafb_pm_hooks_lock);\n\nvoid viafb_pm_register(struct viafb_pm_hooks *hooks)\n{\n\tINIT_LIST_HEAD(&hooks->list);\n\n\tmutex_lock(&viafb_pm_hooks_lock);\n\tlist_add_tail(&hooks->list, &viafb_pm_hooks);\n\tmutex_unlock(&viafb_pm_hooks_lock);\n}\nEXPORT_SYMBOL_GPL(viafb_pm_register);\n\nvoid viafb_pm_unregister(struct viafb_pm_hooks *hooks)\n{\n\tmutex_lock(&viafb_pm_hooks_lock);\n\tlist_del(&hooks->list);\n\tmutex_unlock(&viafb_pm_hooks_lock);\n}\nEXPORT_SYMBOL_GPL(viafb_pm_unregister);\n\nstatic int __maybe_unused via_suspend(struct device *dev)\n{\n\tstruct viafb_pm_hooks *hooks;\n\n\t \n\tmutex_lock(&viafb_pm_hooks_lock);\n\tlist_for_each_entry_reverse(hooks, &viafb_pm_hooks, list)\n\t\thooks->suspend(hooks->private);\n\tmutex_unlock(&viafb_pm_hooks_lock);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused via_resume(struct device *dev)\n{\n\tstruct viafb_pm_hooks *hooks;\n\n\t \n\tmutex_lock(&viafb_pm_hooks_lock);\n\tlist_for_each_entry(hooks, &viafb_pm_hooks, list)\n\t\thooks->resume(hooks->private);\n\tmutex_unlock(&viafb_pm_hooks_lock);\n\n\treturn 0;\n}\n\nstatic int via_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint ret;\n\n\tret = aperture_remove_conflicting_pci_devices(pdev, \"viafb\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmemset(&global_dev, 0, sizeof(global_dev));\n\tglobal_dev.pdev = pdev;\n\tglobal_dev.chip_type = ent->driver_data;\n\tglobal_dev.port_cfg = adap_configs;\n\tif (machine_is_olpc())\n\t\tglobal_dev.port_cfg = olpc_adap_configs;\n\n\tspin_lock_init(&global_dev.reg_lock);\n\tret = via_pci_setup_mmio(&global_dev);\n\tif (ret)\n\t\tgoto out_disable;\n\t \n\tviafb_int_init();\n\tvia_setup_subdevs(&global_dev);\n\t \n\tret = via_fb_pci_probe(&global_dev);\n\tif (ret)\n\t\tgoto out_subdevs;\n\treturn 0;\n\nout_subdevs:\n\tvia_teardown_subdevs();\n\tvia_pci_teardown_mmio(&global_dev);\nout_disable:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic void via_pci_remove(struct pci_dev *pdev)\n{\n\tvia_teardown_subdevs();\n\tvia_fb_pci_remove(pdev);\n\tvia_pci_teardown_mmio(&global_dev);\n\tpci_disable_device(pdev);\n}\n\n\nstatic const struct pci_device_id via_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_CLE266_DID),\n\t  .driver_data = UNICHROME_CLE266 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_K400_DID),\n\t  .driver_data = UNICHROME_K400 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_K800_DID),\n\t  .driver_data = UNICHROME_K800 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_PM800_DID),\n\t  .driver_data = UNICHROME_PM800 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_CN700_DID),\n\t  .driver_data = UNICHROME_CN700 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_CX700_DID),\n\t  .driver_data = UNICHROME_CX700 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_CN750_DID),\n\t  .driver_data = UNICHROME_CN750 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_K8M890_DID),\n\t  .driver_data = UNICHROME_K8M890 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_P4M890_DID),\n\t  .driver_data = UNICHROME_P4M890 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_P4M900_DID),\n\t  .driver_data = UNICHROME_P4M900 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_VX800_DID),\n\t  .driver_data = UNICHROME_VX800 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_VX855_DID),\n\t  .driver_data = UNICHROME_VX855 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, UNICHROME_VX900_DID),\n\t  .driver_data = UNICHROME_VX900 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, via_pci_table);\n\nstatic const struct dev_pm_ops via_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= via_suspend,\n\t.resume\t\t= via_resume,\n\t.freeze\t\t= NULL,\n\t.thaw\t\t= via_resume,\n\t.poweroff\t= NULL,\n\t.restore\t= via_resume,\n#endif\n};\n\nstatic struct pci_driver via_driver = {\n\t.name\t\t= \"viafb\",\n\t.id_table\t= via_pci_table,\n\t.probe\t\t= via_pci_probe,\n\t.remove\t\t= via_pci_remove,\n\t.driver.pm\t= &via_pm_ops,\n};\n\nstatic int __init via_core_init(void)\n{\n\tint ret;\n\n\tif (fb_modesetting_disabled(\"viafb\"))\n\t\treturn -ENODEV;\n\n\tret = viafb_init();\n\tif (ret)\n\t\treturn ret;\n\tviafb_i2c_init();\n\tviafb_gpio_init();\n\tret = pci_register_driver(&via_driver);\n\tif (ret) {\n\t\tviafb_gpio_exit();\n\t\tviafb_i2c_exit();\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit via_core_exit(void)\n{\n\tpci_unregister_driver(&via_driver);\n\tviafb_gpio_exit();\n\tviafb_i2c_exit();\n\tviafb_exit();\n}\n\nmodule_init(via_core_init);\nmodule_exit(via_core_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}