{
  "module_name": "dvi.c",
  "hash_id": "cf6c1160bf8a0e340c98697f4fc73fb8363b1e56330538c44222eeefc955e053",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/via/dvi.c",
  "human_readable_source": "\n \n#include <linux/via-core.h>\n#include <linux/via_i2c.h>\n#include \"global.h\"\n\nstatic void tmds_register_write(int index, u8 data);\nstatic int tmds_register_read(int index);\nstatic int tmds_register_read_bytes(int index, u8 *buff, int buff_len);\nstatic void dvi_get_panel_size_from_DDCv1(\n\tstruct tmds_chip_information *tmds_chip,\n\tstruct tmds_setting_information *tmds_setting);\nstatic int viafb_dvi_query_EDID(void);\n\nstatic inline bool check_tmds_chip(int device_id_subaddr, int device_id)\n{\n\treturn tmds_register_read(device_id_subaddr) == device_id;\n}\n\nvoid viafb_init_dvi_size(struct tmds_chip_information *tmds_chip,\n\t\t\t struct tmds_setting_information *tmds_setting)\n{\n\tDEBUG_MSG(KERN_INFO \"viafb_init_dvi_size()\\n\");\n\n\tviafb_dvi_sense();\n\tif (viafb_dvi_query_EDID() == 1)\n\t\tdvi_get_panel_size_from_DDCv1(tmds_chip, tmds_setting);\n\n\treturn;\n}\n\nbool viafb_tmds_trasmitter_identify(void)\n{\n\tunsigned char sr2a = 0, sr1e = 0, sr3e = 0;\n\n\t \n\tswitch (viaparinfo->chip_info->gfx_chip_name) {\n\tcase UNICHROME_K8M890:\n\t     \n\t\tsr2a = viafb_read_reg(VIASR, SR2A);\n\t\tviafb_write_reg_mask(SR2A, VIASR, 0x03, BIT0 + BIT1);\n\t\tbreak;\n\n\tcase UNICHROME_P4M900:\n\tcase UNICHROME_P4M890:\n\t\t \n\t\tsr2a = viafb_read_reg(VIASR, SR2A);\n\t\tviafb_write_reg_mask(SR2A, VIASR, 0x03, BIT0 + BIT1);\n\t\t \n\t\tsr1e = viafb_read_reg(VIASR, SR1E);\n\t\tviafb_write_reg_mask(SR1E, VIASR, 0xC0, BIT6 + BIT7);\n\t\tbreak;\n\n\tdefault:\n\t     \n\t\tsr1e = viafb_read_reg(VIASR, SR1E);\n\t\tviafb_write_reg_mask(SR1E, VIASR, 0xF0, BIT4 +\n\t\t\tBIT5 + BIT6 + BIT7);\n\t     \n\t\tsr3e = viafb_read_reg(VIASR, SR3E);\n\t\tviafb_write_reg_mask(SR3E, VIASR, 0x0, BIT5);\n\t\tbreak;\n\t}\n\n\t \n\tviaparinfo->chip_info->tmds_chip_info.tmds_chip_name = VT1632_TMDS;\n\tviaparinfo->chip_info->\n\t\ttmds_chip_info.tmds_chip_slave_addr = VT1632_TMDS_I2C_ADDR;\n\tviaparinfo->chip_info->tmds_chip_info.i2c_port = VIA_PORT_31;\n\tif (check_tmds_chip(VT1632_DEVICE_ID_REG, VT1632_DEVICE_ID)) {\n\t\t \n\t\ttmds_register_write(0x08, 0x3b);\n\n\t\tDEBUG_MSG(KERN_INFO \"\\n VT1632 TMDS ! \\n\");\n\t\tDEBUG_MSG(KERN_INFO \"\\n %2d\",\n\t\t\t  viaparinfo->chip_info->tmds_chip_info.tmds_chip_name);\n\t\tDEBUG_MSG(KERN_INFO \"\\n %2d\",\n\t\t\t  viaparinfo->chip_info->tmds_chip_info.i2c_port);\n\t\treturn true;\n\t} else {\n\t\tviaparinfo->chip_info->tmds_chip_info.i2c_port = VIA_PORT_2C;\n\t\tif (check_tmds_chip(VT1632_DEVICE_ID_REG, VT1632_DEVICE_ID)) {\n\t\t\ttmds_register_write(0x08, 0x3b);\n\t\t\tDEBUG_MSG(KERN_INFO \"\\n VT1632 TMDS ! \\n\");\n\t\t\tDEBUG_MSG(KERN_INFO \"\\n %2d\",\n\t\t\t\t  viaparinfo->chip_info->\n\t\t\t\t  tmds_chip_info.tmds_chip_name);\n\t\t\tDEBUG_MSG(KERN_INFO \"\\n %2d\",\n\t\t\t\t  viaparinfo->chip_info->\n\t\t\t\t  tmds_chip_info.i2c_port);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tviaparinfo->chip_info->tmds_chip_info.tmds_chip_name = INTEGRATED_TMDS;\n\n\tif ((viaparinfo->chip_info->gfx_chip_name == UNICHROME_CX700) &&\n\t    ((viafb_display_hardware_layout == HW_LAYOUT_DVI_ONLY) ||\n\t     (viafb_display_hardware_layout == HW_LAYOUT_LCD_DVI))) {\n\t\tDEBUG_MSG(KERN_INFO \"\\n Integrated TMDS ! \\n\");\n\t\treturn true;\n\t}\n\n\tswitch (viaparinfo->chip_info->gfx_chip_name) {\n\tcase UNICHROME_K8M890:\n\t\tviafb_write_reg(SR2A, VIASR, sr2a);\n\t\tbreak;\n\n\tcase UNICHROME_P4M900:\n\tcase UNICHROME_P4M890:\n\t\tviafb_write_reg(SR2A, VIASR, sr2a);\n\t\tviafb_write_reg(SR1E, VIASR, sr1e);\n\t\tbreak;\n\n\tdefault:\n\t\tviafb_write_reg(SR1E, VIASR, sr1e);\n\t\tviafb_write_reg(SR3E, VIASR, sr3e);\n\t\tbreak;\n\t}\n\n\tviaparinfo->chip_info->\n\t\ttmds_chip_info.tmds_chip_name = NON_TMDS_TRANSMITTER;\n\tviaparinfo->chip_info->tmds_chip_info.\n\t\ttmds_chip_slave_addr = VT1632_TMDS_I2C_ADDR;\n\treturn false;\n}\n\nstatic void tmds_register_write(int index, u8 data)\n{\n\tviafb_i2c_writebyte(viaparinfo->chip_info->tmds_chip_info.i2c_port,\n\t\t\t    viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr,\n\t\t\t    index, data);\n}\n\nstatic int tmds_register_read(int index)\n{\n\tu8 data;\n\n\tviafb_i2c_readbyte(viaparinfo->chip_info->tmds_chip_info.i2c_port,\n\t\t\t   (u8) viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr,\n\t\t\t   (u8) index, &data);\n\treturn data;\n}\n\nstatic int tmds_register_read_bytes(int index, u8 *buff, int buff_len)\n{\n\tviafb_i2c_readbytes(viaparinfo->chip_info->tmds_chip_info.i2c_port,\n\t\t\t    (u8) viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr,\n\t\t\t    (u8) index, buff, buff_len);\n\treturn 0;\n}\n\n \nvoid viafb_dvi_set_mode(const struct fb_var_screeninfo *var,\n\tu16 cxres, u16 cyres, int iga)\n{\n\tstruct fb_var_screeninfo dvi_var = *var;\n\tconst struct fb_videomode *rb_mode;\n\tint maxPixelClock;\n\n\tmaxPixelClock = viaparinfo->shared->tmds_setting_info.max_pixel_clock;\n\tif (maxPixelClock && PICOS2KHZ(var->pixclock) / 1000 > maxPixelClock) {\n\t\trb_mode = viafb_get_best_rb_mode(var->xres, var->yres, 60);\n\t\tif (rb_mode)\n\t\t\tviafb_fill_var_timing_info(&dvi_var, rb_mode);\n\t}\n\n\tviafb_fill_crtc_timing(&dvi_var, cxres, cyres, iga);\n}\n\n \nint viafb_dvi_sense(void)\n{\n\tu8 RegSR1E = 0, RegSR3E = 0, RegCR6B = 0, RegCR91 = 0,\n\t\tRegCR93 = 0, RegCR9B = 0, data;\n\tint ret = false;\n\n\tDEBUG_MSG(KERN_INFO \"viafb_dvi_sense!!\\n\");\n\n\tif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266) {\n\t\t \n\t\tRegSR1E = viafb_read_reg(VIASR, SR1E);\n\t\tviafb_write_reg(SR1E, VIASR, RegSR1E | 0x30);\n\n\t\t \n\t\tRegCR6B = viafb_read_reg(VIACR, CR6B);\n\t\tviafb_write_reg(CR6B, VIACR, RegCR6B | 0x08);\n\n\t\t \n\t\tRegCR91 = viafb_read_reg(VIACR, CR91);\n\t\tviafb_write_reg(CR91, VIACR, 0x1D);\n\n\t\t \n\t\tRegCR93 = viafb_read_reg(VIACR, CR93);\n\t\tviafb_write_reg(CR93, VIACR, 0x01);\n\t} else {\n\t\t \n\t\tRegSR1E = viafb_read_reg(VIASR, SR1E);\n\t\tviafb_write_reg(SR1E, VIASR, RegSR1E | 0xF0);\n\n\t\t \n\t\tRegSR3E = viafb_read_reg(VIASR, SR3E);\n\t\tviafb_write_reg(SR3E, VIASR, RegSR3E & (~0x20));\n\n\t\t \n\t\tRegCR91 = viafb_read_reg(VIACR, CR91);\n\t\tviafb_write_reg(CR91, VIACR, 0x1D);\n\n\t\t \n\t\tRegCR9B = viafb_read_reg(VIACR, CR9B);\n\t\tviafb_write_reg(CR9B, VIACR, 0x01);\n\t}\n\n\tdata = (u8) tmds_register_read(0x09);\n\tif (data & 0x04)\n\t\tret = true;\n\n\tif (ret == false) {\n\t\tif (viafb_dvi_query_EDID())\n\t\t\tret = true;\n\t}\n\n\t \n\tviafb_write_reg(SR1E, VIASR, RegSR1E);\n\tviafb_write_reg(CR91, VIACR, RegCR91);\n\tif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266) {\n\t\tviafb_write_reg(CR6B, VIACR, RegCR6B);\n\t\tviafb_write_reg(CR93, VIACR, RegCR93);\n\t} else {\n\t\tviafb_write_reg(SR3E, VIASR, RegSR3E);\n\t\tviafb_write_reg(CR9B, VIACR, RegCR9B);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int viafb_dvi_query_EDID(void)\n{\n\tu8 data0, data1;\n\tint restore;\n\n\tDEBUG_MSG(KERN_INFO \"viafb_dvi_query_EDID!!\\n\");\n\n\trestore = viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr;\n\tviaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr = 0xA0;\n\n\tdata0 = (u8) tmds_register_read(0x00);\n\tdata1 = (u8) tmds_register_read(0x01);\n\tif ((data0 == 0) && (data1 == 0xFF)) {\n\t\tviaparinfo->chip_info->\n\t\t\ttmds_chip_info.tmds_chip_slave_addr = restore;\n\t\treturn EDID_VERSION_1;\t \n\t}\n\n\treturn false;\n}\n\n \nstatic void dvi_get_panel_size_from_DDCv1(\n\tstruct tmds_chip_information *tmds_chip,\n\tstruct tmds_setting_information *tmds_setting)\n{\n\tint i, restore;\n\tunsigned char EDID_DATA[18];\n\n\tDEBUG_MSG(KERN_INFO \"\\n dvi_get_panel_size_from_DDCv1 \\n\");\n\n\trestore = tmds_chip->tmds_chip_slave_addr;\n\ttmds_chip->tmds_chip_slave_addr = 0xA0;\n\tfor (i = 0x25; i < 0x6D; i++) {\n\t\tswitch (i) {\n\t\tcase 0x36:\n\t\tcase 0x48:\n\t\tcase 0x5A:\n\t\tcase 0x6C:\n\t\t\ttmds_register_read_bytes(i, EDID_DATA, 10);\n\t\t\tif (!(EDID_DATA[0] || EDID_DATA[1])) {\n\t\t\t\t \n\t\t\t\tif (EDID_DATA[3] == 0xFD) {\n\t\t\t\t\t \n\t\t\t\t\ttmds_setting->max_pixel_clock =\n\t\t\t\t\t\tEDID_DATA[9] * 10;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tDEBUG_MSG(KERN_INFO \"DVI max pixelclock = %d\\n\",\n\t\ttmds_setting->max_pixel_clock);\n\ttmds_chip->tmds_chip_slave_addr = restore;\n}\n\n \nvoid viafb_dvi_disable(void)\n{\n\tif (viaparinfo->chip_info->\n\t\ttmds_chip_info.output_interface == INTERFACE_TMDS)\n\t\t \n\t\tviafb_write_reg(CRD2, VIACR,\n\t\tviafb_read_reg(VIACR, CRD2) | 0x08);\n}\n\nstatic void dvi_patch_skew_dvp0(void)\n{\n\t \n\tviafb_write_reg_mask(SR1B, VIASR, 0, BIT1);\n\tviafb_write_reg_mask(SR2A, VIASR, 0, BIT4);\n\n\tswitch (viaparinfo->chip_info->gfx_chip_name) {\n\tcase UNICHROME_P4M890:\n\t\t{\n\t\t\tif ((viaparinfo->tmds_setting_info->h_active == 1600) &&\n\t\t\t\t(viaparinfo->tmds_setting_info->v_active ==\n\t\t\t\t1200))\n\t\t\t\tviafb_write_reg_mask(CR96, VIACR, 0x03,\n\t\t\t\t\t       BIT0 + BIT1 + BIT2);\n\t\t\telse\n\t\t\t\tviafb_write_reg_mask(CR96, VIACR, 0x07,\n\t\t\t\t\t       BIT0 + BIT1 + BIT2);\n\t\t\tbreak;\n\t\t}\n\n\tcase UNICHROME_P4M900:\n\t\t{\n\t\t\tviafb_write_reg_mask(CR96, VIACR, 0x07,\n\t\t\t\t       BIT0 + BIT1 + BIT2 + BIT3);\n\t\t\tviafb_write_reg_mask(SR1B, VIASR, 0x02, BIT1);\n\t\t\tviafb_write_reg_mask(SR2A, VIASR, 0x10, BIT4);\n\t\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void dvi_patch_skew_dvp_low(void)\n{\n\tswitch (viaparinfo->chip_info->gfx_chip_name) {\n\tcase UNICHROME_K8M890:\n\t\t{\n\t\t\tviafb_write_reg_mask(CR99, VIACR, 0x03, BIT0 + BIT1);\n\t\t\tbreak;\n\t\t}\n\n\tcase UNICHROME_P4M900:\n\t\t{\n\t\t\tviafb_write_reg_mask(CR99, VIACR, 0x08,\n\t\t\t\t       BIT0 + BIT1 + BIT2 + BIT3);\n\t\t\tbreak;\n\t\t}\n\n\tcase UNICHROME_P4M890:\n\t\t{\n\t\t\tviafb_write_reg_mask(CR99, VIACR, 0x0F,\n\t\t\t\t       BIT0 + BIT1 + BIT2 + BIT3);\n\t\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nvoid viafb_dvi_enable(void)\n{\n\tu8 data;\n\n\tswitch (viaparinfo->chip_info->tmds_chip_info.output_interface) {\n\tcase INTERFACE_DVP0:\n\t\tviafb_write_reg_mask(CR6B, VIACR, 0x01, BIT0);\n\t\tviafb_write_reg_mask(CR6C, VIACR, 0x21, BIT0 + BIT5);\n\t\tdvi_patch_skew_dvp0();\n\t\tif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)\n\t\t\ttmds_register_write(0x88, 0x3b);\n\t\telse\n\t\t\t \n\t\t\tvia_write_reg_mask(VIACR, 0x91, 0x00, 0x20);\n\t\tbreak;\n\n\tcase INTERFACE_DVP1:\n\t\tif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)\n\t\t\tviafb_write_reg_mask(CR93, VIACR, 0x21, BIT0 + BIT5);\n\n\t\t \n\t\tif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)\n\t\t\ttmds_register_write(0x88, 0x3b);\n\t\telse\n\t\t\t \n\t\t\tvia_write_reg_mask(VIACR, 0x91, 0x00, 0x20);\n\n\t\t \n\t\tif (viafb_platform_epia_dvi == 1) {\n\t\t\tviafb_write_reg_mask(CR91, VIACR, 0x1f, 0x1f);\n\t\t\tviafb_write_reg_mask(CR88, VIACR, 0x00, BIT6 + BIT0);\n\t\t\tif (viafb_bus_width == 24) {\n\t\t\t\tif (viafb_device_lcd_dualedge == 1)\n\t\t\t\t\tdata = 0x3F;\n\t\t\t\telse\n\t\t\t\t\tdata = 0x37;\n\t\t\t\tviafb_i2c_writebyte(viaparinfo->chip_info->\n\t\t\t\t\ttmds_chip_info.i2c_port,\n\t\t\t\t\tviaparinfo->chip_info->\n\t\t\t\t\ttmds_chip_info.tmds_chip_slave_addr,\n\t\t\t\t\t0x08, data);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase INTERFACE_DFP_HIGH:\n\t\tif (viaparinfo->chip_info->gfx_chip_name != UNICHROME_CLE266)\n\t\t\tvia_write_reg_mask(VIACR, CR97, 0x03, 0x03);\n\n\t\tvia_write_reg_mask(VIACR, 0x91, 0x00, 0x20);\n\t\tbreak;\n\n\tcase INTERFACE_DFP_LOW:\n\t\tif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)\n\t\t\tbreak;\n\n\t\tdvi_patch_skew_dvp_low();\n\t\tvia_write_reg_mask(VIACR, 0x91, 0x00, 0x20);\n\t\tbreak;\n\n\tcase INTERFACE_TMDS:\n\t\t \n\t\tviafb_write_reg_mask(CR91, VIACR, 0, BIT7);\n\n\t\t \n\t\tviafb_write_reg_mask(CRD2, VIACR, 0, BIT3);\n\t\tbreak;\n\t}\n\n\tif (viaparinfo->tmds_setting_info->iga_path == IGA2) {\n\t\t \n\t\tviafb_write_reg_mask(CR79, VIACR, 0x00, BIT0);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}