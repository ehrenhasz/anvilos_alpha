{
  "module_name": "accel.c",
  "hash_id": "7ff8b4e42e37eb7c7ec119a4d0d26f030392ef886383cb9a2ed60b5fae7e4aeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/via/accel.c",
  "human_readable_source": "\n \n#include <linux/via-core.h>\n#include \"global.h\"\n\n \nstatic int viafb_set_bpp(void __iomem *engine, u8 bpp)\n{\n\tu32 gemode;\n\n\t \n\t \n\tgemode = readl(engine + VIA_REG_GEMODE) & 0xfffffcfc;\n\tswitch (bpp) {\n\tcase 8:\n\t\tgemode |= VIA_GEM_8bpp;\n\t\tbreak;\n\tcase 16:\n\t\tgemode |= VIA_GEM_16bpp;\n\t\tbreak;\n\tcase 32:\n\t\tgemode |= VIA_GEM_32bpp;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"viafb_set_bpp: Unsupported bpp %d\\n\", bpp);\n\t\treturn -EINVAL;\n\t}\n\twritel(gemode, engine + VIA_REG_GEMODE);\n\treturn 0;\n}\n\n\nstatic int hw_bitblt_1(void __iomem *engine, u8 op, u32 width, u32 height,\n\tu8 dst_bpp, u32 dst_addr, u32 dst_pitch, u32 dst_x, u32 dst_y,\n\tu32 *src_mem, u32 src_addr, u32 src_pitch, u32 src_x, u32 src_y,\n\tu32 fg_color, u32 bg_color, u8 fill_rop)\n{\n\tu32 ge_cmd = 0, tmp, i;\n\tint ret;\n\n\tif (!op || op > 3) {\n\t\tprintk(KERN_WARNING \"hw_bitblt_1: Invalid operation: %d\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\tif (op != VIA_BITBLT_FILL && !src_mem && src_addr == dst_addr) {\n\t\tif (src_x < dst_x) {\n\t\t\tge_cmd |= 0x00008000;\n\t\t\tsrc_x += width - 1;\n\t\t\tdst_x += width - 1;\n\t\t}\n\t\tif (src_y < dst_y) {\n\t\t\tge_cmd |= 0x00004000;\n\t\t\tsrc_y += height - 1;\n\t\t\tdst_y += height - 1;\n\t\t}\n\t}\n\n\tif (op == VIA_BITBLT_FILL) {\n\t\tswitch (fill_rop) {\n\t\tcase 0x00:  \n\t\tcase 0x5A:  \n\t\tcase 0xF0:  \n\t\tcase 0xFF:  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING \"hw_bitblt_1: Invalid fill rop: \"\n\t\t\t\t\"%u\\n\", fill_rop);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = viafb_set_bpp(engine, dst_bpp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (op != VIA_BITBLT_FILL) {\n\t\tif (src_x & (op == VIA_BITBLT_MONO ? 0xFFFF8000 : 0xFFFFF000)\n\t\t\t|| src_y & 0xFFFFF000) {\n\t\t\tprintk(KERN_WARNING \"hw_bitblt_1: Unsupported source \"\n\t\t\t\t\"x/y %d %d\\n\", src_x, src_y);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp = src_x | (src_y << 16);\n\t\twritel(tmp, engine + 0x08);\n\t}\n\n\tif (dst_x & 0xFFFFF000 || dst_y & 0xFFFFF000) {\n\t\tprintk(KERN_WARNING \"hw_bitblt_1: Unsupported destination x/y \"\n\t\t\t\"%d %d\\n\", dst_x, dst_y);\n\t\treturn -EINVAL;\n\t}\n\ttmp = dst_x | (dst_y << 16);\n\twritel(tmp, engine + 0x0C);\n\n\tif ((width - 1) & 0xFFFFF000 || (height - 1) & 0xFFFFF000) {\n\t\tprintk(KERN_WARNING \"hw_bitblt_1: Unsupported width/height \"\n\t\t\t\"%d %d\\n\", width, height);\n\t\treturn -EINVAL;\n\t}\n\ttmp = (width - 1) | ((height - 1) << 16);\n\twritel(tmp, engine + 0x10);\n\n\tif (op != VIA_BITBLT_COLOR)\n\t\twritel(fg_color, engine + 0x18);\n\n\tif (op == VIA_BITBLT_MONO)\n\t\twritel(bg_color, engine + 0x1C);\n\n\tif (op != VIA_BITBLT_FILL) {\n\t\ttmp = src_mem ? 0 : src_addr;\n\t\tif (dst_addr & 0xE0000007) {\n\t\t\tprintk(KERN_WARNING \"hw_bitblt_1: Unsupported source \"\n\t\t\t\t\"address %X\\n\", tmp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp >>= 3;\n\t\twritel(tmp, engine + 0x30);\n\t}\n\n\tif (dst_addr & 0xE0000007) {\n\t\tprintk(KERN_WARNING \"hw_bitblt_1: Unsupported destination \"\n\t\t\t\"address %X\\n\", dst_addr);\n\t\treturn -EINVAL;\n\t}\n\ttmp = dst_addr >> 3;\n\twritel(tmp, engine + 0x34);\n\n\tif (op == VIA_BITBLT_FILL)\n\t\ttmp = 0;\n\telse\n\t\ttmp = src_pitch;\n\tif (tmp & 0xFFFFC007 || dst_pitch & 0xFFFFC007) {\n\t\tprintk(KERN_WARNING \"hw_bitblt_1: Unsupported pitch %X %X\\n\",\n\t\t\ttmp, dst_pitch);\n\t\treturn -EINVAL;\n\t}\n\ttmp = VIA_PITCH_ENABLE | (tmp >> 3) | (dst_pitch << (16 - 3));\n\twritel(tmp, engine + 0x38);\n\n\tif (op == VIA_BITBLT_FILL)\n\t\tge_cmd |= fill_rop << 24 | 0x00002000 | 0x00000001;\n\telse {\n\t\tge_cmd |= 0xCC000000;  \n\t\tif (src_mem)\n\t\t\tge_cmd |= 0x00000040;\n\t\tif (op == VIA_BITBLT_MONO)\n\t\t\tge_cmd |= 0x00000002 | 0x00000100 | 0x00020000;\n\t\telse\n\t\t\tge_cmd |= 0x00000001;\n\t}\n\twritel(ge_cmd, engine);\n\n\tif (op == VIA_BITBLT_FILL || !src_mem)\n\t\treturn 0;\n\n\ttmp = (width * height * (op == VIA_BITBLT_MONO ? 1 : (dst_bpp >> 3)) +\n\t\t3) >> 2;\n\n\tfor (i = 0; i < tmp; i++)\n\t\twritel(src_mem[i], engine + VIA_MMIO_BLTBASE);\n\n\treturn 0;\n}\n\nstatic int hw_bitblt_2(void __iomem *engine, u8 op, u32 width, u32 height,\n\tu8 dst_bpp, u32 dst_addr, u32 dst_pitch, u32 dst_x, u32 dst_y,\n\tu32 *src_mem, u32 src_addr, u32 src_pitch, u32 src_x, u32 src_y,\n\tu32 fg_color, u32 bg_color, u8 fill_rop)\n{\n\tu32 ge_cmd = 0, tmp, i;\n\tint ret;\n\n\tif (!op || op > 3) {\n\t\tprintk(KERN_WARNING \"hw_bitblt_2: Invalid operation: %d\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\tif (op != VIA_BITBLT_FILL && !src_mem && src_addr == dst_addr) {\n\t\tif (src_x < dst_x) {\n\t\t\tge_cmd |= 0x00008000;\n\t\t\tsrc_x += width - 1;\n\t\t\tdst_x += width - 1;\n\t\t}\n\t\tif (src_y < dst_y) {\n\t\t\tge_cmd |= 0x00004000;\n\t\t\tsrc_y += height - 1;\n\t\t\tdst_y += height - 1;\n\t\t}\n\t}\n\n\tif (op == VIA_BITBLT_FILL) {\n\t\tswitch (fill_rop) {\n\t\tcase 0x00:  \n\t\tcase 0x5A:  \n\t\tcase 0xF0:  \n\t\tcase 0xFF:  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING \"hw_bitblt_2: Invalid fill rop: \"\n\t\t\t\t\"%u\\n\", fill_rop);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = viafb_set_bpp(engine, dst_bpp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (op == VIA_BITBLT_FILL)\n\t\ttmp = 0;\n\telse\n\t\ttmp = src_pitch;\n\tif (tmp & 0xFFFFC007 || dst_pitch & 0xFFFFC007) {\n\t\tprintk(KERN_WARNING \"hw_bitblt_2: Unsupported pitch %X %X\\n\",\n\t\t\ttmp, dst_pitch);\n\t\treturn -EINVAL;\n\t}\n\ttmp = (tmp >> 3) | (dst_pitch << (16 - 3));\n\twritel(tmp, engine + 0x08);\n\n\tif ((width - 1) & 0xFFFFF000 || (height - 1) & 0xFFFFF000) {\n\t\tprintk(KERN_WARNING \"hw_bitblt_2: Unsupported width/height \"\n\t\t\t\"%d %d\\n\", width, height);\n\t\treturn -EINVAL;\n\t}\n\ttmp = (width - 1) | ((height - 1) << 16);\n\twritel(tmp, engine + 0x0C);\n\n\tif (dst_x & 0xFFFFF000 || dst_y & 0xFFFFF000) {\n\t\tprintk(KERN_WARNING \"hw_bitblt_2: Unsupported destination x/y \"\n\t\t\t\"%d %d\\n\", dst_x, dst_y);\n\t\treturn -EINVAL;\n\t}\n\ttmp = dst_x | (dst_y << 16);\n\twritel(tmp, engine + 0x10);\n\n\tif (dst_addr & 0xE0000007) {\n\t\tprintk(KERN_WARNING \"hw_bitblt_2: Unsupported destination \"\n\t\t\t\"address %X\\n\", dst_addr);\n\t\treturn -EINVAL;\n\t}\n\ttmp = dst_addr >> 3;\n\twritel(tmp, engine + 0x14);\n\n\tif (op != VIA_BITBLT_FILL) {\n\t\tif (src_x & (op == VIA_BITBLT_MONO ? 0xFFFF8000 : 0xFFFFF000)\n\t\t\t|| src_y & 0xFFFFF000) {\n\t\t\tprintk(KERN_WARNING \"hw_bitblt_2: Unsupported source \"\n\t\t\t\t\"x/y %d %d\\n\", src_x, src_y);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp = src_x | (src_y << 16);\n\t\twritel(tmp, engine + 0x18);\n\n\t\ttmp = src_mem ? 0 : src_addr;\n\t\tif (dst_addr & 0xE0000007) {\n\t\t\tprintk(KERN_WARNING \"hw_bitblt_2: Unsupported source \"\n\t\t\t\t\"address %X\\n\", tmp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp >>= 3;\n\t\twritel(tmp, engine + 0x1C);\n\t}\n\n\tif (op == VIA_BITBLT_FILL) {\n\t\twritel(fg_color, engine + 0x58);\n\t} else if (op == VIA_BITBLT_MONO) {\n\t\twritel(fg_color, engine + 0x4C);\n\t\twritel(bg_color, engine + 0x50);\n\t}\n\n\tif (op == VIA_BITBLT_FILL)\n\t\tge_cmd |= fill_rop << 24 | 0x00002000 | 0x00000001;\n\telse {\n\t\tge_cmd |= 0xCC000000;  \n\t\tif (src_mem)\n\t\t\tge_cmd |= 0x00000040;\n\t\tif (op == VIA_BITBLT_MONO)\n\t\t\tge_cmd |= 0x00000002 | 0x00000100 | 0x00020000;\n\t\telse\n\t\t\tge_cmd |= 0x00000001;\n\t}\n\twritel(ge_cmd, engine);\n\n\tif (op == VIA_BITBLT_FILL || !src_mem)\n\t\treturn 0;\n\n\ttmp = (width * height * (op == VIA_BITBLT_MONO ? 1 : (dst_bpp >> 3)) +\n\t\t3) >> 2;\n\n\tfor (i = 0; i < tmp; i++)\n\t\twritel(src_mem[i], engine + VIA_MMIO_BLTBASE);\n\n\treturn 0;\n}\n\nint viafb_setup_engine(struct fb_info *info)\n{\n\tstruct viafb_par *viapar = info->par;\n\tvoid __iomem *engine;\n\tu32 chip_name = viapar->shared->chip_info.gfx_chip_name;\n\n\tengine = viapar->shared->vdev->engine_mmio;\n\tif (!engine) {\n\t\tprintk(KERN_WARNING \"viafb_init_accel: ioremap failed, \"\n\t\t\t\"hardware acceleration disabled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tswitch (chip_name) {\n\tcase UNICHROME_CLE266:\n\tcase UNICHROME_K400:\n\tcase UNICHROME_K800:\n\tcase UNICHROME_PM800:\n\tcase UNICHROME_CN700:\n\tcase UNICHROME_CX700:\n\tcase UNICHROME_CN750:\n\tcase UNICHROME_K8M890:\n\tcase UNICHROME_P4M890:\n\tcase UNICHROME_P4M900:\n\t\tviapar->shared->hw_bitblt = hw_bitblt_1;\n\t\tbreak;\n\tcase UNICHROME_VX800:\n\tcase UNICHROME_VX855:\n\tcase UNICHROME_VX900:\n\t\tviapar->shared->hw_bitblt = hw_bitblt_2;\n\t\tbreak;\n\tdefault:\n\t\tviapar->shared->hw_bitblt = NULL;\n\t}\n\n\tviapar->fbmem_free -= CURSOR_SIZE;\n\tviapar->shared->cursor_vram_addr = viapar->fbmem_free;\n\tviapar->fbmem_used += CURSOR_SIZE;\n\n\tviapar->fbmem_free -= VQ_SIZE;\n\tviapar->shared->vq_vram_addr = viapar->fbmem_free;\n\tviapar->fbmem_used += VQ_SIZE;\n\n#if IS_ENABLED(CONFIG_VIDEO_VIA_CAMERA)\n\t \n\tviapar->shared->vdev->camera_fbmem_size = 3*VGA_HEIGHT*VGA_WIDTH*2;\n\tviapar->fbmem_free -= viapar->shared->vdev->camera_fbmem_size;\n\tviapar->fbmem_used += viapar->shared->vdev->camera_fbmem_size;\n\tviapar->shared->vdev->camera_fbmem_offset = viapar->fbmem_free;\n#endif\n\n\tviafb_reset_engine(viapar);\n\treturn 0;\n}\n\nvoid viafb_reset_engine(struct viafb_par *viapar)\n{\n\tvoid __iomem *engine = viapar->shared->vdev->engine_mmio;\n\tint highest_reg, i;\n\tu32 vq_start_addr, vq_end_addr, vq_start_low, vq_end_low, vq_high,\n\t\tvq_len, chip_name = viapar->shared->chip_info.gfx_chip_name;\n\n\t \n\tswitch (viapar->shared->chip_info.twod_engine) {\n\tcase VIA_2D_ENG_M1:\n\t\thighest_reg = 0x5c;\n\t\tbreak;\n\tdefault:\n\t\thighest_reg = 0x40;\n\t\tbreak;\n\t}\n\tfor (i = 0; i <= highest_reg; i += 4)\n\t\twritel(0x0, engine + i);\n\n\t \n\tswitch (chip_name) {\n\tcase UNICHROME_K8M890:\n\tcase UNICHROME_P4M900:\n\tcase UNICHROME_VX800:\n\tcase UNICHROME_VX855:\n\tcase UNICHROME_VX900:\n\t\twritel(0x00100000, engine + VIA_REG_CR_TRANSET);\n\t\twritel(0x680A0000, engine + VIA_REG_CR_TRANSPACE);\n\t\twritel(0x02000000, engine + VIA_REG_CR_TRANSPACE);\n\t\tbreak;\n\n\tdefault:\n\t\twritel(0x00100000, engine + VIA_REG_TRANSET);\n\t\twritel(0x00000000, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x00333004, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x60000000, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x61000000, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x62000000, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x63000000, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x64000000, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x7D000000, engine + VIA_REG_TRANSPACE);\n\n\t\twritel(0xFE020000, engine + VIA_REG_TRANSET);\n\t\twritel(0x00000000, engine + VIA_REG_TRANSPACE);\n\t\tbreak;\n\t}\n\n\t \n\tvq_start_addr = viapar->shared->vq_vram_addr;\n\tvq_end_addr = viapar->shared->vq_vram_addr + VQ_SIZE - 1;\n\n\tvq_start_low = 0x50000000 | (vq_start_addr & 0xFFFFFF);\n\tvq_end_low = 0x51000000 | (vq_end_addr & 0xFFFFFF);\n\tvq_high = 0x52000000 | ((vq_start_addr & 0xFF000000) >> 24) |\n\t\t((vq_end_addr & 0xFF000000) >> 16);\n\tvq_len = 0x53000000 | (VQ_SIZE >> 3);\n\n\tswitch (chip_name) {\n\tcase UNICHROME_K8M890:\n\tcase UNICHROME_P4M900:\n\tcase UNICHROME_VX800:\n\tcase UNICHROME_VX855:\n\tcase UNICHROME_VX900:\n\t\tvq_start_low |= 0x20000000;\n\t\tvq_end_low |= 0x20000000;\n\t\tvq_high |= 0x20000000;\n\t\tvq_len |= 0x20000000;\n\n\t\twritel(0x00100000, engine + VIA_REG_CR_TRANSET);\n\t\twritel(vq_high, engine + VIA_REG_CR_TRANSPACE);\n\t\twritel(vq_start_low, engine + VIA_REG_CR_TRANSPACE);\n\t\twritel(vq_end_low, engine + VIA_REG_CR_TRANSPACE);\n\t\twritel(vq_len, engine + VIA_REG_CR_TRANSPACE);\n\t\twritel(0x74301001, engine + VIA_REG_CR_TRANSPACE);\n\t\twritel(0x00000000, engine + VIA_REG_CR_TRANSPACE);\n\t\tbreak;\n\tdefault:\n\t\twritel(0x00FE0000, engine + VIA_REG_TRANSET);\n\t\twritel(0x080003FE, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x0A00027C, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x0B000260, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x0C000274, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x0D000264, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x0E000000, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x0F000020, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x1000027E, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x110002FE, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x200F0060, engine + VIA_REG_TRANSPACE);\n\n\t\twritel(0x00000006, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x40008C0F, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x44000000, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x45080C04, engine + VIA_REG_TRANSPACE);\n\t\twritel(0x46800408, engine + VIA_REG_TRANSPACE);\n\n\t\twritel(vq_high, engine + VIA_REG_TRANSPACE);\n\t\twritel(vq_start_low, engine + VIA_REG_TRANSPACE);\n\t\twritel(vq_end_low, engine + VIA_REG_TRANSPACE);\n\t\twritel(vq_len, engine + VIA_REG_TRANSPACE);\n\t\tbreak;\n\t}\n\n\t \n\twritel(viapar->shared->cursor_vram_addr, engine + VIA_REG_CURSOR_MODE);\n\twritel(0x0, engine + VIA_REG_CURSOR_POS);\n\twritel(0x0, engine + VIA_REG_CURSOR_ORG);\n\twritel(0x0, engine + VIA_REG_CURSOR_BG);\n\twritel(0x0, engine + VIA_REG_CURSOR_FG);\n\treturn;\n}\n\nvoid viafb_show_hw_cursor(struct fb_info *info, int Status)\n{\n\tstruct viafb_par *viapar = info->par;\n\tu32 temp, iga_path = viapar->iga_path;\n\n\ttemp = readl(viapar->shared->vdev->engine_mmio + VIA_REG_CURSOR_MODE);\n\tswitch (Status) {\n\tcase HW_Cursor_ON:\n\t\ttemp |= 0x1;\n\t\tbreak;\n\tcase HW_Cursor_OFF:\n\t\ttemp &= 0xFFFFFFFE;\n\t\tbreak;\n\t}\n\tswitch (iga_path) {\n\tcase IGA2:\n\t\ttemp |= 0x80000000;\n\t\tbreak;\n\tcase IGA1:\n\tdefault:\n\t\ttemp &= 0x7FFFFFFF;\n\t}\n\twritel(temp, viapar->shared->vdev->engine_mmio + VIA_REG_CURSOR_MODE);\n}\n\nvoid viafb_wait_engine_idle(struct fb_info *info)\n{\n\tstruct viafb_par *viapar = info->par;\n\tint loop = 0;\n\tu32 mask;\n\tvoid __iomem *engine = viapar->shared->vdev->engine_mmio;\n\n\tswitch (viapar->shared->chip_info.twod_engine) {\n\tcase VIA_2D_ENG_H5:\n\tcase VIA_2D_ENG_M1:\n\t\tmask = VIA_CMD_RGTR_BUSY_M1 | VIA_2D_ENG_BUSY_M1 |\n\t\t\t      VIA_3D_ENG_BUSY_M1;\n\t\tbreak;\n\tdefault:\n\t\twhile (!(readl(engine + VIA_REG_STATUS) &\n\t\t\t\tVIA_VR_QUEUE_BUSY) && (loop < MAXLOOP)) {\n\t\t\tloop++;\n\t\t\tcpu_relax();\n\t\t}\n\t\tmask = VIA_CMD_RGTR_BUSY | VIA_2D_ENG_BUSY | VIA_3D_ENG_BUSY;\n\t\tbreak;\n\t}\n\n\twhile ((readl(engine + VIA_REG_STATUS) & mask) && (loop < MAXLOOP)) {\n\t\tloop++;\n\t\tcpu_relax();\n\t}\n\n\tif (loop >= MAXLOOP)\n\t\tprintk(KERN_ERR \"viafb_wait_engine_idle: not syncing\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}