{
  "module_name": "via_clock.c",
  "hash_id": "653b41a612676e62dabad767903853bb4443835264c8e7c07d59abe85db735a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/via/via_clock.c",
  "human_readable_source": "\n \n \n\n#include <linux/kernel.h>\n#include <linux/via-core.h>\n\n#include \"via_clock.h\"\n#include \"global.h\"\n#include \"debug.h\"\n\nstatic const char *via_slap = \"Please slap VIA Technologies to motivate them \"\n\t\"releasing full documentation for your platform!\\n\";\n\nstatic inline u32 cle266_encode_pll(struct via_pll_config pll)\n{\n\treturn (pll.multiplier << 8)\n\t\t| (pll.rshift << 6)\n\t\t| pll.divisor;\n}\n\nstatic inline u32 k800_encode_pll(struct via_pll_config pll)\n{\n\treturn ((pll.divisor - 2) << 16)\n\t\t| (pll.rshift << 10)\n\t\t| (pll.multiplier - 2);\n}\n\nstatic inline u32 vx855_encode_pll(struct via_pll_config pll)\n{\n\treturn (pll.divisor << 16)\n\t\t| (pll.rshift << 10)\n\t\t| pll.multiplier;\n}\n\nstatic inline void cle266_set_primary_pll_encoded(u32 data)\n{\n\tvia_write_reg_mask(VIASR, 0x40, 0x02, 0x02);  \n\tvia_write_reg(VIASR, 0x46, data & 0xFF);\n\tvia_write_reg(VIASR, 0x47, (data >> 8) & 0xFF);\n\tvia_write_reg_mask(VIASR, 0x40, 0x00, 0x02);  \n}\n\nstatic inline void k800_set_primary_pll_encoded(u32 data)\n{\n\tvia_write_reg_mask(VIASR, 0x40, 0x02, 0x02);  \n\tvia_write_reg(VIASR, 0x44, data & 0xFF);\n\tvia_write_reg(VIASR, 0x45, (data >> 8) & 0xFF);\n\tvia_write_reg(VIASR, 0x46, (data >> 16) & 0xFF);\n\tvia_write_reg_mask(VIASR, 0x40, 0x00, 0x02);  \n}\n\nstatic inline void cle266_set_secondary_pll_encoded(u32 data)\n{\n\tvia_write_reg_mask(VIASR, 0x40, 0x04, 0x04);  \n\tvia_write_reg(VIASR, 0x44, data & 0xFF);\n\tvia_write_reg(VIASR, 0x45, (data >> 8) & 0xFF);\n\tvia_write_reg_mask(VIASR, 0x40, 0x00, 0x04);  \n}\n\nstatic inline void k800_set_secondary_pll_encoded(u32 data)\n{\n\tvia_write_reg_mask(VIASR, 0x40, 0x04, 0x04);  \n\tvia_write_reg(VIASR, 0x4A, data & 0xFF);\n\tvia_write_reg(VIASR, 0x4B, (data >> 8) & 0xFF);\n\tvia_write_reg(VIASR, 0x4C, (data >> 16) & 0xFF);\n\tvia_write_reg_mask(VIASR, 0x40, 0x00, 0x04);  \n}\n\nstatic inline void set_engine_pll_encoded(u32 data)\n{\n\tvia_write_reg_mask(VIASR, 0x40, 0x01, 0x01);  \n\tvia_write_reg(VIASR, 0x47, data & 0xFF);\n\tvia_write_reg(VIASR, 0x48, (data >> 8) & 0xFF);\n\tvia_write_reg(VIASR, 0x49, (data >> 16) & 0xFF);\n\tvia_write_reg_mask(VIASR, 0x40, 0x00, 0x01);  \n}\n\nstatic void cle266_set_primary_pll(struct via_pll_config config)\n{\n\tcle266_set_primary_pll_encoded(cle266_encode_pll(config));\n}\n\nstatic void k800_set_primary_pll(struct via_pll_config config)\n{\n\tk800_set_primary_pll_encoded(k800_encode_pll(config));\n}\n\nstatic void vx855_set_primary_pll(struct via_pll_config config)\n{\n\tk800_set_primary_pll_encoded(vx855_encode_pll(config));\n}\n\nstatic void cle266_set_secondary_pll(struct via_pll_config config)\n{\n\tcle266_set_secondary_pll_encoded(cle266_encode_pll(config));\n}\n\nstatic void k800_set_secondary_pll(struct via_pll_config config)\n{\n\tk800_set_secondary_pll_encoded(k800_encode_pll(config));\n}\n\nstatic void vx855_set_secondary_pll(struct via_pll_config config)\n{\n\tk800_set_secondary_pll_encoded(vx855_encode_pll(config));\n}\n\nstatic void k800_set_engine_pll(struct via_pll_config config)\n{\n\tset_engine_pll_encoded(k800_encode_pll(config));\n}\n\nstatic void vx855_set_engine_pll(struct via_pll_config config)\n{\n\tset_engine_pll_encoded(vx855_encode_pll(config));\n}\n\nstatic void set_primary_pll_state(u8 state)\n{\n\tu8 value;\n\n\tswitch (state) {\n\tcase VIA_STATE_ON:\n\t\tvalue = 0x20;\n\t\tbreak;\n\tcase VIA_STATE_OFF:\n\t\tvalue = 0x00;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tvia_write_reg_mask(VIASR, 0x2D, value, 0x30);\n}\n\nstatic void set_secondary_pll_state(u8 state)\n{\n\tu8 value;\n\n\tswitch (state) {\n\tcase VIA_STATE_ON:\n\t\tvalue = 0x08;\n\t\tbreak;\n\tcase VIA_STATE_OFF:\n\t\tvalue = 0x00;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tvia_write_reg_mask(VIASR, 0x2D, value, 0x0C);\n}\n\nstatic void set_engine_pll_state(u8 state)\n{\n\tu8 value;\n\n\tswitch (state) {\n\tcase VIA_STATE_ON:\n\t\tvalue = 0x02;\n\t\tbreak;\n\tcase VIA_STATE_OFF:\n\t\tvalue = 0x00;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tvia_write_reg_mask(VIASR, 0x2D, value, 0x03);\n}\n\nstatic void set_primary_clock_state(u8 state)\n{\n\tu8 value;\n\n\tswitch (state) {\n\tcase VIA_STATE_ON:\n\t\tvalue = 0x20;\n\t\tbreak;\n\tcase VIA_STATE_OFF:\n\t\tvalue = 0x00;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tvia_write_reg_mask(VIASR, 0x1B, value, 0x30);\n}\n\nstatic void set_secondary_clock_state(u8 state)\n{\n\tu8 value;\n\n\tswitch (state) {\n\tcase VIA_STATE_ON:\n\t\tvalue = 0x80;\n\t\tbreak;\n\tcase VIA_STATE_OFF:\n\t\tvalue = 0x00;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tvia_write_reg_mask(VIASR, 0x1B, value, 0xC0);\n}\n\nstatic inline u8 set_clock_source_common(enum via_clksrc source, bool use_pll)\n{\n\tu8 data = 0;\n\n\tswitch (source) {\n\tcase VIA_CLKSRC_X1:\n\t\tdata = 0x00;\n\t\tbreak;\n\tcase VIA_CLKSRC_TVX1:\n\t\tdata = 0x02;\n\t\tbreak;\n\tcase VIA_CLKSRC_TVPLL:\n\t\tdata = 0x04;  \n\t\tbreak;\n\tcase VIA_CLKSRC_DVP1TVCLKR:\n\t\tdata = 0x0A;\n\t\tbreak;\n\tcase VIA_CLKSRC_CAP0:\n\t\tdata = 0xC;\n\t\tbreak;\n\tcase VIA_CLKSRC_CAP1:\n\t\tdata = 0x0E;\n\t\tbreak;\n\t}\n\n\tif (!use_pll)\n\t\tdata |= 1;\n\n\treturn data;\n}\n\nstatic void set_primary_clock_source(enum via_clksrc source, bool use_pll)\n{\n\tu8 data = set_clock_source_common(source, use_pll) << 4;\n\tvia_write_reg_mask(VIACR, 0x6C, data, 0xF0);\n}\n\nstatic void set_secondary_clock_source(enum via_clksrc source, bool use_pll)\n{\n\tu8 data = set_clock_source_common(source, use_pll);\n\tvia_write_reg_mask(VIACR, 0x6C, data, 0x0F);\n}\n\nstatic void dummy_set_clock_state(u8 state)\n{\n\tprintk(KERN_INFO \"Using undocumented set clock state.\\n%s\", via_slap);\n}\n\nstatic void dummy_set_clock_source(enum via_clksrc source, bool use_pll)\n{\n\tprintk(KERN_INFO \"Using undocumented set clock source.\\n%s\", via_slap);\n}\n\nstatic void dummy_set_pll_state(u8 state)\n{\n\tprintk(KERN_INFO \"Using undocumented set PLL state.\\n%s\", via_slap);\n}\n\nstatic void dummy_set_pll(struct via_pll_config config)\n{\n\tprintk(KERN_INFO \"Using undocumented set PLL.\\n%s\", via_slap);\n}\n\nstatic void noop_set_clock_state(u8 state)\n{\n}\n\nvoid via_clock_init(struct via_clock *clock, int gfx_chip)\n{\n\tswitch (gfx_chip) {\n\tcase UNICHROME_CLE266:\n\tcase UNICHROME_K400:\n\t\tclock->set_primary_clock_state = dummy_set_clock_state;\n\t\tclock->set_primary_clock_source = dummy_set_clock_source;\n\t\tclock->set_primary_pll_state = dummy_set_pll_state;\n\t\tclock->set_primary_pll = cle266_set_primary_pll;\n\n\t\tclock->set_secondary_clock_state = dummy_set_clock_state;\n\t\tclock->set_secondary_clock_source = dummy_set_clock_source;\n\t\tclock->set_secondary_pll_state = dummy_set_pll_state;\n\t\tclock->set_secondary_pll = cle266_set_secondary_pll;\n\n\t\tclock->set_engine_pll_state = dummy_set_pll_state;\n\t\tclock->set_engine_pll = dummy_set_pll;\n\t\tbreak;\n\tcase UNICHROME_K800:\n\tcase UNICHROME_PM800:\n\tcase UNICHROME_CN700:\n\tcase UNICHROME_CX700:\n\tcase UNICHROME_CN750:\n\tcase UNICHROME_K8M890:\n\tcase UNICHROME_P4M890:\n\tcase UNICHROME_P4M900:\n\tcase UNICHROME_VX800:\n\t\tclock->set_primary_clock_state = set_primary_clock_state;\n\t\tclock->set_primary_clock_source = set_primary_clock_source;\n\t\tclock->set_primary_pll_state = set_primary_pll_state;\n\t\tclock->set_primary_pll = k800_set_primary_pll;\n\n\t\tclock->set_secondary_clock_state = set_secondary_clock_state;\n\t\tclock->set_secondary_clock_source = set_secondary_clock_source;\n\t\tclock->set_secondary_pll_state = set_secondary_pll_state;\n\t\tclock->set_secondary_pll = k800_set_secondary_pll;\n\n\t\tclock->set_engine_pll_state = set_engine_pll_state;\n\t\tclock->set_engine_pll = k800_set_engine_pll;\n\t\tbreak;\n\tcase UNICHROME_VX855:\n\tcase UNICHROME_VX900:\n\t\tclock->set_primary_clock_state = set_primary_clock_state;\n\t\tclock->set_primary_clock_source = set_primary_clock_source;\n\t\tclock->set_primary_pll_state = set_primary_pll_state;\n\t\tclock->set_primary_pll = vx855_set_primary_pll;\n\n\t\tclock->set_secondary_clock_state = set_secondary_clock_state;\n\t\tclock->set_secondary_clock_source = set_secondary_clock_source;\n\t\tclock->set_secondary_pll_state = set_secondary_pll_state;\n\t\tclock->set_secondary_pll = vx855_set_secondary_pll;\n\n\t\tclock->set_engine_pll_state = set_engine_pll_state;\n\t\tclock->set_engine_pll = vx855_set_engine_pll;\n\t\tbreak;\n\n\t}\n\n\tif (machine_is_olpc()) {\n\t\t \n\t\tclock->set_primary_clock_state = noop_set_clock_state;\n\t\tclock->set_secondary_clock_state = noop_set_clock_state;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}