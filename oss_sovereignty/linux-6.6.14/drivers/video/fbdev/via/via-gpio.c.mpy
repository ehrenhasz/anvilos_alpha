{
  "module_name": "via-gpio.c",
  "hash_id": "6c1064e1e1ab2d427bdbcefaa44ffda3d4fc2bf08250353d027d46f36d6d6b36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/via/via-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/machine.h>\n#include <linux/platform_device.h>\n#include <linux/via-core.h>\n#include <linux/export.h>\n#include \"via-gpio.h\"\n\n \n\nstruct viafb_gpio {\n\tchar *vg_name;\t \n\tu16 vg_io_port;\n\tu8  vg_port_index;\n\tint  vg_mask_shift;\n};\n\nstatic struct viafb_gpio viafb_all_gpios[] = {\n\t{\n\t\t.vg_name = \"VGPIO0\",   \n\t\t.vg_io_port = VIASR,\n\t\t.vg_port_index = 0x25,\n\t\t.vg_mask_shift = 1\n\t},\n\t{\n\t\t.vg_name = \"VGPIO1\",\n\t\t.vg_io_port = VIASR,\n\t\t.vg_port_index = 0x25,\n\t\t.vg_mask_shift = 0\n\t},\n\t{\n\t\t.vg_name = \"VGPIO2\",   \n\t\t.vg_io_port = VIASR,\n\t\t.vg_port_index = 0x2c,\n\t\t.vg_mask_shift = 1\n\t},\n\t{\n\t\t.vg_name = \"VGPIO3\",   \n\t\t.vg_io_port = VIASR,\n\t\t.vg_port_index = 0x2c,\n\t\t.vg_mask_shift = 0\n\t},\n\t{\n\t\t.vg_name = \"VGPIO4\",   \n\t\t.vg_io_port = VIASR,\n\t\t.vg_port_index = 0x3d,\n\t\t.vg_mask_shift = 1\n\t},\n\t{\n\t\t.vg_name = \"VGPIO5\",   \n\t\t.vg_io_port = VIASR,\n\t\t.vg_port_index = 0x3d,\n\t\t.vg_mask_shift = 0\n\t},\n};\n\n#define VIAFB_NUM_GPIOS ARRAY_SIZE(viafb_all_gpios)\n\n \n\nstruct viafb_gpio_cfg {\n\tstruct gpio_chip gpio_chip;\n\tstruct viafb_dev *vdev;\n\tstruct viafb_gpio *active_gpios[VIAFB_NUM_GPIOS];\n\tconst char *gpio_names[VIAFB_NUM_GPIOS];\n};\n\n \nstatic void via_gpio_set(struct gpio_chip *chip, unsigned int nr,\n\t\t\t int value)\n{\n\tstruct viafb_gpio_cfg *cfg = gpiochip_get_data(chip);\n\tu8 reg;\n\tstruct viafb_gpio *gpio;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cfg->vdev->reg_lock, flags);\n\tgpio = cfg->active_gpios[nr];\n\treg = via_read_reg(VIASR, gpio->vg_port_index);\n\treg |= 0x40 << gpio->vg_mask_shift;   \n\tif (value)\n\t\treg |= 0x10 << gpio->vg_mask_shift;\n\telse\n\t\treg &= ~(0x10 << gpio->vg_mask_shift);\n\tvia_write_reg(VIASR, gpio->vg_port_index, reg);\n\tspin_unlock_irqrestore(&cfg->vdev->reg_lock, flags);\n}\n\nstatic int via_gpio_dir_out(struct gpio_chip *chip, unsigned int nr,\n\t\t\t    int value)\n{\n\tvia_gpio_set(chip, nr, value);\n\treturn 0;\n}\n\n \nstatic int via_gpio_dir_input(struct gpio_chip *chip, unsigned int nr)\n{\n\tstruct viafb_gpio_cfg *cfg = gpiochip_get_data(chip);\n\tstruct viafb_gpio *gpio;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cfg->vdev->reg_lock, flags);\n\tgpio = cfg->active_gpios[nr];\n\tvia_write_reg_mask(VIASR, gpio->vg_port_index, 0,\n\t\t\t0x40 << gpio->vg_mask_shift);\n\tspin_unlock_irqrestore(&cfg->vdev->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int via_gpio_get(struct gpio_chip *chip, unsigned int nr)\n{\n\tstruct viafb_gpio_cfg *cfg = gpiochip_get_data(chip);\n\tu8 reg;\n\tstruct viafb_gpio *gpio;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cfg->vdev->reg_lock, flags);\n\tgpio = cfg->active_gpios[nr];\n\treg = via_read_reg(VIASR, gpio->vg_port_index);\n\tspin_unlock_irqrestore(&cfg->vdev->reg_lock, flags);\n\treturn !!(reg & (0x04 << gpio->vg_mask_shift));\n}\n\n\nstatic struct viafb_gpio_cfg viafb_gpio_config = {\n\t.gpio_chip = {\n\t\t.label = \"VIAFB onboard GPIO\",\n\t\t.owner = THIS_MODULE,\n\t\t.direction_output = via_gpio_dir_out,\n\t\t.set = via_gpio_set,\n\t\t.direction_input = via_gpio_dir_input,\n\t\t.get = via_gpio_get,\n\t\t.base = -1,\n\t\t.ngpio = 0,\n\t\t.can_sleep = 0\n\t}\n};\n\n \nstatic void viafb_gpio_enable(struct viafb_gpio *gpio)\n{\n\tvia_write_reg_mask(VIASR, gpio->vg_port_index, 0x02, 0x02);\n}\n\nstatic void viafb_gpio_disable(struct viafb_gpio *gpio)\n{\n\tvia_write_reg_mask(VIASR, gpio->vg_port_index, 0, 0x02);\n}\n\n#ifdef CONFIG_PM\n\nstatic int viafb_gpio_suspend(void *private)\n{\n\treturn 0;\n}\n\nstatic int viafb_gpio_resume(void *private)\n{\n\tint i;\n\n\tfor (i = 0; i < viafb_gpio_config.gpio_chip.ngpio; i += 2)\n\t\tviafb_gpio_enable(viafb_gpio_config.active_gpios[i]);\n\treturn 0;\n}\n\nstatic struct viafb_pm_hooks viafb_gpio_pm_hooks = {\n\t.suspend = viafb_gpio_suspend,\n\t.resume = viafb_gpio_resume\n};\n#endif  \n\nstatic struct gpiod_lookup_table viafb_gpio_table = {\n\t.dev_id = \"viafb-camera\",\n\t.table = {\n\t\tGPIO_LOOKUP(\"via-gpio\", 2, \"VGPIO2\", GPIO_ACTIVE_LOW),\n\t\tGPIO_LOOKUP(\"via-gpio\", 3, \"VGPIO3\", GPIO_ACTIVE_HIGH),\n\t\t{ }\n\t},\n};\n\n \nstatic int viafb_gpio_probe(struct platform_device *platdev)\n{\n\tstruct viafb_dev *vdev = platdev->dev.platform_data;\n\tstruct via_port_cfg *port_cfg = vdev->port_cfg;\n\tint i, ngpio = 0, ret;\n\tstruct viafb_gpio *gpio;\n\tunsigned long flags;\n\n\t \n\tfor (i = 0; i < VIAFB_NUM_PORTS; i++) {\n\t\tif (port_cfg[i].mode != VIA_MODE_GPIO)\n\t\t\tcontinue;\n\t\tfor (gpio = viafb_all_gpios;\n\t\t     gpio < viafb_all_gpios + VIAFB_NUM_GPIOS; gpio++)\n\t\t\tif (gpio->vg_port_index == port_cfg[i].ioport_index) {\n\t\t\t\tviafb_gpio_config.active_gpios[ngpio] = gpio;\n\t\t\t\tviafb_gpio_config.gpio_names[ngpio] =\n\t\t\t\t\tgpio->vg_name;\n\t\t\t\tngpio++;\n\t\t\t}\n\t}\n\tviafb_gpio_config.gpio_chip.ngpio = ngpio;\n\tviafb_gpio_config.gpio_chip.names = viafb_gpio_config.gpio_names;\n\tviafb_gpio_config.vdev = vdev;\n\tif (ngpio == 0) {\n\t\tprintk(KERN_INFO \"viafb: no GPIOs configured\\n\");\n\t\treturn 0;\n\t}\n\t \n\tspin_lock_irqsave(&viafb_gpio_config.vdev->reg_lock, flags);\n\tfor (i = 0; i < ngpio; i += 2)\n\t\tviafb_gpio_enable(viafb_gpio_config.active_gpios[i]);\n\tspin_unlock_irqrestore(&viafb_gpio_config.vdev->reg_lock, flags);\n\t \n\tviafb_gpio_config.gpio_chip.base = -1;   \n\tviafb_gpio_config.gpio_chip.label = \"via-gpio\";\n\tret = gpiochip_add_data(&viafb_gpio_config.gpio_chip,\n\t\t\t\t&viafb_gpio_config);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"viafb: failed to add gpios (%d)\\n\", ret);\n\t\tviafb_gpio_config.gpio_chip.ngpio = 0;\n\t}\n\n\tgpiod_add_lookup_table(&viafb_gpio_table);\n\n#ifdef CONFIG_PM\n\tviafb_pm_register(&viafb_gpio_pm_hooks);\n#endif\n\treturn ret;\n}\n\n\nstatic void viafb_gpio_remove(struct platform_device *platdev)\n{\n\tunsigned long flags;\n\tint i;\n\n#ifdef CONFIG_PM\n\tviafb_pm_unregister(&viafb_gpio_pm_hooks);\n#endif\n\n\t \n\tif (viafb_gpio_config.gpio_chip.ngpio > 0) {\n\t\tgpiochip_remove(&viafb_gpio_config.gpio_chip);\n\t}\n\t \n\tspin_lock_irqsave(&viafb_gpio_config.vdev->reg_lock, flags);\n\tfor (i = 0; i < viafb_gpio_config.gpio_chip.ngpio; i += 2)\n\t\tviafb_gpio_disable(viafb_gpio_config.active_gpios[i]);\n\tviafb_gpio_config.gpio_chip.ngpio = 0;\n\tspin_unlock_irqrestore(&viafb_gpio_config.vdev->reg_lock, flags);\n}\n\nstatic struct platform_driver via_gpio_driver = {\n\t.driver = {\n\t\t.name = \"viafb-gpio\",\n\t},\n\t.probe = viafb_gpio_probe,\n\t.remove_new = viafb_gpio_remove,\n};\n\nint viafb_gpio_init(void)\n{\n\treturn platform_driver_register(&via_gpio_driver);\n}\n\nvoid viafb_gpio_exit(void)\n{\n\tplatform_driver_unregister(&via_gpio_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}