{
  "module_name": "via_i2c.c",
  "hash_id": "94a081e051ccf38f677d8437de754809518a6be8b1d2ce21816d5daa01b0e3e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/via/via_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/via-core.h>\n#include <linux/via_i2c.h>\n\n \n#define VIAFB_NUM_I2C\t\t5\nstatic struct via_i2c_stuff via_i2c_par[VIAFB_NUM_I2C];\nstatic struct viafb_dev *i2c_vdev;   \n\nstatic void via_i2c_setscl(void *data, int state)\n{\n\tu8 val;\n\tstruct via_port_cfg *adap_data = data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&i2c_vdev->reg_lock, flags);\n\tval = via_read_reg(adap_data->io_port, adap_data->ioport_index) & 0xF0;\n\tif (state)\n\t\tval |= 0x20;\n\telse\n\t\tval &= ~0x20;\n\tswitch (adap_data->type) {\n\tcase VIA_PORT_I2C:\n\t\tval |= 0x01;\n\t\tbreak;\n\tcase VIA_PORT_GPIO:\n\t\tval |= 0x82;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"viafb_i2c: specify wrong i2c type.\\n\");\n\t}\n\tvia_write_reg(adap_data->io_port, adap_data->ioport_index, val);\n\tspin_unlock_irqrestore(&i2c_vdev->reg_lock, flags);\n}\n\nstatic int via_i2c_getscl(void *data)\n{\n\tstruct via_port_cfg *adap_data = data;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&i2c_vdev->reg_lock, flags);\n\tif (adap_data->type == VIA_PORT_GPIO)\n\t\tvia_write_reg_mask(adap_data->io_port, adap_data->ioport_index,\n\t\t\t0, 0x80);\n\tif (via_read_reg(adap_data->io_port, adap_data->ioport_index) & 0x08)\n\t\tret = 1;\n\tspin_unlock_irqrestore(&i2c_vdev->reg_lock, flags);\n\treturn ret;\n}\n\nstatic int via_i2c_getsda(void *data)\n{\n\tstruct via_port_cfg *adap_data = data;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&i2c_vdev->reg_lock, flags);\n\tif (adap_data->type == VIA_PORT_GPIO)\n\t\tvia_write_reg_mask(adap_data->io_port, adap_data->ioport_index,\n\t\t\t0, 0x40);\n\tif (via_read_reg(adap_data->io_port, adap_data->ioport_index) & 0x04)\n\t\tret = 1;\n\tspin_unlock_irqrestore(&i2c_vdev->reg_lock, flags);\n\treturn ret;\n}\n\nstatic void via_i2c_setsda(void *data, int state)\n{\n\tu8 val;\n\tstruct via_port_cfg *adap_data = data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&i2c_vdev->reg_lock, flags);\n\tval = via_read_reg(adap_data->io_port, adap_data->ioport_index) & 0xF0;\n\tif (state)\n\t\tval |= 0x10;\n\telse\n\t\tval &= ~0x10;\n\tswitch (adap_data->type) {\n\tcase VIA_PORT_I2C:\n\t\tval |= 0x01;\n\t\tbreak;\n\tcase VIA_PORT_GPIO:\n\t\tval |= 0x42;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"viafb_i2c: specify wrong i2c type.\\n\");\n\t}\n\tvia_write_reg(adap_data->io_port, adap_data->ioport_index, val);\n\tspin_unlock_irqrestore(&i2c_vdev->reg_lock, flags);\n}\n\nint viafb_i2c_readbyte(u8 adap, u8 slave_addr, u8 index, u8 *pdata)\n{\n\tint ret;\n\tu8 mm1[] = {0x00};\n\tstruct i2c_msg msgs[2];\n\n\tif (!via_i2c_par[adap].is_active)\n\t\treturn -ENODEV;\n\t*pdata = 0;\n\tmsgs[0].flags = 0;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[0].addr = msgs[1].addr = slave_addr / 2;\n\tmm1[0] = index;\n\tmsgs[0].len = 1; msgs[1].len = 1;\n\tmsgs[0].buf = mm1; msgs[1].buf = pdata;\n\tret = i2c_transfer(&via_i2c_par[adap].adapter, msgs, 2);\n\tif (ret == 2)\n\t\tret = 0;\n\telse if (ret >= 0)\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\nint viafb_i2c_writebyte(u8 adap, u8 slave_addr, u8 index, u8 data)\n{\n\tint ret;\n\tu8 msg[2] = { index, data };\n\tstruct i2c_msg msgs;\n\n\tif (!via_i2c_par[adap].is_active)\n\t\treturn -ENODEV;\n\tmsgs.flags = 0;\n\tmsgs.addr = slave_addr / 2;\n\tmsgs.len = 2;\n\tmsgs.buf = msg;\n\tret = i2c_transfer(&via_i2c_par[adap].adapter, &msgs, 1);\n\tif (ret == 1)\n\t\tret = 0;\n\telse if (ret >= 0)\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\nint viafb_i2c_readbytes(u8 adap, u8 slave_addr, u8 index, u8 *buff, int buff_len)\n{\n\tint ret;\n\tu8 mm1[] = {0x00};\n\tstruct i2c_msg msgs[2];\n\n\tif (!via_i2c_par[adap].is_active)\n\t\treturn -ENODEV;\n\tmsgs[0].flags = 0;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[0].addr = msgs[1].addr = slave_addr / 2;\n\tmm1[0] = index;\n\tmsgs[0].len = 1; msgs[1].len = buff_len;\n\tmsgs[0].buf = mm1; msgs[1].buf = buff;\n\tret = i2c_transfer(&via_i2c_par[adap].adapter, msgs, 2);\n\tif (ret == 2)\n\t\tret = 0;\n\telse if (ret >= 0)\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\n \nstruct i2c_adapter *viafb_find_i2c_adapter(enum viafb_i2c_adap which)\n{\n\tstruct via_i2c_stuff *stuff = &via_i2c_par[which];\n\n\treturn &stuff->adapter;\n}\nEXPORT_SYMBOL_GPL(viafb_find_i2c_adapter);\n\n\nstatic int create_i2c_bus(struct i2c_adapter *adapter,\n\t\t\t  struct i2c_algo_bit_data *algo,\n\t\t\t  struct via_port_cfg *adap_cfg,\n\t\t\t  struct pci_dev *pdev)\n{\n\talgo->setsda = via_i2c_setsda;\n\talgo->setscl = via_i2c_setscl;\n\talgo->getsda = via_i2c_getsda;\n\talgo->getscl = via_i2c_getscl;\n\talgo->udelay = 10;\n\talgo->timeout = 2;\n\talgo->data = adap_cfg;\n\n\tsprintf(adapter->name, \"viafb i2c io_port idx 0x%02x\",\n\t\tadap_cfg->ioport_index);\n\tadapter->owner = THIS_MODULE;\n\tadapter->class = I2C_CLASS_DDC;\n\tadapter->algo_data = algo;\n\tif (pdev)\n\t\tadapter->dev.parent = &pdev->dev;\n\telse\n\t\tadapter->dev.parent = NULL;\n\t \n\n\t \n\tvia_i2c_setsda(adap_cfg, 1);\n\tvia_i2c_setscl(adap_cfg, 1);\n\tudelay(20);\n\n\treturn i2c_bit_add_bus(adapter);\n}\n\nstatic int viafb_i2c_probe(struct platform_device *platdev)\n{\n\tint i, ret;\n\tstruct via_port_cfg *configs;\n\n\ti2c_vdev = platdev->dev.platform_data;\n\tconfigs = i2c_vdev->port_cfg;\n\n\tfor (i = 0; i < VIAFB_NUM_PORTS; i++) {\n\t\tstruct via_port_cfg *adap_cfg = configs++;\n\t\tstruct via_i2c_stuff *i2c_stuff = &via_i2c_par[i];\n\n\t\ti2c_stuff->is_active = 0;\n\t\tif (adap_cfg->type == 0 || adap_cfg->mode != VIA_MODE_I2C)\n\t\t\tcontinue;\n\t\tret = create_i2c_bus(&i2c_stuff->adapter,\n\t\t\t\t     &i2c_stuff->algo, adap_cfg,\n\t\t\t\tNULL);  \n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_ERR \"viafb: cannot create i2c bus %u:%d\\n\",\n\t\t\t\ti, ret);\n\t\t\tcontinue;   \n\t\t}\n\t\ti2c_stuff->is_active = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void viafb_i2c_remove(struct platform_device *platdev)\n{\n\tint i;\n\n\tfor (i = 0; i < VIAFB_NUM_PORTS; i++) {\n\t\tstruct via_i2c_stuff *i2c_stuff = &via_i2c_par[i];\n\t\t \n\t\tif (i2c_stuff->is_active)\n\t\t\ti2c_del_adapter(&i2c_stuff->adapter);\n\t}\n}\n\nstatic struct platform_driver via_i2c_driver = {\n\t.driver = {\n\t\t.name = \"viafb-i2c\",\n\t},\n\t.probe = viafb_i2c_probe,\n\t.remove_new = viafb_i2c_remove,\n};\n\nint viafb_i2c_init(void)\n{\n\treturn platform_driver_register(&via_i2c_driver);\n}\n\nvoid viafb_i2c_exit(void)\n{\n\tplatform_driver_unregister(&via_i2c_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}