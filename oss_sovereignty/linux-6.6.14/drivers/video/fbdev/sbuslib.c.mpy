{
  "module_name": "sbuslib.c",
  "hash_id": "c1ef3f890514802e64f951a36f180619989724ef69ad289e93716191ee1720de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/sbuslib.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/fb.h>\n#include <linux/mm.h>\n#include <linux/uaccess.h>\n#include <linux/of.h>\n\n#include <asm/fbio.h>\n\n#include \"sbuslib.h\"\n\nvoid sbusfb_fill_var(struct fb_var_screeninfo *var, struct device_node *dp,\n\t\t     int bpp)\n{\n\tmemset(var, 0, sizeof(*var));\n\n\tvar->xres = of_getintprop_default(dp, \"width\", 1152);\n\tvar->yres = of_getintprop_default(dp, \"height\", 900);\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = var->yres;\n\tvar->bits_per_pixel = bpp;\n}\n\nEXPORT_SYMBOL(sbusfb_fill_var);\n\nstatic unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)\n{\n\tif (size == SBUS_MMAP_EMPTY) return 0;\n\tif (size >= 0) return size;\n\treturn fbsize * (-size);\n}\n\nint sbusfb_mmap_helper(struct sbus_mmap_map *map,\n\t\t       unsigned long physbase,\n\t\t       unsigned long fbsize,\n\t\t       unsigned long iospace,\n\t\t       struct vm_area_struct *vma)\n{\n\tunsigned int size, page, r, map_size;\n\tunsigned long map_offset = 0;\n\tunsigned long off;\n\tint i;\n                                        \n\tif (!(vma->vm_flags & (VM_SHARED | VM_MAYSHARE)))\n\t\treturn -EINVAL;\n\n\tsize = vma->vm_end - vma->vm_start;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\n\t \n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t \n\tfor (page = 0; page < size; ){\n\t\tmap_size = 0;\n\t\tfor (i = 0; map[i].size; i++)\n\t\t\tif (map[i].voff == off+page) {\n\t\t\t\tmap_size = sbusfb_mmapsize(map[i].size, fbsize);\n#ifdef __sparc_v9__\n#define POFF_MASK\t(PAGE_MASK|0x1UL)\n#else\n#define POFF_MASK\t(PAGE_MASK)\n#endif\t\t\t\t\n\t\t\t\tmap_offset = (physbase + map[i].poff) & POFF_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!map_size) {\n\t\t\tpage += PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (page + map_size > size)\n\t\t\tmap_size = size - page;\n\t\tr = io_remap_pfn_range(vma,\n\t\t\t\t\tvma->vm_start + page,\n\t\t\t\t\tMK_IOSPACE_PFN(iospace,\n\t\t\t\t\t\tmap_offset >> PAGE_SHIFT),\n\t\t\t\t\tmap_size,\n\t\t\t\t\tvma->vm_page_prot);\n\t\tif (r)\n\t\t\treturn -EAGAIN;\n\t\tpage += map_size;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sbusfb_mmap_helper);\n\nint sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,\n\t\t\tstruct fb_info *info,\n\t\t\tint type, int fb_depth, unsigned long fb_size)\n{\n\tswitch(cmd) {\n\tcase FBIOGTYPE: {\n\t\tstruct fbtype __user *f = (struct fbtype __user *) arg;\n\n\t\tif (put_user(type, &f->fb_type) ||\n\t\t    put_user(info->var.yres, &f->fb_height) ||\n\t\t    put_user(info->var.xres, &f->fb_width) ||\n\t\t    put_user(fb_depth, &f->fb_depth) ||\n\t\t    put_user(0, &f->fb_cmsize) ||\n\t\t    put_user(fb_size, &f->fb_cmsize))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase FBIOPUTCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tstruct fb_cmap cmap;\n\t\tu16 red, green, blue;\n\t\tu8 red8, green8, blue8;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tunsigned int index, count, i;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    get_user(count, &c->count) ||\n\t\t    get_user(ured, &c->red) ||\n\t\t    get_user(ugreen, &c->green) ||\n\t\t    get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tcmap.len = 1;\n\t\tcmap.red = &red;\n\t\tcmap.green = &green;\n\t\tcmap.blue = &blue;\n\t\tcmap.transp = NULL;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint err;\n\n\t\t\tif (get_user(red8, &ured[i]) ||\n\t\t\t    get_user(green8, &ugreen[i]) ||\n\t\t\t    get_user(blue8, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tred = red8 << 8;\n\t\t\tgreen = green8 << 8;\n\t\t\tblue = blue8 << 8;\n\n\t\t\tcmap.start = index + i;\n\t\t\terr = fb_set_cmap(&cmap, info);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase FBIOGETCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tstruct fb_cmap *cmap = &info->cmap;\n\t\tunsigned int index, count, i;\n\t\tu8 red, green, blue;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    get_user(count, &c->count) ||\n\t\t    get_user(ured, &c->red) ||\n\t\t    get_user(ugreen, &c->green) ||\n\t\t    get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tif (index > cmap->len || count > cmap->len - index)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tred = cmap->red[index + i] >> 8;\n\t\t\tgreen = cmap->green[index + i] >> 8;\n\t\t\tblue = cmap->blue[index + i] >> 8;\n\t\t\tif (put_user(red, &ured[i]) ||\n\t\t\t    put_user(green, &ugreen[i]) ||\n\t\t\t    put_user(blue, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(sbusfb_ioctl_helper);\n\n#ifdef CONFIG_COMPAT\nint sbusfb_compat_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase FBIOGTYPE:\n\tcase FBIOSATTR:\n\tcase FBIOGATTR:\n\tcase FBIOSVIDEO:\n\tcase FBIOGVIDEO:\n\tcase FBIOSCURSOR32:\n\tcase FBIOGCURSOR32:\t \n\tcase FBIOSCURPOS:\n\tcase FBIOGCURPOS:\n\tcase FBIOGCURMAX:\n\t\treturn info->fbops->fb_ioctl(info, cmd, arg);\n\tcase FBIOPUTCMAP32:\n\tcase FBIOPUTCMAP_SPARC: {\n\t\tstruct fbcmap32 c;\n\t\tstruct fb_cmap cmap;\n\t\tu16 red, green, blue;\n\t\tu8 red8, green8, blue8;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tunsigned int i;\n\n\t\tif (copy_from_user(&c, compat_ptr(arg), sizeof(c)))\n\t\t\treturn -EFAULT;\n\t\tured = compat_ptr(c.red);\n\t\tugreen = compat_ptr(c.green);\n\t\tublue = compat_ptr(c.blue);\n\n\t\tcmap.len = 1;\n\t\tcmap.red = &red;\n\t\tcmap.green = &green;\n\t\tcmap.blue = &blue;\n\t\tcmap.transp = NULL;\n\t\tfor (i = 0; i < c.count; i++) {\n\t\t\tint err;\n\n\t\t\tif (get_user(red8, &ured[i]) ||\n\t\t\t    get_user(green8, &ugreen[i]) ||\n\t\t\t    get_user(blue8, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tred = red8 << 8;\n\t\t\tgreen = green8 << 8;\n\t\t\tblue = blue8 << 8;\n\n\t\t\tcmap.start = c.index + i;\n\t\t\terr = fb_set_cmap(&cmap, info);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase FBIOGETCMAP32: {\n\t\tstruct fbcmap32 c;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tstruct fb_cmap *cmap = &info->cmap;\n\t\tunsigned int index, i;\n\t\tu8 red, green, blue;\n\n\t\tif (copy_from_user(&c, compat_ptr(arg), sizeof(c)))\n\t\t\treturn -EFAULT;\n\t\tindex = c.index;\n\t\tured = compat_ptr(c.red);\n\t\tugreen = compat_ptr(c.green);\n\t\tublue = compat_ptr(c.blue);\n\n\t\tif (index > cmap->len || c.count > cmap->len - index)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < c.count; i++) {\n\t\t\tred = cmap->red[index + i] >> 8;\n\t\t\tgreen = cmap->green[index + i] >> 8;\n\t\t\tblue = cmap->blue[index + i] >> 8;\n\t\t\tif (put_user(red, &ured[i]) ||\n\t\t\t    put_user(green, &ugreen[i]) ||\n\t\t\t    put_user(blue, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\nEXPORT_SYMBOL(sbusfb_compat_ioctl);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}