{
  "module_name": "clps711x-fb.c",
  "hash_id": "0d95a3eb757e823bb07e894a75f4242864405ed5e224e4437cd29197bf8be7d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/clps711x-fb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/fb.h>\n#include <linux/io.h>\n#include <linux/lcd.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/clps711x.h>\n#include <linux/regulator/consumer.h>\n#include <video/of_display_timing.h>\n\n#define CLPS711X_FB_NAME\t\"clps711x-fb\"\n#define CLPS711X_FB_BPP_MAX\t(4)\n\n \n#define CLPS711X_LCDCON\t\t(0x0000)\n# define LCDCON_GSEN\t\tBIT(30)\n# define LCDCON_GSMD\t\tBIT(31)\n#define CLPS711X_PALLSW\t\t(0x0280)\n#define CLPS711X_PALMSW\t\t(0x02c0)\n#define CLPS711X_FBADDR\t\t(0x0d40)\n\nstruct clps711x_fb_info {\n\tstruct clk\t\t*clk;\n\tvoid __iomem\t\t*base;\n\tstruct regmap\t\t*syscon;\n\tresource_size_t\t\tbuffsize;\n\tstruct fb_videomode\tmode;\n\tstruct regulator\t*lcd_pwr;\n\tu32\t\t\tac_prescale;\n\tbool\t\t\tcmap_invert;\n};\n\nstatic int clps711x_fb_setcolreg(u_int regno, u_int red, u_int green,\n\t\t\t\t u_int blue, u_int transp, struct fb_info *info)\n{\n\tstruct clps711x_fb_info *cfb = info->par;\n\tu32 level, mask, shift;\n\n\tif (regno >= BIT(info->var.bits_per_pixel))\n\t\treturn -EINVAL;\n\n\tshift = 4 * (regno & 7);\n\tmask  = 0xf << shift;\n\t \n\tlevel = (((red * 77 + green * 151 + blue * 28) >> 20) << shift) & mask;\n\tif (cfb->cmap_invert)\n\t\tlevel = 0xf - level;\n\n\tregno = (regno < 8) ? CLPS711X_PALLSW : CLPS711X_PALMSW;\n\n\twritel((readl(cfb->base + regno) & ~mask) | level, cfb->base + regno);\n\n\treturn 0;\n}\n\nstatic int clps711x_fb_check_var(struct fb_var_screeninfo *var,\n\t\t\t\t struct fb_info *info)\n{\n\tu32 val;\n\n\tif (var->bits_per_pixel < 1 ||\n\t    var->bits_per_pixel > CLPS711X_FB_BPP_MAX)\n\t\treturn -EINVAL;\n\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\tval = DIV_ROUND_UP(var->xres, 16) - 1;\n\tif (val < 0x01 || val > 0x3f)\n\t\treturn -EINVAL;\n\n\tval = DIV_ROUND_UP(var->yres * var->xres * var->bits_per_pixel, 128);\n\tval--;\n\tif (val < 0x001 || val > 0x1fff)\n\t\treturn -EINVAL;\n\n\tvar->transp.msb_right\t= 0;\n\tvar->transp.offset\t= 0;\n\tvar->transp.length\t= 0;\n\tvar->red.msb_right\t= 0;\n\tvar->red.offset\t\t= 0;\n\tvar->red.length\t\t= var->bits_per_pixel;\n\tvar->green\t\t= var->red;\n\tvar->blue\t\t= var->red;\n\tvar->grayscale\t\t= var->bits_per_pixel > 1;\n\n\treturn 0;\n}\n\nstatic int clps711x_fb_set_par(struct fb_info *info)\n{\n\tstruct clps711x_fb_info *cfb = info->par;\n\tresource_size_t size;\n\tu32 lcdcon, pps;\n\n\tsize = (info->var.xres * info->var.yres * info->var.bits_per_pixel) / 8;\n\tif (size > cfb->buffsize)\n\t\treturn -EINVAL;\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 1:\n\t\tinfo->fix.visual = FB_VISUAL_MONO01;\n\t\tbreak;\n\tcase 2:\n\tcase 4:\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->fix.line_length = info->var.xres * info->var.bits_per_pixel / 8;\n\tinfo->fix.smem_len = size;\n\n\tlcdcon = (info->var.xres * info->var.yres *\n\t\t  info->var.bits_per_pixel) / 128 - 1;\n\tlcdcon |= ((info->var.xres / 16) - 1) << 13;\n\tlcdcon |= (cfb->ac_prescale & 0x1f) << 25;\n\n\tpps = clk_get_rate(cfb->clk) / (PICOS2KHZ(info->var.pixclock) * 1000);\n\tif (pps)\n\t\tpps--;\n\tlcdcon |= (pps & 0x3f) << 19;\n\n\tif (info->var.bits_per_pixel == 4)\n\t\tlcdcon |= LCDCON_GSMD;\n\tif (info->var.bits_per_pixel >= 2)\n\t\tlcdcon |= LCDCON_GSEN;\n\n\t \n\tregmap_update_bits(cfb->syscon, SYSCON_OFFSET, SYSCON1_LCDEN, 0);\n\twritel(lcdcon, cfb->base + CLPS711X_LCDCON);\n\tregmap_update_bits(cfb->syscon, SYSCON_OFFSET,\n\t\t\t   SYSCON1_LCDEN, SYSCON1_LCDEN);\n\n\treturn 0;\n}\n\nstatic int clps711x_fb_blank(int blank, struct fb_info *info)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct fb_ops clps711x_fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_setcolreg\t= clps711x_fb_setcolreg,\n\t.fb_check_var\t= clps711x_fb_check_var,\n\t.fb_set_par\t= clps711x_fb_set_par,\n\t.fb_blank\t= clps711x_fb_blank,\n\t.fb_fillrect\t= sys_fillrect,\n\t.fb_copyarea\t= sys_copyarea,\n\t.fb_imageblit\t= sys_imageblit,\n};\n\nstatic int clps711x_lcd_check_fb(struct lcd_device *lcddev, struct fb_info *fi)\n{\n\tstruct clps711x_fb_info *cfb = dev_get_drvdata(&lcddev->dev);\n\n\treturn (!fi || fi->par == cfb) ? 1 : 0;\n}\n\nstatic int clps711x_lcd_get_power(struct lcd_device *lcddev)\n{\n\tstruct clps711x_fb_info *cfb = dev_get_drvdata(&lcddev->dev);\n\n\tif (!IS_ERR_OR_NULL(cfb->lcd_pwr))\n\t\tif (!regulator_is_enabled(cfb->lcd_pwr))\n\t\t\treturn FB_BLANK_NORMAL;\n\n\treturn FB_BLANK_UNBLANK;\n}\n\nstatic int clps711x_lcd_set_power(struct lcd_device *lcddev, int blank)\n{\n\tstruct clps711x_fb_info *cfb = dev_get_drvdata(&lcddev->dev);\n\n\tif (!IS_ERR_OR_NULL(cfb->lcd_pwr)) {\n\t\tif (blank == FB_BLANK_UNBLANK) {\n\t\t\tif (!regulator_is_enabled(cfb->lcd_pwr))\n\t\t\t\treturn regulator_enable(cfb->lcd_pwr);\n\t\t} else {\n\t\t\tif (regulator_is_enabled(cfb->lcd_pwr))\n\t\t\t\treturn regulator_disable(cfb->lcd_pwr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct lcd_ops clps711x_lcd_ops = {\n\t.check_fb\t= clps711x_lcd_check_fb,\n\t.get_power\t= clps711x_lcd_get_power,\n\t.set_power\t= clps711x_lcd_set_power,\n};\n\nstatic int clps711x_fb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *disp, *np = dev->of_node;\n\tstruct clps711x_fb_info *cfb;\n\tstruct lcd_device *lcd;\n\tstruct fb_info *info;\n\tstruct resource *res;\n\tint ret = -ENOENT;\n\tu32 val;\n\n\tif (fb_get_options(CLPS711X_FB_NAME, NULL))\n\t\treturn -ENODEV;\n\n\tinfo = framebuffer_alloc(sizeof(*cfb), dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tcfb = info->par;\n\tplatform_set_drvdata(pdev, info);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\tgoto out_fb_release;\n\tcfb->base = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!cfb->base) {\n\t\tret = -ENOMEM;\n\t\tgoto out_fb_release;\n\t}\n\n\tinfo->fix.mmio_start = res->start;\n\tinfo->fix.mmio_len = resource_size(res);\n\n\tinfo->screen_base = devm_platform_get_and_ioremap_resource(pdev, 1, &res);\n\tif (IS_ERR(info->screen_base)) {\n\t\tret = PTR_ERR(info->screen_base);\n\t\tgoto out_fb_release;\n\t}\n\n\t \n\tif (res->start & 0x0fffffff) {\n\t\tret = -EINVAL;\n\t\tgoto out_fb_release;\n\t}\n\n\tcfb->buffsize = resource_size(res);\n\tinfo->fix.smem_start = res->start;\n\n\tcfb->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(cfb->clk)) {\n\t\tret = PTR_ERR(cfb->clk);\n\t\tgoto out_fb_release;\n\t}\n\n\tcfb->syscon = syscon_regmap_lookup_by_phandle(np, \"syscon\");\n\tif (IS_ERR(cfb->syscon)) {\n\t\tret = PTR_ERR(cfb->syscon);\n\t\tgoto out_fb_release;\n\t}\n\n\tdisp = of_parse_phandle(np, \"display\", 0);\n\tif (!disp) {\n\t\tdev_err(&pdev->dev, \"No display defined\\n\");\n\t\tret = -ENODATA;\n\t\tgoto out_fb_release;\n\t}\n\n\tret = of_get_fb_videomode(disp, &cfb->mode, OF_USE_NATIVE_MODE);\n\tif (ret) {\n\t\tof_node_put(disp);\n\t\tgoto out_fb_release;\n\t}\n\n\tof_property_read_u32(disp, \"ac-prescale\", &cfb->ac_prescale);\n\tcfb->cmap_invert = of_property_read_bool(disp, \"cmap-invert\");\n\n\tret = of_property_read_u32(disp, \"bits-per-pixel\",\n\t\t\t\t   &info->var.bits_per_pixel);\n\tof_node_put(disp);\n\tif (ret)\n\t\tgoto out_fb_release;\n\n\t \n\tif (info->fix.smem_start != (readb(cfb->base + CLPS711X_FBADDR) << 28))\n\t\tregmap_update_bits(cfb->syscon, SYSCON_OFFSET,\n\t\t\t\t   SYSCON1_LCDEN, 0);\n\n\tret = regmap_read(cfb->syscon, SYSCON_OFFSET, &val);\n\tif (ret)\n\t\tgoto out_fb_release;\n\n\tif (!(val & SYSCON1_LCDEN)) {\n\t\t \n\t\twriteb(info->fix.smem_start >> 28, cfb->base + CLPS711X_FBADDR);\n\t\t \n\t\tmemset_io(info->screen_base, 0, cfb->buffsize);\n\t}\n\n\tcfb->lcd_pwr = devm_regulator_get(dev, \"lcd\");\n\tif (PTR_ERR(cfb->lcd_pwr) == -EPROBE_DEFER) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto out_fb_release;\n\t}\n\n\tinfo->fbops = &clps711x_fb_ops;\n\tinfo->var.activate = FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW;\n\tinfo->var.height = -1;\n\tinfo->var.width = -1;\n\tinfo->var.vmode = FB_VMODE_NONINTERLACED;\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.accel = FB_ACCEL_NONE;\n\tstrscpy(info->fix.id, CLPS711X_FB_NAME, sizeof(info->fix.id));\n\tfb_videomode_to_var(&info->var, &cfb->mode);\n\n\tret = fb_alloc_cmap(&info->cmap, BIT(CLPS711X_FB_BPP_MAX), 0);\n\tif (ret)\n\t\tgoto out_fb_release;\n\n\tret = fb_set_var(info, &info->var);\n\tif (ret)\n\t\tgoto out_fb_dealloc_cmap;\n\n\tret = register_framebuffer(info);\n\tif (ret)\n\t\tgoto out_fb_dealloc_cmap;\n\n\tlcd = devm_lcd_device_register(dev, \"clps711x-lcd\", dev, cfb,\n\t\t\t\t       &clps711x_lcd_ops);\n\tif (!IS_ERR(lcd))\n\t\treturn 0;\n\n\tret = PTR_ERR(lcd);\n\tunregister_framebuffer(info);\n\nout_fb_dealloc_cmap:\n\tregmap_update_bits(cfb->syscon, SYSCON_OFFSET, SYSCON1_LCDEN, 0);\n\tfb_dealloc_cmap(&info->cmap);\n\nout_fb_release:\n\tframebuffer_release(info);\n\n\treturn ret;\n}\n\nstatic void clps711x_fb_remove(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\tstruct clps711x_fb_info *cfb = info->par;\n\n\tregmap_update_bits(cfb->syscon, SYSCON_OFFSET, SYSCON1_LCDEN, 0);\n\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\tframebuffer_release(info);\n}\n\nstatic const struct of_device_id clps711x_fb_dt_ids[] = {\n\t{ .compatible = \"cirrus,ep7209-fb\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, clps711x_fb_dt_ids);\n\nstatic struct platform_driver clps711x_fb_driver = {\n\t.driver\t= {\n\t\t.name\t\t= CLPS711X_FB_NAME,\n\t\t.of_match_table\t= clps711x_fb_dt_ids,\n\t},\n\t.probe\t= clps711x_fb_probe,\n\t.remove_new = clps711x_fb_remove,\n};\nmodule_platform_driver(clps711x_fb_driver);\n\nMODULE_AUTHOR(\"Alexander Shiyan <shc_work@mail.ru>\");\nMODULE_DESCRIPTION(\"Cirrus Logic CLPS711X FB driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}