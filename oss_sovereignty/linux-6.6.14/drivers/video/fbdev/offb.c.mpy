{
  "module_name": "offb.c",
  "hash_id": "e86206a1f8bdc3a932837ef4f9689548961f55dee2434a36373b973ab61777ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/offb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/interrupt.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <asm/io.h>\n\n#ifdef CONFIG_PPC32\n#include <asm/bootx.h>\n#endif\n\n#include \"macmodes.h\"\n\n \nenum {\n\tcmap_unknown,\n\tcmap_simple,\t\t \n\tcmap_r128,\t\t \n\tcmap_M3A,\t\t \n\tcmap_M3B,\t\t \n\tcmap_radeon,\t\t \n\tcmap_gxt2000,\t\t \n\tcmap_avivo,\t\t \n\tcmap_qemu,\t\t \n};\n\nstruct offb_par {\n\tvolatile void __iomem *cmap_adr;\n\tvolatile void __iomem *cmap_data;\n\tint cmap_type;\n\tint blanked;\n\tu32 pseudo_palette[16];\n\tresource_size_t base;\n\tresource_size_t size;\n};\n\n#ifdef CONFIG_PPC32\nextern boot_infos_t *boot_infos;\n#endif\n\n \n#define AVIVO_DC_LUT_RW_SELECT                  0x6480\n#define AVIVO_DC_LUT_RW_MODE                    0x6484\n#define AVIVO_DC_LUT_RW_INDEX                   0x6488\n#define AVIVO_DC_LUT_SEQ_COLOR                  0x648c\n#define AVIVO_DC_LUT_PWL_DATA                   0x6490\n#define AVIVO_DC_LUT_30_COLOR                   0x6494\n#define AVIVO_DC_LUT_READ_PIPE_SELECT           0x6498\n#define AVIVO_DC_LUT_WRITE_EN_MASK              0x649c\n#define AVIVO_DC_LUT_AUTOFILL                   0x64a0\n\n#define AVIVO_DC_LUTA_CONTROL                   0x64c0\n#define AVIVO_DC_LUTA_BLACK_OFFSET_BLUE         0x64c4\n#define AVIVO_DC_LUTA_BLACK_OFFSET_GREEN        0x64c8\n#define AVIVO_DC_LUTA_BLACK_OFFSET_RED          0x64cc\n#define AVIVO_DC_LUTA_WHITE_OFFSET_BLUE         0x64d0\n#define AVIVO_DC_LUTA_WHITE_OFFSET_GREEN        0x64d4\n#define AVIVO_DC_LUTA_WHITE_OFFSET_RED          0x64d8\n\n#define AVIVO_DC_LUTB_CONTROL                   0x6cc0\n#define AVIVO_DC_LUTB_BLACK_OFFSET_BLUE         0x6cc4\n#define AVIVO_DC_LUTB_BLACK_OFFSET_GREEN        0x6cc8\n#define AVIVO_DC_LUTB_BLACK_OFFSET_RED          0x6ccc\n#define AVIVO_DC_LUTB_WHITE_OFFSET_BLUE         0x6cd0\n#define AVIVO_DC_LUTB_WHITE_OFFSET_GREEN        0x6cd4\n#define AVIVO_DC_LUTB_WHITE_OFFSET_RED          0x6cd8\n\n     \n\nstatic int offb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t  u_int transp, struct fb_info *info)\n{\n\tstruct offb_par *par = (struct offb_par *) info->par;\n\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\tu32 *pal = info->pseudo_palette;\n\t\tu32 cr = red >> (16 - info->var.red.length);\n\t\tu32 cg = green >> (16 - info->var.green.length);\n\t\tu32 cb = blue >> (16 - info->var.blue.length);\n\t\tu32 value;\n\n\t\tif (regno >= 16)\n\t\t\treturn -EINVAL;\n\n\t\tvalue = (cr << info->var.red.offset) |\n\t\t\t(cg << info->var.green.offset) |\n\t\t\t(cb << info->var.blue.offset);\n\t\tif (info->var.transp.length > 0) {\n\t\t\tu32 mask = (1 << info->var.transp.length) - 1;\n\t\t\tmask <<= info->var.transp.offset;\n\t\t\tvalue |= mask;\n\t\t}\n\t\tpal[regno] = value;\n\t\treturn 0;\n\t}\n\n\tif (regno > 255)\n\t\treturn -EINVAL;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\tif (!par->cmap_adr)\n\t\treturn 0;\n\n\tswitch (par->cmap_type) {\n\tcase cmap_simple:\n\t\twriteb(regno, par->cmap_adr);\n\t\twriteb(red, par->cmap_data);\n\t\twriteb(green, par->cmap_data);\n\t\twriteb(blue, par->cmap_data);\n\t\tbreak;\n\tcase cmap_M3A:\n\t\t \n\t\tout_le32(par->cmap_adr + 0x58,\n\t\t\t in_le32(par->cmap_adr + 0x58) & ~0x20);\n\t\tfallthrough;\n\tcase cmap_r128:\n\t\t \n\t\tout_8(par->cmap_adr + 0xb0, regno);\n\t\tout_le32(par->cmap_adr + 0xb4,\n\t\t\t (red << 16 | green << 8 | blue));\n\t\tbreak;\n\tcase cmap_M3B:\n\t\t \n\t\tout_le32(par->cmap_adr + 0x58,\n\t\t\t in_le32(par->cmap_adr + 0x58) | 0x20);\n\t\t \n\t\tout_8(par->cmap_adr + 0xb0, regno);\n\t\tout_le32(par->cmap_adr + 0xb4, (red << 16 | green << 8 | blue));\n\t\tbreak;\n\tcase cmap_radeon:\n\t\t \n\t\tout_8(par->cmap_adr + 0xb0, regno);\n\t\tout_le32(par->cmap_adr + 0xb4, (red << 16 | green << 8 | blue));\n\t\tbreak;\n\tcase cmap_gxt2000:\n\t\tout_le32(((unsigned __iomem *) par->cmap_adr) + regno,\n\t\t\t (red << 16 | green << 8 | blue));\n\t\tbreak;\n\tcase cmap_avivo:\n\t\t \n\t\twritel(1, par->cmap_adr + AVIVO_DC_LUT_RW_SELECT);\n\t\twriteb(regno, par->cmap_adr + AVIVO_DC_LUT_RW_INDEX);\n\t\twritel(((red) << 22) | ((green) << 12) | ((blue) << 2),\n\t\t       par->cmap_adr + AVIVO_DC_LUT_30_COLOR);\n\t\twritel(0, par->cmap_adr + AVIVO_DC_LUT_RW_SELECT);\n\t\twriteb(regno, par->cmap_adr + AVIVO_DC_LUT_RW_INDEX);\n\t\twritel(((red) << 22) | ((green) << 12) | ((blue) << 2),\n\t\t       par->cmap_adr + AVIVO_DC_LUT_30_COLOR);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n     \n\nstatic int offb_blank(int blank, struct fb_info *info)\n{\n\tstruct offb_par *par = (struct offb_par *) info->par;\n\tint i, j;\n\n\tif (!par->cmap_adr)\n\t\treturn 0;\n\n\tif (!par->blanked)\n\t\tif (!blank)\n\t\t\treturn 0;\n\n\tpar->blanked = blank;\n\n\tif (blank)\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tswitch (par->cmap_type) {\n\t\t\tcase cmap_simple:\n\t\t\t\twriteb(i, par->cmap_adr);\n\t\t\t\tfor (j = 0; j < 3; j++)\n\t\t\t\t\twriteb(0, par->cmap_data);\n\t\t\t\tbreak;\n\t\t\tcase cmap_M3A:\n\t\t\t\t \n\t\t\t\tout_le32(par->cmap_adr + 0x58,\n\t\t\t\t\t in_le32(par->cmap_adr + 0x58) & ~0x20);\n\t\t\t\tfallthrough;\n\t\t\tcase cmap_r128:\n\t\t\t\t \n\t\t\t\tout_8(par->cmap_adr + 0xb0, i);\n\t\t\t\tout_le32(par->cmap_adr + 0xb4, 0);\n\t\t\t\tbreak;\n\t\t\tcase cmap_M3B:\n\t\t\t\t \n\t\t\t\tout_le32(par->cmap_adr + 0x58,\n\t\t\t\t\t in_le32(par->cmap_adr + 0x58) | 0x20);\n\t\t\t\t \n\t\t\t\tout_8(par->cmap_adr + 0xb0, i);\n\t\t\t\tout_le32(par->cmap_adr + 0xb4, 0);\n\t\t\t\tbreak;\n\t\t\tcase cmap_radeon:\n\t\t\t\tout_8(par->cmap_adr + 0xb0, i);\n\t\t\t\tout_le32(par->cmap_adr + 0xb4, 0);\n\t\t\t\tbreak;\n\t\t\tcase cmap_gxt2000:\n\t\t\t\tout_le32(((unsigned __iomem *) par->cmap_adr) + i,\n\t\t\t\t\t 0);\n\t\t\t\tbreak;\n\t\t\tcase cmap_avivo:\n\t\t\t\twritel(1, par->cmap_adr + AVIVO_DC_LUT_RW_SELECT);\n\t\t\t\twriteb(i, par->cmap_adr + AVIVO_DC_LUT_RW_INDEX);\n\t\t\t\twritel(0, par->cmap_adr + AVIVO_DC_LUT_30_COLOR);\n\t\t\t\twritel(0, par->cmap_adr + AVIVO_DC_LUT_RW_SELECT);\n\t\t\t\twriteb(i, par->cmap_adr + AVIVO_DC_LUT_RW_INDEX);\n\t\t\t\twritel(0, par->cmap_adr + AVIVO_DC_LUT_30_COLOR);\n\t\t\t\tbreak;\n\t\t\t}\n\t} else\n\t\tfb_set_cmap(&info->cmap, info);\n\treturn 0;\n}\n\nstatic int offb_set_par(struct fb_info *info)\n{\n\tstruct offb_par *par = (struct offb_par *) info->par;\n\n\t \n\tif (par->cmap_type == cmap_avivo) {\n\t\twritel(0, par->cmap_adr + AVIVO_DC_LUTA_CONTROL);\n\t\twritel(0, par->cmap_adr + AVIVO_DC_LUTA_BLACK_OFFSET_BLUE);\n\t\twritel(0, par->cmap_adr + AVIVO_DC_LUTA_BLACK_OFFSET_GREEN);\n\t\twritel(0, par->cmap_adr + AVIVO_DC_LUTA_BLACK_OFFSET_RED);\n\t\twritel(0x0000ffff, par->cmap_adr + AVIVO_DC_LUTA_WHITE_OFFSET_BLUE);\n\t\twritel(0x0000ffff, par->cmap_adr + AVIVO_DC_LUTA_WHITE_OFFSET_GREEN);\n\t\twritel(0x0000ffff, par->cmap_adr + AVIVO_DC_LUTA_WHITE_OFFSET_RED);\n\t\twritel(0, par->cmap_adr + AVIVO_DC_LUTB_CONTROL);\n\t\twritel(0, par->cmap_adr + AVIVO_DC_LUTB_BLACK_OFFSET_BLUE);\n\t\twritel(0, par->cmap_adr + AVIVO_DC_LUTB_BLACK_OFFSET_GREEN);\n\t\twritel(0, par->cmap_adr + AVIVO_DC_LUTB_BLACK_OFFSET_RED);\n\t\twritel(0x0000ffff, par->cmap_adr + AVIVO_DC_LUTB_WHITE_OFFSET_BLUE);\n\t\twritel(0x0000ffff, par->cmap_adr + AVIVO_DC_LUTB_WHITE_OFFSET_GREEN);\n\t\twritel(0x0000ffff, par->cmap_adr + AVIVO_DC_LUTB_WHITE_OFFSET_RED);\n\t\twritel(1, par->cmap_adr + AVIVO_DC_LUT_RW_SELECT);\n\t\twritel(0, par->cmap_adr + AVIVO_DC_LUT_RW_MODE);\n\t\twritel(0x0000003f, par->cmap_adr + AVIVO_DC_LUT_WRITE_EN_MASK);\n\t\twritel(0, par->cmap_adr + AVIVO_DC_LUT_RW_SELECT);\n\t\twritel(0, par->cmap_adr + AVIVO_DC_LUT_RW_MODE);\n\t\twritel(0x0000003f, par->cmap_adr + AVIVO_DC_LUT_WRITE_EN_MASK);\n\t}\n\treturn 0;\n}\n\nstatic void offb_destroy(struct fb_info *info)\n{\n\tstruct offb_par *par = info->par;\n\n\tif (info->screen_base)\n\t\tiounmap(info->screen_base);\n\trelease_mem_region(par->base, par->size);\n\tfb_dealloc_cmap(&info->cmap);\n\tframebuffer_release(info);\n}\n\nstatic const struct fb_ops offb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_destroy\t= offb_destroy,\n\t.fb_setcolreg\t= offb_setcolreg,\n\t.fb_set_par\t= offb_set_par,\n\t.fb_blank\t= offb_blank,\n};\n\nstatic void __iomem *offb_map_reg(struct device_node *np, int index,\n\t\t\t\t  unsigned long offset, unsigned long size)\n{\n\tconst __be32 *addrp;\n\tu64 asize, taddr;\n\tunsigned int flags;\n\n\taddrp = of_get_pci_address(np, index, &asize, &flags);\n\tif (addrp == NULL)\n\t\taddrp = of_get_address(np, index, &asize, &flags);\n\tif (addrp == NULL)\n\t\treturn NULL;\n\tif ((flags & (IORESOURCE_IO | IORESOURCE_MEM)) == 0)\n\t\treturn NULL;\n\tif ((offset + size) > asize)\n\t\treturn NULL;\n\ttaddr = of_translate_address(np, addrp);\n\tif (taddr == OF_BAD_ADDR)\n\t\treturn NULL;\n\treturn ioremap(taddr + offset, size);\n}\n\nstatic void offb_init_palette_hacks(struct fb_info *info, struct device_node *dp,\n\t\t\t\t    unsigned long address)\n{\n\tstruct offb_par *par = (struct offb_par *) info->par;\n\n\tif (of_node_name_prefix(dp, \"ATY,Rage128\")) {\n\t\tpar->cmap_adr = offb_map_reg(dp, 2, 0, 0x1fff);\n\t\tif (par->cmap_adr)\n\t\t\tpar->cmap_type = cmap_r128;\n\t} else if (of_node_name_prefix(dp, \"ATY,RageM3pA\") ||\n\t\t   of_node_name_prefix(dp, \"ATY,RageM3p12A\")) {\n\t\tpar->cmap_adr = offb_map_reg(dp, 2, 0, 0x1fff);\n\t\tif (par->cmap_adr)\n\t\t\tpar->cmap_type = cmap_M3A;\n\t} else if (of_node_name_prefix(dp, \"ATY,RageM3pB\")) {\n\t\tpar->cmap_adr = offb_map_reg(dp, 2, 0, 0x1fff);\n\t\tif (par->cmap_adr)\n\t\t\tpar->cmap_type = cmap_M3B;\n\t} else if (of_node_name_prefix(dp, \"ATY,Rage6\")) {\n\t\tpar->cmap_adr = offb_map_reg(dp, 1, 0, 0x1fff);\n\t\tif (par->cmap_adr)\n\t\t\tpar->cmap_type = cmap_radeon;\n\t} else if (of_node_name_prefix(dp, \"ATY,\")) {\n\t\tunsigned long base = address & 0xff000000UL;\n\t\tpar->cmap_adr =\n\t\t\tioremap(base + 0x7ff000, 0x1000) + 0xcc0;\n\t\tpar->cmap_data = par->cmap_adr + 1;\n\t\tpar->cmap_type = cmap_simple;\n\t} else if (dp && (of_device_is_compatible(dp, \"pci1014,b7\") ||\n\t\t\t  of_device_is_compatible(dp, \"pci1014,21c\"))) {\n\t\tpar->cmap_adr = offb_map_reg(dp, 0, 0x6000, 0x1000);\n\t\tif (par->cmap_adr)\n\t\t\tpar->cmap_type = cmap_gxt2000;\n\t} else if (of_node_name_prefix(dp, \"vga,Display-\")) {\n\t\t \n\t\tstruct device_node *pciparent = of_get_parent(dp);\n\t\tconst u32 *vid, *did;\n\t\tvid = of_get_property(pciparent, \"vendor-id\", NULL);\n\t\tdid = of_get_property(pciparent, \"device-id\", NULL);\n\t\t \n\t\tif (vid && did && *vid == 0x1002 &&\n\t\t    ((*did >= 0x7100 && *did < 0x7800) ||\n\t\t     (*did >= 0x9400))) {\n\t\t\tpar->cmap_adr = offb_map_reg(pciparent, 2, 0, 0x10000);\n\t\t\tif (par->cmap_adr)\n\t\t\t\tpar->cmap_type = cmap_avivo;\n\t\t}\n\t\tof_node_put(pciparent);\n\t} else if (dp && of_device_is_compatible(dp, \"qemu,std-vga\")) {\n#ifdef __BIG_ENDIAN\n\t\tconst __be32 io_of_addr[3] = { 0x01000000, 0x0, 0x0 };\n#else\n\t\tconst __be32 io_of_addr[3] = { 0x00000001, 0x0, 0x0 };\n#endif\n\t\tu64 io_addr = of_translate_address(dp, io_of_addr);\n\t\tif (io_addr != OF_BAD_ADDR) {\n\t\t\tpar->cmap_adr = ioremap(io_addr + 0x3c8, 2);\n\t\t\tif (par->cmap_adr) {\n\t\t\t\tpar->cmap_type = cmap_simple;\n\t\t\t\tpar->cmap_data = par->cmap_adr + 1;\n\t\t\t}\n\t\t}\n\t}\n\tinfo->fix.visual = (par->cmap_type != cmap_unknown) ?\n\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_STATIC_PSEUDOCOLOR;\n}\n\nstatic void offb_init_fb(struct platform_device *parent, const char *name,\n\t\t\t int width, int height, int depth,\n\t\t\t int pitch, unsigned long address,\n\t\t\t int foreign_endian, struct device_node *dp)\n{\n\tunsigned long res_size = pitch * height;\n\tunsigned long res_start = address;\n\tstruct fb_fix_screeninfo *fix;\n\tstruct fb_var_screeninfo *var;\n\tstruct fb_info *info;\n\tstruct offb_par *par;\n\n\tif (!request_mem_region(res_start, res_size, \"offb\"))\n\t\treturn;\n\n\tprintk(KERN_INFO\n\t       \"Using unsupported %dx%d %s at %lx, depth=%d, pitch=%d\\n\",\n\t       width, height, name, address, depth, pitch);\n\tif (depth != 8 && depth != 15 && depth != 16 && depth != 32) {\n\t\tprintk(KERN_ERR \"%pOF: can't use depth = %d\\n\", dp, depth);\n\t\trelease_mem_region(res_start, res_size);\n\t\treturn;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(*par), &parent->dev);\n\tif (!info) {\n\t\trelease_mem_region(res_start, res_size);\n\t\treturn;\n\t}\n\tplatform_set_drvdata(parent, info);\n\tpar = info->par;\n\tfix = &info->fix;\n\tvar = &info->var;\n\n\tif (name) {\n\t\tstrcpy(fix->id, \"OFfb \");\n\t\tstrncat(fix->id, name, sizeof(fix->id) - sizeof(\"OFfb \"));\n\t\tfix->id[sizeof(fix->id) - 1] = '\\0';\n\t} else\n\t\tsnprintf(fix->id, sizeof(fix->id), \"OFfb %pOFn\", dp);\n\n\n\tvar->xres = var->xres_virtual = width;\n\tvar->yres = var->yres_virtual = height;\n\tfix->line_length = pitch;\n\n\tfix->smem_start = address;\n\tfix->smem_len = pitch * height;\n\tfix->type = FB_TYPE_PACKED_PIXELS;\n\tfix->type_aux = 0;\n\n\tpar->cmap_type = cmap_unknown;\n\tif (depth == 8)\n\t\toffb_init_palette_hacks(info, dp, address);\n\telse\n\t\tfix->visual = FB_VISUAL_TRUECOLOR;\n\n\tvar->xoffset = var->yoffset = 0;\n\tswitch (depth) {\n\tcase 8:\n\t\tvar->bits_per_pixel = 8;\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 15:\t\t \n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 10;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 5;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 16:\t\t \n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 11;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 32:\t\t \n\t\tvar->bits_per_pixel = 32;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tbreak;\n\t}\n\tvar->red.msb_right = var->green.msb_right = var->blue.msb_right =\n\t    var->transp.msb_right = 0;\n\tvar->grayscale = 0;\n\tvar->nonstd = 0;\n\tvar->activate = 0;\n\tvar->height = var->width = -1;\n\tvar->pixclock = 10000;\n\tvar->left_margin = var->right_margin = 16;\n\tvar->upper_margin = var->lower_margin = 16;\n\tvar->hsync_len = var->vsync_len = 8;\n\tvar->sync = 0;\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\n\tpar->base = address;\n\tpar->size = fix->smem_len;\n\n\tinfo->fbops = &offb_ops;\n\tinfo->screen_base = ioremap(address, fix->smem_len);\n\tinfo->pseudo_palette = par->pseudo_palette;\n\tinfo->flags = foreign_endian;\n\n\tfb_alloc_cmap(&info->cmap, 256, 0);\n\n\tif (devm_aperture_acquire_for_platform_device(parent, par->base, par->size) < 0)\n\t\tgoto out_err;\n\tif (register_framebuffer(info) < 0)\n\t\tgoto out_err;\n\n\tfb_info(info, \"Open Firmware frame buffer device on %pOF\\n\", dp);\n\treturn;\n\nout_err:\n\tfb_dealloc_cmap(&info->cmap);\n\tiounmap(info->screen_base);\n\tiounmap(par->cmap_adr);\n\tpar->cmap_adr = NULL;\n\tframebuffer_release(info);\n\trelease_mem_region(res_start, res_size);\n}\n\n\nstatic void offb_init_nodriver(struct platform_device *parent, struct device_node *dp,\n\t\t\t       int no_real_node)\n{\n\tunsigned int len;\n\tint i, width = 640, height = 480, depth = 8, pitch = 640;\n\tunsigned int flags, rsize, addr_prop = 0;\n\tunsigned long max_size = 0;\n\tu64 rstart, address = OF_BAD_ADDR;\n\tconst __be32 *pp, *addrp, *up;\n\tu64 asize;\n\tint foreign_endian = 0;\n\n#ifdef __BIG_ENDIAN\n\tif (of_property_read_bool(dp, \"little-endian\"))\n\t\tforeign_endian = FBINFO_FOREIGN_ENDIAN;\n#else\n\tif (of_property_read_bool(dp, \"big-endian\"))\n\t\tforeign_endian = FBINFO_FOREIGN_ENDIAN;\n#endif\n\n\tpp = of_get_property(dp, \"linux,bootx-depth\", &len);\n\tif (pp == NULL)\n\t\tpp = of_get_property(dp, \"depth\", &len);\n\tif (pp && len == sizeof(u32))\n\t\tdepth = be32_to_cpup(pp);\n\n\tpp = of_get_property(dp, \"linux,bootx-width\", &len);\n\tif (pp == NULL)\n\t\tpp = of_get_property(dp, \"width\", &len);\n\tif (pp && len == sizeof(u32))\n\t\twidth = be32_to_cpup(pp);\n\n\tpp = of_get_property(dp, \"linux,bootx-height\", &len);\n\tif (pp == NULL)\n\t\tpp = of_get_property(dp, \"height\", &len);\n\tif (pp && len == sizeof(u32))\n\t\theight = be32_to_cpup(pp);\n\n\tpp = of_get_property(dp, \"linux,bootx-linebytes\", &len);\n\tif (pp == NULL)\n\t\tpp = of_get_property(dp, \"linebytes\", &len);\n\tif (pp && len == sizeof(u32) && (*pp != 0xffffffffu))\n\t\tpitch = be32_to_cpup(pp);\n\telse\n\t\tpitch = width * ((depth + 7) / 8);\n\n\trsize = (unsigned long)pitch * (unsigned long)height;\n\n\t \n\tup = of_get_property(dp, \"linux,bootx-addr\", &len);\n\tif (up == NULL)\n\t\tup = of_get_property(dp, \"address\", &len);\n\tif (up && len == sizeof(u32))\n\t\taddr_prop = *up;\n\n\t \n\tif (no_real_node)\n\t\tgoto skip_addr;\n\n\tfor (i = 0; (addrp = of_get_address(dp, i, &asize, &flags))\n\t\t     != NULL; i++) {\n\t\tint match_addrp = 0;\n\n\t\tif (!(flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tif (asize < rsize)\n\t\t\tcontinue;\n\t\trstart = of_translate_address(dp, addrp);\n\t\tif (rstart == OF_BAD_ADDR)\n\t\t\tcontinue;\n\t\tif (addr_prop && (rstart <= addr_prop) &&\n\t\t    ((rstart + asize) >= (addr_prop + rsize)))\n\t\t\tmatch_addrp = 1;\n\t\tif (match_addrp) {\n\t\t\taddress = addr_prop;\n\t\t\tbreak;\n\t\t}\n\t\tif (rsize > max_size) {\n\t\t\tmax_size = rsize;\n\t\t\taddress = OF_BAD_ADDR;\n \t\t}\n\n\t\tif (address == OF_BAD_ADDR)\n\t\t\taddress = rstart;\n\t}\n skip_addr:\n\tif (address == OF_BAD_ADDR && addr_prop)\n\t\taddress = (u64)addr_prop;\n\tif (address != OF_BAD_ADDR) {\n#ifdef CONFIG_PCI\n\t\tconst __be32 *vidp, *didp;\n\t\tu32 vid, did;\n\t\tstruct pci_dev *pdev;\n\n\t\tvidp = of_get_property(dp, \"vendor-id\", NULL);\n\t\tdidp = of_get_property(dp, \"device-id\", NULL);\n\t\tif (vidp && didp) {\n\t\t\tvid = be32_to_cpup(vidp);\n\t\t\tdid = be32_to_cpup(didp);\n\t\t\tpdev = pci_get_device(vid, did, NULL);\n\t\t\tif (!pdev || pci_enable_device(pdev))\n\t\t\t\treturn;\n\t\t}\n#endif\n\t\t \n\t\tif (of_node_name_eq(dp, \"valkyrie\"))\n\t\t\taddress += 0x1000;\n\t\toffb_init_fb(parent, no_real_node ? \"bootx\" : NULL,\n\t\t\t     width, height, depth, pitch, address,\n\t\t\t     foreign_endian, no_real_node ? NULL : dp);\n\t}\n}\n\nstatic void offb_remove(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\n\tif (info)\n\t\tunregister_framebuffer(info);\n}\n\nstatic int offb_probe_bootx_noscreen(struct platform_device *pdev)\n{\n\toffb_init_nodriver(pdev, of_chosen, 1);\n\n\treturn 0;\n}\n\nstatic struct platform_driver offb_driver_bootx_noscreen = {\n\t.driver = {\n\t\t.name = \"bootx-noscreen\",\n\t},\n\t.probe = offb_probe_bootx_noscreen,\n\t.remove_new = offb_remove,\n};\n\nstatic int offb_probe_display(struct platform_device *pdev)\n{\n\toffb_init_nodriver(pdev, pdev->dev.of_node, 0);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id offb_of_match_display[] = {\n\t{ .compatible = \"display\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, offb_of_match_display);\n\nstatic struct platform_driver offb_driver_display = {\n\t.driver = {\n\t\t.name = \"of-display\",\n\t\t.of_match_table = offb_of_match_display,\n\t},\n\t.probe = offb_probe_display,\n\t.remove_new = offb_remove,\n};\n\nstatic int __init offb_init(void)\n{\n\tif (fb_get_options(\"offb\", NULL))\n\t\treturn -ENODEV;\n\n\tplatform_driver_register(&offb_driver_bootx_noscreen);\n\tplatform_driver_register(&offb_driver_display);\n\n\treturn 0;\n}\nmodule_init(offb_init);\n\nstatic void __exit offb_exit(void)\n{\n\tplatform_driver_unregister(&offb_driver_display);\n\tplatform_driver_unregister(&offb_driver_bootx_noscreen);\n}\nmodule_exit(offb_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}