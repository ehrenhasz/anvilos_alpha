{
  "module_name": "hgafb.c",
  "hash_id": "326d017808e0fbceb702a96cbd08dd6223ae3c78304131e402b7913bfddecba0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/hgafb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <asm/io.h>\n#include <asm/vga.h>\n\n#if 0\n#define DPRINTK(args...) printk(KERN_DEBUG __FILE__\": \" ##args)\n#else\n#define DPRINTK(args...)\n#endif\n\n#if 0\n#define CHKINFO(ret) if (info != &fb_info) { printk(KERN_DEBUG __FILE__\": This should never happen, line:%d \\n\", __LINE__); return ret; }\n#else\n#define CHKINFO(ret)\n#endif\n\n \n\nstatic void __iomem *hga_vram;\t\t\t \nstatic unsigned long hga_vram_len;\t\t \n\n#define HGA_ROWADDR(row) ((row%4)*8192 + (row>>2)*90)\n#define HGA_TXT\t\t\t0\n#define HGA_GFX\t\t\t1\n\nstatic inline u8 __iomem * rowaddr(struct fb_info *info, u_int row)\n{\n\treturn info->screen_base + HGA_ROWADDR(row);\n}\n\nstatic int hga_mode = -1;\t\t\t \n\nstatic enum { TYPE_HERC, TYPE_HERCPLUS, TYPE_HERCCOLOR } hga_type;\nstatic char *hga_type_name;\n\n#define HGA_INDEX_PORT\t\t0x3b4\t\t \n#define HGA_VALUE_PORT\t\t0x3b5\t\t \n#define HGA_MODE_PORT\t\t0x3b8\t\t \n#define HGA_STATUS_PORT\t\t0x3ba\t\t \n#define HGA_GFX_PORT\t\t0x3bf\t\t \n\n \n\n#define HGA_CURSOR_BLINKING\t0x00\n#define HGA_CURSOR_OFF\t\t0x20\n#define HGA_CURSOR_SLOWBLINK\t0x60\n\n#define HGA_MODE_GRAPHICS\t0x02\n#define HGA_MODE_VIDEO_EN\t0x08\n#define HGA_MODE_BLINK_EN\t0x20\n#define HGA_MODE_GFX_PAGE1\t0x80\n\n#define HGA_STATUS_HSYNC\t0x01\n#define HGA_STATUS_VSYNC\t0x80\n#define HGA_STATUS_VIDEO\t0x08\n\n#define HGA_CONFIG_COL132\t0x08\n#define HGA_GFX_MODE_EN\t\t0x01\n#define HGA_GFX_PAGE_EN\t\t0x02\n\n \n\nstatic DEFINE_SPINLOCK(hga_reg_lock);\n\n \n\nstatic const struct fb_var_screeninfo hga_default_var = {\n\t.xres\t\t= 720,\n\t.yres \t\t= 348,\n\t.xres_virtual \t= 720,\n\t.yres_virtual\t= 348,\n\t.bits_per_pixel = 1,\n\t.red \t\t= {0, 1, 0},\n\t.green \t\t= {0, 1, 0},\n\t.blue \t\t= {0, 1, 0},\n\t.transp \t= {0, 0, 0},\n\t.height \t= -1,\n\t.width \t\t= -1,\n};\n\nstatic struct fb_fix_screeninfo hga_fix = {\n\t.id \t\t= \"HGA\",\n\t.type \t\t= FB_TYPE_PACKED_PIXELS,\t \n\t.visual \t= FB_VISUAL_MONO10,\n\t.xpanstep \t= 8,\n\t.ypanstep \t= 8,\n\t.line_length \t= 90,\n\t.accel \t\t= FB_ACCEL_NONE\n};\n\n \nstatic int release_io_port = 0;\nstatic int release_io_ports = 0;\nstatic bool nologo = 0;\n\n \n\nstatic void write_hga_b(unsigned int val, unsigned char reg)\n{\n\toutb_p(reg, HGA_INDEX_PORT);\n\toutb_p(val, HGA_VALUE_PORT);\n}\n\nstatic void write_hga_w(unsigned int val, unsigned char reg)\n{\n\toutb_p(reg,   HGA_INDEX_PORT); outb_p(val >> 8,   HGA_VALUE_PORT);\n\toutb_p(reg+1, HGA_INDEX_PORT); outb_p(val & 0xff, HGA_VALUE_PORT);\n}\n\nstatic int test_hga_b(unsigned char val, unsigned char reg)\n{\n\toutb_p(reg, HGA_INDEX_PORT);\n\toutb  (val, HGA_VALUE_PORT);\n\tudelay(20); val = (inb_p(HGA_VALUE_PORT) == val);\n\treturn val;\n}\n\nstatic void hga_clear_screen(void)\n{\n\tunsigned char fillchar = 0xbf;  \n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hga_reg_lock, flags);\n\tif (hga_mode == HGA_TXT)\n\t\tfillchar = ' ';\n\telse if (hga_mode == HGA_GFX)\n\t\tfillchar = 0x00;\n\tspin_unlock_irqrestore(&hga_reg_lock, flags);\n\tif (fillchar != 0xbf)\n\t\tmemset_io(hga_vram, fillchar, hga_vram_len);\n}\n\nstatic void hga_txt_mode(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hga_reg_lock, flags);\n\toutb_p(HGA_MODE_VIDEO_EN | HGA_MODE_BLINK_EN, HGA_MODE_PORT);\n\toutb_p(0x00, HGA_GFX_PORT);\n\toutb_p(0x00, HGA_STATUS_PORT);\n\n\twrite_hga_b(0x61, 0x00);\t \n\twrite_hga_b(0x50, 0x01);\t \n\twrite_hga_b(0x52, 0x02);\t \n\twrite_hga_b(0x0f, 0x03);\t \n\n\twrite_hga_b(0x19, 0x04);\t \n\twrite_hga_b(0x06, 0x05);\t \n\twrite_hga_b(0x19, 0x06);\t \n\twrite_hga_b(0x19, 0x07);\t \n\n\twrite_hga_b(0x02, 0x08);\t \n\twrite_hga_b(0x0d, 0x09);\t \n\twrite_hga_b(0x0c, 0x0a);\t \n\twrite_hga_b(0x0d, 0x0b);\t \n\n\twrite_hga_w(0x0000, 0x0c);\t \n\twrite_hga_w(0x0000, 0x0e);\t \n\n\thga_mode = HGA_TXT;\n\tspin_unlock_irqrestore(&hga_reg_lock, flags);\n}\n\nstatic void hga_gfx_mode(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hga_reg_lock, flags);\n\toutb_p(0x00, HGA_STATUS_PORT);\n\toutb_p(HGA_GFX_MODE_EN, HGA_GFX_PORT);\n\toutb_p(HGA_MODE_VIDEO_EN | HGA_MODE_GRAPHICS, HGA_MODE_PORT);\n\n\twrite_hga_b(0x35, 0x00);\t \n\twrite_hga_b(0x2d, 0x01);\t \n\twrite_hga_b(0x2e, 0x02);\t \n\twrite_hga_b(0x07, 0x03);\t \n\n\twrite_hga_b(0x5b, 0x04);\t \n\twrite_hga_b(0x02, 0x05);\t \n\twrite_hga_b(0x57, 0x06);\t \n\twrite_hga_b(0x57, 0x07);\t \n\n\twrite_hga_b(0x02, 0x08);\t \n\twrite_hga_b(0x03, 0x09);\t \n\twrite_hga_b(0x00, 0x0a);\t \n\twrite_hga_b(0x00, 0x0b);\t \n\n\twrite_hga_w(0x0000, 0x0c);\t \n\twrite_hga_w(0x0000, 0x0e);\t \n\n\thga_mode = HGA_GFX;\n\tspin_unlock_irqrestore(&hga_reg_lock, flags);\n}\n\nstatic void hga_show_logo(struct fb_info *info)\n{\n \n}\n\nstatic void hga_pan(unsigned int xoffset, unsigned int yoffset)\n{\n\tunsigned int base;\n\tunsigned long flags;\n\n\tbase = (yoffset / 8) * 90 + xoffset;\n\tspin_lock_irqsave(&hga_reg_lock, flags);\n\twrite_hga_w(base, 0x0c);\t \n\tspin_unlock_irqrestore(&hga_reg_lock, flags);\n\tDPRINTK(\"hga_pan: base:%d\\n\", base);\n}\n\nstatic void hga_blank(int blank_mode)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hga_reg_lock, flags);\n\tif (blank_mode) {\n\t\toutb_p(0x00, HGA_MODE_PORT);\t \n\t} else {\n\t\toutb_p(HGA_MODE_VIDEO_EN | HGA_MODE_GRAPHICS, HGA_MODE_PORT);\n\t}\n\tspin_unlock_irqrestore(&hga_reg_lock, flags);\n}\n\nstatic int hga_card_detect(void)\n{\n\tint count = 0;\n\tvoid __iomem *p, *q;\n\tunsigned short p_save, q_save;\n\n\thga_vram_len  = 0x08000;\n\n\thga_vram = ioremap(0xb0000, hga_vram_len);\n\tif (!hga_vram)\n\t\treturn -ENOMEM;\n\n\tif (request_region(0x3b0, 12, \"hgafb\"))\n\t\trelease_io_ports = 1;\n\tif (request_region(0x3bf, 1, \"hgafb\"))\n\t\trelease_io_port = 1;\n\n\t \n\n\tp = hga_vram;\n\tq = hga_vram + 0x01000;\n\n\tp_save = readw(p); q_save = readw(q);\n\n\twritew(0xaa55, p); if (readw(p) == 0xaa55) count++;\n\twritew(0x55aa, p); if (readw(p) == 0x55aa) count++;\n\twritew(p_save, p);\n\n\tif (count != 2)\n\t\tgoto error;\n\n\t \n\n\tif (!test_hga_b(0x66, 0x0f))\t     \n\t\tgoto error;\n\n\tif (!test_hga_b(0x99, 0x0f))      \n\t\tgoto error;\n\n\t \n\n\tp_save = q_save = inb_p(HGA_STATUS_PORT) & HGA_STATUS_VSYNC;\n\n\tfor (count=0; count < 50000 && p_save == q_save; count++) {\n\t\tq_save = inb(HGA_STATUS_PORT) & HGA_STATUS_VSYNC;\n\t\tudelay(2);\n\t}\n\n\tif (p_save == q_save)\n\t\tgoto error;\n\n\tswitch (inb_p(HGA_STATUS_PORT) & 0x70) {\n\t\tcase 0x10:\n\t\t\thga_type = TYPE_HERCPLUS;\n\t\t\thga_type_name = \"HerculesPlus\";\n\t\t\tbreak;\n\t\tcase 0x50:\n\t\t\thga_type = TYPE_HERCCOLOR;\n\t\t\thga_type_name = \"HerculesColor\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thga_type = TYPE_HERC;\n\t\t\thga_type_name = \"Hercules\";\n\t\t\tbreak;\n\t}\n\treturn 0;\nerror:\n\tif (release_io_ports)\n\t\trelease_region(0x3b0, 12);\n\tif (release_io_port)\n\t\trelease_region(0x3bf, 1);\n\n\tiounmap(hga_vram);\n\n\tpr_err(\"hgafb: HGA card not detected.\\n\");\n\n\treturn -EINVAL;\n}\n\n \n\nstatic int hgafb_open(struct fb_info *info, int init)\n{\n\thga_gfx_mode();\n\thga_clear_screen();\n\tif (!nologo) hga_show_logo(info);\n\treturn 0;\n}\n\n \n\nstatic int hgafb_release(struct fb_info *info, int init)\n{\n\thga_txt_mode();\n\thga_clear_screen();\n\treturn 0;\n}\n\n \n\nstatic int hgafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t   u_int transp, struct fb_info *info)\n{\n\tif (regno > 1)\n\t\treturn 1;\n\treturn 0;\n}\n\n \n\nstatic int hgafb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tif (var->vmode & FB_VMODE_YWRAP) {\n\t\tif (var->yoffset >= info->var.yres_virtual ||\n\t\t    var->xoffset)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (var->xoffset + info->var.xres > info->var.xres_virtual\n\t\t || var->yoffset + info->var.yres > info->var.yres_virtual\n\t\t || var->yoffset % 8)\n\t\t\treturn -EINVAL;\n\t}\n\n\thga_pan(var->xoffset, var->yoffset);\n\treturn 0;\n}\n\n \n\nstatic int hgafb_blank(int blank_mode, struct fb_info *info)\n{\n\thga_blank(blank_mode);\n\treturn 0;\n}\n\n \nstatic void hgafb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tu_int rows, y;\n\tu8 __iomem *dest;\n\n\ty = rect->dy;\n\n\tfor (rows = rect->height; rows--; y++) {\n\t\tdest = rowaddr(info, y) + (rect->dx >> 3);\n\t\tswitch (rect->rop) {\n\t\tcase ROP_COPY:\n\t\t\tmemset_io(dest, rect->color, (rect->width >> 3));\n\t\t\tbreak;\n\t\tcase ROP_XOR:\n\t\t\tfb_writeb(~(fb_readb(dest)), dest);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void hgafb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tu_int rows, y1, y2;\n\tu8 __iomem *src;\n\tu8 __iomem *dest;\n\n\tif (area->dy <= area->sy) {\n\t\ty1 = area->sy;\n\t\ty2 = area->dy;\n\n\t\tfor (rows = area->height; rows--; ) {\n\t\t\tsrc = rowaddr(info, y1) + (area->sx >> 3);\n\t\t\tdest = rowaddr(info, y2) + (area->dx >> 3);\n\t\t\tmemmove(dest, src, (area->width >> 3));\n\t\t\ty1++;\n\t\t\ty2++;\n\t\t}\n\t} else {\n\t\ty1 = area->sy + area->height - 1;\n\t\ty2 = area->dy + area->height - 1;\n\n\t\tfor (rows = area->height; rows--;) {\n\t\t\tsrc = rowaddr(info, y1) + (area->sx >> 3);\n\t\t\tdest = rowaddr(info, y2) + (area->dx >> 3);\n\t\t\tmemmove(dest, src, (area->width >> 3));\n\t\t\ty1--;\n\t\t\ty2--;\n\t\t}\n\t}\n}\n\nstatic void hgafb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tu8 __iomem *dest;\n\tu8 *cdat = (u8 *) image->data;\n\tu_int rows, y = image->dy;\n\tu_int x;\n\tu8 d;\n\n\tfor (rows = image->height; rows--; y++) {\n\t\tfor (x = 0; x < image->width; x+= 8) {\n\t\t\td = *cdat++;\n\t\t\tdest = rowaddr(info, y) + ((image->dx + x)>> 3);\n\t\t\tfb_writeb(d, dest);\n\t\t}\n\t}\n}\n\nstatic const struct fb_ops hgafb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= hgafb_open,\n\t.fb_release\t= hgafb_release,\n\t.fb_setcolreg\t= hgafb_setcolreg,\n\t.fb_pan_display\t= hgafb_pan_display,\n\t.fb_blank\t= hgafb_blank,\n\t.fb_fillrect\t= hgafb_fillrect,\n\t.fb_copyarea\t= hgafb_copyarea,\n\t.fb_imageblit\t= hgafb_imageblit,\n};\n\n \n\n \n\n\t \n\nstatic int hgafb_probe(struct platform_device *pdev)\n{\n\tstruct fb_info *info;\n\tint ret;\n\n\tret = hga_card_detect();\n\tif (ret)\n\t\treturn ret;\n\n\tprintk(KERN_INFO \"hgafb: %s with %ldK of memory detected.\\n\",\n\t\thga_type_name, hga_vram_len/1024);\n\n\tinfo = framebuffer_alloc(0, &pdev->dev);\n\tif (!info) {\n\t\tiounmap(hga_vram);\n\t\treturn -ENOMEM;\n\t}\n\n\thga_fix.smem_start = (unsigned long)hga_vram;\n\thga_fix.smem_len = hga_vram_len;\n\n\tinfo->flags = FBINFO_HWACCEL_YPAN;\n\tinfo->var = hga_default_var;\n\tinfo->fix = hga_fix;\n\tinfo->monspecs.hfmin = 0;\n\tinfo->monspecs.hfmax = 0;\n\tinfo->monspecs.vfmin = 10000;\n\tinfo->monspecs.vfmax = 10000;\n\tinfo->monspecs.dpms = 0;\n\tinfo->fbops = &hgafb_ops;\n\tinfo->screen_base = hga_vram;\n\n        if (register_framebuffer(info) < 0) {\n\t\tframebuffer_release(info);\n\t\tiounmap(hga_vram);\n\t\treturn -EINVAL;\n\t}\n\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\tplatform_set_drvdata(pdev, info);\n\treturn 0;\n}\n\nstatic void hgafb_remove(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\n\thga_txt_mode();\n\thga_clear_screen();\n\n\tif (info) {\n\t\tunregister_framebuffer(info);\n\t\tframebuffer_release(info);\n\t}\n\n\tiounmap(hga_vram);\n\n\tif (release_io_ports)\n\t\trelease_region(0x3b0, 12);\n\n\tif (release_io_port)\n\t\trelease_region(0x3bf, 1);\n}\n\nstatic struct platform_driver hgafb_driver = {\n\t.probe = hgafb_probe,\n\t.remove_new = hgafb_remove,\n\t.driver = {\n\t\t.name = \"hgafb\",\n\t},\n};\n\nstatic struct platform_device *hgafb_device;\n\nstatic int __init hgafb_init(void)\n{\n\tint ret;\n\n\tif (fb_get_options(\"hgafb\", NULL))\n\t\treturn -ENODEV;\n\n\tret = platform_driver_register(&hgafb_driver);\n\n\tif (!ret) {\n\t\thgafb_device = platform_device_register_simple(\"hgafb\", 0, NULL, 0);\n\n\t\tif (IS_ERR(hgafb_device)) {\n\t\t\tplatform_driver_unregister(&hgafb_driver);\n\t\t\tret = PTR_ERR(hgafb_device);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit hgafb_exit(void)\n{\n\tplatform_device_unregister(hgafb_device);\n\tplatform_driver_unregister(&hgafb_driver);\n}\n\n \n\nMODULE_AUTHOR(\"Ferenc Bakonyi (fero@drama.obuda.kando.hu)\");\nMODULE_DESCRIPTION(\"FBDev driver for Hercules Graphics Adaptor\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(nologo, bool, 0);\nMODULE_PARM_DESC(nologo, \"Disables startup logo if != 0 (default=0)\");\nmodule_init(hgafb_init);\nmodule_exit(hgafb_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}