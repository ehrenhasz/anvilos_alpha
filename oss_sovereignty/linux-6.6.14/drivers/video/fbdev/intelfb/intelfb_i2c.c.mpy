{
  "module_name": "intelfb_i2c.c",
  "hash_id": "d95967a48c1c2e3479b7411785f9a25cc5ee98c4141eb9d573572bcfe8f5f701",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/intelfb/intelfb_i2c.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/fb.h>\n\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n\n#include <asm/io.h>\n\n#include \"intelfb.h\"\n#include \"intelfbhw.h\"\n\n \n#define SCL_DIR_MASK\t\t0x0001\n#define SCL_DIR\t\t\t0x0002\n#define SCL_VAL_MASK\t\t0x0004\n#define SCL_VAL_OUT\t\t0x0008\n#define SCL_VAL_IN\t\t0x0010\n#define SDA_DIR_MASK\t\t0x0100\n#define SDA_DIR\t\t\t0x0200\n#define SDA_VAL_MASK\t\t0x0400\n#define SDA_VAL_OUT\t\t0x0800\n#define SDA_VAL_IN\t\t0x1000\n\nstatic void intelfb_gpio_setscl(void *data, int state)\n{\n\tstruct intelfb_i2c_chan *chan = data;\n\tstruct intelfb_info *dinfo = chan->dinfo;\n\tu32 val;\n\n\tOUTREG(chan->reg, (state ? SCL_VAL_OUT : 0) |\n\t       SCL_DIR | SCL_DIR_MASK | SCL_VAL_MASK);\n\tval = INREG(chan->reg);\n}\n\nstatic void intelfb_gpio_setsda(void *data, int state)\n{\n\tstruct intelfb_i2c_chan *chan = data;\n\tstruct intelfb_info *dinfo = chan->dinfo;\n\tu32 val;\n\n\tOUTREG(chan->reg, (state ? SDA_VAL_OUT : 0) |\n\t       SDA_DIR | SDA_DIR_MASK | SDA_VAL_MASK);\n\tval = INREG(chan->reg);\n}\n\nstatic int intelfb_gpio_getscl(void *data)\n{\n\tstruct intelfb_i2c_chan *chan = data;\n\tstruct intelfb_info *dinfo = chan->dinfo;\n\tu32 val;\n\n\tOUTREG(chan->reg, SCL_DIR_MASK);\n\tOUTREG(chan->reg, 0);\n\tval = INREG(chan->reg);\n\treturn ((val & SCL_VAL_IN) != 0);\n}\n\nstatic int intelfb_gpio_getsda(void *data)\n{\n\tstruct intelfb_i2c_chan *chan = data;\n\tstruct intelfb_info *dinfo = chan->dinfo;\n\tu32 val;\n\n\tOUTREG(chan->reg, SDA_DIR_MASK);\n\tOUTREG(chan->reg, 0);\n\tval = INREG(chan->reg);\n\treturn ((val & SDA_VAL_IN) != 0);\n}\n\nstatic int intelfb_setup_i2c_bus(struct intelfb_info *dinfo,\n\t\t\t\t struct intelfb_i2c_chan *chan,\n\t\t\t\t const u32 reg, const char *name,\n\t\t\t\t int class)\n{\n\tint rc;\n\n\tchan->dinfo\t\t\t= dinfo;\n\tchan->reg\t\t\t= reg;\n\tsnprintf(chan->adapter.name, sizeof(chan->adapter.name),\n\t\t \"intelfb %s\", name);\n\tchan->adapter.class\t\t= class;\n\tchan->adapter.owner\t\t= THIS_MODULE;\n\tchan->adapter.algo_data\t\t= &chan->algo;\n\tchan->adapter.dev.parent\t= &chan->dinfo->pdev->dev;\n\tchan->algo.setsda\t\t= intelfb_gpio_setsda;\n\tchan->algo.setscl\t\t= intelfb_gpio_setscl;\n\tchan->algo.getsda\t\t= intelfb_gpio_getsda;\n\tchan->algo.getscl\t\t= intelfb_gpio_getscl;\n\tchan->algo.udelay\t\t= 40;\n\tchan->algo.timeout\t\t= 20;\n\tchan->algo.data\t\t\t= chan;\n\n\ti2c_set_adapdata(&chan->adapter, chan);\n\n\t \n\tintelfb_gpio_setsda(chan, 1);\n\tintelfb_gpio_setscl(chan, 1);\n\tudelay(20);\n\n\trc = i2c_bit_add_bus(&chan->adapter);\n\tif (rc == 0)\n\t\tDBG_MSG(\"I2C bus %s registered.\\n\", name);\n\telse\n\t\tWRN_MSG(\"Failed to register I2C bus %s.\\n\", name);\n\treturn rc;\n}\n\nvoid intelfb_create_i2c_busses(struct intelfb_info *dinfo)\n{\n\tint i = 0;\n\n\t \n\tdinfo->num_outputs = 1;\n\tdinfo->output[i].type = INTELFB_OUTPUT_ANALOG;\n\n\t \n\tintelfb_setup_i2c_bus(dinfo, &dinfo->output[i].ddc_bus, GPIOA,\n\t\t\t      \"CRTDDC_A\", I2C_CLASS_DDC);\n\ti++;\n\n\t \n\tswitch(dinfo->chipset) {\n\tcase INTEL_830M:\n\tcase INTEL_845G:\n\tcase INTEL_854:\n\tcase INTEL_855GM:\n\tcase INTEL_865G:\n\t\tdinfo->output[i].type = INTELFB_OUTPUT_DVO;\n\t\tintelfb_setup_i2c_bus(dinfo, &dinfo->output[i].ddc_bus,\n\t\t\t\t      GPIOD, \"DVODDC_D\", I2C_CLASS_DDC);\n\t\tintelfb_setup_i2c_bus(dinfo, &dinfo->output[i].i2c_bus,\n\t\t\t\t      GPIOE, \"DVOI2C_E\", 0);\n\t\ti++;\n\t\tbreak;\n\tcase INTEL_915G:\n\tcase INTEL_915GM:\n\t\t \n\tcase INTEL_945G:\n\tcase INTEL_945GM:\n\tcase INTEL_945GME:\n\tcase INTEL_965G:\n\tcase INTEL_965GM:\n\t\t \n\t\tdinfo->output[i].type = INTELFB_OUTPUT_SDVO;\n\t\tintelfb_setup_i2c_bus(dinfo, &dinfo->output[i].i2c_bus,\n\t\t\t\t      GPIOE, \"SDVOCTRL_E\", 0);\n\t\t \n\t\t \n\t\ti++;\n\n\t\t \n\t\tdinfo->output[i].type = INTELFB_OUTPUT_SDVO;\n\t\tdinfo->output[i].i2c_bus = dinfo->output[i - 1].i2c_bus;\n\t\t \n\t\t \n\t\ti++;\n\t\tbreak;\n\t}\n\tdinfo->num_outputs = i;\n}\n\nvoid intelfb_delete_i2c_busses(struct intelfb_info *dinfo)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_OUTPUTS; i++) {\n\t\tif (dinfo->output[i].i2c_bus.dinfo) {\n\t\t\ti2c_del_adapter(&dinfo->output[i].i2c_bus.adapter);\n\t\t\tdinfo->output[i].i2c_bus.dinfo = NULL;\n\t\t}\n\t\tif (dinfo->output[i].ddc_bus.dinfo) {\n\t\t\ti2c_del_adapter(&dinfo->output[i].ddc_bus.adapter);\n\t\t\tdinfo->output[i].ddc_bus.dinfo = NULL;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}