{
  "module_name": "intelfbdrv.c",
  "hash_id": "2695c0b9ea490c72da4a55c44ff375110215009935301abf61551c4ff6d83468",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/intelfb/intelfbdrv.c",
  "human_readable_source": " \n\n \n\n \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/screen_info.h>\n\n#include <asm/io.h>\n\n#include \"intelfb.h\"\n#include \"intelfbhw.h\"\n#include \"../edid.h\"\n\nstatic void get_initial_mode(struct intelfb_info *dinfo);\nstatic void update_dinfo(struct intelfb_info *dinfo,\n\t\t\t struct fb_var_screeninfo *var);\nstatic int intelfb_open(struct fb_info *info, int user);\nstatic int intelfb_release(struct fb_info *info, int user);\nstatic int intelfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info);\nstatic int intelfb_set_par(struct fb_info *info);\nstatic int intelfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t     unsigned blue, unsigned transp,\n\t\t\t     struct fb_info *info);\n\nstatic int intelfb_blank(int blank, struct fb_info *info);\nstatic int intelfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t       struct fb_info *info);\n\nstatic void intelfb_fillrect(struct fb_info *info,\n\t\t\t     const struct fb_fillrect *rect);\nstatic void intelfb_copyarea(struct fb_info *info,\n\t\t\t     const struct fb_copyarea *region);\nstatic void intelfb_imageblit(struct fb_info *info,\n\t\t\t      const struct fb_image *image);\nstatic int intelfb_cursor(struct fb_info *info,\n\t\t\t   struct fb_cursor *cursor);\n\nstatic int intelfb_sync(struct fb_info *info);\n\nstatic int intelfb_ioctl(struct fb_info *info,\n\t\t\t unsigned int cmd, unsigned long arg);\n\nstatic int intelfb_pci_register(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *ent);\nstatic void intelfb_pci_unregister(struct pci_dev *pdev);\nstatic int intelfb_set_fbinfo(struct intelfb_info *dinfo);\n\n \n#if DETECT_VGA_CLASS_ONLY\n#define INTELFB_CLASS_MASK ~0 << 8\n#else\n#define INTELFB_CLASS_MASK 0\n#endif\n\nstatic const struct pci_device_id intelfb_pci_table[] = {\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_830M, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8, INTELFB_CLASS_MASK, INTEL_830M },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_845G, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8, INTELFB_CLASS_MASK, INTEL_845G },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_85XGM, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8, INTELFB_CLASS_MASK, INTEL_85XGM },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_865G, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8, INTELFB_CLASS_MASK, INTEL_865G },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_854, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8, INTELFB_CLASS_MASK, INTEL_854 },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_915G, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8, INTELFB_CLASS_MASK, INTEL_915G },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_915GM, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8, INTELFB_CLASS_MASK, INTEL_915GM },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_945G, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8, INTELFB_CLASS_MASK, INTEL_945G },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_945GM, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8, INTELFB_CLASS_MASK, INTEL_945GM },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_945GME, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8, INTELFB_CLASS_MASK, INTEL_945GME },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_965G, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8, INTELFB_CLASS_MASK, INTEL_965G },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_965GM, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA << 8, INTELFB_CLASS_MASK, INTEL_965GM },\n\t{ 0, }\n};\n\n \nstatic int num_registered = 0;\n\n \nstatic const struct fb_ops intel_fb_ops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.fb_open =              intelfb_open,\n\t.fb_release =           intelfb_release,\n\t.fb_check_var =         intelfb_check_var,\n\t.fb_set_par =           intelfb_set_par,\n\t.fb_setcolreg =\t\tintelfb_setcolreg,\n\t.fb_blank =\t\tintelfb_blank,\n\t.fb_pan_display =       intelfb_pan_display,\n\t.fb_fillrect  =         intelfb_fillrect,\n\t.fb_copyarea  =         intelfb_copyarea,\n\t.fb_imageblit =         intelfb_imageblit,\n\t.fb_cursor =            intelfb_cursor,\n\t.fb_sync =              intelfb_sync,\n\t.fb_ioctl =\t\tintelfb_ioctl\n};\n\n \nstatic struct pci_driver intelfb_driver = {\n\t.name =\t\t\"intelfb\",\n\t.id_table =\tintelfb_pci_table,\n\t.probe =\tintelfb_pci_register,\n\t.remove =\tintelfb_pci_unregister,\n};\n\n \nMODULE_AUTHOR(\"David Dawes <dawes@tungstengraphics.com>, \"\n\t      \"Sylvain Meyer <sylvain.meyer@worldonline.fr>\");\nMODULE_DESCRIPTION(\"Framebuffer driver for Intel(R) \" SUPPORTED_CHIPSETS\n\t\t   \" chipsets\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DEVICE_TABLE(pci, intelfb_pci_table);\n\nstatic bool accel       = 1;\nstatic int vram         = 4;\nstatic bool hwcursor    = 0;\nstatic bool mtrr        = 1;\nstatic bool fixed       = 0;\nstatic bool noinit      = 0;\nstatic bool noregister  = 0;\nstatic bool probeonly   = 0;\nstatic bool idonly      = 0;\nstatic int bailearly    = 0;\nstatic int voffset\t= 48;\nstatic char *mode       = NULL;\n\nmodule_param(accel, bool, S_IRUGO);\nMODULE_PARM_DESC(accel, \"Enable hardware acceleration\");\nmodule_param(vram, int, S_IRUGO);\nMODULE_PARM_DESC(vram, \"System RAM to allocate to framebuffer in MiB\");\nmodule_param(voffset, int, S_IRUGO);\nMODULE_PARM_DESC(voffset, \"Offset of framebuffer in MiB\");\nmodule_param(hwcursor, bool, S_IRUGO);\nMODULE_PARM_DESC(hwcursor, \"Enable HW cursor\");\nmodule_param(mtrr, bool, S_IRUGO);\nMODULE_PARM_DESC(mtrr, \"Enable MTRR support\");\nmodule_param(fixed, bool, S_IRUGO);\nMODULE_PARM_DESC(fixed, \"Disable mode switching\");\nmodule_param(noinit, bool, 0);\nMODULE_PARM_DESC(noinit, \"Don't initialise graphics mode when loading\");\nmodule_param(noregister, bool, 0);\nMODULE_PARM_DESC(noregister, \"Don't register, just probe and exit (debug)\");\nmodule_param(probeonly, bool, 0);\nMODULE_PARM_DESC(probeonly, \"Do a minimal probe (debug)\");\nmodule_param(idonly, bool, 0);\nMODULE_PARM_DESC(idonly, \"Just identify without doing anything else (debug)\");\nmodule_param(bailearly, int, 0);\nMODULE_PARM_DESC(bailearly, \"Bail out early, depending on value (debug)\");\nmodule_param(mode, charp, S_IRUGO);\nMODULE_PARM_DESC(mode,\n\t\t \"Initial video mode \\\"<xres>x<yres>[-<depth>][@<refresh>]\\\"\");\n\n#ifndef MODULE\n#define OPT_EQUAL(opt, name) (!strncmp(opt, name, strlen(name)))\n#define OPT_INTVAL(opt, name) simple_strtoul(opt + strlen(name) + 1, NULL, 0)\n#define OPT_STRVAL(opt, name) (opt + strlen(name))\n\nstatic __inline__ char * get_opt_string(const char *this_opt, const char *name)\n{\n\tconst char *p;\n\tint i;\n\tchar *ret;\n\n\tp = OPT_STRVAL(this_opt, name);\n\ti = 0;\n\twhile (p[i] && p[i] != ' ' && p[i] != ',')\n\t\ti++;\n\tret = kmalloc(i + 1, GFP_KERNEL);\n\tif (ret) {\n\t\tstrncpy(ret, p, i);\n\t\tret[i] = '\\0';\n\t}\n\treturn ret;\n}\n\nstatic __inline__ int get_opt_int(const char *this_opt, const char *name,\n\t\t\t\t  int *ret)\n{\n\tif (!ret)\n\t\treturn 0;\n\n\tif (!OPT_EQUAL(this_opt, name))\n\t\treturn 0;\n\n\t*ret = OPT_INTVAL(this_opt, name);\n\treturn 1;\n}\n\nstatic __inline__ int get_opt_bool(const char *this_opt, const char *name,\n\t\t\t\t   bool *ret)\n{\n\tif (!ret)\n\t\treturn 0;\n\n\tif (OPT_EQUAL(this_opt, name)) {\n\t\tif (this_opt[strlen(name)] == '=')\n\t\t\t*ret = simple_strtoul(this_opt + strlen(name) + 1,\n\t\t\t\t\t      NULL, 0);\n\t\telse\n\t\t\t*ret = 1;\n\t} else {\n\t\tif (OPT_EQUAL(this_opt, \"no\") && OPT_EQUAL(this_opt + 2, name))\n\t\t\t*ret = 0;\n\t\telse\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int __init intelfb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tDBG_MSG(\"intelfb_setup\\n\");\n\n\tif (!options || !*options) {\n\t\tDBG_MSG(\"no options\\n\");\n\t\treturn 0;\n\t} else\n\t\tDBG_MSG(\"options: %s\\n\", options);\n\n\t \n\n\twhile ((this_opt = strsep(&options, \",\"))) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\t\tif (get_opt_bool(this_opt, \"accel\", &accel))\n\t\t\t;\n\t\telse if (get_opt_int(this_opt, \"vram\", &vram))\n\t\t\t;\n\t\telse if (get_opt_bool(this_opt, \"hwcursor\", &hwcursor))\n\t\t\t;\n\t\telse if (get_opt_bool(this_opt, \"mtrr\", &mtrr))\n\t\t\t;\n\t\telse if (get_opt_bool(this_opt, \"fixed\", &fixed))\n\t\t\t;\n\t\telse if (get_opt_bool(this_opt, \"init\", &noinit))\n\t\t\tnoinit = !noinit;\n\t\telse if (OPT_EQUAL(this_opt, \"mode=\"))\n\t\t\tmode = get_opt_string(this_opt, \"mode=\");\n\t\telse\n\t\t\tmode = this_opt;\n\t}\n\n\treturn 0;\n}\n\n#endif\n\nstatic int __init intelfb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tDBG_MSG(\"intelfb_init\\n\");\n\n\tINF_MSG(\"Framebuffer driver for \"\n\t\t\"Intel(R) \" SUPPORTED_CHIPSETS \" chipsets\\n\");\n\tINF_MSG(\"Version \" INTELFB_VERSION \"\\n\");\n\n\tif (idonly)\n\t\treturn -ENODEV;\n\n\tif (fb_modesetting_disabled(\"intelfb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"intelfb\", &option))\n\t\treturn -ENODEV;\n\tintelfb_setup(option);\n#endif\n\n\treturn pci_register_driver(&intelfb_driver);\n}\n\nstatic void __exit intelfb_exit(void)\n{\n\tDBG_MSG(\"intelfb_exit\\n\");\n\tpci_unregister_driver(&intelfb_driver);\n}\n\nmodule_init(intelfb_init);\nmodule_exit(intelfb_exit);\n\n \n\nstatic void cleanup(struct intelfb_info *dinfo)\n{\n\tDBG_MSG(\"cleanup\\n\");\n\n\tif (!dinfo)\n\t\treturn;\n\n\tintelfbhw_disable_irq(dinfo);\n\n\tfb_dealloc_cmap(&dinfo->info->cmap);\n\tkfree(dinfo->info->pixmap.addr);\n\n\tif (dinfo->registered)\n\t\tunregister_framebuffer(dinfo->info);\n\n\tarch_phys_wc_del(dinfo->wc_cookie);\n\n\tif (dinfo->fbmem_gart && dinfo->gtt_fb_mem) {\n\t\tagp_unbind_memory(dinfo->gtt_fb_mem);\n\t\tagp_free_memory(dinfo->gtt_fb_mem);\n\t}\n\tif (dinfo->gtt_cursor_mem) {\n\t\tagp_unbind_memory(dinfo->gtt_cursor_mem);\n\t\tagp_free_memory(dinfo->gtt_cursor_mem);\n\t}\n\tif (dinfo->gtt_ring_mem) {\n\t\tagp_unbind_memory(dinfo->gtt_ring_mem);\n\t\tagp_free_memory(dinfo->gtt_ring_mem);\n\t}\n\n#ifdef CONFIG_FB_INTEL_I2C\n\t \n\tintelfb_delete_i2c_busses(dinfo);\n#endif\n\n\tif (dinfo->mmio_base)\n\t\tiounmap((void __iomem *)dinfo->mmio_base);\n\tif (dinfo->aperture.virtual)\n\t\tiounmap((void __iomem *)dinfo->aperture.virtual);\n\n\tif (dinfo->flag & INTELFB_MMIO_ACQUIRED)\n\t\trelease_mem_region(dinfo->mmio_base_phys, INTEL_REG_SIZE);\n\tif (dinfo->flag & INTELFB_FB_ACQUIRED)\n\t\trelease_mem_region(dinfo->aperture.physical,\n\t\t\t\t   dinfo->aperture.size);\n\tframebuffer_release(dinfo->info);\n}\n\n#define bailout(dinfo) do {\t\t\t\t\t\t\\\n\tDBG_MSG(\"bailout\\n\");\t\t\t\t\t\t\\\n\tcleanup(dinfo);\t\t\t\t\t\t\t\\\n\tINF_MSG(\"Not going to register framebuffer, exiting...\\n\");\t\\\n\treturn -ENODEV;\t\t\t\t\t\t\t\\\n} while (0)\n\n\nstatic int intelfb_pci_register(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *ent)\n{\n\tstruct fb_info *info;\n\tstruct intelfb_info *dinfo;\n\tint i, err, dvo;\n\tint aperture_size, stolen_size = 0;\n\tstruct agp_kern_info gtt_info;\n\tint agp_memtype;\n\tconst char *s;\n\tstruct agp_bridge_data *bridge;\n\tint aperture_bar = 0;\n\tint mmio_bar = 1;\n\tint offset;\n\n\tDBG_MSG(\"intelfb_pci_register\\n\");\n\n\terr = aperture_remove_conflicting_pci_devices(pdev, \"intelfb\");\n\tif (err)\n\t\treturn err;\n\n\tnum_registered++;\n\tif (num_registered != 1) {\n\t\tERR_MSG(\"Attempted to register %d devices \"\n\t\t\t\"(should be only 1).\\n\", num_registered);\n\t\treturn -ENODEV;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct intelfb_info), &pdev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 1) < 0) {\n\t\tERR_MSG(\"Could not allocate cmap for intelfb_info.\\n\");\n\t\tgoto err_out_cmap;\n\t}\n\n\tdinfo = info->par;\n\tdinfo->info  = info;\n\tdinfo->fbops = &intel_fb_ops;\n\tdinfo->pdev  = pdev;\n\n\t \n\tinfo->pixmap.addr = kzalloc(64 * 1024, GFP_KERNEL);\n\tif (info->pixmap.addr == NULL) {\n\t\tERR_MSG(\"Cannot reserve pixmap memory.\\n\");\n\t\tgoto err_out_pixmap;\n\t}\n\n\t \n\tdinfo->fixed_mode = fixed;\n\n\t \n\tif ((err = pci_enable_device(pdev))) {\n\t\tERR_MSG(\"Cannot enable device.\\n\");\n\t\tcleanup(dinfo);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif ((ent->device == PCI_DEVICE_ID_INTEL_915G) ||\n\t    (ent->device == PCI_DEVICE_ID_INTEL_915GM) ||\n\t    (ent->device == PCI_DEVICE_ID_INTEL_945G)  ||\n\t    (ent->device == PCI_DEVICE_ID_INTEL_945GM) ||\n\t    (ent->device == PCI_DEVICE_ID_INTEL_945GME) ||\n\t    (ent->device == PCI_DEVICE_ID_INTEL_965G) ||\n\t    (ent->device == PCI_DEVICE_ID_INTEL_965GM)) {\n\n\t\taperture_bar = 2;\n\t\tmmio_bar = 0;\n\t}\n\tdinfo->aperture.physical = pci_resource_start(pdev, aperture_bar);\n\tdinfo->aperture.size     = pci_resource_len(pdev, aperture_bar);\n\tdinfo->mmio_base_phys    = pci_resource_start(pdev, mmio_bar);\n\tDBG_MSG(\"fb aperture: 0x%llx/0x%llx, MMIO region: 0x%llx/0x%llx\\n\",\n\t\t(unsigned long long)pci_resource_start(pdev, aperture_bar),\n\t\t(unsigned long long)pci_resource_len(pdev, aperture_bar),\n\t\t(unsigned long long)pci_resource_start(pdev, mmio_bar),\n\t\t(unsigned long long)pci_resource_len(pdev, mmio_bar));\n\n\t \n\tif (!request_mem_region(dinfo->aperture.physical, dinfo->aperture.size,\n\t\t\t\tINTELFB_MODULE_NAME)) {\n\t\tERR_MSG(\"Cannot reserve FB region.\\n\");\n\t\tcleanup(dinfo);\n\t\treturn -ENODEV;\n\t}\n\n\tdinfo->flag |= INTELFB_FB_ACQUIRED;\n\n\tif (!request_mem_region(dinfo->mmio_base_phys,\n\t\t\t\tINTEL_REG_SIZE,\n\t\t\t\tINTELFB_MODULE_NAME)) {\n\t\tERR_MSG(\"Cannot reserve MMIO region.\\n\");\n\t\tcleanup(dinfo);\n\t\treturn -ENODEV;\n\t}\n\n\tdinfo->flag |= INTELFB_MMIO_ACQUIRED;\n\n\t \n\tdinfo->pci_chipset = pdev->device;\n\n\tif (intelfbhw_get_chipset(pdev, dinfo)) {\n\t\tcleanup(dinfo);\n\t\treturn -ENODEV;\n\t}\n\n\tif (intelfbhw_get_memory(pdev, &aperture_size, &stolen_size)) {\n\t\tcleanup(dinfo);\n\t\treturn -ENODEV;\n\t}\n\n\tINF_MSG(\"%02x:%02x.%d: %s, aperture size %dMB, \"\n\t\t\"stolen memory %dkB\\n\",\n\t\tpdev->bus->number, PCI_SLOT(pdev->devfn),\n\t\tPCI_FUNC(pdev->devfn), dinfo->name,\n\t\tBtoMB(aperture_size), BtoKB(stolen_size));\n\n\t \n\tdinfo->accel    = accel;\n\tdinfo->hwcursor = hwcursor;\n\n\tif (NOACCEL_CHIPSET(dinfo) && dinfo->accel == 1) {\n\t\tINF_MSG(\"Acceleration is not supported for the %s chipset.\\n\",\n\t\t\tdinfo->name);\n\t\tdinfo->accel = 0;\n\t}\n\n\t \n\tif (ROUND_UP_TO_PAGE(stolen_size) >= MB(vram)) {\n\t\tdinfo->fb.size = ROUND_UP_TO_PAGE(stolen_size);\n\t\tdinfo->fbmem_gart = 0;\n\t} else {\n\t\tdinfo->fb.size =  MB(vram);\n\t\tdinfo->fbmem_gart = 1;\n\t}\n\n\t \n\tif (dinfo->accel) {\n\t\tdinfo->ring.size = RINGBUFFER_SIZE;\n\t\tdinfo->ring_tail_mask = dinfo->ring.size - 1;\n\t}\n\tif (dinfo->hwcursor)\n\t\tdinfo->cursor.size = HW_CURSOR_SIZE;\n\n\t \n\tif (!(bridge = agp_backend_acquire(pdev))) {\n\t\tERR_MSG(\"cannot acquire agp\\n\");\n\t\tcleanup(dinfo);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (agp_copy_info(bridge, &gtt_info)) {\n\t\tERR_MSG(\"cannot get agp info\\n\");\n\t\tagp_backend_release(bridge);\n\t\tcleanup(dinfo);\n\t\treturn -ENODEV;\n\t}\n\n\tif (MB(voffset) < stolen_size)\n\t\toffset = (stolen_size >> 12);\n\telse\n\t\toffset = ROUND_UP_TO_PAGE(MB(voffset))/GTT_PAGE_SIZE;\n\n\t \n\tif (dinfo->accel)\n\t\tdinfo->ring.offset = offset + gtt_info.current_memory;\n\tif (dinfo->hwcursor)\n\t\tdinfo->cursor.offset = offset +\n\t\t\t+ gtt_info.current_memory + (dinfo->ring.size >> 12);\n\tif (dinfo->fbmem_gart)\n\t\tdinfo->fb.offset = offset +\n\t\t\t+ gtt_info.current_memory + (dinfo->ring.size >> 12)\n\t\t\t+ (dinfo->cursor.size >> 12);\n\n\t \n\t \n\t \n\tdinfo->aperture.virtual = (u8 __iomem *)ioremap_wc\n\t\t(dinfo->aperture.physical, ((offset + dinfo->fb.offset) << 12)\n\t\t + dinfo->fb.size);\n\tif (!dinfo->aperture.virtual) {\n\t\tERR_MSG(\"Cannot remap FB region.\\n\");\n\t\tagp_backend_release(bridge);\n\t\tcleanup(dinfo);\n\t\treturn -ENODEV;\n\t}\n\n\tdinfo->mmio_base =\n\t\t(u8 __iomem *)ioremap(dinfo->mmio_base_phys,\n\t\t\t\t\t      INTEL_REG_SIZE);\n\tif (!dinfo->mmio_base) {\n\t\tERR_MSG(\"Cannot remap MMIO region.\\n\");\n\t\tagp_backend_release(bridge);\n\t\tcleanup(dinfo);\n\t\treturn -ENODEV;\n\t}\n\n\tif (dinfo->accel) {\n\t\tif (!(dinfo->gtt_ring_mem =\n\t\t      agp_allocate_memory(bridge, dinfo->ring.size >> 12,\n\t\t\t\t\t  AGP_NORMAL_MEMORY))) {\n\t\t\tERR_MSG(\"cannot allocate ring buffer memory\\n\");\n\t\t\tagp_backend_release(bridge);\n\t\t\tcleanup(dinfo);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (agp_bind_memory(dinfo->gtt_ring_mem,\n\t\t\t\t    dinfo->ring.offset)) {\n\t\t\tERR_MSG(\"cannot bind ring buffer memory\\n\");\n\t\t\tagp_backend_release(bridge);\n\t\t\tcleanup(dinfo);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tdinfo->ring.physical = dinfo->aperture.physical\n\t\t\t+ (dinfo->ring.offset << 12);\n\t\tdinfo->ring.virtual  = dinfo->aperture.virtual\n\t\t\t+ (dinfo->ring.offset << 12);\n\t\tdinfo->ring_head = 0;\n\t}\n\tif (dinfo->hwcursor) {\n\t\tagp_memtype = dinfo->mobile ? AGP_PHYSICAL_MEMORY\n\t\t\t: AGP_NORMAL_MEMORY;\n\t\tif (!(dinfo->gtt_cursor_mem =\n\t\t      agp_allocate_memory(bridge, dinfo->cursor.size >> 12,\n\t\t\t\t\t  agp_memtype))) {\n\t\t\tERR_MSG(\"cannot allocate cursor memory\\n\");\n\t\t\tagp_backend_release(bridge);\n\t\t\tcleanup(dinfo);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (agp_bind_memory(dinfo->gtt_cursor_mem,\n\t\t\t\t    dinfo->cursor.offset)) {\n\t\t\tERR_MSG(\"cannot bind cursor memory\\n\");\n\t\t\tagp_backend_release(bridge);\n\t\t\tcleanup(dinfo);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (dinfo->mobile)\n\t\t\tdinfo->cursor.physical\n\t\t\t\t= dinfo->gtt_cursor_mem->physical;\n\t\telse\n\t\t\tdinfo->cursor.physical = dinfo->aperture.physical\n\t\t\t\t+ (dinfo->cursor.offset << 12);\n\t\tdinfo->cursor.virtual = dinfo->aperture.virtual\n\t\t\t+ (dinfo->cursor.offset << 12);\n\t}\n\tif (dinfo->fbmem_gart) {\n\t\tif (!(dinfo->gtt_fb_mem =\n\t\t      agp_allocate_memory(bridge, dinfo->fb.size >> 12,\n\t\t\t\t\t  AGP_NORMAL_MEMORY))) {\n\t\t\tWRN_MSG(\"cannot allocate framebuffer memory - use \"\n\t\t\t\t\"the stolen one\\n\");\n\t\t\tdinfo->fbmem_gart = 0;\n\t\t}\n\t\tif (agp_bind_memory(dinfo->gtt_fb_mem,\n\t\t\t\t    dinfo->fb.offset)) {\n\t\t\tWRN_MSG(\"cannot bind framebuffer memory - use \"\n\t\t\t\t\"the stolen one\\n\");\n\t\t\tdinfo->fbmem_gart = 0;\n\t\t}\n\t}\n\n\t \n\tif (!dinfo->fbmem_gart)\n\t\tdinfo->fb.offset = 0;    \n\tdinfo->fb.physical = dinfo->aperture.physical\n\t\t+ (dinfo->fb.offset << 12);\n\tdinfo->fb.virtual = dinfo->aperture.virtual + (dinfo->fb.offset << 12);\n\tdinfo->fb_start = dinfo->fb.offset << 12;\n\n\t \n\tagp_backend_release(bridge);\n\n\tif (mtrr)\n\t\tdinfo->wc_cookie = arch_phys_wc_add(dinfo->aperture.physical,\n\t\t\t\t\t\t    dinfo->aperture.size);\n\n\tDBG_MSG(\"fb: 0x%x(+ 0x%x)/0x%x (0x%p)\\n\",\n\t\tdinfo->fb.physical, dinfo->fb.offset, dinfo->fb.size,\n\t\tdinfo->fb.virtual);\n\tDBG_MSG(\"MMIO: 0x%x/0x%x (0x%p)\\n\",\n\t\tdinfo->mmio_base_phys, INTEL_REG_SIZE,\n\t\tdinfo->mmio_base);\n\tDBG_MSG(\"ring buffer: 0x%x/0x%x (0x%p)\\n\",\n\t\tdinfo->ring.physical, dinfo->ring.size,\n\t\tdinfo->ring.virtual);\n\tDBG_MSG(\"HW cursor: 0x%x/0x%x (0x%p) (offset 0x%x) (phys 0x%x)\\n\",\n\t\tdinfo->cursor.physical, dinfo->cursor.size,\n\t\tdinfo->cursor.virtual, dinfo->cursor.offset,\n\t\tdinfo->cursor.physical);\n\n\tDBG_MSG(\"options: vram = %d, accel = %d, hwcursor = %d, fixed = %d, \"\n\t\t\"noinit = %d\\n\", vram, accel, hwcursor, fixed, noinit);\n\tDBG_MSG(\"options: mode = \\\"%s\\\"\\n\", mode ? mode : \"\");\n\n\tif (probeonly)\n\t\tbailout(dinfo);\n\n\t \n\tdvo = intelfbhw_check_non_crt(dinfo);\n\tif (dvo) {\n\t\tdinfo->fixed_mode = 1;\n\t\tWRN_MSG(\"Non-CRT device is enabled ( \");\n\t\ti = 0;\n\t\twhile (dvo) {\n\t\t\tif (dvo & 1) {\n\t\t\t\ts = intelfbhw_dvo_to_string(1 << i);\n\t\t\t\tif (s)\n\t\t\t\t\tprintk(\"%s \", s);\n\t\t\t}\n\t\t\tdvo >>= 1;\n\t\t\t++i;\n\t\t}\n\t\tprintk(\").  Disabling mode switching.\\n\");\n\t}\n\n\tif (bailearly == 1)\n\t\tbailout(dinfo);\n\n\tif (FIXED_MODE(dinfo) &&\n\t    screen_info.orig_video_isVGA != VIDEO_TYPE_VLFB) {\n\t\tERR_MSG(\"Video mode must be programmed at boot time.\\n\");\n\t\tcleanup(dinfo);\n\t\treturn -ENODEV;\n\t}\n\n\tif (bailearly == 2)\n\t\tbailout(dinfo);\n\n\t \n\t \n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB)\n\t\tget_initial_mode(dinfo);\n\n\tif (bailearly == 3)\n\t\tbailout(dinfo);\n\n\tif (FIXED_MODE(dinfo))\t \n\t\tupdate_dinfo(dinfo, &dinfo->initial_var);\n\n\tif (bailearly == 4)\n\t\tbailout(dinfo);\n\n\n\tif (intelfb_set_fbinfo(dinfo)) {\n\t\tcleanup(dinfo);\n\t\treturn -ENODEV;\n\t}\n\n\tif (bailearly == 5)\n\t\tbailout(dinfo);\n\n#ifdef CONFIG_FB_INTEL_I2C\n\t \n\tintelfb_create_i2c_busses(dinfo);\n#endif\n\n\tif (bailearly == 6)\n\t\tbailout(dinfo);\n\n\tpci_set_drvdata(pdev, dinfo);\n\n\t \n\ti = intelfbhw_read_hw_state(dinfo, &dinfo->save_state,\n\t\t\t\t    bailearly > 6 ? bailearly - 6 : 0);\n\tif (i != 0) {\n\t\tDBG_MSG(\"intelfbhw_read_hw_state returned %d\\n\", i);\n\t\tbailout(dinfo);\n\t}\n\n\tintelfbhw_print_hw_state(dinfo, &dinfo->save_state);\n\n\tif (bailearly == 18)\n\t\tbailout(dinfo);\n\n\t \n\tdinfo->pipe = intelfbhw_active_pipe(&dinfo->save_state);\n\n\t \n\tif (dinfo->hwcursor) {\n\t\tintelfbhw_cursor_init(dinfo);\n\t\tintelfbhw_cursor_reset(dinfo);\n\t}\n\n\tif (bailearly == 19)\n\t\tbailout(dinfo);\n\n\t \n\tif (dinfo->accel)\n\t\tintelfbhw_2d_start(dinfo);\n\n\tif (bailearly == 20)\n\t\tbailout(dinfo);\n\n\tif (noregister)\n\t\tbailout(dinfo);\n\n\tif (register_framebuffer(dinfo->info) < 0) {\n\t\tERR_MSG(\"Cannot register framebuffer.\\n\");\n\t\tcleanup(dinfo);\n\t\treturn -ENODEV;\n\t}\n\n\tdinfo->registered = 1;\n\tdinfo->open = 0;\n\n\tinit_waitqueue_head(&dinfo->vsync.wait);\n\tspin_lock_init(&dinfo->int_lock);\n\tdinfo->irq_flags = 0;\n\tdinfo->vsync.pan_display = 0;\n\tdinfo->vsync.pan_offset = 0;\n\n\treturn 0;\n\nerr_out_pixmap:\n\tfb_dealloc_cmap(&info->cmap);\nerr_out_cmap:\n\tframebuffer_release(info);\n\treturn -ENODEV;\n}\n\nstatic void intelfb_pci_unregister(struct pci_dev *pdev)\n{\n\tstruct intelfb_info *dinfo = pci_get_drvdata(pdev);\n\n\tDBG_MSG(\"intelfb_pci_unregister\\n\");\n\n\tif (!dinfo)\n\t\treturn;\n\n\tcleanup(dinfo);\n}\n\n \n\n__inline__ int intelfb_var_to_depth(const struct fb_var_screeninfo *var)\n{\n\tDBG_MSG(\"intelfb_var_to_depth: bpp: %d, green.length is %d\\n\",\n\t\tvar->bits_per_pixel, var->green.length);\n\n\tswitch (var->bits_per_pixel) {\n\tcase 16:\n\t\treturn (var->green.length == 6) ? 16 : 15;\n\tcase 32:\n\t\treturn 24;\n\tdefault:\n\t\treturn var->bits_per_pixel;\n\t}\n}\n\n\nstatic __inline__ int var_to_refresh(const struct fb_var_screeninfo *var)\n{\n\tint xtot = var->xres + var->left_margin + var->right_margin +\n\t\t   var->hsync_len;\n\tint ytot = var->yres + var->upper_margin + var->lower_margin +\n\t\t   var->vsync_len;\n\n\treturn (1000000000 / var->pixclock * 1000 + 500) / xtot / ytot;\n}\n\n \n\nstatic void get_initial_mode(struct intelfb_info *dinfo)\n{\n\tstruct fb_var_screeninfo *var;\n\tint xtot, ytot;\n\n\tDBG_MSG(\"get_initial_mode\\n\");\n\n\tdinfo->initial_vga = 1;\n\tdinfo->initial_fb_base = screen_info.lfb_base;\n\tdinfo->initial_video_ram = screen_info.lfb_size * KB(64);\n\tdinfo->initial_pitch = screen_info.lfb_linelength;\n\n\tvar = &dinfo->initial_var;\n\tmemset(var, 0, sizeof(*var));\n\tvar->xres = screen_info.lfb_width;\n\tvar->yres = screen_info.lfb_height;\n\tvar->bits_per_pixel = screen_info.lfb_depth;\n\tswitch (screen_info.lfb_depth) {\n\tcase 15:\n\t\tvar->bits_per_pixel = 16;\n\t\tbreak;\n\tcase 24:\n\t\tvar->bits_per_pixel = 32;\n\t\tbreak;\n\t}\n\n\tDBG_MSG(\"Initial info: FB is 0x%x/0x%x (%d kByte)\\n\",\n\t\tdinfo->initial_fb_base, dinfo->initial_video_ram,\n\t\tBtoKB(dinfo->initial_video_ram));\n\n\tDBG_MSG(\"Initial info: mode is %dx%d-%d (%d)\\n\",\n\t\tvar->xres, var->yres, var->bits_per_pixel,\n\t\tdinfo->initial_pitch);\n\n\t \n\tvar->left_margin = (var->xres / 8) & 0xf8;\n\tvar->right_margin = 32;\n\tvar->upper_margin = 16;\n\tvar->lower_margin = 4;\n\tvar->hsync_len = (var->xres / 8) & 0xf8;\n\tvar->vsync_len = 4;\n\n\txtot = var->xres + var->left_margin +\n\t\tvar->right_margin + var->hsync_len;\n\tytot = var->yres + var->upper_margin +\n\t\tvar->lower_margin + var->vsync_len;\n\tvar->pixclock = 10000000 / xtot * 1000 / ytot * 100 / 60;\n\n\tvar->height = -1;\n\tvar->width = -1;\n\n\tif (var->bits_per_pixel > 8) {\n\t\tvar->red.offset = screen_info.red_pos;\n\t\tvar->red.length = screen_info.red_size;\n\t\tvar->green.offset = screen_info.green_pos;\n\t\tvar->green.length = screen_info.green_size;\n\t\tvar->blue.offset = screen_info.blue_pos;\n\t\tvar->blue.length = screen_info.blue_size;\n\t\tvar->transp.offset = screen_info.rsvd_pos;\n\t\tvar->transp.length = screen_info.rsvd_size;\n\t} else {\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t}\n}\n\nstatic int intelfb_init_var(struct intelfb_info *dinfo)\n{\n\tstruct fb_var_screeninfo *var;\n\tint msrc = 0;\n\n\tDBG_MSG(\"intelfb_init_var\\n\");\n\n\tvar = &dinfo->info->var;\n\tif (FIXED_MODE(dinfo)) {\n\t        memcpy(var, &dinfo->initial_var,\n\t\t       sizeof(struct fb_var_screeninfo));\n\t\tmsrc = 5;\n\t} else {\n\t\tconst u8 *edid_s = fb_firmware_edid(&dinfo->pdev->dev);\n\t\tu8 *edid_d = NULL;\n\n\t\tif (edid_s) {\n\t\t\tedid_d = kmemdup(edid_s, EDID_LENGTH, GFP_KERNEL);\n\n\t\t\tif (edid_d) {\n\t\t\t\tfb_edid_to_monspecs(edid_d,\n\t\t\t\t\t\t    &dinfo->info->monspecs);\n\t\t\t\tkfree(edid_d);\n\t\t\t}\n\t\t}\n\n\t\tif (mode) {\n\t\t\tprintk(\"intelfb: Looking for mode in private \"\n\t\t\t       \"database\\n\");\n\t\t\tmsrc = fb_find_mode(var, dinfo->info, mode,\n\t\t\t\t\t    dinfo->info->monspecs.modedb,\n\t\t\t\t\t    dinfo->info->monspecs.modedb_len,\n\t\t\t\t\t    NULL, 0);\n\n\t\t\tif (msrc && msrc > 1) {\n\t\t\t\tprintk(\"intelfb: No mode in private database, \"\n\t\t\t\t       \"intelfb: looking for mode in global \"\n\t\t\t\t       \"database \");\n\t\t\t\tmsrc = fb_find_mode(var, dinfo->info, mode,\n\t\t\t\t\t\t    NULL, 0, NULL, 0);\n\n\t\t\t\tif (msrc)\n\t\t\t\t\tmsrc |= 8;\n\t\t\t}\n\n\t\t}\n\n\t\tif (!msrc)\n\t\t\tmsrc = fb_find_mode(var, dinfo->info, PREFERRED_MODE,\n\t\t\t\t\t    NULL, 0, NULL, 0);\n\t}\n\n\tif (!msrc) {\n\t\tERR_MSG(\"Cannot find a suitable video mode.\\n\");\n\t\treturn 1;\n\t}\n\n\tINF_MSG(\"Initial video mode is %dx%d-%d@%d.\\n\", var->xres, var->yres,\n\t\tvar->bits_per_pixel, var_to_refresh(var));\n\n\tDBG_MSG(\"Initial video mode is from %d.\\n\", msrc);\n\n#if ALLOCATE_FOR_PANNING\n\t \n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual =\n\t\tdinfo->fb.size / 2 / (var->bits_per_pixel * var->xres);\n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres_virtual = var->yres;\n#else\n\tvar->yres_virtual = var->yres;\n#endif\n\n\tif (dinfo->accel)\n\t\tvar->accel_flags |= FB_ACCELF_TEXT;\n\telse\n\t\tvar->accel_flags &= ~FB_ACCELF_TEXT;\n\n\treturn 0;\n}\n\nstatic int intelfb_set_fbinfo(struct intelfb_info *dinfo)\n{\n\tstruct fb_info *info = dinfo->info;\n\n\tDBG_MSG(\"intelfb_set_fbinfo\\n\");\n\n\tinfo->fbops = &intel_fb_ops;\n\tinfo->pseudo_palette = dinfo->pseudo_palette;\n\n\tinfo->pixmap.size = 64*1024;\n\tinfo->pixmap.buf_align = 8;\n\tinfo->pixmap.access_align = 32;\n\tinfo->pixmap.flags = FB_PIXMAP_SYSTEM;\n\n\tif (intelfb_init_var(dinfo))\n\t\treturn 1;\n\n\tinfo->pixmap.scan_align = 1;\n\tstrcpy(info->fix.id, dinfo->name);\n\tinfo->fix.smem_start = dinfo->fb.physical;\n\tinfo->fix.smem_len = dinfo->fb.size;\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.type_aux = 0;\n\tinfo->fix.xpanstep = 8;\n\tinfo->fix.ypanstep = 1;\n\tinfo->fix.ywrapstep = 0;\n\tinfo->fix.mmio_start = dinfo->mmio_base_phys;\n\tinfo->fix.mmio_len = INTEL_REG_SIZE;\n\tinfo->fix.accel = FB_ACCEL_I830;\n\tupdate_dinfo(dinfo, &info->var);\n\n\treturn 0;\n}\n\n \nstatic void update_dinfo(struct intelfb_info *dinfo,\n\t\t\t struct fb_var_screeninfo *var)\n{\n\tDBG_MSG(\"update_dinfo\\n\");\n\n\tdinfo->bpp = var->bits_per_pixel;\n\tdinfo->depth = intelfb_var_to_depth(var);\n\tdinfo->xres = var->xres;\n\tdinfo->yres = var->xres;\n\tdinfo->pixclock = var->pixclock;\n\n\tdinfo->info->fix.visual = dinfo->visual;\n\tdinfo->info->fix.line_length = dinfo->pitch;\n\n\tswitch (dinfo->bpp) {\n\tcase 8:\n\t\tdinfo->visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tdinfo->pitch = var->xres_virtual;\n\t\tbreak;\n\tcase 16:\n\t\tdinfo->visual = FB_VISUAL_TRUECOLOR;\n\t\tdinfo->pitch = var->xres_virtual * 2;\n\t\tbreak;\n\tcase 32:\n\t\tdinfo->visual = FB_VISUAL_TRUECOLOR;\n\t\tdinfo->pitch = var->xres_virtual * 4;\n\t\tbreak;\n\t}\n\n\t \n\tif (IS_I9XX(dinfo))\n\t\tdinfo->pitch = ROUND_UP_TO(dinfo->pitch, STRIDE_ALIGNMENT_I9XX);\n\telse\n\t\tdinfo->pitch = ROUND_UP_TO(dinfo->pitch, STRIDE_ALIGNMENT);\n\n\tif (FIXED_MODE(dinfo))\n\t\tdinfo->pitch = dinfo->initial_pitch;\n\n\tdinfo->info->screen_base = (char __iomem *)dinfo->fb.virtual;\n\tdinfo->info->fix.line_length = dinfo->pitch;\n\tdinfo->info->fix.visual = dinfo->visual;\n}\n\n \n\n \n\nstatic int intelfb_open(struct fb_info *info, int user)\n{\n\tstruct intelfb_info *dinfo = GET_DINFO(info);\n\n\tif (user)\n\t\tdinfo->open++;\n\n\treturn 0;\n}\n\nstatic int intelfb_release(struct fb_info *info, int user)\n{\n\tstruct intelfb_info *dinfo = GET_DINFO(info);\n\n\tif (user) {\n\t\tdinfo->open--;\n\t\tmsleep(1);\n\t\tif (!dinfo->open)\n\t\t\tintelfbhw_disable_irq(dinfo);\n\t}\n\n\treturn 0;\n}\n\nstatic int intelfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tint change_var = 0;\n\tstruct fb_var_screeninfo v;\n\tstruct intelfb_info *dinfo;\n\tstatic int first = 1;\n\tint i;\n\t \n\tstatic const int pitches[] = {\n\t\t128 * 8,\n\t\t128 * 16,\n\t\t128 * 32,\n\t\t128 * 64,\n\t\t0\n\t};\n\n\tDBG_MSG(\"intelfb_check_var: accel_flags is %d\\n\", var->accel_flags);\n\n\tdinfo = GET_DINFO(info);\n\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\t \n\tif (intelfbhw_validate_mode(dinfo, var) != 0)\n\t\treturn -EINVAL;\n\n\tv = *var;\n\n\tfor (i = 0; pitches[i] != 0; i++) {\n\t\tif (pitches[i] >= v.xres_virtual) {\n\t\t\tv.xres_virtual = pitches[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (v.bits_per_pixel <= 8)\n\t\tv.bits_per_pixel = 8;\n\telse if (v.bits_per_pixel <= 16) {\n\t\tif (v.bits_per_pixel == 16)\n\t\t\tv.green.length = 6;\n\t\tv.bits_per_pixel = 16;\n\t} else if (v.bits_per_pixel <= 32)\n\t\tv.bits_per_pixel = 32;\n\telse\n\t\treturn -EINVAL;\n\n\tchange_var = ((info->var.xres != var->xres) ||\n\t\t      (info->var.yres != var->yres) ||\n\t\t      (info->var.xres_virtual != var->xres_virtual) ||\n\t\t      (info->var.yres_virtual != var->yres_virtual) ||\n\t\t      (info->var.bits_per_pixel != var->bits_per_pixel) ||\n\t\t      memcmp(&info->var.red, &var->red, sizeof(var->red)) ||\n\t\t      memcmp(&info->var.green, &var->green,\n\t\t\t     sizeof(var->green)) ||\n\t\t      memcmp(&info->var.blue, &var->blue, sizeof(var->blue)));\n\n\tif (FIXED_MODE(dinfo) &&\n\t    (change_var ||\n\t     var->yres_virtual > dinfo->initial_var.yres_virtual ||\n\t     var->yres_virtual < dinfo->initial_var.yres ||\n\t     var->xoffset || var->nonstd)) {\n\t\tif (first) {\n\t\t\tERR_MSG(\"Changing the video mode is not supported.\\n\");\n\t\t\tfirst = 0;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (intelfb_var_to_depth(&v)) {\n\tcase 8:\n\t\tv.red.offset = v.green.offset = v.blue.offset = 0;\n\t\tv.red.length = v.green.length = v.blue.length = 8;\n\t\tv.transp.offset = v.transp.length = 0;\n\t\tbreak;\n\tcase 15:\n\t\tv.red.offset = 10;\n\t\tv.green.offset = 5;\n\t\tv.blue.offset = 0;\n\t\tv.red.length = v.green.length = v.blue.length = 5;\n\t\tv.transp.offset = v.transp.length = 0;\n\t\tbreak;\n\tcase 16:\n\t\tv.red.offset = 11;\n\t\tv.green.offset = 5;\n\t\tv.blue.offset = 0;\n\t\tv.red.length = 5;\n\t\tv.green.length = 6;\n\t\tv.blue.length = 5;\n\t\tv.transp.offset = v.transp.length = 0;\n\t\tbreak;\n\tcase 24:\n\t\tv.red.offset = 16;\n\t\tv.green.offset = 8;\n\t\tv.blue.offset = 0;\n\t\tv.red.length = v.green.length = v.blue.length = 8;\n\t\tv.transp.offset = v.transp.length = 0;\n\t\tbreak;\n\tcase 32:\n\t\tv.red.offset = 16;\n\t\tv.green.offset = 8;\n\t\tv.blue.offset = 0;\n\t\tv.red.length = v.green.length = v.blue.length = 8;\n\t\tv.transp.offset = 24;\n\t\tv.transp.length = 8;\n\t\tbreak;\n\t}\n\n\tif (v.xoffset > v.xres_virtual - v.xres)\n\t\tv.xoffset = v.xres_virtual - v.xres;\n\tif (v.yoffset > v.yres_virtual - v.yres)\n\t\tv.yoffset = v.yres_virtual - v.yres;\n\n\tv.red.msb_right = v.green.msb_right = v.blue.msb_right =\n\t\t\t  v.transp.msb_right = 0;\n\n        *var = v;\n\n\treturn 0;\n}\n\nstatic int intelfb_set_par(struct fb_info *info)\n{\n\tstruct intelfb_hwstate *hw;\n        struct intelfb_info *dinfo = GET_DINFO(info);\n\n\tif (FIXED_MODE(dinfo)) {\n\t\tERR_MSG(\"Changing the video mode is not supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thw = kmalloc(sizeof(*hw), GFP_ATOMIC);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tDBG_MSG(\"intelfb_set_par (%dx%d-%d)\\n\", info->var.xres,\n\t\tinfo->var.yres, info->var.bits_per_pixel);\n\n\t \n\tOUTREG(DPLL_A, INREG(DPLL_A) & ~DPLL_VCO_ENABLE);\n\n\tintelfb_blank(FB_BLANK_POWERDOWN, info);\n\n\tif (ACCEL(dinfo, info))\n\t\tintelfbhw_2d_stop(dinfo);\n\n\tmemcpy(hw, &dinfo->save_state, sizeof(*hw));\n\tif (intelfbhw_mode_to_hw(dinfo, hw, &info->var))\n\t\tgoto invalid_mode;\n\tif (intelfbhw_program_mode(dinfo, hw, 0))\n\t\tgoto invalid_mode;\n\n#if REGDUMP > 0\n\tintelfbhw_read_hw_state(dinfo, hw, 0);\n\tintelfbhw_print_hw_state(dinfo, hw);\n#endif\n\n\tupdate_dinfo(dinfo, &info->var);\n\n\tif (ACCEL(dinfo, info))\n\t\tintelfbhw_2d_start(dinfo);\n\n\tintelfb_pan_display(&info->var, info);\n\n\tintelfb_blank(FB_BLANK_UNBLANK, info);\n\n\tif (ACCEL(dinfo, info)) {\n\t\tinfo->flags = FBINFO_HWACCEL_YPAN |\n\t\tFBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |\n\t\tFBINFO_HWACCEL_IMAGEBLIT;\n\t} else\n\t\tinfo->flags = FBINFO_HWACCEL_YPAN;\n\n\tkfree(hw);\n\treturn 0;\ninvalid_mode:\n\tkfree(hw);\n\treturn -EINVAL;\n}\n\nstatic int intelfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t     unsigned blue, unsigned transp,\n\t\t\t     struct fb_info *info)\n{\n\tstruct intelfb_info *dinfo = GET_DINFO(info);\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfb_setcolreg: regno %d, depth %d\\n\", regno, dinfo->depth);\n#endif\n\n\tif (regno > 255)\n\t\treturn 1;\n\n\tif (dinfo->depth == 8) {\n\t\tred >>= 8;\n\t\tgreen >>= 8;\n\t\tblue >>= 8;\n\n\t\tintelfbhw_setcolreg(dinfo, regno, red, green, blue,\n\t\t\t\t    transp);\n\t}\n\n\tif (regno < 16) {\n\t\tswitch (dinfo->depth) {\n\t\tcase 15:\n\t\t\tdinfo->pseudo_palette[regno] = ((red & 0xf800) >>  1) |\n\t\t\t\t((green & 0xf800) >>  6) |\n\t\t\t\t((blue & 0xf800) >> 11);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tdinfo->pseudo_palette[regno] = (red & 0xf800) |\n\t\t\t\t((green & 0xfc00) >>  5) |\n\t\t\t\t((blue  & 0xf800) >> 11);\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tdinfo->pseudo_palette[regno] = ((red & 0xff00) << 8) |\n\t\t\t\t(green & 0xff00) |\n\t\t\t\t((blue  & 0xff00) >> 8);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int intelfb_blank(int blank, struct fb_info *info)\n{\n\tintelfbhw_do_blank(blank, info);\n\treturn 0;\n}\n\nstatic int intelfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t       struct fb_info *info)\n{\n\tintelfbhw_pan_display(var, info);\n\treturn 0;\n}\n\n \nstatic int intelfb_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tint retval = 0;\n\tstruct intelfb_info *dinfo = GET_DINFO(info);\n\tu32 pipe = 0;\n\n\tswitch (cmd) {\n\t\tcase FBIO_WAITFORVSYNC:\n\t\t\tif (get_user(pipe, (__u32 __user *)arg))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tretval = intelfbhw_wait_for_vsync(dinfo, pipe);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\nstatic void intelfb_fillrect (struct fb_info *info,\n\t\t\t      const struct fb_fillrect *rect)\n{\n        struct intelfb_info *dinfo = GET_DINFO(info);\n\tu32 rop, color;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfb_fillrect\\n\");\n#endif\n\n\tif (!ACCEL(dinfo, info) || dinfo->depth == 4) {\n\t\tcfb_fillrect(info, rect);\n\t\treturn;\n\t}\n\n\tif (rect->rop == ROP_COPY)\n\t\trop = PAT_ROP_GXCOPY;\n\telse  \n\t\trop = PAT_ROP_GXXOR;\n\n\tif (dinfo->depth != 8)\n\t\tcolor = dinfo->pseudo_palette[rect->color];\n\telse\n\t\tcolor = rect->color;\n\n\tintelfbhw_do_fillrect(dinfo, rect->dx, rect->dy,\n\t\t\t      rect->width, rect->height, color,\n\t\t\t      dinfo->pitch, info->var.bits_per_pixel,\n\t\t\t      rop);\n}\n\nstatic void intelfb_copyarea(struct fb_info *info,\n\t\t\t     const struct fb_copyarea *region)\n{\n        struct intelfb_info *dinfo = GET_DINFO(info);\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfb_copyarea\\n\");\n#endif\n\n\tif (!ACCEL(dinfo, info) || dinfo->depth == 4) {\n\t\tcfb_copyarea(info, region);\n\t\treturn;\n\t}\n\n\tintelfbhw_do_bitblt(dinfo, region->sx, region->sy, region->dx,\n\t\t\t    region->dy, region->width, region->height,\n\t\t\t    dinfo->pitch, info->var.bits_per_pixel);\n}\n\nstatic void intelfb_imageblit(struct fb_info *info,\n\t\t\t      const struct fb_image *image)\n{\n        struct intelfb_info *dinfo = GET_DINFO(info);\n\tu32 fgcolor, bgcolor;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfb_imageblit\\n\");\n#endif\n\n\tif (!ACCEL(dinfo, info) || dinfo->depth == 4\n\t    || image->depth != 1) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\n\tif (dinfo->depth != 8) {\n\t\tfgcolor = dinfo->pseudo_palette[image->fg_color];\n\t\tbgcolor = dinfo->pseudo_palette[image->bg_color];\n\t} else {\n\t\tfgcolor = image->fg_color;\n\t\tbgcolor = image->bg_color;\n\t}\n\n\tif (!intelfbhw_do_drawglyph(dinfo, fgcolor, bgcolor, image->width,\n\t\t\t\t    image->height, image->data,\n\t\t\t\t    image->dx, image->dy,\n\t\t\t\t    dinfo->pitch, info->var.bits_per_pixel)) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n}\n\nstatic int intelfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n        struct intelfb_info *dinfo = GET_DINFO(info);\n\tu32 physical;\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfb_cursor\\n\");\n#endif\n\n\tif (!dinfo->hwcursor)\n\t\treturn -ENODEV;\n\n\tintelfbhw_cursor_hide(dinfo);\n\n\t \n\tphysical = (dinfo->mobile || IS_I9XX(dinfo)) ? dinfo->cursor.physical :\n\t\t   (dinfo->cursor.offset << 12);\n\n\tif (INREG(CURSOR_A_BASEADDR) != physical) {\n\t\tu32 fg, bg;\n\n\t\tDBG_MSG(\"the cursor was killed - restore it !!\\n\");\n\t\tDBG_MSG(\"size %d, %d   pos %d, %d\\n\",\n\t\t\tcursor->image.width, cursor->image.height,\n\t\t\tcursor->image.dx, cursor->image.dy);\n\n\t\tintelfbhw_cursor_init(dinfo);\n\t\tintelfbhw_cursor_reset(dinfo);\n\t\tintelfbhw_cursor_setpos(dinfo, cursor->image.dx,\n\t\t\t\t\tcursor->image.dy);\n\n\t\tif (dinfo->depth != 8) {\n\t\t\tfg =dinfo->pseudo_palette[cursor->image.fg_color];\n\t\t\tbg =dinfo->pseudo_palette[cursor->image.bg_color];\n\t\t} else {\n\t\t\tfg = cursor->image.fg_color;\n\t\t\tbg = cursor->image.bg_color;\n\t\t}\n\t\tintelfbhw_cursor_setcolor(dinfo, bg, fg);\n\t\tintelfbhw_cursor_load(dinfo, cursor->image.width,\n\t\t\t\t      cursor->image.height,\n\t\t\t\t      dinfo->cursor_src);\n\n\t\tif (cursor->enable)\n\t\t\tintelfbhw_cursor_show(dinfo);\n\t\treturn 0;\n\t}\n\n\tif (cursor->set & FB_CUR_SETPOS) {\n\t\tu32 dx, dy;\n\n\t\tdx = cursor->image.dx - info->var.xoffset;\n\t\tdy = cursor->image.dy - info->var.yoffset;\n\n\t\tintelfbhw_cursor_setpos(dinfo, dx, dy);\n\t}\n\n\tif (cursor->set & FB_CUR_SETSIZE) {\n\t\tif (cursor->image.width > 64 || cursor->image.height > 64)\n\t\t\treturn -ENXIO;\n\n\t\tintelfbhw_cursor_reset(dinfo);\n\t}\n\n\tif (cursor->set & FB_CUR_SETCMAP) {\n\t\tu32 fg, bg;\n\n\t\tif (dinfo->depth != 8) {\n\t\t\tfg = dinfo->pseudo_palette[cursor->image.fg_color];\n\t\t\tbg = dinfo->pseudo_palette[cursor->image.bg_color];\n\t\t} else {\n\t\t\tfg = cursor->image.fg_color;\n\t\t\tbg = cursor->image.bg_color;\n\t\t}\n\n\t\tintelfbhw_cursor_setcolor(dinfo, bg, fg);\n\t}\n\n\tif (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\n\t\tu32 s_pitch = (ROUND_UP_TO(cursor->image.width, 8) / 8);\n\t\tu32 size = s_pitch * cursor->image.height;\n\t\tu8 *dat = (u8 *) cursor->image.data;\n\t\tu8 *msk = (u8 *) cursor->mask;\n\t\tu8 src[64];\n\t\tu32 i;\n\n\t\tif (cursor->image.depth != 1)\n\t\t\treturn -ENXIO;\n\n\t\tswitch (cursor->rop) {\n\t\tcase ROP_XOR:\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\tsrc[i] = dat[i] ^ msk[i];\n\t\t\tbreak;\n\t\tcase ROP_COPY:\n\t\tdefault:\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\tsrc[i] = dat[i] & msk[i];\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmemcpy(dinfo->cursor_src, src, size);\n\n\t\tintelfbhw_cursor_load(dinfo, cursor->image.width,\n\t\t\t\t      cursor->image.height, src);\n\t}\n\n\tif (cursor->enable)\n\t\tintelfbhw_cursor_show(dinfo);\n\n\treturn 0;\n}\n\nstatic int intelfb_sync(struct fb_info *info)\n{\n        struct intelfb_info *dinfo = GET_DINFO(info);\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfb_sync\\n\");\n#endif\n\n\tif (dinfo->ring_lockup)\n\t\treturn 0;\n\n\tintelfbhw_do_sync(dinfo);\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}