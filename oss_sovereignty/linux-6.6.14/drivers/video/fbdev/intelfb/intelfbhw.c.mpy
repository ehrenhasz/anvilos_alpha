{
  "module_name": "intelfbhw.c",
  "hash_id": "f769ce26ce1b64befb234f7ffb9113cdb829ffd4b2e92bdc1df29673c8c7a16e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/intelfb/intelfbhw.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n\n#include <asm/io.h>\n\n#include \"intelfb.h\"\n#include \"intelfbhw.h\"\n\nstruct pll_min_max {\n\tint min_m, max_m, min_m1, max_m1;\n\tint min_m2, max_m2, min_n, max_n;\n\tint min_p, max_p, min_p1, max_p1;\n\tint min_vco, max_vco, p_transition_clk, ref_clk;\n\tint p_inc_lo, p_inc_hi;\n};\n\n#define PLLS_I8xx 0\n#define PLLS_I9xx 1\n#define PLLS_MAX 2\n\nstatic struct pll_min_max plls[PLLS_MAX] = {\n\t{ 108, 140, 18, 26,\n\t  6, 16, 3, 16,\n\t  4, 128, 0, 31,\n\t  930000, 1400000, 165000, 48000,\n\t  4, 2 },\t\t \n\n\t{ 75, 120, 10, 20,\n\t  5, 9, 4, 7,\n\t  5, 80, 1, 8,\n\t  1400000, 2800000, 200000, 96000,\n\t  10, 5 }\t\t \n};\n\nint intelfbhw_get_chipset(struct pci_dev *pdev, struct intelfb_info *dinfo)\n{\n\tu32 tmp;\n\tif (!pdev || !dinfo)\n\t\treturn 1;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_830M:\n\t\tdinfo->name = \"Intel(R) 830M\";\n\t\tdinfo->chipset = INTEL_830M;\n\t\tdinfo->mobile = 1;\n\t\tdinfo->pll_index = PLLS_I8xx;\n\t\treturn 0;\n\tcase PCI_DEVICE_ID_INTEL_845G:\n\t\tdinfo->name = \"Intel(R) 845G\";\n\t\tdinfo->chipset = INTEL_845G;\n\t\tdinfo->mobile = 0;\n\t\tdinfo->pll_index = PLLS_I8xx;\n\t\treturn 0;\n\tcase PCI_DEVICE_ID_INTEL_854:\n\t\tdinfo->mobile = 1;\n\t\tdinfo->name = \"Intel(R) 854\";\n\t\tdinfo->chipset = INTEL_854;\n\t\treturn 0;\n\tcase PCI_DEVICE_ID_INTEL_85XGM:\n\t\ttmp = 0;\n\t\tdinfo->mobile = 1;\n\t\tdinfo->pll_index = PLLS_I8xx;\n\t\tpci_read_config_dword(pdev, INTEL_85X_CAPID, &tmp);\n\t\tswitch ((tmp >> INTEL_85X_VARIANT_SHIFT) &\n\t\t\tINTEL_85X_VARIANT_MASK) {\n\t\tcase INTEL_VAR_855GME:\n\t\t\tdinfo->name = \"Intel(R) 855GME\";\n\t\t\tdinfo->chipset = INTEL_855GME;\n\t\t\treturn 0;\n\t\tcase INTEL_VAR_855GM:\n\t\t\tdinfo->name = \"Intel(R) 855GM\";\n\t\t\tdinfo->chipset = INTEL_855GM;\n\t\t\treturn 0;\n\t\tcase INTEL_VAR_852GME:\n\t\t\tdinfo->name = \"Intel(R) 852GME\";\n\t\t\tdinfo->chipset = INTEL_852GME;\n\t\t\treturn 0;\n\t\tcase INTEL_VAR_852GM:\n\t\t\tdinfo->name = \"Intel(R) 852GM\";\n\t\t\tdinfo->chipset = INTEL_852GM;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tdinfo->name = \"Intel(R) 852GM/855GM\";\n\t\t\tdinfo->chipset = INTEL_85XGM;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase PCI_DEVICE_ID_INTEL_865G:\n\t\tdinfo->name = \"Intel(R) 865G\";\n\t\tdinfo->chipset = INTEL_865G;\n\t\tdinfo->mobile = 0;\n\t\tdinfo->pll_index = PLLS_I8xx;\n\t\treturn 0;\n\tcase PCI_DEVICE_ID_INTEL_915G:\n\t\tdinfo->name = \"Intel(R) 915G\";\n\t\tdinfo->chipset = INTEL_915G;\n\t\tdinfo->mobile = 0;\n\t\tdinfo->pll_index = PLLS_I9xx;\n\t\treturn 0;\n\tcase PCI_DEVICE_ID_INTEL_915GM:\n\t\tdinfo->name = \"Intel(R) 915GM\";\n\t\tdinfo->chipset = INTEL_915GM;\n\t\tdinfo->mobile = 1;\n\t\tdinfo->pll_index = PLLS_I9xx;\n\t\treturn 0;\n\tcase PCI_DEVICE_ID_INTEL_945G:\n\t\tdinfo->name = \"Intel(R) 945G\";\n\t\tdinfo->chipset = INTEL_945G;\n\t\tdinfo->mobile = 0;\n\t\tdinfo->pll_index = PLLS_I9xx;\n\t\treturn 0;\n\tcase PCI_DEVICE_ID_INTEL_945GM:\n\t\tdinfo->name = \"Intel(R) 945GM\";\n\t\tdinfo->chipset = INTEL_945GM;\n\t\tdinfo->mobile = 1;\n\t\tdinfo->pll_index = PLLS_I9xx;\n\t\treturn 0;\n\tcase PCI_DEVICE_ID_INTEL_945GME:\n\t\tdinfo->name = \"Intel(R) 945GME\";\n\t\tdinfo->chipset = INTEL_945GME;\n\t\tdinfo->mobile = 1;\n\t\tdinfo->pll_index = PLLS_I9xx;\n\t\treturn 0;\n\tcase PCI_DEVICE_ID_INTEL_965G:\n\t\tdinfo->name = \"Intel(R) 965G\";\n\t\tdinfo->chipset = INTEL_965G;\n\t\tdinfo->mobile = 0;\n\t\tdinfo->pll_index = PLLS_I9xx;\n\t\treturn 0;\n\tcase PCI_DEVICE_ID_INTEL_965GM:\n\t\tdinfo->name = \"Intel(R) 965GM\";\n\t\tdinfo->chipset = INTEL_965GM;\n\t\tdinfo->mobile = 1;\n\t\tdinfo->pll_index = PLLS_I9xx;\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nint intelfbhw_get_memory(struct pci_dev *pdev, int *aperture_size,\n\t\t\t int *stolen_size)\n{\n\tstruct pci_dev *bridge_dev;\n\tu16 tmp;\n\tint stolen_overhead;\n\n\tif (!pdev || !aperture_size || !stolen_size)\n\t\treturn 1;\n\n\t \n\tbridge_dev = pci_get_domain_bus_and_slot(pci_domain_nr(pdev->bus), 0,\n\t\t\t\t\t\t PCI_DEVFN(0, 0));\n\tif (!bridge_dev) {\n\t\tERR_MSG(\"cannot find bridge device\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\ttmp = 0;\n\tpci_read_config_word(bridge_dev, INTEL_GMCH_CTRL, &tmp);\n\tpci_dev_put(bridge_dev);\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_915G:\n\tcase PCI_DEVICE_ID_INTEL_915GM:\n\tcase PCI_DEVICE_ID_INTEL_945G:\n\tcase PCI_DEVICE_ID_INTEL_945GM:\n\tcase PCI_DEVICE_ID_INTEL_945GME:\n\tcase PCI_DEVICE_ID_INTEL_965G:\n\tcase PCI_DEVICE_ID_INTEL_965GM:\n\t\t \n\t\t*aperture_size = pci_resource_len(pdev, 2);\n\t\tbreak;\n\tdefault:\n\t\tif ((tmp & INTEL_GMCH_MEM_MASK) == INTEL_GMCH_MEM_64M)\n\t\t\t*aperture_size = MB(64);\n\t\telse\n\t\t\t*aperture_size = MB(128);\n\t\tbreak;\n\t}\n\n\t \n\tstolen_overhead = (*aperture_size / MB(1)) + 4;\n\tswitch(pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_830M:\n\tcase PCI_DEVICE_ID_INTEL_845G:\n\t\tswitch (tmp & INTEL_830_GMCH_GMS_MASK) {\n\t\tcase INTEL_830_GMCH_GMS_STOLEN_512:\n\t\t\t*stolen_size = KB(512) - KB(stolen_overhead);\n\t\t\treturn 0;\n\t\tcase INTEL_830_GMCH_GMS_STOLEN_1024:\n\t\t\t*stolen_size = MB(1) - KB(stolen_overhead);\n\t\t\treturn 0;\n\t\tcase INTEL_830_GMCH_GMS_STOLEN_8192:\n\t\t\t*stolen_size = MB(8) - KB(stolen_overhead);\n\t\t\treturn 0;\n\t\tcase INTEL_830_GMCH_GMS_LOCAL:\n\t\t\tERR_MSG(\"only local memory found\\n\");\n\t\t\treturn 1;\n\t\tcase INTEL_830_GMCH_GMS_DISABLED:\n\t\t\tERR_MSG(\"video memory is disabled\\n\");\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tERR_MSG(\"unexpected GMCH_GMS value: 0x%02x\\n\",\n\t\t\t\ttmp & INTEL_830_GMCH_GMS_MASK);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tswitch (tmp & INTEL_855_GMCH_GMS_MASK) {\n\t\tcase INTEL_855_GMCH_GMS_STOLEN_1M:\n\t\t\t*stolen_size = MB(1) - KB(stolen_overhead);\n\t\t\treturn 0;\n\t\tcase INTEL_855_GMCH_GMS_STOLEN_4M:\n\t\t\t*stolen_size = MB(4) - KB(stolen_overhead);\n\t\t\treturn 0;\n\t\tcase INTEL_855_GMCH_GMS_STOLEN_8M:\n\t\t\t*stolen_size = MB(8) - KB(stolen_overhead);\n\t\t\treturn 0;\n\t\tcase INTEL_855_GMCH_GMS_STOLEN_16M:\n\t\t\t*stolen_size = MB(16) - KB(stolen_overhead);\n\t\t\treturn 0;\n\t\tcase INTEL_855_GMCH_GMS_STOLEN_32M:\n\t\t\t*stolen_size = MB(32) - KB(stolen_overhead);\n\t\t\treturn 0;\n\t\tcase INTEL_915G_GMCH_GMS_STOLEN_48M:\n\t\t\t*stolen_size = MB(48) - KB(stolen_overhead);\n\t\t\treturn 0;\n\t\tcase INTEL_915G_GMCH_GMS_STOLEN_64M:\n\t\t\t*stolen_size = MB(64) - KB(stolen_overhead);\n\t\t\treturn 0;\n\t\tcase INTEL_855_GMCH_GMS_DISABLED:\n\t\t\tERR_MSG(\"video memory is disabled\\n\");\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tERR_MSG(\"unexpected GMCH_GMS value: 0x%02x\\n\",\n\t\t\t\ttmp & INTEL_855_GMCH_GMS_MASK);\n\t\t\treturn 1;\n\t\t}\n\t}\n}\n\nint intelfbhw_check_non_crt(struct intelfb_info *dinfo)\n{\n\tint dvo = 0;\n\n\tif (INREG(LVDS) & PORT_ENABLE)\n\t\tdvo |= LVDS_PORT;\n\tif (INREG(DVOA) & PORT_ENABLE)\n\t\tdvo |= DVOA_PORT;\n\tif (INREG(DVOB) & PORT_ENABLE)\n\t\tdvo |= DVOB_PORT;\n\tif (INREG(DVOC) & PORT_ENABLE)\n\t\tdvo |= DVOC_PORT;\n\n\treturn dvo;\n}\n\nconst char * intelfbhw_dvo_to_string(int dvo)\n{\n\tif (dvo & DVOA_PORT)\n\t\treturn \"DVO port A\";\n\telse if (dvo & DVOB_PORT)\n\t\treturn \"DVO port B\";\n\telse if (dvo & DVOC_PORT)\n\t\treturn \"DVO port C\";\n\telse if (dvo & LVDS_PORT)\n\t\treturn \"LVDS port\";\n\telse\n\t\treturn NULL;\n}\n\n\nint intelfbhw_validate_mode(struct intelfb_info *dinfo,\n\t\t\t    struct fb_var_screeninfo *var)\n{\n\tint bytes_per_pixel;\n\tint tmp;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_validate_mode\\n\");\n#endif\n\n\tbytes_per_pixel = var->bits_per_pixel / 8;\n\tif (bytes_per_pixel == 3)\n\t\tbytes_per_pixel = 4;\n\n\t \n\ttmp = var->yres_virtual * var->xres_virtual * bytes_per_pixel;\n\tif (tmp > dinfo->fb.size) {\n\t\tWRN_MSG(\"Not enough video ram for mode \"\n\t\t\t\"(%d KByte vs %d KByte).\\n\",\n\t\t\tBtoKB(tmp), BtoKB(dinfo->fb.size));\n\t\treturn 1;\n\t}\n\n\t \n\tif (var->xres - 1 > HACTIVE_MASK) {\n\t\tWRN_MSG(\"X resolution too large (%d vs %d).\\n\",\n\t\t\tvar->xres, HACTIVE_MASK + 1);\n\t\treturn 1;\n\t}\n\tif (var->yres - 1 > VACTIVE_MASK) {\n\t\tWRN_MSG(\"Y resolution too large (%d vs %d).\\n\",\n\t\t\tvar->yres, VACTIVE_MASK + 1);\n\t\treturn 1;\n\t}\n\tif (var->xres < 4) {\n\t\tWRN_MSG(\"X resolution too small (%d vs 4).\\n\", var->xres);\n\t\treturn 1;\n\t}\n\tif (var->yres < 4) {\n\t\tWRN_MSG(\"Y resolution too small (%d vs 4).\\n\", var->yres);\n\t\treturn 1;\n\t}\n\n\t \n\tif (var->vmode & FB_VMODE_DOUBLE) {\n\t\tWRN_MSG(\"Mode is double-scan.\\n\");\n\t\treturn 1;\n\t}\n\n\tif ((var->vmode & FB_VMODE_INTERLACED) && (var->yres & 1)) {\n\t\tWRN_MSG(\"Odd number of lines in interlaced mode\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\ttmp = 1000000000 / var->pixclock;\n\tif (tmp < MIN_CLOCK) {\n\t\tWRN_MSG(\"Pixel clock is too low (%d MHz vs %d MHz).\\n\",\n\t\t\t(tmp + 500) / 1000, MIN_CLOCK / 1000);\n\t\treturn 1;\n\t}\n\tif (tmp > MAX_CLOCK) {\n\t\tWRN_MSG(\"Pixel clock is too high (%d MHz vs %d MHz).\\n\",\n\t\t\t(tmp + 500) / 1000, MAX_CLOCK / 1000);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint intelfbhw_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct intelfb_info *dinfo = GET_DINFO(info);\n\tu32 offset, xoffset, yoffset;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_pan_display\\n\");\n#endif\n\n\txoffset = ROUND_DOWN_TO(var->xoffset, 8);\n\tyoffset = var->yoffset;\n\n\tif ((xoffset + info->var.xres > info->var.xres_virtual) ||\n\t    (yoffset + info->var.yres > info->var.yres_virtual))\n\t\treturn -EINVAL;\n\n\toffset = (yoffset * dinfo->pitch) +\n\t\t (xoffset * info->var.bits_per_pixel) / 8;\n\n\toffset += dinfo->fb.offset << 12;\n\n\tdinfo->vsync.pan_offset = offset;\n\tif ((var->activate & FB_ACTIVATE_VBL) &&\n\t    !intelfbhw_enable_irq(dinfo))\n\t\tdinfo->vsync.pan_display = 1;\n\telse {\n\t\tdinfo->vsync.pan_display = 0;\n\t\tOUTREG(DSPABASE, offset);\n\t}\n\n\treturn 0;\n}\n\n \nvoid intelfbhw_do_blank(int blank, struct fb_info *info)\n{\n\tstruct intelfb_info *dinfo = GET_DINFO(info);\n\tu32 tmp;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_do_blank: blank is %d\\n\", blank);\n#endif\n\n\t \n\ttmp = INREG(DSPACNTR);\n\tif (blank)\n\t\ttmp &= ~DISPPLANE_PLANE_ENABLE;\n\telse\n\t\ttmp |= DISPPLANE_PLANE_ENABLE;\n\tOUTREG(DSPACNTR, tmp);\n\t \n\ttmp = INREG(DSPABASE);\n\tOUTREG(DSPABASE, tmp);\n\n\t \n#if VERBOSE > 0\n\tDBG_MSG(\"cursor_on is %d\\n\", dinfo->cursor_on);\n#endif\n\tif (dinfo->cursor_on) {\n\t\tif (blank)\n\t\t\tintelfbhw_cursor_hide(dinfo);\n\t\telse\n\t\t\tintelfbhw_cursor_show(dinfo);\n\t\tdinfo->cursor_on = 1;\n\t}\n\tdinfo->cursor_blanked = blank;\n\n\t \n\ttmp = INREG(ADPA) & ~ADPA_DPMS_CONTROL_MASK;\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\n\tcase FB_BLANK_NORMAL:\n\t\ttmp |= ADPA_DPMS_D0;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\ttmp |= ADPA_DPMS_D1;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\ttmp |= ADPA_DPMS_D2;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\ttmp |= ADPA_DPMS_D3;\n\t\tbreak;\n\t}\n\tOUTREG(ADPA, tmp);\n\n\treturn;\n}\n\n\n \nint intelfbhw_active_pipe(const struct intelfb_hwstate *hw)\n{\n\tint pipe = -1;\n\n\t \n\tif (hw->disp_b_ctrl & DISPPLANE_PLANE_ENABLE) {\n\t\tpipe = (hw->disp_b_ctrl >> DISPPLANE_SEL_PIPE_SHIFT);\n\t\tpipe &= PIPE_MASK;\n\t\tif (unlikely(pipe == PIPE_A))\n\t\t\treturn PIPE_A;\n\t}\n\tif (hw->disp_a_ctrl & DISPPLANE_PLANE_ENABLE) {\n\t\tpipe = (hw->disp_a_ctrl >> DISPPLANE_SEL_PIPE_SHIFT);\n\t\tpipe &= PIPE_MASK;\n\t\tif (likely(pipe == PIPE_A))\n\t\t\treturn PIPE_A;\n\t}\n\t \n\tWARN_ON(pipe == -1);\n\tif (unlikely(pipe == -1))\n\t\tpipe = PIPE_A;\n\n\treturn pipe;\n}\n\nvoid intelfbhw_setcolreg(struct intelfb_info *dinfo, unsigned regno,\n\t\t\t unsigned red, unsigned green, unsigned blue,\n\t\t\t unsigned transp)\n{\n\tu32 palette_reg = (dinfo->pipe == PIPE_A) ?\n\t\t\t  PALETTE_A : PALETTE_B;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_setcolreg: %d: (%d, %d, %d)\\n\",\n\t\tregno, red, green, blue);\n#endif\n\n\tOUTREG(palette_reg + (regno << 2),\n\t       (red << PALETTE_8_RED_SHIFT) |\n\t       (green << PALETTE_8_GREEN_SHIFT) |\n\t       (blue << PALETTE_8_BLUE_SHIFT));\n}\n\n\nint intelfbhw_read_hw_state(struct intelfb_info *dinfo,\n\t\t\t    struct intelfb_hwstate *hw, int flag)\n{\n\tint i;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_read_hw_state\\n\");\n#endif\n\n\tif (!hw || !dinfo)\n\t\treturn -1;\n\n\t \n\thw->vga0_divisor = INREG(VGA0_DIVISOR);\n\thw->vga1_divisor = INREG(VGA1_DIVISOR);\n\thw->vga_pd = INREG(VGAPD);\n\thw->dpll_a = INREG(DPLL_A);\n\thw->dpll_b = INREG(DPLL_B);\n\thw->fpa0 = INREG(FPA0);\n\thw->fpa1 = INREG(FPA1);\n\thw->fpb0 = INREG(FPB0);\n\thw->fpb1 = INREG(FPB1);\n\n\tif (flag == 1)\n\t\treturn flag;\n\n#if 0\n\t \n\tfor (i = 0; i < PALETTE_8_ENTRIES; i++) {\n\t\thw->palette_a[i] = INREG(PALETTE_A + (i << 2));\n\t\thw->palette_b[i] = INREG(PALETTE_B + (i << 2));\n\t}\n#endif\n\n\tif (flag == 2)\n\t\treturn flag;\n\n\thw->htotal_a = INREG(HTOTAL_A);\n\thw->hblank_a = INREG(HBLANK_A);\n\thw->hsync_a = INREG(HSYNC_A);\n\thw->vtotal_a = INREG(VTOTAL_A);\n\thw->vblank_a = INREG(VBLANK_A);\n\thw->vsync_a = INREG(VSYNC_A);\n\thw->src_size_a = INREG(SRC_SIZE_A);\n\thw->bclrpat_a = INREG(BCLRPAT_A);\n\thw->htotal_b = INREG(HTOTAL_B);\n\thw->hblank_b = INREG(HBLANK_B);\n\thw->hsync_b = INREG(HSYNC_B);\n\thw->vtotal_b = INREG(VTOTAL_B);\n\thw->vblank_b = INREG(VBLANK_B);\n\thw->vsync_b = INREG(VSYNC_B);\n\thw->src_size_b = INREG(SRC_SIZE_B);\n\thw->bclrpat_b = INREG(BCLRPAT_B);\n\n\tif (flag == 3)\n\t\treturn flag;\n\n\thw->adpa = INREG(ADPA);\n\thw->dvoa = INREG(DVOA);\n\thw->dvob = INREG(DVOB);\n\thw->dvoc = INREG(DVOC);\n\thw->dvoa_srcdim = INREG(DVOA_SRCDIM);\n\thw->dvob_srcdim = INREG(DVOB_SRCDIM);\n\thw->dvoc_srcdim = INREG(DVOC_SRCDIM);\n\thw->lvds = INREG(LVDS);\n\n\tif (flag == 4)\n\t\treturn flag;\n\n\thw->pipe_a_conf = INREG(PIPEACONF);\n\thw->pipe_b_conf = INREG(PIPEBCONF);\n\thw->disp_arb = INREG(DISPARB);\n\n\tif (flag == 5)\n\t\treturn flag;\n\n\thw->cursor_a_control = INREG(CURSOR_A_CONTROL);\n\thw->cursor_b_control = INREG(CURSOR_B_CONTROL);\n\thw->cursor_a_base = INREG(CURSOR_A_BASEADDR);\n\thw->cursor_b_base = INREG(CURSOR_B_BASEADDR);\n\n\tif (flag == 6)\n\t\treturn flag;\n\n\tfor (i = 0; i < 4; i++) {\n\t\thw->cursor_a_palette[i] = INREG(CURSOR_A_PALETTE0 + (i << 2));\n\t\thw->cursor_b_palette[i] = INREG(CURSOR_B_PALETTE0 + (i << 2));\n\t}\n\n\tif (flag == 7)\n\t\treturn flag;\n\n\thw->cursor_size = INREG(CURSOR_SIZE);\n\n\tif (flag == 8)\n\t\treturn flag;\n\n\thw->disp_a_ctrl = INREG(DSPACNTR);\n\thw->disp_b_ctrl = INREG(DSPBCNTR);\n\thw->disp_a_base = INREG(DSPABASE);\n\thw->disp_b_base = INREG(DSPBBASE);\n\thw->disp_a_stride = INREG(DSPASTRIDE);\n\thw->disp_b_stride = INREG(DSPBSTRIDE);\n\n\tif (flag == 9)\n\t\treturn flag;\n\n\thw->vgacntrl = INREG(VGACNTRL);\n\n\tif (flag == 10)\n\t\treturn flag;\n\n\thw->add_id = INREG(ADD_ID);\n\n\tif (flag == 11)\n\t\treturn flag;\n\n\tfor (i = 0; i < 7; i++) {\n\t\thw->swf0x[i] = INREG(SWF00 + (i << 2));\n\t\thw->swf1x[i] = INREG(SWF10 + (i << 2));\n\t\tif (i < 3)\n\t\t\thw->swf3x[i] = INREG(SWF30 + (i << 2));\n\t}\n\n\tfor (i = 0; i < 8; i++)\n\t\thw->fence[i] = INREG(FENCE + (i << 2));\n\n\thw->instpm = INREG(INSTPM);\n\thw->mem_mode = INREG(MEM_MODE);\n\thw->fw_blc_0 = INREG(FW_BLC_0);\n\thw->fw_blc_1 = INREG(FW_BLC_1);\n\n\thw->hwstam = INREG16(HWSTAM);\n\thw->ier = INREG16(IER);\n\thw->iir = INREG16(IIR);\n\thw->imr = INREG16(IMR);\n\n\treturn 0;\n}\n\n\nstatic int calc_vclock3(int index, int m, int n, int p)\n{\n\tif (p == 0 || n == 0)\n\t\treturn 0;\n\treturn plls[index].ref_clk * m / n / p;\n}\n\nstatic int calc_vclock(int index, int m1, int m2, int n, int p1, int p2,\n\t\t       int lvds)\n{\n\tstruct pll_min_max *pll = &plls[index];\n\tu32 m, vco, p;\n\n\tm = (5 * (m1 + 2)) + (m2 + 2);\n\tn += 2;\n\tvco = pll->ref_clk * m / n;\n\n\tif (index == PLLS_I8xx)\n\t\tp = ((p1 + 2) * (1 << (p2 + 1)));\n\telse\n\t\tp = ((p1) * (p2 ? 5 : 10));\n\treturn vco / p;\n}\n\n#if REGDUMP\nstatic void intelfbhw_get_p1p2(struct intelfb_info *dinfo, int dpll,\n\t\t\t       int *o_p1, int *o_p2)\n{\n\tint p1, p2;\n\n\tif (IS_I9XX(dinfo)) {\n\t\tif (dpll & DPLL_P1_FORCE_DIV2)\n\t\t\tp1 = 1;\n\t\telse\n\t\t\tp1 = (dpll >> DPLL_P1_SHIFT) & 0xff;\n\n\t\tp1 = ffs(p1);\n\n\t\tp2 = (dpll >> DPLL_I9XX_P2_SHIFT) & DPLL_P2_MASK;\n\t} else {\n\t\tif (dpll & DPLL_P1_FORCE_DIV2)\n\t\t\tp1 = 0;\n\t\telse\n\t\t\tp1 = (dpll >> DPLL_P1_SHIFT) & DPLL_P1_MASK;\n\t\tp2 = (dpll >> DPLL_P2_SHIFT) & DPLL_P2_MASK;\n\t}\n\n\t*o_p1 = p1;\n\t*o_p2 = p2;\n}\n#endif\n\n\nvoid intelfbhw_print_hw_state(struct intelfb_info *dinfo,\n\t\t\t      struct intelfb_hwstate *hw)\n{\n#if REGDUMP\n\tint i, m1, m2, n, p1, p2;\n\tint index = dinfo->pll_index;\n\tDBG_MSG(\"intelfbhw_print_hw_state\\n\");\n\n\tif (!hw)\n\t\treturn;\n\t \n\tprintk(\"hw state dump start\\n\");\n\tprintk(\"\tVGA0_DIVISOR:\t\t0x%08x\\n\", hw->vga0_divisor);\n\tprintk(\"\tVGA1_DIVISOR:\t\t0x%08x\\n\", hw->vga1_divisor);\n\tprintk(\"\tVGAPD:\t\t\t0x%08x\\n\", hw->vga_pd);\n\tn = (hw->vga0_divisor >> FP_N_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\n\tm1 = (hw->vga0_divisor >> FP_M1_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\n\tm2 = (hw->vga0_divisor >> FP_M2_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\n\n\tintelfbhw_get_p1p2(dinfo, hw->vga_pd, &p1, &p2);\n\n\tprintk(\"\tVGA0: (m1, m2, n, p1, p2) = (%d, %d, %d, %d, %d)\\n\",\n\t       m1, m2, n, p1, p2);\n\tprintk(\"\tVGA0: clock is %d\\n\",\n\t       calc_vclock(index, m1, m2, n, p1, p2, 0));\n\n\tn = (hw->vga1_divisor >> FP_N_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\n\tm1 = (hw->vga1_divisor >> FP_M1_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\n\tm2 = (hw->vga1_divisor >> FP_M2_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\n\n\tintelfbhw_get_p1p2(dinfo, hw->vga_pd, &p1, &p2);\n\tprintk(\"\tVGA1: (m1, m2, n, p1, p2) = (%d, %d, %d, %d, %d)\\n\",\n\t       m1, m2, n, p1, p2);\n\tprintk(\"\tVGA1: clock is %d\\n\",\n\t       calc_vclock(index, m1, m2, n, p1, p2, 0));\n\n\tprintk(\"\tDPLL_A:\t\t\t0x%08x\\n\", hw->dpll_a);\n\tprintk(\"\tDPLL_B:\t\t\t0x%08x\\n\", hw->dpll_b);\n\tprintk(\"\tFPA0:\t\t\t0x%08x\\n\", hw->fpa0);\n\tprintk(\"\tFPA1:\t\t\t0x%08x\\n\", hw->fpa1);\n\tprintk(\"\tFPB0:\t\t\t0x%08x\\n\", hw->fpb0);\n\tprintk(\"\tFPB1:\t\t\t0x%08x\\n\", hw->fpb1);\n\n\tn = (hw->fpa0 >> FP_N_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\n\tm1 = (hw->fpa0 >> FP_M1_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\n\tm2 = (hw->fpa0 >> FP_M2_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\n\n\tintelfbhw_get_p1p2(dinfo, hw->dpll_a, &p1, &p2);\n\n\tprintk(\"\tPLLA0: (m1, m2, n, p1, p2) = (%d, %d, %d, %d, %d)\\n\",\n\t       m1, m2, n, p1, p2);\n\tprintk(\"\tPLLA0: clock is %d\\n\",\n\t       calc_vclock(index, m1, m2, n, p1, p2, 0));\n\n\tn = (hw->fpa1 >> FP_N_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\n\tm1 = (hw->fpa1 >> FP_M1_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\n\tm2 = (hw->fpa1 >> FP_M2_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\n\n\tintelfbhw_get_p1p2(dinfo, hw->dpll_a, &p1, &p2);\n\n\tprintk(\"\tPLLA1: (m1, m2, n, p1, p2) = (%d, %d, %d, %d, %d)\\n\",\n\t       m1, m2, n, p1, p2);\n\tprintk(\"\tPLLA1: clock is %d\\n\",\n\t       calc_vclock(index, m1, m2, n, p1, p2, 0));\n\n#if 0\n\tprintk(\"\tPALETTE_A:\\n\");\n\tfor (i = 0; i < PALETTE_8_ENTRIES)\n\t\tprintk(\"\t%3d:\t0x%08x\\n\", i, hw->palette_a[i]);\n\tprintk(\"\tPALETTE_B:\\n\");\n\tfor (i = 0; i < PALETTE_8_ENTRIES)\n\t\tprintk(\"\t%3d:\t0x%08x\\n\", i, hw->palette_b[i]);\n#endif\n\n\tprintk(\"\tHTOTAL_A:\t\t0x%08x\\n\", hw->htotal_a);\n\tprintk(\"\tHBLANK_A:\t\t0x%08x\\n\", hw->hblank_a);\n\tprintk(\"\tHSYNC_A:\t\t0x%08x\\n\", hw->hsync_a);\n\tprintk(\"\tVTOTAL_A:\t\t0x%08x\\n\", hw->vtotal_a);\n\tprintk(\"\tVBLANK_A:\t\t0x%08x\\n\", hw->vblank_a);\n\tprintk(\"\tVSYNC_A:\t\t0x%08x\\n\", hw->vsync_a);\n\tprintk(\"\tSRC_SIZE_A:\t\t0x%08x\\n\", hw->src_size_a);\n\tprintk(\"\tBCLRPAT_A:\t\t0x%08x\\n\", hw->bclrpat_a);\n\tprintk(\"\tHTOTAL_B:\t\t0x%08x\\n\", hw->htotal_b);\n\tprintk(\"\tHBLANK_B:\t\t0x%08x\\n\", hw->hblank_b);\n\tprintk(\"\tHSYNC_B:\t\t0x%08x\\n\", hw->hsync_b);\n\tprintk(\"\tVTOTAL_B:\t\t0x%08x\\n\", hw->vtotal_b);\n\tprintk(\"\tVBLANK_B:\t\t0x%08x\\n\", hw->vblank_b);\n\tprintk(\"\tVSYNC_B:\t\t0x%08x\\n\", hw->vsync_b);\n\tprintk(\"\tSRC_SIZE_B:\t\t0x%08x\\n\", hw->src_size_b);\n\tprintk(\"\tBCLRPAT_B:\t\t0x%08x\\n\", hw->bclrpat_b);\n\n\tprintk(\"\tADPA:\t\t\t0x%08x\\n\", hw->adpa);\n\tprintk(\"\tDVOA:\t\t\t0x%08x\\n\", hw->dvoa);\n\tprintk(\"\tDVOB:\t\t\t0x%08x\\n\", hw->dvob);\n\tprintk(\"\tDVOC:\t\t\t0x%08x\\n\", hw->dvoc);\n\tprintk(\"\tDVOA_SRCDIM:\t\t0x%08x\\n\", hw->dvoa_srcdim);\n\tprintk(\"\tDVOB_SRCDIM:\t\t0x%08x\\n\", hw->dvob_srcdim);\n\tprintk(\"\tDVOC_SRCDIM:\t\t0x%08x\\n\", hw->dvoc_srcdim);\n\tprintk(\"\tLVDS:\t\t\t0x%08x\\n\", hw->lvds);\n\n\tprintk(\"\tPIPEACONF:\t\t0x%08x\\n\", hw->pipe_a_conf);\n\tprintk(\"\tPIPEBCONF:\t\t0x%08x\\n\", hw->pipe_b_conf);\n\tprintk(\"\tDISPARB:\t\t0x%08x\\n\", hw->disp_arb);\n\n\tprintk(\"\tCURSOR_A_CONTROL:\t0x%08x\\n\", hw->cursor_a_control);\n\tprintk(\"\tCURSOR_B_CONTROL:\t0x%08x\\n\", hw->cursor_b_control);\n\tprintk(\"\tCURSOR_A_BASEADDR:\t0x%08x\\n\", hw->cursor_a_base);\n\tprintk(\"\tCURSOR_B_BASEADDR:\t0x%08x\\n\", hw->cursor_b_base);\n\n\tprintk(\"\tCURSOR_A_PALETTE:\t\");\n\tfor (i = 0; i < 4; i++) {\n\t\tprintk(\"0x%08x\", hw->cursor_a_palette[i]);\n\t\tif (i < 3)\n\t\t\tprintk(\", \");\n\t}\n\tprintk(\"\\n\");\n\tprintk(\"\tCURSOR_B_PALETTE:\t\");\n\tfor (i = 0; i < 4; i++) {\n\t\tprintk(\"0x%08x\", hw->cursor_b_palette[i]);\n\t\tif (i < 3)\n\t\t\tprintk(\", \");\n\t}\n\tprintk(\"\\n\");\n\n\tprintk(\"\tCURSOR_SIZE:\t\t0x%08x\\n\", hw->cursor_size);\n\n\tprintk(\"\tDSPACNTR:\t\t0x%08x\\n\", hw->disp_a_ctrl);\n\tprintk(\"\tDSPBCNTR:\t\t0x%08x\\n\", hw->disp_b_ctrl);\n\tprintk(\"\tDSPABASE:\t\t0x%08x\\n\", hw->disp_a_base);\n\tprintk(\"\tDSPBBASE:\t\t0x%08x\\n\", hw->disp_b_base);\n\tprintk(\"\tDSPASTRIDE:\t\t0x%08x\\n\", hw->disp_a_stride);\n\tprintk(\"\tDSPBSTRIDE:\t\t0x%08x\\n\", hw->disp_b_stride);\n\n\tprintk(\"\tVGACNTRL:\t\t0x%08x\\n\", hw->vgacntrl);\n\tprintk(\"\tADD_ID:\t\t\t0x%08x\\n\", hw->add_id);\n\n\tfor (i = 0; i < 7; i++) {\n\t\tprintk(\"\tSWF0%d\t\t\t0x%08x\\n\", i,\n\t\t\thw->swf0x[i]);\n\t}\n\tfor (i = 0; i < 7; i++) {\n\t\tprintk(\"\tSWF1%d\t\t\t0x%08x\\n\", i,\n\t\t\thw->swf1x[i]);\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\tprintk(\"\tSWF3%d\t\t\t0x%08x\\n\", i,\n\t\t       hw->swf3x[i]);\n\t}\n\tfor (i = 0; i < 8; i++)\n\t\tprintk(\"\tFENCE%d\t\t\t0x%08x\\n\", i,\n\t\t       hw->fence[i]);\n\n\tprintk(\"\tINSTPM\t\t\t0x%08x\\n\", hw->instpm);\n\tprintk(\"\tMEM_MODE\t\t0x%08x\\n\", hw->mem_mode);\n\tprintk(\"\tFW_BLC_0\t\t0x%08x\\n\", hw->fw_blc_0);\n\tprintk(\"\tFW_BLC_1\t\t0x%08x\\n\", hw->fw_blc_1);\n\n\tprintk(\"\tHWSTAM\t\t\t0x%04x\\n\", hw->hwstam);\n\tprintk(\"\tIER\t\t\t0x%04x\\n\", hw->ier);\n\tprintk(\"\tIIR\t\t\t0x%04x\\n\", hw->iir);\n\tprintk(\"\tIMR\t\t\t0x%04x\\n\", hw->imr);\n\tprintk(\"hw state dump end\\n\");\n#endif\n}\n\n\n\n \nstatic int splitm(int index, unsigned int m, unsigned int *retm1,\n\t\t  unsigned int *retm2)\n{\n\tint m1, m2;\n\tint testm;\n\tstruct pll_min_max *pll = &plls[index];\n\n\t \n\tfor (m1 = pll->min_m1; m1 < pll->max_m1 + 1; m1++) {\n\t\tfor (m2 = pll->min_m2; m2 < pll->max_m2 + 1; m2++) {\n\t\t\ttestm = (5 * (m1 + 2)) + (m2 + 2);\n\t\t\tif (testm == m) {\n\t\t\t\t*retm1 = (unsigned int)m1;\n\t\t\t\t*retm2 = (unsigned int)m2;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\n \nstatic int splitp(int index, unsigned int p, unsigned int *retp1,\n\t\t  unsigned int *retp2)\n{\n\tint p1, p2;\n\tstruct pll_min_max *pll = &plls[index];\n\n\tif (index == PLLS_I9xx) {\n\t\tp2 = (p % 10) ? 1 : 0;\n\n\t\tp1 = p / (p2 ? 5 : 10);\n\n\t\t*retp1 = (unsigned int)p1;\n\t\t*retp2 = (unsigned int)p2;\n\t\treturn 0;\n\t}\n\n\tif (p % 4 == 0)\n\t\tp2 = 1;\n\telse\n\t\tp2 = 0;\n\tp1 = (p / (1 << (p2 + 1))) - 2;\n\tif (p % 4 == 0 && p1 < pll->min_p1) {\n\t\tp2 = 0;\n\t\tp1 = (p / (1 << (p2 + 1))) - 2;\n\t}\n\tif (p1 < pll->min_p1 || p1 > pll->max_p1 ||\n\t    (p1 + 2) * (1 << (p2 + 1)) != p) {\n\t\treturn 1;\n\t} else {\n\t\t*retp1 = (unsigned int)p1;\n\t\t*retp2 = (unsigned int)p2;\n\t\treturn 0;\n\t}\n}\n\nstatic int calc_pll_params(int index, int clock, u32 *retm1, u32 *retm2,\n\t\t\t   u32 *retn, u32 *retp1, u32 *retp2, u32 *retclock)\n{\n\tu32 m1, m2, n, p1, p2, n1, testm;\n\tu32 f_vco, p, p_best = 0, m, f_out = 0;\n\tu32 err_best = 10000000;\n\tu32 n_best = 0, m_best = 0, f_err;\n\tu32 p_min, p_max, p_inc, div_max;\n\tstruct pll_min_max *pll = &plls[index];\n\n\tDBG_MSG(\"Clock is %d\\n\", clock);\n\n\tdiv_max = pll->max_vco / clock;\n\n\tp_inc = (clock <= pll->p_transition_clk) ? pll->p_inc_lo : pll->p_inc_hi;\n\tp_min = p_inc;\n\tp_max = ROUND_DOWN_TO(div_max, p_inc);\n\tif (p_min < pll->min_p)\n\t\tp_min = pll->min_p;\n\tif (p_max > pll->max_p)\n\t\tp_max = pll->max_p;\n\n\tDBG_MSG(\"p range is %d-%d (%d)\\n\", p_min, p_max, p_inc);\n\n\tp = p_min;\n\tdo {\n\t\tif (splitp(index, p, &p1, &p2)) {\n\t\t\tWRN_MSG(\"cannot split p = %d\\n\", p);\n\t\t\tp += p_inc;\n\t\t\tcontinue;\n\t\t}\n\t\tn = pll->min_n;\n\t\tf_vco = clock * p;\n\n\t\tdo {\n\t\t\tm = ROUND_UP_TO(f_vco * n, pll->ref_clk) / pll->ref_clk;\n\t\t\tif (m < pll->min_m)\n\t\t\t\tm = pll->min_m + 1;\n\t\t\tif (m > pll->max_m)\n\t\t\t\tm = pll->max_m - 1;\n\t\t\tfor (testm = m - 1; testm <= m; testm++) {\n\t\t\t\tf_out = calc_vclock3(index, testm, n, p);\n\t\t\t\tif (splitm(index, testm, &m1, &m2)) {\n\t\t\t\t\tWRN_MSG(\"cannot split m = %d\\n\",\n\t\t\t\t\t\ttestm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (clock > f_out)\n\t\t\t\t\tf_err = clock - f_out;\n\t\t\t\telse \n\t\t\t\t\tf_err = f_out - clock + 1;\n\n\t\t\t\tif (f_err < err_best) {\n\t\t\t\t\tm_best = testm;\n\t\t\t\t\tn_best = n;\n\t\t\t\t\tp_best = p;\n\t\t\t\t\terr_best = f_err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn++;\n\t\t} while ((n <= pll->max_n) && (f_out >= clock));\n\t\tp += p_inc;\n\t} while ((p <= p_max));\n\n\tif (!m_best) {\n\t\tWRN_MSG(\"cannot find parameters for clock %d\\n\", clock);\n\t\treturn 1;\n\t}\n\tm = m_best;\n\tn = n_best;\n\tp = p_best;\n\tsplitm(index, m, &m1, &m2);\n\tsplitp(index, p, &p1, &p2);\n\tn1 = n - 2;\n\n\tDBG_MSG(\"m, n, p: %d (%d,%d), %d (%d), %d (%d,%d), \"\n\t\t\"f: %d (%d), VCO: %d\\n\",\n\t\tm, m1, m2, n, n1, p, p1, p2,\n\t\tcalc_vclock3(index, m, n, p),\n\t\tcalc_vclock(index, m1, m2, n1, p1, p2, 0),\n\t\tcalc_vclock3(index, m, n, p) * p);\n\t*retm1 = m1;\n\t*retm2 = m2;\n\t*retn = n1;\n\t*retp1 = p1;\n\t*retp2 = p2;\n\t*retclock = calc_vclock(index, m1, m2, n1, p1, p2, 0);\n\n\treturn 0;\n}\n\nstatic __inline__ int check_overflow(u32 value, u32 limit,\n\t\t\t\t     const char *description)\n{\n\tif (value > limit) {\n\t\tWRN_MSG(\"%s value %d exceeds limit %d\\n\",\n\t\t\tdescription, value, limit);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nint intelfbhw_mode_to_hw(struct intelfb_info *dinfo,\n\t\t\t struct intelfb_hwstate *hw,\n\t\t\t struct fb_var_screeninfo *var)\n{\n\tint pipe = intelfbhw_active_pipe(hw);\n\tu32 *dpll, *fp0, *fp1;\n\tu32 m1, m2, n, p1, p2, clock_target, clock;\n\tu32 hsync_start, hsync_end, hblank_start, hblank_end, htotal, hactive;\n\tu32 vsync_start, vsync_end, vblank_start, vblank_end, vtotal, vactive;\n\tu32 vsync_pol, hsync_pol;\n\tu32 *vs, *vb, *vt, *hs, *hb, *ht, *ss, *pipe_conf;\n\tu32 stride_alignment;\n\n\tDBG_MSG(\"intelfbhw_mode_to_hw\\n\");\n\n\t \n\thw->vgacntrl |= VGA_DISABLE;\n\n\t \n\tif (pipe == PIPE_B) {\n\t\tdpll = &hw->dpll_b;\n\t\tfp0 = &hw->fpb0;\n\t\tfp1 = &hw->fpb1;\n\t\ths = &hw->hsync_b;\n\t\thb = &hw->hblank_b;\n\t\tht = &hw->htotal_b;\n\t\tvs = &hw->vsync_b;\n\t\tvb = &hw->vblank_b;\n\t\tvt = &hw->vtotal_b;\n\t\tss = &hw->src_size_b;\n\t\tpipe_conf = &hw->pipe_b_conf;\n\t} else {\n\t\tdpll = &hw->dpll_a;\n\t\tfp0 = &hw->fpa0;\n\t\tfp1 = &hw->fpa1;\n\t\ths = &hw->hsync_a;\n\t\thb = &hw->hblank_a;\n\t\tht = &hw->htotal_a;\n\t\tvs = &hw->vsync_a;\n\t\tvb = &hw->vblank_a;\n\t\tvt = &hw->vtotal_a;\n\t\tss = &hw->src_size_a;\n\t\tpipe_conf = &hw->pipe_a_conf;\n\t}\n\n\t \n\thw->adpa &= ~ADPA_USE_VGA_HVPOLARITY;\n\n\t \n\thsync_pol = (var->sync & FB_SYNC_HOR_HIGH_ACT) ?\n\t\t\tADPA_SYNC_ACTIVE_HIGH : ADPA_SYNC_ACTIVE_LOW;\n\tvsync_pol = (var->sync & FB_SYNC_VERT_HIGH_ACT) ?\n\t\t\tADPA_SYNC_ACTIVE_HIGH : ADPA_SYNC_ACTIVE_LOW;\n\thw->adpa &= ~((ADPA_SYNC_ACTIVE_MASK << ADPA_VSYNC_ACTIVE_SHIFT) |\n\t\t      (ADPA_SYNC_ACTIVE_MASK << ADPA_HSYNC_ACTIVE_SHIFT));\n\thw->adpa |= (hsync_pol << ADPA_HSYNC_ACTIVE_SHIFT) |\n\t\t    (vsync_pol << ADPA_VSYNC_ACTIVE_SHIFT);\n\n\t \n\thw->adpa &= ~(PIPE_MASK << ADPA_PIPE_SELECT_SHIFT);\n\thw->adpa |= (pipe << ADPA_PIPE_SELECT_SHIFT);\n\n\t \n\thw->adpa &= ~ADPA_DPMS_CONTROL_MASK;\n\thw->adpa |= ADPA_DPMS_D0;\n\n\thw->adpa |= ADPA_DAC_ENABLE;\n\n\t*dpll |= (DPLL_VCO_ENABLE | DPLL_VGA_MODE_DISABLE);\n\t*dpll &= ~(DPLL_RATE_SELECT_MASK | DPLL_REFERENCE_SELECT_MASK);\n\t*dpll |= (DPLL_REFERENCE_DEFAULT | DPLL_RATE_SELECT_FP0);\n\n\t \n\tclock_target = 1000000000 / var->pixclock;\n\n\tif (calc_pll_params(dinfo->pll_index, clock_target, &m1, &m2,\n\t\t\t    &n, &p1, &p2, &clock)) {\n\t\tWRN_MSG(\"calc_pll_params failed\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (check_overflow(p1, DPLL_P1_MASK, \"PLL P1 parameter\"))\n\t\treturn 1;\n\tif (check_overflow(p2, DPLL_P2_MASK, \"PLL P2 parameter\"))\n\t\treturn 1;\n\tif (check_overflow(m1, FP_DIVISOR_MASK, \"PLL M1 parameter\"))\n\t\treturn 1;\n\tif (check_overflow(m2, FP_DIVISOR_MASK, \"PLL M2 parameter\"))\n\t\treturn 1;\n\tif (check_overflow(n, FP_DIVISOR_MASK, \"PLL N parameter\"))\n\t\treturn 1;\n\n\t*dpll &= ~DPLL_P1_FORCE_DIV2;\n\t*dpll &= ~((DPLL_P2_MASK << DPLL_P2_SHIFT) |\n\t\t   (DPLL_P1_MASK << DPLL_P1_SHIFT));\n\n\tif (IS_I9XX(dinfo)) {\n\t\t*dpll |= (p2 << DPLL_I9XX_P2_SHIFT);\n\t\t*dpll |= (1 << (p1 - 1)) << DPLL_P1_SHIFT;\n\t} else\n\t\t*dpll |= (p2 << DPLL_P2_SHIFT) | (p1 << DPLL_P1_SHIFT);\n\n\t*fp0 = (n << FP_N_DIVISOR_SHIFT) |\n\t       (m1 << FP_M1_DIVISOR_SHIFT) |\n\t       (m2 << FP_M2_DIVISOR_SHIFT);\n\t*fp1 = *fp0;\n\n\thw->dvob &= ~PORT_ENABLE;\n\thw->dvoc &= ~PORT_ENABLE;\n\n\t \n\thw->disp_a_ctrl |= DISPPLANE_PLANE_ENABLE;\n\thw->disp_a_ctrl &= ~DISPPLANE_GAMMA_ENABLE;\n\thw->disp_a_ctrl &= ~DISPPLANE_PIXFORMAT_MASK;\n\tswitch (intelfb_var_to_depth(var)) {\n\tcase 8:\n\t\thw->disp_a_ctrl |= DISPPLANE_8BPP | DISPPLANE_GAMMA_ENABLE;\n\t\tbreak;\n\tcase 15:\n\t\thw->disp_a_ctrl |= DISPPLANE_15_16BPP;\n\t\tbreak;\n\tcase 16:\n\t\thw->disp_a_ctrl |= DISPPLANE_16BPP;\n\t\tbreak;\n\tcase 24:\n\t\thw->disp_a_ctrl |= DISPPLANE_32BPP_NO_ALPHA;\n\t\tbreak;\n\t}\n\thw->disp_a_ctrl &= ~(PIPE_MASK << DISPPLANE_SEL_PIPE_SHIFT);\n\thw->disp_a_ctrl |= (pipe << DISPPLANE_SEL_PIPE_SHIFT);\n\n\t \n\thactive = var->xres;\n\thsync_start = hactive + var->right_margin;\n\thsync_end = hsync_start + var->hsync_len;\n\thtotal = hsync_end + var->left_margin;\n\thblank_start = hactive;\n\thblank_end = htotal;\n\n\tDBG_MSG(\"H: act %d, ss %d, se %d, tot %d bs %d, be %d\\n\",\n\t\thactive, hsync_start, hsync_end, htotal, hblank_start,\n\t\thblank_end);\n\n\tvactive = var->yres;\n\tif (var->vmode & FB_VMODE_INTERLACED)\n\t\tvactive--;  \n\tvsync_start = vactive + var->lower_margin;\n\tvsync_end = vsync_start + var->vsync_len;\n\tvtotal = vsync_end + var->upper_margin;\n\tvblank_start = vactive;\n\tvblank_end = vsync_end + 1;\n\n\tDBG_MSG(\"V: act %d, ss %d, se %d, tot %d bs %d, be %d\\n\",\n\t\tvactive, vsync_start, vsync_end, vtotal, vblank_start,\n\t\tvblank_end);\n\n\t \n\thactive--;\n\tif (check_overflow(hactive, HACTIVE_MASK, \"CRTC hactive\"))\n\t\treturn 1;\n\thsync_start--;\n\tif (check_overflow(hsync_start, HSYNCSTART_MASK, \"CRTC hsync_start\"))\n\t\treturn 1;\n\thsync_end--;\n\tif (check_overflow(hsync_end, HSYNCEND_MASK, \"CRTC hsync_end\"))\n\t\treturn 1;\n\thtotal--;\n\tif (check_overflow(htotal, HTOTAL_MASK, \"CRTC htotal\"))\n\t\treturn 1;\n\thblank_start--;\n\tif (check_overflow(hblank_start, HBLANKSTART_MASK, \"CRTC hblank_start\"))\n\t\treturn 1;\n\thblank_end--;\n\tif (check_overflow(hblank_end, HBLANKEND_MASK, \"CRTC hblank_end\"))\n\t\treturn 1;\n\n\tvactive--;\n\tif (check_overflow(vactive, VACTIVE_MASK, \"CRTC vactive\"))\n\t\treturn 1;\n\tvsync_start--;\n\tif (check_overflow(vsync_start, VSYNCSTART_MASK, \"CRTC vsync_start\"))\n\t\treturn 1;\n\tvsync_end--;\n\tif (check_overflow(vsync_end, VSYNCEND_MASK, \"CRTC vsync_end\"))\n\t\treturn 1;\n\tvtotal--;\n\tif (check_overflow(vtotal, VTOTAL_MASK, \"CRTC vtotal\"))\n\t\treturn 1;\n\tvblank_start--;\n\tif (check_overflow(vblank_start, VBLANKSTART_MASK, \"CRTC vblank_start\"))\n\t\treturn 1;\n\tvblank_end--;\n\tif (check_overflow(vblank_end, VBLANKEND_MASK, \"CRTC vblank_end\"))\n\t\treturn 1;\n\n\t*ht = (htotal << HTOTAL_SHIFT) | (hactive << HACTIVE_SHIFT);\n\t*hb = (hblank_start << HBLANKSTART_SHIFT) |\n\t      (hblank_end << HSYNCEND_SHIFT);\n\t*hs = (hsync_start << HSYNCSTART_SHIFT) | (hsync_end << HSYNCEND_SHIFT);\n\n\t*vt = (vtotal << VTOTAL_SHIFT) | (vactive << VACTIVE_SHIFT);\n\t*vb = (vblank_start << VBLANKSTART_SHIFT) |\n\t      (vblank_end << VSYNCEND_SHIFT);\n\t*vs = (vsync_start << VSYNCSTART_SHIFT) | (vsync_end << VSYNCEND_SHIFT);\n\t*ss = (hactive << SRC_SIZE_HORIZ_SHIFT) |\n\t      (vactive << SRC_SIZE_VERT_SHIFT);\n\n\thw->disp_a_stride = dinfo->pitch;\n\tDBG_MSG(\"pitch is %d\\n\", hw->disp_a_stride);\n\n\thw->disp_a_base = hw->disp_a_stride * var->yoffset +\n\t\t\t  var->xoffset * var->bits_per_pixel / 8;\n\n\thw->disp_a_base += dinfo->fb.offset << 12;\n\n\t \n\tstride_alignment = IS_I9XX(dinfo) ? STRIDE_ALIGNMENT_I9XX :\n\t\t\t\t\t    STRIDE_ALIGNMENT;\n\tif (hw->disp_a_stride % stride_alignment != 0) {\n\t\tWRN_MSG(\"display stride %d has bad alignment %d\\n\",\n\t\t\thw->disp_a_stride, stride_alignment);\n\t\treturn 1;\n\t}\n\n\t \n\t*pipe_conf &= ~PIPECONF_GAMMA;\n\n\tif (var->vmode & FB_VMODE_INTERLACED)\n\t\t*pipe_conf |= PIPECONF_INTERLACE_W_FIELD_INDICATION;\n\telse\n\t\t*pipe_conf &= ~PIPECONF_INTERLACE_MASK;\n\n\treturn 0;\n}\n\n \nint intelfbhw_program_mode(struct intelfb_info *dinfo,\n\t\t\t   const struct intelfb_hwstate *hw, int blank)\n{\n\tu32 tmp;\n\tconst u32 *dpll, *fp0, *fp1, *pipe_conf;\n\tconst u32 *hs, *ht, *hb, *vs, *vt, *vb, *ss;\n\tu32 dpll_reg, fp0_reg, fp1_reg, pipe_conf_reg, pipe_stat_reg;\n\tu32 hsync_reg, htotal_reg, hblank_reg;\n\tu32 vsync_reg, vtotal_reg, vblank_reg;\n\tu32 src_size_reg;\n\tu32 count, tmp_val[3];\n\n\t \n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_program_mode\\n\");\n#endif\n\n\t \n\ttmp = INREG(VGACNTRL);\n\ttmp |= VGA_DISABLE;\n\tOUTREG(VGACNTRL, tmp);\n\n\tdinfo->pipe = intelfbhw_active_pipe(hw);\n\n\tif (dinfo->pipe == PIPE_B) {\n\t\tdpll = &hw->dpll_b;\n\t\tfp0 = &hw->fpb0;\n\t\tfp1 = &hw->fpb1;\n\t\tpipe_conf = &hw->pipe_b_conf;\n\t\ths = &hw->hsync_b;\n\t\thb = &hw->hblank_b;\n\t\tht = &hw->htotal_b;\n\t\tvs = &hw->vsync_b;\n\t\tvb = &hw->vblank_b;\n\t\tvt = &hw->vtotal_b;\n\t\tss = &hw->src_size_b;\n\t\tdpll_reg = DPLL_B;\n\t\tfp0_reg = FPB0;\n\t\tfp1_reg = FPB1;\n\t\tpipe_conf_reg = PIPEBCONF;\n\t\tpipe_stat_reg = PIPEBSTAT;\n\t\thsync_reg = HSYNC_B;\n\t\thtotal_reg = HTOTAL_B;\n\t\thblank_reg = HBLANK_B;\n\t\tvsync_reg = VSYNC_B;\n\t\tvtotal_reg = VTOTAL_B;\n\t\tvblank_reg = VBLANK_B;\n\t\tsrc_size_reg = SRC_SIZE_B;\n\t} else {\n\t\tdpll = &hw->dpll_a;\n\t\tfp0 = &hw->fpa0;\n\t\tfp1 = &hw->fpa1;\n\t\tpipe_conf = &hw->pipe_a_conf;\n\t\ths = &hw->hsync_a;\n\t\thb = &hw->hblank_a;\n\t\tht = &hw->htotal_a;\n\t\tvs = &hw->vsync_a;\n\t\tvb = &hw->vblank_a;\n\t\tvt = &hw->vtotal_a;\n\t\tss = &hw->src_size_a;\n\t\tdpll_reg = DPLL_A;\n\t\tfp0_reg = FPA0;\n\t\tfp1_reg = FPA1;\n\t\tpipe_conf_reg = PIPEACONF;\n\t\tpipe_stat_reg = PIPEASTAT;\n\t\thsync_reg = HSYNC_A;\n\t\thtotal_reg = HTOTAL_A;\n\t\thblank_reg = HBLANK_A;\n\t\tvsync_reg = VSYNC_A;\n\t\tvtotal_reg = VTOTAL_A;\n\t\tvblank_reg = VBLANK_A;\n\t\tsrc_size_reg = SRC_SIZE_A;\n\t}\n\n\t \n\ttmp = INREG(pipe_conf_reg);\n\ttmp &= ~PIPECONF_ENABLE;\n\tOUTREG(pipe_conf_reg, tmp);\n\n\tcount = 0;\n\tdo {\n\t\ttmp_val[count % 3] = INREG(PIPEA_DSL);\n\t\tif ((tmp_val[0] == tmp_val[1]) && (tmp_val[1] == tmp_val[2]))\n\t\t\tbreak;\n\t\tcount++;\n\t\tudelay(1);\n\t\tif (count % 200 == 0) {\n\t\t\ttmp = INREG(pipe_conf_reg);\n\t\t\ttmp &= ~PIPECONF_ENABLE;\n\t\t\tOUTREG(pipe_conf_reg, tmp);\n\t\t}\n\t} while (count < 2000);\n\n\tOUTREG(ADPA, INREG(ADPA) & ~ADPA_DAC_ENABLE);\n\n\t \n\ttmp = INREG(DSPACNTR);\n\ttmp &= ~DISPPLANE_PLANE_ENABLE;\n\tOUTREG(DSPACNTR, tmp);\n\ttmp = INREG(DSPBCNTR);\n\ttmp &= ~DISPPLANE_PLANE_ENABLE;\n\tOUTREG(DSPBCNTR, tmp);\n\n\t \n\tmdelay(20);\n\n\tOUTREG(DVOB, INREG(DVOB) & ~PORT_ENABLE);\n\tOUTREG(DVOC, INREG(DVOC) & ~PORT_ENABLE);\n\tOUTREG(ADPA, INREG(ADPA) & ~ADPA_DAC_ENABLE);\n\n\t \n\ttmp = INREG(ADPA);\n\ttmp &= ~ADPA_DPMS_CONTROL_MASK;\n\ttmp |= ADPA_DPMS_D3;\n\tOUTREG(ADPA, tmp);\n\n\t \n\tOUTREG(0x61204, 0xabcd0000);\n\n\t \n\ttmp = INREG(dpll_reg);\n\ttmp &= ~DPLL_VCO_ENABLE;\n\tOUTREG(dpll_reg, tmp);\n\n\t \n\tOUTREG(fp0_reg, *fp0);\n\tOUTREG(fp1_reg, *fp1);\n\n\t \n\tOUTREG(dpll_reg, *dpll);\n\n\t \n\tOUTREG(DVOB, hw->dvob);\n\tOUTREG(DVOC, hw->dvoc);\n\n\t \n\tOUTREG(0x61204, 0x00000000);\n\n\t \n\tOUTREG(ADPA, INREG(ADPA) | ADPA_DAC_ENABLE);\n\tOUTREG(ADPA, (hw->adpa & ~(ADPA_DPMS_CONTROL_MASK)) | ADPA_DPMS_D3);\n\n\t \n\tOUTREG(hsync_reg, *hs);\n\tOUTREG(hblank_reg, *hb);\n\tOUTREG(htotal_reg, *ht);\n\tOUTREG(vsync_reg, *vs);\n\tOUTREG(vblank_reg, *vb);\n\tOUTREG(vtotal_reg, *vt);\n\tOUTREG(src_size_reg, *ss);\n\n\tswitch (dinfo->info->var.vmode & (FB_VMODE_INTERLACED |\n\t\t\t\t\t  FB_VMODE_ODD_FLD_FIRST)) {\n\tcase FB_VMODE_INTERLACED | FB_VMODE_ODD_FLD_FIRST:\n\t\tOUTREG(pipe_stat_reg, 0xFFFF | PIPESTAT_FLD_EVT_ODD_EN);\n\t\tbreak;\n\tcase FB_VMODE_INTERLACED:  \n\t\tOUTREG(pipe_stat_reg, 0xFFFF | PIPESTAT_FLD_EVT_EVEN_EN);\n\t\tbreak;\n\tdefault:\t\t \n\t\tOUTREG(pipe_stat_reg, 0xFFFF);  \n\t}\n\t \n\tOUTREG(pipe_conf_reg, *pipe_conf | PIPECONF_ENABLE);\n\n\t \n\ttmp = INREG(ADPA);\n\ttmp &= ~ADPA_DPMS_CONTROL_MASK;\n\ttmp |= ADPA_DPMS_D0;\n\tOUTREG(ADPA, tmp);\n\n\t \n\tif (dinfo->pdev->device == PCI_DEVICE_ID_INTEL_830M) {\n\t\t \n\t\ttmp = INREG(DSPACNTR);\n\t\tif ((tmp & DISPPLANE_PLANE_ENABLE) != DISPPLANE_PLANE_ENABLE) {\n\t\t\ttmp |= DISPPLANE_PLANE_ENABLE;\n\t\t\tOUTREG(DSPACNTR, tmp);\n\t\t\tOUTREG(DSPACNTR,\n\t\t\t       hw->disp_a_ctrl|DISPPLANE_PLANE_ENABLE);\n\t\t\tmdelay(1);\n\t\t}\n\t}\n\n\tOUTREG(DSPACNTR, hw->disp_a_ctrl & ~DISPPLANE_PLANE_ENABLE);\n\tOUTREG(DSPASTRIDE, hw->disp_a_stride);\n\tOUTREG(DSPABASE, hw->disp_a_base);\n\n\t \n\tif (!blank) {\n\t\ttmp = INREG(DSPACNTR);\n\t\ttmp |= DISPPLANE_PLANE_ENABLE;\n\t\tOUTREG(DSPACNTR, tmp);\n\t\tOUTREG(DSPABASE, hw->disp_a_base);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void refresh_ring(struct intelfb_info *dinfo);\nstatic void reset_state(struct intelfb_info *dinfo);\nstatic void do_flush(struct intelfb_info *dinfo);\n\nstatic  u32 get_ring_space(struct intelfb_info *dinfo)\n{\n\tu32 ring_space;\n\n\tif (dinfo->ring_tail >= dinfo->ring_head)\n\t\tring_space = dinfo->ring.size -\n\t\t\t(dinfo->ring_tail - dinfo->ring_head);\n\telse\n\t\tring_space = dinfo->ring_head - dinfo->ring_tail;\n\n\tif (ring_space > RING_MIN_FREE)\n\t\tring_space -= RING_MIN_FREE;\n\telse\n\t\tring_space = 0;\n\n\treturn ring_space;\n}\n\nstatic int wait_ring(struct intelfb_info *dinfo, int n)\n{\n\tint i = 0;\n\tunsigned long end;\n\tu32 last_head = INREG(PRI_RING_HEAD) & RING_HEAD_MASK;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"wait_ring: %d\\n\", n);\n#endif\n\n\tend = jiffies + (HZ * 3);\n\twhile (dinfo->ring_space < n) {\n\t\tdinfo->ring_head = INREG(PRI_RING_HEAD) & RING_HEAD_MASK;\n\t\tdinfo->ring_space = get_ring_space(dinfo);\n\n\t\tif (dinfo->ring_head != last_head) {\n\t\t\tend = jiffies + (HZ * 3);\n\t\t\tlast_head = dinfo->ring_head;\n\t\t}\n\t\ti++;\n\t\tif (time_before(end, jiffies)) {\n\t\t\tif (!i) {\n\t\t\t\t \n\t\t\t\treset_state(dinfo);\n\t\t\t\trefresh_ring(dinfo);\n\t\t\t\tdo_flush(dinfo);\n\t\t\t\tend = jiffies + (HZ * 3);\n\t\t\t\ti = 1;\n\t\t\t} else {\n\t\t\t\tWRN_MSG(\"ring buffer : space: %d wanted %d\\n\",\n\t\t\t\t\tdinfo->ring_space, n);\n\t\t\t\tWRN_MSG(\"lockup - turning off hardware \"\n\t\t\t\t\t\"acceleration\\n\");\n\t\t\t\tdinfo->ring_lockup = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn i;\n}\n\nstatic void do_flush(struct intelfb_info *dinfo)\n{\n\tSTART_RING(2);\n\tOUT_RING(MI_FLUSH | MI_WRITE_DIRTY_STATE | MI_INVALIDATE_MAP_CACHE);\n\tOUT_RING(MI_NOOP);\n\tADVANCE_RING();\n}\n\nvoid intelfbhw_do_sync(struct intelfb_info *dinfo)\n{\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_do_sync\\n\");\n#endif\n\n\tif (!dinfo->accel)\n\t\treturn;\n\n\t \n\tdo_flush(dinfo);\n\twait_ring(dinfo, dinfo->ring.size - RING_MIN_FREE);\n\tdinfo->ring_space = dinfo->ring.size - RING_MIN_FREE;\n}\n\nstatic void refresh_ring(struct intelfb_info *dinfo)\n{\n#if VERBOSE > 0\n\tDBG_MSG(\"refresh_ring\\n\");\n#endif\n\n\tdinfo->ring_head = INREG(PRI_RING_HEAD) & RING_HEAD_MASK;\n\tdinfo->ring_tail = INREG(PRI_RING_TAIL) & RING_TAIL_MASK;\n\tdinfo->ring_space = get_ring_space(dinfo);\n}\n\nstatic void reset_state(struct intelfb_info *dinfo)\n{\n\tint i;\n\tu32 tmp;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"reset_state\\n\");\n#endif\n\n\tfor (i = 0; i < FENCE_NUM; i++)\n\t\tOUTREG(FENCE + (i << 2), 0);\n\n\t \n\ttmp = INREG(PRI_RING_LENGTH);\n\tif (tmp & RING_ENABLE) {\n#if VERBOSE > 0\n\t\tDBG_MSG(\"reset_state: ring was enabled\\n\");\n#endif\n\t\trefresh_ring(dinfo);\n\t\tintelfbhw_do_sync(dinfo);\n\t\tDO_RING_IDLE();\n\t}\n\n\tOUTREG(PRI_RING_LENGTH, 0);\n\tOUTREG(PRI_RING_HEAD, 0);\n\tOUTREG(PRI_RING_TAIL, 0);\n\tOUTREG(PRI_RING_START, 0);\n}\n\n \nvoid intelfbhw_2d_stop(struct intelfb_info *dinfo)\n{\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_2d_stop: accel: %d, ring_active: %d\\n\",\n\t\tdinfo->accel, dinfo->ring_active);\n#endif\n\n\tif (!dinfo->accel)\n\t\treturn;\n\n\tdinfo->ring_active = 0;\n\treset_state(dinfo);\n}\n\n \nvoid intelfbhw_2d_start(struct intelfb_info *dinfo)\n{\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_2d_start: accel: %d, ring_active: %d\\n\",\n\t\tdinfo->accel, dinfo->ring_active);\n#endif\n\n\tif (!dinfo->accel)\n\t\treturn;\n\n\t \n\tOUTREG(PRI_RING_LENGTH, 0);\n\tOUTREG(PRI_RING_TAIL, 0);\n\tOUTREG(PRI_RING_HEAD, 0);\n\n\tOUTREG(PRI_RING_START, dinfo->ring.physical & RING_START_MASK);\n\tOUTREG(PRI_RING_LENGTH,\n\t\t((dinfo->ring.size - GTT_PAGE_SIZE) & RING_LENGTH_MASK) |\n\t\tRING_NO_REPORT | RING_ENABLE);\n\trefresh_ring(dinfo);\n\tdinfo->ring_active = 1;\n}\n\n \nvoid intelfbhw_do_fillrect(struct intelfb_info *dinfo, u32 x, u32 y, u32 w,\n\t\t\t   u32 h, u32 color, u32 pitch, u32 bpp, u32 rop)\n{\n\tu32 br00, br09, br13, br14, br16;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_do_fillrect: (%d,%d) %dx%d, c 0x%06x, p %d bpp %d, \"\n\t\t\"rop 0x%02x\\n\", x, y, w, h, color, pitch, bpp, rop);\n#endif\n\n\tbr00 = COLOR_BLT_CMD;\n\tbr09 = dinfo->fb_start + (y * pitch + x * (bpp / 8));\n\tbr13 = (rop << ROP_SHIFT) | pitch;\n\tbr14 = (h << HEIGHT_SHIFT) | ((w * (bpp / 8)) << WIDTH_SHIFT);\n\tbr16 = color;\n\n\tswitch (bpp) {\n\tcase 8:\n\t\tbr13 |= COLOR_DEPTH_8;\n\t\tbreak;\n\tcase 16:\n\t\tbr13 |= COLOR_DEPTH_16;\n\t\tbreak;\n\tcase 32:\n\t\tbr13 |= COLOR_DEPTH_32;\n\t\tbr00 |= WRITE_ALPHA | WRITE_RGB;\n\t\tbreak;\n\t}\n\n\tSTART_RING(6);\n\tOUT_RING(br00);\n\tOUT_RING(br13);\n\tOUT_RING(br14);\n\tOUT_RING(br09);\n\tOUT_RING(br16);\n\tOUT_RING(MI_NOOP);\n\tADVANCE_RING();\n\n#if VERBOSE > 0\n\tDBG_MSG(\"ring = 0x%08x, 0x%08x (%d)\\n\", dinfo->ring_head,\n\t\tdinfo->ring_tail, dinfo->ring_space);\n#endif\n}\n\nvoid\nintelfbhw_do_bitblt(struct intelfb_info *dinfo, u32 curx, u32 cury,\n\t\t    u32 dstx, u32 dsty, u32 w, u32 h, u32 pitch, u32 bpp)\n{\n\tu32 br00, br09, br11, br12, br13, br22, br23, br26;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_do_bitblt: (%d,%d)->(%d,%d) %dx%d, p %d bpp %d\\n\",\n\t\tcurx, cury, dstx, dsty, w, h, pitch, bpp);\n#endif\n\n\tbr00 = XY_SRC_COPY_BLT_CMD;\n\tbr09 = dinfo->fb_start;\n\tbr11 = (pitch << PITCH_SHIFT);\n\tbr12 = dinfo->fb_start;\n\tbr13 = (SRC_ROP_GXCOPY << ROP_SHIFT) | (pitch << PITCH_SHIFT);\n\tbr22 = (dstx << WIDTH_SHIFT) | (dsty << HEIGHT_SHIFT);\n\tbr23 = ((dstx + w) << WIDTH_SHIFT) |\n\t       ((dsty + h) << HEIGHT_SHIFT);\n\tbr26 = (curx << WIDTH_SHIFT) | (cury << HEIGHT_SHIFT);\n\n\tswitch (bpp) {\n\tcase 8:\n\t\tbr13 |= COLOR_DEPTH_8;\n\t\tbreak;\n\tcase 16:\n\t\tbr13 |= COLOR_DEPTH_16;\n\t\tbreak;\n\tcase 32:\n\t\tbr13 |= COLOR_DEPTH_32;\n\t\tbr00 |= WRITE_ALPHA | WRITE_RGB;\n\t\tbreak;\n\t}\n\n\tSTART_RING(8);\n\tOUT_RING(br00);\n\tOUT_RING(br13);\n\tOUT_RING(br22);\n\tOUT_RING(br23);\n\tOUT_RING(br09);\n\tOUT_RING(br26);\n\tOUT_RING(br11);\n\tOUT_RING(br12);\n\tADVANCE_RING();\n}\n\nint intelfbhw_do_drawglyph(struct intelfb_info *dinfo, u32 fg, u32 bg, u32 w,\n\t\t\t   u32 h, const u8* cdat, u32 x, u32 y, u32 pitch,\n\t\t\t   u32 bpp)\n{\n\tint nbytes, ndwords, pad, tmp;\n\tu32 br00, br09, br13, br18, br19, br22, br23;\n\tint dat, ix, iy, iw;\n\tint i, j;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_do_drawglyph: (%d,%d) %dx%d\\n\", x, y, w, h);\n#endif\n\n\t \n\tnbytes = ROUND_UP_TO(w, 16) / 8;\n\n\t \n\tnbytes = nbytes * h;\n\n\t \n\tif (nbytes > MAX_MONO_IMM_SIZE)\n\t\treturn 0;\n\n\t \n\tndwords = ROUND_UP_TO(nbytes, 4) / 4;\n\n\t \n\tpad = !(ndwords % 2);\n\n\ttmp = (XY_MONO_SRC_IMM_BLT_CMD & DW_LENGTH_MASK) + ndwords;\n\tbr00 = (XY_MONO_SRC_IMM_BLT_CMD & ~DW_LENGTH_MASK) | tmp;\n\tbr09 = dinfo->fb_start;\n\tbr13 = (SRC_ROP_GXCOPY << ROP_SHIFT) | (pitch << PITCH_SHIFT);\n\tbr18 = bg;\n\tbr19 = fg;\n\tbr22 = (x << WIDTH_SHIFT) | (y << HEIGHT_SHIFT);\n\tbr23 = ((x + w) << WIDTH_SHIFT) | ((y + h) << HEIGHT_SHIFT);\n\n\tswitch (bpp) {\n\tcase 8:\n\t\tbr13 |= COLOR_DEPTH_8;\n\t\tbreak;\n\tcase 16:\n\t\tbr13 |= COLOR_DEPTH_16;\n\t\tbreak;\n\tcase 32:\n\t\tbr13 |= COLOR_DEPTH_32;\n\t\tbr00 |= WRITE_ALPHA | WRITE_RGB;\n\t\tbreak;\n\t}\n\n\tSTART_RING(8 + ndwords);\n\tOUT_RING(br00);\n\tOUT_RING(br13);\n\tOUT_RING(br22);\n\tOUT_RING(br23);\n\tOUT_RING(br09);\n\tOUT_RING(br18);\n\tOUT_RING(br19);\n\tix = iy = 0;\n\tiw = ROUND_UP_TO(w, 8) / 8;\n\twhile (ndwords--) {\n\t\tdat = 0;\n\t\tfor (j = 0; j < 2; ++j) {\n\t\t\tfor (i = 0; i < 2; ++i) {\n\t\t\t\tif (ix != iw || i == 0)\n\t\t\t\t\tdat |= cdat[iy*iw + ix++] << (i+j*2)*8;\n\t\t\t}\n\t\t\tif (ix == iw && iy != (h-1)) {\n\t\t\t\tix = 0;\n\t\t\t\t++iy;\n\t\t\t}\n\t\t}\n\t\tOUT_RING(dat);\n\t}\n\tif (pad)\n\t\tOUT_RING(MI_NOOP);\n\tADVANCE_RING();\n\n\treturn 1;\n}\n\n \nvoid intelfbhw_cursor_init(struct intelfb_info *dinfo)\n{\n\tu32 tmp;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_cursor_init\\n\");\n#endif\n\n\tif (dinfo->mobile || IS_I9XX(dinfo)) {\n\t\tif (!dinfo->cursor.physical)\n\t\t\treturn;\n\t\ttmp = INREG(CURSOR_A_CONTROL);\n\t\ttmp &= ~(CURSOR_MODE_MASK | CURSOR_MOBILE_GAMMA_ENABLE |\n\t\t\t CURSOR_MEM_TYPE_LOCAL |\n\t\t\t (1 << CURSOR_PIPE_SELECT_SHIFT));\n\t\ttmp |= CURSOR_MODE_DISABLE;\n\t\tOUTREG(CURSOR_A_CONTROL, tmp);\n\t\tOUTREG(CURSOR_A_BASEADDR, dinfo->cursor.physical);\n\t} else {\n\t\ttmp = INREG(CURSOR_CONTROL);\n\t\ttmp &= ~(CURSOR_FORMAT_MASK | CURSOR_GAMMA_ENABLE |\n\t\t\t CURSOR_ENABLE | CURSOR_STRIDE_MASK);\n\t\ttmp |= CURSOR_FORMAT_3C;\n\t\tOUTREG(CURSOR_CONTROL, tmp);\n\t\tOUTREG(CURSOR_A_BASEADDR, dinfo->cursor.offset << 12);\n\t\ttmp = (64 << CURSOR_SIZE_H_SHIFT) |\n\t\t      (64 << CURSOR_SIZE_V_SHIFT);\n\t\tOUTREG(CURSOR_SIZE, tmp);\n\t}\n}\n\nvoid intelfbhw_cursor_hide(struct intelfb_info *dinfo)\n{\n\tu32 tmp;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_cursor_hide\\n\");\n#endif\n\n\tdinfo->cursor_on = 0;\n\tif (dinfo->mobile || IS_I9XX(dinfo)) {\n\t\tif (!dinfo->cursor.physical)\n\t\t\treturn;\n\t\ttmp = INREG(CURSOR_A_CONTROL);\n\t\ttmp &= ~CURSOR_MODE_MASK;\n\t\ttmp |= CURSOR_MODE_DISABLE;\n\t\tOUTREG(CURSOR_A_CONTROL, tmp);\n\t\t \n\t\tOUTREG(CURSOR_A_BASEADDR, dinfo->cursor.physical);\n\t} else {\n\t\ttmp = INREG(CURSOR_CONTROL);\n\t\ttmp &= ~CURSOR_ENABLE;\n\t\tOUTREG(CURSOR_CONTROL, tmp);\n\t}\n}\n\nvoid intelfbhw_cursor_show(struct intelfb_info *dinfo)\n{\n\tu32 tmp;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_cursor_show\\n\");\n#endif\n\n\tdinfo->cursor_on = 1;\n\n\tif (dinfo->cursor_blanked)\n\t\treturn;\n\n\tif (dinfo->mobile || IS_I9XX(dinfo)) {\n\t\tif (!dinfo->cursor.physical)\n\t\t\treturn;\n\t\ttmp = INREG(CURSOR_A_CONTROL);\n\t\ttmp &= ~CURSOR_MODE_MASK;\n\t\ttmp |= CURSOR_MODE_64_4C_AX;\n\t\tOUTREG(CURSOR_A_CONTROL, tmp);\n\t\t \n\t\tOUTREG(CURSOR_A_BASEADDR, dinfo->cursor.physical);\n\t} else {\n\t\ttmp = INREG(CURSOR_CONTROL);\n\t\ttmp |= CURSOR_ENABLE;\n\t\tOUTREG(CURSOR_CONTROL, tmp);\n\t}\n}\n\nvoid intelfbhw_cursor_setpos(struct intelfb_info *dinfo, int x, int y)\n{\n\tu32 tmp;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_cursor_setpos: (%d, %d)\\n\", x, y);\n#endif\n\n\t \n\n\ttmp = ((x & CURSOR_POS_MASK) << CURSOR_X_SHIFT) |\n\t      ((y & CURSOR_POS_MASK) << CURSOR_Y_SHIFT);\n\tOUTREG(CURSOR_A_POSITION, tmp);\n\n\tif (IS_I9XX(dinfo))\n\t\tOUTREG(CURSOR_A_BASEADDR, dinfo->cursor.physical);\n}\n\nvoid intelfbhw_cursor_setcolor(struct intelfb_info *dinfo, u32 bg, u32 fg)\n{\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_cursor_setcolor\\n\");\n#endif\n\n\tOUTREG(CURSOR_A_PALETTE0, bg & CURSOR_PALETTE_MASK);\n\tOUTREG(CURSOR_A_PALETTE1, fg & CURSOR_PALETTE_MASK);\n\tOUTREG(CURSOR_A_PALETTE2, fg & CURSOR_PALETTE_MASK);\n\tOUTREG(CURSOR_A_PALETTE3, bg & CURSOR_PALETTE_MASK);\n}\n\nvoid intelfbhw_cursor_load(struct intelfb_info *dinfo, int width, int height,\n\t\t\t   u8 *data)\n{\n\tu8 __iomem *addr = (u8 __iomem *)dinfo->cursor.virtual;\n\tint i, j, w = width / 8;\n\tint mod = width % 8, t_mask, d_mask;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_cursor_load\\n\");\n#endif\n\n\tif (!dinfo->cursor.virtual)\n\t\treturn;\n\n\tt_mask = 0xff >> mod;\n\td_mask = ~(0xff >> mod);\n\tfor (i = height; i--; ) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\twriteb(0x00, addr + j);\n\t\t\twriteb(*(data++), addr + j+8);\n\t\t}\n\t\tif (mod) {\n\t\t\twriteb(t_mask, addr + j);\n\t\t\twriteb(*(data++) & d_mask, addr + j+8);\n\t\t}\n\t\taddr += 16;\n\t}\n}\n\nvoid intelfbhw_cursor_reset(struct intelfb_info *dinfo)\n{\n\tu8 __iomem *addr = (u8 __iomem *)dinfo->cursor.virtual;\n\tint i, j;\n\n#if VERBOSE > 0\n\tDBG_MSG(\"intelfbhw_cursor_reset\\n\");\n#endif\n\n\tif (!dinfo->cursor.virtual)\n\t\treturn;\n\n\tfor (i = 64; i--; ) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\twriteb(0xff, addr + j+0);\n\t\t\twriteb(0x00, addr + j+8);\n\t\t}\n\t\taddr += 16;\n\t}\n}\n\nstatic irqreturn_t intelfbhw_irq(int irq, void *dev_id)\n{\n\tu16 tmp;\n\tstruct intelfb_info *dinfo = dev_id;\n\n\tspin_lock(&dinfo->int_lock);\n\n\ttmp = INREG16(IIR);\n\tif (dinfo->info->var.vmode & FB_VMODE_INTERLACED)\n\t\ttmp &= PIPE_A_EVENT_INTERRUPT;\n\telse\n\t\ttmp &= VSYNC_PIPE_A_INTERRUPT;  \n\n\tif (tmp == 0) {\n\t\tspin_unlock(&dinfo->int_lock);\n\t\treturn IRQ_RETVAL(0);  \n\t}\n\n\t \n\tOUTREG(PIPEASTAT, INREG(PIPEASTAT));\n\n\tOUTREG16(IIR, tmp);\n\tif (dinfo->vsync.pan_display) {\n\t\tdinfo->vsync.pan_display = 0;\n\t\tOUTREG(DSPABASE, dinfo->vsync.pan_offset);\n\t}\n\n\tdinfo->vsync.count++;\n\twake_up_interruptible(&dinfo->vsync.wait);\n\n\tspin_unlock(&dinfo->int_lock);\n\n\treturn IRQ_RETVAL(1);\n}\n\nint intelfbhw_enable_irq(struct intelfb_info *dinfo)\n{\n\tu16 tmp;\n\tif (!test_and_set_bit(0, &dinfo->irq_flags)) {\n\t\tif (request_irq(dinfo->pdev->irq, intelfbhw_irq, IRQF_SHARED,\n\t\t\t\t\"intelfb\", dinfo)) {\n\t\t\tclear_bit(0, &dinfo->irq_flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tspin_lock_irq(&dinfo->int_lock);\n\t\tOUTREG16(HWSTAM, 0xfffe);  \n\t\tOUTREG16(IMR, 0);\n\t} else\n\t\tspin_lock_irq(&dinfo->int_lock);\n\n\tif (dinfo->info->var.vmode & FB_VMODE_INTERLACED)\n\t\ttmp = PIPE_A_EVENT_INTERRUPT;\n\telse\n\t\ttmp = VSYNC_PIPE_A_INTERRUPT;  \n\tif (tmp != INREG16(IER)) {\n\t\tDBG_MSG(\"changing IER to 0x%X\\n\", tmp);\n\t\tOUTREG16(IER, tmp);\n\t}\n\n\tspin_unlock_irq(&dinfo->int_lock);\n\treturn 0;\n}\n\nvoid intelfbhw_disable_irq(struct intelfb_info *dinfo)\n{\n\tif (test_and_clear_bit(0, &dinfo->irq_flags)) {\n\t\tif (dinfo->vsync.pan_display) {\n\t\t\tdinfo->vsync.pan_display = 0;\n\t\t\tOUTREG(DSPABASE, dinfo->vsync.pan_offset);\n\t\t}\n\t\tspin_lock_irq(&dinfo->int_lock);\n\t\tOUTREG16(HWSTAM, 0xffff);\n\t\tOUTREG16(IMR, 0xffff);\n\t\tOUTREG16(IER, 0x0);\n\n\t\tOUTREG16(IIR, INREG16(IIR));  \n\t\tspin_unlock_irq(&dinfo->int_lock);\n\n\t\tfree_irq(dinfo->pdev->irq, dinfo);\n\t}\n}\n\nint intelfbhw_wait_for_vsync(struct intelfb_info *dinfo, u32 pipe)\n{\n\tstruct intelfb_vsync *vsync;\n\tunsigned int count;\n\tint ret;\n\n\tswitch (pipe) {\n\t\tcase 0:\n\t\t\tvsync = &dinfo->vsync;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t}\n\n\tret = intelfbhw_enable_irq(dinfo);\n\tif (ret)\n\t\treturn ret;\n\n\tcount = vsync->count;\n\tret = wait_event_interruptible_timeout(vsync->wait,\n\t\t\t\t\t       count != vsync->count, HZ / 10);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0) {\n\t\tDBG_MSG(\"wait_for_vsync timed out!\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}