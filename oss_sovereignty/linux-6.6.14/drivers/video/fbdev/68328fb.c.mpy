{
  "module_name": "68328fb.c",
  "hash_id": "9754c0a7c4874c1763410c6f7d09507a7d810fda3e05d3b3dc7bceeae649800e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/68328fb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/uaccess.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n\n#if defined(CONFIG_M68VZ328)\n#include <asm/MC68VZ328.h>\n#elif defined(CONFIG_M68EZ328)\n#include <asm/MC68EZ328.h>\n#elif defined(CONFIG_M68328)\n#include <asm/MC68328.h>\n#else\n#error wrong architecture for the MC68x328 frame buffer device\n#endif\n\nstatic u_long videomemory;\nstatic u_long videomemorysize;\n\nstatic struct fb_info fb_info;\nstatic u32 mc68x328fb_pseudo_palette[16];\n\nstatic struct fb_var_screeninfo mc68x328fb_default __initdata = {\n\t.red =\t\t{ 0, 8, 0 },\n      \t.green =\t{ 0, 8, 0 },\n      \t.blue =\t\t{ 0, 8, 0 },\n      \t.activate =\tFB_ACTIVATE_TEST,\n      \t.height =\t-1,\n      \t.width =\t-1,\n      \t.pixclock =\t20000,\n      \t.left_margin =\t64,\n      \t.right_margin =\t64,\n      \t.upper_margin =\t32,\n      \t.lower_margin =\t32,\n      \t.hsync_len =\t64,\n      \t.vsync_len =\t2,\n      \t.vmode =\tFB_VMODE_NONINTERLACED,\n};\n\nstatic const struct fb_fix_screeninfo mc68x328fb_fix __initconst = {\n\t.id =\t\t\"68328fb\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.xpanstep =\t1,\n\t.ypanstep =\t1,\n\t.ywrapstep =\t1,\n\t.accel =\tFB_ACCEL_NONE,\n};\n\n     \nstatic int mc68x328fb_check_var(struct fb_var_screeninfo *var,\n\t\t\t struct fb_info *info);\nstatic int mc68x328fb_set_par(struct fb_info *info);\nstatic int mc68x328fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t u_int transp, struct fb_info *info);\nstatic int mc68x328fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t   struct fb_info *info);\nstatic int mc68x328fb_mmap(struct fb_info *info, struct vm_area_struct *vma);\n\nstatic const struct fb_ops mc68x328fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= mc68x328fb_check_var,\n\t.fb_set_par\t= mc68x328fb_set_par,\n\t.fb_setcolreg\t= mc68x328fb_setcolreg,\n\t.fb_pan_display\t= mc68x328fb_pan_display,\n\t.fb_fillrect\t= cfb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n\t.fb_mmap\t= mc68x328fb_mmap,\n};\n\n     \n\nstatic u_long get_line_length(int xres_virtual, int bpp)\n{\n\tu_long length;\n\n\tlength = xres_virtual * bpp;\n\tlength = (length + 31) & ~31;\n\tlength >>= 3;\n\treturn (length);\n}\n\n     \n\nstatic int mc68x328fb_check_var(struct fb_var_screeninfo *var,\n\t\t\t struct fb_info *info)\n{\n\tu_long line_length;\n\n\t \n\n\tif (var->vmode & FB_VMODE_CONUPDATE) {\n\t\tvar->vmode |= FB_VMODE_YWRAP;\n\t\tvar->xoffset = info->var.xoffset;\n\t\tvar->yoffset = info->var.yoffset;\n\t}\n\n\t \n\tif (!var->xres)\n\t\tvar->xres = 1;\n\tif (!var->yres)\n\t\tvar->yres = 1;\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\tif (var->bits_per_pixel <= 1)\n\t\tvar->bits_per_pixel = 1;\n\telse if (var->bits_per_pixel <= 8)\n\t\tvar->bits_per_pixel = 8;\n\telse if (var->bits_per_pixel <= 16)\n\t\tvar->bits_per_pixel = 16;\n\telse if (var->bits_per_pixel <= 24)\n\t\tvar->bits_per_pixel = 24;\n\telse if (var->bits_per_pixel <= 32)\n\t\tvar->bits_per_pixel = 32;\n\telse\n\t\treturn -EINVAL;\n\n\tif (var->xres_virtual < var->xoffset + var->xres)\n\t\tvar->xres_virtual = var->xoffset + var->xres;\n\tif (var->yres_virtual < var->yoffset + var->yres)\n\t\tvar->yres_virtual = var->yoffset + var->yres;\n\n\t \n\tline_length =\n\t    get_line_length(var->xres_virtual, var->bits_per_pixel);\n\tif (line_length * var->yres_virtual > videomemorysize)\n\t\treturn -ENOMEM;\n\n\t \n\tswitch (var->bits_per_pixel) {\n\tcase 1:\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 1;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 1;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 1;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 8:\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 16:\t\t \n\t\tif (var->transp.length) {\n\t\t\tvar->red.offset = 0;\n\t\t\tvar->red.length = 5;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->green.length = 5;\n\t\t\tvar->blue.offset = 10;\n\t\t\tvar->blue.length = 5;\n\t\t\tvar->transp.offset = 15;\n\t\t\tvar->transp.length = 1;\n\t\t} else {\t \n\t\t\tvar->red.offset = 0;\n\t\t\tvar->red.length = 5;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->green.length = 6;\n\t\t\tvar->blue.offset = 11;\n\t\t\tvar->blue.length = 5;\n\t\t\tvar->transp.offset = 0;\n\t\t\tvar->transp.length = 0;\n\t\t}\n\t\tbreak;\n\tcase 24:\t\t \n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 16;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 32:\t\t \n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 16;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tbreak;\n\t}\n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.msb_right = 0;\n\tvar->transp.msb_right = 0;\n\n\treturn 0;\n}\n\n \nstatic int mc68x328fb_set_par(struct fb_info *info)\n{\n\tinfo->fix.line_length = get_line_length(info->var.xres_virtual,\n\t\t\t\t\t\tinfo->var.bits_per_pixel);\n\treturn 0;\n}\n\n     \n\nstatic int mc68x328fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t u_int transp, struct fb_info *info)\n{\n\tif (regno >= 256)\t \n\t\treturn 1;\n\t \n\n\t \n\tif (info->var.grayscale) {\n\t\t \n\t\tred = green = blue =\n\t\t    (red * 77 + green * 151 + blue * 28) >> 8;\n\t}\n\n\t \n#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tred = CNVT_TOHW(red, info->var.red.length);\n\t\tgreen = CNVT_TOHW(green, info->var.green.length);\n\t\tblue = CNVT_TOHW(blue, info->var.blue.length);\n\t\ttransp = CNVT_TOHW(transp, info->var.transp.length);\n\t\tbreak;\n\tcase FB_VISUAL_DIRECTCOLOR:\n\t\tred = CNVT_TOHW(red, 8);\t \n\t\tgreen = CNVT_TOHW(green, 8);\n\t\tblue = CNVT_TOHW(blue, 8);\n\t\t \n\t\ttransp = CNVT_TOHW(transp, 8);\n\t\tbreak;\n\t}\n#undef CNVT_TOHW\n\t \n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\tu32 v;\n\n\t\tif (regno >= 16)\n\t\t\treturn 1;\n\n\t\tv = (red << info->var.red.offset) |\n\t\t    (green << info->var.green.offset) |\n\t\t    (blue << info->var.blue.offset) |\n\t\t    (transp << info->var.transp.offset);\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 8:\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\t((u32 *) (info->pseudo_palette))[regno] = v;\n\t\t\tbreak;\n\t\tcase 24:\n\t\tcase 32:\n\t\t\t((u32 *) (info->pseudo_palette))[regno] = v;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n     \n\nstatic int mc68x328fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t   struct fb_info *info)\n{\n\tif (var->vmode & FB_VMODE_YWRAP) {\n\t\tif (var->yoffset < 0\n\t\t    || var->yoffset >= info->var.yres_virtual\n\t\t    || var->xoffset)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (var->xoffset + info->var.xres > info->var.xres_virtual ||\n\t\t    var->yoffset + info->var.yres > info->var.yres_virtual)\n\t\t\treturn -EINVAL;\n\t}\n\tinfo->var.xoffset = var->xoffset;\n\tinfo->var.yoffset = var->yoffset;\n\tif (var->vmode & FB_VMODE_YWRAP)\n\t\tinfo->var.vmode |= FB_VMODE_YWRAP;\n\telse\n\t\tinfo->var.vmode &= ~FB_VMODE_YWRAP;\n\treturn 0;\n}\n\n     \n\nstatic int mc68x328fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n#ifndef MMU\n\t \n\n\tvm_flags_set(vma, VM_DONTEXPAND | VM_DONTDUMP);\n\tvma->vm_start = videomemory;\n\n\treturn 0;\n#else\n\treturn -EINVAL;\n#endif\n}\n\nstatic int __init mc68x328fb_setup(char *options)\n{\n\tif (!options || !*options)\n\t\treturn 1;\n\treturn 1;\n}\n\n     \n\nstatic int __init mc68x328fb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"68328fb\", &option))\n\t\treturn -ENODEV;\n\tmc68x328fb_setup(option);\n#endif\n\t \n\tmc68x328fb_default.xres = LXMAX;\n\tmc68x328fb_default.yres = LYMAX+1;\n\tmc68x328fb_default.xres_virtual = mc68x328fb_default.xres;\n\tmc68x328fb_default.yres_virtual = mc68x328fb_default.yres;\n\tmc68x328fb_default.bits_per_pixel = 1 + (LPICF & 0x01);\n\tvideomemory = LSSA;\n\tvideomemorysize = (mc68x328fb_default.xres_virtual+7) / 8 *\n\t\tmc68x328fb_default.yres_virtual * mc68x328fb_default.bits_per_pixel;\n\n\tfb_info.screen_base = (void *)videomemory;\n\tfb_info.fbops = &mc68x328fb_ops;\n\tfb_info.var = mc68x328fb_default;\n\tfb_info.fix = mc68x328fb_fix;\n\tfb_info.fix.smem_start = videomemory;\n\tfb_info.fix.smem_len = videomemorysize;\n\tfb_info.fix.line_length =\n\t\tget_line_length(mc68x328fb_default.xres_virtual, mc68x328fb_default.bits_per_pixel);\n\tfb_info.fix.visual = (mc68x328fb_default.bits_per_pixel) == 1 ?\n\t\tFB_VISUAL_MONO10 : FB_VISUAL_PSEUDOCOLOR;\n\tif (fb_info.var.bits_per_pixel == 1) {\n\t\tfb_info.var.red.length = fb_info.var.green.length = fb_info.var.blue.length = 1;\n\t\tfb_info.var.red.offset = fb_info.var.green.offset = fb_info.var.blue.offset = 0;\n\t}\n\tfb_info.pseudo_palette = &mc68x328fb_pseudo_palette;\n\tfb_info.flags = FBINFO_HWACCEL_YPAN;\n\n\tif (fb_alloc_cmap(&fb_info.cmap, 256, 0))\n\t\treturn -ENOMEM;\n\n\tif (register_framebuffer(&fb_info) < 0) {\n\t\tfb_dealloc_cmap(&fb_info.cmap);\n\t\treturn -EINVAL;\n\t}\n\n\tfb_info(&fb_info, \"%s frame buffer device\\n\", fb_info.fix.id);\n\tfb_info(&fb_info, \"%dx%dx%d at 0x%08lx\\n\",\n\t\tmc68x328fb_default.xres_virtual,\n\t\tmc68x328fb_default.yres_virtual,\n\t\t1 << mc68x328fb_default.bits_per_pixel, videomemory);\n\n\treturn 0;\n}\n\nmodule_init(mc68x328fb_init);\n\n#ifdef MODULE\n\nstatic void __exit mc68x328fb_cleanup(void)\n{\n\tunregister_framebuffer(&fb_info);\n\tfb_dealloc_cmap(&fb_info.cmap);\n}\n\nmodule_exit(mc68x328fb_cleanup);\n\nMODULE_LICENSE(\"GPL\");\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}