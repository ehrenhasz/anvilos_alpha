{
  "module_name": "arcfb.c",
  "hash_id": "b5475e4b435eda4d56922497d0c3484bdac7c1a5e033ad2c394dee4a00a104c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/arcfb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/arcfb.h>\n#include <linux/platform_device.h>\n\n#include <linux/uaccess.h>\n\n#define floor8(a) (a&(~0x07))\n#define floorXres(a,xres) (a&(~(xres - 1)))\n#define iceil8(a) (((int)((a+7)/8))*8)\n#define ceil64(a) (a|0x3F)\n#define ceilXres(a,xres) (a|(xres - 1))\n\n \n\n#define KS_SET_DPY_START_LINE \t0xC0\n#define KS_SET_PAGE_NUM \t0xB8\n#define KS_SET_X \t\t0x40\n#define KS_CEHI \t\t0x01\n#define KS_CELO \t\t0x00\n#define KS_SEL_CMD \t\t0x08\n#define KS_SEL_DATA \t\t0x00\n#define KS_DPY_ON \t\t0x3F\n#define KS_DPY_OFF \t\t0x3E\n#define KS_INTACK \t\t0x40\n#define KS_CLRINT\t\t0x02\n\nstruct arcfb_par {\n\tunsigned long dio_addr;\n\tunsigned long cio_addr;\n\tunsigned long c2io_addr;\n\tatomic_t ref_count;\n\tunsigned char cslut[9];\n\tstruct fb_info *info;\n\tunsigned int irq;\n\tspinlock_t lock;\n};\n\nstatic const struct fb_fix_screeninfo arcfb_fix = {\n\t.id =\t\t\"arcfb\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_MONO01,\n\t.xpanstep =\t0,\n\t.ypanstep =\t1,\n\t.ywrapstep =\t0,\n\t.accel =\tFB_ACCEL_NONE,\n};\n\nstatic const struct fb_var_screeninfo arcfb_var = {\n\t.xres\t\t= 128,\n\t.yres\t\t= 64,\n\t.xres_virtual\t= 128,\n\t.yres_virtual\t= 64,\n\t.bits_per_pixel\t= 1,\n\t.nonstd\t\t= 1,\n};\n\nstatic unsigned long num_cols;\nstatic unsigned long num_rows;\nstatic unsigned long dio_addr;\nstatic unsigned long cio_addr;\nstatic unsigned long c2io_addr;\nstatic unsigned long splashval;\nstatic unsigned long tuhold;\nstatic unsigned int nosplash;\nstatic unsigned int arcfb_enable;\nstatic unsigned int irq;\n\nstatic DECLARE_WAIT_QUEUE_HEAD(arcfb_waitq);\n\nstatic void ks108_writeb_ctl(struct arcfb_par *par,\n\t\t\t\tunsigned int chipindex, unsigned char value)\n{\n\tunsigned char chipselval = par->cslut[chipindex];\n\n\toutb(chipselval|KS_CEHI|KS_SEL_CMD, par->cio_addr);\n\toutb(value, par->dio_addr);\n\tudelay(tuhold);\n\toutb(chipselval|KS_CELO|KS_SEL_CMD, par->cio_addr);\n}\n\nstatic void ks108_writeb_mainctl(struct arcfb_par *par, unsigned char value)\n{\n\n\toutb(value, par->cio_addr);\n\tudelay(tuhold);\n}\n\nstatic unsigned char ks108_readb_ctl2(struct arcfb_par *par)\n{\n\treturn inb(par->c2io_addr);\n}\n\nstatic void ks108_writeb_data(struct arcfb_par *par,\n\t\t\t\tunsigned int chipindex, unsigned char value)\n{\n\tunsigned char chipselval = par->cslut[chipindex];\n\n\toutb(chipselval|KS_CEHI|KS_SEL_DATA, par->cio_addr);\n\toutb(value, par->dio_addr);\n\tudelay(tuhold);\n\toutb(chipselval|KS_CELO|KS_SEL_DATA, par->cio_addr);\n}\n\nstatic void ks108_set_start_line(struct arcfb_par *par,\n\t\t\t\tunsigned int chipindex, unsigned char y)\n{\n\tks108_writeb_ctl(par, chipindex, KS_SET_DPY_START_LINE|y);\n}\n\nstatic void ks108_set_yaddr(struct arcfb_par *par,\n\t\t\t\tunsigned int chipindex, unsigned char y)\n{\n\tks108_writeb_ctl(par, chipindex, KS_SET_PAGE_NUM|y);\n}\n\nstatic void ks108_set_xaddr(struct arcfb_par *par,\n\t\t\t\tunsigned int chipindex, unsigned char x)\n{\n\tks108_writeb_ctl(par, chipindex, KS_SET_X|x);\n}\n\nstatic void ks108_clear_lcd(struct arcfb_par *par, unsigned int chipindex)\n{\n\tint i,j;\n\n\tfor (i = 0; i <= 8; i++) {\n\t\tks108_set_yaddr(par, chipindex, i);\n\t\tks108_set_xaddr(par, chipindex, 0);\n\t\tfor (j = 0; j < 64; j++) {\n\t\t\tks108_writeb_data(par, chipindex,\n\t\t\t\t(unsigned char) splashval);\n\t\t}\n\t}\n}\n\n \n\nstatic int arcfb_open(struct fb_info *info, int user)\n{\n\tstruct arcfb_par *par = info->par;\n\n\tatomic_inc(&par->ref_count);\n\treturn 0;\n}\n\nstatic int arcfb_release(struct fb_info *info, int user)\n{\n\tstruct arcfb_par *par = info->par;\n\tint count = atomic_read(&par->ref_count);\n\n\tif (!count)\n\t\treturn -EINVAL;\n\tatomic_dec(&par->ref_count);\n\treturn 0;\n}\n\nstatic int arcfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info)\n{\n\tint i;\n\tstruct arcfb_par *par = info->par;\n\n\tif ((var->vmode & FB_VMODE_YWRAP) && (var->yoffset < 64)\n\t\t&& (info->var.yres <= 64)) {\n\t\tfor (i = 0; i < num_cols; i++) {\n\t\t\tks108_set_start_line(par, i, var->yoffset);\n\t\t}\n\t\tinfo->var.yoffset = var->yoffset;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic irqreturn_t arcfb_interrupt(int vec, void *dev_instance)\n{\n\tstruct fb_info *info = dev_instance;\n\tunsigned char ctl2status;\n\tstruct arcfb_par *par = info->par;\n\n\tctl2status = ks108_readb_ctl2(par);\n\n\tif (!(ctl2status & KS_INTACK))  \n\t\treturn IRQ_NONE;\n\n\tks108_writeb_mainctl(par, KS_CLRINT);\n\n\tspin_lock(&par->lock);\n        if (waitqueue_active(&arcfb_waitq)) {\n                wake_up(&arcfb_waitq);\n        }\n\tspin_unlock(&par->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void arcfb_lcd_update_page(struct arcfb_par *par, unsigned int upper,\n\t\tunsigned int left, unsigned int right, unsigned int distance)\n{\n\tunsigned char *src;\n\tunsigned int xindex, yindex, chipindex, linesize;\n\tint i;\n\tunsigned char val;\n\tunsigned char bitmask, rightshift;\n\n\txindex = left >> 6;\n\tyindex = upper >> 6;\n\tchipindex = (xindex + (yindex*num_cols));\n\n\tks108_set_yaddr(par, chipindex, upper/8);\n\n\tlinesize = par->info->var.xres/8;\n\tsrc = (unsigned char *)par->info->screen_buffer + (left/8) +\n\t\t(upper * linesize);\n\tks108_set_xaddr(par, chipindex, left);\n\n\tbitmask=1;\n\trightshift=0;\n\twhile (left <= right) {\n\t\tval = 0;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif ( i > rightshift) {\n\t\t\t\tval |= (*(src + (i*linesize)) & bitmask)\n\t\t\t\t\t\t<< (i - rightshift);\n\t\t\t} else {\n\t\t\t\tval |= (*(src + (i*linesize)) & bitmask)\n\t\t\t\t\t\t >> (rightshift - i);\n\t\t\t}\n\t\t}\n\t\tks108_writeb_data(par, chipindex, val);\n\t\tleft++;\n\t\tif (bitmask == 0x80) {\n\t\t\tbitmask = 1;\n\t\t\tsrc++;\n\t\t\trightshift=0;\n\t\t} else {\n\t\t\tbitmask <<= 1;\n\t\t\trightshift++;\n\t\t}\n\t}\n}\n\n \nstatic void arcfb_lcd_update_vert(struct arcfb_par *par, unsigned int top,\n\t\tunsigned int bottom, unsigned int left, unsigned int right)\n{\n\tunsigned int distance, upper, lower;\n\n\tdistance = (bottom - top) + 1;\n\tupper = top;\n\tlower = top + 7;\n\n\twhile (distance > 0) {\n\t\tdistance -= 8;\n\t\tarcfb_lcd_update_page(par, upper, left, right, 8);\n\t\tupper = lower + 1;\n\t\tlower = upper + 7;\n\t}\n}\n\n \nstatic void arcfb_lcd_update_horiz(struct arcfb_par *par, unsigned int left,\n\t\t\tunsigned int right, unsigned int top, unsigned int h)\n{\n\tunsigned int distance, upper, lower;\n\n\tdistance = h;\n\tupper = floor8(top);\n\tlower = min(upper + distance - 1, ceil64(upper));\n\n\twhile (distance > 0) {\n\t\tdistance -= ((lower - upper) + 1 );\n\t\tarcfb_lcd_update_vert(par, upper, lower, left, right);\n\t\tupper = lower + 1;\n\t\tlower = min(upper + distance - 1, ceil64(upper));\n\t}\n}\n\n \nstatic void arcfb_lcd_update(struct arcfb_par *par, unsigned int dx,\n\t\t\tunsigned int dy, unsigned int w, unsigned int h)\n{\n\tunsigned int left, right, distance, y;\n\n\t \n\ty = floor8(dy);\n\th += dy - y;\n\th = iceil8(h);\n\n\tdistance = w;\n\tleft = dx;\n\tright = min(left + w - 1, ceil64(left));\n\n\twhile (distance > 0) {\n\t\tarcfb_lcd_update_horiz(par, left, right, y, h);\n\t\tdistance -= ((right - left) + 1);\n\t\tleft = right + 1;\n\t\tright = min(left + distance - 1, ceil64(left));\n\t}\n}\n\nstatic void arcfb_fillrect(struct fb_info *info,\n\t\t\t   const struct fb_fillrect *rect)\n{\n\tstruct arcfb_par *par = info->par;\n\n\tsys_fillrect(info, rect);\n\n\t \n\tarcfb_lcd_update(par, rect->dx, rect->dy, rect->width, rect->height);\n}\n\nstatic void arcfb_copyarea(struct fb_info *info,\n\t\t\t   const struct fb_copyarea *area)\n{\n\tstruct arcfb_par *par = info->par;\n\n\tsys_copyarea(info, area);\n\n\t \n\tarcfb_lcd_update(par, area->dx, area->dy, area->width, area->height);\n}\n\nstatic void arcfb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct arcfb_par *par = info->par;\n\n\tsys_imageblit(info, image);\n\n\t \n\tarcfb_lcd_update(par, image->dx, image->dy, image->width,\n\t\t\t\timage->height);\n}\n\nstatic int arcfb_ioctl(struct fb_info *info,\n\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tstruct arcfb_par *par = info->par;\n\tunsigned long flags;\n\n\tswitch (cmd) {\n\t\tcase FBIO_WAITEVENT:\n\t\t{\n\t\t\tDEFINE_WAIT(wait);\n\t\t\t \n\t\t\tif (!par->irq)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&par->lock, flags);\n\t\t\tprepare_to_wait(&arcfb_waitq, &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irqrestore(&par->lock, flags);\n\t\t\tschedule();\n\t\t\tfinish_wait(&arcfb_waitq, &wait);\n\t\t}\n\t\tfallthrough;\n\n\t\tcase FBIO_GETCONTROL2:\n\t\t{\n\t\t\tunsigned char ctl2;\n\n\t\t\tctl2 = ks108_readb_ctl2(info->par);\n\t\t\tif (copy_to_user(argp, &ctl2, sizeof(ctl2)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic ssize_t arcfb_write(struct fb_info *info, const char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\t \n\n\tunsigned long p;\n\tint err;\n\tunsigned int fbmemlength,x,y,w,h, bitppos, startpos, endpos, bitcount;\n\tstruct arcfb_par *par;\n\tunsigned int xres;\n\n\tif (!info->screen_buffer)\n\t\treturn -ENODEV;\n\n\tp = *ppos;\n\tpar = info->par;\n\txres = info->var.xres;\n\tfbmemlength = (xres * info->var.yres)/8;\n\n\tif (p > fbmemlength)\n\t\treturn -ENOSPC;\n\n\terr = 0;\n\tif ((count + p) > fbmemlength) {\n\t\tcount = fbmemlength - p;\n\t\terr = -ENOSPC;\n\t}\n\n\tif (count) {\n\t\tchar *base_addr;\n\n\t\tbase_addr = info->screen_buffer;\n\t\tcount -= copy_from_user(base_addr + p, buf, count);\n\t\t*ppos += count;\n\t\terr = -EFAULT;\n\t}\n\n\n\tbitppos = p*8;\n\tstartpos = floorXres(bitppos, xres);\n\tendpos = ceilXres((bitppos + (count*8)), xres);\n\tbitcount = endpos - startpos;\n\n\tx = startpos % xres;\n\ty = startpos / xres;\n\tw = xres;\n\th = bitcount / xres;\n\tarcfb_lcd_update(par, x, y, w, h);\n\n\tif (count)\n\t\treturn count;\n\treturn err;\n}\n\nstatic const struct fb_ops arcfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= arcfb_open,\n\t.fb_read        = fb_sys_read,\n\t.fb_write\t= arcfb_write,\n\t.fb_release\t= arcfb_release,\n\t.fb_pan_display\t= arcfb_pan_display,\n\t.fb_fillrect\t= arcfb_fillrect,\n\t.fb_copyarea\t= arcfb_copyarea,\n\t.fb_imageblit\t= arcfb_imageblit,\n\t.fb_ioctl \t= arcfb_ioctl,\n};\n\nstatic int arcfb_probe(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\tint retval = -ENOMEM;\n\tint videomemorysize;\n\tunsigned char *videomemory;\n\tstruct arcfb_par *par;\n\tint i;\n\n\tvideomemorysize = (((64*64)*num_cols)*num_rows)/8;\n\n\t \n\tvideomemory = vzalloc(videomemorysize);\n\tif (!videomemory)\n\t\treturn retval;\n\n\tinfo = framebuffer_alloc(sizeof(struct arcfb_par), &dev->dev);\n\tif (!info)\n\t\tgoto err_fb_alloc;\n\n\tinfo->screen_buffer = videomemory;\n\tinfo->fbops = &arcfb_ops;\n\n\tinfo->var = arcfb_var;\n\tinfo->fix = arcfb_fix;\n\tpar = info->par;\n\tpar->info = info;\n\n\tif (!dio_addr || !cio_addr || !c2io_addr) {\n\t\tprintk(KERN_WARNING \"no IO addresses supplied\\n\");\n\t\tgoto err_addr;\n\t}\n\tpar->dio_addr = dio_addr;\n\tpar->cio_addr = cio_addr;\n\tpar->c2io_addr = c2io_addr;\n\tpar->cslut[0] = 0x00;\n\tpar->cslut[1] = 0x06;\n\tspin_lock_init(&par->lock);\n\tif (irq) {\n\t\tpar->irq = irq;\n\t\tif (request_irq(par->irq, &arcfb_interrupt, IRQF_SHARED,\n\t\t\t\t\"arcfb\", info)) {\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"arcfb: Failed req IRQ %d\\n\", par->irq);\n\t\t\tretval = -EBUSY;\n\t\t\tgoto err_addr;\n\t\t}\n\t}\n\tretval = register_framebuffer(info);\n\tif (retval < 0)\n\t\tgoto err_register_fb;\n\tplatform_set_drvdata(dev, info);\n\tfb_info(info, \"Arc frame buffer device, using %dK of video memory\\n\",\n\t\tvideomemorysize >> 10);\n\n\t \n\tfor (i = 0; i < num_cols * num_rows; i++) {\n\t\tks108_writeb_ctl(par, i, KS_DPY_OFF);\n\t\tks108_set_start_line(par, i, 0);\n\t\tks108_set_yaddr(par, i, 0);\n\t\tks108_set_xaddr(par, i, 0);\n\t\tks108_writeb_ctl(par, i, KS_DPY_ON);\n\t}\n\n\t \n\tif (!nosplash) {\n\t\tfor (i = 0; i < num_cols * num_rows; i++) {\n\t\t\tfb_info(info, \"splashing lcd %d\\n\", i);\n\t\t\tks108_set_start_line(par, i, 0);\n\t\t\tks108_clear_lcd(par, i);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_register_fb:\n\tfree_irq(par->irq, info);\nerr_addr:\n\tframebuffer_release(info);\nerr_fb_alloc:\n\tvfree(videomemory);\n\treturn retval;\n}\n\nstatic void arcfb_remove(struct platform_device *dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\n\tif (info) {\n\t\tunregister_framebuffer(info);\n\t\tif (irq)\n\t\t\tfree_irq(((struct arcfb_par *)(info->par))->irq, info);\n\t\tvfree(info->screen_buffer);\n\t\tframebuffer_release(info);\n\t}\n}\n\nstatic struct platform_driver arcfb_driver = {\n\t.probe\t= arcfb_probe,\n\t.remove_new = arcfb_remove,\n\t.driver\t= {\n\t\t.name\t= \"arcfb\",\n\t},\n};\n\nstatic struct platform_device *arcfb_device;\n\nstatic int __init arcfb_init(void)\n{\n\tint ret;\n\n\tif (!arcfb_enable)\n\t\treturn -ENXIO;\n\n\tret = platform_driver_register(&arcfb_driver);\n\tif (!ret) {\n\t\tarcfb_device = platform_device_alloc(\"arcfb\", 0);\n\t\tif (arcfb_device) {\n\t\t\tret = platform_device_add(arcfb_device);\n\t\t} else {\n\t\t\tret = -ENOMEM;\n\t\t}\n\t\tif (ret) {\n\t\t\tplatform_device_put(arcfb_device);\n\t\t\tplatform_driver_unregister(&arcfb_driver);\n\t\t}\n\t}\n\treturn ret;\n\n}\n\nstatic void __exit arcfb_exit(void)\n{\n\tplatform_device_unregister(arcfb_device);\n\tplatform_driver_unregister(&arcfb_driver);\n}\n\nmodule_param(num_cols, ulong, 0);\nMODULE_PARM_DESC(num_cols, \"Num horiz panels, eg: 2 = 128 bit wide\");\nmodule_param(num_rows, ulong, 0);\nMODULE_PARM_DESC(num_rows, \"Num vert panels, eg: 1 = 64 bit high\");\nmodule_param(nosplash, uint, 0);\nMODULE_PARM_DESC(nosplash, \"Disable doing the splash screen\");\nmodule_param(arcfb_enable, uint, 0);\nMODULE_PARM_DESC(arcfb_enable, \"Enable communication with Arc board\");\nmodule_param_hw(dio_addr, ulong, ioport, 0);\nMODULE_PARM_DESC(dio_addr, \"IO address for data, eg: 0x480\");\nmodule_param_hw(cio_addr, ulong, ioport, 0);\nMODULE_PARM_DESC(cio_addr, \"IO address for control, eg: 0x400\");\nmodule_param_hw(c2io_addr, ulong, ioport, 0);\nMODULE_PARM_DESC(c2io_addr, \"IO address for secondary control, eg: 0x408\");\nmodule_param(splashval, ulong, 0);\nMODULE_PARM_DESC(splashval, \"Splash pattern: 0xFF is black, 0x00 is green\");\nmodule_param(tuhold, ulong, 0);\nMODULE_PARM_DESC(tuhold, \"Time to hold between strobing data to Arc board\");\nmodule_param_hw(irq, uint, irq, 0);\nMODULE_PARM_DESC(irq, \"IRQ for the Arc board\");\n\nmodule_init(arcfb_init);\nmodule_exit(arcfb_exit);\n\nMODULE_DESCRIPTION(\"fbdev driver for Arc monochrome LCD board\");\nMODULE_AUTHOR(\"Jaya Kumar\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}