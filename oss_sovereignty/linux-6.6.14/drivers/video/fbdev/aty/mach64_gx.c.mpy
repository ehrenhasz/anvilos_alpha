{
  "module_name": "mach64_gx.c",
  "hash_id": "bbeca620406f7292601fef364a7a2fea17ed25fa34021ac1bb16f7256bf372f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/aty/mach64_gx.c",
  "human_readable_source": "\n\n \n\n#include <linux/delay.h>\n#include <linux/fb.h>\n\n#include <asm/io.h>\n\n#include <video/mach64.h>\n#include \"atyfb.h\"\n\n \n\n#define REF_FREQ_2595       1432\t \n#define REF_DIV_2595          46\t \n\t\t\t\t   \n#define MAX_FREQ_2595      15938\t \n#define MIN_FREQ_2595       8000\t \n\t\t\t\t   \n#define ABS_MIN_FREQ_2595   1000\t \n#define N_ADJ_2595           257\n\n#define STOP_BITS_2595     0x1800\n\n\n#define MIN_N_408\t\t2\n\n#define MIN_N_1703\t\t6\n\n#define MIN_M\t\t2\n#define MAX_M\t\t30\n#define MIN_N\t\t35\n#define MAX_N\t\t255-8\n\n\n     \n\nstatic void aty_dac_waste4(const struct atyfb_par *par)\n{\n\t(void) aty_ld_8(DAC_REGS, par);\n\n\t(void) aty_ld_8(DAC_REGS + 2, par);\n\t(void) aty_ld_8(DAC_REGS + 2, par);\n\t(void) aty_ld_8(DAC_REGS + 2, par);\n\t(void) aty_ld_8(DAC_REGS + 2, par);\n}\n\nstatic void aty_StrobeClock(const struct atyfb_par *par)\n{\n\tu8 tmp;\n\n\tudelay(26);\n\n\ttmp = aty_ld_8(CLOCK_CNTL, par);\n\taty_st_8(CLOCK_CNTL + par->clk_wr_offset, tmp | CLOCK_STROBE, par);\n\treturn;\n}\n\n\n     \n\nstatic void aty_st_514(int offset, u8 val, const struct atyfb_par *par)\n{\n\taty_st_8(DAC_CNTL, 1, par);\n\t \n\taty_st_8(DAC_W_INDEX, offset & 0xff, par);\n\t \n\taty_st_8(DAC_DATA, (offset >> 8) & 0xff, par);\n\taty_st_8(DAC_MASK, val, par);\n\taty_st_8(DAC_CNTL, 0, par);\n}\n\nstatic int aty_set_dac_514(const struct fb_info *info,\n\t\t\t   const union aty_pll *pll, u32 bpp, u32 accel)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tstatic struct {\n\t\tu8 pixel_dly;\n\t\tu8 misc2_cntl;\n\t\tu8 pixel_rep;\n\t\tu8 pixel_cntl_index;\n\t\tu8 pixel_cntl_v1;\n\t} tab[3] = {\n\t\t{\n\t\t0, 0x41, 0x03, 0x71, 0x45},\t \n\t\t{\n\t\t0, 0x45, 0x04, 0x0c, 0x01},\t \n\t\t{\n\t\t0, 0x45, 0x06, 0x0e, 0x00},\t \n\t};\n\tint i;\n\n\tswitch (bpp) {\n\tcase 8:\n\tdefault:\n\t\ti = 0;\n\t\tbreak;\n\tcase 16:\n\t\ti = 1;\n\t\tbreak;\n\tcase 32:\n\t\ti = 2;\n\t\tbreak;\n\t}\n\taty_st_514(0x90, 0x00, par);\t \n\taty_st_514(0x04, tab[i].pixel_dly, par);\t \n\taty_st_514(0x05, 0x00, par);\t \n\taty_st_514(0x02, 0x01, par);\t \n\taty_st_514(0x71, tab[i].misc2_cntl, par);\t \n\taty_st_514(0x0a, tab[i].pixel_rep, par);\t \n\taty_st_514(tab[i].pixel_cntl_index, tab[i].pixel_cntl_v1, par);\n\t \n\treturn 0;\n}\n\nstatic int aty_var_to_pll_514(const struct fb_info *info, u32 vclk_per,\n\t\t\t      u32 bpp, union aty_pll *pll)\n{\n\t \n\tstatic struct {\n\t\tu32 limit;\t \n\t\tu8 m;\t\t \n\t\tu8 n;\t\t \n\t} RGB514_clocks[7] = {\n\t\t{\n\t\t8000, (3 << 6) | 20, 9},\t \n\t\t{\n\t\t10000, (1 << 6) | 19, 3},\t \n\t\t{\n\t\t13000, (1 << 6) | 2, 3},\t \n\t\t{\n\t\t14000, (2 << 6) | 8, 7},\t \n\t\t{\n\t\t16000, (1 << 6) | 44, 6},\t \n\t\t{\n\t\t25000, (1 << 6) | 15, 5},\t \n\t\t{\n\t\t50000, (0 << 6) | 53, 7},\t \n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(RGB514_clocks); i++)\n\t\tif (vclk_per <= RGB514_clocks[i].limit) {\n\t\t\tpll->ibm514.m = RGB514_clocks[i].m;\n\t\t\tpll->ibm514.n = RGB514_clocks[i].n;\n\t\t\treturn 0;\n\t\t}\n\treturn -EINVAL;\n}\n\nstatic u32 aty_pll_514_to_var(const struct fb_info *info,\n\t\t\t      const union aty_pll *pll)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu8 df, vco_div_count, ref_div_count;\n\n\tdf = pll->ibm514.m >> 6;\n\tvco_div_count = pll->ibm514.m & 0x3f;\n\tref_div_count = pll->ibm514.n;\n\n\treturn ((par->ref_clk_per * ref_div_count) << (3 - df))/\n\t    \t\t(vco_div_count + 65);\n}\n\nstatic void aty_set_pll_514(const struct fb_info *info,\n\t\t\t    const union aty_pll *pll)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\n\taty_st_514(0x06, 0x02, par);\t \n\taty_st_514(0x10, 0x01, par);\t \n\taty_st_514(0x70, 0x01, par);\t \n\taty_st_514(0x8f, 0x1f, par);\t \n\taty_st_514(0x03, 0x00, par);\t \n\taty_st_514(0x05, 0x00, par);\t \n\taty_st_514(0x20, pll->ibm514.m, par);\t \n\taty_st_514(0x21, pll->ibm514.n, par);\t \n}\n\nconst struct aty_dac_ops aty_dac_ibm514 = {\n\t.set_dac\t= aty_set_dac_514,\n};\n\nconst struct aty_pll_ops aty_pll_ibm514 = {\n\t.var_to_pll\t= aty_var_to_pll_514,\n\t.pll_to_var\t= aty_pll_514_to_var,\n\t.set_pll\t= aty_set_pll_514,\n};\n\n\n     \n\nstatic int aty_set_dac_ATI68860_B(const struct fb_info *info,\n\t\t\t\t  const union aty_pll *pll, u32 bpp,\n\t\t\t\t  u32 accel)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 gModeReg, devSetupRegA, temp, mask;\n\n\tgModeReg = 0;\n\tdevSetupRegA = 0;\n\n\tswitch (bpp) {\n\tcase 8:\n\t\tgModeReg = 0x83;\n\t\tdevSetupRegA =\n\t\t    0x60 | 0x00   ;\n\t\tbreak;\n\tcase 15:\n\t\tgModeReg = 0xA0;\n\t\tdevSetupRegA = 0x60;\n\t\tbreak;\n\tcase 16:\n\t\tgModeReg = 0xA1;\n\t\tdevSetupRegA = 0x60;\n\t\tbreak;\n\tcase 24:\n\t\tgModeReg = 0xC0;\n\t\tdevSetupRegA = 0x60;\n\t\tbreak;\n\tcase 32:\n\t\tgModeReg = 0xE3;\n\t\tdevSetupRegA = 0x60;\n\t\tbreak;\n\t}\n\n\tif (!accel) {\n\t\tgModeReg = 0x80;\n\t\tdevSetupRegA = 0x61;\n\t}\n\n\ttemp = aty_ld_8(DAC_CNTL, par);\n\taty_st_8(DAC_CNTL, (temp & ~DAC_EXT_SEL_RS2) | DAC_EXT_SEL_RS3,\n\t\t par);\n\n\taty_st_8(DAC_REGS + 2, 0x1D, par);\n\taty_st_8(DAC_REGS + 3, gModeReg, par);\n\taty_st_8(DAC_REGS, 0x02, par);\n\n\ttemp = aty_ld_8(DAC_CNTL, par);\n\taty_st_8(DAC_CNTL, temp | DAC_EXT_SEL_RS2 | DAC_EXT_SEL_RS3, par);\n\n\tif (info->fix.smem_len < ONE_MB)\n\t\tmask = 0x04;\n\telse if (info->fix.smem_len == ONE_MB)\n\t\tmask = 0x08;\n\telse\n\t\tmask = 0x0C;\n\n\t \n#define A860_DELAY_L\t0x80\n\n\ttemp = aty_ld_8(DAC_REGS, par);\n\taty_st_8(DAC_REGS, (devSetupRegA | mask) | (temp & A860_DELAY_L),\n\t\t par);\n\ttemp = aty_ld_8(DAC_CNTL, par);\n\taty_st_8(DAC_CNTL, (temp & ~(DAC_EXT_SEL_RS2 | DAC_EXT_SEL_RS3)),\n\t\t par);\n\n\taty_st_le32(BUS_CNTL, 0x890e20f1, par);\n\taty_st_le32(DAC_CNTL, 0x47052100, par);\n\treturn 0;\n}\n\nconst struct aty_dac_ops aty_dac_ati68860b = {\n\t.set_dac\t= aty_set_dac_ATI68860_B,\n};\n\n\n     \n\nstatic int aty_set_dac_ATT21C498(const struct fb_info *info,\n\t\t\t\t const union aty_pll *pll, u32 bpp,\n\t\t\t\t u32 accel)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 dotClock;\n\tint muxmode = 0;\n\tint DACMask = 0;\n\n\tdotClock = 100000000 / pll->ics2595.period_in_ps;\n\n\tswitch (bpp) {\n\tcase 8:\n\t\tif (dotClock > 8000) {\n\t\t\tDACMask = 0x24;\n\t\t\tmuxmode = 1;\n\t\t} else\n\t\t\tDACMask = 0x04;\n\t\tbreak;\n\tcase 15:\n\t\tDACMask = 0x16;\n\t\tbreak;\n\tcase 16:\n\t\tDACMask = 0x36;\n\t\tbreak;\n\tcase 24:\n\t\tDACMask = 0xE6;\n\t\tbreak;\n\tcase 32:\n\t\tDACMask = 0xE6;\n\t\tbreak;\n\t}\n\n\tif (1   )\n\t\tDACMask |= 0x02;\n\n\taty_dac_waste4(par);\n\taty_st_8(DAC_REGS + 2, DACMask, par);\n\n\taty_st_le32(BUS_CNTL, 0x890e20f1, par);\n\taty_st_le32(DAC_CNTL, 0x00072000, par);\n\treturn muxmode;\n}\n\nconst struct aty_dac_ops aty_dac_att21c498 = {\n\t.set_dac\t= aty_set_dac_ATT21C498,\n};\n\n\n     \n\nstatic int aty_var_to_pll_18818(const struct fb_info *info, u32 vclk_per,\n\t\t\t\tu32 bpp, union aty_pll *pll)\n{\n\tu32 MHz100;\t\t \n\tu32 program_bits;\n\tu32 post_divider;\n\n\t \n\tMHz100 = 100000000 / vclk_per;\n\n\tprogram_bits = -1;\n\tpost_divider = 1;\n\n\tif (MHz100 > MAX_FREQ_2595) {\n\t\treturn -EINVAL;\n\t} else if (MHz100 < ABS_MIN_FREQ_2595) {\n\t\treturn -EINVAL;\n\t} else {\n\t\twhile (MHz100 < MIN_FREQ_2595) {\n\t\t\tMHz100 *= 2;\n\t\t\tpost_divider *= 2;\n\t\t}\n\t}\n\tMHz100 *= 1000;\n\tMHz100 = (REF_DIV_2595 * MHz100) / REF_FREQ_2595;\n \n\tMHz100 += 500;\t\t \n\tMHz100 /= 1000;\n\n\tif (program_bits == -1) {\n\t\tprogram_bits = MHz100 - N_ADJ_2595;\n\t\tswitch (post_divider) {\n\t\tcase 1:\n\t\t\tprogram_bits |= 0x0600;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprogram_bits |= 0x0400;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprogram_bits |= 0x0200;\n\t\t\tbreak;\n\t\tcase 8:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprogram_bits |= STOP_BITS_2595;\n\n\tpll->ics2595.program_bits = program_bits;\n\tpll->ics2595.locationAddr = 0;\n\tpll->ics2595.post_divider = post_divider;\n\tpll->ics2595.period_in_ps = vclk_per;\n\n\treturn 0;\n}\n\nstatic u32 aty_pll_18818_to_var(const struct fb_info *info,\n\t\t\t\tconst union aty_pll *pll)\n{\n\treturn (pll->ics2595.period_in_ps);\t \n}\n\nstatic void aty_ICS2595_put1bit(u8 data, const struct atyfb_par *par)\n{\n\tu8 tmp;\n\n\tdata &= 0x01;\n\ttmp = aty_ld_8(CLOCK_CNTL, par);\n\taty_st_8(CLOCK_CNTL + par->clk_wr_offset,\n\t\t (tmp & ~0x04) | (data << 2), par);\n\n\ttmp = aty_ld_8(CLOCK_CNTL, par);\n\taty_st_8(CLOCK_CNTL + par->clk_wr_offset, (tmp & ~0x08) | (0 << 3),\n\t\t par);\n\n\taty_StrobeClock(par);\n\n\ttmp = aty_ld_8(CLOCK_CNTL, par);\n\taty_st_8(CLOCK_CNTL + par->clk_wr_offset, (tmp & ~0x08) | (1 << 3),\n\t\t par);\n\n\taty_StrobeClock(par);\n\treturn;\n}\n\nstatic void aty_set_pll18818(const struct fb_info *info,\n\t\t\t     const union aty_pll *pll)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 program_bits;\n\tu32 locationAddr;\n\n\tu32 i;\n\n\tu8 old_clock_cntl;\n\tu8 old_crtc_ext_disp;\n\n\told_clock_cntl = aty_ld_8(CLOCK_CNTL, par);\n\taty_st_8(CLOCK_CNTL + par->clk_wr_offset, 0, par);\n\n\told_crtc_ext_disp = aty_ld_8(CRTC_GEN_CNTL + 3, par);\n\taty_st_8(CRTC_GEN_CNTL + 3,\n\t\t old_crtc_ext_disp | (CRTC_EXT_DISP_EN >> 24), par);\n\n\tmdelay(15);\t\t \n\n\tprogram_bits = pll->ics2595.program_bits;\n\tlocationAddr = pll->ics2595.locationAddr;\n\n\t \n\taty_st_8(CLOCK_CNTL + par->clk_wr_offset, 0, par);\t \n\taty_StrobeClock(par);\n\taty_st_8(CLOCK_CNTL + par->clk_wr_offset, 1, par);\t \n\taty_StrobeClock(par);\n\n\taty_ICS2595_put1bit(1, par);\t \n\taty_ICS2595_put1bit(0, par);\t \n\taty_ICS2595_put1bit(0, par);\t \n\n\tfor (i = 0; i < 5; i++) {\t \n\t\taty_ICS2595_put1bit(locationAddr & 1, par);\n\t\tlocationAddr >>= 1;\n\t}\n\n\tfor (i = 0; i < 8 + 1 + 2 + 2; i++) {\n\t\taty_ICS2595_put1bit(program_bits & 1, par);\n\t\tprogram_bits >>= 1;\n\t}\n\n\tmdelay(1);\t\t \n\n\t(void) aty_ld_8(DAC_REGS, par);\t \n\taty_st_8(CRTC_GEN_CNTL + 3, old_crtc_ext_disp, par);\n\taty_st_8(CLOCK_CNTL + par->clk_wr_offset,\n\t\t old_clock_cntl | CLOCK_STROBE, par);\n\n\tmdelay(50);\t\t \n\taty_st_8(CLOCK_CNTL + par->clk_wr_offset,\n\t\t ((pll->ics2595.locationAddr & 0x0F) | CLOCK_STROBE), par);\n\treturn;\n}\n\nconst struct aty_pll_ops aty_pll_ati18818_1 = {\n\t.var_to_pll\t= aty_var_to_pll_18818,\n\t.pll_to_var\t= aty_pll_18818_to_var,\n\t.set_pll\t= aty_set_pll18818,\n};\n\n\n     \n\nstatic int aty_var_to_pll_1703(const struct fb_info *info, u32 vclk_per,\n\t\t\t       u32 bpp, union aty_pll *pll)\n{\n\tu32 mhz100;\t\t \n\tu32 program_bits;\n\t \n\tu32 mach64MinFreq, mach64MaxFreq, mach64RefFreq;\n\tu32 temp, tempB;\n\tu16 remainder, preRemainder;\n\tshort divider = 0, tempA;\n\n\t \n\tmhz100 = 100000000 / vclk_per;\n\tmach64MinFreq = MIN_FREQ_2595;\n\tmach64MaxFreq = MAX_FREQ_2595;\n\tmach64RefFreq = REF_FREQ_2595;\t \n\n\t \n\tif (mhz100 == 0)\n\t\tprogram_bits = 0xE0;\n\telse {\n\t\tif (mhz100 < mach64MinFreq)\n\t\t\tmhz100 = mach64MinFreq;\n\t\tif (mhz100 > mach64MaxFreq)\n\t\t\tmhz100 = mach64MaxFreq;\n\n\t\tdivider = 0;\n\t\twhile (mhz100 < (mach64MinFreq << 3)) {\n\t\t\tmhz100 <<= 1;\n\t\t\tdivider += 0x20;\n\t\t}\n\n\t\ttemp = (unsigned int) (mhz100);\n\t\ttemp = (unsigned int) (temp * (MIN_N_1703 + 2));\n\t\ttemp -= (short) (mach64RefFreq << 1);\n\n\t\ttempA = MIN_N_1703;\n\t\tpreRemainder = 0xffff;\n\n\t\tdo {\n\t\t\ttempB = temp;\n\t\t\tremainder = tempB % mach64RefFreq;\n\t\t\ttempB = tempB / mach64RefFreq;\n\n\t\t\tif ((tempB & 0xffff) <= 127\n\t\t\t    && (remainder <= preRemainder)) {\n\t\t\t\tpreRemainder = remainder;\n\t\t\t\tdivider &= ~0x1f;\n\t\t\t\tdivider |= tempA;\n\t\t\t\tdivider =\n\t\t\t\t    (divider & 0x00ff) +\n\t\t\t\t    ((tempB & 0xff) << 8);\n\t\t\t}\n\n\t\t\ttemp += mhz100;\n\t\t\ttempA++;\n\t\t} while (tempA <= (MIN_N_1703 << 1));\n\n\t\tprogram_bits = divider;\n\t}\n\n\tpll->ics2595.program_bits = program_bits;\n\tpll->ics2595.locationAddr = 0;\n\tpll->ics2595.post_divider = divider;\t \n\tpll->ics2595.period_in_ps = vclk_per;\n\n\treturn 0;\n}\n\nstatic u32 aty_pll_1703_to_var(const struct fb_info *info,\n\t\t\t       const union aty_pll *pll)\n{\n\treturn (pll->ics2595.period_in_ps);\t \n}\n\nstatic void aty_set_pll_1703(const struct fb_info *info,\n\t\t\t     const union aty_pll *pll)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 program_bits;\n\tu32 locationAddr;\n\n\tchar old_crtc_ext_disp;\n\n\told_crtc_ext_disp = aty_ld_8(CRTC_GEN_CNTL + 3, par);\n\taty_st_8(CRTC_GEN_CNTL + 3,\n\t\t old_crtc_ext_disp | (CRTC_EXT_DISP_EN >> 24), par);\n\n\tprogram_bits = pll->ics2595.program_bits;\n\tlocationAddr = pll->ics2595.locationAddr;\n\n\t \n\taty_dac_waste4(par);\n\n\t(void) aty_ld_8(DAC_REGS + 2, par);\n\taty_st_8(DAC_REGS + 2, (locationAddr << 1) + 0x20, par);\n\taty_st_8(DAC_REGS + 2, 0, par);\n\taty_st_8(DAC_REGS + 2, (program_bits & 0xFF00) >> 8, par);\n\taty_st_8(DAC_REGS + 2, (program_bits & 0xFF), par);\n\n\t(void) aty_ld_8(DAC_REGS, par);\t \n\taty_st_8(CRTC_GEN_CNTL + 3, old_crtc_ext_disp, par);\n\treturn;\n}\n\nconst struct aty_pll_ops aty_pll_stg1703 = {\n\t.var_to_pll\t= aty_var_to_pll_1703,\n\t.pll_to_var\t= aty_pll_1703_to_var,\n\t.set_pll\t= aty_set_pll_1703,\n};\n\n\n     \n\nstatic int aty_var_to_pll_8398(const struct fb_info *info, u32 vclk_per,\n\t\t\t       u32 bpp, union aty_pll *pll)\n{\n\tu32 tempA, tempB, fOut, longMHz100, diff, preDiff;\n\n\tu32 mhz100;\t\t \n\tu32 program_bits;\n\t \n\tu32 mach64MinFreq, mach64MaxFreq;\n\tu16 m, n, k = 0, save_m, save_n, twoToKth;\n\n\t \n\tmhz100 = 100000000 / vclk_per;\n\tmach64MinFreq = MIN_FREQ_2595;\n\tmach64MaxFreq = MAX_FREQ_2595;\n\n\tsave_m = 0;\n\tsave_n = 0;\n\n\t \n\tif (mhz100 == 0)\n\t\tprogram_bits = 0xE0;\n\telse {\n\t\tif (mhz100 < mach64MinFreq)\n\t\t\tmhz100 = mach64MinFreq;\n\t\tif (mhz100 > mach64MaxFreq)\n\t\t\tmhz100 = mach64MaxFreq;\n\n\t\tlongMHz100 = mhz100 * 256 / 100;\t \n\n\t\twhile (mhz100 < (mach64MinFreq << 3)) {\n\t\t\tmhz100 <<= 1;\n\t\t\tk++;\n\t\t}\n\n\t\ttwoToKth = 1 << k;\n\t\tdiff = 0;\n\t\tpreDiff = 0xFFFFFFFF;\n\n\t\tfor (m = MIN_M; m <= MAX_M; m++) {\n\t\t\tfor (n = MIN_N; n <= MAX_N; n++) {\n\t\t\t\ttempA = 938356;\t\t \n\t\t\t\ttempA *= (n + 8);\t \n\t\t\t\ttempB = twoToKth * 256;\n\t\t\t\ttempB *= (m + 2);\t \n\t\t\t\tfOut = tempA / tempB;\t \n\n\t\t\t\tif (longMHz100 > fOut)\n\t\t\t\t\tdiff = longMHz100 - fOut;\n\t\t\t\telse\n\t\t\t\t\tdiff = fOut - longMHz100;\n\n\t\t\t\tif (diff < preDiff) {\n\t\t\t\t\tsave_m = m;\n\t\t\t\t\tsave_n = n;\n\t\t\t\t\tpreDiff = diff;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprogram_bits = (k << 6) + (save_m) + (save_n << 8);\n\t}\n\n\tpll->ics2595.program_bits = program_bits;\n\tpll->ics2595.locationAddr = 0;\n\tpll->ics2595.post_divider = 0;\n\tpll->ics2595.period_in_ps = vclk_per;\n\n\treturn 0;\n}\n\nstatic u32 aty_pll_8398_to_var(const struct fb_info *info,\n\t\t\t       const union aty_pll *pll)\n{\n\treturn (pll->ics2595.period_in_ps);\t \n}\n\nstatic void aty_set_pll_8398(const struct fb_info *info,\n\t\t\t     const union aty_pll *pll)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 program_bits;\n\tu32 locationAddr;\n\n\tchar old_crtc_ext_disp;\n\tchar tmp;\n\n\told_crtc_ext_disp = aty_ld_8(CRTC_GEN_CNTL + 3, par);\n\taty_st_8(CRTC_GEN_CNTL + 3,\n\t\t old_crtc_ext_disp | (CRTC_EXT_DISP_EN >> 24), par);\n\n\tprogram_bits = pll->ics2595.program_bits;\n\tlocationAddr = pll->ics2595.locationAddr;\n\n\t \n\ttmp = aty_ld_8(DAC_CNTL, par);\n\taty_st_8(DAC_CNTL, tmp | DAC_EXT_SEL_RS2 | DAC_EXT_SEL_RS3, par);\n\n\taty_st_8(DAC_REGS, locationAddr, par);\n\taty_st_8(DAC_REGS + 1, (program_bits & 0xff00) >> 8, par);\n\taty_st_8(DAC_REGS + 1, (program_bits & 0xff), par);\n\n\ttmp = aty_ld_8(DAC_CNTL, par);\n\taty_st_8(DAC_CNTL, (tmp & ~DAC_EXT_SEL_RS2) | DAC_EXT_SEL_RS3,\n\t\t par);\n\n\t(void) aty_ld_8(DAC_REGS, par);\t \n\taty_st_8(CRTC_GEN_CNTL + 3, old_crtc_ext_disp, par);\n\n\treturn;\n}\n\nconst struct aty_pll_ops aty_pll_ch8398 = {\n\t.var_to_pll\t= aty_var_to_pll_8398,\n\t.pll_to_var\t= aty_pll_8398_to_var,\n\t.set_pll\t= aty_set_pll_8398,\n};\n\n\n     \n\nstatic int aty_var_to_pll_408(const struct fb_info *info, u32 vclk_per,\n\t\t\t      u32 bpp, union aty_pll *pll)\n{\n\tu32 mhz100;\t\t \n\tu32 program_bits;\n\t \n\tu32 mach64MinFreq, mach64MaxFreq, mach64RefFreq;\n\tu32 temp, tempB;\n\tu16 remainder, preRemainder;\n\tshort divider = 0, tempA;\n\n\t \n\tmhz100 = 100000000 / vclk_per;\n\tmach64MinFreq = MIN_FREQ_2595;\n\tmach64MaxFreq = MAX_FREQ_2595;\n\tmach64RefFreq = REF_FREQ_2595;\t \n\n\t \n\tif (mhz100 == 0)\n\t\tprogram_bits = 0xFF;\n\telse {\n\t\tif (mhz100 < mach64MinFreq)\n\t\t\tmhz100 = mach64MinFreq;\n\t\tif (mhz100 > mach64MaxFreq)\n\t\t\tmhz100 = mach64MaxFreq;\n\n\t\twhile (mhz100 < (mach64MinFreq << 3)) {\n\t\t\tmhz100 <<= 1;\n\t\t\tdivider += 0x40;\n\t\t}\n\n\t\ttemp = (unsigned int) mhz100;\n\t\ttemp = (unsigned int) (temp * (MIN_N_408 + 2));\n\t\ttemp -= ((short) (mach64RefFreq << 1));\n\n\t\ttempA = MIN_N_408;\n\t\tpreRemainder = 0xFFFF;\n\n\t\tdo {\n\t\t\ttempB = temp;\n\t\t\tremainder = tempB % mach64RefFreq;\n\t\t\ttempB = tempB / mach64RefFreq;\n\t\t\tif (((tempB & 0xFFFF) <= 255)\n\t\t\t    && (remainder <= preRemainder)) {\n\t\t\t\tpreRemainder = remainder;\n\t\t\t\tdivider &= ~0x3f;\n\t\t\t\tdivider |= tempA;\n\t\t\t\tdivider =\n\t\t\t\t    (divider & 0x00FF) +\n\t\t\t\t    ((tempB & 0xFF) << 8);\n\t\t\t}\n\t\t\ttemp += mhz100;\n\t\t\ttempA++;\n\t\t} while (tempA <= 32);\n\n\t\tprogram_bits = divider;\n\t}\n\n\tpll->ics2595.program_bits = program_bits;\n\tpll->ics2595.locationAddr = 0;\n\tpll->ics2595.post_divider = divider;\t \n\tpll->ics2595.period_in_ps = vclk_per;\n\n\treturn 0;\n}\n\nstatic u32 aty_pll_408_to_var(const struct fb_info *info,\n\t\t\t      const union aty_pll *pll)\n{\n\treturn (pll->ics2595.period_in_ps);\t \n}\n\nstatic void aty_set_pll_408(const struct fb_info *info,\n\t\t\t    const union aty_pll *pll)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 program_bits;\n\tu32 locationAddr;\n\n\tu8 tmpA, tmpB, tmpC;\n\tchar old_crtc_ext_disp;\n\n\told_crtc_ext_disp = aty_ld_8(CRTC_GEN_CNTL + 3, par);\n\taty_st_8(CRTC_GEN_CNTL + 3,\n\t\t old_crtc_ext_disp | (CRTC_EXT_DISP_EN >> 24), par);\n\n\tprogram_bits = pll->ics2595.program_bits;\n\tlocationAddr = pll->ics2595.locationAddr;\n\n\t \n\taty_dac_waste4(par);\n\ttmpB = aty_ld_8(DAC_REGS + 2, par) | 1;\n\taty_dac_waste4(par);\n\taty_st_8(DAC_REGS + 2, tmpB, par);\n\n\ttmpA = tmpB;\n\ttmpC = tmpA;\n\ttmpA |= 8;\n\ttmpB = 1;\n\n\taty_st_8(DAC_REGS, tmpB, par);\n\taty_st_8(DAC_REGS + 2, tmpA, par);\n\n\tudelay(400);\t\t \n\n\tlocationAddr = (locationAddr << 2) + 0x40;\n\ttmpB = locationAddr;\n\ttmpA = program_bits >> 8;\n\n\taty_st_8(DAC_REGS, tmpB, par);\n\taty_st_8(DAC_REGS + 2, tmpA, par);\n\n\ttmpB = locationAddr + 1;\n\ttmpA = (u8) program_bits;\n\n\taty_st_8(DAC_REGS, tmpB, par);\n\taty_st_8(DAC_REGS + 2, tmpA, par);\n\n\ttmpB = locationAddr + 2;\n\ttmpA = 0x77;\n\n\taty_st_8(DAC_REGS, tmpB, par);\n\taty_st_8(DAC_REGS + 2, tmpA, par);\n\n\tudelay(400);\t\t \n\ttmpA = tmpC & (~(1 | 8));\n\ttmpB = 1;\n\n\taty_st_8(DAC_REGS, tmpB, par);\n\taty_st_8(DAC_REGS + 2, tmpA, par);\n\n\t(void) aty_ld_8(DAC_REGS, par);\t \n\taty_st_8(CRTC_GEN_CNTL + 3, old_crtc_ext_disp, par);\n\treturn;\n}\n\nconst struct aty_pll_ops aty_pll_att20c408 = {\n\t.var_to_pll\t= aty_var_to_pll_408,\n\t.pll_to_var\t= aty_pll_408_to_var,\n\t.set_pll\t= aty_set_pll_408,\n};\n\n\n     \n\nstatic int aty_set_dac_unsupported(const struct fb_info *info,\n\t\t\t\t   const union aty_pll *pll, u32 bpp,\n\t\t\t\t   u32 accel)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\n\taty_st_le32(BUS_CNTL, 0x890e20f1, par);\n\taty_st_le32(DAC_CNTL, 0x47052100, par);\n\t \n\taty_st_le32(BUS_CNTL, 0x590e10ff, par);\n\taty_st_le32(DAC_CNTL, 0x47012100, par);\n\treturn 0;\n}\n\nstatic int dummy(void)\n{\n\treturn 0;\n}\n\nconst struct aty_dac_ops aty_dac_unsupported = {\n\t.set_dac\t= aty_set_dac_unsupported,\n};\n\nconst struct aty_pll_ops aty_pll_unsupported = {\n\t.var_to_pll\t= (void *) dummy,\n\t.pll_to_var\t= (void *) dummy,\n\t.set_pll\t= (void *) dummy,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}