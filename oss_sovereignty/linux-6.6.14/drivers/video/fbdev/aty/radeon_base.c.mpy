{
  "module_name": "radeon_base.c",
  "hash_id": "8c99848b1f7b22317dcdf5bd55ba68cce61bffdfa7c4acbab1d16730888d2358",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/aty/radeon_base.c",
  "human_readable_source": " \n\n\n#define RADEON_VERSION\t\"0.2.0\"\n\n#include \"radeonfb.h\"\n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/time.h>\n#include <linux/fb.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/device.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#ifdef CONFIG_PPC\n\n#include \"../macmodes.h\"\n\n#ifdef CONFIG_BOOTX_TEXT\n#include <asm/btext.h>\n#endif\n\n#endif  \n\n#include <video/radeon.h>\n#include <linux/radeonfb.h>\n\n#include \"../edid.h\" \n#include \"ati_ids.h\"\n\n#define MAX_MAPPED_VRAM\t(2048*2048*4)\n#define MIN_MAPPED_VRAM\t(1024*768*1)\n\n#define CHIP_DEF(id, family, flags)\t\t\t\t\t\\\n\t{ PCI_VENDOR_ID_ATI, id, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (flags) | (CHIP_FAMILY_##family) }\n\nstatic const struct pci_device_id radeonfb_pci_table[] = {\n         \n\tCHIP_DEF(PCI_CHIP_RS480_5955,   RS480,  CHIP_HAS_CRTC2 | CHIP_IS_IGP | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RS482_5975,\tRS480,\tCHIP_HAS_CRTC2 | CHIP_IS_IGP | CHIP_IS_MOBILITY),\n\t \n\tCHIP_DEF(PCI_CHIP_RADEON_LY, \tRV100,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RADEON_LZ,\tRV100,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\t \n\tCHIP_DEF(PCI_CHIP_RV100_QY, \tRV100,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV100_QZ, \tRV100,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RN50,\t\tRV100,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_RS100_4336,\tRS100,\tCHIP_HAS_CRTC2 | CHIP_IS_IGP | CHIP_IS_MOBILITY),\n\t \n\tCHIP_DEF(PCI_CHIP_RS100_4136,\tRS100,\tCHIP_HAS_CRTC2 | CHIP_IS_IGP),\n\t \n\tCHIP_DEF(PCI_CHIP_RS200_4337,\tRS200,\tCHIP_HAS_CRTC2 | CHIP_IS_IGP | CHIP_IS_MOBILITY),\n\t \n\tCHIP_DEF(PCI_CHIP_RS200_4137,\tRS200,\tCHIP_HAS_CRTC2 | CHIP_IS_IGP),\n\t \n\tCHIP_DEF(PCI_CHIP_RS250_4437,\tRS200,\tCHIP_HAS_CRTC2 | CHIP_IS_IGP | CHIP_IS_MOBILITY),\n\t \n\tCHIP_DEF(PCI_CHIP_RS250_4237,\tRS200,\tCHIP_HAS_CRTC2 | CHIP_IS_IGP),\n\t \n\tCHIP_DEF(PCI_CHIP_R200_BB,\tR200,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R200_BC,\tR200,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_R200_QH,\tR200,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_R200_QL,\tR200,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_R200_QM,\tR200,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_RADEON_LW,\tRV200,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RADEON_LX,\tRV200,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\t \n\tCHIP_DEF(PCI_CHIP_RV200_QW,\tRV200,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV200_QX,\tRV200,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_RV250_Ld,\tRV250,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RV250_Le,\tRV250,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RV250_Lf,\tRV250,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RV250_Lg,\tRV250,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\t \n\tCHIP_DEF(PCI_CHIP_RV250_If,\tRV250,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV250_Ig,\tRV250,\tCHIP_HAS_CRTC2),\n\n\tCHIP_DEF(PCI_CHIP_RC410_5A62,   RC410,  CHIP_HAS_CRTC2 | CHIP_IS_IGP | CHIP_IS_MOBILITY),\n\t \n\tCHIP_DEF(PCI_CHIP_RS300_5835,\tRS300,\tCHIP_HAS_CRTC2 | CHIP_IS_IGP | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RS350_7835,\tRS300,\tCHIP_HAS_CRTC2 | CHIP_IS_IGP | CHIP_IS_MOBILITY),\n\t \n\tCHIP_DEF(PCI_CHIP_RS300_5834,\tRS300,\tCHIP_HAS_CRTC2 | CHIP_IS_IGP),\n\tCHIP_DEF(PCI_CHIP_RS350_7834,\tRS300,\tCHIP_HAS_CRTC2 | CHIP_IS_IGP),\n\t \n\tCHIP_DEF(PCI_CHIP_RV280_5C61,\tRV280,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RV280_5C63,\tRV280,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\t \n\tCHIP_DEF(PCI_CHIP_RV280_5960,\tRV280,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV280_5961,\tRV280,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV280_5962,\tRV280,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV280_5964,\tRV280,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_R300_AD,\tR300,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R300_AE,\tR300,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_R300_AF,\tR300,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R300_AG,\tR300,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_R300_ND,\tR300,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R300_NE,\tR300,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R300_NF,\tR300,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R300_NG,\tR300,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_RV350_NP,\tRV350,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RV350_NQ,\tRV350,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RV350_NR,\tRV350,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RV350_NS,\tRV350,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RV350_NT,\tRV350,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RV350_NV,\tRV350,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\t \n\tCHIP_DEF(PCI_CHIP_RV350_AP,\tRV350,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV350_AQ,\tRV350,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV360_AR,\tRV350,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV350_AS,\tRV350,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV350_AT,\tRV350,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV350_AV,\tRV350,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_R350_AH,\tR350,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R350_AI,\tR350,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R350_AJ,\tR350,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R350_AK,\tR350,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R350_NH,\tR350,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R350_NI,\tR350,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R360_NJ,\tR350,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R350_NK,\tR350,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_RV380_3E50,\tRV380,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV380_3E54,\tRV380,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV380_3150,\tRV380,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RV380_3154,\tRV380,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RV370_5B60,\tRV380,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV370_5B62,\tRV380,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV370_5B63,\tRV380,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV370_5B64,\tRV380,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV370_5B65,\tRV380,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_RV370_5460,\tRV380,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_RV370_5464,\tRV380,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_R420_JH,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R420_JI,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R420_JJ,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R420_JK,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R420_JL,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R420_JM,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R420_JN,\tR420,\tCHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),\n\tCHIP_DEF(PCI_CHIP_R420_JP,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R423_UH,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R423_UI,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R423_UJ,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R423_UK,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R423_UQ,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R423_UR,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R423_UT,\tR420,\tCHIP_HAS_CRTC2),\n\tCHIP_DEF(PCI_CHIP_R423_5D57,\tR420,\tCHIP_HAS_CRTC2),\n\t \n\tCHIP_DEF(PCI_CHIP_RADEON_QD,\tRADEON,\t0),\n\tCHIP_DEF(PCI_CHIP_RADEON_QE,\tRADEON,\t0),\n\tCHIP_DEF(PCI_CHIP_RADEON_QF,\tRADEON,\t0),\n\tCHIP_DEF(PCI_CHIP_RADEON_QG,\tRADEON,\t0),\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, radeonfb_pci_table);\n\n\ntypedef struct {\n\tu16 reg;\n\tu32 val;\n} reg_val;\n\n\n \nstatic reg_val common_regs[] = {\n\t{ OVR_CLR, 0 },\n\t{ OVR_WID_LEFT_RIGHT, 0 },\n\t{ OVR_WID_TOP_BOTTOM, 0 },\n\t{ OV0_SCALE_CNTL, 0 },\n\t{ SUBPIC_CNTL, 0 },\n\t{ VIPH_CONTROL, 0 },\n\t{ I2C_CNTL_1, 0 },\n\t{ GEN_INT_CNTL, 0 },\n\t{ CAP0_TRIG_CNTL, 0 },\n\t{ CAP1_TRIG_CNTL, 0 },\n};\n\n \n\nstatic char *mode_option;\nstatic char *monitor_layout;\nstatic bool noaccel = 0;\nstatic int default_dynclk = -2;\nstatic bool nomodeset = 0;\nstatic bool ignore_edid = 0;\nstatic bool mirror = 0;\nstatic int panel_yres = 0;\nstatic bool force_dfp = 0;\nstatic bool force_measure_pll = 0;\nstatic bool nomtrr = 0;\nstatic bool force_sleep;\nstatic bool ignore_devlist;\nstatic int backlight = IS_BUILTIN(CONFIG_PMAC_BACKLIGHT);\n\n \nvoid _radeon_msleep(struct radeonfb_info *rinfo, unsigned long ms)\n{\n\tif (rinfo->no_schedule || oops_in_progress)\n\t\tmdelay(ms);\n\telse\n\t\tmsleep(ms);\n}\n\nvoid radeon_pll_errata_after_index_slow(struct radeonfb_info *rinfo)\n{\n\t \n\t(void)INREG(CLOCK_CNTL_DATA);\n\t(void)INREG(CRTC_GEN_CNTL);\n}\n\nvoid radeon_pll_errata_after_data_slow(struct radeonfb_info *rinfo)\n{\n\tif (rinfo->errata & CHIP_ERRATA_PLL_DELAY) {\n\t\t \n\t\t_radeon_msleep(rinfo, 5);\n\t}\n\tif (rinfo->errata & CHIP_ERRATA_R300_CG) {\n\t\tu32 save, tmp;\n\t\tsave = INREG(CLOCK_CNTL_INDEX);\n\t\ttmp = save & ~(0x3f | PLL_WR_EN);\n\t\tOUTREG(CLOCK_CNTL_INDEX, tmp);\n\t\ttmp = INREG(CLOCK_CNTL_DATA);\n\t\tOUTREG(CLOCK_CNTL_INDEX, save);\n\t}\n}\n\nvoid _OUTREGP(struct radeonfb_info *rinfo, u32 addr, u32 val, u32 mask)\n{\n\tunsigned long flags;\n\tunsigned int tmp;\n\n\tspin_lock_irqsave(&rinfo->reg_lock, flags);\n\ttmp = INREG(addr);\n\ttmp &= (mask);\n\ttmp |= (val);\n\tOUTREG(addr, tmp);\n\tspin_unlock_irqrestore(&rinfo->reg_lock, flags);\n}\n\nu32 __INPLL(struct radeonfb_info *rinfo, u32 addr)\n{\n\tu32 data;\n\n\tOUTREG8(CLOCK_CNTL_INDEX, addr & 0x0000003f);\n\tradeon_pll_errata_after_index(rinfo);\n\tdata = INREG(CLOCK_CNTL_DATA);\n\tradeon_pll_errata_after_data(rinfo);\n\treturn data;\n}\n\nvoid __OUTPLL(struct radeonfb_info *rinfo, unsigned int index, u32 val)\n{\n\tOUTREG8(CLOCK_CNTL_INDEX, (index & 0x0000003f) | 0x00000080);\n\tradeon_pll_errata_after_index(rinfo);\n\tOUTREG(CLOCK_CNTL_DATA, val);\n\tradeon_pll_errata_after_data(rinfo);\n}\n\nvoid __OUTPLLP(struct radeonfb_info *rinfo, unsigned int index,\n\t\t\t     u32 val, u32 mask)\n{\n\tunsigned int tmp;\n\n\ttmp  = __INPLL(rinfo, index);\n\ttmp &= (mask);\n\ttmp |= (val);\n\t__OUTPLL(rinfo, index, tmp);\n}\n\nvoid _radeon_fifo_wait(struct radeonfb_info *rinfo, int entries)\n{\n\tint i;\n\n\tfor (i=0; i<2000000; i++) {\n\t\tif ((INREG(RBBM_STATUS) & 0x7f) >= entries)\n\t\t\treturn;\n\t\tudelay(1);\n\t}\n\tprintk(KERN_ERR \"radeonfb: FIFO Timeout !\\n\");\n}\n\nvoid radeon_engine_flush(struct radeonfb_info *rinfo)\n{\n\tint i;\n\n\t \n\tOUTREGP(DSTCACHE_CTLSTAT, RB2D_DC_FLUSH_ALL,\n\t        ~RB2D_DC_FLUSH_ALL);\n\n\t \n\t_radeon_fifo_wait(rinfo, 64);\n\n\t \n\tfor (i=0; i < 2000000; i++) {\n\t\tif (!(INREG(DSTCACHE_CTLSTAT) & RB2D_DC_BUSY))\n\t\t\treturn;\n\t\tudelay(1);\n\t}\n\tprintk(KERN_ERR \"radeonfb: Flush Timeout !\\n\");\n}\n\nvoid _radeon_engine_idle(struct radeonfb_info *rinfo)\n{\n\tint i;\n\n\t \n\t_radeon_fifo_wait(rinfo, 64);\n\n\tfor (i=0; i<2000000; i++) {\n\t\tif (((INREG(RBBM_STATUS) & GUI_ACTIVE)) == 0) {\n\t\t\tradeon_engine_flush(rinfo);\n\t\t\treturn;\n\t\t}\n\t\tudelay(1);\n\t}\n\tprintk(KERN_ERR \"radeonfb: Idle Timeout !\\n\");\n}\n\n\n\nstatic void radeon_unmap_ROM(struct radeonfb_info *rinfo, struct pci_dev *dev)\n{\n\tif (!rinfo->bios_seg)\n\t\treturn;\n\tpci_unmap_rom(dev, rinfo->bios_seg);\n}\n\nstatic int radeon_map_ROM(struct radeonfb_info *rinfo, struct pci_dev *dev)\n{\n\tvoid __iomem *rom;\n\tu16 dptr;\n\tu8 rom_type;\n\tsize_t rom_size;\n\n\t \n\n    \t \n    \tunsigned int temp;\n\ttemp = INREG(MPP_TB_CONFIG);\n\ttemp &= 0x00ffffffu;\n\ttemp |= 0x04 << 24;\n\tOUTREG(MPP_TB_CONFIG, temp);\n\ttemp = INREG(MPP_TB_CONFIG);\n\n\trom = pci_map_rom(dev, &rom_size);\n\tif (!rom) {\n\t\tprintk(KERN_ERR \"radeonfb (%s): ROM failed to map\\n\",\n\t\t       pci_name(rinfo->pdev));\n\t\treturn -ENOMEM;\n\t}\n\n\trinfo->bios_seg = rom;\n\n\t \n\tif (BIOS_IN16(0) != 0xaa55) {\n\t\tprintk(KERN_DEBUG \"radeonfb (%s): Invalid ROM signature %x \"\n\t\t\t\"should be 0xaa55\\n\",\n\t\t\tpci_name(rinfo->pdev), BIOS_IN16(0));\n\t\tgoto failed;\n\t}\n\t \n\tdptr = BIOS_IN16(0x18);\n\n\t \n\tif (BIOS_IN32(dptr) !=  (('R' << 24) | ('I' << 16) | ('C' << 8) | 'P')) {\n\t\tprintk(KERN_WARNING \"radeonfb (%s): PCI DATA signature in ROM\"\n\t\t       \"incorrect: %08x\\n\", pci_name(rinfo->pdev), BIOS_IN32(dptr));\n\t\tgoto anyway;\n\t}\n\trom_type = BIOS_IN8(dptr + 0x14);\n\tswitch(rom_type) {\n\tcase 0:\n\t\tprintk(KERN_INFO \"radeonfb: Found Intel x86 BIOS ROM Image\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tprintk(KERN_INFO \"radeonfb: Found Open Firmware ROM Image\\n\");\n\t\tgoto failed;\n\tcase 2:\n\t\tprintk(KERN_INFO \"radeonfb: Found HP PA-RISC ROM Image\\n\");\n\t\tgoto failed;\n\tdefault:\n\t\tprintk(KERN_INFO \"radeonfb: Found unknown type %d ROM Image\\n\", rom_type);\n\t\tgoto failed;\n\t}\n anyway:\n\t \n\trinfo->fp_bios_start = BIOS_IN16(0x48);\n\treturn 0;\n\n failed:\n\trinfo->bios_seg = NULL;\n\tradeon_unmap_ROM(rinfo, dev);\n\treturn -ENXIO;\n}\n\n#ifdef CONFIG_X86\nstatic int  radeon_find_mem_vbios(struct radeonfb_info *rinfo)\n{\n\t \n        u32  segstart;\n\tvoid __iomem *rom_base = NULL;\n\n        for(segstart=0x000c0000; segstart<0x000f0000; segstart+=0x00001000) {\n                rom_base = ioremap(segstart, 0x10000);\n\t\tif (rom_base == NULL)\n\t\t\treturn -ENOMEM;\n                if (readb(rom_base) == 0x55 && readb(rom_base + 1) == 0xaa)\n\t                break;\n                iounmap(rom_base);\n\t\trom_base = NULL;\n        }\n\tif (rom_base == NULL)\n\t\treturn -ENXIO;\n\n\t \n\trinfo->bios_seg = rom_base;\n\trinfo->fp_bios_start = BIOS_IN16(0x48);\n\n\treturn 0;\n}\n#endif\n\n#if defined(CONFIG_PPC) || defined(CONFIG_SPARC)\n \nstatic int radeon_read_xtal_OF(struct radeonfb_info *rinfo)\n{\n\tstruct device_node *dp = rinfo->of_node;\n\tconst u32 *val;\n\n\tif (dp == NULL)\n\t\treturn -ENODEV;\n\tval = of_get_property(dp, \"ATY,RefCLK\", NULL);\n\tif (!val || !*val) {\n\t\tprintk(KERN_WARNING \"radeonfb: No ATY,RefCLK property !\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trinfo->pll.ref_clk = (*val) / 10;\n\n\tval = of_get_property(dp, \"ATY,SCLK\", NULL);\n\tif (val && *val)\n\t\trinfo->pll.sclk = (*val) / 10;\n\n\tval = of_get_property(dp, \"ATY,MCLK\", NULL);\n\tif (val && *val)\n\t\trinfo->pll.mclk = (*val) / 10;\n\n       \treturn 0;\n}\n#endif  \n\n \nstatic int radeon_probe_pll_params(struct radeonfb_info *rinfo)\n{\n\tunsigned char ppll_div_sel;\n\tunsigned Ns, Nm, M;\n\tunsigned sclk, mclk, tmp, ref_div;\n\tint hTotal, vTotal, num, denom, m, n;\n\tunsigned long long hz, vclk;\n\tlong xtal;\n\tktime_t start_time, stop_time;\n\tu64 total_usecs;\n\tint i;\n\n\t \n\n\t \n\ttmp = INREG16(DEVICE_ID);\n\n\tlocal_irq_disable();\n\n\tfor(i=0; i<1000000; i++)\n\t\tif (((INREG(CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) == 0)\n\t\t\tbreak;\n\n\tstart_time = ktime_get();\n\n\tfor(i=0; i<1000000; i++)\n\t\tif (((INREG(CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) != 0)\n\t\t\tbreak;\n\n\tfor(i=0; i<1000000; i++)\n\t\tif (((INREG(CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) == 0)\n\t\t\tbreak;\n\n\tstop_time = ktime_get();\n\n\tlocal_irq_enable();\n\n\ttotal_usecs = ktime_us_delta(stop_time, start_time);\n\tif (total_usecs >= 10 * USEC_PER_SEC || total_usecs == 0)\n\t\treturn -1;\n\thz = USEC_PER_SEC/(u32)total_usecs;\n\n\thTotal = ((INREG(CRTC_H_TOTAL_DISP) & 0x1ff) + 1) * 8;\n\tvTotal = ((INREG(CRTC_V_TOTAL_DISP) & 0x3ff) + 1);\n\tvclk = (long long)hTotal * (long long)vTotal * hz;\n\n\tswitch((INPLL(PPLL_REF_DIV) & 0x30000) >> 16) {\n\tcase 0:\n\tdefault:\n\t\tnum = 1;\n\t\tdenom = 1;\n\t\tbreak;\n\tcase 1:\n\t\tn = ((INPLL(M_SPLL_REF_FB_DIV) >> 16) & 0xff);\n\t\tm = (INPLL(M_SPLL_REF_FB_DIV) & 0xff);\n\t\tnum = 2*n;\n\t\tdenom = 2*m;\n\t\tbreak;\n\tcase 2:\n\t\tn = ((INPLL(M_SPLL_REF_FB_DIV) >> 8) & 0xff);\n\t\tm = (INPLL(M_SPLL_REF_FB_DIV) & 0xff);\n\t\tnum = 2*n;\n\t\tdenom = 2*m;\n        break;\n\t}\n\n\tppll_div_sel = INREG8(CLOCK_CNTL_INDEX + 1) & 0x3;\n\tradeon_pll_errata_after_index(rinfo);\n\n\tn = (INPLL(PPLL_DIV_0 + ppll_div_sel) & 0x7ff);\n\tm = (INPLL(PPLL_REF_DIV) & 0x3ff);\n\n\tnum *= n;\n\tdenom *= m;\n\n\tswitch ((INPLL(PPLL_DIV_0 + ppll_div_sel) >> 16) & 0x7) {\n\tcase 1:\n\t\tdenom *= 2;\n\t\tbreak;\n\tcase 2:\n\t\tdenom *= 4;\n\t\tbreak;\n\tcase 3:\n\t\tdenom *= 8;\n\t\tbreak;\n\tcase 4:\n\t\tdenom *= 3;\n\t\tbreak;\n\tcase 6:\n\t\tdenom *= 6;\n\t\tbreak;\n\tcase 7:\n\t\tdenom *= 12;\n\t\tbreak;\n\t}\n\n\tvclk *= denom;\n\tdo_div(vclk, 1000 * num);\n\txtal = vclk;\n\n\tif ((xtal > 26900) && (xtal < 27100))\n\t\txtal = 2700;\n\telse if ((xtal > 14200) && (xtal < 14400))\n\t\txtal = 1432;\n\telse if ((xtal > 29400) && (xtal < 29600))\n\t\txtal = 2950;\n\telse {\n\t\tprintk(KERN_WARNING \"xtal calculation failed: %ld\\n\", xtal);\n\t\treturn -1;\n\t}\n\n\ttmp = INPLL(M_SPLL_REF_FB_DIV);\n\tref_div = INPLL(PPLL_REF_DIV) & 0x3ff;\n\n\tNs = (tmp & 0xff0000) >> 16;\n\tNm = (tmp & 0xff00) >> 8;\n\tM = (tmp & 0xff);\n\tsclk = round_div((2 * Ns * xtal), (2 * M));\n\tmclk = round_div((2 * Nm * xtal), (2 * M));\n\n\t \n\trinfo->pll.ref_clk = xtal;\n\trinfo->pll.ref_div = ref_div;\n\trinfo->pll.sclk = sclk;\n\trinfo->pll.mclk = mclk;\n\n\treturn 0;\n}\n\n \nstatic void radeon_get_pllinfo(struct radeonfb_info *rinfo)\n{\n\t \n\tswitch (rinfo->chipset) {\n\tcase PCI_DEVICE_ID_ATI_RADEON_QW:\n\tcase PCI_DEVICE_ID_ATI_RADEON_QX:\n\t\trinfo->pll.ppll_max = 35000;\n\t\trinfo->pll.ppll_min = 12000;\n\t\trinfo->pll.mclk = 23000;\n\t\trinfo->pll.sclk = 23000;\n\t\trinfo->pll.ref_clk = 2700;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_ATI_RADEON_QL:\n\tcase PCI_DEVICE_ID_ATI_RADEON_QN:\n\tcase PCI_DEVICE_ID_ATI_RADEON_QO:\n\tcase PCI_DEVICE_ID_ATI_RADEON_Ql:\n\tcase PCI_DEVICE_ID_ATI_RADEON_BB:\n\t\trinfo->pll.ppll_max = 35000;\n\t\trinfo->pll.ppll_min = 12000;\n\t\trinfo->pll.mclk = 27500;\n\t\trinfo->pll.sclk = 27500;\n\t\trinfo->pll.ref_clk = 2700;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_ATI_RADEON_Id:\n\tcase PCI_DEVICE_ID_ATI_RADEON_Ie:\n\tcase PCI_DEVICE_ID_ATI_RADEON_If:\n\tcase PCI_DEVICE_ID_ATI_RADEON_Ig:\n\t\trinfo->pll.ppll_max = 35000;\n\t\trinfo->pll.ppll_min = 12000;\n\t\trinfo->pll.mclk = 25000;\n\t\trinfo->pll.sclk = 25000;\n\t\trinfo->pll.ref_clk = 2700;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_ATI_RADEON_ND:\n\tcase PCI_DEVICE_ID_ATI_RADEON_NE:\n\tcase PCI_DEVICE_ID_ATI_RADEON_NF:\n\tcase PCI_DEVICE_ID_ATI_RADEON_NG:\n\t\trinfo->pll.ppll_max = 40000;\n\t\trinfo->pll.ppll_min = 20000;\n\t\trinfo->pll.mclk = 27000;\n\t\trinfo->pll.sclk = 27000;\n\t\trinfo->pll.ref_clk = 2700;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_ATI_RADEON_QD:\n\tcase PCI_DEVICE_ID_ATI_RADEON_QE:\n\tcase PCI_DEVICE_ID_ATI_RADEON_QF:\n\tcase PCI_DEVICE_ID_ATI_RADEON_QG:\n\tdefault:\n\t\trinfo->pll.ppll_max = 35000;\n\t\trinfo->pll.ppll_min = 12000;\n\t\trinfo->pll.mclk = 16600;\n\t\trinfo->pll.sclk = 16600;\n\t\trinfo->pll.ref_clk = 2700;\n\t\tbreak;\n\t}\n\trinfo->pll.ref_div = INPLL(PPLL_REF_DIV) & PPLL_REF_DIV_MASK;\n\n\n#if defined(CONFIG_PPC) || defined(CONFIG_SPARC)\n\t \n       \tif (!force_measure_pll && radeon_read_xtal_OF(rinfo) == 0) {\n       \t\tprintk(KERN_INFO \"radeonfb: Retrieved PLL infos from Open Firmware\\n\");\n\t\tgoto found;\n\t}\n#endif  \n\n\t \n\tif (!force_measure_pll && rinfo->bios_seg) {\n\t\tu16 pll_info_block = BIOS_IN16(rinfo->fp_bios_start + 0x30);\n\n\t\trinfo->pll.sclk\t\t= BIOS_IN16(pll_info_block + 0x08);\n\t\trinfo->pll.mclk\t\t= BIOS_IN16(pll_info_block + 0x0a);\n\t\trinfo->pll.ref_clk\t= BIOS_IN16(pll_info_block + 0x0e);\n\t\trinfo->pll.ref_div\t= BIOS_IN16(pll_info_block + 0x10);\n\t\trinfo->pll.ppll_min\t= BIOS_IN32(pll_info_block + 0x12);\n\t\trinfo->pll.ppll_max\t= BIOS_IN32(pll_info_block + 0x16);\n\n\t\tprintk(KERN_INFO \"radeonfb: Retrieved PLL infos from BIOS\\n\");\n\t\tgoto found;\n\t}\n\n\t \n\tif (radeon_probe_pll_params(rinfo) == 0) {\n\t\tprintk(KERN_INFO \"radeonfb: Retrieved PLL infos from registers\\n\");\n\t\tgoto found;\n\t}\n\n\t \n       \tprintk(KERN_INFO \"radeonfb: Used default PLL infos\\n\");\n\nfound:\n\t \n\tif (rinfo->pll.mclk == 0)\n\t\trinfo->pll.mclk = 20000;\n\tif (rinfo->pll.sclk == 0)\n\t\trinfo->pll.sclk = 20000;\n\n\tprintk(\"radeonfb: Reference=%d.%02d MHz (RefDiv=%d) Memory=%d.%02d Mhz, System=%d.%02d MHz\\n\",\n\t       rinfo->pll.ref_clk / 100, rinfo->pll.ref_clk % 100,\n\t       rinfo->pll.ref_div,\n\t       rinfo->pll.mclk / 100, rinfo->pll.mclk % 100,\n\t       rinfo->pll.sclk / 100, rinfo->pll.sclk % 100);\n\tprintk(\"radeonfb: PLL min %d max %d\\n\", rinfo->pll.ppll_min, rinfo->pll.ppll_max);\n}\n\nstatic int radeonfb_check_var (struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct radeonfb_info *rinfo = info->par;\n        struct fb_var_screeninfo v;\n        int nom, den;\n\tunsigned int pitch;\n\n\tif (radeon_match_mode(rinfo, &v, var))\n\t\treturn -EINVAL;\n\n        switch (v.bits_per_pixel) {\n\t\tcase 0 ... 8:\n\t\t\tv.bits_per_pixel = 8;\n\t\t\tbreak;\n\t\tcase 9 ... 16:\n\t\t\tv.bits_per_pixel = 16;\n\t\t\tbreak;\n\t\tcase 25 ... 32:\n\t\t\tv.bits_per_pixel = 32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (var_to_depth(&v)) {\n                case 8:\n                        nom = den = 1;\n                        v.red.offset = v.green.offset = v.blue.offset = 0;\n                        v.red.length = v.green.length = v.blue.length = 8;\n                        v.transp.offset = v.transp.length = 0;\n                        break;\n\t\tcase 15:\n\t\t\tnom = 2;\n\t\t\tden = 1;\n\t\t\tv.red.offset = 10;\n\t\t\tv.green.offset = 5;\n\t\t\tv.blue.offset = 0;\n\t\t\tv.red.length = v.green.length = v.blue.length = 5;\n\t\t\tv.transp.offset = v.transp.length = 0;\n\t\t\tbreak;\n                case 16:\n                        nom = 2;\n                        den = 1;\n                        v.red.offset = 11;\n                        v.green.offset = 5;\n                        v.blue.offset = 0;\n                        v.red.length = 5;\n                        v.green.length = 6;\n                        v.blue.length = 5;\n                        v.transp.offset = v.transp.length = 0;\n                        break;\n                case 24:\n                        nom = 4;\n                        den = 1;\n                        v.red.offset = 16;\n                        v.green.offset = 8;\n                        v.blue.offset = 0;\n                        v.red.length = v.blue.length = v.green.length = 8;\n                        v.transp.offset = v.transp.length = 0;\n                        break;\n                case 32:\n                        nom = 4;\n                        den = 1;\n                        v.red.offset = 16;\n                        v.green.offset = 8;\n                        v.blue.offset = 0;\n                        v.red.length = v.blue.length = v.green.length = 8;\n                        v.transp.offset = 24;\n                        v.transp.length = 8;\n                        break;\n                default:\n                        printk (\"radeonfb: mode %dx%dx%d rejected, color depth invalid\\n\",\n                                var->xres, var->yres, var->bits_per_pixel);\n                        return -EINVAL;\n        }\n\n\tif (v.yres_virtual < v.yres)\n\t\tv.yres_virtual = v.yres;\n\tif (v.xres_virtual < v.xres)\n\t\tv.xres_virtual = v.xres;\n\n\n\t \n  \tif (rinfo->info->flags & FBINFO_HWACCEL_DISABLED) {\n\t\tv.xres_virtual = v.xres_virtual & ~7ul;\n\t} else {\n\t\tpitch = ((v.xres_virtual * ((v.bits_per_pixel + 1) / 8) + 0x3f)\n \t\t\t\t& ~(0x3f)) >> 6;\n\t\tv.xres_virtual = (pitch << 6) / ((v.bits_per_pixel + 1) / 8);\n\t}\n\n\tif (((v.xres_virtual * v.yres_virtual * nom) / den) > rinfo->mapped_vram)\n\t\treturn -EINVAL;\n\n\tif (v.xres_virtual < v.xres)\n\t\tv.xres = v.xres_virtual;\n\n        if (v.xoffset > v.xres_virtual - v.xres)\n                v.xoffset = v.xres_virtual - v.xres - 1;\n\n        if (v.yoffset > v.yres_virtual - v.yres)\n                v.yoffset = v.yres_virtual - v.yres - 1;\n\n        v.red.msb_right = v.green.msb_right = v.blue.msb_right =\n                          v.transp.offset = v.transp.length =\n                          v.transp.msb_right = 0;\n\n        memcpy(var, &v, sizeof(v));\n\n        return 0;\n}\n\n\nstatic int radeonfb_pan_display (struct fb_var_screeninfo *var,\n                                 struct fb_info *info)\n{\n        struct radeonfb_info *rinfo = info->par;\n\n\tif ((var->xoffset + info->var.xres > info->var.xres_virtual)\n\t    || (var->yoffset + info->var.yres > info->var.yres_virtual))\n\t\treturn -EINVAL;\n\n        if (rinfo->asleep)\n        \treturn 0;\n\n\tradeon_fifo_wait(2);\n\tOUTREG(CRTC_OFFSET, (var->yoffset * info->fix.line_length +\n\t\t\t     var->xoffset * info->var.bits_per_pixel / 8) & ~7);\n        return 0;\n}\n\n\nstatic int radeonfb_ioctl (struct fb_info *info, unsigned int cmd,\n                           unsigned long arg)\n{\n        struct radeonfb_info *rinfo = info->par;\n\tunsigned int tmp;\n\tu32 value = 0;\n\tint rc;\n\n\tswitch (cmd) {\n\t\t \n\t\tcase FBIO_RADEON_SET_MIRROR:\n\t\t\tif (!rinfo->is_mobility)\n\t\t\t\treturn -EINVAL;\n\n\t\t\trc = get_user(value, (__u32 __user *)arg);\n\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tradeon_fifo_wait(2);\n\t\t\tif (value & 0x01) {\n\t\t\t\ttmp = INREG(LVDS_GEN_CNTL);\n\n\t\t\t\ttmp |= (LVDS_ON | LVDS_BLON);\n\t\t\t} else {\n\t\t\t\ttmp = INREG(LVDS_GEN_CNTL);\n\n\t\t\t\ttmp &= ~(LVDS_ON | LVDS_BLON);\n\t\t\t}\n\n\t\t\tOUTREG(LVDS_GEN_CNTL, tmp);\n\n\t\t\tif (value & 0x02) {\n\t\t\t\ttmp = INREG(CRTC_EXT_CNTL);\n\t\t\t\ttmp |= CRTC_CRT_ON;\n\n\t\t\t\tmirror = 1;\n\t\t\t} else {\n\t\t\t\ttmp = INREG(CRTC_EXT_CNTL);\n\t\t\t\ttmp &= ~CRTC_CRT_ON;\n\n\t\t\t\tmirror = 0;\n\t\t\t}\n\n\t\t\tOUTREG(CRTC_EXT_CNTL, tmp);\n\n\t\t\treturn 0;\n\t\tcase FBIO_RADEON_GET_MIRROR:\n\t\t\tif (!rinfo->is_mobility)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttmp = INREG(LVDS_GEN_CNTL);\n\t\t\tif ((LVDS_ON | LVDS_BLON) & tmp)\n\t\t\t\tvalue |= 0x01;\n\n\t\t\ttmp = INREG(CRTC_EXT_CNTL);\n\t\t\tif (CRTC_CRT_ON & tmp)\n\t\t\t\tvalue |= 0x02;\n\n\t\t\treturn put_user(value, (__u32 __user *)arg);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\n\nint radeon_screen_blank(struct radeonfb_info *rinfo, int blank, int mode_switch)\n{\n        u32 val;\n\tu32 tmp_pix_clks;\n\tint unblank = 0;\n\n\tif (rinfo->lock_blank)\n\t\treturn 0;\n\n\tradeon_engine_idle();\n\n\tval = INREG(CRTC_EXT_CNTL);\n        val &= ~(CRTC_DISPLAY_DIS | CRTC_HSYNC_DIS |\n                 CRTC_VSYNC_DIS);\n        switch (blank) {\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tval |= (CRTC_DISPLAY_DIS | CRTC_VSYNC_DIS);\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tval |= (CRTC_DISPLAY_DIS | CRTC_HSYNC_DIS);\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tval |= (CRTC_DISPLAY_DIS | CRTC_VSYNC_DIS |\n\t\t\tCRTC_HSYNC_DIS);\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\tval |= CRTC_DISPLAY_DIS;\n\t\tbreak;\n\tcase FB_BLANK_UNBLANK:\n\tdefault:\n\t\tunblank = 1;\n        }\n\tOUTREG(CRTC_EXT_CNTL, val);\n\n\n\tswitch (rinfo->mon1_type) {\n\tcase MT_DFP:\n\t\tif (unblank)\n\t\t\tOUTREGP(FP_GEN_CNTL, (FP_FPON | FP_TMDS_EN),\n\t\t\t\t~(FP_FPON | FP_TMDS_EN));\n\t\telse {\n\t\t\tif (mode_switch || blank == FB_BLANK_NORMAL)\n\t\t\t\tbreak;\n\t\t\tOUTREGP(FP_GEN_CNTL, 0, ~(FP_FPON | FP_TMDS_EN));\n\t\t}\n\t\tbreak;\n\tcase MT_LCD:\n\t\tdel_timer_sync(&rinfo->lvds_timer);\n\t\tval = INREG(LVDS_GEN_CNTL);\n\t\tif (unblank) {\n\t\t\tu32 target_val = (val & ~LVDS_DISPLAY_DIS) | LVDS_BLON | LVDS_ON\n\t\t\t\t| LVDS_EN | (rinfo->init_state.lvds_gen_cntl\n\t\t\t\t\t     & (LVDS_DIGON | LVDS_BL_MOD_EN));\n\t\t\tif ((val ^ target_val) == LVDS_DISPLAY_DIS)\n\t\t\t\tOUTREG(LVDS_GEN_CNTL, target_val);\n\t\t\telse if ((val ^ target_val) != 0) {\n\t\t\t\tOUTREG(LVDS_GEN_CNTL, target_val\n\t\t\t\t       & ~(LVDS_ON | LVDS_BL_MOD_EN));\n\t\t\t\trinfo->init_state.lvds_gen_cntl &= ~LVDS_STATE_MASK;\n\t\t\t\trinfo->init_state.lvds_gen_cntl |=\n\t\t\t\t\ttarget_val & LVDS_STATE_MASK;\n\t\t\t\tif (mode_switch) {\n\t\t\t\t\tradeon_msleep(rinfo->panel_info.pwr_delay);\n\t\t\t\t\tOUTREG(LVDS_GEN_CNTL, target_val);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trinfo->pending_lvds_gen_cntl = target_val;\n\t\t\t\t\tmod_timer(&rinfo->lvds_timer,\n\t\t\t\t\t   jiffies +\n\t\t\t\t\t   msecs_to_jiffies(rinfo->panel_info.pwr_delay));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tval |= LVDS_DISPLAY_DIS;\n\t\t\tOUTREG(LVDS_GEN_CNTL, val);\n\n\t\t\t \n\t\t\tif (mode_switch || blank == FB_BLANK_NORMAL)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\ttmp_pix_clks = INPLL(PIXCLKS_CNTL);\n\t\t\tif (rinfo->is_mobility || rinfo->is_IGP)\n\t\t\t\tOUTPLLP(PIXCLKS_CNTL, 0, ~PIXCLK_LVDS_ALWAYS_ONb);\n\t\t\tval &= ~(LVDS_BL_MOD_EN);\n\t\t\tOUTREG(LVDS_GEN_CNTL, val);\n\t\t\tudelay(100);\n\t\t\tval &= ~(LVDS_ON | LVDS_EN);\n\t\t\tOUTREG(LVDS_GEN_CNTL, val);\n\t\t\tval &= ~LVDS_DIGON;\n\t\t\trinfo->pending_lvds_gen_cntl = val;\n\t\t\tmod_timer(&rinfo->lvds_timer,\n\t\t\t\t  jiffies +\n\t\t\t\t  msecs_to_jiffies(rinfo->panel_info.pwr_delay));\n\t\t\trinfo->init_state.lvds_gen_cntl &= ~LVDS_STATE_MASK;\n\t\t\trinfo->init_state.lvds_gen_cntl |= val & LVDS_STATE_MASK;\n\t\t\tif (rinfo->is_mobility || rinfo->is_IGP)\n\t\t\t\tOUTPLL(PIXCLKS_CNTL, tmp_pix_clks);\n\t\t}\n\t\tbreak;\n\tcase MT_CRT:\n\t\t \n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int radeonfb_blank (int blank, struct fb_info *info)\n{\n        struct radeonfb_info *rinfo = info->par;\n\n\tif (rinfo->asleep)\n\t\treturn 0;\n\n\treturn radeon_screen_blank(rinfo, blank, 0);\n}\n\nstatic int radeon_setcolreg (unsigned regno, unsigned red, unsigned green,\n                             unsigned blue, unsigned transp,\n\t\t\t     struct radeonfb_info *rinfo)\n{\n\tu32 pindex;\n\tunsigned int i;\n\n\n\tif (regno > 255)\n\t\treturn -EINVAL;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\trinfo->palette[regno].red = red;\n\trinfo->palette[regno].green = green;\n\trinfo->palette[regno].blue = blue;\n\n         \n        pindex = regno;\n\n        if (!rinfo->asleep) {\n\t\tradeon_fifo_wait(9);\n\n\t\tif (rinfo->bpp == 16) {\n\t\t\tpindex = regno * 8;\n\n\t\t\tif (rinfo->depth == 16 && regno > 63)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (rinfo->depth == 15 && regno > 31)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tif (rinfo->depth == 16) {\n\t\t                OUTREG(PALETTE_INDEX, pindex>>1);\n\t       \t         \tOUTREG(PALETTE_DATA,\n\t\t\t\t       (rinfo->palette[regno>>1].red << 16) |\n\t                        \t(green << 8) |\n\t\t\t\t       (rinfo->palette[regno>>1].blue));\n\t                \tgreen = rinfo->palette[regno<<1].green;\n\t        \t}\n\t\t}\n\n\t\tif (rinfo->depth != 16 || regno < 32) {\n\t\t\tOUTREG(PALETTE_INDEX, pindex);\n\t\t\tOUTREG(PALETTE_DATA, (red << 16) |\n\t\t\t       (green << 8) | blue);\n\t\t}\n\t}\n \tif (regno < 16) {\n\t\tu32 *pal = rinfo->info->pseudo_palette;\n        \tswitch (rinfo->depth) {\n\t\tcase 15:\n\t\t\tpal[regno] = (regno << 10) | (regno << 5) | regno;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tpal[regno] = (regno << 11) | (regno << 5) | regno;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tpal[regno] = (regno << 16) | (regno << 8) | regno;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\ti = (regno << 8) | regno;\n\t\t\tpal[regno] = (i << 16) | i;\n\t\t\tbreak;\n\t\t}\n        }\n\treturn 0;\n}\n\nstatic int radeonfb_setcolreg (unsigned regno, unsigned red, unsigned green,\n\t\t\t       unsigned blue, unsigned transp,\n\t\t\t       struct fb_info *info)\n{\n        struct radeonfb_info *rinfo = info->par;\n\tu32 dac_cntl2, vclk_cntl = 0;\n\tint rc;\n\n        if (!rinfo->asleep) {\n\t\tif (rinfo->is_mobility) {\n\t\t\tvclk_cntl = INPLL(VCLK_ECP_CNTL);\n\t\t\tOUTPLL(VCLK_ECP_CNTL,\n\t\t\t       vclk_cntl & ~PIXCLK_DAC_ALWAYS_ONb);\n\t\t}\n\n\t\t \n\t\tif (rinfo->has_CRTC2) {\n\t\t\tdac_cntl2 = INREG(DAC_CNTL2);\n\t\t\tdac_cntl2 &= ~DAC2_PALETTE_ACCESS_CNTL;\n\t\t\tOUTREG(DAC_CNTL2, dac_cntl2);\n\t\t}\n\t}\n\n\trc = radeon_setcolreg (regno, red, green, blue, transp, rinfo);\n\n\tif (!rinfo->asleep && rinfo->is_mobility)\n\t\tOUTPLL(VCLK_ECP_CNTL, vclk_cntl);\n\n\treturn rc;\n}\n\nstatic int radeonfb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n        struct radeonfb_info *rinfo = info->par;\n\tu16 *red, *green, *blue, *transp;\n\tu32 dac_cntl2, vclk_cntl = 0;\n\tint i, start, rc = 0;\n\n        if (!rinfo->asleep) {\n\t\tif (rinfo->is_mobility) {\n\t\t\tvclk_cntl = INPLL(VCLK_ECP_CNTL);\n\t\t\tOUTPLL(VCLK_ECP_CNTL,\n\t\t\t       vclk_cntl & ~PIXCLK_DAC_ALWAYS_ONb);\n\t\t}\n\n\t\t \n\t\tif (rinfo->has_CRTC2) {\n\t\t\tdac_cntl2 = INREG(DAC_CNTL2);\n\t\t\tdac_cntl2 &= ~DAC2_PALETTE_ACCESS_CNTL;\n\t\t\tOUTREG(DAC_CNTL2, dac_cntl2);\n\t\t}\n\t}\n\n\tred = cmap->red;\n\tgreen = cmap->green;\n\tblue = cmap->blue;\n\ttransp = cmap->transp;\n\tstart = cmap->start;\n\n\tfor (i = 0; i < cmap->len; i++) {\n\t\tu_int hred, hgreen, hblue, htransp = 0xffff;\n\n\t\thred = *red++;\n\t\thgreen = *green++;\n\t\thblue = *blue++;\n\t\tif (transp)\n\t\t\thtransp = *transp++;\n\t\trc = radeon_setcolreg (start++, hred, hgreen, hblue, htransp,\n\t\t\t\t       rinfo);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\tif (!rinfo->asleep && rinfo->is_mobility)\n\t\tOUTPLL(VCLK_ECP_CNTL, vclk_cntl);\n\n\treturn rc;\n}\n\nstatic void radeon_save_state (struct radeonfb_info *rinfo,\n\t\t\t       struct radeon_regs *save)\n{\n\t \n\tsave->crtc_gen_cntl = INREG(CRTC_GEN_CNTL);\n\tsave->crtc_ext_cntl = INREG(CRTC_EXT_CNTL);\n\tsave->crtc_more_cntl = INREG(CRTC_MORE_CNTL);\n\tsave->dac_cntl = INREG(DAC_CNTL);\n        save->crtc_h_total_disp = INREG(CRTC_H_TOTAL_DISP);\n        save->crtc_h_sync_strt_wid = INREG(CRTC_H_SYNC_STRT_WID);\n        save->crtc_v_total_disp = INREG(CRTC_V_TOTAL_DISP);\n        save->crtc_v_sync_strt_wid = INREG(CRTC_V_SYNC_STRT_WID);\n\tsave->crtc_pitch = INREG(CRTC_PITCH);\n\tsave->surface_cntl = INREG(SURFACE_CNTL);\n\n\t \n\tsave->fp_crtc_h_total_disp = INREG(FP_CRTC_H_TOTAL_DISP);\n\tsave->fp_crtc_v_total_disp = INREG(FP_CRTC_V_TOTAL_DISP);\n\tsave->fp_gen_cntl = INREG(FP_GEN_CNTL);\n\tsave->fp_h_sync_strt_wid = INREG(FP_H_SYNC_STRT_WID);\n\tsave->fp_horz_stretch = INREG(FP_HORZ_STRETCH);\n\tsave->fp_v_sync_strt_wid = INREG(FP_V_SYNC_STRT_WID);\n\tsave->fp_vert_stretch = INREG(FP_VERT_STRETCH);\n\tsave->lvds_gen_cntl = INREG(LVDS_GEN_CNTL);\n\tsave->lvds_pll_cntl = INREG(LVDS_PLL_CNTL);\n\tsave->tmds_crc = INREG(TMDS_CRC);\n\tsave->tmds_transmitter_cntl = INREG(TMDS_TRANSMITTER_CNTL);\n\tsave->vclk_ecp_cntl = INPLL(VCLK_ECP_CNTL);\n\n\t \n\tsave->clk_cntl_index = INREG(CLOCK_CNTL_INDEX) & ~0x3f;\n\tradeon_pll_errata_after_index(rinfo);\n\tsave->ppll_div_3 = INPLL(PPLL_DIV_3);\n\tsave->ppll_ref_div = INPLL(PPLL_REF_DIV);\n}\n\n\nstatic void radeon_write_pll_regs(struct radeonfb_info *rinfo, struct radeon_regs *mode)\n{\n\tint i;\n\n\tradeon_fifo_wait(20);\n\n\t \n\tif (rinfo->is_mobility) {\n\t         \n\t\tif ((mode->ppll_ref_div == (INPLL(PPLL_REF_DIV) & PPLL_REF_DIV_MASK)) &&\n\t\t    (mode->ppll_div_3 == (INPLL(PPLL_DIV_3) &\n\t\t\t\t\t  (PPLL_POST3_DIV_MASK | PPLL_FB3_DIV_MASK)))) {\n\t\t\t \n\t\t\tOUTREGP(CLOCK_CNTL_INDEX,\n\t\t\t\tmode->clk_cntl_index & PPLL_DIV_SEL_MASK,\n\t\t\t\t~PPLL_DIV_SEL_MASK);\n\t\t\tradeon_pll_errata_after_index(rinfo);\n\t\t\tradeon_pll_errata_after_data(rinfo);\n            \t\treturn;\n\t\t}\n\t}\n\n\t \n\tOUTPLLP(VCLK_ECP_CNTL, VCLK_SRC_SEL_CPUCLK, ~VCLK_SRC_SEL_MASK);\n\n\t \n\tOUTPLLP(PPLL_CNTL,\n\t\tPPLL_RESET | PPLL_ATOMIC_UPDATE_EN | PPLL_VGA_ATOMIC_UPDATE_EN,\n\t\t~(PPLL_RESET | PPLL_ATOMIC_UPDATE_EN | PPLL_VGA_ATOMIC_UPDATE_EN));\n\n\t \n\tOUTREGP(CLOCK_CNTL_INDEX,\n\t\tmode->clk_cntl_index & PPLL_DIV_SEL_MASK,\n\t\t~PPLL_DIV_SEL_MASK);\n\tradeon_pll_errata_after_index(rinfo);\n\tradeon_pll_errata_after_data(rinfo);\n\n\t \n\tif (IS_R300_VARIANT(rinfo) ||\n\t    rinfo->family == CHIP_FAMILY_RS300 ||\n\t    rinfo->family == CHIP_FAMILY_RS400 ||\n\t    rinfo->family == CHIP_FAMILY_RS480) {\n\t\tif (mode->ppll_ref_div & R300_PPLL_REF_DIV_ACC_MASK) {\n\t\t\t \n\t\t\tOUTPLLP(PPLL_REF_DIV, mode->ppll_ref_div, 0);\n\t\t} else {\n\t\t\t \n\t\t\tOUTPLLP(PPLL_REF_DIV,\n\t\t\t\t(mode->ppll_ref_div << R300_PPLL_REF_DIV_ACC_SHIFT),\n\t\t\t\t~R300_PPLL_REF_DIV_ACC_MASK);\n\t\t}\n\t} else\n\t\tOUTPLLP(PPLL_REF_DIV, mode->ppll_ref_div, ~PPLL_REF_DIV_MASK);\n\n\t \n\tOUTPLLP(PPLL_DIV_3, mode->ppll_div_3, ~PPLL_FB3_DIV_MASK);\n\tOUTPLLP(PPLL_DIV_3, mode->ppll_div_3, ~PPLL_POST3_DIV_MASK);\n\n\t \n\twhile (INPLL(PPLL_REF_DIV) & PPLL_ATOMIC_UPDATE_R)\n\t\t;\n\tOUTPLLP(PPLL_REF_DIV, PPLL_ATOMIC_UPDATE_W, ~PPLL_ATOMIC_UPDATE_W);\n\n\t \n\t \n\tfor (i = 0; (i < 10000 && INPLL(PPLL_REF_DIV) & PPLL_ATOMIC_UPDATE_R); i++)\n\t\t;\n\n\tOUTPLL(HTOTAL_CNTL, 0);\n\n\t \n\tOUTPLLP(PPLL_CNTL, 0,\n\t\t~(PPLL_RESET | PPLL_SLEEP | PPLL_ATOMIC_UPDATE_EN | PPLL_VGA_ATOMIC_UPDATE_EN));\n\n\t \n       \tradeon_msleep(5);\n\n\t \n\tOUTPLLP(VCLK_ECP_CNTL, VCLK_SRC_SEL_PPLLCLK, ~VCLK_SRC_SEL_MASK);\n}\n\n \nstatic void radeon_lvds_timer_func(struct timer_list *t)\n{\n\tstruct radeonfb_info *rinfo = from_timer(rinfo, t, lvds_timer);\n\n\tradeon_engine_idle();\n\n\tOUTREG(LVDS_GEN_CNTL, rinfo->pending_lvds_gen_cntl);\n}\n\n \nvoid radeon_write_mode (struct radeonfb_info *rinfo, struct radeon_regs *mode,\n\t\t\tint regs_only)\n{\n\tint i;\n\tint primary_mon = PRIMARY_MONITOR(rinfo);\n\n\tif (nomodeset)\n\t\treturn;\n\n\tif (!regs_only)\n\t\tradeon_screen_blank(rinfo, FB_BLANK_NORMAL, 0);\n\n\tradeon_fifo_wait(31);\n\tfor (i=0; i<10; i++)\n\t\tOUTREG(common_regs[i].reg, common_regs[i].val);\n\n\t \n\tfor (i=0; i<8; i++) {\n\t\tOUTREG(SURFACE0_LOWER_BOUND + 0x10*i, mode->surf_lower_bound[i]);\n\t\tOUTREG(SURFACE0_UPPER_BOUND + 0x10*i, mode->surf_upper_bound[i]);\n\t\tOUTREG(SURFACE0_INFO + 0x10*i, mode->surf_info[i]);\n\t}\n\n\tOUTREG(CRTC_GEN_CNTL, mode->crtc_gen_cntl);\n\tOUTREGP(CRTC_EXT_CNTL, mode->crtc_ext_cntl,\n\t\t~(CRTC_HSYNC_DIS | CRTC_VSYNC_DIS | CRTC_DISPLAY_DIS));\n\tOUTREG(CRTC_MORE_CNTL, mode->crtc_more_cntl);\n\tOUTREGP(DAC_CNTL, mode->dac_cntl, DAC_RANGE_CNTL | DAC_BLANKING);\n\tOUTREG(CRTC_H_TOTAL_DISP, mode->crtc_h_total_disp);\n\tOUTREG(CRTC_H_SYNC_STRT_WID, mode->crtc_h_sync_strt_wid);\n\tOUTREG(CRTC_V_TOTAL_DISP, mode->crtc_v_total_disp);\n\tOUTREG(CRTC_V_SYNC_STRT_WID, mode->crtc_v_sync_strt_wid);\n\tOUTREG(CRTC_OFFSET, 0);\n\tOUTREG(CRTC_OFFSET_CNTL, 0);\n\tOUTREG(CRTC_PITCH, mode->crtc_pitch);\n\tOUTREG(SURFACE_CNTL, mode->surface_cntl);\n\n\tradeon_write_pll_regs(rinfo, mode);\n\n\tif ((primary_mon == MT_DFP) || (primary_mon == MT_LCD)) {\n\t\tradeon_fifo_wait(10);\n\t\tOUTREG(FP_CRTC_H_TOTAL_DISP, mode->fp_crtc_h_total_disp);\n\t\tOUTREG(FP_CRTC_V_TOTAL_DISP, mode->fp_crtc_v_total_disp);\n\t\tOUTREG(FP_H_SYNC_STRT_WID, mode->fp_h_sync_strt_wid);\n\t\tOUTREG(FP_V_SYNC_STRT_WID, mode->fp_v_sync_strt_wid);\n\t\tOUTREG(FP_HORZ_STRETCH, mode->fp_horz_stretch);\n\t\tOUTREG(FP_VERT_STRETCH, mode->fp_vert_stretch);\n\t\tOUTREG(FP_GEN_CNTL, mode->fp_gen_cntl);\n\t\tOUTREG(TMDS_CRC, mode->tmds_crc);\n\t\tOUTREG(TMDS_TRANSMITTER_CNTL, mode->tmds_transmitter_cntl);\n\t}\n\n\tif (!regs_only)\n\t\tradeon_screen_blank(rinfo, FB_BLANK_UNBLANK, 0);\n\n\tradeon_fifo_wait(2);\n\tOUTPLL(VCLK_ECP_CNTL, mode->vclk_ecp_cntl);\n\n\treturn;\n}\n\n \nstatic void radeon_calc_pll_regs(struct radeonfb_info *rinfo, struct radeon_regs *regs,\n\t\t\t\t unsigned long freq)\n{\n\tstatic const struct {\n\t\tint divider;\n\t\tint bitvalue;\n\t} *post_div,\n\t  post_divs[] = {\n\t\t{ 1,  0 },\n\t\t{ 2,  1 },\n\t\t{ 4,  2 },\n\t\t{ 8,  3 },\n\t\t{ 3,  4 },\n\t\t{ 16, 5 },\n\t\t{ 6,  6 },\n\t\t{ 12, 7 },\n\t\t{ 0,  0 },\n\t};\n\tint fb_div, pll_output_freq = 0;\n\tint uses_dvo = 0;\n\n\t \n#if 1\n\t \n\twhile (rinfo->has_CRTC2) {\n\t\tu32 fp2_gen_cntl = INREG(FP2_GEN_CNTL);\n\t\tu32 disp_output_cntl;\n\t\tint source;\n\n\t\t \n\t\tif ((fp2_gen_cntl & FP2_ON) == 0)\n\t\t\tbreak;\n\t\t \n\t\tif (rinfo->family == CHIP_FAMILY_R200 || IS_R300_VARIANT(rinfo)) {\n\t\t\tsource = (fp2_gen_cntl >> 10) & 0x3;\n\t\t\t \n\t\t\tif (source == 3) {\n\t\t\t\tdisp_output_cntl = INREG(DISP_OUTPUT_CNTL);\n\t\t\t\tsource = (disp_output_cntl >> 12) & 0x3;\n\t\t\t}\n\t\t} else\n\t\t\tsource = (fp2_gen_cntl >> 13) & 0x1;\n\t\t \n\t\tif (source == 1)\n\t\t\tbreak;\n\n\t\t \n\t\tuses_dvo = 1;\n\t\tbreak;\n\t}\n#else\n\tuses_dvo = 1;\n#endif\n\tif (freq > rinfo->pll.ppll_max)\n\t\tfreq = rinfo->pll.ppll_max;\n\tif (freq*12 < rinfo->pll.ppll_min)\n\t\tfreq = rinfo->pll.ppll_min / 12;\n\tpr_debug(\"freq = %lu, PLL min = %u, PLL max = %u\\n\",\n\t       freq, rinfo->pll.ppll_min, rinfo->pll.ppll_max);\n\n\tfor (post_div = &post_divs[0]; post_div->divider; ++post_div) {\n\t\tpll_output_freq = post_div->divider * freq;\n\t\t \n\t\tif (uses_dvo && (post_div->divider & 1))\n\t\t\tcontinue;\n\t\tif (pll_output_freq >= rinfo->pll.ppll_min  &&\n\t\t    pll_output_freq <= rinfo->pll.ppll_max)\n\t\t\tbreak;\n\t}\n\n\t \n\tif ( !post_div->divider ) {\n\t\tpost_div = &post_divs[post_div->bitvalue];\n\t\tpll_output_freq = post_div->divider * freq;\n\t}\n\tpr_debug(\"ref_div = %d, ref_clk = %d, output_freq = %d\\n\",\n\t       rinfo->pll.ref_div, rinfo->pll.ref_clk,\n\t       pll_output_freq);\n\n\t \n\tif ( !post_div->divider ) {\n\t\tpost_div = &post_divs[post_div->bitvalue];\n\t\tpll_output_freq = post_div->divider * freq;\n\t}\n\tpr_debug(\"ref_div = %d, ref_clk = %d, output_freq = %d\\n\",\n\t       rinfo->pll.ref_div, rinfo->pll.ref_clk,\n\t       pll_output_freq);\n\n\tfb_div = round_div(rinfo->pll.ref_div*pll_output_freq,\n\t\t\t\t  rinfo->pll.ref_clk);\n\tregs->ppll_ref_div = rinfo->pll.ref_div;\n\tregs->ppll_div_3 = fb_div | (post_div->bitvalue << 16);\n\n\tpr_debug(\"post div = 0x%x\\n\", post_div->bitvalue);\n\tpr_debug(\"fb_div = 0x%x\\n\", fb_div);\n\tpr_debug(\"ppll_div_3 = 0x%x\\n\", regs->ppll_div_3);\n}\n\nstatic int radeonfb_set_par(struct fb_info *info)\n{\n\tstruct radeonfb_info *rinfo = info->par;\n\tstruct fb_var_screeninfo *mode = &info->var;\n\tstruct radeon_regs *newmode;\n\tint hTotal, vTotal, hSyncStart, hSyncEnd,\n\t    vSyncStart, vSyncEnd;\n\tu8 hsync_adj_tab[] = {0, 0x12, 9, 9, 6, 5};\n\tu8 hsync_fudge_fp[] = {2, 2, 0, 0, 5, 5};\n\tu32 sync, h_sync_pol, v_sync_pol, dotClock, pixClock;\n\tint i, freq;\n\tint format = 0;\n\tint nopllcalc = 0;\n\tint hsync_start, hsync_fudge, hsync_wid, vsync_wid;\n\tint primary_mon = PRIMARY_MONITOR(rinfo);\n\tint depth = var_to_depth(mode);\n\tint use_rmx = 0;\n\n\tnewmode = kmalloc(sizeof(struct radeon_regs), GFP_KERNEL);\n\tif (!newmode)\n\t\treturn -ENOMEM;\n\n\t \n\tradeon_engine_idle();\n\n\thSyncStart = mode->xres + mode->right_margin;\n\thSyncEnd = hSyncStart + mode->hsync_len;\n\thTotal = hSyncEnd + mode->left_margin;\n\n\tvSyncStart = mode->yres + mode->lower_margin;\n\tvSyncEnd = vSyncStart + mode->vsync_len;\n\tvTotal = vSyncEnd + mode->upper_margin;\n\tpixClock = mode->pixclock;\n\n\tsync = mode->sync;\n\th_sync_pol = sync & FB_SYNC_HOR_HIGH_ACT ? 0 : 1;\n\tv_sync_pol = sync & FB_SYNC_VERT_HIGH_ACT ? 0 : 1;\n\n\tif (primary_mon == MT_DFP || primary_mon == MT_LCD) {\n\t\tif (rinfo->panel_info.xres < mode->xres)\n\t\t\tmode->xres = rinfo->panel_info.xres;\n\t\tif (rinfo->panel_info.yres < mode->yres)\n\t\t\tmode->yres = rinfo->panel_info.yres;\n\n\t\thTotal = mode->xres + rinfo->panel_info.hblank;\n\t\thSyncStart = mode->xres + rinfo->panel_info.hOver_plus;\n\t\thSyncEnd = hSyncStart + rinfo->panel_info.hSync_width;\n\n\t\tvTotal = mode->yres + rinfo->panel_info.vblank;\n\t\tvSyncStart = mode->yres + rinfo->panel_info.vOver_plus;\n\t\tvSyncEnd = vSyncStart + rinfo->panel_info.vSync_width;\n\n\t\th_sync_pol = !rinfo->panel_info.hAct_high;\n\t\tv_sync_pol = !rinfo->panel_info.vAct_high;\n\n\t\tpixClock = 100000000 / rinfo->panel_info.clock;\n\n\t\tif (rinfo->panel_info.use_bios_dividers) {\n\t\t\tnopllcalc = 1;\n\t\t\tnewmode->ppll_div_3 = rinfo->panel_info.fbk_divider |\n\t\t\t\t(rinfo->panel_info.post_divider << 16);\n\t\t\tnewmode->ppll_ref_div = rinfo->panel_info.ref_divider;\n\t\t}\n\t}\n\tdotClock = 1000000000 / pixClock;\n\tfreq = dotClock / 10;  \n\n\tpr_debug(\"hStart = %d, hEnd = %d, hTotal = %d\\n\",\n\t\thSyncStart, hSyncEnd, hTotal);\n\tpr_debug(\"vStart = %d, vEnd = %d, vTotal = %d\\n\",\n\t\tvSyncStart, vSyncEnd, vTotal);\n\n\thsync_wid = (hSyncEnd - hSyncStart) / 8;\n\tvsync_wid = vSyncEnd - vSyncStart;\n\tif (hsync_wid == 0)\n\t\thsync_wid = 1;\n\telse if (hsync_wid > 0x3f)\t \n\t\thsync_wid = 0x3f;\n\n\tif (vsync_wid == 0)\n\t\tvsync_wid = 1;\n\telse if (vsync_wid > 0x1f)\t \n\t\tvsync_wid = 0x1f;\n\n\tformat = radeon_get_dstbpp(depth);\n\n\tif ((primary_mon == MT_DFP) || (primary_mon == MT_LCD))\n\t\thsync_fudge = hsync_fudge_fp[format-1];\n\telse\n\t\thsync_fudge = hsync_adj_tab[format-1];\n\n\thsync_start = hSyncStart - 8 + hsync_fudge;\n\n\tnewmode->crtc_gen_cntl = CRTC_EXT_DISP_EN | CRTC_EN |\n\t\t\t\t(format << 8);\n\n\t \n\tnewmode->crtc_more_cntl = rinfo->init_state.crtc_more_cntl;\n\tnewmode->crtc_more_cntl &= 0xfffffff0;\n\n\tif ((primary_mon == MT_DFP) || (primary_mon == MT_LCD)) {\n\t\tnewmode->crtc_ext_cntl = VGA_ATI_LINEAR | XCRT_CNT_EN;\n\t\tif (mirror)\n\t\t\tnewmode->crtc_ext_cntl |= CRTC_CRT_ON;\n\n\t\tnewmode->crtc_gen_cntl &= ~(CRTC_DBL_SCAN_EN |\n\t\t\t\t\t   CRTC_INTERLACE_EN);\n\t} else {\n\t\tnewmode->crtc_ext_cntl = VGA_ATI_LINEAR | XCRT_CNT_EN |\n\t\t\t\t\tCRTC_CRT_ON;\n\t}\n\n\tnewmode->dac_cntl =   DAC_MASK_ALL | DAC_VGA_ADR_EN |\n\t\t\t   DAC_8BIT_EN;\n\n\tnewmode->crtc_h_total_disp = ((((hTotal / 8) - 1) & 0x3ff) |\n\t\t\t\t     (((mode->xres / 8) - 1) << 16));\n\n\tnewmode->crtc_h_sync_strt_wid = ((hsync_start & 0x1fff) |\n\t\t\t\t\t(hsync_wid << 16) | (h_sync_pol << 23));\n\n\tnewmode->crtc_v_total_disp = ((vTotal - 1) & 0xffff) |\n\t\t\t\t    ((mode->yres - 1) << 16);\n\n\tnewmode->crtc_v_sync_strt_wid = (((vSyncStart - 1) & 0xfff) |\n\t\t\t\t\t (vsync_wid << 16) | (v_sync_pol  << 23));\n\n\tif (!(info->flags & FBINFO_HWACCEL_DISABLED)) {\n\t\t \n\t\trinfo->pitch = ((mode->xres_virtual * ((mode->bits_per_pixel + 1) / 8) + 0x3f)\n \t\t\t\t& ~(0x3f)) >> 6;\n\n\t\t \n\t\tnewmode->crtc_pitch = (rinfo->pitch << 3) / ((mode->bits_per_pixel + 1) / 8);\n\t} else\n\t\tnewmode->crtc_pitch = (mode->xres_virtual >> 3);\n\n\tnewmode->crtc_pitch |= (newmode->crtc_pitch << 16);\n\n\t \n\tnewmode->surface_cntl = 0;\n\n#if defined(__BIG_ENDIAN)\n\n\t \n\tswitch (mode->bits_per_pixel) {\n\t\tcase 16:\n\t\t\tnewmode->surface_cntl |= NONSURF_AP0_SWP_16BPP;\n\t\t\tnewmode->surface_cntl |= NONSURF_AP1_SWP_16BPP;\n\t\t\tbreak;\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tnewmode->surface_cntl |= NONSURF_AP0_SWP_32BPP;\n\t\t\tnewmode->surface_cntl |= NONSURF_AP1_SWP_32BPP;\n\t\t\tbreak;\n\t}\n#endif\n\n\t \n\tfor (i=0; i<8; i++) {\n\t\tnewmode->surf_lower_bound[i] = 0;\n\t\tnewmode->surf_upper_bound[i] = 0x1f;\n\t\tnewmode->surf_info[i] = 0;\n\t}\n\n\tpr_debug(\"h_total_disp = 0x%x\\t   hsync_strt_wid = 0x%x\\n\",\n\t\tnewmode->crtc_h_total_disp, newmode->crtc_h_sync_strt_wid);\n\tpr_debug(\"v_total_disp = 0x%x\\t   vsync_strt_wid = 0x%x\\n\",\n\t\tnewmode->crtc_v_total_disp, newmode->crtc_v_sync_strt_wid);\n\n\trinfo->bpp = mode->bits_per_pixel;\n\trinfo->depth = depth;\n\n\tpr_debug(\"pixclock = %lu\\n\", (unsigned long)pixClock);\n\tpr_debug(\"freq = %lu\\n\", (unsigned long)freq);\n\n\t \n\tnewmode->clk_cntl_index = 0x300;\n\n\t \n\tif (!nopllcalc)\n\t\tradeon_calc_pll_regs(rinfo, newmode, freq);\n\n\tnewmode->vclk_ecp_cntl = rinfo->init_state.vclk_ecp_cntl;\n\n\tif ((primary_mon == MT_DFP) || (primary_mon == MT_LCD)) {\n\t\tunsigned int hRatio, vRatio;\n\n\t\tif (mode->xres > rinfo->panel_info.xres)\n\t\t\tmode->xres = rinfo->panel_info.xres;\n\t\tif (mode->yres > rinfo->panel_info.yres)\n\t\t\tmode->yres = rinfo->panel_info.yres;\n\n\t\tnewmode->fp_horz_stretch = (((rinfo->panel_info.xres / 8) - 1)\n\t\t\t\t\t   << HORZ_PANEL_SHIFT);\n\t\tnewmode->fp_vert_stretch = ((rinfo->panel_info.yres - 1)\n\t\t\t\t\t   << VERT_PANEL_SHIFT);\n\n\t\tif (mode->xres != rinfo->panel_info.xres) {\n\t\t\thRatio = round_div(mode->xres * HORZ_STRETCH_RATIO_MAX,\n\t\t\t\t\t   rinfo->panel_info.xres);\n\t\t\tnewmode->fp_horz_stretch = (((((unsigned long)hRatio) & HORZ_STRETCH_RATIO_MASK)) |\n\t\t\t\t\t\t   (newmode->fp_horz_stretch &\n\t\t\t\t\t\t    (HORZ_PANEL_SIZE | HORZ_FP_LOOP_STRETCH |\n\t\t\t\t\t\t     HORZ_AUTO_RATIO_INC)));\n\t\t\tnewmode->fp_horz_stretch |= (HORZ_STRETCH_BLEND |\n\t\t\t\t\t\t    HORZ_STRETCH_ENABLE);\n\t\t\tuse_rmx = 1;\n\t\t}\n\t\tnewmode->fp_horz_stretch &= ~HORZ_AUTO_RATIO;\n\n\t\tif (mode->yres != rinfo->panel_info.yres) {\n\t\t\tvRatio = round_div(mode->yres * VERT_STRETCH_RATIO_MAX,\n\t\t\t\t\t   rinfo->panel_info.yres);\n\t\t\tnewmode->fp_vert_stretch = (((((unsigned long)vRatio) & VERT_STRETCH_RATIO_MASK)) |\n\t\t\t\t\t\t   (newmode->fp_vert_stretch &\n\t\t\t\t\t\t   (VERT_PANEL_SIZE | VERT_STRETCH_RESERVED)));\n\t\t\tnewmode->fp_vert_stretch |= (VERT_STRETCH_BLEND |\n\t\t\t\t\t\t    VERT_STRETCH_ENABLE);\n\t\t\tuse_rmx = 1;\n\t\t}\n\t\tnewmode->fp_vert_stretch &= ~VERT_AUTO_RATIO_EN;\n\n\t\tnewmode->fp_gen_cntl = (rinfo->init_state.fp_gen_cntl & (u32)\n\t\t\t\t       ~(FP_SEL_CRTC2 |\n\t\t\t\t\t FP_RMX_HVSYNC_CONTROL_EN |\n\t\t\t\t\t FP_DFP_SYNC_SEL |\n\t\t\t\t\t FP_CRT_SYNC_SEL |\n\t\t\t\t\t FP_CRTC_LOCK_8DOT |\n\t\t\t\t\t FP_USE_SHADOW_EN |\n\t\t\t\t\t FP_CRTC_USE_SHADOW_VEND |\n\t\t\t\t\t FP_CRT_SYNC_ALT));\n\n\t\tnewmode->fp_gen_cntl |= (FP_CRTC_DONT_SHADOW_VPAR |\n\t\t\t\t\tFP_CRTC_DONT_SHADOW_HEND |\n\t\t\t\t\tFP_PANEL_FORMAT);\n\n\t\tif (IS_R300_VARIANT(rinfo) ||\n\t\t    (rinfo->family == CHIP_FAMILY_R200)) {\n\t\t\tnewmode->fp_gen_cntl &= ~R200_FP_SOURCE_SEL_MASK;\n\t\t\tif (use_rmx)\n\t\t\t\tnewmode->fp_gen_cntl |= R200_FP_SOURCE_SEL_RMX;\n\t\t\telse\n\t\t\t\tnewmode->fp_gen_cntl |= R200_FP_SOURCE_SEL_CRTC1;\n\t\t} else\n\t\t\tnewmode->fp_gen_cntl |= FP_SEL_CRTC1;\n\n\t\tnewmode->lvds_gen_cntl = rinfo->init_state.lvds_gen_cntl;\n\t\tnewmode->lvds_pll_cntl = rinfo->init_state.lvds_pll_cntl;\n\t\tnewmode->tmds_crc = rinfo->init_state.tmds_crc;\n\t\tnewmode->tmds_transmitter_cntl = rinfo->init_state.tmds_transmitter_cntl;\n\n\t\tif (primary_mon == MT_LCD) {\n\t\t\tnewmode->lvds_gen_cntl |= (LVDS_ON | LVDS_BLON);\n\t\t\tnewmode->fp_gen_cntl &= ~(FP_FPON | FP_TMDS_EN);\n\t\t} else {\n\t\t\t \n\t\t\tnewmode->fp_gen_cntl |= (FP_FPON | FP_TMDS_EN);\n\t\t\tnewmode->tmds_transmitter_cntl &= ~(TMDS_PLLRST);\n\t\t\t \n\t\t\tif (IS_R300_VARIANT(rinfo) ||\n\t\t\t    (rinfo->family == CHIP_FAMILY_R200) || !rinfo->has_CRTC2)\n\t\t\t\tnewmode->tmds_transmitter_cntl &= ~TMDS_PLL_EN;\n\t\t\telse\n\t\t\t\tnewmode->tmds_transmitter_cntl |= TMDS_PLL_EN;\n\t\t\tnewmode->crtc_ext_cntl &= ~CRTC_CRT_ON;\n\t\t}\n\n\t\tnewmode->fp_crtc_h_total_disp = (((rinfo->panel_info.hblank / 8) & 0x3ff) |\n\t\t\t\t(((mode->xres / 8) - 1) << 16));\n\t\tnewmode->fp_crtc_v_total_disp = (rinfo->panel_info.vblank & 0xffff) |\n\t\t\t\t((mode->yres - 1) << 16);\n\t\tnewmode->fp_h_sync_strt_wid = ((rinfo->panel_info.hOver_plus & 0x1fff) |\n\t\t\t\t(hsync_wid << 16) | (h_sync_pol << 23));\n\t\tnewmode->fp_v_sync_strt_wid = ((rinfo->panel_info.vOver_plus & 0xfff) |\n\t\t\t\t(vsync_wid << 16) | (v_sync_pol  << 23));\n\t}\n\n\t \n\tif (!rinfo->asleep) {\n\t\tmemcpy(&rinfo->state, newmode, sizeof(*newmode));\n\t\tradeon_write_mode (rinfo, newmode, 0);\n\t\t \n\t\tif (!(info->flags & FBINFO_HWACCEL_DISABLED))\n\t\t\tradeonfb_engine_init (rinfo);\n\t}\n\t \n\tif (!(info->flags & FBINFO_HWACCEL_DISABLED))\n        \tinfo->fix.line_length = rinfo->pitch*64;\n        else\n\t\tinfo->fix.line_length = mode->xres_virtual\n\t\t\t* ((mode->bits_per_pixel + 1) / 8);\n        info->fix.visual = rinfo->depth == 8 ? FB_VISUAL_PSEUDOCOLOR\n\t\t: FB_VISUAL_DIRECTCOLOR;\n\n#ifdef CONFIG_BOOTX_TEXT\n\t \n\tbtext_update_display(rinfo->fb_base_phys, mode->xres, mode->yres,\n\t\t\t     rinfo->depth, info->fix.line_length);\n#endif\n\n\tkfree(newmode);\n\treturn 0;\n}\n\n\nstatic const struct fb_ops radeonfb_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_check_var\t\t= radeonfb_check_var,\n\t.fb_set_par\t\t= radeonfb_set_par,\n\t.fb_setcolreg\t\t= radeonfb_setcolreg,\n\t.fb_setcmap\t\t= radeonfb_setcmap,\n\t.fb_pan_display \t= radeonfb_pan_display,\n\t.fb_blank\t\t= radeonfb_blank,\n\t.fb_ioctl\t\t= radeonfb_ioctl,\n\t.fb_sync\t\t= radeonfb_sync,\n\t.fb_fillrect\t\t= radeonfb_fillrect,\n\t.fb_copyarea\t\t= radeonfb_copyarea,\n\t.fb_imageblit\t\t= radeonfb_imageblit,\n};\n\n\nstatic int radeon_set_fbinfo(struct radeonfb_info *rinfo)\n{\n\tstruct fb_info *info = rinfo->info;\n\n\tinfo->par = rinfo;\n\tinfo->pseudo_palette = rinfo->pseudo_palette;\n\tinfo->flags = FBINFO_HWACCEL_COPYAREA\n\t\t    | FBINFO_HWACCEL_FILLRECT\n\t\t    | FBINFO_HWACCEL_XPAN\n\t\t    | FBINFO_HWACCEL_YPAN;\n\tinfo->fbops = &radeonfb_ops;\n\tinfo->screen_base = rinfo->fb_base;\n\tinfo->screen_size = rinfo->mapped_vram;\n\t \n\tstrscpy(info->fix.id, rinfo->name, sizeof(info->fix.id));\n        info->fix.smem_start = rinfo->fb_base_phys;\n        info->fix.smem_len = rinfo->video_ram;\n        info->fix.type = FB_TYPE_PACKED_PIXELS;\n        info->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n        info->fix.xpanstep = 8;\n        info->fix.ypanstep = 1;\n        info->fix.ywrapstep = 0;\n        info->fix.type_aux = 0;\n        info->fix.mmio_start = rinfo->mmio_base_phys;\n        info->fix.mmio_len = RADEON_REGSIZE;\n\tinfo->fix.accel = FB_ACCEL_ATI_RADEON;\n\n\tfb_alloc_cmap(&info->cmap, 256, 0);\n\n\tif (noaccel)\n\t\tinfo->flags |= FBINFO_HWACCEL_DISABLED;\n\n        return 0;\n}\n\n \n#ifdef CONFIG_PPC\n#undef SET_MC_FB_FROM_APERTURE\nstatic void fixup_memory_mappings(struct radeonfb_info *rinfo)\n{\n\tu32 save_crtc_gen_cntl, save_crtc2_gen_cntl = 0;\n\tu32 save_crtc_ext_cntl;\n\tu32 aper_base, aper_size;\n\tu32 agp_base;\n\n\t \n\tif (rinfo->has_CRTC2) {\n\t\tsave_crtc2_gen_cntl = INREG(CRTC2_GEN_CNTL);\n\t\tOUTREG(CRTC2_GEN_CNTL, save_crtc2_gen_cntl | CRTC2_DISP_REQ_EN_B);\n\t}\n\tsave_crtc_gen_cntl = INREG(CRTC_GEN_CNTL);\n\tsave_crtc_ext_cntl = INREG(CRTC_EXT_CNTL);\n\n\tOUTREG(CRTC_EXT_CNTL, save_crtc_ext_cntl | CRTC_DISPLAY_DIS);\n\tOUTREG(CRTC_GEN_CNTL, save_crtc_gen_cntl | CRTC_DISP_REQ_EN_B);\n\tmdelay(100);\n\n\taper_base = INREG(CNFG_APER_0_BASE);\n\taper_size = INREG(CNFG_APER_SIZE);\n\n#ifdef SET_MC_FB_FROM_APERTURE\n\t \n\tOUTREG(MC_FB_LOCATION,\n\t\t((aper_base + aper_size - 1) & 0xffff0000) | (aper_base >> 16));\n\trinfo->fb_local_base = aper_base;\n#else\n\tOUTREG(MC_FB_LOCATION, 0x7fff0000);\n\trinfo->fb_local_base = 0;\n#endif\n\tagp_base = aper_base + aper_size;\n\tif (agp_base & 0xf0000000)\n\t\tagp_base = (aper_base | 0x0fffffff) + 1;\n\n\t \n#ifdef SET_MC_FB_FROM_APERTURE\n\tOUTREG(MC_AGP_LOCATION, 0xffff0000 | (agp_base >> 16));\n#else\n\tOUTREG(MC_AGP_LOCATION, 0xffffe000);\n#endif\n\n\t \n#ifdef SET_MC_FB_FROM_APERTURE\n\tOUTREG(DISPLAY_BASE_ADDR, aper_base);\n\tif (rinfo->has_CRTC2)\n\t\tOUTREG(CRTC2_DISPLAY_BASE_ADDR, aper_base);\n\tOUTREG(OV0_BASE_ADDR, aper_base);\n#else\n\tOUTREG(DISPLAY_BASE_ADDR, 0);\n\tif (rinfo->has_CRTC2)\n\t\tOUTREG(CRTC2_DISPLAY_BASE_ADDR, 0);\n\tOUTREG(OV0_BASE_ADDR, 0);\n#endif\n\tmdelay(100);\n\n\t \n\tOUTREG(CRTC_GEN_CNTL, save_crtc_gen_cntl);\n\tOUTREG(CRTC_EXT_CNTL, save_crtc_ext_cntl);\n\tif (rinfo->has_CRTC2)\n\t\tOUTREG(CRTC2_GEN_CNTL, save_crtc2_gen_cntl);\n\n\tpr_debug(\"aper_base: %08x MC_FB_LOC to: %08x, MC_AGP_LOC to: %08x\\n\",\n\t\taper_base,\n\t\t((aper_base + aper_size - 1) & 0xffff0000) | (aper_base >> 16),\n\t\t0xffff0000 | (agp_base >> 16));\n}\n#endif  \n\n\nstatic void radeon_identify_vram(struct radeonfb_info *rinfo)\n{\n\tu32 tmp;\n\n\t \n\tif ((rinfo->family == CHIP_FAMILY_RS100) ||\n            (rinfo->family == CHIP_FAMILY_RS200) ||\n            (rinfo->family == CHIP_FAMILY_RS300) ||\n            (rinfo->family == CHIP_FAMILY_RC410) ||\n            (rinfo->family == CHIP_FAMILY_RS400) ||\n\t    (rinfo->family == CHIP_FAMILY_RS480) ) {\n\t\tu32 tom = INREG(NB_TOM);\n\n\t\ttmp = ((((tom >> 16) - (tom & 0xffff) + 1) << 6) * 1024);\n\t\tradeon_fifo_wait(6);\n\t\tOUTREG(MC_FB_LOCATION, tom);\n\t\tOUTREG(DISPLAY_BASE_ADDR, (tom & 0xffff) << 16);\n\t\tOUTREG(CRTC2_DISPLAY_BASE_ADDR, (tom & 0xffff) << 16);\n\t\tOUTREG(OV0_BASE_ADDR, (tom & 0xffff) << 16);\n\n\t\t \n\t\tOUTREG(GRPH2_BUFFER_CNTL, INREG(GRPH2_BUFFER_CNTL) & ~0x7f0000);\n\n\t\tif ((rinfo->family == CHIP_FAMILY_RS100) ||\n\t\t    (rinfo->family == CHIP_FAMILY_RS200)) {\n\t\t\t \n\t\t\tOUTREGP(CRTC_MORE_CNTL, CRTC_H_CUTOFF_ACTIVE_EN,\n\t\t\t\t~CRTC_H_CUTOFF_ACTIVE_EN);\n\t\t}\n\t} else {\n\t\ttmp = INREG(CNFG_MEMSIZE);\n        }\n\n\t \n\trinfo->video_ram = tmp & CNFG_MEMSIZE_MASK;\n\n\t \n\tif (rinfo->video_ram == 0) {\n\t\tswitch (rinfo->pdev->device) {\n\t       \tcase PCI_CHIP_RADEON_LY:\n\t\tcase PCI_CHIP_RADEON_LZ:\n\t       \t\trinfo->video_ram = 8192 * 1024;\n\t       \t\tbreak;\n\t       \tdefault:\n\t       \t\tbreak;\n\t\t}\n\t}\n\n\n\t \n\tif (rinfo->is_IGP || (rinfo->family >= CHIP_FAMILY_R300) ||\n\t    (INREG(MEM_SDRAM_MODE_REG) & (1<<30)))\n\t\trinfo->vram_ddr = 1;\n\telse\n\t\trinfo->vram_ddr = 0;\n\n\ttmp = INREG(MEM_CNTL);\n\tif (IS_R300_VARIANT(rinfo)) {\n\t\ttmp &=  R300_MEM_NUM_CHANNELS_MASK;\n\t\tswitch (tmp) {\n\t\tcase 0:  rinfo->vram_width = 64; break;\n\t\tcase 1:  rinfo->vram_width = 128; break;\n\t\tcase 2:  rinfo->vram_width = 256; break;\n\t\tdefault: rinfo->vram_width = 128; break;\n\t\t}\n\t} else if ((rinfo->family == CHIP_FAMILY_RV100) ||\n\t\t   (rinfo->family == CHIP_FAMILY_RS100) ||\n\t\t   (rinfo->family == CHIP_FAMILY_RS200)){\n\t\tif (tmp & RV100_MEM_HALF_MODE)\n\t\t\trinfo->vram_width = 32;\n\t\telse\n\t\t\trinfo->vram_width = 64;\n\t} else {\n\t\tif (tmp & MEM_NUM_CHANNELS_MASK)\n\t\t\trinfo->vram_width = 128;\n\t\telse\n\t\t\trinfo->vram_width = 64;\n\t}\n\n\t \n\n\tpr_debug(\"radeonfb (%s): Found %ldk of %s %d bits wide videoram\\n\",\n\t       pci_name(rinfo->pdev),\n\t       rinfo->video_ram / 1024,\n\t       rinfo->vram_ddr ? \"DDR\" : \"SDRAM\",\n\t       rinfo->vram_width);\n}\n\n \n\nstatic ssize_t radeon_show_one_edid(char *buf, loff_t off, size_t count, const u8 *edid)\n{\n\treturn memory_read_from_buffer(buf, count, &off, edid, EDID_LENGTH);\n}\n\n\nstatic ssize_t radeon_show_edid1(struct file *filp, struct kobject *kobj,\n\t\t\t\t struct bin_attribute *bin_attr,\n\t\t\t\t char *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct fb_info *info = dev_get_drvdata(dev);\n        struct radeonfb_info *rinfo = info->par;\n\n\treturn radeon_show_one_edid(buf, off, count, rinfo->mon1_EDID);\n}\n\n\nstatic ssize_t radeon_show_edid2(struct file *filp, struct kobject *kobj,\n\t\t\t\t struct bin_attribute *bin_attr,\n\t\t\t\t char *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct fb_info *info = dev_get_drvdata(dev);\n        struct radeonfb_info *rinfo = info->par;\n\n\treturn radeon_show_one_edid(buf, off, count, rinfo->mon2_EDID);\n}\n\nstatic const struct bin_attribute edid1_attr = {\n\t.attr   = {\n\t\t.name\t= \"edid1\",\n\t\t.mode\t= 0444,\n\t},\n\t.size\t= EDID_LENGTH,\n\t.read\t= radeon_show_edid1,\n};\n\nstatic const struct bin_attribute edid2_attr = {\n\t.attr   = {\n\t\t.name\t= \"edid2\",\n\t\t.mode\t= 0444,\n\t},\n\t.size\t= EDID_LENGTH,\n\t.read\t= radeon_show_edid2,\n};\n\nstatic int radeonfb_pci_register(struct pci_dev *pdev,\n\t\t\t\t const struct pci_device_id *ent)\n{\n\tstruct fb_info *info;\n\tstruct radeonfb_info *rinfo;\n\tint ret;\n\tunsigned char c1, c2;\n\tint err = 0;\n\n\tpr_debug(\"radeonfb_pci_register BEGIN\\n\");\n\n\t \n\tret = pci_enable_device(pdev);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"radeonfb (%s): Cannot enable PCI device\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto err_out;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct radeonfb_info), &pdev->dev);\n\tif (!info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable;\n\t}\n\trinfo = info->par;\n\trinfo->info = info;\n\trinfo->pdev = pdev;\n\n\tspin_lock_init(&rinfo->reg_lock);\n\ttimer_setup(&rinfo->lvds_timer, radeon_lvds_timer_func, 0);\n\n\tc1 = ent->device >> 8;\n\tc2 = ent->device & 0xff;\n\tif (isprint(c1) && isprint(c2))\n\t\tsnprintf(rinfo->name, sizeof(rinfo->name),\n\t\t\t \"ATI Radeon %x \\\"%c%c\\\"\", ent->device & 0xffff, c1, c2);\n\telse\n\t\tsnprintf(rinfo->name, sizeof(rinfo->name),\n\t\t\t \"ATI Radeon %x\", ent->device & 0xffff);\n\n\trinfo->family = ent->driver_data & CHIP_FAMILY_MASK;\n\trinfo->chipset = pdev->device;\n\trinfo->has_CRTC2 = (ent->driver_data & CHIP_HAS_CRTC2) != 0;\n\trinfo->is_mobility = (ent->driver_data & CHIP_IS_MOBILITY) != 0;\n\trinfo->is_IGP = (ent->driver_data & CHIP_IS_IGP) != 0;\n\n\t \n\trinfo->fb_base_phys = pci_resource_start (pdev, 0);\n\trinfo->mmio_base_phys = pci_resource_start (pdev, 2);\n\n\tret = aperture_remove_conflicting_pci_devices(pdev, KBUILD_MODNAME);\n\tif (ret)\n\t\tgoto err_release_fb;\n\n\t \n\tret = pci_request_region(pdev, 0, \"radeonfb framebuffer\");\n\tif (ret < 0) {\n\t\tprintk( KERN_ERR \"radeonfb (%s): cannot request region 0.\\n\",\n\t\t\tpci_name(rinfo->pdev));\n\t\tgoto err_release_fb;\n\t}\n\n\tret = pci_request_region(pdev, 2, \"radeonfb mmio\");\n\tif (ret < 0) {\n\t\tprintk( KERN_ERR \"radeonfb (%s): cannot request region 2.\\n\",\n\t\t\tpci_name(rinfo->pdev));\n\t\tgoto err_release_pci0;\n\t}\n\n\t \n\trinfo->mmio_base = ioremap(rinfo->mmio_base_phys, RADEON_REGSIZE);\n\tif (!rinfo->mmio_base) {\n\t\tprintk(KERN_ERR \"radeonfb (%s): cannot map MMIO\\n\",\n\t\t       pci_name(rinfo->pdev));\n\t\tret = -EIO;\n\t\tgoto err_release_pci2;\n\t}\n\n\trinfo->fb_local_base = INREG(MC_FB_LOCATION) << 16;\n\n\t \n\trinfo->errata = 0;\n\tif (rinfo->family == CHIP_FAMILY_R300 &&\n\t    (INREG(CNFG_CNTL) & CFG_ATI_REV_ID_MASK)\n\t    == CFG_ATI_REV_A11)\n\t\trinfo->errata |= CHIP_ERRATA_R300_CG;\n\n\tif (rinfo->family == CHIP_FAMILY_RV200 ||\n\t    rinfo->family == CHIP_FAMILY_RS200)\n\t\trinfo->errata |= CHIP_ERRATA_PLL_DUMMYREADS;\n\n\tif (rinfo->family == CHIP_FAMILY_RV100 ||\n\t    rinfo->family == CHIP_FAMILY_RS100 ||\n\t    rinfo->family == CHIP_FAMILY_RS200)\n\t\trinfo->errata |= CHIP_ERRATA_PLL_DELAY;\n\n#if defined(CONFIG_PPC) || defined(CONFIG_SPARC)\n\t \n\trinfo->of_node = pci_device_to_OF_node(pdev);\n\tif (rinfo->of_node == NULL)\n\t\tprintk(KERN_WARNING \"radeonfb (%s): Cannot match card to OF node !\\n\",\n\t\t       pci_name(rinfo->pdev));\n\n#endif  \n#ifdef CONFIG_PPC\n\t \n\tfixup_memory_mappings(rinfo);\n#endif  \n\n\t \n\tradeon_identify_vram(rinfo);\n\n\trinfo->mapped_vram = min_t(unsigned long, MAX_MAPPED_VRAM, rinfo->video_ram);\n\n\tdo {\n\t\trinfo->fb_base = ioremap_wc(rinfo->fb_base_phys,\n\t\t\t\t\t    rinfo->mapped_vram);\n\t} while (rinfo->fb_base == NULL &&\n\t\t ((rinfo->mapped_vram /= 2) >= MIN_MAPPED_VRAM));\n\n\tif (rinfo->fb_base == NULL) {\n\t\tprintk (KERN_ERR \"radeonfb (%s): cannot map FB\\n\",\n\t\t\tpci_name(rinfo->pdev));\n\t\tret = -EIO;\n\t\tgoto err_unmap_rom;\n\t}\n\n\tpr_debug(\"radeonfb (%s): mapped %ldk videoram\\n\", pci_name(rinfo->pdev),\n\t       rinfo->mapped_vram/1024);\n\n\t \n\tif (!rinfo->is_mobility)\n\t\tradeon_map_ROM(rinfo, pdev);\n\n\t \n#ifdef CONFIG_X86\n\tif (rinfo->bios_seg == NULL)\n\t\tradeon_find_mem_vbios(rinfo);\n#endif\n\n\t \n\tif (rinfo->bios_seg == NULL && rinfo->is_mobility)\n\t\tradeon_map_ROM(rinfo, pdev);\n\n\t \n\tradeon_get_pllinfo(rinfo);\n\n#ifdef CONFIG_FB_RADEON_I2C\n\t \n\tradeon_create_i2c_busses(rinfo);\n#endif\n\n\t \n\tradeon_set_fbinfo (rinfo);\n\n\t \n\tradeon_probe_screens(rinfo, monitor_layout, ignore_edid);\n\n\t \n\tradeon_check_modes(rinfo, mode_option);\n\n\t \n\tif (rinfo->mon1_EDID)\n\t\terr |= sysfs_create_bin_file(&rinfo->pdev->dev.kobj,\n\t\t\t\t\t\t&edid1_attr);\n\tif (rinfo->mon2_EDID)\n\t\terr |= sysfs_create_bin_file(&rinfo->pdev->dev.kobj,\n\t\t\t\t\t\t&edid2_attr);\n\tif (err)\n\t\tpr_warn(\"%s() Creating sysfs files failed, continuing\\n\",\n\t\t\t__func__);\n\n\t \n\tradeon_save_state (rinfo, &rinfo->init_state);\n\tmemcpy(&rinfo->state, &rinfo->init_state, sizeof(struct radeon_regs));\n\n\t \n\tif (default_dynclk < -1) {\n\t\t \n\t\tradeonfb_pm_init(rinfo, rinfo->is_mobility ? 1 : -1, ignore_devlist, force_sleep);\n\t} else\n\t\tradeonfb_pm_init(rinfo, default_dynclk, ignore_devlist, force_sleep);\n\n\tpci_set_drvdata(pdev, info);\n\n\t \n\tret = register_framebuffer(info);\n\tif (ret < 0) {\n\t\tprintk (KERN_ERR \"radeonfb (%s): could not register framebuffer\\n\",\n\t\t\tpci_name(rinfo->pdev));\n\t\tgoto err_unmap_fb;\n\t}\n\n\tif (!nomtrr)\n\t\trinfo->wc_cookie = arch_phys_wc_add(rinfo->fb_base_phys,\n\t\t\t\t\t\t    rinfo->video_ram);\n\n\tif (backlight)\n\t\tradeonfb_bl_init(rinfo);\n\n\tprintk (\"radeonfb (%s): %s\\n\", pci_name(rinfo->pdev), rinfo->name);\n\n\tif (rinfo->bios_seg)\n\t\tradeon_unmap_ROM(rinfo, pdev);\n\tpr_debug(\"radeonfb_pci_register END\\n\");\n\n\treturn 0;\nerr_unmap_fb:\n\tiounmap(rinfo->fb_base);\nerr_unmap_rom:\n\tkfree(rinfo->mon1_EDID);\n\tkfree(rinfo->mon2_EDID);\n\tif (rinfo->mon1_modedb)\n\t\tfb_destroy_modedb(rinfo->mon1_modedb);\n\tfb_dealloc_cmap(&info->cmap);\n#ifdef CONFIG_FB_RADEON_I2C\n\tradeon_delete_i2c_busses(rinfo);\n#endif\n\tif (rinfo->bios_seg)\n\t\tradeon_unmap_ROM(rinfo, pdev);\n\tiounmap(rinfo->mmio_base);\nerr_release_pci2:\n\tpci_release_region(pdev, 2);\nerr_release_pci0:\n\tpci_release_region(pdev, 0);\nerr_release_fb:\n        framebuffer_release(info);\nerr_disable:\nerr_out:\n\treturn ret;\n}\n\n\n\nstatic void radeonfb_pci_unregister(struct pci_dev *pdev)\n{\n        struct fb_info *info = pci_get_drvdata(pdev);\n        struct radeonfb_info *rinfo = info->par;\n\n        if (!rinfo)\n                return;\n\n\tradeonfb_pm_exit(rinfo);\n\n\tif (rinfo->mon1_EDID)\n\t\tsysfs_remove_bin_file(&rinfo->pdev->dev.kobj, &edid1_attr);\n\tif (rinfo->mon2_EDID)\n\t\tsysfs_remove_bin_file(&rinfo->pdev->dev.kobj, &edid2_attr);\n\n\tdel_timer_sync(&rinfo->lvds_timer);\n\tarch_phys_wc_del(rinfo->wc_cookie);\n        radeonfb_bl_exit(rinfo);\n\tunregister_framebuffer(info);\n\n        iounmap(rinfo->mmio_base);\n        iounmap(rinfo->fb_base);\n\n\tpci_release_region(pdev, 2);\n\tpci_release_region(pdev, 0);\n\n\tkfree(rinfo->mon1_EDID);\n\tkfree(rinfo->mon2_EDID);\n\tif (rinfo->mon1_modedb)\n\t\tfb_destroy_modedb(rinfo->mon1_modedb);\n#ifdef CONFIG_FB_RADEON_I2C\n\tradeon_delete_i2c_busses(rinfo);\n#endif\n\tfb_dealloc_cmap(&info->cmap);\n        framebuffer_release(info);\n}\n\n#ifdef CONFIG_PM\n#define RADEONFB_PCI_PM_OPS (&radeonfb_pci_pm_ops)\n#else\n#define RADEONFB_PCI_PM_OPS NULL\n#endif\n\nstatic struct pci_driver radeonfb_driver = {\n\t.name\t\t= \"radeonfb\",\n\t.id_table\t= radeonfb_pci_table,\n\t.probe\t\t= radeonfb_pci_register,\n\t.remove\t\t= radeonfb_pci_unregister,\n\t.driver.pm\t= RADEONFB_PCI_PM_OPS,\n};\n\n#ifndef MODULE\nstatic int __init radeonfb_setup (char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep (&options, \",\")) != NULL) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\n\t\tif (!strncmp(this_opt, \"noaccel\", 7)) {\n\t\t\tnoaccel = 1;\n\t\t} else if (!strncmp(this_opt, \"mirror\", 6)) {\n\t\t\tmirror = 1;\n\t\t} else if (!strncmp(this_opt, \"force_dfp\", 9)) {\n\t\t\tforce_dfp = 1;\n\t\t} else if (!strncmp(this_opt, \"panel_yres:\", 11)) {\n\t\t\tpanel_yres = simple_strtoul((this_opt+11), NULL, 0);\n\t\t} else if (!strncmp(this_opt, \"backlight:\", 10)) {\n\t\t\tbacklight = simple_strtoul(this_opt+10, NULL, 0);\n\t\t} else if (!strncmp(this_opt, \"nomtrr\", 6)) {\n\t\t\tnomtrr = 1;\n\t\t} else if (!strncmp(this_opt, \"nomodeset\", 9)) {\n\t\t\tnomodeset = 1;\n\t\t} else if (!strncmp(this_opt, \"force_measure_pll\", 17)) {\n\t\t\tforce_measure_pll = 1;\n\t\t} else if (!strncmp(this_opt, \"ignore_edid\", 11)) {\n\t\t\tignore_edid = 1;\n#if defined(CONFIG_PM) && defined(CONFIG_X86)\n\t \t} else if (!strncmp(this_opt, \"force_sleep\", 11)) {\n\t\t\tforce_sleep = 1;\n\t\t} else if (!strncmp(this_opt, \"ignore_devlist\", 14)) {\n\t\t\tignore_devlist = 1;\n#endif\n\t\t} else\n\t\t\tmode_option = this_opt;\n\t}\n\treturn 0;\n}\n#endif   \n\nstatic int __init radeonfb_init (void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"radeonfb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"radeonfb\", &option))\n\t\treturn -ENODEV;\n\tradeonfb_setup(option);\n#endif\n\treturn pci_register_driver (&radeonfb_driver);\n}\n\n\nstatic void __exit radeonfb_exit (void)\n{\n\tpci_unregister_driver (&radeonfb_driver);\n}\n\nmodule_init(radeonfb_init);\nmodule_exit(radeonfb_exit);\n\nMODULE_AUTHOR(\"Ani Joshi\");\nMODULE_DESCRIPTION(\"framebuffer driver for ATI Radeon chipset\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(noaccel, bool, 0);\nmodule_param(default_dynclk, int, 0);\nMODULE_PARM_DESC(default_dynclk, \"int: -2=enable on mobility only,-1=do not change,0=off,1=on\");\nMODULE_PARM_DESC(noaccel, \"bool: disable acceleration\");\nmodule_param(nomodeset, bool, 0);\nMODULE_PARM_DESC(nomodeset, \"bool: disable actual setting of video mode\");\nmodule_param(mirror, bool, 0);\nMODULE_PARM_DESC(mirror, \"bool: mirror the display to both monitors\");\nmodule_param(force_dfp, bool, 0);\nMODULE_PARM_DESC(force_dfp, \"bool: force display to dfp\");\nmodule_param(ignore_edid, bool, 0);\nMODULE_PARM_DESC(ignore_edid, \"bool: Ignore EDID data when doing DDC probe\");\nmodule_param(monitor_layout, charp, 0);\nMODULE_PARM_DESC(monitor_layout, \"Specify monitor mapping (like XFree86)\");\nmodule_param(force_measure_pll, bool, 0);\nMODULE_PARM_DESC(force_measure_pll, \"Force measurement of PLL (debug)\");\nmodule_param(nomtrr, bool, 0);\nMODULE_PARM_DESC(nomtrr, \"bool: disable use of MTRR registers\");\nmodule_param(panel_yres, int, 0);\nMODULE_PARM_DESC(panel_yres, \"int: set panel yres\");\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Specify resolution as \\\"<xres>x<yres>[-<bpp>][@<refresh>]\\\" \");\n#if defined(CONFIG_PM) && defined(CONFIG_X86)\nmodule_param(force_sleep, bool, 0);\nMODULE_PARM_DESC(force_sleep, \"bool: force D2 sleep mode on all hardware\");\nmodule_param(ignore_devlist, bool, 0);\nMODULE_PARM_DESC(ignore_devlist, \"bool: ignore workarounds for bugs in specific laptops\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}