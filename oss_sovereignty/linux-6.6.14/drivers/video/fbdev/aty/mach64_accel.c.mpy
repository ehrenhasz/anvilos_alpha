{
  "module_name": "mach64_accel.c",
  "hash_id": "38cc72483b77fa01d3bf5f6bb6283992df875390da21175d549faa1236f13423",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/aty/mach64_accel.c",
  "human_readable_source": "\n\n \n\n#include <linux/delay.h>\n#include <asm/unaligned.h>\n#include <linux/fb.h>\n#include <video/mach64.h>\n#include \"atyfb.h\"\n\n     \n\n \ntypedef struct {\n\tu32 frame_buf_offset;\n\tu32 system_mem_addr;\n\tu32 command;\n\tu32 reserved;\n} BM_DESCRIPTOR_ENTRY;\n\n#define LAST_DESCRIPTOR (1 << 31)\n#define SYSTEM_TO_FRAME_BUFFER 0\n\nstatic u32 rotation24bpp(u32 dx, u32 direction)\n{\n\tu32 rotation;\n\tif (direction & DST_X_LEFT_TO_RIGHT) {\n\t\trotation = (dx / 4) % 6;\n\t} else {\n\t\trotation = ((dx + 2) / 4) % 6;\n\t}\n\n\treturn ((rotation << 8) | DST_24_ROTATION_ENABLE);\n}\n\nvoid aty_reset_engine(struct atyfb_par *par)\n{\n\t \n\taty_st_le32(GEN_TEST_CNTL,\n\t\taty_ld_le32(GEN_TEST_CNTL, par) &\n\t\t~(GUI_ENGINE_ENABLE | HWCURSOR_ENABLE), par);\n\t \n\taty_st_le32(GEN_TEST_CNTL,\n\t\taty_ld_le32(GEN_TEST_CNTL, par) | GUI_ENGINE_ENABLE, par);\n\t \n\t \n\taty_st_le32(BUS_CNTL,\n\t\taty_ld_le32(BUS_CNTL, par) | BUS_HOST_ERR_ACK | BUS_FIFO_ERR_ACK, par);\n\n\tpar->fifo_space = 0;\n}\n\nstatic void reset_GTC_3D_engine(const struct atyfb_par *par)\n{\n\taty_st_le32(SCALE_3D_CNTL, 0xc0, par);\n\tmdelay(GTC_3D_RESET_DELAY);\n\taty_st_le32(SETUP_CNTL, 0x00, par);\n\tmdelay(GTC_3D_RESET_DELAY);\n\taty_st_le32(SCALE_3D_CNTL, 0x00, par);\n\tmdelay(GTC_3D_RESET_DELAY);\n}\n\nvoid aty_init_engine(struct atyfb_par *par, struct fb_info *info)\n{\n\tu32 pitch_value;\n\tu32 vxres;\n\n\t \n\tpitch_value = info->fix.line_length / (info->var.bits_per_pixel / 8);\n\tvxres = info->var.xres_virtual;\n\n\tif (info->var.bits_per_pixel == 24) {\n\t\t \n\t\t \n\t\tpitch_value *= 3;\n\t\tvxres *= 3;\n\t}\n\n\t \n\tif (M64_HAS(RESET_3D))\n\t\treset_GTC_3D_engine(par);\n\n\t \n\taty_reset_engine(par);\n\t \n\t \n\t \n\taty_st_le32(MEM_VGA_WP_SEL, 0x00010000, par);\n\taty_st_le32(MEM_VGA_RP_SEL, 0x00010000, par);\n\n\t \n\n\t \n\t \n\twait_for_fifo(14, par);\n\n\t \n\taty_st_le32(CONTEXT_MASK, 0xFFFFFFFF, par);\n\n\t \n\taty_st_le32(DST_OFF_PITCH, (pitch_value / 8) << 22, par);\n\n\t \n\taty_st_le32(DST_Y_X, 0, par);\n\taty_st_le32(DST_HEIGHT, 0, par);\n\taty_st_le32(DST_BRES_ERR, 0, par);\n\taty_st_le32(DST_BRES_INC, 0, par);\n\taty_st_le32(DST_BRES_DEC, 0, par);\n\n\t \n\taty_st_le32(DST_CNTL, DST_LAST_PEL | DST_Y_TOP_TO_BOTTOM |\n\t\t    DST_X_LEFT_TO_RIGHT, par);\n\n\t \n\taty_st_le32(SRC_OFF_PITCH, (pitch_value / 8) << 22, par);\n\n\t \n\taty_st_le32(SRC_Y_X, 0, par);\n\taty_st_le32(SRC_HEIGHT1_WIDTH1, 1, par);\n\taty_st_le32(SRC_Y_X_START, 0, par);\n\taty_st_le32(SRC_HEIGHT2_WIDTH2, 1, par);\n\n\t \n\taty_st_le32(SRC_CNTL, SRC_LINE_X_LEFT_TO_RIGHT, par);\n\n\t \n\twait_for_fifo(13, par);\n\taty_st_le32(HOST_CNTL, HOST_BYTE_ALIGN, par);\n\n\t \n\taty_st_le32(PAT_REG0, 0, par);\n\taty_st_le32(PAT_REG1, 0, par);\n\taty_st_le32(PAT_CNTL, 0, par);\n\n\t \n\taty_st_le32(SC_LEFT, 0, par);\n\taty_st_le32(SC_TOP, 0, par);\n\taty_st_le32(SC_BOTTOM, par->crtc.vyres - 1, par);\n\taty_st_le32(SC_RIGHT, vxres - 1, par);\n\n\t \n\taty_st_le32(DP_BKGD_CLR, 0, par);\n\n\t \n\taty_st_le32(DP_FRGD_CLR, 0xFFFFFFFF, par);\n\n\t \n\taty_st_le32(DP_WRITE_MASK, 0xFFFFFFFF, par);\n\n\t \n\t \n\taty_st_le32(DP_MIX, FRGD_MIX_S | BKGD_MIX_D, par);\n\n\t \n\t \n\taty_st_le32(DP_SRC, FRGD_SRC_FRGD_CLR, par);\n\n\t \n\t \n\twait_for_fifo(3, par);\n\taty_st_le32(CLR_CMP_CLR, 0, par);\n\taty_st_le32(CLR_CMP_MASK, 0xFFFFFFFF, par);\n\taty_st_le32(CLR_CMP_CNTL, 0, par);\n\n\t \n\twait_for_fifo(2, par);\n\taty_st_le32(DP_PIX_WIDTH, par->crtc.dp_pix_width, par);\n\taty_st_le32(DP_CHAIN_MASK, par->crtc.dp_chain_mask, par);\n\n\twait_for_fifo(5, par);\n \taty_st_le32(SCALE_3D_CNTL, 0, par);\n\taty_st_le32(Z_CNTL, 0, par);\n\taty_st_le32(CRTC_INT_CNTL, aty_ld_le32(CRTC_INT_CNTL, par) & ~0x20,\n\t\t    par);\n\taty_st_le32(GUI_TRAJ_CNTL, 0x100023, par);\n\n\t \n\twait_for_idle(par);\n}\n\n     \n\nstatic inline void draw_rect(s16 x, s16 y, u16 width, u16 height,\n\t\t\t     struct atyfb_par *par)\n{\n\t \n\twait_for_fifo(2, par);\n\taty_st_le32(DST_Y_X, (x << 16) | y, par);\n\taty_st_le32(DST_HEIGHT_WIDTH, (width << 16) | height, par);\n\tpar->blitter_may_be_busy = 1;\n}\n\nvoid atyfb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 dy = area->dy, sy = area->sy, direction = DST_LAST_PEL;\n\tu32 sx = area->sx, dx = area->dx, width = area->width, rotation = 0;\n\n\tif (par->asleep)\n\t\treturn;\n\tif (!area->width || !area->height)\n\t\treturn;\n\tif (!par->accel_flags) {\n\t\tcfb_copyarea(info, area);\n\t\treturn;\n\t}\n\n\tif (info->var.bits_per_pixel == 24) {\n\t\t \n\t\t \n\t\tsx *= 3;\n\t\tdx *= 3;\n\t\twidth *= 3;\n\t}\n\n\tif (area->sy < area->dy) {\n\t\tdy += area->height - 1;\n\t\tsy += area->height - 1;\n\t} else\n\t\tdirection |= DST_Y_TOP_TO_BOTTOM;\n\n\tif (sx < dx) {\n\t\tdx += width - 1;\n\t\tsx += width - 1;\n\t} else\n\t\tdirection |= DST_X_LEFT_TO_RIGHT;\n\n\tif (info->var.bits_per_pixel == 24) {\n\t\trotation = rotation24bpp(dx, direction);\n\t}\n\n\twait_for_fifo(5, par);\n\taty_st_le32(DP_PIX_WIDTH, par->crtc.dp_pix_width, par);\n\taty_st_le32(DP_SRC, FRGD_SRC_BLIT, par);\n\taty_st_le32(SRC_Y_X, (sx << 16) | sy, par);\n\taty_st_le32(SRC_HEIGHT1_WIDTH1, (width << 16) | area->height, par);\n\taty_st_le32(DST_CNTL, direction | rotation, par);\n\tdraw_rect(dx, dy, width, area->height, par);\n}\n\nvoid atyfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 color, dx = rect->dx, width = rect->width, rotation = 0;\n\n\tif (par->asleep)\n\t\treturn;\n\tif (!rect->width || !rect->height)\n\t\treturn;\n\tif (!par->accel_flags) {\n\t\tcfb_fillrect(info, rect);\n\t\treturn;\n\t}\n\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\n\t    info->fix.visual == FB_VISUAL_DIRECTCOLOR)\n\t\tcolor = ((u32 *)(info->pseudo_palette))[rect->color];\n\telse\n\t\tcolor = rect->color;\n\n\tif (info->var.bits_per_pixel == 24) {\n\t\t \n\t\t \n\t\tdx *= 3;\n\t\twidth *= 3;\n\t\trotation = rotation24bpp(dx, DST_X_LEFT_TO_RIGHT);\n\t}\n\n\twait_for_fifo(4, par);\n\taty_st_le32(DP_PIX_WIDTH, par->crtc.dp_pix_width, par);\n\taty_st_le32(DP_FRGD_CLR, color, par);\n\taty_st_le32(DP_SRC,\n\t\t    BKGD_SRC_BKGD_CLR | FRGD_SRC_FRGD_CLR | MONO_SRC_ONE,\n\t\t    par);\n\taty_st_le32(DST_CNTL,\n\t\t    DST_LAST_PEL | DST_Y_TOP_TO_BOTTOM |\n\t\t    DST_X_LEFT_TO_RIGHT | rotation, par);\n\tdraw_rect(dx, rect->dy, width, rect->height, par);\n}\n\nvoid atyfb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 src_bytes, dx = image->dx, dy = image->dy, width = image->width;\n\tu32 pix_width, rotation = 0, src, mix;\n\n\tif (par->asleep)\n\t\treturn;\n\tif (!image->width || !image->height)\n\t\treturn;\n\tif (!par->accel_flags ||\n\t    (image->depth != 1 && info->var.bits_per_pixel != image->depth)) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\n\tpix_width = par->crtc.dp_pix_width;\n\n\tswitch (image->depth) {\n\tcase 1:\n\t    pix_width &= ~(BYTE_ORDER_MASK | HOST_MASK);\n\t    pix_width |= (BYTE_ORDER_MSB_TO_LSB | HOST_1BPP);\n\t    break;\n\tcase 4:\n\t    pix_width &= ~(BYTE_ORDER_MASK | HOST_MASK);\n\t    pix_width |= (BYTE_ORDER_MSB_TO_LSB | HOST_4BPP);\n\t    break;\n\tcase 8:\n\t    pix_width &= ~HOST_MASK;\n\t    pix_width |= HOST_8BPP;\n\t    break;\n\tcase 15:\n\t    pix_width &= ~HOST_MASK;\n\t    pix_width |= HOST_15BPP;\n\t    break;\n\tcase 16:\n\t    pix_width &= ~HOST_MASK;\n\t    pix_width |= HOST_16BPP;\n\t    break;\n\tcase 24:\n\t    pix_width &= ~HOST_MASK;\n\t    pix_width |= HOST_24BPP;\n\t    break;\n\tcase 32:\n\t    pix_width &= ~HOST_MASK;\n\t    pix_width |= HOST_32BPP;\n\t    break;\n\t}\n\n\tif (info->var.bits_per_pixel == 24) {\n\t\t \n\t\t \n\t\tdx *= 3;\n\t\twidth *= 3;\n\n\t\trotation = rotation24bpp(dx, DST_X_LEFT_TO_RIGHT);\n\n\t\tpix_width &= ~DST_MASK;\n\t\tpix_width |= DST_8BPP;\n\n\t\t \n\t\tif (image->depth == 1 && M64_HAS(HW_TRIPLE) && image->width % 8 == 0)\n\t\t\tpix_width |= DP_HOST_TRIPLE_EN;\n\t}\n\n\tif (image->depth == 1) {\n\t\tu32 fg, bg;\n\t\tif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\n\t\t    info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\t\tfg = ((u32*)(info->pseudo_palette))[image->fg_color];\n\t\t\tbg = ((u32*)(info->pseudo_palette))[image->bg_color];\n\t\t} else {\n\t\t\tfg = image->fg_color;\n\t\t\tbg = image->bg_color;\n\t\t}\n\n\t\twait_for_fifo(2, par);\n\t\taty_st_le32(DP_BKGD_CLR, bg, par);\n\t\taty_st_le32(DP_FRGD_CLR, fg, par);\n\t\tsrc = MONO_SRC_HOST | FRGD_SRC_FRGD_CLR | BKGD_SRC_BKGD_CLR;\n\t\tmix = FRGD_MIX_S | BKGD_MIX_S;\n\t} else {\n\t\tsrc = MONO_SRC_ONE | FRGD_SRC_HOST;\n\t\tmix = FRGD_MIX_D_XOR_S | BKGD_MIX_D;\n\t}\n\n\twait_for_fifo(5, par);\n\taty_st_le32(DP_PIX_WIDTH, pix_width, par);\n\taty_st_le32(DP_MIX, mix, par);\n\taty_st_le32(DP_SRC, src, par);\n\taty_st_le32(HOST_CNTL, HOST_BYTE_ALIGN, par);\n\taty_st_le32(DST_CNTL, DST_Y_TOP_TO_BOTTOM | DST_X_LEFT_TO_RIGHT | rotation, par);\n\n\tdraw_rect(dx, dy, width, image->height, par);\n\tsrc_bytes = (((image->width * image->depth) + 7) / 8) * image->height;\n\n\t \n\tif (image->depth == 1 && info->var.bits_per_pixel == 24 && !(pix_width & DP_HOST_TRIPLE_EN)) {\n\t\tint inbit, outbit, mult24, byte_id_in_dword, width;\n\t\tu8 *pbitmapin = (u8*)image->data, *pbitmapout;\n\t\tu32 hostdword;\n\n\t\tfor (width = image->width, inbit = 7, mult24 = 0; src_bytes; ) {\n\t\t\tfor (hostdword = 0, pbitmapout = (u8*)&hostdword, byte_id_in_dword = 0;\n\t\t\t\tbyte_id_in_dword < 4 && src_bytes;\n\t\t\t\tbyte_id_in_dword++, pbitmapout++) {\n\t\t\t\tfor (outbit = 7; outbit >= 0; outbit--) {\n\t\t\t\t\t*pbitmapout |= (((*pbitmapin >> inbit) & 1) << outbit);\n\t\t\t\t\tmult24++;\n\t\t\t\t\t \n\t\t\t\t\tif (mult24 == 3) {\n\t\t\t\t\t\tmult24 = 0;\n\t\t\t\t\t\tinbit--;\n\t\t\t\t\t\twidth--;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tif (inbit < 0 || width == 0) {\n\t\t\t\t\t\tsrc_bytes--;\n\t\t\t\t\t\tpbitmapin++;\n\t\t\t\t\t\tinbit = 7;\n\n\t\t\t\t\t\tif (width == 0) {\n\t\t\t\t\t\t    width = image->width;\n\t\t\t\t\t\t    outbit = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twait_for_fifo(1, par);\n\t\t\taty_st_le32(HOST_DATA0, le32_to_cpu(hostdword), par);\n\t\t}\n\t} else {\n\t\tu32 *pbitmap, dwords = (src_bytes + 3) / 4;\n\t\tfor (pbitmap = (u32*)(image->data); dwords; dwords--, pbitmap++) {\n\t\t\twait_for_fifo(1, par);\n\t\t\taty_st_le32(HOST_DATA0, get_unaligned_le32(pbitmap), par);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}