{
  "module_name": "aty128fb.c",
  "hash_id": "cbbb0c233c67d0114548e5c2a78dfcff1468ff230fc420293681443663c6cf90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/aty/aty128fb.c",
  "human_readable_source": "\n \n\n \n\n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/uaccess.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/ioport.h>\n#include <linux/console.h>\n#include <linux/backlight.h>\n#include <asm/io.h>\n\n#ifdef CONFIG_PPC_PMAC\n#include <asm/machdep.h>\n#include <asm/pmac_feature.h>\n#include \"../macmodes.h\"\n#endif\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n#include <asm/backlight.h>\n#endif\n\n#ifdef CONFIG_BOOTX_TEXT\n#include <asm/btext.h>\n#endif  \n\n#include <video/aty128.h>\n\n \n#undef DEBUG\n\n#ifdef DEBUG\n#define DBG(fmt, args...) \\\n\tprintk(KERN_DEBUG \"aty128fb: %s \" fmt, __func__, ##args);\n#else\n#define DBG(fmt, args...)\n#endif\n\n#ifndef CONFIG_PPC_PMAC\n \nstatic const struct fb_var_screeninfo default_var = {\n\t \n\t640, 480, 640, 480, 0, 0, 8, 0,\n\t{0, 8, 0}, {0, 8, 0}, {0, 8, 0}, {0, 0, 0},\n\t0, 0, -1, -1, 0, 39722, 48, 16, 33, 10, 96, 2,\n\t0, FB_VMODE_NONINTERLACED\n};\n\n#else  \n \nstatic const struct fb_var_screeninfo default_var = {\n\t \n\t1024, 768, 1024, 768, 0, 0, 8, 0,\n\t{0, 8, 0}, {0, 8, 0}, {0, 8, 0}, {0, 0, 0},\n\t0, 0, -1, -1, 0, 12699, 160, 32, 28, 1, 96, 3,\n\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\tFB_VMODE_NONINTERLACED\n};\n#endif  \n\n \n \nstatic const struct fb_videomode defaultmode = {\n\t.refresh =\t60,\n\t.xres =\t\t640,\n\t.yres =\t\t480,\n\t.pixclock =\t39722,\n\t.left_margin =\t48,\n\t.right_margin =\t16,\n\t.upper_margin =\t33,\n\t.lower_margin =\t10,\n\t.hsync_len =\t96,\n\t.vsync_len =\t2,\n\t.sync =\t\t0,\n\t.vmode =\tFB_VMODE_NONINTERLACED\n};\n\n \nenum {\n\trage_128,\n\trage_128_pci,\n\trage_128_pro,\n\trage_128_pro_pci,\n\trage_M3,\n\trage_M3_pci,\n\trage_M4,\n\trage_128_ultra,\n};\n\n \nstatic char * const r128_family[] = {\n\t\"AGP\",\n\t\"PCI\",\n\t\"PRO AGP\",\n\t\"PRO PCI\",\n\t\"M3 AGP\",\n\t\"M3 PCI\",\n\t\"M4 AGP\",\n\t\"Ultra AGP\",\n};\n\n \nstatic int aty128_probe(struct pci_dev *pdev,\n                               const struct pci_device_id *ent);\nstatic void aty128_remove(struct pci_dev *pdev);\nstatic int aty128_pci_suspend_late(struct device *dev, pm_message_t state);\nstatic int __maybe_unused aty128_pci_suspend(struct device *dev);\nstatic int __maybe_unused aty128_pci_hibernate(struct device *dev);\nstatic int __maybe_unused aty128_pci_freeze(struct device *dev);\nstatic int __maybe_unused aty128_pci_resume(struct device *dev);\nstatic int aty128_do_resume(struct pci_dev *pdev);\n\nstatic const struct dev_pm_ops aty128_pci_pm_ops = {\n\t.suspend\t= aty128_pci_suspend,\n\t.resume\t\t= aty128_pci_resume,\n\t.freeze\t\t= aty128_pci_freeze,\n\t.thaw\t\t= aty128_pci_resume,\n\t.poweroff\t= aty128_pci_hibernate,\n\t.restore\t= aty128_pci_resume,\n};\n\n \nstatic const struct pci_device_id aty128_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_LE,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_M3_pci },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_LF,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_M3 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_MF,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_M4 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_ML,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_M4 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PA,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PB,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PC,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PD,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro_pci },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PE,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PF,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PG,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PH,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PI,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PJ,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PK,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PL,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PM,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PN,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PO,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PP,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro_pci },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PQ,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PR,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro_pci },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PS,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PT,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PU,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PV,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PW,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_PX,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pro },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_RE,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pci },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_RF,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_RG,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_RK,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pci },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_RL,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_SE,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_SF,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_pci },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_SG,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_SH,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_SK,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_SL,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_SM,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_SN,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128 },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_TF,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_ultra },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_TL,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_ultra },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_TR,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_ultra },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_TS,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_ultra },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_TT,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_ultra },\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RAGE128_TU,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, rage_128_ultra },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, aty128_pci_tbl);\n\nstatic struct pci_driver aty128fb_driver = {\n\t.name\t\t= \"aty128fb\",\n\t.id_table\t= aty128_pci_tbl,\n\t.probe\t\t= aty128_probe,\n\t.remove\t\t= aty128_remove,\n\t.driver.pm\t= &aty128_pci_pm_ops,\n};\n\n \n#ifndef CONFIG_PPC\ntypedef struct {\n\tu8 clock_chip_type;\n\tu8 struct_size;\n\tu8 accelerator_entry;\n\tu8 VGA_entry;\n\tu16 VGA_table_offset;\n\tu16 POST_table_offset;\n\tu16 XCLK;\n\tu16 MCLK;\n\tu8 num_PLL_blocks;\n\tu8 size_PLL_blocks;\n\tu16 PCLK_ref_freq;\n\tu16 PCLK_ref_divider;\n\tu32 PCLK_min_freq;\n\tu32 PCLK_max_freq;\n\tu16 MCLK_ref_freq;\n\tu16 MCLK_ref_divider;\n\tu32 MCLK_min_freq;\n\tu32 MCLK_max_freq;\n\tu16 XCLK_ref_freq;\n\tu16 XCLK_ref_divider;\n\tu32 XCLK_min_freq;\n\tu32 XCLK_max_freq;\n} __attribute__ ((packed)) PLL_BLOCK;\n#endif  \n\n \nstruct aty128_meminfo {\n\tu8 ML;\n\tu8 MB;\n\tu8 Trcd;\n\tu8 Trp;\n\tu8 Twr;\n\tu8 CL;\n\tu8 Tr2w;\n\tu8 LoopLatency;\n\tu8 DspOn;\n\tu8 Rloop;\n\tconst char *name;\n};\n\n \nstatic const struct aty128_meminfo sdr_128 = {\n\t.ML = 4,\n\t.MB = 4,\n\t.Trcd = 3,\n\t.Trp = 3,\n\t.Twr = 1,\n\t.CL = 3,\n\t.Tr2w = 1,\n\t.LoopLatency = 16,\n\t.DspOn = 30,\n\t.Rloop = 16,\n\t.name = \"128-bit SDR SGRAM (1:1)\",\n};\n\nstatic const struct aty128_meminfo sdr_sgram = {\n\t.ML = 4,\n\t.MB = 4,\n\t.Trcd = 1,\n\t.Trp = 2,\n\t.Twr = 1,\n\t.CL = 2,\n\t.Tr2w = 1,\n\t.LoopLatency = 16,\n\t.DspOn = 24,\n\t.Rloop = 16,\n\t.name = \"64-bit SDR SGRAM (2:1)\",\n};\n\nstatic const struct aty128_meminfo ddr_sgram = {\n\t.ML = 4,\n\t.MB = 4,\n\t.Trcd = 3,\n\t.Trp = 3,\n\t.Twr = 2,\n\t.CL = 3,\n\t.Tr2w = 1,\n\t.LoopLatency = 16,\n\t.DspOn = 31,\n\t.Rloop = 16,\n\t.name = \"64-bit DDR SGRAM\",\n};\n\nstatic const struct fb_fix_screeninfo aty128fb_fix = {\n\t.id\t\t= \"ATY Rage128\",\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.visual\t\t= FB_VISUAL_PSEUDOCOLOR,\n\t.xpanstep\t= 8,\n\t.ypanstep\t= 1,\n\t.mmio_len\t= 0x2000,\n\t.accel\t\t= FB_ACCEL_ATI_RAGE128,\n};\n\nstatic char *mode_option = NULL;\n\n#ifdef CONFIG_PPC_PMAC\nstatic int default_vmode = VMODE_1024_768_60;\nstatic int default_cmode = CMODE_8;\n#endif\n\nstatic int default_crt_on = 0;\nstatic int default_lcd_on = 1;\nstatic bool mtrr = true;\n\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\nstatic int backlight = IS_BUILTIN(CONFIG_PMAC_BACKLIGHT);\n#endif\n\n \nstruct aty128_constants {\n\tu32 ref_clk;\n\tu32 ppll_min;\n\tu32 ppll_max;\n\tu32 ref_divider;\n\tu32 xclk;\n\tu32 fifo_width;\n\tu32 fifo_depth;\n};\n\nstruct aty128_crtc {\n\tu32 gen_cntl;\n\tu32 h_total, h_sync_strt_wid;\n\tu32 v_total, v_sync_strt_wid;\n\tu32 pitch;\n\tu32 offset, offset_cntl;\n\tu32 xoffset, yoffset;\n\tu32 vxres, vyres;\n\tu32 depth, bpp;\n};\n\nstruct aty128_pll {\n\tu32 post_divider;\n\tu32 feedback_divider;\n\tu32 vclk;\n};\n\nstruct aty128_ddafifo {\n\tu32 dda_config;\n\tu32 dda_on_off;\n};\n\n \nstruct aty128fb_par {\n\tstruct aty128_crtc crtc;\n\tstruct aty128_pll pll;\n\tstruct aty128_ddafifo fifo_reg;\n\tu32 accel_flags;\n\tstruct aty128_constants constants;   \n\tvoid __iomem *regbase;               \n\tu32 vram_size;                       \n\tint chip_gen;\n\tconst struct aty128_meminfo *mem;    \n\tint wc_cookie;\n\tint blitter_may_be_busy;\n\tint fifo_slots;                  \n\n\tint crt_on, lcd_on;\n\tstruct pci_dev *pdev;\n\tstruct fb_info *next;\n\tint\tasleep;\n\tint\tlock_blank;\n\n\tu8\tred[32];\t\t \n\tu8\tgreen[64];\n\tu8\tblue[32];\n\tu32\tpseudo_palette[16];\t \n};\n\n\n#define round_div(n, d) ((n+(d/2))/d)\n\nstatic int aty128fb_check_var(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info);\nstatic int aty128fb_set_par(struct fb_info *info);\nstatic int aty128fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t      u_int transp, struct fb_info *info);\nstatic int aty128fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t   struct fb_info *fb);\nstatic int aty128fb_blank(int blank, struct fb_info *fb);\nstatic int aty128fb_ioctl(struct fb_info *info, u_int cmd, unsigned long arg);\nstatic int aty128fb_sync(struct fb_info *info);\n\n     \n\nstatic int aty128_encode_var(struct fb_var_screeninfo *var,\n                             const struct aty128fb_par *par);\nstatic int aty128_decode_var(struct fb_var_screeninfo *var,\n                             struct aty128fb_par *par);\nstatic void aty128_timings(struct aty128fb_par *par);\nstatic void aty128_init_engine(struct aty128fb_par *par);\nstatic void aty128_reset_engine(const struct aty128fb_par *par);\nstatic void aty128_flush_pixel_cache(const struct aty128fb_par *par);\nstatic void do_wait_for_fifo(u16 entries, struct aty128fb_par *par);\nstatic void wait_for_fifo(u16 entries, struct aty128fb_par *par);\nstatic void wait_for_idle(struct aty128fb_par *par);\nstatic u32 depth_to_dst(u32 depth);\n\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\nstatic void aty128_bl_set_power(struct fb_info *info, int power);\n#endif\n\n#define BIOS_IN8(v)  \t(readb(bios + (v)))\n#define BIOS_IN16(v) \t(readb(bios + (v)) | \\\n\t\t\t  (readb(bios + (v) + 1) << 8))\n#define BIOS_IN32(v) \t(readb(bios + (v)) | \\\n\t\t\t  (readb(bios + (v) + 1) << 8) | \\\n\t\t\t  (readb(bios + (v) + 2) << 16) | \\\n\t\t\t  (readb(bios + (v) + 3) << 24))\n\n\nstatic const struct fb_ops aty128fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= aty128fb_check_var,\n\t.fb_set_par\t= aty128fb_set_par,\n\t.fb_setcolreg\t= aty128fb_setcolreg,\n\t.fb_pan_display = aty128fb_pan_display,\n\t.fb_blank\t= aty128fb_blank,\n\t.fb_ioctl\t= aty128fb_ioctl,\n\t.fb_sync\t= aty128fb_sync,\n};\n\n     \nstatic inline u32 _aty_ld_le32(volatile unsigned int regindex,\n\t\t\t       const struct aty128fb_par *par)\n{\n\treturn readl (par->regbase + regindex);\n}\n\nstatic inline void _aty_st_le32(volatile unsigned int regindex, u32 val,\n\t\t\t\tconst struct aty128fb_par *par)\n{\n\twritel (val, par->regbase + regindex);\n}\n\nstatic inline u8 _aty_ld_8(unsigned int regindex,\n\t\t\t   const struct aty128fb_par *par)\n{\n\treturn readb (par->regbase + regindex);\n}\n\nstatic inline void _aty_st_8(unsigned int regindex, u8 val,\n\t\t\t     const struct aty128fb_par *par)\n{\n\twriteb (val, par->regbase + regindex);\n}\n\n#define aty_ld_le32(regindex)\t\t_aty_ld_le32(regindex, par)\n#define aty_st_le32(regindex, val)\t_aty_st_le32(regindex, val, par)\n#define aty_ld_8(regindex)\t\t_aty_ld_8(regindex, par)\n#define aty_st_8(regindex, val)\t\t_aty_st_8(regindex, val, par)\n\n     \n\n#define aty_ld_pll(pll_index)\t\t_aty_ld_pll(pll_index, par)\n#define aty_st_pll(pll_index, val)\t_aty_st_pll(pll_index, val, par)\n\n\nstatic u32 _aty_ld_pll(unsigned int pll_index,\n\t\t       const struct aty128fb_par *par)\n{\n\taty_st_8(CLOCK_CNTL_INDEX, pll_index & 0x3F);\n\treturn aty_ld_le32(CLOCK_CNTL_DATA);\n}\n\n\nstatic void _aty_st_pll(unsigned int pll_index, u32 val,\n\t\t\tconst struct aty128fb_par *par)\n{\n\taty_st_8(CLOCK_CNTL_INDEX, (pll_index & 0x3F) | PLL_WR_EN);\n\taty_st_le32(CLOCK_CNTL_DATA, val);\n}\n\n\n \nstatic int aty_pll_readupdate(const struct aty128fb_par *par)\n{\n\treturn !(aty_ld_pll(PPLL_REF_DIV) & PPLL_ATOMIC_UPDATE_R);\n}\n\n\nstatic void aty_pll_wait_readupdate(const struct aty128fb_par *par)\n{\n\tunsigned long timeout = jiffies + HZ/100; \n\tint reset = 1;\n\n\twhile (time_before(jiffies, timeout))\n\t\tif (aty_pll_readupdate(par)) {\n\t\t\treset = 0;\n\t\t\tbreak;\n\t\t}\n\n\tif (reset)\t \n\t\tprintk(KERN_DEBUG \"aty128fb: PLL write timeout!\\n\");\n}\n\n\n \nstatic void aty_pll_writeupdate(const struct aty128fb_par *par)\n{\n\taty_pll_wait_readupdate(par);\n\n\taty_st_pll(PPLL_REF_DIV,\n\t\t   aty_ld_pll(PPLL_REF_DIV) | PPLL_ATOMIC_UPDATE_W);\n}\n\n\n \nstatic int register_test(const struct aty128fb_par *par)\n{\n\tu32 val;\n\tint flag = 0;\n\n\tval = aty_ld_le32(BIOS_0_SCRATCH);\n\n\taty_st_le32(BIOS_0_SCRATCH, 0x55555555);\n\tif (aty_ld_le32(BIOS_0_SCRATCH) == 0x55555555) {\n\t\taty_st_le32(BIOS_0_SCRATCH, 0xAAAAAAAA);\n\n\t\tif (aty_ld_le32(BIOS_0_SCRATCH) == 0xAAAAAAAA)\n\t\t\tflag = 1;\n\t}\n\n\taty_st_le32(BIOS_0_SCRATCH, val);\t\n\treturn flag;\n}\n\n\n \nstatic void do_wait_for_fifo(u16 entries, struct aty128fb_par *par)\n{\n\tint i;\n\n\tfor (;;) {\n\t\tfor (i = 0; i < 2000000; i++) {\n\t\t\tpar->fifo_slots = aty_ld_le32(GUI_STAT) & 0x0fff;\n\t\t\tif (par->fifo_slots >= entries)\n\t\t\t\treturn;\n\t\t}\n\t\taty128_reset_engine(par);\n\t}\n}\n\n\nstatic void wait_for_idle(struct aty128fb_par *par)\n{\n\tint i;\n\n\tdo_wait_for_fifo(64, par);\n\n\tfor (;;) {\n\t\tfor (i = 0; i < 2000000; i++) {\n\t\t\tif (!(aty_ld_le32(GUI_STAT) & (1 << 31))) {\n\t\t\t\taty128_flush_pixel_cache(par);\n\t\t\t\tpar->blitter_may_be_busy = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\taty128_reset_engine(par);\n\t}\n}\n\n\nstatic void wait_for_fifo(u16 entries, struct aty128fb_par *par)\n{\n\tif (par->fifo_slots < entries)\n\t\tdo_wait_for_fifo(64, par);\n\tpar->fifo_slots -= entries;\n}\n\n\nstatic void aty128_flush_pixel_cache(const struct aty128fb_par *par)\n{\n\tint i;\n\tu32 tmp;\n\n\ttmp = aty_ld_le32(PC_NGUI_CTLSTAT);\n\ttmp &= ~(0x00ff);\n\ttmp |= 0x00ff;\n\taty_st_le32(PC_NGUI_CTLSTAT, tmp);\n\n\tfor (i = 0; i < 2000000; i++)\n\t\tif (!(aty_ld_le32(PC_NGUI_CTLSTAT) & PC_BUSY))\n\t\t\tbreak;\n}\n\n\nstatic void aty128_reset_engine(const struct aty128fb_par *par)\n{\n\tu32 gen_reset_cntl, clock_cntl_index, mclk_cntl;\n\n\taty128_flush_pixel_cache(par);\n\n\tclock_cntl_index = aty_ld_le32(CLOCK_CNTL_INDEX);\n\tmclk_cntl = aty_ld_pll(MCLK_CNTL);\n\n\taty_st_pll(MCLK_CNTL, mclk_cntl | 0x00030000);\n\n\tgen_reset_cntl = aty_ld_le32(GEN_RESET_CNTL);\n\taty_st_le32(GEN_RESET_CNTL, gen_reset_cntl | SOFT_RESET_GUI);\n\taty_ld_le32(GEN_RESET_CNTL);\n\taty_st_le32(GEN_RESET_CNTL, gen_reset_cntl & ~(SOFT_RESET_GUI));\n\taty_ld_le32(GEN_RESET_CNTL);\n\n\taty_st_pll(MCLK_CNTL, mclk_cntl);\n\taty_st_le32(CLOCK_CNTL_INDEX, clock_cntl_index);\n\taty_st_le32(GEN_RESET_CNTL, gen_reset_cntl);\n\n\t \n\taty_st_le32(PM4_BUFFER_CNTL, PM4_BUFFER_CNTL_NONPM4);\n\n\tDBG(\"engine reset\");\n}\n\n\nstatic void aty128_init_engine(struct aty128fb_par *par)\n{\n\tu32 pitch_value;\n\n\twait_for_idle(par);\n\n\t \n\twait_for_fifo(1, par);\n\taty_st_le32(SCALE_3D_CNTL, 0x00000000);\n\n\taty128_reset_engine(par);\n\n\tpitch_value = par->crtc.pitch;\n\tif (par->crtc.bpp == 24) {\n\t\tpitch_value = pitch_value * 3;\n\t}\n\n\twait_for_fifo(4, par);\n\t \n\taty_st_le32(DEFAULT_OFFSET, 0x00000000);\n\n\t \n\taty_st_le32(DEFAULT_PITCH, pitch_value);\n\n\t \n\taty_st_le32(DEFAULT_SC_BOTTOM_RIGHT, (0x1FFF << 16) | 0x1FFF);\n\n\t \n\taty_st_le32(DP_GUI_MASTER_CNTL,\n\t\t    GMC_SRC_PITCH_OFFSET_DEFAULT\t\t|\n\t\t    GMC_DST_PITCH_OFFSET_DEFAULT\t\t|\n\t\t    GMC_SRC_CLIP_DEFAULT\t\t\t|\n\t\t    GMC_DST_CLIP_DEFAULT\t\t\t|\n\t\t    GMC_BRUSH_SOLIDCOLOR\t\t\t|\n\t\t    (depth_to_dst(par->crtc.depth) << 8)\t|\n\t\t    GMC_SRC_DSTCOLOR\t\t\t|\n\t\t    GMC_BYTE_ORDER_MSB_TO_LSB\t\t|\n\t\t    GMC_DP_CONVERSION_TEMP_6500\t\t|\n\t\t    ROP3_PATCOPY\t\t\t\t|\n\t\t    GMC_DP_SRC_RECT\t\t\t\t|\n\t\t    GMC_3D_FCN_EN_CLR\t\t\t|\n\t\t    GMC_DST_CLR_CMP_FCN_CLEAR\t\t|\n\t\t    GMC_AUX_CLIP_CLEAR\t\t\t|\n\t\t    GMC_WRITE_MASK_SET);\n\n\twait_for_fifo(8, par);\n\t \n\taty_st_le32(DST_BRES_ERR, 0);\n\taty_st_le32(DST_BRES_INC, 0);\n\taty_st_le32(DST_BRES_DEC, 0);\n\n\t \n\taty_st_le32(DP_BRUSH_FRGD_CLR, 0xFFFFFFFF);  \n\taty_st_le32(DP_BRUSH_BKGD_CLR, 0x00000000);  \n\n\t \n\taty_st_le32(DP_SRC_FRGD_CLR, 0xFFFFFFFF);    \n\taty_st_le32(DP_SRC_BKGD_CLR, 0x00000000);    \n\n\t \n\taty_st_le32(DP_WRITE_MASK, 0xFFFFFFFF);\n\n\t \n\twait_for_idle(par);\n}\n\n\n \nstatic u32 depth_to_dst(u32 depth)\n{\n\tif (depth <= 8)\n\t\treturn DST_8BPP;\n\telse if (depth <= 15)\n\t\treturn DST_15BPP;\n\telse if (depth == 16)\n\t\treturn DST_16BPP;\n\telse if (depth <= 24)\n\t\treturn DST_24BPP;\n\telse if (depth <= 32)\n\t\treturn DST_32BPP;\n\n\treturn -EINVAL;\n}\n\n \n\n\n#ifndef __sparc__\nstatic void __iomem *aty128_map_ROM(const struct aty128fb_par *par,\n\t\t\t\t    struct pci_dev *dev)\n{\n\tu16 dptr;\n\tu8 rom_type;\n\tvoid __iomem *bios;\n\tsize_t rom_size;\n\n    \t \n    \tunsigned int temp;\n\ttemp = aty_ld_le32(RAGE128_MPP_TB_CONFIG);\n\ttemp &= 0x00ffffffu;\n\ttemp |= 0x04 << 24;\n\taty_st_le32(RAGE128_MPP_TB_CONFIG, temp);\n\ttemp = aty_ld_le32(RAGE128_MPP_TB_CONFIG);\n\n\tbios = pci_map_rom(dev, &rom_size);\n\n\tif (!bios) {\n\t\tprintk(KERN_ERR \"aty128fb: ROM failed to map\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tif (BIOS_IN16(0) != 0xaa55) {\n\t\tprintk(KERN_DEBUG \"aty128fb: Invalid ROM signature %x should \"\n\t\t\t\" be 0xaa55\\n\", BIOS_IN16(0));\n\t\tgoto failed;\n\t}\n\n\t \n\tdptr = BIOS_IN16(0x18);\n\n\t \n\tif (BIOS_IN32(dptr) !=  (('R' << 24) | ('I' << 16) | ('C' << 8) | 'P')) {\n\t\tprintk(KERN_WARNING \"aty128fb: PCI DATA signature in ROM incorrect: %08x\\n\",\n\t\t       BIOS_IN32(dptr));\n\t\tgoto anyway;\n\t}\n\trom_type = BIOS_IN8(dptr + 0x14);\n\tswitch(rom_type) {\n\tcase 0:\n\t\tprintk(KERN_INFO \"aty128fb: Found Intel x86 BIOS ROM Image\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tprintk(KERN_INFO \"aty128fb: Found Open Firmware ROM Image\\n\");\n\t\tgoto failed;\n\tcase 2:\n\t\tprintk(KERN_INFO \"aty128fb: Found HP PA-RISC ROM Image\\n\");\n\t\tgoto failed;\n\tdefault:\n\t\tprintk(KERN_INFO \"aty128fb: Found unknown type %d ROM Image\\n\",\n\t\t       rom_type);\n\t\tgoto failed;\n\t}\n anyway:\n\treturn bios;\n\n failed:\n\tpci_unmap_rom(dev, bios);\n\treturn NULL;\n}\n\nstatic void aty128_get_pllinfo(struct aty128fb_par *par,\n\t\t\t       unsigned char __iomem *bios)\n{\n\tunsigned int bios_hdr;\n\tunsigned int bios_pll;\n\n\tbios_hdr = BIOS_IN16(0x48);\n\tbios_pll = BIOS_IN16(bios_hdr + 0x30);\n\n\tpar->constants.ppll_max = BIOS_IN32(bios_pll + 0x16);\n\tpar->constants.ppll_min = BIOS_IN32(bios_pll + 0x12);\n\tpar->constants.xclk = BIOS_IN16(bios_pll + 0x08);\n\tpar->constants.ref_divider = BIOS_IN16(bios_pll + 0x10);\n\tpar->constants.ref_clk = BIOS_IN16(bios_pll + 0x0e);\n\n\tDBG(\"ppll_max %d ppll_min %d xclk %d ref_divider %d ref clock %d\\n\",\n\t\t\tpar->constants.ppll_max, par->constants.ppll_min,\n\t\t\tpar->constants.xclk, par->constants.ref_divider,\n\t\t\tpar->constants.ref_clk);\n\n}\n\n#ifdef CONFIG_X86\nstatic void __iomem *aty128_find_mem_vbios(struct aty128fb_par *par)\n{\n\t \n        u32  segstart;\n        unsigned char __iomem *rom_base = NULL;\n\n        for (segstart=0x000c0000; segstart<0x000f0000; segstart+=0x00001000) {\n                rom_base = ioremap(segstart, 0x10000);\n\t\tif (rom_base == NULL)\n\t\t\treturn NULL;\n\t\tif (readb(rom_base) == 0x55 && readb(rom_base + 1) == 0xaa)\n\t                break;\n                iounmap(rom_base);\n\t\trom_base = NULL;\n        }\n\treturn rom_base;\n}\n#endif\n#endif  \n\n \nstatic void aty128_timings(struct aty128fb_par *par)\n{\n#ifdef CONFIG_PPC\n\t \n\n\tu32 x_mpll_ref_fb_div;\n\tu32 xclk_cntl;\n\tu32 Nx, M;\n\tstatic const unsigned int PostDivSet[] = { 0, 1, 2, 4, 8, 3, 6, 12 };\n#endif\n\n\tif (!par->constants.ref_clk)\n\t\tpar->constants.ref_clk = 2950;\n\n#ifdef CONFIG_PPC\n\tx_mpll_ref_fb_div = aty_ld_pll(X_MPLL_REF_FB_DIV);\n\txclk_cntl = aty_ld_pll(XCLK_CNTL) & 0x7;\n\tNx = (x_mpll_ref_fb_div & 0x00ff00) >> 8;\n\tM  = x_mpll_ref_fb_div & 0x0000ff;\n\n\tpar->constants.xclk = round_div((2 * Nx * par->constants.ref_clk),\n\t\t\t\t\t(M * PostDivSet[xclk_cntl]));\n\n\tpar->constants.ref_divider =\n\t\taty_ld_pll(PPLL_REF_DIV) & PPLL_REF_DIV_MASK;\n#endif\n\n\tif (!par->constants.ref_divider) {\n\t\tpar->constants.ref_divider = 0x3b;\n\n\t\taty_st_pll(X_MPLL_REF_FB_DIV, 0x004c4c1e);\n\t\taty_pll_writeupdate(par);\n\t}\n\taty_st_pll(PPLL_REF_DIV, par->constants.ref_divider);\n\taty_pll_writeupdate(par);\n\n\t \n\tif (!par->constants.ppll_min)\n\t\tpar->constants.ppll_min = 12500;\n\tif (!par->constants.ppll_max)\n\t\tpar->constants.ppll_max = 25000;     \n\tif (!par->constants.xclk)\n\t\tpar->constants.xclk = 0x1d4d;\t      \n\n\tpar->constants.fifo_width = 128;\n\tpar->constants.fifo_depth = 32;\n\n\tswitch (aty_ld_le32(MEM_CNTL) & 0x3) {\n\tcase 0:\n\t\tpar->mem = &sdr_128;\n\t\tbreak;\n\tcase 1:\n\t\tpar->mem = &sdr_sgram;\n\t\tbreak;\n\tcase 2:\n\t\tpar->mem = &ddr_sgram;\n\t\tbreak;\n\tdefault:\n\t\tpar->mem = &sdr_sgram;\n\t}\n}\n\n\n\n \n\n \nstatic void aty128_set_crtc(const struct aty128_crtc *crtc,\n\t\t\t    const struct aty128fb_par *par)\n{\n\taty_st_le32(CRTC_GEN_CNTL, crtc->gen_cntl);\n\taty_st_le32(CRTC_H_TOTAL_DISP, crtc->h_total);\n\taty_st_le32(CRTC_H_SYNC_STRT_WID, crtc->h_sync_strt_wid);\n\taty_st_le32(CRTC_V_TOTAL_DISP, crtc->v_total);\n\taty_st_le32(CRTC_V_SYNC_STRT_WID, crtc->v_sync_strt_wid);\n\taty_st_le32(CRTC_PITCH, crtc->pitch);\n\taty_st_le32(CRTC_OFFSET, crtc->offset);\n\taty_st_le32(CRTC_OFFSET_CNTL, crtc->offset_cntl);\n\t \n\taty_st_pll(PPLL_CNTL, aty_ld_pll(PPLL_CNTL) & ~(0x00030000));\n}\n\n\nstatic int aty128_var_to_crtc(const struct fb_var_screeninfo *var,\n\t\t\t      struct aty128_crtc *crtc,\n\t\t\t      const struct aty128fb_par *par)\n{\n\tu32 xres, yres, vxres, vyres, xoffset, yoffset, bpp, dst;\n\tu32 left, right, upper, lower, hslen, vslen, sync, vmode;\n\tu32 h_total, h_disp, h_sync_strt, h_sync_wid, h_sync_pol;\n\tu32 v_total, v_disp, v_sync_strt, v_sync_wid, v_sync_pol, c_sync;\n\tu32 depth, bytpp;\n\tu8 mode_bytpp[7] = { 0, 0, 1, 2, 2, 3, 4 };\n\n\t \n\txres = var->xres;\n\tyres = var->yres;\n\tvxres   = var->xres_virtual;\n\tvyres   = var->yres_virtual;\n\txoffset = var->xoffset;\n\tyoffset = var->yoffset;\n\tbpp   = var->bits_per_pixel;\n\tleft  = var->left_margin;\n\tright = var->right_margin;\n\tupper = var->upper_margin;\n\tlower = var->lower_margin;\n\thslen = var->hsync_len;\n\tvslen = var->vsync_len;\n\tsync  = var->sync;\n\tvmode = var->vmode;\n\n\tif (bpp != 16)\n\t\tdepth = bpp;\n\telse\n\t\tdepth = (var->green.length == 6) ? 16 : 15;\n\n\t \n\tif ((vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)\n\t\treturn -EINVAL;\n\n\t \n\txres = (xres + 7) & ~7;\n\txoffset = (xoffset + 7) & ~7;\n\n\tif (vxres < xres + xoffset)\n\t\tvxres = xres + xoffset;\n\n\tif (vyres < yres + yoffset)\n\t\tvyres = yres + yoffset;\n\n\t \n\tdst = depth_to_dst(depth);\n\n\tif (dst == -EINVAL) {\n\t\tprintk(KERN_ERR \"aty128fb: Invalid depth or RGBA\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbytpp = mode_bytpp[dst];\n\n\t \n\tif ((u32)(vxres * vyres * bytpp) > par->vram_size) {\n\t\tprintk(KERN_ERR \"aty128fb: Not enough memory for mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\th_disp = (xres >> 3) - 1;\n\th_total = (((xres + right + hslen + left) >> 3) - 1) & 0xFFFFL;\n\n\tv_disp = yres - 1;\n\tv_total = (yres + upper + vslen + lower - 1) & 0xFFFFL;\n\n\t \n\tif (((h_total >> 3) - 1) > 0x1ff || (v_total - 1) > 0x7FF) {\n\t\tprintk(KERN_ERR \"aty128fb: invalid width ranges\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\th_sync_wid = (hslen + 7) >> 3;\n\tif (h_sync_wid == 0)\n\t\th_sync_wid = 1;\n\telse if (h_sync_wid > 0x3f)         \n\t\th_sync_wid = 0x3f;\n\n\th_sync_strt = (h_disp << 3) + right;\n\n\tv_sync_wid = vslen;\n\tif (v_sync_wid == 0)\n\t\tv_sync_wid = 1;\n\telse if (v_sync_wid > 0x1f)         \n\t\tv_sync_wid = 0x1f;\n\n\tv_sync_strt = v_disp + lower;\n\n\th_sync_pol = sync & FB_SYNC_HOR_HIGH_ACT ? 0 : 1;\n\tv_sync_pol = sync & FB_SYNC_VERT_HIGH_ACT ? 0 : 1;\n\n\tc_sync = sync & FB_SYNC_COMP_HIGH_ACT ? (1 << 4) : 0;\n\n\tcrtc->gen_cntl = 0x3000000L | c_sync | (dst << 8);\n\n\tcrtc->h_total = h_total | (h_disp << 16);\n\tcrtc->v_total = v_total | (v_disp << 16);\n\n\tcrtc->h_sync_strt_wid = h_sync_strt | (h_sync_wid << 16) |\n\t        (h_sync_pol << 23);\n\tcrtc->v_sync_strt_wid = v_sync_strt | (v_sync_wid << 16) |\n                (v_sync_pol << 23);\n\n\tcrtc->pitch = vxres >> 3;\n\n\tcrtc->offset = 0;\n\n\tif ((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW)\n\t\tcrtc->offset_cntl = 0x00010000;\n\telse\n\t\tcrtc->offset_cntl = 0;\n\n\tcrtc->vxres = vxres;\n\tcrtc->vyres = vyres;\n\tcrtc->xoffset = xoffset;\n\tcrtc->yoffset = yoffset;\n\tcrtc->depth = depth;\n\tcrtc->bpp = bpp;\n\n\treturn 0;\n}\n\n\nstatic int aty128_pix_width_to_var(int pix_width, struct fb_var_screeninfo *var)\n{\n\n\t \n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.offset = 0;\n\tvar->blue.msb_right = 0;\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\tvar->transp.msb_right = 0;\n\tswitch (pix_width) {\n\tcase CRTC_PIX_WIDTH_8BPP:\n\t\tvar->bits_per_pixel = 8;\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\tcase CRTC_PIX_WIDTH_15BPP:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 10;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 5;\n\t\tvar->blue.length = 5;\n\t\tbreak;\n\tcase CRTC_PIX_WIDTH_16BPP:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 11;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.length = 5;\n\t\tbreak;\n\tcase CRTC_PIX_WIDTH_24BPP:\n\t\tvar->bits_per_pixel = 24;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\tcase CRTC_PIX_WIDTH_32BPP:\n\t\tvar->bits_per_pixel = 32;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"aty128fb: Invalid pixel width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int aty128_crtc_to_var(const struct aty128_crtc *crtc,\n\t\t\t      struct fb_var_screeninfo *var)\n{\n\tu32 xres, yres, left, right, upper, lower, hslen, vslen, sync;\n\tu32 h_total, h_disp, h_sync_strt, h_sync_dly, h_sync_wid, h_sync_pol;\n\tu32 v_total, v_disp, v_sync_strt, v_sync_wid, v_sync_pol, c_sync;\n\tu32 pix_width;\n\n\t \n\th_total     = crtc->h_total & 0x1ff;\n\th_disp      = (crtc->h_total >> 16) & 0xff;\n\th_sync_strt = (crtc->h_sync_strt_wid >> 3) & 0x1ff;\n\th_sync_dly  = crtc->h_sync_strt_wid & 0x7;\n\th_sync_wid  = (crtc->h_sync_strt_wid >> 16) & 0x3f;\n\th_sync_pol  = (crtc->h_sync_strt_wid >> 23) & 0x1;\n\tv_total     = crtc->v_total & 0x7ff;\n\tv_disp      = (crtc->v_total >> 16) & 0x7ff;\n\tv_sync_strt = crtc->v_sync_strt_wid & 0x7ff;\n\tv_sync_wid  = (crtc->v_sync_strt_wid >> 16) & 0x1f;\n\tv_sync_pol  = (crtc->v_sync_strt_wid >> 23) & 0x1;\n\tc_sync      = crtc->gen_cntl & CRTC_CSYNC_EN ? 1 : 0;\n\tpix_width   = crtc->gen_cntl & CRTC_PIX_WIDTH_MASK;\n\n\t \n\txres  = (h_disp + 1) << 3;\n\tyres  = v_disp + 1;\n\tleft  = ((h_total - h_sync_strt - h_sync_wid) << 3) - h_sync_dly;\n\tright = ((h_sync_strt - h_disp) << 3) + h_sync_dly;\n\thslen = h_sync_wid << 3;\n\tupper = v_total - v_sync_strt - v_sync_wid;\n\tlower = v_sync_strt - v_disp;\n\tvslen = v_sync_wid;\n\tsync  = (h_sync_pol ? 0 : FB_SYNC_HOR_HIGH_ACT) |\n\t\t(v_sync_pol ? 0 : FB_SYNC_VERT_HIGH_ACT) |\n\t\t(c_sync ? FB_SYNC_COMP_HIGH_ACT : 0);\n\n\taty128_pix_width_to_var(pix_width, var);\n\n\tvar->xres = xres;\n\tvar->yres = yres;\n\tvar->xres_virtual = crtc->vxres;\n\tvar->yres_virtual = crtc->vyres;\n\tvar->xoffset = crtc->xoffset;\n\tvar->yoffset = crtc->yoffset;\n\tvar->left_margin  = left;\n\tvar->right_margin = right;\n\tvar->upper_margin = upper;\n\tvar->lower_margin = lower;\n\tvar->hsync_len = hslen;\n\tvar->vsync_len = vslen;\n\tvar->sync  = sync;\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\n\treturn 0;\n}\n\nstatic void aty128_set_crt_enable(struct aty128fb_par *par, int on)\n{\n\tif (on) {\n\t\taty_st_le32(CRTC_EXT_CNTL, aty_ld_le32(CRTC_EXT_CNTL) |\n\t\t\t    CRT_CRTC_ON);\n\t\taty_st_le32(DAC_CNTL, (aty_ld_le32(DAC_CNTL) |\n\t\t\t    DAC_PALETTE2_SNOOP_EN));\n\t} else\n\t\taty_st_le32(CRTC_EXT_CNTL, aty_ld_le32(CRTC_EXT_CNTL) &\n\t\t\t    ~CRT_CRTC_ON);\n}\n\nstatic void aty128_set_lcd_enable(struct aty128fb_par *par, int on)\n{\n\tu32 reg;\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\n\tstruct fb_info *info = pci_get_drvdata(par->pdev);\n#endif\n\n\tif (on) {\n\t\treg = aty_ld_le32(LVDS_GEN_CNTL);\n\t\treg |= LVDS_ON | LVDS_EN | LVDS_BLON | LVDS_DIGION;\n\t\treg &= ~LVDS_DISPLAY_DIS;\n\t\taty_st_le32(LVDS_GEN_CNTL, reg);\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\n\t\taty128_bl_set_power(info, FB_BLANK_UNBLANK);\n#endif\n\t} else {\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\n\t\taty128_bl_set_power(info, FB_BLANK_POWERDOWN);\n#endif\n\t\treg = aty_ld_le32(LVDS_GEN_CNTL);\n\t\treg |= LVDS_DISPLAY_DIS;\n\t\taty_st_le32(LVDS_GEN_CNTL, reg);\n\t\tmdelay(100);\n\t\treg &= ~(LVDS_ON  );\n\t\taty_st_le32(LVDS_GEN_CNTL, reg);\n\t}\n}\n\nstatic void aty128_set_pll(struct aty128_pll *pll,\n\t\t\t   const struct aty128fb_par *par)\n{\n\tu32 div3;\n\n\t \n\tstatic const unsigned char post_conv[] = {\n\t\t2, 0, 1, 4, 2, 2, 6, 2, 3, 2, 2, 2, 7\n\t};\n\n\t \n\taty_st_le32(CLOCK_CNTL_INDEX, aty_ld_le32(CLOCK_CNTL_INDEX) | (3 << 8));\n\n\t \n\taty_st_pll(PPLL_CNTL,\n\t\t   aty_ld_pll(PPLL_CNTL) | PPLL_RESET | PPLL_ATOMIC_UPDATE_EN);\n\n\t \n\taty_pll_wait_readupdate(par);\n\taty_st_pll(PPLL_REF_DIV, par->constants.ref_divider & 0x3ff);\n\taty_pll_writeupdate(par);\n\n\tdiv3 = aty_ld_pll(PPLL_DIV_3);\n\tdiv3 &= ~PPLL_FB3_DIV_MASK;\n\tdiv3 |= pll->feedback_divider;\n\tdiv3 &= ~PPLL_POST3_DIV_MASK;\n\tdiv3 |= post_conv[pll->post_divider] << 16;\n\n\t \n\taty_pll_wait_readupdate(par);\n\taty_st_pll(PPLL_DIV_3, div3);\n\taty_pll_writeupdate(par);\n\n\taty_pll_wait_readupdate(par);\n\taty_st_pll(HTOTAL_CNTL, 0);\t \n\taty_pll_writeupdate(par);\n\n\t \n\taty_st_pll(PPLL_CNTL, aty_ld_pll(PPLL_CNTL) & ~PPLL_RESET);\n}\n\n\nstatic int aty128_var_to_pll(u32 period_in_ps, struct aty128_pll *pll,\n\t\t\t     const struct aty128fb_par *par)\n{\n\tconst struct aty128_constants c = par->constants;\n\tstatic const unsigned char post_dividers[] = { 1, 2, 4, 8, 3, 6, 12 };\n\tu32 output_freq;\n\tu32 vclk;         \n\tint i = 0;\n\tu32 n, d;\n\n\tvclk = 100000000 / period_in_ps;\t \n\n\t \n\tif (vclk > c.ppll_max)\n\t\tvclk = c.ppll_max;\n\tif (vclk * 12 < c.ppll_min)\n\t\tvclk = c.ppll_min/12;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(post_dividers); i++) {\n\t\toutput_freq = post_dividers[i] * vclk;\n\t\tif (output_freq >= c.ppll_min && output_freq <= c.ppll_max) {\n\t\t\tpll->post_divider = post_dividers[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(post_dividers))\n\t\treturn -EINVAL;\n\n\t \n\tn = c.ref_divider * output_freq;\n\td = c.ref_clk;\n\n\tpll->feedback_divider = round_div(n, d);\n\tpll->vclk = vclk;\n\n\tDBG(\"post %d feedback %d vlck %d output %d ref_divider %d \"\n\t    \"vclk_per: %d\\n\", pll->post_divider,\n\t    pll->feedback_divider, vclk, output_freq,\n\t    c.ref_divider, period_in_ps);\n\n\treturn 0;\n}\n\n\nstatic int aty128_pll_to_var(const struct aty128_pll *pll,\n\t\t\t     struct fb_var_screeninfo *var)\n{\n\tvar->pixclock = 100000000 / pll->vclk;\n\n\treturn 0;\n}\n\n\nstatic void aty128_set_fifo(const struct aty128_ddafifo *dsp,\n\t\t\t    const struct aty128fb_par *par)\n{\n\taty_st_le32(DDA_CONFIG, dsp->dda_config);\n\taty_st_le32(DDA_ON_OFF, dsp->dda_on_off);\n}\n\n\nstatic int aty128_ddafifo(struct aty128_ddafifo *dsp,\n\t\t\t  const struct aty128_pll *pll,\n\t\t\t  u32 depth,\n\t\t\t  const struct aty128fb_par *par)\n{\n\tconst struct aty128_meminfo *m = par->mem;\n\tu32 xclk = par->constants.xclk;\n\tu32 fifo_width = par->constants.fifo_width;\n\tu32 fifo_depth = par->constants.fifo_depth;\n\ts32 x, b, p, ron, roff;\n\tu32 n, d, bpp;\n\n\t \n\tbpp = (depth+7) & ~7;\n\n\tn = xclk * fifo_width;\n\td = pll->vclk * bpp;\n\tx = round_div(n, d);\n\n\tron = 4 * m->MB +\n\t\t3 * ((m->Trcd - 2 > 0) ? m->Trcd - 2 : 0) +\n\t\t2 * m->Trp +\n\t\tm->Twr +\n\t\tm->CL +\n\t\tm->Tr2w +\n\t\tx;\n\n\tDBG(\"x %x\\n\", x);\n\n\tb = 0;\n\twhile (x) {\n\t\tx >>= 1;\n\t\tb++;\n\t}\n\tp = b + 1;\n\n\tron <<= (11 - p);\n\n\tn <<= (11 - p);\n\tx = round_div(n, d);\n\troff = x * (fifo_depth - 4);\n\n\tif ((ron + m->Rloop) >= roff) {\n\t\tprintk(KERN_ERR \"aty128fb: Mode out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDBG(\"p: %x rloop: %x x: %x ron: %x roff: %x\\n\",\n\t    p, m->Rloop, x, ron, roff);\n\n\tdsp->dda_config = p << 16 | m->Rloop << 20 | x;\n\tdsp->dda_on_off = ron << 16 | roff;\n\n\treturn 0;\n}\n\n\n \nstatic int aty128fb_set_par(struct fb_info *info)\n{\n\tstruct aty128fb_par *par = info->par;\n\tu32 config;\n\tint err;\n\n\tif ((err = aty128_decode_var(&info->var, par)) != 0)\n\t\treturn err;\n\n\tif (par->blitter_may_be_busy)\n\t\twait_for_idle(par);\n\n\t \n\taty_st_le32(OVR_CLR, 0);\n\taty_st_le32(OVR_WID_LEFT_RIGHT, 0);\n\taty_st_le32(OVR_WID_TOP_BOTTOM, 0);\n\taty_st_le32(OV0_SCALE_CNTL, 0);\n\taty_st_le32(MPP_TB_CONFIG, 0);\n\taty_st_le32(MPP_GP_CONFIG, 0);\n\taty_st_le32(SUBPIC_CNTL, 0);\n\taty_st_le32(VIPH_CONTROL, 0);\n\taty_st_le32(I2C_CNTL_1, 0);          \n\taty_st_le32(GEN_INT_CNTL, 0);\t \n\taty_st_le32(CAP0_TRIG_CNTL, 0);\n\taty_st_le32(CAP1_TRIG_CNTL, 0);\n\n\taty_st_8(CRTC_EXT_CNTL + 1, 4);\t \n\n\taty128_set_crtc(&par->crtc, par);\n\taty128_set_pll(&par->pll, par);\n\taty128_set_fifo(&par->fifo_reg, par);\n\n\tconfig = aty_ld_le32(CNFG_CNTL) & ~3;\n\n#if defined(__BIG_ENDIAN)\n\tif (par->crtc.bpp == 32)\n\t\tconfig |= 2;\t \n\telse if (par->crtc.bpp == 16)\n\t\tconfig |= 1;\t \n#endif\n\n\taty_st_le32(CNFG_CNTL, config);\n\taty_st_8(CRTC_EXT_CNTL + 1, 0);\t \n\n\tinfo->fix.line_length = (par->crtc.vxres * par->crtc.bpp) >> 3;\n\tinfo->fix.visual = par->crtc.bpp == 8 ? FB_VISUAL_PSEUDOCOLOR\n\t\t: FB_VISUAL_DIRECTCOLOR;\n\n\tif (par->chip_gen == rage_M3) {\n\t\taty128_set_crt_enable(par, par->crt_on);\n\t\taty128_set_lcd_enable(par, par->lcd_on);\n\t}\n\tif (par->accel_flags & FB_ACCELF_TEXT)\n\t\taty128_init_engine(par);\n\n#ifdef CONFIG_BOOTX_TEXT\n\tbtext_update_display(info->fix.smem_start,\n\t\t\t     (((par->crtc.h_total>>16) & 0xff)+1)*8,\n\t\t\t     ((par->crtc.v_total>>16) & 0x7ff)+1,\n\t\t\t     par->crtc.bpp,\n\t\t\t     par->crtc.vxres*par->crtc.bpp/8);\n#endif  \n\n\treturn 0;\n}\n\n \n\nstatic int aty128_decode_var(struct fb_var_screeninfo *var,\n\t\t\t     struct aty128fb_par *par)\n{\n\tint err;\n\tstruct aty128_crtc crtc;\n\tstruct aty128_pll pll;\n\tstruct aty128_ddafifo fifo_reg;\n\n\tif ((err = aty128_var_to_crtc(var, &crtc, par)))\n\t\treturn err;\n\n\tif ((err = aty128_var_to_pll(var->pixclock, &pll, par)))\n\t\treturn err;\n\n\tif ((err = aty128_ddafifo(&fifo_reg, &pll, crtc.depth, par)))\n\t\treturn err;\n\n\tpar->crtc = crtc;\n\tpar->pll = pll;\n\tpar->fifo_reg = fifo_reg;\n\tpar->accel_flags = var->accel_flags;\n\n\treturn 0;\n}\n\n\nstatic int aty128_encode_var(struct fb_var_screeninfo *var,\n\t\t\t     const struct aty128fb_par *par)\n{\n\tint err;\n\n\tif ((err = aty128_crtc_to_var(&par->crtc, var)))\n\t\treturn err;\n\n\tif ((err = aty128_pll_to_var(&par->pll, var)))\n\t\treturn err;\n\n\tvar->nonstd = 0;\n\tvar->activate = 0;\n\n\tvar->height = -1;\n\tvar->width = -1;\n\tvar->accel_flags = par->accel_flags;\n\n\treturn 0;\n}\n\n\nstatic int aty128fb_check_var(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct aty128fb_par par;\n\tint err;\n\n\tpar = *(struct aty128fb_par *)info->par;\n\tif ((err = aty128_decode_var(var, &par)) != 0)\n\t\treturn err;\n\taty128_encode_var(var, &par);\n\treturn 0;\n}\n\n\n \nstatic int aty128fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *fb)\n{\n\tstruct aty128fb_par *par = fb->par;\n\tu32 xoffset, yoffset;\n\tu32 offset;\n\tu32 xres, yres;\n\n\txres = (((par->crtc.h_total >> 16) & 0xff) + 1) << 3;\n\tyres = ((par->crtc.v_total >> 16) & 0x7ff) + 1;\n\n\txoffset = (var->xoffset +7) & ~7;\n\tyoffset = var->yoffset;\n\n\tif (xoffset+xres > par->crtc.vxres || yoffset+yres > par->crtc.vyres)\n\t\treturn -EINVAL;\n\n\tpar->crtc.xoffset = xoffset;\n\tpar->crtc.yoffset = yoffset;\n\n\toffset = ((yoffset * par->crtc.vxres + xoffset) * (par->crtc.bpp >> 3))\n\t\t\t\t\t\t\t\t\t  & ~7;\n\n\tif (par->crtc.bpp == 24)\n\t\toffset += 8 * (offset % 3);  \n\n\taty_st_le32(CRTC_OFFSET, offset);\n\n\treturn 0;\n}\n\n\n \nstatic void aty128_st_pal(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t  struct aty128fb_par *par)\n{\n\tif (par->chip_gen == rage_M3) {\n\t\taty_st_le32(DAC_CNTL, aty_ld_le32(DAC_CNTL) &\n\t\t\t    ~DAC_PALETTE_ACCESS_CNTL);\n\t}\n\n\taty_st_8(PALETTE_INDEX, regno);\n\taty_st_le32(PALETTE_DATA, (red<<16)|(green<<8)|blue);\n}\n\nstatic int aty128fb_sync(struct fb_info *info)\n{\n\tstruct aty128fb_par *par = info->par;\n\n\tif (par->blitter_may_be_busy)\n\t\twait_for_idle(par);\n\treturn 0;\n}\n\n#ifndef MODULE\nstatic int aty128fb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!strncmp(this_opt, \"lcd:\", 4)) {\n\t\t\tdefault_lcd_on = simple_strtoul(this_opt+4, NULL, 0);\n\t\t\tcontinue;\n\t\t} else if (!strncmp(this_opt, \"crt:\", 4)) {\n\t\t\tdefault_crt_on = simple_strtoul(this_opt+4, NULL, 0);\n\t\t\tcontinue;\n\t\t} else if (!strncmp(this_opt, \"backlight:\", 10)) {\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\n\t\t\tbacklight = simple_strtoul(this_opt+10, NULL, 0);\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif(!strncmp(this_opt, \"nomtrr\", 6)) {\n\t\t\tmtrr = false;\n\t\t\tcontinue;\n\t\t}\n#ifdef CONFIG_PPC_PMAC\n\t\t \n\t\tif (!strncmp(this_opt, \"vmode:\", 6)) {\n\t\t\tunsigned int vmode = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\tif (vmode > 0 && vmode <= VMODE_MAX)\n\t\t\t\tdefault_vmode = vmode;\n\t\t\tcontinue;\n\t\t} else if (!strncmp(this_opt, \"cmode:\", 6)) {\n\t\t\tunsigned int cmode = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\tswitch (cmode) {\n\t\t\tcase 0:\n\t\t\tcase 8:\n\t\t\t\tdefault_cmode = CMODE_8;\n\t\t\t\tbreak;\n\t\t\tcase 15:\n\t\t\tcase 16:\n\t\t\t\tdefault_cmode = CMODE_16;\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\tcase 32:\n\t\t\t\tdefault_cmode = CMODE_32;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#endif  \n\t\tmode_option = this_opt;\n\t}\n\treturn 0;\n}\n#endif   \n\n \n#ifdef CONFIG_FB_ATY128_BACKLIGHT\n#define MAX_LEVEL 0xFF\n\nstatic int aty128_bl_get_level_brightness(struct aty128fb_par *par,\n\t\tint level)\n{\n\tstruct fb_info *info = pci_get_drvdata(par->pdev);\n\tint atylevel;\n\n\t \n\t \n\tatylevel = MAX_LEVEL -\n\t\t(info->bl_curve[level] * FB_BACKLIGHT_MAX / MAX_LEVEL);\n\n\tif (atylevel < 0)\n\t\tatylevel = 0;\n\telse if (atylevel > MAX_LEVEL)\n\t\tatylevel = MAX_LEVEL;\n\n\treturn atylevel;\n}\n\n \n#define BACKLIGHT_LVDS_OFF\n \n#undef BACKLIGHT_DAC_OFF\n\nstatic int aty128_bl_update_status(struct backlight_device *bd)\n{\n\tstruct aty128fb_par *par = bl_get_data(bd);\n\tunsigned int reg = aty_ld_le32(LVDS_GEN_CNTL);\n\tint level;\n\n\tif (!par->lcd_on)\n\t\tlevel = 0;\n\telse\n\t\tlevel = backlight_get_brightness(bd);\n\n\treg |= LVDS_BL_MOD_EN | LVDS_BLON;\n\tif (level > 0) {\n\t\treg |= LVDS_DIGION;\n\t\tif (!(reg & LVDS_ON)) {\n\t\t\treg &= ~LVDS_BLON;\n\t\t\taty_st_le32(LVDS_GEN_CNTL, reg);\n\t\t\taty_ld_le32(LVDS_GEN_CNTL);\n\t\t\tmdelay(10);\n\t\t\treg |= LVDS_BLON;\n\t\t\taty_st_le32(LVDS_GEN_CNTL, reg);\n\t\t}\n\t\treg &= ~LVDS_BL_MOD_LEVEL_MASK;\n\t\treg |= (aty128_bl_get_level_brightness(par, level) <<\n\t\t\tLVDS_BL_MOD_LEVEL_SHIFT);\n#ifdef BACKLIGHT_LVDS_OFF\n\t\treg |= LVDS_ON | LVDS_EN;\n\t\treg &= ~LVDS_DISPLAY_DIS;\n#endif\n\t\taty_st_le32(LVDS_GEN_CNTL, reg);\n#ifdef BACKLIGHT_DAC_OFF\n\t\taty_st_le32(DAC_CNTL, aty_ld_le32(DAC_CNTL) & (~DAC_PDWN));\n#endif\n\t} else {\n\t\treg &= ~LVDS_BL_MOD_LEVEL_MASK;\n\t\treg |= (aty128_bl_get_level_brightness(par, 0) <<\n\t\t\tLVDS_BL_MOD_LEVEL_SHIFT);\n#ifdef BACKLIGHT_LVDS_OFF\n\t\treg |= LVDS_DISPLAY_DIS;\n\t\taty_st_le32(LVDS_GEN_CNTL, reg);\n\t\taty_ld_le32(LVDS_GEN_CNTL);\n\t\tudelay(10);\n\t\treg &= ~(LVDS_ON | LVDS_EN | LVDS_BLON | LVDS_DIGION);\n#endif\n\t\taty_st_le32(LVDS_GEN_CNTL, reg);\n#ifdef BACKLIGHT_DAC_OFF\n\t\taty_st_le32(DAC_CNTL, aty_ld_le32(DAC_CNTL) | DAC_PDWN);\n#endif\n\t}\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops aty128_bl_data = {\n\t.update_status\t= aty128_bl_update_status,\n};\n\nstatic void aty128_bl_set_power(struct fb_info *info, int power)\n{\n\tif (info->bl_dev) {\n\t\tinfo->bl_dev->props.power = power;\n\t\tbacklight_update_status(info->bl_dev);\n\t}\n}\n\nstatic void aty128_bl_init(struct aty128fb_par *par)\n{\n\tstruct backlight_properties props;\n\tstruct fb_info *info = pci_get_drvdata(par->pdev);\n\tstruct backlight_device *bd;\n\tchar name[12];\n\n\t \n\tif (par->chip_gen != rage_M3)\n\t\treturn;\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n\tif (!pmac_has_backlight_type(\"ati\"))\n\t\treturn;\n#endif\n\n\tsnprintf(name, sizeof(name), \"aty128bl%d\", info->node);\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = FB_BACKLIGHT_LEVELS - 1;\n\tbd = backlight_device_register(name, info->device, par, &aty128_bl_data,\n\t\t\t\t       &props);\n\tif (IS_ERR(bd)) {\n\t\tinfo->bl_dev = NULL;\n\t\tprintk(KERN_WARNING \"aty128: Backlight registration failed\\n\");\n\t\tgoto error;\n\t}\n\n\tinfo->bl_dev = bd;\n\tfb_bl_default_curve(info, 0,\n\t\t 63 * FB_BACKLIGHT_MAX / MAX_LEVEL,\n\t\t219 * FB_BACKLIGHT_MAX / MAX_LEVEL);\n\n\tbd->props.brightness = bd->props.max_brightness;\n\tbd->props.power = FB_BLANK_UNBLANK;\n\tbacklight_update_status(bd);\n\n\tprintk(\"aty128: Backlight initialized (%s)\\n\", name);\n\n\treturn;\n\nerror:\n\treturn;\n}\n\nstatic void aty128_bl_exit(struct backlight_device *bd)\n{\n\tbacklight_device_unregister(bd);\n\tprintk(\"aty128: Backlight unloaded\\n\");\n}\n#endif  \n\n \n\n#ifdef CONFIG_PPC_PMAC__disabled\nstatic void aty128_early_resume(void *data)\n{\n        struct aty128fb_par *par = data;\n\n\tif (!console_trylock())\n\t\treturn;\n\tpci_restore_state(par->pdev);\n\taty128_do_resume(par->pdev);\n\tconsole_unlock();\n}\n#endif  \n\nstatic int aty128_init(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct aty128fb_par *par = info->par;\n\tstruct fb_var_screeninfo var;\n\tchar video_card[50];\n\tu8 chip_rev;\n\tu32 dac;\n\n\t \n\tchip_rev = (aty_ld_le32(CNFG_CNTL) >> 16) & 0x1F;\n\n\tstrcpy(video_card, \"Rage128 XX \");\n\tvideo_card[8] = ent->device >> 8;\n\tvideo_card[9] = ent->device & 0xFF;\n\n\t \n\tif (ent->driver_data < ARRAY_SIZE(r128_family))\n\t\tstrlcat(video_card, r128_family[ent->driver_data],\n\t\t\tsizeof(video_card));\n\n\tprintk(KERN_INFO \"aty128fb: %s [chip rev 0x%x] \", video_card, chip_rev);\n\n\tif (par->vram_size % (1024 * 1024) == 0)\n\t\tprintk(\"%dM %s\\n\", par->vram_size / (1024*1024), par->mem->name);\n\telse\n\t\tprintk(\"%dk %s\\n\", par->vram_size / 1024, par->mem->name);\n\n\tpar->chip_gen = ent->driver_data;\n\n\t \n\tinfo->fbops = &aty128fb_ops;\n\n\tpar->lcd_on = default_lcd_on;\n\tpar->crt_on = default_crt_on;\n\n\tvar = default_var;\n#ifdef CONFIG_PPC_PMAC\n\tif (machine_is(powermac)) {\n\t\t \n\t\tif (par->chip_gen == rage_M3) {\n\t\t\tpmac_call_feature(PMAC_FTR_DEVICE_CAN_WAKE, NULL, 0, 1);\n#if 0  \n\t\t\tpmac_set_early_video_resume(aty128_early_resume, par);\n#endif\n\t\t}\n\n\t\t \n\t\tif (mode_option) {\n\t\t\tif (!mac_find_mode(&var, info, mode_option, 8))\n\t\t\t\tvar = default_var;\n\t\t} else {\n\t\t\tif (default_vmode <= 0 || default_vmode > VMODE_MAX)\n\t\t\t\tdefault_vmode = VMODE_1024_768_60;\n\n\t\t\t \n\t\t\tif (of_machine_is_compatible(\"PowerMac2,1\") ||\n\t\t\t    of_machine_is_compatible(\"PowerMac2,2\") ||\n\t\t\t    of_machine_is_compatible(\"PowerMac4,1\"))\n\t\t\t\tdefault_vmode = VMODE_1024_768_75;\n\n\t\t\t \n\t\t\tif (of_machine_is_compatible(\"PowerBook2,2\"))\n\t\t\t\tdefault_vmode = VMODE_800_600_60;\n\n\t\t\t \n\t\t\tif (of_machine_is_compatible(\"PowerBook3,1\") ||\n\t\t\t    of_machine_is_compatible(\"PowerBook4,1\"))\n\t\t\t\tdefault_vmode = VMODE_1024_768_60;\n\n\t\t\t \n\t\t\tif (of_machine_is_compatible(\"PowerBook3,2\"))\n\t\t\t\tdefault_vmode = VMODE_1152_768_60;\n\n\t\t\tif (default_cmode > 16)\n\t\t\t\tdefault_cmode = CMODE_32;\n\t\t\telse if (default_cmode > 8)\n\t\t\t\tdefault_cmode = CMODE_16;\n\t\t\telse\n\t\t\t\tdefault_cmode = CMODE_8;\n\n\t\t\tif (mac_vmode_to_var(default_vmode, default_cmode, &var))\n\t\t\t\tvar = default_var;\n\t\t}\n\t} else\n#endif  \n\t{\n\t\tif (mode_option)\n\t\t\tif (fb_find_mode(&var, info, mode_option, NULL,\n\t\t\t\t\t 0, &defaultmode, 8) == 0)\n\t\t\t\tvar = default_var;\n\t}\n\n\tvar.accel_flags &= ~FB_ACCELF_TEXT;\n\n\n\tif (aty128fb_check_var(&var, info)) {\n\t\tprintk(KERN_ERR \"aty128fb: Cannot set default mode.\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tdac = aty_ld_le32(DAC_CNTL);\n\tdac |= (DAC_8BIT_EN | DAC_RANGE_CNTL);\n\tdac |= DAC_MASK;\n\tif (par->chip_gen == rage_M3)\n\t\tdac |= DAC_PALETTE2_SNOOP_EN;\n\taty_st_le32(DAC_CNTL, dac);\n\n\t \n\taty_st_le32(BUS_CNTL, aty_ld_le32(BUS_CNTL) | BUS_MASTER_DIS);\n\n\tinfo->var = var;\n\tfb_alloc_cmap(&info->cmap, 256, 0);\n\n\tvar.activate = FB_ACTIVATE_NOW;\n\n\taty128_init_engine(par);\n\n\tpar->pdev = pdev;\n\tpar->asleep = 0;\n\tpar->lock_blank = 0;\n\n\tif (register_framebuffer(info) < 0)\n\t\treturn 0;\n\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\n\tif (backlight)\n\t\taty128_bl_init(par);\n#endif\n\n\tfb_info(info, \"%s frame buffer device on %s\\n\",\n\t\tinfo->fix.id, video_card);\n\n\treturn 1;\t \n}\n\n#ifdef CONFIG_PCI\n \nstatic int aty128_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tunsigned long fb_addr, reg_addr;\n\tstruct aty128fb_par *par;\n\tstruct fb_info *info;\n\tint err;\n#ifndef __sparc__\n\tvoid __iomem *bios = NULL;\n#endif\n\n\terr = aperture_remove_conflicting_pci_devices(pdev, \"aty128fb\");\n\tif (err)\n\t\treturn err;\n\n\t \n\tif ((err = pci_enable_device(pdev))) {\n\t\tprintk(KERN_ERR \"aty128fb: Cannot enable PCI device: %d\\n\",\n\t\t\t\terr);\n\t\treturn -ENODEV;\n\t}\n\n\tfb_addr = pci_resource_start(pdev, 0);\n\tif (!request_mem_region(fb_addr, pci_resource_len(pdev, 0),\n\t\t\t\t\"aty128fb FB\")) {\n\t\tprintk(KERN_ERR \"aty128fb: cannot reserve frame \"\n\t\t\t\t\"buffer memory\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treg_addr = pci_resource_start(pdev, 2);\n\tif (!request_mem_region(reg_addr, pci_resource_len(pdev, 2),\n\t\t\t\t\"aty128fb MMIO\")) {\n\t\tprintk(KERN_ERR \"aty128fb: cannot reserve MMIO region\\n\");\n\t\tgoto err_free_fb;\n\t}\n\n\t \n\tinfo = framebuffer_alloc(sizeof(struct aty128fb_par), &pdev->dev);\n\tif (!info)\n\t\tgoto err_free_mmio;\n\n\tpar = info->par;\n\n\tinfo->pseudo_palette = par->pseudo_palette;\n\n\t \n\tinfo->fix.mmio_start = reg_addr;\n\tpar->regbase = pci_ioremap_bar(pdev, 2);\n\tif (!par->regbase)\n\t\tgoto err_free_info;\n\n\t \n\t\n\tpar->vram_size = aty_ld_le32(CNFG_MEMSIZE) & 0x03FFFFFF;\n\n\t \n\tinfo->screen_base = ioremap_wc(fb_addr, par->vram_size);\n\tif (!info->screen_base)\n\t\tgoto err_unmap_out;\n\n\t \n\tinfo->fix = aty128fb_fix;\n\tinfo->fix.smem_start = fb_addr;\n\tinfo->fix.smem_len = par->vram_size;\n\tinfo->fix.mmio_start = reg_addr;\n\n\t \n\tif (!register_test(par)) {\n\t\tprintk(KERN_ERR \"aty128fb: Can't write to video register!\\n\");\n\t\tgoto err_out;\n\t}\n\n#ifndef __sparc__\n\tbios = aty128_map_ROM(par, pdev);\n#ifdef CONFIG_X86\n\tif (bios == NULL)\n\t\tbios = aty128_find_mem_vbios(par);\n#endif\n\tif (bios == NULL)\n\t\tprintk(KERN_INFO \"aty128fb: BIOS not located, guessing timings.\\n\");\n\telse {\n\t\tprintk(KERN_INFO \"aty128fb: Rage128 BIOS located\\n\");\n\t\taty128_get_pllinfo(par, bios);\n\t\tpci_unmap_rom(pdev, bios);\n\t}\n#endif  \n\n\taty128_timings(par);\n\tpci_set_drvdata(pdev, info);\n\n\tif (!aty128_init(pdev, ent))\n\t\tgoto err_out;\n\n\tif (mtrr)\n\t\tpar->wc_cookie = arch_phys_wc_add(info->fix.smem_start,\n\t\t\t\t\t\t  par->vram_size);\n\treturn 0;\n\nerr_out:\n\tiounmap(info->screen_base);\nerr_unmap_out:\n\tiounmap(par->regbase);\nerr_free_info:\n\tframebuffer_release(info);\nerr_free_mmio:\n\trelease_mem_region(pci_resource_start(pdev, 2),\n\t\t\tpci_resource_len(pdev, 2));\nerr_free_fb:\n\trelease_mem_region(pci_resource_start(pdev, 0),\n\t\t\tpci_resource_len(pdev, 0));\n\treturn -ENODEV;\n}\n\nstatic void aty128_remove(struct pci_dev *pdev)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct aty128fb_par *par;\n\n\tif (!info)\n\t\treturn;\n\n\tpar = info->par;\n\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\n\taty128_bl_exit(info->bl_dev);\n#endif\n\n\tunregister_framebuffer(info);\n\n\tarch_phys_wc_del(par->wc_cookie);\n\tiounmap(par->regbase);\n\tiounmap(info->screen_base);\n\n\trelease_mem_region(pci_resource_start(pdev, 0),\n\t\t\t   pci_resource_len(pdev, 0));\n\trelease_mem_region(pci_resource_start(pdev, 2),\n\t\t\t   pci_resource_len(pdev, 2));\n\tframebuffer_release(info);\n}\n#endif  \n\n\n\n     \nstatic int aty128fb_blank(int blank, struct fb_info *fb)\n{\n\tstruct aty128fb_par *par = fb->par;\n\tu8 state;\n\n\tif (par->lock_blank || par->asleep)\n\t\treturn 0;\n\n\tswitch (blank) {\n\tcase FB_BLANK_NORMAL:\n\t\tstate = 4;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tstate = 6;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tstate = 5;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tstate = 7;\n\t\tbreak;\n\tcase FB_BLANK_UNBLANK:\n\tdefault:\n\t\tstate = 0;\n\t\tbreak;\n\t}\n\taty_st_8(CRTC_EXT_CNTL+1, state);\n\n\tif (par->chip_gen == rage_M3) {\n\t\taty128_set_crt_enable(par, par->crt_on && !blank);\n\t\taty128_set_lcd_enable(par, par->lcd_on && !blank);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int aty128fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t      u_int transp, struct fb_info *info)\n{\n\tstruct aty128fb_par *par = info->par;\n\n\tif (regno > 255\n\t    || (par->crtc.depth == 16 && regno > 63)\n\t    || (par->crtc.depth == 15 && regno > 31))\n\t\treturn 1;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\tif (regno < 16) {\n\t\tint i;\n\t\tu32 *pal = info->pseudo_palette;\n\n\t\tswitch (par->crtc.depth) {\n\t\tcase 15:\n\t\t\tpal[regno] = (regno << 10) | (regno << 5) | regno;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tpal[regno] = (regno << 11) | (regno << 6) | regno;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tpal[regno] = (regno << 16) | (regno << 8) | regno;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\ti = (regno << 8) | regno;\n\t\t\tpal[regno] = (i << 16) | i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (par->crtc.depth == 16 && regno > 0) {\n\t\t \n\t\tpar->green[regno] = green;\n\t\tif (regno < 32) {\n\t\t\tpar->red[regno] = red;\n\t\t\tpar->blue[regno] = blue;\n\t\t\taty128_st_pal(regno * 8, red, par->green[regno*2],\n\t\t\t\t      blue, par);\n\t\t}\n\t\tred = par->red[regno/2];\n\t\tblue = par->blue[regno/2];\n\t\tregno <<= 2;\n\t} else if (par->crtc.bpp == 16)\n\t\tregno <<= 3;\n\taty128_st_pal(regno, red, green, blue, par);\n\n\treturn 0;\n}\n\n#define ATY_MIRROR_LCD_ON\t0x00000001\n#define ATY_MIRROR_CRT_ON\t0x00000002\n\n \n#define FBIO_ATY128_GET_MIRROR\t_IOR('@', 1, __u32)\n \n#define FBIO_ATY128_SET_MIRROR\t_IOW('@', 2, __u32)\n\nstatic int aty128fb_ioctl(struct fb_info *info, u_int cmd, u_long arg)\n{\n\tstruct aty128fb_par *par = info->par;\n\tu32 value;\n\tint rc;\n\n\tswitch (cmd) {\n\tcase FBIO_ATY128_SET_MIRROR:\n\t\tif (par->chip_gen != rage_M3)\n\t\t\treturn -EINVAL;\n\t\trc = get_user(value, (__u32 __user *)arg);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tpar->lcd_on = (value & 0x01) != 0;\n\t\tpar->crt_on = (value & 0x02) != 0;\n\t\tif (!par->crt_on && !par->lcd_on)\n\t\t\tpar->lcd_on = 1;\n\t\taty128_set_crt_enable(par, par->crt_on);\n\t\taty128_set_lcd_enable(par, par->lcd_on);\n\t\treturn 0;\n\tcase FBIO_ATY128_GET_MIRROR:\n\t\tif (par->chip_gen != rage_M3)\n\t\t\treturn -EINVAL;\n\t\tvalue = (par->crt_on << 1) | par->lcd_on;\n\t\treturn put_user(value, (__u32 __user *)arg);\n\t}\n\treturn -EINVAL;\n}\n\nstatic void aty128_set_suspend(struct aty128fb_par *par, int suspend)\n{\n\tu32\tpmgt;\n\n\tif (!par->pdev->pm_cap)\n\t\treturn;\n\n\t \n\tif (suspend) {\n\t\t \n\t\taty_st_le32(CRTC2_GEN_CNTL, aty_ld_le32(CRTC2_GEN_CNTL) &\n\t\t\t~(CRTC2_EN));\n\n\t\t \n\t\t \n\t\tpmgt = 0x0c005407;\n\t\taty_st_pll(POWER_MANAGEMENT, pmgt);\n\t\t(void)aty_ld_pll(POWER_MANAGEMENT);\n\t\taty_st_le32(BUS_CNTL1, 0x00000010);\n\t\taty_st_le32(MEM_POWER_MISC, 0x0c830000);\n\t\tmsleep(100);\n\t}\n}\n\nstatic int aty128_pci_suspend_late(struct device *dev, pm_message_t state)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct aty128fb_par *par = info->par;\n\n\t \n#ifndef CONFIG_PPC_PMAC\n\t \n\treturn 0;\n#endif  \n\n\tif (state.event == pdev->dev.power.power_state.event)\n\t\treturn 0;\n\n\tprintk(KERN_DEBUG \"aty128fb: suspending...\\n\");\n\n\tconsole_lock();\n\n\tfb_set_suspend(info, 1);\n\n\t \n\twait_for_idle(par);\n\taty128_reset_engine(par);\n\twait_for_idle(par);\n\n\t \n\taty128fb_blank(FB_BLANK_POWERDOWN, info);\n\n\t \n\tpar->asleep = 1;\n\tpar->lock_blank = 1;\n\n#ifdef CONFIG_PPC_PMAC\n\t \n\tpmac_suspend_agp_for_card(pdev);\n#endif  \n\n\t \n\tif (state.event != PM_EVENT_ON)\n\t\taty128_set_suspend(par, 1);\n\n\tconsole_unlock();\n\n\tpdev->dev.power.power_state = state;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused aty128_pci_suspend(struct device *dev)\n{\n\treturn aty128_pci_suspend_late(dev, PMSG_SUSPEND);\n}\n\nstatic int __maybe_unused aty128_pci_hibernate(struct device *dev)\n{\n\treturn aty128_pci_suspend_late(dev, PMSG_HIBERNATE);\n}\n\nstatic int __maybe_unused aty128_pci_freeze(struct device *dev)\n{\n\treturn aty128_pci_suspend_late(dev, PMSG_FREEZE);\n}\n\nstatic int aty128_do_resume(struct pci_dev *pdev)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct aty128fb_par *par = info->par;\n\n\tif (pdev->dev.power.power_state.event == PM_EVENT_ON)\n\t\treturn 0;\n\n\t \n\n\t \n\taty128_set_suspend(par, 0);\n\tpar->asleep = 0;\n\n\t \n\taty128_reset_engine(par);\n\twait_for_idle(par);\n\taty128fb_set_par(info);\n\tfb_pan_display(info, &info->var);\n\tfb_set_cmap(&info->cmap, info);\n\n\t \n\tfb_set_suspend(info, 0);\n\n\t \n\tpar->lock_blank = 0;\n\taty128fb_blank(0, info);\n\n#ifdef CONFIG_PPC_PMAC\n\t \n\tpmac_resume_agp_for_card(pdev);\n#endif  \n\n\tpdev->dev.power.power_state = PMSG_ON;\n\n\tprintk(KERN_DEBUG \"aty128fb: resumed !\\n\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused aty128_pci_resume(struct device *dev)\n{\n\tint rc;\n\n\tconsole_lock();\n\trc = aty128_do_resume(to_pci_dev(dev));\n\tconsole_unlock();\n\n\treturn rc;\n}\n\n\nstatic int aty128fb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"aty128fb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"aty128fb\", &option))\n\t\treturn -ENODEV;\n\taty128fb_setup(option);\n#endif\n\n\treturn pci_register_driver(&aty128fb_driver);\n}\n\nstatic void __exit aty128fb_exit(void)\n{\n\tpci_unregister_driver(&aty128fb_driver);\n}\n\nmodule_init(aty128fb_init);\n\nmodule_exit(aty128fb_exit);\n\nMODULE_AUTHOR(\"(c)1999-2003 Brad Douglas <brad@neruo.com>\");\nMODULE_DESCRIPTION(\"FBDev driver for ATI Rage128 / Pro cards\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Specify resolution as \\\"<xres>x<yres>[-<bpp>][@<refresh>]\\\" \");\nmodule_param_named(nomtrr, mtrr, invbool, 0);\nMODULE_PARM_DESC(nomtrr, \"bool: Disable MTRR support (0 or 1=disabled) (default=0)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}