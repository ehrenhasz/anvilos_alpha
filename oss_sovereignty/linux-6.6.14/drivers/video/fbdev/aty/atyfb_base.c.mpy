{
  "module_name": "atyfb_base.c",
  "hash_id": "bdd75ffe4f041e04afed0949acd28d9951669fdd6cb14e2faabf8f11181d4d49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/aty/atyfb_base.c",
  "human_readable_source": " \n\n \n\n#include <linux/aperture.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/compiler.h>\n#include <linux/console.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n#include <linux/backlight.h>\n#include <linux/reboot.h>\n#include <linux/dmi.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include <video/mach64.h>\n#include \"atyfb.h\"\n#include \"ati_ids.h\"\n\n#ifdef __powerpc__\n#include <asm/machdep.h>\n#include \"../macmodes.h\"\n#endif\n#ifdef __sparc__\n#include <asm/fbio.h>\n#include <asm/oplib.h>\n#include <asm/prom.h>\n#endif\n\n#ifdef CONFIG_ADB_PMU\n#include <linux/adb.h>\n#include <linux/pmu.h>\n#endif\n#ifdef CONFIG_BOOTX_TEXT\n#include <asm/btext.h>\n#endif\n#ifdef CONFIG_PMAC_BACKLIGHT\n#include <asm/backlight.h>\n#endif\n\n \n#undef DEBUG\n \n\n \n \n \n#define GUI_RESERVE\t(1 * PAGE_SIZE)\n\n \n#define FAIL(msg) do { \\\n\tif (!(var->activate & FB_ACTIVATE_TEST)) \\\n\t\tprintk(KERN_CRIT \"atyfb: \" msg \"\\n\"); \\\n\treturn -EINVAL; \\\n} while (0)\n#define FAIL_MAX(msg, x, _max_) do { \\\n\tif (x > _max_) { \\\n\t\tif (!(var->activate & FB_ACTIVATE_TEST)) \\\n\t\t\tprintk(KERN_CRIT \"atyfb: \" msg \" %x(%x)\\n\", x, _max_); \\\n\t\treturn -EINVAL; \\\n\t} \\\n} while (0)\n#ifdef DEBUG\n#define DPRINTK(fmt, args...)\tprintk(KERN_DEBUG \"atyfb: \" fmt, ## args)\n#else\n#define DPRINTK(fmt, args...)\tno_printk(fmt, ##args)\n#endif\n\n#define PRINTKI(fmt, args...)\tprintk(KERN_INFO \"atyfb: \" fmt, ## args)\n#define PRINTKE(fmt, args...)\tprintk(KERN_ERR \"atyfb: \" fmt, ## args)\n\n#if defined(CONFIG_PMAC_BACKLIGHT) || defined(CONFIG_FB_ATY_GENERIC_LCD) || \\\ndefined(CONFIG_FB_ATY_BACKLIGHT) || defined (CONFIG_PPC_PMAC)\nstatic const u32 lt_lcd_regs[] = {\n\tCNFG_PANEL_LG,\n\tLCD_GEN_CNTL_LG,\n\tDSTN_CONTROL_LG,\n\tHFB_PITCH_ADDR_LG,\n\tHORZ_STRETCHING_LG,\n\tVERT_STRETCHING_LG,\n\t0,  \n\tLT_GIO_LG,\n\tPOWER_MANAGEMENT_LG\n};\n\nvoid aty_st_lcd(int index, u32 val, const struct atyfb_par *par)\n{\n\tif (M64_HAS(LT_LCD_REGS)) {\n\t\taty_st_le32(lt_lcd_regs[index], val, par);\n\t} else {\n\t\tunsigned long temp;\n\n\t\t \n\t\ttemp = aty_ld_le32(LCD_INDEX, par);\n\t\taty_st_le32(LCD_INDEX, (temp & ~LCD_INDEX_MASK) | index, par);\n\t\t \n\t\taty_st_le32(LCD_DATA, val, par);\n\t}\n}\n\nu32 aty_ld_lcd(int index, const struct atyfb_par *par)\n{\n\tif (M64_HAS(LT_LCD_REGS)) {\n\t\treturn aty_ld_le32(lt_lcd_regs[index], par);\n\t} else {\n\t\tunsigned long temp;\n\n\t\t \n\t\ttemp = aty_ld_le32(LCD_INDEX, par);\n\t\taty_st_le32(LCD_INDEX, (temp & ~LCD_INDEX_MASK) | index, par);\n\t\t \n\t\treturn aty_ld_le32(LCD_DATA, par);\n\t}\n}\n#else  \nvoid aty_st_lcd(int index, u32 val, const struct atyfb_par *par)\n{ }\n\nu32 aty_ld_lcd(int index, const struct atyfb_par *par)\n{\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n \nstatic void ATIReduceRatio(int *Numerator, int *Denominator)\n{\n\tint Multiplier, Divider, Remainder;\n\n\tMultiplier = *Numerator;\n\tDivider = *Denominator;\n\n\twhile ((Remainder = Multiplier % Divider)) {\n\t\tMultiplier = Divider;\n\t\tDivider = Remainder;\n\t}\n\n\t*Numerator /= Divider;\n\t*Denominator /= Divider;\n}\n#endif\n \n\nstruct pci_mmap_map {\n\tunsigned long voff;\n\tunsigned long poff;\n\tunsigned long size;\n\tunsigned long prot_flag;\n\tunsigned long prot_mask;\n};\n\nstatic const struct fb_fix_screeninfo atyfb_fix = {\n\t.id\t\t= \"ATY Mach64\",\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.visual\t\t= FB_VISUAL_PSEUDOCOLOR,\n\t.xpanstep\t= 8,\n\t.ypanstep\t= 1,\n};\n\n \n\nstatic int atyfb_open(struct fb_info *info, int user);\nstatic int atyfb_release(struct fb_info *info, int user);\nstatic int atyfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t   struct fb_info *info);\nstatic int atyfb_set_par(struct fb_info *info);\nstatic int atyfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t   u_int transp, struct fb_info *info);\nstatic int atyfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info);\nstatic int atyfb_blank(int blank, struct fb_info *info);\nstatic int atyfb_ioctl(struct fb_info *info, u_int cmd, u_long arg);\n#ifdef CONFIG_COMPAT\nstatic int atyfb_compat_ioctl(struct fb_info *info, u_int cmd, u_long arg)\n{\n\treturn atyfb_ioctl(info, cmd, (u_long)compat_ptr(arg));\n}\n#endif\n\n#ifdef __sparc__\nstatic int atyfb_mmap(struct fb_info *info, struct vm_area_struct *vma);\n#endif\nstatic int atyfb_sync(struct fb_info *info);\n\n \n\nstatic int aty_init(struct fb_info *info);\n\nstatic void aty_get_crtc(const struct atyfb_par *par, struct crtc *crtc);\n\nstatic void aty_set_crtc(const struct atyfb_par *par, const struct crtc *crtc);\nstatic int aty_var_to_crtc(const struct fb_info *info,\n\t\t\t   const struct fb_var_screeninfo *var,\n\t\t\t   struct crtc *crtc);\nstatic int aty_crtc_to_var(const struct crtc *crtc,\n\t\t\t   struct fb_var_screeninfo *var);\nstatic void set_off_pitch(struct atyfb_par *par, const struct fb_info *info);\n#ifdef CONFIG_PPC\nstatic int read_aty_sense(const struct atyfb_par *par);\n#endif\n\nstatic DEFINE_MUTEX(reboot_lock);\nstatic struct fb_info *reboot_info;\n\n \n\nstatic struct fb_var_screeninfo default_var = {\n\t \n\t640, 480, 640, 480, 0, 0, 8, 0,\n\t{0, 8, 0}, {0, 8, 0}, {0, 8, 0}, {0, 0, 0},\n\t0, 0, -1, -1, 0, 39722, 48, 16, 33, 10, 96, 2,\n\t0, FB_VMODE_NONINTERLACED\n};\n\nstatic const struct fb_videomode defmode = {\n\t \n\tNULL, 60, 640, 480, 39721, 40, 24, 32, 11, 96, 2,\n\t0, FB_VMODE_NONINTERLACED\n};\n\nstatic struct fb_ops atyfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= atyfb_open,\n\t.fb_release\t= atyfb_release,\n\t.fb_check_var\t= atyfb_check_var,\n\t.fb_set_par\t= atyfb_set_par,\n\t.fb_setcolreg\t= atyfb_setcolreg,\n\t.fb_pan_display\t= atyfb_pan_display,\n\t.fb_blank\t= atyfb_blank,\n\t.fb_ioctl\t= atyfb_ioctl,\n#ifdef CONFIG_COMPAT\n\t.fb_compat_ioctl = atyfb_compat_ioctl,\n#endif\n\t.fb_fillrect\t= atyfb_fillrect,\n\t.fb_copyarea\t= atyfb_copyarea,\n\t.fb_imageblit\t= atyfb_imageblit,\n#ifdef __sparc__\n\t.fb_mmap\t= atyfb_mmap,\n#endif\n\t.fb_sync\t= atyfb_sync,\n};\n\nstatic bool noaccel;\nstatic bool nomtrr;\nstatic int vram;\nstatic int pll;\nstatic int mclk;\nstatic int xclk;\nstatic int comp_sync = -1;\nstatic char *mode;\nstatic int backlight = IS_BUILTIN(CONFIG_PMAC_BACKLIGHT);\n\n#ifdef CONFIG_PPC\nstatic int default_vmode = VMODE_CHOOSE;\nstatic int default_cmode = CMODE_CHOOSE;\n\nmodule_param_named(vmode, default_vmode, int, 0);\nMODULE_PARM_DESC(vmode, \"int: video mode for mac\");\nmodule_param_named(cmode, default_cmode, int, 0);\nMODULE_PARM_DESC(cmode, \"int: color mode for mac\");\n#endif\n\n#ifdef CONFIG_ATARI\nstatic unsigned int mach64_count = 0;\nstatic unsigned long phys_vmembase[FB_MAX] = { 0, };\nstatic unsigned long phys_size[FB_MAX] = { 0, };\nstatic unsigned long phys_guiregbase[FB_MAX] = { 0, };\n#endif\n\n \n#define ATI_CHIP_88800GX   (M64F_GX)\n#define ATI_CHIP_88800CX   (M64F_GX)\n\n#define ATI_CHIP_264CT     (M64F_CT | M64F_INTEGRATED | M64F_CT_BUS | M64F_MAGIC_FIFO)\n#define ATI_CHIP_264ET     (M64F_CT | M64F_INTEGRATED | M64F_CT_BUS | M64F_MAGIC_FIFO)\n\n#define ATI_CHIP_264VT     (M64F_VT | M64F_INTEGRATED | M64F_VT_BUS | M64F_MAGIC_FIFO)\n#define ATI_CHIP_264GT     (M64F_GT | M64F_INTEGRATED               | M64F_MAGIC_FIFO | M64F_EXTRA_BRIGHT)\n\n#define ATI_CHIP_264VTB    (M64F_VT | M64F_INTEGRATED | M64F_VT_BUS | M64F_GTB_DSP)\n#define ATI_CHIP_264VT3    (M64F_VT | M64F_INTEGRATED | M64F_VT_BUS | M64F_GTB_DSP | M64F_SDRAM_MAGIC_PLL)\n#define ATI_CHIP_264VT4    (M64F_VT | M64F_INTEGRATED               | M64F_GTB_DSP)\n\n \n#define ATI_CHIP_264LT     (M64F_GT | M64F_INTEGRATED               | M64F_GTB_DSP)\n\n \n#define ATI_MODERN_SET     (M64F_GT | M64F_INTEGRATED               | M64F_GTB_DSP | M64F_EXTRA_BRIGHT)\n\n#define ATI_CHIP_264GTB    (ATI_MODERN_SET | M64F_SDRAM_MAGIC_PLL)\n \n#define ATI_CHIP_264LTG    (ATI_MODERN_SET | M64F_SDRAM_MAGIC_PLL)\n\n#define ATI_CHIP_264GT2C   (ATI_MODERN_SET | M64F_SDRAM_MAGIC_PLL | M64F_HW_TRIPLE)\n#define ATI_CHIP_264GTPRO  (ATI_MODERN_SET | M64F_SDRAM_MAGIC_PLL | M64F_HW_TRIPLE | M64F_FIFO_32 | M64F_RESET_3D)\n#define ATI_CHIP_264LTPRO  (ATI_MODERN_SET | M64F_HW_TRIPLE | M64F_FIFO_32 | M64F_RESET_3D)\n\n#define ATI_CHIP_264XL     (ATI_MODERN_SET | M64F_HW_TRIPLE | M64F_FIFO_32 | M64F_RESET_3D | M64F_XL_DLL | M64F_MFB_FORCE_4 | M64F_XL_MEM)\n#define ATI_CHIP_MOBILITY  (ATI_MODERN_SET | M64F_HW_TRIPLE | M64F_FIFO_32 | M64F_RESET_3D | M64F_XL_DLL | M64F_MFB_FORCE_4 | M64F_XL_MEM | M64F_MOBIL_BUS)\n\nstatic struct {\n\tu16 pci_id;\n\tconst char *name;\n\tint pll, mclk, xclk, ecp_max;\n\tu32 features;\n} aty_chips[] = {\n#ifdef CONFIG_FB_ATY_GX\n\t \n\t{ PCI_CHIP_MACH64GX, \"ATI888GX00 (Mach64 GX)\", 135, 50, 50, 0, ATI_CHIP_88800GX },\n\t{ PCI_CHIP_MACH64CX, \"ATI888CX00 (Mach64 CX)\", 135, 50, 50, 0, ATI_CHIP_88800CX },\n#endif  \n\n#ifdef CONFIG_FB_ATY_CT\n\t{ PCI_CHIP_MACH64CT, \"ATI264CT (Mach64 CT)\", 135, 60, 60, 0, ATI_CHIP_264CT },\n\t{ PCI_CHIP_MACH64ET, \"ATI264ET (Mach64 ET)\", 135, 60, 60, 0, ATI_CHIP_264ET },\n\n\t \n\t{ PCI_CHIP_MACH64LT, \"ATI264LT (Mach64 LT)\", 135, 63, 63, 0, ATI_CHIP_264LT },\n\n\t{ PCI_CHIP_MACH64VT, \"ATI264VT (Mach64 VT)\", 170, 67, 67, 80, ATI_CHIP_264VT },\n\t{ PCI_CHIP_MACH64GT, \"3D RAGE (Mach64 GT)\", 135, 63, 63, 80, ATI_CHIP_264GT },\n\n\t{ PCI_CHIP_MACH64VU, \"ATI264VT3 (Mach64 VU)\", 200, 67, 67, 80, ATI_CHIP_264VT3 },\n\t{ PCI_CHIP_MACH64GU, \"3D RAGE II+ (Mach64 GU)\", 200, 67, 67, 100, ATI_CHIP_264GTB },\n\n\t{ PCI_CHIP_MACH64LG, \"3D RAGE LT (Mach64 LG)\", 230, 63, 63, 100, ATI_CHIP_264LTG | M64F_LT_LCD_REGS | M64F_G3_PB_1024x768 },\n\n\t{ PCI_CHIP_MACH64VV, \"ATI264VT4 (Mach64 VV)\", 230, 83, 83, 100, ATI_CHIP_264VT4 },\n\n\t{ PCI_CHIP_MACH64GV, \"3D RAGE IIC (Mach64 GV, PCI)\", 230, 83, 83, 100, ATI_CHIP_264GT2C },\n\t{ PCI_CHIP_MACH64GW, \"3D RAGE IIC (Mach64 GW, AGP)\", 230, 83, 83, 100, ATI_CHIP_264GT2C },\n\t{ PCI_CHIP_MACH64GY, \"3D RAGE IIC (Mach64 GY, PCI)\", 230, 83, 83, 100, ATI_CHIP_264GT2C },\n\t{ PCI_CHIP_MACH64GZ, \"3D RAGE IIC (Mach64 GZ, AGP)\", 230, 83, 83, 100, ATI_CHIP_264GT2C },\n\n\t{ PCI_CHIP_MACH64GB, \"3D RAGE PRO (Mach64 GB, BGA, AGP)\", 230, 100, 100, 125, ATI_CHIP_264GTPRO },\n\t{ PCI_CHIP_MACH64GD, \"3D RAGE PRO (Mach64 GD, BGA, AGP 1x)\", 230, 100, 100, 125, ATI_CHIP_264GTPRO },\n\t{ PCI_CHIP_MACH64GI, \"3D RAGE PRO (Mach64 GI, BGA, PCI)\", 230, 100, 100, 125, ATI_CHIP_264GTPRO | M64F_MAGIC_VRAM_SIZE },\n\t{ PCI_CHIP_MACH64GP, \"3D RAGE PRO (Mach64 GP, PQFP, PCI)\", 230, 100, 100, 125, ATI_CHIP_264GTPRO },\n\t{ PCI_CHIP_MACH64GQ, \"3D RAGE PRO (Mach64 GQ, PQFP, PCI, limited 3D)\", 230, 100, 100, 125, ATI_CHIP_264GTPRO },\n\n\t{ PCI_CHIP_MACH64LB, \"3D RAGE LT PRO (Mach64 LB, AGP)\", 236, 75, 100, 135, ATI_CHIP_264LTPRO },\n\t{ PCI_CHIP_MACH64LD, \"3D RAGE LT PRO (Mach64 LD, AGP)\", 230, 100, 100, 135, ATI_CHIP_264LTPRO },\n\t{ PCI_CHIP_MACH64LI, \"3D RAGE LT PRO (Mach64 LI, PCI)\", 230, 100, 100, 135, ATI_CHIP_264LTPRO | M64F_G3_PB_1_1 | M64F_G3_PB_1024x768 },\n\t{ PCI_CHIP_MACH64LP, \"3D RAGE LT PRO (Mach64 LP, PCI)\", 230, 100, 100, 135, ATI_CHIP_264LTPRO | M64F_G3_PB_1024x768 },\n\t{ PCI_CHIP_MACH64LQ, \"3D RAGE LT PRO (Mach64 LQ, PCI)\", 230, 100, 100, 135, ATI_CHIP_264LTPRO },\n\n\t{ PCI_CHIP_MACH64GM, \"3D RAGE XL (Mach64 GM, AGP 2x)\", 230, 83, 63, 135, ATI_CHIP_264XL },\n\t{ PCI_CHIP_MACH64GN, \"3D RAGE XC (Mach64 GN, AGP 2x)\", 230, 83, 63, 135, ATI_CHIP_264XL },\n\t{ PCI_CHIP_MACH64GO, \"3D RAGE XL (Mach64 GO, PCI-66)\", 230, 83, 63, 135, ATI_CHIP_264XL },\n\t{ PCI_CHIP_MACH64GL, \"3D RAGE XC (Mach64 GL, PCI-66)\", 230, 83, 63, 135, ATI_CHIP_264XL },\n\t{ PCI_CHIP_MACH64GR, \"3D RAGE XL (Mach64 GR, PCI-33)\", 230, 83, 63, 135, ATI_CHIP_264XL | M64F_SDRAM_MAGIC_PLL },\n\t{ PCI_CHIP_MACH64GS, \"3D RAGE XC (Mach64 GS, PCI-33)\", 230, 83, 63, 135, ATI_CHIP_264XL },\n\n\t{ PCI_CHIP_MACH64LM, \"3D RAGE Mobility P/M (Mach64 LM, AGP 2x)\", 230, 83, 125, 135, ATI_CHIP_MOBILITY },\n\t{ PCI_CHIP_MACH64LN, \"3D RAGE Mobility L (Mach64 LN, AGP 2x)\", 230, 83, 125, 135, ATI_CHIP_MOBILITY },\n\t{ PCI_CHIP_MACH64LR, \"3D RAGE Mobility P/M (Mach64 LR, PCI)\", 230, 83, 125, 135, ATI_CHIP_MOBILITY },\n\t{ PCI_CHIP_MACH64LS, \"3D RAGE Mobility L (Mach64 LS, PCI)\", 230, 83, 125, 135, ATI_CHIP_MOBILITY },\n#endif  \n};\n\n \nstatic void aty_fudge_framebuffer_len(struct fb_info *info)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\n\tif (!par->aux_start &&\n\t    (info->fix.smem_len == 0x800000 ||\n\t     (par->bus_type == ISA && info->fix.smem_len == 0x400000)))\n\t\tinfo->fix.smem_len -= GUI_RESERVE;\n}\n\nstatic int correct_chipset(struct atyfb_par *par)\n{\n\tu8 rev;\n\tu16 type;\n\tu32 chip_id;\n\tconst char *name;\n\tint i;\n\n\tfor (i = (int)ARRAY_SIZE(aty_chips) - 1; i >= 0; i--)\n\t\tif (par->pci_id == aty_chips[i].pci_id)\n\t\t\tbreak;\n\n\tif (i < 0)\n\t\treturn -ENODEV;\n\n\tname = aty_chips[i].name;\n\tpar->pll_limits.pll_max = aty_chips[i].pll;\n\tpar->pll_limits.mclk = aty_chips[i].mclk;\n\tpar->pll_limits.xclk = aty_chips[i].xclk;\n\tpar->pll_limits.ecp_max = aty_chips[i].ecp_max;\n\tpar->features = aty_chips[i].features;\n\n\tchip_id = aty_ld_le32(CNFG_CHIP_ID, par);\n\ttype = chip_id & CFG_CHIP_TYPE;\n\trev = (chip_id & CFG_CHIP_REV) >> 24;\n\n\tswitch (par->pci_id) {\n#ifdef CONFIG_FB_ATY_GX\n\tcase PCI_CHIP_MACH64GX:\n\t\tif (type != 0x00d7)\n\t\t\treturn -ENODEV;\n\t\tbreak;\n\tcase PCI_CHIP_MACH64CX:\n\t\tif (type != 0x0057)\n\t\t\treturn -ENODEV;\n\t\tbreak;\n#endif\n#ifdef CONFIG_FB_ATY_CT\n\tcase PCI_CHIP_MACH64VT:\n\t\tswitch (rev & 0x07) {\n\t\tcase 0x00:\n\t\t\tswitch (rev & 0xc0) {\n\t\t\tcase 0x00:\n\t\t\t\tname = \"ATI264VT (A3) (Mach64 VT)\";\n\t\t\t\tpar->pll_limits.pll_max = 170;\n\t\t\t\tpar->pll_limits.mclk = 67;\n\t\t\t\tpar->pll_limits.xclk = 67;\n\t\t\t\tpar->pll_limits.ecp_max = 80;\n\t\t\t\tpar->features = ATI_CHIP_264VT;\n\t\t\t\tbreak;\n\t\t\tcase 0x40:\n\t\t\t\tname = \"ATI264VT2 (A4) (Mach64 VT)\";\n\t\t\t\tpar->pll_limits.pll_max = 200;\n\t\t\t\tpar->pll_limits.mclk = 67;\n\t\t\t\tpar->pll_limits.xclk = 67;\n\t\t\t\tpar->pll_limits.ecp_max = 80;\n\t\t\t\tpar->features = ATI_CHIP_264VT | M64F_MAGIC_POSTDIV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tname = \"ATI264VT3 (B1) (Mach64 VT)\";\n\t\t\tpar->pll_limits.pll_max = 200;\n\t\t\tpar->pll_limits.mclk = 67;\n\t\t\tpar->pll_limits.xclk = 67;\n\t\t\tpar->pll_limits.ecp_max = 80;\n\t\t\tpar->features = ATI_CHIP_264VTB;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tname = \"ATI264VT3 (B2) (Mach64 VT)\";\n\t\t\tpar->pll_limits.pll_max = 200;\n\t\t\tpar->pll_limits.mclk = 67;\n\t\t\tpar->pll_limits.xclk = 67;\n\t\t\tpar->pll_limits.ecp_max = 80;\n\t\t\tpar->features = ATI_CHIP_264VT3;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PCI_CHIP_MACH64GT:\n\t\tswitch (rev & 0x07) {\n\t\tcase 0x01:\n\t\t\tname = \"3D RAGE II (Mach64 GT)\";\n\t\t\tpar->pll_limits.pll_max = 170;\n\t\t\tpar->pll_limits.mclk = 67;\n\t\t\tpar->pll_limits.xclk = 67;\n\t\t\tpar->pll_limits.ecp_max = 80;\n\t\t\tpar->features = ATI_CHIP_264GTB;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tname = \"3D RAGE II+ (Mach64 GT)\";\n\t\t\tpar->pll_limits.pll_max = 200;\n\t\t\tpar->pll_limits.mclk = 67;\n\t\t\tpar->pll_limits.xclk = 67;\n\t\t\tpar->pll_limits.ecp_max = 100;\n\t\t\tpar->features = ATI_CHIP_264GTB;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\tPRINTKI(\"%s [0x%04x rev 0x%02x]\\n\", name, type, rev);\n\treturn 0;\n}\n\nstatic char ram_dram[] __maybe_unused = \"DRAM\";\nstatic char ram_resv[] __maybe_unused = \"RESV\";\n#ifdef CONFIG_FB_ATY_GX\nstatic char ram_vram[] = \"VRAM\";\n#endif  \n#ifdef CONFIG_FB_ATY_CT\nstatic char ram_edo[] = \"EDO\";\nstatic char ram_sdram[] = \"SDRAM (1:1)\";\nstatic char ram_sgram[] = \"SGRAM (1:1)\";\nstatic char ram_sdram32[] = \"SDRAM (2:1) (32-bit)\";\nstatic char ram_wram[] = \"WRAM\";\nstatic char ram_off[] = \"OFF\";\n#endif  \n\n\n#ifdef CONFIG_FB_ATY_GX\nstatic char *aty_gx_ram[8] = {\n\tram_dram, ram_vram, ram_vram, ram_dram,\n\tram_dram, ram_vram, ram_vram, ram_resv\n};\n#endif  \n\n#ifdef CONFIG_FB_ATY_CT\nstatic char *aty_ct_ram[8] = {\n\tram_off, ram_dram, ram_edo, ram_edo,\n\tram_sdram, ram_sgram, ram_wram, ram_resv\n};\nstatic char *aty_xl_ram[8] = {\n\tram_off, ram_dram, ram_edo, ram_edo,\n\tram_sdram, ram_sgram, ram_sdram32, ram_resv\n};\n#endif  \n\nstatic u32 atyfb_get_pixclock(struct fb_var_screeninfo *var,\n\t\t\t      struct atyfb_par *par)\n{\n\tu32 pixclock = var->pixclock;\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tu32 lcd_on_off;\n\tpar->pll.ct.xres = 0;\n\tif (par->lcd_table != 0) {\n\t\tlcd_on_off = aty_ld_lcd(LCD_GEN_CNTL, par);\n\t\tif (lcd_on_off & LCD_ON) {\n\t\t\tpar->pll.ct.xres = var->xres;\n\t\t\tpixclock = par->lcd_pixclock;\n\t\t}\n\t}\n#endif\n\treturn pixclock;\n}\n\n#if defined(CONFIG_PPC)\n\n \n\nstatic int read_aty_sense(const struct atyfb_par *par)\n{\n\tint sense, i;\n\n\taty_st_le32(GP_IO, 0x31003100, par);  \n\t__delay(200);\n\taty_st_le32(GP_IO, 0, par);  \n\t__delay(2000);\n\ti = aty_ld_le32(GP_IO, par);  \n\tsense = ((i & 0x3000) >> 3) | (i & 0x100);\n\n\t \n\taty_st_le32(GP_IO, 0x20000000, par);  \n\t__delay(2000);\n\ti = aty_ld_le32(GP_IO, par);\n\tsense |= ((i & 0x1000) >> 7) | ((i & 0x100) >> 4);\n\taty_st_le32(GP_IO, 0x20002000, par);  \n\t__delay(200);\n\n\taty_st_le32(GP_IO, 0x10000000, par);  \n\t__delay(2000);\n\ti = aty_ld_le32(GP_IO, par);\n\tsense |= ((i & 0x2000) >> 10) | ((i & 0x100) >> 6);\n\taty_st_le32(GP_IO, 0x10001000, par);  \n\t__delay(200);\n\n\taty_st_le32(GP_IO, 0x01000000, par);  \n\t__delay(2000);\n\tsense |= (aty_ld_le32(GP_IO, par) & 0x3000) >> 12;\n\taty_st_le32(GP_IO, 0, par);  \n\treturn sense;\n}\n\n#endif  \n\n \n\n \n\nstatic void aty_get_crtc(const struct atyfb_par *par, struct crtc *crtc)\n{\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tif (par->lcd_table != 0) {\n\t\tif (!M64_HAS(LT_LCD_REGS)) {\n\t\t\tcrtc->lcd_index = aty_ld_le32(LCD_INDEX, par);\n\t\t\taty_st_le32(LCD_INDEX, crtc->lcd_index, par);\n\t\t}\n\t\tcrtc->lcd_config_panel = aty_ld_lcd(CNFG_PANEL, par);\n\t\tcrtc->lcd_gen_cntl = aty_ld_lcd(LCD_GEN_CNTL, par);\n\n\n\t\t \n\t\taty_st_lcd(LCD_GEN_CNTL, crtc->lcd_gen_cntl &\n\t\t\t   ~(CRTC_RW_SELECT | SHADOW_EN | SHADOW_RW_EN), par);\n\n\t\t \n\t\tcrtc->horz_stretching = aty_ld_lcd(HORZ_STRETCHING, par);\n\t\tcrtc->vert_stretching = aty_ld_lcd(VERT_STRETCHING, par);\n\t\tif (!M64_HAS(LT_LCD_REGS))\n\t\t\tcrtc->ext_vert_stretch = aty_ld_lcd(EXT_VERT_STRETCH, par);\n\t}\n#endif\n\tcrtc->h_tot_disp = aty_ld_le32(CRTC_H_TOTAL_DISP, par);\n\tcrtc->h_sync_strt_wid = aty_ld_le32(CRTC_H_SYNC_STRT_WID, par);\n\tcrtc->v_tot_disp = aty_ld_le32(CRTC_V_TOTAL_DISP, par);\n\tcrtc->v_sync_strt_wid = aty_ld_le32(CRTC_V_SYNC_STRT_WID, par);\n\tcrtc->vline_crnt_vline = aty_ld_le32(CRTC_VLINE_CRNT_VLINE, par);\n\tcrtc->off_pitch = aty_ld_le32(CRTC_OFF_PITCH, par);\n\tcrtc->gen_cntl = aty_ld_le32(CRTC_GEN_CNTL, par);\n\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tif (par->lcd_table != 0) {\n\t\t \n\t\taty_st_lcd(LCD_GEN_CNTL, (crtc->lcd_gen_cntl & ~CRTC_RW_SELECT) |\n\t\t\t   SHADOW_EN | SHADOW_RW_EN, par);\n\n\t\tcrtc->shadow_h_tot_disp = aty_ld_le32(CRTC_H_TOTAL_DISP, par);\n\t\tcrtc->shadow_h_sync_strt_wid = aty_ld_le32(CRTC_H_SYNC_STRT_WID, par);\n\t\tcrtc->shadow_v_tot_disp = aty_ld_le32(CRTC_V_TOTAL_DISP, par);\n\t\tcrtc->shadow_v_sync_strt_wid = aty_ld_le32(CRTC_V_SYNC_STRT_WID, par);\n\n\t\taty_st_le32(LCD_GEN_CNTL, crtc->lcd_gen_cntl, par);\n\t}\n#endif  \n}\n\nstatic void aty_set_crtc(const struct atyfb_par *par, const struct crtc *crtc)\n{\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tif (par->lcd_table != 0) {\n\t\t \n\t\taty_st_le32(CRTC_GEN_CNTL, crtc->gen_cntl &\n\t\t\t    ~(CRTC_EXT_DISP_EN | CRTC_EN), par);\n\n\t\t \n\t\taty_st_lcd(CNFG_PANEL, crtc->lcd_config_panel, par);\n\t\taty_st_lcd(LCD_GEN_CNTL, crtc->lcd_gen_cntl &\n\t\t\t   ~(CRTC_RW_SELECT | SHADOW_EN | SHADOW_RW_EN), par);\n\n\t\t \n\t\taty_st_lcd(HORZ_STRETCHING, crtc->horz_stretching &\n\t\t\t   ~(HORZ_STRETCH_MODE | HORZ_STRETCH_EN), par);\n\t\taty_st_lcd(VERT_STRETCHING, crtc->vert_stretching &\n\t\t\t   ~(VERT_STRETCH_RATIO1 | VERT_STRETCH_RATIO2 |\n\t\t\t     VERT_STRETCH_USE0 | VERT_STRETCH_EN), par);\n\t}\n#endif\n\t \n\taty_st_le32(CRTC_GEN_CNTL, crtc->gen_cntl & ~CRTC_EN, par);\n\n\tDPRINTK(\"setting up CRTC\\n\");\n\tDPRINTK(\"set primary CRT to %ix%i %c%c composite %c\\n\",\n\t\t((((crtc->h_tot_disp >> 16) & 0xff) + 1) << 3),\n\t\t(((crtc->v_tot_disp >> 16) & 0x7ff) + 1),\n\t\t(crtc->h_sync_strt_wid & 0x200000) ? 'N' : 'P',\n\t\t(crtc->v_sync_strt_wid & 0x200000) ? 'N' : 'P',\n\t\t(crtc->gen_cntl & CRTC_CSYNC_EN) ? 'P' : 'N');\n\n\tDPRINTK(\"CRTC_H_TOTAL_DISP: %x\\n\", crtc->h_tot_disp);\n\tDPRINTK(\"CRTC_H_SYNC_STRT_WID: %x\\n\", crtc->h_sync_strt_wid);\n\tDPRINTK(\"CRTC_V_TOTAL_DISP: %x\\n\", crtc->v_tot_disp);\n\tDPRINTK(\"CRTC_V_SYNC_STRT_WID: %x\\n\", crtc->v_sync_strt_wid);\n\tDPRINTK(\"CRTC_OFF_PITCH: %x\\n\", crtc->off_pitch);\n\tDPRINTK(\"CRTC_VLINE_CRNT_VLINE: %x\\n\", crtc->vline_crnt_vline);\n\tDPRINTK(\"CRTC_GEN_CNTL: %x\\n\", crtc->gen_cntl);\n\n\taty_st_le32(CRTC_H_TOTAL_DISP, crtc->h_tot_disp, par);\n\taty_st_le32(CRTC_H_SYNC_STRT_WID, crtc->h_sync_strt_wid, par);\n\taty_st_le32(CRTC_V_TOTAL_DISP, crtc->v_tot_disp, par);\n\taty_st_le32(CRTC_V_SYNC_STRT_WID, crtc->v_sync_strt_wid, par);\n\taty_st_le32(CRTC_OFF_PITCH, crtc->off_pitch, par);\n\taty_st_le32(CRTC_VLINE_CRNT_VLINE, crtc->vline_crnt_vline, par);\n\n\taty_st_le32(CRTC_GEN_CNTL, crtc->gen_cntl, par);\n#if 0\n\tFIXME\n\tif (par->accel_flags & FB_ACCELF_TEXT)\n\t\taty_init_engine(par, info);\n#endif\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\t \n\tif (par->lcd_table != 0) {\n\t\t \n\t\taty_st_lcd(LCD_GEN_CNTL, (crtc->lcd_gen_cntl & ~CRTC_RW_SELECT) |\n\t\t\t   SHADOW_EN | SHADOW_RW_EN, par);\n\n\t\tDPRINTK(\"set shadow CRT to %ix%i %c%c\\n\",\n\t\t\t((((crtc->shadow_h_tot_disp >> 16) & 0xff) + 1) << 3),\n\t\t\t(((crtc->shadow_v_tot_disp >> 16) & 0x7ff) + 1),\n\t\t\t(crtc->shadow_h_sync_strt_wid & 0x200000) ? 'N' : 'P',\n\t\t\t(crtc->shadow_v_sync_strt_wid & 0x200000) ? 'N' : 'P');\n\n\t\tDPRINTK(\"SHADOW CRTC_H_TOTAL_DISP: %x\\n\",\n\t\t\tcrtc->shadow_h_tot_disp);\n\t\tDPRINTK(\"SHADOW CRTC_H_SYNC_STRT_WID: %x\\n\",\n\t\t\tcrtc->shadow_h_sync_strt_wid);\n\t\tDPRINTK(\"SHADOW CRTC_V_TOTAL_DISP: %x\\n\",\n\t\t\tcrtc->shadow_v_tot_disp);\n\t\tDPRINTK(\"SHADOW CRTC_V_SYNC_STRT_WID: %x\\n\",\n\t\t\tcrtc->shadow_v_sync_strt_wid);\n\n\t\taty_st_le32(CRTC_H_TOTAL_DISP, crtc->shadow_h_tot_disp, par);\n\t\taty_st_le32(CRTC_H_SYNC_STRT_WID, crtc->shadow_h_sync_strt_wid, par);\n\t\taty_st_le32(CRTC_V_TOTAL_DISP, crtc->shadow_v_tot_disp, par);\n\t\taty_st_le32(CRTC_V_SYNC_STRT_WID, crtc->shadow_v_sync_strt_wid, par);\n\n\t\t \n\t\tDPRINTK(\"LCD_GEN_CNTL: %x\\n\", crtc->lcd_gen_cntl);\n\t\tDPRINTK(\"HORZ_STRETCHING: %x\\n\", crtc->horz_stretching);\n\t\tDPRINTK(\"VERT_STRETCHING: %x\\n\", crtc->vert_stretching);\n\t\tif (!M64_HAS(LT_LCD_REGS))\n\t\t\tDPRINTK(\"EXT_VERT_STRETCH: %x\\n\", crtc->ext_vert_stretch);\n\n\t\taty_st_lcd(LCD_GEN_CNTL, crtc->lcd_gen_cntl, par);\n\t\taty_st_lcd(HORZ_STRETCHING, crtc->horz_stretching, par);\n\t\taty_st_lcd(VERT_STRETCHING, crtc->vert_stretching, par);\n\t\tif (!M64_HAS(LT_LCD_REGS)) {\n\t\t\taty_st_lcd(EXT_VERT_STRETCH, crtc->ext_vert_stretch, par);\n\t\t\taty_ld_le32(LCD_INDEX, par);\n\t\t\taty_st_le32(LCD_INDEX, crtc->lcd_index, par);\n\t\t}\n\t}\n#endif  \n}\n\nstatic u32 calc_line_length(struct atyfb_par *par, u32 vxres, u32 bpp)\n{\n\tu32 line_length = vxres * bpp / 8;\n\n\tif (par->ram_type == SGRAM ||\n\t    (!M64_HAS(XL_MEM) && par->ram_type == WRAM))\n\t\tline_length = (line_length + 63) & ~63;\n\n\treturn line_length;\n}\n\nstatic int aty_var_to_crtc(const struct fb_info *info,\n\t\t\t   const struct fb_var_screeninfo *var,\n\t\t\t   struct crtc *crtc)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 xres, yres, vxres, vyres, xoffset, yoffset, bpp;\n\tu32 sync, vmode;\n\tu32 h_total, h_disp, h_sync_strt, h_sync_end, h_sync_dly, h_sync_wid, h_sync_pol;\n\tu32 v_total, v_disp, v_sync_strt, v_sync_end, v_sync_wid, v_sync_pol, c_sync;\n\tu32 pix_width, dp_pix_width, dp_chain_mask;\n\tu32 line_length;\n\n\t \n\txres = (var->xres + 7) & ~7;\n\tyres = var->yres;\n\tvxres = (var->xres_virtual + 7) & ~7;\n\tvyres = var->yres_virtual;\n\txoffset = (var->xoffset + 7) & ~7;\n\tyoffset = var->yoffset;\n\tbpp = var->bits_per_pixel;\n\tif (bpp == 16)\n\t\tbpp = (var->green.length == 5) ? 15 : 16;\n\tsync = var->sync;\n\tvmode = var->vmode;\n\n\t \n\tif (vxres < xres + xoffset)\n\t\tvxres = xres + xoffset;\n\th_disp = xres;\n\n\tif (vyres < yres + yoffset)\n\t\tvyres = yres + yoffset;\n\tv_disp = yres;\n\n\tif (bpp <= 8) {\n\t\tbpp = 8;\n\t\tpix_width = CRTC_PIX_WIDTH_8BPP;\n\t\tdp_pix_width = HOST_8BPP | SRC_8BPP | DST_8BPP |\n\t\t\tBYTE_ORDER_LSB_TO_MSB;\n\t\tdp_chain_mask = DP_CHAIN_8BPP;\n\t} else if (bpp <= 15) {\n\t\tbpp = 16;\n\t\tpix_width = CRTC_PIX_WIDTH_15BPP;\n\t\tdp_pix_width = HOST_15BPP | SRC_15BPP | DST_15BPP |\n\t\t\tBYTE_ORDER_LSB_TO_MSB;\n\t\tdp_chain_mask = DP_CHAIN_15BPP;\n\t} else if (bpp <= 16) {\n\t\tbpp = 16;\n\t\tpix_width = CRTC_PIX_WIDTH_16BPP;\n\t\tdp_pix_width = HOST_16BPP | SRC_16BPP | DST_16BPP |\n\t\t\tBYTE_ORDER_LSB_TO_MSB;\n\t\tdp_chain_mask = DP_CHAIN_16BPP;\n\t} else if (bpp <= 24 && M64_HAS(INTEGRATED)) {\n\t\tbpp = 24;\n\t\tpix_width = CRTC_PIX_WIDTH_24BPP;\n\t\tdp_pix_width = HOST_8BPP | SRC_8BPP | DST_8BPP |\n\t\t\tBYTE_ORDER_LSB_TO_MSB;\n\t\tdp_chain_mask = DP_CHAIN_24BPP;\n\t} else if (bpp <= 32) {\n\t\tbpp = 32;\n\t\tpix_width = CRTC_PIX_WIDTH_32BPP;\n\t\tdp_pix_width = HOST_32BPP | SRC_32BPP | DST_32BPP |\n\t\t\tBYTE_ORDER_LSB_TO_MSB;\n\t\tdp_chain_mask = DP_CHAIN_32BPP;\n\t} else\n\t\tFAIL(\"invalid bpp\");\n\n\tline_length = calc_line_length(par, vxres, bpp);\n\n\tif (vyres * line_length > info->fix.smem_len)\n\t\tFAIL(\"not enough video RAM\");\n\n\th_sync_pol = sync & FB_SYNC_HOR_HIGH_ACT ? 0 : 1;\n\tv_sync_pol = sync & FB_SYNC_VERT_HIGH_ACT ? 0 : 1;\n\n\tif ((xres > 1920) || (yres > 1200)) {\n\t\tFAIL(\"MACH64 chips are designed for max 1920x1200\\n\"\n\t\t     \"select another resolution.\");\n\t}\n\th_sync_strt = h_disp + var->right_margin;\n\th_sync_end = h_sync_strt + var->hsync_len;\n\th_sync_dly  = var->right_margin & 7;\n\th_total = h_sync_end + h_sync_dly + var->left_margin;\n\n\tv_sync_strt = v_disp + var->lower_margin;\n\tv_sync_end = v_sync_strt + var->vsync_len;\n\tv_total = v_sync_end + var->upper_margin;\n\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tif (par->lcd_table != 0) {\n\t\tif (!M64_HAS(LT_LCD_REGS)) {\n\t\t\tu32 lcd_index = aty_ld_le32(LCD_INDEX, par);\n\t\t\tcrtc->lcd_index = lcd_index &\n\t\t\t\t~(LCD_INDEX_MASK | LCD_DISPLAY_DIS |\n\t\t\t\t  LCD_SRC_SEL | CRTC2_DISPLAY_DIS);\n\t\t\taty_st_le32(LCD_INDEX, lcd_index, par);\n\t\t}\n\n\t\tif (!M64_HAS(MOBIL_BUS))\n\t\t\tcrtc->lcd_index |= CRTC2_DISPLAY_DIS;\n\n\t\tcrtc->lcd_config_panel = aty_ld_lcd(CNFG_PANEL, par) | 0x4000;\n\t\tcrtc->lcd_gen_cntl = aty_ld_lcd(LCD_GEN_CNTL, par) & ~CRTC_RW_SELECT;\n\n\t\tcrtc->lcd_gen_cntl &=\n\t\t\t~(HORZ_DIVBY2_EN | DIS_HOR_CRT_DIVBY2 | TVCLK_PM_EN |\n\t\t\t \n\t\t\tUSE_SHADOWED_ROWCUR | SHADOW_EN | SHADOW_RW_EN);\n\t\tcrtc->lcd_gen_cntl |= DONT_SHADOW_VPAR | LOCK_8DOT;\n\n\t\tif ((crtc->lcd_gen_cntl & LCD_ON) &&\n\t\t    ((xres > par->lcd_width) || (yres > par->lcd_height))) {\n\t\t\t \n\t\t\tif (crtc->lcd_gen_cntl & CRT_ON) {\n\t\t\t\tif (!(var->activate & FB_ACTIVATE_TEST))\n\t\t\t\t\tPRINTKI(\"Disable LCD panel, because video mode does not fit.\\n\");\n\t\t\t\tcrtc->lcd_gen_cntl &= ~LCD_ON;\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\tif (!(var->activate & FB_ACTIVATE_TEST))\n\t\t\t\t\tPRINTKE(\"Video mode exceeds size of LCD panel.\\nConnect this computer to a conventional monitor if you really need this mode.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((par->lcd_table != 0) && (crtc->lcd_gen_cntl & LCD_ON)) {\n\t\tint VScan = 1;\n\t\t \n\n\t\tvmode &= ~(FB_VMODE_DOUBLE | FB_VMODE_INTERLACED);\n\n\t\t \n\t\tif (yres < par->lcd_height) {\n\t\t\tVScan = par->lcd_height / yres;\n\t\t\tif (VScan > 1) {\n\t\t\t\tVScan = 2;\n\t\t\t\tvmode |= FB_VMODE_DOUBLE;\n\t\t\t}\n\t\t}\n\n\t\th_sync_strt = h_disp + par->lcd_right_margin;\n\t\th_sync_end = h_sync_strt + par->lcd_hsync_len;\n\t\th_sync_dly =  par->lcd_hsync_dly;\n\t\th_total = h_disp + par->lcd_hblank_len;\n\n\t\tv_sync_strt = v_disp + par->lcd_lower_margin / VScan;\n\t\tv_sync_end = v_sync_strt + par->lcd_vsync_len / VScan;\n\t\tv_total = v_disp + par->lcd_vblank_len / VScan;\n\t}\n#endif  \n\n\th_disp = (h_disp >> 3) - 1;\n\th_sync_strt = (h_sync_strt >> 3) - 1;\n\th_sync_end = (h_sync_end >> 3) - 1;\n\th_total = (h_total >> 3) - 1;\n\th_sync_wid = h_sync_end - h_sync_strt;\n\n\tFAIL_MAX(\"h_disp too large\", h_disp, 0xff);\n\tFAIL_MAX(\"h_sync_strt too large\", h_sync_strt, 0x1ff);\n\t \n\tif (h_sync_wid > 0x1f)\n\t\th_sync_wid = 0x1f;\n\tFAIL_MAX(\"h_total too large\", h_total, 0x1ff);\n\n\tif (vmode & FB_VMODE_DOUBLE) {\n\t\tv_disp <<= 1;\n\t\tv_sync_strt <<= 1;\n\t\tv_sync_end <<= 1;\n\t\tv_total <<= 1;\n\t}\n\n\tv_disp--;\n\tv_sync_strt--;\n\tv_sync_end--;\n\tv_total--;\n\tv_sync_wid = v_sync_end - v_sync_strt;\n\n\tFAIL_MAX(\"v_disp too large\", v_disp, 0x7ff);\n\tFAIL_MAX(\"v_sync_stsrt too large\", v_sync_strt, 0x7ff);\n\t \n\tif (v_sync_wid > 0x1f)\n\t\tv_sync_wid = 0x1f;\n\tFAIL_MAX(\"v_total too large\", v_total, 0x7ff);\n\n\tc_sync = sync & FB_SYNC_COMP_HIGH_ACT ? CRTC_CSYNC_EN : 0;\n\n\t \n\tcrtc->vxres = vxres;\n\tcrtc->vyres = vyres;\n\tcrtc->xoffset = xoffset;\n\tcrtc->yoffset = yoffset;\n\tcrtc->bpp = bpp;\n\tcrtc->off_pitch =\n\t\t((yoffset * line_length + xoffset * bpp / 8) / 8) |\n\t\t((line_length / bpp) << 22);\n\tcrtc->vline_crnt_vline = 0;\n\n\tcrtc->h_tot_disp = h_total | (h_disp << 16);\n\tcrtc->h_sync_strt_wid = (h_sync_strt & 0xff) | (h_sync_dly << 8) |\n\t\t((h_sync_strt & 0x100) << 4) | (h_sync_wid << 16) |\n\t\t(h_sync_pol << 21);\n\tcrtc->v_tot_disp = v_total | (v_disp << 16);\n\tcrtc->v_sync_strt_wid = v_sync_strt | (v_sync_wid << 16) |\n\t\t(v_sync_pol << 21);\n\n\t \n\tcrtc->gen_cntl = CRTC_EXT_DISP_EN | CRTC_EN | pix_width | c_sync;\n\tcrtc->gen_cntl |= CRTC_VGA_LINEAR;\n\n\t \n\tif (vmode & FB_VMODE_DOUBLE)\n\t\tcrtc->gen_cntl |= CRTC_DBL_SCAN_EN;\n\t \n\tif (vmode & FB_VMODE_INTERLACED)\n\t\tcrtc->gen_cntl |= CRTC_INTERLACE_EN;\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tif (par->lcd_table != 0) {\n\t\tu32 vdisplay = yres;\n\t\tif (vmode & FB_VMODE_DOUBLE)\n\t\t\tvdisplay <<= 1;\n\t\tcrtc->gen_cntl &= ~(CRTC2_EN | CRTC2_PIX_WIDTH);\n\t\tcrtc->lcd_gen_cntl &= ~(HORZ_DIVBY2_EN | DIS_HOR_CRT_DIVBY2 |\n\t\t\t\t\t \n\t\t\t\t\tUSE_SHADOWED_VEND |\n\t\t\t\t\tUSE_SHADOWED_ROWCUR |\n\t\t\t\t\tSHADOW_EN | SHADOW_RW_EN);\n\t\tcrtc->lcd_gen_cntl |= DONT_SHADOW_VPAR ;\n\n\t\t \n\t\tcrtc->horz_stretching = aty_ld_lcd(HORZ_STRETCHING, par);\n\t\tif (!M64_HAS(LT_LCD_REGS))\n\t\t\tcrtc->ext_vert_stretch = aty_ld_lcd(EXT_VERT_STRETCH, par) &\n\t\t\t\t~(AUTO_VERT_RATIO | VERT_STRETCH_MODE | VERT_STRETCH_RATIO3);\n\n\t\tcrtc->horz_stretching &= ~(HORZ_STRETCH_RATIO |\n\t\t\t\t\t   HORZ_STRETCH_LOOP | AUTO_HORZ_RATIO |\n\t\t\t\t\t   HORZ_STRETCH_MODE | HORZ_STRETCH_EN);\n\t\tif (xres < par->lcd_width && crtc->lcd_gen_cntl & LCD_ON) {\n\t\t\tdo {\n\t\t\t\t \n\t\t\t\tint HDisplay  = xres & ~7;\n\t\t\t\tint nStretch  = par->lcd_width / HDisplay;\n\t\t\t\tint Remainder = par->lcd_width % HDisplay;\n\n\t\t\t\tif ((!Remainder && ((nStretch > 2))) ||\n\t\t\t\t    (((HDisplay * 16) / par->lcd_width) < 7)) {\n\t\t\t\t\tstatic const char StretchLoops[] = { 10, 12, 13, 15, 16 };\n\t\t\t\t\tint horz_stretch_loop = -1, BestRemainder;\n\t\t\t\t\tint Numerator = HDisplay, Denominator = par->lcd_width;\n\t\t\t\t\tint Index = 5;\n\t\t\t\t\tATIReduceRatio(&Numerator, &Denominator);\n\n\t\t\t\t\tBestRemainder = (Numerator * 16) / Denominator;\n\t\t\t\t\twhile (--Index >= 0) {\n\t\t\t\t\t\tRemainder = ((Denominator - Numerator) * StretchLoops[Index]) %\n\t\t\t\t\t\t\tDenominator;\n\t\t\t\t\t\tif (Remainder < BestRemainder) {\n\t\t\t\t\t\t\thorz_stretch_loop = Index;\n\t\t\t\t\t\t\tif (!(BestRemainder = Remainder))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((horz_stretch_loop >= 0) && !BestRemainder) {\n\t\t\t\t\t\tint horz_stretch_ratio = 0, Accumulator = 0;\n\t\t\t\t\t\tint reuse_previous = 1;\n\n\t\t\t\t\t\tIndex = StretchLoops[horz_stretch_loop];\n\n\t\t\t\t\t\twhile (--Index >= 0) {\n\t\t\t\t\t\t\tif (Accumulator > 0)\n\t\t\t\t\t\t\t\thorz_stretch_ratio |= reuse_previous;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tAccumulator += Denominator;\n\t\t\t\t\t\t\tAccumulator -= Numerator;\n\t\t\t\t\t\t\treuse_previous <<= 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcrtc->horz_stretching |= (HORZ_STRETCH_EN |\n\t\t\t\t\t\t\t((horz_stretch_loop & HORZ_STRETCH_LOOP) << 16) |\n\t\t\t\t\t\t\t(horz_stretch_ratio & HORZ_STRETCH_RATIO));\n\t\t\t\t\t\tbreak;       \n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcrtc->horz_stretching |= (HORZ_STRETCH_MODE | HORZ_STRETCH_EN |\n\t\t\t\t\t(((HDisplay * (HORZ_STRETCH_BLEND + 1)) / par->lcd_width) & HORZ_STRETCH_BLEND));\n\t\t\t} while (0);\n\t\t}\n\n\t\tif (vdisplay < par->lcd_height && crtc->lcd_gen_cntl & LCD_ON) {\n\t\t\tcrtc->vert_stretching = (VERT_STRETCH_USE0 | VERT_STRETCH_EN |\n\t\t\t\t(((vdisplay * (VERT_STRETCH_RATIO0 + 1)) / par->lcd_height) & VERT_STRETCH_RATIO0));\n\n\t\t\tif (!M64_HAS(LT_LCD_REGS) &&\n\t\t\t    xres <= (M64_HAS(MOBIL_BUS) ? 1024 : 800))\n\t\t\t\tcrtc->ext_vert_stretch |= VERT_STRETCH_MODE;\n\t\t} else {\n\t\t\t \n\t\t\tcrtc->vert_stretching = 0;\n\t\t}\n\t\t \n\t\tcrtc->shadow_h_tot_disp = crtc->h_tot_disp;\n\t\tcrtc->shadow_h_sync_strt_wid = crtc->h_sync_strt_wid;\n\t\tcrtc->shadow_v_tot_disp = crtc->v_tot_disp;\n\t\tcrtc->shadow_v_sync_strt_wid = crtc->v_sync_strt_wid;\n\t}\n#endif  \n\n\tif (M64_HAS(MAGIC_FIFO)) {\n\t\t \n\t\tcrtc->gen_cntl |= (aty_ld_le32(CRTC_GEN_CNTL, par) & CRTC_FIFO_LWM);\n\t}\n\tcrtc->dp_pix_width = dp_pix_width;\n\tcrtc->dp_chain_mask = dp_chain_mask;\n\n\treturn 0;\n}\n\nstatic int aty_crtc_to_var(const struct crtc *crtc,\n\t\t\t   struct fb_var_screeninfo *var)\n{\n\tu32 xres, yres, bpp, left, right, upper, lower, hslen, vslen, sync;\n\tu32 h_total, h_disp, h_sync_strt, h_sync_dly, h_sync_wid, h_sync_pol;\n\tu32 v_total, v_disp, v_sync_strt, v_sync_wid, v_sync_pol, c_sync;\n\tu32 pix_width;\n\tu32 double_scan, interlace;\n\n\t \n\th_total = crtc->h_tot_disp & 0x1ff;\n\th_disp = (crtc->h_tot_disp >> 16) & 0xff;\n\th_sync_strt = (crtc->h_sync_strt_wid & 0xff) | ((crtc->h_sync_strt_wid >> 4) & 0x100);\n\th_sync_dly = (crtc->h_sync_strt_wid >> 8) & 0x7;\n\th_sync_wid = (crtc->h_sync_strt_wid >> 16) & 0x1f;\n\th_sync_pol = (crtc->h_sync_strt_wid >> 21) & 0x1;\n\tv_total = crtc->v_tot_disp & 0x7ff;\n\tv_disp = (crtc->v_tot_disp >> 16) & 0x7ff;\n\tv_sync_strt = crtc->v_sync_strt_wid & 0x7ff;\n\tv_sync_wid = (crtc->v_sync_strt_wid >> 16) & 0x1f;\n\tv_sync_pol = (crtc->v_sync_strt_wid >> 21) & 0x1;\n\tc_sync = crtc->gen_cntl & CRTC_CSYNC_EN ? 1 : 0;\n\tpix_width = crtc->gen_cntl & CRTC_PIX_WIDTH_MASK;\n\tdouble_scan = crtc->gen_cntl & CRTC_DBL_SCAN_EN;\n\tinterlace = crtc->gen_cntl & CRTC_INTERLACE_EN;\n\n\t \n\txres = (h_disp + 1) * 8;\n\tyres = v_disp + 1;\n\tleft = (h_total - h_sync_strt - h_sync_wid) * 8 - h_sync_dly;\n\tright = (h_sync_strt - h_disp) * 8 + h_sync_dly;\n\thslen = h_sync_wid * 8;\n\tupper = v_total - v_sync_strt - v_sync_wid;\n\tlower = v_sync_strt - v_disp;\n\tvslen = v_sync_wid;\n\tsync = (h_sync_pol ? 0 : FB_SYNC_HOR_HIGH_ACT) |\n\t\t(v_sync_pol ? 0 : FB_SYNC_VERT_HIGH_ACT) |\n\t\t(c_sync ? FB_SYNC_COMP_HIGH_ACT : 0);\n\n\tswitch (pix_width) {\n\tcase CRTC_PIX_WIDTH_8BPP:\n\t\tbpp = 8;\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase CRTC_PIX_WIDTH_15BPP:\t \n\t\tbpp = 16;\n\t\tvar->red.offset = 10;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 5;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase CRTC_PIX_WIDTH_16BPP:\t \n\t\tbpp = 16;\n\t\tvar->red.offset = 11;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase CRTC_PIX_WIDTH_24BPP:\t \n\t\tbpp = 24;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase CRTC_PIX_WIDTH_32BPP:\t \n\t\tbpp = 32;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tbreak;\n\tdefault:\n\t\tPRINTKE(\"Invalid pixel width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvar->xres = xres;\n\tvar->yres = yres;\n\tvar->xres_virtual = crtc->vxres;\n\tvar->yres_virtual = crtc->vyres;\n\tvar->bits_per_pixel = bpp;\n\tvar->left_margin = left;\n\tvar->right_margin = right;\n\tvar->upper_margin = upper;\n\tvar->lower_margin = lower;\n\tvar->hsync_len = hslen;\n\tvar->vsync_len = vslen;\n\tvar->sync = sync;\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\t \n\tif (interlace)\n\t\tvar->vmode = FB_VMODE_INTERLACED;\n\n\tif (double_scan) {\n\t\tvar->vmode = FB_VMODE_DOUBLE;\n\t\tvar->yres >>= 1;\n\t\tvar->upper_margin >>= 1;\n\t\tvar->lower_margin >>= 1;\n\t\tvar->vsync_len >>= 1;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int atyfb_set_par(struct fb_info *info)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tu32 tmp, pixclock;\n\tint err;\n#ifdef DEBUG\n\tstruct fb_var_screeninfo debug;\n\tu32 pixclock_in_ps;\n#endif\n\tif (par->asleep)\n\t\treturn 0;\n\n\terr = aty_var_to_crtc(info, var, &par->crtc);\n\tif (err)\n\t\treturn err;\n\n\tpixclock = atyfb_get_pixclock(var, par);\n\n\tif (pixclock == 0) {\n\t\tPRINTKE(\"Invalid pixclock\\n\");\n\t\treturn -EINVAL;\n\t} else {\n\t\terr = par->pll_ops->var_to_pll(info, pixclock,\n\t\t\t\t\t       var->bits_per_pixel, &par->pll);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tpar->accel_flags = var->accel_flags;  \n\n\tif (var->accel_flags) {\n\t\tatyfb_ops.fb_sync = atyfb_sync;\n\t\tinfo->flags &= ~FBINFO_HWACCEL_DISABLED;\n\t} else {\n\t\tatyfb_ops.fb_sync = NULL;\n\t\tinfo->flags |= FBINFO_HWACCEL_DISABLED;\n\t}\n\n\tif (par->blitter_may_be_busy)\n\t\twait_for_idle(par);\n\n\taty_set_crtc(par, &par->crtc);\n\tpar->dac_ops->set_dac(info, &par->pll,\n\t\t\t      var->bits_per_pixel, par->accel_flags);\n\tpar->pll_ops->set_pll(info, &par->pll);\n\n#ifdef DEBUG\n\tif (par->pll_ops && par->pll_ops->pll_to_var)\n\t\tpixclock_in_ps = par->pll_ops->pll_to_var(info, &par->pll);\n\telse\n\t\tpixclock_in_ps = 0;\n\n\tif (0 == pixclock_in_ps) {\n\t\tPRINTKE(\"ALERT ops->pll_to_var get 0\\n\");\n\t\tpixclock_in_ps = pixclock;\n\t}\n\n\tmemset(&debug, 0, sizeof(debug));\n\tif (!aty_crtc_to_var(&par->crtc, &debug)) {\n\t\tu32 hSync, vRefresh;\n\t\tu32 h_disp, h_sync_strt, h_sync_end, h_total;\n\t\tu32 v_disp, v_sync_strt, v_sync_end, v_total;\n\n\t\th_disp = debug.xres;\n\t\th_sync_strt = h_disp + debug.right_margin;\n\t\th_sync_end = h_sync_strt + debug.hsync_len;\n\t\th_total = h_sync_end + debug.left_margin;\n\t\tv_disp = debug.yres;\n\t\tv_sync_strt = v_disp + debug.lower_margin;\n\t\tv_sync_end = v_sync_strt + debug.vsync_len;\n\t\tv_total = v_sync_end + debug.upper_margin;\n\n\t\thSync = 1000000000 / (pixclock_in_ps * h_total);\n\t\tvRefresh = (hSync * 1000) / v_total;\n\t\tif (par->crtc.gen_cntl & CRTC_INTERLACE_EN)\n\t\t\tvRefresh *= 2;\n\t\tif (par->crtc.gen_cntl & CRTC_DBL_SCAN_EN)\n\t\t\tvRefresh /= 2;\n\n\t\tDPRINTK(\"atyfb_set_par\\n\");\n\t\tDPRINTK(\" Set Visible Mode to %ix%i-%i\\n\",\n\t\t\tvar->xres, var->yres, var->bits_per_pixel);\n\t\tDPRINTK(\" Virtual resolution %ix%i, \"\n\t\t\t\"pixclock_in_ps %i (calculated %i)\\n\",\n\t\t\tvar->xres_virtual, var->yres_virtual,\n\t\t\tpixclock, pixclock_in_ps);\n\t\tDPRINTK(\" Dot clock:           %i MHz\\n\",\n\t\t\t1000000 / pixclock_in_ps);\n\t\tDPRINTK(\" Horizontal sync:     %i kHz\\n\", hSync);\n\t\tDPRINTK(\" Vertical refresh:    %i Hz\\n\", vRefresh);\n\t\tDPRINTK(\" x  style: %i.%03i %i %i %i %i   %i %i %i %i\\n\",\n\t\t\t1000000 / pixclock_in_ps, 1000000 % pixclock_in_ps,\n\t\t\th_disp, h_sync_strt, h_sync_end, h_total,\n\t\t\tv_disp, v_sync_strt, v_sync_end, v_total);\n\t\tDPRINTK(\" fb style: %i  %i %i %i %i %i %i %i %i\\n\",\n\t\t\tpixclock_in_ps,\n\t\t\tdebug.left_margin, h_disp, debug.right_margin, debug.hsync_len,\n\t\t\tdebug.upper_margin, v_disp, debug.lower_margin, debug.vsync_len);\n\t}\n#endif  \n\n\tif (!M64_HAS(INTEGRATED)) {\n\t\t \n\t\ttmp = aty_ld_le32(MEM_CNTL, par) & 0xf0ffffff;\n\t\tswitch (var->bits_per_pixel) {\n\t\tcase 8:\n\t\t\ttmp |= 0x02000000;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\ttmp |= 0x03000000;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\ttmp |= 0x06000000;\n\t\t\tbreak;\n\t\t}\n\t\taty_st_le32(MEM_CNTL, tmp, par);\n\t} else {\n\t\ttmp = aty_ld_le32(MEM_CNTL, par) & 0xf00fffff;\n\t\tif (!M64_HAS(MAGIC_POSTDIV))\n\t\t\ttmp |= par->mem_refresh_rate << 20;\n\t\tswitch (var->bits_per_pixel) {\n\t\tcase 8:\n\t\tcase 24:\n\t\t\ttmp |= 0x00000000;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\ttmp |= 0x04000000;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\ttmp |= 0x08000000;\n\t\t\tbreak;\n\t\t}\n\t\tif (M64_HAS(CT_BUS)) {\n\t\t\taty_st_le32(DAC_CNTL, 0x87010184, par);\n\t\t\taty_st_le32(BUS_CNTL, 0x680000f9, par);\n\t\t} else if (M64_HAS(VT_BUS)) {\n\t\t\taty_st_le32(DAC_CNTL, 0x87010184, par);\n\t\t\taty_st_le32(BUS_CNTL, 0x680000f9, par);\n\t\t} else if (M64_HAS(MOBIL_BUS)) {\n\t\t\taty_st_le32(DAC_CNTL, 0x80010102, par);\n\t\t\taty_st_le32(BUS_CNTL, 0x7b33a040 | (par->aux_start ? BUS_APER_REG_DIS : 0), par);\n\t\t} else {\n\t\t\t \n\t\t\taty_st_le32(DAC_CNTL, 0x86010102, par);\n\t\t\taty_st_le32(BUS_CNTL, 0x7b23a040 | (par->aux_start ? BUS_APER_REG_DIS : 0), par);\n\t\t\taty_st_le32(EXT_MEM_CNTL, aty_ld_le32(EXT_MEM_CNTL, par) | 0x5000001, par);\n\t\t}\n\t\taty_st_le32(MEM_CNTL, tmp, par);\n\t}\n\taty_st_8(DAC_MASK, 0xff, par);\n\n\tinfo->fix.line_length = calc_line_length(par, var->xres_virtual,\n\t\t\t\t\t\t var->bits_per_pixel);\n\n\tinfo->fix.visual = var->bits_per_pixel <= 8 ?\n\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\n\n\t \n\tif (par->accel_flags & FB_ACCELF_TEXT)\n\t\taty_init_engine(par, info);\n\n#ifdef CONFIG_BOOTX_TEXT\n\tbtext_update_display(info->fix.smem_start,\n\t\t(((par->crtc.h_tot_disp >> 16) & 0xff) + 1) * 8,\n\t\t((par->crtc.v_tot_disp >> 16) & 0x7ff) + 1,\n\t\tvar->bits_per_pixel,\n\t\tpar->crtc.vxres * var->bits_per_pixel / 8);\n#endif  \n#ifdef DEBUG\n{\n\t \n\tint i; u32 base;\n\n\t \n\tbase = 0x2000;\n\tprintk(\"debug atyfb: Mach64 non-shadow register values:\");\n\tfor (i = 0; i < 256; i = i+4) {\n\t\tif (i % 16 == 0) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tprintk(\"debug atyfb: 0x%04X: \", base + i);\n\t\t}\n\t\tpr_cont(\" %08X\", aty_ld_le32(i, par));\n\t}\n\tpr_cont(\"\\n\\n\");\n\n#ifdef CONFIG_FB_ATY_CT\n\t \n\tbase = 0x00;\n\tprintk(\"debug atyfb: Mach64 PLL register values:\");\n\tfor (i = 0; i < 64; i++) {\n\t\tif (i % 16 == 0) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tprintk(\"debug atyfb: 0x%02X: \", base + i);\n\t\t}\n\t\tif (i % 4 == 0)\n\t\t\tpr_cont(\" \");\n\t\tpr_cont(\"%02X\", aty_ld_pll_ct(i, par));\n\t}\n\tpr_cont(\"\\n\\n\");\n#endif\t \n\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tif (par->lcd_table != 0) {\n\t\t \n\t\tbase = 0x00;\n\t\tprintk(\"debug atyfb: LCD register values:\");\n\t\tif (M64_HAS(LT_LCD_REGS)) {\n\t\t\tfor (i = 0; i <= POWER_MANAGEMENT; i++) {\n\t\t\t\tif (i == EXT_VERT_STRETCH)\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\"\\ndebug atyfb: 0x%04X: \",\n\t\t\t\t       lt_lcd_regs[i]);\n\t\t\t\tpr_cont(\" %08X\", aty_ld_lcd(i, par));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < 64; i++) {\n\t\t\t\tif (i % 4 == 0)\n\t\t\t\t\tpr_cont(\"\\ndebug atyfb: 0x%02X: \",\n\t\t\t\t\t       base + i);\n\t\t\t\tpr_cont(\" %08X\", aty_ld_lcd(i, par));\n\t\t\t}\n\t\t}\n\t\tpr_cont(\"\\n\\n\");\n\t}\n#endif  \n}\n#endif  \n\treturn 0;\n}\n\nstatic int atyfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tint err;\n\tstruct crtc crtc;\n\tunion aty_pll pll;\n\tu32 pixclock;\n\n\tmemcpy(&pll, &par->pll, sizeof(pll));\n\n\terr = aty_var_to_crtc(info, var, &crtc);\n\tif (err)\n\t\treturn err;\n\n\tpixclock = atyfb_get_pixclock(var, par);\n\n\tif (pixclock == 0) {\n\t\tif (!(var->activate & FB_ACTIVATE_TEST))\n\t\t\tPRINTKE(\"Invalid pixclock\\n\");\n\t\treturn -EINVAL;\n\t} else {\n\t\terr = par->pll_ops->var_to_pll(info, pixclock,\n\t\t\t\t\t       var->bits_per_pixel, &pll);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (var->accel_flags & FB_ACCELF_TEXT)\n\t\tinfo->var.accel_flags = FB_ACCELF_TEXT;\n\telse\n\t\tinfo->var.accel_flags = 0;\n\n\taty_crtc_to_var(&crtc, var);\n\tvar->pixclock = par->pll_ops->pll_to_var(info, &pll);\n\treturn 0;\n}\n\nstatic void set_off_pitch(struct atyfb_par *par, const struct fb_info *info)\n{\n\tu32 xoffset = info->var.xoffset;\n\tu32 yoffset = info->var.yoffset;\n\tu32 line_length = info->fix.line_length;\n\tu32 bpp = info->var.bits_per_pixel;\n\n\tpar->crtc.off_pitch =\n\t\t((yoffset * line_length + xoffset * bpp / 8) / 8) |\n\t\t((line_length / bpp) << 22);\n}\n\n\n \n\nstatic int atyfb_open(struct fb_info *info, int user)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\n\tif (user) {\n\t\tpar->open++;\n#ifdef __sparc__\n\t\tpar->mmaped = 0;\n#endif\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t aty_irq(int irq, void *dev_id)\n{\n\tstruct atyfb_par *par = dev_id;\n\tint handled = 0;\n\tu32 int_cntl;\n\n\tspin_lock(&par->int_lock);\n\n\tint_cntl = aty_ld_le32(CRTC_INT_CNTL, par);\n\n\tif (int_cntl & CRTC_VBLANK_INT) {\n\t\t \n\t\taty_st_le32(CRTC_INT_CNTL, (int_cntl & CRTC_INT_EN_MASK) |\n\t\t\t    CRTC_VBLANK_INT_AK, par);\n\t\tpar->vblank.count++;\n\t\tif (par->vblank.pan_display) {\n\t\t\tpar->vblank.pan_display = 0;\n\t\t\taty_st_le32(CRTC_OFF_PITCH, par->crtc.off_pitch, par);\n\t\t}\n\t\twake_up_interruptible(&par->vblank.wait);\n\t\thandled = 1;\n\t}\n\n\tspin_unlock(&par->int_lock);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic int aty_enable_irq(struct atyfb_par *par, int reenable)\n{\n\tu32 int_cntl;\n\n\tif (!test_and_set_bit(0, &par->irq_flags)) {\n\t\tif (request_irq(par->irq, aty_irq, IRQF_SHARED, \"atyfb\", par)) {\n\t\t\tclear_bit(0, &par->irq_flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tspin_lock_irq(&par->int_lock);\n\t\tint_cntl = aty_ld_le32(CRTC_INT_CNTL, par) & CRTC_INT_EN_MASK;\n\t\t \n\t\taty_st_le32(CRTC_INT_CNTL, int_cntl | CRTC_VBLANK_INT_AK, par);\n\t\t \n\t\taty_st_le32(CRTC_INT_CNTL, int_cntl | CRTC_VBLANK_INT_EN, par);\n\t\tspin_unlock_irq(&par->int_lock);\n\t} else if (reenable) {\n\t\tspin_lock_irq(&par->int_lock);\n\t\tint_cntl = aty_ld_le32(CRTC_INT_CNTL, par) & CRTC_INT_EN_MASK;\n\t\tif (!(int_cntl & CRTC_VBLANK_INT_EN)) {\n\t\t\tprintk(\"atyfb: someone disabled IRQ [%08x]\\n\",\n\t\t\t       int_cntl);\n\t\t\t \n\t\t\taty_st_le32(CRTC_INT_CNTL, int_cntl |\n\t\t\t\t    CRTC_VBLANK_INT_EN, par);\n\t\t}\n\t\tspin_unlock_irq(&par->int_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int aty_disable_irq(struct atyfb_par *par)\n{\n\tu32 int_cntl;\n\n\tif (test_and_clear_bit(0, &par->irq_flags)) {\n\t\tif (par->vblank.pan_display) {\n\t\t\tpar->vblank.pan_display = 0;\n\t\t\taty_st_le32(CRTC_OFF_PITCH, par->crtc.off_pitch, par);\n\t\t}\n\t\tspin_lock_irq(&par->int_lock);\n\t\tint_cntl = aty_ld_le32(CRTC_INT_CNTL, par) & CRTC_INT_EN_MASK;\n\t\t \n\t\taty_st_le32(CRTC_INT_CNTL, int_cntl & ~CRTC_VBLANK_INT_EN, par);\n\t\tspin_unlock_irq(&par->int_lock);\n\t\tfree_irq(par->irq, par);\n\t}\n\n\treturn 0;\n}\n\nstatic int atyfb_release(struct fb_info *info, int user)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n#ifdef __sparc__\n\tint was_mmaped;\n#endif\n\n\tif (!user)\n\t\treturn 0;\n\n\tpar->open--;\n\tmdelay(1);\n\twait_for_idle(par);\n\n\tif (par->open)\n\t\treturn 0;\n\n#ifdef __sparc__\n\twas_mmaped = par->mmaped;\n\n\tpar->mmaped = 0;\n\n\tif (was_mmaped) {\n\t\tstruct fb_var_screeninfo var;\n\n\t\t \n\t\tvar = default_var;\n\t\tif (noaccel)\n\t\t\tvar.accel_flags &= ~FB_ACCELF_TEXT;\n\t\telse\n\t\t\tvar.accel_flags |= FB_ACCELF_TEXT;\n\t\tif (var.yres == var.yres_virtual) {\n\t\t\tu32 videoram = (info->fix.smem_len - (PAGE_SIZE << 2));\n\t\t\tvar.yres_virtual =\n\t\t\t\t((videoram * 8) / var.bits_per_pixel) /\n\t\t\t\tvar.xres_virtual;\n\t\t\tif (var.yres_virtual < var.yres)\n\t\t\t\tvar.yres_virtual = var.yres;\n\t\t}\n\t}\n#endif\n\taty_disable_irq(par);\n\n\treturn 0;\n}\n\n \n\nstatic int atyfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 xres, yres, xoffset, yoffset;\n\n\txres = (((par->crtc.h_tot_disp >> 16) & 0xff) + 1) * 8;\n\tyres = ((par->crtc.v_tot_disp >> 16) & 0x7ff) + 1;\n\tif (par->crtc.gen_cntl & CRTC_DBL_SCAN_EN)\n\t\tyres >>= 1;\n\txoffset = (var->xoffset + 7) & ~7;\n\tyoffset = var->yoffset;\n\tif (xoffset + xres > par->crtc.vxres ||\n\t    yoffset + yres > par->crtc.vyres)\n\t\treturn -EINVAL;\n\tinfo->var.xoffset = xoffset;\n\tinfo->var.yoffset = yoffset;\n\tif (par->asleep)\n\t\treturn 0;\n\n\tset_off_pitch(par, info);\n\tif ((var->activate & FB_ACTIVATE_VBL) && !aty_enable_irq(par, 0)) {\n\t\tpar->vblank.pan_display = 1;\n\t} else {\n\t\tpar->vblank.pan_display = 0;\n\t\taty_st_le32(CRTC_OFF_PITCH, par->crtc.off_pitch, par);\n\t}\n\n\treturn 0;\n}\n\nstatic int aty_waitforvblank(struct atyfb_par *par, u32 crtc)\n{\n\tstruct aty_interrupt *vbl;\n\tunsigned int count;\n\tint ret;\n\n\tswitch (crtc) {\n\tcase 0:\n\t\tvbl = &par->vblank;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tret = aty_enable_irq(par, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tcount = vbl->count;\n\tret = wait_event_interruptible_timeout(vbl->wait,\n\t\t\t\t\t       count != vbl->count, HZ/10);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0) {\n\t\taty_enable_irq(par, 1);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n\n#ifdef DEBUG\n#define ATYIO_CLKR\t\t0x41545900\t \n#define ATYIO_CLKW\t\t0x41545901\t \n\nstruct atyclk {\n\tu32 ref_clk_per;\n\tu8 pll_ref_div;\n\tu8 mclk_fb_div;\n\tu8 mclk_post_div;\t \n\tu8 mclk_fb_mult;\t \n\tu8 xclk_post_div;\t \n\tu8 vclk_fb_div;\n\tu8 vclk_post_div;\t \n\tu32 dsp_xclks_per_row;\t \n\tu32 dsp_loop_latency;\t \n\tu32 dsp_precision;\t \n\tu32 dsp_on;\t\t \n\tu32 dsp_off;\t\t \n};\n\n#define ATYIO_FEATR\t\t0x41545902\t \n#define ATYIO_FEATW\t\t0x41545903\t \n#endif\n\nstatic int atyfb_ioctl(struct fb_info *info, u_int cmd, u_long arg)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n#ifdef __sparc__\n\tstruct fbtype fbtyp;\n#endif\n\n\tswitch (cmd) {\n#ifdef __sparc__\n\tcase FBIOGTYPE:\n\t\tfbtyp.fb_type = FBTYPE_PCI_GENERIC;\n\t\tfbtyp.fb_width = par->crtc.vxres;\n\t\tfbtyp.fb_height = par->crtc.vyres;\n\t\tfbtyp.fb_depth = info->var.bits_per_pixel;\n\t\tfbtyp.fb_cmsize = info->cmap.len;\n\t\tfbtyp.fb_size = info->fix.smem_len;\n\t\tif (copy_to_user((struct fbtype __user *) arg, &fbtyp,\n\t\t\t\t sizeof(fbtyp)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif  \n\n\tcase FBIO_WAITFORVSYNC:\n\t\t{\n\t\t\tu32 crtc;\n\n\t\t\tif (get_user(crtc, (__u32 __user *) arg))\n\t\t\t\treturn -EFAULT;\n\n\t\t\treturn aty_waitforvblank(par, crtc);\n\t\t}\n\n#if defined(DEBUG) && defined(CONFIG_FB_ATY_CT)\n\tcase ATYIO_CLKR:\n\t\tif (M64_HAS(INTEGRATED)) {\n\t\t\tstruct atyclk clk = { 0 };\n\t\t\tunion aty_pll *pll = &par->pll;\n\t\t\tu32 dsp_config = pll->ct.dsp_config;\n\t\t\tu32 dsp_on_off = pll->ct.dsp_on_off;\n\t\t\tclk.ref_clk_per = par->ref_clk_per;\n\t\t\tclk.pll_ref_div = pll->ct.pll_ref_div;\n\t\t\tclk.mclk_fb_div = pll->ct.mclk_fb_div;\n\t\t\tclk.mclk_post_div = pll->ct.mclk_post_div_real;\n\t\t\tclk.mclk_fb_mult = pll->ct.mclk_fb_mult;\n\t\t\tclk.xclk_post_div = pll->ct.xclk_post_div_real;\n\t\t\tclk.vclk_fb_div = pll->ct.vclk_fb_div;\n\t\t\tclk.vclk_post_div = pll->ct.vclk_post_div_real;\n\t\t\tclk.dsp_xclks_per_row = dsp_config & 0x3fff;\n\t\t\tclk.dsp_loop_latency = (dsp_config >> 16) & 0xf;\n\t\t\tclk.dsp_precision = (dsp_config >> 20) & 7;\n\t\t\tclk.dsp_off = dsp_on_off & 0x7ff;\n\t\t\tclk.dsp_on = (dsp_on_off >> 16) & 0x7ff;\n\t\t\tif (copy_to_user((struct atyclk __user *) arg, &clk,\n\t\t\t\t\t sizeof(clk)))\n\t\t\t\treturn -EFAULT;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase ATYIO_CLKW:\n\t\tif (M64_HAS(INTEGRATED)) {\n\t\t\tstruct atyclk clk;\n\t\t\tunion aty_pll *pll = &par->pll;\n\t\t\tif (copy_from_user(&clk, (struct atyclk __user *) arg,\n\t\t\t\t\t   sizeof(clk)))\n\t\t\t\treturn -EFAULT;\n\t\t\tpar->ref_clk_per = clk.ref_clk_per;\n\t\t\tpll->ct.pll_ref_div = clk.pll_ref_div;\n\t\t\tpll->ct.mclk_fb_div = clk.mclk_fb_div;\n\t\t\tpll->ct.mclk_post_div_real = clk.mclk_post_div;\n\t\t\tpll->ct.mclk_fb_mult = clk.mclk_fb_mult;\n\t\t\tpll->ct.xclk_post_div_real = clk.xclk_post_div;\n\t\t\tpll->ct.vclk_fb_div = clk.vclk_fb_div;\n\t\t\tpll->ct.vclk_post_div_real = clk.vclk_post_div;\n\t\t\tpll->ct.dsp_config = (clk.dsp_xclks_per_row & 0x3fff) |\n\t\t\t\t((clk.dsp_loop_latency & 0xf) << 16) |\n\t\t\t\t((clk.dsp_precision & 7) << 20);\n\t\t\tpll->ct.dsp_on_off = (clk.dsp_off & 0x7ff) |\n\t\t\t\t((clk.dsp_on & 0x7ff) << 16);\n\t\t\t \n\t\t\taty_set_pll_ct(info, pll);\n\t\t} else\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase ATYIO_FEATR:\n\t\tif (get_user(par->features, (u32 __user *) arg))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase ATYIO_FEATW:\n\t\tif (put_user(par->features, (u32 __user *) arg))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif  \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int atyfb_sync(struct fb_info *info)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\n\tif (par->blitter_may_be_busy)\n\t\twait_for_idle(par);\n\treturn 0;\n}\n\n#ifdef __sparc__\nstatic int atyfb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tunsigned int size, page, map_size = 0;\n\tunsigned long map_offset = 0;\n\tunsigned long off;\n\tint i;\n\n\tif (!par->mmap_map)\n\t\treturn -ENXIO;\n\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tsize = vma->vm_end - vma->vm_start;\n\n\t \n\n\tif (((vma->vm_pgoff == 0) && (size == info->fix.smem_len)) ||\n\t    ((off == info->fix.smem_len) && (size == PAGE_SIZE)))\n\t\toff += 0x8000000000000000UL;\n\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\t \n\n\t \n\tfor (page = 0; page < size;) {\n\t\tmap_size = 0;\n\t\tfor (i = 0; par->mmap_map[i].size; i++) {\n\t\t\tunsigned long start = par->mmap_map[i].voff;\n\t\t\tunsigned long end = start + par->mmap_map[i].size;\n\t\t\tunsigned long offset = off + page;\n\n\t\t\tif (start > offset)\n\t\t\t\tcontinue;\n\t\t\tif (offset >= end)\n\t\t\t\tcontinue;\n\n\t\t\tmap_size = par->mmap_map[i].size - (offset - start);\n\t\t\tmap_offset = par->mmap_map[i].poff + (offset - start);\n\t\t\tbreak;\n\t\t}\n\t\tif (!map_size) {\n\t\t\tpage += PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (page + map_size > size)\n\t\t\tmap_size = size - page;\n\n\t\tpgprot_val(vma->vm_page_prot) &= ~(par->mmap_map[i].prot_mask);\n\t\tpgprot_val(vma->vm_page_prot) |= par->mmap_map[i].prot_flag;\n\n\t\tif (remap_pfn_range(vma, vma->vm_start + page,\n\t\t\tmap_offset >> PAGE_SHIFT, map_size, vma->vm_page_prot))\n\t\t\treturn -EAGAIN;\n\n\t\tpage += map_size;\n\t}\n\n\tif (!map_size)\n\t\treturn -EINVAL;\n\n\tif (!par->mmaped)\n\t\tpar->mmaped = 1;\n\treturn 0;\n}\n#endif  \n\n\n\n#if defined(CONFIG_PCI)\n\n#ifdef CONFIG_PPC_PMAC\n \nstatic int aty_power_mgmt(int sleep, struct atyfb_par *par)\n{\n\tu32 pm;\n\tint timeout;\n\n\tpm = aty_ld_lcd(POWER_MANAGEMENT, par);\n\tpm = (pm & ~PWR_MGT_MODE_MASK) | PWR_MGT_MODE_REG;\n\taty_st_lcd(POWER_MANAGEMENT, pm, par);\n\tpm = aty_ld_lcd(POWER_MANAGEMENT, par);\n\n\ttimeout = 2000;\n\tif (sleep) {\n\t\t \n\t\tpm &= ~PWR_MGT_ON;\n\t\taty_st_lcd(POWER_MANAGEMENT, pm, par);\n\t\tpm = aty_ld_lcd(POWER_MANAGEMENT, par);\n\t\tudelay(10);\n\t\tpm &= ~(PWR_BLON | AUTO_PWR_UP);\n\t\tpm |= SUSPEND_NOW;\n\t\taty_st_lcd(POWER_MANAGEMENT, pm, par);\n\t\tpm = aty_ld_lcd(POWER_MANAGEMENT, par);\n\t\tudelay(10);\n\t\tpm |= PWR_MGT_ON;\n\t\taty_st_lcd(POWER_MANAGEMENT, pm, par);\n\t\tdo {\n\t\t\tpm = aty_ld_lcd(POWER_MANAGEMENT, par);\n\t\t\tmdelay(1);\n\t\t\tif ((--timeout) == 0)\n\t\t\t\tbreak;\n\t\t} while ((pm & PWR_MGT_STATUS_MASK) != PWR_MGT_STATUS_SUSPEND);\n\t} else {\n\t\t \n\t\tpm &= ~PWR_MGT_ON;\n\t\taty_st_lcd(POWER_MANAGEMENT, pm, par);\n\t\tpm = aty_ld_lcd(POWER_MANAGEMENT, par);\n\t\tudelay(10);\n\t\tpm &= ~SUSPEND_NOW;\n\t\tpm |= (PWR_BLON | AUTO_PWR_UP);\n\t\taty_st_lcd(POWER_MANAGEMENT, pm, par);\n\t\tpm = aty_ld_lcd(POWER_MANAGEMENT, par);\n\t\tudelay(10);\n\t\tpm |= PWR_MGT_ON;\n\t\taty_st_lcd(POWER_MANAGEMENT, pm, par);\n\t\tdo {\n\t\t\tpm = aty_ld_lcd(POWER_MANAGEMENT, par);\n\t\t\tmdelay(1);\n\t\t\tif ((--timeout) == 0)\n\t\t\t\tbreak;\n\t\t} while ((pm & PWR_MGT_STATUS_MASK) != 0);\n\t}\n\tmdelay(500);\n\n\treturn timeout ? 0 : -EIO;\n}\n#endif  \n\nstatic int atyfb_pci_suspend_late(struct device *dev, pm_message_t state)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\n\tif (state.event == pdev->dev.power.power_state.event)\n\t\treturn 0;\n\n\tconsole_lock();\n\n\tfb_set_suspend(info, 1);\n\n\t \n\twait_for_idle(par);\n\taty_reset_engine(par);\n\n\t \n\tatyfb_blank(FB_BLANK_POWERDOWN, info);\n\n\tpar->asleep = 1;\n\tpar->lock_blank = 1;\n\n\t \n\n#ifdef CONFIG_PPC_PMAC\n\t \n\tif (machine_is(powermac) && aty_power_mgmt(1, par)) {\n\t\tpar->asleep = 0;\n\t\tpar->lock_blank = 0;\n\t\tatyfb_blank(FB_BLANK_UNBLANK, info);\n\t\tfb_set_suspend(info, 0);\n\t\tconsole_unlock();\n\t\treturn -EIO;\n\t}\n#endif\n\n\tconsole_unlock();\n\n\tpdev->dev.power.power_state = state;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused atyfb_pci_suspend(struct device *dev)\n{\n\treturn atyfb_pci_suspend_late(dev, PMSG_SUSPEND);\n}\n\nstatic int __maybe_unused atyfb_pci_hibernate(struct device *dev)\n{\n\treturn atyfb_pci_suspend_late(dev, PMSG_HIBERNATE);\n}\n\nstatic int __maybe_unused atyfb_pci_freeze(struct device *dev)\n{\n\treturn atyfb_pci_suspend_late(dev, PMSG_FREEZE);\n}\n\nstatic void aty_resume_chip(struct fb_info *info)\n{\n\tstruct atyfb_par *par = info->par;\n\n\taty_st_le32(MEM_CNTL, par->mem_cntl, par);\n\n\tif (par->pll_ops->resume_pll)\n\t\tpar->pll_ops->resume_pll(info, &par->pll);\n\n\tif (par->aux_start)\n\t\taty_st_le32(BUS_CNTL,\n\t\t\taty_ld_le32(BUS_CNTL, par) | BUS_APER_REG_DIS, par);\n}\n\nstatic int __maybe_unused atyfb_pci_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\n\tif (pdev->dev.power.power_state.event == PM_EVENT_ON)\n\t\treturn 0;\n\n\tconsole_lock();\n\n\t \n\n#ifdef CONFIG_PPC_PMAC\n\tif (machine_is(powermac) &&\n\t    pdev->dev.power.power_state.event == PM_EVENT_SUSPEND)\n\t\taty_power_mgmt(0, par);\n#endif\n\n\taty_resume_chip(info);\n\n\tpar->asleep = 0;\n\n\t \n\tatyfb_set_par(info);\n\n\t \n\tfb_set_suspend(info, 0);\n\n\t \n\tpar->lock_blank = 0;\n\tatyfb_blank(FB_BLANK_UNBLANK, info);\n\n\tconsole_unlock();\n\n\tpdev->dev.power.power_state = PMSG_ON;\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops atyfb_pci_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= atyfb_pci_suspend,\n\t.resume\t\t= atyfb_pci_resume,\n\t.freeze\t\t= atyfb_pci_freeze,\n\t.thaw\t\t= atyfb_pci_resume,\n\t.poweroff\t= atyfb_pci_hibernate,\n\t.restore\t= atyfb_pci_resume,\n#endif  \n};\n\n#endif  \n\n \n#ifdef CONFIG_FB_ATY_BACKLIGHT\n#define MAX_LEVEL 0xFF\n\nstatic int aty_bl_get_level_brightness(struct atyfb_par *par, int level)\n{\n\tstruct fb_info *info = pci_get_drvdata(par->pdev);\n\tint atylevel;\n\n\t \n\t \n\tatylevel = info->bl_curve[level] * FB_BACKLIGHT_MAX / MAX_LEVEL;\n\n\tif (atylevel < 0)\n\t\tatylevel = 0;\n\telse if (atylevel > MAX_LEVEL)\n\t\tatylevel = MAX_LEVEL;\n\n\treturn atylevel;\n}\n\nstatic int aty_bl_update_status(struct backlight_device *bd)\n{\n\tstruct atyfb_par *par = bl_get_data(bd);\n\tunsigned int reg = aty_ld_lcd(LCD_MISC_CNTL, par);\n\tint level = backlight_get_brightness(bd);\n\n\treg |= (BLMOD_EN | BIASMOD_EN);\n\tif (level > 0) {\n\t\treg &= ~BIAS_MOD_LEVEL_MASK;\n\t\treg |= (aty_bl_get_level_brightness(par, level) << BIAS_MOD_LEVEL_SHIFT);\n\t} else {\n\t\treg &= ~BIAS_MOD_LEVEL_MASK;\n\t\treg |= (aty_bl_get_level_brightness(par, 0) << BIAS_MOD_LEVEL_SHIFT);\n\t}\n\taty_st_lcd(LCD_MISC_CNTL, reg, par);\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops aty_bl_data = {\n\t.update_status\t= aty_bl_update_status,\n};\n\nstatic void aty_bl_init(struct atyfb_par *par)\n{\n\tstruct backlight_properties props;\n\tstruct fb_info *info = pci_get_drvdata(par->pdev);\n\tstruct backlight_device *bd;\n\tchar name[12];\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n\tif (!pmac_has_backlight_type(\"ati\"))\n\t\treturn;\n#endif\n\n\tsnprintf(name, sizeof(name), \"atybl%d\", info->node);\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = FB_BACKLIGHT_LEVELS - 1;\n\tbd = backlight_device_register(name, info->device, par, &aty_bl_data,\n\t\t\t\t       &props);\n\tif (IS_ERR(bd)) {\n\t\tinfo->bl_dev = NULL;\n\t\tprintk(KERN_WARNING \"aty: Backlight registration failed\\n\");\n\t\tgoto error;\n\t}\n\n\tinfo->bl_dev = bd;\n\tfb_bl_default_curve(info, 0,\n\t\t\t    0x3F * FB_BACKLIGHT_MAX / MAX_LEVEL,\n\t\t\t    0xFF * FB_BACKLIGHT_MAX / MAX_LEVEL);\n\n\tbd->props.brightness = bd->props.max_brightness;\n\tbd->props.power = FB_BLANK_UNBLANK;\n\tbacklight_update_status(bd);\n\n\tprintk(\"aty: Backlight initialized (%s)\\n\", name);\n\n\treturn;\n\nerror:\n\treturn;\n}\n\n#ifdef CONFIG_PCI\nstatic void aty_bl_exit(struct backlight_device *bd)\n{\n\tbacklight_device_unregister(bd);\n\tprintk(\"aty: Backlight unloaded\\n\");\n}\n#endif  \n\n#endif  \n\nstatic void aty_calc_mem_refresh(struct atyfb_par *par, int xclk)\n{\n\tstatic const int ragepro_tbl[] = {\n\t\t44, 50, 55, 66, 75, 80, 100\n\t};\n\tstatic const int ragexl_tbl[] = {\n\t\t50, 66, 75, 83, 90, 95, 100, 105,\n\t\t110, 115, 120, 125, 133, 143, 166\n\t};\n\tconst int *refresh_tbl;\n\tint i, size;\n\n\tif (M64_HAS(XL_MEM)) {\n\t\trefresh_tbl = ragexl_tbl;\n\t\tsize = ARRAY_SIZE(ragexl_tbl);\n\t} else {\n\t\trefresh_tbl = ragepro_tbl;\n\t\tsize = ARRAY_SIZE(ragepro_tbl);\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (xclk < refresh_tbl[i])\n\t\t\tbreak;\n\t}\n\tpar->mem_refresh_rate = i;\n}\n\n \n\nstatic struct fb_info *fb_list = NULL;\n\n#if defined(__i386__) && defined(CONFIG_FB_ATY_GENERIC_LCD)\nstatic int atyfb_get_timings_from_lcd(struct atyfb_par *par,\n\t\t\t\t      struct fb_var_screeninfo *var)\n{\n\tint ret = -EINVAL;\n\n\tif (par->lcd_table != 0 && (aty_ld_lcd(LCD_GEN_CNTL, par) & LCD_ON)) {\n\t\t*var = default_var;\n\t\tvar->xres = var->xres_virtual = par->lcd_hdisp;\n\t\tvar->right_margin = par->lcd_right_margin;\n\t\tvar->left_margin = par->lcd_hblank_len -\n\t\t\t(par->lcd_right_margin + par->lcd_hsync_dly +\n\t\t\t par->lcd_hsync_len);\n\t\tvar->hsync_len = par->lcd_hsync_len + par->lcd_hsync_dly;\n\t\tvar->yres = var->yres_virtual = par->lcd_vdisp;\n\t\tvar->lower_margin = par->lcd_lower_margin;\n\t\tvar->upper_margin = par->lcd_vblank_len -\n\t\t\t(par->lcd_lower_margin + par->lcd_vsync_len);\n\t\tvar->vsync_len = par->lcd_vsync_len;\n\t\tvar->pixclock = par->lcd_pixclock;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n#endif  \n\nstatic int aty_init(struct fb_info *info)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tconst char *ramname = NULL, *xtal;\n\tint gtb_memsize, has_var = 0;\n\tstruct fb_var_screeninfo var;\n\tint ret;\n#ifdef CONFIG_ATARI\n\tu8 dac_type;\n#endif\n\n\tinit_waitqueue_head(&par->vblank.wait);\n\tspin_lock_init(&par->int_lock);\n\n#ifdef CONFIG_FB_ATY_GX\n\tif (!M64_HAS(INTEGRATED)) {\n\t\tu32 stat0;\n\t\tu8 dac_subtype, clk_type;\n\t\tstat0 = aty_ld_le32(CNFG_STAT0, par);\n\t\tpar->bus_type = (stat0 >> 0) & 0x07;\n\t\tpar->ram_type = (stat0 >> 3) & 0x07;\n\t\tramname = aty_gx_ram[par->ram_type];\n\t\t \n#ifdef CONFIG_ATARI\n\t\tclk_type = CLK_ATI18818_1;\n\t\tdac_type = (stat0 >> 9) & 0x07;\n\t\tif (dac_type == 0x07)\n\t\t\tdac_subtype = DAC_ATT20C408;\n\t\telse\n\t\t\tdac_subtype = (aty_ld_8(SCRATCH_REG1 + 1, par) & 0xF0) | dac_type;\n#else\n\t\tdac_subtype = DAC_IBMRGB514;\n\t\tclk_type = CLK_IBMRGB514;\n#endif\n\t\tswitch (dac_subtype) {\n\t\tcase DAC_IBMRGB514:\n\t\t\tpar->dac_ops = &aty_dac_ibm514;\n\t\t\tbreak;\n#ifdef CONFIG_ATARI\n\t\tcase DAC_ATI68860_B:\n\t\tcase DAC_ATI68860_C:\n\t\t\tpar->dac_ops = &aty_dac_ati68860b;\n\t\t\tbreak;\n\t\tcase DAC_ATT20C408:\n\t\tcase DAC_ATT21C498:\n\t\t\tpar->dac_ops = &aty_dac_att21c498;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tPRINTKI(\"aty_init: DAC type not implemented yet!\\n\");\n\t\t\tpar->dac_ops = &aty_dac_unsupported;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (clk_type) {\n#ifdef CONFIG_ATARI\n\t\tcase CLK_ATI18818_1:\n\t\t\tpar->pll_ops = &aty_pll_ati18818_1;\n\t\t\tbreak;\n#else\n\t\tcase CLK_IBMRGB514:\n\t\t\tpar->pll_ops = &aty_pll_ibm514;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tPRINTKI(\"aty_init: CLK type not implemented yet!\");\n\t\t\tpar->pll_ops = &aty_pll_unsupported;\n\t\t\tbreak;\n\t\t}\n\t}\n#endif  \n#ifdef CONFIG_FB_ATY_CT\n\tif (M64_HAS(INTEGRATED)) {\n\t\tpar->dac_ops = &aty_dac_ct;\n\t\tpar->pll_ops = &aty_pll_ct;\n\t\tpar->bus_type = PCI;\n\t\tpar->ram_type = (aty_ld_le32(CNFG_STAT0, par) & 0x07);\n\t\tif (M64_HAS(XL_MEM))\n\t\t\tramname = aty_xl_ram[par->ram_type];\n\t\telse\n\t\t\tramname = aty_ct_ram[par->ram_type];\n\t\t \n\t\tif (par->pll_limits.mclk == 67 && par->ram_type < SDRAM)\n\t\t\tpar->pll_limits.mclk = 63;\n\t\t \n\t\tif (M64_HAS(MOBIL_BUS) && par->ram_type == SDRAM32)\n\t\t\tpar->pll_limits.xclk = (par->pll_limits.xclk + 1) >> 1;\n\t}\n#endif\n#ifdef CONFIG_PPC_PMAC\n\t \n\tif (of_machine_is_compatible(\"PowerBook2,1\")) {\n\t\tpar->pll_limits.mclk = 70;\n\t\tpar->pll_limits.xclk = 53;\n\t}\n#endif\n\n\t \n\tif (pll)\n\t\tpar->pll_limits.pll_max = pll;\n\tif (mclk)\n\t\tpar->pll_limits.mclk = mclk;\n\tif (xclk)\n\t\tpar->pll_limits.xclk = xclk;\n\n\taty_calc_mem_refresh(par, par->pll_limits.xclk);\n\tpar->pll_per = 1000000/par->pll_limits.pll_max;\n\tpar->mclk_per = 1000000/par->pll_limits.mclk;\n\tpar->xclk_per = 1000000/par->pll_limits.xclk;\n\n\tpar->ref_clk_per = 1000000000000ULL / 14318180;\n\txtal = \"14.31818\";\n\n#ifdef CONFIG_FB_ATY_CT\n\tif (M64_HAS(GTB_DSP)) {\n\t\tu8 pll_ref_div = aty_ld_pll_ct(PLL_REF_DIV, par);\n\n\t\tif (pll_ref_div) {\n\t\t\tint diff1, diff2;\n\t\t\tdiff1 = 510 * 14 / pll_ref_div - par->pll_limits.pll_max;\n\t\t\tdiff2 = 510 * 29 / pll_ref_div - par->pll_limits.pll_max;\n\t\t\tif (diff1 < 0)\n\t\t\t\tdiff1 = -diff1;\n\t\t\tif (diff2 < 0)\n\t\t\t\tdiff2 = -diff2;\n\t\t\tif (diff2 < diff1) {\n\t\t\t\tpar->ref_clk_per = 1000000000000ULL / 29498928;\n\t\t\t\txtal = \"29.498928\";\n\t\t\t}\n\t\t}\n\t}\n#endif  \n\n\t \n\taty_get_crtc(par, &par->saved_crtc);\n\tif (par->pll_ops->get_pll)\n\t\tpar->pll_ops->get_pll(info, &par->saved_pll);\n\n\tpar->mem_cntl = aty_ld_le32(MEM_CNTL, par);\n\tgtb_memsize = M64_HAS(GTB_DSP);\n\tif (gtb_memsize)\n\t\t \n\t\tswitch (par->mem_cntl & 0xF) {\n\t\tcase MEM_SIZE_512K:\n\t\t\tinfo->fix.smem_len = 0x80000;\n\t\t\tbreak;\n\t\tcase MEM_SIZE_1M:\n\t\t\tinfo->fix.smem_len = 0x100000;\n\t\t\tbreak;\n\t\tcase MEM_SIZE_2M_GTB:\n\t\t\tinfo->fix.smem_len = 0x200000;\n\t\t\tbreak;\n\t\tcase MEM_SIZE_4M_GTB:\n\t\t\tinfo->fix.smem_len = 0x400000;\n\t\t\tbreak;\n\t\tcase MEM_SIZE_6M_GTB:\n\t\t\tinfo->fix.smem_len = 0x600000;\n\t\t\tbreak;\n\t\tcase MEM_SIZE_8M_GTB:\n\t\t\tinfo->fix.smem_len = 0x800000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo->fix.smem_len = 0x80000;\n\t} else\n\t\tswitch (par->mem_cntl & MEM_SIZE_ALIAS) {\n\t\tcase MEM_SIZE_512K:\n\t\t\tinfo->fix.smem_len = 0x80000;\n\t\t\tbreak;\n\t\tcase MEM_SIZE_1M:\n\t\t\tinfo->fix.smem_len = 0x100000;\n\t\t\tbreak;\n\t\tcase MEM_SIZE_2M:\n\t\t\tinfo->fix.smem_len = 0x200000;\n\t\t\tbreak;\n\t\tcase MEM_SIZE_4M:\n\t\t\tinfo->fix.smem_len = 0x400000;\n\t\t\tbreak;\n\t\tcase MEM_SIZE_6M:\n\t\t\tinfo->fix.smem_len = 0x600000;\n\t\t\tbreak;\n\t\tcase MEM_SIZE_8M:\n\t\t\tinfo->fix.smem_len = 0x800000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo->fix.smem_len = 0x80000;\n\t\t}\n\n\tif (M64_HAS(MAGIC_VRAM_SIZE)) {\n\t\tif (aty_ld_le32(CNFG_STAT1, par) & 0x40000000)\n\t\t\tinfo->fix.smem_len += 0x400000;\n\t}\n\n\tif (vram) {\n\t\tinfo->fix.smem_len = vram * 1024;\n\t\tpar->mem_cntl &= ~(gtb_memsize ? 0xF : MEM_SIZE_ALIAS);\n\t\tif (info->fix.smem_len <= 0x80000)\n\t\t\tpar->mem_cntl |= MEM_SIZE_512K;\n\t\telse if (info->fix.smem_len <= 0x100000)\n\t\t\tpar->mem_cntl |= MEM_SIZE_1M;\n\t\telse if (info->fix.smem_len <= 0x200000)\n\t\t\tpar->mem_cntl |= gtb_memsize ? MEM_SIZE_2M_GTB : MEM_SIZE_2M;\n\t\telse if (info->fix.smem_len <= 0x400000)\n\t\t\tpar->mem_cntl |= gtb_memsize ? MEM_SIZE_4M_GTB : MEM_SIZE_4M;\n\t\telse if (info->fix.smem_len <= 0x600000)\n\t\t\tpar->mem_cntl |= gtb_memsize ? MEM_SIZE_6M_GTB : MEM_SIZE_6M;\n\t\telse\n\t\t\tpar->mem_cntl |= gtb_memsize ? MEM_SIZE_8M_GTB : MEM_SIZE_8M;\n\t\taty_st_le32(MEM_CNTL, par->mem_cntl, par);\n\t}\n\n\t \n\tif (M64_HAS(GX)) {\n\t\tinfo->fix.mmio_len = 0x400;\n\t\tinfo->fix.accel = FB_ACCEL_ATI_MACH64GX;\n\t} else if (M64_HAS(CT)) {\n\t\tinfo->fix.mmio_len = 0x400;\n\t\tinfo->fix.accel = FB_ACCEL_ATI_MACH64CT;\n\t} else if (M64_HAS(VT)) {\n\t\tinfo->fix.mmio_start -= 0x400;\n\t\tinfo->fix.mmio_len = 0x800;\n\t\tinfo->fix.accel = FB_ACCEL_ATI_MACH64VT;\n\t} else { \n\t\tinfo->fix.mmio_start -= 0x400;\n\t\tinfo->fix.mmio_len = 0x800;\n\t\tinfo->fix.accel = FB_ACCEL_ATI_MACH64GT;\n\t}\n\n\tPRINTKI(\"%d%c %s, %s MHz XTAL, %d MHz PLL, %d Mhz MCLK, %d MHz XCLK\\n\",\n\t\tinfo->fix.smem_len == 0x80000 ? 512 : (info->fix.smem_len>>20),\n\t\tinfo->fix.smem_len == 0x80000 ? 'K' : 'M', ramname, xtal,\n\t\tpar->pll_limits.pll_max, par->pll_limits.mclk,\n\t\tpar->pll_limits.xclk);\n\n#if defined(DEBUG) && defined(CONFIG_FB_ATY_CT)\n\tif (M64_HAS(INTEGRATED)) {\n\t\tint i;\n\t\tprintk(\"debug atyfb: BUS_CNTL DAC_CNTL MEM_CNTL \"\n\t\t       \"EXT_MEM_CNTL CRTC_GEN_CNTL DSP_CONFIG \"\n\t\t       \"DSP_ON_OFF CLOCK_CNTL\\n\"\n\t\t       \"debug atyfb: %08x %08x %08x \"\n\t\t       \"%08x     %08x      %08x   \"\n\t\t       \"%08x   %08x\\n\"\n\t\t       \"debug atyfb: PLL\",\n\t\t       aty_ld_le32(BUS_CNTL, par),\n\t\t       aty_ld_le32(DAC_CNTL, par),\n\t\t       aty_ld_le32(MEM_CNTL, par),\n\t\t       aty_ld_le32(EXT_MEM_CNTL, par),\n\t\t       aty_ld_le32(CRTC_GEN_CNTL, par),\n\t\t       aty_ld_le32(DSP_CONFIG, par),\n\t\t       aty_ld_le32(DSP_ON_OFF, par),\n\t\t       aty_ld_le32(CLOCK_CNTL, par));\n\t\tfor (i = 0; i < 40; i++)\n\t\t\tpr_cont(\" %02x\", aty_ld_pll_ct(i, par));\n\t\tpr_cont(\"\\n\");\n\t}\n#endif\n\tif (par->pll_ops->init_pll)\n\t\tpar->pll_ops->init_pll(info, &par->pll);\n\tif (par->pll_ops->resume_pll)\n\t\tpar->pll_ops->resume_pll(info, &par->pll);\n\n\taty_fudge_framebuffer_len(info);\n\n\t \n\tif (par->aux_start)\n\t\taty_st_le32(BUS_CNTL, aty_ld_le32(BUS_CNTL, par) |\n\t\t\t    BUS_APER_REG_DIS, par);\n\n\tif (!nomtrr)\n\t\t \n\t\tpar->wc_cookie = arch_phys_wc_add(par->res_start,\n\t\t\t\t\t\t  par->res_size);\n\n\tinfo->fbops = &atyfb_ops;\n\tinfo->pseudo_palette = par->pseudo_palette;\n\tinfo->flags = FBINFO_HWACCEL_IMAGEBLIT |\n\t\t      FBINFO_HWACCEL_FILLRECT  |\n\t\t      FBINFO_HWACCEL_COPYAREA  |\n\t\t      FBINFO_HWACCEL_YPAN      |\n\t\t      FBINFO_READS_FAST;\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n\tif (M64_HAS(G3_PB_1_1) && of_machine_is_compatible(\"PowerBook1,1\")) {\n\t\t \n\t\taty_st_lcd(POWER_MANAGEMENT, aty_ld_lcd(POWER_MANAGEMENT, par) |\n\t\t\t   USE_F32KHZ | TRISTATE_MEM_EN, par);\n\t} else\n#endif\n\n\tmemset(&var, 0, sizeof(var));\n#ifdef CONFIG_PPC\n\tif (machine_is(powermac)) {\n\t\t \n\t\tif (mode) {\n\t\t\tif (mac_find_mode(&var, info, mode, 8))\n\t\t\t\thas_var = 1;\n\t\t} else {\n\t\t\tif (default_vmode == VMODE_CHOOSE) {\n\t\t\t\tint sense;\n\t\t\t\tif (M64_HAS(G3_PB_1024x768))\n\t\t\t\t\t \n\t\t\t\t\tdefault_vmode = VMODE_1024_768_60;\n\t\t\t\telse if (of_machine_is_compatible(\"iMac\"))\n\t\t\t\t\tdefault_vmode = VMODE_1024_768_75;\n\t\t\t\telse if (of_machine_is_compatible(\"PowerBook2,1\"))\n\t\t\t\t\t \n\t\t\t\t\tdefault_vmode = VMODE_800_600_60;\n\t\t\t\telse\n\t\t\t\t\tdefault_vmode = VMODE_640_480_67;\n\t\t\t\tsense = read_aty_sense(par);\n\t\t\t\tPRINTKI(\"monitor sense=%x, mode %d\\n\",\n\t\t\t\t\tsense,  mac_map_monitor_sense(sense));\n\t\t\t}\n\t\t\tif (default_vmode <= 0 || default_vmode > VMODE_MAX)\n\t\t\t\tdefault_vmode = VMODE_640_480_60;\n\t\t\tif (default_cmode < CMODE_8 || default_cmode > CMODE_32)\n\t\t\t\tdefault_cmode = CMODE_8;\n\t\t\tif (!mac_vmode_to_var(default_vmode, default_cmode,\n\t\t\t\t\t      &var))\n\t\t\t\thas_var = 1;\n\t\t}\n\t}\n\n#endif  \n\n#if defined(__i386__) && defined(CONFIG_FB_ATY_GENERIC_LCD)\n\tif (!atyfb_get_timings_from_lcd(par, &var))\n\t\thas_var = 1;\n#endif\n\n\tif (mode && fb_find_mode(&var, info, mode, NULL, 0, &defmode, 8))\n\t\thas_var = 1;\n\n\tif (!has_var)\n\t\tvar = default_var;\n\n\tif (noaccel)\n\t\tvar.accel_flags &= ~FB_ACCELF_TEXT;\n\telse\n\t\tvar.accel_flags |= FB_ACCELF_TEXT;\n\n\tif (comp_sync != -1) {\n\t\tif (!comp_sync)\n\t\t\tvar.sync &= ~FB_SYNC_COMP_HIGH_ACT;\n\t\telse\n\t\t\tvar.sync |= FB_SYNC_COMP_HIGH_ACT;\n\t}\n\n\tif (var.yres == var.yres_virtual) {\n\t\tu32 videoram = (info->fix.smem_len - (PAGE_SIZE << 2));\n\t\tvar.yres_virtual = ((videoram * 8) / var.bits_per_pixel) / var.xres_virtual;\n\t\tif (var.yres_virtual < var.yres)\n\t\t\tvar.yres_virtual = var.yres;\n\t}\n\n\tret = atyfb_check_var(&var, info);\n\tif (ret) {\n\t\tPRINTKE(\"can't set default video mode\\n\");\n\t\tgoto aty_init_exit;\n\t}\n\n#ifdef CONFIG_FB_ATY_CT\n\tif (!noaccel && M64_HAS(INTEGRATED))\n\t\taty_init_cursor(info, &atyfb_ops);\n#endif  \n\tinfo->var = var;\n\n\tret = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (ret < 0)\n\t\tgoto aty_init_exit;\n\n\tret = register_framebuffer(info);\n\tif (ret < 0) {\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\tgoto aty_init_exit;\n\t}\n\n\tif (M64_HAS(MOBIL_BUS) && backlight) {\n#ifdef CONFIG_FB_ATY_BACKLIGHT\n\t\taty_bl_init(par);\n#endif\n\t}\n\n\tfb_list = info;\n\n\tPRINTKI(\"fb%d: %s frame buffer device on %s\\n\",\n\t\tinfo->node, info->fix.id, par->bus_type == ISA ? \"ISA\" : \"PCI\");\n\treturn 0;\n\naty_init_exit:\n\t \n\taty_set_crtc(par, &par->saved_crtc);\n\tpar->pll_ops->set_pll(info, &par->saved_pll);\n\tarch_phys_wc_del(par->wc_cookie);\n\n\treturn ret;\n}\n\n#if defined(CONFIG_ATARI) && !defined(MODULE)\nstatic int store_video_par(char *video_str, unsigned char m64_num)\n{\n\tchar *p;\n\tunsigned long vmembase, size, guiregbase;\n\n\tPRINTKI(\"store_video_par() '%s' \\n\", video_str);\n\n\tif (!(p = strsep(&video_str, \";\")) || !*p)\n\t\tgoto mach64_invalid;\n\tvmembase = simple_strtoul(p, NULL, 0);\n\tif (!(p = strsep(&video_str, \";\")) || !*p)\n\t\tgoto mach64_invalid;\n\tsize = simple_strtoul(p, NULL, 0);\n\tif (!(p = strsep(&video_str, \";\")) || !*p)\n\t\tgoto mach64_invalid;\n\tguiregbase = simple_strtoul(p, NULL, 0);\n\n\tphys_vmembase[m64_num] = vmembase;\n\tphys_size[m64_num] = size;\n\tphys_guiregbase[m64_num] = guiregbase;\n\tPRINTKI(\"stored them all: $%08lX $%08lX $%08lX \\n\", vmembase, size,\n\t\tguiregbase);\n\treturn 0;\n\n mach64_invalid:\n\tphys_vmembase[m64_num] = 0;\n\treturn -1;\n}\n#endif  \n\n \n\nstatic int atyfb_blank(int blank, struct fb_info *info)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 gen_cntl;\n\n\tif (par->lock_blank || par->asleep)\n\t\treturn 0;\n\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tif (par->lcd_table && blank > FB_BLANK_NORMAL &&\n\t    (aty_ld_lcd(LCD_GEN_CNTL, par) & LCD_ON)) {\n\t\tu32 pm = aty_ld_lcd(POWER_MANAGEMENT, par);\n\t\tpm &= ~PWR_BLON;\n\t\taty_st_lcd(POWER_MANAGEMENT, pm, par);\n\t}\n#endif\n\n\tgen_cntl = aty_ld_le32(CRTC_GEN_CNTL, par);\n\tgen_cntl &= ~0x400004c;\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\tgen_cntl |= 0x4000040;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tgen_cntl |= 0x4000048;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tgen_cntl |= 0x4000044;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tgen_cntl |= 0x400004c;\n\t\tbreak;\n\t}\n\taty_st_le32(CRTC_GEN_CNTL, gen_cntl, par);\n\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tif (par->lcd_table && blank <= FB_BLANK_NORMAL &&\n\t    (aty_ld_lcd(LCD_GEN_CNTL, par) & LCD_ON)) {\n\t\tu32 pm = aty_ld_lcd(POWER_MANAGEMENT, par);\n\t\tpm |= PWR_BLON;\n\t\taty_st_lcd(POWER_MANAGEMENT, pm, par);\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic void aty_st_pal(u_int regno, u_int red, u_int green, u_int blue,\n\t\t       const struct atyfb_par *par)\n{\n\taty_st_8(DAC_W_INDEX, regno, par);\n\taty_st_8(DAC_DATA, red, par);\n\taty_st_8(DAC_DATA, green, par);\n\taty_st_8(DAC_DATA, blue, par);\n}\n\n \n\nstatic int atyfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t   u_int transp, struct fb_info *info)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tint i, depth;\n\tu32 *pal = info->pseudo_palette;\n\n\tdepth = info->var.bits_per_pixel;\n\tif (depth == 16)\n\t\tdepth = (info->var.green.length == 5) ? 15 : 16;\n\n\tif (par->asleep)\n\t\treturn 0;\n\n\tif (regno > 255 ||\n\t    (depth == 16 && regno > 63) ||\n\t    (depth == 15 && regno > 31))\n\t\treturn 1;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\tpar->palette[regno].red = red;\n\tpar->palette[regno].green = green;\n\tpar->palette[regno].blue = blue;\n\n\tif (regno < 16) {\n\t\tswitch (depth) {\n\t\tcase 15:\n\t\t\tpal[regno] = (regno << 10) | (regno << 5) | regno;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tpal[regno] = (regno << 11) | (regno << 5) | regno;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tpal[regno] = (regno << 16) | (regno << 8) | regno;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\ti = (regno << 8) | regno;\n\t\t\tpal[regno] = (i << 16) | i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ti = aty_ld_8(DAC_CNTL, par) & 0xfc;\n\tif (M64_HAS(EXTRA_BRIGHT))\n\t\ti |= 0x2;  \n\taty_st_8(DAC_CNTL, i, par);\n\taty_st_8(DAC_MASK, 0xff, par);\n\n\tif (M64_HAS(INTEGRATED)) {\n\t\tif (depth == 16) {\n\t\t\tif (regno < 32)\n\t\t\t\taty_st_pal(regno << 3, red,\n\t\t\t\t\t   par->palette[regno << 1].green,\n\t\t\t\t\t   blue, par);\n\t\t\tred = par->palette[regno >> 1].red;\n\t\t\tblue = par->palette[regno >> 1].blue;\n\t\t\tregno <<= 2;\n\t\t} else if (depth == 15) {\n\t\t\tregno <<= 3;\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\taty_st_pal(regno + i, red, green, blue, par);\n\t\t}\n\t}\n\taty_st_pal(regno, red, green, blue, par);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PCI\n\n#ifdef __sparc__\n\nstatic int atyfb_setup_sparc(struct pci_dev *pdev, struct fb_info *info,\n\t\t\t     unsigned long addr)\n{\n\tstruct atyfb_par *par = info->par;\n\tstruct device_node *dp;\n\tu32 mem, chip_id;\n\tint i, j, ret;\n\n\t \n\tpar->ati_regbase = (void *)addr + 0x7ffc00UL;\n\tinfo->fix.mmio_start = addr + 0x7ffc00UL;\n\n\t \n\tinfo->screen_base = (char *) (addr + 0x800000UL);\n\tinfo->fix.smem_start = addr + 0x800000UL;\n\n\t \n\tfor (i = 0; i < 6 && pdev->resource[i].start; i++)\n\t\t  ;\n\tj = i + 4;\n\n\tpar->mmap_map = kcalloc(j, sizeof(*par->mmap_map), GFP_ATOMIC);\n\tif (!par->mmap_map) {\n\t\tPRINTKE(\"atyfb_setup_sparc() can't alloc mmap_map\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0, j = 2; i < 6 && pdev->resource[i].start; i++) {\n\t\tstruct resource *rp = &pdev->resource[i];\n\t\tint io, breg = PCI_BASE_ADDRESS_0 + (i << 2);\n\t\tunsigned long base;\n\t\tu32 size, pbase;\n\n\t\tbase = rp->start;\n\n\t\tio = (rp->flags & IORESOURCE_IO);\n\n\t\tsize = rp->end - base + 1;\n\n\t\tpci_read_config_dword(pdev, breg, &pbase);\n\n\t\tif (io)\n\t\t\tsize &= ~1;\n\n\t\t \n\t\tif (base == addr) {\n\t\t\tpar->mmap_map[j].voff = (pbase + 0x10000000) & PAGE_MASK;\n\t\t\tpar->mmap_map[j].poff = base & PAGE_MASK;\n\t\t\tpar->mmap_map[j].size = (size + ~PAGE_MASK) & PAGE_MASK;\n\t\t\tpar->mmap_map[j].prot_mask = _PAGE_CACHE;\n\t\t\tpar->mmap_map[j].prot_flag = _PAGE_E;\n\t\t\tj++;\n\t\t}\n\n\t\t \n\t\tif (base == addr) {\n\t\t\tpar->mmap_map[j].voff = (pbase + 0x800000) & PAGE_MASK;\n\t\t\tpar->mmap_map[j].poff = (base + 0x800000) & PAGE_MASK;\n\t\t\tpar->mmap_map[j].size = 0x800000;\n\t\t\tpar->mmap_map[j].prot_mask = _PAGE_CACHE;\n\t\t\tpar->mmap_map[j].prot_flag = _PAGE_E | _PAGE_IE;\n\t\t\tsize -= 0x800000;\n\t\t\tj++;\n\t\t}\n\n\t\tpar->mmap_map[j].voff = pbase & PAGE_MASK;\n\t\tpar->mmap_map[j].poff = base & PAGE_MASK;\n\t\tpar->mmap_map[j].size = (size + ~PAGE_MASK) & PAGE_MASK;\n\t\tpar->mmap_map[j].prot_mask = _PAGE_CACHE;\n\t\tpar->mmap_map[j].prot_flag = _PAGE_E;\n\t\tj++;\n\t}\n\n\tret = correct_chipset(par);\n\tif (ret)\n\t\treturn ret;\n\n\tif (IS_XL(pdev->device)) {\n\t\t \n\t\tmem = aty_ld_le32(MEM_CNTL, par);\n\t\tchip_id = aty_ld_le32(CNFG_CHIP_ID, par);\n\t\tif (((chip_id & CFG_CHIP_TYPE) == VT_CHIP_ID) && !((chip_id >> 24) & 1)) {\n\t\t\tswitch (mem & 0x0f) {\n\t\t\tcase 3:\n\t\t\t\tmem = (mem & ~(0x0f)) | 2;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tmem = (mem & ~(0x0f)) | 3;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tmem = (mem & ~(0x0f)) | 4;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tmem = (mem & ~(0x0f)) | 5;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((aty_ld_le32(CNFG_STAT0, par) & 7) >= SDRAM)\n\t\t\t\tmem &= ~(0x00700000);\n\t\t}\n\t\tmem &= ~(0xcf80e000);\t \n\t\taty_st_le32(MEM_CNTL, mem, par);\n\t}\n\n\tdp = pci_device_to_OF_node(pdev);\n\tif (dp == of_console_device) {\n\t\tstruct fb_var_screeninfo *var = &default_var;\n\t\tunsigned int N, P, Q, M, T, R;\n\t\tstruct crtc crtc;\n\t\tu8 pll_regs[16];\n\t\tu8 clock_cntl;\n\n\t\tcrtc.vxres = of_getintprop_default(dp, \"width\", 1024);\n\t\tcrtc.vyres = of_getintprop_default(dp, \"height\", 768);\n\t\tvar->bits_per_pixel = of_getintprop_default(dp, \"depth\", 8);\n\t\tvar->xoffset = var->yoffset = 0;\n\t\tcrtc.h_tot_disp = aty_ld_le32(CRTC_H_TOTAL_DISP, par);\n\t\tcrtc.h_sync_strt_wid = aty_ld_le32(CRTC_H_SYNC_STRT_WID, par);\n\t\tcrtc.v_tot_disp = aty_ld_le32(CRTC_V_TOTAL_DISP, par);\n\t\tcrtc.v_sync_strt_wid = aty_ld_le32(CRTC_V_SYNC_STRT_WID, par);\n\t\tcrtc.gen_cntl = aty_ld_le32(CRTC_GEN_CNTL, par);\n\t\taty_crtc_to_var(&crtc, var);\n\n\t\t \n\t\tclock_cntl = aty_ld_8(CLOCK_CNTL, par);\n\t\t \n\t\tfor (i = 0; i < 16; i++)\n\t\t\tpll_regs[i] = aty_ld_pll_ct(i, par);\n\n\t\t \n\t\tM = pll_regs[PLL_REF_DIV];\n\n\t\t \n\t\tN = pll_regs[VCLK0_FB_DIV + (clock_cntl & 3)];\n\n\t\t \n\t\tP = aty_postdividers[((pll_regs[VCLK_POST_DIV] >> ((clock_cntl & 3) << 1)) & 3) |\n\t\t                     ((pll_regs[PLL_EXT_CNTL] >> (2 + (clock_cntl & 3))) & 4)];\n\n\t\t \n\t\tQ = N / P;\n\n\t\t \n\t\tif (IS_XL(pdev->device))\n\t\t\tR = 29498;\n\t\telse\n\t\t\tR = 14318;\n\n\t\tT = 2 * Q * R / M;\n\n\t\tdefault_var.pixclock = 1000000000 / T;\n\t}\n\n\treturn 0;\n}\n\n#else  \n\n#ifdef __i386__\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\nstatic void aty_init_lcd(struct atyfb_par *par, u32 bios_base)\n{\n\tu32 driv_inf_tab, sig;\n\tu16 lcd_ofs;\n\n\t \n\t \n\tdriv_inf_tab = bios_base + *((u16 *)(bios_base+0x78));\n\n\t \n\tsig = *(u32 *)driv_inf_tab;\n\tif ((sig == 0x54504c24) ||  \n\t    (sig == 0x544d5224) ||  \n\t    (sig == 0x54435824) ||  \n\t    (sig == 0x544c5824)) {  \n\t\tPRINTKI(\"BIOS contains driver information table.\\n\");\n\t\tlcd_ofs = *(u16 *)(driv_inf_tab + 10);\n\t\tpar->lcd_table = 0;\n\t\tif (lcd_ofs != 0)\n\t\t\tpar->lcd_table = bios_base + lcd_ofs;\n\t}\n\n\tif (par->lcd_table != 0) {\n\t\tchar model[24];\n\t\tchar strbuf[16];\n\t\tchar refresh_rates_buf[100];\n\t\tint id, tech, f, i, m, default_refresh_rate;\n\t\tchar *txtcolour;\n\t\tchar *txtmonitor;\n\t\tchar *txtdual;\n\t\tchar *txtformat;\n\t\tu16 width, height, panel_type, refresh_rates;\n\t\tu16 *lcdmodeptr;\n\t\tu32 format;\n\t\tu8 lcd_refresh_rates[16] = { 50, 56, 60, 67, 70, 72, 75, 76, 85,\n\t\t\t\t\t     90, 100, 120, 140, 150, 160, 200 };\n\t\t \n\t\tid = *(u8 *)par->lcd_table;\n\t\tstrscpy(model, (char *)par->lcd_table+1, sizeof(model));\n\n\t\twidth = par->lcd_width = *(u16 *)(par->lcd_table+25);\n\t\theight = par->lcd_height = *(u16 *)(par->lcd_table+27);\n\t\tpanel_type = *(u16 *)(par->lcd_table+29);\n\t\tif (panel_type & 1)\n\t\t\ttxtcolour = \"colour\";\n\t\telse\n\t\t\ttxtcolour = \"monochrome\";\n\t\tif (panel_type & 2)\n\t\t\ttxtdual = \"dual (split) \";\n\t\telse\n\t\t\ttxtdual = \"\";\n\t\ttech = (panel_type >> 2) & 63;\n\t\tswitch (tech) {\n\t\tcase 0:\n\t\t\ttxtmonitor = \"passive matrix\";\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttxtmonitor = \"active matrix\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttxtmonitor = \"active addressed STN\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttxtmonitor = \"EL\";\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttxtmonitor = \"plasma\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttxtmonitor = \"unknown\";\n\t\t}\n\t\tformat = *(u32 *)(par->lcd_table+57);\n\t\tif (tech == 0 || tech == 2) {\n\t\t\tswitch (format & 7) {\n\t\t\tcase 0:\n\t\t\t\ttxtformat = \"12 bit interface\";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttxtformat = \"16 bit interface\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttxtformat = \"24 bit interface\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttxtformat = \"unknown format\";\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (format & 7) {\n\t\t\tcase 0:\n\t\t\t\ttxtformat = \"8 colours\";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttxtformat = \"512 colours\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttxtformat = \"4096 colours\";\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\ttxtformat = \"262144 colours (LT mode)\";\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\ttxtformat = \"16777216 colours\";\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ttxtformat = \"262144 colours (FDPI-2 mode)\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttxtformat = \"unknown format\";\n\t\t\t}\n\t\t}\n\t\tPRINTKI(\"%s%s %s monitor detected: %s\\n\",\n\t\t\ttxtdual, txtcolour, txtmonitor, model);\n\t\tPRINTKI(\"       id=%d, %dx%d pixels, %s\\n\",\n\t\t\tid, width, height, txtformat);\n\t\trefresh_rates_buf[0] = 0;\n\t\trefresh_rates = *(u16 *)(par->lcd_table+62);\n\t\tm = 1;\n\t\tf = 0;\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tif (refresh_rates & m) {\n\t\t\t\tif (f == 0) {\n\t\t\t\t\tsprintf(strbuf, \"%d\",\n\t\t\t\t\t\tlcd_refresh_rates[i]);\n\t\t\t\t\tf++;\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(strbuf, \",%d\",\n\t\t\t\t\t\tlcd_refresh_rates[i]);\n\t\t\t\t}\n\t\t\t\tstrcat(refresh_rates_buf, strbuf);\n\t\t\t}\n\t\t\tm = m << 1;\n\t\t}\n\t\tdefault_refresh_rate = (*(u8 *)(par->lcd_table+61) & 0xf0) >> 4;\n\t\tPRINTKI(\"       supports refresh rates [%s], default %d Hz\\n\",\n\t\t\trefresh_rates_buf, lcd_refresh_rates[default_refresh_rate]);\n\t\tpar->lcd_refreshrate = lcd_refresh_rates[default_refresh_rate];\n\t\t \n\t\tlcdmodeptr = (u16 *)(par->lcd_table + 64);\n\t\twhile (*lcdmodeptr != 0) {\n\t\t\tu32 modeptr;\n\t\t\tu16 mwidth, mheight, lcd_hsync_start, lcd_vsync_start;\n\t\t\tmodeptr = bios_base + *lcdmodeptr;\n\n\t\t\tmwidth = *((u16 *)(modeptr+0));\n\t\t\tmheight = *((u16 *)(modeptr+2));\n\n\t\t\tif (mwidth == width && mheight == height) {\n\t\t\t\tpar->lcd_pixclock = 100000000 / *((u16 *)(modeptr+9));\n\t\t\t\tpar->lcd_htotal = *((u16 *)(modeptr+17)) & 511;\n\t\t\t\tpar->lcd_hdisp = *((u16 *)(modeptr+19)) & 511;\n\t\t\t\tlcd_hsync_start = *((u16 *)(modeptr+21)) & 511;\n\t\t\t\tpar->lcd_hsync_dly = (*((u16 *)(modeptr+21)) >> 9) & 7;\n\t\t\t\tpar->lcd_hsync_len = *((u8 *)(modeptr+23)) & 63;\n\n\t\t\t\tpar->lcd_vtotal = *((u16 *)(modeptr+24)) & 2047;\n\t\t\t\tpar->lcd_vdisp = *((u16 *)(modeptr+26)) & 2047;\n\t\t\t\tlcd_vsync_start = *((u16 *)(modeptr+28)) & 2047;\n\t\t\t\tpar->lcd_vsync_len = (*((u16 *)(modeptr+28)) >> 11) & 31;\n\n\t\t\t\tpar->lcd_htotal = (par->lcd_htotal + 1) * 8;\n\t\t\t\tpar->lcd_hdisp = (par->lcd_hdisp + 1) * 8;\n\t\t\t\tlcd_hsync_start = (lcd_hsync_start + 1) * 8;\n\t\t\t\tpar->lcd_hsync_len = par->lcd_hsync_len * 8;\n\n\t\t\t\tpar->lcd_vtotal++;\n\t\t\t\tpar->lcd_vdisp++;\n\t\t\t\tlcd_vsync_start++;\n\n\t\t\t\tpar->lcd_right_margin = lcd_hsync_start - par->lcd_hdisp;\n\t\t\t\tpar->lcd_lower_margin = lcd_vsync_start - par->lcd_vdisp;\n\t\t\t\tpar->lcd_hblank_len = par->lcd_htotal - par->lcd_hdisp;\n\t\t\t\tpar->lcd_vblank_len = par->lcd_vtotal - par->lcd_vdisp;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlcdmodeptr++;\n\t\t}\n\t\tif (*lcdmodeptr == 0) {\n\t\t\tPRINTKE(\"LCD monitor CRTC parameters not found!!!\\n\");\n\t\t\t \n\t\t} else {\n\t\t\tPRINTKI(\"       LCD CRTC parameters: %d.%d  %d %d %d %d  %d %d %d %d\\n\",\n\t\t\t\t1000000 / par->lcd_pixclock, 1000000 % par->lcd_pixclock,\n\t\t\t\tpar->lcd_hdisp,\n\t\t\t\tpar->lcd_hdisp + par->lcd_right_margin,\n\t\t\t\tpar->lcd_hdisp + par->lcd_right_margin\n\t\t\t\t\t+ par->lcd_hsync_dly + par->lcd_hsync_len,\n\t\t\t\tpar->lcd_htotal,\n\t\t\t\tpar->lcd_vdisp,\n\t\t\t\tpar->lcd_vdisp + par->lcd_lower_margin,\n\t\t\t\tpar->lcd_vdisp + par->lcd_lower_margin + par->lcd_vsync_len,\n\t\t\t\tpar->lcd_vtotal);\n\t\t\tPRINTKI(\"                          : %d %d %d %d %d %d %d %d %d\\n\",\n\t\t\t\tpar->lcd_pixclock,\n\t\t\t\tpar->lcd_hblank_len - (par->lcd_right_margin +\n\t\t\t\t\tpar->lcd_hsync_dly + par->lcd_hsync_len),\n\t\t\t\tpar->lcd_hdisp,\n\t\t\t\tpar->lcd_right_margin,\n\t\t\t\tpar->lcd_hsync_len,\n\t\t\t\tpar->lcd_vblank_len - (par->lcd_lower_margin + par->lcd_vsync_len),\n\t\t\t\tpar->lcd_vdisp,\n\t\t\t\tpar->lcd_lower_margin,\n\t\t\t\tpar->lcd_vsync_len);\n\t\t}\n\t}\n}\n#endif  \n\nstatic int init_from_bios(struct atyfb_par *par)\n{\n\tu32 bios_base, rom_addr;\n\tint ret;\n\n\trom_addr = 0xc0000 + ((aty_ld_le32(SCRATCH_REG1, par) & 0x7f) << 11);\n\tbios_base = (unsigned long)ioremap(rom_addr, 0x10000);\n\n\t \n\tif (*((u16 *)bios_base) == 0xaa55) {\n\n\t\tu8 *bios_ptr;\n\t\tu16 rom_table_offset, freq_table_offset;\n\t\tPLL_BLOCK_MACH64 pll_block;\n\n\t\tPRINTKI(\"Mach64 BIOS is located at %x, mapped at %x.\\n\", rom_addr, bios_base);\n\n\t\t \n\t\tbios_ptr = (u8*)bios_base;\n\t\trom_table_offset = (u16)(bios_ptr[0x48] | (bios_ptr[0x49] << 8));\n\t\tfreq_table_offset = bios_ptr[rom_table_offset + 16] | (bios_ptr[rom_table_offset + 17] << 8);\n\t\tmemcpy(&pll_block, bios_ptr + freq_table_offset, sizeof(PLL_BLOCK_MACH64));\n\n\t\tPRINTKI(\"BIOS frequency table:\\n\");\n\t\tPRINTKI(\"PCLK_min_freq %d, PCLK_max_freq %d, ref_freq %d, ref_divider %d\\n\",\n\t\t\tpll_block.PCLK_min_freq, pll_block.PCLK_max_freq,\n\t\t\tpll_block.ref_freq, pll_block.ref_divider);\n\t\tPRINTKI(\"MCLK_pwd %d, MCLK_max_freq %d, XCLK_max_freq %d, SCLK_freq %d\\n\",\n\t\t\tpll_block.MCLK_pwd, pll_block.MCLK_max_freq,\n\t\t\tpll_block.XCLK_max_freq, pll_block.SCLK_freq);\n\n\t\tpar->pll_limits.pll_min = pll_block.PCLK_min_freq/100;\n\t\tpar->pll_limits.pll_max = pll_block.PCLK_max_freq/100;\n\t\tpar->pll_limits.ref_clk = pll_block.ref_freq/100;\n\t\tpar->pll_limits.ref_div = pll_block.ref_divider;\n\t\tpar->pll_limits.sclk = pll_block.SCLK_freq/100;\n\t\tpar->pll_limits.mclk = pll_block.MCLK_max_freq/100;\n\t\tpar->pll_limits.mclk_pm = pll_block.MCLK_pwd/100;\n\t\tpar->pll_limits.xclk = pll_block.XCLK_max_freq/100;\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\t\taty_init_lcd(par, bios_base);\n#endif\n\t\tret = 0;\n\t} else {\n\t\tPRINTKE(\"no BIOS frequency table found, use parameters\\n\");\n\t\tret = -ENXIO;\n\t}\n\tiounmap((void __iomem *)bios_base);\n\n\treturn ret;\n}\n#endif  \n\nstatic int atyfb_setup_generic(struct pci_dev *pdev, struct fb_info *info,\n\t\t\t       unsigned long addr)\n{\n\tstruct atyfb_par *par = info->par;\n\tu16 tmp;\n\tunsigned long raddr;\n\tstruct resource *rrp;\n\tint ret = 0;\n\n\traddr = addr + 0x7ff000UL;\n\trrp = &pdev->resource[2];\n\tif ((rrp->flags & IORESOURCE_MEM) &&\n\t    request_mem_region(rrp->start, resource_size(rrp), \"atyfb\")) {\n\t\tpar->aux_start = rrp->start;\n\t\tpar->aux_size = resource_size(rrp);\n\t\traddr = rrp->start;\n\t\tPRINTKI(\"using auxiliary register aperture\\n\");\n\t}\n\n\tinfo->fix.mmio_start = raddr;\n#if defined(__i386__) || defined(__ia64__)\n\t \n\tpar->ati_regbase = ioremap_uc(info->fix.mmio_start, 0x1000);\n#else\n\tpar->ati_regbase = ioremap(info->fix.mmio_start, 0x1000);\n#endif\n\tif (par->ati_regbase == NULL)\n\t\treturn -ENOMEM;\n\n\tinfo->fix.mmio_start += par->aux_start ? 0x400 : 0xc00;\n\tpar->ati_regbase += par->aux_start ? 0x400 : 0xc00;\n\n\t \n\tpci_read_config_word(pdev, PCI_COMMAND, &tmp);\n\tif (!(tmp & PCI_COMMAND_MEMORY)) {\n\t\ttmp |= PCI_COMMAND_MEMORY;\n\t\tpci_write_config_word(pdev, PCI_COMMAND, tmp);\n\t}\n#ifdef __BIG_ENDIAN\n\t \n\taddr += 0x800000;\n#endif\n\n\t \n\tinfo->fix.smem_start = addr;\n\n\t \n\tinfo->fix.smem_len = 0x800000;\n\n\taty_fudge_framebuffer_len(info);\n\n\tinfo->screen_base = ioremap_wc(info->fix.smem_start,\n\t\t\t\t       info->fix.smem_len);\n\tif (info->screen_base == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto atyfb_setup_generic_fail;\n\t}\n\n\tret = correct_chipset(par);\n\tif (ret)\n\t\tgoto atyfb_setup_generic_fail;\n#ifdef __i386__\n\tret = init_from_bios(par);\n\tif (ret)\n\t\tgoto atyfb_setup_generic_fail;\n#endif\n\t \n\tpar->clk_wr_offset = 3;\n\n\treturn 0;\n\natyfb_setup_generic_fail:\n\tiounmap(par->ati_regbase);\n\tpar->ati_regbase = NULL;\n\tif (info->screen_base) {\n\t\tiounmap(info->screen_base);\n\t\tinfo->screen_base = NULL;\n\t}\n\treturn ret;\n}\n\n#endif  \n\nstatic int atyfb_pci_probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tunsigned long addr, res_start, res_size;\n\tstruct fb_info *info;\n\tstruct resource *rp;\n\tstruct atyfb_par *par;\n\tint rc;\n\n\trc = aperture_remove_conflicting_pci_devices(pdev, \"atyfb\");\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (pci_enable_device(pdev)) {\n\t\tPRINTKE(\"Cannot enable PCI device\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\trp = &pdev->resource[0];\n\tif (rp->flags & IORESOURCE_IO)\n\t\trp = &pdev->resource[1];\n\taddr = rp->start;\n\tif (!addr)\n\t\treturn -ENXIO;\n\n\t \n\tres_start = rp->start;\n\tres_size = resource_size(rp);\n\tif (!request_mem_region(res_start, res_size, \"atyfb\"))\n\t\treturn -EBUSY;\n\n\t \n\tinfo = framebuffer_alloc(sizeof(struct atyfb_par), &pdev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tpar->bus_type = PCI;\n\tinfo->fix = atyfb_fix;\n\tinfo->device = &pdev->dev;\n\tpar->pci_id = pdev->device;\n\tpar->res_start = res_start;\n\tpar->res_size = res_size;\n\tpar->irq = pdev->irq;\n\tpar->pdev = pdev;\n\n\t \n#ifdef __sparc__\n\trc = atyfb_setup_sparc(pdev, info, addr);\n#else\n\trc = atyfb_setup_generic(pdev, info, addr);\n#endif\n\tif (rc)\n\t\tgoto err_release_mem;\n\n\tpci_set_drvdata(pdev, info);\n\n\t \n\trc = aty_init(info);\n\tif (rc)\n\t\tgoto err_release_io;\n\n#ifdef __sparc__\n\t \n\tpar->mmap_map[0].voff = 0x8000000000000000UL;\n\tpar->mmap_map[0].poff = (unsigned long) info->screen_base & PAGE_MASK;\n\tpar->mmap_map[0].size = info->fix.smem_len;\n\tpar->mmap_map[0].prot_mask = _PAGE_CACHE;\n\tpar->mmap_map[0].prot_flag = _PAGE_E;\n\tpar->mmap_map[1].voff = par->mmap_map[0].voff + info->fix.smem_len;\n\tpar->mmap_map[1].poff = (long)par->ati_regbase & PAGE_MASK;\n\tpar->mmap_map[1].size = PAGE_SIZE;\n\tpar->mmap_map[1].prot_mask = _PAGE_CACHE;\n\tpar->mmap_map[1].prot_flag = _PAGE_E;\n#endif  \n\n\tmutex_lock(&reboot_lock);\n\tif (!reboot_info)\n\t\treboot_info = info;\n\tmutex_unlock(&reboot_lock);\n\n\treturn 0;\n\nerr_release_io:\n#ifdef __sparc__\n\tkfree(par->mmap_map);\n#else\n\tif (par->ati_regbase)\n\t\tiounmap(par->ati_regbase);\n\tif (info->screen_base)\n\t\tiounmap(info->screen_base);\n#endif\nerr_release_mem:\n\tif (par->aux_start)\n\t\trelease_mem_region(par->aux_start, par->aux_size);\n\n\trelease_mem_region(par->res_start, par->res_size);\n\tframebuffer_release(info);\n\n\treturn rc;\n}\n\n#endif  \n\n#ifdef CONFIG_ATARI\n\nstatic int __init atyfb_atari_probe(void)\n{\n\tstruct atyfb_par *par;\n\tstruct fb_info *info;\n\tint m64_num;\n\tu32 clock_r;\n\tint num_found = 0;\n\n\tfor (m64_num = 0; m64_num < mach64_count; m64_num++) {\n\t\tif (!phys_vmembase[m64_num] || !phys_size[m64_num] ||\n\t\t    !phys_guiregbase[m64_num]) {\n\t\t\tPRINTKI(\"phys_*[%d] parameters not set => \"\n\t\t\t\t\"returning early. \\n\", m64_num);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinfo = framebuffer_alloc(sizeof(struct atyfb_par), NULL);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\n\t\tpar = info->par;\n\n\t\tinfo->fix = atyfb_fix;\n\n\t\tpar->irq = (unsigned int) -1;  \n\n\t\t \n\t\tinfo->screen_base = ioremap_wc(phys_vmembase[m64_num],\n\t\t\t\t\t       phys_size[m64_num]);\n\t\tinfo->fix.smem_start = (unsigned long)info->screen_base;  \n\t\tpar->ati_regbase = ioremap(phys_guiregbase[m64_num], 0x10000) +\n\t\t\t\t\t\t0xFC00ul;\n\t\tinfo->fix.mmio_start = (unsigned long)par->ati_regbase;  \n\n\t\taty_st_le32(CLOCK_CNTL, 0x12345678, par);\n\t\tclock_r = aty_ld_le32(CLOCK_CNTL, par);\n\n\t\tswitch (clock_r & 0x003F) {\n\t\tcase 0x12:\n\t\t\tpar->clk_wr_offset = 3;  \n\t\t\tbreak;\n\t\tcase 0x34:\n\t\t\tpar->clk_wr_offset = 2;  \n\t\t\tbreak;\n\t\tcase 0x16:\n\t\t\tpar->clk_wr_offset = 1;  \n\t\t\tbreak;\n\t\tcase 0x38:\n\t\t\tpar->clk_wr_offset = 0;  \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tswitch (aty_ld_le32(CNFG_CHIP_ID, par) & CFG_CHIP_TYPE) {\n\t\tcase 0x00d7:\n\t\t\tpar->pci_id = PCI_CHIP_MACH64GX;\n\t\t\tbreak;\n\t\tcase 0x0057:\n\t\t\tpar->pci_id = PCI_CHIP_MACH64CX;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (correct_chipset(par) || aty_init(info)) {\n\t\t\tiounmap(info->screen_base);\n\t\t\tiounmap(par->ati_regbase);\n\t\t\tframebuffer_release(info);\n\t\t} else {\n\t\t\tnum_found++;\n\t\t}\n\t}\n\n\treturn num_found ? 0 : -ENXIO;\n}\n\n#endif  \n\n#ifdef CONFIG_PCI\n\nstatic void atyfb_remove(struct fb_info *info)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\n\t \n\taty_set_crtc(par, &par->saved_crtc);\n\tpar->pll_ops->set_pll(info, &par->saved_pll);\n\n#ifdef CONFIG_FB_ATY_BACKLIGHT\n\tif (M64_HAS(MOBIL_BUS))\n\t\taty_bl_exit(info->bl_dev);\n#endif\n\n\tunregister_framebuffer(info);\n\n\tarch_phys_wc_del(par->wc_cookie);\n\n#ifndef __sparc__\n\tif (par->ati_regbase)\n\t\tiounmap(par->ati_regbase);\n\tif (info->screen_base)\n\t\tiounmap(info->screen_base);\n#ifdef __BIG_ENDIAN\n\tif (info->sprite.addr)\n\t\tiounmap(info->sprite.addr);\n#endif\n#endif\n#ifdef __sparc__\n\tkfree(par->mmap_map);\n#endif\n\tif (par->aux_start)\n\t\trelease_mem_region(par->aux_start, par->aux_size);\n\n\tif (par->res_start)\n\t\trelease_mem_region(par->res_start, par->res_size);\n\n\tframebuffer_release(info);\n}\n\n\nstatic void atyfb_pci_remove(struct pci_dev *pdev)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\n\tmutex_lock(&reboot_lock);\n\tif (reboot_info == info)\n\t\treboot_info = NULL;\n\tmutex_unlock(&reboot_lock);\n\n\tatyfb_remove(info);\n}\n\nstatic const struct pci_device_id atyfb_pci_tbl[] = {\n#ifdef CONFIG_FB_ATY_GX\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GX) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64CX) },\n#endif  \n\n#ifdef CONFIG_FB_ATY_CT\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64CT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64ET) },\n\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64LT) },\n\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64VT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GT) },\n\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64VU) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GU) },\n\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64LG) },\n\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64VV) },\n\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GV) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GW) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GY) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GZ) },\n\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GB) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GD) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GI) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GP) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GQ) },\n\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64LB) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64LD) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64LI) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64LP) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64LQ) },\n\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GM) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GN) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GO) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GL) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GR) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64GS) },\n\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64LM) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64LN) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64LR) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_CHIP_MACH64LS) },\n#endif  \n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, atyfb_pci_tbl);\n\nstatic struct pci_driver atyfb_driver = {\n\t.name\t\t= \"atyfb\",\n\t.id_table\t= atyfb_pci_tbl,\n\t.probe\t\t= atyfb_pci_probe,\n\t.remove\t\t= atyfb_pci_remove,\n\t.driver.pm\t= &atyfb_pci_pm_ops,\n};\n\n#endif  \n\n#ifndef MODULE\nstatic int __init atyfb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!strncmp(this_opt, \"noaccel\", 7)) {\n\t\t\tnoaccel = true;\n\t\t} else if (!strncmp(this_opt, \"nomtrr\", 6)) {\n\t\t\tnomtrr = true;\n\t\t} else if (!strncmp(this_opt, \"vram:\", 5))\n\t\t\tvram = simple_strtoul(this_opt + 5, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"pll:\", 4))\n\t\t\tpll = simple_strtoul(this_opt + 4, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"mclk:\", 5))\n\t\t\tmclk = simple_strtoul(this_opt + 5, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"xclk:\", 5))\n\t\t\txclk = simple_strtoul(this_opt+5, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"comp_sync:\", 10))\n\t\t\tcomp_sync = simple_strtoul(this_opt+10, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"backlight:\", 10))\n\t\t\tbacklight = simple_strtoul(this_opt+10, NULL, 0);\n#ifdef CONFIG_PPC\n\t\telse if (!strncmp(this_opt, \"vmode:\", 6)) {\n\t\t\tunsigned int vmode =\n\t\t\t    simple_strtoul(this_opt + 6, NULL, 0);\n\t\t\tif (vmode > 0 && vmode <= VMODE_MAX)\n\t\t\t\tdefault_vmode = vmode;\n\t\t} else if (!strncmp(this_opt, \"cmode:\", 6)) {\n\t\t\tunsigned int cmode =\n\t\t\t    simple_strtoul(this_opt + 6, NULL, 0);\n\t\t\tswitch (cmode) {\n\t\t\tcase 0:\n\t\t\tcase 8:\n\t\t\t\tdefault_cmode = CMODE_8;\n\t\t\t\tbreak;\n\t\t\tcase 15:\n\t\t\tcase 16:\n\t\t\t\tdefault_cmode = CMODE_16;\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\tcase 32:\n\t\t\t\tdefault_cmode = CMODE_32;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n#ifdef CONFIG_ATARI\n\t\t \n\t\telse if (MACH_IS_ATARI\n\t\t\t && (!strncmp(this_opt, \"Mach64:\", 7))) {\n\t\t\tstatic unsigned char m64_num;\n\t\t\tstatic char mach64_str[80];\n\t\t\tstrscpy(mach64_str, this_opt + 7, sizeof(mach64_str));\n\t\t\tif (!store_video_par(mach64_str, m64_num)) {\n\t\t\t\tm64_num++;\n\t\t\t\tmach64_count = m64_num;\n\t\t\t}\n\t\t}\n#endif\n\t\telse\n\t\t\tmode = this_opt;\n\t}\n\treturn 0;\n}\n#endif   \n\nstatic int atyfb_reboot_notify(struct notifier_block *nb,\n\t\t\t       unsigned long code, void *unused)\n{\n\tstruct atyfb_par *par;\n\n\tif (code != SYS_RESTART)\n\t\treturn NOTIFY_DONE;\n\n\tmutex_lock(&reboot_lock);\n\n\tif (!reboot_info)\n\t\tgoto out;\n\n\tlock_fb_info(reboot_info);\n\n\tpar = reboot_info->par;\n\n\t \n\taty_set_crtc(par, &par->saved_crtc);\n\tpar->pll_ops->set_pll(reboot_info, &par->saved_pll);\n\n\tunlock_fb_info(reboot_info);\n out:\n\tmutex_unlock(&reboot_lock);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block atyfb_reboot_notifier = {\n\t.notifier_call = atyfb_reboot_notify,\n};\n\nstatic const struct dmi_system_id atyfb_reboot_ids[] __initconst = {\n\t{\n\t\t.ident = \"HP OmniBook 500\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP OmniBook PC\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"HP OmniBook 500 FA\"),\n\t\t},\n\t},\n\n\t{ }\n};\nstatic bool registered_notifier = false;\n\nstatic int __init atyfb_init(void)\n{\n\tint err1 = 1, err2 = 1;\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"atyfb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"atyfb\", &option))\n\t\treturn -ENODEV;\n\tatyfb_setup(option);\n#endif\n\n#ifdef CONFIG_PCI\n\terr1 = pci_register_driver(&atyfb_driver);\n#endif\n#ifdef CONFIG_ATARI\n\terr2 = atyfb_atari_probe();\n#endif\n\n\tif (err1 && err2)\n\t\treturn -ENODEV;\n\n\tif (dmi_check_system(atyfb_reboot_ids)) {\n\t\tregister_reboot_notifier(&atyfb_reboot_notifier);\n\t\tregistered_notifier = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit atyfb_exit(void)\n{\n\tif (registered_notifier)\n\t\tunregister_reboot_notifier(&atyfb_reboot_notifier);\n\n#ifdef CONFIG_PCI\n\tpci_unregister_driver(&atyfb_driver);\n#endif\n}\n\nmodule_init(atyfb_init);\nmodule_exit(atyfb_exit);\n\nMODULE_DESCRIPTION(\"FBDev driver for ATI Mach64 cards\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(noaccel, bool, 0);\nMODULE_PARM_DESC(noaccel, \"bool: disable acceleration\");\nmodule_param(vram, int, 0);\nMODULE_PARM_DESC(vram, \"int: override size of video ram\");\nmodule_param(pll, int, 0);\nMODULE_PARM_DESC(pll, \"int: override video clock\");\nmodule_param(mclk, int, 0);\nMODULE_PARM_DESC(mclk, \"int: override memory clock\");\nmodule_param(xclk, int, 0);\nMODULE_PARM_DESC(xclk, \"int: override accelerated engine clock\");\nmodule_param(comp_sync, int, 0);\nMODULE_PARM_DESC(comp_sync, \"Set composite sync signal to low (0) or high (1)\");\nmodule_param(mode, charp, 0);\nMODULE_PARM_DESC(mode, \"Specify resolution as \\\"<xres>x<yres>[-<bpp>][@<refresh>]\\\" \");\nmodule_param(nomtrr, bool, 0);\nMODULE_PARM_DESC(nomtrr, \"bool: disable use of MTRR registers\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}