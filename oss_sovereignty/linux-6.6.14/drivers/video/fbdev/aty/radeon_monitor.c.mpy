{
  "module_name": "radeon_monitor.c",
  "hash_id": "52ed44c603349e241e95d32575a83284035e21f4f6fc30b848e49e43e66c7158",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/aty/radeon_monitor.c",
  "human_readable_source": "\n#include \"radeonfb.h\"\n\n#include <linux/slab.h>\n\n#include \"../edid.h\"\n\nstatic const struct fb_var_screeninfo radeonfb_default_var = {\n\t.xres\t\t= 640,\n\t.yres\t\t= 480,\n\t.xres_virtual\t= 640,\n\t.yres_virtual\t= 480,\n\t.bits_per_pixel = 8,\n\t.red\t\t= { .length = 8 },\n\t.green\t\t= { .length = 8 },\n\t.blue\t\t= { .length = 8 },\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.pixclock\t= 39721,\n\t.left_margin\t= 40,\n\t.right_margin\t= 24,\n\t.upper_margin\t= 32,\n\t.lower_margin\t= 11,\n\t.hsync_len\t= 96,\n\t.vsync_len\t= 2,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED\n};\n\nstatic char *radeon_get_mon_name(int type)\n{\n\tchar *pret = NULL;\n\n\tswitch (type) {\n\t\tcase MT_NONE:\n\t\t\tpret = \"no\";\n\t\t\tbreak;\n\t\tcase MT_CRT:\n\t\t\tpret = \"CRT\";\n\t\t\tbreak;\n\t\tcase MT_DFP:\n\t\t\tpret = \"DFP\";\n\t\t\tbreak;\n\t\tcase MT_LCD:\n\t\t\tpret = \"LCD\";\n\t\t\tbreak;\n\t\tcase MT_CTV:\n\t\t\tpret = \"CTV\";\n\t\t\tbreak;\n\t\tcase MT_STV:\n\t\t\tpret = \"STV\";\n\t\t\tbreak;\n\t}\n\n\treturn pret;\n}\n\n\n#if defined(CONFIG_PPC) || defined(CONFIG_SPARC)\n \nstatic int radeon_parse_montype_prop(struct device_node *dp, u8 **out_EDID,\n\t\t\t\t     int hdno)\n{\n        static char *propnames[] = { \"DFP,EDID\", \"LCD,EDID\", \"EDID\",\n\t\t\t\t     \"EDID1\", \"EDID2\",  NULL };\n\tconst u8 *pedid = NULL;\n\tconst u8 *pmt = NULL;\n\tu8 *tmp;\n        int i, mt = MT_NONE;  \n\t\n\tpr_debug(\"analyzing OF properties...\\n\");\n\tpmt = of_get_property(dp, \"display-type\", NULL);\n\tif (!pmt)\n\t\treturn MT_NONE;\n\tpr_debug(\"display-type: %s\\n\", pmt);\n\t \n\tif (!strcmp(pmt, \"LCD\") || !strcmp(pmt, \"DFP\"))\n\t\tmt = MT_DFP;\n\telse if (!strcmp(pmt, \"CRT\"))\n\t\tmt = MT_CRT;\n\telse {\n\t\tif (strcmp(pmt, \"NONE\") != 0)\n\t\t\tprintk(KERN_WARNING \"radeonfb: Unknown OF display-type: %s\\n\",\n\t\t\t       pmt);\n\t\treturn MT_NONE;\n\t}\n\n\tfor (i = 0; propnames[i] != NULL; ++i) {\n\t\tpedid = of_get_property(dp, propnames[i], NULL);\n\t\tif (pedid != NULL)\n\t\t\tbreak;\n\t}\n\t \n\tif (pedid == NULL && dp->parent && (hdno != -1))\n\t\tpedid = of_get_property(dp->parent,\n\t\t\t\t(hdno == 0) ? \"EDID1\" : \"EDID2\", NULL);\n\tif (pedid == NULL && dp->parent && (hdno == 0))\n\t\tpedid = of_get_property(dp->parent, \"EDID\", NULL);\n\tif (pedid == NULL)\n\t\treturn mt;\n\n\ttmp = kmemdup(pedid, EDID_LENGTH, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn mt;\n\t*out_EDID = tmp;\n\treturn mt;\n}\n\nstatic int radeon_probe_OF_head(struct radeonfb_info *rinfo, int head_no,\n\t\t\t\tu8 **out_EDID)\n{\n        struct device_node *dp;\n\n\tpr_debug(\"radeon_probe_OF_head\\n\");\n\n        dp = rinfo->of_node;\n        while (dp == NULL)\n\t\treturn MT_NONE;\n\n\tif (rinfo->has_CRTC2) {\n\t\tconst char *pname;\n\t\tint len, second = 0;\n\n\t\tdp = dp->child;\n\t\tdo {\n\t\t\tif (!dp)\n\t\t\t\treturn MT_NONE;\n\t\t\tpname = of_get_property(dp, \"name\", NULL);\n\t\t\tif (!pname)\n\t\t\t\treturn MT_NONE;\n\t\t\tlen = strlen(pname);\n\t\t\tpr_debug(\"head: %s (letter: %c, head_no: %d)\\n\",\n\t\t\t       pname, pname[len-1], head_no);\n\t\t\tif (pname[len-1] == 'A' && head_no == 0) {\n\t\t\t\tint mt = radeon_parse_montype_prop(dp, out_EDID, 0);\n\t\t\t\t \n\t\t\t\tif (mt == MT_DFP && rinfo->is_mobility)\n\t\t\t\t\tmt = MT_LCD;\n\t\t\t\treturn mt;\n\t\t\t} else if (pname[len-1] == 'B' && head_no == 1)\n\t\t\t\treturn radeon_parse_montype_prop(dp, out_EDID, 1);\n\t\t\tsecond = 1;\n\t\t\tdp = dp->sibling;\n\t\t} while(!second);\n\t} else {\n\t\tif (head_no > 0)\n\t\t\treturn MT_NONE;\n\t\treturn radeon_parse_montype_prop(dp, out_EDID, -1);\n\t}\n        return MT_NONE;\n}\n#endif  \n\n\nstatic int radeon_get_panel_info_BIOS(struct radeonfb_info *rinfo)\n{\n\tunsigned long tmp, tmp0;\n\tchar stmp[30];\n\tint i;\n\n\tif (!rinfo->bios_seg)\n\t\treturn 0;\n\n\tif (!(tmp = BIOS_IN16(rinfo->fp_bios_start + 0x40))) {\n\t\tprintk(KERN_ERR \"radeonfb: Failed to detect DFP panel info using BIOS\\n\");\n\t\trinfo->panel_info.pwr_delay = 200;\n\t\treturn 0;\n\t}\n\n\tfor(i=0; i<24; i++)\n\t\tstmp[i] = BIOS_IN8(tmp+i+1);\n\tstmp[24] = 0;\n\tprintk(\"radeonfb: panel ID string: %s\\n\", stmp);\n\trinfo->panel_info.xres = BIOS_IN16(tmp + 25);\n\trinfo->panel_info.yres = BIOS_IN16(tmp + 27);\n\tprintk(\"radeonfb: detected LVDS panel size from BIOS: %dx%d\\n\",\n\t\trinfo->panel_info.xres, rinfo->panel_info.yres);\n\n\trinfo->panel_info.pwr_delay = BIOS_IN16(tmp + 44);\n\tpr_debug(\"BIOS provided panel power delay: %d\\n\", rinfo->panel_info.pwr_delay);\n\tif (rinfo->panel_info.pwr_delay > 2000 || rinfo->panel_info.pwr_delay <= 0)\n\t\trinfo->panel_info.pwr_delay = 2000;\n\n\t \n\trinfo->panel_info.ref_divider = BIOS_IN16(tmp + 46);\n\trinfo->panel_info.post_divider = BIOS_IN8(tmp + 48);\n\trinfo->panel_info.fbk_divider = BIOS_IN16(tmp + 49);\n\tif (rinfo->panel_info.ref_divider != 0 &&\n\t    rinfo->panel_info.fbk_divider > 3) {\n\t\trinfo->panel_info.use_bios_dividers = 1;\n\t\tprintk(KERN_INFO \"radeondb: BIOS provided dividers will be used\\n\");\n\t\tpr_debug(\"ref_divider = %x\\n\", rinfo->panel_info.ref_divider);\n\t\tpr_debug(\"post_divider = %x\\n\", rinfo->panel_info.post_divider);\n\t\tpr_debug(\"fbk_divider = %x\\n\", rinfo->panel_info.fbk_divider);\n\t}\n\tpr_debug(\"Scanning BIOS table ...\\n\");\n\tfor(i=0; i<32; i++) {\n\t\ttmp0 = BIOS_IN16(tmp+64+i*2);\n\t\tif (tmp0 == 0)\n\t\t\tbreak;\n\t\tpr_debug(\" %d x %d\\n\", BIOS_IN16(tmp0), BIOS_IN16(tmp0+2));\n\t\tif ((BIOS_IN16(tmp0) == rinfo->panel_info.xres) &&\n\t\t    (BIOS_IN16(tmp0+2) == rinfo->panel_info.yres)) {\n\t\t\trinfo->panel_info.hblank = (BIOS_IN16(tmp0+17) - BIOS_IN16(tmp0+19)) * 8;\n\t\t\trinfo->panel_info.hOver_plus = ((BIOS_IN16(tmp0+21) -\n\t\t\t\t\t\t\t BIOS_IN16(tmp0+19) -1) * 8) & 0x7fff;\n\t\t\trinfo->panel_info.hSync_width = BIOS_IN8(tmp0+23) * 8;\n\t\t\trinfo->panel_info.vblank = BIOS_IN16(tmp0+24) - BIOS_IN16(tmp0+26);\n\t\t\trinfo->panel_info.vOver_plus = (BIOS_IN16(tmp0+28) & 0x7ff) - BIOS_IN16(tmp0+26);\n\t\t\trinfo->panel_info.vSync_width = (BIOS_IN16(tmp0+28) & 0xf800) >> 11;\n\t\t\trinfo->panel_info.clock = BIOS_IN16(tmp0+9);\n\t\t\t \n\t\t\trinfo->panel_info.hAct_high = 1;\n\t\t\trinfo->panel_info.vAct_high = 1;\n\t\t\t \n\t\t\trinfo->panel_info.valid = 1;\n\n\t\t\tpr_debug(\"Found panel in BIOS table:\\n\");\n\t\t\tpr_debug(\"  hblank: %d\\n\", rinfo->panel_info.hblank);\n\t\t\tpr_debug(\"  hOver_plus: %d\\n\", rinfo->panel_info.hOver_plus);\n\t\t\tpr_debug(\"  hSync_width: %d\\n\", rinfo->panel_info.hSync_width);\n\t\t\tpr_debug(\"  vblank: %d\\n\", rinfo->panel_info.vblank);\n\t\t\tpr_debug(\"  vOver_plus: %d\\n\", rinfo->panel_info.vOver_plus);\n\t\t\tpr_debug(\"  vSync_width: %d\\n\", rinfo->panel_info.vSync_width);\n\t\t\tpr_debug(\"  clock: %d\\n\", rinfo->panel_info.clock);\n\t\t\t\t\n\t\t\treturn 1;\n\t\t}\n\t}\n\tpr_debug(\"Didn't find panel in BIOS table !\\n\");\n\n\treturn 0;\n}\n\n \nstatic void radeon_parse_connector_info(struct radeonfb_info *rinfo)\n{\n\tint offset, chips, connectors, tmp, i, conn, type;\n\n\tstatic char* __conn_type_table[16] = {\n\t\t\"NONE\", \"Proprietary\", \"CRT\", \"DVI-I\", \"DVI-D\", \"Unknown\", \"Unknown\",\n\t\t\"Unknown\", \"Unknown\", \"Unknown\", \"Unknown\", \"Unknown\", \"Unknown\",\n\t\t\"Unknown\", \"Unknown\", \"Unknown\"\n\t};\n\n\tif (!rinfo->bios_seg)\n\t\treturn;\n\n\toffset = BIOS_IN16(rinfo->fp_bios_start + 0x50);\n\tif (offset == 0) {\n\t\tprintk(KERN_WARNING \"radeonfb: No connector info table detected\\n\");\n\t\treturn;\n\t}\n\n\t \n\tchips = BIOS_IN8(offset++) >> 4;\n\tpr_debug(\"%d chips in connector info\\n\", chips);\n\tfor (i = 0; i < chips; i++) {\n\t\ttmp = BIOS_IN8(offset++);\n\t\tconnectors = tmp & 0x0f;\n\t\tpr_debug(\" - chip %d has %d connectors\\n\", tmp >> 4, connectors);\n\t\tfor (conn = 0; ; conn++) {\n\t\t\ttmp = BIOS_IN16(offset);\n\t\t\tif (tmp == 0)\n\t\t\t\tbreak;\n\t\t\toffset += 2;\n\t\t\ttype = (tmp >> 12) & 0x0f;\n\t\t\tpr_debug(\"  * connector %d of type %d (%s) : %04x\\n\",\n\t\t\t       conn, type, __conn_type_table[type], tmp);\n\t\t}\n\t}\n}\n\n\n \nstatic int radeon_crt_is_connected(struct radeonfb_info *rinfo, int is_crt_dac)\n{\n    int\t          connected = 0;\n\n     \n    if (is_crt_dac) {\n\tunsigned long ulOrigVCLK_ECP_CNTL;\n\tunsigned long ulOrigDAC_CNTL;\n\tunsigned long ulOrigDAC_EXT_CNTL;\n\tunsigned long ulOrigCRTC_EXT_CNTL;\n\tunsigned long ulData;\n\tunsigned long ulMask;\n\n\tulOrigVCLK_ECP_CNTL = INPLL(VCLK_ECP_CNTL);\n\n\tulData              = ulOrigVCLK_ECP_CNTL;\n\tulData             &= ~(PIXCLK_ALWAYS_ONb\n\t\t\t\t| PIXCLK_DAC_ALWAYS_ONb);\n\tulMask              = ~(PIXCLK_ALWAYS_ONb\n\t\t\t\t| PIXCLK_DAC_ALWAYS_ONb);\n\tOUTPLLP(VCLK_ECP_CNTL, ulData, ulMask);\n\n\tulOrigCRTC_EXT_CNTL = INREG(CRTC_EXT_CNTL);\n\tulData              = ulOrigCRTC_EXT_CNTL;\n\tulData             |= CRTC_CRT_ON;\n\tOUTREG(CRTC_EXT_CNTL, ulData);\n   \n\tulOrigDAC_EXT_CNTL = INREG(DAC_EXT_CNTL);\n\tulData             = ulOrigDAC_EXT_CNTL;\n\tulData            &= ~DAC_FORCE_DATA_MASK;\n\tulData            |=  (DAC_FORCE_BLANK_OFF_EN\n\t\t\t       |DAC_FORCE_DATA_EN\n\t\t\t       |DAC_FORCE_DATA_SEL_MASK);\n\tif ((rinfo->family == CHIP_FAMILY_RV250) ||\n\t    (rinfo->family == CHIP_FAMILY_RV280))\n\t    ulData |= (0x01b6 << DAC_FORCE_DATA_SHIFT);\n\telse\n\t    ulData |= (0x01ac << DAC_FORCE_DATA_SHIFT);\n\n\tOUTREG(DAC_EXT_CNTL, ulData);\n\n\tulOrigDAC_CNTL     = INREG(DAC_CNTL);\n\tulData             = ulOrigDAC_CNTL;\n\tulData            |= DAC_CMP_EN;\n\tulData            &= ~(DAC_RANGE_CNTL_MASK\n\t\t\t       | DAC_PDWN);\n\tulData            |= 0x2;\n\tOUTREG(DAC_CNTL, ulData);\n\n\tmdelay(1);\n\n\tulData     = INREG(DAC_CNTL);\n\tconnected =  (DAC_CMP_OUTPUT & ulData) ? 1 : 0;\n  \n\tulData    = ulOrigVCLK_ECP_CNTL;\n\tulMask    = 0xFFFFFFFFL;\n\tOUTPLLP(VCLK_ECP_CNTL, ulData, ulMask);\n\n\tOUTREG(DAC_CNTL,      ulOrigDAC_CNTL     );\n\tOUTREG(DAC_EXT_CNTL,  ulOrigDAC_EXT_CNTL );\n\tOUTREG(CRTC_EXT_CNTL, ulOrigCRTC_EXT_CNTL);\n    }\n\n    return connected ? MT_CRT : MT_NONE;\n}\n\n \nstatic int radeon_parse_monitor_layout(struct radeonfb_info *rinfo,\n\t\t\t\t       const char *monitor_layout)\n{\n\tchar s1[5], s2[5];\n\tint i = 0, second = 0;\n\tconst char *s;\n\n\tif (!monitor_layout)\n\t\treturn 0;\n\n\ts = monitor_layout;\n\tdo {\n\t\tswitch(*s) {\n\t\tcase ',':\n\t\t\ts1[i] = '\\0';\n\t\t\ti = 0;\n\t\t\tsecond = 1;\n\t\t\tbreak;\n\t\tcase ' ':\n\t\tcase '\\0':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (i > 4)\n\t\t\t\tbreak;\n\t\t\tif (second)\n\t\t\t\ts2[i] = *s;\n\t\t\telse\n\t\t\t\ts1[i] = *s;\n\t\t\ti++;\n\t\t}\n\n\t\tif (i > 4)\n\t\t\ti = 4;\n\n\t} while (*s++);\n\tif (second)\n\t\ts2[i] = 0;\n\telse {\n\t\ts1[i] = 0;\n\t\ts2[0] = 0;\n\t}\n\tif (strcmp(s1, \"CRT\") == 0)\n\t\trinfo->mon1_type = MT_CRT;\n\telse if (strcmp(s1, \"TMDS\") == 0)\n\t\trinfo->mon1_type = MT_DFP;\n\telse if (strcmp(s1, \"LVDS\") == 0)\n\t\trinfo->mon1_type = MT_LCD;\n\n\tif (strcmp(s2, \"CRT\") == 0)\n\t\trinfo->mon2_type = MT_CRT;\n\telse if (strcmp(s2, \"TMDS\") == 0)\n\t\trinfo->mon2_type = MT_DFP;\n\telse if (strcmp(s2, \"LVDS\") == 0)\n\t\trinfo->mon2_type = MT_LCD;\n\n\treturn 1;\n}\n\n \nvoid radeon_probe_screens(struct radeonfb_info *rinfo,\n\t\t\t  const char *monitor_layout, int ignore_edid)\n{\n#ifdef CONFIG_FB_RADEON_I2C\n\tint ddc_crt2_used = 0;\t\n#endif\n\tint tmp, i;\n\n\tradeon_parse_connector_info(rinfo);\n\n\tif (radeon_parse_monitor_layout(rinfo, monitor_layout)) {\n\n\t\t \n\n\t\tpr_debug(\"Using specified monitor layout: %s\", monitor_layout);\n#ifdef CONFIG_FB_RADEON_I2C\n\t\tif (!ignore_edid) {\n\t\t\tif (rinfo->mon1_type != MT_NONE)\n\t\t\t\tif (!radeon_probe_i2c_connector(rinfo, ddc_dvi, &rinfo->mon1_EDID)) {\n\t\t\t\t\tradeon_probe_i2c_connector(rinfo, ddc_crt2, &rinfo->mon1_EDID);\n\t\t\t\t\tddc_crt2_used = 1;\n\t\t\t\t}\n\t\t\tif (rinfo->mon2_type != MT_NONE)\n\t\t\t\tif (!radeon_probe_i2c_connector(rinfo, ddc_vga, &rinfo->mon2_EDID) &&\n\t\t\t\t    !ddc_crt2_used)\n\t\t\t\t\tradeon_probe_i2c_connector(rinfo, ddc_crt2, &rinfo->mon2_EDID);\n\t\t}\n#endif  \n\t\tif (rinfo->mon1_type == MT_NONE) {\n\t\t\tif (rinfo->mon2_type != MT_NONE) {\n\t\t\t\trinfo->mon1_type = rinfo->mon2_type;\n\t\t\t\trinfo->mon1_EDID = rinfo->mon2_EDID;\n\t\t\t} else {\n\t\t\t\trinfo->mon1_type = MT_CRT;\n\t\t\t\tprintk(KERN_INFO \"radeonfb: No valid monitor, assuming CRT on first port\\n\");\n\t\t\t}\n\t\t\trinfo->mon2_type = MT_NONE;\n\t\t\trinfo->mon2_EDID = NULL;\n\t\t}\n\t} else {\n\t\t \n\t\t\n\t\tpr_debug(\"Starting monitor auto detection...\\n\");\n\n#if defined(DEBUG) && defined(CONFIG_FB_RADEON_I2C)\n\t\t{\n\t\t\tu8 *EDIDs[4] = { NULL, NULL, NULL, NULL };\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tradeon_probe_i2c_connector(rinfo, i + 1, &EDIDs[i]);\n\t\t}\n#endif  \n\t\t \n\t\tif (!rinfo->has_CRTC2) {\n#if defined(CONFIG_PPC) || defined(CONFIG_SPARC)\n\t\t\tif (rinfo->mon1_type == MT_NONE)\n\t\t\t\trinfo->mon1_type = radeon_probe_OF_head(rinfo, 0,\n\t\t\t\t\t\t\t\t\t&rinfo->mon1_EDID);\n#endif  \n#ifdef CONFIG_FB_RADEON_I2C\n\t\t\tif (rinfo->mon1_type == MT_NONE)\n\t\t\t\trinfo->mon1_type =\n\t\t\t\t\tradeon_probe_i2c_connector(rinfo, ddc_dvi,\n\t\t\t\t\t\t\t\t   &rinfo->mon1_EDID);\n\t\t\tif (rinfo->mon1_type == MT_NONE)\n\t\t\t\trinfo->mon1_type =\n\t\t\t\t\tradeon_probe_i2c_connector(rinfo, ddc_vga,\n\t\t\t\t\t\t\t\t   &rinfo->mon1_EDID);\n\t\t\tif (rinfo->mon1_type == MT_NONE)\n\t\t\t\trinfo->mon1_type =\n\t\t\t\t\tradeon_probe_i2c_connector(rinfo, ddc_crt2,\n\t\t\t\t\t\t\t\t   &rinfo->mon1_EDID);\t\n#endif  \n\t\t\tif (rinfo->mon1_type == MT_NONE)\n\t\t\t\trinfo->mon1_type = MT_CRT;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tif (rinfo->bios_seg &&\n\t\t    (tmp = BIOS_IN16(rinfo->fp_bios_start + 0x50))) {\n\t\t\tfor (i = 1; i < 4; i++) {\n\t\t\t\tunsigned int tmp0;\n\n\t\t\t\tif (!BIOS_IN8(tmp + i*2) && i > 1)\n\t\t\t\t\tbreak;\n\t\t\t\ttmp0 = BIOS_IN16(tmp + i*2);\n\t\t\t\tif ((!(tmp0 & 0x01)) && (((tmp0 >> 8) & 0x0f) == ddc_dvi)) {\n\t\t\t\t\trinfo->reversed_DAC = 1;\n\t\t\t\t\tprintk(KERN_INFO \"radeonfb: Reversed DACs detected\\n\");\n\t\t\t\t}\n\t\t\t\tif ((((tmp0 >> 8) & 0x0f) == ddc_dvi) && ((tmp0 >> 4) & 0x01)) {\n\t\t\t\t\trinfo->reversed_TMDS = 1;\n\t\t\t\t\tprintk(KERN_INFO \"radeonfb: Reversed TMDS detected\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n#if defined(CONFIG_PPC) || defined(CONFIG_SPARC)\n\t\tif (rinfo->mon1_type == MT_NONE)\n\t\t\trinfo->mon1_type = radeon_probe_OF_head(rinfo, 0,\n\t\t\t\t\t\t\t\t&rinfo->mon1_EDID);\n#endif  \n#ifdef CONFIG_FB_RADEON_I2C\n\t\tif (rinfo->mon1_type == MT_NONE)\n\t\t\trinfo->mon1_type = radeon_probe_i2c_connector(rinfo, ddc_dvi,\n\t\t\t\t\t\t\t\t      &rinfo->mon1_EDID);\n\t\tif (rinfo->mon1_type == MT_NONE) {\n\t\t\trinfo->mon1_type = radeon_probe_i2c_connector(rinfo, ddc_crt2,\n\t\t\t\t\t\t\t\t      &rinfo->mon1_EDID);\n\t\t\tif (rinfo->mon1_type != MT_NONE)\n\t\t\t\tddc_crt2_used = 1;\n\t\t}\n#endif  \n\t\tif (rinfo->mon1_type == MT_NONE && rinfo->is_mobility &&\n\t\t    ((rinfo->bios_seg && (INREG(BIOS_4_SCRATCH) & 4))\n\t\t     || (INREG(LVDS_GEN_CNTL) & LVDS_ON))) {\n\t\t\trinfo->mon1_type = MT_LCD;\n\t\t\tprintk(\"Non-DDC laptop panel detected\\n\");\n\t\t}\n\t\tif (rinfo->mon1_type == MT_NONE)\n\t\t\trinfo->mon1_type = radeon_crt_is_connected(rinfo, rinfo->reversed_DAC);\n\n\t\t \n#if defined(CONFIG_PPC) || defined(CONFIG_SPARC)\n\t\tif (rinfo->mon2_type == MT_NONE)\n\t\t\trinfo->mon2_type = radeon_probe_OF_head(rinfo, 1,\n\t\t\t\t\t\t\t\t&rinfo->mon2_EDID);\n#endif  \n#ifdef CONFIG_FB_RADEON_I2C\n\t\tif (rinfo->mon2_type == MT_NONE)\n\t\t\trinfo->mon2_type = radeon_probe_i2c_connector(rinfo, ddc_vga,\n\t\t\t\t\t\t\t\t      &rinfo->mon2_EDID);\n\t\tif (rinfo->mon2_type == MT_NONE && !ddc_crt2_used)\n\t\t\trinfo->mon2_type = radeon_probe_i2c_connector(rinfo, ddc_crt2,\n\t\t\t\t\t\t\t\t      &rinfo->mon2_EDID);\n#endif  \n\t\tif (rinfo->mon2_type == MT_NONE)\n\t\t\trinfo->mon2_type = radeon_crt_is_connected(rinfo, !rinfo->reversed_DAC);\n\n\t\t \n\t\tif (rinfo->mon1_type == MT_NONE) {\n\t\t\tif (rinfo->mon2_type != MT_NONE) {\n\t\t\t\trinfo->mon1_type = rinfo->mon2_type;\n\t\t\t\trinfo->mon1_EDID = rinfo->mon2_EDID;\n\t\t\t} else\n\t\t\t\trinfo->mon1_type = MT_CRT;\n\t\t\trinfo->mon2_type = MT_NONE;\n\t\t\trinfo->mon2_EDID = NULL;\n\t\t}\n\n\t\t \n\t\tif (rinfo->reversed_TMDS) {\n\t\t\t \n\t\t\tif (rinfo->mon1_type == MT_DFP || rinfo->mon2_type == MT_DFP) {\n\t\t\t\tint tmp_type = rinfo->mon1_type;\n\t\t\t\tu8 *tmp_EDID = rinfo->mon1_EDID;\n\t\t\t\trinfo->mon1_type = rinfo->mon2_type;\n\t\t\t\trinfo->mon1_EDID = rinfo->mon2_EDID;\n\t\t\t\trinfo->mon2_type = tmp_type;\n\t\t\t\trinfo->mon2_EDID = tmp_EDID;\n\t\t\t\tif (rinfo->mon1_type == MT_CRT || rinfo->mon2_type == MT_CRT)\n\t\t\t\t\trinfo->reversed_DAC ^= 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (ignore_edid) {\n\t\tkfree(rinfo->mon1_EDID);\n\t\trinfo->mon1_EDID = NULL;\n\t\tkfree(rinfo->mon2_EDID);\n\t\trinfo->mon2_EDID = NULL;\n\t}\n\n bail:\n\tprintk(KERN_INFO \"radeonfb: Monitor 1 type %s found\\n\",\n\t       radeon_get_mon_name(rinfo->mon1_type));\n\tif (rinfo->mon1_EDID)\n\t\tprintk(KERN_INFO \"radeonfb: EDID probed\\n\");\n\tif (!rinfo->has_CRTC2)\n\t\treturn;\n\tprintk(KERN_INFO \"radeonfb: Monitor 2 type %s found\\n\",\n\t       radeon_get_mon_name(rinfo->mon2_type));\n\tif (rinfo->mon2_EDID)\n\t\tprintk(KERN_INFO \"radeonfb: EDID probed\\n\");\n}\n\n\n \nstatic void radeon_fixup_panel_info(struct radeonfb_info *rinfo)\n{\n#ifdef CONFIG_PPC\n\t \n\tif (!rinfo->panel_info.use_bios_dividers && rinfo->mon1_type == MT_LCD\n\t    && rinfo->is_mobility) {\n\t\tint ppll_div_sel;\n\t\tu32 ppll_divn;\n\t\tppll_div_sel = INREG8(CLOCK_CNTL_INDEX + 1) & 0x3;\n\t\tradeon_pll_errata_after_index(rinfo);\n\t\tppll_divn = INPLL(PPLL_DIV_0 + ppll_div_sel);\n\t\trinfo->panel_info.ref_divider = rinfo->pll.ref_div;\n\t\trinfo->panel_info.fbk_divider = ppll_divn & 0x7ff;\n\t\trinfo->panel_info.post_divider = (ppll_divn >> 16) & 0x7;\n\t\trinfo->panel_info.use_bios_dividers = 1;\n\n\t\tprintk(KERN_DEBUG \"radeonfb: Using Firmware dividers 0x%08x \"\n\t\t       \"from PPLL %d\\n\",\n\t\t       rinfo->panel_info.fbk_divider |\n\t\t       (rinfo->panel_info.post_divider << 16),\n\t\t       ppll_div_sel);\n\t}\n#endif  \n}\n\n\n \nstatic void radeon_var_to_panel_info(struct radeonfb_info *rinfo, struct fb_var_screeninfo *var)\n{\n\trinfo->panel_info.xres = var->xres;\n\trinfo->panel_info.yres = var->yres;\n\trinfo->panel_info.clock = 100000000 / var->pixclock;\n\trinfo->panel_info.hOver_plus = var->right_margin;\n\trinfo->panel_info.hSync_width = var->hsync_len;\n       \trinfo->panel_info.hblank = var->left_margin +\n\t\t(var->right_margin + var->hsync_len);\n\trinfo->panel_info.vOver_plus = var->lower_margin;\n\trinfo->panel_info.vSync_width = var->vsync_len;\n       \trinfo->panel_info.vblank = var->upper_margin +\n\t\t(var->lower_margin + var->vsync_len);\n\trinfo->panel_info.hAct_high =\n\t\t(var->sync & FB_SYNC_HOR_HIGH_ACT) != 0;\n\trinfo->panel_info.vAct_high =\n\t\t(var->sync & FB_SYNC_VERT_HIGH_ACT) != 0;\n\trinfo->panel_info.valid = 1;\n\t \n\trinfo->panel_info.pwr_delay = 200;\n}\n\nstatic void radeon_videomode_to_var(struct fb_var_screeninfo *var,\n\t\t\t\t    const struct fb_videomode *mode)\n{\n\tvar->xres = mode->xres;\n\tvar->yres = mode->yres;\n\tvar->xres_virtual = mode->xres;\n\tvar->yres_virtual = mode->yres;\n\tvar->xoffset = 0;\n\tvar->yoffset = 0;\n\tvar->pixclock = mode->pixclock;\n\tvar->left_margin = mode->left_margin;\n\tvar->right_margin = mode->right_margin;\n\tvar->upper_margin = mode->upper_margin;\n\tvar->lower_margin = mode->lower_margin;\n\tvar->hsync_len = mode->hsync_len;\n\tvar->vsync_len = mode->vsync_len;\n\tvar->sync = mode->sync;\n\tvar->vmode = mode->vmode;\n}\n\n#ifdef CONFIG_PPC_PSERIES\nstatic int is_powerblade(const char *model)\n{\n\tstruct device_node *root;\n\tconst char* cp;\n\tint len, l, rc = 0;\n\n\troot = of_find_node_by_path(\"/\");\n\tif (root && model) {\n\t\tl = strlen(model);\n\t\tcp = of_get_property(root, \"model\", &len);\n\t\tif (cp)\n\t\t\trc = memcmp(model, cp, min(len, l)) == 0;\n\t\tof_node_put(root);\n\t}\n\treturn rc;\n}\n#endif\n\n \nvoid radeon_check_modes(struct radeonfb_info *rinfo, const char *mode_option)\n{\n\tstruct fb_info * info = rinfo->info;\n\tint has_default_mode = 0;\n\n\t \n\tinfo->var = radeonfb_default_var;\n\tINIT_LIST_HEAD(&info->modelist);\n\n\t \n\tif (rinfo->mon1_type == MT_LCD)\n\t\tradeon_get_panel_info_BIOS(rinfo);\n\n\t \n\tif (!rinfo->panel_info.use_bios_dividers && rinfo->mon1_type != MT_CRT\n\t    && rinfo->mon1_EDID) {\n\t\tstruct fb_var_screeninfo var;\n\t\tpr_debug(\"Parsing EDID data for panel info\\n\");\n\t\tif (fb_parse_edid(rinfo->mon1_EDID, &var) == 0) {\n\t\t\tif (var.xres >= rinfo->panel_info.xres &&\n\t\t\t    var.yres >= rinfo->panel_info.yres)\n\t\t\t\tradeon_var_to_panel_info(rinfo, &var);\n\t\t}\n\t}\n\n\t \n\tradeon_fixup_panel_info(rinfo);\n\n\t \n\tif (rinfo->mon1_type != MT_CRT && rinfo->panel_info.valid) {\n\t\tstruct fb_var_screeninfo *var = &info->var;\n\n\t\tpr_debug(\"Setting up default mode based on panel info\\n\");\n\t\tvar->xres = rinfo->panel_info.xres;\n\t\tvar->yres = rinfo->panel_info.yres;\n\t\tvar->xres_virtual = rinfo->panel_info.xres;\n\t\tvar->yres_virtual = rinfo->panel_info.yres;\n\t\tvar->xoffset = var->yoffset = 0;\n\t\tvar->bits_per_pixel = 8;\n\t\tvar->pixclock = 100000000 / rinfo->panel_info.clock;\n\t\tvar->left_margin = (rinfo->panel_info.hblank - rinfo->panel_info.hOver_plus\n\t\t\t\t    - rinfo->panel_info.hSync_width);\n\t\tvar->right_margin = rinfo->panel_info.hOver_plus;\n\t\tvar->upper_margin = (rinfo->panel_info.vblank - rinfo->panel_info.vOver_plus\n\t\t\t\t     - rinfo->panel_info.vSync_width);\n\t\tvar->lower_margin = rinfo->panel_info.vOver_plus;\n\t\tvar->hsync_len = rinfo->panel_info.hSync_width;\n\t\tvar->vsync_len = rinfo->panel_info.vSync_width;\n\t\tvar->sync = 0;\n\t\tif (rinfo->panel_info.hAct_high)\n\t\t\tvar->sync |= FB_SYNC_HOR_HIGH_ACT;\n\t\tif (rinfo->panel_info.vAct_high)\n\t\t\tvar->sync |= FB_SYNC_VERT_HIGH_ACT;\n\t\tvar->vmode = 0;\n\t\thas_default_mode = 1;\n\t}\n\n\t \n\tif (rinfo->mon1_EDID) {\n\t\tfb_edid_to_monspecs(rinfo->mon1_EDID, &info->monspecs);\n\t\tfb_videomode_to_modelist(info->monspecs.modedb,\n\t\t\t\t\t info->monspecs.modedb_len,\n\t\t\t\t\t &info->modelist);\n\t\trinfo->mon1_modedb = info->monspecs.modedb;\n\t\trinfo->mon1_dbsize = info->monspecs.modedb_len;\n\t}\n\n\t\n\t \n\tif (rinfo->mon1_type != MT_CRT && !rinfo->panel_info.valid) {\n\t\tstruct fb_videomode\t*modedb;\n\t\tint\t\t\tdbsize;\n\t\tchar\t\t\tmodename[32];\n\n\t\tpr_debug(\"Guessing panel info...\\n\");\n\t\tif (rinfo->panel_info.xres == 0 || rinfo->panel_info.yres == 0) {\n\t\t\tu32 tmp = INREG(FP_HORZ_STRETCH) & HORZ_PANEL_SIZE;\n\t\t\trinfo->panel_info.xres = ((tmp >> HORZ_PANEL_SHIFT) + 1) * 8;\n\t\t\ttmp = INREG(FP_VERT_STRETCH) & VERT_PANEL_SIZE;\n\t\t\trinfo->panel_info.yres = (tmp >> VERT_PANEL_SHIFT) + 1;\n\t\t}\n\t\tif (rinfo->panel_info.xres == 0 || rinfo->panel_info.yres == 0) {\n\t\t\tprintk(KERN_WARNING \"radeonfb: Can't find panel size, going back to CRT\\n\");\n\t\t\trinfo->mon1_type = MT_CRT;\n\t\t\tgoto pickup_default;\n\t\t}\n\t\tprintk(KERN_WARNING \"radeonfb: Assuming panel size %dx%d\\n\",\n\t\t       rinfo->panel_info.xres, rinfo->panel_info.yres);\n\t\tmodedb = rinfo->mon1_modedb;\n\t\tdbsize = rinfo->mon1_dbsize;\n\t\tsnprintf(modename, 31, \"%dx%d\", rinfo->panel_info.xres, rinfo->panel_info.yres);\n\t\tif (fb_find_mode(&info->var, info, modename,\n\t\t\t\t modedb, dbsize, NULL, 8) == 0) {\n\t\t\tprintk(KERN_WARNING \"radeonfb: Can't find mode for panel size, going back to CRT\\n\");\n\t\t\trinfo->mon1_type = MT_CRT;\n\t\t\tgoto pickup_default;\n\t\t}\n\t\thas_default_mode = 1;\n\t\tradeon_var_to_panel_info(rinfo, &info->var);\n\t}\n\n pickup_default:\n\t \n\tif (mode_option) {\n\t\tif (fb_find_mode(&info->var, info, mode_option,\n\t\t\t\t info->monspecs.modedb,\n\t\t\t\t info->monspecs.modedb_len, NULL, 8) != 0)\n\t\t\thas_default_mode = 1;\n \t}\n\n#ifdef CONFIG_PPC_PSERIES\n\tif (!has_default_mode && (\n\t\tis_powerblade(\"IBM,8842\") ||  \n\t\tis_powerblade(\"IBM,8844\") ||  \n\t\tis_powerblade(\"IBM,7998\") ||  \n\t\tis_powerblade(\"IBM,0792\") ||  \n\t\tis_powerblade(\"IBM,0793\")     \n\t    )) {\n\t\tprintk(\"Falling back to 800x600 on JSxx hardware\\n\");\n\t\tif (fb_find_mode(&info->var, info, \"800x600@60\",\n\t\t\t\t info->monspecs.modedb,\n\t\t\t\t info->monspecs.modedb_len, NULL, 8) != 0)\n\t\t\thas_default_mode = 1;\n\t}\n#endif\n\n\t \n\tif (!has_default_mode && info->monspecs.modedb != NULL) {\n\t\tstruct fb_monspecs *specs = &info->monspecs;\n\t\tstruct fb_videomode *modedb = NULL;\n\n\t\t \n\t\tif (specs->misc & FB_MISC_1ST_DETAIL) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < specs->modedb_len; i++) {\n\t\t\t\tif (specs->modedb[i].flag & FB_MODE_IS_FIRST) {\n\t\t\t\t\tmodedb = &specs->modedb[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tmodedb = &specs->modedb[0];\n\t\t}\n\t\tif (modedb != NULL) {\n\t\t\tinfo->var.bits_per_pixel = 8;\n\t\t\tradeon_videomode_to_var(&info->var, modedb);\n\t\t\thas_default_mode = 1;\n\t\t}\n\t}\n\tif (1) {\n\t\tstruct fb_videomode mode;\n\t\t \n\t\tfb_var_to_videomode(&mode, &info->var);\n\t\tfb_add_videomode(&mode, &info->modelist);\n\t}\n}\n\n \n\n \nstatic int radeon_compare_modes(const struct fb_var_screeninfo *var,\n\t\t\t\tconst struct fb_videomode *mode)\n{\n\tint distance = 0;\n\n\tdistance = mode->yres - var->yres;\n\tdistance += (mode->xres - var->xres)/2;\n\treturn distance;\n}\n\n \nint  radeon_match_mode(struct radeonfb_info *rinfo,\n\t\t       struct fb_var_screeninfo *dest,\n\t\t       const struct fb_var_screeninfo *src)\n{\n\tconst struct fb_videomode\t*db = vesa_modes;\n\tint\t\t\t\ti, dbsize = 34;\n\tint\t\t\t\thas_rmx, native_db = 0;\n\tint\t\t\t\tdistance = INT_MAX;\n\tconst struct fb_videomode\t*candidate = NULL;\n\n\t \n\tmemcpy(dest, src, sizeof(struct fb_var_screeninfo));\n\n\t \n\tif (rinfo->mon1_modedb) {\n\t\tdb = rinfo->mon1_modedb;\n\t\tdbsize = rinfo->mon1_dbsize;\n\t\tnative_db = 1;\n\t}\n\n\t \n\thas_rmx = rinfo->mon1_type == MT_LCD || rinfo->mon1_type == MT_DFP;\n\n\t \n\tif ((src->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_TEST ||\n\t    (src->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW) {\n\t\t \n\t\tif (has_rmx == 0 && rinfo->mon1_modedb)\n\t\t\tif (fb_validate_mode((struct fb_var_screeninfo *)src, rinfo->info))\n\t\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t \n\twhile (db) {\n\t\tfor (i = 0; i < dbsize; i++) {\n\t\t\tint d;\n\n\t\t\tif (db[i].yres < src->yres)\n\t\t\t\tcontinue;\t\n\t\t\tif (db[i].xres < src->xres)\n\t\t\t\tcontinue;\n\t\t\td = radeon_compare_modes(src, &db[i]);\n\t\t\t \n\t\t\tif (d < distance) {\n\t\t\t\tcandidate = &db[i];\n\t\t\t\tdistance = d;\n\t\t\t}\n\t\t}\n\t\tdb = NULL;\n\t\t \n\t\tif (native_db && has_rmx) {\n\t\t\tdb = vesa_modes;\n\t\t\tdbsize = 34;\n\t\t\tnative_db = 0;\n\t\t}\n\t}\n\n\t \n\tif (candidate != NULL) {\n\t\tradeon_videomode_to_var(dest, candidate);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!has_rmx)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}