{
  "module_name": "atyfb.h",
  "hash_id": "b7de042377ae1b3e8c1c8c83f987a60e495e19094cd4a0018f8fac9c036a3bc0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/aty/atyfb.h",
  "human_readable_source": " \n \n\n#include <linux/io.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n\n     \n\nstruct crtc {\n\tu32 vxres;\n\tu32 vyres;\n\tu32 xoffset;\n\tu32 yoffset;\n\tu32 bpp;\n\tu32 h_tot_disp;\n\tu32 h_sync_strt_wid;\n\tu32 v_tot_disp;\n\tu32 v_sync_strt_wid;\n\tu32 vline_crnt_vline;\n\tu32 off_pitch;\n\tu32 gen_cntl;\n\tu32 dp_pix_width;\t \n\tu32 dp_chain_mask;\t \n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tu32 horz_stretching;\n\tu32 vert_stretching;\n\tu32 ext_vert_stretch;\n\tu32 shadow_h_tot_disp;\n\tu32 shadow_h_sync_strt_wid;\n\tu32 shadow_v_tot_disp;\n\tu32 shadow_v_sync_strt_wid;\n\tu32 lcd_gen_cntl;\n\tu32 lcd_config_panel;\n\tu32 lcd_index;\n#endif\n};\n\nstruct aty_interrupt {\n\twait_queue_head_t wait;\n\tunsigned int count;\n\tint pan_display;\n};\n\nstruct pll_info {\n\tint pll_max;\n\tint pll_min;\n\tint sclk, mclk, mclk_pm, xclk;\n\tint ref_div;\n\tint ref_clk;\n\tint ecp_max;\n};\n\ntypedef struct {\n\tu16 unknown1;\n\tu16 PCLK_min_freq;\n\tu16 PCLK_max_freq;\n\tu16 unknown2;\n\tu16 ref_freq;\n\tu16 ref_divider;\n\tu16 unknown3;\n\tu16 MCLK_pwd;\n\tu16 MCLK_max_freq;\n\tu16 XCLK_max_freq;\n\tu16 SCLK_freq;\n} __attribute__ ((packed)) PLL_BLOCK_MACH64;\n\nstruct pll_514 {\n\tu8 m;\n\tu8 n;\n};\n\nstruct pll_18818 {\n\tu32 program_bits;\n\tu32 locationAddr;\n\tu32 period_in_ps;\n\tu32 post_divider;\n};\n\nstruct pll_ct {\n\tu8 pll_ref_div;\n\tu8 pll_gen_cntl;\n\tu8 mclk_fb_div;\n\tu8 mclk_fb_mult;  \n\tu8 sclk_fb_div;\n\tu8 pll_vclk_cntl;\n\tu8 vclk_post_div;\n\tu8 vclk_fb_div;\n\tu8 pll_ext_cntl;\n\tu8 ext_vpll_cntl;\n\tu8 spll_cntl2;\n\tu32 dsp_config;  \n\tu32 dsp_on_off;  \n\tu32 dsp_loop_latency;\n\tu32 fifo_size;\n\tu32 xclkpagefaultdelay;\n\tu32 xclkmaxrasdelay;\n\tu8 xclk_ref_div;\n\tu8 xclk_post_div;\n\tu8 mclk_post_div_real;\n\tu8 xclk_post_div_real;\n\tu8 vclk_post_div_real;\n\tu8 features;\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tu32 xres;  \n#endif\n};\n\n \n#define DONT_USE_SPLL 0x1\n#define DONT_USE_XDLL 0x2\n#define USE_CPUCLK    0x4\n#define POWERDOWN_PLL 0x8\n\nunion aty_pll {\n\tstruct pll_ct ct;\n\tstruct pll_514 ibm514;\n\tstruct pll_18818 ics2595;\n};\n\n     \n\nstruct atyfb_par {\n\tu32 pseudo_palette[16];\n\tstruct { u8 red, green, blue; } palette[256];\n\tconst struct aty_dac_ops *dac_ops;\n\tconst struct aty_pll_ops *pll_ops;\n\tvoid __iomem *ati_regbase;\n\tunsigned long clk_wr_offset;  \n\tstruct crtc crtc;\n\tunion aty_pll pll;\n\tstruct pll_info pll_limits;\n\tu32 features;\n\tu32 ref_clk_per;\n\tu32 pll_per;\n\tu32 mclk_per;\n\tu32 xclk_per;\n\tu8 bus_type;\n\tu8 ram_type;\n\tu8 mem_refresh_rate;\n\tu16 pci_id;\n\tu32 accel_flags;\n\tint blitter_may_be_busy;\n\tunsigned fifo_space;\n\tint asleep;\n\tint lock_blank;\n\tunsigned long res_start;\n\tunsigned long res_size;\n\tstruct pci_dev *pdev;\n#ifdef __sparc__\n\tstruct pci_mmap_map *mmap_map;\n\tu8 mmaped;\n#endif\n\tint open;\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tunsigned long bios_base_phys;\n\tunsigned long bios_base;\n\tunsigned long lcd_table;\n\tu16 lcd_width;\n\tu16 lcd_height;\n\tu32 lcd_pixclock;\n\tu16 lcd_refreshrate;\n\tu16 lcd_htotal;\n\tu16 lcd_hdisp;\n\tu16 lcd_hsync_dly;\n\tu16 lcd_hsync_len;\n\tu16 lcd_vtotal;\n\tu16 lcd_vdisp;\n\tu16 lcd_vsync_len;\n\tu16 lcd_right_margin;\n\tu16 lcd_lower_margin;\n\tu16 lcd_hblank_len;\n\tu16 lcd_vblank_len;\n#endif\n\tunsigned long aux_start;  \n\tunsigned long aux_size;\n\tstruct aty_interrupt vblank;\n\tunsigned long irq_flags;\n\tunsigned int irq;\n\tspinlock_t int_lock;\n\tint wc_cookie;\n\tu32 mem_cntl;\n\tstruct crtc saved_crtc;\n\tunion aty_pll saved_pll;\n};\n\n     \n\n#define M64_HAS(feature)\t((par)->features & (M64F_##feature))\n\n#define M64F_RESET_3D\t\t0x00000001\n#define M64F_MAGIC_FIFO\t\t0x00000002\n#define M64F_GTB_DSP\t\t0x00000004\n#define M64F_FIFO_32\t\t0x00000008\n#define M64F_SDRAM_MAGIC_PLL\t0x00000010\n#define M64F_MAGIC_POSTDIV\t0x00000020\n#define M64F_INTEGRATED\t\t0x00000040\n#define M64F_CT_BUS\t\t0x00000080\n#define M64F_VT_BUS\t\t0x00000100\n#define M64F_MOBIL_BUS\t\t0x00000200\n#define M64F_GX\t\t\t0x00000400\n#define M64F_CT\t\t\t0x00000800\n#define M64F_VT\t\t\t0x00001000\n#define M64F_GT\t\t\t0x00002000\n#define M64F_MAGIC_VRAM_SIZE\t0x00004000\n#define M64F_G3_PB_1_1\t\t0x00008000\n#define M64F_G3_PB_1024x768\t0x00010000\n#define M64F_EXTRA_BRIGHT\t0x00020000\n#define M64F_LT_LCD_REGS\t0x00040000\n#define M64F_XL_DLL\t\t0x00080000\n#define M64F_MFB_FORCE_4\t0x00100000\n#define M64F_HW_TRIPLE\t\t0x00200000\n#define M64F_XL_MEM\t\t0x00400000\n     \n\nstatic inline u32 aty_ld_le32(int regindex, const struct atyfb_par *par)\n{\n\t \n\tif (regindex >= 0x400)\n\t\tregindex -= 0x800;\n\n#ifdef CONFIG_ATARI\n\treturn in_le32(par->ati_regbase + regindex);\n#else\n\treturn readl(par->ati_regbase + regindex);\n#endif\n}\n\nstatic inline void aty_st_le32(int regindex, u32 val, const struct atyfb_par *par)\n{\n\t \n\tif (regindex >= 0x400)\n\t\tregindex -= 0x800;\n\n#ifdef CONFIG_ATARI\n\tout_le32(par->ati_regbase + regindex, val);\n#else\n\twritel(val, par->ati_regbase + regindex);\n#endif\n}\n\nstatic inline void aty_st_le16(int regindex, u16 val,\n\t\t\t       const struct atyfb_par *par)\n{\n\t \n\tif (regindex >= 0x400)\n\t\tregindex -= 0x800;\n#ifdef CONFIG_ATARI\n\tout_le16(par->ati_regbase + regindex, val);\n#else\n\twritel(val, par->ati_regbase + regindex);\n#endif\n}\n\nstatic inline u8 aty_ld_8(int regindex, const struct atyfb_par *par)\n{\n\t \n\tif (regindex >= 0x400)\n\t\tregindex -= 0x800;\n#ifdef CONFIG_ATARI\n\treturn in_8(par->ati_regbase + regindex);\n#else\n\treturn readb(par->ati_regbase + regindex);\n#endif\n}\n\nstatic inline void aty_st_8(int regindex, u8 val, const struct atyfb_par *par)\n{\n\t \n\tif (regindex >= 0x400)\n\t\tregindex -= 0x800;\n\n#ifdef CONFIG_ATARI\n\tout_8(par->ati_regbase + regindex, val);\n#else\n\twriteb(val, par->ati_regbase + regindex);\n#endif\n}\n\nextern void aty_st_lcd(int index, u32 val, const struct atyfb_par *par);\nextern u32 aty_ld_lcd(int index, const struct atyfb_par *par);\n\n     \n\nstruct aty_dac_ops {\n\tint (*set_dac) (const struct fb_info * info,\n\t\tconst union aty_pll * pll, u32 bpp, u32 accel);\n};\n\nextern const struct aty_dac_ops aty_dac_ibm514;  \nextern const struct aty_dac_ops aty_dac_ati68860b;  \nextern const struct aty_dac_ops aty_dac_att21c498;  \nextern const struct aty_dac_ops aty_dac_unsupported;  \nextern const struct aty_dac_ops aty_dac_ct;  \n\n\n     \n\nstruct aty_pll_ops {\n\tint (*var_to_pll) (const struct fb_info * info, u32 vclk_per, u32 bpp, union aty_pll * pll);\n\tu32 (*pll_to_var) (const struct fb_info * info, const union aty_pll * pll);\n\tvoid (*set_pll)   (const struct fb_info * info, const union aty_pll * pll);\n\tvoid (*get_pll)   (const struct fb_info *info, union aty_pll * pll);\n\tint (*init_pll)   (const struct fb_info * info, union aty_pll * pll);\n\tvoid (*resume_pll)(const struct fb_info *info, union aty_pll *pll);\n};\n\nextern const struct aty_pll_ops aty_pll_ati18818_1;  \nextern const struct aty_pll_ops aty_pll_stg1703;  \nextern const struct aty_pll_ops aty_pll_ch8398;  \nextern const struct aty_pll_ops aty_pll_att20c408;  \nextern const struct aty_pll_ops aty_pll_ibm514;  \nextern const struct aty_pll_ops aty_pll_unsupported;  \nextern const struct aty_pll_ops aty_pll_ct;  \n\n\nextern void aty_set_pll_ct(const struct fb_info *info, const union aty_pll *pll);\nextern u8 aty_ld_pll_ct(int offset, const struct atyfb_par *par);\n\nextern const u8 aty_postdividers[8];\n\n\n     \n\nextern int aty_init_cursor(struct fb_info *info, struct fb_ops *atyfb_ops);\n\n     \n\nstatic inline void wait_for_fifo(u16 entries, struct atyfb_par *par)\n{\n\tunsigned fifo_space = par->fifo_space;\n\twhile (entries > fifo_space) {\n\t\tfifo_space = 16 - fls(aty_ld_le32(FIFO_STAT, par) & 0xffff);\n\t}\n\tpar->fifo_space = fifo_space - entries;\n}\n\nstatic inline void wait_for_idle(struct atyfb_par *par)\n{\n\twait_for_fifo(16, par);\n\twhile ((aty_ld_le32(GUI_STAT, par) & 1) != 0);\n\tpar->blitter_may_be_busy = 0;\n}\n\nextern void aty_reset_engine(struct atyfb_par *par);\nextern void aty_init_engine(struct atyfb_par *par, struct fb_info *info);\n\nvoid atyfb_copyarea(struct fb_info *info, const struct fb_copyarea *area);\nvoid atyfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect);\nvoid atyfb_imageblit(struct fb_info *info, const struct fb_image *image);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}