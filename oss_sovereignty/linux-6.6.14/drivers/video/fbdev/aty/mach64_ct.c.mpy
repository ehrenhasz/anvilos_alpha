{
  "module_name": "mach64_ct.c",
  "hash_id": "d21740e292bec872d43dd2535090b6b48871cbff7a53324398f5b9307d47fa25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/aty/mach64_ct.c",
  "human_readable_source": "\n\n \n\n#include <linux/fb.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n#include <video/mach64.h>\n#include \"atyfb.h\"\n#ifdef CONFIG_PPC\n#include <asm/machdep.h>\n#endif\n\n#undef DEBUG\n\nstatic int aty_valid_pll_ct (const struct fb_info *info, u32 vclk_per, struct pll_ct *pll);\nstatic int aty_dsp_gt       (const struct fb_info *info, u32 bpp, struct pll_ct *pll);\nstatic int aty_var_to_pll_ct(const struct fb_info *info, u32 vclk_per, u32 bpp, union aty_pll *pll);\nstatic u32 aty_pll_to_var_ct(const struct fb_info *info, const union aty_pll *pll);\n\nu8 aty_ld_pll_ct(int offset, const struct atyfb_par *par)\n{\n\n\t \n\taty_st_8(CLOCK_CNTL_ADDR, (offset << 2) & PLL_ADDR, par);\n\t \n\treturn aty_ld_8(CLOCK_CNTL_DATA, par);\n}\n\nstatic void aty_st_pll_ct(int offset, u8 val, const struct atyfb_par *par)\n{\n\t \n\taty_st_8(CLOCK_CNTL_ADDR, ((offset << 2) & PLL_ADDR) | PLL_WR_EN, par);\n\t \n\taty_st_8(CLOCK_CNTL_DATA, val & PLL_DATA, par);\n\taty_st_8(CLOCK_CNTL_ADDR, ((offset << 2) & PLL_ADDR) & ~PLL_WR_EN, par);\n}\n\n \n\n  \n\n \n\n \n\n#define Maximum_DSP_PRECISION 7\nconst u8 aty_postdividers[8] = {1,2,4,8,3,5,6,12};\n\nstatic int aty_dsp_gt(const struct fb_info *info, u32 bpp, struct pll_ct *pll)\n{\n\tu32 dsp_off, dsp_on, dsp_xclks;\n\tu32 multiplier, divider, ras_multiplier, ras_divider, tmp;\n\tu8 vshift, xshift;\n\ts8 dsp_precision;\n\n\tmultiplier = ((u32)pll->mclk_fb_div) * pll->vclk_post_div_real;\n\tdivider = ((u32)pll->vclk_fb_div) * pll->xclk_ref_div;\n\n\tras_multiplier = pll->xclkmaxrasdelay;\n\tras_divider = 1;\n\n\tif (bpp>=8)\n\t\tdivider = divider * (bpp >> 2);\n\n\tvshift = (6 - 2) - pll->xclk_post_div;\t \n\n\tif (bpp == 0)\n\t\tvshift--;\t \n\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tif (pll->xres != 0) {\n\t\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\n\t\tmultiplier = multiplier * par->lcd_width;\n\t\tdivider = divider * pll->xres & ~7;\n\n\t\tras_multiplier = ras_multiplier * par->lcd_width;\n\t\tras_divider = ras_divider * pll->xres & ~7;\n\t}\n#endif\n\t \n\twhile (((multiplier | divider) & 1) == 0) {\n\t\tmultiplier = multiplier >> 1;\n\t\tdivider = divider >> 1;\n\t}\n\n\t \n\ttmp = ((multiplier * pll->fifo_size) << vshift) / divider;\n\n\tfor (dsp_precision = -5;  tmp;  dsp_precision++)\n\t\ttmp >>= 1;\n\tif (dsp_precision < 0)\n\t\tdsp_precision = 0;\n\telse if (dsp_precision > Maximum_DSP_PRECISION)\n\t\tdsp_precision = Maximum_DSP_PRECISION;\n\n\txshift = 6 - dsp_precision;\n\tvshift += xshift;\n\n\t \n\tdsp_off = ((multiplier * (pll->fifo_size - 1)) << vshift) / divider -\n\t\t(1 << (vshift - xshift));\n\n \n\t{\n\t\tdsp_on = ((multiplier << vshift) + divider) / divider;\n\t\ttmp = ((ras_multiplier << xshift) + ras_divider) / ras_divider;\n\t\tif (dsp_on < tmp)\n\t\t\tdsp_on = tmp;\n\t\tdsp_on = dsp_on + (tmp * 2) + (pll->xclkpagefaultdelay << xshift);\n\t}\n\n\t \n\ttmp = ((1 << (Maximum_DSP_PRECISION - dsp_precision)) - 1) >> 1;\n\tdsp_on = ((dsp_on + tmp) / (tmp + 1)) * (tmp + 1);\n\n\tif (dsp_on >= ((dsp_off / (tmp + 1)) * (tmp + 1))) {\n\t\tdsp_on = dsp_off - (multiplier << vshift) / divider;\n\t\tdsp_on = (dsp_on / (tmp + 1)) * (tmp + 1);\n\t}\n\n\t \n\tdsp_xclks = ((multiplier << (vshift + 5)) + divider) / divider;\n\n\t \n\tpll->dsp_on_off = (dsp_on << 16) + dsp_off;\n\tpll->dsp_config = (dsp_precision << 20) | (pll->dsp_loop_latency << 16) | dsp_xclks;\n#ifdef DEBUG\n\tprintk(\"atyfb(%s): dsp_config 0x%08x, dsp_on_off 0x%08x\\n\",\n\t\t__func__, pll->dsp_config, pll->dsp_on_off);\n#endif\n\treturn 0;\n}\n\nstatic int aty_valid_pll_ct(const struct fb_info *info, u32 vclk_per, struct pll_ct *pll)\n{\n\tu32 q;\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tint pllvclk;\n\n\t \n\tq = par->ref_clk_per * pll->pll_ref_div * 4 / vclk_per;\n\tif (q < 16*8 || q > 255*8) {\n\t\tprintk(KERN_CRIT \"atyfb: vclk out of range\\n\");\n\t\treturn -EINVAL;\n\t} else {\n\t\tpll->vclk_post_div  = (q < 128*8);\n\t\tpll->vclk_post_div += (q <  64*8);\n\t\tpll->vclk_post_div += (q <  32*8);\n\t}\n\tpll->vclk_post_div_real = aty_postdividers[pll->vclk_post_div];\n\t \n\tpll->vclk_fb_div = q * pll->vclk_post_div_real / 8;\n\tpllvclk = (1000000 * 2 * pll->vclk_fb_div) /\n\t\t(par->ref_clk_per * pll->pll_ref_div);\n#ifdef DEBUG\n\tprintk(\"atyfb(%s): pllvclk=%d MHz, vclk=%d MHz\\n\",\n\t\t__func__, pllvclk, pllvclk / pll->vclk_post_div_real);\n#endif\n\tpll->pll_vclk_cntl = 0x03;  \n\n\t \n\tif (par->pll_limits.ecp_max) {\n\t\tint ecp = pllvclk / pll->vclk_post_div_real;\n\t\tint ecp_div = 0;\n\n\t\twhile (ecp > par->pll_limits.ecp_max && ecp_div < 2) {\n\t\t\tecp >>= 1;\n\t\t\tecp_div++;\n\t\t}\n\t\tpll->pll_vclk_cntl |= ecp_div << 4;\n\t}\n\n\treturn 0;\n}\n\nstatic int aty_var_to_pll_ct(const struct fb_info *info, u32 vclk_per, u32 bpp, union aty_pll *pll)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tint err;\n\n\tif ((err = aty_valid_pll_ct(info, vclk_per, &pll->ct)))\n\t\treturn err;\n\tif (M64_HAS(GTB_DSP) && (err = aty_dsp_gt(info, bpp, &pll->ct)))\n\t\treturn err;\n\t \n\treturn 0;\n}\n\nstatic u32 aty_pll_to_var_ct(const struct fb_info *info, const union aty_pll *pll)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 ret;\n\tret = par->ref_clk_per * pll->ct.pll_ref_div * pll->ct.vclk_post_div_real / pll->ct.vclk_fb_div / 2;\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tif(pll->ct.xres > 0) {\n\t\tret *= par->lcd_width;\n\t\tret /= pll->ct.xres;\n\t}\n#endif\n#ifdef DEBUG\n\tprintk(\"atyfb(%s): calculated 0x%08X(%i)\\n\", __func__, ret, ret);\n#endif\n\treturn ret;\n}\n\nvoid aty_set_pll_ct(const struct fb_info *info, const union aty_pll *pll)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu32 crtc_gen_cntl;\n\tu8 tmp, tmp2;\n\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tu32 lcd_gen_cntrl = 0;\n#endif\n\n#ifdef DEBUG\n\tprintk(\"atyfb(%s): about to program:\\n\"\n\t\t\"pll_ext_cntl=0x%02x pll_gen_cntl=0x%02x pll_vclk_cntl=0x%02x\\n\",\n\t\t__func__,\n\t\tpll->ct.pll_ext_cntl, pll->ct.pll_gen_cntl, pll->ct.pll_vclk_cntl);\n\n\tprintk(\"atyfb(%s): setting clock %lu for FeedBackDivider %i, ReferenceDivider %i, PostDivider %i(%i)\\n\",\n\t\t__func__,\n\t\tpar->clk_wr_offset, pll->ct.vclk_fb_div,\n\t\tpll->ct.pll_ref_div, pll->ct.vclk_post_div, pll->ct.vclk_post_div_real);\n#endif\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tif (par->lcd_table != 0) {\n\t\t \n\t\tlcd_gen_cntrl = aty_ld_lcd(LCD_GEN_CNTL, par);\n\t\taty_st_lcd(LCD_GEN_CNTL, lcd_gen_cntrl & ~LCD_ON, par);\n\t}\n#endif\n\taty_st_8(CLOCK_CNTL, par->clk_wr_offset | CLOCK_STROBE, par);\n\n\t \n\tcrtc_gen_cntl = aty_ld_le32(CRTC_GEN_CNTL, par);\n\tif (!(crtc_gen_cntl & CRTC_EXT_DISP_EN))\n\t\taty_st_le32(CRTC_GEN_CNTL, crtc_gen_cntl | CRTC_EXT_DISP_EN, par);\n\n\t \n\taty_st_pll_ct(PLL_VCLK_CNTL, pll->ct.pll_vclk_cntl, par);\n\n\t \n\ttmp2 = par->clk_wr_offset << 1;\n\ttmp = aty_ld_pll_ct(VCLK_POST_DIV, par);\n\ttmp &= ~(0x03U << tmp2);\n\ttmp |= ((pll->ct.vclk_post_div & 0x03U) << tmp2);\n\taty_st_pll_ct(VCLK_POST_DIV, tmp, par);\n\n\t \n\ttmp = aty_ld_pll_ct(PLL_EXT_CNTL, par);\n\ttmp &= ~(0x10U << par->clk_wr_offset);\n\ttmp &= 0xF0U;\n\ttmp |= pll->ct.pll_ext_cntl;\n\taty_st_pll_ct(PLL_EXT_CNTL, tmp, par);\n\n\t \n\ttmp = VCLK0_FB_DIV + par->clk_wr_offset;\n\taty_st_pll_ct(tmp, (pll->ct.vclk_fb_div & 0xFFU), par);\n\n\taty_st_pll_ct(PLL_GEN_CNTL, (pll->ct.pll_gen_cntl & (~(PLL_OVERRIDE | PLL_MCLK_RST))) | OSC_EN, par);\n\n\t \n\taty_st_pll_ct(PLL_VCLK_CNTL, pll->ct.pll_vclk_cntl & ~(PLL_VCLK_RST), par);\n\tmdelay(5);\n\n\taty_st_pll_ct(PLL_GEN_CNTL, pll->ct.pll_gen_cntl, par);\n\taty_st_pll_ct(PLL_VCLK_CNTL, pll->ct.pll_vclk_cntl, par);\n\tmdelay(1);\n\n\t \n\tif (!(crtc_gen_cntl & CRTC_EXT_DISP_EN))\n\t\taty_st_le32(CRTC_GEN_CNTL, crtc_gen_cntl, par);\n\n\tif (M64_HAS(GTB_DSP)) {\n\t\tu8 dll_cntl;\n\n\t\tif (M64_HAS(XL_DLL))\n\t\t\tdll_cntl = 0x80;\n\t\telse if (par->ram_type >= SDRAM)\n\t\t\tdll_cntl = 0xa6;\n\t\telse\n\t\t\tdll_cntl = 0xa0;\n\t\taty_st_pll_ct(DLL_CNTL, dll_cntl, par);\n\t\taty_st_pll_ct(VFC_CNTL, 0x1b, par);\n\t\taty_st_le32(DSP_CONFIG, pll->ct.dsp_config, par);\n\t\taty_st_le32(DSP_ON_OFF, pll->ct.dsp_on_off, par);\n\n\t\tmdelay(10);\n\t\taty_st_pll_ct(DLL_CNTL, dll_cntl, par);\n\t\tmdelay(10);\n\t\taty_st_pll_ct(DLL_CNTL, dll_cntl | 0x40, par);\n\t\tmdelay(10);\n\t\taty_st_pll_ct(DLL_CNTL, dll_cntl & ~0x40, par);\n\t}\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\n\tif (par->lcd_table != 0) {\n\t\t \n\t\taty_st_lcd(LCD_GEN_CNTL, lcd_gen_cntrl, par);\n\t}\n#endif\n}\n\nstatic void aty_get_pll_ct(const struct fb_info *info, union aty_pll *pll)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu8 tmp, clock;\n\n\tclock = aty_ld_8(CLOCK_CNTL, par) & 0x03U;\n\ttmp = clock << 1;\n\tpll->ct.vclk_post_div = (aty_ld_pll_ct(VCLK_POST_DIV, par) >> tmp) & 0x03U;\n\n\tpll->ct.pll_ext_cntl = aty_ld_pll_ct(PLL_EXT_CNTL, par) & 0x0FU;\n\tpll->ct.vclk_fb_div = aty_ld_pll_ct(VCLK0_FB_DIV + clock, par) & 0xFFU;\n\tpll->ct.pll_ref_div = aty_ld_pll_ct(PLL_REF_DIV, par);\n\tpll->ct.mclk_fb_div = aty_ld_pll_ct(MCLK_FB_DIV, par);\n\n\tpll->ct.pll_gen_cntl = aty_ld_pll_ct(PLL_GEN_CNTL, par);\n\tpll->ct.pll_vclk_cntl = aty_ld_pll_ct(PLL_VCLK_CNTL, par);\n\n\tif (M64_HAS(GTB_DSP)) {\n\t\tpll->ct.dsp_config = aty_ld_le32(DSP_CONFIG, par);\n\t\tpll->ct.dsp_on_off = aty_ld_le32(DSP_ON_OFF, par);\n\t}\n}\n\nstatic int aty_init_pll_ct(const struct fb_info *info, union aty_pll *pll)\n{\n\tstruct atyfb_par *par = (struct atyfb_par *) info->par;\n\tu8 mpost_div, xpost_div, sclk_post_div_real;\n\tu32 q, memcntl, trp;\n\tu32 dsp_config;\n#ifdef DEBUG\n\tint pllmclk, pllsclk;\n#endif\n\tpll->ct.pll_ext_cntl = aty_ld_pll_ct(PLL_EXT_CNTL, par);\n\tpll->ct.xclk_post_div = pll->ct.pll_ext_cntl & 0x07;\n\tpll->ct.xclk_ref_div = 1;\n\tswitch (pll->ct.xclk_post_div) {\n\tcase 0:  case 1:  case 2:  case 3:\n\t\tbreak;\n\n\tcase 4:\n\t\tpll->ct.xclk_ref_div = 3;\n\t\tpll->ct.xclk_post_div = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_CRIT \"atyfb: Unsupported xclk source:  %d.\\n\", pll->ct.xclk_post_div);\n\t\treturn -EINVAL;\n\t}\n\tpll->ct.mclk_fb_mult = 2;\n\tif(pll->ct.pll_ext_cntl & PLL_MFB_TIMES_4_2B) {\n\t\tpll->ct.mclk_fb_mult = 4;\n\t\tpll->ct.xclk_post_div -= 1;\n\t}\n\n#ifdef DEBUG\n\tprintk(\"atyfb(%s): mclk_fb_mult=%d, xclk_post_div=%d\\n\",\n\t\t__func__, pll->ct.mclk_fb_mult, pll->ct.xclk_post_div);\n#endif\n\n\tmemcntl = aty_ld_le32(MEM_CNTL, par);\n\ttrp = (memcntl & 0x300) >> 8;\n\n\tpll->ct.xclkpagefaultdelay = ((memcntl & 0xc00) >> 10) + ((memcntl & 0x1000) >> 12) + trp + 2;\n\tpll->ct.xclkmaxrasdelay = ((memcntl & 0x70000) >> 16) + trp + 2;\n\n\tif (M64_HAS(FIFO_32)) {\n\t\tpll->ct.fifo_size = 32;\n\t} else {\n\t\tpll->ct.fifo_size = 24;\n\t\tpll->ct.xclkpagefaultdelay += 2;\n\t\tpll->ct.xclkmaxrasdelay += 3;\n\t}\n\n\tswitch (par->ram_type) {\n\tcase DRAM:\n\t\tif (info->fix.smem_len<=ONE_MB) {\n\t\t\tpll->ct.dsp_loop_latency = 10;\n\t\t} else {\n\t\t\tpll->ct.dsp_loop_latency = 8;\n\t\t\tpll->ct.xclkpagefaultdelay += 2;\n\t\t}\n\t\tbreak;\n\tcase EDO:\n\tcase PSEUDO_EDO:\n\t\tif (info->fix.smem_len<=ONE_MB) {\n\t\t\tpll->ct.dsp_loop_latency = 9;\n\t\t} else {\n\t\t\tpll->ct.dsp_loop_latency = 8;\n\t\t\tpll->ct.xclkpagefaultdelay += 1;\n\t\t}\n\t\tbreak;\n\tcase SDRAM:\n\t\tif (info->fix.smem_len<=ONE_MB) {\n\t\t\tpll->ct.dsp_loop_latency = 11;\n\t\t} else {\n\t\t\tpll->ct.dsp_loop_latency = 10;\n\t\t\tpll->ct.xclkpagefaultdelay += 1;\n\t\t}\n\t\tbreak;\n\tcase SGRAM:\n\t\tpll->ct.dsp_loop_latency = 8;\n\t\tpll->ct.xclkpagefaultdelay += 3;\n\t\tbreak;\n\tdefault:\n\t\tpll->ct.dsp_loop_latency = 11;\n\t\tpll->ct.xclkpagefaultdelay += 3;\n\t\tbreak;\n\t}\n\n\tif (pll->ct.xclkmaxrasdelay <= pll->ct.xclkpagefaultdelay)\n\t\tpll->ct.xclkmaxrasdelay = pll->ct.xclkpagefaultdelay + 1;\n\n\t \n\tdsp_config = aty_ld_le32(DSP_CONFIG, par);\n\taty_ld_le32(DSP_ON_OFF, par);\n\taty_ld_le32(VGA_DSP_CONFIG, par);\n\taty_ld_le32(VGA_DSP_ON_OFF, par);\n\n\tif (dsp_config)\n\t\tpll->ct.dsp_loop_latency = (dsp_config & DSP_LOOP_LATENCY) >> 16;\n#if 0\n\tFIXME: is it relevant for us?\n\tif ((!dsp_on_off && !M64_HAS(RESET_3D)) ||\n\t\t((dsp_on_off == vga_dsp_on_off) &&\n\t\t(!dsp_config || !((dsp_config ^ vga_dsp_config) & DSP_XCLKS_PER_QW)))) {\n\t\tvga_dsp_on_off &= VGA_DSP_OFF;\n\t\tvga_dsp_config &= VGA_DSP_XCLKS_PER_QW;\n\t\tif (ATIDivide(vga_dsp_on_off, vga_dsp_config, 5, 1) > 24)\n\t\t\tpll->ct.fifo_size = 32;\n\t\telse\n\t\t\tpll->ct.fifo_size = 24;\n\t}\n#endif\n\t \n\tif (par->mclk_per == 0) {\n\t\tu8 mclk_fb_div, pll_ext_cntl;\n\t\tpll->ct.pll_ref_div = aty_ld_pll_ct(PLL_REF_DIV, par);\n\t\tpll_ext_cntl = aty_ld_pll_ct(PLL_EXT_CNTL, par);\n\t\tpll->ct.xclk_post_div_real = aty_postdividers[pll_ext_cntl & 0x07];\n\t\tmclk_fb_div = aty_ld_pll_ct(MCLK_FB_DIV, par);\n\t\tif (pll_ext_cntl & PLL_MFB_TIMES_4_2B)\n\t\t\tmclk_fb_div <<= 1;\n\t\tpll->ct.mclk_fb_div = mclk_fb_div;\n\t\treturn 0;\n\t}\n\n\tpll->ct.pll_ref_div = par->pll_per * 2 * 255 / par->ref_clk_per;\n\n\t \n\tq = par->ref_clk_per * pll->ct.pll_ref_div * 8 /\n\t\t(pll->ct.mclk_fb_mult * par->xclk_per);\n\n\tif (q < 16*8 || q > 255*8) {\n\t\tprintk(KERN_CRIT \"atxfb: xclk out of range\\n\");\n\t\treturn -EINVAL;\n\t} else {\n\t\txpost_div  = (q < 128*8);\n\t\txpost_div += (q <  64*8);\n\t\txpost_div += (q <  32*8);\n\t}\n\tpll->ct.xclk_post_div_real = aty_postdividers[xpost_div];\n\tpll->ct.mclk_fb_div = q * pll->ct.xclk_post_div_real / 8;\n\n#ifdef CONFIG_PPC\n\tif (machine_is(powermac)) {\n\t\t \n\t\tpll->ct.xclk_post_div = xpost_div;\n\t\tpll->ct.xclk_ref_div = 1;\n\t}\n#endif\n\n#ifdef DEBUG\n\tpllmclk = (1000000 * pll->ct.mclk_fb_mult * pll->ct.mclk_fb_div) /\n\t\t\t(par->ref_clk_per * pll->ct.pll_ref_div);\n\tprintk(\"atyfb(%s): pllmclk=%d MHz, xclk=%d MHz\\n\",\n\t\t__func__, pllmclk, pllmclk / pll->ct.xclk_post_div_real);\n#endif\n\n\tif (M64_HAS(SDRAM_MAGIC_PLL) && (par->ram_type >= SDRAM))\n\t\tpll->ct.pll_gen_cntl = OSC_EN;\n\telse\n\t\tpll->ct.pll_gen_cntl = OSC_EN | DLL_PWDN  ;\n\n\tif (M64_HAS(MAGIC_POSTDIV))\n\t\tpll->ct.pll_ext_cntl = 0;\n\telse\n\t\tpll->ct.pll_ext_cntl = xpost_div;\n\n\tif (pll->ct.mclk_fb_mult == 4)\n\t\tpll->ct.pll_ext_cntl |= PLL_MFB_TIMES_4_2B;\n\n\tif (par->mclk_per == par->xclk_per) {\n\t\tpll->ct.pll_gen_cntl |= (xpost_div << 4);  \n\t} else {\n\t\t \n\t\tpll->ct.pll_gen_cntl |= (6 << 4);  \n\n\t\tq = par->ref_clk_per * pll->ct.pll_ref_div * 4 / par->mclk_per;\n\t\tif (q < 16*8 || q > 255*8) {\n\t\t\tprintk(KERN_CRIT \"atyfb: mclk out of range\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tmpost_div  = (q < 128*8);\n\t\t\tmpost_div += (q <  64*8);\n\t\t\tmpost_div += (q <  32*8);\n\t\t}\n\t\tsclk_post_div_real = aty_postdividers[mpost_div];\n\t\tpll->ct.sclk_fb_div = q * sclk_post_div_real / 8;\n\t\tpll->ct.spll_cntl2 = mpost_div << 4;\n#ifdef DEBUG\n\t\tpllsclk = (1000000 * 2 * pll->ct.sclk_fb_div) /\n\t\t\t(par->ref_clk_per * pll->ct.pll_ref_div);\n\t\tprintk(\"atyfb(%s): use sclk, pllsclk=%d MHz, sclk=mclk=%d MHz\\n\",\n\t\t\t__func__, pllsclk, pllsclk / sclk_post_div_real);\n#endif\n\t}\n\n\t \n\tpll->ct.ext_vpll_cntl = aty_ld_pll_ct(EXT_VPLL_CNTL, par);\n\tpll->ct.ext_vpll_cntl &= ~(EXT_VPLL_EN | EXT_VPLL_VGA_EN | EXT_VPLL_INSYNC);\n\n\treturn 0;\n}\n\nstatic void aty_resume_pll_ct(const struct fb_info *info,\n\t\t\t      union aty_pll *pll)\n{\n\tstruct atyfb_par *par = info->par;\n\n\tif (par->mclk_per != par->xclk_per) {\n\t\t \n\t\taty_st_pll_ct(SCLK_FB_DIV, pll->ct.sclk_fb_div, par);\n\t\taty_st_pll_ct(SPLL_CNTL2, pll->ct.spll_cntl2, par);\n\t\t \n\t\tmdelay(5);\n\t}\n\n\taty_st_pll_ct(PLL_REF_DIV, pll->ct.pll_ref_div, par);\n\taty_st_pll_ct(PLL_GEN_CNTL, pll->ct.pll_gen_cntl, par);\n\taty_st_pll_ct(MCLK_FB_DIV, pll->ct.mclk_fb_div, par);\n\taty_st_pll_ct(PLL_EXT_CNTL, pll->ct.pll_ext_cntl, par);\n\taty_st_pll_ct(EXT_VPLL_CNTL, pll->ct.ext_vpll_cntl, par);\n}\n\nstatic int dummy(void)\n{\n\treturn 0;\n}\n\nconst struct aty_dac_ops aty_dac_ct = {\n\t.set_dac\t= (void *) dummy,\n};\n\nconst struct aty_pll_ops aty_pll_ct = {\n\t.var_to_pll\t= aty_var_to_pll_ct,\n\t.pll_to_var\t= aty_pll_to_var_ct,\n\t.set_pll\t= aty_set_pll_ct,\n\t.get_pll\t= aty_get_pll_ct,\n\t.init_pll\t= aty_init_pll_ct,\n\t.resume_pll\t= aty_resume_pll_ct,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}