{
  "module_name": "stifb.c",
  "hash_id": "b9b01c61bc6447a7e6d7493c70583c6db6c7549652232500a88506f7508d0228",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/stifb.c",
  "human_readable_source": " \n\n \n\n\n \n#undef FALLBACK_TO_1BPP\n\n#undef DEBUG_STIFB_REGS\t\t \n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n\n#include <asm/grfioctl.h>\t \n#include <linux/uaccess.h>\n\n#include <video/sticore.h>\n\n \n#define REGION_BASE(fb_info, index) \\\n\tF_EXTEND(fb_info->sti->regions_phys[index])\n\n#define NGLEDEVDEPROM_CRT_REGION 1\n\n#define NR_PALETTE 256\n\ntypedef struct {\n\t__s32\tvideo_config_reg;\n\t__s32\tmisc_video_start;\n\t__s32\thoriz_timing_fmt;\n\t__s32\tserr_timing_fmt;\n\t__s32\tvert_timing_fmt;\n\t__s32\thoriz_state;\n\t__s32\tvert_state;\n\t__s32\tvtg_state_elements;\n\t__s32\tpipeline_delay;\n\t__s32\tmisc_video_end;\n} video_setup_t;\n\ntypedef struct {\n\t__s16\tsizeof_ngle_data;\n\t__s16\tx_size_visible;\t     \n\t__s16\ty_size_visible;\n\t__s16\tpad2[15];\n\t__s16\tcursor_pipeline_delay;\n\t__s16\tvideo_interleaves;\n\t__s32\tpad3[11];\n} ngle_rom_t;\n\nstruct stifb_info {\n\tstruct fb_info info;\n\tunsigned int id;\n\tngle_rom_t ngle_rom;\n\tstruct sti_struct *sti;\n\tint deviceSpecificConfig;\n\tu32 pseudo_palette[16];\n};\n\nstatic int __initdata stifb_bpp_pref[MAX_STI_ROMS];\n\n \n\n \n\n#define REG_1\t\t0x000118\n#define REG_2\t\t0x000480\n#define REG_3\t\t0x0004a0\n#define REG_4\t\t0x000600\n#define REG_6\t\t0x000800\n#define REG_7\t\t0x000804\n#define REG_8\t\t0x000820\n#define REG_9\t\t0x000a04\n#define REG_10\t\t0x018000\n#define REG_11\t\t0x018004\n#define REG_12\t\t0x01800c\n#define REG_13\t\t0x018018\n#define REG_14  \t0x01801c\n#define REG_15\t\t0x200000\n#define REG_15b0\t0x200000\n#define REG_16b1\t0x200005\n#define REG_16b3\t0x200007\n#define REG_21\t\t0x200218\n#define REG_22\t\t0x0005a0\n#define REG_23\t\t0x0005c0\n#define REG_24\t\t0x000808\n#define REG_25\t\t0x000b00\n#define REG_26\t\t0x200118\n#define REG_27\t\t0x200308\n#define REG_32\t\t0x21003c\n#define REG_33\t\t0x210040\n#define REG_34\t\t0x200008\n#define REG_35\t\t0x018010\n#define REG_38\t\t0x210020\n#define REG_39\t\t0x210120\n#define REG_40\t\t0x210130\n#define REG_42\t\t0x210028\n#define REG_43\t\t0x21002c\n#define REG_44\t\t0x210030\n#define REG_45\t\t0x210034\n\n#define READ_BYTE(fb,reg)\t\tgsc_readb((fb)->info.fix.mmio_start + (reg))\n#define READ_WORD(fb,reg)\t\tgsc_readl((fb)->info.fix.mmio_start + (reg))\n\n\n#ifndef DEBUG_STIFB_REGS\n# define  DEBUG_OFF()\n# define  DEBUG_ON()\n# define WRITE_BYTE(value,fb,reg)\tgsc_writeb((value),(fb)->info.fix.mmio_start + (reg))\n# define WRITE_WORD(value,fb,reg)\tgsc_writel((value),(fb)->info.fix.mmio_start + (reg))\n#else\n  static int debug_on = 1;\n# define  DEBUG_OFF() debug_on=0\n# define  DEBUG_ON()  debug_on=1\n# define WRITE_BYTE(value,fb,reg)\tdo { if (debug_on) \\\n\t\t\t\t\t\tprintk(KERN_DEBUG \"%30s: WRITE_BYTE(0x%06x) = 0x%02x (old=0x%02x)\\n\", \\\n\t\t\t\t\t\t\t__func__, reg, value, READ_BYTE(fb,reg)); \t\t  \\\n\t\t\t\t\tgsc_writeb((value),(fb)->info.fix.mmio_start + (reg)); } while (0)\n# define WRITE_WORD(value,fb,reg)\tdo { if (debug_on) \\\n\t\t\t\t\t\tprintk(KERN_DEBUG \"%30s: WRITE_WORD(0x%06x) = 0x%08x (old=0x%08x)\\n\", \\\n\t\t\t\t\t\t\t__func__, reg, value, READ_WORD(fb,reg)); \t\t  \\\n\t\t\t\t\tgsc_writel((value),(fb)->info.fix.mmio_start + (reg)); } while (0)\n#endif  \n\n\n#define ENABLE\t1\t \n#define DISABLE 0\n\n#define NGLE_LOCK(fb_info)\tdo { } while (0)\n#define NGLE_UNLOCK(fb_info)\tdo { } while (0)\n\nstatic void\nSETUP_HW(struct stifb_info *fb)\n{\n\tchar stat;\n\n\tdo {\n\t\tstat = READ_BYTE(fb, REG_15b0);\n\t\tif (!stat)\n\t    \t\tstat = READ_BYTE(fb, REG_15b0);\n\t} while (stat);\n}\n\n\nstatic void\nSETUP_FB(struct stifb_info *fb)\n{\n\tunsigned int reg10_value = 0;\n\n\tSETUP_HW(fb);\n\tswitch (fb->id)\n\t{\n\t\tcase CRT_ID_VISUALIZE_EG:\n\t\tcase S9000_ID_ARTIST:\n\t\tcase S9000_ID_A1659A:\n\t\t\treg10_value = 0x13601000;\n\t\t\tbreak;\n\t\tcase S9000_ID_A1439A:\n\t\t\tif (fb->info.var.bits_per_pixel == 32)\n\t\t\t\treg10_value = 0xBBA0A000;\n\t\t\telse\n\t\t\t\treg10_value = 0x13601000;\n\t\t\tbreak;\n\t\tcase S9000_ID_HCRX:\n\t\t\tif (fb->info.var.bits_per_pixel == 32)\n\t\t\t\treg10_value = 0xBBA0A000;\n\t\t\telse\n\t\t\t\treg10_value = 0x13602000;\n\t\t\tbreak;\n\t\tcase S9000_ID_TIMBER:\n\t\tcase CRX24_OVERLAY_PLANES:\n\t\t\treg10_value = 0x13602000;\n\t\t\tbreak;\n\t}\n\tif (reg10_value)\n\t\tWRITE_WORD(reg10_value, fb, REG_10);\n\tWRITE_WORD(0x83000300, fb, REG_14);\n\tSETUP_HW(fb);\n\tWRITE_BYTE(1, fb, REG_16b1);\n}\n\nstatic void\nSTART_IMAGE_COLORMAP_ACCESS(struct stifb_info *fb)\n{\n\tSETUP_HW(fb);\n\tWRITE_WORD(0xBBE0F000, fb, REG_10);\n\tWRITE_WORD(0x03000300, fb, REG_14);\n\tWRITE_WORD(~0, fb, REG_13);\n}\n\nstatic void\nWRITE_IMAGE_COLOR(struct stifb_info *fb, int index, int color)\n{\n\tSETUP_HW(fb);\n\tWRITE_WORD(((0x100+index)<<2), fb, REG_3);\n\tWRITE_WORD(color, fb, REG_4);\n}\n\nstatic void\nFINISH_IMAGE_COLORMAP_ACCESS(struct stifb_info *fb)\n{\n\tWRITE_WORD(0x400, fb, REG_2);\n\tif (fb->info.var.bits_per_pixel == 32) {\n\t\tWRITE_WORD(0x83000100, fb, REG_1);\n\t} else {\n\t\tif (fb->id == S9000_ID_ARTIST || fb->id == CRT_ID_VISUALIZE_EG)\n\t\t\tWRITE_WORD(0x80000100, fb, REG_26);\n\t\telse\n\t\t\tWRITE_WORD(0x80000100, fb, REG_1);\n\t}\n\tSETUP_FB(fb);\n}\n\nstatic void\nSETUP_RAMDAC(struct stifb_info *fb)\n{\n\tSETUP_HW(fb);\n\tWRITE_WORD(0x04000000, fb, 0x1020);\n\tWRITE_WORD(0xff000000, fb, 0x1028);\n}\n\nstatic void\nCRX24_SETUP_RAMDAC(struct stifb_info *fb)\n{\n\tSETUP_HW(fb);\n\tWRITE_WORD(0x04000000, fb, 0x1000);\n\tWRITE_WORD(0x02000000, fb, 0x1004);\n\tWRITE_WORD(0xff000000, fb, 0x1008);\n\tWRITE_WORD(0x05000000, fb, 0x1000);\n\tWRITE_WORD(0x02000000, fb, 0x1004);\n\tWRITE_WORD(0x03000000, fb, 0x1008);\n}\n\n#if 0\nstatic void\nHCRX_SETUP_RAMDAC(struct stifb_info *fb)\n{\n\tWRITE_WORD(0xffffffff, fb, REG_32);\n}\n#endif\n\nstatic void\nCRX24_SET_OVLY_MASK(struct stifb_info *fb)\n{\n\tSETUP_HW(fb);\n\tWRITE_WORD(0x13a02000, fb, REG_11);\n\tWRITE_WORD(0x03000300, fb, REG_14);\n\tWRITE_WORD(0x000017f0, fb, REG_3);\n\tWRITE_WORD(0xffffffff, fb, REG_13);\n\tWRITE_WORD(0xffffffff, fb, REG_22);\n\tWRITE_WORD(0x00000000, fb, REG_23);\n}\n\nstatic void\nENABLE_DISABLE_DISPLAY(struct stifb_info *fb, int enable)\n{\n\tunsigned int value = enable ? 0x43000000 : 0x03000000;\n        SETUP_HW(fb);\n        WRITE_WORD(0x06000000,\tfb, 0x1030);\n        WRITE_WORD(value, \tfb, 0x1038);\n}\n\nstatic void\nCRX24_ENABLE_DISABLE_DISPLAY(struct stifb_info *fb, int enable)\n{\n\tunsigned int value = enable ? 0x10000000 : 0x30000000;\n\tSETUP_HW(fb);\n\tWRITE_WORD(0x01000000,\tfb, 0x1000);\n\tWRITE_WORD(0x02000000,\tfb, 0x1004);\n\tWRITE_WORD(value,\tfb, 0x1008);\n}\n\nstatic void\nARTIST_ENABLE_DISABLE_DISPLAY(struct stifb_info *fb, int enable)\n{\n\tu32 DregsMiscVideo = REG_21;\n\tu32 DregsMiscCtl = REG_27;\n\n\tSETUP_HW(fb);\n\tif (enable) {\n\t  WRITE_WORD(READ_WORD(fb, DregsMiscVideo) | 0x0A000000, fb, DregsMiscVideo);\n\t  WRITE_WORD(READ_WORD(fb, DregsMiscCtl)   | 0x00800000, fb, DregsMiscCtl);\n\t} else {\n\t  WRITE_WORD(READ_WORD(fb, DregsMiscVideo) & ~0x0A000000, fb, DregsMiscVideo);\n\t  WRITE_WORD(READ_WORD(fb, DregsMiscCtl)   & ~0x00800000, fb, DregsMiscCtl);\n\t}\n}\n\n#define GET_ROMTABLE_INDEX(fb) \\\n\t(READ_BYTE(fb, REG_16b3) - 1)\n\n#define HYPER_CONFIG_PLANES_24 0x00000100\n\n#define IS_24_DEVICE(fb) \\\n\t(fb->deviceSpecificConfig & HYPER_CONFIG_PLANES_24)\n\n#define IS_888_DEVICE(fb) \\\n\t(!(IS_24_DEVICE(fb)))\n\n#define GET_FIFO_SLOTS(fb, cnt, numslots)\t\\\n{\twhile (cnt < numslots) \t\t\t\\\n\t\tcnt = READ_WORD(fb, REG_34);\t\\\n\tcnt -= numslots;\t\t\t\\\n}\n\n#define\t    IndexedDcd\t0\t \n#define\t    Otc04\t2\t \n#define\t    Otc32\t5\t \n#define\t    Ots08\t3\t \n#define\t    OtsIndirect\t6\t \n#define\t    AddrLong\t5\t \n#define\t    BINovly\t0x2\t \n#define\t    BINapp0I\t0x0\t \n#define\t    BINapp1I\t0x1\t \n#define\t    BINapp0F8\t0xa\t \n#define\t    BINattr\t0xd\t \n#define\t    RopSrc \t0x3\n#define\t    BitmapExtent08  3\t \n#define\t    BitmapExtent32  5\t \n#define\t    DataDynamic\t    0\t \n#define\t    MaskDynamic\t    1\t \n#define\t    MaskOtc\t    0\t \n\n#define MaskAddrOffset(offset) (offset)\n#define StaticReg(en) (en)\n#define BGx(en) (en)\n#define FGx(en) (en)\n\n#define BAJustPoint(offset) (offset)\n#define BAIndexBase(base) (base)\n#define BA(F,C,S,A,J,B,I) \\\n\t(((F)<<31)|((C)<<27)|((S)<<24)|((A)<<21)|((J)<<16)|((B)<<12)|(I))\n\n#define IBOvals(R,M,X,S,D,L,B,F) \\\n\t(((R)<<8)|((M)<<16)|((X)<<24)|((S)<<29)|((D)<<28)|((L)<<31)|((B)<<1)|(F))\n\n#define NGLE_QUICK_SET_IMAGE_BITMAP_OP(fb, val) \\\n\tWRITE_WORD(val, fb, REG_14)\n\n#define NGLE_QUICK_SET_DST_BM_ACCESS(fb, val) \\\n\tWRITE_WORD(val, fb, REG_11)\n\n#define NGLE_QUICK_SET_CTL_PLN_REG(fb, val) \\\n\tWRITE_WORD(val, fb, REG_12)\n\n#define NGLE_REALLY_SET_IMAGE_PLANEMASK(fb, plnmsk32) \\\n\tWRITE_WORD(plnmsk32, fb, REG_13)\n\n#define NGLE_REALLY_SET_IMAGE_FG_COLOR(fb, fg32) \\\n\tWRITE_WORD(fg32, fb, REG_35)\n\n#define NGLE_SET_TRANSFERDATA(fb, val) \\\n\tWRITE_WORD(val, fb, REG_8)\n\n#define NGLE_SET_DSTXY(fb, val) \\\n\tWRITE_WORD(val, fb, REG_6)\n\n#define NGLE_LONG_FB_ADDRESS(fbaddrbase, x, y) (\t\t\\\n\t(u32) (fbaddrbase) +\t\t\t\t\t\\\n\t    (\t(unsigned int)  ( (y) << 13      ) |\t\t\\\n\t\t(unsigned int)  ( (x) << 2       )\t)\t\\\n\t)\n\n#define NGLE_BINC_SET_DSTADDR(fb, addr) \\\n\tWRITE_WORD(addr, fb, REG_3)\n\n#define NGLE_BINC_SET_SRCADDR(fb, addr) \\\n\tWRITE_WORD(addr, fb, REG_2)\n\n#define NGLE_BINC_SET_DSTMASK(fb, mask) \\\n\tWRITE_WORD(mask, fb, REG_22)\n\n#define NGLE_BINC_WRITE32(fb, data32) \\\n\tWRITE_WORD(data32, fb, REG_23)\n\n#define START_COLORMAPLOAD(fb, cmapBltCtlData32) \\\n\tWRITE_WORD((cmapBltCtlData32), fb, REG_38)\n\n#define SET_LENXY_START_RECFILL(fb, lenxy) \\\n\tWRITE_WORD(lenxy, fb, REG_9)\n\n#define SETUP_COPYAREA(fb) \\\n\tWRITE_BYTE(0, fb, REG_16b1)\n\nstatic void\nHYPER_ENABLE_DISABLE_DISPLAY(struct stifb_info *fb, int enable)\n{\n\tu32 DregsHypMiscVideo = REG_33;\n\tunsigned int value;\n\tSETUP_HW(fb);\n\tvalue = READ_WORD(fb, DregsHypMiscVideo);\n\tif (enable)\n\t\tvalue |= 0x0A000000;\n\telse\n\t\tvalue &= ~0x0A000000;\n\tWRITE_WORD(value, fb, DregsHypMiscVideo);\n}\n\n\n \n#define BUFF0_CMAP0\t0x00001e02\n#define BUFF1_CMAP0\t0x02001e02\n#define BUFF1_CMAP3\t0x0c001e02\n#define ARTIST_CMAP0\t0x00000102\n#define HYPER_CMAP8\t0x00000100\n#define HYPER_CMAP24\t0x00000800\n\nstatic void\nSETUP_ATTR_ACCESS(struct stifb_info *fb, unsigned BufferNumber)\n{\n\tSETUP_HW(fb);\n\tWRITE_WORD(0x2EA0D000, fb, REG_11);\n\tWRITE_WORD(0x23000302, fb, REG_14);\n\tWRITE_WORD(BufferNumber, fb, REG_12);\n\tWRITE_WORD(0xffffffff, fb, REG_8);\n}\n\nstatic void\nSET_ATTR_SIZE(struct stifb_info *fb, int width, int height)\n{\n\t \n\tWRITE_WORD(0x00000000, fb, REG_6);\n\tWRITE_WORD((width<<16) | height, fb, REG_9);\n\tWRITE_WORD(0x05000000, fb, REG_6);\n\tWRITE_WORD(0x00040001, fb, REG_9);\n}\n\nstatic void\nFINISH_ATTR_ACCESS(struct stifb_info *fb)\n{\n\tSETUP_HW(fb);\n\tWRITE_WORD(0x00000000, fb, REG_12);\n}\n\nstatic void\nelkSetupPlanes(struct stifb_info *fb)\n{\n\tSETUP_RAMDAC(fb);\n\tSETUP_FB(fb);\n}\n\nstatic void\nngleSetupAttrPlanes(struct stifb_info *fb, int BufferNumber)\n{\n\tSETUP_ATTR_ACCESS(fb, BufferNumber);\n\tSET_ATTR_SIZE(fb, fb->info.var.xres, fb->info.var.yres);\n\tFINISH_ATTR_ACCESS(fb);\n\tSETUP_FB(fb);\n}\n\n\nstatic void\nrattlerSetupPlanes(struct stifb_info *fb)\n{\n\tint saved_id, y;\n\n \t \n\tCRX24_SETUP_RAMDAC(fb);\n\n\t \n\tsaved_id = fb->id;\n\tfb->id = CRX24_OVERLAY_PLANES;\n\tSETUP_FB(fb);\n\tfb->id = saved_id;\n\n\tfor (y = 0; y < fb->info.var.yres; ++y)\n\t\tfb_memset_io(fb->info.screen_base + y * fb->info.fix.line_length,\n\t\t\t     0xff, fb->info.var.xres * fb->info.var.bits_per_pixel/8);\n\n\tCRX24_SET_OVLY_MASK(fb);\n\tSETUP_FB(fb);\n}\n\n\n#define HYPER_CMAP_TYPE\t\t\t\t0\n#define NGLE_CMAP_INDEXED0_TYPE\t\t\t0\n#define NGLE_CMAP_OVERLAY_TYPE\t\t\t3\n\n \ntypedef union\t \n{\tu32 all;\n\tstruct\n\t{\n\t\tunsigned enable              :  1;\n\t\tunsigned waitBlank           :  1;\n\t\tunsigned reserved1           :  4;\n\t\tunsigned lutOffset           : 10;    \n\t\tunsigned lutType             :  2;    \n\t\tunsigned reserved2           :  4;\n\t\tunsigned length              : 10;\n\t} fields;\n} NgleLutBltCtl;\n\n\n#if 0\nstatic NgleLutBltCtl\nsetNgleLutBltCtl(struct stifb_info *fb, int offsetWithinLut, int length)\n{\n\tNgleLutBltCtl lutBltCtl;\n\n\t \n\tlutBltCtl.all           = 0x80000000;\n\tlutBltCtl.fields.length = length;\n\n\tswitch (fb->id)\n\t{\n\tcase S9000_ID_A1439A:\t\t \n\t\tif (fb->var.bits_per_pixel == 8) {\n\t\t\tlutBltCtl.fields.lutType = NGLE_CMAP_OVERLAY_TYPE;\n\t\t\tlutBltCtl.fields.lutOffset = 0;\n\t\t} else {\n\t\t\tlutBltCtl.fields.lutType = NGLE_CMAP_INDEXED0_TYPE;\n\t\t\tlutBltCtl.fields.lutOffset = 0 * 256;\n\t\t}\n\t\tbreak;\n\n\tcase S9000_ID_ARTIST:\n\t\tlutBltCtl.fields.lutType = NGLE_CMAP_INDEXED0_TYPE;\n\t\tlutBltCtl.fields.lutOffset = 0 * 256;\n\t\tbreak;\n\n\tdefault:\n\t\tlutBltCtl.fields.lutType = NGLE_CMAP_INDEXED0_TYPE;\n\t\tlutBltCtl.fields.lutOffset = 0;\n\t\tbreak;\n\t}\n\n\t \n\tlutBltCtl.fields.lutOffset += offsetWithinLut;\n\n\treturn lutBltCtl;\n}\n#endif\n\nstatic NgleLutBltCtl\nsetHyperLutBltCtl(struct stifb_info *fb, int offsetWithinLut, int length)\n{\n\tNgleLutBltCtl lutBltCtl;\n\n\t \n\tlutBltCtl.all = 0x80000000;\n\n\tlutBltCtl.fields.length = length;\n\tlutBltCtl.fields.lutType = HYPER_CMAP_TYPE;\n\n\t \n\tif (fb->info.var.bits_per_pixel == 8)\n\t\tlutBltCtl.fields.lutOffset = 2 * 256;\n\telse\n\t\tlutBltCtl.fields.lutOffset = 0 * 256;\n\n\t \n\tlutBltCtl.fields.lutOffset += offsetWithinLut;\n\n\treturn lutBltCtl;\n}\n\n\nstatic void hyperUndoITE(struct stifb_info *fb)\n{\n\tint nFreeFifoSlots = 0;\n\tu32 fbAddr;\n\n\tNGLE_LOCK(fb);\n\n\tGET_FIFO_SLOTS(fb, nFreeFifoSlots, 1);\n\tWRITE_WORD(0xffffffff, fb, REG_32);\n\n\t \n\n\t \n\tGET_FIFO_SLOTS(fb, nFreeFifoSlots, 7);\n\tNGLE_QUICK_SET_DST_BM_ACCESS(fb,\n\t\tBA(IndexedDcd, Otc04, Ots08, AddrLong,\n\t\tBAJustPoint(0), BINovly, BAIndexBase(0)));\n\tNGLE_QUICK_SET_IMAGE_BITMAP_OP(fb,\n\t\tIBOvals(RopSrc, MaskAddrOffset(0),\n\t\tBitmapExtent08, StaticReg(0),\n\t\tDataDynamic, MaskOtc, BGx(0), FGx(0)));\n\n\t \n\tfbAddr = NGLE_LONG_FB_ADDRESS(0, 1532, 0);\n\tNGLE_BINC_SET_DSTADDR(fb, fbAddr);\n\tNGLE_REALLY_SET_IMAGE_PLANEMASK(fb, 0xffffff);\n\tNGLE_BINC_SET_DSTMASK(fb, 0xffffffff);\n\n\t \n\tNGLE_BINC_WRITE32(fb, 0);\n\n\tNGLE_UNLOCK(fb);\n}\n\nstatic void\nngleDepth8_ClearImagePlanes(struct stifb_info *fb)\n{\n\t \n}\n\nstatic void\nngleDepth24_ClearImagePlanes(struct stifb_info *fb)\n{\n\t \n}\n\nstatic void\nngleResetAttrPlanes(struct stifb_info *fb, unsigned int ctlPlaneReg)\n{\n\tint nFreeFifoSlots = 0;\n\tu32 packed_dst;\n\tu32 packed_len;\n\n\tNGLE_LOCK(fb);\n\n\tGET_FIFO_SLOTS(fb, nFreeFifoSlots, 4);\n\tNGLE_QUICK_SET_DST_BM_ACCESS(fb,\n\t\t\t\t     BA(IndexedDcd, Otc32, OtsIndirect,\n\t\t\t\t\tAddrLong, BAJustPoint(0),\n\t\t\t\t\tBINattr, BAIndexBase(0)));\n\tNGLE_QUICK_SET_CTL_PLN_REG(fb, ctlPlaneReg);\n\tNGLE_SET_TRANSFERDATA(fb, 0xffffffff);\n\n\tNGLE_QUICK_SET_IMAGE_BITMAP_OP(fb,\n\t\t\t\t       IBOvals(RopSrc, MaskAddrOffset(0),\n\t\t\t\t\t       BitmapExtent08, StaticReg(1),\n\t\t\t\t\t       DataDynamic, MaskOtc,\n\t\t\t\t\t       BGx(0), FGx(0)));\n\tpacked_dst = 0;\n\tpacked_len = (fb->info.var.xres << 16) | fb->info.var.yres;\n\tGET_FIFO_SLOTS(fb, nFreeFifoSlots, 2);\n\tNGLE_SET_DSTXY(fb, packed_dst);\n\tSET_LENXY_START_RECFILL(fb, packed_len);\n\n\t \n\n\tif (fb->id == S9000_ID_A1659A) {    \n\t\t \n\t\tpacked_dst = (1280 << 16);\n\t\tGET_FIFO_SLOTS(fb, nFreeFifoSlots, 2);\n\t\tNGLE_SET_DSTXY(fb, packed_dst);\n\t\tpacked_len = (4 << 16) | 1;\n\t\tSET_LENXY_START_RECFILL(fb, packed_len);\n\t}    \n\n\t \n\tGET_FIFO_SLOTS(fb, nFreeFifoSlots, 1);\n\tNGLE_QUICK_SET_CTL_PLN_REG(fb, 0);\n\n\tNGLE_UNLOCK(fb);\n}\n\nstatic void\nngleClearOverlayPlanes(struct stifb_info *fb, int mask, int data)\n{\n\tint nFreeFifoSlots = 0;\n\tu32 packed_dst;\n\tu32 packed_len;\n\n\tNGLE_LOCK(fb);\n\n\t \n\tGET_FIFO_SLOTS(fb, nFreeFifoSlots, 8);\n\tNGLE_QUICK_SET_DST_BM_ACCESS(fb,\n\t\t\t\t     BA(IndexedDcd, Otc04, Ots08, AddrLong,\n\t\t\t\t\tBAJustPoint(0), BINovly, BAIndexBase(0)));\n\n        NGLE_SET_TRANSFERDATA(fb, 0xffffffff);   \n\n        NGLE_REALLY_SET_IMAGE_FG_COLOR(fb, data);\n        NGLE_REALLY_SET_IMAGE_PLANEMASK(fb, mask);\n\n        packed_dst = 0;\n        packed_len = (fb->info.var.xres << 16) | fb->info.var.yres;\n        NGLE_SET_DSTXY(fb, packed_dst);\n\n\t \n\tNGLE_QUICK_SET_IMAGE_BITMAP_OP(fb,\n\t\t\t\t       IBOvals(RopSrc, MaskAddrOffset(0),\n\t\t\t\t\t       BitmapExtent08, StaticReg(0),\n\t\t\t\t\t       DataDynamic, MaskOtc, BGx(0), FGx(0)));\n\n        SET_LENXY_START_RECFILL(fb, packed_len);\n\n\tNGLE_UNLOCK(fb);\n}\n\nstatic void\nhyperResetPlanes(struct stifb_info *fb, int enable)\n{\n\tunsigned int controlPlaneReg;\n\n\tNGLE_LOCK(fb);\n\n\tif (IS_24_DEVICE(fb))\n\t\tif (fb->info.var.bits_per_pixel == 32)\n\t\t\tcontrolPlaneReg = 0x04000F00;\n\t\telse\n\t\t\tcontrolPlaneReg = 0x00000F00;    \n\telse\n\t\tcontrolPlaneReg = 0x00000F00;  \n\n\tswitch (enable) {\n\tcase ENABLE:\n\t\t \n\t\tif (IS_24_DEVICE(fb))\n\t\t\tngleDepth24_ClearImagePlanes(fb);\n\t\telse\n\t\t\tngleDepth8_ClearImagePlanes(fb);\n\n\t\t \n\t\tngleResetAttrPlanes(fb, controlPlaneReg);\n\n\t\t \n\t        ngleClearOverlayPlanes(fb, 0xff, 255);\n\n\t\t \n\t\thyperUndoITE(fb);\n\t\tbreak;\n\n\tcase DISABLE:\n\t\t \n\t\tif (IS_24_DEVICE(fb))\n\t\t\tngleDepth24_ClearImagePlanes(fb);\n\t\telse\n\t\t\tngleDepth8_ClearImagePlanes(fb);\n\t\tngleResetAttrPlanes(fb, controlPlaneReg);\n\t\tngleClearOverlayPlanes(fb, 0xff, 0);\n\t\tbreak;\n\n\tcase -1:\t \n\t\thyperUndoITE(fb);\n\t\tngleResetAttrPlanes(fb, controlPlaneReg);\n\t\tbreak;\n    \t}\n\n\tNGLE_UNLOCK(fb);\n}\n\n \n\nstatic void\nngleGetDeviceRomData(struct stifb_info *fb)\n{\n#if 0\nXXX: FIXME: !!!\n\tint\t*pBytePerLongDevDepData; \n\tint \t*pRomTable;\n\tNgleDevRomData\t*pPackedDevRomData;\n\tint\tsizePackedDevRomData = sizeof(*pPackedDevRomData);\n\tchar\t*pCard8;\n\tint\ti;\n\tchar\t*mapOrigin = NULL;\n\n\tint romTableIdx;\n\n\tpPackedDevRomData = fb->ngle_rom;\n\n\tSETUP_HW(fb);\n\tif (fb->id == S9000_ID_ARTIST) {\n\t\tpPackedDevRomData->cursor_pipeline_delay = 4;\n\t\tpPackedDevRomData->video_interleaves     = 4;\n\t} else {\n\t\t \n\t\tpBytePerLongDevDepData = fb->sti->regions[NGLEDEVDEPROM_CRT_REGION];\n\n\t\t \n\t\tif (fb->id == S9000_ID_TOMCAT)\n\t{\n\t     \n\t    GET_ROMTABLE_INDEX(romTableIdx);\n\t    while  (romTableIdx > 0)\n\t    {\n\t\tpCard8 = (Card8 *) pPackedDevRomData;\n\t\tpRomTable = pBytePerLongDevDepData;\n\t\t \n\t\tfor (i = 0; i < sizePackedDevRomData; i++)\n\t\t{\n\t\t    *pCard8++ = (Card8) (*pRomTable++);\n\t\t}\n\n\t\tpBytePerLongDevDepData = (Card32 *)\n\t\t\t((Card8 *) pBytePerLongDevDepData +\n\t\t\t       pPackedDevRomData->sizeof_ngle_data);\n\n\t\tromTableIdx--;\n\t    }\n\t}\n\n\tpCard8 = (Card8 *) pPackedDevRomData;\n\n\t \n\tfor (i = 0; i < sizePackedDevRomData; i++)\n\t{\n\t    *pCard8++ = (Card8) (*pBytePerLongDevDepData++);\n\t}\n    }\n\n    SETUP_FB(fb);\n#endif\n}\n\n\n#define HYPERBOWL_MODE_FOR_8_OVER_88_LUT0_NO_TRANSPARENCIES\t4\n#define HYPERBOWL_MODE01_8_24_LUT0_TRANSPARENT_LUT1_OPAQUE\t8\n#define HYPERBOWL_MODE01_8_24_LUT0_OPAQUE_LUT1_OPAQUE\t\t10\n#define HYPERBOWL_MODE2_8_24\t\t\t\t\t15\n\n \nstatic void __init\nSETUP_HCRX(struct stifb_info *fb)\n{\n\tint\thyperbowl;\n        int\tnFreeFifoSlots = 0;\n\n\tif (fb->id != S9000_ID_HCRX)\n\t\treturn;\n\n\t \n\tGET_FIFO_SLOTS(fb, nFreeFifoSlots, 7);\n\n\tif (IS_24_DEVICE(fb)) {\n\t\thyperbowl = (fb->info.var.bits_per_pixel == 32) ?\n\t\t\tHYPERBOWL_MODE01_8_24_LUT0_TRANSPARENT_LUT1_OPAQUE :\n\t\t\tHYPERBOWL_MODE01_8_24_LUT0_OPAQUE_LUT1_OPAQUE;\n\n\t\t \n\t\tWRITE_WORD(hyperbowl, fb, REG_40);\n\t\tWRITE_WORD(hyperbowl, fb, REG_40);\n\n\t\tWRITE_WORD(HYPERBOWL_MODE2_8_24, fb, REG_39);\n\n\t\tWRITE_WORD(0x014c0148, fb, REG_42);  \n\t\tWRITE_WORD(0x404c4048, fb, REG_43);\n\t\tWRITE_WORD(0x034c0348, fb, REG_44);\n\t\tWRITE_WORD(0x444c4448, fb, REG_45);\n\t} else {\n\t\thyperbowl = HYPERBOWL_MODE_FOR_8_OVER_88_LUT0_NO_TRANSPARENCIES;\n\n\t\t \n\t\tWRITE_WORD(hyperbowl, fb, REG_40);\n\t\tWRITE_WORD(hyperbowl, fb, REG_40);\n\n\t\tWRITE_WORD(0x00000000, fb, REG_42);\n\t\tWRITE_WORD(0x00000000, fb, REG_43);\n\t\tWRITE_WORD(0x00000000, fb, REG_44);\n\t\tWRITE_WORD(0x444c4048, fb, REG_45);\n\t}\n}\n\n\n \n\nstatic int\nstifb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct stifb_info *fb = container_of(info, struct stifb_info, info);\n\n\tif (var->xres != fb->info.var.xres ||\n\t    var->yres != fb->info.var.yres ||\n\t    var->bits_per_pixel != fb->info.var.bits_per_pixel)\n\t\treturn -EINVAL;\n\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = var->yres;\n\tvar->xoffset = 0;\n\tvar->yoffset = 0;\n\tvar->grayscale = fb->info.var.grayscale;\n\tvar->red.length = fb->info.var.red.length;\n\tvar->green.length = fb->info.var.green.length;\n\tvar->blue.length = fb->info.var.blue.length;\n\n\treturn 0;\n}\n\nstatic int\nstifb_setcolreg(u_int regno, u_int red, u_int green,\n\t      u_int blue, u_int transp, struct fb_info *info)\n{\n\tstruct stifb_info *fb = container_of(info, struct stifb_info, info);\n\tu32 color;\n\n\tif (regno >= NR_PALETTE)\n\t\treturn 1;\n\n\tred   >>= 8;\n\tgreen >>= 8;\n\tblue  >>= 8;\n\n\tDEBUG_OFF();\n\n\tSTART_IMAGE_COLORMAP_ACCESS(fb);\n\n\tif (unlikely(fb->info.var.grayscale)) {\n\t\t \n\t\tcolor = ((red * 77) +\n\t\t\t (green * 151) +\n\t\t\t (blue * 28)) >> 8;\n\t} else {\n\t\tcolor = ((red << 16) |\n\t\t\t (green << 8) |\n\t\t\t (blue));\n\t}\n\n\tif (fb->info.fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\tstruct fb_var_screeninfo *var = &fb->info.var;\n\t\tif (regno < 16)\n\t\t\t((u32 *)fb->info.pseudo_palette)[regno] =\n\t\t\t\tregno << var->red.offset |\n\t\t\t\tregno << var->green.offset |\n\t\t\t\tregno << var->blue.offset;\n\t}\n\n\tWRITE_IMAGE_COLOR(fb, regno, color);\n\n\tif (fb->id == S9000_ID_HCRX) {\n\t\tNgleLutBltCtl lutBltCtl;\n\n\t\tlutBltCtl = setHyperLutBltCtl(fb,\n\t\t\t\t0,\t \n\t\t\t\t256);\t \n\t\tNGLE_BINC_SET_SRCADDR(fb,\n\t\t\t\tNGLE_LONG_FB_ADDRESS(0, 0x100, 0));\n\t\t\t\t \n\t\tSTART_COLORMAPLOAD(fb, lutBltCtl.all);\n\t\tSETUP_FB(fb);\n\t} else {\n\t\t \n\t\tFINISH_IMAGE_COLORMAP_ACCESS(fb);\n\t}\n\n\tDEBUG_ON();\n\n\treturn 0;\n}\n\nstatic int\nstifb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct stifb_info *fb = container_of(info, struct stifb_info, info);\n\tint enable = (blank_mode == 0) ? ENABLE : DISABLE;\n\n\tswitch (fb->id) {\n\tcase S9000_ID_A1439A:\n\t\tCRX24_ENABLE_DISABLE_DISPLAY(fb, enable);\n\t\tbreak;\n\tcase CRT_ID_VISUALIZE_EG:\n\tcase S9000_ID_ARTIST:\n\t\tARTIST_ENABLE_DISABLE_DISPLAY(fb, enable);\n\t\tbreak;\n\tcase S9000_ID_HCRX:\n\t\tHYPER_ENABLE_DISABLE_DISPLAY(fb, enable);\n\t\tbreak;\n\tcase S9000_ID_A1659A:\n\tcase S9000_ID_TIMBER:\n\tcase CRX24_OVERLAY_PLANES:\n\tdefault:\n\t\tENABLE_DISABLE_DISPLAY(fb, enable);\n\t\tbreak;\n\t}\n\n\tSETUP_FB(fb);\n\treturn 0;\n}\n\nstatic void\nstifb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tstruct stifb_info *fb = container_of(info, struct stifb_info, info);\n\n\tSETUP_COPYAREA(fb);\n\n\tSETUP_HW(fb);\n\tif (fb->info.var.bits_per_pixel == 32) {\n\t\tWRITE_WORD(0xBBA0A000, fb, REG_10);\n\n\t\tNGLE_REALLY_SET_IMAGE_PLANEMASK(fb, 0xffffffff);\n\t} else {\n\t\tWRITE_WORD(fb->id == S9000_ID_HCRX ? 0x13a02000 : 0x13a01000, fb, REG_10);\n\n\t\tNGLE_REALLY_SET_IMAGE_PLANEMASK(fb, 0xff);\n\t}\n\n\tNGLE_QUICK_SET_IMAGE_BITMAP_OP(fb,\n\t\tIBOvals(RopSrc, MaskAddrOffset(0),\n\t\tBitmapExtent08, StaticReg(1),\n\t\tDataDynamic, MaskOtc, BGx(0), FGx(0)));\n\n\tWRITE_WORD(((area->sx << 16) | area->sy), fb, REG_24);\n\tWRITE_WORD(((area->width << 16) | area->height), fb, REG_7);\n\tWRITE_WORD(((area->dx << 16) | area->dy), fb, REG_25);\n\n\tSETUP_FB(fb);\n}\n\n#define ARTIST_VRAM_SIZE\t\t\t0x000804\n#define ARTIST_VRAM_SRC\t\t\t\t0x000808\n#define ARTIST_VRAM_SIZE_TRIGGER_WINFILL\t0x000a04\n#define ARTIST_VRAM_DEST_TRIGGER_BLOCKMOVE\t0x000b00\n#define ARTIST_SRC_BM_ACCESS\t\t\t0x018008\n#define ARTIST_FGCOLOR\t\t\t\t0x018010\n#define ARTIST_BGCOLOR\t\t\t\t0x018014\n#define ARTIST_BITMAP_OP\t\t\t0x01801c\n\nstatic void\nstifb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct stifb_info *fb = container_of(info, struct stifb_info, info);\n\n\tif (rect->rop != ROP_COPY ||\n\t    (fb->id == S9000_ID_HCRX && fb->info.var.bits_per_pixel == 32))\n\t\treturn cfb_fillrect(info, rect);\n\n\tSETUP_HW(fb);\n\n\tif (fb->info.var.bits_per_pixel == 32) {\n\t\tWRITE_WORD(0xBBA0A000, fb, REG_10);\n\n\t\tNGLE_REALLY_SET_IMAGE_PLANEMASK(fb, 0xffffffff);\n\t} else {\n\t\tWRITE_WORD(fb->id == S9000_ID_HCRX ? 0x13a02000 : 0x13a01000, fb, REG_10);\n\n\t\tNGLE_REALLY_SET_IMAGE_PLANEMASK(fb, 0xff);\n\t}\n\n\tWRITE_WORD(0x03000300, fb, ARTIST_BITMAP_OP);\n\tWRITE_WORD(0x2ea01000, fb, ARTIST_SRC_BM_ACCESS);\n\tNGLE_QUICK_SET_DST_BM_ACCESS(fb, 0x2ea01000);\n\tNGLE_REALLY_SET_IMAGE_FG_COLOR(fb, rect->color);\n\tWRITE_WORD(0, fb, ARTIST_BGCOLOR);\n\n\tNGLE_SET_DSTXY(fb, (rect->dx << 16) | (rect->dy));\n\tSET_LENXY_START_RECFILL(fb, (rect->width << 16) | (rect->height));\n\n\tSETUP_FB(fb);\n}\n\nstatic void __init\nstifb_init_display(struct stifb_info *fb)\n{\n\tint id = fb->id;\n\n\tSETUP_FB(fb);\n\n\t \n\tSETUP_HCRX(fb);\n\n\t \n\n\t \n        switch (id) {\n\t case S9000_ID_HCRX:\n\t    hyperResetPlanes(fb, ENABLE);\n\t    break;\n\t case S9000_ID_A1439A:\n\t    rattlerSetupPlanes(fb);\n\t    break;\n\t case S9000_ID_A1659A:\n\t case S9000_ID_ARTIST:\n\t case CRT_ID_VISUALIZE_EG:\n\t    elkSetupPlanes(fb);\n\t    break;\n\t}\n\n\t \n        switch (id) {\n\t case S9000_ID_A1659A:\n\t case S9000_ID_A1439A:\n\t    if (fb->info.var.bits_per_pixel == 32)\n\t\tngleSetupAttrPlanes(fb, BUFF1_CMAP3);\n\t    else {\n\t\tngleSetupAttrPlanes(fb, BUFF1_CMAP0);\n\t    }\n\t    if (id == S9000_ID_A1439A)\n\t\tngleClearOverlayPlanes(fb, 0xff, 0);\n\t    break;\n\t case S9000_ID_ARTIST:\n\t case CRT_ID_VISUALIZE_EG:\n\t    if (fb->info.var.bits_per_pixel == 32)\n\t\tngleSetupAttrPlanes(fb, BUFF1_CMAP3);\n\t    else {\n\t\tngleSetupAttrPlanes(fb, ARTIST_CMAP0);\n\t    }\n\t    break;\n\t}\n\tstifb_blank(0, (struct fb_info *)fb);\t \n\n\tSETUP_FB(fb);\n}\n\n \n\nstatic const struct fb_ops stifb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= stifb_check_var,\n\t.fb_setcolreg\t= stifb_setcolreg,\n\t.fb_blank\t= stifb_blank,\n\t.fb_fillrect\t= stifb_fillrect,\n\t.fb_copyarea\t= stifb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n};\n\n\n \n\nstatic int __init stifb_init_fb(struct sti_struct *sti, int bpp_pref)\n{\n\tstruct fb_fix_screeninfo *fix;\n\tstruct fb_var_screeninfo *var;\n\tstruct stifb_info *fb;\n\tstruct fb_info *info;\n\tunsigned long sti_rom_address;\n\tchar modestr[32];\n\tchar *dev_name;\n\tint bpp, xres, yres;\n\n\tfb = kzalloc(sizeof(*fb), GFP_ATOMIC);\n\tif (!fb)\n\t\treturn -ENOMEM;\n\n\tinfo = &fb->info;\n\n\t \n\tfix = &info->fix;\n\tvar = &info->var;\n\n\tfb->sti = sti;\n\tdev_name = sti->sti_data->inq_outptr.dev_name;\n\t \n\tfb->id = fb->sti->graphics_id[0];\n\n\t \n\tswitch (fb->id) {\n\tcase CRT_ID_VISUALIZE_EG:\n\t\t \n\t\tif (strstr(dev_name, \"DX\")) {\n\t\t   printk(KERN_WARNING\n\"WARNING: stifb framebuffer driver does not support '%s' in double-buffer mode.\\n\"\n\"WARNING: Please disable the double-buffer mode in IPL menu (the PARISC-BIOS).\\n\",\n\t\t\tdev_name);\n\t\t   goto out_err0;\n\t\t}\n\t\tfallthrough;\n\tcase S9000_ID_ARTIST:\n\tcase S9000_ID_HCRX:\n\tcase S9000_ID_TIMBER:\n\tcase S9000_ID_A1659A:\n\tcase S9000_ID_A1439A:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"stifb: '%s' (id: 0x%08x) not supported.\\n\",\n\t\t\tdev_name, fb->id);\n\t\tgoto out_err0;\n\t}\n\n\t \n\tbpp = 8;\n\txres = sti_onscreen_x(fb->sti);\n\tyres = sti_onscreen_y(fb->sti);\n\n\tngleGetDeviceRomData(fb);\n\n\t \n\tfix->mmio_start = REGION_BASE(fb,2);\n\tfix->mmio_len   = 0x400000;\n\n       \t \n\tswitch (fb->id) {\n\tcase S9000_ID_A1659A:\t \n\t\tbreak;\n\tcase S9000_ID_ELM:\t \n\t\tvar->grayscale = 1;\n\t\tfb->id = S9000_ID_A1659A;\n\t\tbreak;\n\tcase S9000_ID_TIMBER:\t \n\t\tif (strstr(dev_name, \"GRAYSCALE\") ||\n\t\t    strstr(dev_name, \"Grayscale\") ||\n\t\t    strstr(dev_name, \"grayscale\"))\n\t\t\tvar->grayscale = 1;\n\t\tbreak;\n\tcase S9000_ID_TOMCAT:\t \n\t\t \n\t\txres = fb->ngle_rom.x_size_visible;\n\t\tyres = fb->ngle_rom.y_size_visible;\n\t\tfb->id = S9000_ID_A1659A;\n\t\tbreak;\n\tcase S9000_ID_A1439A:\t \n\t\tbpp = 32;\n\t\tbreak;\n\tcase S9000_ID_HCRX:\t \n\t\tmemset(&fb->ngle_rom, 0, sizeof(fb->ngle_rom));\n\t\tif ((fb->sti->regions_phys[0] & 0xfc000000) ==\n\t\t    (fb->sti->regions_phys[2] & 0xfc000000))\n\t\t\tsti_rom_address = F_EXTEND(fb->sti->regions_phys[0]);\n\t\telse\n\t\t\tsti_rom_address = F_EXTEND(fb->sti->regions_phys[1]);\n\n\t\tfb->deviceSpecificConfig = gsc_readl(sti_rom_address);\n\t\tif (IS_24_DEVICE(fb)) {\n\t\t\tif (bpp_pref == 8 || bpp_pref == 32)\n\t\t\t\tbpp = bpp_pref;\n\t\t\telse\n\t\t\t\tbpp = 32;\n\t\t} else\n\t\t\tbpp = 8;\n\t\tREAD_WORD(fb, REG_15);\n\t\tSETUP_HW(fb);\n\t\tbreak;\n\tcase CRT_ID_VISUALIZE_EG:\n\tcase S9000_ID_ARTIST:\t \n\t\tbreak;\n\tdefault:\n#ifdef FALLBACK_TO_1BPP\n\t\tprintk(KERN_WARNING\n\t\t\t\"stifb: Unsupported graphics card (id=0x%08x) \"\n\t\t\t\t\"- now trying 1bpp mode instead\\n\",\n\t\t\tfb->id);\n\t\tbpp = 1;\t \n\t\tbreak;\n#else\n\t\tprintk(KERN_WARNING\n\t\t\t\"stifb: Unsupported graphics card (id=0x%08x) \"\n\t\t\t\t\"- skipping.\\n\",\n\t\t\tfb->id);\n\t\tgoto out_err0;\n#endif\n\t}\n\n\n\t \n\tfix->smem_start = F_EXTEND(fb->sti->regions_phys[1]);\n\tfix->smem_len = fb->sti->regions[1].region_desc.length * 4096;\n\n\tfix->line_length = (fb->sti->glob_cfg->total_x * bpp) / 8;\n\tif (!fix->line_length)\n\t\tfix->line_length = 2048;  \n\n\t \n\tif (fix->smem_len > yres*fix->line_length)\n\t\tfix->smem_len = ALIGN(yres*fix->line_length, 4*1024*1024);\n\n\tfix->accel = FB_ACCEL_NONE;\n\n\tswitch (bpp) {\n\t    case 1:\n\t\tfix->type = FB_TYPE_PLANES;\t \n\t\tfix->visual = FB_VISUAL_MONO10;\n\t\tvar->red.length = var->green.length = var->blue.length = 1;\n\t\tbreak;\n\t    case 8:\n\t\tfix->type = FB_TYPE_PACKED_PIXELS;\n\t\tfix->visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tbreak;\n\t    case 32:\n\t\tfix->type = FB_TYPE_PACKED_PIXELS;\n\t\tfix->visual = FB_VISUAL_DIRECTCOLOR;\n\t\tvar->red.length = var->green.length = var->blue.length = var->transp.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->green.offset = 8;\n\t\tvar->red.offset = 16;\n\t\tvar->transp.offset = 24;\n\t\tbreak;\n\t    default:\n\t\tbreak;\n\t}\n\n\tvar->xres = var->xres_virtual = xres;\n\tvar->yres = var->yres_virtual = yres;\n\tvar->bits_per_pixel = bpp;\n\n\tstrcpy(fix->id, \"stifb\");\n\tinfo->fbops = &stifb_ops;\n\tinfo->screen_base = ioremap(REGION_BASE(fb,1), fix->smem_len);\n\tif (!info->screen_base) {\n\t\tprintk(KERN_ERR \"stifb: failed to map memory\\n\");\n\t\tgoto out_err0;\n\t}\n\tinfo->screen_size = fix->smem_len;\n\tinfo->flags = FBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT;\n\tinfo->pseudo_palette = &fb->pseudo_palette;\n\n\tscnprintf(modestr, sizeof(modestr), \"%dx%d-%d\", xres, yres, bpp);\n\tfb_find_mode(&info->var, info, modestr, NULL, 0, NULL, bpp);\n\n\t \n\tif (fb_alloc_cmap(&info->cmap, NR_PALETTE, 0))\n\t\tgoto out_err1;\n\tstifb_init_display(fb);\n\n\tif (!request_mem_region(fix->smem_start, fix->smem_len, \"stifb fb\")) {\n\t\tprintk(KERN_ERR \"stifb: cannot reserve fb region 0x%04lx-0x%04lx\\n\",\n\t\t\t\tfix->smem_start, fix->smem_start+fix->smem_len);\n\t\tgoto out_err2;\n\t}\n\n\tif (!request_mem_region(fix->mmio_start, fix->mmio_len, \"stifb mmio\")) {\n\t\tprintk(KERN_ERR \"stifb: cannot reserve sti mmio region 0x%04lx-0x%04lx\\n\",\n\t\t\t\tfix->mmio_start, fix->mmio_start+fix->mmio_len);\n\t\tgoto out_err3;\n\t}\n\n\t \n\tsti->info = info;\n\tif (register_framebuffer(&fb->info) < 0)\n\t\tgoto out_err4;\n\n\tfb_info(&fb->info, \"%s %dx%d-%d frame buffer device, %s, id: %04x, mmio: 0x%04lx\\n\",\n\t\tfix->id,\n\t\tvar->xres,\n\t\tvar->yres,\n\t\tvar->bits_per_pixel,\n\t\tdev_name,\n\t\tfb->id,\n\t\tfix->mmio_start);\n\n\treturn 0;\n\n\nout_err4:\n\trelease_mem_region(fix->mmio_start, fix->mmio_len);\nout_err3:\n\trelease_mem_region(fix->smem_start, fix->smem_len);\nout_err2:\n\tfb_dealloc_cmap(&info->cmap);\nout_err1:\n\tiounmap(info->screen_base);\nout_err0:\n\tkfree(fb);\n\tsti->info = NULL;\n\treturn -ENXIO;\n}\n\nstatic int stifb_disabled __initdata;\n\nint __init\nstifb_setup(char *options);\n\nstatic int __init stifb_init(void)\n{\n\tstruct sti_struct *sti;\n\tstruct sti_struct *def_sti;\n\tint i;\n\n#ifndef MODULE\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"stifb\", &option))\n\t\treturn -ENODEV;\n\tstifb_setup(option);\n#endif\n\tif (stifb_disabled) {\n\t\tprintk(KERN_INFO \"stifb: disabled by \\\"stifb=off\\\" kernel parameter\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tdef_sti = sti_get_rom(0);\n\tif (def_sti) {\n\t\tfor (i = 1; i <= MAX_STI_ROMS; i++) {\n\t\t\tsti = sti_get_rom(i);\n\t\t\tif (!sti)\n\t\t\t\tbreak;\n\t\t\tif (sti == def_sti) {\n\t\t\t\tstifb_init_fb(sti, stifb_bpp_pref[i - 1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 1; i <= MAX_STI_ROMS; i++) {\n\t\tsti = sti_get_rom(i);\n\t\tif (!sti)\n\t\t\tbreak;\n\t\tif (sti == def_sti)\n\t\t\tcontinue;\n\t\tstifb_init_fb(sti, stifb_bpp_pref[i - 1]);\n\t}\n\treturn 0;\n}\n\n \n\nstatic void __exit\nstifb_cleanup(void)\n{\n\tstruct sti_struct *sti;\n\tint i;\n\n\tfor (i = 1; i <= MAX_STI_ROMS; i++) {\n\t\tsti = sti_get_rom(i);\n\t\tif (!sti)\n\t\t\tbreak;\n\t\tif (sti->info) {\n\t\t\tstruct fb_info *info = sti->info;\n\t\t\tunregister_framebuffer(sti->info);\n\t\t\trelease_mem_region(info->fix.mmio_start, info->fix.mmio_len);\n\t\t        release_mem_region(info->fix.smem_start, info->fix.smem_len);\n\t\t\t\tif (info->screen_base)\n\t\t\t\t\tiounmap(info->screen_base);\n\t\t        fb_dealloc_cmap(&info->cmap);\n\t\t        framebuffer_release(info);\n\t\t}\n\t\tsti->info = NULL;\n\t}\n}\n\nint __init\nstifb_setup(char *options)\n{\n\tint i;\n\n\tif (!options || !*options)\n\t\treturn 1;\n\n\tif (strncmp(options, \"off\", 3) == 0) {\n\t\tstifb_disabled = 1;\n\t\toptions += 3;\n\t}\n\n\tif (strncmp(options, \"bpp\", 3) == 0) {\n\t\toptions += 3;\n\t\tfor (i = 0; i < MAX_STI_ROMS; i++) {\n\t\t\tif (*options++ != ':')\n\t\t\t\tbreak;\n\t\t\tstifb_bpp_pref[i] = simple_strtoul(options, &options, 10);\n\t\t}\n\t}\n\treturn 1;\n}\n\n__setup(\"stifb=\", stifb_setup);\n\nmodule_init(stifb_init);\nmodule_exit(stifb_cleanup);\n\nMODULE_AUTHOR(\"Helge Deller <deller@gmx.de>, Thomas Bogendoerfer <tsbogend@alpha.franken.de>\");\nMODULE_DESCRIPTION(\"Framebuffer driver for HP's NGLE series graphics cards in HP PARISC machines\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}