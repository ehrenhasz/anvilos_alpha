{
  "module_name": "pxa3xx-gcu.c",
  "hash_id": "a490c39c1b24c39c679dca1b0aa8e55d99f8d74528324a572a3375203297cd76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/pxa3xx-gcu.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/miscdevice.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/ioctl.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#include \"pxa3xx-gcu.h\"\n\n#define DRV_NAME\t\"pxa3xx-gcu\"\n\n#define REG_GCCR\t0x00\n#define GCCR_SYNC_CLR\t(1 << 9)\n#define GCCR_BP_RST\t(1 << 8)\n#define GCCR_ABORT\t(1 << 6)\n#define GCCR_STOP\t(1 << 4)\n\n#define REG_GCISCR\t0x04\n#define REG_GCIECR\t0x08\n#define REG_GCRBBR\t0x20\n#define REG_GCRBLR\t0x24\n#define REG_GCRBHR\t0x28\n#define REG_GCRBTR\t0x2C\n#define REG_GCRBEXHR\t0x30\n\n#define IE_EOB\t\t(1 << 0)\n#define IE_EEOB\t\t(1 << 5)\n#define IE_ALL\t\t0xff\n\n#define SHARED_SIZE\tPAGE_ALIGN(sizeof(struct pxa3xx_gcu_shared))\n\n \n \n\n#ifdef PXA3XX_GCU_DEBUG\n#define QDUMP(msg)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tQPRINT(priv, KERN_DEBUG, msg);\t\t\\\n\t} while (0)\n#else\n#define QDUMP(msg)\tdo {} while (0)\n#endif\n\n#define QERROR(msg)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tQPRINT(priv, KERN_ERR, msg);\t\t\\\n\t} while (0)\n\nstruct pxa3xx_gcu_batch {\n\tstruct pxa3xx_gcu_batch *next;\n\tu32\t\t\t*ptr;\n\tdma_addr_t\t\t phys;\n\tunsigned long\t\t length;\n};\n\nstruct pxa3xx_gcu_priv {\n\tstruct device\t\t *dev;\n\tvoid __iomem\t\t *mmio_base;\n\tstruct clk\t\t *clk;\n\tstruct pxa3xx_gcu_shared *shared;\n\tdma_addr_t\t\t  shared_phys;\n\tstruct resource\t\t *resource_mem;\n\tstruct miscdevice\t  misc_dev;\n\twait_queue_head_t\t  wait_idle;\n\twait_queue_head_t\t  wait_free;\n\tspinlock_t\t\t  spinlock;\n\tstruct timespec64\t  base_time;\n\n\tstruct pxa3xx_gcu_batch *free;\n\tstruct pxa3xx_gcu_batch *ready;\n\tstruct pxa3xx_gcu_batch *ready_last;\n\tstruct pxa3xx_gcu_batch *running;\n};\n\nstatic inline unsigned long\ngc_readl(struct pxa3xx_gcu_priv *priv, unsigned int off)\n{\n\treturn __raw_readl(priv->mmio_base + off);\n}\n\nstatic inline void\ngc_writel(struct pxa3xx_gcu_priv *priv, unsigned int off, unsigned long val)\n{\n\t__raw_writel(val, priv->mmio_base + off);\n}\n\n#define QPRINT(priv, level, msg)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct timespec64 ts;\t\t\t\t\t\\\n\t\tstruct pxa3xx_gcu_shared *shared = priv->shared;\t\\\n\t\tu32 base = gc_readl(priv, REG_GCRBBR);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tktime_get_ts64(&ts);\t\t\t\t\t\\\n\t\tts = timespec64_sub(ts, priv->base_time);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tprintk(level \"%lld.%03ld.%03ld - %-17s: %-21s (%s, \"\t\\\n\t\t\t\"STATUS \"\t\t\t\t\t\\\n\t\t\t\"0x%02lx, B 0x%08lx [%ld], E %5ld, H %5ld, \"\t\\\n\t\t\t\"T %5ld)\\n\",\t\t\t\t\t\\\n\t\t\t(s64)(ts.tv_sec),\t\t\t\t\\\n\t\t\tts.tv_nsec / NSEC_PER_MSEC,\t\t\t\\\n\t\t\t(ts.tv_nsec % NSEC_PER_MSEC) / USEC_PER_MSEC,\t\\\n\t\t\t__func__, msg,\t\t\t\t\t\\\n\t\t\tshared->hw_running ? \"running\" : \"   idle\",\t\\\n\t\t\tgc_readl(priv, REG_GCISCR),\t\t\t\\\n\t\t\tgc_readl(priv, REG_GCRBBR),\t\t\t\\\n\t\t\tgc_readl(priv, REG_GCRBLR),\t\t\t\\\n\t\t\t(gc_readl(priv, REG_GCRBEXHR) - base) / 4,\t\\\n\t\t\t(gc_readl(priv, REG_GCRBHR) - base) / 4,\t\\\n\t\t\t(gc_readl(priv, REG_GCRBTR) - base) / 4);\t\\\n\t} while (0)\n\nstatic void\npxa3xx_gcu_reset(struct pxa3xx_gcu_priv *priv)\n{\n\tQDUMP(\"RESET\");\n\n\t \n\tgc_writel(priv, REG_GCIECR, 0);\n\n\t \n\tgc_writel(priv, REG_GCCR, GCCR_ABORT);\n\tgc_writel(priv, REG_GCCR, 0);\n\n\tmemset(priv->shared, 0, SHARED_SIZE);\n\tpriv->shared->buffer_phys = priv->shared_phys;\n\tpriv->shared->magic = PXA3XX_GCU_SHARED_MAGIC;\n\n\tktime_get_ts64(&priv->base_time);\n\n\t \n\tgc_writel(priv, REG_GCRBLR, 0);\n\tgc_writel(priv, REG_GCRBBR, priv->shared_phys);\n\tgc_writel(priv, REG_GCRBTR, priv->shared_phys);\n\n\t \n\tgc_writel(priv, REG_GCIECR, IE_ALL & ~IE_EOB);\n}\n\nstatic void\ndump_whole_state(struct pxa3xx_gcu_priv *priv)\n{\n\tstruct pxa3xx_gcu_shared *sh = priv->shared;\n\tu32 base = gc_readl(priv, REG_GCRBBR);\n\n\tQDUMP(\"DUMP\");\n\n\tprintk(KERN_DEBUG \"== PXA3XX-GCU DUMP ==\\n\"\n\t\t\"%s, STATUS 0x%02lx, B 0x%08lx [%ld], E %5ld, H %5ld, T %5ld\\n\",\n\t\tsh->hw_running ? \"running\" : \"idle   \",\n\t\tgc_readl(priv, REG_GCISCR),\n\t\tgc_readl(priv, REG_GCRBBR),\n\t\tgc_readl(priv, REG_GCRBLR),\n\t\t(gc_readl(priv, REG_GCRBEXHR) - base) / 4,\n\t\t(gc_readl(priv, REG_GCRBHR) - base) / 4,\n\t\t(gc_readl(priv, REG_GCRBTR) - base) / 4);\n}\n\nstatic void\nflush_running(struct pxa3xx_gcu_priv *priv)\n{\n\tstruct pxa3xx_gcu_batch *running = priv->running;\n\tstruct pxa3xx_gcu_batch *next;\n\n\twhile (running) {\n\t\tnext = running->next;\n\t\trunning->next = priv->free;\n\t\tpriv->free = running;\n\t\trunning = next;\n\t}\n\n\tpriv->running = NULL;\n}\n\nstatic void\nrun_ready(struct pxa3xx_gcu_priv *priv)\n{\n\tunsigned int num = 0;\n\tstruct pxa3xx_gcu_shared *shared = priv->shared;\n\tstruct pxa3xx_gcu_batch\t*ready = priv->ready;\n\n\tQDUMP(\"Start\");\n\n\tBUG_ON(!ready);\n\n\tshared->buffer[num++] = 0x05000000;\n\n\twhile (ready) {\n\t\tshared->buffer[num++] = 0x00000001;\n\t\tshared->buffer[num++] = ready->phys;\n\t\tready = ready->next;\n\t}\n\n\tshared->buffer[num++] = 0x05000000;\n\tpriv->running = priv->ready;\n\tpriv->ready = priv->ready_last = NULL;\n\tgc_writel(priv, REG_GCRBLR, 0);\n\tshared->hw_running = 1;\n\n\t \n\tgc_writel(priv, REG_GCRBBR, shared->buffer_phys);\n\n\t \n\tgc_writel(priv, REG_GCRBTR, shared->buffer_phys + num * 4);\n\n\t \n\tgc_writel(priv, REG_GCRBLR, ((num + 63) & ~63) * 4);\n}\n\nstatic irqreturn_t\npxa3xx_gcu_handle_irq(int irq, void *ctx)\n{\n\tstruct pxa3xx_gcu_priv *priv = ctx;\n\tstruct pxa3xx_gcu_shared *shared = priv->shared;\n\tu32 status = gc_readl(priv, REG_GCISCR) & IE_ALL;\n\n\tQDUMP(\"-Interrupt\");\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&priv->spinlock);\n\tshared->num_interrupts++;\n\n\tif (status & IE_EEOB) {\n\t\tQDUMP(\" [EEOB]\");\n\n\t\tflush_running(priv);\n\t\twake_up_all(&priv->wait_free);\n\n\t\tif (priv->ready) {\n\t\t\trun_ready(priv);\n\t\t} else {\n\t\t\t \n\t\t\tshared->num_idle++;\n\t\t\tshared->hw_running = 0;\n\n\t\t\tQDUMP(\" '-> Idle.\");\n\n\t\t\t \n\t\t\tgc_writel(priv, REG_GCRBLR, 0);\n\n\t\t\twake_up_all(&priv->wait_idle);\n\t\t}\n\n\t\tshared->num_done++;\n\t} else {\n\t\tQERROR(\" [???]\");\n\t\tdump_whole_state(priv);\n\t}\n\n\t \n\tgc_writel(priv, REG_GCISCR, status);\n\tspin_unlock(&priv->spinlock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\npxa3xx_gcu_wait_idle(struct pxa3xx_gcu_priv *priv)\n{\n\tint ret = 0;\n\n\tQDUMP(\"Waiting for idle...\");\n\n\t \n\tpriv->shared->num_wait_idle++;\n\n\twhile (priv->shared->hw_running) {\n\t\tint num = priv->shared->num_interrupts;\n\t\tu32 rbexhr = gc_readl(priv, REG_GCRBEXHR);\n\n\t\tret = wait_event_interruptible_timeout(priv->wait_idle,\n\t\t\t\t\t!priv->shared->hw_running, HZ*4);\n\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\tif (gc_readl(priv, REG_GCRBEXHR) == rbexhr &&\n\t\t    priv->shared->num_interrupts == num) {\n\t\t\tQERROR(\"TIMEOUT\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tQDUMP(\"done\");\n\n\treturn ret;\n}\n\nstatic int\npxa3xx_gcu_wait_free(struct pxa3xx_gcu_priv *priv)\n{\n\tint ret = 0;\n\n\tQDUMP(\"Waiting for free...\");\n\n\t \n\tpriv->shared->num_wait_free++;\n\n\twhile (!priv->free) {\n\t\tu32 rbexhr = gc_readl(priv, REG_GCRBEXHR);\n\n\t\tret = wait_event_interruptible_timeout(priv->wait_free,\n\t\t\t\t\t\t       priv->free, HZ*4);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (ret > 0)\n\t\t\tcontinue;\n\n\t\tif (gc_readl(priv, REG_GCRBEXHR) == rbexhr) {\n\t\t\tQERROR(\"TIMEOUT\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tQDUMP(\"done\");\n\n\treturn ret;\n}\n\n \n\nstatic inline struct pxa3xx_gcu_priv *to_pxa3xx_gcu_priv(struct file *file)\n{\n\tstruct miscdevice *dev = file->private_data;\n\treturn container_of(dev, struct pxa3xx_gcu_priv, misc_dev);\n}\n\n \nstatic int pxa3xx_gcu_open(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\nstatic ssize_t\npxa3xx_gcu_write(struct file *file, const char *buff,\n\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_batch\t*buffer;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\n\tsize_t words = count / 4;\n\n\t \n\tpriv->shared->num_writes++;\n\tpriv->shared->num_words += words;\n\n\t \n\tif (words >= PXA3XX_GCU_BATCH_WORDS)\n\t\treturn -E2BIG;\n\n\t \n\tif (!priv->free) {\n\t\tret = pxa3xx_gcu_wait_free(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer = priv->free;\n\tpriv->free = buffer->next;\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\n\n\t \n\tret = copy_from_user(buffer->ptr, buff, words * 4);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tbuffer->next = priv->free;\n\t\tpriv->free = buffer;\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn -EFAULT;\n\t}\n\n\tbuffer->length = words;\n\n\t \n\tbuffer->ptr[words] = 0x01000000;\n\n\t \n\tspin_lock_irqsave(&priv->spinlock, flags);\n\n\tbuffer->next = NULL;\n\n\tif (priv->ready) {\n\t\tBUG_ON(priv->ready_last == NULL);\n\n\t\tpriv->ready_last->next = buffer;\n\t} else\n\t\tpriv->ready = buffer;\n\n\tpriv->ready_last = buffer;\n\n\tif (!priv->shared->hw_running)\n\t\trun_ready(priv);\n\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\n\treturn words * 4;\n}\n\n\nstatic long\npxa3xx_gcu_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\n\tswitch (cmd) {\n\tcase PXA3XX_GCU_IOCTL_RESET:\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tpxa3xx_gcu_reset(priv);\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn 0;\n\n\tcase PXA3XX_GCU_IOCTL_WAIT_IDLE:\n\t\treturn pxa3xx_gcu_wait_idle(priv);\n\t}\n\n\treturn -ENOSYS;\n}\n\nstatic int\npxa3xx_gcu_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tunsigned int size = vma->vm_end - vma->vm_start;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\n\tswitch (vma->vm_pgoff) {\n\tcase 0:\n\t\t \n\t\tif (size != SHARED_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\treturn dma_mmap_coherent(priv->dev, vma,\n\t\t\tpriv->shared, priv->shared_phys, size);\n\n\tcase SHARED_SIZE >> PAGE_SHIFT:\n\t\t \n\t\tif (size != resource_size(priv->resource_mem))\n\t\t\treturn -EINVAL;\n\n\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t\treturn io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\tpriv->resource_mem->start >> PAGE_SHIFT,\n\t\t\t\tsize, vma->vm_page_prot);\n\t}\n\n\treturn -EINVAL;\n}\n\n\n#ifdef PXA3XX_GCU_DEBUG_TIMER\nstatic struct timer_list pxa3xx_gcu_debug_timer;\nstatic struct pxa3xx_gcu_priv *debug_timer_priv;\n\nstatic void pxa3xx_gcu_debug_timedout(struct timer_list *unused)\n{\n\tstruct pxa3xx_gcu_priv *priv = debug_timer_priv;\n\n\tQERROR(\"Timer DUMP\");\n\n\tmod_timer(&pxa3xx_gcu_debug_timer, jiffies + 5 * HZ);\n}\n\nstatic void pxa3xx_gcu_init_debug_timer(struct pxa3xx_gcu_priv *priv)\n{\n\t \n\tdebug_timer_priv = priv;\n\ttimer_setup(&pxa3xx_gcu_debug_timer, pxa3xx_gcu_debug_timedout, 0);\n\tpxa3xx_gcu_debug_timedout(NULL);\n}\n#else\nstatic inline void pxa3xx_gcu_init_debug_timer(struct pxa3xx_gcu_priv *priv) {}\n#endif\n\nstatic int\npxa3xx_gcu_add_buffer(struct device *dev,\n\t\t      struct pxa3xx_gcu_priv *priv)\n{\n\tstruct pxa3xx_gcu_batch *buffer;\n\n\tbuffer = kzalloc(sizeof(struct pxa3xx_gcu_batch), GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer->ptr = dma_alloc_coherent(dev, PXA3XX_GCU_BATCH_WORDS * 4,\n\t\t\t\t\t &buffer->phys, GFP_KERNEL);\n\tif (!buffer->ptr) {\n\t\tkfree(buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\tbuffer->next = priv->free;\n\tpriv->free = buffer;\n\n\treturn 0;\n}\n\nstatic void\npxa3xx_gcu_free_buffers(struct device *dev,\n\t\t\tstruct pxa3xx_gcu_priv *priv)\n{\n\tstruct pxa3xx_gcu_batch *next, *buffer = priv->free;\n\n\twhile (buffer) {\n\t\tnext = buffer->next;\n\n\t\tdma_free_coherent(dev, PXA3XX_GCU_BATCH_WORDS * 4,\n\t\t\t\t  buffer->ptr, buffer->phys);\n\n\t\tkfree(buffer);\n\t\tbuffer = next;\n\t}\n\n\tpriv->free = NULL;\n}\n\nstatic const struct file_operations pxa3xx_gcu_miscdev_fops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.open =\t\t\tpxa3xx_gcu_open,\n\t.write =\t\tpxa3xx_gcu_write,\n\t.unlocked_ioctl =\tpxa3xx_gcu_ioctl,\n\t.mmap =\t\t\tpxa3xx_gcu_mmap,\n};\n\nstatic int pxa3xx_gcu_probe(struct platform_device *pdev)\n{\n\tint i, ret, irq;\n\tstruct resource *r;\n\tstruct pxa3xx_gcu_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct pxa3xx_gcu_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&priv->wait_idle);\n\tinit_waitqueue_head(&priv->wait_free);\n\tspin_lock_init(&priv->spinlock);\n\n\t \n\n\tpriv->misc_dev.minor\t= PXA3XX_GCU_MINOR,\n\tpriv->misc_dev.name\t= DRV_NAME,\n\tpriv->misc_dev.fops\t= &pxa3xx_gcu_miscdev_fops;\n\n\t \n\tpriv->mmio_base = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(priv->mmio_base))\n\t\treturn PTR_ERR(priv->mmio_base);\n\n\t \n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk), \"failed to get clock\\n\");\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, pxa3xx_gcu_handle_irq,\n\t\t\t       0, DRV_NAME, priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"request_irq failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpriv->shared = dma_alloc_coherent(dev, SHARED_SIZE,\n\t\t\t\t\t  &priv->shared_phys, GFP_KERNEL);\n\tif (!priv->shared) {\n\t\tdev_err(dev, \"failed to allocate DMA memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = misc_register(&priv->misc_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"misc_register() for minor %d failed\\n\",\n\t\t\tPXA3XX_GCU_MINOR);\n\t\tgoto err_free_dma;\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable clock\\n\");\n\t\tgoto err_misc_deregister;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tret = pxa3xx_gcu_add_buffer(dev, priv);\n\t\tif (ret) {\n\t\t\tpxa3xx_gcu_free_buffers(dev, priv);\n\t\t\tdev_err(dev, \"failed to allocate DMA memory\\n\");\n\t\t\tgoto err_disable_clk;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\tpriv->resource_mem = r;\n\tpriv->dev = dev;\n\tpxa3xx_gcu_reset(priv);\n\tpxa3xx_gcu_init_debug_timer(priv);\n\n\tdev_info(dev, \"registered @0x%p, DMA 0x%p (%d bytes), IRQ %d\\n\",\n\t\t\t(void *) r->start, (void *) priv->shared_phys,\n\t\t\tSHARED_SIZE, irq);\n\treturn 0;\n\nerr_disable_clk:\n\tclk_disable_unprepare(priv->clk);\n\nerr_misc_deregister:\n\tmisc_deregister(&priv->misc_dev);\n\nerr_free_dma:\n\tdma_free_coherent(dev, SHARED_SIZE,\n\t\t\t  priv->shared, priv->shared_phys);\n\n\treturn ret;\n}\n\nstatic void pxa3xx_gcu_remove(struct platform_device *pdev)\n{\n\tstruct pxa3xx_gcu_priv *priv = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\tpxa3xx_gcu_wait_idle(priv);\n\tmisc_deregister(&priv->misc_dev);\n\tdma_free_coherent(dev, SHARED_SIZE, priv->shared, priv->shared_phys);\n\tclk_disable_unprepare(priv->clk);\n\tpxa3xx_gcu_free_buffers(dev, priv);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pxa3xx_gcu_of_match[] = {\n\t{ .compatible = \"marvell,pxa300-gcu\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pxa3xx_gcu_of_match);\n#endif\n\nstatic struct platform_driver pxa3xx_gcu_driver = {\n\t.probe\t  = pxa3xx_gcu_probe,\n\t.remove_new\t = pxa3xx_gcu_remove,\n\t.driver\t = {\n\t\t.name   = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(pxa3xx_gcu_of_match),\n\t},\n};\n\nmodule_platform_driver(pxa3xx_gcu_driver);\n\nMODULE_DESCRIPTION(\"PXA3xx graphics controller unit driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_MISCDEV(PXA3XX_GCU_MINOR);\nMODULE_AUTHOR(\"Janine Kropp <nin@directfb.org>, \"\n\t\t\"Denis Oliver Kropp <dok@directfb.org>, \"\n\t\t\"Daniel Mack <daniel@caiaq.de>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}