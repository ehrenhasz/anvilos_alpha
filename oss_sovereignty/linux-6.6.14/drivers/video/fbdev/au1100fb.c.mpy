{
  "module_name": "au1100fb.c",
  "hash_id": "217042dd4654205f73c4469851a2d18d1d934526099208df5fb3aab52ae9fd2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/au1100fb.c",
  "human_readable_source": " \n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ctype.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <asm/mach-au1x00/au1000.h>\n\n#define DEBUG 0\n\n#include \"au1100fb.h\"\n\n#define DRIVER_NAME \"au1100fb\"\n#define DRIVER_DESC \"LCD controller driver for AU1100 processors\"\n\n#define to_au1100fb_device(_info) \\\n\t  (_info ? container_of(_info, struct au1100fb_device, info) : NULL);\n\n \nstruct fb_bitfield rgb_bitfields[][4] =\n{\n  \t \n\t{ { 10, 6, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\t{ { 11, 5, 0 }, { 5, 6, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 0, 6, 0 }, { 0, 0, 0 } },\n\t{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 15, 1, 0 } },\n\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 1, 0 } },\n\n\t \n\t{ { 8, 4, 0 },  { 4, 4, 0 }, { 0, 4, 0 }, { 0, 0, 0 } },\n};\n\nstatic struct fb_fix_screeninfo au1100fb_fix = {\n\t.id\t\t= \"AU1100 FB\",\n\t.xpanstep \t= 1,\n\t.ypanstep \t= 1,\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.accel\t\t= FB_ACCEL_NONE,\n};\n\nstatic struct fb_var_screeninfo au1100fb_var = {\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\n \nstatic int au1100fb_fb_blank(int blank_mode, struct fb_info *fbi)\n{\n\tstruct au1100fb_device *fbdev = to_au1100fb_device(fbi);\n\n\tprint_dbg(\"fb_blank %d %p\", blank_mode, fbi);\n\n\tswitch (blank_mode) {\n\n\tcase VESA_NO_BLANKING:\n\t\t \n\t\tfbdev->regs->lcd_control |= LCD_CONTROL_GO;\n\t\twmb();  \n\t\tbreak;\n\n\tcase VESA_VSYNC_SUSPEND:\n\tcase VESA_HSYNC_SUSPEND:\n\tcase VESA_POWERDOWN:\n\t\t \n\t\tfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\n\t\twmb();  \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n\treturn 0;\n}\n\n \nint au1100fb_setmode(struct au1100fb_device *fbdev)\n{\n\tstruct fb_info *info = &fbdev->info;\n\tu32 words;\n\tint index;\n\n\tif (!fbdev)\n\t\treturn -EINVAL;\n\n\t \n\tif (panel_is_active(fbdev->panel) || panel_is_color(fbdev->panel)) {\n\t\tif (info->var.bits_per_pixel <= 8) {\n\t\t\t \n\t\t\tinfo->var.red.offset    = 0;\n\t\t\tinfo->var.red.length    = info->var.bits_per_pixel;\n\t\t\tinfo->var.red.msb_right = 0;\n\n\t\t\tinfo->var.green.offset  = 0;\n\t\t\tinfo->var.green.length  = info->var.bits_per_pixel;\n\t\t\tinfo->var.green.msb_right = 0;\n\n\t\t\tinfo->var.blue.offset   = 0;\n\t\t\tinfo->var.blue.length   = info->var.bits_per_pixel;\n\t\t\tinfo->var.blue.msb_right = 0;\n\n\t\t\tinfo->var.transp.offset = 0;\n\t\t\tinfo->var.transp.length = 0;\n\t\t\tinfo->var.transp.msb_right = 0;\n\n\t\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\t\tinfo->fix.line_length = info->var.xres_virtual /\n\t\t\t\t\t\t\t(8/info->var.bits_per_pixel);\n\t\t} else {\n\t\t\t \n\t\t\tindex = (fbdev->panel->control_base & LCD_CONTROL_SBPPF_MASK) >> LCD_CONTROL_SBPPF_BIT;\n\t\t\tinfo->var.red = rgb_bitfields[index][0];\n\t\t\tinfo->var.green = rgb_bitfields[index][1];\n\t\t\tinfo->var.blue = rgb_bitfields[index][2];\n\t\t\tinfo->var.transp = rgb_bitfields[index][3];\n\n\t\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\t\tinfo->fix.line_length = info->var.xres_virtual << 1;  \n\t\t}\n\t} else {\n\t\t \n\t\tinfo->fix.visual = FB_VISUAL_MONO10;\n\t\tinfo->fix.line_length = info->var.xres_virtual / 8;\n\t}\n\n\tinfo->screen_size = info->fix.line_length * info->var.yres_virtual;\n\tinfo->var.rotate = ((fbdev->panel->control_base&LCD_CONTROL_SM_MASK) \\\n\t\t\t\t>> LCD_CONTROL_SM_BIT) * 90;\n\n\t \n\tfbdev->regs->lcd_control = fbdev->panel->control_base;\n\tfbdev->regs->lcd_horztiming = fbdev->panel->horztiming;\n\tfbdev->regs->lcd_verttiming = fbdev->panel->verttiming;\n\tfbdev->regs->lcd_clkcontrol = fbdev->panel->clkcontrol_base;\n\tfbdev->regs->lcd_intenable = 0;\n\tfbdev->regs->lcd_intstatus = 0;\n\tfbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(fbdev->fb_phys);\n\n\tif (panel_is_dual(fbdev->panel)) {\n\t\t \n\t\tif (info->var.yres_virtual >= (info->var.yres << 1)) {\n\t\t\tfbdev->regs->lcd_dmaaddr1 = LCD_DMA_SA_N(fbdev->fb_phys +\n\t\t\t\t\t\t\t  (info->fix.line_length *\n\t\t\t\t\t\t          (info->var.yres_virtual >> 1)));\n\t\t} else {\n\t\t\tfbdev->regs->lcd_dmaaddr1 = LCD_DMA_SA_N(fbdev->fb_phys);\n\t\t}\n\t}\n\n\twords = info->fix.line_length / sizeof(u32);\n\tif (!info->var.rotate || (info->var.rotate == 180)) {\n\t\twords *= info->var.yres_virtual;\n\t\tif (info->var.rotate  ) {\n\t\t\twords -= (words % 8);  \n\t\t}\n\t}\n\tfbdev->regs->lcd_words = LCD_WRD_WRDS_N(words);\n\n\tfbdev->regs->lcd_pwmdiv = 0;\n\tfbdev->regs->lcd_pwmhi = 0;\n\n\t \n\tfbdev->regs->lcd_control |= LCD_CONTROL_GO;\n\tmdelay(10);\n\tau1100fb_fb_blank(VESA_NO_BLANKING, info);\n\n\treturn 0;\n}\n\n \nint au1100fb_fb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *fbi)\n{\n\tstruct au1100fb_device *fbdev;\n\tu32 *palette;\n\tu32 value;\n\n\tfbdev = to_au1100fb_device(fbi);\n\tpalette = fbdev->regs->lcd_palettebase;\n\n\tif (regno > (AU1100_LCD_NBR_PALETTE_ENTRIES - 1))\n\t\treturn -EINVAL;\n\n\tif (fbi->var.grayscale) {\n\t\t \n\t\tred = green = blue =\n\t\t\t(19595 * red + 38470 * green + 7471 * blue) >> 16;\n\t}\n\n\tif (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\t \n\t\tif (regno > 16)\n\t\t\treturn -EINVAL;\n\n\t\tpalette = (u32*)fbi->pseudo_palette;\n\n\t\tred   >>= (16 - fbi->var.red.length);\n\t\tgreen >>= (16 - fbi->var.green.length);\n\t\tblue  >>= (16 - fbi->var.blue.length);\n\n\t\tvalue = (red   << fbi->var.red.offset) \t|\n\t\t\t(green << fbi->var.green.offset)|\n\t\t\t(blue  << fbi->var.blue.offset);\n\t\tvalue &= 0xFFFF;\n\n\t} else if (panel_is_active(fbdev->panel)) {\n\t\t \n\t\tvalue = (red & 0xF800)|((green >> 5) & 0x07E0)|((blue >> 11) & 0x001F);\n\t\tvalue &= 0xFFFF;\n\n\t} else if (panel_is_color(fbdev->panel)) {\n\t\t \n\t\tvalue = (((panel_swap_rgb(fbdev->panel) ? blue : red) >> 12) & 0x000F) |\n\t\t\t((green >> 8) & 0x00F0) |\n\t\t\t(((panel_swap_rgb(fbdev->panel) ? red : blue) >> 4) & 0x0F00);\n\t\tvalue &= 0xFFF;\n\t} else {\n\t\t \n\t\tvalue = (green >> 12) & 0x000F;\n\t\tvalue &= 0xF;\n\t}\n\n\tpalette[regno] = value;\n\n\treturn 0;\n}\n\n \nint au1100fb_fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *fbi)\n{\n\tstruct au1100fb_device *fbdev;\n\tint dy;\n\n\tfbdev = to_au1100fb_device(fbi);\n\n\tprint_dbg(\"fb_pan_display %p %p\", var, fbi);\n\n\tif (!var || !fbdev) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->xoffset - fbi->var.xoffset) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tprint_dbg(\"fb_pan_display 2 %p %p\", var, fbi);\n\tdy = var->yoffset - fbi->var.yoffset;\n\tif (dy) {\n\n\t\tu32 dmaaddr;\n\n\t\tprint_dbg(\"Panning screen of %d lines\", dy);\n\n\t\tdmaaddr = fbdev->regs->lcd_dmaaddr0;\n\t\tdmaaddr += (fbi->fix.line_length * dy);\n\n\t\t \n\t\tfbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(dmaaddr);\n\n\t\tif (panel_is_dual(fbdev->panel)) {\n\t\t\tdmaaddr = fbdev->regs->lcd_dmaaddr1;\n\t\t\tdmaaddr += (fbi->fix.line_length * dy);\n\t\t\tfbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(dmaaddr);\n\t}\n\t}\n\tprint_dbg(\"fb_pan_display 3 %p %p\", var, fbi);\n\n\treturn 0;\n}\n\n \nint au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n{\n\tstruct au1100fb_device *fbdev = to_au1100fb_device(fbi);\n\n\tpgprot_val(vma->vm_page_prot) |= (6 << 9);  \n\n\treturn dma_mmap_coherent(fbdev->dev, vma, fbdev->fb_mem, fbdev->fb_phys,\n\t\t\tfbdev->fb_len);\n}\n\nstatic const struct fb_ops au1100fb_ops =\n{\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_setcolreg\t\t= au1100fb_fb_setcolreg,\n\t.fb_blank\t\t= au1100fb_fb_blank,\n\t.fb_pan_display\t\t= au1100fb_fb_pan_display,\n\t.fb_fillrect\t\t= cfb_fillrect,\n\t.fb_copyarea\t\t= cfb_copyarea,\n\t.fb_imageblit\t\t= cfb_imageblit,\n\t.fb_mmap\t\t= au1100fb_fb_mmap,\n};\n\n\n \n\nstatic int au1100fb_setup(struct au1100fb_device *fbdev)\n{\n\tchar *this_opt, *options;\n\tint num_panels = ARRAY_SIZE(known_lcd_panels);\n\n\tif (num_panels <= 0) {\n\t\tprint_err(\"No LCD panels supported by driver!\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (fb_get_options(DRIVER_NAME, &options))\n\t\treturn -ENODEV;\n\tif (!options)\n\t\treturn -ENODEV;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\t \n\t\tif (!strncmp(this_opt, \"panel:\", 6)) {\n\t\t\tint i;\n\t\t\tthis_opt += 6;\n\t\t\tfor (i = 0; i < num_panels; i++) {\n\t\t\t\tif (!strncmp(this_opt, known_lcd_panels[i].name,\n\t\t\t\t\t     strlen(this_opt))) {\n\t\t\t\t\tfbdev->panel = &known_lcd_panels[i];\n\t\t\t\t\tfbdev->panel_idx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i >= num_panels) {\n\t\t\t\tprint_warn(\"Panel '%s' not supported!\", this_opt);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t\t \n\t\telse\n\t\t\tprint_warn(\"Unsupported option \\\"%s\\\"\", this_opt);\n\t}\n\n\tprint_info(\"Panel=%s\", fbdev->panel->name);\n\n\treturn 0;\n}\n\nstatic int au1100fb_drv_probe(struct platform_device *dev)\n{\n\tstruct au1100fb_device *fbdev;\n\tstruct resource *regs_res;\n\tstruct clk *c;\n\n\t \n\tfbdev = devm_kzalloc(&dev->dev, sizeof(*fbdev), GFP_KERNEL);\n\tif (!fbdev)\n\t\treturn -ENOMEM;\n\n\tif (au1100fb_setup(fbdev))\n\t\tgoto failed;\n\n\tplatform_set_drvdata(dev, (void *)fbdev);\n\tfbdev->dev = &dev->dev;\n\n\t \n\tregs_res = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!regs_res) {\n\t\tprint_err(\"fail to retrieve registers resource\");\n\t\treturn -EFAULT;\n\t}\n\n\tau1100fb_fix.mmio_start = regs_res->start;\n\tau1100fb_fix.mmio_len = resource_size(regs_res);\n\n\tif (!devm_request_mem_region(&dev->dev,\n\t\t\t\t     au1100fb_fix.mmio_start,\n\t\t\t\t     au1100fb_fix.mmio_len,\n\t\t\t\t     DRIVER_NAME)) {\n\t\tprint_err(\"fail to lock memory region at 0x%08lx\",\n\t\t\t\tau1100fb_fix.mmio_start);\n\t\treturn -EBUSY;\n\t}\n\n\tfbdev->regs = (struct au1100fb_regs*)KSEG1ADDR(au1100fb_fix.mmio_start);\n\n\tprint_dbg(\"Register memory map at %p\", fbdev->regs);\n\tprint_dbg(\"phys=0x%08x, size=%d\", fbdev->regs_phys, fbdev->regs_len);\n\n\tc = clk_get(NULL, \"lcd_intclk\");\n\tif (!IS_ERR(c)) {\n\t\tfbdev->lcdclk = c;\n\t\tclk_set_rate(c, 48000000);\n\t\tclk_prepare_enable(c);\n\t}\n\n\t \n\tfbdev->fb_len = fbdev->panel->xres * fbdev->panel->yres *\n\t\t  \t(fbdev->panel->bpp >> 3) * AU1100FB_NBR_VIDEO_BUFFERS;\n\n\tfbdev->fb_mem = dmam_alloc_coherent(&dev->dev,\n\t\t\t\t\t    PAGE_ALIGN(fbdev->fb_len),\n\t\t\t\t\t    &fbdev->fb_phys, GFP_KERNEL);\n\tif (!fbdev->fb_mem) {\n\t\tprint_err(\"fail to allocate framebuffer (size: %dK))\",\n\t\t\t  fbdev->fb_len / 1024);\n\t\treturn -ENOMEM;\n\t}\n\n\tau1100fb_fix.smem_start = fbdev->fb_phys;\n\tau1100fb_fix.smem_len = fbdev->fb_len;\n\n\tprint_dbg(\"Framebuffer memory map at %p\", fbdev->fb_mem);\n\tprint_dbg(\"phys=0x%08x, size=%dK\", fbdev->fb_phys, fbdev->fb_len / 1024);\n\n\t \n\tau1100fb_var.bits_per_pixel = fbdev->panel->bpp;\n\tau1100fb_var.xres = fbdev->panel->xres;\n\tau1100fb_var.xres_virtual = au1100fb_var.xres;\n\tau1100fb_var.yres = fbdev->panel->yres;\n\tau1100fb_var.yres_virtual = au1100fb_var.yres;\n\n\tfbdev->info.screen_base = fbdev->fb_mem;\n\tfbdev->info.fbops = &au1100fb_ops;\n\tfbdev->info.fix = au1100fb_fix;\n\n\tfbdev->info.pseudo_palette =\n\t\tdevm_kcalloc(&dev->dev, 16, sizeof(u32), GFP_KERNEL);\n\tif (!fbdev->info.pseudo_palette)\n\t\treturn -ENOMEM;\n\n\tif (fb_alloc_cmap(&fbdev->info.cmap, AU1100_LCD_NBR_PALETTE_ENTRIES, 0) < 0) {\n\t\tprint_err(\"Fail to allocate colormap (%d entries)\",\n\t\t\t   AU1100_LCD_NBR_PALETTE_ENTRIES);\n\t\treturn -EFAULT;\n\t}\n\n\tfbdev->info.var = au1100fb_var;\n\n\t \n\tau1100fb_setmode(fbdev);\n\n\t \n\tif (register_framebuffer(&fbdev->info) < 0) {\n\t\tprint_err(\"cannot register new framebuffer\");\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tif (fbdev->lcdclk) {\n\t\tclk_disable_unprepare(fbdev->lcdclk);\n\t\tclk_put(fbdev->lcdclk);\n\t}\n\tif (fbdev->info.cmap.len != 0) {\n\t\tfb_dealloc_cmap(&fbdev->info.cmap);\n\t}\n\n\treturn -ENODEV;\n}\n\nvoid au1100fb_drv_remove(struct platform_device *dev)\n{\n\tstruct au1100fb_device *fbdev = NULL;\n\n\tfbdev = platform_get_drvdata(dev);\n\n#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)\n\tau1100fb_fb_blank(VESA_POWERDOWN, &fbdev->info);\n#endif\n\tfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\n\n\t \n\tunregister_framebuffer(&fbdev->info);\n\n\tfb_dealloc_cmap(&fbdev->info.cmap);\n\n\tif (fbdev->lcdclk) {\n\t\tclk_disable_unprepare(fbdev->lcdclk);\n\t\tclk_put(fbdev->lcdclk);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic struct au1100fb_regs fbregs;\n\nint au1100fb_drv_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tstruct au1100fb_device *fbdev = platform_get_drvdata(dev);\n\n\tif (!fbdev)\n\t\treturn 0;\n\n\t \n\tau1100fb_fb_blank(VESA_POWERDOWN, &fbdev->info);\n\n\tclk_disable(fbdev->lcdclk);\n\n\tmemcpy(&fbregs, fbdev->regs, sizeof(struct au1100fb_regs));\n\n\treturn 0;\n}\n\nint au1100fb_drv_resume(struct platform_device *dev)\n{\n\tstruct au1100fb_device *fbdev = platform_get_drvdata(dev);\n\n\tif (!fbdev)\n\t\treturn 0;\n\n\tmemcpy(fbdev->regs, &fbregs, sizeof(struct au1100fb_regs));\n\n\tclk_enable(fbdev->lcdclk);\n\n\t \n\tau1100fb_fb_blank(VESA_NO_BLANKING, &fbdev->info);\n\n\treturn 0;\n}\n#else\n#define au1100fb_drv_suspend NULL\n#define au1100fb_drv_resume NULL\n#endif\n\nstatic struct platform_driver au1100fb_driver = {\n\t.driver = {\n\t\t.name\t\t= \"au1100-lcd\",\n\t},\n\t.probe\t\t= au1100fb_drv_probe,\n\t.remove_new\t= au1100fb_drv_remove,\n\t.suspend\t= au1100fb_drv_suspend,\n\t.resume\t\t= au1100fb_drv_resume,\n};\nmodule_platform_driver(au1100fb_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}