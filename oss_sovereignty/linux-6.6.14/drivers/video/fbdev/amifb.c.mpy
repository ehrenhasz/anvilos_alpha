{
  "module_name": "amifb.c",
  "hash_id": "e8287b266b785c6143965ad1ec39aa6fab00790006205f312a449a37b5f3cc89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/amifb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n\n#include <asm/irq.h>\n#include <asm/amigahw.h>\n#include <asm/amigaints.h>\n#include <asm/setup.h>\n\n#include \"c2p.h\"\n\n\n#define DEBUG\n\n#if !defined(CONFIG_FB_AMIGA_OCS) && !defined(CONFIG_FB_AMIGA_ECS) && !defined(CONFIG_FB_AMIGA_AGA)\n#define CONFIG_FB_AMIGA_OCS    \n#endif\n\n#if !defined(CONFIG_FB_AMIGA_OCS)\n#  define IS_OCS (0)\n#elif defined(CONFIG_FB_AMIGA_ECS) || defined(CONFIG_FB_AMIGA_AGA)\n#  define IS_OCS (chipset == TAG_OCS)\n#else\n#  define CONFIG_FB_AMIGA_OCS_ONLY\n#  define IS_OCS (1)\n#endif\n\n#if !defined(CONFIG_FB_AMIGA_ECS)\n#  define IS_ECS (0)\n#elif defined(CONFIG_FB_AMIGA_OCS) || defined(CONFIG_FB_AMIGA_AGA)\n#  define IS_ECS (chipset == TAG_ECS)\n#else\n#  define CONFIG_FB_AMIGA_ECS_ONLY\n#  define IS_ECS (1)\n#endif\n\n#if !defined(CONFIG_FB_AMIGA_AGA)\n#  define IS_AGA (0)\n#elif defined(CONFIG_FB_AMIGA_OCS) || defined(CONFIG_FB_AMIGA_ECS)\n#  define IS_AGA (chipset == TAG_AGA)\n#else\n#  define CONFIG_FB_AMIGA_AGA_ONLY\n#  define IS_AGA (1)\n#endif\n\n#ifdef DEBUG\n#  define DPRINTK(fmt, args...)\tprintk(KERN_DEBUG \"%s: \" fmt, __func__ , ## args)\n#else\n#  define DPRINTK(fmt, args...)\n#endif\n\n \n\n\n\t \n\n#define CUSTOM_OFS(fld) ((long)&((struct CUSTOM*)0)->fld)\n\n\t \n\n#define BPC0_HIRES\t(0x8000)\n#define BPC0_BPU2\t(0x4000)  \n#define BPC0_BPU1\t(0x2000)\n#define BPC0_BPU0\t(0x1000)\n#define BPC0_HAM\t(0x0800)  \n#define BPC0_DPF\t(0x0400)  \n#define BPC0_COLOR\t(0x0200)  \n#define BPC0_GAUD\t(0x0100)  \n#define BPC0_UHRES\t(0x0080)  \n#define BPC0_SHRES\t(0x0040)  \n#define BPC0_BYPASS\t(0x0020)  \n#define BPC0_BPU3\t(0x0010)  \n#define BPC0_LPEN\t(0x0008)  \n#define BPC0_LACE\t(0x0004)  \n#define BPC0_ERSY\t(0x0002)  \n#define BPC0_ECSENA\t(0x0001)  \n\n\t \n\n#define BPC2_ZDBPSEL2\t(0x4000)  \n#define BPC2_ZDBPSEL1\t(0x2000)\n#define BPC2_ZDBPSEL0\t(0x1000)\n#define BPC2_ZDBPEN\t(0x0800)  \n#define BPC2_ZDCTEN\t(0x0400)  \n#define BPC2_KILLEHB\t(0x0200)  \n#define BPC2_RDRAM\t(0x0100)  \n#define BPC2_SOGEN\t(0x0080)  \n#define BPC2_PF2PRI\t(0x0040)  \n#define BPC2_PF2P2\t(0x0020)  \n#define BPC2_PF2P1\t(0x0010)\n#define BPC2_PF2P0\t(0x0008)\n#define BPC2_PF1P2\t(0x0004)  \n#define BPC2_PF1P1\t(0x0002)\n#define BPC2_PF1P0\t(0x0001)\n\n\t \n\n#define BPC3_BANK2\t(0x8000)  \n#define BPC3_BANK1\t(0x4000)\n#define BPC3_BANK0\t(0x2000)\n#define BPC3_PF2OF2\t(0x1000)  \n#define BPC3_PF2OF1\t(0x0800)\n#define BPC3_PF2OF0\t(0x0400)\n#define BPC3_LOCT\t(0x0200)  \n#define BPC3_SPRES1\t(0x0080)  \n#define BPC3_SPRES0\t(0x0040)\n#define BPC3_BRDRBLNK\t(0x0020)  \n#define BPC3_BRDRTRAN\t(0x0010)  \n#define BPC3_ZDCLKEN\t(0x0004)  \n#define BPC3_BRDRSPRT\t(0x0002)  \n#define BPC3_EXTBLKEN\t(0x0001)  \n\n\t \n\n#define BPC4_BPLAM7\t(0x8000)  \n#define BPC4_BPLAM6\t(0x4000)\n#define BPC4_BPLAM5\t(0x2000)\n#define BPC4_BPLAM4\t(0x1000)\n#define BPC4_BPLAM3\t(0x0800)\n#define BPC4_BPLAM2\t(0x0400)\n#define BPC4_BPLAM1\t(0x0200)\n#define BPC4_BPLAM0\t(0x0100)\n#define BPC4_ESPRM7\t(0x0080)  \n#define BPC4_ESPRM6\t(0x0040)\n#define BPC4_ESPRM5\t(0x0020)\n#define BPC4_ESPRM4\t(0x0010)\n#define BPC4_OSPRM7\t(0x0008)  \n#define BPC4_OSPRM6\t(0x0004)\n#define BPC4_OSPRM5\t(0x0002)\n#define BPC4_OSPRM4\t(0x0001)\n\n\t \n\n#define BMC0_HARDDIS\t(0x4000)  \n#define BMC0_LPENDIS\t(0x2000)  \n#define BMC0_VARVBEN\t(0x1000)  \n#define BMC0_LOLDIS\t(0x0800)  \n#define BMC0_CSCBEN\t(0x0400)  \n#define BMC0_VARVSYEN\t(0x0200)  \n#define BMC0_VARHSYEN\t(0x0100)  \n#define BMC0_VARBEAMEN\t(0x0080)  \n#define BMC0_DUAL\t(0x0040)  \n#define BMC0_PAL\t(0x0020)  \n#define BMC0_VARCSYEN\t(0x0010)  \n#define BMC0_BLANKEN\t(0x0008)  \n#define BMC0_CSYTRUE\t(0x0004)  \n#define BMC0_VSYTRUE\t(0x0002)  \n#define BMC0_HSYTRUE\t(0x0001)  \n\n\n\t \n\n#define FMODE_SSCAN2\t(0x8000)  \n#define FMODE_BSCAN2\t(0x4000)  \n#define FMODE_SPAGEM\t(0x0008)  \n#define FMODE_SPR32\t(0x0004)  \n#define FMODE_BPAGEM\t(0x0002)  \n#define FMODE_BPL32\t(0x0001)  \n\n\t \n\nenum { TAG_SHRES, TAG_HIRES, TAG_LORES };\n\n\t \n\nenum { TAG_OCS, TAG_ECS, TAG_AGA };\n\n\t \n\nenum { TAG_FMODE_1, TAG_FMODE_2, TAG_FMODE_4 };\n\n\n\t \n\nstatic u_long pixclock[3];\t \nstatic u_short maxdepth[3];\t \nstatic u_short maxfmode, chipset;\n\n\n\t \n\n#define PAL_DIWSTRT_H\t(360)\t \n#define PAL_DIWSTRT_V\t(48)\n#define PAL_HTOTAL\t(1816)\n#define PAL_VTOTAL\t(625)\n\n#define NTSC_DIWSTRT_H\t(360)\t \n#define NTSC_DIWSTRT_V\t(40)\n#define NTSC_HTOTAL\t(1816)\n#define NTSC_VTOTAL\t(525)\n\n\n\t \n\n#define up2(v)\t\t(((v) + 1) & -2)\n#define down2(v)\t((v) & -2)\n#define div2(v)\t\t((v)>>1)\n#define mod2(v)\t\t((v) & 1)\n\n#define up4(v)\t\t(((v) + 3) & -4)\n#define down4(v)\t((v) & -4)\n#define mul4(v)\t\t((v) << 2)\n#define div4(v)\t\t((v)>>2)\n#define mod4(v)\t\t((v) & 3)\n\n#define up8(v)\t\t(((v) + 7) & -8)\n#define down8(v)\t((v) & -8)\n#define div8(v)\t\t((v)>>3)\n#define mod8(v)\t\t((v) & 7)\n\n#define up16(v)\t\t(((v) + 15) & -16)\n#define down16(v)\t((v) & -16)\n#define div16(v)\t((v)>>4)\n#define mod16(v)\t((v) & 15)\n\n#define up32(v)\t\t(((v) + 31) & -32)\n#define down32(v)\t((v) & -32)\n#define div32(v)\t((v)>>5)\n#define mod32(v)\t((v) & 31)\n\n#define up64(v)\t\t(((v) + 63) & -64)\n#define down64(v)\t((v) & -64)\n#define div64(v)\t((v)>>6)\n#define mod64(v)\t((v) & 63)\n\n#define upx(x, v)\t(((v) + (x) - 1) & -(x))\n#define downx(x, v)\t((v) & -(x))\n#define modx(x, v)\t((v) & ((x) - 1))\n\n \n \n#ifdef __mc68000__\n#define DIVUL(x1, x2) ({int res; asm(\"divul %1,%2,%3\": \"=d\" (res): \\\n\t\"d\" (x2), \"d\" ((long)((x1) / 0x100000000ULL)), \"0\" ((long)(x1))); res;})\n#else\n \n#define DIVUL(x1, x2) ((((long)((unsigned long long)x1 >> 8) / x2) << 8) + \\\n\t((((long)((unsigned long long)x1 >> 8) % x2) << 8) / x2))\n#endif\n\n#define highw(x)\t((u_long)(x)>>16 & 0xffff)\n#define loww(x)\t\t((u_long)(x) & 0xffff)\n\n#define custom\t\tamiga_custom\n\n#define VBlankOn()\tcustom.intena = IF_SETCLR|IF_COPER\n#define VBlankOff()\tcustom.intena = IF_COPER\n\n\n\t \n\n#define VIDEOMEMSIZE_AGA_2M\t(1310720)  \n#define VIDEOMEMSIZE_AGA_1M\t(786432)   \n#define VIDEOMEMSIZE_ECS_2M\t(655360)   \n#define VIDEOMEMSIZE_ECS_1M\t(393216)   \n#define VIDEOMEMSIZE_OCS\t(262144)   \n\n#define SPRITEMEMSIZE\t\t(64 * 64 / 4)  \n#define DUMMYSPRITEMEMSIZE\t(8)\nstatic u_long spritememory;\n\n#define CHIPRAM_SAFETY_LIMIT\t(16384)\n\nstatic u_long videomemory;\n\n\t \n\nstatic u_long min_fstrt = 192;\n\n#define assignchunk(name, type, ptr, size) \\\n{ \\\n\t(name) = (type)(ptr); \\\n\tptr += size; \\\n}\n\n\n\t \n\n#define CMOVE(val, reg)\t\t(CUSTOM_OFS(reg) << 16 | (val))\n#define CMOVE2(val, reg)\t((CUSTOM_OFS(reg) + 2) << 16 | (val))\n#define CWAIT(x, y)\t\t(((y) & 0x1fe) << 23 | ((x) & 0x7f0) << 13 | 0x0001fffe)\n#define CEND\t\t\t(0xfffffffe)\n\n\ntypedef union {\n\tu_long l;\n\tu_short w[2];\n} copins;\n\nstatic struct copdisplay {\n\tcopins *init;\n\tcopins *wait;\n\tcopins *list[2][2];\n\tcopins *rebuild[2];\n} copdisplay;\n\nstatic u_short currentcop = 0;\n\n\t \n\n#define FBIOGET_FCURSORINFO     0x4607\n#define FBIOGET_VCURSORINFO     0x4608\n#define FBIOPUT_VCURSORINFO     0x4609\n#define FBIOGET_CURSORSTATE     0x460A\n#define FBIOPUT_CURSORSTATE     0x460B\n\n\nstruct fb_fix_cursorinfo {\n\t__u16 crsr_width;\t\t \n\t__u16 crsr_height;\t\t \n\t__u16 crsr_xsize;\t\t \n\t__u16 crsr_ysize;\n\t__u16 crsr_color1;\t\t \n\t__u16 crsr_color2;\t\t \n};\n\nstruct fb_var_cursorinfo {\n\t__u16 width;\n\t__u16 height;\n\t__u16 xspot;\n\t__u16 yspot;\n\tDECLARE_FLEX_ARRAY(__u8, data);\t \n};\n\nstruct fb_cursorstate {\n\t__s16 xoffset;\n\t__s16 yoffset;\n\t__u16 mode;\n};\n\n#define FB_CURSOR_OFF\t\t0\n#define FB_CURSOR_ON\t\t1\n#define FB_CURSOR_FLASH\t\t2\n\n\n\t \n\nstatic int cursorrate = 20;\t \nstatic u_short cursorstate = -1;\nstatic u_short cursormode = FB_CURSOR_OFF;\n\nstatic u_short *lofsprite, *shfsprite, *dummysprite;\n\n\t \n\nstruct amifb_par {\n\n\t \n\n\tint xres;\t\t \n\tint yres;\t\t \n\tint vxres;\t\t \n\tint vyres;\t\t \n\tint xoffset;\t\t \n\tint yoffset;\t\t \n\tu_short bpp;\t\t \n\tu_short clk_shift;\t \n\tu_short line_shift;\t \n\tint vmode;\t\t \n\tu_short diwstrt_h;\t \n\tu_short diwstop_h;\t \n\tu_short diwstrt_v;\t \n\tu_short diwstop_v;\t \n\tu_long next_line;\t \n\tu_long next_plane;\t \n\n\t \n\n\tstruct {\n\t\tshort crsr_x;\t \n\t\tshort crsr_y;\t \n\t\tshort spot_x;\n\t\tshort spot_y;\n\t\tu_short height;\n\t\tu_short width;\n\t\tu_short fmode;\n\t} crsr;\n\n\t \n\n\tu_long bplpt0;\t\t \n\tu_long bplpt0wrap;\t \n\tu_short ddfstrt;\n\tu_short ddfstop;\n\tu_short bpl1mod;\n\tu_short bpl2mod;\n\tu_short bplcon0;\t \n\tu_short bplcon1;\t \n\tu_short htotal;\t\t \n\tu_short vtotal;\t\t \n\n\t \n\n\tu_short bplcon3;\t \n\tu_short beamcon0;\t \n\tu_short hsstrt;\t\t \n\tu_short hsstop;\t\t \n\tu_short hbstrt;\t\t \n\tu_short hbstop;\t\t \n\tu_short vsstrt;\t\t \n\tu_short vsstop;\t\t \n\tu_short vbstrt;\t\t \n\tu_short vbstop;\t\t \n\tu_short hcenter;\t \n\n\t \n\n\tu_short fmode;\t\t \n};\n\n\n\t \n\nstatic u_char red0, green0, blue0;\n\n\n#if defined(CONFIG_FB_AMIGA_ECS)\nstatic u_short ecs_palette[32];\n#endif\n\n\n\t \n\nstatic u_short do_vmode_full = 0;\t \nstatic u_short do_vmode_pan = 0;\t \nstatic short do_blank = 0;\t\t \nstatic u_short do_cursor = 0;\t\t \n\n\n\t \n\nstatic u_short is_blanked = 0;\t\t \nstatic u_short is_lace = 0;\t\t \n\n\t \n\nstatic struct fb_videomode ami_modedb[] __initdata = {\n\n\t \n\n\t{\n\t\t \n\t\t\"ntsc\", 60, 640, 200, TAG_HIRES, 106, 86, 44, 16, 76, 2,\n\t\tFB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"ntsc-lace\", 60, 640, 400, TAG_HIRES, 106, 86, 88, 33, 76, 4,\n\t\tFB_SYNC_BROADCAST, FB_VMODE_INTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"pal\", 50, 640, 256, TAG_HIRES, 106, 86, 40, 14, 76, 2,\n\t\tFB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"pal-lace\", 50, 640, 512, TAG_HIRES, 106, 86, 80, 29, 76, 4,\n\t\tFB_SYNC_BROADCAST, FB_VMODE_INTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"multiscan\", 57, 640, 480, TAG_SHRES, 96, 112, 29, 8, 72, 8,\n\t\t0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"multiscan-lace\", 57, 640, 960, TAG_SHRES, 96, 112, 58, 16, 72,\n\t\t16,\n\t\t0, FB_VMODE_INTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"euro36\", 72, 640, 200, TAG_HIRES, 92, 124, 6, 6, 52, 5,\n\t\t0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"euro36-lace\", 72, 640, 400, TAG_HIRES, 92, 124, 12, 12, 52,\n\t\t10,\n\t\t0, FB_VMODE_INTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"euro72\", 68, 640, 400, TAG_SHRES, 164, 92, 9, 9, 80, 8,\n\t\t0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"euro72-lace\", 68, 640, 800, TAG_SHRES, 164, 92, 18, 18, 80,\n\t\t16,\n\t\t0, FB_VMODE_INTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"super72\", 70, 800, 300, TAG_SHRES, 212, 140, 10, 11, 80, 7,\n\t\t0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"super72-lace\", 70, 800, 600, TAG_SHRES, 212, 140, 20, 22, 80,\n\t\t14,\n\t\t0, FB_VMODE_INTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"dblntsc\", 57, 640, 200, TAG_SHRES, 196, 124, 18, 17, 80, 4,\n\t\t0, FB_VMODE_DOUBLE | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"dblntsc-ff\", 57, 640, 400, TAG_SHRES, 196, 124, 36, 35, 80, 7,\n\t\t0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"dblntsc-lace\", 57, 640, 800, TAG_SHRES, 196, 124, 72, 70, 80,\n\t\t14,\n\t\t0, FB_VMODE_INTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"dblpal\", 47, 640, 256, TAG_SHRES, 196, 124, 14, 13, 80, 4,\n\t\t0, FB_VMODE_DOUBLE | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"dblpal-ff\", 47, 640, 512, TAG_SHRES, 196, 124, 28, 27, 80, 7,\n\t\t0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"dblpal-lace\", 47, 640, 1024, TAG_SHRES, 196, 124, 56, 54, 80,\n\t\t14,\n\t\t0, FB_VMODE_INTERLACED | FB_VMODE_YWRAP\n\t},\n\n\t \n\n\t{\n\t\t \n\t\t\"vga\", 60, 640, 480, TAG_SHRES, 64, 96, 30, 9, 112, 2,\n\t\t0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"vga70\", 70, 640, 400, TAG_SHRES, 64, 96, 35, 12, 112, 2,\n\t\tFB_SYNC_VERT_HIGH_ACT | FB_SYNC_COMP_HIGH_ACT,\n\t\tFB_VMODE_NONINTERLACED | FB_VMODE_YWRAP\n\t},\n\n#if 0\n\n\t \n\n\t{\n\t\t \n\t\t\"a2024-10\", 10, 1024, 800, TAG_HIRES, 0, 0, 0, 0, 0, 0,\n\t\t0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP\n\t}, {\n\t\t \n\t\t\"a2024-15\", 15, 1024, 800, TAG_HIRES, 0, 0, 0, 0, 0, 0,\n\t\t0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP\n\t}\n#endif\n};\n\n#define NUM_TOTAL_MODES  ARRAY_SIZE(ami_modedb)\n\nstatic char *mode_option __initdata = NULL;\nstatic int round_down_bpp = 1;\t \n\n\t \n\n\n#define DEFMODE_PAL\t    2\t \n#define DEFMODE_NTSC\t    0\t \n#define DEFMODE_AMBER_PAL   3\t \n#define DEFMODE_AMBER_NTSC  1\t \n#define DEFMODE_AGA\t    19\t \n\n\nstatic int amifb_ilbm = 0;\t \n\nstatic u32 amifb_hfmin __initdata;\t \nstatic u32 amifb_hfmax __initdata;\t \nstatic u16 amifb_vfmin __initdata;\t \nstatic u16 amifb_vfmax __initdata;\t \n\n\n\t \n\n \n\n#define hscroll2hw(hscroll) \\\n\t(((hscroll) << 12 & 0x3000) | ((hscroll) << 8 & 0xc300) | \\\n\t ((hscroll) << 4 & 0x0c00) | ((hscroll) << 2 & 0x00f0) | \\\n\t ((hscroll)>>2 & 0x000f))\n\n \n\n#define diwstrt2hw(diwstrt_h, diwstrt_v) \\\n\t(((diwstrt_v) << 7 & 0xff00) | ((diwstrt_h)>>2 & 0x00ff))\n#define diwstop2hw(diwstop_h, diwstop_v) \\\n\t(((diwstop_v) << 7 & 0xff00) | ((diwstop_h)>>2 & 0x00ff))\n#define diwhigh2hw(diwstrt_h, diwstrt_v, diwstop_h, diwstop_v) \\\n\t(((diwstop_h) << 3 & 0x2000) | ((diwstop_h) << 11 & 0x1800) | \\\n\t ((diwstop_v)>>1 & 0x0700) | ((diwstrt_h)>>5 & 0x0020) | \\\n\t ((diwstrt_h) << 3 & 0x0018) | ((diwstrt_v)>>9 & 0x0007))\n\n \n\n#define ddfstrt2hw(ddfstrt)\tdiv8(ddfstrt)\n#define ddfstop2hw(ddfstop)\tdiv8(ddfstop)\n\n \n\n#define hsstrt2hw(hsstrt)\t(div8(hsstrt))\n#define hsstop2hw(hsstop)\t(div8(hsstop))\n#define htotal2hw(htotal)\t(div8(htotal) - 1)\n#define vsstrt2hw(vsstrt)\t(div2(vsstrt))\n#define vsstop2hw(vsstop)\t(div2(vsstop))\n#define vtotal2hw(vtotal)\t(div2(vtotal) - 1)\n#define hcenter2hw(htotal)\t(div8(htotal))\n\n \n\n#define hbstrt2hw(hbstrt)\t(((hbstrt) << 8 & 0x0700) | ((hbstrt)>>3 & 0x00ff))\n#define hbstop2hw(hbstop)\t(((hbstop) << 8 & 0x0700) | ((hbstop)>>3 & 0x00ff))\n#define vbstrt2hw(vbstrt)\t(div2(vbstrt))\n#define vbstop2hw(vbstop)\t(div2(vbstop))\n\n \n\n#define rgb2hw8_high(red, green, blue) \\\n\t(((red & 0xf0) << 4) | (green & 0xf0) | ((blue & 0xf0)>>4))\n#define rgb2hw8_low(red, green, blue) \\\n\t(((red & 0x0f) << 8) | ((green & 0x0f) << 4) | (blue & 0x0f))\n#define rgb2hw4(red, green, blue) \\\n\t(((red & 0xf0) << 4) | (green & 0xf0) | ((blue & 0xf0)>>4))\n#define rgb2hw2(red, green, blue) \\\n\t(((red & 0xc0) << 4) | (green & 0xc0) | ((blue & 0xc0)>>4))\n\n \n\n#define spr2hw_pos(start_v, start_h) \\\n\t(((start_v) << 7 & 0xff00) | ((start_h)>>3 & 0x00ff))\n#define spr2hw_ctl(start_v, start_h, stop_v) \\\n\t(((stop_v) << 7 & 0xff00) | ((start_v)>>4 & 0x0040) | \\\n\t ((stop_v)>>5 & 0x0020) | ((start_h) << 3 & 0x0018) | \\\n\t ((start_v)>>7 & 0x0004) | ((stop_v)>>8 & 0x0002) | \\\n\t ((start_h)>>2 & 0x0001))\n\n \n#define get_vbpos()\t((u_short)((*(u_long volatile *)&custom.vposr >> 7) & 0xffe))\n\n\t \n\n#define COPINITSIZE (sizeof(copins) * 40)\n\nenum {\n\tcip_bplcon0\n};\n\n\t \n\n#define COPLISTSIZE (sizeof(copins) * 64)\n\nenum {\n\tcop_wait, cop_bplcon0,\n\tcop_spr0ptrh, cop_spr0ptrl,\n\tcop_diwstrt, cop_diwstop,\n\tcop_diwhigh,\n};\n\n\t \n\nstatic u_short bplpixmode[3] = {\n\tBPC0_SHRES,\t\t\t \n\tBPC0_HIRES,\t\t\t \n\t0\t\t\t\t \n};\n\nstatic u_short sprpixmode[3] = {\n\tBPC3_SPRES1 | BPC3_SPRES0,\t \n\tBPC3_SPRES1,\t\t\t \n\tBPC3_SPRES0\t\t\t \n};\n\n\t \n\nstatic u_short bplfetchmode[3] = {\n\t0,\t\t\t\t \n\tFMODE_BPL32,\t\t\t \n\tFMODE_BPAGEM | FMODE_BPL32\t \n};\n\nstatic u_short sprfetchmode[3] = {\n\t0,\t\t\t\t \n\tFMODE_SPR32,\t\t\t \n\tFMODE_SPAGEM | FMODE_SPR32\t \n};\n\n\n \n\n\t \n\nstatic int ami_decode_var(struct fb_var_screeninfo *var, struct amifb_par *par,\n\t\t\t  const struct fb_info *info)\n{\n\tu_short clk_shift, line_shift;\n\tu_long maxfetchstop, fstrt, fsize, fconst, xres_n, yres_n;\n\tu_int htotal, vtotal;\n\n\t \n\n\tfor (clk_shift = TAG_SHRES; clk_shift <= TAG_LORES; clk_shift++)\n\t\tif (var->pixclock <= pixclock[clk_shift])\n\t\t\tbreak;\n\tif (clk_shift > TAG_LORES) {\n\t\tDPRINTK(\"pixclock too high\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpar->clk_shift = clk_shift;\n\n\t \n\n\tif ((par->xres = var->xres) < 64)\n\t\tpar->xres = 64;\n\tif ((par->yres = var->yres) < 64)\n\t\tpar->yres = 64;\n\tif ((par->vxres = var->xres_virtual) < par->xres)\n\t\tpar->vxres = par->xres;\n\tif ((par->vyres = var->yres_virtual) < par->yres)\n\t\tpar->vyres = par->yres;\n\n\tpar->bpp = var->bits_per_pixel;\n\tif (!var->nonstd) {\n\t\tif (par->bpp < 1)\n\t\t\tpar->bpp = 1;\n\t\tif (par->bpp > maxdepth[clk_shift]) {\n\t\t\tif (round_down_bpp && maxdepth[clk_shift])\n\t\t\t\tpar->bpp = maxdepth[clk_shift];\n\t\t\telse {\n\t\t\t\tDPRINTK(\"invalid bpp\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else if (var->nonstd == FB_NONSTD_HAM) {\n\t\tif (par->bpp < 6)\n\t\t\tpar->bpp = 6;\n\t\tif (par->bpp != 6) {\n\t\t\tif (par->bpp < 8)\n\t\t\t\tpar->bpp = 8;\n\t\t\tif (par->bpp != 8 || !IS_AGA) {\n\t\t\t\tDPRINTK(\"invalid bpp for ham mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tDPRINTK(\"unknown nonstd mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tpar->vmode = var->vmode | FB_VMODE_SMOOTH_XPAN;\n\tswitch (par->vmode & FB_VMODE_MASK) {\n\tcase FB_VMODE_INTERLACED:\n\t\tline_shift = 0;\n\t\tbreak;\n\tcase FB_VMODE_NONINTERLACED:\n\t\tline_shift = 1;\n\t\tbreak;\n\tcase FB_VMODE_DOUBLE:\n\t\tif (!IS_AGA) {\n\t\t\tDPRINTK(\"double mode only possible with aga\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tline_shift = 2;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTK(\"unknown video mode\\n\");\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tpar->line_shift = line_shift;\n\n\t \n\n\txres_n = par->xres << clk_shift;\n\tyres_n = par->yres << line_shift;\n\tpar->htotal = down8((var->left_margin + par->xres + var->right_margin +\n\t\t\t     var->hsync_len) << clk_shift);\n\tpar->vtotal =\n\t\tdown2(((var->upper_margin + par->yres + var->lower_margin +\n\t\t\tvar->vsync_len) << line_shift) + 1);\n\n\tif (IS_AGA)\n\t\tpar->bplcon3 = sprpixmode[clk_shift];\n\telse\n\t\tpar->bplcon3 = 0;\n\tif (var->sync & FB_SYNC_BROADCAST) {\n\t\tpar->diwstop_h = par->htotal -\n\t\t\t((var->right_margin - var->hsync_len) << clk_shift);\n\t\tif (IS_AGA)\n\t\t\tpar->diwstop_h += mod4(var->hsync_len);\n\t\telse\n\t\t\tpar->diwstop_h = down4(par->diwstop_h);\n\n\t\tpar->diwstrt_h = par->diwstop_h - xres_n;\n\t\tpar->diwstop_v = par->vtotal -\n\t\t\t((var->lower_margin - var->vsync_len) << line_shift);\n\t\tpar->diwstrt_v = par->diwstop_v - yres_n;\n\t\tif (par->diwstop_h >= par->htotal + 8) {\n\t\t\tDPRINTK(\"invalid diwstop_h\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (par->diwstop_v > par->vtotal) {\n\t\t\tDPRINTK(\"invalid diwstop_v\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!IS_OCS) {\n\t\t\t \n\t\t\tpar->hsstrt = 160;\n\t\t\tpar->hsstop = 320;\n\t\t\tpar->vsstrt = 30;\n\t\t\tpar->vsstop = 34;\n\t\t} else {\n\t\t\tpar->hsstrt = 0;\n\t\t\tpar->hsstop = 0;\n\t\t\tpar->vsstrt = 0;\n\t\t\tpar->vsstop = 0;\n\t\t}\n\t\tif (par->vtotal > (PAL_VTOTAL + NTSC_VTOTAL) / 2) {\n\t\t\t \n\t\t\tif (par->htotal != PAL_HTOTAL) {\n\t\t\t\tDPRINTK(\"htotal invalid for pal\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (par->diwstrt_h < PAL_DIWSTRT_H) {\n\t\t\t\tDPRINTK(\"diwstrt_h too low for pal\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (par->diwstrt_v < PAL_DIWSTRT_V) {\n\t\t\t\tDPRINTK(\"diwstrt_v too low for pal\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\thtotal = PAL_HTOTAL>>clk_shift;\n\t\t\tvtotal = PAL_VTOTAL>>1;\n\t\t\tif (!IS_OCS) {\n\t\t\t\tpar->beamcon0 = BMC0_PAL;\n\t\t\t\tpar->bplcon3 |= BPC3_BRDRBLNK;\n\t\t\t} else if (AMIGAHW_PRESENT(AGNUS_HR_PAL) ||\n\t\t\t\t   AMIGAHW_PRESENT(AGNUS_HR_NTSC)) {\n\t\t\t\tpar->beamcon0 = BMC0_PAL;\n\t\t\t\tpar->hsstop = 1;\n\t\t\t} else if (amiga_vblank != 50) {\n\t\t\t\tDPRINTK(\"pal not supported by this chipset\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (par->htotal != NTSC_HTOTAL) {\n\t\t\t\tDPRINTK(\"htotal invalid for ntsc\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (par->diwstrt_h < NTSC_DIWSTRT_H) {\n\t\t\t\tDPRINTK(\"diwstrt_h too low for ntsc\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (par->diwstrt_v < NTSC_DIWSTRT_V) {\n\t\t\t\tDPRINTK(\"diwstrt_v too low for ntsc\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\thtotal = NTSC_HTOTAL>>clk_shift;\n\t\t\tvtotal = NTSC_VTOTAL>>1;\n\t\t\tif (!IS_OCS) {\n\t\t\t\tpar->beamcon0 = 0;\n\t\t\t\tpar->bplcon3 |= BPC3_BRDRBLNK;\n\t\t\t} else if (AMIGAHW_PRESENT(AGNUS_HR_PAL) ||\n\t\t\t\t   AMIGAHW_PRESENT(AGNUS_HR_NTSC)) {\n\t\t\t\tpar->beamcon0 = 0;\n\t\t\t\tpar->hsstop = 1;\n\t\t\t} else if (amiga_vblank != 60) {\n\t\t\t\tDPRINTK(\"ntsc not supported by this chipset\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (IS_OCS) {\n\t\t\tif (par->diwstrt_h >= 1024 || par->diwstop_h < 1024 ||\n\t\t\t    par->diwstrt_v >=  512 || par->diwstop_v <  256) {\n\t\t\t\tDPRINTK(\"invalid position for display on ocs\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else if (!IS_OCS) {\n\t\t \n\t\tpar->hsstrt = var->right_margin << clk_shift;\n\t\tpar->hsstop = (var->right_margin + var->hsync_len) << clk_shift;\n\t\tpar->diwstop_h = par->htotal - mod8(par->hsstrt) + 8 - (1 << clk_shift);\n\t\tif (!IS_AGA)\n\t\t\tpar->diwstop_h = down4(par->diwstop_h) - 16;\n\t\tpar->diwstrt_h = par->diwstop_h - xres_n;\n\t\tpar->hbstop = par->diwstrt_h + 4;\n\t\tpar->hbstrt = par->diwstop_h + 4;\n\t\tif (par->hbstrt >= par->htotal + 8)\n\t\t\tpar->hbstrt -= par->htotal;\n\t\tpar->hcenter = par->hsstrt + (par->htotal >> 1);\n\t\tpar->vsstrt = var->lower_margin << line_shift;\n\t\tpar->vsstop = (var->lower_margin + var->vsync_len) << line_shift;\n\t\tpar->diwstop_v = par->vtotal;\n\t\tif ((par->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)\n\t\t\tpar->diwstop_v -= 2;\n\t\tpar->diwstrt_v = par->diwstop_v - yres_n;\n\t\tpar->vbstop = par->diwstrt_v - 2;\n\t\tpar->vbstrt = par->diwstop_v - 2;\n\t\tif (par->vtotal > 2048) {\n\t\t\tDPRINTK(\"vtotal too high\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (par->htotal > 2048) {\n\t\t\tDPRINTK(\"htotal too high\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpar->bplcon3 |= BPC3_EXTBLKEN;\n\t\tpar->beamcon0 = BMC0_HARDDIS | BMC0_VARVBEN | BMC0_LOLDIS |\n\t\t\t\tBMC0_VARVSYEN | BMC0_VARHSYEN | BMC0_VARBEAMEN |\n\t\t\t\tBMC0_PAL | BMC0_VARCSYEN;\n\t\tif (var->sync & FB_SYNC_HOR_HIGH_ACT)\n\t\t\tpar->beamcon0 |= BMC0_HSYTRUE;\n\t\tif (var->sync & FB_SYNC_VERT_HIGH_ACT)\n\t\t\tpar->beamcon0 |= BMC0_VSYTRUE;\n\t\tif (var->sync & FB_SYNC_COMP_HIGH_ACT)\n\t\t\tpar->beamcon0 |= BMC0_CSYTRUE;\n\t\thtotal = par->htotal>>clk_shift;\n\t\tvtotal = par->vtotal>>1;\n\t} else {\n\t\tDPRINTK(\"only broadcast modes possible for ocs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tfconst = 16 << maxfmode << clk_shift;\n\n\t \n\n\n\tfsize = ((maxfmode + clk_shift <= 1) ? fconst : 64);\n\tfstrt = downx(fconst, par->diwstrt_h - 4) - fsize;\n\tif (fstrt < min_fstrt) {\n\t\tDPRINTK(\"fetch start too low\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tfstrt = downx(fconst, par->diwstrt_h - fconst + (1 << clk_shift) - 4) -\n\t\tfsize;\n\tif (fstrt < min_fstrt)\n\t\tpar->vmode &= ~FB_VMODE_SMOOTH_XPAN;\n\n\tmaxfetchstop = down16(par->htotal - 80);\n\n\tfstrt = downx(fconst, par->diwstrt_h - 4) - 64 - fconst;\n\tfsize = upx(fconst, xres_n +\n\t\t    modx(fconst, downx(1 << clk_shift, par->diwstrt_h - 4)));\n\tif (fstrt + fsize > maxfetchstop)\n\t\tpar->vmode &= ~FB_VMODE_SMOOTH_XPAN;\n\n\tfsize = upx(fconst, xres_n);\n\tif (fstrt + fsize > maxfetchstop) {\n\t\tDPRINTK(\"fetch stop too high\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (maxfmode + clk_shift <= 1) {\n\t\tfsize = up64(xres_n + fconst - 1);\n\t\tif (min_fstrt + fsize - 64 > maxfetchstop)\n\t\t\tpar->vmode &= ~FB_VMODE_SMOOTH_XPAN;\n\n\t\tfsize = up64(xres_n);\n\t\tif (min_fstrt + fsize - 64 > maxfetchstop) {\n\t\t\tDPRINTK(\"fetch size too high\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfsize -= 64;\n\t} else\n\t\tfsize -= fconst;\n\n\t \n\n\tif (par->htotal - fsize - 64 < par->bpp * 64)\n\t\tpar->vmode &= ~FB_VMODE_YWRAP;\n\n\t \n\n\tif (amifb_ilbm) {\n\t\tpar->next_plane = div8(upx(16 << maxfmode, par->vxres));\n\t\tpar->next_line = par->bpp * par->next_plane;\n\t\tif (par->next_line * par->vyres > info->fix.smem_len) {\n\t\t\tDPRINTK(\"too few video mem\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tpar->next_line = div8(upx(16 << maxfmode, par->vxres));\n\t\tpar->next_plane = par->vyres * par->next_line;\n\t\tif (par->next_plane * par->bpp > info->fix.smem_len) {\n\t\t\tDPRINTK(\"too few video mem\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\n\tpar->bplcon0 = BPC0_COLOR | bplpixmode[clk_shift];\n\tif (!IS_OCS)\n\t\tpar->bplcon0 |= BPC0_ECSENA;\n\tif (par->bpp == 8)\n\t\tpar->bplcon0 |= BPC0_BPU3;\n\telse\n\t\tpar->bplcon0 |= par->bpp << 12;\n\tif (var->nonstd == FB_NONSTD_HAM)\n\t\tpar->bplcon0 |= BPC0_HAM;\n\tif (var->sync & FB_SYNC_EXT)\n\t\tpar->bplcon0 |= BPC0_ERSY;\n\n\tif (IS_AGA)\n\t\tpar->fmode = bplfetchmode[maxfmode];\n\n\tswitch (par->vmode & FB_VMODE_MASK) {\n\tcase FB_VMODE_INTERLACED:\n\t\tpar->bplcon0 |= BPC0_LACE;\n\t\tbreak;\n\tcase FB_VMODE_DOUBLE:\n\t\tif (IS_AGA)\n\t\t\tpar->fmode |= FMODE_SSCAN2 | FMODE_BSCAN2;\n\t\tbreak;\n\t}\n\n\tif (!((par->vmode ^ var->vmode) & FB_VMODE_YWRAP)) {\n\t\tpar->xoffset = var->xoffset;\n\t\tpar->yoffset = var->yoffset;\n\t\tif (par->vmode & FB_VMODE_YWRAP) {\n\t\t\tif (par->yoffset >= par->vyres)\n\t\t\t\tpar->xoffset = par->yoffset = 0;\n\t\t} else {\n\t\t\tif (par->xoffset > upx(16 << maxfmode, par->vxres - par->xres) ||\n\t\t\t    par->yoffset > par->vyres - par->yres)\n\t\t\t\tpar->xoffset = par->yoffset = 0;\n\t\t}\n\t} else\n\t\tpar->xoffset = par->yoffset = 0;\n\n\tpar->crsr.crsr_x = par->crsr.crsr_y = 0;\n\tpar->crsr.spot_x = par->crsr.spot_y = 0;\n\tpar->crsr.height = par->crsr.width = 0;\n\n\treturn 0;\n}\n\n\t \n\nstatic void ami_encode_var(struct fb_var_screeninfo *var,\n\t\t\t   struct amifb_par *par)\n{\n\tu_short clk_shift, line_shift;\n\n\tmemset(var, 0, sizeof(struct fb_var_screeninfo));\n\n\tclk_shift = par->clk_shift;\n\tline_shift = par->line_shift;\n\n\tvar->xres = par->xres;\n\tvar->yres = par->yres;\n\tvar->xres_virtual = par->vxres;\n\tvar->yres_virtual = par->vyres;\n\tvar->xoffset = par->xoffset;\n\tvar->yoffset = par->yoffset;\n\n\tvar->bits_per_pixel = par->bpp;\n\tvar->grayscale = 0;\n\n\tvar->red.offset = 0;\n\tvar->red.msb_right = 0;\n\tvar->red.length = par->bpp;\n\tif (par->bplcon0 & BPC0_HAM)\n\t\tvar->red.length -= 2;\n\tvar->blue = var->green = var->red;\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\tvar->transp.msb_right = 0;\n\n\tif (par->bplcon0 & BPC0_HAM)\n\t\tvar->nonstd = FB_NONSTD_HAM;\n\telse\n\t\tvar->nonstd = 0;\n\tvar->activate = 0;\n\n\tvar->height = -1;\n\tvar->width = -1;\n\n\tvar->pixclock = pixclock[clk_shift];\n\n\tif (IS_AGA && par->fmode & FMODE_BSCAN2)\n\t\tvar->vmode = FB_VMODE_DOUBLE;\n\telse if (par->bplcon0 & BPC0_LACE)\n\t\tvar->vmode = FB_VMODE_INTERLACED;\n\telse\n\t\tvar->vmode = FB_VMODE_NONINTERLACED;\n\n\tif (!IS_OCS && par->beamcon0 & BMC0_VARBEAMEN) {\n\t\tvar->hsync_len = (par->hsstop - par->hsstrt)>>clk_shift;\n\t\tvar->right_margin = par->hsstrt>>clk_shift;\n\t\tvar->left_margin = (par->htotal>>clk_shift) - var->xres - var->right_margin - var->hsync_len;\n\t\tvar->vsync_len = (par->vsstop - par->vsstrt)>>line_shift;\n\t\tvar->lower_margin = par->vsstrt>>line_shift;\n\t\tvar->upper_margin = (par->vtotal>>line_shift) - var->yres - var->lower_margin - var->vsync_len;\n\t\tvar->sync = 0;\n\t\tif (par->beamcon0 & BMC0_HSYTRUE)\n\t\t\tvar->sync |= FB_SYNC_HOR_HIGH_ACT;\n\t\tif (par->beamcon0 & BMC0_VSYTRUE)\n\t\t\tvar->sync |= FB_SYNC_VERT_HIGH_ACT;\n\t\tif (par->beamcon0 & BMC0_CSYTRUE)\n\t\t\tvar->sync |= FB_SYNC_COMP_HIGH_ACT;\n\t} else {\n\t\tvar->sync = FB_SYNC_BROADCAST;\n\t\tvar->hsync_len = (152>>clk_shift) + mod4(par->diwstop_h);\n\t\tvar->right_margin = ((par->htotal - down4(par->diwstop_h))>>clk_shift) + var->hsync_len;\n\t\tvar->left_margin = (par->htotal>>clk_shift) - var->xres - var->right_margin - var->hsync_len;\n\t\tvar->vsync_len = 4>>line_shift;\n\t\tvar->lower_margin = ((par->vtotal - par->diwstop_v)>>line_shift) + var->vsync_len;\n\t\tvar->upper_margin = (((par->vtotal - 2)>>line_shift) + 1) - var->yres -\n\t\t\t\t    var->lower_margin - var->vsync_len;\n\t}\n\n\tif (par->bplcon0 & BPC0_ERSY)\n\t\tvar->sync |= FB_SYNC_EXT;\n\tif (par->vmode & FB_VMODE_YWRAP)\n\t\tvar->vmode |= FB_VMODE_YWRAP;\n}\n\n\n\t \n\nstatic void ami_update_par(struct fb_info *info)\n{\n\tstruct amifb_par *par = info->par;\n\tshort clk_shift, vshift, fstrt, fsize, fstop, fconst,  shift, move, mod;\n\n\tclk_shift = par->clk_shift;\n\n\tif (!(par->vmode & FB_VMODE_SMOOTH_XPAN))\n\t\tpar->xoffset = upx(16 << maxfmode, par->xoffset);\n\n\tfconst = 16 << maxfmode << clk_shift;\n\tvshift = modx(16 << maxfmode, par->xoffset);\n\tfstrt = par->diwstrt_h - (vshift << clk_shift) - 4;\n\tfsize = (par->xres + vshift) << clk_shift;\n\tshift = modx(fconst, fstrt);\n\tmove = downx(2 << maxfmode, div8(par->xoffset));\n\tif (maxfmode + clk_shift > 1) {\n\t\tfstrt = downx(fconst, fstrt) - 64;\n\t\tfsize = upx(fconst, fsize);\n\t\tfstop = fstrt + fsize - fconst;\n\t} else {\n\t\tmod = fstrt = downx(fconst, fstrt) - fconst;\n\t\tfstop = fstrt + upx(fconst, fsize) - 64;\n\t\tfsize = up64(fsize);\n\t\tfstrt = fstop - fsize + 64;\n\t\tif (fstrt < min_fstrt) {\n\t\t\tfstop += min_fstrt - fstrt;\n\t\t\tfstrt = min_fstrt;\n\t\t}\n\t\tmove = move - div8((mod - fstrt)>>clk_shift);\n\t}\n\tmod = par->next_line - div8(fsize>>clk_shift);\n\tpar->ddfstrt = fstrt;\n\tpar->ddfstop = fstop;\n\tpar->bplcon1 = hscroll2hw(shift);\n\tpar->bpl2mod = mod;\n\tif (par->bplcon0 & BPC0_LACE)\n\t\tpar->bpl2mod += par->next_line;\n\tif (IS_AGA && (par->fmode & FMODE_BSCAN2))\n\t\tpar->bpl1mod = -div8(fsize>>clk_shift);\n\telse\n\t\tpar->bpl1mod = par->bpl2mod;\n\n\tif (par->yoffset) {\n\t\tpar->bplpt0 = info->fix.smem_start +\n\t\t\t      par->next_line * par->yoffset + move;\n\t\tif (par->vmode & FB_VMODE_YWRAP) {\n\t\t\tif (par->yoffset > par->vyres - par->yres) {\n\t\t\t\tpar->bplpt0wrap = info->fix.smem_start + move;\n\t\t\t\tif (par->bplcon0 & BPC0_LACE &&\n\t\t\t\t    mod2(par->diwstrt_v + par->vyres -\n\t\t\t\t\t par->yoffset))\n\t\t\t\t\tpar->bplpt0wrap += par->next_line;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpar->bplpt0 = info->fix.smem_start + move;\n\n\tif (par->bplcon0 & BPC0_LACE && mod2(par->diwstrt_v))\n\t\tpar->bplpt0 += par->next_line;\n}\n\n\n\t \n\nstatic void ami_pan_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct amifb_par *par = info->par;\n\n\tpar->xoffset = var->xoffset;\n\tpar->yoffset = var->yoffset;\n\tif (var->vmode & FB_VMODE_YWRAP)\n\t\tpar->vmode |= FB_VMODE_YWRAP;\n\telse\n\t\tpar->vmode &= ~FB_VMODE_YWRAP;\n\n\tdo_vmode_pan = 0;\n\tami_update_par(info);\n\tdo_vmode_pan = 1;\n}\n\n\nstatic void ami_update_display(const struct amifb_par *par)\n{\n\tcustom.bplcon1 = par->bplcon1;\n\tcustom.bpl1mod = par->bpl1mod;\n\tcustom.bpl2mod = par->bpl2mod;\n\tcustom.ddfstrt = ddfstrt2hw(par->ddfstrt);\n\tcustom.ddfstop = ddfstop2hw(par->ddfstop);\n}\n\n\t \n\nstatic void ami_init_display(const struct amifb_par *par)\n{\n\tint i;\n\n\tcustom.bplcon0 = par->bplcon0 & ~BPC0_LACE;\n\tcustom.bplcon2 = (IS_OCS ? 0 : BPC2_KILLEHB) | BPC2_PF2P2 | BPC2_PF1P2;\n\tif (!IS_OCS) {\n\t\tcustom.bplcon3 = par->bplcon3;\n\t\tif (IS_AGA)\n\t\t\tcustom.bplcon4 = BPC4_ESPRM4 | BPC4_OSPRM4;\n\t\tif (par->beamcon0 & BMC0_VARBEAMEN) {\n\t\t\tcustom.htotal = htotal2hw(par->htotal);\n\t\t\tcustom.hbstrt = hbstrt2hw(par->hbstrt);\n\t\t\tcustom.hbstop = hbstop2hw(par->hbstop);\n\t\t\tcustom.hsstrt = hsstrt2hw(par->hsstrt);\n\t\t\tcustom.hsstop = hsstop2hw(par->hsstop);\n\t\t\tcustom.hcenter = hcenter2hw(par->hcenter);\n\t\t\tcustom.vtotal = vtotal2hw(par->vtotal);\n\t\t\tcustom.vbstrt = vbstrt2hw(par->vbstrt);\n\t\t\tcustom.vbstop = vbstop2hw(par->vbstop);\n\t\t\tcustom.vsstrt = vsstrt2hw(par->vsstrt);\n\t\t\tcustom.vsstop = vsstop2hw(par->vsstop);\n\t\t}\n\t}\n\tif (!IS_OCS || par->hsstop)\n\t\tcustom.beamcon0 = par->beamcon0;\n\tif (IS_AGA)\n\t\tcustom.fmode = par->fmode;\n\n\t \n\n\tamiga_audio_min_period = div16(par->htotal);\n\n\tis_lace = par->bplcon0 & BPC0_LACE ? 1 : 0;\n#if 1\n\tif (is_lace) {\n\t\ti = custom.vposr >> 15;\n\t} else {\n\t\tcustom.vposw = custom.vposr | 0x8000;\n\t\ti = 1;\n\t}\n#else\n\ti = 1;\n\tcustom.vposw = custom.vposr | 0x8000;\n#endif\n\tcustom.cop2lc = (u_short *)ZTWO_PADDR(copdisplay.list[currentcop][i]);\n}\n\n\t \n\nstatic void ami_do_blank(const struct amifb_par *par)\n{\n#if defined(CONFIG_FB_AMIGA_AGA)\n\tu_short bplcon3 = par->bplcon3;\n#endif\n\tu_char red, green, blue;\n\n\tif (do_blank > 0) {\n\t\tcustom.dmacon = DMAF_RASTER | DMAF_SPRITE;\n\t\tred = green = blue = 0;\n\t\tif (!IS_OCS && do_blank > 1) {\n\t\t\tswitch (do_blank) {\n\t\t\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\t\t\tcustom.hsstrt = hsstrt2hw(par->hsstrt);\n\t\t\t\tcustom.hsstop = hsstop2hw(par->hsstop);\n\t\t\t\tcustom.vsstrt = vsstrt2hw(par->vtotal + 4);\n\t\t\t\tcustom.vsstop = vsstop2hw(par->vtotal + 4);\n\t\t\t\tbreak;\n\t\t\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\t\t\tcustom.hsstrt = hsstrt2hw(par->htotal + 16);\n\t\t\t\tcustom.hsstop = hsstop2hw(par->htotal + 16);\n\t\t\t\tcustom.vsstrt = vsstrt2hw(par->vsstrt);\n\t\t\t\tcustom.vsstop = vsstrt2hw(par->vsstop);\n\t\t\t\tbreak;\n\t\t\tcase FB_BLANK_POWERDOWN:\n\t\t\t\tcustom.hsstrt = hsstrt2hw(par->htotal + 16);\n\t\t\t\tcustom.hsstop = hsstop2hw(par->htotal + 16);\n\t\t\t\tcustom.vsstrt = vsstrt2hw(par->vtotal + 4);\n\t\t\t\tcustom.vsstop = vsstop2hw(par->vtotal + 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(par->beamcon0 & BMC0_VARBEAMEN)) {\n\t\t\t\tcustom.htotal = htotal2hw(par->htotal);\n\t\t\t\tcustom.vtotal = vtotal2hw(par->vtotal);\n\t\t\t\tcustom.beamcon0 = BMC0_HARDDIS | BMC0_VARBEAMEN |\n\t\t\t\t\t\t  BMC0_VARVSYEN | BMC0_VARHSYEN | BMC0_VARCSYEN;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcustom.dmacon = DMAF_SETCLR | DMAF_RASTER | DMAF_SPRITE;\n\t\tred = red0;\n\t\tgreen = green0;\n\t\tblue = blue0;\n\t\tif (!IS_OCS) {\n\t\t\tcustom.hsstrt = hsstrt2hw(par->hsstrt);\n\t\t\tcustom.hsstop = hsstop2hw(par->hsstop);\n\t\t\tcustom.vsstrt = vsstrt2hw(par->vsstrt);\n\t\t\tcustom.vsstop = vsstop2hw(par->vsstop);\n\t\t\tcustom.beamcon0 = par->beamcon0;\n\t\t}\n\t}\n#if defined(CONFIG_FB_AMIGA_AGA)\n\tif (IS_AGA) {\n\t\tcustom.bplcon3 = bplcon3;\n\t\tcustom.color[0] = rgb2hw8_high(red, green, blue);\n\t\tcustom.bplcon3 = bplcon3 | BPC3_LOCT;\n\t\tcustom.color[0] = rgb2hw8_low(red, green, blue);\n\t\tcustom.bplcon3 = bplcon3;\n\t} else\n#endif\n#if defined(CONFIG_FB_AMIGA_ECS)\n\tif (par->bplcon0 & BPC0_SHRES) {\n\t\tu_short color, mask;\n\t\tint i;\n\n\t\tmask = 0x3333;\n\t\tcolor = rgb2hw2(red, green, blue);\n\t\tfor (i = 12; i >= 0; i -= 4)\n\t\t\tcustom.color[i] = ecs_palette[i] = (ecs_palette[i] & mask) | color;\n\t\tmask <<= 2; color >>= 2;\n\t\tfor (i = 3; i >= 0; i--)\n\t\t\tcustom.color[i] = ecs_palette[i] = (ecs_palette[i] & mask) | color;\n\t} else\n#endif\n\t\tcustom.color[0] = rgb2hw4(red, green, blue);\n\tis_blanked = do_blank > 0 ? do_blank : 0;\n}\n\nstatic int ami_get_fix_cursorinfo(struct fb_fix_cursorinfo *fix,\n\t\t\t\t  const struct amifb_par *par)\n{\n\tfix->crsr_width = fix->crsr_xsize = par->crsr.width;\n\tfix->crsr_height = fix->crsr_ysize = par->crsr.height;\n\tfix->crsr_color1 = 17;\n\tfix->crsr_color2 = 18;\n\treturn 0;\n}\n\nstatic int ami_get_var_cursorinfo(struct fb_var_cursorinfo *var,\n\t\t\t\t  u_char __user *data,\n\t\t\t\t  const struct amifb_par *par)\n{\n\tregister u_short *lspr, *sspr;\n#ifdef __mc68000__\n\tregister u_long datawords asm (\"d2\");\n#else\n\tregister u_long datawords;\n#endif\n\tregister short delta;\n\tregister u_char color;\n\tshort height, width, bits, words;\n\tint size, alloc;\n\n\tsize = par->crsr.height * par->crsr.width;\n\talloc = var->height * var->width;\n\tvar->height = par->crsr.height;\n\tvar->width = par->crsr.width;\n\tvar->xspot = par->crsr.spot_x;\n\tvar->yspot = par->crsr.spot_y;\n\tif (size > var->height * var->width)\n\t\treturn -ENAMETOOLONG;\n\tdelta = 1 << par->crsr.fmode;\n\tlspr = lofsprite + (delta << 1);\n\tif (par->bplcon0 & BPC0_LACE)\n\t\tsspr = shfsprite + (delta << 1);\n\telse\n\t\tsspr = NULL;\n\tfor (height = (short)var->height - 1; height >= 0; height--) {\n\t\tbits = 0; words = delta; datawords = 0;\n\t\tfor (width = (short)var->width - 1; width >= 0; width--) {\n\t\t\tif (bits == 0) {\n\t\t\t\tbits = 16; --words;\n#ifdef __mc68000__\n\t\t\t\tasm volatile (\"movew %1@(%3:w:2),%0 ; swap %0 ; movew %1@+,%0\"\n\t\t\t\t\t: \"=d\" (datawords), \"=a\" (lspr) : \"1\" (lspr), \"d\" (delta));\n#else\n\t\t\t\tdatawords = (*(lspr + delta) << 16) | (*lspr++);\n#endif\n\t\t\t}\n\t\t\t--bits;\n#ifdef __mc68000__\n\t\t\tasm volatile (\n\t\t\t\t\"clrb %0 ; swap %1 ; lslw #1,%1 ; roxlb #1,%0 ; \"\n\t\t\t\t\"swap %1 ; lslw #1,%1 ; roxlb #1,%0\"\n\t\t\t\t: \"=d\" (color), \"=d\" (datawords) : \"1\" (datawords));\n#else\n\t\t\tcolor = (((datawords >> 30) & 2)\n\t\t\t\t | ((datawords >> 15) & 1));\n\t\t\tdatawords <<= 1;\n#endif\n\t\t\t \n\t\t\tput_user(color, data++);\n\t\t}\n\t\tif (bits > 0) {\n\t\t\t--words; ++lspr;\n\t\t}\n\t\twhile (--words >= 0)\n\t\t\t++lspr;\n#ifdef __mc68000__\n\t\tasm volatile (\"lea %0@(%4:w:2),%0 ; tstl %1 ; jeq 1f ; exg %0,%1\\n1:\"\n\t\t\t: \"=a\" (lspr), \"=a\" (sspr) : \"0\" (lspr), \"1\" (sspr), \"d\" (delta));\n#else\n\t\tlspr += delta;\n\t\tif (sspr) {\n\t\t\tu_short *tmp = lspr;\n\t\t\tlspr = sspr;\n\t\t\tsspr = tmp;\n\t\t}\n#endif\n\t}\n\treturn 0;\n}\n\nstatic int ami_set_var_cursorinfo(struct fb_var_cursorinfo *var,\n\t\t\t\t  u_char __user *data, struct amifb_par *par)\n{\n\tregister u_short *lspr, *sspr;\n#ifdef __mc68000__\n\tregister u_long datawords asm (\"d2\");\n#else\n\tregister u_long datawords;\n#endif\n\tregister short delta;\n\tu_short fmode;\n\tshort height, width, bits, words;\n\n\tif (!var->width)\n\t\treturn -EINVAL;\n\telse if (var->width <= 16)\n\t\tfmode = TAG_FMODE_1;\n\telse if (var->width <= 32)\n\t\tfmode = TAG_FMODE_2;\n\telse if (var->width <= 64)\n\t\tfmode = TAG_FMODE_4;\n\telse\n\t\treturn -EINVAL;\n\tif (fmode > maxfmode)\n\t\treturn -EINVAL;\n\tif (!var->height)\n\t\treturn -EINVAL;\n\tdelta = 1 << fmode;\n\tlofsprite = shfsprite = (u_short *)spritememory;\n\tlspr = lofsprite + (delta << 1);\n\tif (par->bplcon0 & BPC0_LACE) {\n\t\tif (((var->height + 4) << fmode << 2) > SPRITEMEMSIZE)\n\t\t\treturn -EINVAL;\n\t\tmemset(lspr, 0, (var->height + 4) << fmode << 2);\n\t\tshfsprite += ((var->height + 5)&-2) << fmode;\n\t\tsspr = shfsprite + (delta << 1);\n\t} else {\n\t\tif (((var->height + 2) << fmode << 2) > SPRITEMEMSIZE)\n\t\t\treturn -EINVAL;\n\t\tmemset(lspr, 0, (var->height + 2) << fmode << 2);\n\t\tsspr = NULL;\n\t}\n\tfor (height = (short)var->height - 1; height >= 0; height--) {\n\t\tbits = 16; words = delta; datawords = 0;\n\t\tfor (width = (short)var->width - 1; width >= 0; width--) {\n\t\t\tunsigned long tdata = 0;\n\t\t\t \n\t\t\tget_user(tdata, data);\n\t\t\tdata++;\n#ifdef __mc68000__\n\t\t\tasm volatile (\n\t\t\t\t\"lsrb #1,%2 ; roxlw #1,%0 ; swap %0 ; \"\n\t\t\t\t\"lsrb #1,%2 ; roxlw #1,%0 ; swap %0\"\n\t\t\t\t: \"=d\" (datawords)\n\t\t\t\t: \"0\" (datawords), \"d\" (tdata));\n#else\n\t\t\tdatawords = ((datawords << 1) & 0xfffefffe);\n\t\t\tdatawords |= tdata & 1;\n\t\t\tdatawords |= (tdata & 2) << (16 - 1);\n#endif\n\t\t\tif (--bits == 0) {\n\t\t\t\tbits = 16; --words;\n#ifdef __mc68000__\n\t\t\t\tasm volatile (\"swap %2 ; movew %2,%0@(%3:w:2) ; swap %2 ; movew %2,%0@+\"\n\t\t\t\t\t: \"=a\" (lspr) : \"0\" (lspr), \"d\" (datawords), \"d\" (delta));\n#else\n\t\t\t\t*(lspr + delta) = (u_short) (datawords >> 16);\n\t\t\t\t*lspr++ = (u_short) (datawords & 0xffff);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (bits < 16) {\n\t\t\t--words;\n#ifdef __mc68000__\n\t\t\tasm volatile (\n\t\t\t\t\"swap %2 ; lslw %4,%2 ; movew %2,%0@(%3:w:2) ; \"\n\t\t\t\t\"swap %2 ; lslw %4,%2 ; movew %2,%0@+\"\n\t\t\t\t: \"=a\" (lspr) : \"0\" (lspr), \"d\" (datawords), \"d\" (delta), \"d\" (bits));\n#else\n\t\t\t*(lspr + delta) = (u_short) (datawords >> (16 + bits));\n\t\t\t*lspr++ = (u_short) ((datawords & 0x0000ffff) >> bits);\n#endif\n\t\t}\n\t\twhile (--words >= 0) {\n#ifdef __mc68000__\n\t\t\tasm volatile (\"moveql #0,%%d0 ; movew %%d0,%0@(%2:w:2) ; movew %%d0,%0@+\"\n\t\t\t\t: \"=a\" (lspr) : \"0\" (lspr), \"d\" (delta) : \"d0\");\n#else\n\t\t\t*(lspr + delta) = 0;\n\t\t\t*lspr++ = 0;\n#endif\n\t\t}\n#ifdef __mc68000__\n\t\tasm volatile (\"lea %0@(%4:w:2),%0 ; tstl %1 ; jeq 1f ; exg %0,%1\\n1:\"\n\t\t\t: \"=a\" (lspr), \"=a\" (sspr) : \"0\" (lspr), \"1\" (sspr), \"d\" (delta));\n#else\n\t\tlspr += delta;\n\t\tif (sspr) {\n\t\t\tu_short *tmp = lspr;\n\t\t\tlspr = sspr;\n\t\t\tsspr = tmp;\n\t\t}\n#endif\n\t}\n\tpar->crsr.height = var->height;\n\tpar->crsr.width = var->width;\n\tpar->crsr.spot_x = var->xspot;\n\tpar->crsr.spot_y = var->yspot;\n\tpar->crsr.fmode = fmode;\n\tif (IS_AGA) {\n\t\tpar->fmode &= ~(FMODE_SPAGEM | FMODE_SPR32);\n\t\tpar->fmode |= sprfetchmode[fmode];\n\t\tcustom.fmode = par->fmode;\n\t}\n\treturn 0;\n}\n\nstatic int ami_get_cursorstate(struct fb_cursorstate *state,\n\t\t\t       const struct amifb_par *par)\n{\n\tstate->xoffset = par->crsr.crsr_x;\n\tstate->yoffset = par->crsr.crsr_y;\n\tstate->mode = cursormode;\n\treturn 0;\n}\n\nstatic int ami_set_cursorstate(struct fb_cursorstate *state,\n\t\t\t       struct amifb_par *par)\n{\n\tpar->crsr.crsr_x = state->xoffset;\n\tpar->crsr.crsr_y = state->yoffset;\n\tif ((cursormode = state->mode) == FB_CURSOR_OFF)\n\t\tcursorstate = -1;\n\tdo_cursor = 1;\n\treturn 0;\n}\n\nstatic void ami_set_sprite(const struct amifb_par *par)\n{\n\tcopins *copl, *cops;\n\tu_short hs, vs, ve;\n\tu_long pl, ps;\n\tshort mx, my;\n\n\tcops = copdisplay.list[currentcop][0];\n\tcopl = copdisplay.list[currentcop][1];\n\tps = pl = ZTWO_PADDR(dummysprite);\n\tmx = par->crsr.crsr_x - par->crsr.spot_x;\n\tmy = par->crsr.crsr_y - par->crsr.spot_y;\n\tif (!(par->vmode & FB_VMODE_YWRAP)) {\n\t\tmx -= par->xoffset;\n\t\tmy -= par->yoffset;\n\t}\n\tif (!is_blanked && cursorstate > 0 && par->crsr.height > 0 &&\n\t    mx > -(short)par->crsr.width && mx < par->xres &&\n\t    my > -(short)par->crsr.height && my < par->yres) {\n\t\tpl = ZTWO_PADDR(lofsprite);\n\t\ths = par->diwstrt_h + (mx << par->clk_shift) - 4;\n\t\tvs = par->diwstrt_v + (my << par->line_shift);\n\t\tve = vs + (par->crsr.height << par->line_shift);\n\t\tif (par->bplcon0 & BPC0_LACE) {\n\t\t\tps = ZTWO_PADDR(shfsprite);\n\t\t\tlofsprite[0] = spr2hw_pos(vs, hs);\n\t\t\tshfsprite[0] = spr2hw_pos(vs + 1, hs);\n\t\t\tif (mod2(vs)) {\n\t\t\t\tlofsprite[1 << par->crsr.fmode] = spr2hw_ctl(vs, hs, ve);\n\t\t\t\tshfsprite[1 << par->crsr.fmode] = spr2hw_ctl(vs + 1, hs, ve + 1);\n\t\t\t\tswap(pl, ps);\n\t\t\t} else {\n\t\t\t\tlofsprite[1 << par->crsr.fmode] = spr2hw_ctl(vs, hs, ve + 1);\n\t\t\t\tshfsprite[1 << par->crsr.fmode] = spr2hw_ctl(vs + 1, hs, ve);\n\t\t\t}\n\t\t} else {\n\t\t\tlofsprite[0] = spr2hw_pos(vs, hs) | (IS_AGA && (par->fmode & FMODE_BSCAN2) ? 0x80 : 0);\n\t\t\tlofsprite[1 << par->crsr.fmode] = spr2hw_ctl(vs, hs, ve);\n\t\t}\n\t}\n\tcopl[cop_spr0ptrh].w[1] = highw(pl);\n\tcopl[cop_spr0ptrl].w[1] = loww(pl);\n\tif (par->bplcon0 & BPC0_LACE) {\n\t\tcops[cop_spr0ptrh].w[1] = highw(ps);\n\t\tcops[cop_spr0ptrl].w[1] = loww(ps);\n\t}\n}\n\n\n\t \n\nstatic void __init ami_init_copper(void)\n{\n\tcopins *cop = copdisplay.init;\n\tu_long p;\n\tint i;\n\n\tif (!IS_OCS) {\n\t\t(cop++)->l = CMOVE(BPC0_COLOR | BPC0_SHRES | BPC0_ECSENA, bplcon0);\n\t\t(cop++)->l = CMOVE(0x0181, diwstrt);\n\t\t(cop++)->l = CMOVE(0x0281, diwstop);\n\t\t(cop++)->l = CMOVE(0x0000, diwhigh);\n\t} else\n\t\t(cop++)->l = CMOVE(BPC0_COLOR, bplcon0);\n\tp = ZTWO_PADDR(dummysprite);\n\tfor (i = 0; i < 8; i++) {\n\t\t(cop++)->l = CMOVE(0, spr[i].pos);\n\t\t(cop++)->l = CMOVE(highw(p), sprpt[i]);\n\t\t(cop++)->l = CMOVE2(loww(p), sprpt[i]);\n\t}\n\n\t(cop++)->l = CMOVE(IF_SETCLR | IF_COPER, intreq);\n\tcopdisplay.wait = cop;\n\t(cop++)->l = CEND;\n\t(cop++)->l = CMOVE(0, copjmp2);\n\tcop->l = CEND;\n\n\tcustom.cop1lc = (u_short *)ZTWO_PADDR(copdisplay.init);\n\tcustom.copjmp1 = 0;\n}\n\nstatic void ami_reinit_copper(const struct amifb_par *par)\n{\n\tcopdisplay.init[cip_bplcon0].w[1] = ~(BPC0_BPU3 | BPC0_BPU2 | BPC0_BPU1 | BPC0_BPU0) & par->bplcon0;\n\tcopdisplay.wait->l = CWAIT(32, par->diwstrt_v - 4);\n}\n\n\n\t \n\nstatic void ami_rebuild_copper(const struct amifb_par *par)\n{\n\tcopins *copl, *cops;\n\tu_short line, h_end1, h_end2;\n\tshort i;\n\tu_long p;\n\n\tif (IS_AGA && maxfmode + par->clk_shift == 0)\n\t\th_end1 = par->diwstrt_h - 64;\n\telse\n\t\th_end1 = par->htotal - 32;\n\th_end2 = par->ddfstop + 64;\n\n\tami_set_sprite(par);\n\n\tcopl = copdisplay.rebuild[1];\n\tp = par->bplpt0;\n\tif (par->vmode & FB_VMODE_YWRAP) {\n\t\tif ((par->vyres - par->yoffset) != 1 || !mod2(par->diwstrt_v)) {\n\t\t\tif (par->yoffset > par->vyres - par->yres) {\n\t\t\t\tfor (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {\n\t\t\t\t\t(copl++)->l = CMOVE(highw(p), bplpt[i]);\n\t\t\t\t\t(copl++)->l = CMOVE2(loww(p), bplpt[i]);\n\t\t\t\t}\n\t\t\t\tline = par->diwstrt_v + ((par->vyres - par->yoffset) << par->line_shift) - 1;\n\t\t\t\twhile (line >= 512) {\n\t\t\t\t\t(copl++)->l = CWAIT(h_end1, 510);\n\t\t\t\t\tline -= 512;\n\t\t\t\t}\n\t\t\t\tif (line >= 510 && IS_AGA && maxfmode + par->clk_shift == 0)\n\t\t\t\t\t(copl++)->l = CWAIT(h_end1, line);\n\t\t\t\telse\n\t\t\t\t\t(copl++)->l = CWAIT(h_end2, line);\n\t\t\t\tp = par->bplpt0wrap;\n\t\t\t}\n\t\t} else\n\t\t\tp = par->bplpt0wrap;\n\t}\n\tfor (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {\n\t\t(copl++)->l = CMOVE(highw(p), bplpt[i]);\n\t\t(copl++)->l = CMOVE2(loww(p), bplpt[i]);\n\t}\n\tcopl->l = CEND;\n\n\tif (par->bplcon0 & BPC0_LACE) {\n\t\tcops = copdisplay.rebuild[0];\n\t\tp = par->bplpt0;\n\t\tif (mod2(par->diwstrt_v))\n\t\t\tp -= par->next_line;\n\t\telse\n\t\t\tp += par->next_line;\n\t\tif (par->vmode & FB_VMODE_YWRAP) {\n\t\t\tif ((par->vyres - par->yoffset) != 1 || mod2(par->diwstrt_v)) {\n\t\t\t\tif (par->yoffset > par->vyres - par->yres + 1) {\n\t\t\t\t\tfor (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {\n\t\t\t\t\t\t(cops++)->l = CMOVE(highw(p), bplpt[i]);\n\t\t\t\t\t\t(cops++)->l = CMOVE2(loww(p), bplpt[i]);\n\t\t\t\t\t}\n\t\t\t\t\tline = par->diwstrt_v + ((par->vyres - par->yoffset) << par->line_shift) - 2;\n\t\t\t\t\twhile (line >= 512) {\n\t\t\t\t\t\t(cops++)->l = CWAIT(h_end1, 510);\n\t\t\t\t\t\tline -= 512;\n\t\t\t\t\t}\n\t\t\t\t\tif (line > 510 && IS_AGA && maxfmode + par->clk_shift == 0)\n\t\t\t\t\t\t(cops++)->l = CWAIT(h_end1, line);\n\t\t\t\t\telse\n\t\t\t\t\t\t(cops++)->l = CWAIT(h_end2, line);\n\t\t\t\t\tp = par->bplpt0wrap;\n\t\t\t\t\tif (mod2(par->diwstrt_v + par->vyres -\n\t\t\t\t\t    par->yoffset))\n\t\t\t\t\t\tp -= par->next_line;\n\t\t\t\t\telse\n\t\t\t\t\t\tp += par->next_line;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tp = par->bplpt0wrap - par->next_line;\n\t\t}\n\t\tfor (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {\n\t\t\t(cops++)->l = CMOVE(highw(p), bplpt[i]);\n\t\t\t(cops++)->l = CMOVE2(loww(p), bplpt[i]);\n\t\t}\n\t\tcops->l = CEND;\n\t}\n}\n\n\n\t \n\nstatic void ami_build_copper(struct fb_info *info)\n{\n\tstruct amifb_par *par = info->par;\n\tcopins *copl, *cops;\n\tu_long p;\n\n\tcurrentcop = 1 - currentcop;\n\n\tcopl = copdisplay.list[currentcop][1];\n\n\t(copl++)->l = CWAIT(0, 10);\n\t(copl++)->l = CMOVE(par->bplcon0, bplcon0);\n\t(copl++)->l = CMOVE(0, sprpt[0]);\n\t(copl++)->l = CMOVE2(0, sprpt[0]);\n\n\tif (par->bplcon0 & BPC0_LACE) {\n\t\tcops = copdisplay.list[currentcop][0];\n\n\t\t(cops++)->l = CWAIT(0, 10);\n\t\t(cops++)->l = CMOVE(par->bplcon0, bplcon0);\n\t\t(cops++)->l = CMOVE(0, sprpt[0]);\n\t\t(cops++)->l = CMOVE2(0, sprpt[0]);\n\n\t\t(copl++)->l = CMOVE(diwstrt2hw(par->diwstrt_h, par->diwstrt_v + 1), diwstrt);\n\t\t(copl++)->l = CMOVE(diwstop2hw(par->diwstop_h, par->diwstop_v + 1), diwstop);\n\t\t(cops++)->l = CMOVE(diwstrt2hw(par->diwstrt_h, par->diwstrt_v), diwstrt);\n\t\t(cops++)->l = CMOVE(diwstop2hw(par->diwstop_h, par->diwstop_v), diwstop);\n\t\tif (!IS_OCS) {\n\t\t\t(copl++)->l = CMOVE(diwhigh2hw(par->diwstrt_h, par->diwstrt_v + 1,\n\t\t\t\t\t    par->diwstop_h, par->diwstop_v + 1), diwhigh);\n\t\t\t(cops++)->l = CMOVE(diwhigh2hw(par->diwstrt_h, par->diwstrt_v,\n\t\t\t\t\t    par->diwstop_h, par->diwstop_v), diwhigh);\n#if 0\n\t\t\tif (par->beamcon0 & BMC0_VARBEAMEN) {\n\t\t\t\t(copl++)->l = CMOVE(vtotal2hw(par->vtotal), vtotal);\n\t\t\t\t(copl++)->l = CMOVE(vbstrt2hw(par->vbstrt + 1), vbstrt);\n\t\t\t\t(copl++)->l = CMOVE(vbstop2hw(par->vbstop + 1), vbstop);\n\t\t\t\t(cops++)->l = CMOVE(vtotal2hw(par->vtotal), vtotal);\n\t\t\t\t(cops++)->l = CMOVE(vbstrt2hw(par->vbstrt), vbstrt);\n\t\t\t\t(cops++)->l = CMOVE(vbstop2hw(par->vbstop), vbstop);\n\t\t\t}\n#endif\n\t\t}\n\t\tp = ZTWO_PADDR(copdisplay.list[currentcop][0]);\n\t\t(copl++)->l = CMOVE(highw(p), cop2lc);\n\t\t(copl++)->l = CMOVE2(loww(p), cop2lc);\n\t\tp = ZTWO_PADDR(copdisplay.list[currentcop][1]);\n\t\t(cops++)->l = CMOVE(highw(p), cop2lc);\n\t\t(cops++)->l = CMOVE2(loww(p), cop2lc);\n\t\tcopdisplay.rebuild[0] = cops;\n\t} else {\n\t\t(copl++)->l = CMOVE(diwstrt2hw(par->diwstrt_h, par->diwstrt_v), diwstrt);\n\t\t(copl++)->l = CMOVE(diwstop2hw(par->diwstop_h, par->diwstop_v), diwstop);\n\t\tif (!IS_OCS) {\n\t\t\t(copl++)->l = CMOVE(diwhigh2hw(par->diwstrt_h, par->diwstrt_v,\n\t\t\t\t\t    par->diwstop_h, par->diwstop_v), diwhigh);\n#if 0\n\t\t\tif (par->beamcon0 & BMC0_VARBEAMEN) {\n\t\t\t\t(copl++)->l = CMOVE(vtotal2hw(par->vtotal), vtotal);\n\t\t\t\t(copl++)->l = CMOVE(vbstrt2hw(par->vbstrt), vbstrt);\n\t\t\t\t(copl++)->l = CMOVE(vbstop2hw(par->vbstop), vbstop);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\tcopdisplay.rebuild[1] = copl;\n\n\tami_update_par(info);\n\tami_rebuild_copper(info->par);\n}\n\n#ifndef MODULE\nstatic void __init amifb_setup_mcap(char *spec)\n{\n\tchar *p;\n\tint vmin, vmax, hmin, hmax;\n\n\t \n\n\tif (!(p = strsep(&spec, \";\")) || !*p)\n\t\treturn;\n\tvmin = simple_strtoul(p, NULL, 10);\n\tif (vmin <= 0)\n\t\treturn;\n\tif (!(p = strsep(&spec, \";\")) || !*p)\n\t\treturn;\n\tvmax = simple_strtoul(p, NULL, 10);\n\tif (vmax <= 0 || vmax <= vmin)\n\t\treturn;\n\tif (!(p = strsep(&spec, \";\")) || !*p)\n\t\treturn;\n\thmin = 1000 * simple_strtoul(p, NULL, 10);\n\tif (hmin <= 0)\n\t\treturn;\n\tif (!(p = strsep(&spec, \"\")) || !*p)\n\t\treturn;\n\thmax = 1000 * simple_strtoul(p, NULL, 10);\n\tif (hmax <= 0 || hmax <= hmin)\n\t\treturn;\n\n\tamifb_hfmin = hmin;\n\tamifb_hfmax = hmax;\n\tamifb_vfmin = vmin;\n\tamifb_vfmax = vmax;\n}\n\nstatic int __init amifb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\t\tif (!strcmp(this_opt, \"inverse\")) {\n\t\t\tfb_invert_cmaps();\n\t\t} else if (!strcmp(this_opt, \"ilbm\"))\n\t\t\tamifb_ilbm = 1;\n\t\telse if (!strncmp(this_opt, \"monitorcap:\", 11))\n\t\t\tamifb_setup_mcap(this_opt + 11);\n\t\telse if (!strncmp(this_opt, \"fstart:\", 7))\n\t\t\tmin_fstrt = simple_strtoul(this_opt + 7, NULL, 0);\n\t\telse\n\t\t\tmode_option = this_opt;\n\t}\n\n\tif (min_fstrt < 48)\n\t\tmin_fstrt = 48;\n\n\treturn 0;\n}\n#endif\n\nstatic int amifb_check_var(struct fb_var_screeninfo *var,\n\t\t\t   struct fb_info *info)\n{\n\tint err;\n\tstruct amifb_par par;\n\n\t \n\terr = ami_decode_var(var, &par, info);\n\tif (err)\n\t\treturn err;\n\n\t \n\tami_encode_var(var, &par);\n\treturn 0;\n}\n\n\nstatic int amifb_set_par(struct fb_info *info)\n{\n\tstruct amifb_par *par = info->par;\n\tint error;\n\n\tdo_vmode_pan = 0;\n\tdo_vmode_full = 0;\n\n\t \n\terror = ami_decode_var(&info->var, par, info);\n\tif (error)\n\t\treturn error;\n\n\t \n\tami_build_copper(info);\n\n\t \n\tdo_vmode_full = 1;\n\n\t \n\tif (par->bpp == 1) {\n\t\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\t\tinfo->fix.type_aux = 0;\n\t} else if (amifb_ilbm) {\n\t\tinfo->fix.type = FB_TYPE_INTERLEAVED_PLANES;\n\t\tinfo->fix.type_aux = par->next_line;\n\t} else {\n\t\tinfo->fix.type = FB_TYPE_PLANES;\n\t\tinfo->fix.type_aux = 0;\n\t}\n\tinfo->fix.line_length = div8(upx(16 << maxfmode, par->vxres));\n\n\tif (par->vmode & FB_VMODE_YWRAP) {\n\t\tinfo->fix.ywrapstep = 1;\n\t\tinfo->fix.xpanstep = 0;\n\t\tinfo->fix.ypanstep = 0;\n\t\tinfo->flags = FBINFO_HWACCEL_YWRAP |\n\t\t\tFBINFO_READS_FAST;  \n\t} else {\n\t\tinfo->fix.ywrapstep = 0;\n\t\tif (par->vmode & FB_VMODE_SMOOTH_XPAN)\n\t\t\tinfo->fix.xpanstep = 1;\n\t\telse\n\t\t\tinfo->fix.xpanstep = 16 << maxfmode;\n\t\tinfo->fix.ypanstep = 1;\n\t\tinfo->flags = FBINFO_HWACCEL_YPAN;\n\t}\n\treturn 0;\n}\n\n\n\t \n\nstatic int amifb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t   u_int transp, struct fb_info *info)\n{\n\tconst struct amifb_par *par = info->par;\n\n\tif (IS_AGA) {\n\t\tif (regno > 255)\n\t\t\treturn 1;\n\t} else if (par->bplcon0 & BPC0_SHRES) {\n\t\tif (regno > 3)\n\t\t\treturn 1;\n\t} else {\n\t\tif (regno > 31)\n\t\t\treturn 1;\n\t}\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\tif (!regno) {\n\t\tred0 = red;\n\t\tgreen0 = green;\n\t\tblue0 = blue;\n\t}\n\n\t \n\n\tif (regno || !is_blanked) {\n#if defined(CONFIG_FB_AMIGA_AGA)\n\t\tif (IS_AGA) {\n\t\t\tu_short bplcon3 = par->bplcon3;\n\t\t\tVBlankOff();\n\t\t\tcustom.bplcon3 = bplcon3 | (regno << 8 & 0xe000);\n\t\t\tcustom.color[regno & 31] = rgb2hw8_high(red, green,\n\t\t\t\t\t\t\t\tblue);\n\t\t\tcustom.bplcon3 = bplcon3 | (regno << 8 & 0xe000) |\n\t\t\t\t\t BPC3_LOCT;\n\t\t\tcustom.color[regno & 31] = rgb2hw8_low(red, green,\n\t\t\t\t\t\t\t       blue);\n\t\t\tcustom.bplcon3 = bplcon3;\n\t\t\tVBlankOn();\n\t\t} else\n#endif\n#if defined(CONFIG_FB_AMIGA_ECS)\n\t\tif (par->bplcon0 & BPC0_SHRES) {\n\t\t\tu_short color, mask;\n\t\t\tint i;\n\n\t\t\tmask = 0x3333;\n\t\t\tcolor = rgb2hw2(red, green, blue);\n\t\t\tVBlankOff();\n\t\t\tfor (i = regno + 12; i >= (int)regno; i -= 4)\n\t\t\t\tcustom.color[i] = ecs_palette[i] = (ecs_palette[i] & mask) | color;\n\t\t\tmask <<= 2; color >>= 2;\n\t\t\tregno = down16(regno) + mul4(mod4(regno));\n\t\t\tfor (i = regno + 3; i >= (int)regno; i--)\n\t\t\t\tcustom.color[i] = ecs_palette[i] = (ecs_palette[i] & mask) | color;\n\t\t\tVBlankOn();\n\t\t} else\n#endif\n\t\t\tcustom.color[regno] = rgb2hw4(red, green, blue);\n\t}\n\treturn 0;\n}\n\n\n\t \n\nstatic int amifb_blank(int blank, struct fb_info *info)\n{\n\tdo_blank = blank ? blank : -1;\n\n\treturn 0;\n}\n\n\n\t \n\nstatic int amifb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tif (!(var->vmode & FB_VMODE_YWRAP)) {\n\t\t \n\t\tif (var->xoffset + info->var.xres >\n\t\t    upx(16 << maxfmode, info->var.xres_virtual))\n\t\t\treturn -EINVAL;\n\t}\n\tami_pan_var(var, info);\n\treturn 0;\n}\n\n\n#if BITS_PER_LONG == 32\n#define BYTES_PER_LONG\t4\n#define SHIFT_PER_LONG\t5\n#elif BITS_PER_LONG == 64\n#define BYTES_PER_LONG\t8\n#define SHIFT_PER_LONG\t6\n#else\n#define Please update me\n#endif\n\n\n\t \n\nstatic inline unsigned long comp(unsigned long a, unsigned long b,\n\t\t\t\t unsigned long mask)\n{\n\treturn ((a ^ b) & mask) ^ b;\n}\n\n\nstatic inline unsigned long xor(unsigned long a, unsigned long b,\n\t\t\t\tunsigned long mask)\n{\n\treturn (a & mask) ^ b;\n}\n\n\n\t \n\nstatic void bitcpy(unsigned long *dst, int dst_idx, const unsigned long *src,\n\t\t   int src_idx, u32 n)\n{\n\tunsigned long first, last;\n\tint shift = dst_idx - src_idx, left, right;\n\tunsigned long d0, d1;\n\tint m;\n\n\tif (!n)\n\t\treturn;\n\n\tshift = dst_idx - src_idx;\n\tfirst = ~0UL >> dst_idx;\n\tlast = ~(~0UL >> ((dst_idx + n) % BITS_PER_LONG));\n\n\tif (!shift) {\n\t\t\n\n\t\tif (dst_idx + n <= BITS_PER_LONG) {\n\t\t\t\n\t\t\tif (last)\n\t\t\t\tfirst &= last;\n\t\t\t*dst = comp(*src, *dst, first);\n\t\t} else {\n\t\t\t\n\t\t\t\n\t\t\tif (first) {\n\t\t\t\t*dst = comp(*src, *dst, first);\n\t\t\t\tdst++;\n\t\t\t\tsrc++;\n\t\t\t\tn -= BITS_PER_LONG - dst_idx;\n\t\t\t}\n\n\t\t\t\n\t\t\tn /= BITS_PER_LONG;\n\t\t\twhile (n >= 8) {\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\tn -= 8;\n\t\t\t}\n\t\t\twhile (n--)\n\t\t\t\t*dst++ = *src++;\n\n\t\t\t\n\t\t\tif (last)\n\t\t\t\t*dst = comp(*src, *dst, last);\n\t\t}\n\t} else {\n\t\t\n\n\t\tright = shift & (BITS_PER_LONG - 1);\n\t\tleft = -shift & (BITS_PER_LONG - 1);\n\n\t\tif (dst_idx + n <= BITS_PER_LONG) {\n\t\t\t\n\t\t\tif (last)\n\t\t\t\tfirst &= last;\n\t\t\tif (shift > 0) {\n\t\t\t\t\n\t\t\t\t*dst = comp(*src >> right, *dst, first);\n\t\t\t} else if (src_idx + n <= BITS_PER_LONG) {\n\t\t\t\t\n\t\t\t\t*dst = comp(*src << left, *dst, first);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\td0 = *src++;\n\t\t\t\td1 = *src;\n\t\t\t\t*dst = comp(d0 << left | d1 >> right, *dst,\n\t\t\t\t\t    first);\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\td0 = *src++;\n\t\t\t\n\t\t\tif (shift > 0) {\n\t\t\t\t\n\t\t\t\t*dst = comp(d0 >> right, *dst, first);\n\t\t\t\tdst++;\n\t\t\t\tn -= BITS_PER_LONG - dst_idx;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\td1 = *src++;\n\t\t\t\t*dst = comp(d0 << left | d1 >> right, *dst,\n\t\t\t\t\t    first);\n\t\t\t\td0 = d1;\n\t\t\t\tdst++;\n\t\t\t\tn -= BITS_PER_LONG - dst_idx;\n\t\t\t}\n\n\t\t\t\n\t\t\tm = n % BITS_PER_LONG;\n\t\t\tn /= BITS_PER_LONG;\n\t\t\twhile (n >= 4) {\n\t\t\t\td1 = *src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t\td1 = *src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t\td1 = *src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t\td1 = *src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t\tn -= 4;\n\t\t\t}\n\t\t\twhile (n--) {\n\t\t\t\td1 = *src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (last) {\n\t\t\t\tif (m <= right) {\n\t\t\t\t\t\n\t\t\t\t\t*dst = comp(d0 << left, *dst, last);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\td1 = *src;\n\t\t\t\t\t*dst = comp(d0 << left | d1 >> right,\n\t\t\t\t\t\t    *dst, last);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\t \n\nstatic void bitcpy_rev(unsigned long *dst, int dst_idx,\n\t\t       const unsigned long *src, int src_idx, u32 n)\n{\n\tunsigned long first, last;\n\tint shift = dst_idx - src_idx, left, right;\n\tunsigned long d0, d1;\n\tint m;\n\n\tif (!n)\n\t\treturn;\n\n\tdst += (n - 1) / BITS_PER_LONG;\n\tsrc += (n - 1) / BITS_PER_LONG;\n\tif ((n - 1) % BITS_PER_LONG) {\n\t\tdst_idx += (n - 1) % BITS_PER_LONG;\n\t\tdst += dst_idx >> SHIFT_PER_LONG;\n\t\tdst_idx &= BITS_PER_LONG - 1;\n\t\tsrc_idx += (n - 1) % BITS_PER_LONG;\n\t\tsrc += src_idx >> SHIFT_PER_LONG;\n\t\tsrc_idx &= BITS_PER_LONG - 1;\n\t}\n\n\tshift = dst_idx - src_idx;\n\tfirst = ~0UL << (BITS_PER_LONG - 1 - dst_idx);\n\tlast = ~(~0UL << (BITS_PER_LONG - 1 - ((dst_idx - n) % BITS_PER_LONG)));\n\n\tif (!shift) {\n\t\t\n\n\t\tif ((unsigned long)dst_idx + 1 >= n) {\n\t\t\t\n\t\t\tif (last)\n\t\t\t\tfirst &= last;\n\t\t\t*dst = comp(*src, *dst, first);\n\t\t} else {\n\t\t\t\n\t\t\t\n\t\t\tif (first) {\n\t\t\t\t*dst = comp(*src, *dst, first);\n\t\t\t\tdst--;\n\t\t\t\tsrc--;\n\t\t\t\tn -= dst_idx + 1;\n\t\t\t}\n\n\t\t\t\n\t\t\tn /= BITS_PER_LONG;\n\t\t\twhile (n >= 8) {\n\t\t\t\t*dst-- = *src--;\n\t\t\t\t*dst-- = *src--;\n\t\t\t\t*dst-- = *src--;\n\t\t\t\t*dst-- = *src--;\n\t\t\t\t*dst-- = *src--;\n\t\t\t\t*dst-- = *src--;\n\t\t\t\t*dst-- = *src--;\n\t\t\t\t*dst-- = *src--;\n\t\t\t\tn -= 8;\n\t\t\t}\n\t\t\twhile (n--)\n\t\t\t\t*dst-- = *src--;\n\n\t\t\t\n\t\t\tif (last)\n\t\t\t\t*dst = comp(*src, *dst, last);\n\t\t}\n\t} else {\n\t\t\n\n\t\tright = shift & (BITS_PER_LONG - 1);\n\t\tleft = -shift & (BITS_PER_LONG - 1);\n\n\t\tif ((unsigned long)dst_idx + 1 >= n) {\n\t\t\t\n\t\t\tif (last)\n\t\t\t\tfirst &= last;\n\t\t\tif (shift < 0) {\n\t\t\t\t\n\t\t\t\t*dst = comp(*src << left, *dst, first);\n\t\t\t} else if (1 + (unsigned long)src_idx >= n) {\n\t\t\t\t\n\t\t\t\t*dst = comp(*src >> right, *dst, first);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\td0 = *src--;\n\t\t\t\td1 = *src;\n\t\t\t\t*dst = comp(d0 >> right | d1 << left, *dst,\n\t\t\t\t\t    first);\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\td0 = *src--;\n\t\t\t\n\t\t\tif (shift < 0) {\n\t\t\t\t\n\t\t\t\t*dst = comp(d0 << left, *dst, first);\n\t\t\t\tdst--;\n\t\t\t\tn -= dst_idx + 1;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\td1 = *src--;\n\t\t\t\t*dst = comp(d0 >> right | d1 << left, *dst,\n\t\t\t\t\t    first);\n\t\t\t\td0 = d1;\n\t\t\t\tdst--;\n\t\t\t\tn -= dst_idx + 1;\n\t\t\t}\n\n\t\t\t\n\t\t\tm = n % BITS_PER_LONG;\n\t\t\tn /= BITS_PER_LONG;\n\t\t\twhile (n >= 4) {\n\t\t\t\td1 = *src--;\n\t\t\t\t*dst-- = d0 >> right | d1 << left;\n\t\t\t\td0 = d1;\n\t\t\t\td1 = *src--;\n\t\t\t\t*dst-- = d0 >> right | d1 << left;\n\t\t\t\td0 = d1;\n\t\t\t\td1 = *src--;\n\t\t\t\t*dst-- = d0 >> right | d1 << left;\n\t\t\t\td0 = d1;\n\t\t\t\td1 = *src--;\n\t\t\t\t*dst-- = d0 >> right | d1 << left;\n\t\t\t\td0 = d1;\n\t\t\t\tn -= 4;\n\t\t\t}\n\t\t\twhile (n--) {\n\t\t\t\td1 = *src--;\n\t\t\t\t*dst-- = d0 >> right | d1 << left;\n\t\t\t\td0 = d1;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (last) {\n\t\t\t\tif (m <= left) {\n\t\t\t\t\t\n\t\t\t\t\t*dst = comp(d0 >> right, *dst, last);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\td1 = *src;\n\t\t\t\t\t*dst = comp(d0 >> right | d1 << left,\n\t\t\t\t\t\t    *dst, last);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\t \n\nstatic void bitcpy_not(unsigned long *dst, int dst_idx,\n\t\t       const unsigned long *src, int src_idx, u32 n)\n{\n\tunsigned long first, last;\n\tint shift = dst_idx - src_idx, left, right;\n\tunsigned long d0, d1;\n\tint m;\n\n\tif (!n)\n\t\treturn;\n\n\tshift = dst_idx - src_idx;\n\tfirst = ~0UL >> dst_idx;\n\tlast = ~(~0UL >> ((dst_idx + n) % BITS_PER_LONG));\n\n\tif (!shift) {\n\t\t\n\n\t\tif (dst_idx + n <= BITS_PER_LONG) {\n\t\t\t\n\t\t\tif (last)\n\t\t\t\tfirst &= last;\n\t\t\t*dst = comp(~*src, *dst, first);\n\t\t} else {\n\t\t\t\n\t\t\t\n\t\t\tif (first) {\n\t\t\t\t*dst = comp(~*src, *dst, first);\n\t\t\t\tdst++;\n\t\t\t\tsrc++;\n\t\t\t\tn -= BITS_PER_LONG - dst_idx;\n\t\t\t}\n\n\t\t\t\n\t\t\tn /= BITS_PER_LONG;\n\t\t\twhile (n >= 8) {\n\t\t\t\t*dst++ = ~*src++;\n\t\t\t\t*dst++ = ~*src++;\n\t\t\t\t*dst++ = ~*src++;\n\t\t\t\t*dst++ = ~*src++;\n\t\t\t\t*dst++ = ~*src++;\n\t\t\t\t*dst++ = ~*src++;\n\t\t\t\t*dst++ = ~*src++;\n\t\t\t\t*dst++ = ~*src++;\n\t\t\t\tn -= 8;\n\t\t\t}\n\t\t\twhile (n--)\n\t\t\t\t*dst++ = ~*src++;\n\n\t\t\t\n\t\t\tif (last)\n\t\t\t\t*dst = comp(~*src, *dst, last);\n\t\t}\n\t} else {\n\t\t\n\n\t\tright = shift & (BITS_PER_LONG - 1);\n\t\tleft = -shift & (BITS_PER_LONG - 1);\n\n\t\tif (dst_idx + n <= BITS_PER_LONG) {\n\t\t\t\n\t\t\tif (last)\n\t\t\t\tfirst &= last;\n\t\t\tif (shift > 0) {\n\t\t\t\t\n\t\t\t\t*dst = comp(~*src >> right, *dst, first);\n\t\t\t} else if (src_idx + n <= BITS_PER_LONG) {\n\t\t\t\t\n\t\t\t\t*dst = comp(~*src << left, *dst, first);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\td0 = ~*src++;\n\t\t\t\td1 = ~*src;\n\t\t\t\t*dst = comp(d0 << left | d1 >> right, *dst,\n\t\t\t\t\t    first);\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\td0 = ~*src++;\n\t\t\t\n\t\t\tif (shift > 0) {\n\t\t\t\t\n\t\t\t\t*dst = comp(d0 >> right, *dst, first);\n\t\t\t\tdst++;\n\t\t\t\tn -= BITS_PER_LONG - dst_idx;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\td1 = ~*src++;\n\t\t\t\t*dst = comp(d0 << left | d1 >> right, *dst,\n\t\t\t\t\t    first);\n\t\t\t\td0 = d1;\n\t\t\t\tdst++;\n\t\t\t\tn -= BITS_PER_LONG - dst_idx;\n\t\t\t}\n\n\t\t\t\n\t\t\tm = n % BITS_PER_LONG;\n\t\t\tn /= BITS_PER_LONG;\n\t\t\twhile (n >= 4) {\n\t\t\t\td1 = ~*src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t\td1 = ~*src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t\td1 = ~*src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t\td1 = ~*src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t\tn -= 4;\n\t\t\t}\n\t\t\twhile (n--) {\n\t\t\t\td1 = ~*src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (last) {\n\t\t\t\tif (m <= right) {\n\t\t\t\t\t\n\t\t\t\t\t*dst = comp(d0 << left, *dst, last);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\td1 = ~*src;\n\t\t\t\t\t*dst = comp(d0 << left | d1 >> right,\n\t\t\t\t\t\t    *dst, last);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\t \n\nstatic void bitfill32(unsigned long *dst, int dst_idx, u32 pat, u32 n)\n{\n\tunsigned long val = pat;\n\tunsigned long first, last;\n\n\tif (!n)\n\t\treturn;\n\n#if BITS_PER_LONG == 64\n\tval |= val << 32;\n#endif\n\n\tfirst = ~0UL >> dst_idx;\n\tlast = ~(~0UL >> ((dst_idx + n) % BITS_PER_LONG));\n\n\tif (dst_idx + n <= BITS_PER_LONG) {\n\t\t\n\t\tif (last)\n\t\t\tfirst &= last;\n\t\t*dst = comp(val, *dst, first);\n\t} else {\n\t\t\n\t\t\n\t\tif (first) {\n\t\t\t*dst = comp(val, *dst, first);\n\t\t\tdst++;\n\t\t\tn -= BITS_PER_LONG - dst_idx;\n\t\t}\n\n\t\t\n\t\tn /= BITS_PER_LONG;\n\t\twhile (n >= 8) {\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\tn -= 8;\n\t\t}\n\t\twhile (n--)\n\t\t\t*dst++ = val;\n\n\t\t\n\t\tif (last)\n\t\t\t*dst = comp(val, *dst, last);\n\t}\n}\n\n\n\t \n\nstatic void bitxor32(unsigned long *dst, int dst_idx, u32 pat, u32 n)\n{\n\tunsigned long val = pat;\n\tunsigned long first, last;\n\n\tif (!n)\n\t\treturn;\n\n#if BITS_PER_LONG == 64\n\tval |= val << 32;\n#endif\n\n\tfirst = ~0UL >> dst_idx;\n\tlast = ~(~0UL >> ((dst_idx + n) % BITS_PER_LONG));\n\n\tif (dst_idx + n <= BITS_PER_LONG) {\n\t\t\n\t\tif (last)\n\t\t\tfirst &= last;\n\t\t*dst = xor(val, *dst, first);\n\t} else {\n\t\t\n\t\t\n\t\tif (first) {\n\t\t\t*dst = xor(val, *dst, first);\n\t\t\tdst++;\n\t\t\tn -= BITS_PER_LONG - dst_idx;\n\t\t}\n\n\t\t\n\t\tn /= BITS_PER_LONG;\n\t\twhile (n >= 4) {\n\t\t\t*dst++ ^= val;\n\t\t\t*dst++ ^= val;\n\t\t\t*dst++ ^= val;\n\t\t\t*dst++ ^= val;\n\t\t\tn -= 4;\n\t\t}\n\t\twhile (n--)\n\t\t\t*dst++ ^= val;\n\n\t\t\n\t\tif (last)\n\t\t\t*dst = xor(val, *dst, last);\n\t}\n}\n\nstatic inline void fill_one_line(int bpp, unsigned long next_plane,\n\t\t\t\t unsigned long *dst, int dst_idx, u32 n,\n\t\t\t\t u32 color)\n{\n\twhile (1) {\n\t\tdst += dst_idx >> SHIFT_PER_LONG;\n\t\tdst_idx &= (BITS_PER_LONG - 1);\n\t\tbitfill32(dst, dst_idx, color & 1 ? ~0 : 0, n);\n\t\tif (!--bpp)\n\t\t\tbreak;\n\t\tcolor >>= 1;\n\t\tdst_idx += next_plane * 8;\n\t}\n}\n\nstatic inline void xor_one_line(int bpp, unsigned long next_plane,\n\t\t\t\tunsigned long *dst, int dst_idx, u32 n,\n\t\t\t\tu32 color)\n{\n\twhile (color) {\n\t\tdst += dst_idx >> SHIFT_PER_LONG;\n\t\tdst_idx &= (BITS_PER_LONG - 1);\n\t\tbitxor32(dst, dst_idx, color & 1 ? ~0 : 0, n);\n\t\tif (!--bpp)\n\t\t\tbreak;\n\t\tcolor >>= 1;\n\t\tdst_idx += next_plane * 8;\n\t}\n}\n\n\nstatic void amifb_fillrect(struct fb_info *info,\n\t\t\t   const struct fb_fillrect *rect)\n{\n\tstruct amifb_par *par = info->par;\n\tint dst_idx, x2, y2;\n\tunsigned long *dst;\n\tu32 width, height;\n\n\tif (!rect->width || !rect->height)\n\t\treturn;\n\n\t \n\tx2 = rect->dx + rect->width;\n\ty2 = rect->dy + rect->height;\n\tx2 = x2 < info->var.xres_virtual ? x2 : info->var.xres_virtual;\n\ty2 = y2 < info->var.yres_virtual ? y2 : info->var.yres_virtual;\n\twidth = x2 - rect->dx;\n\theight = y2 - rect->dy;\n\n\tdst = (unsigned long *)\n\t\t((unsigned long)info->screen_base & ~(BYTES_PER_LONG - 1));\n\tdst_idx = ((unsigned long)info->screen_base & (BYTES_PER_LONG - 1)) * 8;\n\tdst_idx += rect->dy * par->next_line * 8 + rect->dx;\n\twhile (height--) {\n\t\tswitch (rect->rop) {\n\t\tcase ROP_COPY:\n\t\t\tfill_one_line(info->var.bits_per_pixel,\n\t\t\t\t      par->next_plane, dst, dst_idx, width,\n\t\t\t\t      rect->color);\n\t\t\tbreak;\n\n\t\tcase ROP_XOR:\n\t\t\txor_one_line(info->var.bits_per_pixel, par->next_plane,\n\t\t\t\t     dst, dst_idx, width, rect->color);\n\t\t\tbreak;\n\t\t}\n\t\tdst_idx += par->next_line * 8;\n\t}\n}\n\nstatic inline void copy_one_line(int bpp, unsigned long next_plane,\n\t\t\t\t unsigned long *dst, int dst_idx,\n\t\t\t\t unsigned long *src, int src_idx, u32 n)\n{\n\twhile (1) {\n\t\tdst += dst_idx >> SHIFT_PER_LONG;\n\t\tdst_idx &= (BITS_PER_LONG - 1);\n\t\tsrc += src_idx >> SHIFT_PER_LONG;\n\t\tsrc_idx &= (BITS_PER_LONG - 1);\n\t\tbitcpy(dst, dst_idx, src, src_idx, n);\n\t\tif (!--bpp)\n\t\t\tbreak;\n\t\tdst_idx += next_plane * 8;\n\t\tsrc_idx += next_plane * 8;\n\t}\n}\n\nstatic inline void copy_one_line_rev(int bpp, unsigned long next_plane,\n\t\t\t\t     unsigned long *dst, int dst_idx,\n\t\t\t\t     unsigned long *src, int src_idx, u32 n)\n{\n\twhile (1) {\n\t\tdst += dst_idx >> SHIFT_PER_LONG;\n\t\tdst_idx &= (BITS_PER_LONG - 1);\n\t\tsrc += src_idx >> SHIFT_PER_LONG;\n\t\tsrc_idx &= (BITS_PER_LONG - 1);\n\t\tbitcpy_rev(dst, dst_idx, src, src_idx, n);\n\t\tif (!--bpp)\n\t\t\tbreak;\n\t\tdst_idx += next_plane * 8;\n\t\tsrc_idx += next_plane * 8;\n\t}\n}\n\n\nstatic void amifb_copyarea(struct fb_info *info,\n\t\t\t   const struct fb_copyarea *area)\n{\n\tstruct amifb_par *par = info->par;\n\tint x2, y2;\n\tu32 dx, dy, sx, sy, width, height;\n\tunsigned long *dst, *src;\n\tint dst_idx, src_idx;\n\tint rev_copy = 0;\n\n\t \n\tx2 = area->dx + area->width;\n\ty2 = area->dy + area->height;\n\tdx = area->dx > 0 ? area->dx : 0;\n\tdy = area->dy > 0 ? area->dy : 0;\n\tx2 = x2 < info->var.xres_virtual ? x2 : info->var.xres_virtual;\n\ty2 = y2 < info->var.yres_virtual ? y2 : info->var.yres_virtual;\n\twidth = x2 - dx;\n\theight = y2 - dy;\n\n\tif (area->sx + dx < area->dx || area->sy + dy < area->dy)\n\t\treturn;\n\n\t \n\tsx = area->sx + (dx - area->dx);\n\tsy = area->sy + (dy - area->dy);\n\n\t \n\tif (sx + width > info->var.xres_virtual ||\n\t\t\tsy + height > info->var.yres_virtual)\n\t\treturn;\n\n\tif (dy > sy || (dy == sy && dx > sx)) {\n\t\tdy += height;\n\t\tsy += height;\n\t\trev_copy = 1;\n\t}\n\tdst = (unsigned long *)\n\t\t((unsigned long)info->screen_base & ~(BYTES_PER_LONG - 1));\n\tsrc = dst;\n\tdst_idx = ((unsigned long)info->screen_base & (BYTES_PER_LONG - 1)) * 8;\n\tsrc_idx = dst_idx;\n\tdst_idx += dy * par->next_line * 8 + dx;\n\tsrc_idx += sy * par->next_line * 8 + sx;\n\tif (rev_copy) {\n\t\twhile (height--) {\n\t\t\tdst_idx -= par->next_line * 8;\n\t\t\tsrc_idx -= par->next_line * 8;\n\t\t\tcopy_one_line_rev(info->var.bits_per_pixel,\n\t\t\t\t\t  par->next_plane, dst, dst_idx, src,\n\t\t\t\t\t  src_idx, width);\n\t\t}\n\t} else {\n\t\twhile (height--) {\n\t\t\tcopy_one_line(info->var.bits_per_pixel,\n\t\t\t\t      par->next_plane, dst, dst_idx, src,\n\t\t\t\t      src_idx, width);\n\t\t\tdst_idx += par->next_line * 8;\n\t\t\tsrc_idx += par->next_line * 8;\n\t\t}\n\t}\n}\n\n\nstatic inline void expand_one_line(int bpp, unsigned long next_plane,\n\t\t\t\t   unsigned long *dst, int dst_idx, u32 n,\n\t\t\t\t   const u8 *data, u32 bgcolor, u32 fgcolor)\n{\n\tconst unsigned long *src;\n\tint src_idx;\n\n\twhile (1) {\n\t\tdst += dst_idx >> SHIFT_PER_LONG;\n\t\tdst_idx &= (BITS_PER_LONG - 1);\n\t\tif ((bgcolor ^ fgcolor) & 1) {\n\t\t\tsrc = (unsigned long *)\n\t\t\t\t((unsigned long)data & ~(BYTES_PER_LONG - 1));\n\t\t\tsrc_idx = ((unsigned long)data & (BYTES_PER_LONG - 1)) * 8;\n\t\t\tif (fgcolor & 1)\n\t\t\t\tbitcpy(dst, dst_idx, src, src_idx, n);\n\t\t\telse\n\t\t\t\tbitcpy_not(dst, dst_idx, src, src_idx, n);\n\t\t\t \n\t\t} else\n\t\t\tbitfill32(dst, dst_idx, fgcolor & 1 ? ~0 : 0, n);\n\t\tif (!--bpp)\n\t\t\tbreak;\n\t\tbgcolor >>= 1;\n\t\tfgcolor >>= 1;\n\t\tdst_idx += next_plane * 8;\n\t}\n}\n\n\nstatic void amifb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct amifb_par *par = info->par;\n\tint x2, y2;\n\tunsigned long *dst;\n\tint dst_idx;\n\tconst char *src;\n\tu32 dx, dy, width, height, pitch;\n\n\t \n\tx2 = image->dx + image->width;\n\ty2 = image->dy + image->height;\n\tdx = image->dx;\n\tdy = image->dy;\n\tx2 = x2 < info->var.xres_virtual ? x2 : info->var.xres_virtual;\n\ty2 = y2 < info->var.yres_virtual ? y2 : info->var.yres_virtual;\n\twidth  = x2 - dx;\n\theight = y2 - dy;\n\n\tif (image->depth == 1) {\n\t\tdst = (unsigned long *)\n\t\t\t((unsigned long)info->screen_base & ~(BYTES_PER_LONG - 1));\n\t\tdst_idx = ((unsigned long)info->screen_base & (BYTES_PER_LONG - 1)) * 8;\n\t\tdst_idx += dy * par->next_line * 8 + dx;\n\t\tsrc = image->data;\n\t\tpitch = (image->width + 7) / 8;\n\t\twhile (height--) {\n\t\t\texpand_one_line(info->var.bits_per_pixel,\n\t\t\t\t\tpar->next_plane, dst, dst_idx, width,\n\t\t\t\t\tsrc, image->bg_color,\n\t\t\t\t\timage->fg_color);\n\t\t\tdst_idx += par->next_line * 8;\n\t\t\tsrc += pitch;\n\t\t}\n\t} else {\n\t\tc2p_planar(info->screen_base, image->data, dx, dy, width,\n\t\t\t   height, par->next_line, par->next_plane,\n\t\t\t   image->width, info->var.bits_per_pixel);\n\t}\n}\n\n\n\t \n\nstatic int amifb_ioctl(struct fb_info *info,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tunion {\n\t\tstruct fb_fix_cursorinfo fix;\n\t\tstruct fb_var_cursorinfo var;\n\t\tstruct fb_cursorstate state;\n\t} crsr;\n\tvoid __user *argp = (void __user *)arg;\n\tint i;\n\n\tswitch (cmd) {\n\tcase FBIOGET_FCURSORINFO:\n\t\ti = ami_get_fix_cursorinfo(&crsr.fix, info->par);\n\t\tif (i)\n\t\t\treturn i;\n\t\treturn copy_to_user(argp, &crsr.fix,\n\t\t\t\t    sizeof(crsr.fix)) ? -EFAULT : 0;\n\n\tcase FBIOGET_VCURSORINFO:\n\t\ti = ami_get_var_cursorinfo(&crsr.var,\n\t\t\t((struct fb_var_cursorinfo __user *)arg)->data,\n\t\t\tinfo->par);\n\t\tif (i)\n\t\t\treturn i;\n\t\treturn copy_to_user(argp, &crsr.var,\n\t\t\t\t    sizeof(crsr.var)) ? -EFAULT : 0;\n\n\tcase FBIOPUT_VCURSORINFO:\n\t\tif (copy_from_user(&crsr.var, argp, sizeof(crsr.var)))\n\t\t\treturn -EFAULT;\n\t\treturn ami_set_var_cursorinfo(&crsr.var,\n\t\t\t((struct fb_var_cursorinfo __user *)arg)->data,\n\t\t\tinfo->par);\n\n\tcase FBIOGET_CURSORSTATE:\n\t\ti = ami_get_cursorstate(&crsr.state, info->par);\n\t\tif (i)\n\t\t\treturn i;\n\t\treturn copy_to_user(argp, &crsr.state,\n\t\t\t\t    sizeof(crsr.state)) ? -EFAULT : 0;\n\n\tcase FBIOPUT_CURSORSTATE:\n\t\tif (copy_from_user(&crsr.state, argp, sizeof(crsr.state)))\n\t\t\treturn -EFAULT;\n\t\treturn ami_set_cursorstate(&crsr.state, info->par);\n\t}\n\treturn -EINVAL;\n}\n\n\n\t \n\nstatic int flash_cursor(void)\n{\n\tstatic int cursorcount = 1;\n\n\tif (cursormode == FB_CURSOR_FLASH) {\n\t\tif (!--cursorcount) {\n\t\t\tcursorstate = -cursorstate;\n\t\t\tcursorcount = cursorrate;\n\t\t\tif (!is_blanked)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\t \n\nstatic irqreturn_t amifb_interrupt(int irq, void *dev_id)\n{\n\tstruct amifb_par *par = dev_id;\n\n\tif (do_vmode_pan || do_vmode_full)\n\t\tami_update_display(par);\n\n\tif (do_vmode_full)\n\t\tami_init_display(par);\n\n\tif (do_vmode_pan) {\n\t\tflash_cursor();\n\t\tami_rebuild_copper(par);\n\t\tdo_cursor = do_vmode_pan = 0;\n\t} else if (do_cursor) {\n\t\tflash_cursor();\n\t\tami_set_sprite(par);\n\t\tdo_cursor = 0;\n\t} else {\n\t\tif (flash_cursor())\n\t\t\tami_set_sprite(par);\n\t}\n\n\tif (do_blank) {\n\t\tami_do_blank(par);\n\t\tdo_blank = 0;\n\t}\n\n\tif (do_vmode_full) {\n\t\tami_reinit_copper(par);\n\t\tdo_vmode_full = 0;\n\t}\n\treturn IRQ_HANDLED;\n}\n\n\nstatic const struct fb_ops amifb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= amifb_check_var,\n\t.fb_set_par\t= amifb_set_par,\n\t.fb_setcolreg\t= amifb_setcolreg,\n\t.fb_blank\t= amifb_blank,\n\t.fb_pan_display\t= amifb_pan_display,\n\t.fb_fillrect\t= amifb_fillrect,\n\t.fb_copyarea\t= amifb_copyarea,\n\t.fb_imageblit\t= amifb_imageblit,\n\t.fb_ioctl\t= amifb_ioctl,\n};\n\n\n\t \n\nstatic void *aligned_chipptr;\n\nstatic inline u_long __init chipalloc(u_long size)\n{\n\taligned_chipptr = amiga_chip_alloc(size, \"amifb [RAM]\");\n\tif (!aligned_chipptr) {\n\t\tpr_err(\"amifb: No Chip RAM for frame buffer\");\n\t\treturn 0;\n\t}\n\tmemset(aligned_chipptr, 0, size);\n\treturn (u_long)aligned_chipptr;\n}\n\nstatic inline void chipfree(void)\n{\n\tif (aligned_chipptr)\n\t\tamiga_chip_free(aligned_chipptr);\n}\n\n\n\t \n\nstatic int __init amifb_probe(struct platform_device *pdev)\n{\n\tstruct fb_info *info;\n\tint tag, i, err = 0;\n\tu_long chipptr;\n\tu_int defmode;\n\n#ifndef MODULE\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"amifb\", &option)) {\n\t\tamifb_video_off();\n\t\treturn -ENODEV;\n\t}\n\tamifb_setup(option);\n#endif\n\tcustom.dmacon = DMAF_ALL | DMAF_MASTER;\n\n\tinfo = framebuffer_alloc(sizeof(struct amifb_par), &pdev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tstrcpy(info->fix.id, \"Amiga \");\n\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\tinfo->fix.accel = FB_ACCEL_AMIGABLITT;\n\n\tswitch (amiga_chipset) {\n#ifdef CONFIG_FB_AMIGA_OCS\n\tcase CS_OCS:\n\t\tstrcat(info->fix.id, \"OCS\");\ndefault_chipset:\n\t\tchipset = TAG_OCS;\n\t\tmaxdepth[TAG_SHRES] = 0;\t \n\t\tmaxdepth[TAG_HIRES] = 4;\n\t\tmaxdepth[TAG_LORES] = 6;\n\t\tmaxfmode = TAG_FMODE_1;\n\t\tdefmode = amiga_vblank == 50 ? DEFMODE_PAL : DEFMODE_NTSC;\n\t\tinfo->fix.smem_len = VIDEOMEMSIZE_OCS;\n\t\tbreak;\n#endif  \n\n#ifdef CONFIG_FB_AMIGA_ECS\n\tcase CS_ECS:\n\t\tstrcat(info->fix.id, \"ECS\");\n\t\tchipset = TAG_ECS;\n\t\tmaxdepth[TAG_SHRES] = 2;\n\t\tmaxdepth[TAG_HIRES] = 4;\n\t\tmaxdepth[TAG_LORES] = 6;\n\t\tmaxfmode = TAG_FMODE_1;\n\t\tif (AMIGAHW_PRESENT(AMBER_FF))\n\t\t\tdefmode = amiga_vblank == 50 ? DEFMODE_AMBER_PAL\n\t\t\t\t\t\t     : DEFMODE_AMBER_NTSC;\n\t\telse\n\t\t\tdefmode = amiga_vblank == 50 ? DEFMODE_PAL\n\t\t\t\t\t\t     : DEFMODE_NTSC;\n\t\tif (amiga_chip_avail() - CHIPRAM_SAFETY_LIMIT >\n\t\t    VIDEOMEMSIZE_ECS_2M)\n\t\t\tinfo->fix.smem_len = VIDEOMEMSIZE_ECS_2M;\n\t\telse\n\t\t\tinfo->fix.smem_len = VIDEOMEMSIZE_ECS_1M;\n\t\tbreak;\n#endif  \n\n#ifdef CONFIG_FB_AMIGA_AGA\n\tcase CS_AGA:\n\t\tstrcat(info->fix.id, \"AGA\");\n\t\tchipset = TAG_AGA;\n\t\tmaxdepth[TAG_SHRES] = 8;\n\t\tmaxdepth[TAG_HIRES] = 8;\n\t\tmaxdepth[TAG_LORES] = 8;\n\t\tmaxfmode = TAG_FMODE_4;\n\t\tdefmode = DEFMODE_AGA;\n\t\tif (amiga_chip_avail() - CHIPRAM_SAFETY_LIMIT >\n\t\t    VIDEOMEMSIZE_AGA_2M)\n\t\t\tinfo->fix.smem_len = VIDEOMEMSIZE_AGA_2M;\n\t\telse\n\t\t\tinfo->fix.smem_len = VIDEOMEMSIZE_AGA_1M;\n\t\tbreak;\n#endif  \n\n\tdefault:\n#ifdef CONFIG_FB_AMIGA_OCS\n\t\tprintk(\"Unknown graphics chipset, defaulting to OCS\\n\");\n\t\tstrcat(info->fix.id, \"Unknown\");\n\t\tgoto default_chipset;\n#else  \n\t\terr = -ENODEV;\n\t\tgoto release;\n#endif  \n\t\tbreak;\n\t}\n\n\t \n\n\t{\n\tu_long tmp = DIVUL(200000000000ULL, amiga_eclock);\n\n\tpixclock[TAG_SHRES] = (tmp + 4) / 8;\t \n\tpixclock[TAG_HIRES] = (tmp + 2) / 4;\t \n\tpixclock[TAG_LORES] = (tmp + 1) / 2;\t \n\t}\n\n\t \n\n\tfor (i = 0; i < NUM_TOTAL_MODES; i++) {\n\t\tstruct fb_videomode *mode = &ami_modedb[i];\n\t\ttag = mode->pixclock;\n\t\tif (tag == TAG_SHRES || tag == TAG_HIRES || tag == TAG_LORES) {\n\t\t\tmode->pixclock = pixclock[tag];\n\t\t}\n\t}\n\n\tif (amifb_hfmin) {\n\t\tinfo->monspecs.hfmin = amifb_hfmin;\n\t\tinfo->monspecs.hfmax = amifb_hfmax;\n\t\tinfo->monspecs.vfmin = amifb_vfmin;\n\t\tinfo->monspecs.vfmax = amifb_vfmax;\n\t} else {\n\t\t \n\t\tinfo->monspecs.hfmin = 15000;\n\t\tinfo->monspecs.hfmax = 38000;\n\t\tinfo->monspecs.vfmin = 49;\n\t\tinfo->monspecs.vfmax = 90;\n\t}\n\n\tinfo->fbops = &amifb_ops;\n\tinfo->device = &pdev->dev;\n\n\tif (!fb_find_mode(&info->var, info, mode_option, ami_modedb,\n\t\t\t  NUM_TOTAL_MODES, &ami_modedb[defmode], 4)) {\n\t\terr = -EINVAL;\n\t\tgoto release;\n\t}\n\n\tfb_videomode_to_modelist(ami_modedb, NUM_TOTAL_MODES,\n\t\t\t\t &info->modelist);\n\n\tround_down_bpp = 0;\n\tchipptr = chipalloc(info->fix.smem_len + SPRITEMEMSIZE +\n\t\t\t    DUMMYSPRITEMEMSIZE + COPINITSIZE +\n\t\t\t    4 * COPLISTSIZE);\n\tif (!chipptr) {\n\t\terr = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\tassignchunk(videomemory, u_long, chipptr, info->fix.smem_len);\n\tassignchunk(spritememory, u_long, chipptr, SPRITEMEMSIZE);\n\tassignchunk(dummysprite, u_short *, chipptr, DUMMYSPRITEMEMSIZE);\n\tassignchunk(copdisplay.init, copins *, chipptr, COPINITSIZE);\n\tassignchunk(copdisplay.list[0][0], copins *, chipptr, COPLISTSIZE);\n\tassignchunk(copdisplay.list[0][1], copins *, chipptr, COPLISTSIZE);\n\tassignchunk(copdisplay.list[1][0], copins *, chipptr, COPLISTSIZE);\n\tassignchunk(copdisplay.list[1][1], copins *, chipptr, COPLISTSIZE);\n\n\t \n\tinfo->fix.smem_start = (u_long)ZTWO_PADDR(videomemory);\n\tvideomemory = (u_long)ioremap_wt(info->fix.smem_start,\n\t\t\t\t\t info->fix.smem_len);\n\tif (!videomemory) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Unable to map videomem cached writethrough\\n\");\n\t\tinfo->screen_base = ZTWO_VADDR(info->fix.smem_start);\n\t} else\n\t\tinfo->screen_base = (char *)videomemory;\n\n\tmemset(dummysprite, 0, DUMMYSPRITEMEMSIZE);\n\n\t \n\tami_init_copper();\n\n\t \n\tcustom.dmacon = DMAF_SETCLR | DMAF_MASTER | DMAF_RASTER | DMAF_COPPER |\n\t\t\tDMAF_BLITTER | DMAF_SPRITE;\n\n\terr = request_irq(IRQ_AMIGA_COPPER, amifb_interrupt, 0,\n\t\t\t  \"fb vertb handler\", info->par);\n\tif (err)\n\t\tgoto disable_dma;\n\n\terr = fb_alloc_cmap(&info->cmap, 1 << info->var.bits_per_pixel, 0);\n\tif (err)\n\t\tgoto free_irq;\n\n\tplatform_set_drvdata(pdev, info);\n\n\terr = register_framebuffer(info);\n\tif (err)\n\t\tgoto unset_drvdata;\n\n\tfb_info(info, \"%s frame buffer device, using %dK of video memory\\n\",\n\t\tinfo->fix.id, info->fix.smem_len>>10);\n\n\treturn 0;\n\nunset_drvdata:\n\tfb_dealloc_cmap(&info->cmap);\nfree_irq:\n\tfree_irq(IRQ_AMIGA_COPPER, info->par);\ndisable_dma:\n\tcustom.dmacon = DMAF_ALL | DMAF_MASTER;\n\tif (videomemory)\n\t\tiounmap((void *)videomemory);\n\tchipfree();\nrelease:\n\tframebuffer_release(info);\n\treturn err;\n}\n\n\nstatic int __exit amifb_remove(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\tfree_irq(IRQ_AMIGA_COPPER, info->par);\n\tcustom.dmacon = DMAF_ALL | DMAF_MASTER;\n\tif (videomemory)\n\t\tiounmap((void *)videomemory);\n\tchipfree();\n\tframebuffer_release(info);\n\tamifb_video_off();\n\treturn 0;\n}\n\nstatic struct platform_driver amifb_driver = {\n\t.remove = __exit_p(amifb_remove),\n\t.driver   = {\n\t\t.name\t= \"amiga-video\",\n\t},\n};\n\nmodule_platform_driver_probe(amifb_driver, amifb_probe);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:amiga-video\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}