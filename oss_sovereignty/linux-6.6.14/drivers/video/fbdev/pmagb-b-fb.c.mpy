{
  "module_name": "pmagb-b-fb.c",
  "hash_id": "b9148a3804e18d7b337a2d8e4d29b64519bd015a7195b95100ea46f43c9b17ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/pmagb-b-fb.c",
  "human_readable_source": " \n\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/tc.h>\n#include <linux/types.h>\n\n#include <asm/io.h>\n\n#include <video/pmagb-b-fb.h>\n\n\nstruct pmagbbfb_par {\n\tvolatile void __iomem *mmio;\n\tvolatile void __iomem *smem;\n\tvolatile u32 __iomem *sfb;\n\tvolatile u32 __iomem *dac;\n\tunsigned int osc0;\n\tunsigned int osc1;\n\tint slot;\n};\n\n\nstatic const struct fb_var_screeninfo pmagbbfb_defined = {\n\t.bits_per_pixel\t= 8,\n\t.red.length\t= 8,\n\t.green.length\t= 8,\n\t.blue.length\t= 8,\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.accel_flags\t= FB_ACCEL_NONE,\n\t.sync\t\t= FB_SYNC_ON_GREEN,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\nstatic const struct fb_fix_screeninfo pmagbbfb_fix = {\n\t.id\t\t= \"PMAGB-BA\",\n\t.smem_len\t= (2048 * 1024),\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.visual\t\t= FB_VISUAL_PSEUDOCOLOR,\n\t.mmio_len\t= PMAGB_B_FBMEM,\n};\n\n\nstatic inline void sfb_write(struct pmagbbfb_par *par, unsigned int reg, u32 v)\n{\n\twritel(v, par->sfb + reg / 4);\n}\n\nstatic inline u32 sfb_read(struct pmagbbfb_par *par, unsigned int reg)\n{\n\treturn readl(par->sfb + reg / 4);\n}\n\nstatic inline void dac_write(struct pmagbbfb_par *par, unsigned int reg, u8 v)\n{\n\twriteb(v, par->dac + reg / 4);\n}\n\nstatic inline u8 dac_read(struct pmagbbfb_par *par, unsigned int reg)\n{\n\treturn readb(par->dac + reg / 4);\n}\n\nstatic inline void gp0_write(struct pmagbbfb_par *par, u32 v)\n{\n\twritel(v, par->mmio + PMAGB_B_GP0);\n}\n\n\n \nstatic int pmagbbfb_setcolreg(unsigned int regno, unsigned int red,\n\t\t\t      unsigned int green, unsigned int blue,\n\t\t\t      unsigned int transp, struct fb_info *info)\n{\n\tstruct pmagbbfb_par *par = info->par;\n\n\tif (regno >= info->cmap.len)\n\t\treturn 1;\n\n\tred   >>= 8;\t \n\tgreen >>= 8;\t \n\tblue  >>= 8;\t \n\n\tmb();\n\tdac_write(par, BT459_ADDR_LO, regno);\n\tdac_write(par, BT459_ADDR_HI, 0x00);\n\twmb();\n\tdac_write(par, BT459_CMAP, red);\n\twmb();\n\tdac_write(par, BT459_CMAP, green);\n\twmb();\n\tdac_write(par, BT459_CMAP, blue);\n\n\treturn 0;\n}\n\nstatic const struct fb_ops pmagbbfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_setcolreg\t= pmagbbfb_setcolreg,\n};\n\n\n \nstatic void pmagbbfb_erase_cursor(struct fb_info *info)\n{\n\tstruct pmagbbfb_par *par = info->par;\n\n\tmb();\n\tdac_write(par, BT459_ADDR_LO, 0x00);\n\tdac_write(par, BT459_ADDR_HI, 0x03);\n\twmb();\n\tdac_write(par, BT459_DATA, 0x00);\n}\n\n \nstatic void pmagbbfb_screen_setup(struct fb_info *info)\n{\n\tstruct pmagbbfb_par *par = info->par;\n\n\tinfo->var.xres = ((sfb_read(par, SFB_REG_VID_HOR) >>\n\t\t\t   SFB_VID_HOR_PIX_SHIFT) & SFB_VID_HOR_PIX_MASK) * 4;\n\tinfo->var.xres_virtual = info->var.xres;\n\tinfo->var.yres = (sfb_read(par, SFB_REG_VID_VER) >>\n\t\t\t  SFB_VID_VER_SL_SHIFT) & SFB_VID_VER_SL_MASK;\n\tinfo->var.yres_virtual = info->var.yres;\n\tinfo->var.left_margin = ((sfb_read(par, SFB_REG_VID_HOR) >>\n\t\t\t\t  SFB_VID_HOR_BP_SHIFT) &\n\t\t\t\t SFB_VID_HOR_BP_MASK) * 4;\n\tinfo->var.right_margin = ((sfb_read(par, SFB_REG_VID_HOR) >>\n\t\t\t\t   SFB_VID_HOR_FP_SHIFT) &\n\t\t\t\t  SFB_VID_HOR_FP_MASK) * 4;\n\tinfo->var.upper_margin = (sfb_read(par, SFB_REG_VID_VER) >>\n\t\t\t\t  SFB_VID_VER_BP_SHIFT) & SFB_VID_VER_BP_MASK;\n\tinfo->var.lower_margin = (sfb_read(par, SFB_REG_VID_VER) >>\n\t\t\t\t  SFB_VID_VER_FP_SHIFT) & SFB_VID_VER_FP_MASK;\n\tinfo->var.hsync_len = ((sfb_read(par, SFB_REG_VID_HOR) >>\n\t\t\t\tSFB_VID_HOR_SYN_SHIFT) &\n\t\t\t       SFB_VID_HOR_SYN_MASK) * 4;\n\tinfo->var.vsync_len = (sfb_read(par, SFB_REG_VID_VER) >>\n\t\t\t       SFB_VID_VER_SYN_SHIFT) & SFB_VID_VER_SYN_MASK;\n\n\tinfo->fix.line_length = info->var.xres;\n};\n\n \nstatic void pmagbbfb_osc_setup(struct fb_info *info)\n{\n\tstatic unsigned int pmagbbfb_freqs[] = {\n\t\t130808, 119843, 104000, 92980, 74370, 72800,\n\t\t69197, 66000, 65000, 50350, 36000, 32000, 25175\n\t};\n\tstruct pmagbbfb_par *par = info->par;\n\tstruct tc_bus *tbus = to_tc_dev(info->device)->bus;\n\tu32 count0 = 8, count1 = 8, counttc = 16 * 256 + 8;\n\tu32 freq0, freq1, freqtc = tc_get_speed(tbus) / 250;\n\tint i, j;\n\n\tgp0_write(par, 0);\t\t\t\t \n\tfor (j = 0; j < 16; j++) {\n\t\tmb();\n\t\tsfb_write(par, SFB_REG_TCCLK_COUNT, 0);\n\t\tmb();\n\t\tfor (i = 0; i < 100; i++) {\t \n\t\t\tif (sfb_read(par, SFB_REG_TCCLK_COUNT) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t\tcount0 += sfb_read(par, SFB_REG_VIDCLK_COUNT);\n\t}\n\n\tgp0_write(par, 1);\t\t\t\t \n\tfor (j = 0; j < 16; j++) {\n\t\tmb();\n\t\tsfb_write(par, SFB_REG_TCCLK_COUNT, 0);\n\n\t\tfor (i = 0; i < 100; i++) {\t \n\t\t\tif (sfb_read(par, SFB_REG_TCCLK_COUNT) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t\tcount1 += sfb_read(par, SFB_REG_VIDCLK_COUNT);\n\t}\n\n\tfreq0 = (freqtc * count0 + counttc / 2) / counttc;\n\tpar->osc0 = freq0;\n\tif (freq0 >= pmagbbfb_freqs[0] - (pmagbbfb_freqs[0] + 32) / 64 &&\n\t    freq0 <= pmagbbfb_freqs[0] + (pmagbbfb_freqs[0] + 32) / 64)\n\t\tpar->osc0 = pmagbbfb_freqs[0];\n\n\tfreq1 = (par->osc0 * count1 + count0 / 2) / count0;\n\tpar->osc1 = freq1;\n\tfor (i = 0; i < ARRAY_SIZE(pmagbbfb_freqs); i++)\n\t\tif (freq1 >= pmagbbfb_freqs[i] -\n\t\t\t     (pmagbbfb_freqs[i] + 128) / 256 &&\n\t\t    freq1 <= pmagbbfb_freqs[i] +\n\t\t\t     (pmagbbfb_freqs[i] + 128) / 256) {\n\t\t\tpar->osc1 = pmagbbfb_freqs[i];\n\t\t\tbreak;\n\t\t}\n\n\tif (par->osc0 - par->osc1 <= (par->osc0 + par->osc1 + 256) / 512 ||\n\t    par->osc1 - par->osc0 <= (par->osc0 + par->osc1 + 256) / 512)\n\t\tpar->osc1 = 0;\n\n\tgp0_write(par, par->osc1 != 0);\t\t\t \n\n\tinfo->var.pixclock = par->osc1 ?\n\t\t\t     (1000000000 + par->osc1 / 2) / par->osc1 :\n\t\t\t     (1000000000 + par->osc0 / 2) / par->osc0;\n};\n\n\nstatic int pmagbbfb_probe(struct device *dev)\n{\n\tstruct tc_dev *tdev = to_tc_dev(dev);\n\tresource_size_t start, len;\n\tstruct fb_info *info;\n\tstruct pmagbbfb_par *par;\n\tchar freq0[12], freq1[12];\n\tu32 vid_base;\n\tint err;\n\n\tinfo = framebuffer_alloc(sizeof(struct pmagbbfb_par), dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tdev_set_drvdata(dev, info);\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\n\t\tprintk(KERN_ERR \"%s: Cannot allocate color map\\n\",\n\t\t       dev_name(dev));\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tinfo->fbops = &pmagbbfb_ops;\n\tinfo->fix = pmagbbfb_fix;\n\tinfo->var = pmagbbfb_defined;\n\n\t \n\tstart = tdev->resource.start;\n\tlen = tdev->resource.end - start + 1;\n\tif (!request_mem_region(start, len, dev_name(dev))) {\n\t\tprintk(KERN_ERR \"%s: Cannot reserve FB region\\n\",\n\t\t       dev_name(dev));\n\t\terr = -EBUSY;\n\t\tgoto err_cmap;\n\t}\n\n\t \n\tinfo->fix.mmio_start = start;\n\tpar->mmio = ioremap(info->fix.mmio_start, info->fix.mmio_len);\n\tif (!par->mmio) {\n\t\tprintk(KERN_ERR \"%s: Cannot map MMIO\\n\", dev_name(dev));\n\t\terr = -ENOMEM;\n\t\tgoto err_resource;\n\t}\n\tpar->sfb = par->mmio + PMAGB_B_SFB;\n\tpar->dac = par->mmio + PMAGB_B_BT459;\n\n\t \n\tinfo->fix.smem_start = start + PMAGB_B_FBMEM;\n\tpar->smem = ioremap(info->fix.smem_start, info->fix.smem_len);\n\tif (!par->smem) {\n\t\tprintk(KERN_ERR \"%s: Cannot map FB\\n\", dev_name(dev));\n\t\terr = -ENOMEM;\n\t\tgoto err_mmio_map;\n\t}\n\tvid_base = sfb_read(par, SFB_REG_VID_BASE);\n\tinfo->screen_base = (void __iomem *)par->smem + vid_base * 0x1000;\n\tinfo->screen_size = info->fix.smem_len - 2 * vid_base * 0x1000;\n\n\tpmagbbfb_erase_cursor(info);\n\tpmagbbfb_screen_setup(info);\n\tpmagbbfb_osc_setup(info);\n\n\terr = register_framebuffer(info);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"%s: Cannot register framebuffer\\n\",\n\t\t       dev_name(dev));\n\t\tgoto err_smem_map;\n\t}\n\n\tget_device(dev);\n\n\tsnprintf(freq0, sizeof(freq0), \"%u.%03uMHz\",\n\t\t par->osc0 / 1000, par->osc0 % 1000);\n\tsnprintf(freq1, sizeof(freq1), \"%u.%03uMHz\",\n\t\t par->osc1 / 1000, par->osc1 % 1000);\n\n\tfb_info(info, \"%s frame buffer device at %s\\n\",\n\t\tinfo->fix.id, dev_name(dev));\n\tfb_info(info, \"Osc0: %s, Osc1: %s, Osc%u selected\\n\",\n\t\tfreq0, par->osc1 ? freq1 : \"disabled\", par->osc1 != 0);\n\n\treturn 0;\n\n\nerr_smem_map:\n\tiounmap(par->smem);\n\nerr_mmio_map:\n\tiounmap(par->mmio);\n\nerr_resource:\n\trelease_mem_region(start, len);\n\nerr_cmap:\n\tfb_dealloc_cmap(&info->cmap);\n\nerr_alloc:\n\tframebuffer_release(info);\n\treturn err;\n}\n\nstatic int pmagbbfb_remove(struct device *dev)\n{\n\tstruct tc_dev *tdev = to_tc_dev(dev);\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct pmagbbfb_par *par = info->par;\n\tresource_size_t start, len;\n\n\tput_device(dev);\n\tunregister_framebuffer(info);\n\tiounmap(par->smem);\n\tiounmap(par->mmio);\n\tstart = tdev->resource.start;\n\tlen = tdev->resource.end - start + 1;\n\trelease_mem_region(start, len);\n\tfb_dealloc_cmap(&info->cmap);\n\tframebuffer_release(info);\n\treturn 0;\n}\n\n\n \nstatic const struct tc_device_id pmagbbfb_tc_table[] = {\n\t{ \"DEC     \", \"PMAGB-BA\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(tc, pmagbbfb_tc_table);\n\nstatic struct tc_driver pmagbbfb_driver = {\n\t.id_table\t= pmagbbfb_tc_table,\n\t.driver\t\t= {\n\t\t.name\t= \"pmagbbfb\",\n\t\t.bus\t= &tc_bus_type,\n\t\t.probe\t= pmagbbfb_probe,\n\t\t.remove\t= pmagbbfb_remove,\n\t},\n};\n\nstatic int __init pmagbbfb_init(void)\n{\n#ifndef MODULE\n\tif (fb_get_options(\"pmagbbfb\", NULL))\n\t\treturn -ENXIO;\n#endif\n\treturn tc_register_driver(&pmagbbfb_driver);\n}\n\nstatic void __exit pmagbbfb_exit(void)\n{\n\ttc_unregister_driver(&pmagbbfb_driver);\n}\n\n\nmodule_init(pmagbbfb_init);\nmodule_exit(pmagbbfb_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}