{
  "module_name": "sis_main.c",
  "hash_id": "966c50cfb009325c368a3c0f75dc56c7162988aacd117584a2c621f674268b07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/sis/sis_main.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/screen_info.h>\n#include <linux/slab.h>\n#include <linux/fb.h>\n#include <linux/selection.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n\n#include \"sis.h\"\n#include \"sis_main.h\"\n#include \"init301.h\"\n\n#if !defined(CONFIG_FB_SIS_300) && !defined(CONFIG_FB_SIS_315)\n#warning Neither CONFIG_FB_SIS_300 nor CONFIG_FB_SIS_315 is set\n#warning sisfb will not work!\n#endif\n\n \n\n \n#ifndef MODULE\nstatic int sisfb_setup(char *options);\n#endif\n\n \nstatic int sisfb_init(void);\n\n \nstatic int\tsisfb_get_fix(struct fb_fix_screeninfo *fix, int con,\n\t\t\t\tstruct fb_info *info);\n\nstatic int\tsisfb_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\t    unsigned long arg);\nstatic int\tsisfb_set_par(struct fb_info *info);\nstatic int\tsisfb_blank(int blank,\n\t\t\t\tstruct fb_info *info);\n\nstatic void sisfb_handle_command(struct sis_video_info *ivideo,\n\t\t\t\t struct sisfb_cmd *sisfb_command);\n\nstatic void\tsisfb_search_mode(char *name, bool quiet);\nstatic int\tsisfb_validate_mode(struct sis_video_info *ivideo, int modeindex, u32 vbflags);\nstatic u8\tsisfb_search_refresh_rate(struct sis_video_info *ivideo, unsigned int rate,\n\t\t\t\tint index);\nstatic int\tsisfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t\tunsigned blue, unsigned transp,\n\t\t\t\tstruct fb_info *fb_info);\nstatic int\tsisfb_do_set_var(struct fb_var_screeninfo *var, int isactive,\n\t\t\t\tstruct fb_info *info);\nstatic void\tsisfb_pre_setmode(struct sis_video_info *ivideo);\nstatic void\tsisfb_post_setmode(struct sis_video_info *ivideo);\nstatic bool\tsisfb_CheckVBRetrace(struct sis_video_info *ivideo);\nstatic bool\tsisfbcheckvretracecrt2(struct sis_video_info *ivideo);\nstatic bool\tsisfbcheckvretracecrt1(struct sis_video_info *ivideo);\nstatic bool\tsisfb_bridgeisslave(struct sis_video_info *ivideo);\nstatic void\tsisfb_detect_VB_connect(struct sis_video_info *ivideo);\nstatic void\tsisfb_get_VB_type(struct sis_video_info *ivideo);\nstatic void\tsisfb_set_TVxposoffset(struct sis_video_info *ivideo, int val);\nstatic void\tsisfb_set_TVyposoffset(struct sis_video_info *ivideo, int val);\n\n \nstatic int\t\tsisfb_heap_init(struct sis_video_info *ivideo);\nstatic struct SIS_OH *\tsisfb_poh_new_node(struct SIS_HEAP *memheap);\nstatic struct SIS_OH *\tsisfb_poh_allocate(struct SIS_HEAP *memheap, u32 size);\nstatic void\t\tsisfb_delete_node(struct SIS_OH *poh);\nstatic void\t\tsisfb_insert_node(struct SIS_OH *pohList, struct SIS_OH *poh);\nstatic struct SIS_OH *\tsisfb_poh_free(struct SIS_HEAP *memheap, u32 base);\nstatic void\t\tsisfb_free_node(struct SIS_HEAP *memheap, struct SIS_OH *poh);\n\n\n \n\nstatic void __init\nsisfb_setdefaultparms(void)\n{\n\tsisfb_off\t\t= 0;\n\tsisfb_parm_mem\t\t= 0;\n\tsisfb_accel\t\t= -1;\n\tsisfb_ypan\t\t= -1;\n\tsisfb_max\t\t= -1;\n\tsisfb_userom\t\t= -1;\n\tsisfb_useoem\t\t= -1;\n\tsisfb_mode_idx\t\t= -1;\n\tsisfb_parm_rate\t\t= -1;\n\tsisfb_crt1off\t\t= 0;\n\tsisfb_forcecrt1\t\t= -1;\n\tsisfb_crt2type\t\t= -1;\n\tsisfb_crt2flags\t\t= 0;\n\tsisfb_pdc\t\t= 0xff;\n\tsisfb_pdca\t\t= 0xff;\n\tsisfb_scalelcd\t\t= -1;\n\tsisfb_specialtiming \t= CUT_NONE;\n\tsisfb_lvdshl\t\t= -1;\n\tsisfb_dstn\t\t= 0;\n\tsisfb_fstn\t\t= 0;\n\tsisfb_tvplug\t\t= -1;\n\tsisfb_tvstd\t\t= -1;\n\tsisfb_tvxposoffset\t= 0;\n\tsisfb_tvyposoffset\t= 0;\n\tsisfb_nocrt2rate\t= 0;\n#if !defined(__i386__) && !defined(__x86_64__)\n\tsisfb_resetcard\t\t= 0;\n\tsisfb_videoram\t\t= 0;\n#endif\n}\n\n \n\nstatic void sisfb_search_vesamode(unsigned int vesamode, bool quiet)\n{\n\tint i = 0, j = 0;\n\n\t \n\n\tif(vesamode == 0) {\n\t\tif(!quiet)\n\t\t\tprintk(KERN_ERR \"sisfb: Invalid mode. Using default.\\n\");\n\n\t\tsisfb_mode_idx = DEFAULT_MODE;\n\n\t\treturn;\n\t}\n\n\tvesamode &= 0x1dff;   \n\n\twhile(sisbios_mode[i++].mode_no[0] != 0) {\n\t\tif( (sisbios_mode[i-1].vesa_mode_no_1 == vesamode) ||\n\t\t    (sisbios_mode[i-1].vesa_mode_no_2 == vesamode) ) {\n\t\t\tif(sisfb_fstn) {\n\t\t\t\tif(sisbios_mode[i-1].mode_no[1] == 0x50 ||\n\t\t\t\t   sisbios_mode[i-1].mode_no[1] == 0x56 ||\n\t\t\t\t   sisbios_mode[i-1].mode_no[1] == 0x53)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif(sisbios_mode[i-1].mode_no[1] == 0x5a ||\n\t\t\t\t   sisbios_mode[i-1].mode_no[1] == 0x5b)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsisfb_mode_idx = i - 1;\n\t\t\tj = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif((!j) && !quiet)\n\t\tprintk(KERN_ERR \"sisfb: Invalid VESA mode 0x%x'\\n\", vesamode);\n}\n\nstatic void sisfb_search_mode(char *name, bool quiet)\n{\n\tunsigned int j = 0, xres = 0, yres = 0, depth = 0, rate = 0;\n\tint i = 0;\n\tchar strbuf[16], strbuf1[20];\n\tchar *nameptr = name;\n\n\t \n\n\tif(name == NULL) {\n\t\tif(!quiet)\n\t\t\tprintk(KERN_ERR \"sisfb: Internal error, using default mode.\\n\");\n\n\t\tsisfb_mode_idx = DEFAULT_MODE;\n\t\treturn;\n\t}\n\n\tif(!strncasecmp(name, sisbios_mode[MODE_INDEX_NONE].name, strlen(name))) {\n\t\tif(!quiet)\n\t\t\tprintk(KERN_ERR \"sisfb: Mode 'none' not supported anymore. Using default.\\n\");\n\n\t\tsisfb_mode_idx = DEFAULT_MODE;\n\t\treturn;\n\t}\n\n\tif(strlen(name) <= 19) {\n\t\tstrcpy(strbuf1, name);\n\t\tfor(i = 0; i < strlen(strbuf1); i++) {\n\t\t\tif(strbuf1[i] < '0' || strbuf1[i] > '9') strbuf1[i] = ' ';\n\t\t}\n\n\t\t \n\t\tif(sscanf(strbuf1, \"%u %u %u %u\", &xres, &yres, &depth, &rate) == 4) {\n\t\t\tif((rate <= 32) || (depth > 32)) {\n\t\t\t\tswap(rate, depth);\n\t\t\t}\n\t\t\tsprintf(strbuf, \"%ux%ux%u\", xres, yres, depth);\n\t\t\tnameptr = strbuf;\n\t\t\tsisfb_parm_rate = rate;\n\t\t} else if(sscanf(strbuf1, \"%u %u %u\", &xres, &yres, &depth) == 3) {\n\t\t\tsprintf(strbuf, \"%ux%ux%u\", xres, yres, depth);\n\t\t\tnameptr = strbuf;\n\t\t} else {\n\t\t\txres = 0;\n\t\t\tif((sscanf(strbuf1, \"%u %u\", &xres, &yres) == 2) && (xres != 0)) {\n\t\t\t\tsprintf(strbuf, \"%ux%ux8\", xres, yres);\n\t\t\t\tnameptr = strbuf;\n\t\t\t} else {\n\t\t\t\tsisfb_search_vesamode(simple_strtoul(name, NULL, 0), quiet);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0; j = 0;\n\twhile(sisbios_mode[i].mode_no[0] != 0) {\n\t\tif(!strncasecmp(nameptr, sisbios_mode[i++].name, strlen(nameptr))) {\n\t\t\tif(sisfb_fstn) {\n\t\t\t\tif(sisbios_mode[i-1].mode_no[1] == 0x50 ||\n\t\t\t\t   sisbios_mode[i-1].mode_no[1] == 0x56 ||\n\t\t\t\t   sisbios_mode[i-1].mode_no[1] == 0x53)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif(sisbios_mode[i-1].mode_no[1] == 0x5a ||\n\t\t\t\t   sisbios_mode[i-1].mode_no[1] == 0x5b)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsisfb_mode_idx = i - 1;\n\t\t\tj = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif((!j) && !quiet)\n\t\tprintk(KERN_ERR \"sisfb: Invalid mode '%s'\\n\", nameptr);\n}\n\n#ifndef MODULE\nstatic void sisfb_get_vga_mode_from_kernel(void)\n{\n#ifdef CONFIG_X86\n\tchar mymode[32];\n\tint  mydepth = screen_info.lfb_depth;\n\n\tif(screen_info.orig_video_isVGA != VIDEO_TYPE_VLFB) return;\n\n\tif( (screen_info.lfb_width >= 320) && (screen_info.lfb_width <= 2048) &&\n\t    (screen_info.lfb_height >= 200) && (screen_info.lfb_height <= 1536) &&\n\t    (mydepth >= 8) && (mydepth <= 32) ) {\n\n\t\tif(mydepth == 24) mydepth = 32;\n\n\t\tsprintf(mymode, \"%ux%ux%u\", screen_info.lfb_width,\n\t\t\t\t\tscreen_info.lfb_height,\n\t\t\t\t\tmydepth);\n\n\t\tprintk(KERN_DEBUG\n\t\t\t\"sisfb: Using vga mode %s pre-set by kernel as default\\n\",\n\t\t\tmymode);\n\n\t\tsisfb_search_mode(mymode, true);\n\t}\n#endif\n\treturn;\n}\n#endif\n\nstatic void __init\nsisfb_search_crt2type(const char *name)\n{\n\tint i = 0;\n\n\t \n\n\tif(name == NULL) return;\n\n\twhile(sis_crt2type[i].type_no != -1) {\n\t\tif(!strncasecmp(name, sis_crt2type[i].name, strlen(sis_crt2type[i].name))) {\n\t\t\tsisfb_crt2type = sis_crt2type[i].type_no;\n\t\t\tsisfb_tvplug = sis_crt2type[i].tvplug_no;\n\t\t\tsisfb_crt2flags = sis_crt2type[i].flags;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\tsisfb_dstn = (sisfb_crt2flags & FL_550_DSTN) ? 1 : 0;\n\tsisfb_fstn = (sisfb_crt2flags & FL_550_FSTN) ? 1 : 0;\n\n\tif(sisfb_crt2type < 0)\n\t\tprintk(KERN_ERR \"sisfb: Invalid CRT2 type: %s\\n\", name);\n}\n\nstatic void __init\nsisfb_search_tvstd(const char *name)\n{\n\tint i = 0;\n\n\t \n\n\tif(name == NULL)\n\t\treturn;\n\n\twhile(sis_tvtype[i].type_no != -1) {\n\t\tif(!strncasecmp(name, sis_tvtype[i].name, strlen(sis_tvtype[i].name))) {\n\t\t\tsisfb_tvstd = sis_tvtype[i].type_no;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n}\n\nstatic void __init\nsisfb_search_specialtiming(const char *name)\n{\n\tint i = 0;\n\tbool found = false;\n\n\t \n\n\tif(name == NULL)\n\t\treturn;\n\n\tif(!strncasecmp(name, \"none\", 4)) {\n\t\tsisfb_specialtiming = CUT_FORCENONE;\n\t\tprintk(KERN_DEBUG \"sisfb: Special timing disabled\\n\");\n\t} else {\n\t\twhile(mycustomttable[i].chipID != 0) {\n\t\t\tif(!strncasecmp(name,mycustomttable[i].optionName,\n\t\t\t   strlen(mycustomttable[i].optionName))) {\n\t\t\t\tsisfb_specialtiming = mycustomttable[i].SpecialID;\n\t\t\t\tfound = true;\n\t\t\t\tprintk(KERN_INFO \"sisfb: Special timing for %s %s forced (\\\"%s\\\")\\n\",\n\t\t\t\t\tmycustomttable[i].vendorName,\n\t\t\t\t\tmycustomttable[i].cardName,\n\t\t\t\t\tmycustomttable[i].optionName);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif(!found) {\n\t\t\tprintk(KERN_WARNING \"sisfb: Invalid SpecialTiming parameter, valid are:\");\n\t\t\tprintk(KERN_WARNING \"\\t\\\"none\\\" (to disable special timings)\\n\");\n\t\t\ti = 0;\n\t\t\twhile(mycustomttable[i].chipID != 0) {\n\t\t\t\tprintk(KERN_WARNING \"\\t\\\"%s\\\" (for %s %s)\\n\",\n\t\t\t\t\tmycustomttable[i].optionName,\n\t\t\t\t\tmycustomttable[i].vendorName,\n\t\t\t\t\tmycustomttable[i].cardName);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n\nstatic void sisfb_detect_custom_timing(struct sis_video_info *ivideo)\n{\n\tunsigned char *biosver = NULL;\n\tunsigned char *biosdate = NULL;\n\tbool footprint;\n\tu32 chksum = 0;\n\tint i, j;\n\n\tif(ivideo->SiS_Pr.UseROM) {\n\t\tbiosver = ivideo->SiS_Pr.VirtualRomBase + 0x06;\n\t\tbiosdate = ivideo->SiS_Pr.VirtualRomBase + 0x2c;\n\t\tfor(i = 0; i < 32768; i++)\n\t\t\tchksum += ivideo->SiS_Pr.VirtualRomBase[i];\n\t}\n\n\ti = 0;\n\tdo {\n\t\tif( (mycustomttable[i].chipID == ivideo->chip)\t\t\t&&\n\t\t    ((!strlen(mycustomttable[i].biosversion)) ||\n\t\t     (ivideo->SiS_Pr.UseROM &&\n\t\t      (!strncmp(mycustomttable[i].biosversion, biosver,\n\t\t\t\tstrlen(mycustomttable[i].biosversion)))))\t&&\n\t\t    ((!strlen(mycustomttable[i].biosdate)) ||\n\t\t     (ivideo->SiS_Pr.UseROM &&\n\t\t      (!strncmp(mycustomttable[i].biosdate, biosdate,\n\t\t\t\tstrlen(mycustomttable[i].biosdate)))))\t\t&&\n\t\t    ((!mycustomttable[i].bioschksum) ||\n\t\t     (ivideo->SiS_Pr.UseROM &&\n\t\t      (mycustomttable[i].bioschksum == chksum)))\t\t&&\n\t\t    (mycustomttable[i].pcisubsysvendor == ivideo->subsysvendor) &&\n\t\t    (mycustomttable[i].pcisubsyscard == ivideo->subsysdevice) ) {\n\t\t\tfootprint = true;\n\t\t\tfor(j = 0; j < 5; j++) {\n\t\t\t\tif(mycustomttable[i].biosFootprintAddr[j]) {\n\t\t\t\t\tif(ivideo->SiS_Pr.UseROM) {\n\t\t\t\t\t\tif(ivideo->SiS_Pr.VirtualRomBase[mycustomttable[i].biosFootprintAddr[j]] !=\n\t\t\t\t\t\t\tmycustomttable[i].biosFootprintData[j]) {\n\t\t\t\t\t\t\tfootprint = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tfootprint = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(footprint) {\n\t\t\t\tivideo->SiS_Pr.SiS_CustomT = mycustomttable[i].SpecialID;\n\t\t\t\tprintk(KERN_DEBUG \"sisfb: Identified [%s %s], special timing applies\\n\",\n\t\t\t\t\tmycustomttable[i].vendorName,\n\t\t\t\tmycustomttable[i].cardName);\n\t\t\t\tprintk(KERN_DEBUG \"sisfb: [specialtiming parameter name: %s]\\n\",\n\t\t\t\t\tmycustomttable[i].optionName);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t} while(mycustomttable[i].chipID);\n}\n\nstatic bool sisfb_interpret_edid(struct sisfb_monitor *monitor, u8 *buffer)\n{\n\tint i, j, xres, yres, refresh, index;\n\tu32 emodes;\n\n\tif(buffer[0] != 0x00 || buffer[1] != 0xff ||\n\t   buffer[2] != 0xff || buffer[3] != 0xff ||\n\t   buffer[4] != 0xff || buffer[5] != 0xff ||\n\t   buffer[6] != 0xff || buffer[7] != 0x00) {\n\t\tprintk(KERN_DEBUG \"sisfb: Bad EDID header\\n\");\n\t\treturn false;\n\t}\n\n\tif(buffer[0x12] != 0x01) {\n\t\tprintk(KERN_INFO \"sisfb: EDID version %d not supported\\n\",\n\t\t\tbuffer[0x12]);\n\t\treturn false;\n\t}\n\n\tmonitor->feature = buffer[0x18];\n\n\tif(!(buffer[0x14] & 0x80)) {\n\t\tif(!(buffer[0x14] & 0x08)) {\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: WARNING: Monitor does not support separate syncs\\n\");\n\t\t}\n\t}\n\n\tif(buffer[0x13] >= 0x01) {\n\t    \n\t    j = 0x36;\n\t    for(i=0; i<4; i++) {\n\t       if(buffer[j]     == 0x00 && buffer[j + 1] == 0x00 &&\n\t\t  buffer[j + 2] == 0x00 && buffer[j + 3] == 0xfd &&\n\t\t  buffer[j + 4] == 0x00) {\n\t\t  monitor->hmin = buffer[j + 7];\n\t\t  monitor->hmax = buffer[j + 8];\n\t\t  monitor->vmin = buffer[j + 5];\n\t\t  monitor->vmax = buffer[j + 6];\n\t\t  monitor->dclockmax = buffer[j + 9] * 10 * 1000;\n\t\t  monitor->datavalid = true;\n\t\t  break;\n\t       }\n\t       j += 18;\n\t    }\n\t}\n\n\tif(!monitor->datavalid) {\n\t    \n\t   monitor->hmin = 65535; monitor->hmax = 0;\n\t   monitor->vmin = 65535; monitor->vmax = 0;\n\t   monitor->dclockmax = 0;\n\t   emodes = buffer[0x23] | (buffer[0x24] << 8) | (buffer[0x25] << 16);\n\t   for(i = 0; i < 13; i++) {\n\t      if(emodes & sisfb_ddcsmodes[i].mask) {\n\t\t if(monitor->hmin > sisfb_ddcsmodes[i].h) monitor->hmin = sisfb_ddcsmodes[i].h;\n\t\t if(monitor->hmax < sisfb_ddcsmodes[i].h) monitor->hmax = sisfb_ddcsmodes[i].h + 1;\n\t\t if(monitor->vmin > sisfb_ddcsmodes[i].v) monitor->vmin = sisfb_ddcsmodes[i].v;\n\t\t if(monitor->vmax < sisfb_ddcsmodes[i].v) monitor->vmax = sisfb_ddcsmodes[i].v;\n\t\t if(monitor->dclockmax < sisfb_ddcsmodes[i].d) monitor->dclockmax = sisfb_ddcsmodes[i].d;\n\t      }\n\t   }\n\t   index = 0x26;\n\t   for(i = 0; i < 8; i++) {\n\t      xres = (buffer[index] + 31) * 8;\n\t      switch(buffer[index + 1] & 0xc0) {\n\t\t case 0xc0: yres = (xres * 9) / 16; break;\n\t\t case 0x80: yres = (xres * 4) /  5; break;\n\t\t case 0x40: yres = (xres * 3) /  4; break;\n\t\t default:   yres = xres;\t    break;\n\t      }\n\t      refresh = (buffer[index + 1] & 0x3f) + 60;\n\t      if((xres >= 640) && (yres >= 480)) {\n\t\t for(j = 0; j < 8; j++) {\n\t\t    if((xres == sisfb_ddcfmodes[j].x) &&\n\t\t       (yres == sisfb_ddcfmodes[j].y) &&\n\t\t       (refresh == sisfb_ddcfmodes[j].v)) {\n\t\t      if(monitor->hmin > sisfb_ddcfmodes[j].h) monitor->hmin = sisfb_ddcfmodes[j].h;\n\t\t      if(monitor->hmax < sisfb_ddcfmodes[j].h) monitor->hmax = sisfb_ddcfmodes[j].h + 1;\n\t\t      if(monitor->vmin > sisfb_ddcsmodes[j].v) monitor->vmin = sisfb_ddcsmodes[j].v;\n\t\t      if(monitor->vmax < sisfb_ddcsmodes[j].v) monitor->vmax = sisfb_ddcsmodes[j].v;\n\t\t      if(monitor->dclockmax < sisfb_ddcsmodes[j].d) monitor->dclockmax = sisfb_ddcsmodes[j].d;\n\t\t    }\n\t\t }\n\t      }\n\t      index += 2;\n\t   }\n\t   if((monitor->hmin <= monitor->hmax) && (monitor->vmin <= monitor->vmax)) {\n\t      monitor->datavalid = true;\n\t   }\n\t}\n\n\treturn monitor->datavalid;\n}\n\nstatic void sisfb_handle_ddc(struct sis_video_info *ivideo,\n\t\t\t     struct sisfb_monitor *monitor, int crtno)\n{\n\tunsigned short temp, i, realcrtno = crtno;\n\tunsigned char  buffer[256];\n\n\tmonitor->datavalid = false;\n\n\tif(crtno) {\n\t   if(ivideo->vbflags & CRT2_LCD)      realcrtno = 1;\n\t   else if(ivideo->vbflags & CRT2_VGA) realcrtno = 2;\n\t   else return;\n\t}\n\n\tif((ivideo->sisfb_crt1off) && (!crtno))\n\t\treturn;\n\n\ttemp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags, ivideo->sisvga_engine,\n\t\t\t\trealcrtno, 0, &buffer[0], ivideo->vbflags2);\n\tif((!temp) || (temp == 0xffff)) {\n\t   printk(KERN_INFO \"sisfb: CRT%d DDC probing failed\\n\", crtno + 1);\n\t   return;\n\t} else {\n\t   printk(KERN_INFO \"sisfb: CRT%d DDC supported\\n\", crtno + 1);\n\t   printk(KERN_INFO \"sisfb: CRT%d DDC level: %s%s%s%s\\n\",\n\t\tcrtno + 1,\n\t\t(temp & 0x1a) ? \"\" : \"[none of the supported]\",\n\t\t(temp & 0x02) ? \"2 \" : \"\",\n\t\t(temp & 0x08) ? \"D&P\" : \"\",\n\t\t(temp & 0x10) ? \"FPDI-2\" : \"\");\n\t   if(temp & 0x02) {\n\t      i = 3;   \n\t      do {\n\t\t temp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags, ivideo->sisvga_engine,\n\t\t\t\t     realcrtno, 1, &buffer[0], ivideo->vbflags2);\n\t      } while((temp) && i--);\n\t      if(!temp) {\n\t\t if(sisfb_interpret_edid(monitor, &buffer[0])) {\n\t\t    printk(KERN_INFO \"sisfb: Monitor range H %d-%dKHz, V %d-%dHz, Max. dotclock %dMHz\\n\",\n\t\t\tmonitor->hmin, monitor->hmax, monitor->vmin, monitor->vmax,\n\t\t\tmonitor->dclockmax / 1000);\n\t\t } else {\n\t\t    printk(KERN_INFO \"sisfb: CRT%d DDC EDID corrupt\\n\", crtno + 1);\n\t\t }\n\t      } else {\n\t\t printk(KERN_INFO \"sisfb: CRT%d DDC reading failed\\n\", crtno + 1);\n\t      }\n\t   } else {\n\t      printk(KERN_INFO \"sisfb: VESA D&P and FPDI-2 not supported yet\\n\");\n\t   }\n\t}\n}\n\n \n\nstatic bool\nsisfb_verify_rate(struct sis_video_info *ivideo, struct sisfb_monitor *monitor,\n\t\tint mode_idx, int rate_idx, int rate)\n{\n\tint htotal, vtotal;\n\tunsigned int dclock, hsync;\n\n\tif(!monitor->datavalid)\n\t\treturn true;\n\n\tif(mode_idx < 0)\n\t\treturn false;\n\n\t \n\tswitch(sisbios_mode[mode_idx].mode_no[ivideo->mni]) {\n\tcase 0x59:\n\tcase 0x41:\n\tcase 0x4f:\n\tcase 0x50:\n\tcase 0x56:\n\tcase 0x53:\n\tcase 0x2f:\n\tcase 0x5d:\n\tcase 0x5e:\n\t\treturn true;\n#ifdef CONFIG_FB_SIS_315\n\tcase 0x5a:\n\tcase 0x5b:\n\t\tif(ivideo->sisvga_engine == SIS_315_VGA) return true;\n#endif\n\t}\n\n\tif(rate < (monitor->vmin - 1))\n\t\treturn false;\n\tif(rate > (monitor->vmax + 1))\n\t\treturn false;\n\n\tif(sisfb_gettotalfrommode(&ivideo->SiS_Pr,\n\t\t\t\t  sisbios_mode[mode_idx].mode_no[ivideo->mni],\n\t\t\t\t  &htotal, &vtotal, rate_idx)) {\n\t\tdclock = (htotal * vtotal * rate) / 1000;\n\t\tif(dclock > (monitor->dclockmax + 1000))\n\t\t\treturn false;\n\t\thsync = dclock / htotal;\n\t\tif(hsync < (monitor->hmin - 1))\n\t\t\treturn false;\n\t\tif(hsync > (monitor->hmax + 1))\n\t\t\treturn false;\n        } else {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int\nsisfb_validate_mode(struct sis_video_info *ivideo, int myindex, u32 vbflags)\n{\n\tu16 xres=0, yres, myres;\n\n#ifdef CONFIG_FB_SIS_300\n\tif (ivideo->sisvga_engine == SIS_300_VGA) {\n\t\tif (!(sisbios_mode[myindex].chipset & MD_SIS300))\n\t\t\treturn -1 ;\n\t}\n#endif\n#ifdef CONFIG_FB_SIS_315\n\tif (ivideo->sisvga_engine == SIS_315_VGA) {\n\t\tif (!(sisbios_mode[myindex].chipset & MD_SIS315))\n\t\t\treturn -1;\n\t}\n#endif\n\n\tmyres = sisbios_mode[myindex].yres;\n\n\tswitch (vbflags & VB_DISPTYPE_DISP2) {\n\n\tcase CRT2_LCD:\n\t\txres = ivideo->lcdxres; yres = ivideo->lcdyres;\n\n\t\tif ((ivideo->SiS_Pr.SiS_CustomT != CUT_PANEL848) &&\n\t\t    (ivideo->SiS_Pr.SiS_CustomT != CUT_PANEL856)) {\n\t\t\tif (sisbios_mode[myindex].xres > xres)\n\t\t\t\treturn -1;\n\t\t\tif (myres > yres)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (ivideo->sisfb_fstn) {\n\t\t\tif (sisbios_mode[myindex].xres == 320) {\n\t\t\t\tif (myres == 240) {\n\t\t\t\t\tswitch (sisbios_mode[myindex].mode_no[1]) {\n\t\t\t\t\t\tcase 0x50: myindex = MODE_FSTN_8;  break;\n\t\t\t\t\t\tcase 0x56: myindex = MODE_FSTN_16; break;\n\t\t\t\t\t\tcase 0x53: return -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (SiS_GetModeID_LCD(ivideo->sisvga_engine, vbflags, sisbios_mode[myindex].xres,\n\t\t\t \tsisbios_mode[myindex].yres, 0, ivideo->sisfb_fstn,\n\t\t\t \tivideo->SiS_Pr.SiS_CustomT, xres, yres, ivideo->vbflags2) < 0x14) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\n\tcase CRT2_TV:\n\t\tif (SiS_GetModeID_TV(ivideo->sisvga_engine, vbflags, sisbios_mode[myindex].xres,\n\t\t\t\tsisbios_mode[myindex].yres, 0, ivideo->vbflags2) < 0x14) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\n\tcase CRT2_VGA:\n\t\tif (SiS_GetModeID_VGA2(ivideo->sisvga_engine, vbflags, sisbios_mode[myindex].xres,\n\t\t\t\tsisbios_mode[myindex].yres, 0, ivideo->vbflags2) < 0x14) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn myindex;\n}\n\nstatic u8\nsisfb_search_refresh_rate(struct sis_video_info *ivideo, unsigned int rate, int mode_idx)\n{\n\tint i = 0;\n\tu16 xres = sisbios_mode[mode_idx].xres;\n\tu16 yres = sisbios_mode[mode_idx].yres;\n\n\tivideo->rate_idx = 0;\n\twhile((sisfb_vrate[i].idx != 0) && (sisfb_vrate[i].xres <= xres)) {\n\t\tif((sisfb_vrate[i].xres == xres) && (sisfb_vrate[i].yres == yres)) {\n\t\t\tif(sisfb_vrate[i].refresh == rate) {\n\t\t\t\tivideo->rate_idx = sisfb_vrate[i].idx;\n\t\t\t\tbreak;\n\t\t\t} else if(sisfb_vrate[i].refresh > rate) {\n\t\t\t\tif((sisfb_vrate[i].refresh - rate) <= 3) {\n\t\t\t\t\tDPRINTK(\"sisfb: Adjusting rate from %d up to %d\\n\",\n\t\t\t\t\t\trate, sisfb_vrate[i].refresh);\n\t\t\t\t\tivideo->rate_idx = sisfb_vrate[i].idx;\n\t\t\t\t\tivideo->refresh_rate = sisfb_vrate[i].refresh;\n\t\t\t\t} else if((sisfb_vrate[i].idx != 1) &&\n\t\t\t\t\t\t((rate - sisfb_vrate[i-1].refresh) <= 2)) {\n\t\t\t\t\tDPRINTK(\"sisfb: Adjusting rate from %d down to %d\\n\",\n\t\t\t\t\t\trate, sisfb_vrate[i-1].refresh);\n\t\t\t\t\tivideo->rate_idx = sisfb_vrate[i-1].idx;\n\t\t\t\t\tivideo->refresh_rate = sisfb_vrate[i-1].refresh;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if((rate - sisfb_vrate[i].refresh) <= 2) {\n\t\t\t\tDPRINTK(\"sisfb: Adjusting rate from %d down to %d\\n\",\n\t\t\t\t\t\trate, sisfb_vrate[i].refresh);\n\t\t\t\tivideo->rate_idx = sisfb_vrate[i].idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif(ivideo->rate_idx > 0) {\n\t\treturn ivideo->rate_idx;\n\t} else {\n\t\tprintk(KERN_INFO \"sisfb: Unsupported rate %d for %dx%d\\n\",\n\t\t\t\trate, xres, yres);\n\t\treturn 0;\n\t}\n}\n\nstatic bool\nsisfb_bridgeisslave(struct sis_video_info *ivideo)\n{\n\tunsigned char P1_00;\n\n\tif(!(ivideo->vbflags2 & VB2_VIDEOBRIDGE))\n\t\treturn false;\n\n\tP1_00 = SiS_GetReg(SISPART1, 0x00);\n\tif( ((ivideo->sisvga_engine == SIS_300_VGA) && (P1_00 & 0xa0) == 0x20) ||\n\t    ((ivideo->sisvga_engine == SIS_315_VGA) && (P1_00 & 0x50) == 0x10) ) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nstatic bool\nsisfballowretracecrt1(struct sis_video_info *ivideo)\n{\n\tu8 temp;\n\n\ttemp = SiS_GetReg(SISCR, 0x17);\n\tif(!(temp & 0x80))\n\t\treturn false;\n\n\ttemp = SiS_GetReg(SISSR, 0x1f);\n\tif(temp & 0xc0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nsisfbcheckvretracecrt1(struct sis_video_info *ivideo)\n{\n\tif(!sisfballowretracecrt1(ivideo))\n\t\treturn false;\n\n\tif (SiS_GetRegByte(SISINPSTAT) & 0x08)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void\nsisfbwaitretracecrt1(struct sis_video_info *ivideo)\n{\n\tint watchdog;\n\n\tif(!sisfballowretracecrt1(ivideo))\n\t\treturn;\n\n\twatchdog = 65536;\n\twhile ((!(SiS_GetRegByte(SISINPSTAT) & 0x08)) && --watchdog);\n\twatchdog = 65536;\n\twhile ((SiS_GetRegByte(SISINPSTAT) & 0x08) && --watchdog);\n}\n\nstatic bool\nsisfbcheckvretracecrt2(struct sis_video_info *ivideo)\n{\n\tunsigned char temp, reg;\n\n\tswitch(ivideo->sisvga_engine) {\n\tcase SIS_300_VGA: reg = 0x25; break;\n\tcase SIS_315_VGA: reg = 0x30; break;\n\tdefault:\t  return false;\n\t}\n\n\ttemp = SiS_GetReg(SISPART1, reg);\n\tif(temp & 0x02)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool\nsisfb_CheckVBRetrace(struct sis_video_info *ivideo)\n{\n\tif(ivideo->currentvbflags & VB_DISPTYPE_DISP2) {\n\t\tif(!sisfb_bridgeisslave(ivideo)) {\n\t\t\treturn sisfbcheckvretracecrt2(ivideo);\n\t\t}\n\t}\n\treturn sisfbcheckvretracecrt1(ivideo);\n}\n\nstatic u32\nsisfb_setupvbblankflags(struct sis_video_info *ivideo, u32 *vcount, u32 *hcount)\n{\n\tu8 idx, reg1, reg2, reg3, reg4;\n\tu32 ret = 0;\n\n\t(*vcount) = (*hcount) = 0;\n\n\tif((ivideo->currentvbflags & VB_DISPTYPE_DISP2) && (!(sisfb_bridgeisslave(ivideo)))) {\n\n\t\tret |= (FB_VBLANK_HAVE_VSYNC  |\n\t\t\tFB_VBLANK_HAVE_HBLANK |\n\t\t\tFB_VBLANK_HAVE_VBLANK |\n\t\t\tFB_VBLANK_HAVE_VCOUNT |\n\t\t\tFB_VBLANK_HAVE_HCOUNT);\n\t\tswitch(ivideo->sisvga_engine) {\n\t\t\tcase SIS_300_VGA: idx = 0x25; break;\n\t\t\tdefault:\n\t\t\tcase SIS_315_VGA: idx = 0x30; break;\n\t\t}\n\t\treg1 = SiS_GetReg(SISPART1, (idx+0));  \n\t\treg2 = SiS_GetReg(SISPART1, (idx+1));  \n\t\treg3 = SiS_GetReg(SISPART1, (idx+2));  \n\t\treg4 = SiS_GetReg(SISPART1, (idx+3));  \n\t\tif(reg1 & 0x01) ret |= FB_VBLANK_VBLANKING;\n\t\tif(reg1 & 0x02) ret |= FB_VBLANK_VSYNCING;\n\t\tif(reg4 & 0x80) ret |= FB_VBLANK_HBLANKING;\n\t\t(*vcount) = reg3 | ((reg4 & 0x70) << 4);\n\t\t(*hcount) = reg2 | ((reg4 & 0x0f) << 8);\n\n\t} else if(sisfballowretracecrt1(ivideo)) {\n\n\t\tret |= (FB_VBLANK_HAVE_VSYNC  |\n\t\t\tFB_VBLANK_HAVE_VBLANK |\n\t\t\tFB_VBLANK_HAVE_VCOUNT |\n\t\t\tFB_VBLANK_HAVE_HCOUNT);\n\t\treg1 = SiS_GetRegByte(SISINPSTAT);\n\t\tif(reg1 & 0x08) ret |= FB_VBLANK_VSYNCING;\n\t\tif(reg1 & 0x01) ret |= FB_VBLANK_VBLANKING;\n\t\treg1 = SiS_GetReg(SISCR, 0x20);\n\t\treg1 = SiS_GetReg(SISCR, 0x1b);\n\t\treg2 = SiS_GetReg(SISCR, 0x1c);\n\t\treg3 = SiS_GetReg(SISCR, 0x1d);\n\t\t(*vcount) = reg2 | ((reg3 & 0x07) << 8);\n\t\t(*hcount) = (reg1 | ((reg3 & 0x10) << 4)) << 3;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nsisfb_myblank(struct sis_video_info *ivideo, int blank)\n{\n\tu8 sr01, sr11, sr1f, cr63=0, p2_0, p1_13;\n\tbool backlight = true;\n\n\tswitch(blank) {\n\t\tcase FB_BLANK_UNBLANK:\t \n\t\t\tsr01  = 0x00;\n\t\t\tsr11  = 0x00;\n\t\t\tsr1f  = 0x00;\n\t\t\tcr63  = 0x00;\n\t\t\tp2_0  = 0x20;\n\t\t\tp1_13 = 0x00;\n\t\t\tbacklight = true;\n\t\t\tbreak;\n\t\tcase FB_BLANK_NORMAL:\t \n\t\t\tsr01  = 0x20;\n\t\t\tsr11  = 0x00;\n\t\t\tsr1f  = 0x00;\n\t\t\tcr63  = 0x00;\n\t\t\tp2_0  = 0x20;\n\t\t\tp1_13 = 0x00;\n\t\t\tbacklight = true;\n\t\t\tbreak;\n\t\tcase FB_BLANK_VSYNC_SUSPEND:\t \n\t\t\tsr01  = 0x20;\n\t\t\tsr11  = 0x08;\n\t\t\tsr1f  = 0x80;\n\t\t\tcr63  = 0x40;\n\t\t\tp2_0  = 0x40;\n\t\t\tp1_13 = 0x80;\n\t\t\tbacklight = false;\n\t\t\tbreak;\n\t\tcase FB_BLANK_HSYNC_SUSPEND:\t \n\t\t\tsr01  = 0x20;\n\t\t\tsr11  = 0x08;\n\t\t\tsr1f  = 0x40;\n\t\t\tcr63  = 0x40;\n\t\t\tp2_0  = 0x80;\n\t\t\tp1_13 = 0x40;\n\t\t\tbacklight = false;\n\t\t\tbreak;\n\t\tcase FB_BLANK_POWERDOWN:\t \n\t\t\tsr01  = 0x20;\n\t\t\tsr11  = 0x08;\n\t\t\tsr1f  = 0xc0;\n\t\t\tcr63  = 0x40;\n\t\t\tp2_0  = 0xc0;\n\t\t\tp1_13 = 0xc0;\n\t\t\tbacklight = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t}\n\n\tif(ivideo->currentvbflags & VB_DISPTYPE_CRT1) {\n\n\t\tif( (!ivideo->sisfb_thismonitor.datavalid) ||\n\t\t    ((ivideo->sisfb_thismonitor.datavalid) &&\n\t\t     (ivideo->sisfb_thismonitor.feature & 0xe0))) {\n\n\t\t\tif(ivideo->sisvga_engine == SIS_315_VGA) {\n\t\t\t\tSiS_SetRegANDOR(SISCR, ivideo->SiS_Pr.SiS_MyCR63, 0xbf, cr63);\n\t\t\t}\n\n\t\t\tif(!(sisfb_bridgeisslave(ivideo))) {\n\t\t\t\tSiS_SetRegANDOR(SISSR, 0x01, ~0x20, sr01);\n\t\t\t\tSiS_SetRegANDOR(SISSR, 0x1f, 0x3f, sr1f);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif(ivideo->currentvbflags & CRT2_LCD) {\n\n\t\tif(ivideo->vbflags2 & VB2_SISLVDSBRIDGE) {\n\t\t\tif(backlight) {\n\t\t\t\tSiS_SiS30xBLOn(&ivideo->SiS_Pr);\n\t\t\t} else {\n\t\t\t\tSiS_SiS30xBLOff(&ivideo->SiS_Pr);\n\t\t\t}\n\t\t} else if(ivideo->sisvga_engine == SIS_315_VGA) {\n#ifdef CONFIG_FB_SIS_315\n\t\t\tif(ivideo->vbflags2 & VB2_CHRONTEL) {\n\t\t\t\tif(backlight) {\n\t\t\t\t\tSiS_Chrontel701xBLOn(&ivideo->SiS_Pr);\n\t\t\t\t} else {\n\t\t\t\t\tSiS_Chrontel701xBLOff(&ivideo->SiS_Pr);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t}\n\n\t\tif(((ivideo->sisvga_engine == SIS_300_VGA) &&\n\t\t    (ivideo->vbflags2 & (VB2_301|VB2_30xBDH|VB2_LVDS))) ||\n\t\t   ((ivideo->sisvga_engine == SIS_315_VGA) &&\n\t\t    ((ivideo->vbflags2 & (VB2_LVDS | VB2_CHRONTEL)) == VB2_LVDS))) {\n\t\t\tSiS_SetRegANDOR(SISSR, 0x11, ~0x0c, sr11);\n\t\t}\n\n\t\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t\t\tif((ivideo->vbflags2 & VB2_30xB) &&\n\t\t\t   (!(ivideo->vbflags2 & VB2_30xBDH))) {\n\t\t\t\tSiS_SetRegANDOR(SISPART1, 0x13, 0x3f, p1_13);\n\t\t\t}\n\t\t} else if(ivideo->sisvga_engine == SIS_315_VGA) {\n\t\t\tif((ivideo->vbflags2 & VB2_30xB) &&\n\t\t\t   (!(ivideo->vbflags2 & VB2_30xBDH))) {\n\t\t\t\tSiS_SetRegANDOR(SISPART2, 0x00, 0x1f, p2_0);\n\t\t\t}\n\t\t}\n\n\t} else if(ivideo->currentvbflags & CRT2_VGA) {\n\n\t\tif(ivideo->vbflags2 & VB2_30xB) {\n\t\t\tSiS_SetRegANDOR(SISPART2, 0x00, 0x1f, p2_0);\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_FB_SIS_300\nunsigned int\nsisfb_read_nbridge_pci_dword(struct SiS_Private *SiS_Pr, int reg)\n{\n   struct sis_video_info *ivideo = (struct sis_video_info *)SiS_Pr->ivideo;\n   u32 val = 0;\n\n   pci_read_config_dword(ivideo->nbridge, reg, &val);\n   return (unsigned int)val;\n}\n\nvoid\nsisfb_write_nbridge_pci_dword(struct SiS_Private *SiS_Pr, int reg, unsigned int val)\n{\n   struct sis_video_info *ivideo = (struct sis_video_info *)SiS_Pr->ivideo;\n\n   pci_write_config_dword(ivideo->nbridge, reg, (u32)val);\n}\n\nunsigned int\nsisfb_read_lpc_pci_dword(struct SiS_Private *SiS_Pr, int reg)\n{\n   struct sis_video_info *ivideo = (struct sis_video_info *)SiS_Pr->ivideo;\n   u32 val = 0;\n\n   if(!ivideo->lpcdev) return 0;\n\n   pci_read_config_dword(ivideo->lpcdev, reg, &val);\n   return (unsigned int)val;\n}\n#endif\n\n#ifdef CONFIG_FB_SIS_315\nvoid\nsisfb_write_nbridge_pci_byte(struct SiS_Private *SiS_Pr, int reg, unsigned char val)\n{\n   struct sis_video_info *ivideo = (struct sis_video_info *)SiS_Pr->ivideo;\n\n   pci_write_config_byte(ivideo->nbridge, reg, (u8)val);\n}\n\nunsigned int\nsisfb_read_mio_pci_word(struct SiS_Private *SiS_Pr, int reg)\n{\n   struct sis_video_info *ivideo = (struct sis_video_info *)SiS_Pr->ivideo;\n   u16 val = 0;\n\n   if(!ivideo->lpcdev) return 0;\n\n   pci_read_config_word(ivideo->lpcdev, reg, &val);\n   return (unsigned int)val;\n}\n#endif\n\n \n\nstatic int\nsisfb_get_cmap_len(const struct fb_var_screeninfo *var)\n{\n\treturn (var->bits_per_pixel == 8) ? 256 : 16;\n}\n\nstatic void\nsisfb_set_vparms(struct sis_video_info *ivideo)\n{\n\tswitch(ivideo->video_bpp) {\n\tcase 8:\n\t\tivideo->DstColor = 0x0000;\n\t\tivideo->SiS310_AccelDepth = 0x00000000;\n\t\tivideo->video_cmap_len = 256;\n\t\tbreak;\n\tcase 16:\n\t\tivideo->DstColor = 0x8000;\n\t\tivideo->SiS310_AccelDepth = 0x00010000;\n\t\tivideo->video_cmap_len = 16;\n\t\tbreak;\n\tcase 32:\n\t\tivideo->DstColor = 0xC000;\n\t\tivideo->SiS310_AccelDepth = 0x00020000;\n\t\tivideo->video_cmap_len = 16;\n\t\tbreak;\n\tdefault:\n\t\tivideo->video_cmap_len = 16;\n\t\tprintk(KERN_ERR \"sisfb: Unsupported depth %d\", ivideo->video_bpp);\n\t\tivideo->accel = 0;\n\t}\n}\n\nstatic int\nsisfb_calc_maxyres(struct sis_video_info *ivideo, struct fb_var_screeninfo *var)\n{\n\tint maxyres = ivideo->sisfb_mem / (var->xres_virtual * (var->bits_per_pixel >> 3));\n\n\tif(maxyres > 32767) maxyres = 32767;\n\n\treturn maxyres;\n}\n\nstatic void\nsisfb_calc_pitch(struct sis_video_info *ivideo, struct fb_var_screeninfo *var)\n{\n\tivideo->video_linelength = var->xres_virtual * (var->bits_per_pixel >> 3);\n\tivideo->scrnpitchCRT1 = ivideo->video_linelength;\n\tif(!(ivideo->currentvbflags & CRT1_LCDA)) {\n\t\tif((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\n\t\t\tivideo->scrnpitchCRT1 <<= 1;\n\t\t}\n\t}\n}\n\nstatic void\nsisfb_set_pitch(struct sis_video_info *ivideo)\n{\n\tbool isslavemode = false;\n\tunsigned short HDisplay1 = ivideo->scrnpitchCRT1 >> 3;\n\tunsigned short HDisplay2 = ivideo->video_linelength >> 3;\n\n\tif(sisfb_bridgeisslave(ivideo)) isslavemode = true;\n\n\t \n\tif((ivideo->currentvbflags & VB_DISPTYPE_DISP1) || (isslavemode)) {\n\t\tSiS_SetReg(SISCR, 0x13, (HDisplay1 & 0xFF));\n\t\tSiS_SetRegANDOR(SISSR, 0x0E, 0xF0, (HDisplay1 >> 8));\n\t}\n\n\t \n\tif((ivideo->currentvbflags & VB_DISPTYPE_DISP2) && (!isslavemode)) {\n\t\tSiS_SetRegOR(SISPART1, ivideo->CRT2_write_enable, 0x01);\n\t\tSiS_SetReg(SISPART1, 0x07, (HDisplay2 & 0xFF));\n\t\tSiS_SetRegANDOR(SISPART1, 0x09, 0xF0, (HDisplay2 >> 8));\n\t}\n}\n\nstatic void\nsisfb_bpp_to_var(struct sis_video_info *ivideo, struct fb_var_screeninfo *var)\n{\n\tivideo->video_cmap_len = sisfb_get_cmap_len(var);\n\n\tswitch(var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset = var->green.offset = var->blue.offset = 0;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 16:\n\t\tvar->red.offset = 11;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 32:\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tbreak;\n\t}\n}\n\nstatic int\nsisfb_set_mode(struct sis_video_info *ivideo, int clrscrn)\n{\n\tunsigned short modeno = ivideo->mode_no;\n\n\t \n\tmodeno |= 0x80;\n\n\tSiS_SetReg(SISSR, IND_SIS_PASSWORD, SIS_PASSWORD);\n\n\tsisfb_pre_setmode(ivideo);\n\n\tif(!SiSSetMode(&ivideo->SiS_Pr, modeno)) {\n\t\tprintk(KERN_ERR \"sisfb: Setting mode[0x%x] failed\\n\", ivideo->mode_no);\n\t\treturn -EINVAL;\n\t}\n\n\tSiS_SetReg(SISSR, IND_SIS_PASSWORD, SIS_PASSWORD);\n\n\tsisfb_post_setmode(ivideo);\n\n\treturn 0;\n}\n\n\nstatic int\nsisfb_do_set_var(struct fb_var_screeninfo *var, int isactive, struct fb_info *info)\n{\n\tstruct sis_video_info *ivideo = (struct sis_video_info *)info->par;\n\tunsigned int htotal = 0, vtotal = 0;\n\tunsigned int drate = 0, hrate = 0;\n\tint found_mode = 0, ret;\n\tint old_mode;\n\tu32 pixclock;\n\n\thtotal = var->left_margin + var->xres + var->right_margin + var->hsync_len;\n\n\tvtotal = var->upper_margin + var->lower_margin + var->vsync_len;\n\n\tpixclock = var->pixclock;\n\n\tif((var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED) {\n\t\tvtotal += var->yres;\n\t\tvtotal <<= 1;\n\t} else if((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {\n\t\tvtotal += var->yres;\n\t\tvtotal <<= 2;\n\t} else if((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\n\t\tvtotal += var->yres;\n\t\tvtotal <<= 1;\n\t} else \tvtotal += var->yres;\n\n\tif(!(htotal) || !(vtotal)) {\n\t\tDPRINTK(\"sisfb: Invalid 'var' information\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif(pixclock && htotal && vtotal) {\n\t\tdrate = 1000000000 / pixclock;\n\t\thrate = (drate * 1000) / htotal;\n\t\tivideo->refresh_rate = (unsigned int) (hrate * 2 / vtotal);\n\t} else {\n\t\tivideo->refresh_rate = 60;\n\t}\n\n\told_mode = ivideo->sisfb_mode_idx;\n\tivideo->sisfb_mode_idx = 0;\n\n\twhile( (sisbios_mode[ivideo->sisfb_mode_idx].mode_no[0] != 0) &&\n\t       (sisbios_mode[ivideo->sisfb_mode_idx].xres <= var->xres) ) {\n\t\tif( (sisbios_mode[ivideo->sisfb_mode_idx].xres == var->xres) &&\n\t\t    (sisbios_mode[ivideo->sisfb_mode_idx].yres == var->yres) &&\n\t\t    (sisbios_mode[ivideo->sisfb_mode_idx].bpp == var->bits_per_pixel)) {\n\t\t\tivideo->mode_no = sisbios_mode[ivideo->sisfb_mode_idx].mode_no[ivideo->mni];\n\t\t\tfound_mode = 1;\n\t\t\tbreak;\n\t\t}\n\t\tivideo->sisfb_mode_idx++;\n\t}\n\n\tif(found_mode) {\n\t\tivideo->sisfb_mode_idx = sisfb_validate_mode(ivideo,\n\t\t\t\tivideo->sisfb_mode_idx, ivideo->currentvbflags);\n\t} else {\n\t\tivideo->sisfb_mode_idx = -1;\n\t}\n\n       \tif(ivideo->sisfb_mode_idx < 0) {\n\t\tprintk(KERN_ERR \"sisfb: Mode %dx%dx%d not supported\\n\", var->xres,\n\t\t       var->yres, var->bits_per_pixel);\n\t\tivideo->sisfb_mode_idx = old_mode;\n\t\treturn -EINVAL;\n\t}\n\n\tivideo->mode_no = sisbios_mode[ivideo->sisfb_mode_idx].mode_no[ivideo->mni];\n\n\tif(sisfb_search_refresh_rate(ivideo, ivideo->refresh_rate, ivideo->sisfb_mode_idx) == 0) {\n\t\tivideo->rate_idx = sisbios_mode[ivideo->sisfb_mode_idx].rate_idx;\n\t\tivideo->refresh_rate = 60;\n\t}\n\n\tif(isactive) {\n\t\t \n\t\tivideo->accel = 0;\n#if defined(FBINFO_HWACCEL_DISABLED) && defined(FBINFO_HWACCEL_XPAN)\n#ifdef STUPID_ACCELF_TEXT_SHIT\n\t\tif(var->accel_flags & FB_ACCELF_TEXT) {\n\t\t\tinfo->flags &= ~FBINFO_HWACCEL_DISABLED;\n\t\t} else {\n\t\t\tinfo->flags |= FBINFO_HWACCEL_DISABLED;\n\t\t}\n#endif\n\t\tif(!(info->flags & FBINFO_HWACCEL_DISABLED)) ivideo->accel = -1;\n#else\n\t\tif(var->accel_flags & FB_ACCELF_TEXT) ivideo->accel = -1;\n#endif\n\n\t\tif((ret = sisfb_set_mode(ivideo, 1))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tivideo->video_bpp    = sisbios_mode[ivideo->sisfb_mode_idx].bpp;\n\t\tivideo->video_width  = sisbios_mode[ivideo->sisfb_mode_idx].xres;\n\t\tivideo->video_height = sisbios_mode[ivideo->sisfb_mode_idx].yres;\n\n\t\tsisfb_calc_pitch(ivideo, var);\n\t\tsisfb_set_pitch(ivideo);\n\n\t\tsisfb_set_vparms(ivideo);\n\n\t\tivideo->current_width = ivideo->video_width;\n\t\tivideo->current_height = ivideo->video_height;\n\t\tivideo->current_bpp = ivideo->video_bpp;\n\t\tivideo->current_htotal = htotal;\n\t\tivideo->current_vtotal = vtotal;\n\t\tivideo->current_linelength = ivideo->video_linelength;\n\t\tivideo->current_pixclock = var->pixclock;\n\t\tivideo->current_refresh_rate = ivideo->refresh_rate;\n\t\tivideo->sisfb_lastrates[ivideo->mode_no] = ivideo->refresh_rate;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nsisfb_set_base_CRT1(struct sis_video_info *ivideo, unsigned int base)\n{\n\tSiS_SetReg(SISSR, IND_SIS_PASSWORD, SIS_PASSWORD);\n\n\tSiS_SetReg(SISCR, 0x0D, base & 0xFF);\n\tSiS_SetReg(SISCR, 0x0C, (base >> 8) & 0xFF);\n\tSiS_SetReg(SISSR, 0x0D, (base >> 16) & 0xFF);\n\tif(ivideo->sisvga_engine == SIS_315_VGA) {\n\t\tSiS_SetRegANDOR(SISSR, 0x37, 0xFE, (base >> 24) & 0x01);\n\t}\n}\n\nstatic void\nsisfb_set_base_CRT2(struct sis_video_info *ivideo, unsigned int base)\n{\n\tif(ivideo->currentvbflags & VB_DISPTYPE_DISP2) {\n\t\tSiS_SetRegOR(SISPART1, ivideo->CRT2_write_enable, 0x01);\n\t\tSiS_SetReg(SISPART1, 0x06, (base & 0xFF));\n\t\tSiS_SetReg(SISPART1, 0x05, ((base >> 8) & 0xFF));\n\t\tSiS_SetReg(SISPART1, 0x04, ((base >> 16) & 0xFF));\n\t\tif(ivideo->sisvga_engine == SIS_315_VGA) {\n\t\t\tSiS_SetRegANDOR(SISPART1, 0x02, 0x7F, ((base >> 24) & 0x01) << 7);\n\t\t}\n\t}\n}\n\nstatic int\nsisfb_pan_var(struct sis_video_info *ivideo, struct fb_info *info,\n\t      struct fb_var_screeninfo *var)\n{\n\tivideo->current_base = var->yoffset * info->var.xres_virtual\n\t\t\t     + var->xoffset;\n\n\t \n\tswitch (info->var.bits_per_pixel) {\n\tcase 32:\n\t\tbreak;\n\tcase 16:\n\t\tivideo->current_base >>= 1;\n\t\tbreak;\n\tcase 8:\n\tdefault:\n\t\tivideo->current_base >>= 2;\n\t\tbreak;\n\t}\n\n\tivideo->current_base += (ivideo->video_offset >> 2);\n\n\tsisfb_set_base_CRT1(ivideo, ivideo->current_base);\n\tsisfb_set_base_CRT2(ivideo, ivideo->current_base);\n\n\treturn 0;\n}\n\nstatic int\nsisfb_open(struct fb_info *info, int user)\n{\n\treturn 0;\n}\n\nstatic int\nsisfb_release(struct fb_info *info, int user)\n{\n\treturn 0;\n}\n\nstatic int\nsisfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue,\n\t\tunsigned transp, struct fb_info *info)\n{\n\tstruct sis_video_info *ivideo = (struct sis_video_info *)info->par;\n\n\tif(regno >= sisfb_get_cmap_len(&info->var))\n\t\treturn 1;\n\n\tswitch(info->var.bits_per_pixel) {\n\tcase 8:\n\t\tSiS_SetRegByte(SISDACA, regno);\n\t\tSiS_SetRegByte(SISDACD, (red >> 10));\n\t\tSiS_SetRegByte(SISDACD, (green >> 10));\n\t\tSiS_SetRegByte(SISDACD, (blue >> 10));\n\t\tif(ivideo->currentvbflags & VB_DISPTYPE_DISP2) {\n\t\t\tSiS_SetRegByte(SISDAC2A, regno);\n\t\t\tSiS_SetRegByte(SISDAC2D, (red >> 8));\n\t\t\tSiS_SetRegByte(SISDAC2D, (green >> 8));\n\t\t\tSiS_SetRegByte(SISDAC2D, (blue >> 8));\n\t\t}\n\t\tbreak;\n\tcase 16:\n\t\tif (regno >= 16)\n\t\t\tbreak;\n\n\t\t((u32 *)(info->pseudo_palette))[regno] =\n\t\t\t\t(red & 0xf800)          |\n\t\t\t\t((green & 0xfc00) >> 5) |\n\t\t\t\t((blue & 0xf800) >> 11);\n\t\tbreak;\n\tcase 32:\n\t\tif (regno >= 16)\n\t\t\tbreak;\n\n\t\tred >>= 8;\n\t\tgreen >>= 8;\n\t\tblue >>= 8;\n\t\t((u32 *)(info->pseudo_palette))[regno] =\n\t\t\t\t(red << 16) | (green << 8) | (blue);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int\nsisfb_set_par(struct fb_info *info)\n{\n\tint err;\n\n\tif((err = sisfb_do_set_var(&info->var, 1, info)))\n\t\treturn err;\n\n\tsisfb_get_fix(&info->fix, -1, info);\n\n\treturn 0;\n}\n\nstatic int\nsisfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct sis_video_info *ivideo = (struct sis_video_info *)info->par;\n\tunsigned int htotal = 0, vtotal = 0, myrateindex = 0;\n\tunsigned int drate = 0, hrate = 0, maxyres;\n\tint found_mode = 0;\n\tint refresh_rate, search_idx, tidx;\n\tbool recalc_clock = false;\n\tu32 pixclock;\n\n\thtotal = var->left_margin + var->xres + var->right_margin + var->hsync_len;\n\n\tvtotal = var->upper_margin + var->lower_margin + var->vsync_len;\n\n\tpixclock = var->pixclock;\n\n\tif((var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED) {\n\t\tvtotal += var->yres;\n\t\tvtotal <<= 1;\n\t} else if((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {\n\t\tvtotal += var->yres;\n\t\tvtotal <<= 2;\n\t} else if((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\n\t\tvtotal += var->yres;\n\t\tvtotal <<= 1;\n\t} else\n\t\tvtotal += var->yres;\n\n\tif(!(htotal) || !(vtotal)) {\n\t\tSISFAIL(\"sisfb: no valid timing data\");\n\t}\n\n\tsearch_idx = 0;\n\twhile( (sisbios_mode[search_idx].mode_no[0] != 0) &&\n\t       (sisbios_mode[search_idx].xres <= var->xres) ) {\n\t\tif( (sisbios_mode[search_idx].xres == var->xres) &&\n\t\t    (sisbios_mode[search_idx].yres == var->yres) &&\n\t\t    (sisbios_mode[search_idx].bpp == var->bits_per_pixel)) {\n\t\t\tif((tidx = sisfb_validate_mode(ivideo, search_idx,\n\t\t\t\t\t\tivideo->currentvbflags)) > 0) {\n\t\t\t\tfound_mode = 1;\n\t\t\t\tsearch_idx = tidx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsearch_idx++;\n\t}\n\n\tif(!found_mode) {\n\t\tsearch_idx = 0;\n\t\twhile(sisbios_mode[search_idx].mode_no[0] != 0) {\n\t\t   if( (var->xres <= sisbios_mode[search_idx].xres) &&\n\t\t       (var->yres <= sisbios_mode[search_idx].yres) &&\n\t\t       (var->bits_per_pixel == sisbios_mode[search_idx].bpp) ) {\n\t\t\tif((tidx = sisfb_validate_mode(ivideo,search_idx,\n\t\t\t\t\t\tivideo->currentvbflags)) > 0) {\n\t\t\t\tfound_mode = 1;\n\t\t\t\tsearch_idx = tidx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t   }\n\t\t   search_idx++;\n\t\t}\n\t\tif(found_mode) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"sisfb: Adapted from %dx%dx%d to %dx%dx%d\\n\",\n\t\t\t\tvar->xres, var->yres, var->bits_per_pixel,\n\t\t\t\tsisbios_mode[search_idx].xres,\n\t\t\t\tsisbios_mode[search_idx].yres,\n\t\t\t\tvar->bits_per_pixel);\n\t\t\tvar->xres = sisbios_mode[search_idx].xres;\n\t\t\tvar->yres = sisbios_mode[search_idx].yres;\n\t\t} else {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"sisfb: Failed to find supported mode near %dx%dx%d\\n\",\n\t\t\t\tvar->xres, var->yres, var->bits_per_pixel);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif( ((ivideo->vbflags2 & VB2_LVDS) ||\n\t     ((ivideo->vbflags2 & VB2_30xBDH) && (ivideo->currentvbflags & CRT2_LCD))) &&\n\t    (var->bits_per_pixel == 8) ) {\n\t\t \n\t\trefresh_rate = 60;\n\t\trecalc_clock = true;\n\t} else if( (ivideo->current_htotal == htotal) &&\n\t\t   (ivideo->current_vtotal == vtotal) &&\n\t\t   (ivideo->current_pixclock == pixclock) ) {\n\t\t \n\t\tdrate = 1000000000 / pixclock;\n\t\thrate = (drate * 1000) / htotal;\n\t\trefresh_rate = (unsigned int) (hrate * 2 / vtotal);\n\t} else if( ( (ivideo->current_htotal != htotal) ||\n\t\t     (ivideo->current_vtotal != vtotal) ) &&\n\t\t   (ivideo->current_pixclock == var->pixclock) ) {\n\t\t \n\t\tif(ivideo->sisfb_lastrates[sisbios_mode[search_idx].mode_no[ivideo->mni]]) {\n\t\t\trefresh_rate =\n\t\t\t\tivideo->sisfb_lastrates[sisbios_mode[search_idx].mode_no[ivideo->mni]];\n\t\t} else if(ivideo->sisfb_parm_rate != -1) {\n\t\t\t \n\t\t\trefresh_rate = ivideo->sisfb_parm_rate;\n\t\t} else {\n\t\t\trefresh_rate = 60;\n\t\t}\n\t\trecalc_clock = true;\n\t} else if((pixclock) && (htotal) && (vtotal)) {\n\t\tdrate = 1000000000 / pixclock;\n\t\thrate = (drate * 1000) / htotal;\n\t\trefresh_rate = (unsigned int) (hrate * 2 / vtotal);\n\t} else if(ivideo->current_refresh_rate) {\n\t\trefresh_rate = ivideo->current_refresh_rate;\n\t\trecalc_clock = true;\n\t} else {\n\t\trefresh_rate = 60;\n\t\trecalc_clock = true;\n\t}\n\n\tmyrateindex = sisfb_search_refresh_rate(ivideo, refresh_rate, search_idx);\n\n\t \n\tif(recalc_clock) {\n\t\tif(!myrateindex) myrateindex = sisbios_mode[search_idx].rate_idx;\n\t\tvar->pixclock = (u32) (1000000000 / sisfb_mode_rate_to_dclock(&ivideo->SiS_Pr,\n\t\t\t\t\t\tsisbios_mode[search_idx].mode_no[ivideo->mni],\n\t\t\t\t\t\tmyrateindex));\n\t\tsisfb_mode_rate_to_ddata(&ivideo->SiS_Pr,\n\t\t\t\t\tsisbios_mode[search_idx].mode_no[ivideo->mni],\n\t\t\t\t\tmyrateindex, var);\n\t\tif((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {\n\t\t\tvar->pixclock <<= 1;\n\t\t}\n\t}\n\n\tif(ivideo->sisfb_thismonitor.datavalid) {\n\t\tif(!sisfb_verify_rate(ivideo, &ivideo->sisfb_thismonitor, search_idx,\n\t\t\t\tmyrateindex, refresh_rate)) {\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: WARNING: Refresh rate exceeds monitor specs!\\n\");\n\t\t}\n\t}\n\n\t \n\tsisfb_bpp_to_var(ivideo, var);\n\n\tif(var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\n\tif(ivideo->sisfb_ypan) {\n\t\tmaxyres = sisfb_calc_maxyres(ivideo, var);\n\t\tif(ivideo->sisfb_max) {\n\t\t\tvar->yres_virtual = maxyres;\n\t\t} else {\n\t\t\tif(var->yres_virtual > maxyres) {\n\t\t\t\tvar->yres_virtual = maxyres;\n\t\t\t}\n\t\t}\n\t\tif(var->yres_virtual <= var->yres) {\n\t\t\tvar->yres_virtual = var->yres;\n\t\t}\n\t} else {\n\t\tif(var->yres != var->yres_virtual) {\n\t\t\tvar->yres_virtual = var->yres;\n\t\t}\n\t\tvar->xoffset = 0;\n\t\tvar->yoffset = 0;\n\t}\n\n\t \n\tif(var->xoffset > var->xres_virtual - var->xres) {\n\t\tvar->xoffset = var->xres_virtual - var->xres - 1;\n\t}\n\n\tif(var->yoffset > var->yres_virtual - var->yres) {\n\t\tvar->yoffset = var->yres_virtual - var->yres - 1;\n\t}\n\n\t \n\tvar->red.msb_right =\n\t\tvar->green.msb_right =\n\t\tvar->blue.msb_right =\n\t\tvar->transp.offset =\n\t\tvar->transp.length =\n\t\tvar->transp.msb_right = 0;\n\n\treturn 0;\n}\n\nstatic int\nsisfb_pan_display(struct fb_var_screeninfo *var, struct fb_info* info)\n{\n\tstruct sis_video_info *ivideo = (struct sis_video_info *)info->par;\n\tint err;\n\n\tif (var->vmode & FB_VMODE_YWRAP)\n\t\treturn -EINVAL;\n\n\tif (var->xoffset + info->var.xres > info->var.xres_virtual ||\n\t    var->yoffset + info->var.yres > info->var.yres_virtual)\n\t\treturn -EINVAL;\n\n\terr = sisfb_pan_var(ivideo, info, var);\n\tif (err < 0)\n\t\treturn err;\n\n\tinfo->var.xoffset = var->xoffset;\n\tinfo->var.yoffset = var->yoffset;\n\n\treturn 0;\n}\n\nstatic int\nsisfb_blank(int blank, struct fb_info *info)\n{\n\tstruct sis_video_info *ivideo = (struct sis_video_info *)info->par;\n\n\treturn sisfb_myblank(ivideo, blank);\n}\n\n \n\nstatic int\tsisfb_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct sis_video_info\t*ivideo = (struct sis_video_info *)info->par;\n\tstruct sis_memreq\tsismemreq;\n\tstruct fb_vblank\tsisvbblank;\n\tu32\t\t\tgpu32 = 0;\n#ifndef __user\n#define __user\n#endif\n\tu32 __user \t\t*argp = (u32 __user *)arg;\n\n\tswitch(cmd) {\n\t   case FBIO_ALLOC:\n\t\tif(!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\n\t\tif(copy_from_user(&sismemreq, (void __user *)arg, sizeof(sismemreq)))\n\t\t\treturn -EFAULT;\n\n\t\tsis_malloc(&sismemreq);\n\n\t\tif(copy_to_user((void __user *)arg, &sismemreq, sizeof(sismemreq))) {\n\t\t\tsis_free((u32)sismemreq.offset);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tbreak;\n\n\t   case FBIO_FREE:\n\t\tif(!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\n\t\tif(get_user(gpu32, argp))\n\t\t\treturn -EFAULT;\n\n\t\tsis_free(gpu32);\n\t\tbreak;\n\n\t   case FBIOGET_VBLANK:\n\n\t\tmemset(&sisvbblank, 0, sizeof(struct fb_vblank));\n\n\t\tsisvbblank.count = 0;\n\t\tsisvbblank.flags = sisfb_setupvbblankflags(ivideo, &sisvbblank.vcount, &sisvbblank.hcount);\n\n\t\tif(copy_to_user((void __user *)arg, &sisvbblank, sizeof(sisvbblank)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\t   case SISFB_GET_INFO_SIZE:\n\t\treturn put_user(sizeof(struct sisfb_info), argp);\n\n\t   case SISFB_GET_INFO_OLD:\n\t\tif(ivideo->warncount++ < 10)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: Deprecated ioctl call received - update your application!\\n\");\n\t\tfallthrough;\n\t   case SISFB_GET_INFO:   \n\t\tivideo->sisfb_infoblock.sisfb_id         = SISFB_ID;\n\t\tivideo->sisfb_infoblock.sisfb_version    = VER_MAJOR;\n\t\tivideo->sisfb_infoblock.sisfb_revision   = VER_MINOR;\n\t\tivideo->sisfb_infoblock.sisfb_patchlevel = VER_LEVEL;\n\t\tivideo->sisfb_infoblock.chip_id = ivideo->chip_id;\n\t\tivideo->sisfb_infoblock.sisfb_pci_vendor = ivideo->chip_vendor;\n\t\tivideo->sisfb_infoblock.memory = ivideo->video_size / 1024;\n\t\tivideo->sisfb_infoblock.heapstart = ivideo->heapstart / 1024;\n\t\tif(ivideo->modechanged) {\n\t\t\tivideo->sisfb_infoblock.fbvidmode = ivideo->mode_no;\n\t\t} else {\n\t\t\tivideo->sisfb_infoblock.fbvidmode = ivideo->modeprechange;\n\t\t}\n\t\tivideo->sisfb_infoblock.sisfb_caps = ivideo->caps;\n\t\tivideo->sisfb_infoblock.sisfb_tqlen = ivideo->cmdQueueSize / 1024;\n\t\tivideo->sisfb_infoblock.sisfb_pcibus = ivideo->pcibus;\n\t\tivideo->sisfb_infoblock.sisfb_pcislot = ivideo->pcislot;\n\t\tivideo->sisfb_infoblock.sisfb_pcifunc = ivideo->pcifunc;\n\t\tivideo->sisfb_infoblock.sisfb_lcdpdc = ivideo->detectedpdc;\n\t\tivideo->sisfb_infoblock.sisfb_lcdpdca = ivideo->detectedpdca;\n\t\tivideo->sisfb_infoblock.sisfb_lcda = ivideo->detectedlcda;\n\t\tivideo->sisfb_infoblock.sisfb_vbflags = ivideo->vbflags;\n\t\tivideo->sisfb_infoblock.sisfb_currentvbflags = ivideo->currentvbflags;\n\t\tivideo->sisfb_infoblock.sisfb_scalelcd = ivideo->SiS_Pr.UsePanelScaler;\n\t\tivideo->sisfb_infoblock.sisfb_specialtiming = ivideo->SiS_Pr.SiS_CustomT;\n\t\tivideo->sisfb_infoblock.sisfb_haveemi = ivideo->SiS_Pr.HaveEMI ? 1 : 0;\n\t\tivideo->sisfb_infoblock.sisfb_haveemilcd = ivideo->SiS_Pr.HaveEMILCD ? 1 : 0;\n\t\tivideo->sisfb_infoblock.sisfb_emi30 = ivideo->SiS_Pr.EMI_30;\n\t\tivideo->sisfb_infoblock.sisfb_emi31 = ivideo->SiS_Pr.EMI_31;\n\t\tivideo->sisfb_infoblock.sisfb_emi32 = ivideo->SiS_Pr.EMI_32;\n\t\tivideo->sisfb_infoblock.sisfb_emi33 = ivideo->SiS_Pr.EMI_33;\n\t\tivideo->sisfb_infoblock.sisfb_tvxpos = (u16)(ivideo->tvxpos + 32);\n\t\tivideo->sisfb_infoblock.sisfb_tvypos = (u16)(ivideo->tvypos + 32);\n\t\tivideo->sisfb_infoblock.sisfb_heapsize = ivideo->sisfb_heap_size / 1024;\n\t\tivideo->sisfb_infoblock.sisfb_videooffset = ivideo->video_offset;\n\t\tivideo->sisfb_infoblock.sisfb_curfstn = ivideo->curFSTN;\n\t\tivideo->sisfb_infoblock.sisfb_curdstn = ivideo->curDSTN;\n\t\tivideo->sisfb_infoblock.sisfb_vbflags2 = ivideo->vbflags2;\n\t\tivideo->sisfb_infoblock.sisfb_can_post = ivideo->sisfb_can_post ? 1 : 0;\n\t\tivideo->sisfb_infoblock.sisfb_card_posted = ivideo->sisfb_card_posted ? 1 : 0;\n\t\tivideo->sisfb_infoblock.sisfb_was_boot_device = ivideo->sisfb_was_boot_device ? 1 : 0;\n\n\t\tif(copy_to_user((void __user *)arg, &ivideo->sisfb_infoblock,\n\t\t\t\t\t\tsizeof(ivideo->sisfb_infoblock)))\n\t\t\treturn -EFAULT;\n\n\t        break;\n\n\t   case SISFB_GET_VBRSTATUS_OLD:\n\t\tif(ivideo->warncount++ < 10)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: Deprecated ioctl call received - update your application!\\n\");\n\t\tfallthrough;\n\t   case SISFB_GET_VBRSTATUS:\n\t\tif(sisfb_CheckVBRetrace(ivideo))\n\t\t\treturn put_user((u32)1, argp);\n\t\telse\n\t\t\treturn put_user((u32)0, argp);\n\n\t   case SISFB_GET_AUTOMAXIMIZE_OLD:\n\t\tif(ivideo->warncount++ < 10)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: Deprecated ioctl call received - update your application!\\n\");\n\t\tfallthrough;\n\t   case SISFB_GET_AUTOMAXIMIZE:\n\t\tif(ivideo->sisfb_max)\n\t\t\treturn put_user((u32)1, argp);\n\t\telse\n\t\t\treturn put_user((u32)0, argp);\n\n\t   case SISFB_SET_AUTOMAXIMIZE_OLD:\n\t\tif(ivideo->warncount++ < 10)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: Deprecated ioctl call received - update your application!\\n\");\n\t\tfallthrough;\n\t   case SISFB_SET_AUTOMAXIMIZE:\n\t\tif(get_user(gpu32, argp))\n\t\t\treturn -EFAULT;\n\n\t\tivideo->sisfb_max = (gpu32) ? 1 : 0;\n\t\tbreak;\n\n\t   case SISFB_SET_TVPOSOFFSET:\n\t\tif(get_user(gpu32, argp))\n\t\t\treturn -EFAULT;\n\n\t\tsisfb_set_TVxposoffset(ivideo, ((int)(gpu32 >> 16)) - 32);\n\t\tsisfb_set_TVyposoffset(ivideo, ((int)(gpu32 & 0xffff)) - 32);\n\t\tbreak;\n\n\t   case SISFB_GET_TVPOSOFFSET:\n\t\treturn put_user((u32)(((ivideo->tvxpos+32)<<16)|((ivideo->tvypos+32)&0xffff)),\n\t\t\t\t\t\t\targp);\n\n\t   case SISFB_COMMAND:\n\t\tif(copy_from_user(&ivideo->sisfb_command, (void __user *)arg,\n\t\t\t\t\t\t\tsizeof(struct sisfb_cmd)))\n\t\t\treturn -EFAULT;\n\n\t\tsisfb_handle_command(ivideo, &ivideo->sisfb_command);\n\n\t\tif(copy_to_user((void __user *)arg, &ivideo->sisfb_command,\n\t\t\t\t\t\t\tsizeof(struct sisfb_cmd)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\t   case SISFB_SET_LOCK:\n\t\tif(get_user(gpu32, argp))\n\t\t\treturn -EFAULT;\n\n\t\tivideo->sisfblocked = (gpu32) ? 1 : 0;\n\t\tbreak;\n\n\t   default:\n#ifdef SIS_NEW_CONFIG_COMPAT\n\t\treturn -ENOIOCTLCMD;\n#else\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}\n\nstatic int\nsisfb_get_fix(struct fb_fix_screeninfo *fix, int con, struct fb_info *info)\n{\n\tstruct sis_video_info *ivideo = (struct sis_video_info *)info->par;\n\n\tmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\n\n\tstrscpy(fix->id, ivideo->myid, sizeof(fix->id));\n\n\tmutex_lock(&info->mm_lock);\n\tfix->smem_start  = ivideo->video_base + ivideo->video_offset;\n\tfix->smem_len    = ivideo->sisfb_mem;\n\tmutex_unlock(&info->mm_lock);\n\tfix->type        = FB_TYPE_PACKED_PIXELS;\n\tfix->type_aux    = 0;\n\tfix->visual      = (ivideo->video_bpp == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\tfix->xpanstep    = 1;\n\tfix->ypanstep \t = (ivideo->sisfb_ypan) ? 1 : 0;\n\tfix->ywrapstep   = 0;\n\tfix->line_length = ivideo->video_linelength;\n\tfix->mmio_start  = ivideo->mmio_base;\n\tfix->mmio_len    = ivideo->mmio_size;\n\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t\tfix->accel = FB_ACCEL_SIS_GLAMOUR;\n\t} else if((ivideo->chip == SIS_330) ||\n\t\t  (ivideo->chip == SIS_760) ||\n\t\t  (ivideo->chip == SIS_761)) {\n\t\tfix->accel = FB_ACCEL_SIS_XABRE;\n\t} else if(ivideo->chip == XGI_20) {\n\t\tfix->accel = FB_ACCEL_XGI_VOLARI_Z;\n\t} else if(ivideo->chip >= XGI_40) {\n\t\tfix->accel = FB_ACCEL_XGI_VOLARI_V;\n\t} else {\n\t\tfix->accel = FB_ACCEL_SIS_GLAMOUR_2;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct fb_ops sisfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= sisfb_open,\n\t.fb_release\t= sisfb_release,\n\t.fb_check_var\t= sisfb_check_var,\n\t.fb_set_par\t= sisfb_set_par,\n\t.fb_setcolreg\t= sisfb_setcolreg,\n\t.fb_pan_display\t= sisfb_pan_display,\n\t.fb_blank\t= sisfb_blank,\n\t.fb_fillrect\t= fbcon_sis_fillrect,\n\t.fb_copyarea\t= fbcon_sis_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n\t.fb_sync\t= fbcon_sis_sync,\n#ifdef SIS_NEW_CONFIG_COMPAT\n\t.fb_compat_ioctl= sisfb_ioctl,\n#endif\n\t.fb_ioctl\t= sisfb_ioctl\n};\n\n \n\nstatic struct pci_dev *sisfb_get_northbridge(int basechipid)\n{\n\tstruct pci_dev *pdev = NULL;\n\tint nbridgenum, nbridgeidx, i;\n\tstatic const unsigned short nbridgeids[] = {\n\t\tPCI_DEVICE_ID_SI_540,\t \n\t\tPCI_DEVICE_ID_SI_630,\t \n\t\tPCI_DEVICE_ID_SI_730,\n\t\tPCI_DEVICE_ID_SI_550,    \n\t\tPCI_DEVICE_ID_SI_650,    \n\t\tPCI_DEVICE_ID_SI_651,\n\t\tPCI_DEVICE_ID_SI_740,\n\t\tPCI_DEVICE_ID_SI_661,\t \n\t\tPCI_DEVICE_ID_SI_741,\n\t\tPCI_DEVICE_ID_SI_660,\n\t\tPCI_DEVICE_ID_SI_760,\n\t\tPCI_DEVICE_ID_SI_761\n\t};\n\n\tswitch(basechipid) {\n#ifdef CONFIG_FB_SIS_300\n\tcase SIS_540:\tnbridgeidx = 0; nbridgenum = 1; break;\n\tcase SIS_630:\tnbridgeidx = 1; nbridgenum = 2; break;\n#endif\n#ifdef CONFIG_FB_SIS_315\n\tcase SIS_550:   nbridgeidx = 3; nbridgenum = 1; break;\n\tcase SIS_650:\tnbridgeidx = 4; nbridgenum = 3; break;\n\tcase SIS_660:\tnbridgeidx = 7; nbridgenum = 5; break;\n#endif\n\tdefault:\treturn NULL;\n\t}\n\tfor(i = 0; i < nbridgenum; i++) {\n\t\tif((pdev = pci_get_device(PCI_VENDOR_ID_SI,\n\t\t\t\tnbridgeids[nbridgeidx+i], NULL)))\n\t\t\tbreak;\n\t}\n\treturn pdev;\n}\n\nstatic int sisfb_get_dram_size(struct sis_video_info *ivideo)\n{\n#if defined(CONFIG_FB_SIS_300) || defined(CONFIG_FB_SIS_315)\n\tu8 reg;\n#endif\n\n\tivideo->video_size = 0;\n\tivideo->UMAsize = ivideo->LFBsize = 0;\n\n\tswitch(ivideo->chip) {\n#ifdef CONFIG_FB_SIS_300\n\tcase SIS_300:\n\t\treg = SiS_GetReg(SISSR, 0x14);\n\t\tivideo->video_size = ((reg & 0x3F) + 1) << 20;\n\t\tbreak;\n\tcase SIS_540:\n\tcase SIS_630:\n\tcase SIS_730:\n\t\tif(!ivideo->nbridge)\n\t\t\treturn -1;\n\t\tpci_read_config_byte(ivideo->nbridge, 0x63, &reg);\n\t\tivideo->video_size = 1 << (((reg & 0x70) >> 4) + 21);\n\t\tbreak;\n#endif\n#ifdef CONFIG_FB_SIS_315\n\tcase SIS_315H:\n\tcase SIS_315PRO:\n\tcase SIS_315:\n\t\treg = SiS_GetReg(SISSR, 0x14);\n\t\tivideo->video_size = (1 << ((reg & 0xf0) >> 4)) << 20;\n\t\tswitch((reg >> 2) & 0x03) {\n\t\tcase 0x01:\n\t\tcase 0x03:\n\t\t\tivideo->video_size <<= 1;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tivideo->video_size += (ivideo->video_size/2);\n\t\t}\n\t\tbreak;\n\tcase SIS_330:\n\t\treg = SiS_GetReg(SISSR, 0x14);\n\t\tivideo->video_size = (1 << ((reg & 0xf0) >> 4)) << 20;\n\t\tif(reg & 0x0c) ivideo->video_size <<= 1;\n\t\tbreak;\n\tcase SIS_550:\n\tcase SIS_650:\n\tcase SIS_740:\n\t\treg = SiS_GetReg(SISSR, 0x14);\n\t\tivideo->video_size = (((reg & 0x3f) + 1) << 2) << 20;\n\t\tbreak;\n\tcase SIS_661:\n\tcase SIS_741:\n\t\treg = SiS_GetReg(SISCR, 0x79);\n\t\tivideo->video_size = (1 << ((reg & 0xf0) >> 4)) << 20;\n\t\tbreak;\n\tcase SIS_660:\n\tcase SIS_760:\n\tcase SIS_761:\n\t\treg = SiS_GetReg(SISCR, 0x79);\n\t\treg = (reg & 0xf0) >> 4;\n\t\tif(reg)\t{\n\t\t\tivideo->video_size = (1 << reg) << 20;\n\t\t\tivideo->UMAsize = ivideo->video_size;\n\t\t}\n\t\treg = SiS_GetReg(SISCR, 0x78);\n\t\treg &= 0x30;\n\t\tif(reg) {\n\t\t\tif(reg == 0x10) {\n\t\t\t\tivideo->LFBsize = (32 << 20);\n\t\t\t} else {\n\t\t\t\tivideo->LFBsize = (64 << 20);\n\t\t\t}\n\t\t\tivideo->video_size += ivideo->LFBsize;\n\t\t}\n\t\tbreak;\n\tcase SIS_340:\n\tcase XGI_20:\n\tcase XGI_40:\n\t\treg = SiS_GetReg(SISSR, 0x14);\n\t\tivideo->video_size = (1 << ((reg & 0xf0) >> 4)) << 20;\n\t\tif(ivideo->chip != XGI_20) {\n\t\t\treg = (reg & 0x0c) >> 2;\n\t\t\tif(ivideo->revision_id == 2) {\n\t\t\t\tif(reg & 0x01) reg = 0x02;\n\t\t\t\telse\t       reg = 0x00;\n\t\t\t}\n\t\t\tif(reg == 0x02)\t\tivideo->video_size <<= 1;\n\t\t\telse if(reg == 0x03)\tivideo->video_size <<= 2;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \n\nstatic void sisfb_detect_VB_connect(struct sis_video_info *ivideo)\n{\n\tu8 cr32, temp;\n\n\t \n\tif(ivideo->chip == XGI_20) {\n\t\tivideo->sisfb_crt1off = 0;\n\t\treturn;\n\t}\n\n#ifdef CONFIG_FB_SIS_300\n\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t\ttemp = SiS_GetReg(SISSR, 0x17);\n\t\tif((temp & 0x0F) && (ivideo->chip != SIS_300)) {\n\t\t\t \n\t\t\tif(!(ivideo->vbflags & (TV_PAL | TV_NTSC | TV_PALM | TV_PALN))) {\n\t\t\t\ttemp = SiS_GetReg(SISSR, 0x16);\n\t\t\t\tif(temp & 0x20)\n\t\t\t\t\tivideo->vbflags |= TV_PAL;\n\t\t\t\telse\n\t\t\t\t\tivideo->vbflags |= TV_NTSC;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tcr32 = SiS_GetReg(SISCR, 0x32);\n\n\tif(cr32 & SIS_CRT1) {\n\t\tivideo->sisfb_crt1off = 0;\n\t} else {\n\t\tivideo->sisfb_crt1off = (cr32 & 0xDF) ? 1 : 0;\n\t}\n\n\tivideo->vbflags &= ~(CRT2_TV | CRT2_LCD | CRT2_VGA);\n\n\tif(cr32 & SIS_VB_TV)   ivideo->vbflags |= CRT2_TV;\n\tif(cr32 & SIS_VB_LCD)  ivideo->vbflags |= CRT2_LCD;\n\tif(cr32 & SIS_VB_CRT2) ivideo->vbflags |= CRT2_VGA;\n\n\t \n\n\tif(ivideo->chip != SIS_550) {\n\t   ivideo->sisfb_dstn = ivideo->sisfb_fstn = 0;\n\t}\n\n\tif(ivideo->sisfb_tvplug != -1) {\n\t   if( (ivideo->sisvga_engine != SIS_315_VGA) ||\n\t       (!(ivideo->vbflags2 & VB2_SISYPBPRBRIDGE)) ) {\n\t      if(ivideo->sisfb_tvplug & TV_YPBPR) {\n\t\t ivideo->sisfb_tvplug = -1;\n\t\t printk(KERN_ERR \"sisfb: YPbPr not supported\\n\");\n\t      }\n\t   }\n\t}\n\tif(ivideo->sisfb_tvplug != -1) {\n\t   if( (ivideo->sisvga_engine != SIS_315_VGA) ||\n\t       (!(ivideo->vbflags2 & VB2_SISHIVISIONBRIDGE)) ) {\n\t      if(ivideo->sisfb_tvplug & TV_HIVISION) {\n\t\t ivideo->sisfb_tvplug = -1;\n\t\t printk(KERN_ERR \"sisfb: HiVision not supported\\n\");\n\t      }\n\t   }\n\t}\n\tif(ivideo->sisfb_tvstd != -1) {\n\t   if( (!(ivideo->vbflags2 & VB2_SISBRIDGE)) &&\n\t       (!((ivideo->sisvga_engine == SIS_315_VGA) &&\n\t\t\t(ivideo->vbflags2 & VB2_CHRONTEL))) ) {\n\t      if(ivideo->sisfb_tvstd & (TV_PALM | TV_PALN | TV_NTSCJ)) {\n\t\t ivideo->sisfb_tvstd = -1;\n\t\t printk(KERN_ERR \"sisfb: PALM/PALN/NTSCJ not supported\\n\");\n\t      }\n\t   }\n\t}\n\n\t \n\tif(ivideo->sisfb_tvplug != -1) {\n\t\tivideo->vbflags |= ivideo->sisfb_tvplug;\n\t} else {\n\t\tif(cr32 & SIS_VB_YPBPR)     \t ivideo->vbflags |= (TV_YPBPR|TV_YPBPR525I);  \n\t\telse if(cr32 & SIS_VB_HIVISION)  ivideo->vbflags |= TV_HIVISION;\n\t\telse if(cr32 & SIS_VB_SCART)     ivideo->vbflags |= TV_SCART;\n\t\telse {\n\t\t\tif(cr32 & SIS_VB_SVIDEO)    ivideo->vbflags |= TV_SVIDEO;\n\t\t\tif(cr32 & SIS_VB_COMPOSITE) ivideo->vbflags |= TV_AVIDEO;\n\t\t}\n\t}\n\n\tif(!(ivideo->vbflags & (TV_YPBPR | TV_HIVISION))) {\n\t    if(ivideo->sisfb_tvstd != -1) {\n\t       ivideo->vbflags &= ~(TV_NTSC | TV_PAL | TV_PALM | TV_PALN | TV_NTSCJ);\n\t       ivideo->vbflags |= ivideo->sisfb_tvstd;\n\t    }\n\t    if(ivideo->vbflags & TV_SCART) {\n\t       ivideo->vbflags &= ~(TV_NTSC | TV_PALM | TV_PALN | TV_NTSCJ);\n\t       ivideo->vbflags |= TV_PAL;\n\t    }\n\t    if(!(ivideo->vbflags & (TV_PAL | TV_NTSC | TV_PALM | TV_PALN | TV_NTSCJ))) {\n\t\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t\t\ttemp = SiS_GetReg(SISSR, 0x38);\n\t\t\tif(temp & 0x01) ivideo->vbflags |= TV_PAL;\n\t\t\telse\t\tivideo->vbflags |= TV_NTSC;\n\t\t} else if((ivideo->chip <= SIS_315PRO) || (ivideo->chip >= SIS_330)) {\n\t\t\ttemp = SiS_GetReg(SISSR, 0x38);\n\t\t\tif(temp & 0x01) ivideo->vbflags |= TV_PAL;\n\t\t\telse\t\tivideo->vbflags |= TV_NTSC;\n\t\t} else {\n\t\t\ttemp = SiS_GetReg(SISCR, 0x79);\n\t\t\tif(temp & 0x20)\tivideo->vbflags |= TV_PAL;\n\t\t\telse\t\tivideo->vbflags |= TV_NTSC;\n\t\t}\n\t    }\n\t}\n\n\t \n\tif(ivideo->sisfb_forcecrt1 != -1) {\n\t   ivideo->sisfb_crt1off = (ivideo->sisfb_forcecrt1) ? 0 : 1;\n\t}\n}\n\n \n\nstatic bool sisfb_test_DDC1(struct sis_video_info *ivideo)\n{\n    unsigned short old;\n    int count = 48;\n\n    old = SiS_ReadDDC1Bit(&ivideo->SiS_Pr);\n    do {\n\tif(old != SiS_ReadDDC1Bit(&ivideo->SiS_Pr)) break;\n    } while(count--);\n    return (count != -1);\n}\n\nstatic void sisfb_sense_crt1(struct sis_video_info *ivideo)\n{\n\tbool mustwait = false;\n\tu8  sr1F, cr17;\n#ifdef CONFIG_FB_SIS_315\n\tu8  cr63 = 0;\n#endif\n\tu16 temp = 0xffff;\n\tint i;\n\n\tsr1F = SiS_GetReg(SISSR, 0x1F);\n\tSiS_SetRegOR(SISSR, 0x1F, 0x04);\n\tSiS_SetRegAND(SISSR, 0x1F, 0x3F);\n\n\tif (sr1F & 0xc0)\n\t\tmustwait = true;\n\n#ifdef CONFIG_FB_SIS_315\n\tif (ivideo->sisvga_engine == SIS_315_VGA) {\n\t\tcr63 = SiS_GetReg(SISCR, ivideo->SiS_Pr.SiS_MyCR63);\n\t\tcr63 &= 0x40;\n\t\tSiS_SetRegAND(SISCR, ivideo->SiS_Pr.SiS_MyCR63, 0xBF);\n\t}\n#endif\n\n\tcr17 = SiS_GetReg(SISCR, 0x17);\n\tcr17 &= 0x80;\n\n\tif (!cr17) {\n\t\tSiS_SetRegOR(SISCR, 0x17, 0x80);\n\t\tmustwait = true;\n\t\tSiS_SetReg(SISSR, 0x00, 0x01);\n\t\tSiS_SetReg(SISSR, 0x00, 0x03);\n\t}\n\n\tif (mustwait) {\n\t\tfor (i = 0; i < 10; i++)\n\t\t\tsisfbwaitretracecrt1(ivideo);\n\t}\n#ifdef CONFIG_FB_SIS_315\n\tif (ivideo->chip >= SIS_330) {\n\t\tSiS_SetRegAND(SISCR, 0x32, ~0x20);\n\t\tif (ivideo->chip >= SIS_340)\n\t\t\tSiS_SetReg(SISCR, 0x57, 0x4a);\n\t\telse\n\t\t\tSiS_SetReg(SISCR, 0x57, 0x5f);\n\n\t\tSiS_SetRegOR(SISCR, 0x53, 0x02);\n\t\twhile ((SiS_GetRegByte(SISINPSTAT)) & 0x01)\n\t\t\tbreak;\n\t\twhile (!((SiS_GetRegByte(SISINPSTAT)) & 0x01))\n\t\t\tbreak;\n\t\tif ((SiS_GetRegByte(SISMISCW)) & 0x10)\n\t\t\ttemp = 1;\n\n\t\tSiS_SetRegAND(SISCR, 0x53, 0xfd);\n\t\tSiS_SetRegAND(SISCR, 0x57, 0x00);\n\t}\n#endif\n\n\tif (temp == 0xffff) {\n\t\ti = 3;\n\n\t\tdo {\n\t\t\ttemp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags,\n\t\t\tivideo->sisvga_engine, 0, 0, NULL, ivideo->vbflags2);\n\t\t} while (((temp == 0) || (temp == 0xffff)) && i--);\n\n\t\tif ((temp == 0) || (temp == 0xffff)) {\n\t\t\tif (sisfb_test_DDC1(ivideo))\n\t\t\t\ttemp = 1;\n\t\t}\n\t}\n\n\tif ((temp) && (temp != 0xffff))\n\t\tSiS_SetRegOR(SISCR, 0x32, 0x20);\n\n#ifdef CONFIG_FB_SIS_315\n\tif (ivideo->sisvga_engine == SIS_315_VGA)\n\t\tSiS_SetRegANDOR(SISCR, ivideo->SiS_Pr.SiS_MyCR63, 0xBF, cr63);\n#endif\n\n\tSiS_SetRegANDOR(SISCR, 0x17, 0x7F, cr17);\n\tSiS_SetReg(SISSR, 0x1F, sr1F);\n}\n\n \nstatic void SiS_SenseLCD(struct sis_video_info *ivideo)\n{\n\tunsigned char buffer[256];\n\tunsigned short temp, realcrtno, i;\n\tu8 reg, cr37 = 0, paneltype = 0;\n\tu16 xres, yres;\n\n\tivideo->SiS_Pr.PanelSelfDetected = false;\n\n\t \n\tif (!(ivideo->vbflags2 & VB2_SISTMDSBRIDGE))\n\t\treturn;\n\tif (ivideo->vbflags2 & VB2_30xBDH)\n\t\treturn;\n\n\t \n\treg = SiS_GetReg(SISCR, 0x32);\n\tif (reg & 0x08)\n\t\treturn;\n\n\trealcrtno = 1;\n\tif (ivideo->SiS_Pr.DDCPortMixup)\n\t\trealcrtno = 0;\n\n\t \n\ttemp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags, ivideo->sisvga_engine,\n\t\t\t\trealcrtno, 0, &buffer[0], ivideo->vbflags2);\n\n\tif ((!temp) || (temp == 0xffff) || (!(temp & 0x02)))\n\t\treturn;\n\n\t \n\ti = 3;   \n\tdo {\n\t\ttemp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags,\n\t\t\t\tivideo->sisvga_engine, realcrtno, 1,\n\t\t\t\t&buffer[0], ivideo->vbflags2);\n\t} while ((temp) && i--);\n\n\tif (temp)\n\t\treturn;\n\n\t \n\tif (!(buffer[0x14] & 0x80))\n\t\treturn;\n\n\t \n\tif (!(buffer[0x18] & 0x02))\n\t\treturn;\n\n\txres = buffer[0x38] | ((buffer[0x3a] & 0xf0) << 4);\n\tyres = buffer[0x3b] | ((buffer[0x3d] & 0xf0) << 4);\n\n\tswitch(xres) {\n\t\tcase 1024:\n\t\t\tif (yres == 768)\n\t\t\t\tpaneltype = 0x02;\n\t\t\tbreak;\n\t\tcase 1280:\n\t\t\tif (yres == 1024)\n\t\t\t\tpaneltype = 0x03;\n\t\t\tbreak;\n\t\tcase 1600:\n\t\t\tif ((yres == 1200) && (ivideo->vbflags2 & VB2_30xC))\n\t\t\t\tpaneltype = 0x0b;\n\t\t\tbreak;\n\t}\n\n\tif (!paneltype)\n\t\treturn;\n\n\tif (buffer[0x23])\n\t\tcr37 |= 0x10;\n\n\tif ((buffer[0x47] & 0x18) == 0x18)\n\t\tcr37 |= ((((buffer[0x47] & 0x06) ^ 0x06) << 5) | 0x20);\n\telse\n\t\tcr37 |= 0xc0;\n\n\tSiS_SetReg(SISCR, 0x36, paneltype);\n\tcr37 &= 0xf1;\n\tSiS_SetRegANDOR(SISCR, 0x37, 0x0c, cr37);\n\tSiS_SetRegOR(SISCR, 0x32, 0x08);\n\n\tivideo->SiS_Pr.PanelSelfDetected = true;\n}\n\nstatic int SISDoSense(struct sis_video_info *ivideo, u16 type, u16 test)\n{\n\tint temp, mytest, result, i, j;\n\n\tfor (j = 0; j < 10; j++) {\n\t\tresult = 0;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tmytest = test;\n\t\t\tSiS_SetReg(SISPART4, 0x11, (type & 0x00ff));\n\t\t\ttemp = (type >> 8) | (mytest & 0x00ff);\n\t\t\tSiS_SetRegANDOR(SISPART4, 0x10, 0xe0, temp);\n\t\t\tSiS_DDC2Delay(&ivideo->SiS_Pr, 0x1500);\n\t\t\tmytest >>= 8;\n\t\t\tmytest &= 0x7f;\n\t\t\ttemp = SiS_GetReg(SISPART4, 0x03);\n\t\t\ttemp ^= 0x0e;\n\t\t\ttemp &= mytest;\n\t\t\tif (temp == mytest)\n\t\t\t\tresult++;\n#if 1\n\t\t\tSiS_SetReg(SISPART4, 0x11, 0x00);\n\t\t\tSiS_SetRegAND(SISPART4, 0x10, 0xe0);\n\t\t\tSiS_DDC2Delay(&ivideo->SiS_Pr, 0x1000);\n#endif\n\t\t}\n\n\t\tif ((result == 0) || (result >= 2))\n\t\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic void SiS_Sense30x(struct sis_video_info *ivideo)\n{\n    u8  backupP4_0d,backupP2_00,backupP2_4d,backupSR_1e,biosflag=0;\n    u16 svhs=0, svhs_c=0;\n    u16 cvbs=0, cvbs_c=0;\n    u16 vga2=0, vga2_c=0;\n    int myflag, result;\n    char stdstr[] = \"sisfb: Detected\";\n    char tvstr[]  = \"TV connected to\";\n\n    if(ivideo->vbflags2 & VB2_301) {\n       svhs = 0x00b9; cvbs = 0x00b3; vga2 = 0x00d1;\n       myflag = SiS_GetReg(SISPART4, 0x01);\n       if(myflag & 0x04) {\n\t  svhs = 0x00dd; cvbs = 0x00ee; vga2 = 0x00fd;\n       }\n    } else if(ivideo->vbflags2 & (VB2_301B | VB2_302B)) {\n       svhs = 0x016b; cvbs = 0x0174; vga2 = 0x0190;\n    } else if(ivideo->vbflags2 & (VB2_301LV | VB2_302LV)) {\n       svhs = 0x0200; cvbs = 0x0100;\n    } else if(ivideo->vbflags2 & (VB2_301C | VB2_302ELV | VB2_307T | VB2_307LV)) {\n       svhs = 0x016b; cvbs = 0x0110; vga2 = 0x0190;\n    } else\n       return;\n\n    vga2_c = 0x0e08; svhs_c = 0x0404; cvbs_c = 0x0804;\n    if(ivideo->vbflags & (VB2_301LV|VB2_302LV|VB2_302ELV|VB2_307LV)) {\n       svhs_c = 0x0408; cvbs_c = 0x0808;\n    }\n\n    biosflag = 2;\n    if(ivideo->haveXGIROM) {\n       biosflag = ivideo->bios_abase[0x58] & 0x03;\n    } else if(ivideo->newrom) {\n       if(ivideo->bios_abase[0x5d] & 0x04) biosflag |= 0x01;\n    } else if(ivideo->sisvga_engine == SIS_300_VGA) {\n       if(ivideo->bios_abase) {\n          biosflag = ivideo->bios_abase[0xfe] & 0x03;\n       }\n    }\n\n    if(ivideo->chip == SIS_300) {\n       myflag = SiS_GetReg(SISSR, 0x3b);\n       if(!(myflag & 0x01)) vga2 = vga2_c = 0;\n    }\n\n    if(!(ivideo->vbflags2 & VB2_SISVGA2BRIDGE)) {\n       vga2 = vga2_c = 0;\n    }\n\n    backupSR_1e = SiS_GetReg(SISSR, 0x1e);\n    SiS_SetRegOR(SISSR, 0x1e, 0x20);\n\n    backupP4_0d = SiS_GetReg(SISPART4, 0x0d);\n    if(ivideo->vbflags2 & VB2_30xC) {\n\tSiS_SetRegANDOR(SISPART4, 0x0d, ~0x07, 0x01);\n    } else {\n       SiS_SetRegOR(SISPART4, 0x0d, 0x04);\n    }\n    SiS_DDC2Delay(&ivideo->SiS_Pr, 0x2000);\n\n    backupP2_00 = SiS_GetReg(SISPART2, 0x00);\n    SiS_SetReg(SISPART2, 0x00, ((backupP2_00 | 0x1c) & 0xfc));\n\n    backupP2_4d = SiS_GetReg(SISPART2, 0x4d);\n    if(ivideo->vbflags2 & VB2_SISYPBPRBRIDGE) {\n\tSiS_SetReg(SISPART2, 0x4d, (backupP2_4d & ~0x10));\n    }\n\n    if(!(ivideo->vbflags2 & VB2_30xCLV)) {\n       SISDoSense(ivideo, 0, 0);\n    }\n\n    SiS_SetRegAND(SISCR, 0x32, ~0x14);\n\n    if(vga2_c || vga2) {\n       if(SISDoSense(ivideo, vga2, vga2_c)) {\n          if(biosflag & 0x01) {\n\t     printk(KERN_INFO \"%s %s SCART output\\n\", stdstr, tvstr);\n\t     SiS_SetRegOR(SISCR, 0x32, 0x04);\n\t  } else {\n\t     printk(KERN_INFO \"%s secondary VGA connection\\n\", stdstr);\n\t     SiS_SetRegOR(SISCR, 0x32, 0x10);\n\t  }\n       }\n    }\n\n    SiS_SetRegAND(SISCR, 0x32, 0x3f);\n\n    if(ivideo->vbflags2 & VB2_30xCLV) {\n       SiS_SetRegOR(SISPART4, 0x0d, 0x04);\n    }\n\n    if((ivideo->sisvga_engine == SIS_315_VGA) && (ivideo->vbflags2 & VB2_SISYPBPRBRIDGE)) {\n       SiS_SetReg(SISPART2, 0x4d, (backupP2_4d | 0x10));\n       SiS_DDC2Delay(&ivideo->SiS_Pr, 0x2000);\n       if((result = SISDoSense(ivideo, svhs, 0x0604))) {\n          if((result = SISDoSense(ivideo, cvbs, 0x0804))) {\n\t     printk(KERN_INFO \"%s %s YPbPr component output\\n\", stdstr, tvstr);\n\t     SiS_SetRegOR(SISCR, 0x32, 0x80);\n\t  }\n       }\n       SiS_SetReg(SISPART2, 0x4d, backupP2_4d);\n    }\n\n    SiS_SetRegAND(SISCR, 0x32, ~0x03);\n\n    if(!(ivideo->vbflags & TV_YPBPR)) {\n       if((result = SISDoSense(ivideo, svhs, svhs_c))) {\n          printk(KERN_INFO \"%s %s SVIDEO output\\n\", stdstr, tvstr);\n\t   SiS_SetRegOR(SISCR, 0x32, 0x02);\n       }\n       if((biosflag & 0x02) || (!result)) {\n          if(SISDoSense(ivideo, cvbs, cvbs_c)) {\n\t     printk(KERN_INFO \"%s %s COMPOSITE output\\n\", stdstr, tvstr);\n\t     SiS_SetRegOR(SISCR, 0x32, 0x01);\n          }\n       }\n    }\n\n    SISDoSense(ivideo, 0, 0);\n\n    SiS_SetReg(SISPART2, 0x00, backupP2_00);\n    SiS_SetReg(SISPART4, 0x0d, backupP4_0d);\n    SiS_SetReg(SISSR, 0x1e, backupSR_1e);\n\n    if(ivideo->vbflags2 & VB2_30xCLV) {\n\tbiosflag = SiS_GetReg(SISPART2, 0x00);\n       if(biosflag & 0x20) {\n          for(myflag = 2; myflag > 0; myflag--) {\n\t     biosflag ^= 0x20;\n\t     SiS_SetReg(SISPART2, 0x00, biosflag);\n\t  }\n       }\n    }\n\n    SiS_SetReg(SISPART2, 0x00, backupP2_00);\n}\n\n \nstatic void SiS_SenseCh(struct sis_video_info *ivideo)\n{\n#if defined(CONFIG_FB_SIS_300) || defined(CONFIG_FB_SIS_315)\n    u8 temp1, temp2;\n    char stdstr[] = \"sisfb: Chrontel: Detected TV connected to\";\n#endif\n#ifdef CONFIG_FB_SIS_300\n    unsigned char test[3];\n    int i;\n#endif\n\n    if(ivideo->chip < SIS_315H) {\n\n#ifdef CONFIG_FB_SIS_300\n       ivideo->SiS_Pr.SiS_IF_DEF_CH70xx = 1;\t\t \n       SiS_SetChrontelGPIO(&ivideo->SiS_Pr, 0x9c);\t \n       SiS_DDC2Delay(&ivideo->SiS_Pr, 1000);\n       temp1 = SiS_GetCH700x(&ivideo->SiS_Pr, 0x25);\n        \n       temp2 = SiS_GetCH700x(&ivideo->SiS_Pr, 0x0e);\n       if(((temp2 & 0x07) == 0x01) || (temp2 & 0x04)) {\n\t  SiS_SetCH700x(&ivideo->SiS_Pr, 0x0e, 0x0b);\n\t  SiS_DDC2Delay(&ivideo->SiS_Pr, 300);\n       }\n       temp2 = SiS_GetCH700x(&ivideo->SiS_Pr, 0x25);\n       if(temp2 != temp1) temp1 = temp2;\n\n       if((temp1 >= 0x22) && (temp1 <= 0x50)) {\n\t    \n\t   temp1 = SiS_GetCH700x(&ivideo->SiS_Pr, 0x0e);\n\t   if((temp1 & 0x03) != 0x03) {\n\t\t \n\t\tSiS_SetCH700x(&ivideo->SiS_Pr, 0x0e,0x0b);\n\t\tSiS_DDC2Delay(&ivideo->SiS_Pr, 300);\n\t   }\n\t    \n\t   for(i = 0; i < 3; i++) {\n\t       SiS_SetCH700x(&ivideo->SiS_Pr, 0x10, 0x01);\n\t       SiS_DDC2Delay(&ivideo->SiS_Pr, 0x96);\n\t       SiS_SetCH700x(&ivideo->SiS_Pr, 0x10, 0x00);\n\t       SiS_DDC2Delay(&ivideo->SiS_Pr, 0x96);\n\t       temp1 = SiS_GetCH700x(&ivideo->SiS_Pr, 0x10);\n\t       if(!(temp1 & 0x08))       test[i] = 0x02;\n\t       else if(!(temp1 & 0x02))  test[i] = 0x01;\n\t       else                      test[i] = 0;\n\t       SiS_DDC2Delay(&ivideo->SiS_Pr, 0x96);\n\t   }\n\n\t   if(test[0] == test[1])      temp1 = test[0];\n\t   else if(test[0] == test[2]) temp1 = test[0];\n\t   else if(test[1] == test[2]) temp1 = test[1];\n\t   else {\n\t\tprintk(KERN_INFO\n\t\t\t\"sisfb: TV detection unreliable - test results varied\\n\");\n\t\ttemp1 = test[2];\n\t   }\n\t   if(temp1 == 0x02) {\n\t\tprintk(KERN_INFO \"%s SVIDEO output\\n\", stdstr);\n\t\tivideo->vbflags |= TV_SVIDEO;\n\t\tSiS_SetRegOR(SISCR, 0x32, 0x02);\n\t\tSiS_SetRegAND(SISCR, 0x32, ~0x05);\n\t   } else if (temp1 == 0x01) {\n\t\tprintk(KERN_INFO \"%s CVBS output\\n\", stdstr);\n\t\tivideo->vbflags |= TV_AVIDEO;\n\t\tSiS_SetRegOR(SISCR, 0x32, 0x01);\n\t\tSiS_SetRegAND(SISCR, 0x32, ~0x06);\n\t   } else {\n\t\tSiS_SetCH70xxANDOR(&ivideo->SiS_Pr, 0x0e, 0x01, 0xF8);\n\t\tSiS_SetRegAND(SISCR, 0x32, ~0x07);\n\t   }\n       } else if(temp1 == 0) {\n\t  SiS_SetCH70xxANDOR(&ivideo->SiS_Pr, 0x0e, 0x01, 0xF8);\n\t  SiS_SetRegAND(SISCR, 0x32, ~0x07);\n       }\n        \n       SiS_SetChrontelGPIO(&ivideo->SiS_Pr, 0x00);\n#endif\n\n    } else {\n\n#ifdef CONFIG_FB_SIS_315\n\tivideo->SiS_Pr.SiS_IF_DEF_CH70xx = 2;\t\t \n\ttemp1 = SiS_GetCH701x(&ivideo->SiS_Pr, 0x49);\n\tSiS_SetCH701x(&ivideo->SiS_Pr, 0x49, 0x20);\n\tSiS_DDC2Delay(&ivideo->SiS_Pr, 0x96);\n\ttemp2 = SiS_GetCH701x(&ivideo->SiS_Pr, 0x20);\n\ttemp2 |= 0x01;\n\tSiS_SetCH701x(&ivideo->SiS_Pr, 0x20, temp2);\n\tSiS_DDC2Delay(&ivideo->SiS_Pr, 0x96);\n\ttemp2 ^= 0x01;\n\tSiS_SetCH701x(&ivideo->SiS_Pr, 0x20, temp2);\n\tSiS_DDC2Delay(&ivideo->SiS_Pr, 0x96);\n\ttemp2 = SiS_GetCH701x(&ivideo->SiS_Pr, 0x20);\n\tSiS_SetCH701x(&ivideo->SiS_Pr, 0x49, temp1);\n\ttemp1 = 0;\n\tif(temp2 & 0x02) temp1 |= 0x01;\n\tif(temp2 & 0x10) temp1 |= 0x01;\n\tif(temp2 & 0x04) temp1 |= 0x02;\n\tif( (temp1 & 0x01) && (temp1 & 0x02) ) temp1 = 0x04;\n\tswitch(temp1) {\n\tcase 0x01:\n\t     printk(KERN_INFO \"%s CVBS output\\n\", stdstr);\n\t     ivideo->vbflags |= TV_AVIDEO;\n\t     SiS_SetRegOR(SISCR, 0x32, 0x01);\n\t     SiS_SetRegAND(SISCR, 0x32, ~0x06);\n\t     break;\n\tcase 0x02:\n\t     printk(KERN_INFO \"%s SVIDEO output\\n\", stdstr);\n\t     ivideo->vbflags |= TV_SVIDEO;\n\t     SiS_SetRegOR(SISCR, 0x32, 0x02);\n\t     SiS_SetRegAND(SISCR, 0x32, ~0x05);\n\t     break;\n\tcase 0x04:\n\t     printk(KERN_INFO \"%s SCART output\\n\", stdstr);\n\t     SiS_SetRegOR(SISCR, 0x32, 0x04);\n\t     SiS_SetRegAND(SISCR, 0x32, ~0x03);\n\t     break;\n\tdefault:\n\t     SiS_SetRegAND(SISCR, 0x32, ~0x07);\n\t}\n#endif\n    }\n}\n\nstatic void sisfb_get_VB_type(struct sis_video_info *ivideo)\n{\n\tchar stdstr[]    = \"sisfb: Detected\";\n\tchar bridgestr[] = \"video bridge\";\n\tu8 vb_chipid;\n\tu8 reg;\n\n\t \n\tif(ivideo->chip == XGI_20)\n\t\treturn;\n\n\tvb_chipid = SiS_GetReg(SISPART4, 0x00);\n\tswitch(vb_chipid) {\n\tcase 0x01:\n\t\treg = SiS_GetReg(SISPART4, 0x01);\n\t\tif(reg < 0xb0) {\n\t\t\tivideo->vbflags |= VB_301;\t \n\t\t\tivideo->vbflags2 |= VB2_301;\n\t\t\tprintk(KERN_INFO \"%s SiS301 %s\\n\", stdstr, bridgestr);\n\t\t} else if(reg < 0xc0) {\n\t\t\tivideo->vbflags |= VB_301B;\t \n\t\t\tivideo->vbflags2 |= VB2_301B;\n\t\t\treg = SiS_GetReg(SISPART4, 0x23);\n\t\t\tif(!(reg & 0x02)) {\n\t\t\t   ivideo->vbflags |= VB_30xBDH;\t \n\t\t\t   ivideo->vbflags2 |= VB2_30xBDH;\n\t\t\t   printk(KERN_INFO \"%s SiS301B-DH %s\\n\", stdstr, bridgestr);\n\t\t\t} else {\n\t\t\t   printk(KERN_INFO \"%s SiS301B %s\\n\", stdstr, bridgestr);\n\t\t\t}\n\t\t} else if(reg < 0xd0) {\n\t\t\tivideo->vbflags |= VB_301C;\t \n\t\t\tivideo->vbflags2 |= VB2_301C;\n\t\t\tprintk(KERN_INFO \"%s SiS301C %s\\n\", stdstr, bridgestr);\n\t\t} else if(reg < 0xe0) {\n\t\t\tivideo->vbflags |= VB_301LV;\t \n\t\t\tivideo->vbflags2 |= VB2_301LV;\n\t\t\tprintk(KERN_INFO \"%s SiS301LV %s\\n\", stdstr, bridgestr);\n\t\t} else if(reg <= 0xe1) {\n\t\t\treg = SiS_GetReg(SISPART4, 0x39);\n\t\t\tif(reg == 0xff) {\n\t\t\t   ivideo->vbflags |= VB_302LV;\t \n\t\t\t   ivideo->vbflags2 |= VB2_302LV;\n\t\t\t   printk(KERN_INFO \"%s SiS302LV %s\\n\", stdstr, bridgestr);\n\t\t\t} else {\n\t\t\t   ivideo->vbflags |= VB_301C;\t \n\t\t\t   ivideo->vbflags2 |= VB2_301C;\n\t\t\t   printk(KERN_INFO \"%s SiS301C(P4) %s\\n\", stdstr, bridgestr);\n#if 0\n\t\t\t   ivideo->vbflags |= VB_302ELV;\t \n\t\t\t   ivideo->vbflags2 |= VB2_302ELV;\n\t\t\t   printk(KERN_INFO \"%s SiS302ELV %s\\n\", stdstr, bridgestr);\n#endif\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 0x02:\n\t\tivideo->vbflags |= VB_302B;\t \n\t\tivideo->vbflags2 |= VB2_302B;\n\t\tprintk(KERN_INFO \"%s SiS302B %s\\n\", stdstr, bridgestr);\n\t\tbreak;\n\t}\n\n\tif((!(ivideo->vbflags2 & VB2_VIDEOBRIDGE)) && (ivideo->chip != SIS_300)) {\n\t\treg = SiS_GetReg(SISCR, 0x37);\n\t\treg &= SIS_EXTERNAL_CHIP_MASK;\n\t\treg >>= 1;\n\t\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n#ifdef CONFIG_FB_SIS_300\n\t\t\tswitch(reg) {\n\t\t\t   case SIS_EXTERNAL_CHIP_LVDS:\n\t\t\t\tivideo->vbflags |= VB_LVDS;\t \n\t\t\t\tivideo->vbflags2 |= VB2_LVDS;\n\t\t\t\tbreak;\n\t\t\t   case SIS_EXTERNAL_CHIP_TRUMPION:\n\t\t\t\tivideo->vbflags |= (VB_LVDS | VB_TRUMPION);\t \n\t\t\t\tivideo->vbflags2 |= (VB2_LVDS | VB2_TRUMPION);\n\t\t\t\tbreak;\n\t\t\t   case SIS_EXTERNAL_CHIP_CHRONTEL:\n\t\t\t\tivideo->vbflags |= VB_CHRONTEL;\t \n\t\t\t\tivideo->vbflags2 |= VB2_CHRONTEL;\n\t\t\t\tbreak;\n\t\t\t   case SIS_EXTERNAL_CHIP_LVDS_CHRONTEL:\n\t\t\t\tivideo->vbflags |= (VB_LVDS | VB_CHRONTEL);\t \n\t\t\t\tivideo->vbflags2 |= (VB2_LVDS | VB2_CHRONTEL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ivideo->vbflags2 & VB2_CHRONTEL) ivideo->chronteltype = 1;\n#endif\n\t\t} else if(ivideo->chip < SIS_661) {\n#ifdef CONFIG_FB_SIS_315\n\t\t\tswitch (reg) {\n\t\t\t   case SIS310_EXTERNAL_CHIP_LVDS:\n\t\t\t\tivideo->vbflags |= VB_LVDS;\t \n\t\t\t\tivideo->vbflags2 |= VB2_LVDS;\n\t\t\t\tbreak;\n\t\t\t   case SIS310_EXTERNAL_CHIP_LVDS_CHRONTEL:\n\t\t\t\tivideo->vbflags |= (VB_LVDS | VB_CHRONTEL);\t \n\t\t\t\tivideo->vbflags2 |= (VB2_LVDS | VB2_CHRONTEL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ivideo->vbflags2 & VB2_CHRONTEL) ivideo->chronteltype = 2;\n#endif\n\t\t} else if(ivideo->chip >= SIS_661) {\n#ifdef CONFIG_FB_SIS_315\n\t\t\treg = SiS_GetReg(SISCR, 0x38);\n\t\t\treg >>= 5;\n\t\t\tswitch(reg) {\n\t\t\t   case 0x02:\n\t\t\t\tivideo->vbflags |= VB_LVDS;\t \n\t\t\t\tivideo->vbflags2 |= VB2_LVDS;\n\t\t\t\tbreak;\n\t\t\t   case 0x03:\n\t\t\t\tivideo->vbflags |= (VB_LVDS | VB_CHRONTEL);\t \n\t\t\t\tivideo->vbflags2 |= (VB2_LVDS | VB2_CHRONTEL);\n\t\t\t\tbreak;\n\t\t\t   case 0x04:\n\t\t\t\tivideo->vbflags |= (VB_LVDS | VB_CONEXANT);\t \n\t\t\t\tivideo->vbflags2 |= (VB2_LVDS | VB2_CONEXANT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ivideo->vbflags2 & VB2_CHRONTEL) ivideo->chronteltype = 2;\n#endif\n\t\t}\n\t\tif(ivideo->vbflags2 & VB2_LVDS) {\n\t\t   printk(KERN_INFO \"%s LVDS transmitter\\n\", stdstr);\n\t\t}\n\t\tif((ivideo->sisvga_engine == SIS_300_VGA) && (ivideo->vbflags2 & VB2_TRUMPION)) {\n\t\t   printk(KERN_INFO \"%s Trumpion Zurac LCD scaler\\n\", stdstr);\n\t\t}\n\t\tif(ivideo->vbflags2 & VB2_CHRONTEL) {\n\t\t   printk(KERN_INFO \"%s Chrontel TV encoder\\n\", stdstr);\n\t\t}\n\t\tif((ivideo->chip >= SIS_661) && (ivideo->vbflags2 & VB2_CONEXANT)) {\n\t\t   printk(KERN_INFO \"%s Conexant external device\\n\", stdstr);\n\t\t}\n\t}\n\n\tif(ivideo->vbflags2 & VB2_SISBRIDGE) {\n\t\tSiS_SenseLCD(ivideo);\n\t\tSiS_Sense30x(ivideo);\n\t} else if(ivideo->vbflags2 & VB2_CHRONTEL) {\n\t\tSiS_SenseCh(ivideo);\n\t}\n}\n\n \n\nstatic void\nsisfb_engine_init(struct sis_video_info *ivideo)\n{\n\n\t \n\n\t \n\n\tivideo->caps &= ~(TURBO_QUEUE_CAP    |\n\t\t\t  MMIO_CMD_QUEUE_CAP |\n\t\t\t  VM_CMD_QUEUE_CAP   |\n\t\t\t  AGP_CMD_QUEUE_CAP);\n\n#ifdef CONFIG_FB_SIS_300\n\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t\tu32 tqueue_pos;\n\t\tu8 tq_state;\n\n\t\ttqueue_pos = (ivideo->video_size - ivideo->cmdQueueSize) / (64 * 1024);\n\n\t\ttq_state = SiS_GetReg(SISSR, IND_SIS_TURBOQUEUE_SET);\n\t\ttq_state |= 0xf0;\n\t\ttq_state &= 0xfc;\n\t\ttq_state |= (u8)(tqueue_pos >> 8);\n\t\tSiS_SetReg(SISSR, IND_SIS_TURBOQUEUE_SET, tq_state);\n\n\t\tSiS_SetReg(SISSR, IND_SIS_TURBOQUEUE_ADR, (u8)(tqueue_pos & 0xff));\n\n\t\tivideo->caps |= TURBO_QUEUE_CAP;\n\t}\n#endif\n\n#ifdef CONFIG_FB_SIS_315\n\tif(ivideo->sisvga_engine == SIS_315_VGA) {\n\t\tu32 tempq = 0, templ;\n\t\tu8  temp;\n\n\t\tif(ivideo->chip == XGI_20) {\n\t\t\tswitch(ivideo->cmdQueueSize) {\n\t\t\tcase (64 * 1024):\n\t\t\t\ttemp = SIS_CMD_QUEUE_SIZE_Z7_64k;\n\t\t\t\tbreak;\n\t\t\tcase (128 * 1024):\n\t\t\tdefault:\n\t\t\t\ttemp = SIS_CMD_QUEUE_SIZE_Z7_128k;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch(ivideo->cmdQueueSize) {\n\t\t\tcase (4 * 1024 * 1024):\n\t\t\t\ttemp = SIS_CMD_QUEUE_SIZE_4M;\n\t\t\t\tbreak;\n\t\t\tcase (2 * 1024 * 1024):\n\t\t\t\ttemp = SIS_CMD_QUEUE_SIZE_2M;\n\t\t\t\tbreak;\n\t\t\tcase (1 * 1024 * 1024):\n\t\t\t\ttemp = SIS_CMD_QUEUE_SIZE_1M;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase (512 * 1024):\n\t\t\t\ttemp = SIS_CMD_QUEUE_SIZE_512k;\n\t\t\t}\n\t\t}\n\n\t\tSiS_SetReg(SISSR, IND_SIS_CMDQUEUE_THRESHOLD, COMMAND_QUEUE_THRESHOLD);\n\t\tSiS_SetReg(SISSR, IND_SIS_CMDQUEUE_SET, SIS_CMD_QUEUE_RESET);\n\n\t\tif((ivideo->chip >= XGI_40) && ivideo->modechanged) {\n\t\t\t \n\t\t\tif(!((templ = MMIO_IN32(ivideo->mmio_vbase, 0x8240)) & (1 << 10))) {\n\n\t\t\t\tMMIO_OUT32(ivideo->mmio_vbase, Q_WRITE_PTR, 0);\n\n\t\t\t\tSiS_SetReg(SISSR, IND_SIS_CMDQUEUE_SET, (temp | SIS_VRAM_CMDQUEUE_ENABLE));\n\n\t\t\t\ttempq = MMIO_IN32(ivideo->mmio_vbase, Q_READ_PTR);\n\t\t\t\tMMIO_OUT32(ivideo->mmio_vbase, Q_WRITE_PTR, tempq);\n\n\t\t\t\ttempq = (u32)(ivideo->video_size - ivideo->cmdQueueSize);\n\t\t\t\tMMIO_OUT32(ivideo->mmio_vbase, Q_BASE_ADDR, tempq);\n\n\t\t\t\twritel(0x16800000 + 0x8240, ivideo->video_vbase + tempq);\n\t\t\t\twritel(templ | (1 << 10), ivideo->video_vbase + tempq + 4);\n\t\t\t\twritel(0x168F0000, ivideo->video_vbase + tempq + 8);\n\t\t\t\twritel(0x168F0000, ivideo->video_vbase + tempq + 12);\n\n\t\t\t\tMMIO_OUT32(ivideo->mmio_vbase, Q_WRITE_PTR, (tempq + 16));\n\n\t\t\t\tsisfb_syncaccel(ivideo);\n\n\t\t\t\tSiS_SetReg(SISSR, IND_SIS_CMDQUEUE_SET, SIS_CMD_QUEUE_RESET);\n\n\t\t\t}\n\t\t}\n\n\t\ttempq = MMIO_IN32(ivideo->mmio_vbase, MMIO_QUEUE_READPORT);\n\t\tMMIO_OUT32(ivideo->mmio_vbase, MMIO_QUEUE_WRITEPORT, tempq);\n\n\t\ttemp |= (SIS_MMIO_CMD_ENABLE | SIS_CMD_AUTO_CORR);\n\t\tSiS_SetReg(SISSR, IND_SIS_CMDQUEUE_SET, temp);\n\n\t\ttempq = (u32)(ivideo->video_size - ivideo->cmdQueueSize);\n\t\tMMIO_OUT32(ivideo->mmio_vbase, MMIO_QUEUE_PHYBASE, tempq);\n\n\t\tivideo->caps |= MMIO_CMD_QUEUE_CAP;\n\t}\n#endif\n\n\tivideo->engineok = 1;\n}\n\nstatic void sisfb_detect_lcd_type(struct sis_video_info *ivideo)\n{\n\tu8 reg;\n\tint i;\n\n\treg = SiS_GetReg(SISCR, 0x36);\n\treg &= 0x0f;\n\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t\tivideo->CRT2LCDType = sis300paneltype[reg];\n\t} else if(ivideo->chip >= SIS_661) {\n\t\tivideo->CRT2LCDType = sis661paneltype[reg];\n\t} else {\n\t\tivideo->CRT2LCDType = sis310paneltype[reg];\n\t\tif((ivideo->chip == SIS_550) && (sisfb_fstn)) {\n\t\t\tif((ivideo->CRT2LCDType != LCD_320x240_2) &&\n\t\t\t   (ivideo->CRT2LCDType != LCD_320x240_3)) {\n\t\t\t\tivideo->CRT2LCDType = LCD_320x240;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(ivideo->CRT2LCDType == LCD_UNKNOWN) {\n\t\t \n\t\tivideo->CRT2LCDType = LCD_1024x768;\n\t\tSiS_SetRegANDOR(SISCR, 0x36, 0xf0, 0x02);\n\t\tSiS_SetRegANDOR(SISCR, 0x37, 0xee, 0x01);\n\t\tprintk(KERN_DEBUG \"sisfb: Invalid panel ID (%02x), assuming 1024x768, RGB18\\n\", reg);\n\t}\n\n\tfor(i = 0; i < SIS_LCD_NUMBER; i++) {\n\t\tif(ivideo->CRT2LCDType == sis_lcd_data[i].lcdtype) {\n\t\t\tivideo->lcdxres = sis_lcd_data[i].xres;\n\t\t\tivideo->lcdyres = sis_lcd_data[i].yres;\n\t\t\tivideo->lcddefmodeidx = sis_lcd_data[i].default_mode_idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef CONFIG_FB_SIS_300\n\tif(ivideo->SiS_Pr.SiS_CustomT == CUT_BARCO1366) {\n\t\tivideo->lcdxres = 1360; ivideo->lcdyres = 1024;\n\t\tivideo->lcddefmodeidx = DEFAULT_MODE_1360;\n\t} else if(ivideo->SiS_Pr.SiS_CustomT == CUT_PANEL848) {\n\t\tivideo->lcdxres =  848; ivideo->lcdyres =  480;\n\t\tivideo->lcddefmodeidx = DEFAULT_MODE_848;\n\t} else if(ivideo->SiS_Pr.SiS_CustomT == CUT_PANEL856) {\n\t\tivideo->lcdxres =  856; ivideo->lcdyres =  480;\n\t\tivideo->lcddefmodeidx = DEFAULT_MODE_856;\n\t}\n#endif\n\n\tprintk(KERN_DEBUG \"sisfb: Detected %dx%d flat panel\\n\",\n\t\t\tivideo->lcdxres, ivideo->lcdyres);\n}\n\nstatic void sisfb_save_pdc_emi(struct sis_video_info *ivideo)\n{\n#ifdef CONFIG_FB_SIS_300\n\t \n\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t\tif(ivideo->vbflags2 & (VB2_LVDS | VB2_30xBDH)) {\n\t\t\tint tmp;\n\t\t\ttmp = SiS_GetReg(SISCR, 0x30);\n\t\t\tif(tmp & 0x20) {\n\t\t\t\t \n\t\t\t\tivideo->detectedpdc = SiS_GetReg(SISPART1, 0x13);\n\t\t\t\tivideo->detectedpdc &= 0x3c;\n\t\t\t\tif(ivideo->SiS_Pr.PDC == -1) {\n\t\t\t\t\t \n\t\t\t\t\tivideo->SiS_Pr.PDC = ivideo->detectedpdc;\n\t\t\t\t}\n\t\t\t\tprintk(KERN_INFO \"sisfb: Detected LCD PDC 0x%02x\\n\",\n\t\t\t\t\tivideo->detectedpdc);\n\t\t\t}\n\t\t\tif((ivideo->SiS_Pr.PDC != -1) &&\n\t\t\t   (ivideo->SiS_Pr.PDC != ivideo->detectedpdc)) {\n\t\t\t\tprintk(KERN_INFO \"sisfb: Using LCD PDC 0x%02x\\n\",\n\t\t\t\t\tivideo->SiS_Pr.PDC);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n#ifdef CONFIG_FB_SIS_315\n\tif(ivideo->sisvga_engine == SIS_315_VGA) {\n\n\t\t \n\t\tif(ivideo->vbflags2 & VB2_SISLCDABRIDGE) {\n\t\t\tint tmp;\n\t\t\ttmp = SiS_GetReg(SISPART1, 0x13);\n\t\t\tif(tmp & 0x04) {\n\t\t\t\tivideo->SiS_Pr.SiS_UseLCDA = true;\n\t\t\t\tivideo->detectedlcda = 0x03;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif(ivideo->vbflags2 & VB2_SISLVDSBRIDGE) {\n\t\t\tint tmp;\n\t\t\ttmp = SiS_GetReg(SISCR, 0x30);\n\t\t\tif((tmp & 0x20) || (ivideo->detectedlcda != 0xff)) {\n\t\t\t\t \n\t\t\t\tu8 pdc;\n\t\t\t\tpdc = SiS_GetReg(SISPART1, 0x2D);\n\t\t\t\tivideo->detectedpdc  = (pdc & 0x0f) << 1;\n\t\t\t\tivideo->detectedpdca = (pdc & 0xf0) >> 3;\n\t\t\t\tpdc = SiS_GetReg(SISPART1, 0x35);\n\t\t\t\tivideo->detectedpdc |= ((pdc >> 7) & 0x01);\n\t\t\t\tpdc = SiS_GetReg(SISPART1, 0x20);\n\t\t\t\tivideo->detectedpdca |= ((pdc >> 6) & 0x01);\n\t\t\t\tif(ivideo->newrom) {\n\t\t\t\t\t \n\t\t\t\t\tif(ivideo->detectedlcda != 0xff) {\n\t\t\t\t\t\tivideo->detectedpdc = 0xff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tivideo->detectedpdca = 0xff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ivideo->SiS_Pr.PDC == -1) {\n\t\t\t\t\tif(ivideo->detectedpdc != 0xff) {\n\t\t\t\t\t\tivideo->SiS_Pr.PDC = ivideo->detectedpdc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ivideo->SiS_Pr.PDCA == -1) {\n\t\t\t\t\tif(ivideo->detectedpdca != 0xff) {\n\t\t\t\t\t\tivideo->SiS_Pr.PDCA = ivideo->detectedpdca;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ivideo->detectedpdc != 0xff) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t\t\"sisfb: Detected LCD PDC 0x%02x (for LCD=CRT2)\\n\",\n\t\t\t\t\t\tivideo->detectedpdc);\n\t\t\t\t}\n\t\t\t\tif(ivideo->detectedpdca != 0xff) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t\t\"sisfb: Detected LCD PDC1 0x%02x (for LCD=CRT1)\\n\",\n\t\t\t\t\t\tivideo->detectedpdca);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif(ivideo->vbflags2 & VB2_SISEMIBRIDGE) {\n\t\t\t\tivideo->SiS_Pr.EMI_30 = SiS_GetReg(SISPART4, 0x30);\n\t\t\t\tivideo->SiS_Pr.EMI_31 = SiS_GetReg(SISPART4, 0x31);\n\t\t\t\tivideo->SiS_Pr.EMI_32 = SiS_GetReg(SISPART4, 0x32);\n\t\t\t\tivideo->SiS_Pr.EMI_33 = SiS_GetReg(SISPART4, 0x33);\n\t\t\t\tivideo->SiS_Pr.HaveEMI = true;\n\t\t\t\tif((tmp & 0x20) || (ivideo->detectedlcda != 0xff)) {\n\t\t\t\t\tivideo->SiS_Pr.HaveEMILCD = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif(ivideo->vbflags2 & VB2_30xBLV) {\n\t\t\tif((ivideo->SiS_Pr.PDC != -1) &&\n\t\t\t   (ivideo->SiS_Pr.PDC != ivideo->detectedpdc)) {\n\t\t\t\tprintk(KERN_INFO \"sisfb: Using LCD PDC 0x%02x (for LCD=CRT2)\\n\",\n\t\t\t\t\tivideo->SiS_Pr.PDC);\n\t\t\t}\n\t\t\tif((ivideo->SiS_Pr.PDCA != -1) &&\n\t\t\t   (ivideo->SiS_Pr.PDCA != ivideo->detectedpdca)) {\n\t\t\t\tprintk(KERN_INFO \"sisfb: Using LCD PDC1 0x%02x (for LCD=CRT1)\\n\",\n\t\t\t\t ivideo->SiS_Pr.PDCA);\n\t\t\t}\n\t\t}\n\n\t}\n#endif\n}\n\n \n\nstatic u32 sisfb_getheapstart(struct sis_video_info *ivideo)\n{\n\tu32 ret = ivideo->sisfb_parm_mem * 1024;\n\tu32 maxoffs = ivideo->video_size - ivideo->hwcursor_size - ivideo->cmdQueueSize;\n\tu32 def;\n\n\t \n\n\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t\tif(ivideo->video_size > 0x1000000) {\n\t\t\tdef = 0xc00000;\n\t\t} else if(ivideo->video_size > 0x800000) {\n\t\t\tdef = 0x800000;\n\t\t} else {\n\t\t\tdef = 0x400000;\n\t\t}\n\t} else if(ivideo->UMAsize && ivideo->LFBsize) {\n\t\tret = def = 0;\n\t} else {\n\t\tdef = maxoffs - 0x8000;\n\t}\n\n\t \n\tif((!ret) || (ret > maxoffs) || (ivideo->cardnumber != 0))\n\t\tret = def;\n\n\treturn ret;\n}\n\nstatic u32 sisfb_getheapsize(struct sis_video_info *ivideo)\n{\n\tu32 max = ivideo->video_size - ivideo->hwcursor_size - ivideo->cmdQueueSize;\n\tu32 ret = 0;\n\n\tif(ivideo->UMAsize && ivideo->LFBsize) {\n\t\tif( (!ivideo->sisfb_parm_mem)\t\t\t||\n\t\t    ((ivideo->sisfb_parm_mem * 1024) > max)\t||\n\t\t    ((max - (ivideo->sisfb_parm_mem * 1024)) < ivideo->UMAsize) ) {\n\t\t\tret = ivideo->UMAsize;\n\t\t\tmax -= ivideo->UMAsize;\n\t\t} else {\n\t\t\tret = max - (ivideo->sisfb_parm_mem * 1024);\n\t\t\tmax = ivideo->sisfb_parm_mem * 1024;\n\t\t}\n\t\tivideo->video_offset = ret;\n\t\tivideo->sisfb_mem = max;\n\t} else {\n\t\tret = max - ivideo->heapstart;\n\t\tivideo->sisfb_mem = ivideo->heapstart;\n\t}\n\n\treturn ret;\n}\n\nstatic int sisfb_heap_init(struct sis_video_info *ivideo)\n{\n\tstruct SIS_OH *poh;\n\n\tivideo->video_offset = 0;\n\tif(ivideo->sisfb_parm_mem) {\n\t\tif( (ivideo->sisfb_parm_mem < (2 * 1024 * 1024)) ||\n\t\t    (ivideo->sisfb_parm_mem > ivideo->video_size) ) {\n\t\t\tivideo->sisfb_parm_mem = 0;\n\t\t}\n\t}\n\n\tivideo->heapstart = sisfb_getheapstart(ivideo);\n\tivideo->sisfb_heap_size = sisfb_getheapsize(ivideo);\n\n\tivideo->sisfb_heap_start = ivideo->video_vbase + ivideo->heapstart;\n\tivideo->sisfb_heap_end   = ivideo->sisfb_heap_start + ivideo->sisfb_heap_size;\n\n\tprintk(KERN_INFO \"sisfb: Memory heap starting at %dK, size %dK\\n\",\n\t\t(int)(ivideo->heapstart / 1024), (int)(ivideo->sisfb_heap_size / 1024));\n\n\tivideo->sisfb_heap.vinfo = ivideo;\n\n\tivideo->sisfb_heap.poha_chain = NULL;\n\tivideo->sisfb_heap.poh_freelist = NULL;\n\n\tpoh = sisfb_poh_new_node(&ivideo->sisfb_heap);\n\tif(poh == NULL)\n\t\treturn 1;\n\n\tpoh->poh_next = &ivideo->sisfb_heap.oh_free;\n\tpoh->poh_prev = &ivideo->sisfb_heap.oh_free;\n\tpoh->size = ivideo->sisfb_heap_size;\n\tpoh->offset = ivideo->heapstart;\n\n\tivideo->sisfb_heap.oh_free.poh_next = poh;\n\tivideo->sisfb_heap.oh_free.poh_prev = poh;\n\tivideo->sisfb_heap.oh_free.size = 0;\n\tivideo->sisfb_heap.max_freesize = poh->size;\n\n\tivideo->sisfb_heap.oh_used.poh_next = &ivideo->sisfb_heap.oh_used;\n\tivideo->sisfb_heap.oh_used.poh_prev = &ivideo->sisfb_heap.oh_used;\n\tivideo->sisfb_heap.oh_used.size = SENTINEL;\n\n\tif(ivideo->cardnumber == 0) {\n\t\t \n\t\tsisfb_heap = &ivideo->sisfb_heap;\n\t}\n\n\treturn 0;\n}\n\nstatic struct SIS_OH *\nsisfb_poh_new_node(struct SIS_HEAP *memheap)\n{\n\tstruct SIS_OHALLOC\t*poha;\n\tstruct SIS_OH\t\t*poh;\n\tunsigned long\t\tcOhs;\n\tint\t\t\ti;\n\n\tif(memheap->poh_freelist == NULL) {\n\t\tpoha = kmalloc(SIS_OH_ALLOC_SIZE, GFP_KERNEL);\n\t\tif(!poha)\n\t\t\treturn NULL;\n\n\t\tpoha->poha_next = memheap->poha_chain;\n\t\tmemheap->poha_chain = poha;\n\n\t\tcOhs = (SIS_OH_ALLOC_SIZE - sizeof(struct SIS_OHALLOC)) / sizeof(struct SIS_OH) + 1;\n\n\t\tpoh = &poha->aoh[0];\n\t\tfor(i = cOhs - 1; i != 0; i--) {\n\t\t\tpoh->poh_next = poh + 1;\n\t\t\tpoh = poh + 1;\n\t\t}\n\n\t\tpoh->poh_next = NULL;\n\t\tmemheap->poh_freelist = &poha->aoh[0];\n\t}\n\n\tpoh = memheap->poh_freelist;\n\tmemheap->poh_freelist = poh->poh_next;\n\n\treturn poh;\n}\n\nstatic struct SIS_OH *\nsisfb_poh_allocate(struct SIS_HEAP *memheap, u32 size)\n{\n\tstruct SIS_OH\t*pohThis;\n\tstruct SIS_OH\t*pohRoot;\n\tint\t\tbAllocated = 0;\n\n\tif(size > memheap->max_freesize) {\n\t\tDPRINTK(\"sisfb: Can't allocate %dk video memory\\n\",\n\t\t\t(unsigned int) size / 1024);\n\t\treturn NULL;\n\t}\n\n\tpohThis = memheap->oh_free.poh_next;\n\n\twhile(pohThis != &memheap->oh_free) {\n\t\tif(size <= pohThis->size) {\n\t\t\tbAllocated = 1;\n\t\t\tbreak;\n\t\t}\n\t\tpohThis = pohThis->poh_next;\n\t}\n\n\tif(!bAllocated) {\n\t\tDPRINTK(\"sisfb: Can't allocate %dk video memory\\n\",\n\t\t\t(unsigned int) size / 1024);\n\t\treturn NULL;\n\t}\n\n\tif(size == pohThis->size) {\n\t\tpohRoot = pohThis;\n\t\tsisfb_delete_node(pohThis);\n\t} else {\n\t\tpohRoot = sisfb_poh_new_node(memheap);\n\t\tif(pohRoot == NULL)\n\t\t\treturn NULL;\n\n\t\tpohRoot->offset = pohThis->offset;\n\t\tpohRoot->size = size;\n\n\t\tpohThis->offset += size;\n\t\tpohThis->size -= size;\n\t}\n\n\tmemheap->max_freesize -= size;\n\n\tpohThis = &memheap->oh_used;\n\tsisfb_insert_node(pohThis, pohRoot);\n\n\treturn pohRoot;\n}\n\nstatic void\nsisfb_delete_node(struct SIS_OH *poh)\n{\n\tpoh->poh_prev->poh_next = poh->poh_next;\n\tpoh->poh_next->poh_prev = poh->poh_prev;\n}\n\nstatic void\nsisfb_insert_node(struct SIS_OH *pohList, struct SIS_OH *poh)\n{\n\tstruct SIS_OH *pohTemp = pohList->poh_next;\n\n\tpohList->poh_next = poh;\n\tpohTemp->poh_prev = poh;\n\n\tpoh->poh_prev = pohList;\n\tpoh->poh_next = pohTemp;\n}\n\nstatic struct SIS_OH *\nsisfb_poh_free(struct SIS_HEAP *memheap, u32 base)\n{\n\tstruct SIS_OH *pohThis;\n\tstruct SIS_OH *poh_freed;\n\tstruct SIS_OH *poh_prev;\n\tstruct SIS_OH *poh_next;\n\tu32    ulUpper;\n\tu32    ulLower;\n\tint    foundNode = 0;\n\n\tpoh_freed = memheap->oh_used.poh_next;\n\n\twhile(poh_freed != &memheap->oh_used) {\n\t\tif(poh_freed->offset == base) {\n\t\t\tfoundNode = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tpoh_freed = poh_freed->poh_next;\n\t}\n\n\tif(!foundNode)\n\t\treturn NULL;\n\n\tmemheap->max_freesize += poh_freed->size;\n\n\tpoh_prev = poh_next = NULL;\n\tulUpper = poh_freed->offset + poh_freed->size;\n\tulLower = poh_freed->offset;\n\n\tpohThis = memheap->oh_free.poh_next;\n\n\twhile(pohThis != &memheap->oh_free) {\n\t\tif(pohThis->offset == ulUpper) {\n\t\t\tpoh_next = pohThis;\n\t\t} else if((pohThis->offset + pohThis->size) == ulLower) {\n\t\t\tpoh_prev = pohThis;\n\t\t}\n\t\tpohThis = pohThis->poh_next;\n\t}\n\n\tsisfb_delete_node(poh_freed);\n\n\tif(poh_prev && poh_next) {\n\t\tpoh_prev->size += (poh_freed->size + poh_next->size);\n\t\tsisfb_delete_node(poh_next);\n\t\tsisfb_free_node(memheap, poh_freed);\n\t\tsisfb_free_node(memheap, poh_next);\n\t\treturn poh_prev;\n\t}\n\n\tif(poh_prev) {\n\t\tpoh_prev->size += poh_freed->size;\n\t\tsisfb_free_node(memheap, poh_freed);\n\t\treturn poh_prev;\n\t}\n\n\tif(poh_next) {\n\t\tpoh_next->size += poh_freed->size;\n\t\tpoh_next->offset = poh_freed->offset;\n\t\tsisfb_free_node(memheap, poh_freed);\n\t\treturn poh_next;\n\t}\n\n\tsisfb_insert_node(&memheap->oh_free, poh_freed);\n\n\treturn poh_freed;\n}\n\nstatic void\nsisfb_free_node(struct SIS_HEAP *memheap, struct SIS_OH *poh)\n{\n\tif(poh == NULL)\n\t\treturn;\n\n\tpoh->poh_next = memheap->poh_freelist;\n\tmemheap->poh_freelist = poh;\n}\n\nstatic void\nsis_int_malloc(struct sis_video_info *ivideo, struct sis_memreq *req)\n{\n\tstruct SIS_OH *poh = NULL;\n\n\tif((ivideo) && (ivideo->sisfb_id == SISFB_ID) && (!ivideo->havenoheap))\n\t\tpoh = sisfb_poh_allocate(&ivideo->sisfb_heap, (u32)req->size);\n\n\tif(poh == NULL) {\n\t\treq->offset = req->size = 0;\n\t\tDPRINTK(\"sisfb: Video RAM allocation failed\\n\");\n\t} else {\n\t\treq->offset = poh->offset;\n\t\treq->size = poh->size;\n\t\tDPRINTK(\"sisfb: Video RAM allocation succeeded: 0x%lx\\n\",\n\t\t\t(poh->offset + ivideo->video_vbase));\n\t}\n}\n\nvoid\nsis_malloc(struct sis_memreq *req)\n{\n\tstruct sis_video_info *ivideo = sisfb_heap->vinfo;\n\n\tif(&ivideo->sisfb_heap == sisfb_heap)\n\t\tsis_int_malloc(ivideo, req);\n\telse\n\t\treq->offset = req->size = 0;\n}\n\nvoid\nsis_malloc_new(struct pci_dev *pdev, struct sis_memreq *req)\n{\n\tstruct sis_video_info *ivideo = pci_get_drvdata(pdev);\n\n\tsis_int_malloc(ivideo, req);\n}\n\n \n\nstatic void\nsis_int_free(struct sis_video_info *ivideo, u32 base)\n{\n\tstruct SIS_OH *poh;\n\n\tif((!ivideo) || (ivideo->sisfb_id != SISFB_ID) || (ivideo->havenoheap))\n\t\treturn;\n\n\tpoh = sisfb_poh_free(&ivideo->sisfb_heap, base);\n\n\tif(poh == NULL) {\n\t\tDPRINTK(\"sisfb: sisfb_poh_free() failed at base 0x%x\\n\",\n\t\t\t(unsigned int) base);\n\t}\n}\n\nvoid\nsis_free(u32 base)\n{\n\tstruct sis_video_info *ivideo = sisfb_heap->vinfo;\n\n\tsis_int_free(ivideo, base);\n}\n\nvoid\nsis_free_new(struct pci_dev *pdev, u32 base)\n{\n\tstruct sis_video_info *ivideo = pci_get_drvdata(pdev);\n\n\tsis_int_free(ivideo, base);\n}\n\n \n\nstatic void\nsisfb_check_engine_and_sync(struct sis_video_info *ivideo)\n{\n\tu8 cr30, cr31;\n\n\t \n\tcr30 = SiS_GetReg(SISSR, IND_SIS_PCI_ADDRESS_SET);\n\tcr31 = SiS_GetReg(SISSR, IND_SIS_MODULE_ENABLE);\n\t \n\tif((cr30 & SIS_MEM_MAP_IO_ENABLE) && (cr31 & 0x42)) {\n#ifdef CONFIG_FB_SIS_300\n\t\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t\t\t \n\t\t\tsisfb_syncaccel(ivideo);\n\t\t}\n#endif\n#ifdef CONFIG_FB_SIS_315\n\t\tif(ivideo->sisvga_engine == SIS_315_VGA) {\n\t\t\t \n\t\t\tcr30 = SiS_GetReg(SISSR, 0x26);\n\t\t\tif((cr30 & 0xe0) && (!(cr30 & 0x01))) {\n\t\t\t\tsisfb_syncaccel(ivideo);\n\t\t\t}\n\t\t}\n#endif\n\t}\n}\n\nstatic void\nsisfb_pre_setmode(struct sis_video_info *ivideo)\n{\n\tu8 cr30 = 0, cr31 = 0, cr33 = 0, cr35 = 0, cr38 = 0;\n\tint tvregnum = 0;\n\n\tivideo->currentvbflags &= (VB_VIDEOBRIDGE | VB_DISPTYPE_DISP2);\n\n\tSiS_SetReg(SISSR, 0x05, 0x86);\n\n\tcr31 = SiS_GetReg(SISCR, 0x31);\n\tcr31 &= ~0x60;\n\tcr31 |= 0x04;\n\n\tcr33 = ivideo->rate_idx & 0x0F;\n\n#ifdef CONFIG_FB_SIS_315\n\tif(ivideo->sisvga_engine == SIS_315_VGA) {\n\t   if(ivideo->chip >= SIS_661) {\n\t      cr38 = SiS_GetReg(SISCR, 0x38);\n\t      cr38 &= ~0x07;   \n\t   } else {\n\t      tvregnum = 0x38;\n\t      cr38 = SiS_GetReg(SISCR, tvregnum);\n\t      cr38 &= ~0x3b;   \n\t   }\n\t}\n#endif\n#ifdef CONFIG_FB_SIS_300\n\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t   tvregnum = 0x35;\n\t   cr38 = SiS_GetReg(SISCR, tvregnum);\n\t}\n#endif\n\n\tSiS_SetEnableDstn(&ivideo->SiS_Pr, false);\n\tSiS_SetEnableFstn(&ivideo->SiS_Pr, false);\n\tivideo->curFSTN = ivideo->curDSTN = 0;\n\n\tswitch(ivideo->currentvbflags & VB_DISPTYPE_DISP2) {\n\n\t   case CRT2_TV:\n\t      cr38 &= ~0xc0;    \n\t      if((ivideo->vbflags & TV_YPBPR) && (ivideo->vbflags2 & VB2_SISYPBPRBRIDGE)) {\n#ifdef CONFIG_FB_SIS_315\n\t\t if(ivideo->chip >= SIS_661) {\n\t\t    cr38 |= 0x04;\n\t\t    if(ivideo->vbflags & TV_YPBPR525P)       cr35 |= 0x20;\n\t\t    else if(ivideo->vbflags & TV_YPBPR750P)  cr35 |= 0x40;\n\t\t    else if(ivideo->vbflags & TV_YPBPR1080I) cr35 |= 0x60;\n\t\t    cr30 |= SIS_SIMULTANEOUS_VIEW_ENABLE;\n\t\t    cr35 &= ~0x01;\n\t\t    ivideo->currentvbflags |= (TV_YPBPR | (ivideo->vbflags & TV_YPBPRALL));\n\t\t } else if(ivideo->sisvga_engine == SIS_315_VGA) {\n\t\t    cr30 |= (0x80 | SIS_SIMULTANEOUS_VIEW_ENABLE);\n\t\t    cr38 |= 0x08;\n\t\t    if(ivideo->vbflags & TV_YPBPR525P)       cr38 |= 0x10;\n\t\t    else if(ivideo->vbflags & TV_YPBPR750P)  cr38 |= 0x20;\n\t\t    else if(ivideo->vbflags & TV_YPBPR1080I) cr38 |= 0x30;\n\t\t    cr31 &= ~0x01;\n\t\t    ivideo->currentvbflags |= (TV_YPBPR | (ivideo->vbflags & TV_YPBPRALL));\n\t\t }\n#endif\n\t      } else if((ivideo->vbflags & TV_HIVISION) &&\n\t\t\t\t(ivideo->vbflags2 & VB2_SISHIVISIONBRIDGE)) {\n\t\t if(ivideo->chip >= SIS_661) {\n\t\t    cr38 |= 0x04;\n\t\t    cr35 |= 0x60;\n\t\t } else {\n\t\t    cr30 |= 0x80;\n\t\t }\n\t\t cr30 |= SIS_SIMULTANEOUS_VIEW_ENABLE;\n\t\t cr31 |= 0x01;\n\t\t cr35 |= 0x01;\n\t\t ivideo->currentvbflags |= TV_HIVISION;\n\t      } else if(ivideo->vbflags & TV_SCART) {\n\t\t cr30 = (SIS_VB_OUTPUT_SCART | SIS_SIMULTANEOUS_VIEW_ENABLE);\n\t\t cr31 |= 0x01;\n\t\t cr35 |= 0x01;\n\t\t ivideo->currentvbflags |= TV_SCART;\n\t      } else {\n\t\t if(ivideo->vbflags & TV_SVIDEO) {\n\t\t    cr30 = (SIS_VB_OUTPUT_SVIDEO | SIS_SIMULTANEOUS_VIEW_ENABLE);\n\t\t    ivideo->currentvbflags |= TV_SVIDEO;\n\t\t }\n\t\t if(ivideo->vbflags & TV_AVIDEO) {\n\t\t    cr30 = (SIS_VB_OUTPUT_COMPOSITE | SIS_SIMULTANEOUS_VIEW_ENABLE);\n\t\t    ivideo->currentvbflags |= TV_AVIDEO;\n\t\t }\n\t      }\n\t      cr31 |= SIS_DRIVER_MODE;\n\n\t      if(ivideo->vbflags & (TV_AVIDEO | TV_SVIDEO)) {\n\t\t if(ivideo->vbflags & TV_PAL) {\n\t\t    cr31 |= 0x01; cr35 |= 0x01;\n\t\t    ivideo->currentvbflags |= TV_PAL;\n\t\t    if(ivideo->vbflags & TV_PALM) {\n\t\t       cr38 |= 0x40; cr35 |= 0x04;\n\t\t       ivideo->currentvbflags |= TV_PALM;\n\t\t    } else if(ivideo->vbflags & TV_PALN) {\n\t\t       cr38 |= 0x80; cr35 |= 0x08;\n\t\t       ivideo->currentvbflags |= TV_PALN;\n\t\t    }\n\t\t } else {\n\t\t    cr31 &= ~0x01; cr35 &= ~0x01;\n\t\t    ivideo->currentvbflags |= TV_NTSC;\n\t\t    if(ivideo->vbflags & TV_NTSCJ) {\n\t\t       cr38 |= 0x40; cr35 |= 0x02;\n\t\t       ivideo->currentvbflags |= TV_NTSCJ;\n\t\t    }\n\t\t }\n\t      }\n\t      break;\n\n\t   case CRT2_LCD:\n\t      cr30  = (SIS_VB_OUTPUT_LCD | SIS_SIMULTANEOUS_VIEW_ENABLE);\n\t      cr31 |= SIS_DRIVER_MODE;\n\t      SiS_SetEnableDstn(&ivideo->SiS_Pr, ivideo->sisfb_dstn);\n\t      SiS_SetEnableFstn(&ivideo->SiS_Pr, ivideo->sisfb_fstn);\n\t      ivideo->curFSTN = ivideo->sisfb_fstn;\n\t      ivideo->curDSTN = ivideo->sisfb_dstn;\n\t      break;\n\n\t   case CRT2_VGA:\n\t      cr30 = (SIS_VB_OUTPUT_CRT2 | SIS_SIMULTANEOUS_VIEW_ENABLE);\n\t      cr31 |= SIS_DRIVER_MODE;\n\t      if(ivideo->sisfb_nocrt2rate) {\n\t\t cr33 |= (sisbios_mode[ivideo->sisfb_mode_idx].rate_idx << 4);\n\t      } else {\n\t\t cr33 |= ((ivideo->rate_idx & 0x0F) << 4);\n\t      }\n\t      break;\n\n\t   default:\t \n\t      cr30 = 0x00;\n\t      cr31 |= (SIS_DRIVER_MODE | SIS_VB_OUTPUT_DISABLE);\n\t}\n\n\tSiS_SetReg(SISCR, 0x30, cr30);\n\tSiS_SetReg(SISCR, 0x33, cr33);\n\n\tif(ivideo->chip >= SIS_661) {\n#ifdef CONFIG_FB_SIS_315\n\t   cr31 &= ~0x01;                           \n\t   SiS_SetRegANDOR(SISCR, 0x35, ~0x10, cr35);  \n\t   cr38 &= 0x07;                            \n\t   SiS_SetRegANDOR(SISCR, 0x38, 0xf8, cr38);\n#endif\n\t} else if(ivideo->chip != SIS_300) {\n\t   SiS_SetReg(SISCR, tvregnum, cr38);\n\t}\n\tSiS_SetReg(SISCR, 0x31, cr31);\n\n\tivideo->SiS_Pr.SiS_UseOEM = ivideo->sisfb_useoem;\n\n\tsisfb_check_engine_and_sync(ivideo);\n}\n\n \n#ifdef CONFIG_FB_SIS_315\nstatic void\nsisfb_fixup_SR11(struct sis_video_info *ivideo)\n{\n\tu8  tmpreg;\n\n\tif(ivideo->chip >= SIS_661) {\n\t\ttmpreg = SiS_GetReg(SISSR, 0x11);\n\t\tif(tmpreg & 0x20) {\n\t\t\ttmpreg = SiS_GetReg(SISSR, 0x3e);\n\t\t\ttmpreg = (tmpreg + 1) & 0xff;\n\t\t\tSiS_SetReg(SISSR, 0x3e, tmpreg);\n\t\t\ttmpreg = SiS_GetReg(SISSR, 0x11);\n\t\t}\n\t\tif(tmpreg & 0xf0) {\n\t\t\tSiS_SetRegAND(SISSR, 0x11, 0x0f);\n\t\t}\n\t}\n}\n#endif\n\nstatic void\nsisfb_set_TVxposoffset(struct sis_video_info *ivideo, int val)\n{\n\tif(val > 32) val = 32;\n\tif(val < -32) val = -32;\n\tivideo->tvxpos = val;\n\n\tif(ivideo->sisfblocked) return;\n\tif(!ivideo->modechanged) return;\n\n\tif(ivideo->currentvbflags & CRT2_TV) {\n\n\t\tif(ivideo->vbflags2 & VB2_CHRONTEL) {\n\n\t\t\tint x = ivideo->tvx;\n\n\t\t\tswitch(ivideo->chronteltype) {\n\t\t\tcase 1:\n\t\t\t\tx += val;\n\t\t\t\tif(x < 0) x = 0;\n\t\t\t\tSiS_SetReg(SISSR, 0x05, 0x86);\n\t\t\t\tSiS_SetCH700x(&ivideo->SiS_Pr, 0x0a, (x & 0xff));\n\t\t\t\tSiS_SetCH70xxANDOR(&ivideo->SiS_Pr, 0x08, ((x & 0x0100) >> 7), 0xFD);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else if(ivideo->vbflags2 & VB2_SISBRIDGE) {\n\n\t\t\tu8 p2_1f,p2_20,p2_2b,p2_42,p2_43;\n\t\t\tunsigned short temp;\n\n\t\t\tp2_1f = ivideo->p2_1f;\n\t\t\tp2_20 = ivideo->p2_20;\n\t\t\tp2_2b = ivideo->p2_2b;\n\t\t\tp2_42 = ivideo->p2_42;\n\t\t\tp2_43 = ivideo->p2_43;\n\n\t\t\ttemp = p2_1f | ((p2_20 & 0xf0) << 4);\n\t\t\ttemp += (val * 2);\n\t\t\tp2_1f = temp & 0xff;\n\t\t\tp2_20 = (temp & 0xf00) >> 4;\n\t\t\tp2_2b = ((p2_2b & 0x0f) + (val * 2)) & 0x0f;\n\t\t\ttemp = p2_43 | ((p2_42 & 0xf0) << 4);\n\t\t\ttemp += (val * 2);\n\t\t\tp2_43 = temp & 0xff;\n\t\t\tp2_42 = (temp & 0xf00) >> 4;\n\t\t\tSiS_SetReg(SISPART2, 0x1f, p2_1f);\n\t\t\tSiS_SetRegANDOR(SISPART2, 0x20, 0x0F, p2_20);\n\t\t\tSiS_SetRegANDOR(SISPART2, 0x2b, 0xF0, p2_2b);\n\t\t\tSiS_SetRegANDOR(SISPART2, 0x42, 0x0F, p2_42);\n\t\t\tSiS_SetReg(SISPART2, 0x43, p2_43);\n\t\t}\n\t}\n}\n\nstatic void\nsisfb_set_TVyposoffset(struct sis_video_info *ivideo, int val)\n{\n\tif(val > 32) val = 32;\n\tif(val < -32) val = -32;\n\tivideo->tvypos = val;\n\n\tif(ivideo->sisfblocked) return;\n\tif(!ivideo->modechanged) return;\n\n\tif(ivideo->currentvbflags & CRT2_TV) {\n\n\t\tif(ivideo->vbflags2 & VB2_CHRONTEL) {\n\n\t\t\tint y = ivideo->tvy;\n\n\t\t\tswitch(ivideo->chronteltype) {\n\t\t\tcase 1:\n\t\t\t\ty -= val;\n\t\t\t\tif(y < 0) y = 0;\n\t\t\t\tSiS_SetReg(SISSR, 0x05, 0x86);\n\t\t\t\tSiS_SetCH700x(&ivideo->SiS_Pr, 0x0b, (y & 0xff));\n\t\t\t\tSiS_SetCH70xxANDOR(&ivideo->SiS_Pr, 0x08, ((y & 0x0100) >> 8), 0xFE);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else if(ivideo->vbflags2 & VB2_SISBRIDGE) {\n\n\t\t\tchar p2_01, p2_02;\n\t\t\tval /= 2;\n\t\t\tp2_01 = ivideo->p2_01;\n\t\t\tp2_02 = ivideo->p2_02;\n\n\t\t\tp2_01 += val;\n\t\t\tp2_02 += val;\n\t\t\tif(!(ivideo->currentvbflags & (TV_HIVISION | TV_YPBPR))) {\n\t\t\t\twhile((p2_01 <= 0) || (p2_02 <= 0)) {\n\t\t\t\t\tp2_01 += 2;\n\t\t\t\t\tp2_02 += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSiS_SetReg(SISPART2, 0x01, p2_01);\n\t\t\tSiS_SetReg(SISPART2, 0x02, p2_02);\n\t\t}\n\t}\n}\n\nstatic void\nsisfb_post_setmode(struct sis_video_info *ivideo)\n{\n\tbool crt1isoff = false;\n\tbool doit = true;\n#if defined(CONFIG_FB_SIS_300) || defined(CONFIG_FB_SIS_315)\n\tu8 reg;\n#endif\n#ifdef CONFIG_FB_SIS_315\n\tu8 reg1;\n#endif\n\n\tSiS_SetReg(SISSR, 0x05, 0x86);\n\n#ifdef CONFIG_FB_SIS_315\n\tsisfb_fixup_SR11(ivideo);\n#endif\n\n\t \n\tivideo->modechanged = 1;\n\n\t \n\tif(ivideo->vbflags2 & VB2_VIDEOBRIDGE) {\n\t\tif(sisfb_bridgeisslave(ivideo)) doit = false;\n\t} else\n\t\tivideo->sisfb_crt1off = 0;\n\n#ifdef CONFIG_FB_SIS_300\n\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t\tif((ivideo->sisfb_crt1off) && (doit)) {\n\t\t\tcrt1isoff = true;\n\t\t\treg = 0x00;\n\t\t} else {\n\t\t\tcrt1isoff = false;\n\t\t\treg = 0x80;\n\t\t}\n\t\tSiS_SetRegANDOR(SISCR, 0x17, 0x7f, reg);\n\t}\n#endif\n#ifdef CONFIG_FB_SIS_315\n\tif(ivideo->sisvga_engine == SIS_315_VGA) {\n\t\tif((ivideo->sisfb_crt1off) && (doit)) {\n\t\t\tcrt1isoff = true;\n\t\t\treg  = 0x40;\n\t\t\treg1 = 0xc0;\n\t\t} else {\n\t\t\tcrt1isoff = false;\n\t\t\treg  = 0x00;\n\t\t\treg1 = 0x00;\n\t\t}\n\t\tSiS_SetRegANDOR(SISCR, ivideo->SiS_Pr.SiS_MyCR63, ~0x40, reg);\n\t\tSiS_SetRegANDOR(SISSR, 0x1f, 0x3f, reg1);\n\t}\n#endif\n\n\tif(crt1isoff) {\n\t\tivideo->currentvbflags &= ~VB_DISPTYPE_CRT1;\n\t\tivideo->currentvbflags |= VB_SINGLE_MODE;\n\t} else {\n\t\tivideo->currentvbflags |= VB_DISPTYPE_CRT1;\n\t\tif(ivideo->currentvbflags & VB_DISPTYPE_CRT2) {\n\t\t\tivideo->currentvbflags |= VB_MIRROR_MODE;\n\t\t} else {\n\t\t\tivideo->currentvbflags |= VB_SINGLE_MODE;\n\t\t}\n\t}\n\n\tSiS_SetRegAND(SISSR, IND_SIS_RAMDAC_CONTROL, ~0x04);\n\n\tif(ivideo->currentvbflags & CRT2_TV) {\n\t\tif(ivideo->vbflags2 & VB2_SISBRIDGE) {\n\t\t\tivideo->p2_1f = SiS_GetReg(SISPART2, 0x1f);\n\t\t\tivideo->p2_20 = SiS_GetReg(SISPART2, 0x20);\n\t\t\tivideo->p2_2b = SiS_GetReg(SISPART2, 0x2b);\n\t\t\tivideo->p2_42 = SiS_GetReg(SISPART2, 0x42);\n\t\t\tivideo->p2_43 = SiS_GetReg(SISPART2, 0x43);\n\t\t\tivideo->p2_01 = SiS_GetReg(SISPART2, 0x01);\n\t\t\tivideo->p2_02 = SiS_GetReg(SISPART2, 0x02);\n\t\t} else if(ivideo->vbflags2 & VB2_CHRONTEL) {\n\t\t\tif(ivideo->chronteltype == 1) {\n\t\t\t\tivideo->tvx = SiS_GetCH700x(&ivideo->SiS_Pr, 0x0a);\n\t\t\t\tivideo->tvx |= (((SiS_GetCH700x(&ivideo->SiS_Pr, 0x08) & 0x02) >> 1) << 8);\n\t\t\t\tivideo->tvy = SiS_GetCH700x(&ivideo->SiS_Pr, 0x0b);\n\t\t\t\tivideo->tvy |= ((SiS_GetCH700x(&ivideo->SiS_Pr, 0x08) & 0x01) << 8);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(ivideo->tvxpos) {\n\t\tsisfb_set_TVxposoffset(ivideo, ivideo->tvxpos);\n\t}\n\tif(ivideo->tvypos) {\n\t\tsisfb_set_TVyposoffset(ivideo, ivideo->tvypos);\n\t}\n\n\t \n\tsisfb_check_engine_and_sync(ivideo);\n\n\t \n\tif(ivideo->accel) {\n\t\tsisfb_engine_init(ivideo);\n\t} else {\n\t\tivideo->engineok = 0;\n\t}\n}\n\nstatic int\nsisfb_reset_mode(struct sis_video_info *ivideo)\n{\n\tif(sisfb_set_mode(ivideo, 0))\n\t\treturn 1;\n\n\tsisfb_set_pitch(ivideo);\n\tsisfb_set_base_CRT1(ivideo, ivideo->current_base);\n\tsisfb_set_base_CRT2(ivideo, ivideo->current_base);\n\n\treturn 0;\n}\n\nstatic void\nsisfb_handle_command(struct sis_video_info *ivideo, struct sisfb_cmd *sisfb_command)\n{\n\tint mycrt1off;\n\n\tswitch(sisfb_command->sisfb_cmd) {\n\tcase SISFB_CMD_GETVBFLAGS:\n\t\tif(!ivideo->modechanged) {\n\t\t\tsisfb_command->sisfb_result[0] = SISFB_CMD_ERR_EARLY;\n\t\t} else {\n\t\t\tsisfb_command->sisfb_result[0] = SISFB_CMD_ERR_OK;\n\t\t\tsisfb_command->sisfb_result[1] = ivideo->currentvbflags;\n\t\t\tsisfb_command->sisfb_result[2] = ivideo->vbflags2;\n\t\t}\n\t\tbreak;\n\tcase SISFB_CMD_SWITCHCRT1:\n\t\t \n\t\tif(!ivideo->modechanged) {\n\t\t\tsisfb_command->sisfb_result[0] = SISFB_CMD_ERR_EARLY;\n\t\t} else if(sisfb_command->sisfb_arg[0] == 99) {\n\t\t\t \n\t\t\tsisfb_command->sisfb_result[1] = ivideo->sisfb_crt1off ? 0 : 1;\n\t\t\tsisfb_command->sisfb_result[0] = SISFB_CMD_ERR_OK;\n\t\t} else if(ivideo->sisfblocked) {\n\t\t\tsisfb_command->sisfb_result[0] = SISFB_CMD_ERR_LOCKED;\n\t\t} else if((!(ivideo->currentvbflags & CRT2_ENABLE)) &&\n\t\t\t\t\t(sisfb_command->sisfb_arg[0] == 0)) {\n\t\t\tsisfb_command->sisfb_result[0] = SISFB_CMD_ERR_NOCRT2;\n\t\t} else {\n\t\t\tsisfb_command->sisfb_result[0] = SISFB_CMD_ERR_OK;\n\t\t\tmycrt1off = sisfb_command->sisfb_arg[0] ? 0 : 1;\n\t\t\tif( ((ivideo->currentvbflags & VB_DISPTYPE_CRT1) && mycrt1off) ||\n\t\t\t    ((!(ivideo->currentvbflags & VB_DISPTYPE_CRT1)) && !mycrt1off) ) {\n\t\t\t\tivideo->sisfb_crt1off = mycrt1off;\n\t\t\t\tif(sisfb_reset_mode(ivideo)) {\n\t\t\t\t\tsisfb_command->sisfb_result[0] = SISFB_CMD_ERR_OTHER;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsisfb_command->sisfb_result[1] = ivideo->sisfb_crt1off ? 0 : 1;\n\t\t}\n\t\tbreak;\n\t \n\tdefault:\n\t\tsisfb_command->sisfb_result[0] = SISFB_CMD_ERR_UNKNOWN;\n\t\tprintk(KERN_ERR \"sisfb: Unknown command 0x%x\\n\",\n\t\t\tsisfb_command->sisfb_cmd);\n\t}\n}\n\n#ifndef MODULE\nstatic int __init sisfb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tsisfb_setdefaultparms();\n\n\tif(!options || !(*options))\n\t\treturn 0;\n\n\twhile((this_opt = strsep(&options, \",\")) != NULL) {\n\n\t\tif(!(*this_opt)) continue;\n\n\t\tif(!strncasecmp(this_opt, \"off\", 3)) {\n\t\t\tsisfb_off = 1;\n\t\t} else if(!strncasecmp(this_opt, \"forcecrt2type:\", 14)) {\n\t\t\t \n\t\t\tsisfb_search_crt2type(this_opt + 14);\n\t\t} else if(!strncasecmp(this_opt, \"tvmode:\",7)) {\n\t\t\tsisfb_search_tvstd(this_opt + 7);\n\t\t} else if(!strncasecmp(this_opt, \"tvstandard:\",11)) {\n\t\t\tsisfb_search_tvstd(this_opt + 11);\n\t\t} else if(!strncasecmp(this_opt, \"mode:\", 5)) {\n\t\t\tsisfb_search_mode(this_opt + 5, false);\n\t\t} else if(!strncasecmp(this_opt, \"vesa:\", 5)) {\n\t\t\tsisfb_search_vesamode(simple_strtoul(this_opt + 5, NULL, 0), false);\n\t\t} else if(!strncasecmp(this_opt, \"rate:\", 5)) {\n\t\t\tsisfb_parm_rate = simple_strtoul(this_opt + 5, NULL, 0);\n\t\t} else if(!strncasecmp(this_opt, \"forcecrt1:\", 10)) {\n\t\t\tsisfb_forcecrt1 = (int)simple_strtoul(this_opt + 10, NULL, 0);\n\t\t} else if(!strncasecmp(this_opt, \"mem:\",4)) {\n\t\t\tsisfb_parm_mem = simple_strtoul(this_opt + 4, NULL, 0);\n\t\t} else if(!strncasecmp(this_opt, \"pdc:\", 4)) {\n\t\t\tsisfb_pdc = simple_strtoul(this_opt + 4, NULL, 0);\n\t\t} else if(!strncasecmp(this_opt, \"pdc1:\", 5)) {\n\t\t\tsisfb_pdca = simple_strtoul(this_opt + 5, NULL, 0);\n\t\t} else if(!strncasecmp(this_opt, \"noaccel\", 7)) {\n\t\t\tsisfb_accel = 0;\n\t\t} else if(!strncasecmp(this_opt, \"accel\", 5)) {\n\t\t\tsisfb_accel = -1;\n\t\t} else if(!strncasecmp(this_opt, \"noypan\", 6)) {\n\t\t\tsisfb_ypan = 0;\n\t\t} else if(!strncasecmp(this_opt, \"ypan\", 4)) {\n\t\t\tsisfb_ypan = -1;\n\t\t} else if(!strncasecmp(this_opt, \"nomax\", 5)) {\n\t\t\tsisfb_max = 0;\n\t\t} else if(!strncasecmp(this_opt, \"max\", 3)) {\n\t\t\tsisfb_max = -1;\n\t\t} else if(!strncasecmp(this_opt, \"userom:\", 7)) {\n\t\t\tsisfb_userom = (int)simple_strtoul(this_opt + 7, NULL, 0);\n\t\t} else if(!strncasecmp(this_opt, \"useoem:\", 7)) {\n\t\t\tsisfb_useoem = (int)simple_strtoul(this_opt + 7, NULL, 0);\n\t\t} else if(!strncasecmp(this_opt, \"nocrt2rate\", 10)) {\n\t\t\tsisfb_nocrt2rate = 1;\n\t\t} else if(!strncasecmp(this_opt, \"scalelcd:\", 9)) {\n\t\t\tunsigned long temp = 2;\n\t\t\ttemp = simple_strtoul(this_opt + 9, NULL, 0);\n\t\t\tif((temp == 0) || (temp == 1)) {\n\t\t\t   sisfb_scalelcd = temp ^ 1;\n\t\t\t}\n\t\t} else if(!strncasecmp(this_opt, \"tvxposoffset:\", 13)) {\n\t\t\tint temp = 0;\n\t\t\ttemp = (int)simple_strtol(this_opt + 13, NULL, 0);\n\t\t\tif((temp >= -32) && (temp <= 32)) {\n\t\t\t   sisfb_tvxposoffset = temp;\n\t\t\t}\n\t\t} else if(!strncasecmp(this_opt, \"tvyposoffset:\", 13)) {\n\t\t\tint temp = 0;\n\t\t\ttemp = (int)simple_strtol(this_opt + 13, NULL, 0);\n\t\t\tif((temp >= -32) && (temp <= 32)) {\n\t\t\t   sisfb_tvyposoffset = temp;\n\t\t\t}\n\t\t} else if(!strncasecmp(this_opt, \"specialtiming:\", 14)) {\n\t\t\tsisfb_search_specialtiming(this_opt + 14);\n\t\t} else if(!strncasecmp(this_opt, \"lvdshl:\", 7)) {\n\t\t\tint temp = 4;\n\t\t\ttemp = simple_strtoul(this_opt + 7, NULL, 0);\n\t\t\tif((temp >= 0) && (temp <= 3)) {\n\t\t\t   sisfb_lvdshl = temp;\n\t\t\t}\n\t\t} else if(this_opt[0] >= '0' && this_opt[0] <= '9') {\n\t\t\tsisfb_search_mode(this_opt, true);\n#if !defined(__i386__) && !defined(__x86_64__)\n\t\t} else if(!strncasecmp(this_opt, \"resetcard\", 9)) {\n\t\t\tsisfb_resetcard = 1;\n\t        } else if(!strncasecmp(this_opt, \"videoram:\", 9)) {\n\t\t\tsisfb_videoram = simple_strtoul(this_opt + 9, NULL, 0);\n#endif\n\t\t} else {\n\t\t\tprintk(KERN_INFO \"sisfb: Invalid option %s\\n\", this_opt);\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int sisfb_check_rom(void __iomem *rom_base,\n\t\t\t   struct sis_video_info *ivideo)\n{\n\tvoid __iomem *rom;\n\tint romptr;\n\n\tif((readb(rom_base) != 0x55) || (readb(rom_base + 1) != 0xaa))\n\t\treturn 0;\n\n\tromptr = (readb(rom_base + 0x18) | (readb(rom_base + 0x19) << 8));\n\tif(romptr > (0x10000 - 8))\n\t\treturn 0;\n\n\trom = rom_base + romptr;\n\n\tif((readb(rom)     != 'P') || (readb(rom + 1) != 'C') ||\n\t   (readb(rom + 2) != 'I') || (readb(rom + 3) != 'R'))\n\t\treturn 0;\n\n\tif((readb(rom + 4) | (readb(rom + 5) << 8)) != ivideo->chip_vendor)\n\t\treturn 0;\n\n\tif((readb(rom + 6) | (readb(rom + 7) << 8)) != ivideo->chip_id)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic unsigned char *sisfb_find_rom(struct pci_dev *pdev)\n{\n\tstruct sis_video_info *ivideo = pci_get_drvdata(pdev);\n\tvoid __iomem *rom_base;\n\tunsigned char *myrombase = NULL;\n\tsize_t romsize;\n\n\t \n\n\tif(!ivideo->nbridge) {\n\n\t\tif((rom_base = pci_map_rom(pdev, &romsize))) {\n\n\t\t\tif(sisfb_check_rom(rom_base, ivideo)) {\n\n\t\t\t\tif((myrombase = vmalloc(65536))) {\n\t\t\t\t\tmemcpy_fromio(myrombase, rom_base,\n\t\t\t\t\t\t\t(romsize > 65536) ? 65536 : romsize);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, rom_base);\n\t\t}\n\t}\n\n\tif(myrombase) return myrombase;\n\n\t \n\n#if defined(__i386__) || defined(__x86_64__)\n\t{\n\t\tu32 temp;\n\n\t\tfor (temp = 0x000c0000; temp < 0x000f0000; temp += 0x00001000) {\n\n\t\t\trom_base = ioremap(temp, 65536);\n\t\t\tif (!rom_base)\n\t\t\t\tcontinue;\n\n\t\t\tif (!sisfb_check_rom(rom_base, ivideo)) {\n\t\t\t\tiounmap(rom_base);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((myrombase = vmalloc(65536)))\n\t\t\t\tmemcpy_fromio(myrombase, rom_base, 65536);\n\n\t\t\tiounmap(rom_base);\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n#endif\n\n\treturn myrombase;\n}\n\nstatic void sisfb_post_map_vram(struct sis_video_info *ivideo,\n\t\t\t\tunsigned int *mapsize, unsigned int min)\n{\n\tif (*mapsize < (min << 20))\n\t\treturn;\n\n\tivideo->video_vbase = ioremap_wc(ivideo->video_base, (*mapsize));\n\n\tif(!ivideo->video_vbase) {\n\t\tprintk(KERN_ERR\n\t\t\t\"sisfb: Unable to map maximum video RAM for size detection\\n\");\n\t\t(*mapsize) >>= 1;\n\t\twhile((!(ivideo->video_vbase = ioremap_wc(ivideo->video_base, (*mapsize))))) {\n\t\t\t(*mapsize) >>= 1;\n\t\t\tif((*mapsize) < (min << 20))\n\t\t\t\tbreak;\n\t\t}\n\t\tif(ivideo->video_vbase) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"sisfb: Video RAM size detection limited to %dMB\\n\",\n\t\t\t\t(int)((*mapsize) >> 20));\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_FB_SIS_300\nstatic int sisfb_post_300_buswidth(struct sis_video_info *ivideo)\n{\n\tvoid __iomem *FBAddress = ivideo->video_vbase;\n\tunsigned short temp;\n\tunsigned char reg;\n\tint i, j;\n\n\tSiS_SetRegAND(SISSR, 0x15, 0xFB);\n\tSiS_SetRegOR(SISSR, 0x15, 0x04);\n\tSiS_SetReg(SISSR, 0x13, 0x00);\n\tSiS_SetReg(SISSR, 0x14, 0xBF);\n\n\tfor(i = 0; i < 2; i++) {\n\t\ttemp = 0x1234;\n\t\tfor(j = 0; j < 4; j++) {\n\t\t\twritew(temp, FBAddress);\n\t\t\tif(readw(FBAddress) == temp)\n\t\t\t\tbreak;\n\t\t\tSiS_SetRegOR(SISSR, 0x3c, 0x01);\n\t\t\treg = SiS_GetReg(SISSR, 0x05);\n\t\t\treg = SiS_GetReg(SISSR, 0x05);\n\t\t\tSiS_SetRegAND(SISSR, 0x3c, 0xfe);\n\t\t\treg = SiS_GetReg(SISSR, 0x05);\n\t\t\treg = SiS_GetReg(SISSR, 0x05);\n\t\t\ttemp++;\n\t\t}\n\t}\n\n\twritel(0x01234567L, FBAddress);\n\twritel(0x456789ABL, (FBAddress + 4));\n\twritel(0x89ABCDEFL, (FBAddress + 8));\n\twritel(0xCDEF0123L, (FBAddress + 12));\n\n\treg = SiS_GetReg(SISSR, 0x3b);\n\tif(reg & 0x01) {\n\t\tif(readl((FBAddress + 12)) == 0xCDEF0123L)\n\t\t\treturn 4;\t \n\t}\n\n\tif(readl((FBAddress + 4)) == 0x456789ABL)\n\t\treturn 2;\t\t \n\n\treturn 1;\t\t\t \n}\n\nstatic const unsigned short SiS_DRAMType[17][5] = {\n\t{0x0C,0x0A,0x02,0x40,0x39},\n\t{0x0D,0x0A,0x01,0x40,0x48},\n\t{0x0C,0x09,0x02,0x20,0x35},\n\t{0x0D,0x09,0x01,0x20,0x44},\n\t{0x0C,0x08,0x02,0x10,0x31},\n\t{0x0D,0x08,0x01,0x10,0x40},\n\t{0x0C,0x0A,0x01,0x20,0x34},\n\t{0x0C,0x09,0x01,0x08,0x32},\n\t{0x0B,0x08,0x02,0x08,0x21},\n\t{0x0C,0x08,0x01,0x08,0x30},\n\t{0x0A,0x08,0x02,0x04,0x11},\n\t{0x0B,0x0A,0x01,0x10,0x28},\n\t{0x09,0x08,0x02,0x02,0x01},\n\t{0x0B,0x09,0x01,0x08,0x24},\n\t{0x0B,0x08,0x01,0x04,0x20},\n\t{0x0A,0x08,0x01,0x02,0x10},\n\t{0x09,0x08,0x01,0x01,0x00}\n};\n\nstatic int sisfb_post_300_rwtest(struct sis_video_info *ivideo, int iteration,\n\t\t\t\t int buswidth, int PseudoRankCapacity,\n\t\t\t\t int PseudoAdrPinCount, unsigned int mapsize)\n{\n\tvoid __iomem *FBAddr = ivideo->video_vbase;\n\tunsigned short sr14;\n\tunsigned int k, RankCapacity, PageCapacity, BankNumHigh, BankNumMid;\n\tunsigned int PhysicalAdrOtherPage, PhysicalAdrHigh, PhysicalAdrHalfPage;\n\n\tfor (k = 0; k < ARRAY_SIZE(SiS_DRAMType); k++) {\n\t\tRankCapacity = buswidth * SiS_DRAMType[k][3];\n\n\t\tif (RankCapacity != PseudoRankCapacity)\n\t\t\tcontinue;\n\n\t\tif ((SiS_DRAMType[k][2] + SiS_DRAMType[k][0]) > PseudoAdrPinCount)\n\t\t\tcontinue;\n\n\t\tBankNumHigh = RankCapacity * 16 * iteration - 1;\n\t\tif (iteration == 3) {              \n\t\t\tBankNumMid  = RankCapacity * 16 - 1;\n\t\t} else {\n\t\t\tBankNumMid  = RankCapacity * 16 * iteration / 2 - 1;\n\t\t}\n\n\t\tPageCapacity = (1 << SiS_DRAMType[k][1]) * buswidth * 4;\n\t\tPhysicalAdrHigh = BankNumHigh;\n\t\tPhysicalAdrHalfPage = (PageCapacity / 2 + PhysicalAdrHigh) % PageCapacity;\n\t\tPhysicalAdrOtherPage = PageCapacity * SiS_DRAMType[k][2] + PhysicalAdrHigh;\n\n\t\tSiS_SetRegAND(SISSR, 0x15, 0xFB);  \n\t\tSiS_SetRegOR(SISSR, 0x15, 0x04);   \n\t\tsr14 = (SiS_DRAMType[k][3] * buswidth) - 1;\n\n\t\tif (buswidth == 4)\n\t\t\tsr14 |= 0x80;\n\t\telse if (buswidth == 2)\n\t\t\tsr14 |= 0x40;\n\n\t\tSiS_SetReg(SISSR, 0x13, SiS_DRAMType[k][4]);\n\t\tSiS_SetReg(SISSR, 0x14, sr14);\n\n\t\tBankNumHigh <<= 16;\n\t\tBankNumMid <<= 16;\n\n\t\tif ((BankNumHigh + PhysicalAdrHigh >= mapsize) ||\n\t\t    (BankNumMid  + PhysicalAdrHigh >= mapsize) ||\n\t\t    (BankNumHigh + PhysicalAdrHalfPage  >= mapsize) ||\n\t\t    (BankNumHigh + PhysicalAdrOtherPage >= mapsize))\n\t\t\tcontinue;\n\n\t\t \n\t\twritew(((unsigned short)PhysicalAdrHigh),\n\t\t\t\t(FBAddr + BankNumHigh + PhysicalAdrHigh));\n\t\twritew(((unsigned short)BankNumMid),\n\t\t\t\t(FBAddr + BankNumMid  + PhysicalAdrHigh));\n\t\twritew(((unsigned short)PhysicalAdrHalfPage),\n\t\t\t\t(FBAddr + BankNumHigh + PhysicalAdrHalfPage));\n\t\twritew(((unsigned short)PhysicalAdrOtherPage),\n\t\t\t\t(FBAddr + BankNumHigh + PhysicalAdrOtherPage));\n\n\t\t \n\t\tif (readw(FBAddr + BankNumHigh + PhysicalAdrHigh) == PhysicalAdrHigh)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void sisfb_post_300_ramsize(struct pci_dev *pdev, unsigned int mapsize)\n{\n\tstruct\tsis_video_info *ivideo = pci_get_drvdata(pdev);\n\tint\ti, j, buswidth;\n\tint\tPseudoRankCapacity, PseudoAdrPinCount;\n\n\tbuswidth = sisfb_post_300_buswidth(ivideo);\n\n\tfor(i = 6; i >= 0; i--) {\n\t\tPseudoRankCapacity = 1 << i;\n\t\tfor(j = 4; j >= 1; j--) {\n\t\t\tPseudoAdrPinCount = 15 - j;\n\t\t\tif((PseudoRankCapacity * j) <= 64) {\n\t\t\t\tif(sisfb_post_300_rwtest(ivideo,\n\t\t\t\t\t\tj,\n\t\t\t\t\t\tbuswidth,\n\t\t\t\t\t\tPseudoRankCapacity,\n\t\t\t\t\t\tPseudoAdrPinCount,\n\t\t\t\t\t\tmapsize))\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void sisfb_post_sis300(struct pci_dev *pdev)\n{\n\tstruct sis_video_info *ivideo = pci_get_drvdata(pdev);\n\tunsigned char *bios = ivideo->SiS_Pr.VirtualRomBase;\n\tu8  reg, v1, v2, v3, v4, v5, v6, v7, v8;\n\tu16 index, rindex, memtype = 0;\n\tunsigned int mapsize;\n\n\tif(!ivideo->SiS_Pr.UseROM)\n\t\tbios = NULL;\n\n\tSiS_SetReg(SISSR, 0x05, 0x86);\n\n\tif(bios) {\n\t\tif(bios[0x52] & 0x80) {\n\t\t\tmemtype = bios[0x52];\n\t\t} else {\n\t\t\tmemtype = SiS_GetReg(SISSR, 0x3a);\n\t\t}\n\t\tmemtype &= 0x07;\n\t}\n\n\tv3 = 0x80; v6 = 0x80;\n\tif(ivideo->revision_id <= 0x13) {\n\t\tv1 = 0x44; v2 = 0x42;\n\t\tv4 = 0x44; v5 = 0x42;\n\t} else {\n\t\tv1 = 0x68; v2 = 0x43;  \n\t\tv4 = 0x68; v5 = 0x43;  \n\t\tif(bios) {\n\t\t\tindex = memtype * 5;\n\t\t\trindex = index + 0x54;\n\t\t\tv1 = bios[rindex++];\n\t\t\tv2 = bios[rindex++];\n\t\t\tv3 = bios[rindex++];\n\t\t\trindex = index + 0x7c;\n\t\t\tv4 = bios[rindex++];\n\t\t\tv5 = bios[rindex++];\n\t\t\tv6 = bios[rindex++];\n\t\t}\n\t}\n\tSiS_SetReg(SISSR, 0x28, v1);\n\tSiS_SetReg(SISSR, 0x29, v2);\n\tSiS_SetReg(SISSR, 0x2a, v3);\n\tSiS_SetReg(SISSR, 0x2e, v4);\n\tSiS_SetReg(SISSR, 0x2f, v5);\n\tSiS_SetReg(SISSR, 0x30, v6);\n\n\tv1 = 0x10;\n\tif(bios)\n\t\tv1 = bios[0xa4];\n\tSiS_SetReg(SISSR, 0x07, v1);        \n\n\tSiS_SetReg(SISSR, 0x11, 0x0f);      \n\n\tv1 = 0x01; v2 = 0x43; v3 = 0x1e; v4 = 0x2a;\n\tv5 = 0x06; v6 = 0x00; v7 = 0x00; v8 = 0x00;\n\tif(bios) {\n\t\tmemtype += 0xa5;\n\t\tv1 = bios[memtype];\n\t\tv2 = bios[memtype + 8];\n\t\tv3 = bios[memtype + 16];\n\t\tv4 = bios[memtype + 24];\n\t\tv5 = bios[memtype + 32];\n\t\tv6 = bios[memtype + 40];\n\t\tv7 = bios[memtype + 48];\n\t\tv8 = bios[memtype + 56];\n\t}\n\tif(ivideo->revision_id >= 0x80)\n\t\tv3 &= 0xfd;\n\tSiS_SetReg(SISSR, 0x15, v1);        \n\tSiS_SetReg(SISSR, 0x16, v2);\n\tSiS_SetReg(SISSR, 0x17, v3);\n\tSiS_SetReg(SISSR, 0x18, v4);\n\tSiS_SetReg(SISSR, 0x19, v5);\n\tSiS_SetReg(SISSR, 0x1a, v6);\n\tSiS_SetReg(SISSR, 0x1b, v7);\n\tSiS_SetReg(SISSR, 0x1c, v8);\t    \n\tSiS_SetRegAND(SISSR, 0x15, 0xfb);\n\tSiS_SetRegOR(SISSR, 0x15, 0x04);\n\tif(bios) {\n\t\tif(bios[0x53] & 0x02) {\n\t\t\tSiS_SetRegOR(SISSR, 0x19, 0x20);\n\t\t}\n\t}\n\tv1 = 0x04;\t\t\t    \n\tif(ivideo->revision_id >= 0x80)\n\t\tv1 |= 0x01;\n\tSiS_SetReg(SISSR, 0x1f, v1);\n\tSiS_SetReg(SISSR, 0x20, 0xa4);      \n\tv1 = 0xf6; v2 = 0x0d; v3 = 0x00;\n\tif(bios) {\n\t\tv1 = bios[0xe8];\n\t\tv2 = bios[0xe9];\n\t\tv3 = bios[0xea];\n\t}\n\tSiS_SetReg(SISSR, 0x23, v1);\n\tSiS_SetReg(SISSR, 0x24, v2);\n\tSiS_SetReg(SISSR, 0x25, v3);\n\tSiS_SetReg(SISSR, 0x21, 0x84);\n\tSiS_SetReg(SISSR, 0x22, 0x00);\n\tSiS_SetReg(SISCR, 0x37, 0x00);\n\tSiS_SetRegOR(SISPART1, 0x24, 0x01);    \n\tSiS_SetReg(SISPART1, 0x00, 0x00);\n\tv1 = 0x40; v2 = 0x11;\n\tif(bios) {\n\t\tv1 = bios[0xec];\n\t\tv2 = bios[0xeb];\n\t}\n\tSiS_SetReg(SISPART1, 0x02, v1);\n\n\tif(ivideo->revision_id >= 0x80)\n\t\tv2 &= ~0x01;\n\n\treg = SiS_GetReg(SISPART4, 0x00);\n\tif((reg == 1) || (reg == 2)) {\n\t\tSiS_SetReg(SISCR, 0x37, 0x02);\n\t\tSiS_SetReg(SISPART2, 0x00, 0x1c);\n\t\tv4 = 0x00; v5 = 0x00; v6 = 0x10;\n\t\tif (ivideo->SiS_Pr.UseROM && bios) {\n\t\t\tv4 = bios[0xf5];\n\t\t\tv5 = bios[0xf6];\n\t\t\tv6 = bios[0xf7];\n\t\t}\n\t\tSiS_SetReg(SISPART4, 0x0d, v4);\n\t\tSiS_SetReg(SISPART4, 0x0e, v5);\n\t\tSiS_SetReg(SISPART4, 0x10, v6);\n\t\tSiS_SetReg(SISPART4, 0x0f, 0x3f);\n\t\treg = SiS_GetReg(SISPART4, 0x01);\n\t\tif(reg >= 0xb0) {\n\t\t\treg = SiS_GetReg(SISPART4, 0x23);\n\t\t\treg &= 0x20;\n\t\t\treg <<= 1;\n\t\t\tSiS_SetReg(SISPART4, 0x23, reg);\n\t\t}\n\t} else {\n\t\tv2 &= ~0x10;\n\t}\n\tSiS_SetReg(SISSR, 0x32, v2);\n\n\tSiS_SetRegAND(SISPART1, 0x24, 0xfe);   \n\n\treg = SiS_GetReg(SISSR, 0x16);\n\treg &= 0xc3;\n\tSiS_SetReg(SISCR, 0x35, reg);\n\tSiS_SetReg(SISCR, 0x83, 0x00);\n#if !defined(__i386__) && !defined(__x86_64__)\n\tif(sisfb_videoram) {\n\t\tSiS_SetReg(SISSR, 0x13, 0x28);   \n\t\treg = ((sisfb_videoram >> 10) - 1) | 0x40;\n\t\tSiS_SetReg(SISSR, 0x14, reg);\n\t} else {\n#endif\n\t\t \n\t\tmapsize = ivideo->video_size;\n\t\tsisfb_post_map_vram(ivideo, &mapsize, 4);\n\n\t\tif(ivideo->video_vbase) {\n\t\t\tsisfb_post_300_ramsize(pdev, mapsize);\n\t\t\tiounmap(ivideo->video_vbase);\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"sisfb: Failed to map memory for size detection, assuming 8MB\\n\");\n\t\t\tSiS_SetReg(SISSR, 0x13, 0x28);   \n\t\t\tSiS_SetReg(SISSR, 0x14, 0x47);   \n\t\t}\n#if !defined(__i386__) && !defined(__x86_64__)\n\t}\n#endif\n\tif(bios) {\n\t\tv1 = bios[0xe6];\n\t\tv2 = bios[0xe7];\n\t} else {\n\t\treg = SiS_GetReg(SISSR, 0x3a);\n\t\tif((reg & 0x30) == 0x30) {\n\t\t\tv1 = 0x04;  \n\t\t\tv2 = 0x92;\n\t\t} else {\n\t\t\tv1 = 0x14;  \n\t\t\tv2 = 0xb2;\n\t\t}\n\t}\n\tSiS_SetReg(SISSR, 0x21, v1);\n\tSiS_SetReg(SISSR, 0x22, v2);\n\n\t \n\tsisfb_sense_crt1(ivideo);\n\n\t \n\tivideo->SiS_Pr.SiS_UseOEM = false;\n\tSiS_SetEnableDstn(&ivideo->SiS_Pr, false);\n\tSiS_SetEnableFstn(&ivideo->SiS_Pr, false);\n\tivideo->curFSTN = ivideo->curDSTN = 0;\n\tivideo->SiS_Pr.VideoMemorySize = 8 << 20;\n\tSiSSetMode(&ivideo->SiS_Pr, 0x2e | 0x80);\n\n\tSiS_SetReg(SISSR, 0x05, 0x86);\n\n\t \n\tSiS_SetRegOR(SISSR, 0x01, 0x20);\n\n\t \n\tSiS_SetReg(SISCR, 0x34, 0x2e);\n\n\t \n\tivideo->modeprechange = 0x2e;\n}\n#endif\n\n#ifdef CONFIG_FB_SIS_315\n#if 0\nstatic void sisfb_post_sis315330(struct pci_dev *pdev)\n{\n\t \n}\n#endif\n\nstatic inline int sisfb_xgi_is21(struct sis_video_info *ivideo)\n{\n\treturn ivideo->chip_real_id == XGI_21;\n}\n\nstatic void sisfb_post_xgi_delay(struct sis_video_info *ivideo, int delay)\n{\n\tunsigned int i;\n\tu8 reg;\n\n\tfor(i = 0; i <= (delay * 10 * 36); i++) {\n\t\treg = SiS_GetReg(SISSR, 0x05);\n\t\treg++;\n\t}\n}\n\nstatic int sisfb_find_host_bridge(struct sis_video_info *ivideo,\n\t\t\t\t  struct pci_dev *mypdev,\n\t\t\t\t  unsigned short pcivendor)\n{\n\tstruct pci_dev *pdev = NULL;\n\tunsigned short temp;\n\tint ret = 0;\n\n\twhile((pdev = pci_get_class(PCI_CLASS_BRIDGE_HOST, pdev))) {\n\t\ttemp = pdev->vendor;\n\t\tif(temp == pcivendor) {\n\t\t\tret = 1;\n\t\t\tpci_dev_put(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int sisfb_post_xgi_rwtest(struct sis_video_info *ivideo, int starta,\n\t\t\t\t unsigned int enda, unsigned int mapsize)\n{\n\tunsigned int pos;\n\tint i;\n\n\twritel(0, ivideo->video_vbase);\n\n\tfor(i = starta; i <= enda; i++) {\n\t\tpos = 1 << i;\n\t\tif(pos < mapsize)\n\t\t\twritel(pos, ivideo->video_vbase + pos);\n\t}\n\n\tsisfb_post_xgi_delay(ivideo, 150);\n\n\tif(readl(ivideo->video_vbase) != 0)\n\t\treturn 0;\n\n\tfor(i = starta; i <= enda; i++) {\n\t\tpos = 1 << i;\n\t\tif(pos < mapsize) {\n\t\t\tif(readl(ivideo->video_vbase + pos) != pos)\n\t\t\t\treturn 0;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int sisfb_post_xgi_ramsize(struct sis_video_info *ivideo)\n{\n\tunsigned int buswidth, ranksize, channelab, mapsize;\n\tint i, j, k, l, status;\n\tu8 reg, sr14;\n\tstatic const u8 dramsr13[12 * 5] = {\n\t\t0x02, 0x0e, 0x0b, 0x80, 0x5d,\n\t\t0x02, 0x0e, 0x0a, 0x40, 0x59,\n\t\t0x02, 0x0d, 0x0b, 0x40, 0x4d,\n\t\t0x02, 0x0e, 0x09, 0x20, 0x55,\n\t\t0x02, 0x0d, 0x0a, 0x20, 0x49,\n\t\t0x02, 0x0c, 0x0b, 0x20, 0x3d,\n\t\t0x02, 0x0e, 0x08, 0x10, 0x51,\n\t\t0x02, 0x0d, 0x09, 0x10, 0x45,\n\t\t0x02, 0x0c, 0x0a, 0x10, 0x39,\n\t\t0x02, 0x0d, 0x08, 0x08, 0x41,\n\t\t0x02, 0x0c, 0x09, 0x08, 0x35,\n\t\t0x02, 0x0c, 0x08, 0x04, 0x31\n\t};\n\tstatic const u8 dramsr13_4[4 * 5] = {\n\t\t0x02, 0x0d, 0x09, 0x40, 0x45,\n\t\t0x02, 0x0c, 0x09, 0x20, 0x35,\n\t\t0x02, 0x0c, 0x08, 0x10, 0x31,\n\t\t0x02, 0x0b, 0x08, 0x08, 0x21\n\t};\n\n\t \n\t \n\tSiS_SetRegOR(SISSR, 0x20, (0x80 | 0x04));\n\n\t \n\tmapsize = ivideo->video_size;\n\tsisfb_post_map_vram(ivideo, &mapsize, 32);\n\n\tif(!ivideo->video_vbase) {\n\t\tprintk(KERN_ERR \"sisfb: Unable to detect RAM size. Setting default.\\n\");\n\t\tSiS_SetReg(SISSR, 0x13, 0x35);\n\t\tSiS_SetReg(SISSR, 0x14, 0x41);\n\t\t \n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tSiS_SetReg(SISSR, 0x15, 0x00);\n\t \n\tSiS_SetReg(SISSR, 0x1c, 0x00);\n\n\tif(ivideo->chip == XGI_20) {\n\n\t\tchannelab = 1;\n\t\treg = SiS_GetReg(SISCR, 0x97);\n\t\tif(!(reg & 0x01)) {\t \n\t\t\tbuswidth = 32;\n\t\t\tSiS_SetReg(SISSR, 0x13, 0xb1);\n\t\t\tSiS_SetReg(SISSR, 0x14, 0x52);\n\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\t\t\tsr14 = 0x02;\n\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 23, 24, mapsize))\n\t\t\t\tgoto bail_out;\n\n\t\t\tSiS_SetReg(SISSR, 0x13, 0x31);\n\t\t\tSiS_SetReg(SISSR, 0x14, 0x42);\n\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 23, 23, mapsize))\n\t\t\t\tgoto bail_out;\n\n\t\t\tbuswidth = 16;\n\t\t\tSiS_SetReg(SISSR, 0x13, 0xb1);\n\t\t\tSiS_SetReg(SISSR, 0x14, 0x41);\n\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\t\t\tsr14 = 0x01;\n\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 22, 23, mapsize))\n\t\t\t\tgoto bail_out;\n\t\t\telse\n\t\t\t\tSiS_SetReg(SISSR, 0x13, 0x31);\n\t\t} else {\t\t \n\t\t\tbuswidth = 16;\n\t\t\tSiS_SetReg(SISSR, 0x13, 0xb1);\n\t\t\tSiS_SetReg(SISSR, 0x14, 0x41);\n\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\t\t\tsr14 = 0x01;\n\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 22, 23, mapsize))\n\t\t\t\tgoto bail_out;\n\n\t\t\tSiS_SetReg(SISSR, 0x13, 0x31);\n\t\t\tSiS_SetReg(SISSR, 0x14, 0x31);\n\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 22, 22, mapsize))\n\t\t\t\tgoto bail_out;\n\n\t\t\tbuswidth = 8;\n\t\t\tSiS_SetReg(SISSR, 0x13, 0xb1);\n\t\t\tSiS_SetReg(SISSR, 0x14, 0x30);\n\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\t\t\tsr14 = 0x00;\n\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 21, 22, mapsize))\n\t\t\t\tgoto bail_out;\n\t\t\telse\n\t\t\t\tSiS_SetReg(SISSR, 0x13, 0x31);\n\t\t}\n\n\t} else {\t \n\n\t\treg = SiS_GetReg(SISCR, 0x97);\n\t\tif(!(reg & 0x10)) {\n\t\t\treg = SiS_GetReg(SISSR, 0x39);\n\t\t\treg >>= 1;\n\t\t}\n\n\t\tif(reg & 0x01) {\t \n\t\t\tbuswidth = 32;\n\t\t\tif(ivideo->revision_id == 2) {\n\t\t\t\tchannelab = 2;\n\t\t\t\tSiS_SetReg(SISSR, 0x13, 0xa1);\n\t\t\t\tSiS_SetReg(SISSR, 0x14, 0x44);\n\t\t\t\tsr14 = 0x04;\n\t\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\t\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 23, 24, mapsize))\n\t\t\t\t\tgoto bail_out;\n\n\t\t\t\tSiS_SetReg(SISSR, 0x13, 0x21);\n\t\t\t\tSiS_SetReg(SISSR, 0x14, 0x34);\n\t\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 22, 23, mapsize))\n\t\t\t\t\tgoto bail_out;\n\n\t\t\t\tchannelab = 1;\n\t\t\t\tSiS_SetReg(SISSR, 0x13, 0xa1);\n\t\t\t\tSiS_SetReg(SISSR, 0x14, 0x40);\n\t\t\t\tsr14 = 0x00;\n\t\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 22, 23, mapsize))\n\t\t\t\t\tgoto bail_out;\n\n\t\t\t\tSiS_SetReg(SISSR, 0x13, 0x21);\n\t\t\t\tSiS_SetReg(SISSR, 0x14, 0x30);\n\t\t\t} else {\n\t\t\t\tchannelab = 3;\n\t\t\t\tSiS_SetReg(SISSR, 0x13, 0xa1);\n\t\t\t\tSiS_SetReg(SISSR, 0x14, 0x4c);\n\t\t\t\tsr14 = 0x0c;\n\t\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\t\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 23, 25, mapsize))\n\t\t\t\t\tgoto bail_out;\n\n\t\t\t\tchannelab = 2;\n\t\t\t\tSiS_SetReg(SISSR, 0x14, 0x48);\n\t\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\t\t\t\tsr14 = 0x08;\n\t\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 23, 24, mapsize))\n\t\t\t\t\tgoto bail_out;\n\n\t\t\t\tSiS_SetReg(SISSR, 0x13, 0x21);\n\t\t\t\tSiS_SetReg(SISSR, 0x14, 0x3c);\n\t\t\t\tsr14 = 0x0c;\n\n\t\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 23, 24, mapsize)) {\n\t\t\t\t\tchannelab = 3;\n\t\t\t\t} else {\n\t\t\t\t\tchannelab = 2;\n\t\t\t\t\tSiS_SetReg(SISSR, 0x14, 0x38);\n\t\t\t\t\tsr14 = 0x08;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\n\t\t} else {\t \n\n\t\t\tbuswidth = 64;\n\t\t\tif(ivideo->revision_id == 2) {\n\t\t\t\tchannelab = 1;\n\t\t\t\tSiS_SetReg(SISSR, 0x13, 0xa1);\n\t\t\t\tSiS_SetReg(SISSR, 0x14, 0x52);\n\t\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\t\t\t\tsr14 = 0x02;\n\t\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 23, 24, mapsize))\n\t\t\t\t\tgoto bail_out;\n\n\t\t\t\tSiS_SetReg(SISSR, 0x13, 0x21);\n\t\t\t\tSiS_SetReg(SISSR, 0x14, 0x42);\n\t\t\t} else {\n\t\t\t\tchannelab = 2;\n\t\t\t\tSiS_SetReg(SISSR, 0x13, 0xa1);\n\t\t\t\tSiS_SetReg(SISSR, 0x14, 0x5a);\n\t\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\t\t\t\tsr14 = 0x0a;\n\t\t\t\tif(sisfb_post_xgi_rwtest(ivideo, 24, 25, mapsize))\n\t\t\t\t\tgoto bail_out;\n\n\t\t\t\tSiS_SetReg(SISSR, 0x13, 0x21);\n\t\t\t\tSiS_SetReg(SISSR, 0x14, 0x4a);\n\t\t\t}\n\t\t\tsisfb_post_xgi_delay(ivideo, 1);\n\n\t\t}\n\t}\n\nbail_out:\n\tSiS_SetRegANDOR(SISSR, 0x14, 0xf0, sr14);\n\tsisfb_post_xgi_delay(ivideo, 1);\n\n\tj = (ivideo->chip == XGI_20) ? 5 : 9;\n\tk = (ivideo->chip == XGI_20) ? 12 : 4;\n\tstatus = -EIO;\n\n\tfor(i = 0; i < k; i++) {\n\n\t\treg = (ivideo->chip == XGI_20) ?\n\t\t\t\tdramsr13[(i * 5) + 4] : dramsr13_4[(i * 5) + 4];\n\t\tSiS_SetRegANDOR(SISSR, 0x13, 0x80, reg);\n\t\tsisfb_post_xgi_delay(ivideo, 50);\n\n\t\tranksize = (ivideo->chip == XGI_20) ?\n\t\t\t\tdramsr13[(i * 5) + 3] : dramsr13_4[(i * 5) + 3];\n\n\t\treg = SiS_GetReg(SISSR, 0x13);\n\t\tif(reg & 0x80) ranksize <<= 1;\n\n\t\tif(ivideo->chip == XGI_20) {\n\t\t\tif(buswidth == 16)      ranksize <<= 1;\n\t\t\telse if(buswidth == 32) ranksize <<= 2;\n\t\t} else {\n\t\t\tif(buswidth == 64)      ranksize <<= 1;\n\t\t}\n\n\t\treg = 0;\n\t\tl = channelab;\n\t\tif(l == 3) l = 4;\n\t\tif((ranksize * l) <= 256) {\n\t\t\twhile((ranksize >>= 1)) reg += 0x10;\n\t\t}\n\n\t\tif(!reg) continue;\n\n\t\tSiS_SetRegANDOR(SISSR, 0x14, 0x0f, (reg & 0xf0));\n\t\tsisfb_post_xgi_delay(ivideo, 1);\n\n\t\tif (sisfb_post_xgi_rwtest(ivideo, j, ((reg >> 4) + channelab - 2 + 20), mapsize)) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tiounmap(ivideo->video_vbase);\n\n\treturn status;\n}\n\nstatic void sisfb_post_xgi_setclocks(struct sis_video_info *ivideo, u8 regb)\n{\n\tu8 v1, v2, v3;\n\tint index;\n\tstatic const u8 cs90[8 * 3] = {\n\t\t0x16, 0x01, 0x01,\n\t\t0x3e, 0x03, 0x01,\n\t\t0x7c, 0x08, 0x01,\n\t\t0x79, 0x06, 0x01,\n\t\t0x29, 0x01, 0x81,\n\t\t0x5c, 0x23, 0x01,\n\t\t0x5c, 0x23, 0x01,\n\t\t0x5c, 0x23, 0x01\n\t};\n\tstatic const u8 csb8[8 * 3] = {\n\t\t0x5c, 0x23, 0x01,\n\t\t0x29, 0x01, 0x01,\n\t\t0x7c, 0x08, 0x01,\n\t\t0x79, 0x06, 0x01,\n\t\t0x29, 0x01, 0x81,\n\t\t0x5c, 0x23, 0x01,\n\t\t0x5c, 0x23, 0x01,\n\t\t0x5c, 0x23, 0x01\n\t};\n\n\tregb = 0;   \n\n\tindex = regb * 3;\n\tv1 = cs90[index]; v2 = cs90[index + 1]; v3 = cs90[index + 2];\n\tif(ivideo->haveXGIROM) {\n\t\tv1 = ivideo->bios_abase[0x90 + index];\n\t\tv2 = ivideo->bios_abase[0x90 + index + 1];\n\t\tv3 = ivideo->bios_abase[0x90 + index + 2];\n\t}\n\tSiS_SetReg(SISSR, 0x28, v1);\n\tSiS_SetReg(SISSR, 0x29, v2);\n\tSiS_SetReg(SISSR, 0x2a, v3);\n\tsisfb_post_xgi_delay(ivideo, 0x43);\n\tsisfb_post_xgi_delay(ivideo, 0x43);\n\tsisfb_post_xgi_delay(ivideo, 0x43);\n\tindex = regb * 3;\n\tv1 = csb8[index]; v2 = csb8[index + 1]; v3 = csb8[index + 2];\n\tif(ivideo->haveXGIROM) {\n\t\tv1 = ivideo->bios_abase[0xb8 + index];\n\t\tv2 = ivideo->bios_abase[0xb8 + index + 1];\n\t\tv3 = ivideo->bios_abase[0xb8 + index + 2];\n\t}\n\tSiS_SetReg(SISSR, 0x2e, v1);\n\tSiS_SetReg(SISSR, 0x2f, v2);\n\tSiS_SetReg(SISSR, 0x30, v3);\n\tsisfb_post_xgi_delay(ivideo, 0x43);\n\tsisfb_post_xgi_delay(ivideo, 0x43);\n\tsisfb_post_xgi_delay(ivideo, 0x43);\n}\n\nstatic void sisfb_post_xgi_ddr2_mrs_default(struct sis_video_info *ivideo,\n\t\t\t\t\t    u8 regb)\n{\n\tunsigned char *bios = ivideo->bios_abase;\n\tu8 v1;\n\n\tSiS_SetReg(SISSR, 0x28, 0x64);\n\tSiS_SetReg(SISSR, 0x29, 0x63);\n\tsisfb_post_xgi_delay(ivideo, 15);\n\tSiS_SetReg(SISSR, 0x18, 0x00);\n\tSiS_SetReg(SISSR, 0x19, 0x20);\n\tSiS_SetReg(SISSR, 0x16, 0x00);\n\tSiS_SetReg(SISSR, 0x16, 0x80);\n\tSiS_SetReg(SISSR, 0x18, 0xc5);\n\tSiS_SetReg(SISSR, 0x19, 0x23);\n\tSiS_SetReg(SISSR, 0x16, 0x00);\n\tSiS_SetReg(SISSR, 0x16, 0x80);\n\tsisfb_post_xgi_delay(ivideo, 1);\n\tSiS_SetReg(SISCR, 0x97, 0x11);\n\tsisfb_post_xgi_setclocks(ivideo, regb);\n\tsisfb_post_xgi_delay(ivideo, 0x46);\n\tSiS_SetReg(SISSR, 0x18, 0xc5);\n\tSiS_SetReg(SISSR, 0x19, 0x23);\n\tSiS_SetReg(SISSR, 0x16, 0x00);\n\tSiS_SetReg(SISSR, 0x16, 0x80);\n\tsisfb_post_xgi_delay(ivideo, 1);\n\tSiS_SetReg(SISSR, 0x1b, 0x04);\n\tsisfb_post_xgi_delay(ivideo, 1);\n\tSiS_SetReg(SISSR, 0x1b, 0x00);\n\tsisfb_post_xgi_delay(ivideo, 1);\n\tv1 = 0x31;\n\tif (ivideo->haveXGIROM) {\n\t\tv1 = bios[0xf0];\n\t}\n\tSiS_SetReg(SISSR, 0x18, v1);\n\tSiS_SetReg(SISSR, 0x19, 0x06);\n\tSiS_SetReg(SISSR, 0x16, 0x04);\n\tSiS_SetReg(SISSR, 0x16, 0x84);\n\tsisfb_post_xgi_delay(ivideo, 1);\n}\n\nstatic void sisfb_post_xgi_ddr2_mrs_xg21(struct sis_video_info *ivideo)\n{\n\tsisfb_post_xgi_setclocks(ivideo, 1);\n\n\tSiS_SetReg(SISCR, 0x97, 0x11);\n\tsisfb_post_xgi_delay(ivideo, 0x46);\n\n\tSiS_SetReg(SISSR, 0x18, 0x00);\t \n\tSiS_SetReg(SISSR, 0x19, 0x80);\n\tSiS_SetReg(SISSR, 0x16, 0x05);\n\tSiS_SetReg(SISSR, 0x16, 0x85);\n\n\tSiS_SetReg(SISSR, 0x18, 0x00);\t \n\tSiS_SetReg(SISSR, 0x19, 0xc0);\n\tSiS_SetReg(SISSR, 0x16, 0x05);\n\tSiS_SetReg(SISSR, 0x16, 0x85);\n\n\tSiS_SetReg(SISSR, 0x18, 0x00);\t \n\tSiS_SetReg(SISSR, 0x19, 0x40);\n\tSiS_SetReg(SISSR, 0x16, 0x05);\n\tSiS_SetReg(SISSR, 0x16, 0x85);\n\n\tSiS_SetReg(SISSR, 0x18, 0x42);\t \n\tSiS_SetReg(SISSR, 0x19, 0x02);\n\tSiS_SetReg(SISSR, 0x16, 0x05);\n\tSiS_SetReg(SISSR, 0x16, 0x85);\n\tsisfb_post_xgi_delay(ivideo, 1);\n\n\tSiS_SetReg(SISSR, 0x1b, 0x04);\n\tsisfb_post_xgi_delay(ivideo, 1);\n\n\tSiS_SetReg(SISSR, 0x1b, 0x00);\n\tsisfb_post_xgi_delay(ivideo, 1);\n\n\tSiS_SetReg(SISSR, 0x18, 0x42);\t \n\tSiS_SetReg(SISSR, 0x19, 0x00);\n\tSiS_SetReg(SISSR, 0x16, 0x05);\n\tSiS_SetReg(SISSR, 0x16, 0x85);\n\tsisfb_post_xgi_delay(ivideo, 1);\n}\n\nstatic void sisfb_post_xgi_ddr2(struct sis_video_info *ivideo, u8 regb)\n{\n\tunsigned char *bios = ivideo->bios_abase;\n\tstatic const u8 cs158[8] = {\n\t\t0x88, 0xaa, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cs160[8] = {\n\t\t0x44, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cs168[8] = {\n\t\t0x48, 0x78, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tu8 v1;\n\tu8 v2;\n\tu8 v3;\n\n\tSiS_SetReg(SISCR, 0xb0, 0x80);  \n\tSiS_SetReg(SISCR, 0x82, 0x77);\n\tSiS_SetReg(SISCR, 0x86, 0x00);\n\tSiS_GetReg(SISCR, 0x86);\n\tSiS_SetReg(SISCR, 0x86, 0x88);\n\tSiS_GetReg(SISCR, 0x86);\n\tv1 = cs168[regb]; v2 = cs160[regb]; v3 = cs158[regb];\n\tif (ivideo->haveXGIROM) {\n\t\tv1 = bios[regb + 0x168];\n\t\tv2 = bios[regb + 0x160];\n\t\tv3 = bios[regb + 0x158];\n\t}\n\tSiS_SetReg(SISCR, 0x86, v1);\n\tSiS_SetReg(SISCR, 0x82, 0x77);\n\tSiS_SetReg(SISCR, 0x85, 0x00);\n\tSiS_GetReg(SISCR, 0x85);\n\tSiS_SetReg(SISCR, 0x85, 0x88);\n\tSiS_GetReg(SISCR, 0x85);\n\tSiS_SetReg(SISCR, 0x85, v2);\n\tSiS_SetReg(SISCR, 0x82, v3);\n\tSiS_SetReg(SISCR, 0x98, 0x01);\n\tSiS_SetReg(SISCR, 0x9a, 0x02);\n\tif (sisfb_xgi_is21(ivideo))\n\t\tsisfb_post_xgi_ddr2_mrs_xg21(ivideo);\n\telse\n\t\tsisfb_post_xgi_ddr2_mrs_default(ivideo, regb);\n}\n\nstatic u8 sisfb_post_xgi_ramtype(struct sis_video_info *ivideo)\n{\n\tunsigned char *bios = ivideo->bios_abase;\n\tu8 ramtype;\n\tu8 reg;\n\tu8 v1;\n\n\tramtype = 0x00; v1 = 0x10;\n\tif (ivideo->haveXGIROM) {\n\t\tramtype = bios[0x62];\n\t\tv1 = bios[0x1d2];\n\t}\n\tif (!(ramtype & 0x80)) {\n\t\tif (sisfb_xgi_is21(ivideo)) {\n\t\t\tSiS_SetRegAND(SISCR, 0xb4, 0xfd);  \n\t\t\tSiS_SetRegOR(SISCR, 0x4a, 0x80);   \n\t\t\treg = SiS_GetReg(SISCR, 0x48);\n\t\t\tSiS_SetRegOR(SISCR, 0xb4, 0x02);\n\t\t\tramtype = reg & 0x01;\t\t   \n\t\t} else if (ivideo->chip == XGI_20) {\n\t\t\tSiS_SetReg(SISCR, 0x97, v1);\n\t\t\treg = SiS_GetReg(SISCR, 0x97);\n\t\t\tif (reg & 0x10) {\n\t\t\t\tramtype = (reg & 0x01) << 1;\n\t\t\t}\n\t\t} else {\n\t\t\treg = SiS_GetReg(SISSR, 0x39);\n\t\t\tramtype = reg & 0x02;\n\t\t\tif (!(ramtype)) {\n\t\t\t\treg = SiS_GetReg(SISSR, 0x3a);\n\t\t\t\tramtype = (reg >> 1) & 0x01;\n\t\t\t}\n\t\t}\n\t}\n\tramtype &= 0x07;\n\n\treturn ramtype;\n}\n\nstatic int sisfb_post_xgi(struct pci_dev *pdev)\n{\n\tstruct sis_video_info *ivideo = pci_get_drvdata(pdev);\n\tunsigned char *bios = ivideo->bios_abase;\n\tstruct pci_dev *mypdev = NULL;\n\tconst u8 *ptr, *ptr2;\n\tu8 v1, v2, v3, v4, v5, reg, ramtype;\n\tu32 rega, regb, regd;\n\tint i, j, k, index;\n\tstatic const u8 cs78[3] = { 0xf6, 0x0d, 0x00 };\n\tstatic const u8 cs76[2] = { 0xa3, 0xfb };\n\tstatic const u8 cs7b[3] = { 0xc0, 0x11, 0x00 };\n\tstatic const u8 cs158[8] = {\n\t\t0x88, 0xaa, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cs160[8] = {\n\t\t0x44, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cs168[8] = {\n\t\t0x48, 0x78, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cs128[3 * 8] = {\n\t\t0x90, 0x28, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x77, 0x44, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x77, 0x44, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cs148[2 * 8] = {\n\t\t0x55, 0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cs31a[8 * 4] = {\n\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n\t\t0xaa, 0xaa, 0xaa, 0xaa, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cs33a[8 * 4] = {\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cs45a[8 * 2] = {\n\t\t0x00, 0x00, 0xa0, 0x00, 0xa0, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cs170[7 * 8] = {\n\t\t0x54, 0x32, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x54, 0x43, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x0a, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x44, 0x34, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x10, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x11, 0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cs1a8[3 * 8] = {\n\t\t0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x05, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cs100[2 * 8] = {\n\t\t0xc4, 0x04, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0xc4, 0x04, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\n\t \n\treg = SiS_GetRegByte(SISVGAENABLE) | 0x01;\n\tSiS_SetRegByte(SISVGAENABLE, reg);\n\n\t \n\treg = SiS_GetRegByte(SISMISCR) | 0x01;\n\tSiS_SetRegByte(SISMISCW, reg);\n\n\t \n\tSiS_SetReg(SISSR, 0x05, 0x86);\n\treg = SiS_GetReg(SISSR, 0x05);\n\tif(reg != 0xa1)\n\t\treturn 0;\n\n\t \n\tfor(i = 0; i < 0x22; i++) {\n\t\tif(0x06 + i == 0x20) continue;\n\t\tSiS_SetReg(SISSR, 0x06 + i, 0x00);\n\t}\n\tfor(i = 0; i < 0x0b; i++) {\n\t\tSiS_SetReg(SISSR, 0x31 + i, 0x00);\n\t}\n\tfor(i = 0; i < 0x10; i++) {\n\t\tSiS_SetReg(SISCR, 0x30 + i, 0x00);\n\t}\n\n\tptr = cs78;\n\tif(ivideo->haveXGIROM) {\n\t\tptr = (const u8 *)&bios[0x78];\n\t}\n\tfor(i = 0; i < 3; i++) {\n\t\tSiS_SetReg(SISSR, 0x23 + i, ptr[i]);\n\t}\n\n\tptr = cs76;\n\tif(ivideo->haveXGIROM) {\n\t\tptr = (const u8 *)&bios[0x76];\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tSiS_SetReg(SISSR, 0x21 + i, ptr[i]);\n\t}\n\n\tv1 = 0x18; v2 = 0x00;\n\tif(ivideo->haveXGIROM) {\n\t\tv1 = bios[0x74];\n\t\tv2 = bios[0x75];\n\t}\n\tSiS_SetReg(SISSR, 0x07, v1);\n\tSiS_SetReg(SISSR, 0x11, 0x0f);\n\tSiS_SetReg(SISSR, 0x1f, v2);\n\t \n\tSiS_SetReg(SISSR, 0x20, 0x80 | 0x20 | 0x04);\n\tSiS_SetReg(SISSR, 0x27, 0x74);\n\n\tptr = cs7b;\n\tif(ivideo->haveXGIROM) {\n\t\tptr = (const u8 *)&bios[0x7b];\n\t}\n\tfor(i = 0; i < 3; i++) {\n\t\tSiS_SetReg(SISSR, 0x31 + i, ptr[i]);\n\t}\n\n\tif(ivideo->chip == XGI_40) {\n\t\tif(ivideo->revision_id == 2) {\n\t\t\tSiS_SetRegANDOR(SISSR, 0x3b, 0x3f, 0xc0);\n\t\t}\n\t\tSiS_SetReg(SISCR, 0x7d, 0xfe);\n\t\tSiS_SetReg(SISCR, 0x7e, 0x0f);\n\t}\n\tif(ivideo->revision_id == 0) {\t \n\t\tSiS_SetRegAND(SISCR, 0x58, 0xd7);\n\t\treg = SiS_GetReg(SISCR, 0xcb);\n\t\tif(reg & 0x20) {\n\t\t\tSiS_SetRegANDOR(SISCR, 0x58, 0xd7, (reg & 0x10) ? 0x08 : 0x20);  \n\t\t}\n\t}\n\n\treg = (ivideo->chip == XGI_40) ? 0x20 : 0x00;\n\tSiS_SetRegANDOR(SISCR, 0x38, 0x1f, reg);\n\n\tif(ivideo->chip == XGI_20) {\n\t\tSiS_SetReg(SISSR, 0x36, 0x70);\n\t} else {\n\t\tSiS_SetReg(SISVID, 0x00, 0x86);\n\t\tSiS_SetReg(SISVID, 0x32, 0x00);\n\t\tSiS_SetReg(SISVID, 0x30, 0x00);\n\t\tSiS_SetReg(SISVID, 0x32, 0x01);\n\t\tSiS_SetReg(SISVID, 0x30, 0x00);\n\t\tSiS_SetRegAND(SISVID, 0x2f, 0xdf);\n\t\tSiS_SetRegAND(SISCAP, 0x00, 0x3f);\n\n\t\tSiS_SetReg(SISPART1, 0x2f, 0x01);\n\t\tSiS_SetReg(SISPART1, 0x00, 0x00);\n\t\tSiS_SetReg(SISPART1, 0x02, bios[0x7e]);\n\t\tSiS_SetReg(SISPART1, 0x2e, 0x08);\n\t\tSiS_SetRegAND(SISPART1, 0x35, 0x7f);\n\t\tSiS_SetRegAND(SISPART1, 0x50, 0xfe);\n\n\t\treg = SiS_GetReg(SISPART4, 0x00);\n\t\tif(reg == 1 || reg == 2) {\n\t\t\tSiS_SetReg(SISPART2, 0x00, 0x1c);\n\t\t\tSiS_SetReg(SISPART4, 0x0d, bios[0x7f]);\n\t\t\tSiS_SetReg(SISPART4, 0x0e, bios[0x80]);\n\t\t\tSiS_SetReg(SISPART4, 0x10, bios[0x81]);\n\t\t\tSiS_SetRegAND(SISPART4, 0x0f, 0x3f);\n\n\t\t\treg = SiS_GetReg(SISPART4, 0x01);\n\t\t\tif((reg & 0xf0) >= 0xb0) {\n\t\t\t\treg = SiS_GetReg(SISPART4, 0x23);\n\t\t\t\tif(reg & 0x20) reg |= 0x40;\n\t\t\t\tSiS_SetReg(SISPART4, 0x23, reg);\n\t\t\t\treg = (reg & 0x20) ? 0x02 : 0x00;\n\t\t\t\tSiS_SetRegANDOR(SISPART1, 0x1e, 0xfd, reg);\n\t\t\t}\n\t\t}\n\n\t\tv1 = bios[0x77];\n\n\t\treg = SiS_GetReg(SISSR, 0x3b);\n\t\tif(reg & 0x02) {\n\t\t\treg = SiS_GetReg(SISSR, 0x3a);\n\t\t\tv2 = (reg & 0x30) >> 3;\n\t\t\tif(!(v2 & 0x04)) v2 ^= 0x02;\n\t\t\treg = SiS_GetReg(SISSR, 0x39);\n\t\t\tif(reg & 0x80) v2 |= 0x80;\n\t\t\tv2 |= 0x01;\n\n\t\t\tif((mypdev = pci_get_device(PCI_VENDOR_ID_SI, 0x0730, NULL))) {\n\t\t\t\tpci_dev_put(mypdev);\n\t\t\t\tif(((v2 & 0x06) == 2) || ((v2 & 0x06) == 4))\n\t\t\t\t\tv2 &= 0xf9;\n\t\t\t\tv2 |= 0x08;\n\t\t\t\tv1 &= 0xfe;\n\t\t\t} else {\n\t\t\t\tmypdev = pci_get_device(PCI_VENDOR_ID_SI, 0x0735, NULL);\n\t\t\t\tif(!mypdev)\n\t\t\t\t\tmypdev = pci_get_device(PCI_VENDOR_ID_SI, 0x0645, NULL);\n\t\t\t\tif(!mypdev)\n\t\t\t\t\tmypdev = pci_get_device(PCI_VENDOR_ID_SI, 0x0650, NULL);\n\t\t\t\tif(mypdev) {\n\t\t\t\t\tpci_read_config_dword(mypdev, 0x94, &regd);\n\t\t\t\t\tregd &= 0xfffffeff;\n\t\t\t\t\tpci_write_config_dword(mypdev, 0x94, regd);\n\t\t\t\t\tv1 &= 0xfe;\n\t\t\t\t\tpci_dev_put(mypdev);\n\t\t\t\t} else if(sisfb_find_host_bridge(ivideo, pdev, PCI_VENDOR_ID_SI)) {\n\t\t\t\t\tv1 &= 0xfe;\n\t\t\t\t} else if(sisfb_find_host_bridge(ivideo, pdev, 0x1106) ||\n\t\t\t\t\t  sisfb_find_host_bridge(ivideo, pdev, 0x1022) ||\n\t\t\t\t\t  sisfb_find_host_bridge(ivideo, pdev, 0x700e) ||\n\t\t\t\t\t  sisfb_find_host_bridge(ivideo, pdev, 0x10de)) {\n\t\t\t\t\tif((v2 & 0x06) == 4)\n\t\t\t\t\t\tv2 ^= 0x06;\n\t\t\t\t\tv2 |= 0x08;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSiS_SetRegANDOR(SISCR, 0x5f, 0xf0, v2);\n\t\t}\n\t\tSiS_SetReg(SISSR, 0x22, v1);\n\n\t\tif(ivideo->revision_id == 2) {\n\t\t\tv1 = SiS_GetReg(SISSR, 0x3b);\n\t\t\tv2 = SiS_GetReg(SISSR, 0x3a);\n\t\t\tregd = bios[0x90 + 3] | (bios[0x90 + 4] << 8);\n\t\t\tif( (!(v1 & 0x02)) && (v2 & 0x30) && (regd < 0xcf) )\n\t\t\t\tSiS_SetRegANDOR(SISCR, 0x5f, 0xf1, 0x01);\n\n\t\t\tif((mypdev = pci_get_device(0x10de, 0x01e0, NULL))) {\n\t\t\t\t \n\t\t\t\tif(0)\n\t\t\t\t\tSiS_SetRegANDOR(SISCR, 0x5f, 0xf1, 0x01);\n\t\t\t\tpci_dev_put(mypdev);\n\t\t\t}\n\t\t}\n\n\t\tv1 = 0x30;\n\t\treg = SiS_GetReg(SISSR, 0x3b);\n\t\tv2 = SiS_GetReg(SISCR, 0x5f);\n\t\tif((!(reg & 0x02)) && (v2 & 0x0e))\n\t\t\tv1 |= 0x08;\n\t\tSiS_SetReg(SISSR, 0x27, v1);\n\n\t\tif(bios[0x64] & 0x01) {\n\t\t\tSiS_SetRegANDOR(SISCR, 0x5f, 0xf0, bios[0x64]);\n\t\t}\n\n\t\tv1 = bios[0x4f7];\n\t\tpci_read_config_dword(pdev, 0x50, &regd);\n\t\tregd = (regd >> 20) & 0x0f;\n\t\tif(regd == 1) {\n\t\t\tv1 &= 0xfc;\n\t\t\tSiS_SetRegOR(SISCR, 0x5f, 0x08);\n\t\t}\n\t\tSiS_SetReg(SISCR, 0x48, v1);\n\n\t\tSiS_SetRegANDOR(SISCR, 0x47, 0x04, bios[0x4f6] & 0xfb);\n\t\tSiS_SetRegANDOR(SISCR, 0x49, 0xf0, bios[0x4f8] & 0x0f);\n\t\tSiS_SetRegANDOR(SISCR, 0x4a, 0x60, bios[0x4f9] & 0x9f);\n\t\tSiS_SetRegANDOR(SISCR, 0x4b, 0x08, bios[0x4fa] & 0xf7);\n\t\tSiS_SetRegANDOR(SISCR, 0x4c, 0x80, bios[0x4fb] & 0x7f);\n\t\tSiS_SetReg(SISCR, 0x70, bios[0x4fc]);\n\t\tSiS_SetRegANDOR(SISCR, 0x71, 0xf0, bios[0x4fd] & 0x0f);\n\t\tSiS_SetReg(SISCR, 0x74, 0xd0);\n\t\tSiS_SetRegANDOR(SISCR, 0x74, 0xcf, bios[0x4fe] & 0x30);\n\t\tSiS_SetRegANDOR(SISCR, 0x75, 0xe0, bios[0x4ff] & 0x1f);\n\t\tSiS_SetRegANDOR(SISCR, 0x76, 0xe0, bios[0x500] & 0x1f);\n\t\tv1 = bios[0x501];\n\t\tif((mypdev = pci_get_device(0x8086, 0x2530, NULL))) {\n\t\t\tv1 = 0xf0;\n\t\t\tpci_dev_put(mypdev);\n\t\t}\n\t\tSiS_SetReg(SISCR, 0x77, v1);\n\t}\n\n\t \n\tramtype = sisfb_post_xgi_ramtype(ivideo);\n\tif (!sisfb_xgi_is21(ivideo) && ramtype) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"RAM type something else than expected: %d\\n\",\n\t\t\t ramtype);\n\t\tregb = 0;\n\t} else {\n\t\tregb = ramtype;\n\t}\n\n\tv1 = 0xff;\n\tif(ivideo->haveXGIROM) {\n\t\tv1 = bios[0x140 + regb];\n\t}\n\tSiS_SetReg(SISCR, 0x6d, v1);\n\n\tptr = cs128;\n\tif(ivideo->haveXGIROM) {\n\t\tptr = (const u8 *)&bios[0x128];\n\t}\n\tfor(i = 0, j = 0; i < 3; i++, j += 8) {\n\t\tSiS_SetReg(SISCR, 0x68 + i, ptr[j + regb]);\n\t}\n\n\tptr  = cs31a;\n\tptr2 = cs33a;\n\tif(ivideo->haveXGIROM) {\n\t\tindex = (ivideo->chip == XGI_20) ? 0x31a : 0x3a6;\n\t\tptr  = (const u8 *)&bios[index];\n\t\tptr2 = (const u8 *)&bios[index + 0x20];\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tif(i == 0) {\n\t\t\tregd = le32_to_cpu(((u32 *)ptr)[regb]);\n\t\t\trega = 0x6b;\n\t\t} else {\n\t\t\tregd = le32_to_cpu(((u32 *)ptr2)[regb]);\n\t\t\trega = 0x6e;\n\t\t}\n\t\treg = 0x00;\n\t\tfor(j = 0; j < 16; j++) {\n\t\t\treg &= 0xf3;\n\t\t\tif(regd & 0x01) reg |= 0x04;\n\t\t\tif(regd & 0x02) reg |= 0x08;\n\t\t\tregd >>= 2;\n\t\t\tSiS_SetReg(SISCR, rega, reg);\n\t\t\treg = SiS_GetReg(SISCR, rega);\n\t\t\treg = SiS_GetReg(SISCR, rega);\n\t\t\treg += 0x10;\n\t\t}\n\t}\n\n\tSiS_SetRegAND(SISCR, 0x6e, 0xfc);\n\n\tptr  = NULL;\n\tif(ivideo->haveXGIROM) {\n\t\tindex = (ivideo->chip == XGI_20) ? 0x35a : 0x3e6;\n\t\tptr  = (const u8 *)&bios[index];\n\t}\n\tfor(i = 0; i < 4; i++) {\n\t\tSiS_SetRegANDOR(SISCR, 0x6e, 0xfc, i);\n\t\treg = 0x00;\n\t\tfor(j = 0; j < 2; j++) {\n\t\t\tregd = 0;\n\t\t\tif(ptr) {\n\t\t\t\tregd = le32_to_cpu(((u32 *)ptr)[regb * 8]);\n\t\t\t\tptr += 4;\n\t\t\t}\n\t\t\t \n\t\t\tfor(k = 0; k < 16; k++) {\n\t\t\t\treg &= 0xfc;\n\t\t\t\tif(regd & 0x01) reg |= 0x01;\n\t\t\t\tif(regd & 0x02) reg |= 0x02;\n\t\t\t\tregd >>= 2;\n\t\t\t\tSiS_SetReg(SISCR, 0x6f, reg);\n\t\t\t\treg = SiS_GetReg(SISCR, 0x6f);\n\t\t\t\treg = SiS_GetReg(SISCR, 0x6f);\n\t\t\t\treg += 0x08;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr  = cs148;\n\tif(ivideo->haveXGIROM) {\n\t\tptr  = (const u8 *)&bios[0x148];\n\t}\n\tfor(i = 0, j = 0; i < 2; i++, j += 8) {\n\t\tSiS_SetReg(SISCR, 0x80 + i, ptr[j + regb]);\n\t}\n\n\tSiS_SetRegAND(SISCR, 0x89, 0x8f);\n\n\tptr  = cs45a;\n\tif(ivideo->haveXGIROM) {\n\t\tindex = (ivideo->chip == XGI_20) ? 0x45a : 0x4e6;\n\t\tptr  = (const u8 *)&bios[index];\n\t}\n\tregd = le16_to_cpu(((const u16 *)ptr)[regb]);\n\treg = 0x80;\n\tfor(i = 0; i < 5; i++) {\n\t\treg &= 0xfc;\n\t\tif(regd & 0x01) reg |= 0x01;\n\t\tif(regd & 0x02) reg |= 0x02;\n\t\tregd >>= 2;\n\t\tSiS_SetReg(SISCR, 0x89, reg);\n\t\treg = SiS_GetReg(SISCR, 0x89);\n\t\treg = SiS_GetReg(SISCR, 0x89);\n\t\treg += 0x10;\n\t}\n\n\tv1 = 0xb5; v2 = 0x20; v3 = 0xf0; v4 = 0x13;\n\tif(ivideo->haveXGIROM) {\n\t\tv1 = bios[0x118 + regb];\n\t\tv2 = bios[0xf8 + regb];\n\t\tv3 = bios[0x120 + regb];\n\t\tv4 = bios[0x1ca];\n\t}\n\tSiS_SetReg(SISCR, 0x45, v1 & 0x0f);\n\tSiS_SetReg(SISCR, 0x99, (v1 >> 4) & 0x07);\n\tSiS_SetRegOR(SISCR, 0x40, v1 & 0x80);\n\tSiS_SetReg(SISCR, 0x41, v2);\n\n\tptr  = cs170;\n\tif(ivideo->haveXGIROM) {\n\t\tptr  = (const u8 *)&bios[0x170];\n\t}\n\tfor(i = 0, j = 0; i < 7; i++, j += 8) {\n\t\tSiS_SetReg(SISCR, 0x90 + i, ptr[j + regb]);\n\t}\n\n\tSiS_SetReg(SISCR, 0x59, v3);\n\n\tptr  = cs1a8;\n\tif(ivideo->haveXGIROM) {\n\t\tptr  = (const u8 *)&bios[0x1a8];\n\t}\n\tfor(i = 0, j = 0; i < 3; i++, j += 8) {\n\t\tSiS_SetReg(SISCR, 0xc3 + i, ptr[j + regb]);\n\t}\n\n\tptr  = cs100;\n\tif(ivideo->haveXGIROM) {\n\t\tptr  = (const u8 *)&bios[0x100];\n\t}\n\tfor(i = 0, j = 0; i < 2; i++, j += 8) {\n\t\tSiS_SetReg(SISCR, 0x8a + i, ptr[j + regb]);\n\t}\n\n\tSiS_SetReg(SISCR, 0xcf, v4);\n\n\tSiS_SetReg(SISCR, 0x83, 0x09);\n\tSiS_SetReg(SISCR, 0x87, 0x00);\n\n\tif(ivideo->chip == XGI_40) {\n\t\tif( (ivideo->revision_id == 1) ||\n\t\t    (ivideo->revision_id == 2) ) {\n\t\t\tSiS_SetReg(SISCR, 0x8c, 0x87);\n\t\t}\n\t}\n\n\tif (regb == 1)\n\t\tSiS_SetReg(SISSR, 0x17, 0x80);\t\t \n\telse\n\t\tSiS_SetReg(SISSR, 0x17, 0x00);\t\t \n\tSiS_SetReg(SISSR, 0x1a, 0x87);\n\n\tif(ivideo->chip == XGI_20) {\n\t\tSiS_SetReg(SISSR, 0x15, 0x00);\n\t\tSiS_SetReg(SISSR, 0x1c, 0x00);\n\t}\n\n\tswitch(ramtype) {\n\tcase 0:\n\t\tsisfb_post_xgi_setclocks(ivideo, regb);\n\t\tif((ivideo->chip == XGI_20) ||\n\t\t   (ivideo->revision_id == 1)   ||\n\t\t   (ivideo->revision_id == 2)) {\n\t\t\tv1 = cs158[regb]; v2 = cs160[regb]; v3 = cs168[regb];\n\t\t\tif(ivideo->haveXGIROM) {\n\t\t\t\tv1 = bios[regb + 0x158];\n\t\t\t\tv2 = bios[regb + 0x160];\n\t\t\t\tv3 = bios[regb + 0x168];\n\t\t\t}\n\t\t\tSiS_SetReg(SISCR, 0x82, v1);\n\t\t\tSiS_SetReg(SISCR, 0x85, v2);\n\t\t\tSiS_SetReg(SISCR, 0x86, v3);\n\t\t} else {\n\t\t\tSiS_SetReg(SISCR, 0x82, 0x88);\n\t\t\tSiS_SetReg(SISCR, 0x86, 0x00);\n\t\t\treg = SiS_GetReg(SISCR, 0x86);\n\t\t\tSiS_SetReg(SISCR, 0x86, 0x88);\n\t\t\treg = SiS_GetReg(SISCR, 0x86);\n\t\t\tSiS_SetReg(SISCR, 0x86, bios[regb + 0x168]);\n\t\t\tSiS_SetReg(SISCR, 0x82, 0x77);\n\t\t\tSiS_SetReg(SISCR, 0x85, 0x00);\n\t\t\treg = SiS_GetReg(SISCR, 0x85);\n\t\t\tSiS_SetReg(SISCR, 0x85, 0x88);\n\t\t\treg = SiS_GetReg(SISCR, 0x85);\n\t\t\tSiS_SetReg(SISCR, 0x85, bios[regb + 0x160]);\n\t\t\tSiS_SetReg(SISCR, 0x82, bios[regb + 0x158]);\n\t\t}\n\t\tif(ivideo->chip == XGI_40) {\n\t\t\tSiS_SetReg(SISCR, 0x97, 0x00);\n\t\t}\n\t\tSiS_SetReg(SISCR, 0x98, 0x01);\n\t\tSiS_SetReg(SISCR, 0x9a, 0x02);\n\n\t\tSiS_SetReg(SISSR, 0x18, 0x01);\n\t\tif((ivideo->chip == XGI_20) ||\n\t\t   (ivideo->revision_id == 2)) {\n\t\t\tSiS_SetReg(SISSR, 0x19, 0x40);\n\t\t} else {\n\t\t\tSiS_SetReg(SISSR, 0x19, 0x20);\n\t\t}\n\t\tSiS_SetReg(SISSR, 0x16, 0x00);\n\t\tSiS_SetReg(SISSR, 0x16, 0x80);\n\t\tif((ivideo->chip == XGI_20) || (bios[0x1cb] != 0x0c)) {\n\t\t\tsisfb_post_xgi_delay(ivideo, 0x43);\n\t\t\tsisfb_post_xgi_delay(ivideo, 0x43);\n\t\t\tsisfb_post_xgi_delay(ivideo, 0x43);\n\t\t\tSiS_SetReg(SISSR, 0x18, 0x00);\n\t\t\tif((ivideo->chip == XGI_20) ||\n\t\t\t   (ivideo->revision_id == 2)) {\n\t\t\t\tSiS_SetReg(SISSR, 0x19, 0x40);\n\t\t\t} else {\n\t\t\t\tSiS_SetReg(SISSR, 0x19, 0x20);\n\t\t\t}\n\t\t} else if((ivideo->chip == XGI_40) && (bios[0x1cb] == 0x0c)) {\n\t\t\t   \n\t\t}\n\t\tSiS_SetReg(SISSR, 0x16, 0x00);\n\t\tSiS_SetReg(SISSR, 0x16, 0x80);\n\t\tsisfb_post_xgi_delay(ivideo, 4);\n\t\tv1 = 0x31; v2 = 0x03; v3 = 0x83; v4 = 0x03; v5 = 0x83;\n\t\tif(ivideo->haveXGIROM) {\n\t\t\tv1 = bios[0xf0];\n\t\t\tindex = (ivideo->chip == XGI_20) ? 0x4b2 : 0x53e;\n\t\t\tv2 = bios[index];\n\t\t\tv3 = bios[index + 1];\n\t\t\tv4 = bios[index + 2];\n\t\t\tv5 = bios[index + 3];\n\t\t}\n\t\tSiS_SetReg(SISSR, 0x18, v1);\n\t\tSiS_SetReg(SISSR, 0x19, ((ivideo->chip == XGI_20) ? 0x02 : 0x01));\n\t\tSiS_SetReg(SISSR, 0x16, v2);\n\t\tSiS_SetReg(SISSR, 0x16, v3);\n\t\tsisfb_post_xgi_delay(ivideo, 0x43);\n\t\tSiS_SetReg(SISSR, 0x1b, 0x03);\n\t\tsisfb_post_xgi_delay(ivideo, 0x22);\n\t\tSiS_SetReg(SISSR, 0x18, v1);\n\t\tSiS_SetReg(SISSR, 0x19, 0x00);\n\t\tSiS_SetReg(SISSR, 0x16, v4);\n\t\tSiS_SetReg(SISSR, 0x16, v5);\n\t\tSiS_SetReg(SISSR, 0x1b, 0x00);\n\t\tbreak;\n\tcase 1:\n\t\tsisfb_post_xgi_ddr2(ivideo, regb);\n\t\tbreak;\n\tdefault:\n\t\tsisfb_post_xgi_setclocks(ivideo, regb);\n\t\tif((ivideo->chip == XGI_40) &&\n\t\t   ((ivideo->revision_id == 1) ||\n\t\t    (ivideo->revision_id == 2))) {\n\t\t\tSiS_SetReg(SISCR, 0x82, bios[regb + 0x158]);\n\t\t\tSiS_SetReg(SISCR, 0x85, bios[regb + 0x160]);\n\t\t\tSiS_SetReg(SISCR, 0x86, bios[regb + 0x168]);\n\t\t} else {\n\t\t\tSiS_SetReg(SISCR, 0x82, 0x88);\n\t\t\tSiS_SetReg(SISCR, 0x86, 0x00);\n\t\t\treg = SiS_GetReg(SISCR, 0x86);\n\t\t\tSiS_SetReg(SISCR, 0x86, 0x88);\n\t\t\tSiS_SetReg(SISCR, 0x82, 0x77);\n\t\t\tSiS_SetReg(SISCR, 0x85, 0x00);\n\t\t\treg = SiS_GetReg(SISCR, 0x85);\n\t\t\tSiS_SetReg(SISCR, 0x85, 0x88);\n\t\t\treg = SiS_GetReg(SISCR, 0x85);\n\t\t\tv1 = cs160[regb]; v2 = cs158[regb];\n\t\t\tif(ivideo->haveXGIROM) {\n\t\t\t\tv1 = bios[regb + 0x160];\n\t\t\t\tv2 = bios[regb + 0x158];\n\t\t\t}\n\t\t\tSiS_SetReg(SISCR, 0x85, v1);\n\t\t\tSiS_SetReg(SISCR, 0x82, v2);\n\t\t}\n\t\tif(ivideo->chip == XGI_40) {\n\t\t\tSiS_SetReg(SISCR, 0x97, 0x11);\n\t\t}\n\t\tif((ivideo->chip == XGI_40) && (ivideo->revision_id == 2)) {\n\t\t\tSiS_SetReg(SISCR, 0x98, 0x01);\n\t\t} else {\n\t\t\tSiS_SetReg(SISCR, 0x98, 0x03);\n\t\t}\n\t\tSiS_SetReg(SISCR, 0x9a, 0x02);\n\n\t\tif(ivideo->chip == XGI_40) {\n\t\t\tSiS_SetReg(SISSR, 0x18, 0x01);\n\t\t} else {\n\t\t\tSiS_SetReg(SISSR, 0x18, 0x00);\n\t\t}\n\t\tSiS_SetReg(SISSR, 0x19, 0x40);\n\t\tSiS_SetReg(SISSR, 0x16, 0x00);\n\t\tSiS_SetReg(SISSR, 0x16, 0x80);\n\t\tif((ivideo->chip == XGI_40) && (bios[0x1cb] != 0x0c)) {\n\t\t\tsisfb_post_xgi_delay(ivideo, 0x43);\n\t\t\tsisfb_post_xgi_delay(ivideo, 0x43);\n\t\t\tsisfb_post_xgi_delay(ivideo, 0x43);\n\t\t\tSiS_SetReg(SISSR, 0x18, 0x00);\n\t\t\tSiS_SetReg(SISSR, 0x19, 0x40);\n\t\t\tSiS_SetReg(SISSR, 0x16, 0x00);\n\t\t\tSiS_SetReg(SISSR, 0x16, 0x80);\n\t\t}\n\t\tsisfb_post_xgi_delay(ivideo, 4);\n\t\tv1 = 0x31;\n\t\tif(ivideo->haveXGIROM) {\n\t\t\tv1 = bios[0xf0];\n\t\t}\n\t\tSiS_SetReg(SISSR, 0x18, v1);\n\t\tSiS_SetReg(SISSR, 0x19, 0x01);\n\t\tif(ivideo->chip == XGI_40) {\n\t\t\tSiS_SetReg(SISSR, 0x16, bios[0x53e]);\n\t\t\tSiS_SetReg(SISSR, 0x16, bios[0x53f]);\n\t\t} else {\n\t\t\tSiS_SetReg(SISSR, 0x16, 0x05);\n\t\t\tSiS_SetReg(SISSR, 0x16, 0x85);\n\t\t}\n\t\tsisfb_post_xgi_delay(ivideo, 0x43);\n\t\tif(ivideo->chip == XGI_40) {\n\t\t\tSiS_SetReg(SISSR, 0x1b, 0x01);\n\t\t} else {\n\t\t\tSiS_SetReg(SISSR, 0x1b, 0x03);\n\t\t}\n\t\tsisfb_post_xgi_delay(ivideo, 0x22);\n\t\tSiS_SetReg(SISSR, 0x18, v1);\n\t\tSiS_SetReg(SISSR, 0x19, 0x00);\n\t\tif(ivideo->chip == XGI_40) {\n\t\t\tSiS_SetReg(SISSR, 0x16, bios[0x540]);\n\t\t\tSiS_SetReg(SISSR, 0x16, bios[0x541]);\n\t\t} else {\n\t\t\tSiS_SetReg(SISSR, 0x16, 0x05);\n\t\t\tSiS_SetReg(SISSR, 0x16, 0x85);\n\t\t}\n\t\tSiS_SetReg(SISSR, 0x1b, 0x00);\n\t}\n\n\tregb = 0;\t \n\tv1 = 0x03;\n\tif(ivideo->haveXGIROM) {\n\t\tv1 = bios[0x110 + regb];\n\t}\n\tSiS_SetReg(SISSR, 0x1b, v1);\n\n\t \n\tv1 = 0x00; v2 = 0x00;\n\tif(ivideo->haveXGIROM) {\n\t\tv1 = bios[0x62];\n\t\tv2 = bios[0x63];\n\t}\n\tregb = 0;\t \n\tregd = 1 << regb;\n\tif((v1 & 0x40) && (v2 & regd) && ivideo->haveXGIROM) {\n\n\t\tSiS_SetReg(SISSR, 0x13, bios[regb + 0xe0]);\n\t\tSiS_SetReg(SISSR, 0x14, bios[regb + 0xe0 + 8]);\n\n\t} else {\n\t\tint err;\n\n\t\t \n\t\tivideo->SiS_Pr.SiS_UseOEM = false;\n\t\tSiS_SetEnableDstn(&ivideo->SiS_Pr, false);\n\t\tSiS_SetEnableFstn(&ivideo->SiS_Pr, false);\n\t\tivideo->curFSTN = ivideo->curDSTN = 0;\n\t\tivideo->SiS_Pr.VideoMemorySize = 8 << 20;\n\t\tSiSSetMode(&ivideo->SiS_Pr, 0x2e | 0x80);\n\n\t\tSiS_SetReg(SISSR, 0x05, 0x86);\n\n\t\t \n\t\tSiS_SetRegAND(SISSR, 0x21, 0xdf);\n\t\terr = sisfb_post_xgi_ramsize(ivideo);\n\t\t \n\t\tSiS_SetRegOR(SISSR, 0x21, 0x20);\n\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"%s: RAM size detection failed: %d\\n\",\n\t\t\t\t__func__, err);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#if 0\n\tprintk(KERN_DEBUG \"-----------------\\n\");\n\tfor(i = 0; i < 0xff; i++) {\n\t\treg = SiS_GetReg(SISCR, i);\n\t\tprintk(KERN_DEBUG \"CR%02x(%x) = 0x%02x\\n\", i, SISCR, reg);\n\t}\n\tfor(i = 0; i < 0x40; i++) {\n\t\treg = SiS_GetReg(SISSR, i);\n\t\tprintk(KERN_DEBUG \"SR%02x(%x) = 0x%02x\\n\", i, SISSR, reg);\n\t}\n\tprintk(KERN_DEBUG \"-----------------\\n\");\n#endif\n\n\t \n\tif(ivideo->chip == XGI_20) {\n\t\tSiS_SetRegOR(SISCR, 0x32, 0x20);\n\t} else {\n\t\treg = SiS_GetReg(SISPART4, 0x00);\n\t\tif((reg == 1) || (reg == 2)) {\n\t\t\tsisfb_sense_crt1(ivideo);\n\t\t} else {\n\t\t\tSiS_SetRegOR(SISCR, 0x32, 0x20);\n\t\t}\n\t}\n\n\t \n\tivideo->SiS_Pr.SiS_UseOEM = false;\n\tSiS_SetEnableDstn(&ivideo->SiS_Pr, false);\n\tSiS_SetEnableFstn(&ivideo->SiS_Pr, false);\n\tivideo->curFSTN = ivideo->curDSTN = 0;\n\tSiSSetMode(&ivideo->SiS_Pr, 0x2e | 0x80);\n\n\tSiS_SetReg(SISSR, 0x05, 0x86);\n\n\t \n\tSiS_SetRegOR(SISSR, 0x01, 0x20);\n\n\t \n\tSiS_SetReg(SISCR, 0x34, 0x2e);\n\n\t \n\tivideo->modeprechange = 0x2e;\n\n\tif(ivideo->chip == XGI_40) {\n\t\treg = SiS_GetReg(SISCR, 0xca);\n\t\tv1 = SiS_GetReg(SISCR, 0xcc);\n\t\tif((reg & 0x10) && (!(v1 & 0x04))) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"sisfb: Please connect power to the card.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n#endif\n\nstatic int sisfb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct sisfb_chip_info\t*chipinfo = &sisfb_chip_info[ent->driver_data];\n\tstruct sis_video_info\t*ivideo = NULL;\n\tstruct fb_info\t\t*sis_fb_info = NULL;\n\tu16 reg16;\n\tu8  reg;\n\tint i, ret;\n\n\tif(sisfb_off)\n\t\treturn -ENXIO;\n\n\tret = aperture_remove_conflicting_pci_devices(pdev, \"sisfb\");\n\tif (ret)\n\t\treturn ret;\n\n\tsis_fb_info = framebuffer_alloc(sizeof(*ivideo), &pdev->dev);\n\tif(!sis_fb_info)\n\t\treturn -ENOMEM;\n\n\tivideo = (struct sis_video_info *)sis_fb_info->par;\n\tivideo->memyselfandi = sis_fb_info;\n\n\tivideo->sisfb_id = SISFB_ID;\n\n\tif(card_list == NULL) {\n\t\tivideo->cardnumber = 0;\n\t} else {\n\t\tstruct sis_video_info *countvideo = card_list;\n\t\tivideo->cardnumber = 1;\n\t\twhile((countvideo = countvideo->next) != NULL)\n\t\t\tivideo->cardnumber++;\n\t}\n\n\tstrscpy(ivideo->myid, chipinfo->chip_name, sizeof(ivideo->myid));\n\n\tivideo->warncount = 0;\n\tivideo->chip_id = pdev->device;\n\tivideo->chip_vendor = pdev->vendor;\n\tivideo->revision_id = pdev->revision;\n\tivideo->SiS_Pr.ChipRevision = ivideo->revision_id;\n\tpci_read_config_word(pdev, PCI_COMMAND, &reg16);\n\tivideo->sisvga_enabled = reg16 & 0x01;\n\tivideo->pcibus = pdev->bus->number;\n\tivideo->pcislot = PCI_SLOT(pdev->devfn);\n\tivideo->pcifunc = PCI_FUNC(pdev->devfn);\n\tivideo->subsysvendor = pdev->subsystem_vendor;\n\tivideo->subsysdevice = pdev->subsystem_device;\n\n#ifndef MODULE\n\tif(sisfb_mode_idx == -1) {\n\t\tsisfb_get_vga_mode_from_kernel();\n\t}\n#endif\n\n\tivideo->chip = chipinfo->chip;\n\tivideo->chip_real_id = chipinfo->chip;\n\tivideo->sisvga_engine = chipinfo->vgaengine;\n\tivideo->hwcursor_size = chipinfo->hwcursor_size;\n\tivideo->CRT2_write_enable = chipinfo->CRT2_write_enable;\n\tivideo->mni = chipinfo->mni;\n\n\tivideo->detectedpdc  = 0xff;\n\tivideo->detectedpdca = 0xff;\n\tivideo->detectedlcda = 0xff;\n\n\tivideo->sisfb_thismonitor.datavalid = false;\n\n\tivideo->current_base = 0;\n\n\tivideo->engineok = 0;\n\n\tivideo->sisfb_was_boot_device = 0;\n\n\tif(pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW) {\n\t\tif(ivideo->sisvga_enabled)\n\t\t\tivideo->sisfb_was_boot_device = 1;\n\t\telse {\n\t\t\tprintk(KERN_DEBUG \"sisfb: PCI device is disabled, \"\n\t\t\t\t\"but marked as boot video device ???\\n\");\n\t\t\tprintk(KERN_DEBUG \"sisfb: I will not accept this \"\n\t\t\t\t\"as the primary VGA device\\n\");\n\t\t}\n\t}\n\n\tivideo->sisfb_parm_mem = sisfb_parm_mem;\n\tivideo->sisfb_accel = sisfb_accel;\n\tivideo->sisfb_ypan = sisfb_ypan;\n\tivideo->sisfb_max = sisfb_max;\n\tivideo->sisfb_userom = sisfb_userom;\n\tivideo->sisfb_useoem = sisfb_useoem;\n\tivideo->sisfb_mode_idx = sisfb_mode_idx;\n\tivideo->sisfb_parm_rate = sisfb_parm_rate;\n\tivideo->sisfb_crt1off = sisfb_crt1off;\n\tivideo->sisfb_forcecrt1 = sisfb_forcecrt1;\n\tivideo->sisfb_crt2type = sisfb_crt2type;\n\tivideo->sisfb_crt2flags = sisfb_crt2flags;\n\t \n\tivideo->sisfb_dstn = sisfb_dstn;\n\tivideo->sisfb_fstn = sisfb_fstn;\n\tivideo->sisfb_tvplug = sisfb_tvplug;\n\tivideo->sisfb_tvstd = sisfb_tvstd;\n\tivideo->tvxpos = sisfb_tvxposoffset;\n\tivideo->tvypos = sisfb_tvyposoffset;\n\tivideo->sisfb_nocrt2rate = sisfb_nocrt2rate;\n\tivideo->refresh_rate = 0;\n\tif(ivideo->sisfb_parm_rate != -1) {\n\t\tivideo->refresh_rate = ivideo->sisfb_parm_rate;\n\t}\n\n\tivideo->SiS_Pr.UsePanelScaler = sisfb_scalelcd;\n\tivideo->SiS_Pr.CenterScreen = -1;\n\tivideo->SiS_Pr.SiS_CustomT = sisfb_specialtiming;\n\tivideo->SiS_Pr.LVDSHL = sisfb_lvdshl;\n\n\tivideo->SiS_Pr.SiS_Backup70xx = 0xff;\n\tivideo->SiS_Pr.SiS_CHOverScan = -1;\n\tivideo->SiS_Pr.SiS_ChSW = false;\n\tivideo->SiS_Pr.SiS_UseLCDA = false;\n\tivideo->SiS_Pr.HaveEMI = false;\n\tivideo->SiS_Pr.HaveEMILCD = false;\n\tivideo->SiS_Pr.OverruleEMI = false;\n\tivideo->SiS_Pr.SiS_SensibleSR11 = false;\n\tivideo->SiS_Pr.SiS_MyCR63 = 0x63;\n\tivideo->SiS_Pr.PDC  = -1;\n\tivideo->SiS_Pr.PDCA = -1;\n\tivideo->SiS_Pr.DDCPortMixup = false;\n#ifdef CONFIG_FB_SIS_315\n\tif(ivideo->chip >= SIS_330) {\n\t\tivideo->SiS_Pr.SiS_MyCR63 = 0x53;\n\t\tif(ivideo->chip >= SIS_661) {\n\t\t\tivideo->SiS_Pr.SiS_SensibleSR11 = true;\n\t\t}\n\t}\n#endif\n\n\tmemcpy(&ivideo->default_var, &my_default_var, sizeof(my_default_var));\n\n\tpci_set_drvdata(pdev, ivideo);\n\n\t \n\tif((ivideo->nbridge = sisfb_get_northbridge(ivideo->chip))) {\n\t\tswitch(ivideo->nbridge->device) {\n#ifdef CONFIG_FB_SIS_300\n\t\tcase PCI_DEVICE_ID_SI_730:\n\t\t\tivideo->chip = SIS_730;\n\t\t\tstrcpy(ivideo->myid, \"SiS 730\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_FB_SIS_315\n\t\tcase PCI_DEVICE_ID_SI_651:\n\t\t\t \n\t\t\tstrcpy(ivideo->myid, \"SiS 651\");\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_SI_740:\n\t\t\tivideo->chip = SIS_740;\n\t\t\tstrcpy(ivideo->myid, \"SiS 740\");\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_SI_661:\n\t\t\tivideo->chip = SIS_661;\n\t\t\tstrcpy(ivideo->myid, \"SiS 661\");\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_SI_741:\n\t\t\tivideo->chip = SIS_741;\n\t\t\tstrcpy(ivideo->myid, \"SiS 741\");\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_SI_760:\n\t\t\tivideo->chip = SIS_760;\n\t\t\tstrcpy(ivideo->myid, \"SiS 760\");\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_SI_761:\n\t\t\tivideo->chip = SIS_761;\n\t\t\tstrcpy(ivideo->myid, \"SiS 761\");\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tivideo->SiS_Pr.ChipType = ivideo->chip;\n\n\tivideo->SiS_Pr.ivideo = (void *)ivideo;\n\n#ifdef CONFIG_FB_SIS_315\n\tif((ivideo->SiS_Pr.ChipType == SIS_315PRO) ||\n\t   (ivideo->SiS_Pr.ChipType == SIS_315)) {\n\t\tivideo->SiS_Pr.ChipType = SIS_315H;\n\t}\n#endif\n\n\tif(!ivideo->sisvga_enabled) {\n\t\tif(pci_enable_device(pdev)) {\n\t\t\tpci_dev_put(ivideo->nbridge);\n\t\t\tframebuffer_release(sis_fb_info);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tivideo->video_base = pci_resource_start(pdev, 0);\n\tivideo->video_size = pci_resource_len(pdev, 0);\n\tivideo->mmio_base  = pci_resource_start(pdev, 1);\n\tivideo->mmio_size  = pci_resource_len(pdev, 1);\n\tivideo->SiS_Pr.RelIO = pci_resource_start(pdev, 2) + 0x30;\n\tivideo->SiS_Pr.IOAddress = ivideo->vga_base = ivideo->SiS_Pr.RelIO;\n\n\tSiSRegInit(&ivideo->SiS_Pr, ivideo->SiS_Pr.IOAddress);\n\n#ifdef CONFIG_FB_SIS_300\n\t \n\tif(ivideo->chip == SIS_630) {\n\t\ti = 0;\n        \tdo {\n\t\t\tif(mychswtable[i].subsysVendor == ivideo->subsysvendor &&\n\t\t\t   mychswtable[i].subsysCard   == ivideo->subsysdevice) {\n\t\t\t\tivideo->SiS_Pr.SiS_ChSW = true;\n\t\t\t\tprintk(KERN_DEBUG \"sisfb: Identified [%s %s] \"\n\t\t\t\t\t\"requiring Chrontel/GPIO setup\\n\",\n\t\t\t\t\tmychswtable[i].vendorName,\n\t\t\t\t\tmychswtable[i].cardName);\n\t\t\t\tivideo->lpcdev = pci_get_device(PCI_VENDOR_ID_SI, 0x0008, NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t} while(mychswtable[i].subsysVendor != 0);\n\t}\n#endif\n\n#ifdef CONFIG_FB_SIS_315\n\tif((ivideo->chip == SIS_760) && (ivideo->nbridge)) {\n\t\tivideo->lpcdev = pci_get_slot(ivideo->nbridge->bus, (2 << 3));\n\t}\n#endif\n\n\tSiS_SetReg(SISSR, 0x05, 0x86);\n\n\tif( (!ivideo->sisvga_enabled)\n#if !defined(__i386__) && !defined(__x86_64__)\n\t\t\t      || (sisfb_resetcard)\n#endif\n\t\t\t\t\t\t   ) {\n\t\tfor(i = 0x30; i <= 0x3f; i++) {\n\t\t\tSiS_SetReg(SISCR, i, 0x00);\n\t\t}\n\t}\n\n\t \n\tivideo->modeprechange = 0x03;\n\treg = SiS_GetReg(SISCR, 0x34);\n\tif(reg & 0x7f) {\n\t\tivideo->modeprechange = reg & 0x7f;\n\t} else if(ivideo->sisvga_enabled) {\n#if defined(__i386__) || defined(__x86_64__)\n\t\tunsigned char __iomem *tt = ioremap(0x400, 0x100);\n\t\tif(tt) {\n\t\t\tivideo->modeprechange = readb(tt + 0x49);\n\t\t\tiounmap(tt);\n\t\t}\n#endif\n\t}\n\n\t \n\tivideo->bios_abase = NULL;\n\tivideo->SiS_Pr.VirtualRomBase = NULL;\n\tivideo->SiS_Pr.UseROM = false;\n\tivideo->haveXGIROM = ivideo->SiS_Pr.SiS_XGIROM = false;\n\tif(ivideo->sisfb_userom) {\n\t\tivideo->SiS_Pr.VirtualRomBase = sisfb_find_rom(pdev);\n\t\tivideo->bios_abase = ivideo->SiS_Pr.VirtualRomBase;\n\t\tivideo->SiS_Pr.UseROM = (bool)(ivideo->SiS_Pr.VirtualRomBase);\n\t\tprintk(KERN_INFO \"sisfb: Video ROM %sfound\\n\",\n\t\t\tivideo->SiS_Pr.UseROM ? \"\" : \"not \");\n\t\tif((ivideo->SiS_Pr.UseROM) && (ivideo->chip >= XGI_20)) {\n\t\t   ivideo->SiS_Pr.UseROM = false;\n\t\t   ivideo->haveXGIROM = ivideo->SiS_Pr.SiS_XGIROM = true;\n\t\t   if( (ivideo->revision_id == 2) &&\n\t\t       (!(ivideo->bios_abase[0x1d1] & 0x01)) ) {\n\t\t\tivideo->SiS_Pr.DDCPortMixup = true;\n\t\t   }\n\t\t}\n\t} else {\n\t\tprintk(KERN_INFO \"sisfb: Video ROM usage disabled\\n\");\n\t}\n\n\t \n\tif(ivideo->SiS_Pr.SiS_CustomT == CUT_NONE) {\n\t\tsisfb_detect_custom_timing(ivideo);\n\t}\n\n#ifdef CONFIG_FB_SIS_315\n\tif (ivideo->chip == XGI_20) {\n\t\t \n\t\tSiS_SetRegOR(SISCR, 0x4a, 0x40);\t \n\t\treg = SiS_GetReg(SISCR, 0x48);\n\t\tif (reg & 0x02) {\t\t\t \n\t\t\tivideo->chip_real_id = XGI_21;\n\t\t\tdev_info(&pdev->dev, \"Z9 detected\\n\");\n\t\t}\n\t}\n#endif\n\n\t \n\tif( (!ivideo->sisvga_enabled)\n#if !defined(__i386__) && !defined(__x86_64__)\n\t\t\t     || (sisfb_resetcard)\n#endif\n\t\t\t\t\t\t ) {\n#ifdef CONFIG_FB_SIS_300\n\t\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t\t\tif(ivideo->chip == SIS_300) {\n\t\t\t\tsisfb_post_sis300(pdev);\n\t\t\t\tivideo->sisfb_can_post = 1;\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef CONFIG_FB_SIS_315\n\t\tif (ivideo->sisvga_engine == SIS_315_VGA) {\n\t\t\tint result = 1;\n\n\t\t\tif (ivideo->chip == XGI_20) {\n\t\t\t\tresult = sisfb_post_xgi(pdev);\n\t\t\t\tivideo->sisfb_can_post = 1;\n\t\t\t} else if ((ivideo->chip == XGI_40) && ivideo->haveXGIROM) {\n\t\t\t\tresult = sisfb_post_xgi(pdev);\n\t\t\t\tivideo->sisfb_can_post = 1;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_INFO \"sisfb: Card is not \"\n\t\t\t\t\t\"POSTed and sisfb can't do this either.\\n\");\n\t\t\t}\n\t\t\tif (!result) {\n\t\t\t\tprintk(KERN_ERR \"sisfb: Failed to POST card\\n\");\n\t\t\t\tret = -ENODEV;\n\t\t\t\tgoto error_3;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tivideo->sisfb_card_posted = 1;\n\n\t \n\tif(sisfb_get_dram_size(ivideo)) {\n\t\tprintk(KERN_INFO \"sisfb: Fatal error: Unable to determine VRAM size.\\n\");\n\t\tret = -ENODEV;\n\t\tgoto error_3;\n\t}\n\n\n\t \n\tif((ivideo->sisfb_mode_idx < 0) ||\n\t   ((sisbios_mode[ivideo->sisfb_mode_idx].mode_no[ivideo->mni]) != 0xFF)) {\n\t\t \n\t\tSiS_SetRegOR(SISSR, IND_SIS_PCI_ADDRESS_SET, (SIS_PCI_ADDR_ENABLE | SIS_MEM_MAP_IO_ENABLE));\n\t\t \n\t\tSiS_SetRegOR(SISSR, IND_SIS_MODULE_ENABLE, SIS_ENABLE_2D);\n\t}\n\n\tif(sisfb_pdc != 0xff) {\n\t\tif(ivideo->sisvga_engine == SIS_300_VGA)\n\t\t\tsisfb_pdc &= 0x3c;\n\t\telse\n\t\t\tsisfb_pdc &= 0x1f;\n\t\tivideo->SiS_Pr.PDC = sisfb_pdc;\n\t}\n#ifdef CONFIG_FB_SIS_315\n\tif(ivideo->sisvga_engine == SIS_315_VGA) {\n\t\tif(sisfb_pdca != 0xff)\n\t\t\tivideo->SiS_Pr.PDCA = sisfb_pdca & 0x1f;\n\t}\n#endif\n\n\tif(!request_mem_region(ivideo->video_base, ivideo->video_size, \"sisfb FB\")) {\n\t\tprintk(KERN_ERR \"sisfb: Fatal error: Unable to reserve %dMB framebuffer memory\\n\",\n\t\t\t\t(int)(ivideo->video_size >> 20));\n\t\tprintk(KERN_ERR \"sisfb: Is there another framebuffer driver active?\\n\");\n\t\tret = -ENODEV;\n\t\tgoto error_3;\n\t}\n\n\tif(!request_mem_region(ivideo->mmio_base, ivideo->mmio_size, \"sisfb MMIO\")) {\n\t\tprintk(KERN_ERR \"sisfb: Fatal error: Unable to reserve MMIO region\\n\");\n\t\tret = -ENODEV;\n\t\tgoto error_2;\n\t}\n\n\tivideo->video_vbase = ioremap_wc(ivideo->video_base, ivideo->video_size);\n\tivideo->SiS_Pr.VideoMemoryAddress = ivideo->video_vbase;\n\tif(!ivideo->video_vbase) {\n\t\tprintk(KERN_ERR \"sisfb: Fatal error: Unable to map framebuffer memory\\n\");\n\t\tret = -ENODEV;\n\t\tgoto error_1;\n\t}\n\n\tivideo->mmio_vbase = ioremap(ivideo->mmio_base, ivideo->mmio_size);\n\tif(!ivideo->mmio_vbase) {\n\t\tprintk(KERN_ERR \"sisfb: Fatal error: Unable to map MMIO region\\n\");\n\t\tret = -ENODEV;\nerror_0:\tiounmap(ivideo->video_vbase);\nerror_1:\trelease_mem_region(ivideo->video_base, ivideo->video_size);\nerror_2:\trelease_mem_region(ivideo->mmio_base, ivideo->mmio_size);\nerror_3:\tvfree(ivideo->bios_abase);\n\t\tpci_dev_put(ivideo->lpcdev);\n\t\tpci_dev_put(ivideo->nbridge);\n\t\tif(!ivideo->sisvga_enabled)\n\t\t\tpci_disable_device(pdev);\n\t\tframebuffer_release(sis_fb_info);\n\t\treturn ret;\n\t}\n\n\tprintk(KERN_INFO \"sisfb: Video RAM at 0x%lx, mapped to 0x%lx, size %ldk\\n\",\n\t\tivideo->video_base, (unsigned long)ivideo->video_vbase, ivideo->video_size / 1024);\n\n\tif(ivideo->video_offset) {\n\t\tprintk(KERN_INFO \"sisfb: Viewport offset %ldk\\n\",\n\t\t\tivideo->video_offset / 1024);\n\t}\n\n\tprintk(KERN_INFO \"sisfb: MMIO at 0x%lx, mapped to 0x%lx, size %ldk\\n\",\n\t\tivideo->mmio_base, (unsigned long)ivideo->mmio_vbase, ivideo->mmio_size / 1024);\n\n\n\t \n\tif(ivideo->sisvga_engine == SIS_300_VGA) {\n\t\tivideo->cmdQueueSize = TURBO_QUEUE_AREA_SIZE;\n\t} else {\n\t\tif(ivideo->chip == XGI_20) {\n\t\t\tivideo->cmdQueueSize = COMMAND_QUEUE_AREA_SIZE_Z7;\n\t\t} else {\n\t\t\tivideo->cmdQueueSize = COMMAND_QUEUE_AREA_SIZE;\n\t\t}\n\t}\n\n\t \n\n\t \n\tivideo->hwcursor_vbase = ivideo->video_vbase\n\t\t\t\t + ivideo->video_size\n\t\t\t\t - ivideo->cmdQueueSize\n\t\t\t\t - ivideo->hwcursor_size;\n\tivideo->caps |= HW_CURSOR_CAP;\n\n\t \n\tif((ivideo->havenoheap = sisfb_heap_init(ivideo))) {\n\t\tprintk(KERN_WARNING \"sisfb: Failed to initialize offscreen memory heap\\n\");\n\t}\n\n\t \n\tivideo->SiS_Pr.VideoMemoryAddress += ivideo->video_offset;\n\tivideo->SiS_Pr.VideoMemorySize = ivideo->sisfb_mem;\n\n\tivideo->vbflags = 0;\n\tivideo->lcddefmodeidx = DEFAULT_LCDMODE;\n\tivideo->tvdefmodeidx  = DEFAULT_TVMODE;\n\tivideo->defmodeidx    = DEFAULT_MODE;\n\n\tivideo->newrom = 0;\n\tif(ivideo->chip < XGI_20) {\n\t\tif(ivideo->bios_abase) {\n\t\t\tivideo->newrom = SiSDetermineROMLayout661(&ivideo->SiS_Pr);\n\t\t}\n\t}\n\n\tif((ivideo->sisfb_mode_idx < 0) ||\n\t   ((sisbios_mode[ivideo->sisfb_mode_idx].mode_no[ivideo->mni]) != 0xFF)) {\n\n\t\tsisfb_sense_crt1(ivideo);\n\n\t\tsisfb_get_VB_type(ivideo);\n\n\t\tif(ivideo->vbflags2 & VB2_VIDEOBRIDGE) {\n\t\t\tsisfb_detect_VB_connect(ivideo);\n\t\t}\n\n\t\tivideo->currentvbflags = ivideo->vbflags & (VB_VIDEOBRIDGE | TV_STANDARD);\n\n\t\t \n\t\tif(ivideo->vbflags2 & VB2_VIDEOBRIDGE) {\n\t\t\tif(ivideo->sisfb_crt2type != -1) {\n\t\t\t\tif((ivideo->sisfb_crt2type == CRT2_LCD) &&\n\t\t\t\t   (ivideo->vbflags & CRT2_LCD)) {\n\t\t\t\t\tivideo->currentvbflags |= CRT2_LCD;\n\t\t\t\t} else if(ivideo->sisfb_crt2type != CRT2_LCD) {\n\t\t\t\t\tivideo->currentvbflags |= ivideo->sisfb_crt2type;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif((ivideo->sisvga_engine == SIS_300_VGA) &&\n\t\t\t\t   (ivideo->vbflags2 & VB2_CHRONTEL)) {\n\t\t\t\t\tif(ivideo->vbflags & CRT2_LCD)\n\t\t\t\t\t\tivideo->currentvbflags |= CRT2_LCD;\n\t\t\t\t\telse if(ivideo->vbflags & CRT2_TV)\n\t\t\t\t\t\tivideo->currentvbflags |= CRT2_TV;\n\t\t\t\t\telse if(ivideo->vbflags & CRT2_VGA)\n\t\t\t\t\t\tivideo->currentvbflags |= CRT2_VGA;\n\t\t\t\t} else {\n\t\t\t\t\tif(ivideo->vbflags & CRT2_TV)\n\t\t\t\t\t\tivideo->currentvbflags |= CRT2_TV;\n\t\t\t\t\telse if(ivideo->vbflags & CRT2_LCD)\n\t\t\t\t\t\tivideo->currentvbflags |= CRT2_LCD;\n\t\t\t\t\telse if(ivideo->vbflags & CRT2_VGA)\n\t\t\t\t\t\tivideo->currentvbflags |= CRT2_VGA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ivideo->vbflags & CRT2_LCD) {\n\t\t\tsisfb_detect_lcd_type(ivideo);\n\t\t}\n\n\t\tsisfb_save_pdc_emi(ivideo);\n\n\t\tif(!ivideo->sisfb_crt1off) {\n\t\t\tsisfb_handle_ddc(ivideo, &ivideo->sisfb_thismonitor, 0);\n\t\t} else {\n\t\t\tif((ivideo->vbflags2 & VB2_SISTMDSBRIDGE) &&\n\t\t\t   (ivideo->vbflags & (CRT2_VGA | CRT2_LCD))) {\n\t\t\t\tsisfb_handle_ddc(ivideo, &ivideo->sisfb_thismonitor, 1);\n\t\t\t}\n\t\t}\n\n\t\tif(ivideo->sisfb_mode_idx >= 0) {\n\t\t\tint bu = ivideo->sisfb_mode_idx;\n\t\t\tivideo->sisfb_mode_idx = sisfb_validate_mode(ivideo,\n\t\t\t\t\tivideo->sisfb_mode_idx, ivideo->currentvbflags);\n\t\t\tif(bu != ivideo->sisfb_mode_idx) {\n\t\t\t\tprintk(KERN_ERR \"Mode %dx%dx%d failed validation\\n\",\n\t\t\t\t\tsisbios_mode[bu].xres,\n\t\t\t\t\tsisbios_mode[bu].yres,\n\t\t\t\t\tsisbios_mode[bu].bpp);\n\t\t\t}\n\t\t}\n\n\t\tif(ivideo->sisfb_mode_idx < 0) {\n\t\t\tswitch(ivideo->currentvbflags & VB_DISPTYPE_DISP2) {\n\t\t\t   case CRT2_LCD:\n\t\t\t\tivideo->sisfb_mode_idx = ivideo->lcddefmodeidx;\n\t\t\t\tbreak;\n\t\t\t   case CRT2_TV:\n\t\t\t\tivideo->sisfb_mode_idx = ivideo->tvdefmodeidx;\n\t\t\t\tbreak;\n\t\t\t   default:\n\t\t\t\tivideo->sisfb_mode_idx = ivideo->defmodeidx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tivideo->mode_no = sisbios_mode[ivideo->sisfb_mode_idx].mode_no[ivideo->mni];\n\n\t\tif(ivideo->refresh_rate != 0) {\n\t\t\tsisfb_search_refresh_rate(ivideo, ivideo->refresh_rate,\n\t\t\t\t\t\tivideo->sisfb_mode_idx);\n\t\t}\n\n\t\tif(ivideo->rate_idx == 0) {\n\t\t\tivideo->rate_idx = sisbios_mode[ivideo->sisfb_mode_idx].rate_idx;\n\t\t\tivideo->refresh_rate = 60;\n\t\t}\n\n\t\tif(ivideo->sisfb_thismonitor.datavalid) {\n\t\t\tif(!sisfb_verify_rate(ivideo, &ivideo->sisfb_thismonitor,\n\t\t\t\t\t\tivideo->sisfb_mode_idx,\n\t\t\t\t\t\tivideo->rate_idx,\n\t\t\t\t\t\tivideo->refresh_rate)) {\n\t\t\t\tprintk(KERN_INFO \"sisfb: WARNING: Refresh rate \"\n\t\t\t\t\t\t\t\"exceeds monitor specs!\\n\");\n\t\t\t}\n\t\t}\n\n\t\tivideo->video_bpp = sisbios_mode[ivideo->sisfb_mode_idx].bpp;\n\t\tivideo->video_width = sisbios_mode[ivideo->sisfb_mode_idx].xres;\n\t\tivideo->video_height = sisbios_mode[ivideo->sisfb_mode_idx].yres;\n\n\t\tsisfb_set_vparms(ivideo);\n\n\t\tprintk(KERN_INFO \"sisfb: Default mode is %dx%dx%d (%dHz)\\n\",\n\t\t\tivideo->video_width, ivideo->video_height, ivideo->video_bpp,\n\t\t\tivideo->refresh_rate);\n\n\t\t \n\t\tivideo->default_var.xres = ivideo->default_var.xres_virtual = ivideo->video_width;\n\t\tivideo->default_var.yres = ivideo->default_var.yres_virtual = ivideo->video_height;\n\t\tivideo->default_var.bits_per_pixel = ivideo->video_bpp;\n\n\t\tsisfb_bpp_to_var(ivideo, &ivideo->default_var);\n\n\t\tivideo->default_var.pixclock = (u32) (1000000000 /\n\t\t\tsisfb_mode_rate_to_dclock(&ivideo->SiS_Pr, ivideo->mode_no, ivideo->rate_idx));\n\n\t\tif(sisfb_mode_rate_to_ddata(&ivideo->SiS_Pr, ivideo->mode_no,\n\t\t\t\t\t\tivideo->rate_idx, &ivideo->default_var)) {\n\t\t\tif((ivideo->default_var.vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {\n\t\t\t\tivideo->default_var.pixclock <<= 1;\n\t\t\t}\n\t\t}\n\n\t\tif(ivideo->sisfb_ypan) {\n\t\t\t \n\t\t\tivideo->default_var.yres_virtual =\n\t\t\t\tsisfb_calc_maxyres(ivideo, &ivideo->default_var);\n\t\t\tif(ivideo->default_var.yres_virtual < ivideo->default_var.yres) {\n\t\t\t\tivideo->default_var.yres_virtual = ivideo->default_var.yres;\n\t\t\t}\n\t\t}\n\n\t\tsisfb_calc_pitch(ivideo, &ivideo->default_var);\n\n\t\tivideo->accel = 0;\n\t\tif(ivideo->sisfb_accel) {\n\t\t\tivideo->accel = -1;\n#ifdef STUPID_ACCELF_TEXT_SHIT\n\t\t\tivideo->default_var.accel_flags |= FB_ACCELF_TEXT;\n#endif\n\t\t}\n\t\tsisfb_initaccel(ivideo);\n\n#if defined(FBINFO_HWACCEL_DISABLED) && defined(FBINFO_HWACCEL_XPAN)\n\t\tsis_fb_info->flags = FBINFO_HWACCEL_YPAN\t|\n\t\t\t\t     FBINFO_HWACCEL_XPAN \t|\n\t\t\t\t     FBINFO_HWACCEL_COPYAREA \t|\n\t\t\t\t     FBINFO_HWACCEL_FILLRECT \t|\n\t\t\t\t     ((ivideo->accel) ? 0 : FBINFO_HWACCEL_DISABLED);\n#endif\n\t\tsis_fb_info->var = ivideo->default_var;\n\t\tsis_fb_info->fix = ivideo->sisfb_fix;\n\t\tsis_fb_info->screen_base = ivideo->video_vbase + ivideo->video_offset;\n\t\tsis_fb_info->fbops = &sisfb_ops;\n\t\tsis_fb_info->pseudo_palette = ivideo->pseudo_palette;\n\n\t\tfb_alloc_cmap(&sis_fb_info->cmap, 256 , 0);\n\n\t\tprintk(KERN_DEBUG \"sisfb: Initial vbflags 0x%x\\n\", (int)ivideo->vbflags);\n\n\t\tivideo->wc_cookie = arch_phys_wc_add(ivideo->video_base,\n\t\t\t\t\t\t     ivideo->video_size);\n\t\tif(register_framebuffer(sis_fb_info) < 0) {\n\t\t\tprintk(KERN_ERR \"sisfb: Fatal error: Failed to register framebuffer\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tiounmap(ivideo->mmio_vbase);\n\t\t\tgoto error_0;\n\t\t}\n\n\t\tivideo->registered = 1;\n\n\t\t \n\t\tivideo->next = card_list;\n\t\tcard_list = ivideo;\n\n\t\tprintk(KERN_INFO \"sisfb: 2D acceleration is %s, y-panning %s\\n\",\n\t\t\tivideo->sisfb_accel ? \"enabled\" : \"disabled\",\n\t\t\tivideo->sisfb_ypan  ?\n\t\t\t\t(ivideo->sisfb_max ? \"enabled (auto-max)\" :\n\t\t\t\t\t\t\"enabled (no auto-max)\") :\n\t\t\t\t\t\t\t\t\t\"disabled\");\n\n\n\t\tfb_info(sis_fb_info, \"%s frame buffer device version %d.%d.%d\\n\",\n\t\t\tivideo->myid, VER_MAJOR, VER_MINOR, VER_LEVEL);\n\n\t\tprintk(KERN_INFO \"sisfb: Copyright (C) 2001-2005 Thomas Winischhofer\\n\");\n\n\t}\t \n\n\treturn 0;\n}\n\n \n \n \n\nstatic void sisfb_remove(struct pci_dev *pdev)\n{\n\tstruct sis_video_info\t*ivideo = pci_get_drvdata(pdev);\n\tstruct fb_info\t\t*sis_fb_info = ivideo->memyselfandi;\n\tint\t\t\tregistered = ivideo->registered;\n\tint\t\t\tmodechanged = ivideo->modechanged;\n\n\t \n\tiounmap(ivideo->mmio_vbase);\n\tiounmap(ivideo->video_vbase);\n\n\t \n\trelease_mem_region(ivideo->video_base, ivideo->video_size);\n\trelease_mem_region(ivideo->mmio_base, ivideo->mmio_size);\n\n\tvfree(ivideo->bios_abase);\n\n\tpci_dev_put(ivideo->lpcdev);\n\n\tpci_dev_put(ivideo->nbridge);\n\n\tarch_phys_wc_del(ivideo->wc_cookie);\n\n\t \n\tif(!ivideo->sisvga_enabled)\n\t\tpci_disable_device(pdev);\n\n\t \n\tif(ivideo->registered) {\n\t\tunregister_framebuffer(sis_fb_info);\n\t\tframebuffer_release(sis_fb_info);\n\t}\n\n\t \n\n\t \n\tif(registered && modechanged)\n\t\tprintk(KERN_INFO\n\t\t\t\"sisfb: Restoring of text mode not supported yet\\n\");\n};\n\nstatic struct pci_driver sisfb_driver = {\n\t.name\t\t= \"sisfb\",\n\t.id_table \t= sisfb_pci_table,\n\t.probe\t\t= sisfb_probe,\n\t.remove \t= sisfb_remove,\n};\n\nstatic int __init sisfb_init(void)\n{\n#ifndef MODULE\n\tchar *options = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"sisfb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif(fb_get_options(\"sisfb\", &options))\n\t\treturn -ENODEV;\n\n\tsisfb_setup(options);\n#endif\n\treturn pci_register_driver(&sisfb_driver);\n}\n\n#ifndef MODULE\nmodule_init(sisfb_init);\n#endif\n\n \n \n \n\n#ifdef MODULE\n\nstatic char\t\t*mode = NULL;\nstatic int\t\tvesa = -1;\nstatic unsigned int\trate = 0;\nstatic unsigned int\tcrt1off = 1;\nstatic unsigned int\tmem = 0;\nstatic char\t\t*forcecrt2type = NULL;\nstatic int\t\tforcecrt1 = -1;\nstatic int\t\tpdc = -1;\nstatic int\t\tpdc1 = -1;\nstatic int\t\tnoaccel = -1;\nstatic int\t\tnoypan  = -1;\nstatic int\t\tnomax = -1;\nstatic int\t\tuserom = -1;\nstatic int\t\tuseoem = -1;\nstatic char\t\t*tvstandard = NULL;\nstatic int\t\tnocrt2rate = 0;\nstatic int\t\tscalelcd = -1;\nstatic char\t\t*specialtiming = NULL;\nstatic int\t\tlvdshl = -1;\nstatic int\t\ttvxposoffset = 0, tvyposoffset = 0;\n#if !defined(__i386__) && !defined(__x86_64__)\nstatic int\t\tresetcard = 0;\nstatic int\t\tvideoram = 0;\n#endif\n\nstatic int __init sisfb_init_module(void)\n{\n\tsisfb_setdefaultparms();\n\n\tif(rate)\n\t\tsisfb_parm_rate = rate;\n\n\tif((scalelcd == 0) || (scalelcd == 1))\n\t\tsisfb_scalelcd = scalelcd ^ 1;\n\n\t \n\n\tif(forcecrt2type)\n\t\tsisfb_search_crt2type(forcecrt2type);\n\n\tif(tvstandard)\n\t\tsisfb_search_tvstd(tvstandard);\n\n\tif(mode)\n\t\tsisfb_search_mode(mode, false);\n\telse if(vesa != -1)\n\t\tsisfb_search_vesamode(vesa, false);\n\n\tsisfb_crt1off = (crt1off == 0) ? 1 : 0;\n\n\tsisfb_forcecrt1 = forcecrt1;\n\tif(forcecrt1 == 1)\n\t\tsisfb_crt1off = 0;\n\telse if(forcecrt1 == 0)\n\t\tsisfb_crt1off = 1;\n\n\tif(noaccel == 1)\n\t\tsisfb_accel = 0;\n\telse if(noaccel == 0)\n\t\tsisfb_accel = 1;\n\n\tif(noypan == 1)\n\t\tsisfb_ypan = 0;\n\telse if(noypan == 0)\n\t\tsisfb_ypan = 1;\n\n\tif(nomax == 1)\n\t\tsisfb_max = 0;\n\telse if(nomax == 0)\n\t\tsisfb_max = 1;\n\n\tif(mem)\n\t\tsisfb_parm_mem = mem;\n\n\tif(userom != -1)\n\t\tsisfb_userom = userom;\n\n\tif(useoem != -1)\n\t\tsisfb_useoem = useoem;\n\n        if(pdc != -1)\n\t\tsisfb_pdc  = (pdc  & 0x7f);\n\n\tif(pdc1 != -1)\n\t\tsisfb_pdca = (pdc1 & 0x1f);\n\n\tsisfb_nocrt2rate = nocrt2rate;\n\n\tif(specialtiming)\n\t\tsisfb_search_specialtiming(specialtiming);\n\n\tif((lvdshl >= 0) && (lvdshl <= 3))\n\t\tsisfb_lvdshl = lvdshl;\n\n\tsisfb_tvxposoffset = tvxposoffset;\n\tsisfb_tvyposoffset = tvyposoffset;\n\n#if !defined(__i386__) && !defined(__x86_64__)\n\tsisfb_resetcard = (resetcard) ? 1 : 0;\n\tif(videoram)\n\t\tsisfb_videoram = videoram;\n#endif\n\n\treturn sisfb_init();\n}\n\nstatic void __exit sisfb_remove_module(void)\n{\n\tpci_unregister_driver(&sisfb_driver);\n\tprintk(KERN_DEBUG \"sisfb: Module unloaded\\n\");\n}\n\nmodule_init(sisfb_init_module);\nmodule_exit(sisfb_remove_module);\n\nMODULE_DESCRIPTION(\"SiS 300/540/630/730/315/55x/65x/661/74x/330/76x/34x, XGI V3XT/V5/V8/Z7 framebuffer device driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Thomas Winischhofer <thomas@winischhofer.net>, Others\");\n\nmodule_param(mem, int, 0);\nmodule_param(noaccel, int, 0);\nmodule_param(noypan, int, 0);\nmodule_param(nomax, int, 0);\nmodule_param(userom, int, 0);\nmodule_param(useoem, int, 0);\nmodule_param(mode, charp, 0);\nmodule_param(vesa, int, 0);\nmodule_param(rate, int, 0);\nmodule_param(forcecrt1, int, 0);\nmodule_param(forcecrt2type, charp, 0);\nmodule_param(scalelcd, int, 0);\nmodule_param(pdc, int, 0);\nmodule_param(pdc1, int, 0);\nmodule_param(specialtiming, charp, 0);\nmodule_param(lvdshl, int, 0);\nmodule_param(tvstandard, charp, 0);\nmodule_param(tvxposoffset, int, 0);\nmodule_param(tvyposoffset, int, 0);\nmodule_param(nocrt2rate, int, 0);\n#if !defined(__i386__) && !defined(__x86_64__)\nmodule_param(resetcard, int, 0);\nmodule_param(videoram, int, 0);\n#endif\n\nMODULE_PARM_DESC(mem,\n\t\"\\nDetermines the beginning of the video memory heap in KB. This heap is used\\n\"\n\t  \"for video RAM management for eg. DRM/DRI. On 300 series, the default depends\\n\"\n\t  \"on the amount of video RAM available. If 8MB of video RAM or less is available,\\n\"\n\t  \"the heap starts at 4096KB, if between 8 and 16MB are available at 8192KB,\\n\"\n\t  \"otherwise at 12288KB. On 315/330/340 series, the heap size is 32KB by default.\\n\"\n\t  \"The value is to be specified without 'KB'.\\n\");\n\nMODULE_PARM_DESC(noaccel,\n\t\"\\nIf set to anything other than 0, 2D acceleration will be disabled.\\n\"\n\t  \"(default: 0)\\n\");\n\nMODULE_PARM_DESC(noypan,\n\t\"\\nIf set to anything other than 0, y-panning will be disabled and scrolling\\n\"\n\t  \"will be performed by redrawing the screen. (default: 0)\\n\");\n\nMODULE_PARM_DESC(nomax,\n\t\"\\nIf y-panning is enabled, sisfb will by default use the entire available video\\n\"\n\t  \"memory for the virtual screen in order to optimize scrolling performance. If\\n\"\n\t  \"this is set to anything other than 0, sisfb will not do this and thereby \\n\"\n\t  \"enable the user to positively specify a virtual Y size of the screen using\\n\"\n\t  \"fbset. (default: 0)\\n\");\n\nMODULE_PARM_DESC(mode,\n\t\"\\nSelects the desired default display mode in the format XxYxDepth,\\n\"\n\t \"eg. 1024x768x16. Other formats supported include XxY-Depth and\\n\"\n\t \"XxY-Depth@Rate. If the parameter is only one (decimal or hexadecimal)\\n\"\n\t \"number, it will be interpreted as a VESA mode number. (default: 800x600x8)\\n\");\n\nMODULE_PARM_DESC(vesa,\n\t\"\\nSelects the desired default display mode by VESA defined mode number, eg.\\n\"\n\t \"0x117 (default: 0x0103)\\n\");\n\nMODULE_PARM_DESC(rate,\n\t\"\\nSelects the desired vertical refresh rate for CRT1 (external VGA) in Hz.\\n\"\n\t  \"If the mode is specified in the format XxY-Depth@Rate, this parameter\\n\"\n\t  \"will be ignored (default: 60)\\n\");\n\nMODULE_PARM_DESC(forcecrt1,\n\t\"\\nNormally, the driver autodetects whether or not CRT1 (external VGA) is \\n\"\n\t  \"connected. With this option, the detection can be overridden (1=CRT1 ON,\\n\"\n\t  \"0=CRT1 OFF) (default: [autodetected])\\n\");\n\nMODULE_PARM_DESC(forcecrt2type,\n\t\"\\nIf this option is omitted, the driver autodetects CRT2 output devices, such as\\n\"\n\t  \"LCD, TV or secondary VGA. With this option, this autodetection can be\\n\"\n\t  \"overridden. Possible parameters are LCD, TV, VGA or NONE. NONE disables CRT2.\\n\"\n\t  \"On systems with a SiS video bridge, parameters SVIDEO, COMPOSITE or SCART can\\n\"\n\t  \"be used instead of TV to override the TV detection. Furthermore, on systems\\n\"\n\t  \"with a SiS video bridge, SVIDEO+COMPOSITE, HIVISION, YPBPR480I, YPBPR480P,\\n\"\n\t  \"YPBPR720P and YPBPR1080I are understood. However, whether or not these work\\n\"\n\t  \"depends on the very hardware in use. (default: [autodetected])\\n\");\n\nMODULE_PARM_DESC(scalelcd,\n\t\"\\nSetting this to 1 will force the driver to scale the LCD image to the panel's\\n\"\n\t  \"native resolution. Setting it to 0 will disable scaling; LVDS panels will\\n\"\n\t  \"show black bars around the image, TMDS panels will probably do the scaling\\n\"\n\t  \"themselves. Default: 1 on LVDS panels, 0 on TMDS panels\\n\");\n\nMODULE_PARM_DESC(pdc,\n\t\"\\nThis is for manually selecting the LCD panel delay compensation. The driver\\n\"\n\t  \"should detect this correctly in most cases; however, sometimes this is not\\n\"\n\t  \"possible. If you see 'small waves' on the LCD, try setting this to 4, 32 or 24\\n\"\n\t  \"on a 300 series chipset; 6 on other chipsets. If the problem persists, try\\n\"\n\t  \"other values (on 300 series: between 4 and 60 in steps of 4; otherwise: any\\n\"\n\t  \"value from 0 to 31). (default: autodetected, if LCD is active during start)\\n\");\n\n#ifdef CONFIG_FB_SIS_315\nMODULE_PARM_DESC(pdc1,\n\t\"\\nThis is same as pdc, but for LCD-via CRT1. Hence, this is for the 315/330/340\\n\"\n\t  \"series only. (default: autodetected if LCD is in LCD-via-CRT1 mode during\\n\"\n\t  \"startup) - Note: currently, this has no effect because LCD-via-CRT1 is not\\n\"\n\t  \"implemented yet.\\n\");\n#endif\n\nMODULE_PARM_DESC(specialtiming,\n\t\"\\nPlease refer to documentation for more information on this option.\\n\");\n\nMODULE_PARM_DESC(lvdshl,\n\t\"\\nPlease refer to documentation for more information on this option.\\n\");\n\nMODULE_PARM_DESC(tvstandard,\n\t\"\\nThis allows overriding the BIOS default for the TV standard. Valid choices are\\n\"\n\t  \"pal, ntsc, palm and paln. (default: [auto; pal or ntsc only])\\n\");\n\nMODULE_PARM_DESC(tvxposoffset,\n\t\"\\nRelocate TV output horizontally. Possible parameters: -32 through 32.\\n\"\n\t  \"Default: 0\\n\");\n\nMODULE_PARM_DESC(tvyposoffset,\n\t\"\\nRelocate TV output vertically. Possible parameters: -32 through 32.\\n\"\n\t  \"Default: 0\\n\");\n\nMODULE_PARM_DESC(nocrt2rate,\n\t\"\\nSetting this to 1 will force the driver to use the default refresh rate for\\n\"\n\t  \"CRT2 if CRT2 type is VGA. (default: 0, use same rate as CRT1)\\n\");\n\n#if !defined(__i386__) && !defined(__x86_64__)\n#ifdef CONFIG_FB_SIS_300\nMODULE_PARM_DESC(resetcard,\n\t\"\\nSet this to 1 in order to reset (POST) the card on non-x86 machines where\\n\"\n\t  \"the BIOS did not POST the card (only supported for SiS 300/305 and XGI cards\\n\"\n\t  \"currently). Default: 0\\n\");\n\nMODULE_PARM_DESC(videoram,\n\t\"\\nSet this to the amount of video RAM (in kilobyte) the card has. Required on\\n\"\n\t  \"some non-x86 architectures where the memory auto detection fails. Only\\n\"\n\t  \"relevant if resetcard is set, too. SiS300/305 only. Default: [auto-detect]\\n\");\n#endif\n#endif\n\n#endif \t    \n\n \nEXPORT_SYMBOL(sis_malloc);\nEXPORT_SYMBOL(sis_free);\nEXPORT_SYMBOL_GPL(sis_malloc_new);\nEXPORT_SYMBOL_GPL(sis_free_new);\n\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}