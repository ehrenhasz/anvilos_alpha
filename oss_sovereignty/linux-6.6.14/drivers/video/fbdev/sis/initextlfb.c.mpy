{
  "module_name": "initextlfb.c",
  "hash_id": "ec8dc87424798577aa926077ff1b7c12590b50c4dfe0ca55e203764e38699405",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/sis/initextlfb.c",
  "human_readable_source": "\n \n\n#include \"initdef.h\"\n#include \"vgatypes.h\"\n#include \"vstruct.h\"\n\n#include <linux/types.h>\n#include <linux/fb.h>\n\nint\t\tsisfb_mode_rate_to_dclock(struct SiS_Private *SiS_Pr,\n\t\t\tunsigned char modeno, unsigned char rateindex);\nint\t\tsisfb_mode_rate_to_ddata(struct SiS_Private *SiS_Pr, unsigned char modeno,\n\t\t\tunsigned char rateindex, struct fb_var_screeninfo *var);\nbool\t\tsisfb_gettotalfrommode(struct SiS_Private *SiS_Pr, unsigned char modeno,\n\t\t\tint *htotal, int *vtotal, unsigned char rateindex);\n\nextern bool\tSiSInitPtr(struct SiS_Private *SiS_Pr);\nextern bool\tSiS_SearchModeID(struct SiS_Private *SiS_Pr, unsigned short *ModeNo,\n\t\t\tunsigned short *ModeIdIndex);\nextern void\tSiS_Generic_ConvertCRData(struct SiS_Private *SiS_Pr, unsigned char *crdata,\n\t\t\tint xres, int yres, struct fb_var_screeninfo *var, bool writeres);\n\nint\nsisfb_mode_rate_to_dclock(struct SiS_Private *SiS_Pr, unsigned char modeno,\n\t\t\tunsigned char rateindex)\n{\n    unsigned short ModeNo = modeno;\n    unsigned short ModeIdIndex = 0, ClockIndex = 0;\n    unsigned short RRTI = 0;\n    int Clock;\n\n    if(!SiSInitPtr(SiS_Pr)) return 65000;\n\n    if(rateindex > 0) rateindex--;\n\n#ifdef CONFIG_FB_SIS_315\n    switch(ModeNo) {\n    case 0x5a: ModeNo = 0x50; break;\n    case 0x5b: ModeNo = 0x56;\n    }\n#endif\n\n    if(!(SiS_SearchModeID(SiS_Pr, &ModeNo, &ModeIdIndex))) {\n       printk(KERN_ERR \"Could not find mode %x\\n\", ModeNo);\n       return 65000;\n    }\n\n    RRTI = SiS_Pr->SiS_EModeIDTable[ModeIdIndex].REFindex;\n\n    if(SiS_Pr->SiS_RefIndex[RRTI].Ext_InfoFlag & HaveWideTiming) {\n       if(SiS_Pr->SiS_UseWide == 1) {\n\t   \n\t  ClockIndex = SiS_Pr->SiS_RefIndex[RRTI].Ext_CRTVCLK_WIDE;\n       } else {\n\t  RRTI += rateindex;\n\t  ClockIndex = SiS_Pr->SiS_RefIndex[RRTI].Ext_CRTVCLK_NORM;\n       }\n    } else {\n       RRTI += rateindex;\n       ClockIndex = SiS_Pr->SiS_RefIndex[RRTI].Ext_CRTVCLK;\n    }\n\n    Clock = SiS_Pr->SiS_VCLKData[ClockIndex].CLOCK * 1000;\n\n    return Clock;\n}\n\nint\nsisfb_mode_rate_to_ddata(struct SiS_Private *SiS_Pr, unsigned char modeno,\n\t\t\tunsigned char rateindex, struct fb_var_screeninfo *var)\n{\n    unsigned short ModeNo = modeno;\n    unsigned short ModeIdIndex = 0, index = 0, RRTI = 0;\n    int            j;\n\n    if(!SiSInitPtr(SiS_Pr)) return 0;\n\n    if(rateindex > 0) rateindex--;\n\n#ifdef CONFIG_FB_SIS_315\n    switch(ModeNo) {\n       case 0x5a: ModeNo = 0x50; break;\n       case 0x5b: ModeNo = 0x56;\n    }\n#endif\n\n    if(!(SiS_SearchModeID(SiS_Pr, &ModeNo, &ModeIdIndex))) return 0;\n\n    RRTI = SiS_Pr->SiS_EModeIDTable[ModeIdIndex].REFindex;\n    if(SiS_Pr->SiS_RefIndex[RRTI].Ext_InfoFlag & HaveWideTiming) {\n       if(SiS_Pr->SiS_UseWide == 1) {\n\t   \n\t  index = SiS_Pr->SiS_RefIndex[RRTI].Ext_CRT1CRTC_WIDE;\n       } else {\n\t  RRTI += rateindex;\n\t  index = SiS_Pr->SiS_RefIndex[RRTI].Ext_CRT1CRTC_NORM;\n       }\n    } else {\n       RRTI += rateindex;\n       index = SiS_Pr->SiS_RefIndex[RRTI].Ext_CRT1CRTC;\n    }\n\n    SiS_Generic_ConvertCRData(SiS_Pr,\n\t\t\t(unsigned char *)&SiS_Pr->SiS_CRT1Table[index].CR[0],\n\t\t\tSiS_Pr->SiS_RefIndex[RRTI].XRes,\n\t\t\tSiS_Pr->SiS_RefIndex[RRTI].YRes,\n\t\t\tvar, false);\n\n    if(SiS_Pr->SiS_RefIndex[RRTI].Ext_InfoFlag & 0x8000)\n       var->sync &= ~FB_SYNC_VERT_HIGH_ACT;\n    else\n       var->sync |= FB_SYNC_VERT_HIGH_ACT;\n\n    if(SiS_Pr->SiS_RefIndex[RRTI].Ext_InfoFlag & 0x4000)\n       var->sync &= ~FB_SYNC_HOR_HIGH_ACT;\n    else\n       var->sync |= FB_SYNC_HOR_HIGH_ACT;\n\n    var->vmode = FB_VMODE_NONINTERLACED;\n    if(SiS_Pr->SiS_RefIndex[RRTI].Ext_InfoFlag & 0x0080)\n       var->vmode = FB_VMODE_INTERLACED;\n    else {\n       j = 0;\n       while(SiS_Pr->SiS_EModeIDTable[j].Ext_ModeID != 0xff) {\n\t  if(SiS_Pr->SiS_EModeIDTable[j].Ext_ModeID ==\n\t                  SiS_Pr->SiS_RefIndex[RRTI].ModeID) {\n\t      if(SiS_Pr->SiS_EModeIDTable[j].Ext_ModeFlag & DoubleScanMode) {\n\t      \t  var->vmode = FB_VMODE_DOUBLE;\n\t      }\n\t      break;\n\t  }\n\t  j++;\n       }\n    }\n\n    if((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\n#if 0   \n       var->upper_margin <<= 1;\n       var->lower_margin <<= 1;\n       var->vsync_len <<= 1;\n#endif\n    } else if((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {\n       var->upper_margin >>= 1;\n       var->lower_margin >>= 1;\n       var->vsync_len >>= 1;\n    }\n\n    return 1;\n}\n\nbool\nsisfb_gettotalfrommode(struct SiS_Private *SiS_Pr, unsigned char modeno, int *htotal,\n\t\t\tint *vtotal, unsigned char rateindex)\n{\n    unsigned short ModeNo = modeno;\n    unsigned short ModeIdIndex = 0, CRT1Index = 0;\n    unsigned short RRTI = 0;\n    unsigned char  sr_data, cr_data, cr_data2;\n\n    if(!SiSInitPtr(SiS_Pr)) return false;\n\n    if(rateindex > 0) rateindex--;\n\n#ifdef CONFIG_FB_SIS_315\n    switch(ModeNo) {\n       case 0x5a: ModeNo = 0x50; break;\n       case 0x5b: ModeNo = 0x56;\n    }\n#endif\n\n    if(!(SiS_SearchModeID(SiS_Pr, &ModeNo, &ModeIdIndex))) return false;\n\n    RRTI = SiS_Pr->SiS_EModeIDTable[ModeIdIndex].REFindex;\n    if(SiS_Pr->SiS_RefIndex[RRTI].Ext_InfoFlag & HaveWideTiming) {\n       if(SiS_Pr->SiS_UseWide == 1) {\n\t   \n\t  CRT1Index = SiS_Pr->SiS_RefIndex[RRTI].Ext_CRT1CRTC_WIDE;\n       } else {\n\t  RRTI += rateindex;\n\t  CRT1Index = SiS_Pr->SiS_RefIndex[RRTI].Ext_CRT1CRTC_NORM;\n       }\n    } else {\n       RRTI += rateindex;\n       CRT1Index = SiS_Pr->SiS_RefIndex[RRTI].Ext_CRT1CRTC;\n    }\n\n    sr_data = SiS_Pr->SiS_CRT1Table[CRT1Index].CR[14];\n    cr_data = SiS_Pr->SiS_CRT1Table[CRT1Index].CR[0];\n    *htotal = (((cr_data & 0xff) | ((unsigned short) (sr_data & 0x03) << 8)) + 5) * 8;\n\n    sr_data = SiS_Pr->SiS_CRT1Table[CRT1Index].CR[13];\n    cr_data = SiS_Pr->SiS_CRT1Table[CRT1Index].CR[6];\n    cr_data2 = SiS_Pr->SiS_CRT1Table[CRT1Index].CR[7];\n    *vtotal = ((cr_data & 0xFF) |\n\t       ((unsigned short)(cr_data2 & 0x01) <<  8) |\n\t       ((unsigned short)(cr_data2 & 0x20) <<  4) |\n\t       ((unsigned short)(sr_data  & 0x01) << 10)) + 2;\n\n    if(SiS_Pr->SiS_RefIndex[RRTI].Ext_InfoFlag & InterlaceMode)\n       *vtotal *= 2;\n\n    return true;\n}\n\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}