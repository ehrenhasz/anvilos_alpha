{
  "module_name": "skeletonfb.c",
  "hash_id": "aa72d44e3637fa11dad7cbf6a78866cfa974ae24c9539ba0bd6021902a6b9ae5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/skeletonfb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n\n     \n\n \nstatic char *mode_option;\n\n \n\n \nstruct xxx_par;\n\n \nstatic const struct fb_fix_screeninfo xxxfb_fix = {\n\t.id =\t\t\"FB's name\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_PSEUDOCOLOR,\n\t.xpanstep =\t1,\n\t.ypanstep =\t1,\n\t.ywrapstep =\t1,\n\t.accel =\tFB_ACCEL_NONE,\n};\n\n     \n\n     \nstatic struct fb_info info;\n\n     \nstatic struct xxx_par __initdata current_par;\n\n \nstatic int xxxfb_open(struct fb_info *info, int user)\n{\n    return 0;\n}\n\n \nstatic int xxxfb_release(struct fb_info *info, int user)\n{\n    return 0;\n}\n\n \nstatic int xxxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n     \n    return 0;\n}\n\n \nstatic int xxxfb_set_par(struct fb_info *info)\n{\n    struct xxx_par *par = info->par;\n     \n    return 0;\n}\n\n \nstatic int xxxfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t   unsigned blue, unsigned transp,\n\t\t\t   struct fb_info *info)\n{\n    if (regno >= 256)   \n       return -EINVAL;\n     \n\n     \n    if (info->var.grayscale) {\n        \n       red = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n    }\n\n     \n\n     \n#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)\n    red = CNVT_TOHW(red, info->var.red.length);\n    green = CNVT_TOHW(green, info->var.green.length);\n    blue = CNVT_TOHW(blue, info->var.blue.length);\n    transp = CNVT_TOHW(transp, info->var.transp.length);\n#undef CNVT_TOHW\n     \n    if (info->fix.visual == FB_VISUAL_DIRECTCOLOR ||\n\tinfo->fix.visual == FB_VISUAL_TRUECOLOR)\n\t    write_{red|green|blue|transp}_to_clut();\n\n     \n    if (info->fix.visual == FB_VISUAL_TRUECOLOR ||\n\tinfo->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t    u32 v;\n\n\t    if (regno >= 16)\n\t\t    return -EINVAL;\n\n\t    v = (red << info->var.red.offset) |\n\t\t    (green << info->var.green.offset) |\n\t\t    (blue << info->var.blue.offset) |\n\t\t    (transp << info->var.transp.offset);\n\n\t    ((u32*)(info->pseudo_palette))[regno] = v;\n    }\n\n     \n    return 0;\n}\n\n \nstatic int xxxfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n     \n\n     \n\n     \n    return 0;\n}\n\n \nstatic int xxxfb_blank(int blank_mode, struct fb_info *info)\n{\n     \n    return 0;\n}\n\n \n\n \n\n \nvoid xxxfb_fillrect(struct fb_info *p, const struct fb_fillrect *region)\n{\n \n}\n\n \nvoid xxxfb_copyarea(struct fb_info *p, const struct fb_copyarea *area)\n{\n \n}\n\n\n \nvoid xxxfb_imageblit(struct fb_info *p, const struct fb_image *image)\n{\n \n\n \n}\n\n \nint xxxfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n \n}\n\n \nint xxxfb_sync(struct fb_info *info)\n{\n\treturn 0;\n}\n\n     \n\nstatic const struct fb_ops xxxfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= xxxfb_open,\n\t.fb_read\t= xxxfb_read,\n\t.fb_write\t= xxxfb_write,\n\t.fb_release\t= xxxfb_release,\n\t.fb_check_var\t= xxxfb_check_var,\n\t.fb_set_par\t= xxxfb_set_par,\n\t.fb_setcolreg\t= xxxfb_setcolreg,\n\t.fb_blank\t= xxxfb_blank,\n\t.fb_pan_display\t= xxxfb_pan_display,\n\t.fb_fillrect\t= xxxfb_fillrect, \t \n\t.fb_copyarea\t= xxxfb_copyarea,\t \n\t.fb_imageblit\t= xxxfb_imageblit,\t \n\t.fb_cursor\t= xxxfb_cursor,\t\t \n\t.fb_sync\t= xxxfb_sync,\n\t.fb_ioctl\t= xxxfb_ioctl,\n\t.fb_mmap\t= xxxfb_mmap,\n};\n\n \n\n     \n\n \nstatic int xxxfb_probe(struct pci_dev *dev, const struct pci_device_id *ent)\n{\n    struct fb_info *info;\n    struct xxx_par *par;\n    struct device *device = &dev->dev;  \n    int cmap_len, retval;\n\n     \n    retval = aperture_remove_conflicting_pci_devices(pdev, \"xxxfb\");\n    if (retval)\n\t    return retval;\n\n     \n    info = framebuffer_alloc(sizeof(struct xxx_par), device);\n\n    if (!info) {\n\t     \n    }\n\n    par = info->par;\n\n     \n    info->screen_base = framebuffer_virtual_memory;\n    info->fbops = &xxxfb_ops;\n    info->fix = xxxfb_fix;\n    info->pseudo_palette = pseudo_palette;  \n     \n    info->flags = 0;\n\n \n      \n\n     \n    info->pixmap.addr = kmalloc(PIXMAP_SIZE, GFP_KERNEL);\n    if (!info->pixmap.addr) {\n\t     \n    }\n\n    info->pixmap.size = PIXMAP_SIZE;\n\n     \n    info->pixmap.flags = FB_PIXMAP_SYSTEM;\n\n     \n    info->pixmap.scan_align = 4;\n\n     \n    info->pixmap.buf_align = 4;\n\n     \n    info->pixmap.access_align = 32;\n \n\n     \n    if (!mode_option)\n\tmode_option = \"640x480@60\";\n\n    retval = fb_find_mode(&info->var, info, mode_option, NULL, 0, NULL, 8);\n\n    if (!retval || retval == 4)\n\treturn -EINVAL;\n\n     \n    if (fb_alloc_cmap(&info->cmap, cmap_len, 0))\n\treturn -ENOMEM;\n\n     \n    info->var = xxxfb_var;\n\n     \n    xxxfb_check_var(&info->var, info);\n\n     \n     \n\n    if (register_framebuffer(info) < 0) {\n\tfb_dealloc_cmap(&info->cmap);\n\treturn -EINVAL;\n    }\n    fb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n    pci_set_drvdata(dev, info);  \n    return 0;\n}\n\n     \n \nstatic void xxxfb_remove(struct pci_dev *dev)\n{\n\tstruct fb_info *info = pci_get_drvdata(dev);\n\t \n\n\tif (info) {\n\t\tunregister_framebuffer(info);\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\t \n\t\tframebuffer_release(info);\n\t}\n}\n\n#ifdef CONFIG_PCI\n#ifdef CONFIG_PM\n \nstatic int xxxfb_suspend(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct xxxfb_par *par = info->par;\n\n\t \n\treturn 0;\n}\n\n \nstatic int xxxfb_resume(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct xxxfb_par *par = info->par;\n\n\t \n\treturn 0;\n}\n#else\n#define xxxfb_suspend NULL\n#define xxxfb_resume NULL\n#endif  \n\nstatic const struct pci_device_id xxxfb_id_table[] = {\n\t{ PCI_VENDOR_ID_XXX, PCI_DEVICE_ID_XXX,\n\t  PCI_ANY_ID, PCI_ANY_ID, PCI_BASE_CLASS_DISPLAY << 16,\n\t  PCI_CLASS_MASK, 0 },\n\t{ 0, }\n};\n\nstatic SIMPLE_DEV_PM_OPS(xxxfb_pm_ops, xxxfb_suspend, xxxfb_resume);\n\n \nstatic struct pci_driver xxxfb_driver = {\n\t.name =\t\t\"xxxfb\",\n\t.id_table =\txxxfb_id_table,\n\t.probe =\txxxfb_probe,\n\t.remove =\txxxfb_remove,\n\t.driver.pm =\txxxfb_pm_ops,  \n};\n\nMODULE_DEVICE_TABLE(pci, xxxfb_id_table);\n\nstatic int __init xxxfb_init(void)\n{\n\t \n#ifndef MODULE\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"xxxfb\", &option))\n\t\treturn -ENODEV;\n\txxxfb_setup(option);\n#endif\n\n\treturn pci_register_driver(&xxxfb_driver);\n}\n\nstatic void __exit xxxfb_exit(void)\n{\n\tpci_unregister_driver(&xxxfb_driver);\n}\n#else  \n#include <linux/platform_device.h>\n \n\n#ifdef CONFIG_PM\n \nstatic int xxxfb_suspend(struct platform_device *dev, pm_message_t msg)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\tstruct xxxfb_par *par = info->par;\n\n\t \n\treturn 0;\n}\n\n \nstatic int xxxfb_resume(struct platform_dev *dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\tstruct xxxfb_par *par = info->par;\n\n\t \n\treturn 0;\n}\n#else\n#define xxxfb_suspend NULL\n#define xxxfb_resume NULL\n#endif  \n\nstatic struct platform_device_driver xxxfb_driver = {\n\t.probe = xxxfb_probe,\n\t.remove = xxxfb_remove,\n\t.suspend = xxxfb_suspend,  \n\t.resume = xxxfb_resume,    \n\t.driver = {\n\t\t.name = \"xxxfb\",\n\t},\n};\n\nstatic struct platform_device *xxxfb_device;\n\n#ifndef MODULE\n     \n\n \nstatic int __init xxxfb_setup(char *options)\n{\n     \n}\n#endif  \n\nstatic int __init xxxfb_init(void)\n{\n\tint ret;\n\t \n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"xxxfb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"xxxfb\", &option))\n\t\treturn -ENODEV;\n\txxxfb_setup(option);\n#endif\n\tret = platform_driver_register(&xxxfb_driver);\n\n\tif (!ret) {\n\t\txxxfb_device = platform_device_register_simple(\"xxxfb\", 0,\n\t\t\t\t\t\t\t\tNULL, 0);\n\n\t\tif (IS_ERR(xxxfb_device)) {\n\t\t\tplatform_driver_unregister(&xxxfb_driver);\n\t\t\tret = PTR_ERR(xxxfb_device);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit xxxfb_exit(void)\n{\n\tplatform_device_unregister(xxxfb_device);\n\tplatform_driver_unregister(&xxxfb_driver);\n}\n#endif  \n\n \n\n\n     \n\nmodule_init(xxxfb_init);\nmodule_exit(xxxfb_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}