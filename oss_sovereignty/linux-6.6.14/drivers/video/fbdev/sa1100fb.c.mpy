{
  "module_name": "sa1100fb.c",
  "hash_id": "12bfc1d8e2a9c7946a826294f2b78e82dd7d1ee85e3338fdd74e4390bc93c27e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/sa1100fb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/cpufreq.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n\n#include <video/sa1100fb.h>\n\n#include <mach/hardware.h>\n#include <asm/mach-types.h>\n\n \n#define DEBUG_VAR 1\n\n#include \"sa1100fb.h\"\n\nstatic const struct sa1100fb_rgb rgb_4 = {\n\t.red\t= { .offset = 0,  .length = 4, },\n\t.green\t= { .offset = 0,  .length = 4, },\n\t.blue\t= { .offset = 0,  .length = 4, },\n\t.transp\t= { .offset = 0,  .length = 0, },\n};\n\nstatic const struct sa1100fb_rgb rgb_8 = {\n\t.red\t= { .offset = 0,  .length = 8, },\n\t.green\t= { .offset = 0,  .length = 8, },\n\t.blue\t= { .offset = 0,  .length = 8, },\n\t.transp\t= { .offset = 0,  .length = 0, },\n};\n\nstatic const struct sa1100fb_rgb def_rgb_16 = {\n\t.red\t= { .offset = 11, .length = 5, },\n\t.green\t= { .offset = 5,  .length = 6, },\n\t.blue\t= { .offset = 0,  .length = 5, },\n\t.transp\t= { .offset = 0,  .length = 0, },\n};\n\n\n\nstatic int sa1100fb_activate_var(struct fb_var_screeninfo *var, struct sa1100fb_info *);\nstatic void set_ctrlr_state(struct sa1100fb_info *fbi, u_int state);\n\nstatic inline void sa1100fb_schedule_work(struct sa1100fb_info *fbi, u_int state)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t \n\tif (fbi->task_state == C_ENABLE && state == C_REENABLE)\n\t\tstate = (u_int) -1;\n\tif (fbi->task_state == C_DISABLE && state == C_ENABLE)\n\t\tstate = C_REENABLE;\n\n\tif (state != (u_int)-1) {\n\t\tfbi->task_state = state;\n\t\tschedule_work(&fbi->task);\n\t}\n\tlocal_irq_restore(flags);\n}\n\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\n \nstatic inline u_int palette_pbs(struct fb_var_screeninfo *var)\n{\n\tint ret = 0;\n\tswitch (var->bits_per_pixel) {\n\tcase 4:  ret = 0 << 12;\tbreak;\n\tcase 8:  ret = 1 << 12; break;\n\tcase 16: ret = 2 << 12; break;\n\t}\n\treturn ret;\n}\n\nstatic int\nsa1100fb_setpalettereg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t       u_int trans, struct fb_info *info)\n{\n\tstruct sa1100fb_info *fbi =\n\t\tcontainer_of(info, struct sa1100fb_info, fb);\n\tu_int val, ret = 1;\n\n\tif (regno < fbi->palette_size) {\n\t\tval = ((red >> 4) & 0xf00);\n\t\tval |= ((green >> 8) & 0x0f0);\n\t\tval |= ((blue >> 12) & 0x00f);\n\n\t\tif (regno == 0)\n\t\t\tval |= palette_pbs(&fbi->fb.var);\n\n\t\tfbi->palette_cpu[regno] = val;\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic int\nsa1100fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t   u_int trans, struct fb_info *info)\n{\n\tstruct sa1100fb_info *fbi =\n\t\tcontainer_of(info, struct sa1100fb_info, fb);\n\tunsigned int val;\n\tint ret = 1;\n\n\t \n\tif (fbi->inf->cmap_inverse) {\n\t\tred   = 0xffff - red;\n\t\tgreen = 0xffff - green;\n\t\tblue  = 0xffff - blue;\n\t}\n\n\t \n\tif (fbi->fb.var.grayscale)\n\t\tred = green = blue = (19595 * red + 38470 * green +\n\t\t\t\t\t7471 * blue) >> 16;\n\n\tswitch (fbi->fb.fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\t \n\t\tif (regno < 16) {\n\t\t\tval  = chan_to_field(red, &fbi->fb.var.red);\n\t\t\tval |= chan_to_field(green, &fbi->fb.var.green);\n\t\t\tval |= chan_to_field(blue, &fbi->fb.var.blue);\n\n\t\t\tfbi->pseudo_palette[regno] = val;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FB_VISUAL_STATIC_PSEUDOCOLOR:\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tret = sa1100fb_setpalettereg(regno, red, green, blue, trans, info);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_CPU_FREQ\n \nstatic inline unsigned int sa1100fb_display_dma_period(struct fb_var_screeninfo *var)\n{\n\t \n\treturn var->pixclock * 8 * 16 / var->bits_per_pixel;\n}\n#endif\n\n \nstatic int\nsa1100fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct sa1100fb_info *fbi =\n\t\tcontainer_of(info, struct sa1100fb_info, fb);\n\tint rgbidx;\n\n\tif (var->xres < MIN_XRES)\n\t\tvar->xres = MIN_XRES;\n\tif (var->yres < MIN_YRES)\n\t\tvar->yres = MIN_YRES;\n\tif (var->xres > fbi->inf->xres)\n\t\tvar->xres = fbi->inf->xres;\n\tif (var->yres > fbi->inf->yres)\n\t\tvar->yres = fbi->inf->yres;\n\tvar->xres_virtual = max(var->xres_virtual, var->xres);\n\tvar->yres_virtual = max(var->yres_virtual, var->yres);\n\n\tdev_dbg(fbi->dev, \"var->bits_per_pixel=%d\\n\", var->bits_per_pixel);\n\tswitch (var->bits_per_pixel) {\n\tcase 4:\n\t\trgbidx = RGB_4;\n\t\tbreak;\n\tcase 8:\n\t\trgbidx = RGB_8;\n\t\tbreak;\n\tcase 16:\n\t\trgbidx = RGB_16;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvar->red    = fbi->rgb[rgbidx]->red;\n\tvar->green  = fbi->rgb[rgbidx]->green;\n\tvar->blue   = fbi->rgb[rgbidx]->blue;\n\tvar->transp = fbi->rgb[rgbidx]->transp;\n\n\tdev_dbg(fbi->dev, \"RGBT length = %d:%d:%d:%d\\n\",\n\t\tvar->red.length, var->green.length, var->blue.length,\n\t\tvar->transp.length);\n\n\tdev_dbg(fbi->dev, \"RGBT offset = %d:%d:%d:%d\\n\",\n\t\tvar->red.offset, var->green.offset, var->blue.offset,\n\t\tvar->transp.offset);\n\n#ifdef CONFIG_CPU_FREQ\n\tdev_dbg(fbi->dev, \"dma period = %d ps, clock = %ld kHz\\n\",\n\t\tsa1100fb_display_dma_period(var),\n\t\tclk_get_rate(fbi->clk) / 1000);\n#endif\n\n\treturn 0;\n}\n\nstatic void sa1100fb_set_visual(struct sa1100fb_info *fbi, u32 visual)\n{\n\tif (fbi->inf->set_visual)\n\t\tfbi->inf->set_visual(visual);\n}\n\n \nstatic int sa1100fb_set_par(struct fb_info *info)\n{\n\tstruct sa1100fb_info *fbi =\n\t\tcontainer_of(info, struct sa1100fb_info, fb);\n\tstruct fb_var_screeninfo *var = &info->var;\n\tunsigned long palette_mem_size;\n\n\tdev_dbg(fbi->dev, \"set_par\\n\");\n\n\tif (var->bits_per_pixel == 16)\n\t\tfbi->fb.fix.visual = FB_VISUAL_TRUECOLOR;\n\telse if (!fbi->inf->cmap_static)\n\t\tfbi->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\telse {\n\t\t \n\t\tfbi->fb.fix.visual = FB_VISUAL_STATIC_PSEUDOCOLOR;\n\t}\n\n\tfbi->fb.fix.line_length = var->xres_virtual *\n\t\t\t\t  var->bits_per_pixel / 8;\n\tfbi->palette_size = var->bits_per_pixel == 8 ? 256 : 16;\n\n\tpalette_mem_size = fbi->palette_size * sizeof(u16);\n\n\tdev_dbg(fbi->dev, \"palette_mem_size = 0x%08lx\\n\", palette_mem_size);\n\n\tfbi->palette_cpu = (u16 *)(fbi->map_cpu + PAGE_SIZE - palette_mem_size);\n\tfbi->palette_dma = fbi->map_dma + PAGE_SIZE - palette_mem_size;\n\n\t \n\tsa1100fb_set_visual(fbi, fbi->fb.fix.visual);\n\tsa1100fb_activate_var(var, fbi);\n\n\treturn 0;\n}\n\n#if 0\nstatic int\nsa1100fb_set_cmap(struct fb_cmap *cmap, int kspc, int con,\n\t\t  struct fb_info *info)\n{\n\tstruct sa1100fb_info *fbi = (struct sa1100fb_info *)info;\n\n\t \n\tif (!kspc && (fbi->fb.var.bits_per_pixel == 16 || fbi->inf->cmap_static))\n\t\treturn -EINVAL;\n\n\treturn gen_set_cmap(cmap, kspc, con, info);\n}\n#endif\n\n \n \nstatic int sa1100fb_blank(int blank, struct fb_info *info)\n{\n\tstruct sa1100fb_info *fbi =\n\t\tcontainer_of(info, struct sa1100fb_info, fb);\n\tint i;\n\n\tdev_dbg(fbi->dev, \"sa1100fb_blank: blank=%d\\n\", blank);\n\n\tswitch (blank) {\n\tcase FB_BLANK_POWERDOWN:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_NORMAL:\n\t\tif (fbi->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR ||\n\t\t    fbi->fb.fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR)\n\t\t\tfor (i = 0; i < fbi->palette_size; i++)\n\t\t\t\tsa1100fb_setpalettereg(i, 0, 0, 0, 0, info);\n\t\tsa1100fb_schedule_work(fbi, C_DISABLE);\n\t\tbreak;\n\n\tcase FB_BLANK_UNBLANK:\n\t\tif (fbi->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR ||\n\t\t    fbi->fb.fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR)\n\t\t\tfb_set_cmap(&fbi->fb.cmap, info);\n\t\tsa1100fb_schedule_work(fbi, C_ENABLE);\n\t}\n\treturn 0;\n}\n\nstatic int sa1100fb_mmap(struct fb_info *info,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct sa1100fb_info *fbi =\n\t\tcontainer_of(info, struct sa1100fb_info, fb);\n\tunsigned long off = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (off < info->fix.smem_len) {\n\t\tvma->vm_pgoff += 1;  \n\t\treturn dma_mmap_wc(fbi->dev, vma, fbi->map_cpu, fbi->map_dma,\n\t\t\t\t   fbi->map_size);\n\t}\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\treturn vm_iomap_memory(vma, info->fix.mmio_start, info->fix.mmio_len);\n}\n\nstatic const struct fb_ops sa1100fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= sa1100fb_check_var,\n\t.fb_set_par\t= sa1100fb_set_par,\n\n\t.fb_setcolreg\t= sa1100fb_setcolreg,\n\t.fb_fillrect\t= cfb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n\t.fb_blank\t= sa1100fb_blank,\n\t.fb_mmap\t= sa1100fb_mmap,\n};\n\n \nstatic inline unsigned int get_pcd(struct sa1100fb_info *fbi,\n\t\tunsigned int pixclock)\n{\n\tunsigned int pcd = clk_get_rate(fbi->clk) / 100 / 1000;\n\n\tpcd *= pixclock;\n\tpcd /= 10000000;\n\n\treturn pcd + 1;\t \n}\n\n \nstatic int sa1100fb_activate_var(struct fb_var_screeninfo *var, struct sa1100fb_info *fbi)\n{\n\tstruct sa1100fb_lcd_reg new_regs;\n\tu_int half_screen_size, yres, pcd;\n\tu_long flags;\n\n\tdev_dbg(fbi->dev, \"Configuring SA1100 LCD\\n\");\n\n\tdev_dbg(fbi->dev, \"var: xres=%d hslen=%d lm=%d rm=%d\\n\",\n\t\tvar->xres, var->hsync_len,\n\t\tvar->left_margin, var->right_margin);\n\tdev_dbg(fbi->dev, \"var: yres=%d vslen=%d um=%d bm=%d\\n\",\n\t\tvar->yres, var->vsync_len,\n\t\tvar->upper_margin, var->lower_margin);\n\n#if DEBUG_VAR\n\tif (var->xres < 16        || var->xres > 1024)\n\t\tdev_err(fbi->dev, \"%s: invalid xres %d\\n\",\n\t\t\tfbi->fb.fix.id, var->xres);\n\tif (var->hsync_len < 1    || var->hsync_len > 64)\n\t\tdev_err(fbi->dev, \"%s: invalid hsync_len %d\\n\",\n\t\t\tfbi->fb.fix.id, var->hsync_len);\n\tif (var->left_margin < 1  || var->left_margin > 255)\n\t\tdev_err(fbi->dev, \"%s: invalid left_margin %d\\n\",\n\t\t\tfbi->fb.fix.id, var->left_margin);\n\tif (var->right_margin < 1 || var->right_margin > 255)\n\t\tdev_err(fbi->dev, \"%s: invalid right_margin %d\\n\",\n\t\t\tfbi->fb.fix.id, var->right_margin);\n\tif (var->yres < 1         || var->yres > 1024)\n\t\tdev_err(fbi->dev, \"%s: invalid yres %d\\n\",\n\t\t\tfbi->fb.fix.id, var->yres);\n\tif (var->vsync_len < 1    || var->vsync_len > 64)\n\t\tdev_err(fbi->dev, \"%s: invalid vsync_len %d\\n\",\n\t\t\tfbi->fb.fix.id, var->vsync_len);\n\tif (var->upper_margin < 0 || var->upper_margin > 255)\n\t\tdev_err(fbi->dev, \"%s: invalid upper_margin %d\\n\",\n\t\t\tfbi->fb.fix.id, var->upper_margin);\n\tif (var->lower_margin < 0 || var->lower_margin > 255)\n\t\tdev_err(fbi->dev, \"%s: invalid lower_margin %d\\n\",\n\t\t\tfbi->fb.fix.id, var->lower_margin);\n#endif\n\n\tnew_regs.lccr0 = fbi->inf->lccr0 |\n\t\tLCCR0_LEN | LCCR0_LDM | LCCR0_BAM |\n\t\tLCCR0_ERM | LCCR0_LtlEnd | LCCR0_DMADel(0);\n\n\tnew_regs.lccr1 =\n\t\tLCCR1_DisWdth(var->xres) +\n\t\tLCCR1_HorSnchWdth(var->hsync_len) +\n\t\tLCCR1_BegLnDel(var->left_margin) +\n\t\tLCCR1_EndLnDel(var->right_margin);\n\n\t \n\tyres = var->yres;\n\tif (fbi->inf->lccr0 & LCCR0_Dual)\n\t\tyres /= 2;\n\n\tnew_regs.lccr2 =\n\t\tLCCR2_DisHght(yres) +\n\t\tLCCR2_VrtSnchWdth(var->vsync_len) +\n\t\tLCCR2_BegFrmDel(var->upper_margin) +\n\t\tLCCR2_EndFrmDel(var->lower_margin);\n\n\tpcd = get_pcd(fbi, var->pixclock);\n\tnew_regs.lccr3 = LCCR3_PixClkDiv(pcd) | fbi->inf->lccr3 |\n\t\t(var->sync & FB_SYNC_HOR_HIGH_ACT ? LCCR3_HorSnchH : LCCR3_HorSnchL) |\n\t\t(var->sync & FB_SYNC_VERT_HIGH_ACT ? LCCR3_VrtSnchH : LCCR3_VrtSnchL);\n\n\tdev_dbg(fbi->dev, \"nlccr0 = 0x%08lx\\n\", new_regs.lccr0);\n\tdev_dbg(fbi->dev, \"nlccr1 = 0x%08lx\\n\", new_regs.lccr1);\n\tdev_dbg(fbi->dev, \"nlccr2 = 0x%08lx\\n\", new_regs.lccr2);\n\tdev_dbg(fbi->dev, \"nlccr3 = 0x%08lx\\n\", new_regs.lccr3);\n\n\thalf_screen_size = var->bits_per_pixel;\n\thalf_screen_size = half_screen_size * var->xres * var->yres / 16;\n\n\t \n\tlocal_irq_save(flags);\n\tfbi->dbar1 = fbi->palette_dma;\n\tfbi->dbar2 = fbi->screen_dma + half_screen_size;\n\n\tfbi->reg_lccr0 = new_regs.lccr0;\n\tfbi->reg_lccr1 = new_regs.lccr1;\n\tfbi->reg_lccr2 = new_regs.lccr2;\n\tfbi->reg_lccr3 = new_regs.lccr3;\n\tlocal_irq_restore(flags);\n\n\t \n\tif (readl_relaxed(fbi->base + LCCR0) != fbi->reg_lccr0 ||\n\t    readl_relaxed(fbi->base + LCCR1) != fbi->reg_lccr1 ||\n\t    readl_relaxed(fbi->base + LCCR2) != fbi->reg_lccr2 ||\n\t    readl_relaxed(fbi->base + LCCR3) != fbi->reg_lccr3 ||\n\t    readl_relaxed(fbi->base + DBAR1) != fbi->dbar1 ||\n\t    readl_relaxed(fbi->base + DBAR2) != fbi->dbar2)\n\t\tsa1100fb_schedule_work(fbi, C_REENABLE);\n\n\treturn 0;\n}\n\n \nstatic inline void __sa1100fb_backlight_power(struct sa1100fb_info *fbi, int on)\n{\n\tdev_dbg(fbi->dev, \"backlight o%s\\n\", on ? \"n\" : \"ff\");\n\n\tif (fbi->inf->backlight_power)\n\t\tfbi->inf->backlight_power(on);\n}\n\nstatic inline void __sa1100fb_lcd_power(struct sa1100fb_info *fbi, int on)\n{\n\tdev_dbg(fbi->dev, \"LCD power o%s\\n\", on ? \"n\" : \"ff\");\n\n\tif (fbi->inf->lcd_power)\n\t\tfbi->inf->lcd_power(on);\n}\n\nstatic void sa1100fb_setup_gpio(struct sa1100fb_info *fbi)\n{\n\tu_int mask = 0;\n\n\t \n\tif ((fbi->reg_lccr0 & LCCR0_CMS) == LCCR0_Color &&\n\t    (fbi->reg_lccr0 & (LCCR0_Dual|LCCR0_Act)) != 0) {\n\t\tmask = GPIO_LDD11 | GPIO_LDD10 | GPIO_LDD9  | GPIO_LDD8;\n\n\t\tif (fbi->fb.var.bits_per_pixel > 8 ||\n\t\t    (fbi->reg_lccr0 & (LCCR0_Dual|LCCR0_Act)) == LCCR0_Dual)\n\t\t\tmask |= GPIO_LDD15 | GPIO_LDD14 | GPIO_LDD13 | GPIO_LDD12;\n\n\t}\n\n\tif (mask) {\n\t\tunsigned long flags;\n\n\t\t \n\t\tlocal_irq_save(flags);\n\t\tGPDR |= mask;\n\t\tGAFR |= mask;\n\t\tlocal_irq_restore(flags);\n\t}\n}\n\nstatic void sa1100fb_enable_controller(struct sa1100fb_info *fbi)\n{\n\tdev_dbg(fbi->dev, \"Enabling LCD controller\\n\");\n\n\t \n\tfbi->palette_cpu[0] &= 0xcfff;\n\tfbi->palette_cpu[0] |= palette_pbs(&fbi->fb.var);\n\n\t \n\tclk_prepare_enable(fbi->clk);\n\n\t \n\twritel_relaxed(fbi->reg_lccr3, fbi->base + LCCR3);\n\twritel_relaxed(fbi->reg_lccr2, fbi->base + LCCR2);\n\twritel_relaxed(fbi->reg_lccr1, fbi->base + LCCR1);\n\twritel_relaxed(fbi->reg_lccr0 & ~LCCR0_LEN, fbi->base + LCCR0);\n\twritel_relaxed(fbi->dbar1, fbi->base + DBAR1);\n\twritel_relaxed(fbi->dbar2, fbi->base + DBAR2);\n\twritel_relaxed(fbi->reg_lccr0 | LCCR0_LEN, fbi->base + LCCR0);\n\n\tif (fbi->shannon_lcden)\n\t\tgpiod_set_value(fbi->shannon_lcden, 1);\n\n\tdev_dbg(fbi->dev, \"DBAR1: 0x%08x\\n\", readl_relaxed(fbi->base + DBAR1));\n\tdev_dbg(fbi->dev, \"DBAR2: 0x%08x\\n\", readl_relaxed(fbi->base + DBAR2));\n\tdev_dbg(fbi->dev, \"LCCR0: 0x%08x\\n\", readl_relaxed(fbi->base + LCCR0));\n\tdev_dbg(fbi->dev, \"LCCR1: 0x%08x\\n\", readl_relaxed(fbi->base + LCCR1));\n\tdev_dbg(fbi->dev, \"LCCR2: 0x%08x\\n\", readl_relaxed(fbi->base + LCCR2));\n\tdev_dbg(fbi->dev, \"LCCR3: 0x%08x\\n\", readl_relaxed(fbi->base + LCCR3));\n}\n\nstatic void sa1100fb_disable_controller(struct sa1100fb_info *fbi)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tu32 lccr0;\n\n\tdev_dbg(fbi->dev, \"Disabling LCD controller\\n\");\n\n\tif (fbi->shannon_lcden)\n\t\tgpiod_set_value(fbi->shannon_lcden, 0);\n\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tadd_wait_queue(&fbi->ctrlr_wait, &wait);\n\n\t \n\twritel_relaxed(~0, fbi->base + LCSR);\n\n\tlccr0 = readl_relaxed(fbi->base + LCCR0);\n\tlccr0 &= ~LCCR0_LDM;\t \n\twritel_relaxed(lccr0, fbi->base + LCCR0);\n\tlccr0 &= ~LCCR0_LEN;\t \n\twritel_relaxed(lccr0, fbi->base + LCCR0);\n\n\tschedule_timeout(20 * HZ / 1000);\n\tremove_wait_queue(&fbi->ctrlr_wait, &wait);\n\n\t \n\tclk_disable_unprepare(fbi->clk);\n}\n\n \nstatic irqreturn_t sa1100fb_handle_irq(int irq, void *dev_id)\n{\n\tstruct sa1100fb_info *fbi = dev_id;\n\tunsigned int lcsr = readl_relaxed(fbi->base + LCSR);\n\n\tif (lcsr & LCSR_LDD) {\n\t\tu32 lccr0 = readl_relaxed(fbi->base + LCCR0) | LCCR0_LDM;\n\t\twritel_relaxed(lccr0, fbi->base + LCCR0);\n\t\twake_up(&fbi->ctrlr_wait);\n\t}\n\n\twritel_relaxed(lcsr, fbi->base + LCSR);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void set_ctrlr_state(struct sa1100fb_info *fbi, u_int state)\n{\n\tu_int old_state;\n\n\tmutex_lock(&fbi->ctrlr_lock);\n\n\told_state = fbi->state;\n\n\t \n\tif (old_state == C_STARTUP && state == C_REENABLE)\n\t\tstate = C_ENABLE;\n\n\tswitch (state) {\n\tcase C_DISABLE_CLKCHANGE:\n\t\t \n\t\tif (old_state != C_DISABLE && old_state != C_DISABLE_PM) {\n\t\t\tfbi->state = state;\n\t\t\tsa1100fb_disable_controller(fbi);\n\t\t}\n\t\tbreak;\n\n\tcase C_DISABLE_PM:\n\tcase C_DISABLE:\n\t\t \n\t\tif (old_state != C_DISABLE) {\n\t\t\tfbi->state = state;\n\n\t\t\t__sa1100fb_backlight_power(fbi, 0);\n\t\t\tif (old_state != C_DISABLE_CLKCHANGE)\n\t\t\t\tsa1100fb_disable_controller(fbi);\n\t\t\t__sa1100fb_lcd_power(fbi, 0);\n\t\t}\n\t\tbreak;\n\n\tcase C_ENABLE_CLKCHANGE:\n\t\t \n\t\tif (old_state == C_DISABLE_CLKCHANGE) {\n\t\t\tfbi->state = C_ENABLE;\n\t\t\tsa1100fb_enable_controller(fbi);\n\t\t}\n\t\tbreak;\n\n\tcase C_REENABLE:\n\t\t \n\t\tif (old_state == C_ENABLE) {\n\t\t\tsa1100fb_disable_controller(fbi);\n\t\t\tsa1100fb_setup_gpio(fbi);\n\t\t\tsa1100fb_enable_controller(fbi);\n\t\t}\n\t\tbreak;\n\n\tcase C_ENABLE_PM:\n\t\t \n\t\tif (old_state != C_DISABLE_PM)\n\t\t\tbreak;\n\t\tfallthrough;\n\n\tcase C_ENABLE:\n\t\t \n\t\tif (old_state != C_ENABLE) {\n\t\t\tfbi->state = C_ENABLE;\n\t\t\tsa1100fb_setup_gpio(fbi);\n\t\t\t__sa1100fb_lcd_power(fbi, 1);\n\t\t\tsa1100fb_enable_controller(fbi);\n\t\t\t__sa1100fb_backlight_power(fbi, 1);\n\t\t}\n\t\tbreak;\n\t}\n\tmutex_unlock(&fbi->ctrlr_lock);\n}\n\n \nstatic void sa1100fb_task(struct work_struct *w)\n{\n\tstruct sa1100fb_info *fbi = container_of(w, struct sa1100fb_info, task);\n\tu_int state = xchg(&fbi->task_state, -1);\n\n\tset_ctrlr_state(fbi, state);\n}\n\n#ifdef CONFIG_CPU_FREQ\n \nstatic int\nsa1100fb_freq_transition(struct notifier_block *nb, unsigned long val,\n\t\t\t void *data)\n{\n\tstruct sa1100fb_info *fbi = TO_INF(nb, freq_transition);\n\tu_int pcd;\n\n\tswitch (val) {\n\tcase CPUFREQ_PRECHANGE:\n\t\tset_ctrlr_state(fbi, C_DISABLE_CLKCHANGE);\n\t\tbreak;\n\n\tcase CPUFREQ_POSTCHANGE:\n\t\tpcd = get_pcd(fbi, fbi->fb.var.pixclock);\n\t\tfbi->reg_lccr3 = (fbi->reg_lccr3 & ~0xff) | LCCR3_PixClkDiv(pcd);\n\t\tset_ctrlr_state(fbi, C_ENABLE_CLKCHANGE);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM\n \nstatic int sa1100fb_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tstruct sa1100fb_info *fbi = platform_get_drvdata(dev);\n\n\tset_ctrlr_state(fbi, C_DISABLE_PM);\n\treturn 0;\n}\n\nstatic int sa1100fb_resume(struct platform_device *dev)\n{\n\tstruct sa1100fb_info *fbi = platform_get_drvdata(dev);\n\n\tset_ctrlr_state(fbi, C_ENABLE_PM);\n\treturn 0;\n}\n#else\n#define sa1100fb_suspend\tNULL\n#define sa1100fb_resume\t\tNULL\n#endif\n\n \nstatic int sa1100fb_map_video_memory(struct sa1100fb_info *fbi)\n{\n\t \n\tfbi->map_size = PAGE_ALIGN(fbi->fb.fix.smem_len + PAGE_SIZE);\n\tfbi->map_cpu = dma_alloc_wc(fbi->dev, fbi->map_size, &fbi->map_dma,\n\t\t\t\t    GFP_KERNEL);\n\n\tif (fbi->map_cpu) {\n\t\tfbi->fb.screen_base = fbi->map_cpu + PAGE_SIZE;\n\t\tfbi->screen_dma = fbi->map_dma + PAGE_SIZE;\n\t\t \n\t\tfbi->fb.fix.smem_start = fbi->screen_dma;\n\t}\n\n\treturn fbi->map_cpu ? 0 : -ENOMEM;\n}\n\n \nstatic const struct fb_monspecs monspecs = {\n\t.hfmin\t= 30000,\n\t.hfmax\t= 70000,\n\t.vfmin\t= 50,\n\t.vfmax\t= 65,\n};\n\n\nstatic struct sa1100fb_info *sa1100fb_init_fbinfo(struct device *dev)\n{\n\tstruct sa1100fb_mach_info *inf = dev_get_platdata(dev);\n\tstruct sa1100fb_info *fbi;\n\tunsigned i;\n\n\tfbi = devm_kzalloc(dev, sizeof(struct sa1100fb_info), GFP_KERNEL);\n\tif (!fbi)\n\t\treturn NULL;\n\n\tfbi->dev = dev;\n\n\tstrcpy(fbi->fb.fix.id, SA1100_NAME);\n\n\tfbi->fb.fix.type\t= FB_TYPE_PACKED_PIXELS;\n\tfbi->fb.fix.type_aux\t= 0;\n\tfbi->fb.fix.xpanstep\t= 0;\n\tfbi->fb.fix.ypanstep\t= 0;\n\tfbi->fb.fix.ywrapstep\t= 0;\n\tfbi->fb.fix.accel\t= FB_ACCEL_NONE;\n\n\tfbi->fb.var.nonstd\t= 0;\n\tfbi->fb.var.activate\t= FB_ACTIVATE_NOW;\n\tfbi->fb.var.height\t= -1;\n\tfbi->fb.var.width\t= -1;\n\tfbi->fb.var.accel_flags\t= 0;\n\tfbi->fb.var.vmode\t= FB_VMODE_NONINTERLACED;\n\n\tfbi->fb.fbops\t\t= &sa1100fb_ops;\n\tfbi->fb.monspecs\t= monspecs;\n\tfbi->fb.pseudo_palette\t= fbi->pseudo_palette;\n\n\tfbi->rgb[RGB_4]\t\t= &rgb_4;\n\tfbi->rgb[RGB_8]\t\t= &rgb_8;\n\tfbi->rgb[RGB_16]\t= &def_rgb_16;\n\n\t \n\tif (inf->lccr3 & (LCCR3_VrtSnchL|LCCR3_HorSnchL|0xff) ||\n\t    inf->pixclock == 0)\n\t\tpanic(\"sa1100fb error: invalid LCCR3 fields set or zero \"\n\t\t\t\"pixclock.\");\n\n\tfbi->fb.var.xres\t\t= inf->xres;\n\tfbi->fb.var.xres_virtual\t= inf->xres;\n\tfbi->fb.var.yres\t\t= inf->yres;\n\tfbi->fb.var.yres_virtual\t= inf->yres;\n\tfbi->fb.var.bits_per_pixel\t= inf->bpp;\n\tfbi->fb.var.pixclock\t\t= inf->pixclock;\n\tfbi->fb.var.hsync_len\t\t= inf->hsync_len;\n\tfbi->fb.var.left_margin\t\t= inf->left_margin;\n\tfbi->fb.var.right_margin\t= inf->right_margin;\n\tfbi->fb.var.vsync_len\t\t= inf->vsync_len;\n\tfbi->fb.var.upper_margin\t= inf->upper_margin;\n\tfbi->fb.var.lower_margin\t= inf->lower_margin;\n\tfbi->fb.var.sync\t\t= inf->sync;\n\tfbi->fb.var.grayscale\t\t= inf->cmap_greyscale;\n\tfbi->state\t\t\t= C_STARTUP;\n\tfbi->task_state\t\t\t= (u_char)-1;\n\tfbi->fb.fix.smem_len\t\t= inf->xres * inf->yres *\n\t\t\t\t\t  inf->bpp / 8;\n\tfbi->inf\t\t\t= inf;\n\n\t \n\tfor (i = 0; i < NR_RGB; i++)\n\t\tif (inf->rgb[i])\n\t\t\tfbi->rgb[i] = inf->rgb[i];\n\n\tinit_waitqueue_head(&fbi->ctrlr_wait);\n\tINIT_WORK(&fbi->task, sa1100fb_task);\n\tmutex_init(&fbi->ctrlr_lock);\n\n\treturn fbi;\n}\n\nstatic int sa1100fb_probe(struct platform_device *pdev)\n{\n\tstruct sa1100fb_info *fbi;\n\tint ret, irq;\n\n\tif (!dev_get_platdata(&pdev->dev)) {\n\t\tdev_err(&pdev->dev, \"no platform LCD data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tfbi = sa1100fb_init_fbinfo(&pdev->dev);\n\tif (!fbi)\n\t\treturn -ENOMEM;\n\n\tfbi->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(fbi->base))\n\t\treturn PTR_ERR(fbi->base);\n\n\tfbi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(fbi->clk))\n\t\treturn PTR_ERR(fbi->clk);\n\n\tret = devm_request_irq(&pdev->dev, irq, sa1100fb_handle_irq, 0,\n\t\t\t       \"LCD\", fbi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request_irq failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfbi->shannon_lcden = gpiod_get_optional(&pdev->dev, \"shannon-lcden\",\n\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(fbi->shannon_lcden))\n\t\treturn PTR_ERR(fbi->shannon_lcden);\n\n\t \n\tret = sa1100fb_map_video_memory(fbi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsa1100fb_check_var(&fbi->fb.var, &fbi->fb);\n\n\tplatform_set_drvdata(pdev, fbi);\n\n\tret = register_framebuffer(&fbi->fb);\n\tif (ret < 0) {\n\t\tdma_free_wc(fbi->dev, fbi->map_size, fbi->map_cpu,\n\t\t\t    fbi->map_dma);\n\t\treturn ret;\n\t}\n\n#ifdef CONFIG_CPU_FREQ\n\tfbi->freq_transition.notifier_call = sa1100fb_freq_transition;\n\tcpufreq_register_notifier(&fbi->freq_transition, CPUFREQ_TRANSITION_NOTIFIER);\n#endif\n\n\t \n\treturn 0;\n}\n\nstatic struct platform_driver sa1100fb_driver = {\n\t.probe\t\t= sa1100fb_probe,\n\t.suspend\t= sa1100fb_suspend,\n\t.resume\t\t= sa1100fb_resume,\n\t.driver\t\t= {\n\t\t.name\t= \"sa11x0-fb\",\n\t},\n};\n\nstatic int __init sa1100fb_init(void)\n{\n\tif (fb_get_options(\"sa1100fb\", NULL))\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&sa1100fb_driver);\n}\n\nmodule_init(sa1100fb_init);\nMODULE_DESCRIPTION(\"StrongARM-1100/1110 framebuffer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}