{
  "module_name": "vga16fb.c",
  "hash_id": "64a6ca5a24505470ff7b0855d1054fa574b3fe9eecc22bab4268572b0ff8d57e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/vga16fb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/screen_info.h>\n\n#include <asm/io.h>\n#include <video/vga.h>\n\n#define MODE_SKIP4\t1\n#define MODE_8BPP\t2\n#define MODE_CFB\t4\n#define MODE_TEXT\t8\n\n \n\n \n\nstruct vga16fb_par {\n\t \n\tstruct {\n\t\tunsigned char\tSeqCtrlIndex;\t   \n\t\tunsigned char\tCrtCtrlIndex;\t   \n\t\tunsigned char\tCrtMiscIO;\t   \n\t\tunsigned char\tHorizontalTotal;   \n\t\tunsigned char\tHorizDisplayEnd;   \n\t\tunsigned char\tStartHorizRetrace; \n\t\tunsigned char\tEndHorizRetrace;   \n\t\tunsigned char\tOverflow;\t   \n\t\tunsigned char\tStartVertRetrace;  \n\t\tunsigned char\tEndVertRetrace;\t   \n\t\tunsigned char\tModeControl;\t   \n\t\tunsigned char\tClockingMode;\t   \n\t} vga_state;\n\tstruct vgastate state;\n\tunsigned int ref_count;\n\tint palette_blanked, vesa_blanked, mode, isVGA;\n\tu8 misc, pel_msk, vss, clkdiv;\n\tu8 crtc[VGA_CRT_C];\n};\n\n \n\nstatic struct fb_var_screeninfo vga16fb_defined = {\n\t.xres\t\t= 640,\n\t.yres\t\t= 480,\n\t.xres_virtual\t= 640,\n\t.yres_virtual\t= 480,\n\t.bits_per_pixel\t= 4,\n\t.activate\t= FB_ACTIVATE_TEST,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.pixclock\t= 39721,\n\t.left_margin\t= 48,\n\t.right_margin\t= 16,\n\t.upper_margin\t= 33,\n\t.lower_margin\t= 10,\n\t.hsync_len \t= 96,\n\t.vsync_len\t= 2,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\n \nstatic const struct fb_fix_screeninfo vga16fb_fix = {\n\t.id\t\t= \"VGA16 VGA\",\n\t.smem_start\t= VGA_FB_PHYS_BASE,\n\t.smem_len\t= VGA_FB_PHYS_SIZE,\n\t.type\t\t= FB_TYPE_VGA_PLANES,\n\t.type_aux\t= FB_AUX_VGA_PLANES_VGA4,\n\t.visual\t\t= FB_VISUAL_PSEUDOCOLOR,\n\t.xpanstep\t= 8,\n\t.ypanstep\t= 1,\n\t.line_length\t= 640 / 8,\n\t.accel\t\t= FB_ACCEL_NONE\n};\n\n \nstatic inline void rmw(volatile char __iomem *p)\n{\n\treadb(p);\n\twriteb(1, p);\n}\n\n \nstatic inline int setmode(int mode)\n{\n\tint oldmode;\n\n\toldmode = vga_io_rgfx(VGA_GFX_MODE);\n\tvga_io_w(VGA_GFX_D, mode);\n\treturn oldmode;\n}\n\n \nstatic inline int selectmask(void)\n{\n\treturn vga_io_rgfx(VGA_GFX_BIT_MASK);\n}\n\n \nstatic inline void setmask(int mask)\n{\n\tvga_io_w(VGA_GFX_D, mask);\n}\n\n \nstatic inline int setop(int op)\n{\n\tint oldop;\n\n\toldop = vga_io_rgfx(VGA_GFX_DATA_ROTATE);\n\tvga_io_w(VGA_GFX_D, op);\n\treturn oldop;\n}\n\n \nstatic inline int setsr(int sr)\n{\n\tint oldsr;\n\n\toldsr = vga_io_rgfx(VGA_GFX_SR_ENABLE);\n\tvga_io_w(VGA_GFX_D, sr);\n\treturn oldsr;\n}\n\n \nstatic inline int setcolor(int color)\n{\n\tint oldcolor;\n\n\toldcolor = vga_io_rgfx(VGA_GFX_SR_VALUE);\n\tvga_io_w(VGA_GFX_D, color);\n\treturn oldcolor;\n}\n\n \nstatic inline int getindex(void)\n{\n\treturn vga_io_r(VGA_GFX_I);\n}\n\n \nstatic inline void setindex(int index)\n{\n\tvga_io_w(VGA_GFX_I, index);\n}\n\n \nstatic inline int check_mode_supported(const struct screen_info *si)\n{\n\t \n#if defined(CONFIG_X86)\n\t \n\tif (si->orig_video_isVGA != VIDEO_TYPE_EGAC &&\n\t    si->orig_video_isVGA != VIDEO_TYPE_VGAC)\n\t\treturn -ENODEV;\n\n\tif (si->orig_video_mode != 0x0D &&\t \n\t    si->orig_video_mode != 0x0E &&\t \n\t    si->orig_video_mode != 0x10 &&\t \n\t    si->orig_video_mode != 0x12)\t \n\t\treturn -ENODEV;\n#endif\n\treturn 0;\n}\n\nstatic void vga16fb_pan_var(struct fb_info *info,\n\t\t\t    struct fb_var_screeninfo *var)\n{\n\tstruct vga16fb_par *par = info->par;\n\tu32 xoffset, pos;\n\n\txoffset = var->xoffset;\n\tif (info->var.bits_per_pixel == 8) {\n\t\tpos = (info->var.xres_virtual * var->yoffset + xoffset) >> 2;\n\t} else if (par->mode & MODE_TEXT) {\n\t\tint fh = 16;  \n\t\tpos = (info->var.xres_virtual * (var->yoffset / fh) + xoffset) >> 3;\n\t} else {\n\t\tif (info->var.nonstd)\n\t\t\txoffset--;\n\t\tpos = (info->var.xres_virtual * var->yoffset + xoffset) >> 3;\n\t}\n\tvga_io_wcrt(VGA_CRTC_START_HI, pos >> 8);\n\tvga_io_wcrt(VGA_CRTC_START_LO, pos & 0xFF);\n\t \n\tvga_io_r(VGA_IS1_RC);\t\t \n\tvga_io_w(VGA_ATT_IW, VGA_ATC_PEL);\n\tif (info->var.bits_per_pixel == 8)\n\t\tvga_io_w(VGA_ATT_IW, (xoffset & 3) << 1);\n\telse\n\t\tvga_io_w(VGA_ATT_IW, xoffset & 7);\n\tvga_io_r(VGA_IS1_RC);\n\tvga_io_w(VGA_ATT_IW, 0x20);\n}\n\nstatic void vga16fb_update_fix(struct fb_info *info)\n{\n\tif (info->var.bits_per_pixel == 4) {\n\t\tif (info->var.nonstd) {\n\t\t\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\t\t\tinfo->fix.line_length = info->var.xres_virtual / 2;\n\t\t} else {\n\t\t\tinfo->fix.type = FB_TYPE_VGA_PLANES;\n\t\t\tinfo->fix.type_aux = FB_AUX_VGA_PLANES_VGA4;\n\t\t\tinfo->fix.line_length = info->var.xres_virtual / 8;\n\t\t}\n\t} else if (info->var.bits_per_pixel == 0) {\n\t\tinfo->fix.type = FB_TYPE_TEXT;\n\t\tinfo->fix.type_aux = FB_AUX_TEXT_CGA;\n\t\tinfo->fix.line_length = info->var.xres_virtual / 4;\n\t} else {\t \n\t\tif (info->var.nonstd) {\n\t\t\tinfo->fix.type = FB_TYPE_VGA_PLANES;\n\t\t\tinfo->fix.type_aux = FB_AUX_VGA_PLANES_CFB8;\n\t\t\tinfo->fix.line_length = info->var.xres_virtual / 4;\n\t\t} else {\n\t\t\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\t\t\tinfo->fix.line_length = info->var.xres_virtual;\n\t\t}\n\t}\n}\n\nstatic void vga16fb_clock_chip(struct vga16fb_par *par,\n\t\t\t       unsigned int *pixclock,\n\t\t\t       const struct fb_info *info,\n\t\t\t       int mul, int div)\n{\n\tstatic const struct {\n\t\tu32 pixclock;\n\t\tu8  misc;\n\t\tu8  seq_clock_mode;\n\t} *ptr, *best, vgaclocks[] = {\n\t\t{ 79442  , 0x00, 0x08},\n\t\t{ 70616  , 0x04, 0x08},\n\t\t{ 39721  , 0x00, 0x00},\n\t\t{ 35308  , 0x04, 0x00},\n\t\t{     0  ,    0x00, 0x00}};\n\tint err;\n\n\t*pixclock = (*pixclock * mul) / div;\n\tbest = vgaclocks;\n\terr = *pixclock - best->pixclock;\n\tif (err < 0) err = -err;\n\tfor (ptr = vgaclocks + 1; ptr->pixclock; ptr++) {\n\t\tint tmp;\n\n\t\ttmp = *pixclock - ptr->pixclock;\n\t\tif (tmp < 0) tmp = -tmp;\n\t\tif (tmp < err) {\n\t\t\terr = tmp;\n\t\t\tbest = ptr;\n\t\t}\n\t}\n\tpar->misc |= best->misc;\n\tpar->clkdiv = best->seq_clock_mode;\n\t*pixclock = (best->pixclock * div) / mul;\n}\n\n#define FAIL(X) return -EINVAL\n\nstatic int vga16fb_open(struct fb_info *info, int user)\n{\n\tstruct vga16fb_par *par = info->par;\n\n\tif (!par->ref_count) {\n\t\tmemset(&par->state, 0, sizeof(struct vgastate));\n\t\tpar->state.flags = VGA_SAVE_FONTS | VGA_SAVE_MODE |\n\t\t\tVGA_SAVE_CMAP;\n\t\tsave_vga(&par->state);\n\t}\n\tpar->ref_count++;\n\n\treturn 0;\n}\n\nstatic int vga16fb_release(struct fb_info *info, int user)\n{\n\tstruct vga16fb_par *par = info->par;\n\n\tif (!par->ref_count)\n\t\treturn -EINVAL;\n\n\tif (par->ref_count == 1)\n\t\trestore_vga(&par->state);\n\tpar->ref_count--;\n\n\treturn 0;\n}\n\nstatic int vga16fb_check_var(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tstruct vga16fb_par *par = info->par;\n\tu32 xres, right, hslen, left, xtotal;\n\tu32 yres, lower, vslen, upper, ytotal;\n\tu32 vxres, xoffset, vyres, yoffset;\n\tu32 pos;\n\tu8 r7, rMode;\n\tint shift;\n\tint mode;\n\tu32 maxmem;\n\n\tpar->pel_msk = 0xFF;\n\n\tif (var->bits_per_pixel == 4) {\n\t\tif (var->nonstd) {\n\t\t\tif (!par->isVGA)\n\t\t\t\treturn -EINVAL;\n\t\t\tshift = 3;\n\t\t\tmode = MODE_SKIP4 | MODE_CFB;\n\t\t\tmaxmem = 16384;\n\t\t\tpar->pel_msk = 0x0F;\n\t\t} else {\n\t\t\tshift = 3;\n\t\t\tmode = 0;\n\t\t\tmaxmem = 65536;\n\t\t}\n\t} else if (var->bits_per_pixel == 8) {\n\t\tif (!par->isVGA)\n\t\t\treturn -EINVAL;\t \n\t\tshift = 2;\n\t\tif (var->nonstd) {\n\t\t\tmode = MODE_8BPP | MODE_CFB;\n\t\t\tmaxmem = 65536;\n\t\t} else {\n\t\t\tmode = MODE_SKIP4 | MODE_8BPP | MODE_CFB;\n\t\t\tmaxmem = 16384;\n\t\t}\n\t} else\n\t\treturn -EINVAL;\n\n\txres = (var->xres + 7) & ~7;\n\tvxres = (var->xres_virtual + 0xF) & ~0xF;\n\txoffset = (var->xoffset + 7) & ~7;\n\tleft = (var->left_margin + 7) & ~7;\n\tright = (var->right_margin + 7) & ~7;\n\thslen = (var->hsync_len + 7) & ~7;\n\n\tif (vxres < xres)\n\t\tvxres = xres;\n\tif (xres + xoffset > vxres)\n\t\txoffset = vxres - xres;\n\n\tvar->xres = xres;\n\tvar->right_margin = right;\n\tvar->hsync_len = hslen;\n\tvar->left_margin = left;\n\tvar->xres_virtual = vxres;\n\tvar->xoffset = xoffset;\n\n\txres >>= shift;\n\tright >>= shift;\n\thslen >>= shift;\n\tleft >>= shift;\n\tvxres >>= shift;\n\txtotal = xres + right + hslen + left;\n\tif (xtotal >= 256)\n\t\tFAIL(\"xtotal too big\");\n\tif (hslen > 32)\n\t\tFAIL(\"hslen too big\");\n\tif (right + hslen + left > 64)\n\t\tFAIL(\"hblank too big\");\n\tpar->crtc[VGA_CRTC_H_TOTAL] = xtotal - 5;\n\tpar->crtc[VGA_CRTC_H_BLANK_START] = xres - 1;\n\tpar->crtc[VGA_CRTC_H_DISP] = xres - 1;\n\tpos = xres + right;\n\tpar->crtc[VGA_CRTC_H_SYNC_START] = pos;\n\tpos += hslen;\n\tpar->crtc[VGA_CRTC_H_SYNC_END] = pos & 0x1F;\n\tpos += left - 2;  \n\tpar->crtc[VGA_CRTC_H_BLANK_END] = (pos & 0x1F) | 0x80;\n\tif (pos & 0x20)\n\t\tpar->crtc[VGA_CRTC_H_SYNC_END] |= 0x80;\n\n\tyres = var->yres;\n\tlower = var->lower_margin;\n\tvslen = var->vsync_len;\n\tupper = var->upper_margin;\n\tvyres = var->yres_virtual;\n\tyoffset = var->yoffset;\n\n\tif (yres > vyres)\n\t\tvyres = yres;\n\tif (vxres * vyres > maxmem) {\n\t\tvyres = maxmem / vxres;\n\t\tif (vyres < yres)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (yoffset + yres > vyres)\n\t\tyoffset = vyres - yres;\n\tvar->yres = yres;\n\tvar->lower_margin = lower;\n\tvar->vsync_len = vslen;\n\tvar->upper_margin = upper;\n\tvar->yres_virtual = vyres;\n\tvar->yoffset = yoffset;\n\n\tif (var->vmode & FB_VMODE_DOUBLE) {\n\t\tyres <<= 1;\n\t\tlower <<= 1;\n\t\tvslen <<= 1;\n\t\tupper <<= 1;\n\t}\n\tytotal = yres + lower + vslen + upper;\n\tif (ytotal > 1024) {\n\t\tytotal >>= 1;\n\t\tyres >>= 1;\n\t\tlower >>= 1;\n\t\tvslen >>= 1;\n\t\tupper >>= 1;\n\t\trMode = 0x04;\n\t} else\n\t\trMode = 0x00;\n\tif (ytotal > 1024)\n\t\tFAIL(\"ytotal too big\");\n\tif (vslen > 16)\n\t\tFAIL(\"vslen too big\");\n\tpar->crtc[VGA_CRTC_V_TOTAL] = ytotal - 2;\n\tr7 = 0x10;\t \n\tif (ytotal & 0x100) r7 |= 0x01;\n\tif (ytotal & 0x200) r7 |= 0x20;\n\tpar->crtc[VGA_CRTC_PRESET_ROW] = 0;\n\tpar->crtc[VGA_CRTC_MAX_SCAN] = 0x40;\t \n\tif (var->vmode & FB_VMODE_DOUBLE)\n\t\tpar->crtc[VGA_CRTC_MAX_SCAN] |= 0x80;\n\tpar->crtc[VGA_CRTC_CURSOR_START] = 0x20;\n\tpar->crtc[VGA_CRTC_CURSOR_END]   = 0x00;\n\tif ((mode & (MODE_CFB | MODE_8BPP)) == MODE_CFB)\n\t\txoffset--;\n\tpos = yoffset * vxres + (xoffset >> shift);\n\tpar->crtc[VGA_CRTC_START_HI]     = pos >> 8;\n\tpar->crtc[VGA_CRTC_START_LO]     = pos & 0xFF;\n\tpar->crtc[VGA_CRTC_CURSOR_HI]    = 0x00;\n\tpar->crtc[VGA_CRTC_CURSOR_LO]    = 0x00;\n\tpos = yres - 1;\n\tpar->crtc[VGA_CRTC_V_DISP_END] = pos & 0xFF;\n\tpar->crtc[VGA_CRTC_V_BLANK_START] = pos & 0xFF;\n\tif (pos & 0x100)\n\t\tr7 |= 0x0A;\t \n\tif (pos & 0x200) {\n\t\tr7 |= 0x40;\t \n\t\tpar->crtc[VGA_CRTC_MAX_SCAN] |= 0x20;  \n\t}\n\tpos += lower;\n\tpar->crtc[VGA_CRTC_V_SYNC_START] = pos & 0xFF;\n\tif (pos & 0x100)\n\t\tr7 |= 0x04;\n\tif (pos & 0x200)\n\t\tr7 |= 0x80;\n\tpos += vslen;\n\tpar->crtc[VGA_CRTC_V_SYNC_END] = (pos & 0x0F) & ~0x10;  \n\tpos += upper - 1;  \n\tpar->crtc[VGA_CRTC_V_BLANK_END] = pos & 0xFF;  \n\tif (vxres >= 512)\n\t\tFAIL(\"vxres too long\");\n\tpar->crtc[VGA_CRTC_OFFSET] = vxres >> 1;\n\tif (mode & MODE_SKIP4)\n\t\tpar->crtc[VGA_CRTC_UNDERLINE] = 0x5F;\t \n\telse\n\t\tpar->crtc[VGA_CRTC_UNDERLINE] = 0x1F;\t \n\tpar->crtc[VGA_CRTC_MODE] = rMode | ((mode & MODE_TEXT) ? 0xA3 : 0xE3);\n\tpar->crtc[VGA_CRTC_LINE_COMPARE] = 0xFF;\n\tpar->crtc[VGA_CRTC_OVERFLOW] = r7;\n\n\tpar->vss = 0x00;\t \n\n\tpar->misc = 0xE3;\t \n\tif (var->sync & FB_SYNC_HOR_HIGH_ACT)\n\t\tpar->misc &= ~0x40;\n\tif (var->sync & FB_SYNC_VERT_HIGH_ACT)\n\t\tpar->misc &= ~0x80;\n\n\tpar->mode = mode;\n\n\tif (mode & MODE_8BPP)\n\t\t \n\t\tvga16fb_clock_chip(par, &var->pixclock, info, 1, 2);\n\telse\n\t\t \n\t\tvga16fb_clock_chip(par, &var->pixclock, info, 1, 1);\n\n\tvar->red.offset = var->green.offset = var->blue.offset =\n\tvar->transp.offset = 0;\n\tvar->red.length = var->green.length = var->blue.length =\n\t\t(par->isVGA) ? 6 : 2;\n\tvar->transp.length = 0;\n\tvar->activate = FB_ACTIVATE_NOW;\n\tvar->height = -1;\n\tvar->width = -1;\n\tvar->accel_flags = 0;\n\treturn 0;\n}\n#undef FAIL\n\nstatic int vga16fb_set_par(struct fb_info *info)\n{\n\tstruct vga16fb_par *par = info->par;\n\tu8 gdc[VGA_GFX_C];\n\tu8 seq[VGA_SEQ_C];\n\tu8 atc[VGA_ATT_C];\n\tint fh, i;\n\n\tseq[VGA_SEQ_CLOCK_MODE] = 0x01 | par->clkdiv;\n\tif (par->mode & MODE_TEXT)\n\t\tseq[VGA_SEQ_PLANE_WRITE] = 0x03;\n\telse\n\t\tseq[VGA_SEQ_PLANE_WRITE] = 0x0F;\n\tseq[VGA_SEQ_CHARACTER_MAP] = 0x00;\n\tif (par->mode & MODE_TEXT)\n\t\tseq[VGA_SEQ_MEMORY_MODE] = 0x03;\n\telse if (par->mode & MODE_SKIP4)\n\t\tseq[VGA_SEQ_MEMORY_MODE] = 0x0E;\n\telse\n\t\tseq[VGA_SEQ_MEMORY_MODE] = 0x06;\n\n\tgdc[VGA_GFX_SR_VALUE] = 0x00;\n\tgdc[VGA_GFX_SR_ENABLE] = 0x00;\n\tgdc[VGA_GFX_COMPARE_VALUE] = 0x00;\n\tgdc[VGA_GFX_DATA_ROTATE] = 0x00;\n\tgdc[VGA_GFX_PLANE_READ] = 0;\n\tif (par->mode & MODE_TEXT) {\n\t\tgdc[VGA_GFX_MODE] = 0x10;\n\t\tgdc[VGA_GFX_MISC] = 0x06;\n\t} else {\n\t\tif (par->mode & MODE_CFB)\n\t\t\tgdc[VGA_GFX_MODE] = 0x40;\n\t\telse\n\t\t\tgdc[VGA_GFX_MODE] = 0x00;\n\t\tgdc[VGA_GFX_MISC] = 0x05;\n\t}\n\tgdc[VGA_GFX_COMPARE_MASK] = 0x0F;\n\tgdc[VGA_GFX_BIT_MASK] = 0xFF;\n\n\tfor (i = 0x00; i < 0x10; i++)\n\t\tatc[i] = i;\n\tif (par->mode & MODE_TEXT)\n\t\tatc[VGA_ATC_MODE] = 0x04;\n\telse if (par->mode & MODE_8BPP)\n\t\tatc[VGA_ATC_MODE] = 0x41;\n\telse\n\t\tatc[VGA_ATC_MODE] = 0x81;\n\tatc[VGA_ATC_OVERSCAN] = 0x00;\t \n\tatc[VGA_ATC_PLANE_ENABLE] = 0x0F;\n\tif (par->mode & MODE_8BPP)\n\t\tatc[VGA_ATC_PEL] = (info->var.xoffset & 3) << 1;\n\telse\n\t\tatc[VGA_ATC_PEL] = info->var.xoffset & 7;\n\tatc[VGA_ATC_COLOR_PAGE] = 0x00;\n\n\tif (par->mode & MODE_TEXT) {\n\t\tfh = 16;  \n\t\tpar->crtc[VGA_CRTC_MAX_SCAN] = (par->crtc[VGA_CRTC_MAX_SCAN]\n\t\t\t\t\t       & ~0x1F) | (fh - 1);\n\t}\n\n\tvga_io_w(VGA_MIS_W, vga_io_r(VGA_MIS_R) | 0x01);\n\n\t \n\tif (!par->isVGA) {\n\t\tvga_io_w(EGA_GFX_E0, 0x00);\n\t\tvga_io_w(EGA_GFX_E1, 0x01);\n\t}\n\n\t \n\tvga_io_w(VGA_MIS_W, par->misc);\n\n\t \n\tvga_io_wseq(0x00, 0x01);\n\n\tif (par->isVGA)\n\t\tvga_io_w(VGA_PEL_MSK, par->pel_msk);\n\n\t \n\tvga_io_wseq(VGA_SEQ_CLOCK_MODE, seq[VGA_SEQ_CLOCK_MODE] | 0x20);\n\tfor (i = 2; i < VGA_SEQ_C; i++) {\n\t\tvga_io_wseq(i, seq[i]);\n\t}\n\n\t \n\tvga_io_wseq(0x00, 0x03);\n\n\t \n\tvga_io_wcrt(VGA_CRTC_V_SYNC_END, par->crtc[VGA_CRTC_V_SYNC_END]);\n\n\t \n\tfor (i = 0; i < VGA_CRTC_REGS; i++) {\n\t\tvga_io_wcrt(i, par->crtc[i]);\n\t}\n\n\t \n\tfor (i = 0; i < VGA_GFX_C; i++) {\n\t\tvga_io_wgfx(i, gdc[i]);\n\t}\n\n\t \n\tfor (i = 0; i < VGA_ATT_C; i++) {\n\t\tvga_io_r(VGA_IS1_RC);\t\t \n\t\tvga_io_wattr(i, atc[i]);\n\t}\n\n\t \n\tmdelay(50);\n\n\tvga_io_wseq(VGA_SEQ_CLOCK_MODE, seq[VGA_SEQ_CLOCK_MODE]);\n\n\tvga_io_r(VGA_IS1_RC);\n\tvga_io_w(VGA_ATT_IW, 0x20);\n\n\tvga16fb_update_fix(info);\n\treturn 0;\n}\n\nstatic void ega16_setpalette(int regno, unsigned red, unsigned green, unsigned blue)\n{\n\tstatic const unsigned char map[] = { 000, 001, 010, 011 };\n\tint val;\n\n\tif (regno >= 16)\n\t\treturn;\n\tval = map[red>>14] | ((map[green>>14]) << 1) | ((map[blue>>14]) << 2);\n\tvga_io_r(VGA_IS1_RC);    \n\tvga_io_wattr(regno, val);\n\tvga_io_r(VGA_IS1_RC);    \n\tvga_io_w(VGA_ATT_IW, 0x20);  \n}\n\nstatic void vga16_setpalette(int regno, unsigned red, unsigned green, unsigned blue)\n{\n\toutb(regno,       VGA_PEL_IW);\n\toutb(red   >> 10, VGA_PEL_D);\n\toutb(green >> 10, VGA_PEL_D);\n\toutb(blue  >> 10, VGA_PEL_D);\n}\n\nstatic int vga16fb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t     unsigned blue, unsigned transp,\n\t\t\t     struct fb_info *info)\n{\n\tstruct vga16fb_par *par = info->par;\n\tint gray;\n\n\t \n\n\tif (regno >= 256)\n\t\treturn 1;\n\n\tgray = info->var.grayscale;\n\n\tif (gray) {\n\t\t \n\t\tred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n\t}\n\tif (par->isVGA)\n\t\tvga16_setpalette(regno,red,green,blue);\n\telse\n\t\tega16_setpalette(regno,red,green,blue);\n\treturn 0;\n}\n\nstatic int vga16fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t       struct fb_info *info)\n{\n\tvga16fb_pan_var(info, var);\n\treturn 0;\n}\n\n \n\nstatic void vga_vesa_blank(struct vga16fb_par *par, int mode)\n{\n\tunsigned char SeqCtrlIndex = vga_io_r(VGA_SEQ_I);\n\tunsigned char CrtCtrlIndex = vga_io_r(VGA_CRT_IC);\n\n\t \n\tif(!par->vesa_blanked) {\n\t\tpar->vga_state.CrtMiscIO = vga_io_r(VGA_MIS_R);\n\t\t\n\n\t\tpar->vga_state.HorizontalTotal = vga_io_rcrt(0x00);\t \n\t\tpar->vga_state.HorizDisplayEnd = vga_io_rcrt(0x01);\t \n\t\tpar->vga_state.StartHorizRetrace = vga_io_rcrt(0x04);\t \n\t\tpar->vga_state.EndHorizRetrace = vga_io_rcrt(0x05);\t \n\t\tpar->vga_state.Overflow = vga_io_rcrt(0x07);\t\t \n\t\tpar->vga_state.StartVertRetrace = vga_io_rcrt(0x10);\t \n\t\tpar->vga_state.EndVertRetrace = vga_io_rcrt(0x11);\t \n\t\tpar->vga_state.ModeControl = vga_io_rcrt(0x17);\t \n\t\tpar->vga_state.ClockingMode = vga_io_rseq(0x01);\t \n\t}\n\n\t \n\t \n\tvga_io_wseq(0x01, par->vga_state.ClockingMode | 0x20);\n\n\t \n\tif ((par->vga_state.CrtMiscIO & 0x80) == 0x80)\n\t\tvga_io_w(VGA_MIS_W, par->vga_state.CrtMiscIO & 0xef);\n\n\t \n\tif (mode & FB_BLANK_VSYNC_SUSPEND) {\n\t\tvga_io_wcrt(VGA_CRTC_V_SYNC_START, 0xff);\n\t\tvga_io_wcrt(VGA_CRTC_V_SYNC_END, 0x40);\n\t\t \n\t\tvga_io_wcrt(VGA_CRTC_OVERFLOW, par->vga_state.Overflow | 0x84);\n\t}\n\n\tif (mode & FB_BLANK_HSYNC_SUSPEND) {\n\t\t \n\t\tvga_io_wcrt(VGA_CRTC_H_SYNC_START, 0xff);\n\t\tvga_io_wcrt(VGA_CRTC_H_SYNC_END, 0x00);\n\t}\n\n\t \n\toutb_p(SeqCtrlIndex, VGA_SEQ_I);\n\toutb_p(CrtCtrlIndex, VGA_CRT_IC);\n}\n\nstatic void vga_vesa_unblank(struct vga16fb_par *par)\n{\n\tunsigned char SeqCtrlIndex = vga_io_r(VGA_SEQ_I);\n\tunsigned char CrtCtrlIndex = vga_io_r(VGA_CRT_IC);\n\n\t \n\tvga_io_w(VGA_MIS_W, par->vga_state.CrtMiscIO);\n\n\t \n\tvga_io_wcrt(0x00, par->vga_state.HorizontalTotal);\n\t \n\tvga_io_wcrt(0x01, par->vga_state.HorizDisplayEnd);\n\t \n\tvga_io_wcrt(0x04, par->vga_state.StartHorizRetrace);\n\t \n\tvga_io_wcrt(0x05, par->vga_state.EndHorizRetrace);\n\t \n\tvga_io_wcrt(0x07, par->vga_state.Overflow);\n\t \n\tvga_io_wcrt(0x10, par->vga_state.StartVertRetrace);\n\t \n\tvga_io_wcrt(0x11, par->vga_state.EndVertRetrace);\n\t \n\tvga_io_wcrt(0x17, par->vga_state.ModeControl);\n\t \n\tvga_io_wseq(0x01, par->vga_state.ClockingMode);\n\n\t \n\tvga_io_w(VGA_SEQ_I, SeqCtrlIndex);\n\tvga_io_w(VGA_CRT_IC, CrtCtrlIndex);\n}\n\nstatic void vga_pal_blank(void)\n{\n\tint i;\n\n\tfor (i=0; i<16; i++) {\n\t\toutb_p(i, VGA_PEL_IW);\n\t\toutb_p(0, VGA_PEL_D);\n\t\toutb_p(0, VGA_PEL_D);\n\t\toutb_p(0, VGA_PEL_D);\n\t}\n}\n\n \nstatic int vga16fb_blank(int blank, struct fb_info *info)\n{\n\tstruct vga16fb_par *par = info->par;\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\t\t\t\t \n\t\tif (par->vesa_blanked) {\n\t\t\tvga_vesa_unblank(par);\n\t\t\tpar->vesa_blanked = 0;\n\t\t}\n\t\tif (par->palette_blanked) {\n\t\t\tpar->palette_blanked = 0;\n\t\t}\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\t\t\t\t \n\t\tvga_pal_blank();\n\t\tpar->palette_blanked = 1;\n\t\tbreak;\n\tdefault:\t\t\t \n\t\tvga_vesa_blank(par, blank);\n\t\tpar->vesa_blanked = 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void vga_8planes_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tu32 dx = rect->dx, width = rect->width;\n        char oldindex = getindex();\n        char oldmode = setmode(0x40);\n        char oldmask = selectmask();\n        int line_ofs, height;\n        char oldop, oldsr;\n        char __iomem *where;\n\n        dx /= 4;\n        where = info->screen_base + dx + rect->dy * info->fix.line_length;\n\n        if (rect->rop == ROP_COPY) {\n                oldop = setop(0);\n                oldsr = setsr(0);\n\n                width /= 4;\n                line_ofs = info->fix.line_length - width;\n                setmask(0xff);\n\n                height = rect->height;\n\n                while (height--) {\n                        int x;\n\n                         \n                        for (x = width; x > 0; --x) {\n                                writeb(rect->color, where);\n                                where++;\n                        }\n                        where += line_ofs;\n                }\n        } else {\n                char oldcolor = setcolor(0xf);\n                int y;\n\n                oldop = setop(0x18);\n                oldsr = setsr(0xf);\n                setmask(0x0F);\n                for (y = 0; y < rect->height; y++) {\n                        rmw(where);\n                        rmw(where+1);\n                        where += info->fix.line_length;\n                }\n                setcolor(oldcolor);\n        }\n        setmask(oldmask);\n        setsr(oldsr);\n        setop(oldop);\n        setmode(oldmode);\n        setindex(oldindex);\n}\n\nstatic void vga16fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tint x, x2, y2, vxres, vyres, width, height, line_ofs;\n\tchar __iomem *dst;\n\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\n\tif (!rect->width || !rect->height || rect->dx > vxres || rect->dy > vyres)\n\t\treturn;\n\n\t \n\n\tx2 = rect->dx + rect->width;\n\ty2 = rect->dy + rect->height;\n\tx2 = x2 < vxres ? x2 : vxres;\n\ty2 = y2 < vyres ? y2 : vyres;\n\twidth = x2 - rect->dx;\n\n\tswitch (info->fix.type) {\n\tcase FB_TYPE_VGA_PLANES:\n\t\tif (info->fix.type_aux == FB_AUX_VGA_PLANES_VGA4) {\n\n\t\t\theight = y2 - rect->dy;\n\t\t\twidth = rect->width/8;\n\n\t\t\tline_ofs = info->fix.line_length - width;\n\t\t\tdst = info->screen_base + (rect->dx/8) + rect->dy * info->fix.line_length;\n\n\t\t\tswitch (rect->rop) {\n\t\t\tcase ROP_COPY:\n\t\t\t\tsetmode(0);\n\t\t\t\tsetop(0);\n\t\t\t\tsetsr(0xf);\n\t\t\t\tsetcolor(rect->color);\n\t\t\t\tselectmask();\n\n\t\t\t\tsetmask(0xff);\n\n\t\t\t\twhile (height--) {\n\t\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\t\twriteb(0, dst);\n\t\t\t\t\t\tdst++;\n\t\t\t\t\t}\n\t\t\t\t\tdst += line_ofs;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ROP_XOR:\n\t\t\t\tsetmode(0);\n\t\t\t\tsetop(0x18);\n\t\t\t\tsetsr(0xf);\n\t\t\t\tsetcolor(0xf);\n\t\t\t\tselectmask();\n\n\t\t\t\tsetmask(0xff);\n\t\t\t\twhile (height--) {\n\t\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\t\trmw(dst);\n\t\t\t\t\t\tdst++;\n\t\t\t\t\t}\n\t\t\t\t\tdst += line_ofs;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tvga_8planes_fillrect(info, rect);\n\t\tbreak;\n\tcase FB_TYPE_PACKED_PIXELS:\n\tdefault:\n\t\tcfb_fillrect(info, rect);\n\t\tbreak;\n\t}\n}\n\nstatic void vga_8planes_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n        char oldindex = getindex();\n        char oldmode = setmode(0x41);\n        char oldop = setop(0);\n        char oldsr = setsr(0xf);\n        int height, line_ofs, x;\n\tu32 sx, dx, width;\n\tchar __iomem *dest;\n\tchar __iomem *src;\n\n        height = area->height;\n\n        sx = area->sx / 4;\n        dx = area->dx / 4;\n        width = area->width / 4;\n\n        if (area->dy < area->sy || (area->dy == area->sy && dx < sx)) {\n                line_ofs = info->fix.line_length - width;\n                dest = info->screen_base + dx + area->dy * info->fix.line_length;\n                src = info->screen_base + sx + area->sy * info->fix.line_length;\n                while (height--) {\n                        for (x = 0; x < width; x++) {\n                                readb(src);\n                                writeb(0, dest);\n                                src++;\n                                dest++;\n                        }\n                        src += line_ofs;\n                        dest += line_ofs;\n                }\n        } else {\n                line_ofs = info->fix.line_length - width;\n                dest = info->screen_base + dx + width +\n\t\t\t(area->dy + height - 1) * info->fix.line_length;\n                src = info->screen_base + sx + width +\n\t\t\t(area->sy + height - 1) * info->fix.line_length;\n                while (height--) {\n                        for (x = 0; x < width; x++) {\n                                --src;\n                                --dest;\n                                readb(src);\n                                writeb(0, dest);\n                        }\n                        src -= line_ofs;\n                        dest -= line_ofs;\n                }\n        }\n\n        setsr(oldsr);\n        setop(oldop);\n        setmode(oldmode);\n        setindex(oldindex);\n}\n\nstatic void vga16fb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tu32 dx = area->dx, dy = area->dy, sx = area->sx, sy = area->sy;\n\tint x, x2, y2, old_dx, old_dy, vxres, vyres;\n\tint height, width, line_ofs;\n\tchar __iomem *dst = NULL;\n\tchar __iomem *src = NULL;\n\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\n\tif (area->dx > vxres || area->sx > vxres || area->dy > vyres ||\n\t    area->sy > vyres)\n\t\treturn;\n\n\t \n\told_dx = area->dx;\n\told_dy = area->dy;\n\n\t \n\tx2 = area->dx + area->width;\n\ty2 = area->dy + area->height;\n\tdx = area->dx > 0 ? area->dx : 0;\n\tdy = area->dy > 0 ? area->dy : 0;\n\tx2 = x2 < vxres ? x2 : vxres;\n\ty2 = y2 < vyres ? y2 : vyres;\n\twidth = x2 - dx;\n\theight = y2 - dy;\n\n\tif (sx + dx < old_dx || sy + dy < old_dy)\n\t\treturn;\n\n\t \n\tsx += (dx - old_dx);\n\tsy += (dy - old_dy);\n\n\t \n\tif (sx + width > vxres || sy + height > vyres)\n\t\treturn;\n\n\tswitch (info->fix.type) {\n\tcase FB_TYPE_VGA_PLANES:\n\t\tif (info->fix.type_aux == FB_AUX_VGA_PLANES_VGA4) {\n\t\t\twidth = width/8;\n\t\t\tline_ofs = info->fix.line_length - width;\n\n\t\t\tsetmode(1);\n\t\t\tsetop(0);\n\t\t\tsetsr(0xf);\n\n\t\t\tif (dy < sy || (dy == sy && dx < sx)) {\n\t\t\t\tdst = info->screen_base + (dx/8) + dy * info->fix.line_length;\n\t\t\t\tsrc = info->screen_base + (sx/8) + sy * info->fix.line_length;\n\t\t\t\twhile (height--) {\n\t\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\t\treadb(src);\n\t\t\t\t\t\twriteb(0, dst);\n\t\t\t\t\t\tdst++;\n\t\t\t\t\t\tsrc++;\n\t\t\t\t\t}\n\t\t\t\t\tsrc += line_ofs;\n\t\t\t\t\tdst += line_ofs;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst = info->screen_base + (dx/8) + width +\n\t\t\t\t\t(dy + height - 1) * info->fix.line_length;\n\t\t\t\tsrc = info->screen_base + (sx/8) + width +\n\t\t\t\t\t(sy + height  - 1) * info->fix.line_length;\n\t\t\t\twhile (height--) {\n\t\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\t\tdst--;\n\t\t\t\t\t\tsrc--;\n\t\t\t\t\t\treadb(src);\n\t\t\t\t\t\twriteb(0, dst);\n\t\t\t\t\t}\n\t\t\t\t\tsrc -= line_ofs;\n\t\t\t\t\tdst -= line_ofs;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tvga_8planes_copyarea(info, area);\n\t\tbreak;\n\tcase FB_TYPE_PACKED_PIXELS:\n\tdefault:\n\t\tcfb_copyarea(info, area);\n\t\tbreak;\n\t}\n}\n\n#define TRANS_MASK_LOW  {0x0,0x8,0x4,0xC,0x2,0xA,0x6,0xE,0x1,0x9,0x5,0xD,0x3,0xB,0x7,0xF}\n#define TRANS_MASK_HIGH {0x000, 0x800, 0x400, 0xC00, 0x200, 0xA00, 0x600, 0xE00, \\\n\t\t\t 0x100, 0x900, 0x500, 0xD00, 0x300, 0xB00, 0x700, 0xF00}\n\n#if defined(__LITTLE_ENDIAN)\nstatic const u16 transl_l[] = TRANS_MASK_LOW;\nstatic const u16 transl_h[] = TRANS_MASK_HIGH;\n#elif defined(__BIG_ENDIAN)\nstatic const u16 transl_l[] = TRANS_MASK_HIGH;\nstatic const u16 transl_h[] = TRANS_MASK_LOW;\n#else\n#error \"Only __BIG_ENDIAN and __LITTLE_ENDIAN are supported in vga-planes\"\n#endif\n\nstatic void vga_8planes_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n        char oldindex = getindex();\n        char oldmode = setmode(0x40);\n        char oldop = setop(0);\n        char oldsr = setsr(0);\n        char oldmask = selectmask();\n\tconst unsigned char *cdat = image->data;\n\tu32 dx = image->dx;\n        char __iomem *where;\n        int y;\n\n        dx /= 4;\n        where = info->screen_base + dx + image->dy * info->fix.line_length;\n\n        setmask(0xff);\n        writeb(image->bg_color, where);\n        readb(where);\n        selectmask();\n        setmask(image->fg_color ^ image->bg_color);\n        setmode(0x42);\n        setop(0x18);\n        for (y = 0; y < image->height; y++, where += info->fix.line_length)\n                writew(transl_h[cdat[y]&0xF] | transl_l[cdat[y] >> 4], where);\n        setmask(oldmask);\n        setsr(oldsr);\n        setop(oldop);\n        setmode(oldmode);\n        setindex(oldindex);\n}\n\nstatic void vga_imageblit_expand(struct fb_info *info, const struct fb_image *image)\n{\n\tchar __iomem *where = info->screen_base + (image->dx/8) +\n\t\timage->dy * info->fix.line_length;\n\tstruct vga16fb_par *par = info->par;\n\tchar *cdat = (char *) image->data;\n\tchar __iomem *dst;\n\tint x, y;\n\n\tswitch (info->fix.type) {\n\tcase FB_TYPE_VGA_PLANES:\n\t\tif (info->fix.type_aux == FB_AUX_VGA_PLANES_VGA4) {\n\t\t\tif (par->isVGA) {\n\t\t\t\tsetmode(2);\n\t\t\t\tsetop(0);\n\t\t\t\tsetsr(0xf);\n\t\t\t\tsetcolor(image->fg_color);\n\t\t\t\tselectmask();\n\n\t\t\t\tsetmask(0xff);\n\t\t\t\twriteb(image->bg_color, where);\n\t\t\t\trmb();\n\t\t\t\treadb(where);  \n\t\t\t\tsetmode(3);\n\t\t\t\twmb();\n\t\t\t\tfor (y = 0; y < image->height; y++) {\n\t\t\t\t\tdst = where;\n\t\t\t\t\tfor (x = image->width/8; x--;)\n\t\t\t\t\t\twriteb(*cdat++, dst++);\n\t\t\t\t\twhere += info->fix.line_length;\n\t\t\t\t}\n\t\t\t\twmb();\n\t\t\t} else {\n\t\t\t\tsetmode(0);\n\t\t\t\tsetop(0);\n\t\t\t\tsetsr(0xf);\n\t\t\t\tsetcolor(image->bg_color);\n\t\t\t\tselectmask();\n\n\t\t\t\tsetmask(0xff);\n\t\t\t\tfor (y = 0; y < image->height; y++) {\n\t\t\t\t\tdst = where;\n\t\t\t\t\tfor (x=image->width/8; x--;){\n\t\t\t\t\t\trmw(dst);\n\t\t\t\t\t\tsetcolor(image->fg_color);\n\t\t\t\t\t\tselectmask();\n\t\t\t\t\t\tif (*cdat) {\n\t\t\t\t\t\t\tsetmask(*cdat++);\n\t\t\t\t\t\t\trmw(dst++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhere += info->fix.line_length;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tvga_8planes_imageblit(info, image);\n\t\tbreak;\n\tcase FB_TYPE_PACKED_PIXELS:\n\tdefault:\n\t\tcfb_imageblit(info, image);\n\t\tbreak;\n\t}\n}\n\nstatic void vga_imageblit_color(struct fb_info *info, const struct fb_image *image)\n{\n\t \n\tstruct vga16fb_par *par = info->par;\n\tchar __iomem *where =\n\t\tinfo->screen_base + image->dy * info->fix.line_length +\n\t\timage->dx/8;\n\tconst char *cdat = image->data;\n\tchar __iomem *dst;\n\tint x, y;\n\n\tswitch (info->fix.type) {\n\tcase FB_TYPE_VGA_PLANES:\n\t\tif (info->fix.type_aux == FB_AUX_VGA_PLANES_VGA4 &&\n\t\t    par->isVGA) {\n\t\t\tsetsr(0xf);\n\t\t\tsetop(0);\n\t\t\tsetmode(0);\n\n\t\t\tfor (y = 0; y < image->height; y++) {\n\t\t\t\tfor (x = 0; x < image->width; x++) {\n\t\t\t\t\tdst = where + x/8;\n\n\t\t\t\t\tsetcolor(*cdat);\n\t\t\t\t\tselectmask();\n\t\t\t\t\tsetmask(1 << (7 - (x % 8)));\n\t\t\t\t\tfb_readb(dst);\n\t\t\t\t\tfb_writeb(0, dst);\n\n\t\t\t\t\tcdat++;\n\t\t\t\t}\n\t\t\t\twhere += info->fix.line_length;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase FB_TYPE_PACKED_PIXELS:\n\t\tcfb_imageblit(info, image);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void vga16fb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tif (image->depth == 1)\n\t\tvga_imageblit_expand(info, image);\n\telse\n\t\tvga_imageblit_color(info, image);\n}\n\nstatic void vga16fb_destroy(struct fb_info *info)\n{\n\tiounmap(info->screen_base);\n\tfb_dealloc_cmap(&info->cmap);\n\t \n\tframebuffer_release(info);\n}\n\nstatic const struct fb_ops vga16fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open        = vga16fb_open,\n\t.fb_release     = vga16fb_release,\n\t.fb_destroy\t= vga16fb_destroy,\n\t.fb_check_var\t= vga16fb_check_var,\n\t.fb_set_par\t= vga16fb_set_par,\n\t.fb_setcolreg \t= vga16fb_setcolreg,\n\t.fb_pan_display = vga16fb_pan_display,\n\t.fb_blank \t= vga16fb_blank,\n\t.fb_fillrect\t= vga16fb_fillrect,\n\t.fb_copyarea\t= vga16fb_copyarea,\n\t.fb_imageblit\t= vga16fb_imageblit,\n};\n\nstatic int vga16fb_probe(struct platform_device *dev)\n{\n\tstruct screen_info *si;\n\tstruct fb_info *info;\n\tstruct vga16fb_par *par;\n\tint i;\n\tint ret = 0;\n\n\tsi = dev_get_platdata(&dev->dev);\n\tif (!si)\n\t\treturn -ENODEV;\n\n\tret = check_mode_supported(si);\n\tif (ret)\n\t\treturn ret;\n\n\tprintk(KERN_DEBUG \"vga16fb: initializing\\n\");\n\tinfo = framebuffer_alloc(sizeof(struct vga16fb_par), &dev->dev);\n\n\tif (!info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_fb_alloc;\n\t}\n\n\t \n\tinfo->screen_base = (void __iomem *)VGA_MAP_MEM(VGA_FB_PHYS_BASE, 0);\n\n\tif (!info->screen_base) {\n\t\tprintk(KERN_ERR \"vga16fb: unable to map device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_ioremap;\n\t}\n\n\tprintk(KERN_INFO \"vga16fb: mapped to 0x%p\\n\", info->screen_base);\n\tpar = info->par;\n\n#if defined(CONFIG_X86)\n\tpar->isVGA = si->orig_video_isVGA == VIDEO_TYPE_VGAC;\n#else\n\t \n\tpar->isVGA = si->orig_video_isVGA;\n#endif\n\tpar->palette_blanked = 0;\n\tpar->vesa_blanked = 0;\n\n\ti = par->isVGA? 6 : 2;\n\n\tvga16fb_defined.red.length   = i;\n\tvga16fb_defined.green.length = i;\n\tvga16fb_defined.blue.length  = i;\n\n\t \n\tinfo->fbops = &vga16fb_ops;\n\tinfo->var = vga16fb_defined;\n\tinfo->fix = vga16fb_fix;\n\t \n\tinfo->pixmap.blit_x = 1 << 7 | 1 << 15 | 1 << 23 | 1 << 31;\n\tinfo->flags = FBINFO_HWACCEL_YPAN;\n\n\ti = (info->var.bits_per_pixel == 8) ? 256 : 16;\n\tret = fb_alloc_cmap(&info->cmap, i, 0);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"vga16fb: unable to allocate colormap\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_cmap;\n\t}\n\n\tif (vga16fb_check_var(&info->var, info)) {\n\t\tprintk(KERN_ERR \"vga16fb: unable to validate variable\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_check_var;\n\t}\n\n\tvga16fb_update_fix(info);\n\n\tret = devm_aperture_acquire_for_platform_device(dev, VGA_FB_PHYS_BASE, VGA_FB_PHYS_SIZE);\n\tif (ret)\n\t\tgoto err_check_var;\n\tif (register_framebuffer(info) < 0) {\n\t\tprintk(KERN_ERR \"vga16fb: unable to register framebuffer\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_check_var;\n\t}\n\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\tplatform_set_drvdata(dev, info);\n\n\treturn 0;\n\n err_check_var:\n\tfb_dealloc_cmap(&info->cmap);\n err_alloc_cmap:\n\tiounmap(info->screen_base);\n err_ioremap:\n\tframebuffer_release(info);\n err_fb_alloc:\n\treturn ret;\n}\n\nstatic void vga16fb_remove(struct platform_device *dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\n\tif (info)\n\t\tunregister_framebuffer(info);\n}\n\nstatic const struct platform_device_id vga16fb_driver_id_table[] = {\n\t{\"ega-framebuffer\", 0},\n\t{\"vga-framebuffer\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, vga16fb_driver_id_table);\n\nstatic struct platform_driver vga16fb_driver = {\n\t.probe = vga16fb_probe,\n\t.remove_new = vga16fb_remove,\n\t.driver = {\n\t\t.name = \"vga16fb\",\n\t},\n\t.id_table = vga16fb_driver_id_table,\n};\n\nmodule_platform_driver(vga16fb_driver);\n\nMODULE_DESCRIPTION(\"Legacy VGA framebuffer device driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}