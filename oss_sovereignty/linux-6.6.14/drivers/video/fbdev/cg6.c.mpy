{
  "module_name": "cg6.c",
  "hash_id": "01f3787eb0914e705452a1f32d1f2f998171b34f4fd4bea1e14542a187333b8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/cg6.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/fb.h>\n#include <linux/mm.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <asm/io.h>\n#include <asm/fbio.h>\n\n#include \"sbuslib.h\"\n\n \n\nstatic int cg6_setcolreg(unsigned, unsigned, unsigned, unsigned,\n\t\t\t unsigned, struct fb_info *);\nstatic int cg6_blank(int, struct fb_info *);\n\nstatic void cg6_imageblit(struct fb_info *, const struct fb_image *);\nstatic void cg6_fillrect(struct fb_info *, const struct fb_fillrect *);\nstatic void cg6_copyarea(struct fb_info *info, const struct fb_copyarea *area);\nstatic int cg6_sync(struct fb_info *);\nstatic int cg6_mmap(struct fb_info *, struct vm_area_struct *);\nstatic int cg6_ioctl(struct fb_info *, unsigned int, unsigned long);\nstatic int cg6_pan_display(struct fb_var_screeninfo *, struct fb_info *);\n\n \n\nstatic const struct fb_ops cg6_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_setcolreg\t\t= cg6_setcolreg,\n\t.fb_blank\t\t= cg6_blank,\n\t.fb_pan_display\t\t= cg6_pan_display,\n\t.fb_fillrect\t\t= cg6_fillrect,\n\t.fb_copyarea\t\t= cg6_copyarea,\n\t.fb_imageblit\t\t= cg6_imageblit,\n\t.fb_sync\t\t= cg6_sync,\n\t.fb_mmap\t\t= cg6_mmap,\n\t.fb_ioctl\t\t= cg6_ioctl,\n#ifdef CONFIG_COMPAT\n\t.fb_compat_ioctl\t= sbusfb_compat_ioctl,\n#endif\n};\n\n \n \n#define CG6_ROM_OFFSET\t\t\t0x0UL\n#define CG6_BROOKTREE_OFFSET\t\t0x200000UL\n#define CG6_DHC_OFFSET\t\t\t0x240000UL\n#define CG6_ALT_OFFSET\t\t\t0x280000UL\n#define CG6_FHC_OFFSET\t\t\t0x300000UL\n#define CG6_THC_OFFSET\t\t\t0x301000UL\n#define CG6_FBC_OFFSET\t\t\t0x700000UL\n#define CG6_TEC_OFFSET\t\t\t0x701000UL\n#define CG6_RAM_OFFSET\t\t\t0x800000UL\n\n \n#define CG6_FHC_FBID_SHIFT\t\t24\n#define CG6_FHC_FBID_MASK\t\t255\n#define CG6_FHC_REV_SHIFT\t\t20\n#define CG6_FHC_REV_MASK\t\t15\n#define CG6_FHC_FROP_DISABLE\t\t(1 << 19)\n#define CG6_FHC_ROW_DISABLE\t\t(1 << 18)\n#define CG6_FHC_SRC_DISABLE\t\t(1 << 17)\n#define CG6_FHC_DST_DISABLE\t\t(1 << 16)\n#define CG6_FHC_RESET\t\t\t(1 << 15)\n#define CG6_FHC_LITTLE_ENDIAN\t\t(1 << 13)\n#define CG6_FHC_RES_MASK\t\t(3 << 11)\n#define CG6_FHC_1024\t\t\t(0 << 11)\n#define CG6_FHC_1152\t\t\t(1 << 11)\n#define CG6_FHC_1280\t\t\t(2 << 11)\n#define CG6_FHC_1600\t\t\t(3 << 11)\n#define CG6_FHC_CPU_MASK\t\t(3 << 9)\n#define CG6_FHC_CPU_SPARC\t\t(0 << 9)\n#define CG6_FHC_CPU_68020\t\t(1 << 9)\n#define CG6_FHC_CPU_386\t\t\t(2 << 9)\n#define CG6_FHC_TEST\t\t\t(1 << 8)\n#define CG6_FHC_TEST_X_SHIFT\t\t4\n#define CG6_FHC_TEST_X_MASK\t\t15\n#define CG6_FHC_TEST_Y_SHIFT\t\t0\n#define CG6_FHC_TEST_Y_MASK\t\t15\n\n \n#define CG6_FBC_BLIT_IGNORE\t\t0x00000000\n#define CG6_FBC_BLIT_NOSRC\t\t0x00100000\n#define CG6_FBC_BLIT_SRC\t\t0x00200000\n#define CG6_FBC_BLIT_ILLEGAL\t\t0x00300000\n#define CG6_FBC_BLIT_MASK\t\t0x00300000\n\n#define CG6_FBC_VBLANK\t\t\t0x00080000\n\n#define CG6_FBC_MODE_IGNORE\t\t0x00000000\n#define CG6_FBC_MODE_COLOR8\t\t0x00020000\n#define CG6_FBC_MODE_COLOR1\t\t0x00040000\n#define CG6_FBC_MODE_HRMONO\t\t0x00060000\n#define CG6_FBC_MODE_MASK\t\t0x00060000\n\n#define CG6_FBC_DRAW_IGNORE\t\t0x00000000\n#define CG6_FBC_DRAW_RENDER\t\t0x00008000\n#define CG6_FBC_DRAW_PICK\t\t0x00010000\n#define CG6_FBC_DRAW_ILLEGAL\t\t0x00018000\n#define CG6_FBC_DRAW_MASK\t\t0x00018000\n\n#define CG6_FBC_BWRITE0_IGNORE\t\t0x00000000\n#define CG6_FBC_BWRITE0_ENABLE\t\t0x00002000\n#define CG6_FBC_BWRITE0_DISABLE\t\t0x00004000\n#define CG6_FBC_BWRITE0_ILLEGAL\t\t0x00006000\n#define CG6_FBC_BWRITE0_MASK\t\t0x00006000\n\n#define CG6_FBC_BWRITE1_IGNORE\t\t0x00000000\n#define CG6_FBC_BWRITE1_ENABLE\t\t0x00000800\n#define CG6_FBC_BWRITE1_DISABLE\t\t0x00001000\n#define CG6_FBC_BWRITE1_ILLEGAL\t\t0x00001800\n#define CG6_FBC_BWRITE1_MASK\t\t0x00001800\n\n#define CG6_FBC_BREAD_IGNORE\t\t0x00000000\n#define CG6_FBC_BREAD_0\t\t\t0x00000200\n#define CG6_FBC_BREAD_1\t\t\t0x00000400\n#define CG6_FBC_BREAD_ILLEGAL\t\t0x00000600\n#define CG6_FBC_BREAD_MASK\t\t0x00000600\n\n#define CG6_FBC_BDISP_IGNORE\t\t0x00000000\n#define CG6_FBC_BDISP_0\t\t\t0x00000080\n#define CG6_FBC_BDISP_1\t\t\t0x00000100\n#define CG6_FBC_BDISP_ILLEGAL\t\t0x00000180\n#define CG6_FBC_BDISP_MASK\t\t0x00000180\n\n#define CG6_FBC_INDEX_MOD\t\t0x00000040\n#define CG6_FBC_INDEX_MASK\t\t0x00000030\n\n \n#define CG6_THC_MISC_REV_SHIFT\t\t16\n#define CG6_THC_MISC_REV_MASK\t\t15\n#define CG6_THC_MISC_RESET\t\t(1 << 12)\n#define CG6_THC_MISC_VIDEO\t\t(1 << 10)\n#define CG6_THC_MISC_SYNC\t\t(1 << 9)\n#define CG6_THC_MISC_VSYNC\t\t(1 << 8)\n#define CG6_THC_MISC_SYNC_ENAB\t\t(1 << 7)\n#define CG6_THC_MISC_CURS_RES\t\t(1 << 6)\n#define CG6_THC_MISC_INT_ENAB\t\t(1 << 5)\n#define CG6_THC_MISC_INT\t\t(1 << 4)\n#define CG6_THC_MISC_INIT\t\t0x9f\n#define CG6_THC_CURSOFF\t\t\t((65536-32) | ((65536-32) << 16))\n\n \nstruct cg6_tec {\n\tint tec_matrix;\n\tint tec_clip;\n\tint tec_vdc;\n};\n\nstruct cg6_thc {\n\tu32\tthc_pad0[512];\n\tu32\tthc_hs;\t\t \n\tu32\tthc_hsdvs;\n\tu32\tthc_hd;\n\tu32\tthc_vs;\t\t \n\tu32\tthc_vd;\n\tu32\tthc_refresh;\n\tu32\tthc_misc;\n\tu32\tthc_pad1[56];\n\tu32\tthc_cursxy;\t \n\tu32\tthc_cursmask[32];\t \n\tu32\tthc_cursbits[32];\t \n};\n\nstruct cg6_fbc {\n\tu32\txxx0[1];\n\tu32\tmode;\n\tu32\tclip;\n\tu32\txxx1[1];\n\tu32\ts;\n\tu32\tdraw;\n\tu32\tblit;\n\tu32\tfont;\n\tu32\txxx2[24];\n\tu32\tx0, y0, z0, color0;\n\tu32\tx1, y1, z1, color1;\n\tu32\tx2, y2, z2, color2;\n\tu32\tx3, y3, z3, color3;\n\tu32\toffx, offy;\n\tu32\txxx3[2];\n\tu32\tincx, incy;\n\tu32\txxx4[2];\n\tu32\tclipminx, clipminy;\n\tu32\txxx5[2];\n\tu32\tclipmaxx, clipmaxy;\n\tu32\txxx6[2];\n\tu32\tfg;\n\tu32\tbg;\n\tu32\talu;\n\tu32\tpm;\n\tu32\tpixelm;\n\tu32\txxx7[2];\n\tu32\tpatalign;\n\tu32\tpattern[8];\n\tu32\txxx8[432];\n\tu32\tapointx, apointy, apointz;\n\tu32\txxx9[1];\n\tu32\trpointx, rpointy, rpointz;\n\tu32\txxx10[5];\n\tu32\tpointr, pointg, pointb, pointa;\n\tu32\talinex, aliney, alinez;\n\tu32\txxx11[1];\n\tu32\trlinex, rliney, rlinez;\n\tu32\txxx12[5];\n\tu32\tliner, lineg, lineb, linea;\n\tu32\tatrix, atriy, atriz;\n\tu32\txxx13[1];\n\tu32\trtrix, rtriy, rtriz;\n\tu32\txxx14[5];\n\tu32\ttrir, trig, trib, tria;\n\tu32\taquadx, aquady, aquadz;\n\tu32\txxx15[1];\n\tu32\trquadx, rquady, rquadz;\n\tu32\txxx16[5];\n\tu32\tquadr, quadg, quadb, quada;\n\tu32\tarectx, arecty, arectz;\n\tu32\txxx17[1];\n\tu32\trrectx, rrecty, rrectz;\n\tu32\txxx18[5];\n\tu32\trectr, rectg, rectb, recta;\n};\n\nstruct bt_regs {\n\tu32\taddr;\n\tu32\tcolor_map;\n\tu32\tcontrol;\n\tu32\tcursor;\n};\n\nstruct cg6_par {\n\tspinlock_t\t\tlock;\n\tstruct bt_regs\t\t__iomem *bt;\n\tstruct cg6_fbc\t\t__iomem *fbc;\n\tstruct cg6_thc\t\t__iomem *thc;\n\tstruct cg6_tec\t\t__iomem *tec;\n\tu32\t\t\t__iomem *fhc;\n\n\tu32\t\t\tflags;\n#define CG6_FLAG_BLANKED\t0x00000001\n\n\tunsigned long\t\twhich_io;\n};\n\nstatic int cg6_sync(struct fb_info *info)\n{\n\tstruct cg6_par *par = (struct cg6_par *)info->par;\n\tstruct cg6_fbc __iomem *fbc = par->fbc;\n\tint limit = 10000;\n\n\tdo {\n\t\tif (!(sbus_readl(&fbc->s) & 0x10000000))\n\t\t\tbreak;\n\t\tudelay(10);\n\t} while (--limit > 0);\n\n\treturn 0;\n}\n\nstatic void cg6_switch_from_graph(struct cg6_par *par)\n{\n\tstruct cg6_thc __iomem *thc = par->thc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\t \n\tsbus_writel(CG6_THC_CURSOFF, &thc->thc_cursxy);\n\n\tspin_unlock_irqrestore(&par->lock, flags);\n}\n\nstatic int cg6_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct cg6_par *par = (struct cg6_par *)info->par;\n\n\t \n\tcg6_switch_from_graph(par);\n\n\tif (var->xoffset || var->yoffset || var->vmode)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic void cg6_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct cg6_par *par = (struct cg6_par *)info->par;\n\tstruct cg6_fbc __iomem *fbc = par->fbc;\n\tunsigned long flags;\n\ts32 val;\n\n\t \n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tcg6_sync(info);\n\n\tsbus_writel(rect->color, &fbc->fg);\n\tsbus_writel(~(u32)0, &fbc->pixelm);\n\tsbus_writel(0xea80ff00, &fbc->alu);\n\tsbus_writel(0, &fbc->s);\n\tsbus_writel(0, &fbc->clip);\n\tsbus_writel(~(u32)0, &fbc->pm);\n\tsbus_writel(rect->dy, &fbc->arecty);\n\tsbus_writel(rect->dx, &fbc->arectx);\n\tsbus_writel(rect->dy + rect->height, &fbc->arecty);\n\tsbus_writel(rect->dx + rect->width, &fbc->arectx);\n\tdo {\n\t\tval = sbus_readl(&fbc->draw);\n\t} while (val < 0 && (val & 0x20000000));\n\tspin_unlock_irqrestore(&par->lock, flags);\n}\n\n \nstatic void cg6_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tstruct cg6_par *par = (struct cg6_par *)info->par;\n\tstruct cg6_fbc __iomem *fbc = par->fbc;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tcg6_sync(info);\n\n\tsbus_writel(0xff, &fbc->fg);\n\tsbus_writel(0x00, &fbc->bg);\n\tsbus_writel(~0, &fbc->pixelm);\n\tsbus_writel(0xe880cccc, &fbc->alu);\n\tsbus_writel(0, &fbc->s);\n\tsbus_writel(0, &fbc->clip);\n\n\tsbus_writel(area->sy, &fbc->y0);\n\tsbus_writel(area->sx, &fbc->x0);\n\tsbus_writel(area->sy + area->height - 1, &fbc->y1);\n\tsbus_writel(area->sx + area->width - 1, &fbc->x1);\n\tsbus_writel(area->dy, &fbc->y2);\n\tsbus_writel(area->dx, &fbc->x2);\n\tsbus_writel(area->dy + area->height - 1, &fbc->y3);\n\tsbus_writel(area->dx + area->width - 1, &fbc->x3);\n\tdo {\n\t\ti = sbus_readl(&fbc->blit);\n\t} while (i < 0 && (i & 0x20000000));\n\tspin_unlock_irqrestore(&par->lock, flags);\n}\n\n \nstatic void cg6_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct cg6_par *par = (struct cg6_par *)info->par;\n\tstruct cg6_fbc __iomem *fbc = par->fbc;\n\tconst u8 *data = image->data;\n\tunsigned long flags;\n\tu32 x, y;\n\tint i, width;\n\n\tif (image->depth > 1) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tcg6_sync(info);\n\n\tsbus_writel(image->fg_color, &fbc->fg);\n\tsbus_writel(image->bg_color, &fbc->bg);\n\tsbus_writel(0x140000, &fbc->mode);\n\tsbus_writel(0xe880fc30, &fbc->alu);\n\tsbus_writel(~(u32)0, &fbc->pixelm);\n\tsbus_writel(0, &fbc->s);\n\tsbus_writel(0, &fbc->clip);\n\tsbus_writel(0xff, &fbc->pm);\n\tsbus_writel(32, &fbc->incx);\n\tsbus_writel(0, &fbc->incy);\n\n\tx = image->dx;\n\ty = image->dy;\n\tfor (i = 0; i < image->height; i++) {\n\t\twidth = image->width;\n\n\t\twhile (width >= 32) {\n\t\t\tu32 val;\n\n\t\t\tsbus_writel(y, &fbc->y0);\n\t\t\tsbus_writel(x, &fbc->x0);\n\t\t\tsbus_writel(x + 32 - 1, &fbc->x1);\n\n\t\t\tval = ((u32)data[0] << 24) |\n\t\t\t      ((u32)data[1] << 16) |\n\t\t\t      ((u32)data[2] <<  8) |\n\t\t\t      ((u32)data[3] <<  0);\n\t\t\tsbus_writel(val, &fbc->font);\n\n\t\t\tdata += 4;\n\t\t\tx += 32;\n\t\t\twidth -= 32;\n\t\t}\n\t\tif (width) {\n\t\t\tu32 val;\n\n\t\t\tsbus_writel(y, &fbc->y0);\n\t\t\tsbus_writel(x, &fbc->x0);\n\t\t\tsbus_writel(x + width - 1, &fbc->x1);\n\t\t\tif (width <= 8) {\n\t\t\t\tval = (u32) data[0] << 24;\n\t\t\t\tdata += 1;\n\t\t\t} else if (width <= 16) {\n\t\t\t\tval = ((u32) data[0] << 24) |\n\t\t\t\t      ((u32) data[1] << 16);\n\t\t\t\tdata += 2;\n\t\t\t} else {\n\t\t\t\tval = ((u32) data[0] << 24) |\n\t\t\t\t      ((u32) data[1] << 16) |\n\t\t\t\t      ((u32) data[2] <<  8);\n\t\t\t\tdata += 3;\n\t\t\t}\n\t\t\tsbus_writel(val, &fbc->font);\n\t\t}\n\n\t\ty += 1;\n\t\tx = image->dx;\n\t}\n\n\tspin_unlock_irqrestore(&par->lock, flags);\n}\n\n \nstatic int cg6_setcolreg(unsigned regno,\n\t\t\t unsigned red, unsigned green, unsigned blue,\n\t\t\t unsigned transp, struct fb_info *info)\n{\n\tstruct cg6_par *par = (struct cg6_par *)info->par;\n\tstruct bt_regs __iomem *bt = par->bt;\n\tunsigned long flags;\n\n\tif (regno >= 256)\n\t\treturn 1;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tsbus_writel((u32)regno << 24, &bt->addr);\n\tsbus_writel((u32)red << 24, &bt->color_map);\n\tsbus_writel((u32)green << 24, &bt->color_map);\n\tsbus_writel((u32)blue << 24, &bt->color_map);\n\n\tspin_unlock_irqrestore(&par->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int cg6_blank(int blank, struct fb_info *info)\n{\n\tstruct cg6_par *par = (struct cg6_par *)info->par;\n\tstruct cg6_thc __iomem *thc = par->thc;\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\tval = sbus_readl(&thc->thc_misc);\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:  \n\t\tval |= CG6_THC_MISC_VIDEO;\n\t\tpar->flags &= ~CG6_FLAG_BLANKED;\n\t\tbreak;\n\n\tcase FB_BLANK_NORMAL:  \n\tcase FB_BLANK_VSYNC_SUSPEND:  \n\tcase FB_BLANK_HSYNC_SUSPEND:  \n\tcase FB_BLANK_POWERDOWN:  \n\t\tval &= ~CG6_THC_MISC_VIDEO;\n\t\tpar->flags |= CG6_FLAG_BLANKED;\n\t\tbreak;\n\t}\n\n\tsbus_writel(val, &thc->thc_misc);\n\tspin_unlock_irqrestore(&par->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct sbus_mmap_map cg6_mmap_map[] = {\n\t{\n\t\t.voff\t= CG6_FBC,\n\t\t.poff\t= CG6_FBC_OFFSET,\n\t\t.size\t= PAGE_SIZE\n\t},\n\t{\n\t\t.voff\t= CG6_TEC,\n\t\t.poff\t= CG6_TEC_OFFSET,\n\t\t.size\t= PAGE_SIZE\n\t},\n\t{\n\t\t.voff\t= CG6_BTREGS,\n\t\t.poff\t= CG6_BROOKTREE_OFFSET,\n\t\t.size\t= PAGE_SIZE\n\t},\n\t{\n\t\t.voff\t= CG6_FHC,\n\t\t.poff\t= CG6_FHC_OFFSET,\n\t\t.size\t= PAGE_SIZE\n\t},\n\t{\n\t\t.voff\t= CG6_THC,\n\t\t.poff\t= CG6_THC_OFFSET,\n\t\t.size\t= PAGE_SIZE\n\t},\n\t{\n\t\t.voff\t= CG6_ROM,\n\t\t.poff\t= CG6_ROM_OFFSET,\n\t\t.size\t= 0x10000\n\t},\n\t{\n\t\t.voff\t= CG6_RAM,\n\t\t.poff\t= CG6_RAM_OFFSET,\n\t\t.size\t= SBUS_MMAP_FBSIZE(1)\n\t},\n\t{\n\t\t.voff\t= CG6_DHC,\n\t\t.poff\t= CG6_DHC_OFFSET,\n\t\t.size\t= 0x40000\n\t},\n\t{ .size\t= 0 }\n};\n\nstatic int cg6_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct cg6_par *par = (struct cg6_par *)info->par;\n\n\treturn sbusfb_mmap_helper(cg6_mmap_map,\n\t\t\t\t  info->fix.smem_start, info->fix.smem_len,\n\t\t\t\t  par->which_io, vma);\n}\n\nstatic int cg6_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\n{\n\treturn sbusfb_ioctl_helper(cmd, arg, info,\n\t\t\t\t   FBTYPE_SUNFAST_COLOR, 8, info->fix.smem_len);\n}\n\n \n\nstatic void cg6_init_fix(struct fb_info *info, int linebytes)\n{\n\tstruct cg6_par *par = (struct cg6_par *)info->par;\n\tconst char *cg6_cpu_name, *cg6_card_name;\n\tu32 conf;\n\n\tconf = sbus_readl(par->fhc);\n\tswitch (conf & CG6_FHC_CPU_MASK) {\n\tcase CG6_FHC_CPU_SPARC:\n\t\tcg6_cpu_name = \"sparc\";\n\t\tbreak;\n\tcase CG6_FHC_CPU_68020:\n\t\tcg6_cpu_name = \"68020\";\n\t\tbreak;\n\tdefault:\n\t\tcg6_cpu_name = \"i386\";\n\t\tbreak;\n\t}\n\tif (((conf >> CG6_FHC_REV_SHIFT) & CG6_FHC_REV_MASK) >= 11) {\n\t\tif (info->fix.smem_len <= 0x100000)\n\t\t\tcg6_card_name = \"TGX\";\n\t\telse\n\t\t\tcg6_card_name = \"TGX+\";\n\t} else {\n\t\tif (info->fix.smem_len <= 0x100000)\n\t\t\tcg6_card_name = \"GX\";\n\t\telse\n\t\t\tcg6_card_name = \"GX+\";\n\t}\n\n\tsprintf(info->fix.id, \"%s %s\", cg6_card_name, cg6_cpu_name);\n\tinfo->fix.id[sizeof(info->fix.id) - 1] = 0;\n\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\n\tinfo->fix.line_length = linebytes;\n\n\tinfo->fix.accel = FB_ACCEL_SUN_CGSIX;\n}\n\n \nstatic void cg6_bt_init(struct cg6_par *par)\n{\n\tstruct bt_regs __iomem *bt = par->bt;\n\n\tsbus_writel(0x04 << 24, &bt->addr);\t  \n\tsbus_writel(0xff << 24, &bt->control);\n\tsbus_writel(0x05 << 24, &bt->addr);\n\tsbus_writel(0x00 << 24, &bt->control);\n\tsbus_writel(0x06 << 24, &bt->addr);\t  \n\tsbus_writel(0x73 << 24, &bt->control);\n\tsbus_writel(0x07 << 24, &bt->addr);\n\tsbus_writel(0x00 << 24, &bt->control);\n}\n\nstatic void cg6_chip_init(struct fb_info *info)\n{\n\tstruct cg6_par *par = (struct cg6_par *)info->par;\n\tstruct cg6_tec __iomem *tec = par->tec;\n\tstruct cg6_fbc __iomem *fbc = par->fbc;\n\tstruct cg6_thc __iomem *thc = par->thc;\n\tu32 rev, conf, mode;\n\tint i;\n\n\t \n\tsbus_writel(CG6_THC_CURSOFF, &thc->thc_cursxy);\n\n\t \n\tsbus_writel(0, &tec->tec_matrix);\n\tsbus_writel(0, &tec->tec_clip);\n\tsbus_writel(0, &tec->tec_vdc);\n\n\t \n\trev = (sbus_readl(par->fhc) >> CG6_FHC_REV_SHIFT) & CG6_FHC_REV_MASK;\n\tif (rev < 5) {\n\t\tconf = (sbus_readl(par->fhc) & CG6_FHC_RES_MASK) |\n\t\t\tCG6_FHC_CPU_68020 | CG6_FHC_TEST |\n\t\t\t(11 << CG6_FHC_TEST_X_SHIFT) |\n\t\t\t(11 << CG6_FHC_TEST_Y_SHIFT);\n\t\tif (rev < 2)\n\t\t\tconf |= CG6_FHC_DST_DISABLE;\n\t\tsbus_writel(conf, par->fhc);\n\t}\n\n\t \n\tmode = sbus_readl(&fbc->mode);\n\tdo {\n\t\ti = sbus_readl(&fbc->s);\n\t} while (i & 0x10000000);\n\tmode &= ~(CG6_FBC_BLIT_MASK | CG6_FBC_MODE_MASK |\n\t\t  CG6_FBC_DRAW_MASK | CG6_FBC_BWRITE0_MASK |\n\t\t  CG6_FBC_BWRITE1_MASK | CG6_FBC_BREAD_MASK |\n\t\t  CG6_FBC_BDISP_MASK);\n\tmode |= (CG6_FBC_BLIT_SRC | CG6_FBC_MODE_COLOR8 |\n\t\t CG6_FBC_DRAW_RENDER | CG6_FBC_BWRITE0_ENABLE |\n\t\t CG6_FBC_BWRITE1_DISABLE | CG6_FBC_BREAD_0 |\n\t\t CG6_FBC_BDISP_0);\n\tsbus_writel(mode, &fbc->mode);\n\n\tsbus_writel(0, &fbc->clip);\n\tsbus_writel(0, &fbc->offx);\n\tsbus_writel(0, &fbc->offy);\n\tsbus_writel(0, &fbc->clipminx);\n\tsbus_writel(0, &fbc->clipminy);\n\tsbus_writel(info->var.xres - 1, &fbc->clipmaxx);\n\tsbus_writel(info->var.yres - 1, &fbc->clipmaxy);\n}\n\nstatic void cg6_unmap_regs(struct platform_device *op, struct fb_info *info,\n\t\t\t   struct cg6_par *par)\n{\n\tif (par->fbc)\n\t\tof_iounmap(&op->resource[0], par->fbc, 4096);\n\tif (par->tec)\n\t\tof_iounmap(&op->resource[0], par->tec, sizeof(struct cg6_tec));\n\tif (par->thc)\n\t\tof_iounmap(&op->resource[0], par->thc, sizeof(struct cg6_thc));\n\tif (par->bt)\n\t\tof_iounmap(&op->resource[0], par->bt, sizeof(struct bt_regs));\n\tif (par->fhc)\n\t\tof_iounmap(&op->resource[0], par->fhc, sizeof(u32));\n\n\tif (info->screen_base)\n\t\tof_iounmap(&op->resource[0], info->screen_base,\n\t\t\t   info->fix.smem_len);\n}\n\nstatic int cg6_probe(struct platform_device *op)\n{\n\tstruct device_node *dp = op->dev.of_node;\n\tstruct fb_info *info;\n\tstruct cg6_par *par;\n\tint linebytes, err;\n\tint dblbuf;\n\n\tinfo = framebuffer_alloc(sizeof(struct cg6_par), &op->dev);\n\n\terr = -ENOMEM;\n\tif (!info)\n\t\tgoto out_err;\n\tpar = info->par;\n\n\tspin_lock_init(&par->lock);\n\n\tinfo->fix.smem_start = op->resource[0].start;\n\tpar->which_io = op->resource[0].flags & IORESOURCE_BITS;\n\n\tsbusfb_fill_var(&info->var, dp, 8);\n\tinfo->var.red.length = 8;\n\tinfo->var.green.length = 8;\n\tinfo->var.blue.length = 8;\n\n\tlinebytes = of_getintprop_default(dp, \"linebytes\",\n\t\t\t\t\t  info->var.xres);\n\tinfo->fix.smem_len = PAGE_ALIGN(linebytes * info->var.yres);\n\n\tdblbuf = of_getintprop_default(dp, \"dblbuf\", 0);\n\tif (dblbuf)\n\t\tinfo->fix.smem_len *= 4;\n\n\tpar->fbc = of_ioremap(&op->resource[0], CG6_FBC_OFFSET,\n\t\t\t\t4096, \"cgsix fbc\");\n\tpar->tec = of_ioremap(&op->resource[0], CG6_TEC_OFFSET,\n\t\t\t\tsizeof(struct cg6_tec), \"cgsix tec\");\n\tpar->thc = of_ioremap(&op->resource[0], CG6_THC_OFFSET,\n\t\t\t\tsizeof(struct cg6_thc), \"cgsix thc\");\n\tpar->bt = of_ioremap(&op->resource[0], CG6_BROOKTREE_OFFSET,\n\t\t\t\tsizeof(struct bt_regs), \"cgsix dac\");\n\tpar->fhc = of_ioremap(&op->resource[0], CG6_FHC_OFFSET,\n\t\t\t\tsizeof(u32), \"cgsix fhc\");\n\n\tinfo->flags = FBINFO_HWACCEL_IMAGEBLIT |\n\t\t\tFBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |\n\t\t\tFBINFO_READS_FAST;\n\tinfo->fbops = &cg6_ops;\n\n\tinfo->screen_base = of_ioremap(&op->resource[0], CG6_RAM_OFFSET,\n\t\t\t\t\tinfo->fix.smem_len, \"cgsix ram\");\n\tif (!par->fbc || !par->tec || !par->thc ||\n\t    !par->bt || !par->fhc || !info->screen_base)\n\t\tgoto out_unmap_regs;\n\n\tinfo->var.accel_flags = FB_ACCELF_TEXT;\n\n\tcg6_bt_init(par);\n\tcg6_chip_init(info);\n\tcg6_blank(FB_BLANK_UNBLANK, info);\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0))\n\t\tgoto out_unmap_regs;\n\n\tfb_set_cmap(&info->cmap, info);\n\tcg6_init_fix(info, linebytes);\n\n\terr = register_framebuffer(info);\n\tif (err < 0)\n\t\tgoto out_dealloc_cmap;\n\n\tdev_set_drvdata(&op->dev, info);\n\n\tprintk(KERN_INFO \"%pOF: CGsix [%s] at %lx:%lx\\n\",\n\t       dp, info->fix.id,\n\t       par->which_io, info->fix.smem_start);\n\n\treturn 0;\n\nout_dealloc_cmap:\n\tfb_dealloc_cmap(&info->cmap);\n\nout_unmap_regs:\n\tcg6_unmap_regs(op, info, par);\n\tframebuffer_release(info);\n\nout_err:\n\treturn err;\n}\n\nstatic void cg6_remove(struct platform_device *op)\n{\n\tstruct fb_info *info = dev_get_drvdata(&op->dev);\n\tstruct cg6_par *par = info->par;\n\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\n\tcg6_unmap_regs(op, info, par);\n\n\tframebuffer_release(info);\n}\n\nstatic const struct of_device_id cg6_match[] = {\n\t{\n\t\t.name = \"cgsix\",\n\t},\n\t{\n\t\t.name = \"cgthree+\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cg6_match);\n\nstatic struct platform_driver cg6_driver = {\n\t.driver = {\n\t\t.name = \"cg6\",\n\t\t.of_match_table = cg6_match,\n\t},\n\t.probe\t\t= cg6_probe,\n\t.remove_new\t= cg6_remove,\n};\n\nstatic int __init cg6_init(void)\n{\n\tif (fb_get_options(\"cg6fb\", NULL))\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&cg6_driver);\n}\n\nstatic void __exit cg6_exit(void)\n{\n\tplatform_driver_unregister(&cg6_driver);\n}\n\nmodule_init(cg6_init);\nmodule_exit(cg6_exit);\n\nMODULE_DESCRIPTION(\"framebuffer driver for CGsix chipsets\");\nMODULE_AUTHOR(\"David S. Miller <davem@davemloft.net>\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}