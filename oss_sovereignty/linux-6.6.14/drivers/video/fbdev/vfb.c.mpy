{
  "module_name": "vfb.c",
  "hash_id": "92579f013fdb3eaf9cc1a65949d3124f74995fa1d765a86e448254d1bc2336b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/vfb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n\n#include <linux/fb.h>\n#include <linux/init.h>\n\n     \n\n#define VIDEOMEMSIZE\t(1*1024*1024)\t \n\nstatic void *videomemory;\nstatic u_long videomemorysize = VIDEOMEMSIZE;\nmodule_param(videomemorysize, ulong, 0);\nMODULE_PARM_DESC(videomemorysize, \"RAM available to frame buffer (in bytes)\");\n\nstatic char *mode_option = NULL;\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Preferred video mode (e.g. 640x480-8@60)\");\n\nstatic const struct fb_videomode vfb_default = {\n\t.xres =\t\t640,\n\t.yres =\t\t480,\n\t.pixclock =\t20000,\n\t.left_margin =\t64,\n\t.right_margin =\t64,\n\t.upper_margin =\t32,\n\t.lower_margin =\t32,\n\t.hsync_len =\t64,\n\t.vsync_len =\t2,\n\t.vmode =\tFB_VMODE_NONINTERLACED,\n};\n\nstatic struct fb_fix_screeninfo vfb_fix = {\n\t.id =\t\t\"Virtual FB\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_PSEUDOCOLOR,\n\t.xpanstep =\t1,\n\t.ypanstep =\t1,\n\t.ywrapstep =\t1,\n\t.accel =\tFB_ACCEL_NONE,\n};\n\nstatic bool vfb_enable __initdata = 0;\t \nmodule_param(vfb_enable, bool, 0);\nMODULE_PARM_DESC(vfb_enable, \"Enable Virtual FB driver\");\n\nstatic int vfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t struct fb_info *info);\nstatic int vfb_set_par(struct fb_info *info);\nstatic int vfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t u_int transp, struct fb_info *info);\nstatic int vfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t   struct fb_info *info);\nstatic int vfb_mmap(struct fb_info *info,\n\t\t    struct vm_area_struct *vma);\n\nstatic const struct fb_ops vfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_read        = fb_sys_read,\n\t.fb_write       = fb_sys_write,\n\t.fb_check_var\t= vfb_check_var,\n\t.fb_set_par\t= vfb_set_par,\n\t.fb_setcolreg\t= vfb_setcolreg,\n\t.fb_pan_display\t= vfb_pan_display,\n\t.fb_fillrect\t= sys_fillrect,\n\t.fb_copyarea\t= sys_copyarea,\n\t.fb_imageblit\t= sys_imageblit,\n\t.fb_mmap\t= vfb_mmap,\n};\n\n     \n\nstatic u_long get_line_length(int xres_virtual, int bpp)\n{\n\tu_long length;\n\n\tlength = xres_virtual * bpp;\n\tlength = (length + 31) & ~31;\n\tlength >>= 3;\n\treturn (length);\n}\n\n     \n\nstatic int vfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t struct fb_info *info)\n{\n\tu_long line_length;\n\n\t \n\n\tif (var->vmode & FB_VMODE_CONUPDATE) {\n\t\tvar->vmode |= FB_VMODE_YWRAP;\n\t\tvar->xoffset = info->var.xoffset;\n\t\tvar->yoffset = info->var.yoffset;\n\t}\n\n\t \n\tif (!var->xres)\n\t\tvar->xres = 1;\n\tif (!var->yres)\n\t\tvar->yres = 1;\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\tif (var->bits_per_pixel <= 1)\n\t\tvar->bits_per_pixel = 1;\n\telse if (var->bits_per_pixel <= 8)\n\t\tvar->bits_per_pixel = 8;\n\telse if (var->bits_per_pixel <= 16)\n\t\tvar->bits_per_pixel = 16;\n\telse if (var->bits_per_pixel <= 24)\n\t\tvar->bits_per_pixel = 24;\n\telse if (var->bits_per_pixel <= 32)\n\t\tvar->bits_per_pixel = 32;\n\telse\n\t\treturn -EINVAL;\n\n\tif (var->xres_virtual < var->xoffset + var->xres)\n\t\tvar->xres_virtual = var->xoffset + var->xres;\n\tif (var->yres_virtual < var->yoffset + var->yres)\n\t\tvar->yres_virtual = var->yoffset + var->yres;\n\n\t \n\tline_length =\n\t    get_line_length(var->xres_virtual, var->bits_per_pixel);\n\tif (line_length * var->yres_virtual > videomemorysize)\n\t\treturn -ENOMEM;\n\n\t \n\tswitch (var->bits_per_pixel) {\n\tcase 1:\n\tcase 8:\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 16:\t\t \n\t\tif (var->transp.length) {\n\t\t\tvar->red.offset = 0;\n\t\t\tvar->red.length = 5;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->green.length = 5;\n\t\t\tvar->blue.offset = 10;\n\t\t\tvar->blue.length = 5;\n\t\t\tvar->transp.offset = 15;\n\t\t\tvar->transp.length = 1;\n\t\t} else {\t \n\t\t\tvar->red.offset = 0;\n\t\t\tvar->red.length = 5;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->green.length = 6;\n\t\t\tvar->blue.offset = 11;\n\t\t\tvar->blue.length = 5;\n\t\t\tvar->transp.offset = 0;\n\t\t\tvar->transp.length = 0;\n\t\t}\n\t\tbreak;\n\tcase 24:\t\t \n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 16;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 32:\t\t \n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 16;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tbreak;\n\t}\n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.msb_right = 0;\n\tvar->transp.msb_right = 0;\n\n\treturn 0;\n}\n\n \nstatic int vfb_set_par(struct fb_info *info)\n{\n\tswitch (info->var.bits_per_pixel) {\n\tcase 1:\n\t\tinfo->fix.visual = FB_VISUAL_MONO01;\n\t\tbreak;\n\tcase 8:\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\t}\n\n\tinfo->fix.line_length = get_line_length(info->var.xres_virtual,\n\t\t\t\t\t\tinfo->var.bits_per_pixel);\n\n\treturn 0;\n}\n\n     \n\nstatic int vfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t u_int transp, struct fb_info *info)\n{\n\tif (regno >= 256)\t \n\t\treturn 1;\n\t \n\n\t \n\tif (info->var.grayscale) {\n\t\t \n\t\tred = green = blue =\n\t\t    (red * 77 + green * 151 + blue * 28) >> 8;\n\t}\n\n\t \n#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tred = CNVT_TOHW(red, info->var.red.length);\n\t\tgreen = CNVT_TOHW(green, info->var.green.length);\n\t\tblue = CNVT_TOHW(blue, info->var.blue.length);\n\t\ttransp = CNVT_TOHW(transp, info->var.transp.length);\n\t\tbreak;\n\tcase FB_VISUAL_DIRECTCOLOR:\n\t\tred = CNVT_TOHW(red, 8);\t \n\t\tgreen = CNVT_TOHW(green, 8);\n\t\tblue = CNVT_TOHW(blue, 8);\n\t\t \n\t\ttransp = CNVT_TOHW(transp, 8);\n\t\tbreak;\n\t}\n#undef CNVT_TOHW\n\t \n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\tu32 v;\n\n\t\tif (regno >= 16)\n\t\t\treturn 1;\n\n\t\tv = (red << info->var.red.offset) |\n\t\t    (green << info->var.green.offset) |\n\t\t    (blue << info->var.blue.offset) |\n\t\t    (transp << info->var.transp.offset);\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 8:\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\t((u32 *) (info->pseudo_palette))[regno] = v;\n\t\t\tbreak;\n\t\tcase 24:\n\t\tcase 32:\n\t\t\t((u32 *) (info->pseudo_palette))[regno] = v;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n     \n\nstatic int vfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t   struct fb_info *info)\n{\n\tif (var->vmode & FB_VMODE_YWRAP) {\n\t\tif (var->yoffset >= info->var.yres_virtual ||\n\t\t    var->xoffset)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (var->xoffset + info->var.xres > info->var.xres_virtual ||\n\t\t    var->yoffset + info->var.yres > info->var.yres_virtual)\n\t\t\treturn -EINVAL;\n\t}\n\tinfo->var.xoffset = var->xoffset;\n\tinfo->var.yoffset = var->yoffset;\n\tif (var->vmode & FB_VMODE_YWRAP)\n\t\tinfo->var.vmode |= FB_VMODE_YWRAP;\n\telse\n\t\tinfo->var.vmode &= ~FB_VMODE_YWRAP;\n\treturn 0;\n}\n\n     \n\nstatic int vfb_mmap(struct fb_info *info,\n\t\t    struct vm_area_struct *vma)\n{\n\treturn remap_vmalloc_range(vma, (void *)info->fix.smem_start, vma->vm_pgoff);\n}\n\n#ifndef MODULE\n \nstatic int __init vfb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tvfb_enable = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\tvfb_enable = 1;\n\n\tif (!*options)\n\t\treturn 1;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\t\t \n\t\tif (!strcmp(this_opt, \"disable\"))\n\t\t\tvfb_enable = 0;\n\t\telse\n\t\t\tmode_option = this_opt;\n\t}\n\treturn 1;\n}\n#endif   \n\n     \n\nstatic int vfb_probe(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\tunsigned int size = PAGE_ALIGN(videomemorysize);\n\tint retval = -ENOMEM;\n\n\t \n\tif (!(videomemory = vmalloc_32_user(size)))\n\t\treturn retval;\n\n\tinfo = framebuffer_alloc(sizeof(u32) * 256, &dev->dev);\n\tif (!info)\n\t\tgoto err;\n\n\tinfo->screen_buffer = videomemory;\n\tinfo->fbops = &vfb_ops;\n\n\tif (!fb_find_mode(&info->var, info, mode_option,\n\t\t\t  NULL, 0, &vfb_default, 8)){\n\t\tfb_err(info, \"Unable to find usable video mode.\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err1;\n\t}\n\n\tvfb_fix.smem_start = (unsigned long) videomemory;\n\tvfb_fix.smem_len = videomemorysize;\n\tinfo->fix = vfb_fix;\n\tinfo->pseudo_palette = info->par;\n\tinfo->par = NULL;\n\n\tretval = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (retval < 0)\n\t\tgoto err1;\n\n\tretval = register_framebuffer(info);\n\tif (retval < 0)\n\t\tgoto err2;\n\tplatform_set_drvdata(dev, info);\n\n\tvfb_set_par(info);\n\n\tfb_info(info, \"Virtual frame buffer device, using %ldK of video memory\\n\",\n\t\tvideomemorysize >> 10);\n\treturn 0;\nerr2:\n\tfb_dealloc_cmap(&info->cmap);\nerr1:\n\tframebuffer_release(info);\nerr:\n\tvfree(videomemory);\n\treturn retval;\n}\n\nstatic void vfb_remove(struct platform_device *dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\n\tif (info) {\n\t\tunregister_framebuffer(info);\n\t\tvfree(videomemory);\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\tframebuffer_release(info);\n\t}\n}\n\nstatic struct platform_driver vfb_driver = {\n\t.probe\t= vfb_probe,\n\t.remove_new = vfb_remove,\n\t.driver = {\n\t\t.name\t= \"vfb\",\n\t},\n};\n\nstatic struct platform_device *vfb_device;\n\nstatic int __init vfb_init(void)\n{\n\tint ret = 0;\n\n#ifndef MODULE\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"vfb\", &option))\n\t\treturn -ENODEV;\n\tvfb_setup(option);\n#endif\n\n\tif (!vfb_enable)\n\t\treturn -ENXIO;\n\n\tret = platform_driver_register(&vfb_driver);\n\n\tif (!ret) {\n\t\tvfb_device = platform_device_alloc(\"vfb\", 0);\n\n\t\tif (vfb_device)\n\t\t\tret = platform_device_add(vfb_device);\n\t\telse\n\t\t\tret = -ENOMEM;\n\n\t\tif (ret) {\n\t\t\tplatform_device_put(vfb_device);\n\t\t\tplatform_driver_unregister(&vfb_driver);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nmodule_init(vfb_init);\n\n#ifdef MODULE\nstatic void __exit vfb_exit(void)\n{\n\tplatform_device_unregister(vfb_device);\n\tplatform_driver_unregister(&vfb_driver);\n}\n\nmodule_exit(vfb_exit);\n\nMODULE_LICENSE(\"GPL\");\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}