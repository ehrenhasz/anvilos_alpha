{
  "module_name": "smscufx.c",
  "hash_id": "97d84e123a6139d5c4ff95500617382218dddff19a66e6005215e68662b4ba7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/smscufx.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/usb.h>\n#include <linux/uaccess.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include \"edid.h\"\n\n#define check_warn(status, fmt, args...) \\\n\t({ if (status < 0) pr_warn(fmt, ##args); })\n\n#define check_warn_return(status, fmt, args...) \\\n\t({ if (status < 0) { pr_warn(fmt, ##args); return status; } })\n\n#define check_warn_goto_error(status, fmt, args...) \\\n\t({ if (status < 0) { pr_warn(fmt, ##args); goto error; } })\n\n#define all_bits_set(x, bits) (((x) & (bits)) == (bits))\n\n#define USB_VENDOR_REQUEST_WRITE_REGISTER\t0xA0\n#define USB_VENDOR_REQUEST_READ_REGISTER\t0xA1\n\n \n#define UFX_IOCTL_RETURN_EDID\t(0xAD)\n#define UFX_IOCTL_REPORT_DAMAGE\t(0xAA)\n\n \n#define BULK_SIZE\t\t(512)\n#define MAX_TRANSFER\t\t(PAGE_SIZE*16 - BULK_SIZE)\n#define WRITES_IN_FLIGHT\t(4)\n\n#define GET_URB_TIMEOUT\t\t(HZ)\n#define FREE_URB_TIMEOUT\t(HZ*2)\n\n#define BPP\t\t\t2\n\n#define UFX_DEFIO_WRITE_DELAY\t5  \n#define UFX_DEFIO_WRITE_DISABLE\t(HZ*60)  \n\nstruct dloarea {\n\tint x, y;\n\tint w, h;\n};\n\nstruct urb_node {\n\tstruct list_head entry;\n\tstruct ufx_data *dev;\n\tstruct delayed_work release_urb_work;\n\tstruct urb *urb;\n};\n\nstruct urb_list {\n\tstruct list_head list;\n\tspinlock_t lock;\n\tstruct semaphore limit_sem;\n\tint available;\n\tint count;\n\tsize_t size;\n};\n\nstruct ufx_data {\n\tstruct usb_device *udev;\n\tstruct device *gdev;  \n\tstruct fb_info *info;\n\tstruct urb_list urbs;\n\tstruct kref kref;\n\tint fb_count;\n\tbool virtualized;  \n\tatomic_t usb_active;  \n\tatomic_t lost_pixels;  \n\tu8 *edid;  \n\tsize_t edid_size;\n\tu32 pseudo_palette[256];\n};\n\nstatic struct fb_fix_screeninfo ufx_fix = {\n\t.id =           \"smscufx\",\n\t.type =         FB_TYPE_PACKED_PIXELS,\n\t.visual =       FB_VISUAL_TRUECOLOR,\n\t.xpanstep =     0,\n\t.ypanstep =     0,\n\t.ywrapstep =    0,\n\t.accel =        FB_ACCEL_NONE,\n};\n\nstatic const u32 smscufx_info_flags = FBINFO_READS_FAST |\n\tFBINFO_VIRTFB |\tFBINFO_HWACCEL_IMAGEBLIT | FBINFO_HWACCEL_FILLRECT |\n\tFBINFO_HWACCEL_COPYAREA | FBINFO_MISC_ALWAYS_SETPAR;\n\nstatic const struct usb_device_id id_table[] = {\n\t{USB_DEVICE(0x0424, 0x9d00),},\n\t{USB_DEVICE(0x0424, 0x9d01),},\n\t{},\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\n \nstatic bool console;    \nstatic bool fb_defio = true;   \n\n \nstatic void ufx_urb_completion(struct urb *urb);\nstatic struct urb *ufx_get_urb(struct ufx_data *dev);\nstatic int ufx_submit_urb(struct ufx_data *dev, struct urb * urb, size_t len);\nstatic int ufx_alloc_urb_list(struct ufx_data *dev, int count, size_t size);\nstatic void ufx_free_urb_list(struct ufx_data *dev);\n\nstatic DEFINE_MUTEX(disconnect_mutex);\n\n \nstatic int ufx_reg_read(struct ufx_data *dev, u32 index, u32 *data)\n{\n\tu32 *buf = kmalloc(4, GFP_KERNEL);\n\tint ret;\n\n\tBUG_ON(!dev);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\tUSB_VENDOR_REQUEST_READ_REGISTER,\n\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t00, index, buf, 4, USB_CTRL_GET_TIMEOUT);\n\n\tle32_to_cpus(buf);\n\t*data = *buf;\n\tkfree(buf);\n\n\tif (unlikely(ret < 0))\n\t\tpr_warn(\"Failed to read register index 0x%08x\\n\", index);\n\n\treturn ret;\n}\n\n \nstatic int ufx_reg_write(struct ufx_data *dev, u32 index, u32 data)\n{\n\tu32 *buf = kmalloc(4, GFP_KERNEL);\n\tint ret;\n\n\tBUG_ON(!dev);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t*buf = data;\n\tcpu_to_le32s(buf);\n\n\tret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\tUSB_VENDOR_REQUEST_WRITE_REGISTER,\n\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t00, index, buf, 4, USB_CTRL_SET_TIMEOUT);\n\n\tkfree(buf);\n\n\tif (unlikely(ret < 0))\n\t\tpr_warn(\"Failed to write register index 0x%08x with value \"\n\t\t\t\"0x%08x\\n\", index, data);\n\n\treturn ret;\n}\n\nstatic int ufx_reg_clear_and_set_bits(struct ufx_data *dev, u32 index,\n\tu32 bits_to_clear, u32 bits_to_set)\n{\n\tu32 data;\n\tint status = ufx_reg_read(dev, index, &data);\n\tcheck_warn_return(status, \"ufx_reg_clear_and_set_bits error reading \"\n\t\t\"0x%x\", index);\n\n\tdata &= (~bits_to_clear);\n\tdata |= bits_to_set;\n\n\tstatus = ufx_reg_write(dev, index, data);\n\tcheck_warn_return(status, \"ufx_reg_clear_and_set_bits error writing \"\n\t\t\"0x%x\", index);\n\n\treturn 0;\n}\n\nstatic int ufx_reg_set_bits(struct ufx_data *dev, u32 index, u32 bits)\n{\n\treturn ufx_reg_clear_and_set_bits(dev, index, 0, bits);\n}\n\nstatic int ufx_reg_clear_bits(struct ufx_data *dev, u32 index, u32 bits)\n{\n\treturn ufx_reg_clear_and_set_bits(dev, index, bits, 0);\n}\n\nstatic int ufx_lite_reset(struct ufx_data *dev)\n{\n\tint status;\n\tu32 value;\n\n\tstatus = ufx_reg_write(dev, 0x3008, 0x00000001);\n\tcheck_warn_return(status, \"ufx_lite_reset error writing 0x3008\");\n\n\tstatus = ufx_reg_read(dev, 0x3008, &value);\n\tcheck_warn_return(status, \"ufx_lite_reset error reading 0x3008\");\n\n\treturn (value == 0) ? 0 : -EIO;\n}\n\n \nstatic int ufx_blank(struct ufx_data *dev, bool wait)\n{\n\tu32 dc_ctrl, dc_sts;\n\tint i;\n\n\tint status = ufx_reg_read(dev, 0x2004, &dc_sts);\n\tcheck_warn_return(status, \"ufx_blank error reading 0x2004\");\n\n\tstatus = ufx_reg_read(dev, 0x2000, &dc_ctrl);\n\tcheck_warn_return(status, \"ufx_blank error reading 0x2000\");\n\n\t \n\tif ((dc_sts & 0x00000100) || (dc_ctrl & 0x00000100))\n\t\treturn 0;\n\n\t \n\tdc_ctrl |= 0x00000100;\n\tstatus = ufx_reg_write(dev, 0x2000, dc_ctrl);\n\tcheck_warn_return(status, \"ufx_blank error writing 0x2000\");\n\n\t \n\tif (!wait)\n\t\treturn 0;\n\n\tfor (i = 0; i < 250; i++) {\n\t\tstatus = ufx_reg_read(dev, 0x2004, &dc_sts);\n\t\tcheck_warn_return(status, \"ufx_blank error reading 0x2004\");\n\n\t\tif (dc_sts & 0x00000100)\n\t\t\treturn 0;\n\t}\n\n\t \n\treturn -EIO;\n}\n\n \nstatic int ufx_unblank(struct ufx_data *dev, bool wait)\n{\n\tu32 dc_ctrl, dc_sts;\n\tint i;\n\n\tint status = ufx_reg_read(dev, 0x2004, &dc_sts);\n\tcheck_warn_return(status, \"ufx_unblank error reading 0x2004\");\n\n\tstatus = ufx_reg_read(dev, 0x2000, &dc_ctrl);\n\tcheck_warn_return(status, \"ufx_unblank error reading 0x2000\");\n\n\t \n\tif (((dc_sts & 0x00000100) == 0) || ((dc_ctrl & 0x00000100) == 0))\n\t\treturn 0;\n\n\t \n\tdc_ctrl &= ~0x00000100;\n\tstatus = ufx_reg_write(dev, 0x2000, dc_ctrl);\n\tcheck_warn_return(status, \"ufx_unblank error writing 0x2000\");\n\n\t \n\tif (!wait)\n\t\treturn 0;\n\n\tfor (i = 0; i < 250; i++) {\n\t\tstatus = ufx_reg_read(dev, 0x2004, &dc_sts);\n\t\tcheck_warn_return(status, \"ufx_unblank error reading 0x2004\");\n\n\t\tif ((dc_sts & 0x00000100) == 0)\n\t\t\treturn 0;\n\t}\n\n\t \n\treturn -EIO;\n}\n\n \nstatic int ufx_disable(struct ufx_data *dev, bool wait)\n{\n\tu32 dc_ctrl, dc_sts;\n\tint i;\n\n\tint status = ufx_reg_read(dev, 0x2004, &dc_sts);\n\tcheck_warn_return(status, \"ufx_disable error reading 0x2004\");\n\n\tstatus = ufx_reg_read(dev, 0x2000, &dc_ctrl);\n\tcheck_warn_return(status, \"ufx_disable error reading 0x2000\");\n\n\t \n\tif (((dc_sts & 0x00000001) == 0) || ((dc_ctrl & 0x00000001) == 0))\n\t\treturn 0;\n\n\t \n\tdc_ctrl &= ~(0x00000001);\n\tstatus = ufx_reg_write(dev, 0x2000, dc_ctrl);\n\tcheck_warn_return(status, \"ufx_disable error writing 0x2000\");\n\n\t \n\tif (!wait)\n\t\treturn 0;\n\n\tfor (i = 0; i < 250; i++) {\n\t\tstatus = ufx_reg_read(dev, 0x2004, &dc_sts);\n\t\tcheck_warn_return(status, \"ufx_disable error reading 0x2004\");\n\n\t\tif ((dc_sts & 0x00000001) == 0)\n\t\t\treturn 0;\n\t}\n\n\t \n\treturn -EIO;\n}\n\n \nstatic int ufx_enable(struct ufx_data *dev, bool wait)\n{\n\tu32 dc_ctrl, dc_sts;\n\tint i;\n\n\tint status = ufx_reg_read(dev, 0x2004, &dc_sts);\n\tcheck_warn_return(status, \"ufx_enable error reading 0x2004\");\n\n\tstatus = ufx_reg_read(dev, 0x2000, &dc_ctrl);\n\tcheck_warn_return(status, \"ufx_enable error reading 0x2000\");\n\n\t \n\tif ((dc_sts & 0x00000001) || (dc_ctrl & 0x00000001))\n\t\treturn 0;\n\n\t \n\tdc_ctrl |= 0x00000001;\n\tstatus = ufx_reg_write(dev, 0x2000, dc_ctrl);\n\tcheck_warn_return(status, \"ufx_enable error writing 0x2000\");\n\n\t \n\tif (!wait)\n\t\treturn 0;\n\n\tfor (i = 0; i < 250; i++) {\n\t\tstatus = ufx_reg_read(dev, 0x2004, &dc_sts);\n\t\tcheck_warn_return(status, \"ufx_enable error reading 0x2004\");\n\n\t\tif (dc_sts & 0x00000001)\n\t\t\treturn 0;\n\t}\n\n\t \n\treturn -EIO;\n}\n\nstatic int ufx_config_sys_clk(struct ufx_data *dev)\n{\n\tint status = ufx_reg_write(dev, 0x700C, 0x8000000F);\n\tcheck_warn_return(status, \"error writing 0x700C\");\n\n\tstatus = ufx_reg_write(dev, 0x7014, 0x0010024F);\n\tcheck_warn_return(status, \"error writing 0x7014\");\n\n\tstatus = ufx_reg_write(dev, 0x7010, 0x00000000);\n\tcheck_warn_return(status, \"error writing 0x7010\");\n\n\tstatus = ufx_reg_clear_bits(dev, 0x700C, 0x0000000A);\n\tcheck_warn_return(status, \"error clearing PLL1 bypass in 0x700C\");\n\tmsleep(1);\n\n\tstatus = ufx_reg_clear_bits(dev, 0x700C, 0x80000000);\n\tcheck_warn_return(status, \"error clearing output gate in 0x700C\");\n\n\treturn 0;\n}\n\nstatic int ufx_config_ddr2(struct ufx_data *dev)\n{\n\tint status, i = 0;\n\tu32 tmp;\n\n\tstatus = ufx_reg_write(dev, 0x0004, 0x001F0F77);\n\tcheck_warn_return(status, \"error writing 0x0004\");\n\n\tstatus = ufx_reg_write(dev, 0x0008, 0xFFF00000);\n\tcheck_warn_return(status, \"error writing 0x0008\");\n\n\tstatus = ufx_reg_write(dev, 0x000C, 0x0FFF2222);\n\tcheck_warn_return(status, \"error writing 0x000C\");\n\n\tstatus = ufx_reg_write(dev, 0x0010, 0x00030814);\n\tcheck_warn_return(status, \"error writing 0x0010\");\n\n\tstatus = ufx_reg_write(dev, 0x0014, 0x00500019);\n\tcheck_warn_return(status, \"error writing 0x0014\");\n\n\tstatus = ufx_reg_write(dev, 0x0018, 0x020D0F15);\n\tcheck_warn_return(status, \"error writing 0x0018\");\n\n\tstatus = ufx_reg_write(dev, 0x001C, 0x02532305);\n\tcheck_warn_return(status, \"error writing 0x001C\");\n\n\tstatus = ufx_reg_write(dev, 0x0020, 0x0B030905);\n\tcheck_warn_return(status, \"error writing 0x0020\");\n\n\tstatus = ufx_reg_write(dev, 0x0024, 0x00000827);\n\tcheck_warn_return(status, \"error writing 0x0024\");\n\n\tstatus = ufx_reg_write(dev, 0x0028, 0x00000000);\n\tcheck_warn_return(status, \"error writing 0x0028\");\n\n\tstatus = ufx_reg_write(dev, 0x002C, 0x00000042);\n\tcheck_warn_return(status, \"error writing 0x002C\");\n\n\tstatus = ufx_reg_write(dev, 0x0030, 0x09520000);\n\tcheck_warn_return(status, \"error writing 0x0030\");\n\n\tstatus = ufx_reg_write(dev, 0x0034, 0x02223314);\n\tcheck_warn_return(status, \"error writing 0x0034\");\n\n\tstatus = ufx_reg_write(dev, 0x0038, 0x00430043);\n\tcheck_warn_return(status, \"error writing 0x0038\");\n\n\tstatus = ufx_reg_write(dev, 0x003C, 0xF00F000F);\n\tcheck_warn_return(status, \"error writing 0x003C\");\n\n\tstatus = ufx_reg_write(dev, 0x0040, 0xF380F00F);\n\tcheck_warn_return(status, \"error writing 0x0040\");\n\n\tstatus = ufx_reg_write(dev, 0x0044, 0xF00F0496);\n\tcheck_warn_return(status, \"error writing 0x0044\");\n\n\tstatus = ufx_reg_write(dev, 0x0048, 0x03080406);\n\tcheck_warn_return(status, \"error writing 0x0048\");\n\n\tstatus = ufx_reg_write(dev, 0x004C, 0x00001000);\n\tcheck_warn_return(status, \"error writing 0x004C\");\n\n\tstatus = ufx_reg_write(dev, 0x005C, 0x00000007);\n\tcheck_warn_return(status, \"error writing 0x005C\");\n\n\tstatus = ufx_reg_write(dev, 0x0100, 0x54F00012);\n\tcheck_warn_return(status, \"error writing 0x0100\");\n\n\tstatus = ufx_reg_write(dev, 0x0104, 0x00004012);\n\tcheck_warn_return(status, \"error writing 0x0104\");\n\n\tstatus = ufx_reg_write(dev, 0x0118, 0x40404040);\n\tcheck_warn_return(status, \"error writing 0x0118\");\n\n\tstatus = ufx_reg_write(dev, 0x0000, 0x00000001);\n\tcheck_warn_return(status, \"error writing 0x0000\");\n\n\twhile (i++ < 500) {\n\t\tstatus = ufx_reg_read(dev, 0x0000, &tmp);\n\t\tcheck_warn_return(status, \"error reading 0x0000\");\n\n\t\tif (all_bits_set(tmp, 0xC0000000))\n\t\t\treturn 0;\n\t}\n\n\tpr_err(\"DDR2 initialisation timed out, reg 0x0000=0x%08x\", tmp);\n\treturn -ETIMEDOUT;\n}\n\nstruct pll_values {\n\tu32 div_r0;\n\tu32 div_f0;\n\tu32 div_q0;\n\tu32 range0;\n\tu32 div_r1;\n\tu32 div_f1;\n\tu32 div_q1;\n\tu32 range1;\n};\n\nstatic u32 ufx_calc_range(u32 ref_freq)\n{\n\tif (ref_freq >= 88000000)\n\t\treturn 7;\n\n\tif (ref_freq >= 54000000)\n\t\treturn 6;\n\n\tif (ref_freq >= 34000000)\n\t\treturn 5;\n\n\tif (ref_freq >= 21000000)\n\t\treturn 4;\n\n\tif (ref_freq >= 13000000)\n\t\treturn 3;\n\n\tif (ref_freq >= 8000000)\n\t\treturn 2;\n\n\treturn 1;\n}\n\n \nstatic void ufx_calc_pll_values(const u32 clk_pixel_pll, struct pll_values *asic_pll)\n{\n\tconst u32 ref_clk = 25000000;\n\tu32 div_r0, div_f0, div_q0, div_r1, div_f1, div_q1;\n\tu32 min_error = clk_pixel_pll;\n\n\tfor (div_r0 = 1; div_r0 <= 32; div_r0++) {\n\t\tu32 ref_freq0 = ref_clk / div_r0;\n\t\tif (ref_freq0 < 5000000)\n\t\t\tbreak;\n\n\t\tif (ref_freq0 > 200000000)\n\t\t\tcontinue;\n\n\t\tfor (div_f0 = 1; div_f0 <= 256; div_f0++) {\n\t\t\tu32 vco_freq0 = ref_freq0 * div_f0;\n\n\t\t\tif (vco_freq0 < 350000000)\n\t\t\t\tcontinue;\n\n\t\t\tif (vco_freq0 > 700000000)\n\t\t\t\tbreak;\n\n\t\t\tfor (div_q0 = 0; div_q0 < 7; div_q0++) {\n\t\t\t\tu32 pllout_freq0 = vco_freq0 / (1 << div_q0);\n\n\t\t\t\tif (pllout_freq0 < 5000000)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (pllout_freq0 > 200000000)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (div_r1 = 1; div_r1 <= 32; div_r1++) {\n\t\t\t\t\tu32 ref_freq1 = pllout_freq0 / div_r1;\n\n\t\t\t\t\tif (ref_freq1 < 5000000)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tfor (div_f1 = 1; div_f1 <= 256; div_f1++) {\n\t\t\t\t\t\tu32 vco_freq1 = ref_freq1 * div_f1;\n\n\t\t\t\t\t\tif (vco_freq1 < 350000000)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif (vco_freq1 > 700000000)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tfor (div_q1 = 0; div_q1 < 7; div_q1++) {\n\t\t\t\t\t\t\tu32 pllout_freq1 = vco_freq1 / (1 << div_q1);\n\t\t\t\t\t\t\tint error = abs(pllout_freq1 - clk_pixel_pll);\n\n\t\t\t\t\t\t\tif (pllout_freq1 < 5000000)\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tif (pllout_freq1 > 700000000)\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\tif (error < min_error) {\n\t\t\t\t\t\t\t\tmin_error = error;\n\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tasic_pll->div_r0 = div_r0 - 1;\n\t\t\t\t\t\t\t\tasic_pll->div_f0 = div_f0 - 1;\n\t\t\t\t\t\t\t\tasic_pll->div_q0 = div_q0;\n\t\t\t\t\t\t\t\tasic_pll->div_r1 = div_r1 - 1;\n\t\t\t\t\t\t\t\tasic_pll->div_f1 = div_f1 - 1;\n\t\t\t\t\t\t\t\tasic_pll->div_q1 = div_q1;\n\n\t\t\t\t\t\t\t\tasic_pll->range0 = ufx_calc_range(ref_freq0);\n\t\t\t\t\t\t\t\tasic_pll->range1 = ufx_calc_range(ref_freq1);\n\n\t\t\t\t\t\t\t\tif (min_error == 0)\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int ufx_config_pix_clk(struct ufx_data *dev, u32 pixclock)\n{\n\tstruct pll_values asic_pll = {0};\n\tu32 value, clk_pixel, clk_pixel_pll;\n\tint status;\n\n\t \n\tclk_pixel = PICOS2KHZ(pixclock) * 1000;\n\tpr_debug(\"pixclock %d ps = clk_pixel %d Hz\", pixclock, clk_pixel);\n\n\t \n\tclk_pixel_pll = clk_pixel * 2;\n\n\tufx_calc_pll_values(clk_pixel_pll, &asic_pll);\n\n\t \n\tstatus = ufx_reg_write(dev, 0x7000, 0x8000000F);\n\tcheck_warn_return(status, \"error writing 0x7000\");\n\n\tvalue = (asic_pll.div_f1 | (asic_pll.div_r1 << 8) |\n\t\t(asic_pll.div_q1 << 16) | (asic_pll.range1 << 20));\n\tstatus = ufx_reg_write(dev, 0x7008, value);\n\tcheck_warn_return(status, \"error writing 0x7008\");\n\n\tvalue = (asic_pll.div_f0 | (asic_pll.div_r0 << 8) |\n\t\t(asic_pll.div_q0 << 16) | (asic_pll.range0 << 20));\n\tstatus = ufx_reg_write(dev, 0x7004, value);\n\tcheck_warn_return(status, \"error writing 0x7004\");\n\n\tstatus = ufx_reg_clear_bits(dev, 0x7000, 0x00000005);\n\tcheck_warn_return(status,\n\t\t\"error clearing PLL0 bypass bits in 0x7000\");\n\tmsleep(1);\n\n\tstatus = ufx_reg_clear_bits(dev, 0x7000, 0x0000000A);\n\tcheck_warn_return(status,\n\t\t\"error clearing PLL1 bypass bits in 0x7000\");\n\tmsleep(1);\n\n\tstatus = ufx_reg_clear_bits(dev, 0x7000, 0x80000000);\n\tcheck_warn_return(status, \"error clearing gate bits in 0x7000\");\n\n\treturn 0;\n}\n\nstatic int ufx_set_vid_mode(struct ufx_data *dev, struct fb_var_screeninfo *var)\n{\n\tu32 temp;\n\tu16 h_total, h_active, h_blank_start, h_blank_end, h_sync_start, h_sync_end;\n\tu16 v_total, v_active, v_blank_start, v_blank_end, v_sync_start, v_sync_end;\n\n\tint status = ufx_reg_write(dev, 0x8028, 0);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error disabling RGB pad\");\n\n\tstatus = ufx_reg_write(dev, 0x8024, 0);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error disabling VDAC\");\n\n\t \n\tstatus = ufx_blank(dev, true);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error blanking display\");\n\n\tstatus = ufx_disable(dev, true);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error disabling display\");\n\n\tstatus = ufx_config_pix_clk(dev, var->pixclock);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error configuring pixclock\");\n\n\tstatus = ufx_reg_write(dev, 0x2000, 0x00000104);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x2000\");\n\n\t \n\th_total = var->xres + var->right_margin + var->hsync_len + var->left_margin;\n\th_active = var->xres;\n\th_blank_start = var->xres + var->right_margin;\n\th_blank_end = var->xres + var->right_margin + var->hsync_len;\n\th_sync_start = var->xres + var->right_margin;\n\th_sync_end = var->xres + var->right_margin + var->hsync_len;\n\n\ttemp = ((h_total - 1) << 16) | (h_active - 1);\n\tstatus = ufx_reg_write(dev, 0x2008, temp);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x2008\");\n\n\ttemp = ((h_blank_start - 1) << 16) | (h_blank_end - 1);\n\tstatus = ufx_reg_write(dev, 0x200C, temp);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x200C\");\n\n\ttemp = ((h_sync_start - 1) << 16) | (h_sync_end - 1);\n\tstatus = ufx_reg_write(dev, 0x2010, temp);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x2010\");\n\n\t \n\tv_total = var->upper_margin + var->yres + var->lower_margin + var->vsync_len;\n\tv_active = var->yres;\n\tv_blank_start = var->yres + var->lower_margin;\n\tv_blank_end = var->yres + var->lower_margin + var->vsync_len;\n\tv_sync_start = var->yres + var->lower_margin;\n\tv_sync_end = var->yres + var->lower_margin + var->vsync_len;\n\n\ttemp = ((v_total - 1) << 16) | (v_active - 1);\n\tstatus = ufx_reg_write(dev, 0x2014, temp);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x2014\");\n\n\ttemp = ((v_blank_start - 1) << 16) | (v_blank_end - 1);\n\tstatus = ufx_reg_write(dev, 0x2018, temp);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x2018\");\n\n\ttemp = ((v_sync_start - 1) << 16) | (v_sync_end - 1);\n\tstatus = ufx_reg_write(dev, 0x201C, temp);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x201C\");\n\n\tstatus = ufx_reg_write(dev, 0x2020, 0x00000000);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x2020\");\n\n\tstatus = ufx_reg_write(dev, 0x2024, 0x00000000);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x2024\");\n\n\t \n\ttemp = var->xres * var->yres * 2;\n\ttemp = (temp + 7) & (~0x7);\n\tstatus = ufx_reg_write(dev, 0x2028, temp);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x2028\");\n\n\t \n\tstatus = ufx_reg_write(dev, 0x2040, 0);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x2040\");\n\n\tstatus = ufx_reg_write(dev, 0x2044, 0);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x2044\");\n\n\tstatus = ufx_reg_write(dev, 0x2048, 0);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x2048\");\n\n\t \n\ttemp = 0x00000001;\n\tif (var->sync & FB_SYNC_HOR_HIGH_ACT)\n\t\ttemp |= 0x00000010;\n\n\tif (var->sync & FB_SYNC_VERT_HIGH_ACT)\n\t\ttemp |= 0x00000008;\n\n\tstatus = ufx_reg_write(dev, 0x2040, temp);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error writing 0x2040\");\n\n\t \n\tstatus = ufx_enable(dev, true);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error enabling display\");\n\n\t \n\tstatus = ufx_unblank(dev, true);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error unblanking display\");\n\n\t \n\tstatus = ufx_reg_write(dev, 0x8028, 0x00000003);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error enabling RGB pad\");\n\n\t \n\tstatus = ufx_reg_write(dev, 0x8024, 0x00000007);\n\tcheck_warn_return(status, \"ufx_set_vid_mode error enabling VDAC\");\n\n\treturn 0;\n}\n\nstatic int ufx_ops_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tunsigned long start = vma->vm_start;\n\tunsigned long size = vma->vm_end - vma->vm_start;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\tunsigned long page, pos;\n\n\tif (info->fbdefio)\n\t\treturn fb_deferred_io_mmap(info, vma);\n\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\tif (size > info->fix.smem_len)\n\t\treturn -EINVAL;\n\tif (offset > info->fix.smem_len - size)\n\t\treturn -EINVAL;\n\n\tpos = (unsigned long)info->fix.smem_start + offset;\n\n\tpr_debug(\"mmap() framebuffer addr:%lu size:%lu\\n\",\n\t\t  pos, size);\n\n\twhile (size > 0) {\n\t\tpage = vmalloc_to_pfn((void *)pos);\n\t\tif (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED))\n\t\t\treturn -EAGAIN;\n\n\t\tstart += PAGE_SIZE;\n\t\tpos += PAGE_SIZE;\n\t\tif (size > PAGE_SIZE)\n\t\t\tsize -= PAGE_SIZE;\n\t\telse\n\t\t\tsize = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void ufx_raw_rect(struct ufx_data *dev, u16 *cmd, int x, int y,\n\tint width, int height)\n{\n\tsize_t packed_line_len = ALIGN((width * 2), 4);\n\tsize_t packed_rect_len = packed_line_len * height;\n\tint line;\n\n\tBUG_ON(!dev);\n\tBUG_ON(!dev->info);\n\n\t \n\t*((u32 *)&cmd[0]) = cpu_to_le32(0x01);\n\n\t \n\t*((u32 *)&cmd[2]) = cpu_to_le32(packed_rect_len + 16);\n\n\tcmd[4] = cpu_to_le16(x);\n\tcmd[5] = cpu_to_le16(y);\n\tcmd[6] = cpu_to_le16(width);\n\tcmd[7] = cpu_to_le16(height);\n\n\t \n\t*((u32 *)&cmd[8]) = cpu_to_le32(0);\n\n\t \n\tcmd[10] = cpu_to_le16(0x4000 | dev->info->var.xres);\n\n\t \n\tcmd[11] = cpu_to_le16(dev->info->var.yres);\n\n\t \n\tfor (line = 0; line < height; line++) {\n\t\tconst int line_offset = dev->info->fix.line_length * (y + line);\n\t\tconst int byte_offset = line_offset + (x * BPP);\n\t\tmemcpy(&cmd[(24 + (packed_line_len * line)) / 2],\n\t\t\t(char *)dev->info->fix.smem_start + byte_offset, width * BPP);\n\t}\n}\n\nstatic int ufx_handle_damage(struct ufx_data *dev, int x, int y,\n\tint width, int height)\n{\n\tsize_t packed_line_len = ALIGN((width * 2), 4);\n\tint len, status, urb_lines, start_line = 0;\n\n\tif ((width <= 0) || (height <= 0) ||\n\t    (x + width > dev->info->var.xres) ||\n\t    (y + height > dev->info->var.yres))\n\t\treturn -EINVAL;\n\n\tif (!atomic_read(&dev->usb_active))\n\t\treturn 0;\n\n\twhile (start_line < height) {\n\t\tstruct urb *urb = ufx_get_urb(dev);\n\t\tif (!urb) {\n\t\t\tpr_warn(\"ufx_handle_damage unable to get urb\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tBUG_ON(urb->transfer_buffer_length < (24 + (width * 2)));\n\n\t\t \n\t\turb_lines = (urb->transfer_buffer_length - 24) / packed_line_len;\n\n\t\t \n\t\turb_lines = min(urb_lines, (height - start_line));\n\n\t\tmemset(urb->transfer_buffer, 0, urb->transfer_buffer_length);\n\n\t\tufx_raw_rect(dev, urb->transfer_buffer, x, (y + start_line), width, urb_lines);\n\t\tlen = 24 + (packed_line_len * urb_lines);\n\n\t\tstatus = ufx_submit_urb(dev, urb, len);\n\t\tcheck_warn_return(status, \"Error submitting URB\");\n\n\t\tstart_line += urb_lines;\n\t}\n\n\treturn 0;\n}\n\n \nstatic ssize_t ufx_ops_write(struct fb_info *info, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tssize_t result;\n\tstruct ufx_data *dev = info->par;\n\tu32 offset = (u32) *ppos;\n\n\tresult = fb_sys_write(info, buf, count, ppos);\n\n\tif (result > 0) {\n\t\tint start = max((int)(offset / info->fix.line_length), 0);\n\t\tint lines = min((u32)((result / info->fix.line_length) + 1),\n\t\t\t\t(u32)info->var.yres);\n\n\t\tufx_handle_damage(dev, 0, start, info->var.xres, lines);\n\t}\n\n\treturn result;\n}\n\nstatic void ufx_ops_copyarea(struct fb_info *info,\n\t\t\t\tconst struct fb_copyarea *area)\n{\n\n\tstruct ufx_data *dev = info->par;\n\n\tsys_copyarea(info, area);\n\n\tufx_handle_damage(dev, area->dx, area->dy,\n\t\t\tarea->width, area->height);\n}\n\nstatic void ufx_ops_imageblit(struct fb_info *info,\n\t\t\t\tconst struct fb_image *image)\n{\n\tstruct ufx_data *dev = info->par;\n\n\tsys_imageblit(info, image);\n\n\tufx_handle_damage(dev, image->dx, image->dy,\n\t\t\timage->width, image->height);\n}\n\nstatic void ufx_ops_fillrect(struct fb_info *info,\n\t\t\t  const struct fb_fillrect *rect)\n{\n\tstruct ufx_data *dev = info->par;\n\n\tsys_fillrect(info, rect);\n\n\tufx_handle_damage(dev, rect->dx, rect->dy, rect->width,\n\t\t\t      rect->height);\n}\n\n \nstatic void ufx_dpy_deferred_io(struct fb_info *info, struct list_head *pagereflist)\n{\n\tstruct ufx_data *dev = info->par;\n\tstruct fb_deferred_io_pageref *pageref;\n\n\tif (!fb_defio)\n\t\treturn;\n\n\tif (!atomic_read(&dev->usb_active))\n\t\treturn;\n\n\t \n\tlist_for_each_entry(pageref, pagereflist, list) {\n\t\t \n\t\tconst int x = 0;\n\t\tconst int width = dev->info->var.xres;\n\t\tconst int y = pageref->offset / (width * 2);\n\t\tint height = (PAGE_SIZE / (width * 2)) + 1;\n\t\theight = min(height, (int)(dev->info->var.yres - y));\n\n\t\tBUG_ON(y >= dev->info->var.yres);\n\t\tBUG_ON((y + height) > dev->info->var.yres);\n\n\t\tufx_handle_damage(dev, x, y, width, height);\n\t}\n}\n\nstatic int ufx_ops_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tstruct ufx_data *dev = info->par;\n\tstruct dloarea *area = NULL;\n\n\tif (!atomic_read(&dev->usb_active))\n\t\treturn 0;\n\n\t \n\tif (cmd == UFX_IOCTL_RETURN_EDID) {\n\t\tu8 __user *edid = (u8 __user *)arg;\n\t\tif (copy_to_user(edid, dev->edid, dev->edid_size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\t \n\tif (cmd == UFX_IOCTL_REPORT_DAMAGE) {\n\t\t \n\t\tif (info->fbdefio)\n\t\t\tinfo->fbdefio->delay = UFX_DEFIO_WRITE_DISABLE;\n\n\t\tarea = (struct dloarea *)arg;\n\n\t\tif (area->x < 0)\n\t\t\tarea->x = 0;\n\n\t\tif (area->x > info->var.xres)\n\t\t\tarea->x = info->var.xres;\n\n\t\tif (area->y < 0)\n\t\t\tarea->y = 0;\n\n\t\tif (area->y > info->var.yres)\n\t\t\tarea->y = info->var.yres;\n\n\t\tufx_handle_damage(dev, area->x, area->y, area->w, area->h);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nufx_ops_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t       unsigned blue, unsigned transp, struct fb_info *info)\n{\n\tint err = 0;\n\n\tif (regno >= info->cmap.len)\n\t\treturn 1;\n\n\tif (regno < 16) {\n\t\tif (info->var.red.offset == 10) {\n\t\t\t \n\t\t\t((u32 *) (info->pseudo_palette))[regno] =\n\t\t\t    ((red & 0xf800) >> 1) |\n\t\t\t    ((green & 0xf800) >> 6) | ((blue & 0xf800) >> 11);\n\t\t} else {\n\t\t\t \n\t\t\t((u32 *) (info->pseudo_palette))[regno] =\n\t\t\t    ((red & 0xf800)) |\n\t\t\t    ((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic int ufx_ops_open(struct fb_info *info, int user)\n{\n\tstruct ufx_data *dev = info->par;\n\n\t \n\tif (user == 0 && !console)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&disconnect_mutex);\n\n\t \n\tif (dev->virtualized) {\n\t\tmutex_unlock(&disconnect_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tdev->fb_count++;\n\n\tkref_get(&dev->kref);\n\n\tif (fb_defio && (info->fbdefio == NULL)) {\n\t\t \n\n\t\tstruct fb_deferred_io *fbdefio;\n\n\t\tfbdefio = kzalloc(sizeof(*fbdefio), GFP_KERNEL);\n\t\tif (fbdefio) {\n\t\t\tfbdefio->delay = UFX_DEFIO_WRITE_DELAY;\n\t\t\tfbdefio->deferred_io = ufx_dpy_deferred_io;\n\t\t}\n\n\t\tinfo->fbdefio = fbdefio;\n\t\tfb_deferred_io_init(info);\n\t}\n\n\tpr_debug(\"open /dev/fb%d user=%d fb_info=%p count=%d\",\n\t\tinfo->node, user, info, dev->fb_count);\n\n\tmutex_unlock(&disconnect_mutex);\n\n\treturn 0;\n}\n\n \nstatic void ufx_free(struct kref *kref)\n{\n\tstruct ufx_data *dev = container_of(kref, struct ufx_data, kref);\n\n\tkfree(dev);\n}\n\nstatic void ufx_ops_destory(struct fb_info *info)\n{\n\tstruct ufx_data *dev = info->par;\n\tint node = info->node;\n\n\t \n\tframebuffer_release(info);\n\n\tpr_debug(\"fb_info for /dev/fb%d has been freed\", node);\n\n\t \n\tkref_put(&dev->kref, ufx_free);\n}\n\n\nstatic void ufx_release_urb_work(struct work_struct *work)\n{\n\tstruct urb_node *unode = container_of(work, struct urb_node,\n\t\t\t\t\t      release_urb_work.work);\n\n\tup(&unode->dev->urbs.limit_sem);\n}\n\nstatic void ufx_free_framebuffer(struct ufx_data *dev)\n{\n\tstruct fb_info *info = dev->info;\n\n\tif (info->cmap.len != 0)\n\t\tfb_dealloc_cmap(&info->cmap);\n\tif (info->monspecs.modedb)\n\t\tfb_destroy_modedb(info->monspecs.modedb);\n\tvfree(info->screen_buffer);\n\n\tfb_destroy_modelist(&info->modelist);\n\n\tdev->info = NULL;\n\n\t \n\tkref_put(&dev->kref, ufx_free);\n}\n\n \nstatic int ufx_ops_release(struct fb_info *info, int user)\n{\n\tstruct ufx_data *dev = info->par;\n\n\tmutex_lock(&disconnect_mutex);\n\n\tdev->fb_count--;\n\n\t \n\tif (dev->virtualized && (dev->fb_count == 0))\n\t\tufx_free_framebuffer(dev);\n\n\tif ((dev->fb_count == 0) && (info->fbdefio)) {\n\t\tfb_deferred_io_cleanup(info);\n\t\tkfree(info->fbdefio);\n\t\tinfo->fbdefio = NULL;\n\t}\n\n\tpr_debug(\"released /dev/fb%d user=%d count=%d\",\n\t\t  info->node, user, dev->fb_count);\n\n\tkref_put(&dev->kref, ufx_free);\n\n\tmutex_unlock(&disconnect_mutex);\n\n\treturn 0;\n}\n\n \nstatic int ufx_is_valid_mode(struct fb_videomode *mode,\n\t\tstruct fb_info *info)\n{\n\tif ((mode->xres * mode->yres) > (2048 * 1152)) {\n\t\tpr_debug(\"%dx%d too many pixels\",\n\t\t       mode->xres, mode->yres);\n\t\treturn 0;\n\t}\n\n\tif (mode->pixclock < 5000) {\n\t\tpr_debug(\"%dx%d %dps pixel clock too fast\",\n\t\t       mode->xres, mode->yres, mode->pixclock);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%dx%d (pixclk %dps %dMHz) valid mode\", mode->xres, mode->yres,\n\t\tmode->pixclock, (1000000 / mode->pixclock));\n\treturn 1;\n}\n\nstatic void ufx_var_color_format(struct fb_var_screeninfo *var)\n{\n\tconst struct fb_bitfield red = { 11, 5, 0 };\n\tconst struct fb_bitfield green = { 5, 6, 0 };\n\tconst struct fb_bitfield blue = { 0, 5, 0 };\n\n\tvar->bits_per_pixel = 16;\n\tvar->red = red;\n\tvar->green = green;\n\tvar->blue = blue;\n}\n\nstatic int ufx_ops_check_var(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info)\n{\n\tstruct fb_videomode mode;\n\n\t \n\tif ((var->xres * var->yres * 2) > info->fix.smem_len)\n\t\treturn -EINVAL;\n\n\t \n\tufx_var_color_format(var);\n\n\tfb_var_to_videomode(&mode, var);\n\n\tif (!ufx_is_valid_mode(&mode, info))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ufx_ops_set_par(struct fb_info *info)\n{\n\tstruct ufx_data *dev = info->par;\n\tint result;\n\tu16 *pix_framebuffer;\n\tint i;\n\n\tpr_debug(\"set_par mode %dx%d\", info->var.xres, info->var.yres);\n\tresult = ufx_set_vid_mode(dev, &info->var);\n\n\tif ((result == 0) && (dev->fb_count == 0)) {\n\t\t \n\t\tpix_framebuffer = (u16 *)info->screen_buffer;\n\t\tfor (i = 0; i < info->fix.smem_len / 2; i++)\n\t\t\tpix_framebuffer[i] = 0x37e6;\n\n\t\tufx_handle_damage(dev, 0, 0, info->var.xres, info->var.yres);\n\t}\n\n\t \n\tif (info->fbdefio)\n\t\tinfo->fbdefio->delay = UFX_DEFIO_WRITE_DELAY;\n\n\treturn result;\n}\n\n \nstatic int ufx_ops_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct ufx_data *dev = info->par;\n\tufx_set_vid_mode(dev, &info->var);\n\treturn 0;\n}\n\nstatic const struct fb_ops ufx_ops = {\n\t.owner = THIS_MODULE,\n\t.fb_read = fb_sys_read,\n\t.fb_write = ufx_ops_write,\n\t.fb_setcolreg = ufx_ops_setcolreg,\n\t.fb_fillrect = ufx_ops_fillrect,\n\t.fb_copyarea = ufx_ops_copyarea,\n\t.fb_imageblit = ufx_ops_imageblit,\n\t.fb_mmap = ufx_ops_mmap,\n\t.fb_ioctl = ufx_ops_ioctl,\n\t.fb_open = ufx_ops_open,\n\t.fb_release = ufx_ops_release,\n\t.fb_blank = ufx_ops_blank,\n\t.fb_check_var = ufx_ops_check_var,\n\t.fb_set_par = ufx_ops_set_par,\n\t.fb_destroy = ufx_ops_destory,\n};\n\n \nstatic int ufx_realloc_framebuffer(struct ufx_data *dev, struct fb_info *info)\n{\n\tint old_len = info->fix.smem_len;\n\tint new_len;\n\tunsigned char *old_fb = info->screen_buffer;\n\tunsigned char *new_fb;\n\n\tpr_debug(\"Reallocating framebuffer. Addresses will change!\");\n\n\tnew_len = info->fix.line_length * info->var.yres;\n\n\tif (PAGE_ALIGN(new_len) > old_len) {\n\t\t \n\t\tnew_fb = vmalloc(new_len);\n\t\tif (!new_fb)\n\t\t\treturn -ENOMEM;\n\n\t\tif (info->screen_buffer) {\n\t\t\tmemcpy(new_fb, old_fb, old_len);\n\t\t\tvfree(info->screen_buffer);\n\t\t}\n\n\t\tinfo->screen_buffer = new_fb;\n\t\tinfo->fix.smem_len = PAGE_ALIGN(new_len);\n\t\tinfo->fix.smem_start = (unsigned long) new_fb;\n\t\tinfo->flags = smscufx_info_flags;\n\t}\n\treturn 0;\n}\n\n \nstatic int ufx_i2c_init(struct ufx_data *dev)\n{\n\tu32 tmp;\n\n\t \n\tint status = ufx_reg_write(dev, 0x106C, 0x00);\n\tcheck_warn_return(status, \"failed to disable I2C\");\n\n\t \n\tstatus = ufx_reg_write(dev, 0x1018, 12);\n\tcheck_warn_return(status, \"error writing 0x1018\");\n\n\t \n\tstatus = ufx_reg_write(dev, 0x1014, 6);\n\tcheck_warn_return(status, \"error writing 0x1014\");\n\n\tstatus = ufx_reg_read(dev, 0x1000, &tmp);\n\tcheck_warn_return(status, \"error reading 0x1000\");\n\n\t \n\ttmp &= ~(0x06);\n\ttmp |= 0x02;\n\n\t \n\ttmp &= ~(0x10);\n\n\t \n\ttmp |= 0x21;\n\n\tstatus = ufx_reg_write(dev, 0x1000, tmp);\n\tcheck_warn_return(status, \"error writing 0x1000\");\n\n\t \n\tstatus = ufx_reg_clear_and_set_bits(dev, 0x1004, 0xC00, 0x000);\n\tcheck_warn_return(status, \"error setting TX mode bits in 0x1004\");\n\n\t \n\tstatus = ufx_reg_write(dev, 0x106C, 0x01);\n\tcheck_warn_return(status, \"failed to enable I2C\");\n\n\treturn 0;\n}\n\n \nstatic int ufx_i2c_configure(struct ufx_data *dev)\n{\n\tint status = ufx_reg_write(dev, 0x106C, 0x00);\n\tcheck_warn_return(status, \"failed to disable I2C\");\n\n\tstatus = ufx_reg_write(dev, 0x3010, 0x00000000);\n\tcheck_warn_return(status, \"failed to write 0x3010\");\n\n\t \n\tstatus = ufx_reg_clear_and_set_bits(dev, 0x1004, 0x3FF,\t(0xA0 >> 1));\n\tcheck_warn_return(status, \"failed to set TAR bits in 0x1004\");\n\n\tstatus = ufx_reg_write(dev, 0x106C, 0x01);\n\tcheck_warn_return(status, \"failed to enable I2C\");\n\n\treturn 0;\n}\n\n \nstatic int ufx_i2c_wait_busy(struct ufx_data *dev)\n{\n\tu32 tmp;\n\tint i, status;\n\n\tfor (i = 0; i < 15; i++) {\n\t\tstatus = ufx_reg_read(dev, 0x1100, &tmp);\n\t\tcheck_warn_return(status, \"0x1100 read failed\");\n\n\t\t \n\t\tif ((tmp & 0x80000000) == 0) {\n\t\t\tif (tmp & 0x20000000) {\n\t\t\t\tpr_warn(\"I2C read failed, 0x1100=0x%08x\", tmp);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (i >= 10)\n\t\t\tmsleep(10);\n\t}\n\n\tpr_warn(\"I2C access timed out, resetting I2C hardware\");\n\tstatus =  ufx_reg_write(dev, 0x1100, 0x40000000);\n\tcheck_warn_return(status, \"0x1100 write failed\");\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int ufx_read_edid(struct ufx_data *dev, u8 *edid, int edid_len)\n{\n\tint i, j, status;\n\tu32 *edid_u32 = (u32 *)edid;\n\n\tBUG_ON(edid_len != EDID_LENGTH);\n\n\tstatus = ufx_i2c_configure(dev);\n\tif (status < 0) {\n\t\tpr_err(\"ufx_i2c_configure failed\");\n\t\treturn status;\n\t}\n\n\tmemset(edid, 0xff, EDID_LENGTH);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tu32 temp = 0x28070000 | (63 << 20) | (((u32)(i * 64)) << 8);\n\t\tstatus = ufx_reg_write(dev, 0x1100, temp);\n\t\tcheck_warn_return(status, \"Failed to write 0x1100\");\n\n\t\ttemp |= 0x80000000;\n\t\tstatus = ufx_reg_write(dev, 0x1100, temp);\n\t\tcheck_warn_return(status, \"Failed to write 0x1100\");\n\n\t\tstatus = ufx_i2c_wait_busy(dev);\n\t\tcheck_warn_return(status, \"Timeout waiting for I2C BUSY to clear\");\n\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tu32 data_reg_addr = 0x1110 + (j * 4);\n\t\t\tstatus = ufx_reg_read(dev, data_reg_addr, edid_u32++);\n\t\t\tcheck_warn_return(status, \"Error reading i2c data\");\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tif (edid[i] != 0xFF) {\n\t\t\tpr_debug(\"edid data read successfully\");\n\t\t\treturn EDID_LENGTH;\n\t\t}\n\t}\n\n\tpr_warn(\"edid data contains all 0xff\");\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int ufx_setup_modes(struct ufx_data *dev, struct fb_info *info,\n\tchar *default_edid, size_t default_edid_size)\n{\n\tconst struct fb_videomode *default_vmode = NULL;\n\tu8 *edid;\n\tint i, result = 0, tries = 3;\n\n\tif (refcount_read(&info->count))  \n\t\tmutex_lock(&info->lock);\n\n\tedid = kmalloc(EDID_LENGTH, GFP_KERNEL);\n\tif (!edid) {\n\t\tresult = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tfb_destroy_modelist(&info->modelist);\n\tmemset(&info->monspecs, 0, sizeof(info->monspecs));\n\n\t \n\twhile (tries--) {\n\t\ti = ufx_read_edid(dev, edid, EDID_LENGTH);\n\n\t\tif (i >= EDID_LENGTH)\n\t\t\tfb_edid_to_monspecs(edid, &info->monspecs);\n\n\t\tif (info->monspecs.modedb_len > 0) {\n\t\t\tdev->edid = edid;\n\t\t\tdev->edid_size = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (info->monspecs.modedb_len == 0) {\n\t\tpr_err(\"Unable to get valid EDID from device/display\\n\");\n\n\t\tif (dev->edid) {\n\t\t\tfb_edid_to_monspecs(dev->edid, &info->monspecs);\n\t\t\tif (info->monspecs.modedb_len > 0)\n\t\t\t\tpr_err(\"Using previously queried EDID\\n\");\n\t\t}\n\t}\n\n\t \n\tif (info->monspecs.modedb_len == 0) {\n\t\tif (default_edid_size >= EDID_LENGTH) {\n\t\t\tfb_edid_to_monspecs(default_edid, &info->monspecs);\n\t\t\tif (info->monspecs.modedb_len > 0) {\n\t\t\t\tmemcpy(edid, default_edid, default_edid_size);\n\t\t\t\tdev->edid = edid;\n\t\t\t\tdev->edid_size = default_edid_size;\n\t\t\t\tpr_err(\"Using default/backup EDID\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (info->monspecs.modedb_len > 0) {\n\n\t\tfor (i = 0; i < info->monspecs.modedb_len; i++) {\n\t\t\tif (ufx_is_valid_mode(&info->monspecs.modedb[i], info))\n\t\t\t\tfb_add_videomode(&info->monspecs.modedb[i],\n\t\t\t\t\t&info->modelist);\n\t\t\telse  \n\t\t\t\tinfo->monspecs.misc &= ~FB_MISC_1ST_DETAIL;\n\t\t}\n\n\t\tdefault_vmode = fb_find_best_display(&info->monspecs,\n\t\t\t\t\t\t     &info->modelist);\n\t}\n\n\t \n\tif (default_vmode == NULL) {\n\n\t\tstruct fb_videomode fb_vmode = {0};\n\n\t\t \n\t\tfor (i = 0; i < VESA_MODEDB_SIZE; i++) {\n\t\t\tif (ufx_is_valid_mode((struct fb_videomode *)\n\t\t\t\t\t\t&vesa_modes[i], info))\n\t\t\t\tfb_add_videomode(&vesa_modes[i],\n\t\t\t\t\t\t &info->modelist);\n\t\t}\n\n\t\t \n\t\tfb_vmode.xres = 800;\n\t\tfb_vmode.yres = 600;\n\t\tfb_vmode.refresh = 60;\n\t\tdefault_vmode = fb_find_nearest_mode(&fb_vmode,\n\t\t\t\t\t\t     &info->modelist);\n\t}\n\n\t \n\tif ((default_vmode != NULL) && (dev->fb_count == 0)) {\n\n\t\tfb_videomode_to_var(&info->var, default_vmode);\n\t\tufx_var_color_format(&info->var);\n\n\t\t \n\t\tmemcpy(&info->fix, &ufx_fix, sizeof(ufx_fix));\n\t\tinfo->fix.line_length = info->var.xres *\n\t\t\t(info->var.bits_per_pixel / 8);\n\n\t\tresult = ufx_realloc_framebuffer(dev, info);\n\n\t} else\n\t\tresult = -EINVAL;\n\nerror:\n\tif (edid && (dev->edid != edid))\n\t\tkfree(edid);\n\n\tif (refcount_read(&info->count))\n\t\tmutex_unlock(&info->lock);\n\n\treturn result;\n}\n\nstatic int ufx_usb_probe(struct usb_interface *interface,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *usbdev;\n\tstruct ufx_data *dev;\n\tstruct fb_info *info;\n\tint retval = -ENOMEM;\n\tu32 id_rev, fpga_rev;\n\n\t \n\tusbdev = interface_to_usbdev(interface);\n\tBUG_ON(!usbdev);\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tdev_err(&usbdev->dev, \"ufx_usb_probe: failed alloc of dev struct\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tkref_init(&dev->kref);  \n\tkref_get(&dev->kref);  \n\n\tdev->udev = usbdev;\n\tdev->gdev = &usbdev->dev;  \n\tusb_set_intfdata(interface, dev);\n\n\tdev_dbg(dev->gdev, \"%s %s - serial #%s\\n\",\n\t\tusbdev->manufacturer, usbdev->product, usbdev->serial);\n\tdev_dbg(dev->gdev, \"vid_%04x&pid_%04x&rev_%04x driver's ufx_data struct at %p\\n\",\n\t\tle16_to_cpu(usbdev->descriptor.idVendor),\n\t\tle16_to_cpu(usbdev->descriptor.idProduct),\n\t\tle16_to_cpu(usbdev->descriptor.bcdDevice), dev);\n\tdev_dbg(dev->gdev, \"console enable=%d\\n\", console);\n\tdev_dbg(dev->gdev, \"fb_defio enable=%d\\n\", fb_defio);\n\n\tif (!ufx_alloc_urb_list(dev, WRITES_IN_FLIGHT, MAX_TRANSFER)) {\n\t\tdev_err(dev->gdev, \"ufx_alloc_urb_list failed\\n\");\n\t\tgoto put_ref;\n\t}\n\n\t \n\n\t \n\tinfo = framebuffer_alloc(0, &usbdev->dev);\n\tif (!info) {\n\t\tdev_err(dev->gdev, \"framebuffer_alloc failed\\n\");\n\t\tgoto free_urb_list;\n\t}\n\n\tdev->info = info;\n\tinfo->par = dev;\n\tinfo->pseudo_palette = dev->pseudo_palette;\n\tinfo->fbops = &ufx_ops;\n\tINIT_LIST_HEAD(&info->modelist);\n\n\tretval = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (retval < 0) {\n\t\tdev_err(dev->gdev, \"fb_alloc_cmap failed %x\\n\", retval);\n\t\tgoto destroy_modedb;\n\t}\n\n\tretval = ufx_reg_read(dev, 0x3000, &id_rev);\n\tcheck_warn_goto_error(retval, \"error %d reading 0x3000 register from device\", retval);\n\tdev_dbg(dev->gdev, \"ID_REV register value 0x%08x\", id_rev);\n\n\tretval = ufx_reg_read(dev, 0x3004, &fpga_rev);\n\tcheck_warn_goto_error(retval, \"error %d reading 0x3004 register from device\", retval);\n\tdev_dbg(dev->gdev, \"FPGA_REV register value 0x%08x\", fpga_rev);\n\n\tdev_dbg(dev->gdev, \"resetting device\");\n\tretval = ufx_lite_reset(dev);\n\tcheck_warn_goto_error(retval, \"error %d resetting device\", retval);\n\n\tdev_dbg(dev->gdev, \"configuring system clock\");\n\tretval = ufx_config_sys_clk(dev);\n\tcheck_warn_goto_error(retval, \"error %d configuring system clock\", retval);\n\n\tdev_dbg(dev->gdev, \"configuring DDR2 controller\");\n\tretval = ufx_config_ddr2(dev);\n\tcheck_warn_goto_error(retval, \"error %d initialising DDR2 controller\", retval);\n\n\tdev_dbg(dev->gdev, \"configuring I2C controller\");\n\tretval = ufx_i2c_init(dev);\n\tcheck_warn_goto_error(retval, \"error %d initialising I2C controller\", retval);\n\n\tdev_dbg(dev->gdev, \"selecting display mode\");\n\tretval = ufx_setup_modes(dev, info, NULL, 0);\n\tcheck_warn_goto_error(retval, \"unable to find common mode for display and adapter\");\n\n\tretval = ufx_reg_set_bits(dev, 0x4000, 0x00000001);\n\tif (retval < 0) {\n\t\tdev_err(dev->gdev, \"error %d enabling graphics engine\", retval);\n\t\tgoto setup_modes;\n\t}\n\n\t \n\tatomic_set(&dev->usb_active, 1);\n\n\tdev_dbg(dev->gdev, \"checking var\");\n\tretval = ufx_ops_check_var(&info->var, info);\n\tif (retval < 0) {\n\t\tdev_err(dev->gdev, \"error %d ufx_ops_check_var\", retval);\n\t\tgoto reset_active;\n\t}\n\n\tdev_dbg(dev->gdev, \"setting par\");\n\tretval = ufx_ops_set_par(info);\n\tif (retval < 0) {\n\t\tdev_err(dev->gdev, \"error %d ufx_ops_set_par\", retval);\n\t\tgoto reset_active;\n\t}\n\n\tdev_dbg(dev->gdev, \"registering framebuffer\");\n\tretval = register_framebuffer(info);\n\tif (retval < 0) {\n\t\tdev_err(dev->gdev, \"error %d register_framebuffer\", retval);\n\t\tgoto reset_active;\n\t}\n\n\tdev_info(dev->gdev, \"SMSC UDX USB device /dev/fb%d attached. %dx%d resolution.\"\n\t\t\" Using %dK framebuffer memory\\n\", info->node,\n\t\tinfo->var.xres, info->var.yres, info->fix.smem_len >> 10);\n\n\treturn 0;\n\nreset_active:\n\tatomic_set(&dev->usb_active, 0);\nsetup_modes:\n\tfb_destroy_modedb(info->monspecs.modedb);\n\tvfree(info->screen_buffer);\n\tfb_destroy_modelist(&info->modelist);\nerror:\n\tfb_dealloc_cmap(&info->cmap);\ndestroy_modedb:\n\tframebuffer_release(info);\nfree_urb_list:\n\tif (dev->urbs.count > 0)\n\t\tufx_free_urb_list(dev);\nput_ref:\n\tkref_put(&dev->kref, ufx_free);  \n\tkref_put(&dev->kref, ufx_free);  \n\treturn retval;\n}\n\nstatic void ufx_usb_disconnect(struct usb_interface *interface)\n{\n\tstruct ufx_data *dev;\n\tstruct fb_info *info;\n\n\tmutex_lock(&disconnect_mutex);\n\n\tdev = usb_get_intfdata(interface);\n\tinfo = dev->info;\n\n\tpr_debug(\"USB disconnect starting\\n\");\n\n\t \n\tdev->virtualized = true;\n\n\t \n\tatomic_set(&dev->usb_active, 0);\n\n\tusb_set_intfdata(interface, NULL);\n\n\t \n\tif (dev->fb_count == 0)\n\t\tufx_free_framebuffer(dev);\n\n\t \n\tif (dev->urbs.count > 0)\n\t\tufx_free_urb_list(dev);\n\n\tpr_debug(\"freeing ufx_data %p\", dev);\n\n\tunregister_framebuffer(info);\n\n\tmutex_unlock(&disconnect_mutex);\n}\n\nstatic struct usb_driver ufx_driver = {\n\t.name = \"smscufx\",\n\t.probe = ufx_usb_probe,\n\t.disconnect = ufx_usb_disconnect,\n\t.id_table = id_table,\n};\n\nmodule_usb_driver(ufx_driver);\n\nstatic void ufx_urb_completion(struct urb *urb)\n{\n\tstruct urb_node *unode = urb->context;\n\tstruct ufx_data *dev = unode->dev;\n\tunsigned long flags;\n\n\t \n\tif (urb->status) {\n\t\tif (!(urb->status == -ENOENT ||\n\t\t    urb->status == -ECONNRESET ||\n\t\t    urb->status == -ESHUTDOWN)) {\n\t\t\tpr_err(\"%s - nonzero write bulk status received: %d\\n\",\n\t\t\t\t__func__, urb->status);\n\t\t\tatomic_set(&dev->lost_pixels, 1);\n\t\t}\n\t}\n\n\turb->transfer_buffer_length = dev->urbs.size;  \n\n\tspin_lock_irqsave(&dev->urbs.lock, flags);\n\tlist_add_tail(&unode->entry, &dev->urbs.list);\n\tdev->urbs.available++;\n\tspin_unlock_irqrestore(&dev->urbs.lock, flags);\n\n\t \n\tif (fb_defio)\n\t\tschedule_delayed_work(&unode->release_urb_work, 0);\n\telse\n\t\tup(&dev->urbs.limit_sem);\n}\n\nstatic void ufx_free_urb_list(struct ufx_data *dev)\n{\n\tint count = dev->urbs.count;\n\tstruct list_head *node;\n\tstruct urb_node *unode;\n\tstruct urb *urb;\n\tint ret;\n\tunsigned long flags;\n\n\tpr_debug(\"Waiting for completes and freeing all render urbs\\n\");\n\n\t \n\twhile (count--) {\n\t\t \n\t\tret = down_interruptible(&dev->urbs.limit_sem);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tspin_lock_irqsave(&dev->urbs.lock, flags);\n\n\t\tnode = dev->urbs.list.next;  \n\t\tlist_del_init(node);\n\n\t\tspin_unlock_irqrestore(&dev->urbs.lock, flags);\n\n\t\tunode = list_entry(node, struct urb_node, entry);\n\t\turb = unode->urb;\n\n\t\t \n\t\tusb_free_coherent(urb->dev, dev->urbs.size,\n\t\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t\tkfree(node);\n\t}\n}\n\nstatic int ufx_alloc_urb_list(struct ufx_data *dev, int count, size_t size)\n{\n\tint i = 0;\n\tstruct urb *urb;\n\tstruct urb_node *unode;\n\tchar *buf;\n\n\tspin_lock_init(&dev->urbs.lock);\n\n\tdev->urbs.size = size;\n\tINIT_LIST_HEAD(&dev->urbs.list);\n\n\twhile (i < count) {\n\t\tunode = kzalloc(sizeof(*unode), GFP_KERNEL);\n\t\tif (!unode)\n\t\t\tbreak;\n\t\tunode->dev = dev;\n\n\t\tINIT_DELAYED_WORK(&unode->release_urb_work,\n\t\t\t  ufx_release_urb_work);\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tkfree(unode);\n\t\t\tbreak;\n\t\t}\n\t\tunode->urb = urb;\n\n\t\tbuf = usb_alloc_coherent(dev->udev, size, GFP_KERNEL,\n\t\t\t\t\t &urb->transfer_dma);\n\t\tif (!buf) {\n\t\t\tkfree(unode);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 1),\n\t\t\tbuf, size, ufx_urb_completion, unode);\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\tlist_add_tail(&unode->entry, &dev->urbs.list);\n\n\t\ti++;\n\t}\n\n\tsema_init(&dev->urbs.limit_sem, i);\n\tdev->urbs.count = i;\n\tdev->urbs.available = i;\n\n\tpr_debug(\"allocated %d %d byte urbs\\n\", i, (int) size);\n\n\treturn i;\n}\n\nstatic struct urb *ufx_get_urb(struct ufx_data *dev)\n{\n\tint ret = 0;\n\tstruct list_head *entry;\n\tstruct urb_node *unode;\n\tstruct urb *urb = NULL;\n\tunsigned long flags;\n\n\t \n\tret = down_timeout(&dev->urbs.limit_sem, GET_URB_TIMEOUT);\n\tif (ret) {\n\t\tatomic_set(&dev->lost_pixels, 1);\n\t\tpr_warn(\"wait for urb interrupted: %x available: %d\\n\",\n\t\t       ret, dev->urbs.available);\n\t\tgoto error;\n\t}\n\n\tspin_lock_irqsave(&dev->urbs.lock, flags);\n\n\tBUG_ON(list_empty(&dev->urbs.list));  \n\tentry = dev->urbs.list.next;\n\tlist_del_init(entry);\n\tdev->urbs.available--;\n\n\tspin_unlock_irqrestore(&dev->urbs.lock, flags);\n\n\tunode = list_entry(entry, struct urb_node, entry);\n\turb = unode->urb;\n\nerror:\n\treturn urb;\n}\n\nstatic int ufx_submit_urb(struct ufx_data *dev, struct urb *urb, size_t len)\n{\n\tint ret;\n\n\tBUG_ON(len > dev->urbs.size);\n\n\turb->transfer_buffer_length = len;  \n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tufx_urb_completion(urb);  \n\t\tatomic_set(&dev->lost_pixels, 1);\n\t\tpr_err(\"usb_submit_urb error %x\\n\", ret);\n\t}\n\treturn ret;\n}\n\nmodule_param(console, bool, S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP);\nMODULE_PARM_DESC(console, \"Allow fbcon to be used on this display\");\n\nmodule_param(fb_defio, bool, S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP);\nMODULE_PARM_DESC(fb_defio, \"Enable fb_defio mmap support\");\n\nMODULE_AUTHOR(\"Steve Glendinning <steve.glendinning@shawell.net>\");\nMODULE_DESCRIPTION(\"SMSC UFX kernel framebuffer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}