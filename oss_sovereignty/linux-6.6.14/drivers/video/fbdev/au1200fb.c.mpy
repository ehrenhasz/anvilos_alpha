{
  "module_name": "au1200fb.c",
  "hash_id": "70a78ca95f1f916f0ccc46e6721ab835fe0306911ecf172e4c0a899f9a64e949",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/au1200fb.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ctype.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <asm/mach-au1x00/au1000.h>\n#include <asm/mach-au1x00/au1200fb.h>\t \n#include \"au1200fb.h\"\n\n#define DRIVER_NAME \"au1200fb\"\n#define DRIVER_DESC \"LCD controller driver for AU1200 processors\"\n\n#define DEBUG 0\n\n#define print_err(f, arg...) printk(KERN_ERR DRIVER_NAME \": \" f \"\\n\", ## arg)\n#define print_warn(f, arg...) printk(KERN_WARNING DRIVER_NAME \": \" f \"\\n\", ## arg)\n#define print_info(f, arg...) printk(KERN_INFO DRIVER_NAME \": \" f \"\\n\", ## arg)\n\n#if DEBUG\n#define print_dbg(f, arg...) printk(KERN_DEBUG __FILE__ \": \" f \"\\n\", ## arg)\n#else\n#define print_dbg(f, arg...) do {} while (0)\n#endif\n\n\n#define AU1200_LCD_FB_IOCTL 0x46FF\n\n#define AU1200_LCD_SET_SCREEN 1\n#define AU1200_LCD_GET_SCREEN 2\n#define AU1200_LCD_SET_WINDOW 3\n#define AU1200_LCD_GET_WINDOW 4\n#define AU1200_LCD_SET_PANEL  5\n#define AU1200_LCD_GET_PANEL  6\n\n#define SCREEN_SIZE\t\t    (1<< 1)\n#define SCREEN_BACKCOLOR    (1<< 2)\n#define SCREEN_BRIGHTNESS   (1<< 3)\n#define SCREEN_COLORKEY     (1<< 4)\n#define SCREEN_MASK         (1<< 5)\n\nstruct au1200_lcd_global_regs_t {\n\tunsigned int flags;\n\tunsigned int xsize;\n\tunsigned int ysize;\n\tunsigned int backcolor;\n\tunsigned int brightness;\n\tunsigned int colorkey;\n\tunsigned int mask;\n\tunsigned int panel_choice;\n\tchar panel_desc[80];\n\n};\n\n#define WIN_POSITION            (1<< 0)\n#define WIN_ALPHA_COLOR         (1<< 1)\n#define WIN_ALPHA_MODE          (1<< 2)\n#define WIN_PRIORITY            (1<< 3)\n#define WIN_CHANNEL             (1<< 4)\n#define WIN_BUFFER_FORMAT       (1<< 5)\n#define WIN_COLOR_ORDER         (1<< 6)\n#define WIN_PIXEL_ORDER         (1<< 7)\n#define WIN_SIZE                (1<< 8)\n#define WIN_COLORKEY_MODE       (1<< 9)\n#define WIN_DOUBLE_BUFFER_MODE  (1<< 10)\n#define WIN_RAM_ARRAY_MODE      (1<< 11)\n#define WIN_BUFFER_SCALE        (1<< 12)\n#define WIN_ENABLE\t            (1<< 13)\n\nstruct au1200_lcd_window_regs_t {\n\tunsigned int flags;\n\tunsigned int xpos;\n\tunsigned int ypos;\n\tunsigned int alpha_color;\n\tunsigned int alpha_mode;\n\tunsigned int priority;\n\tunsigned int channel;\n\tunsigned int buffer_format;\n\tunsigned int color_order;\n\tunsigned int pixel_order;\n\tunsigned int xsize;\n\tunsigned int ysize;\n\tunsigned int colorkey_mode;\n\tunsigned int double_buffer_mode;\n\tunsigned int ram_array_mode;\n\tunsigned int xscale;\n\tunsigned int yscale;\n\tunsigned int enable;\n};\n\n\nstruct au1200_lcd_iodata_t {\n\tunsigned int subcmd;\n\tstruct au1200_lcd_global_regs_t global;\n\tstruct au1200_lcd_window_regs_t window;\n};\n\n#if defined(__BIG_ENDIAN)\n#define LCD_CONTROL_DEFAULT_PO LCD_CONTROL_PO_11\n#else\n#define LCD_CONTROL_DEFAULT_PO LCD_CONTROL_PO_00\n#endif\n#define LCD_CONTROL_DEFAULT_SBPPF LCD_CONTROL_SBPPF_565\n\n \nstruct au1200fb_device {\n\tstruct fb_info *fb_info;\t\t \n\tstruct au1200fb_platdata *pd;\n\tstruct device *dev;\n\n\tint\t\t\t\t\tplane;\n\tunsigned char* \t\tfb_mem;\t\t \n\tunsigned int\t\tfb_len;\n\tdma_addr_t    \t\tfb_phys;\n};\n\n \n\n \n#define AU1200_LCD_MAX_XRES\t1280\n#define AU1200_LCD_MAX_YRES\t1024\n#define AU1200_LCD_MAX_BPP\t32\n#define AU1200_LCD_MAX_CLK\t96000000  \n#define AU1200_LCD_NBR_PALETTE_ENTRIES 256\n\n \n#define AU1200FB_NBR_VIDEO_BUFFERS 1\n\n \n#define MAX_DEVICE_COUNT\t4\n\n \n#define DEFAULT_WINDOW_INDEX\t2\n\n \n\nstatic struct fb_info *_au1200fb_infos[MAX_DEVICE_COUNT];\nstatic struct au1200_lcd *lcd = (struct au1200_lcd *) AU1200_LCD_ADDR;\nstatic int device_count = MAX_DEVICE_COUNT;\nstatic int window_index = DEFAULT_WINDOW_INDEX;\t \nstatic int panel_index = 2;  \nstatic struct window_settings *win;\nstatic struct panel_settings *panel;\nstatic int noblanking = 1;\nstatic int nohwcursor = 0;\n\nstruct window_settings {\n\tunsigned char name[64];\n\tuint32 mode_backcolor;\n\tuint32 mode_colorkey;\n\tuint32 mode_colorkeymsk;\n\tstruct {\n\t\tint xres;\n\t\tint yres;\n\t\tint xpos;\n\t\tint ypos;\n\t\tuint32 mode_winctrl1;  \n\t\tuint32 mode_winenable;\n\t} w[4];\n};\n\n#if defined(__BIG_ENDIAN)\n#define LCD_WINCTRL1_PO_16BPP LCD_WINCTRL1_PO_00\n#else\n#define LCD_WINCTRL1_PO_16BPP LCD_WINCTRL1_PO_01\n#endif\n\n \nstatic struct window_settings windows[] = {\n\t{  \n\t\t\"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx\",\n\t\t  0x006600ff,\n\t\t  0, 0,\n\t\t{\n\t\t\t{\n\t\t\t  0, 0, 0, 0,\n\t\t\t  LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP,\n\t\t\t  LCD_WINENABLE_WEN0,\n\t\t\t},\n\t\t\t{\n\t\t\t  100, 100, 100, 100,\n\t\t\t  LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t  LCD_WINENABLE_WEN1,\n\t\t\t},\n\t\t\t{\n\t\t\t  0, 0, 0, 0,\n\t\t\t  LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP,\n\t\t\t  0,\n\t\t\t},\n\t\t\t{\n\t\t\t  0, 0, 0, 0,\n\t\t\t  LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t  0,\n\t\t\t},\n\t\t},\n\t},\n\n\t{  \n\t\t\"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx\",\n\t\t  0x006600ff,\n\t\t  0, 0,\n\t\t{\n\t\t\t{\n\t\t\t  320, 240, 5, 5,\n\t\t\t  LCD_WINCTRL1_FRM_24BPP |\n\t\t\t\tLCD_WINCTRL1_PO_00,\n\t\t\t  LCD_WINENABLE_WEN0,\n\t\t\t},\n\t\t\t{\n\t\t\t  0, 0, 0, 0,\n\t\t\t  LCD_WINCTRL1_FRM_16BPP565\n\t\t\t\t| LCD_WINCTRL1_PO_16BPP,\n\t\t\t  0,\n\t\t\t},\n\t\t\t{\n\t\t\t  100, 100, 0, 0,\n\t\t\t  LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t  0 ,\n\t\t\t},\n\t\t\t{\n\t\t\t  200, 25, 0, 0,\n\t\t\t  LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t  0,\n\t\t\t},\n\t\t},\n\t},\n\t{  \n\t\t\"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx\",\n\t\t  0x006600ff,\n\t\t  0, 0,\n\t\t{\n\t\t\t{\n\t\t\t  0, 0, 0, 0,\n\t\t\t  LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP,\n\t\t\t  LCD_WINENABLE_WEN0,\n\t\t\t},\n\t\t\t{\n\t\t\t  0, 0, 0, 0,\n\t\t\t  LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP,\n\t\t\t  0,\n\t\t\t},\n\t\t\t{\n\t\t\t  0, 0, 0, 0,\n\t\t\t  LCD_WINCTRL1_FRM_32BPP |\n\t\t\t\tLCD_WINCTRL1_PO_00|LCD_WINCTRL1_PIPE,\n\t\t\t  0 ,\n\t\t\t},\n\t\t\t{\n\t\t\t  0, 0, 0, 0,\n\t\t\t  LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t  0,\n\t\t\t},\n\t\t},\n\t},\n\t \n\t \n\t \n};\n\n \n\nstruct panel_settings\n{\n\tconst char name[25];\t\t \n\n\tstruct \tfb_monspecs monspecs; \t \n\n\t \n\tuint32 mode_screen;\n\tuint32 mode_horztiming;\n\tuint32 mode_verttiming;\n\tuint32 mode_clkcontrol;\n\tuint32 mode_pwmdiv;\n\tuint32 mode_pwmhi;\n\tuint32 mode_outmask;\n\tuint32 mode_fifoctrl;\n\tuint32 mode_backlight;\n\tuint32 lcdclk;\n#define Xres min_xres\n#define Yres min_yres\n\tu32\tmin_xres;\t\t \n\tu32\tmax_xres;\t\t \n\tu32 \tmin_yres;\t\t \n\tu32 \tmax_yres;\t\t \n};\n\n \n \n\n \nstatic struct panel_settings known_lcd_panels[] =\n{\n\t[0] = {  \n\t\t.name = \"QVGA_320x240\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(320) |\n\t\t\tLCD_SCREEN_SY_N(240),\n\t\t.mode_horztiming\t= 0x00c4623b,\n\t\t.mode_verttiming\t= 0x00502814,\n\t\t.mode_clkcontrol\t= 0x00020002,  \n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.lcdclk\t\t= 96,\n\t\t320, 320,\n\t\t240, 240,\n\t},\n\n\t[1] = {  \n\t\t.name = \"VGA_640x480\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x13f9df80,\n\t\t.mode_horztiming\t= 0x003c5859,\n\t\t.mode_verttiming\t= 0x00741201,\n\t\t.mode_clkcontrol\t= 0x00020001,  \n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.lcdclk\t\t= 96,\n\t\t640, 480,\n\t\t640, 480,\n\t},\n\n\t[2] = {  \n\t\t.name = \"SVGA_800x600\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x18fa5780,\n\t\t.mode_horztiming\t= 0x00dc7e77,\n\t\t.mode_verttiming\t= 0x00584805,\n\t\t.mode_clkcontrol\t= 0x00020000,  \n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.lcdclk\t\t= 96,\n\t\t800, 800,\n\t\t600, 600,\n\t},\n\n\t[3] = {  \n\t\t.name = \"XVGA_1024x768\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x1ffaff80,\n\t\t.mode_horztiming\t= 0x007d0e57,\n\t\t.mode_verttiming\t= 0x00740a01,\n\t\t.mode_clkcontrol\t= 0x000A0000,  \n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.lcdclk\t\t= 72,\n\t\t1024, 1024,\n\t\t768, 768,\n\t},\n\n\t[4] = {  \n\t\t.name = \"XVGA_1280x1024\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x27fbff80,\n\t\t.mode_horztiming\t= 0x00cdb2c7,\n\t\t.mode_verttiming\t= 0x00600002,\n\t\t.mode_clkcontrol\t= 0x000A0000,  \n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.lcdclk\t\t= 120,\n\t\t1280, 1280,\n\t\t1024, 1024,\n\t},\n\n\t[5] = {  \n\t\t.name = \"Samsung_1024x768_TFT\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x1ffaff80,\n\t\t.mode_horztiming\t= 0x018cc677,\n\t\t.mode_verttiming\t= 0x00241217,\n\t\t.mode_clkcontrol\t= 0x00000000,  \n\t\t.mode_pwmdiv\t\t= 0x8000063f,  \n\t\t.mode_pwmhi\t\t= 0x03400000,  \n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.lcdclk\t\t= 96,\n\t\t1024, 1024,\n\t\t768, 768,\n\t},\n\n\t[6] = {  \n\t\t.name = \"Toshiba_640x480_TFT\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(640) |\n\t\t\tLCD_SCREEN_SY_N(480),\n\t\t.mode_horztiming\t= LCD_HORZTIMING_HPW_N(96) |\n\t\t\tLCD_HORZTIMING_HND1_N(13) | LCD_HORZTIMING_HND2_N(51),\n\t\t.mode_verttiming\t= LCD_VERTTIMING_VPW_N(2) |\n\t\t\tLCD_VERTTIMING_VND1_N(11) | LCD_VERTTIMING_VND2_N(32),\n\t\t.mode_clkcontrol\t= 0x00000000,  \n\t\t.mode_pwmdiv\t\t= 0x8000063f,\n\t\t.mode_pwmhi\t\t= 0x03400000,\n\t\t.mode_outmask\t= 0x00fcfcfc,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.lcdclk\t\t= 96,\n\t\t640, 480,\n\t\t640, 480,\n\t},\n\n\t[7] = {  \n\t\t.name = \"Sharp_320x240_TFT\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 12500,\n\t\t\t.hfmax = 20000,\n\t\t\t.vfmin = 38,\n\t\t\t.vfmax = 81,\n\t\t\t.dclkmin = 4500000,\n\t\t\t.dclkmax = 6800000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(320) |\n\t\t\tLCD_SCREEN_SY_N(240),\n\t\t.mode_horztiming\t= LCD_HORZTIMING_HPW_N(60) |\n\t\t\tLCD_HORZTIMING_HND1_N(13) | LCD_HORZTIMING_HND2_N(2),\n\t\t.mode_verttiming\t= LCD_VERTTIMING_VPW_N(2) |\n\t\t\tLCD_VERTTIMING_VND1_N(2) | LCD_VERTTIMING_VND2_N(5),\n\t\t.mode_clkcontrol\t= LCD_CLKCONTROL_PCD_N(7),  \n\t\t.mode_pwmdiv\t\t= 0x8000063f,\n\t\t.mode_pwmhi\t\t= 0x03400000,\n\t\t.mode_outmask\t= 0x00fcfcfc,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.lcdclk\t\t= 96,  \n\t\t320, 320,\n\t\t240, 240,\n\t},\n\n\t[8] = {  \n\t\t.name = \"Toppoly_TD070WGCB2\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(856) |\n\t\t\tLCD_SCREEN_SY_N(480),\n\t\t.mode_horztiming\t= LCD_HORZTIMING_HND2_N(43) |\n\t\t\tLCD_HORZTIMING_HND1_N(43) | LCD_HORZTIMING_HPW_N(114),\n\t\t.mode_verttiming\t= LCD_VERTTIMING_VND2_N(20) |\n\t\t\tLCD_VERTTIMING_VND1_N(21) | LCD_VERTTIMING_VPW_N(4),\n\t\t.mode_clkcontrol\t= 0x00020001,  \n\t\t.mode_pwmdiv\t\t= 0x8000063f,\n\t\t.mode_pwmhi\t\t= 0x03400000,\n\t\t.mode_outmask\t= 0x00fcfcfc,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.lcdclk\t\t= 96,\n\t\t856, 856,\n\t\t480, 480,\n\t},\n\t[9] = {\n\t\t.name = \"DB1300_800x480\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(800) |\n\t\t\t\t\t  LCD_SCREEN_SY_N(480),\n\t\t.mode_horztiming\t= LCD_HORZTIMING_HPW_N(5) |\n\t\t\t\t\t  LCD_HORZTIMING_HND1_N(16) |\n\t\t\t\t\t  LCD_HORZTIMING_HND2_N(8),\n\t\t.mode_verttiming\t= LCD_VERTTIMING_VPW_N(4) |\n\t\t\t\t\t  LCD_VERTTIMING_VND1_N(8) |\n\t\t\t\t\t  LCD_VERTTIMING_VND2_N(5),\n\t\t.mode_clkcontrol\t= LCD_CLKCONTROL_PCD_N(1) |\n\t\t\t\t\t  LCD_CLKCONTROL_IV |\n\t\t\t\t\t  LCD_CLKCONTROL_IH,\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t\t= 0x2f2f2f2f,\n\t\t.mode_backlight\t\t= 0x00000000,\n\t\t.lcdclk\t\t\t= 96,\n\t\t800, 800,\n\t\t480, 480,\n\t},\n};\n\n#define NUM_PANELS (ARRAY_SIZE(known_lcd_panels))\n\n \n\nstatic int winbpp (unsigned int winctrl1)\n{\n\tint bits = 0;\n\n\t \n\tswitch (winctrl1 & LCD_WINCTRL1_FRM) {\n\tcase LCD_WINCTRL1_FRM_1BPP:\n\t\tbits = 1;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_2BPP:\n\t\tbits = 2;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_4BPP:\n\t\tbits = 4;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_8BPP:\n\t\tbits = 8;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_12BPP:\n\tcase LCD_WINCTRL1_FRM_16BPP655:\n\tcase LCD_WINCTRL1_FRM_16BPP565:\n\tcase LCD_WINCTRL1_FRM_16BPP556:\n\tcase LCD_WINCTRL1_FRM_16BPPI1555:\n\tcase LCD_WINCTRL1_FRM_16BPPI5551:\n\tcase LCD_WINCTRL1_FRM_16BPPA1555:\n\tcase LCD_WINCTRL1_FRM_16BPPA5551:\n\t\tbits = 16;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_24BPP:\n\tcase LCD_WINCTRL1_FRM_32BPP:\n\t\tbits = 32;\n\t\tbreak;\n\t}\n\n\treturn bits;\n}\n\nstatic int fbinfo2index (struct fb_info *fb_info)\n{\n\tint i;\n\n\tfor (i = 0; i < device_count; ++i) {\n\t\tif (fb_info == _au1200fb_infos[i])\n\t\t\treturn i;\n\t}\n\tprintk(\"au1200fb: ERROR: fbinfo2index failed!\\n\");\n\treturn -1;\n}\n\nstatic int au1200_setlocation (struct au1200fb_device *fbdev, int plane,\n\tint xpos, int ypos)\n{\n\tuint32 winctrl0, winctrl1, winenable, fb_offset = 0;\n\tint xsz, ysz;\n\n\t \n\n\twinctrl0 = lcd->window[plane].winctrl0;\n\twinctrl1 = lcd->window[plane].winctrl1;\n\twinctrl0 &= (LCD_WINCTRL0_A | LCD_WINCTRL0_AEN);\n\twinctrl1 &= ~(LCD_WINCTRL1_SZX | LCD_WINCTRL1_SZY);\n\n\t \n\txsz = win->w[plane].xres;\n\tysz = win->w[plane].yres;\n\tif ((xpos + win->w[plane].xres) > panel->Xres) {\n\t\t \n\t\txsz = panel->Xres - xpos;  \n\t\t \n\t}\n\n\tif ((ypos + win->w[plane].yres) > panel->Yres) {\n\t\t \n\t\tysz = panel->Yres - ypos;  \n\t\t \n\t}\n\n\tif (xpos < 0) {\n\t\t \n\t\txsz = win->w[plane].xres + xpos;\n\t\tfb_offset += (((0 - xpos) * winbpp(lcd->window[plane].winctrl1))/8);\n\t\txpos = 0;\n\t\t \n\t}\n\n\tif (ypos < 0) {\n\t\t \n\t\tysz = win->w[plane].yres + ypos;\n\t\t \n\t\typos = 0;\n\t\t \n\t}\n\n\t \n\twin->w[plane].xpos = xpos;\n\twin->w[plane].ypos = ypos;\n\n\txsz -= 1;\n\tysz -= 1;\n\twinctrl0 |= (xpos << 21);\n\twinctrl0 |= (ypos << 10);\n\twinctrl1 |= (xsz << 11);\n\twinctrl1 |= (ysz << 0);\n\n\t \n\twinenable = lcd->winenable & (1 << plane);\n\twmb();  \n\tlcd->winenable &= ~(1 << plane);\n\tlcd->window[plane].winctrl0 = winctrl0;\n\tlcd->window[plane].winctrl1 = winctrl1;\n\tlcd->window[plane].winbuf0 =\n\tlcd->window[plane].winbuf1 = fbdev->fb_phys;\n\tlcd->window[plane].winbufctrl = 0;  \n\tlcd->winenable |= winenable;\n\twmb();  \n\n\treturn 0;\n}\n\nstatic void au1200_setpanel(struct panel_settings *newpanel,\n\t\t\t    struct au1200fb_platdata *pd)\n{\n\t \n\tuint32 winenable;\n\n\t \n\twinenable = lcd->winenable;\n\tlcd->winenable = 0;\n\twmb();  \n\t \n\tif (lcd->screen & LCD_SCREEN_SEN) {\n\t\t \n\t\tlcd->intstatus = LCD_INT_SS;\n\t\twhile ((lcd->intstatus & LCD_INT_SS) == 0)\n\t\t\t;\n\n\t\tlcd->screen &= ~LCD_SCREEN_SEN;\t \n\n\t\tdo {\n\t\t\tlcd->intstatus = lcd->intstatus;  \n\t\t\twmb();  \n\t\t \n\t\t} while ((lcd->intstatus & LCD_INT_SD) == 0);\n\n\t\t \n\t\t \n\t\tif (pd->panel_shutdown)\n\t\t\tpd->panel_shutdown();\n\t}\n\n\t \n\tif (newpanel == NULL)\n\t\treturn;\n\n\tpanel = newpanel;\n\n\tprintk(\"Panel(%s), %dx%d\\n\", panel->name, panel->Xres, panel->Yres);\n\n\t \n\tif (!(panel->mode_clkcontrol & LCD_CLKCONTROL_EXT))\n\t{\n\t\tstruct clk *c = clk_get(NULL, \"lcd_intclk\");\n\t\tlong r, pc = panel->lcdclk * 1000000;\n\n\t\tif (!IS_ERR(c)) {\n\t\t\tr = clk_round_rate(c, pc);\n\t\t\tif ((pc - r) < (pc / 10)) {\t \n\t\t\t\tclk_set_rate(c, r);\n\t\t\t\tclk_prepare_enable(c);\n\t\t\t}\n\t\t\tclk_put(c);\n\t\t}\n\t}\n\n\t \n\tlcd->screen = panel->mode_screen;\n\tlcd->horztiming = panel->mode_horztiming;\n\tlcd->verttiming = panel->mode_verttiming;\n\tlcd->clkcontrol = panel->mode_clkcontrol;\n\tlcd->pwmdiv = panel->mode_pwmdiv;\n\tlcd->pwmhi = panel->mode_pwmhi;\n\tlcd->outmask = panel->mode_outmask;\n\tlcd->fifoctrl = panel->mode_fifoctrl;\n\twmb();  \n\n\t \n#if 0\n\tau1200_setlocation(fbdev, 0, win->w[0].xpos, win->w[0].ypos);\n\tau1200_setlocation(fbdev, 1, win->w[1].xpos, win->w[1].ypos);\n\tau1200_setlocation(fbdev, 2, win->w[2].xpos, win->w[2].ypos);\n\tau1200_setlocation(fbdev, 3, win->w[3].xpos, win->w[3].ypos);\n#endif\n\tlcd->winenable = winenable;\n\n\t \n\tlcd->screen |= LCD_SCREEN_SEN;\n\twmb();  \n\n\t \n\tif (pd->panel_init)\n\t\tpd->panel_init();\n\n\t \n\tlcd->intenable = 0;\n\tlcd->intstatus = ~0;\n\tlcd->backcolor = win->mode_backcolor;\n\n\t \n\tlcd->colorkey = win->mode_colorkey;\n\tlcd->colorkeymsk = win->mode_colorkeymsk;\n\n\t \n\tlcd->hwc.cursorctrl = 0;\n\tlcd->hwc.cursorpos = 0;\n\tlcd->hwc.cursorcolor0 = 0;\n\tlcd->hwc.cursorcolor1 = 0;\n\tlcd->hwc.cursorcolor2 = 0;\n\tlcd->hwc.cursorcolor3 = 0;\n\n\n#if 0\n#define D(X) printk(\"%25s: %08X\\n\", #X, X)\n\tD(lcd->screen);\n\tD(lcd->horztiming);\n\tD(lcd->verttiming);\n\tD(lcd->clkcontrol);\n\tD(lcd->pwmdiv);\n\tD(lcd->pwmhi);\n\tD(lcd->outmask);\n\tD(lcd->fifoctrl);\n\tD(lcd->window[0].winctrl0);\n\tD(lcd->window[0].winctrl1);\n\tD(lcd->window[0].winctrl2);\n\tD(lcd->window[0].winbuf0);\n\tD(lcd->window[0].winbuf1);\n\tD(lcd->window[0].winbufctrl);\n\tD(lcd->window[1].winctrl0);\n\tD(lcd->window[1].winctrl1);\n\tD(lcd->window[1].winctrl2);\n\tD(lcd->window[1].winbuf0);\n\tD(lcd->window[1].winbuf1);\n\tD(lcd->window[1].winbufctrl);\n\tD(lcd->window[2].winctrl0);\n\tD(lcd->window[2].winctrl1);\n\tD(lcd->window[2].winctrl2);\n\tD(lcd->window[2].winbuf0);\n\tD(lcd->window[2].winbuf1);\n\tD(lcd->window[2].winbufctrl);\n\tD(lcd->window[3].winctrl0);\n\tD(lcd->window[3].winctrl1);\n\tD(lcd->window[3].winctrl2);\n\tD(lcd->window[3].winbuf0);\n\tD(lcd->window[3].winbuf1);\n\tD(lcd->window[3].winbufctrl);\n\tD(lcd->winenable);\n\tD(lcd->intenable);\n\tD(lcd->intstatus);\n\tD(lcd->backcolor);\n\tD(lcd->winenable);\n\tD(lcd->colorkey);\n    D(lcd->colorkeymsk);\n\tD(lcd->hwc.cursorctrl);\n\tD(lcd->hwc.cursorpos);\n\tD(lcd->hwc.cursorcolor0);\n\tD(lcd->hwc.cursorcolor1);\n\tD(lcd->hwc.cursorcolor2);\n\tD(lcd->hwc.cursorcolor3);\n#endif\n}\n\nstatic void au1200_setmode(struct au1200fb_device *fbdev)\n{\n\tint plane = fbdev->plane;\n\t \n\tlcd->window[plane].winctrl1 = ( 0\n\t\t| LCD_WINCTRL1_PRI_N(plane)\n\t\t| win->w[plane].mode_winctrl1  \n\t\t) ;\n\n\tau1200_setlocation(fbdev, plane, win->w[plane].xpos, win->w[plane].ypos);\n\n\tlcd->window[plane].winctrl2 = ( 0\n\t\t| LCD_WINCTRL2_CKMODE_00\n\t\t| LCD_WINCTRL2_DBM\n\t\t| LCD_WINCTRL2_BX_N(fbdev->fb_info->fix.line_length)\n\t\t| LCD_WINCTRL2_SCX_1\n\t\t| LCD_WINCTRL2_SCY_1\n\t\t) ;\n\tlcd->winenable |= win->w[plane].mode_winenable;\n\twmb();  \n}\n\n\n \n\n \n \n\n#define panel_is_color(panel) ((panel->mode_screen & LCD_SCREEN_PT) <= LCD_SCREEN_PT_CDSTN)\n\n \nstatic struct fb_bitfield rgb_bitfields[][4] = {\n  \t \n\t[LCD_WINCTRL1_FRM_16BPP655 >> 25] =\n\t\t{ { 10, 6, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPP565 >> 25] =\n\t\t{ { 11, 5, 0 }, { 5, 6, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPP556 >> 25] =\n\t\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 0, 6, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPPI1555 >> 25] =\n\t\t{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPPI5551 >> 25] =\n\t\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPPA1555 >> 25] =\n\t\t{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 15, 1, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPPA5551 >> 25] =\n\t\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 1, 0 } },\n\n\t[LCD_WINCTRL1_FRM_24BPP >> 25] =\n\t\t{ { 16, 8, 0 }, { 8, 8, 0 }, { 0, 8, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_32BPP >> 25] =\n\t\t{ { 16, 8, 0 }, { 8, 8, 0 }, { 0, 8, 0 }, { 24, 0, 0 } },\n};\n\n \n\n \n\nstatic void au1200fb_update_fbinfo(struct fb_info *fbi)\n{\n\t \n\n\t \n\tif (panel_is_color(panel)) {\n\t\tif (fbi->var.bits_per_pixel <= 8) {\n\t\t\t \n\t\t\tfbi->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\t\tfbi->fix.line_length = fbi->var.xres_virtual /\n\t\t\t\t(8/fbi->var.bits_per_pixel);\n\t\t} else {\n\t\t\t \n\t\t\tfbi->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\t\tfbi->fix.line_length = fbi->var.xres_virtual * (fbi->var.bits_per_pixel / 8);\n\t\t}\n\t} else {\n\t\t \n\t\tfbi->fix.visual = FB_VISUAL_MONO10;\n\t\tfbi->fix.line_length = fbi->var.xres_virtual / 8;\n\t}\n\n\tfbi->screen_size = fbi->fix.line_length * fbi->var.yres_virtual;\n\tprint_dbg(\"line length: %d\\n\", fbi->fix.line_length);\n\tprint_dbg(\"bits_per_pixel: %d\\n\", fbi->var.bits_per_pixel);\n}\n\n \n\n \n\n \nstatic int au1200fb_fb_check_var(struct fb_var_screeninfo *var,\n\tstruct fb_info *fbi)\n{\n\tstruct au1200fb_device *fbdev = fbi->par;\n\tu32 pixclock;\n\tint screen_size, plane;\n\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\tplane = fbdev->plane;\n\n\t \n\tvar->xres = win->w[plane].xres;\n\tvar->yres = win->w[plane].yres;\n\n\t \n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = var->yres;\n\n\tvar->bits_per_pixel = winbpp(win->w[plane].mode_winctrl1);\n\n\tscreen_size = var->xres_virtual * var->yres_virtual;\n\tif (var->bits_per_pixel > 8) screen_size *= (var->bits_per_pixel / 8);\n\telse screen_size /= (8/var->bits_per_pixel);\n\n\tif (fbdev->fb_len < screen_size)\n\t\treturn -EINVAL;  \n\n\t \n\t \n\tpixclock = max((u32)(PICOS2KHZ(var->pixclock) * 1000), fbi->monspecs.dclkmin);\n\tpixclock = min3(pixclock, fbi->monspecs.dclkmax, (u32)AU1200_LCD_MAX_CLK/2);\n\n\tif (AU1200_LCD_MAX_CLK % pixclock) {\n\t\tint diff = AU1200_LCD_MAX_CLK % pixclock;\n\t\tpixclock -= diff;\n\t}\n\n\tvar->pixclock = KHZ2PICOS(pixclock/1000);\n#if 0\n\tif (!panel_is_active(panel)) {\n\t\tint pcd = AU1200_LCD_MAX_CLK / (pixclock * 2) - 1;\n\n\t\tif (!panel_is_color(panel)\n\t\t\t&& (panel->control_base & LCD_CONTROL_MPI) && (pcd < 3)) {\n\t\t\t \n\t\t\tvar->pixclock = KHZ2PICOS(6000);\n\t\t} else if (!pcd) {\n\t\t\t \n\t\t\tvar->pixclock = KHZ2PICOS(12000);\n\t\t}\n\t}\n#endif\n\t \n\tswitch (var->bits_per_pixel) {\n\t\tcase 16:\n\t\t{\n\t\t\t \n\t\t\tint idx;\n\t\t\tidx = (win->w[0].mode_winctrl1 & LCD_WINCTRL1_FRM) >> 25;\n\t\t\tvar->red    = rgb_bitfields[idx][0];\n\t\t\tvar->green  = rgb_bitfields[idx][1];\n\t\t\tvar->blue   = rgb_bitfields[idx][2];\n\t\t\tvar->transp = rgb_bitfields[idx][3];\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 32:\n\t\t{\n\t\t\t \n\t\t\tint idx;\n\t\t\tidx = (win->w[0].mode_winctrl1 & LCD_WINCTRL1_FRM) >> 25;\n\t\t\tvar->red    = rgb_bitfields[idx][0];\n\t\t\tvar->green  = rgb_bitfields[idx][1];\n\t\t\tvar->blue   = rgb_bitfields[idx][2];\n\t\t\tvar->transp = rgb_bitfields[idx][3];\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tprint_dbg(\"Unsupported depth %dbpp\", var->bits_per_pixel);\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int au1200fb_fb_set_par(struct fb_info *fbi)\n{\n\tstruct au1200fb_device *fbdev = fbi->par;\n\n\tau1200fb_update_fbinfo(fbi);\n\tau1200_setmode(fbdev);\n\n\treturn 0;\n}\n\n \nstatic int au1200fb_fb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\tunsigned blue, unsigned transp, struct fb_info *fbi)\n{\n\tvolatile u32 *palette = lcd->palette;\n\tu32 value;\n\n\tif (regno > (AU1200_LCD_NBR_PALETTE_ENTRIES - 1))\n\t\treturn -EINVAL;\n\n\tif (fbi->var.grayscale) {\n\t\t \n\t\tred = green = blue =\n\t\t\t(19595 * red + 38470 * green + 7471 * blue) >> 16;\n\t}\n\n\tif (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\t \n\t\tif (regno > 16)\n\t\t\treturn -EINVAL;\n\n\t\tpalette = (u32*) fbi->pseudo_palette;\n\n\t\tred   >>= (16 - fbi->var.red.length);\n\t\tgreen >>= (16 - fbi->var.green.length);\n\t\tblue  >>= (16 - fbi->var.blue.length);\n\n\t\tvalue = (red   << fbi->var.red.offset) \t|\n\t\t\t(green << fbi->var.green.offset)|\n\t\t\t(blue  << fbi->var.blue.offset);\n\t\tvalue &= 0xFFFF;\n\n\t} else if (1  ) {\n\t\t \n\t\tvalue = (red & 0xF800)|((green >> 5) &\n\t\t\t\t0x07E0)|((blue >> 11) & 0x001F);\n\t\tvalue &= 0xFFFF;\n\n\t} else if (0  ) {\n\t\t \n\t\tvalue = 0x1234;\n\t\tvalue &= 0xFFF;\n\t} else {\n\t\t \n\t\tvalue = (green >> 12) & 0x000F;\n\t\tvalue &= 0xF;\n\t}\n\n\tpalette[regno] = value;\n\n\treturn 0;\n}\n\n \nstatic int au1200fb_fb_blank(int blank_mode, struct fb_info *fbi)\n{\n\tstruct au1200fb_device *fbdev = fbi->par;\n\n\t \n\tif (noblanking)\n\t\treturn 0;\n\n\tswitch (blank_mode) {\n\n\tcase FB_BLANK_UNBLANK:\n\tcase FB_BLANK_NORMAL:\n\t\t \n\t\tau1200_setpanel(panel, fbdev->pd);\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_POWERDOWN:\n\t\t \n\t\tau1200_setpanel(NULL, fbdev->pd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n\n\t \n\treturn (blank_mode == FB_BLANK_NORMAL) ? -EINVAL : 0;\n}\n\n \nstatic int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct au1200fb_device *fbdev = info->par;\n\n\treturn dma_mmap_coherent(fbdev->dev, vma,\n\t\t\t\t fbdev->fb_mem, fbdev->fb_phys, fbdev->fb_len);\n}\n\nstatic void set_global(u_int cmd, struct au1200_lcd_global_regs_t *pdata)\n{\n\n\tunsigned int hi1, divider;\n\n\t \n\n\tif (pdata->flags & SCREEN_BACKCOLOR)\n\t\tlcd->backcolor = pdata->backcolor;\n\n\tif (pdata->flags & SCREEN_BRIGHTNESS) {\n\n\t\t\n\t\tif (pdata->brightness < 30) {\n\t\t\tpdata->brightness = 30;\n\t\t}\n\t\tdivider = (lcd->pwmdiv & 0x3FFFF) + 1;\n\t\thi1 = (((pdata->brightness & 0xFF)+1) * divider >> 8);\n\t\tlcd->pwmhi &= 0xFFFF;\n\t\tlcd->pwmhi |= (hi1 << 16);\n\t}\n\n\tif (pdata->flags & SCREEN_COLORKEY)\n\t\tlcd->colorkey = pdata->colorkey;\n\n\tif (pdata->flags & SCREEN_MASK)\n\t\tlcd->colorkeymsk = pdata->mask;\n\twmb();  \n}\n\nstatic void get_global(u_int cmd, struct au1200_lcd_global_regs_t *pdata)\n{\n\tunsigned int hi1, divider;\n\n\tpdata->xsize = ((lcd->screen & LCD_SCREEN_SX) >> 19) + 1;\n\tpdata->ysize = ((lcd->screen & LCD_SCREEN_SY) >> 8) + 1;\n\n\tpdata->backcolor = lcd->backcolor;\n\tpdata->colorkey = lcd->colorkey;\n\tpdata->mask = lcd->colorkeymsk;\n\n\t\n\thi1 = (lcd->pwmhi >> 16) + 1;\n\tdivider = (lcd->pwmdiv & 0x3FFFF) + 1;\n\tpdata->brightness = ((hi1 << 8) / divider) - 1;\n\twmb();  \n}\n\nstatic void set_window(unsigned int plane,\n\tstruct au1200_lcd_window_regs_t *pdata)\n{\n\tunsigned int val, bpp;\n\n\t \n\tif (pdata->flags & WIN_POSITION) {\n\t\tval = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_OX |\n\t\t\t\tLCD_WINCTRL0_OY);\n\t\tval |= ((pdata->xpos << 21) & LCD_WINCTRL0_OX);\n\t\tval |= ((pdata->ypos << 10) & LCD_WINCTRL0_OY);\n\t\tlcd->window[plane].winctrl0 = val;\n\t}\n\tif (pdata->flags & WIN_ALPHA_COLOR) {\n\t\tval = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_A);\n\t\tval |= ((pdata->alpha_color << 2) & LCD_WINCTRL0_A);\n\t\tlcd->window[plane].winctrl0 = val;\n\t}\n\tif (pdata->flags & WIN_ALPHA_MODE) {\n\t\tval = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_AEN);\n\t\tval |= ((pdata->alpha_mode << 1) & LCD_WINCTRL0_AEN);\n\t\tlcd->window[plane].winctrl0 = val;\n\t}\n\n\t \n\tif (pdata->flags & WIN_PRIORITY) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PRI);\n\t\tval |= ((pdata->priority << 30) & LCD_WINCTRL1_PRI);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_CHANNEL) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PIPE);\n\t\tval |= ((pdata->channel << 29) & LCD_WINCTRL1_PIPE);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_BUFFER_FORMAT) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_FRM);\n\t\tval |= ((pdata->buffer_format << 25) & LCD_WINCTRL1_FRM);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_COLOR_ORDER) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_CCO);\n\t\tval |= ((pdata->color_order << 24) & LCD_WINCTRL1_CCO);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_PIXEL_ORDER) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PO);\n\t\tval |= ((pdata->pixel_order << 22) & LCD_WINCTRL1_PO);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_SIZE) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_SZX |\n\t\t\t\tLCD_WINCTRL1_SZY);\n\t\tval |= (((pdata->xsize << 11) - 1) & LCD_WINCTRL1_SZX);\n\t\tval |= (((pdata->ysize) - 1) & LCD_WINCTRL1_SZY);\n\t\tlcd->window[plane].winctrl1 = val;\n\t\t \n\t\tbpp = winbpp(val) / 8;\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_BX);\n\t\tval |= (((pdata->xsize * bpp) << 8) & LCD_WINCTRL2_BX);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\n\t \n\tif (pdata->flags & WIN_COLORKEY_MODE) {\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_CKMODE);\n\t\tval |= ((pdata->colorkey_mode << 24) & LCD_WINCTRL2_CKMODE);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\tif (pdata->flags & WIN_DOUBLE_BUFFER_MODE) {\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_DBM);\n\t\tval |= ((pdata->double_buffer_mode << 23) & LCD_WINCTRL2_DBM);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\tif (pdata->flags & WIN_RAM_ARRAY_MODE) {\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_RAM);\n\t\tval |= ((pdata->ram_array_mode << 21) & LCD_WINCTRL2_RAM);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\n\t \n\n\tif (pdata->flags & WIN_BUFFER_SCALE) {\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_SCX |\n\t\t\t\tLCD_WINCTRL2_SCY);\n\t\tval |= ((pdata->xsize << 11) & LCD_WINCTRL2_SCX);\n\t\tval |= ((pdata->ysize) & LCD_WINCTRL2_SCY);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\n\tif (pdata->flags & WIN_ENABLE) {\n\t\tval = lcd->winenable;\n\t\tval &= ~(1<<plane);\n\t\tval |= (pdata->enable & 1) << plane;\n\t\tlcd->winenable = val;\n\t}\n\twmb();  \n}\n\nstatic void get_window(unsigned int plane,\n\tstruct au1200_lcd_window_regs_t *pdata)\n{\n\t \n\tpdata->xpos = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_OX) >> 21;\n\tpdata->ypos = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_OY) >> 10;\n\tpdata->alpha_color = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_A) >> 2;\n\tpdata->alpha_mode = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_AEN) >> 1;\n\n\t \n\tpdata->priority = (lcd->window[plane].winctrl1& LCD_WINCTRL1_PRI) >> 30;\n\tpdata->channel = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_PIPE) >> 29;\n\tpdata->buffer_format = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_FRM) >> 25;\n\tpdata->color_order = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_CCO) >> 24;\n\tpdata->pixel_order = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_PO) >> 22;\n\tpdata->xsize = ((lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZX) >> 11) + 1;\n\tpdata->ysize = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZY) + 1;\n\n\t \n\tpdata->colorkey_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_CKMODE) >> 24;\n\tpdata->double_buffer_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_DBM) >> 23;\n\tpdata->ram_array_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_RAM) >> 21;\n\n\tpdata->enable = (lcd->winenable >> plane) & 1;\n\twmb();  \n}\n\nstatic int au1200fb_ioctl(struct fb_info *info, unsigned int cmd,\n                          unsigned long arg)\n{\n\tstruct au1200fb_device *fbdev = info->par;\n\tint plane;\n\tint val;\n\n\tplane = fbinfo2index(info);\n\tprint_dbg(\"au1200fb: ioctl %d on plane %d\\n\", cmd, plane);\n\n\tif (cmd == AU1200_LCD_FB_IOCTL) {\n\t\tstruct au1200_lcd_iodata_t iodata;\n\n\t\tif (copy_from_user(&iodata, (void __user *) arg, sizeof(iodata)))\n\t\t\treturn -EFAULT;\n\n\t\tprint_dbg(\"FB IOCTL called\\n\");\n\n\t\tswitch (iodata.subcmd) {\n\t\tcase AU1200_LCD_SET_SCREEN:\n\t\t\tprint_dbg(\"AU1200_LCD_SET_SCREEN\\n\");\n\t\t\tset_global(cmd, &iodata.global);\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_GET_SCREEN:\n\t\t\tprint_dbg(\"AU1200_LCD_GET_SCREEN\\n\");\n\t\t\tget_global(cmd, &iodata.global);\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_SET_WINDOW:\n\t\t\tprint_dbg(\"AU1200_LCD_SET_WINDOW\\n\");\n\t\t\tset_window(plane, &iodata.window);\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_GET_WINDOW:\n\t\t\tprint_dbg(\"AU1200_LCD_GET_WINDOW\\n\");\n\t\t\tget_window(plane, &iodata.window);\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_SET_PANEL:\n\t\t\tprint_dbg(\"AU1200_LCD_SET_PANEL\\n\");\n\t\t\tif ((iodata.global.panel_choice >= 0) &&\n\t\t\t\t\t(iodata.global.panel_choice <\n\t\t\t\t\t NUM_PANELS))\n\t\t\t{\n\t\t\t\tstruct panel_settings *newpanel;\n\t\t\t\tpanel_index = iodata.global.panel_choice;\n\t\t\t\tnewpanel = &known_lcd_panels[panel_index];\n\t\t\t\tau1200_setpanel(newpanel, fbdev->pd);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_GET_PANEL:\n\t\t\tprint_dbg(\"AU1200_LCD_GET_PANEL\\n\");\n\t\t\tiodata.global.panel_choice = panel_index;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = copy_to_user((void __user *) arg, &iodata, sizeof(iodata));\n\t\tif (val) {\n\t\t\tprint_dbg(\"error: could not copy %d bytes\\n\", val);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic const struct fb_ops au1200fb_fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= au1200fb_fb_check_var,\n\t.fb_set_par\t= au1200fb_fb_set_par,\n\t.fb_setcolreg\t= au1200fb_fb_setcolreg,\n\t.fb_blank\t= au1200fb_fb_blank,\n\t.fb_fillrect\t= sys_fillrect,\n\t.fb_copyarea\t= sys_copyarea,\n\t.fb_imageblit\t= sys_imageblit,\n\t.fb_read\t= fb_sys_read,\n\t.fb_write\t= fb_sys_write,\n\t.fb_sync\t= NULL,\n\t.fb_ioctl\t= au1200fb_ioctl,\n\t.fb_mmap\t= au1200fb_fb_mmap,\n};\n\n \n\nstatic irqreturn_t au1200fb_handle_irq(int irq, void* dev_id)\n{\n\t \n\tlcd->intstatus = lcd->intstatus;\n\twmb();  \n\n\treturn IRQ_HANDLED;\n}\n\n \n\n \n\nstatic int au1200fb_init_fbinfo(struct au1200fb_device *fbdev)\n{\n\tstruct fb_info *fbi = fbdev->fb_info;\n\tint bpp, ret;\n\n\tfbi->fbops = &au1200fb_fb_ops;\n\n\tbpp = winbpp(win->w[fbdev->plane].mode_winctrl1);\n\n\t \n\t \n\tmemcpy(&fbi->monspecs, &panel->monspecs, sizeof(struct fb_monspecs));\n\n\t \n\tif (!fb_find_mode(&fbi->var,\n\t\t\t  fbi,\n\t\t\t  NULL,  \n\t\t\t  fbi->monspecs.modedb,\n\t\t\t  fbi->monspecs.modedb_len,\n\t\t\t  fbi->monspecs.modedb,\n\t\t\t  bpp)) {\n\n\t\tprint_err(\"Cannot find valid mode for panel %s\", panel->name);\n\t\treturn -EFAULT;\n\t}\n\n\tfbi->pseudo_palette = kcalloc(16, sizeof(u32), GFP_KERNEL);\n\tif (!fbi->pseudo_palette)\n\t\treturn -ENOMEM;\n\n\tret = fb_alloc_cmap(&fbi->cmap, AU1200_LCD_NBR_PALETTE_ENTRIES, 0);\n\tif (ret < 0) {\n\t\tprint_err(\"Fail to allocate colormap (%d entries)\",\n\t\t\t  AU1200_LCD_NBR_PALETTE_ENTRIES);\n\t\treturn ret;\n\t}\n\n\tstrncpy(fbi->fix.id, \"AU1200\", sizeof(fbi->fix.id));\n\tfbi->fix.smem_start = fbdev->fb_phys;\n\tfbi->fix.smem_len = fbdev->fb_len;\n\tfbi->fix.type = FB_TYPE_PACKED_PIXELS;\n\tfbi->fix.xpanstep = 0;\n\tfbi->fix.ypanstep = 0;\n\tfbi->fix.mmio_start = 0;\n\tfbi->fix.mmio_len = 0;\n\tfbi->fix.accel = FB_ACCEL_NONE;\n\n\tfbi->screen_buffer = fbdev->fb_mem;\n\n\tau1200fb_update_fbinfo(fbi);\n\n\treturn 0;\n}\n\n \n\n\nstatic int au1200fb_setup(struct au1200fb_platdata *pd)\n{\n\tchar *options = NULL;\n\tchar *this_opt, *endptr;\n\tint num_panels = ARRAY_SIZE(known_lcd_panels);\n\tint panel_idx = -1;\n\n\tfb_get_options(DRIVER_NAME, &options);\n\n\tif (!options)\n\t\tgoto out;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\t \n\t\tif (!strncmp(this_opt, \"panel:\", 6)) {\n\t\t\tint i;\n\t\t\tlong int li;\n\t\t\tchar *endptr;\n\t\t\tthis_opt += 6;\n\t\t\t \n\t\t\tli = simple_strtol(this_opt, &endptr, 0);\n\t\t\tif (*endptr == '\\0')\n\t\t\t\tpanel_idx = (int)li;\n\t\t\telse if (strcmp(this_opt, \"bs\") == 0)\n\t\t\t\tpanel_idx = pd->panel_index();\n\t\t\telse {\n\t\t\t\tfor (i = 0; i < num_panels; i++) {\n\t\t\t\t\tif (!strcmp(this_opt,\n\t\t\t\t\t\t    known_lcd_panels[i].name)) {\n\t\t\t\t\t\tpanel_idx = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((panel_idx < 0) || (panel_idx >= num_panels))\n\t\t\t\tprint_warn(\"Panel %s not supported!\", this_opt);\n\t\t\telse\n\t\t\t\tpanel_index = panel_idx;\n\n\t\t} else if (strncmp(this_opt, \"nohwcursor\", 10) == 0)\n\t\t\tnohwcursor = 1;\n\t\telse if (strncmp(this_opt, \"devices:\", 8) == 0) {\n\t\t\tthis_opt += 8;\n\t\t\tdevice_count = simple_strtol(this_opt, &endptr, 0);\n\t\t\tif ((device_count < 0) ||\n\t\t\t    (device_count > MAX_DEVICE_COUNT))\n\t\t\t\tdevice_count = MAX_DEVICE_COUNT;\n\t\t} else if (strncmp(this_opt, \"wincfg:\", 7) == 0) {\n\t\t\tthis_opt += 7;\n\t\t\twindow_index = simple_strtol(this_opt, &endptr, 0);\n\t\t\tif ((window_index < 0) ||\n\t\t\t    (window_index >= ARRAY_SIZE(windows)))\n\t\t\t\twindow_index = DEFAULT_WINDOW_INDEX;\n\t\t} else if (strncmp(this_opt, \"off\", 3) == 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\tprint_warn(\"Unsupported option \\\"%s\\\"\", this_opt);\n\t}\n\nout:\n\treturn 0;\n}\n\n \nstatic int au1200fb_drv_probe(struct platform_device *dev)\n{\n\tstruct au1200fb_device *fbdev;\n\tstruct au1200fb_platdata *pd;\n\tstruct fb_info *fbi = NULL;\n\tint bpp, plane, ret, irq;\n\n\tprint_info(\"\" DRIVER_DESC \"\");\n\n\tpd = dev->dev.platform_data;\n\tif (!pd)\n\t\treturn -ENODEV;\n\n\t \n\tif (au1200fb_setup(pd))\n\t\treturn -ENODEV;\n\n\t \n\tpanel = &known_lcd_panels[panel_index];\n\twin = &windows[window_index];\n\n\tprintk(DRIVER_NAME \": Panel %d %s\\n\", panel_index, panel->name);\n\tprintk(DRIVER_NAME \": Win %d %s\\n\", window_index, win->name);\n\n\tfor (plane = 0; plane < device_count; ++plane) {\n\t\tbpp = winbpp(win->w[plane].mode_winctrl1);\n\t\tif (win->w[plane].xres == 0)\n\t\t\twin->w[plane].xres = panel->Xres;\n\t\tif (win->w[plane].yres == 0)\n\t\t\twin->w[plane].yres = panel->Yres;\n\n\t\tfbi = framebuffer_alloc(sizeof(struct au1200fb_device),\n\t\t\t\t\t&dev->dev);\n\t\tif (!fbi) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\t_au1200fb_infos[plane] = fbi;\n\t\tfbdev = fbi->par;\n\t\tfbdev->fb_info = fbi;\n\t\tfbdev->pd = pd;\n\t\tfbdev->dev = &dev->dev;\n\n\t\tfbdev->plane = plane;\n\n\t\t \n\t\tfbdev->fb_len = (win->w[plane].xres * win->w[plane].yres * bpp) / 8;\n\n\t\tfbdev->fb_mem = dmam_alloc_attrs(&dev->dev,\n\t\t\t\tPAGE_ALIGN(fbdev->fb_len),\n\t\t\t\t&fbdev->fb_phys, GFP_KERNEL, 0);\n\t\tif (!fbdev->fb_mem) {\n\t\t\tprint_err(\"fail to allocate framebuffer (size: %dK))\",\n\t\t\t\t  fbdev->fb_len / 1024);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tprint_dbg(\"Framebuffer memory map at %p\", fbdev->fb_mem);\n\t\tprint_dbg(\"phys=0x%08x, size=%dK\", fbdev->fb_phys, fbdev->fb_len / 1024);\n\n\t\t \n\t\tret = au1200fb_init_fbinfo(fbdev);\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\n\t\t \n\t\tret = register_framebuffer(fbi);\n\t\tif (ret < 0) {\n\t\t\tprint_err(\"cannot register new framebuffer\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tau1200fb_fb_set_par(fbi);\n\n#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)\n\t\tif (plane == 0)\n\t\t\tif (fb_prepare_logo(fbi, FB_ROTATE_UR)) {\n\t\t\t\t \n\t\t\t\tfb_set_cmap(&fbi->cmap, fbi);\n\t\t\t\tfb_show_logo(fbi, FB_ROTATE_UR);\n\t\t\t}\n#endif\n\t}\n\n\t \n\tirq = platform_get_irq(dev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = request_irq(irq, au1200fb_handle_irq,\n\t\t\t  IRQF_SHARED, \"lcd\", (void *)dev);\n\tif (ret) {\n\t\tprint_err(\"fail to request interrupt line %d (err: %d)\",\n\t\t\t  irq, ret);\n\t\tgoto failed;\n\t}\n\n\tplatform_set_drvdata(dev, pd);\n\n\t \n\tau1200_setpanel(panel, pd);\n\n\treturn 0;\n\nfailed:\n\tfor (plane = 0; plane < device_count; ++plane) {\n\t\tfbi = _au1200fb_infos[plane];\n\t\tif (!fbi)\n\t\t\tbreak;\n\n\t\t \n\t\tunregister_framebuffer(fbi);\n\t\tif (fbi->cmap.len != 0)\n\t\t\tfb_dealloc_cmap(&fbi->cmap);\n\t\tkfree(fbi->pseudo_palette);\n\n\t\tframebuffer_release(fbi);\n\t\t_au1200fb_infos[plane] = NULL;\n\t}\n\treturn ret;\n}\n\nstatic void au1200fb_drv_remove(struct platform_device *dev)\n{\n\tstruct au1200fb_platdata *pd = platform_get_drvdata(dev);\n\tstruct fb_info *fbi;\n\tint plane;\n\n\t \n\tau1200_setpanel(NULL, pd);\n\n\tfor (plane = 0; plane < device_count; ++plane)\t{\n\t\tfbi = _au1200fb_infos[plane];\n\n\t\t \n\t\tunregister_framebuffer(fbi);\n\t\tif (fbi->cmap.len != 0)\n\t\t\tfb_dealloc_cmap(&fbi->cmap);\n\t\tkfree(fbi->pseudo_palette);\n\n\t\tframebuffer_release(fbi);\n\t\t_au1200fb_infos[plane] = NULL;\n\t}\n\n\tfree_irq(platform_get_irq(dev, 0), (void *)dev);\n}\n\n#ifdef CONFIG_PM\nstatic int au1200fb_drv_suspend(struct device *dev)\n{\n\tstruct au1200fb_platdata *pd = dev_get_drvdata(dev);\n\tau1200_setpanel(NULL, pd);\n\n\tlcd->outmask = 0;\n\twmb();  \n\n\treturn 0;\n}\n\nstatic int au1200fb_drv_resume(struct device *dev)\n{\n\tstruct au1200fb_platdata *pd = dev_get_drvdata(dev);\n\tstruct fb_info *fbi;\n\tint i;\n\n\t \n\tau1200_setpanel(panel, pd);\n\n\tfor (i = 0; i < device_count; i++) {\n\t\tfbi = _au1200fb_infos[i];\n\t\tau1200fb_fb_set_par(fbi);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops au1200fb_pmops = {\n\t.suspend\t= au1200fb_drv_suspend,\n\t.resume\t\t= au1200fb_drv_resume,\n\t.freeze\t\t= au1200fb_drv_suspend,\n\t.thaw\t\t= au1200fb_drv_resume,\n};\n\n#define AU1200FB_PMOPS\t(&au1200fb_pmops)\n\n#else\n#define AU1200FB_PMOPS\tNULL\n#endif  \n\nstatic struct platform_driver au1200fb_driver = {\n\t.driver = {\n\t\t.name\t= \"au1200-lcd\",\n\t\t.pm\t= AU1200FB_PMOPS,\n\t},\n\t.probe\t\t= au1200fb_drv_probe,\n\t.remove_new\t= au1200fb_drv_remove,\n};\nmodule_platform_driver(au1200fb_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}