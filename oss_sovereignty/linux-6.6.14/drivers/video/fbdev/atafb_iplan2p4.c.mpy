{
  "module_name": "atafb_iplan2p4.c",
  "hash_id": "253175bf53e3dd7013ce4924569fdab99a25f0d6fcc27dc64cff2846e45521cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/atafb_iplan2p4.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <linux/fb.h>\n\n#include <asm/setup.h>\n\n#include \"atafb.h\"\n\n#define BPL\t4\n#include \"atafb_utils.h\"\n\nvoid atafb_iplan2p4_copyarea(struct fb_info *info, u_long next_line,\n\t\t\t     int sy, int sx, int dy, int dx,\n\t\t\t     int height, int width)\n{\n\t \n\n\tu8 *src, *dst;\n\tu32 *s, *d;\n\tint w, l , i, j;\n\tu_int colsize;\n\tu_int upwards = (dy < sy) || (dy == sy && dx < sx);\n\n\tcolsize = height;\n\tif (!((sx ^ dx) & 15)) {\n\t\t \n\n\t\tif (upwards) {\n\t\t\tsrc = (u8 *)info->screen_base + sy * next_line + (sx & ~15) / (8 / BPL);\n\t\t\tdst = (u8 *)info->screen_base + dy * next_line + (dx & ~15) / (8 / BPL);\n\t\t\tif (sx & 15) {\n\t\t\t\tmemmove32_col(dst, src, 0xff00ff, height, next_line - BPL * 2);\n\t\t\t\tsrc += BPL * 2;\n\t\t\t\tdst += BPL * 2;\n\t\t\t\twidth -= 8;\n\t\t\t}\n\t\t\tw = width >> 4;\n\t\t\tif (w) {\n\t\t\t\ts = (u32 *)src;\n\t\t\t\td = (u32 *)dst;\n\t\t\t\tw *= BPL / 2;\n\t\t\t\tl = next_line - w * 4;\n\t\t\t\tfor (j = height; j > 0; j--) {\n\t\t\t\t\tfor (i = w; i > 0; i--)\n\t\t\t\t\t\t*d++ = *s++;\n\t\t\t\t\ts = (u32 *)((u8 *)s + l);\n\t\t\t\t\td = (u32 *)((u8 *)d + l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (width & 15)\n\t\t\t\tmemmove32_col(dst + width / (8 / BPL), src + width / (8 / BPL),\n\t\t\t\t\t      0xff00ff00, height, next_line - BPL * 2);\n\t\t} else {\n\t\t\tsrc = (u8 *)info->screen_base + (sy - 1) * next_line + ((sx + width + 8) & ~15) / (8 / BPL);\n\t\t\tdst = (u8 *)info->screen_base + (dy - 1) * next_line + ((dx + width + 8) & ~15) / (8 / BPL);\n\n\t\t\tif ((sx + width) & 15) {\n\t\t\t\tsrc -= BPL * 2;\n\t\t\t\tdst -= BPL * 2;\n\t\t\t\tmemmove32_col(dst, src, 0xff00ff00, colsize, -next_line - BPL * 2);\n\t\t\t\twidth -= 8;\n\t\t\t}\n\t\t\tw = width >> 4;\n\t\t\tif (w) {\n\t\t\t\ts = (u32 *)src;\n\t\t\t\td = (u32 *)dst;\n\t\t\t\tw *= BPL / 2;\n\t\t\t\tl = next_line - w * 4;\n\t\t\t\tfor (j = height; j > 0; j--) {\n\t\t\t\t\tfor (i = w; i > 0; i--)\n\t\t\t\t\t\t*--d = *--s;\n\t\t\t\t\ts = (u32 *)((u8 *)s - l);\n\t\t\t\t\td = (u32 *)((u8 *)d - l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sx & 15)\n\t\t\t\tmemmove32_col(dst - (width - 16) / (8 / BPL),\n\t\t\t\t\t      src - (width - 16) / (8 / BPL),\n\t\t\t\t\t      0xff00ff, colsize, -next_line - BPL * 2);\n\t\t}\n\t} else {\n\t\t \n\t\tif (upwards) {\n\t\t\tu32 *src32, *dst32;\n\t\t\tu32 pval[4], v, v1, mask;\n\t\t\tint i, j, w, f;\n\n\t\t\tsrc = (u8 *)info->screen_base + sy * next_line + (sx & ~15) / (8 / BPL);\n\t\t\tdst = (u8 *)info->screen_base + dy * next_line + (dx & ~15) / (8 / BPL);\n\n\t\t\tmask = 0xff00ff00;\n\t\t\tf = 0;\n\t\t\tw = width;\n\t\t\tif (sx & 15) {\n\t\t\t\tf = 1;\n\t\t\t\tw += 8;\n\t\t\t}\n\t\t\tif ((sx + width) & 15)\n\t\t\t\tf |= 2;\n\t\t\tw >>= 4;\n\t\t\tfor (i = height; i; i--) {\n\t\t\t\tsrc32 = (u32 *)src;\n\t\t\t\tdst32 = (u32 *)dst;\n\n\t\t\t\tif (f & 1) {\n\t\t\t\t\tpval[0] = (*src32++ << 8) & mask;\n\t\t\t\t\tpval[1] = (*src32++ << 8) & mask;\n\t\t\t\t} else {\n\t\t\t\t\tpval[0] = dst32[0] & mask;\n\t\t\t\t\tpval[1] = dst32[1] & mask;\n\t\t\t\t}\n\n\t\t\t\tfor (j = w; j > 0; j--) {\n\t\t\t\t\tv = *src32++;\n\t\t\t\t\tv1 = v & mask;\n\t\t\t\t\t*dst32++ = pval[0] | (v1 >> 8);\n\t\t\t\t\tpval[0] = (v ^ v1) << 8;\n\t\t\t\t\tv = *src32++;\n\t\t\t\t\tv1 = v & mask;\n\t\t\t\t\t*dst32++ = pval[1] | (v1 >> 8);\n\t\t\t\t\tpval[1] = (v ^ v1) << 8;\n\t\t\t\t}\n\n\t\t\t\tif (f & 2) {\n\t\t\t\t\tdst32[0] = (dst32[0] & mask) | pval[0];\n\t\t\t\t\tdst32[1] = (dst32[1] & mask) | pval[1];\n\t\t\t\t}\n\n\t\t\t\tsrc += next_line;\n\t\t\t\tdst += next_line;\n\t\t\t}\n\t\t} else {\n\t\t\tu32 *src32, *dst32;\n\t\t\tu32 pval[4], v, v1, mask;\n\t\t\tint i, j, w, f;\n\n\t\t\tsrc = (u8 *)info->screen_base + (sy - 1) * next_line + ((sx + width + 8) & ~15) / (8 / BPL);\n\t\t\tdst = (u8 *)info->screen_base + (dy - 1) * next_line + ((dx + width + 8) & ~15) / (8 / BPL);\n\n\t\t\tmask = 0xff00ff;\n\t\t\tf = 0;\n\t\t\tw = width;\n\t\t\tif ((dx + width) & 15)\n\t\t\t\tf = 1;\n\t\t\tif (sx & 15) {\n\t\t\t\tf |= 2;\n\t\t\t\tw += 8;\n\t\t\t}\n\t\t\tw >>= 4;\n\t\t\tfor (i = height; i; i--) {\n\t\t\t\tsrc32 = (u32 *)src;\n\t\t\t\tdst32 = (u32 *)dst;\n\n\t\t\t\tif (f & 1) {\n\t\t\t\t\tpval[0] = dst32[-1] & mask;\n\t\t\t\t\tpval[1] = dst32[-2] & mask;\n\t\t\t\t} else {\n\t\t\t\t\tpval[0] = (*--src32 >> 8) & mask;\n\t\t\t\t\tpval[1] = (*--src32 >> 8) & mask;\n\t\t\t\t}\n\n\t\t\t\tfor (j = w; j > 0; j--) {\n\t\t\t\t\tv = *--src32;\n\t\t\t\t\tv1 = v & mask;\n\t\t\t\t\t*--dst32 = pval[0] | (v1 << 8);\n\t\t\t\t\tpval[0] = (v ^ v1) >> 8;\n\t\t\t\t\tv = *--src32;\n\t\t\t\t\tv1 = v & mask;\n\t\t\t\t\t*--dst32 = pval[1] | (v1 << 8);\n\t\t\t\t\tpval[1] = (v ^ v1) >> 8;\n\t\t\t\t}\n\n\t\t\t\tif (!(f & 2)) {\n\t\t\t\t\tdst32[-1] = (dst32[-1] & mask) | pval[0];\n\t\t\t\t\tdst32[-2] = (dst32[-2] & mask) | pval[1];\n\t\t\t\t}\n\n\t\t\t\tsrc -= next_line;\n\t\t\t\tdst -= next_line;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid atafb_iplan2p4_fillrect(struct fb_info *info, u_long next_line, u32 color,\n                             int sy, int sx, int height, int width)\n{\n\tu32 *dest;\n\tint rows, i;\n\tu32 cval[4];\n\n\tdest = (u32 *)(info->screen_base + sy * next_line + (sx & ~15) / (8 / BPL));\n\tif (sx & 15) {\n\t\tu8 *dest8 = (u8 *)dest + 1;\n\n\t\texpand8_col2mask(color, cval);\n\n\t\tfor (i = height; i; i--) {\n\t\t\tfill8_col(dest8, cval);\n\t\t\tdest8 += next_line;\n\t\t}\n\t\tdest += BPL / 2;\n\t\twidth -= 8;\n\t}\n\n\texpand16_col2mask(color, cval);\n\trows = width >> 4;\n\tif (rows) {\n\t\tu32 *d = dest;\n\t\tu32 off = next_line - rows * BPL * 2;\n\t\tfor (i = height; i; i--) {\n\t\t\td = fill16_col(d, rows, cval);\n\t\t\td = (u32 *)((long)d + off);\n\t\t}\n\t\tdest += rows * BPL / 2;\n\t\twidth &= 15;\n\t}\n\n\tif (width) {\n\t\tu8 *dest8 = (u8 *)dest;\n\n\t\texpand8_col2mask(color, cval);\n\n\t\tfor (i = height; i; i--) {\n\t\t\tfill8_col(dest8, cval);\n\t\t\tdest8 += next_line;\n\t\t}\n\t}\n}\n\nvoid atafb_iplan2p4_linefill(struct fb_info *info, u_long next_line,\n                             int dy, int dx, u32 width,\n                             const u8 *data, u32 bgcolor, u32 fgcolor)\n{\n\tu32 *dest;\n\tconst u16 *data16;\n\tint rows;\n\tu32 fgm[4], bgm[4], m;\n\n\tdest = (u32 *)(info->screen_base + dy * next_line + (dx & ~15) / (8 / BPL));\n\tif (dx & 15) {\n\t\tfill8_2col((u8 *)dest + 1, fgcolor, bgcolor, *data++);\n\t\tdest += BPL / 2;\n\t\twidth -= 8;\n\t}\n\n\tif (width >= 16) {\n\t\tdata16 = (const u16 *)data;\n\t\texpand16_2col2mask(fgcolor, bgcolor, fgm, bgm);\n\n\t\tfor (rows = width / 16; rows; rows--) {\n\t\t\tu16 d = *data16++;\n\t\t\tm = d | ((u32)d << 16);\n\t\t\t*dest++ = (m & fgm[0]) ^ bgm[0];\n\t\t\t*dest++ = (m & fgm[1]) ^ bgm[1];\n\t\t}\n\n\t\tdata = (const u8 *)data16;\n\t\twidth &= 15;\n\t}\n\n\tif (width)\n\t\tfill8_2col((u8 *)dest, fgcolor, bgcolor, *data);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}