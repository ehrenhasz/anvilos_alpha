{
  "module_name": "vermilion.c",
  "hash_id": "9430ff09f608440035067279fe67ae36f0e06a41a6e8d9800406c232702953b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/vermilion/vermilion.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/pci.h>\n#include <asm/set_memory.h>\n#include <asm/tlbflush.h>\n#include <linux/mmzone.h>\n\n \n\n#include \"vermilion.h\"\n\n#define MODULE_NAME \"vmlfb\"\n\n#define VML_TOHW(_val, _width) ((((_val) << (_width)) + 0x7FFF - (_val)) >> 16)\n\nstatic struct mutex vml_mutex;\nstatic struct list_head global_no_mode;\nstatic struct list_head global_has_mode;\nstatic struct fb_ops vmlfb_ops;\nstatic struct vml_sys *subsys = NULL;\nstatic char *vml_default_mode = \"1024x768@60\";\nstatic const struct fb_videomode defaultmode = {\n\tNULL, 60, 1024, 768, 12896, 144, 24, 29, 3, 136, 6,\n\t0, FB_VMODE_NONINTERLACED\n};\n\nstatic u32 vml_mem_requested = (10 * 1024 * 1024);\nstatic u32 vml_mem_contig = (4 * 1024 * 1024);\nstatic u32 vml_mem_min = (4 * 1024 * 1024);\n\nstatic u32 vml_clocks[] = {\n\t6750,\n\t13500,\n\t27000,\n\t29700,\n\t37125,\n\t54000,\n\t59400,\n\t74250,\n\t120000,\n\t148500\n};\n\nstatic u32 vml_num_clocks = ARRAY_SIZE(vml_clocks);\n\n \n\nstatic int vmlfb_alloc_vram_area(struct vram_area *va, unsigned max_order,\n\t\t\t\t unsigned min_order)\n{\n\tgfp_t flags;\n\tunsigned long i;\n\n\tmax_order++;\n\tdo {\n\t\t \n\n\t\tflags = __GFP_DMA | __GFP_HIGH | __GFP_KSWAPD_RECLAIM;\n\t\tva->logical =\n\t\t\t __get_free_pages(flags, --max_order);\n\t} while (va->logical == 0 && max_order > min_order);\n\n\tif (!va->logical)\n\t\treturn -ENOMEM;\n\n\tva->phys = virt_to_phys((void *)va->logical);\n\tva->size = PAGE_SIZE << max_order;\n\tva->order = max_order;\n\n\t \n\n\tmemset((void *)va->logical, 0x00, va->size);\n\tfor (i = va->logical; i < va->logical + va->size; i += PAGE_SIZE) {\n\t\tget_page(virt_to_page(i));\n\t}\n\n\t \n\tset_pages_uc(virt_to_page(va->logical), va->size >> PAGE_SHIFT);\n\n\tprintk(KERN_DEBUG MODULE_NAME\n\t       \": Allocated %ld bytes vram area at 0x%08lx\\n\",\n\t       va->size, va->phys);\n\n\treturn 0;\n}\n\n \n\nstatic void vmlfb_free_vram_area(struct vram_area *va)\n{\n\tunsigned long j;\n\n\tif (va->logical) {\n\n\t\t \n\n\t\tset_pages_wb(virt_to_page(va->logical),\n\t\t\t\t va->size >> PAGE_SHIFT);\n\n\t\t \n\n\t\tfor (j = va->logical; j < va->logical + va->size;\n\t\t     j += PAGE_SIZE) {\n\t\t\t(void)put_page_testzero(virt_to_page(j));\n\t\t}\n\n\t\tprintk(KERN_DEBUG MODULE_NAME\n\t\t       \": Freeing %ld bytes vram area at 0x%08lx\\n\",\n\t\t       va->size, va->phys);\n\t\tfree_pages(va->logical, va->order);\n\n\t\tva->logical = 0;\n\t}\n}\n\n \n\nstatic void vmlfb_free_vram(struct vml_info *vinfo)\n{\n\tint i;\n\n\tfor (i = 0; i < vinfo->num_areas; ++i) {\n\t\tvmlfb_free_vram_area(&vinfo->vram[i]);\n\t}\n\tvinfo->num_areas = 0;\n}\n\n \n\nstatic int vmlfb_alloc_vram(struct vml_info *vinfo,\n\t\t\t    size_t requested,\n\t\t\t    size_t min_total, size_t min_contig)\n{\n\tint i, j;\n\tint order;\n\tint contiguous;\n\tint err;\n\tstruct vram_area *va;\n\tstruct vram_area *va2;\n\n\tvinfo->num_areas = 0;\n\tfor (i = 0; i < VML_VRAM_AREAS; ++i) {\n\t\tva = &vinfo->vram[i];\n\t\torder = 0;\n\n\t\twhile (requested > (PAGE_SIZE << order) && order <= MAX_ORDER)\n\t\t\torder++;\n\n\t\terr = vmlfb_alloc_vram_area(va, order, 0);\n\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (i == 0) {\n\t\t\tvinfo->vram_start = va->phys;\n\t\t\tvinfo->vram_logical = (void __iomem *) va->logical;\n\t\t\tvinfo->vram_contig_size = va->size;\n\t\t\tvinfo->num_areas = 1;\n\t\t} else {\n\t\t\tcontiguous = 0;\n\n\t\t\tfor (j = 0; j < i; ++j) {\n\t\t\t\tva2 = &vinfo->vram[j];\n\t\t\t\tif (va->phys + va->size == va2->phys ||\n\t\t\t\t    va2->phys + va2->size == va->phys) {\n\t\t\t\t\tcontiguous = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (contiguous) {\n\t\t\t\tvinfo->num_areas++;\n\t\t\t\tif (va->phys < vinfo->vram_start) {\n\t\t\t\t\tvinfo->vram_start = va->phys;\n\t\t\t\t\tvinfo->vram_logical =\n\t\t\t\t\t\t(void __iomem *)va->logical;\n\t\t\t\t}\n\t\t\t\tvinfo->vram_contig_size += va->size;\n\t\t\t} else {\n\t\t\t\tvmlfb_free_vram_area(va);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (requested < va->size)\n\t\t\tbreak;\n\t\telse\n\t\t\trequested -= va->size;\n\t}\n\n\tif (vinfo->vram_contig_size > min_total &&\n\t    vinfo->vram_contig_size > min_contig) {\n\n\t\tprintk(KERN_DEBUG MODULE_NAME\n\t\t       \": Contiguous vram: %ld bytes at physical 0x%08lx.\\n\",\n\t\t       (unsigned long)vinfo->vram_contig_size,\n\t\t       (unsigned long)vinfo->vram_start);\n\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_ERR MODULE_NAME\n\t       \": Could not allocate requested minimal amount of vram.\\n\");\n\n\tvmlfb_free_vram(vinfo);\n\n\treturn -ENOMEM;\n}\n\n \n\nstatic int vmlfb_get_gpu(struct vml_par *par)\n{\n\tmutex_lock(&vml_mutex);\n\n\tpar->gpu = pci_get_device(PCI_VENDOR_ID_INTEL, VML_DEVICE_GPU, NULL);\n\n\tif (!par->gpu) {\n\t\tmutex_unlock(&vml_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_unlock(&vml_mutex);\n\n\tif (pci_enable_device(par->gpu) < 0) {\n\t\tpci_dev_put(par->gpu);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vmlfb_vram_offset(struct vml_info *vinfo, unsigned long offset)\n{\n\tunsigned long aoffset;\n\tunsigned i;\n\n\tfor (i = 0; i < vinfo->num_areas; ++i) {\n\t\taoffset = offset - (vinfo->vram[i].phys - vinfo->vram_start);\n\n\t\tif (aoffset < vinfo->vram[i].size) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \n\nstatic int vmlfb_enable_mmio(struct vml_par *par)\n{\n\tint err;\n\n\tpar->vdc_mem_base = pci_resource_start(par->vdc, 0);\n\tpar->vdc_mem_size = pci_resource_len(par->vdc, 0);\n\tif (!request_mem_region(par->vdc_mem_base, par->vdc_mem_size, \"vmlfb\")) {\n\t\tprintk(KERN_ERR MODULE_NAME\n\t\t       \": Could not claim display controller MMIO.\\n\");\n\t\treturn -EBUSY;\n\t}\n\tpar->vdc_mem = ioremap(par->vdc_mem_base, par->vdc_mem_size);\n\tif (par->vdc_mem == NULL) {\n\t\tprintk(KERN_ERR MODULE_NAME\n\t\t       \": Could not map display controller MMIO.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_err_0;\n\t}\n\n\tpar->gpu_mem_base = pci_resource_start(par->gpu, 0);\n\tpar->gpu_mem_size = pci_resource_len(par->gpu, 0);\n\tif (!request_mem_region(par->gpu_mem_base, par->gpu_mem_size, \"vmlfb\")) {\n\t\tprintk(KERN_ERR MODULE_NAME \": Could not claim GPU MMIO.\\n\");\n\t\terr = -EBUSY;\n\t\tgoto out_err_1;\n\t}\n\tpar->gpu_mem = ioremap(par->gpu_mem_base, par->gpu_mem_size);\n\tif (par->gpu_mem == NULL) {\n\t\tprintk(KERN_ERR MODULE_NAME \": Could not map GPU MMIO.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_err_2;\n\t}\n\n\treturn 0;\n\nout_err_2:\n\trelease_mem_region(par->gpu_mem_base, par->gpu_mem_size);\nout_err_1:\n\tiounmap(par->vdc_mem);\nout_err_0:\n\trelease_mem_region(par->vdc_mem_base, par->vdc_mem_size);\n\treturn err;\n}\n\n \n\nstatic void vmlfb_disable_mmio(struct vml_par *par)\n{\n\tiounmap(par->gpu_mem);\n\trelease_mem_region(par->gpu_mem_base, par->gpu_mem_size);\n\tiounmap(par->vdc_mem);\n\trelease_mem_region(par->vdc_mem_base, par->vdc_mem_size);\n}\n\n \n\nstatic void vmlfb_release_devices(struct vml_par *par)\n{\n\tif (atomic_dec_and_test(&par->refcount)) {\n\t\tpci_disable_device(par->gpu);\n\t\tpci_disable_device(par->vdc);\n\t}\n}\n\n \n\nstatic void vml_pci_remove(struct pci_dev *dev)\n{\n\tstruct fb_info *info;\n\tstruct vml_info *vinfo;\n\tstruct vml_par *par;\n\n\tinfo = pci_get_drvdata(dev);\n\tif (info) {\n\t\tvinfo = container_of(info, struct vml_info, info);\n\t\tpar = vinfo->par;\n\t\tmutex_lock(&vml_mutex);\n\t\tunregister_framebuffer(info);\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\tvmlfb_free_vram(vinfo);\n\t\tvmlfb_disable_mmio(par);\n\t\tvmlfb_release_devices(par);\n\t\tkfree(vinfo);\n\t\tkfree(par);\n\t\tmutex_unlock(&vml_mutex);\n\t}\n}\n\nstatic void vmlfb_set_pref_pixel_format(struct fb_var_screeninfo *var)\n{\n\tswitch (var->bits_per_pixel) {\n\tcase 16:\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 5;\n\t\tvar->red.offset = 10;\n\t\tvar->red.length = 5;\n\t\tvar->transp.offset = 15;\n\t\tvar->transp.length = 1;\n\t\tbreak;\n\tcase 32:\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tvar->blue.msb_right = var->green.msb_right =\n\t    var->red.msb_right = var->transp.msb_right = 0;\n}\n\n \n\nstatic int vml_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct vml_info *vinfo;\n\tstruct fb_info *info;\n\tstruct vml_par *par;\n\tint err;\n\n\terr = aperture_remove_conflicting_pci_devices(dev, \"vmlfb\");\n\tif (err)\n\t\treturn err;\n\n\tpar = kzalloc(sizeof(*par), GFP_KERNEL);\n\tif (par == NULL)\n\t\treturn -ENOMEM;\n\n\tvinfo = kzalloc(sizeof(*vinfo), GFP_KERNEL);\n\tif (vinfo == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err_0;\n\t}\n\n\tvinfo->par = par;\n\tpar->vdc = dev;\n\tatomic_set(&par->refcount, 1);\n\n\tswitch (id->device) {\n\tcase VML_DEVICE_VDC:\n\t\tif ((err = vmlfb_get_gpu(par)))\n\t\t\tgoto out_err_1;\n\t\tpci_set_drvdata(dev, &vinfo->info);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENODEV;\n\t\tgoto out_err_1;\n\t}\n\n\tinfo = &vinfo->info;\n\tinfo->flags = FBINFO_PARTIAL_PAN_OK;\n\n\terr = vmlfb_enable_mmio(par);\n\tif (err)\n\t\tgoto out_err_2;\n\n\terr = vmlfb_alloc_vram(vinfo, vml_mem_requested,\n\t\t\t       vml_mem_contig, vml_mem_min);\n\tif (err)\n\t\tgoto out_err_3;\n\n\tstrcpy(info->fix.id, \"Vermilion Range\");\n\tinfo->fix.mmio_start = 0;\n\tinfo->fix.mmio_len = 0;\n\tinfo->fix.smem_start = vinfo->vram_start;\n\tinfo->fix.smem_len = vinfo->vram_contig_size;\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\tinfo->fix.ypanstep = 1;\n\tinfo->fix.xpanstep = 1;\n\tinfo->fix.ywrapstep = 0;\n\tinfo->fix.accel = FB_ACCEL_NONE;\n\tinfo->screen_base = vinfo->vram_logical;\n\tinfo->pseudo_palette = vinfo->pseudo_palette;\n\tinfo->par = par;\n\tinfo->fbops = &vmlfb_ops;\n\tinfo->device = &dev->dev;\n\n\tINIT_LIST_HEAD(&vinfo->head);\n\tvinfo->pipe_disabled = 1;\n\tvinfo->cur_blank_mode = FB_BLANK_UNBLANK;\n\n\tinfo->var.grayscale = 0;\n\tinfo->var.bits_per_pixel = 16;\n\tvmlfb_set_pref_pixel_format(&info->var);\n\n\tif (!fb_find_mode\n\t    (&info->var, info, vml_default_mode, NULL, 0, &defaultmode, 16)) {\n\t\tprintk(KERN_ERR MODULE_NAME \": Could not find initial mode\\n\");\n\t}\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 1) < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err_4;\n\t}\n\n\terr = register_framebuffer(info);\n\tif (err) {\n\t\tprintk(KERN_ERR MODULE_NAME \": Register framebuffer error.\\n\");\n\t\tgoto out_err_5;\n\t}\n\n\tprintk(\"Initialized vmlfb\\n\");\n\n\treturn 0;\n\nout_err_5:\n\tfb_dealloc_cmap(&info->cmap);\nout_err_4:\n\tvmlfb_free_vram(vinfo);\nout_err_3:\n\tvmlfb_disable_mmio(par);\nout_err_2:\n\tvmlfb_release_devices(par);\nout_err_1:\n\tkfree(vinfo);\nout_err_0:\n\tkfree(par);\n\treturn err;\n}\n\nstatic int vmlfb_open(struct fb_info *info, int user)\n{\n\t \n\treturn 0;\n}\n\nstatic int vmlfb_release(struct fb_info *info, int user)\n{\n\t \n\n\treturn 0;\n}\n\nstatic int vml_nearest_clock(int clock)\n{\n\n\tint i;\n\tint cur_index;\n\tint cur_diff;\n\tint diff;\n\n\tcur_index = 0;\n\tcur_diff = clock - vml_clocks[0];\n\tcur_diff = (cur_diff < 0) ? -cur_diff : cur_diff;\n\tfor (i = 1; i < vml_num_clocks; ++i) {\n\t\tdiff = clock - vml_clocks[i];\n\t\tdiff = (diff < 0) ? -diff : diff;\n\t\tif (diff < cur_diff) {\n\t\t\tcur_index = i;\n\t\t\tcur_diff = diff;\n\t\t}\n\t}\n\treturn vml_clocks[cur_index];\n}\n\nstatic int vmlfb_check_var_locked(struct fb_var_screeninfo *var,\n\t\t\t\t  struct vml_info *vinfo)\n{\n\tu32 pitch;\n\tu64 mem;\n\tint nearest_clock;\n\tint clock;\n\tint clock_diff;\n\tstruct fb_var_screeninfo v;\n\n\tv = *var;\n\tclock = PICOS2KHZ(var->pixclock);\n\n\tif (subsys && subsys->nearest_clock) {\n\t\tnearest_clock = subsys->nearest_clock(subsys, clock);\n\t} else {\n\t\tnearest_clock = vml_nearest_clock(clock);\n\t}\n\n\t \n\n\tclock_diff = nearest_clock - clock;\n\tclock_diff = (clock_diff < 0) ? -clock_diff : clock_diff;\n\tif (clock_diff > clock / 5) {\n#if 0\n\t\tprintk(KERN_DEBUG MODULE_NAME \": Diff failure. %d %d\\n\",clock_diff,clock);\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\tv.pixclock = KHZ2PICOS(nearest_clock);\n\n\tif (var->xres > VML_MAX_XRES || var->yres > VML_MAX_YRES) {\n\t\tprintk(KERN_DEBUG MODULE_NAME \": Resolution failure.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (var->xres_virtual > VML_MAX_XRES_VIRTUAL) {\n\t\tprintk(KERN_DEBUG MODULE_NAME\n\t\t       \": Virtual resolution failure.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tswitch (v.bits_per_pixel) {\n\tcase 0 ... 16:\n\t\tv.bits_per_pixel = 16;\n\t\tbreak;\n\tcase 17 ... 32:\n\t\tv.bits_per_pixel = 32;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_DEBUG MODULE_NAME \": Invalid bpp: %d.\\n\",\n\t\t       var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\tpitch = ALIGN((var->xres * var->bits_per_pixel) >> 3, 0x40);\n\tmem = (u64)pitch * var->yres_virtual;\n\tif (mem > vinfo->vram_contig_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\tswitch (v.bits_per_pixel) {\n\tcase 16:\n\t\tif (var->blue.offset != 0 ||\n\t\t    var->blue.length != 5 ||\n\t\t    var->green.offset != 5 ||\n\t\t    var->green.length != 5 ||\n\t\t    var->red.offset != 10 ||\n\t\t    var->red.length != 5 ||\n\t\t    var->transp.offset != 15 || var->transp.length != 1) {\n\t\t\tvmlfb_set_pref_pixel_format(&v);\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tif (var->blue.offset != 0 ||\n\t\t    var->blue.length != 8 ||\n\t\t    var->green.offset != 8 ||\n\t\t    var->green.length != 8 ||\n\t\t    var->red.offset != 16 ||\n\t\t    var->red.length != 8 ||\n\t\t    (var->transp.length != 0 && var->transp.length != 8) ||\n\t\t    (var->transp.length == 8 && var->transp.offset != 24)) {\n\t\t\tvmlfb_set_pref_pixel_format(&v);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*var = v;\n\n\treturn 0;\n}\n\nstatic int vmlfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct vml_info *vinfo = container_of(info, struct vml_info, info);\n\tint ret;\n\n\tmutex_lock(&vml_mutex);\n\tret = vmlfb_check_var_locked(var, vinfo);\n\tmutex_unlock(&vml_mutex);\n\n\treturn ret;\n}\n\nstatic void vml_wait_vblank(struct vml_info *vinfo)\n{\n\t \n\tmdelay(20);\n}\n\nstatic void vmlfb_disable_pipe(struct vml_info *vinfo)\n{\n\tstruct vml_par *par = vinfo->par;\n\n\t \n\tVML_WRITE32(par, VML_RCOMPSTAT, 0);\n\twhile (!(VML_READ32(par, VML_RCOMPSTAT) & VML_MDVO_VDC_I_RCOMP)) ;\n\n\t \n\tVML_WRITE32(par, VML_DSPCCNTR,\n\t\t    VML_READ32(par, VML_DSPCCNTR) & ~VML_GFX_ENABLE);\n\t(void)VML_READ32(par, VML_DSPCCNTR);\n\t \n\tvml_wait_vblank(vinfo);\n\n\t \n\tVML_WRITE32(par, VML_PIPEACONF, 0);\n\t(void)VML_READ32(par, VML_PIPEACONF);\n\n\tvinfo->pipe_disabled = 1;\n}\n\n#ifdef VERMILION_DEBUG\nstatic void vml_dump_regs(struct vml_info *vinfo)\n{\n\tstruct vml_par *par = vinfo->par;\n\n\tprintk(KERN_DEBUG MODULE_NAME \": Modesetting register dump:\\n\");\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tHTOTAL_A         : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_HTOTAL_A));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tHBLANK_A         : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_HBLANK_A));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tHSYNC_A          : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_HSYNC_A));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tVTOTAL_A         : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_VTOTAL_A));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tVBLANK_A         : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_VBLANK_A));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tVSYNC_A          : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_VSYNC_A));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tDSPCSTRIDE       : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_DSPCSTRIDE));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tDSPCSIZE         : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_DSPCSIZE));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tDSPCPOS          : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_DSPCPOS));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tDSPARB           : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_DSPARB));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tDSPCADDR         : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_DSPCADDR));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tBCLRPAT_A        : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_BCLRPAT_A));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tCANVSCLR_A       : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_CANVSCLR_A));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tPIPEASRC         : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_PIPEASRC));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tPIPEACONF        : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_PIPEACONF));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tDSPCCNTR         : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_DSPCCNTR));\n\tprintk(KERN_DEBUG MODULE_NAME \": \\tRCOMPSTAT        : 0x%08x\\n\",\n\t       (unsigned)VML_READ32(par, VML_RCOMPSTAT));\n\tprintk(KERN_DEBUG MODULE_NAME \": End of modesetting register dump.\\n\");\n}\n#endif\n\nstatic int vmlfb_set_par_locked(struct vml_info *vinfo)\n{\n\tstruct vml_par *par = vinfo->par;\n\tstruct fb_info *info = &vinfo->info;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tu32 htotal, hactive, hblank_start, hblank_end, hsync_start, hsync_end;\n\tu32 vtotal, vactive, vblank_start, vblank_end, vsync_start, vsync_end;\n\tu32 dspcntr;\n\tint clock;\n\n\tvinfo->bytes_per_pixel = var->bits_per_pixel >> 3;\n\tvinfo->stride = ALIGN(var->xres_virtual * vinfo->bytes_per_pixel, 0x40);\n\tinfo->fix.line_length = vinfo->stride;\n\n\tif (!subsys)\n\t\treturn 0;\n\n\thtotal =\n\t    var->xres + var->right_margin + var->hsync_len + var->left_margin;\n\thactive = var->xres;\n\thblank_start = var->xres;\n\thblank_end = htotal;\n\thsync_start = hactive + var->right_margin;\n\thsync_end = hsync_start + var->hsync_len;\n\n\tvtotal =\n\t    var->yres + var->lower_margin + var->vsync_len + var->upper_margin;\n\tvactive = var->yres;\n\tvblank_start = var->yres;\n\tvblank_end = vtotal;\n\tvsync_start = vactive + var->lower_margin;\n\tvsync_end = vsync_start + var->vsync_len;\n\n\tdspcntr = VML_GFX_ENABLE | VML_GFX_GAMMABYPASS;\n\tclock = PICOS2KHZ(var->pixclock);\n\n\tif (subsys->nearest_clock) {\n\t\tclock = subsys->nearest_clock(subsys, clock);\n\t} else {\n\t\tclock = vml_nearest_clock(clock);\n\t}\n\tprintk(KERN_DEBUG MODULE_NAME\n\t       \": Set mode Hfreq : %d kHz, Vfreq : %d Hz.\\n\", clock / htotal,\n\t       ((clock / htotal) * 1000) / vtotal);\n\n\tswitch (var->bits_per_pixel) {\n\tcase 16:\n\t\tdspcntr |= VML_GFX_ARGB1555;\n\t\tbreak;\n\tcase 32:\n\t\tif (var->transp.length == 8)\n\t\t\tdspcntr |= VML_GFX_ARGB8888 | VML_GFX_ALPHAMULT;\n\t\telse\n\t\t\tdspcntr |= VML_GFX_RGB0888;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tvmlfb_disable_pipe(vinfo);\n\tmb();\n\n\tif (subsys->set_clock)\n\t\tsubsys->set_clock(subsys, clock);\n\telse\n\t\treturn -EINVAL;\n\n\tVML_WRITE32(par, VML_HTOTAL_A, ((htotal - 1) << 16) | (hactive - 1));\n\tVML_WRITE32(par, VML_HBLANK_A,\n\t\t    ((hblank_end - 1) << 16) | (hblank_start - 1));\n\tVML_WRITE32(par, VML_HSYNC_A,\n\t\t    ((hsync_end - 1) << 16) | (hsync_start - 1));\n\tVML_WRITE32(par, VML_VTOTAL_A, ((vtotal - 1) << 16) | (vactive - 1));\n\tVML_WRITE32(par, VML_VBLANK_A,\n\t\t    ((vblank_end - 1) << 16) | (vblank_start - 1));\n\tVML_WRITE32(par, VML_VSYNC_A,\n\t\t    ((vsync_end - 1) << 16) | (vsync_start - 1));\n\tVML_WRITE32(par, VML_DSPCSTRIDE, vinfo->stride);\n\tVML_WRITE32(par, VML_DSPCSIZE,\n\t\t    ((var->yres - 1) << 16) | (var->xres - 1));\n\tVML_WRITE32(par, VML_DSPCPOS, 0x00000000);\n\tVML_WRITE32(par, VML_DSPARB, VML_FIFO_DEFAULT);\n\tVML_WRITE32(par, VML_BCLRPAT_A, 0x00000000);\n\tVML_WRITE32(par, VML_CANVSCLR_A, 0x00000000);\n\tVML_WRITE32(par, VML_PIPEASRC,\n\t\t    ((var->xres - 1) << 16) | (var->yres - 1));\n\n\twmb();\n\tVML_WRITE32(par, VML_PIPEACONF, VML_PIPE_ENABLE);\n\twmb();\n\tVML_WRITE32(par, VML_DSPCCNTR, dspcntr);\n\twmb();\n\tVML_WRITE32(par, VML_DSPCADDR, (u32) vinfo->vram_start +\n\t\t    var->yoffset * vinfo->stride +\n\t\t    var->xoffset * vinfo->bytes_per_pixel);\n\n\tVML_WRITE32(par, VML_RCOMPSTAT, VML_MDVO_PAD_ENABLE);\n\n\twhile (!(VML_READ32(par, VML_RCOMPSTAT) &\n\t\t (VML_MDVO_VDC_I_RCOMP | VML_MDVO_PAD_ENABLE))) ;\n\n\tvinfo->pipe_disabled = 0;\n#ifdef VERMILION_DEBUG\n\tvml_dump_regs(vinfo);\n#endif\n\n\treturn 0;\n}\n\nstatic int vmlfb_set_par(struct fb_info *info)\n{\n\tstruct vml_info *vinfo = container_of(info, struct vml_info, info);\n\tint ret;\n\n\tmutex_lock(&vml_mutex);\n\tlist_move(&vinfo->head, (subsys) ? &global_has_mode : &global_no_mode);\n\tret = vmlfb_set_par_locked(vinfo);\n\n\tmutex_unlock(&vml_mutex);\n\treturn ret;\n}\n\nstatic int vmlfb_blank_locked(struct vml_info *vinfo)\n{\n\tstruct vml_par *par = vinfo->par;\n\tu32 cur = VML_READ32(par, VML_PIPEACONF);\n\n\tswitch (vinfo->cur_blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\tif (vinfo->pipe_disabled) {\n\t\t\tvmlfb_set_par_locked(vinfo);\n\t\t}\n\t\tVML_WRITE32(par, VML_PIPEACONF, cur & ~VML_PIPE_FORCE_BORDER);\n\t\t(void)VML_READ32(par, VML_PIPEACONF);\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\tif (vinfo->pipe_disabled) {\n\t\t\tvmlfb_set_par_locked(vinfo);\n\t\t}\n\t\tVML_WRITE32(par, VML_PIPEACONF, cur | VML_PIPE_FORCE_BORDER);\n\t\t(void)VML_READ32(par, VML_PIPEACONF);\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tif (!vinfo->pipe_disabled) {\n\t\t\tvmlfb_disable_pipe(vinfo);\n\t\t}\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tif (!vinfo->pipe_disabled) {\n\t\t\tvmlfb_disable_pipe(vinfo);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vmlfb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct vml_info *vinfo = container_of(info, struct vml_info, info);\n\tint ret;\n\n\tmutex_lock(&vml_mutex);\n\tvinfo->cur_blank_mode = blank_mode;\n\tret = vmlfb_blank_locked(vinfo);\n\tmutex_unlock(&vml_mutex);\n\treturn ret;\n}\n\nstatic int vmlfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tstruct vml_info *vinfo = container_of(info, struct vml_info, info);\n\tstruct vml_par *par = vinfo->par;\n\n\tmutex_lock(&vml_mutex);\n\tVML_WRITE32(par, VML_DSPCADDR, (u32) vinfo->vram_start +\n\t\t    var->yoffset * vinfo->stride +\n\t\t    var->xoffset * vinfo->bytes_per_pixel);\n\t(void)VML_READ32(par, VML_DSPCADDR);\n\tmutex_unlock(&vml_mutex);\n\n\treturn 0;\n}\n\nstatic int vmlfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t   u_int transp, struct fb_info *info)\n{\n\tu32 v;\n\n\tif (regno >= 16)\n\t\treturn -EINVAL;\n\n\tif (info->var.grayscale) {\n\t\tred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n\t}\n\n\tif (info->fix.visual != FB_VISUAL_TRUECOLOR)\n\t\treturn -EINVAL;\n\n\tred = VML_TOHW(red, info->var.red.length);\n\tblue = VML_TOHW(blue, info->var.blue.length);\n\tgreen = VML_TOHW(green, info->var.green.length);\n\ttransp = VML_TOHW(transp, info->var.transp.length);\n\n\tv = (red << info->var.red.offset) |\n\t    (green << info->var.green.offset) |\n\t    (blue << info->var.blue.offset) |\n\t    (transp << info->var.transp.offset);\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 16:\n\t\t((u32 *) info->pseudo_palette)[regno] = v;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\t((u32 *) info->pseudo_palette)[regno] = v;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int vmlfb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct vml_info *vinfo = container_of(info, struct vml_info, info);\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\tint ret;\n\tunsigned long prot;\n\n\tret = vmlfb_vram_offset(vinfo, offset);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tprot = pgprot_val(vma->vm_page_prot) & ~_PAGE_CACHE_MASK;\n\tpgprot_val(vma->vm_page_prot) =\n\t\tprot | cachemode2protval(_PAGE_CACHE_MODE_UC_MINUS);\n\n\treturn vm_iomap_memory(vma, vinfo->vram_start,\n\t\t\tvinfo->vram_contig_size);\n}\n\nstatic int vmlfb_sync(struct fb_info *info)\n{\n\treturn 0;\n}\n\nstatic int vmlfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\treturn -EINVAL;\t \n}\n\nstatic struct fb_ops vmlfb_ops = {\n\t.owner = THIS_MODULE,\n\t.fb_open = vmlfb_open,\n\t.fb_release = vmlfb_release,\n\t.fb_check_var = vmlfb_check_var,\n\t.fb_set_par = vmlfb_set_par,\n\t.fb_blank = vmlfb_blank,\n\t.fb_pan_display = vmlfb_pan_display,\n\t.fb_fillrect = cfb_fillrect,\n\t.fb_copyarea = cfb_copyarea,\n\t.fb_imageblit = cfb_imageblit,\n\t.fb_cursor = vmlfb_cursor,\n\t.fb_sync = vmlfb_sync,\n\t.fb_mmap = vmlfb_mmap,\n\t.fb_setcolreg = vmlfb_setcolreg\n};\n\nstatic const struct pci_device_id vml_ids[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, VML_DEVICE_VDC)},\n\t{0}\n};\n\nstatic struct pci_driver vmlfb_pci_driver = {\n\t.name = \"vmlfb\",\n\t.id_table = vml_ids,\n\t.probe = vml_pci_probe,\n\t.remove = vml_pci_remove,\n};\n\nstatic void __exit vmlfb_cleanup(void)\n{\n\tpci_unregister_driver(&vmlfb_pci_driver);\n}\n\nstatic int __init vmlfb_init(void)\n{\n\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"vmlfb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(MODULE_NAME, &option))\n\t\treturn -ENODEV;\n#endif\n\n\tprintk(KERN_DEBUG MODULE_NAME \": initializing\\n\");\n\tmutex_init(&vml_mutex);\n\tINIT_LIST_HEAD(&global_no_mode);\n\tINIT_LIST_HEAD(&global_has_mode);\n\n\treturn pci_register_driver(&vmlfb_pci_driver);\n}\n\nint vmlfb_register_subsys(struct vml_sys *sys)\n{\n\tstruct vml_info *entry;\n\tstruct list_head *list;\n\tu32 save_activate;\n\n\tmutex_lock(&vml_mutex);\n\tif (subsys != NULL) {\n\t\tsubsys->restore(subsys);\n\t}\n\tsubsys = sys;\n\tsubsys->save(subsys);\n\n\t \n\n\tlist = global_no_mode.next;\n\twhile (list != &global_no_mode) {\n\t\tlist_del_init(list);\n\t\tentry = list_entry(list, struct vml_info, head);\n\n\t\t \n\n\t\tif (!vmlfb_check_var_locked(&entry->info.var, entry)) {\n\t\t\tvmlfb_set_par_locked(entry);\n\t\t\tlist_add_tail(list, &global_has_mode);\n\t\t} else {\n\n\t\t\t \n\n\t\t\tmutex_unlock(&vml_mutex);\n\t\t\tsave_activate = entry->info.var.activate;\n\t\t\tentry->info.var.bits_per_pixel = 16;\n\t\t\tvmlfb_set_pref_pixel_format(&entry->info.var);\n\t\t\tif (fb_find_mode(&entry->info.var,\n\t\t\t\t\t &entry->info,\n\t\t\t\t\t vml_default_mode, NULL, 0, NULL, 16)) {\n\t\t\t\tentry->info.var.activate |=\n\t\t\t\t    FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW;\n\t\t\t\tfb_set_var(&entry->info, &entry->info.var);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_ERR MODULE_NAME\n\t\t\t\t       \": Sorry. no mode found for this subsys.\\n\");\n\t\t\t}\n\t\t\tentry->info.var.activate = save_activate;\n\t\t\tmutex_lock(&vml_mutex);\n\t\t}\n\t\tvmlfb_blank_locked(entry);\n\t\tlist = global_no_mode.next;\n\t}\n\tmutex_unlock(&vml_mutex);\n\n\tprintk(KERN_DEBUG MODULE_NAME \": Registered %s subsystem.\\n\",\n\t\t\t\tsubsys->name ? subsys->name : \"unknown\");\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(vmlfb_register_subsys);\n\nvoid vmlfb_unregister_subsys(struct vml_sys *sys)\n{\n\tstruct vml_info *entry, *next;\n\n\tmutex_lock(&vml_mutex);\n\tif (subsys != sys) {\n\t\tmutex_unlock(&vml_mutex);\n\t\treturn;\n\t}\n\tsubsys->restore(subsys);\n\tsubsys = NULL;\n\tlist_for_each_entry_safe(entry, next, &global_has_mode, head) {\n\t\tprintk(KERN_DEBUG MODULE_NAME \": subsys disable pipe\\n\");\n\t\tvmlfb_disable_pipe(entry);\n\t\tlist_move_tail(&entry->head, &global_no_mode);\n\t}\n\tmutex_unlock(&vml_mutex);\n}\n\nEXPORT_SYMBOL_GPL(vmlfb_unregister_subsys);\n\nmodule_init(vmlfb_init);\nmodule_exit(vmlfb_cleanup);\n\nMODULE_AUTHOR(\"Tungsten Graphics\");\nMODULE_DESCRIPTION(\"Initialization of the Vermilion display devices\");\nMODULE_VERSION(\"1.0.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}