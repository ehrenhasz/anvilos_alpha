{
  "module_name": "arkfb.c",
  "hash_id": "fa982281b3cc62db591d2635c0d82d8965a62ac3b324569983ab1590932bbff6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/arkfb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/tty.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/svga.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/console.h>  \n#include <video/vga.h>\n\nstruct arkfb_info {\n\tint mclk_freq;\n\tint wc_cookie;\n\n\tstruct dac_info *dac;\n\tstruct vgastate state;\n\tstruct mutex open_lock;\n\tunsigned int ref_count;\n\tu32 pseudo_palette[16];\n};\n\n\n \n\n\nstatic const struct svga_fb_format arkfb_formats[] = {\n\t{ 0,  {0, 6, 0},  {0, 6, 0},  {0, 6, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_TEXT, FB_AUX_TEXT_SVGA_STEP4,\tFB_VISUAL_PSEUDOCOLOR, 8, 8},\n\t{ 4,  {0, 6, 0},  {0, 6, 0},  {0, 6, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_PSEUDOCOLOR, 8, 16},\n\t{ 4,  {0, 6, 0},  {0, 6, 0},  {0, 6, 0}, {0, 0, 0}, 1,\n\t\tFB_TYPE_INTERLEAVED_PLANES, 1,\t\tFB_VISUAL_PSEUDOCOLOR, 8, 16},\n\t{ 8,  {0, 6, 0},  {0, 6, 0},  {0, 6, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_PSEUDOCOLOR, 8, 8},\n\t{16,  {10, 5, 0}, {5, 5, 0},  {0, 5, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_TRUECOLOR, 4, 4},\n\t{16,  {11, 5, 0}, {5, 6, 0},  {0, 5, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_TRUECOLOR, 4, 4},\n\t{24,  {16, 8, 0}, {8, 8, 0},  {0, 8, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_TRUECOLOR, 8, 8},\n\t{32,  {16, 8, 0}, {8, 8, 0},  {0, 8, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_TRUECOLOR, 2, 2},\n\tSVGA_FORMAT_END\n};\n\n\n \n\nstatic const struct vga_regset ark_h_total_regs[]        = {{0x00, 0, 7}, {0x41, 7, 7}, VGA_REGSET_END};\nstatic const struct vga_regset ark_h_display_regs[]      = {{0x01, 0, 7}, {0x41, 6, 6}, VGA_REGSET_END};\nstatic const struct vga_regset ark_h_blank_start_regs[]  = {{0x02, 0, 7}, {0x41, 5, 5}, VGA_REGSET_END};\nstatic const struct vga_regset ark_h_blank_end_regs[]    = {{0x03, 0, 4}, {0x05, 7, 7\t}, VGA_REGSET_END};\nstatic const struct vga_regset ark_h_sync_start_regs[]   = {{0x04, 0, 7}, {0x41, 4, 4}, VGA_REGSET_END};\nstatic const struct vga_regset ark_h_sync_end_regs[]     = {{0x05, 0, 4}, VGA_REGSET_END};\n\nstatic const struct vga_regset ark_v_total_regs[]        = {{0x06, 0, 7}, {0x07, 0, 0}, {0x07, 5, 5}, {0x40, 7, 7}, VGA_REGSET_END};\nstatic const struct vga_regset ark_v_display_regs[]      = {{0x12, 0, 7}, {0x07, 1, 1}, {0x07, 6, 6}, {0x40, 6, 6}, VGA_REGSET_END};\nstatic const struct vga_regset ark_v_blank_start_regs[]  = {{0x15, 0, 7}, {0x07, 3, 3}, {0x09, 5, 5}, {0x40, 5, 5}, VGA_REGSET_END};\n\nstatic const struct vga_regset ark_v_blank_end_regs[]    = {{0x16, 0, 7}, VGA_REGSET_END};\nstatic const struct vga_regset ark_v_sync_start_regs[]   = {{0x10, 0, 7}, {0x07, 2, 2}, {0x07, 7, 7}, {0x40, 4, 4}, VGA_REGSET_END};\nstatic const struct vga_regset ark_v_sync_end_regs[]     = {{0x11, 0, 3}, VGA_REGSET_END};\n\nstatic const struct vga_regset ark_line_compare_regs[]   = {{0x18, 0, 7}, {0x07, 4, 4}, {0x09, 6, 6}, VGA_REGSET_END};\nstatic const struct vga_regset ark_start_address_regs[]  = {{0x0d, 0, 7}, {0x0c, 0, 7}, {0x40, 0, 2}, VGA_REGSET_END};\nstatic const struct vga_regset ark_offset_regs[]         = {{0x13, 0, 7}, {0x41, 3, 3}, VGA_REGSET_END};\n\nstatic const struct svga_timing_regs ark_timing_regs     = {\n\tark_h_total_regs, ark_h_display_regs, ark_h_blank_start_regs,\n\tark_h_blank_end_regs, ark_h_sync_start_regs, ark_h_sync_end_regs,\n\tark_v_total_regs, ark_v_display_regs, ark_v_blank_start_regs,\n\tark_v_blank_end_regs, ark_v_sync_start_regs, ark_v_sync_end_regs,\n};\n\n\n \n\n\n \n\nstatic char *mode_option = \"640x480-8@60\";\n\nMODULE_AUTHOR(\"(c) 2007 Ondrej Zajicek <santiago@crfreenet.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"fbdev driver for ARK 2000PV\");\n\nmodule_param(mode_option, charp, 0444);\nMODULE_PARM_DESC(mode_option, \"Default video mode ('640x480-8@60', etc)\");\nmodule_param_named(mode, mode_option, charp, 0444);\nMODULE_PARM_DESC(mode, \"Default video mode ('640x480-8@60', etc) (deprecated)\");\n\nstatic int threshold = 4;\n\nmodule_param(threshold, int, 0644);\nMODULE_PARM_DESC(threshold, \"FIFO threshold\");\n\n\n \n\n\nstatic void arkfb_settile(struct fb_info *info, struct fb_tilemap *map)\n{\n\tconst u8 *font = map->data;\n\tu8 __iomem *fb = (u8 __iomem *)info->screen_base;\n\tint i, c;\n\n\tif ((map->width != 8) || (map->height != 16) ||\n\t    (map->depth != 1) || (map->length != 256)) {\n\t\tfb_err(info, \"unsupported font parameters: width %d, height %d, depth %d, length %d\\n\",\n\t\t       map->width, map->height, map->depth, map->length);\n\t\treturn;\n\t}\n\n\tfb += 2;\n\tfor (c = 0; c < map->length; c++) {\n\t\tfor (i = 0; i < map->height; i++) {\n\t\t\tfb_writeb(font[i], &fb[i * 4]);\n\t\t\tfb_writeb(font[i], &fb[i * 4 + (128 * 8)]);\n\t\t}\n\t\tfb += 128;\n\n\t\tif ((c % 8) == 7)\n\t\t\tfb += 128*8;\n\n\t\tfont += map->height;\n\t}\n}\n\nstatic void arkfb_tilecursor(struct fb_info *info, struct fb_tilecursor *cursor)\n{\n\tstruct arkfb_info *par = info->par;\n\n\tsvga_tilecursor(par->state.vgabase, info, cursor);\n}\n\nstatic struct fb_tile_ops arkfb_tile_ops = {\n\t.fb_settile\t= arkfb_settile,\n\t.fb_tilecopy\t= svga_tilecopy,\n\t.fb_tilefill    = svga_tilefill,\n\t.fb_tileblit    = svga_tileblit,\n\t.fb_tilecursor  = arkfb_tilecursor,\n\t.fb_get_tilemax = svga_get_tilemax,\n};\n\n\n \n\n\n \nstatic inline u32 expand_color(u32 c)\n{\n\treturn ((c & 1) | ((c & 2) << 7) | ((c & 4) << 14) | ((c & 8) << 21)) * 0xFF;\n}\n\n \nstatic void arkfb_iplan_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tu32 fg = expand_color(image->fg_color);\n\tu32 bg = expand_color(image->bg_color);\n\tconst u8 *src1, *src;\n\tu8 __iomem *dst1;\n\tu32 __iomem *dst;\n\tu32 val;\n\tint x, y;\n\n\tsrc1 = image->data;\n\tdst1 = info->screen_base + (image->dy * info->fix.line_length)\n\t\t + ((image->dx / 8) * 4);\n\n\tfor (y = 0; y < image->height; y++) {\n\t\tsrc = src1;\n\t\tdst = (u32 __iomem *) dst1;\n\t\tfor (x = 0; x < image->width; x += 8) {\n\t\t\tval = *(src++) * 0x01010101;\n\t\t\tval = (val & fg) | (~val & bg);\n\t\t\tfb_writel(val, dst++);\n\t\t}\n\t\tsrc1 += image->width / 8;\n\t\tdst1 += info->fix.line_length;\n\t}\n\n}\n\n \nstatic void arkfb_iplan_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tu32 fg = expand_color(rect->color);\n\tu8 __iomem *dst1;\n\tu32 __iomem *dst;\n\tint x, y;\n\n\tdst1 = info->screen_base + (rect->dy * info->fix.line_length)\n\t\t + ((rect->dx / 8) * 4);\n\n\tfor (y = 0; y < rect->height; y++) {\n\t\tdst = (u32 __iomem *) dst1;\n\t\tfor (x = 0; x < rect->width; x += 8) {\n\t\t\tfb_writel(fg, dst++);\n\t\t}\n\t\tdst1 += info->fix.line_length;\n\t}\n\n}\n\n\n \nstatic inline u32 expand_pixel(u32 c)\n{\n\treturn (((c &  1) << 24) | ((c &  2) << 27) | ((c &  4) << 14) | ((c &   8) << 17) |\n\t\t((c & 16) <<  4) | ((c & 32) <<  7) | ((c & 64) >>  6) | ((c & 128) >>  3)) * 0xF;\n}\n\n \nstatic void arkfb_cfb4_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tu32 fg = image->fg_color * 0x11111111;\n\tu32 bg = image->bg_color * 0x11111111;\n\tconst u8 *src1, *src;\n\tu8 __iomem *dst1;\n\tu32 __iomem *dst;\n\tu32 val;\n\tint x, y;\n\n\tsrc1 = image->data;\n\tdst1 = info->screen_base + (image->dy * info->fix.line_length)\n\t\t + ((image->dx / 8) * 4);\n\n\tfor (y = 0; y < image->height; y++) {\n\t\tsrc = src1;\n\t\tdst = (u32 __iomem *) dst1;\n\t\tfor (x = 0; x < image->width; x += 8) {\n\t\t\tval = expand_pixel(*(src++));\n\t\t\tval = (val & fg) | (~val & bg);\n\t\t\tfb_writel(val, dst++);\n\t\t}\n\t\tsrc1 += image->width / 8;\n\t\tdst1 += info->fix.line_length;\n\t}\n\n}\n\nstatic void arkfb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tif ((info->var.bits_per_pixel == 4) && (image->depth == 1)\n\t    && ((image->width % 8) == 0) && ((image->dx % 8) == 0)) {\n\t\tif (info->fix.type == FB_TYPE_INTERLEAVED_PLANES)\n\t\t\tarkfb_iplan_imageblit(info, image);\n\t\telse\n\t\t\tarkfb_cfb4_imageblit(info, image);\n\t} else\n\t\tcfb_imageblit(info, image);\n}\n\nstatic void arkfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tif ((info->var.bits_per_pixel == 4)\n\t    && ((rect->width % 8) == 0) && ((rect->dx % 8) == 0)\n\t    && (info->fix.type == FB_TYPE_INTERLEAVED_PLANES))\n\t\tarkfb_iplan_fillrect(info, rect);\n\t else\n\t\tcfb_fillrect(info, rect);\n}\n\n\n \n\n\nenum\n{\n\tDAC_PSEUDO8_8,\n\tDAC_RGB1555_8,\n\tDAC_RGB0565_8,\n\tDAC_RGB0888_8,\n\tDAC_RGB8888_8,\n\tDAC_PSEUDO8_16,\n\tDAC_RGB1555_16,\n\tDAC_RGB0565_16,\n\tDAC_RGB0888_16,\n\tDAC_RGB8888_16,\n\tDAC_MAX\n};\n\nstruct dac_ops {\n\tint (*dac_get_mode)(struct dac_info *info);\n\tint (*dac_set_mode)(struct dac_info *info, int mode);\n\tint (*dac_get_freq)(struct dac_info *info, int channel);\n\tint (*dac_set_freq)(struct dac_info *info, int channel, u32 freq);\n\tvoid (*dac_release)(struct dac_info *info);\n};\n\ntypedef void (*dac_read_regs_t)(void *data, u8 *code, int count);\ntypedef void (*dac_write_regs_t)(void *data, u8 *code, int count);\n\nstruct dac_info\n{\n\tstruct dac_ops *dacops;\n\tdac_read_regs_t dac_read_regs;\n\tdac_write_regs_t dac_write_regs;\n\tvoid *data;\n};\n\nstatic inline void dac_read_regs(struct dac_info *info, u8 *code, int count)\n{\n\tinfo->dac_read_regs(info->data, code, count);\n}\n\nstatic inline void dac_write_reg(struct dac_info *info, u8 reg, u8 val)\n{\n\tu8 code[2] = {reg, val};\n\tinfo->dac_write_regs(info->data, code, 1);\n}\n\nstatic inline void dac_write_regs(struct dac_info *info, u8 *code, int count)\n{\n\tinfo->dac_write_regs(info->data, code, count);\n}\n\nstatic inline int dac_set_mode(struct dac_info *info, int mode)\n{\n\treturn info->dacops->dac_set_mode(info, mode);\n}\n\nstatic inline int dac_set_freq(struct dac_info *info, int channel, u32 freq)\n{\n\treturn info->dacops->dac_set_freq(info, channel, freq);\n}\n\nstatic inline void dac_release(struct dac_info *info)\n{\n\tinfo->dacops->dac_release(info);\n}\n\n\n \n\n\n \n\nstruct ics5342_info\n{\n\tstruct dac_info dac;\n\tu8 mode;\n};\n\n#define DAC_PAR(info) ((struct ics5342_info *) info)\n\n \nstatic const u8 ics5342_mode_table[DAC_MAX] = {\n\t[DAC_PSEUDO8_8]  = 0x01, [DAC_RGB1555_8]  = 0x21, [DAC_RGB0565_8]  = 0x61,\n\t[DAC_RGB0888_8]  = 0x41, [DAC_PSEUDO8_16] = 0x11, [DAC_RGB1555_16] = 0x31,\n\t[DAC_RGB0565_16] = 0x51, [DAC_RGB0888_16] = 0x91, [DAC_RGB8888_16] = 0x71\n};\n\nstatic int ics5342_set_mode(struct dac_info *info, int mode)\n{\n\tu8 code;\n\n\tif (mode >= DAC_MAX)\n\t\treturn -EINVAL;\n\n\tcode = ics5342_mode_table[mode];\n\n\tif (! code)\n\t\treturn -EINVAL;\n\n\tdac_write_reg(info, 6, code & 0xF0);\n\tDAC_PAR(info)->mode = mode;\n\n\treturn 0;\n}\n\nstatic const struct svga_pll ics5342_pll = {3, 129, 3, 33, 0, 3,\n\t60000, 250000, 14318};\n\n \nstatic const struct svga_pll ics5342_pll_pd4 = {3, 129, 3, 33, 2, 2,\n\t60000, 335000, 14318};\n\n \n\nstatic int ics5342_set_freq(struct dac_info *info, int channel, u32 freq)\n{\n\tu16 m, n, r;\n\n\t \n\tint rv = svga_compute_pll((DAC_PAR(info)->mode == DAC_PSEUDO8_16)\n\t\t\t\t  ? &ics5342_pll_pd4 : &ics5342_pll,\n\t\t\t\t  freq, &m, &n, &r, 0);\n\n\tif (rv < 0) {\n\t\treturn -EINVAL;\n\t} else {\n\t\tu8 code[6] = {4, 3, 5, m-2, 5, (n-2) | (r << 5)};\n\t\tdac_write_regs(info, code, 3);\n\t\treturn 0;\n\t}\n}\n\nstatic void ics5342_release(struct dac_info *info)\n{\n\tics5342_set_mode(info, DAC_PSEUDO8_8);\n\tkfree(info);\n}\n\nstatic struct dac_ops ics5342_ops = {\n\t.dac_set_mode\t= ics5342_set_mode,\n\t.dac_set_freq\t= ics5342_set_freq,\n\t.dac_release\t= ics5342_release\n};\n\n\nstatic struct dac_info * ics5342_init(dac_read_regs_t drr, dac_write_regs_t dwr, void *data)\n{\n\tstruct dac_info *info = kzalloc(sizeof(struct ics5342_info), GFP_KERNEL);\n\n\tif (! info)\n\t\treturn NULL;\n\n\tinfo->dacops = &ics5342_ops;\n\tinfo->dac_read_regs = drr;\n\tinfo->dac_write_regs = dwr;\n\tinfo->data = data;\n\tDAC_PAR(info)->mode = DAC_PSEUDO8_8;  \n\treturn info;\n}\n\n\n \n\n\nstatic unsigned short dac_regs[4] = {0x3c8, 0x3c9, 0x3c6, 0x3c7};\n\nstatic void ark_dac_read_regs(void *data, u8 *code, int count)\n{\n\tstruct fb_info *info = data;\n\tstruct arkfb_info *par;\n\tu8 regval;\n\n\tpar = info->par;\n\tregval = vga_rseq(par->state.vgabase, 0x1C);\n\twhile (count != 0)\n\t{\n\t\tvga_wseq(par->state.vgabase, 0x1C, regval | (code[0] & 4 ? 0x80 : 0));\n\t\tcode[1] = vga_r(par->state.vgabase, dac_regs[code[0] & 3]);\n\t\tcount--;\n\t\tcode += 2;\n\t}\n\n\tvga_wseq(par->state.vgabase, 0x1C, regval);\n}\n\nstatic void ark_dac_write_regs(void *data, u8 *code, int count)\n{\n\tstruct fb_info *info = data;\n\tstruct arkfb_info *par;\n\tu8 regval;\n\n\tpar = info->par;\n\tregval = vga_rseq(par->state.vgabase, 0x1C);\n\twhile (count != 0)\n\t{\n\t\tvga_wseq(par->state.vgabase, 0x1C, regval | (code[0] & 4 ? 0x80 : 0));\n\t\tvga_w(par->state.vgabase, dac_regs[code[0] & 3], code[1]);\n\t\tcount--;\n\t\tcode += 2;\n\t}\n\n\tvga_wseq(par->state.vgabase, 0x1C, regval);\n}\n\n\nstatic void ark_set_pixclock(struct fb_info *info, u32 pixclock)\n{\n\tstruct arkfb_info *par = info->par;\n\tu8 regval;\n\n\tint rv = dac_set_freq(par->dac, 0, 1000000000 / pixclock);\n\tif (rv < 0) {\n\t\tfb_err(info, \"cannot set requested pixclock, keeping old value\\n\");\n\t\treturn;\n\t}\n\n\t \n\tregval = vga_r(par->state.vgabase, VGA_MIS_R);\n\tvga_w(par->state.vgabase, VGA_MIS_W, regval | VGA_MIS_ENB_PLL_LOAD);\n}\n\n\n \n\nstatic int arkfb_open(struct fb_info *info, int user)\n{\n\tstruct arkfb_info *par = info->par;\n\n\tmutex_lock(&(par->open_lock));\n\tif (par->ref_count == 0) {\n\t\tvoid __iomem *vgabase = par->state.vgabase;\n\n\t\tmemset(&(par->state), 0, sizeof(struct vgastate));\n\t\tpar->state.vgabase = vgabase;\n\t\tpar->state.flags = VGA_SAVE_MODE | VGA_SAVE_FONTS | VGA_SAVE_CMAP;\n\t\tpar->state.num_crtc = 0x60;\n\t\tpar->state.num_seq = 0x30;\n\t\tsave_vga(&(par->state));\n\t}\n\n\tpar->ref_count++;\n\tmutex_unlock(&(par->open_lock));\n\n\treturn 0;\n}\n\n \n\nstatic int arkfb_release(struct fb_info *info, int user)\n{\n\tstruct arkfb_info *par = info->par;\n\n\tmutex_lock(&(par->open_lock));\n\tif (par->ref_count == 0) {\n\t\tmutex_unlock(&(par->open_lock));\n\t\treturn -EINVAL;\n\t}\n\n\tif (par->ref_count == 1) {\n\t\trestore_vga(&(par->state));\n\t\tdac_set_mode(par->dac, DAC_PSEUDO8_8);\n\t}\n\n\tpar->ref_count--;\n\tmutex_unlock(&(par->open_lock));\n\n\treturn 0;\n}\n\n \n\nstatic int arkfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tint rv, mem, step;\n\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\t \n\trv = svga_match_format (arkfb_formats, var, NULL);\n\tif (rv < 0)\n\t{\n\t\tfb_err(info, \"unsupported mode requested\\n\");\n\t\treturn rv;\n\t}\n\n\t \n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\n\t \n\tstep = arkfb_formats[rv].xresstep - 1;\n\tvar->xres_virtual = (var->xres_virtual+step) & ~step;\n\n\n\t \n\tmem = ((var->bits_per_pixel * var->xres_virtual) >> 3) * var->yres_virtual;\n\tif (mem > info->screen_size)\n\t{\n\t\tfb_err(info, \"not enough framebuffer memory (%d kB requested, %d kB available)\\n\",\n\t\t       mem >> 10, (unsigned int) (info->screen_size >> 10));\n\t\treturn -EINVAL;\n\t}\n\n\trv = svga_check_timings (&ark_timing_regs, var, info->node);\n\tif (rv < 0)\n\t{\n\t\tfb_err(info, \"invalid timings requested\\n\");\n\t\treturn rv;\n\t}\n\n\t \n\tif (var->vmode & FB_VMODE_INTERLACED)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \n\nstatic int arkfb_set_par(struct fb_info *info)\n{\n\tstruct arkfb_info *par = info->par;\n\tu32 value, mode, hmul, hdiv, offset_value, screen_size;\n\tu32 bpp = info->var.bits_per_pixel;\n\tu8 regval;\n\n\tif (bpp != 0) {\n\t\tinfo->fix.ypanstep = 1;\n\t\tinfo->fix.line_length = (info->var.xres_virtual * bpp) / 8;\n\n\t\tinfo->flags &= ~FBINFO_MISC_TILEBLITTING;\n\t\tinfo->tileops = NULL;\n\n\t\t \n\t\tinfo->pixmap.blit_x = (bpp == 4) ? (1 << (8 - 1)) : (~(u32)0);\n\t\tinfo->pixmap.blit_y = ~(u32)0;\n\n\t\toffset_value = (info->var.xres_virtual * bpp) / 64;\n\t\tscreen_size = info->var.yres_virtual * info->fix.line_length;\n\t} else {\n\t\tinfo->fix.ypanstep = 16;\n\t\tinfo->fix.line_length = 0;\n\n\t\tinfo->flags |= FBINFO_MISC_TILEBLITTING;\n\t\tinfo->tileops = &arkfb_tile_ops;\n\n\t\t \n\t\tinfo->pixmap.blit_x = 1 << (8 - 1);\n\t\tinfo->pixmap.blit_y = 1 << (16 - 1);\n\n\t\toffset_value = info->var.xres_virtual / 16;\n\t\tscreen_size = (info->var.xres_virtual * info->var.yres_virtual) / 64;\n\t}\n\n\tinfo->var.xoffset = 0;\n\tinfo->var.yoffset = 0;\n\tinfo->var.activate = FB_ACTIVATE_NOW;\n\n\t \n\tsvga_wcrt_mask(par->state.vgabase, 0x11, 0x00, 0x80);\n\n\t \n\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\tsvga_wcrt_mask(par->state.vgabase, 0x17, 0x00, 0x80);\n\n\t \n\tsvga_set_default_gfx_regs(par->state.vgabase);\n\tsvga_set_default_atc_regs(par->state.vgabase);\n\tsvga_set_default_seq_regs(par->state.vgabase);\n\tsvga_set_default_crt_regs(par->state.vgabase);\n\tsvga_wcrt_multi(par->state.vgabase, ark_line_compare_regs, 0xFFFFFFFF);\n\tsvga_wcrt_multi(par->state.vgabase, ark_start_address_regs, 0);\n\n\t \n\tsvga_wseq_mask(par->state.vgabase, 0x10, 0x1F, 0x1F);  \n\tsvga_wseq_mask(par->state.vgabase, 0x12, 0x03, 0x03);  \n\n\tvga_wseq(par->state.vgabase, 0x13, info->fix.smem_start >> 16);\n\tvga_wseq(par->state.vgabase, 0x14, info->fix.smem_start >> 24);\n\tvga_wseq(par->state.vgabase, 0x15, 0);\n\tvga_wseq(par->state.vgabase, 0x16, 0);\n\n\t \n\t \n\tregval = 0x10 | ((threshold & 0x0E) >> 1) | (threshold & 0x01) << 7 | (threshold & 0x10) << 1;\n\tvga_wseq(par->state.vgabase, 0x18, regval);\n\n\t \n\tfb_dbg(info, \"offset register       : %d\\n\", offset_value);\n\tsvga_wcrt_multi(par->state.vgabase, ark_offset_regs, offset_value);\n\n\t \n\tsvga_wcrt_mask(par->state.vgabase, 0x40, 0x08, 0x08);\n\n\tif (info->var.vmode & FB_VMODE_DOUBLE)\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x09, 0x80, 0x80);\n\telse\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x09, 0x00, 0x80);\n\n\tif (info->var.vmode & FB_VMODE_INTERLACED)\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x44, 0x04, 0x04);\n\telse\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x44, 0x00, 0x04);\n\n\thmul = 1;\n\thdiv = 1;\n\tmode = svga_match_format(arkfb_formats, &(info->var), &(info->fix));\n\n\t \n\tswitch (mode) {\n\tcase 0:\n\t\tfb_dbg(info, \"text mode\\n\");\n\t\tsvga_set_textmode_vga_regs(par->state.vgabase);\n\n\t\tvga_wseq(par->state.vgabase, 0x11, 0x10);  \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x46, 0x00, 0x04);  \n\t\tdac_set_mode(par->dac, DAC_PSEUDO8_8);\n\n\t\tbreak;\n\tcase 1:\n\t\tfb_dbg(info, \"4 bit pseudocolor\\n\");\n\t\tvga_wgfx(par->state.vgabase, VGA_GFX_MODE, 0x40);\n\n\t\tvga_wseq(par->state.vgabase, 0x11, 0x10);  \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x46, 0x00, 0x04);  \n\t\tdac_set_mode(par->dac, DAC_PSEUDO8_8);\n\t\tbreak;\n\tcase 2:\n\t\tfb_dbg(info, \"4 bit pseudocolor, planar\\n\");\n\n\t\tvga_wseq(par->state.vgabase, 0x11, 0x10);  \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x46, 0x00, 0x04);  \n\t\tdac_set_mode(par->dac, DAC_PSEUDO8_8);\n\t\tbreak;\n\tcase 3:\n\t\tfb_dbg(info, \"8 bit pseudocolor\\n\");\n\n\t\tvga_wseq(par->state.vgabase, 0x11, 0x16);  \n\n\t\tif (info->var.pixclock > 20000) {\n\t\t\tfb_dbg(info, \"not using multiplex\\n\");\n\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x46, 0x00, 0x04);  \n\t\t\tdac_set_mode(par->dac, DAC_PSEUDO8_8);\n\t\t} else {\n\t\t\tfb_dbg(info, \"using multiplex\\n\");\n\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x46, 0x04, 0x04);  \n\t\t\tdac_set_mode(par->dac, DAC_PSEUDO8_16);\n\t\t\thdiv = 2;\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tfb_dbg(info, \"5/5/5 truecolor\\n\");\n\n\t\tvga_wseq(par->state.vgabase, 0x11, 0x1A);  \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x46, 0x04, 0x04);  \n\t\tdac_set_mode(par->dac, DAC_RGB1555_16);\n\t\tbreak;\n\tcase 5:\n\t\tfb_dbg(info, \"5/6/5 truecolor\\n\");\n\n\t\tvga_wseq(par->state.vgabase, 0x11, 0x1A);  \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x46, 0x04, 0x04);  \n\t\tdac_set_mode(par->dac, DAC_RGB0565_16);\n\t\tbreak;\n\tcase 6:\n\t\tfb_dbg(info, \"8/8/8 truecolor\\n\");\n\n\t\tvga_wseq(par->state.vgabase, 0x11, 0x16);  \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x46, 0x04, 0x04);  \n\t\tdac_set_mode(par->dac, DAC_RGB0888_16);\n\t\thmul = 3;\n\t\thdiv = 2;\n\t\tbreak;\n\tcase 7:\n\t\tfb_dbg(info, \"8/8/8/8 truecolor\\n\");\n\n\t\tvga_wseq(par->state.vgabase, 0x11, 0x1E);  \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x46, 0x04, 0x04);  \n\t\tdac_set_mode(par->dac, DAC_RGB8888_16);\n\t\thmul = 2;\n\t\tbreak;\n\tdefault:\n\t\tfb_err(info, \"unsupported mode - bug\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvalue = (hdiv * info->var.pixclock) / hmul;\n\tif (!value) {\n\t\tfb_dbg(info, \"invalid pixclock\\n\");\n\t\tvalue = 1;\n\t}\n\tark_set_pixclock(info, value);\n\tsvga_set_timings(par->state.vgabase, &ark_timing_regs, &(info->var), hmul, hdiv,\n\t\t\t (info->var.vmode & FB_VMODE_DOUBLE)     ? 2 : 1,\n\t\t\t (info->var.vmode & FB_VMODE_INTERLACED) ? 2 : 1,\n\t\t\t  hmul, info->node);\n\n\t \n\tvalue = info->var.xres + info->var.left_margin + info->var.right_margin + info->var.hsync_len;\n\tvalue = ((value * hmul / hdiv) / 8) - 5;\n\tvga_wcrt(par->state.vgabase, 0x42, (value + 1) / 2);\n\n\tif (screen_size > info->screen_size)\n\t\tscreen_size = info->screen_size;\n\tmemset_io(info->screen_base, 0x00, screen_size);\n\t \n\tsvga_wcrt_mask(par->state.vgabase, 0x17, 0x80, 0x80);\n\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x00, 0x20);\n\n\treturn 0;\n}\n\n \n\nstatic int arkfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t\tu_int transp, struct fb_info *fb)\n{\n\tswitch (fb->var.bits_per_pixel) {\n\tcase 0:\n\tcase 4:\n\t\tif (regno >= 16)\n\t\t\treturn -EINVAL;\n\n\t\tif ((fb->var.bits_per_pixel == 4) &&\n\t\t    (fb->var.nonstd == 0)) {\n\t\t\toutb(0xF0, VGA_PEL_MSK);\n\t\t\toutb(regno*16, VGA_PEL_IW);\n\t\t} else {\n\t\t\toutb(0x0F, VGA_PEL_MSK);\n\t\t\toutb(regno, VGA_PEL_IW);\n\t\t}\n\t\toutb(red >> 10, VGA_PEL_D);\n\t\toutb(green >> 10, VGA_PEL_D);\n\t\toutb(blue >> 10, VGA_PEL_D);\n\t\tbreak;\n\tcase 8:\n\t\tif (regno >= 256)\n\t\t\treturn -EINVAL;\n\n\t\toutb(0xFF, VGA_PEL_MSK);\n\t\toutb(regno, VGA_PEL_IW);\n\t\toutb(red >> 10, VGA_PEL_D);\n\t\toutb(green >> 10, VGA_PEL_D);\n\t\toutb(blue >> 10, VGA_PEL_D);\n\t\tbreak;\n\tcase 16:\n\t\tif (regno >= 16)\n\t\t\treturn 0;\n\n\t\tif (fb->var.green.length == 5)\n\t\t\t((u32*)fb->pseudo_palette)[regno] = ((red & 0xF800) >> 1) |\n\t\t\t\t((green & 0xF800) >> 6) | ((blue & 0xF800) >> 11);\n\t\telse if (fb->var.green.length == 6)\n\t\t\t((u32*)fb->pseudo_palette)[regno] = (red & 0xF800) |\n\t\t\t\t((green & 0xFC00) >> 5) | ((blue & 0xF800) >> 11);\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tif (regno >= 16)\n\t\t\treturn 0;\n\n\t\t((u32*)fb->pseudo_palette)[regno] = ((red & 0xFF00) << 8) |\n\t\t\t(green & 0xFF00) | ((blue & 0xFF00) >> 8);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int arkfb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct arkfb_info *par = info->par;\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\tfb_dbg(info, \"unblank\\n\");\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x00, 0x20);\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x17, 0x80, 0x80);\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\tfb_dbg(info, \"blank\\n\");\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x17, 0x80, 0x80);\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tfb_dbg(info, \"sync down\\n\");\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x17, 0x00, 0x80);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\n \n\nstatic int arkfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct arkfb_info *par = info->par;\n\tunsigned int offset;\n\n\t \n\tif (info->var.bits_per_pixel == 0) {\n\t\toffset = (var->yoffset / 16) * (info->var.xres_virtual / 2)\n\t\t       + (var->xoffset / 2);\n\t\toffset = offset >> 2;\n\t} else {\n\t\toffset = (var->yoffset * info->fix.line_length) +\n\t\t\t (var->xoffset * info->var.bits_per_pixel / 8);\n\t\toffset = offset >> ((info->var.bits_per_pixel == 4) ? 2 : 3);\n\t}\n\n\t \n\tsvga_wcrt_multi(par->state.vgabase, ark_start_address_regs, offset);\n\n\treturn 0;\n}\n\n\n \n\n\n \n\nstatic const struct fb_ops arkfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= arkfb_open,\n\t.fb_release\t= arkfb_release,\n\t.fb_check_var\t= arkfb_check_var,\n\t.fb_set_par\t= arkfb_set_par,\n\t.fb_setcolreg\t= arkfb_setcolreg,\n\t.fb_blank\t= arkfb_blank,\n\t.fb_pan_display\t= arkfb_pan_display,\n\t.fb_fillrect\t= arkfb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= arkfb_imageblit,\n\t.fb_get_caps    = svga_get_caps,\n};\n\n\n \n\n\n \nstatic int ark_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct pci_bus_region bus_reg;\n\tstruct resource vga_res;\n\tstruct fb_info *info;\n\tstruct arkfb_info *par;\n\tint rc;\n\tu8 regval;\n\n\trc = aperture_remove_conflicting_pci_devices(dev, \"arkfb\");\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (! svga_primary_device(dev)) {\n\t\tdev_info(&(dev->dev), \"ignoring secondary device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tinfo = framebuffer_alloc(sizeof(struct arkfb_info), &(dev->dev));\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tmutex_init(&par->open_lock);\n\n\tinfo->flags = FBINFO_PARTIAL_PAN_OK | FBINFO_HWACCEL_YPAN;\n\tinfo->fbops = &arkfb_ops;\n\n\t \n\trc = pci_enable_device(dev);\n\tif (rc < 0) {\n\t\tdev_err(info->device, \"cannot enable PCI device\\n\");\n\t\tgoto err_enable_device;\n\t}\n\n\trc = pci_request_regions(dev, \"arkfb\");\n\tif (rc < 0) {\n\t\tdev_err(info->device, \"cannot reserve framebuffer region\\n\");\n\t\tgoto err_request_regions;\n\t}\n\n\tpar->dac = ics5342_init(ark_dac_read_regs, ark_dac_write_regs, info);\n\tif (! par->dac) {\n\t\trc = -ENOMEM;\n\t\tdev_err(info->device, \"RAMDAC initialization failed\\n\");\n\t\tgoto err_dac;\n\t}\n\n\tinfo->fix.smem_start = pci_resource_start(dev, 0);\n\tinfo->fix.smem_len = pci_resource_len(dev, 0);\n\n\t \n\tinfo->screen_base = pci_iomap_wc(dev, 0, 0);\n\tif (! info->screen_base) {\n\t\trc = -ENOMEM;\n\t\tdev_err(info->device, \"iomap for framebuffer failed\\n\");\n\t\tgoto err_iomap;\n\t}\n\n\tbus_reg.start = 0;\n\tbus_reg.end = 64 * 1024;\n\n\tvga_res.flags = IORESOURCE_IO;\n\n\tpcibios_bus_to_resource(dev->bus, &vga_res, &bus_reg);\n\n\tpar->state.vgabase = (void __iomem *) (unsigned long) vga_res.start;\n\n\t \n\tregval = vga_rseq(par->state.vgabase, 0x10);\n\tinfo->screen_size = (1 << (regval >> 6)) << 20;\n\tinfo->fix.smem_len = info->screen_size;\n\n\tstrcpy(info->fix.id, \"ARK 2000PV\");\n\tinfo->fix.mmio_start = 0;\n\tinfo->fix.mmio_len = 0;\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\tinfo->fix.ypanstep = 0;\n\tinfo->fix.accel = FB_ACCEL_NONE;\n\tinfo->pseudo_palette = (void*) (par->pseudo_palette);\n\n\t \n\trc = fb_find_mode(&(info->var), info, mode_option, NULL, 0, NULL, 8);\n\tif (! ((rc == 1) || (rc == 2))) {\n\t\trc = -EINVAL;\n\t\tdev_err(info->device, \"mode %s not found\\n\", mode_option);\n\t\tgoto err_find_mode;\n\t}\n\n\trc = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (rc < 0) {\n\t\tdev_err(info->device, \"cannot allocate colormap\\n\");\n\t\tgoto err_alloc_cmap;\n\t}\n\n\trc = register_framebuffer(info);\n\tif (rc < 0) {\n\t\tdev_err(info->device, \"cannot register framebuffer\\n\");\n\t\tgoto err_reg_fb;\n\t}\n\n\tfb_info(info, \"%s on %s, %d MB RAM\\n\",\n\t\tinfo->fix.id, pci_name(dev), info->fix.smem_len >> 20);\n\n\t \n\tpci_set_drvdata(dev, info);\n\tpar->wc_cookie = arch_phys_wc_add(info->fix.smem_start,\n\t\t\t\t\t  info->fix.smem_len);\n\treturn 0;\n\n\t \nerr_reg_fb:\n\tfb_dealloc_cmap(&info->cmap);\nerr_alloc_cmap:\nerr_find_mode:\n\tpci_iounmap(dev, info->screen_base);\nerr_iomap:\n\tdac_release(par->dac);\nerr_dac:\n\tpci_release_regions(dev);\nerr_request_regions:\n \nerr_enable_device:\n\tframebuffer_release(info);\n\treturn rc;\n}\n\n \n\nstatic void ark_pci_remove(struct pci_dev *dev)\n{\n\tstruct fb_info *info = pci_get_drvdata(dev);\n\n\tif (info) {\n\t\tstruct arkfb_info *par = info->par;\n\t\tarch_phys_wc_del(par->wc_cookie);\n\t\tdac_release(par->dac);\n\t\tunregister_framebuffer(info);\n\t\tfb_dealloc_cmap(&info->cmap);\n\n\t\tpci_iounmap(dev, info->screen_base);\n\t\tpci_release_regions(dev);\n \n\n\t\tframebuffer_release(info);\n\t}\n}\n\n\n \n\nstatic int __maybe_unused ark_pci_suspend(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct arkfb_info *par = info->par;\n\n\tdev_info(info->device, \"suspend\\n\");\n\n\tconsole_lock();\n\tmutex_lock(&(par->open_lock));\n\n\tif (par->ref_count == 0) {\n\t\tmutex_unlock(&(par->open_lock));\n\t\tconsole_unlock();\n\t\treturn 0;\n\t}\n\n\tfb_set_suspend(info, 1);\n\n\tmutex_unlock(&(par->open_lock));\n\tconsole_unlock();\n\n\treturn 0;\n}\n\n\n \n\nstatic int __maybe_unused ark_pci_resume(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct arkfb_info *par = info->par;\n\n\tdev_info(info->device, \"resume\\n\");\n\n\tconsole_lock();\n\tmutex_lock(&(par->open_lock));\n\n\tif (par->ref_count == 0)\n\t\tgoto fail;\n\n\tarkfb_set_par(info);\n\tfb_set_suspend(info, 0);\n\nfail:\n\tmutex_unlock(&(par->open_lock));\n\tconsole_unlock();\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ark_pci_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ark_pci_suspend,\n\t.resume\t\t= ark_pci_resume,\n\t.freeze\t\t= NULL,\n\t.thaw\t\t= ark_pci_resume,\n\t.poweroff\t= ark_pci_suspend,\n\t.restore\t= ark_pci_resume,\n#endif\n};\n\n \n\nstatic const struct pci_device_id ark_devices[] = {\n\t{PCI_DEVICE(0xEDD8, 0xA099)},\n\t{0, 0, 0, 0, 0, 0, 0}\n};\n\n\nMODULE_DEVICE_TABLE(pci, ark_devices);\n\nstatic struct pci_driver arkfb_pci_driver = {\n\t.name\t\t= \"arkfb\",\n\t.id_table\t= ark_devices,\n\t.probe\t\t= ark_pci_probe,\n\t.remove\t\t= ark_pci_remove,\n\t.driver.pm\t= &ark_pci_pm_ops,\n};\n\n \n\nstatic void __exit arkfb_cleanup(void)\n{\n\tpr_debug(\"arkfb: cleaning up\\n\");\n\tpci_unregister_driver(&arkfb_pci_driver);\n}\n\n \n\nstatic int __init arkfb_init(void)\n{\n\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"arkfb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"arkfb\", &option))\n\t\treturn -ENODEV;\n\n\tif (option && *option)\n\t\tmode_option = option;\n#endif\n\n\tpr_debug(\"arkfb: initializing\\n\");\n\treturn pci_register_driver(&arkfb_pci_driver);\n}\n\nmodule_init(arkfb_init);\nmodule_exit(arkfb_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}