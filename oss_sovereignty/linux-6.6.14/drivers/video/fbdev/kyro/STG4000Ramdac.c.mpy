{
  "module_name": "STG4000Ramdac.c",
  "hash_id": "46a0052b0ff0ba83572e13b74d343d2da42d02b2cc271039b8592b4320c140ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/kyro/STG4000Ramdac.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <video/kyro.h>\n\n#include \"STG4000Reg.h\"\n#include \"STG4000Interface.h\"\n\nstatic u32 STG_PIXEL_BUS_WIDTH = 128;\t \nstatic u32 REF_CLOCK = 14318;\n\nint InitialiseRamdac(volatile STG4000REG __iomem * pSTGReg,\n\t\t     u32 displayDepth,\n\t\t     u32 displayWidth,\n\t\t     u32 displayHeight,\n\t\t     s32 HSyncPolarity,\n\t\t     s32 VSyncPolarity, u32 * pixelClock)\n{\n\tu32 tmp = 0;\n\tu32 F = 0, R = 0, P = 0;\n\tu32 stride = 0;\n\tu32 ulPdiv = 0;\n\tu32 physicalPixelDepth = 0;\n\t \n\ttmp = STG_READ_REG(SoftwareReset);\n\n\tif (tmp & 0x1) {\n\t\tCLEAR_BIT(1);\n\t\tSTG_WRITE_REG(SoftwareReset, tmp);\n\t}\n\n\t \n\ttmp = STG_READ_REG(DACPixelFormat);\n\tCLEAR_BITS_FRM_TO(0, 2);\n\n\t \n\tCLEAR_BITS_FRM_TO(8, 9);\n\n\tswitch (displayDepth) {\n\tcase 16:\n\t\t{\n\t\t\tphysicalPixelDepth = 16;\n\t\t\ttmp |= _16BPP;\n\t\t\tbreak;\n\t\t}\n\tcase 32:\n\t\t{\n\t\t\t \n\t\t\tphysicalPixelDepth = 32;\n\t\t\ttmp |= _32BPP;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tSTG_WRITE_REG(DACPixelFormat, tmp);\n\n\t \n\tulPdiv = STG_PIXEL_BUS_WIDTH / physicalPixelDepth;\n\n\t \n\tstride = displayWidth;\n\n\t \n\ttmp = STG_READ_REG(DACPrimSize);\n\tCLEAR_BITS_FRM_TO(0, 10);\n\tCLEAR_BITS_FRM_TO(12, 31);\n\ttmp |=\n\t    ((((displayHeight - 1) << 12) | (((displayWidth / ulPdiv) -\n\t\t\t\t\t      1) << 23))\n\t     | (stride / ulPdiv));\n\tSTG_WRITE_REG(DACPrimSize, tmp);\n\n\n\t \n\t*pixelClock = ProgramClock(REF_CLOCK, *pixelClock, &F, &R, &P);\n\n\t \n\ttmp = STG_READ_REG(DACPLLMode);\n\tCLEAR_BITS_FRM_TO(0, 15);\n\t \n\ttmp |= ((P) | ((F - 2) << 2) | ((R - 2) << 11));\n\tSTG_WRITE_REG(DACPLLMode, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACPrimAddress);\n\tCLEAR_BITS_FRM_TO(0, 20);\n\tCLEAR_BITS_FRM_TO(20, 31);\n\tSTG_WRITE_REG(DACPrimAddress, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACCursorCtrl);\n\ttmp &= ~SET_BIT(31);\n\tSTG_WRITE_REG(DACCursorCtrl, tmp);\n\n\ttmp = STG_READ_REG(DACCursorAddr);\n\tCLEAR_BITS_FRM_TO(0, 20);\n\tSTG_WRITE_REG(DACCursorAddr, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACVidWinStart);\n\tCLEAR_BITS_FRM_TO(0, 10);\n\tCLEAR_BITS_FRM_TO(16, 26);\n\tSTG_WRITE_REG(DACVidWinStart, tmp);\n\n\ttmp = STG_READ_REG(DACVidWinEnd);\n\tCLEAR_BITS_FRM_TO(0, 10);\n\tCLEAR_BITS_FRM_TO(16, 26);\n\tSTG_WRITE_REG(DACVidWinEnd, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACBorderColor);\n\tCLEAR_BITS_FRM_TO(0, 23);\n\tSTG_WRITE_REG(DACBorderColor, tmp);\n\n\t \n\tSTG_WRITE_REG(DACBurstCtrl, 0x0404);\n\n\t \n\ttmp = STG_READ_REG(DACCrcTrigger);\n\tCLEAR_BIT(0);\n\tSTG_WRITE_REG(DACCrcTrigger, tmp);\n\n\t \n\ttmp = STG_READ_REG(DigVidPortCtrl);\n\tCLEAR_BIT(8);\n\tCLEAR_BITS_FRM_TO(16, 27);\n\tCLEAR_BITS_FRM_TO(1, 3);\n\tCLEAR_BITS_FRM_TO(10, 11);\n\tSTG_WRITE_REG(DigVidPortCtrl, tmp);\n\n\treturn 0;\n}\n\n \nvoid DisableRamdacOutput(volatile STG4000REG __iomem * pSTGReg)\n{\n\tu32 tmp;\n\n\t \n\ttmp = (STG_READ_REG(DACStreamCtrl)) & ~SET_BIT(0);\n\tSTG_WRITE_REG(DACStreamCtrl, tmp);\n}\n\nvoid EnableRamdacOutput(volatile STG4000REG __iomem * pSTGReg)\n{\n\tu32 tmp;\n\n\t \n\ttmp = (STG_READ_REG(DACStreamCtrl)) | SET_BIT(0);\n\tSTG_WRITE_REG(DACStreamCtrl, tmp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}