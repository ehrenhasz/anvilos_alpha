{
  "module_name": "STG4000InitDevice.c",
  "hash_id": "558e701d2b4d92e1fcafbc06e9c82febf0bfbd289f9d9404c675e894cf1d2655",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/kyro/STG4000InitDevice.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n\n#include \"STG4000Reg.h\"\n#include \"STG4000Interface.h\"\n\n \n#define SDRAM_CFG_0   0x49A1\n#define SDRAM_CFG_1   0xA732\n#define SDRAM_CFG_2   0x31\n#define SDRAM_ARB_CFG 0xA0\n#define SDRAM_REFRESH 0x20\n\n \n#define PMX2_SOFTRESET_DAC_RST\t\t0x0001\n#define PMX2_SOFTRESET_C1_RST\t\t0x0004\n#define PMX2_SOFTRESET_C2_RST\t\t0x0008\n#define PMX2_SOFTRESET_3D_RST\t\t0x0010\n#define PMX2_SOFTRESET_VIDIN_RST\t0x0020\n#define PMX2_SOFTRESET_TLB_RST\t\t0x0040\n#define PMX2_SOFTRESET_SD_RST\t\t0x0080\n#define PMX2_SOFTRESET_VGA_RST\t\t0x0100\n#define PMX2_SOFTRESET_ROM_RST\t\t0x0200\t \n#define PMX2_SOFTRESET_TA_RST\t\t0x0400\n#define PMX2_SOFTRESET_REG_RST\t\t0x4000\n#define PMX2_SOFTRESET_ALL\t\t0x7fff\n\n \n#define CORE_PLL_FREQ 1000000\n\n \n#define REF_FREQ 14318\n\n \nstatic u16 CorePllControl = 0x70;\n\n#define\tPCI_CONFIG_SUBSYS_ID\t0x2e\n\n \n#define CORE_PLL_MODE_REG_0_7      3\n#define CORE_PLL_MODE_REG_8_15     2\n#define CORE_PLL_MODE_CONFIG_REG   1\n#define DAC_PLL_CONFIG_REG         0\n\n#define STG_MAX_VCO 500000\n#define STG_MIN_VCO 100000\n\n \n#define    STG4K3_PLL_SCALER      8\t \n#define    STG4K3_PLL_MIN_R       2\t \n#define    STG4K3_PLL_MAX_R       33\t \n#define    STG4K3_PLL_MIN_F       2\t \n#define    STG4K3_PLL_MAX_F       513\t \n#define    STG4K3_PLL_MIN_OD      0\t \n#define    STG4K3_PLL_MAX_OD      2\t \n#define    STG4K3_PLL_MIN_VCO_SC  (100000000 >> STG4K3_PLL_SCALER)\t \n#define    STG4K3_PLL_MAX_VCO_SC  (500000000 >> STG4K3_PLL_SCALER)\t \n#define    STG4K3_PLL_MINR_VCO_SC (100000000 >> STG4K3_PLL_SCALER)\t \n#define    STG4K3_PLL_MAXR_VCO_SC (500000000 >> STG4K3_PLL_SCALER)\t \n#define    STG4K3_PLL_MINR_VCO    100000000\t \n#define    STG4K3_PLL_MAX_VCO     500000000\t \n#define    STG4K3_PLL_MAXR_VCO    500000000\t \n\n#define OS_DELAY(X) \\\n{ \\\nvolatile u32 i,count=0; \\\n    for(i=0;i<X;i++) count++; \\\n}\n\nstatic u32 InitSDRAMRegisters(volatile STG4000REG __iomem *pSTGReg,\n\t\t\t      u32 dwSubSysID, u32 dwRevID)\n{\n\tstatic const u8 adwSDRAMArgCfg0[] = { 0xa0, 0x80, 0xa0, 0xa0, 0xa0 };\n\tstatic const u16 adwSDRAMCfg1[] = { 0x8732, 0x8732, 0xa732, 0xa732, 0x8732 };\n\tstatic const u16 adwSDRAMCfg2[] = { 0x87d2, 0x87d2, 0xa7d2, 0x87d2, 0xa7d2 };\n\tstatic const u8 adwSDRAMRsh[] = { 36, 39, 40 };\n\tstatic const u8 adwChipSpeed[] = { 110, 120, 125 };\n\tu32 dwMemTypeIdx;\n\tu32 dwChipSpeedIdx;\n\n\t \n\tdwMemTypeIdx = (dwSubSysID & 0x70) >> 4;\n\tdwChipSpeedIdx = (dwSubSysID & 0x180) >> 7;\n\n\tif (dwMemTypeIdx > 4 || dwChipSpeedIdx > 2)\n\t\treturn 0;\n\n\t \n\tSTG_WRITE_REG(SDRAMArbiterConf, adwSDRAMArgCfg0[dwMemTypeIdx]);\n\tif (dwRevID < 5) {\n\t\tSTG_WRITE_REG(SDRAMConf0, 0x49A1);\n\t\tSTG_WRITE_REG(SDRAMConf1, adwSDRAMCfg1[dwMemTypeIdx]);\n\t} else {\n\t\tSTG_WRITE_REG(SDRAMConf0, 0x4DF1);\n\t\tSTG_WRITE_REG(SDRAMConf1, adwSDRAMCfg2[dwMemTypeIdx]);\n\t}\n\n\tSTG_WRITE_REG(SDRAMConf2, 0x31);\n\tSTG_WRITE_REG(SDRAMRefresh, adwSDRAMRsh[dwChipSpeedIdx]);\n\n\treturn adwChipSpeed[dwChipSpeedIdx] * 10000;\n}\n\nu32 ProgramClock(u32 refClock,\n\t\t   u32 coreClock,\n\t\t   u32 * FOut, u32 * ROut, u32 * POut)\n{\n\tu32 R = 0, F = 0, OD = 0, ODIndex = 0;\n\tu32 ulBestR = 0, ulBestF = 0, ulBestOD = 0;\n\tu32 ulBestClk = 0, ulBestScore = 0;\n\tu32 ulScore, ulPhaseScore, ulVcoScore;\n\tu32 ulTmp = 0, ulVCO;\n\tu32 ulScaleClockReq, ulMinClock, ulMaxClock;\n\tstatic const unsigned char ODValues[] = { 1, 2, 0 };\n\n\t \n\tcoreClock *= 100;\t \n\trefClock *= 1000;\t \n\n\t \n\tulMinClock = coreClock - (coreClock >> 8);\n\tulMaxClock = coreClock + (coreClock >> 8);\n\n\t \n\tulScaleClockReq = coreClock >> STG4K3_PLL_SCALER;\n\n\t \n\tfor (ODIndex = 0; ODIndex < 3; ODIndex++) {\n\t\tOD = ODValues[ODIndex];\n\t\tR = STG4K3_PLL_MIN_R;\n\n\t\t \n\t\twhile (R <= STG4K3_PLL_MAX_R) {\n\t\t\t \n\t\t\tulTmp = R * (ulScaleClockReq << OD);\n\n\t\t\t \n\t\t\tF = (u32)(ulTmp / (refClock >> STG4K3_PLL_SCALER));\n\n\t\t\t \n\t\t\tif (F > STG4K3_PLL_MIN_F)\n\t\t\t\tF--;\n\n\n\t\t\t \n\t\t\twhile ((F >= STG4K3_PLL_MIN_F) &&\n\t\t\t       (F <= STG4K3_PLL_MAX_F)) {\n\t\t\t\t \n\t\t\t\tulVCO = refClock / R;\n\t\t\t\tulVCO = F * ulVCO;\n\n\t\t\t\t \n\t\t\t\tif ((ulVCO >= STG4K3_PLL_MINR_VCO) &&\n\t\t\t\t    ((ulVCO <= STG4K3_PLL_MAXR_VCO) ||\n\t\t\t\t     ((coreClock > STG4K3_PLL_MAXR_VCO)\n\t\t\t\t      && (ulVCO <= STG4K3_PLL_MAX_VCO)))) {\n\t\t\t\t\tulTmp = (ulVCO >> OD);\t \n\n\t\t\t\t\t \n\t\t\t\t\tif ((ulTmp >= ulMinClock)\n\t\t\t\t\t    && (ulTmp <= ulMaxClock)) {\n\t\t\t\t\t\tulPhaseScore = (((refClock / R) - (refClock / STG4K3_PLL_MAX_R))) / ((refClock - (refClock / STG4K3_PLL_MAX_R)) >> 10);\n\n\t\t\t\t\t\tulVcoScore = ((ulVCO - STG4K3_PLL_MINR_VCO)) / ((STG4K3_PLL_MAXR_VCO - STG4K3_PLL_MINR_VCO) >> 10);\n\t\t\t\t\t\tulScore = ulPhaseScore + ulVcoScore;\n\n\t\t\t\t\t\tif (!ulBestScore) {\n\t\t\t\t\t\t\tulBestOD = OD;\n\t\t\t\t\t\t\tulBestF = F;\n\t\t\t\t\t\t\tulBestR = R;\n\t\t\t\t\t\t\tulBestClk = ulTmp;\n\t\t\t\t\t\t\tulBestScore =\n\t\t\t\t\t\t\t    ulScore;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t \n\t\t\t \n\t\t\t\t\t\tif ((ulScore >= ulBestScore) && (OD > 0)) {\n\t\t\t\t\t\t\tulBestOD = OD;\n\t\t\t\t\t\t\tulBestF = F;\n\t\t\t\t\t\t\tulBestR = R;\n\t\t\t\t\t\t\tulBestClk = ulTmp;\n\t\t\t\t\t\t\tulBestScore =\n\t\t\t\t\t\t\t    ulScore;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tF++;\n\t\t\t}\n\t\t\tR++;\n\t\t}\n\t}\n\n\t \n\tif (ulBestScore) {\n\t\t*ROut = ulBestR;\n\t\t*FOut = ulBestF;\n\n\t\tif ((ulBestOD == 2) || (ulBestOD == 3)) {\n\t\t\t*POut = 3;\n\t\t} else\n\t\t\t*POut = ulBestOD;\n\n\t}\n\n\treturn (ulBestClk);\n}\n\nint SetCoreClockPLL(volatile STG4000REG __iomem *pSTGReg, struct pci_dev *pDev)\n{\n\tu32 F, R, P;\n\tu16 core_pll = 0, sub;\n\tu32 tmp;\n\tu32 ulChipSpeed;\n\n\tSTG_WRITE_REG(IntMask, 0xFFFF);\n\n\t \n\ttmp = STG_READ_REG(Thread0Enable);\n\tCLEAR_BIT(0);\n\tSTG_WRITE_REG(Thread0Enable, tmp);\n\n\t \n\ttmp = STG_READ_REG(Thread1Enable);\n\tCLEAR_BIT(0);\n\tSTG_WRITE_REG(Thread1Enable, tmp);\n\n\tSTG_WRITE_REG(SoftwareReset,\n\t\t      PMX2_SOFTRESET_REG_RST | PMX2_SOFTRESET_ROM_RST);\n\tSTG_WRITE_REG(SoftwareReset,\n\t\t      PMX2_SOFTRESET_REG_RST | PMX2_SOFTRESET_TA_RST |\n\t\t      PMX2_SOFTRESET_ROM_RST);\n\n\t \n\tSTG_WRITE_REG(TAConfiguration, 0);\n\tSTG_WRITE_REG(SoftwareReset,\n\t\t      PMX2_SOFTRESET_REG_RST | PMX2_SOFTRESET_ROM_RST);\n\tSTG_WRITE_REG(SoftwareReset,\n\t\t      PMX2_SOFTRESET_REG_RST | PMX2_SOFTRESET_TA_RST |\n\t\t      PMX2_SOFTRESET_ROM_RST);\n\n\tpci_read_config_word(pDev, PCI_CONFIG_SUBSYS_ID, &sub);\n\n\tulChipSpeed = InitSDRAMRegisters(pSTGReg, (u32)sub,\n\t\t                         (u32)pDev->revision);\n\n\tif (ulChipSpeed == 0)\n\t\treturn -EINVAL;\n\n\tProgramClock(REF_FREQ, CORE_PLL_FREQ, &F, &R, &P);\n\n\tcore_pll |= ((P) | ((F - 2) << 2) | ((R - 2) << 11));\n\n\t \n\n\t \n\ttmp = ((CORE_PLL_MODE_REG_0_7 << 8) | (core_pll & 0x00FF));\n\tpci_write_config_word(pDev, CorePllControl, tmp);\n\t \n\tOS_DELAY(1000000);\n\n\ttmp |= SET_BIT(14);\n\tpci_write_config_word(pDev, CorePllControl, tmp);\n\tOS_DELAY(1000000);\n\n\t \n\ttmp =\n\t    ((CORE_PLL_MODE_REG_8_15 << 8) | ((core_pll & 0xFF00) >> 8));\n\tpci_write_config_word(pDev, CorePllControl, tmp);\n\tOS_DELAY(1000000);\n\n\ttmp |= SET_BIT(14);\n\tpci_write_config_word(pDev, CorePllControl, tmp);\n\tOS_DELAY(1000000);\n\n\tSTG_WRITE_REG(SoftwareReset, PMX2_SOFTRESET_ALL);\n\n#if 0\n\t \n\ttmp = ((STG_READ_REG(Thread0Enable)) | SET_BIT(0));\n\tSTG_WRITE_REG(Thread0Enable, tmp);\n\n\t \n\ttmp = ((STG_READ_REG(Thread1Enable)) | SET_BIT(0));\n\tSTG_WRITE_REG(Thread1Enable, tmp);\n#endif\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}