{
  "module_name": "fbdev.c",
  "hash_id": "7271631ce40ffcee6f47c6c46aba37c0c7141fe5beb27f134ac57e2e391b3218",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/kyro/fbdev.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/ioctl.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include <video/kyro.h>\n\n#include \"STG4000Reg.h\"\n#include \"STG4000Interface.h\"\n\n \n#define PCI_VENDOR_ID_ST\t0x104a\n#define PCI_DEVICE_ID_STG4000\t0x0010\n\n#define KHZ2PICOS(a) (1000000000UL/(a))\n\n \nstatic struct fb_fix_screeninfo kyro_fix = {\n\t.id\t\t= \"ST Kyro\",\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.visual\t\t= FB_VISUAL_TRUECOLOR,\n\t.accel\t\t= FB_ACCEL_NONE,\n};\n\nstatic const struct fb_var_screeninfo kyro_var = {\n\t \n\t.xres\t\t= 640,\n\t.yres\t\t= 480,\n\t.xres_virtual\t= 640,\n\t.yres_virtual\t= 480,\n\t.bits_per_pixel\t= 16,\n\t.red\t\t= { 11, 5, 0 },\n\t.green\t\t= {  5, 6, 0 },\n\t.blue\t\t= {  0, 5, 0 },\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.pixclock\t= KHZ2PICOS(25175),\n\t.left_margin\t= 48,\n\t.right_margin\t= 16,\n\t.upper_margin\t= 33,\n\t.lower_margin\t= 10,\n\t.hsync_len\t= 96,\n\t.vsync_len\t= 2,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\ntypedef struct {\n\tSTG4000REG __iomem *pSTGReg;\t \n\tu32 ulNextFreeVidMem;\t \n\tu32 ulOverlayOffset;\t \n\tu32 ulOverlayStride;\t \n\tu32 ulOverlayUVStride;\t \n} device_info_t;\n\n \nstatic device_info_t deviceInfo;\n\nstatic char *mode_option = NULL;\nstatic int nopan = 0;\nstatic int nowrap = 1;\nstatic int nomtrr = 0;\n\n \nstatic int kyrofb_probe(struct pci_dev *pdev, const struct pci_device_id *ent);\nstatic void kyrofb_remove(struct pci_dev *pdev);\n\nstatic struct fb_videomode kyro_modedb[] = {\n\t{\n\t\t \n\t\tNULL, 85, 640, 350, KHZ2PICOS(31500),\n\t\t96, 32, 60, 32, 64, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 85, 640, 400, KHZ2PICOS(31500),\n\t\t96, 32, 41, 1, 64, 3,\n\t\tFB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 85, 720, 400, KHZ2PICOS(35500),\n\t\t108, 36, 42, 1, 72, 3,\n\t\tFB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 60, 640, 480, KHZ2PICOS(25175),\n\t\t48, 16, 33, 10, 96, 2,\n\t\t0, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 72, 640, 480, KHZ2PICOS(31500),\n\t\t128, 24, 28, 9, 40, 3,\n\t\t0, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 75, 640, 480, KHZ2PICOS(31500),\n\t\t120, 16, 16, 1, 64, 3,\n\t\t0, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 85, 640, 480, KHZ2PICOS(36000),\n\t\t80, 56, 25, 1, 56, 3,\n\t\t0, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 56, 800, 600, KHZ2PICOS(36000),\n\t\t128, 24, 22, 1, 72, 2,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 60, 800, 600, KHZ2PICOS(40000),\n\t\t88, 40, 23, 1, 128, 4,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 72, 800, 600, KHZ2PICOS(50000),\n\t\t64, 56, 23, 37, 120, 6,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 75, 800, 600, KHZ2PICOS(49500),\n\t\t160, 16, 21, 1, 80, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 85, 800, 600, KHZ2PICOS(56250),\n\t\t152, 32, 27, 1, 64, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 60, 1024, 768, KHZ2PICOS(65000),\n\t\t160, 24, 29, 3, 136, 6,\n\t\t0, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 70, 1024, 768, KHZ2PICOS(75000),\n\t\t144, 24, 29, 3, 136, 6,\n\t\t0, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 75, 1024, 768, KHZ2PICOS(78750),\n\t\t176, 16, 28, 1, 96, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 85, 1024, 768, KHZ2PICOS(94500),\n\t\t208, 48, 36, 1, 96, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 75, 1152, 864, KHZ2PICOS(108000),\n\t\t256, 64, 32, 1, 128, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 60, 1280, 960, KHZ2PICOS(108000),\n\t\t312, 96, 36, 1, 112, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 85, 1280, 960, KHZ2PICOS(148500),\n\t\t224, 64, 47, 1, 160, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 60, 1280, 1024, KHZ2PICOS(108000),\n\t\t248, 48, 38, 1, 112, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 75, 1280, 1024, KHZ2PICOS(135000),\n\t\t248, 16, 38, 1, 144, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 85, 1280, 1024, KHZ2PICOS(157500),\n\t\t224, 64, 44, 1, 160, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 60, 1600, 1200, KHZ2PICOS(162000),\n\t\t304, 64, 46, 1, 192, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 65, 1600, 1200, KHZ2PICOS(175500),\n\t\t304, 64, 46, 1, 192, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 70, 1600, 1200, KHZ2PICOS(189000),\n\t\t304, 64, 46, 1, 192, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 75, 1600, 1200, KHZ2PICOS(202500),\n\t\t304, 64, 46, 1, 192, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 85, 1600, 1200, KHZ2PICOS(229500),\n\t\t304, 64, 46, 1, 192, 3,\n\t\tFB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 60, 1792, 1344, KHZ2PICOS(204750),\n\t\t328, 128, 46, 1, 200, 3,\n\t\tFB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 75, 1792, 1344, KHZ2PICOS(261000),\n\t\t352, 96, 69, 1, 216, 3,\n\t\tFB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 60, 1856, 1392, KHZ2PICOS(218250),\n\t\t352, 96, 43, 1, 224, 3,\n\t\tFB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 75, 1856, 1392, KHZ2PICOS(288000),\n\t\t352, 128, 104, 1, 224, 3,\n\t\tFB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 60, 1920, 1440, KHZ2PICOS(234000),\n\t\t344, 128, 56, 1, 208, 3,\n\t\tFB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\tNULL, 75, 1920, 1440, KHZ2PICOS(297000),\n\t\t352, 144, 56, 1, 224, 3,\n\t\tFB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t},\n};\n#define NUM_TOTAL_MODES\tARRAY_SIZE(kyro_modedb)\n\n \nenum {\n\tVMODE_640_350_85,\n\tVMODE_640_400_85,\n\tVMODE_720_400_85,\n\tVMODE_640_480_60,\n\tVMODE_640_480_72,\n\tVMODE_640_480_75,\n\tVMODE_640_480_85,\n\tVMODE_800_600_56,\n\tVMODE_800_600_60,\n\tVMODE_800_600_72,\n\tVMODE_800_600_75,\n\tVMODE_800_600_85,\n\tVMODE_1024_768_60,\n\tVMODE_1024_768_70,\n\tVMODE_1024_768_75,\n\tVMODE_1024_768_85,\n\tVMODE_1152_864_75,\n\tVMODE_1280_960_60,\n\tVMODE_1280_960_85,\n\tVMODE_1280_1024_60,\n\tVMODE_1280_1024_75,\n\tVMODE_1280_1024_85,\n\tVMODE_1600_1200_60,\n\tVMODE_1600_1200_65,\n\tVMODE_1600_1200_70,\n\tVMODE_1600_1200_75,\n\tVMODE_1600_1200_85,\n\tVMODE_1792_1344_60,\n\tVMODE_1792_1344_75,\n\tVMODE_1856_1392_60,\n\tVMODE_1856_1392_75,\n\tVMODE_1920_1440_60,\n\tVMODE_1920_1440_75,\n};\n\n \nstatic int kyro_dev_video_mode_set(struct fb_info *info)\n{\n\tstruct kyrofb_info *par = info->par;\n\n\t \n\tStopVTG(deviceInfo.pSTGReg);\n\tDisableRamdacOutput(deviceInfo.pSTGReg);\n\n\t \n\tDisableVGA(deviceInfo.pSTGReg);\n\n\tif (InitialiseRamdac(deviceInfo.pSTGReg,\n\t\t\t     info->var.bits_per_pixel,\n\t\t\t     info->var.xres, info->var.yres,\n\t\t\t     par->HSP, par->VSP, &par->PIXCLK) < 0)\n\t\treturn -EINVAL;\n\n\tSetupVTG(deviceInfo.pSTGReg, par);\n\n\tResetOverlayRegisters(deviceInfo.pSTGReg);\n\n\t \n\tEnableRamdacOutput(deviceInfo.pSTGReg);\n\tStartVTG(deviceInfo.pSTGReg);\n\n\tdeviceInfo.ulNextFreeVidMem = info->var.xres * info->var.yres *\n\t\t\t\t      info->var.bits_per_pixel;\n\tdeviceInfo.ulOverlayOffset = 0;\n\n\treturn 0;\n}\n\nstatic int kyro_dev_overlay_create(u32 ulWidth,\n\t\t\t\t   u32 ulHeight, int bLinear)\n{\n\tu32 offset;\n\tu32 stride, uvStride;\n\n\tif (deviceInfo.ulOverlayOffset != 0)\n\t\t \n\t\treturn -EINVAL;\n\n\tResetOverlayRegisters(deviceInfo.pSTGReg);\n\n\t \n\toffset = deviceInfo.ulNextFreeVidMem;\n\tif ((offset & 0x1f) != 0) {\n\t\toffset = (offset + 32L) & 0xffffffE0L;\n\t}\n\n\tif (CreateOverlaySurface(deviceInfo.pSTGReg, ulWidth, ulHeight,\n\t\t\t\t bLinear, offset, &stride, &uvStride) < 0)\n\t\treturn -EINVAL;\n\n\tdeviceInfo.ulOverlayOffset = offset;\n\tdeviceInfo.ulOverlayStride = stride;\n\tdeviceInfo.ulOverlayUVStride = uvStride;\n\tdeviceInfo.ulNextFreeVidMem = offset + (ulHeight * stride) + (ulHeight * 2 * uvStride);\n\n\tSetOverlayBlendMode(deviceInfo.pSTGReg, GLOBAL_ALPHA, 0xf, 0x0);\n\n\treturn 0;\n}\n\nstatic int kyro_dev_overlay_viewport_set(u32 x, u32 y, u32 ulWidth, u32 ulHeight)\n{\n\tif (deviceInfo.ulOverlayOffset == 0)\n\t\t \n\t\treturn -EINVAL;\n\n\tif (ulWidth == 0 || ulWidth == 0xffffffff ||\n\t    ulHeight == 0 || ulHeight == 0xffffffff ||\n\t    (x < 2 && ulWidth + 2 == 0))\n\t\treturn -EINVAL;\n\n\t \n\tDisableRamdacOutput(deviceInfo.pSTGReg);\n\n\tSetOverlayViewPort(deviceInfo.pSTGReg,\n\t\t\t   x, y, x + ulWidth - 1, y + ulHeight - 1);\n\n\tEnableOverlayPlane(deviceInfo.pSTGReg);\n\t \n\tEnableRamdacOutput(deviceInfo.pSTGReg);\n\n\treturn 0;\n}\n\nstatic inline unsigned long get_line_length(int x, int bpp)\n{\n\treturn (unsigned long)((((x*bpp)+31)&~31) >> 3);\n}\n\nstatic int kyrofb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct kyrofb_info *par = info->par;\n\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\tif (var->bits_per_pixel != 16 && var->bits_per_pixel != 32) {\n\t\tprintk(KERN_WARNING \"kyrofb: depth not supported: %u\\n\", var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (var->bits_per_pixel) {\n\tcase 16:\n\t\tvar->red.offset = 11;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.length = 5;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.length = 8;\n\t\tbreak;\n\t}\n\n\t \n\tvar->height = var->width = -1;\n\n\t \n\n\t \n\t \n \n\n\t \n\n\t \n\tif ((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_TEST)\n\t\treturn 0;\n\n\tvar->left_margin = par->HBP;\n\tvar->hsync_len = par->HST;\n\tvar->right_margin = par->HFP;\n\n\tvar->upper_margin = par->VBP;\n\tvar->vsync_len = par->VST;\n\tvar->lower_margin = par->VFP;\n\n\tif (par->HSP == 1)\n\t\tvar->sync |= FB_SYNC_HOR_HIGH_ACT;\n\tif (par->VSP == 1)\n\t\tvar->sync |= FB_SYNC_VERT_HIGH_ACT;\n\n\treturn 0;\n}\n\nstatic int kyrofb_set_par(struct fb_info *info)\n{\n\tstruct kyrofb_info *par = info->par;\n\tunsigned long lineclock;\n\tunsigned long frameclock;\n\n\t \n\tpar->XRES = info->var.xres;\n\tpar->YRES = info->var.yres;\n\n\t \n\tpar->PIXDEPTH = info->var.bits_per_pixel;\n\n\t \n\t \n\tlineclock = (info->var.pixclock * (info->var.xres +\n\t\t\t\t    info->var.right_margin +\n\t\t\t\t    info->var.hsync_len +\n\t\t\t\t    info->var.left_margin)) / 1000;\n\n\tif (!lineclock)\n\t\treturn -EINVAL;\n\n\t \n\tframeclock = lineclock * (info->var.yres +\n\t\t\t\t  info->var.lower_margin +\n\t\t\t\t  info->var.vsync_len +\n\t\t\t\t  info->var.upper_margin);\n\n\t \n\tpar->VFREQ = (1000000000 + (frameclock / 2)) / frameclock;\n\tpar->HCLK = (1000000000 + (lineclock / 2)) / lineclock;\n\tpar->PIXCLK = ((1000000000 + (info->var.pixclock / 2))\n\t\t\t\t\t/ info->var.pixclock) * 10;\n\n\t \n\tpar->HFP = info->var.right_margin;\n\tpar->HST = info->var.hsync_len;\n\tpar->HBP = info->var.left_margin;\n\tpar->HTot = par->XRES + par->HBP + par->HST + par->HFP;\n\n\t \n\tpar->VFP = info->var.lower_margin;\n\tpar->VST = info->var.vsync_len;\n\tpar->VBP = info->var.upper_margin;\n\tpar->VTot = par->YRES + par->VBP + par->VST + par->VFP;\n\n\tpar->HSP = (info->var.sync & FB_SYNC_HOR_HIGH_ACT) ? 1 : 0;\n\tpar->VSP = (info->var.sync & FB_SYNC_VERT_HIGH_ACT) ? 1 : 0;\n\n\tkyro_dev_video_mode_set(info);\n\n\t \n\tinfo->fix.line_length = get_line_length(par->XRES, par->PIXDEPTH);\n\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\n\treturn 0;\n}\n\nstatic int kyrofb_setcolreg(u_int regno, u_int red, u_int green,\n\t\t\t    u_int blue, u_int transp, struct fb_info *info)\n{\n\tstruct kyrofb_info *par = info->par;\n\n\tif (regno > 255)\n\t\treturn 1;\t \n\n\tif (regno < 16) {\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 16:\n\t\t\tpar->palette[regno] =\n\t\t\t     (red   & 0xf800) |\n\t\t\t    ((green & 0xfc00) >> 5) |\n\t\t\t    ((blue  & 0xf800) >> 11);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tred >>= 8; green >>= 8; blue >>= 8; transp >>= 8;\n\t\t\tpar->palette[regno] =\n\t\t\t    (transp << 24) | (red << 16) | (green << 8) | blue;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifndef MODULE\nstatic int __init kyrofb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\"))) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\t\tif (strcmp(this_opt, \"nopan\") == 0) {\n\t\t\tnopan = 1;\n\t\t} else if (strcmp(this_opt, \"nowrap\") == 0) {\n\t\t\tnowrap = 1;\n\t\t} else if (strcmp(this_opt, \"nomtrr\") == 0) {\n\t\t\tnomtrr = 1;\n\t\t} else {\n\t\t\tmode_option = this_opt;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int kyrofb_ioctl(struct fb_info *info,\n\t\t\tunsigned int cmd, unsigned long arg)\n{\n\toverlay_create ol_create;\n\toverlay_viewport_set ol_viewport_set;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase KYRO_IOCTL_OVERLAY_CREATE:\n\t\tif (copy_from_user(&ol_create, argp, sizeof(overlay_create)))\n\t\t\treturn -EFAULT;\n\n\t\tif (kyro_dev_overlay_create(ol_create.ulWidth,\n\t\t\t\t\t    ol_create.ulHeight, 0) < 0) {\n\t\t\tprintk(KERN_ERR \"Kyro FB: failed to create overlay surface.\\n\");\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase KYRO_IOCTL_OVERLAY_VIEWPORT_SET:\n\t\tif (copy_from_user(&ol_viewport_set, argp,\n\t\t\t       sizeof(overlay_viewport_set)))\n\t\t\treturn -EFAULT;\n\n\t\tif (kyro_dev_overlay_viewport_set(ol_viewport_set.xOrgin,\n\t\t\t\t\t\t  ol_viewport_set.yOrgin,\n\t\t\t\t\t\t  ol_viewport_set.xSize,\n\t\t\t\t\t\t  ol_viewport_set.ySize) != 0)\n\t\t{\n\t\t\tprintk(KERN_ERR \"Kyro FB: failed to create overlay viewport.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase KYRO_IOCTL_SET_VIDEO_MODE:\n\t\t{\n\t\t\tprintk(KERN_ERR \"Kyro FB: KYRO_IOCTL_SET_VIDEO_MODE is\"\n\t\t\t\t\"obsolete, use the appropriate fb_ioctl()\"\n\t\t\t\t\"command instead.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase KYRO_IOCTL_UVSTRIDE:\n\t\tif (copy_to_user(argp, &deviceInfo.ulOverlayUVStride, sizeof(deviceInfo.ulOverlayUVStride)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase KYRO_IOCTL_STRIDE:\n\t\tif (copy_to_user(argp, &deviceInfo.ulOverlayStride, sizeof(deviceInfo.ulOverlayStride)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase KYRO_IOCTL_OVERLAY_OFFSET:\n\t\tif (copy_to_user(argp, &deviceInfo.ulOverlayOffset, sizeof(deviceInfo.ulOverlayOffset)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id kyrofb_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_ST, PCI_DEVICE_ID_STG4000,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, kyrofb_pci_tbl);\n\nstatic struct pci_driver kyrofb_pci_driver = {\n\t.name\t\t= \"kyrofb\",\n\t.id_table\t= kyrofb_pci_tbl,\n\t.probe\t\t= kyrofb_probe,\n\t.remove\t\t= kyrofb_remove,\n};\n\nstatic const struct fb_ops kyrofb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= kyrofb_check_var,\n\t.fb_set_par\t= kyrofb_set_par,\n\t.fb_setcolreg\t= kyrofb_setcolreg,\n\t.fb_ioctl\t= kyrofb_ioctl,\n};\n\nstatic int kyrofb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct fb_info *info;\n\tstruct kyrofb_info *currentpar;\n\tunsigned long size;\n\tint err;\n\n\terr = aperture_remove_conflicting_pci_devices(pdev, \"kyrofb\");\n\tif (err)\n\t\treturn err;\n\n\tif ((err = pci_enable_device(pdev))) {\n\t\tprintk(KERN_WARNING \"kyrofb: Can't enable pdev: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct kyrofb_info), &pdev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tcurrentpar = info->par;\n\n\tkyro_fix.smem_start = pci_resource_start(pdev, 0);\n\tkyro_fix.smem_len   = pci_resource_len(pdev, 0);\n\tkyro_fix.mmio_start = pci_resource_start(pdev, 1);\n\tkyro_fix.mmio_len   = pci_resource_len(pdev, 1);\n\n\tcurrentpar->regbase = deviceInfo.pSTGReg =\n\t\tioremap(kyro_fix.mmio_start, kyro_fix.mmio_len);\n\tif (!currentpar->regbase)\n\t\tgoto out_free_fb;\n\n\tinfo->screen_base = pci_ioremap_wc_bar(pdev, 0);\n\tif (!info->screen_base)\n\t\tgoto out_unmap_regs;\n\n\tif (!nomtrr)\n\t\tcurrentpar->wc_cookie = arch_phys_wc_add(kyro_fix.smem_start,\n\t\t\t\t\t\t\t kyro_fix.smem_len);\n\n\tkyro_fix.ypanstep\t= nopan ? 0 : 1;\n\tkyro_fix.ywrapstep\t= nowrap ? 0 : 1;\n\n\tinfo->fbops\t\t= &kyrofb_ops;\n\tinfo->fix\t\t= kyro_fix;\n\tinfo->pseudo_palette\t= currentpar->palette;\n\n\tSetCoreClockPLL(deviceInfo.pSTGReg, pdev);\n\n\tdeviceInfo.ulNextFreeVidMem = 0;\n\tdeviceInfo.ulOverlayOffset = 0;\n\n\t \n\tif (!fb_find_mode(&info->var, info, mode_option, kyro_modedb,\n\t\t\t  NUM_TOTAL_MODES, &kyro_modedb[VMODE_1024_768_75], 32))\n\t\tinfo->var = kyro_var;\n\n\tfb_alloc_cmap(&info->cmap, 256, 0);\n\n\tkyrofb_set_par(info);\n\tkyrofb_check_var(&info->var, info);\n\n\tsize = get_line_length(info->var.xres_virtual,\n\t\t\t       info->var.bits_per_pixel);\n\tsize *= info->var.yres_virtual;\n\n\tfb_memset_io(info->screen_base, 0, size);\n\n\tif (register_framebuffer(info) < 0)\n\t\tgoto out_unmap;\n\n\tfb_info(info, \"%s frame buffer device, at %dx%d@%d using %ldk/%ldk of VRAM\\n\",\n\t\tinfo->fix.id,\n\t\tinfo->var.xres, info->var.yres, info->var.bits_per_pixel,\n\t\tsize >> 10, (unsigned long)info->fix.smem_len >> 10);\n\n\tpci_set_drvdata(pdev, info);\n\n\treturn 0;\n\nout_unmap:\n\tiounmap(info->screen_base);\nout_unmap_regs:\n\tiounmap(currentpar->regbase);\nout_free_fb:\n\tframebuffer_release(info);\n\n\treturn -EINVAL;\n}\n\nstatic void kyrofb_remove(struct pci_dev *pdev)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct kyrofb_info *par = info->par;\n\n\t \n\tStopVTG(deviceInfo.pSTGReg);\n\tDisableRamdacOutput(deviceInfo.pSTGReg);\n\n\t \n\tSetCoreClockPLL(deviceInfo.pSTGReg, pdev);\n\n\tdeviceInfo.ulNextFreeVidMem = 0;\n\tdeviceInfo.ulOverlayOffset = 0;\n\n\tiounmap(info->screen_base);\n\tiounmap(par->regbase);\n\n\tarch_phys_wc_del(par->wc_cookie);\n\n\tunregister_framebuffer(info);\n\tframebuffer_release(info);\n}\n\nstatic int __init kyrofb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"kyrofb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"kyrofb\", &option))\n\t\treturn -ENODEV;\n\tkyrofb_setup(option);\n#endif\n\treturn pci_register_driver(&kyrofb_pci_driver);\n}\n\nstatic void __exit kyrofb_exit(void)\n{\n\tpci_unregister_driver(&kyrofb_pci_driver);\n}\n\nmodule_init(kyrofb_init);\n\n#ifdef MODULE\nmodule_exit(kyrofb_exit);\n#endif\n\nMODULE_AUTHOR(\"STMicroelectronics; Paul Mundt <lethal@linux-sh.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}