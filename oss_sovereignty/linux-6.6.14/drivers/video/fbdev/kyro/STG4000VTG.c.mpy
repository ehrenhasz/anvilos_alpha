{
  "module_name": "STG4000VTG.c",
  "hash_id": "98aa2bc4d28ee11dca0c4f409d95a04042f535769305b8e07235506430c492c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/kyro/STG4000VTG.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <video/kyro.h>\n\n#include \"STG4000Reg.h\"\n#include \"STG4000Interface.h\"\n\nvoid DisableVGA(volatile STG4000REG __iomem *pSTGReg)\n{\n\tu32 tmp;\n\tvolatile u32 count = 0, i;\n\n\t \n\ttmp = STG_READ_REG(SoftwareReset);\n\tCLEAR_BIT(8);\n\tSTG_WRITE_REG(SoftwareReset, tmp);\n\n\t \n\tfor (i = 0; i < 1000; i++) {\n\t\tcount++;\n\t}\n\n\t \n\ttmp = STG_READ_REG(SoftwareReset);\n\ttmp |= SET_BIT(8);\n\tSTG_WRITE_REG(SoftwareReset, tmp);\n}\n\nvoid StopVTG(volatile STG4000REG __iomem *pSTGReg)\n{\n\tu32 tmp = 0;\n\n\t \n\ttmp = (STG_READ_REG(DACSyncCtrl)) | SET_BIT(0) | SET_BIT(2);\n\tCLEAR_BIT(31);\n\tSTG_WRITE_REG(DACSyncCtrl, tmp);\n}\n\nvoid StartVTG(volatile STG4000REG __iomem *pSTGReg)\n{\n\tu32 tmp = 0;\n\n\t \n\ttmp = ((STG_READ_REG(DACSyncCtrl)) | SET_BIT(31));\n\tCLEAR_BIT(0);\n\tCLEAR_BIT(2);\n\tSTG_WRITE_REG(DACSyncCtrl, tmp);\n}\n\nvoid SetupVTG(volatile STG4000REG __iomem *pSTGReg,\n\t      const struct kyrofb_info * pTiming)\n{\n\tu32 tmp = 0;\n\tu32 margins = 0;\n\tu32 ulBorder;\n\tu32 xRes = pTiming->XRES;\n\tu32 yRes = pTiming->YRES;\n\n\t \n\tu32 HAddrTime, HRightBorder, HLeftBorder;\n\tu32 HBackPorcStrt, HFrontPorchStrt, HTotal,\n\t    HLeftBorderStrt, HRightBorderStrt, HDisplayStrt;\n\n\t \n\tu32 VDisplayStrt, VBottomBorder, VTopBorder;\n\tu32 VBackPorchStrt, VTotal, VTopBorderStrt,\n\t    VFrontPorchStrt, VBottomBorderStrt, VAddrTime;\n\n\t \n\tif ((xRes == 640) && (yRes == 480)) {\n\t\tif ((pTiming->VFREQ == 60) || (pTiming->VFREQ == 72)) {\n\t\t\tmargins = 8;\n\t\t}\n\t}\n\n\t \n\tulBorder =\n\t    (pTiming->HTot -\n\t     (pTiming->HST + (pTiming->HBP - margins) + xRes +\n\t      (pTiming->HFP - margins))) >> 1;\n\n\t \n\tVBottomBorder = HLeftBorder = VTopBorder = HRightBorder = ulBorder;\n\n     \n\tHAddrTime = xRes;\n\tHBackPorcStrt = pTiming->HST;\n\tHTotal = pTiming->HTot;\n\tHDisplayStrt =\n\t    pTiming->HST + (pTiming->HBP - margins) + HLeftBorder;\n\tHLeftBorderStrt = HDisplayStrt - HLeftBorder;\n\tHFrontPorchStrt =\n\t    pTiming->HST + (pTiming->HBP - margins) + HLeftBorder +\n\t    HAddrTime + HRightBorder;\n\tHRightBorderStrt = HFrontPorchStrt - HRightBorder;\n\n     \n\tVAddrTime = yRes;\n\tVBackPorchStrt = pTiming->VST;\n\tVTotal = pTiming->VTot;\n\tVDisplayStrt =\n\t    pTiming->VST + (pTiming->VBP - margins) + VTopBorder;\n\tVTopBorderStrt = VDisplayStrt - VTopBorder;\n\tVFrontPorchStrt =\n\t    pTiming->VST + (pTiming->VBP - margins) + VTopBorder +\n\t    VAddrTime + VBottomBorder;\n\tVBottomBorderStrt = VFrontPorchStrt - VBottomBorder;\n\n\t \n\ttmp = STG_READ_REG(DACHorTim1);\n\tCLEAR_BITS_FRM_TO(0, 11);\n\tCLEAR_BITS_FRM_TO(16, 27);\n\ttmp |= (HTotal) | (HBackPorcStrt << 16);\n\tSTG_WRITE_REG(DACHorTim1, tmp);\n\n\ttmp = STG_READ_REG(DACHorTim2);\n\tCLEAR_BITS_FRM_TO(0, 11);\n\tCLEAR_BITS_FRM_TO(16, 27);\n\ttmp |= (HDisplayStrt << 16) | HLeftBorderStrt;\n\tSTG_WRITE_REG(DACHorTim2, tmp);\n\n\ttmp = STG_READ_REG(DACHorTim3);\n\tCLEAR_BITS_FRM_TO(0, 11);\n\tCLEAR_BITS_FRM_TO(16, 27);\n\ttmp |= (HFrontPorchStrt << 16) | HRightBorderStrt;\n\tSTG_WRITE_REG(DACHorTim3, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACVerTim1);\n\tCLEAR_BITS_FRM_TO(0, 11);\n\tCLEAR_BITS_FRM_TO(16, 27);\n\ttmp |= (VBackPorchStrt << 16) | (VTotal);\n\tSTG_WRITE_REG(DACVerTim1, tmp);\n\n\ttmp = STG_READ_REG(DACVerTim2);\n\tCLEAR_BITS_FRM_TO(0, 11);\n\tCLEAR_BITS_FRM_TO(16, 27);\n\ttmp |= (VDisplayStrt << 16) | VTopBorderStrt;\n\tSTG_WRITE_REG(DACVerTim2, tmp);\n\n\ttmp = STG_READ_REG(DACVerTim3);\n\tCLEAR_BITS_FRM_TO(0, 11);\n\tCLEAR_BITS_FRM_TO(16, 27);\n\ttmp |= (VFrontPorchStrt << 16) | VBottomBorderStrt;\n\tSTG_WRITE_REG(DACVerTim3, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACSyncCtrl) | SET_BIT(3) | SET_BIT(1);\n\n\tif ((pTiming->HSP > 0) && (pTiming->VSP < 0)) {\t \n\t\ttmp &= ~0x8;\n\t} else if ((pTiming->HSP < 0) && (pTiming->VSP > 0)) {\t \n\t\ttmp &= ~0x2;\n\t} else if ((pTiming->HSP < 0) && (pTiming->VSP < 0)) {\t \n\t\ttmp &= ~0xA;\n\t} else if ((pTiming->HSP > 0) && (pTiming->VSP > 0)) {\t \n\t\ttmp &= ~0x0;\n\t}\n\n\tSTG_WRITE_REG(DACSyncCtrl, tmp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}