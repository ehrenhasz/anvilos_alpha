{
  "module_name": "STG4000OverlayDevice.c",
  "hash_id": "4489b43c20e1491ae82ef4cb1962964cffdf790221b558c966ab9608f3f8b149",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/kyro/STG4000OverlayDevice.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#include \"STG4000Reg.h\"\n#include \"STG4000Interface.h\"\n\n \n\n#define STG4000_NO_SCALING    0x800\n#define STG4000_NO_DECIMATION 0xFFFFFFFF\n\n \n#define STG4000_PRIM_NUM_PIX   5\n#define STG4000_PRIM_ALIGN     4\n#define STG4000_PRIM_ADDR_BITS 20\n\n#define STG4000_PRIM_MIN_WIDTH  640\n#define STG4000_PRIM_MAX_WIDTH  1600\n#define STG4000_PRIM_MIN_HEIGHT 480\n#define STG4000_PRIM_MAX_HEIGHT 1200\n\n \n#define STG4000_OVRL_NUM_PIX   4\n#define STG4000_OVRL_ALIGN     2\n#define STG4000_OVRL_ADDR_BITS 20\n#define STG4000_OVRL_NUM_MODES 5\n\n#define STG4000_OVRL_MIN_WIDTH  0\n#define STG4000_OVRL_MAX_WIDTH  720\n#define STG4000_OVRL_MIN_HEIGHT 0\n#define STG4000_OVRL_MAX_HEIGHT 576\n\n \nstatic u32 adwDecim8[33] = {\n\t    0xffffffff, 0xfffeffff, 0xffdffbff, 0xfefefeff, 0xfdf7efbf,\n\t    0xfbdf7bdf, 0xf7bbddef, 0xeeeeeeef, 0xeeddbb77, 0xedb76db7,\n\t    0xdb6db6db, 0xdb5b5b5b, 0xdab5ad6b, 0xd5ab55ab, 0xd555aaab,\n\t    0xaaaaaaab, 0xaaaa5555, 0xaa952a55, 0xa94a5295, 0xa5252525,\n\t    0xa4924925, 0x92491249, 0x91224489, 0x91111111, 0x90884211,\n\t    0x88410821, 0x88102041, 0x81010101, 0x80800801, 0x80010001,\n\t    0x80000001, 0x00000001, 0x00000000\n};\n\ntypedef struct _OVRL_SRC_DEST {\n\t \n\tu32 ulDstX1;\n\tu32 ulDstY1;\n\tu32 ulDstX2;\n\tu32 ulDstY2;\n\n\t \n\tu32 ulSrcX1;\n\tu32 ulSrcY1;\n\tu32 ulSrcX2;\n\tu32 ulSrcY2;\n\n\t \n\ts32 lDstX1;\n\ts32 lDstY1;\n\ts32 lDstX2;\n\ts32 lDstY2;\n} OVRL_SRC_DEST;\n\nstatic u32 ovlWidth, ovlHeight, ovlStride;\nstatic int ovlLinear;\n\nvoid ResetOverlayRegisters(volatile STG4000REG __iomem *pSTGReg)\n{\n\tu32 tmp;\n\n\t \n\ttmp = STG_READ_REG(DACOverlayAddr);\n\tCLEAR_BITS_FRM_TO(0, 20);\n\tCLEAR_BIT(31);\n\tSTG_WRITE_REG(DACOverlayAddr, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACOverlayUAddr);\n\tCLEAR_BITS_FRM_TO(0, 20);\n\tSTG_WRITE_REG(DACOverlayUAddr, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACOverlayVAddr);\n\tCLEAR_BITS_FRM_TO(0, 20);\n\tSTG_WRITE_REG(DACOverlayVAddr, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACOverlaySize);\n\tCLEAR_BITS_FRM_TO(0, 10);\n\tCLEAR_BITS_FRM_TO(12, 31);\n\tSTG_WRITE_REG(DACOverlaySize, tmp);\n\n\t \n\ttmp = STG4000_NO_DECIMATION;\n\tSTG_WRITE_REG(DACOverlayVtDec, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACPixelFormat);\n\tCLEAR_BITS_FRM_TO(4, 7);\n\tCLEAR_BITS_FRM_TO(16, 22);\n\tSTG_WRITE_REG(DACPixelFormat, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACVerticalScal);\n\tCLEAR_BITS_FRM_TO(0, 11);\n\tCLEAR_BITS_FRM_TO(16, 22);\n\ttmp |= STG4000_NO_SCALING;\t \n\tSTG_WRITE_REG(DACVerticalScal, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACHorizontalScal);\n\tCLEAR_BITS_FRM_TO(0, 11);\n\tCLEAR_BITS_FRM_TO(16, 17);\n\ttmp |= STG4000_NO_SCALING;\t \n\tSTG_WRITE_REG(DACHorizontalScal, tmp);\n\n\t \n\t \n\ttmp = STG_READ_REG(DACBlendCtrl);\n\tCLEAR_BITS_FRM_TO(0, 30);\n\ttmp = (GRAPHICS_MODE << 28);\n\tSTG_WRITE_REG(DACBlendCtrl, tmp);\n\n}\n\nint CreateOverlaySurface(volatile STG4000REG __iomem *pSTGReg,\n\t\t\t u32 inWidth,\n\t\t\t u32 inHeight,\n\t\t\t int bLinear,\n\t\t\t u32 ulOverlayOffset,\n\t\t\t u32 * retStride, u32 * retUVStride)\n{\n\tu32 tmp;\n\tu32 ulStride;\n\n\tif (inWidth > STG4000_OVRL_MAX_WIDTH ||\n\t    inHeight > STG4000_OVRL_MAX_HEIGHT) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (bLinear) {\n\t\t \n\t\tif ((inWidth & 0x7) == 0) {\t \n\t\t\tulStride = (inWidth / 8);\n\t\t} else {\n\t\t\t \n\t\t\tulStride = ((inWidth + 8) / 8);\n\t\t}\n\t} else {\n\t\t \n\t\tif ((inWidth & 0xf) == 0) {\t \n\t\t\tulStride = (inWidth / 16);\n\t\t} else {\n\t\t\t \n\t\t\tulStride = ((inWidth + 16) / 16);\n\t\t}\n\t}\n\n\n\t \n\ttmp = STG_READ_REG(DACOverlayAddr);\n\tCLEAR_BITS_FRM_TO(0, 20);\n\tif (bLinear) {\n\t\tCLEAR_BIT(31);\t \n\t} else {\n\t\ttmp |= SET_BIT(31);\t \n\t}\n\n\t \n\ttmp |= (ulOverlayOffset >> 4);\n\tSTG_WRITE_REG(DACOverlayAddr, tmp);\n\n\tif (!bLinear) {\n\t\tu32 uvSize =\n\t\t    (inWidth & 0x1) ? (inWidth + 1 / 2) : (inWidth / 2);\n\t\tu32 uvStride;\n\t\tu32 ulOffset;\n\t\t \n\t\tif ((uvSize & 0xf) == 0) {\t \n\t\t\tuvStride = (uvSize / 16);\n\t\t} else {\n\t\t\t \n\t\t\tuvStride = ((uvSize + 16) / 16);\n\t\t}\n\n\t\tulOffset = ulOverlayOffset + (inHeight * (ulStride * 16));\n\t\t \n\t\tif ((ulOffset & 0x1f) != 0)\n\t\t\tulOffset = (ulOffset + 32L) & 0xffffffE0L;\n\n\t\ttmp = STG_READ_REG(DACOverlayUAddr);\n\t\tCLEAR_BITS_FRM_TO(0, 20);\n\t\ttmp |= (ulOffset >> 4);\n\t\tSTG_WRITE_REG(DACOverlayUAddr, tmp);\n\n\t\tulOffset += (inHeight / 2) * (uvStride * 16);\n\t\t \n\t\tif ((ulOffset & 0x1f) != 0)\n\t\t\tulOffset = (ulOffset + 32L) & 0xffffffE0L;\n\n\t\ttmp = STG_READ_REG(DACOverlayVAddr);\n\t\tCLEAR_BITS_FRM_TO(0, 20);\n\t\ttmp |= (ulOffset >> 4);\n\t\tSTG_WRITE_REG(DACOverlayVAddr, tmp);\n\n\t\t*retUVStride = uvStride * 16;\n\t}\n\n\n\t \n\ttmp = STG_READ_REG(DACPixelFormat);\n\t \n\tCLEAR_BITS_FRM_TO(4, 9);\n\tSTG_WRITE_REG(DACPixelFormat, tmp);\n\n\tovlWidth = inWidth;\n\tovlHeight = inHeight;\n\tovlStride = ulStride;\n\tovlLinear = bLinear;\n\t*retStride = ulStride << 4;\t \n\n\treturn 0;\n}\n\nint SetOverlayBlendMode(volatile STG4000REG __iomem *pSTGReg,\n\t\t\tOVRL_BLEND_MODE mode,\n\t\t\tu32 ulAlpha, u32 ulColorKey)\n{\n\tu32 tmp;\n\n\ttmp = STG_READ_REG(DACBlendCtrl);\n\tCLEAR_BITS_FRM_TO(28, 30);\n\ttmp |= (mode << 28);\n\n\tswitch (mode) {\n\tcase COLOR_KEY:\n\t\tCLEAR_BITS_FRM_TO(0, 23);\n\t\ttmp |= (ulColorKey & 0x00FFFFFF);\n\t\tbreak;\n\n\tcase GLOBAL_ALPHA:\n\t\tCLEAR_BITS_FRM_TO(24, 27);\n\t\ttmp |= ((ulAlpha & 0xF) << 24);\n\t\tbreak;\n\n\tcase CK_PIXEL_ALPHA:\n\t\tCLEAR_BITS_FRM_TO(0, 23);\n\t\ttmp |= (ulColorKey & 0x00FFFFFF);\n\t\tbreak;\n\n\tcase CK_GLOBAL_ALPHA:\n\t\tCLEAR_BITS_FRM_TO(0, 23);\n\t\ttmp |= (ulColorKey & 0x00FFFFFF);\n\t\tCLEAR_BITS_FRM_TO(24, 27);\n\t\ttmp |= ((ulAlpha & 0xF) << 24);\n\t\tbreak;\n\n\tcase GRAPHICS_MODE:\n\tcase PER_PIXEL_ALPHA:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tSTG_WRITE_REG(DACBlendCtrl, tmp);\n\n\treturn 0;\n}\n\nvoid EnableOverlayPlane(volatile STG4000REG __iomem *pSTGReg)\n{\n\tu32 tmp;\n\t \n\ttmp = STG_READ_REG(DACPixelFormat);\n\ttmp |= SET_BIT(7);\n\tSTG_WRITE_REG(DACPixelFormat, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACStreamCtrl);\n\ttmp |= SET_BIT(1);\t \n\tSTG_WRITE_REG(DACStreamCtrl, tmp);\n}\n\nstatic u32 Overlap(u32 ulBits, u32 ulPattern)\n{\n\tu32 ulCount = 0;\n\n\twhile (ulBits) {\n\t\tif (!(ulPattern & 1))\n\t\t\tulCount++;\n\t\tulBits--;\n\t\tulPattern = ulPattern >> 1;\n\t}\n\n\treturn ulCount;\n\n}\n\nint SetOverlayViewPort(volatile STG4000REG __iomem *pSTGReg,\n\t\t       u32 left, u32 top,\n\t\t       u32 right, u32 bottom)\n{\n\tOVRL_SRC_DEST srcDest;\n\n\tu32 ulSrcTop, ulSrcBottom;\n\tu32 ulSrc, ulDest;\n\tu32 ulFxScale, ulFxOffset;\n\tu32 ulHeight, ulWidth;\n\tu32 ulPattern;\n\tu32 ulDecimate, ulDecimated;\n\tu32 ulApplied;\n\tu32 ulDacXScale, ulDacYScale;\n\tu32 ulScale;\n\tu32 ulLeft, ulRight;\n\tu32 ulSrcLeft, ulSrcRight;\n\tu32 ulScaleLeft;\n\tu32 ulhDecim;\n\tu32 ulsVal;\n\tu32 ulVertDecFactor;\n\tint bResult;\n\tu32 ulClipOff = 0;\n\tu32 ulBits = 0;\n\tu32 ulsAdd = 0;\n\tu32 tmp, ulStride;\n\tu32 ulExcessPixels, ulClip, ulExtraLines;\n\n\n\tsrcDest.ulSrcX1 = 0;\n\tsrcDest.ulSrcY1 = 0;\n\tsrcDest.ulSrcX2 = ovlWidth - 1;\n\tsrcDest.ulSrcY2 = ovlHeight - 1;\n\n\tsrcDest.ulDstX1 = left;\n\tsrcDest.ulDstY1 = top;\n\tsrcDest.ulDstX2 = right;\n\tsrcDest.ulDstY2 = bottom;\n\n\tsrcDest.lDstX1 = srcDest.ulDstX1;\n\tsrcDest.lDstY1 = srcDest.ulDstY1;\n\tsrcDest.lDstX2 = srcDest.ulDstX2;\n\tsrcDest.lDstY2 = srcDest.ulDstY2;\n\n     \n\n\t \n\tulSrcTop = srcDest.ulSrcY1;\n\tulSrcBottom = srcDest.ulSrcY2;\n\n\tulSrc = ulSrcBottom - ulSrcTop;\n\tulDest = srcDest.lDstY2 - srcDest.lDstY1;\t \n\n\tif (ulSrc <= 1)\n\t\treturn -EINVAL;\n\n\t \n\tulFxScale = (ulDest << 11) / ulSrc;\t \n\tulFxOffset = (srcDest.lDstY2 - srcDest.ulDstY2) << 11;\n\n\tulSrcBottom = ulSrcBottom - (ulFxOffset / ulFxScale);\n\tulSrc = ulSrcBottom - ulSrcTop;\n\tulHeight = ulSrc;\n\n\tulDest = srcDest.ulDstY2 - (srcDest.ulDstY1 - 1);\n\tulPattern = adwDecim8[ulBits];\n\n\t \n\tif (ulSrc > ulDest) {\n\t\tulDecimate = ulSrc - ulDest;\n\t\tulBits = 0;\n\t\tulApplied = ulSrc / 32;\n\n\t\twhile (((ulBits * ulApplied) +\n\t\t\tOverlap((ulSrc % 32),\n\t\t\t\tadwDecim8[ulBits])) < ulDecimate)\n\t\t\tulBits++;\n\n\t\tulPattern = adwDecim8[ulBits];\n\t\tulDecimated =\n\t\t    (ulBits * ulApplied) + Overlap((ulSrc % 32),\n\t\t\t\t\t\t   ulPattern);\n\t\tulSrc = ulSrc - ulDecimated;\t \n\t}\n\n\tif (ulBits && (ulBits != 32)) {\n\t\tulVertDecFactor = (63 - ulBits) / (32 - ulBits);\t \n\t} else {\n\t\tulVertDecFactor = 1;\n\t}\n\n\tulDacYScale = ((ulSrc - 1) * 2048) / (ulDest + 1);\n\n\ttmp = STG_READ_REG(DACOverlayVtDec);\t \n\tCLEAR_BITS_FRM_TO(0, 31);\n\ttmp = ulPattern;\n\tSTG_WRITE_REG(DACOverlayVtDec, tmp);\n\n\t \n\n\t \n\tulSrc = srcDest.ulSrcX2 - srcDest.ulSrcX1;\n\tulDest = srcDest.lDstX2 - srcDest.lDstX1;\n#ifdef _OLDCODE\n\tulLeft = srcDest.ulDstX1;\n\tulRight = srcDest.ulDstX2;\n#else\n\tif (srcDest.ulDstX1 > 2) {\n\t\tulLeft = srcDest.ulDstX1 + 2;\n\t\tulRight = srcDest.ulDstX2 + 1;\n\t} else {\n\t\tulLeft = srcDest.ulDstX1;\n\t\tulRight = srcDest.ulDstX2 + 1;\n\t}\n#endif\n\t \n\tbResult = 1;\n\n\tdo {\n\t\tif (ulDest == 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tulFxScale = ((ulSrc - 1) << 11) / (ulDest);\n\n\t\t \n\t\tulFxOffset = ulFxScale * ((srcDest.ulDstX1 - srcDest.lDstX1) + ulClipOff);\n\t\tulFxOffset >>= 11;\n\n\t\t \n\t\tulSrcLeft = srcDest.ulSrcX1 + ulFxOffset;\n\n\t\t \n\t\tulFxOffset = ulFxScale * (srcDest.lDstX2 - srcDest.ulDstX2);\n\t\tulFxOffset >>= 11;\n\n\t\tulSrcRight = srcDest.ulSrcX2 - ulFxOffset;\n\n\t\t \n\t\tulScaleLeft = ulSrcLeft;\n\n\t\t \n\t\tulhDecim = 0;\n\t\tulScale = (((ulSrcRight - ulSrcLeft) - 1) << (11 - ulhDecim)) / (ulRight - ulLeft + 2);\n\n\t\twhile (ulScale > 0x800) {\n\t\t\tulhDecim++;\n\t\t\tulScale = (((ulSrcRight - ulSrcLeft) - 1) << (11 - ulhDecim)) / (ulRight - ulLeft + 2);\n\t\t}\n\n\t\t \n\t\tif (!ovlLinear) {\n\t\t\tulSrcLeft &= ~0x1f;\n\n\t\t\t \n\t\t\tulSrcRight = (ulSrcRight + 0x1f) & ~0x1f;\n\t\t} else {\n\t\t\tulSrcLeft &= ~0x7;\n\n\t\t\t \n\t\t\tulSrcRight = (ulSrcRight + 0x7) & ~0x7;\n\t\t}\n\n\t\t \n\t\tulWidth = ulSrcRight - ulSrcLeft;\n\n\t\t \n\t\tulsVal = ((ulWidth / 8) >> ulhDecim);\n\n\t\tif ((ulWidth != (ulsVal << ulhDecim) * 8))\n\t\t\tulsAdd = 1;\n\n\t\t \n\t\tulSrc = ulWidth >> ulhDecim;\n\n\t\tif (ulSrc <= 2)\n\t\t\treturn -EINVAL;\n\n\t\tulExcessPixels = ((((ulScaleLeft - ulSrcLeft)) << (11 - ulhDecim)) / ulScale);\n\n\t\tulClip = (ulSrc << 11) / ulScale;\n\t\tulClip -= (ulRight - ulLeft);\n\t\tulClip += ulExcessPixels;\n\n\t\tif (ulClip)\n\t\t\tulClip--;\n\n\t\t \n\t} while (!bResult);\n\n\tulExtraLines = (1 << ulhDecim) * ulVertDecFactor;\n\tulExtraLines += 64;\n\tulHeight += ulExtraLines;\n\n\tulDacXScale = ulScale;\n\n\n\ttmp = STG_READ_REG(DACVerticalScal);\n\tCLEAR_BITS_FRM_TO(0, 11);\n\tCLEAR_BITS_FRM_TO(16, 22);\t \n\n\t \n\tulStride = (ulWidth >> (ulhDecim + 3)) + ulsAdd;\n\ttmp |= ((ulStride << 16) | (ulDacYScale));\t \n\tSTG_WRITE_REG(DACVerticalScal, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACOverlaySize);\n\tCLEAR_BITS_FRM_TO(0, 10);\n\tCLEAR_BITS_FRM_TO(12, 31);\n\n\tif (ovlLinear) {\n\t\ttmp |=\n\t\t    (ovlStride | ((ulHeight + 1) << 12) |\n\t\t     (((ulWidth / 8) - 1) << 23));\n\t} else {\n\t\ttmp |=\n\t\t    (ovlStride | ((ulHeight + 1) << 12) |\n\t\t     (((ulWidth / 32) - 1) << 23));\n\t}\n\n\tSTG_WRITE_REG(DACOverlaySize, tmp);\n\n\t \n\ttmp = ((ulLeft << 16)) | (srcDest.ulDstY1);\n\tSTG_WRITE_REG(DACVidWinStart, tmp);\n\n\t \n\ttmp = ((ulRight) << 16) | (srcDest.ulDstY2);\n\tSTG_WRITE_REG(DACVidWinEnd, tmp);\n\n\t \n\ttmp = STG_READ_REG(DACPixelFormat);\n\ttmp = ((ulExcessPixels << 16) | tmp) & 0x7fffffff;\n\tSTG_WRITE_REG(DACPixelFormat, tmp);\n\n\ttmp = STG_READ_REG(DACHorizontalScal);\n\tCLEAR_BITS_FRM_TO(0, 11);\n\tCLEAR_BITS_FRM_TO(16, 17);\n\ttmp |= ((ulhDecim << 16) | (ulDacXScale));\n\tSTG_WRITE_REG(DACHorizontalScal, tmp);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}