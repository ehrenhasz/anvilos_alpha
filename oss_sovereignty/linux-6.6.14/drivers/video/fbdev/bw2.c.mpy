{
  "module_name": "bw2.c",
  "hash_id": "690bb85228c59f5154511514eb2a0c2fc4dc2019578addd30b5ae8dd2de0a726",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/bw2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/fb.h>\n#include <linux/mm.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <asm/io.h>\n#include <asm/fbio.h>\n\n#include \"sbuslib.h\"\n\n \n\nstatic int bw2_blank(int, struct fb_info *);\n\nstatic int bw2_mmap(struct fb_info *, struct vm_area_struct *);\nstatic int bw2_ioctl(struct fb_info *, unsigned int, unsigned long);\n\n \n\nstatic const struct fb_ops bw2_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_blank\t\t= bw2_blank,\n\t.fb_fillrect\t\t= cfb_fillrect,\n\t.fb_copyarea\t\t= cfb_copyarea,\n\t.fb_imageblit\t\t= cfb_imageblit,\n\t.fb_mmap\t\t= bw2_mmap,\n\t.fb_ioctl\t\t= bw2_ioctl,\n#ifdef CONFIG_COMPAT\n\t.fb_compat_ioctl\t= sbusfb_compat_ioctl,\n#endif\n};\n\n \n#define BWTWO_REGISTER_OFFSET 0x400000\n\nstruct bt_regs {\n\tu32 addr;\n\tu32 color_map;\n\tu32 control;\n\tu32 cursor;\n};\n\nstruct bw2_regs {\n\tstruct bt_regs\tcmap;\n\tu8\tcontrol;\n\tu8\tstatus;\n\tu8\tcursor_start;\n\tu8\tcursor_end;\n\tu8\th_blank_start;\n\tu8\th_blank_end;\n\tu8\th_sync_start;\n\tu8\th_sync_end;\n\tu8\tcomp_sync_end;\n\tu8\tv_blank_start_high;\n\tu8\tv_blank_start_low;\n\tu8\tv_blank_end;\n\tu8\tv_sync_start;\n\tu8\tv_sync_end;\n\tu8\txfer_holdoff_start;\n\tu8\txfer_holdoff_end;\n};\n\n \n#define BWTWO_SR_RES_MASK\t0x70\n#define BWTWO_SR_1600_1280\t0x50\n#define BWTWO_SR_1152_900_76_A\t0x40\n#define BWTWO_SR_1152_900_76_B\t0x60\n#define BWTWO_SR_ID_MASK\t0x0f\n#define BWTWO_SR_ID_MONO\t0x02\n#define BWTWO_SR_ID_MONO_ECL\t0x03\n#define BWTWO_SR_ID_MSYNC\t0x04\n#define BWTWO_SR_ID_NOCONN\t0x0a\n\n \n#define BWTWO_CTL_ENABLE_INTS   0x80\n#define BWTWO_CTL_ENABLE_VIDEO  0x40\n#define BWTWO_CTL_ENABLE_TIMING 0x20\n#define BWTWO_CTL_ENABLE_CURCMP 0x10\n#define BWTWO_CTL_XTAL_MASK     0x0C\n#define BWTWO_CTL_DIVISOR_MASK  0x03\n\n \n#define BWTWO_STAT_PENDING_INT  0x80\n#define BWTWO_STAT_MSENSE_MASK  0x70\n#define BWTWO_STAT_ID_MASK      0x0f\n\nstruct bw2_par {\n\tspinlock_t\t\tlock;\n\tstruct bw2_regs\t\t__iomem *regs;\n\n\tu32\t\t\tflags;\n#define BW2_FLAG_BLANKED\t0x00000001\n\n\tunsigned long\t\twhich_io;\n};\n\n \nstatic int\nbw2_blank(int blank, struct fb_info *info)\n{\n\tstruct bw2_par *par = (struct bw2_par *) info->par;\n\tstruct bw2_regs __iomem *regs = par->regs;\n\tunsigned long flags;\n\tu8 val;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:  \n\t\tval = sbus_readb(&regs->control);\n\t\tval |= BWTWO_CTL_ENABLE_VIDEO;\n\t\tsbus_writeb(val, &regs->control);\n\t\tpar->flags &= ~BW2_FLAG_BLANKED;\n\t\tbreak;\n\n\tcase FB_BLANK_NORMAL:  \n\tcase FB_BLANK_VSYNC_SUSPEND:  \n\tcase FB_BLANK_HSYNC_SUSPEND:  \n\tcase FB_BLANK_POWERDOWN:  \n\t\tval = sbus_readb(&regs->control);\n\t\tval &= ~BWTWO_CTL_ENABLE_VIDEO;\n\t\tsbus_writeb(val, &regs->control);\n\t\tpar->flags |= BW2_FLAG_BLANKED;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&par->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct sbus_mmap_map bw2_mmap_map[] = {\n\t{\n\t\t.size = SBUS_MMAP_FBSIZE(1)\n\t},\n\t{ .size = 0 }\n};\n\nstatic int bw2_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct bw2_par *par = (struct bw2_par *)info->par;\n\n\treturn sbusfb_mmap_helper(bw2_mmap_map,\n\t\t\t\t  info->fix.smem_start, info->fix.smem_len,\n\t\t\t\t  par->which_io,\n\t\t\t\t  vma);\n}\n\nstatic int bw2_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\n{\n\treturn sbusfb_ioctl_helper(cmd, arg, info,\n\t\t\t\t   FBTYPE_SUN2BW, 1, info->fix.smem_len);\n}\n\n \n\nstatic void bw2_init_fix(struct fb_info *info, int linebytes)\n{\n\tstrscpy(info->fix.id, \"bwtwo\", sizeof(info->fix.id));\n\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = FB_VISUAL_MONO01;\n\n\tinfo->fix.line_length = linebytes;\n\n\tinfo->fix.accel = FB_ACCEL_SUN_BWTWO;\n}\n\nstatic u8 bw2regs_1600[] = {\n\t0x14, 0x8b,\t0x15, 0x28,\t0x16, 0x03,\t0x17, 0x13,\n\t0x18, 0x7b,\t0x19, 0x05,\t0x1a, 0x34,\t0x1b, 0x2e,\n\t0x1c, 0x00,\t0x1d, 0x0a,\t0x1e, 0xff,\t0x1f, 0x01,\n\t0x10, 0x21,\t0\n};\n\nstatic u8 bw2regs_ecl[] = {\n\t0x14, 0x65,\t0x15, 0x1e,\t0x16, 0x04,\t0x17, 0x0c,\n\t0x18, 0x5e,\t0x19, 0x03,\t0x1a, 0xa7,\t0x1b, 0x23,\n\t0x1c, 0x00,\t0x1d, 0x08,\t0x1e, 0xff,\t0x1f, 0x01,\n\t0x10, 0x20,\t0\n};\n\nstatic u8 bw2regs_analog[] = {\n\t0x14, 0xbb,\t0x15, 0x2b,\t0x16, 0x03,\t0x17, 0x13,\n\t0x18, 0xb0,\t0x19, 0x03,\t0x1a, 0xa6,\t0x1b, 0x22,\n\t0x1c, 0x01,\t0x1d, 0x05,\t0x1e, 0xff,\t0x1f, 0x01,\n\t0x10, 0x20,\t0\n};\n\nstatic u8 bw2regs_76hz[] = {\n\t0x14, 0xb7,\t0x15, 0x27,\t0x16, 0x03,\t0x17, 0x0f,\n\t0x18, 0xae,\t0x19, 0x03,\t0x1a, 0xae,\t0x1b, 0x2a,\n\t0x1c, 0x01,\t0x1d, 0x09,\t0x1e, 0xff,\t0x1f, 0x01,\n\t0x10, 0x24,\t0\n};\n\nstatic u8 bw2regs_66hz[] = {\n\t0x14, 0xbb,\t0x15, 0x2b,\t0x16, 0x04,\t0x17, 0x14,\n\t0x18, 0xae,\t0x19, 0x03,\t0x1a, 0xa8,\t0x1b, 0x24,\n\t0x1c, 0x01,\t0x1d, 0x05,\t0x1e, 0xff,\t0x1f, 0x01,\n\t0x10, 0x20,\t0\n};\n\nstatic int bw2_do_default_mode(struct bw2_par *par, struct fb_info *info,\n\t\t\t       int *linebytes)\n{\n\tu8 status, mon;\n\tu8 *p;\n\n\tstatus = sbus_readb(&par->regs->status);\n\tmon = status & BWTWO_SR_RES_MASK;\n\tswitch (status & BWTWO_SR_ID_MASK) {\n\tcase BWTWO_SR_ID_MONO_ECL:\n\t\tif (mon == BWTWO_SR_1600_1280) {\n\t\t\tp = bw2regs_1600;\n\t\t\tinfo->var.xres = info->var.xres_virtual = 1600;\n\t\t\tinfo->var.yres = info->var.yres_virtual = 1280;\n\t\t\t*linebytes = 1600 / 8;\n\t\t} else\n\t\t\tp = bw2regs_ecl;\n\t\tbreak;\n\n\tcase BWTWO_SR_ID_MONO:\n\t\tp = bw2regs_analog;\n\t\tbreak;\n\n\tcase BWTWO_SR_ID_MSYNC:\n\t\tif (mon == BWTWO_SR_1152_900_76_A ||\n\t\t    mon == BWTWO_SR_1152_900_76_B)\n\t\t\tp = bw2regs_76hz;\n\t\telse\n\t\t\tp = bw2regs_66hz;\n\t\tbreak;\n\n\tcase BWTWO_SR_ID_NOCONN:\n\t\treturn 0;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"bw2: can't handle SR %02x\\n\",\n\t\t       status);\n\t\treturn -EINVAL;\n\t}\n\tfor ( ; *p; p += 2) {\n\t\tu8 __iomem *regp = &((u8 __iomem *)par->regs)[p[0]];\n\t\tsbus_writeb(p[1], regp);\n\t}\n\treturn 0;\n}\n\nstatic int bw2_probe(struct platform_device *op)\n{\n\tstruct device_node *dp = op->dev.of_node;\n\tstruct fb_info *info;\n\tstruct bw2_par *par;\n\tint linebytes, err;\n\n\tinfo = framebuffer_alloc(sizeof(struct bw2_par), &op->dev);\n\n\terr = -ENOMEM;\n\tif (!info)\n\t\tgoto out_err;\n\tpar = info->par;\n\n\tspin_lock_init(&par->lock);\n\n\tinfo->fix.smem_start = op->resource[0].start;\n\tpar->which_io = op->resource[0].flags & IORESOURCE_BITS;\n\n\tsbusfb_fill_var(&info->var, dp, 1);\n\tlinebytes = of_getintprop_default(dp, \"linebytes\",\n\t\t\t\t\t  info->var.xres);\n\n\tinfo->var.red.length = info->var.green.length =\n\t\tinfo->var.blue.length = info->var.bits_per_pixel;\n\tinfo->var.red.offset = info->var.green.offset =\n\t\tinfo->var.blue.offset = 0;\n\n\tpar->regs = of_ioremap(&op->resource[0], BWTWO_REGISTER_OFFSET,\n\t\t\t       sizeof(struct bw2_regs), \"bw2 regs\");\n\tif (!par->regs)\n\t\tgoto out_release_fb;\n\n\tif (!of_property_present(dp, \"width\")) {\n\t\terr = bw2_do_default_mode(par, info, &linebytes);\n\t\tif (err)\n\t\t\tgoto out_unmap_regs;\n\t}\n\n\tinfo->fix.smem_len = PAGE_ALIGN(linebytes * info->var.yres);\n\n\tinfo->fbops = &bw2_ops;\n\n\tinfo->screen_base = of_ioremap(&op->resource[0], 0,\n\t\t\t\t       info->fix.smem_len, \"bw2 ram\");\n\tif (!info->screen_base) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unmap_regs;\n\t}\n\n\tbw2_blank(FB_BLANK_UNBLANK, info);\n\n\tbw2_init_fix(info, linebytes);\n\n\terr = register_framebuffer(info);\n\tif (err < 0)\n\t\tgoto out_unmap_screen;\n\n\tdev_set_drvdata(&op->dev, info);\n\n\tprintk(KERN_INFO \"%pOF: bwtwo at %lx:%lx\\n\",\n\t       dp, par->which_io, info->fix.smem_start);\n\n\treturn 0;\n\nout_unmap_screen:\n\tof_iounmap(&op->resource[0], info->screen_base, info->fix.smem_len);\n\nout_unmap_regs:\n\tof_iounmap(&op->resource[0], par->regs, sizeof(struct bw2_regs));\n\nout_release_fb:\n\tframebuffer_release(info);\n\nout_err:\n\treturn err;\n}\n\nstatic void bw2_remove(struct platform_device *op)\n{\n\tstruct fb_info *info = dev_get_drvdata(&op->dev);\n\tstruct bw2_par *par = info->par;\n\n\tunregister_framebuffer(info);\n\n\tof_iounmap(&op->resource[0], par->regs, sizeof(struct bw2_regs));\n\tof_iounmap(&op->resource[0], info->screen_base, info->fix.smem_len);\n\n\tframebuffer_release(info);\n}\n\nstatic const struct of_device_id bw2_match[] = {\n\t{\n\t\t.name = \"bwtwo\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bw2_match);\n\nstatic struct platform_driver bw2_driver = {\n\t.driver = {\n\t\t.name = \"bw2\",\n\t\t.of_match_table = bw2_match,\n\t},\n\t.probe\t\t= bw2_probe,\n\t.remove_new\t= bw2_remove,\n};\n\nstatic int __init bw2_init(void)\n{\n\tif (fb_get_options(\"bw2fb\", NULL))\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&bw2_driver);\n}\n\nstatic void __exit bw2_exit(void)\n{\n\tplatform_driver_unregister(&bw2_driver);\n}\n\nmodule_init(bw2_init);\nmodule_exit(bw2_exit);\n\nMODULE_DESCRIPTION(\"framebuffer driver for BWTWO chipsets\");\nMODULE_AUTHOR(\"David S. Miller <davem@davemloft.net>\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}