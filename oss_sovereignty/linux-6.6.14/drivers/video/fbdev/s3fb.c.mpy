{
  "module_name": "s3fb.c",
  "hash_id": "ddac642906a35cd018de089fee4b3137cf8ec057d7363d06a4437273d9aab98f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/s3fb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/tty.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/svga.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/console.h>  \n#include <video/vga.h>\n\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n\nstruct s3fb_info {\n\tint chip, rev, mclk_freq;\n\tint wc_cookie;\n\tstruct vgastate state;\n\tstruct mutex open_lock;\n\tunsigned int ref_count;\n\tu32 pseudo_palette[16];\n#ifdef CONFIG_FB_S3_DDC\n\tu8 __iomem *mmio;\n\tbool ddc_registered;\n\tstruct i2c_adapter ddc_adapter;\n\tstruct i2c_algo_bit_data ddc_algo;\n#endif\n};\n\n\n \n\nstatic const struct svga_fb_format s3fb_formats[] = {\n\t{ 0,  {0, 6, 0},  {0, 6, 0},  {0, 6, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_TEXT, FB_AUX_TEXT_SVGA_STEP4,\tFB_VISUAL_PSEUDOCOLOR, 8, 16},\n\t{ 4,  {0, 4, 0},  {0, 4, 0},  {0, 4, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_PSEUDOCOLOR, 8, 16},\n\t{ 4,  {0, 4, 0},  {0, 4, 0},  {0, 4, 0}, {0, 0, 0}, 1,\n\t\tFB_TYPE_INTERLEAVED_PLANES, 1,\t\tFB_VISUAL_PSEUDOCOLOR, 8, 16},\n\t{ 8,  {0, 8, 0},  {0, 8, 0},  {0, 8, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_PSEUDOCOLOR, 4, 8},\n\t{16,  {10, 5, 0}, {5, 5, 0},  {0, 5, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_TRUECOLOR, 2, 4},\n\t{16,  {11, 5, 0}, {5, 6, 0},  {0, 5, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_TRUECOLOR, 2, 4},\n\t{24,  {16, 8, 0}, {8, 8, 0},  {0, 8, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_TRUECOLOR, 1, 2},\n\t{32,  {16, 8, 0}, {8, 8, 0},  {0, 8, 0}, {0, 0, 0}, 0,\n\t\tFB_TYPE_PACKED_PIXELS, 0,\t\tFB_VISUAL_TRUECOLOR, 1, 2},\n\tSVGA_FORMAT_END\n};\n\n\nstatic const struct svga_pll s3_pll = {3, 129, 3, 33, 0, 3,\n\t35000, 240000, 14318};\nstatic const struct svga_pll s3_trio3d_pll = {3, 129, 3, 31, 0, 4,\n\t230000, 460000, 14318};\n\nstatic const int s3_memsizes[] = {4096, 0, 3072, 8192, 2048, 6144, 1024, 512};\n\nstatic const char * const s3_names[] = {\"S3 Unknown\", \"S3 Trio32\", \"S3 Trio64\", \"S3 Trio64V+\",\n\t\t\t\"S3 Trio64UV+\", \"S3 Trio64V2/DX\", \"S3 Trio64V2/GX\",\n\t\t\t\"S3 Plato/PX\", \"S3 Aurora64V+\", \"S3 Virge\",\n\t\t\t\"S3 Virge/VX\", \"S3 Virge/DX\", \"S3 Virge/GX\",\n\t\t\t\"S3 Virge/GX2\", \"S3 Virge/GX2+\", \"\",\n\t\t\t\"S3 Trio3D/1X\", \"S3 Trio3D/2X\", \"S3 Trio3D/2X\",\n\t\t\t\"S3 Trio3D\", \"S3 Virge/MX\"};\n\n#define CHIP_UNKNOWN\t\t0x00\n#define CHIP_732_TRIO32\t\t0x01\n#define CHIP_764_TRIO64\t\t0x02\n#define CHIP_765_TRIO64VP\t0x03\n#define CHIP_767_TRIO64UVP\t0x04\n#define CHIP_775_TRIO64V2_DX\t0x05\n#define CHIP_785_TRIO64V2_GX\t0x06\n#define CHIP_551_PLATO_PX\t0x07\n#define CHIP_M65_AURORA64VP\t0x08\n#define CHIP_325_VIRGE\t\t0x09\n#define CHIP_988_VIRGE_VX\t0x0A\n#define CHIP_375_VIRGE_DX\t0x0B\n#define CHIP_385_VIRGE_GX\t0x0C\n#define CHIP_357_VIRGE_GX2\t0x0D\n#define CHIP_359_VIRGE_GX2P\t0x0E\n#define CHIP_360_TRIO3D_1X\t0x10\n#define CHIP_362_TRIO3D_2X\t0x11\n#define CHIP_368_TRIO3D_2X\t0x12\n#define CHIP_365_TRIO3D\t\t0x13\n#define CHIP_260_VIRGE_MX\t0x14\n\n#define CHIP_XXX_TRIO\t\t0x80\n#define CHIP_XXX_TRIO64V2_DXGX\t0x81\n#define CHIP_XXX_VIRGE_DXGX\t0x82\n#define CHIP_36X_TRIO3D_1X_2X\t0x83\n\n#define CHIP_UNDECIDED_FLAG\t0x80\n#define CHIP_MASK\t\t0xFF\n\n#define MMIO_OFFSET\t\t0x1000000\n#define MMIO_SIZE\t\t0x10000\n\n \n\nstatic const struct vga_regset s3_h_total_regs[]        = {{0x00, 0, 7}, {0x5D, 0, 0}, VGA_REGSET_END};\nstatic const struct vga_regset s3_h_display_regs[]      = {{0x01, 0, 7}, {0x5D, 1, 1}, VGA_REGSET_END};\nstatic const struct vga_regset s3_h_blank_start_regs[]  = {{0x02, 0, 7}, {0x5D, 2, 2}, VGA_REGSET_END};\nstatic const struct vga_regset s3_h_blank_end_regs[]    = {{0x03, 0, 4}, {0x05, 7, 7}, VGA_REGSET_END};\nstatic const struct vga_regset s3_h_sync_start_regs[]   = {{0x04, 0, 7}, {0x5D, 4, 4}, VGA_REGSET_END};\nstatic const struct vga_regset s3_h_sync_end_regs[]     = {{0x05, 0, 4}, VGA_REGSET_END};\n\nstatic const struct vga_regset s3_v_total_regs[]        = {{0x06, 0, 7}, {0x07, 0, 0}, {0x07, 5, 5}, {0x5E, 0, 0}, VGA_REGSET_END};\nstatic const struct vga_regset s3_v_display_regs[]      = {{0x12, 0, 7}, {0x07, 1, 1}, {0x07, 6, 6}, {0x5E, 1, 1}, VGA_REGSET_END};\nstatic const struct vga_regset s3_v_blank_start_regs[]  = {{0x15, 0, 7}, {0x07, 3, 3}, {0x09, 5, 5}, {0x5E, 2, 2}, VGA_REGSET_END};\nstatic const struct vga_regset s3_v_blank_end_regs[]    = {{0x16, 0, 7}, VGA_REGSET_END};\nstatic const struct vga_regset s3_v_sync_start_regs[]   = {{0x10, 0, 7}, {0x07, 2, 2}, {0x07, 7, 7}, {0x5E, 4, 4}, VGA_REGSET_END};\nstatic const struct vga_regset s3_v_sync_end_regs[]     = {{0x11, 0, 3}, VGA_REGSET_END};\n\nstatic const struct vga_regset s3_line_compare_regs[]   = {{0x18, 0, 7}, {0x07, 4, 4}, {0x09, 6, 6}, {0x5E, 6, 6}, VGA_REGSET_END};\nstatic const struct vga_regset s3_start_address_regs[]  = {{0x0d, 0, 7}, {0x0c, 0, 7}, {0x69, 0, 4}, VGA_REGSET_END};\nstatic const struct vga_regset s3_offset_regs[]         = {{0x13, 0, 7}, {0x51, 4, 5}, VGA_REGSET_END};  \n\nstatic const struct vga_regset s3_dtpc_regs[]\t\t= {{0x3B, 0, 7}, {0x5D, 6, 6}, VGA_REGSET_END};\n\nstatic const struct svga_timing_regs s3_timing_regs     = {\n\ts3_h_total_regs, s3_h_display_regs, s3_h_blank_start_regs,\n\ts3_h_blank_end_regs, s3_h_sync_start_regs, s3_h_sync_end_regs,\n\ts3_v_total_regs, s3_v_display_regs, s3_v_blank_start_regs,\n\ts3_v_blank_end_regs, s3_v_sync_start_regs, s3_v_sync_end_regs,\n};\n\n\n \n\n \n\n\nstatic char *mode_option;\nstatic int mtrr = 1;\nstatic int fasttext = 1;\n\n\nMODULE_AUTHOR(\"(c) 2006-2007 Ondrej Zajicek <santiago@crfreenet.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"fbdev driver for S3 Trio/Virge\");\n\nmodule_param(mode_option, charp, 0444);\nMODULE_PARM_DESC(mode_option, \"Default video mode ('640x480-8@60', etc)\");\nmodule_param_named(mode, mode_option, charp, 0444);\nMODULE_PARM_DESC(mode, \"Default video mode ('640x480-8@60', etc) (deprecated)\");\nmodule_param(mtrr, int, 0444);\nMODULE_PARM_DESC(mtrr, \"Enable write-combining with MTRR (1=enable, 0=disable, default=1)\");\n\nmodule_param(fasttext, int, 0644);\nMODULE_PARM_DESC(fasttext, \"Enable S3 fast text mode (1=enable, 0=disable, default=1)\");\n\n\n \n\n#ifdef CONFIG_FB_S3_DDC\n\n#define DDC_REG\t\t0xaa\t\t \n#define DDC_MMIO_REG\t0xff20\t\t \n#define DDC_SCL_OUT\t(1 << 0)\n#define DDC_SDA_OUT\t(1 << 1)\n#define DDC_SCL_IN\t(1 << 2)\n#define DDC_SDA_IN\t(1 << 3)\n#define DDC_DRIVE_EN\t(1 << 4)\n\nstatic bool s3fb_ddc_needs_mmio(int chip)\n{\n\treturn !(chip == CHIP_360_TRIO3D_1X  ||\n\t\t chip == CHIP_362_TRIO3D_2X  ||\n\t\t chip == CHIP_368_TRIO3D_2X);\n}\n\nstatic u8 s3fb_ddc_read(struct s3fb_info *par)\n{\n\tif (s3fb_ddc_needs_mmio(par->chip))\n\t\treturn readb(par->mmio + DDC_MMIO_REG);\n\telse\n\t\treturn vga_rcrt(par->state.vgabase, DDC_REG);\n}\n\nstatic void s3fb_ddc_write(struct s3fb_info *par, u8 val)\n{\n\tif (s3fb_ddc_needs_mmio(par->chip))\n\t\twriteb(val, par->mmio + DDC_MMIO_REG);\n\telse\n\t\tvga_wcrt(par->state.vgabase, DDC_REG, val);\n}\n\nstatic void s3fb_ddc_setscl(void *data, int val)\n{\n\tstruct s3fb_info *par = data;\n\tunsigned char reg;\n\n\treg = s3fb_ddc_read(par) | DDC_DRIVE_EN;\n\tif (val)\n\t\treg |= DDC_SCL_OUT;\n\telse\n\t\treg &= ~DDC_SCL_OUT;\n\ts3fb_ddc_write(par, reg);\n}\n\nstatic void s3fb_ddc_setsda(void *data, int val)\n{\n\tstruct s3fb_info *par = data;\n\tunsigned char reg;\n\n\treg = s3fb_ddc_read(par) | DDC_DRIVE_EN;\n\tif (val)\n\t\treg |= DDC_SDA_OUT;\n\telse\n\t\treg &= ~DDC_SDA_OUT;\n\ts3fb_ddc_write(par, reg);\n}\n\nstatic int s3fb_ddc_getscl(void *data)\n{\n\tstruct s3fb_info *par = data;\n\n\treturn !!(s3fb_ddc_read(par) & DDC_SCL_IN);\n}\n\nstatic int s3fb_ddc_getsda(void *data)\n{\n\tstruct s3fb_info *par = data;\n\n\treturn !!(s3fb_ddc_read(par) & DDC_SDA_IN);\n}\n\nstatic int s3fb_setup_ddc_bus(struct fb_info *info)\n{\n\tstruct s3fb_info *par = info->par;\n\n\tstrscpy(par->ddc_adapter.name, info->fix.id,\n\t\tsizeof(par->ddc_adapter.name));\n\tpar->ddc_adapter.owner\t\t= THIS_MODULE;\n\tpar->ddc_adapter.class\t\t= I2C_CLASS_DDC;\n\tpar->ddc_adapter.algo_data\t= &par->ddc_algo;\n\tpar->ddc_adapter.dev.parent\t= info->device;\n\tpar->ddc_algo.setsda\t\t= s3fb_ddc_setsda;\n\tpar->ddc_algo.setscl\t\t= s3fb_ddc_setscl;\n\tpar->ddc_algo.getsda\t\t= s3fb_ddc_getsda;\n\tpar->ddc_algo.getscl\t\t= s3fb_ddc_getscl;\n\tpar->ddc_algo.udelay\t\t= 10;\n\tpar->ddc_algo.timeout\t\t= 20;\n\tpar->ddc_algo.data\t\t= par;\n\n\ti2c_set_adapdata(&par->ddc_adapter, par);\n\n\t \n \n\tif (par->chip == CHIP_357_VIRGE_GX2 ||\n\t    par->chip == CHIP_359_VIRGE_GX2P ||\n\t    par->chip == CHIP_260_VIRGE_MX)\n\t\tsvga_wseq_mask(par->state.vgabase, 0x0d, 0x01, 0x03);\n\telse\n\t\tsvga_wseq_mask(par->state.vgabase, 0x0d, 0x00, 0x03);\n\t \n\tsvga_wcrt_mask(par->state.vgabase, 0x5c, 0x03, 0x03);\n\n\treturn i2c_bit_add_bus(&par->ddc_adapter);\n}\n#endif  \n\n\n \n\n \n\nstatic void s3fb_settile_fast(struct fb_info *info, struct fb_tilemap *map)\n{\n\tconst u8 *font = map->data;\n\tu8 __iomem *fb = (u8 __iomem *) info->screen_base;\n\tint i, c;\n\n\tif ((map->width != 8) || (map->height != 16) ||\n\t    (map->depth != 1) || (map->length != 256)) {\n\t\tfb_err(info, \"unsupported font parameters: width %d, height %d, depth %d, length %d\\n\",\n\t\t       map->width, map->height, map->depth, map->length);\n\t\treturn;\n\t}\n\n\tfb += 2;\n\tfor (i = 0; i < map->height; i++) {\n\t\tfor (c = 0; c < map->length; c++) {\n\t\t\tfb_writeb(font[c * map->height + i], fb + c * 4);\n\t\t}\n\t\tfb += 1024;\n\t}\n}\n\nstatic void s3fb_tilecursor(struct fb_info *info, struct fb_tilecursor *cursor)\n{\n\tstruct s3fb_info *par = info->par;\n\n\tsvga_tilecursor(par->state.vgabase, info, cursor);\n}\n\nstatic struct fb_tile_ops s3fb_tile_ops = {\n\t.fb_settile\t= svga_settile,\n\t.fb_tilecopy\t= svga_tilecopy,\n\t.fb_tilefill    = svga_tilefill,\n\t.fb_tileblit    = svga_tileblit,\n\t.fb_tilecursor  = s3fb_tilecursor,\n\t.fb_get_tilemax = svga_get_tilemax,\n};\n\nstatic struct fb_tile_ops s3fb_fast_tile_ops = {\n\t.fb_settile\t= s3fb_settile_fast,\n\t.fb_tilecopy\t= svga_tilecopy,\n\t.fb_tilefill    = svga_tilefill,\n\t.fb_tileblit    = svga_tileblit,\n\t.fb_tilecursor  = s3fb_tilecursor,\n\t.fb_get_tilemax = svga_get_tilemax,\n};\n\n\n \n\n \nstatic inline u32 expand_color(u32 c)\n{\n\treturn ((c & 1) | ((c & 2) << 7) | ((c & 4) << 14) | ((c & 8) << 21)) * 0xFF;\n}\n\n \nstatic void s3fb_iplan_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tu32 fg = expand_color(image->fg_color);\n\tu32 bg = expand_color(image->bg_color);\n\tconst u8 *src1, *src;\n\tu8 __iomem *dst1;\n\tu32 __iomem *dst;\n\tu32 val;\n\tint x, y;\n\n\tsrc1 = image->data;\n\tdst1 = info->screen_base + (image->dy * info->fix.line_length)\n\t\t + ((image->dx / 8) * 4);\n\n\tfor (y = 0; y < image->height; y++) {\n\t\tsrc = src1;\n\t\tdst = (u32 __iomem *) dst1;\n\t\tfor (x = 0; x < image->width; x += 8) {\n\t\t\tval = *(src++) * 0x01010101;\n\t\t\tval = (val & fg) | (~val & bg);\n\t\t\tfb_writel(val, dst++);\n\t\t}\n\t\tsrc1 += image->width / 8;\n\t\tdst1 += info->fix.line_length;\n\t}\n\n}\n\n \nstatic void s3fb_iplan_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tu32 fg = expand_color(rect->color);\n\tu8 __iomem *dst1;\n\tu32 __iomem *dst;\n\tint x, y;\n\n\tdst1 = info->screen_base + (rect->dy * info->fix.line_length)\n\t\t + ((rect->dx / 8) * 4);\n\n\tfor (y = 0; y < rect->height; y++) {\n\t\tdst = (u32 __iomem *) dst1;\n\t\tfor (x = 0; x < rect->width; x += 8) {\n\t\t\tfb_writel(fg, dst++);\n\t\t}\n\t\tdst1 += info->fix.line_length;\n\t}\n}\n\n\n \nstatic inline u32 expand_pixel(u32 c)\n{\n\treturn (((c &  1) << 24) | ((c &  2) << 27) | ((c &  4) << 14) | ((c &   8) << 17) |\n\t\t((c & 16) <<  4) | ((c & 32) <<  7) | ((c & 64) >>  6) | ((c & 128) >>  3)) * 0xF;\n}\n\n \nstatic void s3fb_cfb4_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tu32 fg = image->fg_color * 0x11111111;\n\tu32 bg = image->bg_color * 0x11111111;\n\tconst u8 *src1, *src;\n\tu8 __iomem *dst1;\n\tu32 __iomem *dst;\n\tu32 val;\n\tint x, y;\n\n\tsrc1 = image->data;\n\tdst1 = info->screen_base + (image->dy * info->fix.line_length)\n\t\t + ((image->dx / 8) * 4);\n\n\tfor (y = 0; y < image->height; y++) {\n\t\tsrc = src1;\n\t\tdst = (u32 __iomem *) dst1;\n\t\tfor (x = 0; x < image->width; x += 8) {\n\t\t\tval = expand_pixel(*(src++));\n\t\t\tval = (val & fg) | (~val & bg);\n\t\t\tfb_writel(val, dst++);\n\t\t}\n\t\tsrc1 += image->width / 8;\n\t\tdst1 += info->fix.line_length;\n\t}\n}\n\nstatic void s3fb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tif ((info->var.bits_per_pixel == 4) && (image->depth == 1)\n\t    && ((image->width % 8) == 0) && ((image->dx % 8) == 0)) {\n\t\tif (info->fix.type == FB_TYPE_INTERLEAVED_PLANES)\n\t\t\ts3fb_iplan_imageblit(info, image);\n\t\telse\n\t\t\ts3fb_cfb4_imageblit(info, image);\n\t} else\n\t\tcfb_imageblit(info, image);\n}\n\nstatic void s3fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tif ((info->var.bits_per_pixel == 4)\n\t    && ((rect->width % 8) == 0) && ((rect->dx % 8) == 0)\n\t    && (info->fix.type == FB_TYPE_INTERLEAVED_PLANES))\n\t\ts3fb_iplan_fillrect(info, rect);\n\t else\n\t\tcfb_fillrect(info, rect);\n}\n\n\n\n \n\n\nstatic void s3_set_pixclock(struct fb_info *info, u32 pixclock)\n{\n\tstruct s3fb_info *par = info->par;\n\tu16 m, n, r;\n\tu8 regval;\n\tint rv;\n\n\trv = svga_compute_pll((par->chip == CHIP_365_TRIO3D) ? &s3_trio3d_pll : &s3_pll,\n\t\t\t      1000000000 / pixclock, &m, &n, &r, info->node);\n\tif (rv < 0) {\n\t\tfb_err(info, \"cannot set requested pixclock, keeping old value\\n\");\n\t\treturn;\n\t}\n\n\t \n\tregval = vga_r(par->state.vgabase, VGA_MIS_R);\n\tvga_w(par->state.vgabase, VGA_MIS_W, regval | VGA_MIS_ENB_PLL_LOAD);\n\n\t \n\tif (par->chip == CHIP_357_VIRGE_GX2 ||\n\t    par->chip == CHIP_359_VIRGE_GX2P ||\n\t    par->chip == CHIP_360_TRIO3D_1X ||\n\t    par->chip == CHIP_362_TRIO3D_2X ||\n\t    par->chip == CHIP_368_TRIO3D_2X ||\n\t    par->chip == CHIP_260_VIRGE_MX) {\n\t\tvga_wseq(par->state.vgabase, 0x12, (n - 2) | ((r & 3) << 6));\t \n\t\tvga_wseq(par->state.vgabase, 0x29, r >> 2);  \n\t} else\n\t\tvga_wseq(par->state.vgabase, 0x12, (n - 2) | (r << 5));\n\tvga_wseq(par->state.vgabase, 0x13, m - 2);\n\n\tudelay(1000);\n\n\t \n\tregval = vga_rseq (par->state.vgabase, 0x15);  \n\tvga_wseq(par->state.vgabase, 0x15, regval & ~(1<<5));\n\tvga_wseq(par->state.vgabase, 0x15, regval |  (1<<5));\n\tvga_wseq(par->state.vgabase, 0x15, regval & ~(1<<5));\n}\n\n\n \n\nstatic int s3fb_open(struct fb_info *info, int user)\n{\n\tstruct s3fb_info *par = info->par;\n\n\tmutex_lock(&(par->open_lock));\n\tif (par->ref_count == 0) {\n\t\tvoid __iomem *vgabase = par->state.vgabase;\n\n\t\tmemset(&(par->state), 0, sizeof(struct vgastate));\n\t\tpar->state.vgabase = vgabase;\n\t\tpar->state.flags = VGA_SAVE_MODE | VGA_SAVE_FONTS | VGA_SAVE_CMAP;\n\t\tpar->state.num_crtc = 0x70;\n\t\tpar->state.num_seq = 0x20;\n\t\tsave_vga(&(par->state));\n\t}\n\n\tpar->ref_count++;\n\tmutex_unlock(&(par->open_lock));\n\n\treturn 0;\n}\n\n \n\nstatic int s3fb_release(struct fb_info *info, int user)\n{\n\tstruct s3fb_info *par = info->par;\n\n\tmutex_lock(&(par->open_lock));\n\tif (par->ref_count == 0) {\n\t\tmutex_unlock(&(par->open_lock));\n\t\treturn -EINVAL;\n\t}\n\n\tif (par->ref_count == 1)\n\t\trestore_vga(&(par->state));\n\n\tpar->ref_count--;\n\tmutex_unlock(&(par->open_lock));\n\n\treturn 0;\n}\n\n \n\nstatic int s3fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct s3fb_info *par = info->par;\n\tint rv, mem, step;\n\tu16 m, n, r;\n\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\t \n\trv = svga_match_format (s3fb_formats, var, NULL);\n\n\t \n\tif ((par->chip == CHIP_988_VIRGE_VX) ? (rv == 7) : (rv == 6))\n\t\trv = -EINVAL;\n\n\tif (rv < 0) {\n\t\tfb_err(info, \"unsupported mode requested\\n\");\n\t\treturn rv;\n\t}\n\n\t \n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\n\t \n\tstep = s3fb_formats[rv].xresstep - 1;\n\tvar->xres_virtual = (var->xres_virtual+step) & ~step;\n\n\t \n\tmem = ((var->bits_per_pixel * var->xres_virtual) >> 3) * var->yres_virtual;\n\tif (mem > info->screen_size) {\n\t\tfb_err(info, \"not enough framebuffer memory (%d kB requested , %u kB available)\\n\",\n\t\t       mem >> 10, (unsigned int) (info->screen_size >> 10));\n\t\treturn -EINVAL;\n\t}\n\n\trv = svga_check_timings (&s3_timing_regs, var, info->node);\n\tif (rv < 0) {\n\t\tfb_err(info, \"invalid timings requested\\n\");\n\t\treturn rv;\n\t}\n\n\trv = svga_compute_pll(&s3_pll, PICOS2KHZ(var->pixclock), &m, &n, &r,\n\t\t\t\tinfo->node);\n\tif (rv < 0) {\n\t\tfb_err(info, \"invalid pixclock value requested\\n\");\n\t\treturn rv;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int s3fb_set_par(struct fb_info *info)\n{\n\tstruct s3fb_info *par = info->par;\n\tu32 value, mode, hmul, offset_value, screen_size, multiplex, dbytes;\n\tu32 bpp = info->var.bits_per_pixel;\n\tu32 htotal, hsstart;\n\n\tif (bpp != 0) {\n\t\tinfo->fix.ypanstep = 1;\n\t\tinfo->fix.line_length = (info->var.xres_virtual * bpp) / 8;\n\n\t\tinfo->flags &= ~FBINFO_MISC_TILEBLITTING;\n\t\tinfo->tileops = NULL;\n\n\t\t \n\t\tinfo->pixmap.blit_x = (bpp == 4) ? (1 << (8 - 1)) : (~(u32)0);\n\t\tinfo->pixmap.blit_y = ~(u32)0;\n\n\t\toffset_value = (info->var.xres_virtual * bpp) / 64;\n\t\tscreen_size = info->var.yres_virtual * info->fix.line_length;\n\t} else {\n\t\tinfo->fix.ypanstep = 16;\n\t\tinfo->fix.line_length = 0;\n\n\t\tinfo->flags |= FBINFO_MISC_TILEBLITTING;\n\t\tinfo->tileops = fasttext ? &s3fb_fast_tile_ops : &s3fb_tile_ops;\n\n\t\t \n\t\tinfo->pixmap.blit_x = 1 << (8 - 1);\n\t\tinfo->pixmap.blit_y = 1 << (16 - 1);\n\n\t\toffset_value = info->var.xres_virtual / 16;\n\t\tscreen_size = (info->var.xres_virtual * info->var.yres_virtual) / 64;\n\t}\n\n\tinfo->var.xoffset = 0;\n\tinfo->var.yoffset = 0;\n\tinfo->var.activate = FB_ACTIVATE_NOW;\n\n\t \n\tvga_wcrt(par->state.vgabase, 0x38, 0x48);\n\tvga_wcrt(par->state.vgabase, 0x39, 0xA5);\n\tvga_wseq(par->state.vgabase, 0x08, 0x06);\n\tsvga_wcrt_mask(par->state.vgabase, 0x11, 0x00, 0x80);\n\n\t \n\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\tsvga_wcrt_mask(par->state.vgabase, 0x17, 0x00, 0x80);\n\n\t \n\tsvga_set_default_gfx_regs(par->state.vgabase);\n\tsvga_set_default_atc_regs(par->state.vgabase);\n\tsvga_set_default_seq_regs(par->state.vgabase);\n\tsvga_set_default_crt_regs(par->state.vgabase);\n\tsvga_wcrt_multi(par->state.vgabase, s3_line_compare_regs, 0xFFFFFFFF);\n\tsvga_wcrt_multi(par->state.vgabase, s3_start_address_regs, 0);\n\n\t \n\tsvga_wcrt_mask(par->state.vgabase, 0x58, 0x10, 0x10);  \n\tsvga_wcrt_mask(par->state.vgabase, 0x31, 0x08, 0x08);  \n\n   \n   \n\tsvga_wcrt_mask(par->state.vgabase, 0x33, 0x00, 0x08);  \n\tsvga_wcrt_mask(par->state.vgabase, 0x43, 0x00, 0x01);  \n\n\tsvga_wcrt_mask(par->state.vgabase, 0x5D, 0x00, 0x28);  \n\n \n\n   \n   \n\n\n\t \n\tfb_dbg(info, \"offset register       : %d\\n\", offset_value);\n\tsvga_wcrt_multi(par->state.vgabase, s3_offset_regs, offset_value);\n\n\tif (par->chip != CHIP_357_VIRGE_GX2 &&\n\t    par->chip != CHIP_359_VIRGE_GX2P &&\n\t    par->chip != CHIP_360_TRIO3D_1X &&\n\t    par->chip != CHIP_362_TRIO3D_2X &&\n\t    par->chip != CHIP_368_TRIO3D_2X &&\n\t    par->chip != CHIP_260_VIRGE_MX) {\n\t\tvga_wcrt(par->state.vgabase, 0x54, 0x18);  \n\t\tvga_wcrt(par->state.vgabase, 0x60, 0xff);  \n\t\tvga_wcrt(par->state.vgabase, 0x61, 0xff);  \n\t\tvga_wcrt(par->state.vgabase, 0x62, 0xff);  \n\t}\n\n\tvga_wcrt(par->state.vgabase, 0x3A, 0x35);\n\tsvga_wattr(par->state.vgabase, 0x33, 0x00);\n\n\tif (info->var.vmode & FB_VMODE_DOUBLE)\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x09, 0x80, 0x80);\n\telse\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x09, 0x00, 0x80);\n\n\tif (info->var.vmode & FB_VMODE_INTERLACED)\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x42, 0x20, 0x20);\n\telse\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x42, 0x00, 0x20);\n\n\t \n\tsvga_wcrt_mask(par->state.vgabase, 0x45, 0x00, 0x01);\n\t \n\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x00, 0x0C);\n\n\tmode = svga_match_format(s3fb_formats, &(info->var), &(info->fix));\n\n\t \n\tif (par->chip == CHIP_375_VIRGE_DX) {\n\t\tvga_wcrt(par->state.vgabase, 0x86, 0x80);\n\t\tvga_wcrt(par->state.vgabase, 0x90, 0x00);\n\t}\n\n\t \n\tif (par->chip == CHIP_988_VIRGE_VX) {\n\t\tvga_wcrt(par->state.vgabase, 0x50, 0x00);\n\t\tvga_wcrt(par->state.vgabase, 0x67, 0x50);\n\t\tmsleep(10);  \n\t\tvga_wcrt(par->state.vgabase, 0x63, (mode <= 2) ? 0x90 : 0x09);\n\t\tvga_wcrt(par->state.vgabase, 0x66, 0x90);\n\t}\n\n\tif (par->chip == CHIP_357_VIRGE_GX2 ||\n\t    par->chip == CHIP_359_VIRGE_GX2P ||\n\t    par->chip == CHIP_360_TRIO3D_1X ||\n\t    par->chip == CHIP_362_TRIO3D_2X ||\n\t    par->chip == CHIP_368_TRIO3D_2X ||\n\t    par->chip == CHIP_365_TRIO3D    ||\n\t    par->chip == CHIP_375_VIRGE_DX  ||\n\t    par->chip == CHIP_385_VIRGE_GX  ||\n\t    par->chip == CHIP_260_VIRGE_MX) {\n\t\tdbytes = info->var.xres * ((bpp+7)/8);\n\t\tvga_wcrt(par->state.vgabase, 0x91, (dbytes + 7) / 8);\n\t\tvga_wcrt(par->state.vgabase, 0x90, (((dbytes + 7) / 8) >> 8) | 0x80);\n\n\t\tvga_wcrt(par->state.vgabase, 0x66, 0x81);\n\t}\n\n\tif (par->chip == CHIP_357_VIRGE_GX2  ||\n\t    par->chip == CHIP_359_VIRGE_GX2P ||\n\t    par->chip == CHIP_360_TRIO3D_1X ||\n\t    par->chip == CHIP_362_TRIO3D_2X ||\n\t    par->chip == CHIP_368_TRIO3D_2X ||\n\t    par->chip == CHIP_260_VIRGE_MX)\n\t\tvga_wcrt(par->state.vgabase, 0x34, 0x00);\n\telse\t \n\t\tvga_wcrt(par->state.vgabase, 0x34, 0x10);\n\n\tsvga_wcrt_mask(par->state.vgabase, 0x31, 0x00, 0x40);\n\tmultiplex = 0;\n\thmul = 1;\n\n\t \n\tswitch (mode) {\n\tcase 0:\n\t\tfb_dbg(info, \"text mode\\n\");\n\t\tsvga_set_textmode_vga_regs(par->state.vgabase);\n\n\t\t \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x50, 0x00, 0x30);\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x00, 0xF0);\n\n\t\t \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x3A, 0x00, 0x30);\n\n\t\tif (fasttext) {\n\t\t\tfb_dbg(info, \"high speed text mode set\\n\");\n\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x31, 0x40, 0x40);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tfb_dbg(info, \"4 bit pseudocolor\\n\");\n\t\tvga_wgfx(par->state.vgabase, VGA_GFX_MODE, 0x40);\n\n\t\t \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x50, 0x00, 0x30);\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x00, 0xF0);\n\n\t\t \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x3A, 0x00, 0x30);\n\t\tbreak;\n\tcase 2:\n\t\tfb_dbg(info, \"4 bit pseudocolor, planar\\n\");\n\n\t\t \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x50, 0x00, 0x30);\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x00, 0xF0);\n\n\t\t \n\t\tsvga_wcrt_mask(par->state.vgabase, 0x3A, 0x00, 0x30);\n\t\tbreak;\n\tcase 3:\n\t\tfb_dbg(info, \"8 bit pseudocolor\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x50, 0x00, 0x30);\n\t\tif (info->var.pixclock > 20000 ||\n\t\t    par->chip == CHIP_357_VIRGE_GX2 ||\n\t\t    par->chip == CHIP_359_VIRGE_GX2P ||\n\t\t    par->chip == CHIP_360_TRIO3D_1X ||\n\t\t    par->chip == CHIP_362_TRIO3D_2X ||\n\t\t    par->chip == CHIP_368_TRIO3D_2X ||\n\t\t    par->chip == CHIP_260_VIRGE_MX)\n\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x00, 0xF0);\n\t\telse {\n\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x10, 0xF0);\n\t\t\tmultiplex = 1;\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tfb_dbg(info, \"5/5/5 truecolor\\n\");\n\t\tif (par->chip == CHIP_988_VIRGE_VX) {\n\t\t\tif (info->var.pixclock > 20000)\n\t\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x20, 0xF0);\n\t\t\telse\n\t\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x30, 0xF0);\n\t\t} else if (par->chip == CHIP_365_TRIO3D) {\n\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x50, 0x10, 0x30);\n\t\t\tif (info->var.pixclock > 8695) {\n\t\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x30, 0xF0);\n\t\t\t\thmul = 2;\n\t\t\t} else {\n\t\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x20, 0xF0);\n\t\t\t\tmultiplex = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x50, 0x10, 0x30);\n\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x30, 0xF0);\n\t\t\tif (par->chip != CHIP_357_VIRGE_GX2 &&\n\t\t\t    par->chip != CHIP_359_VIRGE_GX2P &&\n\t\t\t    par->chip != CHIP_360_TRIO3D_1X &&\n\t\t\t    par->chip != CHIP_362_TRIO3D_2X &&\n\t\t\t    par->chip != CHIP_368_TRIO3D_2X &&\n\t\t\t    par->chip != CHIP_260_VIRGE_MX)\n\t\t\t\thmul = 2;\n\t\t}\n\t\tbreak;\n\tcase 5:\n\t\tfb_dbg(info, \"5/6/5 truecolor\\n\");\n\t\tif (par->chip == CHIP_988_VIRGE_VX) {\n\t\t\tif (info->var.pixclock > 20000)\n\t\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x40, 0xF0);\n\t\t\telse\n\t\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x50, 0xF0);\n\t\t} else if (par->chip == CHIP_365_TRIO3D) {\n\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x50, 0x10, 0x30);\n\t\t\tif (info->var.pixclock > 8695) {\n\t\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x50, 0xF0);\n\t\t\t\thmul = 2;\n\t\t\t} else {\n\t\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x40, 0xF0);\n\t\t\t\tmultiplex = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x50, 0x10, 0x30);\n\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0x50, 0xF0);\n\t\t\tif (par->chip != CHIP_357_VIRGE_GX2 &&\n\t\t\t    par->chip != CHIP_359_VIRGE_GX2P &&\n\t\t\t    par->chip != CHIP_360_TRIO3D_1X &&\n\t\t\t    par->chip != CHIP_362_TRIO3D_2X &&\n\t\t\t    par->chip != CHIP_368_TRIO3D_2X &&\n\t\t\t    par->chip != CHIP_260_VIRGE_MX)\n\t\t\t\thmul = 2;\n\t\t}\n\t\tbreak;\n\tcase 6:\n\t\t \n\t\tfb_dbg(info, \"8/8/8 truecolor\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0xD0, 0xF0);\n\t\tbreak;\n\tcase 7:\n\t\tfb_dbg(info, \"8/8/8/8 truecolor\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x50, 0x30, 0x30);\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x67, 0xD0, 0xF0);\n\t\tbreak;\n\tdefault:\n\t\tfb_err(info, \"unsupported mode - bug\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (par->chip != CHIP_988_VIRGE_VX) {\n\t\tsvga_wseq_mask(par->state.vgabase, 0x15, multiplex ? 0x10 : 0x00, 0x10);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x18, multiplex ? 0x80 : 0x00, 0x80);\n\t}\n\n\ts3_set_pixclock(info, info->var.pixclock);\n\tsvga_set_timings(par->state.vgabase, &s3_timing_regs, &(info->var), hmul, 1,\n\t\t\t (info->var.vmode & FB_VMODE_DOUBLE)     ? 2 : 1,\n\t\t\t (info->var.vmode & FB_VMODE_INTERLACED) ? 2 : 1,\n\t\t\t hmul, info->node);\n\n\t \n\thtotal = info->var.xres + info->var.left_margin + info->var.right_margin + info->var.hsync_len;\n\thtotal = ((htotal * hmul) / 8) - 5;\n\tvga_wcrt(par->state.vgabase, 0x3C, (htotal + 1) / 2);\n\n\t \n\thsstart = ((info->var.xres + info->var.right_margin) * hmul) / 8;\n\t \n\tvalue = clamp((htotal + hsstart + 1) / 2 + 2, hsstart + 4, htotal + 1);\n\tsvga_wcrt_multi(par->state.vgabase, s3_dtpc_regs, value);\n\n\tif (screen_size > info->screen_size)\n\t\tscreen_size = info->screen_size;\n\tmemset_io(info->screen_base, 0x00, screen_size);\n\t \n\tsvga_wcrt_mask(par->state.vgabase, 0x17, 0x80, 0x80);\n\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x00, 0x20);\n\n\treturn 0;\n}\n\n \n\nstatic int s3fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t\tu_int transp, struct fb_info *fb)\n{\n\tswitch (fb->var.bits_per_pixel) {\n\tcase 0:\n\tcase 4:\n\t\tif (regno >= 16)\n\t\t\treturn -EINVAL;\n\n\t\tif ((fb->var.bits_per_pixel == 4) &&\n\t\t    (fb->var.nonstd == 0)) {\n\t\t\toutb(0xF0, VGA_PEL_MSK);\n\t\t\toutb(regno*16, VGA_PEL_IW);\n\t\t} else {\n\t\t\toutb(0x0F, VGA_PEL_MSK);\n\t\t\toutb(regno, VGA_PEL_IW);\n\t\t}\n\t\toutb(red >> 10, VGA_PEL_D);\n\t\toutb(green >> 10, VGA_PEL_D);\n\t\toutb(blue >> 10, VGA_PEL_D);\n\t\tbreak;\n\tcase 8:\n\t\tif (regno >= 256)\n\t\t\treturn -EINVAL;\n\n\t\toutb(0xFF, VGA_PEL_MSK);\n\t\toutb(regno, VGA_PEL_IW);\n\t\toutb(red >> 10, VGA_PEL_D);\n\t\toutb(green >> 10, VGA_PEL_D);\n\t\toutb(blue >> 10, VGA_PEL_D);\n\t\tbreak;\n\tcase 16:\n\t\tif (regno >= 16)\n\t\t\treturn 0;\n\n\t\tif (fb->var.green.length == 5)\n\t\t\t((u32*)fb->pseudo_palette)[regno] = ((red & 0xF800) >> 1) |\n\t\t\t\t((green & 0xF800) >> 6) | ((blue & 0xF800) >> 11);\n\t\telse if (fb->var.green.length == 6)\n\t\t\t((u32*)fb->pseudo_palette)[regno] = (red & 0xF800) |\n\t\t\t\t((green & 0xFC00) >> 5) | ((blue & 0xF800) >> 11);\n\t\telse return -EINVAL;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tif (regno >= 16)\n\t\t\treturn 0;\n\n\t\t((u32*)fb->pseudo_palette)[regno] = ((red & 0xFF00) << 8) |\n\t\t\t(green & 0xFF00) | ((blue & 0xFF00) >> 8);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\n \n\nstatic int s3fb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct s3fb_info *par = info->par;\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\tfb_dbg(info, \"unblank\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x56, 0x00, 0x06);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x00, 0x20);\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\tfb_dbg(info, \"blank\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x56, 0x00, 0x06);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tfb_dbg(info, \"hsync\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x56, 0x02, 0x06);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tfb_dbg(info, \"vsync\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x56, 0x04, 0x06);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tfb_dbg(info, \"sync down\\n\");\n\t\tsvga_wcrt_mask(par->state.vgabase, 0x56, 0x06, 0x06);\n\t\tsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\n \n\nstatic int s3fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct s3fb_info *par = info->par;\n\tunsigned int offset;\n\n\t \n\tif (info->var.bits_per_pixel == 0) {\n\t\toffset = (var->yoffset / 16) * (info->var.xres_virtual / 2)\n\t\t       + (var->xoffset / 2);\n\t\toffset = offset >> 2;\n\t} else {\n\t\toffset = (var->yoffset * info->fix.line_length) +\n\t\t\t (var->xoffset * info->var.bits_per_pixel / 8);\n\t\toffset = offset >> 2;\n\t}\n\n\t \n\tsvga_wcrt_multi(par->state.vgabase, s3_start_address_regs, offset);\n\n\treturn 0;\n}\n\n \n\n \n\nstatic const struct fb_ops s3fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= s3fb_open,\n\t.fb_release\t= s3fb_release,\n\t.fb_check_var\t= s3fb_check_var,\n\t.fb_set_par\t= s3fb_set_par,\n\t.fb_setcolreg\t= s3fb_setcolreg,\n\t.fb_blank\t= s3fb_blank,\n\t.fb_pan_display\t= s3fb_pan_display,\n\t.fb_fillrect\t= s3fb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= s3fb_imageblit,\n\t.fb_get_caps    = svga_get_caps,\n};\n\n \n\nstatic int s3_identification(struct s3fb_info *par)\n{\n\tint chip = par->chip;\n\n\tif (chip == CHIP_XXX_TRIO) {\n\t\tu8 cr30 = vga_rcrt(par->state.vgabase, 0x30);\n\t\tu8 cr2e = vga_rcrt(par->state.vgabase, 0x2e);\n\t\tu8 cr2f = vga_rcrt(par->state.vgabase, 0x2f);\n\n\t\tif ((cr30 == 0xE0) || (cr30 == 0xE1)) {\n\t\t\tif (cr2e == 0x10)\n\t\t\t\treturn CHIP_732_TRIO32;\n\t\t\tif (cr2e == 0x11) {\n\t\t\t\tif (! (cr2f & 0x40))\n\t\t\t\t\treturn CHIP_764_TRIO64;\n\t\t\t\telse\n\t\t\t\t\treturn CHIP_765_TRIO64VP;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (chip == CHIP_XXX_TRIO64V2_DXGX) {\n\t\tu8 cr6f = vga_rcrt(par->state.vgabase, 0x6f);\n\n\t\tif (! (cr6f & 0x01))\n\t\t\treturn CHIP_775_TRIO64V2_DX;\n\t\telse\n\t\t\treturn CHIP_785_TRIO64V2_GX;\n\t}\n\n\tif (chip == CHIP_XXX_VIRGE_DXGX) {\n\t\tu8 cr6f = vga_rcrt(par->state.vgabase, 0x6f);\n\n\t\tif (! (cr6f & 0x01))\n\t\t\treturn CHIP_375_VIRGE_DX;\n\t\telse\n\t\t\treturn CHIP_385_VIRGE_GX;\n\t}\n\n\tif (chip == CHIP_36X_TRIO3D_1X_2X) {\n\t\tswitch (vga_rcrt(par->state.vgabase, 0x2f)) {\n\t\tcase 0x00:\n\t\t\treturn CHIP_360_TRIO3D_1X;\n\t\tcase 0x01:\n\t\t\treturn CHIP_362_TRIO3D_2X;\n\t\tcase 0x02:\n\t\t\treturn CHIP_368_TRIO3D_2X;\n\t\t}\n\t}\n\n\treturn CHIP_UNKNOWN;\n}\n\n\n \n\nstatic int s3_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct pci_bus_region bus_reg;\n\tstruct resource vga_res;\n\tstruct fb_info *info;\n\tstruct s3fb_info *par;\n\tint rc;\n\tu8 regval, cr38, cr39;\n\tbool found = false;\n\n\t \n\tif (! svga_primary_device(dev)) {\n\t\tdev_info(&(dev->dev), \"ignoring secondary device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trc = aperture_remove_conflicting_pci_devices(dev, \"s3fb\");\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tinfo = framebuffer_alloc(sizeof(struct s3fb_info), &(dev->dev));\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tmutex_init(&par->open_lock);\n\n\tinfo->flags = FBINFO_PARTIAL_PAN_OK | FBINFO_HWACCEL_YPAN;\n\tinfo->fbops = &s3fb_ops;\n\n\t \n\trc = pci_enable_device(dev);\n\tif (rc < 0) {\n\t\tdev_err(info->device, \"cannot enable PCI device\\n\");\n\t\tgoto err_enable_device;\n\t}\n\n\trc = pci_request_regions(dev, \"s3fb\");\n\tif (rc < 0) {\n\t\tdev_err(info->device, \"cannot reserve framebuffer region\\n\");\n\t\tgoto err_request_regions;\n\t}\n\n\n\tinfo->fix.smem_start = pci_resource_start(dev, 0);\n\tinfo->fix.smem_len = pci_resource_len(dev, 0);\n\n\t \n\tinfo->screen_base = pci_iomap_wc(dev, 0, 0);\n\tif (! info->screen_base) {\n\t\trc = -ENOMEM;\n\t\tdev_err(info->device, \"iomap for framebuffer failed\\n\");\n\t\tgoto err_iomap;\n\t}\n\n\tbus_reg.start = 0;\n\tbus_reg.end = 64 * 1024;\n\n\tvga_res.flags = IORESOURCE_IO;\n\n\tpcibios_bus_to_resource(dev->bus, &vga_res, &bus_reg);\n\n\tpar->state.vgabase = (void __iomem *) (unsigned long) vga_res.start;\n\n\t \n\tcr38 = vga_rcrt(par->state.vgabase, 0x38);\n\tcr39 = vga_rcrt(par->state.vgabase, 0x39);\n\tvga_wseq(par->state.vgabase, 0x08, 0x06);\n\tvga_wcrt(par->state.vgabase, 0x38, 0x48);\n\tvga_wcrt(par->state.vgabase, 0x39, 0xA5);\n\n\t \n\tpar->chip = id->driver_data & CHIP_MASK;\n\tpar->rev = vga_rcrt(par->state.vgabase, 0x2f);\n\tif (par->chip & CHIP_UNDECIDED_FLAG)\n\t\tpar->chip = s3_identification(par);\n\n\t \n\t \n\tregval = vga_rcrt(par->state.vgabase, 0x36);\n\tif (par->chip == CHIP_360_TRIO3D_1X ||\n\t    par->chip == CHIP_362_TRIO3D_2X ||\n\t    par->chip == CHIP_368_TRIO3D_2X ||\n\t    par->chip == CHIP_365_TRIO3D) {\n\t\tswitch ((regval & 0xE0) >> 5) {\n\t\tcase 0:  \n\t\tcase 1:  \n\t\tcase 2:\t \n\t\t\tinfo->screen_size = 4 << 20;\n\t\t\tbreak;\n\t\tcase 4:  \n\t\tcase 6:  \n\t\t\tinfo->screen_size = 2 << 20;\n\t\t\tbreak;\n\t\t}\n\t} else if (par->chip == CHIP_357_VIRGE_GX2 ||\n\t\t   par->chip == CHIP_359_VIRGE_GX2P ||\n\t\t   par->chip == CHIP_260_VIRGE_MX) {\n\t\tswitch ((regval & 0xC0) >> 6) {\n\t\tcase 1:  \n\t\t\tinfo->screen_size = 4 << 20;\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tinfo->screen_size = 2 << 20;\n\t\t\tbreak;\n\t\t}\n\t} else if (par->chip == CHIP_988_VIRGE_VX) {\n\t\tswitch ((regval & 0x60) >> 5) {\n\t\tcase 0:  \n\t\t\tinfo->screen_size = 2 << 20;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tinfo->screen_size = 4 << 20;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tinfo->screen_size = 6 << 20;\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tinfo->screen_size = 8 << 20;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tregval = vga_rcrt(par->state.vgabase, 0x37);\n\t\tswitch ((regval & 0x60) >> 5) {\n\t\tcase 1:  \n\t\t\tinfo->screen_size -= 4 << 20;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tinfo->screen_size -= 2 << 20;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tinfo->screen_size = s3_memsizes[regval >> 5] << 10;\n\tinfo->fix.smem_len = info->screen_size;\n\n\t \n\tregval = vga_rseq(par->state.vgabase, 0x10);\n\tpar->mclk_freq = ((vga_rseq(par->state.vgabase, 0x11) + 2) * 14318) / ((regval & 0x1F)  + 2);\n\tpar->mclk_freq = par->mclk_freq >> (regval >> 5);\n\n\t \n\tvga_wcrt(par->state.vgabase, 0x38, cr38);\n\tvga_wcrt(par->state.vgabase, 0x39, cr39);\n\n\tstrcpy(info->fix.id, s3_names [par->chip]);\n\tinfo->fix.mmio_start = 0;\n\tinfo->fix.mmio_len = 0;\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\tinfo->fix.ypanstep = 0;\n\tinfo->fix.accel = FB_ACCEL_NONE;\n\tinfo->pseudo_palette = (void*) (par->pseudo_palette);\n\tinfo->var.bits_per_pixel = 8;\n\n#ifdef CONFIG_FB_S3_DDC\n\t \n\tif (s3fb_ddc_needs_mmio(par->chip)) {\n\t\tpar->mmio = ioremap(info->fix.smem_start + MMIO_OFFSET, MMIO_SIZE);\n\t\tif (par->mmio)\n\t\t\tsvga_wcrt_mask(par->state.vgabase, 0x53, 0x08, 0x08);\t \n\t\telse\n\t\t\tdev_err(info->device, \"unable to map MMIO at 0x%lx, disabling DDC\",\n\t\t\t\tinfo->fix.smem_start + MMIO_OFFSET);\n\t}\n\tif (!s3fb_ddc_needs_mmio(par->chip) || par->mmio)\n\t\tif (s3fb_setup_ddc_bus(info) == 0) {\n\t\t\tu8 *edid = fb_ddc_read(&par->ddc_adapter);\n\t\t\tpar->ddc_registered = true;\n\t\t\tif (edid) {\n\t\t\t\tfb_edid_to_monspecs(edid, &info->monspecs);\n\t\t\t\tkfree(edid);\n\t\t\t\tif (!info->monspecs.modedb)\n\t\t\t\t\tdev_err(info->device, \"error getting mode database\\n\");\n\t\t\t\telse {\n\t\t\t\t\tconst struct fb_videomode *m;\n\n\t\t\t\t\tfb_videomode_to_modelist(info->monspecs.modedb,\n\t\t\t\t\t\t\t\t info->monspecs.modedb_len,\n\t\t\t\t\t\t\t\t &info->modelist);\n\t\t\t\t\tm = fb_find_best_display(&info->monspecs, &info->modelist);\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\tfb_videomode_to_var(&info->var, m);\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (s3fb_check_var(&info->var, info) == 0)\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\tif (!mode_option && !found)\n\t\tmode_option = \"640x480-8@60\";\n\n\t \n\tif (mode_option) {\n\t\trc = fb_find_mode(&info->var, info, mode_option,\n\t\t\t\t   info->monspecs.modedb, info->monspecs.modedb_len,\n\t\t\t\t   NULL, info->var.bits_per_pixel);\n\t\tif (!rc || rc == 4) {\n\t\t\trc = -EINVAL;\n\t\t\tdev_err(info->device, \"mode %s not found\\n\", mode_option);\n\t\t\tfb_destroy_modedb(info->monspecs.modedb);\n\t\t\tinfo->monspecs.modedb = NULL;\n\t\t\tgoto err_find_mode;\n\t\t}\n\t}\n\n\tfb_destroy_modedb(info->monspecs.modedb);\n\tinfo->monspecs.modedb = NULL;\n\n\t \n\tinfo->var.yres_virtual = info->fix.smem_len * 8 /\n\t\t\t(info->var.bits_per_pixel * info->var.xres_virtual);\n\tif (info->var.yres_virtual < info->var.yres) {\n\t\tdev_err(info->device, \"virtual vertical size smaller than real\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_find_mode;\n\t}\n\n\trc = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (rc < 0) {\n\t\tdev_err(info->device, \"cannot allocate colormap\\n\");\n\t\tgoto err_alloc_cmap;\n\t}\n\n\trc = register_framebuffer(info);\n\tif (rc < 0) {\n\t\tdev_err(info->device, \"cannot register framebuffer\\n\");\n\t\tgoto err_reg_fb;\n\t}\n\n\tfb_info(info, \"%s on %s, %d MB RAM, %d MHz MCLK\\n\",\n\t\tinfo->fix.id, pci_name(dev),\n\t\tinfo->fix.smem_len >> 20, (par->mclk_freq + 500) / 1000);\n\n\tif (par->chip == CHIP_UNKNOWN)\n\t\tfb_info(info, \"unknown chip, CR2D=%x, CR2E=%x, CRT2F=%x, CRT30=%x\\n\",\n\t\t\tvga_rcrt(par->state.vgabase, 0x2d),\n\t\t\tvga_rcrt(par->state.vgabase, 0x2e),\n\t\t\tvga_rcrt(par->state.vgabase, 0x2f),\n\t\t\tvga_rcrt(par->state.vgabase, 0x30));\n\n\t \n\tpci_set_drvdata(dev, info);\n\n\tif (mtrr)\n\t\tpar->wc_cookie = arch_phys_wc_add(info->fix.smem_start,\n\t\t\t\t\t\t  info->fix.smem_len);\n\n\treturn 0;\n\n\t \nerr_reg_fb:\n\tfb_dealloc_cmap(&info->cmap);\nerr_alloc_cmap:\nerr_find_mode:\n#ifdef CONFIG_FB_S3_DDC\n\tif (par->ddc_registered)\n\t\ti2c_del_adapter(&par->ddc_adapter);\n\tif (par->mmio)\n\t\tiounmap(par->mmio);\n#endif\n\tpci_iounmap(dev, info->screen_base);\nerr_iomap:\n\tpci_release_regions(dev);\nerr_request_regions:\n \nerr_enable_device:\n\tframebuffer_release(info);\n\treturn rc;\n}\n\n\n \n\nstatic void s3_pci_remove(struct pci_dev *dev)\n{\n\tstruct fb_info *info = pci_get_drvdata(dev);\n\tstruct s3fb_info __maybe_unused *par;\n\n\tif (info) {\n\t\tpar = info->par;\n\t\tarch_phys_wc_del(par->wc_cookie);\n\t\tunregister_framebuffer(info);\n\t\tfb_dealloc_cmap(&info->cmap);\n\n#ifdef CONFIG_FB_S3_DDC\n\t\tif (par->ddc_registered)\n\t\t\ti2c_del_adapter(&par->ddc_adapter);\n\t\tif (par->mmio)\n\t\t\tiounmap(par->mmio);\n#endif\n\n\t\tpci_iounmap(dev, info->screen_base);\n\t\tpci_release_regions(dev);\n \n\n\t\tframebuffer_release(info);\n\t}\n}\n\n \n\nstatic int __maybe_unused s3_pci_suspend(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct s3fb_info *par = info->par;\n\n\tdev_info(info->device, \"suspend\\n\");\n\n\tconsole_lock();\n\tmutex_lock(&(par->open_lock));\n\n\tif (par->ref_count == 0) {\n\t\tmutex_unlock(&(par->open_lock));\n\t\tconsole_unlock();\n\t\treturn 0;\n\t}\n\n\tfb_set_suspend(info, 1);\n\n\tmutex_unlock(&(par->open_lock));\n\tconsole_unlock();\n\n\treturn 0;\n}\n\n\n \n\nstatic int __maybe_unused s3_pci_resume(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct s3fb_info *par = info->par;\n\n\tdev_info(info->device, \"resume\\n\");\n\n\tconsole_lock();\n\tmutex_lock(&(par->open_lock));\n\n\tif (par->ref_count == 0) {\n\t\tmutex_unlock(&(par->open_lock));\n\t\tconsole_unlock();\n\t\treturn 0;\n\t}\n\n\ts3fb_set_par(info);\n\tfb_set_suspend(info, 0);\n\n\tmutex_unlock(&(par->open_lock));\n\tconsole_unlock();\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops s3_pci_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= s3_pci_suspend,\n\t.resume\t\t= s3_pci_resume,\n\t.freeze\t\t= NULL,\n\t.thaw\t\t= s3_pci_resume,\n\t.poweroff\t= s3_pci_suspend,\n\t.restore\t= s3_pci_resume,\n#endif\n};\n\n \n\nstatic const struct pci_device_id s3_devices[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8810), .driver_data = CHIP_XXX_TRIO},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8811), .driver_data = CHIP_XXX_TRIO},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8812), .driver_data = CHIP_M65_AURORA64VP},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8814), .driver_data = CHIP_767_TRIO64UVP},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8901), .driver_data = CHIP_XXX_TRIO64V2_DXGX},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8902), .driver_data = CHIP_551_PLATO_PX},\n\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x5631), .driver_data = CHIP_325_VIRGE},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x883D), .driver_data = CHIP_988_VIRGE_VX},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8A01), .driver_data = CHIP_XXX_VIRGE_DXGX},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8A10), .driver_data = CHIP_357_VIRGE_GX2},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8A11), .driver_data = CHIP_359_VIRGE_GX2P},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8A12), .driver_data = CHIP_359_VIRGE_GX2P},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8A13), .driver_data = CHIP_36X_TRIO3D_1X_2X},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8904), .driver_data = CHIP_365_TRIO3D},\n\t{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8C01), .driver_data = CHIP_260_VIRGE_MX},\n\n\t{0, 0, 0, 0, 0, 0, 0}\n};\n\n\nMODULE_DEVICE_TABLE(pci, s3_devices);\n\nstatic struct pci_driver s3fb_pci_driver = {\n\t.name\t\t= \"s3fb\",\n\t.id_table\t= s3_devices,\n\t.probe\t\t= s3_pci_probe,\n\t.remove\t\t= s3_pci_remove,\n\t.driver.pm\t= &s3_pci_pm_ops,\n};\n\n \n\n#ifndef MODULE\nstatic int  __init s3fb_setup(char *options)\n{\n\tchar *opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((opt = strsep(&options, \",\")) != NULL) {\n\n\t\tif (!*opt)\n\t\t\tcontinue;\n\t\telse if (!strncmp(opt, \"mtrr:\", 5))\n\t\t\tmtrr = simple_strtoul(opt + 5, NULL, 0);\n\t\telse if (!strncmp(opt, \"fasttext:\", 9))\n\t\t\tfasttext = simple_strtoul(opt + 9, NULL, 0);\n\t\telse\n\t\t\tmode_option = opt;\n\t}\n\n\treturn 0;\n}\n#endif\n\n \n\nstatic void __exit s3fb_cleanup(void)\n{\n\tpr_debug(\"s3fb: cleaning up\\n\");\n\tpci_unregister_driver(&s3fb_pci_driver);\n}\n\n \n\nstatic int __init s3fb_init(void)\n{\n\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"s3fb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"s3fb\", &option))\n\t\treturn -ENODEV;\n\ts3fb_setup(option);\n#endif\n\n\tpr_debug(\"s3fb: initializing\\n\");\n\treturn pci_register_driver(&s3fb_pci_driver);\n}\n\n \n\n \n\nmodule_init(s3fb_init);\nmodule_exit(s3fb_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}