{
  "module_name": "pxafb.c",
  "hash_id": "604af9255a6f9fae66702bd8e022d37c58e13c2dc249e0f65651b885a0ec80f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/pxafb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/cpufreq.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/console.h>\n#include <linux/of_graph.h>\n#include <linux/regulator/consumer.h>\n#include <linux/soc/pxa/cpu.h>\n#include <video/of_display_timing.h>\n#include <video/videomode.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/div64.h>\n#include <linux/platform_data/video-pxafb.h>\n\n \n#define DEBUG_VAR 1\n\n#include \"pxafb.h\"\n#include \"pxa3xx-regs.h\"\n\n \n#define LCCR0_INVALID_CONFIG_MASK\t(LCCR0_OUM | LCCR0_BM | LCCR0_QDM |\\\n\t\t\t\t\t LCCR0_DIS | LCCR0_EFM | LCCR0_IUM |\\\n\t\t\t\t\t LCCR0_SFM | LCCR0_LDM | LCCR0_ENB)\n\n#define LCCR3_INVALID_CONFIG_MASK\t(LCCR3_HSP | LCCR3_VSP |\\\n\t\t\t\t\t LCCR3_PCD | LCCR3_BPP(0xf))\n\nstatic int pxafb_activate_var(struct fb_var_screeninfo *var,\n\t\t\t\tstruct pxafb_info *);\nstatic void set_ctrlr_state(struct pxafb_info *fbi, u_int state);\nstatic void setup_base_frame(struct pxafb_info *fbi,\n                             struct fb_var_screeninfo *var, int branch);\nstatic int setup_frame_dma(struct pxafb_info *fbi, int dma, int pal,\n\t\t\t   unsigned long offset, size_t size);\n\nstatic unsigned long video_mem_size = 0;\n\nstatic inline unsigned long\nlcd_readl(struct pxafb_info *fbi, unsigned int off)\n{\n\treturn __raw_readl(fbi->mmio_base + off);\n}\n\nstatic inline void\nlcd_writel(struct pxafb_info *fbi, unsigned int off, unsigned long val)\n{\n\t__raw_writel(val, fbi->mmio_base + off);\n}\n\nstatic inline void pxafb_schedule_work(struct pxafb_info *fbi, u_int state)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t \n\tif (fbi->task_state == C_ENABLE && state == C_REENABLE)\n\t\tstate = (u_int) -1;\n\tif (fbi->task_state == C_DISABLE && state == C_ENABLE)\n\t\tstate = C_REENABLE;\n\n\tif (state != (u_int)-1) {\n\t\tfbi->task_state = state;\n\t\tschedule_work(&fbi->task);\n\t}\n\tlocal_irq_restore(flags);\n}\n\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\nstatic int\npxafb_setpalettereg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t       u_int trans, struct fb_info *info)\n{\n\tstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\n\tu_int val;\n\n\tif (regno >= fbi->palette_size)\n\t\treturn 1;\n\n\tif (fbi->fb.var.grayscale) {\n\t\tfbi->palette_cpu[regno] = ((blue >> 8) & 0x00ff);\n\t\treturn 0;\n\t}\n\n\tswitch (fbi->lccr4 & LCCR4_PAL_FOR_MASK) {\n\tcase LCCR4_PAL_FOR_0:\n\t\tval  = ((red   >>  0) & 0xf800);\n\t\tval |= ((green >>  5) & 0x07e0);\n\t\tval |= ((blue  >> 11) & 0x001f);\n\t\tfbi->palette_cpu[regno] = val;\n\t\tbreak;\n\tcase LCCR4_PAL_FOR_1:\n\t\tval  = ((red   << 8) & 0x00f80000);\n\t\tval |= ((green >> 0) & 0x0000fc00);\n\t\tval |= ((blue  >> 8) & 0x000000f8);\n\t\t((u32 *)(fbi->palette_cpu))[regno] = val;\n\t\tbreak;\n\tcase LCCR4_PAL_FOR_2:\n\t\tval  = ((red   << 8) & 0x00fc0000);\n\t\tval |= ((green >> 0) & 0x0000fc00);\n\t\tval |= ((blue  >> 8) & 0x000000fc);\n\t\t((u32 *)(fbi->palette_cpu))[regno] = val;\n\t\tbreak;\n\tcase LCCR4_PAL_FOR_3:\n\t\tval  = ((red   << 8) & 0x00ff0000);\n\t\tval |= ((green >> 0) & 0x0000ff00);\n\t\tval |= ((blue  >> 8) & 0x000000ff);\n\t\t((u32 *)(fbi->palette_cpu))[regno] = val;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\npxafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t   u_int trans, struct fb_info *info)\n{\n\tstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\n\tunsigned int val;\n\tint ret = 1;\n\n\t \n\tif (fbi->cmap_inverse) {\n\t\tred   = 0xffff - red;\n\t\tgreen = 0xffff - green;\n\t\tblue  = 0xffff - blue;\n\t}\n\n\t \n\tif (fbi->fb.var.grayscale)\n\t\tred = green = blue = (19595 * red + 38470 * green +\n\t\t\t\t\t7471 * blue) >> 16;\n\n\tswitch (fbi->fb.fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\t \n\t\tif (regno < 16) {\n\t\t\tu32 *pal = fbi->fb.pseudo_palette;\n\n\t\t\tval  = chan_to_field(red, &fbi->fb.var.red);\n\t\t\tval |= chan_to_field(green, &fbi->fb.var.green);\n\t\t\tval |= chan_to_field(blue, &fbi->fb.var.blue);\n\n\t\t\tpal[regno] = val;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FB_VISUAL_STATIC_PSEUDOCOLOR:\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tret = pxafb_setpalettereg(regno, red, green, blue, trans, info);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic inline int var_to_depth(struct fb_var_screeninfo *var)\n{\n\treturn var->red.length + var->green.length +\n\t\tvar->blue.length + var->transp.length;\n}\n\n \nstatic int pxafb_var_to_bpp(struct fb_var_screeninfo *var)\n{\n\tint bpp = -EINVAL;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 1:  bpp = 0; break;\n\tcase 2:  bpp = 1; break;\n\tcase 4:  bpp = 2; break;\n\tcase 8:  bpp = 3; break;\n\tcase 16: bpp = 4; break;\n\tcase 24:\n\t\tswitch (var_to_depth(var)) {\n\t\tcase 18: bpp = 6; break;  \n\t\tcase 19: bpp = 8; break;  \n\t\tcase 24: bpp = 9; break;\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tswitch (var_to_depth(var)) {\n\t\tcase 18: bpp = 5; break;  \n\t\tcase 19: bpp = 7; break;  \n\t\tcase 25: bpp = 10; break;\n\t\t}\n\t\tbreak;\n\t}\n\treturn bpp;\n}\n\n \nstatic uint32_t pxafb_var_to_lccr3(struct fb_var_screeninfo *var)\n{\n\tint bpp = pxafb_var_to_bpp(var);\n\tuint32_t lccr3;\n\n\tif (bpp < 0)\n\t\treturn 0;\n\n\tlccr3 = LCCR3_BPP(bpp);\n\n\tswitch (var_to_depth(var)) {\n\tcase 16: lccr3 |= var->transp.length ? LCCR3_PDFOR_3 : 0; break;\n\tcase 18: lccr3 |= LCCR3_PDFOR_3; break;\n\tcase 24: lccr3 |= var->transp.length ? LCCR3_PDFOR_2 : LCCR3_PDFOR_3;\n\t\t break;\n\tcase 19:\n\tcase 25: lccr3 |= LCCR3_PDFOR_0; break;\n\t}\n\treturn lccr3;\n}\n\n#define SET_PIXFMT(v, r, g, b, t)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\t(v)->transp.offset = (t) ? (r) + (g) + (b) : 0;\t\t\\\n\t(v)->transp.length = (t) ? (t) : 0;\t\t\t\\\n\t(v)->blue.length   = (b); (v)->blue.offset = 0;\t\t\\\n\t(v)->green.length  = (g); (v)->green.offset = (b);\t\\\n\t(v)->red.length    = (r); (v)->red.offset = (b) + (g);\t\\\n})\n\n \nstatic void pxafb_set_pixfmt(struct fb_var_screeninfo *var, int depth)\n{\n\tif (depth == 0)\n\t\tdepth = var->bits_per_pixel;\n\n\tif (var->bits_per_pixel < 16) {\n\t\t \n\t\tvar->red.offset    = 0; var->red.length    = 8;\n\t\tvar->green.offset  = 0; var->green.length  = 8;\n\t\tvar->blue.offset   = 0; var->blue.length   = 8;\n\t\tvar->transp.offset = 0; var->transp.length = 8;\n\t}\n\n\tswitch (depth) {\n\tcase 16: var->transp.length ?\n\t\t SET_PIXFMT(var, 5, 5, 5, 1) :\t\t \n\t\t SET_PIXFMT(var, 5, 6, 5, 0); break;\t \n\tcase 18: SET_PIXFMT(var, 6, 6, 6, 0); break;\t \n\tcase 19: SET_PIXFMT(var, 6, 6, 6, 1); break;\t \n\tcase 24: var->transp.length ?\n\t\t SET_PIXFMT(var, 8, 8, 7, 1) :\t\t \n\t\t SET_PIXFMT(var, 8, 8, 8, 0); break;\t \n\tcase 25: SET_PIXFMT(var, 8, 8, 8, 1); break;\t \n\t}\n}\n\n#ifdef CONFIG_CPU_FREQ\n \nstatic unsigned int pxafb_display_dma_period(struct fb_var_screeninfo *var)\n{\n\t \n\treturn var->pixclock * 8 * 16 / var->bits_per_pixel;\n}\n#endif\n\n \nstatic struct pxafb_mode_info *pxafb_getmode(struct pxafb_mach_info *mach,\n\t\t\t\t\t     struct fb_var_screeninfo *var)\n{\n\tstruct pxafb_mode_info *mode = NULL;\n\tstruct pxafb_mode_info *modelist = mach->modes;\n\tunsigned int best_x = 0xffffffff, best_y = 0xffffffff;\n\tunsigned int i;\n\n\tfor (i = 0; i < mach->num_modes; i++) {\n\t\tif (modelist[i].xres >= var->xres &&\n\t\t    modelist[i].yres >= var->yres &&\n\t\t    modelist[i].xres < best_x &&\n\t\t    modelist[i].yres < best_y &&\n\t\t    modelist[i].bpp >= var->bits_per_pixel) {\n\t\t\tbest_x = modelist[i].xres;\n\t\t\tbest_y = modelist[i].yres;\n\t\t\tmode = &modelist[i];\n\t\t}\n\t}\n\n\treturn mode;\n}\n\nstatic void pxafb_setmode(struct fb_var_screeninfo *var,\n\t\t\t  struct pxafb_mode_info *mode)\n{\n\tvar->xres\t\t= mode->xres;\n\tvar->yres\t\t= mode->yres;\n\tvar->bits_per_pixel\t= mode->bpp;\n\tvar->pixclock\t\t= mode->pixclock;\n\tvar->hsync_len\t\t= mode->hsync_len;\n\tvar->left_margin\t= mode->left_margin;\n\tvar->right_margin\t= mode->right_margin;\n\tvar->vsync_len\t\t= mode->vsync_len;\n\tvar->upper_margin\t= mode->upper_margin;\n\tvar->lower_margin\t= mode->lower_margin;\n\tvar->sync\t\t= mode->sync;\n\tvar->grayscale\t\t= mode->cmap_greyscale;\n\tvar->transp.length\t= mode->transparency;\n\n\t \n\tpxafb_set_pixfmt(var, mode->depth);\n}\n\nstatic int pxafb_adjust_timing(struct pxafb_info *fbi,\n\t\t\t       struct fb_var_screeninfo *var)\n{\n\tint line_length;\n\n\tvar->xres = max_t(int, var->xres, MIN_XRES);\n\tvar->yres = max_t(int, var->yres, MIN_YRES);\n\n\tif (!(fbi->lccr0 & LCCR0_LCDT)) {\n\t\tclamp_val(var->hsync_len, 1, 64);\n\t\tclamp_val(var->vsync_len, 1, 64);\n\t\tclamp_val(var->left_margin,  1, 255);\n\t\tclamp_val(var->right_margin, 1, 255);\n\t\tclamp_val(var->upper_margin, 1, 255);\n\t\tclamp_val(var->lower_margin, 1, 255);\n\t}\n\n\t \n\tline_length = var->xres * var->bits_per_pixel / 8;\n\tline_length = ALIGN(line_length, 4);\n\tvar->xres = line_length * 8 / var->bits_per_pixel;\n\n\t \n\tvar->xres_virtual = var->xres;\n\n\tif (var->accel_flags & FB_ACCELF_TEXT)\n\t\tvar->yres_virtual = fbi->fb.fix.smem_len / line_length;\n\telse\n\t\tvar->yres_virtual = max(var->yres_virtual, var->yres);\n\n\t \n\tif (var->xres > MAX_XRES || var->yres > MAX_YRES)\n\t\treturn -EINVAL;\n\n\tif (var->yres > var->yres_virtual)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int pxafb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\n\tstruct pxafb_mach_info *inf = fbi->inf;\n\tint err;\n\n\tif (inf->fixed_modes) {\n\t\tstruct pxafb_mode_info *mode;\n\n\t\tmode = pxafb_getmode(inf, var);\n\t\tif (!mode)\n\t\t\treturn -EINVAL;\n\t\tpxafb_setmode(var, mode);\n\t}\n\n\t \n\terr = pxafb_var_to_bpp(var);\n\tif (err < 0)\n\t\treturn err;\n\n\tpxafb_set_pixfmt(var, var_to_depth(var));\n\n\terr = pxafb_adjust_timing(fbi, var);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_CPU_FREQ\n\tpr_debug(\"pxafb: dma period = %d ps\\n\",\n\t\t pxafb_display_dma_period(var));\n#endif\n\n\treturn 0;\n}\n\n \nstatic int pxafb_set_par(struct fb_info *info)\n{\n\tstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\n\tstruct fb_var_screeninfo *var = &info->var;\n\n\tif (var->bits_per_pixel >= 16)\n\t\tfbi->fb.fix.visual = FB_VISUAL_TRUECOLOR;\n\telse if (!fbi->cmap_static)\n\t\tfbi->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\telse {\n\t\t \n\t\tfbi->fb.fix.visual = FB_VISUAL_STATIC_PSEUDOCOLOR;\n\t}\n\n\tfbi->fb.fix.line_length = var->xres_virtual *\n\t\t\t\t  var->bits_per_pixel / 8;\n\tif (var->bits_per_pixel >= 16)\n\t\tfbi->palette_size = 0;\n\telse\n\t\tfbi->palette_size = var->bits_per_pixel == 1 ?\n\t\t\t\t\t4 : 1 << var->bits_per_pixel;\n\n\tfbi->palette_cpu = (u16 *)&fbi->dma_buff->palette[0];\n\n\tif (fbi->fb.var.bits_per_pixel >= 16)\n\t\tfb_dealloc_cmap(&fbi->fb.cmap);\n\telse\n\t\tfb_alloc_cmap(&fbi->fb.cmap, 1<<fbi->fb.var.bits_per_pixel, 0);\n\n\tpxafb_activate_var(var, fbi);\n\n\treturn 0;\n}\n\nstatic int pxafb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\n\tstruct fb_var_screeninfo newvar;\n\tint dma = DMA_MAX + DMA_BASE;\n\n\tif (fbi->state != C_ENABLE)\n\t\treturn 0;\n\n\t \n\tmemcpy(&newvar, &fbi->fb.var, sizeof(newvar));\n\tnewvar.xoffset = var->xoffset;\n\tnewvar.yoffset = var->yoffset;\n\tnewvar.vmode &= ~FB_VMODE_YWRAP;\n\tnewvar.vmode |= var->vmode & FB_VMODE_YWRAP;\n\n\tsetup_base_frame(fbi, &newvar, 1);\n\n\tif (fbi->lccr0 & LCCR0_SDS)\n\t\tlcd_writel(fbi, FBR1, fbi->fdadr[dma + 1] | 0x1);\n\n\tlcd_writel(fbi, FBR0, fbi->fdadr[dma] | 0x1);\n\treturn 0;\n}\n\n \nstatic int pxafb_blank(int blank, struct fb_info *info)\n{\n\tstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\n\tint i;\n\n\tswitch (blank) {\n\tcase FB_BLANK_POWERDOWN:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_NORMAL:\n\t\tif (fbi->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR ||\n\t\t    fbi->fb.fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR)\n\t\t\tfor (i = 0; i < fbi->palette_size; i++)\n\t\t\t\tpxafb_setpalettereg(i, 0, 0, 0, 0, info);\n\n\t\tpxafb_schedule_work(fbi, C_DISABLE);\n\t\t \n\t\tbreak;\n\n\tcase FB_BLANK_UNBLANK:\n\t\t \n\t\tif (fbi->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR ||\n\t\t    fbi->fb.fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR)\n\t\t\tfb_set_cmap(&fbi->fb.cmap, info);\n\t\tpxafb_schedule_work(fbi, C_ENABLE);\n\t}\n\treturn 0;\n}\n\nstatic const struct fb_ops pxafb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= pxafb_check_var,\n\t.fb_set_par\t= pxafb_set_par,\n\t.fb_pan_display\t= pxafb_pan_display,\n\t.fb_setcolreg\t= pxafb_setcolreg,\n\t.fb_blank\t= pxafb_blank,\n};\n\n#ifdef CONFIG_FB_PXA_OVERLAY\nstatic void overlay1fb_setup(struct pxafb_layer *ofb)\n{\n\tint size = ofb->fb.fix.line_length * ofb->fb.var.yres_virtual;\n\tunsigned long start = ofb->video_mem_phys;\n\tsetup_frame_dma(ofb->fbi, DMA_OV1, PAL_NONE, start, size);\n}\n\n \nstatic void overlay1fb_enable(struct pxafb_layer *ofb)\n{\n\tint enabled = lcd_readl(ofb->fbi, OVL1C1) & OVLxC1_OEN;\n\tuint32_t fdadr1 = ofb->fbi->fdadr[DMA_OV1] | (enabled ? 0x1 : 0);\n\n\tlcd_writel(ofb->fbi, enabled ? FBR1 : FDADR1, fdadr1);\n\tlcd_writel(ofb->fbi, OVL1C2, ofb->control[1]);\n\tlcd_writel(ofb->fbi, OVL1C1, ofb->control[0] | OVLxC1_OEN);\n}\n\nstatic void overlay1fb_disable(struct pxafb_layer *ofb)\n{\n\tuint32_t lccr5;\n\n\tif (!(lcd_readl(ofb->fbi, OVL1C1) & OVLxC1_OEN))\n\t\treturn;\n\n\tlccr5 = lcd_readl(ofb->fbi, LCCR5);\n\n\tlcd_writel(ofb->fbi, OVL1C1, ofb->control[0] & ~OVLxC1_OEN);\n\n\tlcd_writel(ofb->fbi, LCSR1, LCSR1_BS(1));\n\tlcd_writel(ofb->fbi, LCCR5, lccr5 & ~LCSR1_BS(1));\n\tlcd_writel(ofb->fbi, FBR1, ofb->fbi->fdadr[DMA_OV1] | 0x3);\n\n\tif (wait_for_completion_timeout(&ofb->branch_done, 1 * HZ) == 0)\n\t\tpr_warn(\"%s: timeout disabling overlay1\\n\", __func__);\n\n\tlcd_writel(ofb->fbi, LCCR5, lccr5);\n}\n\nstatic void overlay2fb_setup(struct pxafb_layer *ofb)\n{\n\tint size, div = 1, pfor = NONSTD_TO_PFOR(ofb->fb.var.nonstd);\n\tunsigned long start[3] = { ofb->video_mem_phys, 0, 0 };\n\n\tif (pfor == OVERLAY_FORMAT_RGB || pfor == OVERLAY_FORMAT_YUV444_PACKED) {\n\t\tsize = ofb->fb.fix.line_length * ofb->fb.var.yres_virtual;\n\t\tsetup_frame_dma(ofb->fbi, DMA_OV2_Y, -1, start[0], size);\n\t} else {\n\t\tsize = ofb->fb.var.xres_virtual * ofb->fb.var.yres_virtual;\n\t\tswitch (pfor) {\n\t\tcase OVERLAY_FORMAT_YUV444_PLANAR: div = 1; break;\n\t\tcase OVERLAY_FORMAT_YUV422_PLANAR: div = 2; break;\n\t\tcase OVERLAY_FORMAT_YUV420_PLANAR: div = 4; break;\n\t\t}\n\t\tstart[1] = start[0] + size;\n\t\tstart[2] = start[1] + size / div;\n\t\tsetup_frame_dma(ofb->fbi, DMA_OV2_Y,  -1, start[0], size);\n\t\tsetup_frame_dma(ofb->fbi, DMA_OV2_Cb, -1, start[1], size / div);\n\t\tsetup_frame_dma(ofb->fbi, DMA_OV2_Cr, -1, start[2], size / div);\n\t}\n}\n\nstatic void overlay2fb_enable(struct pxafb_layer *ofb)\n{\n\tint pfor = NONSTD_TO_PFOR(ofb->fb.var.nonstd);\n\tint enabled = lcd_readl(ofb->fbi, OVL2C1) & OVLxC1_OEN;\n\tuint32_t fdadr2 = ofb->fbi->fdadr[DMA_OV2_Y]  | (enabled ? 0x1 : 0);\n\tuint32_t fdadr3 = ofb->fbi->fdadr[DMA_OV2_Cb] | (enabled ? 0x1 : 0);\n\tuint32_t fdadr4 = ofb->fbi->fdadr[DMA_OV2_Cr] | (enabled ? 0x1 : 0);\n\n\tif (pfor == OVERLAY_FORMAT_RGB || pfor == OVERLAY_FORMAT_YUV444_PACKED)\n\t\tlcd_writel(ofb->fbi, enabled ? FBR2 : FDADR2, fdadr2);\n\telse {\n\t\tlcd_writel(ofb->fbi, enabled ? FBR2 : FDADR2, fdadr2);\n\t\tlcd_writel(ofb->fbi, enabled ? FBR3 : FDADR3, fdadr3);\n\t\tlcd_writel(ofb->fbi, enabled ? FBR4 : FDADR4, fdadr4);\n\t}\n\tlcd_writel(ofb->fbi, OVL2C2, ofb->control[1]);\n\tlcd_writel(ofb->fbi, OVL2C1, ofb->control[0] | OVLxC1_OEN);\n}\n\nstatic void overlay2fb_disable(struct pxafb_layer *ofb)\n{\n\tuint32_t lccr5;\n\n\tif (!(lcd_readl(ofb->fbi, OVL2C1) & OVLxC1_OEN))\n\t\treturn;\n\n\tlccr5 = lcd_readl(ofb->fbi, LCCR5);\n\n\tlcd_writel(ofb->fbi, OVL2C1, ofb->control[0] & ~OVLxC1_OEN);\n\n\tlcd_writel(ofb->fbi, LCSR1, LCSR1_BS(2));\n\tlcd_writel(ofb->fbi, LCCR5, lccr5 & ~LCSR1_BS(2));\n\tlcd_writel(ofb->fbi, FBR2, ofb->fbi->fdadr[DMA_OV2_Y]  | 0x3);\n\tlcd_writel(ofb->fbi, FBR3, ofb->fbi->fdadr[DMA_OV2_Cb] | 0x3);\n\tlcd_writel(ofb->fbi, FBR4, ofb->fbi->fdadr[DMA_OV2_Cr] | 0x3);\n\n\tif (wait_for_completion_timeout(&ofb->branch_done, 1 * HZ) == 0)\n\t\tpr_warn(\"%s: timeout disabling overlay2\\n\", __func__);\n}\n\nstatic struct pxafb_layer_ops ofb_ops[] = {\n\t[0] = {\n\t\t.enable\t\t= overlay1fb_enable,\n\t\t.disable\t= overlay1fb_disable,\n\t\t.setup\t\t= overlay1fb_setup,\n\t},\n\t[1] = {\n\t\t.enable\t\t= overlay2fb_enable,\n\t\t.disable\t= overlay2fb_disable,\n\t\t.setup\t\t= overlay2fb_setup,\n\t},\n};\n\nstatic int overlayfb_open(struct fb_info *info, int user)\n{\n\tstruct pxafb_layer *ofb = container_of(info, struct pxafb_layer, fb);\n\n\t \n\tif (user == 0)\n\t\treturn -ENODEV;\n\n\tif (ofb->usage++ == 0) {\n\t\t \n\t\tconsole_lock();\n\t\tfb_blank(&ofb->fbi->fb, FB_BLANK_UNBLANK);\n\t\tconsole_unlock();\n\t}\n\n\treturn 0;\n}\n\nstatic int overlayfb_release(struct fb_info *info, int user)\n{\n\tstruct pxafb_layer *ofb = container_of(info, struct pxafb_layer, fb);\n\n\tif (ofb->usage == 1) {\n\t\tofb->ops->disable(ofb);\n\t\tofb->fb.var.height\t= -1;\n\t\tofb->fb.var.width\t= -1;\n\t\tofb->fb.var.xres = ofb->fb.var.xres_virtual = 0;\n\t\tofb->fb.var.yres = ofb->fb.var.yres_virtual = 0;\n\n\t\tofb->usage--;\n\t}\n\treturn 0;\n}\n\nstatic int overlayfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t       struct fb_info *info)\n{\n\tstruct pxafb_layer *ofb = container_of(info, struct pxafb_layer, fb);\n\tstruct fb_var_screeninfo *base_var = &ofb->fbi->fb.var;\n\tint xpos, ypos, pfor, bpp;\n\n\txpos = NONSTD_TO_XPOS(var->nonstd);\n\typos = NONSTD_TO_YPOS(var->nonstd);\n\tpfor = NONSTD_TO_PFOR(var->nonstd);\n\n\tbpp = pxafb_var_to_bpp(var);\n\tif (bpp < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (ofb->id == OVERLAY1 && pfor != 0)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (pfor) {\n\tcase OVERLAY_FORMAT_RGB:\n\t\tbpp = pxafb_var_to_bpp(var);\n\t\tif (bpp < 0)\n\t\t\treturn -EINVAL;\n\n\t\tpxafb_set_pixfmt(var, var_to_depth(var));\n\t\tbreak;\n\tcase OVERLAY_FORMAT_YUV444_PACKED: bpp = 24; break;\n\tcase OVERLAY_FORMAT_YUV444_PLANAR: bpp = 8; break;\n\tcase OVERLAY_FORMAT_YUV422_PLANAR: bpp = 4; break;\n\tcase OVERLAY_FORMAT_YUV420_PLANAR: bpp = 2; break;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((xpos * bpp) % 32)\n\t\treturn -EINVAL;\n\n\t \n\tvar->xres = roundup(var->xres * bpp, 32) / bpp;\n\n\tif ((xpos + var->xres > base_var->xres) ||\n\t    (ypos + var->yres > base_var->yres))\n\t\treturn -EINVAL;\n\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = max(var->yres, var->yres_virtual);\n\treturn 0;\n}\n\nstatic int overlayfb_check_video_memory(struct pxafb_layer *ofb)\n{\n\tstruct fb_var_screeninfo *var = &ofb->fb.var;\n\tint pfor = NONSTD_TO_PFOR(var->nonstd);\n\tint size, bpp = 0;\n\n\tswitch (pfor) {\n\tcase OVERLAY_FORMAT_RGB: bpp = var->bits_per_pixel; break;\n\tcase OVERLAY_FORMAT_YUV444_PACKED: bpp = 24; break;\n\tcase OVERLAY_FORMAT_YUV444_PLANAR: bpp = 24; break;\n\tcase OVERLAY_FORMAT_YUV422_PLANAR: bpp = 16; break;\n\tcase OVERLAY_FORMAT_YUV420_PLANAR: bpp = 12; break;\n\t}\n\n\tofb->fb.fix.line_length = var->xres_virtual * bpp / 8;\n\n\tsize = PAGE_ALIGN(ofb->fb.fix.line_length * var->yres_virtual);\n\n\tif (ofb->video_mem) {\n\t\tif (ofb->video_mem_size >= size)\n\t\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int overlayfb_set_par(struct fb_info *info)\n{\n\tstruct pxafb_layer *ofb = container_of(info, struct pxafb_layer, fb);\n\tstruct fb_var_screeninfo *var = &info->var;\n\tint xpos, ypos, pfor, bpp, ret;\n\n\tret = overlayfb_check_video_memory(ofb);\n\tif (ret)\n\t\treturn ret;\n\n\tbpp  = pxafb_var_to_bpp(var);\n\txpos = NONSTD_TO_XPOS(var->nonstd);\n\typos = NONSTD_TO_YPOS(var->nonstd);\n\tpfor = NONSTD_TO_PFOR(var->nonstd);\n\n\tofb->control[0] = OVLxC1_PPL(var->xres) | OVLxC1_LPO(var->yres) |\n\t\t\t  OVLxC1_BPP(bpp);\n\tofb->control[1] = OVLxC2_XPOS(xpos) | OVLxC2_YPOS(ypos);\n\n\tif (ofb->id == OVERLAY2)\n\t\tofb->control[1] |= OVL2C2_PFOR(pfor);\n\n\tofb->ops->setup(ofb);\n\tofb->ops->enable(ofb);\n\treturn 0;\n}\n\nstatic const struct fb_ops overlay_fb_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_open\t\t= overlayfb_open,\n\t.fb_release\t\t= overlayfb_release,\n\t.fb_check_var \t\t= overlayfb_check_var,\n\t.fb_set_par\t\t= overlayfb_set_par,\n};\n\nstatic void init_pxafb_overlay(struct pxafb_info *fbi, struct pxafb_layer *ofb,\n\t\t\t       int id)\n{\n\tsprintf(ofb->fb.fix.id, \"overlay%d\", id + 1);\n\n\tofb->fb.fix.type\t\t= FB_TYPE_PACKED_PIXELS;\n\tofb->fb.fix.xpanstep\t\t= 0;\n\tofb->fb.fix.ypanstep\t\t= 1;\n\n\tofb->fb.var.activate\t\t= FB_ACTIVATE_NOW;\n\tofb->fb.var.height\t\t= -1;\n\tofb->fb.var.width\t\t= -1;\n\tofb->fb.var.vmode\t\t= FB_VMODE_NONINTERLACED;\n\n\tofb->fb.fbops\t\t\t= &overlay_fb_ops;\n\tofb->fb.node\t\t\t= -1;\n\tofb->fb.pseudo_palette\t\t= NULL;\n\n\tofb->id = id;\n\tofb->ops = &ofb_ops[id];\n\tofb->usage = 0;\n\tofb->fbi = fbi;\n\tinit_completion(&ofb->branch_done);\n}\n\nstatic inline int pxafb_overlay_supported(void)\n{\n\tif (cpu_is_pxa27x() || cpu_is_pxa3xx())\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int pxafb_overlay_map_video_memory(struct pxafb_info *pxafb,\n\t\t\t\t\t  struct pxafb_layer *ofb)\n{\n\t \n\tofb->video_mem = alloc_pages_exact(PAGE_ALIGN(pxafb->video_mem_size),\n\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (ofb->video_mem == NULL)\n\t\treturn -ENOMEM;\n\n\tofb->video_mem_phys = virt_to_phys(ofb->video_mem);\n\tofb->video_mem_size = PAGE_ALIGN(pxafb->video_mem_size);\n\n\tmutex_lock(&ofb->fb.mm_lock);\n\tofb->fb.fix.smem_start\t= ofb->video_mem_phys;\n\tofb->fb.fix.smem_len\t= pxafb->video_mem_size;\n\tmutex_unlock(&ofb->fb.mm_lock);\n\n\tofb->fb.screen_base\t= ofb->video_mem;\n\n\treturn 0;\n}\n\nstatic void pxafb_overlay_init(struct pxafb_info *fbi)\n{\n\tint i, ret;\n\n\tif (!pxafb_overlay_supported())\n\t\treturn;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct pxafb_layer *ofb = &fbi->overlay[i];\n\t\tinit_pxafb_overlay(fbi, ofb, i);\n\t\tret = register_framebuffer(&ofb->fb);\n\t\tif (ret) {\n\t\t\tdev_err(fbi->dev, \"failed to register overlay %d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tret = pxafb_overlay_map_video_memory(fbi, ofb);\n\t\tif (ret) {\n\t\t\tdev_err(fbi->dev,\n\t\t\t\t\"failed to map video memory for overlay %d\\n\",\n\t\t\t\ti);\n\t\t\tunregister_framebuffer(&ofb->fb);\n\t\t\tcontinue;\n\t\t}\n\t\tofb->registered = 1;\n\t}\n\n\t \n\tlcd_writel(fbi, LCCR5, ~0);\n\n\tpr_info(\"PXA Overlay driver loaded successfully!\\n\");\n}\n\nstatic void pxafb_overlay_exit(struct pxafb_info *fbi)\n{\n\tint i;\n\n\tif (!pxafb_overlay_supported())\n\t\treturn;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct pxafb_layer *ofb = &fbi->overlay[i];\n\t\tif (ofb->registered) {\n\t\t\tif (ofb->video_mem)\n\t\t\t\tfree_pages_exact(ofb->video_mem,\n\t\t\t\t\tofb->video_mem_size);\n\t\t\tunregister_framebuffer(&ofb->fb);\n\t\t}\n\t}\n}\n#else\nstatic inline void pxafb_overlay_init(struct pxafb_info *fbi) {}\nstatic inline void pxafb_overlay_exit(struct pxafb_info *fbi) {}\n#endif  \n\n \nstatic inline unsigned int get_pcd(struct pxafb_info *fbi,\n\t\t\t\t   unsigned int pixclock)\n{\n\tunsigned long long pcd;\n\n\t \n\tpcd = (unsigned long long)(clk_get_rate(fbi->clk) / 10000);\n\tpcd *= pixclock;\n\tdo_div(pcd, 100000000 * 2);\n\t \n\t   \n\treturn (unsigned int)pcd;\n}\n\n \nstatic inline void set_hsync_time(struct pxafb_info *fbi, unsigned int pcd)\n{\n\tunsigned long htime;\n\n\tif ((pcd == 0) || (fbi->fb.var.hsync_len == 0)) {\n\t\tfbi->hsync_time = 0;\n\t\treturn;\n\t}\n\n\thtime = clk_get_rate(fbi->clk) / (pcd * fbi->fb.var.hsync_len);\n\n\tfbi->hsync_time = htime;\n}\n\nunsigned long pxafb_get_hsync_time(struct device *dev)\n{\n\tstruct pxafb_info *fbi = dev_get_drvdata(dev);\n\n\t \n\tif (!fbi || (fbi->state != C_ENABLE))\n\t\treturn 0;\n\n\treturn fbi->hsync_time;\n}\nEXPORT_SYMBOL(pxafb_get_hsync_time);\n\nstatic int setup_frame_dma(struct pxafb_info *fbi, int dma, int pal,\n\t\t\t   unsigned long start, size_t size)\n{\n\tstruct pxafb_dma_descriptor *dma_desc, *pal_desc;\n\tunsigned int dma_desc_off, pal_desc_off;\n\n\tif (dma < 0 || dma >= DMA_MAX * 2)\n\t\treturn -EINVAL;\n\n\tdma_desc = &fbi->dma_buff->dma_desc[dma];\n\tdma_desc_off = offsetof(struct pxafb_dma_buff, dma_desc[dma]);\n\n\tdma_desc->fsadr = start;\n\tdma_desc->fidr  = 0;\n\tdma_desc->ldcmd = size;\n\n\tif (pal < 0 || pal >= PAL_MAX * 2) {\n\t\tdma_desc->fdadr = fbi->dma_buff_phys + dma_desc_off;\n\t\tfbi->fdadr[dma] = fbi->dma_buff_phys + dma_desc_off;\n\t} else {\n\t\tpal_desc = &fbi->dma_buff->pal_desc[pal];\n\t\tpal_desc_off = offsetof(struct pxafb_dma_buff, pal_desc[pal]);\n\n\t\tpal_desc->fsadr = fbi->dma_buff_phys + pal * PALETTE_SIZE;\n\t\tpal_desc->fidr  = 0;\n\n\t\tif ((fbi->lccr4 & LCCR4_PAL_FOR_MASK) == LCCR4_PAL_FOR_0)\n\t\t\tpal_desc->ldcmd = fbi->palette_size * sizeof(u16);\n\t\telse\n\t\t\tpal_desc->ldcmd = fbi->palette_size * sizeof(u32);\n\n\t\tpal_desc->ldcmd |= LDCMD_PAL;\n\n\t\t \n\t\tpal_desc->fdadr = fbi->dma_buff_phys + dma_desc_off;\n\t\tdma_desc->fdadr = fbi->dma_buff_phys + pal_desc_off;\n\t\tfbi->fdadr[dma] = fbi->dma_buff_phys + dma_desc_off;\n\t}\n\n\treturn 0;\n}\n\nstatic void setup_base_frame(struct pxafb_info *fbi,\n                             struct fb_var_screeninfo *var,\n                             int branch)\n{\n\tstruct fb_fix_screeninfo *fix = &fbi->fb.fix;\n\tint nbytes, dma, pal, bpp = var->bits_per_pixel;\n\tunsigned long offset;\n\n\tdma = DMA_BASE + (branch ? DMA_MAX : 0);\n\tpal = (bpp >= 16) ? PAL_NONE : PAL_BASE + (branch ? PAL_MAX : 0);\n\n\tnbytes = fix->line_length * var->yres;\n\toffset = fix->line_length * var->yoffset + fbi->video_mem_phys;\n\n\tif (fbi->lccr0 & LCCR0_SDS) {\n\t\tnbytes = nbytes / 2;\n\t\tsetup_frame_dma(fbi, dma + 1, PAL_NONE, offset + nbytes, nbytes);\n\t}\n\n\tsetup_frame_dma(fbi, dma, pal, offset, nbytes);\n}\n\n#ifdef CONFIG_FB_PXA_SMARTPANEL\nstatic int setup_smart_dma(struct pxafb_info *fbi)\n{\n\tstruct pxafb_dma_descriptor *dma_desc;\n\tunsigned long dma_desc_off, cmd_buff_off;\n\n\tdma_desc = &fbi->dma_buff->dma_desc[DMA_CMD];\n\tdma_desc_off = offsetof(struct pxafb_dma_buff, dma_desc[DMA_CMD]);\n\tcmd_buff_off = offsetof(struct pxafb_dma_buff, cmd_buff);\n\n\tdma_desc->fdadr = fbi->dma_buff_phys + dma_desc_off;\n\tdma_desc->fsadr = fbi->dma_buff_phys + cmd_buff_off;\n\tdma_desc->fidr  = 0;\n\tdma_desc->ldcmd = fbi->n_smart_cmds * sizeof(uint16_t);\n\n\tfbi->fdadr[DMA_CMD] = dma_desc->fdadr;\n\treturn 0;\n}\n\nint pxafb_smart_flush(struct fb_info *info)\n{\n\tstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\n\tuint32_t prsr;\n\tint ret = 0;\n\n\t \n\tlcd_writel(fbi, LCCR0, fbi->reg_lccr0 & ~LCCR0_ENB);\n\n\t \n\n\twhile (fbi->n_smart_cmds & 1)\n\t\tfbi->smart_cmds[fbi->n_smart_cmds++] = SMART_CMD_NOOP;\n\n\tfbi->smart_cmds[fbi->n_smart_cmds++] = SMART_CMD_INTERRUPT;\n\tfbi->smart_cmds[fbi->n_smart_cmds++] = SMART_CMD_WAIT_FOR_VSYNC;\n\tsetup_smart_dma(fbi);\n\n\t \n\tprsr = lcd_readl(fbi, PRSR) | PRSR_ST_OK | PRSR_CON_NT;\n\tlcd_writel(fbi, PRSR, prsr);\n\n\t \n\tlcd_writel(fbi, CMDCR, 0x0001);\n\n\t \n\tlcd_writel(fbi, LCCR5, LCCR5_IUM(6));\n\n\tlcd_writel(fbi, LCCR1, fbi->reg_lccr1);\n\tlcd_writel(fbi, LCCR2, fbi->reg_lccr2);\n\tlcd_writel(fbi, LCCR3, fbi->reg_lccr3);\n\tlcd_writel(fbi, LCCR4, fbi->reg_lccr4);\n\tlcd_writel(fbi, FDADR0, fbi->fdadr[0]);\n\tlcd_writel(fbi, FDADR6, fbi->fdadr[6]);\n\n\t \n\tlcd_writel(fbi, LCCR0, fbi->reg_lccr0 | LCCR0_ENB);\n\n\tif (wait_for_completion_timeout(&fbi->command_done, HZ/2) == 0) {\n\t\tpr_warn(\"%s: timeout waiting for command done\\n\", __func__);\n\t\tret = -ETIMEDOUT;\n\t}\n\n\t \n\tprsr = lcd_readl(fbi, PRSR) & ~(PRSR_ST_OK | PRSR_CON_NT);\n\tlcd_writel(fbi, PRSR, prsr);\n\tlcd_writel(fbi, LCCR0, fbi->reg_lccr0 & ~LCCR0_ENB);\n\tlcd_writel(fbi, FDADR6, 0);\n\tfbi->n_smart_cmds = 0;\n\treturn ret;\n}\n\nint pxafb_smart_queue(struct fb_info *info, uint16_t *cmds, int n_cmds)\n{\n\tint i;\n\tstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\n\n\tfor (i = 0; i < n_cmds; i++, cmds++) {\n\t\t \n\t\tif ((*cmds & 0xff00) == SMART_CMD_DELAY) {\n\t\t\tpxafb_smart_flush(info);\n\t\t\tmdelay(*cmds & 0xff);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (fbi->n_smart_cmds == CMD_BUFF_SIZE - 8)\n\t\t\tpxafb_smart_flush(info);\n\n\t\tfbi->smart_cmds[fbi->n_smart_cmds++] = *cmds;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int __smart_timing(unsigned time_ns, unsigned long lcd_clk)\n{\n\tunsigned int t = (time_ns * (lcd_clk / 1000000) / 1000);\n\treturn (t == 0) ? 1 : t;\n}\n\nstatic void setup_smart_timing(struct pxafb_info *fbi,\n\t\t\t\tstruct fb_var_screeninfo *var)\n{\n\tstruct pxafb_mach_info *inf = fbi->inf;\n\tstruct pxafb_mode_info *mode = &inf->modes[0];\n\tunsigned long lclk = clk_get_rate(fbi->clk);\n\tunsigned t1, t2, t3, t4;\n\n\tt1 = max(mode->a0csrd_set_hld, mode->a0cswr_set_hld);\n\tt2 = max(mode->rd_pulse_width, mode->wr_pulse_width);\n\tt3 = mode->op_hold_time;\n\tt4 = mode->cmd_inh_time;\n\n\tfbi->reg_lccr1 =\n\t\tLCCR1_DisWdth(var->xres) |\n\t\tLCCR1_BegLnDel(__smart_timing(t1, lclk)) |\n\t\tLCCR1_EndLnDel(__smart_timing(t2, lclk)) |\n\t\tLCCR1_HorSnchWdth(__smart_timing(t3, lclk));\n\n\tfbi->reg_lccr2 = LCCR2_DisHght(var->yres);\n\tfbi->reg_lccr3 = fbi->lccr3 | LCCR3_PixClkDiv(__smart_timing(t4, lclk));\n\tfbi->reg_lccr3 |= (var->sync & FB_SYNC_HOR_HIGH_ACT) ? LCCR3_HSP : 0;\n\tfbi->reg_lccr3 |= (var->sync & FB_SYNC_VERT_HIGH_ACT) ? LCCR3_VSP : 0;\n\n\t \n\tfbi->reg_cmdcr = 1;\n}\n\nstatic int pxafb_smart_thread(void *arg)\n{\n\tstruct pxafb_info *fbi = arg;\n\tstruct pxafb_mach_info *inf = fbi->inf;\n\n\tif (!inf->smart_update) {\n\t\tpr_err(\"%s: not properly initialized, thread terminated\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"%s(): task starting\\n\", __func__);\n\n\tset_freezable();\n\twhile (!kthread_should_stop()) {\n\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tmutex_lock(&fbi->ctrlr_lock);\n\n\t\tif (fbi->state == C_ENABLE) {\n\t\t\tinf->smart_update(&fbi->fb);\n\t\t\tcomplete(&fbi->refresh_done);\n\t\t}\n\n\t\tmutex_unlock(&fbi->ctrlr_lock);\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(msecs_to_jiffies(30));\n\t}\n\n\tpr_debug(\"%s(): task ending\\n\", __func__);\n\treturn 0;\n}\n\nstatic int pxafb_smart_init(struct pxafb_info *fbi)\n{\n\tif (!(fbi->lccr0 & LCCR0_LCDT))\n\t\treturn 0;\n\n\tfbi->smart_cmds = (uint16_t *) fbi->dma_buff->cmd_buff;\n\tfbi->n_smart_cmds = 0;\n\n\tinit_completion(&fbi->command_done);\n\tinit_completion(&fbi->refresh_done);\n\n\tfbi->smart_thread = kthread_run(pxafb_smart_thread, fbi,\n\t\t\t\t\t\"lcd_refresh\");\n\tif (IS_ERR(fbi->smart_thread)) {\n\t\tpr_err(\"%s: unable to create kernel thread\\n\", __func__);\n\t\treturn PTR_ERR(fbi->smart_thread);\n\t}\n\n\treturn 0;\n}\n#else\nstatic inline int pxafb_smart_init(struct pxafb_info *fbi) { return 0; }\n#endif  \n\nstatic void setup_parallel_timing(struct pxafb_info *fbi,\n\t\t\t\t  struct fb_var_screeninfo *var)\n{\n\tunsigned int lines_per_panel, pcd = get_pcd(fbi, var->pixclock);\n\n\tfbi->reg_lccr1 =\n\t\tLCCR1_DisWdth(var->xres) +\n\t\tLCCR1_HorSnchWdth(var->hsync_len) +\n\t\tLCCR1_BegLnDel(var->left_margin) +\n\t\tLCCR1_EndLnDel(var->right_margin);\n\n\t \n\tlines_per_panel = var->yres;\n\tif ((fbi->lccr0 & LCCR0_SDS) == LCCR0_Dual)\n\t\tlines_per_panel /= 2;\n\n\tfbi->reg_lccr2 =\n\t\tLCCR2_DisHght(lines_per_panel) +\n\t\tLCCR2_VrtSnchWdth(var->vsync_len) +\n\t\tLCCR2_BegFrmDel(var->upper_margin) +\n\t\tLCCR2_EndFrmDel(var->lower_margin);\n\n\tfbi->reg_lccr3 = fbi->lccr3 |\n\t\t(var->sync & FB_SYNC_HOR_HIGH_ACT ?\n\t\t LCCR3_HorSnchH : LCCR3_HorSnchL) |\n\t\t(var->sync & FB_SYNC_VERT_HIGH_ACT ?\n\t\t LCCR3_VrtSnchH : LCCR3_VrtSnchL);\n\n\tif (pcd) {\n\t\tfbi->reg_lccr3 |= LCCR3_PixClkDiv(pcd);\n\t\tset_hsync_time(fbi, pcd);\n\t}\n}\n\n \nstatic int pxafb_activate_var(struct fb_var_screeninfo *var,\n\t\t\t      struct pxafb_info *fbi)\n{\n\tu_long flags;\n\n\t \n\tlocal_irq_save(flags);\n\n#ifdef CONFIG_FB_PXA_SMARTPANEL\n\tif (fbi->lccr0 & LCCR0_LCDT)\n\t\tsetup_smart_timing(fbi, var);\n\telse\n#endif\n\t\tsetup_parallel_timing(fbi, var);\n\n\tsetup_base_frame(fbi, var, 0);\n\n\tfbi->reg_lccr0 = fbi->lccr0 |\n\t\t(LCCR0_LDM | LCCR0_SFM | LCCR0_IUM | LCCR0_EFM |\n\t\t LCCR0_QDM | LCCR0_BM  | LCCR0_OUM);\n\n\tfbi->reg_lccr3 |= pxafb_var_to_lccr3(var);\n\n\tfbi->reg_lccr4 = lcd_readl(fbi, LCCR4) & ~LCCR4_PAL_FOR_MASK;\n\tfbi->reg_lccr4 |= (fbi->lccr4 & LCCR4_PAL_FOR_MASK);\n\tlocal_irq_restore(flags);\n\n\t \n\tif ((lcd_readl(fbi, LCCR0) != fbi->reg_lccr0) ||\n\t    (lcd_readl(fbi, LCCR1) != fbi->reg_lccr1) ||\n\t    (lcd_readl(fbi, LCCR2) != fbi->reg_lccr2) ||\n\t    (lcd_readl(fbi, LCCR3) != fbi->reg_lccr3) ||\n\t    (lcd_readl(fbi, LCCR4) != fbi->reg_lccr4) ||\n\t    (lcd_readl(fbi, FDADR0) != fbi->fdadr[0]) ||\n\t    ((fbi->lccr0 & LCCR0_SDS) &&\n\t    (lcd_readl(fbi, FDADR1) != fbi->fdadr[1])))\n\t\tpxafb_schedule_work(fbi, C_REENABLE);\n\n\treturn 0;\n}\n\n \nstatic inline void __pxafb_backlight_power(struct pxafb_info *fbi, int on)\n{\n\tpr_debug(\"pxafb: backlight o%s\\n\", on ? \"n\" : \"ff\");\n\n\tif (fbi->backlight_power)\n\t\tfbi->backlight_power(on);\n}\n\nstatic inline void __pxafb_lcd_power(struct pxafb_info *fbi, int on)\n{\n\tpr_debug(\"pxafb: LCD power o%s\\n\", on ? \"n\" : \"ff\");\n\n\tif (fbi->lcd_power)\n\t\tfbi->lcd_power(on, &fbi->fb.var);\n\n\tif (fbi->lcd_supply && fbi->lcd_supply_enabled != on) {\n\t\tint ret;\n\n\t\tif (on)\n\t\t\tret = regulator_enable(fbi->lcd_supply);\n\t\telse\n\t\t\tret = regulator_disable(fbi->lcd_supply);\n\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Unable to %s LCD supply regulator: %d\\n\",\n\t\t\t\ton ? \"enable\" : \"disable\", ret);\n\t\telse\n\t\t\tfbi->lcd_supply_enabled = on;\n\t}\n}\n\nstatic void pxafb_enable_controller(struct pxafb_info *fbi)\n{\n\tpr_debug(\"pxafb: Enabling LCD controller\\n\");\n\tpr_debug(\"fdadr0 0x%08x\\n\", (unsigned int) fbi->fdadr[0]);\n\tpr_debug(\"fdadr1 0x%08x\\n\", (unsigned int) fbi->fdadr[1]);\n\tpr_debug(\"reg_lccr0 0x%08x\\n\", (unsigned int) fbi->reg_lccr0);\n\tpr_debug(\"reg_lccr1 0x%08x\\n\", (unsigned int) fbi->reg_lccr1);\n\tpr_debug(\"reg_lccr2 0x%08x\\n\", (unsigned int) fbi->reg_lccr2);\n\tpr_debug(\"reg_lccr3 0x%08x\\n\", (unsigned int) fbi->reg_lccr3);\n\n\t \n\tif (clk_prepare_enable(fbi->clk)) {\n\t\tpr_err(\"%s: Failed to prepare clock\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (fbi->lccr0 & LCCR0_LCDT)\n\t\treturn;\n\n\t \n\tlcd_writel(fbi, LCCR4, fbi->reg_lccr4);\n\tlcd_writel(fbi, LCCR3, fbi->reg_lccr3);\n\tlcd_writel(fbi, LCCR2, fbi->reg_lccr2);\n\tlcd_writel(fbi, LCCR1, fbi->reg_lccr1);\n\tlcd_writel(fbi, LCCR0, fbi->reg_lccr0 & ~LCCR0_ENB);\n\n\tlcd_writel(fbi, FDADR0, fbi->fdadr[0]);\n\tif (fbi->lccr0 & LCCR0_SDS)\n\t\tlcd_writel(fbi, FDADR1, fbi->fdadr[1]);\n\tlcd_writel(fbi, LCCR0, fbi->reg_lccr0 | LCCR0_ENB);\n}\n\nstatic void pxafb_disable_controller(struct pxafb_info *fbi)\n{\n\tuint32_t lccr0;\n\n#ifdef CONFIG_FB_PXA_SMARTPANEL\n\tif (fbi->lccr0 & LCCR0_LCDT) {\n\t\twait_for_completion_timeout(&fbi->refresh_done,\n\t\t\t\tmsecs_to_jiffies(200));\n\t\treturn;\n\t}\n#endif\n\n\t \n\tlcd_writel(fbi, LCSR, 0xffffffff);\n\n\tlccr0 = lcd_readl(fbi, LCCR0) & ~LCCR0_LDM;\n\tlcd_writel(fbi, LCCR0, lccr0);\n\tlcd_writel(fbi, LCCR0, lccr0 | LCCR0_DIS);\n\n\twait_for_completion_timeout(&fbi->disable_done, msecs_to_jiffies(200));\n\n\t \n\tclk_disable_unprepare(fbi->clk);\n}\n\n \nstatic irqreturn_t pxafb_handle_irq(int irq, void *dev_id)\n{\n\tstruct pxafb_info *fbi = dev_id;\n\tunsigned int lccr0, lcsr;\n\n\tlcsr = lcd_readl(fbi, LCSR);\n\tif (lcsr & LCSR_LDD) {\n\t\tlccr0 = lcd_readl(fbi, LCCR0);\n\t\tlcd_writel(fbi, LCCR0, lccr0 | LCCR0_LDM);\n\t\tcomplete(&fbi->disable_done);\n\t}\n\n#ifdef CONFIG_FB_PXA_SMARTPANEL\n\tif (lcsr & LCSR_CMD_INT)\n\t\tcomplete(&fbi->command_done);\n#endif\n\tlcd_writel(fbi, LCSR, lcsr);\n\n#ifdef CONFIG_FB_PXA_OVERLAY\n\t{\n\t\tunsigned int lcsr1 = lcd_readl(fbi, LCSR1);\n\t\tif (lcsr1 & LCSR1_BS(1))\n\t\t\tcomplete(&fbi->overlay[0].branch_done);\n\n\t\tif (lcsr1 & LCSR1_BS(2))\n\t\t\tcomplete(&fbi->overlay[1].branch_done);\n\n\t\tlcd_writel(fbi, LCSR1, lcsr1);\n\t}\n#endif\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void set_ctrlr_state(struct pxafb_info *fbi, u_int state)\n{\n\tu_int old_state;\n\n\tmutex_lock(&fbi->ctrlr_lock);\n\n\told_state = fbi->state;\n\n\t \n\tif (old_state == C_STARTUP && state == C_REENABLE)\n\t\tstate = C_ENABLE;\n\n\tswitch (state) {\n\tcase C_DISABLE_CLKCHANGE:\n\t\t \n\t\tif (old_state != C_DISABLE && old_state != C_DISABLE_PM) {\n\t\t\tfbi->state = state;\n\t\t\t \n\t\t\tpxafb_disable_controller(fbi);\n\t\t}\n\t\tbreak;\n\n\tcase C_DISABLE_PM:\n\tcase C_DISABLE:\n\t\t \n\t\tif (old_state != C_DISABLE) {\n\t\t\tfbi->state = state;\n\t\t\t__pxafb_backlight_power(fbi, 0);\n\t\t\t__pxafb_lcd_power(fbi, 0);\n\t\t\tif (old_state != C_DISABLE_CLKCHANGE)\n\t\t\t\tpxafb_disable_controller(fbi);\n\t\t}\n\t\tbreak;\n\n\tcase C_ENABLE_CLKCHANGE:\n\t\t \n\t\tif (old_state == C_DISABLE_CLKCHANGE) {\n\t\t\tfbi->state = C_ENABLE;\n\t\t\tpxafb_enable_controller(fbi);\n\t\t\t \n\t\t}\n\t\tbreak;\n\n\tcase C_REENABLE:\n\t\t \n\t\tif (old_state == C_ENABLE) {\n\t\t\t__pxafb_lcd_power(fbi, 0);\n\t\t\tpxafb_disable_controller(fbi);\n\t\t\tpxafb_enable_controller(fbi);\n\t\t\t__pxafb_lcd_power(fbi, 1);\n\t\t}\n\t\tbreak;\n\n\tcase C_ENABLE_PM:\n\t\t \n\t\tif (old_state != C_DISABLE_PM)\n\t\t\tbreak;\n\t\tfallthrough;\n\n\tcase C_ENABLE:\n\t\t \n\t\tif (old_state != C_ENABLE) {\n\t\t\tfbi->state = C_ENABLE;\n\t\t\tpxafb_enable_controller(fbi);\n\t\t\t__pxafb_lcd_power(fbi, 1);\n\t\t\t__pxafb_backlight_power(fbi, 1);\n\t\t}\n\t\tbreak;\n\t}\n\tmutex_unlock(&fbi->ctrlr_lock);\n}\n\n \nstatic void pxafb_task(struct work_struct *work)\n{\n\tstruct pxafb_info *fbi =\n\t\tcontainer_of(work, struct pxafb_info, task);\n\tu_int state = xchg(&fbi->task_state, -1);\n\n\tset_ctrlr_state(fbi, state);\n}\n\n#ifdef CONFIG_CPU_FREQ\n \nstatic int\npxafb_freq_transition(struct notifier_block *nb, unsigned long val, void *data)\n{\n\tstruct pxafb_info *fbi = TO_INF(nb, freq_transition);\n\t \n\tu_int pcd;\n\n\tswitch (val) {\n\tcase CPUFREQ_PRECHANGE:\n#ifdef CONFIG_FB_PXA_OVERLAY\n\t\tif (!(fbi->overlay[0].usage || fbi->overlay[1].usage))\n#endif\n\t\t\tset_ctrlr_state(fbi, C_DISABLE_CLKCHANGE);\n\t\tbreak;\n\n\tcase CPUFREQ_POSTCHANGE:\n\t\tpcd = get_pcd(fbi, fbi->fb.var.pixclock);\n\t\tset_hsync_time(fbi, pcd);\n\t\tfbi->reg_lccr3 = (fbi->reg_lccr3 & ~0xff) |\n\t\t\t\t  LCCR3_PixClkDiv(pcd);\n\t\tset_ctrlr_state(fbi, C_ENABLE_CLKCHANGE);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM\n \nstatic int pxafb_suspend(struct device *dev)\n{\n\tstruct pxafb_info *fbi = dev_get_drvdata(dev);\n\n\tset_ctrlr_state(fbi, C_DISABLE_PM);\n\treturn 0;\n}\n\nstatic int pxafb_resume(struct device *dev)\n{\n\tstruct pxafb_info *fbi = dev_get_drvdata(dev);\n\n\tset_ctrlr_state(fbi, C_ENABLE_PM);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops pxafb_pm_ops = {\n\t.suspend\t= pxafb_suspend,\n\t.resume\t\t= pxafb_resume,\n};\n#endif\n\nstatic int pxafb_init_video_memory(struct pxafb_info *fbi)\n{\n\tint size = PAGE_ALIGN(fbi->video_mem_size);\n\n\tfbi->video_mem = alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);\n\tif (fbi->video_mem == NULL)\n\t\treturn -ENOMEM;\n\n\tfbi->video_mem_phys = virt_to_phys(fbi->video_mem);\n\tfbi->video_mem_size = size;\n\n\tfbi->fb.fix.smem_start\t= fbi->video_mem_phys;\n\tfbi->fb.fix.smem_len\t= fbi->video_mem_size;\n\tfbi->fb.screen_base\t= fbi->video_mem;\n\n\treturn fbi->video_mem ? 0 : -ENOMEM;\n}\n\nstatic void pxafb_decode_mach_info(struct pxafb_info *fbi,\n\t\t\t\t   struct pxafb_mach_info *inf)\n{\n\tunsigned int lcd_conn = inf->lcd_conn;\n\tstruct pxafb_mode_info *m;\n\tint i;\n\n\tfbi->cmap_inverse\t= inf->cmap_inverse;\n\tfbi->cmap_static\t= inf->cmap_static;\n\tfbi->lccr4 \t\t= inf->lccr4;\n\n\tswitch (lcd_conn & LCD_TYPE_MASK) {\n\tcase LCD_TYPE_MONO_STN:\n\t\tfbi->lccr0 = LCCR0_CMS;\n\t\tbreak;\n\tcase LCD_TYPE_MONO_DSTN:\n\t\tfbi->lccr0 = LCCR0_CMS | LCCR0_SDS;\n\t\tbreak;\n\tcase LCD_TYPE_COLOR_STN:\n\t\tfbi->lccr0 = 0;\n\t\tbreak;\n\tcase LCD_TYPE_COLOR_DSTN:\n\t\tfbi->lccr0 = LCCR0_SDS;\n\t\tbreak;\n\tcase LCD_TYPE_COLOR_TFT:\n\t\tfbi->lccr0 = LCCR0_PAS;\n\t\tbreak;\n\tcase LCD_TYPE_SMART_PANEL:\n\t\tfbi->lccr0 = LCCR0_LCDT | LCCR0_PAS;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tfbi->lccr0 = inf->lccr0;\n\t\tfbi->lccr3 = inf->lccr3;\n\t\tgoto decode_mode;\n\t}\n\n\tif (lcd_conn == LCD_MONO_STN_8BPP)\n\t\tfbi->lccr0 |= LCCR0_DPD;\n\n\tfbi->lccr0 |= (lcd_conn & LCD_ALTERNATE_MAPPING) ? LCCR0_LDDALT : 0;\n\n\tfbi->lccr3 = LCCR3_Acb((inf->lcd_conn >> 10) & 0xff);\n\tfbi->lccr3 |= (lcd_conn & LCD_BIAS_ACTIVE_LOW) ? LCCR3_OEP : 0;\n\tfbi->lccr3 |= (lcd_conn & LCD_PCLK_EDGE_FALL)  ? LCCR3_PCP : 0;\n\ndecode_mode:\n\tpxafb_setmode(&fbi->fb.var, &inf->modes[0]);\n\n\t \n\tfor (i = 0, m = &inf->modes[0]; i < inf->num_modes; i++, m++)\n\t\tfbi->video_mem_size = max_t(size_t, fbi->video_mem_size,\n\t\t\t\tm->xres * m->yres * m->bpp / 8);\n\n\tif (inf->video_mem_size > fbi->video_mem_size)\n\t\tfbi->video_mem_size = inf->video_mem_size;\n\n\tif (video_mem_size > fbi->video_mem_size)\n\t\tfbi->video_mem_size = video_mem_size;\n}\n\nstatic struct pxafb_info *pxafb_init_fbinfo(struct device *dev,\n\t\t\t\t\t    struct pxafb_mach_info *inf)\n{\n\tstruct pxafb_info *fbi;\n\tvoid *addr;\n\n\t \n\tfbi = devm_kzalloc(dev, sizeof(struct pxafb_info) + sizeof(u32) * 16,\n\t\t\t   GFP_KERNEL);\n\tif (!fbi)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfbi->dev = dev;\n\tfbi->inf = inf;\n\n\tfbi->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(fbi->clk))\n\t\treturn ERR_CAST(fbi->clk);\n\n\tstrcpy(fbi->fb.fix.id, PXA_NAME);\n\n\tfbi->fb.fix.type\t= FB_TYPE_PACKED_PIXELS;\n\tfbi->fb.fix.type_aux\t= 0;\n\tfbi->fb.fix.xpanstep\t= 0;\n\tfbi->fb.fix.ypanstep\t= 1;\n\tfbi->fb.fix.ywrapstep\t= 0;\n\tfbi->fb.fix.accel\t= FB_ACCEL_NONE;\n\n\tfbi->fb.var.nonstd\t= 0;\n\tfbi->fb.var.activate\t= FB_ACTIVATE_NOW;\n\tfbi->fb.var.height\t= -1;\n\tfbi->fb.var.width\t= -1;\n\tfbi->fb.var.accel_flags\t= FB_ACCELF_TEXT;\n\tfbi->fb.var.vmode\t= FB_VMODE_NONINTERLACED;\n\n\tfbi->fb.fbops\t\t= &pxafb_ops;\n\tfbi->fb.node\t\t= -1;\n\n\taddr = fbi;\n\taddr = addr + sizeof(struct pxafb_info);\n\tfbi->fb.pseudo_palette\t= addr;\n\n\tfbi->state\t\t= C_STARTUP;\n\tfbi->task_state\t\t= (u_char)-1;\n\n\tpxafb_decode_mach_info(fbi, inf);\n\n#ifdef CONFIG_FB_PXA_OVERLAY\n\t \n\tif (pxafb_overlay_supported())\n\t\tfbi->lccr0 |= LCCR0_OUC;\n#endif\n\n\tinit_waitqueue_head(&fbi->ctrlr_wait);\n\tINIT_WORK(&fbi->task, pxafb_task);\n\tmutex_init(&fbi->ctrlr_lock);\n\tinit_completion(&fbi->disable_done);\n\n\treturn fbi;\n}\n\n#ifdef CONFIG_FB_PXA_PARAMETERS\nstatic int parse_opt_mode(struct device *dev, const char *this_opt,\n\t\t\t  struct pxafb_mach_info *inf)\n{\n\tconst char *name = this_opt+5;\n\tunsigned int namelen = strlen(name);\n\tint res_specified = 0, bpp_specified = 0;\n\tunsigned int xres = 0, yres = 0, bpp = 0;\n\tint yres_specified = 0;\n\tint i;\n\tfor (i = namelen-1; i >= 0; i--) {\n\t\tswitch (name[i]) {\n\t\tcase '-':\n\t\t\tnamelen = i;\n\t\t\tif (!bpp_specified && !yres_specified) {\n\t\t\t\tbpp = simple_strtoul(&name[i+1], NULL, 0);\n\t\t\t\tbpp_specified = 1;\n\t\t\t} else\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (!yres_specified) {\n\t\t\t\tyres = simple_strtoul(&name[i+1], NULL, 0);\n\t\t\t\tyres_specified = 1;\n\t\t\t} else\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase '0' ... '9':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (i < 0 && yres_specified) {\n\t\txres = simple_strtoul(name, NULL, 0);\n\t\tres_specified = 1;\n\t}\ndone:\n\tif (res_specified) {\n\t\tdev_info(dev, \"overriding resolution: %dx%d\\n\", xres, yres);\n\t\tinf->modes[0].xres = xres; inf->modes[0].yres = yres;\n\t}\n\tif (bpp_specified)\n\t\tswitch (bpp) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tinf->modes[0].bpp = bpp;\n\t\t\tdev_info(dev, \"overriding bit depth: %d\\n\", bpp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Depth %d is not valid\\n\", bpp);\n\t\t\treturn -EINVAL;\n\t\t}\n\treturn 0;\n}\n\nstatic int parse_opt(struct device *dev, char *this_opt,\n\t\t     struct pxafb_mach_info *inf)\n{\n\tstruct pxafb_mode_info *mode = &inf->modes[0];\n\tchar s[64];\n\n\ts[0] = '\\0';\n\n\tif (!strncmp(this_opt, \"vmem:\", 5)) {\n\t\tvideo_mem_size = memparse(this_opt + 5, NULL);\n\t} else if (!strncmp(this_opt, \"mode:\", 5)) {\n\t\treturn parse_opt_mode(dev, this_opt, inf);\n\t} else if (!strncmp(this_opt, \"pixclock:\", 9)) {\n\t\tmode->pixclock = simple_strtoul(this_opt+9, NULL, 0);\n\t\tsprintf(s, \"pixclock: %ld\\n\", mode->pixclock);\n\t} else if (!strncmp(this_opt, \"left:\", 5)) {\n\t\tmode->left_margin = simple_strtoul(this_opt+5, NULL, 0);\n\t\tsprintf(s, \"left: %u\\n\", mode->left_margin);\n\t} else if (!strncmp(this_opt, \"right:\", 6)) {\n\t\tmode->right_margin = simple_strtoul(this_opt+6, NULL, 0);\n\t\tsprintf(s, \"right: %u\\n\", mode->right_margin);\n\t} else if (!strncmp(this_opt, \"upper:\", 6)) {\n\t\tmode->upper_margin = simple_strtoul(this_opt+6, NULL, 0);\n\t\tsprintf(s, \"upper: %u\\n\", mode->upper_margin);\n\t} else if (!strncmp(this_opt, \"lower:\", 6)) {\n\t\tmode->lower_margin = simple_strtoul(this_opt+6, NULL, 0);\n\t\tsprintf(s, \"lower: %u\\n\", mode->lower_margin);\n\t} else if (!strncmp(this_opt, \"hsynclen:\", 9)) {\n\t\tmode->hsync_len = simple_strtoul(this_opt+9, NULL, 0);\n\t\tsprintf(s, \"hsynclen: %u\\n\", mode->hsync_len);\n\t} else if (!strncmp(this_opt, \"vsynclen:\", 9)) {\n\t\tmode->vsync_len = simple_strtoul(this_opt+9, NULL, 0);\n\t\tsprintf(s, \"vsynclen: %u\\n\", mode->vsync_len);\n\t} else if (!strncmp(this_opt, \"hsync:\", 6)) {\n\t\tif (simple_strtoul(this_opt+6, NULL, 0) == 0) {\n\t\t\tsprintf(s, \"hsync: Active Low\\n\");\n\t\t\tmode->sync &= ~FB_SYNC_HOR_HIGH_ACT;\n\t\t} else {\n\t\t\tsprintf(s, \"hsync: Active High\\n\");\n\t\t\tmode->sync |= FB_SYNC_HOR_HIGH_ACT;\n\t\t}\n\t} else if (!strncmp(this_opt, \"vsync:\", 6)) {\n\t\tif (simple_strtoul(this_opt+6, NULL, 0) == 0) {\n\t\t\tsprintf(s, \"vsync: Active Low\\n\");\n\t\t\tmode->sync &= ~FB_SYNC_VERT_HIGH_ACT;\n\t\t} else {\n\t\t\tsprintf(s, \"vsync: Active High\\n\");\n\t\t\tmode->sync |= FB_SYNC_VERT_HIGH_ACT;\n\t\t}\n\t} else if (!strncmp(this_opt, \"dpc:\", 4)) {\n\t\tif (simple_strtoul(this_opt+4, NULL, 0) == 0) {\n\t\t\tsprintf(s, \"double pixel clock: false\\n\");\n\t\t\tinf->lccr3 &= ~LCCR3_DPC;\n\t\t} else {\n\t\t\tsprintf(s, \"double pixel clock: true\\n\");\n\t\t\tinf->lccr3 |= LCCR3_DPC;\n\t\t}\n\t} else if (!strncmp(this_opt, \"outputen:\", 9)) {\n\t\tif (simple_strtoul(this_opt+9, NULL, 0) == 0) {\n\t\t\tsprintf(s, \"output enable: active low\\n\");\n\t\t\tinf->lccr3 = (inf->lccr3 & ~LCCR3_OEP) | LCCR3_OutEnL;\n\t\t} else {\n\t\t\tsprintf(s, \"output enable: active high\\n\");\n\t\t\tinf->lccr3 = (inf->lccr3 & ~LCCR3_OEP) | LCCR3_OutEnH;\n\t\t}\n\t} else if (!strncmp(this_opt, \"pixclockpol:\", 12)) {\n\t\tif (simple_strtoul(this_opt+12, NULL, 0) == 0) {\n\t\t\tsprintf(s, \"pixel clock polarity: falling edge\\n\");\n\t\t\tinf->lccr3 = (inf->lccr3 & ~LCCR3_PCP) | LCCR3_PixFlEdg;\n\t\t} else {\n\t\t\tsprintf(s, \"pixel clock polarity: rising edge\\n\");\n\t\t\tinf->lccr3 = (inf->lccr3 & ~LCCR3_PCP) | LCCR3_PixRsEdg;\n\t\t}\n\t} else if (!strncmp(this_opt, \"color\", 5)) {\n\t\tinf->lccr0 = (inf->lccr0 & ~LCCR0_CMS) | LCCR0_Color;\n\t} else if (!strncmp(this_opt, \"mono\", 4)) {\n\t\tinf->lccr0 = (inf->lccr0 & ~LCCR0_CMS) | LCCR0_Mono;\n\t} else if (!strncmp(this_opt, \"active\", 6)) {\n\t\tinf->lccr0 = (inf->lccr0 & ~LCCR0_PAS) | LCCR0_Act;\n\t} else if (!strncmp(this_opt, \"passive\", 7)) {\n\t\tinf->lccr0 = (inf->lccr0 & ~LCCR0_PAS) | LCCR0_Pas;\n\t} else if (!strncmp(this_opt, \"single\", 6)) {\n\t\tinf->lccr0 = (inf->lccr0 & ~LCCR0_SDS) | LCCR0_Sngl;\n\t} else if (!strncmp(this_opt, \"dual\", 4)) {\n\t\tinf->lccr0 = (inf->lccr0 & ~LCCR0_SDS) | LCCR0_Dual;\n\t} else if (!strncmp(this_opt, \"4pix\", 4)) {\n\t\tinf->lccr0 = (inf->lccr0 & ~LCCR0_DPD) | LCCR0_4PixMono;\n\t} else if (!strncmp(this_opt, \"8pix\", 4)) {\n\t\tinf->lccr0 = (inf->lccr0 & ~LCCR0_DPD) | LCCR0_8PixMono;\n\t} else {\n\t\tdev_err(dev, \"unknown option: %s\\n\", this_opt);\n\t\treturn -EINVAL;\n\t}\n\n\tif (s[0] != '\\0')\n\t\tdev_info(dev, \"override %s\", s);\n\n\treturn 0;\n}\n\nstatic int pxafb_parse_options(struct device *dev, char *options,\n\t\t\t       struct pxafb_mach_info *inf)\n{\n\tchar *this_opt;\n\tint ret;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\tdev_dbg(dev, \"options are \\\"%s\\\"\\n\", options ? options : \"null\");\n\n\t \n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tret = parse_opt(dev, this_opt, inf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic char g_options[256] = \"\";\n\n#ifndef MODULE\nstatic int __init pxafb_setup_options(void)\n{\n\tchar *options = NULL;\n\n\tif (fb_get_options(\"pxafb\", &options))\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tstrscpy(g_options, options, sizeof(g_options));\n\n\treturn 0;\n}\n#else\n#define pxafb_setup_options()\t\t(0)\n\nmodule_param_string(options, g_options, sizeof(g_options), 0);\nMODULE_PARM_DESC(options, \"LCD parameters (see Documentation/fb/pxafb.rst)\");\n#endif\n\n#else\n#define pxafb_parse_options(...)\t(0)\n#define pxafb_setup_options()\t\t(0)\n#endif\n\n#ifdef DEBUG_VAR\n \nstatic void pxafb_check_options(struct device *dev, struct pxafb_mach_info *inf)\n{\n\tif (inf->lcd_conn)\n\t\treturn;\n\n\tif (inf->lccr0 & LCCR0_INVALID_CONFIG_MASK)\n\t\tdev_warn(dev, \"machine LCCR0 setting contains \"\n\t\t\t\t\"illegal bits: %08x\\n\",\n\t\t\tinf->lccr0 & LCCR0_INVALID_CONFIG_MASK);\n\tif (inf->lccr3 & LCCR3_INVALID_CONFIG_MASK)\n\t\tdev_warn(dev, \"machine LCCR3 setting contains \"\n\t\t\t\t\"illegal bits: %08x\\n\",\n\t\t\tinf->lccr3 & LCCR3_INVALID_CONFIG_MASK);\n\tif (inf->lccr0 & LCCR0_DPD &&\n\t    ((inf->lccr0 & LCCR0_PAS) != LCCR0_Pas ||\n\t     (inf->lccr0 & LCCR0_SDS) != LCCR0_Sngl ||\n\t     (inf->lccr0 & LCCR0_CMS) != LCCR0_Mono))\n\t\tdev_warn(dev, \"Double Pixel Data (DPD) mode is \"\n\t\t\t\t\"only valid in passive mono\"\n\t\t\t\t\" single panel mode\\n\");\n\tif ((inf->lccr0 & LCCR0_PAS) == LCCR0_Act &&\n\t    (inf->lccr0 & LCCR0_SDS) == LCCR0_Dual)\n\t\tdev_warn(dev, \"Dual panel only valid in passive mode\\n\");\n\tif ((inf->lccr0 & LCCR0_PAS) == LCCR0_Pas &&\n\t     (inf->modes->upper_margin || inf->modes->lower_margin))\n\t\tdev_warn(dev, \"Upper and lower margins must be 0 in \"\n\t\t\t\t\"passive mode\\n\");\n}\n#else\n#define pxafb_check_options(...)\tdo {} while (0)\n#endif\n\n#if defined(CONFIG_OF)\nstatic const char * const lcd_types[] = {\n\t\"unknown\", \"mono-stn\", \"mono-dstn\", \"color-stn\", \"color-dstn\",\n\t\"color-tft\", \"smart-panel\", NULL\n};\n\nstatic int of_get_pxafb_display(struct device *dev, struct device_node *disp,\n\t\t\t\tstruct pxafb_mach_info *info, u32 bus_width)\n{\n\tstruct display_timings *timings;\n\tstruct videomode vm;\n\tint i, ret = -EINVAL;\n\tconst char *s;\n\n\tret = of_property_read_string(disp, \"lcd-type\", &s);\n\tif (ret)\n\t\ts = \"color-tft\";\n\n\ti = match_string(lcd_types, -1, s);\n\tif (i < 0) {\n\t\tdev_err(dev, \"lcd-type %s is unknown\\n\", s);\n\t\treturn i;\n\t}\n\tinfo->lcd_conn |= LCD_CONN_TYPE(i);\n\tinfo->lcd_conn |= LCD_CONN_WIDTH(bus_width);\n\n\ttimings = of_get_display_timings(disp);\n\tif (!timings)\n\t\treturn -EINVAL;\n\n\tret = -ENOMEM;\n\tinfo->modes = devm_kcalloc(dev, timings->num_timings,\n\t\t\t\t   sizeof(info->modes[0]),\n\t\t\t\t   GFP_KERNEL);\n\tif (!info->modes)\n\t\tgoto out;\n\tinfo->num_modes = timings->num_timings;\n\n\tfor (i = 0; i < timings->num_timings; i++) {\n\t\tret = videomode_from_timings(timings, &vm, i);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"videomode_from_timings %d failed: %d\\n\",\n\t\t\t\ti, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (vm.flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)\n\t\t\tinfo->lcd_conn |= LCD_PCLK_EDGE_RISE;\n\t\tif (vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)\n\t\t\tinfo->lcd_conn |= LCD_PCLK_EDGE_FALL;\n\t\tif (vm.flags & DISPLAY_FLAGS_DE_HIGH)\n\t\t\tinfo->lcd_conn |= LCD_BIAS_ACTIVE_HIGH;\n\t\tif (vm.flags & DISPLAY_FLAGS_DE_LOW)\n\t\t\tinfo->lcd_conn |= LCD_BIAS_ACTIVE_LOW;\n\t\tif (vm.flags & DISPLAY_FLAGS_HSYNC_HIGH)\n\t\t\tinfo->modes[i].sync |= FB_SYNC_HOR_HIGH_ACT;\n\t\tif (vm.flags & DISPLAY_FLAGS_VSYNC_HIGH)\n\t\t\tinfo->modes[i].sync |= FB_SYNC_VERT_HIGH_ACT;\n\n\t\tinfo->modes[i].pixclock = 1000000000UL / (vm.pixelclock / 1000);\n\t\tinfo->modes[i].xres = vm.hactive;\n\t\tinfo->modes[i].yres = vm.vactive;\n\t\tinfo->modes[i].hsync_len = vm.hsync_len;\n\t\tinfo->modes[i].left_margin = vm.hback_porch;\n\t\tinfo->modes[i].right_margin = vm.hfront_porch;\n\t\tinfo->modes[i].vsync_len = vm.vsync_len;\n\t\tinfo->modes[i].upper_margin = vm.vback_porch;\n\t\tinfo->modes[i].lower_margin = vm.vfront_porch;\n\t}\n\tret = 0;\n\nout:\n\tdisplay_timings_release(timings);\n\treturn ret;\n}\n\nstatic int of_get_pxafb_mode_info(struct device *dev,\n\t\t\t\t  struct pxafb_mach_info *info)\n{\n\tstruct device_node *display, *np;\n\tu32 bus_width;\n\tint ret, i;\n\n\tnp = of_graph_get_next_endpoint(dev->of_node, NULL);\n\tif (!np) {\n\t\tdev_err(dev, \"could not find endpoint\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = of_property_read_u32(np, \"bus-width\", &bus_width);\n\tif (ret) {\n\t\tdev_err(dev, \"no bus-width specified: %d\\n\", ret);\n\t\tof_node_put(np);\n\t\treturn ret;\n\t}\n\n\tdisplay = of_graph_get_remote_port_parent(np);\n\tof_node_put(np);\n\tif (!display) {\n\t\tdev_err(dev, \"no display defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_get_pxafb_display(dev, display, info, bus_width);\n\tof_node_put(display);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < info->num_modes; i++)\n\t\tinfo->modes[i].bpp = bus_width;\n\n\treturn 0;\n}\n\nstatic struct pxafb_mach_info *of_pxafb_of_mach_info(struct device *dev)\n{\n\tint ret;\n\tstruct pxafb_mach_info *info;\n\n\tif (!dev->of_node)\n\t\treturn NULL;\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = of_get_pxafb_mode_info(dev, info);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t \n\treturn info;\n}\n#else\nstatic struct pxafb_mach_info *of_pxafb_of_mach_info(struct device *dev)\n{\n\treturn NULL;\n}\n#endif\n\nstatic int pxafb_probe(struct platform_device *dev)\n{\n\tstruct pxafb_info *fbi;\n\tstruct pxafb_mach_info *inf, *pdata;\n\tint i, irq, ret;\n\n\tdev_dbg(&dev->dev, \"pxafb_probe\\n\");\n\n\tret = -ENOMEM;\n\tpdata = dev_get_platdata(&dev->dev);\n\tinf = devm_kmalloc(&dev->dev, sizeof(*inf), GFP_KERNEL);\n\tif (!inf)\n\t\tgoto failed;\n\n\tif (pdata) {\n\t\t*inf = *pdata;\n\t\tinf->modes =\n\t\t\tdevm_kmalloc_array(&dev->dev, pdata->num_modes,\n\t\t\t\t\t   sizeof(inf->modes[0]), GFP_KERNEL);\n\t\tif (!inf->modes)\n\t\t\tgoto failed;\n\t\tfor (i = 0; i < inf->num_modes; i++)\n\t\t\tinf->modes[i] = pdata->modes[i];\n\t} else {\n\t\tinf = of_pxafb_of_mach_info(&dev->dev);\n\t}\n\n\tif (IS_ERR_OR_NULL(inf))\n\t\tgoto failed;\n\n\tret = pxafb_parse_options(&dev->dev, g_options, inf);\n\tif (ret < 0)\n\t\tgoto failed;\n\n\tpxafb_check_options(&dev->dev, inf);\n\n\tdev_dbg(&dev->dev, \"got a %dx%dx%d LCD\\n\",\n\t\t\tinf->modes->xres,\n\t\t\tinf->modes->yres,\n\t\t\tinf->modes->bpp);\n\tif (inf->modes->xres == 0 ||\n\t    inf->modes->yres == 0 ||\n\t    inf->modes->bpp == 0) {\n\t\tdev_err(&dev->dev, \"Invalid resolution or bit depth\\n\");\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\tfbi = pxafb_init_fbinfo(&dev->dev, inf);\n\tif (IS_ERR(fbi)) {\n\t\tdev_err(&dev->dev, \"Failed to initialize framebuffer device\\n\");\n\t\tret = PTR_ERR(fbi);\n\t\tgoto failed;\n\t}\n\n\tif (cpu_is_pxa3xx() && inf->acceleration_enabled)\n\t\tfbi->fb.fix.accel = FB_ACCEL_PXA3XX;\n\n\tfbi->backlight_power = inf->pxafb_backlight_power;\n\tfbi->lcd_power = inf->pxafb_lcd_power;\n\n\tfbi->lcd_supply = devm_regulator_get_optional(&dev->dev, \"lcd\");\n\tif (IS_ERR(fbi->lcd_supply)) {\n\t\tif (PTR_ERR(fbi->lcd_supply) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tfbi->lcd_supply = NULL;\n\t}\n\n\tfbi->mmio_base = devm_platform_ioremap_resource(dev, 0);\n\tif (IS_ERR(fbi->mmio_base)) {\n\t\tdev_err(&dev->dev, \"failed to get I/O memory\\n\");\n\t\tret = PTR_ERR(fbi->mmio_base);\n\t\tgoto failed;\n\t}\n\n\tfbi->dma_buff_size = PAGE_ALIGN(sizeof(struct pxafb_dma_buff));\n\tfbi->dma_buff = dma_alloc_coherent(fbi->dev, fbi->dma_buff_size,\n\t\t\t\t&fbi->dma_buff_phys, GFP_KERNEL);\n\tif (fbi->dma_buff == NULL) {\n\t\tdev_err(&dev->dev, \"failed to allocate memory for DMA\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tret = pxafb_init_video_memory(fbi);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"Failed to allocate video RAM: %d\\n\", ret);\n\t\tret = -ENOMEM;\n\t\tgoto failed_free_dma;\n\t}\n\n\tirq = platform_get_irq(dev, 0);\n\tif (irq < 0) {\n\t\tret = -ENODEV;\n\t\tgoto failed_free_mem;\n\t}\n\n\tret = devm_request_irq(&dev->dev, irq, pxafb_handle_irq, 0, \"LCD\", fbi);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"request_irq failed: %d\\n\", ret);\n\t\tret = -EBUSY;\n\t\tgoto failed_free_mem;\n\t}\n\n\tret = pxafb_smart_init(fbi);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"failed to initialize smartpanel\\n\");\n\t\tgoto failed_free_mem;\n\t}\n\n\t \n\tret = pxafb_check_var(&fbi->fb.var, &fbi->fb);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"failed to get suitable mode\\n\");\n\t\tgoto failed_free_mem;\n\t}\n\n\tret = pxafb_set_par(&fbi->fb);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"Failed to set parameters\\n\");\n\t\tgoto failed_free_mem;\n\t}\n\n\tplatform_set_drvdata(dev, fbi);\n\n\tret = register_framebuffer(&fbi->fb);\n\tif (ret < 0) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Failed to register framebuffer device: %d\\n\", ret);\n\t\tgoto failed_free_cmap;\n\t}\n\n\tpxafb_overlay_init(fbi);\n\n#ifdef CONFIG_CPU_FREQ\n\tfbi->freq_transition.notifier_call = pxafb_freq_transition;\n\tcpufreq_register_notifier(&fbi->freq_transition,\n\t\t\t\tCPUFREQ_TRANSITION_NOTIFIER);\n#endif\n\n\t \n\tset_ctrlr_state(fbi, C_ENABLE);\n\n\treturn 0;\n\nfailed_free_cmap:\n\tif (fbi->fb.cmap.len)\n\t\tfb_dealloc_cmap(&fbi->fb.cmap);\nfailed_free_mem:\n\tfree_pages_exact(fbi->video_mem, fbi->video_mem_size);\nfailed_free_dma:\n\tdma_free_coherent(&dev->dev, fbi->dma_buff_size,\n\t\t\tfbi->dma_buff, fbi->dma_buff_phys);\nfailed:\n\treturn ret;\n}\n\nstatic void pxafb_remove(struct platform_device *dev)\n{\n\tstruct pxafb_info *fbi = platform_get_drvdata(dev);\n\tstruct fb_info *info;\n\n\tif (!fbi)\n\t\treturn;\n\n\tinfo = &fbi->fb;\n\n\tpxafb_overlay_exit(fbi);\n\tunregister_framebuffer(info);\n\n\tpxafb_disable_controller(fbi);\n\n\tif (fbi->fb.cmap.len)\n\t\tfb_dealloc_cmap(&fbi->fb.cmap);\n\n\tfree_pages_exact(fbi->video_mem, fbi->video_mem_size);\n\n\tdma_free_coherent(&dev->dev, fbi->dma_buff_size, fbi->dma_buff,\n\t\t\t  fbi->dma_buff_phys);\n}\n\nstatic const struct of_device_id pxafb_of_dev_id[] = {\n\t{ .compatible = \"marvell,pxa270-lcdc\", },\n\t{ .compatible = \"marvell,pxa300-lcdc\", },\n\t{ .compatible = \"marvell,pxa2xx-lcdc\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pxafb_of_dev_id);\n\nstatic struct platform_driver pxafb_driver = {\n\t.probe\t\t= pxafb_probe,\n\t.remove_new \t= pxafb_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"pxa2xx-fb\",\n\t\t.of_match_table = pxafb_of_dev_id,\n#ifdef CONFIG_PM\n\t\t.pm\t= &pxafb_pm_ops,\n#endif\n\t},\n};\n\nstatic int __init pxafb_init(void)\n{\n\tif (pxafb_setup_options())\n\t\treturn -EINVAL;\n\n\treturn platform_driver_register(&pxafb_driver);\n}\n\nstatic void __exit pxafb_exit(void)\n{\n\tplatform_driver_unregister(&pxafb_driver);\n}\n\nmodule_init(pxafb_init);\nmodule_exit(pxafb_exit);\n\nMODULE_DESCRIPTION(\"loadable framebuffer driver for PXA\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}