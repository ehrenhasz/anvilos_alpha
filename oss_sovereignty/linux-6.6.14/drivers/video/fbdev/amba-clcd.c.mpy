{
  "module_name": "amba-clcd.c",
  "hash_id": "8684107503f266c54e405deec0c1cdb08ecf4e3659127fbd855f60f2d6723397",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/amba-clcd.c",
  "human_readable_source": " \n#include <linux/amba/bus.h>\n#include <linux/amba/clcd.h>\n#include <linux/backlight.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_graph.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <video/display_timing.h>\n#include <video/of_display_timing.h>\n#include <video/videomode.h>\n\n#define to_clcd(info)\tcontainer_of(info, struct clcd_fb, fb)\n\n \nstatic const char *clcd_name = \"CLCD FB\";\n\nstatic inline void clcdfb_set_start(struct clcd_fb *fb)\n{\n\tunsigned long ustart = fb->fb.fix.smem_start;\n\tunsigned long lstart;\n\n\tustart += fb->fb.var.yoffset * fb->fb.fix.line_length;\n\tlstart = ustart + fb->fb.var.yres * fb->fb.fix.line_length / 2;\n\n\twritel(ustart, fb->regs + CLCD_UBAS);\n\twritel(lstart, fb->regs + CLCD_LBAS);\n}\n\nstatic void clcdfb_disable(struct clcd_fb *fb)\n{\n\tu32 val;\n\n\tif (fb->board->disable)\n\t\tfb->board->disable(fb);\n\n\tif (fb->panel->backlight) {\n\t\tfb->panel->backlight->props.power = FB_BLANK_POWERDOWN;\n\t\tbacklight_update_status(fb->panel->backlight);\n\t}\n\n\tval = readl(fb->regs + fb->off_cntl);\n\tif (val & CNTL_LCDPWR) {\n\t\tval &= ~CNTL_LCDPWR;\n\t\twritel(val, fb->regs + fb->off_cntl);\n\n\t\tmsleep(20);\n\t}\n\tif (val & CNTL_LCDEN) {\n\t\tval &= ~CNTL_LCDEN;\n\t\twritel(val, fb->regs + fb->off_cntl);\n\t}\n\n\t \n\tif (fb->clk_enabled) {\n\t\tfb->clk_enabled = false;\n\t\tclk_disable(fb->clk);\n\t}\n}\n\nstatic void clcdfb_enable(struct clcd_fb *fb, u32 cntl)\n{\n\t \n\tif (!fb->clk_enabled) {\n\t\tfb->clk_enabled = true;\n\t\tclk_enable(fb->clk);\n\t}\n\n\t \n\tcntl |= CNTL_LCDEN;\n\twritel(cntl, fb->regs + fb->off_cntl);\n\n\tmsleep(20);\n\n\t \n\tcntl |= CNTL_LCDPWR;\n\twritel(cntl, fb->regs + fb->off_cntl);\n\n\t \n\tif (fb->panel->backlight) {\n\t\tfb->panel->backlight->props.power = FB_BLANK_UNBLANK;\n\t\tbacklight_update_status(fb->panel->backlight);\n\t}\n\n\t \n\tif (fb->board->enable)\n\t\tfb->board->enable(fb);\n}\n\nstatic int\nclcdfb_set_bitfields(struct clcd_fb *fb, struct fb_var_screeninfo *var)\n{\n\tu32 caps;\n\tint ret = 0;\n\n\tif (fb->panel->caps && fb->board->caps)\n\t\tcaps = fb->panel->caps & fb->board->caps;\n\telse {\n\t\t \n\t\tcaps = fb->panel->cntl & CNTL_BGR ?\n\t\t\tCLCD_CAP_BGR : CLCD_CAP_RGB;\n\t\t \n\t\tcaps &= ~CLCD_CAP_444;\n\t}\n\n\t \n\tif (!(fb->panel->cntl & CNTL_LCDTFT))\n\t\tcaps &= ~CLCD_CAP_888;\n\n\tmemset(&var->transp, 0, sizeof(var->transp));\n\n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.msb_right = 0;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\t\t \n\t\tcaps &= CLCD_CAP_5551;\n\t\tif (!caps) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tvar->red.length\t\t= var->bits_per_pixel;\n\t\tvar->red.offset\t\t= 0;\n\t\tvar->green.length\t= var->bits_per_pixel;\n\t\tvar->green.offset\t= 0;\n\t\tvar->blue.length\t= var->bits_per_pixel;\n\t\tvar->blue.offset\t= 0;\n\t\tbreak;\n\n\tcase 16:\n\t\t \n\t\tif (!(caps & (CLCD_CAP_444 | CLCD_CAP_5551 | CLCD_CAP_565))) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (var->green.length == 4 && caps & CLCD_CAP_444)\n\t\t\tcaps &= CLCD_CAP_444;\n\t\tif (var->green.length == 5 && caps & CLCD_CAP_5551)\n\t\t\tcaps &= CLCD_CAP_5551;\n\t\telse if (var->green.length == 6 && caps & CLCD_CAP_565)\n\t\t\tcaps &= CLCD_CAP_565;\n\t\telse {\n\t\t\t \n\t\t\tif (caps & CLCD_CAP_565) {\n\t\t\t\tvar->green.length = 6;\n\t\t\t\tcaps &= CLCD_CAP_565;\n\t\t\t} else if (caps & CLCD_CAP_5551) {\n\t\t\t\tvar->green.length = 5;\n\t\t\t\tcaps &= CLCD_CAP_5551;\n\t\t\t} else {\n\t\t\t\tvar->green.length = 4;\n\t\t\t\tcaps &= CLCD_CAP_444;\n\t\t\t}\n\t\t}\n\n\t\tif (var->green.length >= 5) {\n\t\t\tvar->red.length = 5;\n\t\t\tvar->blue.length = 5;\n\t\t} else {\n\t\t\tvar->red.length = 4;\n\t\t\tvar->blue.length = 4;\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\t \n\t\tcaps &= CLCD_CAP_888;\n\t\tif (!caps) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\t \n\tif (ret == 0 && var->bits_per_pixel >= 16) {\n\t\tbool bgr, rgb;\n\n\t\tbgr = caps & CLCD_CAP_BGR && var->blue.offset == 0;\n\t\trgb = caps & CLCD_CAP_RGB && var->red.offset == 0;\n\n\t\tif (!bgr && !rgb)\n\t\t\t \n\t\t\tbgr = caps & CLCD_CAP_BGR;\n\n\t\tif (bgr) {\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->green.offset = var->blue.offset + var->blue.length;\n\t\t\tvar->red.offset = var->green.offset + var->green.length;\n\t\t} else {\n\t\t\tvar->red.offset = 0;\n\t\t\tvar->green.offset = var->red.offset + var->red.length;\n\t\t\tvar->blue.offset = var->green.offset + var->green.length;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int clcdfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct clcd_fb *fb = to_clcd(info);\n\tint ret = -EINVAL;\n\n\tif (fb->board->check)\n\t\tret = fb->board->check(fb, var);\n\n\tif (ret == 0 &&\n\t    var->xres_virtual * var->bits_per_pixel / 8 *\n\t    var->yres_virtual > fb->fb.fix.smem_len)\n\t\tret = -EINVAL;\n\n\tif (ret == 0)\n\t\tret = clcdfb_set_bitfields(fb, var);\n\n\treturn ret;\n}\n\nstatic int clcdfb_set_par(struct fb_info *info)\n{\n\tstruct clcd_fb *fb = to_clcd(info);\n\tstruct clcd_regs regs;\n\n\tfb->fb.fix.line_length = fb->fb.var.xres_virtual *\n\t\t\t\t fb->fb.var.bits_per_pixel / 8;\n\n\tif (fb->fb.var.bits_per_pixel <= 8)\n\t\tfb->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\telse\n\t\tfb->fb.fix.visual = FB_VISUAL_TRUECOLOR;\n\n\tfb->board->decode(fb, &regs);\n\n\tclcdfb_disable(fb);\n\n\twritel(regs.tim0, fb->regs + CLCD_TIM0);\n\twritel(regs.tim1, fb->regs + CLCD_TIM1);\n\twritel(regs.tim2, fb->regs + CLCD_TIM2);\n\twritel(regs.tim3, fb->regs + CLCD_TIM3);\n\n\tclcdfb_set_start(fb);\n\n\tclk_set_rate(fb->clk, (1000000000 / regs.pixclock) * 1000);\n\n\tfb->clcd_cntl = regs.cntl;\n\n\tclcdfb_enable(fb, regs.cntl);\n\n#ifdef DEBUG\n\tprintk(KERN_INFO\n\t       \"CLCD: Registers set to\\n\"\n\t       \"  %08x %08x %08x %08x\\n\"\n\t       \"  %08x %08x %08x %08x\\n\",\n\t\treadl(fb->regs + CLCD_TIM0), readl(fb->regs + CLCD_TIM1),\n\t\treadl(fb->regs + CLCD_TIM2), readl(fb->regs + CLCD_TIM3),\n\t\treadl(fb->regs + CLCD_UBAS), readl(fb->regs + CLCD_LBAS),\n\t\treadl(fb->regs + fb->off_ienb), readl(fb->regs + fb->off_cntl));\n#endif\n\n\treturn 0;\n}\n\nstatic inline u32 convert_bitfield(int val, struct fb_bitfield *bf)\n{\n\tunsigned int mask = (1 << bf->length) - 1;\n\n\treturn (val >> (16 - bf->length) & mask) << bf->offset;\n}\n\n \nstatic int\nclcdfb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,\n\t\t unsigned int blue, unsigned int transp, struct fb_info *info)\n{\n\tstruct clcd_fb *fb = to_clcd(info);\n\n\tif (regno < 16)\n\t\tfb->cmap[regno] = convert_bitfield(transp, &fb->fb.var.transp) |\n\t\t\t\t  convert_bitfield(blue, &fb->fb.var.blue) |\n\t\t\t\t  convert_bitfield(green, &fb->fb.var.green) |\n\t\t\t\t  convert_bitfield(red, &fb->fb.var.red);\n\n\tif (fb->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR && regno < 256) {\n\t\tint hw_reg = CLCD_PALETTE + ((regno * 2) & ~3);\n\t\tu32 val, mask, newval;\n\n\t\tnewval  = (red >> 11)  & 0x001f;\n\t\tnewval |= (green >> 6) & 0x03e0;\n\t\tnewval |= (blue >> 1)  & 0x7c00;\n\n\t\t \n\t\tif (fb->clcd_cntl & CNTL_BEBO)\n\t\t\tregno ^= 1;\n\n\t\tif (regno & 1) {\n\t\t\tnewval <<= 16;\n\t\t\tmask = 0x0000ffff;\n\t\t} else {\n\t\t\tmask = 0xffff0000;\n\t\t}\n\n\t\tval = readl(fb->regs + hw_reg) & mask;\n\t\twritel(val | newval, fb->regs + hw_reg);\n\t}\n\n\treturn regno > 255;\n}\n\n \nstatic int clcdfb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct clcd_fb *fb = to_clcd(info);\n\n\tif (blank_mode != 0) {\n\t\tclcdfb_disable(fb);\n\t} else {\n\t\tclcdfb_enable(fb, fb->clcd_cntl);\n\t}\n\treturn 0;\n}\n\nstatic int clcdfb_mmap(struct fb_info *info,\n\t\t       struct vm_area_struct *vma)\n{\n\tstruct clcd_fb *fb = to_clcd(info);\n\tunsigned long len, off = vma->vm_pgoff << PAGE_SHIFT;\n\tint ret = -EINVAL;\n\n\tlen = info->fix.smem_len;\n\n\tif (off <= len && vma->vm_end - vma->vm_start <= len - off &&\n\t    fb->board->mmap)\n\t\tret = fb->board->mmap(fb, vma);\n\n\treturn ret;\n}\n\nstatic const struct fb_ops clcdfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= clcdfb_check_var,\n\t.fb_set_par\t= clcdfb_set_par,\n\t.fb_setcolreg\t= clcdfb_setcolreg,\n\t.fb_blank\t= clcdfb_blank,\n\t.fb_fillrect\t= cfb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n\t.fb_mmap\t= clcdfb_mmap,\n};\n\nstatic int clcdfb_register(struct clcd_fb *fb)\n{\n\tint ret;\n\n\t \n\tif (amba_manf(fb->dev) == 0x41 && amba_part(fb->dev) == 0x111) {\n\t\tfb->off_ienb = CLCD_PL111_IENB;\n\t\tfb->off_cntl = CLCD_PL111_CNTL;\n\t} else {\n\t\tfb->off_ienb = CLCD_PL110_IENB;\n\t\tfb->off_cntl = CLCD_PL110_CNTL;\n\t}\n\n\tfb->clk = clk_get(&fb->dev->dev, NULL);\n\tif (IS_ERR(fb->clk)) {\n\t\tret = PTR_ERR(fb->clk);\n\t\tgoto out;\n\t}\n\n\tret = clk_prepare(fb->clk);\n\tif (ret)\n\t\tgoto free_clk;\n\n\tfb->fb.device\t\t= &fb->dev->dev;\n\n\tfb->fb.fix.mmio_start\t= fb->dev->res.start;\n\tfb->fb.fix.mmio_len\t= resource_size(&fb->dev->res);\n\n\tfb->regs = ioremap(fb->fb.fix.mmio_start, fb->fb.fix.mmio_len);\n\tif (!fb->regs) {\n\t\tprintk(KERN_ERR \"CLCD: unable to remap registers\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clk_unprep;\n\t}\n\n\tfb->fb.fbops\t\t= &clcdfb_ops;\n\tfb->fb.pseudo_palette\t= fb->cmap;\n\n\tstrncpy(fb->fb.fix.id, clcd_name, sizeof(fb->fb.fix.id));\n\tfb->fb.fix.type\t\t= FB_TYPE_PACKED_PIXELS;\n\tfb->fb.fix.type_aux\t= 0;\n\tfb->fb.fix.xpanstep\t= 0;\n\tfb->fb.fix.ypanstep\t= 0;\n\tfb->fb.fix.ywrapstep\t= 0;\n\tfb->fb.fix.accel\t= FB_ACCEL_NONE;\n\n\tfb->fb.var.xres\t\t= fb->panel->mode.xres;\n\tfb->fb.var.yres\t\t= fb->panel->mode.yres;\n\tfb->fb.var.xres_virtual\t= fb->panel->mode.xres;\n\tfb->fb.var.yres_virtual\t= fb->panel->mode.yres;\n\tfb->fb.var.bits_per_pixel = fb->panel->bpp;\n\tfb->fb.var.grayscale\t= fb->panel->grayscale;\n\tfb->fb.var.pixclock\t= fb->panel->mode.pixclock;\n\tfb->fb.var.left_margin\t= fb->panel->mode.left_margin;\n\tfb->fb.var.right_margin\t= fb->panel->mode.right_margin;\n\tfb->fb.var.upper_margin\t= fb->panel->mode.upper_margin;\n\tfb->fb.var.lower_margin\t= fb->panel->mode.lower_margin;\n\tfb->fb.var.hsync_len\t= fb->panel->mode.hsync_len;\n\tfb->fb.var.vsync_len\t= fb->panel->mode.vsync_len;\n\tfb->fb.var.sync\t\t= fb->panel->mode.sync;\n\tfb->fb.var.vmode\t= fb->panel->mode.vmode;\n\tfb->fb.var.activate\t= FB_ACTIVATE_NOW;\n\tfb->fb.var.nonstd\t= 0;\n\tfb->fb.var.height\t= fb->panel->height;\n\tfb->fb.var.width\t= fb->panel->width;\n\tfb->fb.var.accel_flags\t= 0;\n\n\tfb->fb.monspecs.hfmin\t= 0;\n\tfb->fb.monspecs.hfmax   = 100000;\n\tfb->fb.monspecs.vfmin\t= 0;\n\tfb->fb.monspecs.vfmax\t= 400;\n\tfb->fb.monspecs.dclkmin = 1000000;\n\tfb->fb.monspecs.dclkmax\t= 100000000;\n\n\t \n\tclcdfb_set_bitfields(fb, &fb->fb.var);\n\n\t \n\tret = fb_alloc_cmap(&fb->fb.cmap, 256, 0);\n\tif (ret)\n\t\tgoto unmap;\n\n\t \n\twritel(0, fb->regs + fb->off_ienb);\n\n\tfb_set_var(&fb->fb, &fb->fb.var);\n\n\tdev_info(&fb->dev->dev, \"%s hardware, %s display\\n\",\n\t         fb->board->name, fb->panel->mode.name);\n\n\tret = register_framebuffer(&fb->fb);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tprintk(KERN_ERR \"CLCD: cannot register framebuffer (%d)\\n\", ret);\n\n\tfb_dealloc_cmap(&fb->fb.cmap);\n unmap:\n\tiounmap(fb->regs);\n clk_unprep:\n\tclk_unprepare(fb->clk);\n free_clk:\n\tclk_put(fb->clk);\n out:\n\treturn ret;\n}\n\n#ifdef CONFIG_OF\nstatic int clcdfb_of_get_dpi_panel_mode(struct device_node *node,\n\t\tstruct clcd_panel *clcd_panel)\n{\n\tint err;\n\tstruct display_timing timing;\n\tstruct videomode video;\n\n\terr = of_get_display_timing(node, \"panel-timing\", &timing);\n\tif (err) {\n\t\tpr_err(\"%pOF: problems parsing panel-timing (%d)\\n\", node, err);\n\t\treturn err;\n\t}\n\n\tvideomode_from_timing(&timing, &video);\n\n\terr = fb_videomode_from_videomode(&video, &clcd_panel->mode);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (timing.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)\n\t\tclcd_panel->tim2 |= TIM2_IPC;\n\telse if (!(timing.flags & DISPLAY_FLAGS_PIXDATA_POSEDGE))\n\t\t \n\t\tclcd_panel->tim2 |= TIM2_IPC;\n\n\tif (timing.flags & DISPLAY_FLAGS_HSYNC_LOW)\n\t\tclcd_panel->tim2 |= TIM2_IHS;\n\n\tif (timing.flags & DISPLAY_FLAGS_VSYNC_LOW)\n\t\tclcd_panel->tim2 |= TIM2_IVS;\n\n\tif (timing.flags & DISPLAY_FLAGS_DE_LOW)\n\t\tclcd_panel->tim2 |= TIM2_IOE;\n\n\treturn 0;\n}\n\nstatic int clcdfb_snprintf_mode(char *buf, int size, struct fb_videomode *mode)\n{\n\treturn snprintf(buf, size, \"%ux%u@%u\", mode->xres, mode->yres,\n\t\t\tmode->refresh);\n}\n\nstatic int clcdfb_of_get_backlight(struct device *dev,\n\t\t\t\t   struct clcd_panel *clcd_panel)\n{\n\tstruct backlight_device *backlight;\n\n\t \n\tbacklight = devm_of_find_backlight(dev);\n\tif (IS_ERR(backlight))\n\t\treturn PTR_ERR(backlight);\n\n\tclcd_panel->backlight = backlight;\n\treturn 0;\n}\n\nstatic int clcdfb_of_get_mode(struct device *dev, struct device_node *panel,\n\t\t\t      struct clcd_panel *clcd_panel)\n{\n\tint err;\n\tstruct fb_videomode *mode;\n\tchar *name;\n\tint len;\n\n\t \n\tif (of_device_is_compatible(panel, \"panel-dpi\"))\n\t\terr = clcdfb_of_get_dpi_panel_mode(panel, clcd_panel);\n\telse\n\t\terr = -ENOENT;\n\tif (err)\n\t\treturn err;\n\tmode = &clcd_panel->mode;\n\n\tlen = clcdfb_snprintf_mode(NULL, 0, mode);\n\tname = devm_kzalloc(dev, len + 1, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tclcdfb_snprintf_mode(name, len + 1, mode);\n\tmode->name = name;\n\n\treturn 0;\n}\n\nstatic int clcdfb_of_init_tft_panel(struct clcd_fb *fb, u32 r0, u32 g0, u32 b0)\n{\n\tstatic struct {\n\t\tunsigned int part;\n\t\tu32 r0, g0, b0;\n\t\tu32 caps;\n\t} panels[] = {\n\t\t{ 0x110, 1,  7, 13, CLCD_CAP_5551 },\n\t\t{ 0x110, 0,  8, 16, CLCD_CAP_888 },\n\t\t{ 0x110, 16, 8, 0,  CLCD_CAP_888 },\n\t\t{ 0x111, 4, 14, 20, CLCD_CAP_444 },\n\t\t{ 0x111, 3, 11, 19, CLCD_CAP_444 | CLCD_CAP_5551 },\n\t\t{ 0x111, 3, 10, 19, CLCD_CAP_444 | CLCD_CAP_5551 |\n\t\t\t\t    CLCD_CAP_565 },\n\t\t{ 0x111, 0,  8, 16, CLCD_CAP_444 | CLCD_CAP_5551 |\n\t\t\t\t    CLCD_CAP_565 | CLCD_CAP_888 },\n\t};\n\tint i;\n\n\t \n\tfb->panel->tim2 |= TIM2_BCD;\n\n\t \n\tfb->panel->cntl |= CNTL_LCDTFT | CNTL_LCDVCOMP(1);\n\n\tfb->panel->caps = 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(panels) && !fb->panel->caps; i++) {\n\t\tif (amba_part(fb->dev) != panels[i].part)\n\t\t\tcontinue;\n\t\tif (g0 != panels[i].g0)\n\t\t\tcontinue;\n\t\tif (r0 == panels[i].r0 && b0 == panels[i].b0)\n\t\t\tfb->panel->caps = panels[i].caps;\n\t}\n\n\t \n\tif (r0 != 0 && b0 == 0)\n\t\tfb->panel->bgr_connection = true;\n\n\treturn fb->panel->caps ? 0 : -EINVAL;\n}\n\nstatic int clcdfb_of_init_display(struct clcd_fb *fb)\n{\n\tstruct device_node *endpoint, *panel;\n\tint err;\n\tunsigned int bpp;\n\tu32 max_bandwidth;\n\tu32 tft_r0b0g0[3];\n\n\tfb->panel = devm_kzalloc(&fb->dev->dev, sizeof(*fb->panel), GFP_KERNEL);\n\tif (!fb->panel)\n\t\treturn -ENOMEM;\n\n\t \n\tendpoint = of_graph_get_next_endpoint(fb->dev->dev.of_node, NULL);\n\tif (!endpoint)\n\t\treturn -ENODEV;\n\n\tpanel = of_graph_get_remote_port_parent(endpoint);\n\tif (!panel) {\n\t\terr = -ENODEV;\n\t\tgoto out_endpoint_put;\n\t}\n\n\terr = clcdfb_of_get_backlight(&fb->dev->dev, fb->panel);\n\tif (err)\n\t\tgoto out_panel_put;\n\n\terr = clcdfb_of_get_mode(&fb->dev->dev, panel, fb->panel);\n\tif (err)\n\t\tgoto out_panel_put;\n\n\terr = of_property_read_u32(fb->dev->dev.of_node, \"max-memory-bandwidth\",\n\t\t\t&max_bandwidth);\n\tif (!err) {\n\t\t \n\t\tbpp = max_bandwidth / (1000 / 8)\n\t\t\t/ PICOS2KHZ(fb->panel->mode.pixclock);\n\t\tbpp = rounddown_pow_of_two(bpp);\n\t\tif (bpp > 32)\n\t\t\tbpp = 32;\n\t} else\n\t\tbpp = 32;\n\tfb->panel->bpp = bpp;\n\n#ifdef CONFIG_CPU_BIG_ENDIAN\n\tfb->panel->cntl |= CNTL_BEBO;\n#endif\n\tfb->panel->width = -1;\n\tfb->panel->height = -1;\n\n\tif (of_property_read_u32_array(endpoint,\n\t\t\t\"arm,pl11x,tft-r0g0b0-pads\",\n\t\t\ttft_r0b0g0, ARRAY_SIZE(tft_r0b0g0)) != 0) {\n\t\terr = -ENOENT;\n\t\tgoto out_panel_put;\n\t}\n\n\tof_node_put(panel);\n\tof_node_put(endpoint);\n\n\treturn clcdfb_of_init_tft_panel(fb, tft_r0b0g0[0],\n\t\t\t\t\ttft_r0b0g0[1],  tft_r0b0g0[2]);\nout_panel_put:\n\tof_node_put(panel);\nout_endpoint_put:\n\tof_node_put(endpoint);\n\treturn err;\n}\n\nstatic int clcdfb_of_vram_setup(struct clcd_fb *fb)\n{\n\tint err;\n\tstruct device_node *memory;\n\tu64 size;\n\n\terr = clcdfb_of_init_display(fb);\n\tif (err)\n\t\treturn err;\n\n\tmemory = of_parse_phandle(fb->dev->dev.of_node, \"memory-region\", 0);\n\tif (!memory)\n\t\treturn -ENODEV;\n\n\tfb->fb.screen_base = of_iomap(memory, 0);\n\tif (!fb->fb.screen_base) {\n\t\tof_node_put(memory);\n\t\treturn -ENOMEM;\n\t}\n\n\tfb->fb.fix.smem_start = of_translate_address(memory,\n\t\t\tof_get_address(memory, 0, &size, NULL));\n\tfb->fb.fix.smem_len = size;\n\tof_node_put(memory);\n\n\treturn 0;\n}\n\nstatic int clcdfb_of_vram_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)\n{\n\tunsigned long off, user_size, kernel_size;\n\n\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tuser_size = vma->vm_end - vma->vm_start;\n\tkernel_size = fb->fb.fix.smem_len;\n\n\tif (off >= kernel_size || user_size > (kernel_size - off))\n\t\treturn -ENXIO;\n\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t__phys_to_pfn(fb->fb.fix.smem_start) + vma->vm_pgoff,\n\t\t\tuser_size,\n\t\t\tpgprot_writecombine(vma->vm_page_prot));\n}\n\nstatic void clcdfb_of_vram_remove(struct clcd_fb *fb)\n{\n\tiounmap(fb->fb.screen_base);\n}\n\nstatic int clcdfb_of_dma_setup(struct clcd_fb *fb)\n{\n\tunsigned long framesize;\n\tdma_addr_t dma;\n\tint err;\n\n\terr = clcdfb_of_init_display(fb);\n\tif (err)\n\t\treturn err;\n\n\tframesize = PAGE_ALIGN(fb->panel->mode.xres * fb->panel->mode.yres *\n\t\t\tfb->panel->bpp / 8);\n\tfb->fb.screen_base = dma_alloc_coherent(&fb->dev->dev, framesize,\n\t\t\t&dma, GFP_KERNEL);\n\tif (!fb->fb.screen_base)\n\t\treturn -ENOMEM;\n\n\tfb->fb.fix.smem_start = dma;\n\tfb->fb.fix.smem_len = framesize;\n\n\treturn 0;\n}\n\nstatic int clcdfb_of_dma_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)\n{\n\treturn dma_mmap_wc(&fb->dev->dev, vma, fb->fb.screen_base,\n\t\t\t   fb->fb.fix.smem_start, fb->fb.fix.smem_len);\n}\n\nstatic void clcdfb_of_dma_remove(struct clcd_fb *fb)\n{\n\tdma_free_coherent(&fb->dev->dev, fb->fb.fix.smem_len,\n\t\t\tfb->fb.screen_base, fb->fb.fix.smem_start);\n}\n\nstatic struct clcd_board *clcdfb_of_get_board(struct amba_device *dev)\n{\n\tstruct clcd_board *board = devm_kzalloc(&dev->dev, sizeof(*board),\n\t\t\tGFP_KERNEL);\n\tstruct device_node *node = dev->dev.of_node;\n\n\tif (!board)\n\t\treturn NULL;\n\n\tboard->name = of_node_full_name(node);\n\tboard->caps = CLCD_CAP_ALL;\n\tboard->check = clcdfb_check;\n\tboard->decode = clcdfb_decode;\n\tif (of_property_present(node, \"memory-region\")) {\n\t\tboard->setup = clcdfb_of_vram_setup;\n\t\tboard->mmap = clcdfb_of_vram_mmap;\n\t\tboard->remove = clcdfb_of_vram_remove;\n\t} else {\n\t\tboard->setup = clcdfb_of_dma_setup;\n\t\tboard->mmap = clcdfb_of_dma_mmap;\n\t\tboard->remove = clcdfb_of_dma_remove;\n\t}\n\n\treturn board;\n}\n#else\nstatic struct clcd_board *clcdfb_of_get_board(struct amba_device *dev)\n{\n\treturn NULL;\n}\n#endif\n\nstatic int clcdfb_probe(struct amba_device *dev, const struct amba_id *id)\n{\n\tstruct clcd_board *board = dev_get_platdata(&dev->dev);\n\tstruct clcd_fb *fb;\n\tint ret;\n\n\tif (!board)\n\t\tboard = clcdfb_of_get_board(dev);\n\n\tif (!board)\n\t\treturn -EINVAL;\n\n\tret = dma_set_mask_and_coherent(&dev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\tgoto out;\n\n\tret = amba_request_regions(dev, NULL);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"CLCD: unable to reserve regs region\\n\");\n\t\tgoto out;\n\t}\n\n\tfb = kzalloc(sizeof(*fb), GFP_KERNEL);\n\tif (!fb) {\n\t\tret = -ENOMEM;\n\t\tgoto free_region;\n\t}\n\n\tfb->dev = dev;\n\tfb->board = board;\n\n\tdev_info(&fb->dev->dev, \"PL%03x designer %02x rev%u at 0x%08llx\\n\",\n\t\tamba_part(dev), amba_manf(dev), amba_rev(dev),\n\t\t(unsigned long long)dev->res.start);\n\n\tret = fb->board->setup(fb);\n\tif (ret)\n\t\tgoto free_fb;\n\n\tret = clcdfb_register(fb);\n\tif (ret == 0) {\n\t\tamba_set_drvdata(dev, fb);\n\t\tgoto out;\n\t}\n\n\tfb->board->remove(fb);\n free_fb:\n\tkfree(fb);\n free_region:\n\tamba_release_regions(dev);\n out:\n\treturn ret;\n}\n\nstatic void clcdfb_remove(struct amba_device *dev)\n{\n\tstruct clcd_fb *fb = amba_get_drvdata(dev);\n\n\tclcdfb_disable(fb);\n\tunregister_framebuffer(&fb->fb);\n\tif (fb->fb.cmap.len)\n\t\tfb_dealloc_cmap(&fb->fb.cmap);\n\tiounmap(fb->regs);\n\tclk_unprepare(fb->clk);\n\tclk_put(fb->clk);\n\n\tfb->board->remove(fb);\n\n\tkfree(fb);\n\n\tamba_release_regions(dev);\n}\n\nstatic const struct amba_id clcdfb_id_table[] = {\n\t{\n\t\t.id\t= 0x00041110,\n\t\t.mask\t= 0x000ffffe,\n\t},\n\t{ 0, 0 },\n};\n\nMODULE_DEVICE_TABLE(amba, clcdfb_id_table);\n\nstatic struct amba_driver clcd_driver = {\n\t.drv \t\t= {\n\t\t.name\t= \"clcd-pl11x\",\n\t},\n\t.probe\t\t= clcdfb_probe,\n\t.remove\t\t= clcdfb_remove,\n\t.id_table\t= clcdfb_id_table,\n};\n\nstatic int __init amba_clcdfb_init(void)\n{\n\tif (fb_get_options(\"ambafb\", NULL))\n\t\treturn -ENODEV;\n\n\treturn amba_driver_register(&clcd_driver);\n}\n\nmodule_init(amba_clcdfb_init);\n\nstatic void __exit amba_clcdfb_exit(void)\n{\n\tamba_driver_unregister(&clcd_driver);\n}\n\nmodule_exit(amba_clcdfb_exit);\n\nMODULE_DESCRIPTION(\"ARM PrimeCell PL110 CLCD core driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}