{
  "module_name": "asiliantfb.c",
  "hash_id": "c318a4aa22aced5fa70ef2a8e301b9690d1cc716e9220f5d85e5787e19b7ae1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/asiliantfb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <asm/io.h>\n\n \nstatic const unsigned Fref = 14318180;\n\n#define mmio_base (p->screen_base + 0x400000)\n\n#define mm_write_ind(num, val, ap, dp)\tdo { \\\n\twriteb((num), mmio_base + (ap)); writeb((val), mmio_base + (dp)); \\\n} while (0)\n\nstatic void mm_write_xr(struct fb_info *p, u8 reg, u8 data)\n{\n\tmm_write_ind(reg, data, 0x7ac, 0x7ad);\n}\n#define write_xr(num, val)\tmm_write_xr(p, num, val)\n\nstatic void mm_write_fr(struct fb_info *p, u8 reg, u8 data)\n{\n\tmm_write_ind(reg, data, 0x7a0, 0x7a1);\n}\n#define write_fr(num, val)\tmm_write_fr(p, num, val)\n\nstatic void mm_write_cr(struct fb_info *p, u8 reg, u8 data)\n{\n\tmm_write_ind(reg, data, 0x7a8, 0x7a9);\n}\n#define write_cr(num, val)\tmm_write_cr(p, num, val)\n\nstatic void mm_write_gr(struct fb_info *p, u8 reg, u8 data)\n{\n\tmm_write_ind(reg, data, 0x79c, 0x79d);\n}\n#define write_gr(num, val)\tmm_write_gr(p, num, val)\n\nstatic void mm_write_sr(struct fb_info *p, u8 reg, u8 data)\n{\n\tmm_write_ind(reg, data, 0x788, 0x789);\n}\n#define write_sr(num, val)\tmm_write_sr(p, num, val)\n\nstatic void mm_write_ar(struct fb_info *p, u8 reg, u8 data)\n{\n\treadb(mmio_base + 0x7b4);\n\tmm_write_ind(reg, data, 0x780, 0x780);\n}\n#define write_ar(num, val)\tmm_write_ar(p, num, val)\n\nstatic int asiliantfb_pci_init(struct pci_dev *dp, const struct pci_device_id *);\nstatic int asiliantfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info);\nstatic int asiliantfb_set_par(struct fb_info *info);\nstatic int asiliantfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t\tu_int transp, struct fb_info *info);\n\nstatic const struct fb_ops asiliantfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= asiliantfb_check_var,\n\t.fb_set_par\t= asiliantfb_set_par,\n\t.fb_setcolreg\t= asiliantfb_setcolreg,\n};\n\n \nstatic void asiliant_calc_dclk2(u32 *ppixclock, u8 *dclk2_m, u8 *dclk2_n, u8 *dclk2_div)\n{\n\tunsigned pixclock = *ppixclock;\n\tunsigned Ftarget;\n\tunsigned n;\n\tunsigned best_error = 0xffffffff;\n\tunsigned best_m = 0xffffffff,\n\t         best_n = 0xffffffff;\n\tunsigned ratio;\n\tunsigned remainder;\n\tunsigned char divisor = 0;\n\n\t \n\tratio = 1000000 / pixclock;\n\tremainder = 1000000 % pixclock;\n\tFtarget = 1000000 * ratio + (1000000 * remainder) / pixclock;\n\n\twhile (Ftarget < 100000000) {\n\t\tdivisor += 0x10;\n\t\tFtarget <<= 1;\n\t}\n\n\tratio = Ftarget / Fref;\n\tremainder = Ftarget % Fref;\n\n\t \n\tfor (n = 3; n <= 257; n++) {\n\t\tunsigned m = n * ratio + (n * remainder) / Fref;\n\n\t\t \n\t\tif (m >= 3 && m <= 257) {\n\t\t\tunsigned new_error = Ftarget * n >= Fref * m ?\n\t\t\t\t\t       ((Ftarget * n) - (Fref * m)) : ((Fref * m) - (Ftarget * n));\n\t\t\tif (new_error < best_error) {\n\t\t\t\tbest_n = n;\n\t\t\t\tbest_m = m;\n\t\t\t\tbest_error = new_error;\n\t\t\t}\n\t\t}\n\t\t \n\t\telse if (m <= 1028) {\n\t\t\t \n\t\t\tunsigned new_error = Ftarget * n >= Fref * (m & ~3) ?\n\t\t\t\t\t       ((Ftarget * n) - (Fref * (m & ~3))) : ((Fref * (m & ~3)) - (Ftarget * n));\n\t\t\tif (new_error < best_error) {\n\t\t\t\tbest_n = n;\n\t\t\t\tbest_m = m;\n\t\t\t\tbest_error = new_error;\n\t\t\t}\n\t\t}\n\t}\n\tif (best_m > 257)\n\t\tbest_m >>= 2;\t \n\telse\n\t\tdivisor |= 4;\t \n\t*dclk2_m = best_m - 2;\n\t*dclk2_n = best_n - 2;\n\t*dclk2_div = divisor;\n\t*ppixclock = pixclock;\n\treturn;\n}\n\nstatic void asiliant_set_timing(struct fb_info *p)\n{\n\tunsigned hd = p->var.xres / 8;\n\tunsigned hs = (p->var.xres + p->var.right_margin) / 8;\n       \tunsigned he = (p->var.xres + p->var.right_margin + p->var.hsync_len) / 8;\n\tunsigned ht = (p->var.left_margin + p->var.xres + p->var.right_margin + p->var.hsync_len) / 8;\n\tunsigned vd = p->var.yres;\n\tunsigned vs = p->var.yres + p->var.lower_margin;\n\tunsigned ve = p->var.yres + p->var.lower_margin + p->var.vsync_len;\n\tunsigned vt = p->var.upper_margin + p->var.yres + p->var.lower_margin + p->var.vsync_len;\n\tunsigned wd = (p->var.xres_virtual * ((p->var.bits_per_pixel+7)/8)) / 8;\n\n\tif ((p->var.xres == 640) && (p->var.yres == 480) && (p->var.pixclock == 39722)) {\n\t  write_fr(0x01, 0x02);   \n\t} else {\n\t  write_fr(0x01, 0x01);   \n\t}\n\n\twrite_cr(0x11, (ve - 1) & 0x0f);\n\twrite_cr(0x00, (ht - 5) & 0xff);\n\twrite_cr(0x01, hd - 1);\n\twrite_cr(0x02, hd);\n\twrite_cr(0x03, ((ht - 1) & 0x1f) | 0x80);\n\twrite_cr(0x04, hs);\n\twrite_cr(0x05, (((ht - 1) & 0x20) <<2) | (he & 0x1f));\n\twrite_cr(0x3c, (ht - 1) & 0xc0);\n\twrite_cr(0x06, (vt - 2) & 0xff);\n\twrite_cr(0x30, (vt - 2) >> 8);\n\twrite_cr(0x07, 0x00);\n\twrite_cr(0x08, 0x00);\n\twrite_cr(0x09, 0x00);\n\twrite_cr(0x10, (vs - 1) & 0xff);\n\twrite_cr(0x32, ((vs - 1) >> 8) & 0xf);\n\twrite_cr(0x11, ((ve - 1) & 0x0f) | 0x80);\n\twrite_cr(0x12, (vd - 1) & 0xff);\n\twrite_cr(0x31, ((vd - 1) & 0xf00) >> 8);\n\twrite_cr(0x13, wd & 0xff);\n\twrite_cr(0x41, (wd & 0xf00) >> 8);\n\twrite_cr(0x15, (vs - 1) & 0xff);\n\twrite_cr(0x33, ((vs - 1) >> 8) & 0xf);\n\twrite_cr(0x38, ((ht - 5) & 0x100) >> 8);\n\twrite_cr(0x16, (vt - 1) & 0xff);\n\twrite_cr(0x18, 0x00);\n\n\tif (p->var.xres == 640) {\n\t  writeb(0xc7, mmio_base + 0x784);\t \n\t} else {\n\t  writeb(0x07, mmio_base + 0x784);\t \n\t}\n}\n\nstatic int asiliantfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *p)\n{\n\tunsigned long Ftarget, ratio, remainder;\n\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\tratio = 1000000 / var->pixclock;\n\tremainder = 1000000 % var->pixclock;\n\tFtarget = 1000000 * ratio + (1000000 * remainder) / var->pixclock;\n\n\t \n\tif (Ftarget > 220000000 || Ftarget < 3125000) {\n\t\tprintk(KERN_ERR \"asiliantfb dotclock must be between 3.125 and 220MHz\\n\");\n\t\treturn -ENXIO;\n\t}\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = var->yres;\n\n\tif (var->bits_per_pixel == 24) {\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = var->blue.length = var->green.length = 8;\n\t} else if (var->bits_per_pixel == 16) {\n\t\tswitch (var->red.offset) {\n\t\t\tcase 11:\n\t\t\t\tvar->green.length = 6;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tvar->green.length = 5;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tvar->green.offset = 5;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = var->blue.length = 5;\n\t} else if (var->bits_per_pixel == 8) {\n\t\tvar->red.offset = var->green.offset = var->blue.offset = 0;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t}\n\treturn 0;\n}\n\nstatic int asiliantfb_set_par(struct fb_info *p)\n{\n\tu8 dclk2_m;\t\t \n\tu8 dclk2_n;\t\t \n\tu8 dclk2_div;\t\t \n\n\t \n\tasiliant_calc_dclk2(&p->var.pixclock, &dclk2_m, &dclk2_n, &dclk2_div);\n\n\t \n\tif (p->var.bits_per_pixel == 24) {\n\t\twrite_xr(0x81, 0x16);\t \n\t\twrite_xr(0x82, 0x00);\t \n\t\twrite_xr(0x20, 0x20);\t \n\t} else if (p->var.bits_per_pixel == 16) {\n\t\tif (p->var.red.offset == 11)\n\t\t\twrite_xr(0x81, 0x15);\t \n\t\telse\n\t\t\twrite_xr(0x81, 0x14);\t \n\t\twrite_xr(0x82, 0x00);\t \n\t\twrite_xr(0x20, 0x10);\t \n\t} else if (p->var.bits_per_pixel == 8) {\n\t\twrite_xr(0x0a, 0x02);\t \n\t\twrite_xr(0x81, 0x12);\t \n\t\twrite_xr(0x82, 0x00);\t \n\t\twrite_xr(0x20, 0x00);\t \n\t}\n\tp->fix.line_length = p->var.xres * (p->var.bits_per_pixel >> 3);\n\tp->fix.visual = (p->var.bits_per_pixel == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\twrite_xr(0xc4, dclk2_m);\n\twrite_xr(0xc5, dclk2_n);\n\twrite_xr(0xc7, dclk2_div);\n\t \n\tasiliant_set_timing(p);\n\treturn 0;\n}\n\nstatic int asiliantfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t     u_int transp, struct fb_info *p)\n{\n\tif (regno > 255)\n\t\treturn 1;\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n         \n\twriteb(regno, mmio_base + 0x790);\n\tudelay(1);\n\twriteb(red, mmio_base + 0x791);\n\twriteb(green, mmio_base + 0x791);\n\twriteb(blue, mmio_base + 0x791);\n\n\tif (regno < 16) {\n\t\tswitch(p->var.red.offset) {\n\t\tcase 10:  \n\t\t\t((u32 *)(p->pseudo_palette))[regno] =\n\t\t\t\t((red & 0xf8) << 7) |\n\t\t\t\t((green & 0xf8) << 2) |\n\t\t\t\t((blue & 0xf8) >> 3);\n\t\t\tbreak;\n\t\tcase 11:  \n\t\t\t((u32 *)(p->pseudo_palette))[regno] =\n\t\t\t\t((red & 0xf8) << 8) |\n\t\t\t\t((green & 0xfc) << 3) |\n\t\t\t\t((blue & 0xf8) >> 3);\n\t\t\tbreak;\n\t\tcase 16:  \n\t\t\t((u32 *)(p->pseudo_palette))[regno] =\n\t\t\t\t(red << 16)  |\n\t\t\t\t(green << 8) |\n\t\t\t\t(blue);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct chips_init_reg {\n\tunsigned char addr;\n\tunsigned char data;\n};\n\nstatic struct chips_init_reg chips_init_sr[] =\n{\n\t{0x00, 0x03},\t\t \n\t{0x01, 0x01},\t\t \n\t{0x02, 0x0f},\t\t \n\t{0x04, 0x0e}\t\t \n};\n\nstatic struct chips_init_reg chips_init_gr[] =\n{\n        {0x03, 0x00},\t\t \n\t{0x05, 0x00},\t\t \n\t{0x06, 0x01},\t\t \n\t{0x08, 0x00}\t\t \n};\n\nstatic struct chips_init_reg chips_init_ar[] =\n{\n\t{0x10, 0x01},\t\t \n\t{0x11, 0x00},\t\t \n\t{0x12, 0x0f},\t\t \n\t{0x13, 0x00}\t\t \n};\n\nstatic struct chips_init_reg chips_init_cr[] =\n{\n\t{0x0c, 0x00},\t\t \n\t{0x0d, 0x00},\t\t \n\t{0x40, 0x00},\t\t \n\t{0x41, 0x00},\t\t \n\t{0x14, 0x00},\t\t \n\t{0x17, 0xe3},\t\t \n\t{0x70, 0x00}\t\t \n};\n\n\nstatic struct chips_init_reg chips_init_fr[] =\n{\n\t{0x01, 0x02},\n\t{0x03, 0x08},\n\t{0x08, 0xcc},\n\t{0x0a, 0x08},\n\t{0x18, 0x00},\n\t{0x1e, 0x80},\n\t{0x40, 0x83},\n\t{0x41, 0x00},\n\t{0x48, 0x13},\n\t{0x4d, 0x60},\n\t{0x4e, 0x0f},\n\n\t{0x0b, 0x01},\n\n\t{0x21, 0x51},\n\t{0x22, 0x1d},\n\t{0x23, 0x5f},\n\t{0x20, 0x4f},\n\t{0x34, 0x00},\n\t{0x24, 0x51},\n\t{0x25, 0x00},\n\t{0x27, 0x0b},\n\t{0x26, 0x00},\n\t{0x37, 0x80},\n\t{0x33, 0x0b},\n\t{0x35, 0x11},\n\t{0x36, 0x02},\n\t{0x31, 0xea},\n\t{0x32, 0x0c},\n\t{0x30, 0xdf},\n\t{0x10, 0x0c},\n\t{0x11, 0xe0},\n\t{0x12, 0x50},\n\t{0x13, 0x00},\n\t{0x16, 0x03},\n\t{0x17, 0xbd},\n\t{0x1a, 0x00},\n};\n\n\nstatic struct chips_init_reg chips_init_xr[] =\n{\n\t{0xce, 0x00},\t\t \n\t{0xcc, 200 },\t         \n\t{0xcd, 18  },\t         \n\t{0xce, 0x90},\t\t \n\n\t{0xc4, 209 },\n\t{0xc5, 118 },\n\t{0xc7, 32  },\n\t{0xcf, 0x06},\n\t{0x09, 0x01},\t\t \n\t{0x0a, 0x02},\t\t \n\t{0x0b, 0x01},\t\t \n\t{0x40, 0x03},\t\t \n\t{0x80, 0x82},\t\t \n\t{0x81, 0x12},\t\t \n\t{0x82, 0x08},\t\t \n\n\t{0xd0, 0x0f},\n\t{0xd1, 0x01},\n};\n\nstatic void chips_hw_init(struct fb_info *p)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(chips_init_xr); ++i)\n\t\twrite_xr(chips_init_xr[i].addr, chips_init_xr[i].data);\n\twrite_xr(0x81, 0x12);\n\twrite_xr(0x82, 0x08);\n\twrite_xr(0x20, 0x00);\n\tfor (i = 0; i < ARRAY_SIZE(chips_init_sr); ++i)\n\t\twrite_sr(chips_init_sr[i].addr, chips_init_sr[i].data);\n\tfor (i = 0; i < ARRAY_SIZE(chips_init_gr); ++i)\n\t\twrite_gr(chips_init_gr[i].addr, chips_init_gr[i].data);\n\tfor (i = 0; i < ARRAY_SIZE(chips_init_ar); ++i)\n\t\twrite_ar(chips_init_ar[i].addr, chips_init_ar[i].data);\n\t \n\twriteb(0x20, mmio_base + 0x780);\n\tfor (i = 0; i < ARRAY_SIZE(chips_init_cr); ++i)\n\t\twrite_cr(chips_init_cr[i].addr, chips_init_cr[i].data);\n\tfor (i = 0; i < ARRAY_SIZE(chips_init_fr); ++i)\n\t\twrite_fr(chips_init_fr[i].addr, chips_init_fr[i].data);\n}\n\nstatic const struct fb_fix_screeninfo asiliantfb_fix = {\n\t.id =\t\t\"Asiliant 69000\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_PSEUDOCOLOR,\n\t.accel =\tFB_ACCEL_NONE,\n\t.line_length =\t640,\n\t.smem_len =\t0x200000,\t \n};\n\nstatic const struct fb_var_screeninfo asiliantfb_var = {\n\t.xres \t\t= 640,\n\t.yres \t\t= 480,\n\t.xres_virtual \t= 640,\n\t.yres_virtual \t= 480,\n\t.bits_per_pixel = 8,\n\t.red \t\t= { .length = 8 },\n\t.green \t\t= { .length = 8 },\n\t.blue \t\t= { .length = 8 },\n\t.height \t= -1,\n\t.width \t\t= -1,\n\t.vmode \t\t= FB_VMODE_NONINTERLACED,\n\t.pixclock \t= 39722,\n\t.left_margin \t= 48,\n\t.right_margin \t= 16,\n\t.upper_margin \t= 33,\n\t.lower_margin \t= 10,\n\t.hsync_len \t= 96,\n\t.vsync_len \t= 2,\n};\n\nstatic int init_asiliant(struct fb_info *p, unsigned long addr)\n{\n\tint err;\n\n\tp->fix\t\t\t= asiliantfb_fix;\n\tp->fix.smem_start\t= addr;\n\tp->var\t\t\t= asiliantfb_var;\n\tp->fbops\t\t= &asiliantfb_ops;\n\n\terr = fb_alloc_cmap(&p->cmap, 256, 0);\n\tif (err) {\n\t\tprintk(KERN_ERR \"C&T 69000 fb failed to alloc cmap memory\\n\");\n\t\treturn err;\n\t}\n\n\terr = register_framebuffer(p);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"C&T 69000 framebuffer failed to register\\n\");\n\t\tfb_dealloc_cmap(&p->cmap);\n\t\treturn err;\n\t}\n\n\tfb_info(p, \"Asiliant 69000 frame buffer (%dK RAM detected)\\n\",\n\t\tp->fix.smem_len / 1024);\n\n\twriteb(0xff, mmio_base + 0x78c);\n\tchips_hw_init(p);\n\treturn 0;\n}\n\nstatic int asiliantfb_pci_init(struct pci_dev *dp,\n\t\t\t       const struct pci_device_id *ent)\n{\n\tunsigned long addr, size;\n\tstruct fb_info *p;\n\tint err;\n\n\terr = aperture_remove_conflicting_pci_devices(dp, \"asiliantfb\");\n\tif (err)\n\t\treturn err;\n\n\tif ((dp->resource[0].flags & IORESOURCE_MEM) == 0)\n\t\treturn -ENODEV;\n\taddr = pci_resource_start(dp, 0);\n\tsize = pci_resource_len(dp, 0);\n\tif (addr == 0)\n\t\treturn -ENODEV;\n\tif (!request_mem_region(addr, size, \"asiliantfb\"))\n\t\treturn -EBUSY;\n\n\tp = framebuffer_alloc(sizeof(u32) * 16, &dp->dev);\n\tif (!p)\t{\n\t\trelease_mem_region(addr, size);\n\t\treturn -ENOMEM;\n\t}\n\tp->pseudo_palette = p->par;\n\tp->par = NULL;\n\n\tp->screen_base = ioremap(addr, 0x800000);\n\tif (p->screen_base == NULL) {\n\t\trelease_mem_region(addr, size);\n\t\tframebuffer_release(p);\n\t\treturn -ENOMEM;\n\t}\n\n\tpci_write_config_dword(dp, 4, 0x02800083);\n\twriteb(3, p->screen_base + 0x400784);\n\n\terr = init_asiliant(p, addr);\n\tif (err) {\n\t\tiounmap(p->screen_base);\n\t\trelease_mem_region(addr, size);\n\t\tframebuffer_release(p);\n\t\treturn err;\n\t}\n\n\tpci_set_drvdata(dp, p);\n\treturn 0;\n}\n\nstatic void asiliantfb_remove(struct pci_dev *dp)\n{\n\tstruct fb_info *p = pci_get_drvdata(dp);\n\n\tunregister_framebuffer(p);\n\tfb_dealloc_cmap(&p->cmap);\n\tiounmap(p->screen_base);\n\trelease_mem_region(pci_resource_start(dp, 0), pci_resource_len(dp, 0));\n\tframebuffer_release(p);\n}\n\nstatic const struct pci_device_id asiliantfb_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_CT, PCI_DEVICE_ID_CT_69000, PCI_ANY_ID, PCI_ANY_ID },\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, asiliantfb_pci_tbl);\n\nstatic struct pci_driver asiliantfb_driver = {\n\t.name =\t\t\"asiliantfb\",\n\t.id_table =\tasiliantfb_pci_tbl,\n\t.probe =\tasiliantfb_pci_init,\n\t.remove =\tasiliantfb_remove,\n};\n\nstatic int __init asiliantfb_init(void)\n{\n\tif (fb_modesetting_disabled(\"asiliantfb\"))\n\t\treturn -ENODEV;\n\n\tif (fb_get_options(\"asiliantfb\", NULL))\n\t\treturn -ENODEV;\n\n\treturn pci_register_driver(&asiliantfb_driver);\n}\n\nmodule_init(asiliantfb_init);\n\nstatic void __exit asiliantfb_exit(void)\n{\n\tpci_unregister_driver(&asiliantfb_driver);\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}