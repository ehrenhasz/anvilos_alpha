{
  "module_name": "pm2fb.c",
  "hash_id": "0c7ec5ce43105eae800adf6e849fcaa810a20d7abf07e1eab2a03dd4198cb8ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/pm2fb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <video/permedia2.h>\n#include <video/cvisionppc.h>\n\n#if !defined(__LITTLE_ENDIAN) && !defined(__BIG_ENDIAN)\n#error\t\"The endianness of the target host has not been defined.\"\n#endif\n\n#if !defined(CONFIG_PCI)\n#error \"Only generic PCI cards supported.\"\n#endif\n\n#undef PM2FB_MASTER_DEBUG\n#ifdef PM2FB_MASTER_DEBUG\n#define DPRINTK(a, b...)\t\\\n\tprintk(KERN_DEBUG \"pm2fb: %s: \" a, __func__ , ## b)\n#else\n#define DPRINTK(a, b...)\tno_printk(a, ##b)\n#endif\n\n#define PM2_PIXMAP_SIZE\t(1600 * 4)\n\n \nstatic int hwcursor = 1;\nstatic char *mode_option;\n\n \nstatic bool lowhsync;\nstatic bool lowvsync;\nstatic bool noaccel;\nstatic bool nomtrr;\n\n \nstruct pm2fb_par\n{\n\tpm2type_t\ttype;\t\t \n\tunsigned char\t__iomem *v_regs; \n\tu32\t\tmemclock;\t \n\tu32\t\tvideo;\t\t \n\tu32\t\tmem_config;\t \n\tu32\t\tmem_control;\t \n\tu32\t\tboot_address;\t \n\tu32\t\tpalette[16];\n\tint\t\twc_cookie;\n};\n\n \nstatic struct fb_fix_screeninfo pm2fb_fix = {\n\t.id =\t\t\"\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_PSEUDOCOLOR,\n\t.xpanstep =\t1,\n\t.ypanstep =\t1,\n\t.ywrapstep =\t0,\n\t.accel =\tFB_ACCEL_3DLABS_PERMEDIA2,\n};\n\n \nstatic const struct fb_var_screeninfo pm2fb_var = {\n\t \n\t.xres =\t\t\t640,\n\t.yres =\t\t\t480,\n\t.xres_virtual =\t\t640,\n\t.yres_virtual =\t\t480,\n\t.bits_per_pixel =\t8,\n\t.red =\t\t\t{0, 8, 0},\n\t.blue =\t\t\t{0, 8, 0},\n\t.green =\t\t{0, 8, 0},\n\t.activate =\t\tFB_ACTIVATE_NOW,\n\t.height =\t\t-1,\n\t.width =\t\t-1,\n\t.accel_flags =\t\t0,\n\t.pixclock =\t\t39721,\n\t.left_margin =\t\t40,\n\t.right_margin =\t\t24,\n\t.upper_margin =\t\t32,\n\t.lower_margin =\t\t11,\n\t.hsync_len =\t\t96,\n\t.vsync_len =\t\t2,\n\t.vmode =\t\tFB_VMODE_NONINTERLACED\n};\n\n \n\nstatic inline u32 pm2_RD(struct pm2fb_par *p, s32 off)\n{\n\treturn fb_readl(p->v_regs + off);\n}\n\nstatic inline void pm2_WR(struct pm2fb_par *p, s32 off, u32 v)\n{\n\tfb_writel(v, p->v_regs + off);\n}\n\nstatic inline u32 pm2_RDAC_RD(struct pm2fb_par *p, s32 idx)\n{\n\tpm2_WR(p, PM2R_RD_PALETTE_WRITE_ADDRESS, idx);\n\tmb();\n\treturn pm2_RD(p, PM2R_RD_INDEXED_DATA);\n}\n\nstatic inline u32 pm2v_RDAC_RD(struct pm2fb_par *p, s32 idx)\n{\n\tpm2_WR(p, PM2VR_RD_INDEX_LOW, idx & 0xff);\n\tmb();\n\treturn pm2_RD(p,  PM2VR_RD_INDEXED_DATA);\n}\n\nstatic inline void pm2_RDAC_WR(struct pm2fb_par *p, s32 idx, u32 v)\n{\n\tpm2_WR(p, PM2R_RD_PALETTE_WRITE_ADDRESS, idx);\n\twmb();\n\tpm2_WR(p, PM2R_RD_INDEXED_DATA, v);\n\twmb();\n}\n\nstatic inline void pm2v_RDAC_WR(struct pm2fb_par *p, s32 idx, u32 v)\n{\n\tpm2_WR(p, PM2VR_RD_INDEX_LOW, idx & 0xff);\n\twmb();\n\tpm2_WR(p, PM2VR_RD_INDEXED_DATA, v);\n\twmb();\n}\n\n#ifdef CONFIG_FB_PM2_FIFO_DISCONNECT\n#define WAIT_FIFO(p, a)\n#else\nstatic inline void WAIT_FIFO(struct pm2fb_par *p, u32 a)\n{\n\twhile (pm2_RD(p, PM2R_IN_FIFO_SPACE) < a)\n\t\tcpu_relax();\n}\n#endif\n\n \n#define PACKPP(p0, p1, p2)\t(((p2) << 6) | ((p1) << 3) | (p0))\nstatic const struct {\n\tu16 width;\n\tu16 pp;\n} pp_table[] = {\n\t{ 32,\tPACKPP(1, 0, 0) }, { 64,\tPACKPP(1, 1, 0) },\n\t{ 96,\tPACKPP(1, 1, 1) }, { 128,\tPACKPP(2, 1, 1) },\n\t{ 160,\tPACKPP(2, 2, 1) }, { 192,\tPACKPP(2, 2, 2) },\n\t{ 224,\tPACKPP(3, 2, 1) }, { 256,\tPACKPP(3, 2, 2) },\n\t{ 288,\tPACKPP(3, 3, 1) }, { 320,\tPACKPP(3, 3, 2) },\n\t{ 384,\tPACKPP(3, 3, 3) }, { 416,\tPACKPP(4, 3, 1) },\n\t{ 448,\tPACKPP(4, 3, 2) }, { 512,\tPACKPP(4, 3, 3) },\n\t{ 544,\tPACKPP(4, 4, 1) }, { 576,\tPACKPP(4, 4, 2) },\n\t{ 640,\tPACKPP(4, 4, 3) }, { 768,\tPACKPP(4, 4, 4) },\n\t{ 800,\tPACKPP(5, 4, 1) }, { 832,\tPACKPP(5, 4, 2) },\n\t{ 896,\tPACKPP(5, 4, 3) }, { 1024,\tPACKPP(5, 4, 4) },\n\t{ 1056,\tPACKPP(5, 5, 1) }, { 1088,\tPACKPP(5, 5, 2) },\n\t{ 1152,\tPACKPP(5, 5, 3) }, { 1280,\tPACKPP(5, 5, 4) },\n\t{ 1536,\tPACKPP(5, 5, 5) }, { 1568,\tPACKPP(6, 5, 1) },\n\t{ 1600,\tPACKPP(6, 5, 2) }, { 1664,\tPACKPP(6, 5, 3) },\n\t{ 1792,\tPACKPP(6, 5, 4) }, { 2048,\tPACKPP(6, 5, 5) },\n\t{ 0,\t0 } };\n\nstatic u32 partprod(u32 xres)\n{\n\tint i;\n\n\tfor (i = 0; pp_table[i].width && pp_table[i].width != xres; i++)\n\t\t;\n\tif (pp_table[i].width == 0)\n\t\tDPRINTK(\"invalid width %u\\n\", xres);\n\treturn pp_table[i].pp;\n}\n\nstatic u32 to3264(u32 timing, int bpp, int is64)\n{\n\tswitch (bpp) {\n\tcase 24:\n\t\ttiming *= 3;\n\t\tfallthrough;\n\tcase 8:\n\t\ttiming >>= 1;\n\t\tfallthrough;\n\tcase 16:\n\t\ttiming >>= 1;\n\t\tfallthrough;\n\tcase 32:\n\t\tbreak;\n\t}\n\tif (is64)\n\t\ttiming >>= 1;\n\treturn timing;\n}\n\nstatic void pm2_mnp(u32 clk, unsigned char *mm, unsigned char *nn,\n\t\t    unsigned char *pp)\n{\n\tunsigned char m;\n\tunsigned char n;\n\tunsigned char p;\n\tu32 f;\n\ts32 curr;\n\ts32 delta = 100000;\n\n\t*mm = *nn = *pp = 0;\n\tfor (n = 2; n < 15; n++) {\n\t\tfor (m = 2; m; m++) {\n\t\t\tf = PM2_REFERENCE_CLOCK * m / n;\n\t\t\tif (f >= 150000 && f <= 300000) {\n\t\t\t\tfor (p = 0; p < 5; p++, f >>= 1) {\n\t\t\t\t\tcurr = (clk > f) ? clk - f : f - clk;\n\t\t\t\t\tif (curr < delta) {\n\t\t\t\t\t\tdelta = curr;\n\t\t\t\t\t\t*mm = m;\n\t\t\t\t\t\t*nn = n;\n\t\t\t\t\t\t*pp = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void pm2v_mnp(u32 clk, unsigned char *mm, unsigned char *nn,\n\t\t     unsigned char *pp)\n{\n\tunsigned char m;\n\tunsigned char n;\n\tunsigned char p;\n\tu32 f;\n\ts32 delta = 1000;\n\n\t*mm = *nn = *pp = 0;\n\tfor (m = 1; m < 128; m++) {\n\t\tfor (n = 2 * m + 1; n; n++) {\n\t\t\tfor (p = 0; p < 2; p++) {\n\t\t\t\tf = (PM2_REFERENCE_CLOCK >> (p + 1)) * n / m;\n\t\t\t\tif (clk > f - delta && clk < f + delta) {\n\t\t\t\t\tdelta = (clk > f) ? clk - f : f - clk;\n\t\t\t\t\t*mm = m;\n\t\t\t\t\t*nn = n;\n\t\t\t\t\t*pp = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void clear_palette(struct pm2fb_par *p)\n{\n\tint i = 256;\n\n\tWAIT_FIFO(p, 1);\n\tpm2_WR(p, PM2R_RD_PALETTE_WRITE_ADDRESS, 0);\n\twmb();\n\twhile (i--) {\n\t\tWAIT_FIFO(p, 3);\n\t\tpm2_WR(p, PM2R_RD_PALETTE_DATA, 0);\n\t\tpm2_WR(p, PM2R_RD_PALETTE_DATA, 0);\n\t\tpm2_WR(p, PM2R_RD_PALETTE_DATA, 0);\n\t}\n}\n\nstatic void reset_card(struct pm2fb_par *p)\n{\n\tif (p->type == PM2_TYPE_PERMEDIA2V)\n\t\tpm2_WR(p, PM2VR_RD_INDEX_HIGH, 0);\n\tpm2_WR(p, PM2R_RESET_STATUS, 0);\n\tmb();\n\twhile (pm2_RD(p, PM2R_RESET_STATUS) & PM2F_BEING_RESET)\n\t\tcpu_relax();\n\tmb();\n#ifdef CONFIG_FB_PM2_FIFO_DISCONNECT\n\tDPRINTK(\"FIFO disconnect enabled\\n\");\n\tpm2_WR(p, PM2R_FIFO_DISCON, 1);\n\tmb();\n#endif\n\n\t \n\tWAIT_FIFO(p, 3);\n\tpm2_WR(p, PM2R_MEM_CONTROL, p->mem_control);\n\tpm2_WR(p, PM2R_BOOT_ADDRESS, p->boot_address);\n\twmb();\n\tpm2_WR(p, PM2R_MEM_CONFIG, p->mem_config);\n}\n\nstatic void reset_config(struct pm2fb_par *p)\n{\n\tWAIT_FIFO(p, 53);\n\tpm2_WR(p, PM2R_CHIP_CONFIG, pm2_RD(p, PM2R_CHIP_CONFIG) &\n\t\t\t~(PM2F_VGA_ENABLE | PM2F_VGA_FIXED));\n\tpm2_WR(p, PM2R_BYPASS_WRITE_MASK, ~(0L));\n\tpm2_WR(p, PM2R_FRAMEBUFFER_WRITE_MASK, ~(0L));\n\tpm2_WR(p, PM2R_FIFO_CONTROL, 0);\n\tpm2_WR(p, PM2R_APERTURE_ONE, 0);\n\tpm2_WR(p, PM2R_APERTURE_TWO, 0);\n\tpm2_WR(p, PM2R_RASTERIZER_MODE, 0);\n\tpm2_WR(p, PM2R_DELTA_MODE, PM2F_DELTA_ORDER_RGB);\n\tpm2_WR(p, PM2R_LB_READ_FORMAT, 0);\n\tpm2_WR(p, PM2R_LB_WRITE_FORMAT, 0);\n\tpm2_WR(p, PM2R_LB_READ_MODE, 0);\n\tpm2_WR(p, PM2R_LB_SOURCE_OFFSET, 0);\n\tpm2_WR(p, PM2R_FB_SOURCE_OFFSET, 0);\n\tpm2_WR(p, PM2R_FB_PIXEL_OFFSET, 0);\n\tpm2_WR(p, PM2R_FB_WINDOW_BASE, 0);\n\tpm2_WR(p, PM2R_LB_WINDOW_BASE, 0);\n\tpm2_WR(p, PM2R_FB_SOFT_WRITE_MASK, ~(0L));\n\tpm2_WR(p, PM2R_FB_HARD_WRITE_MASK, ~(0L));\n\tpm2_WR(p, PM2R_FB_READ_PIXEL, 0);\n\tpm2_WR(p, PM2R_DITHER_MODE, 0);\n\tpm2_WR(p, PM2R_AREA_STIPPLE_MODE, 0);\n\tpm2_WR(p, PM2R_DEPTH_MODE, 0);\n\tpm2_WR(p, PM2R_STENCIL_MODE, 0);\n\tpm2_WR(p, PM2R_TEXTURE_ADDRESS_MODE, 0);\n\tpm2_WR(p, PM2R_TEXTURE_READ_MODE, 0);\n\tpm2_WR(p, PM2R_TEXEL_LUT_MODE, 0);\n\tpm2_WR(p, PM2R_YUV_MODE, 0);\n\tpm2_WR(p, PM2R_COLOR_DDA_MODE, 0);\n\tpm2_WR(p, PM2R_TEXTURE_COLOR_MODE, 0);\n\tpm2_WR(p, PM2R_FOG_MODE, 0);\n\tpm2_WR(p, PM2R_ALPHA_BLEND_MODE, 0);\n\tpm2_WR(p, PM2R_LOGICAL_OP_MODE, 0);\n\tpm2_WR(p, PM2R_STATISTICS_MODE, 0);\n\tpm2_WR(p, PM2R_SCISSOR_MODE, 0);\n\tpm2_WR(p, PM2R_FILTER_MODE, PM2F_SYNCHRONIZATION);\n\tpm2_WR(p, PM2R_RD_PIXEL_MASK, 0xff);\n\tswitch (p->type) {\n\tcase PM2_TYPE_PERMEDIA2:\n\t\tpm2_RDAC_WR(p, PM2I_RD_MODE_CONTROL, 0);  \n\t\tpm2_RDAC_WR(p, PM2I_RD_CURSOR_CONTROL, 0);\n\t\tpm2_RDAC_WR(p, PM2I_RD_MISC_CONTROL, PM2F_RD_PALETTE_WIDTH_8);\n\t\tpm2_RDAC_WR(p, PM2I_RD_COLOR_KEY_CONTROL, 0);\n\t\tpm2_RDAC_WR(p, PM2I_RD_OVERLAY_KEY, 0);\n\t\tpm2_RDAC_WR(p, PM2I_RD_RED_KEY, 0);\n\t\tpm2_RDAC_WR(p, PM2I_RD_GREEN_KEY, 0);\n\t\tpm2_RDAC_WR(p, PM2I_RD_BLUE_KEY, 0);\n\t\tbreak;\n\tcase PM2_TYPE_PERMEDIA2V:\n\t\tpm2v_RDAC_WR(p, PM2VI_RD_MISC_CONTROL, 1);  \n\t\tbreak;\n\t}\n}\n\nstatic void set_aperture(struct pm2fb_par *p, u32 depth)\n{\n\t \n\tWAIT_FIFO(p, 2);\n#ifdef __LITTLE_ENDIAN\n\tpm2_WR(p, PM2R_APERTURE_ONE, PM2F_APERTURE_STANDARD);\n#else\n\tswitch (depth) {\n\tcase 24:\t \n\t\t \n\tcase 8:\t\t \n\t\tpm2_WR(p, PM2R_APERTURE_ONE, PM2F_APERTURE_STANDARD);\n\t\tbreak;\n\tcase 16:\t \n\t\tpm2_WR(p, PM2R_APERTURE_ONE, PM2F_APERTURE_HALFWORDSWAP);\n\t\tbreak;\n\tcase 32:\t \n\t\tpm2_WR(p, PM2R_APERTURE_ONE, PM2F_APERTURE_BYTESWAP);\n\t\tbreak;\n\t}\n#endif\n\n\t \n\tpm2_WR(p, PM2R_APERTURE_TWO, PM2F_APERTURE_STANDARD);\n}\n\nstatic void set_color(struct pm2fb_par *p, unsigned char regno,\n\t\t      unsigned char r, unsigned char g, unsigned char b)\n{\n\tWAIT_FIFO(p, 4);\n\tpm2_WR(p, PM2R_RD_PALETTE_WRITE_ADDRESS, regno);\n\twmb();\n\tpm2_WR(p, PM2R_RD_PALETTE_DATA, r);\n\twmb();\n\tpm2_WR(p, PM2R_RD_PALETTE_DATA, g);\n\twmb();\n\tpm2_WR(p, PM2R_RD_PALETTE_DATA, b);\n}\n\nstatic void set_memclock(struct pm2fb_par *par, u32 clk)\n{\n\tint i;\n\tunsigned char m, n, p;\n\n\tswitch (par->type) {\n\tcase PM2_TYPE_PERMEDIA2V:\n\t\tpm2v_mnp(clk/2, &m, &n, &p);\n\t\tWAIT_FIFO(par, 12);\n\t\tpm2_WR(par, PM2VR_RD_INDEX_HIGH, PM2VI_RD_MCLK_CONTROL >> 8);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_MCLK_CONTROL, 0);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_MCLK_PRESCALE, m);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_MCLK_FEEDBACK, n);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_MCLK_POSTSCALE, p);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_MCLK_CONTROL, 1);\n\t\trmb();\n\t\tfor (i = 256; i; i--)\n\t\t\tif (pm2v_RDAC_RD(par, PM2VI_RD_MCLK_CONTROL) & 2)\n\t\t\t\tbreak;\n\t\tpm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);\n\t\tbreak;\n\tcase PM2_TYPE_PERMEDIA2:\n\t\tpm2_mnp(clk, &m, &n, &p);\n\t\tWAIT_FIFO(par, 10);\n\t\tpm2_RDAC_WR(par, PM2I_RD_MEMORY_CLOCK_3, 6);\n\t\tpm2_RDAC_WR(par, PM2I_RD_MEMORY_CLOCK_1, m);\n\t\tpm2_RDAC_WR(par, PM2I_RD_MEMORY_CLOCK_2, n);\n\t\tpm2_RDAC_WR(par, PM2I_RD_MEMORY_CLOCK_3, 8|p);\n\t\tpm2_RDAC_RD(par, PM2I_RD_MEMORY_CLOCK_STATUS);\n\t\trmb();\n\t\tfor (i = 256; i; i--)\n\t\t\tif (pm2_RD(par, PM2R_RD_INDEXED_DATA) & PM2F_PLL_LOCKED)\n\t\t\t\tbreak;\n\t\tbreak;\n\t}\n}\n\nstatic void set_pixclock(struct pm2fb_par *par, u32 clk)\n{\n\tint i;\n\tunsigned char m, n, p;\n\n\tswitch (par->type) {\n\tcase PM2_TYPE_PERMEDIA2:\n\t\tpm2_mnp(clk, &m, &n, &p);\n\t\tWAIT_FIFO(par, 10);\n\t\tpm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A3, 0);\n\t\tpm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A1, m);\n\t\tpm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A2, n);\n\t\tpm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A3, 8|p);\n\t\tpm2_RDAC_RD(par, PM2I_RD_PIXEL_CLOCK_STATUS);\n\t\trmb();\n\t\tfor (i = 256; i; i--)\n\t\t\tif (pm2_RD(par, PM2R_RD_INDEXED_DATA) & PM2F_PLL_LOCKED)\n\t\t\t\tbreak;\n\t\tbreak;\n\tcase PM2_TYPE_PERMEDIA2V:\n\t\tpm2v_mnp(clk/2, &m, &n, &p);\n\t\tWAIT_FIFO(par, 8);\n\t\tpm2_WR(par, PM2VR_RD_INDEX_HIGH, PM2VI_RD_CLK0_PRESCALE >> 8);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_CLK0_PRESCALE, m);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_CLK0_FEEDBACK, n);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_CLK0_POSTSCALE, p);\n\t\tpm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void set_video(struct pm2fb_par *p, u32 video)\n{\n\tu32 tmp;\n\tu32 vsync = video;\n\n\tDPRINTK(\"video = 0x%x\\n\", video);\n\n\t \n\tvsync &= ~(PM2F_HSYNC_MASK | PM2F_VSYNC_MASK);\n\tvsync |= PM2F_HSYNC_ACT_HIGH | PM2F_VSYNC_ACT_HIGH;\n\n\tWAIT_FIFO(p, 3);\n\tpm2_WR(p, PM2R_VIDEO_CONTROL, vsync);\n\n\tswitch (p->type) {\n\tcase PM2_TYPE_PERMEDIA2:\n\t\ttmp = PM2F_RD_PALETTE_WIDTH_8;\n\t\tif ((video & PM2F_HSYNC_MASK) == PM2F_HSYNC_ACT_LOW)\n\t\t\ttmp |= 4;  \n\t\tif ((video & PM2F_VSYNC_MASK) == PM2F_VSYNC_ACT_LOW)\n\t\t\ttmp |= 8;  \n\t\tpm2_RDAC_WR(p, PM2I_RD_MISC_CONTROL, tmp);\n\t\tbreak;\n\tcase PM2_TYPE_PERMEDIA2V:\n\t\ttmp = 0;\n\t\tif ((video & PM2F_HSYNC_MASK) == PM2F_HSYNC_ACT_LOW)\n\t\t\ttmp |= 1;  \n\t\tif ((video & PM2F_VSYNC_MASK) == PM2F_VSYNC_ACT_LOW)\n\t\t\ttmp |= 4;  \n\t\tpm2v_RDAC_WR(p, PM2VI_RD_SYNC_CONTROL, tmp);\n\t\tbreak;\n\t}\n}\n\n \nstatic int pm2fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tu32 lpitch;\n\n\tif (var->bits_per_pixel != 8  && var->bits_per_pixel != 16 &&\n\t    var->bits_per_pixel != 24 && var->bits_per_pixel != 32) {\n\t\tDPRINTK(\"depth not supported: %u\\n\", var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->xres != var->xres_virtual) {\n\t\tDPRINTK(\"virtual x resolution != \"\n\t\t\t\"physical x resolution not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->yres > var->yres_virtual) {\n\t\tDPRINTK(\"virtual y resolution < \"\n\t\t\t\"physical y resolution not possible\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (var->yres_virtual > 2047) {\n\t\tvar->yres_virtual = 2047;\n\t}\n\n\tif (var->xoffset) {\n\t\tDPRINTK(\"xoffset not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\n\t\tDPRINTK(\"interlace not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvar->xres = (var->xres + 15) & ~15;  \n\tlpitch = var->xres * ((var->bits_per_pixel + 7) >> 3);\n\n\tif (var->xres < 320 || var->xres > 1600) {\n\t\tDPRINTK(\"width not supported: %u\\n\", var->xres);\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->yres < 200 || var->yres > 1200) {\n\t\tDPRINTK(\"height not supported: %u\\n\", var->yres);\n\t\treturn -EINVAL;\n\t}\n\n\tif (lpitch * var->yres_virtual > info->fix.smem_len) {\n\t\tDPRINTK(\"no memory for screen (%ux%ux%u)\\n\",\n\t\t\tvar->xres, var->yres_virtual, var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!var->pixclock) {\n\t\tDPRINTK(\"pixclock is zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (PICOS2KHZ(var->pixclock) > PM2_MAX_PIXCLOCK) {\n\t\tDPRINTK(\"pixclock too high (%ldKHz)\\n\",\n\t\t\tPICOS2KHZ(var->pixclock));\n\t\treturn -EINVAL;\n\t}\n\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\tcase 16:\n\t\tvar->red.offset   = 11;\n\t\tvar->red.length   = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.offset  = 0;\n\t\tvar->blue.length  = 5;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tvar->red.offset\t  = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset  = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\tcase 24:\n#ifdef __BIG_ENDIAN\n\t\tvar->red.offset   = 0;\n\t\tvar->blue.offset  = 16;\n#else\n\t\tvar->red.offset   = 16;\n\t\tvar->blue.offset  = 0;\n#endif\n\t\tvar->green.offset = 8;\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\t}\n\tvar->height = -1;\n\tvar->width = -1;\n\n\tvar->accel_flags = 0;\t \n\n\tDPRINTK(\"Checking graphics mode at %dx%d depth %d\\n\",\n\t\tvar->xres, var->yres, var->bits_per_pixel);\n\treturn 0;\n}\n\n \nstatic int pm2fb_set_par(struct fb_info *info)\n{\n\tstruct pm2fb_par *par = info->par;\n\tu32 pixclock;\n\tu32 width = (info->var.xres_virtual + 7) & ~7;\n\tu32 height = info->var.yres_virtual;\n\tu32 depth = (info->var.bits_per_pixel + 7) & ~7;\n\tu32 hsstart, hsend, hbend, htotal;\n\tu32 vsstart, vsend, vbend, vtotal;\n\tu32 stride;\n\tu32 base;\n\tu32 video = 0;\n\tu32 clrmode = PM2F_RD_COLOR_MODE_RGB | PM2F_RD_GUI_ACTIVE;\n\tu32 txtmap = 0;\n\tu32 pixsize = 0;\n\tu32 clrformat = 0;\n\tu32 misc = 1;  \n\tu32 xres = (info->var.xres + 31) & ~31;\n\tint data64;\n\n\treset_card(par);\n\treset_config(par);\n\tclear_palette(par);\n\tif (par->memclock)\n\t\tset_memclock(par, par->memclock);\n\n\tdepth = (depth > 32) ? 32 : depth;\n\tdata64 = depth > 8 || par->type == PM2_TYPE_PERMEDIA2V;\n\n\tpixclock = PICOS2KHZ(info->var.pixclock);\n\tif (pixclock > PM2_MAX_PIXCLOCK) {\n\t\tDPRINTK(\"pixclock too high (%uKHz)\\n\", pixclock);\n\t\treturn -EINVAL;\n\t}\n\n\thsstart = to3264(info->var.right_margin, depth, data64);\n\thsend = hsstart + to3264(info->var.hsync_len, depth, data64);\n\thbend = hsend + to3264(info->var.left_margin, depth, data64);\n\thtotal = to3264(xres, depth, data64) + hbend - 1;\n\tvsstart = (info->var.lower_margin)\n\t\t? info->var.lower_margin - 1\n\t\t: 0;\t \n\tvsend = info->var.lower_margin + info->var.vsync_len - 1;\n\tvbend = info->var.lower_margin + info->var.vsync_len +\n\t\tinfo->var.upper_margin;\n\tvtotal = info->var.yres + vbend - 1;\n\tstride = to3264(width, depth, 1);\n\tbase = to3264(info->var.yoffset * xres + info->var.xoffset, depth, 1);\n\tif (data64)\n\t\tvideo |= PM2F_DATA_64_ENABLE;\n\n\tif (info->var.sync & FB_SYNC_HOR_HIGH_ACT) {\n\t\tif (lowhsync) {\n\t\t\tDPRINTK(\"ignoring +hsync, using -hsync.\\n\");\n\t\t\tvideo |= PM2F_HSYNC_ACT_LOW;\n\t\t} else\n\t\t\tvideo |= PM2F_HSYNC_ACT_HIGH;\n\t} else\n\t\tvideo |= PM2F_HSYNC_ACT_LOW;\n\n\tif (info->var.sync & FB_SYNC_VERT_HIGH_ACT) {\n\t\tif (lowvsync) {\n\t\t\tDPRINTK(\"ignoring +vsync, using -vsync.\\n\");\n\t\t\tvideo |= PM2F_VSYNC_ACT_LOW;\n\t\t} else\n\t\t\tvideo |= PM2F_VSYNC_ACT_HIGH;\n\t} else\n\t\tvideo |= PM2F_VSYNC_ACT_LOW;\n\n\tif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\n\t\tDPRINTK(\"interlaced not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE)\n\t\tvideo |= PM2F_LINE_DOUBLE;\n\tif ((info->var.activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW)\n\t\tvideo |= PM2F_VIDEO_ENABLE;\n\tpar->video = video;\n\n\tinfo->fix.visual =\n\t\t(depth == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\tinfo->fix.line_length = info->var.xres * depth / 8;\n\tinfo->cmap.len = 256;\n\n\t \n\tif (par->type == PM2_TYPE_PERMEDIA2V) {\n\t\tWAIT_FIFO(par, 1);\n\t\tpm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);\n\t}\n\n\tset_aperture(par, depth);\n\n\tmb();\n\tWAIT_FIFO(par, 19);\n\tswitch (depth) {\n\tcase 8:\n\t\tpm2_WR(par, PM2R_FB_READ_PIXEL, 0);\n\t\tclrformat = 0x2e;\n\t\tbreak;\n\tcase 16:\n\t\tpm2_WR(par, PM2R_FB_READ_PIXEL, 1);\n\t\tclrmode |= PM2F_RD_TRUECOLOR | PM2F_RD_PIXELFORMAT_RGB565;\n\t\ttxtmap = PM2F_TEXTEL_SIZE_16;\n\t\tpixsize = 1;\n\t\tclrformat = 0x70;\n\t\tmisc |= 8;\n\t\tbreak;\n\tcase 32:\n\t\tpm2_WR(par, PM2R_FB_READ_PIXEL, 2);\n\t\tclrmode |= PM2F_RD_TRUECOLOR | PM2F_RD_PIXELFORMAT_RGBA8888;\n\t\ttxtmap = PM2F_TEXTEL_SIZE_32;\n\t\tpixsize = 2;\n\t\tclrformat = 0x20;\n\t\tmisc |= 8;\n\t\tbreak;\n\tcase 24:\n\t\tpm2_WR(par, PM2R_FB_READ_PIXEL, 4);\n\t\tclrmode |= PM2F_RD_TRUECOLOR | PM2F_RD_PIXELFORMAT_RGB888;\n\t\ttxtmap = PM2F_TEXTEL_SIZE_24;\n\t\tpixsize = 4;\n\t\tclrformat = 0x20;\n\t\tmisc |= 8;\n\t\tbreak;\n\t}\n\tpm2_WR(par, PM2R_FB_WRITE_MODE, PM2F_FB_WRITE_ENABLE);\n\tpm2_WR(par, PM2R_FB_READ_MODE, partprod(xres));\n\tpm2_WR(par, PM2R_LB_READ_MODE, partprod(xres));\n\tpm2_WR(par, PM2R_TEXTURE_MAP_FORMAT, txtmap | partprod(xres));\n\tpm2_WR(par, PM2R_H_TOTAL, htotal);\n\tpm2_WR(par, PM2R_HS_START, hsstart);\n\tpm2_WR(par, PM2R_HS_END, hsend);\n\tpm2_WR(par, PM2R_HG_END, hbend);\n\tpm2_WR(par, PM2R_HB_END, hbend);\n\tpm2_WR(par, PM2R_V_TOTAL, vtotal);\n\tpm2_WR(par, PM2R_VS_START, vsstart);\n\tpm2_WR(par, PM2R_VS_END, vsend);\n\tpm2_WR(par, PM2R_VB_END, vbend);\n\tpm2_WR(par, PM2R_SCREEN_STRIDE, stride);\n\twmb();\n\tpm2_WR(par, PM2R_WINDOW_ORIGIN, 0);\n\tpm2_WR(par, PM2R_SCREEN_SIZE, (height << 16) | width);\n\tpm2_WR(par, PM2R_SCISSOR_MODE, PM2F_SCREEN_SCISSOR_ENABLE);\n\twmb();\n\tpm2_WR(par, PM2R_SCREEN_BASE, base);\n\twmb();\n\tset_video(par, video);\n\tWAIT_FIFO(par, 10);\n\tswitch (par->type) {\n\tcase PM2_TYPE_PERMEDIA2:\n\t\tpm2_RDAC_WR(par, PM2I_RD_COLOR_MODE, clrmode);\n\t\tpm2_RDAC_WR(par, PM2I_RD_COLOR_KEY_CONTROL,\n\t\t\t\t(depth == 8) ? 0 : PM2F_COLOR_KEY_TEST_OFF);\n\t\tbreak;\n\tcase PM2_TYPE_PERMEDIA2V:\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_DAC_CONTROL, 0);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_PIXEL_SIZE, pixsize);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_COLOR_FORMAT, clrformat);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_MISC_CONTROL, misc);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_OVERLAY_KEY, 0);\n\t\tbreak;\n\t}\n\tset_pixclock(par, pixclock);\n\tDPRINTK(\"Setting graphics mode at %dx%d depth %d\\n\",\n\t\tinfo->var.xres, info->var.yres, info->var.bits_per_pixel);\n\treturn 0;\n}\n\n \nstatic int pm2fb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t   unsigned blue, unsigned transp,\n\t\t\t   struct fb_info *info)\n{\n\tstruct pm2fb_par *par = info->par;\n\n\tif (regno >= info->cmap.len)   \n\t\treturn -EINVAL;\n\t \n\n\t \n\t \n\tif (info->var.grayscale)\n\t\tred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n\n\t \n#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF -(val)) >> 16)\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tred = CNVT_TOHW(red, info->var.red.length);\n\t\tgreen = CNVT_TOHW(green, info->var.green.length);\n\t\tblue = CNVT_TOHW(blue, info->var.blue.length);\n\t\ttransp = CNVT_TOHW(transp, info->var.transp.length);\n\t\tbreak;\n\tcase FB_VISUAL_DIRECTCOLOR:\n\t\t \n\t\tred = CNVT_TOHW(red, 8);\n\t\tgreen = CNVT_TOHW(green, 8);\n\t\tblue = CNVT_TOHW(blue, 8);\n\t\t \n\t\ttransp = CNVT_TOHW(transp, 8);\n\t\tbreak;\n\t}\n#undef CNVT_TOHW\n\t \n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\tu32 v;\n\n\t\tif (regno >= 16)\n\t\t\treturn -EINVAL;\n\n\t\tv = (red << info->var.red.offset) |\n\t\t\t(green << info->var.green.offset) |\n\t\t\t(blue << info->var.blue.offset) |\n\t\t\t(transp << info->var.transp.offset);\n\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 8:\n\t\t\tbreak;\n\t\tcase 16:\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tpar->palette[regno] = v;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t} else if (info->fix.visual == FB_VISUAL_PSEUDOCOLOR)\n\t\tset_color(par, regno, red, green, blue);\n\n\treturn 0;\n}\n\n \nstatic int pm2fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tstruct pm2fb_par *p = info->par;\n\tu32 base;\n\tu32 depth = (info->var.bits_per_pixel + 7) & ~7;\n\tu32 xres = (info->var.xres + 31) & ~31;\n\n\tdepth = (depth > 32) ? 32 : depth;\n\tbase = to3264(var->yoffset * xres + var->xoffset, depth, 1);\n\tWAIT_FIFO(p, 1);\n\tpm2_WR(p, PM2R_SCREEN_BASE, base);\n\treturn 0;\n}\n\n \nstatic int pm2fb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct pm2fb_par *par = info->par;\n\tu32 video = par->video;\n\n\tDPRINTK(\"blank_mode %d\\n\", blank_mode);\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\t \n\t\tvideo |= PM2F_VIDEO_ENABLE;\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\t \n\t\tvideo &= ~PM2F_VIDEO_ENABLE;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\t \n\t\tvideo &= ~(PM2F_VSYNC_MASK | PM2F_BLANK_LOW);\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\t \n\t\tvideo &= ~(PM2F_HSYNC_MASK | PM2F_BLANK_LOW);\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\t \n\t\tvideo &= ~(PM2F_VSYNC_MASK | PM2F_HSYNC_MASK | PM2F_BLANK_LOW);\n\t\tbreak;\n\t}\n\tset_video(par, video);\n\treturn 0;\n}\n\nstatic int pm2fb_sync(struct fb_info *info)\n{\n\tstruct pm2fb_par *par = info->par;\n\n\tWAIT_FIFO(par, 1);\n\tpm2_WR(par, PM2R_SYNC, 0);\n\tmb();\n\tdo {\n\t\twhile (pm2_RD(par, PM2R_OUT_FIFO_WORDS) == 0)\n\t\t\tcpu_relax();\n\t} while (pm2_RD(par, PM2R_OUT_FIFO) != PM2TAG(PM2R_SYNC));\n\n\treturn 0;\n}\n\nstatic void pm2fb_fillrect(struct fb_info *info,\n\t\t\t\tconst struct fb_fillrect *region)\n{\n\tstruct pm2fb_par *par = info->par;\n\tstruct fb_fillrect modded;\n\tint vxres, vyres;\n\tu32 color = (info->fix.visual == FB_VISUAL_TRUECOLOR) ?\n\t\t((u32 *)info->pseudo_palette)[region->color] : region->color;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\tif ((info->flags & FBINFO_HWACCEL_DISABLED) ||\n\t\tregion->rop != ROP_COPY ) {\n\t\tcfb_fillrect(info, region);\n\t\treturn;\n\t}\n\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\n\tmemcpy(&modded, region, sizeof(struct fb_fillrect));\n\n\tif (!modded.width || !modded.height ||\n\t    modded.dx >= vxres || modded.dy >= vyres)\n\t\treturn;\n\n\tif (modded.dx + modded.width  > vxres)\n\t\tmodded.width  = vxres - modded.dx;\n\tif (modded.dy + modded.height > vyres)\n\t\tmodded.height = vyres - modded.dy;\n\n\tif (info->var.bits_per_pixel == 8)\n\t\tcolor |= color << 8;\n\tif (info->var.bits_per_pixel <= 16)\n\t\tcolor |= color << 16;\n\n\tWAIT_FIFO(par, 3);\n\tpm2_WR(par, PM2R_CONFIG, PM2F_CONFIG_FB_WRITE_ENABLE);\n\tpm2_WR(par, PM2R_RECTANGLE_ORIGIN, (modded.dy << 16) | modded.dx);\n\tpm2_WR(par, PM2R_RECTANGLE_SIZE, (modded.height << 16) | modded.width);\n\tif (info->var.bits_per_pixel != 24) {\n\t\tWAIT_FIFO(par, 2);\n\t\tpm2_WR(par, PM2R_FB_BLOCK_COLOR, color);\n\t\twmb();\n\t\tpm2_WR(par, PM2R_RENDER,\n\t\t\t\tPM2F_RENDER_RECTANGLE | PM2F_RENDER_FASTFILL);\n\t} else {\n\t\tWAIT_FIFO(par, 4);\n\t\tpm2_WR(par, PM2R_COLOR_DDA_MODE, 1);\n\t\tpm2_WR(par, PM2R_CONSTANT_COLOR, color);\n\t\twmb();\n\t\tpm2_WR(par, PM2R_RENDER,\n\t\t\t\tPM2F_RENDER_RECTANGLE |\n\t\t\t\tPM2F_INCREASE_X | PM2F_INCREASE_Y );\n\t\tpm2_WR(par, PM2R_COLOR_DDA_MODE, 0);\n\t}\n}\n\nstatic void pm2fb_copyarea(struct fb_info *info,\n\t\t\t\tconst struct fb_copyarea *area)\n{\n\tstruct pm2fb_par *par = info->par;\n\tstruct fb_copyarea modded;\n\tu32 vxres, vyres;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\tif (info->flags & FBINFO_HWACCEL_DISABLED) {\n\t\tcfb_copyarea(info, area);\n\t\treturn;\n\t}\n\n\tmemcpy(&modded, area, sizeof(struct fb_copyarea));\n\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\n\tif (!modded.width || !modded.height ||\n\t    modded.sx >= vxres || modded.sy >= vyres ||\n\t    modded.dx >= vxres || modded.dy >= vyres)\n\t\treturn;\n\n\tif (modded.sx + modded.width > vxres)\n\t\tmodded.width = vxres - modded.sx;\n\tif (modded.dx + modded.width > vxres)\n\t\tmodded.width = vxres - modded.dx;\n\tif (modded.sy + modded.height > vyres)\n\t\tmodded.height = vyres - modded.sy;\n\tif (modded.dy + modded.height > vyres)\n\t\tmodded.height = vyres - modded.dy;\n\n\tWAIT_FIFO(par, 5);\n\tpm2_WR(par, PM2R_CONFIG, PM2F_CONFIG_FB_WRITE_ENABLE |\n\t\tPM2F_CONFIG_FB_READ_SOURCE_ENABLE);\n\tpm2_WR(par, PM2R_FB_SOURCE_DELTA,\n\t\t\t((modded.sy - modded.dy) & 0xfff) << 16 |\n\t\t\t((modded.sx - modded.dx) & 0xfff));\n\tpm2_WR(par, PM2R_RECTANGLE_ORIGIN, (modded.dy << 16) | modded.dx);\n\tpm2_WR(par, PM2R_RECTANGLE_SIZE, (modded.height << 16) | modded.width);\n\twmb();\n\tpm2_WR(par, PM2R_RENDER, PM2F_RENDER_RECTANGLE |\n\t\t\t\t(modded.dx < modded.sx ? PM2F_INCREASE_X : 0) |\n\t\t\t\t(modded.dy < modded.sy ? PM2F_INCREASE_Y : 0));\n}\n\nstatic void pm2fb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct pm2fb_par *par = info->par;\n\tu32 height = image->height;\n\tu32 fgx, bgx;\n\tconst u32 *src = (const u32 *)image->data;\n\tu32 xres = (info->var.xres + 31) & ~31;\n\tint raster_mode = 1;  \n\n#ifdef __LITTLE_ENDIAN\n\traster_mode |= 3 << 7;  \n#endif\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\tif (info->flags & FBINFO_HWACCEL_DISABLED || image->depth != 1) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tfgx = image->fg_color;\n\t\tbgx = image->bg_color;\n\t\tbreak;\n\tcase FB_VISUAL_TRUECOLOR:\n\tdefault:\n\t\tfgx = par->palette[image->fg_color];\n\t\tbgx = par->palette[image->bg_color];\n\t\tbreak;\n\t}\n\tif (info->var.bits_per_pixel == 8) {\n\t\tfgx |= fgx << 8;\n\t\tbgx |= bgx << 8;\n\t}\n\tif (info->var.bits_per_pixel <= 16) {\n\t\tfgx |= fgx << 16;\n\t\tbgx |= bgx << 16;\n\t}\n\n\tWAIT_FIFO(par, 13);\n\tpm2_WR(par, PM2R_FB_READ_MODE, partprod(xres));\n\tpm2_WR(par, PM2R_SCISSOR_MIN_XY,\n\t\t\t((image->dy & 0xfff) << 16) | (image->dx & 0x0fff));\n\tpm2_WR(par, PM2R_SCISSOR_MAX_XY,\n\t\t\t(((image->dy + image->height) & 0x0fff) << 16) |\n\t\t\t((image->dx + image->width) & 0x0fff));\n\tpm2_WR(par, PM2R_SCISSOR_MODE, 1);\n\t \n\tpm2_WR(par, PM2R_LOGICAL_OP_MODE, (0x3 << 1) | 1);\n\tpm2_WR(par, PM2R_RECTANGLE_ORIGIN,\n\t\t\t((image->dy & 0xfff) << 16) | (image->dx & 0x0fff));\n\tpm2_WR(par, PM2R_RECTANGLE_SIZE,\n\t\t\t((image->height & 0x0fff) << 16) |\n\t\t\t((image->width) & 0x0fff));\n\tif (info->var.bits_per_pixel == 24) {\n\t\tpm2_WR(par, PM2R_COLOR_DDA_MODE, 1);\n\t\t \n\t\tpm2_WR(par, PM2R_CONSTANT_COLOR, bgx);\n\t\tpm2_WR(par, PM2R_RENDER,\n\t\t\tPM2F_RENDER_RECTANGLE |\n\t\t\tPM2F_INCREASE_X | PM2F_INCREASE_Y);\n\t\t \n\t\tpm2_WR(par, PM2R_RASTERIZER_MODE, raster_mode | (1 << 9));\n\t\tpm2_WR(par, PM2R_CONSTANT_COLOR, fgx);\n\t\tpm2_WR(par, PM2R_RENDER,\n\t\t\tPM2F_RENDER_RECTANGLE |\n\t\t\tPM2F_INCREASE_X | PM2F_INCREASE_Y |\n\t\t\tPM2F_RENDER_SYNC_ON_BIT_MASK);\n\t} else {\n\t\tpm2_WR(par, PM2R_COLOR_DDA_MODE, 0);\n\t\t \n\t\tpm2_WR(par, PM2R_FB_BLOCK_COLOR, bgx);\n\t\tpm2_WR(par, PM2R_RENDER,\n\t\t\tPM2F_RENDER_RECTANGLE |\n\t\t\tPM2F_RENDER_FASTFILL |\n\t\t\tPM2F_INCREASE_X | PM2F_INCREASE_Y);\n\t\tpm2_WR(par, PM2R_RASTERIZER_MODE, raster_mode);\n\t\tpm2_WR(par, PM2R_FB_BLOCK_COLOR, fgx);\n\t\tpm2_WR(par, PM2R_RENDER,\n\t\t\tPM2F_RENDER_RECTANGLE |\n\t\t\tPM2F_INCREASE_X | PM2F_INCREASE_Y |\n\t\t\tPM2F_RENDER_FASTFILL |\n\t\t\tPM2F_RENDER_SYNC_ON_BIT_MASK);\n\t}\n\n\twhile (height--) {\n\t\tint width = ((image->width + 7) >> 3)\n\t\t\t\t+ info->pixmap.scan_align - 1;\n\t\twidth >>= 2;\n\t\tWAIT_FIFO(par, width);\n\t\twhile (width--) {\n\t\t\tpm2_WR(par, PM2R_BIT_MASK_PATTERN, *src);\n\t\t\tsrc++;\n\t\t}\n\t}\n\tWAIT_FIFO(par, 3);\n\tpm2_WR(par, PM2R_RASTERIZER_MODE, 0);\n\tpm2_WR(par, PM2R_COLOR_DDA_MODE, 0);\n\tpm2_WR(par, PM2R_SCISSOR_MODE, 0);\n}\n\n \nstatic const u8 cursor_bits_lookup[16] = {\n\t0x00, 0x40, 0x10, 0x50, 0x04, 0x44, 0x14, 0x54,\n\t0x01, 0x41, 0x11, 0x51, 0x05, 0x45, 0x15, 0x55\n};\n\nstatic int pm2vfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\tstruct pm2fb_par *par = info->par;\n\tu8 mode = PM2F_CURSORMODE_TYPE_X;\n\tint x = cursor->image.dx - info->var.xoffset;\n\tint y = cursor->image.dy - info->var.yoffset;\n\n\tif (cursor->enable)\n\t\tmode |= PM2F_CURSORMODE_CURSOR_ENABLE;\n\n\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_MODE, mode);\n\n\tif (!cursor->enable)\n\t\tx = 2047;\t \n\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_X_LOW, x & 0xff);\n\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_X_HIGH, (x >> 8) & 0xf);\n\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_Y_LOW, y & 0xff);\n\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_Y_HIGH, (y >> 8) & 0xf);\n\n\t \n\tif (!cursor->set)\n\t\treturn 0;\n\n\tif (cursor->set & FB_CUR_SETHOT) {\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_X_HOT,\n\t\t\t     cursor->hot.x & 0x3f);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_Y_HOT,\n\t\t\t     cursor->hot.y & 0x3f);\n\t}\n\n\tif (cursor->set & FB_CUR_SETCMAP) {\n\t\tu32 fg_idx = cursor->image.fg_color;\n\t\tu32 bg_idx = cursor->image.bg_color;\n\t\tstruct fb_cmap cmap = info->cmap;\n\n\t\t \n\t\tpm2_WR(par, PM2VR_RD_INDEX_HIGH, PM2VI_RD_CURSOR_PALETTE >> 8);\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_PALETTE + 0,\n\t\t\t     cmap.red[bg_idx] >> 8 );\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_PALETTE + 1,\n\t\t\t     cmap.green[bg_idx] >> 8 );\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_PALETTE + 2,\n\t\t\t     cmap.blue[bg_idx] >> 8 );\n\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_PALETTE + 3,\n\t\t\t     cmap.red[fg_idx] >> 8 );\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_PALETTE + 4,\n\t\t\t     cmap.green[fg_idx] >> 8 );\n\t\tpm2v_RDAC_WR(par, PM2VI_RD_CURSOR_PALETTE + 5,\n\t\t\t     cmap.blue[fg_idx] >> 8 );\n\t\tpm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);\n\t}\n\n\tif (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\n\t\tu8 *bitmap = (u8 *)cursor->image.data;\n\t\tu8 *mask = (u8 *)cursor->mask;\n\t\tint i;\n\t\tint pos = PM2VI_RD_CURSOR_PATTERN;\n\n\t\tfor (i = 0; i < cursor->image.height; i++) {\n\t\t\tint j = (cursor->image.width + 7) >> 3;\n\t\t\tint k = 8 - j;\n\n\t\t\tpm2_WR(par, PM2VR_RD_INDEX_HIGH, pos >> 8);\n\n\t\t\tfor (; j > 0; j--) {\n\t\t\t\tu8 data = *bitmap ^ *mask;\n\n\t\t\t\tif (cursor->rop == ROP_COPY)\n\t\t\t\t\tdata = *mask & *bitmap;\n\t\t\t\t \n\t\t\t\tpm2v_RDAC_WR(par, pos++,\n\t\t\t\t\tcursor_bits_lookup[data >> 4] |\n\t\t\t\t\t(cursor_bits_lookup[*mask >> 4] << 1));\n\t\t\t\t \n\t\t\t\tpm2v_RDAC_WR(par, pos++,\n\t\t\t\t\tcursor_bits_lookup[data & 0xf] |\n\t\t\t\t\t(cursor_bits_lookup[*mask & 0xf] << 1));\n\t\t\t\tbitmap++;\n\t\t\t\tmask++;\n\t\t\t}\n\t\t\tfor (; k > 0; k--) {\n\t\t\t\tpm2v_RDAC_WR(par, pos++, 0);\n\t\t\t\tpm2v_RDAC_WR(par, pos++, 0);\n\t\t\t}\n\t\t}\n\n\t\twhile (pos < (1024 + PM2VI_RD_CURSOR_PATTERN)) {\n\t\t\tpm2_WR(par, PM2VR_RD_INDEX_HIGH, pos >> 8);\n\t\t\tpm2v_RDAC_WR(par, pos++, 0);\n\t\t}\n\n\t\tpm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);\n\t}\n\treturn 0;\n}\n\nstatic int pm2fb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\tstruct pm2fb_par *par = info->par;\n\tu8 mode;\n\n\tif (!hwcursor)\n\t\treturn -EINVAL;\t \n\n\t \n\tif (cursor->image.width > 64 ||\n\t    cursor->image.height > 64 ||\n\t    cursor->image.depth > 1)\n\t\treturn -EINVAL;\n\n\tif (par->type == PM2_TYPE_PERMEDIA2V)\n\t\treturn pm2vfb_cursor(info, cursor);\n\n\tmode = 0x40;\n\tif (cursor->enable)\n\t\t mode = 0x43;\n\n\tpm2_RDAC_WR(par, PM2I_RD_CURSOR_CONTROL, mode);\n\n\t \n\tif (!cursor->set)\n\t\treturn 0;\n\n\tif (cursor->set & FB_CUR_SETPOS) {\n\t\tint x = cursor->image.dx - info->var.xoffset + 63;\n\t\tint y = cursor->image.dy - info->var.yoffset + 63;\n\n\t\tWAIT_FIFO(par, 4);\n\t\tpm2_WR(par, PM2R_RD_CURSOR_X_LSB, x & 0xff);\n\t\tpm2_WR(par, PM2R_RD_CURSOR_X_MSB, (x >> 8) & 0x7);\n\t\tpm2_WR(par, PM2R_RD_CURSOR_Y_LSB, y & 0xff);\n\t\tpm2_WR(par, PM2R_RD_CURSOR_Y_MSB, (y >> 8) & 0x7);\n\t}\n\n\tif (cursor->set & FB_CUR_SETCMAP) {\n\t\tu32 fg_idx = cursor->image.fg_color;\n\t\tu32 bg_idx = cursor->image.bg_color;\n\n\t\tWAIT_FIFO(par, 7);\n\t\tpm2_WR(par, PM2R_RD_CURSOR_COLOR_ADDRESS, 1);\n\t\tpm2_WR(par, PM2R_RD_CURSOR_COLOR_DATA,\n\t\t\tinfo->cmap.red[bg_idx] >> 8);\n\t\tpm2_WR(par, PM2R_RD_CURSOR_COLOR_DATA,\n\t\t\tinfo->cmap.green[bg_idx] >> 8);\n\t\tpm2_WR(par, PM2R_RD_CURSOR_COLOR_DATA,\n\t\t\tinfo->cmap.blue[bg_idx] >> 8);\n\n\t\tpm2_WR(par, PM2R_RD_CURSOR_COLOR_DATA,\n\t\t\tinfo->cmap.red[fg_idx] >> 8);\n\t\tpm2_WR(par, PM2R_RD_CURSOR_COLOR_DATA,\n\t\t\tinfo->cmap.green[fg_idx] >> 8);\n\t\tpm2_WR(par, PM2R_RD_CURSOR_COLOR_DATA,\n\t\t\tinfo->cmap.blue[fg_idx] >> 8);\n\t}\n\n\tif (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\n\t\tu8 *bitmap = (u8 *)cursor->image.data;\n\t\tu8 *mask = (u8 *)cursor->mask;\n\t\tint i;\n\n\t\tWAIT_FIFO(par, 1);\n\t\tpm2_WR(par, PM2R_RD_PALETTE_WRITE_ADDRESS, 0);\n\n\t\tfor (i = 0; i < cursor->image.height; i++) {\n\t\t\tint j = (cursor->image.width + 7) >> 3;\n\t\t\tint k = 8 - j;\n\n\t\t\tWAIT_FIFO(par, 8);\n\t\t\tfor (; j > 0; j--) {\n\t\t\t\tu8 data = *bitmap ^ *mask;\n\n\t\t\t\tif (cursor->rop == ROP_COPY)\n\t\t\t\t\tdata = *mask & *bitmap;\n\t\t\t\t \n\t\t\t\tpm2_WR(par, PM2R_RD_CURSOR_DATA, data);\n\t\t\t\tbitmap++;\n\t\t\t\tmask++;\n\t\t\t}\n\t\t\tfor (; k > 0; k--)\n\t\t\t\tpm2_WR(par, PM2R_RD_CURSOR_DATA, 0);\n\t\t}\n\t\tfor (; i < 64; i++) {\n\t\t\tint j = 8;\n\t\t\tWAIT_FIFO(par, 8);\n\t\t\twhile (j-- > 0)\n\t\t\t\tpm2_WR(par, PM2R_RD_CURSOR_DATA, 0);\n\t\t}\n\n\t\tmask = (u8 *)cursor->mask;\n\t\tfor (i = 0; i < cursor->image.height; i++) {\n\t\t\tint j = (cursor->image.width + 7) >> 3;\n\t\t\tint k = 8 - j;\n\n\t\t\tWAIT_FIFO(par, 8);\n\t\t\tfor (; j > 0; j--) {\n\t\t\t\t \n\t\t\t\tpm2_WR(par, PM2R_RD_CURSOR_DATA, *mask);\n\t\t\t\tmask++;\n\t\t\t}\n\t\t\tfor (; k > 0; k--)\n\t\t\t\tpm2_WR(par, PM2R_RD_CURSOR_DATA, 0);\n\t\t}\n\t\tfor (; i < 64; i++) {\n\t\t\tint j = 8;\n\t\t\tWAIT_FIFO(par, 8);\n\t\t\twhile (j-- > 0)\n\t\t\t\tpm2_WR(par, PM2R_RD_CURSOR_DATA, 0);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\n \n\nstatic const struct fb_ops pm2fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= pm2fb_check_var,\n\t.fb_set_par\t= pm2fb_set_par,\n\t.fb_setcolreg\t= pm2fb_setcolreg,\n\t.fb_blank\t= pm2fb_blank,\n\t.fb_pan_display\t= pm2fb_pan_display,\n\t.fb_fillrect\t= pm2fb_fillrect,\n\t.fb_copyarea\t= pm2fb_copyarea,\n\t.fb_imageblit\t= pm2fb_imageblit,\n\t.fb_sync\t= pm2fb_sync,\n\t.fb_cursor\t= pm2fb_cursor,\n};\n\n \n\n\n \nstatic int pm2fb_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct pm2fb_par *default_par;\n\tstruct fb_info *info;\n\tint err;\n\tint retval = -ENXIO;\n\n\terr = aperture_remove_conflicting_pci_devices(pdev, \"pm2fb\");\n\tif (err)\n\t\treturn err;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"pm2fb: Can't enable pdev: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct pm2fb_par), &pdev->dev);\n\tif (!info) {\n\t\terr = -ENOMEM;\n\t\tgoto err_exit_disable;\n\t}\n\tdefault_par = info->par;\n\n\tswitch (pdev->device) {\n\tcase  PCI_DEVICE_ID_TI_TVP4020:\n\t\tstrcpy(pm2fb_fix.id, \"TVP4020\");\n\t\tdefault_par->type = PM2_TYPE_PERMEDIA2;\n\t\tbreak;\n\tcase  PCI_DEVICE_ID_3DLABS_PERMEDIA2:\n\t\tstrcpy(pm2fb_fix.id, \"Permedia2\");\n\t\tdefault_par->type = PM2_TYPE_PERMEDIA2;\n\t\tbreak;\n\tcase  PCI_DEVICE_ID_3DLABS_PERMEDIA2V:\n\t\tstrcpy(pm2fb_fix.id, \"Permedia2v\");\n\t\tdefault_par->type = PM2_TYPE_PERMEDIA2V;\n\t\tbreak;\n\t}\n\n\tpm2fb_fix.mmio_start = pci_resource_start(pdev, 0);\n\tpm2fb_fix.mmio_len = PM2_REGS_SIZE;\n\n#if defined(__BIG_ENDIAN)\n\t \n\tpm2fb_fix.mmio_start += PM2_REGS_SIZE;\n\tDPRINTK(\"Adjusting register base for big-endian.\\n\");\n#endif\n\tDPRINTK(\"Register base at 0x%lx\\n\", pm2fb_fix.mmio_start);\n\n\t \n\tif (!request_mem_region(pm2fb_fix.mmio_start, pm2fb_fix.mmio_len,\n\t\t\t\t\"pm2fb regbase\")) {\n\t\tprintk(KERN_WARNING \"pm2fb: Can't reserve regbase.\\n\");\n\t\tgoto err_exit_neither;\n\t}\n\tdefault_par->v_regs =\n\t\tioremap(pm2fb_fix.mmio_start, pm2fb_fix.mmio_len);\n\tif (!default_par->v_regs) {\n\t\tprintk(KERN_WARNING \"pm2fb: Can't remap %s register area.\\n\",\n\t\t       pm2fb_fix.id);\n\t\trelease_mem_region(pm2fb_fix.mmio_start, pm2fb_fix.mmio_len);\n\t\tgoto err_exit_neither;\n\t}\n\n\t \n\tdefault_par->mem_control = pm2_RD(default_par, PM2R_MEM_CONTROL);\n\tdefault_par->boot_address = pm2_RD(default_par, PM2R_BOOT_ADDRESS);\n\tdefault_par->mem_config = pm2_RD(default_par, PM2R_MEM_CONFIG);\n\tDPRINTK(\"MemControl 0x%x BootAddress 0x%x MemConfig 0x%x\\n\",\n\t\tdefault_par->mem_control, default_par->boot_address,\n\t\tdefault_par->mem_config);\n\n\tif (default_par->mem_control == 0 &&\n\t\tdefault_par->boot_address == 0x31 &&\n\t\tdefault_par->mem_config == 0x259fffff) {\n\t\tdefault_par->memclock = CVPPC_MEMCLOCK;\n\t\tdefault_par->mem_control = 0;\n\t\tdefault_par->boot_address = 0x20;\n\t\tdefault_par->mem_config = 0xe6002021;\n\t\tif (pdev->subsystem_vendor == 0x1048 &&\n\t\t\tpdev->subsystem_device == 0x0a31) {\n\t\t\tDPRINTK(\"subsystem_vendor: %04x, \"\n\t\t\t\t\"subsystem_device: %04x\\n\",\n\t\t\t\tpdev->subsystem_vendor, pdev->subsystem_device);\n\t\t\tDPRINTK(\"We have not been initialized by VGA BIOS and \"\n\t\t\t\t\"are running on an Elsa Winner 2000 Office\\n\");\n\t\t\tDPRINTK(\"Initializing card timings manually...\\n\");\n\t\t\tdefault_par->memclock = 100000;\n\t\t}\n\t\tif (pdev->subsystem_vendor == 0x3d3d &&\n\t\t\tpdev->subsystem_device == 0x0100) {\n\t\t\tDPRINTK(\"subsystem_vendor: %04x, \"\n\t\t\t\t\"subsystem_device: %04x\\n\",\n\t\t\t\tpdev->subsystem_vendor, pdev->subsystem_device);\n\t\t\tDPRINTK(\"We have not been initialized by VGA BIOS and \"\n\t\t\t\t\"are running on an 3dlabs reference board\\n\");\n\t\t\tDPRINTK(\"Initializing card timings manually...\\n\");\n\t\t\tdefault_par->memclock = 74894;\n\t\t}\n\t}\n\n\t \n\tswitch (default_par->mem_config & PM2F_MEM_CONFIG_RAM_MASK) {\n\tcase PM2F_MEM_BANKS_1:\n\t\tpm2fb_fix.smem_len = 0x200000;\n\t\tbreak;\n\tcase PM2F_MEM_BANKS_2:\n\t\tpm2fb_fix.smem_len = 0x400000;\n\t\tbreak;\n\tcase PM2F_MEM_BANKS_3:\n\t\tpm2fb_fix.smem_len = 0x600000;\n\t\tbreak;\n\tcase PM2F_MEM_BANKS_4:\n\t\tpm2fb_fix.smem_len = 0x800000;\n\t\tbreak;\n\t}\n\tpm2fb_fix.smem_start = pci_resource_start(pdev, 1);\n\n\t \n\tif (!request_mem_region(pm2fb_fix.smem_start, pm2fb_fix.smem_len,\n\t\t\t\t\"pm2fb smem\")) {\n\t\tprintk(KERN_WARNING \"pm2fb: Can't reserve smem.\\n\");\n\t\tgoto err_exit_mmio;\n\t}\n\tinfo->screen_base =\n\t\tioremap_wc(pm2fb_fix.smem_start, pm2fb_fix.smem_len);\n\tif (!info->screen_base) {\n\t\tprintk(KERN_WARNING \"pm2fb: Can't ioremap smem area.\\n\");\n\t\trelease_mem_region(pm2fb_fix.smem_start, pm2fb_fix.smem_len);\n\t\tgoto err_exit_mmio;\n\t}\n\n\tif (!nomtrr)\n\t\tdefault_par->wc_cookie = arch_phys_wc_add(pm2fb_fix.smem_start,\n\t\t\t\t\t\t\t  pm2fb_fix.smem_len);\n\n\tinfo->fbops\t\t= &pm2fb_ops;\n\tinfo->fix\t\t= pm2fb_fix;\n\tinfo->pseudo_palette\t= default_par->palette;\n\tinfo->flags\t\t= FBINFO_HWACCEL_YPAN |\n\t\t\t\t  FBINFO_HWACCEL_COPYAREA |\n\t\t\t\t  FBINFO_HWACCEL_IMAGEBLIT |\n\t\t\t\t  FBINFO_HWACCEL_FILLRECT;\n\n\tinfo->pixmap.addr = kmalloc(PM2_PIXMAP_SIZE, GFP_KERNEL);\n\tif (!info->pixmap.addr) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_exit_pixmap;\n\t}\n\tinfo->pixmap.size = PM2_PIXMAP_SIZE;\n\tinfo->pixmap.buf_align = 4;\n\tinfo->pixmap.scan_align = 4;\n\tinfo->pixmap.access_align = 32;\n\tinfo->pixmap.flags = FB_PIXMAP_SYSTEM;\n\n\tif (noaccel) {\n\t\tprintk(KERN_DEBUG \"disabling acceleration\\n\");\n\t\tinfo->flags |= FBINFO_HWACCEL_DISABLED;\n\t\tinfo->pixmap.scan_align = 1;\n\t}\n\n\tif (!mode_option)\n\t\tmode_option = \"640x480@60\";\n\n\terr = fb_find_mode(&info->var, info, mode_option, NULL, 0, NULL, 8);\n\tif (!err || err == 4)\n\t\tinfo->var = pm2fb_var;\n\n\tretval = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (retval < 0)\n\t\tgoto err_exit_both;\n\n\tretval = register_framebuffer(info);\n\tif (retval < 0)\n\t\tgoto err_exit_all;\n\n\tfb_info(info, \"%s frame buffer device, memory = %dK\\n\",\n\t\tinfo->fix.id, pm2fb_fix.smem_len / 1024);\n\n\t \n\tpci_set_drvdata(pdev, info);\n\n\treturn 0;\n\n err_exit_all:\n\tfb_dealloc_cmap(&info->cmap);\n err_exit_both:\n\tkfree(info->pixmap.addr);\n err_exit_pixmap:\n\tiounmap(info->screen_base);\n\trelease_mem_region(pm2fb_fix.smem_start, pm2fb_fix.smem_len);\n err_exit_mmio:\n\tiounmap(default_par->v_regs);\n\trelease_mem_region(pm2fb_fix.mmio_start, pm2fb_fix.mmio_len);\n err_exit_neither:\n\tframebuffer_release(info);\n err_exit_disable:\n\tpci_disable_device(pdev);\n\treturn retval;\n}\n\n \nstatic void pm2fb_remove(struct pci_dev *pdev)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct fb_fix_screeninfo *fix = &info->fix;\n\tstruct pm2fb_par *par = info->par;\n\n\tunregister_framebuffer(info);\n\tarch_phys_wc_del(par->wc_cookie);\n\tiounmap(info->screen_base);\n\trelease_mem_region(fix->smem_start, fix->smem_len);\n\tiounmap(par->v_regs);\n\trelease_mem_region(fix->mmio_start, fix->mmio_len);\n\n\tfb_dealloc_cmap(&info->cmap);\n\tkfree(info->pixmap.addr);\n\tframebuffer_release(info);\n\tpci_disable_device(pdev);\n}\n\nstatic const struct pci_device_id pm2fb_id_table[] = {\n\t{ PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_TVP4020,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_3DLABS, PCI_DEVICE_ID_3DLABS_PERMEDIA2,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_3DLABS, PCI_DEVICE_ID_3DLABS_PERMEDIA2V,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0, }\n};\n\nstatic struct pci_driver pm2fb_driver = {\n\t.name\t\t= \"pm2fb\",\n\t.id_table\t= pm2fb_id_table,\n\t.probe\t\t= pm2fb_probe,\n\t.remove\t\t= pm2fb_remove,\n};\n\nMODULE_DEVICE_TABLE(pci, pm2fb_id_table);\n\n\n#ifndef MODULE\n \nstatic int __init pm2fb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\t\tif (!strcmp(this_opt, \"lowhsync\"))\n\t\t\tlowhsync = 1;\n\t\telse if (!strcmp(this_opt, \"lowvsync\"))\n\t\t\tlowvsync = 1;\n\t\telse if (!strncmp(this_opt, \"hwcursor=\", 9))\n\t\t\thwcursor = simple_strtoul(this_opt + 9, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"nomtrr\", 6))\n\t\t\tnomtrr = 1;\n\t\telse if (!strncmp(this_opt, \"noaccel\", 7))\n\t\t\tnoaccel = 1;\n\t\telse\n\t\t\tmode_option = this_opt;\n\t}\n\treturn 0;\n}\n#endif\n\n\nstatic int __init pm2fb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"pm2fb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"pm2fb\", &option))\n\t\treturn -ENODEV;\n\tpm2fb_setup(option);\n#endif\n\n\treturn pci_register_driver(&pm2fb_driver);\n}\n\nmodule_init(pm2fb_init);\n\n#ifdef MODULE\n \n\nstatic void __exit pm2fb_exit(void)\n{\n\tpci_unregister_driver(&pm2fb_driver);\n}\n#endif\n\n#ifdef MODULE\nmodule_exit(pm2fb_exit);\n\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Initial video mode e.g. '648x480-8@60'\");\nmodule_param_named(mode, mode_option, charp, 0);\nMODULE_PARM_DESC(mode, \"Initial video mode e.g. '648x480-8@60' (deprecated)\");\nmodule_param(lowhsync, bool, 0);\nMODULE_PARM_DESC(lowhsync, \"Force horizontal sync low regardless of mode\");\nmodule_param(lowvsync, bool, 0);\nMODULE_PARM_DESC(lowvsync, \"Force vertical sync low regardless of mode\");\nmodule_param(noaccel, bool, 0);\nMODULE_PARM_DESC(noaccel, \"Disable acceleration\");\nmodule_param(hwcursor, int, 0644);\nMODULE_PARM_DESC(hwcursor, \"Enable hardware cursor \"\n\t\t\t\"(1=enable, 0=disable, default=1)\");\nmodule_param(nomtrr, bool, 0);\nMODULE_PARM_DESC(nomtrr, \"Disable MTRR support (0 or 1=disabled) (default=0)\");\n\nMODULE_AUTHOR(\"Jim Hague <jim.hague@acm.org>\");\nMODULE_DESCRIPTION(\"Permedia2 framebuffer device driver\");\nMODULE_LICENSE(\"GPL\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}