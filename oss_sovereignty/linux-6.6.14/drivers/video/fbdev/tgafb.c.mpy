{
  "module_name": "tgafb.c",
  "hash_id": "cc0d2c9db262a38b09cb1b927e938e0aaf017a4d04cc120116ffe69b2b7c4d91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/tgafb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/bitrev.h>\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/selection.h>\n#include <linux/string.h>\n#include <linux/tc.h>\n\n#include <asm/io.h>\n\n#include <video/tgafb.h>\n\n#ifdef CONFIG_TC\n#define TGA_BUS_TC(dev) (dev->bus == &tc_bus_type)\n#else\n#define TGA_BUS_TC(dev) 0\n#endif\n\n \n\nstatic int tgafb_check_var(struct fb_var_screeninfo *, struct fb_info *);\nstatic int tgafb_set_par(struct fb_info *);\nstatic void tgafb_set_pll(struct tga_par *, int);\nstatic int tgafb_setcolreg(unsigned, unsigned, unsigned, unsigned,\n\t\t\t   unsigned, struct fb_info *);\nstatic int tgafb_blank(int, struct fb_info *);\nstatic void tgafb_init_fix(struct fb_info *);\n\nstatic void tgafb_imageblit(struct fb_info *, const struct fb_image *);\nstatic void tgafb_fillrect(struct fb_info *, const struct fb_fillrect *);\nstatic void tgafb_copyarea(struct fb_info *, const struct fb_copyarea *);\nstatic int tgafb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info);\n\nstatic int tgafb_register(struct device *dev);\nstatic void tgafb_unregister(struct device *dev);\n\nstatic const char *mode_option;\nstatic const char *mode_option_pci = \"640x480@60\";\nstatic const char *mode_option_tc = \"1280x1024@72\";\n\n\nstatic struct pci_driver tgafb_pci_driver;\nstatic struct tc_driver tgafb_tc_driver;\n\n \n\nstatic const struct fb_ops tgafb_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_check_var\t\t= tgafb_check_var,\n\t.fb_set_par\t\t= tgafb_set_par,\n\t.fb_setcolreg\t\t= tgafb_setcolreg,\n\t.fb_blank\t\t= tgafb_blank,\n\t.fb_pan_display\t\t= tgafb_pan_display,\n\t.fb_fillrect\t\t= tgafb_fillrect,\n\t.fb_copyarea\t\t= tgafb_copyarea,\n\t.fb_imageblit\t\t= tgafb_imageblit,\n};\n\n\n#ifdef CONFIG_PCI\n \nstatic int tgafb_pci_register(struct pci_dev *, const struct pci_device_id *);\nstatic void tgafb_pci_unregister(struct pci_dev *);\n\nstatic struct pci_device_id const tgafb_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DEC, PCI_DEVICE_ID_DEC_TGA) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, tgafb_pci_table);\n\nstatic struct pci_driver tgafb_pci_driver = {\n\t.name\t\t\t= \"tgafb\",\n\t.id_table\t\t= tgafb_pci_table,\n\t.probe\t\t\t= tgafb_pci_register,\n\t.remove\t\t\t= tgafb_pci_unregister,\n};\n\nstatic int tgafb_pci_register(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tint ret;\n\n\tret = aperture_remove_conflicting_pci_devices(pdev, \"tgafb\");\n\tif (ret)\n\t\treturn ret;\n\n\treturn tgafb_register(&pdev->dev);\n}\n\nstatic void tgafb_pci_unregister(struct pci_dev *pdev)\n{\n\ttgafb_unregister(&pdev->dev);\n}\n#endif  \n\n#ifdef CONFIG_TC\n \nstatic int tgafb_tc_register(struct device *);\nstatic int tgafb_tc_unregister(struct device *);\n\nstatic struct tc_device_id const tgafb_tc_table[] = {\n\t{ \"DEC     \", \"PMAGD-AA\" },\n\t{ \"DEC     \", \"PMAGD   \" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(tc, tgafb_tc_table);\n\nstatic struct tc_driver tgafb_tc_driver = {\n\t.id_table\t\t= tgafb_tc_table,\n\t.driver\t\t\t= {\n\t\t.name\t\t= \"tgafb\",\n\t\t.bus\t\t= &tc_bus_type,\n\t\t.probe\t\t= tgafb_tc_register,\n\t\t.remove\t\t= tgafb_tc_unregister,\n\t},\n};\n\nstatic int tgafb_tc_register(struct device *dev)\n{\n\tint status = tgafb_register(dev);\n\tif (!status)\n\t\tget_device(dev);\n\treturn status;\n}\n\nstatic int tgafb_tc_unregister(struct device *dev)\n{\n\tput_device(dev);\n\ttgafb_unregister(dev);\n\treturn 0;\n}\n#endif  \n\n\n \nstatic int\ntgafb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct tga_par *par = (struct tga_par *)info->par;\n\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\tif (par->tga_type == TGA_TYPE_8PLANE) {\n\t\tif (var->bits_per_pixel != 8)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (var->bits_per_pixel != 32)\n\t\t\treturn -EINVAL;\n\t}\n\tvar->red.length = var->green.length = var->blue.length = 8;\n\tif (var->bits_per_pixel == 32) {\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t}\n\n\tif (var->xres_virtual != var->xres || var->yres_virtual != var->yres)\n\t\treturn -EINVAL;\n\tif (var->xres * var->yres * (var->bits_per_pixel >> 3) > info->fix.smem_len)\n\t\treturn -EINVAL;\n\tif (var->nonstd)\n\t\treturn -EINVAL;\n\tif (1000000000 / var->pixclock > TGA_PLL_MAX_FREQ)\n\t\treturn -EINVAL;\n\tif ((var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)\n\t\treturn -EINVAL;\n\n\t \n\tif (var->xres * (par->tga_type == TGA_TYPE_8PLANE ? 1 : 4) % 8)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int\ntgafb_set_par(struct fb_info *info)\n{\n\tstatic unsigned int const deep_presets[4] = {\n\t\t0x00004000,\n\t\t0x0000440d,\n\t\t0xffffffff,\n\t\t0x0000441d\n\t};\n\tstatic unsigned int const rasterop_presets[4] = {\n\t\t0x00000003,\n\t\t0x00000303,\n\t\t0xffffffff,\n\t\t0x00000303\n\t};\n\tstatic unsigned int const mode_presets[4] = {\n\t\t0x00000000,\n\t\t0x00000300,\n\t\t0xffffffff,\n\t\t0x00000300\n\t};\n\tstatic unsigned int const base_addr_presets[4] = {\n\t\t0x00000000,\n\t\t0x00000001,\n\t\t0xffffffff,\n\t\t0x00000001\n\t};\n\n\tstruct tga_par *par = (struct tga_par *) info->par;\n\tint tga_bus_pci = dev_is_pci(par->dev);\n\tint tga_bus_tc = TGA_BUS_TC(par->dev);\n\tu32 htimings, vtimings, pll_freq;\n\tu8 tga_type;\n\tint i;\n\n\t \n\thtimings = (((info->var.xres/4) & TGA_HORIZ_ACT_LSB)\n\t\t    | (((info->var.xres/4) & 0x600 << 19) & TGA_HORIZ_ACT_MSB));\n\tvtimings = (info->var.yres & TGA_VERT_ACTIVE);\n\thtimings |= ((info->var.right_margin/4) << 9) & TGA_HORIZ_FP;\n\tvtimings |= (info->var.lower_margin << 11) & TGA_VERT_FP;\n\thtimings |= ((info->var.hsync_len/4) << 14) & TGA_HORIZ_SYNC;\n\tvtimings |= (info->var.vsync_len << 16) & TGA_VERT_SYNC;\n\thtimings |= ((info->var.left_margin/4) << 21) & TGA_HORIZ_BP;\n\tvtimings |= (info->var.upper_margin << 22) & TGA_VERT_BP;\n\n\tif (info->var.sync & FB_SYNC_HOR_HIGH_ACT)\n\t\thtimings |= TGA_HORIZ_POLARITY;\n\tif (info->var.sync & FB_SYNC_VERT_HIGH_ACT)\n\t\tvtimings |= TGA_VERT_POLARITY;\n\n\tpar->htimings = htimings;\n\tpar->vtimings = vtimings;\n\n\tpar->sync_on_green = !!(info->var.sync & FB_SYNC_ON_GREEN);\n\n\t \n\tpar->xres = info->var.xres;\n\tpar->yres = info->var.yres;\n\tpar->pll_freq = pll_freq = 1000000000 / info->var.pixclock;\n\tpar->bits_per_pixel = info->var.bits_per_pixel;\n\tinfo->fix.line_length = par->xres * (par->bits_per_pixel >> 3);\n\n\ttga_type = par->tga_type;\n\n\t \n\tTGA_WRITE_REG(par, TGA_VALID_VIDEO | TGA_VALID_BLANK, TGA_VALID_REG);\n\n\t \n\twhile (TGA_READ_REG(par, TGA_CMD_STAT_REG) & 1)  \n\t\tcontinue;\n\tmb();\n\tTGA_WRITE_REG(par, deep_presets[tga_type] |\n\t\t\t   (par->sync_on_green ? 0x0 : 0x00010000),\n\t\t      TGA_DEEP_REG);\n\twhile (TGA_READ_REG(par, TGA_CMD_STAT_REG) & 1)  \n\t\tcontinue;\n\tmb();\n\n\t \n\tTGA_WRITE_REG(par, rasterop_presets[tga_type], TGA_RASTEROP_REG);\n\tTGA_WRITE_REG(par, mode_presets[tga_type], TGA_MODE_REG);\n\tTGA_WRITE_REG(par, base_addr_presets[tga_type], TGA_BASE_ADDR_REG);\n\n\t \n\ttgafb_set_pll(par, pll_freq);\n\n\t \n\tTGA_WRITE_REG(par, 0xffffffff, TGA_PLANEMASK_REG);\n\tTGA_WRITE_REG(par, 0xffffffff, TGA_PIXELMASK_REG);\n\n\t \n\tTGA_WRITE_REG(par, htimings, TGA_HORIZ_REG);\n\tTGA_WRITE_REG(par, vtimings, TGA_VERT_REG);\n\n\t \n\tif (tga_type == TGA_TYPE_8PLANE && tga_bus_pci) {\n\n\t\t \n\t\tBT485_WRITE(par, 0xa2 | (par->sync_on_green ? 0x8 : 0x0),\n\t\t\t    BT485_CMD_0);\n\t\tBT485_WRITE(par, 0x01, BT485_ADDR_PAL_WRITE);\n\t\tBT485_WRITE(par, 0x14, BT485_CMD_3);  \n\t\tBT485_WRITE(par, 0x40, BT485_CMD_1);\n\t\tBT485_WRITE(par, 0x20, BT485_CMD_2);  \n\t\tBT485_WRITE(par, 0xff, BT485_PIXEL_MASK);\n\n\t\t \n\t\tBT485_WRITE(par, 0x00, BT485_ADDR_PAL_WRITE);\n\t\tTGA_WRITE_REG(par, BT485_DATA_PAL, TGA_RAMDAC_SETUP_REG);\n\n\t\tfor (i = 0; i < 256 * 3; i += 4) {\n\t\t\tTGA_WRITE_REG(par, 0x55 | (BT485_DATA_PAL << 8),\n\t\t\t\t      TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, 0x00 | (BT485_DATA_PAL << 8),\n\t\t\t\t      TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, 0x00 | (BT485_DATA_PAL << 8),\n\t\t\t\t      TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, 0x00 | (BT485_DATA_PAL << 8),\n\t\t\t\t      TGA_RAMDAC_REG);\n\t\t}\n\n\t} else if (tga_type == TGA_TYPE_8PLANE && tga_bus_tc) {\n\n\t\t \n\t\tBT459_WRITE(par, BT459_REG_ACC, BT459_CMD_REG_0, 0x40);\n\t\tBT459_WRITE(par, BT459_REG_ACC, BT459_CMD_REG_1, 0x00);\n\t\tBT459_WRITE(par, BT459_REG_ACC, BT459_CMD_REG_2,\n\t\t\t    (par->sync_on_green ? 0xc0 : 0x40));\n\n\t\tBT459_WRITE(par, BT459_REG_ACC, BT459_CUR_CMD_REG, 0x00);\n\n\t\t \n\t\tBT459_LOAD_ADDR(par, 0x0000);\n\t\tTGA_WRITE_REG(par, BT459_PALETTE << 2, TGA_RAMDAC_SETUP_REG);\n\n\t\tfor (i = 0; i < 256 * 3; i += 4) {\n\t\t\tTGA_WRITE_REG(par, 0x55, TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, 0x00, TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, 0x00, TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, 0x00, TGA_RAMDAC_REG);\n\t\t}\n\n\t} else {  \n\n\t\t \n\t\tBT463_WRITE(par, BT463_REG_ACC, BT463_CMD_REG_0, 0x40);\n\t\tBT463_WRITE(par, BT463_REG_ACC, BT463_CMD_REG_1, 0x08);\n\t\tBT463_WRITE(par, BT463_REG_ACC, BT463_CMD_REG_2,\n\t\t\t    (par->sync_on_green ? 0xc0 : 0x40));\n\n\t\tBT463_WRITE(par, BT463_REG_ACC, BT463_READ_MASK_0, 0xff);\n\t\tBT463_WRITE(par, BT463_REG_ACC, BT463_READ_MASK_1, 0xff);\n\t\tBT463_WRITE(par, BT463_REG_ACC, BT463_READ_MASK_2, 0xff);\n\t\tBT463_WRITE(par, BT463_REG_ACC, BT463_READ_MASK_3, 0x0f);\n\n\t\tBT463_WRITE(par, BT463_REG_ACC, BT463_BLINK_MASK_0, 0x00);\n\t\tBT463_WRITE(par, BT463_REG_ACC, BT463_BLINK_MASK_1, 0x00);\n\t\tBT463_WRITE(par, BT463_REG_ACC, BT463_BLINK_MASK_2, 0x00);\n\t\tBT463_WRITE(par, BT463_REG_ACC, BT463_BLINK_MASK_3, 0x00);\n\n\t\t \n\t\tBT463_LOAD_ADDR(par, 0x0000);\n\t\tTGA_WRITE_REG(par, BT463_PALETTE << 2, TGA_RAMDAC_SETUP_REG);\n\n#ifdef CONFIG_HW_CONSOLE\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tint j = color_table[i];\n\n\t\t\tTGA_WRITE_REG(par, default_red[j], TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, default_grn[j], TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, default_blu[j], TGA_RAMDAC_REG);\n\t\t}\n\t\tfor (i = 0; i < 512 * 3; i += 4) {\n#else\n\t\tfor (i = 0; i < 528 * 3; i += 4) {\n#endif\n\t\t\tTGA_WRITE_REG(par, 0x55, TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, 0x00, TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, 0x00, TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, 0x00, TGA_RAMDAC_REG);\n\t\t}\n\n\t\t \n\t\twhile (!(TGA_READ_REG(par, TGA_INTR_STAT_REG) & 0x01))\n\t\t\tcontinue;\n\t\tTGA_WRITE_REG(par, 0x01, TGA_INTR_STAT_REG);\n\t\tmb();\n\t\twhile (!(TGA_READ_REG(par, TGA_INTR_STAT_REG) & 0x01))\n\t\t\tcontinue;\n\t\tTGA_WRITE_REG(par, 0x01, TGA_INTR_STAT_REG);\n\n\t\tBT463_LOAD_ADDR(par, BT463_WINDOW_TYPE_BASE);\n\t\tTGA_WRITE_REG(par, BT463_REG_ACC << 2, TGA_RAMDAC_SETUP_REG);\n\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tTGA_WRITE_REG(par, 0x00, TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, 0x01, TGA_RAMDAC_REG);\n\t\t\tTGA_WRITE_REG(par, 0x00, TGA_RAMDAC_REG);\n\t\t}\n\n\t}\n\n\t \n\tTGA_WRITE_REG(par, TGA_VALID_VIDEO, TGA_VALID_REG);\n\n\treturn 0;\n}\n\n#define DIFFCHECK(X)\t\t\t\t\t\t\t  \\\ndo {\t\t\t\t\t\t\t\t\t  \\\n\tif (m <= 0x3f) {\t\t\t\t\t\t  \\\n\t\tint delta = f - (TGA_PLL_BASE_FREQ * (X)) / (r << shift); \\\n\t\tif (delta < 0)\t\t\t\t\t\t  \\\n\t\t\tdelta = -delta;\t\t\t\t\t  \\\n\t\tif (delta < min_diff)\t\t\t\t\t  \\\n\t\t\tmin_diff = delta, vm = m, va = a, vr = r;\t  \\\n\t}\t\t\t\t\t\t\t\t  \\\n} while (0)\n\nstatic void\ntgafb_set_pll(struct tga_par *par, int f)\n{\n\tint n, shift, base, min_diff, target;\n\tint r,a,m,vm = 34, va = 1, vr = 30;\n\n\tfor (r = 0 ; r < 12 ; r++)\n\t\tTGA_WRITE_REG(par, !r, TGA_CLOCK_REG);\n\n\tif (f > TGA_PLL_MAX_FREQ)\n\t\tf = TGA_PLL_MAX_FREQ;\n\n\tif (f >= TGA_PLL_MAX_FREQ / 2)\n\t\tshift = 0;\n\telse if (f >= TGA_PLL_MAX_FREQ / 4)\n\t\tshift = 1;\n\telse\n\t\tshift = 2;\n\n\tTGA_WRITE_REG(par, shift & 1, TGA_CLOCK_REG);\n\tTGA_WRITE_REG(par, shift >> 1, TGA_CLOCK_REG);\n\n\tfor (r = 0 ; r < 10 ; r++)\n\t\tTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\n\n\tif (f <= 120000) {\n\t\tTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\n\t\tTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\n\t}\n\telse if (f <= 200000) {\n\t\tTGA_WRITE_REG(par, 1, TGA_CLOCK_REG);\n\t\tTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\n\t}\n\telse {\n\t\tTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\n\t\tTGA_WRITE_REG(par, 1, TGA_CLOCK_REG);\n\t}\n\n\tTGA_WRITE_REG(par, 1, TGA_CLOCK_REG);\n\tTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\n\tTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\n\tTGA_WRITE_REG(par, 1, TGA_CLOCK_REG);\n\tTGA_WRITE_REG(par, 0, TGA_CLOCK_REG);\n\tTGA_WRITE_REG(par, 1, TGA_CLOCK_REG);\n\n\ttarget = (f << shift) / TGA_PLL_BASE_FREQ;\n\tmin_diff = TGA_PLL_MAX_FREQ;\n\n\tr = 7 / target;\n\tif (!r) r = 1;\n\n\tbase = target * r;\n\twhile (base < 449) {\n\t\tfor (n = base < 7 ? 7 : base; n < base + target && n < 449; n++) {\n\t\t\tm = ((n + 3) / 7) - 1;\n\t\t\ta = 0;\n\t\t\tDIFFCHECK((m + 1) * 7);\n\t\t\tm++;\n\t\t\tDIFFCHECK((m + 1) * 7);\n\t\t\tm = (n / 6) - 1;\n\t\t\tif ((a = n % 6))\n\t\t\t\tDIFFCHECK(n);\n\t\t}\n\t\tr++;\n\t\tbase += target;\n\t}\n\n\tvr--;\n\n\tfor (r = 0; r < 8; r++)\n\t\tTGA_WRITE_REG(par, (vm >> r) & 1, TGA_CLOCK_REG);\n\tfor (r = 0; r < 8 ; r++)\n\t\tTGA_WRITE_REG(par, (va >> r) & 1, TGA_CLOCK_REG);\n\tfor (r = 0; r < 7 ; r++)\n\t\tTGA_WRITE_REG(par, (vr >> r) & 1, TGA_CLOCK_REG);\n\tTGA_WRITE_REG(par, ((vr >> 7) & 1)|2, TGA_CLOCK_REG);\n}\n\n\n \nstatic int\ntgafb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue,\n\t\tunsigned transp, struct fb_info *info)\n{\n\tstruct tga_par *par = (struct tga_par *) info->par;\n\tint tga_bus_pci = dev_is_pci(par->dev);\n\tint tga_bus_tc = TGA_BUS_TC(par->dev);\n\n\tif (regno > 255)\n\t\treturn 1;\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\tif (par->tga_type == TGA_TYPE_8PLANE && tga_bus_pci) {\n\t\tBT485_WRITE(par, regno, BT485_ADDR_PAL_WRITE);\n\t\tTGA_WRITE_REG(par, BT485_DATA_PAL, TGA_RAMDAC_SETUP_REG);\n\t\tTGA_WRITE_REG(par, red|(BT485_DATA_PAL<<8),TGA_RAMDAC_REG);\n\t\tTGA_WRITE_REG(par, green|(BT485_DATA_PAL<<8),TGA_RAMDAC_REG);\n\t\tTGA_WRITE_REG(par, blue|(BT485_DATA_PAL<<8),TGA_RAMDAC_REG);\n\t} else if (par->tga_type == TGA_TYPE_8PLANE && tga_bus_tc) {\n\t\tBT459_LOAD_ADDR(par, regno);\n\t\tTGA_WRITE_REG(par, BT459_PALETTE << 2, TGA_RAMDAC_SETUP_REG);\n\t\tTGA_WRITE_REG(par, red, TGA_RAMDAC_REG);\n\t\tTGA_WRITE_REG(par, green, TGA_RAMDAC_REG);\n\t\tTGA_WRITE_REG(par, blue, TGA_RAMDAC_REG);\n\t} else {\n\t\tif (regno < 16) {\n\t\t\tu32 value = (regno << 16) | (regno << 8) | regno;\n\t\t\t((u32 *)info->pseudo_palette)[regno] = value;\n\t\t}\n\t\tBT463_LOAD_ADDR(par, regno);\n\t\tTGA_WRITE_REG(par, BT463_PALETTE << 2, TGA_RAMDAC_SETUP_REG);\n\t\tTGA_WRITE_REG(par, red, TGA_RAMDAC_REG);\n\t\tTGA_WRITE_REG(par, green, TGA_RAMDAC_REG);\n\t\tTGA_WRITE_REG(par, blue, TGA_RAMDAC_REG);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int\ntgafb_blank(int blank, struct fb_info *info)\n{\n\tstruct tga_par *par = (struct tga_par *) info->par;\n\tu32 vhcr, vvcr, vvvr;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tvhcr = TGA_READ_REG(par, TGA_HORIZ_REG);\n\tvvcr = TGA_READ_REG(par, TGA_VERT_REG);\n\tvvvr = TGA_READ_REG(par, TGA_VALID_REG);\n\tvvvr &= ~(TGA_VALID_VIDEO | TGA_VALID_BLANK);\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:  \n\t\tif (par->vesa_blanked) {\n\t\t\tTGA_WRITE_REG(par, vhcr & 0xbfffffff, TGA_HORIZ_REG);\n\t\t\tTGA_WRITE_REG(par, vvcr & 0xbfffffff, TGA_VERT_REG);\n\t\t\tpar->vesa_blanked = 0;\n\t\t}\n\t\tTGA_WRITE_REG(par, vvvr | TGA_VALID_VIDEO, TGA_VALID_REG);\n\t\tbreak;\n\n\tcase FB_BLANK_NORMAL:  \n\t\tTGA_WRITE_REG(par, vvvr | TGA_VALID_VIDEO | TGA_VALID_BLANK,\n\t\t\t      TGA_VALID_REG);\n\t\tbreak;\n\n\tcase FB_BLANK_VSYNC_SUSPEND:  \n\t\tTGA_WRITE_REG(par, vvcr | 0x40000000, TGA_VERT_REG);\n\t\tTGA_WRITE_REG(par, vvvr | TGA_VALID_BLANK, TGA_VALID_REG);\n\t\tpar->vesa_blanked = 1;\n\t\tbreak;\n\n\tcase FB_BLANK_HSYNC_SUSPEND:  \n\t\tTGA_WRITE_REG(par, vhcr | 0x40000000, TGA_HORIZ_REG);\n\t\tTGA_WRITE_REG(par, vvvr | TGA_VALID_BLANK, TGA_VALID_REG);\n\t\tpar->vesa_blanked = 1;\n\t\tbreak;\n\n\tcase FB_BLANK_POWERDOWN:  \n\t\tTGA_WRITE_REG(par, vhcr | 0x40000000, TGA_HORIZ_REG);\n\t\tTGA_WRITE_REG(par, vvcr | 0x40000000, TGA_VERT_REG);\n\t\tTGA_WRITE_REG(par, vvvr | TGA_VALID_BLANK, TGA_VALID_REG);\n\t\tpar->vesa_blanked = 1;\n\t\tbreak;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn 0;\n}\n\n\n \n\nstatic void\ntgafb_mono_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct tga_par *par = (struct tga_par *) info->par;\n\tu32 fgcolor, bgcolor, dx, dy, width, height, vxres, vyres, pixelmask;\n\tunsigned long rincr, line_length, shift, pos, is8bpp;\n\tunsigned long i, j;\n\tconst unsigned char *data;\n\tvoid __iomem *regs_base;\n\tvoid __iomem *fb_base;\n\n\tis8bpp = info->var.bits_per_pixel == 8;\n\n\tdx = image->dx;\n\tdy = image->dy;\n\twidth = image->width;\n\theight = image->height;\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\tline_length = info->fix.line_length;\n\trincr = (width + 7) / 8;\n\n\t \n\tif (unlikely(width == 0))\n\t\treturn;\n\t \n\tif (dx > vxres || dy > vyres)\n\t\treturn;\n\tif (dx + width > vxres)\n\t\twidth = vxres - dx;\n\tif (dy + height > vyres)\n\t\theight = vyres - dy;\n\n\tregs_base = par->tga_regs_base;\n\tfb_base = par->tga_fb_base;\n\n\t \n\t \n\tfgcolor = image->fg_color;\n\tbgcolor = image->bg_color;\n\tif (is8bpp) {\n\t\tfgcolor |= fgcolor << 8;\n\t\tfgcolor |= fgcolor << 16;\n\t\tbgcolor |= bgcolor << 8;\n\t\tbgcolor |= bgcolor << 16;\n\t} else {\n\t\tif (fgcolor < 16)\n\t\t\tfgcolor = ((u32 *)info->pseudo_palette)[fgcolor];\n\t\tif (bgcolor < 16)\n\t\t\tbgcolor = ((u32 *)info->pseudo_palette)[bgcolor];\n\t}\n\t__raw_writel(fgcolor, regs_base + TGA_FOREGROUND_REG);\n\t__raw_writel(bgcolor, regs_base + TGA_BACKGROUND_REG);\n\n\t \n\tpos = dy * line_length;\n\tif (is8bpp) {\n\t\tpos += dx;\n\t\tshift = pos & 3;\n\t\tpos &= -4;\n\t} else {\n\t\tpos += dx * 4;\n\t\tshift = (pos & 7) >> 2;\n\t\tpos &= -8;\n\t}\n\n\tdata = (const unsigned char *) image->data;\n\n\t \n\t__raw_writel((is8bpp\n\t\t      ? TGA_MODE_SBM_8BPP | TGA_MODE_OPAQUE_STIPPLE\n\t\t      : TGA_MODE_SBM_24BPP | TGA_MODE_OPAQUE_STIPPLE),\n\t\t     regs_base + TGA_MODE_REG);\n\n\tif (width + shift <= 32) {\n\t\tunsigned long bwidth;\n\n\t\t \n\n\t\t \n\t\tpixelmask = (2ul << (width - 1)) - 1;\n\t\tpixelmask <<= shift;\n\t\t__raw_writel(pixelmask, regs_base + TGA_PIXELMASK_REG);\n\t\twmb();\n\n\t\tbwidth = (width + 7) / 8;\n\n\t\tfor (i = 0; i < height; ++i) {\n\t\t\tu32 mask = 0;\n\n\t\t\t \n\t\t\tfor (j = 0; j < bwidth; ++j)\n\t\t\t\tmask |= bitrev8(data[j]) << (j * 8);\n\n\t\t\t__raw_writel(mask << shift, fb_base + pos);\n\n\t\t\tpos += line_length;\n\t\t\tdata += rincr;\n\t\t}\n\t\twmb();\n\t\t__raw_writel(0xffffffff, regs_base + TGA_PIXELMASK_REG);\n\t} else if (shift == 0) {\n\t\tunsigned long pos0 = pos;\n\t\tconst unsigned char *data0 = data;\n\t\tunsigned long bincr = (is8bpp ? 8 : 8*4);\n\t\tunsigned long bwidth;\n\n\t\t \n\n\t\twmb();\n\n\t\tbwidth = (width / 8) & -4;\n\t\tfor (i = 0; i < height; ++i) {\n\t\t\tfor (j = 0; j < bwidth; j += 4) {\n\t\t\t\tu32 mask = 0;\n\t\t\t\tmask |= bitrev8(data[j+0]) << (0 * 8);\n\t\t\t\tmask |= bitrev8(data[j+1]) << (1 * 8);\n\t\t\t\tmask |= bitrev8(data[j+2]) << (2 * 8);\n\t\t\t\tmask |= bitrev8(data[j+3]) << (3 * 8);\n\t\t\t\t__raw_writel(mask, fb_base + pos + j*bincr);\n\t\t\t}\n\t\t\tpos += line_length;\n\t\t\tdata += rincr;\n\t\t}\n\t\twmb();\n\n\t\tpixelmask = (1ul << (width & 31)) - 1;\n\t\tif (pixelmask) {\n\t\t\t__raw_writel(pixelmask, regs_base + TGA_PIXELMASK_REG);\n\t\t\twmb();\n\n\t\t\tpos = pos0 + bwidth*bincr;\n\t\t\tdata = data0 + bwidth;\n\t\t\tbwidth = ((width & 31) + 7) / 8;\n\n\t\t\tfor (i = 0; i < height; ++i) {\n\t\t\t\tu32 mask = 0;\n\t\t\t\tfor (j = 0; j < bwidth; ++j)\n\t\t\t\t\tmask |= bitrev8(data[j]) << (j * 8);\n\t\t\t\t__raw_writel(mask, fb_base + pos);\n\t\t\t\tpos += line_length;\n\t\t\t\tdata += rincr;\n\t\t\t}\n\t\t\twmb();\n\t\t\t__raw_writel(0xffffffff, regs_base + TGA_PIXELMASK_REG);\n\t\t}\n\t} else {\n\t\tunsigned long pos0 = pos;\n\t\tconst unsigned char *data0 = data;\n\t\tunsigned long bincr = (is8bpp ? 8 : 8*4);\n\t\tunsigned long bwidth;\n\n\t\t \n\n\t\tpixelmask = 0xffff << shift;\n\t\t__raw_writel(pixelmask, regs_base + TGA_PIXELMASK_REG);\n\t\twmb();\n\n\t\tbwidth = (width / 8) & -2;\n\t\tfor (i = 0; i < height; ++i) {\n\t\t\tfor (j = 0; j < bwidth; j += 2) {\n\t\t\t\tu32 mask = 0;\n\t\t\t\tmask |= bitrev8(data[j+0]) << (0 * 8);\n\t\t\t\tmask |= bitrev8(data[j+1]) << (1 * 8);\n\t\t\t\tmask <<= shift;\n\t\t\t\t__raw_writel(mask, fb_base + pos + j*bincr);\n\t\t\t}\n\t\t\tpos += line_length;\n\t\t\tdata += rincr;\n\t\t}\n\t\twmb();\n\n\t\tpixelmask = ((1ul << (width & 15)) - 1) << shift;\n\t\tif (pixelmask) {\n\t\t\t__raw_writel(pixelmask, regs_base + TGA_PIXELMASK_REG);\n\t\t\twmb();\n\n\t\t\tpos = pos0 + bwidth*bincr;\n\t\t\tdata = data0 + bwidth;\n\t\t\tbwidth = (width & 15) > 8;\n\n\t\t\tfor (i = 0; i < height; ++i) {\n\t\t\t\tu32 mask = bitrev8(data[0]);\n\t\t\t\tif (bwidth)\n\t\t\t\t\tmask |= bitrev8(data[1]) << 8;\n\t\t\t\tmask <<= shift;\n\t\t\t\t__raw_writel(mask, fb_base + pos);\n\t\t\t\tpos += line_length;\n\t\t\t\tdata += rincr;\n\t\t\t}\n\t\t\twmb();\n\t\t}\n\t\t__raw_writel(0xffffffff, regs_base + TGA_PIXELMASK_REG);\n\t}\n\n\t \n\t__raw_writel((is8bpp\n\t\t      ? TGA_MODE_SBM_8BPP | TGA_MODE_SIMPLE\n\t\t      : TGA_MODE_SBM_24BPP | TGA_MODE_SIMPLE),\n\t\t     regs_base + TGA_MODE_REG);\n}\n\nstatic void\ntgafb_clut_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct tga_par *par = (struct tga_par *) info->par;\n\tu32 color, dx, dy, width, height, vxres, vyres;\n\tu32 *palette = ((u32 *)info->pseudo_palette);\n\tunsigned long pos, line_length, i, j;\n\tconst unsigned char *data;\n\tvoid __iomem *fb_base;\n\n\tdx = image->dx;\n\tdy = image->dy;\n\twidth = image->width;\n\theight = image->height;\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\tline_length = info->fix.line_length;\n\n\t \n\tif (dx > vxres || dy > vyres)\n\t\treturn;\n\tif (dx + width > vxres)\n\t\twidth = vxres - dx;\n\tif (dy + height > vyres)\n\t\theight = vyres - dy;\n\n\tfb_base = par->tga_fb_base;\n\n\tpos = dy * line_length + (dx * 4);\n\tdata = image->data;\n\n\t \n\tfor (i = 0; i < height; i++) {\n\t\tfor (j = 0; j < width; j++) {\n\t\t\tcolor = palette[*data++];\n\t\t\t__raw_writel(color, fb_base + pos + j*4);\n\t\t}\n\t\tpos += line_length;\n\t}\n}\n\n \nstatic void\ntgafb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tunsigned int is8bpp = info->var.bits_per_pixel == 8;\n\n\t \n\tif (image->depth == 1) {\n\t\ttgafb_mono_imageblit(info, image);\n\t\treturn;\n\t}\n\n\t \n\t \n\tif (image->depth == info->var.bits_per_pixel) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\n\t \n\tif (!is8bpp && image->depth == 8) {\n\t\ttgafb_clut_imageblit(info, image);\n\t\treturn;\n\t}\n\n\t \n}\n\n \nstatic void\ntgafb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct tga_par *par = (struct tga_par *) info->par;\n\tint is8bpp = info->var.bits_per_pixel == 8;\n\tu32 dx, dy, width, height, vxres, vyres, color;\n\tunsigned long pos, align, line_length, i, j;\n\tvoid __iomem *regs_base;\n\tvoid __iomem *fb_base;\n\n\tdx = rect->dx;\n\tdy = rect->dy;\n\twidth = rect->width;\n\theight = rect->height;\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\tline_length = info->fix.line_length;\n\tregs_base = par->tga_regs_base;\n\tfb_base = par->tga_fb_base;\n\n\t \n\tif (dx > vxres || dy > vyres || !width || !height)\n\t\treturn;\n\tif (dx + width > vxres)\n\t\twidth = vxres - dx;\n\tif (dy + height > vyres)\n\t\theight = vyres - dy;\n\n\tpos = dy * line_length + dx * (is8bpp ? 1 : 4);\n\n\t \n\tif (rect->rop != ROP_COPY) {\n\t\tcfb_fillrect(info, rect);\n\t\treturn;\n\t}\n\n\t \n\tcolor = rect->color;\n\tif (is8bpp) {\n\t\tcolor |= color << 8;\n\t\tcolor |= color << 16;\n\t\t__raw_writel(color, regs_base + TGA_BLOCK_COLOR0_REG);\n\t\t__raw_writel(color, regs_base + TGA_BLOCK_COLOR1_REG);\n\t} else {\n\t\tif (color < 16)\n\t\t\tcolor = ((u32 *)info->pseudo_palette)[color];\n\t\t__raw_writel(color, regs_base + TGA_BLOCK_COLOR0_REG);\n\t\t__raw_writel(color, regs_base + TGA_BLOCK_COLOR1_REG);\n\t\t__raw_writel(color, regs_base + TGA_BLOCK_COLOR2_REG);\n\t\t__raw_writel(color, regs_base + TGA_BLOCK_COLOR3_REG);\n\t\t__raw_writel(color, regs_base + TGA_BLOCK_COLOR4_REG);\n\t\t__raw_writel(color, regs_base + TGA_BLOCK_COLOR5_REG);\n\t\t__raw_writel(color, regs_base + TGA_BLOCK_COLOR6_REG);\n\t\t__raw_writel(color, regs_base + TGA_BLOCK_COLOR7_REG);\n\t}\n\n\t \n\t__raw_writel(0xffffffff, regs_base + TGA_DATA_REG);\n\n\t \n\t__raw_writel((is8bpp\n\t\t      ? TGA_MODE_SBM_8BPP | TGA_MODE_BLOCK_FILL\n\t\t      : TGA_MODE_SBM_24BPP | TGA_MODE_BLOCK_FILL),\n\t\t     regs_base + TGA_MODE_REG);\n\twmb();\n\n\t \n\tif (width == line_length) {\n\t\twidth *= height;\n\t\theight = 1;\n\t}\n\n\t \n\talign = (pos & 3) << 16;\n\tpos &= -4;\n\n\tif (width <= 2048) {\n\t\tu32 data;\n\n\t\tdata = (width - 1) | align;\n\n\t\tfor (i = 0; i < height; ++i) {\n\t\t\t__raw_writel(data, fb_base + pos);\n\t\t\tpos += line_length;\n\t\t}\n\t} else {\n\t\tunsigned long Bpp = (is8bpp ? 1 : 4);\n\t\tunsigned long nwidth = width & -2048;\n\t\tu32 fdata, ldata;\n\n\t\tfdata = (2048 - 1) | align;\n\t\tldata = ((width & 2047) - 1) | align;\n\n\t\tfor (i = 0; i < height; ++i) {\n\t\t\tfor (j = 0; j < nwidth; j += 2048)\n\t\t\t\t__raw_writel(fdata, fb_base + pos + j*Bpp);\n\t\t\tif (j < width)\n\t\t\t\t__raw_writel(ldata, fb_base + pos + j*Bpp);\n\t\t\tpos += line_length;\n\t\t}\n\t}\n\twmb();\n\n\t \n\t__raw_writel((is8bpp\n\t\t      ? TGA_MODE_SBM_8BPP | TGA_MODE_SIMPLE\n\t\t      : TGA_MODE_SBM_24BPP | TGA_MODE_SIMPLE),\n\t\t     regs_base + TGA_MODE_REG);\n}\n\n \n\n \n\nstatic inline void\ncopyarea_line_8bpp(struct fb_info *info, u32 dy, u32 sy,\n\t\t   u32 height, u32 width)\n{\n\tstruct tga_par *par = (struct tga_par *) info->par;\n\tvoid __iomem *tga_regs = par->tga_regs_base;\n\tunsigned long dpos, spos, i, n64;\n\n\t \n\t__raw_writel(TGA_MODE_SBM_8BPP | TGA_MODE_COPY, tga_regs+TGA_MODE_REG);\n\t__raw_writel(0, tga_regs+TGA_PIXELSHIFT_REG);\n\twmb();\n\n\tn64 = (height * width) / 64;\n\n\tif (sy < dy) {\n\t\tspos = (sy + height) * width;\n\t\tdpos = (dy + height) * width;\n\n\t\tfor (i = 0; i < n64; ++i) {\n\t\t\tspos -= 64;\n\t\t\tdpos -= 64;\n\t\t\t__raw_writel(spos, tga_regs+TGA_COPY64_SRC);\n\t\t\twmb();\n\t\t\t__raw_writel(dpos, tga_regs+TGA_COPY64_DST);\n\t\t\twmb();\n\t\t}\n\t} else {\n\t\tspos = sy * width;\n\t\tdpos = dy * width;\n\n\t\tfor (i = 0; i < n64; ++i) {\n\t\t\t__raw_writel(spos, tga_regs+TGA_COPY64_SRC);\n\t\t\twmb();\n\t\t\t__raw_writel(dpos, tga_regs+TGA_COPY64_DST);\n\t\t\twmb();\n\t\t\tspos += 64;\n\t\t\tdpos += 64;\n\t\t}\n\t}\n\n\t \n\t__raw_writel(TGA_MODE_SBM_8BPP|TGA_MODE_SIMPLE, tga_regs+TGA_MODE_REG);\n}\n\nstatic inline void\ncopyarea_line_32bpp(struct fb_info *info, u32 dy, u32 sy,\n\t\t    u32 height, u32 width)\n{\n\tstruct tga_par *par = (struct tga_par *) info->par;\n\tvoid __iomem *tga_regs = par->tga_regs_base;\n\tvoid __iomem *tga_fb = par->tga_fb_base;\n\tvoid __iomem *src;\n\tvoid __iomem *dst;\n\tunsigned long i, n16;\n\n\t \n\t__raw_writel(TGA_MODE_SBM_24BPP | TGA_MODE_COPY, tga_regs+TGA_MODE_REG);\n\t__raw_writel(0, tga_regs+TGA_PIXELSHIFT_REG);\n\twmb();\n\n\tn16 = (height * width) / 16;\n\n\tif (sy < dy) {\n\t\tsrc = tga_fb + (sy + height) * width * 4;\n\t\tdst = tga_fb + (dy + height) * width * 4;\n\n\t\tfor (i = 0; i < n16; ++i) {\n\t\t\tsrc -= 64;\n\t\t\tdst -= 64;\n\t\t\t__raw_writel(0xffff, src);\n\t\t\twmb();\n\t\t\t__raw_writel(0xffff, dst);\n\t\t\twmb();\n\t\t}\n\t} else {\n\t\tsrc = tga_fb + sy * width * 4;\n\t\tdst = tga_fb + dy * width * 4;\n\n\t\tfor (i = 0; i < n16; ++i) {\n\t\t\t__raw_writel(0xffff, src);\n\t\t\twmb();\n\t\t\t__raw_writel(0xffff, dst);\n\t\t\twmb();\n\t\t\tsrc += 64;\n\t\t\tdst += 64;\n\t\t}\n\t}\n\n\t \n\t__raw_writel(TGA_MODE_SBM_24BPP|TGA_MODE_SIMPLE, tga_regs+TGA_MODE_REG);\n}\n\n \nstatic inline void\ncopyarea_8bpp(struct fb_info *info, u32 dx, u32 dy, u32 sx, u32 sy,\n\t      u32 height, u32 width, u32 line_length,\n\t      const struct fb_copyarea *area)\n{\n\tstruct tga_par *par = (struct tga_par *) info->par;\n\tunsigned i, yincr;\n\tint depos, sepos, backward, last_step, step;\n\tu32 mask_last;\n\tunsigned n32;\n\tvoid __iomem *tga_regs;\n\tvoid __iomem *tga_fb;\n\n\t \n\tif ((dx | sx | width) & 7) {\n\t\tcfb_copyarea(info, area);\n\t\treturn;\n\t}\n\n\tyincr = line_length;\n\tif (dy > sy) {\n\t\tdy += height - 1;\n\t\tsy += height - 1;\n\t\tyincr = -yincr;\n\t}\n\tbackward = dy == sy && dx > sx && dx < sx + width;\n\n\t \n\tdepos = dy * line_length + dx;\n\tsepos = sy * line_length + sx;\n\tif (backward) {\n\t\tdepos += width;\n\t\tsepos += width;\n\t}\n\n\t \n\tn32 = width / 32;\n\tlast_step = width % 32;\n\n\t \n\tmask_last = (1ul << last_step) - 1;\n\n\tif (!backward) {\n\t\tstep = 32;\n\t\tlast_step = 32;\n\t} else {\n\t\tstep = -32;\n\t\tlast_step = -last_step;\n\t\tsepos -= 32;\n\t\tdepos -= 32;\n\t}\n\n\ttga_regs = par->tga_regs_base;\n\ttga_fb = par->tga_fb_base;\n\n\t \n\t__raw_writel(TGA_MODE_SBM_8BPP|TGA_MODE_COPY, tga_regs+TGA_MODE_REG);\n\t__raw_writel(0, tga_regs+TGA_PIXELSHIFT_REG);\n\twmb();\n\n\tfor (i = 0; i < height; ++i) {\n\t\tunsigned long j;\n\t\tvoid __iomem *sfb;\n\t\tvoid __iomem *dfb;\n\n\t\tsfb = tga_fb + sepos;\n\t\tdfb = tga_fb + depos;\n\n\t\tfor (j = 0; j < n32; j++) {\n\t\t\tif (j < 2 && j + 1 < n32 && !backward &&\n\t\t\t    !(((unsigned long)sfb | (unsigned long)dfb) & 63)) {\n\t\t\t\tdo {\n\t\t\t\t\t__raw_writel(sfb - tga_fb, tga_regs+TGA_COPY64_SRC);\n\t\t\t\t\twmb();\n\t\t\t\t\t__raw_writel(dfb - tga_fb, tga_regs+TGA_COPY64_DST);\n\t\t\t\t\twmb();\n\t\t\t\t\tsfb += 64;\n\t\t\t\t\tdfb += 64;\n\t\t\t\t\tj += 2;\n\t\t\t\t} while (j + 1 < n32);\n\t\t\t\tj--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t__raw_writel(0xffffffff, sfb);\n\t\t\twmb();\n\t\t\t__raw_writel(0xffffffff, dfb);\n\t\t\twmb();\n\t\t\tsfb += step;\n\t\t\tdfb += step;\n\t\t}\n\n\t\tif (mask_last) {\n\t\t\tsfb += last_step - step;\n\t\t\tdfb += last_step - step;\n\t\t\t__raw_writel(mask_last, sfb);\n\t\t\twmb();\n\t\t\t__raw_writel(mask_last, dfb);\n\t\t\twmb();\n\t\t}\n\n\t\tsepos += yincr;\n\t\tdepos += yincr;\n\t}\n\n\t \n\t__raw_writel(TGA_MODE_SBM_8BPP|TGA_MODE_SIMPLE, tga_regs+TGA_MODE_REG);\n}\n\nstatic void\ntgafb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tunsigned long dx, dy, width, height, sx, sy, vxres, vyres;\n\tunsigned long line_length, bpp;\n\n\tdx = area->dx;\n\tdy = area->dy;\n\twidth = area->width;\n\theight = area->height;\n\tsx = area->sx;\n\tsy = area->sy;\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\tline_length = info->fix.line_length;\n\n\t \n\tif (dx > vxres || sx > vxres || dy > vyres || sy > vyres)\n\t\treturn;\n\n\t \n\tif (dx + width > vxres)\n\t\twidth = vxres - dx;\n\tif (dy + height > vyres)\n\t\theight = vyres - dy;\n\n\t \n\tif (sx + width > vxres || sy + height > vyres)\n\t\treturn;\n\n\tbpp = info->var.bits_per_pixel;\n\n\t \n\tif (!(line_length & 63) && width * (bpp >> 3) == line_length) {\n\t\tif (bpp == 8)\n\t\t\tcopyarea_line_8bpp(info, dy, sy, height, width);\n\t\telse\n\t\t\tcopyarea_line_32bpp(info, dy, sy, height, width);\n\t}\n\n\t \n\telse if (bpp == 32)\n\t\tcfb_copyarea(info, area);\n\n\telse\n\t\tcopyarea_8bpp(info, dx, dy, sx, sy, height,\n\t\t\t      width, line_length, area);\n}\n\n\n \n\nstatic void\ntgafb_init_fix(struct fb_info *info)\n{\n\tstruct tga_par *par = (struct tga_par *)info->par;\n\tint tga_bus_pci = dev_is_pci(par->dev);\n\tint tga_bus_tc = TGA_BUS_TC(par->dev);\n\tu8 tga_type = par->tga_type;\n\tconst char *tga_type_name = NULL;\n\tunsigned memory_size;\n\n\tswitch (tga_type) {\n\tcase TGA_TYPE_8PLANE:\n\t\tif (tga_bus_pci)\n\t\t\ttga_type_name = \"Digital ZLXp-E1\";\n\t\tif (tga_bus_tc)\n\t\t\ttga_type_name = \"Digital ZLX-E1\";\n\t\tmemory_size = 2097152;\n\t\tbreak;\n\tcase TGA_TYPE_24PLANE:\n\t\tif (tga_bus_pci)\n\t\t\ttga_type_name = \"Digital ZLXp-E2\";\n\t\tif (tga_bus_tc)\n\t\t\ttga_type_name = \"Digital ZLX-E2\";\n\t\tmemory_size = 8388608;\n\t\tbreak;\n\tcase TGA_TYPE_24PLUSZ:\n\t\tif (tga_bus_pci)\n\t\t\ttga_type_name = \"Digital ZLXp-E3\";\n\t\tif (tga_bus_tc)\n\t\t\ttga_type_name = \"Digital ZLX-E3\";\n\t\tmemory_size = 16777216;\n\t\tbreak;\n\t}\n\tif (!tga_type_name) {\n\t\ttga_type_name = \"Unknown\";\n\t\tmemory_size = 16777216;\n\t}\n\n\tstrscpy(info->fix.id, tga_type_name, sizeof(info->fix.id));\n\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.type_aux = 0;\n\tinfo->fix.visual = (tga_type == TGA_TYPE_8PLANE\n\t\t\t    ? FB_VISUAL_PSEUDOCOLOR\n\t\t\t    : FB_VISUAL_DIRECTCOLOR);\n\n\tinfo->fix.smem_start = (size_t) par->tga_fb_base;\n\tinfo->fix.smem_len = memory_size;\n\tinfo->fix.mmio_start = (size_t) par->tga_regs_base;\n\tinfo->fix.mmio_len = 512;\n\n\tinfo->fix.xpanstep = 0;\n\tinfo->fix.ypanstep = 0;\n\tinfo->fix.ywrapstep = 0;\n\n\tinfo->fix.accel = FB_ACCEL_DEC_TGA;\n\n\t \n\tif (tga_type != TGA_TYPE_8PLANE) {\n\t\tinfo->var.red.length = 8;\n\t\tinfo->var.green.length = 8;\n\t\tinfo->var.blue.length = 8;\n\t\tinfo->var.red.offset = 16;\n\t\tinfo->var.green.offset = 8;\n\t\tinfo->var.blue.offset = 0;\n\t}\n}\n\nstatic int tgafb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\t \n\ttgafb_set_par(info);  \n\treturn 0;\n}\n\nstatic int tgafb_register(struct device *dev)\n{\n\tstatic const struct fb_videomode modedb_tc = {\n\t\t \n\t\t\"1280x1024@72\", 0, 1280, 1024, 7645, 224, 28, 33, 3, 160, 3,\n\t\tFB_SYNC_ON_GREEN, FB_VMODE_NONINTERLACED\n\t};\n\n\tstatic unsigned int const fb_offset_presets[4] = {\n\t\tTGA_8PLANE_FB_OFFSET,\n\t\tTGA_24PLANE_FB_OFFSET,\n\t\t0xffffffff,\n\t\tTGA_24PLUSZ_FB_OFFSET\n\t};\n\n\tconst struct fb_videomode *modedb_tga = NULL;\n\tresource_size_t bar0_start = 0, bar0_len = 0;\n\tconst char *mode_option_tga = NULL;\n\tint tga_bus_pci = dev_is_pci(dev);\n\tint tga_bus_tc = TGA_BUS_TC(dev);\n\tunsigned int modedbsize_tga = 0;\n\tvoid __iomem *mem_base;\n\tstruct fb_info *info;\n\tstruct tga_par *par;\n\tu8 tga_type;\n\tint ret = 0;\n\n\t \n\tif (tga_bus_pci && pci_enable_device(to_pci_dev(dev))) {\n\t\tprintk(KERN_ERR \"tgafb: Cannot enable PCI device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tinfo = framebuffer_alloc(sizeof(struct tga_par), dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tdev_set_drvdata(dev, info);\n\n\t \n\tret = -ENODEV;\n\tif (tga_bus_pci) {\n\t\tbar0_start = pci_resource_start(to_pci_dev(dev), 0);\n\t\tbar0_len = pci_resource_len(to_pci_dev(dev), 0);\n\t}\n\tif (tga_bus_tc) {\n\t\tbar0_start = to_tc_dev(dev)->resource.start;\n\t\tbar0_len = to_tc_dev(dev)->resource.end - bar0_start + 1;\n\t}\n\tif (!request_mem_region (bar0_start, bar0_len, \"tgafb\")) {\n\t\tprintk(KERN_ERR \"tgafb: cannot reserve FB region\\n\");\n\t\tgoto err0;\n\t}\n\n\t \n\tmem_base = ioremap(bar0_start, bar0_len);\n\tif (!mem_base) {\n\t\tprintk(KERN_ERR \"tgafb: Cannot map MMIO\\n\");\n\t\tgoto err1;\n\t}\n\n\t \n\ttga_type = (readl(mem_base) >> 12) & 0x0f;\n\tpar->dev = dev;\n\tpar->tga_mem_base = mem_base;\n\tpar->tga_fb_base = mem_base + fb_offset_presets[tga_type];\n\tpar->tga_regs_base = mem_base + TGA_REGS_OFFSET;\n\tpar->tga_type = tga_type;\n\tif (tga_bus_pci)\n\t\tpar->tga_chip_rev = (to_pci_dev(dev))->revision;\n\tif (tga_bus_tc)\n\t\tpar->tga_chip_rev = TGA_READ_REG(par, TGA_START_REG) & 0xff;\n\n\t \n\tinfo->flags = FBINFO_HWACCEL_COPYAREA |\n\t\t      FBINFO_HWACCEL_IMAGEBLIT | FBINFO_HWACCEL_FILLRECT;\n\tinfo->fbops = &tgafb_ops;\n\tinfo->screen_base = par->tga_fb_base;\n\tinfo->pseudo_palette = par->palette;\n\n\t \n\tif (tga_bus_pci) {\n\t\tmode_option_tga = mode_option_pci;\n\t}\n\tif (tga_bus_tc) {\n\t\tmode_option_tga = mode_option_tc;\n\t\tmodedb_tga = &modedb_tc;\n\t\tmodedbsize_tga = 1;\n\t}\n\n\ttgafb_init_fix(info);\n\n\tret = fb_find_mode(&info->var, info,\n\t\t\t   mode_option ? mode_option : mode_option_tga,\n\t\t\t   modedb_tga, modedbsize_tga, NULL,\n\t\t\t   tga_type == TGA_TYPE_8PLANE ? 8 : 32);\n\tif (ret == 0 || ret == 4) {\n\t\tprintk(KERN_ERR \"tgafb: Could not find valid video mode\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err1;\n\t}\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0)) {\n\t\tprintk(KERN_ERR \"tgafb: Could not allocate color map\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\ttgafb_set_par(info);\n\n\tif (register_framebuffer(info) < 0) {\n\t\tprintk(KERN_ERR \"tgafb: Could not register framebuffer\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err2;\n\t}\n\n\tif (tga_bus_pci) {\n\t\tpr_info(\"tgafb: DC21030 [TGA] detected, rev=0x%02x\\n\",\n\t\t\tpar->tga_chip_rev);\n\t\tpr_info(\"tgafb: at PCI bus %d, device %d, function %d\\n\",\n\t\t\tto_pci_dev(dev)->bus->number,\n\t\t\tPCI_SLOT(to_pci_dev(dev)->devfn),\n\t\t\tPCI_FUNC(to_pci_dev(dev)->devfn));\n\t}\n\tif (tga_bus_tc)\n\t\tpr_info(\"tgafb: SFB+ detected, rev=0x%02x\\n\",\n\t\t\tpar->tga_chip_rev);\n\tfb_info(info, \"%s frame buffer device at 0x%lx\\n\",\n\t\tinfo->fix.id, (long)bar0_start);\n\n\treturn 0;\n\n err2:\n\tfb_dealloc_cmap(&info->cmap);\n err1:\n\tif (mem_base)\n\t\tiounmap(mem_base);\n\trelease_mem_region(bar0_start, bar0_len);\n err0:\n\tframebuffer_release(info);\n\treturn ret;\n}\n\nstatic void tgafb_unregister(struct device *dev)\n{\n\tresource_size_t bar0_start = 0, bar0_len = 0;\n\tint tga_bus_pci = dev_is_pci(dev);\n\tint tga_bus_tc = TGA_BUS_TC(dev);\n\tstruct fb_info *info = NULL;\n\tstruct tga_par *par;\n\n\tinfo = dev_get_drvdata(dev);\n\tif (!info)\n\t\treturn;\n\n\tpar = info->par;\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\tiounmap(par->tga_mem_base);\n\tif (tga_bus_pci) {\n\t\tbar0_start = pci_resource_start(to_pci_dev(dev), 0);\n\t\tbar0_len = pci_resource_len(to_pci_dev(dev), 0);\n\t}\n\tif (tga_bus_tc) {\n\t\tbar0_start = to_tc_dev(dev)->resource.start;\n\t\tbar0_len = to_tc_dev(dev)->resource.end - bar0_start + 1;\n\t}\n\trelease_mem_region(bar0_start, bar0_len);\n\tframebuffer_release(info);\n}\n\nstatic void tgafb_exit(void)\n{\n\ttc_unregister_driver(&tgafb_tc_driver);\n\tpci_unregister_driver(&tgafb_pci_driver);\n}\n\n#ifndef MODULE\nstatic int tgafb_setup(char *arg)\n{\n\tchar *this_opt;\n\n\tif (arg && *arg) {\n\t\twhile ((this_opt = strsep(&arg, \",\"))) {\n\t\t\tif (!*this_opt)\n\t\t\t\tcontinue;\n\t\t\tif (!strncmp(this_opt, \"mode:\", 5))\n\t\t\t\tmode_option = this_opt+5;\n\t\t\telse\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"tgafb: unknown parameter %s\\n\",\n\t\t\t\t       this_opt);\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif  \n\nstatic int tgafb_init(void)\n{\n\tint status;\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"tgafb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"tgafb\", &option))\n\t\treturn -ENODEV;\n\ttgafb_setup(option);\n#endif\n\tstatus = pci_register_driver(&tgafb_pci_driver);\n\tif (!status)\n\t\tstatus = tc_register_driver(&tgafb_tc_driver);\n\treturn status;\n}\n\n \n\nmodule_init(tgafb_init);\nmodule_exit(tgafb_exit);\n\nMODULE_DESCRIPTION(\"Framebuffer driver for TGA/SFB+ chipset\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}