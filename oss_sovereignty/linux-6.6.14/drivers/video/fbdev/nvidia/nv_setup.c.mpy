{
  "module_name": "nv_setup.c",
  "hash_id": "5f65883480f253a9a13bdf0d2e5734a3a0ff22a186bfb25eae1e9f265a1f8b8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/nvidia/nv_setup.c",
  "human_readable_source": "  \n\n \n\n#include <video/vga.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include \"nv_type.h\"\n#include \"nv_local.h\"\n#include \"nv_proto.h\"\n \nvoid NVWriteCrtc(struct nvidia_par *par, u8 index, u8 value)\n{\n\tVGA_WR08(par->PCIO, par->IOBase + 0x04, index);\n\tVGA_WR08(par->PCIO, par->IOBase + 0x05, value);\n}\nu8 NVReadCrtc(struct nvidia_par *par, u8 index)\n{\n\tVGA_WR08(par->PCIO, par->IOBase + 0x04, index);\n\treturn (VGA_RD08(par->PCIO, par->IOBase + 0x05));\n}\nvoid NVWriteGr(struct nvidia_par *par, u8 index, u8 value)\n{\n\tVGA_WR08(par->PVIO, VGA_GFX_I, index);\n\tVGA_WR08(par->PVIO, VGA_GFX_D, value);\n}\nu8 NVReadGr(struct nvidia_par *par, u8 index)\n{\n\tVGA_WR08(par->PVIO, VGA_GFX_I, index);\n\treturn (VGA_RD08(par->PVIO, VGA_GFX_D));\n}\nvoid NVWriteSeq(struct nvidia_par *par, u8 index, u8 value)\n{\n\tVGA_WR08(par->PVIO, VGA_SEQ_I, index);\n\tVGA_WR08(par->PVIO, VGA_SEQ_D, value);\n}\nu8 NVReadSeq(struct nvidia_par *par, u8 index)\n{\n\tVGA_WR08(par->PVIO, VGA_SEQ_I, index);\n\treturn (VGA_RD08(par->PVIO, VGA_SEQ_D));\n}\nvoid NVWriteAttr(struct nvidia_par *par, u8 index, u8 value)\n{\n\n\tVGA_RD08(par->PCIO, par->IOBase + 0x0a);\n\tif (par->paletteEnabled)\n\t\tindex &= ~0x20;\n\telse\n\t\tindex |= 0x20;\n\tVGA_WR08(par->PCIO, VGA_ATT_IW, index);\n\tVGA_WR08(par->PCIO, VGA_ATT_W, value);\n}\nu8 NVReadAttr(struct nvidia_par *par, u8 index)\n{\n\tVGA_RD08(par->PCIO, par->IOBase + 0x0a);\n\tif (par->paletteEnabled)\n\t\tindex &= ~0x20;\n\telse\n\t\tindex |= 0x20;\n\tVGA_WR08(par->PCIO, VGA_ATT_IW, index);\n\treturn (VGA_RD08(par->PCIO, VGA_ATT_R));\n}\nvoid NVWriteMiscOut(struct nvidia_par *par, u8 value)\n{\n\tVGA_WR08(par->PVIO, VGA_MIS_W, value);\n}\nu8 NVReadMiscOut(struct nvidia_par *par)\n{\n\treturn (VGA_RD08(par->PVIO, VGA_MIS_R));\n}\nvoid NVWriteDacMask(struct nvidia_par *par, u8 value)\n{\n\tVGA_WR08(par->PDIO, VGA_PEL_MSK, value);\n}\nvoid NVWriteDacReadAddr(struct nvidia_par *par, u8 value)\n{\n\tVGA_WR08(par->PDIO, VGA_PEL_IR, value);\n}\nvoid NVWriteDacWriteAddr(struct nvidia_par *par, u8 value)\n{\n\tVGA_WR08(par->PDIO, VGA_PEL_IW, value);\n}\nvoid NVWriteDacData(struct nvidia_par *par, u8 value)\n{\n\tVGA_WR08(par->PDIO, VGA_PEL_D, value);\n}\nu8 NVReadDacData(struct nvidia_par *par)\n{\n\treturn (VGA_RD08(par->PDIO, VGA_PEL_D));\n}\n\nstatic int NVIsConnected(struct nvidia_par *par, int output)\n{\n\tvolatile u32 __iomem *PRAMDAC = par->PRAMDAC0;\n\tu32 reg52C, reg608, dac0_reg608 = 0;\n\tint present;\n\n\tif (output) {\n\t    dac0_reg608 = NV_RD32(PRAMDAC, 0x0608);\n\t    PRAMDAC += 0x800;\n\t}\n\n\treg52C = NV_RD32(PRAMDAC, 0x052C);\n\treg608 = NV_RD32(PRAMDAC, 0x0608);\n\n\tNV_WR32(PRAMDAC, 0x0608, reg608 & ~0x00010000);\n\n\tNV_WR32(PRAMDAC, 0x052C, reg52C & 0x0000FEEE);\n\tmsleep(1);\n\tNV_WR32(PRAMDAC, 0x052C, NV_RD32(PRAMDAC, 0x052C) | 1);\n\n\tNV_WR32(par->PRAMDAC0, 0x0610, 0x94050140);\n\tNV_WR32(par->PRAMDAC0, 0x0608, NV_RD32(par->PRAMDAC0, 0x0608) |\n\t\t0x00001000);\n\n\tmsleep(1);\n\n\tpresent = (NV_RD32(PRAMDAC, 0x0608) & (1 << 28)) ? 1 : 0;\n\n\tif (present)\n\t\tprintk(\"nvidiafb: CRTC%i analog found\\n\", output);\n\telse\n\t\tprintk(\"nvidiafb: CRTC%i analog not found\\n\", output);\n\n\tif (output)\n\t    NV_WR32(par->PRAMDAC0, 0x0608, dac0_reg608);\n\n\tNV_WR32(PRAMDAC, 0x052C, reg52C);\n\tNV_WR32(PRAMDAC, 0x0608, reg608);\n\n\treturn present;\n}\n\nstatic void NVSelectHeadRegisters(struct nvidia_par *par, int head)\n{\n\tif (head) {\n\t\tpar->PCIO = par->PCIO0 + 0x2000;\n\t\tpar->PCRTC = par->PCRTC0 + 0x800;\n\t\tpar->PRAMDAC = par->PRAMDAC0 + 0x800;\n\t\tpar->PDIO = par->PDIO0 + 0x2000;\n\t} else {\n\t\tpar->PCIO = par->PCIO0;\n\t\tpar->PCRTC = par->PCRTC0;\n\t\tpar->PRAMDAC = par->PRAMDAC0;\n\t\tpar->PDIO = par->PDIO0;\n\t}\n}\n\nstatic void nv4GetConfig(struct nvidia_par *par)\n{\n\tif (NV_RD32(par->PFB, 0x0000) & 0x00000100) {\n\t\tpar->RamAmountKBytes =\n\t\t    ((NV_RD32(par->PFB, 0x0000) >> 12) & 0x0F) * 1024 * 2 +\n\t\t    1024 * 2;\n\t} else {\n\t\tswitch (NV_RD32(par->PFB, 0x0000) & 0x00000003) {\n\t\tcase 0:\n\t\t\tpar->RamAmountKBytes = 1024 * 32;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpar->RamAmountKBytes = 1024 * 4;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpar->RamAmountKBytes = 1024 * 8;\n\t\t\tbreak;\n\t\tcase 3:\n\t\tdefault:\n\t\t\tpar->RamAmountKBytes = 1024 * 16;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpar->CrystalFreqKHz = (NV_RD32(par->PEXTDEV, 0x0000) & 0x00000040) ?\n\t    14318 : 13500;\n\tpar->CURSOR = &par->PRAMIN[0x1E00];\n\tpar->MinVClockFreqKHz = 12000;\n\tpar->MaxVClockFreqKHz = 350000;\n}\n\nstatic void nv10GetConfig(struct nvidia_par *par)\n{\n\tstruct pci_dev *dev;\n\tu32 implementation = par->Chipset & 0x0ff0;\n\n#ifdef __BIG_ENDIAN\n\t \n\tif (!(NV_RD32(par->PMC, 0x0004) & 0x01000001)) {\n\t\tNV_WR32(par->PMC, 0x0004, 0x01000001);\n\t\tmb();\n\t}\n#endif\n\n\tdev = pci_get_domain_bus_and_slot(pci_domain_nr(par->pci_dev->bus),\n\t\t\t\t\t  0, 1);\n\tif ((par->Chipset & 0xffff) == 0x01a0) {\n\t\tu32 amt;\n\n\t\tpci_read_config_dword(dev, 0x7c, &amt);\n\t\tpar->RamAmountKBytes = (((amt >> 6) & 31) + 1) * 1024;\n\t} else if ((par->Chipset & 0xffff) == 0x01f0) {\n\t\tu32 amt;\n\n\t\tpci_read_config_dword(dev, 0x84, &amt);\n\t\tpar->RamAmountKBytes = (((amt >> 4) & 127) + 1) * 1024;\n\t} else {\n\t\tpar->RamAmountKBytes =\n\t\t    (NV_RD32(par->PFB, 0x020C) & 0xFFF00000) >> 10;\n\t}\n\tpci_dev_put(dev);\n\n\tpar->CrystalFreqKHz = (NV_RD32(par->PEXTDEV, 0x0000) & (1 << 6)) ?\n\t    14318 : 13500;\n\n\tif (par->twoHeads && (implementation != 0x0110)) {\n\t\tif (NV_RD32(par->PEXTDEV, 0x0000) & (1 << 22))\n\t\t\tpar->CrystalFreqKHz = 27000;\n\t}\n\n\tpar->CURSOR = NULL;\t \n\tpar->MinVClockFreqKHz = 12000;\n\tpar->MaxVClockFreqKHz = par->twoStagePLL ? 400000 : 350000;\n}\n\nint NVCommonSetup(struct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\tstruct fb_var_screeninfo *var;\n\tu16 implementation = par->Chipset & 0x0ff0;\n\tu8 *edidA = NULL, *edidB = NULL;\n\tstruct fb_monspecs *monitorA, *monitorB;\n\tstruct fb_monspecs *monA = NULL, *monB = NULL;\n\tint mobile = 0;\n\tint tvA = 0;\n\tint tvB = 0;\n\tint FlatPanel = -1;\t \n\tint Television = 0;\n\tint err = 0;\n\n\tvar = kzalloc(sizeof(struct fb_var_screeninfo), GFP_KERNEL);\n\tmonitorA = kzalloc(sizeof(struct fb_monspecs), GFP_KERNEL);\n\tmonitorB = kzalloc(sizeof(struct fb_monspecs), GFP_KERNEL);\n\n\tif (!var || !monitorA || !monitorB) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tpar->PRAMIN = par->REGS + (0x00710000 / 4);\n\tpar->PCRTC0 = par->REGS + (0x00600000 / 4);\n\tpar->PRAMDAC0 = par->REGS + (0x00680000 / 4);\n\tpar->PFB = par->REGS + (0x00100000 / 4);\n\tpar->PFIFO = par->REGS + (0x00002000 / 4);\n\tpar->PGRAPH = par->REGS + (0x00400000 / 4);\n\tpar->PEXTDEV = par->REGS + (0x00101000 / 4);\n\tpar->PTIMER = par->REGS + (0x00009000 / 4);\n\tpar->PMC = par->REGS + (0x00000000 / 4);\n\tpar->FIFO = par->REGS + (0x00800000 / 4);\n\n\t \n\tpar->PCIO0 = (u8 __iomem *) par->REGS + 0x00601000;\n\tpar->PDIO0 = (u8 __iomem *) par->REGS + 0x00681000;\n\tpar->PVIO = (u8 __iomem *) par->REGS + 0x000C0000;\n\n\tpar->twoHeads = (par->Architecture >= NV_ARCH_10) &&\n\t    (implementation != 0x0100) &&\n\t    (implementation != 0x0150) &&\n\t    (implementation != 0x01A0) && (implementation != 0x0200);\n\n\tpar->fpScaler = (par->FpScale && par->twoHeads &&\n\t\t\t (implementation != 0x0110));\n\n\tpar->twoStagePLL = (implementation == 0x0310) ||\n\t    (implementation == 0x0340) || (par->Architecture >= NV_ARCH_40);\n\n\tpar->WaitVSyncPossible = (par->Architecture >= NV_ARCH_10) &&\n\t    (implementation != 0x0100);\n\n\tpar->BlendingPossible = ((par->Chipset & 0xffff) != 0x0020);\n\n\t \n\tswitch (par->Chipset & 0xffff) {\n\tcase 0x0112:\n\tcase 0x0174:\n\tcase 0x0175:\n\tcase 0x0176:\n\tcase 0x0177:\n\tcase 0x0179:\n\tcase 0x017C:\n\tcase 0x017D:\n\tcase 0x0186:\n\tcase 0x0187:\n\tcase 0x018D:\n\tcase 0x01D7:\n\tcase 0x0228:\n\tcase 0x0286:\n\tcase 0x028C:\n\tcase 0x0316:\n\tcase 0x0317:\n\tcase 0x031A:\n\tcase 0x031B:\n\tcase 0x031C:\n\tcase 0x031D:\n\tcase 0x031E:\n\tcase 0x031F:\n\tcase 0x0324:\n\tcase 0x0325:\n\tcase 0x0328:\n\tcase 0x0329:\n\tcase 0x032C:\n\tcase 0x032D:\n\tcase 0x0347:\n\tcase 0x0348:\n\tcase 0x0349:\n\tcase 0x034B:\n\tcase 0x034C:\n\tcase 0x0160:\n\tcase 0x0166:\n\tcase 0x0169:\n\tcase 0x016B:\n\tcase 0x016C:\n\tcase 0x016D:\n\tcase 0x00C8:\n\tcase 0x00CC:\n\tcase 0x0144:\n\tcase 0x0146:\n\tcase 0x0147:\n\tcase 0x0148:\n\tcase 0x0098:\n\tcase 0x0099:\n\t\tmobile = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (par->Architecture == NV_ARCH_04)\n\t\tnv4GetConfig(par);\n\telse\n\t\tnv10GetConfig(par);\n\n\tNVSelectHeadRegisters(par, 0);\n\n\tNVLockUnlock(par, 0);\n\n\tpar->IOBase = (NVReadMiscOut(par) & 0x01) ? 0x3d0 : 0x3b0;\n\n\tpar->Television = 0;\n\n\tnvidia_create_i2c_busses(par);\n\tif (!par->twoHeads) {\n\t\tpar->CRTCnumber = 0;\n\t\tif (nvidia_probe_i2c_connector(info, 1, &edidA))\n\t\t\tnvidia_probe_of_connector(info, 1, &edidA);\n\t\tif (edidA && !fb_parse_edid(edidA, var)) {\n\t\t\tprintk(\"nvidiafb: EDID found from BUS1\\n\");\n\t\t\tmonA = monitorA;\n\t\t\tfb_edid_to_monspecs(edidA, monA);\n\t\t\tFlatPanel = (monA->input & FB_DISP_DDI) ? 1 : 0;\n\n\t\t\t \n\t\t\tif ((par->Chipset & 0x0fff) <= 0x0020)\n\t\t\t\tFlatPanel = 0;\n\t\t} else {\n\t\t\tVGA_WR08(par->PCIO, 0x03D4, 0x28);\n\t\t\tif (VGA_RD08(par->PCIO, 0x03D5) & 0x80) {\n\t\t\t\tVGA_WR08(par->PCIO, 0x03D4, 0x33);\n\t\t\t\tif (!(VGA_RD08(par->PCIO, 0x03D5) & 0x01))\n\t\t\t\t\tTelevision = 1;\n\t\t\t\tFlatPanel = 1;\n\t\t\t} else {\n\t\t\t\tFlatPanel = 0;\n\t\t\t}\n\t\t\tprintk(\"nvidiafb: HW is currently programmed for %s\\n\",\n\t\t\t       FlatPanel ? (Television ? \"TV\" : \"DFP\") :\n\t\t\t       \"CRT\");\n\t\t}\n\n\t\tif (par->FlatPanel == -1) {\n\t\t\tpar->FlatPanel = FlatPanel;\n\t\t\tpar->Television = Television;\n\t\t} else {\n\t\t\tprintk(\"nvidiafb: Forcing display type to %s as \"\n\t\t\t       \"specified\\n\", par->FlatPanel ? \"DFP\" : \"CRT\");\n\t\t}\n\t} else {\n\t\tu8 outputAfromCRTC, outputBfromCRTC;\n\t\tint CRTCnumber = -1;\n\t\tu8 slaved_on_A, slaved_on_B;\n\t\tint analog_on_A, analog_on_B;\n\t\tu32 oldhead;\n\t\tu8 cr44;\n\n\t\tif (implementation != 0x0110) {\n\t\t\tif (NV_RD32(par->PRAMDAC0, 0x0000052C) & 0x100)\n\t\t\t\toutputAfromCRTC = 1;\n\t\t\telse\n\t\t\t\toutputAfromCRTC = 0;\n\t\t\tif (NV_RD32(par->PRAMDAC0, 0x0000252C) & 0x100)\n\t\t\t\toutputBfromCRTC = 1;\n\t\t\telse\n\t\t\t\toutputBfromCRTC = 0;\n\t\t\tanalog_on_A = NVIsConnected(par, 0);\n\t\t\tanalog_on_B = NVIsConnected(par, 1);\n\t\t} else {\n\t\t\toutputAfromCRTC = 0;\n\t\t\toutputBfromCRTC = 1;\n\t\t\tanalog_on_A = 0;\n\t\t\tanalog_on_B = 0;\n\t\t}\n\n\t\tVGA_WR08(par->PCIO, 0x03D4, 0x44);\n\t\tcr44 = VGA_RD08(par->PCIO, 0x03D5);\n\n\t\tVGA_WR08(par->PCIO, 0x03D5, 3);\n\t\tNVSelectHeadRegisters(par, 1);\n\t\tNVLockUnlock(par, 0);\n\n\t\tVGA_WR08(par->PCIO, 0x03D4, 0x28);\n\t\tslaved_on_B = VGA_RD08(par->PCIO, 0x03D5) & 0x80;\n\t\tif (slaved_on_B) {\n\t\t\tVGA_WR08(par->PCIO, 0x03D4, 0x33);\n\t\t\ttvB = !(VGA_RD08(par->PCIO, 0x03D5) & 0x01);\n\t\t}\n\n\t\tVGA_WR08(par->PCIO, 0x03D4, 0x44);\n\t\tVGA_WR08(par->PCIO, 0x03D5, 0);\n\t\tNVSelectHeadRegisters(par, 0);\n\t\tNVLockUnlock(par, 0);\n\n\t\tVGA_WR08(par->PCIO, 0x03D4, 0x28);\n\t\tslaved_on_A = VGA_RD08(par->PCIO, 0x03D5) & 0x80;\n\t\tif (slaved_on_A) {\n\t\t\tVGA_WR08(par->PCIO, 0x03D4, 0x33);\n\t\t\ttvA = !(VGA_RD08(par->PCIO, 0x03D5) & 0x01);\n\t\t}\n\n\t\toldhead = NV_RD32(par->PCRTC0, 0x00000860);\n\t\tNV_WR32(par->PCRTC0, 0x00000860, oldhead | 0x00000010);\n\n\t\tif (nvidia_probe_i2c_connector(info, 1, &edidA))\n\t\t\tnvidia_probe_of_connector(info, 1, &edidA);\n\t\tif (edidA && !fb_parse_edid(edidA, var)) {\n\t\t\tprintk(\"nvidiafb: EDID found from BUS1\\n\");\n\t\t\tmonA = monitorA;\n\t\t\tfb_edid_to_monspecs(edidA, monA);\n\t\t}\n\n\t\tif (nvidia_probe_i2c_connector(info, 2, &edidB))\n\t\t\tnvidia_probe_of_connector(info, 2, &edidB);\n\t\tif (edidB && !fb_parse_edid(edidB, var)) {\n\t\t\tprintk(\"nvidiafb: EDID found from BUS2\\n\");\n\t\t\tmonB = monitorB;\n\t\t\tfb_edid_to_monspecs(edidB, monB);\n\t\t}\n\n\t\tif (slaved_on_A && !tvA) {\n\t\t\tCRTCnumber = 0;\n\t\t\tFlatPanel = 1;\n\t\t\tprintk(\"nvidiafb: CRTC 0 is currently programmed for \"\n\t\t\t       \"DFP\\n\");\n\t\t} else if (slaved_on_B && !tvB) {\n\t\t\tCRTCnumber = 1;\n\t\t\tFlatPanel = 1;\n\t\t\tprintk(\"nvidiafb: CRTC 1 is currently programmed \"\n\t\t\t       \"for DFP\\n\");\n\t\t} else if (analog_on_A) {\n\t\t\tCRTCnumber = outputAfromCRTC;\n\t\t\tFlatPanel = 0;\n\t\t\tprintk(\"nvidiafb: CRTC %i appears to have a \"\n\t\t\t       \"CRT attached\\n\", CRTCnumber);\n\t\t} else if (analog_on_B) {\n\t\t\tCRTCnumber = outputBfromCRTC;\n\t\t\tFlatPanel = 0;\n\t\t\tprintk(\"nvidiafb: CRTC %i appears to have a \"\n\t\t\t       \"CRT attached\\n\", CRTCnumber);\n\t\t} else if (slaved_on_A) {\n\t\t\tCRTCnumber = 0;\n\t\t\tFlatPanel = 1;\n\t\t\tTelevision = 1;\n\t\t\tprintk(\"nvidiafb: CRTC 0 is currently programmed \"\n\t\t\t       \"for TV\\n\");\n\t\t} else if (slaved_on_B) {\n\t\t\tCRTCnumber = 1;\n\t\t\tFlatPanel = 1;\n\t\t\tTelevision = 1;\n\t\t\tprintk(\"nvidiafb: CRTC 1 is currently programmed for \"\n\t\t\t       \"TV\\n\");\n\t\t} else if (monA) {\n\t\t\tFlatPanel = (monA->input & FB_DISP_DDI) ? 1 : 0;\n\t\t} else if (monB) {\n\t\t\tFlatPanel = (monB->input & FB_DISP_DDI) ? 1 : 0;\n\t\t}\n\n\t\tif (par->FlatPanel == -1) {\n\t\t\tif (FlatPanel != -1) {\n\t\t\t\tpar->FlatPanel = FlatPanel;\n\t\t\t\tpar->Television = Television;\n\t\t\t} else {\n\t\t\t\tprintk(\"nvidiafb: Unable to detect display \"\n\t\t\t\t       \"type...\\n\");\n\t\t\t\tif (mobile) {\n\t\t\t\t\tprintk(\"...On a laptop, assuming \"\n\t\t\t\t\t       \"DFP\\n\");\n\t\t\t\t\tpar->FlatPanel = 1;\n\t\t\t\t} else {\n\t\t\t\t\tprintk(\"...Using default of CRT\\n\");\n\t\t\t\t\tpar->FlatPanel = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tprintk(\"nvidiafb: Forcing display type to %s as \"\n\t\t\t       \"specified\\n\", par->FlatPanel ? \"DFP\" : \"CRT\");\n\t\t}\n\n\t\tif (par->CRTCnumber == -1) {\n\t\t\tif (CRTCnumber != -1)\n\t\t\t\tpar->CRTCnumber = CRTCnumber;\n\t\t\telse {\n\t\t\t\tprintk(\"nvidiafb: Unable to detect which \"\n\t\t\t\t       \"CRTCNumber...\\n\");\n\t\t\t\tif (par->FlatPanel)\n\t\t\t\t\tpar->CRTCnumber = 1;\n\t\t\t\telse\n\t\t\t\t\tpar->CRTCnumber = 0;\n\t\t\t\tprintk(\"...Defaulting to CRTCNumber %i\\n\",\n\t\t\t\t       par->CRTCnumber);\n\t\t\t}\n\t\t} else {\n\t\t\tprintk(\"nvidiafb: Forcing CRTCNumber %i as \"\n\t\t\t       \"specified\\n\", par->CRTCnumber);\n\t\t}\n\n\t\tif (monA) {\n\t\t\tif (((monA->input & FB_DISP_DDI) &&\n\t\t\t     par->FlatPanel) ||\n\t\t\t    ((!(monA->input & FB_DISP_DDI)) &&\n\t\t\t     !par->FlatPanel)) {\n\t\t\t\tif (monB) {\n\t\t\t\t\tfb_destroy_modedb(monB->modedb);\n\t\t\t\t\tmonB = NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfb_destroy_modedb(monA->modedb);\n\t\t\t\tmonA = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (monB) {\n\t\t\tif (((monB->input & FB_DISP_DDI) &&\n\t\t\t     !par->FlatPanel) ||\n\t\t\t    ((!(monB->input & FB_DISP_DDI)) &&\n\t\t\t     par->FlatPanel)) {\n\t\t\t\tfb_destroy_modedb(monB->modedb);\n\t\t\t\tmonB = NULL;\n\t\t\t} else\n\t\t\t\tmonA = monB;\n\t\t}\n\n\t\tif (implementation == 0x0110)\n\t\t\tcr44 = par->CRTCnumber * 0x3;\n\n\t\tNV_WR32(par->PCRTC0, 0x00000860, oldhead);\n\n\t\tVGA_WR08(par->PCIO, 0x03D4, 0x44);\n\t\tVGA_WR08(par->PCIO, 0x03D5, cr44);\n\t\tNVSelectHeadRegisters(par, par->CRTCnumber);\n\t}\n\n\tprintk(\"nvidiafb: Using %s on CRTC %i\\n\",\n\t       par->FlatPanel ? (par->Television ? \"TV\" : \"DFP\") : \"CRT\",\n\t       par->CRTCnumber);\n\n\tif (par->FlatPanel && !par->Television) {\n\t\tpar->fpWidth = NV_RD32(par->PRAMDAC, 0x0820) + 1;\n\t\tpar->fpHeight = NV_RD32(par->PRAMDAC, 0x0800) + 1;\n\t\tpar->fpSyncs = NV_RD32(par->PRAMDAC, 0x0848) & 0x30000033;\n\n\t\tprintk(\"nvidiafb: Panel size is %i x %i\\n\", par->fpWidth, par->fpHeight);\n\t}\n\n\tif (monA)\n\t\tinfo->monspecs = *monA;\n\n\tif (!par->FlatPanel || !par->twoHeads)\n\t\tpar->FPDither = 0;\n\n\tpar->LVDS = 0;\n\tif (par->FlatPanel && par->twoHeads) {\n\t\tNV_WR32(par->PRAMDAC0, 0x08B0, 0x00010004);\n\t\tif (NV_RD32(par->PRAMDAC0, 0x08b4) & 1)\n\t\t\tpar->LVDS = 1;\n\t\tprintk(\"nvidiafb: Panel is %s\\n\", par->LVDS ? \"LVDS\" : \"TMDS\");\n\t}\n\n\tkfree(edidA);\n\tkfree(edidB);\ndone:\n\tkfree(var);\n\tkfree(monitorA);\n\tkfree(monitorB);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}