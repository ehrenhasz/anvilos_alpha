{
  "module_name": "nv_accel.c",
  "hash_id": "a73ab8c295d7c3332c9bf32b61d02d3ed3dbbc1cdf625bb8309cebbeef8a4727",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/nvidia/nv_accel.c",
  "human_readable_source": "  \n\n \n\n#include <linux/fb.h>\n#include <linux/nmi.h>\n\n#include \"nv_type.h\"\n#include \"nv_proto.h\"\n#include \"nv_dma.h\"\n#include \"nv_local.h\"\n\n \n#define SKIPS  8\n\nstatic const int NVCopyROP[16] = {\n\t0xCC,\t\t\t \n\t0x55\t\t\t \n};\n\nstatic const int NVCopyROP_PM[16] = {\n\t0xCA,\t\t\t \n\t0x5A,\t\t\t \n};\n\nstatic inline void nvidiafb_safe_mode(struct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\n\ttouch_softlockup_watchdog();\n\tinfo->pixmap.scan_align = 1;\n\tpar->lockup = 1;\n}\n\nstatic inline void NVFlush(struct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\tint count = 1000000000;\n\n\twhile (--count && READ_GET(par) != par->dmaPut) ;\n\n\tif (!count) {\n\t\tprintk(\"nvidiafb: DMA Flush lockup\\n\");\n\t\tnvidiafb_safe_mode(info);\n\t}\n}\n\nstatic inline void NVSync(struct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\tint count = 1000000000;\n\n\twhile (--count && NV_RD32(par->PGRAPH, 0x0700)) ;\n\n\tif (!count) {\n\t\tprintk(\"nvidiafb: DMA Sync lockup\\n\");\n\t\tnvidiafb_safe_mode(info);\n\t}\n}\n\nstatic void NVDmaKickoff(struct nvidia_par *par)\n{\n\tif (par->dmaCurrent != par->dmaPut) {\n\t\tpar->dmaPut = par->dmaCurrent;\n\t\tWRITE_PUT(par, par->dmaPut);\n\t}\n}\n\nstatic void NVDmaWait(struct fb_info *info, int size)\n{\n\tstruct nvidia_par *par = info->par;\n\tint dmaGet;\n\tint count = 1000000000, cnt;\n\tsize++;\n\n\twhile (par->dmaFree < size && --count && !par->lockup) {\n\t\tdmaGet = READ_GET(par);\n\n\t\tif (par->dmaPut >= dmaGet) {\n\t\t\tpar->dmaFree = par->dmaMax - par->dmaCurrent;\n\t\t\tif (par->dmaFree < size) {\n\t\t\t\tNVDmaNext(par, 0x20000000);\n\t\t\t\tif (dmaGet <= SKIPS) {\n\t\t\t\t\tif (par->dmaPut <= SKIPS)\n\t\t\t\t\t\tWRITE_PUT(par, SKIPS + 1);\n\t\t\t\t\tcnt = 1000000000;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tdmaGet = READ_GET(par);\n\t\t\t\t\t} while (--cnt && dmaGet <= SKIPS);\n\t\t\t\t\tif (!cnt) {\n\t\t\t\t\t\tprintk(\"DMA Get lockup\\n\");\n\t\t\t\t\t\tpar->lockup = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tWRITE_PUT(par, SKIPS);\n\t\t\t\tpar->dmaCurrent = par->dmaPut = SKIPS;\n\t\t\t\tpar->dmaFree = dmaGet - (SKIPS + 1);\n\t\t\t}\n\t\t} else\n\t\t\tpar->dmaFree = dmaGet - par->dmaCurrent - 1;\n\t}\n\n\tif (!count) {\n\t\tprintk(\"nvidiafb: DMA Wait Lockup\\n\");\n\t\tnvidiafb_safe_mode(info);\n\t}\n}\n\nstatic void NVSetPattern(struct fb_info *info, u32 clr0, u32 clr1,\n\t\t\t u32 pat0, u32 pat1)\n{\n\tstruct nvidia_par *par = info->par;\n\n\tNVDmaStart(info, par, PATTERN_COLOR_0, 4);\n\tNVDmaNext(par, clr0);\n\tNVDmaNext(par, clr1);\n\tNVDmaNext(par, pat0);\n\tNVDmaNext(par, pat1);\n}\n\nstatic void NVSetRopSolid(struct fb_info *info, u32 rop, u32 planemask)\n{\n\tstruct nvidia_par *par = info->par;\n\n\tif (planemask != ~0) {\n\t\tNVSetPattern(info, 0, planemask, ~0, ~0);\n\t\tif (par->currentRop != (rop + 32)) {\n\t\t\tNVDmaStart(info, par, ROP_SET, 1);\n\t\t\tNVDmaNext(par, NVCopyROP_PM[rop]);\n\t\t\tpar->currentRop = rop + 32;\n\t\t}\n\t} else if (par->currentRop != rop) {\n\t\tif (par->currentRop >= 16)\n\t\t\tNVSetPattern(info, ~0, ~0, ~0, ~0);\n\t\tNVDmaStart(info, par, ROP_SET, 1);\n\t\tNVDmaNext(par, NVCopyROP[rop]);\n\t\tpar->currentRop = rop;\n\t}\n}\n\nstatic void NVSetClippingRectangle(struct fb_info *info, int x1, int y1,\n\t\t\t\t   int x2, int y2)\n{\n\tstruct nvidia_par *par = info->par;\n\tint h = y2 - y1 + 1;\n\tint w = x2 - x1 + 1;\n\n\tNVDmaStart(info, par, CLIP_POINT, 2);\n\tNVDmaNext(par, (y1 << 16) | x1);\n\tNVDmaNext(par, (h << 16) | w);\n}\n\nvoid NVResetGraphics(struct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\tu32 surfaceFormat, patternFormat, rectFormat, lineFormat;\n\tint pitch, i;\n\n\tpitch = info->fix.line_length;\n\n\tpar->dmaBase = (u32 __iomem *) (&par->FbStart[par->FbUsableSize]);\n\n\tfor (i = 0; i < SKIPS; i++)\n\t\tNV_WR32(&par->dmaBase[i], 0, 0x00000000);\n\n\tNV_WR32(&par->dmaBase[0x0 + SKIPS], 0, 0x00040000);\n\tNV_WR32(&par->dmaBase[0x1 + SKIPS], 0, 0x80000010);\n\tNV_WR32(&par->dmaBase[0x2 + SKIPS], 0, 0x00042000);\n\tNV_WR32(&par->dmaBase[0x3 + SKIPS], 0, 0x80000011);\n\tNV_WR32(&par->dmaBase[0x4 + SKIPS], 0, 0x00044000);\n\tNV_WR32(&par->dmaBase[0x5 + SKIPS], 0, 0x80000012);\n\tNV_WR32(&par->dmaBase[0x6 + SKIPS], 0, 0x00046000);\n\tNV_WR32(&par->dmaBase[0x7 + SKIPS], 0, 0x80000013);\n\tNV_WR32(&par->dmaBase[0x8 + SKIPS], 0, 0x00048000);\n\tNV_WR32(&par->dmaBase[0x9 + SKIPS], 0, 0x80000014);\n\tNV_WR32(&par->dmaBase[0xA + SKIPS], 0, 0x0004A000);\n\tNV_WR32(&par->dmaBase[0xB + SKIPS], 0, 0x80000015);\n\tNV_WR32(&par->dmaBase[0xC + SKIPS], 0, 0x0004C000);\n\tNV_WR32(&par->dmaBase[0xD + SKIPS], 0, 0x80000016);\n\tNV_WR32(&par->dmaBase[0xE + SKIPS], 0, 0x0004E000);\n\tNV_WR32(&par->dmaBase[0xF + SKIPS], 0, 0x80000017);\n\n\tpar->dmaPut = 0;\n\tpar->dmaCurrent = 16 + SKIPS;\n\tpar->dmaMax = 8191;\n\tpar->dmaFree = par->dmaMax - par->dmaCurrent;\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 32:\n\tcase 24:\n\t\tsurfaceFormat = SURFACE_FORMAT_DEPTH24;\n\t\tpatternFormat = PATTERN_FORMAT_DEPTH24;\n\t\trectFormat = RECT_FORMAT_DEPTH24;\n\t\tlineFormat = LINE_FORMAT_DEPTH24;\n\t\tbreak;\n\tcase 16:\n\t\tsurfaceFormat = SURFACE_FORMAT_DEPTH16;\n\t\tpatternFormat = PATTERN_FORMAT_DEPTH16;\n\t\trectFormat = RECT_FORMAT_DEPTH16;\n\t\tlineFormat = LINE_FORMAT_DEPTH16;\n\t\tbreak;\n\tdefault:\n\t\tsurfaceFormat = SURFACE_FORMAT_DEPTH8;\n\t\tpatternFormat = PATTERN_FORMAT_DEPTH8;\n\t\trectFormat = RECT_FORMAT_DEPTH8;\n\t\tlineFormat = LINE_FORMAT_DEPTH8;\n\t\tbreak;\n\t}\n\n\tNVDmaStart(info, par, SURFACE_FORMAT, 4);\n\tNVDmaNext(par, surfaceFormat);\n\tNVDmaNext(par, pitch | (pitch << 16));\n\tNVDmaNext(par, 0);\n\tNVDmaNext(par, 0);\n\n\tNVDmaStart(info, par, PATTERN_FORMAT, 1);\n\tNVDmaNext(par, patternFormat);\n\n\tNVDmaStart(info, par, RECT_FORMAT, 1);\n\tNVDmaNext(par, rectFormat);\n\n\tNVDmaStart(info, par, LINE_FORMAT, 1);\n\tNVDmaNext(par, lineFormat);\n\n\tpar->currentRop = ~0;\t \n\tNVSetRopSolid(info, ROP_COPY, ~0);\n\n\tNVSetClippingRectangle(info, 0, 0, info->var.xres_virtual,\n\t\t\t       info->var.yres_virtual);\n\n\tNVDmaKickoff(par);\n}\n\nint nvidiafb_sync(struct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn 0;\n\n\tif (!par->lockup)\n\t\tNVFlush(info);\n\n\tif (!par->lockup)\n\t\tNVSync(info);\n\n\treturn 0;\n}\n\nvoid nvidiafb_copyarea(struct fb_info *info, const struct fb_copyarea *region)\n{\n\tstruct nvidia_par *par = info->par;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\n\tif (par->lockup) {\n\t\tcfb_copyarea(info, region);\n\t\treturn;\n\t}\n\n\tNVDmaStart(info, par, BLIT_POINT_SRC, 3);\n\tNVDmaNext(par, (region->sy << 16) | region->sx);\n\tNVDmaNext(par, (region->dy << 16) | region->dx);\n\tNVDmaNext(par, (region->height << 16) | region->width);\n\n\tNVDmaKickoff(par);\n}\n\nvoid nvidiafb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct nvidia_par *par = info->par;\n\tu32 color;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\n\tif (par->lockup) {\n\t\tcfb_fillrect(info, rect);\n\t\treturn;\n\t}\n\n\tif (info->var.bits_per_pixel == 8)\n\t\tcolor = rect->color;\n\telse\n\t\tcolor = ((u32 *) info->pseudo_palette)[rect->color];\n\n\tif (rect->rop != ROP_COPY)\n\t\tNVSetRopSolid(info, rect->rop, ~0);\n\n\tNVDmaStart(info, par, RECT_SOLID_COLOR, 1);\n\tNVDmaNext(par, color);\n\n\tNVDmaStart(info, par, RECT_SOLID_RECTS(0), 2);\n\tNVDmaNext(par, (rect->dx << 16) | rect->dy);\n\tNVDmaNext(par, (rect->width << 16) | rect->height);\n\n\tNVDmaKickoff(par);\n\n\tif (rect->rop != ROP_COPY)\n\t\tNVSetRopSolid(info, ROP_COPY, ~0);\n}\n\nstatic void nvidiafb_mono_color_expand(struct fb_info *info,\n\t\t\t\t       const struct fb_image *image)\n{\n\tstruct nvidia_par *par = info->par;\n\tu32 fg, bg, mask = ~(~0 >> (32 - info->var.bits_per_pixel));\n\tu32 dsize, width, *data = (u32 *) image->data, tmp;\n\tint j, k = 0;\n\n\twidth = (image->width + 31) & ~31;\n\tdsize = (width * image->height) >> 5;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tfg = image->fg_color | mask;\n\t\tbg = image->bg_color | mask;\n\t} else {\n\t\tfg = ((u32 *) info->pseudo_palette)[image->fg_color] | mask;\n\t\tbg = ((u32 *) info->pseudo_palette)[image->bg_color] | mask;\n\t}\n\n\tNVDmaStart(info, par, RECT_EXPAND_TWO_COLOR_CLIP, 7);\n\tNVDmaNext(par, (image->dy << 16) | (image->dx & 0xffff));\n\tNVDmaNext(par, ((image->dy + image->height) << 16) |\n\t\t  ((image->dx + image->width) & 0xffff));\n\tNVDmaNext(par, bg);\n\tNVDmaNext(par, fg);\n\tNVDmaNext(par, (image->height << 16) | width);\n\tNVDmaNext(par, (image->height << 16) | width);\n\tNVDmaNext(par, (image->dy << 16) | (image->dx & 0xffff));\n\n\twhile (dsize >= RECT_EXPAND_TWO_COLOR_DATA_MAX_DWORDS) {\n\t\tNVDmaStart(info, par, RECT_EXPAND_TWO_COLOR_DATA(0),\n\t\t\t   RECT_EXPAND_TWO_COLOR_DATA_MAX_DWORDS);\n\n\t\tfor (j = RECT_EXPAND_TWO_COLOR_DATA_MAX_DWORDS; j--;) {\n\t\t\ttmp = data[k++];\n\t\t\treverse_order(&tmp);\n\t\t\tNVDmaNext(par, tmp);\n\t\t}\n\n\t\tdsize -= RECT_EXPAND_TWO_COLOR_DATA_MAX_DWORDS;\n\t}\n\n\tif (dsize) {\n\t\tNVDmaStart(info, par, RECT_EXPAND_TWO_COLOR_DATA(0), dsize);\n\n\t\tfor (j = dsize; j--;) {\n\t\t\ttmp = data[k++];\n\t\t\treverse_order(&tmp);\n\t\t\tNVDmaNext(par, tmp);\n\t\t}\n\t}\n\n\tNVDmaKickoff(par);\n}\n\nvoid nvidiafb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct nvidia_par *par = info->par;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\n\tif (image->depth == 1 && !par->lockup)\n\t\tnvidiafb_mono_color_expand(info, image);\n\telse\n\t\tcfb_imageblit(info, image);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}