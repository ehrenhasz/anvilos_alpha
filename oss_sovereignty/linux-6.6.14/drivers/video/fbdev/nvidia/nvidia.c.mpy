{
  "module_name": "nvidia.c",
  "hash_id": "4927173266cab461d31003767c9942e3ee2a56559174b77b0d8449a03c1e0949",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/nvidia/nvidia.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/backlight.h>\n#ifdef CONFIG_BOOTX_TEXT\n#include <asm/btext.h>\n#endif\n\n#include \"nv_local.h\"\n#include \"nv_type.h\"\n#include \"nv_proto.h\"\n#include \"nv_dma.h\"\n\n#ifdef CONFIG_FB_NVIDIA_DEBUG\n#define NVTRACE          printk\n#else\n#define NVTRACE          if (0) printk\n#endif\n\n#define NVTRACE_ENTER(...)  NVTRACE(\"%s START\\n\", __func__)\n#define NVTRACE_LEAVE(...)  NVTRACE(\"%s END\\n\", __func__)\n\n#ifdef CONFIG_FB_NVIDIA_DEBUG\n#define assert(expr) \\\n\tif (!(expr)) { \\\n\tprintk( \"Assertion failed! %s,%s,%s,line=%d\\n\",\\\n\t#expr,__FILE__,__func__,__LINE__); \\\n\tBUG(); \\\n\t}\n#else\n#define assert(expr)\n#endif\n\n#define PFX \"nvidiafb: \"\n\n \n#define MAX_CURS\t\t32\n\nstatic const struct pci_device_id nvidiafb_pci_tbl[] = {\n\t{PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t PCI_BASE_CLASS_DISPLAY << 16, 0xff0000, 0},\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, nvidiafb_pci_tbl);\n\n \nstatic int flatpanel = -1;\t \nstatic int fpdither = -1;\nstatic int forceCRTC = -1;\nstatic int hwcur = 0;\nstatic int noaccel = 0;\nstatic int noscale = 0;\nstatic int paneltweak = 0;\nstatic int vram = 0;\nstatic int bpp = 8;\nstatic int reverse_i2c;\nstatic bool nomtrr = false;\nstatic int backlight = IS_BUILTIN(CONFIG_PMAC_BACKLIGHT);\n\nstatic char *mode_option = NULL;\n\nstatic struct fb_fix_screeninfo nvidiafb_fix = {\n\t.type = FB_TYPE_PACKED_PIXELS,\n\t.xpanstep = 8,\n\t.ypanstep = 1,\n};\n\nstatic struct fb_var_screeninfo nvidiafb_default_var = {\n\t.xres = 640,\n\t.yres = 480,\n\t.xres_virtual = 640,\n\t.yres_virtual = 480,\n\t.bits_per_pixel = 8,\n\t.red = {0, 8, 0},\n\t.green = {0, 8, 0},\n\t.blue = {0, 8, 0},\n\t.transp = {0, 0, 0},\n\t.activate = FB_ACTIVATE_NOW,\n\t.height = -1,\n\t.width = -1,\n\t.pixclock = 39721,\n\t.left_margin = 40,\n\t.right_margin = 24,\n\t.upper_margin = 32,\n\t.lower_margin = 11,\n\t.hsync_len = 96,\n\t.vsync_len = 2,\n\t.vmode = FB_VMODE_NONINTERLACED\n};\n\nstatic void nvidiafb_load_cursor_image(struct nvidia_par *par, u8 * data8,\n\t\t\t\t       u16 bg, u16 fg, u32 w, u32 h)\n{\n\tu32 *data = (u32 *) data8;\n\tint i, j, k = 0;\n\tu32 b, tmp;\n\n\tw = (w + 1) & ~1;\n\n\tfor (i = 0; i < h; i++) {\n\t\tb = *data++;\n\t\treverse_order(&b);\n\n\t\tfor (j = 0; j < w / 2; j++) {\n\t\t\ttmp = 0;\n#if defined (__BIG_ENDIAN)\n\t\t\ttmp = (b & (1 << 31)) ? fg << 16 : bg << 16;\n\t\t\tb <<= 1;\n\t\t\ttmp |= (b & (1 << 31)) ? fg : bg;\n\t\t\tb <<= 1;\n#else\n\t\t\ttmp = (b & 1) ? fg : bg;\n\t\t\tb >>= 1;\n\t\t\ttmp |= (b & 1) ? fg << 16 : bg << 16;\n\t\t\tb >>= 1;\n#endif\n\t\t\tNV_WR32(&par->CURSOR[k++], 0, tmp);\n\t\t}\n\t\tk += (MAX_CURS - w) / 2;\n\t}\n}\n\nstatic void nvidia_write_clut(struct nvidia_par *par,\n\t\t\t      u8 regnum, u8 red, u8 green, u8 blue)\n{\n\tNVWriteDacMask(par, 0xff);\n\tNVWriteDacWriteAddr(par, regnum);\n\tNVWriteDacData(par, red);\n\tNVWriteDacData(par, green);\n\tNVWriteDacData(par, blue);\n}\n\nstatic void nvidia_read_clut(struct nvidia_par *par,\n\t\t\t     u8 regnum, u8 * red, u8 * green, u8 * blue)\n{\n\tNVWriteDacMask(par, 0xff);\n\tNVWriteDacReadAddr(par, regnum);\n\t*red = NVReadDacData(par);\n\t*green = NVReadDacData(par);\n\t*blue = NVReadDacData(par);\n}\n\nstatic int nvidia_panel_tweak(struct nvidia_par *par,\n\t\t\t      struct _riva_hw_state *state)\n{\n\tint tweak = 0;\n\n\tif (par->paneltweak) {\n\t\ttweak = par->paneltweak;\n\t} else {\n\t\t \n\t\tif (((par->Chipset & 0xffff) == 0x0328) && (state->bpp == 32)) {\n\t\t\t \n\t\t\ttweak = -1;\n\t\t}\n\n\t\tif ((par->Chipset & 0xfff0) == 0x0310)\n\t\t\ttweak = 1;\n\t\t \n\t}\n\n\treturn tweak;\n}\n\nstatic void nvidia_screen_off(struct nvidia_par *par, int on)\n{\n\tunsigned char tmp;\n\n\tif (on) {\n\t\t \n\t\ttmp = NVReadSeq(par, 0x01);\n\n\t\tNVWriteSeq(par, 0x00, 0x01);\t\t \n\t\tNVWriteSeq(par, 0x01, tmp | 0x20);\t \n\t} else {\n\t\t \n\n\t\ttmp = NVReadSeq(par, 0x01);\n\n\t\tNVWriteSeq(par, 0x01, tmp & ~0x20);\t \n\t\tNVWriteSeq(par, 0x00, 0x03);\t\t \n\t}\n}\n\nstatic void nvidia_save_vga(struct nvidia_par *par,\n\t\t\t    struct _riva_hw_state *state)\n{\n\tint i;\n\n\tNVTRACE_ENTER();\n\tNVLockUnlock(par, 0);\n\n\tNVUnloadStateExt(par, state);\n\n\tstate->misc_output = NVReadMiscOut(par);\n\n\tfor (i = 0; i < NUM_CRT_REGS; i++)\n\t\tstate->crtc[i] = NVReadCrtc(par, i);\n\n\tfor (i = 0; i < NUM_ATC_REGS; i++)\n\t\tstate->attr[i] = NVReadAttr(par, i);\n\n\tfor (i = 0; i < NUM_GRC_REGS; i++)\n\t\tstate->gra[i] = NVReadGr(par, i);\n\n\tfor (i = 0; i < NUM_SEQ_REGS; i++)\n\t\tstate->seq[i] = NVReadSeq(par, i);\n\tNVTRACE_LEAVE();\n}\n\n#undef DUMP_REG\n\nstatic void nvidia_write_regs(struct nvidia_par *par,\n\t\t\t      struct _riva_hw_state *state)\n{\n\tint i;\n\n\tNVTRACE_ENTER();\n\n\tNVLoadStateExt(par, state);\n\n\tNVWriteMiscOut(par, state->misc_output);\n\n\tfor (i = 1; i < NUM_SEQ_REGS; i++) {\n#ifdef DUMP_REG\n\t\tprintk(\" SEQ[%02x] = %08x\\n\", i, state->seq[i]);\n#endif\n\t\tNVWriteSeq(par, i, state->seq[i]);\n\t}\n\n\t \n\tNVWriteCrtc(par, 0x11, state->crtc[0x11] & ~0x80);\n\n\tfor (i = 0; i < NUM_CRT_REGS; i++) {\n\t\tswitch (i) {\n\t\tcase 0x19:\n\t\tcase 0x20 ... 0x40:\n\t\t\tbreak;\n\t\tdefault:\n#ifdef DUMP_REG\n\t\t\tprintk(\"CRTC[%02x] = %08x\\n\", i, state->crtc[i]);\n#endif\n\t\t\tNVWriteCrtc(par, i, state->crtc[i]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < NUM_GRC_REGS; i++) {\n#ifdef DUMP_REG\n\t\tprintk(\" GRA[%02x] = %08x\\n\", i, state->gra[i]);\n#endif\n\t\tNVWriteGr(par, i, state->gra[i]);\n\t}\n\n\tfor (i = 0; i < NUM_ATC_REGS; i++) {\n#ifdef DUMP_REG\n\t\tprintk(\"ATTR[%02x] = %08x\\n\", i, state->attr[i]);\n#endif\n\t\tNVWriteAttr(par, i, state->attr[i]);\n\t}\n\n\tNVTRACE_LEAVE();\n}\n\nstatic int nvidia_calc_regs(struct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\tstruct _riva_hw_state *state = &par->ModeReg;\n\tint i, depth = fb_get_color_depth(&info->var, &info->fix);\n\tint h_display = info->var.xres / 8 - 1;\n\tint h_start = (info->var.xres + info->var.right_margin) / 8 - 1;\n\tint h_end = (info->var.xres + info->var.right_margin +\n\t\t     info->var.hsync_len) / 8 - 1;\n\tint h_total = (info->var.xres + info->var.right_margin +\n\t\t       info->var.hsync_len + info->var.left_margin) / 8 - 5;\n\tint h_blank_s = h_display;\n\tint h_blank_e = h_total + 4;\n\tint v_display = info->var.yres - 1;\n\tint v_start = info->var.yres + info->var.lower_margin - 1;\n\tint v_end = (info->var.yres + info->var.lower_margin +\n\t\t     info->var.vsync_len) - 1;\n\tint v_total = (info->var.yres + info->var.lower_margin +\n\t\t       info->var.vsync_len + info->var.upper_margin) - 2;\n\tint v_blank_s = v_display;\n\tint v_blank_e = v_total + 1;\n\n\t \n\n\tif (info->var.vmode & FB_VMODE_INTERLACED)\n\t\tv_total |= 1;\n\n\tif (par->FlatPanel == 1) {\n\t\tv_start = v_total - 3;\n\t\tv_end = v_total - 2;\n\t\tv_blank_s = v_start;\n\t\th_start = h_total - 5;\n\t\th_end = h_total - 2;\n\t\th_blank_e = h_total + 4;\n\t}\n\n\tstate->crtc[0x0] = Set8Bits(h_total);\n\tstate->crtc[0x1] = Set8Bits(h_display);\n\tstate->crtc[0x2] = Set8Bits(h_blank_s);\n\tstate->crtc[0x3] = SetBitField(h_blank_e, 4: 0, 4:0)\n\t\t| SetBit(7);\n\tstate->crtc[0x4] = Set8Bits(h_start);\n\tstate->crtc[0x5] = SetBitField(h_blank_e, 5: 5, 7:7)\n\t\t| SetBitField(h_end, 4: 0, 4:0);\n\tstate->crtc[0x6] = SetBitField(v_total, 7: 0, 7:0);\n\tstate->crtc[0x7] = SetBitField(v_total, 8: 8, 0:0)\n\t\t| SetBitField(v_display, 8: 8, 1:1)\n\t\t| SetBitField(v_start, 8: 8, 2:2)\n\t\t| SetBitField(v_blank_s, 8: 8, 3:3)\n\t\t| SetBit(4)\n\t\t| SetBitField(v_total, 9: 9, 5:5)\n\t\t| SetBitField(v_display, 9: 9, 6:6)\n\t\t| SetBitField(v_start, 9: 9, 7:7);\n\tstate->crtc[0x9] = SetBitField(v_blank_s, 9: 9, 5:5)\n\t\t| SetBit(6)\n\t\t| ((info->var.vmode & FB_VMODE_DOUBLE) ? 0x80 : 0x00);\n\tstate->crtc[0x10] = Set8Bits(v_start);\n\tstate->crtc[0x11] = SetBitField(v_end, 3: 0, 3:0) | SetBit(5);\n\tstate->crtc[0x12] = Set8Bits(v_display);\n\tstate->crtc[0x13] = ((info->var.xres_virtual / 8) *\n\t\t\t     (info->var.bits_per_pixel / 8));\n\tstate->crtc[0x15] = Set8Bits(v_blank_s);\n\tstate->crtc[0x16] = Set8Bits(v_blank_e);\n\n\tstate->attr[0x10] = 0x01;\n\n\tif (par->Television)\n\t\tstate->attr[0x11] = 0x00;\n\n\tstate->screen = SetBitField(h_blank_e, 6: 6, 4:4)\n\t\t| SetBitField(v_blank_s, 10: 10, 3:3)\n\t\t| SetBitField(v_start, 10: 10, 2:2)\n\t\t| SetBitField(v_display, 10: 10, 1:1)\n\t\t| SetBitField(v_total, 10: 10, 0:0);\n\n\tstate->horiz = SetBitField(h_total, 8: 8, 0:0)\n\t\t| SetBitField(h_display, 8: 8, 1:1)\n\t\t| SetBitField(h_blank_s, 8: 8, 2:2)\n\t\t| SetBitField(h_start, 8: 8, 3:3);\n\n\tstate->extra = SetBitField(v_total, 11: 11, 0:0)\n\t\t| SetBitField(v_display, 11: 11, 2:2)\n\t\t| SetBitField(v_start, 11: 11, 4:4)\n\t\t| SetBitField(v_blank_s, 11: 11, 6:6);\n\n\tif (info->var.vmode & FB_VMODE_INTERLACED) {\n\t\th_total = (h_total >> 1) & ~1;\n\t\tstate->interlace = Set8Bits(h_total);\n\t\tstate->horiz |= SetBitField(h_total, 8: 8, 4:4);\n\t} else {\n\t\tstate->interlace = 0xff;\t \n\t}\n\n\t \n\n\tif (depth < 24)\n\t\ti = depth;\n\telse\n\t\ti = 32;\n\n\tif (par->Architecture >= NV_ARCH_10)\n\t\tpar->CURSOR = (volatile u32 __iomem *)(info->screen_base +\n\t\t\t\t\t\t       par->CursorStart);\n\n\tif (info->var.sync & FB_SYNC_HOR_HIGH_ACT)\n\t\tstate->misc_output &= ~0x40;\n\telse\n\t\tstate->misc_output |= 0x40;\n\tif (info->var.sync & FB_SYNC_VERT_HIGH_ACT)\n\t\tstate->misc_output &= ~0x80;\n\telse\n\t\tstate->misc_output |= 0x80;\n\n\tNVCalcStateExt(par, state, i, info->var.xres_virtual,\n\t\t       info->var.xres, info->var.yres_virtual,\n\t\t       1000000000 / info->var.pixclock, info->var.vmode);\n\n\tstate->scale = NV_RD32(par->PRAMDAC, 0x00000848) & 0xfff000ff;\n\tif (par->FlatPanel == 1) {\n\t\tstate->pixel |= (1 << 7);\n\n\t\tif (!par->fpScaler || (par->fpWidth <= info->var.xres)\n\t\t    || (par->fpHeight <= info->var.yres)) {\n\t\t\tstate->scale |= (1 << 8);\n\t\t}\n\n\t\tif (!par->crtcSync_read) {\n\t\t\tstate->crtcSync = NV_RD32(par->PRAMDAC, 0x0828);\n\t\t\tpar->crtcSync_read = 1;\n\t\t}\n\n\t\tpar->PanelTweak = nvidia_panel_tweak(par, state);\n\t}\n\n\tstate->vpll = state->pll;\n\tstate->vpll2 = state->pll;\n\tstate->vpllB = state->pllB;\n\tstate->vpll2B = state->pllB;\n\n\tVGA_WR08(par->PCIO, 0x03D4, 0x1C);\n\tstate->fifo = VGA_RD08(par->PCIO, 0x03D5) & ~(1<<5);\n\n\tif (par->CRTCnumber) {\n\t\tstate->head = NV_RD32(par->PCRTC0, 0x00000860) & ~0x00001000;\n\t\tstate->head2 = NV_RD32(par->PCRTC0, 0x00002860) | 0x00001000;\n\t\tstate->crtcOwner = 3;\n\t\tstate->pllsel |= 0x20000800;\n\t\tstate->vpll = NV_RD32(par->PRAMDAC0, 0x00000508);\n\t\tif (par->twoStagePLL)\n\t\t\tstate->vpllB = NV_RD32(par->PRAMDAC0, 0x00000578);\n\t} else if (par->twoHeads) {\n\t\tstate->head = NV_RD32(par->PCRTC0, 0x00000860) | 0x00001000;\n\t\tstate->head2 = NV_RD32(par->PCRTC0, 0x00002860) & ~0x00001000;\n\t\tstate->crtcOwner = 0;\n\t\tstate->vpll2 = NV_RD32(par->PRAMDAC0, 0x0520);\n\t\tif (par->twoStagePLL)\n\t\t\tstate->vpll2B = NV_RD32(par->PRAMDAC0, 0x057C);\n\t}\n\n\tstate->cursorConfig = 0x00000100;\n\n\tif (info->var.vmode & FB_VMODE_DOUBLE)\n\t\tstate->cursorConfig |= (1 << 4);\n\n\tif (par->alphaCursor) {\n\t\tif ((par->Chipset & 0x0ff0) != 0x0110)\n\t\t\tstate->cursorConfig |= 0x04011000;\n\t\telse\n\t\t\tstate->cursorConfig |= 0x14011000;\n\t\tstate->general |= (1 << 29);\n\t} else\n\t\tstate->cursorConfig |= 0x02000000;\n\n\tif (par->twoHeads) {\n\t\tif ((par->Chipset & 0x0ff0) == 0x0110) {\n\t\t\tstate->dither = NV_RD32(par->PRAMDAC, 0x0528) &\n\t\t\t    ~0x00010000;\n\t\t\tif (par->FPDither)\n\t\t\t\tstate->dither |= 0x00010000;\n\t\t} else {\n\t\t\tstate->dither = NV_RD32(par->PRAMDAC, 0x083C) & ~1;\n\t\t\tif (par->FPDither)\n\t\t\t\tstate->dither |= 1;\n\t\t}\n\t}\n\n\tstate->timingH = 0;\n\tstate->timingV = 0;\n\tstate->displayV = info->var.xres;\n\n\treturn 0;\n}\n\nstatic void nvidia_init_vga(struct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\tstruct _riva_hw_state *state = &par->ModeReg;\n\tint i;\n\n\tfor (i = 0; i < 0x10; i++)\n\t\tstate->attr[i] = i;\n\tstate->attr[0x10] = 0x41;\n\tstate->attr[0x11] = 0xff;\n\tstate->attr[0x12] = 0x0f;\n\tstate->attr[0x13] = 0x00;\n\tstate->attr[0x14] = 0x00;\n\n\tmemset(state->crtc, 0x00, NUM_CRT_REGS);\n\tstate->crtc[0x0a] = 0x20;\n\tstate->crtc[0x17] = 0xe3;\n\tstate->crtc[0x18] = 0xff;\n\tstate->crtc[0x28] = 0x40;\n\n\tmemset(state->gra, 0x00, NUM_GRC_REGS);\n\tstate->gra[0x05] = 0x40;\n\tstate->gra[0x06] = 0x05;\n\tstate->gra[0x07] = 0x0f;\n\tstate->gra[0x08] = 0xff;\n\n\tstate->seq[0x00] = 0x03;\n\tstate->seq[0x01] = 0x01;\n\tstate->seq[0x02] = 0x0f;\n\tstate->seq[0x03] = 0x00;\n\tstate->seq[0x04] = 0x0e;\n\n\tstate->misc_output = 0xeb;\n}\n\nstatic int nvidiafb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\tstruct nvidia_par *par = info->par;\n\tu8 data[MAX_CURS * MAX_CURS / 8];\n\tint i, set = cursor->set;\n\tu16 fg, bg;\n\n\tif (cursor->image.width > MAX_CURS || cursor->image.height > MAX_CURS)\n\t\treturn -ENXIO;\n\n\tNVShowHideCursor(par, 0);\n\n\tif (par->cursor_reset) {\n\t\tset = FB_CUR_SETALL;\n\t\tpar->cursor_reset = 0;\n\t}\n\n\tif (set & FB_CUR_SETSIZE)\n\t\tmemset_io(par->CURSOR, 0, MAX_CURS * MAX_CURS * 2);\n\n\tif (set & FB_CUR_SETPOS) {\n\t\tu32 xx, yy, temp;\n\n\t\tyy = cursor->image.dy - info->var.yoffset;\n\t\txx = cursor->image.dx - info->var.xoffset;\n\t\ttemp = xx & 0xFFFF;\n\t\ttemp |= yy << 16;\n\n\t\tNV_WR32(par->PRAMDAC, 0x0000300, temp);\n\t}\n\n\tif (set & (FB_CUR_SETSHAPE | FB_CUR_SETCMAP | FB_CUR_SETIMAGE)) {\n\t\tu32 bg_idx = cursor->image.bg_color;\n\t\tu32 fg_idx = cursor->image.fg_color;\n\t\tu32 s_pitch = (cursor->image.width + 7) >> 3;\n\t\tu32 d_pitch = MAX_CURS / 8;\n\t\tu8 *dat = (u8 *) cursor->image.data;\n\t\tu8 *msk = (u8 *) cursor->mask;\n\t\tu8 *src;\n\n\t\tsrc = kmalloc_array(s_pitch, cursor->image.height, GFP_ATOMIC);\n\n\t\tif (src) {\n\t\t\tswitch (cursor->rop) {\n\t\t\tcase ROP_XOR:\n\t\t\t\tfor (i = 0; i < s_pitch * cursor->image.height; i++)\n\t\t\t\t\tsrc[i] = dat[i] ^ msk[i];\n\t\t\t\tbreak;\n\t\t\tcase ROP_COPY:\n\t\t\tdefault:\n\t\t\t\tfor (i = 0; i < s_pitch * cursor->image.height; i++)\n\t\t\t\t\tsrc[i] = dat[i] & msk[i];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfb_pad_aligned_buffer(data, d_pitch, src, s_pitch,\n\t\t\t\t\t\tcursor->image.height);\n\n\t\t\tbg = ((info->cmap.red[bg_idx] & 0xf8) << 7) |\n\t\t\t    ((info->cmap.green[bg_idx] & 0xf8) << 2) |\n\t\t\t    ((info->cmap.blue[bg_idx] & 0xf8) >> 3) | 1 << 15;\n\n\t\t\tfg = ((info->cmap.red[fg_idx] & 0xf8) << 7) |\n\t\t\t    ((info->cmap.green[fg_idx] & 0xf8) << 2) |\n\t\t\t    ((info->cmap.blue[fg_idx] & 0xf8) >> 3) | 1 << 15;\n\n\t\t\tNVLockUnlock(par, 0);\n\n\t\t\tnvidiafb_load_cursor_image(par, data, bg, fg,\n\t\t\t\t\t\t   cursor->image.width,\n\t\t\t\t\t\t   cursor->image.height);\n\t\t\tkfree(src);\n\t\t}\n\t}\n\n\tif (cursor->enable)\n\t\tNVShowHideCursor(par, 1);\n\n\treturn 0;\n}\n\nstatic struct fb_ops nvidia_fb_ops;\n\nstatic int nvidiafb_set_par(struct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\n\tNVTRACE_ENTER();\n\n\tNVLockUnlock(par, 1);\n\tif (!par->FlatPanel || !par->twoHeads)\n\t\tpar->FPDither = 0;\n\n\tif (par->FPDither < 0) {\n\t\tif ((par->Chipset & 0x0ff0) == 0x0110)\n\t\t\tpar->FPDither = !!(NV_RD32(par->PRAMDAC, 0x0528)\n\t\t\t\t\t   & 0x00010000);\n\t\telse\n\t\t\tpar->FPDither = !!(NV_RD32(par->PRAMDAC, 0x083C) & 1);\n\t\tprintk(KERN_INFO PFX \"Flat panel dithering %s\\n\",\n\t\t       par->FPDither ? \"enabled\" : \"disabled\");\n\t}\n\n\tinfo->fix.visual = (info->var.bits_per_pixel == 8) ?\n\t    FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\n\n\tnvidia_init_vga(info);\n\tnvidia_calc_regs(info);\n\n\tNVLockUnlock(par, 0);\n\tif (par->twoHeads) {\n\t\tVGA_WR08(par->PCIO, 0x03D4, 0x44);\n\t\tVGA_WR08(par->PCIO, 0x03D5, par->ModeReg.crtcOwner);\n\t\tNVLockUnlock(par, 0);\n\t}\n\n\tnvidia_screen_off(par, 1);\n\n\tnvidia_write_regs(par, &par->ModeReg);\n\tNVSetStartAddress(par, 0);\n\n#if defined (__BIG_ENDIAN)\n\t \n\t{\n\t\tunsigned char tmp;\n\n\t\tVGA_WR08(par->PCIO, 0x3d4, 0x46);\n\t\ttmp = VGA_RD08(par->PCIO, 0x3d5);\n\t\ttmp |= (1 << 7);\n\t\tVGA_WR08(par->PCIO, 0x3d5, tmp);\n    }\n#endif\n\n\tinfo->fix.line_length = (info->var.xres_virtual *\n\t\t\t\t info->var.bits_per_pixel) >> 3;\n\tif (info->var.accel_flags) {\n\t\tnvidia_fb_ops.fb_imageblit = nvidiafb_imageblit;\n\t\tnvidia_fb_ops.fb_fillrect = nvidiafb_fillrect;\n\t\tnvidia_fb_ops.fb_copyarea = nvidiafb_copyarea;\n\t\tnvidia_fb_ops.fb_sync = nvidiafb_sync;\n\t\tinfo->pixmap.scan_align = 4;\n\t\tinfo->flags &= ~FBINFO_HWACCEL_DISABLED;\n\t\tinfo->flags |= FBINFO_READS_FAST;\n\t\tNVResetGraphics(info);\n\t} else {\n\t\tnvidia_fb_ops.fb_imageblit = cfb_imageblit;\n\t\tnvidia_fb_ops.fb_fillrect = cfb_fillrect;\n\t\tnvidia_fb_ops.fb_copyarea = cfb_copyarea;\n\t\tnvidia_fb_ops.fb_sync = NULL;\n\t\tinfo->pixmap.scan_align = 1;\n\t\tinfo->flags |= FBINFO_HWACCEL_DISABLED;\n\t\tinfo->flags &= ~FBINFO_READS_FAST;\n\t}\n\n\tpar->cursor_reset = 1;\n\n\tnvidia_screen_off(par, 0);\n\n#ifdef CONFIG_BOOTX_TEXT\n\t \n\tbtext_update_display(info->fix.smem_start,\n\t\t\t     info->var.xres, info->var.yres,\n\t\t\t     info->var.bits_per_pixel, info->fix.line_length);\n#endif\n\n\tNVLockUnlock(par, 0);\n\tNVTRACE_LEAVE();\n\treturn 0;\n}\n\nstatic int nvidiafb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t      unsigned blue, unsigned transp,\n\t\t\t      struct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\tint i;\n\n\tNVTRACE_ENTER();\n\tif (regno >= (1 << info->var.green.length))\n\t\treturn -EINVAL;\n\n\tif (info->var.grayscale) {\n\t\t \n\t\tred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n\t}\n\n\tif (regno < 16 && info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\t((u32 *) info->pseudo_palette)[regno] =\n\t\t    (regno << info->var.red.offset) |\n\t\t    (regno << info->var.green.offset) |\n\t\t    (regno << info->var.blue.offset);\n\t}\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\t \n\t\tnvidia_write_clut(par, regno, red >> 8, green >> 8, blue >> 8);\n\t\tbreak;\n\tcase 16:\n\t\tif (info->var.green.length == 5) {\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tnvidia_write_clut(par, regno * 8 + i, red >> 8,\n\t\t\t\t\t\t  green >> 8, blue >> 8);\n\t\t\t}\n\t\t} else {\n\t\t\tu8 r, g, b;\n\n\t\t\tif (regno < 32) {\n\t\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\t\tnvidia_write_clut(par, regno * 8 + i,\n\t\t\t\t\t\t\t  red >> 8, green >> 8,\n\t\t\t\t\t\t\t  blue >> 8);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnvidia_read_clut(par, regno * 4, &r, &g, &b);\n\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tnvidia_write_clut(par, regno * 4 + i, r,\n\t\t\t\t\t\t  green >> 8, b);\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tnvidia_write_clut(par, regno, red >> 8, green >> 8, blue >> 8);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tNVTRACE_LEAVE();\n\treturn 0;\n}\n\nstatic int nvidiafb_check_var(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\tint memlen, vramlen, mode_valid = 0;\n\tint pitch, err = 0;\n\n\tNVTRACE_ENTER();\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\n\tvar->xres &= ~7;\n\n\tif (var->bits_per_pixel <= 8)\n\t\tvar->bits_per_pixel = 8;\n\telse if (var->bits_per_pixel <= 16)\n\t\tvar->bits_per_pixel = 16;\n\telse\n\t\tvar->bits_per_pixel = 32;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 16:\n\t\tvar->green.length = (var->green.length < 6) ? 5 : 6;\n\t\tvar->red.length = 5;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.length = 6 - var->green.length;\n\t\tvar->blue.offset = 0;\n\t\tvar->green.offset = 5;\n\t\tvar->red.offset = 5 + var->green.length;\n\t\tvar->transp.offset = (5 + var->red.offset) & 15;\n\t\tbreak;\n\tcase 32:\t\t \n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.length = 8;\n\t\tvar->transp.offset = 24;\n\t\tbreak;\n\t}\n\n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.msb_right = 0;\n\tvar->transp.msb_right = 0;\n\n\tif (!info->monspecs.hfmax || !info->monspecs.vfmax ||\n\t    !info->monspecs.dclkmax || !fb_validate_mode(var, info))\n\t\tmode_valid = 1;\n\n\t \n\tif (!mode_valid && info->monspecs.gtf) {\n\t\tif (!fb_get_mode(FB_MAXTIMINGS, 0, var, info))\n\t\t\tmode_valid = 1;\n\t}\n\n\tif (!mode_valid) {\n\t\tconst struct fb_videomode *mode;\n\n\t\tmode = fb_find_best_mode(var, &info->modelist);\n\t\tif (mode) {\n\t\t\tfb_videomode_to_var(var, mode);\n\t\t\tmode_valid = 1;\n\t\t}\n\t}\n\n\tif (!mode_valid && info->monspecs.modedb_len)\n\t\treturn -EINVAL;\n\n\t \n\tif (par->fpWidth && par->fpHeight && (par->fpWidth < var->xres ||\n\t\t\t\t\t      par->fpHeight < var->yres)) {\n\t\tconst struct fb_videomode *mode;\n\n\t\tvar->xres = par->fpWidth;\n\t\tvar->yres = par->fpHeight;\n\n\t\tmode = fb_find_best_mode(var, &info->modelist);\n\t\tif (!mode) {\n\t\t\tprintk(KERN_ERR PFX \"mode out of range of flat \"\n\t\t\t       \"panel dimensions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfb_videomode_to_var(var, mode);\n\t}\n\n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres_virtual = var->yres;\n\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\n\tvar->xres_virtual = (var->xres_virtual + 63) & ~63;\n\n\tvramlen = info->screen_size;\n\tpitch = ((var->xres_virtual * var->bits_per_pixel) + 7) / 8;\n\tmemlen = pitch * var->yres_virtual;\n\n\tif (memlen > vramlen) {\n\t\tvar->yres_virtual = vramlen / pitch;\n\n\t\tif (var->yres_virtual < var->yres) {\n\t\t\tvar->yres_virtual = var->yres;\n\t\t\tvar->xres_virtual = vramlen / var->yres_virtual;\n\t\t\tvar->xres_virtual /= var->bits_per_pixel / 8;\n\t\t\tvar->xres_virtual &= ~63;\n\t\t\tpitch = (var->xres_virtual *\n\t\t\t\t var->bits_per_pixel + 7) / 8;\n\t\t\tmemlen = pitch * var->yres;\n\n\t\t\tif (var->xres_virtual < var->xres) {\n\t\t\t\tprintk(\"nvidiafb: required video memory, \"\n\t\t\t\t       \"%d bytes, for %dx%d-%d (virtual) \"\n\t\t\t\t       \"is out of range\\n\",\n\t\t\t\t       memlen, var->xres_virtual,\n\t\t\t\t       var->yres_virtual, var->bits_per_pixel);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (var->accel_flags) {\n\t\tif (var->yres_virtual > 0x7fff)\n\t\t\tvar->yres_virtual = 0x7fff;\n\t\tif (var->xres_virtual > 0x7fff)\n\t\t\tvar->xres_virtual = 0x7fff;\n\t}\n\n\tvar->xres_virtual &= ~63;\n\n\tNVTRACE_LEAVE();\n\n\treturn err;\n}\n\nstatic int nvidiafb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\tu32 total;\n\n\ttotal = var->yoffset * info->fix.line_length + var->xoffset;\n\n\tNVSetStartAddress(par, total);\n\n\treturn 0;\n}\n\nstatic int nvidiafb_blank(int blank, struct fb_info *info)\n{\n\tstruct nvidia_par *par = info->par;\n\tunsigned char tmp, vesa;\n\n\ttmp = NVReadSeq(par, 0x01) & ~0x20;\t \n\tvesa = NVReadCrtc(par, 0x1a) & ~0xc0;\t \n\n\tNVTRACE_ENTER();\n\n\tif (blank)\n\t\ttmp |= 0x20;\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\n\tcase FB_BLANK_NORMAL:\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tvesa |= 0x80;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tvesa |= 0x40;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tvesa |= 0xc0;\n\t\tbreak;\n\t}\n\n\tNVWriteSeq(par, 0x01, tmp);\n\tNVWriteCrtc(par, 0x1a, vesa);\n\n\tNVTRACE_LEAVE();\n\n\treturn 0;\n}\n\n \n#ifdef CONFIG_X86\nstatic void save_vga_x86(struct nvidia_par *par)\n{\n\tstruct resource *res= &par->pci_dev->resource[PCI_ROM_RESOURCE];\n\n\tif (res && res->flags & IORESOURCE_ROM_SHADOW) {\n\t\tmemset(&par->vgastate, 0, sizeof(par->vgastate));\n\t\tpar->vgastate.flags = VGA_SAVE_MODE | VGA_SAVE_FONTS |\n\t\t\tVGA_SAVE_CMAP;\n\t\tsave_vga(&par->vgastate);\n\t}\n}\n\nstatic void restore_vga_x86(struct nvidia_par *par)\n{\n\tstruct resource *res= &par->pci_dev->resource[PCI_ROM_RESOURCE];\n\n\tif (res && res->flags & IORESOURCE_ROM_SHADOW)\n\t\trestore_vga(&par->vgastate);\n}\n#else\n#define save_vga_x86(x) do {} while (0)\n#define restore_vga_x86(x) do {} while (0)\n#endif  \n\nstatic int nvidiafb_open(struct fb_info *info, int user)\n{\n\tstruct nvidia_par *par = info->par;\n\n\tif (!par->open_count) {\n\t\tsave_vga_x86(par);\n\t\tnvidia_save_vga(par, &par->initial_state);\n\t}\n\n\tpar->open_count++;\n\treturn 0;\n}\n\nstatic int nvidiafb_release(struct fb_info *info, int user)\n{\n\tstruct nvidia_par *par = info->par;\n\tint err = 0;\n\n\tif (!par->open_count) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (par->open_count == 1) {\n\t\tnvidia_write_regs(par, &par->initial_state);\n\t\trestore_vga_x86(par);\n\t}\n\n\tpar->open_count--;\ndone:\n\treturn err;\n}\n\nstatic struct fb_ops nvidia_fb_ops = {\n\t.owner          = THIS_MODULE,\n\t.fb_open        = nvidiafb_open,\n\t.fb_release     = nvidiafb_release,\n\t.fb_check_var   = nvidiafb_check_var,\n\t.fb_set_par     = nvidiafb_set_par,\n\t.fb_setcolreg   = nvidiafb_setcolreg,\n\t.fb_pan_display = nvidiafb_pan_display,\n\t.fb_blank       = nvidiafb_blank,\n\t.fb_fillrect    = nvidiafb_fillrect,\n\t.fb_copyarea    = nvidiafb_copyarea,\n\t.fb_imageblit   = nvidiafb_imageblit,\n\t.fb_cursor      = nvidiafb_cursor,\n\t.fb_sync        = nvidiafb_sync,\n};\n\nstatic int nvidiafb_suspend_late(struct device *dev, pm_message_t mesg)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct nvidia_par *par = info->par;\n\n\tif (mesg.event == PM_EVENT_PRETHAW)\n\t\tmesg.event = PM_EVENT_FREEZE;\n\tconsole_lock();\n\tpar->pm_state = mesg.event;\n\n\tif (mesg.event & PM_EVENT_SLEEP) {\n\t\tfb_set_suspend(info, 1);\n\t\tnvidiafb_blank(FB_BLANK_POWERDOWN, info);\n\t\tnvidia_write_regs(par, &par->SavedReg);\n\t}\n\tdev->power.power_state = mesg;\n\n\tconsole_unlock();\n\treturn 0;\n}\n\nstatic int __maybe_unused nvidiafb_suspend(struct device *dev)\n{\n\treturn nvidiafb_suspend_late(dev, PMSG_SUSPEND);\n}\n\nstatic int __maybe_unused nvidiafb_hibernate(struct device *dev)\n{\n\treturn nvidiafb_suspend_late(dev, PMSG_HIBERNATE);\n}\n\nstatic int __maybe_unused nvidiafb_freeze(struct device *dev)\n{\n\treturn nvidiafb_suspend_late(dev, PMSG_FREEZE);\n}\n\nstatic int __maybe_unused nvidiafb_resume(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct nvidia_par *par = info->par;\n\n\tconsole_lock();\n\n\tpar->pm_state = PM_EVENT_ON;\n\tnvidiafb_set_par(info);\n\tfb_set_suspend (info, 0);\n\tnvidiafb_blank(FB_BLANK_UNBLANK, info);\n\n\tconsole_unlock();\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops nvidiafb_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= nvidiafb_suspend,\n\t.resume\t\t= nvidiafb_resume,\n\t.freeze\t\t= nvidiafb_freeze,\n\t.thaw\t\t= nvidiafb_resume,\n\t.poweroff\t= nvidiafb_hibernate,\n\t.restore\t= nvidiafb_resume,\n#endif  \n};\n\nstatic int nvidia_set_fbinfo(struct fb_info *info)\n{\n\tstruct fb_monspecs *specs = &info->monspecs;\n\tstruct fb_videomode modedb;\n\tstruct nvidia_par *par = info->par;\n\tint lpitch;\n\n\tNVTRACE_ENTER();\n\tinfo->flags =\n\t      FBINFO_HWACCEL_IMAGEBLIT\n\t    | FBINFO_HWACCEL_FILLRECT\n\t    | FBINFO_HWACCEL_COPYAREA\n\t    | FBINFO_HWACCEL_YPAN;\n\n\tfb_videomode_to_modelist(info->monspecs.modedb,\n\t\t\t\t info->monspecs.modedb_len, &info->modelist);\n\tfb_var_to_videomode(&modedb, &nvidiafb_default_var);\n\n\tswitch (bpp) {\n\tcase 0 ... 8:\n\t\tbpp = 8;\n\t\tbreak;\n\tcase 9 ... 16:\n\t\tbpp = 16;\n\t\tbreak;\n\tdefault:\n\t\tbpp = 32;\n\t\tbreak;\n\t}\n\n\tif (specs->modedb != NULL) {\n\t\tconst struct fb_videomode *mode;\n\n\t\tmode = fb_find_best_display(specs, &info->modelist);\n\t\tfb_videomode_to_var(&nvidiafb_default_var, mode);\n\t\tnvidiafb_default_var.bits_per_pixel = bpp;\n\t} else if (par->fpWidth && par->fpHeight) {\n\t\tchar buf[16];\n\n\t\tmemset(buf, 0, 16);\n\t\tsnprintf(buf, 15, \"%dx%dMR\", par->fpWidth, par->fpHeight);\n\t\tfb_find_mode(&nvidiafb_default_var, info, buf, specs->modedb,\n\t\t\t     specs->modedb_len, &modedb, bpp);\n\t}\n\n\tif (mode_option)\n\t\tfb_find_mode(&nvidiafb_default_var, info, mode_option,\n\t\t\t     specs->modedb, specs->modedb_len, &modedb, bpp);\n\n\tinfo->var = nvidiafb_default_var;\n\tinfo->fix.visual = (info->var.bits_per_pixel == 8) ?\n\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\n\tinfo->pseudo_palette = par->pseudo_palette;\n\tfb_alloc_cmap(&info->cmap, 256, 0);\n\tfb_destroy_modedb(info->monspecs.modedb);\n\tinfo->monspecs.modedb = NULL;\n\n\t \n\tlpitch = info->var.xres_virtual *\n\t\t((info->var.bits_per_pixel + 7) >> 3);\n\tinfo->var.yres_virtual = info->screen_size / lpitch;\n\n\tinfo->pixmap.scan_align = 4;\n\tinfo->pixmap.buf_align = 4;\n\tinfo->pixmap.access_align = 32;\n\tinfo->pixmap.size = 8 * 1024;\n\tinfo->pixmap.flags = FB_PIXMAP_SYSTEM;\n\n\tif (!hwcur)\n\t    nvidia_fb_ops.fb_cursor = NULL;\n\n\tinfo->var.accel_flags = (!noaccel);\n\n\tswitch (par->Architecture) {\n\tcase NV_ARCH_04:\n\t\tinfo->fix.accel = FB_ACCEL_NV4;\n\t\tbreak;\n\tcase NV_ARCH_10:\n\t\tinfo->fix.accel = FB_ACCEL_NV_10;\n\t\tbreak;\n\tcase NV_ARCH_20:\n\t\tinfo->fix.accel = FB_ACCEL_NV_20;\n\t\tbreak;\n\tcase NV_ARCH_30:\n\t\tinfo->fix.accel = FB_ACCEL_NV_30;\n\t\tbreak;\n\tcase NV_ARCH_40:\n\t\tinfo->fix.accel = FB_ACCEL_NV_40;\n\t\tbreak;\n\t}\n\n\tNVTRACE_LEAVE();\n\n\treturn nvidiafb_check_var(&info->var, info);\n}\n\nstatic u32 nvidia_get_chipset(struct pci_dev *pci_dev,\n\t\t\t      volatile u32 __iomem *REGS)\n{\n\tu32 id = (pci_dev->vendor << 16) | pci_dev->device;\n\n\tprintk(KERN_INFO PFX \"Device ID: %x \\n\", id);\n\n\tif ((id & 0xfff0) == 0x00f0 ||\n\t    (id & 0xfff0) == 0x02e0) {\n\t\t \n\t\tid = NV_RD32(REGS, 0x1800);\n\n\t\tif ((id & 0x0000ffff) == 0x000010DE)\n\t\t\tid = 0x10DE0000 | (id >> 16);\n\t\telse if ((id & 0xffff0000) == 0xDE100000)  \n\t\t\tid = 0x10DE0000 | ((id << 8) & 0x0000ff00) |\n                            ((id >> 8) & 0x000000ff);\n\t\tprintk(KERN_INFO PFX \"Subsystem ID: %x \\n\", id);\n\t}\n\n\treturn id;\n}\n\nstatic u32 nvidia_get_arch(u32 Chipset)\n{\n\tu32 arch = 0;\n\n\tswitch (Chipset & 0x0ff0) {\n\tcase 0x0100:\t\t \n\tcase 0x0110:\t\t \n\tcase 0x0150:\t\t \n\tcase 0x0170:\t\t \n\tcase 0x0180:\t\t \n\tcase 0x01A0:\t\t \n\tcase 0x01F0:\t\t \n\t\tarch = NV_ARCH_10;\n\t\tbreak;\n\tcase 0x0200:\t\t \n\tcase 0x0250:\t\t \n\tcase 0x0280:\t\t \n\t\tarch = NV_ARCH_20;\n\t\tbreak;\n\tcase 0x0300:\t\t \n\tcase 0x0310:\t\t \n\tcase 0x0320:\t\t \n\tcase 0x0330:\t\t \n\tcase 0x0340:\t\t \n\t\tarch = NV_ARCH_30;\n\t\tbreak;\n\tcase 0x0040:\t\t \n\tcase 0x00C0:\t\t \n\tcase 0x0120:\t\t \n\tcase 0x0140:\t\t \n\tcase 0x0160:\t\t \n\tcase 0x01D0:\t\t \n\tcase 0x0090:\t\t \n\tcase 0x0210:\t\t \n\tcase 0x0220:\t\t \n\tcase 0x0240:\t\t \n\tcase 0x0290:\t\t \n\tcase 0x0390:\t\t \n\tcase 0x03D0:\n\t\tarch = NV_ARCH_40;\n\t\tbreak;\n\tcase 0x0020:\t\t \n\t\tarch = NV_ARCH_04;\n\t\tbreak;\n\tdefault:\t\t \n\t\tbreak;\n\t}\n\n\treturn arch;\n}\n\nstatic int nvidiafb_probe(struct pci_dev *pd, const struct pci_device_id *ent)\n{\n\tstruct nvidia_par *par;\n\tstruct fb_info *info;\n\tunsigned short cmd;\n\tint ret;\n\tvolatile u32 __iomem *REGS;\n\tint Chipset;\n\tu32 Architecture;\n\n\tNVTRACE_ENTER();\n\tassert(pd != NULL);\n\n\tif (pci_enable_device(pd)) {\n\t\tprintk(KERN_ERR PFX \"cannot enable PCI device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpci_read_config_word(pd, PCI_COMMAND, &cmd);\n\tcmd |= (PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\tpci_write_config_word(pd, PCI_COMMAND, cmd);\n\n\tnvidiafb_fix.mmio_start = pci_resource_start(pd, 0);\n\tnvidiafb_fix.mmio_len = pci_resource_len(pd, 0);\n\n\tREGS = ioremap(nvidiafb_fix.mmio_start, nvidiafb_fix.mmio_len);\n\tif (!REGS) {\n\t\tprintk(KERN_ERR PFX \"cannot ioremap MMIO base\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tChipset = nvidia_get_chipset(pd, REGS);\n\tArchitecture = nvidia_get_arch(Chipset);\n\tif (Architecture == 0) {\n\t\tprintk(KERN_ERR PFX \"unknown NV_ARCH\\n\");\n\t\tgoto err_out;\n\t}\n\n\tret = aperture_remove_conflicting_pci_devices(pd, \"nvidiafb\");\n\tif (ret)\n\t\tgoto err_out;\n\n\tinfo = framebuffer_alloc(sizeof(struct nvidia_par), &pd->dev);\n\tif (!info)\n\t\tgoto err_out;\n\n\tpar = info->par;\n\tpar->pci_dev = pd;\n\tinfo->pixmap.addr = kzalloc(8 * 1024, GFP_KERNEL);\n\n\tif (info->pixmap.addr == NULL)\n\t\tgoto err_out_kfree;\n\n\tif (pci_request_regions(pd, \"nvidiafb\")) {\n\t\tprintk(KERN_ERR PFX \"cannot request PCI regions\\n\");\n\t\tgoto err_out_enable;\n\t}\n\n\tpar->FlatPanel = flatpanel;\n\tif (flatpanel == 1)\n\t\tprintk(KERN_INFO PFX \"flatpanel support enabled\\n\");\n\tpar->FPDither = fpdither;\n\n\tpar->CRTCnumber = forceCRTC;\n\tpar->FpScale = (!noscale);\n\tpar->paneltweak = paneltweak;\n\tpar->reverse_i2c = reverse_i2c;\n\n\tnvidiafb_fix.smem_start = pci_resource_start(pd, 1);\n\n\tpar->REGS = REGS;\n\n\tpar->Chipset = Chipset;\n\tpar->Architecture = Architecture;\n\n\tsprintf(nvidiafb_fix.id, \"NV%x\", (pd->device & 0x0ff0) >> 4);\n\n\tif (NVCommonSetup(info))\n\t\tgoto err_out_free_base0;\n\n\tpar->FbAddress = nvidiafb_fix.smem_start;\n\tpar->FbMapSize = par->RamAmountKBytes * 1024;\n\tif (vram && vram * 1024 * 1024 < par->FbMapSize)\n\t\tpar->FbMapSize = vram * 1024 * 1024;\n\n\t \n\tif (par->FbMapSize > 64 * 1024 * 1024)\n\t\tpar->FbMapSize = 64 * 1024 * 1024;\n\n\tif(par->Architecture >= NV_ARCH_40)\n  \t        par->FbUsableSize = par->FbMapSize - (560 * 1024);\n\telse\n\t\tpar->FbUsableSize = par->FbMapSize - (128 * 1024);\n\tpar->ScratchBufferSize = (par->Architecture < NV_ARCH_10) ? 8 * 1024 :\n\t    16 * 1024;\n\tpar->ScratchBufferStart = par->FbUsableSize - par->ScratchBufferSize;\n\tpar->CursorStart = par->FbUsableSize + (32 * 1024);\n\n\tinfo->screen_base = ioremap_wc(nvidiafb_fix.smem_start,\n\t\t\t\t       par->FbMapSize);\n\tinfo->screen_size = par->FbUsableSize;\n\tnvidiafb_fix.smem_len = par->RamAmountKBytes * 1024;\n\n\tif (!info->screen_base) {\n\t\tprintk(KERN_ERR PFX \"cannot ioremap FB base\\n\");\n\t\tgoto err_out_free_base1;\n\t}\n\n\tpar->FbStart = info->screen_base;\n\n\tif (!nomtrr)\n\t\tpar->wc_cookie = arch_phys_wc_add(nvidiafb_fix.smem_start,\n\t\t\t\t\t\t  par->RamAmountKBytes * 1024);\n\n\tinfo->fbops = &nvidia_fb_ops;\n\tinfo->fix = nvidiafb_fix;\n\n\tif (nvidia_set_fbinfo(info) < 0) {\n\t\tprintk(KERN_ERR PFX \"error setting initial video mode\\n\");\n\t\tgoto err_out_iounmap_fb;\n\t}\n\n\tnvidia_save_vga(par, &par->SavedReg);\n\n\tpci_set_drvdata(pd, info);\n\n\tif (register_framebuffer(info) < 0) {\n\t\tprintk(KERN_ERR PFX \"error registering nVidia framebuffer\\n\");\n\t\tgoto err_out_iounmap_fb;\n\t}\n\n\tif (backlight)\n\t\tnvidia_bl_init(par);\n\n\tprintk(KERN_INFO PFX\n\t       \"PCI nVidia %s framebuffer (%dMB @ 0x%lX)\\n\",\n\t       info->fix.id,\n\t       par->FbMapSize / (1024 * 1024), info->fix.smem_start);\n\n\tNVTRACE_LEAVE();\n\treturn 0;\n\nerr_out_iounmap_fb:\n\tiounmap(info->screen_base);\nerr_out_free_base1:\n\tfb_destroy_modedb(info->monspecs.modedb);\n\tnvidia_delete_i2c_busses(par);\nerr_out_free_base0:\n\tpci_release_regions(pd);\nerr_out_enable:\n\tkfree(info->pixmap.addr);\nerr_out_kfree:\n\tframebuffer_release(info);\nerr_out:\n\tiounmap(REGS);\n\treturn -ENODEV;\n}\n\nstatic void nvidiafb_remove(struct pci_dev *pd)\n{\n\tstruct fb_info *info = pci_get_drvdata(pd);\n\tstruct nvidia_par *par = info->par;\n\n\tNVTRACE_ENTER();\n\n\tnvidia_bl_exit(par);\n\tunregister_framebuffer(info);\n\n\tarch_phys_wc_del(par->wc_cookie);\n\tiounmap(info->screen_base);\n\tfb_destroy_modedb(info->monspecs.modedb);\n\tnvidia_delete_i2c_busses(par);\n\tiounmap(par->REGS);\n\tpci_release_regions(pd);\n\tkfree(info->pixmap.addr);\n\tframebuffer_release(info);\n\tNVTRACE_LEAVE();\n}\n\n \n\n#ifndef MODULE\nstatic int nvidiafb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tNVTRACE_ENTER();\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!strncmp(this_opt, \"forceCRTC\", 9)) {\n\t\t\tchar *p;\n\n\t\t\tp = this_opt + 9;\n\t\t\tif (!*p || !*(++p))\n\t\t\t\tcontinue;\n\t\t\tforceCRTC = *p - '0';\n\t\t\tif (forceCRTC < 0 || forceCRTC > 1)\n\t\t\t\tforceCRTC = -1;\n\t\t} else if (!strncmp(this_opt, \"flatpanel\", 9)) {\n\t\t\tflatpanel = 1;\n\t\t} else if (!strncmp(this_opt, \"hwcur\", 5)) {\n\t\t\thwcur = 1;\n\t\t} else if (!strncmp(this_opt, \"noaccel\", 6)) {\n\t\t\tnoaccel = 1;\n\t\t} else if (!strncmp(this_opt, \"noscale\", 7)) {\n\t\t\tnoscale = 1;\n\t\t} else if (!strncmp(this_opt, \"reverse_i2c\", 11)) {\n\t\t\treverse_i2c = 1;\n\t\t} else if (!strncmp(this_opt, \"paneltweak:\", 11)) {\n\t\t\tpaneltweak = simple_strtoul(this_opt+11, NULL, 0);\n\t\t} else if (!strncmp(this_opt, \"vram:\", 5)) {\n\t\t\tvram = simple_strtoul(this_opt+5, NULL, 0);\n\t\t} else if (!strncmp(this_opt, \"backlight:\", 10)) {\n\t\t\tbacklight = simple_strtoul(this_opt+10, NULL, 0);\n\t\t} else if (!strncmp(this_opt, \"nomtrr\", 6)) {\n\t\t\tnomtrr = true;\n\t\t} else if (!strncmp(this_opt, \"fpdither:\", 9)) {\n\t\t\tfpdither = simple_strtol(this_opt+9, NULL, 0);\n\t\t} else if (!strncmp(this_opt, \"bpp:\", 4)) {\n\t\t\tbpp = simple_strtoul(this_opt+4, NULL, 0);\n\t\t} else\n\t\t\tmode_option = this_opt;\n\t}\n\tNVTRACE_LEAVE();\n\treturn 0;\n}\n#endif\t\t\t\t \n\nstatic struct pci_driver nvidiafb_driver = {\n\t.name      = \"nvidiafb\",\n\t.id_table  = nvidiafb_pci_tbl,\n\t.probe     = nvidiafb_probe,\n\t.driver.pm = &nvidiafb_pm_ops,\n\t.remove    = nvidiafb_remove,\n};\n\n \n\nstatic int nvidiafb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"nvidiafb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"nvidiafb\", &option))\n\t\treturn -ENODEV;\n\tnvidiafb_setup(option);\n#endif\n\treturn pci_register_driver(&nvidiafb_driver);\n}\n\nmodule_init(nvidiafb_init);\n\nstatic void __exit nvidiafb_exit(void)\n{\n\tpci_unregister_driver(&nvidiafb_driver);\n}\n\nmodule_exit(nvidiafb_exit);\n\nmodule_param(flatpanel, int, 0);\nMODULE_PARM_DESC(flatpanel,\n\t\t \"Enables experimental flat panel support for some chipsets. \"\n\t\t \"(0=disabled, 1=enabled, -1=autodetect) (default=-1)\");\nmodule_param(fpdither, int, 0);\nMODULE_PARM_DESC(fpdither,\n\t\t \"Enables dithering of flat panel for 6 bits panels. \"\n\t\t \"(0=disabled, 1=enabled, -1=autodetect) (default=-1)\");\nmodule_param(hwcur, int, 0);\nMODULE_PARM_DESC(hwcur,\n\t\t \"Enables hardware cursor implementation. (0 or 1=enabled) \"\n\t\t \"(default=0)\");\nmodule_param(noaccel, int, 0);\nMODULE_PARM_DESC(noaccel,\n\t\t \"Disables hardware acceleration. (0 or 1=disable) \"\n\t\t \"(default=0)\");\nmodule_param(noscale, int, 0);\nMODULE_PARM_DESC(noscale,\n\t\t \"Disables screen scaling. (0 or 1=disable) \"\n\t\t \"(default=0, do scaling)\");\nmodule_param(paneltweak, int, 0);\nMODULE_PARM_DESC(paneltweak,\n\t\t \"Tweak display settings for flatpanels. \"\n\t\t \"(default=0, no tweaks)\");\nmodule_param(forceCRTC, int, 0);\nMODULE_PARM_DESC(forceCRTC,\n\t\t \"Forces usage of a particular CRTC in case autodetection \"\n\t\t \"fails. (0 or 1) (default=autodetect)\");\nmodule_param(vram, int, 0);\nMODULE_PARM_DESC(vram,\n\t\t \"amount of framebuffer memory to remap in MiB\"\n\t\t \"(default=0 - remap entire memory)\");\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Specify initial video mode\");\nmodule_param(bpp, int, 0);\nMODULE_PARM_DESC(bpp, \"pixel width in bits\"\n\t\t \"(default=8)\");\nmodule_param(reverse_i2c, int, 0);\nMODULE_PARM_DESC(reverse_i2c, \"reverse port assignment of the i2c bus\");\nmodule_param(nomtrr, bool, false);\nMODULE_PARM_DESC(nomtrr, \"Disables MTRR support (0 or 1=disabled) \"\n\t\t \"(default=0)\");\n\nMODULE_AUTHOR(\"Antonino Daplas\");\nMODULE_DESCRIPTION(\"Framebuffer driver for nVidia graphics chipset\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}