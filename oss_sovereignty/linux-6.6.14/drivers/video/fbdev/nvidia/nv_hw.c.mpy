{
  "module_name": "nv_hw.c",
  "hash_id": "e8293f0761b881cd033387e11bfa3d0dfa4af0eb0b312b7ef682737cb08e7bdf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/nvidia/nv_hw.c",
  "human_readable_source": "  \n\n \n\n \n\n#include <linux/pci.h>\n#include \"nv_type.h\"\n#include \"nv_local.h\"\n#include \"nv_proto.h\"\n\nvoid NVLockUnlock(struct nvidia_par *par, int Lock)\n{\n\tu8 cr11;\n\n\tVGA_WR08(par->PCIO, 0x3D4, 0x1F);\n\tVGA_WR08(par->PCIO, 0x3D5, Lock ? 0x99 : 0x57);\n\n\tVGA_WR08(par->PCIO, 0x3D4, 0x11);\n\tcr11 = VGA_RD08(par->PCIO, 0x3D5);\n\tif (Lock)\n\t\tcr11 |= 0x80;\n\telse\n\t\tcr11 &= ~0x80;\n\tVGA_WR08(par->PCIO, 0x3D5, cr11);\n}\n\nint NVShowHideCursor(struct nvidia_par *par, int ShowHide)\n{\n\tint cur = par->CurrentState->cursor1;\n\n\tpar->CurrentState->cursor1 = (par->CurrentState->cursor1 & 0xFE) |\n\t    (ShowHide & 0x01);\n\tVGA_WR08(par->PCIO, 0x3D4, 0x31);\n\tVGA_WR08(par->PCIO, 0x3D5, par->CurrentState->cursor1);\n\n\tif (par->Architecture == NV_ARCH_40)\n\t\tNV_WR32(par->PRAMDAC, 0x0300, NV_RD32(par->PRAMDAC, 0x0300));\n\n\treturn (cur & 0x01);\n}\n\n \n\ntypedef struct {\n\tint graphics_lwm;\n\tint video_lwm;\n\tint graphics_burst_size;\n\tint video_burst_size;\n\tint valid;\n} nv4_fifo_info;\n\ntypedef struct {\n\tint pclk_khz;\n\tint mclk_khz;\n\tint nvclk_khz;\n\tchar mem_page_miss;\n\tchar mem_latency;\n\tint memory_width;\n\tchar enable_video;\n\tchar gr_during_vid;\n\tchar pix_bpp;\n\tchar mem_aligned;\n\tchar enable_mp;\n} nv4_sim_state;\n\ntypedef struct {\n\tint graphics_lwm;\n\tint video_lwm;\n\tint graphics_burst_size;\n\tint video_burst_size;\n\tint valid;\n} nv10_fifo_info;\n\ntypedef struct {\n\tint pclk_khz;\n\tint mclk_khz;\n\tint nvclk_khz;\n\tchar mem_page_miss;\n\tchar mem_latency;\n\tu32 memory_type;\n\tint memory_width;\n\tchar enable_video;\n\tchar gr_during_vid;\n\tchar pix_bpp;\n\tchar mem_aligned;\n\tchar enable_mp;\n} nv10_sim_state;\n\nstatic void nvGetClocks(struct nvidia_par *par, unsigned int *MClk,\n\t\t\tunsigned int *NVClk)\n{\n\tunsigned int pll, N, M, MB, NB, P;\n\n\tif (par->Architecture >= NV_ARCH_40) {\n\t\tpll = NV_RD32(par->PMC, 0x4020);\n\t\tP = (pll >> 16) & 0x07;\n\t\tpll = NV_RD32(par->PMC, 0x4024);\n\t\tM = pll & 0xFF;\n\t\tN = (pll >> 8) & 0xFF;\n\t\tif (((par->Chipset & 0xfff0) == 0x0290) ||\n\t\t    ((par->Chipset & 0xfff0) == 0x0390)) {\n\t\t\tMB = 1;\n\t\t\tNB = 1;\n\t\t} else {\n\t\t\tMB = (pll >> 16) & 0xFF;\n\t\t\tNB = (pll >> 24) & 0xFF;\n\t\t}\n\t\t*MClk = ((N * NB * par->CrystalFreqKHz) / (M * MB)) >> P;\n\n\t\tpll = NV_RD32(par->PMC, 0x4000);\n\t\tP = (pll >> 16) & 0x07;\n\t\tpll = NV_RD32(par->PMC, 0x4004);\n\t\tM = pll & 0xFF;\n\t\tN = (pll >> 8) & 0xFF;\n\t\tMB = (pll >> 16) & 0xFF;\n\t\tNB = (pll >> 24) & 0xFF;\n\n\t\t*NVClk = ((N * NB * par->CrystalFreqKHz) / (M * MB)) >> P;\n\t} else if (par->twoStagePLL) {\n\t\tpll = NV_RD32(par->PRAMDAC0, 0x0504);\n\t\tM = pll & 0xFF;\n\t\tN = (pll >> 8) & 0xFF;\n\t\tP = (pll >> 16) & 0x0F;\n\t\tpll = NV_RD32(par->PRAMDAC0, 0x0574);\n\t\tif (pll & 0x80000000) {\n\t\t\tMB = pll & 0xFF;\n\t\t\tNB = (pll >> 8) & 0xFF;\n\t\t} else {\n\t\t\tMB = 1;\n\t\t\tNB = 1;\n\t\t}\n\t\t*MClk = ((N * NB * par->CrystalFreqKHz) / (M * MB)) >> P;\n\n\t\tpll = NV_RD32(par->PRAMDAC0, 0x0500);\n\t\tM = pll & 0xFF;\n\t\tN = (pll >> 8) & 0xFF;\n\t\tP = (pll >> 16) & 0x0F;\n\t\tpll = NV_RD32(par->PRAMDAC0, 0x0570);\n\t\tif (pll & 0x80000000) {\n\t\t\tMB = pll & 0xFF;\n\t\t\tNB = (pll >> 8) & 0xFF;\n\t\t} else {\n\t\t\tMB = 1;\n\t\t\tNB = 1;\n\t\t}\n\t\t*NVClk = ((N * NB * par->CrystalFreqKHz) / (M * MB)) >> P;\n\t} else\n\t    if (((par->Chipset & 0x0ff0) == 0x0300) ||\n\t\t((par->Chipset & 0x0ff0) == 0x0330)) {\n\t\tpll = NV_RD32(par->PRAMDAC0, 0x0504);\n\t\tM = pll & 0x0F;\n\t\tN = (pll >> 8) & 0xFF;\n\t\tP = (pll >> 16) & 0x07;\n\t\tif (pll & 0x00000080) {\n\t\t\tMB = (pll >> 4) & 0x07;\n\t\t\tNB = (pll >> 19) & 0x1f;\n\t\t} else {\n\t\t\tMB = 1;\n\t\t\tNB = 1;\n\t\t}\n\t\t*MClk = ((N * NB * par->CrystalFreqKHz) / (M * MB)) >> P;\n\n\t\tpll = NV_RD32(par->PRAMDAC0, 0x0500);\n\t\tM = pll & 0x0F;\n\t\tN = (pll >> 8) & 0xFF;\n\t\tP = (pll >> 16) & 0x07;\n\t\tif (pll & 0x00000080) {\n\t\t\tMB = (pll >> 4) & 0x07;\n\t\t\tNB = (pll >> 19) & 0x1f;\n\t\t} else {\n\t\t\tMB = 1;\n\t\t\tNB = 1;\n\t\t}\n\t\t*NVClk = ((N * NB * par->CrystalFreqKHz) / (M * MB)) >> P;\n\t} else {\n\t\tpll = NV_RD32(par->PRAMDAC0, 0x0504);\n\t\tM = pll & 0xFF;\n\t\tN = (pll >> 8) & 0xFF;\n\t\tP = (pll >> 16) & 0x0F;\n\t\t*MClk = (N * par->CrystalFreqKHz / M) >> P;\n\n\t\tpll = NV_RD32(par->PRAMDAC0, 0x0500);\n\t\tM = pll & 0xFF;\n\t\tN = (pll >> 8) & 0xFF;\n\t\tP = (pll >> 16) & 0x0F;\n\t\t*NVClk = (N * par->CrystalFreqKHz / M) >> P;\n\t}\n}\n\nstatic void nv4CalcArbitration(nv4_fifo_info * fifo, nv4_sim_state * arb)\n{\n\tint data, pagemiss, cas, width, video_enable, bpp;\n\tint nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;\n\tint found, mclk_extra, mclk_loop, cbs, m1, p1;\n\tint mclk_freq, pclk_freq, nvclk_freq, mp_enable;\n\tint us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;\n\tint vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt, clwm;\n\n\tfifo->valid = 1;\n\tpclk_freq = arb->pclk_khz;\n\tmclk_freq = arb->mclk_khz;\n\tnvclk_freq = arb->nvclk_khz;\n\tpagemiss = arb->mem_page_miss;\n\tcas = arb->mem_latency;\n\twidth = arb->memory_width >> 6;\n\tvideo_enable = arb->enable_video;\n\tbpp = arb->pix_bpp;\n\tmp_enable = arb->enable_mp;\n\tclwm = 0;\n\tvlwm = 0;\n\tcbs = 128;\n\tpclks = 2;\n\tnvclks = 2;\n\tnvclks += 2;\n\tnvclks += 1;\n\tmclks = 5;\n\tmclks += 3;\n\tmclks += 1;\n\tmclks += cas;\n\tmclks += 1;\n\tmclks += 1;\n\tmclks += 1;\n\tmclks += 1;\n\tmclk_extra = 3;\n\tnvclks += 2;\n\tnvclks += 1;\n\tnvclks += 1;\n\tnvclks += 1;\n\tif (mp_enable)\n\t\tmclks += 4;\n\tnvclks += 0;\n\tpclks += 0;\n\tfound = 0;\n\tvbs = 0;\n\twhile (found != 1) {\n\t\tfifo->valid = 1;\n\t\tfound = 1;\n\t\tmclk_loop = mclks + mclk_extra;\n\t\tus_m = mclk_loop * 1000 * 1000 / mclk_freq;\n\t\tus_n = nvclks * 1000 * 1000 / nvclk_freq;\n\t\tus_p = nvclks * 1000 * 1000 / pclk_freq;\n\t\tif (video_enable) {\n\t\t\tvideo_drain_rate = pclk_freq * 2;\n\t\t\tcrtc_drain_rate = pclk_freq * bpp / 8;\n\t\t\tvpagemiss = 2;\n\t\t\tvpagemiss += 1;\n\t\t\tcrtpagemiss = 2;\n\t\t\tvpm_us =\n\t\t\t    (vpagemiss * pagemiss) * 1000 * 1000 / mclk_freq;\n\t\t\tif (nvclk_freq * 2 > mclk_freq * width)\n\t\t\t\tvideo_fill_us =\n\t\t\t\t    cbs * 1000 * 1000 / 16 / nvclk_freq;\n\t\t\telse\n\t\t\t\tvideo_fill_us =\n\t\t\t\t    cbs * 1000 * 1000 / (8 * width) /\n\t\t\t\t    mclk_freq;\n\t\t\tus_video = vpm_us + us_m + us_n + us_p + video_fill_us;\n\t\t\tvlwm = us_video * video_drain_rate / (1000 * 1000);\n\t\t\tvlwm++;\n\t\t\tvbs = 128;\n\t\t\tif (vlwm > 128)\n\t\t\t\tvbs = 64;\n\t\t\tif (vlwm > (256 - 64))\n\t\t\t\tvbs = 32;\n\t\t\tif (nvclk_freq * 2 > mclk_freq * width)\n\t\t\t\tvideo_fill_us =\n\t\t\t\t    vbs * 1000 * 1000 / 16 / nvclk_freq;\n\t\t\telse\n\t\t\t\tvideo_fill_us =\n\t\t\t\t    vbs * 1000 * 1000 / (8 * width) /\n\t\t\t\t    mclk_freq;\n\t\t\tcpm_us =\n\t\t\t    crtpagemiss * pagemiss * 1000 * 1000 / mclk_freq;\n\t\t\tus_crt =\n\t\t\t    us_video + video_fill_us + cpm_us + us_m + us_n +\n\t\t\t    us_p;\n\t\t\tclwm = us_crt * crtc_drain_rate / (1000 * 1000);\n\t\t\tclwm++;\n\t\t} else {\n\t\t\tcrtc_drain_rate = pclk_freq * bpp / 8;\n\t\t\tcrtpagemiss = 2;\n\t\t\tcrtpagemiss += 1;\n\t\t\tcpm_us =\n\t\t\t    crtpagemiss * pagemiss * 1000 * 1000 / mclk_freq;\n\t\t\tus_crt = cpm_us + us_m + us_n + us_p;\n\t\t\tclwm = us_crt * crtc_drain_rate / (1000 * 1000);\n\t\t\tclwm++;\n\t\t}\n\t\tm1 = clwm + cbs - 512;\n\t\tp1 = m1 * pclk_freq / mclk_freq;\n\t\tp1 = p1 * bpp / 8;\n\t\tif ((p1 < m1) && (m1 > 0)) {\n\t\t\tfifo->valid = 0;\n\t\t\tfound = 0;\n\t\t\tif (mclk_extra == 0)\n\t\t\t\tfound = 1;\n\t\t\tmclk_extra--;\n\t\t} else if (video_enable) {\n\t\t\tif ((clwm > 511) || (vlwm > 255)) {\n\t\t\t\tfifo->valid = 0;\n\t\t\t\tfound = 0;\n\t\t\t\tif (mclk_extra == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tmclk_extra--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (clwm > 519) {\n\t\t\t\tfifo->valid = 0;\n\t\t\t\tfound = 0;\n\t\t\t\tif (mclk_extra == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tmclk_extra--;\n\t\t\t}\n\t\t}\n\t\tif (clwm < 384)\n\t\t\tclwm = 384;\n\t\tif (vlwm < 128)\n\t\t\tvlwm = 128;\n\t\tdata = (int)(clwm);\n\t\tfifo->graphics_lwm = data;\n\t\tfifo->graphics_burst_size = 128;\n\t\tdata = (int)((vlwm + 15));\n\t\tfifo->video_lwm = data;\n\t\tfifo->video_burst_size = vbs;\n\t}\n}\n\nstatic void nv4UpdateArbitrationSettings(unsigned VClk,\n\t\t\t\t\t unsigned pixelDepth,\n\t\t\t\t\t unsigned *burst,\n\t\t\t\t\t unsigned *lwm, struct nvidia_par *par)\n{\n\tnv4_fifo_info fifo_data;\n\tnv4_sim_state sim_data;\n\tunsigned int MClk, NVClk, cfg1;\n\n\tnvGetClocks(par, &MClk, &NVClk);\n\n\tcfg1 = NV_RD32(par->PFB, 0x00000204);\n\tsim_data.pix_bpp = (char)pixelDepth;\n\tsim_data.enable_video = 0;\n\tsim_data.enable_mp = 0;\n\tsim_data.memory_width = (NV_RD32(par->PEXTDEV, 0x0000) & 0x10) ?\n\t    128 : 64;\n\tsim_data.mem_latency = (char)cfg1 & 0x0F;\n\tsim_data.mem_aligned = 1;\n\tsim_data.mem_page_miss =\n\t    (char)(((cfg1 >> 4) & 0x0F) + ((cfg1 >> 31) & 0x01));\n\tsim_data.gr_during_vid = 0;\n\tsim_data.pclk_khz = VClk;\n\tsim_data.mclk_khz = MClk;\n\tsim_data.nvclk_khz = NVClk;\n\tnv4CalcArbitration(&fifo_data, &sim_data);\n\tif (fifo_data.valid) {\n\t\tint b = fifo_data.graphics_burst_size >> 4;\n\t\t*burst = 0;\n\t\twhile (b >>= 1)\n\t\t\t(*burst)++;\n\t\t*lwm = fifo_data.graphics_lwm >> 3;\n\t}\n}\n\nstatic void nv10CalcArbitration(nv10_fifo_info * fifo, nv10_sim_state * arb)\n{\n\tint data, pagemiss, width, video_enable, bpp;\n\tint nvclks, mclks, pclks, vpagemiss, crtpagemiss;\n\tint nvclk_fill;\n\tint found, mclk_extra, mclk_loop, cbs, m1;\n\tint mclk_freq, pclk_freq, nvclk_freq, mp_enable;\n\tint us_m, us_m_min, us_n, us_p, crtc_drain_rate;\n\tint vus_m;\n\tint vpm_us, us_video, cpm_us, us_crt, clwm;\n\tint clwm_rnd_down;\n\tint m2us, us_pipe_min, p1clk, p2;\n\tint min_mclk_extra;\n\tint us_min_mclk_extra;\n\n\tfifo->valid = 1;\n\tpclk_freq = arb->pclk_khz;\t \n\tmclk_freq = arb->mclk_khz;\n\tnvclk_freq = arb->nvclk_khz;\n\tpagemiss = arb->mem_page_miss;\n\twidth = arb->memory_width / 64;\n\tvideo_enable = arb->enable_video;\n\tbpp = arb->pix_bpp;\n\tmp_enable = arb->enable_mp;\n\tclwm = 0;\n\n\tcbs = 512;\n\n\tpclks = 4;\t \n\n\tnvclks = 3;\t \n\tnvclks += 2;\t \n\t \n\tmclks = 1;\n\tmclks += 1;\t \n\tmclks += 5;\t \n\n\tmclks += 2;\t \n\tmclks += 2;\t \n\tmclks += 7;\t \n\n\t \n\tif (arb->memory_type == 0)\n\t\tif (arb->memory_width == 64)\t \n\t\t\tmclks += 4;\n\t\telse\n\t\t\tmclks += 2;\n\telse if (arb->memory_width == 64)\t \n\t\tmclks += 2;\n\telse\n\t\tmclks += 1;\n\n\tif ((!video_enable) && (arb->memory_width == 128)) {\n\t\tmclk_extra = (bpp == 32) ? 31 : 42;\t \n\t\tmin_mclk_extra = 17;\n\t} else {\n\t\tmclk_extra = (bpp == 32) ? 8 : 4;\t \n\t\t \n\tnvclks += 1;\n\tnvclks += 1;\t\t \n\tnvclks += 1;\t\t \n\tnvclks += 1;\t\t \n\n\tif (mp_enable)\n\t\tmclks += 4;\t \n\t \n\n\tnvclks += 0;\n\tpclks += 0;\n\tfound = 0;\n\twhile (found != 1) {\n\t\tfifo->valid = 1;\n\t\tfound = 1;\n\t\tmclk_loop = mclks + mclk_extra;\n\t\t \n\t\tus_m = mclk_loop * 1000 * 1000 / mclk_freq;\n\t\t \n\t\tus_m_min = mclks * 1000 * 1000 / mclk_freq;\n\t\tus_min_mclk_extra = min_mclk_extra * 1000 * 1000 / mclk_freq;\n\t\t \n\t\tus_n = nvclks * 1000 * 1000 / nvclk_freq;\n\t\t \n\t\tus_p = pclks * 1000 * 1000 / pclk_freq;\n\t\tus_pipe_min = us_m_min + us_n + us_p;\n\n\t\t \n\t\tvus_m = mclk_loop * 1000 * 1000 / mclk_freq;\n\n\t\tif (video_enable) {\n\t\t\tcrtc_drain_rate = pclk_freq * bpp / 8;\t \n\n\t\t\tvpagemiss = 1;\t \n\t\t\tvpagemiss += 1;\t \n\n\t\t\tcrtpagemiss = 2;\t \n\t\t\tif (mp_enable)\n\t\t\t\tcrtpagemiss += 1;\t \n\n\t\t\tvpm_us =\n\t\t\t    (vpagemiss * pagemiss) * 1000 * 1000 / mclk_freq;\n\n\t\t\t \n\t\t\tus_video = vpm_us + vus_m;\n\n\t\t\tcpm_us =\n\t\t\t    crtpagemiss * pagemiss * 1000 * 1000 / mclk_freq;\n\t\t\t \n\t\t\tus_crt = us_video\n\t\t\t    + cpm_us\t \n\t\t\t    + us_m + us_n + us_p\t \n\t\t\t    ;\n\n\t\t\tclwm = us_crt * crtc_drain_rate / (1000 * 1000);\n\t\t\t \n\t\t\tclwm++;\n\t\t} else {\n\t\t     \n\t\t\tcrtc_drain_rate = pclk_freq * bpp / 8;\n\n\t\t\tcrtpagemiss = 1;\t \n\t\t\tcrtpagemiss += 1;\t \n\t\t\tif (mp_enable)\n\t\t\t\tcrtpagemiss += 1;\t \n\t\t\tcpm_us =\n\t\t\t    crtpagemiss * pagemiss * 1000 * 1000 / mclk_freq;\n\t\t\tus_crt = cpm_us + us_m + us_n + us_p;\n\t\t\tclwm = us_crt * crtc_drain_rate / (1000 * 1000);\n\t\t\t \n\t\t\tclwm++;\n\n\t\t\t \n\t\t\tif (width == 1) {\n\t\t\t\tnvclk_fill = nvclk_freq * 8;\n\t\t\t\tif (crtc_drain_rate * 100 >= nvclk_fill * 102)\n\t\t\t\t\t \n\t\t\t\t\tclwm = 0xfff;\n\n\t\t\t\telse if (crtc_drain_rate * 100 >=\n\t\t\t\t\t nvclk_fill * 98) {\n\t\t\t\t\tclwm = 1024;\n\t\t\t\t\tcbs = 512;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tclwm_rnd_down = ((int)clwm / 8) * 8;\n\t\tif (clwm_rnd_down < clwm)\n\t\t\tclwm += 8;\n\n\t\tm1 = clwm + cbs - 1024;\t \n\t\tm2us = us_pipe_min + us_min_mclk_extra;\n\n\t\t \n\t\tp1clk = m2us * pclk_freq / (1000 * 1000);\n\t\tp2 = p1clk * bpp / 8;\t \n\n\t\tif ((p2 < m1) && (m1 > 0)) {\n\t\t\tfifo->valid = 0;\n\t\t\tfound = 0;\n\t\t\tif (min_mclk_extra == 0) {\n\t\t\t\tif (cbs <= 32) {\n\t\t\t\t\t \n\t\t\t\t\tfound = 1;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tcbs = cbs / 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmin_mclk_extra--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (clwm > 1023) {\t \n\t\t\t\tfifo->valid = 0;\n\t\t\t\tfound = 0;\n\t\t\t\tif (min_mclk_extra == 0)\n\t\t\t\t\t \n\t\t\t\t\tfound = 1;\n\t\t\t\telse\n\t\t\t\t\tmin_mclk_extra--;\n\t\t\t}\n\t\t}\n\n\t\tif (clwm < (1024 - cbs + 8))\n\t\t\tclwm = 1024 - cbs + 8;\n\t\tdata = (int)(clwm);\n\t\t \n\t\tfifo->graphics_lwm = data;\n\t\tfifo->graphics_burst_size = cbs;\n\n\t\tfifo->video_lwm = 1024;\n\t\tfifo->video_burst_size = 512;\n\t}\n}\n\nstatic void nv10UpdateArbitrationSettings(unsigned VClk,\n\t\t\t\t\t  unsigned pixelDepth,\n\t\t\t\t\t  unsigned *burst,\n\t\t\t\t\t  unsigned *lwm,\n\t\t\t\t\t  struct nvidia_par *par)\n{\n\tnv10_fifo_info fifo_data;\n\tnv10_sim_state sim_data;\n\tunsigned int MClk, NVClk, cfg1;\n\n\tnvGetClocks(par, &MClk, &NVClk);\n\n\tcfg1 = NV_RD32(par->PFB, 0x0204);\n\tsim_data.pix_bpp = (char)pixelDepth;\n\tsim_data.enable_video = 1;\n\tsim_data.enable_mp = 0;\n\tsim_data.memory_type = (NV_RD32(par->PFB, 0x0200) & 0x01) ? 1 : 0;\n\tsim_data.memory_width = (NV_RD32(par->PEXTDEV, 0x0000) & 0x10) ?\n\t    128 : 64;\n\tsim_data.mem_latency = (char)cfg1 & 0x0F;\n\tsim_data.mem_aligned = 1;\n\tsim_data.mem_page_miss =\n\t    (char)(((cfg1 >> 4) & 0x0F) + ((cfg1 >> 31) & 0x01));\n\tsim_data.gr_during_vid = 0;\n\tsim_data.pclk_khz = VClk;\n\tsim_data.mclk_khz = MClk;\n\tsim_data.nvclk_khz = NVClk;\n\tnv10CalcArbitration(&fifo_data, &sim_data);\n\tif (fifo_data.valid) {\n\t\tint b = fifo_data.graphics_burst_size >> 4;\n\t\t*burst = 0;\n\t\twhile (b >>= 1)\n\t\t\t(*burst)++;\n\t\t*lwm = fifo_data.graphics_lwm >> 3;\n\t}\n}\n\nstatic void nv30UpdateArbitrationSettings (\n    struct nvidia_par *par,\n    unsigned int      *burst,\n    unsigned int      *lwm\n)\n{\n    unsigned int MClk, NVClk;\n    unsigned int fifo_size, burst_size, graphics_lwm;\n\n    fifo_size = 2048;\n    burst_size = 512;\n    graphics_lwm = fifo_size - burst_size;\n\n    nvGetClocks(par, &MClk, &NVClk);\n\n    *burst = 0;\n    burst_size >>= 5;\n    while(burst_size >>= 1) (*burst)++;\n    *lwm = graphics_lwm >> 3;\n}\n\nstatic void nForceUpdateArbitrationSettings(unsigned VClk,\n\t\t\t\t\t    unsigned pixelDepth,\n\t\t\t\t\t    unsigned *burst,\n\t\t\t\t\t    unsigned *lwm,\n\t\t\t\t\t    struct nvidia_par *par)\n{\n\tnv10_fifo_info fifo_data;\n\tnv10_sim_state sim_data;\n\tunsigned int M, N, P, pll, MClk, NVClk, memctrl;\n\tstruct pci_dev *dev;\n\tint domain = pci_domain_nr(par->pci_dev->bus);\n\n\tif ((par->Chipset & 0x0FF0) == 0x01A0) {\n\t\tunsigned int uMClkPostDiv;\n\t\tdev = pci_get_domain_bus_and_slot(domain, 0, 3);\n\t\tpci_read_config_dword(dev, 0x6C, &uMClkPostDiv);\n\t\tuMClkPostDiv = (uMClkPostDiv >> 8) & 0xf;\n\n\t\tif (!uMClkPostDiv)\n\t\t\tuMClkPostDiv = 4;\n\t\tMClk = 400000 / uMClkPostDiv;\n\t} else {\n\t\tdev = pci_get_domain_bus_and_slot(domain, 0, 5);\n\t\tpci_read_config_dword(dev, 0x4c, &MClk);\n\t\tMClk /= 1000;\n\t}\n\tpci_dev_put(dev);\n\tpll = NV_RD32(par->PRAMDAC0, 0x0500);\n\tM = (pll >> 0) & 0xFF;\n\tN = (pll >> 8) & 0xFF;\n\tP = (pll >> 16) & 0x0F;\n\tNVClk = (N * par->CrystalFreqKHz / M) >> P;\n\tsim_data.pix_bpp = (char)pixelDepth;\n\tsim_data.enable_video = 0;\n\tsim_data.enable_mp = 0;\n\tdev = pci_get_domain_bus_and_slot(domain, 0, 1);\n\tpci_read_config_dword(dev, 0x7C, &sim_data.memory_type);\n\tpci_dev_put(dev);\n\tsim_data.memory_type = (sim_data.memory_type >> 12) & 1;\n\tsim_data.memory_width = 64;\n\n\tdev = pci_get_domain_bus_and_slot(domain, 0, 3);\n\tpci_read_config_dword(dev, 0, &memctrl);\n\tpci_dev_put(dev);\n\tmemctrl >>= 16;\n\n\tif ((memctrl == 0x1A9) || (memctrl == 0x1AB) || (memctrl == 0x1ED)) {\n\t\tu32 dimm[3];\n\n\t\tdev = pci_get_domain_bus_and_slot(domain, 0, 2);\n\t\tpci_read_config_dword(dev, 0x40, &dimm[0]);\n\t\tdimm[0] = (dimm[0] >> 8) & 0x4f;\n\t\tpci_read_config_dword(dev, 0x44, &dimm[1]);\n\t\tdimm[1] = (dimm[1] >> 8) & 0x4f;\n\t\tpci_read_config_dword(dev, 0x48, &dimm[2]);\n\t\tdimm[2] = (dimm[2] >> 8) & 0x4f;\n\n\t\tif ((dimm[0] + dimm[1]) != dimm[2]) {\n\t\t\tprintk(\"nvidiafb: your nForce DIMMs are not arranged \"\n\t\t\t       \"in optimal banks!\\n\");\n\t\t}\n\t\tpci_dev_put(dev);\n\t}\n\n\tsim_data.mem_latency = 3;\n\tsim_data.mem_aligned = 1;\n\tsim_data.mem_page_miss = 10;\n\tsim_data.gr_during_vid = 0;\n\tsim_data.pclk_khz = VClk;\n\tsim_data.mclk_khz = MClk;\n\tsim_data.nvclk_khz = NVClk;\n\tnv10CalcArbitration(&fifo_data, &sim_data);\n\tif (fifo_data.valid) {\n\t\tint b = fifo_data.graphics_burst_size >> 4;\n\t\t*burst = 0;\n\t\twhile (b >>= 1)\n\t\t\t(*burst)++;\n\t\t*lwm = fifo_data.graphics_lwm >> 3;\n\t}\n}\n\n \n\n \nstatic void CalcVClock(int clockIn,\n\t\t       int *clockOut, u32 * pllOut, struct nvidia_par *par)\n{\n\tunsigned lowM, highM;\n\tunsigned DeltaNew, DeltaOld;\n\tunsigned VClk, Freq;\n\tunsigned M, N, P;\n\n\tDeltaOld = 0xFFFFFFFF;\n\n\tVClk = (unsigned)clockIn;\n\n\tif (par->CrystalFreqKHz == 13500) {\n\t\tlowM = 7;\n\t\thighM = 13;\n\t} else {\n\t\tlowM = 8;\n\t\thighM = 14;\n\t}\n\n\tfor (P = 0; P <= 4; P++) {\n\t\tFreq = VClk << P;\n\t\tif ((Freq >= 128000) && (Freq <= 350000)) {\n\t\t\tfor (M = lowM; M <= highM; M++) {\n\t\t\t\tN = ((VClk << P) * M) / par->CrystalFreqKHz;\n\t\t\t\tif (N <= 255) {\n\t\t\t\t\tFreq =\n\t\t\t\t\t    ((par->CrystalFreqKHz * N) /\n\t\t\t\t\t     M) >> P;\n\t\t\t\t\tif (Freq > VClk)\n\t\t\t\t\t\tDeltaNew = Freq - VClk;\n\t\t\t\t\telse\n\t\t\t\t\t\tDeltaNew = VClk - Freq;\n\t\t\t\t\tif (DeltaNew < DeltaOld) {\n\t\t\t\t\t\t*pllOut =\n\t\t\t\t\t\t    (P << 16) | (N << 8) | M;\n\t\t\t\t\t\t*clockOut = Freq;\n\t\t\t\t\t\tDeltaOld = DeltaNew;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void CalcVClock2Stage(int clockIn,\n\t\t\t     int *clockOut,\n\t\t\t     u32 * pllOut,\n\t\t\t     u32 * pllBOut, struct nvidia_par *par)\n{\n\tunsigned DeltaNew, DeltaOld;\n\tunsigned VClk, Freq;\n\tunsigned M, N, P;\n\n\tDeltaOld = 0xFFFFFFFF;\n\n\t*pllBOut = 0x80000401;\t \n\n\tVClk = (unsigned)clockIn;\n\n\tfor (P = 0; P <= 6; P++) {\n\t\tFreq = VClk << P;\n\t\tif ((Freq >= 400000) && (Freq <= 1000000)) {\n\t\t\tfor (M = 1; M <= 13; M++) {\n\t\t\t\tN = ((VClk << P) * M) /\n\t\t\t\t    (par->CrystalFreqKHz << 2);\n\t\t\t\tif ((N >= 5) && (N <= 255)) {\n\t\t\t\t\tFreq =\n\t\t\t\t\t    (((par->CrystalFreqKHz << 2) * N) /\n\t\t\t\t\t     M) >> P;\n\t\t\t\t\tif (Freq > VClk)\n\t\t\t\t\t\tDeltaNew = Freq - VClk;\n\t\t\t\t\telse\n\t\t\t\t\t\tDeltaNew = VClk - Freq;\n\t\t\t\t\tif (DeltaNew < DeltaOld) {\n\t\t\t\t\t\t*pllOut =\n\t\t\t\t\t\t    (P << 16) | (N << 8) | M;\n\t\t\t\t\t\t*clockOut = Freq;\n\t\t\t\t\t\tDeltaOld = DeltaNew;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid NVCalcStateExt(struct nvidia_par *par,\n\t\t    RIVA_HW_STATE * state,\n\t\t    int bpp,\n\t\t    int width,\n\t\t    int hDisplaySize, int height, int dotClock, int flags)\n{\n\tint pixelDepth, VClk = 0;\n\t \n\tstate->bpp = bpp;\t \n\tstate->width = width;\n\tstate->height = height;\n\t \n\tpixelDepth = (bpp + 1) / 8;\n\tif (par->twoStagePLL)\n\t\tCalcVClock2Stage(dotClock, &VClk, &state->pll, &state->pllB,\n\t\t\t\t par);\n\telse\n\t\tCalcVClock(dotClock, &VClk, &state->pll, par);\n\n\tswitch (par->Architecture) {\n\tcase NV_ARCH_04:\n\t\tnv4UpdateArbitrationSettings(VClk,\n\t\t\t\t\t     pixelDepth * 8,\n\t\t\t\t\t     &(state->arbitration0),\n\t\t\t\t\t     &(state->arbitration1), par);\n\t\tstate->cursor0 = 0x00;\n\t\tstate->cursor1 = 0xbC;\n\t\tif (flags & FB_VMODE_DOUBLE)\n\t\t\tstate->cursor1 |= 2;\n\t\tstate->cursor2 = 0x00000000;\n\t\tstate->pllsel = 0x10000700;\n\t\tstate->config = 0x00001114;\n\t\tstate->general = bpp == 16 ? 0x00101100 : 0x00100100;\n\t\tstate->repaint1 = hDisplaySize < 1280 ? 0x04 : 0x00;\n\t\tbreak;\n\tcase NV_ARCH_40:\n\t\tif (!par->FlatPanel)\n\t\t\tstate->control = NV_RD32(par->PRAMDAC0, 0x0580) &\n\t\t\t\t0xeffffeff;\n\t\tfallthrough;\n\tcase NV_ARCH_10:\n\tcase NV_ARCH_20:\n\tcase NV_ARCH_30:\n\tdefault:\n\t\tif ((par->Chipset & 0xfff0) == 0x0240 ||\n\t\t    (par->Chipset & 0xfff0) == 0x03d0) {\n\t\t\tstate->arbitration0 = 256;\n\t\t\tstate->arbitration1 = 0x0480;\n\t\t} else if (((par->Chipset & 0xffff) == 0x01A0) ||\n\t\t    ((par->Chipset & 0xffff) == 0x01f0)) {\n\t\t\tnForceUpdateArbitrationSettings(VClk,\n\t\t\t\t\t\t\tpixelDepth * 8,\n\t\t\t\t\t\t\t&(state->arbitration0),\n\t\t\t\t\t\t\t&(state->arbitration1),\n\t\t\t\t\t\t\tpar);\n\t\t} else if (par->Architecture < NV_ARCH_30) {\n\t\t\tnv10UpdateArbitrationSettings(VClk,\n\t\t\t\t\t\t      pixelDepth * 8,\n\t\t\t\t\t\t      &(state->arbitration0),\n\t\t\t\t\t\t      &(state->arbitration1),\n\t\t\t\t\t\t      par);\n\t\t} else {\n\t\t\tnv30UpdateArbitrationSettings(par,\n\t\t\t\t\t\t      &(state->arbitration0),\n\t\t\t\t\t\t      &(state->arbitration1));\n\t\t}\n\n\t\tstate->cursor0 = 0x80 | (par->CursorStart >> 17);\n\t\tstate->cursor1 = (par->CursorStart >> 11) << 2;\n\t\tstate->cursor2 = par->CursorStart >> 24;\n\t\tif (flags & FB_VMODE_DOUBLE)\n\t\t\tstate->cursor1 |= 2;\n\t\tstate->pllsel = 0x10000700;\n\t\tstate->config = NV_RD32(par->PFB, 0x00000200);\n\t\tstate->general = bpp == 16 ? 0x00101100 : 0x00100100;\n\t\tstate->repaint1 = hDisplaySize < 1280 ? 0x04 : 0x00;\n\t\tbreak;\n\t}\n\n\tif (bpp != 8)\t\t \n\t\tstate->general |= 0x00000030;\n\n\tstate->repaint0 = (((width / 8) * pixelDepth) & 0x700) >> 3;\n\tstate->pixel = (pixelDepth > 2) ? 3 : pixelDepth;\n}\n\nvoid NVLoadStateExt(struct nvidia_par *par, RIVA_HW_STATE * state)\n{\n\tint i, j;\n\n\tNV_WR32(par->PMC, 0x0140, 0x00000000);\n\tNV_WR32(par->PMC, 0x0200, 0xFFFF00FF);\n\tNV_WR32(par->PMC, 0x0200, 0xFFFFFFFF);\n\n\tNV_WR32(par->PTIMER, 0x0200 * 4, 0x00000008);\n\tNV_WR32(par->PTIMER, 0x0210 * 4, 0x00000003);\n\tNV_WR32(par->PTIMER, 0x0140 * 4, 0x00000000);\n\tNV_WR32(par->PTIMER, 0x0100 * 4, 0xFFFFFFFF);\n\n\tif (par->Architecture == NV_ARCH_04) {\n\t\tif (state)\n\t\t\tNV_WR32(par->PFB, 0x0200, state->config);\n\t} else if ((par->Architecture < NV_ARCH_40) ||\n\t\t   (par->Chipset & 0xfff0) == 0x0040) {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tNV_WR32(par->PFB, 0x0240 + (i * 0x10), 0);\n\t\t\tNV_WR32(par->PFB, 0x0244 + (i * 0x10),\n\t\t\t\tpar->FbMapSize - 1);\n\t\t}\n\t} else {\n\t\tint regions = 12;\n\n\t\tif (((par->Chipset & 0xfff0) == 0x0090) ||\n\t\t    ((par->Chipset & 0xfff0) == 0x01D0) ||\n\t\t    ((par->Chipset & 0xfff0) == 0x0290) ||\n\t\t    ((par->Chipset & 0xfff0) == 0x0390) ||\n\t\t    ((par->Chipset & 0xfff0) == 0x03D0))\n\t\t\tregions = 15;\n\t\tfor(i = 0; i < regions; i++) {\n\t\t\tNV_WR32(par->PFB, 0x0600 + (i * 0x10), 0);\n\t\t\tNV_WR32(par->PFB, 0x0604 + (i * 0x10),\n\t\t\t\tpar->FbMapSize - 1);\n\t\t}\n\t}\n\n\tif (par->Architecture >= NV_ARCH_40) {\n\t\tNV_WR32(par->PRAMIN, 0x0000 * 4, 0x80000010);\n\t\tNV_WR32(par->PRAMIN, 0x0001 * 4, 0x00101202);\n\t\tNV_WR32(par->PRAMIN, 0x0002 * 4, 0x80000011);\n\t\tNV_WR32(par->PRAMIN, 0x0003 * 4, 0x00101204);\n\t\tNV_WR32(par->PRAMIN, 0x0004 * 4, 0x80000012);\n\t\tNV_WR32(par->PRAMIN, 0x0005 * 4, 0x00101206);\n\t\tNV_WR32(par->PRAMIN, 0x0006 * 4, 0x80000013);\n\t\tNV_WR32(par->PRAMIN, 0x0007 * 4, 0x00101208);\n\t\tNV_WR32(par->PRAMIN, 0x0008 * 4, 0x80000014);\n\t\tNV_WR32(par->PRAMIN, 0x0009 * 4, 0x0010120A);\n\t\tNV_WR32(par->PRAMIN, 0x000A * 4, 0x80000015);\n\t\tNV_WR32(par->PRAMIN, 0x000B * 4, 0x0010120C);\n\t\tNV_WR32(par->PRAMIN, 0x000C * 4, 0x80000016);\n\t\tNV_WR32(par->PRAMIN, 0x000D * 4, 0x0010120E);\n\t\tNV_WR32(par->PRAMIN, 0x000E * 4, 0x80000017);\n\t\tNV_WR32(par->PRAMIN, 0x000F * 4, 0x00101210);\n\t\tNV_WR32(par->PRAMIN, 0x0800 * 4, 0x00003000);\n\t\tNV_WR32(par->PRAMIN, 0x0801 * 4, par->FbMapSize - 1);\n\t\tNV_WR32(par->PRAMIN, 0x0802 * 4, 0x00000002);\n\t\tNV_WR32(par->PRAMIN, 0x0808 * 4, 0x02080062);\n\t\tNV_WR32(par->PRAMIN, 0x0809 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x080A * 4, 0x00001200);\n\t\tNV_WR32(par->PRAMIN, 0x080B * 4, 0x00001200);\n\t\tNV_WR32(par->PRAMIN, 0x080C * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x080D * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0810 * 4, 0x02080043);\n\t\tNV_WR32(par->PRAMIN, 0x0811 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0812 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0813 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0814 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0815 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0818 * 4, 0x02080044);\n\t\tNV_WR32(par->PRAMIN, 0x0819 * 4, 0x02000000);\n\t\tNV_WR32(par->PRAMIN, 0x081A * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x081B * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x081C * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x081D * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0820 * 4, 0x02080019);\n\t\tNV_WR32(par->PRAMIN, 0x0821 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0822 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0823 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0824 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0825 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0828 * 4, 0x020A005C);\n\t\tNV_WR32(par->PRAMIN, 0x0829 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x082A * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x082B * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x082C * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x082D * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0830 * 4, 0x0208009F);\n\t\tNV_WR32(par->PRAMIN, 0x0831 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0832 * 4, 0x00001200);\n\t\tNV_WR32(par->PRAMIN, 0x0833 * 4, 0x00001200);\n\t\tNV_WR32(par->PRAMIN, 0x0834 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0835 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0838 * 4, 0x0208004A);\n\t\tNV_WR32(par->PRAMIN, 0x0839 * 4, 0x02000000);\n\t\tNV_WR32(par->PRAMIN, 0x083A * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x083B * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x083C * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x083D * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0840 * 4, 0x02080077);\n\t\tNV_WR32(par->PRAMIN, 0x0841 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0842 * 4, 0x00001200);\n\t\tNV_WR32(par->PRAMIN, 0x0843 * 4, 0x00001200);\n\t\tNV_WR32(par->PRAMIN, 0x0844 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0845 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x084C * 4, 0x00003002);\n\t\tNV_WR32(par->PRAMIN, 0x084D * 4, 0x00007FFF);\n\t\tNV_WR32(par->PRAMIN, 0x084E * 4,\n\t\t\tpar->FbUsableSize | 0x00000002);\n\n#ifdef __BIG_ENDIAN\n\t\tNV_WR32(par->PRAMIN, 0x080A * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x080A * 4) | 0x01000000);\n\t\tNV_WR32(par->PRAMIN, 0x0812 * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x0812 * 4) | 0x01000000);\n\t\tNV_WR32(par->PRAMIN, 0x081A * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x081A * 4) | 0x01000000);\n\t\tNV_WR32(par->PRAMIN, 0x0822 * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x0822 * 4) | 0x01000000);\n\t\tNV_WR32(par->PRAMIN, 0x082A * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x082A * 4) | 0x01000000);\n\t\tNV_WR32(par->PRAMIN, 0x0832 * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x0832 * 4) | 0x01000000);\n\t\tNV_WR32(par->PRAMIN, 0x083A * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x083A * 4) | 0x01000000);\n\t\tNV_WR32(par->PRAMIN, 0x0842 * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x0842 * 4) | 0x01000000);\n\t\tNV_WR32(par->PRAMIN, 0x0819 * 4, 0x01000000);\n\t\tNV_WR32(par->PRAMIN, 0x0839 * 4, 0x01000000);\n#endif\n\t} else {\n\t\tNV_WR32(par->PRAMIN, 0x0000 * 4, 0x80000010);\n\t\tNV_WR32(par->PRAMIN, 0x0001 * 4, 0x80011201);\n\t\tNV_WR32(par->PRAMIN, 0x0002 * 4, 0x80000011);\n\t\tNV_WR32(par->PRAMIN, 0x0003 * 4, 0x80011202);\n\t\tNV_WR32(par->PRAMIN, 0x0004 * 4, 0x80000012);\n\t\tNV_WR32(par->PRAMIN, 0x0005 * 4, 0x80011203);\n\t\tNV_WR32(par->PRAMIN, 0x0006 * 4, 0x80000013);\n\t\tNV_WR32(par->PRAMIN, 0x0007 * 4, 0x80011204);\n\t\tNV_WR32(par->PRAMIN, 0x0008 * 4, 0x80000014);\n\t\tNV_WR32(par->PRAMIN, 0x0009 * 4, 0x80011205);\n\t\tNV_WR32(par->PRAMIN, 0x000A * 4, 0x80000015);\n\t\tNV_WR32(par->PRAMIN, 0x000B * 4, 0x80011206);\n\t\tNV_WR32(par->PRAMIN, 0x000C * 4, 0x80000016);\n\t\tNV_WR32(par->PRAMIN, 0x000D * 4, 0x80011207);\n\t\tNV_WR32(par->PRAMIN, 0x000E * 4, 0x80000017);\n\t\tNV_WR32(par->PRAMIN, 0x000F * 4, 0x80011208);\n\t\tNV_WR32(par->PRAMIN, 0x0800 * 4, 0x00003000);\n\t\tNV_WR32(par->PRAMIN, 0x0801 * 4, par->FbMapSize - 1);\n\t\tNV_WR32(par->PRAMIN, 0x0802 * 4, 0x00000002);\n\t\tNV_WR32(par->PRAMIN, 0x0803 * 4, 0x00000002);\n\t\tif (par->Architecture >= NV_ARCH_10)\n\t\t\tNV_WR32(par->PRAMIN, 0x0804 * 4, 0x01008062);\n\t\telse\n\t\t\tNV_WR32(par->PRAMIN, 0x0804 * 4, 0x01008042);\n\t\tNV_WR32(par->PRAMIN, 0x0805 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0806 * 4, 0x12001200);\n\t\tNV_WR32(par->PRAMIN, 0x0807 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0808 * 4, 0x01008043);\n\t\tNV_WR32(par->PRAMIN, 0x0809 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x080A * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x080B * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x080C * 4, 0x01008044);\n\t\tNV_WR32(par->PRAMIN, 0x080D * 4, 0x00000002);\n\t\tNV_WR32(par->PRAMIN, 0x080E * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x080F * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0810 * 4, 0x01008019);\n\t\tNV_WR32(par->PRAMIN, 0x0811 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0812 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0813 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0814 * 4, 0x0100A05C);\n\t\tNV_WR32(par->PRAMIN, 0x0815 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0816 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0817 * 4, 0x00000000);\n\t\tif (par->WaitVSyncPossible)\n\t\t\tNV_WR32(par->PRAMIN, 0x0818 * 4, 0x0100809F);\n\t\telse\n\t\t\tNV_WR32(par->PRAMIN, 0x0818 * 4, 0x0100805F);\n\t\tNV_WR32(par->PRAMIN, 0x0819 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x081A * 4, 0x12001200);\n\t\tNV_WR32(par->PRAMIN, 0x081B * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x081C * 4, 0x0100804A);\n\t\tNV_WR32(par->PRAMIN, 0x081D * 4, 0x00000002);\n\t\tNV_WR32(par->PRAMIN, 0x081E * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x081F * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0820 * 4, 0x01018077);\n\t\tNV_WR32(par->PRAMIN, 0x0821 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0822 * 4, 0x12001200);\n\t\tNV_WR32(par->PRAMIN, 0x0823 * 4, 0x00000000);\n\t\tNV_WR32(par->PRAMIN, 0x0824 * 4, 0x00003002);\n\t\tNV_WR32(par->PRAMIN, 0x0825 * 4, 0x00007FFF);\n\t\tNV_WR32(par->PRAMIN, 0x0826 * 4,\n\t\t\tpar->FbUsableSize | 0x00000002);\n\t\tNV_WR32(par->PRAMIN, 0x0827 * 4, 0x00000002);\n#ifdef __BIG_ENDIAN\n\t\tNV_WR32(par->PRAMIN, 0x0804 * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x0804 * 4) | 0x00080000);\n\t\tNV_WR32(par->PRAMIN, 0x0808 * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x0808 * 4) | 0x00080000);\n\t\tNV_WR32(par->PRAMIN, 0x080C * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x080C * 4) | 0x00080000);\n\t\tNV_WR32(par->PRAMIN, 0x0810 * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x0810 * 4) | 0x00080000);\n\t\tNV_WR32(par->PRAMIN, 0x0814 * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x0814 * 4) | 0x00080000);\n\t\tNV_WR32(par->PRAMIN, 0x0818 * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x0818 * 4) | 0x00080000);\n\t\tNV_WR32(par->PRAMIN, 0x081C * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x081C * 4) | 0x00080000);\n\t\tNV_WR32(par->PRAMIN, 0x0820 * 4,\n\t\t\tNV_RD32(par->PRAMIN, 0x0820 * 4) | 0x00080000);\n\t\tNV_WR32(par->PRAMIN, 0x080D * 4, 0x00000001);\n\t\tNV_WR32(par->PRAMIN, 0x081D * 4, 0x00000001);\n#endif\n\t}\n\tif (par->Architecture < NV_ARCH_10) {\n\t\tif ((par->Chipset & 0x0fff) == 0x0020) {\n\t\t\tNV_WR32(par->PRAMIN, 0x0824 * 4,\n\t\t\t\tNV_RD32(par->PRAMIN, 0x0824 * 4) | 0x00020000);\n\t\t\tNV_WR32(par->PRAMIN, 0x0826 * 4,\n\t\t\t\tNV_RD32(par->PRAMIN,\n\t\t\t\t\t0x0826 * 4) + par->FbAddress);\n\t\t}\n\t\tNV_WR32(par->PGRAPH, 0x0080, 0x000001FF);\n\t\tNV_WR32(par->PGRAPH, 0x0080, 0x1230C000);\n\t\tNV_WR32(par->PGRAPH, 0x0084, 0x72111101);\n\t\tNV_WR32(par->PGRAPH, 0x0088, 0x11D5F071);\n\t\tNV_WR32(par->PGRAPH, 0x008C, 0x0004FF31);\n\t\tNV_WR32(par->PGRAPH, 0x008C, 0x4004FF31);\n\t\tNV_WR32(par->PGRAPH, 0x0140, 0x00000000);\n\t\tNV_WR32(par->PGRAPH, 0x0100, 0xFFFFFFFF);\n\t\tNV_WR32(par->PGRAPH, 0x0170, 0x10010100);\n\t\tNV_WR32(par->PGRAPH, 0x0710, 0xFFFFFFFF);\n\t\tNV_WR32(par->PGRAPH, 0x0720, 0x00000001);\n\t\tNV_WR32(par->PGRAPH, 0x0810, 0x00000000);\n\t\tNV_WR32(par->PGRAPH, 0x0608, 0xFFFFFFFF);\n\t} else {\n\t\tNV_WR32(par->PGRAPH, 0x0080, 0xFFFFFFFF);\n\t\tNV_WR32(par->PGRAPH, 0x0080, 0x00000000);\n\n\t\tNV_WR32(par->PGRAPH, 0x0140, 0x00000000);\n\t\tNV_WR32(par->PGRAPH, 0x0100, 0xFFFFFFFF);\n\t\tNV_WR32(par->PGRAPH, 0x0144, 0x10010100);\n\t\tNV_WR32(par->PGRAPH, 0x0714, 0xFFFFFFFF);\n\t\tNV_WR32(par->PGRAPH, 0x0720, 0x00000001);\n\t\tNV_WR32(par->PGRAPH, 0x0710,\n\t\t\tNV_RD32(par->PGRAPH, 0x0710) & 0x0007ff00);\n\t\tNV_WR32(par->PGRAPH, 0x0710,\n\t\t\tNV_RD32(par->PGRAPH, 0x0710) | 0x00020100);\n\n\t\tif (par->Architecture == NV_ARCH_10) {\n\t\t\tNV_WR32(par->PGRAPH, 0x0084, 0x00118700);\n\t\t\tNV_WR32(par->PGRAPH, 0x0088, 0x24E00810);\n\t\t\tNV_WR32(par->PGRAPH, 0x008C, 0x55DE0030);\n\n\t\t\tfor (i = 0; i < 32; i++)\n\t\t\t\tNV_WR32(&par->PGRAPH[(0x0B00 / 4) + i], 0,\n\t\t\t\t\tNV_RD32(&par->PFB[(0x0240 / 4) + i],\n\t\t\t\t\t\t0));\n\n\t\t\tNV_WR32(par->PGRAPH, 0x640, 0);\n\t\t\tNV_WR32(par->PGRAPH, 0x644, 0);\n\t\t\tNV_WR32(par->PGRAPH, 0x684, par->FbMapSize - 1);\n\t\t\tNV_WR32(par->PGRAPH, 0x688, par->FbMapSize - 1);\n\n\t\t\tNV_WR32(par->PGRAPH, 0x0810, 0x00000000);\n\t\t\tNV_WR32(par->PGRAPH, 0x0608, 0xFFFFFFFF);\n\t\t} else {\n\t\t\tif (par->Architecture >= NV_ARCH_40) {\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0084, 0x401287c0);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x008C, 0x60de8051);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0090, 0x00008000);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0610, 0x00be3c5f);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0bc4,\n\t\t\t\t\tNV_RD32(par->PGRAPH, 0x0bc4) |\n\t\t\t\t\t0x00008000);\n\n\t\t\t\tj = NV_RD32(par->REGS, 0x1540) & 0xff;\n\n\t\t\t\tif (j) {\n\t\t\t\t\tfor (i = 0; !(j & 1); j >>= 1, i++);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x5000, i);\n\t\t\t\t}\n\n\t\t\t\tif ((par->Chipset & 0xfff0) == 0x0040) {\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x09b0,\n\t\t\t\t\t\t0x83280fff);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x09b4,\n\t\t\t\t\t\t0x000000a0);\n\t\t\t\t} else {\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0820,\n\t\t\t\t\t\t0x83280eff);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0824,\n\t\t\t\t\t\t0x000000a0);\n\t\t\t\t}\n\n\t\t\t\tswitch (par->Chipset & 0xfff0) {\n\t\t\t\tcase 0x0040:\n\t\t\t\tcase 0x0210:\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x09b8,\n\t\t\t\t\t\t0x0078e366);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x09bc,\n\t\t\t\t\t\t0x0000014c);\n\t\t\t\t\tNV_WR32(par->PFB, 0x033C,\n\t\t\t\t\t\tNV_RD32(par->PFB, 0x33C) &\n\t\t\t\t\t\t0xffff7fff);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x00C0:\n\t\t\t\tcase 0x0120:\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0828,\n\t\t\t\t\t\t0x007596ff);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x082C,\n\t\t\t\t\t\t0x00000108);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x0160:\n\t\t\t\tcase 0x01D0:\n\t\t\t\tcase 0x0240:\n\t\t\t\tcase 0x03D0:\n\t\t\t\t\tNV_WR32(par->PMC, 0x1700,\n\t\t\t\t\t\tNV_RD32(par->PFB, 0x020C));\n\t\t\t\t\tNV_WR32(par->PMC, 0x1704, 0);\n\t\t\t\t\tNV_WR32(par->PMC, 0x1708, 0);\n\t\t\t\t\tNV_WR32(par->PMC, 0x170C,\n\t\t\t\t\t\tNV_RD32(par->PFB, 0x020C));\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0860, 0);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0864, 0);\n\t\t\t\t\tNV_WR32(par->PRAMDAC, 0x0608,\n\t\t\t\t\t\tNV_RD32(par->PRAMDAC,\n\t\t\t\t\t\t\t0x0608) | 0x00100000);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x0140:\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0828,\n\t\t\t\t\t\t0x0072cb77);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x082C,\n\t\t\t\t\t\t0x00000108);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x0220:\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0860, 0);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0864, 0);\n\t\t\t\t\tNV_WR32(par->PRAMDAC, 0x0608,\n\t\t\t\t\t\tNV_RD32(par->PRAMDAC, 0x0608) |\n\t\t\t\t\t\t0x00100000);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x0090:\n\t\t\t\tcase 0x0290:\n\t\t\t\tcase 0x0390:\n\t\t\t\t\tNV_WR32(par->PRAMDAC, 0x0608,\n\t\t\t\t\t\tNV_RD32(par->PRAMDAC, 0x0608) |\n\t\t\t\t\t\t0x00100000);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0828,\n\t\t\t\t\t\t0x07830610);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x082C,\n\t\t\t\t\t\t0x0000016A);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0b38, 0x2ffff800);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0b3c, 0x00006000);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x032C, 0x01000000);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0220, 0x00001200);\n\t\t\t} else if (par->Architecture == NV_ARCH_30) {\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0084, 0x40108700);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0890, 0x00140000);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x008C, 0xf00e0431);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0090, 0x00008000);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0610, 0xf04b1f36);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0B80, 0x1002d888);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0B88, 0x62ff007f);\n\t\t\t} else {\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0084, 0x00118700);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x008C, 0xF20E0431);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0090, 0x00000000);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x009C, 0x00000040);\n\n\t\t\t\tif ((par->Chipset & 0x0ff0) >= 0x0250) {\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0890,\n\t\t\t\t\t\t0x00080000);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0610,\n\t\t\t\t\t\t0x304B1FB6);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0B80,\n\t\t\t\t\t\t0x18B82880);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0B84,\n\t\t\t\t\t\t0x44000000);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0098,\n\t\t\t\t\t\t0x40000080);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0B88,\n\t\t\t\t\t\t0x000000ff);\n\t\t\t\t} else {\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0880,\n\t\t\t\t\t\t0x00080000);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0094,\n\t\t\t\t\t\t0x00000005);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0B80,\n\t\t\t\t\t\t0x45CAA208);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0B84,\n\t\t\t\t\t\t0x24000000);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0098,\n\t\t\t\t\t\t0x00000040);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0750,\n\t\t\t\t\t\t0x00E00038);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0754,\n\t\t\t\t\t\t0x00000030);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0750,\n\t\t\t\t\t\t0x00E10038);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0754,\n\t\t\t\t\t\t0x00000030);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((par->Architecture < NV_ARCH_40) ||\n\t\t\t    ((par->Chipset & 0xfff0) == 0x0040)) {\n\t\t\t\tfor (i = 0; i < 32; i++) {\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0900 + i*4,\n\t\t\t\t\t\tNV_RD32(par->PFB, 0x0240 +i*4));\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x6900 + i*4,\n\t\t\t\t\t\tNV_RD32(par->PFB, 0x0240 +i*4));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (((par->Chipset & 0xfff0) == 0x0090) ||\n\t\t\t\t    ((par->Chipset & 0xfff0) == 0x01D0) ||\n\t\t\t\t    ((par->Chipset & 0xfff0) == 0x0290) ||\n\t\t\t\t    ((par->Chipset & 0xfff0) == 0x0390) ||\n\t\t\t\t    ((par->Chipset & 0xfff0) == 0x03D0)) {\n\t\t\t\t\tfor (i = 0; i < 60; i++) {\n\t\t\t\t\t\tNV_WR32(par->PGRAPH,\n\t\t\t\t\t\t\t0x0D00 + i*4,\n\t\t\t\t\t\t\tNV_RD32(par->PFB,\n\t\t\t\t\t\t\t\t0x0600 + i*4));\n\t\t\t\t\t\tNV_WR32(par->PGRAPH,\n\t\t\t\t\t\t\t0x6900 + i*4,\n\t\t\t\t\t\t\tNV_RD32(par->PFB,\n\t\t\t\t\t\t\t\t0x0600 + i*4));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < 48; i++) {\n\t\t\t\t\t\tNV_WR32(par->PGRAPH,\n\t\t\t\t\t\t\t0x0900 + i*4,\n\t\t\t\t\t\t\tNV_RD32(par->PFB,\n\t\t\t\t\t\t\t\t0x0600 + i*4));\n\t\t\t\t\t\tif(((par->Chipset & 0xfff0)\n\t\t\t\t\t\t    != 0x0160) &&\n\t\t\t\t\t\t   ((par->Chipset & 0xfff0)\n\t\t\t\t\t\t    != 0x0220) &&\n\t\t\t\t\t\t   ((par->Chipset & 0xfff0)\n\t\t\t\t\t\t    != 0x240))\n\t\t\t\t\t\t\tNV_WR32(par->PGRAPH,\n\t\t\t\t\t\t\t\t0x6900 + i*4,\n\t\t\t\t\t\t\t\tNV_RD32(par->PFB,\n\t\t\t\t\t\t\t\t\t0x0600 + i*4));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (par->Architecture >= NV_ARCH_40) {\n\t\t\t\tif ((par->Chipset & 0xfff0) == 0x0040) {\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x09A4,\n\t\t\t\t\t\tNV_RD32(par->PFB, 0x0200));\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x09A8,\n\t\t\t\t\t\tNV_RD32(par->PFB, 0x0204));\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x69A4,\n\t\t\t\t\t\tNV_RD32(par->PFB, 0x0200));\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x69A8,\n\t\t\t\t\t\tNV_RD32(par->PFB, 0x0204));\n\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0820, 0);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0824, 0);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0864,\n\t\t\t\t\t\tpar->FbMapSize - 1);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0868,\n\t\t\t\t\t\tpar->FbMapSize - 1);\n\t\t\t\t} else {\n\t\t\t\t\tif ((par->Chipset & 0xfff0) == 0x0090 ||\n\t\t\t\t\t    (par->Chipset & 0xfff0) == 0x01D0 ||\n\t\t\t\t\t    (par->Chipset & 0xfff0) == 0x0290 ||\n\t\t\t\t\t    (par->Chipset & 0xfff0) == 0x0390) {\n\t\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0DF0,\n\t\t\t\t\t\t\tNV_RD32(par->PFB, 0x0200));\n\t\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0DF4,\n\t\t\t\t\t\t\tNV_RD32(par->PFB, 0x0204));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tNV_WR32(par->PGRAPH, 0x09F0,\n\t\t\t\t\t\t\tNV_RD32(par->PFB, 0x0200));\n\t\t\t\t\t\tNV_WR32(par->PGRAPH, 0x09F4,\n\t\t\t\t\t\t\tNV_RD32(par->PFB, 0x0204));\n\t\t\t\t\t}\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x69F0,\n\t\t\t\t\t\tNV_RD32(par->PFB, 0x0200));\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x69F4,\n\t\t\t\t\t\tNV_RD32(par->PFB, 0x0204));\n\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0840, 0);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x0844, 0);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x08a0,\n\t\t\t\t\t\tpar->FbMapSize - 1);\n\t\t\t\t\tNV_WR32(par->PGRAPH, 0x08a4,\n\t\t\t\t\t\tpar->FbMapSize - 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tNV_WR32(par->PGRAPH, 0x09A4,\n\t\t\t\t\tNV_RD32(par->PFB, 0x0200));\n\t\t\t\tNV_WR32(par->PGRAPH, 0x09A8,\n\t\t\t\t\tNV_RD32(par->PFB, 0x0204));\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0750, 0x00EA0000);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0754,\n\t\t\t\t\tNV_RD32(par->PFB, 0x0200));\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0750, 0x00EA0004);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0754,\n\t\t\t\t\tNV_RD32(par->PFB, 0x0204));\n\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0820, 0);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0824, 0);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0864,\n\t\t\t\t\tpar->FbMapSize - 1);\n\t\t\t\tNV_WR32(par->PGRAPH, 0x0868,\n\t\t\t\t\tpar->FbMapSize - 1);\n\t\t\t}\n\t\t\tNV_WR32(par->PGRAPH, 0x0B20, 0x00000000);\n\t\t\tNV_WR32(par->PGRAPH, 0x0B04, 0xFFFFFFFF);\n\t\t}\n\t}\n\tNV_WR32(par->PGRAPH, 0x053C, 0);\n\tNV_WR32(par->PGRAPH, 0x0540, 0);\n\tNV_WR32(par->PGRAPH, 0x0544, 0x00007FFF);\n\tNV_WR32(par->PGRAPH, 0x0548, 0x00007FFF);\n\n\tNV_WR32(par->PFIFO, 0x0140 * 4, 0x00000000);\n\tNV_WR32(par->PFIFO, 0x0141 * 4, 0x00000001);\n\tNV_WR32(par->PFIFO, 0x0480 * 4, 0x00000000);\n\tNV_WR32(par->PFIFO, 0x0494 * 4, 0x00000000);\n\tif (par->Architecture >= NV_ARCH_40)\n\t\tNV_WR32(par->PFIFO, 0x0481 * 4, 0x00010000);\n\telse\n\t\tNV_WR32(par->PFIFO, 0x0481 * 4, 0x00000100);\n\tNV_WR32(par->PFIFO, 0x0490 * 4, 0x00000000);\n\tNV_WR32(par->PFIFO, 0x0491 * 4, 0x00000000);\n\tif (par->Architecture >= NV_ARCH_40)\n\t\tNV_WR32(par->PFIFO, 0x048B * 4, 0x00001213);\n\telse\n\t\tNV_WR32(par->PFIFO, 0x048B * 4, 0x00001209);\n\tNV_WR32(par->PFIFO, 0x0400 * 4, 0x00000000);\n\tNV_WR32(par->PFIFO, 0x0414 * 4, 0x00000000);\n\tNV_WR32(par->PFIFO, 0x0084 * 4, 0x03000100);\n\tNV_WR32(par->PFIFO, 0x0085 * 4, 0x00000110);\n\tNV_WR32(par->PFIFO, 0x0086 * 4, 0x00000112);\n\tNV_WR32(par->PFIFO, 0x0143 * 4, 0x0000FFFF);\n\tNV_WR32(par->PFIFO, 0x0496 * 4, 0x0000FFFF);\n\tNV_WR32(par->PFIFO, 0x0050 * 4, 0x00000000);\n\tNV_WR32(par->PFIFO, 0x0040 * 4, 0xFFFFFFFF);\n\tNV_WR32(par->PFIFO, 0x0415 * 4, 0x00000001);\n\tNV_WR32(par->PFIFO, 0x048C * 4, 0x00000000);\n\tNV_WR32(par->PFIFO, 0x04A0 * 4, 0x00000000);\n#ifdef __BIG_ENDIAN\n\tNV_WR32(par->PFIFO, 0x0489 * 4, 0x800F0078);\n#else\n\tNV_WR32(par->PFIFO, 0x0489 * 4, 0x000F0078);\n#endif\n\tNV_WR32(par->PFIFO, 0x0488 * 4, 0x00000001);\n\tNV_WR32(par->PFIFO, 0x0480 * 4, 0x00000001);\n\tNV_WR32(par->PFIFO, 0x0494 * 4, 0x00000001);\n\tNV_WR32(par->PFIFO, 0x0495 * 4, 0x00000001);\n\tNV_WR32(par->PFIFO, 0x0140 * 4, 0x00000001);\n\n    if (!state) {\n\t    par->CurrentState = NULL;\n\t    return;\n    }\n\n\tif (par->Architecture >= NV_ARCH_10) {\n\t\tif (par->twoHeads) {\n\t\t\tNV_WR32(par->PCRTC0, 0x0860, state->head);\n\t\t\tNV_WR32(par->PCRTC0, 0x2860, state->head2);\n\t\t}\n\t\tNV_WR32(par->PRAMDAC, 0x0404, NV_RD32(par->PRAMDAC, 0x0404) |\n\t\t\t(1 << 25));\n\n\t\tNV_WR32(par->PMC, 0x8704, 1);\n\t\tNV_WR32(par->PMC, 0x8140, 0);\n\t\tNV_WR32(par->PMC, 0x8920, 0);\n\t\tNV_WR32(par->PMC, 0x8924, 0);\n\t\tNV_WR32(par->PMC, 0x8908, par->FbMapSize - 1);\n\t\tNV_WR32(par->PMC, 0x890C, par->FbMapSize - 1);\n\t\tNV_WR32(par->PMC, 0x1588, 0);\n\n\t\tNV_WR32(par->PCRTC, 0x0810, state->cursorConfig);\n\t\tNV_WR32(par->PCRTC, 0x0830, state->displayV - 3);\n\t\tNV_WR32(par->PCRTC, 0x0834, state->displayV - 1);\n\n\t\tif (par->FlatPanel) {\n\t\t\tif ((par->Chipset & 0x0ff0) == 0x0110) {\n\t\t\t\tNV_WR32(par->PRAMDAC, 0x0528, state->dither);\n\t\t\t} else if (par->twoHeads) {\n\t\t\t\tNV_WR32(par->PRAMDAC, 0x083C, state->dither);\n\t\t\t}\n\n\t\t\tVGA_WR08(par->PCIO, 0x03D4, 0x53);\n\t\t\tVGA_WR08(par->PCIO, 0x03D5, state->timingH);\n\t\t\tVGA_WR08(par->PCIO, 0x03D4, 0x54);\n\t\t\tVGA_WR08(par->PCIO, 0x03D5, state->timingV);\n\t\t\tVGA_WR08(par->PCIO, 0x03D4, 0x21);\n\t\t\tVGA_WR08(par->PCIO, 0x03D5, 0xfa);\n\t\t}\n\n\t\tVGA_WR08(par->PCIO, 0x03D4, 0x41);\n\t\tVGA_WR08(par->PCIO, 0x03D5, state->extra);\n\t}\n\n\tVGA_WR08(par->PCIO, 0x03D4, 0x19);\n\tVGA_WR08(par->PCIO, 0x03D5, state->repaint0);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x1A);\n\tVGA_WR08(par->PCIO, 0x03D5, state->repaint1);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x25);\n\tVGA_WR08(par->PCIO, 0x03D5, state->screen);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x28);\n\tVGA_WR08(par->PCIO, 0x03D5, state->pixel);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x2D);\n\tVGA_WR08(par->PCIO, 0x03D5, state->horiz);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x1C);\n\tVGA_WR08(par->PCIO, 0x03D5, state->fifo);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x1B);\n\tVGA_WR08(par->PCIO, 0x03D5, state->arbitration0);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x20);\n\tVGA_WR08(par->PCIO, 0x03D5, state->arbitration1);\n\n\tif(par->Architecture >= NV_ARCH_30) {\n\t\tVGA_WR08(par->PCIO, 0x03D4, 0x47);\n\t\tVGA_WR08(par->PCIO, 0x03D5, state->arbitration1 >> 8);\n\t}\n\n\tVGA_WR08(par->PCIO, 0x03D4, 0x30);\n\tVGA_WR08(par->PCIO, 0x03D5, state->cursor0);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x31);\n\tVGA_WR08(par->PCIO, 0x03D5, state->cursor1);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x2F);\n\tVGA_WR08(par->PCIO, 0x03D5, state->cursor2);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x39);\n\tVGA_WR08(par->PCIO, 0x03D5, state->interlace);\n\n\tif (!par->FlatPanel) {\n\t\tif (par->Architecture >= NV_ARCH_40)\n\t\t\tNV_WR32(par->PRAMDAC0, 0x0580, state->control);\n\n\t\tNV_WR32(par->PRAMDAC0, 0x050C, state->pllsel);\n\t\tNV_WR32(par->PRAMDAC0, 0x0508, state->vpll);\n\t\tif (par->twoHeads)\n\t\t\tNV_WR32(par->PRAMDAC0, 0x0520, state->vpll2);\n\t\tif (par->twoStagePLL) {\n\t\t\tNV_WR32(par->PRAMDAC0, 0x0578, state->vpllB);\n\t\t\tNV_WR32(par->PRAMDAC0, 0x057C, state->vpll2B);\n\t\t}\n\t} else {\n\t\tNV_WR32(par->PRAMDAC, 0x0848, state->scale);\n\t\tNV_WR32(par->PRAMDAC, 0x0828, state->crtcSync +\n\t\t\tpar->PanelTweak);\n\t}\n\n\tNV_WR32(par->PRAMDAC, 0x0600, state->general);\n\n\tNV_WR32(par->PCRTC, 0x0140, 0);\n\tNV_WR32(par->PCRTC, 0x0100, 1);\n\n\tpar->CurrentState = state;\n}\n\nvoid NVUnloadStateExt(struct nvidia_par *par, RIVA_HW_STATE * state) {\n\tVGA_WR08(par->PCIO, 0x03D4, 0x19);\n\tstate->repaint0 = VGA_RD08(par->PCIO, 0x03D5);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x1A);\n\tstate->repaint1 = VGA_RD08(par->PCIO, 0x03D5);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x25);\n\tstate->screen = VGA_RD08(par->PCIO, 0x03D5);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x28);\n\tstate->pixel = VGA_RD08(par->PCIO, 0x03D5);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x2D);\n\tstate->horiz = VGA_RD08(par->PCIO, 0x03D5);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x1C);\n\tstate->fifo         = VGA_RD08(par->PCIO, 0x03D5);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x1B);\n\tstate->arbitration0 = VGA_RD08(par->PCIO, 0x03D5);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x20);\n\tstate->arbitration1 = VGA_RD08(par->PCIO, 0x03D5);\n\n\tif(par->Architecture >= NV_ARCH_30) {\n\t\tVGA_WR08(par->PCIO, 0x03D4, 0x47);\n\t\tstate->arbitration1 |= (VGA_RD08(par->PCIO, 0x03D5) & 1) << 8;\n\t}\n\n\tVGA_WR08(par->PCIO, 0x03D4, 0x30);\n\tstate->cursor0 = VGA_RD08(par->PCIO, 0x03D5);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x31);\n\tstate->cursor1 = VGA_RD08(par->PCIO, 0x03D5);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x2F);\n\tstate->cursor2 = VGA_RD08(par->PCIO, 0x03D5);\n\tVGA_WR08(par->PCIO, 0x03D4, 0x39);\n\tstate->interlace = VGA_RD08(par->PCIO, 0x03D5);\n\tstate->vpll = NV_RD32(par->PRAMDAC0, 0x0508);\n\tif (par->twoHeads)\n\t\tstate->vpll2 = NV_RD32(par->PRAMDAC0, 0x0520);\n\tif (par->twoStagePLL) {\n\t\tstate->vpllB = NV_RD32(par->PRAMDAC0, 0x0578);\n\t\tstate->vpll2B = NV_RD32(par->PRAMDAC0, 0x057C);\n\t}\n\tstate->pllsel = NV_RD32(par->PRAMDAC0, 0x050C);\n\tstate->general = NV_RD32(par->PRAMDAC, 0x0600);\n\tstate->scale = NV_RD32(par->PRAMDAC, 0x0848);\n\tstate->config = NV_RD32(par->PFB, 0x0200);\n\n\tif (par->Architecture >= NV_ARCH_40 && !par->FlatPanel)\n\t\tstate->control  = NV_RD32(par->PRAMDAC0, 0x0580);\n\n\tif (par->Architecture >= NV_ARCH_10) {\n\t\tif (par->twoHeads) {\n\t\t\tstate->head = NV_RD32(par->PCRTC0, 0x0860);\n\t\t\tstate->head2 = NV_RD32(par->PCRTC0, 0x2860);\n\t\t\tVGA_WR08(par->PCIO, 0x03D4, 0x44);\n\t\t\tstate->crtcOwner = VGA_RD08(par->PCIO, 0x03D5);\n\t\t}\n\t\tVGA_WR08(par->PCIO, 0x03D4, 0x41);\n\t\tstate->extra = VGA_RD08(par->PCIO, 0x03D5);\n\t\tstate->cursorConfig = NV_RD32(par->PCRTC, 0x0810);\n\n\t\tif ((par->Chipset & 0x0ff0) == 0x0110) {\n\t\t\tstate->dither = NV_RD32(par->PRAMDAC, 0x0528);\n\t\t} else if (par->twoHeads) {\n\t\t\tstate->dither = NV_RD32(par->PRAMDAC, 0x083C);\n\t\t}\n\n\t\tif (par->FlatPanel) {\n\t\t\tVGA_WR08(par->PCIO, 0x03D4, 0x53);\n\t\t\tstate->timingH = VGA_RD08(par->PCIO, 0x03D5);\n\t\t\tVGA_WR08(par->PCIO, 0x03D4, 0x54);\n\t\t\tstate->timingV = VGA_RD08(par->PCIO, 0x03D5);\n\t\t}\n\t}\n}\n\nvoid NVSetStartAddress(struct nvidia_par *par, u32 start)\n{\n\tNV_WR32(par->PCRTC, 0x800, start);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}