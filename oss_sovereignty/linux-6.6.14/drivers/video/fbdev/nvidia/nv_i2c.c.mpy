{
  "module_name": "nv_i2c.c",
  "hash_id": "a865d8c6b37da22e58b8ce0fadb0513c8fc2516050b913e8420ce33a9ac1f516",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/nvidia/nv_i2c.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <linux/pci.h>\n#include <linux/fb.h>\n\n#include <asm/io.h>\n\n#include \"nv_type.h\"\n#include \"nv_local.h\"\n#include \"nv_proto.h\"\n\n#include \"../edid.h\"\n\nstatic void nvidia_gpio_setscl(void *data, int state)\n{\n\tstruct nvidia_i2c_chan *chan = data;\n\tstruct nvidia_par *par = chan->par;\n\tu32 val;\n\n\tval = NVReadCrtc(par, chan->ddc_base + 1) & 0xf0;\n\n\tif (state)\n\t\tval |= 0x20;\n\telse\n\t\tval &= ~0x20;\n\n\tNVWriteCrtc(par, chan->ddc_base + 1, val | 0x01);\n}\n\nstatic void nvidia_gpio_setsda(void *data, int state)\n{\n\tstruct nvidia_i2c_chan *chan = data;\n\tstruct nvidia_par *par = chan->par;\n\tu32 val;\n\n\tval = NVReadCrtc(par, chan->ddc_base + 1) & 0xf0;\n\n\tif (state)\n\t\tval |= 0x10;\n\telse\n\t\tval &= ~0x10;\n\n\tNVWriteCrtc(par, chan->ddc_base + 1, val | 0x01);\n}\n\nstatic int nvidia_gpio_getscl(void *data)\n{\n\tstruct nvidia_i2c_chan *chan = data;\n\tstruct nvidia_par *par = chan->par;\n\tu32 val = 0;\n\n\tif (NVReadCrtc(par, chan->ddc_base) & 0x04)\n\t\tval = 1;\n\n\treturn val;\n}\n\nstatic int nvidia_gpio_getsda(void *data)\n{\n\tstruct nvidia_i2c_chan *chan = data;\n\tstruct nvidia_par *par = chan->par;\n\tu32 val = 0;\n\n\tif (NVReadCrtc(par, chan->ddc_base) & 0x08)\n\t\tval = 1;\n\n\treturn val;\n}\n\nstatic int nvidia_setup_i2c_bus(struct nvidia_i2c_chan *chan, const char *name,\n\t\t\t\tunsigned int i2c_class)\n{\n\tint rc;\n\n\tstrscpy(chan->adapter.name, name, sizeof(chan->adapter.name));\n\tchan->adapter.owner = THIS_MODULE;\n\tchan->adapter.class = i2c_class;\n\tchan->adapter.algo_data = &chan->algo;\n\tchan->adapter.dev.parent = &chan->par->pci_dev->dev;\n\tchan->algo.setsda = nvidia_gpio_setsda;\n\tchan->algo.setscl = nvidia_gpio_setscl;\n\tchan->algo.getsda = nvidia_gpio_getsda;\n\tchan->algo.getscl = nvidia_gpio_getscl;\n\tchan->algo.udelay = 40;\n\tchan->algo.timeout = msecs_to_jiffies(2);\n\tchan->algo.data = chan;\n\n\ti2c_set_adapdata(&chan->adapter, chan);\n\n\t \n\tnvidia_gpio_setsda(chan, 1);\n\tnvidia_gpio_setscl(chan, 1);\n\tudelay(20);\n\n\trc = i2c_bit_add_bus(&chan->adapter);\n\tif (rc == 0)\n\t\tdev_dbg(&chan->par->pci_dev->dev,\n\t\t\t\"I2C bus %s registered.\\n\", name);\n\telse {\n\t\tdev_warn(&chan->par->pci_dev->dev,\n\t\t\t \"Failed to register I2C bus %s.\\n\", name);\n\t\tchan->par = NULL;\n\t}\n\n\treturn rc;\n}\n\nvoid nvidia_create_i2c_busses(struct nvidia_par *par)\n{\n\tpar->chan[0].par = par;\n\tpar->chan[1].par = par;\n\tpar->chan[2].par = par;\n\n\tpar->chan[0].ddc_base = (par->reverse_i2c) ? 0x36 : 0x3e;\n \tnvidia_setup_i2c_bus(&par->chan[0], \"nvidia #0\",\n\t\t\t     (par->reverse_i2c) ? I2C_CLASS_HWMON : 0);\n\n\tpar->chan[1].ddc_base = (par->reverse_i2c) ? 0x3e : 0x36;\n \tnvidia_setup_i2c_bus(&par->chan[1], \"nvidia #1\",\n\t\t\t     (par->reverse_i2c) ? 0 : I2C_CLASS_HWMON);\n\n\tpar->chan[2].ddc_base = 0x50;\n \tnvidia_setup_i2c_bus(&par->chan[2], \"nvidia #2\", 0);\n}\n\nvoid nvidia_delete_i2c_busses(struct nvidia_par *par)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (!par->chan[i].par)\n\t\t\tcontinue;\n\t\ti2c_del_adapter(&par->chan[i].adapter);\n\t\tpar->chan[i].par = NULL;\n\t}\n}\n\nint nvidia_probe_i2c_connector(struct fb_info *info, int conn, u8 **out_edid)\n{\n\tstruct nvidia_par *par = info->par;\n\tu8 *edid = NULL;\n\n\tif (par->chan[conn - 1].par)\n\t\tedid = fb_ddc_read(&par->chan[conn - 1].adapter);\n\n\tif (!edid && conn == 1) {\n\t\t \n\t\tconst u8 *e = fb_firmware_edid(info->device);\n\n\t\tif (e != NULL)\n\t\t\tedid = kmemdup(e, EDID_LENGTH, GFP_KERNEL);\n\t}\n\n\t*out_edid = edid;\n\n\treturn (edid) ? 0 : 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}