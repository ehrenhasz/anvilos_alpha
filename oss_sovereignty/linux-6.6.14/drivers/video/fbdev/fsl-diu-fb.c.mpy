{
  "module_name": "fsl-diu-fb.c",
  "hash_id": "b8f0b341a0e6bce546d55bafb670655b7376a57aa89fcb0566bfbe6dc98c83f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/fsl-diu-fb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <sysdev/fsl_soc.h>\n#include <linux/fsl-diu-fb.h>\n#include \"edid.h\"\n\n#define NUM_AOIS\t5\t \n\n \n#define MAX_CURS\t\t32\n\n \n#define INT_VSYNC\t0x01\t \n#define INT_VSYNC_WB\t0x02\t \n#define INT_UNDRUN\t0x04\t \n#define INT_PARERR\t0x08\t \n#define INT_LS_BF_VS\t0x10\t \n\n \nstatic struct fb_videomode fsl_diu_mode_db[] = {\n\t{\n\t\t.refresh\t= 60,\n\t\t.xres\t\t= 1024,\n\t\t.yres\t\t= 768,\n\t\t.pixclock\t= 15385,\n\t\t.left_margin\t= 160,\n\t\t.right_margin\t= 24,\n\t\t.upper_margin\t= 29,\n\t\t.lower_margin\t= 3,\n\t\t.hsync_len\t= 136,\n\t\t.vsync_len\t= 6,\n\t\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode\t\t= FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh\t= 60,\n\t\t.xres\t\t= 320,\n\t\t.yres\t\t= 240,\n\t\t.pixclock\t= 79440,\n\t\t.left_margin\t= 16,\n\t\t.right_margin\t= 16,\n\t\t.upper_margin\t= 16,\n\t\t.lower_margin\t= 5,\n\t\t.hsync_len\t= 48,\n\t\t.vsync_len\t= 1,\n\t\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode\t\t= FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh        = 60,\n\t\t.xres           = 640,\n\t\t.yres           = 480,\n\t\t.pixclock       = 39722,\n\t\t.left_margin    = 48,\n\t\t.right_margin   = 16,\n\t\t.upper_margin   = 33,\n\t\t.lower_margin   = 10,\n\t\t.hsync_len      = 96,\n\t\t.vsync_len      = 2,\n\t\t.sync           = FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode          = FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh        = 72,\n\t\t.xres           = 640,\n\t\t.yres           = 480,\n\t\t.pixclock       = 32052,\n\t\t.left_margin    = 128,\n\t\t.right_margin   = 24,\n\t\t.upper_margin   = 28,\n\t\t.lower_margin   = 9,\n\t\t.hsync_len      = 40,\n\t\t.vsync_len      = 3,\n\t\t.sync           = FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode          = FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh        = 75,\n\t\t.xres           = 640,\n\t\t.yres           = 480,\n\t\t.pixclock       = 31747,\n\t\t.left_margin    = 120,\n\t\t.right_margin   = 16,\n\t\t.upper_margin   = 16,\n\t\t.lower_margin   = 1,\n\t\t.hsync_len      = 64,\n\t\t.vsync_len      = 3,\n\t\t.sync           = FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode          = FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh        = 90,\n\t\t.xres           = 640,\n\t\t.yres           = 480,\n\t\t.pixclock       = 25057,\n\t\t.left_margin    = 120,\n\t\t.right_margin   = 32,\n\t\t.upper_margin   = 14,\n\t\t.lower_margin   = 25,\n\t\t.hsync_len      = 40,\n\t\t.vsync_len      = 14,\n\t\t.sync           = FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode          = FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh        = 100,\n\t\t.xres           = 640,\n\t\t.yres           = 480,\n\t\t.pixclock       = 22272,\n\t\t.left_margin    = 48,\n\t\t.right_margin   = 32,\n\t\t.upper_margin   = 17,\n\t\t.lower_margin   = 22,\n\t\t.hsync_len      = 128,\n\t\t.vsync_len      = 12,\n\t\t.sync           = FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode          = FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh\t= 60,\n\t\t.xres\t\t= 800,\n\t\t.yres\t\t= 480,\n\t\t.pixclock\t= 33805,\n\t\t.left_margin\t= 96,\n\t\t.right_margin\t= 24,\n\t\t.upper_margin\t= 10,\n\t\t.lower_margin\t= 3,\n\t\t.hsync_len\t= 72,\n\t\t.vsync_len\t= 7,\n\t\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode\t\t= FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh        = 60,\n\t\t.xres           = 800,\n\t\t.yres           = 600,\n\t\t.pixclock       = 25000,\n\t\t.left_margin    = 88,\n\t\t.right_margin   = 40,\n\t\t.upper_margin   = 23,\n\t\t.lower_margin   = 1,\n\t\t.hsync_len      = 128,\n\t\t.vsync_len      = 4,\n\t\t.sync           = FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode          = FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh\t= 60,\n\t\t.xres\t\t= 854,\n\t\t.yres\t\t= 480,\n\t\t.pixclock\t= 31518,\n\t\t.left_margin\t= 104,\n\t\t.right_margin\t= 16,\n\t\t.upper_margin\t= 13,\n\t\t.lower_margin\t= 1,\n\t\t.hsync_len\t= 88,\n\t\t.vsync_len\t= 3,\n\t\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode\t\t= FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh\t= 70,\n\t\t.xres\t\t= 1024,\n\t\t.yres\t\t= 768,\n\t\t.pixclock\t= 16886,\n\t\t.left_margin\t= 3,\n\t\t.right_margin\t= 3,\n\t\t.upper_margin\t= 2,\n\t\t.lower_margin\t= 2,\n\t\t.hsync_len\t= 40,\n\t\t.vsync_len\t= 18,\n\t\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode\t\t= FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh\t= 75,\n\t\t.xres\t\t= 1024,\n\t\t.yres\t\t= 768,\n\t\t.pixclock\t= 15009,\n\t\t.left_margin\t= 3,\n\t\t.right_margin\t= 3,\n\t\t.upper_margin\t= 2,\n\t\t.lower_margin\t= 2,\n\t\t.hsync_len\t= 80,\n\t\t.vsync_len\t= 32,\n\t\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode\t\t= FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh\t= 60,\n\t\t.xres\t\t= 1280,\n\t\t.yres\t\t= 480,\n\t\t.pixclock\t= 18939,\n\t\t.left_margin\t= 353,\n\t\t.right_margin\t= 47,\n\t\t.upper_margin\t= 39,\n\t\t.lower_margin\t= 4,\n\t\t.hsync_len\t= 8,\n\t\t.vsync_len\t= 2,\n\t\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode\t\t= FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh\t= 60,\n\t\t.xres\t\t= 1280,\n\t\t.yres\t\t= 720,\n\t\t.pixclock\t= 13426,\n\t\t.left_margin\t= 192,\n\t\t.right_margin\t= 64,\n\t\t.upper_margin\t= 22,\n\t\t.lower_margin\t= 1,\n\t\t.hsync_len\t= 136,\n\t\t.vsync_len\t= 3,\n\t\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode\t\t= FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh\t= 60,\n\t\t.xres\t\t= 1280,\n\t\t.yres\t\t= 1024,\n\t\t.pixclock\t= 9375,\n\t\t.left_margin\t= 38,\n\t\t.right_margin\t= 128,\n\t\t.upper_margin\t= 2,\n\t\t.lower_margin\t= 7,\n\t\t.hsync_len\t= 216,\n\t\t.vsync_len\t= 37,\n\t\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode\t\t= FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh\t= 70,\n\t\t.xres\t\t= 1280,\n\t\t.yres\t\t= 1024,\n\t\t.pixclock\t= 9380,\n\t\t.left_margin\t= 6,\n\t\t.right_margin\t= 6,\n\t\t.upper_margin\t= 4,\n\t\t.lower_margin\t= 4,\n\t\t.hsync_len\t= 60,\n\t\t.vsync_len\t= 94,\n\t\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode\t\t= FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh\t= 75,\n\t\t.xres\t\t= 1280,\n\t\t.yres\t\t= 1024,\n\t\t.pixclock\t= 9380,\n\t\t.left_margin\t= 6,\n\t\t.right_margin\t= 6,\n\t\t.upper_margin\t= 4,\n\t\t.lower_margin\t= 4,\n\t\t.hsync_len\t= 60,\n\t\t.vsync_len\t= 15,\n\t\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode\t\t= FB_VMODE_NONINTERLACED\n\t},\n\t{\n\t\t.refresh\t= 60,\n\t\t.xres\t\t= 1920,\n\t\t.yres\t\t= 1080,\n\t\t.pixclock\t= 5787,\n\t\t.left_margin\t= 328,\n\t\t.right_margin\t= 120,\n\t\t.upper_margin\t= 34,\n\t\t.lower_margin\t= 1,\n\t\t.hsync_len\t= 208,\n\t\t.vsync_len\t= 3,\n\t\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t\t.vmode\t\t= FB_VMODE_NONINTERLACED\n\t},\n};\n\nstatic char *fb_mode;\nstatic unsigned long default_bpp = 32;\nstatic enum fsl_diu_monitor_port monitor_port;\nstatic char *monitor_string;\n\n#if defined(CONFIG_NOT_COHERENT_CACHE)\nstatic u8 *coherence_data;\nstatic size_t coherence_data_size;\nstatic unsigned int d_cache_line_size;\n#endif\n\nstatic DEFINE_SPINLOCK(diu_lock);\n\nenum mfb_index {\n\tPLANE0 = 0,\t \n\tPLANE1_AOI0,\t \n\tPLANE1_AOI1,\t \n\tPLANE2_AOI0,\t \n\tPLANE2_AOI1,\t \n};\n\nstruct mfb_info {\n\tenum mfb_index index;\n\tchar *id;\n\tint registered;\n\tunsigned long pseudo_palette[16];\n\tstruct diu_ad *ad;\n\tunsigned char g_alpha;\n\tunsigned int count;\n\tint x_aoi_d;\t\t \n\tint y_aoi_d;\t\t \n\tstruct fsl_diu_data *parent;\n};\n\n \nstruct fsl_diu_data {\n\tdma_addr_t dma_addr;\n\tstruct fb_info fsl_diu_info[NUM_AOIS];\n\tstruct mfb_info mfb[NUM_AOIS];\n\tstruct device_attribute dev_attr;\n\tunsigned int irq;\n\tenum fsl_diu_monitor_port monitor_port;\n\tstruct diu __iomem *diu_reg;\n\tspinlock_t reg_lock;\n\tu8 dummy_aoi[4 * 4 * 4];\n\tstruct diu_ad dummy_ad __aligned(8);\n\tstruct diu_ad ad[NUM_AOIS] __aligned(8);\n\tu8 gamma[256 * 3] __aligned(32);\n\t \n\t__le16 cursor[MAX_CURS * MAX_CURS] __aligned(32);\n\t \n\t__le16 blank_cursor[MAX_CURS * MAX_CURS] __aligned(32);\n\t \n\t__le16 next_cursor[MAX_CURS * MAX_CURS] __aligned(32);\n\tuint8_t edid_data[EDID_LENGTH];\n\tbool has_edid;\n} __aligned(32);\n\n \n#define DMA_ADDR(p, f) ((p)->dma_addr + offsetof(struct fsl_diu_data, f))\n\nstatic const struct mfb_info mfb_template[] = {\n\t{\n\t\t.index = PLANE0,\n\t\t.id = \"Panel0\",\n\t\t.registered = 0,\n\t\t.count = 0,\n\t\t.x_aoi_d = 0,\n\t\t.y_aoi_d = 0,\n\t},\n\t{\n\t\t.index = PLANE1_AOI0,\n\t\t.id = \"Panel1 AOI0\",\n\t\t.registered = 0,\n\t\t.g_alpha = 0xff,\n\t\t.count = 0,\n\t\t.x_aoi_d = 0,\n\t\t.y_aoi_d = 0,\n\t},\n\t{\n\t\t.index = PLANE1_AOI1,\n\t\t.id = \"Panel1 AOI1\",\n\t\t.registered = 0,\n\t\t.g_alpha = 0xff,\n\t\t.count = 0,\n\t\t.x_aoi_d = 0,\n\t\t.y_aoi_d = 480,\n\t},\n\t{\n\t\t.index = PLANE2_AOI0,\n\t\t.id = \"Panel2 AOI0\",\n\t\t.registered = 0,\n\t\t.g_alpha = 0xff,\n\t\t.count = 0,\n\t\t.x_aoi_d = 640,\n\t\t.y_aoi_d = 0,\n\t},\n\t{\n\t\t.index = PLANE2_AOI1,\n\t\t.id = \"Panel2 AOI1\",\n\t\t.registered = 0,\n\t\t.g_alpha = 0xff,\n\t\t.count = 0,\n\t\t.x_aoi_d = 640,\n\t\t.y_aoi_d = 480,\n\t},\n};\n\n#ifdef DEBUG\nstatic void __attribute__ ((unused)) fsl_diu_dump(struct diu __iomem *hw)\n{\n\tmb();\n\tpr_debug(\"DIU: desc=%08x,%08x,%08x, gamma=%08x palette=%08x \"\n\t\t \"cursor=%08x curs_pos=%08x diu_mode=%08x bgnd=%08x \"\n\t\t \"disp_size=%08x hsyn_para=%08x vsyn_para=%08x syn_pol=%08x \"\n\t\t \"thresholds=%08x int_mask=%08x plut=%08x\\n\",\n\t\t hw->desc[0], hw->desc[1], hw->desc[2], hw->gamma,\n\t\t hw->palette, hw->cursor, hw->curs_pos, hw->diu_mode,\n\t\t hw->bgnd, hw->disp_size, hw->hsyn_para, hw->vsyn_para,\n\t\t hw->syn_pol, hw->thresholds, hw->int_mask, hw->plut);\n\trmb();\n}\n#endif\n\n \nstatic enum fsl_diu_monitor_port fsl_diu_name_to_port(const char *s)\n{\n\tenum fsl_diu_monitor_port port = FSL_DIU_PORT_DVI;\n\tunsigned long val;\n\n\tif (s) {\n\t\tif (!kstrtoul(s, 10, &val) && (val <= 2))\n\t\t\tport = (enum fsl_diu_monitor_port) val;\n\t\telse if (strncmp(s, \"lvds\", 4) == 0)\n\t\t\tport = FSL_DIU_PORT_LVDS;\n\t\telse if (strncmp(s, \"dlvds\", 5) == 0)\n\t\t\tport = FSL_DIU_PORT_DLVDS;\n\t}\n\n\tif (diu_ops.valid_monitor_port)\n\t\tport = diu_ops.valid_monitor_port(port);\n\n\treturn port;\n}\n\n \nstatic void wr_reg_wa(u32 *reg, u32 val)\n{\n\tdo {\n\t\tout_be32(reg, val);\n\t} while (in_be32(reg) != val);\n}\n\nstatic void fsl_diu_enable_panel(struct fb_info *info)\n{\n\tstruct mfb_info *pmfbi, *cmfbi, *mfbi = info->par;\n\tstruct diu_ad *ad = mfbi->ad;\n\tstruct fsl_diu_data *data = mfbi->parent;\n\tstruct diu __iomem *hw = data->diu_reg;\n\n\tswitch (mfbi->index) {\n\tcase PLANE0:\n\t\twr_reg_wa(&hw->desc[0], ad->paddr);\n\t\tbreak;\n\tcase PLANE1_AOI0:\n\t\tcmfbi = &data->mfb[2];\n\t\tif (hw->desc[1] != ad->paddr) {\t \n\t\t\tif (cmfbi->count > 0)\t \n\t\t\t\tad->next_ad =\n\t\t\t\t\tcpu_to_le32(cmfbi->ad->paddr);\n\t\t\telse\n\t\t\t\tad->next_ad = 0;\n\t\t\twr_reg_wa(&hw->desc[1], ad->paddr);\n\t\t}\n\t\tbreak;\n\tcase PLANE2_AOI0:\n\t\tcmfbi = &data->mfb[4];\n\t\tif (hw->desc[2] != ad->paddr) {\t \n\t\t\tif (cmfbi->count > 0)\t \n\t\t\t\tad->next_ad =\n\t\t\t\t\tcpu_to_le32(cmfbi->ad->paddr);\n\t\t\telse\n\t\t\t\tad->next_ad = 0;\n\t\t\twr_reg_wa(&hw->desc[2], ad->paddr);\n\t\t}\n\t\tbreak;\n\tcase PLANE1_AOI1:\n\t\tpmfbi = &data->mfb[1];\n\t\tad->next_ad = 0;\n\t\tif (hw->desc[1] == data->dummy_ad.paddr)\n\t\t\twr_reg_wa(&hw->desc[1], ad->paddr);\n\t\telse\t\t\t\t\t \n\t\t\tpmfbi->ad->next_ad = cpu_to_le32(ad->paddr);\n\t\tbreak;\n\tcase PLANE2_AOI1:\n\t\tpmfbi = &data->mfb[3];\n\t\tad->next_ad = 0;\n\t\tif (hw->desc[2] == data->dummy_ad.paddr)\n\t\t\twr_reg_wa(&hw->desc[2], ad->paddr);\n\t\telse\t\t\t\t \n\t\t\tpmfbi->ad->next_ad = cpu_to_le32(ad->paddr);\n\t\tbreak;\n\t}\n}\n\nstatic void fsl_diu_disable_panel(struct fb_info *info)\n{\n\tstruct mfb_info *pmfbi, *cmfbi, *mfbi = info->par;\n\tstruct diu_ad *ad = mfbi->ad;\n\tstruct fsl_diu_data *data = mfbi->parent;\n\tstruct diu __iomem *hw = data->diu_reg;\n\n\tswitch (mfbi->index) {\n\tcase PLANE0:\n\t\twr_reg_wa(&hw->desc[0], 0);\n\t\tbreak;\n\tcase PLANE1_AOI0:\n\t\tcmfbi = &data->mfb[2];\n\t\tif (cmfbi->count > 0)\t \n\t\t\twr_reg_wa(&hw->desc[1], cmfbi->ad->paddr);\n\t\t\t\t\t \n\t\telse\t\t\t \n\t\t\twr_reg_wa(&hw->desc[1], data->dummy_ad.paddr);\n\t\t\t\t\t \n\t\tbreak;\n\tcase PLANE2_AOI0:\n\t\tcmfbi = &data->mfb[4];\n\t\tif (cmfbi->count > 0)\t \n\t\t\twr_reg_wa(&hw->desc[2], cmfbi->ad->paddr);\n\t\t\t\t\t \n\t\telse\t\t\t \n\t\t\twr_reg_wa(&hw->desc[2], data->dummy_ad.paddr);\n\t\t\t\t\t \n\t\tbreak;\n\tcase PLANE1_AOI1:\n\t\tpmfbi = &data->mfb[1];\n\t\tif (hw->desc[1] != ad->paddr) {\n\t\t\t\t \n\t\t\tif (pmfbi->count > 0)\n\t\t\t\t\t \n\t\t\t\tpmfbi->ad->next_ad = 0;\n\t\t} else\t\t\t \n\t\t\twr_reg_wa(&hw->desc[1], data->dummy_ad.paddr);\n\t\t\t\t\t \n\t\tbreak;\n\tcase PLANE2_AOI1:\n\t\tpmfbi = &data->mfb[3];\n\t\tif (hw->desc[2] != ad->paddr) {\n\t\t\t\t \n\t\t\tif (pmfbi->count > 0)\n\t\t\t\t \n\t\t\t\tpmfbi->ad->next_ad = 0;\n\t\t} else\t\t \n\t\t\twr_reg_wa(&hw->desc[2], data->dummy_ad.paddr);\n\t\t\t\t \n\t\tbreak;\n\t}\n}\n\nstatic void enable_lcdc(struct fb_info *info)\n{\n\tstruct mfb_info *mfbi = info->par;\n\tstruct fsl_diu_data *data = mfbi->parent;\n\tstruct diu __iomem *hw = data->diu_reg;\n\n\tout_be32(&hw->diu_mode, MFB_MODE1);\n}\n\nstatic void disable_lcdc(struct fb_info *info)\n{\n\tstruct mfb_info *mfbi = info->par;\n\tstruct fsl_diu_data *data = mfbi->parent;\n\tstruct diu __iomem *hw = data->diu_reg;\n\n\tout_be32(&hw->diu_mode, 0);\n}\n\nstatic void adjust_aoi_size_position(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info)\n{\n\tstruct mfb_info *lower_aoi_mfbi, *upper_aoi_mfbi, *mfbi = info->par;\n\tstruct fsl_diu_data *data = mfbi->parent;\n\tint available_height, upper_aoi_bottom;\n\tenum mfb_index index = mfbi->index;\n\tint lower_aoi_is_open, upper_aoi_is_open;\n\t__u32 base_plane_width, base_plane_height, upper_aoi_height;\n\n\tbase_plane_width = data->fsl_diu_info[0].var.xres;\n\tbase_plane_height = data->fsl_diu_info[0].var.yres;\n\n\tif (mfbi->x_aoi_d < 0)\n\t\tmfbi->x_aoi_d = 0;\n\tif (mfbi->y_aoi_d < 0)\n\t\tmfbi->y_aoi_d = 0;\n\tswitch (index) {\n\tcase PLANE0:\n\t\tif (mfbi->x_aoi_d != 0)\n\t\t\tmfbi->x_aoi_d = 0;\n\t\tif (mfbi->y_aoi_d != 0)\n\t\t\tmfbi->y_aoi_d = 0;\n\t\tbreak;\n\tcase PLANE1_AOI0:\n\tcase PLANE2_AOI0:\n\t\tlower_aoi_mfbi = data->fsl_diu_info[index+1].par;\n\t\tlower_aoi_is_open = lower_aoi_mfbi->count > 0 ? 1 : 0;\n\t\tif (var->xres > base_plane_width)\n\t\t\tvar->xres = base_plane_width;\n\t\tif ((mfbi->x_aoi_d + var->xres) > base_plane_width)\n\t\t\tmfbi->x_aoi_d = base_plane_width - var->xres;\n\n\t\tif (lower_aoi_is_open)\n\t\t\tavailable_height = lower_aoi_mfbi->y_aoi_d;\n\t\telse\n\t\t\tavailable_height = base_plane_height;\n\t\tif (var->yres > available_height)\n\t\t\tvar->yres = available_height;\n\t\tif ((mfbi->y_aoi_d + var->yres) > available_height)\n\t\t\tmfbi->y_aoi_d = available_height - var->yres;\n\t\tbreak;\n\tcase PLANE1_AOI1:\n\tcase PLANE2_AOI1:\n\t\tupper_aoi_mfbi = data->fsl_diu_info[index-1].par;\n\t\tupper_aoi_height = data->fsl_diu_info[index-1].var.yres;\n\t\tupper_aoi_bottom = upper_aoi_mfbi->y_aoi_d + upper_aoi_height;\n\t\tupper_aoi_is_open = upper_aoi_mfbi->count > 0 ? 1 : 0;\n\t\tif (var->xres > base_plane_width)\n\t\t\tvar->xres = base_plane_width;\n\t\tif ((mfbi->x_aoi_d + var->xres) > base_plane_width)\n\t\t\tmfbi->x_aoi_d = base_plane_width - var->xres;\n\t\tif (mfbi->y_aoi_d < 0)\n\t\t\tmfbi->y_aoi_d = 0;\n\t\tif (upper_aoi_is_open) {\n\t\t\tif (mfbi->y_aoi_d < upper_aoi_bottom)\n\t\t\t\tmfbi->y_aoi_d = upper_aoi_bottom;\n\t\t\tavailable_height = base_plane_height\n\t\t\t\t\t\t- upper_aoi_bottom;\n\t\t} else\n\t\t\tavailable_height = base_plane_height;\n\t\tif (var->yres > available_height)\n\t\t\tvar->yres = available_height;\n\t\tif ((mfbi->y_aoi_d + var->yres) > base_plane_height)\n\t\t\tmfbi->y_aoi_d = base_plane_height - var->yres;\n\t\tbreak;\n\t}\n}\n \nstatic int fsl_diu_check_var(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info)\n{\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres_virtual = var->yres;\n\n\tif (var->xoffset + info->var.xres > info->var.xres_virtual)\n\t\tvar->xoffset = info->var.xres_virtual - info->var.xres;\n\n\tif (var->yoffset + info->var.yres > info->var.yres_virtual)\n\t\tvar->yoffset = info->var.yres_virtual - info->var.yres;\n\n\tif ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&\n\t    (var->bits_per_pixel != 16))\n\t\tvar->bits_per_pixel = default_bpp;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 16:\n\t\tvar->red.length = 5;\n\t\tvar->red.offset = 11;\n\t\tvar->red.msb_right = 0;\n\n\t\tvar->green.length = 6;\n\t\tvar->green.offset = 5;\n\t\tvar->green.msb_right = 0;\n\n\t\tvar->blue.length = 5;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.msb_right = 0;\n\n\t\tvar->transp.length = 0;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.msb_right = 0;\n\t\tbreak;\n\tcase 24:\n\t\tvar->red.length = 8;\n\t\tvar->red.offset = 0;\n\t\tvar->red.msb_right = 0;\n\n\t\tvar->green.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.msb_right = 0;\n\n\t\tvar->blue.length = 8;\n\t\tvar->blue.offset = 16;\n\t\tvar->blue.msb_right = 0;\n\n\t\tvar->transp.length = 0;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.msb_right = 0;\n\t\tbreak;\n\tcase 32:\n\t\tvar->red.length = 8;\n\t\tvar->red.offset = 16;\n\t\tvar->red.msb_right = 0;\n\n\t\tvar->green.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.msb_right = 0;\n\n\t\tvar->blue.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.msb_right = 0;\n\n\t\tvar->transp.length = 8;\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.msb_right = 0;\n\n\t\tbreak;\n\t}\n\n\tvar->height = -1;\n\tvar->width = -1;\n\tvar->grayscale = 0;\n\n\t \n\tvar->sync |= var->nonstd;\n\tvar->nonstd |= var->sync;\n\n\tadjust_aoi_size_position(var, info);\n\treturn 0;\n}\n\nstatic void set_fix(struct fb_info *info)\n{\n\tstruct fb_fix_screeninfo *fix = &info->fix;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tstruct mfb_info *mfbi = info->par;\n\n\tstrncpy(fix->id, mfbi->id, sizeof(fix->id));\n\tfix->line_length = var->xres_virtual * var->bits_per_pixel / 8;\n\tfix->type = FB_TYPE_PACKED_PIXELS;\n\tfix->accel = FB_ACCEL_NONE;\n\tfix->visual = FB_VISUAL_TRUECOLOR;\n\tfix->xpanstep = 1;\n\tfix->ypanstep = 1;\n}\n\nstatic void update_lcdc(struct fb_info *info)\n{\n\tstruct fb_var_screeninfo *var = &info->var;\n\tstruct mfb_info *mfbi = info->par;\n\tstruct fsl_diu_data *data = mfbi->parent;\n\tstruct diu __iomem *hw;\n\tint i, j;\n\tu8 *gamma_table_base;\n\n\tu32 temp;\n\n\thw = data->diu_reg;\n\n\tif (diu_ops.set_monitor_port)\n\t\tdiu_ops.set_monitor_port(data->monitor_port);\n\tgamma_table_base = data->gamma;\n\n\t \n\n\tfor (i = 0; i <= 2; i++)\n\t\tfor (j = 0; j <= 255; j++)\n\t\t\t*gamma_table_base++ = j;\n\n\tif (diu_ops.set_gamma_table)\n\t\tdiu_ops.set_gamma_table(data->monitor_port, data->gamma);\n\n\tdisable_lcdc(info);\n\n\t \n\n\tout_be32(&hw->gamma, DMA_ADDR(data, gamma));\n\n\tout_be32(&hw->bgnd, 0x007F7F7F);  \n\tout_be32(&hw->disp_size, (var->yres << 16) | var->xres);\n\n\t \n\ttemp = var->left_margin << 22 |  \n\t       var->hsync_len << 11 |    \n\t       var->right_margin;        \n\n\tout_be32(&hw->hsyn_para, temp);\n\n\ttemp = var->upper_margin << 22 |  \n\t       var->vsync_len << 11 |     \n\t       var->lower_margin;         \n\n\tout_be32(&hw->vsyn_para, temp);\n\n\tdiu_ops.set_pixel_clock(var->pixclock);\n\n#ifndef CONFIG_PPC_MPC512x\n\t \n\tout_be32(&hw->plut, 0x01F5F666);\n#endif\n\n\t \n\tenable_lcdc(info);\n}\n\nstatic int map_video_memory(struct fb_info *info)\n{\n\tu32 smem_len = info->fix.line_length * info->var.yres_virtual;\n\tvoid *p;\n\n\tp = alloc_pages_exact(smem_len, GFP_DMA | __GFP_ZERO);\n\tif (!p) {\n\t\tfb_err(info, \"unable to allocate fb memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmutex_lock(&info->mm_lock);\n\tinfo->screen_base = p;\n\tinfo->fix.smem_start = virt_to_phys(info->screen_base);\n\tinfo->fix.smem_len = smem_len;\n\tmutex_unlock(&info->mm_lock);\n\tinfo->screen_size = info->fix.smem_len;\n\n\treturn 0;\n}\n\nstatic void unmap_video_memory(struct fb_info *info)\n{\n\tvoid *p = info->screen_base;\n\tsize_t l = info->fix.smem_len;\n\n\tmutex_lock(&info->mm_lock);\n\tinfo->screen_base = NULL;\n\tinfo->fix.smem_start = 0;\n\tinfo->fix.smem_len = 0;\n\tmutex_unlock(&info->mm_lock);\n\n\tif (p)\n\t\tfree_pages_exact(p, l);\n}\n\n \nstatic int fsl_diu_set_aoi(struct fb_info *info)\n{\n\tstruct fb_var_screeninfo *var = &info->var;\n\tstruct mfb_info *mfbi = info->par;\n\tstruct diu_ad *ad = mfbi->ad;\n\n\t \n\tad->offset_xyi = cpu_to_le32((var->yoffset << 16) | var->xoffset);\n\tad->offset_xyd = cpu_to_le32((mfbi->y_aoi_d << 16) | mfbi->x_aoi_d);\n\treturn 0;\n}\n\n \nstatic u32 fsl_diu_get_pixel_format(unsigned int bits_per_pixel)\n{\n#define PF_BYTE_F\t\t0x10000000\n#define PF_ALPHA_C_MASK\t\t0x0E000000\n#define PF_ALPHA_C_SHIFT\t25\n#define PF_BLUE_C_MASK\t\t0x01800000\n#define PF_BLUE_C_SHIFT\t\t23\n#define PF_GREEN_C_MASK\t\t0x00600000\n#define PF_GREEN_C_SHIFT\t21\n#define PF_RED_C_MASK\t\t0x00180000\n#define PF_RED_C_SHIFT\t\t19\n#define PF_PALETTE\t\t0x00040000\n#define PF_PIXEL_S_MASK\t\t0x00030000\n#define PF_PIXEL_S_SHIFT\t16\n#define PF_COMP_3_MASK\t\t0x0000F000\n#define PF_COMP_3_SHIFT\t\t12\n#define PF_COMP_2_MASK\t\t0x00000F00\n#define PF_COMP_2_SHIFT\t\t8\n#define PF_COMP_1_MASK\t\t0x000000F0\n#define PF_COMP_1_SHIFT\t\t4\n#define PF_COMP_0_MASK\t\t0x0000000F\n#define PF_COMP_0_SHIFT\t\t0\n\n#define MAKE_PF(alpha, red, green, blue, size, c0, c1, c2, c3) \\\n\tcpu_to_le32(PF_BYTE_F | (alpha << PF_ALPHA_C_SHIFT) | \\\n\t(blue << PF_BLUE_C_SHIFT) | (green << PF_GREEN_C_SHIFT) | \\\n\t(red << PF_RED_C_SHIFT) | (c3 << PF_COMP_3_SHIFT) | \\\n\t(c2 << PF_COMP_2_SHIFT) | (c1 << PF_COMP_1_SHIFT) | \\\n\t(c0 << PF_COMP_0_SHIFT) | (size << PF_PIXEL_S_SHIFT))\n\n\tswitch (bits_per_pixel) {\n\tcase 32:\n\t\t \n\t\treturn MAKE_PF(3, 2, 1, 0, 3, 8, 8, 8, 8);\n\tcase 24:\n\t\t \n\t\treturn MAKE_PF(4, 0, 1, 2, 2, 8, 8, 8, 0);\n\tcase 16:\n\t\t \n\t\treturn MAKE_PF(4, 2, 1, 0, 1, 5, 6, 5, 0);\n\tdefault:\n\t\tpr_err(\"fsl-diu: unsupported color depth %u\\n\", bits_per_pixel);\n\t\treturn 0;\n\t}\n}\n\n \nstatic void fsl_diu_load_cursor_image(struct fb_info *info,\n\tconst void *image, uint16_t bg, uint16_t fg,\n\tunsigned int width, unsigned int height)\n{\n\tstruct mfb_info *mfbi = info->par;\n\tstruct fsl_diu_data *data = mfbi->parent;\n\t__le16 *cursor = data->cursor;\n\t__le16 _fg = cpu_to_le16(fg);\n\t__le16 _bg = cpu_to_le16(bg);\n\tunsigned int h, w;\n\n\tfor (h = 0; h < height; h++) {\n\t\tuint32_t mask = 1 << 31;\n\t\tuint32_t line = be32_to_cpup(image);\n\n\t\tfor (w = 0; w < width; w++) {\n\t\t\tcursor[w] = (line & mask) ? _fg : _bg;\n\t\t\tmask >>= 1;\n\t\t}\n\n\t\tcursor += MAX_CURS;\n\t\timage += DIV_ROUND_UP(width, 8);\n\t}\n}\n\n \nstatic int fsl_diu_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\tstruct mfb_info *mfbi = info->par;\n\tstruct fsl_diu_data *data = mfbi->parent;\n\tstruct diu __iomem *hw = data->diu_reg;\n\n\tif (cursor->image.width > MAX_CURS || cursor->image.height > MAX_CURS)\n\t\treturn -EINVAL;\n\n\t \n\tif (cursor->set & FB_CUR_SETSIZE) {\n\t\t \n\t\tmemset(data->cursor, 0, sizeof(data->cursor));\n\t}\n\n\t \n\tif (cursor->set & FB_CUR_SETPOS) {\n\t\tuint32_t xx, yy;\n\n\t\tyy = (cursor->image.dy - info->var.yoffset) & 0x7ff;\n\t\txx = (cursor->image.dx - info->var.xoffset) & 0x7ff;\n\n\t\tout_be32(&hw->curs_pos, yy << 16 | xx);\n\t}\n\n\t \n\tif (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETCMAP | FB_CUR_SETIMAGE)) {\n\t\t \n\t\tunsigned int image_size =\n\t\t\tDIV_ROUND_UP(cursor->image.width, 8) *\n\t\t\tcursor->image.height;\n\t\tunsigned int image_words =\n\t\t\tDIV_ROUND_UP(image_size, sizeof(uint32_t));\n\t\tunsigned int bg_idx = cursor->image.bg_color;\n\t\tunsigned int fg_idx = cursor->image.fg_color;\n\t\tuint32_t *image, *source, *mask;\n\t\tuint16_t fg, bg;\n\t\tunsigned int i;\n\n\t\tif (info->state != FBINFO_STATE_RUNNING)\n\t\t\treturn 0;\n\n\t\tbg = ((info->cmap.red[bg_idx] & 0xf8) << 7) |\n\t\t     ((info->cmap.green[bg_idx] & 0xf8) << 2) |\n\t\t     ((info->cmap.blue[bg_idx] & 0xf8) >> 3) |\n\t\t     1 << 15;\n\n\t\tfg = ((info->cmap.red[fg_idx] & 0xf8) << 7) |\n\t\t     ((info->cmap.green[fg_idx] & 0xf8) << 2) |\n\t\t     ((info->cmap.blue[fg_idx] & 0xf8) >> 3) |\n\t\t     1 << 15;\n\n\t\t \n\t\timage = (uint32_t *)data->next_cursor;\n\t\tsource = (uint32_t *)cursor->image.data;\n\t\tmask = (uint32_t *)cursor->mask;\n\n\t\tif (cursor->rop == ROP_XOR)\n\t\t\tfor (i = 0; i < image_words; i++)\n\t\t\t\timage[i] = source[i] ^ mask[i];\n\t\telse\n\t\t\tfor (i = 0; i < image_words; i++)\n\t\t\t\timage[i] = source[i] & mask[i];\n\n\t\tfsl_diu_load_cursor_image(info, image, bg, fg,\n\t\t\tcursor->image.width, cursor->image.height);\n\t}\n\n\t \n\tif (cursor->enable)\n\t\tout_be32(&hw->cursor, DMA_ADDR(data, cursor));\n\telse\n\t\tout_be32(&hw->cursor, DMA_ADDR(data, blank_cursor));\n\n\treturn 0;\n}\n\n \nstatic int fsl_diu_set_par(struct fb_info *info)\n{\n\tunsigned long len;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tstruct mfb_info *mfbi = info->par;\n\tstruct fsl_diu_data *data = mfbi->parent;\n\tstruct diu_ad *ad = mfbi->ad;\n\tstruct diu __iomem *hw;\n\n\thw = data->diu_reg;\n\n\tset_fix(info);\n\n\tlen = info->var.yres_virtual * info->fix.line_length;\n\t \n\tif (len != info->fix.smem_len) {\n\t\tif (info->fix.smem_start)\n\t\t\tunmap_video_memory(info);\n\n\t\t \n\t\tif (map_video_memory(info)) {\n\t\t\tfb_err(info, \"unable to allocate fb memory 1\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (diu_ops.get_pixel_format)\n\t\tad->pix_fmt = diu_ops.get_pixel_format(data->monitor_port,\n\t\t\t\t\t\t       var->bits_per_pixel);\n\telse\n\t\tad->pix_fmt = fsl_diu_get_pixel_format(var->bits_per_pixel);\n\n\tad->addr    = cpu_to_le32(info->fix.smem_start);\n\tad->src_size_g_alpha = cpu_to_le32((var->yres_virtual << 12) |\n\t\t\t\tvar->xres_virtual) | mfbi->g_alpha;\n\t \n\tad->aoi_size \t= cpu_to_le32((var->yres << 16) | var->xres);\n\tad->offset_xyi = cpu_to_le32((var->yoffset << 16) | var->xoffset);\n\tad->offset_xyd = cpu_to_le32((mfbi->y_aoi_d << 16) | mfbi->x_aoi_d);\n\n\t \n\tad->ckmax_r = 0;\n\tad->ckmax_g = 0;\n\tad->ckmax_b = 0;\n\n\tad->ckmin_r = 255;\n\tad->ckmin_g = 255;\n\tad->ckmin_b = 255;\n\n\tif (mfbi->index == PLANE0)\n\t\tupdate_lcdc(info);\n\treturn 0;\n}\n\nstatic inline __u32 CNVT_TOHW(__u32 val, __u32 width)\n{\n\treturn ((val << width) + 0x7FFF - val) >> 16;\n}\n\n \nstatic int fsl_diu_setcolreg(unsigned int regno, unsigned int red,\n\t\t\t     unsigned int green, unsigned int blue,\n\t\t\t     unsigned int transp, struct fb_info *info)\n{\n\tint ret = 1;\n\n\t \n\tif (info->var.grayscale)\n\t\tred = green = blue = (19595 * red + 38470 * green +\n\t\t\t\t      7471 * blue) >> 16;\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\t \n\t\tif (regno < 16) {\n\t\t\tu32 *pal = info->pseudo_palette;\n\t\t\tu32 v;\n\n\t\t\tred = CNVT_TOHW(red, info->var.red.length);\n\t\t\tgreen = CNVT_TOHW(green, info->var.green.length);\n\t\t\tblue = CNVT_TOHW(blue, info->var.blue.length);\n\t\t\ttransp = CNVT_TOHW(transp, info->var.transp.length);\n\n\t\t\tv = (red << info->var.red.offset) |\n\t\t\t    (green << info->var.green.offset) |\n\t\t\t    (blue << info->var.blue.offset) |\n\t\t\t    (transp << info->var.transp.offset);\n\n\t\t\tpal[regno] = v;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int fsl_diu_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tif ((info->var.xoffset == var->xoffset) &&\n\t    (info->var.yoffset == var->yoffset))\n\t\treturn 0;\t \n\n\tif (var->xoffset + info->var.xres > info->var.xres_virtual\n\t    || var->yoffset + info->var.yres > info->var.yres_virtual)\n\t\treturn -EINVAL;\n\n\tinfo->var.xoffset = var->xoffset;\n\tinfo->var.yoffset = var->yoffset;\n\n\tif (var->vmode & FB_VMODE_YWRAP)\n\t\tinfo->var.vmode |= FB_VMODE_YWRAP;\n\telse\n\t\tinfo->var.vmode &= ~FB_VMODE_YWRAP;\n\n\tfsl_diu_set_aoi(info);\n\n\treturn 0;\n}\n\nstatic int fsl_diu_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t       unsigned long arg)\n{\n\tstruct mfb_info *mfbi = info->par;\n\tstruct diu_ad *ad = mfbi->ad;\n\tstruct mfb_chroma_key ck;\n\tunsigned char global_alpha;\n\tstruct aoi_display_offset aoi_d;\n\t__u32 pix_fmt;\n\tvoid __user *buf = (void __user *)arg;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tfb_dbg(info, \"ioctl %08x (dir=%s%s type=%u nr=%u size=%u)\\n\", cmd,\n\t\t_IOC_DIR(cmd) & _IOC_READ ? \"R\" : \"\",\n\t\t_IOC_DIR(cmd) & _IOC_WRITE ? \"W\" : \"\",\n\t\t_IOC_TYPE(cmd), _IOC_NR(cmd), _IOC_SIZE(cmd));\n\n\tswitch (cmd) {\n\tcase MFB_SET_PIXFMT_OLD:\n\t\tfb_warn(info,\n\t\t\t\"MFB_SET_PIXFMT value of 0x%08x is deprecated.\\n\",\n\t\t\tMFB_SET_PIXFMT_OLD);\n\t\tfallthrough;\n\tcase MFB_SET_PIXFMT:\n\t\tif (copy_from_user(&pix_fmt, buf, sizeof(pix_fmt)))\n\t\t\treturn -EFAULT;\n\t\tad->pix_fmt = pix_fmt;\n\t\tbreak;\n\tcase MFB_GET_PIXFMT_OLD:\n\t\tfb_warn(info,\n\t\t\t\"MFB_GET_PIXFMT value of 0x%08x is deprecated.\\n\",\n\t\t\tMFB_GET_PIXFMT_OLD);\n\t\tfallthrough;\n\tcase MFB_GET_PIXFMT:\n\t\tpix_fmt = ad->pix_fmt;\n\t\tif (copy_to_user(buf, &pix_fmt, sizeof(pix_fmt)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase MFB_SET_AOID:\n\t\tif (copy_from_user(&aoi_d, buf, sizeof(aoi_d)))\n\t\t\treturn -EFAULT;\n\t\tmfbi->x_aoi_d = aoi_d.x_aoi_d;\n\t\tmfbi->y_aoi_d = aoi_d.y_aoi_d;\n\t\tfsl_diu_check_var(&info->var, info);\n\t\tfsl_diu_set_aoi(info);\n\t\tbreak;\n\tcase MFB_GET_AOID:\n\t\taoi_d.x_aoi_d = mfbi->x_aoi_d;\n\t\taoi_d.y_aoi_d = mfbi->y_aoi_d;\n\t\tif (copy_to_user(buf, &aoi_d, sizeof(aoi_d)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase MFB_GET_ALPHA:\n\t\tglobal_alpha = mfbi->g_alpha;\n\t\tif (copy_to_user(buf, &global_alpha, sizeof(global_alpha)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase MFB_SET_ALPHA:\n\t\t \n\t\tif (copy_from_user(&global_alpha, buf, sizeof(global_alpha)))\n\t\t\treturn -EFAULT;\n\t\tad->src_size_g_alpha = (ad->src_size_g_alpha & (~0xff)) |\n\t\t\t\t\t\t\t(global_alpha & 0xff);\n\t\tmfbi->g_alpha = global_alpha;\n\t\tbreak;\n\tcase MFB_SET_CHROMA_KEY:\n\t\t \n\t\tif (copy_from_user(&ck, buf, sizeof(ck)))\n\t\t\treturn -EFAULT;\n\n\t\tif (ck.enable &&\n\t\t   (ck.red_max < ck.red_min ||\n\t\t    ck.green_max < ck.green_min ||\n\t\t    ck.blue_max < ck.blue_min))\n\t\t\treturn -EINVAL;\n\n\t\tif (!ck.enable) {\n\t\t\tad->ckmax_r = 0;\n\t\t\tad->ckmax_g = 0;\n\t\t\tad->ckmax_b = 0;\n\t\t\tad->ckmin_r = 255;\n\t\t\tad->ckmin_g = 255;\n\t\t\tad->ckmin_b = 255;\n\t\t} else {\n\t\t\tad->ckmax_r = ck.red_max;\n\t\t\tad->ckmax_g = ck.green_max;\n\t\t\tad->ckmax_b = ck.blue_max;\n\t\t\tad->ckmin_r = ck.red_min;\n\t\t\tad->ckmin_g = ck.green_min;\n\t\t\tad->ckmin_b = ck.blue_min;\n\t\t}\n\t\tbreak;\n#ifdef CONFIG_PPC_MPC512x\n\tcase MFB_SET_GAMMA: {\n\t\tstruct fsl_diu_data *data = mfbi->parent;\n\n\t\tif (copy_from_user(data->gamma, buf, sizeof(data->gamma)))\n\t\t\treturn -EFAULT;\n\t\tsetbits32(&data->diu_reg->gamma, 0);  \n\t\tbreak;\n\t}\n\tcase MFB_GET_GAMMA: {\n\t\tstruct fsl_diu_data *data = mfbi->parent;\n\n\t\tif (copy_to_user(buf, data->gamma, sizeof(data->gamma)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tfb_err(info, \"unknown ioctl command (0x%08X)\\n\", cmd);\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void fsl_diu_enable_interrupts(struct fsl_diu_data *data)\n{\n\tu32 int_mask = INT_UNDRUN;  \n\n\tif (IS_ENABLED(CONFIG_NOT_COHERENT_CACHE))\n\t\tint_mask |= INT_VSYNC;  \n\n\tclrbits32(&data->diu_reg->int_mask, int_mask);\n}\n\n \nstatic int fsl_diu_open(struct fb_info *info, int user)\n{\n\tstruct mfb_info *mfbi = info->par;\n\tint res = 0;\n\n\t \n\tif ((mfbi->index == PLANE0) && diu_ops.release_bootmem)\n\t\tdiu_ops.release_bootmem();\n\n\tspin_lock(&diu_lock);\n\tmfbi->count++;\n\tif (mfbi->count == 1) {\n\t\tfsl_diu_check_var(&info->var, info);\n\t\tres = fsl_diu_set_par(info);\n\t\tif (res < 0)\n\t\t\tmfbi->count--;\n\t\telse {\n\t\t\tfsl_diu_enable_interrupts(mfbi->parent);\n\t\t\tfsl_diu_enable_panel(info);\n\t\t}\n\t}\n\n\tspin_unlock(&diu_lock);\n\treturn res;\n}\n\n \nstatic int fsl_diu_release(struct fb_info *info, int user)\n{\n\tstruct mfb_info *mfbi = info->par;\n\n\tspin_lock(&diu_lock);\n\tmfbi->count--;\n\tif (mfbi->count == 0) {\n\t\tstruct fsl_diu_data *data = mfbi->parent;\n\t\tbool disable = true;\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < NUM_AOIS; i++) {\n\t\t\tstruct mfb_info *mi = data->fsl_diu_info[i].par;\n\n\t\t\tif (mi->count)\n\t\t\t\tdisable = false;\n\t\t}\n\t\tif (disable)\n\t\t\tout_be32(&data->diu_reg->int_mask, 0xffffffff);\n\t\tfsl_diu_disable_panel(info);\n\t}\n\n\tspin_unlock(&diu_lock);\n\treturn 0;\n}\n\nstatic const struct fb_ops fsl_diu_ops = {\n\t.owner = THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var = fsl_diu_check_var,\n\t.fb_set_par = fsl_diu_set_par,\n\t.fb_setcolreg = fsl_diu_setcolreg,\n\t.fb_pan_display = fsl_diu_pan_display,\n\t.fb_ioctl = fsl_diu_ioctl,\n\t.fb_open = fsl_diu_open,\n\t.fb_release = fsl_diu_release,\n\t.fb_cursor = fsl_diu_cursor,\n};\n\nstatic int install_fb(struct fb_info *info)\n{\n\tint rc;\n\tstruct mfb_info *mfbi = info->par;\n\tstruct fsl_diu_data *data = mfbi->parent;\n\tconst char *aoi_mode, *init_aoi_mode = \"320x240\";\n\tstruct fb_videomode *db = fsl_diu_mode_db;\n\tunsigned int dbsize = ARRAY_SIZE(fsl_diu_mode_db);\n\tint has_default_mode = 1;\n\n\tinfo->var.activate = FB_ACTIVATE_NOW;\n\tinfo->fbops = &fsl_diu_ops;\n\tinfo->flags = FBINFO_VIRTFB | FBINFO_PARTIAL_PAN_OK |\n\t\tFBINFO_READS_FAST;\n\tinfo->pseudo_palette = mfbi->pseudo_palette;\n\n\trc = fb_alloc_cmap(&info->cmap, 16, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (mfbi->index == PLANE0) {\n\t\tif (data->has_edid) {\n\t\t\t \n\t\t\tfb_edid_to_monspecs(data->edid_data, &info->monspecs);\n\t\t\tfb_videomode_to_modelist(info->monspecs.modedb,\n\t\t\t\t\t\t info->monspecs.modedb_len,\n\t\t\t\t\t\t &info->modelist);\n\t\t\tdb = info->monspecs.modedb;\n\t\t\tdbsize = info->monspecs.modedb_len;\n\t\t}\n\t\taoi_mode = fb_mode;\n\t} else {\n\t\taoi_mode = init_aoi_mode;\n\t}\n\trc = fb_find_mode(&info->var, info, aoi_mode, db, dbsize, NULL,\n\t\t\t  default_bpp);\n\tif (!rc) {\n\t\t \n\t\tif ((mfbi->index == PLANE0) && data->has_edid)\n\t\t\thas_default_mode = 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!has_default_mode) {\n\t\trc = fb_find_mode(&info->var, info, aoi_mode, fsl_diu_mode_db,\n\t\t\tARRAY_SIZE(fsl_diu_mode_db), NULL, default_bpp);\n\t\tif (rc)\n\t\t\thas_default_mode = 1;\n\t}\n\n\t \n\tif (!has_default_mode && info->monspecs.modedb) {\n\t\tstruct fb_monspecs *specs = &info->monspecs;\n\t\tstruct fb_videomode *modedb = &specs->modedb[0];\n\n\t\t \n\t\tif (specs->misc & FB_MISC_1ST_DETAIL) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < specs->modedb_len; i++) {\n\t\t\t\tif (specs->modedb[i].flag & FB_MODE_IS_FIRST) {\n\t\t\t\t\tmodedb = &specs->modedb[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinfo->var.bits_per_pixel = default_bpp;\n\t\tfb_videomode_to_var(&info->var, modedb);\n\t}\n\n\tif (fsl_diu_check_var(&info->var, info)) {\n\t\tfb_err(info, \"fsl_diu_check_var failed\\n\");\n\t\tunmap_video_memory(info);\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\treturn -EINVAL;\n\t}\n\n\tif (register_framebuffer(info) < 0) {\n\t\tfb_err(info, \"register_framebuffer failed\\n\");\n\t\tunmap_video_memory(info);\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\treturn -EINVAL;\n\t}\n\n\tmfbi->registered = 1;\n\tfb_info(info, \"%s registered successfully\\n\", mfbi->id);\n\n\treturn 0;\n}\n\nstatic void uninstall_fb(struct fb_info *info)\n{\n\tstruct mfb_info *mfbi = info->par;\n\n\tif (!mfbi->registered)\n\t\treturn;\n\n\tunregister_framebuffer(info);\n\tunmap_video_memory(info);\n\tfb_dealloc_cmap(&info->cmap);\n\n\tmfbi->registered = 0;\n}\n\nstatic irqreturn_t fsl_diu_isr(int irq, void *dev_id)\n{\n\tstruct diu __iomem *hw = dev_id;\n\tuint32_t status = in_be32(&hw->int_status);\n\n\tif (status) {\n\t\t \n\t\tif (status & INT_UNDRUN) {\n\t\t\tout_be32(&hw->diu_mode, 0);\n\t\t\tudelay(1);\n\t\t\tout_be32(&hw->diu_mode, 1);\n\t\t}\n#if defined(CONFIG_NOT_COHERENT_CACHE)\n\t\telse if (status & INT_VSYNC) {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i = 0; i < coherence_data_size;\n\t\t\t\ti += d_cache_line_size)\n\t\t\t\t__asm__ __volatile__ (\n\t\t\t\t\t\"dcbz 0, %[input]\"\n\t\t\t\t::[input]\"r\"(&coherence_data[i]));\n\t\t}\n#endif\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\n#ifdef CONFIG_PM\n \nstatic int fsl_diu_suspend(struct platform_device *ofdev, pm_message_t state)\n{\n\tstruct fsl_diu_data *data;\n\n\tdata = dev_get_drvdata(&ofdev->dev);\n\tdisable_lcdc(data->fsl_diu_info);\n\n\treturn 0;\n}\n\nstatic int fsl_diu_resume(struct platform_device *ofdev)\n{\n\tstruct fsl_diu_data *data;\n\tunsigned int i;\n\n\tdata = dev_get_drvdata(&ofdev->dev);\n\n\tfsl_diu_enable_interrupts(data);\n\tupdate_lcdc(data->fsl_diu_info);\n\tfor (i = 0; i < NUM_AOIS; i++) {\n\t\tif (data->mfb[i].count)\n\t\t\tfsl_diu_enable_panel(&data->fsl_diu_info[i]);\n\t}\n\n\treturn 0;\n}\n\n#else\n#define fsl_diu_suspend NULL\n#define fsl_diu_resume NULL\n#endif\t\t\t\t \n\nstatic ssize_t store_monitor(struct device *device,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tenum fsl_diu_monitor_port old_monitor_port;\n\tstruct fsl_diu_data *data =\n\t\tcontainer_of(attr, struct fsl_diu_data, dev_attr);\n\n\told_monitor_port = data->monitor_port;\n\tdata->monitor_port = fsl_diu_name_to_port(buf);\n\n\tif (old_monitor_port != data->monitor_port) {\n\t\t \n\t\tunsigned int i;\n\n\t\tfor (i=0; i < NUM_AOIS; i++)\n\t\t\tfsl_diu_set_par(&data->fsl_diu_info[i]);\n\t}\n\treturn count;\n}\n\nstatic ssize_t show_monitor(struct device *device,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fsl_diu_data *data =\n\t\tcontainer_of(attr, struct fsl_diu_data, dev_attr);\n\n\tswitch (data->monitor_port) {\n\tcase FSL_DIU_PORT_DVI:\n\t\treturn sprintf(buf, \"DVI\\n\");\n\tcase FSL_DIU_PORT_LVDS:\n\t\treturn sprintf(buf, \"Single-link LVDS\\n\");\n\tcase FSL_DIU_PORT_DLVDS:\n\t\treturn sprintf(buf, \"Dual-link LVDS\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_diu_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct mfb_info *mfbi;\n\tstruct fsl_diu_data *data;\n\tdma_addr_t dma_addr;  \n\tconst void *prop;\n\tunsigned int i;\n\tint ret;\n\n\tdata = dmam_alloc_coherent(&pdev->dev, sizeof(struct fsl_diu_data),\n\t\t\t\t   &dma_addr, GFP_DMA | __GFP_ZERO);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->dma_addr = dma_addr;\n\n\t \n\tif ((unsigned long)data & 31) {\n\t\tdev_err(&pdev->dev, \"misaligned allocation\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tspin_lock_init(&data->reg_lock);\n\n\tfor (i = 0; i < NUM_AOIS; i++) {\n\t\tstruct fb_info *info = &data->fsl_diu_info[i];\n\n\t\tinfo->device = &pdev->dev;\n\t\tinfo->par = &data->mfb[i];\n\n\t\t \n\t\tdata->ad[i].paddr = DMA_ADDR(data, ad[i]);\n\n\t\tinfo->fix.smem_start = 0;\n\n\t\t \n\t\tmfbi = info->par;\n\t\tmemcpy(mfbi, &mfb_template[i], sizeof(struct mfb_info));\n\t\tmfbi->parent = data;\n\t\tmfbi->ad = &data->ad[i];\n\t}\n\n\t \n\tprop = of_get_property(np, \"edid\", &ret);\n\tif (prop && ret == EDID_LENGTH) {\n\t\tmemcpy(data->edid_data, prop, EDID_LENGTH);\n\t\tdata->has_edid = true;\n\t}\n\n\tdata->diu_reg = of_iomap(np, 0);\n\tif (!data->diu_reg) {\n\t\tdev_err(&pdev->dev, \"cannot map DIU registers\\n\");\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\t \n\tdata->irq = irq_of_parse_and_map(np, 0);\n\n\tif (!data->irq) {\n\t\tdev_err(&pdev->dev, \"could not get DIU IRQ\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tdata->monitor_port = monitor_port;\n\n\t \n\tdata->dummy_ad.addr = cpu_to_le32(DMA_ADDR(data, dummy_aoi));\n\tdata->dummy_ad.pix_fmt = 0x88882317;\n\tdata->dummy_ad.src_size_g_alpha = cpu_to_le32((4 << 12) | 4);\n\tdata->dummy_ad.aoi_size = cpu_to_le32((4 << 16) |  2);\n\tdata->dummy_ad.offset_xyi = 0;\n\tdata->dummy_ad.offset_xyd = 0;\n\tdata->dummy_ad.next_ad = 0;\n\tdata->dummy_ad.paddr = DMA_ADDR(data, dummy_ad);\n\n\t \n\tif (in_be32(&data->diu_reg->diu_mode) == MFB_MODE0)\n\t\tout_be32(&data->diu_reg->desc[0], 0);\n\n\tout_be32(&data->diu_reg->desc[1], data->dummy_ad.paddr);\n\tout_be32(&data->diu_reg->desc[2], data->dummy_ad.paddr);\n\n\t \n\tout_be32(&data->diu_reg->int_mask, 0xffffffff);\n\tin_be32(&data->diu_reg->int_status);\n\n\tret = request_irq(data->irq, fsl_diu_isr, 0, \"fsl-diu-fb\",\n\t\t\t  data->diu_reg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not claim irq\\n\");\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < NUM_AOIS; i++) {\n\t\tret = install_fb(&data->fsl_diu_info[i]);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"could not register fb %d\\n\", i);\n\t\t\tfree_irq(data->irq, data->diu_reg);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tsysfs_attr_init(&data->dev_attr.attr);\n\tdata->dev_attr.attr.name = \"monitor\";\n\tdata->dev_attr.attr.mode = S_IRUGO|S_IWUSR;\n\tdata->dev_attr.show = show_monitor;\n\tdata->dev_attr.store = store_monitor;\n\tret = device_create_file(&pdev->dev, &data->dev_attr);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not create sysfs file %s\\n\",\n\t\t\tdata->dev_attr.attr.name);\n\t}\n\n\tdev_set_drvdata(&pdev->dev, data);\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < NUM_AOIS; i++)\n\t\tuninstall_fb(&data->fsl_diu_info[i]);\n\n\tiounmap(data->diu_reg);\n\n\treturn ret;\n}\n\nstatic void fsl_diu_remove(struct platform_device *pdev)\n{\n\tstruct fsl_diu_data *data;\n\tint i;\n\n\tdata = dev_get_drvdata(&pdev->dev);\n\tdisable_lcdc(&data->fsl_diu_info[0]);\n\n\tfree_irq(data->irq, data->diu_reg);\n\n\tfor (i = 0; i < NUM_AOIS; i++)\n\t\tuninstall_fb(&data->fsl_diu_info[i]);\n\n\tiounmap(data->diu_reg);\n}\n\n#ifndef MODULE\nstatic int __init fsl_diu_setup(char *options)\n{\n\tchar *opt;\n\tunsigned long val;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*opt)\n\t\t\tcontinue;\n\t\tif (!strncmp(opt, \"monitor=\", 8)) {\n\t\t\tmonitor_port = fsl_diu_name_to_port(opt + 8);\n\t\t} else if (!strncmp(opt, \"bpp=\", 4)) {\n\t\t\tif (!kstrtoul(opt + 4, 10, &val))\n\t\t\t\tdefault_bpp = val;\n\t\t} else\n\t\t\tfb_mode = opt;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct of_device_id fsl_diu_match[] = {\n#ifdef CONFIG_PPC_MPC512x\n\t{\n\t\t.compatible = \"fsl,mpc5121-diu\",\n\t},\n#endif\n\t{\n\t\t.compatible = \"fsl,diu\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_diu_match);\n\nstatic struct platform_driver fsl_diu_driver = {\n\t.driver = {\n\t\t.name = \"fsl-diu-fb\",\n\t\t.of_match_table = fsl_diu_match,\n\t},\n\t.probe  \t= fsl_diu_probe,\n\t.remove_new \t= fsl_diu_remove,\n\t.suspend\t= fsl_diu_suspend,\n\t.resume\t\t= fsl_diu_resume,\n};\n\nstatic int __init fsl_diu_init(void)\n{\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\tstruct device_node *np;\n\tconst u32 *prop;\n#endif\n\tint ret;\n#ifndef MODULE\n\tchar *option;\n\n\t \n\tif (fb_get_options(\"fslfb\", &option))\n\t\treturn -ENODEV;\n\tfsl_diu_setup(option);\n#else\n\tmonitor_port = fsl_diu_name_to_port(monitor_string);\n#endif\n\n\t \n\tif (!diu_ops.set_pixel_clock)\n\t\treturn -ENODEV;\n\n\tpr_info(\"Freescale Display Interface Unit (DIU) framebuffer driver\\n\");\n\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\tnp = of_get_cpu_node(0, NULL);\n\tif (!np) {\n\t\tpr_err(\"fsl-diu-fb: can't find 'cpu' device node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tprop = of_get_property(np, \"d-cache-size\", NULL);\n\tif (prop == NULL) {\n\t\tpr_err(\"fsl-diu-fb: missing 'd-cache-size' property' \"\n\t\t       \"in 'cpu' node\\n\");\n\t\tof_node_put(np);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tcoherence_data_size = be32_to_cpup(prop) * 13;\n\tcoherence_data_size /= 8;\n\n\tpr_debug(\"fsl-diu-fb: coherence data size is %zu bytes\\n\",\n\t\t coherence_data_size);\n\n\tprop = of_get_property(np, \"d-cache-line-size\", NULL);\n\tif (prop == NULL) {\n\t\tpr_err(\"fsl-diu-fb: missing 'd-cache-line-size' property' \"\n\t\t       \"in 'cpu' node\\n\");\n\t\tof_node_put(np);\n\t\treturn -ENODEV;\n\t}\n\td_cache_line_size = be32_to_cpup(prop);\n\n\tpr_debug(\"fsl-diu-fb: cache lines size is %u bytes\\n\",\n\t\t d_cache_line_size);\n\n\tof_node_put(np);\n\tcoherence_data = vmalloc(coherence_data_size);\n\tif (!coherence_data)\n\t\treturn -ENOMEM;\n#endif\n\n\tret = platform_driver_register(&fsl_diu_driver);\n\tif (ret) {\n\t\tpr_err(\"fsl-diu-fb: failed to register platform driver\\n\");\n#if defined(CONFIG_NOT_COHERENT_CACHE)\n\t\tvfree(coherence_data);\n#endif\n\t}\n\treturn ret;\n}\n\nstatic void __exit fsl_diu_exit(void)\n{\n\tplatform_driver_unregister(&fsl_diu_driver);\n#if defined(CONFIG_NOT_COHERENT_CACHE)\n\tvfree(coherence_data);\n#endif\n}\n\nmodule_init(fsl_diu_init);\nmodule_exit(fsl_diu_exit);\n\nMODULE_AUTHOR(\"York Sun <yorksun@freescale.com>\");\nMODULE_DESCRIPTION(\"Freescale DIU framebuffer driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param_named(mode, fb_mode, charp, 0);\nMODULE_PARM_DESC(mode,\n\t\"Specify resolution as \\\"<xres>x<yres>[-<bpp>][@<refresh>]\\\" \");\nmodule_param_named(bpp, default_bpp, ulong, 0);\nMODULE_PARM_DESC(bpp, \"Specify bit-per-pixel if not specified in 'mode'\");\nmodule_param_named(monitor, monitor_string, charp, 0);\nMODULE_PARM_DESC(monitor, \"Specify the monitor port \"\n\t\"(\\\"dvi\\\", \\\"lvds\\\", or \\\"dlvds\\\") if supported by the platform\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}