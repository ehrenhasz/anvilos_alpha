{
  "module_name": "atafb_utils.h",
  "hash_id": "a7732b6cf03ebff4f8745593c53c8dc61844ec6c46ed87893e1d07d82b11e038",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/atafb_utils.h",
  "human_readable_source": " \n#ifndef _VIDEO_ATAFB_UTILS_H\n#define _VIDEO_ATAFB_UTILS_H\n\n \n \n \n\n \n\n \n\n\n \n\n \n\nstatic inline void *fb_memclear_small(void *s, size_t count)\n{\n\tif (!count)\n\t\treturn 0;\n\n\tasm volatile (\"\\n\"\n\t\t\"\tlsr.l\t#1,%1 ; jcc 1f ; move.b %2,-(%0)\\n\"\n\t\t\"1:\tlsr.l\t#1,%1 ; jcc 1f ; move.w %2,-(%0)\\n\"\n\t\t\"1:\tlsr.l\t#1,%1 ; jcc 1f ; move.l %2,-(%0)\\n\"\n\t\t\"1:\tlsr.l\t#1,%1 ; jcc 1f ; move.l %2,-(%0) ; move.l %2,-(%0)\\n\"\n\t\t\"1:\"\n\t\t: \"=a\" (s), \"=d\" (count)\n\t\t: \"d\" (0), \"0\" ((char *)s + count), \"1\" (count));\n\tasm volatile (\"\\n\"\n\t\t\"\tsubq.l  #1,%1\\n\"\n\t\t\"\tjcs\t3f\\n\"\n\t\t\"\tmove.l\t%2,%%d4; move.l %2,%%d5; move.l %2,%%d6\\n\"\n\t\t\"2:\tmovem.l\t%2/%%d4/%%d5/%%d6,-(%0)\\n\"\n\t\t\"\tdbra\t%1,2b\\n\"\n\t\t\"3:\"\n\t\t: \"=a\" (s), \"=d\" (count)\n\t\t: \"d\" (0), \"0\" (s), \"1\" (count)\n\t\t: \"d4\", \"d5\", \"d6\"\n\t\t);\n\n\treturn 0;\n}\n\n\nstatic inline void *fb_memclear(void *s, size_t count)\n{\n\tif (!count)\n\t\treturn 0;\n\n\tif (count < 16) {\n\t\tasm volatile (\"\\n\"\n\t\t\t\"\tlsr.l\t#1,%1 ; jcc 1f ; clr.b (%0)+\\n\"\n\t\t\t\"1:\tlsr.l\t#1,%1 ; jcc 1f ; clr.w (%0)+\\n\"\n\t\t\t\"1:\tlsr.l\t#1,%1 ; jcc 1f ; clr.l (%0)+\\n\"\n\t\t\t\"1:\tlsr.l\t#1,%1 ; jcc 1f ; clr.l (%0)+ ; clr.l (%0)+\\n\"\n\t\t\t\"1:\"\n\t\t\t: \"=a\" (s), \"=d\" (count)\n\t\t\t: \"0\" (s), \"1\" (count));\n\t} else {\n\t\tlong tmp;\n\t\tasm volatile (\"\\n\"\n\t\t\t\"\tmove.l\t%1,%2\\n\"\n\t\t\t\"\tlsr.l\t#1,%2 ; jcc 1f ; clr.b (%0)+ ; subq.w #1,%1\\n\"\n\t\t\t\"\tlsr.l\t#1,%2 ; jcs 2f\\n\"   \n\t\t\t\"\tclr.w\t(%0)+  ; subq.w  #2,%1 ; jra 2f\\n\"\n\t\t\t\"1:\tlsr.l\t#1,%2 ; jcc 2f\\n\"\n\t\t\t\"\tclr.w\t(%0)+  ; subq.w  #2,%1\\n\"\n\t\t\t\"2:\tmove.w\t%1,%2; lsr.l #2,%1 ; jeq 6f\\n\"\n\t\t\t\"\tlsr.l\t#1,%1 ; jcc 3f ; clr.l (%0)+\\n\"\n\t\t\t\"3:\tlsr.l\t#1,%1 ; jcc 4f ; clr.l (%0)+ ; clr.l (%0)+\\n\"\n\t\t\t\"4:\tsubq.l\t#1,%1 ; jcs 6f\\n\"\n\t\t\t\"5:\tclr.l\t(%0)+; clr.l (%0)+ ; clr.l (%0)+ ; clr.l (%0)+\\n\"\n\t\t\t\"\tdbra\t%1,5b ; clr.w %1; subq.l #1,%1; jcc 5b\\n\"\n\t\t\t\"6:\tmove.w\t%2,%1; btst #1,%1 ; jeq 7f ; clr.w (%0)+\\n\"\n\t\t\t\"7:\tbtst\t#0,%1 ; jeq 8f ; clr.b (%0)+\\n\"\n\t\t\t\"8:\"\n\t\t\t: \"=a\" (s), \"=d\" (count), \"=d\" (tmp)\n\t\t\t: \"0\" (s), \"1\" (count));\n\t}\n\n\treturn 0;\n}\n\n\nstatic inline void *fb_memset255(void *s, size_t count)\n{\n\tif (!count)\n\t\treturn 0;\n\n\tasm volatile (\"\\n\"\n\t\t\"\tlsr.l\t#1,%1 ; jcc 1f ; move.b %2,-(%0)\\n\"\n\t\t\"1:\tlsr.l\t#1,%1 ; jcc 1f ; move.w %2,-(%0)\\n\"\n\t\t\"1:\tlsr.l\t#1,%1 ; jcc 1f ; move.l %2,-(%0)\\n\"\n\t\t\"1:\tlsr.l\t#1,%1 ; jcc 1f ; move.l %2,-(%0) ; move.l %2,-(%0)\\n\"\n\t\t\"1:\"\n\t\t: \"=a\" (s), \"=d\" (count)\n\t\t: \"d\" (-1), \"0\" ((char *)s+count), \"1\" (count));\n\tasm volatile (\"\\n\"\n\t\t\"\tsubq.l\t#1,%1 ; jcs 3f\\n\"\n\t\t\"\tmove.l\t%2,%%d4; move.l %2,%%d5; move.l %2,%%d6\\n\"\n\t\t\"2:\tmovem.l\t%2/%%d4/%%d5/%%d6,-(%0)\\n\"\n\t\t\"\tdbra\t%1,2b\\n\"\n\t\t\"3:\"\n\t\t: \"=a\" (s), \"=d\" (count)\n\t\t: \"d\" (-1), \"0\" (s), \"1\" (count)\n\t\t: \"d4\", \"d5\", \"d6\");\n\n\treturn 0;\n}\n\n\nstatic inline void *fb_memmove(void *d, const void *s, size_t count)\n{\n\tif (d < s) {\n\t\tif (count < 16) {\n\t\t\tasm volatile (\"\\n\"\n\t\t\t\t\"\tlsr.l\t#1,%2 ; jcc 1f ; move.b (%1)+,(%0)+\\n\"\n\t\t\t\t\"1:\tlsr.l\t#1,%2 ; jcc 1f ; move.w (%1)+,(%0)+\\n\"\n\t\t\t\t\"1:\tlsr.l\t#1,%2 ; jcc 1f ; move.l (%1)+,(%0)+\\n\"\n\t\t\t\t\"1:\tlsr.l\t#1,%2 ; jcc 1f ; move.l (%1)+,(%0)+ ; move.l (%1)+,(%0)+\\n\"\n\t\t\t\t\"1:\"\n\t\t\t\t: \"=a\" (d), \"=a\" (s), \"=d\" (count)\n\t\t\t\t: \"0\" (d), \"1\" (s), \"2\" (count));\n\t\t} else {\n\t\t\tlong tmp;\n\t\t\tasm volatile (\"\\n\"\n\t\t\t\t\"\tmove.l\t%0,%3\\n\"\n\t\t\t\t\"\tlsr.l\t#1,%3 ; jcc 1f ; move.b (%1)+,(%0)+ ; subqw #1,%2\\n\"\n\t\t\t\t\"\tlsr.l\t#1,%3 ; jcs 2f\\n\"   \n\t\t\t\t\"\tmove.w\t(%1)+,(%0)+  ; subqw  #2,%2 ; jra 2f\\n\"\n\t\t\t\t\"1:\tlsr.l   #1,%3 ; jcc 2f\\n\"\n\t\t\t\t\"\tmove.w\t(%1)+,(%0)+  ; subqw  #2,%2\\n\"\n\t\t\t\t\"2:\tmove.w\t%2,%-; lsr.l #2,%2 ; jeq 6f\\n\"\n\t\t\t\t\"\tlsr.l\t#1,%2 ; jcc 3f ; move.l (%1)+,(%0)+\\n\"\n\t\t\t\t\"3:\tlsr.l\t#1,%2 ; jcc 4f ; move.l (%1)+,(%0)+ ; move.l (%1)+,(%0)+\\n\"\n\t\t\t\t\"4:\tsubq.l\t#1,%2 ; jcs 6f\\n\"\n\t\t\t\t\"5:\tmove.l\t(%1)+,(%0)+; move.l (%1)+,(%0)+\\n\"\n\t\t\t\t\"\tmove.l\t(%1)+,(%0)+; move.l (%1)+,(%0)+\\n\"\n\t\t\t\t\"\tdbra\t%2,5b ; clr.w %2; subq.l #1,%2; jcc 5b\\n\"\n\t\t\t\t\"6:\tmove.w\t%+,%2; btst #1,%2 ; jeq 7f ; move.w (%1)+,(%0)+\\n\"\n\t\t\t\t\"7:\tbtst\t#0,%2 ; jeq 8f ; move.b (%1)+,(%0)+\\n\"\n\t\t\t\t\"8:\"\n\t\t\t\t: \"=a\" (d), \"=a\" (s), \"=d\" (count), \"=d\" (tmp)\n\t\t\t\t: \"0\" (d), \"1\" (s), \"2\" (count));\n\t\t}\n\t} else {\n\t\tif (count < 16) {\n\t\t\tasm volatile (\"\\n\"\n\t\t\t\t\"\tlsr.l\t#1,%2 ; jcc 1f ; move.b -(%1),-(%0)\\n\"\n\t\t\t\t\"1:\tlsr.l\t#1,%2 ; jcc 1f ; move.w -(%1),-(%0)\\n\"\n\t\t\t\t\"1:\tlsr.l\t#1,%2 ; jcc 1f ; move.l -(%1),-(%0)\\n\"\n\t\t\t\t\"1:\tlsr.l\t#1,%2 ; jcc 1f ; move.l -(%1),-(%0) ; move.l -(%1),-(%0)\\n\"\n\t\t\t\t\"1:\"\n\t\t\t\t: \"=a\" (d), \"=a\" (s), \"=d\" (count)\n\t\t\t\t: \"0\" ((char *) d + count), \"1\" ((char *) s + count), \"2\" (count));\n\t\t} else {\n\t\t\tlong tmp;\n\n\t\t\tasm volatile (\"\\n\"\n\t\t\t\t\"\tmove.l\t%0,%3\\n\"\n\t\t\t\t\"\tlsr.l\t#1,%3 ; jcc 1f ; move.b -(%1),-(%0) ; subqw #1,%2\\n\"\n\t\t\t\t\"\tlsr.l\t#1,%3 ; jcs 2f\\n\"   \n\t\t\t\t\"\tmove.w\t-(%1),-(%0) ; subqw  #2,%2 ; jra 2f\\n\"\n\t\t\t\t\"1:\tlsr.l\t#1,%3 ; jcc 2f\\n\"\n\t\t\t\t\"\tmove.w\t-(%1),-(%0) ; subqw  #2,%2\\n\"\n\t\t\t\t\"2:\tmove.w\t%2,%-; lsr.l #2,%2 ; jeq 6f\\n\"\n\t\t\t\t\"\tlsr.l\t#1,%2 ; jcc 3f ; move.l -(%1),-(%0)\\n\"\n\t\t\t\t\"3:\tlsr.l\t#1,%2 ; jcc 4f ; move.l -(%1),-(%0) ; move.l -(%1),-(%0)\\n\"\n\t\t\t\t\"4:\tsubq.l\t#1,%2 ; jcs 6f\\n\"\n\t\t\t\t\"5:\tmove.l\t-(%1),-(%0); move.l -(%1),-(%0)\\n\"\n\t\t\t\t\"\tmove.l\t-(%1),-(%0); move.l -(%1),-(%0)\\n\"\n\t\t\t\t\"\tdbra\t%2,5b ; clr.w %2; subq.l #1,%2; jcc 5b\\n\"\n\t\t\t\t\"6:\tmove.w\t%+,%2; btst #1,%2 ; jeq 7f ; move.w -(%1),-(%0)\\n\"\n\t\t\t\t\"7:\tbtst\t#0,%2 ; jeq 8f ; move.b -(%1),-(%0)\\n\"\n\t\t\t\t\"8:\"\n\t\t\t\t: \"=a\" (d), \"=a\" (s), \"=d\" (count), \"=d\" (tmp)\n\t\t\t\t: \"0\" ((char *) d + count), \"1\" ((char *) s + count), \"2\" (count));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic inline void fast_memmove(char *dst, const char *src, size_t size)\n{\n\tif (!size)\n\t\treturn;\n\tif (dst < src)\n\t\tasm volatile (\"\\n\"\n\t\t\t\"1:\tmovem.l\t(%0)+,%%d0/%%d1/%%a0/%%a1\\n\"\n\t\t\t\"\tmovem.l\t%%d0/%%d1/%%a0/%%a1,%1@\\n\"\n\t\t\t\"\taddq.l\t#8,%1; addq.l #8,%1\\n\"\n\t\t\t\"\tdbra\t%2,1b\\n\"\n\t\t\t\"\tclr.w\t%2; subq.l #1,%2\\n\"\n\t\t\t\"\tjcc\t1b\"\n\t\t\t: \"=a\" (src), \"=a\" (dst), \"=d\" (size)\n\t\t\t: \"0\" (src), \"1\" (dst), \"2\" (size / 16 - 1)\n\t\t\t: \"d0\", \"d1\", \"a0\", \"a1\", \"memory\");\n\telse\n\t\tasm volatile (\"\\n\"\n\t\t\t\"1:\tsubq.l\t#8,%0; subq.l #8,%0\\n\"\n\t\t\t\"\tmovem.l\t%0@,%%d0/%%d1/%%a0/%%a1\\n\"\n\t\t\t\"\tmovem.l\t%%d0/%%d1/%%a0/%%a1,-(%1)\\n\"\n\t\t\t\"\tdbra\t%2,1b\\n\"\n\t\t\t\"\tclr.w\t%2; subq.l #1,%2\\n\"\n\t\t\t\"\tjcc 1b\"\n\t\t\t: \"=a\" (src), \"=a\" (dst), \"=d\" (size)\n\t\t\t: \"0\" (src + size), \"1\" (dst + size), \"2\" (size / 16 - 1)\n\t\t\t: \"d0\", \"d1\", \"a0\", \"a1\", \"memory\");\n}\n\n#ifdef BPL\n\n \nstatic const u32 four2long[] = {\n\t0x00000000, 0x000000ff, 0x0000ff00, 0x0000ffff,\n\t0x00ff0000, 0x00ff00ff, 0x00ffff00, 0x00ffffff,\n\t0xff000000, 0xff0000ff, 0xff00ff00, 0xff00ffff,\n\t0xffff0000, 0xffff00ff, 0xffffff00, 0xffffffff,\n};\n\nstatic inline void expand8_col2mask(u8 c, u32 m[])\n{\n\tm[0] = four2long[c & 15];\n#if BPL > 4\n\tm[1] = four2long[c >> 4];\n#endif\n}\n\nstatic inline void expand8_2col2mask(u8 fg, u8 bg, u32 fgm[], u32 bgm[])\n{\n\tfgm[0] = four2long[fg & 15] ^ (bgm[0] = four2long[bg & 15]);\n#if BPL > 4\n\tfgm[1] = four2long[fg >> 4] ^ (bgm[1] = four2long[bg >> 4]);\n#endif\n}\n\n \nstatic inline void fill8_col(u8 *dst, u32 m[])\n{\n\tu32 tmp = m[0];\n\tdst[0] = tmp;\n\tdst[2] = (tmp >>= 8);\n#if BPL > 2\n\tdst[4] = (tmp >>= 8);\n\tdst[6] = tmp >> 8;\n#endif\n#if BPL > 4\n\ttmp = m[1];\n\tdst[8] = tmp;\n\tdst[10] = (tmp >>= 8);\n\tdst[12] = (tmp >>= 8);\n\tdst[14] = tmp >> 8;\n#endif\n}\n\n \nstatic inline void fill8_2col(u8 *dst, u8 fg, u8 bg, u32 mask)\n{\n\tu32 fgm[2], bgm[2], tmp;\n\n\texpand8_2col2mask(fg, bg, fgm, bgm);\n\n\tmask |= mask << 8;\n#if BPL > 2\n\tmask |= mask << 16;\n#endif\n\ttmp = (mask & fgm[0]) ^ bgm[0];\n\tdst[0] = tmp;\n\tdst[2] = (tmp >>= 8);\n#if BPL > 2\n\tdst[4] = (tmp >>= 8);\n\tdst[6] = tmp >> 8;\n#endif\n#if BPL > 4\n\ttmp = (mask & fgm[1]) ^ bgm[1];\n\tdst[8] = tmp;\n\tdst[10] = (tmp >>= 8);\n\tdst[12] = (tmp >>= 8);\n\tdst[14] = tmp >> 8;\n#endif\n}\n\nstatic const u32 two2word[] = {\n\t0x00000000, 0xffff0000, 0x0000ffff, 0xffffffff\n};\n\nstatic inline void expand16_col2mask(u8 c, u32 m[])\n{\n\tm[0] = two2word[c & 3];\n#if BPL > 2\n\tm[1] = two2word[(c >> 2) & 3];\n#endif\n#if BPL > 4\n\tm[2] = two2word[(c >> 4) & 3];\n\tm[3] = two2word[c >> 6];\n#endif\n}\n\nstatic inline void expand16_2col2mask(u8 fg, u8 bg, u32 fgm[], u32 bgm[])\n{\n\tbgm[0] = two2word[bg & 3];\n\tfgm[0] = two2word[fg & 3] ^ bgm[0];\n#if BPL > 2\n\tbgm[1] = two2word[(bg >> 2) & 3];\n\tfgm[1] = two2word[(fg >> 2) & 3] ^ bgm[1];\n#endif\n#if BPL > 4\n\tbgm[2] = two2word[(bg >> 4) & 3];\n\tfgm[2] = two2word[(fg >> 4) & 3] ^ bgm[2];\n\tbgm[3] = two2word[bg >> 6];\n\tfgm[3] = two2word[fg >> 6] ^ bgm[3];\n#endif\n}\n\nstatic inline u32 *fill16_col(u32 *dst, int rows, u32 m[])\n{\n\twhile (rows) {\n\t\t*dst++ = m[0];\n#if BPL > 2\n\t\t*dst++ = m[1];\n#endif\n#if BPL > 4\n\t\t*dst++ = m[2];\n\t\t*dst++ = m[3];\n#endif\n\t\trows--;\n\t}\n\treturn dst;\n}\n\nstatic inline void memmove32_col(void *dst, void *src, u32 mask, u32 h, u32 bytes)\n{\n\tu32 *s, *d, v;\n\n        s = src;\n        d = dst;\n        do {\n                v = (*s++ & mask) | (*d  & ~mask);\n                *d++ = v;\n#if BPL > 2\n                v = (*s++ & mask) | (*d  & ~mask);\n                *d++ = v;\n#endif\n#if BPL > 4\n                v = (*s++ & mask) | (*d  & ~mask);\n                *d++ = v;\n                v = (*s++ & mask) | (*d  & ~mask);\n                *d++ = v;\n#endif\n                d = (u32 *)((u8 *)d + bytes);\n                s = (u32 *)((u8 *)s + bytes);\n        } while (--h);\n}\n\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}