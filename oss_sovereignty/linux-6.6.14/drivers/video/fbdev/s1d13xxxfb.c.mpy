{
  "module_name": "s1d13xxxfb.c",
  "hash_id": "2ee91eea6933f8b12b722a7508f68bcd185bbeb3290d50325845c467327427bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/s1d13xxxfb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/fb.h>\n#include <linux/spinlock_types.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#include <video/s1d13xxxfb.h>\n\n#define PFX\t\"s1d13xxxfb: \"\n#define BLIT\t\"s1d13xxxfb_bitblt: \"\n\n \n#if 0\n#define dbg(fmt, args...) do { printk(KERN_INFO fmt, ## args); } while(0)\n#else\n#define dbg(fmt, args...) do { no_printk(KERN_INFO fmt, ## args); } while (0)\n#endif\n\n \n#if 0\n#define dbg_blit(fmt, args...) do { printk(KERN_INFO BLIT fmt, ## args); } while (0)\n#else\n#define dbg_blit(fmt, args...) do { } while (0)\n#endif\n\n \nstatic DEFINE_SPINLOCK(s1d13xxxfb_bitblt_lock);\n\n \nstatic const int s1d13xxxfb_prod_ids[] = {\n\tS1D13505_PROD_ID,\n\tS1D13506_PROD_ID,\n\tS1D13806_PROD_ID,\n};\n\n \nstatic const char *s1d13xxxfb_prod_names[] = {\n\t\"S1D13505\",\n\t\"S1D13506\",\n\t\"S1D13806\",\n};\n\n \nstatic const struct fb_fix_screeninfo s1d13xxxfb_fix = {\n\t.id\t\t= S1D_FBID,\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.visual\t\t= FB_VISUAL_PSEUDOCOLOR,\n\t.xpanstep\t= 0,\n\t.ypanstep\t= 1,\n\t.ywrapstep\t= 0,\n\t.accel\t\t= FB_ACCEL_NONE,\n};\n\nstatic inline u8\ns1d13xxxfb_readreg(struct s1d13xxxfb_par *par, u16 regno)\n{\n\treturn readb(par->regs + regno);\n}\n\nstatic inline void\ns1d13xxxfb_writereg(struct s1d13xxxfb_par *par, u16 regno, u8 value)\n{\n\twriteb(value, par->regs + regno);\n}\n\nstatic inline void\ns1d13xxxfb_runinit(struct s1d13xxxfb_par *par,\n\t\t\tconst struct s1d13xxxfb_regval *initregs,\n\t\t\tconst unsigned int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n        \tif ((initregs[i].addr == S1DREG_DELAYOFF) ||\n\t\t\t\t(initregs[i].addr == S1DREG_DELAYON))\n\t\t\tmdelay((int)initregs[i].value);\n        \telse {\n\t\t\ts1d13xxxfb_writereg(par, initregs[i].addr, initregs[i].value);\n\t\t}\n        }\n\n\t \n\tmdelay(1);\n}\n\nstatic inline void\nlcd_enable(struct s1d13xxxfb_par *par, int enable)\n{\n\tu8 mode = s1d13xxxfb_readreg(par, S1DREG_COM_DISP_MODE);\n\n\tif (enable)\n\t\tmode |= 0x01;\n\telse\n\t\tmode &= ~0x01;\n\n\ts1d13xxxfb_writereg(par, S1DREG_COM_DISP_MODE, mode);\n}\n\nstatic inline void\ncrt_enable(struct s1d13xxxfb_par *par, int enable)\n{\n\tu8 mode = s1d13xxxfb_readreg(par, S1DREG_COM_DISP_MODE);\n\n\tif (enable)\n\t\tmode |= 0x02;\n\telse\n\t\tmode &= ~0x02;\n\n\ts1d13xxxfb_writereg(par, S1DREG_COM_DISP_MODE, mode);\n}\n\n\n \nstatic inline void\ns1d13xxxfb_setup_pseudocolour(struct fb_info *info)\n{\n\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\n\tinfo->var.red.length = 4;\n\tinfo->var.green.length = 4;\n\tinfo->var.blue.length = 4;\n}\n\nstatic inline void\ns1d13xxxfb_setup_truecolour(struct fb_info *info)\n{\n\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\tinfo->var.bits_per_pixel = 16;\n\n\tinfo->var.red.length = 5;\n\tinfo->var.red.offset = 11;\n\n\tinfo->var.green.length = 6;\n\tinfo->var.green.offset = 5;\n\n\tinfo->var.blue.length = 5;\n\tinfo->var.blue.offset = 0;\n}\n\n \nstatic int\ns1d13xxxfb_set_par(struct fb_info *info)\n{\n\tstruct s1d13xxxfb_par *s1dfb = info->par;\n\tunsigned int val;\n\n\tdbg(\"s1d13xxxfb_set_par: bpp=%d\\n\", info->var.bits_per_pixel);\n\n\tif ((s1dfb->display & 0x01))\t \n\t\tval = s1d13xxxfb_readreg(s1dfb, S1DREG_LCD_DISP_MODE);    \n\telse\t \n\t\tval = s1d13xxxfb_readreg(s1dfb, S1DREG_CRT_DISP_MODE);    \n\n\tval &= ~0x07;\n\n\tswitch (info->var.bits_per_pixel) {\n\t\tcase 4:\n\t\t\tdbg(\"pseudo colour 4\\n\");\n\t\t\ts1d13xxxfb_setup_pseudocolour(info);\n\t\t\tval |= 2;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tdbg(\"pseudo colour 8\\n\");\n\t\t\ts1d13xxxfb_setup_pseudocolour(info);\n\t\t\tval |= 3;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tdbg(\"true colour\\n\");\n\t\t\ts1d13xxxfb_setup_truecolour(info);\n\t\t\tval |= 5;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdbg(\"bpp not supported!\\n\");\n\t\t\treturn -EINVAL;\n\t}\n\n\tdbg(\"writing %02x to display mode register\\n\", val);\n\n\tif ((s1dfb->display & 0x01))\t \n\t\ts1d13xxxfb_writereg(s1dfb, S1DREG_LCD_DISP_MODE, val);\n\telse\t \n\t\ts1d13xxxfb_writereg(s1dfb, S1DREG_CRT_DISP_MODE, val);\n\n\tinfo->fix.line_length  = info->var.xres * info->var.bits_per_pixel;\n\tinfo->fix.line_length /= 8;\n\n\tdbg(\"setting line_length to %d\\n\", info->fix.line_length);\n\n\tdbg(\"done setup\\n\");\n\n\treturn 0;\n}\n\n \nstatic int\ns1d13xxxfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\tu_int transp, struct fb_info *info)\n{\n\tstruct s1d13xxxfb_par *s1dfb = info->par;\n\tunsigned int pseudo_val;\n\n\tif (regno >= S1D_PALETTE_SIZE)\n\t\treturn -EINVAL;\n\n\tdbg(\"s1d13xxxfb_setcolreg: %d: rgb=%d,%d,%d, tr=%d\\n\",\n\t\t    regno, red, green, blue, transp);\n\n\tif (info->var.grayscale)\n\t\tred = green = blue = (19595*red + 38470*green + 7471*blue) >> 16;\n\n\tswitch (info->fix.visual) {\n\t\tcase FB_VISUAL_TRUECOLOR:\n\t\t\tif (regno >= 16)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\n\t\t\tpseudo_val  = (red   >> 11) << info->var.red.offset;\n\t\t\tpseudo_val |= (green >> 10) << info->var.green.offset;\n\t\t\tpseudo_val |= (blue  >> 11) << info->var.blue.offset;\n\n\t\t\tdbg(\"s1d13xxxfb_setcolreg: pseudo %d, val %08x\\n\",\n\t\t\t\t    regno, pseudo_val);\n\n\t\t\t((u32 *)info->pseudo_palette)[regno] = pseudo_val;\n\n\t\t\tbreak;\n\t\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\t\ts1d13xxxfb_writereg(s1dfb, S1DREG_LKUP_ADDR, regno);\n\t\t\ts1d13xxxfb_writereg(s1dfb, S1DREG_LKUP_DATA, red);\n\t\t\ts1d13xxxfb_writereg(s1dfb, S1DREG_LKUP_DATA, green);\n\t\t\ts1d13xxxfb_writereg(s1dfb, S1DREG_LKUP_DATA, blue);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOSYS;\n\t}\n\n\tdbg(\"s1d13xxxfb_setcolreg: done\\n\");\n\n\treturn 0;\n}\n\n \nstatic int\ns1d13xxxfb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct s1d13xxxfb_par *par = info->par;\n\n\tdbg(\"s1d13xxxfb_blank: blank=%d, info=%p\\n\", blank_mode, info);\n\n\tswitch (blank_mode) {\n\t\tcase FB_BLANK_UNBLANK:\n\t\tcase FB_BLANK_NORMAL:\n\t\t\tif ((par->display & 0x01) != 0)\n\t\t\t\tlcd_enable(par, 1);\n\t\t\tif ((par->display & 0x02) != 0)\n\t\t\t\tcrt_enable(par, 1);\n\t\t\tbreak;\n\t\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\t\tbreak;\n\t\tcase FB_BLANK_POWERDOWN:\n\t\t\tlcd_enable(par, 0);\n\t\t\tcrt_enable(par, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn ((blank_mode == FB_BLANK_NORMAL) ? 1 : 0);\n}\n\n \nstatic int\ns1d13xxxfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct s1d13xxxfb_par *par = info->par;\n\tu32 start;\n\n\tif (var->xoffset != 0)\t \n\t\treturn -EINVAL;\n\n\tif (var->yoffset + info->var.yres > info->var.yres_virtual)\n\t\treturn -EINVAL;\n\n\tstart = (info->fix.line_length >> 1) * var->yoffset;\n\n\tif ((par->display & 0x01)) {\n\t\t \n\t\ts1d13xxxfb_writereg(par, S1DREG_LCD_DISP_START0, (start & 0xff));\n\t\ts1d13xxxfb_writereg(par, S1DREG_LCD_DISP_START1, ((start >> 8) & 0xff));\n\t\ts1d13xxxfb_writereg(par, S1DREG_LCD_DISP_START2, ((start >> 16) & 0x0f));\n\t} else {\n\t\t \n\t\ts1d13xxxfb_writereg(par, S1DREG_CRT_DISP_START0, (start & 0xff));\n\t\ts1d13xxxfb_writereg(par, S1DREG_CRT_DISP_START1, ((start >> 8) & 0xff));\n\t\ts1d13xxxfb_writereg(par, S1DREG_CRT_DISP_START2, ((start >> 16) & 0x0f));\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic u8\nbltbit_wait_bitclear(struct fb_info *info, u8 bit, int timeout)\n{\n\twhile (s1d13xxxfb_readreg(info->par, S1DREG_BBLT_CTL0) & bit) {\n\t\tudelay(10);\n\t\tif (!--timeout) {\n\t\t\tdbg_blit(\"wait_bitclear timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn timeout;\n}\n\n \nstatic void\ns1d13xxxfb_bitblt_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tu32 dst, src;\n\tu32 stride;\n\tu16 reverse = 0;\n\tu16 sx = area->sx, sy = area->sy;\n\tu16 dx = area->dx, dy = area->dy;\n\tu16 width = area->width, height = area->height;\n\tu16 bpp;\n\n\tspin_lock(&s1d13xxxfb_bitblt_lock);\n\n\t \n\tbpp = (info->var.bits_per_pixel >> 3);\n\tstride = bpp * info->var.xres;\n\n\t \n\tif ((dy > sy) || ((dy == sy) && (dx >= sx))) {\n\t\tdst = (((dy + height - 1) * stride) + (bpp * (dx + width - 1)));\n\t\tsrc = (((sy + height - 1) * stride) + (bpp * (sx + width - 1)));\n\t\treverse = 1;\n\t \n\t} else {  \n\t\tdst = (dy * stride) + (bpp * dx);\n\t\tsrc = (sy * stride) + (bpp * sx);\n\t}\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_SRC_START0, (src & 0xff));\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_SRC_START1, (src >> 8) & 0x00ff);\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_SRC_START2, (src >> 16) & 0x00ff);\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_DST_START0, (dst & 0xff));\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_DST_START1, (dst >> 8) & 0x00ff);\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_DST_START2, (dst >> 16) & 0x00ff);\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_WIDTH0, (width & 0xff) - 1);\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_WIDTH1, (width >> 8));\n\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_HEIGHT0, (height & 0xff) - 1);\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_HEIGHT1, (height >> 8));\n\n\t \n\tif (reverse == 1) {\n\t\tdbg_blit(\"(copyarea) negative rop\\n\");\n\t\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_OP, 0x03);\n\t} else   {\n\t\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_OP, 0x02);\n\t\tdbg_blit(\"(copyarea) positive rop\\n\");\n\t}\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_CTL0, 0x0);\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_CTL1, (bpp >> 1));\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_MEM_OFF0, (stride >> 1) & 0xff);\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_MEM_OFF1, (stride >> 9));\n\n\tdbg_blit(\"(copyarea) dx=%d, dy=%d\\n\", dx, dy);\n\tdbg_blit(\"(copyarea) sx=%d, sy=%d\\n\", sx, sy);\n\tdbg_blit(\"(copyarea) width=%d, height=%d\\n\", width - 1, height - 1);\n\tdbg_blit(\"(copyarea) stride=%d\\n\", stride);\n\tdbg_blit(\"(copyarea) bpp=%d=0x0%d, mem_offset1=%d, mem_offset2=%d\\n\", bpp, (bpp >> 1),\n\t\t(stride >> 1) & 0xff, stride >> 9);\n\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_CC_EXP, 0x0c);\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_CTL0, 0x80);\n\n\t \n\tbltbit_wait_bitclear(info, 0x80, 8000);\n\n\tspin_unlock(&s1d13xxxfb_bitblt_lock);\n}\n\n \nstatic void\ns1d13xxxfb_bitblt_solidfill(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tu32 screen_stride, dest;\n\tu32 fg;\n\tu16 bpp = (info->var.bits_per_pixel >> 3);\n\n\t \n\tspin_lock(&s1d13xxxfb_bitblt_lock);\n\n\t \n\tscreen_stride = (bpp * info->var.xres);\n\n\t \n\tdest = ((rect->dy * screen_stride) + (bpp * rect->dx));\n\n\tdbg_blit(\"(solidfill) dx=%d, dy=%d, stride=%d, dest=%d\\n\"\n\t\t \"(solidfill) : rect_width=%d, rect_height=%d\\n\",\n\t\t\t\trect->dx, rect->dy, screen_stride, dest,\n\t\t\t\trect->width - 1, rect->height - 1);\n\n\tdbg_blit(\"(solidfill) : xres=%d, yres=%d, bpp=%d\\n\",\n\t\t\t\tinfo->var.xres, info->var.yres,\n\t\t\t\tinfo->var.bits_per_pixel);\n\tdbg_blit(\"(solidfill) : rop=%d\\n\", rect->rop);\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_DST_START0, (dest & 0x00ff));\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_DST_START1, ((dest >> 8) & 0x00ff));\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_DST_START2, ((dest >> 16) & 0x00ff));\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_WIDTH0, ((rect->width) & 0x00ff) - 1);\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_WIDTH1, (rect->width >> 8));\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_HEIGHT0, ((rect->height) & 0x00ff) - 1);\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_HEIGHT1, (rect->height >> 8));\n\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\n\t\tinfo->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\tfg = ((u32 *)info->pseudo_palette)[rect->color];\n\t\tdbg_blit(\"(solidfill) truecolor/directcolor\\n\");\n\t\tdbg_blit(\"(solidfill) pseudo_palette[%d] = %d\\n\", rect->color, fg);\n\t} else {\n\t\tfg = rect->color;\n\t\tdbg_blit(\"(solidfill) color = %d\\n\", rect->color);\n\t}\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_FGC0, (fg & 0xff));\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_FGC1, (fg >> 8) & 0xff);\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_CTL0, 0x0);\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_OP, BBLT_SOLID_FILL);\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_CTL1, (info->var.bits_per_pixel >> 4));\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_MEM_OFF0, (screen_stride >> 1) & 0x00ff);\n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_MEM_OFF1, (screen_stride >> 9));\n\n\t \n\ts1d13xxxfb_writereg(info->par, S1DREG_BBLT_CTL0, 0x80);\n\n\t \n\tbltbit_wait_bitclear(info, 0x80, 8000);\n\n\t \n\tspin_unlock(&s1d13xxxfb_bitblt_lock);\n}\n\n \nstatic struct fb_ops s1d13xxxfb_fbops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_set_par\t= s1d13xxxfb_set_par,\n\t.fb_setcolreg\t= s1d13xxxfb_setcolreg,\n\t.fb_blank\t= s1d13xxxfb_blank,\n\n\t.fb_pan_display\t= s1d13xxxfb_pan_display,\n\n\t \n\t.fb_fillrect\t= cfb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n};\n\nstatic int s1d13xxxfb_width_tab[2][4] = {\n\t{4, 8, 16, -1},\n\t{9, 12, 18, -1},\n};\n\n \nstatic void s1d13xxxfb_fetch_hw_state(struct fb_info *info)\n{\n\tstruct fb_var_screeninfo *var = &info->var;\n\tstruct fb_fix_screeninfo *fix = &info->fix;\n\tstruct s1d13xxxfb_par *par = info->par;\n\tu8 panel, display;\n\tu16 offset;\n\tu32 xres, yres;\n\tu32 xres_virtual, yres_virtual;\n\tint bpp, lcd_bpp;\n\tint is_color, is_dual, is_tft;\n\tint lcd_enabled, crt_enabled;\n\n\tfix->type = FB_TYPE_PACKED_PIXELS;\n\n\t \n\tpar->display = s1d13xxxfb_readreg(par, S1DREG_COM_DISP_MODE);\n\tcrt_enabled = (par->display & 0x02) != 0;\n\tlcd_enabled = (par->display & 0x01) != 0;\n\n\tif (lcd_enabled && crt_enabled)\n\t\tprintk(KERN_WARNING PFX \"Warning: LCD and CRT detected, using LCD\\n\");\n\n\tif (lcd_enabled)\n\t\tdisplay = s1d13xxxfb_readreg(par, S1DREG_LCD_DISP_MODE);\n\telse\t \n\t\tdisplay = s1d13xxxfb_readreg(par, S1DREG_CRT_DISP_MODE);\n\n\tbpp = display & 0x07;\n\n\tswitch (bpp) {\n\t\tcase 2:\t \n\t\tcase 3:\t \n\t\t\tvar->bits_per_pixel = 8;\n\t\t\tvar->red.offset = var->green.offset = var->blue.offset = 0;\n\t\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\t\tbreak;\n\t\tcase 5:\t \n\t\t\ts1d13xxxfb_setup_truecolour(info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdbg(\"bpp: %i\\n\", bpp);\n\t}\n\tfb_alloc_cmap(&info->cmap, 256, 0);\n\n\t \n\tpanel = s1d13xxxfb_readreg(par, S1DREG_PANEL_TYPE);\n\tis_color = (panel & 0x04) != 0;\n\tis_dual = (panel & 0x02) != 0;\n\tis_tft = (panel & 0x01) != 0;\n\tlcd_bpp = s1d13xxxfb_width_tab[is_tft][(panel >> 4) & 3];\n\n\tif (lcd_enabled) {\n\t\txres = (s1d13xxxfb_readreg(par, S1DREG_LCD_DISP_HWIDTH) + 1) * 8;\n\t\tyres = (s1d13xxxfb_readreg(par, S1DREG_LCD_DISP_VHEIGHT0) +\n\t\t\t((s1d13xxxfb_readreg(par, S1DREG_LCD_DISP_VHEIGHT1) & 0x03) << 8) + 1);\n\n\t\toffset = (s1d13xxxfb_readreg(par, S1DREG_LCD_MEM_OFF0) +\n\t\t\t((s1d13xxxfb_readreg(par, S1DREG_LCD_MEM_OFF1) & 0x7) << 8));\n\t} else {  \n\t\txres = (s1d13xxxfb_readreg(par, S1DREG_CRT_DISP_HWIDTH) + 1) * 8;\n\t\tyres = (s1d13xxxfb_readreg(par, S1DREG_CRT_DISP_VHEIGHT0) +\n\t\t\t((s1d13xxxfb_readreg(par, S1DREG_CRT_DISP_VHEIGHT1) & 0x03) << 8) + 1);\n\n\t\toffset = (s1d13xxxfb_readreg(par, S1DREG_CRT_MEM_OFF0) +\n\t\t\t((s1d13xxxfb_readreg(par, S1DREG_CRT_MEM_OFF1) & 0x7) << 8));\n\t}\n\txres_virtual = offset * 16 / var->bits_per_pixel;\n\tyres_virtual = fix->smem_len / (offset * 2);\n\n\tvar->xres\t\t= xres;\n\tvar->yres\t\t= yres;\n\tvar->xres_virtual\t= xres_virtual;\n\tvar->yres_virtual\t= yres_virtual;\n\tvar->xoffset\t\t= var->yoffset = 0;\n\n\tfix->line_length\t= offset * 2;\n\n\tvar->grayscale\t\t= !is_color;\n\n\tvar->activate\t\t= FB_ACTIVATE_NOW;\n\n\tdbg(PFX \"bpp=%d, lcd_bpp=%d, \"\n\t\t\"crt_enabled=%d, lcd_enabled=%d\\n\",\n\t\tvar->bits_per_pixel, lcd_bpp, crt_enabled, lcd_enabled);\n\tdbg(PFX \"xres=%d, yres=%d, vxres=%d, vyres=%d \"\n\t\t\"is_color=%d, is_dual=%d, is_tft=%d\\n\",\n\t\txres, yres, xres_virtual, yres_virtual, is_color, is_dual, is_tft);\n}\n\nstatic void __s1d13xxxfb_remove(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\tstruct s1d13xxxfb_par *par = NULL;\n\n\tif (info) {\n\t\tpar = info->par;\n\t\tif (par && par->regs) {\n\t\t\t \n\t\t\ts1d13xxxfb_writereg(par, S1DREG_COM_DISP_MODE, 0x00);\n\t\t\ts1d13xxxfb_writereg(par, S1DREG_PS_CNF, 0x11);\n\t\t\tiounmap(par->regs);\n\t\t}\n\n\t\tfb_dealloc_cmap(&info->cmap);\n\n\t\tif (info->screen_base)\n\t\t\tiounmap(info->screen_base);\n\n\t\tframebuffer_release(info);\n\t}\n\n\trelease_mem_region(pdev->resource[0].start,\n\t\t\t   resource_size(&pdev->resource[0]));\n\trelease_mem_region(pdev->resource[1].start,\n\t\t\t   resource_size(&pdev->resource[1]));\n}\n\nstatic void s1d13xxxfb_remove(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\n\tunregister_framebuffer(info);\n\t__s1d13xxxfb_remove(pdev);\n}\n\nstatic int s1d13xxxfb_probe(struct platform_device *pdev)\n{\n\tstruct s1d13xxxfb_par *default_par;\n\tstruct fb_info *info;\n\tstruct s1d13xxxfb_pdata *pdata = NULL;\n\tint ret = 0;\n\tint i;\n\tu8 revision, prod_id;\n\n\tdbg(\"probe called: device is %p\\n\", pdev);\n\n\tprintk(KERN_INFO \"Epson S1D13XXX FB Driver\\n\");\n\n\t \n\tif (dev_get_platdata(&pdev->dev))\n\t\tpdata = dev_get_platdata(&pdev->dev);\n\n\tif (pdata && pdata->platform_init_video)\n\t\tpdata->platform_init_video();\n\n\tif (pdev->num_resources != 2) {\n\t\tdev_err(&pdev->dev, \"invalid num_resources: %i\\n\",\n\t\t       pdev->num_resources);\n\t\tret = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\t \n\tif (pdev->resource[0].flags != IORESOURCE_MEM\n\t\t\t|| pdev->resource[1].flags != IORESOURCE_MEM) {\n\t\tdev_err(&pdev->dev, \"invalid resource type\\n\");\n\t\tret = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\tif (!request_mem_region(pdev->resource[0].start,\n\t\tresource_size(&pdev->resource[0]), \"s1d13xxxfb mem\")) {\n\t\tdev_dbg(&pdev->dev, \"request_mem_region failed\\n\");\n\t\tret = -EBUSY;\n\t\tgoto bail;\n\t}\n\n\tif (!request_mem_region(pdev->resource[1].start,\n\t\tresource_size(&pdev->resource[1]), \"s1d13xxxfb regs\")) {\n\t\tdev_dbg(&pdev->dev, \"request_mem_region failed\\n\");\n\t\tret = -EBUSY;\n\t\tgoto bail;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct s1d13xxxfb_par) + sizeof(u32) * 256, &pdev->dev);\n\tif (!info) {\n\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tplatform_set_drvdata(pdev, info);\n\tdefault_par = info->par;\n\tdefault_par->regs = ioremap(pdev->resource[1].start,\n\t\t\t\t    resource_size(&pdev->resource[1]));\n\tif (!default_par->regs) {\n\t\tprintk(KERN_ERR PFX \"unable to map registers\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tinfo->pseudo_palette = default_par->pseudo_palette;\n\n\tinfo->screen_base = ioremap(pdev->resource[0].start,\n\t\t\t\t    resource_size(&pdev->resource[0]));\n\n\tif (!info->screen_base) {\n\t\tprintk(KERN_ERR PFX \"unable to map framebuffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\t \n\tprod_id = s1d13xxxfb_readreg(default_par, S1DREG_REV_CODE) >> 2;\n\t \n\trevision = s1d13xxxfb_readreg(default_par, S1DREG_REV_CODE) & 0x3;\n\tret = -ENODEV;\n\n\tfor (i = 0; i < ARRAY_SIZE(s1d13xxxfb_prod_ids); i++) {\n\t\tif (prod_id == s1d13xxxfb_prod_ids[i]) {\n\t\t\t \n\t\t\tdefault_par->prod_id = prod_id;\n\t\t\tdefault_par->revision = revision;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\tprintk(KERN_INFO PFX \"chip production id %i = %s\\n\",\n\t\t\tprod_id, s1d13xxxfb_prod_names[i]);\n\t\tprintk(KERN_INFO PFX \"chip revision %i\\n\", revision);\n\t} else {\n\t\tprintk(KERN_INFO PFX\n\t\t\t\"unknown chip production id %i, revision %i\\n\",\n\t\t\tprod_id, revision);\n\t\tprintk(KERN_INFO PFX \"please contact maintainer\\n\");\n\t\tgoto bail;\n\t}\n\n\tinfo->fix = s1d13xxxfb_fix;\n\tinfo->fix.mmio_start = pdev->resource[1].start;\n\tinfo->fix.mmio_len = resource_size(&pdev->resource[1]);\n\tinfo->fix.smem_start = pdev->resource[0].start;\n\tinfo->fix.smem_len = resource_size(&pdev->resource[0]);\n\n\tprintk(KERN_INFO PFX \"regs mapped at 0x%p, fb %d KiB mapped at 0x%p\\n\",\n\t       default_par->regs, info->fix.smem_len / 1024, info->screen_base);\n\n\tinfo->par = default_par;\n\tinfo->flags = FBINFO_HWACCEL_YPAN;\n\tinfo->fbops = &s1d13xxxfb_fbops;\n\n\tswitch(prod_id) {\n\tcase S1D13506_PROD_ID:\t \n\t\ts1d13xxxfb_fbops.fb_fillrect = s1d13xxxfb_bitblt_solidfill;\n\t\ts1d13xxxfb_fbops.fb_copyarea = s1d13xxxfb_bitblt_copyarea;\n\t\tinfo->flags = FBINFO_HWACCEL_YPAN |\n\t\t\tFBINFO_HWACCEL_FILLRECT | FBINFO_HWACCEL_COPYAREA;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (pdata && pdata->initregs)\n\t\ts1d13xxxfb_runinit(info->par, pdata->initregs, pdata->initregssize);\n\n\ts1d13xxxfb_fetch_hw_state(info);\n\n\tif (register_framebuffer(info) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\n\treturn 0;\n\nbail:\n\t__s1d13xxxfb_remove(pdev);\n\treturn ret;\n\n}\n\n#ifdef CONFIG_PM\nstatic int s1d13xxxfb_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\tstruct s1d13xxxfb_par *s1dfb = info->par;\n\tstruct s1d13xxxfb_pdata *pdata = NULL;\n\n\t \n\tlcd_enable(s1dfb, 0);\n\tcrt_enable(s1dfb, 0);\n\n\tif (dev_get_platdata(&dev->dev))\n\t\tpdata = dev_get_platdata(&dev->dev);\n\n#if 0\n\tif (!s1dfb->disp_save)\n\t\ts1dfb->disp_save = kmalloc(info->fix.smem_len, GFP_KERNEL);\n\n\tif (!s1dfb->disp_save) {\n\t\tprintk(KERN_ERR PFX \"no memory to save screen\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy_fromio(s1dfb->disp_save, info->screen_base, info->fix.smem_len);\n#else\n\ts1dfb->disp_save = NULL;\n#endif\n\n\tif (!s1dfb->regs_save)\n\t\ts1dfb->regs_save = kmalloc(info->fix.mmio_len, GFP_KERNEL);\n\n\tif (!s1dfb->regs_save) {\n\t\tprintk(KERN_ERR PFX \"no memory to save registers\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmemcpy_fromio(s1dfb->regs_save, s1dfb->regs, info->fix.mmio_len);\n\n\t \n\ts1d13xxxfb_writereg(s1dfb, S1DREG_PS_CNF, 0x11);\n\n\tif (pdata && pdata->platform_suspend_video)\n\t\treturn pdata->platform_suspend_video();\n\telse\n\t\treturn 0;\n}\n\nstatic int s1d13xxxfb_resume(struct platform_device *dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\tstruct s1d13xxxfb_par *s1dfb = info->par;\n\tstruct s1d13xxxfb_pdata *pdata = NULL;\n\n\t \n\ts1d13xxxfb_writereg(s1dfb, S1DREG_PS_CNF, 0x10);\n\n\t \n\twhile ((s1d13xxxfb_readreg(s1dfb, S1DREG_PS_STATUS) & 0x01))\n\t\tudelay(10);\n\n\tif (dev_get_platdata(&dev->dev))\n\t\tpdata = dev_get_platdata(&dev->dev);\n\n\tif (s1dfb->regs_save) {\n\t\t \n\t\tmemcpy_toio(s1dfb->regs, s1dfb->regs_save, info->fix.mmio_len);\n\t\tkfree(s1dfb->regs_save);\n\t}\n\n\tif (s1dfb->disp_save) {\n\t\tmemcpy_toio(info->screen_base, s1dfb->disp_save,\n\t\t\t\tinfo->fix.smem_len);\n\t\tkfree(s1dfb->disp_save);\t \n\t}\n\n\tif ((s1dfb->display & 0x01) != 0)\n\t\tlcd_enable(s1dfb, 1);\n\tif ((s1dfb->display & 0x02) != 0)\n\t\tcrt_enable(s1dfb, 1);\n\n\tif (pdata && pdata->platform_resume_video)\n\t\treturn pdata->platform_resume_video();\n\telse\n\t\treturn 0;\n}\n#endif  \n\nstatic struct platform_driver s1d13xxxfb_driver = {\n\t.probe\t\t= s1d13xxxfb_probe,\n\t.remove_new\t= s1d13xxxfb_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= s1d13xxxfb_suspend,\n\t.resume\t\t= s1d13xxxfb_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= S1D_DEVICENAME,\n\t},\n};\n\n\nstatic int __init\ns1d13xxxfb_init(void)\n{\n\n#ifndef MODULE\n\tif (fb_get_options(\"s1d13xxxfb\", NULL))\n\t\treturn -ENODEV;\n#endif\n\n\treturn platform_driver_register(&s1d13xxxfb_driver);\n}\n\n\nstatic void __exit\ns1d13xxxfb_exit(void)\n{\n\tplatform_driver_unregister(&s1d13xxxfb_driver);\n}\n\nmodule_init(s1d13xxxfb_init);\nmodule_exit(s1d13xxxfb_exit);\n\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Framebuffer driver for S1D13xxx devices\");\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>, Thibaut VARENE <varenet@parisc-linux.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}