{
  "module_name": "c2p_iplan2.c",
  "hash_id": "55af79e5cac150945cbb097c37791544e31bd4bdfcf59f2cc9bedbce5de0cf1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/c2p_iplan2.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/string.h>\n\n#include <asm/unaligned.h>\n\n#include \"c2p.h\"\n#include \"c2p_core.h\"\n\n\n     \n\nstatic void c2p_16x8(u32 d[4])\n{\n\ttransp4(d, 8, 2);\n\ttransp4(d, 1, 2);\n\ttransp4x(d, 16, 2);\n\ttransp4x(d, 2, 2);\n\ttransp4(d, 4, 1);\n}\n\n\n     \n\nstatic const int perm_c2p_16x8[4] = { 1, 3, 0, 2 };\n\n\n     \n\nstatic inline void store_iplan2(void *dst, u32 bpp, u32 d[4])\n{\n\tint i;\n\n\tfor (i = 0; i < bpp/2; i++, dst += 4)\n\t\tput_unaligned_be32(d[perm_c2p_16x8[i]], dst);\n}\n\n\n     \n\nstatic inline void store_iplan2_masked(void *dst, u32 bpp, u32 d[4], u32 mask)\n{\n\tint i;\n\n\tfor (i = 0; i < bpp/2; i++, dst += 4)\n\t\tput_unaligned_be32(comp(d[perm_c2p_16x8[i]],\n\t\t\t\t\tget_unaligned_be32(dst), mask),\n\t\t\t\t   dst);\n}\n\n\n     \n\nvoid c2p_iplan2(void *dst, const void *src, u32 dx, u32 dy, u32 width,\n\t\tu32 height, u32 dst_nextline, u32 src_nextline, u32 bpp)\n{\n\tunion {\n\t\tu8 pixels[16];\n\t\tu32 words[4];\n\t} d;\n\tu32 dst_idx, first, last, w;\n\tconst u8 *c;\n\tvoid *p;\n\n\tdst += dy*dst_nextline+(dx & ~15)*bpp;\n\tdst_idx = dx % 16;\n\tfirst = 0xffffU >> dst_idx;\n\tfirst |= first << 16;\n\tlast = 0xffffU ^ (0xffffU >> ((dst_idx+width) % 16));\n\tlast |= last << 16;\n\twhile (height--) {\n\t\tc = src;\n\t\tp = dst;\n\t\tw = width;\n\t\tif (dst_idx+width <= 16) {\n\t\t\t \n\t\t\tfirst &= last;\n\t\t\tmemset(d.pixels, 0, sizeof(d));\n\t\t\tmemcpy(d.pixels+dst_idx, c, width);\n\t\t\tc += width;\n\t\t\tc2p_16x8(d.words);\n\t\t\tstore_iplan2_masked(p, bpp, d.words, first);\n\t\t\tp += bpp*2;\n\t\t} else {\n\t\t\t \n\t\t\tw = width;\n\t\t\t \n\t\t\tif (dst_idx) {\n\t\t\t\tw = 16 - dst_idx;\n\t\t\t\tmemset(d.pixels, 0, dst_idx);\n\t\t\t\tmemcpy(d.pixels+dst_idx, c, w);\n\t\t\t\tc += w;\n\t\t\t\tc2p_16x8(d.words);\n\t\t\t\tstore_iplan2_masked(p, bpp, d.words, first);\n\t\t\t\tp += bpp*2;\n\t\t\t\tw = width-w;\n\t\t\t}\n\t\t\t \n\t\t\twhile (w >= 16) {\n\t\t\t\tmemcpy(d.pixels, c, 16);\n\t\t\t\tc += 16;\n\t\t\t\tc2p_16x8(d.words);\n\t\t\t\tstore_iplan2(p, bpp, d.words);\n\t\t\t\tp += bpp*2;\n\t\t\t\tw -= 16;\n\t\t\t}\n\t\t\t \n\t\t\tw %= 16;\n\t\t\tif (w > 0) {\n\t\t\t\tmemcpy(d.pixels, c, w);\n\t\t\t\tmemset(d.pixels+w, 0, 16-w);\n\t\t\t\tc2p_16x8(d.words);\n\t\t\t\tstore_iplan2_masked(p, bpp, d.words, last);\n\t\t\t}\n\t\t}\n\t\tsrc += src_nextline;\n\t\tdst += dst_nextline;\n\t}\n}\nEXPORT_SYMBOL_GPL(c2p_iplan2);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}