{
  "module_name": "udlfb.c",
  "hash_id": "801c50ea57e938c83c28ca4e2f3c900a7a2d28f8c70ce6d009cd1bf4fcb9c8ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/udlfb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/usb.h>\n#include <linux/uaccess.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <asm/unaligned.h>\n#include <video/udlfb.h>\n#include \"edid.h\"\n\n#define OUT_EP_NUM\t1\t \n\nstatic const struct fb_fix_screeninfo dlfb_fix = {\n\t.id =           \"udlfb\",\n\t.type =         FB_TYPE_PACKED_PIXELS,\n\t.visual =       FB_VISUAL_TRUECOLOR,\n\t.xpanstep =     0,\n\t.ypanstep =     0,\n\t.ywrapstep =    0,\n\t.accel =        FB_ACCEL_NONE,\n};\n\nstatic const u32 udlfb_info_flags = FBINFO_READS_FAST |\n\t\tFBINFO_VIRTFB |\n\t\tFBINFO_HWACCEL_IMAGEBLIT | FBINFO_HWACCEL_FILLRECT |\n\t\tFBINFO_HWACCEL_COPYAREA | FBINFO_MISC_ALWAYS_SETPAR;\n\n \nstatic const struct usb_device_id id_table[] = {\n\t{.idVendor = 0x17e9,\n\t .bInterfaceClass = 0xff,\n\t .bInterfaceSubClass = 0x00,\n\t .bInterfaceProtocol = 0x00,\n\t .match_flags = USB_DEVICE_ID_MATCH_VENDOR |\n\t\tUSB_DEVICE_ID_MATCH_INT_CLASS |\n\t\tUSB_DEVICE_ID_MATCH_INT_SUBCLASS |\n\t\tUSB_DEVICE_ID_MATCH_INT_PROTOCOL,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\n \nstatic bool console = true;  \nstatic bool fb_defio = true;   \nstatic bool shadow = true;  \nstatic int pixel_limit;  \n\nstruct dlfb_deferred_free {\n\tstruct list_head list;\n\tvoid *mem;\n};\n\nstatic int dlfb_realloc_framebuffer(struct dlfb_data *dlfb, struct fb_info *info, u32 new_len);\n\n \nstatic void dlfb_urb_completion(struct urb *urb);\nstatic struct urb *dlfb_get_urb(struct dlfb_data *dlfb);\nstatic int dlfb_submit_urb(struct dlfb_data *dlfb, struct urb * urb, size_t len);\nstatic int dlfb_alloc_urb_list(struct dlfb_data *dlfb, int count, size_t size);\nstatic void dlfb_free_urb_list(struct dlfb_data *dlfb);\n\n \nstatic char *dlfb_set_register(char *buf, u8 reg, u8 val)\n{\n\t*buf++ = 0xAF;\n\t*buf++ = 0x20;\n\t*buf++ = reg;\n\t*buf++ = val;\n\treturn buf;\n}\n\nstatic char *dlfb_vidreg_lock(char *buf)\n{\n\treturn dlfb_set_register(buf, 0xFF, 0x00);\n}\n\nstatic char *dlfb_vidreg_unlock(char *buf)\n{\n\treturn dlfb_set_register(buf, 0xFF, 0xFF);\n}\n\n \nstatic char *dlfb_blanking(char *buf, int fb_blank)\n{\n\tu8 reg;\n\n\tswitch (fb_blank) {\n\tcase FB_BLANK_POWERDOWN:\n\t\treg = 0x07;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\treg = 0x05;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\treg = 0x03;\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\treg = 0x01;\n\t\tbreak;\n\tdefault:\n\t\treg = 0x00;\n\t}\n\n\tbuf = dlfb_set_register(buf, 0x1F, reg);\n\n\treturn buf;\n}\n\nstatic char *dlfb_set_color_depth(char *buf, u8 selection)\n{\n\treturn dlfb_set_register(buf, 0x00, selection);\n}\n\nstatic char *dlfb_set_base16bpp(char *wrptr, u32 base)\n{\n\t \n\twrptr = dlfb_set_register(wrptr, 0x20, base >> 16);\n\twrptr = dlfb_set_register(wrptr, 0x21, base >> 8);\n\treturn dlfb_set_register(wrptr, 0x22, base);\n}\n\n \nstatic char *dlfb_set_base8bpp(char *wrptr, u32 base)\n{\n\twrptr = dlfb_set_register(wrptr, 0x26, base >> 16);\n\twrptr = dlfb_set_register(wrptr, 0x27, base >> 8);\n\treturn dlfb_set_register(wrptr, 0x28, base);\n}\n\nstatic char *dlfb_set_register_16(char *wrptr, u8 reg, u16 value)\n{\n\twrptr = dlfb_set_register(wrptr, reg, value >> 8);\n\treturn dlfb_set_register(wrptr, reg+1, value);\n}\n\n \nstatic char *dlfb_set_register_16be(char *wrptr, u8 reg, u16 value)\n{\n\twrptr = dlfb_set_register(wrptr, reg, value);\n\treturn dlfb_set_register(wrptr, reg+1, value >> 8);\n}\n\n \nstatic u16 dlfb_lfsr16(u16 actual_count)\n{\n\tu32 lv = 0xFFFF;  \n\n\twhile (actual_count--) {\n\t\tlv =\t ((lv << 1) |\n\t\t\t(((lv >> 15) ^ (lv >> 4) ^ (lv >> 2) ^ (lv >> 1)) & 1))\n\t\t\t& 0xFFFF;\n\t}\n\n\treturn (u16) lv;\n}\n\n \nstatic char *dlfb_set_register_lfsr16(char *wrptr, u8 reg, u16 value)\n{\n\treturn dlfb_set_register_16(wrptr, reg, dlfb_lfsr16(value));\n}\n\n \nstatic char *dlfb_set_vid_cmds(char *wrptr, struct fb_var_screeninfo *var)\n{\n\tu16 xds, yds;\n\tu16 xde, yde;\n\tu16 yec;\n\n\t \n\txds = var->left_margin + var->hsync_len;\n\twrptr = dlfb_set_register_lfsr16(wrptr, 0x01, xds);\n\t \n\txde = xds + var->xres;\n\twrptr = dlfb_set_register_lfsr16(wrptr, 0x03, xde);\n\n\t \n\tyds = var->upper_margin + var->vsync_len;\n\twrptr = dlfb_set_register_lfsr16(wrptr, 0x05, yds);\n\t \n\tyde = yds + var->yres;\n\twrptr = dlfb_set_register_lfsr16(wrptr, 0x07, yde);\n\n\t \n\twrptr = dlfb_set_register_lfsr16(wrptr, 0x09,\n\t\t\txde + var->right_margin - 1);\n\n\t \n\twrptr = dlfb_set_register_lfsr16(wrptr, 0x0B, 1);\n\n\t \n\twrptr = dlfb_set_register_lfsr16(wrptr, 0x0D, var->hsync_len + 1);\n\n\t \n\twrptr = dlfb_set_register_16(wrptr, 0x0F, var->xres);\n\n\t \n\tyec = var->yres + var->upper_margin + var->lower_margin +\n\t\t\tvar->vsync_len;\n\twrptr = dlfb_set_register_lfsr16(wrptr, 0x11, yec);\n\n\t \n\twrptr = dlfb_set_register_lfsr16(wrptr, 0x13, 0);\n\n\t \n\twrptr = dlfb_set_register_lfsr16(wrptr, 0x15, var->vsync_len);\n\n\t \n\twrptr = dlfb_set_register_16(wrptr, 0x17, var->yres);\n\n\t \n\twrptr = dlfb_set_register_16be(wrptr, 0x1B,\n\t\t\t200*1000*1000/var->pixclock);\n\n\treturn wrptr;\n}\n\n \nstatic int dlfb_set_video_mode(struct dlfb_data *dlfb,\n\t\t\t\tstruct fb_var_screeninfo *var)\n{\n\tchar *buf;\n\tchar *wrptr;\n\tint retval;\n\tint writesize;\n\tstruct urb *urb;\n\n\tif (!atomic_read(&dlfb->usb_active))\n\t\treturn -EPERM;\n\n\turb = dlfb_get_urb(dlfb);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tbuf = (char *) urb->transfer_buffer;\n\n\t \n\twrptr = dlfb_vidreg_lock(buf);\n\twrptr = dlfb_set_color_depth(wrptr, 0x00);\n\t \n\twrptr = dlfb_set_base16bpp(wrptr, 0);\n\t \n\twrptr = dlfb_set_base8bpp(wrptr, dlfb->info->fix.smem_len);\n\n\twrptr = dlfb_set_vid_cmds(wrptr, var);\n\twrptr = dlfb_blanking(wrptr, FB_BLANK_UNBLANK);\n\twrptr = dlfb_vidreg_unlock(wrptr);\n\n\twritesize = wrptr - buf;\n\n\tretval = dlfb_submit_urb(dlfb, urb, writesize);\n\n\tdlfb->blank_mode = FB_BLANK_UNBLANK;\n\n\treturn retval;\n}\n\nstatic int dlfb_ops_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tunsigned long start = vma->vm_start;\n\tunsigned long size = vma->vm_end - vma->vm_start;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\tunsigned long page, pos;\n\n\tif (info->fbdefio)\n\t\treturn fb_deferred_io_mmap(info, vma);\n\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\tif (size > info->fix.smem_len)\n\t\treturn -EINVAL;\n\tif (offset > info->fix.smem_len - size)\n\t\treturn -EINVAL;\n\n\tpos = (unsigned long)info->fix.smem_start + offset;\n\n\tdev_dbg(info->dev, \"mmap() framebuffer addr:%lu size:%lu\\n\",\n\t\tpos, size);\n\n\twhile (size > 0) {\n\t\tpage = vmalloc_to_pfn((void *)pos);\n\t\tif (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED))\n\t\t\treturn -EAGAIN;\n\n\t\tstart += PAGE_SIZE;\n\t\tpos += PAGE_SIZE;\n\t\tif (size > PAGE_SIZE)\n\t\t\tsize -= PAGE_SIZE;\n\t\telse\n\t\t\tsize = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dlfb_trim_hline(const u8 *bback, const u8 **bfront, int *width_bytes)\n{\n\tint j, k;\n\tconst unsigned long *back = (const unsigned long *) bback;\n\tconst unsigned long *front = (const unsigned long *) *bfront;\n\tconst int width = *width_bytes / sizeof(unsigned long);\n\tint identical;\n\tint start = width;\n\tint end = width;\n\n\tfor (j = 0; j < width; j++) {\n\t\tif (back[j] != front[j]) {\n\t\t\tstart = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (k = width - 1; k > j; k--) {\n\t\tif (back[k] != front[k]) {\n\t\t\tend = k+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tidentical = start + (width - end);\n\t*bfront = (u8 *) &front[start];\n\t*width_bytes = (end - start) * sizeof(unsigned long);\n\n\treturn identical * sizeof(unsigned long);\n}\n\n \nstatic void dlfb_compress_hline(\n\tconst uint16_t **pixel_start_ptr,\n\tconst uint16_t *const pixel_end,\n\tuint32_t *device_address_ptr,\n\tuint8_t **command_buffer_ptr,\n\tconst uint8_t *const cmd_buffer_end,\n\tunsigned long back_buffer_offset,\n\tint *ident_ptr)\n{\n\tconst uint16_t *pixel = *pixel_start_ptr;\n\tuint32_t dev_addr  = *device_address_ptr;\n\tuint8_t *cmd = *command_buffer_ptr;\n\n\twhile ((pixel_end > pixel) &&\n\t       (cmd_buffer_end - MIN_RLX_CMD_BYTES > cmd)) {\n\t\tuint8_t *raw_pixels_count_byte = NULL;\n\t\tuint8_t *cmd_pixels_count_byte = NULL;\n\t\tconst uint16_t *raw_pixel_start = NULL;\n\t\tconst uint16_t *cmd_pixel_start, *cmd_pixel_end = NULL;\n\n\t\tif (back_buffer_offset &&\n\t\t    *pixel == *(u16 *)((u8 *)pixel + back_buffer_offset)) {\n\t\t\tpixel++;\n\t\t\tdev_addr += BPP;\n\t\t\t(*ident_ptr)++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*cmd++ = 0xAF;\n\t\t*cmd++ = 0x6B;\n\t\t*cmd++ = dev_addr >> 16;\n\t\t*cmd++ = dev_addr >> 8;\n\t\t*cmd++ = dev_addr;\n\n\t\tcmd_pixels_count_byte = cmd++;  \n\t\tcmd_pixel_start = pixel;\n\n\t\traw_pixels_count_byte = cmd++;  \n\t\traw_pixel_start = pixel;\n\n\t\tcmd_pixel_end = pixel + min3(MAX_CMD_PIXELS + 1UL,\n\t\t\t\t\t(unsigned long)(pixel_end - pixel),\n\t\t\t\t\t(unsigned long)(cmd_buffer_end - 1 - cmd) / BPP);\n\n\t\tif (back_buffer_offset) {\n\t\t\t \n\t\t\twhile (cmd_pixel_end - 1 > pixel &&\n\t\t\t       *(cmd_pixel_end - 1) == *(u16 *)((u8 *)(cmd_pixel_end - 1) + back_buffer_offset))\n\t\t\t\tcmd_pixel_end--;\n\t\t}\n\n\t\twhile (pixel < cmd_pixel_end) {\n\t\t\tconst uint16_t * const repeating_pixel = pixel;\n\t\t\tu16 pixel_value = *pixel;\n\n\t\t\tput_unaligned_be16(pixel_value, cmd);\n\t\t\tif (back_buffer_offset)\n\t\t\t\t*(u16 *)((u8 *)pixel + back_buffer_offset) = pixel_value;\n\t\t\tcmd += 2;\n\t\t\tpixel++;\n\n\t\t\tif (unlikely((pixel < cmd_pixel_end) &&\n\t\t\t\t     (*pixel == pixel_value))) {\n\t\t\t\t \n\t\t\t\t*raw_pixels_count_byte = ((repeating_pixel -\n\t\t\t\t\t\traw_pixel_start) + 1) & 0xFF;\n\n\t\t\t\tdo {\n\t\t\t\t\tif (back_buffer_offset)\n\t\t\t\t\t\t*(u16 *)((u8 *)pixel + back_buffer_offset) = pixel_value;\n\t\t\t\t\tpixel++;\n\t\t\t\t} while ((pixel < cmd_pixel_end) &&\n\t\t\t\t\t (*pixel == pixel_value));\n\n\t\t\t\t \n\t\t\t\t*cmd++ = ((pixel - repeating_pixel) - 1) & 0xFF;\n\n\t\t\t\t \n\t\t\t\traw_pixel_start = pixel;\n\t\t\t\traw_pixels_count_byte = cmd++;\n\t\t\t}\n\t\t}\n\n\t\tif (pixel > raw_pixel_start) {\n\t\t\t \n\t\t\t*raw_pixels_count_byte = (pixel-raw_pixel_start) & 0xFF;\n\t\t} else {\n\t\t\t \n\t\t\tcmd--;\n\t\t}\n\n\t\t*cmd_pixels_count_byte = (pixel - cmd_pixel_start) & 0xFF;\n\t\tdev_addr += (u8 *)pixel - (u8 *)cmd_pixel_start;\n\t}\n\n\tif (cmd_buffer_end - MIN_RLX_CMD_BYTES <= cmd) {\n\t\t \n\t\tif (cmd_buffer_end > cmd)\n\t\t\tmemset(cmd, 0xAF, cmd_buffer_end - cmd);\n\t\tcmd = (uint8_t *) cmd_buffer_end;\n\t}\n\n\t*command_buffer_ptr = cmd;\n\t*pixel_start_ptr = pixel;\n\t*device_address_ptr = dev_addr;\n}\n\n \nstatic int dlfb_render_hline(struct dlfb_data *dlfb, struct urb **urb_ptr,\n\t\t\t      const char *front, char **urb_buf_ptr,\n\t\t\t      u32 byte_offset, u32 byte_width,\n\t\t\t      int *ident_ptr, int *sent_ptr)\n{\n\tconst u8 *line_start, *line_end, *next_pixel;\n\tu32 dev_addr = dlfb->base16 + byte_offset;\n\tstruct urb *urb = *urb_ptr;\n\tu8 *cmd = *urb_buf_ptr;\n\tu8 *cmd_end = (u8 *) urb->transfer_buffer + urb->transfer_buffer_length;\n\tunsigned long back_buffer_offset = 0;\n\n\tline_start = (u8 *) (front + byte_offset);\n\tnext_pixel = line_start;\n\tline_end = next_pixel + byte_width;\n\n\tif (dlfb->backing_buffer) {\n\t\tint offset;\n\t\tconst u8 *back_start = (u8 *) (dlfb->backing_buffer\n\t\t\t\t\t\t+ byte_offset);\n\n\t\tback_buffer_offset = (unsigned long)back_start - (unsigned long)line_start;\n\n\t\t*ident_ptr += dlfb_trim_hline(back_start, &next_pixel,\n\t\t\t&byte_width);\n\n\t\toffset = next_pixel - line_start;\n\t\tline_end = next_pixel + byte_width;\n\t\tdev_addr += offset;\n\t\tback_start += offset;\n\t\tline_start += offset;\n\t}\n\n\twhile (next_pixel < line_end) {\n\n\t\tdlfb_compress_hline((const uint16_t **) &next_pixel,\n\t\t\t     (const uint16_t *) line_end, &dev_addr,\n\t\t\t(u8 **) &cmd, (u8 *) cmd_end, back_buffer_offset,\n\t\t\tident_ptr);\n\n\t\tif (cmd >= cmd_end) {\n\t\t\tint len = cmd - (u8 *) urb->transfer_buffer;\n\t\t\tif (dlfb_submit_urb(dlfb, urb, len))\n\t\t\t\treturn 1;  \n\t\t\t*sent_ptr += len;\n\t\t\turb = dlfb_get_urb(dlfb);\n\t\t\tif (!urb)\n\t\t\t\treturn 1;  \n\t\t\t*urb_ptr = urb;\n\t\t\tcmd = urb->transfer_buffer;\n\t\t\tcmd_end = &cmd[urb->transfer_buffer_length];\n\t\t}\n\t}\n\n\t*urb_buf_ptr = cmd;\n\n\treturn 0;\n}\n\nstatic int dlfb_handle_damage(struct dlfb_data *dlfb, int x, int y, int width, int height)\n{\n\tint i, ret;\n\tchar *cmd;\n\tcycles_t start_cycles, end_cycles;\n\tint bytes_sent = 0;\n\tint bytes_identical = 0;\n\tstruct urb *urb;\n\tint aligned_x;\n\n\tstart_cycles = get_cycles();\n\n\tmutex_lock(&dlfb->render_mutex);\n\n\taligned_x = DL_ALIGN_DOWN(x, sizeof(unsigned long));\n\twidth = DL_ALIGN_UP(width + (x-aligned_x), sizeof(unsigned long));\n\tx = aligned_x;\n\n\tif ((width <= 0) ||\n\t    (x + width > dlfb->info->var.xres) ||\n\t    (y + height > dlfb->info->var.yres)) {\n\t\tret = -EINVAL;\n\t\tgoto unlock_ret;\n\t}\n\n\tif (!atomic_read(&dlfb->usb_active)) {\n\t\tret = 0;\n\t\tgoto unlock_ret;\n\t}\n\n\turb = dlfb_get_urb(dlfb);\n\tif (!urb) {\n\t\tret = 0;\n\t\tgoto unlock_ret;\n\t}\n\tcmd = urb->transfer_buffer;\n\n\tfor (i = y; i < y + height ; i++) {\n\t\tconst int line_offset = dlfb->info->fix.line_length * i;\n\t\tconst int byte_offset = line_offset + (x * BPP);\n\n\t\tif (dlfb_render_hline(dlfb, &urb,\n\t\t\t\t      (char *) dlfb->info->fix.smem_start,\n\t\t\t\t      &cmd, byte_offset, width * BPP,\n\t\t\t\t      &bytes_identical, &bytes_sent))\n\t\t\tgoto error;\n\t}\n\n\tif (cmd > (char *) urb->transfer_buffer) {\n\t\tint len;\n\t\tif (cmd < (char *) urb->transfer_buffer + urb->transfer_buffer_length)\n\t\t\t*cmd++ = 0xAF;\n\t\t \n\t\tlen = cmd - (char *) urb->transfer_buffer;\n\t\tdlfb_submit_urb(dlfb, urb, len);\n\t\tbytes_sent += len;\n\t} else\n\t\tdlfb_urb_completion(urb);\n\nerror:\n\tatomic_add(bytes_sent, &dlfb->bytes_sent);\n\tatomic_add(bytes_identical, &dlfb->bytes_identical);\n\tatomic_add(width*height*2, &dlfb->bytes_rendered);\n\tend_cycles = get_cycles();\n\tatomic_add(((unsigned int) ((end_cycles - start_cycles)\n\t\t    >> 10)),  \n\t\t   &dlfb->cpu_kcycles_used);\n\n\tret = 0;\n\nunlock_ret:\n\tmutex_unlock(&dlfb->render_mutex);\n\treturn ret;\n}\n\nstatic void dlfb_init_damage(struct dlfb_data *dlfb)\n{\n\tdlfb->damage_x = INT_MAX;\n\tdlfb->damage_x2 = 0;\n\tdlfb->damage_y = INT_MAX;\n\tdlfb->damage_y2 = 0;\n}\n\nstatic void dlfb_damage_work(struct work_struct *w)\n{\n\tstruct dlfb_data *dlfb = container_of(w, struct dlfb_data, damage_work);\n\tint x, x2, y, y2;\n\n\tspin_lock_irq(&dlfb->damage_lock);\n\tx = dlfb->damage_x;\n\tx2 = dlfb->damage_x2;\n\ty = dlfb->damage_y;\n\ty2 = dlfb->damage_y2;\n\tdlfb_init_damage(dlfb);\n\tspin_unlock_irq(&dlfb->damage_lock);\n\n\tif (x < x2 && y < y2)\n\t\tdlfb_handle_damage(dlfb, x, y, x2 - x, y2 - y);\n}\n\nstatic void dlfb_offload_damage(struct dlfb_data *dlfb, int x, int y, int width, int height)\n{\n\tunsigned long flags;\n\tint x2 = x + width;\n\tint y2 = y + height;\n\n\tif (x >= x2 || y >= y2)\n\t\treturn;\n\n\tspin_lock_irqsave(&dlfb->damage_lock, flags);\n\tdlfb->damage_x = min(x, dlfb->damage_x);\n\tdlfb->damage_x2 = max(x2, dlfb->damage_x2);\n\tdlfb->damage_y = min(y, dlfb->damage_y);\n\tdlfb->damage_y2 = max(y2, dlfb->damage_y2);\n\tspin_unlock_irqrestore(&dlfb->damage_lock, flags);\n\n\tschedule_work(&dlfb->damage_work);\n}\n\n \nstatic ssize_t dlfb_ops_write(struct fb_info *info, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tssize_t result;\n\tstruct dlfb_data *dlfb = info->par;\n\tu32 offset = (u32) *ppos;\n\n\tresult = fb_sys_write(info, buf, count, ppos);\n\n\tif (result > 0) {\n\t\tint start = max((int)(offset / info->fix.line_length), 0);\n\t\tint lines = min((u32)((result / info->fix.line_length) + 1),\n\t\t\t\t(u32)info->var.yres);\n\n\t\tdlfb_handle_damage(dlfb, 0, start, info->var.xres,\n\t\t\tlines);\n\t}\n\n\treturn result;\n}\n\n \nstatic void dlfb_ops_copyarea(struct fb_info *info,\n\t\t\t\tconst struct fb_copyarea *area)\n{\n\n\tstruct dlfb_data *dlfb = info->par;\n\n\tsys_copyarea(info, area);\n\n\tdlfb_offload_damage(dlfb, area->dx, area->dy,\n\t\t\tarea->width, area->height);\n}\n\nstatic void dlfb_ops_imageblit(struct fb_info *info,\n\t\t\t\tconst struct fb_image *image)\n{\n\tstruct dlfb_data *dlfb = info->par;\n\n\tsys_imageblit(info, image);\n\n\tdlfb_offload_damage(dlfb, image->dx, image->dy,\n\t\t\timage->width, image->height);\n}\n\nstatic void dlfb_ops_fillrect(struct fb_info *info,\n\t\t\t  const struct fb_fillrect *rect)\n{\n\tstruct dlfb_data *dlfb = info->par;\n\n\tsys_fillrect(info, rect);\n\n\tdlfb_offload_damage(dlfb, rect->dx, rect->dy, rect->width,\n\t\t\t      rect->height);\n}\n\n \nstatic void dlfb_dpy_deferred_io(struct fb_info *info, struct list_head *pagereflist)\n{\n\tstruct fb_deferred_io_pageref *pageref;\n\tstruct dlfb_data *dlfb = info->par;\n\tstruct urb *urb;\n\tchar *cmd;\n\tcycles_t start_cycles, end_cycles;\n\tint bytes_sent = 0;\n\tint bytes_identical = 0;\n\tint bytes_rendered = 0;\n\n\tmutex_lock(&dlfb->render_mutex);\n\n\tif (!fb_defio)\n\t\tgoto unlock_ret;\n\n\tif (!atomic_read(&dlfb->usb_active))\n\t\tgoto unlock_ret;\n\n\tstart_cycles = get_cycles();\n\n\turb = dlfb_get_urb(dlfb);\n\tif (!urb)\n\t\tgoto unlock_ret;\n\n\tcmd = urb->transfer_buffer;\n\n\t \n\tlist_for_each_entry(pageref, pagereflist, list) {\n\t\tif (dlfb_render_hline(dlfb, &urb, (char *) info->fix.smem_start,\n\t\t\t\t      &cmd, pageref->offset, PAGE_SIZE,\n\t\t\t\t      &bytes_identical, &bytes_sent))\n\t\t\tgoto error;\n\t\tbytes_rendered += PAGE_SIZE;\n\t}\n\n\tif (cmd > (char *) urb->transfer_buffer) {\n\t\tint len;\n\t\tif (cmd < (char *) urb->transfer_buffer + urb->transfer_buffer_length)\n\t\t\t*cmd++ = 0xAF;\n\t\t \n\t\tlen = cmd - (char *) urb->transfer_buffer;\n\t\tdlfb_submit_urb(dlfb, urb, len);\n\t\tbytes_sent += len;\n\t} else\n\t\tdlfb_urb_completion(urb);\n\nerror:\n\tatomic_add(bytes_sent, &dlfb->bytes_sent);\n\tatomic_add(bytes_identical, &dlfb->bytes_identical);\n\tatomic_add(bytes_rendered, &dlfb->bytes_rendered);\n\tend_cycles = get_cycles();\n\tatomic_add(((unsigned int) ((end_cycles - start_cycles)\n\t\t    >> 10)),  \n\t\t   &dlfb->cpu_kcycles_used);\nunlock_ret:\n\tmutex_unlock(&dlfb->render_mutex);\n}\n\nstatic int dlfb_get_edid(struct dlfb_data *dlfb, char *edid, int len)\n{\n\tint i, ret;\n\tchar *rbuf;\n\n\trbuf = kmalloc(2, GFP_KERNEL);\n\tif (!rbuf)\n\t\treturn 0;\n\n\tfor (i = 0; i < len; i++) {\n\t\tret = usb_control_msg(dlfb->udev,\n\t\t\t\t      usb_rcvctrlpipe(dlfb->udev, 0), 0x02,\n\t\t\t\t      (0x80 | (0x02 << 5)), i << 8, 0xA1,\n\t\t\t\t      rbuf, 2, USB_CTRL_GET_TIMEOUT);\n\t\tif (ret < 2) {\n\t\t\tdev_err(&dlfb->udev->dev,\n\t\t\t\t\"Read EDID byte %d failed: %d\\n\", i, ret);\n\t\t\ti--;\n\t\t\tbreak;\n\t\t}\n\t\tedid[i] = rbuf[1];\n\t}\n\n\tkfree(rbuf);\n\n\treturn i;\n}\n\nstatic int dlfb_ops_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\n\tstruct dlfb_data *dlfb = info->par;\n\n\tif (!atomic_read(&dlfb->usb_active))\n\t\treturn 0;\n\n\t \n\tif (cmd == DLFB_IOCTL_RETURN_EDID) {\n\t\tvoid __user *edid = (void __user *)arg;\n\t\tif (copy_to_user(edid, dlfb->edid, dlfb->edid_size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\t \n\tif (cmd == DLFB_IOCTL_REPORT_DAMAGE) {\n\t\tstruct dloarea area;\n\n\t\tif (copy_from_user(&area, (void __user *)arg,\n\t\t\t\t  sizeof(struct dloarea)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (info->fbdefio)\n\t\t\tinfo->fbdefio->delay = DL_DEFIO_WRITE_DISABLE;\n\n\t\tif (area.x < 0)\n\t\t\tarea.x = 0;\n\n\t\tif (area.x > info->var.xres)\n\t\t\tarea.x = info->var.xres;\n\n\t\tif (area.y < 0)\n\t\t\tarea.y = 0;\n\n\t\tif (area.y > info->var.yres)\n\t\t\tarea.y = info->var.yres;\n\n\t\tdlfb_handle_damage(dlfb, area.x, area.y, area.w, area.h);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\ndlfb_ops_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t       unsigned blue, unsigned transp, struct fb_info *info)\n{\n\tint err = 0;\n\n\tif (regno >= info->cmap.len)\n\t\treturn 1;\n\n\tif (regno < 16) {\n\t\tif (info->var.red.offset == 10) {\n\t\t\t \n\t\t\t((u32 *) (info->pseudo_palette))[regno] =\n\t\t\t    ((red & 0xf800) >> 1) |\n\t\t\t    ((green & 0xf800) >> 6) | ((blue & 0xf800) >> 11);\n\t\t} else {\n\t\t\t \n\t\t\t((u32 *) (info->pseudo_palette))[regno] =\n\t\t\t    ((red & 0xf800)) |\n\t\t\t    ((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic int dlfb_ops_open(struct fb_info *info, int user)\n{\n\tstruct dlfb_data *dlfb = info->par;\n\n\t \n\tif ((user == 0) && (!console))\n\t\treturn -EBUSY;\n\n\t \n\tif (dlfb->virtualized)\n\t\treturn -ENODEV;\n\n\tdlfb->fb_count++;\n\n\tif (fb_defio && (info->fbdefio == NULL)) {\n\t\t \n\n\t\tstruct fb_deferred_io *fbdefio;\n\n\t\tfbdefio = kzalloc(sizeof(struct fb_deferred_io), GFP_KERNEL);\n\n\t\tif (fbdefio) {\n\t\t\tfbdefio->delay = DL_DEFIO_WRITE_DELAY;\n\t\t\tfbdefio->sort_pagereflist = true;\n\t\t\tfbdefio->deferred_io = dlfb_dpy_deferred_io;\n\t\t}\n\n\t\tinfo->fbdefio = fbdefio;\n\t\tfb_deferred_io_init(info);\n\t}\n\n\tdev_dbg(info->dev, \"open, user=%d fb_info=%p count=%d\\n\",\n\t\tuser, info, dlfb->fb_count);\n\n\treturn 0;\n}\n\nstatic void dlfb_ops_destroy(struct fb_info *info)\n{\n\tstruct dlfb_data *dlfb = info->par;\n\n\tcancel_work_sync(&dlfb->damage_work);\n\n\tmutex_destroy(&dlfb->render_mutex);\n\n\tif (info->cmap.len != 0)\n\t\tfb_dealloc_cmap(&info->cmap);\n\tif (info->monspecs.modedb)\n\t\tfb_destroy_modedb(info->monspecs.modedb);\n\tvfree(info->screen_buffer);\n\n\tfb_destroy_modelist(&info->modelist);\n\n\twhile (!list_empty(&dlfb->deferred_free)) {\n\t\tstruct dlfb_deferred_free *d = list_entry(dlfb->deferred_free.next, struct dlfb_deferred_free, list);\n\t\tlist_del(&d->list);\n\t\tvfree(d->mem);\n\t\tkfree(d);\n\t}\n\tvfree(dlfb->backing_buffer);\n\tkfree(dlfb->edid);\n\tdlfb_free_urb_list(dlfb);\n\tusb_put_dev(dlfb->udev);\n\tkfree(dlfb);\n\n\t \n\tframebuffer_release(info);\n}\n\n \nstatic int dlfb_ops_release(struct fb_info *info, int user)\n{\n\tstruct dlfb_data *dlfb = info->par;\n\n\tdlfb->fb_count--;\n\n\tif ((dlfb->fb_count == 0) && (info->fbdefio)) {\n\t\tfb_deferred_io_cleanup(info);\n\t\tkfree(info->fbdefio);\n\t\tinfo->fbdefio = NULL;\n\t}\n\n\tdev_dbg(info->dev, \"release, user=%d count=%d\\n\", user, dlfb->fb_count);\n\n\treturn 0;\n}\n\n \nstatic int dlfb_is_valid_mode(struct fb_videomode *mode, struct dlfb_data *dlfb)\n{\n\tif (mode->xres * mode->yres > dlfb->sku_pixel_limit)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void dlfb_var_color_format(struct fb_var_screeninfo *var)\n{\n\tconst struct fb_bitfield red = { 11, 5, 0 };\n\tconst struct fb_bitfield green = { 5, 6, 0 };\n\tconst struct fb_bitfield blue = { 0, 5, 0 };\n\n\tvar->bits_per_pixel = 16;\n\tvar->red = red;\n\tvar->green = green;\n\tvar->blue = blue;\n}\n\nstatic int dlfb_ops_check_var(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info)\n{\n\tstruct fb_videomode mode;\n\tstruct dlfb_data *dlfb = info->par;\n\n\t \n\tdlfb_var_color_format(var);\n\n\tfb_var_to_videomode(&mode, var);\n\n\tif (!dlfb_is_valid_mode(&mode, dlfb))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int dlfb_ops_set_par(struct fb_info *info)\n{\n\tstruct dlfb_data *dlfb = info->par;\n\tint result;\n\tu16 *pix_framebuffer;\n\tint i;\n\tstruct fb_var_screeninfo fvs;\n\tu32 line_length = info->var.xres * (info->var.bits_per_pixel / 8);\n\n\t \n\tfvs = info->var;\n\tfvs.activate = 0;\n\tfvs.vmode &= ~FB_VMODE_SMOOTH_XPAN;\n\n\tif (!memcmp(&dlfb->current_mode, &fvs, sizeof(struct fb_var_screeninfo)))\n\t\treturn 0;\n\n\tresult = dlfb_realloc_framebuffer(dlfb, info, info->var.yres * line_length);\n\tif (result)\n\t\treturn result;\n\n\tresult = dlfb_set_video_mode(dlfb, &info->var);\n\n\tif (result)\n\t\treturn result;\n\n\tdlfb->current_mode = fvs;\n\tinfo->fix.line_length = line_length;\n\n\tif (dlfb->fb_count == 0) {\n\n\t\t \n\n\t\tpix_framebuffer = (u16 *)info->screen_buffer;\n\t\tfor (i = 0; i < info->fix.smem_len / 2; i++)\n\t\t\tpix_framebuffer[i] = 0x37e6;\n\t}\n\n\tdlfb_handle_damage(dlfb, 0, 0, info->var.xres, info->var.yres);\n\n\treturn 0;\n}\n\n \nstatic char *dlfb_dummy_render(char *buf)\n{\n\t*buf++ = 0xAF;\n\t*buf++ = 0x6A;  \n\t*buf++ = 0x00;  \n\t*buf++ = 0x00;\n\t*buf++ = 0x00;\n\t*buf++ = 0x01;  \n\t*buf++ = 0x00;  \n\t*buf++ = 0x00;\n\t*buf++ = 0x00;\n\treturn buf;\n}\n\n \nstatic int dlfb_ops_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct dlfb_data *dlfb = info->par;\n\tchar *bufptr;\n\tstruct urb *urb;\n\n\tdev_dbg(info->dev, \"blank, mode %d --> %d\\n\",\n\t\tdlfb->blank_mode, blank_mode);\n\n\tif ((dlfb->blank_mode == FB_BLANK_POWERDOWN) &&\n\t    (blank_mode != FB_BLANK_POWERDOWN)) {\n\n\t\t \n\t\tdlfb_set_video_mode(dlfb, &info->var);\n\t}\n\n\turb = dlfb_get_urb(dlfb);\n\tif (!urb)\n\t\treturn 0;\n\n\tbufptr = (char *) urb->transfer_buffer;\n\tbufptr = dlfb_vidreg_lock(bufptr);\n\tbufptr = dlfb_blanking(bufptr, blank_mode);\n\tbufptr = dlfb_vidreg_unlock(bufptr);\n\n\t \n\tbufptr = dlfb_dummy_render(bufptr);\n\n\tdlfb_submit_urb(dlfb, urb, bufptr -\n\t\t\t(char *) urb->transfer_buffer);\n\n\tdlfb->blank_mode = blank_mode;\n\n\treturn 0;\n}\n\nstatic const struct fb_ops dlfb_ops = {\n\t.owner = THIS_MODULE,\n\t.fb_read = fb_sys_read,\n\t.fb_write = dlfb_ops_write,\n\t.fb_setcolreg = dlfb_ops_setcolreg,\n\t.fb_fillrect = dlfb_ops_fillrect,\n\t.fb_copyarea = dlfb_ops_copyarea,\n\t.fb_imageblit = dlfb_ops_imageblit,\n\t.fb_mmap = dlfb_ops_mmap,\n\t.fb_ioctl = dlfb_ops_ioctl,\n\t.fb_open = dlfb_ops_open,\n\t.fb_release = dlfb_ops_release,\n\t.fb_blank = dlfb_ops_blank,\n\t.fb_check_var = dlfb_ops_check_var,\n\t.fb_set_par = dlfb_ops_set_par,\n\t.fb_destroy = dlfb_ops_destroy,\n};\n\n\nstatic void dlfb_deferred_vfree(struct dlfb_data *dlfb, void *mem)\n{\n\tstruct dlfb_deferred_free *d = kmalloc(sizeof(struct dlfb_deferred_free), GFP_KERNEL);\n\tif (!d)\n\t\treturn;\n\td->mem = mem;\n\tlist_add(&d->list, &dlfb->deferred_free);\n}\n\n \nstatic int dlfb_realloc_framebuffer(struct dlfb_data *dlfb, struct fb_info *info, u32 new_len)\n{\n\tu32 old_len = info->fix.smem_len;\n\tconst void *old_fb = info->screen_buffer;\n\tunsigned char *new_fb;\n\tunsigned char *new_back = NULL;\n\n\tnew_len = PAGE_ALIGN(new_len);\n\n\tif (new_len > old_len) {\n\t\t \n\t\tnew_fb = vmalloc(new_len);\n\t\tif (!new_fb) {\n\t\t\tdev_err(info->dev, \"Virtual framebuffer alloc failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(new_fb, 0xff, new_len);\n\n\t\tif (info->screen_buffer) {\n\t\t\tmemcpy(new_fb, old_fb, old_len);\n\t\t\tdlfb_deferred_vfree(dlfb, info->screen_buffer);\n\t\t}\n\n\t\tinfo->screen_buffer = new_fb;\n\t\tinfo->fix.smem_len = new_len;\n\t\tinfo->fix.smem_start = (unsigned long) new_fb;\n\t\tinfo->flags = udlfb_info_flags;\n\n\t\t \n\t\tif (shadow)\n\t\t\tnew_back = vzalloc(new_len);\n\t\tif (!new_back)\n\t\t\tdev_info(info->dev,\n\t\t\t\t \"No shadow/backing buffer allocated\\n\");\n\t\telse {\n\t\t\tdlfb_deferred_vfree(dlfb, dlfb->backing_buffer);\n\t\t\tdlfb->backing_buffer = new_back;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int dlfb_setup_modes(struct dlfb_data *dlfb,\n\t\t\t   struct fb_info *info,\n\t\t\t   char *default_edid, size_t default_edid_size)\n{\n\tchar *edid;\n\tint i, result = 0, tries = 3;\n\tstruct device *dev = info->device;\n\tstruct fb_videomode *mode;\n\tconst struct fb_videomode *default_vmode = NULL;\n\n\tif (info->dev) {\n\t\t \n\t\tmutex_lock(&info->lock);\n\t\t \n\t\tdev = info->dev;\n\t}\n\n\tedid = kmalloc(EDID_LENGTH, GFP_KERNEL);\n\tif (!edid) {\n\t\tresult = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tfb_destroy_modelist(&info->modelist);\n\tmemset(&info->monspecs, 0, sizeof(info->monspecs));\n\n\t \n\twhile (tries--) {\n\n\t\ti = dlfb_get_edid(dlfb, edid, EDID_LENGTH);\n\n\t\tif (i >= EDID_LENGTH)\n\t\t\tfb_edid_to_monspecs(edid, &info->monspecs);\n\n\t\tif (info->monspecs.modedb_len > 0) {\n\t\t\tdlfb->edid = edid;\n\t\t\tdlfb->edid_size = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (info->monspecs.modedb_len == 0) {\n\t\tdev_err(dev, \"Unable to get valid EDID from device/display\\n\");\n\n\t\tif (dlfb->edid) {\n\t\t\tfb_edid_to_monspecs(dlfb->edid, &info->monspecs);\n\t\t\tif (info->monspecs.modedb_len > 0)\n\t\t\t\tdev_err(dev, \"Using previously queried EDID\\n\");\n\t\t}\n\t}\n\n\t \n\tif (info->monspecs.modedb_len == 0) {\n\t\tif (default_edid_size >= EDID_LENGTH) {\n\t\t\tfb_edid_to_monspecs(default_edid, &info->monspecs);\n\t\t\tif (info->monspecs.modedb_len > 0) {\n\t\t\t\tmemcpy(edid, default_edid, default_edid_size);\n\t\t\t\tdlfb->edid = edid;\n\t\t\t\tdlfb->edid_size = default_edid_size;\n\t\t\t\tdev_err(dev, \"Using default/backup EDID\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (info->monspecs.modedb_len > 0) {\n\n\t\tfor (i = 0; i < info->monspecs.modedb_len; i++) {\n\t\t\tmode = &info->monspecs.modedb[i];\n\t\t\tif (dlfb_is_valid_mode(mode, dlfb)) {\n\t\t\t\tfb_add_videomode(mode, &info->modelist);\n\t\t\t} else {\n\t\t\t\tdev_dbg(dev, \"Specified mode %dx%d too big\\n\",\n\t\t\t\t\tmode->xres, mode->yres);\n\t\t\t\tif (i == 0)\n\t\t\t\t\t \n\t\t\t\t\tinfo->monspecs.misc\n\t\t\t\t\t\t&= ~FB_MISC_1ST_DETAIL;\n\t\t\t}\n\t\t}\n\n\t\tdefault_vmode = fb_find_best_display(&info->monspecs,\n\t\t\t\t\t\t     &info->modelist);\n\t}\n\n\t \n\tif (default_vmode == NULL) {\n\n\t\tstruct fb_videomode fb_vmode = {0};\n\n\t\t \n\t\tfor (i = 0; i < VESA_MODEDB_SIZE; i++) {\n\t\t\tmode = (struct fb_videomode *)&vesa_modes[i];\n\t\t\tif (dlfb_is_valid_mode(mode, dlfb))\n\t\t\t\tfb_add_videomode(mode, &info->modelist);\n\t\t\telse\n\t\t\t\tdev_dbg(dev, \"VESA mode %dx%d too big\\n\",\n\t\t\t\t\tmode->xres, mode->yres);\n\t\t}\n\n\t\t \n\t\tfb_vmode.xres = 800;\n\t\tfb_vmode.yres = 600;\n\t\tfb_vmode.refresh = 60;\n\t\tdefault_vmode = fb_find_nearest_mode(&fb_vmode,\n\t\t\t\t\t\t     &info->modelist);\n\t}\n\n\t \n\tif ((default_vmode != NULL) && (dlfb->fb_count == 0)) {\n\n\t\tfb_videomode_to_var(&info->var, default_vmode);\n\t\tdlfb_var_color_format(&info->var);\n\n\t\t \n\t\tmemcpy(&info->fix, &dlfb_fix, sizeof(dlfb_fix));\n\t} else\n\t\tresult = -EINVAL;\n\nerror:\n\tif (edid && (dlfb->edid != edid))\n\t\tkfree(edid);\n\n\tif (info->dev)\n\t\tmutex_unlock(&info->lock);\n\n\treturn result;\n}\n\nstatic ssize_t metrics_bytes_rendered_show(struct device *fbdev,\n\t\t\t\t   struct device_attribute *a, char *buf) {\n\tstruct fb_info *fb_info = dev_get_drvdata(fbdev);\n\tstruct dlfb_data *dlfb = fb_info->par;\n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\tatomic_read(&dlfb->bytes_rendered));\n}\n\nstatic ssize_t metrics_bytes_identical_show(struct device *fbdev,\n\t\t\t\t   struct device_attribute *a, char *buf) {\n\tstruct fb_info *fb_info = dev_get_drvdata(fbdev);\n\tstruct dlfb_data *dlfb = fb_info->par;\n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\tatomic_read(&dlfb->bytes_identical));\n}\n\nstatic ssize_t metrics_bytes_sent_show(struct device *fbdev,\n\t\t\t\t   struct device_attribute *a, char *buf) {\n\tstruct fb_info *fb_info = dev_get_drvdata(fbdev);\n\tstruct dlfb_data *dlfb = fb_info->par;\n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\tatomic_read(&dlfb->bytes_sent));\n}\n\nstatic ssize_t metrics_cpu_kcycles_used_show(struct device *fbdev,\n\t\t\t\t   struct device_attribute *a, char *buf) {\n\tstruct fb_info *fb_info = dev_get_drvdata(fbdev);\n\tstruct dlfb_data *dlfb = fb_info->par;\n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\tatomic_read(&dlfb->cpu_kcycles_used));\n}\n\nstatic ssize_t edid_show(\n\t\t\tstruct file *filp,\n\t\t\tstruct kobject *kobj, struct bin_attribute *a,\n\t\t\t char *buf, loff_t off, size_t count) {\n\tstruct device *fbdev = kobj_to_dev(kobj);\n\tstruct fb_info *fb_info = dev_get_drvdata(fbdev);\n\tstruct dlfb_data *dlfb = fb_info->par;\n\n\tif (dlfb->edid == NULL)\n\t\treturn 0;\n\n\tif ((off >= dlfb->edid_size) || (count > dlfb->edid_size))\n\t\treturn 0;\n\n\tif (off + count > dlfb->edid_size)\n\t\tcount = dlfb->edid_size - off;\n\n\tmemcpy(buf, dlfb->edid, count);\n\n\treturn count;\n}\n\nstatic ssize_t edid_store(\n\t\t\tstruct file *filp,\n\t\t\tstruct kobject *kobj, struct bin_attribute *a,\n\t\t\tchar *src, loff_t src_off, size_t src_size) {\n\tstruct device *fbdev = kobj_to_dev(kobj);\n\tstruct fb_info *fb_info = dev_get_drvdata(fbdev);\n\tstruct dlfb_data *dlfb = fb_info->par;\n\tint ret;\n\n\t \n\tif ((src_size != EDID_LENGTH) || (src_off != 0))\n\t\treturn -EINVAL;\n\n\tret = dlfb_setup_modes(dlfb, fb_info, src, src_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!dlfb->edid || memcmp(src, dlfb->edid, src_size))\n\t\treturn -EINVAL;\n\n\tret = dlfb_ops_set_par(fb_info);\n\tif (ret)\n\t\treturn ret;\n\n\treturn src_size;\n}\n\nstatic ssize_t metrics_reset_store(struct device *fbdev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct fb_info *fb_info = dev_get_drvdata(fbdev);\n\tstruct dlfb_data *dlfb = fb_info->par;\n\n\tatomic_set(&dlfb->bytes_rendered, 0);\n\tatomic_set(&dlfb->bytes_identical, 0);\n\tatomic_set(&dlfb->bytes_sent, 0);\n\tatomic_set(&dlfb->cpu_kcycles_used, 0);\n\n\treturn count;\n}\n\nstatic const struct bin_attribute edid_attr = {\n\t.attr.name = \"edid\",\n\t.attr.mode = 0666,\n\t.size = EDID_LENGTH,\n\t.read = edid_show,\n\t.write = edid_store\n};\n\nstatic const struct device_attribute fb_device_attrs[] = {\n\t__ATTR_RO(metrics_bytes_rendered),\n\t__ATTR_RO(metrics_bytes_identical),\n\t__ATTR_RO(metrics_bytes_sent),\n\t__ATTR_RO(metrics_cpu_kcycles_used),\n\t__ATTR(metrics_reset, S_IWUSR, NULL, metrics_reset_store),\n};\n\n \nstatic int dlfb_select_std_channel(struct dlfb_data *dlfb)\n{\n\tint ret;\n\tstatic const u8 set_def_chn[] = {\n\t\t\t\t0x57, 0xCD, 0xDC, 0xA7,\n\t\t\t\t0x1C, 0x88, 0x5E, 0x15,\n\t\t\t\t0x60, 0xFE, 0xC6, 0x97,\n\t\t\t\t0x16, 0x3D, 0x47, 0xF2  };\n\n\tret = usb_control_msg_send(dlfb->udev, 0, NR_USB_REQUEST_CHANNEL,\n\t\t\t(USB_DIR_OUT | USB_TYPE_VENDOR), 0, 0,\n\t\t\t&set_def_chn, sizeof(set_def_chn), USB_CTRL_SET_TIMEOUT,\n\t\t\tGFP_KERNEL);\n\n\treturn ret;\n}\n\nstatic int dlfb_parse_vendor_descriptor(struct dlfb_data *dlfb,\n\t\t\t\t\tstruct usb_interface *intf)\n{\n\tchar *desc;\n\tchar *buf;\n\tchar *desc_end;\n\tint total_len;\n\n\tbuf = kzalloc(MAX_VENDOR_DESCRIPTOR_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn false;\n\tdesc = buf;\n\n\ttotal_len = usb_get_descriptor(interface_to_usbdev(intf),\n\t\t\t\t\t0x5f,  \n\t\t\t\t\t0, desc, MAX_VENDOR_DESCRIPTOR_SIZE);\n\n\t \n\tif (total_len < 0) {\n\t\tif (0 == usb_get_extra_descriptor(intf->cur_altsetting,\n\t\t\t0x5f, &desc))\n\t\t\ttotal_len = (int) desc[0];\n\t}\n\n\tif (total_len > 5) {\n\t\tdev_info(&intf->dev,\n\t\t\t \"vendor descriptor length: %d data: %11ph\\n\",\n\t\t\t total_len, desc);\n\n\t\tif ((desc[0] != total_len) ||  \n\t\t    (desc[1] != 0x5f) ||    \n\t\t    (desc[2] != 0x01) ||    \n\t\t    (desc[3] != 0x00) ||\n\t\t    (desc[4] != total_len - 2))  \n\t\t\tgoto unrecognized;\n\n\t\tdesc_end = desc + total_len;\n\t\tdesc += 5;  \n\n\t\twhile (desc < desc_end) {\n\t\t\tu8 length;\n\t\t\tu16 key;\n\n\t\t\tkey = *desc++;\n\t\t\tkey |= (u16)*desc++ << 8;\n\t\t\tlength = *desc++;\n\n\t\t\tswitch (key) {\n\t\t\tcase 0x0200: {  \n\t\t\t\tu32 max_area = *desc++;\n\t\t\t\tmax_area |= (u32)*desc++ << 8;\n\t\t\t\tmax_area |= (u32)*desc++ << 16;\n\t\t\t\tmax_area |= (u32)*desc++ << 24;\n\t\t\t\tdev_warn(&intf->dev,\n\t\t\t\t\t \"DL chip limited to %d pixel modes\\n\",\n\t\t\t\t\t max_area);\n\t\t\t\tdlfb->sku_pixel_limit = max_area;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdesc += length;\n\t\t}\n\t} else {\n\t\tdev_info(&intf->dev, \"vendor descriptor not available (%d)\\n\",\n\t\t\t total_len);\n\t}\n\n\tgoto success;\n\nunrecognized:\n\t \n\tdev_err(&intf->dev, \"Unrecognized vendor firmware descriptor\\n\");\n\nsuccess:\n\tkfree(buf);\n\treturn true;\n}\n\nstatic int dlfb_usb_probe(struct usb_interface *intf,\n\t\t\t  const struct usb_device_id *id)\n{\n\tint i;\n\tconst struct device_attribute *attr;\n\tstruct dlfb_data *dlfb;\n\tstruct fb_info *info;\n\tint retval;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstatic u8 out_ep[] = {OUT_EP_NUM + USB_DIR_OUT, 0};\n\n\t \n\tdlfb = kzalloc(sizeof(*dlfb), GFP_KERNEL);\n\tif (!dlfb) {\n\t\tdev_err(&intf->dev, \"%s: failed to allocate dlfb\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&dlfb->deferred_free);\n\n\tdlfb->udev = usb_get_dev(usbdev);\n\tusb_set_intfdata(intf, dlfb);\n\n\tif (!usb_check_bulk_endpoints(intf, out_ep)) {\n\t\tdev_err(&intf->dev, \"Invalid DisplayLink device!\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tdev_dbg(&intf->dev, \"console enable=%d\\n\", console);\n\tdev_dbg(&intf->dev, \"fb_defio enable=%d\\n\", fb_defio);\n\tdev_dbg(&intf->dev, \"shadow enable=%d\\n\", shadow);\n\n\tdlfb->sku_pixel_limit = 2048 * 1152;  \n\n\tif (!dlfb_parse_vendor_descriptor(dlfb, intf)) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"firmware not recognized, incompatible device?\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (pixel_limit) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"DL chip limit of %d overridden to %d\\n\",\n\t\t\t dlfb->sku_pixel_limit, pixel_limit);\n\t\tdlfb->sku_pixel_limit = pixel_limit;\n\t}\n\n\n\t \n\tinfo = framebuffer_alloc(0, &dlfb->udev->dev);\n\tif (!info) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tdlfb->info = info;\n\tinfo->par = dlfb;\n\tinfo->pseudo_palette = dlfb->pseudo_palette;\n\tdlfb->ops = dlfb_ops;\n\tinfo->fbops = &dlfb->ops;\n\n\tmutex_init(&dlfb->render_mutex);\n\tdlfb_init_damage(dlfb);\n\tspin_lock_init(&dlfb->damage_lock);\n\tINIT_WORK(&dlfb->damage_work, dlfb_damage_work);\n\n\tINIT_LIST_HEAD(&info->modelist);\n\n\tif (!dlfb_alloc_urb_list(dlfb, WRITES_IN_FLIGHT, MAX_TRANSFER)) {\n\t\tretval = -ENOMEM;\n\t\tdev_err(&intf->dev, \"unable to allocate urb list\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\n\tretval = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (retval < 0) {\n\t\tdev_err(info->device, \"cmap allocation failed: %d\\n\", retval);\n\t\tgoto error;\n\t}\n\n\tretval = dlfb_setup_modes(dlfb, info, NULL, 0);\n\tif (retval != 0) {\n\t\tdev_err(info->device,\n\t\t\t\"unable to find common mode for display and adapter\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\n\tatomic_set(&dlfb->usb_active, 1);\n\tdlfb_select_std_channel(dlfb);\n\n\tdlfb_ops_check_var(&info->var, info);\n\tretval = dlfb_ops_set_par(info);\n\tif (retval)\n\t\tgoto error;\n\n\tretval = register_framebuffer(info);\n\tif (retval < 0) {\n\t\tdev_err(info->device, \"unable to register framebuffer: %d\\n\",\n\t\t\tretval);\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(fb_device_attrs); i++) {\n\t\tattr = &fb_device_attrs[i];\n\t\tretval = device_create_file(info->dev, attr);\n\t\tif (retval)\n\t\t\tdev_warn(info->device,\n\t\t\t\t \"failed to create '%s' attribute: %d\\n\",\n\t\t\t\t attr->attr.name, retval);\n\t}\n\n\tretval = device_create_bin_file(info->dev, &edid_attr);\n\tif (retval)\n\t\tdev_warn(info->device, \"failed to create '%s' attribute: %d\\n\",\n\t\t\t edid_attr.attr.name, retval);\n\n\tdev_info(info->device,\n\t\t \"%s is DisplayLink USB device (%dx%d, %dK framebuffer memory)\\n\",\n\t\t dev_name(info->dev), info->var.xres, info->var.yres,\n\t\t ((dlfb->backing_buffer) ?\n\t\t info->fix.smem_len * 2 : info->fix.smem_len) >> 10);\n\treturn 0;\n\nerror:\n\tif (dlfb->info) {\n\t\tdlfb_ops_destroy(dlfb->info);\n\t} else {\n\t\tusb_put_dev(dlfb->udev);\n\t\tkfree(dlfb);\n\t}\n\treturn retval;\n}\n\nstatic void dlfb_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct dlfb_data *dlfb;\n\tstruct fb_info *info;\n\tint i;\n\n\tdlfb = usb_get_intfdata(intf);\n\tinfo = dlfb->info;\n\n\tdev_dbg(&intf->dev, \"USB disconnect starting\\n\");\n\n\t \n\tdlfb->virtualized = true;\n\n\t \n\tatomic_set(&dlfb->usb_active, 0);\n\n\t \n\tdlfb_free_urb_list(dlfb);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fb_device_attrs); i++)\n\t\tdevice_remove_file(info->dev, &fb_device_attrs[i]);\n\tdevice_remove_bin_file(info->dev, &edid_attr);\n\n\tunregister_framebuffer(info);\n}\n\nstatic struct usb_driver dlfb_driver = {\n\t.name = \"udlfb\",\n\t.probe = dlfb_usb_probe,\n\t.disconnect = dlfb_usb_disconnect,\n\t.id_table = id_table,\n};\n\nmodule_usb_driver(dlfb_driver);\n\nstatic void dlfb_urb_completion(struct urb *urb)\n{\n\tstruct urb_node *unode = urb->context;\n\tstruct dlfb_data *dlfb = unode->dlfb;\n\tunsigned long flags;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dlfb->udev->dev,\n\t\t\t\"%s - nonzero write bulk status received: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\tatomic_set(&dlfb->lost_pixels, 1);\n\t\tbreak;\n\t}\n\n\turb->transfer_buffer_length = dlfb->urbs.size;  \n\n\tspin_lock_irqsave(&dlfb->urbs.lock, flags);\n\tlist_add_tail(&unode->entry, &dlfb->urbs.list);\n\tdlfb->urbs.available++;\n\tspin_unlock_irqrestore(&dlfb->urbs.lock, flags);\n\n\tup(&dlfb->urbs.limit_sem);\n}\n\nstatic void dlfb_free_urb_list(struct dlfb_data *dlfb)\n{\n\tint count = dlfb->urbs.count;\n\tstruct list_head *node;\n\tstruct urb_node *unode;\n\tstruct urb *urb;\n\n\t \n\twhile (count--) {\n\t\tdown(&dlfb->urbs.limit_sem);\n\n\t\tspin_lock_irq(&dlfb->urbs.lock);\n\n\t\tnode = dlfb->urbs.list.next;  \n\t\tlist_del_init(node);\n\n\t\tspin_unlock_irq(&dlfb->urbs.lock);\n\n\t\tunode = list_entry(node, struct urb_node, entry);\n\t\turb = unode->urb;\n\n\t\t \n\t\tusb_free_coherent(urb->dev, dlfb->urbs.size,\n\t\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t\tkfree(node);\n\t}\n\n\tdlfb->urbs.count = 0;\n}\n\nstatic int dlfb_alloc_urb_list(struct dlfb_data *dlfb, int count, size_t size)\n{\n\tstruct urb *urb;\n\tstruct urb_node *unode;\n\tchar *buf;\n\tsize_t wanted_size = count * size;\n\n\tspin_lock_init(&dlfb->urbs.lock);\n\nretry:\n\tdlfb->urbs.size = size;\n\tINIT_LIST_HEAD(&dlfb->urbs.list);\n\n\tsema_init(&dlfb->urbs.limit_sem, 0);\n\tdlfb->urbs.count = 0;\n\tdlfb->urbs.available = 0;\n\n\twhile (dlfb->urbs.count * size < wanted_size) {\n\t\tunode = kzalloc(sizeof(*unode), GFP_KERNEL);\n\t\tif (!unode)\n\t\t\tbreak;\n\t\tunode->dlfb = dlfb;\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tkfree(unode);\n\t\t\tbreak;\n\t\t}\n\t\tunode->urb = urb;\n\n\t\tbuf = usb_alloc_coherent(dlfb->udev, size, GFP_KERNEL,\n\t\t\t\t\t &urb->transfer_dma);\n\t\tif (!buf) {\n\t\t\tkfree(unode);\n\t\t\tusb_free_urb(urb);\n\t\t\tif (size > PAGE_SIZE) {\n\t\t\t\tsize /= 2;\n\t\t\t\tdlfb_free_urb_list(dlfb);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tusb_fill_bulk_urb(urb, dlfb->udev,\n\t\t\tusb_sndbulkpipe(dlfb->udev, OUT_EP_NUM),\n\t\t\tbuf, size, dlfb_urb_completion, unode);\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\tlist_add_tail(&unode->entry, &dlfb->urbs.list);\n\n\t\tup(&dlfb->urbs.limit_sem);\n\t\tdlfb->urbs.count++;\n\t\tdlfb->urbs.available++;\n\t}\n\n\treturn dlfb->urbs.count;\n}\n\nstatic struct urb *dlfb_get_urb(struct dlfb_data *dlfb)\n{\n\tint ret;\n\tstruct list_head *entry;\n\tstruct urb_node *unode;\n\n\t \n\tret = down_timeout(&dlfb->urbs.limit_sem, GET_URB_TIMEOUT);\n\tif (ret) {\n\t\tatomic_set(&dlfb->lost_pixels, 1);\n\t\tdev_warn(&dlfb->udev->dev,\n\t\t\t \"wait for urb interrupted: %d available: %d\\n\",\n\t\t\t ret, dlfb->urbs.available);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_irq(&dlfb->urbs.lock);\n\n\tBUG_ON(list_empty(&dlfb->urbs.list));  \n\tentry = dlfb->urbs.list.next;\n\tlist_del_init(entry);\n\tdlfb->urbs.available--;\n\n\tspin_unlock_irq(&dlfb->urbs.lock);\n\n\tunode = list_entry(entry, struct urb_node, entry);\n\treturn unode->urb;\n}\n\nstatic int dlfb_submit_urb(struct dlfb_data *dlfb, struct urb *urb, size_t len)\n{\n\tint ret;\n\n\tBUG_ON(len > dlfb->urbs.size);\n\n\turb->transfer_buffer_length = len;  \n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tdlfb_urb_completion(urb);  \n\t\tatomic_set(&dlfb->lost_pixels, 1);\n\t\tdev_err(&dlfb->udev->dev, \"submit urb error: %d\\n\", ret);\n\t}\n\treturn ret;\n}\n\nmodule_param(console, bool, S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP);\nMODULE_PARM_DESC(console, \"Allow fbcon to open framebuffer\");\n\nmodule_param(fb_defio, bool, S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP);\nMODULE_PARM_DESC(fb_defio, \"Page fault detection of mmap writes\");\n\nmodule_param(shadow, bool, S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP);\nMODULE_PARM_DESC(shadow, \"Shadow vid mem. Disable to save mem but lose perf\");\n\nmodule_param(pixel_limit, int, S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP);\nMODULE_PARM_DESC(pixel_limit, \"Force limit on max mode (in x*y pixels)\");\n\nMODULE_AUTHOR(\"Roberto De Ioris <roberto@unbit.it>, \"\n\t      \"Jaya Kumar <jayakumar.lkml@gmail.com>, \"\n\t      \"Bernie Thompson <bernie@plugable.com>\");\nMODULE_DESCRIPTION(\"DisplayLink kernel framebuffer driver\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}