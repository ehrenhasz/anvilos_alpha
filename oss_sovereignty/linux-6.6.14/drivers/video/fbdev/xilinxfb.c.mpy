{
  "module_name": "xilinxfb.c",
  "hash_id": "a5d67113e0f83c4a69e7c1faee5534d9e0f01648be3121b35be8628a85dd25c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/xilinxfb.c",
  "human_readable_source": " \n\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#ifdef CONFIG_PPC_DCR\n#include <asm/dcr.h>\n#endif\n\n#define DRIVER_NAME\t\t\"xilinxfb\"\n\n \n#define NUM_REGS\t2\n#define REG_FB_ADDR\t0\n#define REG_CTRL\t1\n#define REG_CTRL_ENABLE\t 0x0001\n#define REG_CTRL_ROTATE\t 0x0002\n\n \n#define BYTES_PER_PIXEL\t4\n#define BITS_PER_PIXEL\t(BYTES_PER_PIXEL * 8)\n\n#define RED_SHIFT\t16\n#define GREEN_SHIFT\t8\n#define BLUE_SHIFT\t0\n\n#define PALETTE_ENTRIES_NO\t16\t \n\n \nstruct xilinxfb_platform_data {\n\tu32 rotate_screen;       \n\tu32 screen_height_mm;    \n\tu32 screen_width_mm;\n\tu32 xres, yres;          \n\tu32 xvirt, yvirt;        \n\n\t \n\tu32 fb_phys;\n};\n\n \nstatic const struct xilinxfb_platform_data xilinx_fb_default_pdata = {\n\t.xres = 640,\n\t.yres = 480,\n\t.xvirt = 1024,\n\t.yvirt = 480,\n};\n\n \nstatic const struct fb_fix_screeninfo xilinx_fb_fix = {\n\t.id =\t\t\"Xilinx\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_TRUECOLOR,\n\t.accel =\tFB_ACCEL_NONE\n};\n\nstatic const struct fb_var_screeninfo xilinx_fb_var = {\n\t.bits_per_pixel =\tBITS_PER_PIXEL,\n\n\t.red =\t\t{ RED_SHIFT, 8, 0 },\n\t.green =\t{ GREEN_SHIFT, 8, 0 },\n\t.blue =\t\t{ BLUE_SHIFT, 8, 0 },\n\t.transp =\t{ 0, 0, 0 },\n\n\t.activate =\tFB_ACTIVATE_NOW\n};\n\n#define BUS_ACCESS_FLAG\t\t0x1  \n#define LITTLE_ENDIAN_ACCESS\t0x2  \n\nstruct xilinxfb_drvdata {\n\tstruct fb_info\tinfo;\t\t \n\n\tphys_addr_t\tregs_phys;\t \n\tvoid __iomem\t*regs;\t\t \n#ifdef CONFIG_PPC_DCR\n\tdcr_host_t      dcr_host;\n\tunsigned int    dcr_len;\n#endif\n\tvoid\t\t*fb_virt;\t \n\tdma_addr_t\tfb_phys;\t \n\tint\t\tfb_alloced;\t \n\n\tu8\t\tflags;\t\t \n\n\tu32\t\treg_ctrl_default;\n\n\tu32\t\tpseudo_palette[PALETTE_ENTRIES_NO];\n\t\t\t\t\t \n};\n\n#define to_xilinxfb_drvdata(_info) \\\n\tcontainer_of(_info, struct xilinxfb_drvdata, info)\n\n \nstatic void xilinx_fb_out32(struct xilinxfb_drvdata *drvdata, u32 offset,\n\t\t\t    u32 val)\n{\n\tif (drvdata->flags & BUS_ACCESS_FLAG) {\n\t\tif (drvdata->flags & LITTLE_ENDIAN_ACCESS)\n\t\t\tiowrite32(val, drvdata->regs + (offset << 2));\n\t\telse\n\t\t\tiowrite32be(val, drvdata->regs + (offset << 2));\n\t}\n#ifdef CONFIG_PPC_DCR\n\telse\n\t\tdcr_write(drvdata->dcr_host, offset, val);\n#endif\n}\n\nstatic u32 xilinx_fb_in32(struct xilinxfb_drvdata *drvdata, u32 offset)\n{\n\tif (drvdata->flags & BUS_ACCESS_FLAG) {\n\t\tif (drvdata->flags & LITTLE_ENDIAN_ACCESS)\n\t\t\treturn ioread32(drvdata->regs + (offset << 2));\n\t\telse\n\t\t\treturn ioread32be(drvdata->regs + (offset << 2));\n\t}\n#ifdef CONFIG_PPC_DCR\n\telse\n\t\treturn dcr_read(drvdata->dcr_host, offset);\n#endif\n\treturn 0;\n}\n\nstatic int\nxilinx_fb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,\n\t\t    unsigned int blue, unsigned int transp, struct fb_info *fbi)\n{\n\tu32 *palette = fbi->pseudo_palette;\n\n\tif (regno >= PALETTE_ENTRIES_NO)\n\t\treturn -EINVAL;\n\n\tif (fbi->var.grayscale) {\n\t\t \n\t\tblue = (red * 77 + green * 151 + blue * 28 + 127) >> 8;\n\t\tgreen = blue;\n\t\tred = green;\n\t}\n\n\t \n\n\t \n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\tpalette[regno] = (red << RED_SHIFT) | (green << GREEN_SHIFT) |\n\t\t\t (blue << BLUE_SHIFT);\n\n\treturn 0;\n}\n\nstatic int\nxilinx_fb_blank(int blank_mode, struct fb_info *fbi)\n{\n\tstruct xilinxfb_drvdata *drvdata = to_xilinxfb_drvdata(fbi);\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\t \n\t\txilinx_fb_out32(drvdata, REG_CTRL, drvdata->reg_ctrl_default);\n\t\tbreak;\n\n\tcase FB_BLANK_NORMAL:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_POWERDOWN:\n\t\t \n\t\txilinx_fb_out32(drvdata, REG_CTRL, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;  \n}\n\nstatic const struct fb_ops xilinxfb_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_setcolreg\t\t= xilinx_fb_setcolreg,\n\t.fb_blank\t\t= xilinx_fb_blank,\n};\n\n \n\nstatic int xilinxfb_assign(struct platform_device *pdev,\n\t\t\t   struct xilinxfb_drvdata *drvdata,\n\t\t\t   struct xilinxfb_platform_data *pdata)\n{\n\tint rc;\n\tstruct device *dev = &pdev->dev;\n\tint fbsize = pdata->xvirt * pdata->yvirt * BYTES_PER_PIXEL;\n\n\tif (drvdata->flags & BUS_ACCESS_FLAG) {\n\t\tstruct resource *res;\n\n\t\tdrvdata->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\t\tif (IS_ERR(drvdata->regs))\n\t\t\treturn PTR_ERR(drvdata->regs);\n\n\t\tdrvdata->regs_phys = res->start;\n\t}\n\n\t \n\tif (pdata->fb_phys) {\n\t\tdrvdata->fb_phys = pdata->fb_phys;\n\t\tdrvdata->fb_virt = ioremap(pdata->fb_phys, fbsize);\n\t} else {\n\t\tdrvdata->fb_alloced = 1;\n\t\tdrvdata->fb_virt = dma_alloc_coherent(dev, PAGE_ALIGN(fbsize),\n\t\t\t\t\t\t      &drvdata->fb_phys,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t}\n\n\tif (!drvdata->fb_virt) {\n\t\tdev_err(dev, \"Could not allocate frame buffer memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmemset_io((void __iomem *)drvdata->fb_virt, 0, fbsize);\n\n\t \n\txilinx_fb_out32(drvdata, REG_FB_ADDR, drvdata->fb_phys);\n\trc = xilinx_fb_in32(drvdata, REG_FB_ADDR);\n\t \n\tif (rc != drvdata->fb_phys) {\n\t\tdrvdata->flags |= LITTLE_ENDIAN_ACCESS;\n\t\txilinx_fb_out32(drvdata, REG_FB_ADDR, drvdata->fb_phys);\n\t}\n\n\t \n\tdrvdata->reg_ctrl_default = REG_CTRL_ENABLE;\n\tif (pdata->rotate_screen)\n\t\tdrvdata->reg_ctrl_default |= REG_CTRL_ROTATE;\n\txilinx_fb_out32(drvdata, REG_CTRL, drvdata->reg_ctrl_default);\n\n\t \n\tdrvdata->info.device = dev;\n\tdrvdata->info.screen_base = (void __iomem *)drvdata->fb_virt;\n\tdrvdata->info.fbops = &xilinxfb_ops;\n\tdrvdata->info.fix = xilinx_fb_fix;\n\tdrvdata->info.fix.smem_start = drvdata->fb_phys;\n\tdrvdata->info.fix.smem_len = fbsize;\n\tdrvdata->info.fix.line_length = pdata->xvirt * BYTES_PER_PIXEL;\n\n\tdrvdata->info.pseudo_palette = drvdata->pseudo_palette;\n\tdrvdata->info.var = xilinx_fb_var;\n\tdrvdata->info.var.height = pdata->screen_height_mm;\n\tdrvdata->info.var.width = pdata->screen_width_mm;\n\tdrvdata->info.var.xres = pdata->xres;\n\tdrvdata->info.var.yres = pdata->yres;\n\tdrvdata->info.var.xres_virtual = pdata->xvirt;\n\tdrvdata->info.var.yres_virtual = pdata->yvirt;\n\n\t \n\trc = fb_alloc_cmap(&drvdata->info.cmap, PALETTE_ENTRIES_NO, 0);\n\tif (rc) {\n\t\tdev_err(dev, \"Fail to allocate colormap (%d entries)\\n\",\n\t\t\tPALETTE_ENTRIES_NO);\n\t\tgoto err_cmap;\n\t}\n\n\t \n\trc = register_framebuffer(&drvdata->info);\n\tif (rc) {\n\t\tdev_err(dev, \"Could not register frame buffer\\n\");\n\t\tgoto err_regfb;\n\t}\n\n\tif (drvdata->flags & BUS_ACCESS_FLAG) {\n\t\t \n\t\tdev_dbg(dev, \"regs: phys=%pa, virt=%p\\n\",\n\t\t\t&drvdata->regs_phys, drvdata->regs);\n\t}\n\t \n\tdev_dbg(dev, \"fb: phys=%llx, virt=%p, size=%x\\n\",\n\t\t(unsigned long long)drvdata->fb_phys, drvdata->fb_virt, fbsize);\n\n\treturn 0;\t \n\nerr_regfb:\n\tfb_dealloc_cmap(&drvdata->info.cmap);\n\nerr_cmap:\n\tif (drvdata->fb_alloced)\n\t\tdma_free_coherent(dev, PAGE_ALIGN(fbsize), drvdata->fb_virt,\n\t\t\t\t  drvdata->fb_phys);\n\telse\n\t\tiounmap(drvdata->fb_virt);\n\n\t \n\txilinx_fb_out32(drvdata, REG_CTRL, 0);\n\n\treturn rc;\n}\n\nstatic void xilinxfb_release(struct device *dev)\n{\n\tstruct xilinxfb_drvdata *drvdata = dev_get_drvdata(dev);\n\n#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)\n\txilinx_fb_blank(VESA_POWERDOWN, &drvdata->info);\n#endif\n\n\tunregister_framebuffer(&drvdata->info);\n\n\tfb_dealloc_cmap(&drvdata->info.cmap);\n\n\tif (drvdata->fb_alloced)\n\t\tdma_free_coherent(dev, PAGE_ALIGN(drvdata->info.fix.smem_len),\n\t\t\t\t  drvdata->fb_virt, drvdata->fb_phys);\n\telse\n\t\tiounmap(drvdata->fb_virt);\n\n\t \n\txilinx_fb_out32(drvdata, REG_CTRL, 0);\n\n#ifdef CONFIG_PPC_DCR\n\t \n\tif (!(drvdata->flags & BUS_ACCESS_FLAG))\n\t\tdcr_unmap(drvdata->dcr_host, drvdata->dcr_len);\n#endif\n}\n\n \n\nstatic int xilinxfb_of_probe(struct platform_device *pdev)\n{\n\tconst u32 *prop;\n\tu32 tft_access = 0;\n\tstruct xilinxfb_platform_data pdata;\n\tint size;\n\tstruct xilinxfb_drvdata *drvdata;\n\n\t \n\tpdata = xilinx_fb_default_pdata;\n\n\t \n\tdrvdata = devm_kzalloc(&pdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\t \n\tof_property_read_u32(pdev->dev.of_node, \"xlnx,dcr-splb-slave-if\",\n\t\t\t     &tft_access);\n\n\t \n\tif (tft_access)\n\t\tdrvdata->flags |= BUS_ACCESS_FLAG;\n#ifdef CONFIG_PPC_DCR\n\telse {\n\t\tint start;\n\n\t\tstart = dcr_resource_start(pdev->dev.of_node, 0);\n\t\tdrvdata->dcr_len = dcr_resource_len(pdev->dev.of_node, 0);\n\t\tdrvdata->dcr_host = dcr_map(pdev->dev.of_node, start, drvdata->dcr_len);\n\t\tif (!DCR_MAP_OK(drvdata->dcr_host)) {\n\t\t\tdev_err(&pdev->dev, \"invalid DCR address\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n#endif\n\n\tprop = of_get_property(pdev->dev.of_node, \"phys-size\", &size);\n\tif ((prop) && (size >= sizeof(u32) * 2)) {\n\t\tpdata.screen_width_mm = prop[0];\n\t\tpdata.screen_height_mm = prop[1];\n\t}\n\n\tprop = of_get_property(pdev->dev.of_node, \"resolution\", &size);\n\tif ((prop) && (size >= sizeof(u32) * 2)) {\n\t\tpdata.xres = prop[0];\n\t\tpdata.yres = prop[1];\n\t}\n\n\tprop = of_get_property(pdev->dev.of_node, \"virtual-resolution\", &size);\n\tif ((prop) && (size >= sizeof(u32) * 2)) {\n\t\tpdata.xvirt = prop[0];\n\t\tpdata.yvirt = prop[1];\n\t}\n\n\tpdata.rotate_screen = of_property_read_bool(pdev->dev.of_node, \"rotate-display\");\n\n\tplatform_set_drvdata(pdev, drvdata);\n\treturn xilinxfb_assign(pdev, drvdata, &pdata);\n}\n\nstatic void xilinxfb_of_remove(struct platform_device *op)\n{\n\txilinxfb_release(&op->dev);\n}\n\n \nstatic const struct of_device_id xilinxfb_of_match[] = {\n\t{ .compatible = \"xlnx,xps-tft-1.00.a\", },\n\t{ .compatible = \"xlnx,xps-tft-2.00.a\", },\n\t{ .compatible = \"xlnx,xps-tft-2.01.a\", },\n\t{ .compatible = \"xlnx,plb-tft-cntlr-ref-1.00.a\", },\n\t{ .compatible = \"xlnx,plb-dvi-cntlr-ref-1.00.c\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xilinxfb_of_match);\n\nstatic struct platform_driver xilinxfb_of_driver = {\n\t.probe = xilinxfb_of_probe,\n\t.remove_new = xilinxfb_of_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = xilinxfb_of_match,\n\t},\n};\n\nmodule_platform_driver(xilinxfb_of_driver);\n\nMODULE_AUTHOR(\"MontaVista Software, Inc. <source@mvista.com>\");\nMODULE_DESCRIPTION(\"Xilinx TFT frame buffer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}