{
  "module_name": "hpfb.c",
  "hash_id": "d936f3ebbe3777a6c753250c6df18d4290fcdf7fe0d95bf8e976decd09479ff3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/hpfb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/fb.h>\n#include <linux/dio.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\nstatic struct fb_info fb_info = {\n\t.fix = {\n\t\t.id\t\t= \"HP300 \",\n\t\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t\t.visual\t\t= FB_VISUAL_PSEUDOCOLOR,\n\t\t.accel\t\t= FB_ACCEL_NONE,\n\t}\n};\n\nstatic unsigned long fb_regs;\nstatic unsigned char fb_bitmask;\n\n#define TC_NBLANK\t0x4080\n#define TC_WEN\t\t0x4088\n#define TC_REN\t\t0x408c\n#define TC_FBEN\t\t0x4090\n#define TC_PRR\t\t0x40ea\n\n \n#define RR_CLEAR\t0x0\n#define RR_COPY\t\t0x3\n#define RR_NOOP\t\t0x5\n#define RR_XOR\t\t0x6\n#define RR_INVERT\t0xa\n#define RR_COPYINVERTED 0xc\n#define RR_SET\t\t0xf\n\n \n#define BUSY\t\t0x4044\n#define WMRR\t\t0x40ef\n#define SOURCE_X\t0x40f2\n#define SOURCE_Y\t0x40f6\n#define DEST_X\t\t0x40fa\n#define DEST_Y\t\t0x40fe\n#define WHEIGHT\t\t0x4106\n#define WWIDTH\t\t0x4102\n#define WMOVE\t\t0x409c\n\nstatic struct fb_var_screeninfo hpfb_defined = {\n\t.red\t\t= {\n\t\t.length = 8,\n\t},\n\t.green\t\t= {\n\t\t.length = 8,\n\t},\n\t.blue\t\t= {\n\t\t.length = 8,\n\t},\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\nstatic int hpfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t  unsigned blue, unsigned transp,\n\t\t\t  struct fb_info *info)\n{\n\t \n\tunsigned char _red  =red>>8;\n\tunsigned char _green=green>>8;\n\tunsigned char _blue =blue>>8;\n\tunsigned char _regno=regno;\n\n\t \n\n\tif (regno >= info->cmap.len)\n\t\treturn 1;\n\n\twhile (in_be16(fb_regs + 0x6002) & 0x4) udelay(1);\n\n\tout_be16(fb_regs + 0x60ba, 0xff);\n\n\tout_be16(fb_regs + 0x60b2, _red);\n\tout_be16(fb_regs + 0x60b4, _green);\n\tout_be16(fb_regs + 0x60b6, _blue);\n\tout_be16(fb_regs + 0x60b8, ~_regno);\n\tout_be16(fb_regs + 0x60f0, 0xff);\n\n\tudelay(100);\n\n\twhile (in_be16(fb_regs + 0x6002) & 0x4) udelay(1);\n\tout_be16(fb_regs + 0x60b2, 0);\n\tout_be16(fb_regs + 0x60b4, 0);\n\tout_be16(fb_regs + 0x60b6, 0);\n\tout_be16(fb_regs + 0x60b8, 0);\n\n\treturn 0;\n}\n\n \n\nstatic int hpfb_blank(int blank, struct fb_info *info)\n{\n\tout_8(fb_regs + TC_NBLANK, (blank ? 0x00 : fb_bitmask));\n\n\treturn 0;\n}\n\nstatic void topcat_blit(int x0, int y0, int x1, int y1, int w, int h, int rr)\n{\n\tif (rr >= 0) {\n\t\twhile (in_8(fb_regs + BUSY) & fb_bitmask)\n\t\t\t;\n\t}\n\tout_8(fb_regs + TC_FBEN, fb_bitmask);\n\tif (rr >= 0) {\n\t\tout_8(fb_regs + TC_WEN, fb_bitmask);\n\t\tout_8(fb_regs + WMRR, rr);\n\t}\n\tout_be16(fb_regs + SOURCE_X, x0);\n\tout_be16(fb_regs + SOURCE_Y, y0);\n\tout_be16(fb_regs + DEST_X, x1);\n\tout_be16(fb_regs + DEST_Y, y1);\n\tout_be16(fb_regs + WWIDTH, w);\n\tout_be16(fb_regs + WHEIGHT, h);\n\tout_8(fb_regs + WMOVE, fb_bitmask);\n}\n\nstatic void hpfb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\ttopcat_blit(area->sx, area->sy, area->dx, area->dy, area->width, area->height, RR_COPY);\n}\n\nstatic void hpfb_fillrect(struct fb_info *p, const struct fb_fillrect *region)\n{\n\tu8 clr;\n\n\tclr = region->color & 0xff;\n\n\twhile (in_8(fb_regs + BUSY) & fb_bitmask)\n\t\t;\n\n\t \n\tout_8(fb_regs + TC_WEN, fb_bitmask & clr);\n\tout_8(fb_regs + WMRR, (region->rop == ROP_COPY ? RR_SET : RR_INVERT));\n\n\t \n\tout_8(fb_regs + TC_WEN, fb_bitmask & ~clr);\n\tout_8(fb_regs + WMRR, (region->rop == ROP_COPY ? RR_CLEAR : RR_NOOP));\n\n\ttopcat_blit(region->dx, region->dy, region->dx, region->dy, region->width, region->height, -1);\n}\n\nstatic int hpfb_sync(struct fb_info *info)\n{\n\t \n\twhile (in_8(fb_regs + BUSY) & fb_bitmask)\n\t\t;\n\n\tout_8(fb_regs + TC_WEN, fb_bitmask);\n\tout_8(fb_regs + TC_PRR, RR_COPY);\n\tout_8(fb_regs + TC_FBEN, fb_bitmask);\n\n\treturn 0;\n}\n\nstatic const struct fb_ops hpfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_setcolreg\t= hpfb_setcolreg,\n\t.fb_blank\t= hpfb_blank,\n\t.fb_fillrect\t= hpfb_fillrect,\n\t.fb_copyarea\t= hpfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n\t.fb_sync\t= hpfb_sync,\n};\n\n \n#define HPFB_FBWMSB\t0x05\t \n#define HPFB_FBWLSB\t0x07\n#define HPFB_FBHMSB\t0x09\t \n#define HPFB_FBHLSB\t0x0b\n#define HPFB_DWMSB\t0x0d\t \n#define HPFB_DWLSB\t0x0f\n#define HPFB_DHMSB\t0x11\t \n#define HPFB_DHLSB\t0x13\n#define HPFB_NUMPLANES\t0x5b\t \n#define HPFB_FBOMSB\t0x5d\t \n#define HPFB_FBOLSB\t0x5f\n\nstatic int hpfb_init_one(unsigned long phys_base, unsigned long virt_base)\n{\n\tunsigned long fboff, fb_width, fb_height, fb_start;\n\tint ret;\n\n\tfb_regs = virt_base;\n\tfboff = (in_8(fb_regs + HPFB_FBOMSB) << 8) | in_8(fb_regs + HPFB_FBOLSB);\n\n\tfb_info.fix.smem_start = (in_8(fb_regs + fboff) << 16);\n\n\tif (phys_base >= DIOII_BASE) {\n\t\tfb_info.fix.smem_start += phys_base;\n\t}\n\n\tif (DIO_SECID(fb_regs) != DIO_ID2_TOPCAT) {\n\t\t \n\t\twhile (in_be16(fb_regs+0x4800) & 1)\n\t\t\t;\n\t\tout_be16(fb_regs+0x4800, 0);\t \n\t\tout_be16(fb_regs+0x4510, 0);\t \n\t\tout_be16(fb_regs+0x4512, 0);\t \n\t\tout_be16(fb_regs+0x4514, 0);\t \n\t\tout_be16(fb_regs+0x4516, 0);\t \n\t\tout_be16(fb_regs+0x4206, 0x90);\t \n\t\tout_be16(fb_regs+0x60a2, 0);\t \n\t\tout_be16(fb_regs+0x60bc, 0);\t \n\t}\n\n\t \n\tfb_width = (in_8(fb_regs + HPFB_FBWMSB) << 8) | in_8(fb_regs + HPFB_FBWLSB);\n\tfb_info.fix.line_length = fb_width;\n\tfb_height = (in_8(fb_regs + HPFB_FBHMSB) << 8) | in_8(fb_regs + HPFB_FBHLSB);\n\tfb_info.fix.smem_len = fb_width * fb_height;\n\tfb_start = (unsigned long)ioremap_wt(fb_info.fix.smem_start,\n\t\t\t\t\t     fb_info.fix.smem_len);\n\thpfb_defined.xres = (in_8(fb_regs + HPFB_DWMSB) << 8) | in_8(fb_regs + HPFB_DWLSB);\n\thpfb_defined.yres = (in_8(fb_regs + HPFB_DHMSB) << 8) | in_8(fb_regs + HPFB_DHLSB);\n\thpfb_defined.xres_virtual = hpfb_defined.xres;\n\thpfb_defined.yres_virtual = hpfb_defined.yres;\n\thpfb_defined.bits_per_pixel = in_8(fb_regs + HPFB_NUMPLANES);\n\n\tprintk(KERN_INFO \"hpfb: framebuffer at 0x%lx, mapped to 0x%lx, size %dk\\n\",\n\t       fb_info.fix.smem_start, fb_start, fb_info.fix.smem_len/1024);\n\tprintk(KERN_INFO \"hpfb: mode is %dx%dx%d, linelength=%d\\n\",\n\t       hpfb_defined.xres, hpfb_defined.yres, hpfb_defined.bits_per_pixel, fb_info.fix.line_length);\n\n\t \n\tout_8(fb_regs + TC_WEN, 0xff);\n\tout_8(fb_regs + TC_PRR, RR_COPY);\n\tout_8(fb_regs + TC_FBEN, 0xff);\n\tout_8(fb_start, 0xff);\n\tfb_bitmask = in_8(fb_start);\n\tout_8(fb_start, 0);\n\n\t \n\tout_8(fb_regs + TC_WEN, fb_bitmask);\n\tout_8(fb_regs + TC_PRR, RR_COPY);\n\tout_8(fb_regs + TC_REN, fb_bitmask);\n\tout_8(fb_regs + TC_FBEN, fb_bitmask);\n\n\t \n\ttopcat_blit(0, 0, 0, 0, fb_width, fb_height, RR_CLEAR);\n\n\t \n\tif (DIO_SECID(fb_regs) == DIO_ID2_TOPCAT)\n\t\tstrcat(fb_info.fix.id, \"Topcat\");\n\telse\n\t\tstrcat(fb_info.fix.id, \"Catseye\");\n\tfb_info.fbops = &hpfb_ops;\n\tfb_info.var   = hpfb_defined;\n\tfb_info.screen_base = (char *)fb_start;\n\n\tret = fb_alloc_cmap(&fb_info.cmap, 1 << hpfb_defined.bits_per_pixel, 0);\n\tif (ret < 0)\n\t\tgoto unmap_screen_base;\n\n\tret = register_framebuffer(&fb_info);\n\tif (ret < 0)\n\t\tgoto dealloc_cmap;\n\n\tfb_info(&fb_info, \"%s frame buffer device\\n\", fb_info.fix.id);\n\n\treturn 0;\n\ndealloc_cmap:\n\tfb_dealloc_cmap(&fb_info.cmap);\n\nunmap_screen_base:\n\tif (fb_info.screen_base) {\n\t\tiounmap(fb_info.screen_base);\n\t\tfb_info.screen_base = NULL;\n\t}\n\n\treturn ret;\n}\n\n \n\n#define topcat_sid_ok(x)  (((x) == DIO_ID2_LRCATSEYE) || ((x) == DIO_ID2_HRCCATSEYE)    \\\n\t\t\t   || ((x) == DIO_ID2_HRMCATSEYE) || ((x) == DIO_ID2_TOPCAT))\n\n \nstatic int hpfb_dio_probe(struct dio_dev *d, const struct dio_device_id *ent)\n{\n\tunsigned long paddr, vaddr;\n\n\tpaddr = d->resource.start;\n\tif (!request_mem_region(d->resource.start, resource_size(&d->resource), d->name))\n                return -EBUSY;\n\n\tif (d->scode >= DIOII_SCBASE) {\n\t\tvaddr = (unsigned long)ioremap(paddr, resource_size(&d->resource));\n\t} else {\n\t\tvaddr = paddr + DIO_VIRADDRBASE;\n\t}\n\tprintk(KERN_INFO \"Topcat found at DIO select code %d \"\n\t       \"(secondary id %02x)\\n\", d->scode, (d->id >> 8) & 0xff);\n\tif (hpfb_init_one(paddr, vaddr)) {\n\t\tif (d->scode >= DIOII_SCBASE)\n\t\t\tiounmap((void *)vaddr);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void hpfb_remove_one(struct dio_dev *d)\n{\n\tunregister_framebuffer(&fb_info);\n\tif (d->scode >= DIOII_SCBASE)\n\t\tiounmap((void *)fb_regs);\n\trelease_mem_region(d->resource.start, resource_size(&d->resource));\n\tfb_dealloc_cmap(&fb_info.cmap);\n\tif (fb_info.screen_base)\n\t\tiounmap(fb_info.screen_base);\n}\n\nstatic struct dio_device_id hpfb_dio_tbl[] = {\n    { DIO_ENCODE_ID(DIO_ID_FBUFFER, DIO_ID2_LRCATSEYE) },\n    { DIO_ENCODE_ID(DIO_ID_FBUFFER, DIO_ID2_HRCCATSEYE) },\n    { DIO_ENCODE_ID(DIO_ID_FBUFFER, DIO_ID2_HRMCATSEYE) },\n    { DIO_ENCODE_ID(DIO_ID_FBUFFER, DIO_ID2_TOPCAT) },\n    { 0 }\n};\n\nstatic struct dio_driver hpfb_driver = {\n    .name      = \"hpfb\",\n    .id_table  = hpfb_dio_tbl,\n    .probe     = hpfb_dio_probe,\n    .remove    = hpfb_remove_one,\n};\n\nstatic int __init hpfb_init(void)\n{\n\tunsigned int sid;\n\tunsigned char i;\n\tint err;\n\n\t \n#define INTFBVADDR 0xf0560000\n#define INTFBPADDR 0x560000\n\n\tif (!MACH_IS_HP300)\n\t\treturn -ENODEV;\n\n\tif (fb_get_options(\"hpfb\", NULL))\n\t\treturn -ENODEV;\n\n\terr = dio_register_driver(&hpfb_driver);\n\tif (err)\n\t\treturn err;\n\n\terr = copy_from_kernel_nofault(&i, (unsigned char *)INTFBVADDR + DIO_IDOFF, 1);\n\n\tif (!err && (i == DIO_ID_FBUFFER) && topcat_sid_ok(sid = DIO_SECID(INTFBVADDR))) {\n\t\tif (!request_mem_region(INTFBPADDR, DIO_DEVSIZE, \"Internal Topcat\"))\n\t\t\treturn -EBUSY;\n\t\tprintk(KERN_INFO \"Internal Topcat found (secondary id %02x)\\n\", sid);\n\t\tif (hpfb_init_one(INTFBPADDR, INTFBVADDR)) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void __exit hpfb_cleanup_module(void)\n{\n\tdio_unregister_driver(&hpfb_driver);\n}\n\nmodule_init(hpfb_init);\nmodule_exit(hpfb_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}