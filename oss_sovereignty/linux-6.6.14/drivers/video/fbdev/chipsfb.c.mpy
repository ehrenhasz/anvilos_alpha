{
  "module_name": "chipsfb.c",
  "hash_id": "94bc30aed4c85ddb3337f00607bcc108efaae2ef4610f98f23bca7bdf4a3abf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/chipsfb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/fb.h>\n#include <linux/pm.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n#include <asm/backlight.h>\n#endif\n\n \n#define write_ind(num, val, ap, dp)\tdo { \\\n\toutb((num), (ap)); outb((val), (dp)); \\\n} while (0)\n#define read_ind(num, var, ap, dp)\tdo { \\\n\toutb((num), (ap)); var = inb((dp)); \\\n} while (0)\n\n \n#define write_xr(num, val)\twrite_ind(num, val, 0x3d6, 0x3d7)\n#define read_xr(num, var)\tread_ind(num, var, 0x3d6, 0x3d7)\n \n#define write_fr(num, val)\twrite_ind(num, val, 0x3d0, 0x3d1)\n#define read_fr(num, var)\tread_ind(num, var, 0x3d0, 0x3d1)\n \n#define write_cr(num, val)\twrite_ind(num, val, 0x3d4, 0x3d5)\n#define read_cr(num, var)\tread_ind(num, var, 0x3d4, 0x3d5)\n \n#define write_gr(num, val)\twrite_ind(num, val, 0x3ce, 0x3cf)\n#define read_gr(num, var)\tread_ind(num, var, 0x3ce, 0x3cf)\n \n#define write_sr(num, val)\twrite_ind(num, val, 0x3c4, 0x3c5)\n#define read_sr(num, var)\tread_ind(num, var, 0x3c4, 0x3c5)\n \n#define write_ar(num, val)\tdo { \\\n\tinb(0x3da); write_ind(num, val, 0x3c0, 0x3c0); \\\n} while (0)\n#define read_ar(num, var)\tdo { \\\n\tinb(0x3da); read_ind(num, var, 0x3c0, 0x3c1); \\\n} while (0)\n\n \nint chips_init(void);\n\nstatic int chipsfb_pci_init(struct pci_dev *dp, const struct pci_device_id *);\nstatic int chipsfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info);\nstatic int chipsfb_set_par(struct fb_info *info);\nstatic int chipsfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t     u_int transp, struct fb_info *info);\nstatic int chipsfb_blank(int blank, struct fb_info *info);\n\nstatic const struct fb_ops chipsfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= chipsfb_check_var,\n\t.fb_set_par\t= chipsfb_set_par,\n\t.fb_setcolreg\t= chipsfb_setcolreg,\n\t.fb_blank\t= chipsfb_blank,\n};\n\nstatic int chipsfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tif (var->xres > 800 || var->yres > 600\n\t    || var->xres_virtual > 800 || var->yres_virtual > 600\n\t    || (var->bits_per_pixel != 8 && var->bits_per_pixel != 16)\n\t    || var->nonstd\n\t    || (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)\n\t\treturn -EINVAL;\n\n\tvar->xres = var->xres_virtual = 800;\n\tvar->yres = var->yres_virtual = 600;\n\n\treturn 0;\n}\n\nstatic int chipsfb_set_par(struct fb_info *info)\n{\n\tif (info->var.bits_per_pixel == 16) {\n\t\twrite_cr(0x13, 200);\t\t\n\t\twrite_xr(0x81, 0x14);\t\t\n\t\twrite_xr(0x82, 0x00);\t\t\n\t\twrite_xr(0x20, 0x10);\t\t\n\n\t\tinfo->fix.line_length = 800*2;\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\n\t\tinfo->var.red.offset = 10;\n\t\tinfo->var.green.offset = 5;\n\t\tinfo->var.blue.offset = 0;\n\t\tinfo->var.red.length = info->var.green.length =\n\t\t\tinfo->var.blue.length = 5;\n\n\t} else {\n\t\t \n\t\twrite_cr(0x13, 100);\t\t\n\t\twrite_xr(0x81, 0x12);\t\t\n\t\twrite_xr(0x82, 0x08);\t\t\n\t\twrite_xr(0x20, 0x00);\t\t\n\n\t\tinfo->fix.line_length = 800;\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\n \t\tinfo->var.red.offset = info->var.green.offset =\n\t\t\tinfo->var.blue.offset = 0;\n\t\tinfo->var.red.length = info->var.green.length =\n\t\t\tinfo->var.blue.length = 8;\n\n\t}\n\treturn 0;\n}\n\nstatic int chipsfb_blank(int blank, struct fb_info *info)\n{\n\treturn 1;\t \n}\n\nstatic int chipsfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t     u_int transp, struct fb_info *info)\n{\n\tif (regno > 255)\n\t\treturn 1;\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\toutb(regno, 0x3c8);\n\tudelay(1);\n\toutb(red, 0x3c9);\n\toutb(green, 0x3c9);\n\toutb(blue, 0x3c9);\n\n\treturn 0;\n}\n\nstruct chips_init_reg {\n\tunsigned char addr;\n\tunsigned char data;\n};\n\nstatic struct chips_init_reg chips_init_sr[] = {\n\t{ 0x00, 0x03 },\n\t{ 0x01, 0x01 },\n\t{ 0x02, 0x0f },\n\t{ 0x04, 0x0e }\n};\n\nstatic struct chips_init_reg chips_init_gr[] = {\n\t{ 0x05, 0x00 },\n\t{ 0x06, 0x0d },\n\t{ 0x08, 0xff }\n};\n\nstatic struct chips_init_reg chips_init_ar[] = {\n\t{ 0x10, 0x01 },\n\t{ 0x12, 0x0f },\n\t{ 0x13, 0x00 }\n};\n\nstatic struct chips_init_reg chips_init_cr[] = {\n\t{ 0x00, 0x7f },\n\t{ 0x01, 0x63 },\n\t{ 0x02, 0x63 },\n\t{ 0x03, 0x83 },\n\t{ 0x04, 0x66 },\n\t{ 0x05, 0x10 },\n\t{ 0x06, 0x72 },\n\t{ 0x07, 0x3e },\n\t{ 0x08, 0x00 },\n\t{ 0x09, 0x40 },\n\t{ 0x0c, 0x00 },\n\t{ 0x0d, 0x00 },\n\t{ 0x10, 0x59 },\n\t{ 0x11, 0x0d },\n\t{ 0x12, 0x57 },\n\t{ 0x13, 0x64 },\n\t{ 0x14, 0x00 },\n\t{ 0x15, 0x57 },\n\t{ 0x16, 0x73 },\n\t{ 0x17, 0xe3 },\n\t{ 0x18, 0xff },\n\t{ 0x30, 0x02 },\n\t{ 0x31, 0x02 },\n\t{ 0x32, 0x02 },\n\t{ 0x33, 0x02 },\n\t{ 0x40, 0x00 },\n\t{ 0x41, 0x00 },\n\t{ 0x40, 0x80 }\n};\n\nstatic struct chips_init_reg chips_init_fr[] = {\n\t{ 0x01, 0x02 },\n\t{ 0x03, 0x08 },\n\t{ 0x04, 0x81 },\n\t{ 0x05, 0x21 },\n\t{ 0x08, 0x0c },\n\t{ 0x0a, 0x74 },\n\t{ 0x0b, 0x11 },\n\t{ 0x10, 0x0c },\n\t{ 0x11, 0xe0 },\n\t \n\t{ 0x20, 0x63 },\n\t{ 0x21, 0x68 },\n\t{ 0x22, 0x19 },\n\t{ 0x23, 0x7f },\n\t{ 0x24, 0x68 },\n\t{ 0x26, 0x00 },\n\t{ 0x27, 0x0f },\n\t{ 0x30, 0x57 },\n\t{ 0x31, 0x58 },\n\t{ 0x32, 0x0d },\n\t{ 0x33, 0x72 },\n\t{ 0x34, 0x02 },\n\t{ 0x35, 0x22 },\n\t{ 0x36, 0x02 },\n\t{ 0x37, 0x00 }\n};\n\nstatic struct chips_init_reg chips_init_xr[] = {\n\t{ 0xce, 0x00 },\t\t \n\t{ 0xcc, 0x43 },\t\t \n\t{ 0xcd, 0x18 },\n\t{ 0xce, 0xa1 },\n\t{ 0xc8, 0x84 },\n\t{ 0xc9, 0x0a },\n\t{ 0xca, 0x00 },\n\t{ 0xcb, 0x20 },\n\t{ 0xcf, 0x06 },\n\t{ 0xd0, 0x0e },\n\t{ 0x09, 0x01 },\n\t{ 0x0a, 0x02 },\n\t{ 0x0b, 0x01 },\n\t{ 0x20, 0x00 },\n\t{ 0x40, 0x03 },\n\t{ 0x41, 0x01 },\n\t{ 0x42, 0x00 },\n\t{ 0x80, 0x82 },\n\t{ 0x81, 0x12 },\n\t{ 0x82, 0x08 },\n\t{ 0xa0, 0x00 },\n\t{ 0xa8, 0x00 }\n};\n\nstatic void chips_hw_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(chips_init_xr); ++i)\n\t\twrite_xr(chips_init_xr[i].addr, chips_init_xr[i].data);\n\toutb(0x29, 0x3c2);  \n\tfor (i = 0; i < ARRAY_SIZE(chips_init_sr); ++i)\n\t\twrite_sr(chips_init_sr[i].addr, chips_init_sr[i].data);\n\tfor (i = 0; i < ARRAY_SIZE(chips_init_gr); ++i)\n\t\twrite_gr(chips_init_gr[i].addr, chips_init_gr[i].data);\n\tfor (i = 0; i < ARRAY_SIZE(chips_init_ar); ++i)\n\t\twrite_ar(chips_init_ar[i].addr, chips_init_ar[i].data);\n\tfor (i = 0; i < ARRAY_SIZE(chips_init_cr); ++i)\n\t\twrite_cr(chips_init_cr[i].addr, chips_init_cr[i].data);\n\tfor (i = 0; i < ARRAY_SIZE(chips_init_fr); ++i)\n\t\twrite_fr(chips_init_fr[i].addr, chips_init_fr[i].data);\n}\n\nstatic const struct fb_fix_screeninfo chipsfb_fix = {\n\t.id =\t\t\"C&T 65550\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_PSEUDOCOLOR,\n\t.accel =\tFB_ACCEL_NONE,\n\t.line_length =\t800,\n\n\n\n\n\n\n\n\n\t.smem_len =\t0x100000,\t \n};\n\nstatic const struct fb_var_screeninfo chipsfb_var = {\n\t.xres = 800,\n\t.yres = 600,\n\t.xres_virtual = 800,\n\t.yres_virtual = 600,\n\t.bits_per_pixel = 8,\n\t.red = { .length = 8 },\n\t.green = { .length = 8 },\n\t.blue = { .length = 8 },\n\t.height = -1,\n\t.width = -1,\n\t.vmode = FB_VMODE_NONINTERLACED,\n\t.pixclock = 10000,\n\t.left_margin = 16,\n\t.right_margin = 16,\n\t.upper_margin = 16,\n\t.lower_margin = 16,\n\t.hsync_len = 8,\n\t.vsync_len = 8,\n};\n\nstatic void init_chips(struct fb_info *p, unsigned long addr)\n{\n\tfb_memset_io(p->screen_base, 0, 0x100000);\n\n\tp->fix = chipsfb_fix;\n\tp->fix.smem_start = addr;\n\n\tp->var = chipsfb_var;\n\n\tp->fbops = &chipsfb_ops;\n\n\tfb_alloc_cmap(&p->cmap, 256, 0);\n\n\tchips_hw_init();\n}\n\nstatic int chipsfb_pci_init(struct pci_dev *dp, const struct pci_device_id *ent)\n{\n\tstruct fb_info *p;\n\tunsigned long addr;\n\tunsigned short cmd;\n\tint rc;\n\n\trc = aperture_remove_conflicting_pci_devices(dp, \"chipsfb\");\n\tif (rc)\n\t\treturn rc;\n\n\trc = pci_enable_device(dp);\n\tif (rc < 0) {\n\t\tdev_err(&dp->dev, \"Cannot enable PCI device\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif ((dp->resource[0].flags & IORESOURCE_MEM) == 0) {\n\t\trc = -ENODEV;\n\t\tgoto err_disable;\n\t}\n\taddr = pci_resource_start(dp, 0);\n\tif (addr == 0) {\n\t\trc = -ENODEV;\n\t\tgoto err_disable;\n\t}\n\n\tp = framebuffer_alloc(0, &dp->dev);\n\tif (p == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto err_disable;\n\t}\n\n\tif (pci_request_region(dp, 0, \"chipsfb\") != 0) {\n\t\tdev_err(&dp->dev, \"Cannot request framebuffer\\n\");\n\t\trc = -EBUSY;\n\t\tgoto err_release_fb;\n\t}\n\n#ifdef __BIG_ENDIAN\n\taddr += 0x800000;\t\n#endif\n\n\t \n\tpci_read_config_word(dp, PCI_COMMAND, &cmd);\n\tcmd |= 3;\t \n\tpci_write_config_word(dp, PCI_COMMAND, cmd);\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n\t \n\tmutex_lock(&pmac_backlight_mutex);\n\tif (pmac_backlight) {\n\t\tpmac_backlight->props.power = FB_BLANK_UNBLANK;\n\t\tbacklight_update_status(pmac_backlight);\n\t}\n\tmutex_unlock(&pmac_backlight_mutex);\n#endif  \n\n#ifdef CONFIG_PPC\n\tp->screen_base = ioremap_wc(addr, 0x200000);\n#else\n\tp->screen_base = ioremap(addr, 0x200000);\n#endif\n\tif (p->screen_base == NULL) {\n\t\tdev_err(&dp->dev, \"Cannot map framebuffer\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_release_pci;\n\t}\n\n\tpci_set_drvdata(dp, p);\n\n\tinit_chips(p, addr);\n\n\trc = register_framebuffer(p);\n\tif (rc < 0) {\n\t\tdev_err(&dp->dev,\"C&T 65550 framebuffer failed to register\\n\");\n\t\tgoto err_unmap;\n\t}\n\n\tdev_info(&dp->dev,\"fb%d: Chips 65550 frame buffer\"\n\t\t \" (%dK RAM detected)\\n\",\n\t\t p->node, p->fix.smem_len / 1024);\n\n\treturn 0;\n\n err_unmap:\n\tiounmap(p->screen_base);\n err_release_pci:\n\tpci_release_region(dp, 0);\n err_release_fb:\n\tframebuffer_release(p);\n err_disable:\n\tpci_disable_device(dp);\n err_out:\n\treturn rc;\n}\n\nstatic void chipsfb_remove(struct pci_dev *dp)\n{\n\tstruct fb_info *p = pci_get_drvdata(dp);\n\n\tif (p->screen_base == NULL)\n\t\treturn;\n\tunregister_framebuffer(p);\n\tiounmap(p->screen_base);\n\tp->screen_base = NULL;\n\tpci_release_region(dp, 0);\n}\n\n#ifdef CONFIG_PM\nstatic int chipsfb_pci_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n        struct fb_info *p = pci_get_drvdata(pdev);\n\n\tif (state.event == pdev->dev.power.power_state.event)\n\t\treturn 0;\n\tif (!(state.event & PM_EVENT_SLEEP))\n\t\tgoto done;\n\n\tconsole_lock();\n\tchipsfb_blank(1, p);\n\tfb_set_suspend(p, 1);\n\tconsole_unlock();\n done:\n\tpdev->dev.power.power_state = state;\n\treturn 0;\n}\n\nstatic int chipsfb_pci_resume(struct pci_dev *pdev)\n{\n        struct fb_info *p = pci_get_drvdata(pdev);\n\n\tconsole_lock();\n\tfb_set_suspend(p, 0);\n\tchipsfb_blank(0, p);\n\tconsole_unlock();\n\n\tpdev->dev.power.power_state = PMSG_ON;\n\treturn 0;\n}\n#endif  \n\n\nstatic struct pci_device_id chipsfb_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_CT, PCI_DEVICE_ID_CT_65550, PCI_ANY_ID, PCI_ANY_ID },\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, chipsfb_pci_tbl);\n\nstatic struct pci_driver chipsfb_driver = {\n\t.name =\t\t\"chipsfb\",\n\t.id_table =\tchipsfb_pci_tbl,\n\t.probe =\tchipsfb_pci_init,\n\t.remove =\tchipsfb_remove,\n#ifdef CONFIG_PM\n\t.suspend =\tchipsfb_pci_suspend,\n\t.resume =\tchipsfb_pci_resume,\n#endif\n};\n\nint __init chips_init(void)\n{\n\tif (fb_modesetting_disabled(\"chipsfb\"))\n\t\treturn -ENODEV;\n\n\tif (fb_get_options(\"chipsfb\", NULL))\n\t\treturn -ENODEV;\n\n\treturn pci_register_driver(&chipsfb_driver);\n}\n\nmodule_init(chips_init);\n\nstatic void __exit chipsfb_exit(void)\n{\n\tpci_unregister_driver(&chipsfb_driver);\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}