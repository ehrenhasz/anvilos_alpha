{
  "module_name": "display_gx1.c",
  "hash_id": "570ffd3b8dd2191e99acebd08289813f0c13134c187e4d33759f8dba3a5ec543",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/geode/display_gx1.c",
  "human_readable_source": "\n \n#include <linux/spinlock.h>\n#include <linux/fb.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n#include <asm/div64.h>\n#include <asm/delay.h>\n\n#include \"geodefb.h\"\n#include \"display_gx1.h\"\n\nstatic DEFINE_SPINLOCK(gx1_conf_reg_lock);\n\nstatic u8 gx1_read_conf_reg(u8 reg)\n{\n\tu8 val, ccr3;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gx1_conf_reg_lock, flags);\n\n\toutb(CONFIG_CCR3, 0x22);\n\tccr3 = inb(0x23);\n\toutb(CONFIG_CCR3, 0x22);\n\toutb(ccr3 | CONFIG_CCR3_MAPEN, 0x23);\n\toutb(reg, 0x22);\n\tval = inb(0x23);\n\toutb(CONFIG_CCR3, 0x22);\n\toutb(ccr3, 0x23);\n\n\tspin_unlock_irqrestore(&gx1_conf_reg_lock, flags);\n\n\treturn val;\n}\n\nunsigned gx1_gx_base(void)\n{\n\treturn (gx1_read_conf_reg(CONFIG_GCR) & 0x03) << 30;\n}\n\nint gx1_frame_buffer_size(void)\n{\n\tvoid __iomem *mc_regs;\n\tu32 bank_cfg;\n\tint d;\n\tunsigned dram_size = 0, fb_base;\n\n\tmc_regs = ioremap(gx1_gx_base() + 0x8400, 0x100);\n\tif (!mc_regs)\n\t\treturn -ENOMEM;\n\n\n\t \n\tbank_cfg = readl(mc_regs + MC_BANK_CFG);\n\n\tfor (d = 0; d < 2; d++) {\n\t\tif ((bank_cfg & MC_BCFG_DIMM0_PG_SZ_MASK) != MC_BCFG_DIMM0_PG_SZ_NO_DIMM)\n\t\t\tdram_size += 0x400000 << ((bank_cfg & MC_BCFG_DIMM0_SZ_MASK) >> 8);\n\t\tbank_cfg >>= 16;  \n\t}\n\n\tfb_base = (readl(mc_regs + MC_GBASE_ADD) & MC_GADD_GBADD_MASK) << 19;\n\n\tiounmap(mc_regs);\n\n\treturn dram_size - fb_base;\n}\n\nstatic void gx1_set_mode(struct fb_info *info)\n{\n\tstruct geodefb_par *par = info->par;\n\tu32 gcfg, tcfg, ocfg, dclk_div, val;\n\tint hactive, hblankstart, hsyncstart, hsyncend, hblankend, htotal;\n\tint vactive, vblankstart, vsyncstart, vsyncend, vblankend, vtotal;\n\n\t \n\treadl(par->dc_regs + DC_UNLOCK);\n\twritel(DC_UNLOCK_CODE, par->dc_regs + DC_UNLOCK);\n\n\tgcfg = readl(par->dc_regs + DC_GENERAL_CFG);\n\ttcfg = readl(par->dc_regs + DC_TIMING_CFG);\n\n\t \n\ttcfg &= ~(DC_TCFG_BLKE | DC_TCFG_TGEN);\n\twritel(tcfg, par->dc_regs + DC_TIMING_CFG);\n\n\t \n\tudelay(100);\n\n\t \n\tgcfg &= ~(DC_GCFG_DFLE | DC_GCFG_CMPE | DC_GCFG_DECE);\n\twritel(gcfg, par->dc_regs + DC_GENERAL_CFG);\n\n\t \n\tgcfg &= ~DC_GCFG_DCLK_MASK;\n\twritel(gcfg, par->dc_regs + DC_GENERAL_CFG);\n\n\tpar->vid_ops->set_dclk(info);\n\n\tdclk_div = DC_GCFG_DCLK_DIV_1;  \n\tgcfg |= dclk_div;\n\twritel(gcfg, par->dc_regs + DC_GENERAL_CFG);\n\n\t \n\tudelay(1000);  \n\n\t \n\n\t \n\tgcfg = DC_GCFG_VRDY | dclk_div;\n\n\t \n\t \n\tgcfg |= (6 << DC_GCFG_DFHPEL_POS) | (5 << DC_GCFG_DFHPSL_POS) | DC_GCFG_DFLE;\n\n\t \n\n\t \n\twritel(0, par->dc_regs + DC_FB_ST_OFFSET);\n\n\t \n\twritel(info->fix.line_length >> 2, par->dc_regs + DC_LINE_DELTA);\n\twritel(((info->var.xres * info->var.bits_per_pixel/8) >> 3) + 2,\n\t       par->dc_regs + DC_BUF_SIZE);\n\n\t \n\tocfg = DC_OCFG_PCKE | DC_OCFG_PDEL | DC_OCFG_PDEH;\n\tif (info->var.bits_per_pixel == 8) ocfg |= DC_OCFG_8BPP;\n\n\t \n\ttcfg = DC_TCFG_FPPE | DC_TCFG_HSYE | DC_TCFG_VSYE | DC_TCFG_BLKE\n\t\t| DC_TCFG_TGEN;\n\n\t \n\thactive = info->var.xres;\n\thblankstart = hactive;\n\thsyncstart = hblankstart + info->var.right_margin;\n\thsyncend =  hsyncstart + info->var.hsync_len;\n\thblankend = hsyncend + info->var.left_margin;\n\thtotal = hblankend;\n\n\tvactive = info->var.yres;\n\tvblankstart = vactive;\n\tvsyncstart = vblankstart + info->var.lower_margin;\n\tvsyncend =  vsyncstart + info->var.vsync_len;\n\tvblankend = vsyncend + info->var.upper_margin;\n\tvtotal = vblankend;\n\n\tval = (hactive - 1) | ((htotal - 1) << 16);\n\twritel(val, par->dc_regs + DC_H_TIMING_1);\n\tval = (hblankstart - 1) | ((hblankend - 1) << 16);\n\twritel(val, par->dc_regs + DC_H_TIMING_2);\n\tval = (hsyncstart - 1) | ((hsyncend - 1) << 16);\n\twritel(val, par->dc_regs + DC_H_TIMING_3);\n\twritel(val, par->dc_regs + DC_FP_H_TIMING);\n\tval = (vactive - 1) | ((vtotal - 1) << 16);\n\twritel(val, par->dc_regs + DC_V_TIMING_1);\n\tval = (vblankstart - 1) | ((vblankend - 1) << 16);\n\twritel(val, par->dc_regs + DC_V_TIMING_2);\n\tval = (vsyncstart - 1) | ((vsyncend - 1) << 16);\n\twritel(val, par->dc_regs + DC_V_TIMING_3);\n\tval = (vsyncstart - 2) | ((vsyncend - 2) << 16);\n\twritel(val, par->dc_regs + DC_FP_V_TIMING);\n\n\t \n\twritel(ocfg, par->dc_regs + DC_OUTPUT_CFG);\n\twritel(tcfg, par->dc_regs + DC_TIMING_CFG);\n\tudelay(1000);  \n\twritel(gcfg, par->dc_regs + DC_GENERAL_CFG);\n\n\tpar->vid_ops->configure_display(info);\n\n\t \n\twritel(0, par->dc_regs + DC_UNLOCK);\n\n\t \n}\n\nstatic void gx1_set_hw_palette_reg(struct fb_info *info, unsigned regno,\n\t\t\t\t   unsigned red, unsigned green, unsigned blue)\n{\n\tstruct geodefb_par *par = info->par;\n\tint val;\n\n\t \n\tval  = (red   <<  2) & 0x3f000;\n\tval |= (green >>  4) & 0x00fc0;\n\tval |= (blue  >> 10) & 0x0003f;\n\n\twritel(regno, par->dc_regs + DC_PAL_ADDRESS);\n\twritel(val, par->dc_regs + DC_PAL_DATA);\n}\n\nconst struct geode_dc_ops gx1_dc_ops = {\n\t.set_mode\t = gx1_set_mode,\n\t.set_palette_reg = gx1_set_hw_palette_reg,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}