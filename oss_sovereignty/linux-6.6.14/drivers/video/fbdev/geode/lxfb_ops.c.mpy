{
  "module_name": "lxfb_ops.c",
  "hash_id": "fd55f31fc72e146304525962b1adbc805378a908f8bb444bf0ea0adac8af398c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/geode/lxfb_ops.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/fb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/cs5535.h>\n\n#include \"lxfb.h\"\n\n \n\n \n\nstatic const struct {\n  unsigned int pllval;\n  unsigned int freq;\n} pll_table[] = {\n  { 0x000131AC,   6231 },\n  { 0x0001215D,   6294 },\n  { 0x00011087,   6750 },\n  { 0x0001216C,   7081 },\n  { 0x0001218D,   7140 },\n  { 0x000110C9,   7800 },\n  { 0x00013147,   7875 },\n  { 0x000110A7,   8258 },\n  { 0x00012159,   8778 },\n  { 0x00014249,   8875 },\n  { 0x00010057,   9000 },\n  { 0x0001219A,   9472 },\n  { 0x00012158,   9792 },\n  { 0x00010045,  10000 },\n  { 0x00010089,  10791 },\n  { 0x000110E7,  11225 },\n  { 0x00012136,  11430 },\n  { 0x00013207,  12375 },\n  { 0x00012187,  12500 },\n  { 0x00014286,  14063 },\n  { 0x000110E5,  15016 },\n  { 0x00014214,  16250 },\n  { 0x00011105,  17045 },\n  { 0x000131E4,  18563 },\n  { 0x00013183,  18750 },\n  { 0x00014284,  19688 },\n  { 0x00011104,  20400 },\n  { 0x00016363,  23625 },\n  { 0x000031AC,  24923 },\n  { 0x0000215D,  25175 },\n  { 0x00001087,  27000 },\n  { 0x0000216C,  28322 },\n  { 0x0000218D,  28560 },\n  { 0x000010C9,  31200 },\n  { 0x00003147,  31500 },\n  { 0x000010A7,  33032 },\n  { 0x00002159,  35112 },\n  { 0x00004249,  35500 },\n  { 0x00000057,  36000 },\n  { 0x0000219A,  37889 },\n  { 0x00002158,  39168 },\n  { 0x00000045,  40000 },\n  { 0x00000089,  43163 },\n  { 0x000010E7,  44900 },\n  { 0x00002136,  45720 },\n  { 0x00003207,  49500 },\n  { 0x00002187,  50000 },\n  { 0x00004286,  56250 },\n  { 0x000010E5,  60065 },\n  { 0x00004214,  65000 },\n  { 0x00001105,  68179 },\n  { 0x000031E4,  74250 },\n  { 0x00003183,  75000 },\n  { 0x00004284,  78750 },\n  { 0x00001104,  81600 },\n  { 0x00006363,  94500 },\n  { 0x00005303,  97520 },\n  { 0x00002183, 100187 },\n  { 0x00002122, 101420 },\n  { 0x00001081, 108000 },\n  { 0x00006201, 113310 },\n  { 0x00000041, 119650 },\n  { 0x000041A1, 129600 },\n  { 0x00002182, 133500 },\n  { 0x000041B1, 135000 },\n  { 0x00000051, 144000 },\n  { 0x000041E1, 148500 },\n  { 0x000062D1, 157500 },\n  { 0x000031A1, 162000 },\n  { 0x00000061, 169203 },\n  { 0x00004231, 172800 },\n  { 0x00002151, 175500 },\n  { 0x000052E1, 189000 },\n  { 0x00000071, 192000 },\n  { 0x00003201, 198000 },\n  { 0x00004291, 202500 },\n  { 0x00001101, 204750 },\n  { 0x00007481, 218250 },\n  { 0x00004170, 229500 },\n  { 0x00006210, 234000 },\n  { 0x00003140, 251182 },\n  { 0x00006250, 261000 },\n  { 0x000041C0, 278400 },\n  { 0x00005220, 280640 },\n  { 0x00000050, 288000 },\n  { 0x000041E0, 297000 },\n  { 0x00002130, 320207 }\n};\n\n\nstatic void lx_set_dotpll(u32 pllval)\n{\n\tu32 dotpll_lo, dotpll_hi;\n\tint i;\n\n\trdmsr(MSR_GLCP_DOTPLL, dotpll_lo, dotpll_hi);\n\n\tif ((dotpll_lo & MSR_GLCP_DOTPLL_LOCK) && (dotpll_hi == pllval))\n\t\treturn;\n\n\tdotpll_hi = pllval;\n\tdotpll_lo &= ~(MSR_GLCP_DOTPLL_BYPASS | MSR_GLCP_DOTPLL_HALFPIX);\n\tdotpll_lo |= MSR_GLCP_DOTPLL_DOTRESET;\n\n\twrmsr(MSR_GLCP_DOTPLL, dotpll_lo, dotpll_hi);\n\n\t \n\n\tudelay(100);\n\n\t \n\n\tfor (i = 0; i < 1000; i++) {\n\t\trdmsr(MSR_GLCP_DOTPLL, dotpll_lo, dotpll_hi);\n\t\tif (dotpll_lo & MSR_GLCP_DOTPLL_LOCK)\n\t\t\tbreak;\n\t}\n\n\t \n\n\tdotpll_lo &= ~MSR_GLCP_DOTPLL_DOTRESET;\n\twrmsr(MSR_GLCP_DOTPLL, dotpll_lo, dotpll_hi);\n}\n\n \n\nstatic void lx_set_clock(struct fb_info *info)\n{\n\tunsigned int diff, min, best = 0;\n\tunsigned int freq, i;\n\n\tfreq = (unsigned int) (1000000000 / info->var.pixclock);\n\n\tmin = abs(pll_table[0].freq - freq);\n\n\tfor (i = 0; i < ARRAY_SIZE(pll_table); i++) {\n\t\tdiff = abs(pll_table[i].freq - freq);\n\t\tif (diff < min) {\n\t\t\tmin = diff;\n\t\t\tbest = i;\n\t\t}\n\t}\n\n\tlx_set_dotpll(pll_table[best].pllval & 0x00017FFF);\n}\n\nstatic void lx_graphics_disable(struct fb_info *info)\n{\n\tstruct lxfb_par *par = info->par;\n\tunsigned int val, gcfg;\n\n\t \n\n\twrite_vp(par, VP_A1T, 0);\n\twrite_vp(par, VP_A2T, 0);\n\twrite_vp(par, VP_A3T, 0);\n\n\t \n\tval = read_dc(par, DC_GENERAL_CFG) & ~(DC_GENERAL_CFG_VGAE |\n\t\t\tDC_GENERAL_CFG_VIDE);\n\n\twrite_dc(par, DC_GENERAL_CFG, val);\n\n\tval = read_vp(par, VP_VCFG) & ~VP_VCFG_VID_EN;\n\twrite_vp(par, VP_VCFG, val);\n\n\twrite_dc(par, DC_IRQ, DC_IRQ_MASK | DC_IRQ_VIP_VSYNC_LOSS_IRQ_MASK |\n\t\t\tDC_IRQ_STATUS | DC_IRQ_VIP_VSYNC_IRQ_STATUS);\n\n\tval = read_dc(par, DC_GENLK_CTL) & ~DC_GENLK_CTL_GENLK_EN;\n\twrite_dc(par, DC_GENLK_CTL, val);\n\n\tval = read_dc(par, DC_CLR_KEY);\n\twrite_dc(par, DC_CLR_KEY, val & ~DC_CLR_KEY_CLR_KEY_EN);\n\n\t \n\twrite_fp(par, FP_PM, read_fp(par, FP_PM) & ~FP_PM_P);\n\n\tval = read_vp(par, VP_MISC) | VP_MISC_DACPWRDN;\n\twrite_vp(par, VP_MISC, val);\n\n\t \n\n\tval = read_vp(par, VP_DCFG);\n\twrite_vp(par, VP_DCFG, val & ~(VP_DCFG_CRT_EN | VP_DCFG_HSYNC_EN |\n\t\t\tVP_DCFG_VSYNC_EN | VP_DCFG_DAC_BL_EN));\n\n\tgcfg = read_dc(par, DC_GENERAL_CFG);\n\tgcfg &= ~(DC_GENERAL_CFG_CMPE | DC_GENERAL_CFG_DECE);\n\twrite_dc(par, DC_GENERAL_CFG, gcfg);\n\n\t \n\tval = read_dc(par, DC_DISPLAY_CFG);\n\tval &= ~DC_DISPLAY_CFG_TGEN;\n\twrite_dc(par, DC_DISPLAY_CFG, val);\n\n\t \n\tudelay(1000);\n\n\t \n\n\tgcfg &= ~DC_GENERAL_CFG_DFLE;\n\twrite_dc(par, DC_GENERAL_CFG, gcfg);\n\n\t \n\n\tdo {\n\t\tval = read_gp(par, GP_BLT_STATUS);\n\t} while ((val & GP_BLT_STATUS_PB) || !(val & GP_BLT_STATUS_CE));\n}\n\nstatic void lx_graphics_enable(struct fb_info *info)\n{\n\tstruct lxfb_par *par = info->par;\n\tu32 temp, config;\n\n\t \n\twrite_vp(par, VP_VRR, 0);\n\n\t \n\n\tconfig = read_vp(par, VP_DCFG);\n\n\tconfig &= ~(VP_DCFG_CRT_SYNC_SKW | VP_DCFG_PWR_SEQ_DELAY |\n\t\t\tVP_DCFG_CRT_HSYNC_POL | VP_DCFG_CRT_VSYNC_POL);\n\n\tconfig |= (VP_DCFG_CRT_SYNC_SKW_DEFAULT | VP_DCFG_PWR_SEQ_DELAY_DEFAULT\n\t\t\t| VP_DCFG_GV_GAM);\n\n\tif (info->var.sync & FB_SYNC_HOR_HIGH_ACT)\n\t\tconfig |= VP_DCFG_CRT_HSYNC_POL;\n\n\tif (info->var.sync & FB_SYNC_VERT_HIGH_ACT)\n\t\tconfig |= VP_DCFG_CRT_VSYNC_POL;\n\n\tif (par->output & OUTPUT_PANEL) {\n\t\tu32 msrlo, msrhi;\n\n\t\twrite_fp(par, FP_PT1, 0);\n\t\ttemp = FP_PT2_SCRC;\n\n\t\tif (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))\n\t\t\ttemp |= FP_PT2_HSP;\n\n\t\tif (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))\n\t\t\ttemp |= FP_PT2_VSP;\n\n\t\twrite_fp(par, FP_PT2, temp);\n\t\twrite_fp(par, FP_DFC, FP_DFC_BC);\n\n\t\tmsrlo = MSR_LX_MSR_PADSEL_TFT_SEL_LOW;\n\t\tmsrhi = MSR_LX_MSR_PADSEL_TFT_SEL_HIGH;\n\n\t\twrmsr(MSR_LX_MSR_PADSEL, msrlo, msrhi);\n\t}\n\n\tif (par->output & OUTPUT_CRT) {\n\t\tconfig |= VP_DCFG_CRT_EN | VP_DCFG_HSYNC_EN |\n\t\t\t\tVP_DCFG_VSYNC_EN | VP_DCFG_DAC_BL_EN;\n\t}\n\n\twrite_vp(par, VP_DCFG, config);\n\n\t \n\n\tif (par->output & OUTPUT_CRT) {\n\t\ttemp = read_vp(par, VP_MISC);\n\t\ttemp &= ~(VP_MISC_DACPWRDN | VP_MISC_APWRDN);\n\t\twrite_vp(par, VP_MISC, temp);\n\t}\n\n\t \n\tif (par->output & OUTPUT_PANEL)\n\t\twrite_fp(par, FP_PM, read_fp(par, FP_PM) | FP_PM_P);\n}\n\nunsigned int lx_framebuffer_size(void)\n{\n\tunsigned int val;\n\n\tif (!cs5535_has_vsa2()) {\n\t\tuint32_t hi, lo;\n\n\t\t \n\t\trdmsr(MSR_GLIU_P2D_RO0, lo, hi);\n\n\t\t \n\t\tval = ((hi & 0xff) << 12) | ((lo & 0xfff00000) >> 20);\n\t\t \n\t\tval -= (lo & 0x000fffff);\n\t\tval += 1;\n\n\t\t \n\t\treturn (val << 12);\n\t}\n\n\t \n\t \n\t \n\n\toutw(VSA_VR_UNLOCK, VSA_VRC_INDEX);\n\toutw(VSA_VR_MEM_SIZE, VSA_VRC_INDEX);\n\n\tval = (unsigned int)(inw(VSA_VRC_DATA)) & 0xFE;\n\treturn (val << 20);\n}\n\nvoid lx_set_mode(struct fb_info *info)\n{\n\tstruct lxfb_par *par = info->par;\n\tu64 msrval;\n\n\tunsigned int max, dv, val, size;\n\n\tunsigned int gcfg, dcfg;\n\tint hactive, hblankstart, hsyncstart, hsyncend, hblankend, htotal;\n\tint vactive, vblankstart, vsyncstart, vsyncend, vblankend, vtotal;\n\n\t \n\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\n\n\tlx_graphics_disable(info);\n\n\tlx_set_clock(info);\n\n\t \n\n\trdmsrl(MSR_LX_GLD_MSR_CONFIG, msrval);\n\tmsrval &= ~MSR_LX_GLD_MSR_CONFIG_FMT;\n\n\tif (par->output & OUTPUT_PANEL) {\n\t\tmsrval |= MSR_LX_GLD_MSR_CONFIG_FMT_FP;\n\n\t\tif (par->output & OUTPUT_CRT)\n\t\t\tmsrval |= MSR_LX_GLD_MSR_CONFIG_FPC;\n\t\telse\n\t\t\tmsrval &= ~MSR_LX_GLD_MSR_CONFIG_FPC;\n\t} else\n\t\tmsrval |= MSR_LX_GLD_MSR_CONFIG_FMT_CRT;\n\n\twrmsrl(MSR_LX_GLD_MSR_CONFIG, msrval);\n\n\t \n\t \n\n\twrite_dc(par, DC_FB_ST_OFFSET, 0);\n\twrite_dc(par, DC_CB_ST_OFFSET, 0);\n\twrite_dc(par, DC_CURS_ST_OFFSET, 0);\n\n\t \n\t \n\n\tval = read_dc(par, DC_GENLK_CTL);\n\tval &= ~(DC_GENLK_CTL_ALPHA_FLICK_EN | DC_GENLK_CTL_FLICK_EN |\n\t\t\tDC_GENLK_CTL_FLICK_SEL_MASK);\n\n\t \n\n\twrite_dc(par, DC_GFX_SCALE, (0x4000 << 16) | 0x4000);\n\twrite_dc(par, DC_IRQ_FILT_CTL, 0);\n\twrite_dc(par, DC_GENLK_CTL, val);\n\n\t \n\n\tif (info->fix.line_length > 4096)\n\t\tdv = DC_DV_CTL_DV_LINE_SIZE_8K;\n\telse if (info->fix.line_length > 2048)\n\t\tdv = DC_DV_CTL_DV_LINE_SIZE_4K;\n\telse if (info->fix.line_length > 1024)\n\t\tdv = DC_DV_CTL_DV_LINE_SIZE_2K;\n\telse\n\t\tdv = DC_DV_CTL_DV_LINE_SIZE_1K;\n\n\tmax = info->fix.line_length * info->var.yres;\n\tmax = (max + 0x3FF) & 0xFFFFFC00;\n\n\twrite_dc(par, DC_DV_TOP, max | DC_DV_TOP_DV_TOP_EN);\n\n\tval = read_dc(par, DC_DV_CTL) & ~DC_DV_CTL_DV_LINE_SIZE;\n\twrite_dc(par, DC_DV_CTL, val | dv);\n\n\tsize = info->var.xres * (info->var.bits_per_pixel >> 3);\n\n\twrite_dc(par, DC_GFX_PITCH, info->fix.line_length >> 3);\n\twrite_dc(par, DC_LINE_SIZE, (size + 7) >> 3);\n\n\t \n\n\trdmsrl(MSR_LX_SPARE_MSR, msrval);\n\n\tmsrval &= ~(MSR_LX_SPARE_MSR_DIS_CFIFO_HGO\n\t\t\t| MSR_LX_SPARE_MSR_VFIFO_ARB_SEL\n\t\t\t| MSR_LX_SPARE_MSR_LOAD_WM_LPEN_M\n\t\t\t| MSR_LX_SPARE_MSR_WM_LPEN_OVRD);\n\tmsrval |= MSR_LX_SPARE_MSR_DIS_VIFO_WM |\n\t\t\tMSR_LX_SPARE_MSR_DIS_INIT_V_PRI;\n\twrmsrl(MSR_LX_SPARE_MSR, msrval);\n\n\tgcfg = DC_GENERAL_CFG_DFLE;    \n\tgcfg |= (0x6 << DC_GENERAL_CFG_DFHPSL_SHIFT) |  \n\t\t\t(0xb << DC_GENERAL_CFG_DFHPEL_SHIFT);\n\tgcfg |= DC_GENERAL_CFG_FDTY;   \n\n\tdcfg  = DC_DISPLAY_CFG_VDEN;   \n\tdcfg |= DC_DISPLAY_CFG_GDEN;   \n\tdcfg |= DC_DISPLAY_CFG_TGEN;   \n\tdcfg |= DC_DISPLAY_CFG_TRUP;   \n\tdcfg |= DC_DISPLAY_CFG_PALB;   \n\tdcfg |= DC_DISPLAY_CFG_VISL;\n\tdcfg |= DC_DISPLAY_CFG_DCEN;   \n\n\t \n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tdcfg |= DC_DISPLAY_CFG_DISP_MODE_8BPP;\n\t\tbreak;\n\n\tcase 16:\n\t\tdcfg |= DC_DISPLAY_CFG_DISP_MODE_16BPP;\n\t\tbreak;\n\n\tcase 32:\n\tcase 24:\n\t\tdcfg |= DC_DISPLAY_CFG_DISP_MODE_24BPP;\n\t\tbreak;\n\t}\n\n\t \n\n\thactive = info->var.xres;\n\thblankstart = hactive;\n\thsyncstart = hblankstart + info->var.right_margin;\n\thsyncend =  hsyncstart + info->var.hsync_len;\n\thblankend = hsyncend + info->var.left_margin;\n\thtotal = hblankend;\n\n\tvactive = info->var.yres;\n\tvblankstart = vactive;\n\tvsyncstart = vblankstart + info->var.lower_margin;\n\tvsyncend =  vsyncstart + info->var.vsync_len;\n\tvblankend = vsyncend + info->var.upper_margin;\n\tvtotal = vblankend;\n\n\twrite_dc(par, DC_H_ACTIVE_TIMING, (hactive - 1) | ((htotal - 1) << 16));\n\twrite_dc(par, DC_H_BLANK_TIMING,\n\t\t\t(hblankstart - 1) | ((hblankend - 1) << 16));\n\twrite_dc(par, DC_H_SYNC_TIMING,\n\t\t\t(hsyncstart - 1) | ((hsyncend - 1) << 16));\n\n\twrite_dc(par, DC_V_ACTIVE_TIMING, (vactive - 1) | ((vtotal - 1) << 16));\n\twrite_dc(par, DC_V_BLANK_TIMING,\n\t\t\t(vblankstart - 1) | ((vblankend - 1) << 16));\n\twrite_dc(par, DC_V_SYNC_TIMING,\n\t\t\t(vsyncstart - 1) | ((vsyncend - 1) << 16));\n\n\twrite_dc(par, DC_FB_ACTIVE,\n\t\t\t(info->var.xres - 1) << 16 | (info->var.yres - 1));\n\n\t \n\tlx_graphics_enable(info);\n\n\t \n\twrite_dc(par, DC_DISPLAY_CFG, dcfg);\n\twrite_dc(par, DC_ARB_CFG, 0);\n\twrite_dc(par, DC_GENERAL_CFG, gcfg);\n\n\t \n\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_LOCK);\n}\n\nvoid lx_set_palette_reg(struct fb_info *info, unsigned regno,\n\t\t\tunsigned red, unsigned green, unsigned blue)\n{\n\tstruct lxfb_par *par = info->par;\n\tint val;\n\n\t \n\n\tval  = (red   << 8) & 0xff0000;\n\tval |= (green)      & 0x00ff00;\n\tval |= (blue  >> 8) & 0x0000ff;\n\n\twrite_dc(par, DC_PAL_ADDRESS, regno);\n\twrite_dc(par, DC_PAL_DATA, val);\n}\n\nint lx_blank_display(struct fb_info *info, int blank_mode)\n{\n\tstruct lxfb_par *par = info->par;\n\tu32 dcfg, misc, fp_pm;\n\tint blank, hsync, vsync;\n\n\t \n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\tblank = 0; hsync = 1; vsync = 1;\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\tblank = 1; hsync = 1; vsync = 1;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tblank = 1; hsync = 1; vsync = 0;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tblank = 1; hsync = 0; vsync = 1;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tblank = 1; hsync = 0; vsync = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdcfg = read_vp(par, VP_DCFG);\n\tdcfg &= ~(VP_DCFG_DAC_BL_EN | VP_DCFG_HSYNC_EN | VP_DCFG_VSYNC_EN |\n\t\t\tVP_DCFG_CRT_EN);\n\tif (!blank)\n\t\tdcfg |= VP_DCFG_DAC_BL_EN | VP_DCFG_CRT_EN;\n\tif (hsync)\n\t\tdcfg |= VP_DCFG_HSYNC_EN;\n\tif (vsync)\n\t\tdcfg |= VP_DCFG_VSYNC_EN;\n\n\twrite_vp(par, VP_DCFG, dcfg);\n\n\tmisc = read_vp(par, VP_MISC);\n\n\tif (vsync && hsync)\n\t\tmisc &= ~VP_MISC_DACPWRDN;\n\telse\n\t\tmisc |= VP_MISC_DACPWRDN;\n\n\twrite_vp(par, VP_MISC, misc);\n\n\t \n\n\tif (par->output & OUTPUT_PANEL) {\n\t\tfp_pm = read_fp(par, FP_PM);\n\t\tif (blank_mode == FB_BLANK_POWERDOWN)\n\t\t\tfp_pm &= ~FP_PM_P;\n\t\telse\n\t\t\tfp_pm |= FP_PM_P;\n\t\twrite_fp(par, FP_PM, fp_pm);\n\t}\n\n\treturn 0;\n}\n\nstatic void lx_save_regs(struct lxfb_par *par)\n{\n\tuint32_t filt;\n\tint i;\n\n\t \n\tdo {\n\t\ti = read_gp(par, GP_BLT_STATUS);\n\t} while ((i & GP_BLT_STATUS_PB) || !(i & GP_BLT_STATUS_CE));\n\n\t \n\trdmsrl(MSR_LX_MSR_PADSEL, par->msr.padsel);\n\trdmsrl(MSR_GLCP_DOTPLL, par->msr.dotpll);\n\trdmsrl(MSR_LX_GLD_MSR_CONFIG, par->msr.dfglcfg);\n\trdmsrl(MSR_LX_SPARE_MSR, par->msr.dcspare);\n\n\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\n\n\t \n\tmemcpy(par->gp, par->gp_regs, sizeof(par->gp));\n\tmemcpy(par->dc, par->dc_regs, sizeof(par->dc));\n\tmemcpy(par->vp, par->vp_regs, sizeof(par->vp));\n\tmemcpy(par->fp, par->vp_regs + VP_FP_START, sizeof(par->fp));\n\n\t \n\twrite_dc(par, DC_PAL_ADDRESS, 0);\n\tfor (i = 0; i < ARRAY_SIZE(par->dc_pal); i++)\n\t\tpar->dc_pal[i] = read_dc(par, DC_PAL_DATA);\n\n\t \n\twrite_vp(par, VP_PAR, 0);\n\tfor (i = 0; i < ARRAY_SIZE(par->vp_pal); i++)\n\t\tpar->vp_pal[i] = read_vp(par, VP_PDR);\n\n\t \n\tfilt = par->dc[DC_IRQ_FILT_CTL] | DC_IRQ_FILT_CTL_H_FILT_SEL;\n\tfor (i = 0; i < ARRAY_SIZE(par->hcoeff); i += 2) {\n\t\twrite_dc(par, DC_IRQ_FILT_CTL, (filt & 0xffffff00) | i);\n\t\tpar->hcoeff[i] = read_dc(par, DC_FILT_COEFF1);\n\t\tpar->hcoeff[i + 1] = read_dc(par, DC_FILT_COEFF2);\n\t}\n\n\t \n\tfilt &= ~DC_IRQ_FILT_CTL_H_FILT_SEL;\n\tfor (i = 0; i < ARRAY_SIZE(par->vcoeff); i++) {\n\t\twrite_dc(par, DC_IRQ_FILT_CTL, (filt & 0xffffff00) | i);\n\t\tpar->vcoeff[i] = read_dc(par, DC_FILT_COEFF1);\n\t}\n\n\t \n\tmemcpy(par->vp_coeff, par->vp_regs + VP_VCR, sizeof(par->vp_coeff));\n}\n\nstatic void lx_restore_gfx_proc(struct lxfb_par *par)\n{\n\tint i;\n\n\t \n\twrite_gp(par, GP_RASTER_MODE, par->gp[GP_RASTER_MODE]);\n\n\tfor (i = 0; i < ARRAY_SIZE(par->gp); i++) {\n\t\tswitch (i) {\n\t\tcase GP_RASTER_MODE:\n\t\tcase GP_VECTOR_MODE:\n\t\tcase GP_BLT_MODE:\n\t\tcase GP_BLT_STATUS:\n\t\tcase GP_HST_SRC:\n\t\t\t \n\t\tcase GP_LUT_INDEX:\n\t\tcase GP_LUT_DATA:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twrite_gp(par, i, par->gp[i]);\n\t\t}\n\t}\n}\n\nstatic void lx_restore_display_ctlr(struct lxfb_par *par)\n{\n\tuint32_t filt;\n\tint i;\n\n\twrmsrl(MSR_LX_SPARE_MSR, par->msr.dcspare);\n\n\tfor (i = 0; i < ARRAY_SIZE(par->dc); i++) {\n\t\tswitch (i) {\n\t\tcase DC_UNLOCK:\n\t\t\t \n\t\t\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\n\t\t\tbreak;\n\n\t\tcase DC_GENERAL_CFG:\n\t\tcase DC_DISPLAY_CFG:\n\t\t\t \n\t\t\twrite_dc(par, i, 0);\n\t\t\tbreak;\n\n\t\tcase DC_DV_CTL:\n\t\t\t \n\t\t\twrite_dc(par, i, par->dc[i] | DC_DV_CTL_CLEAR_DV_RAM);\n\t\t\tbreak;\n\n\t\tcase DC_RSVD_1:\n\t\tcase DC_RSVD_2:\n\t\tcase DC_RSVD_3:\n\t\tcase DC_LINE_CNT:\n\t\tcase DC_PAL_ADDRESS:\n\t\tcase DC_PAL_DATA:\n\t\tcase DC_DFIFO_DIAG:\n\t\tcase DC_CFIFO_DIAG:\n\t\tcase DC_FILT_COEFF1:\n\t\tcase DC_FILT_COEFF2:\n\t\tcase DC_RSVD_4:\n\t\tcase DC_RSVD_5:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twrite_dc(par, i, par->dc[i]);\n\t\t}\n\t}\n\n\t \n\twrite_dc(par, DC_PAL_ADDRESS, 0);\n\tfor (i = 0; i < ARRAY_SIZE(par->dc_pal); i++)\n\t\twrite_dc(par, DC_PAL_DATA, par->dc_pal[i]);\n\n\t \n\tfilt = par->dc[DC_IRQ_FILT_CTL] | DC_IRQ_FILT_CTL_H_FILT_SEL;\n\tfor (i = 0; i < ARRAY_SIZE(par->hcoeff); i += 2) {\n\t\twrite_dc(par, DC_IRQ_FILT_CTL, (filt & 0xffffff00) | i);\n\t\twrite_dc(par, DC_FILT_COEFF1, par->hcoeff[i]);\n\t\twrite_dc(par, DC_FILT_COEFF2, par->hcoeff[i + 1]);\n\t}\n\n\t \n\tfilt &= ~DC_IRQ_FILT_CTL_H_FILT_SEL;\n\tfor (i = 0; i < ARRAY_SIZE(par->vcoeff); i++) {\n\t\twrite_dc(par, DC_IRQ_FILT_CTL, (filt & 0xffffff00) | i);\n\t\twrite_dc(par, DC_FILT_COEFF1, par->vcoeff[i]);\n\t}\n}\n\nstatic void lx_restore_video_proc(struct lxfb_par *par)\n{\n\tint i;\n\n\twrmsrl(MSR_LX_GLD_MSR_CONFIG, par->msr.dfglcfg);\n\twrmsrl(MSR_LX_MSR_PADSEL, par->msr.padsel);\n\n\tfor (i = 0; i < ARRAY_SIZE(par->vp); i++) {\n\t\tswitch (i) {\n\t\tcase VP_VCFG:\n\t\tcase VP_DCFG:\n\t\tcase VP_PAR:\n\t\tcase VP_PDR:\n\t\tcase VP_CCS:\n\t\tcase VP_RSVD_0:\n\t\t   \n\t\tcase VP_RSVD_1:\n\t\tcase VP_CRC32:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twrite_vp(par, i, par->vp[i]);\n\t\t}\n\t}\n\n\t \n\twrite_vp(par, VP_PAR, 0);\n\tfor (i = 0; i < ARRAY_SIZE(par->vp_pal); i++)\n\t\twrite_vp(par, VP_PDR, par->vp_pal[i]);\n\n\t \n\tmemcpy(par->vp_regs + VP_VCR, par->vp_coeff, sizeof(par->vp_coeff));\n}\n\nstatic void lx_restore_regs(struct lxfb_par *par)\n{\n\tint i;\n\n\tlx_set_dotpll((u32) (par->msr.dotpll >> 32));\n\tlx_restore_gfx_proc(par);\n\tlx_restore_display_ctlr(par);\n\tlx_restore_video_proc(par);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(par->fp); i++) {\n\t\tswitch (i) {\n\t\tcase FP_PM:\n\t\tcase FP_RSVD_0:\n\t\tcase FP_RSVD_1:\n\t\tcase FP_RSVD_2:\n\t\tcase FP_RSVD_3:\n\t\tcase FP_RSVD_4:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twrite_fp(par, i, par->fp[i]);\n\t\t}\n\t}\n\n\t \n\tif (par->fp[FP_PM] & FP_PM_P) {\n\t\t \n\t\tif (!(read_fp(par, FP_PM) &\n\t\t\t\t(FP_PM_PANEL_ON|FP_PM_PANEL_PWR_UP)))\n\t\t\twrite_fp(par, FP_PM, par->fp[FP_PM]);\n\t} else {\n\t\t \n\t\tif (!(read_fp(par, FP_PM) &\n\t\t\t\t(FP_PM_PANEL_OFF|FP_PM_PANEL_PWR_DOWN)))\n\t\t\twrite_fp(par, FP_PM, par->fp[FP_PM]);\n\t}\n\n\t \n\twrite_vp(par, VP_VCFG, par->vp[VP_VCFG]);\n\twrite_vp(par, VP_DCFG, par->vp[VP_DCFG]);\n\twrite_dc(par, DC_DISPLAY_CFG, par->dc[DC_DISPLAY_CFG]);\n\t \n\twrite_dc(par, DC_GENERAL_CFG, par->dc[DC_GENERAL_CFG]);\n\n\t \n\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_LOCK);\n}\n\nint lx_powerdown(struct fb_info *info)\n{\n\tstruct lxfb_par *par = info->par;\n\n\tif (par->powered_down)\n\t\treturn 0;\n\n\tlx_save_regs(par);\n\tlx_graphics_disable(info);\n\n\tpar->powered_down = 1;\n\treturn 0;\n}\n\nint lx_powerup(struct fb_info *info)\n{\n\tstruct lxfb_par *par = info->par;\n\n\tif (!par->powered_down)\n\t\treturn 0;\n\n\tlx_restore_regs(par);\n\n\tpar->powered_down = 0;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}