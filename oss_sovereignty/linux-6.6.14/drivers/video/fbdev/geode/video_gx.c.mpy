{
  "module_name": "video_gx.c",
  "hash_id": "ec14efe76f95a5fd533a285d42ffb7d9076f34304c4a12da002027ef6fabca3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/geode/video_gx.c",
  "human_readable_source": "\n \n#include <linux/fb.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n#include <asm/delay.h>\n#include <asm/msr.h>\n#include <linux/cs5535.h>\n\n#include \"gxfb.h\"\n\n\n \nstruct gx_pll_entry {\n\tlong pixclock;  \n\tu32 sys_rstpll_bits;\n\tu32 dotpll_value;\n};\n\n#define POSTDIV3 ((u32)MSR_GLCP_SYS_RSTPLL_DOTPOSTDIV3)\n#define PREMULT2 ((u32)MSR_GLCP_SYS_RSTPLL_DOTPREMULT2)\n#define PREDIV2  ((u32)MSR_GLCP_SYS_RSTPLL_DOTPOSTDIV3)\n\nstatic const struct gx_pll_entry gx_pll_table_48MHz[] = {\n\t{ 40123, POSTDIV3,\t    0x00000BF2 },\t \n\t{ 39721, 0,\t\t    0x00000037 },\t \n\t{ 35308, POSTDIV3|PREMULT2, 0x00000B1A },\t \n\t{ 31746, POSTDIV3,\t    0x000002D2 },\t \n\t{ 27777, POSTDIV3|PREMULT2, 0x00000FE2 },\t \n\t{ 26666, POSTDIV3,\t    0x0000057A },\t \n\t{ 25000, POSTDIV3,\t    0x0000030A },\t \n\t{ 22271, 0,\t\t    0x00000063 },\t \n\t{ 20202, 0,\t\t    0x0000054B },\t \n\t{ 20000, 0,\t\t    0x0000026E },\t \n\t{ 19860, PREMULT2,\t    0x00000037 },\t \n\t{ 18518, POSTDIV3|PREMULT2, 0x00000B0D },\t \n\t{ 17777, 0,\t\t    0x00000577 },\t \n\t{ 17733, 0,\t\t    0x000007F7 },\t \n\t{ 17653, 0,\t\t    0x0000057B },\t \n\t{ 16949, PREMULT2,\t    0x00000707 },\t \n\t{ 15873, POSTDIV3|PREMULT2, 0x00000B39 },\t \n\t{ 15384, POSTDIV3|PREMULT2, 0x00000B45 },\t \n\t{ 14814, POSTDIV3|PREMULT2, 0x00000FC1 },\t \n\t{ 14124, POSTDIV3,\t    0x00000561 },\t \n\t{ 13888, POSTDIV3,\t    0x000007E1 },\t \n\t{ 13426, PREMULT2,\t    0x00000F4A },\t \n\t{ 13333, 0,\t\t    0x00000052 },\t \n\t{ 12698, 0,\t\t    0x00000056 },\t \n\t{ 12500, POSTDIV3|PREMULT2, 0x00000709 },\t \n\t{ 11135, PREMULT2,\t    0x00000262 },\t \n\t{ 10582, 0,\t\t    0x000002D2 },\t \n\t{ 10101, PREMULT2,\t    0x00000B4A },\t \n\t{ 10000, PREMULT2,\t    0x00000036 },\t \n\t{  9259, 0,\t\t    0x000007E2 },\t \n\t{  8888, 0,\t\t    0x000007F6 },\t \n\t{  7692, POSTDIV3|PREMULT2, 0x00000FB0 },\t \n\t{  7407, POSTDIV3|PREMULT2, 0x00000B50 },\t \n\t{  6349, 0,\t\t    0x00000055 },\t \n\t{  6172, 0,\t\t    0x000009C1 },\t \n\t{  5787, PREMULT2,\t    0x0000002D },\t \n\t{  5698, 0,\t\t    0x000002C1 },\t \n\t{  5291, 0,\t\t    0x000002D1 },\t \n\t{  4938, 0,\t\t    0x00000551 },\t \n\t{  4357, 0,\t\t    0x0000057D },\t \n};\n\nstatic const struct gx_pll_entry gx_pll_table_14MHz[] = {\n\t{ 39721, 0, 0x00000037 },\t \n\t{ 35308, 0, 0x00000B7B },\t \n\t{ 31746, 0, 0x000004D3 },\t \n\t{ 27777, 0, 0x00000BE3 },\t \n\t{ 26666, 0, 0x0000074F },\t \n\t{ 25000, 0, 0x0000050B },\t \n\t{ 22271, 0, 0x00000063 },\t \n\t{ 20202, 0, 0x0000054B },\t \n\t{ 20000, 0, 0x0000026E },\t \n\t{ 19860, 0, 0x000007C3 },\t \n\t{ 18518, 0, 0x000007E3 },\t \n\t{ 17777, 0, 0x00000577 },\t \n\t{ 17733, 0, 0x000002FB },\t \n\t{ 17653, 0, 0x0000057B },\t \n\t{ 16949, 0, 0x0000058B },\t \n\t{ 15873, 0, 0x0000095E },\t \n\t{ 15384, 0, 0x0000096A },\t \n\t{ 14814, 0, 0x00000BC2 },\t \n\t{ 14124, 0, 0x0000098A },\t \n\t{ 13888, 0, 0x00000BE2 },\t \n\t{ 13333, 0, 0x00000052 },\t \n\t{ 12698, 0, 0x00000056 },\t \n\t{ 12500, 0, 0x0000050A },\t \n\t{ 11135, 0, 0x0000078E },\t \n\t{ 10582, 0, 0x000002D2 },\t \n\t{ 10101, 0, 0x000011F6 },\t \n\t{ 10000, 0, 0x0000054E },\t \n\t{  9259, 0, 0x000007E2 },\t \n\t{  8888, 0, 0x000002FA },\t \n\t{  7692, 0, 0x00000BB1 },\t \n\t{  7407, 0, 0x00000975 },\t \n\t{  6349, 0, 0x00000055 },\t \n\t{  6172, 0, 0x000009C1 },\t \n\t{  5698, 0, 0x000002C1 },\t \n\t{  5291, 0, 0x00000539 },\t \n\t{  4938, 0, 0x00000551 },\t \n\t{  4357, 0, 0x0000057D },\t \n};\n\nvoid gx_set_dclk_frequency(struct fb_info *info)\n{\n\tconst struct gx_pll_entry *pll_table;\n\tint pll_table_len;\n\tint i, best_i;\n\tlong min, diff;\n\tu64 dotpll, sys_rstpll;\n\tint timeout = 1000;\n\n\t \n\tif (cpu_data(0).x86_stepping == 1) {\n\t\tpll_table = gx_pll_table_14MHz;\n\t\tpll_table_len = ARRAY_SIZE(gx_pll_table_14MHz);\n\t} else {\n\t\tpll_table = gx_pll_table_48MHz;\n\t\tpll_table_len = ARRAY_SIZE(gx_pll_table_48MHz);\n\t}\n\n\t \n\tbest_i = 0;\n\tmin = abs(pll_table[0].pixclock - info->var.pixclock);\n\tfor (i = 1; i < pll_table_len; i++) {\n\t\tdiff = abs(pll_table[i].pixclock - info->var.pixclock);\n\t\tif (diff < min) {\n\t\t\tmin = diff;\n\t\t\tbest_i = i;\n\t\t}\n\t}\n\n\trdmsrl(MSR_GLCP_SYS_RSTPLL, sys_rstpll);\n\trdmsrl(MSR_GLCP_DOTPLL, dotpll);\n\n\t \n\tdotpll &= 0x00000000ffffffffull;\n\tdotpll |= (u64)pll_table[best_i].dotpll_value << 32;\n\tdotpll |= MSR_GLCP_DOTPLL_DOTRESET;\n\tdotpll &= ~MSR_GLCP_DOTPLL_BYPASS;\n\n\twrmsrl(MSR_GLCP_DOTPLL, dotpll);\n\n\t \n\tsys_rstpll &= ~( MSR_GLCP_SYS_RSTPLL_DOTPREDIV2\n\t\t\t | MSR_GLCP_SYS_RSTPLL_DOTPREMULT2\n\t\t\t | MSR_GLCP_SYS_RSTPLL_DOTPOSTDIV3 );\n\tsys_rstpll |= pll_table[best_i].sys_rstpll_bits;\n\n\twrmsrl(MSR_GLCP_SYS_RSTPLL, sys_rstpll);\n\n\t \n\tdotpll &= ~(MSR_GLCP_DOTPLL_DOTRESET);\n\twrmsrl(MSR_GLCP_DOTPLL, dotpll);\n\n\t \n\tdo {\n\t\trdmsrl(MSR_GLCP_DOTPLL, dotpll);\n\t} while (timeout-- && !(dotpll & MSR_GLCP_DOTPLL_LOCK));\n}\n\nstatic void\ngx_configure_tft(struct fb_info *info)\n{\n\tstruct gxfb_par *par = info->par;\n\tunsigned long val;\n\tunsigned long fp;\n\n\t \n\n\trdmsrl(MSR_GX_MSR_PADSEL, val);\n\tval &= ~MSR_GX_MSR_PADSEL_MASK;\n\tval |= MSR_GX_MSR_PADSEL_TFT;\n\twrmsrl(MSR_GX_MSR_PADSEL, val);\n\n\t \n\n\tfp = read_fp(par, FP_PM);\n\tfp &= ~FP_PM_P;\n\twrite_fp(par, FP_PM, fp);\n\n\t \n\n\tfp = read_fp(par, FP_PT1);\n\tfp &= FP_PT1_VSIZE_MASK;\n\tfp |= info->var.yres << FP_PT1_VSIZE_SHIFT;\n\twrite_fp(par, FP_PT1, fp);\n\n\t \n\t \n\n\tfp = 0x0F100000;\n\n\t \n\n\tif (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))\n\t\tfp |= FP_PT2_VSP;\n\n\tif (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))\n\t\tfp |= FP_PT2_HSP;\n\n\twrite_fp(par, FP_PT2, fp);\n\n\t \n\twrite_fp(par, FP_DFC, FP_DFC_NFI);\n\n\t \n\n\tfp = read_vp(par, VP_DCFG);\n\tfp |= VP_DCFG_FP_PWR_EN | VP_DCFG_FP_DATA_EN;\n\twrite_vp(par, VP_DCFG, fp);\n\n\t \n\n\tfp = read_fp(par, FP_PM);\n\tfp |= FP_PM_P;\n\twrite_fp(par, FP_PM, fp);\n}\n\nvoid gx_configure_display(struct fb_info *info)\n{\n\tstruct gxfb_par *par = info->par;\n\tu32 dcfg, misc;\n\n\t \n\tdcfg = read_vp(par, VP_DCFG);\n\n\t \n\tdcfg &= ~(VP_DCFG_VSYNC_EN | VP_DCFG_HSYNC_EN);\n\twrite_vp(par, VP_DCFG, dcfg);\n\n\t \n\tdcfg &= ~(VP_DCFG_CRT_SYNC_SKW\n\t\t  | VP_DCFG_CRT_HSYNC_POL   | VP_DCFG_CRT_VSYNC_POL\n\t\t  | VP_DCFG_VSYNC_EN        | VP_DCFG_HSYNC_EN);\n\n\t \n\tdcfg |= VP_DCFG_CRT_SYNC_SKW_DEFAULT;\n\n\t \n\tdcfg |= VP_DCFG_HSYNC_EN | VP_DCFG_VSYNC_EN;\n\n\tmisc = read_vp(par, VP_MISC);\n\n\t \n\tmisc |= VP_MISC_GAM_EN;\n\n\tif (par->enable_crt) {\n\n\t\t \n\t\tmisc &= ~(VP_MISC_APWRDN | VP_MISC_DACPWRDN);\n\t\twrite_vp(par, VP_MISC, misc);\n\n\t\t \n\t\tif (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))\n\t\t\tdcfg |= VP_DCFG_CRT_HSYNC_POL;\n\t\tif (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))\n\t\t\tdcfg |= VP_DCFG_CRT_VSYNC_POL;\n\t} else {\n\t\t \n\t\tmisc |= (VP_MISC_APWRDN | VP_MISC_DACPWRDN);\n\t\twrite_vp(par, VP_MISC, misc);\n\t}\n\n\t \n\t \n\n\tdcfg |= VP_DCFG_CRT_EN | VP_DCFG_DAC_BL_EN;\n\n\t \n\n\twrite_vp(par, VP_DCFG, dcfg);\n\n\t \n\n\tif (par->enable_crt == 0)\n\t\tgx_configure_tft(info);\n}\n\nint gx_blank_display(struct fb_info *info, int blank_mode)\n{\n\tstruct gxfb_par *par = info->par;\n\tu32 dcfg, fp_pm;\n\tint blank, hsync, vsync, crt;\n\n\t \n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\tblank = 0; hsync = 1; vsync = 1; crt = 1;\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\tblank = 1; hsync = 1; vsync = 1; crt = 1;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tblank = 1; hsync = 1; vsync = 0; crt = 1;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tblank = 1; hsync = 0; vsync = 1; crt = 1;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tblank = 1; hsync = 0; vsync = 0; crt = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tdcfg = read_vp(par, VP_DCFG);\n\tdcfg &= ~(VP_DCFG_DAC_BL_EN | VP_DCFG_HSYNC_EN | VP_DCFG_VSYNC_EN |\n\t\t\tVP_DCFG_CRT_EN);\n\tif (!blank)\n\t\tdcfg |= VP_DCFG_DAC_BL_EN;\n\tif (hsync)\n\t\tdcfg |= VP_DCFG_HSYNC_EN;\n\tif (vsync)\n\t\tdcfg |= VP_DCFG_VSYNC_EN;\n\tif (crt)\n\t\tdcfg |= VP_DCFG_CRT_EN;\n\twrite_vp(par, VP_DCFG, dcfg);\n\n\t \n\n\tif (par->enable_crt == 0) {\n\t\tfp_pm = read_fp(par, FP_PM);\n\t\tif (blank_mode == FB_BLANK_POWERDOWN)\n\t\t\tfp_pm &= ~FP_PM_P;\n\t\telse\n\t\t\tfp_pm |= FP_PM_P;\n\t\twrite_fp(par, FP_PM, fp_pm);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}