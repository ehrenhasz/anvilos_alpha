{
  "module_name": "display_gx.c",
  "hash_id": "7862a8f3baf765a059b4f43f2ea9d2eec14772fd12025f7ae3a1a1830bc1dd94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/geode/display_gx.c",
  "human_readable_source": "\n \n#include <linux/spinlock.h>\n#include <linux/fb.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n#include <asm/div64.h>\n#include <asm/delay.h>\n#include <linux/cs5535.h>\n\n#include \"gxfb.h\"\n\nunsigned int gx_frame_buffer_size(void)\n{\n\tunsigned int val;\n\n\tif (!cs5535_has_vsa2()) {\n\t\tuint32_t hi, lo;\n\n\t\t \n\t\trdmsr(MSR_GLIU_P2D_RO0, lo, hi);\n\n\t\t \n\t\tval = ((hi & 0xff) << 12) | ((lo & 0xfff00000) >> 20);\n\t\t \n\t\tval -= (lo & 0x000fffff);\n\t\tval += 1;\n\n\t\t \n\t\treturn (val << 12);\n\t}\n\n\t \n\t \n\t \n\n\toutw(VSA_VR_UNLOCK, VSA_VRC_INDEX);\n\toutw(VSA_VR_MEM_SIZE, VSA_VRC_INDEX);\n\n\tval = (unsigned int)(inw(VSA_VRC_DATA)) & 0xFFl;\n\treturn (val << 19);\n}\n\nint gx_line_delta(int xres, int bpp)\n{\n\t \n\treturn (xres * (bpp >> 3) + 7) & ~0x7;\n}\n\nvoid gx_set_mode(struct fb_info *info)\n{\n\tstruct gxfb_par *par = info->par;\n\tu32 gcfg, dcfg;\n\tint hactive, hblankstart, hsyncstart, hsyncend, hblankend, htotal;\n\tint vactive, vblankstart, vsyncstart, vsyncend, vblankend, vtotal;\n\n\t \n\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\n\n\tgcfg = read_dc(par, DC_GENERAL_CFG);\n\tdcfg = read_dc(par, DC_DISPLAY_CFG);\n\n\t \n\tdcfg &= ~DC_DISPLAY_CFG_TGEN;\n\twrite_dc(par, DC_DISPLAY_CFG, dcfg);\n\n\t \n\tudelay(100);\n\n\t \n\tgcfg &= ~(DC_GENERAL_CFG_DFLE | DC_GENERAL_CFG_CMPE |\n\t\t\tDC_GENERAL_CFG_DECE);\n\twrite_dc(par, DC_GENERAL_CFG, gcfg);\n\n\t \n\tgx_set_dclk_frequency(info);\n\n\t \n\n\t \n\tgcfg &= DC_GENERAL_CFG_YUVM | DC_GENERAL_CFG_VDSE;\n\tdcfg = 0;\n\n\t \n\t \n\tgcfg |= (6 << DC_GENERAL_CFG_DFHPEL_SHIFT) |\n\t\t(5 << DC_GENERAL_CFG_DFHPSL_SHIFT) | DC_GENERAL_CFG_DFLE;\n\n\t \n\twrite_dc(par, DC_FB_ST_OFFSET, 0);\n\n\t \n\twrite_dc(par, DC_GFX_PITCH, info->fix.line_length >> 3);\n\twrite_dc(par, DC_LINE_SIZE,\n\t\t((info->var.xres * info->var.bits_per_pixel/8) >> 3) + 2);\n\n\n\t \n\tdcfg |= DC_DISPLAY_CFG_GDEN | DC_DISPLAY_CFG_VDEN |\n\t\tDC_DISPLAY_CFG_A20M | DC_DISPLAY_CFG_A18M;\n\n\t \n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tdcfg |= DC_DISPLAY_CFG_DISP_MODE_8BPP;\n\t\tbreak;\n\tcase 16:\n\t\tdcfg |= DC_DISPLAY_CFG_DISP_MODE_16BPP;\n\t\tbreak;\n\tcase 32:\n\t\tdcfg |= DC_DISPLAY_CFG_DISP_MODE_24BPP;\n\t\tdcfg |= DC_DISPLAY_CFG_PALB;\n\t\tbreak;\n\t}\n\n\t \n\tdcfg |= DC_DISPLAY_CFG_TGEN;\n\n\t \n\thactive = info->var.xres;\n\thblankstart = hactive;\n\thsyncstart = hblankstart + info->var.right_margin;\n\thsyncend =  hsyncstart + info->var.hsync_len;\n\thblankend = hsyncend + info->var.left_margin;\n\thtotal = hblankend;\n\n\tvactive = info->var.yres;\n\tvblankstart = vactive;\n\tvsyncstart = vblankstart + info->var.lower_margin;\n\tvsyncend =  vsyncstart + info->var.vsync_len;\n\tvblankend = vsyncend + info->var.upper_margin;\n\tvtotal = vblankend;\n\n\twrite_dc(par, DC_H_ACTIVE_TIMING, (hactive - 1)    |\n\t\t\t((htotal - 1) << 16));\n\twrite_dc(par, DC_H_BLANK_TIMING, (hblankstart - 1) |\n\t\t\t((hblankend - 1) << 16));\n\twrite_dc(par, DC_H_SYNC_TIMING, (hsyncstart - 1)   |\n\t\t\t((hsyncend - 1) << 16));\n\n\twrite_dc(par, DC_V_ACTIVE_TIMING, (vactive - 1)    |\n\t\t\t((vtotal - 1) << 16));\n\twrite_dc(par, DC_V_BLANK_TIMING, (vblankstart - 1) |\n\t\t\t((vblankend - 1) << 16));\n\twrite_dc(par, DC_V_SYNC_TIMING, (vsyncstart - 1)   |\n\t\t\t((vsyncend - 1) << 16));\n\n\t \n\twrite_dc(par, DC_DISPLAY_CFG, dcfg);\n\twrite_dc(par, DC_GENERAL_CFG, gcfg);\n\n\tgx_configure_display(info);\n\n\t \n\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_LOCK);\n}\n\nvoid gx_set_hw_palette_reg(struct fb_info *info, unsigned regno,\n\t\tunsigned red, unsigned green, unsigned blue)\n{\n\tstruct gxfb_par *par = info->par;\n\tint val;\n\n\t \n\tval  = (red   << 8) & 0xff0000;\n\tval |= (green)      & 0x00ff00;\n\tval |= (blue  >> 8) & 0x0000ff;\n\n\twrite_dc(par, DC_PAL_ADDRESS, regno);\n\twrite_dc(par, DC_PAL_DATA, val);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}