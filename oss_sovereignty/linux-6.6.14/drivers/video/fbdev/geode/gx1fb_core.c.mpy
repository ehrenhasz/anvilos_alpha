{
  "module_name": "gx1fb_core.c",
  "hash_id": "2066a11616824a686aa77d512c21e3bb7fb333d6d3770d73140c80368a7fe81c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/geode/gx1fb_core.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n\n#include \"geodefb.h\"\n#include \"display_gx1.h\"\n#include \"video_cs5530.h\"\n\nstatic char mode_option[32] = \"640x480-16@60\";\nstatic int  crt_option = 1;\nstatic char panel_option[32] = \"\";\n\n \nstatic const struct fb_videomode gx1_modedb[] = {\n\t \n\t{ NULL, 60, 640, 480, 39682,  48, 16, 33, 10, 96, 2,\n\t  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 75, 640, 480, 31746, 120, 16, 16, 01, 64, 3,\n\t  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 85, 640, 480, 27777, 80, 56, 25, 01, 56, 3,\n\t  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 60, 800, 600, 25000, 88, 40, 23, 01, 128, 4,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 75, 800, 600, 20202, 160, 16, 21, 01, 80, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 85, 800, 600, 17761, 152, 32, 27, 01, 64, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 60, 1024, 768, 15384, 160, 24, 29, 3, 136, 6,\n\t  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 75, 1024, 768, 12690, 176, 16, 28, 1, 96, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 85, 1024, 768, 10582, 208, 48, 36, 1, 96, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 60, 1280, 960, 9259, 312, 96, 36, 1, 112, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 85, 1280, 960, 6734, 224, 64, 47, 1, 160, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 60, 1280, 1024, 9259, 248, 48, 38, 1, 112, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 75, 1280, 1024, 7407, 248, 16, 38, 1, 144, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n\t \n\t{ NULL, 85, 1280, 1024, 6349, 224, 64, 44, 1, 160, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },\n};\n\nstatic int gx1_line_delta(int xres, int bpp)\n{\n\tint line_delta = xres * (bpp >> 3);\n\n\tif (line_delta > 2048)\n\t\tline_delta = 4096;\n\telse if (line_delta > 1024)\n\t\tline_delta = 2048;\n\telse\n\t\tline_delta = 1024;\n\treturn line_delta;\n}\n\nstatic int gx1fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct geodefb_par *par = info->par;\n\n\t \n\tif (var->xres > 1280 || var->yres > 1024)\n\t\treturn -EINVAL;\n\n\tif (par->panel_x && (var->xres > par->panel_x || var->yres > par->panel_y))\n\t\treturn -EINVAL;\n\n\t \n\tif (var->bits_per_pixel == 16) {\n\t\tvar->red.offset   = 11; var->red.length   = 5;\n\t\tvar->green.offset =  5; var->green.length = 6;\n\t\tvar->blue.offset  =  0; var->blue.length  = 5;\n\t\tvar->transp.offset = 0; var->transp.length = 0;\n\t} else if (var->bits_per_pixel == 8) {\n\t\tvar->red.offset   = 0; var->red.length   = 8;\n\t\tvar->green.offset = 0; var->green.length = 8;\n\t\tvar->blue.offset  = 0; var->blue.length  = 8;\n\t\tvar->transp.offset = 0; var->transp.length = 0;\n\t} else\n\t\treturn -EINVAL;\n\n\t \n\tif (gx1_line_delta(var->xres, var->bits_per_pixel) * var->yres > info->fix.smem_len)\n\t\treturn -EINVAL;\n\n\t \n\n\treturn 0;\n}\n\nstatic int gx1fb_set_par(struct fb_info *info)\n{\n\tstruct geodefb_par *par = info->par;\n\n\tif (info->var.bits_per_pixel == 16)\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\telse\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\n\tinfo->fix.line_length = gx1_line_delta(info->var.xres, info->var.bits_per_pixel);\n\n\tpar->dc_ops->set_mode(info);\n\n\treturn 0;\n}\n\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\nstatic int gx1fb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t   unsigned blue, unsigned transp,\n\t\t\t   struct fb_info *info)\n{\n\tstruct geodefb_par *par = info->par;\n\n\tif (info->var.grayscale) {\n\t\t \n\t\tred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n\t}\n\n\t \n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\tu32 *pal = info->pseudo_palette;\n\t\tu32 v;\n\n\t\tif (regno >= 16)\n\t\t\treturn -EINVAL;\n\n\t\tv  = chan_to_field(red, &info->var.red);\n\t\tv |= chan_to_field(green, &info->var.green);\n\t\tv |= chan_to_field(blue, &info->var.blue);\n\n\t\tpal[regno] = v;\n\t} else {\n\t\tif (regno >= 256)\n\t\t\treturn -EINVAL;\n\n\t\tpar->dc_ops->set_palette_reg(info, regno, red, green, blue);\n\t}\n\n\treturn 0;\n}\n\nstatic int gx1fb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct geodefb_par *par = info->par;\n\n\treturn par->vid_ops->blank_display(info, blank_mode);\n}\n\nstatic int gx1fb_map_video_memory(struct fb_info *info, struct pci_dev *dev)\n{\n\tstruct geodefb_par *par = info->par;\n\tunsigned gx_base;\n\tint fb_len;\n\tint ret;\n\n\tgx_base = gx1_gx_base();\n\tif (!gx_base)\n\t\treturn -ENODEV;\n\n\tret = pci_enable_device(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pci_request_region(dev, 0, \"gx1fb (video)\");\n\tif (ret < 0)\n\t\treturn ret;\n\tpar->vid_regs = pci_ioremap_bar(dev, 0);\n\tif (!par->vid_regs)\n\t\treturn -ENOMEM;\n\n\tif (!request_mem_region(gx_base + 0x8300, 0x100, \"gx1fb (display controller)\"))\n\t\treturn -EBUSY;\n\tpar->dc_regs = ioremap(gx_base + 0x8300, 0x100);\n\tif (!par->dc_regs)\n\t\treturn -ENOMEM;\n\n\tif ((fb_len = gx1_frame_buffer_size()) < 0)\n\t\treturn -ENOMEM;\n\tinfo->fix.smem_start = gx_base + 0x800000;\n\tinfo->fix.smem_len = fb_len;\n\tinfo->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);\n\tif (!info->screen_base)\n\t\treturn -ENOMEM;\n\n\tdev_info(&dev->dev, \"%d Kibyte of video memory at 0x%lx\\n\",\n\t\t info->fix.smem_len / 1024, info->fix.smem_start);\n\n\treturn 0;\n}\n\nstatic int parse_panel_option(struct fb_info *info)\n{\n\tstruct geodefb_par *par = info->par;\n\n\tif (strcmp(panel_option, \"\") != 0) {\n\t\tint x, y;\n\t\tchar *s;\n\t\tx = simple_strtol(panel_option, &s, 10);\n\t\tif (!x)\n\t\t\treturn -EINVAL;\n\t\ty = simple_strtol(s + 1, NULL, 10);\n\t\tif (!y)\n\t\t\treturn -EINVAL;\n\t\tpar->panel_x = x;\n\t\tpar->panel_y = y;\n\t}\n\treturn 0;\n}\n\nstatic const struct fb_ops gx1fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= gx1fb_check_var,\n\t.fb_set_par\t= gx1fb_set_par,\n\t.fb_setcolreg\t= gx1fb_setcolreg,\n\t.fb_blank       = gx1fb_blank,\n};\n\nstatic struct fb_info *gx1fb_init_fbinfo(struct device *dev)\n{\n\tstruct geodefb_par *par;\n\tstruct fb_info *info;\n\n\t \n\tinfo = framebuffer_alloc(sizeof(struct geodefb_par) + sizeof(u32) * 16, dev);\n\tif (!info)\n\t\treturn NULL;\n\n\tpar = info->par;\n\n\tstrcpy(info->fix.id, \"GX1\");\n\n\tinfo->fix.type\t\t= FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.type_aux\t= 0;\n\tinfo->fix.xpanstep\t= 0;\n\tinfo->fix.ypanstep\t= 0;\n\tinfo->fix.ywrapstep\t= 0;\n\tinfo->fix.accel\t\t= FB_ACCEL_NONE;\n\n\tinfo->var.nonstd\t= 0;\n\tinfo->var.activate\t= FB_ACTIVATE_NOW;\n\tinfo->var.height\t= -1;\n\tinfo->var.width\t= -1;\n\tinfo->var.accel_flags = 0;\n\tinfo->var.vmode\t= FB_VMODE_NONINTERLACED;\n\n\tinfo->fbops\t\t= &gx1fb_ops;\n\tinfo->node\t\t= -1;\n\n\tinfo->pseudo_palette\t= (void *)par + sizeof(struct geodefb_par);\n\n\tinfo->var.grayscale\t= 0;\n\n\t \n\tpar->enable_crt = crt_option;\n\tif (parse_panel_option(info) < 0)\n\t\tprintk(KERN_WARNING \"gx1fb: invalid 'panel' option -- disabling flat panel\\n\");\n\tif (!par->panel_x)\n\t\tpar->enable_crt = 1;  \n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\n\t\tframebuffer_release(info);\n\t\treturn NULL;\n\t}\n\treturn info;\n}\n\nstatic int gx1fb_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct geodefb_par *par;\n\tstruct fb_info *info;\n\tint ret;\n\n\tret = aperture_remove_conflicting_pci_devices(pdev, \"gx1fb\");\n\tif (ret)\n\t\treturn ret;\n\n\tinfo = gx1fb_init_fbinfo(&pdev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tpar = info->par;\n\n\t \n\tpar->dc_ops  = &gx1_dc_ops;\n\tpar->vid_ops = &cs5530_vid_ops;\n\n\tif ((ret = gx1fb_map_video_memory(info, pdev)) < 0) {\n\t\tdev_err(&pdev->dev, \"failed to map frame buffer or controller registers\\n\");\n\t\tgoto err;\n\t}\n\n\tret = fb_find_mode(&info->var, info, mode_option,\n\t\t\t   gx1_modedb, ARRAY_SIZE(gx1_modedb), NULL, 16);\n\tif (ret == 0 || ret == 4) {\n\t\tdev_err(&pdev->dev, \"could not find valid video mode\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n         \n        memset_io(info->screen_base, 0, info->fix.smem_len);\n\n\tgx1fb_check_var(&info->var, info);\n\tgx1fb_set_par(info);\n\n\tif (register_framebuffer(info) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tpci_set_drvdata(pdev, info);\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\treturn 0;\n\n  err:\n\tif (info->screen_base) {\n\t\tiounmap(info->screen_base);\n\t\tpci_release_region(pdev, 0);\n\t}\n\tif (par->vid_regs) {\n\t\tiounmap(par->vid_regs);\n\t\tpci_release_region(pdev, 1);\n\t}\n\tif (par->dc_regs) {\n\t\tiounmap(par->dc_regs);\n\t\trelease_mem_region(gx1_gx_base() + 0x8300, 0x100);\n\t}\n\n\tfb_dealloc_cmap(&info->cmap);\n\tframebuffer_release(info);\n\n\treturn ret;\n}\n\nstatic void gx1fb_remove(struct pci_dev *pdev)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct geodefb_par *par = info->par;\n\n\tunregister_framebuffer(info);\n\n\tiounmap((void __iomem *)info->screen_base);\n\tpci_release_region(pdev, 0);\n\n\tiounmap(par->vid_regs);\n\tpci_release_region(pdev, 1);\n\n\tiounmap(par->dc_regs);\n\trelease_mem_region(gx1_gx_base() + 0x8300, 0x100);\n\n\tfb_dealloc_cmap(&info->cmap);\n\n\tframebuffer_release(info);\n}\n\n#ifndef MODULE\nstatic void __init gx1fb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn;\n\n\twhile ((this_opt = strsep(&options, \",\"))) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\n\t\tif (!strncmp(this_opt, \"mode:\", 5))\n\t\t\tstrscpy(mode_option, this_opt + 5, sizeof(mode_option));\n\t\telse if (!strncmp(this_opt, \"crt:\", 4))\n\t\t\tcrt_option = !!simple_strtoul(this_opt + 4, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"panel:\", 6))\n\t\t\tstrscpy(panel_option, this_opt + 6, sizeof(panel_option));\n\t\telse\n\t\t\tstrscpy(mode_option, this_opt, sizeof(mode_option));\n\t}\n}\n#endif\n\nstatic struct pci_device_id gx1fb_id_table[] = {\n\t{ PCI_VENDOR_ID_CYRIX, PCI_DEVICE_ID_CYRIX_5530_VIDEO,\n\t  PCI_ANY_ID, PCI_ANY_ID, PCI_BASE_CLASS_DISPLAY << 16,\n\t  0xff0000, 0 },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, gx1fb_id_table);\n\nstatic struct pci_driver gx1fb_driver = {\n\t.name\t\t= \"gx1fb\",\n\t.id_table\t= gx1fb_id_table,\n\t.probe\t\t= gx1fb_probe,\n\t.remove\t\t= gx1fb_remove,\n};\n\nstatic int __init gx1fb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"gx1fb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"gx1fb\", &option))\n\t\treturn -ENODEV;\n\tgx1fb_setup(option);\n#endif\n\treturn pci_register_driver(&gx1fb_driver);\n}\n\nstatic void gx1fb_cleanup(void)\n{\n\tpci_unregister_driver(&gx1fb_driver);\n}\n\nmodule_init(gx1fb_init);\nmodule_exit(gx1fb_cleanup);\n\nmodule_param_string(mode, mode_option, sizeof(mode_option), 0444);\nMODULE_PARM_DESC(mode, \"video mode (<x>x<y>[-<bpp>][@<refr>])\");\n\nmodule_param_named(crt, crt_option, int, 0444);\nMODULE_PARM_DESC(crt, \"enable CRT output. 0 = off, 1 = on (default)\");\n\nmodule_param_string(panel, panel_option, sizeof(panel_option), 0444);\nMODULE_PARM_DESC(panel, \"size of attached flat panel (<x>x<y>)\");\n\nMODULE_DESCRIPTION(\"framebuffer driver for the AMD Geode GX1\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}