{
  "module_name": "lxfb_core.c",
  "hash_id": "b35786314e6babacf8d9a83aadf1b942a7bbd1dfa7ba6e3f717178816249f92c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/geode/lxfb_core.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/mm.h>\n#include <linux/suspend.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n\n#include <asm/olpc.h>\n\n#include \"lxfb.h\"\n\nstatic char *mode_option;\nstatic int noclear, nopanel, nocrt;\nstatic int vram;\nstatic int vt_switch;\n\n \n\nstatic struct fb_videomode geode_modedb[] = {\n\t \n\t{ NULL, 60, 640, 480, 39682, 48, 8, 25, 2, 88, 2,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 70, 640, 400, 39770, 40, 8, 28, 5, 96, 2,\n\t  FB_SYNC_HOR_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 70, 640, 480, 35014, 88, 24, 15, 2, 64, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 72, 640, 480, 32102, 120, 16, 20, 1, 40, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 75, 640, 480, 31746, 120, 16, 16, 1, 64, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 85, 640, 480, 27780, 80, 56, 25, 1, 56, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 90, 640, 480, 26392, 96, 32, 22, 1, 64, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 100, 640, 480, 23167, 104, 40, 25, 1, 64, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 60, 640, 480, 39682, 48, 16, 25, 10, 88, 2,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 56, 800, 600, 27901, 128, 24, 22, 1, 72, 2,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 60, 800, 600, 25131, 72, 32, 23, 1, 136, 4,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 70, 800, 600, 21873, 120, 40, 21, 4, 80, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 72, 800, 600, 20052, 64, 56, 23, 37, 120, 6,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 75, 800, 600, 20202, 160, 16, 21, 1, 80, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 85, 800, 600, 17790, 152, 32, 27, 1, 64, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 90, 800, 600, 16648, 128, 40, 28, 1, 88, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 100, 800, 600, 14667, 136, 48, 27, 1, 88, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 60, 800, 600, 25131, 88, 40, 23, 1, 128, 4,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 60, 1024, 768, 15385, 160, 24, 29, 3, 136, 6,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 70, 1024, 768, 13346, 144, 24, 29, 3, 136, 6,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 72, 1024, 768, 12702, 168, 56, 29, 4, 112, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 75, 1024, 768, 12703, 176, 16, 28, 1, 96, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 85, 1024, 768, 10581, 208, 48, 36, 1, 96, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 90, 1024, 768, 9981, 176, 64, 37, 1, 112, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 100, 1024, 768, 8825, 184, 72, 42, 1, 112, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 60, 1024, 768, 15385, 160, 24, 29, 3, 136, 6,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 60, 1152, 864, 12251, 184, 64, 27, 1, 120, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 70, 1152, 864, 10254, 192, 72, 32, 8, 120, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 72, 1152, 864, 9866, 200, 72, 33, 7, 128, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 75, 1152, 864, 9259, 256, 64, 32, 1, 128, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 85, 1152, 864, 8357, 200, 72, 37, 3, 128, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 90, 1152, 864, 7719, 208, 80, 42, 9, 128, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 100, 1152, 864, 6947, 208, 80, 48, 3, 128, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 60, 1152, 864, 12251, 184, 64, 27, 1, 120, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 60, 1280, 1024, 9262, 248, 48, 38, 1, 112, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 70, 1280, 1024, 7719, 224, 88, 38, 6, 136, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 72, 1280, 1024, 7490, 224, 88, 39, 7, 136, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 75, 1280, 1024, 7409, 248, 16, 38, 1, 144, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 85, 1280, 1024, 6351, 224, 64, 44, 1, 160, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 90, 1280, 1024, 5791, 240, 96, 51, 12, 144, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 100, 1280, 1024, 5212, 240, 96, 57, 6, 144, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 60, 1280, 1024, 9262, 248, 48, 38, 1, 112, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 60, 1600, 1200, 6172, 304, 64, 46, 1, 192, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 70, 1600, 1200, 5291, 304, 64, 46, 1, 192, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 72, 1600, 1200, 5053, 288, 112, 47, 13, 176, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 75, 1600, 1200, 4938, 304, 64, 46, 1, 192, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 85, 1600, 1200, 4357, 304, 64, 46, 1, 192, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 90, 1600, 1200, 3981, 304, 128, 60, 1, 176, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 100, 1600, 1200, 3563, 304, 128, 67, 1, 176, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 60, 1600, 1200, 6172, 304, 64, 46, 1, 192, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 60, 1920, 1440, 4273, 344, 128, 56, 1, 208, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 70, 1920, 1440, 3593, 360, 152, 55, 8, 208, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 72, 1920, 1440, 3472, 360, 152, 68, 4, 208, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 75, 1920, 1440, 3367, 352, 144, 56, 1, 224, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n\t \n\t{ NULL, 85, 1920, 1440, 2929, 368, 152, 68, 1, 216, 3,\n\t  0, FB_VMODE_NONINTERLACED, 0 },\n};\n\nstatic struct fb_videomode olpc_dcon_modedb[] = {\n\t \n\t{ NULL, 50, 1200, 900, 17460, 24, 8, 4, 5, 8, 3,\n\t  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t  FB_VMODE_NONINTERLACED, 0 }\n};\n\nstatic void get_modedb(struct fb_videomode **modedb, unsigned int *size)\n{\n\tif (olpc_has_dcon()) {\n\t\t*modedb = (struct fb_videomode *) olpc_dcon_modedb;\n\t\t*size = ARRAY_SIZE(olpc_dcon_modedb);\n\t} else {\n\t\t*modedb = (struct fb_videomode *) geode_modedb;\n\t\t*size = ARRAY_SIZE(geode_modedb);\n\t}\n}\n\nstatic int lxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\tif (var->xres > 1920 || var->yres > 1440)\n\t\treturn -EINVAL;\n\n\tif (var->bits_per_pixel == 32) {\n\t\tvar->red.offset   = 16; var->red.length   = 8;\n\t\tvar->green.offset =  8; var->green.length = 8;\n\t\tvar->blue.offset  =  0; var->blue.length  = 8;\n\t} else if (var->bits_per_pixel == 16) {\n\t\tvar->red.offset   = 11; var->red.length   = 5;\n\t\tvar->green.offset =  5; var->green.length = 6;\n\t\tvar->blue.offset  =  0; var->blue.length  = 5;\n\t} else if (var->bits_per_pixel == 8) {\n\t\tvar->red.offset   = 0; var->red.length   = 8;\n\t\tvar->green.offset = 0; var->green.length = 8;\n\t\tvar->blue.offset  = 0; var->blue.length  = 8;\n\t} else\n\t\treturn -EINVAL;\n\n\tvar->transp.offset = 0; var->transp.length = 0;\n\n\t \n\tif ((lx_get_pitch(var->xres, var->bits_per_pixel) * var->yres)\n\t    > info->fix.smem_len)\n\t  return -EINVAL;\n\n\treturn 0;\n}\n\nstatic int lxfb_set_par(struct fb_info *info)\n{\n\tif (info->var.bits_per_pixel > 8)\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\telse\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\n\tinfo->fix.line_length = lx_get_pitch(info->var.xres,\n\t\tinfo->var.bits_per_pixel);\n\n\tlx_set_mode(info);\n\treturn 0;\n}\n\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\nstatic int lxfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t   unsigned blue, unsigned transp,\n\t\t\t   struct fb_info *info)\n{\n\tif (info->var.grayscale) {\n\t\t \n\t\tred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n\t}\n\n\t \n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\tu32 *pal = info->pseudo_palette;\n\t\tu32 v;\n\n\t\tif (regno >= 16)\n\t\t\treturn -EINVAL;\n\n\t\tv  = chan_to_field(red, &info->var.red);\n\t\tv |= chan_to_field(green, &info->var.green);\n\t\tv |= chan_to_field(blue, &info->var.blue);\n\n\t\tpal[regno] = v;\n\t} else {\n\t\tif (regno >= 256)\n\t\t\treturn -EINVAL;\n\n\t\tlx_set_palette_reg(info, regno, red, green, blue);\n\t}\n\n\treturn 0;\n}\n\nstatic int lxfb_blank(int blank_mode, struct fb_info *info)\n{\n\treturn lx_blank_display(info, blank_mode);\n}\n\n\nstatic int lxfb_map_video_memory(struct fb_info *info, struct pci_dev *dev)\n{\n\tstruct lxfb_par *par = info->par;\n\tint ret;\n\n\tret = pci_enable_device(dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_request_region(dev, 0, \"lxfb-framebuffer\");\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_request_region(dev, 1, \"lxfb-gp\");\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_request_region(dev, 2, \"lxfb-vg\");\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_request_region(dev, 3, \"lxfb-vp\");\n\n\tif (ret)\n\t\treturn ret;\n\n\tinfo->fix.smem_start = pci_resource_start(dev, 0);\n\tinfo->fix.smem_len = vram ? vram : lx_framebuffer_size();\n\n\tinfo->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);\n\n\tret = -ENOMEM;\n\n\tif (info->screen_base == NULL)\n\t\treturn ret;\n\n\tpar->gp_regs = pci_ioremap_bar(dev, 1);\n\n\tif (par->gp_regs == NULL)\n\t\treturn ret;\n\n\tpar->dc_regs = pci_ioremap_bar(dev, 2);\n\n\tif (par->dc_regs == NULL)\n\t\treturn ret;\n\n\tpar->vp_regs = pci_ioremap_bar(dev, 3);\n\n\tif (par->vp_regs == NULL)\n\t\treturn ret;\n\n\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\n\twrite_dc(par, DC_GLIU0_MEM_OFFSET, info->fix.smem_start & 0xFF000000);\n\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_LOCK);\n\n\tdev_info(&dev->dev, \"%d KB of video memory at 0x%lx\\n\",\n\t\t info->fix.smem_len / 1024, info->fix.smem_start);\n\n\treturn 0;\n}\n\nstatic const struct fb_ops lxfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= lxfb_check_var,\n\t.fb_set_par\t= lxfb_set_par,\n\t.fb_setcolreg\t= lxfb_setcolreg,\n\t.fb_blank       = lxfb_blank,\n};\n\nstatic struct fb_info *lxfb_init_fbinfo(struct device *dev)\n{\n\tstruct lxfb_par *par;\n\tstruct fb_info *info;\n\n\t \n\tinfo = framebuffer_alloc(sizeof(struct lxfb_par) + sizeof(u32) * 16,\n\t\t\t\t dev);\n\tif (!info)\n\t\treturn NULL;\n\n\tpar = info->par;\n\n\tstrcpy(info->fix.id, \"Geode LX\");\n\n\tinfo->fix.type\t\t= FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.type_aux\t= 0;\n\tinfo->fix.xpanstep\t= 0;\n\tinfo->fix.ypanstep\t= 0;\n\tinfo->fix.ywrapstep\t= 0;\n\tinfo->fix.accel\t\t= FB_ACCEL_NONE;\n\n\tinfo->var.nonstd\t= 0;\n\tinfo->var.activate\t= FB_ACTIVATE_NOW;\n\tinfo->var.height\t= -1;\n\tinfo->var.width\t= -1;\n\tinfo->var.accel_flags = 0;\n\tinfo->var.vmode\t= FB_VMODE_NONINTERLACED;\n\n\tinfo->fbops\t\t= &lxfb_ops;\n\tinfo->node\t\t= -1;\n\n\tinfo->pseudo_palette\t= (void *)par + sizeof(struct lxfb_par);\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\n\t\tframebuffer_release(info);\n\t\treturn NULL;\n\t}\n\n\tinfo->var.grayscale\t= 0;\n\n\treturn info;\n}\n\nstatic int __maybe_unused lxfb_suspend(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\n\tconsole_lock();\n\tlx_powerdown(info);\n\tfb_set_suspend(info, 1);\n\tconsole_unlock();\n\n\t \n\n\treturn 0;\n}\n\nstatic int __maybe_unused lxfb_resume(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tint ret;\n\n\tconsole_lock();\n\tret = lx_powerup(info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"lxfb:  power up failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tfb_set_suspend(info, 0);\n\tconsole_unlock();\n\treturn 0;\n}\n\nstatic int lxfb_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct lxfb_par *par;\n\tstruct fb_info *info;\n\tint ret;\n\n\tstruct fb_videomode *modedb_ptr;\n\tunsigned int modedb_size;\n\n\tret = aperture_remove_conflicting_pci_devices(pdev, \"lxfb\");\n\tif (ret)\n\t\treturn ret;\n\n\tinfo = lxfb_init_fbinfo(&pdev->dev);\n\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\n\tret = lxfb_map_video_memory(info, pdev);\n\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to map frame buffer or controller registers\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\n\tpar->output = 0;\n\tpar->output |= (nopanel) ? 0 : OUTPUT_PANEL;\n\tpar->output |= (nocrt) ? 0 : OUTPUT_CRT;\n\n\t \n\n\tget_modedb(&modedb_ptr, &modedb_size);\n\tret = fb_find_mode(&info->var, info, mode_option,\n\t\t\t   modedb_ptr, modedb_size, NULL, 16);\n\n\tif (ret == 0 || ret == 4) {\n\t\tdev_err(&pdev->dev, \"could not find valid video mode\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\n\tif (!noclear)\n\t\tmemset_io(info->screen_base, 0, info->fix.smem_len);\n\n\t \n\n\tlxfb_check_var(&info->var, info);\n\tlxfb_set_par(info);\n\n\tpm_set_vt_switch(vt_switch);\n\n\tif (register_framebuffer(info) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tpci_set_drvdata(pdev, info);\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\n\treturn 0;\n\nerr:\n\tif (info->screen_base) {\n\t\tiounmap(info->screen_base);\n\t\tpci_release_region(pdev, 0);\n\t}\n\tif (par->gp_regs) {\n\t\tiounmap(par->gp_regs);\n\t\tpci_release_region(pdev, 1);\n\t}\n\tif (par->dc_regs) {\n\t\tiounmap(par->dc_regs);\n\t\tpci_release_region(pdev, 2);\n\t}\n\tif (par->vp_regs) {\n\t\tiounmap(par->vp_regs);\n\t\tpci_release_region(pdev, 3);\n\t}\n\n\tfb_dealloc_cmap(&info->cmap);\n\tframebuffer_release(info);\n\n\treturn ret;\n}\n\nstatic void lxfb_remove(struct pci_dev *pdev)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct lxfb_par *par = info->par;\n\n\tunregister_framebuffer(info);\n\n\tiounmap(info->screen_base);\n\tpci_release_region(pdev, 0);\n\n\tiounmap(par->gp_regs);\n\tpci_release_region(pdev, 1);\n\n\tiounmap(par->dc_regs);\n\tpci_release_region(pdev, 2);\n\n\tiounmap(par->vp_regs);\n\tpci_release_region(pdev, 3);\n\n\tfb_dealloc_cmap(&info->cmap);\n\tframebuffer_release(info);\n}\n\nstatic struct pci_device_id lxfb_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LX_VIDEO) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, lxfb_id_table);\n\nstatic const struct dev_pm_ops lxfb_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= lxfb_suspend,\n\t.resume\t\t= lxfb_resume,\n\t.freeze\t\t= NULL,\n\t.thaw\t\t= lxfb_resume,\n\t.poweroff\t= NULL,\n\t.restore\t= lxfb_resume,\n#endif\n};\n\nstatic struct pci_driver lxfb_driver = {\n\t.name\t\t= \"lxfb\",\n\t.id_table\t= lxfb_id_table,\n\t.probe\t\t= lxfb_probe,\n\t.remove\t\t= lxfb_remove,\n\t.driver.pm\t= &lxfb_pm_ops,\n};\n\n#ifndef MODULE\nstatic int __init lxfb_setup(char *options)\n{\n\tchar *opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*opt)\n\t\t\tcontinue;\n\n\t\tif (!strcmp(opt, \"noclear\"))\n\t\t\tnoclear = 1;\n\t\telse if (!strcmp(opt, \"nopanel\"))\n\t\t\tnopanel = 1;\n\t\telse if (!strcmp(opt, \"nocrt\"))\n\t\t\tnocrt = 1;\n\t\telse\n\t\t\tmode_option = opt;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int __init lxfb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"lxfb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"lxfb\", &option))\n\t\treturn -ENODEV;\n\n\tlxfb_setup(option);\n#endif\n\treturn pci_register_driver(&lxfb_driver);\n}\nstatic void __exit lxfb_cleanup(void)\n{\n\tpci_unregister_driver(&lxfb_driver);\n}\n\nmodule_init(lxfb_init);\nmodule_exit(lxfb_cleanup);\n\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"video mode (<x>x<y>[-<bpp>][@<refr>])\");\n\nmodule_param(vram, int, 0);\nMODULE_PARM_DESC(vram, \"video memory size\");\n\nmodule_param(vt_switch, int, 0);\nMODULE_PARM_DESC(vt_switch, \"enable VT switch during suspend/resume\");\n\nMODULE_DESCRIPTION(\"Framebuffer driver for the AMD Geode LX\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}