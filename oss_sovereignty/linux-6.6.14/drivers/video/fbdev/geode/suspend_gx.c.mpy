{
  "module_name": "suspend_gx.c",
  "hash_id": "2ec78723204d0f6c359987ae61fa644096651dd9ad976fe301fc158d8c2b2e0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/geode/suspend_gx.c",
  "human_readable_source": "\n \n#include <linux/fb.h>\n#include <asm/io.h>\n#include <asm/msr.h>\n#include <linux/cs5535.h>\n#include <asm/delay.h>\n\n#include \"gxfb.h\"\n\nstatic void gx_save_regs(struct gxfb_par *par)\n{\n\tint i;\n\n\t \n\tdo {\n\t\ti = read_gp(par, GP_BLT_STATUS);\n\t} while (i & (GP_BLT_STATUS_BLT_PENDING | GP_BLT_STATUS_BLT_BUSY));\n\n\t \n\trdmsrl(MSR_GX_MSR_PADSEL, par->msr.padsel);\n\trdmsrl(MSR_GLCP_DOTPLL, par->msr.dotpll);\n\n\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\n\n\t \n\tmemcpy(par->gp, par->gp_regs, sizeof(par->gp));\n\tmemcpy(par->dc, par->dc_regs, sizeof(par->dc));\n\tmemcpy(par->vp, par->vid_regs, sizeof(par->vp));\n\tmemcpy(par->fp, par->vid_regs + VP_FP_START, sizeof(par->fp));\n\n\t \n\twrite_dc(par, DC_PAL_ADDRESS, 0);\n\tfor (i = 0; i < ARRAY_SIZE(par->pal); i++)\n\t\tpar->pal[i] = read_dc(par, DC_PAL_DATA);\n}\n\nstatic void gx_set_dotpll(uint32_t dotpll_hi)\n{\n\tuint32_t dotpll_lo;\n\tint i;\n\n\trdmsrl(MSR_GLCP_DOTPLL, dotpll_lo);\n\tdotpll_lo |= MSR_GLCP_DOTPLL_DOTRESET;\n\tdotpll_lo &= ~MSR_GLCP_DOTPLL_BYPASS;\n\twrmsr(MSR_GLCP_DOTPLL, dotpll_lo, dotpll_hi);\n\n\t \n\tfor (i = 0; i < 200; i++) {\n\t\trdmsrl(MSR_GLCP_DOTPLL, dotpll_lo);\n\t\tif (dotpll_lo & MSR_GLCP_DOTPLL_LOCK)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\t \n\tdotpll_lo &= ~MSR_GLCP_DOTPLL_DOTRESET;\n\twrmsr(MSR_GLCP_DOTPLL, dotpll_lo, dotpll_hi);\n}\n\nstatic void gx_restore_gfx_proc(struct gxfb_par *par)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(par->gp); i++) {\n\t\tswitch (i) {\n\t\tcase GP_VECTOR_MODE:\n\t\tcase GP_BLT_MODE:\n\t\tcase GP_BLT_STATUS:\n\t\tcase GP_HST_SRC:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\twrite_gp(par, i, par->gp[i]);\n\t\t}\n\t}\n}\n\nstatic void gx_restore_display_ctlr(struct gxfb_par *par)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(par->dc); i++) {\n\t\tswitch (i) {\n\t\tcase DC_UNLOCK:\n\t\t\t \n\t\t\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\n\t\t\tbreak;\n\n\t\tcase DC_GENERAL_CFG:\n\t\t\t \n\t\t\twrite_dc(par, i, par->dc[i] & ~(DC_GENERAL_CFG_VIDE |\n\t\t\t\t\tDC_GENERAL_CFG_ICNE |\n\t\t\t\t\tDC_GENERAL_CFG_CURE |\n\t\t\t\t\tDC_GENERAL_CFG_DFLE));\n\t\t\tbreak;\n\n\t\tcase DC_DISPLAY_CFG:\n\t\t\t \n\t\t\twrite_dc(par, i, par->dc[i] & ~(DC_DISPLAY_CFG_VDEN |\n\t\t\t\t\tDC_DISPLAY_CFG_GDEN |\n\t\t\t\t\tDC_DISPLAY_CFG_TGEN));\n\t\t\tbreak;\n\n\t\tcase DC_RSVD_0:\n\t\tcase DC_RSVD_1:\n\t\tcase DC_RSVD_2:\n\t\tcase DC_RSVD_3:\n\t\tcase DC_RSVD_4:\n\t\tcase DC_LINE_CNT:\n\t\tcase DC_PAL_ADDRESS:\n\t\tcase DC_PAL_DATA:\n\t\tcase DC_DFIFO_DIAG:\n\t\tcase DC_CFIFO_DIAG:\n\t\tcase DC_RSVD_5:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\twrite_dc(par, i, par->dc[i]);\n\t\t}\n\t}\n\n\t \n\twrite_dc(par, DC_PAL_ADDRESS, 0);\n\tfor (i = 0; i < ARRAY_SIZE(par->pal); i++)\n\t\twrite_dc(par, DC_PAL_DATA, par->pal[i]);\n}\n\nstatic void gx_restore_video_proc(struct gxfb_par *par)\n{\n\tint i;\n\n\twrmsrl(MSR_GX_MSR_PADSEL, par->msr.padsel);\n\n\tfor (i = 0; i < ARRAY_SIZE(par->vp); i++) {\n\t\tswitch (i) {\n\t\tcase VP_VCFG:\n\t\t\t \n\t\t\twrite_vp(par, i, par->vp[i] & ~VP_VCFG_VID_EN);\n\t\t\tbreak;\n\n\t\tcase VP_DCFG:\n\t\t\t \n\t\t\twrite_vp(par, i, par->vp[i] &\n\t\t\t\t\t~(VP_DCFG_DAC_BL_EN | VP_DCFG_VSYNC_EN |\n\t\t\t\t\tVP_DCFG_HSYNC_EN | VP_DCFG_CRT_EN));\n\t\t\tbreak;\n\n\t\tcase VP_GAR:\n\t\tcase VP_GDR:\n\t\tcase VP_RSVD_0:\n\t\tcase VP_RSVD_1:\n\t\tcase VP_RSVD_2:\n\t\tcase VP_RSVD_3:\n\t\tcase VP_CRC32:\n\t\tcase VP_AWT:\n\t\tcase VP_VTM:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\twrite_vp(par, i, par->vp[i]);\n\t\t}\n\t}\n}\n\nstatic void gx_restore_regs(struct gxfb_par *par)\n{\n\tint i;\n\n\tgx_set_dotpll((uint32_t) (par->msr.dotpll >> 32));\n\tgx_restore_gfx_proc(par);\n\tgx_restore_display_ctlr(par);\n\tgx_restore_video_proc(par);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(par->fp); i++) {\n\t\tif (i != FP_PM && i != FP_RSVD_0)\n\t\t\twrite_fp(par, i, par->fp[i]);\n\t}\n}\n\nstatic void gx_disable_graphics(struct gxfb_par *par)\n{\n\t \n\twrite_vp(par, VP_VCFG, par->vp[VP_VCFG] & ~VP_VCFG_VID_EN);\n\twrite_vp(par, VP_DCFG, par->vp[VP_DCFG] & ~(VP_DCFG_DAC_BL_EN |\n\t\t\tVP_DCFG_VSYNC_EN | VP_DCFG_HSYNC_EN | VP_DCFG_CRT_EN));\n\n\t \n\twrite_fp(par, FP_PM, par->fp[FP_PM] & ~FP_PM_P);\n\n\n\t \n\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\n\twrite_dc(par, DC_GENERAL_CFG, par->dc[DC_GENERAL_CFG] &\n\t\t\t~(DC_GENERAL_CFG_VIDE | DC_GENERAL_CFG_ICNE |\n\t\t\tDC_GENERAL_CFG_CURE | DC_GENERAL_CFG_DFLE));\n\twrite_dc(par, DC_DISPLAY_CFG, par->dc[DC_DISPLAY_CFG] &\n\t\t\t~(DC_DISPLAY_CFG_VDEN | DC_DISPLAY_CFG_GDEN |\n\t\t\tDC_DISPLAY_CFG_TGEN));\n\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_LOCK);\n}\n\nstatic void gx_enable_graphics(struct gxfb_par *par)\n{\n\tuint32_t fp;\n\n\tfp = read_fp(par, FP_PM);\n\tif (par->fp[FP_PM] & FP_PM_P) {\n\t\t \n\t\tif (!(fp & (FP_PM_PANEL_ON|FP_PM_PANEL_PWR_UP)))\n\t\t\twrite_fp(par, FP_PM, par->fp[FP_PM]);\n\t} else {\n\t\t \n\t\tif (!(fp & (FP_PM_PANEL_OFF|FP_PM_PANEL_PWR_DOWN)))\n\t\t\twrite_fp(par, FP_PM, par->fp[FP_PM]);\n\t}\n\n\t \n\twrite_vp(par, VP_VCFG, par->vp[VP_VCFG]);\n\twrite_vp(par, VP_DCFG, par->vp[VP_DCFG]);\n\twrite_dc(par, DC_DISPLAY_CFG, par->dc[DC_DISPLAY_CFG]);\n\t \n\twrite_dc(par, DC_GENERAL_CFG, par->dc[DC_GENERAL_CFG]);\n\n\t \n\twrite_dc(par, DC_UNLOCK, DC_UNLOCK_LOCK);\n}\n\nint gx_powerdown(struct fb_info *info)\n{\n\tstruct gxfb_par *par = info->par;\n\n\tif (par->powered_down)\n\t\treturn 0;\n\n\tgx_save_regs(par);\n\tgx_disable_graphics(par);\n\n\tpar->powered_down = 1;\n\treturn 0;\n}\n\nint gx_powerup(struct fb_info *info)\n{\n\tstruct gxfb_par *par = info->par;\n\n\tif (!par->powered_down)\n\t\treturn 0;\n\n\tgx_restore_regs(par);\n\tgx_enable_graphics(par);\n\n\tpar->powered_down  = 0;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}