{
  "module_name": "gxfb.h",
  "hash_id": "1f7faedbd62649425f6fa88878fbdbbad4925e3bd2d41993ead5599dd05432ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/geode/gxfb.h",
  "human_readable_source": " \n \n#ifndef _GXFB_H_\n#define _GXFB_H_\n\n#include <linux/io.h>\n\n#define GP_REG_COUNT   (0x50 / 4)\n#define DC_REG_COUNT   (0x90 / 4)\n#define VP_REG_COUNT   (0x138 / 8)\n#define FP_REG_COUNT   (0x68 / 8)\n\n#define DC_PAL_COUNT   0x104\n\nstruct gxfb_par {\n\tint enable_crt;\n\tvoid __iomem *dc_regs;\n\tvoid __iomem *vid_regs;\n\tvoid __iomem *gp_regs;\n\tint powered_down;\n\n\t \n\tstruct {\n\t\tuint64_t padsel;\n\t\tuint64_t dotpll;\n\t} msr;\n\n\tuint32_t gp[GP_REG_COUNT];\n\tuint32_t dc[DC_REG_COUNT];\n\tuint64_t vp[VP_REG_COUNT];\n\tuint64_t fp[FP_REG_COUNT];\n\n\tuint32_t pal[DC_PAL_COUNT];\n};\n\nunsigned int gx_frame_buffer_size(void);\nint gx_line_delta(int xres, int bpp);\nvoid gx_set_mode(struct fb_info *info);\nvoid gx_set_hw_palette_reg(struct fb_info *info, unsigned regno,\n\t\tunsigned red, unsigned green, unsigned blue);\n\nvoid gx_set_dclk_frequency(struct fb_info *info);\nvoid gx_configure_display(struct fb_info *info);\nint gx_blank_display(struct fb_info *info, int blank_mode);\n\nint gx_powerdown(struct fb_info *info);\nint gx_powerup(struct fb_info *info);\n\n \nenum gp_registers {\n\tGP_DST_OFFSET = 0,\n\tGP_SRC_OFFSET,\n\tGP_STRIDE,\n\tGP_WID_HEIGHT,\n\n\tGP_SRC_COLOR_FG,\n\tGP_SRC_COLOR_BG,\n\tGP_PAT_COLOR_0,\n\tGP_PAT_COLOR_1,\n\n\tGP_PAT_COLOR_2,\n\tGP_PAT_COLOR_3,\n\tGP_PAT_COLOR_4,\n\tGP_PAT_COLOR_5,\n\n\tGP_PAT_DATA_0,\n\tGP_PAT_DATA_1,\n\tGP_RASTER_MODE,\n\tGP_VECTOR_MODE,\n\n\tGP_BLT_MODE,\n\tGP_BLT_STATUS,\n\tGP_HST_SRC,\n\tGP_BASE_OFFSET,  \n};\n\n#define GP_BLT_STATUS_BLT_PENDING\t(1 << 2)\n#define GP_BLT_STATUS_BLT_BUSY\t\t(1 << 0)\n\n\n \nenum dc_registers {\n\tDC_UNLOCK = 0,\n\tDC_GENERAL_CFG,\n\tDC_DISPLAY_CFG,\n\tDC_RSVD_0,\n\n\tDC_FB_ST_OFFSET,\n\tDC_CB_ST_OFFSET,\n\tDC_CURS_ST_OFFSET,\n\tDC_ICON_ST_OFFSET,\n\n\tDC_VID_Y_ST_OFFSET,\n\tDC_VID_U_ST_OFFSET,\n\tDC_VID_V_ST_OFFSET,\n\tDC_RSVD_1,\n\n\tDC_LINE_SIZE,\n\tDC_GFX_PITCH,\n\tDC_VID_YUV_PITCH,\n\tDC_RSVD_2,\n\n\tDC_H_ACTIVE_TIMING,\n\tDC_H_BLANK_TIMING,\n\tDC_H_SYNC_TIMING,\n\tDC_RSVD_3,\n\n\tDC_V_ACTIVE_TIMING,\n\tDC_V_BLANK_TIMING,\n\tDC_V_SYNC_TIMING,\n\tDC_RSVD_4,\n\n\tDC_CURSOR_X,\n\tDC_CURSOR_Y,\n\tDC_ICON_X,\n\tDC_LINE_CNT,\n\n\tDC_PAL_ADDRESS,\n\tDC_PAL_DATA,\n\tDC_DFIFO_DIAG,\n\tDC_CFIFO_DIAG,\n\n\tDC_VID_DS_DELTA,\n\tDC_GLIU0_MEM_OFFSET,\n\tDC_RSVD_5,\n\tDC_DV_ACC,  \n};\n\n#define DC_UNLOCK_LOCK\t\t\t0x00000000\n#define DC_UNLOCK_UNLOCK\t\t0x00004758\t \n\n#define DC_GENERAL_CFG_YUVM\t\t(1 << 20)\n#define DC_GENERAL_CFG_VDSE\t\t(1 << 19)\n#define DC_GENERAL_CFG_DFHPEL_SHIFT\t12\n#define DC_GENERAL_CFG_DFHPSL_SHIFT\t8\n#define DC_GENERAL_CFG_DECE\t\t(1 << 6)\n#define DC_GENERAL_CFG_CMPE\t\t(1 << 5)\n#define DC_GENERAL_CFG_VIDE\t\t(1 << 3)\n#define DC_GENERAL_CFG_ICNE\t\t(1 << 2)\n#define DC_GENERAL_CFG_CURE\t\t(1 << 1)\n#define DC_GENERAL_CFG_DFLE\t\t(1 << 0)\n\n#define DC_DISPLAY_CFG_A20M\t\t(1 << 31)\n#define DC_DISPLAY_CFG_A18M\t\t(1 << 30)\n#define DC_DISPLAY_CFG_PALB\t\t(1 << 25)\n#define DC_DISPLAY_CFG_DISP_MODE_24BPP\t(1 << 9)\n#define DC_DISPLAY_CFG_DISP_MODE_16BPP\t(1 << 8)\n#define DC_DISPLAY_CFG_DISP_MODE_8BPP\t(0)\n#define DC_DISPLAY_CFG_VDEN\t\t(1 << 4)\n#define DC_DISPLAY_CFG_GDEN\t\t(1 << 3)\n#define DC_DISPLAY_CFG_TGEN\t\t(1 << 0)\n\n\n \nenum vp_registers {\n\tVP_VCFG = 0,\n\tVP_DCFG,\n\n\tVP_VX,\n\tVP_VY,\n\n\tVP_VS,\n\tVP_VCK,\n\n\tVP_VCM,\n\tVP_GAR,\n\n\tVP_GDR,\n\tVP_RSVD_0,\n\n\tVP_MISC,\n\tVP_CCS,\n\n\tVP_RSVD_1,\n\tVP_RSVD_2,\n\n\tVP_RSVD_3,\n\tVP_VDC,\n\n\tVP_VCO,\n\tVP_CRC,\n\n\tVP_CRC32,\n\tVP_VDE,\n\n\tVP_CCK,\n\tVP_CCM,\n\n\tVP_CC1,\n\tVP_CC2,\n\n\tVP_A1X,\n\tVP_A1Y,\n\n\tVP_A1C,\n\tVP_A1T,\n\n\tVP_A2X,\n\tVP_A2Y,\n\n\tVP_A2C,\n\tVP_A2T,\n\n\tVP_A3X,\n\tVP_A3Y,\n\n\tVP_A3C,\n\tVP_A3T,\n\n\tVP_VRR,\n\tVP_AWT,\n\n\tVP_VTM,  \n};\n\n#define VP_VCFG_VID_EN\t\t\t(1 << 0)\n\n#define VP_DCFG_DAC_VREF\t\t(1 << 26)\n#define VP_DCFG_GV_GAM\t\t\t(1 << 21)\n#define VP_DCFG_VG_CK\t\t\t(1 << 20)\n#define VP_DCFG_CRT_SYNC_SKW_DEFAULT\t(1 << 16)\n#define VP_DCFG_CRT_SYNC_SKW\t\t((1 << 14) | (1 << 15) | (1 << 16))\n#define VP_DCFG_CRT_VSYNC_POL\t\t(1 << 9)\n#define VP_DCFG_CRT_HSYNC_POL\t\t(1 << 8)\n#define VP_DCFG_FP_DATA_EN\t\t(1 << 7)\t \n#define VP_DCFG_FP_PWR_EN\t\t(1 << 6)\t \n#define VP_DCFG_DAC_BL_EN\t\t(1 << 3)\n#define VP_DCFG_VSYNC_EN\t\t(1 << 2)\n#define VP_DCFG_HSYNC_EN\t\t(1 << 1)\n#define VP_DCFG_CRT_EN\t\t\t(1 << 0)\n\n#define VP_MISC_GAM_EN\t\t\t(1 << 0)\n#define VP_MISC_DACPWRDN\t\t(1 << 10)\n#define VP_MISC_APWRDN\t\t\t(1 << 11)\n\n\n \n\n \n#define VP_FP_START\t\t0x400\n\nenum fp_registers {\n\tFP_PT1 = 0,\n\tFP_PT2,\n\n\tFP_PM,\n\tFP_DFC,\n\n\tFP_BLFSR,\n\tFP_RLFSR,\n\n\tFP_FMI,\n\tFP_FMD,\n\n\tFP_RSVD_0,\n\tFP_DCA,\n\n\tFP_DMD,\n\tFP_CRC,\n\n\tFP_FBB,  \n};\n\n#define FP_PT1_VSIZE_SHIFT\t\t16\t\t \n#define FP_PT1_VSIZE_MASK\t\t0x7FF0000\t \n\n#define FP_PT2_HSP\t\t\t(1 << 22)\n#define FP_PT2_VSP\t\t\t(1 << 23)\n\n#define FP_PM_P\t\t\t\t(1 << 24)        \n#define FP_PM_PANEL_PWR_UP\t\t(1 << 3)         \n#define FP_PM_PANEL_PWR_DOWN\t\t(1 << 2)         \n#define FP_PM_PANEL_OFF\t\t\t(1 << 1)         \n#define FP_PM_PANEL_ON\t\t\t(1 << 0)         \n\n#define FP_DFC_NFI\t\t\t((1 << 4) | (1 << 5) | (1 << 6))\n\n\n \n\nstatic inline uint32_t read_gp(struct gxfb_par *par, int reg)\n{\n\treturn readl(par->gp_regs + 4*reg);\n}\n\nstatic inline void write_gp(struct gxfb_par *par, int reg, uint32_t val)\n{\n\twritel(val, par->gp_regs + 4*reg);\n}\n\nstatic inline uint32_t read_dc(struct gxfb_par *par, int reg)\n{\n\treturn readl(par->dc_regs + 4*reg);\n}\n\nstatic inline void write_dc(struct gxfb_par *par, int reg, uint32_t val)\n{\n\twritel(val, par->dc_regs + 4*reg);\n}\n\nstatic inline uint32_t read_vp(struct gxfb_par *par, int reg)\n{\n\treturn readl(par->vid_regs + 8*reg);\n}\n\nstatic inline void write_vp(struct gxfb_par *par, int reg, uint32_t val)\n{\n\twritel(val, par->vid_regs + 8*reg);\n}\n\nstatic inline uint32_t read_fp(struct gxfb_par *par, int reg)\n{\n\treturn readl(par->vid_regs + 8*reg + VP_FP_START);\n}\n\nstatic inline void write_fp(struct gxfb_par *par, int reg, uint32_t val)\n{\n\twritel(val, par->vid_regs + 8*reg + VP_FP_START);\n}\n\n\n \n\n#define MSR_GLCP_SYS_RSTPLL_DOTPOSTDIV3\t(1 << 3)\n#define MSR_GLCP_SYS_RSTPLL_DOTPREMULT2\t(1 << 2)\n#define MSR_GLCP_SYS_RSTPLL_DOTPREDIV2\t(1 << 1)\n\n#define MSR_GLCP_DOTPLL_LOCK\t\t(1 << 25)\t \n#define MSR_GLCP_DOTPLL_BYPASS\t\t(1 << 15)\n#define MSR_GLCP_DOTPLL_DOTRESET\t(1 << 0)\n\n#define MSR_GX_MSR_PADSEL_MASK\t\t0x3FFFFFFF\t \n#define MSR_GX_MSR_PADSEL_TFT\t\t0x1FFFFFFF\t \n\n#define MSR_GX_GLD_MSR_CONFIG_FP\t(1 << 3)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}