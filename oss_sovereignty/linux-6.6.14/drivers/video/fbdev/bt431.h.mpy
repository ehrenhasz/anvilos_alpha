{
  "module_name": "bt431.h",
  "hash_id": "eafadbca8dc7e76eeadb0504cdc032b84318c53154a173b34941cc80392116a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/bt431.h",
  "human_readable_source": " \n#include <linux/types.h>\n\n#define BT431_CURSOR_SIZE\t64\n\n \nstruct bt431_regs {\n\tvolatile u16 addr_lo;\n\tu16 pad0;\n\tvolatile u16 addr_hi;\n\tu16 pad1;\n\tvolatile u16 addr_cmap;\n\tu16 pad2;\n\tvolatile u16 addr_reg;\n\tu16 pad3;\n};\n\nstatic inline u16 bt431_set_value(u8 val)\n{\n\treturn ((val << 8) | (val & 0xff)) & 0xffff;\n}\n\nstatic inline u8 bt431_get_value(u16 val)\n{\n\treturn val & 0xff;\n}\n\n \n#define BT431_REG_CMD\t\t0x0000\n#define BT431_REG_CXLO\t\t0x0001\n#define BT431_REG_CXHI\t\t0x0002\n#define BT431_REG_CYLO\t\t0x0003\n#define BT431_REG_CYHI\t\t0x0004\n#define BT431_REG_WXLO\t\t0x0005\n#define BT431_REG_WXHI\t\t0x0006\n#define BT431_REG_WYLO\t\t0x0007\n#define BT431_REG_WYHI\t\t0x0008\n#define BT431_REG_WWLO\t\t0x0009\n#define BT431_REG_WWHI\t\t0x000a\n#define BT431_REG_WHLO\t\t0x000b\n#define BT431_REG_WHHI\t\t0x000c\n\n#define BT431_REG_CRAM_BASE\t0x0000\n#define BT431_REG_CRAM_END\t0x01ff\n\n \n#define BT431_CMD_CURS_ENABLE\t0x40\n#define BT431_CMD_XHAIR_ENABLE\t0x20\n#define BT431_CMD_OR_CURSORS\t0x10\n#define BT431_CMD_XOR_CURSORS\t0x00\n#define BT431_CMD_1_1_MUX\t0x00\n#define BT431_CMD_4_1_MUX\t0x04\n#define BT431_CMD_5_1_MUX\t0x08\n#define BT431_CMD_xxx_MUX\t0x0c\n#define BT431_CMD_THICK_1\t0x00\n#define BT431_CMD_THICK_3\t0x01\n#define BT431_CMD_THICK_5\t0x02\n#define BT431_CMD_THICK_7\t0x03\n\nstatic inline void bt431_select_reg(struct bt431_regs *regs, int ir)\n{\n\t \n\tvolatile u16 *lo = &(regs->addr_lo);\n\tvolatile u16 *hi = &(regs->addr_hi);\n\n\tmb();\n\t*lo = bt431_set_value(ir & 0xff);\n\twmb();\n\t*hi = bt431_set_value((ir >> 8) & 0xff);\n}\n\n \nstatic inline u8 bt431_read_reg_inc(struct bt431_regs *regs)\n{\n\t \n\tvolatile u16 *r = &(regs->addr_reg);\n\n\tmb();\n\treturn bt431_get_value(*r);\n}\n\nstatic inline void bt431_write_reg_inc(struct bt431_regs *regs, u8 value)\n{\n\t \n\tvolatile u16 *r = &(regs->addr_reg);\n\n\tmb();\n\t*r = bt431_set_value(value);\n}\n\nstatic inline u8 bt431_read_reg(struct bt431_regs *regs, int ir)\n{\n\tbt431_select_reg(regs, ir);\n\treturn bt431_read_reg_inc(regs);\n}\n\nstatic inline void bt431_write_reg(struct bt431_regs *regs, int ir, u8 value)\n{\n\tbt431_select_reg(regs, ir);\n\tbt431_write_reg_inc(regs, value);\n}\n\n \nstatic inline u16 bt431_read_cmap_inc(struct bt431_regs *regs)\n{\n\t \n\tvolatile u16 *r = &(regs->addr_cmap);\n\n\tmb();\n\treturn *r;\n}\n\nstatic inline void bt431_write_cmap_inc(struct bt431_regs *regs, u16 value)\n{\n\t \n\tvolatile u16 *r = &(regs->addr_cmap);\n\n\tmb();\n\t*r = value;\n}\n\nstatic inline u16 bt431_read_cmap(struct bt431_regs *regs, int cr)\n{\n\tbt431_select_reg(regs, cr);\n\treturn bt431_read_cmap_inc(regs);\n}\n\nstatic inline void bt431_write_cmap(struct bt431_regs *regs, int cr, u16 value)\n{\n\tbt431_select_reg(regs, cr);\n\tbt431_write_cmap_inc(regs, value);\n}\n\nstatic inline void bt431_enable_cursor(struct bt431_regs *regs)\n{\n\tbt431_write_reg(regs, BT431_REG_CMD,\n\t\t\tBT431_CMD_CURS_ENABLE | BT431_CMD_OR_CURSORS\n\t\t\t| BT431_CMD_4_1_MUX | BT431_CMD_THICK_1);\n}\n\nstatic inline void bt431_erase_cursor(struct bt431_regs *regs)\n{\n\tbt431_write_reg(regs, BT431_REG_CMD, BT431_CMD_4_1_MUX);\n}\n\nstatic inline void bt431_position_cursor(struct bt431_regs *regs, u16 x, u16 y)\n{\n\t \n\tx += 412 - 52;\n\ty += 68 - 32;\n\n\t \n\tbt431_select_reg(regs, BT431_REG_CXLO);\n\tbt431_write_reg_inc(regs, x & 0xff);  \n\tbt431_write_reg_inc(regs, (x >> 8) & 0x0f);  \n\tbt431_write_reg_inc(regs, y & 0xff);  \n\tbt431_write_reg_inc(regs, (y >> 8) & 0x0f);  \n}\n\nstatic inline void bt431_set_cursor(struct bt431_regs *regs,\n\t\t\t\t    const char *data, const char *mask,\n\t\t\t\t    u16 rop, u16 width, u16 height)\n{\n\tu16 x, y;\n\tint i;\n\n\ti = 0;\n\twidth = DIV_ROUND_UP(width, 8);\n\tbt431_select_reg(regs, BT431_REG_CRAM_BASE);\n\tfor (y = 0; y < BT431_CURSOR_SIZE; y++)\n\t\tfor (x = 0; x < BT431_CURSOR_SIZE / 8; x++) {\n\t\t\tu16 val = 0;\n\n\t\t\tif (y < height && x < width) {\n\t\t\t\tval = mask[i];\n\t\t\t\tif (rop == ROP_XOR)\n\t\t\t\t\tval = (val << 8) | (val ^ data[i]);\n\t\t\t\telse\n\t\t\t\t\tval = (val << 8) | (val & data[i]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tbt431_write_cmap_inc(regs, val);\n\t\t}\n}\n\nstatic inline void bt431_init_cursor(struct bt431_regs *regs)\n{\n\t \n\tbt431_select_reg(regs, BT431_REG_WXLO);\n\tbt431_write_reg_inc(regs, 0x00);  \n\tbt431_write_reg_inc(regs, 0x00);  \n\tbt431_write_reg_inc(regs, 0x00);  \n\tbt431_write_reg_inc(regs, 0x00);  \n\tbt431_write_reg_inc(regs, 0x00);  \n\tbt431_write_reg_inc(regs, 0x00);  \n\tbt431_write_reg_inc(regs, 0x00);  \n\tbt431_write_reg_inc(regs, 0x00);  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}