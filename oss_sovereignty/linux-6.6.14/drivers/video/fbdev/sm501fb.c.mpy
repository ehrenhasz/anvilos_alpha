{
  "module_name": "sm501fb.c",
  "hash_id": "b08ba2cf39433dfd587f472200a617f53e48c60e3b5f71aac4d24da714d36908",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/sm501fb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/tty.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/io.h>\n\n#include <linux/uaccess.h>\n#include <asm/div64.h>\n\n#ifdef CONFIG_PM\n#include <linux/pm.h>\n#endif\n\n#include <linux/sm501.h>\n#include <linux/sm501-regs.h>\n\n#include \"edid.h\"\n\nstatic char *fb_mode = \"640x480-16@60\";\nstatic unsigned long default_bpp = 16;\n\nstatic const struct fb_videomode sm501_default_mode = {\n\t.refresh\t= 60,\n\t.xres\t\t= 640,\n\t.yres\t\t= 480,\n\t.pixclock\t= 20833,\n\t.left_margin\t= 142,\n\t.right_margin\t= 13,\n\t.upper_margin\t= 21,\n\t.lower_margin\t= 1,\n\t.hsync_len\t= 69,\n\t.vsync_len\t= 3,\n\t.sync\t\t= FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED\n};\n\n#define NR_PALETTE\t256\n\nenum sm501_controller {\n\tHEAD_CRT\t= 0,\n\tHEAD_PANEL\t= 1,\n};\n\n \nstruct sm501_mem {\n\tunsigned long\t size;\n\tunsigned long\t sm_addr;\t \n\tvoid __iomem\t*k_addr;\n};\n\n \nstruct sm501fb_info {\n\tstruct device\t\t*dev;\n\tstruct fb_info\t\t*fb[2];\t\t \n\tstruct resource\t\t*fbmem_res;\t \n\tstruct resource\t\t*regs_res;\t \n\tstruct resource\t\t*regs2d_res;\t \n\tstruct sm501_platdata_fb *pdata;\t \n\n\tunsigned long\t\t pm_crt_ctrl;\t \n\n\tint\t\t\t irq;\n\tint\t\t\t swap_endian;\t \n\tvoid __iomem\t\t*regs;\t\t \n\tvoid __iomem\t\t*regs2d;\t \n\tvoid __iomem\t\t*fbmem;\t\t \n\tsize_t\t\t\t fbmem_len;\t \n\tu8 *edid_data;\n};\n\n \nstruct sm501fb_par {\n\tu32\t\t\t pseudo_palette[16];\n\n\tenum sm501_controller\t head;\n\tstruct sm501_mem\t cursor;\n\tstruct sm501_mem\t screen;\n\tstruct fb_ops\t\t ops;\n\n\tvoid\t\t\t*store_fb;\n\tvoid\t\t\t*store_cursor;\n\tvoid __iomem\t\t*cursor_regs;\n\tstruct sm501fb_info\t*info;\n};\n\n \n\nstatic inline int h_total(struct fb_var_screeninfo *var)\n{\n\treturn var->xres + var->left_margin +\n\t\tvar->right_margin + var->hsync_len;\n}\n\nstatic inline int v_total(struct fb_var_screeninfo *var)\n{\n\treturn var->yres + var->upper_margin +\n\t\tvar->lower_margin + var->vsync_len;\n}\n\n \n\nstatic inline void sm501fb_sync_regs(struct sm501fb_info *info)\n{\n\tsmc501_readl(info->regs);\n}\n\n \n\n#define SM501_MEMF_CURSOR\t\t(1)\n#define SM501_MEMF_PANEL\t\t(2)\n#define SM501_MEMF_CRT\t\t\t(4)\n#define SM501_MEMF_ACCEL\t\t(8)\n\nstatic int sm501_alloc_mem(struct sm501fb_info *inf, struct sm501_mem *mem,\n\t\t\t   unsigned int why, size_t size, u32 smem_len)\n{\n\tstruct sm501fb_par *par;\n\tstruct fb_info *fbi;\n\tunsigned int ptr;\n\tunsigned int end;\n\n\tswitch (why) {\n\tcase SM501_MEMF_CURSOR:\n\t\tptr = inf->fbmem_len - size;\n\t\tinf->fbmem_len = ptr;\t \n\t\tbreak;\n\n\tcase SM501_MEMF_PANEL:\n\t\tif (size > inf->fbmem_len)\n\t\t\treturn -ENOMEM;\n\n\t\tptr = inf->fbmem_len - size;\n\t\tfbi = inf->fb[HEAD_CRT];\n\n\t\t \n\n\t\tif (ptr > 0)\n\t\t\tptr &= ~(PAGE_SIZE - 1);\n\n\t\tif (fbi && ptr < smem_len)\n\t\t\treturn -ENOMEM;\n\n\t\tbreak;\n\n\tcase SM501_MEMF_CRT:\n\t\tptr = 0;\n\n\t\t \n\n\t\tfbi = inf->fb[HEAD_PANEL];\n\t\tif (fbi) {\n\t\t\tpar = fbi->par;\n\t\t\tend = par->screen.k_addr ? par->screen.sm_addr : inf->fbmem_len;\n\t\t} else\n\t\t\tend = inf->fbmem_len;\n\n\t\tif ((ptr + size) > end)\n\t\t\treturn -ENOMEM;\n\n\t\tbreak;\n\n\tcase SM501_MEMF_ACCEL:\n\t\tfbi = inf->fb[HEAD_CRT];\n\t\tptr = fbi ? smem_len : 0;\n\n\t\tfbi = inf->fb[HEAD_PANEL];\n\t\tif (fbi) {\n\t\t\tpar = fbi->par;\n\t\t\tend = par->screen.sm_addr;\n\t\t} else\n\t\t\tend = inf->fbmem_len;\n\n\t\tif ((ptr + size) > end)\n\t\t\treturn -ENOMEM;\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmem->size    = size;\n\tmem->sm_addr = ptr;\n\tmem->k_addr  = inf->fbmem + ptr;\n\n\tdev_dbg(inf->dev, \"%s: result %08lx, %p - %u, %zd\\n\",\n\t\t__func__, mem->sm_addr, mem->k_addr, why, size);\n\n\treturn 0;\n}\n\n \n\nstatic unsigned long sm501fb_ps_to_hz(unsigned long psvalue)\n{\n\tunsigned long long numerator=1000000000000ULL;\n\n\t \n\tdo_div(numerator, psvalue);\n\treturn (unsigned long)numerator;\n}\n\n \n\n#define sm501fb_hz_to_ps(x) sm501fb_ps_to_hz(x)\n\n \n\nstatic void sm501fb_setup_gamma(struct sm501fb_info *fbi,\n\t\t\t\tunsigned long palette)\n{\n\tunsigned long value = 0;\n\tint offset;\n\n\t \n\tfor (offset = 0; offset < 256 * 4; offset += 4) {\n\t\tsmc501_writel(value, fbi->regs + palette + offset);\n\t\tvalue += 0x010101; \t \n\t}\n}\n\n \n\nstatic int sm501fb_check_var(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *sm  = par->info;\n\tunsigned long tmp;\n\n\t \n\n\tif (var->hsync_len > 255 || var->vsync_len > 63)\n\t\treturn -EINVAL;\n\n\t \n\tif ((var->xres + var->right_margin) > 4096)\n\t\treturn -EINVAL;\n\n\t \n\tif ((var->yres + var->lower_margin) > 2048)\n\t\treturn -EINVAL;\n\n\t \n\n\tif (h_total(var) > 4096 || v_total(var) > 2048)\n\t\treturn -EINVAL;\n\n\t \n\n\ttmp = (var->xres * var->bits_per_pixel) / 8;\n\tif ((tmp & 15) != 0)\n\t\treturn -EINVAL;\n\n\t \n\n\tif (var->xres_virtual > 4096 || var->yres_virtual > 2048)\n\t\treturn -EINVAL;\n\n\t \n\n\tif (var->bits_per_pixel <= 8)\n\t\tvar->bits_per_pixel = 8;\n\telse if (var->bits_per_pixel <= 16)\n\t\tvar->bits_per_pixel = 16;\n\telse if (var->bits_per_pixel == 24)\n\t\tvar->bits_per_pixel = 32;\n\n\t \n\tswitch(var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.length\t\t= var->bits_per_pixel;\n\t\tvar->red.offset\t\t= 0;\n\t\tvar->green.length\t= var->bits_per_pixel;\n\t\tvar->green.offset\t= 0;\n\t\tvar->blue.length\t= var->bits_per_pixel;\n\t\tvar->blue.offset\t= 0;\n\t\tvar->transp.length\t= 0;\n\t\tvar->transp.offset\t= 0;\n\n\t\tbreak;\n\n\tcase 16:\n\t\tif (sm->pdata->flags & SM501_FBPD_SWAP_FB_ENDIAN) {\n\t\t\tvar->blue.offset\t= 11;\n\t\t\tvar->green.offset\t= 5;\n\t\t\tvar->red.offset\t\t= 0;\n\t\t} else {\n\t\t\tvar->red.offset\t\t= 11;\n\t\t\tvar->green.offset\t= 5;\n\t\t\tvar->blue.offset\t= 0;\n\t\t}\n\t\tvar->transp.offset\t= 0;\n\n\t\tvar->red.length\t\t= 5;\n\t\tvar->green.length\t= 6;\n\t\tvar->blue.length\t= 5;\n\t\tvar->transp.length\t= 0;\n\t\tbreak;\n\n\tcase 32:\n\t\tif (sm->pdata->flags & SM501_FBPD_SWAP_FB_ENDIAN) {\n\t\t\tvar->transp.offset\t= 0;\n\t\t\tvar->red.offset\t\t= 8;\n\t\t\tvar->green.offset\t= 16;\n\t\t\tvar->blue.offset\t= 24;\n\t\t} else {\n\t\t\tvar->transp.offset\t= 24;\n\t\t\tvar->red.offset\t\t= 16;\n\t\t\tvar->green.offset\t= 8;\n\t\t\tvar->blue.offset\t= 0;\n\t\t}\n\n\t\tvar->red.length\t\t= 8;\n\t\tvar->green.length\t= 8;\n\t\tvar->blue.length\t= 8;\n\t\tvar->transp.length\t= 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int sm501fb_check_var_crt(struct fb_var_screeninfo *var,\n\t\t\t\t struct fb_info *info)\n{\n\treturn sm501fb_check_var(var, info);\n}\n\n \n\nstatic int sm501fb_check_var_pnl(struct fb_var_screeninfo *var,\n\t\t\t\t struct fb_info *info)\n{\n\treturn sm501fb_check_var(var, info);\n}\n\n \n\nstatic int sm501fb_set_par_common(struct fb_info *info,\n\t\t\t\t  struct fb_var_screeninfo *var)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\tunsigned long pixclock;       \n\tunsigned long sm501pixclock;  \n\tunsigned int mem_type;\n\tunsigned int clock_type;\n\tunsigned int head_addr;\n\tunsigned int smem_len;\n\n\tdev_dbg(fbi->dev, \"%s: %dx%d, bpp = %d, virtual %dx%d\\n\",\n\t\t__func__, var->xres, var->yres, var->bits_per_pixel,\n\t\tvar->xres_virtual, var->yres_virtual);\n\n\tswitch (par->head) {\n\tcase HEAD_CRT:\n\t\tmem_type = SM501_MEMF_CRT;\n\t\tclock_type = SM501_CLOCK_V2XCLK;\n\t\thead_addr = SM501_DC_CRT_FB_ADDR;\n\t\tbreak;\n\n\tcase HEAD_PANEL:\n\t\tmem_type = SM501_MEMF_PANEL;\n\t\tclock_type = SM501_CLOCK_P2XCLK;\n\t\thead_addr = SM501_DC_PANEL_FB_ADDR;\n\t\tbreak;\n\n\tdefault:\n\t\tmem_type = 0;\t\t \n\t\thead_addr = 0;\n\t\tclock_type = 0;\n\t}\n\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\n\tcase 16:\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\n\tcase 32:\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\t}\n\n\t \n\tinfo->fix.line_length = (var->xres_virtual * var->bits_per_pixel)/8;\n\tsmem_len = info->fix.line_length * var->yres_virtual;\n\n\tdev_dbg(fbi->dev, \"%s: line length = %u\\n\", __func__,\n\t\tinfo->fix.line_length);\n\n\tif (sm501_alloc_mem(fbi, &par->screen, mem_type, smem_len, smem_len)) {\n\t\tdev_err(fbi->dev, \"no memory available\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&info->mm_lock);\n\tinfo->fix.smem_start = fbi->fbmem_res->start + par->screen.sm_addr;\n\tinfo->fix.smem_len   = smem_len;\n\tmutex_unlock(&info->mm_lock);\n\n\tinfo->screen_base = fbi->fbmem + par->screen.sm_addr;\n\tinfo->screen_size = info->fix.smem_len;\n\n\t \n\n\tsmc501_writel(par->screen.sm_addr | SM501_ADDR_FLIP,\n\t\t\tfbi->regs + head_addr);\n\n\t \n\n\tpixclock = sm501fb_ps_to_hz(var->pixclock);\n\n\tsm501pixclock = sm501_set_clock(fbi->dev->parent, clock_type,\n\t\t\t\t\tpixclock);\n\n\t \n\tvar->pixclock = sm501fb_hz_to_ps(sm501pixclock);\n\n\tdev_dbg(fbi->dev, \"%s: pixclock(ps) = %u, pixclock(Hz)  = %lu, \"\n\t       \"sm501pixclock = %lu,  error = %ld%%\\n\",\n\t       __func__, var->pixclock, pixclock, sm501pixclock,\n\t       ((pixclock - sm501pixclock)*100)/pixclock);\n\n\treturn 0;\n}\n\n \n\nstatic void sm501fb_set_par_geometry(struct fb_info *info,\n\t\t\t\t     struct fb_var_screeninfo *var)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\tvoid __iomem *base = fbi->regs;\n\tunsigned long reg;\n\n\tif (par->head == HEAD_CRT)\n\t\tbase += SM501_DC_CRT_H_TOT;\n\telse\n\t\tbase += SM501_DC_PANEL_H_TOT;\n\n\t \n\n\treg = info->fix.line_length;\n\treg |= ((var->xres * var->bits_per_pixel)/8) << 16;\n\n\tsmc501_writel(reg, fbi->regs + (par->head == HEAD_CRT ?\n\t\t    SM501_DC_CRT_FB_OFFSET :  SM501_DC_PANEL_FB_OFFSET));\n\n\t \n\n\treg  = (h_total(var) - 1) << 16;\n\treg |= (var->xres - 1);\n\n\tsmc501_writel(reg, base + SM501_OFF_DC_H_TOT);\n\n\t \n\n\treg  = var->hsync_len << 16;\n\treg |= var->xres + var->right_margin - 1;\n\n\tsmc501_writel(reg, base + SM501_OFF_DC_H_SYNC);\n\n\t \n\n\treg  = (v_total(var) - 1) << 16;\n\treg |= (var->yres - 1);\n\n\tsmc501_writel(reg, base + SM501_OFF_DC_V_TOT);\n\n\t \n\treg  = var->vsync_len << 16;\n\treg |= var->yres + var->lower_margin - 1;\n\n\tsmc501_writel(reg, base + SM501_OFF_DC_V_SYNC);\n}\n\n \n\nstatic int sm501fb_pan_crt(struct fb_var_screeninfo *var,\n\t\t\t   struct fb_info *info)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\tunsigned int bytes_pixel = info->var.bits_per_pixel / 8;\n\tunsigned long reg;\n\tunsigned long xoffs;\n\n\txoffs = var->xoffset * bytes_pixel;\n\n\treg = smc501_readl(fbi->regs + SM501_DC_CRT_CONTROL);\n\n\treg &= ~SM501_DC_CRT_CONTROL_PIXEL_MASK;\n\treg |= ((xoffs & 15) / bytes_pixel) << 4;\n\tsmc501_writel(reg, fbi->regs + SM501_DC_CRT_CONTROL);\n\n\treg = (par->screen.sm_addr + xoffs +\n\t       var->yoffset * info->fix.line_length);\n\tsmc501_writel(reg | SM501_ADDR_FLIP, fbi->regs + SM501_DC_CRT_FB_ADDR);\n\n\tsm501fb_sync_regs(fbi);\n\treturn 0;\n}\n\n \n\nstatic int sm501fb_pan_pnl(struct fb_var_screeninfo *var,\n\t\t\t   struct fb_info *info)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\tunsigned long reg;\n\n\treg = var->xoffset | (info->var.xres_virtual << 16);\n\tsmc501_writel(reg, fbi->regs + SM501_DC_PANEL_FB_WIDTH);\n\n\treg = var->yoffset | (info->var.yres_virtual << 16);\n\tsmc501_writel(reg, fbi->regs + SM501_DC_PANEL_FB_HEIGHT);\n\n\tsm501fb_sync_regs(fbi);\n\treturn 0;\n}\n\n \n\nstatic int sm501fb_set_par_crt(struct fb_info *info)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tunsigned long control;        \n\tint ret;\n\n\t \n\n\tdev_dbg(fbi->dev, \"%s(%p)\\n\", __func__, info);\n\n\t \n\tsm501_misc_control(fbi->dev->parent, 0, SM501_MISC_DAC_POWER);\n\n\tcontrol = smc501_readl(fbi->regs + SM501_DC_CRT_CONTROL);\n\n\tcontrol &= (SM501_DC_CRT_CONTROL_PIXEL_MASK |\n\t\t    SM501_DC_CRT_CONTROL_GAMMA |\n\t\t    SM501_DC_CRT_CONTROL_BLANK |\n\t\t    SM501_DC_CRT_CONTROL_SEL |\n\t\t    SM501_DC_CRT_CONTROL_CP |\n\t\t    SM501_DC_CRT_CONTROL_TVP);\n\n\t \n\n\tif ((var->sync & FB_SYNC_HOR_HIGH_ACT) == 0)\n\t\tcontrol |= SM501_DC_CRT_CONTROL_HSP;\n\n\tif ((var->sync & FB_SYNC_VERT_HIGH_ACT) == 0)\n\t\tcontrol |= SM501_DC_CRT_CONTROL_VSP;\n\n\tif ((control & SM501_DC_CRT_CONTROL_SEL) == 0) {\n\t\t \n\n\t\tsm501_alloc_mem(fbi, &par->screen, SM501_MEMF_CRT, 0,\n\t\t\t\tinfo->fix.smem_len);\n\t\tgoto out_update;\n\t}\n\n\tret = sm501fb_set_par_common(info, var);\n\tif (ret) {\n\t\tdev_err(fbi->dev, \"failed to set common parameters\\n\");\n\t\treturn ret;\n\t}\n\n\tsm501fb_pan_crt(var, info);\n\tsm501fb_set_par_geometry(info, var);\n\n\tcontrol |= SM501_FIFO_3;\t \n\n\tswitch(var->bits_per_pixel) {\n\tcase 8:\n\t\tcontrol |= SM501_DC_CRT_CONTROL_8BPP;\n\t\tbreak;\n\n\tcase 16:\n\t\tcontrol |= SM501_DC_CRT_CONTROL_16BPP;\n\t\tsm501fb_setup_gamma(fbi, SM501_DC_CRT_PALETTE);\n\t\tbreak;\n\n\tcase 32:\n\t\tcontrol |= SM501_DC_CRT_CONTROL_32BPP;\n\t\tsm501fb_setup_gamma(fbi, SM501_DC_CRT_PALETTE);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\tcontrol |= SM501_DC_CRT_CONTROL_SEL;\t \n\tcontrol |= SM501_DC_CRT_CONTROL_TE;\t \n\tcontrol |= SM501_DC_CRT_CONTROL_ENABLE;\t \n\n out_update:\n\tdev_dbg(fbi->dev, \"new control is %08lx\\n\", control);\n\n\tsmc501_writel(control, fbi->regs + SM501_DC_CRT_CONTROL);\n\tsm501fb_sync_regs(fbi);\n\n\treturn 0;\n}\n\nstatic void sm501fb_panel_power(struct sm501fb_info *fbi, int to)\n{\n\tunsigned long control;\n\tvoid __iomem *ctrl_reg = fbi->regs + SM501_DC_PANEL_CONTROL;\n\tstruct sm501_platdata_fbsub *pd = fbi->pdata->fb_pnl;\n\n\tcontrol = smc501_readl(ctrl_reg);\n\n\tif (to && (control & SM501_DC_PANEL_CONTROL_VDD) == 0) {\n\t\t \n\n\t\tcontrol |= SM501_DC_PANEL_CONTROL_VDD;\t \n\t\tsmc501_writel(control, ctrl_reg);\n\t\tsm501fb_sync_regs(fbi);\n\t\tmdelay(10);\n\n\t\tcontrol |= SM501_DC_PANEL_CONTROL_DATA;\t \n\t\tsmc501_writel(control, ctrl_reg);\n\t\tsm501fb_sync_regs(fbi);\n\t\tmdelay(10);\n\n\t\t \n\n\t\tif (!(pd->flags & SM501FB_FLAG_PANEL_NO_VBIASEN)) {\n\t\t\tif (pd->flags & SM501FB_FLAG_PANEL_INV_VBIASEN)\n\t\t\t\tcontrol &= ~SM501_DC_PANEL_CONTROL_BIAS;\n\t\t\telse\n\t\t\t\tcontrol |= SM501_DC_PANEL_CONTROL_BIAS;\n\n\t\t\tsmc501_writel(control, ctrl_reg);\n\t\t\tsm501fb_sync_regs(fbi);\n\t\t\tmdelay(10);\n\t\t}\n\n\t\tif (!(pd->flags & SM501FB_FLAG_PANEL_NO_FPEN)) {\n\t\t\tif (pd->flags & SM501FB_FLAG_PANEL_INV_FPEN)\n\t\t\t\tcontrol &= ~SM501_DC_PANEL_CONTROL_FPEN;\n\t\t\telse\n\t\t\t\tcontrol |= SM501_DC_PANEL_CONTROL_FPEN;\n\n\t\t\tsmc501_writel(control, ctrl_reg);\n\t\t\tsm501fb_sync_regs(fbi);\n\t\t\tmdelay(10);\n\t\t}\n\t} else if (!to && (control & SM501_DC_PANEL_CONTROL_VDD) != 0) {\n\t\t \n\t\tif (!(pd->flags & SM501FB_FLAG_PANEL_NO_FPEN)) {\n\t\t\tif (pd->flags & SM501FB_FLAG_PANEL_INV_FPEN)\n\t\t\t\tcontrol |= SM501_DC_PANEL_CONTROL_FPEN;\n\t\t\telse\n\t\t\t\tcontrol &= ~SM501_DC_PANEL_CONTROL_FPEN;\n\n\t\t\tsmc501_writel(control, ctrl_reg);\n\t\t\tsm501fb_sync_regs(fbi);\n\t\t\tmdelay(10);\n\t\t}\n\n\t\tif (!(pd->flags & SM501FB_FLAG_PANEL_NO_VBIASEN)) {\n\t\t\tif (pd->flags & SM501FB_FLAG_PANEL_INV_VBIASEN)\n\t\t\t\tcontrol |= SM501_DC_PANEL_CONTROL_BIAS;\n\t\t\telse\n\t\t\t\tcontrol &= ~SM501_DC_PANEL_CONTROL_BIAS;\n\n\t\t\tsmc501_writel(control, ctrl_reg);\n\t\t\tsm501fb_sync_regs(fbi);\n\t\t\tmdelay(10);\n\t\t}\n\n\t\tcontrol &= ~SM501_DC_PANEL_CONTROL_DATA;\n\t\tsmc501_writel(control, ctrl_reg);\n\t\tsm501fb_sync_regs(fbi);\n\t\tmdelay(10);\n\n\t\tcontrol &= ~SM501_DC_PANEL_CONTROL_VDD;\n\t\tsmc501_writel(control, ctrl_reg);\n\t\tsm501fb_sync_regs(fbi);\n\t\tmdelay(10);\n\t}\n\n\tsm501fb_sync_regs(fbi);\n}\n\n \n\nstatic int sm501fb_set_par_pnl(struct fb_info *info)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tunsigned long control;\n\tunsigned long reg;\n\tint ret;\n\n\tdev_dbg(fbi->dev, \"%s(%p)\\n\", __func__, info);\n\n\t \n\n\tret = sm501fb_set_par_common(info, var);\n\tif (ret)\n\t\treturn ret;\n\n\tsm501fb_pan_pnl(var, info);\n\tsm501fb_set_par_geometry(info, var);\n\n\t \n\n\tcontrol = smc501_readl(fbi->regs + SM501_DC_PANEL_CONTROL);\n\tcontrol &= (SM501_DC_PANEL_CONTROL_GAMMA |\n\t\t    SM501_DC_PANEL_CONTROL_VDD  |\n\t\t    SM501_DC_PANEL_CONTROL_DATA |\n\t\t    SM501_DC_PANEL_CONTROL_BIAS |\n\t\t    SM501_DC_PANEL_CONTROL_FPEN |\n\t\t    SM501_DC_PANEL_CONTROL_CP |\n\t\t    SM501_DC_PANEL_CONTROL_CK |\n\t\t    SM501_DC_PANEL_CONTROL_HP |\n\t\t    SM501_DC_PANEL_CONTROL_VP |\n\t\t    SM501_DC_PANEL_CONTROL_HPD |\n\t\t    SM501_DC_PANEL_CONTROL_VPD);\n\n\tcontrol |= SM501_FIFO_3;\t \n\n\tswitch(var->bits_per_pixel) {\n\tcase 8:\n\t\tcontrol |= SM501_DC_PANEL_CONTROL_8BPP;\n\t\tbreak;\n\n\tcase 16:\n\t\tcontrol |= SM501_DC_PANEL_CONTROL_16BPP;\n\t\tsm501fb_setup_gamma(fbi, SM501_DC_PANEL_PALETTE);\n\t\tbreak;\n\n\tcase 32:\n\t\tcontrol |= SM501_DC_PANEL_CONTROL_32BPP;\n\t\tsm501fb_setup_gamma(fbi, SM501_DC_PANEL_PALETTE);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsmc501_writel(0x0, fbi->regs + SM501_DC_PANEL_PANNING_CONTROL);\n\n\t \n\n\tsmc501_writel(0x00, fbi->regs + SM501_DC_PANEL_TL_LOC);\n\n\treg  = var->xres - 1;\n\treg |= (var->yres - 1) << 16;\n\n\tsmc501_writel(reg, fbi->regs + SM501_DC_PANEL_BR_LOC);\n\n\t \n\n\tcontrol |= SM501_DC_PANEL_CONTROL_TE;\t \n\tcontrol |= SM501_DC_PANEL_CONTROL_EN;\t \n\n\tif ((var->sync & FB_SYNC_HOR_HIGH_ACT) == 0)\n\t\tcontrol |= SM501_DC_PANEL_CONTROL_HSP;\n\n\tif ((var->sync & FB_SYNC_VERT_HIGH_ACT) == 0)\n\t\tcontrol |= SM501_DC_PANEL_CONTROL_VSP;\n\n\tsmc501_writel(control, fbi->regs + SM501_DC_PANEL_CONTROL);\n\tsm501fb_sync_regs(fbi);\n\n\t \n\n\tsm501_modify_reg(fbi->dev->parent, SM501_SYSTEM_CONTROL,\n\t\t\t 0, SM501_SYSCTRL_PANEL_TRISTATE);\n\n\t \n\tsm501fb_panel_power(fbi, 1);\n\treturn 0;\n}\n\n\n \n\nstatic inline unsigned int chan_to_field(unsigned int chan,\n\t\t\t\t\t struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\n \n\nstatic int sm501fb_setcolreg(unsigned regno,\n\t\t\t     unsigned red, unsigned green, unsigned blue,\n\t\t\t     unsigned transp, struct fb_info *info)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\tvoid __iomem *base = fbi->regs;\n\tunsigned int val;\n\n\tif (par->head == HEAD_CRT)\n\t\tbase += SM501_DC_CRT_PALETTE;\n\telse\n\t\tbase += SM501_DC_PANEL_PALETTE;\n\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\t \n\n\t\tif (regno < 16) {\n\t\t\tu32 *pal = par->pseudo_palette;\n\n\t\t\tval  = chan_to_field(red,   &info->var.red);\n\t\t\tval |= chan_to_field(green, &info->var.green);\n\t\t\tval |= chan_to_field(blue,  &info->var.blue);\n\n\t\t\tpal[regno] = val;\n\t\t}\n\t\tbreak;\n\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tif (regno < 256) {\n\t\t\tval = (red >> 8) << 16;\n\t\t\tval |= (green >> 8) << 8;\n\t\t\tval |= blue >> 8;\n\n\t\t\tsmc501_writel(val, base + (regno * 4));\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn 1;    \n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int sm501fb_blank_pnl(int blank_mode, struct fb_info *info)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\n\tdev_dbg(fbi->dev, \"%s(mode=%d, %p)\\n\", __func__, blank_mode, info);\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_POWERDOWN:\n\t\tsm501fb_panel_power(fbi, 0);\n\t\tbreak;\n\n\tcase FB_BLANK_UNBLANK:\n\t\tsm501fb_panel_power(fbi, 1);\n\t\tbreak;\n\n\tcase FB_BLANK_NORMAL:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int sm501fb_blank_crt(int blank_mode, struct fb_info *info)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\tunsigned long ctrl;\n\n\tdev_dbg(fbi->dev, \"%s(mode=%d, %p)\\n\", __func__, blank_mode, info);\n\n\tctrl = smc501_readl(fbi->regs + SM501_DC_CRT_CONTROL);\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_POWERDOWN:\n\t\tctrl &= ~SM501_DC_CRT_CONTROL_ENABLE;\n\t\tsm501_misc_control(fbi->dev->parent, SM501_MISC_DAC_POWER, 0);\n\t\tfallthrough;\n\n\tcase FB_BLANK_NORMAL:\n\t\tctrl |= SM501_DC_CRT_CONTROL_BLANK;\n\t\tbreak;\n\n\tcase FB_BLANK_UNBLANK:\n\t\tctrl &= ~SM501_DC_CRT_CONTROL_BLANK;\n\t\tctrl |=  SM501_DC_CRT_CONTROL_ENABLE;\n\t\tsm501_misc_control(fbi->dev->parent, 0, SM501_MISC_DAC_POWER);\n\t\tbreak;\n\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tdefault:\n\t\treturn 1;\n\n\t}\n\n\tsmc501_writel(ctrl, fbi->regs + SM501_DC_CRT_CONTROL);\n\tsm501fb_sync_regs(fbi);\n\n\treturn 0;\n}\n\n \n\nstatic int sm501fb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\tvoid __iomem *base = fbi->regs;\n\tunsigned long hwc_addr;\n\tunsigned long fg, bg;\n\n\tdev_dbg(fbi->dev, \"%s(%p,%p)\\n\", __func__, info, cursor);\n\n\tif (par->head == HEAD_CRT)\n\t\tbase += SM501_DC_CRT_HWC_BASE;\n\telse\n\t\tbase += SM501_DC_PANEL_HWC_BASE;\n\n\t \n\n\tif (cursor->image.width > 64)\n\t\treturn -EINVAL;\n\n\tif (cursor->image.height > 64)\n\t\treturn -EINVAL;\n\n\tif (cursor->image.depth > 1)\n\t\treturn -EINVAL;\n\n\thwc_addr = smc501_readl(base + SM501_OFF_HWC_ADDR);\n\n\tif (cursor->enable)\n\t\tsmc501_writel(hwc_addr | SM501_HWC_EN,\n\t\t\t\tbase + SM501_OFF_HWC_ADDR);\n\telse\n\t\tsmc501_writel(hwc_addr & ~SM501_HWC_EN,\n\t\t\t\tbase + SM501_OFF_HWC_ADDR);\n\n\t \n\tif (cursor->set & FB_CUR_SETPOS) {\n\t\tunsigned int x = cursor->image.dx;\n\t\tunsigned int y = cursor->image.dy;\n\n\t\tif (x >= 2048 || y >= 2048 )\n\t\t\treturn -EINVAL;\n\n\t\tdev_dbg(fbi->dev, \"set position %d,%d\\n\", x, y);\n\n\t\t\n\n\t\tsmc501_writel(x | (y << 16), base + SM501_OFF_HWC_LOC);\n\t}\n\n\tif (cursor->set & FB_CUR_SETCMAP) {\n\t\tunsigned int bg_col = cursor->image.bg_color;\n\t\tunsigned int fg_col = cursor->image.fg_color;\n\n\t\tdev_dbg(fbi->dev, \"%s: update cmap (%08x,%08x)\\n\",\n\t\t\t__func__, bg_col, fg_col);\n\n\t\tbg = ((info->cmap.red[bg_col] & 0xF8) << 8) |\n\t\t\t((info->cmap.green[bg_col] & 0xFC) << 3) |\n\t\t\t((info->cmap.blue[bg_col] & 0xF8) >> 3);\n\n\t\tfg = ((info->cmap.red[fg_col] & 0xF8) << 8) |\n\t\t\t((info->cmap.green[fg_col] & 0xFC) << 3) |\n\t\t\t((info->cmap.blue[fg_col] & 0xF8) >> 3);\n\n\t\tdev_dbg(fbi->dev, \"fgcol %08lx, bgcol %08lx\\n\", fg, bg);\n\n\t\tsmc501_writel(bg, base + SM501_OFF_HWC_COLOR_1_2);\n\t\tsmc501_writel(fg, base + SM501_OFF_HWC_COLOR_3);\n\t}\n\n\tif (cursor->set & FB_CUR_SETSIZE ||\n\t    cursor->set & (FB_CUR_SETIMAGE | FB_CUR_SETSHAPE)) {\n\t\t \n\t\tint x, y;\n\t\tconst unsigned char *pcol = cursor->image.data;\n\t\tconst unsigned char *pmsk = cursor->mask;\n\t\tvoid __iomem   *dst = par->cursor.k_addr;\n\t\tunsigned char  dcol = 0;\n\t\tunsigned char  dmsk = 0;\n\t\tunsigned int   op;\n\n\t\tdev_dbg(fbi->dev, \"%s: setting shape (%d,%d)\\n\",\n\t\t\t__func__, cursor->image.width, cursor->image.height);\n\n\t\tfor (op = 0; op < (64*64*2)/8; op+=4)\n\t\t\tsmc501_writel(0x0, dst + op);\n\n\t\tfor (y = 0; y < cursor->image.height; y++) {\n\t\t\tfor (x = 0; x < cursor->image.width; x++) {\n\t\t\t\tif ((x % 8) == 0) {\n\t\t\t\t\tdcol = *pcol++;\n\t\t\t\t\tdmsk = *pmsk++;\n\t\t\t\t} else {\n\t\t\t\t\tdcol >>= 1;\n\t\t\t\t\tdmsk >>= 1;\n\t\t\t\t}\n\n\t\t\t\tif (dmsk & 1) {\n\t\t\t\t\top = (dcol & 1) ? 1 : 3;\n\t\t\t\t\top <<= ((x % 4) * 2);\n\n\t\t\t\t\top |= readb(dst + (x / 4));\n\t\t\t\t\twriteb(op, dst + (x / 4));\n\t\t\t\t}\n\t\t\t}\n\t\t\tdst += (64*2)/8;\n\t\t}\n\t}\n\n\tsm501fb_sync_regs(fbi);\t \n\treturn 0;\n}\n\n \n\nstatic ssize_t sm501fb_crtsrc_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct sm501fb_info *info = dev_get_drvdata(dev);\n\tunsigned long ctrl;\n\n\tctrl = smc501_readl(info->regs + SM501_DC_CRT_CONTROL);\n\tctrl &= SM501_DC_CRT_CONTROL_SEL;\n\n\treturn sysfs_emit(buf, \"%s\\n\", ctrl ? \"crt\" : \"panel\");\n}\n\n \n\nstatic ssize_t sm501fb_crtsrc_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct sm501fb_info *info = dev_get_drvdata(dev);\n\tenum sm501_controller head;\n\tunsigned long ctrl;\n\n\tif (len < 1)\n\t\treturn -EINVAL;\n\n\tif (strncasecmp(buf, \"crt\", 3) == 0)\n\t\thead = HEAD_CRT;\n\telse if (strncasecmp(buf, \"panel\", 5) == 0)\n\t\thead = HEAD_PANEL;\n\telse\n\t\treturn -EINVAL;\n\n\tdev_info(dev, \"setting crt source to head %d\\n\", head);\n\n\tctrl = smc501_readl(info->regs + SM501_DC_CRT_CONTROL);\n\n\tif (head == HEAD_CRT) {\n\t\tctrl |= SM501_DC_CRT_CONTROL_SEL;\n\t\tctrl |= SM501_DC_CRT_CONTROL_ENABLE;\n\t\tctrl |= SM501_DC_CRT_CONTROL_TE;\n\t} else {\n\t\tctrl &= ~SM501_DC_CRT_CONTROL_SEL;\n\t\tctrl &= ~SM501_DC_CRT_CONTROL_ENABLE;\n\t\tctrl &= ~SM501_DC_CRT_CONTROL_TE;\n\t}\n\n\tsmc501_writel(ctrl, info->regs + SM501_DC_CRT_CONTROL);\n\tsm501fb_sync_regs(info);\n\n\treturn len;\n}\n\n \nstatic DEVICE_ATTR(crt_src, 0664, sm501fb_crtsrc_show, sm501fb_crtsrc_store);\n\n \nstatic int sm501fb_show_regs(struct sm501fb_info *info, char *ptr,\n\t\t\t     unsigned int start, unsigned int len)\n{\n\tvoid __iomem *mem = info->regs;\n\tchar *buf = ptr;\n\tunsigned int reg;\n\n\tfor (reg = start; reg < (len + start); reg += 4)\n\t\tptr += sprintf(ptr, \"%08x = %08x\\n\", reg,\n\t\t\t\tsmc501_readl(mem + reg));\n\n\treturn ptr - buf;\n}\n\n \n\nstatic ssize_t sm501fb_debug_show_crt(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct sm501fb_info *info = dev_get_drvdata(dev);\n\tchar *ptr = buf;\n\n\tptr += sm501fb_show_regs(info, ptr, SM501_DC_CRT_CONTROL, 0x40);\n\tptr += sm501fb_show_regs(info, ptr, SM501_DC_CRT_HWC_BASE, 0x10);\n\n\treturn ptr - buf;\n}\n\nstatic DEVICE_ATTR(fbregs_crt, 0444, sm501fb_debug_show_crt, NULL);\n\n \n\nstatic ssize_t sm501fb_debug_show_pnl(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct sm501fb_info *info = dev_get_drvdata(dev);\n\tchar *ptr = buf;\n\n\tptr += sm501fb_show_regs(info, ptr, 0x0, 0x40);\n\tptr += sm501fb_show_regs(info, ptr, SM501_DC_PANEL_HWC_BASE, 0x10);\n\n\treturn ptr - buf;\n}\n\nstatic DEVICE_ATTR(fbregs_pnl, 0444, sm501fb_debug_show_pnl, NULL);\n\nstatic struct attribute *sm501fb_attrs[] = {\n\t&dev_attr_crt_src.attr,\n\t&dev_attr_fbregs_pnl.attr,\n\t&dev_attr_fbregs_crt.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(sm501fb);\n\n \nstatic int sm501fb_sync(struct fb_info *info)\n{\n\tint count = 1000000;\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\n\t \n\twhile ((count > 0) &&\n\t       (smc501_readl(fbi->regs + SM501_SYSTEM_CONTROL) &\n\t\tSM501_SYSCTRL_2D_ENGINE_STATUS) != 0)\n\t\tcount--;\n\n\tif (count <= 0) {\n\t\tfb_err(info, \"Timeout waiting for 2d engine sync\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void sm501fb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\tint width = area->width;\n\tint height = area->height;\n\tint sx = area->sx;\n\tint sy = area->sy;\n\tint dx = area->dx;\n\tint dy = area->dy;\n\tunsigned long rtl = 0;\n\n\t \n\tif ((sx >= info->var.xres_virtual) ||\n\t    (sy >= info->var.yres_virtual))\n\t\t \n\t\treturn;\n\tif ((sx + width) >= info->var.xres_virtual)\n\t\twidth = info->var.xres_virtual - sx - 1;\n\tif ((sy + height) >= info->var.yres_virtual)\n\t\theight = info->var.yres_virtual - sy - 1;\n\n\t \n\tif ((dx >= info->var.xres_virtual) ||\n\t    (dy >= info->var.yres_virtual))\n\t\t \n\t\treturn;\n\tif ((dx + width) >= info->var.xres_virtual)\n\t\twidth = info->var.xres_virtual - dx - 1;\n\tif ((dy + height) >= info->var.yres_virtual)\n\t\theight = info->var.yres_virtual - dy - 1;\n\n\tif ((sx < dx) || (sy < dy)) {\n\t\trtl = 1 << 27;\n\t\tsx += width - 1;\n\t\tdx += width - 1;\n\t\tsy += height - 1;\n\t\tdy += height - 1;\n\t}\n\n\tif (sm501fb_sync(info))\n\t\treturn;\n\n\t \n\tsmc501_writel(par->screen.sm_addr, fbi->regs2d + SM501_2D_SOURCE_BASE);\n\tsmc501_writel(par->screen.sm_addr,\n\t\t\tfbi->regs2d + SM501_2D_DESTINATION_BASE);\n\n\t \n\tsmc501_writel((info->var.xres << 16) | info->var.xres,\n\t       fbi->regs2d + SM501_2D_WINDOW_WIDTH);\n\n\t \n\tsmc501_writel((info->var.xres_virtual << 16) | info->var.xres_virtual,\n\t       fbi->regs2d + SM501_2D_PITCH);\n\n\t \n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tsmc501_writel(0, fbi->regs2d + SM501_2D_STRETCH);\n\t\tbreak;\n\tcase 16:\n\t\tsmc501_writel(0x00100000, fbi->regs2d + SM501_2D_STRETCH);\n\t\tbreak;\n\tcase 32:\n\t\tsmc501_writel(0x00200000, fbi->regs2d + SM501_2D_STRETCH);\n\t\tbreak;\n\t}\n\n\t \n\tsmc501_writel(0xffffffff, fbi->regs2d + SM501_2D_COLOR_COMPARE_MASK);\n\n\t \n\tsmc501_writel(0xffffffff, fbi->regs2d + SM501_2D_MASK);\n\n\t \n\tsmc501_writel((sx << 16) | sy, fbi->regs2d + SM501_2D_SOURCE);\n\tsmc501_writel((dx << 16) | dy, fbi->regs2d + SM501_2D_DESTINATION);\n\n\t \n\tsmc501_writel((width << 16) | height, fbi->regs2d + SM501_2D_DIMENSION);\n\n\t \n\tsmc501_writel(0x800000cc | rtl, fbi->regs2d + SM501_2D_CONTROL);\n}\n\nstatic void sm501fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct sm501fb_par  *par = info->par;\n\tstruct sm501fb_info *fbi = par->info;\n\tint width = rect->width, height = rect->height;\n\n\tif ((rect->dx >= info->var.xres_virtual) ||\n\t    (rect->dy >= info->var.yres_virtual))\n\t\t \n\t\treturn;\n\tif ((rect->dx + width) >= info->var.xres_virtual)\n\t\twidth = info->var.xres_virtual - rect->dx - 1;\n\tif ((rect->dy + height) >= info->var.yres_virtual)\n\t\theight = info->var.yres_virtual - rect->dy - 1;\n\n\tif (sm501fb_sync(info))\n\t\treturn;\n\n\t \n\tsmc501_writel(par->screen.sm_addr, fbi->regs2d + SM501_2D_SOURCE_BASE);\n\tsmc501_writel(par->screen.sm_addr,\n\t\t\tfbi->regs2d + SM501_2D_DESTINATION_BASE);\n\n\t \n\tsmc501_writel((info->var.xres << 16) | info->var.xres,\n\t       fbi->regs2d + SM501_2D_WINDOW_WIDTH);\n\n\t \n\tsmc501_writel((info->var.xres_virtual << 16) | info->var.xres_virtual,\n\t       fbi->regs2d + SM501_2D_PITCH);\n\n\t \n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tsmc501_writel(0, fbi->regs2d + SM501_2D_STRETCH);\n\t\tbreak;\n\tcase 16:\n\t\tsmc501_writel(0x00100000, fbi->regs2d + SM501_2D_STRETCH);\n\t\tbreak;\n\tcase 32:\n\t\tsmc501_writel(0x00200000, fbi->regs2d + SM501_2D_STRETCH);\n\t\tbreak;\n\t}\n\n\t \n\tsmc501_writel(0xffffffff, fbi->regs2d + SM501_2D_COLOR_COMPARE_MASK);\n\n\t \n\tsmc501_writel(0xffffffff, fbi->regs2d + SM501_2D_MASK);\n\n\t \n\tsmc501_writel(rect->color, fbi->regs2d + SM501_2D_FOREGROUND);\n\n\t \n\tsmc501_writel((rect->dx << 16) | rect->dy,\n\t\t\tfbi->regs2d + SM501_2D_DESTINATION);\n\n\t \n\tsmc501_writel((width << 16) | height, fbi->regs2d + SM501_2D_DIMENSION);\n\n\t \n\tsmc501_writel(0x800100cc, fbi->regs2d + SM501_2D_CONTROL);\n}\n\n\nstatic struct fb_ops sm501fb_ops_crt = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= sm501fb_check_var_crt,\n\t.fb_set_par\t= sm501fb_set_par_crt,\n\t.fb_blank\t= sm501fb_blank_crt,\n\t.fb_setcolreg\t= sm501fb_setcolreg,\n\t.fb_pan_display\t= sm501fb_pan_crt,\n\t.fb_cursor\t= sm501fb_cursor,\n\t.fb_fillrect\t= sm501fb_fillrect,\n\t.fb_copyarea\t= sm501fb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n\t.fb_sync\t= sm501fb_sync,\n};\n\nstatic struct fb_ops sm501fb_ops_pnl = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= sm501fb_check_var_pnl,\n\t.fb_set_par\t= sm501fb_set_par_pnl,\n\t.fb_pan_display\t= sm501fb_pan_pnl,\n\t.fb_blank\t= sm501fb_blank_pnl,\n\t.fb_setcolreg\t= sm501fb_setcolreg,\n\t.fb_cursor\t= sm501fb_cursor,\n\t.fb_fillrect\t= sm501fb_fillrect,\n\t.fb_copyarea\t= sm501fb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n\t.fb_sync\t= sm501fb_sync,\n};\n\n \n\nstatic int sm501_init_cursor(struct fb_info *fbi, unsigned int reg_base)\n{\n\tstruct sm501fb_par *par;\n\tstruct sm501fb_info *info;\n\tint ret;\n\n\tif (fbi == NULL)\n\t\treturn 0;\n\n\tpar = fbi->par;\n\tinfo = par->info;\n\n\tpar->cursor_regs = info->regs + reg_base;\n\n\tret = sm501_alloc_mem(info, &par->cursor, SM501_MEMF_CURSOR, 1024,\n\t\t\t      fbi->fix.smem_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\tsmc501_writel(par->cursor.sm_addr,\n\t\t\tpar->cursor_regs + SM501_OFF_HWC_ADDR);\n\n\tsmc501_writel(0x00, par->cursor_regs + SM501_OFF_HWC_LOC);\n\tsmc501_writel(0x00, par->cursor_regs + SM501_OFF_HWC_COLOR_1_2);\n\tsmc501_writel(0x00, par->cursor_regs + SM501_OFF_HWC_COLOR_3);\n\tsm501fb_sync_regs(info);\n\n\treturn 0;\n}\n\n \n\nstatic int sm501fb_start(struct sm501fb_info *info,\n\t\t\t struct platform_device *pdev)\n{\n\tstruct resource\t*res;\n\tstruct device *dev = &pdev->dev;\n\tint k;\n\tint ret;\n\n\tinfo->irq = ret = platform_get_irq(pdev, 0);\n\tif (ret < 0) {\n\t\t \n\t\tdev_warn(dev, \"no irq for device\\n\");\n\t}\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(dev, \"no resource definition for registers\\n\");\n\t\tret = -ENOENT;\n\t\tgoto err_release;\n\t}\n\n\tinfo->regs_res = request_mem_region(res->start,\n\t\t\t\t\t    resource_size(res),\n\t\t\t\t\t    pdev->name);\n\n\tif (info->regs_res == NULL) {\n\t\tdev_err(dev, \"cannot claim registers\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_release;\n\t}\n\n\tinfo->regs = ioremap(res->start, resource_size(res));\n\tif (info->regs == NULL) {\n\t\tdev_err(dev, \"cannot remap registers\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_regs_res;\n\t}\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res == NULL) {\n\t\tdev_err(dev, \"no resource definition for 2d registers\\n\");\n\t\tret = -ENOENT;\n\t\tgoto err_regs_map;\n\t}\n\n\tinfo->regs2d_res = request_mem_region(res->start,\n\t\t\t\t\t      resource_size(res),\n\t\t\t\t\t      pdev->name);\n\n\tif (info->regs2d_res == NULL) {\n\t\tdev_err(dev, \"cannot claim registers\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_regs_map;\n\t}\n\n\tinfo->regs2d = ioremap(res->start, resource_size(res));\n\tif (info->regs2d == NULL) {\n\t\tdev_err(dev, \"cannot remap registers\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_regs2d_res;\n\t}\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\n\tif (res == NULL) {\n\t\tdev_err(dev, \"no memory resource defined\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_regs2d_map;\n\t}\n\n\tinfo->fbmem_res = request_mem_region(res->start,\n\t\t\t\t\t     resource_size(res),\n\t\t\t\t\t     pdev->name);\n\tif (info->fbmem_res == NULL) {\n\t\tdev_err(dev, \"cannot claim framebuffer\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_regs2d_map;\n\t}\n\n\tinfo->fbmem = ioremap(res->start, resource_size(res));\n\tif (info->fbmem == NULL) {\n\t\tdev_err(dev, \"cannot remap framebuffer\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_mem_res;\n\t}\n\n\tinfo->fbmem_len = resource_size(res);\n\n\t \n\tmemset_io(info->fbmem, 0, info->fbmem_len);\n\n\t \n\tfor (k = 0; k < (256 * 3); k++)\n\t\tsmc501_writel(0, info->regs + SM501_DC_PANEL_PALETTE + (k * 4));\n\n\t \n\tsm501_unit_power(dev->parent, SM501_GATE_DISPLAY, 1);\n\n\t \n\tsm501_unit_power(dev->parent, SM501_GATE_2D_ENGINE, 1);\n\n\t \n\tsm501_init_cursor(info->fb[HEAD_CRT], SM501_DC_CRT_HWC_ADDR);\n\tsm501_init_cursor(info->fb[HEAD_PANEL], SM501_DC_PANEL_HWC_ADDR);\n\n\treturn 0;  \n\n err_mem_res:\n\trelease_mem_region(info->fbmem_res->start,\n\t\t\t   resource_size(info->fbmem_res));\n\n err_regs2d_map:\n\tiounmap(info->regs2d);\n\n err_regs2d_res:\n\trelease_mem_region(info->regs2d_res->start,\n\t\t\t   resource_size(info->regs2d_res));\n\n err_regs_map:\n\tiounmap(info->regs);\n\n err_regs_res:\n\trelease_mem_region(info->regs_res->start,\n\t\t\t   resource_size(info->regs_res));\n\n err_release:\n\treturn ret;\n}\n\nstatic void sm501fb_stop(struct sm501fb_info *info)\n{\n\t \n\tsm501_unit_power(info->dev->parent, SM501_GATE_DISPLAY, 0);\n\n\tiounmap(info->fbmem);\n\trelease_mem_region(info->fbmem_res->start,\n\t\t\t   resource_size(info->fbmem_res));\n\n\tiounmap(info->regs2d);\n\trelease_mem_region(info->regs2d_res->start,\n\t\t\t   resource_size(info->regs2d_res));\n\n\tiounmap(info->regs);\n\trelease_mem_region(info->regs_res->start,\n\t\t\t   resource_size(info->regs_res));\n}\n\nstatic int sm501fb_init_fb(struct fb_info *fb, enum sm501_controller head,\n\t\t\t   const char *fbname)\n{\n\tstruct sm501_platdata_fbsub *pd;\n\tstruct sm501fb_par *par = fb->par;\n\tstruct sm501fb_info *info = par->info;\n\tunsigned long ctrl;\n\tunsigned int enable;\n\tint ret;\n\n\tswitch (head) {\n\tcase HEAD_CRT:\n\t\tpd = info->pdata->fb_crt;\n\t\tctrl = smc501_readl(info->regs + SM501_DC_CRT_CONTROL);\n\t\tenable = (ctrl & SM501_DC_CRT_CONTROL_ENABLE) ? 1 : 0;\n\n\t\t \n\t\tif (info->pdata->fb_route != SM501_FB_CRT_PANEL) {\n\t\t\tctrl |= SM501_DC_CRT_CONTROL_SEL;\n\t\t\tsmc501_writel(ctrl, info->regs + SM501_DC_CRT_CONTROL);\n\t\t}\n\n\t\tbreak;\n\n\tcase HEAD_PANEL:\n\t\tpd = info->pdata->fb_pnl;\n\t\tctrl = smc501_readl(info->regs + SM501_DC_PANEL_CONTROL);\n\t\tenable = (ctrl & SM501_DC_PANEL_CONTROL_EN) ? 1 : 0;\n\t\tbreak;\n\n\tdefault:\n\t\tpd = NULL;\t\t \n\t\tctrl = 0;\n\t\tenable = 0;\n\t\tBUG();\n\t}\n\n\tdev_info(info->dev, \"fb %s %sabled at start\\n\",\n\t\t fbname, enable ? \"en\" : \"dis\");\n\n\t \n\n\tif (head == HEAD_CRT && info->pdata->fb_route == SM501_FB_CRT_PANEL) {\n\t\tctrl &= ~SM501_DC_CRT_CONTROL_SEL;\n\t\tsmc501_writel(ctrl, info->regs + SM501_DC_CRT_CONTROL);\n\t\tenable = 0;\n\t}\n\n\tstrscpy(fb->fix.id, fbname, sizeof(fb->fix.id));\n\n\tmemcpy(&par->ops,\n\t       (head == HEAD_CRT) ? &sm501fb_ops_crt : &sm501fb_ops_pnl,\n\t       sizeof(struct fb_ops));\n\n\t \n\n\tif ((pd->flags & SM501FB_FLAG_USE_HWCURSOR) == 0)\n\t\tpar->ops.fb_cursor = NULL;\n\n\tfb->fbops = &par->ops;\n\tfb->flags = FBINFO_READS_FAST |\n\t\tFBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |\n\t\tFBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;\n\n#if defined(CONFIG_OF)\n#ifdef __BIG_ENDIAN\n\tif (of_property_read_bool(info->dev->parent->of_node, \"little-endian\"))\n\t\tfb->flags |= FBINFO_FOREIGN_ENDIAN;\n#else\n\tif (of_property_read_bool(info->dev->parent->of_node, \"big-endian\"))\n\t\tfb->flags |= FBINFO_FOREIGN_ENDIAN;\n#endif\n#endif\n\t \n\n\tfb->fix.type\t\t= FB_TYPE_PACKED_PIXELS;\n\tfb->fix.type_aux\t= 0;\n\tfb->fix.xpanstep\t= 1;\n\tfb->fix.ypanstep\t= 1;\n\tfb->fix.ywrapstep\t= 0;\n\tfb->fix.accel\t\t= FB_ACCEL_NONE;\n\n\t \n\n\tfb->var.nonstd\t\t= 0;\n\tfb->var.activate\t= FB_ACTIVATE_NOW;\n\tfb->var.accel_flags\t= 0;\n\tfb->var.vmode\t\t= FB_VMODE_NONINTERLACED;\n\tfb->var.bits_per_pixel  = 16;\n\n\tif (info->edid_data) {\n\t\t\t \n\t\t\tfb_edid_to_monspecs(info->edid_data, &fb->monspecs);\n\t\t\tfb_videomode_to_modelist(fb->monspecs.modedb,\n\t\t\t\t\t\t fb->monspecs.modedb_len,\n\t\t\t\t\t\t &fb->modelist);\n\t}\n\n\tif (enable && (pd->flags & SM501FB_FLAG_USE_INIT_MODE) && 0) {\n\t\t \n\t} else {\n\t\tif (pd->def_mode) {\n\t\t\tdev_info(info->dev, \"using supplied mode\\n\");\n\t\t\tfb_videomode_to_var(&fb->var, pd->def_mode);\n\n\t\t\tfb->var.bits_per_pixel = pd->def_bpp ? pd->def_bpp : 8;\n\t\t\tfb->var.xres_virtual = fb->var.xres;\n\t\t\tfb->var.yres_virtual = fb->var.yres;\n\t\t} else {\n\t\t\tif (info->edid_data) {\n\t\t\t\tret = fb_find_mode(&fb->var, fb, fb_mode,\n\t\t\t\t\tfb->monspecs.modedb,\n\t\t\t\t\tfb->monspecs.modedb_len,\n\t\t\t\t\t&sm501_default_mode, default_bpp);\n\t\t\t\t \n\t\t\t\tkfree(info->edid_data);\n\t\t\t} else {\n\t\t\t\tret = fb_find_mode(&fb->var, fb,\n\t\t\t\t\t   NULL, NULL, 0, NULL, 8);\n\t\t\t}\n\n\t\t\tswitch (ret) {\n\t\t\tcase 1:\n\t\t\t\tdev_info(info->dev, \"using mode specified in \"\n\t\t\t\t\t\t\"@mode\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdev_info(info->dev, \"using mode specified in \"\n\t\t\t\t\t\"@mode with ignored refresh rate\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdev_info(info->dev, \"using mode default \"\n\t\t\t\t\t\"mode\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdev_info(info->dev, \"using mode from list\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_info(info->dev, \"ret = %d\\n\", ret);\n\t\t\t\tdev_info(info->dev, \"failed to find mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (fb_alloc_cmap(&fb->cmap, NR_PALETTE, 0)) {\n\t\tdev_err(info->dev, \"failed to allocate cmap memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tfb_set_cmap(&fb->cmap, fb);\n\n\tret = (fb->fbops->fb_check_var)(&fb->var, fb);\n\tif (ret)\n\t\tdev_err(info->dev, \"check_var() failed on initial setup?\\n\");\n\n\treturn 0;\n}\n\n \n\nstatic struct sm501_platdata_fbsub sm501fb_pdata_crt = {\n\t.flags\t\t= (SM501FB_FLAG_USE_INIT_MODE |\n\t\t\t   SM501FB_FLAG_USE_HWCURSOR |\n\t\t\t   SM501FB_FLAG_USE_HWACCEL |\n\t\t\t   SM501FB_FLAG_DISABLE_AT_EXIT),\n\n};\n\nstatic struct sm501_platdata_fbsub sm501fb_pdata_pnl = {\n\t.flags\t\t= (SM501FB_FLAG_USE_INIT_MODE |\n\t\t\t   SM501FB_FLAG_USE_HWCURSOR |\n\t\t\t   SM501FB_FLAG_USE_HWACCEL |\n\t\t\t   SM501FB_FLAG_DISABLE_AT_EXIT),\n};\n\nstatic struct sm501_platdata_fb sm501fb_def_pdata = {\n\t.fb_route\t\t= SM501_FB_OWN,\n\t.fb_crt\t\t\t= &sm501fb_pdata_crt,\n\t.fb_pnl\t\t\t= &sm501fb_pdata_pnl,\n};\n\nstatic char driver_name_crt[] = \"sm501fb-crt\";\nstatic char driver_name_pnl[] = \"sm501fb-panel\";\n\nstatic int sm501fb_probe_one(struct sm501fb_info *info,\n\t\t\t     enum sm501_controller head)\n{\n\tunsigned char *name = (head == HEAD_CRT) ? \"crt\" : \"panel\";\n\tstruct sm501_platdata_fbsub *pd;\n\tstruct sm501fb_par *par;\n\tstruct fb_info *fbi;\n\n\tpd = (head == HEAD_CRT) ? info->pdata->fb_crt : info->pdata->fb_pnl;\n\n\t \n\tif (pd == NULL) {\n\t\tdev_info(info->dev, \"no data for fb %s (disabled)\\n\", name);\n\t\treturn 0;\n\t}\n\n\tfbi = framebuffer_alloc(sizeof(struct sm501fb_par), info->dev);\n\tif (!fbi)\n\t\treturn -ENOMEM;\n\n\tpar = fbi->par;\n\tpar->info = info;\n\tpar->head = head;\n\tfbi->pseudo_palette = &par->pseudo_palette;\n\n\tinfo->fb[head] = fbi;\n\n\treturn 0;\n}\n\n \n\nstatic void sm501_free_init_fb(struct sm501fb_info *info,\n\t\t\t\tenum sm501_controller head)\n{\n\tstruct fb_info *fbi = info->fb[head];\n\n\tif (!fbi)\n\t\treturn;\n\n\tfb_dealloc_cmap(&fbi->cmap);\n}\n\nstatic int sm501fb_start_one(struct sm501fb_info *info,\n\t\t\t     enum sm501_controller head, const char *drvname)\n{\n\tstruct fb_info *fbi = info->fb[head];\n\tint ret;\n\n\tif (!fbi)\n\t\treturn 0;\n\n\tmutex_init(&info->fb[head]->mm_lock);\n\n\tret = sm501fb_init_fb(info->fb[head], head, drvname);\n\tif (ret) {\n\t\tdev_err(info->dev, \"cannot initialise fb %s\\n\", drvname);\n\t\treturn ret;\n\t}\n\n\tret = register_framebuffer(info->fb[head]);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to register fb %s\\n\", drvname);\n\t\tsm501_free_init_fb(info, head);\n\t\treturn ret;\n\t}\n\n\tdev_info(info->dev, \"fb%d: %s frame buffer\\n\", fbi->node, fbi->fix.id);\n\n\treturn 0;\n}\n\nstatic int sm501fb_probe(struct platform_device *pdev)\n{\n\tstruct sm501fb_info *info;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\t \n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\tdev_err(dev, \"failed to allocate state\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo->dev = dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, info);\n\n\tif (dev->parent->platform_data) {\n\t\tstruct sm501_platdata *pd = dev->parent->platform_data;\n\t\tinfo->pdata = pd->fb;\n\t}\n\n\tif (info->pdata == NULL) {\n\t\tint found = 0;\n#if defined(CONFIG_OF)\n\t\tstruct device_node *np = pdev->dev.parent->of_node;\n\t\tconst u8 *prop;\n\t\tconst char *cp;\n\t\tint len;\n\n\t\tinfo->pdata = &sm501fb_def_pdata;\n\t\tif (np) {\n\t\t\t \n\t\t\tcp = of_get_property(np, \"mode\", &len);\n\t\t\tif (cp)\n\t\t\t\tstrcpy(fb_mode, cp);\n\t\t\tprop = of_get_property(np, \"edid\", &len);\n\t\t\tif (prop && len == EDID_LENGTH) {\n\t\t\t\tinfo->edid_data = kmemdup(prop, EDID_LENGTH,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\t\tif (info->edid_data)\n\t\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!found) {\n\t\t\tdev_info(dev, \"using default configuration data\\n\");\n\t\t\tinfo->pdata = &sm501fb_def_pdata;\n\t\t}\n\t}\n\n\t \n\n\tret = sm501fb_probe_one(info, HEAD_CRT);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to probe CRT\\n\");\n\t\tgoto err_alloc;\n\t}\n\n\tret = sm501fb_probe_one(info, HEAD_PANEL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to probe PANEL\\n\");\n\t\tgoto err_probed_crt;\n\t}\n\n\tif (info->fb[HEAD_PANEL] == NULL &&\n\t    info->fb[HEAD_CRT] == NULL) {\n\t\tdev_err(dev, \"no framebuffers found\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_alloc;\n\t}\n\n\t \n\n\tret = sm501fb_start(info, pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot initialise SM501\\n\");\n\t\tgoto err_probed_panel;\n\t}\n\n\tret = sm501fb_start_one(info, HEAD_CRT, driver_name_crt);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to start CRT\\n\");\n\t\tgoto err_started;\n\t}\n\n\tret = sm501fb_start_one(info, HEAD_PANEL, driver_name_pnl);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to start Panel\\n\");\n\t\tgoto err_started_crt;\n\t}\n\n\t \n\treturn 0;\n\nerr_started_crt:\n\tunregister_framebuffer(info->fb[HEAD_CRT]);\n\tsm501_free_init_fb(info, HEAD_CRT);\n\nerr_started:\n\tsm501fb_stop(info);\n\nerr_probed_panel:\n\tframebuffer_release(info->fb[HEAD_PANEL]);\n\nerr_probed_crt:\n\tframebuffer_release(info->fb[HEAD_CRT]);\n\nerr_alloc:\n\tkfree(info);\n\n\treturn ret;\n}\n\n\n \nstatic void sm501fb_remove(struct platform_device *pdev)\n{\n\tstruct sm501fb_info *info = platform_get_drvdata(pdev);\n\tstruct fb_info\t   *fbinfo_crt = info->fb[0];\n\tstruct fb_info\t   *fbinfo_pnl = info->fb[1];\n\n\tsm501_free_init_fb(info, HEAD_CRT);\n\tsm501_free_init_fb(info, HEAD_PANEL);\n\n\tif (fbinfo_crt)\n\t\tunregister_framebuffer(fbinfo_crt);\n\tif (fbinfo_pnl)\n\t\tunregister_framebuffer(fbinfo_pnl);\n\n\tsm501fb_stop(info);\n\tkfree(info);\n\n\tframebuffer_release(fbinfo_pnl);\n\tframebuffer_release(fbinfo_crt);\n}\n\n#ifdef CONFIG_PM\n\nstatic int sm501fb_suspend_fb(struct sm501fb_info *info,\n\t\t\t      enum sm501_controller head)\n{\n\tstruct fb_info *fbi = info->fb[head];\n\tstruct sm501fb_par *par;\n\n\tif (!fbi)\n\t\treturn 0;\n\n\tpar = fbi->par;\n\tif (par->screen.size == 0)\n\t\treturn 0;\n\n\t \n\t(par->ops.fb_blank)(FB_BLANK_POWERDOWN, fbi);\n\n\t \n\n\tconsole_lock();\n\tfb_set_suspend(fbi, 1);\n\tconsole_unlock();\n\n\t \n\n\tpar->store_fb = vmalloc(par->screen.size);\n\tif (par->store_fb == NULL) {\n\t\tdev_err(info->dev, \"no memory to store screen\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpar->store_cursor = vmalloc(par->cursor.size);\n\tif (par->store_cursor == NULL) {\n\t\tdev_err(info->dev, \"no memory to store cursor\\n\");\n\t\tgoto err_nocursor;\n\t}\n\n\tdev_dbg(info->dev, \"suspending screen to %p\\n\", par->store_fb);\n\tdev_dbg(info->dev, \"suspending cursor to %p\\n\", par->store_cursor);\n\n\tmemcpy_fromio(par->store_fb, par->screen.k_addr, par->screen.size);\n\tmemcpy_fromio(par->store_cursor, par->cursor.k_addr, par->cursor.size);\n\n\treturn 0;\n\n err_nocursor:\n\tvfree(par->store_fb);\n\tpar->store_fb = NULL;\n\n\treturn -ENOMEM;\n}\n\nstatic void sm501fb_resume_fb(struct sm501fb_info *info,\n\t\t\t      enum sm501_controller head)\n{\n\tstruct fb_info *fbi = info->fb[head];\n\tstruct sm501fb_par *par;\n\n\tif (!fbi)\n\t\treturn;\n\n\tpar = fbi->par;\n\tif (par->screen.size == 0)\n\t\treturn;\n\n\t \n\n\t(par->ops.fb_set_par)(fbi);\n\n\t \n\n\tdev_dbg(info->dev, \"restoring screen from %p\\n\", par->store_fb);\n\tdev_dbg(info->dev, \"restoring cursor from %p\\n\", par->store_cursor);\n\n\tif (par->store_fb)\n\t\tmemcpy_toio(par->screen.k_addr, par->store_fb,\n\t\t\t    par->screen.size);\n\n\tif (par->store_cursor)\n\t\tmemcpy_toio(par->cursor.k_addr, par->store_cursor,\n\t\t\t    par->cursor.size);\n\n\tconsole_lock();\n\tfb_set_suspend(fbi, 0);\n\tconsole_unlock();\n\n\tvfree(par->store_fb);\n\tvfree(par->store_cursor);\n}\n\n\n \n\nstatic int sm501fb_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct sm501fb_info *info = platform_get_drvdata(pdev);\n\n\t \n\tinfo->pm_crt_ctrl = smc501_readl(info->regs + SM501_DC_CRT_CONTROL);\n\n\tsm501fb_suspend_fb(info, HEAD_CRT);\n\tsm501fb_suspend_fb(info, HEAD_PANEL);\n\n\t \n\tsm501_unit_power(info->dev->parent, SM501_GATE_DISPLAY, 0);\n\n\treturn 0;\n}\n\n#define SM501_CRT_CTRL_SAVE (SM501_DC_CRT_CONTROL_TVP |        \\\n\t\t\t     SM501_DC_CRT_CONTROL_SEL)\n\n\nstatic int sm501fb_resume(struct platform_device *pdev)\n{\n\tstruct sm501fb_info *info = platform_get_drvdata(pdev);\n\tunsigned long crt_ctrl;\n\n\tsm501_unit_power(info->dev->parent, SM501_GATE_DISPLAY, 1);\n\n\t \n\n\tcrt_ctrl = smc501_readl(info->regs + SM501_DC_CRT_CONTROL);\n\tcrt_ctrl &= ~SM501_CRT_CTRL_SAVE;\n\tcrt_ctrl |= info->pm_crt_ctrl & SM501_CRT_CTRL_SAVE;\n\tsmc501_writel(crt_ctrl, info->regs + SM501_DC_CRT_CONTROL);\n\n\tsm501fb_resume_fb(info, HEAD_CRT);\n\tsm501fb_resume_fb(info, HEAD_PANEL);\n\n\treturn 0;\n}\n\n#else\n#define sm501fb_suspend NULL\n#define sm501fb_resume  NULL\n#endif\n\nstatic struct platform_driver sm501fb_driver = {\n\t.probe\t\t= sm501fb_probe,\n\t.remove_new\t= sm501fb_remove,\n\t.suspend\t= sm501fb_suspend,\n\t.resume\t\t= sm501fb_resume,\n\t.driver\t\t= {\n\t\t.name\t= \"sm501-fb\",\n\t\t.dev_groups\t= sm501fb_groups,\n\t},\n};\n\nmodule_platform_driver(sm501fb_driver);\n\nmodule_param_named(mode, fb_mode, charp, 0);\nMODULE_PARM_DESC(mode,\n\t\"Specify resolution as \\\"<xres>x<yres>[-<bpp>][@<refresh>]\\\" \");\nmodule_param_named(bpp, default_bpp, ulong, 0);\nMODULE_PARM_DESC(bpp, \"Specify bit-per-pixel if not specified mode\");\nMODULE_AUTHOR(\"Ben Dooks, Vincent Sanders\");\nMODULE_DESCRIPTION(\"SM501 Framebuffer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}