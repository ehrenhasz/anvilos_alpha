{
  "module_name": "tileblit.c",
  "hash_id": "19c2e0a4ca4ff8c315200ebd09a6b60c72a8cdb3b5efc74f26474728a1df893c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/core/tileblit.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/fb.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n#include <asm/types.h>\n#include \"fbcon.h\"\n\nstatic void tile_bmove(struct vc_data *vc, struct fb_info *info, int sy,\n\t\t       int sx, int dy, int dx, int height, int width)\n{\n\tstruct fb_tilearea area;\n\n\tarea.sx = sx;\n\tarea.sy = sy;\n\tarea.dx = dx;\n\tarea.dy = dy;\n\tarea.height = height;\n\tarea.width = width;\n\n\tinfo->tileops->fb_tilecopy(info, &area);\n}\n\nstatic void tile_clear(struct vc_data *vc, struct fb_info *info, int sy,\n\t\t       int sx, int height, int width)\n{\n\tstruct fb_tilerect rect;\n\tint bgshift = (vc->vc_hi_font_mask) ? 13 : 12;\n\tint fgshift = (vc->vc_hi_font_mask) ? 9 : 8;\n\n\trect.index = vc->vc_video_erase_char &\n\t\t((vc->vc_hi_font_mask) ? 0x1ff : 0xff);\n\trect.fg = attr_fgcol_ec(fgshift, vc, info);\n\trect.bg = attr_bgcol_ec(bgshift, vc, info);\n\trect.sx = sx;\n\trect.sy = sy;\n\trect.width = width;\n\trect.height = height;\n\trect.rop = ROP_COPY;\n\n\tinfo->tileops->fb_tilefill(info, &rect);\n}\n\nstatic void tile_putcs(struct vc_data *vc, struct fb_info *info,\n\t\t       const unsigned short *s, int count, int yy, int xx,\n\t\t       int fg, int bg)\n{\n\tstruct fb_tileblit blit;\n\tunsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\n\tint size = sizeof(u32) * count, i;\n\n\tblit.sx = xx;\n\tblit.sy = yy;\n\tblit.width = count;\n\tblit.height = 1;\n\tblit.fg = fg;\n\tblit.bg = bg;\n\tblit.length = count;\n\tblit.indices = (u32 *) fb_get_buffer_offset(info, &info->pixmap, size);\n\tfor (i = 0; i < count; i++)\n\t\tblit.indices[i] = (u32)(scr_readw(s++) & charmask);\n\n\tinfo->tileops->fb_tileblit(info, &blit);\n}\n\nstatic void tile_clear_margins(struct vc_data *vc, struct fb_info *info,\n\t\t\t       int color, int bottom_only)\n{\n\treturn;\n}\n\nstatic void tile_cursor(struct vc_data *vc, struct fb_info *info, int mode,\n\t\t\tint fg, int bg)\n{\n\tstruct fb_tilecursor cursor;\n\tint use_sw = vc->vc_cursor_type & CUR_SW;\n\n\tcursor.sx = vc->state.x;\n\tcursor.sy = vc->state.y;\n\tcursor.mode = (mode == CM_ERASE || use_sw) ? 0 : 1;\n\tcursor.fg = fg;\n\tcursor.bg = bg;\n\n\tswitch (vc->vc_cursor_type & 0x0f) {\n\tcase CUR_NONE:\n\t\tcursor.shape = FB_TILE_CURSOR_NONE;\n\t\tbreak;\n\tcase CUR_UNDERLINE:\n\t\tcursor.shape = FB_TILE_CURSOR_UNDERLINE;\n\t\tbreak;\n\tcase CUR_LOWER_THIRD:\n\t\tcursor.shape = FB_TILE_CURSOR_LOWER_THIRD;\n\t\tbreak;\n\tcase CUR_LOWER_HALF:\n\t\tcursor.shape = FB_TILE_CURSOR_LOWER_HALF;\n\t\tbreak;\n\tcase CUR_TWO_THIRDS:\n\t\tcursor.shape = FB_TILE_CURSOR_TWO_THIRDS;\n\t\tbreak;\n\tcase CUR_BLOCK:\n\tdefault:\n\t\tcursor.shape = FB_TILE_CURSOR_BLOCK;\n\t\tbreak;\n\t}\n\n\tinfo->tileops->fb_tilecursor(info, &cursor);\n}\n\nstatic int tile_update_start(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint err;\n\n\terr = fb_pan_display(info, &ops->var);\n\tops->var.xoffset = info->var.xoffset;\n\tops->var.yoffset = info->var.yoffset;\n\tops->var.vmode = info->var.vmode;\n\treturn err;\n}\n\nvoid fbcon_set_tileops(struct vc_data *vc, struct fb_info *info)\n{\n\tstruct fb_tilemap map;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tops->bmove = tile_bmove;\n\tops->clear = tile_clear;\n\tops->putcs = tile_putcs;\n\tops->clear_margins = tile_clear_margins;\n\tops->cursor = tile_cursor;\n\tops->update_start = tile_update_start;\n\n\tif (ops->p) {\n\t\tmap.width = vc->vc_font.width;\n\t\tmap.height = vc->vc_font.height;\n\t\tmap.depth = 1;\n\t\tmap.length = vc->vc_font.charcount;\n\t\tmap.data = ops->p->fontdata;\n\t\tinfo->tileops->fb_settile(info, &map);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}