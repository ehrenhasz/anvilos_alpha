{
  "module_name": "fbcon_ud.c",
  "hash_id": "8eea7006d14d79d62653504a600b3aa77ee5d44f9d30ef52dca724609c18c351",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/core/fbcon_ud.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/fb.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n#include <asm/types.h>\n#include \"fbcon.h\"\n#include \"fbcon_rotate.h\"\n\n \n\nstatic void ud_update_attr(u8 *dst, u8 *src, int attribute,\n\t\t\t\t  struct vc_data *vc)\n{\n\tint i, offset = (vc->vc_font.height < 10) ? 1 : 2;\n\tint width = (vc->vc_font.width + 7) >> 3;\n\tunsigned int cellsize = vc->vc_font.height * width;\n\tu8 c;\n\n\toffset = offset * width;\n\n\tfor (i = 0; i < cellsize; i++) {\n\t\tc = src[i];\n\t\tif (attribute & FBCON_ATTRIBUTE_UNDERLINE && i < offset)\n\t\t\tc = 0xff;\n\t\tif (attribute & FBCON_ATTRIBUTE_BOLD)\n\t\t\tc |= c << 1;\n\t\tif (attribute & FBCON_ATTRIBUTE_REVERSE)\n\t\t\tc = ~c;\n\t\tdst[i] = c;\n\t}\n}\n\n\nstatic void ud_bmove(struct vc_data *vc, struct fb_info *info, int sy,\n\t\t     int sx, int dy, int dx, int height, int width)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fb_copyarea area;\n\tu32 vyres = GETVYRES(ops->p, info);\n\tu32 vxres = GETVXRES(ops->p, info);\n\n\tarea.sy = vyres - ((sy + height) * vc->vc_font.height);\n\tarea.sx = vxres - ((sx + width) * vc->vc_font.width);\n\tarea.dy = vyres - ((dy + height) * vc->vc_font.height);\n\tarea.dx = vxres - ((dx + width) * vc->vc_font.width);\n\tarea.height = height * vc->vc_font.height;\n\tarea.width  = width * vc->vc_font.width;\n\n\tinfo->fbops->fb_copyarea(info, &area);\n}\n\nstatic void ud_clear(struct vc_data *vc, struct fb_info *info, int sy,\n\t\t     int sx, int height, int width)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fb_fillrect region;\n\tint bgshift = (vc->vc_hi_font_mask) ? 13 : 12;\n\tu32 vyres = GETVYRES(ops->p, info);\n\tu32 vxres = GETVXRES(ops->p, info);\n\n\tregion.color = attr_bgcol_ec(bgshift,vc,info);\n\tregion.dy = vyres - ((sy + height) * vc->vc_font.height);\n\tregion.dx = vxres - ((sx + width) *  vc->vc_font.width);\n\tregion.width = width * vc->vc_font.width;\n\tregion.height = height * vc->vc_font.height;\n\tregion.rop = ROP_COPY;\n\n\tinfo->fbops->fb_fillrect(info, &region);\n}\n\nstatic inline void ud_putcs_aligned(struct vc_data *vc, struct fb_info *info,\n\t\t\t\t    const u16 *s, u32 attr, u32 cnt,\n\t\t\t\t    u32 d_pitch, u32 s_pitch, u32 cellsize,\n\t\t\t\t    struct fb_image *image, u8 *buf, u8 *dst)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tu16 charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\n\tu32 idx = vc->vc_font.width >> 3;\n\tu8 *src;\n\n\twhile (cnt--) {\n\t\tsrc = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;\n\n\t\tif (attr) {\n\t\t\tud_update_attr(buf, src, attr, vc);\n\t\t\tsrc = buf;\n\t\t}\n\n\t\tif (likely(idx == 1))\n\t\t\t__fb_pad_aligned_buffer(dst, d_pitch, src, idx,\n\t\t\t\t\t\timage->height);\n\t\telse\n\t\t\tfb_pad_aligned_buffer(dst, d_pitch, src, idx,\n\t\t\t\t\t      image->height);\n\n\t\tdst += s_pitch;\n\t}\n\n\tinfo->fbops->fb_imageblit(info, image);\n}\n\nstatic inline void ud_putcs_unaligned(struct vc_data *vc,\n\t\t\t\t      struct fb_info *info, const u16 *s,\n\t\t\t\t      u32 attr, u32 cnt, u32 d_pitch,\n\t\t\t\t      u32 s_pitch, u32 cellsize,\n\t\t\t\t      struct fb_image *image, u8 *buf,\n\t\t\t\t      u8 *dst)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tu16 charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\n\tu32 shift_low = 0, mod = vc->vc_font.width % 8;\n\tu32 shift_high = 8;\n\tu32 idx = vc->vc_font.width >> 3;\n\tu8 *src;\n\n\twhile (cnt--) {\n\t\tsrc = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;\n\n\t\tif (attr) {\n\t\t\tud_update_attr(buf, src, attr, vc);\n\t\t\tsrc = buf;\n\t\t}\n\n\t\tfb_pad_unaligned_buffer(dst, d_pitch, src, idx,\n\t\t\t\t\timage->height, shift_high,\n\t\t\t\t\tshift_low, mod);\n\t\tshift_low += mod;\n\t\tdst += (shift_low >= 8) ? s_pitch : s_pitch - 1;\n\t\tshift_low &= 7;\n\t\tshift_high = 8 - shift_low;\n\t}\n\n\tinfo->fbops->fb_imageblit(info, image);\n\n}\n\nstatic void ud_putcs(struct vc_data *vc, struct fb_info *info,\n\t\t      const unsigned short *s, int count, int yy, int xx,\n\t\t      int fg, int bg)\n{\n\tstruct fb_image image;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tu32 width = (vc->vc_font.width + 7)/8;\n\tu32 cellsize = width * vc->vc_font.height;\n\tu32 maxcnt = info->pixmap.size/cellsize;\n\tu32 scan_align = info->pixmap.scan_align - 1;\n\tu32 buf_align = info->pixmap.buf_align - 1;\n\tu32 mod = vc->vc_font.width % 8, cnt, pitch, size;\n\tu32 attribute = get_attribute(info, scr_readw(s));\n\tu8 *dst, *buf = NULL;\n\tu32 vyres = GETVYRES(ops->p, info);\n\tu32 vxres = GETVXRES(ops->p, info);\n\n\tif (!ops->fontbuffer)\n\t\treturn;\n\n\timage.fg_color = fg;\n\timage.bg_color = bg;\n\timage.dy = vyres - ((yy * vc->vc_font.height) + vc->vc_font.height);\n\timage.dx = vxres - ((xx + count) * vc->vc_font.width);\n\timage.height = vc->vc_font.height;\n\timage.depth = 1;\n\n\tif (attribute) {\n\t\tbuf = kmalloc(cellsize, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn;\n\t}\n\n\ts += count - 1;\n\n\twhile (count) {\n\t\tif (count > maxcnt)\n\t\t\tcnt = maxcnt;\n\t\telse\n\t\t\tcnt = count;\n\n\t\timage.width = vc->vc_font.width * cnt;\n\t\tpitch = ((image.width + 7) >> 3) + scan_align;\n\t\tpitch &= ~scan_align;\n\t\tsize = pitch * image.height + buf_align;\n\t\tsize &= ~buf_align;\n\t\tdst = fb_get_buffer_offset(info, &info->pixmap, size);\n\t\timage.data = dst;\n\n\t\tif (!mod)\n\t\t\tud_putcs_aligned(vc, info, s, attribute, cnt, pitch,\n\t\t\t\t\t width, cellsize, &image, buf, dst);\n\t\telse\n\t\t\tud_putcs_unaligned(vc, info, s, attribute, cnt, pitch,\n\t\t\t\t\t   width, cellsize, &image,\n\t\t\t\t\t   buf, dst);\n\n\t\timage.dx += image.width;\n\t\tcount -= cnt;\n\t\ts -= cnt;\n\t\txx += cnt;\n\t}\n\n\t \n\tif (unlikely(buf))\n\t\tkfree(buf);\n\n}\n\nstatic void ud_clear_margins(struct vc_data *vc, struct fb_info *info,\n\t\t\t     int color, int bottom_only)\n{\n\tunsigned int cw = vc->vc_font.width;\n\tunsigned int ch = vc->vc_font.height;\n\tunsigned int rw = info->var.xres - (vc->vc_cols*cw);\n\tunsigned int bh = info->var.yres - (vc->vc_rows*ch);\n\tstruct fb_fillrect region;\n\n\tregion.color = color;\n\tregion.rop = ROP_COPY;\n\n\tif ((int) rw > 0 && !bottom_only) {\n\t\tregion.dy = 0;\n\t\tregion.dx = info->var.xoffset;\n\t\tregion.width  = rw;\n\t\tregion.height = info->var.yres_virtual;\n\t\tinfo->fbops->fb_fillrect(info, &region);\n\t}\n\n\tif ((int) bh > 0) {\n\t\tregion.dy = info->var.yoffset;\n\t\tregion.dx = info->var.xoffset;\n                region.height  = bh;\n                region.width = info->var.xres;\n\t\tinfo->fbops->fb_fillrect(info, &region);\n\t}\n}\n\nstatic void ud_cursor(struct vc_data *vc, struct fb_info *info, int mode,\n\t\t      int fg, int bg)\n{\n\tstruct fb_cursor cursor;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tunsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\n\tint w = (vc->vc_font.width + 7) >> 3, c;\n\tint y = real_y(ops->p, vc->state.y);\n\tint attribute, use_sw = vc->vc_cursor_type & CUR_SW;\n\tint err = 1, dx, dy;\n\tchar *src;\n\tu32 vyres = GETVYRES(ops->p, info);\n\tu32 vxres = GETVXRES(ops->p, info);\n\n\tif (!ops->fontbuffer)\n\t\treturn;\n\n\tcursor.set = 0;\n\n \tc = scr_readw((u16 *) vc->vc_pos);\n\tattribute = get_attribute(info, c);\n\tsrc = ops->fontbuffer + ((c & charmask) * (w * vc->vc_font.height));\n\n\tif (ops->cursor_state.image.data != src ||\n\t    ops->cursor_reset) {\n\t    ops->cursor_state.image.data = src;\n\t    cursor.set |= FB_CUR_SETIMAGE;\n\t}\n\n\tif (attribute) {\n\t\tu8 *dst;\n\n\t\tdst = kmalloc_array(w, vc->vc_font.height, GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\treturn;\n\t\tkfree(ops->cursor_data);\n\t\tops->cursor_data = dst;\n\t\tud_update_attr(dst, src, attribute, vc);\n\t\tsrc = dst;\n\t}\n\n\tif (ops->cursor_state.image.fg_color != fg ||\n\t    ops->cursor_state.image.bg_color != bg ||\n\t    ops->cursor_reset) {\n\t\tops->cursor_state.image.fg_color = fg;\n\t\tops->cursor_state.image.bg_color = bg;\n\t\tcursor.set |= FB_CUR_SETCMAP;\n\t}\n\n\tif (ops->cursor_state.image.height != vc->vc_font.height ||\n\t    ops->cursor_state.image.width != vc->vc_font.width ||\n\t    ops->cursor_reset) {\n\t\tops->cursor_state.image.height = vc->vc_font.height;\n\t\tops->cursor_state.image.width = vc->vc_font.width;\n\t\tcursor.set |= FB_CUR_SETSIZE;\n\t}\n\n\tdy = vyres - ((y * vc->vc_font.height) + vc->vc_font.height);\n\tdx = vxres - ((vc->state.x * vc->vc_font.width) + vc->vc_font.width);\n\n\tif (ops->cursor_state.image.dx != dx ||\n\t    ops->cursor_state.image.dy != dy ||\n\t    ops->cursor_reset) {\n\t\tops->cursor_state.image.dx = dx;\n\t\tops->cursor_state.image.dy = dy;\n\t\tcursor.set |= FB_CUR_SETPOS;\n\t}\n\n\tif (ops->cursor_state.hot.x || ops->cursor_state.hot.y ||\n\t    ops->cursor_reset) {\n\t\tops->cursor_state.hot.x = cursor.hot.y = 0;\n\t\tcursor.set |= FB_CUR_SETHOT;\n\t}\n\n\tif (cursor.set & FB_CUR_SETSIZE ||\n\t    vc->vc_cursor_type != ops->p->cursor_shape ||\n\t    ops->cursor_state.mask == NULL ||\n\t    ops->cursor_reset) {\n\t\tchar *mask = kmalloc_array(w, vc->vc_font.height, GFP_ATOMIC);\n\t\tint cur_height, size, i = 0;\n\t\tu8 msk = 0xff;\n\n\t\tif (!mask)\n\t\t\treturn;\n\n\t\tkfree(ops->cursor_state.mask);\n\t\tops->cursor_state.mask = mask;\n\n\t\tops->p->cursor_shape = vc->vc_cursor_type;\n\t\tcursor.set |= FB_CUR_SETSHAPE;\n\n\t\tswitch (CUR_SIZE(ops->p->cursor_shape)) {\n\t\tcase CUR_NONE:\n\t\t\tcur_height = 0;\n\t\t\tbreak;\n\t\tcase CUR_UNDERLINE:\n\t\t\tcur_height = (vc->vc_font.height < 10) ? 1 : 2;\n\t\t\tbreak;\n\t\tcase CUR_LOWER_THIRD:\n\t\t\tcur_height = vc->vc_font.height/3;\n\t\t\tbreak;\n\t\tcase CUR_LOWER_HALF:\n\t\t\tcur_height = vc->vc_font.height >> 1;\n\t\t\tbreak;\n\t\tcase CUR_TWO_THIRDS:\n\t\t\tcur_height = (vc->vc_font.height << 1)/3;\n\t\t\tbreak;\n\t\tcase CUR_BLOCK:\n\t\tdefault:\n\t\t\tcur_height = vc->vc_font.height;\n\t\t\tbreak;\n\t\t}\n\n\t\tsize = cur_height * w;\n\n\t\twhile (size--)\n\t\t\tmask[i++] = msk;\n\n\t\tsize = (vc->vc_font.height - cur_height) * w;\n\n\t\twhile (size--)\n\t\t\tmask[i++] = ~msk;\n\t}\n\n\tswitch (mode) {\n\tcase CM_ERASE:\n\t\tops->cursor_state.enable = 0;\n\t\tbreak;\n\tcase CM_DRAW:\n\tcase CM_MOVE:\n\tdefault:\n\t\tops->cursor_state.enable = (use_sw) ? 0 : 1;\n\t\tbreak;\n\t}\n\n\tcursor.image.data = src;\n\tcursor.image.fg_color = ops->cursor_state.image.fg_color;\n\tcursor.image.bg_color = ops->cursor_state.image.bg_color;\n\tcursor.image.dx = ops->cursor_state.image.dx;\n\tcursor.image.dy = ops->cursor_state.image.dy;\n\tcursor.image.height = ops->cursor_state.image.height;\n\tcursor.image.width = ops->cursor_state.image.width;\n\tcursor.hot.x = ops->cursor_state.hot.x;\n\tcursor.hot.y = ops->cursor_state.hot.y;\n\tcursor.mask = ops->cursor_state.mask;\n\tcursor.enable = ops->cursor_state.enable;\n\tcursor.image.depth = 1;\n\tcursor.rop = ROP_XOR;\n\n\tif (info->fbops->fb_cursor)\n\t\terr = info->fbops->fb_cursor(info, &cursor);\n\n\tif (err)\n\t\tsoft_cursor(info, &cursor);\n\n\tops->cursor_reset = 0;\n}\n\nstatic int ud_update_start(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint xoffset, yoffset;\n\tu32 vyres = GETVYRES(ops->p, info);\n\tu32 vxres = GETVXRES(ops->p, info);\n\tint err;\n\n\txoffset = vxres - info->var.xres - ops->var.xoffset;\n\tyoffset = vyres - info->var.yres - ops->var.yoffset;\n\tif (yoffset < 0)\n\t\tyoffset += vyres;\n\tops->var.xoffset = xoffset;\n\tops->var.yoffset = yoffset;\n\terr = fb_pan_display(info, &ops->var);\n\tops->var.xoffset = info->var.xoffset;\n\tops->var.yoffset = info->var.yoffset;\n\tops->var.vmode = info->var.vmode;\n\treturn err;\n}\n\nvoid fbcon_rotate_ud(struct fbcon_ops *ops)\n{\n\tops->bmove = ud_bmove;\n\tops->clear = ud_clear;\n\tops->putcs = ud_putcs;\n\tops->clear_margins = ud_clear_margins;\n\tops->cursor = ud_cursor;\n\tops->update_start = ud_update_start;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}