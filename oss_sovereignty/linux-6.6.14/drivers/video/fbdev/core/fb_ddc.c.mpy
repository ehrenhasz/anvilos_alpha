{
  "module_name": "fb_ddc.c",
  "hash_id": "d29076eea9d46870a0d2b6d819c08957dc496adee00f0df01be123bc7f973fa7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/core/fb_ddc.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/fb.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/slab.h>\n\n#include \"../edid.h\"\n\n#define DDC_ADDR\t0x50\n\nstatic unsigned char *fb_do_probe_ddc_edid(struct i2c_adapter *adapter)\n{\n\tunsigned char start = 0x0;\n\tunsigned char *buf = kmalloc(EDID_LENGTH, GFP_KERNEL);\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr\t= DDC_ADDR,\n\t\t\t.flags\t= 0,\n\t\t\t.len\t= 1,\n\t\t\t.buf\t= &start,\n\t\t}, {\n\t\t\t.addr\t= DDC_ADDR,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= EDID_LENGTH,\n\t\t\t.buf\t= buf,\n\t\t}\n\t};\n\n\tif (!buf) {\n\t\tdev_warn(&adapter->dev, \"unable to allocate memory for EDID \"\n\t\t\t \"block.\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (i2c_transfer(adapter, msgs, 2) == 2)\n\t\treturn buf;\n\n\tdev_warn(&adapter->dev, \"unable to read EDID block.\\n\");\n\tkfree(buf);\n\treturn NULL;\n}\n\nunsigned char *fb_ddc_read(struct i2c_adapter *adapter)\n{\n\tstruct i2c_algo_bit_data *algo_data = adapter->algo_data;\n\tunsigned char *edid = NULL;\n\tint i, j;\n\n\talgo_data->setscl(algo_data->data, 1);\n\n\tfor (i = 0; i < 3; i++) {\n\t\t \n\t\talgo_data->setsda(algo_data->data, 1);\n\t\tmsleep(13);\n\n\t\talgo_data->setscl(algo_data->data, 1);\n\t\tif (algo_data->getscl) {\n\t\t\tfor (j = 0; j < 5; j++) {\n\t\t\t\tmsleep(10);\n\t\t\t\tif (algo_data->getscl(algo_data->data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j == 5)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tudelay(algo_data->udelay);\n\t\t}\n\n\t\talgo_data->setsda(algo_data->data, 0);\n\t\tmsleep(15);\n\t\talgo_data->setscl(algo_data->data, 0);\n\t\tmsleep(15);\n\t\talgo_data->setsda(algo_data->data, 1);\n\t\tmsleep(15);\n\n\t\t \n\t\tedid = fb_do_probe_ddc_edid(adapter);\n\t\talgo_data->setsda(algo_data->data, 0);\n\t\talgo_data->setscl(algo_data->data, 0);\n\t\tmsleep(15);\n\n\t\talgo_data->setscl(algo_data->data, 1);\n\t\tif (algo_data->getscl) {\n\t\t\tfor (j = 0; j < 10; j++) {\n\t\t\t\tmsleep(10);\n\t\t\t\tif (algo_data->getscl(algo_data->data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tudelay(algo_data->udelay);\n\t\t}\n\n\t\talgo_data->setsda(algo_data->data, 1);\n\t\tmsleep(15);\n\t\talgo_data->setscl(algo_data->data, 0);\n\t\talgo_data->setsda(algo_data->data, 0);\n\t\tif (edid)\n\t\t\tbreak;\n\t}\n\t \n\talgo_data->setsda(algo_data->data, 1);\n\talgo_data->setscl(algo_data->data, 1);\n\n\tadapter->class |= I2C_CLASS_DDC;\n\treturn edid;\n}\n\nEXPORT_SYMBOL_GPL(fb_ddc_read);\n\nMODULE_AUTHOR(\"Dennis Munsie <dmunsie@cecropia.com>\");\nMODULE_DESCRIPTION(\"DDC/EDID reading support\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}