{
  "module_name": "fbmon.c",
  "hash_id": "3a23017c136e7d5ae8ce000e03acd6e273ac0107e52ad5ccc945e9f276e08a1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/core/fbmon.c",
  "human_readable_source": " \n#include <linux/fb.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <video/edid.h>\n#include <video/of_videomode.h>\n#include <video/videomode.h>\n#include \"../edid.h\"\n\n \n\n#undef DEBUG   \n\n#ifdef DEBUG\n#define DPRINTK(fmt, args...) printk(fmt,## args)\n#else\n#define DPRINTK(fmt, args...) no_printk(fmt, ##args)\n#endif\n\n#define FBMON_FIX_HEADER  1\n#define FBMON_FIX_INPUT   2\n#define FBMON_FIX_TIMINGS 3\n\n#ifdef CONFIG_FB_MODE_HELPERS\nstruct broken_edid {\n\tu8  manufacturer[4];\n\tu32 model;\n\tu32 fix;\n};\n\nstatic const struct broken_edid brokendb[] = {\n\t \n\t{\n\t\t.manufacturer = \"DEC\",\n\t\t.model        = 0x073a,\n\t\t.fix          = FBMON_FIX_HEADER,\n\t},\n\t \n\t{\n\t\t.manufacturer = \"VSC\",\n\t\t.model        = 0x5a44,\n\t\t.fix          = FBMON_FIX_INPUT,\n\t},\n\t \n\t{\n\t\t.manufacturer = \"SHP\",\n\t\t.model        = 0x138e,\n\t\t.fix          = FBMON_FIX_TIMINGS,\n\t},\n};\n\nstatic const unsigned char edid_v1_header[] = { 0x00, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0x00\n};\n\nstatic void copy_string(unsigned char *c, unsigned char *s)\n{\n  int i;\n  c = c + 5;\n  for (i = 0; (i < 13 && *c != 0x0A); i++)\n    *(s++) = *(c++);\n  *s = 0;\n  while (i-- && (*--s == 0x20)) *s = 0;\n}\n\nstatic int edid_is_serial_block(unsigned char *block)\n{\n\tif ((block[0] == 0x00) && (block[1] == 0x00) &&\n\t    (block[2] == 0x00) && (block[3] == 0xff) &&\n\t    (block[4] == 0x00))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int edid_is_ascii_block(unsigned char *block)\n{\n\tif ((block[0] == 0x00) && (block[1] == 0x00) &&\n\t    (block[2] == 0x00) && (block[3] == 0xfe) &&\n\t    (block[4] == 0x00))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int edid_is_limits_block(unsigned char *block)\n{\n\tif ((block[0] == 0x00) && (block[1] == 0x00) &&\n\t    (block[2] == 0x00) && (block[3] == 0xfd) &&\n\t    (block[4] == 0x00))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int edid_is_monitor_block(unsigned char *block)\n{\n\tif ((block[0] == 0x00) && (block[1] == 0x00) &&\n\t    (block[2] == 0x00) && (block[3] == 0xfc) &&\n\t    (block[4] == 0x00))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int edid_is_timing_block(unsigned char *block)\n{\n\tif ((block[0] != 0x00) || (block[1] != 0x00) ||\n\t    (block[2] != 0x00) || (block[4] != 0x00))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int check_edid(unsigned char *edid)\n{\n\tunsigned char *block = edid + ID_MANUFACTURER_NAME, manufacturer[4];\n\tunsigned char *b;\n\tu32 model;\n\tint i, fix = 0, ret = 0;\n\n\tmanufacturer[0] = ((block[0] & 0x7c) >> 2) + '@';\n\tmanufacturer[1] = ((block[0] & 0x03) << 3) +\n\t\t((block[1] & 0xe0) >> 5) + '@';\n\tmanufacturer[2] = (block[1] & 0x1f) + '@';\n\tmanufacturer[3] = 0;\n\tmodel = block[2] + (block[3] << 8);\n\n\tfor (i = 0; i < ARRAY_SIZE(brokendb); i++) {\n\t\tif (!strncmp(manufacturer, brokendb[i].manufacturer, 4) &&\n\t\t\tbrokendb[i].model == model) {\n\t\t\tfix = brokendb[i].fix;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (fix) {\n\tcase FBMON_FIX_HEADER:\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (edid[i] != edid_v1_header[i]) {\n\t\t\t\tret = fix;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase FBMON_FIX_INPUT:\n\t\tb = edid + EDID_STRUCT_DISPLAY;\n\t\t \n\t\tif (b[4] & 0x01 && b[0] & 0x80)\n\t\t\tret = fix;\n\t\tbreak;\n\tcase FBMON_FIX_TIMINGS:\n\t\tb = edid + DETAILED_TIMING_DESCRIPTIONS_START;\n\t\tret = fix;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (edid_is_limits_block(b)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tb += DETAILED_TIMING_DESCRIPTION_SIZE;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tprintk(\"fbmon: The EDID Block of \"\n\t\t       \"Manufacturer: %s Model: 0x%x is known to \"\n\t\t       \"be broken,\\n\",  manufacturer, model);\n\n\treturn ret;\n}\n\nstatic void fix_edid(unsigned char *edid, int fix)\n{\n\tint i;\n\tunsigned char *b, csum = 0;\n\n\tswitch (fix) {\n\tcase FBMON_FIX_HEADER:\n\t\tprintk(\"fbmon: trying a header reconstruct\\n\");\n\t\tmemcpy(edid, edid_v1_header, 8);\n\t\tbreak;\n\tcase FBMON_FIX_INPUT:\n\t\tprintk(\"fbmon: trying to fix input type\\n\");\n\t\tb = edid + EDID_STRUCT_DISPLAY;\n\t\tb[0] &= ~0x80;\n\t\tedid[127] += 0x80;\n\t\tbreak;\n\tcase FBMON_FIX_TIMINGS:\n\t\tprintk(\"fbmon: trying to fix monitor timings\\n\");\n\t\tb = edid + DETAILED_TIMING_DESCRIPTIONS_START;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (!(edid_is_serial_block(b) ||\n\t\t\t      edid_is_ascii_block(b) ||\n\t\t\t      edid_is_monitor_block(b) ||\n\t\t\t      edid_is_timing_block(b))) {\n\t\t\t\tb[0] = 0x00;\n\t\t\t\tb[1] = 0x00;\n\t\t\t\tb[2] = 0x00;\n\t\t\t\tb[3] = 0xfd;\n\t\t\t\tb[4] = 0x00;\n\t\t\t\tb[5] = 60;    \n\t\t\t\tb[6] = 60;    \n\t\t\t\tb[7] = 30;    \n\t\t\t\tb[8] = 75;    \n\t\t\t\tb[9] = 17;    \n\t\t\t\tb[10] = 0;    \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tb += DETAILED_TIMING_DESCRIPTION_SIZE;\n\t\t}\n\n\t\tfor (i = 0; i < EDID_LENGTH - 1; i++)\n\t\t\tcsum += edid[i];\n\n\t\tedid[127] = 256 - csum;\n\t\tbreak;\n\t}\n}\n\nstatic int edid_checksum(unsigned char *edid)\n{\n\tunsigned char csum = 0, all_null = 0;\n\tint i, err = 0, fix = check_edid(edid);\n\n\tif (fix)\n\t\tfix_edid(edid, fix);\n\n\tfor (i = 0; i < EDID_LENGTH; i++) {\n\t\tcsum += edid[i];\n\t\tall_null |= edid[i];\n\t}\n\n\tif (csum == 0x00 && all_null) {\n\t\t \n\t\terr = 1;\n\t}\n\n\treturn err;\n}\n\nstatic int edid_check_header(unsigned char *edid)\n{\n\tint i, err = 1, fix = check_edid(edid);\n\n\tif (fix)\n\t\tfix_edid(edid, fix);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (edid[i] != edid_v1_header[i])\n\t\t\terr = 0;\n\t}\n\n\treturn err;\n}\n\nstatic void parse_vendor_block(unsigned char *block, struct fb_monspecs *specs)\n{\n\tspecs->manufacturer[0] = ((block[0] & 0x7c) >> 2) + '@';\n\tspecs->manufacturer[1] = ((block[0] & 0x03) << 3) +\n\t\t((block[1] & 0xe0) >> 5) + '@';\n\tspecs->manufacturer[2] = (block[1] & 0x1f) + '@';\n\tspecs->manufacturer[3] = 0;\n\tspecs->model = block[2] + (block[3] << 8);\n\tspecs->serial = block[4] + (block[5] << 8) +\n\t       (block[6] << 16) + (block[7] << 24);\n\tspecs->year = block[9] + 1990;\n\tspecs->week = block[8];\n\tDPRINTK(\"   Manufacturer: %s\\n\", specs->manufacturer);\n\tDPRINTK(\"   Model: %x\\n\", specs->model);\n\tDPRINTK(\"   Serial#: %u\\n\", specs->serial);\n\tDPRINTK(\"   Year: %u Week %u\\n\", specs->year, specs->week);\n}\n\nstatic void get_dpms_capabilities(unsigned char flags,\n\t\t\t\t  struct fb_monspecs *specs)\n{\n\tspecs->dpms = 0;\n\tif (flags & DPMS_ACTIVE_OFF)\n\t\tspecs->dpms |= FB_DPMS_ACTIVE_OFF;\n\tif (flags & DPMS_SUSPEND)\n\t\tspecs->dpms |= FB_DPMS_SUSPEND;\n\tif (flags & DPMS_STANDBY)\n\t\tspecs->dpms |= FB_DPMS_STANDBY;\n\tDPRINTK(\"      DPMS: Active %s, Suspend %s, Standby %s\\n\",\n\t       (flags & DPMS_ACTIVE_OFF) ? \"yes\" : \"no\",\n\t       (flags & DPMS_SUSPEND)    ? \"yes\" : \"no\",\n\t       (flags & DPMS_STANDBY)    ? \"yes\" : \"no\");\n}\n\nstatic void get_chroma(unsigned char *block, struct fb_monspecs *specs)\n{\n\tint tmp;\n\n\tDPRINTK(\"      Chroma\\n\");\n\t \n\ttmp = ((block[5] & (3 << 6)) >> 6) | (block[0x7] << 2);\n\ttmp *= 1000;\n\ttmp += 512;\n\tspecs->chroma.redx = tmp/1024;\n\tDPRINTK(\"         RedX:     0.%03d \", specs->chroma.redx);\n\n\ttmp = ((block[5] & (3 << 4)) >> 4) | (block[0x8] << 2);\n\ttmp *= 1000;\n\ttmp += 512;\n\tspecs->chroma.redy = tmp/1024;\n\tDPRINTK(\"RedY:     0.%03d\\n\", specs->chroma.redy);\n\n\ttmp = ((block[5] & (3 << 2)) >> 2) | (block[0x9] << 2);\n\ttmp *= 1000;\n\ttmp += 512;\n\tspecs->chroma.greenx = tmp/1024;\n\tDPRINTK(\"         GreenX:   0.%03d \", specs->chroma.greenx);\n\n\ttmp = (block[5] & 3) | (block[0xa] << 2);\n\ttmp *= 1000;\n\ttmp += 512;\n\tspecs->chroma.greeny = tmp/1024;\n\tDPRINTK(\"GreenY:   0.%03d\\n\", specs->chroma.greeny);\n\n\ttmp = ((block[6] & (3 << 6)) >> 6) | (block[0xb] << 2);\n\ttmp *= 1000;\n\ttmp += 512;\n\tspecs->chroma.bluex = tmp/1024;\n\tDPRINTK(\"         BlueX:    0.%03d \", specs->chroma.bluex);\n\n\ttmp = ((block[6] & (3 << 4)) >> 4) | (block[0xc] << 2);\n\ttmp *= 1000;\n\ttmp += 512;\n\tspecs->chroma.bluey = tmp/1024;\n\tDPRINTK(\"BlueY:    0.%03d\\n\", specs->chroma.bluey);\n\n\ttmp = ((block[6] & (3 << 2)) >> 2) | (block[0xd] << 2);\n\ttmp *= 1000;\n\ttmp += 512;\n\tspecs->chroma.whitex = tmp/1024;\n\tDPRINTK(\"         WhiteX:   0.%03d \", specs->chroma.whitex);\n\n\ttmp = (block[6] & 3) | (block[0xe] << 2);\n\ttmp *= 1000;\n\ttmp += 512;\n\tspecs->chroma.whitey = tmp/1024;\n\tDPRINTK(\"WhiteY:   0.%03d\\n\", specs->chroma.whitey);\n}\n\nstatic void calc_mode_timings(int xres, int yres, int refresh,\n\t\t\t      struct fb_videomode *mode)\n{\n\tstruct fb_var_screeninfo *var;\n\n\tvar = kzalloc(sizeof(struct fb_var_screeninfo), GFP_KERNEL);\n\n\tif (var) {\n\t\tvar->xres = xres;\n\t\tvar->yres = yres;\n\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON,\n\t\t\t    refresh, var, NULL);\n\t\tmode->xres = xres;\n\t\tmode->yres = yres;\n\t\tmode->pixclock = var->pixclock;\n\t\tmode->refresh = refresh;\n\t\tmode->left_margin = var->left_margin;\n\t\tmode->right_margin = var->right_margin;\n\t\tmode->upper_margin = var->upper_margin;\n\t\tmode->lower_margin = var->lower_margin;\n\t\tmode->hsync_len = var->hsync_len;\n\t\tmode->vsync_len = var->vsync_len;\n\t\tmode->vmode = 0;\n\t\tmode->sync = 0;\n\t\tkfree(var);\n\t}\n}\n\nstatic int get_est_timing(unsigned char *block, struct fb_videomode *mode)\n{\n\tint num = 0;\n\tunsigned char c;\n\n\tc = block[0];\n\tif (c&0x80) {\n\t\tcalc_mode_timings(720, 400, 70, &mode[num]);\n\t\tmode[num++].flag = FB_MODE_IS_CALCULATED;\n\t\tDPRINTK(\"      720x400@70Hz\\n\");\n\t}\n\tif (c&0x40) {\n\t\tcalc_mode_timings(720, 400, 88, &mode[num]);\n\t\tmode[num++].flag = FB_MODE_IS_CALCULATED;\n\t\tDPRINTK(\"      720x400@88Hz\\n\");\n\t}\n\tif (c&0x20) {\n\t\tmode[num++] = vesa_modes[3];\n\t\tDPRINTK(\"      640x480@60Hz\\n\");\n\t}\n\tif (c&0x10) {\n\t\tcalc_mode_timings(640, 480, 67, &mode[num]);\n\t\tmode[num++].flag = FB_MODE_IS_CALCULATED;\n\t\tDPRINTK(\"      640x480@67Hz\\n\");\n\t}\n\tif (c&0x08) {\n\t\tmode[num++] = vesa_modes[4];\n\t\tDPRINTK(\"      640x480@72Hz\\n\");\n\t}\n\tif (c&0x04) {\n\t\tmode[num++] = vesa_modes[5];\n\t\tDPRINTK(\"      640x480@75Hz\\n\");\n\t}\n\tif (c&0x02) {\n\t\tmode[num++] = vesa_modes[7];\n\t\tDPRINTK(\"      800x600@56Hz\\n\");\n\t}\n\tif (c&0x01) {\n\t\tmode[num++] = vesa_modes[8];\n\t\tDPRINTK(\"      800x600@60Hz\\n\");\n\t}\n\n\tc = block[1];\n\tif (c&0x80) {\n\t\tmode[num++] = vesa_modes[9];\n\t\tDPRINTK(\"      800x600@72Hz\\n\");\n\t}\n\tif (c&0x40) {\n\t\tmode[num++] = vesa_modes[10];\n\t\tDPRINTK(\"      800x600@75Hz\\n\");\n\t}\n\tif (c&0x20) {\n\t\tcalc_mode_timings(832, 624, 75, &mode[num]);\n\t\tmode[num++].flag = FB_MODE_IS_CALCULATED;\n\t\tDPRINTK(\"      832x624@75Hz\\n\");\n\t}\n\tif (c&0x10) {\n\t\tmode[num++] = vesa_modes[12];\n\t\tDPRINTK(\"      1024x768@87Hz Interlaced\\n\");\n\t}\n\tif (c&0x08) {\n\t\tmode[num++] = vesa_modes[13];\n\t\tDPRINTK(\"      1024x768@60Hz\\n\");\n\t}\n\tif (c&0x04) {\n\t\tmode[num++] = vesa_modes[14];\n\t\tDPRINTK(\"      1024x768@70Hz\\n\");\n\t}\n\tif (c&0x02) {\n\t\tmode[num++] = vesa_modes[15];\n\t\tDPRINTK(\"      1024x768@75Hz\\n\");\n\t}\n\tif (c&0x01) {\n\t\tmode[num++] = vesa_modes[21];\n\t\tDPRINTK(\"      1280x1024@75Hz\\n\");\n\t}\n\tc = block[2];\n\tif (c&0x80) {\n\t\tmode[num++] = vesa_modes[17];\n\t\tDPRINTK(\"      1152x870@75Hz\\n\");\n\t}\n\tDPRINTK(\"      Manufacturer's mask: %x\\n\",c&0x7F);\n\treturn num;\n}\n\nstatic int get_std_timing(unsigned char *block, struct fb_videomode *mode,\n\t\t\t  int ver, int rev, const struct fb_monspecs *specs)\n{\n\tint i;\n\n\tfor (i = 0; i < DMT_SIZE; i++) {\n\t\tu32 std_2byte_code = block[0] << 8 | block[1];\n\t\tif (std_2byte_code == dmt_modes[i].std_2byte_code)\n\t\t\tbreak;\n\t}\n\n\tif (i < DMT_SIZE && dmt_modes[i].mode) {\n\t\t \n\t\t*mode = *dmt_modes[i].mode;\n\t\tmode->flag |= FB_MODE_IS_STANDARD;\n\t\tDPRINTK(\"        DMT id=%d\\n\", dmt_modes[i].dmt_id);\n\n\t} else {\n\t\tint xres, yres = 0, refresh, ratio;\n\n\t\txres = (block[0] + 31) * 8;\n\t\tif (xres <= 256)\n\t\t\treturn 0;\n\n\t\tratio = (block[1] & 0xc0) >> 6;\n\t\tswitch (ratio) {\n\t\tcase 0:\n\t\t\t \n\t\t\tif (ver < 1 || (ver == 1 && rev < 3))\n\t\t\t\tyres = xres;\n\t\t\telse\n\t\t\t\tyres = (xres * 10)/16;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tyres = (xres * 3)/4;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tyres = (xres * 4)/5;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tyres = (xres * 9)/16;\n\t\t\tbreak;\n\t\t}\n\t\trefresh = (block[1] & 0x3f) + 60;\n\t\tDPRINTK(\"      %dx%d@%dHz\\n\", xres, yres, refresh);\n\n\t\tcalc_mode_timings(xres, yres, refresh, mode);\n\t}\n\n\t \n\tif (specs && specs->dclkmax\n\t    && PICOS2KHZ(mode->pixclock) * 1000 > specs->dclkmax) {\n\t\tDPRINTK(\"        mode exceed max DCLK\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int get_dst_timing(unsigned char *block, struct fb_videomode *mode,\n\t\t\t  int ver, int rev, const struct fb_monspecs *specs)\n{\n\tint j, num = 0;\n\n\tfor (j = 0; j < 6; j++, block += STD_TIMING_DESCRIPTION_SIZE)\n\t\tnum += get_std_timing(block, &mode[num], ver, rev, specs);\n\n\treturn num;\n}\n\nstatic void get_detailed_timing(unsigned char *block,\n\t\t\t\tstruct fb_videomode *mode)\n{\n\tmode->xres = H_ACTIVE;\n\tmode->yres = V_ACTIVE;\n\tmode->pixclock = PIXEL_CLOCK;\n\tmode->pixclock /= 1000;\n\tmode->pixclock = KHZ2PICOS(mode->pixclock);\n\tmode->right_margin = H_SYNC_OFFSET;\n\tmode->left_margin = (H_ACTIVE + H_BLANKING) -\n\t\t(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);\n\tmode->upper_margin = V_BLANKING - V_SYNC_OFFSET -\n\t\tV_SYNC_WIDTH;\n\tmode->lower_margin = V_SYNC_OFFSET;\n\tmode->hsync_len = H_SYNC_WIDTH;\n\tmode->vsync_len = V_SYNC_WIDTH;\n\tif (HSYNC_POSITIVE)\n\t\tmode->sync |= FB_SYNC_HOR_HIGH_ACT;\n\tif (VSYNC_POSITIVE)\n\t\tmode->sync |= FB_SYNC_VERT_HIGH_ACT;\n\tmode->refresh = PIXEL_CLOCK/((H_ACTIVE + H_BLANKING) *\n\t\t\t\t     (V_ACTIVE + V_BLANKING));\n\tif (INTERLACED) {\n\t\tmode->yres *= 2;\n\t\tmode->upper_margin *= 2;\n\t\tmode->lower_margin *= 2;\n\t\tmode->vsync_len *= 2;\n\t\tmode->vmode |= FB_VMODE_INTERLACED;\n\t}\n\tmode->flag = FB_MODE_IS_DETAILED;\n\n\tDPRINTK(\"      %d MHz \",  PIXEL_CLOCK/1000000);\n\tDPRINTK(\"%d %d %d %d \", H_ACTIVE, H_ACTIVE + H_SYNC_OFFSET,\n\t       H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH, H_ACTIVE + H_BLANKING);\n\tDPRINTK(\"%d %d %d %d \", V_ACTIVE, V_ACTIVE + V_SYNC_OFFSET,\n\t       V_ACTIVE + V_SYNC_OFFSET + V_SYNC_WIDTH, V_ACTIVE + V_BLANKING);\n\tDPRINTK(\"%sHSync %sVSync\\n\\n\", (HSYNC_POSITIVE) ? \"+\" : \"-\",\n\t       (VSYNC_POSITIVE) ? \"+\" : \"-\");\n}\n\n \nstatic struct fb_videomode *fb_create_modedb(unsigned char *edid, int *dbsize,\n\t\t\t\t\t     const struct fb_monspecs *specs)\n{\n\tstruct fb_videomode *mode, *m;\n\tunsigned char *block;\n\tint num = 0, i, first = 1;\n\tint ver, rev;\n\n\tmode = kcalloc(50, sizeof(struct fb_videomode), GFP_KERNEL);\n\tif (mode == NULL)\n\t\treturn NULL;\n\n\tif (edid == NULL || !edid_checksum(edid) ||\n\t    !edid_check_header(edid)) {\n\t\tkfree(mode);\n\t\treturn NULL;\n\t}\n\n\tver = edid[EDID_STRUCT_VERSION];\n\trev = edid[EDID_STRUCT_REVISION];\n\n\t*dbsize = 0;\n\n\tDPRINTK(\"   Detailed Timings\\n\");\n\tblock = edid + DETAILED_TIMING_DESCRIPTIONS_START;\n\tfor (i = 0; i < 4; i++, block+= DETAILED_TIMING_DESCRIPTION_SIZE) {\n\t\tif (!(block[0] == 0x00 && block[1] == 0x00)) {\n\t\t\tget_detailed_timing(block, &mode[num]);\n\t\t\tif (first) {\n\t\t\t        mode[num].flag |= FB_MODE_IS_FIRST;\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tnum++;\n\t\t}\n\t}\n\n\tDPRINTK(\"   Supported VESA Modes\\n\");\n\tblock = edid + ESTABLISHED_TIMING_1;\n\tnum += get_est_timing(block, &mode[num]);\n\n\tDPRINTK(\"   Standard Timings\\n\");\n\tblock = edid + STD_TIMING_DESCRIPTIONS_START;\n\tfor (i = 0; i < STD_TIMING; i++, block += STD_TIMING_DESCRIPTION_SIZE)\n\t\tnum += get_std_timing(block, &mode[num], ver, rev, specs);\n\n\tblock = edid + DETAILED_TIMING_DESCRIPTIONS_START;\n\tfor (i = 0; i < 4; i++, block+= DETAILED_TIMING_DESCRIPTION_SIZE) {\n\t\tif (block[0] == 0x00 && block[1] == 0x00 && block[3] == 0xfa)\n\t\t\tnum += get_dst_timing(block + 5, &mode[num],\n\t\t\t\t\t      ver, rev, specs);\n\t}\n\n\t \n\tif (!num) {\n\t\tkfree(mode);\n\t\treturn NULL;\n\t}\n\n\t*dbsize = num;\n\tm = kmalloc_array(num, sizeof(struct fb_videomode), GFP_KERNEL);\n\tif (!m)\n\t\treturn mode;\n\tmemmove(m, mode, num * sizeof(struct fb_videomode));\n\tkfree(mode);\n\treturn m;\n}\n\n \nvoid fb_destroy_modedb(struct fb_videomode *modedb)\n{\n\tkfree(modedb);\n}\n\nstatic int fb_get_monitor_limits(unsigned char *edid, struct fb_monspecs *specs)\n{\n\tint i, retval = 1;\n\tunsigned char *block;\n\n\tblock = edid + DETAILED_TIMING_DESCRIPTIONS_START;\n\n\tDPRINTK(\"      Monitor Operating Limits: \");\n\n\tfor (i = 0; i < 4; i++, block += DETAILED_TIMING_DESCRIPTION_SIZE) {\n\t\tif (edid_is_limits_block(block)) {\n\t\t\tspecs->hfmin = H_MIN_RATE * 1000;\n\t\t\tspecs->hfmax = H_MAX_RATE * 1000;\n\t\t\tspecs->vfmin = V_MIN_RATE;\n\t\t\tspecs->vfmax = V_MAX_RATE;\n\t\t\tspecs->dclkmax = MAX_PIXEL_CLOCK * 1000000;\n\t\t\tspecs->gtf = (GTF_SUPPORT) ? 1 : 0;\n\t\t\tretval = 0;\n\t\t\tDPRINTK(\"From EDID\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (retval) {\n\t\tstruct fb_videomode *modes, *mode;\n\t\tint num_modes, hz, hscan, pixclock;\n\t\tint vtotal, htotal;\n\n\t\tmodes = fb_create_modedb(edid, &num_modes, specs);\n\t\tif (!modes) {\n\t\t\tDPRINTK(\"None Available\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tretval = 0;\n\t\tfor (i = 0; i < num_modes; i++) {\n\t\t\tmode = &modes[i];\n\t\t\tpixclock = PICOS2KHZ(modes[i].pixclock) * 1000;\n\t\t\thtotal = mode->xres + mode->right_margin + mode->hsync_len\n\t\t\t\t+ mode->left_margin;\n\t\t\tvtotal = mode->yres + mode->lower_margin + mode->vsync_len\n\t\t\t\t+ mode->upper_margin;\n\n\t\t\tif (mode->vmode & FB_VMODE_INTERLACED)\n\t\t\t\tvtotal /= 2;\n\n\t\t\tif (mode->vmode & FB_VMODE_DOUBLE)\n\t\t\t\tvtotal *= 2;\n\n\t\t\thscan = (pixclock + htotal / 2) / htotal;\n\t\t\thscan = (hscan + 500) / 1000 * 1000;\n\t\t\thz = (hscan + vtotal / 2) / vtotal;\n\n\t\t\tif (specs->dclkmax == 0 || specs->dclkmax < pixclock)\n\t\t\t\tspecs->dclkmax = pixclock;\n\n\t\t\tif (specs->dclkmin == 0 || specs->dclkmin > pixclock)\n\t\t\t\tspecs->dclkmin = pixclock;\n\n\t\t\tif (specs->hfmax == 0 || specs->hfmax < hscan)\n\t\t\t\tspecs->hfmax = hscan;\n\n\t\t\tif (specs->hfmin == 0 || specs->hfmin > hscan)\n\t\t\t\tspecs->hfmin = hscan;\n\n\t\t\tif (specs->vfmax == 0 || specs->vfmax < hz)\n\t\t\t\tspecs->vfmax = hz;\n\n\t\t\tif (specs->vfmin == 0 || specs->vfmin > hz)\n\t\t\t\tspecs->vfmin = hz;\n\t\t}\n\t\tDPRINTK(\"Extrapolated\\n\");\n\t\tfb_destroy_modedb(modes);\n\t}\n\tDPRINTK(\"           H: %d-%dKHz V: %d-%dHz DCLK: %dMHz\\n\",\n\t\tspecs->hfmin/1000, specs->hfmax/1000, specs->vfmin,\n\t\tspecs->vfmax, specs->dclkmax/1000000);\n\treturn retval;\n}\n\nstatic void get_monspecs(unsigned char *edid, struct fb_monspecs *specs)\n{\n\tunsigned char c, *block;\n\n\tblock = edid + EDID_STRUCT_DISPLAY;\n\n\tfb_get_monitor_limits(edid, specs);\n\n\tc = block[0] & 0x80;\n\tspecs->input = 0;\n\tif (c) {\n\t\tspecs->input |= FB_DISP_DDI;\n\t\tDPRINTK(\"      Digital Display Input\");\n\t} else {\n\t\tDPRINTK(\"      Analog Display Input: Input Voltage - \");\n\t\tswitch ((block[0] & 0x60) >> 5) {\n\t\tcase 0:\n\t\t\tDPRINTK(\"0.700V/0.300V\");\n\t\t\tspecs->input |= FB_DISP_ANA_700_300;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tDPRINTK(\"0.714V/0.286V\");\n\t\t\tspecs->input |= FB_DISP_ANA_714_286;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tDPRINTK(\"1.000V/0.400V\");\n\t\t\tspecs->input |= FB_DISP_ANA_1000_400;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tDPRINTK(\"0.700V/0.000V\");\n\t\t\tspecs->input |= FB_DISP_ANA_700_000;\n\t\t\tbreak;\n\t\t}\n\t}\n\tDPRINTK(\"\\n      Sync: \");\n\tc = block[0] & 0x10;\n\tif (c)\n\t\tDPRINTK(\"      Configurable signal level\\n\");\n\tc = block[0] & 0x0f;\n\tspecs->signal = 0;\n\tif (c & 0x10) {\n\t\tDPRINTK(\"Blank to Blank \");\n\t\tspecs->signal |= FB_SIGNAL_BLANK_BLANK;\n\t}\n\tif (c & 0x08) {\n\t\tDPRINTK(\"Separate \");\n\t\tspecs->signal |= FB_SIGNAL_SEPARATE;\n\t}\n\tif (c & 0x04) {\n\t\tDPRINTK(\"Composite \");\n\t\tspecs->signal |= FB_SIGNAL_COMPOSITE;\n\t}\n\tif (c & 0x02) {\n\t\tDPRINTK(\"Sync on Green \");\n\t\tspecs->signal |= FB_SIGNAL_SYNC_ON_GREEN;\n\t}\n\tif (c & 0x01) {\n\t\tDPRINTK(\"Serration on \");\n\t\tspecs->signal |= FB_SIGNAL_SERRATION_ON;\n\t}\n\tDPRINTK(\"\\n\");\n\tspecs->max_x = block[1];\n\tspecs->max_y = block[2];\n\tDPRINTK(\"      Max H-size in cm: \");\n\tif (specs->max_x)\n\t\tDPRINTK(\"%d\\n\", specs->max_x);\n\telse\n\t\tDPRINTK(\"variable\\n\");\n\tDPRINTK(\"      Max V-size in cm: \");\n\tif (specs->max_y)\n\t\tDPRINTK(\"%d\\n\", specs->max_y);\n\telse\n\t\tDPRINTK(\"variable\\n\");\n\n\tc = block[3];\n\tspecs->gamma = c+100;\n\tDPRINTK(\"      Gamma: \");\n\tDPRINTK(\"%d.%d\\n\", specs->gamma/100, specs->gamma % 100);\n\n\tget_dpms_capabilities(block[4], specs);\n\n\tswitch ((block[4] & 0x18) >> 3) {\n\tcase 0:\n\t\tDPRINTK(\"      Monochrome/Grayscale\\n\");\n\t\tspecs->input |= FB_DISP_MONO;\n\t\tbreak;\n\tcase 1:\n\t\tDPRINTK(\"      RGB Color Display\\n\");\n\t\tspecs->input |= FB_DISP_RGB;\n\t\tbreak;\n\tcase 2:\n\t\tDPRINTK(\"      Non-RGB Multicolor Display\\n\");\n\t\tspecs->input |= FB_DISP_MULTI;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTK(\"      Unknown\\n\");\n\t\tspecs->input |= FB_DISP_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tget_chroma(block, specs);\n\n\tspecs->misc = 0;\n\tc = block[4] & 0x7;\n\tif (c & 0x04) {\n\t\tDPRINTK(\"      Default color format is primary\\n\");\n\t\tspecs->misc |= FB_MISC_PRIM_COLOR;\n\t}\n\tif (c & 0x02) {\n\t\tDPRINTK(\"      First DETAILED Timing is preferred\\n\");\n\t\tspecs->misc |= FB_MISC_1ST_DETAIL;\n\t}\n\tif (c & 0x01) {\n\t\tprintk(\"      Display is GTF capable\\n\");\n\t\tspecs->gtf = 1;\n\t}\n}\n\nint fb_parse_edid(unsigned char *edid, struct fb_var_screeninfo *var)\n{\n\tint i;\n\tunsigned char *block;\n\n\tif (edid == NULL || var == NULL)\n\t\treturn 1;\n\n\tif (!(edid_checksum(edid)))\n\t\treturn 1;\n\n\tif (!(edid_check_header(edid)))\n\t\treturn 1;\n\n\tblock = edid + DETAILED_TIMING_DESCRIPTIONS_START;\n\n\tfor (i = 0; i < 4; i++, block += DETAILED_TIMING_DESCRIPTION_SIZE) {\n\t\tif (edid_is_timing_block(block)) {\n\t\t\tvar->xres = var->xres_virtual = H_ACTIVE;\n\t\t\tvar->yres = var->yres_virtual = V_ACTIVE;\n\t\t\tvar->height = var->width = 0;\n\t\t\tvar->right_margin = H_SYNC_OFFSET;\n\t\t\tvar->left_margin = (H_ACTIVE + H_BLANKING) -\n\t\t\t\t(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);\n\t\t\tvar->upper_margin = V_BLANKING - V_SYNC_OFFSET -\n\t\t\t\tV_SYNC_WIDTH;\n\t\t\tvar->lower_margin = V_SYNC_OFFSET;\n\t\t\tvar->hsync_len = H_SYNC_WIDTH;\n\t\t\tvar->vsync_len = V_SYNC_WIDTH;\n\t\t\tvar->pixclock = PIXEL_CLOCK;\n\t\t\tvar->pixclock /= 1000;\n\t\t\tvar->pixclock = KHZ2PICOS(var->pixclock);\n\n\t\t\tif (HSYNC_POSITIVE)\n\t\t\t\tvar->sync |= FB_SYNC_HOR_HIGH_ACT;\n\t\t\tif (VSYNC_POSITIVE)\n\t\t\t\tvar->sync |= FB_SYNC_VERT_HIGH_ACT;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid fb_edid_to_monspecs(unsigned char *edid, struct fb_monspecs *specs)\n{\n\tunsigned char *block;\n\tint i, found = 0;\n\n\tif (edid == NULL)\n\t\treturn;\n\n\tif (!(edid_checksum(edid)))\n\t\treturn;\n\n\tif (!(edid_check_header(edid)))\n\t\treturn;\n\n\tmemset(specs, 0, sizeof(struct fb_monspecs));\n\n\tspecs->version = edid[EDID_STRUCT_VERSION];\n\tspecs->revision = edid[EDID_STRUCT_REVISION];\n\n\tDPRINTK(\"========================================\\n\");\n\tDPRINTK(\"Display Information (EDID)\\n\");\n\tDPRINTK(\"========================================\\n\");\n\tDPRINTK(\"   EDID Version %d.%d\\n\", (int) specs->version,\n\t       (int) specs->revision);\n\n\tparse_vendor_block(edid + ID_MANUFACTURER_NAME, specs);\n\n\tblock = edid + DETAILED_TIMING_DESCRIPTIONS_START;\n\tfor (i = 0; i < 4; i++, block += DETAILED_TIMING_DESCRIPTION_SIZE) {\n\t\tif (edid_is_serial_block(block)) {\n\t\t\tcopy_string(block, specs->serial_no);\n\t\t\tDPRINTK(\"   Serial Number: %s\\n\", specs->serial_no);\n\t\t} else if (edid_is_ascii_block(block)) {\n\t\t\tcopy_string(block, specs->ascii);\n\t\t\tDPRINTK(\"   ASCII Block: %s\\n\", specs->ascii);\n\t\t} else if (edid_is_monitor_block(block)) {\n\t\t\tcopy_string(block, specs->monitor);\n\t\t\tDPRINTK(\"   Monitor Name: %s\\n\", specs->monitor);\n\t\t}\n\t}\n\n\tDPRINTK(\"   Display Characteristics:\\n\");\n\tget_monspecs(edid, specs);\n\n\tspecs->modedb = fb_create_modedb(edid, &specs->modedb_len, specs);\n\tif (!specs->modedb)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < specs->modedb_len; i++) {\n\t\tif (specs->modedb[i].flag & FB_MODE_IS_DETAILED) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tspecs->misc &= ~FB_MISC_1ST_DETAIL;\n\n\tDPRINTK(\"========================================\\n\");\n}\n\n \n\n#define FLYBACK                     550\n#define V_FRONTPORCH                1\n#define H_OFFSET                    40\n#define H_SCALEFACTOR               20\n#define H_BLANKSCALE                128\n#define H_GRADIENT                  600\n#define C_VAL                       30\n#define M_VAL                       300\n\nstruct __fb_timings {\n\tu32 dclk;\n\tu32 hfreq;\n\tu32 vfreq;\n\tu32 hactive;\n\tu32 vactive;\n\tu32 hblank;\n\tu32 vblank;\n\tu32 htotal;\n\tu32 vtotal;\n};\n\n \nstatic u32 fb_get_vblank(u32 hfreq)\n{\n\tu32 vblank;\n\n\tvblank = (hfreq * FLYBACK)/1000;\n\tvblank = (vblank + 500)/1000;\n\treturn (vblank + V_FRONTPORCH);\n}\n\n \nstatic u32 fb_get_hblank_by_hfreq(u32 hfreq, u32 xres)\n{\n\tu32 c_val, m_val, duty_cycle, hblank;\n\n\tc_val = (((H_OFFSET - H_SCALEFACTOR) * H_BLANKSCALE)/256 +\n\t\t H_SCALEFACTOR) * 1000;\n\tm_val = (H_BLANKSCALE * H_GRADIENT)/256;\n\tm_val = (m_val * 1000000)/hfreq;\n\tduty_cycle = c_val - m_val;\n\thblank = (xres * duty_cycle)/(100000 - duty_cycle);\n\treturn (hblank);\n}\n\n \nstatic u32 fb_get_hblank_by_dclk(u32 dclk, u32 xres)\n{\n\tu32 duty_cycle, h_period, hblank;\n\n\tdclk /= 1000;\n\th_period = 100 - C_VAL;\n\th_period *= h_period;\n\th_period += (M_VAL * xres * 2 * 1000)/(5 * dclk);\n\th_period *= 10000;\n\n\th_period = int_sqrt(h_period);\n\th_period -= (100 - C_VAL) * 100;\n\th_period *= 1000;\n\th_period /= 2 * M_VAL;\n\n\tduty_cycle = C_VAL * 1000 - (M_VAL * h_period)/100;\n\thblank = (xres * duty_cycle)/(100000 - duty_cycle) + 8;\n\thblank &= ~15;\n\treturn (hblank);\n}\n\n \n\nstatic u32 fb_get_hfreq(u32 vfreq, u32 yres)\n{\n\tu32 divisor, hfreq;\n\n\tdivisor = (1000000 - (vfreq * FLYBACK))/1000;\n\thfreq = (yres + V_FRONTPORCH) * vfreq  * 1000;\n\treturn (hfreq/divisor);\n}\n\nstatic void fb_timings_vfreq(struct __fb_timings *timings)\n{\n\ttimings->hfreq = fb_get_hfreq(timings->vfreq, timings->vactive);\n\ttimings->vblank = fb_get_vblank(timings->hfreq);\n\ttimings->vtotal = timings->vactive + timings->vblank;\n\ttimings->hblank = fb_get_hblank_by_hfreq(timings->hfreq,\n\t\t\t\t\t\t timings->hactive);\n\ttimings->htotal = timings->hactive + timings->hblank;\n\ttimings->dclk = timings->htotal * timings->hfreq;\n}\n\nstatic void fb_timings_hfreq(struct __fb_timings *timings)\n{\n\ttimings->vblank = fb_get_vblank(timings->hfreq);\n\ttimings->vtotal = timings->vactive + timings->vblank;\n\ttimings->vfreq = timings->hfreq/timings->vtotal;\n\ttimings->hblank = fb_get_hblank_by_hfreq(timings->hfreq,\n\t\t\t\t\t\t timings->hactive);\n\ttimings->htotal = timings->hactive + timings->hblank;\n\ttimings->dclk = timings->htotal * timings->hfreq;\n}\n\nstatic void fb_timings_dclk(struct __fb_timings *timings)\n{\n\ttimings->hblank = fb_get_hblank_by_dclk(timings->dclk,\n\t\t\t\t\t\ttimings->hactive);\n\ttimings->htotal = timings->hactive + timings->hblank;\n\ttimings->hfreq = timings->dclk/timings->htotal;\n\ttimings->vblank = fb_get_vblank(timings->hfreq);\n\ttimings->vtotal = timings->vactive + timings->vblank;\n\ttimings->vfreq = timings->hfreq/timings->vtotal;\n}\n\n \nint fb_get_mode(int flags, u32 val, struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct __fb_timings *timings;\n\tu32 interlace = 1, dscan = 1;\n\tu32 hfmin, hfmax, vfmin, vfmax, dclkmin, dclkmax, err = 0;\n\n\n\ttimings = kzalloc(sizeof(struct __fb_timings), GFP_KERNEL);\n\n\tif (!timings)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!info || !info->monspecs.hfmax || !info->monspecs.vfmax ||\n\t    !info->monspecs.dclkmax ||\n\t    info->monspecs.hfmax < info->monspecs.hfmin ||\n\t    info->monspecs.vfmax < info->monspecs.vfmin ||\n\t    info->monspecs.dclkmax < info->monspecs.dclkmin) {\n\t\thfmin = 29000; hfmax = 30000;\n\t\tvfmin = 60; vfmax = 60;\n\t\tdclkmin = 0; dclkmax = 25000000;\n\t} else {\n\t\thfmin = info->monspecs.hfmin;\n\t\thfmax = info->monspecs.hfmax;\n\t\tvfmin = info->monspecs.vfmin;\n\t\tvfmax = info->monspecs.vfmax;\n\t\tdclkmin = info->monspecs.dclkmin;\n\t\tdclkmax = info->monspecs.dclkmax;\n\t}\n\n\ttimings->hactive = var->xres;\n\ttimings->vactive = var->yres;\n\tif (var->vmode & FB_VMODE_INTERLACED) {\n\t\ttimings->vactive /= 2;\n\t\tinterlace = 2;\n\t}\n\tif (var->vmode & FB_VMODE_DOUBLE) {\n\t\ttimings->vactive *= 2;\n\t\tdscan = 2;\n\t}\n\n\tswitch (flags & ~FB_IGNOREMON) {\n\tcase FB_MAXTIMINGS:  \n\t\ttimings->hfreq = hfmax;\n\t\tfb_timings_hfreq(timings);\n\t\tif (timings->vfreq > vfmax) {\n\t\t\ttimings->vfreq = vfmax;\n\t\t\tfb_timings_vfreq(timings);\n\t\t}\n\t\tif (timings->dclk > dclkmax) {\n\t\t\ttimings->dclk = dclkmax;\n\t\t\tfb_timings_dclk(timings);\n\t\t}\n\t\tbreak;\n\tcase FB_VSYNCTIMINGS:  \n\t\ttimings->vfreq = val;\n\t\tfb_timings_vfreq(timings);\n\t\tbreak;\n\tcase FB_HSYNCTIMINGS:  \n\t\ttimings->hfreq = val;\n\t\tfb_timings_hfreq(timings);\n\t\tbreak;\n\tcase FB_DCLKTIMINGS:  \n\t\ttimings->dclk = PICOS2KHZ(val) * 1000;\n\t\tfb_timings_dclk(timings);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\n\t}\n\n\tif (err || (!(flags & FB_IGNOREMON) &&\n\t    (timings->vfreq < vfmin || timings->vfreq > vfmax ||\n\t     timings->hfreq < hfmin || timings->hfreq > hfmax ||\n\t     timings->dclk < dclkmin || timings->dclk > dclkmax))) {\n\t\terr = -EINVAL;\n\t} else {\n\t\tvar->pixclock = KHZ2PICOS(timings->dclk/1000);\n\t\tvar->hsync_len = (timings->htotal * 8)/100;\n\t\tvar->right_margin = (timings->hblank/2) - var->hsync_len;\n\t\tvar->left_margin = timings->hblank - var->right_margin -\n\t\t\tvar->hsync_len;\n\t\tvar->vsync_len = (3 * interlace)/dscan;\n\t\tvar->lower_margin = (1 * interlace)/dscan;\n\t\tvar->upper_margin = (timings->vblank * interlace)/dscan -\n\t\t\t(var->vsync_len + var->lower_margin);\n\t}\n\n\tkfree(timings);\n\treturn err;\n}\n\n#ifdef CONFIG_VIDEOMODE_HELPERS\nint fb_videomode_from_videomode(const struct videomode *vm,\n\t\t\t\tstruct fb_videomode *fbmode)\n{\n\tunsigned int htotal, vtotal;\n\n\tfbmode->xres = vm->hactive;\n\tfbmode->left_margin = vm->hback_porch;\n\tfbmode->right_margin = vm->hfront_porch;\n\tfbmode->hsync_len = vm->hsync_len;\n\n\tfbmode->yres = vm->vactive;\n\tfbmode->upper_margin = vm->vback_porch;\n\tfbmode->lower_margin = vm->vfront_porch;\n\tfbmode->vsync_len = vm->vsync_len;\n\n\t \n\tfbmode->pixclock = vm->pixelclock ?\n\t\t\tKHZ2PICOS(vm->pixelclock / 1000) : 0;\n\n\tfbmode->sync = 0;\n\tfbmode->vmode = 0;\n\tif (vm->flags & DISPLAY_FLAGS_HSYNC_HIGH)\n\t\tfbmode->sync |= FB_SYNC_HOR_HIGH_ACT;\n\tif (vm->flags & DISPLAY_FLAGS_VSYNC_HIGH)\n\t\tfbmode->sync |= FB_SYNC_VERT_HIGH_ACT;\n\tif (vm->flags & DISPLAY_FLAGS_INTERLACED)\n\t\tfbmode->vmode |= FB_VMODE_INTERLACED;\n\tif (vm->flags & DISPLAY_FLAGS_DOUBLESCAN)\n\t\tfbmode->vmode |= FB_VMODE_DOUBLE;\n\tfbmode->flag = 0;\n\n\thtotal = vm->hactive + vm->hfront_porch + vm->hback_porch +\n\t\t vm->hsync_len;\n\tvtotal = vm->vactive + vm->vfront_porch + vm->vback_porch +\n\t\t vm->vsync_len;\n\t \n\tif (htotal && vtotal) {\n\t\tfbmode->refresh = vm->pixelclock / (htotal * vtotal);\n\t \n\t} else {\n\t\tfbmode->refresh = 0;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fb_videomode_from_videomode);\n\n#ifdef CONFIG_OF\nstatic inline void dump_fb_videomode(const struct fb_videomode *m)\n{\n\tpr_debug(\"fb_videomode = %ux%u@%uHz (%ukHz) %u %u %u %u %u %u %u %u %u\\n\",\n\t\t m->xres, m->yres, m->refresh, m->pixclock, m->left_margin,\n\t\t m->right_margin, m->upper_margin, m->lower_margin,\n\t\t m->hsync_len, m->vsync_len, m->sync, m->vmode, m->flag);\n}\n\n \nint of_get_fb_videomode(struct device_node *np, struct fb_videomode *fb,\n\t\t\tint index)\n{\n\tstruct videomode vm;\n\tint ret;\n\n\tret = of_get_videomode(np, &vm, index);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fb_videomode_from_videomode(&vm, fb);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_debug(\"%pOF: got %dx%d display mode\\n\",\n\t\tnp, vm.hactive, vm.vactive);\n\tdump_fb_videomode(fb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_get_fb_videomode);\n#endif  \n#endif  \n\n#else\nint fb_parse_edid(unsigned char *edid, struct fb_var_screeninfo *var)\n{\n\treturn 1;\n}\nvoid fb_edid_to_monspecs(unsigned char *edid, struct fb_monspecs *specs)\n{\n}\nvoid fb_destroy_modedb(struct fb_videomode *modedb)\n{\n}\nint fb_get_mode(int flags, u32 val, struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info)\n{\n\treturn -EINVAL;\n}\n#endif  \n\n \nint fb_validate_mode(const struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tu32 hfreq, vfreq, htotal, vtotal, pixclock;\n\tu32 hfmin, hfmax, vfmin, vfmax, dclkmin, dclkmax;\n\n\t \n\tif (!info->monspecs.hfmax || !info->monspecs.vfmax ||\n\t    !info->monspecs.dclkmax ||\n\t    info->monspecs.hfmax < info->monspecs.hfmin ||\n\t    info->monspecs.vfmax < info->monspecs.vfmin ||\n\t    info->monspecs.dclkmax < info->monspecs.dclkmin) {\n\t\thfmin = 29000; hfmax = 30000;\n\t\tvfmin = 60; vfmax = 60;\n\t\tdclkmin = 0; dclkmax = 25000000;\n\t} else {\n\t\thfmin = info->monspecs.hfmin;\n\t\thfmax = info->monspecs.hfmax;\n\t\tvfmin = info->monspecs.vfmin;\n\t\tvfmax = info->monspecs.vfmax;\n\t\tdclkmin = info->monspecs.dclkmin;\n\t\tdclkmax = info->monspecs.dclkmax;\n\t}\n\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\tpixclock = PICOS2KHZ(var->pixclock) * 1000;\n\n\thtotal = var->xres + var->right_margin + var->hsync_len +\n\t\tvar->left_margin;\n\tvtotal = var->yres + var->lower_margin + var->vsync_len +\n\t\tvar->upper_margin;\n\n\tif (var->vmode & FB_VMODE_INTERLACED)\n\t\tvtotal /= 2;\n\tif (var->vmode & FB_VMODE_DOUBLE)\n\t\tvtotal *= 2;\n\n\thfreq = pixclock/htotal;\n\thfreq = (hfreq + 500) / 1000 * 1000;\n\n\tvfreq = hfreq/vtotal;\n\n\treturn (vfreq < vfmin || vfreq > vfmax ||\n\t\thfreq < hfmin || hfreq > hfmax ||\n\t\tpixclock < dclkmin || pixclock > dclkmax) ?\n\t\t-EINVAL : 0;\n}\n\n#if defined(CONFIG_FIRMWARE_EDID) && defined(CONFIG_X86)\n\n \n\nconst unsigned char *fb_firmware_edid(struct device *device)\n{\n\tstruct pci_dev *dev = NULL;\n\tstruct resource *res = NULL;\n\tunsigned char *edid = NULL;\n\n\tif (device)\n\t\tdev = to_pci_dev(device);\n\n\tif (dev)\n\t\tres = &dev->resource[PCI_ROM_RESOURCE];\n\n\tif (res && res->flags & IORESOURCE_ROM_SHADOW)\n\t\tedid = edid_info.dummy;\n\n\treturn edid;\n}\n#else\nconst unsigned char *fb_firmware_edid(struct device *device)\n{\n\treturn NULL;\n}\n#endif\nEXPORT_SYMBOL(fb_firmware_edid);\n\nEXPORT_SYMBOL(fb_parse_edid);\nEXPORT_SYMBOL(fb_edid_to_monspecs);\nEXPORT_SYMBOL(fb_get_mode);\nEXPORT_SYMBOL(fb_validate_mode);\nEXPORT_SYMBOL(fb_destroy_modedb);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}