{
  "module_name": "fb_chrdev.c",
  "hash_id": "6cf5b4bbe26f4c1ebdea6e5a4c18be652ba5ac0c5dca64512f0bce1382a78386",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/core/fb_chrdev.c",
  "human_readable_source": "\n\n#include <linux/compat.h>\n#include <linux/console.h>\n#include <linux/fb.h>\n#include <linux/fbcon.h>\n#include <linux/major.h>\n\n#include \"fb_internal.h\"\n\n \nstatic struct fb_info *file_fb_info(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tint fbidx = iminor(inode);\n\tstruct fb_info *info = registered_fb[fbidx];\n\n\tif (info != file->private_data)\n\t\tinfo = NULL;\n\treturn info;\n}\n\nstatic ssize_t fb_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\n\tif (!info)\n\t\treturn -ENODEV;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn -EPERM;\n\n\tif (info->fbops->fb_read)\n\t\treturn info->fbops->fb_read(info, buf, count, ppos);\n\n\treturn fb_io_read(info, buf, count, ppos);\n}\n\nstatic ssize_t fb_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\n\tif (!info)\n\t\treturn -ENODEV;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn -EPERM;\n\n\tif (info->fbops->fb_write)\n\t\treturn info->fbops->fb_write(info, buf, count, ppos);\n\n\treturn fb_io_write(info, buf, count, ppos);\n}\n\nstatic long do_fb_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tconst struct fb_ops *fb;\n\tstruct fb_var_screeninfo var;\n\tstruct fb_fix_screeninfo fix;\n\tstruct fb_cmap cmap_from;\n\tstruct fb_cmap_user cmap;\n\tvoid __user *argp = (void __user *)arg;\n\tlong ret = 0;\n\n\tswitch (cmd) {\n\tcase FBIOGET_VSCREENINFO:\n\t\tlock_fb_info(info);\n\t\tvar = info->var;\n\t\tunlock_fb_info(info);\n\n\t\tret = copy_to_user(argp, &var, sizeof(var)) ? -EFAULT : 0;\n\t\tbreak;\n\tcase FBIOPUT_VSCREENINFO:\n\t\tif (copy_from_user(&var, argp, sizeof(var)))\n\t\t\treturn -EFAULT;\n\t\t \n\t\tvar.activate &= ~FB_ACTIVATE_KD_TEXT;\n\t\tconsole_lock();\n\t\tlock_fb_info(info);\n\t\tret = fbcon_modechange_possible(info, &var);\n\t\tif (!ret)\n\t\t\tret = fb_set_var(info, &var);\n\t\tif (!ret)\n\t\t\tfbcon_update_vcs(info, var.activate & FB_ACTIVATE_ALL);\n\t\tunlock_fb_info(info);\n\t\tconsole_unlock();\n\t\tif (!ret && copy_to_user(argp, &var, sizeof(var)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase FBIOGET_FSCREENINFO:\n\t\tlock_fb_info(info);\n\t\tmemcpy(&fix, &info->fix, sizeof(fix));\n\t\tif (info->flags & FBINFO_HIDE_SMEM_START)\n\t\t\tfix.smem_start = 0;\n\t\tunlock_fb_info(info);\n\n\t\tret = copy_to_user(argp, &fix, sizeof(fix)) ? -EFAULT : 0;\n\t\tbreak;\n\tcase FBIOPUTCMAP:\n\t\tif (copy_from_user(&cmap, argp, sizeof(cmap)))\n\t\t\treturn -EFAULT;\n\t\tret = fb_set_user_cmap(&cmap, info);\n\t\tbreak;\n\tcase FBIOGETCMAP:\n\t\tif (copy_from_user(&cmap, argp, sizeof(cmap)))\n\t\t\treturn -EFAULT;\n\t\tlock_fb_info(info);\n\t\tcmap_from = info->cmap;\n\t\tunlock_fb_info(info);\n\t\tret = fb_cmap_to_user(&cmap_from, &cmap);\n\t\tbreak;\n\tcase FBIOPAN_DISPLAY:\n\t\tif (copy_from_user(&var, argp, sizeof(var)))\n\t\t\treturn -EFAULT;\n\t\tconsole_lock();\n\t\tlock_fb_info(info);\n\t\tret = fb_pan_display(info, &var);\n\t\tunlock_fb_info(info);\n\t\tconsole_unlock();\n\t\tif (ret == 0 && copy_to_user(argp, &var, sizeof(var)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase FBIO_CURSOR:\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase FBIOGET_CON2FBMAP:\n\t\tret = fbcon_get_con2fb_map_ioctl(argp);\n\t\tbreak;\n\tcase FBIOPUT_CON2FBMAP:\n\t\tret = fbcon_set_con2fb_map_ioctl(argp);\n\t\tbreak;\n\tcase FBIOBLANK:\n\t\tif (arg > FB_BLANK_POWERDOWN)\n\t\t\treturn -EINVAL;\n\t\tconsole_lock();\n\t\tlock_fb_info(info);\n\t\tret = fb_blank(info, arg);\n\t\t \n\t\tfbcon_fb_blanked(info, arg);\n\t\tunlock_fb_info(info);\n\t\tconsole_unlock();\n\t\tbreak;\n\tdefault:\n\t\tlock_fb_info(info);\n\t\tfb = info->fbops;\n\t\tif (fb->fb_ioctl)\n\t\t\tret = fb->fb_ioctl(info, cmd, arg);\n\t\telse\n\t\t\tret = -ENOTTY;\n\t\tunlock_fb_info(info);\n\t}\n\treturn ret;\n}\n\nstatic long fb_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\n\tif (!info)\n\t\treturn -ENODEV;\n\treturn do_fb_ioctl(info, cmd, arg);\n}\n\n#ifdef CONFIG_COMPAT\nstruct fb_fix_screeninfo32 {\n\tchar\t\t\tid[16];\n\tcompat_caddr_t\t\tsmem_start;\n\tu32\t\t\tsmem_len;\n\tu32\t\t\ttype;\n\tu32\t\t\ttype_aux;\n\tu32\t\t\tvisual;\n\tu16\t\t\txpanstep;\n\tu16\t\t\typanstep;\n\tu16\t\t\tywrapstep;\n\tu32\t\t\tline_length;\n\tcompat_caddr_t\t\tmmio_start;\n\tu32\t\t\tmmio_len;\n\tu32\t\t\taccel;\n\tu16\t\t\treserved[3];\n};\n\nstruct fb_cmap32 {\n\tu32\t\t\tstart;\n\tu32\t\t\tlen;\n\tcompat_caddr_t\tred;\n\tcompat_caddr_t\tgreen;\n\tcompat_caddr_t\tblue;\n\tcompat_caddr_t\ttransp;\n};\n\nstatic int fb_getput_cmap(struct fb_info *info, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct fb_cmap32 cmap32;\n\tstruct fb_cmap cmap_from;\n\tstruct fb_cmap_user cmap;\n\n\tif (copy_from_user(&cmap32, compat_ptr(arg), sizeof(cmap32)))\n\t\treturn -EFAULT;\n\n\tcmap = (struct fb_cmap_user) {\n\t\t.start\t= cmap32.start,\n\t\t.len\t= cmap32.len,\n\t\t.red\t= compat_ptr(cmap32.red),\n\t\t.green\t= compat_ptr(cmap32.green),\n\t\t.blue\t= compat_ptr(cmap32.blue),\n\t\t.transp\t= compat_ptr(cmap32.transp),\n\t};\n\n\tif (cmd == FBIOPUTCMAP)\n\t\treturn fb_set_user_cmap(&cmap, info);\n\n\tlock_fb_info(info);\n\tcmap_from = info->cmap;\n\tunlock_fb_info(info);\n\n\treturn fb_cmap_to_user(&cmap_from, &cmap);\n}\n\nstatic int do_fscreeninfo_to_user(struct fb_fix_screeninfo *fix,\n\t\t\t\t  struct fb_fix_screeninfo32 __user *fix32)\n{\n\t__u32 data;\n\tint err;\n\n\terr = copy_to_user(&fix32->id, &fix->id, sizeof(fix32->id));\n\n\tdata = (__u32) (unsigned long) fix->smem_start;\n\terr |= put_user(data, &fix32->smem_start);\n\n\terr |= put_user(fix->smem_len, &fix32->smem_len);\n\terr |= put_user(fix->type, &fix32->type);\n\terr |= put_user(fix->type_aux, &fix32->type_aux);\n\terr |= put_user(fix->visual, &fix32->visual);\n\terr |= put_user(fix->xpanstep, &fix32->xpanstep);\n\terr |= put_user(fix->ypanstep, &fix32->ypanstep);\n\terr |= put_user(fix->ywrapstep, &fix32->ywrapstep);\n\terr |= put_user(fix->line_length, &fix32->line_length);\n\n\tdata = (__u32) (unsigned long) fix->mmio_start;\n\terr |= put_user(data, &fix32->mmio_start);\n\n\terr |= put_user(fix->mmio_len, &fix32->mmio_len);\n\terr |= put_user(fix->accel, &fix32->accel);\n\terr |= copy_to_user(fix32->reserved, fix->reserved,\n\t\t\t    sizeof(fix->reserved));\n\n\tif (err)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int fb_get_fscreeninfo(struct fb_info *info, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tstruct fb_fix_screeninfo fix;\n\n\tlock_fb_info(info);\n\tfix = info->fix;\n\tif (info->flags & FBINFO_HIDE_SMEM_START)\n\t\tfix.smem_start = 0;\n\tunlock_fb_info(info);\n\treturn do_fscreeninfo_to_user(&fix, compat_ptr(arg));\n}\n\nstatic long fb_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tconst struct fb_ops *fb;\n\tlong ret = -ENOIOCTLCMD;\n\n\tif (!info)\n\t\treturn -ENODEV;\n\tfb = info->fbops;\n\tswitch (cmd) {\n\tcase FBIOGET_VSCREENINFO:\n\tcase FBIOPUT_VSCREENINFO:\n\tcase FBIOPAN_DISPLAY:\n\tcase FBIOGET_CON2FBMAP:\n\tcase FBIOPUT_CON2FBMAP:\n\t\targ = (unsigned long) compat_ptr(arg);\n\t\tfallthrough;\n\tcase FBIOBLANK:\n\t\tret = do_fb_ioctl(info, cmd, arg);\n\t\tbreak;\n\n\tcase FBIOGET_FSCREENINFO:\n\t\tret = fb_get_fscreeninfo(info, cmd, arg);\n\t\tbreak;\n\n\tcase FBIOGETCMAP:\n\tcase FBIOPUTCMAP:\n\t\tret = fb_getput_cmap(info, cmd, arg);\n\t\tbreak;\n\n\tdefault:\n\t\tif (fb->fb_compat_ioctl)\n\t\t\tret = fb->fb_compat_ioctl(info, cmd, arg);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n#endif\n\nstatic int fb_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tunsigned long mmio_pgoff;\n\tunsigned long start;\n\tu32 len;\n\n\tif (!info)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\n\tif (info->fbops->fb_mmap) {\n\t\tint res;\n\n\t\t \n\t\tvma->vm_page_prot = pgprot_decrypted(vma->vm_page_prot);\n\t\tres = info->fbops->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n#if IS_ENABLED(CONFIG_FB_DEFERRED_IO)\n\t} else if (info->fbdefio) {\n\t\t \n\t\tdev_warn_once(info->dev, \"fbdev mmap not set up for deferred I/O.\\n\");\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn -ENODEV;\n#endif\n\t}\n\n\t \n\tstart = info->fix.smem_start;\n\tlen = info->fix.smem_len;\n\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\n\tif (vma->vm_pgoff >= mmio_pgoff) {\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvma->vm_pgoff -= mmio_pgoff;\n\t\tstart = info->fix.mmio_start;\n\t\tlen = info->fix.mmio_len;\n\t}\n\tmutex_unlock(&info->mm_lock);\n\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, start);\n\n\treturn vm_iomap_memory(vma, start, len);\n}\n\nstatic int fb_open(struct inode *inode, struct file *file)\n__acquires(&info->lock)\n__releases(&info->lock)\n{\n\tint fbidx = iminor(inode);\n\tstruct fb_info *info;\n\tint res = 0;\n\n\tinfo = get_fb_info(fbidx);\n\tif (!info) {\n\t\trequest_module(\"fb%d\", fbidx);\n\t\tinfo = get_fb_info(fbidx);\n\t\tif (!info)\n\t\t\treturn -ENODEV;\n\t}\n\tif (IS_ERR(info))\n\t\treturn PTR_ERR(info);\n\n\tlock_fb_info(info);\n\tif (!try_module_get(info->fbops->owner)) {\n\t\tres = -ENODEV;\n\t\tgoto out;\n\t}\n\tfile->private_data = info;\n\tif (info->fbops->fb_open) {\n\t\tres = info->fbops->fb_open(info, 1);\n\t\tif (res)\n\t\t\tmodule_put(info->fbops->owner);\n\t}\n#ifdef CONFIG_FB_DEFERRED_IO\n\tif (info->fbdefio)\n\t\tfb_deferred_io_open(info, inode, file);\n#endif\nout:\n\tunlock_fb_info(info);\n\tif (res)\n\t\tput_fb_info(info);\n\treturn res;\n}\n\nstatic int fb_release(struct inode *inode, struct file *file)\n__acquires(&info->lock)\n__releases(&info->lock)\n{\n\tstruct fb_info * const info = file->private_data;\n\n\tlock_fb_info(info);\n#if IS_ENABLED(CONFIG_FB_DEFERRED_IO)\n\tif (info->fbdefio)\n\t\tfb_deferred_io_release(info);\n#endif\n\tif (info->fbops->fb_release)\n\t\tinfo->fbops->fb_release(info, 1);\n\tmodule_put(info->fbops->owner);\n\tunlock_fb_info(info);\n\tput_fb_info(info);\n\treturn 0;\n}\n\n#if defined(CONFIG_FB_PROVIDE_GET_FB_UNMAPPED_AREA) && !defined(CONFIG_MMU)\nstatic unsigned long get_fb_unmapped_area(struct file *filp,\n\t\t\t\t   unsigned long addr, unsigned long len,\n\t\t\t\t   unsigned long pgoff, unsigned long flags)\n{\n\tstruct fb_info * const info = filp->private_data;\n\tunsigned long fb_size = PAGE_ALIGN(info->fix.smem_len);\n\n\tif (pgoff > fb_size || len > fb_size - pgoff)\n\t\treturn -EINVAL;\n\n\treturn (unsigned long)info->screen_base + pgoff;\n}\n#endif\n\nstatic const struct file_operations fb_fops = {\n\t.owner = THIS_MODULE,\n\t.read = fb_read,\n\t.write = fb_write,\n\t.unlocked_ioctl = fb_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = fb_compat_ioctl,\n#endif\n\t.mmap = fb_mmap,\n\t.open = fb_open,\n\t.release = fb_release,\n#if defined(HAVE_ARCH_FB_UNMAPPED_AREA) || \\\n\t(defined(CONFIG_FB_PROVIDE_GET_FB_UNMAPPED_AREA) && \\\n\t !defined(CONFIG_MMU))\n\t.get_unmapped_area = get_fb_unmapped_area,\n#endif\n#ifdef CONFIG_FB_DEFERRED_IO\n\t.fsync = fb_deferred_io_fsync,\n#endif\n\t.llseek = default_llseek,\n};\n\nint fb_register_chrdev(void)\n{\n\tint ret;\n\n\tret = register_chrdev(FB_MAJOR, \"fb\", &fb_fops);\n\tif (ret) {\n\t\tpr_err(\"Unable to get major %d for fb devs\\n\", FB_MAJOR);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nvoid fb_unregister_chrdev(void)\n{\n\tunregister_chrdev(FB_MAJOR, \"fb\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}