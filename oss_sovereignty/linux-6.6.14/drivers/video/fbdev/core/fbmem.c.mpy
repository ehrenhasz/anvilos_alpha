{
  "module_name": "fbmem.c",
  "hash_id": "d1f95ecc376fa0a8bc5201fd911bba971e9785f5da304550b6f7cf4142d55e2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/core/fbmem.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/vt.h>\n#include <linux/init.h>\n#include <linux/linux_logo.h>\n#include <linux/platform_device.h>\n#include <linux/console.h>\n#include <linux/kmod.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/efi.h>\n#include <linux/fb.h>\n#include <linux/fbcon.h>\n#include <linux/mem_encrypt.h>\n#include <linux/pci.h>\n\n#include <video/nomodeset.h>\n#include <video/vga.h>\n\n#include \"fb_internal.h\"\n\n     \n\n#define FBPIXMAPSIZE\t(1024 * 8)\n\nstruct class *fb_class;\n\nDEFINE_MUTEX(registration_lock);\nstruct fb_info *registered_fb[FB_MAX] __read_mostly;\nint num_registered_fb __read_mostly;\n#define for_each_registered_fb(i)\t\t\\\n\tfor (i = 0; i < FB_MAX; i++)\t\t\\\n\t\tif (!registered_fb[i]) {} else\n\nbool fb_center_logo __read_mostly;\n\nint fb_logo_count __read_mostly = -1;\n\nstruct fb_info *get_fb_info(unsigned int idx)\n{\n\tstruct fb_info *fb_info;\n\n\tif (idx >= FB_MAX)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmutex_lock(&registration_lock);\n\tfb_info = registered_fb[idx];\n\tif (fb_info)\n\t\trefcount_inc(&fb_info->count);\n\tmutex_unlock(&registration_lock);\n\n\treturn fb_info;\n}\n\nvoid put_fb_info(struct fb_info *fb_info)\n{\n\tif (!refcount_dec_and_test(&fb_info->count))\n\t\treturn;\n\tif (fb_info->fbops->fb_destroy)\n\t\tfb_info->fbops->fb_destroy(fb_info);\n}\n\n \n\nint fb_get_color_depth(struct fb_var_screeninfo *var,\n\t\t       struct fb_fix_screeninfo *fix)\n{\n\tint depth = 0;\n\n\tif (fix->visual == FB_VISUAL_MONO01 ||\n\t    fix->visual == FB_VISUAL_MONO10)\n\t\tdepth = 1;\n\telse {\n\t\tif (var->green.length == var->blue.length &&\n\t\t    var->green.length == var->red.length &&\n\t\t    var->green.offset == var->blue.offset &&\n\t\t    var->green.offset == var->red.offset)\n\t\t\tdepth = var->green.length;\n\t\telse\n\t\t\tdepth = var->green.length + var->red.length +\n\t\t\t\tvar->blue.length;\n\t}\n\n\treturn depth;\n}\nEXPORT_SYMBOL(fb_get_color_depth);\n\n \nvoid fb_pad_aligned_buffer(u8 *dst, u32 d_pitch, u8 *src, u32 s_pitch, u32 height)\n{\n\t__fb_pad_aligned_buffer(dst, d_pitch, src, s_pitch, height);\n}\nEXPORT_SYMBOL(fb_pad_aligned_buffer);\n\nvoid fb_pad_unaligned_buffer(u8 *dst, u32 d_pitch, u8 *src, u32 idx, u32 height,\n\t\t\t\tu32 shift_high, u32 shift_low, u32 mod)\n{\n\tu8 mask = (u8) (0xfff << shift_high), tmp;\n\tint i, j;\n\n\tfor (i = height; i--; ) {\n\t\tfor (j = 0; j < idx; j++) {\n\t\t\ttmp = dst[j];\n\t\t\ttmp &= mask;\n\t\t\ttmp |= *src >> shift_low;\n\t\t\tdst[j] = tmp;\n\t\t\ttmp = *src << shift_high;\n\t\t\tdst[j+1] = tmp;\n\t\t\tsrc++;\n\t\t}\n\t\ttmp = dst[idx];\n\t\ttmp &= mask;\n\t\ttmp |= *src >> shift_low;\n\t\tdst[idx] = tmp;\n\t\tif (shift_high < mod) {\n\t\t\ttmp = *src << shift_high;\n\t\t\tdst[idx+1] = tmp;\n\t\t}\n\t\tsrc++;\n\t\tdst += d_pitch;\n\t}\n}\nEXPORT_SYMBOL(fb_pad_unaligned_buffer);\n\n \nchar* fb_get_buffer_offset(struct fb_info *info, struct fb_pixmap *buf, u32 size)\n{\n\tu32 align = buf->buf_align - 1, offset;\n\tchar *addr = buf->addr;\n\n\t \n\tif (buf->flags & FB_PIXMAP_IO) {\n\t\tif (info->fbops->fb_sync && (buf->flags & FB_PIXMAP_SYNC))\n\t\t\tinfo->fbops->fb_sync(info);\n\t\treturn addr;\n\t}\n\n\t \n\toffset = buf->offset + align;\n\toffset &= ~align;\n\tif (offset + size > buf->size) {\n\t\t \n\t\tif (info->fbops->fb_sync && (buf->flags & FB_PIXMAP_SYNC))\n\t\t\tinfo->fbops->fb_sync(info);\n\t\toffset = 0;\n\t}\n\tbuf->offset = offset + size;\n\taddr += offset;\n\n\treturn addr;\n}\nEXPORT_SYMBOL(fb_get_buffer_offset);\n\n#ifdef CONFIG_LOGO\n\nstatic inline unsigned safe_shift(unsigned d, int n)\n{\n\treturn n < 0 ? d >> -n : d << n;\n}\n\nstatic void fb_set_logocmap(struct fb_info *info,\n\t\t\t\t   const struct linux_logo *logo)\n{\n\tstruct fb_cmap palette_cmap;\n\tu16 palette_green[16];\n\tu16 palette_blue[16];\n\tu16 palette_red[16];\n\tint i, j, n;\n\tconst unsigned char *clut = logo->clut;\n\n\tpalette_cmap.start = 0;\n\tpalette_cmap.len = 16;\n\tpalette_cmap.red = palette_red;\n\tpalette_cmap.green = palette_green;\n\tpalette_cmap.blue = palette_blue;\n\tpalette_cmap.transp = NULL;\n\n\tfor (i = 0; i < logo->clutsize; i += n) {\n\t\tn = logo->clutsize - i;\n\t\t \n\t\tif (n > 16)\n\t\t\tn = 16;\n\t\tpalette_cmap.start = 32 + i;\n\t\tpalette_cmap.len = n;\n\t\tfor (j = 0; j < n; ++j) {\n\t\t\tpalette_cmap.red[j] = clut[0] << 8 | clut[0];\n\t\t\tpalette_cmap.green[j] = clut[1] << 8 | clut[1];\n\t\t\tpalette_cmap.blue[j] = clut[2] << 8 | clut[2];\n\t\t\tclut += 3;\n\t\t}\n\t\tfb_set_cmap(&palette_cmap, info);\n\t}\n}\n\nstatic void  fb_set_logo_truepalette(struct fb_info *info,\n\t\t\t\t\t    const struct linux_logo *logo,\n\t\t\t\t\t    u32 *palette)\n{\n\tstatic const unsigned char mask[] = { 0,0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff };\n\tunsigned char redmask, greenmask, bluemask;\n\tint redshift, greenshift, blueshift;\n\tint i;\n\tconst unsigned char *clut = logo->clut;\n\n\t \n\t \n\tredmask   = mask[info->var.red.length   < 8 ? info->var.red.length   : 8];\n\tgreenmask = mask[info->var.green.length < 8 ? info->var.green.length : 8];\n\tbluemask  = mask[info->var.blue.length  < 8 ? info->var.blue.length  : 8];\n\tredshift   = info->var.red.offset   - (8 - info->var.red.length);\n\tgreenshift = info->var.green.offset - (8 - info->var.green.length);\n\tblueshift  = info->var.blue.offset  - (8 - info->var.blue.length);\n\n\tfor ( i = 0; i < logo->clutsize; i++) {\n\t\tpalette[i+32] = (safe_shift((clut[0] & redmask), redshift) |\n\t\t\t\t safe_shift((clut[1] & greenmask), greenshift) |\n\t\t\t\t safe_shift((clut[2] & bluemask), blueshift));\n\t\tclut += 3;\n\t}\n}\n\nstatic void fb_set_logo_directpalette(struct fb_info *info,\n\t\t\t\t\t     const struct linux_logo *logo,\n\t\t\t\t\t     u32 *palette)\n{\n\tint redshift, greenshift, blueshift;\n\tint i;\n\n\tredshift = info->var.red.offset;\n\tgreenshift = info->var.green.offset;\n\tblueshift = info->var.blue.offset;\n\n\tfor (i = 32; i < 32 + logo->clutsize; i++)\n\t\tpalette[i] = i << redshift | i << greenshift | i << blueshift;\n}\n\nstatic void fb_set_logo(struct fb_info *info,\n\t\t\t       const struct linux_logo *logo, u8 *dst,\n\t\t\t       int depth)\n{\n\tint i, j, k;\n\tconst u8 *src = logo->data;\n\tu8 xor = (info->fix.visual == FB_VISUAL_MONO01) ? 0xff : 0;\n\tu8 fg = 1, d;\n\n\tswitch (fb_get_color_depth(&info->var, &info->fix)) {\n\tcase 1:\n\t\tfg = 1;\n\t\tbreak;\n\tcase 2:\n\t\tfg = 3;\n\t\tbreak;\n\tdefault:\n\t\tfg = 7;\n\t\tbreak;\n\t}\n\n\tif (info->fix.visual == FB_VISUAL_MONO01 ||\n\t    info->fix.visual == FB_VISUAL_MONO10)\n\t\tfg = ~((u8) (0xfff << info->var.green.length));\n\n\tswitch (depth) {\n\tcase 4:\n\t\tfor (i = 0; i < logo->height; i++)\n\t\t\tfor (j = 0; j < logo->width; src++) {\n\t\t\t\t*dst++ = *src >> 4;\n\t\t\t\tj++;\n\t\t\t\tif (j < logo->width) {\n\t\t\t\t\t*dst++ = *src & 0x0f;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tfor (i = 0; i < logo->height; i++) {\n\t\t\tfor (j = 0; j < logo->width; src++) {\n\t\t\t\td = *src ^ xor;\n\t\t\t\tfor (k = 7; k >= 0 && j < logo->width; k--) {\n\t\t\t\t\t*dst++ = ((d >> k) & 1) ? fg : 0;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \nstatic struct logo_data {\n\tint depth;\n\tint needs_directpalette;\n\tint needs_truepalette;\n\tint needs_cmapreset;\n\tconst struct linux_logo *logo;\n} fb_logo __read_mostly;\n\nstatic void fb_rotate_logo_ud(const u8 *in, u8 *out, u32 width, u32 height)\n{\n\tu32 size = width * height, i;\n\n\tout += size - 1;\n\n\tfor (i = size; i--; )\n\t\t*out-- = *in++;\n}\n\nstatic void fb_rotate_logo_cw(const u8 *in, u8 *out, u32 width, u32 height)\n{\n\tint i, j, h = height - 1;\n\n\tfor (i = 0; i < height; i++)\n\t\tfor (j = 0; j < width; j++)\n\t\t\t\tout[height * j + h - i] = *in++;\n}\n\nstatic void fb_rotate_logo_ccw(const u8 *in, u8 *out, u32 width, u32 height)\n{\n\tint i, j, w = width - 1;\n\n\tfor (i = 0; i < height; i++)\n\t\tfor (j = 0; j < width; j++)\n\t\t\tout[height * (w - j) + i] = *in++;\n}\n\nstatic void fb_rotate_logo(struct fb_info *info, u8 *dst,\n\t\t\t   struct fb_image *image, int rotate)\n{\n\tu32 tmp;\n\n\tif (rotate == FB_ROTATE_UD) {\n\t\tfb_rotate_logo_ud(image->data, dst, image->width,\n\t\t\t\t  image->height);\n\t\timage->dx = info->var.xres - image->width - image->dx;\n\t\timage->dy = info->var.yres - image->height - image->dy;\n\t} else if (rotate == FB_ROTATE_CW) {\n\t\tfb_rotate_logo_cw(image->data, dst, image->width,\n\t\t\t\t  image->height);\n\t\tswap(image->width, image->height);\n\t\ttmp = image->dy;\n\t\timage->dy = image->dx;\n\t\timage->dx = info->var.xres - image->width - tmp;\n\t} else if (rotate == FB_ROTATE_CCW) {\n\t\tfb_rotate_logo_ccw(image->data, dst, image->width,\n\t\t\t\t   image->height);\n\t\tswap(image->width, image->height);\n\t\ttmp = image->dx;\n\t\timage->dx = image->dy;\n\t\timage->dy = info->var.yres - image->height - tmp;\n\t}\n\n\timage->data = dst;\n}\n\nstatic void fb_do_show_logo(struct fb_info *info, struct fb_image *image,\n\t\t\t    int rotate, unsigned int num)\n{\n\tunsigned int x;\n\n\tif (image->width > info->var.xres || image->height > info->var.yres)\n\t\treturn;\n\n\tif (rotate == FB_ROTATE_UR) {\n\t\tfor (x = 0;\n\t\t     x < num && image->dx + image->width <= info->var.xres;\n\t\t     x++) {\n\t\t\tinfo->fbops->fb_imageblit(info, image);\n\t\t\timage->dx += image->width + 8;\n\t\t}\n\t} else if (rotate == FB_ROTATE_UD) {\n\t\tu32 dx = image->dx;\n\n\t\tfor (x = 0; x < num && image->dx <= dx; x++) {\n\t\t\tinfo->fbops->fb_imageblit(info, image);\n\t\t\timage->dx -= image->width + 8;\n\t\t}\n\t} else if (rotate == FB_ROTATE_CW) {\n\t\tfor (x = 0;\n\t\t     x < num && image->dy + image->height <= info->var.yres;\n\t\t     x++) {\n\t\t\tinfo->fbops->fb_imageblit(info, image);\n\t\t\timage->dy += image->height + 8;\n\t\t}\n\t} else if (rotate == FB_ROTATE_CCW) {\n\t\tu32 dy = image->dy;\n\n\t\tfor (x = 0; x < num && image->dy <= dy; x++) {\n\t\t\tinfo->fbops->fb_imageblit(info, image);\n\t\t\timage->dy -= image->height + 8;\n\t\t}\n\t}\n}\n\nstatic int fb_show_logo_line(struct fb_info *info, int rotate,\n\t\t\t     const struct linux_logo *logo, int y,\n\t\t\t     unsigned int n)\n{\n\tu32 *palette = NULL, *saved_pseudo_palette = NULL;\n\tunsigned char *logo_new = NULL, *logo_rotate = NULL;\n\tstruct fb_image image;\n\n\t \n\tif (logo == NULL || info->state != FBINFO_STATE_RUNNING ||\n\t    info->fbops->owner)\n\t\treturn 0;\n\n\timage.depth = 8;\n\timage.data = logo->data;\n\n\tif (fb_logo.needs_cmapreset)\n\t\tfb_set_logocmap(info, logo);\n\n\tif (fb_logo.needs_truepalette ||\n\t    fb_logo.needs_directpalette) {\n\t\tpalette = kmalloc(256 * 4, GFP_KERNEL);\n\t\tif (palette == NULL)\n\t\t\treturn 0;\n\n\t\tif (fb_logo.needs_truepalette)\n\t\t\tfb_set_logo_truepalette(info, logo, palette);\n\t\telse\n\t\t\tfb_set_logo_directpalette(info, logo, palette);\n\n\t\tsaved_pseudo_palette = info->pseudo_palette;\n\t\tinfo->pseudo_palette = palette;\n\t}\n\n\tif (fb_logo.depth <= 4) {\n\t\tlogo_new = kmalloc_array(logo->width, logo->height,\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (logo_new == NULL) {\n\t\t\tkfree(palette);\n\t\t\tif (saved_pseudo_palette)\n\t\t\t\tinfo->pseudo_palette = saved_pseudo_palette;\n\t\t\treturn 0;\n\t\t}\n\t\timage.data = logo_new;\n\t\tfb_set_logo(info, logo, logo_new, fb_logo.depth);\n\t}\n\n\tif (fb_center_logo) {\n\t\tint xres = info->var.xres;\n\t\tint yres = info->var.yres;\n\n\t\tif (rotate == FB_ROTATE_CW || rotate == FB_ROTATE_CCW) {\n\t\t\txres = info->var.yres;\n\t\t\tyres = info->var.xres;\n\t\t}\n\n\t\twhile (n && (n * (logo->width + 8) - 8 > xres))\n\t\t\t--n;\n\t\timage.dx = (xres - (n * (logo->width + 8) - 8)) / 2;\n\t\timage.dy = y ?: (yres - logo->height) / 2;\n\t} else {\n\t\timage.dx = 0;\n\t\timage.dy = y;\n\t}\n\n\timage.width = logo->width;\n\timage.height = logo->height;\n\n\tif (rotate) {\n\t\tlogo_rotate = kmalloc_array(logo->width, logo->height,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (logo_rotate)\n\t\t\tfb_rotate_logo(info, logo_rotate, &image, rotate);\n\t}\n\n\tfb_do_show_logo(info, &image, rotate, n);\n\n\tkfree(palette);\n\tif (saved_pseudo_palette != NULL)\n\t\tinfo->pseudo_palette = saved_pseudo_palette;\n\tkfree(logo_new);\n\tkfree(logo_rotate);\n\treturn image.dy + logo->height;\n}\n\n\n#ifdef CONFIG_FB_LOGO_EXTRA\n\n#define FB_LOGO_EX_NUM_MAX 10\nstatic struct logo_data_extra {\n\tconst struct linux_logo *logo;\n\tunsigned int n;\n} fb_logo_ex[FB_LOGO_EX_NUM_MAX];\nstatic unsigned int fb_logo_ex_num;\n\nvoid fb_append_extra_logo(const struct linux_logo *logo, unsigned int n)\n{\n\tif (!n || fb_logo_ex_num == FB_LOGO_EX_NUM_MAX)\n\t\treturn;\n\n\tfb_logo_ex[fb_logo_ex_num].logo = logo;\n\tfb_logo_ex[fb_logo_ex_num].n = n;\n\tfb_logo_ex_num++;\n}\n\nstatic int fb_prepare_extra_logos(struct fb_info *info, unsigned int height,\n\t\t\t\t  unsigned int yres)\n{\n\tunsigned int i;\n\n\t \n\tif (info->fix.visual != FB_VISUAL_TRUECOLOR)\n\t\tfb_logo_ex_num = 0;\n\n\tfor (i = 0; i < fb_logo_ex_num; i++) {\n\t\tif (fb_logo_ex[i].logo->type != fb_logo.logo->type) {\n\t\t\tfb_logo_ex[i].logo = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\theight += fb_logo_ex[i].logo->height;\n\t\tif (height > yres) {\n\t\t\theight -= fb_logo_ex[i].logo->height;\n\t\t\tfb_logo_ex_num = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn height;\n}\n\nstatic int fb_show_extra_logos(struct fb_info *info, int y, int rotate)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < fb_logo_ex_num; i++)\n\t\ty = fb_show_logo_line(info, rotate,\n\t\t\t\t      fb_logo_ex[i].logo, y, fb_logo_ex[i].n);\n\n\treturn y;\n}\n\n#else  \n\nstatic inline int fb_prepare_extra_logos(struct fb_info *info,\n\t\t\t\t\t unsigned int height,\n\t\t\t\t\t unsigned int yres)\n{\n\treturn height;\n}\n\nstatic inline int fb_show_extra_logos(struct fb_info *info, int y, int rotate)\n{\n\treturn y;\n}\n\n#endif  \n\n\nint fb_prepare_logo(struct fb_info *info, int rotate)\n{\n\tint depth = fb_get_color_depth(&info->var, &info->fix);\n\tunsigned int yres;\n\tint height;\n\n\tmemset(&fb_logo, 0, sizeof(struct logo_data));\n\n\tif (info->flags & FBINFO_MISC_TILEBLITTING ||\n\t    info->fbops->owner || !fb_logo_count)\n\t\treturn 0;\n\n\tif (info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\tdepth = info->var.blue.length;\n\t\tif (info->var.red.length < depth)\n\t\t\tdepth = info->var.red.length;\n\t\tif (info->var.green.length < depth)\n\t\t\tdepth = info->var.green.length;\n\t}\n\n\tif (info->fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR && depth > 4) {\n\t\t \n\t\tdepth = 4;\n\t}\n\n\t \n\tfb_logo.logo = fb_find_logo(depth);\n\n\tif (!fb_logo.logo) {\n\t\treturn 0;\n\t}\n\n\tif (rotate == FB_ROTATE_UR || rotate == FB_ROTATE_UD)\n\t\tyres = info->var.yres;\n\telse\n\t\tyres = info->var.xres;\n\n\tif (fb_logo.logo->height > yres) {\n\t\tfb_logo.logo = NULL;\n\t\treturn 0;\n\t}\n\n\t \n\tif (fb_logo.logo->type == LINUX_LOGO_CLUT224)\n\t\tfb_logo.depth = 8;\n\telse if (fb_logo.logo->type == LINUX_LOGO_VGA16)\n\t\tfb_logo.depth = 4;\n\telse\n\t\tfb_logo.depth = 1;\n\n\n\tif (fb_logo.depth > 4 && depth > 4) {\n\t\tswitch (info->fix.visual) {\n\t\tcase FB_VISUAL_TRUECOLOR:\n\t\t\tfb_logo.needs_truepalette = 1;\n\t\t\tbreak;\n\t\tcase FB_VISUAL_DIRECTCOLOR:\n\t\t\tfb_logo.needs_directpalette = 1;\n\t\t\tfb_logo.needs_cmapreset = 1;\n\t\t\tbreak;\n\t\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\t\tfb_logo.needs_cmapreset = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\theight = fb_logo.logo->height;\n\tif (fb_center_logo)\n\t\theight += (yres - fb_logo.logo->height) / 2;\n\n\treturn fb_prepare_extra_logos(info, height, yres);\n}\n\nint fb_show_logo(struct fb_info *info, int rotate)\n{\n\tunsigned int count;\n\tint y;\n\n\tif (!fb_logo_count)\n\t\treturn 0;\n\n\tcount = fb_logo_count < 0 ? num_online_cpus() : fb_logo_count;\n\ty = fb_show_logo_line(info, rotate, fb_logo.logo, 0, count);\n\ty = fb_show_extra_logos(info, y, rotate);\n\n\treturn y;\n}\n#else\nint fb_prepare_logo(struct fb_info *info, int rotate) { return 0; }\nint fb_show_logo(struct fb_info *info, int rotate) { return 0; }\n#endif  \nEXPORT_SYMBOL(fb_prepare_logo);\nEXPORT_SYMBOL(fb_show_logo);\n\nint\nfb_pan_display(struct fb_info *info, struct fb_var_screeninfo *var)\n{\n\tstruct fb_fix_screeninfo *fix = &info->fix;\n\tunsigned int yres = info->var.yres;\n\tint err = 0;\n\n\tif (var->yoffset > 0) {\n\t\tif (var->vmode & FB_VMODE_YWRAP) {\n\t\t\tif (!fix->ywrapstep || (var->yoffset % fix->ywrapstep))\n\t\t\t\terr = -EINVAL;\n\t\t\telse\n\t\t\t\tyres = 0;\n\t\t} else if (!fix->ypanstep || (var->yoffset % fix->ypanstep))\n\t\t\terr = -EINVAL;\n\t}\n\n\tif (var->xoffset > 0 && (!fix->xpanstep ||\n\t\t\t\t (var->xoffset % fix->xpanstep)))\n\t\terr = -EINVAL;\n\n\tif (err || !info->fbops->fb_pan_display ||\n\t    var->yoffset > info->var.yres_virtual - yres ||\n\t    var->xoffset > info->var.xres_virtual - info->var.xres)\n\t\treturn -EINVAL;\n\n\tif ((err = info->fbops->fb_pan_display(var, info)))\n\t\treturn err;\n\tinfo->var.xoffset = var->xoffset;\n\tinfo->var.yoffset = var->yoffset;\n\tif (var->vmode & FB_VMODE_YWRAP)\n\t\tinfo->var.vmode |= FB_VMODE_YWRAP;\n\telse\n\t\tinfo->var.vmode &= ~FB_VMODE_YWRAP;\n\treturn 0;\n}\nEXPORT_SYMBOL(fb_pan_display);\n\nstatic int fb_check_caps(struct fb_info *info, struct fb_var_screeninfo *var,\n\t\t\t u32 activate)\n{\n\tstruct fb_blit_caps caps, fbcaps;\n\tint err = 0;\n\n\tmemset(&caps, 0, sizeof(caps));\n\tmemset(&fbcaps, 0, sizeof(fbcaps));\n\tcaps.flags = (activate & FB_ACTIVATE_ALL) ? 1 : 0;\n\tfbcon_get_requirement(info, &caps);\n\tinfo->fbops->fb_get_caps(info, &fbcaps, var);\n\n\tif (((fbcaps.x ^ caps.x) & caps.x) ||\n\t    ((fbcaps.y ^ caps.y) & caps.y) ||\n\t    (fbcaps.len < caps.len))\n\t\terr = -EINVAL;\n\n\treturn err;\n}\n\nint\nfb_set_var(struct fb_info *info, struct fb_var_screeninfo *var)\n{\n\tint ret = 0;\n\tu32 activate;\n\tstruct fb_var_screeninfo old_var;\n\tstruct fb_videomode mode;\n\tstruct fb_event event;\n\tu32 unused;\n\n\tif (var->activate & FB_ACTIVATE_INV_MODE) {\n\t\tstruct fb_videomode mode1, mode2;\n\n\t\tfb_var_to_videomode(&mode1, var);\n\t\tfb_var_to_videomode(&mode2, &info->var);\n\t\t \n\t\tret = fb_mode_is_equal(&mode1, &mode2);\n\t\tif (!ret) {\n\t\t\tret = fbcon_mode_deleted(info, &mode1);\n\t\t\tif (!ret)\n\t\t\t\tfb_delete_videomode(&mode1, &info->modelist);\n\t\t}\n\n\t\treturn ret ? -EINVAL : 0;\n\t}\n\n\tif (!(var->activate & FB_ACTIVATE_FORCE) &&\n\t    !memcmp(&info->var, var, sizeof(struct fb_var_screeninfo)))\n\t\treturn 0;\n\n\tactivate = var->activate;\n\n\t \n\tif ((info->fix.capabilities & FB_CAP_FOURCC) &&\n\t    var->grayscale > 1) {\n\t\tif (var->red.offset     || var->green.offset    ||\n\t\t    var->blue.offset    || var->transp.offset   ||\n\t\t    var->red.length     || var->green.length    ||\n\t\t    var->blue.length    || var->transp.length   ||\n\t\t    var->red.msb_right  || var->green.msb_right ||\n\t\t    var->blue.msb_right || var->transp.msb_right)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!info->fbops->fb_check_var) {\n\t\t*var = info->var;\n\t\treturn 0;\n\t}\n\n\t \n\tif (var->xres < 8 || var->yres < 8)\n\t\treturn -EINVAL;\n\n\t \n\tif (check_mul_overflow(var->xres, var->yres, &unused) ||\n\t    check_mul_overflow(var->xres_virtual, var->yres_virtual, &unused))\n\t\treturn -EINVAL;\n\n\tret = info->fbops->fb_check_var(var, info);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (var->xres_virtual < var->xres ||\n\t    var->yres_virtual < var->yres) {\n\t\tpr_warn(\"WARNING: fbcon: Driver '%s' missed to adjust virtual screen size (%ux%u vs. %ux%u)\\n\",\n\t\t\tinfo->fix.id,\n\t\t\tvar->xres_virtual, var->yres_virtual,\n\t\t\tvar->xres, var->yres);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((var->activate & FB_ACTIVATE_MASK) != FB_ACTIVATE_NOW)\n\t\treturn 0;\n\n\tif (info->fbops->fb_get_caps) {\n\t\tret = fb_check_caps(info, var, activate);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\told_var = info->var;\n\tinfo->var = *var;\n\n\tif (info->fbops->fb_set_par) {\n\t\tret = info->fbops->fb_set_par(info);\n\n\t\tif (ret) {\n\t\t\tinfo->var = old_var;\n\t\t\tprintk(KERN_WARNING \"detected \"\n\t\t\t\t\"fb_set_par error, \"\n\t\t\t\t\"error code: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfb_pan_display(info, &info->var);\n\tfb_set_cmap(&info->cmap, info);\n\tfb_var_to_videomode(&mode, &info->var);\n\n\tif (info->modelist.prev && info->modelist.next &&\n\t    !list_empty(&info->modelist))\n\t\tret = fb_add_videomode(&mode, &info->modelist);\n\n\tif (ret)\n\t\treturn ret;\n\n\tevent.info = info;\n\tevent.data = &mode;\n\tfb_notifier_call_chain(FB_EVENT_MODE_CHANGE, &event);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fb_set_var);\n\nint\nfb_blank(struct fb_info *info, int blank)\n{\n\tstruct fb_event event;\n\tint ret = -EINVAL;\n\n\tif (blank > FB_BLANK_POWERDOWN)\n\t\tblank = FB_BLANK_POWERDOWN;\n\n\tevent.info = info;\n\tevent.data = &blank;\n\n\tif (info->fbops->fb_blank)\n\t\tret = info->fbops->fb_blank(blank, info);\n\n\tif (!ret)\n\t\tfb_notifier_call_chain(FB_EVENT_BLANK, &event);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fb_blank);\n\nstatic int fb_check_foreignness(struct fb_info *fi)\n{\n\tconst bool foreign_endian = fi->flags & FBINFO_FOREIGN_ENDIAN;\n\n\tfi->flags &= ~FBINFO_FOREIGN_ENDIAN;\n\n#ifdef __BIG_ENDIAN\n\tfi->flags |= foreign_endian ? 0 : FBINFO_BE_MATH;\n#else\n\tfi->flags |= foreign_endian ? FBINFO_BE_MATH : 0;\n#endif  \n\n\tif (fi->flags & FBINFO_BE_MATH && !fb_be_math(fi)) {\n\t\tpr_err(\"%s: enable CONFIG_FB_BIG_ENDIAN to \"\n\t\t       \"support this framebuffer\\n\", fi->fix.id);\n\t\treturn -ENOSYS;\n\t} else if (!(fi->flags & FBINFO_BE_MATH) && fb_be_math(fi)) {\n\t\tpr_err(\"%s: enable CONFIG_FB_LITTLE_ENDIAN to \"\n\t\t       \"support this framebuffer\\n\", fi->fix.id);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_register_framebuffer(struct fb_info *fb_info)\n{\n\tint i;\n\tstruct fb_videomode mode;\n\n\tif (fb_check_foreignness(fb_info))\n\t\treturn -ENOSYS;\n\n\tif (num_registered_fb == FB_MAX)\n\t\treturn -ENXIO;\n\n\tnum_registered_fb++;\n\tfor (i = 0 ; i < FB_MAX; i++)\n\t\tif (!registered_fb[i])\n\t\t\tbreak;\n\tfb_info->node = i;\n\trefcount_set(&fb_info->count, 1);\n\tmutex_init(&fb_info->lock);\n\tmutex_init(&fb_info->mm_lock);\n\n\tfb_device_create(fb_info);\n\n\tif (fb_info->pixmap.addr == NULL) {\n\t\tfb_info->pixmap.addr = kmalloc(FBPIXMAPSIZE, GFP_KERNEL);\n\t\tif (fb_info->pixmap.addr) {\n\t\t\tfb_info->pixmap.size = FBPIXMAPSIZE;\n\t\t\tfb_info->pixmap.buf_align = 1;\n\t\t\tfb_info->pixmap.scan_align = 1;\n\t\t\tfb_info->pixmap.access_align = 32;\n\t\t\tfb_info->pixmap.flags = FB_PIXMAP_DEFAULT;\n\t\t}\n\t}\n\tfb_info->pixmap.offset = 0;\n\n\tif (!fb_info->pixmap.blit_x)\n\t\tfb_info->pixmap.blit_x = ~(u32)0;\n\n\tif (!fb_info->pixmap.blit_y)\n\t\tfb_info->pixmap.blit_y = ~(u32)0;\n\n\tif (!fb_info->modelist.prev || !fb_info->modelist.next)\n\t\tINIT_LIST_HEAD(&fb_info->modelist);\n\n\tif (fb_info->skip_vt_switch)\n\t\tpm_vt_switch_required(fb_info->device, false);\n\telse\n\t\tpm_vt_switch_required(fb_info->device, true);\n\n\tfb_var_to_videomode(&mode, &fb_info->var);\n\tfb_add_videomode(&mode, &fb_info->modelist);\n\tregistered_fb[i] = fb_info;\n\n#ifdef CONFIG_GUMSTIX_AM200EPD\n\t{\n\t\tstruct fb_event event;\n\t\tevent.info = fb_info;\n\t\tfb_notifier_call_chain(FB_EVENT_FB_REGISTERED, &event);\n\t}\n#endif\n\n\treturn fbcon_fb_registered(fb_info);\n}\n\nstatic void unbind_console(struct fb_info *fb_info)\n{\n\tint i = fb_info->node;\n\n\tif (WARN_ON(i < 0 || i >= FB_MAX || registered_fb[i] != fb_info))\n\t\treturn;\n\n\tfbcon_fb_unbind(fb_info);\n}\n\nstatic void unlink_framebuffer(struct fb_info *fb_info)\n{\n\tint i;\n\n\ti = fb_info->node;\n\tif (WARN_ON(i < 0 || i >= FB_MAX || registered_fb[i] != fb_info))\n\t\treturn;\n\n\tfb_device_destroy(fb_info);\n\tpm_vt_switch_unregister(fb_info->device);\n\tunbind_console(fb_info);\n}\n\nstatic void do_unregister_framebuffer(struct fb_info *fb_info)\n{\n\tunlink_framebuffer(fb_info);\n\tif (fb_info->pixmap.addr &&\n\t    (fb_info->pixmap.flags & FB_PIXMAP_DEFAULT)) {\n\t\tkfree(fb_info->pixmap.addr);\n\t\tfb_info->pixmap.addr = NULL;\n\t}\n\n\tfb_destroy_modelist(&fb_info->modelist);\n\tregistered_fb[fb_info->node] = NULL;\n\tnum_registered_fb--;\n#ifdef CONFIG_GUMSTIX_AM200EPD\n\t{\n\t\tstruct fb_event event;\n\t\tevent.info = fb_info;\n\t\tfb_notifier_call_chain(FB_EVENT_FB_UNREGISTERED, &event);\n\t}\n#endif\n\tfbcon_fb_unregistered(fb_info);\n\n\t \n\tput_fb_info(fb_info);\n}\n\n \nint\nregister_framebuffer(struct fb_info *fb_info)\n{\n\tint ret;\n\n\tmutex_lock(&registration_lock);\n\tret = do_register_framebuffer(fb_info);\n\tmutex_unlock(&registration_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(register_framebuffer);\n\n \nvoid\nunregister_framebuffer(struct fb_info *fb_info)\n{\n\tmutex_lock(&registration_lock);\n\tdo_unregister_framebuffer(fb_info);\n\tmutex_unlock(&registration_lock);\n}\nEXPORT_SYMBOL(unregister_framebuffer);\n\n \nvoid fb_set_suspend(struct fb_info *info, int state)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (state) {\n\t\tfbcon_suspended(info);\n\t\tinfo->state = FBINFO_STATE_SUSPENDED;\n\t} else {\n\t\tinfo->state = FBINFO_STATE_RUNNING;\n\t\tfbcon_resumed(info);\n\t}\n}\nEXPORT_SYMBOL(fb_set_suspend);\n\nstatic int __init fbmem_init(void)\n{\n\tint ret;\n\n\tfb_class = class_create(\"graphics\");\n\tif (IS_ERR(fb_class)) {\n\t\tret = PTR_ERR(fb_class);\n\t\tpr_err(\"Unable to create fb class; errno = %d\\n\", ret);\n\t\tgoto err_fb_class;\n\t}\n\n\tret = fb_init_procfs();\n\tif (ret)\n\t\tgoto err_class_destroy;\n\n\tret = fb_register_chrdev();\n\tif (ret)\n\t\tgoto err_fb_cleanup_procfs;\n\n\tfb_console_init();\n\n\treturn 0;\n\nerr_fb_cleanup_procfs:\n\tfb_cleanup_procfs();\nerr_class_destroy:\n\tclass_destroy(fb_class);\nerr_fb_class:\n\tfb_class = NULL;\n\treturn ret;\n}\n\n#ifdef MODULE\nstatic void __exit fbmem_exit(void)\n{\n\tfb_console_exit();\n\tfb_unregister_chrdev();\n\tfb_cleanup_procfs();\n\tclass_destroy(fb_class);\n}\n\nmodule_init(fbmem_init);\nmodule_exit(fbmem_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Framebuffer base\");\n#else\nsubsys_initcall(fbmem_init);\n#endif\n\nint fb_new_modelist(struct fb_info *info)\n{\n\tstruct fb_var_screeninfo var = info->var;\n\tstruct list_head *pos, *n;\n\tstruct fb_modelist *modelist;\n\tstruct fb_videomode *m, mode;\n\tint err;\n\n\tlist_for_each_safe(pos, n, &info->modelist) {\n\t\tmodelist = list_entry(pos, struct fb_modelist, list);\n\t\tm = &modelist->mode;\n\t\tfb_videomode_to_var(&var, m);\n\t\tvar.activate = FB_ACTIVATE_TEST;\n\t\terr = fb_set_var(info, &var);\n\t\tfb_var_to_videomode(&mode, &var);\n\t\tif (err || !fb_mode_is_equal(m, &mode)) {\n\t\t\tlist_del(pos);\n\t\t\tkfree(pos);\n\t\t}\n\t}\n\n\tif (list_empty(&info->modelist))\n\t\treturn 1;\n\n\tfbcon_new_modelist(info);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_VIDEO_NOMODESET)\nbool fb_modesetting_disabled(const char *drvname)\n{\n\tbool fwonly = video_firmware_drivers_only();\n\n\tif (fwonly)\n\t\tpr_warn(\"Driver %s not loading because of nomodeset parameter\\n\",\n\t\t\tdrvname);\n\n\treturn fwonly;\n}\nEXPORT_SYMBOL(fb_modesetting_disabled);\n#endif\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}