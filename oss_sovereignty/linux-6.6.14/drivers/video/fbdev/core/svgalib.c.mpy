{
  "module_name": "svgalib.c",
  "hash_id": "77dfc535619d0311eb071b131f0642f8ea7b12face4b6afc98712d566e571f0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/core/svgalib.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fb.h>\n#include <linux/math.h>\n#include <linux/svga.h>\n#include <asm/types.h>\n#include <asm/io.h>\n\n\n \nvoid svga_wcrt_multi(void __iomem *regbase, const struct vga_regset *regset, u32 value)\n{\n\tu8 regval, bitval, bitnum;\n\n\twhile (regset->regnum != VGA_REGSET_END_VAL) {\n\t\tregval = vga_rcrt(regbase, regset->regnum);\n\t\tbitnum = regset->lowbit;\n\t\twhile (bitnum <= regset->highbit) {\n\t\t\tbitval = 1 << bitnum;\n\t\t\tregval = regval & ~bitval;\n\t\t\tif (value & 1) regval = regval | bitval;\n\t\t\tbitnum ++;\n\t\t\tvalue = value >> 1;\n\t\t}\n\t\tvga_wcrt(regbase, regset->regnum, regval);\n\t\tregset ++;\n\t}\n}\n\n \nvoid svga_wseq_multi(void __iomem *regbase, const struct vga_regset *regset, u32 value)\n{\n\tu8 regval, bitval, bitnum;\n\n\twhile (regset->regnum != VGA_REGSET_END_VAL) {\n\t\tregval = vga_rseq(regbase, regset->regnum);\n\t\tbitnum = regset->lowbit;\n\t\twhile (bitnum <= regset->highbit) {\n\t\t\tbitval = 1 << bitnum;\n\t\t\tregval = regval & ~bitval;\n\t\t\tif (value & 1) regval = regval | bitval;\n\t\t\tbitnum ++;\n\t\t\tvalue = value >> 1;\n\t\t}\n\t\tvga_wseq(regbase, regset->regnum, regval);\n\t\tregset ++;\n\t}\n}\n\nstatic unsigned int svga_regset_size(const struct vga_regset *regset)\n{\n\tu8 count = 0;\n\n\twhile (regset->regnum != VGA_REGSET_END_VAL) {\n\t\tcount += regset->highbit - regset->lowbit + 1;\n\t\tregset ++;\n\t}\n\treturn 1 << count;\n}\n\n\n \n\n\n \nvoid svga_set_default_gfx_regs(void __iomem *regbase)\n{\n\t \n\tvga_wgfx(regbase, VGA_GFX_SR_VALUE, 0x00);\n\tvga_wgfx(regbase, VGA_GFX_SR_ENABLE, 0x00);\n\tvga_wgfx(regbase, VGA_GFX_COMPARE_VALUE, 0x00);\n\tvga_wgfx(regbase, VGA_GFX_DATA_ROTATE, 0x00);\n\tvga_wgfx(regbase, VGA_GFX_PLANE_READ, 0x00);\n\tvga_wgfx(regbase, VGA_GFX_MODE, 0x00);\n \n \n\tvga_wgfx(regbase, VGA_GFX_MISC, 0x05);\n \n\tvga_wgfx(regbase, VGA_GFX_COMPARE_MASK, 0x0F);\n\tvga_wgfx(regbase, VGA_GFX_BIT_MASK, 0xFF);\n}\n\n \nvoid svga_set_default_atc_regs(void __iomem *regbase)\n{\n\tu8 count;\n\n\tvga_r(regbase, 0x3DA);\n\tvga_w(regbase, VGA_ATT_W, 0x00);\n\n\t \n\tfor (count = 0; count <= 0xF; count ++)\n\t\tsvga_wattr(regbase, count, count);\n\n\tsvga_wattr(regbase, VGA_ATC_MODE, 0x01);\n \n\tsvga_wattr(regbase, VGA_ATC_OVERSCAN, 0x00);\n\tsvga_wattr(regbase, VGA_ATC_PLANE_ENABLE, 0x0F);\n\tsvga_wattr(regbase, VGA_ATC_PEL, 0x00);\n\tsvga_wattr(regbase, VGA_ATC_COLOR_PAGE, 0x00);\n\n\tvga_r(regbase, 0x3DA);\n\tvga_w(regbase, VGA_ATT_W, 0x20);\n}\n\n \nvoid svga_set_default_seq_regs(void __iomem *regbase)\n{\n\t \n\tvga_wseq(regbase, VGA_SEQ_CLOCK_MODE, VGA_SR01_CHAR_CLK_8DOTS);\n\tvga_wseq(regbase, VGA_SEQ_PLANE_WRITE, VGA_SR02_ALL_PLANES);\n\tvga_wseq(regbase, VGA_SEQ_CHARACTER_MAP, 0x00);\n \n\tvga_wseq(regbase, VGA_SEQ_MEMORY_MODE, VGA_SR04_EXT_MEM | VGA_SR04_SEQ_MODE);\n}\n\n \nvoid svga_set_default_crt_regs(void __iomem *regbase)\n{\n\t \n\tsvga_wcrt_mask(regbase, 0x03, 0x80, 0x80);\t \n\tvga_wcrt(regbase, VGA_CRTC_PRESET_ROW, 0);\n\tsvga_wcrt_mask(regbase, VGA_CRTC_MAX_SCAN, 0, 0x1F);\n\tvga_wcrt(regbase, VGA_CRTC_UNDERLINE, 0);\n\tvga_wcrt(regbase, VGA_CRTC_MODE, 0xE3);\n}\n\nvoid svga_set_textmode_vga_regs(void __iomem *regbase)\n{\n\t     \n\tvga_wseq(regbase, VGA_SEQ_MEMORY_MODE, VGA_SR04_EXT_MEM);\n\tvga_wseq(regbase, VGA_SEQ_PLANE_WRITE, 0x03);\n\n\tvga_wcrt(regbase, VGA_CRTC_MAX_SCAN, 0x0f);  \n\tvga_wcrt(regbase, VGA_CRTC_UNDERLINE, 0x1f);\n\tsvga_wcrt_mask(regbase, VGA_CRTC_MODE, 0x23, 0x7f);\n\n\tvga_wcrt(regbase, VGA_CRTC_CURSOR_START, 0x0d);\n\tvga_wcrt(regbase, VGA_CRTC_CURSOR_END, 0x0e);\n\tvga_wcrt(regbase, VGA_CRTC_CURSOR_HI, 0x00);\n\tvga_wcrt(regbase, VGA_CRTC_CURSOR_LO, 0x00);\n\n\tvga_wgfx(regbase, VGA_GFX_MODE, 0x10);  \n\tvga_wgfx(regbase, VGA_GFX_MISC, 0x0E);  \n\tvga_wgfx(regbase, VGA_GFX_COMPARE_MASK, 0x00);\n\n\tvga_r(regbase, 0x3DA);\n\tvga_w(regbase, VGA_ATT_W, 0x00);\n\n\tsvga_wattr(regbase, 0x10, 0x0C);\t\t\t \n\tsvga_wattr(regbase, 0x13, 0x08);\t\t\t \n\n\tvga_r(regbase, 0x3DA);\n\tvga_w(regbase, VGA_ATT_W, 0x20);\n}\n\n#if 0\nvoid svga_dump_var(struct fb_var_screeninfo *var, int node)\n{\n\tpr_debug(\"fb%d: var.vmode         : 0x%X\\n\", node, var->vmode);\n\tpr_debug(\"fb%d: var.xres          : %d\\n\", node, var->xres);\n\tpr_debug(\"fb%d: var.yres          : %d\\n\", node, var->yres);\n\tpr_debug(\"fb%d: var.bits_per_pixel: %d\\n\", node, var->bits_per_pixel);\n\tpr_debug(\"fb%d: var.xres_virtual  : %d\\n\", node, var->xres_virtual);\n\tpr_debug(\"fb%d: var.yres_virtual  : %d\\n\", node, var->yres_virtual);\n\tpr_debug(\"fb%d: var.left_margin   : %d\\n\", node, var->left_margin);\n\tpr_debug(\"fb%d: var.right_margin  : %d\\n\", node, var->right_margin);\n\tpr_debug(\"fb%d: var.upper_margin  : %d\\n\", node, var->upper_margin);\n\tpr_debug(\"fb%d: var.lower_margin  : %d\\n\", node, var->lower_margin);\n\tpr_debug(\"fb%d: var.hsync_len     : %d\\n\", node, var->hsync_len);\n\tpr_debug(\"fb%d: var.vsync_len     : %d\\n\", node, var->vsync_len);\n\tpr_debug(\"fb%d: var.sync          : 0x%X\\n\", node, var->sync);\n\tpr_debug(\"fb%d: var.pixclock      : %d\\n\\n\", node, var->pixclock);\n}\n#endif   \n\n\n \n\n\nvoid svga_settile(struct fb_info *info, struct fb_tilemap *map)\n{\n\tconst u8 *font = map->data;\n\tu8 __iomem *fb = (u8 __iomem *)info->screen_base;\n\tint i, c;\n\n\tif ((map->width != 8) || (map->height != 16) ||\n\t    (map->depth != 1) || (map->length != 256)) {\n\t\tfb_err(info, \"unsupported font parameters: width %d, height %d, depth %d, length %d\\n\",\n\t\t       map->width, map->height, map->depth, map->length);\n\t\treturn;\n\t}\n\n\tfb += 2;\n\tfor (c = 0; c < map->length; c++) {\n\t\tfor (i = 0; i < map->height; i++) {\n\t\t\tfb_writeb(font[i], fb + i * 4);\n\n\t\t}\n\t\tfb += 128;\n\t\tfont += map->height;\n\t}\n}\n\n \nvoid svga_tilecopy(struct fb_info *info, struct fb_tilearea *area)\n{\n\tint dx, dy;\n\t \n\tint colstride = 1 << (info->fix.type_aux & FB_AUX_TEXT_SVGA_MASK);\n\tint rowstride = colstride * (info->var.xres_virtual / 8);\n\tu16 __iomem *fb = (u16 __iomem *) info->screen_base;\n\tu16 __iomem *src, *dst;\n\n\tif ((area->sy > area->dy) ||\n\t    ((area->sy == area->dy) && (area->sx > area->dx))) {\n\t\tsrc = fb + area->sx * colstride + area->sy * rowstride;\n\t\tdst = fb + area->dx * colstride + area->dy * rowstride;\n\t    } else {\n\t\tsrc = fb + (area->sx + area->width - 1) * colstride\n\t\t\t + (area->sy + area->height - 1) * rowstride;\n\t\tdst = fb + (area->dx + area->width - 1) * colstride\n\t\t\t + (area->dy + area->height - 1) * rowstride;\n\n\t\tcolstride = -colstride;\n\t\trowstride = -rowstride;\n\t    }\n\n\tfor (dy = 0; dy < area->height; dy++) {\n\t\tu16 __iomem *src2 = src;\n\t\tu16 __iomem *dst2 = dst;\n\t\tfor (dx = 0; dx < area->width; dx++) {\n\t\t\tfb_writew(fb_readw(src2), dst2);\n\n\t\t\tsrc2 += colstride;\n\t\t\tdst2 += colstride;\n\t\t}\n\t\tsrc += rowstride;\n\t\tdst += rowstride;\n\t}\n}\n\n \nvoid svga_tilefill(struct fb_info *info, struct fb_tilerect *rect)\n{\n\tint dx, dy;\n\tint colstride = 2 << (info->fix.type_aux & FB_AUX_TEXT_SVGA_MASK);\n\tint rowstride = colstride * (info->var.xres_virtual / 8);\n\tint attr = (0x0F & rect->bg) << 4 | (0x0F & rect->fg);\n\tu8 __iomem *fb = (u8 __iomem *)info->screen_base;\n\tfb += rect->sx * colstride + rect->sy * rowstride;\n\n\tfor (dy = 0; dy < rect->height; dy++) {\n\t\tu8 __iomem *fb2 = fb;\n\t\tfor (dx = 0; dx < rect->width; dx++) {\n\t\t\tfb_writeb(rect->index, fb2);\n\t\t\tfb_writeb(attr, fb2 + 1);\n\t\t\tfb2 += colstride;\n\t\t}\n\t\tfb += rowstride;\n\t}\n}\n\n \nvoid svga_tileblit(struct fb_info *info, struct fb_tileblit *blit)\n{\n\tint dx, dy, i;\n\tint colstride = 2 << (info->fix.type_aux & FB_AUX_TEXT_SVGA_MASK);\n\tint rowstride = colstride * (info->var.xres_virtual / 8);\n\tint attr = (0x0F & blit->bg) << 4 | (0x0F & blit->fg);\n\tu8 __iomem *fb = (u8 __iomem *)info->screen_base;\n\tfb += blit->sx * colstride + blit->sy * rowstride;\n\n\ti=0;\n\tfor (dy=0; dy < blit->height; dy ++) {\n\t\tu8 __iomem *fb2 = fb;\n\t\tfor (dx = 0; dx < blit->width; dx ++) {\n\t\t\tfb_writeb(blit->indices[i], fb2);\n\t\t\tfb_writeb(attr, fb2 + 1);\n\t\t\tfb2 += colstride;\n\t\t\ti ++;\n\t\t\tif (i == blit->length) return;\n\t\t}\n\t\tfb += rowstride;\n\t}\n\n}\n\n \nvoid svga_tilecursor(void __iomem *regbase, struct fb_info *info, struct fb_tilecursor *cursor)\n{\n\tu8 cs = 0x0d;\n\tu8 ce = 0x0e;\n\tu16 pos =  cursor->sx + (info->var.xoffset /  8)\n\t\t+ (cursor->sy + (info->var.yoffset / 16))\n\t\t   * (info->var.xres_virtual / 8);\n\n\tif (! cursor -> mode)\n\t\treturn;\n\n\tsvga_wcrt_mask(regbase, 0x0A, 0x20, 0x20);  \n\n\tif (cursor -> shape == FB_TILE_CURSOR_NONE)\n\t\treturn;\n\n\tswitch (cursor -> shape) {\n\tcase FB_TILE_CURSOR_UNDERLINE:\n\t\tcs = 0x0d;\n\t\tbreak;\n\tcase FB_TILE_CURSOR_LOWER_THIRD:\n\t\tcs = 0x09;\n\t\tbreak;\n\tcase FB_TILE_CURSOR_LOWER_HALF:\n\t\tcs = 0x07;\n\t\tbreak;\n\tcase FB_TILE_CURSOR_TWO_THIRDS:\n\t\tcs = 0x05;\n\t\tbreak;\n\tcase FB_TILE_CURSOR_BLOCK:\n\t\tcs = 0x01;\n\t\tbreak;\n\t}\n\n\t \n\tvga_wcrt(regbase, 0x0E, pos >> 8);\n\tvga_wcrt(regbase, 0x0F, pos & 0xFF);\n\n\tvga_wcrt(regbase, 0x0B, ce);  \n\tvga_wcrt(regbase, 0x0A, cs);  \n}\n\nint svga_get_tilemax(struct fb_info *info)\n{\n\treturn 256;\n}\n\n \n\nvoid svga_get_caps(struct fb_info *info, struct fb_blit_caps *caps,\n\t\t   struct fb_var_screeninfo *var)\n{\n\tif (var->bits_per_pixel == 0) {\n\t\t \n\t\tcaps->x = 1 << (8 - 1);\n\t\tcaps->y = 1 << (16 - 1);\n\t\tcaps->len = 256;\n\t} else {\n\t\tcaps->x = (var->bits_per_pixel == 4) ? 1 << (8 - 1) : ~(u32)0;\n\t\tcaps->y = ~(u32)0;\n\t\tcaps->len = ~(u32)0;\n\t}\n}\nEXPORT_SYMBOL(svga_get_caps);\n\n \n\n\n \nint svga_compute_pll(const struct svga_pll *pll, u32 f_wanted, u16 *m, u16 *n, u16 *r, int node)\n{\n\tu16 am, an, ar;\n\tu32 f_vco, f_current, delta_current, delta_best;\n\n\tpr_debug(\"fb%d: ideal frequency: %d kHz\\n\", node, (unsigned int) f_wanted);\n\n\tar = pll->r_max;\n\tf_vco = f_wanted << ar;\n\n\t \n\tif ((f_vco >> ar) != f_wanted)\n\t\treturn -EINVAL;\n\n\t \n\twhile ((ar > pll->r_min) && (f_vco > pll->f_vco_max)) {\n\t\tar--;\n\t\tf_vco = f_vco >> 1;\n\t}\n\n\t \n\tif ((f_vco < pll->f_vco_min) || (f_vco > pll->f_vco_max))\n\t\treturn -EINVAL;\n\n\tdelta_best = 0xFFFFFFFF;\n\t*m = 0;\n\t*n = 0;\n\t*r = ar;\n\n\tam = pll->m_min;\n\tan = pll->n_min;\n\n\twhile ((am <= pll->m_max) && (an <= pll->n_max)) {\n\t\tf_current = (pll->f_base * am) / an;\n\t\tdelta_current = abs_diff (f_current, f_vco);\n\n\t\tif (delta_current < delta_best) {\n\t\t\tdelta_best = delta_current;\n\t\t\t*m = am;\n\t\t\t*n = an;\n\t\t}\n\n\t\tif (f_current <= f_vco) {\n\t\t\tam ++;\n\t\t} else {\n\t\t\tan ++;\n\t\t}\n\t}\n\n\tf_current = (pll->f_base * *m) / *n;\n\tpr_debug(\"fb%d: found frequency: %d kHz (VCO %d kHz)\\n\", node, (int) (f_current >> ar), (int) f_current);\n\tpr_debug(\"fb%d: m = %d n = %d r = %d\\n\", node, (unsigned int) *m, (unsigned int) *n, (unsigned int) *r);\n\treturn 0;\n}\n\n\n \n\n\n \nint svga_check_timings(const struct svga_timing_regs *tm, struct fb_var_screeninfo *var, int node)\n{\n\tu32 value;\n\n\tvar->xres         = (var->xres+7)&~7;\n\tvar->left_margin  = (var->left_margin+7)&~7;\n\tvar->right_margin = (var->right_margin+7)&~7;\n\tvar->hsync_len    = (var->hsync_len+7)&~7;\n\n\t \n\tvalue = var->xres + var->left_margin + var->right_margin + var->hsync_len;\n\tif (((value / 8) - 5) >= svga_regset_size (tm->h_total_regs))\n\t\treturn -EINVAL;\n\n\t \n\tvalue = var->xres;\n\tif (((value / 8) - 1) >= svga_regset_size (tm->h_display_regs))\n\t\treturn -EINVAL;\n\tif (((value / 8) - 1) >= svga_regset_size (tm->h_blank_start_regs))\n\t\treturn -EINVAL;\n\n\t \n\tvalue = var->xres + var->right_margin;\n\tif (((value / 8) - 1) >= svga_regset_size (tm->h_sync_start_regs))\n\t\treturn -EINVAL;\n\n\t \n\tvalue = var->left_margin + var->right_margin + var->hsync_len;\n\tif ((value == 0) || ((value / 8) >= svga_regset_size (tm->h_blank_end_regs)))\n\t\treturn -EINVAL;\n\n\t \n\tvalue = var->hsync_len;\n\tif ((value == 0) || ((value / 8) >= svga_regset_size (tm->h_sync_end_regs)))\n\t\treturn -EINVAL;\n\n\t \n\tvalue = var->yres + var->upper_margin + var->lower_margin + var->vsync_len;\n\tif ((value - 1) >= svga_regset_size(tm->v_total_regs))\n\t\treturn -EINVAL;\n\n\t \n\tvalue = var->yres;\n\tif ((value - 1) >= svga_regset_size(tm->v_display_regs))\n\t\treturn -EINVAL;\n\tif ((value - 1) >= svga_regset_size(tm->v_blank_start_regs))\n\t\treturn -EINVAL;\n\n\t \n\tvalue = var->yres + var->lower_margin;\n\tif ((value - 1) >= svga_regset_size(tm->v_sync_start_regs))\n\t\treturn -EINVAL;\n\n\t \n\tvalue = var->upper_margin + var->lower_margin + var->vsync_len;\n\tif ((value == 0) || (value >= svga_regset_size (tm->v_blank_end_regs)))\n\t\treturn -EINVAL;\n\n\t \n\tvalue = var->vsync_len;\n\tif ((value == 0) || (value >= svga_regset_size (tm->v_sync_end_regs)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nvoid svga_set_timings(void __iomem *regbase, const struct svga_timing_regs *tm,\n\t\t      struct fb_var_screeninfo *var,\n\t\t      u32 hmul, u32 hdiv, u32 vmul, u32 vdiv, u32 hborder, int node)\n{\n\tu8 regval;\n\tu32 value;\n\n\tvalue = var->xres + var->left_margin + var->right_margin + var->hsync_len;\n\tvalue = (value * hmul) / hdiv;\n\tpr_debug(\"fb%d: horizontal total      : %d\\n\", node, value);\n\tsvga_wcrt_multi(regbase, tm->h_total_regs, (value / 8) - 5);\n\n\tvalue = var->xres;\n\tvalue = (value * hmul) / hdiv;\n\tpr_debug(\"fb%d: horizontal display    : %d\\n\", node, value);\n\tsvga_wcrt_multi(regbase, tm->h_display_regs, (value / 8) - 1);\n\n\tvalue = var->xres;\n\tvalue = (value * hmul) / hdiv;\n\tpr_debug(\"fb%d: horizontal blank start: %d\\n\", node, value);\n\tsvga_wcrt_multi(regbase, tm->h_blank_start_regs, (value / 8) - 1 + hborder);\n\n\tvalue = var->xres + var->left_margin + var->right_margin + var->hsync_len;\n\tvalue = (value * hmul) / hdiv;\n\tpr_debug(\"fb%d: horizontal blank end  : %d\\n\", node, value);\n\tsvga_wcrt_multi(regbase, tm->h_blank_end_regs, (value / 8) - 1 - hborder);\n\n\tvalue = var->xres + var->right_margin;\n\tvalue = (value * hmul) / hdiv;\n\tpr_debug(\"fb%d: horizontal sync start : %d\\n\", node, value);\n\tsvga_wcrt_multi(regbase, tm->h_sync_start_regs, (value / 8));\n\n\tvalue = var->xres + var->right_margin + var->hsync_len;\n\tvalue = (value * hmul) / hdiv;\n\tpr_debug(\"fb%d: horizontal sync end   : %d\\n\", node, value);\n\tsvga_wcrt_multi(regbase, tm->h_sync_end_regs, (value / 8));\n\n\tvalue = var->yres + var->upper_margin + var->lower_margin + var->vsync_len;\n\tvalue = (value * vmul) / vdiv;\n\tpr_debug(\"fb%d: vertical total        : %d\\n\", node, value);\n\tsvga_wcrt_multi(regbase, tm->v_total_regs, value - 2);\n\n\tvalue = var->yres;\n\tvalue = (value * vmul) / vdiv;\n\tpr_debug(\"fb%d: vertical display      : %d\\n\", node, value);\n\tsvga_wcrt_multi(regbase, tm->v_display_regs, value - 1);\n\n\tvalue = var->yres;\n\tvalue = (value * vmul) / vdiv;\n\tpr_debug(\"fb%d: vertical blank start  : %d\\n\", node, value);\n\tsvga_wcrt_multi(regbase, tm->v_blank_start_regs, value);\n\n\tvalue = var->yres + var->upper_margin + var->lower_margin + var->vsync_len;\n\tvalue = (value * vmul) / vdiv;\n\tpr_debug(\"fb%d: vertical blank end    : %d\\n\", node, value);\n\tsvga_wcrt_multi(regbase, tm->v_blank_end_regs, value - 2);\n\n\tvalue = var->yres + var->lower_margin;\n\tvalue = (value * vmul) / vdiv;\n\tpr_debug(\"fb%d: vertical sync start   : %d\\n\", node, value);\n\tsvga_wcrt_multi(regbase, tm->v_sync_start_regs, value);\n\n\tvalue = var->yres + var->lower_margin + var->vsync_len;\n\tvalue = (value * vmul) / vdiv;\n\tpr_debug(\"fb%d: vertical sync end     : %d\\n\", node, value);\n\tsvga_wcrt_multi(regbase, tm->v_sync_end_regs, value);\n\n\t \n\n\tregval = vga_r(regbase, VGA_MIS_R);\n\tif (var->sync & FB_SYNC_HOR_HIGH_ACT) {\n\t\tpr_debug(\"fb%d: positive horizontal sync\\n\", node);\n\t\tregval = regval & ~0x80;\n\t} else {\n\t\tpr_debug(\"fb%d: negative horizontal sync\\n\", node);\n\t\tregval = regval | 0x80;\n\t}\n\tif (var->sync & FB_SYNC_VERT_HIGH_ACT) {\n\t\tpr_debug(\"fb%d: positive vertical sync\\n\", node);\n\t\tregval = regval & ~0x40;\n\t} else {\n\t\tpr_debug(\"fb%d: negative vertical sync\\n\\n\", node);\n\t\tregval = regval | 0x40;\n\t}\n\tvga_w(regbase, VGA_MIS_W, regval);\n}\n\n\n \n\n\nstatic inline int match_format(const struct svga_fb_format *frm,\n\t\t\t       struct fb_var_screeninfo *var)\n{\n\tint i = 0;\n\tint stored = -EINVAL;\n\n\twhile (frm->bits_per_pixel != SVGA_FORMAT_END_VAL)\n\t{\n\t\tif ((var->bits_per_pixel == frm->bits_per_pixel) &&\n\t\t    (var->red.length     <= frm->red.length)     &&\n\t\t    (var->green.length   <= frm->green.length)   &&\n\t\t    (var->blue.length    <= frm->blue.length)    &&\n\t\t    (var->transp.length  <= frm->transp.length)  &&\n\t\t    (var->nonstd\t == frm->nonstd))\n\t\t\treturn i;\n\t\tif (var->bits_per_pixel == frm->bits_per_pixel)\n\t\t\tstored = i;\n\t\ti++;\n\t\tfrm++;\n\t}\n\treturn stored;\n}\n\nint svga_match_format(const struct svga_fb_format *frm,\n\t\t      struct fb_var_screeninfo *var,\n\t\t      struct fb_fix_screeninfo *fix)\n{\n\tint i = match_format(frm, var);\n\n\tif (i >= 0) {\n\t\tvar->bits_per_pixel = frm[i].bits_per_pixel;\n\t\tvar->red            = frm[i].red;\n\t\tvar->green          = frm[i].green;\n\t\tvar->blue           = frm[i].blue;\n\t\tvar->transp         = frm[i].transp;\n\t\tvar->nonstd         = frm[i].nonstd;\n\t\tif (fix != NULL) {\n\t\t\tfix->type      = frm[i].type;\n\t\t\tfix->type_aux  = frm[i].type_aux;\n\t\t\tfix->visual    = frm[i].visual;\n\t\t\tfix->xpanstep  = frm[i].xpanstep;\n\t\t}\n\t}\n\n\treturn i;\n}\n\n\nEXPORT_SYMBOL(svga_wcrt_multi);\nEXPORT_SYMBOL(svga_wseq_multi);\n\nEXPORT_SYMBOL(svga_set_default_gfx_regs);\nEXPORT_SYMBOL(svga_set_default_atc_regs);\nEXPORT_SYMBOL(svga_set_default_seq_regs);\nEXPORT_SYMBOL(svga_set_default_crt_regs);\nEXPORT_SYMBOL(svga_set_textmode_vga_regs);\n\nEXPORT_SYMBOL(svga_settile);\nEXPORT_SYMBOL(svga_tilecopy);\nEXPORT_SYMBOL(svga_tilefill);\nEXPORT_SYMBOL(svga_tileblit);\nEXPORT_SYMBOL(svga_tilecursor);\nEXPORT_SYMBOL(svga_get_tilemax);\n\nEXPORT_SYMBOL(svga_compute_pll);\nEXPORT_SYMBOL(svga_check_timings);\nEXPORT_SYMBOL(svga_set_timings);\nEXPORT_SYMBOL(svga_match_format);\n\nMODULE_AUTHOR(\"Ondrej Zajicek <santiago@crfreenet.org>\");\nMODULE_DESCRIPTION(\"Common utility functions for VGA-based graphics cards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}