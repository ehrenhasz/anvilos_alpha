{
  "module_name": "cfbimgblt.c",
  "hash_id": "b8155329618ac7e7dae610dbd284ab7afe64ccf92eff333b1450d520634b8903",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/core/cfbimgblt.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/fb.h>\n#include <asm/types.h>\n#include \"fb_draw.h\"\n\n#define DEBUG\n\n#ifdef DEBUG\n#define DPRINTK(fmt, args...) printk(KERN_DEBUG \"%s: \" fmt,__func__,## args)\n#else\n#define DPRINTK(fmt, args...)\n#endif\n\nstatic const u32 cfb_tab8_be[] = {\n    0x00000000,0x000000ff,0x0000ff00,0x0000ffff,\n    0x00ff0000,0x00ff00ff,0x00ffff00,0x00ffffff,\n    0xff000000,0xff0000ff,0xff00ff00,0xff00ffff,\n    0xffff0000,0xffff00ff,0xffffff00,0xffffffff\n};\n\nstatic const u32 cfb_tab8_le[] = {\n    0x00000000,0xff000000,0x00ff0000,0xffff0000,\n    0x0000ff00,0xff00ff00,0x00ffff00,0xffffff00,\n    0x000000ff,0xff0000ff,0x00ff00ff,0xffff00ff,\n    0x0000ffff,0xff00ffff,0x00ffffff,0xffffffff\n};\n\nstatic const u32 cfb_tab16_be[] = {\n    0x00000000, 0x0000ffff, 0xffff0000, 0xffffffff\n};\n\nstatic const u32 cfb_tab16_le[] = {\n    0x00000000, 0xffff0000, 0x0000ffff, 0xffffffff\n};\n\nstatic const u32 cfb_tab32[] = {\n\t0x00000000, 0xffffffff\n};\n\n#define FB_WRITEL fb_writel\n#define FB_READL  fb_readl\n\nstatic inline void color_imageblit(const struct fb_image *image,\n\t\t\t\t   struct fb_info *p, u8 __iomem *dst1,\n\t\t\t\t   u32 start_index,\n\t\t\t\t   u32 pitch_index)\n{\n\t \n\tu32 __iomem *dst, *dst2;\n\tu32 color = 0, val, shift;\n\tint i, n, bpp = p->var.bits_per_pixel;\n\tu32 null_bits = 32 - bpp;\n\tu32 *palette = (u32 *) p->pseudo_palette;\n\tconst u8 *src = image->data;\n\tu32 bswapmask = fb_compute_bswapmask(p);\n\n\tdst2 = (u32 __iomem *) dst1;\n\tfor (i = image->height; i--; ) {\n\t\tn = image->width;\n\t\tdst = (u32 __iomem *) dst1;\n\t\tshift = 0;\n\t\tval = 0;\n\n\t\tif (start_index) {\n\t\t\tu32 start_mask = ~fb_shifted_pixels_mask_u32(p,\n\t\t\t\t\t\tstart_index, bswapmask);\n\t\t\tval = FB_READL(dst) & start_mask;\n\t\t\tshift = start_index;\n\t\t}\n\t\twhile (n--) {\n\t\t\tif (p->fix.visual == FB_VISUAL_TRUECOLOR ||\n\t\t\t    p->fix.visual == FB_VISUAL_DIRECTCOLOR )\n\t\t\t\tcolor = palette[*src];\n\t\t\telse\n\t\t\t\tcolor = *src;\n\t\t\tcolor <<= FB_LEFT_POS(p, bpp);\n\t\t\tval |= FB_SHIFT_HIGH(p, color, shift ^ bswapmask);\n\t\t\tif (shift >= null_bits) {\n\t\t\t\tFB_WRITEL(val, dst++);\n\n\t\t\t\tval = (shift == null_bits) ? 0 :\n\t\t\t\t\tFB_SHIFT_LOW(p, color, 32 - shift);\n\t\t\t}\n\t\t\tshift += bpp;\n\t\t\tshift &= (32 - 1);\n\t\t\tsrc++;\n\t\t}\n\t\tif (shift) {\n\t\t\tu32 end_mask = fb_shifted_pixels_mask_u32(p, shift,\n\t\t\t\t\t\tbswapmask);\n\n\t\t\tFB_WRITEL((FB_READL(dst) & end_mask) | val, dst);\n\t\t}\n\t\tdst1 += p->fix.line_length;\n\t\tif (pitch_index) {\n\t\t\tdst2 += p->fix.line_length;\n\t\t\tdst1 = (u8 __iomem *)((long __force)dst2 & ~(sizeof(u32) - 1));\n\n\t\t\tstart_index += pitch_index;\n\t\t\tstart_index &= 32 - 1;\n\t\t}\n\t}\n}\n\nstatic inline void slow_imageblit(const struct fb_image *image, struct fb_info *p,\n\t\t\t\t  u8 __iomem *dst1, u32 fgcolor,\n\t\t\t\t  u32 bgcolor,\n\t\t\t\t  u32 start_index,\n\t\t\t\t  u32 pitch_index)\n{\n\tu32 shift, color = 0, bpp = p->var.bits_per_pixel;\n\tu32 __iomem *dst, *dst2;\n\tu32 val, pitch = p->fix.line_length;\n\tu32 null_bits = 32 - bpp;\n\tu32 spitch = (image->width+7)/8;\n\tconst u8 *src = image->data, *s;\n\tu32 i, j, l;\n\tu32 bswapmask = fb_compute_bswapmask(p);\n\n\tdst2 = (u32 __iomem *) dst1;\n\tfgcolor <<= FB_LEFT_POS(p, bpp);\n\tbgcolor <<= FB_LEFT_POS(p, bpp);\n\n\tfor (i = image->height; i--; ) {\n\t\tshift = val = 0;\n\t\tl = 8;\n\t\tj = image->width;\n\t\tdst = (u32 __iomem *) dst1;\n\t\ts = src;\n\n\t\t \n\t\tif (start_index) {\n\t\t\tu32 start_mask = ~fb_shifted_pixels_mask_u32(p,\n\t\t\t\t\t\tstart_index, bswapmask);\n\t\t\tval = FB_READL(dst) & start_mask;\n\t\t\tshift = start_index;\n\t\t}\n\n\t\twhile (j--) {\n\t\t\tl--;\n\t\t\tcolor = (*s & (1 << l)) ? fgcolor : bgcolor;\n\t\t\tval |= FB_SHIFT_HIGH(p, color, shift ^ bswapmask);\n\n\t\t\t \n\t\t\tif (shift >= null_bits) {\n\t\t\t\tFB_WRITEL(val, dst++);\n\t\t\t\tval = (shift == null_bits) ? 0 :\n\t\t\t\t\tFB_SHIFT_LOW(p, color, 32 - shift);\n\t\t\t}\n\t\t\tshift += bpp;\n\t\t\tshift &= (32 - 1);\n\t\t\tif (!l) { l = 8; s++; }\n\t\t}\n\n\t\t \n \t\tif (shift) {\n\t\t\tu32 end_mask = fb_shifted_pixels_mask_u32(p, shift,\n\t\t\t\t\t\tbswapmask);\n\n\t\t\tFB_WRITEL((FB_READL(dst) & end_mask) | val, dst);\n\t\t}\n\n\t\tdst1 += pitch;\n\t\tsrc += spitch;\n\t\tif (pitch_index) {\n\t\t\tdst2 += pitch;\n\t\t\tdst1 = (u8 __iomem *)((long __force)dst2 & ~(sizeof(u32) - 1));\n\t\t\tstart_index += pitch_index;\n\t\t\tstart_index &= 32 - 1;\n\t\t}\n\n\t}\n}\n\n \nstatic inline void fast_imageblit(const struct fb_image *image, struct fb_info *p,\n\t\t\t\t  u8 __iomem *dst1, u32 fgcolor,\n\t\t\t\t  u32 bgcolor)\n{\n\tu32 fgx = fgcolor, bgx = bgcolor, bpp = p->var.bits_per_pixel;\n\tu32 ppw = 32/bpp, spitch = (image->width + 7)/8;\n\tu32 bit_mask, eorx, shift;\n\tconst char *s = image->data, *src;\n\tu32 __iomem *dst;\n\tconst u32 *tab = NULL;\n\tsize_t tablen;\n\tu32 colortab[16];\n\tint i, j, k;\n\n\tswitch (bpp) {\n\tcase 8:\n\t\ttab = fb_be_math(p) ? cfb_tab8_be : cfb_tab8_le;\n\t\ttablen = 16;\n\t\tbreak;\n\tcase 16:\n\t\ttab = fb_be_math(p) ? cfb_tab16_be : cfb_tab16_le;\n\t\ttablen = 4;\n\t\tbreak;\n\tcase 32:\n\t\ttab = cfb_tab32;\n\t\ttablen = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (i = ppw-1; i--; ) {\n\t\tfgx <<= bpp;\n\t\tbgx <<= bpp;\n\t\tfgx |= fgcolor;\n\t\tbgx |= bgcolor;\n\t}\n\n\tbit_mask = (1 << ppw) - 1;\n\teorx = fgx ^ bgx;\n\tk = image->width/ppw;\n\n\tfor (i = 0; i < tablen; ++i)\n\t\tcolortab[i] = (tab[i] & eorx) ^ bgx;\n\n\tfor (i = image->height; i--; ) {\n\t\tdst = (u32 __iomem *)dst1;\n\t\tshift = 8;\n\t\tsrc = s;\n\n\t\t \n\t\tswitch (ppw) {\n\t\tcase 4:  \n\t\t\tfor (j = k; j >= 2; j -= 2, ++src) {\n\t\t\t\tFB_WRITEL(colortab[(*src >> 4) & bit_mask], dst++);\n\t\t\t\tFB_WRITEL(colortab[(*src >> 0) & bit_mask], dst++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tfor (j = k; j >= 4; j -= 4, ++src) {\n\t\t\t\tFB_WRITEL(colortab[(*src >> 6) & bit_mask], dst++);\n\t\t\t\tFB_WRITEL(colortab[(*src >> 4) & bit_mask], dst++);\n\t\t\t\tFB_WRITEL(colortab[(*src >> 2) & bit_mask], dst++);\n\t\t\t\tFB_WRITEL(colortab[(*src >> 0) & bit_mask], dst++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tfor (j = k; j >= 8; j -= 8, ++src) {\n\t\t\t\tFB_WRITEL(colortab[(*src >> 7) & bit_mask], dst++);\n\t\t\t\tFB_WRITEL(colortab[(*src >> 6) & bit_mask], dst++);\n\t\t\t\tFB_WRITEL(colortab[(*src >> 5) & bit_mask], dst++);\n\t\t\t\tFB_WRITEL(colortab[(*src >> 4) & bit_mask], dst++);\n\t\t\t\tFB_WRITEL(colortab[(*src >> 3) & bit_mask], dst++);\n\t\t\t\tFB_WRITEL(colortab[(*src >> 2) & bit_mask], dst++);\n\t\t\t\tFB_WRITEL(colortab[(*src >> 1) & bit_mask], dst++);\n\t\t\t\tFB_WRITEL(colortab[(*src >> 0) & bit_mask], dst++);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (; j--; ) {\n\t\t\tshift -= ppw;\n\t\t\tFB_WRITEL(colortab[(*src >> shift) & bit_mask], dst++);\n\t\t\tif (!shift) {\n\t\t\t\tshift = 8;\n\t\t\t\t++src;\n\t\t\t}\n\t\t}\n\n\t\tdst1 += p->fix.line_length;\n\t\ts += spitch;\n\t}\n}\n\nvoid cfb_imageblit(struct fb_info *p, const struct fb_image *image)\n{\n\tu32 fgcolor, bgcolor, start_index, bitstart, pitch_index = 0;\n\tu32 bpl = sizeof(u32), bpp = p->var.bits_per_pixel;\n\tu32 width = image->width;\n\tu32 dx = image->dx, dy = image->dy;\n\tu8 __iomem *dst1;\n\n\tif (p->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\n\tbitstart = (dy * p->fix.line_length * 8) + (dx * bpp);\n\tstart_index = bitstart & (32 - 1);\n\tpitch_index = (p->fix.line_length & (bpl - 1)) * 8;\n\n\tbitstart /= 8;\n\tbitstart &= ~(bpl - 1);\n\tdst1 = p->screen_base + bitstart;\n\n\tif (p->fbops->fb_sync)\n\t\tp->fbops->fb_sync(p);\n\n\tif (image->depth == 1) {\n\t\tif (p->fix.visual == FB_VISUAL_TRUECOLOR ||\n\t\t    p->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\t\tfgcolor = ((u32*)(p->pseudo_palette))[image->fg_color];\n\t\t\tbgcolor = ((u32*)(p->pseudo_palette))[image->bg_color];\n\t\t} else {\n\t\t\tfgcolor = image->fg_color;\n\t\t\tbgcolor = image->bg_color;\n\t\t}\n\n\t\tif (32 % bpp == 0 && !start_index && !pitch_index &&\n\t\t    ((width & (32/bpp-1)) == 0) &&\n\t\t    bpp >= 8 && bpp <= 32)\n\t\t\tfast_imageblit(image, p, dst1, fgcolor, bgcolor);\n\t\telse\n\t\t\tslow_imageblit(image, p, dst1, fgcolor, bgcolor,\n\t\t\t\t\tstart_index, pitch_index);\n\t} else\n\t\tcolor_imageblit(image, p, dst1, start_index, pitch_index);\n}\n\nEXPORT_SYMBOL(cfb_imageblit);\n\nMODULE_AUTHOR(\"James Simmons <jsimmons@users.sf.net>\");\nMODULE_DESCRIPTION(\"Generic software accelerated imaging drawing\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}