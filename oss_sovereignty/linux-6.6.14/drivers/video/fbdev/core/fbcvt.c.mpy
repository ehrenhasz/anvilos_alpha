{
  "module_name": "fbcvt.c",
  "hash_id": "e9bb131e34a4d088dcf932b670e7e2f6276898bec40452cd95fdcc5f12304ac8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/core/fbcvt.c",
  "human_readable_source": " \n#include <linux/fb.h>\n#include <linux/slab.h>\n\n#define FB_CVT_CELLSIZE               8\n#define FB_CVT_GTF_C                 40\n#define FB_CVT_GTF_J                 20\n#define FB_CVT_GTF_K                128\n#define FB_CVT_GTF_M                600\n#define FB_CVT_MIN_VSYNC_BP         550\n#define FB_CVT_MIN_VPORCH             3\n#define FB_CVT_MIN_BPORCH             6\n\n#define FB_CVT_RB_MIN_VBLANK        460\n#define FB_CVT_RB_HBLANK            160\n#define FB_CVT_RB_V_FPORCH            3\n\n#define FB_CVT_FLAG_REDUCED_BLANK 1\n#define FB_CVT_FLAG_MARGINS       2\n#define FB_CVT_FLAG_INTERLACED    4\n\nstruct fb_cvt_data {\n\tu32 xres;\n\tu32 yres;\n\tu32 refresh;\n\tu32 f_refresh;\n\tu32 pixclock;\n\tu32 hperiod;\n\tu32 hblank;\n\tu32 hfreq;\n\tu32 htotal;\n\tu32 vtotal;\n\tu32 vsync;\n\tu32 hsync;\n\tu32 h_front_porch;\n\tu32 h_back_porch;\n\tu32 v_front_porch;\n\tu32 v_back_porch;\n\tu32 h_margin;\n\tu32 v_margin;\n\tu32 interlace;\n\tu32 aspect_ratio;\n\tu32 active_pixels;\n\tu32 flags;\n\tu32 status;\n};\n\nstatic const unsigned char fb_cvt_vbi_tab[] = {\n\t4,         \n\t5,         \n\t6,         \n\t7,         \n\t7,         \n\t8,         \n\t9,         \n\t10         \n};\n\n \nstatic u32 fb_cvt_hperiod(struct fb_cvt_data *cvt)\n{\n\tu32 num = 1000000000/cvt->f_refresh;\n\tu32 den;\n\n\tif (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK) {\n\t\tnum -= FB_CVT_RB_MIN_VBLANK * 1000;\n\t\tden = 2 * (cvt->yres/cvt->interlace + 2 * cvt->v_margin);\n\t} else {\n\t\tnum -= FB_CVT_MIN_VSYNC_BP * 1000;\n\t\tden = 2 * (cvt->yres/cvt->interlace + cvt->v_margin * 2\n\t\t\t   + FB_CVT_MIN_VPORCH + cvt->interlace/2);\n\t}\n\n\treturn 2 * (num/den);\n}\n\n \nstatic u32 fb_cvt_ideal_duty_cycle(struct fb_cvt_data *cvt)\n{\n\tu32 c_prime = (FB_CVT_GTF_C - FB_CVT_GTF_J) *\n\t\t(FB_CVT_GTF_K) + 256 * FB_CVT_GTF_J;\n\tu32 m_prime = (FB_CVT_GTF_K * FB_CVT_GTF_M);\n\tu32 h_period_est = cvt->hperiod;\n\n\treturn (1000 * c_prime  - ((m_prime * h_period_est)/1000))/256;\n}\n\nstatic u32 fb_cvt_hblank(struct fb_cvt_data *cvt)\n{\n\tu32 hblank = 0;\n\n\tif (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK)\n\t\thblank = FB_CVT_RB_HBLANK;\n\telse {\n\t\tu32 ideal_duty_cycle = fb_cvt_ideal_duty_cycle(cvt);\n\t\tu32 active_pixels = cvt->active_pixels;\n\n\t\tif (ideal_duty_cycle < 20000)\n\t\t\thblank = (active_pixels * 20000)/\n\t\t\t\t(100000 - 20000);\n\t\telse {\n\t\t\thblank = (active_pixels * ideal_duty_cycle)/\n\t\t\t\t(100000 - ideal_duty_cycle);\n\t\t}\n\t}\n\n\thblank &= ~((2 * FB_CVT_CELLSIZE) - 1);\n\n\treturn hblank;\n}\n\nstatic u32 fb_cvt_hsync(struct fb_cvt_data *cvt)\n{\n\tu32 hsync;\n\n\tif (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK)\n\t\thsync = 32;\n\telse\n\t\thsync = (FB_CVT_CELLSIZE * cvt->htotal)/100;\n\n\thsync &= ~(FB_CVT_CELLSIZE - 1);\n\treturn hsync;\n}\n\nstatic u32 fb_cvt_vbi_lines(struct fb_cvt_data *cvt)\n{\n\tu32 vbi_lines, min_vbi_lines, act_vbi_lines;\n\n\tif (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK) {\n\t\tvbi_lines = (1000 * FB_CVT_RB_MIN_VBLANK)/cvt->hperiod + 1;\n\t\tmin_vbi_lines =  FB_CVT_RB_V_FPORCH + cvt->vsync +\n\t\t\tFB_CVT_MIN_BPORCH;\n\n\t} else {\n\t\tvbi_lines = (FB_CVT_MIN_VSYNC_BP * 1000)/cvt->hperiod + 1 +\n\t\t\t FB_CVT_MIN_VPORCH;\n\t\tmin_vbi_lines = cvt->vsync + FB_CVT_MIN_BPORCH +\n\t\t\tFB_CVT_MIN_VPORCH;\n\t}\n\n\tif (vbi_lines < min_vbi_lines)\n\t\tact_vbi_lines = min_vbi_lines;\n\telse\n\t\tact_vbi_lines = vbi_lines;\n\n\treturn act_vbi_lines;\n}\n\nstatic u32 fb_cvt_vtotal(struct fb_cvt_data *cvt)\n{\n\tu32 vtotal = cvt->yres/cvt->interlace;\n\n\tvtotal += 2 * cvt->v_margin + cvt->interlace/2 + fb_cvt_vbi_lines(cvt);\n\tvtotal |= cvt->interlace/2;\n\n\treturn vtotal;\n}\n\nstatic u32 fb_cvt_pixclock(struct fb_cvt_data *cvt)\n{\n\tu32 pixclock;\n\n\tif (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK)\n\t\tpixclock = (cvt->f_refresh * cvt->vtotal * cvt->htotal)/1000;\n\telse\n\t\tpixclock = (cvt->htotal * 1000000)/cvt->hperiod;\n\n\tpixclock /= 250;\n\tpixclock *= 250;\n\tpixclock *= 1000;\n\n\treturn pixclock;\n}\n\nstatic u32 fb_cvt_aspect_ratio(struct fb_cvt_data *cvt)\n{\n\tu32 xres = cvt->xres;\n\tu32 yres = cvt->yres;\n\tu32 aspect = -1;\n\n\tif (xres == (yres * 4)/3 && !((yres * 4) % 3))\n\t\taspect = 0;\n\telse if (xres == (yres * 16)/9 && !((yres * 16) % 9))\n\t\taspect = 1;\n\telse if (xres == (yres * 16)/10 && !((yres * 16) % 10))\n\t\taspect = 2;\n\telse if (xres == (yres * 5)/4 && !((yres * 5) % 4))\n\t\taspect = 3;\n\telse if (xres == (yres * 15)/9 && !((yres * 15) % 9))\n\t\taspect = 4;\n\telse {\n\t\tprintk(KERN_INFO \"fbcvt: Aspect ratio not CVT \"\n\t\t       \"standard\\n\");\n\t\taspect = 7;\n\t\tcvt->status = 1;\n\t}\n\n\treturn aspect;\n}\n\nstatic void fb_cvt_print_name(struct fb_cvt_data *cvt)\n{\n\tu32 pixcount, pixcount_mod;\n\tint size = 256;\n\tint off = 0;\n\tu8 *buf;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tpixcount = (cvt->xres * (cvt->yres/cvt->interlace))/1000000;\n\tpixcount_mod = (cvt->xres * (cvt->yres/cvt->interlace)) % 1000000;\n\tpixcount_mod /= 1000;\n\n\toff += scnprintf(buf + off, size - off, \"fbcvt: %dx%d@%d: CVT Name - \",\n\t\t\t    cvt->xres, cvt->yres, cvt->refresh);\n\n\tif (cvt->status) {\n\t\toff += scnprintf(buf + off, size - off,\n\t\t\t\t \"Not a CVT standard - %d.%03d Mega Pixel Image\\n\",\n\t\t\t\t pixcount, pixcount_mod);\n\t} else {\n\t\tif (pixcount)\n\t\t\toff += scnprintf(buf + off, size - off, \"%d\", pixcount);\n\n\t\toff += scnprintf(buf + off, size - off, \".%03dM\", pixcount_mod);\n\n\t\tif (cvt->aspect_ratio == 0)\n\t\t\toff += scnprintf(buf + off, size - off, \"3\");\n\t\telse if (cvt->aspect_ratio == 3)\n\t\t\toff += scnprintf(buf + off, size - off, \"4\");\n\t\telse if (cvt->aspect_ratio == 1 || cvt->aspect_ratio == 4)\n\t\t\toff += scnprintf(buf + off, size - off, \"9\");\n\t\telse if (cvt->aspect_ratio == 2)\n\t\t\toff += scnprintf(buf + off, size - off, \"A\");\n\n\t\tif (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK)\n\t\t\toff += scnprintf(buf + off, size - off, \"-R\");\n\t}\n\n\tprintk(KERN_INFO \"%s\\n\", buf);\n\tkfree(buf);\n}\n\nstatic void fb_cvt_convert_to_mode(struct fb_cvt_data *cvt,\n\t\t\t\t   struct fb_videomode *mode)\n{\n\tmode->refresh = cvt->f_refresh;\n\tmode->pixclock = KHZ2PICOS(cvt->pixclock/1000);\n\tmode->left_margin = cvt->h_back_porch;\n\tmode->right_margin = cvt->h_front_porch;\n\tmode->hsync_len = cvt->hsync;\n\tmode->upper_margin = cvt->v_back_porch;\n\tmode->lower_margin = cvt->v_front_porch;\n\tmode->vsync_len = cvt->vsync;\n\n\tmode->sync &= ~(FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT);\n\n\tif (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK)\n\t\tmode->sync |= FB_SYNC_HOR_HIGH_ACT;\n\telse\n\t\tmode->sync |= FB_SYNC_VERT_HIGH_ACT;\n}\n\n \nint fb_find_mode_cvt(struct fb_videomode *mode, int margins, int rb)\n{\n\tstruct fb_cvt_data cvt;\n\n\tmemset(&cvt, 0, sizeof(cvt));\n\n\tif (margins)\n\t    cvt.flags |= FB_CVT_FLAG_MARGINS;\n\n\tif (rb)\n\t    cvt.flags |= FB_CVT_FLAG_REDUCED_BLANK;\n\n\tif (mode->vmode & FB_VMODE_INTERLACED)\n\t    cvt.flags |= FB_CVT_FLAG_INTERLACED;\n\n\tcvt.xres = mode->xres;\n\tcvt.yres = mode->yres;\n\tcvt.refresh = mode->refresh;\n\tcvt.f_refresh = cvt.refresh;\n\tcvt.interlace = 1;\n\n\tif (!cvt.xres || !cvt.yres || !cvt.refresh) {\n\t\tprintk(KERN_INFO \"fbcvt: Invalid input parameters\\n\");\n\t\treturn 1;\n\t}\n\n\tif (!(cvt.refresh == 50 || cvt.refresh == 60 || cvt.refresh == 70 ||\n\t      cvt.refresh == 85)) {\n\t\tprintk(KERN_INFO \"fbcvt: Refresh rate not CVT \"\n\t\t       \"standard\\n\");\n\t\tcvt.status = 1;\n\t}\n\n\tcvt.xres &= ~(FB_CVT_CELLSIZE - 1);\n\n\tif (cvt.flags & FB_CVT_FLAG_INTERLACED) {\n\t\tcvt.interlace = 2;\n\t\tcvt.f_refresh *= 2;\n\t}\n\n\tif (cvt.flags & FB_CVT_FLAG_REDUCED_BLANK) {\n\t\tif (cvt.refresh != 60) {\n\t\t\tprintk(KERN_INFO \"fbcvt: 60Hz refresh rate \"\n\t\t\t       \"advised for reduced blanking\\n\");\n\t\t\tcvt.status = 1;\n\t\t}\n\t}\n\n\tif (cvt.flags & FB_CVT_FLAG_MARGINS) {\n\t\tcvt.h_margin = (cvt.xres * 18)/1000;\n\t\tcvt.h_margin &= ~(FB_CVT_CELLSIZE - 1);\n\t\tcvt.v_margin = ((cvt.yres/cvt.interlace)* 18)/1000;\n\t}\n\n\tcvt.aspect_ratio = fb_cvt_aspect_ratio(&cvt);\n\tcvt.active_pixels = cvt.xres + 2 * cvt.h_margin;\n\tcvt.hperiod = fb_cvt_hperiod(&cvt);\n\tcvt.vsync = fb_cvt_vbi_tab[cvt.aspect_ratio];\n\tcvt.vtotal = fb_cvt_vtotal(&cvt);\n\tcvt.hblank = fb_cvt_hblank(&cvt);\n\tcvt.htotal = cvt.active_pixels + cvt.hblank;\n\tcvt.hsync = fb_cvt_hsync(&cvt);\n\tcvt.pixclock = fb_cvt_pixclock(&cvt);\n\tcvt.hfreq = cvt.pixclock/cvt.htotal;\n\tcvt.h_back_porch = cvt.hblank/2 + cvt.h_margin;\n\tcvt.h_front_porch = cvt.hblank - cvt.hsync - cvt.h_back_porch +\n\t\t2 * cvt.h_margin;\n\tcvt.v_front_porch = 3 + cvt.v_margin;\n\tcvt.v_back_porch = cvt.vtotal - cvt.yres/cvt.interlace -\n\t    cvt.v_front_porch - cvt.vsync;\n\tfb_cvt_print_name(&cvt);\n\tfb_cvt_convert_to_mode(&cvt, mode);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}