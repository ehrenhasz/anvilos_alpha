{
  "module_name": "fbcmap.c",
  "hash_id": "7c881c930474dd789cffc30006dc8d3c960ca4b1dd516ad69b409db78b524b9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/core/fbcmap.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/fb.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic u16 red2[] __read_mostly = {\n    0x0000, 0xaaaa\n};\nstatic u16 green2[] __read_mostly = {\n    0x0000, 0xaaaa\n};\nstatic u16 blue2[] __read_mostly = {\n    0x0000, 0xaaaa\n};\n\nstatic u16 red4[] __read_mostly = {\n    0x0000, 0xaaaa, 0x5555, 0xffff\n};\nstatic u16 green4[] __read_mostly = {\n    0x0000, 0xaaaa, 0x5555, 0xffff\n};\nstatic u16 blue4[] __read_mostly = {\n    0x0000, 0xaaaa, 0x5555, 0xffff\n};\n\nstatic u16 red8[] __read_mostly = {\n    0x0000, 0x0000, 0x0000, 0x0000, 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa\n};\nstatic u16 green8[] __read_mostly = {\n    0x0000, 0x0000, 0xaaaa, 0xaaaa, 0x0000, 0x0000, 0x5555, 0xaaaa\n};\nstatic u16 blue8[] __read_mostly = {\n    0x0000, 0xaaaa, 0x0000, 0xaaaa, 0x0000, 0xaaaa, 0x0000, 0xaaaa\n};\n\nstatic u16 red16[] __read_mostly = {\n    0x0000, 0x0000, 0x0000, 0x0000, 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,\n    0x5555, 0x5555, 0x5555, 0x5555, 0xffff, 0xffff, 0xffff, 0xffff\n};\nstatic u16 green16[] __read_mostly = {\n    0x0000, 0x0000, 0xaaaa, 0xaaaa, 0x0000, 0x0000, 0x5555, 0xaaaa,\n    0x5555, 0x5555, 0xffff, 0xffff, 0x5555, 0x5555, 0xffff, 0xffff\n};\nstatic u16 blue16[] __read_mostly = {\n    0x0000, 0xaaaa, 0x0000, 0xaaaa, 0x0000, 0xaaaa, 0x0000, 0xaaaa,\n    0x5555, 0xffff, 0x5555, 0xffff, 0x5555, 0xffff, 0x5555, 0xffff\n};\n\nstatic const struct fb_cmap default_2_colors = {\n    .len=2, .red=red2, .green=green2, .blue=blue2\n};\nstatic const struct fb_cmap default_8_colors = {\n    .len=8, .red=red8, .green=green8, .blue=blue8\n};\nstatic const struct fb_cmap default_4_colors = {\n    .len=4, .red=red4, .green=green4, .blue=blue4\n};\nstatic const struct fb_cmap default_16_colors = {\n    .len=16, .red=red16, .green=green16, .blue=blue16\n};\n\n\n\n \n\nint fb_alloc_cmap_gfp(struct fb_cmap *cmap, int len, int transp, gfp_t flags)\n{\n\tint size = len * sizeof(u16);\n\tint ret = -ENOMEM;\n\n\tflags |= __GFP_NOWARN;\n\n\tif (cmap->len != len) {\n\t\tfb_dealloc_cmap(cmap);\n\t\tif (!len)\n\t\t\treturn 0;\n\n\t\tcmap->red = kzalloc(size, flags);\n\t\tif (!cmap->red)\n\t\t\tgoto fail;\n\t\tcmap->green = kzalloc(size, flags);\n\t\tif (!cmap->green)\n\t\t\tgoto fail;\n\t\tcmap->blue = kzalloc(size, flags);\n\t\tif (!cmap->blue)\n\t\t\tgoto fail;\n\t\tif (transp) {\n\t\t\tcmap->transp = kzalloc(size, flags);\n\t\t\tif (!cmap->transp)\n\t\t\t\tgoto fail;\n\t\t} else {\n\t\t\tcmap->transp = NULL;\n\t\t}\n\t}\n\tcmap->start = 0;\n\tcmap->len = len;\n\tret = fb_copy_cmap(fb_default_cmap(len), cmap);\n\tif (ret)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tfb_dealloc_cmap(cmap);\n\treturn ret;\n}\n\nint fb_alloc_cmap(struct fb_cmap *cmap, int len, int transp)\n{\n\treturn fb_alloc_cmap_gfp(cmap, len, transp, GFP_ATOMIC);\n}\n\n \n\nvoid fb_dealloc_cmap(struct fb_cmap *cmap)\n{\n\tkfree(cmap->red);\n\tkfree(cmap->green);\n\tkfree(cmap->blue);\n\tkfree(cmap->transp);\n\n\tcmap->red = cmap->green = cmap->blue = cmap->transp = NULL;\n\tcmap->len = 0;\n}\n\n \n\nint fb_copy_cmap(const struct fb_cmap *from, struct fb_cmap *to)\n{\n\tunsigned int tooff = 0, fromoff = 0;\n\tsize_t size;\n\n\tif (to->start > from->start)\n\t\tfromoff = to->start - from->start;\n\telse\n\t\ttooff = from->start - to->start;\n\tif (fromoff >= from->len || tooff >= to->len)\n\t\treturn -EINVAL;\n\n\tsize = min_t(size_t, to->len - tooff, from->len - fromoff);\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tsize *= sizeof(u16);\n\n\tmemcpy(to->red+tooff, from->red+fromoff, size);\n\tmemcpy(to->green+tooff, from->green+fromoff, size);\n\tmemcpy(to->blue+tooff, from->blue+fromoff, size);\n\tif (from->transp && to->transp)\n\t\tmemcpy(to->transp+tooff, from->transp+fromoff, size);\n\treturn 0;\n}\n\nint fb_cmap_to_user(const struct fb_cmap *from, struct fb_cmap_user *to)\n{\n\tunsigned int tooff = 0, fromoff = 0;\n\tsize_t size;\n\n\tif (to->start > from->start)\n\t\tfromoff = to->start - from->start;\n\telse\n\t\ttooff = from->start - to->start;\n\tif (fromoff >= from->len || tooff >= to->len)\n\t\treturn -EINVAL;\n\n\tsize = min_t(size_t, to->len - tooff, from->len - fromoff);\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tsize *= sizeof(u16);\n\n\tif (copy_to_user(to->red+tooff, from->red+fromoff, size))\n\t\treturn -EFAULT;\n\tif (copy_to_user(to->green+tooff, from->green+fromoff, size))\n\t\treturn -EFAULT;\n\tif (copy_to_user(to->blue+tooff, from->blue+fromoff, size))\n\t\treturn -EFAULT;\n\tif (from->transp && to->transp)\n\t\tif (copy_to_user(to->transp+tooff, from->transp+fromoff, size))\n\t\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \n\nint fb_set_cmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tint i, start, rc = 0;\n\tu16 *red, *green, *blue, *transp;\n\tu_int hred, hgreen, hblue, htransp = 0xffff;\n\n\tred = cmap->red;\n\tgreen = cmap->green;\n\tblue = cmap->blue;\n\ttransp = cmap->transp;\n\tstart = cmap->start;\n\n\tif (start < 0 || (!info->fbops->fb_setcolreg &&\n\t\t\t  !info->fbops->fb_setcmap))\n\t\treturn -EINVAL;\n\tif (info->fbops->fb_setcmap) {\n\t\trc = info->fbops->fb_setcmap(cmap, info);\n\t} else {\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\thred = *red++;\n\t\t\thgreen = *green++;\n\t\t\thblue = *blue++;\n\t\t\tif (transp)\n\t\t\t\thtransp = *transp++;\n\t\t\tif (info->fbops->fb_setcolreg(start++,\n\t\t\t\t\t\t      hred, hgreen, hblue,\n\t\t\t\t\t\t      htransp, info))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (rc == 0)\n\t\tfb_copy_cmap(cmap, &info->cmap);\n\n\treturn rc;\n}\n\nint fb_set_user_cmap(struct fb_cmap_user *cmap, struct fb_info *info)\n{\n\tint rc, size = cmap->len * sizeof(u16);\n\tstruct fb_cmap umap;\n\n\tif (size < 0 || size < cmap->len)\n\t\treturn -E2BIG;\n\n\tmemset(&umap, 0, sizeof(struct fb_cmap));\n\trc = fb_alloc_cmap_gfp(&umap, cmap->len, cmap->transp != NULL,\n\t\t\t\tGFP_KERNEL);\n\tif (rc)\n\t\treturn rc;\n\tif (copy_from_user(umap.red, cmap->red, size) ||\n\t    copy_from_user(umap.green, cmap->green, size) ||\n\t    copy_from_user(umap.blue, cmap->blue, size) ||\n\t    (cmap->transp && copy_from_user(umap.transp, cmap->transp, size))) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\tumap.start = cmap->start;\n\tlock_fb_info(info);\n\trc = fb_set_cmap(&umap, info);\n\tunlock_fb_info(info);\nout:\n\tfb_dealloc_cmap(&umap);\n\treturn rc;\n}\n\n \n\nconst struct fb_cmap *fb_default_cmap(int len)\n{\n    if (len <= 2)\n\treturn &default_2_colors;\n    if (len <= 4)\n\treturn &default_4_colors;\n    if (len <= 8)\n\treturn &default_8_colors;\n    return &default_16_colors;\n}\n\n\n \n\nvoid fb_invert_cmaps(void)\n{\n    u_int i;\n\n    for (i = 0; i < ARRAY_SIZE(red2); i++) {\n\tred2[i] = ~red2[i];\n\tgreen2[i] = ~green2[i];\n\tblue2[i] = ~blue2[i];\n    }\n    for (i = 0; i < ARRAY_SIZE(red4); i++) {\n\tred4[i] = ~red4[i];\n\tgreen4[i] = ~green4[i];\n\tblue4[i] = ~blue4[i];\n    }\n    for (i = 0; i < ARRAY_SIZE(red8); i++) {\n\tred8[i] = ~red8[i];\n\tgreen8[i] = ~green8[i];\n\tblue8[i] = ~blue8[i];\n    }\n    for (i = 0; i < ARRAY_SIZE(red16); i++) {\n\tred16[i] = ~red16[i];\n\tgreen16[i] = ~green16[i];\n\tblue16[i] = ~blue16[i];\n    }\n}\n\n\n     \n\nEXPORT_SYMBOL(fb_alloc_cmap);\nEXPORT_SYMBOL(fb_dealloc_cmap);\nEXPORT_SYMBOL(fb_copy_cmap);\nEXPORT_SYMBOL(fb_set_cmap);\nEXPORT_SYMBOL(fb_default_cmap);\nEXPORT_SYMBOL(fb_invert_cmaps);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}