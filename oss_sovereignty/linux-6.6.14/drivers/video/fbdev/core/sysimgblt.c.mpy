{
  "module_name": "sysimgblt.c",
  "hash_id": "a1629fac9e53d18710c214dd9b381fe86fbdccdcdd6dfd2106cf8f6cf0467edd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/core/sysimgblt.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/fb.h>\n#include <asm/types.h>\n\n#define DEBUG\n\n#ifdef DEBUG\n#define DPRINTK(fmt, args...) printk(KERN_DEBUG \"%s: \" fmt,__func__,## args)\n#else\n#define DPRINTK(fmt, args...)\n#endif\n\nstatic const u32 cfb_tab8_be[] = {\n    0x00000000,0x000000ff,0x0000ff00,0x0000ffff,\n    0x00ff0000,0x00ff00ff,0x00ffff00,0x00ffffff,\n    0xff000000,0xff0000ff,0xff00ff00,0xff00ffff,\n    0xffff0000,0xffff00ff,0xffffff00,0xffffffff\n};\n\nstatic const u32 cfb_tab8_le[] = {\n    0x00000000,0xff000000,0x00ff0000,0xffff0000,\n    0x0000ff00,0xff00ff00,0x00ffff00,0xffffff00,\n    0x000000ff,0xff0000ff,0x00ff00ff,0xffff00ff,\n    0x0000ffff,0xff00ffff,0x00ffffff,0xffffffff\n};\n\nstatic const u32 cfb_tab16_be[] = {\n    0x00000000, 0x0000ffff, 0xffff0000, 0xffffffff\n};\n\nstatic const u32 cfb_tab16_le[] = {\n    0x00000000, 0xffff0000, 0x0000ffff, 0xffffffff\n};\n\nstatic const u32 cfb_tab32[] = {\n\t0x00000000, 0xffffffff\n};\n\nstatic void color_imageblit(const struct fb_image *image, struct fb_info *p,\n\t\t\t    void *dst1, u32 start_index, u32 pitch_index)\n{\n\t \n\tu32 *dst, *dst2;\n\tu32 color = 0, val, shift;\n\tint i, n, bpp = p->var.bits_per_pixel;\n\tu32 null_bits = 32 - bpp;\n\tu32 *palette = (u32 *) p->pseudo_palette;\n\tconst u8 *src = image->data;\n\n\tdst2 = dst1;\n\tfor (i = image->height; i--; ) {\n\t\tn = image->width;\n\t\tdst = dst1;\n\t\tshift = 0;\n\t\tval = 0;\n\n\t\tif (start_index) {\n\t\t\tu32 start_mask = ~(FB_SHIFT_HIGH(p, ~(u32)0,\n\t\t\t\t\t\t\t start_index));\n\t\t\tval = *dst & start_mask;\n\t\t\tshift = start_index;\n\t\t}\n\t\twhile (n--) {\n\t\t\tif (p->fix.visual == FB_VISUAL_TRUECOLOR ||\n\t\t\t    p->fix.visual == FB_VISUAL_DIRECTCOLOR )\n\t\t\t\tcolor = palette[*src];\n\t\t\telse\n\t\t\t\tcolor = *src;\n\t\t\tcolor <<= FB_LEFT_POS(p, bpp);\n\t\t\tval |= FB_SHIFT_HIGH(p, color, shift);\n\t\t\tif (shift >= null_bits) {\n\t\t\t\t*dst++ = val;\n\n\t\t\t\tval = (shift == null_bits) ? 0 :\n\t\t\t\t\tFB_SHIFT_LOW(p, color, 32 - shift);\n\t\t\t}\n\t\t\tshift += bpp;\n\t\t\tshift &= (32 - 1);\n\t\t\tsrc++;\n\t\t}\n\t\tif (shift) {\n\t\t\tu32 end_mask = FB_SHIFT_HIGH(p, ~(u32)0, shift);\n\n\t\t\t*dst &= end_mask;\n\t\t\t*dst |= val;\n\t\t}\n\t\tdst1 += p->fix.line_length;\n\t\tif (pitch_index) {\n\t\t\tdst2 += p->fix.line_length;\n\t\t\tdst1 = (u8 *)((long)dst2 & ~(sizeof(u32) - 1));\n\n\t\t\tstart_index += pitch_index;\n\t\t\tstart_index &= 32 - 1;\n\t\t}\n\t}\n}\n\nstatic void slow_imageblit(const struct fb_image *image, struct fb_info *p,\n\t\t\t\t  void *dst1, u32 fgcolor, u32 bgcolor,\n\t\t\t\t  u32 start_index, u32 pitch_index)\n{\n\tu32 shift, color = 0, bpp = p->var.bits_per_pixel;\n\tu32 *dst, *dst2;\n\tu32 val, pitch = p->fix.line_length;\n\tu32 null_bits = 32 - bpp;\n\tu32 spitch = (image->width+7)/8;\n\tconst u8 *src = image->data, *s;\n\tu32 i, j, l;\n\n\tdst2 = dst1;\n\tfgcolor <<= FB_LEFT_POS(p, bpp);\n\tbgcolor <<= FB_LEFT_POS(p, bpp);\n\n\tfor (i = image->height; i--; ) {\n\t\tshift = val = 0;\n\t\tl = 8;\n\t\tj = image->width;\n\t\tdst = dst1;\n\t\ts = src;\n\n\t\t \n\t\tif (start_index) {\n\t\t\tu32 start_mask = ~(FB_SHIFT_HIGH(p, ~(u32)0,\n\t\t\t\t\t\t\t start_index));\n\t\t\tval = *dst & start_mask;\n\t\t\tshift = start_index;\n\t\t}\n\n\t\twhile (j--) {\n\t\t\tl--;\n\t\t\tcolor = (*s & (1 << l)) ? fgcolor : bgcolor;\n\t\t\tval |= FB_SHIFT_HIGH(p, color, shift);\n\n\t\t\t \n\t\t\tif (shift >= null_bits) {\n\t\t\t\t*dst++ = val;\n\t\t\t\tval = (shift == null_bits) ? 0 :\n\t\t\t\t\tFB_SHIFT_LOW(p, color, 32 - shift);\n\t\t\t}\n\t\t\tshift += bpp;\n\t\t\tshift &= (32 - 1);\n\t\t\tif (!l) { l = 8; s++; }\n\t\t}\n\n\t\t \n \t\tif (shift) {\n\t\t\tu32 end_mask = FB_SHIFT_HIGH(p, ~(u32)0, shift);\n\n\t\t\t*dst &= end_mask;\n\t\t\t*dst |= val;\n\t\t}\n\n\t\tdst1 += pitch;\n\t\tsrc += spitch;\n\t\tif (pitch_index) {\n\t\t\tdst2 += pitch;\n\t\t\tdst1 = (u8 *)((long)dst2 & ~(sizeof(u32) - 1));\n\t\t\tstart_index += pitch_index;\n\t\t\tstart_index &= 32 - 1;\n\t\t}\n\n\t}\n}\n\n \nstatic void fast_imageblit(const struct fb_image *image, struct fb_info *p,\n\t\t\t\t  void *dst1, u32 fgcolor, u32 bgcolor)\n{\n\tu32 fgx = fgcolor, bgx = bgcolor, bpp = p->var.bits_per_pixel;\n\tu32 ppw = 32/bpp, spitch = (image->width + 7)/8;\n\tu32 bit_mask, eorx, shift;\n\tconst u8 *s = image->data, *src;\n\tu32 *dst;\n\tconst u32 *tab;\n\tsize_t tablen;\n\tu32 colortab[16];\n\tint i, j, k;\n\n\tswitch (bpp) {\n\tcase 8:\n\t\ttab = fb_be_math(p) ? cfb_tab8_be : cfb_tab8_le;\n\t\ttablen = 16;\n\t\tbreak;\n\tcase 16:\n\t\ttab = fb_be_math(p) ? cfb_tab16_be : cfb_tab16_le;\n\t\ttablen = 4;\n\t\tbreak;\n\tcase 32:\n\t\ttab = cfb_tab32;\n\t\ttablen = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (i = ppw-1; i--; ) {\n\t\tfgx <<= bpp;\n\t\tbgx <<= bpp;\n\t\tfgx |= fgcolor;\n\t\tbgx |= bgcolor;\n\t}\n\n\tbit_mask = (1 << ppw) - 1;\n\teorx = fgx ^ bgx;\n\tk = image->width/ppw;\n\n\tfor (i = 0; i < tablen; ++i)\n\t\tcolortab[i] = (tab[i] & eorx) ^ bgx;\n\n\tfor (i = image->height; i--; ) {\n\t\tdst = dst1;\n\t\tshift = 8;\n\t\tsrc = s;\n\n\t\t \n\t\tswitch (ppw) {\n\t\tcase 4:  \n\t\t\tfor (j = k; j >= 2; j -= 2, ++src) {\n\t\t\t\t*dst++ = colortab[(*src >> 4) & bit_mask];\n\t\t\t\t*dst++ = colortab[(*src >> 0) & bit_mask];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tfor (j = k; j >= 4; j -= 4, ++src) {\n\t\t\t\t*dst++ = colortab[(*src >> 6) & bit_mask];\n\t\t\t\t*dst++ = colortab[(*src >> 4) & bit_mask];\n\t\t\t\t*dst++ = colortab[(*src >> 2) & bit_mask];\n\t\t\t\t*dst++ = colortab[(*src >> 0) & bit_mask];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tfor (j = k; j >= 8; j -= 8, ++src) {\n\t\t\t\t*dst++ = colortab[(*src >> 7) & bit_mask];\n\t\t\t\t*dst++ = colortab[(*src >> 6) & bit_mask];\n\t\t\t\t*dst++ = colortab[(*src >> 5) & bit_mask];\n\t\t\t\t*dst++ = colortab[(*src >> 4) & bit_mask];\n\t\t\t\t*dst++ = colortab[(*src >> 3) & bit_mask];\n\t\t\t\t*dst++ = colortab[(*src >> 2) & bit_mask];\n\t\t\t\t*dst++ = colortab[(*src >> 1) & bit_mask];\n\t\t\t\t*dst++ = colortab[(*src >> 0) & bit_mask];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (; j--; ) {\n\t\t\tshift -= ppw;\n\t\t\t*dst++ = colortab[(*src >> shift) & bit_mask];\n\t\t\tif (!shift) {\n\t\t\t\tshift = 8;\n\t\t\t\t++src;\n\t\t\t}\n\t\t}\n\n\t\tdst1 += p->fix.line_length;\n\t\ts += spitch;\n\t}\n}\n\nvoid sys_imageblit(struct fb_info *p, const struct fb_image *image)\n{\n\tu32 fgcolor, bgcolor, start_index, bitstart, pitch_index = 0;\n\tu32 bpl = sizeof(u32), bpp = p->var.bits_per_pixel;\n\tu32 width = image->width;\n\tu32 dx = image->dx, dy = image->dy;\n\tvoid *dst1;\n\n\tif (p->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\n\tbitstart = (dy * p->fix.line_length * 8) + (dx * bpp);\n\tstart_index = bitstart & (32 - 1);\n\tpitch_index = (p->fix.line_length & (bpl - 1)) * 8;\n\n\tbitstart /= 8;\n\tbitstart &= ~(bpl - 1);\n\tdst1 = (void __force *)p->screen_base + bitstart;\n\n\tif (p->fbops->fb_sync)\n\t\tp->fbops->fb_sync(p);\n\n\tif (image->depth == 1) {\n\t\tif (p->fix.visual == FB_VISUAL_TRUECOLOR ||\n\t\t    p->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\t\tfgcolor = ((u32*)(p->pseudo_palette))[image->fg_color];\n\t\t\tbgcolor = ((u32*)(p->pseudo_palette))[image->bg_color];\n\t\t} else {\n\t\t\tfgcolor = image->fg_color;\n\t\t\tbgcolor = image->bg_color;\n\t\t}\n\n\t\tif (32 % bpp == 0 && !start_index && !pitch_index &&\n\t\t    ((width & (32/bpp-1)) == 0) &&\n\t\t    bpp >= 8 && bpp <= 32)\n\t\t\tfast_imageblit(image, p, dst1, fgcolor, bgcolor);\n\t\telse\n\t\t\tslow_imageblit(image, p, dst1, fgcolor, bgcolor,\n\t\t\t\t\tstart_index, pitch_index);\n\t} else\n\t\tcolor_imageblit(image, p, dst1, start_index, pitch_index);\n}\n\nEXPORT_SYMBOL(sys_imageblit);\n\nMODULE_AUTHOR(\"Antonino Daplas <adaplas@pol.net>\");\nMODULE_DESCRIPTION(\"1-bit/8-bit to 1-32 bit color expansion (sys-to-sys)\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}