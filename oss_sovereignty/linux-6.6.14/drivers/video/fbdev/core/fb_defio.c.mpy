{
  "module_name": "fb_defio.c",
  "hash_id": "22d35f2a9c1154ee66a21e8729fba5db83b68ed5c11ed5bfb3ee2b52c7d60920",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/core/fb_defio.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/fb.h>\n#include <linux/list.h>\n\n \n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n\nstatic struct page *fb_deferred_io_page(struct fb_info *info, unsigned long offs)\n{\n\tvoid *screen_base = (void __force *) info->screen_base;\n\tstruct page *page;\n\n\tif (is_vmalloc_addr(screen_base + offs))\n\t\tpage = vmalloc_to_page(screen_base + offs);\n\telse\n\t\tpage = pfn_to_page((info->fix.smem_start + offs) >> PAGE_SHIFT);\n\n\treturn page;\n}\n\nstatic struct fb_deferred_io_pageref *fb_deferred_io_pageref_get(struct fb_info *info,\n\t\t\t\t\t\t\t\t unsigned long offset,\n\t\t\t\t\t\t\t\t struct page *page)\n{\n\tstruct fb_deferred_io *fbdefio = info->fbdefio;\n\tstruct list_head *pos = &fbdefio->pagereflist;\n\tunsigned long pgoff = offset >> PAGE_SHIFT;\n\tstruct fb_deferred_io_pageref *pageref, *cur;\n\n\tif (WARN_ON_ONCE(pgoff >= info->npagerefs))\n\t\treturn NULL;  \n\n\t \n\tpageref = &info->pagerefs[pgoff];\n\n\t \n\tif (!list_empty(&pageref->list))\n\t\tgoto pageref_already_added;\n\n\tpageref->page = page;\n\tpageref->offset = pgoff << PAGE_SHIFT;\n\n\tif (unlikely(fbdefio->sort_pagereflist)) {\n\t\t \n\t\tlist_for_each_entry(cur, &fbdefio->pagereflist, list) {\n\t\t\tif (cur->offset > pageref->offset)\n\t\t\t\tbreak;\n\t\t}\n\t\tpos = &cur->list;\n\t}\n\n\tlist_add_tail(&pageref->list, pos);\n\npageref_already_added:\n\treturn pageref;\n}\n\nstatic void fb_deferred_io_pageref_put(struct fb_deferred_io_pageref *pageref,\n\t\t\t\t       struct fb_info *info)\n{\n\tlist_del_init(&pageref->list);\n}\n\n \nstatic vm_fault_t fb_deferred_io_fault(struct vm_fault *vmf)\n{\n\tunsigned long offset;\n\tstruct page *page;\n\tstruct fb_info *info = vmf->vma->vm_private_data;\n\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tif (offset >= info->fix.smem_len)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tpage = fb_deferred_io_page(info, offset);\n\tif (!page)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tget_page(page);\n\n\tif (vmf->vma->vm_file)\n\t\tpage->mapping = vmf->vma->vm_file->f_mapping;\n\telse\n\t\tprintk(KERN_ERR \"no mapping available\\n\");\n\n\tBUG_ON(!page->mapping);\n\tpage->index = vmf->pgoff;  \n\n\tvmf->page = page;\n\treturn 0;\n}\n\nint fb_deferred_io_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct fb_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tint err = file_write_and_wait_range(file, start, end);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!info->fbdefio)\n\t\treturn 0;\n\n\tinode_lock(inode);\n\tflush_delayed_work(&info->deferred_work);\n\tinode_unlock(inode);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fb_deferred_io_fsync);\n\n \nstatic vm_fault_t fb_deferred_io_track_page(struct fb_info *info, unsigned long offset,\n\t\t\t\t\t    struct page *page)\n{\n\tstruct fb_deferred_io *fbdefio = info->fbdefio;\n\tstruct fb_deferred_io_pageref *pageref;\n\tvm_fault_t ret;\n\n\t \n\tmutex_lock(&fbdefio->lock);\n\n\tpageref = fb_deferred_io_pageref_get(info, offset, page);\n\tif (WARN_ON_ONCE(!pageref)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto err_mutex_unlock;\n\t}\n\n\t \n\tlock_page(pageref->page);\n\n\tmutex_unlock(&fbdefio->lock);\n\n\t \n\tschedule_delayed_work(&info->deferred_work, fbdefio->delay);\n\treturn VM_FAULT_LOCKED;\n\nerr_mutex_unlock:\n\tmutex_unlock(&fbdefio->lock);\n\treturn ret;\n}\n\n \nstatic vm_fault_t fb_deferred_io_page_mkwrite(struct fb_info *info, struct vm_fault *vmf)\n{\n\tunsigned long offset = vmf->address - vmf->vma->vm_start;\n\tstruct page *page = vmf->page;\n\n\tfile_update_time(vmf->vma->vm_file);\n\n\treturn fb_deferred_io_track_page(info, offset, page);\n}\n\n \nstatic vm_fault_t fb_deferred_io_mkwrite(struct vm_fault *vmf)\n{\n\tstruct fb_info *info = vmf->vma->vm_private_data;\n\n\treturn fb_deferred_io_page_mkwrite(info, vmf);\n}\n\nstatic const struct vm_operations_struct fb_deferred_io_vm_ops = {\n\t.fault\t\t= fb_deferred_io_fault,\n\t.page_mkwrite\t= fb_deferred_io_mkwrite,\n};\n\nstatic const struct address_space_operations fb_deferred_io_aops = {\n\t.dirty_folio\t= noop_dirty_folio,\n};\n\nint fb_deferred_io_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tvma->vm_ops = &fb_deferred_io_vm_ops;\n\tvm_flags_set(vma, VM_DONTEXPAND | VM_DONTDUMP);\n\tif (!(info->flags & FBINFO_VIRTFB))\n\t\tvm_flags_set(vma, VM_IO);\n\tvma->vm_private_data = info;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fb_deferred_io_mmap);\n\n \nstatic void fb_deferred_io_work(struct work_struct *work)\n{\n\tstruct fb_info *info = container_of(work, struct fb_info, deferred_work.work);\n\tstruct fb_deferred_io_pageref *pageref, *next;\n\tstruct fb_deferred_io *fbdefio = info->fbdefio;\n\n\t \n\tmutex_lock(&fbdefio->lock);\n\tlist_for_each_entry(pageref, &fbdefio->pagereflist, list) {\n\t\tstruct page *cur = pageref->page;\n\t\tlock_page(cur);\n\t\tpage_mkclean(cur);\n\t\tunlock_page(cur);\n\t}\n\n\t \n\tfbdefio->deferred_io(info, &fbdefio->pagereflist);\n\n\t \n\tlist_for_each_entry_safe(pageref, next, &fbdefio->pagereflist, list)\n\t\tfb_deferred_io_pageref_put(pageref, info);\n\n\tmutex_unlock(&fbdefio->lock);\n}\n\nint fb_deferred_io_init(struct fb_info *info)\n{\n\tstruct fb_deferred_io *fbdefio = info->fbdefio;\n\tstruct fb_deferred_io_pageref *pagerefs;\n\tunsigned long npagerefs, i;\n\tint ret;\n\n\tBUG_ON(!fbdefio);\n\n\tif (WARN_ON(!info->fix.smem_len))\n\t\treturn -EINVAL;\n\n\tmutex_init(&fbdefio->lock);\n\tINIT_DELAYED_WORK(&info->deferred_work, fb_deferred_io_work);\n\tINIT_LIST_HEAD(&fbdefio->pagereflist);\n\tif (fbdefio->delay == 0)  \n\t\tfbdefio->delay = HZ;\n\n\tnpagerefs = DIV_ROUND_UP(info->fix.smem_len, PAGE_SIZE);\n\n\t \n\tpagerefs = kvcalloc(npagerefs, sizeof(*pagerefs), GFP_KERNEL);\n\tif (!pagerefs) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tfor (i = 0; i < npagerefs; ++i)\n\t\tINIT_LIST_HEAD(&pagerefs[i].list);\n\tinfo->npagerefs = npagerefs;\n\tinfo->pagerefs = pagerefs;\n\n\treturn 0;\n\nerr:\n\tmutex_destroy(&fbdefio->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(fb_deferred_io_init);\n\nvoid fb_deferred_io_open(struct fb_info *info,\n\t\t\t struct inode *inode,\n\t\t\t struct file *file)\n{\n\tstruct fb_deferred_io *fbdefio = info->fbdefio;\n\n\tfile->f_mapping->a_ops = &fb_deferred_io_aops;\n\tfbdefio->open_count++;\n}\nEXPORT_SYMBOL_GPL(fb_deferred_io_open);\n\nstatic void fb_deferred_io_lastclose(struct fb_info *info)\n{\n\tstruct page *page;\n\tint i;\n\n\tflush_delayed_work(&info->deferred_work);\n\n\t \n\tfor (i = 0 ; i < info->fix.smem_len; i += PAGE_SIZE) {\n\t\tpage = fb_deferred_io_page(info, i);\n\t\tpage->mapping = NULL;\n\t}\n}\n\nvoid fb_deferred_io_release(struct fb_info *info)\n{\n\tstruct fb_deferred_io *fbdefio = info->fbdefio;\n\n\tif (!--fbdefio->open_count)\n\t\tfb_deferred_io_lastclose(info);\n}\nEXPORT_SYMBOL_GPL(fb_deferred_io_release);\n\nvoid fb_deferred_io_cleanup(struct fb_info *info)\n{\n\tstruct fb_deferred_io *fbdefio = info->fbdefio;\n\n\tfb_deferred_io_lastclose(info);\n\n\tkvfree(info->pagerefs);\n\tmutex_destroy(&fbdefio->lock);\n}\nEXPORT_SYMBOL_GPL(fb_deferred_io_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}