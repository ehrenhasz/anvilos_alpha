{
  "module_name": "tdfxfb.c",
  "hash_id": "392ffee4487c7643ecd3045bec2806864fb78ebbdc0b3a2dbe8465a49d43702e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/tdfxfb.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <asm/io.h>\n\n#include <video/tdfx.h>\n\n#define DPRINTK(a, b...) pr_debug(\"fb: %s: \" a, __func__ , ## b)\n\n#define BANSHEE_MAX_PIXCLOCK 270000\n#define VOODOO3_MAX_PIXCLOCK 300000\n#define VOODOO5_MAX_PIXCLOCK 350000\n\nstatic const struct fb_fix_screeninfo tdfx_fix = {\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_PSEUDOCOLOR,\n\t.ypanstep =\t1,\n\t.ywrapstep =\t1,\n\t.accel =\tFB_ACCEL_3DFX_BANSHEE\n};\n\nstatic const struct fb_var_screeninfo tdfx_var = {\n\t \n\t.xres =\t\t640,\n\t.yres =\t\t480,\n\t.xres_virtual =\t640,\n\t.yres_virtual =\t1024,\n\t.bits_per_pixel = 8,\n\t.red =\t\t{0, 8, 0},\n\t.blue =\t\t{0, 8, 0},\n\t.green =\t{0, 8, 0},\n\t.activate =\tFB_ACTIVATE_NOW,\n\t.height =\t-1,\n\t.width =\t-1,\n\t.accel_flags =\tFB_ACCELF_TEXT,\n\t.pixclock =\t39722,\n\t.left_margin =\t40,\n\t.right_margin =\t24,\n\t.upper_margin =\t32,\n\t.lower_margin =\t11,\n\t.hsync_len =\t96,\n\t.vsync_len =\t2,\n\t.vmode =\tFB_VMODE_NONINTERLACED\n};\n\n \nstatic int tdfxfb_probe(struct pci_dev *pdev, const struct pci_device_id *id);\nstatic void tdfxfb_remove(struct pci_dev *pdev);\n\nstatic const struct pci_device_id tdfxfb_id_table[] = {\n\t{ PCI_VENDOR_ID_3DFX, PCI_DEVICE_ID_3DFX_BANSHEE,\n\t  PCI_ANY_ID, PCI_ANY_ID, PCI_BASE_CLASS_DISPLAY << 16,\n\t  0xff0000, 0 },\n\t{ PCI_VENDOR_ID_3DFX, PCI_DEVICE_ID_3DFX_VOODOO3,\n\t  PCI_ANY_ID, PCI_ANY_ID, PCI_BASE_CLASS_DISPLAY << 16,\n\t  0xff0000, 0 },\n\t{ PCI_VENDOR_ID_3DFX, PCI_DEVICE_ID_3DFX_VOODOO5,\n\t  PCI_ANY_ID, PCI_ANY_ID, PCI_BASE_CLASS_DISPLAY << 16,\n\t  0xff0000, 0 },\n\t{ 0, }\n};\n\nstatic struct pci_driver tdfxfb_driver = {\n\t.name\t\t= \"tdfxfb\",\n\t.id_table\t= tdfxfb_id_table,\n\t.probe\t\t= tdfxfb_probe,\n\t.remove\t\t= tdfxfb_remove,\n};\n\nMODULE_DEVICE_TABLE(pci, tdfxfb_id_table);\n\n \nstatic int nopan;\nstatic int nowrap = 1;       \nstatic int hwcursor = 1;\nstatic char *mode_option;\nstatic bool nomtrr;\n\n \n\nstatic inline u8 vga_inb(struct tdfx_par *par, u32 reg)\n{\n\treturn inb(par->iobase + reg - 0x300);\n}\n\nstatic inline void vga_outb(struct tdfx_par *par, u32 reg, u8 val)\n{\n\toutb(val, par->iobase + reg - 0x300);\n}\n\nstatic inline void gra_outb(struct tdfx_par *par, u32 idx, u8 val)\n{\n\tvga_outb(par, GRA_I, idx);\n\twmb();\n\tvga_outb(par, GRA_D, val);\n\twmb();\n}\n\nstatic inline void seq_outb(struct tdfx_par *par, u32 idx, u8 val)\n{\n\tvga_outb(par, SEQ_I, idx);\n\twmb();\n\tvga_outb(par, SEQ_D, val);\n\twmb();\n}\n\nstatic inline u8 seq_inb(struct tdfx_par *par, u32 idx)\n{\n\tvga_outb(par, SEQ_I, idx);\n\tmb();\n\treturn vga_inb(par, SEQ_D);\n}\n\nstatic inline void crt_outb(struct tdfx_par *par, u32 idx, u8 val)\n{\n\tvga_outb(par, CRT_I, idx);\n\twmb();\n\tvga_outb(par, CRT_D, val);\n\twmb();\n}\n\nstatic inline u8 crt_inb(struct tdfx_par *par, u32 idx)\n{\n\tvga_outb(par, CRT_I, idx);\n\tmb();\n\treturn vga_inb(par, CRT_D);\n}\n\nstatic inline void att_outb(struct tdfx_par *par, u32 idx, u8 val)\n{\n\tvga_inb(par, IS1_R);\n\tvga_outb(par, ATT_IW, idx);\n\tvga_outb(par, ATT_IW, val);\n}\n\nstatic inline void vga_disable_video(struct tdfx_par *par)\n{\n\tunsigned char s;\n\n\ts = seq_inb(par, 0x01) | 0x20;\n\tseq_outb(par, 0x00, 0x01);\n\tseq_outb(par, 0x01, s);\n\tseq_outb(par, 0x00, 0x03);\n}\n\nstatic inline void vga_enable_video(struct tdfx_par *par)\n{\n\tunsigned char s;\n\n\ts = seq_inb(par, 0x01) & 0xdf;\n\tseq_outb(par, 0x00, 0x01);\n\tseq_outb(par, 0x01, s);\n\tseq_outb(par, 0x00, 0x03);\n}\n\nstatic inline void vga_enable_palette(struct tdfx_par *par)\n{\n\tvga_inb(par, IS1_R);\n\tmb();\n\tvga_outb(par, ATT_IW, 0x20);\n}\n\nstatic inline u32 tdfx_inl(struct tdfx_par *par, unsigned int reg)\n{\n\treturn readl(par->regbase_virt + reg);\n}\n\nstatic inline void tdfx_outl(struct tdfx_par *par, unsigned int reg, u32 val)\n{\n\twritel(val, par->regbase_virt + reg);\n}\n\nstatic inline void banshee_make_room(struct tdfx_par *par, int size)\n{\n\t \n\twhile ((tdfx_inl(par, STATUS) & 0x1f) < size - 1)\n\t\tcpu_relax();\n}\n\nstatic int banshee_wait_idle(struct fb_info *info)\n{\n\tstruct tdfx_par *par = info->par;\n\tint i = 0;\n\n\tbanshee_make_room(par, 1);\n\ttdfx_outl(par, COMMAND_3D, COMMAND_3D_NOP);\n\n\tdo {\n\t\tif ((tdfx_inl(par, STATUS) & STATUS_BUSY) == 0)\n\t\t\ti++;\n\t} while (i < 3);\n\n\treturn 0;\n}\n\n \nstatic inline void do_setpalentry(struct tdfx_par *par, unsigned regno, u32 c)\n{\n\tbanshee_make_room(par, 2);\n\ttdfx_outl(par, DACADDR, regno);\n\t \n\ttdfx_inl(par, DACADDR);\n\ttdfx_outl(par, DACDATA, c);\n}\n\nstatic u32 do_calc_pll(int freq, int *freq_out)\n{\n\tint m, n, k, best_m, best_n, best_k, best_error;\n\tint fref = 14318;\n\n\tbest_error = freq;\n\tbest_n = best_m = best_k = 0;\n\n\tfor (k = 3; k >= 0; k--) {\n\t\tfor (m = 63; m >= 0; m--) {\n\t\t\t \n\t\t\tint n_estimated = ((freq * (m + 2) << k) / fref) - 2;\n\n\t\t\t \n\t\t\tfor (n = max(0, n_estimated);\n\t\t\t\tn <= min(255, n_estimated + 1);\n\t\t\t\tn++) {\n\t\t\t\t \n\t\t\t\tint f = (fref * (n + 2) / (m + 2)) >> k;\n\t\t\t\tint error = abs(f - freq);\n\n\t\t\t\t \n\t\t\t\tif (error < best_error) {\n\t\t\t\t\tbest_error = error;\n\t\t\t\t\tbest_n = n;\n\t\t\t\t\tbest_m = m;\n\t\t\t\t\tbest_k = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tn = best_n;\n\tm = best_m;\n\tk = best_k;\n\t*freq_out = (fref * (n + 2) / (m + 2)) >> k;\n\n\treturn (n << 8) | (m << 2) | k;\n}\n\nstatic void do_write_regs(struct fb_info *info, struct banshee_reg *reg)\n{\n\tstruct tdfx_par *par = info->par;\n\tint i;\n\n\tbanshee_wait_idle(info);\n\n\ttdfx_outl(par, MISCINIT1, tdfx_inl(par, MISCINIT1) | 0x01);\n\n\tcrt_outb(par, 0x11, crt_inb(par, 0x11) & 0x7f);  \n\n\tbanshee_make_room(par, 3);\n\ttdfx_outl(par, VGAINIT1, reg->vgainit1 & 0x001FFFFF);\n\ttdfx_outl(par, VIDPROCCFG, reg->vidcfg & ~0x00000001);\n#if 0\n\ttdfx_outl(par, PLLCTRL1, reg->mempll);\n\ttdfx_outl(par, PLLCTRL2, reg->gfxpll);\n#endif\n\ttdfx_outl(par, PLLCTRL0, reg->vidpll);\n\n\tvga_outb(par, MISC_W, reg->misc[0x00] | 0x01);\n\n\tfor (i = 0; i < 5; i++)\n\t\tseq_outb(par, i, reg->seq[i]);\n\n\tfor (i = 0; i < 25; i++)\n\t\tcrt_outb(par, i, reg->crt[i]);\n\n\tfor (i = 0; i < 9; i++)\n\t\tgra_outb(par, i, reg->gra[i]);\n\n\tfor (i = 0; i < 21; i++)\n\t\tatt_outb(par, i, reg->att[i]);\n\n\tcrt_outb(par, 0x1a, reg->ext[0]);\n\tcrt_outb(par, 0x1b, reg->ext[1]);\n\n\tvga_enable_palette(par);\n\tvga_enable_video(par);\n\n\tbanshee_make_room(par, 9);\n\ttdfx_outl(par, VGAINIT0, reg->vgainit0);\n\ttdfx_outl(par, DACMODE, reg->dacmode);\n\ttdfx_outl(par, VIDDESKSTRIDE, reg->stride);\n\ttdfx_outl(par, HWCURPATADDR, reg->curspataddr);\n\n\ttdfx_outl(par, VIDSCREENSIZE, reg->screensize);\n\ttdfx_outl(par, VIDDESKSTART, reg->startaddr);\n\ttdfx_outl(par, VIDPROCCFG, reg->vidcfg);\n\ttdfx_outl(par, VGAINIT1, reg->vgainit1);\n\ttdfx_outl(par, MISCINIT0, reg->miscinit0);\n\n\tbanshee_make_room(par, 8);\n\ttdfx_outl(par, SRCBASE, reg->startaddr);\n\ttdfx_outl(par, DSTBASE, reg->startaddr);\n\ttdfx_outl(par, COMMANDEXTRA_2D, 0);\n\ttdfx_outl(par, CLIP0MIN, 0);\n\ttdfx_outl(par, CLIP0MAX, 0x0fff0fff);\n\ttdfx_outl(par, CLIP1MIN, 0);\n\ttdfx_outl(par, CLIP1MAX, 0x0fff0fff);\n\ttdfx_outl(par, SRCXY, 0);\n\n\tbanshee_wait_idle(info);\n}\n\nstatic unsigned long do_lfb_size(struct tdfx_par *par, unsigned short dev_id)\n{\n\tu32 draminit0 = tdfx_inl(par, DRAMINIT0);\n\tu32 draminit1 = tdfx_inl(par, DRAMINIT1);\n\tu32 miscinit1;\n\tint num_chips = (draminit0 & DRAMINIT0_SGRAM_NUM) ? 8 : 4;\n\tint chip_size;  \n\tint has_sgram = draminit1 & DRAMINIT1_MEM_SDRAM;\n\n\tif (dev_id < PCI_DEVICE_ID_3DFX_VOODOO5) {\n\t\t \n\t\tchip_size = 2;\n\t\tif (has_sgram && !(draminit0 & DRAMINIT0_SGRAM_TYPE))\n\t\t\tchip_size = 1;\n\t} else {\n\t\t \n\t\thas_sgram = 0;\n\t\tchip_size = draminit0 & DRAMINIT0_SGRAM_TYPE_MASK;\n\t\tchip_size = 1 << (chip_size >> DRAMINIT0_SGRAM_TYPE_SHIFT);\n\t}\n\n\t \n\tmiscinit1 = tdfx_inl(par, MISCINIT1);\n\tmiscinit1 |= has_sgram ? 0 : MISCINIT1_2DBLOCK_DIS;\n\tmiscinit1 |= MISCINIT1_CLUT_INV;\n\n\tbanshee_make_room(par, 1);\n\ttdfx_outl(par, MISCINIT1, miscinit1);\n\treturn num_chips * chip_size * 1024l * 1024;\n}\n\n \n\nstatic int tdfxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct tdfx_par *par = info->par;\n\tu32 lpitch;\n\n\tif (var->bits_per_pixel != 8  && var->bits_per_pixel != 16 &&\n\t    var->bits_per_pixel != 24 && var->bits_per_pixel != 32) {\n\t\tDPRINTK(\"depth not supported: %u\\n\", var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->xres != var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\n\tif (var->xoffset) {\n\t\tDPRINTK(\"xoffset not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tvar->yoffset = 0;\n\n\t \n\tif (((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) &&\n\t    (par->max_pixclock < VOODOO3_MAX_PIXCLOCK)) {\n\t\tDPRINTK(\"interlace not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->monspecs.hfmax && info->monspecs.vfmax &&\n\t    info->monspecs.dclkmax && fb_validate_mode(var, info) < 0) {\n\t\tDPRINTK(\"mode outside monitor's specs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvar->xres = (var->xres + 15) & ~15;  \n\tlpitch = var->xres * ((var->bits_per_pixel + 7) >> 3);\n\n\tif (var->xres < 320 || var->xres > 2048) {\n\t\tDPRINTK(\"width not supported: %u\\n\", var->xres);\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->yres < 200 || var->yres > 2048) {\n\t\tDPRINTK(\"height not supported: %u\\n\", var->yres);\n\t\treturn -EINVAL;\n\t}\n\n\tif (lpitch * var->yres_virtual > info->fix.smem_len) {\n\t\tvar->yres_virtual = info->fix.smem_len / lpitch;\n\t\tif (var->yres_virtual < var->yres) {\n\t\t\tDPRINTK(\"no memory for screen (%ux%ux%u)\\n\",\n\t\t\t\tvar->xres, var->yres_virtual,\n\t\t\t\tvar->bits_per_pixel);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (PICOS2KHZ(var->pixclock) > par->max_pixclock) {\n\t\tDPRINTK(\"pixclock too high (%ldKHz)\\n\",\n\t\t\tPICOS2KHZ(var->pixclock));\n\t\treturn -EINVAL;\n\t}\n\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.length = 8;\n\t\tvar->red.offset = 0;\n\t\tvar->green = var->red;\n\t\tvar->blue = var->red;\n\t\tbreak;\n\tcase 16:\n\t\tvar->red.offset   = 11;\n\t\tvar->red.length   = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.offset  = 0;\n\t\tvar->blue.length  = 5;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tfallthrough;\n\tcase 24:\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tbreak;\n\t}\n\tvar->width = -1;\n\tvar->height = -1;\n\n\tvar->accel_flags = FB_ACCELF_TEXT;\n\n\tDPRINTK(\"Checking graphics mode at %dx%d depth %d\\n\",\n\t\tvar->xres, var->yres, var->bits_per_pixel);\n\treturn 0;\n}\n\nstatic int tdfxfb_set_par(struct fb_info *info)\n{\n\tstruct tdfx_par *par = info->par;\n\tu32 hdispend = info->var.xres;\n\tu32 hsyncsta = hdispend + info->var.right_margin;\n\tu32 hsyncend = hsyncsta + info->var.hsync_len;\n\tu32 htotal   = hsyncend + info->var.left_margin;\n\tu32 hd, hs, he, ht, hbs, hbe;\n\tu32 vd, vs, ve, vt, vbs, vbe;\n\tstruct banshee_reg reg;\n\tint fout, freq;\n\tu32 wd;\n\tu32 cpp = (info->var.bits_per_pixel + 7) >> 3;\n\n\tmemset(&reg, 0, sizeof(reg));\n\n\treg.vidcfg = VIDCFG_VIDPROC_ENABLE | VIDCFG_DESK_ENABLE |\n\t\t     VIDCFG_CURS_X11 |\n\t\t     ((cpp - 1) << VIDCFG_PIXFMT_SHIFT) |\n\t\t     (cpp != 1 ? VIDCFG_CLUT_BYPASS : 0);\n\n\t \n\tfreq = PICOS2KHZ(info->var.pixclock);\n\n\treg.vidcfg &= ~VIDCFG_2X;\n\n\tif (freq > par->max_pixclock / 2) {\n\t\tfreq = freq > par->max_pixclock ? par->max_pixclock : freq;\n\t\treg.dacmode |= DACMODE_2X;\n\t\treg.vidcfg  |= VIDCFG_2X;\n\t\thdispend >>= 1;\n\t\thsyncsta >>= 1;\n\t\thsyncend >>= 1;\n\t\thtotal   >>= 1;\n\t}\n\n\twd = (hdispend >> 3) - 1;\n\thd  = wd;\n\ths  = (hsyncsta >> 3) - 1;\n\the  = (hsyncend >> 3) - 1;\n\tht  = (htotal >> 3) - 1;\n\thbs = hd;\n\thbe = ht;\n\n\tif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {\n\t\tvd = (info->var.yres << 1) - 1;\n\t\tvs  = vd + (info->var.lower_margin << 1);\n\t\tve  = vs + (info->var.vsync_len << 1);\n\t\tvt = ve + (info->var.upper_margin << 1) - 1;\n\t\treg.screensize = info->var.xres | (info->var.yres << 13);\n\t\treg.vidcfg |= VIDCFG_HALF_MODE;\n\t\treg.crt[0x09] = 0x80;\n\t} else {\n\t\tvd = info->var.yres - 1;\n\t\tvs  = vd + info->var.lower_margin;\n\t\tve  = vs + info->var.vsync_len;\n\t\tvt = ve + info->var.upper_margin - 1;\n\t\treg.screensize = info->var.xres | (info->var.yres << 12);\n\t\treg.vidcfg &= ~VIDCFG_HALF_MODE;\n\t}\n\tvbs = vd;\n\tvbe = vt;\n\n\t \n\treg.misc[0x00] = 0x0f |\n\t\t\t(info->var.xres < 400 ? 0xa0 :\n\t\t\t info->var.xres < 480 ? 0x60 :\n\t\t\t info->var.xres < 768 ? 0xe0 : 0x20);\n\n\treg.gra[0x05] = 0x40;\n\treg.gra[0x06] = 0x05;\n\treg.gra[0x07] = 0x0f;\n\treg.gra[0x08] = 0xff;\n\n\treg.att[0x00] = 0x00;\n\treg.att[0x01] = 0x01;\n\treg.att[0x02] = 0x02;\n\treg.att[0x03] = 0x03;\n\treg.att[0x04] = 0x04;\n\treg.att[0x05] = 0x05;\n\treg.att[0x06] = 0x06;\n\treg.att[0x07] = 0x07;\n\treg.att[0x08] = 0x08;\n\treg.att[0x09] = 0x09;\n\treg.att[0x0a] = 0x0a;\n\treg.att[0x0b] = 0x0b;\n\treg.att[0x0c] = 0x0c;\n\treg.att[0x0d] = 0x0d;\n\treg.att[0x0e] = 0x0e;\n\treg.att[0x0f] = 0x0f;\n\treg.att[0x10] = 0x41;\n\treg.att[0x12] = 0x0f;\n\n\treg.seq[0x00] = 0x03;\n\treg.seq[0x01] = 0x01;  \n\treg.seq[0x02] = 0x0f;\n\treg.seq[0x03] = 0x00;\n\treg.seq[0x04] = 0x0e;\n\n\treg.crt[0x00] = ht - 4;\n\treg.crt[0x01] = hd;\n\treg.crt[0x02] = hbs;\n\treg.crt[0x03] = 0x80 | (hbe & 0x1f);\n\treg.crt[0x04] = hs;\n\treg.crt[0x05] = ((hbe & 0x20) << 2) | (he & 0x1f);\n\treg.crt[0x06] = vt;\n\treg.crt[0x07] = ((vs & 0x200) >> 2) |\n\t\t\t((vd & 0x200) >> 3) |\n\t\t\t((vt & 0x200) >> 4) | 0x10 |\n\t\t\t((vbs & 0x100) >> 5) |\n\t\t\t((vs & 0x100) >> 6) |\n\t\t\t((vd & 0x100) >> 7) |\n\t\t\t((vt & 0x100) >> 8);\n\treg.crt[0x09] |= 0x40 | ((vbs & 0x200) >> 4);\n\treg.crt[0x10] = vs;\n\treg.crt[0x11] = (ve & 0x0f) | 0x20;\n\treg.crt[0x12] = vd;\n\treg.crt[0x13] = wd;\n\treg.crt[0x15] = vbs;\n\treg.crt[0x16] = vbe + 1;\n\treg.crt[0x17] = 0xc3;\n\treg.crt[0x18] = 0xff;\n\n\t \n\treg.ext[0x00] = (((ht & 0x100) >> 8) |\n\t\t\t((hd & 0x100) >> 6) |\n\t\t\t((hbs & 0x100) >> 4) |\n\t\t\t((hbe & 0x40) >> 1) |\n\t\t\t((hs & 0x100) >> 2) |\n\t\t\t((he & 0x20) << 2));\n\treg.ext[0x01] = (((vt & 0x400) >> 10) |\n\t\t\t((vd & 0x400) >> 8) |\n\t\t\t((vbs & 0x400) >> 6) |\n\t\t\t((vbe & 0x400) >> 4));\n\n\treg.vgainit0 =\tVGAINIT0_8BIT_DAC     |\n\t\t\tVGAINIT0_EXT_ENABLE   |\n\t\t\tVGAINIT0_WAKEUP_3C3   |\n\t\t\tVGAINIT0_ALT_READBACK |\n\t\t\tVGAINIT0_EXTSHIFTOUT;\n\treg.vgainit1 = tdfx_inl(par, VGAINIT1) & 0x1fffff;\n\n\tif (hwcursor)\n\t\treg.curspataddr = info->fix.smem_len;\n\n\treg.cursloc   = 0;\n\n\treg.cursc0    = 0;\n\treg.cursc1    = 0xffffff;\n\n\treg.stride    = info->var.xres * cpp;\n\treg.startaddr = info->var.yoffset * reg.stride\n\t\t\t+ info->var.xoffset * cpp;\n\n\treg.vidpll = do_calc_pll(freq, &fout);\n#if 0\n\treg.mempll = do_calc_pll(..., &fout);\n\treg.gfxpll = do_calc_pll(..., &fout);\n#endif\n\n\tif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)\n\t\treg.vidcfg |= VIDCFG_INTERLACE;\n\treg.miscinit0 = tdfx_inl(par, MISCINIT0);\n\n#if defined(__BIG_ENDIAN)\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\tcase 24:\n\t\treg.miscinit0 &= ~(1 << 30);\n\t\treg.miscinit0 &= ~(1 << 31);\n\t\tbreak;\n\tcase 16:\n\t\treg.miscinit0 |= (1 << 30);\n\t\treg.miscinit0 |= (1 << 31);\n\t\tbreak;\n\tcase 32:\n\t\treg.miscinit0 |= (1 << 30);\n\t\treg.miscinit0 &= ~(1 << 31);\n\t\tbreak;\n\t}\n#endif\n\tdo_write_regs(info, &reg);\n\n\t \n\tinfo->fix.line_length = reg.stride;\n\tinfo->fix.visual = (info->var.bits_per_pixel == 8)\n\t\t\t\t? FB_VISUAL_PSEUDOCOLOR\n\t\t\t\t: FB_VISUAL_TRUECOLOR;\n\tDPRINTK(\"Graphics mode is now set at %dx%d depth %d\\n\",\n\t\tinfo->var.xres, info->var.yres, info->var.bits_per_pixel);\n\treturn 0;\n}\n\n \n#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)\n\nstatic int tdfxfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t    unsigned blue, unsigned transp,\n\t\t\t    struct fb_info *info)\n{\n\tstruct tdfx_par *par = info->par;\n\tu32 rgbcol;\n\n\tif (regno >= info->cmap.len || regno > 255)\n\t\treturn 1;\n\n\t \n\tif (info->var.grayscale) {\n\t\t \n\t\tblue = (red * 77 + green * 151 + blue * 28) >> 8;\n\t\tgreen = blue;\n\t\tred = blue;\n\t}\n\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\trgbcol = (((u32)red   & 0xff00) << 8) |\n\t\t\t (((u32)green & 0xff00) << 0) |\n\t\t\t (((u32)blue  & 0xff00) >> 8);\n\t\tdo_setpalentry(par, regno, rgbcol);\n\t\tbreak;\n\t \n\tcase FB_VISUAL_TRUECOLOR:\n\t\tif (regno < 16) {\n\t\t\trgbcol = (CNVT_TOHW(red, info->var.red.length) <<\n\t\t\t\t  info->var.red.offset) |\n\t\t\t\t(CNVT_TOHW(green, info->var.green.length) <<\n\t\t\t\t info->var.green.offset) |\n\t\t\t\t(CNVT_TOHW(blue, info->var.blue.length) <<\n\t\t\t\t info->var.blue.offset) |\n\t\t\t\t(CNVT_TOHW(transp, info->var.transp.length) <<\n\t\t\t\t info->var.transp.offset);\n\t\t\tpar->palette[regno] = rgbcol;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tDPRINTK(\"bad depth %u\\n\", info->var.bits_per_pixel);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int tdfxfb_blank(int blank, struct fb_info *info)\n{\n\tstruct tdfx_par *par = info->par;\n\tint vgablank = 1;\n\tu32 dacmode = tdfx_inl(par, DACMODE);\n\n\tdacmode &= ~(BIT(1) | BIT(3));\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:  \n\t\tvgablank = 0;\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:  \n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:  \n\t\tdacmode |= BIT(3);\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:  \n\t\tdacmode |= BIT(1);\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:  \n\t\tdacmode |= BIT(1) | BIT(3);\n\t\tbreak;\n\t}\n\n\tbanshee_make_room(par, 1);\n\ttdfx_outl(par, DACMODE, dacmode);\n\tif (vgablank)\n\t\tvga_disable_video(par);\n\telse\n\t\tvga_enable_video(par);\n\treturn 0;\n}\n\n \nstatic int tdfxfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct tdfx_par *par = info->par;\n\tu32 addr = var->yoffset * info->fix.line_length;\n\n\tif (nopan || var->xoffset)\n\t\treturn -EINVAL;\n\n\tbanshee_make_room(par, 1);\n\ttdfx_outl(par, VIDDESKSTART, addr);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_FB_3DFX_ACCEL\n \nstatic void tdfxfb_fillrect(struct fb_info *info,\n\t\t\t    const struct fb_fillrect *rect)\n{\n\tstruct tdfx_par *par = info->par;\n\tu32 bpp = info->var.bits_per_pixel;\n\tu32 stride = info->fix.line_length;\n\tu32 fmt = stride | ((bpp + ((bpp == 8) ? 0 : 8)) << 13);\n\tint tdfx_rop;\n\tu32 dx = rect->dx;\n\tu32 dy = rect->dy;\n\tu32 dstbase = 0;\n\n\tif (rect->rop == ROP_COPY)\n\t\ttdfx_rop = TDFX_ROP_COPY;\n\telse\n\t\ttdfx_rop = TDFX_ROP_XOR;\n\n\t \n\tif (dy + rect->height > 4095) {\n\t\tdstbase = stride * dy;\n\t\tdy = 0;\n\t}\n\t \n\tif (dx + rect->width > 4095) {\n\t\tdstbase += dx * bpp >> 3;\n\t\tdx = 0;\n\t}\n\tbanshee_make_room(par, 6);\n\ttdfx_outl(par, DSTFORMAT, fmt);\n\tif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR) {\n\t\ttdfx_outl(par, COLORFORE, rect->color);\n\t} else {  \n\t\ttdfx_outl(par, COLORFORE, par->palette[rect->color]);\n\t}\n\ttdfx_outl(par, COMMAND_2D, COMMAND_2D_FILLRECT | (tdfx_rop << 24));\n\ttdfx_outl(par, DSTBASE, dstbase);\n\ttdfx_outl(par, DSTSIZE, rect->width | (rect->height << 16));\n\ttdfx_outl(par, LAUNCH_2D, dx | (dy << 16));\n}\n\n \nstatic void tdfxfb_copyarea(struct fb_info *info,\n\t\t\t    const struct fb_copyarea *area)\n{\n\tstruct tdfx_par *par = info->par;\n\tu32 sx = area->sx, sy = area->sy, dx = area->dx, dy = area->dy;\n\tu32 bpp = info->var.bits_per_pixel;\n\tu32 stride = info->fix.line_length;\n\tu32 blitcmd = COMMAND_2D_S2S_BITBLT | (TDFX_ROP_COPY << 24);\n\tu32 fmt = stride | ((bpp + ((bpp == 8) ? 0 : 8)) << 13);\n\tu32 dstbase = 0;\n\tu32 srcbase = 0;\n\n\t \n\tif (sy + area->height > 4095) {\n\t\tsrcbase = stride * sy;\n\t\tsy = 0;\n\t}\n\t \n\tif (sx + area->width > 4095) {\n\t\tsrcbase += sx * bpp >> 3;\n\t\tsx = 0;\n\t}\n\t \n\tif (dy + area->height > 4095) {\n\t\tdstbase = stride * dy;\n\t\tdy = 0;\n\t}\n\t \n\tif (dx + area->width > 4095) {\n\t\tdstbase += dx * bpp >> 3;\n\t\tdx = 0;\n\t}\n\n\tif (area->sx <= area->dx) {\n\t\t \n\t\tblitcmd |= BIT(14);\n\t\tsx += area->width - 1;\n\t\tdx += area->width - 1;\n\t}\n\tif (area->sy <= area->dy) {\n\t\t \n\t\tblitcmd |= BIT(15);\n\t\tsy += area->height - 1;\n\t\tdy += area->height - 1;\n\t}\n\n\tbanshee_make_room(par, 8);\n\n\ttdfx_outl(par, SRCFORMAT, fmt);\n\ttdfx_outl(par, DSTFORMAT, fmt);\n\ttdfx_outl(par, COMMAND_2D, blitcmd);\n\ttdfx_outl(par, DSTSIZE, area->width | (area->height << 16));\n\ttdfx_outl(par, DSTXY, dx | (dy << 16));\n\ttdfx_outl(par, SRCBASE, srcbase);\n\ttdfx_outl(par, DSTBASE, dstbase);\n\ttdfx_outl(par, LAUNCH_2D, sx | (sy << 16));\n}\n\nstatic void tdfxfb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct tdfx_par *par = info->par;\n\tint size = image->height * ((image->width * image->depth + 7) >> 3);\n\tint fifo_free;\n\tint i, stride = info->fix.line_length;\n\tu32 bpp = info->var.bits_per_pixel;\n\tu32 dstfmt = stride | ((bpp + ((bpp == 8) ? 0 : 8)) << 13);\n\tu8 *chardata = (u8 *) image->data;\n\tu32 srcfmt;\n\tu32 dx = image->dx;\n\tu32 dy = image->dy;\n\tu32 dstbase = 0;\n\n\tif (image->depth != 1) {\n#ifdef BROKEN_CODE\n\t\tbanshee_make_room(par, 6 + ((size + 3) >> 2));\n\t\tsrcfmt = stride | ((bpp + ((bpp == 8) ? 0 : 8)) << 13) |\n\t\t\t0x400000;\n#else\n\t\tcfb_imageblit(info, image);\n#endif\n\t\treturn;\n\t}\n\tbanshee_make_room(par, 9);\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\ttdfx_outl(par, COLORFORE, image->fg_color);\n\t\ttdfx_outl(par, COLORBACK, image->bg_color);\n\t\tbreak;\n\tcase FB_VISUAL_TRUECOLOR:\n\tdefault:\n\t\ttdfx_outl(par, COLORFORE,\n\t\t\t  par->palette[image->fg_color]);\n\t\ttdfx_outl(par, COLORBACK,\n\t\t\t  par->palette[image->bg_color]);\n\t}\n#ifdef __BIG_ENDIAN\n\tsrcfmt = 0x400000 | BIT(20);\n#else\n\tsrcfmt = 0x400000;\n#endif\n\t \n\tif (dy + image->height > 4095) {\n\t\tdstbase = stride * dy;\n\t\tdy = 0;\n\t}\n\t \n\tif (dx + image->width > 4095) {\n\t\tdstbase += dx * bpp >> 3;\n\t\tdx = 0;\n\t}\n\n\ttdfx_outl(par, DSTBASE, dstbase);\n\ttdfx_outl(par, SRCXY, 0);\n\ttdfx_outl(par, DSTXY, dx | (dy << 16));\n\ttdfx_outl(par, COMMAND_2D,\n\t\t  COMMAND_2D_H2S_BITBLT | (TDFX_ROP_COPY << 24));\n\ttdfx_outl(par, SRCFORMAT, srcfmt);\n\ttdfx_outl(par, DSTFORMAT, dstfmt);\n\ttdfx_outl(par, DSTSIZE, image->width | (image->height << 16));\n\n\t \n\tfifo_free = 0;\n\n\t \n\tfor (i = (size >> 2); i > 0; i--) {\n\t\tif (--fifo_free < 0) {\n\t\t\tfifo_free = 31;\n\t\t\tbanshee_make_room(par, fifo_free);\n\t\t}\n\t\ttdfx_outl(par, LAUNCH_2D, *(u32 *)chardata);\n\t\tchardata += 4;\n\t}\n\n\t \n\tbanshee_make_room(par, 3);\n\tswitch (size % 4) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\ttdfx_outl(par, LAUNCH_2D, *chardata);\n\t\tbreak;\n\tcase 2:\n\t\ttdfx_outl(par, LAUNCH_2D, *(u16 *)chardata);\n\t\tbreak;\n\tcase 3:\n\t\ttdfx_outl(par, LAUNCH_2D,\n\t\t\t*(u16 *)chardata | (chardata[3] << 24));\n\t\tbreak;\n\t}\n}\n#endif  \n\nstatic int tdfxfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\tstruct tdfx_par *par = info->par;\n\tu32 vidcfg;\n\n\tif (!hwcursor)\n\t\treturn -EINVAL;\t \n\n\t \n\tif (cursor->image.width > 64 ||\n\t    cursor->image.height > 64 ||\n\t    cursor->image.depth > 1)\n\t\treturn -EINVAL;\n\n\tvidcfg = tdfx_inl(par, VIDPROCCFG);\n\tif (cursor->enable)\n\t\ttdfx_outl(par, VIDPROCCFG, vidcfg | VIDCFG_HWCURSOR_ENABLE);\n\telse\n\t\ttdfx_outl(par, VIDPROCCFG, vidcfg & ~VIDCFG_HWCURSOR_ENABLE);\n\n\t \n\tif (!cursor->set)\n\t\treturn 0;\n\n\t \n\tif (cursor->set & FB_CUR_SETCMAP) {\n\t\tstruct fb_cmap cmap = info->cmap;\n\t\tu32 bg_idx = cursor->image.bg_color;\n\t\tu32 fg_idx = cursor->image.fg_color;\n\t\tunsigned long bg_color, fg_color;\n\n\t\tfg_color = (((u32)cmap.red[fg_idx]   & 0xff00) << 8) |\n\t\t\t   (((u32)cmap.green[fg_idx] & 0xff00) << 0) |\n\t\t\t   (((u32)cmap.blue[fg_idx]  & 0xff00) >> 8);\n\t\tbg_color = (((u32)cmap.red[bg_idx]   & 0xff00) << 8) |\n\t\t\t   (((u32)cmap.green[bg_idx] & 0xff00) << 0) |\n\t\t\t   (((u32)cmap.blue[bg_idx]  & 0xff00) >> 8);\n\t\tbanshee_make_room(par, 2);\n\t\ttdfx_outl(par, HWCURC0, bg_color);\n\t\ttdfx_outl(par, HWCURC1, fg_color);\n\t}\n\n\tif (cursor->set & FB_CUR_SETPOS) {\n\t\tint x = cursor->image.dx;\n\t\tint y = cursor->image.dy - info->var.yoffset;\n\n\t\tx += 63;\n\t\ty += 63;\n\t\tbanshee_make_room(par, 1);\n\t\ttdfx_outl(par, HWCURLOC, (y << 16) + x);\n\t}\n\tif (cursor->set & (FB_CUR_SETIMAGE | FB_CUR_SETSHAPE)) {\n\t\t \n\t\tu8 __iomem *cursorbase = info->screen_base + info->fix.smem_len;\n\t\tu8 *bitmap = (u8 *)cursor->image.data;\n\t\tu8 *mask = (u8 *)cursor->mask;\n\t\tint i;\n\n\t\tfb_memset_io(cursorbase, 0, 1024);\n\n\t\tfor (i = 0; i < cursor->image.height; i++) {\n\t\t\tint h = 0;\n\t\t\tint j = (cursor->image.width + 7) >> 3;\n\n\t\t\tfor (; j > 0; j--) {\n\t\t\t\tu8 data = *mask ^ *bitmap;\n\t\t\t\tif (cursor->rop == ROP_COPY)\n\t\t\t\t\tdata = *mask & *bitmap;\n\t\t\t\t \n\t\t\t\tfb_writeb(*mask, cursorbase + h);\n\t\t\t\tmask++;\n\t\t\t\t \n\t\t\t\tfb_writeb(data, cursorbase + h + 8);\n\t\t\t\tbitmap++;\n\t\t\t\th++;\n\t\t\t}\n\t\t\tcursorbase += 16;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct fb_ops tdfxfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= tdfxfb_check_var,\n\t.fb_set_par\t= tdfxfb_set_par,\n\t.fb_setcolreg\t= tdfxfb_setcolreg,\n\t.fb_blank\t= tdfxfb_blank,\n\t.fb_pan_display\t= tdfxfb_pan_display,\n\t.fb_sync\t= banshee_wait_idle,\n\t.fb_cursor\t= tdfxfb_cursor,\n#ifdef CONFIG_FB_3DFX_ACCEL\n\t.fb_fillrect\t= tdfxfb_fillrect,\n\t.fb_copyarea\t= tdfxfb_copyarea,\n\t.fb_imageblit\t= tdfxfb_imageblit,\n#else\n\t.fb_fillrect\t= cfb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n#endif\n};\n\n#ifdef CONFIG_FB_3DFX_I2C\n \n\nstatic void tdfxfb_i2c_setscl(void *data, int val)\n{\n\tstruct tdfxfb_i2c_chan \t*chan = data;\n\tstruct tdfx_par \t*par = chan->par;\n\tunsigned int r;\n\n\tr = tdfx_inl(par, VIDSERPARPORT);\n\tif (val)\n\t\tr |= I2C_SCL_OUT;\n\telse\n\t\tr &= ~I2C_SCL_OUT;\n\ttdfx_outl(par, VIDSERPARPORT, r);\n\ttdfx_inl(par, VIDSERPARPORT);\t \n}\n\nstatic void tdfxfb_i2c_setsda(void *data, int val)\n{\n\tstruct tdfxfb_i2c_chan \t*chan = data;\n\tstruct tdfx_par \t*par = chan->par;\n\tunsigned int r;\n\n\tr = tdfx_inl(par, VIDSERPARPORT);\n\tif (val)\n\t\tr |= I2C_SDA_OUT;\n\telse\n\t\tr &= ~I2C_SDA_OUT;\n\ttdfx_outl(par, VIDSERPARPORT, r);\n\ttdfx_inl(par, VIDSERPARPORT);\t \n}\n\n \n\nstatic int tdfxfb_i2c_getscl(void *data)\n{\n\tstruct tdfxfb_i2c_chan \t*chan = data;\n\tstruct tdfx_par \t*par = chan->par;\n\n\treturn (0 != (tdfx_inl(par, VIDSERPARPORT) & I2C_SCL_IN));\n}\n\nstatic int tdfxfb_i2c_getsda(void *data)\n{\n\tstruct tdfxfb_i2c_chan \t*chan = data;\n\tstruct tdfx_par \t*par = chan->par;\n\n\treturn (0 != (tdfx_inl(par, VIDSERPARPORT) & I2C_SDA_IN));\n}\n\nstatic void tdfxfb_ddc_setscl(void *data, int val)\n{\n\tstruct tdfxfb_i2c_chan \t*chan = data;\n\tstruct tdfx_par \t*par = chan->par;\n\tunsigned int r;\n\n\tr = tdfx_inl(par, VIDSERPARPORT);\n\tif (val)\n\t\tr |= DDC_SCL_OUT;\n\telse\n\t\tr &= ~DDC_SCL_OUT;\n\ttdfx_outl(par, VIDSERPARPORT, r);\n\ttdfx_inl(par, VIDSERPARPORT);\t \n}\n\nstatic void tdfxfb_ddc_setsda(void *data, int val)\n{\n\tstruct tdfxfb_i2c_chan \t*chan = data;\n\tstruct tdfx_par \t*par = chan->par;\n\tunsigned int r;\n\n\tr = tdfx_inl(par, VIDSERPARPORT);\n\tif (val)\n\t\tr |= DDC_SDA_OUT;\n\telse\n\t\tr &= ~DDC_SDA_OUT;\n\ttdfx_outl(par, VIDSERPARPORT, r);\n\ttdfx_inl(par, VIDSERPARPORT);\t \n}\n\nstatic int tdfxfb_ddc_getscl(void *data)\n{\n\tstruct tdfxfb_i2c_chan \t*chan = data;\n\tstruct tdfx_par \t*par = chan->par;\n\n\treturn (0 != (tdfx_inl(par, VIDSERPARPORT) & DDC_SCL_IN));\n}\n\nstatic int tdfxfb_ddc_getsda(void *data)\n{\n\tstruct tdfxfb_i2c_chan \t*chan = data;\n\tstruct tdfx_par \t*par = chan->par;\n\n\treturn (0 != (tdfx_inl(par, VIDSERPARPORT) & DDC_SDA_IN));\n}\n\nstatic int tdfxfb_setup_ddc_bus(struct tdfxfb_i2c_chan *chan, const char *name,\n\t\t\t\tstruct device *dev)\n{\n\tint rc;\n\n\tstrscpy(chan->adapter.name, name, sizeof(chan->adapter.name));\n\tchan->adapter.owner\t\t= THIS_MODULE;\n\tchan->adapter.class\t\t= I2C_CLASS_DDC;\n\tchan->adapter.algo_data\t\t= &chan->algo;\n\tchan->adapter.dev.parent\t= dev;\n\tchan->algo.setsda\t\t= tdfxfb_ddc_setsda;\n\tchan->algo.setscl\t\t= tdfxfb_ddc_setscl;\n\tchan->algo.getsda\t\t= tdfxfb_ddc_getsda;\n\tchan->algo.getscl\t\t= tdfxfb_ddc_getscl;\n\tchan->algo.udelay\t\t= 10;\n\tchan->algo.timeout\t\t= msecs_to_jiffies(500);\n\tchan->algo.data \t\t= chan;\n\n\ti2c_set_adapdata(&chan->adapter, chan);\n\n\trc = i2c_bit_add_bus(&chan->adapter);\n\tif (rc == 0)\n\t\tDPRINTK(\"I2C bus %s registered.\\n\", name);\n\telse\n\t\tchan->par = NULL;\n\n\treturn rc;\n}\n\nstatic int tdfxfb_setup_i2c_bus(struct tdfxfb_i2c_chan *chan, const char *name,\n\t\t\t\tstruct device *dev)\n{\n\tint rc;\n\n\tstrscpy(chan->adapter.name, name, sizeof(chan->adapter.name));\n\tchan->adapter.owner\t\t= THIS_MODULE;\n\tchan->adapter.algo_data\t\t= &chan->algo;\n\tchan->adapter.dev.parent\t= dev;\n\tchan->algo.setsda\t\t= tdfxfb_i2c_setsda;\n\tchan->algo.setscl\t\t= tdfxfb_i2c_setscl;\n\tchan->algo.getsda\t\t= tdfxfb_i2c_getsda;\n\tchan->algo.getscl\t\t= tdfxfb_i2c_getscl;\n\tchan->algo.udelay\t\t= 10;\n\tchan->algo.timeout\t\t= msecs_to_jiffies(500);\n\tchan->algo.data \t\t= chan;\n\n\ti2c_set_adapdata(&chan->adapter, chan);\n\n\trc = i2c_bit_add_bus(&chan->adapter);\n\tif (rc == 0)\n\t\tDPRINTK(\"I2C bus %s registered.\\n\", name);\n\telse\n\t\tchan->par = NULL;\n\n\treturn rc;\n}\n\nstatic void tdfxfb_create_i2c_busses(struct fb_info *info)\n{\n\tstruct tdfx_par *par = info->par;\n\n\ttdfx_outl(par, VIDINFORMAT, 0x8160);\n\ttdfx_outl(par, VIDSERPARPORT, 0xcffc0020);\n\n\tpar->chan[0].par = par;\n\tpar->chan[1].par = par;\n\n\ttdfxfb_setup_ddc_bus(&par->chan[0], \"Voodoo3-DDC\", info->device);\n\ttdfxfb_setup_i2c_bus(&par->chan[1], \"Voodoo3-I2C\", info->device);\n}\n\nstatic void tdfxfb_delete_i2c_busses(struct tdfx_par *par)\n{\n\tif (par->chan[0].par)\n\t\ti2c_del_adapter(&par->chan[0].adapter);\n\tpar->chan[0].par = NULL;\n\n\tif (par->chan[1].par)\n\t\ti2c_del_adapter(&par->chan[1].adapter);\n\tpar->chan[1].par = NULL;\n}\n\nstatic int tdfxfb_probe_i2c_connector(struct tdfx_par *par,\n\t\t\t\t      struct fb_monspecs *specs)\n{\n\tu8 *edid = NULL;\n\n\tDPRINTK(\"Probe DDC Bus\\n\");\n\tif (par->chan[0].par)\n\t\tedid = fb_ddc_read(&par->chan[0].adapter);\n\n\tif (edid) {\n\t\tfb_edid_to_monspecs(edid, specs);\n\t\tkfree(edid);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n#endif  \n\n \nstatic int tdfxfb_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct tdfx_par *default_par;\n\tstruct fb_info *info;\n\tint err, lpitch;\n\tstruct fb_monspecs *specs;\n\tbool found;\n\n\terr = aperture_remove_conflicting_pci_devices(pdev, \"tdfxfb\");\n\tif (err)\n\t\treturn err;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"tdfxfb: Can't enable pdev: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct tdfx_par), &pdev->dev);\n\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tdefault_par = info->par;\n\tinfo->fix = tdfx_fix;\n\n\t \n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_3DFX_BANSHEE:\n\t\tstrcpy(info->fix.id, \"3Dfx Banshee\");\n\t\tdefault_par->max_pixclock = BANSHEE_MAX_PIXCLOCK;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_3DFX_VOODOO3:\n\t\tstrcpy(info->fix.id, \"3Dfx Voodoo3\");\n\t\tdefault_par->max_pixclock = VOODOO3_MAX_PIXCLOCK;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_3DFX_VOODOO5:\n\t\tstrcpy(info->fix.id, \"3Dfx Voodoo5\");\n\t\tdefault_par->max_pixclock = VOODOO5_MAX_PIXCLOCK;\n\t\tbreak;\n\t}\n\n\tinfo->fix.mmio_start = pci_resource_start(pdev, 0);\n\tinfo->fix.mmio_len = pci_resource_len(pdev, 0);\n\tif (!request_mem_region(info->fix.mmio_start, info->fix.mmio_len,\n\t\t\t\t\"tdfx regbase\")) {\n\t\tprintk(KERN_ERR \"tdfxfb: Can't reserve regbase\\n\");\n\t\tgoto out_err;\n\t}\n\n\tdefault_par->regbase_virt =\n\t\tioremap(info->fix.mmio_start, info->fix.mmio_len);\n\tif (!default_par->regbase_virt) {\n\t\tprintk(KERN_ERR \"fb: Can't remap %s register area.\\n\",\n\t\t\t\tinfo->fix.id);\n\t\tgoto out_err_regbase;\n\t}\n\n\tinfo->fix.smem_start = pci_resource_start(pdev, 1);\n\tinfo->fix.smem_len = do_lfb_size(default_par, pdev->device);\n\tif (!info->fix.smem_len) {\n\t\tprintk(KERN_ERR \"fb: Can't count %s memory.\\n\", info->fix.id);\n\t\tgoto out_err_regbase;\n\t}\n\n\tif (!request_mem_region(info->fix.smem_start,\n\t\t\t\tpci_resource_len(pdev, 1), \"tdfx smem\")) {\n\t\tprintk(KERN_ERR \"tdfxfb: Can't reserve smem\\n\");\n\t\tgoto out_err_regbase;\n\t}\n\n\tinfo->screen_base = ioremap_wc(info->fix.smem_start,\n\t\t\t\t       info->fix.smem_len);\n\tif (!info->screen_base) {\n\t\tprintk(KERN_ERR \"fb: Can't remap %s framebuffer.\\n\",\n\t\t\t\tinfo->fix.id);\n\t\tgoto out_err_screenbase;\n\t}\n\n\tdefault_par->iobase = pci_resource_start(pdev, 2);\n\n\tif (!request_region(pci_resource_start(pdev, 2),\n\t\t\t    pci_resource_len(pdev, 2), \"tdfx iobase\")) {\n\t\tprintk(KERN_ERR \"tdfxfb: Can't reserve iobase\\n\");\n\t\tgoto out_err_screenbase;\n\t}\n\n\tprintk(KERN_INFO \"fb: %s memory = %dK\\n\", info->fix.id,\n\t\t\tinfo->fix.smem_len >> 10);\n\n\tif (!nomtrr)\n\t\tdefault_par->wc_cookie= arch_phys_wc_add(info->fix.smem_start,\n\t\t\t\t\t\t\t info->fix.smem_len);\n\n\tinfo->fix.ypanstep\t= nopan ? 0 : 1;\n\tinfo->fix.ywrapstep\t= nowrap ? 0 : 1;\n\n\tinfo->fbops\t\t= &tdfxfb_ops;\n\tinfo->pseudo_palette\t= default_par->palette;\n\tinfo->flags\t\t= FBINFO_HWACCEL_YPAN;\n#ifdef CONFIG_FB_3DFX_ACCEL\n\tinfo->flags\t\t|= FBINFO_HWACCEL_FILLRECT |\n\t\t\t\t   FBINFO_HWACCEL_COPYAREA |\n\t\t\t\t   FBINFO_HWACCEL_IMAGEBLIT |\n\t\t\t\t   FBINFO_READS_FAST;\n#endif\n\t \n\t \n\tif (hwcursor)\n\t\tinfo->fix.smem_len = (info->fix.smem_len - 1024) &\n\t\t\t\t\t(PAGE_MASK << 1);\n\tspecs = &info->monspecs;\n\tfound = false;\n\tinfo->var.bits_per_pixel = 8;\n#ifdef CONFIG_FB_3DFX_I2C\n\ttdfxfb_create_i2c_busses(info);\n\terr = tdfxfb_probe_i2c_connector(default_par, specs);\n\n\tif (!err) {\n\t\tif (specs->modedb == NULL)\n\t\t\tDPRINTK(\"Unable to get Mode Database\\n\");\n\t\telse {\n\t\t\tconst struct fb_videomode *m;\n\n\t\t\tfb_videomode_to_modelist(specs->modedb,\n\t\t\t\t\t\t specs->modedb_len,\n\t\t\t\t\t\t &info->modelist);\n\t\t\tm = fb_find_best_display(specs, &info->modelist);\n\t\t\tif (m) {\n\t\t\t\tfb_videomode_to_var(&info->var, m);\n\t\t\t\t \n\t\t\t\tif (tdfxfb_check_var(&info->var, info) < 0)\n\t\t\t\t\tinfo->var = tdfx_var;\n\t\t\t\telse\n\t\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tif (!mode_option && !found)\n\t\tmode_option = \"640x480@60\";\n\n\tif (mode_option) {\n\t\terr = fb_find_mode(&info->var, info, mode_option,\n\t\t\t\t   specs->modedb, specs->modedb_len,\n\t\t\t\t   NULL, info->var.bits_per_pixel);\n\t\tif (!err || err == 4)\n\t\t\tinfo->var = tdfx_var;\n\t}\n\n\tif (found) {\n\t\tfb_destroy_modedb(specs->modedb);\n\t\tspecs->modedb = NULL;\n\t}\n\n\t \n\tlpitch = info->var.xres_virtual * ((info->var.bits_per_pixel + 7) >> 3);\n\tinfo->var.yres_virtual = info->fix.smem_len / lpitch;\n\tif (info->var.yres_virtual < info->var.yres)\n\t\tgoto out_err_iobase;\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\n\t\tprintk(KERN_ERR \"tdfxfb: Can't allocate color map\\n\");\n\t\tgoto out_err_iobase;\n\t}\n\n\tif (register_framebuffer(info) < 0) {\n\t\tprintk(KERN_ERR \"tdfxfb: can't register framebuffer\\n\");\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\tgoto out_err_iobase;\n\t}\n\t \n\tpci_set_drvdata(pdev, info);\n\treturn 0;\n\nout_err_iobase:\n#ifdef CONFIG_FB_3DFX_I2C\n\ttdfxfb_delete_i2c_busses(default_par);\n#endif\n\tarch_phys_wc_del(default_par->wc_cookie);\n\trelease_region(pci_resource_start(pdev, 2),\n\t\t       pci_resource_len(pdev, 2));\nout_err_screenbase:\n\tif (info->screen_base)\n\t\tiounmap(info->screen_base);\n\trelease_mem_region(info->fix.smem_start, pci_resource_len(pdev, 1));\nout_err_regbase:\n\t \n\tif (default_par->regbase_virt)\n\t\tiounmap(default_par->regbase_virt);\n\trelease_mem_region(info->fix.mmio_start, info->fix.mmio_len);\nout_err:\n\tframebuffer_release(info);\n\treturn -ENXIO;\n}\n\n#ifndef MODULE\nstatic void __init tdfxfb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\t\tif (!strcmp(this_opt, \"nopan\")) {\n\t\t\tnopan = 1;\n\t\t} else if (!strcmp(this_opt, \"nowrap\")) {\n\t\t\tnowrap = 1;\n\t\t} else if (!strncmp(this_opt, \"hwcursor=\", 9)) {\n\t\t\thwcursor = simple_strtoul(this_opt + 9, NULL, 0);\n\t\t} else if (!strncmp(this_opt, \"nomtrr\", 6)) {\n\t\t\tnomtrr = 1;\n\t\t} else {\n\t\t\tmode_option = this_opt;\n\t\t}\n\t}\n}\n#endif\n\n \nstatic void tdfxfb_remove(struct pci_dev *pdev)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct tdfx_par *par = info->par;\n\n\tunregister_framebuffer(info);\n#ifdef CONFIG_FB_3DFX_I2C\n\ttdfxfb_delete_i2c_busses(par);\n#endif\n\tarch_phys_wc_del(par->wc_cookie);\n\tiounmap(par->regbase_virt);\n\tiounmap(info->screen_base);\n\n\t \n\trelease_region(pci_resource_start(pdev, 2),\n\t\t       pci_resource_len(pdev, 2));\n\trelease_mem_region(pci_resource_start(pdev, 1),\n\t\t\t   pci_resource_len(pdev, 1));\n\trelease_mem_region(pci_resource_start(pdev, 0),\n\t\t\t   pci_resource_len(pdev, 0));\n\tfb_dealloc_cmap(&info->cmap);\n\tframebuffer_release(info);\n}\n\nstatic int __init tdfxfb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"tdfxfb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"tdfxfb\", &option))\n\t\treturn -ENODEV;\n\n\ttdfxfb_setup(option);\n#endif\n\treturn pci_register_driver(&tdfxfb_driver);\n}\n\nstatic void __exit tdfxfb_exit(void)\n{\n\tpci_unregister_driver(&tdfxfb_driver);\n}\n\nMODULE_AUTHOR(\"Hannu Mallat <hmallat@cc.hut.fi>\");\nMODULE_DESCRIPTION(\"3Dfx framebuffer device driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(hwcursor, int, 0644);\nMODULE_PARM_DESC(hwcursor, \"Enable hardware cursor \"\n\t\t\t\"(1=enable, 0=disable, default=1)\");\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Initial video mode e.g. '648x480-8@60'\");\nmodule_param(nomtrr, bool, 0);\nMODULE_PARM_DESC(nomtrr, \"Disable MTRR support (default: enabled)\");\n\nmodule_init(tdfxfb_init);\nmodule_exit(tdfxfb_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}