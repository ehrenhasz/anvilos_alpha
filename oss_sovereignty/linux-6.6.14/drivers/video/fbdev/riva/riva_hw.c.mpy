{
  "module_name": "riva_hw.c",
  "hash_id": "baef6e1fb9c931f5122eaa9410e45a6840c536fc221720a3ac3b831400d337a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/riva/riva_hw.c",
  "human_readable_source": "  \n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include \"riva_hw.h\"\n#include \"riva_tbl.h\"\n#include \"nv_type.h\"\n\n \nstatic int nv3Busy\n(\n    RIVA_HW_INST *chip\n)\n{\n    return ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||\n\t    NV_RD32(&chip->PGRAPH[0x000006B0/4], 0) & 0x01);\n}\nstatic int nv4Busy\n(\n    RIVA_HW_INST *chip\n)\n{\n    return ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||\n\t    NV_RD32(&chip->PGRAPH[0x00000700/4], 0) & 0x01);\n}\nstatic int nv10Busy\n(\n    RIVA_HW_INST *chip\n)\n{\n    return ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||\n\t    NV_RD32(&chip->PGRAPH[0x00000700/4], 0) & 0x01);\n}\n\nstatic void vgaLockUnlock\n(\n    RIVA_HW_INST *chip,\n    int           Lock\n)\n{\n    U008 cr11;\n    VGA_WR08(chip->PCIO, 0x3D4, 0x11);\n    cr11 = VGA_RD08(chip->PCIO, 0x3D5);\n    if(Lock) cr11 |= 0x80;\n    else cr11 &= ~0x80;\n    VGA_WR08(chip->PCIO, 0x3D5, cr11);\n}\nstatic void nv3LockUnlock\n(\n    RIVA_HW_INST *chip,\n    int           Lock\n)\n{\n    VGA_WR08(chip->PVIO, 0x3C4, 0x06);\n    VGA_WR08(chip->PVIO, 0x3C5, Lock ? 0x99 : 0x57);\n    vgaLockUnlock(chip, Lock);\n}\nstatic void nv4LockUnlock\n(\n    RIVA_HW_INST *chip,\n    int           Lock\n)\n{\n    VGA_WR08(chip->PCIO, 0x3D4, 0x1F);\n    VGA_WR08(chip->PCIO, 0x3D5, Lock ? 0x99 : 0x57);\n    vgaLockUnlock(chip, Lock);\n}\n\nstatic int ShowHideCursor\n(\n    RIVA_HW_INST *chip,\n    int           ShowHide\n)\n{\n    int cursor;\n    cursor                      =  chip->CurrentState->cursor1;\n    chip->CurrentState->cursor1 = (chip->CurrentState->cursor1 & 0xFE) |\n                                  (ShowHide & 0x01);\n    VGA_WR08(chip->PCIO, 0x3D4, 0x31);\n    VGA_WR08(chip->PCIO, 0x3D5, chip->CurrentState->cursor1);\n    return (cursor & 0x01);\n}\n\n \n\n#define DEFAULT_GR_LWM 100\n#define DEFAULT_VID_LWM 100\n#define DEFAULT_GR_BURST_SIZE 256\n#define DEFAULT_VID_BURST_SIZE 128\n#define VIDEO\t\t0\n#define GRAPHICS\t1\n#define MPORT\t\t2\n#define ENGINE\t\t3\n#define GFIFO_SIZE\t320\n#define GFIFO_SIZE_128\t256\n#define MFIFO_SIZE\t120\n#define VFIFO_SIZE\t256\n\ntypedef struct {\n  int gdrain_rate;\n  int vdrain_rate;\n  int mdrain_rate;\n  int gburst_size;\n  int vburst_size;\n  char vid_en;\n  char gr_en;\n  int wcmocc, wcgocc, wcvocc, wcvlwm, wcglwm;\n  int by_gfacc;\n  char vid_only_once;\n  char gr_only_once;\n  char first_vacc;\n  char first_gacc;\n  char first_macc;\n  int vocc;\n  int gocc;\n  int mocc;\n  char cur;\n  char engine_en;\n  char converged;\n  int priority;\n} nv3_arb_info;\ntypedef struct {\n  int graphics_lwm;\n  int video_lwm;\n  int graphics_burst_size;\n  int video_burst_size;\n  int graphics_hi_priority;\n  int media_hi_priority;\n  int rtl_values;\n  int valid;\n} nv3_fifo_info;\ntypedef struct {\n  char pix_bpp;\n  char enable_video;\n  char gr_during_vid;\n  char enable_mp;\n  int memory_width;\n  int video_scale;\n  int pclk_khz;\n  int mclk_khz;\n  int mem_page_miss;\n  int mem_latency;\n  char mem_aligned;\n} nv3_sim_state;\ntypedef struct {\n  int graphics_lwm;\n  int video_lwm;\n  int graphics_burst_size;\n  int video_burst_size;\n  int valid;\n} nv4_fifo_info;\ntypedef struct {\n  int pclk_khz;\n  int mclk_khz;\n  int nvclk_khz;\n  char mem_page_miss;\n  char mem_latency;\n  int memory_width;\n  char enable_video;\n  char gr_during_vid;\n  char pix_bpp;\n  char mem_aligned;\n  char enable_mp;\n} nv4_sim_state;\ntypedef struct {\n  int graphics_lwm;\n  int video_lwm;\n  int graphics_burst_size;\n  int video_burst_size;\n  int valid;\n} nv10_fifo_info;\ntypedef struct {\n  int pclk_khz;\n  int mclk_khz;\n  int nvclk_khz;\n  char mem_page_miss;\n  char mem_latency;\n  u32 memory_type;\n  int memory_width;\n  char enable_video;\n  char gr_during_vid;\n  char pix_bpp;\n  char mem_aligned;\n  char enable_mp;\n} nv10_sim_state;\nstatic int nv3_iterate(nv3_fifo_info *res_info, nv3_sim_state * state, nv3_arb_info *ainfo)\n{\n    int iter = 0;\n    int tmp;\n    int vfsize, mfsize, gfsize;\n    int mburst_size = 32;\n    int mmisses, gmisses, vmisses;\n    int misses;\n    int vlwm, glwm;\n    int last, next, cur;\n    int max_gfsize ;\n    long ns;\n\n    vlwm = 0;\n    glwm = 0;\n    vfsize = 0;\n    gfsize = 0;\n    cur = ainfo->cur;\n    mmisses = 2;\n    gmisses = 2;\n    vmisses = 2;\n    if (ainfo->gburst_size == 128) max_gfsize = GFIFO_SIZE_128;\n    else  max_gfsize = GFIFO_SIZE;\n    max_gfsize = GFIFO_SIZE;\n    while (1)\n    {\n        if (ainfo->vid_en)\n        {\n            if (ainfo->wcvocc > ainfo->vocc) ainfo->wcvocc = ainfo->vocc;\n            if (ainfo->wcvlwm > vlwm) ainfo->wcvlwm = vlwm ;\n            ns = 1000000 * ainfo->vburst_size/(state->memory_width/8)/state->mclk_khz;\n            vfsize = ns * ainfo->vdrain_rate / 1000000;\n            vfsize =  ainfo->wcvlwm - ainfo->vburst_size + vfsize;\n        }\n        if (state->enable_mp)\n        {\n            if (ainfo->wcmocc > ainfo->mocc) ainfo->wcmocc = ainfo->mocc;\n        }\n        if (ainfo->gr_en)\n        {\n            if (ainfo->wcglwm > glwm) ainfo->wcglwm = glwm ;\n            if (ainfo->wcgocc > ainfo->gocc) ainfo->wcgocc = ainfo->gocc;\n            ns = 1000000 * (ainfo->gburst_size/(state->memory_width/8))/state->mclk_khz;\n            gfsize = (ns * (long) ainfo->gdrain_rate)/1000000;\n            gfsize = ainfo->wcglwm - ainfo->gburst_size + gfsize;\n        }\n        mfsize = 0;\n        if (!state->gr_during_vid && ainfo->vid_en)\n            if (ainfo->vid_en && (ainfo->vocc < 0) && !ainfo->vid_only_once)\n                next = VIDEO;\n            else if (ainfo->mocc < 0)\n                next = MPORT;\n            else if (ainfo->gocc< ainfo->by_gfacc)\n                next = GRAPHICS;\n            else return (0);\n        else switch (ainfo->priority)\n            {\n                case VIDEO:\n                    if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)\n                        next = VIDEO;\n                    else if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)\n                        next = GRAPHICS;\n                    else if (ainfo->mocc<0)\n                        next = MPORT;\n                    else    return (0);\n                    break;\n                case GRAPHICS:\n                    if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)\n                        next = GRAPHICS;\n                    else if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)\n                        next = VIDEO;\n                    else if (ainfo->mocc<0)\n                        next = MPORT;\n                    else    return (0);\n                    break;\n                default:\n                    if (ainfo->mocc<0)\n                        next = MPORT;\n                    else if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)\n                        next = GRAPHICS;\n                    else if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)\n                        next = VIDEO;\n                    else    return (0);\n                    break;\n            }\n        last = cur;\n        cur = next;\n        iter++;\n        switch (cur)\n        {\n            case VIDEO:\n                if (last==cur)    misses = 0;\n                else if (ainfo->first_vacc)   misses = vmisses;\n                else    misses = 1;\n                ainfo->first_vacc = 0;\n                if (last!=cur)\n                {\n                    ns =  1000000 * (vmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz; \n                    vlwm = ns * ainfo->vdrain_rate/ 1000000;\n                    vlwm = ainfo->vocc - vlwm;\n                }\n                ns = 1000000*(misses*state->mem_page_miss + ainfo->vburst_size)/(state->memory_width/8)/state->mclk_khz;\n                ainfo->vocc = ainfo->vocc + ainfo->vburst_size - ns*ainfo->vdrain_rate/1000000;\n                ainfo->gocc = ainfo->gocc - ns*ainfo->gdrain_rate/1000000;\n                ainfo->mocc = ainfo->mocc - ns*ainfo->mdrain_rate/1000000;\n                break;\n            case GRAPHICS:\n                if (last==cur)    misses = 0;\n                else if (ainfo->first_gacc)   misses = gmisses;\n                else    misses = 1;\n                ainfo->first_gacc = 0;\n                if (last!=cur)\n                {\n                    ns = 1000000*(gmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz ;\n                    glwm = ns * ainfo->gdrain_rate/1000000;\n                    glwm = ainfo->gocc - glwm;\n                }\n                ns = 1000000*(misses*state->mem_page_miss + ainfo->gburst_size/(state->memory_width/8))/state->mclk_khz;\n                ainfo->vocc = ainfo->vocc + 0 - ns*ainfo->vdrain_rate/1000000;\n                ainfo->gocc = ainfo->gocc + ainfo->gburst_size - ns*ainfo->gdrain_rate/1000000;\n                ainfo->mocc = ainfo->mocc + 0 - ns*ainfo->mdrain_rate/1000000;\n                break;\n            default:\n                if (last==cur)    misses = 0;\n                else if (ainfo->first_macc)   misses = mmisses;\n                else    misses = 1;\n                ainfo->first_macc = 0;\n                ns = 1000000*(misses*state->mem_page_miss + mburst_size/(state->memory_width/8))/state->mclk_khz;\n                ainfo->vocc = ainfo->vocc + 0 - ns*ainfo->vdrain_rate/1000000;\n                ainfo->gocc = ainfo->gocc + 0 - ns*ainfo->gdrain_rate/1000000;\n                ainfo->mocc = ainfo->mocc + mburst_size - ns*ainfo->mdrain_rate/1000000;\n                break;\n        }\n        if (iter>100)\n        {\n            ainfo->converged = 0;\n            return (1);\n        }\n        ns = 1000000*ainfo->gburst_size/(state->memory_width/8)/state->mclk_khz;\n        tmp = ns * ainfo->gdrain_rate/1000000;\n        if (abs(ainfo->gburst_size) + ((abs(ainfo->wcglwm) + 16 ) & ~0x7) - tmp > max_gfsize)\n        {\n            ainfo->converged = 0;\n            return (1);\n        }\n        ns = 1000000*ainfo->vburst_size/(state->memory_width/8)/state->mclk_khz;\n        tmp = ns * ainfo->vdrain_rate/1000000;\n        if (abs(ainfo->vburst_size) + (abs(ainfo->wcvlwm + 32) & ~0xf)  - tmp> VFIFO_SIZE)\n        {\n            ainfo->converged = 0;\n            return (1);\n        }\n        if (abs(ainfo->gocc) > max_gfsize)\n        {\n            ainfo->converged = 0;\n            return (1);\n        }\n        if (abs(ainfo->vocc) > VFIFO_SIZE)\n        {\n            ainfo->converged = 0;\n            return (1);\n        }\n        if (abs(ainfo->mocc) > MFIFO_SIZE)\n        {\n            ainfo->converged = 0;\n            return (1);\n        }\n        if (abs(vfsize) > VFIFO_SIZE)\n        {\n            ainfo->converged = 0;\n            return (1);\n        }\n        if (abs(gfsize) > max_gfsize)\n        {\n            ainfo->converged = 0;\n            return (1);\n        }\n        if (abs(mfsize) > MFIFO_SIZE)\n        {\n            ainfo->converged = 0;\n            return (1);\n        }\n    }\n}\nstatic char nv3_arb(nv3_fifo_info * res_info, nv3_sim_state * state,  nv3_arb_info *ainfo) \n{\n    long ens, vns, mns, gns;\n    int mmisses, gmisses, vmisses, eburst_size, mburst_size;\n    int refresh_cycle;\n\n    refresh_cycle = 2*(state->mclk_khz/state->pclk_khz) + 5;\n    mmisses = 2;\n    if (state->mem_aligned) gmisses = 2;\n    else    gmisses = 3;\n    vmisses = 2;\n    eburst_size = state->memory_width * 1;\n    mburst_size = 32;\n    gns = 1000000 * (gmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz;\n    ainfo->by_gfacc = gns*ainfo->gdrain_rate/1000000;\n    ainfo->wcmocc = 0;\n    ainfo->wcgocc = 0;\n    ainfo->wcvocc = 0;\n    ainfo->wcvlwm = 0;\n    ainfo->wcglwm = 0;\n    ainfo->engine_en = 1;\n    ainfo->converged = 1;\n    if (ainfo->engine_en)\n    {\n        ens =  1000000*(state->mem_page_miss + eburst_size/(state->memory_width/8) +refresh_cycle)/state->mclk_khz;\n        ainfo->mocc = state->enable_mp ? 0-ens*ainfo->mdrain_rate/1000000 : 0;\n        ainfo->vocc = ainfo->vid_en ? 0-ens*ainfo->vdrain_rate/1000000 : 0;\n        ainfo->gocc = ainfo->gr_en ? 0-ens*ainfo->gdrain_rate/1000000 : 0;\n        ainfo->cur = ENGINE;\n        ainfo->first_vacc = 1;\n        ainfo->first_gacc = 1;\n        ainfo->first_macc = 1;\n        nv3_iterate(res_info, state,ainfo);\n    }\n    if (state->enable_mp)\n    {\n        mns = 1000000 * (mmisses*state->mem_page_miss + mburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;\n        ainfo->mocc = state->enable_mp ? 0 : mburst_size - mns*ainfo->mdrain_rate/1000000;\n        ainfo->vocc = ainfo->vid_en ? 0 : 0- mns*ainfo->vdrain_rate/1000000;\n        ainfo->gocc = ainfo->gr_en ? 0: 0- mns*ainfo->gdrain_rate/1000000;\n        ainfo->cur = MPORT;\n        ainfo->first_vacc = 1;\n        ainfo->first_gacc = 1;\n        ainfo->first_macc = 0;\n        nv3_iterate(res_info, state,ainfo);\n    }\n    if (ainfo->gr_en)\n    {\n        ainfo->first_vacc = 1;\n        ainfo->first_gacc = 0;\n        ainfo->first_macc = 1;\n        gns = 1000000*(gmisses*state->mem_page_miss + ainfo->gburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;\n        ainfo->gocc = ainfo->gburst_size - gns*ainfo->gdrain_rate/1000000;\n        ainfo->vocc = ainfo->vid_en? 0-gns*ainfo->vdrain_rate/1000000 : 0;\n        ainfo->mocc = state->enable_mp ?  0-gns*ainfo->mdrain_rate/1000000: 0;\n        ainfo->cur = GRAPHICS;\n        nv3_iterate(res_info, state,ainfo);\n    }\n    if (ainfo->vid_en)\n    {\n        ainfo->first_vacc = 0;\n        ainfo->first_gacc = 1;\n        ainfo->first_macc = 1;\n        vns = 1000000*(vmisses*state->mem_page_miss + ainfo->vburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;\n        ainfo->vocc = ainfo->vburst_size - vns*ainfo->vdrain_rate/1000000;\n        ainfo->gocc = ainfo->gr_en? (0-vns*ainfo->gdrain_rate/1000000) : 0;\n        ainfo->mocc = state->enable_mp? 0-vns*ainfo->mdrain_rate/1000000 :0 ;\n        ainfo->cur = VIDEO;\n        nv3_iterate(res_info, state, ainfo);\n    }\n    if (ainfo->converged)\n    {\n        res_info->graphics_lwm = (int)abs(ainfo->wcglwm) + 16;\n        res_info->video_lwm = (int)abs(ainfo->wcvlwm) + 32;\n        res_info->graphics_burst_size = ainfo->gburst_size;\n        res_info->video_burst_size = ainfo->vburst_size;\n        res_info->graphics_hi_priority = (ainfo->priority == GRAPHICS);\n        res_info->media_hi_priority = (ainfo->priority == MPORT);\n        if (res_info->video_lwm > 160)\n        {\n            res_info->graphics_lwm = 256;\n            res_info->video_lwm = 128;\n            res_info->graphics_burst_size = 64;\n            res_info->video_burst_size = 64;\n            res_info->graphics_hi_priority = 0;\n            res_info->media_hi_priority = 0;\n            ainfo->converged = 0;\n            return (0);\n        }\n        if (res_info->video_lwm > 128)\n        {\n            res_info->video_lwm = 128;\n        }\n        return (1);\n    }\n    else\n    {\n        res_info->graphics_lwm = 256;\n        res_info->video_lwm = 128;\n        res_info->graphics_burst_size = 64;\n        res_info->video_burst_size = 64;\n        res_info->graphics_hi_priority = 0;\n        res_info->media_hi_priority = 0;\n        return (0);\n    }\n}\nstatic char nv3_get_param(nv3_fifo_info *res_info, nv3_sim_state * state, nv3_arb_info *ainfo)\n{\n    int done, g,v, p;\n    \n    done = 0;\n    for (p=0; p < 2; p++)\n    {\n        for (g=128 ; g > 32; g= g>> 1)\n        {\n            for (v=128; v >=32; v = v>> 1)\n            {\n                ainfo->priority = p;\n                ainfo->gburst_size = g;     \n                ainfo->vburst_size = v;\n                done = nv3_arb(res_info, state,ainfo);\n                if (done && (g==128))\n                    if ((res_info->graphics_lwm + g) > 256)\n                        done = 0;\n                if (done)\n                    goto Done;\n            }\n        }\n    }\n\n Done:\n    return done;\n}\nstatic void nv3CalcArbitration \n(\n    nv3_fifo_info * res_info,\n    nv3_sim_state * state\n)\n{\n    nv3_fifo_info save_info;\n    nv3_arb_info ainfo;\n    char   res_gr, res_vid;\n\n    ainfo.gr_en = 1;\n    ainfo.vid_en = state->enable_video;\n    ainfo.vid_only_once = 0;\n    ainfo.gr_only_once = 0;\n    ainfo.gdrain_rate = (int) state->pclk_khz * (state->pix_bpp/8);\n    ainfo.vdrain_rate = (int) state->pclk_khz * 2;\n    if (state->video_scale != 0)\n        ainfo.vdrain_rate = ainfo.vdrain_rate/state->video_scale;\n    ainfo.mdrain_rate = 33000;\n    res_info->rtl_values = 0;\n    if (!state->gr_during_vid && state->enable_video)\n    {\n        ainfo.gr_only_once = 1;\n        ainfo.gr_en = 1;\n        ainfo.gdrain_rate = 0;\n        res_vid = nv3_get_param(res_info, state,  &ainfo);\n        res_vid = ainfo.converged;\n        save_info.video_lwm = res_info->video_lwm;\n        save_info.video_burst_size = res_info->video_burst_size;\n        ainfo.vid_en = 1;\n        ainfo.vid_only_once = 1;\n        ainfo.gr_en = 1;\n        ainfo.gdrain_rate = (int) state->pclk_khz * (state->pix_bpp/8);\n        ainfo.vdrain_rate = 0;\n        res_gr = nv3_get_param(res_info, state,  &ainfo);\n        res_gr = ainfo.converged;\n        res_info->video_lwm = save_info.video_lwm;\n        res_info->video_burst_size = save_info.video_burst_size;\n        res_info->valid = res_gr & res_vid;\n    }\n    else\n    {\n        if (!ainfo.gr_en) ainfo.gdrain_rate = 0;\n        if (!ainfo.vid_en) ainfo.vdrain_rate = 0;\n        res_gr = nv3_get_param(res_info, state,  &ainfo);\n        res_info->valid = ainfo.converged;\n    }\n}\nstatic void nv3UpdateArbitrationSettings\n(\n    unsigned      VClk, \n    unsigned      pixelDepth, \n    unsigned     *burst,\n    unsigned     *lwm,\n    RIVA_HW_INST *chip\n)\n{\n    nv3_fifo_info fifo_data;\n    nv3_sim_state sim_data;\n    unsigned int M, N, P, pll, MClk;\n    \n    pll = NV_RD32(&chip->PRAMDAC0[0x00000504/4], 0);\n    M = (pll >> 0) & 0xFF; N = (pll >> 8) & 0xFF; P = (pll >> 16) & 0x0F;\n    MClk = (N * chip->CrystalFreqKHz / M) >> P;\n    sim_data.pix_bpp        = (char)pixelDepth;\n    sim_data.enable_video   = 0;\n    sim_data.enable_mp      = 0;\n    sim_data.video_scale    = 1;\n    sim_data.memory_width   = (NV_RD32(&chip->PEXTDEV[0x00000000/4], 0) & 0x10) ?\n\t128 : 64;\n    sim_data.memory_width   = 128;\n\n    sim_data.mem_latency    = 9;\n    sim_data.mem_aligned    = 1;\n    sim_data.mem_page_miss  = 11;\n    sim_data.gr_during_vid  = 0;\n    sim_data.pclk_khz       = VClk;\n    sim_data.mclk_khz       = MClk;\n    nv3CalcArbitration(&fifo_data, &sim_data);\n    if (fifo_data.valid)\n    {\n        int  b = fifo_data.graphics_burst_size >> 4;\n        *burst = 0;\n        while (b >>= 1)\n\t    (*burst)++;\n        *lwm   = fifo_data.graphics_lwm >> 3;\n    }\n    else\n    {\n        *lwm   = 0x24;\n        *burst = 0x2;\n    }\n}\nstatic void nv4CalcArbitration \n(\n    nv4_fifo_info *fifo,\n    nv4_sim_state *arb\n)\n{\n    int data, pagemiss, cas,width, video_enable, bpp;\n    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;\n    int found, mclk_extra, mclk_loop, cbs, m1, p1;\n    int mclk_freq, pclk_freq, nvclk_freq, mp_enable;\n    int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;\n    int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;\n\n    fifo->valid = 1;\n    pclk_freq = arb->pclk_khz;\n    mclk_freq = arb->mclk_khz;\n    nvclk_freq = arb->nvclk_khz;\n    pagemiss = arb->mem_page_miss;\n    cas = arb->mem_latency;\n    width = arb->memory_width >> 6;\n    video_enable = arb->enable_video;\n    bpp = arb->pix_bpp;\n    mp_enable = arb->enable_mp;\n    clwm = 0;\n    vlwm = 0;\n    cbs = 128;\n    pclks = 2;\n    nvclks = 2;\n    nvclks += 2;\n    nvclks += 1;\n    mclks = 5;\n    mclks += 3;\n    mclks += 1;\n    mclks += cas;\n    mclks += 1;\n    mclks += 1;\n    mclks += 1;\n    mclks += 1;\n    mclk_extra = 3;\n    nvclks += 2;\n    nvclks += 1;\n    nvclks += 1;\n    nvclks += 1;\n    if (mp_enable)\n        mclks+=4;\n    nvclks += 0;\n    pclks += 0;\n    found = 0;\n    vbs = 0;\n    while (found != 1)\n    {\n        fifo->valid = 1;\n        found = 1;\n        mclk_loop = mclks+mclk_extra;\n        us_m = mclk_loop *1000*1000 / mclk_freq;\n        us_n = nvclks*1000*1000 / nvclk_freq;\n        us_p = nvclks*1000*1000 / pclk_freq;\n        if (video_enable)\n        {\n            video_drain_rate = pclk_freq * 2;\n            crtc_drain_rate = pclk_freq * bpp/8;\n            vpagemiss = 2;\n            vpagemiss += 1;\n            crtpagemiss = 2;\n            vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;\n            if (nvclk_freq * 2 > mclk_freq * width)\n                video_fill_us = cbs*1000*1000 / 16 / nvclk_freq ;\n            else\n                video_fill_us = cbs*1000*1000 / (8 * width) / mclk_freq;\n            us_video = vpm_us + us_m + us_n + us_p + video_fill_us;\n            vlwm = us_video * video_drain_rate/(1000*1000);\n            vlwm++;\n            vbs = 128;\n            if (vlwm > 128) vbs = 64;\n            if (vlwm > (256-64)) vbs = 32;\n            if (nvclk_freq * 2 > mclk_freq * width)\n                video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;\n            else\n                video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;\n            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;\n            us_crt =\n            us_video\n            +video_fill_us\n            +cpm_us\n            +us_m + us_n +us_p\n            ;\n            clwm = us_crt * crtc_drain_rate/(1000*1000);\n            clwm++;\n        }\n        else\n        {\n            crtc_drain_rate = pclk_freq * bpp/8;\n            crtpagemiss = 2;\n            crtpagemiss += 1;\n            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;\n            us_crt =  cpm_us + us_m + us_n + us_p ;\n            clwm = us_crt * crtc_drain_rate/(1000*1000);\n            clwm++;\n        }\n        m1 = clwm + cbs - 512;\n        p1 = m1 * pclk_freq / mclk_freq;\n        p1 = p1 * bpp / 8;\n        if ((p1 < m1) && (m1 > 0))\n        {\n            fifo->valid = 0;\n            found = 0;\n            if (mclk_extra ==0)   found = 1;\n            mclk_extra--;\n        }\n        else if (video_enable)\n        {\n            if ((clwm > 511) || (vlwm > 255))\n            {\n                fifo->valid = 0;\n                found = 0;\n                if (mclk_extra ==0)   found = 1;\n                mclk_extra--;\n            }\n        }\n        else\n        {\n            if (clwm > 519)\n            {\n                fifo->valid = 0;\n                found = 0;\n                if (mclk_extra ==0)   found = 1;\n                mclk_extra--;\n            }\n        }\n        if (clwm < 384) clwm = 384;\n        if (vlwm < 128) vlwm = 128;\n        data = (int)(clwm);\n        fifo->graphics_lwm = data;\n        fifo->graphics_burst_size = 128;\n        data = (int)((vlwm+15));\n        fifo->video_lwm = data;\n        fifo->video_burst_size = vbs;\n    }\n}\nstatic void nv4UpdateArbitrationSettings\n(\n    unsigned      VClk, \n    unsigned      pixelDepth, \n    unsigned     *burst,\n    unsigned     *lwm,\n    RIVA_HW_INST *chip\n)\n{\n    nv4_fifo_info fifo_data;\n    nv4_sim_state sim_data;\n    unsigned int M, N, P, pll, MClk, NVClk, cfg1;\n\n    pll = NV_RD32(&chip->PRAMDAC0[0x00000504/4], 0);\n    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;\n    MClk  = (N * chip->CrystalFreqKHz / M) >> P;\n    pll = NV_RD32(&chip->PRAMDAC0[0x00000500/4], 0);\n    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;\n    NVClk  = (N * chip->CrystalFreqKHz / M) >> P;\n    cfg1 = NV_RD32(&chip->PFB[0x00000204/4], 0);\n    sim_data.pix_bpp        = (char)pixelDepth;\n    sim_data.enable_video   = 0;\n    sim_data.enable_mp      = 0;\n    sim_data.memory_width   = (NV_RD32(&chip->PEXTDEV[0x00000000/4], 0) & 0x10) ?\n\t128 : 64;\n    sim_data.mem_latency    = (char)cfg1 & 0x0F;\n    sim_data.mem_aligned    = 1;\n    sim_data.mem_page_miss  = (char)(((cfg1 >> 4) &0x0F) + ((cfg1 >> 31) & 0x01));\n    sim_data.gr_during_vid  = 0;\n    sim_data.pclk_khz       = VClk;\n    sim_data.mclk_khz       = MClk;\n    sim_data.nvclk_khz      = NVClk;\n    nv4CalcArbitration(&fifo_data, &sim_data);\n    if (fifo_data.valid)\n    {\n        int  b = fifo_data.graphics_burst_size >> 4;\n        *burst = 0;\n        while (b >>= 1)\n\t    (*burst)++;\n        *lwm   = fifo_data.graphics_lwm >> 3;\n    }\n}\nstatic void nv10CalcArbitration \n(\n    nv10_fifo_info *fifo,\n    nv10_sim_state *arb\n)\n{\n    int data, pagemiss, width, video_enable, bpp;\n    int nvclks, mclks, pclks, vpagemiss, crtpagemiss;\n    int nvclk_fill;\n    int found, mclk_extra, mclk_loop, cbs, m1;\n    int mclk_freq, pclk_freq, nvclk_freq, mp_enable;\n    int us_m, us_m_min, us_n, us_p, crtc_drain_rate;\n    int vus_m;\n    int vpm_us, us_video, cpm_us, us_crt,clwm;\n    int clwm_rnd_down;\n    int m2us, us_pipe_min, p1clk, p2;\n    int min_mclk_extra;\n    int us_min_mclk_extra;\n\n    fifo->valid = 1;\n    pclk_freq = arb->pclk_khz;  \n    mclk_freq = arb->mclk_khz;\n    nvclk_freq = arb->nvclk_khz;\n    pagemiss = arb->mem_page_miss;\n    width = arb->memory_width/64;\n    video_enable = arb->enable_video;\n    bpp = arb->pix_bpp;\n    mp_enable = arb->enable_mp;\n    clwm = 0;\n\n    cbs = 512;\n\n    pclks = 4;  \n\n    nvclks = 3;  \n    nvclks += 2;  \n\n    mclks  = 1;    \n\n    mclks += 1;    \n    mclks += 5;    \n\n    mclks += 2;     \n    mclks += 2;     \n    mclks += 7;     \n\n     \n    if (arb->memory_type == 0)\n      if (arb->memory_width == 64)  \n        mclks += 4;\n      else\n        mclks += 2;\n    else\n      if (arb->memory_width == 64)  \n        mclks += 2;\n      else\n        mclks += 1;\n\n    if ((!video_enable) && (arb->memory_width == 128))\n    {  \n      mclk_extra = (bpp == 32) ? 31 : 42;  \n      min_mclk_extra = 17;\n    }\n    else\n    {\n      mclk_extra = (bpp == 32) ? 8 : 4;  \n         \n      min_mclk_extra = 18;\n    }\n\n    nvclks += 1;  \n    nvclks += 1;  \n    nvclks += 1;  \n    nvclks += 1;  \n\n    if(mp_enable)\n      mclks+=4;  \n     \n\n    nvclks += 0;\n    pclks += 0;\n    found = 0;\n    while(found != 1) {\n      fifo->valid = 1;\n      found = 1;\n      mclk_loop = mclks+mclk_extra;\n      us_m = mclk_loop *1000*1000 / mclk_freq;  \n      us_m_min = mclks * 1000*1000 / mclk_freq;  \n      us_min_mclk_extra = min_mclk_extra *1000*1000 / mclk_freq;\n      us_n = nvclks*1000*1000 / nvclk_freq; \n      us_p = pclks*1000*1000 / pclk_freq; \n      us_pipe_min = us_m_min + us_n + us_p;\n\n      vus_m = mclk_loop *1000*1000 / mclk_freq;  \n\n      if(video_enable) {\n        crtc_drain_rate = pclk_freq * bpp/8;  \n\n        vpagemiss = 1;  \n        vpagemiss += 1;  \n\n        crtpagemiss = 2;  \n        if(mp_enable)\n            crtpagemiss += 1;  \n\n        vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;\n\n        us_video = vpm_us + vus_m;  \n\n        cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;\n        us_crt =\n          us_video   \n          +cpm_us  \n          +us_m + us_n +us_p  \n          ;\n\n        clwm = us_crt * crtc_drain_rate/(1000*1000);\n        clwm++;  \n      } else {\n        crtc_drain_rate = pclk_freq * bpp/8;  \n\n        crtpagemiss = 1;  \n        crtpagemiss += 1;  \n        if(mp_enable)\n            crtpagemiss += 1;  \n        cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;\n        us_crt =  cpm_us + us_m + us_n + us_p ;\n        clwm = us_crt * crtc_drain_rate/(1000*1000);\n        clwm++;  \n\n   \n           \n          if(width == 1){\n              nvclk_fill = nvclk_freq * 8;\n              if(crtc_drain_rate * 100 >= nvclk_fill * 102)\n                      clwm = 0xfff;  \n\n              else if(crtc_drain_rate * 100  >= nvclk_fill * 98) {\n                  clwm = 1024;\n                  cbs = 512;\n              }\n          }\n      }\n\n\n       \n\n      clwm_rnd_down = ((int)clwm/8)*8;\n      if (clwm_rnd_down < clwm)\n          clwm += 8;\n\n      m1 = clwm + cbs -  1024;  \n      m2us = us_pipe_min + us_min_mclk_extra;\n\n       \n      p1clk = m2us * pclk_freq/(1000*1000); \n      p2 = p1clk * bpp / 8;  \n\n      if((p2 < m1) && (m1 > 0)) {\n          fifo->valid = 0;\n          found = 0;\n          if(min_mclk_extra == 0)   {\n            if(cbs <= 32) {\n              found = 1;  \n            } else {\n              cbs = cbs/2;   \n            }\n          } else {\n            min_mclk_extra--;\n          }\n      } else {\n        if (clwm > 1023){  \n          fifo->valid = 0;\n          found = 0;\n          if(min_mclk_extra == 0)   \n              found = 1;  \n          else \n              min_mclk_extra--;\n        }\n      }\n\n      if(clwm < (1024-cbs+8)) clwm = 1024-cbs+8;\n      data = (int)(clwm);\n       \n      fifo->graphics_lwm = data;   fifo->graphics_burst_size = cbs;\n\n       \n      fifo->video_lwm = 1024;  fifo->video_burst_size = 512;\n    }\n}\nstatic void nv10UpdateArbitrationSettings\n(\n    unsigned      VClk, \n    unsigned      pixelDepth, \n    unsigned     *burst,\n    unsigned     *lwm,\n    RIVA_HW_INST *chip\n)\n{\n    nv10_fifo_info fifo_data;\n    nv10_sim_state sim_data;\n    unsigned int M, N, P, pll, MClk, NVClk, cfg1;\n\n    pll = NV_RD32(&chip->PRAMDAC0[0x00000504/4], 0);\n    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;\n    MClk  = (N * chip->CrystalFreqKHz / M) >> P;\n    pll = NV_RD32(&chip->PRAMDAC0[0x00000500/4], 0);\n    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;\n    NVClk  = (N * chip->CrystalFreqKHz / M) >> P;\n    cfg1 = NV_RD32(&chip->PFB[0x00000204/4], 0);\n    sim_data.pix_bpp        = (char)pixelDepth;\n    sim_data.enable_video   = 0;\n    sim_data.enable_mp      = 0;\n    sim_data.memory_type    = (NV_RD32(&chip->PFB[0x00000200/4], 0) & 0x01) ?\n\t1 : 0;\n    sim_data.memory_width   = (NV_RD32(&chip->PEXTDEV[0x00000000/4], 0) & 0x10) ?\n\t128 : 64;\n    sim_data.mem_latency    = (char)cfg1 & 0x0F;\n    sim_data.mem_aligned    = 1;\n    sim_data.mem_page_miss  = (char)(((cfg1 >> 4) &0x0F) + ((cfg1 >> 31) & 0x01));\n    sim_data.gr_during_vid  = 0;\n    sim_data.pclk_khz       = VClk;\n    sim_data.mclk_khz       = MClk;\n    sim_data.nvclk_khz      = NVClk;\n    nv10CalcArbitration(&fifo_data, &sim_data);\n    if (fifo_data.valid)\n    {\n        int  b = fifo_data.graphics_burst_size >> 4;\n        *burst = 0;\n        while (b >>= 1)\n\t    (*burst)++;\n        *lwm   = fifo_data.graphics_lwm >> 3;\n    }\n}\n\nstatic void nForceUpdateArbitrationSettings\n(\n    unsigned      VClk,\n    unsigned      pixelDepth,\n    unsigned     *burst,\n    unsigned     *lwm,\n    RIVA_HW_INST *chip,\n    struct pci_dev *pdev\n)\n{\n    nv10_fifo_info fifo_data;\n    nv10_sim_state sim_data;\n    unsigned int M, N, P, pll, MClk, NVClk;\n    unsigned int uMClkPostDiv;\n    struct pci_dev *dev;\n    int domain = pci_domain_nr(pdev->bus);\n\n    dev = pci_get_domain_bus_and_slot(domain, 0, 3);\n    pci_read_config_dword(dev, 0x6C, &uMClkPostDiv);\n    pci_dev_put(dev);\n    uMClkPostDiv = (uMClkPostDiv >> 8) & 0xf;\n\n    if(!uMClkPostDiv) uMClkPostDiv = 4;\n    MClk = 400000 / uMClkPostDiv;\n\n    pll = NV_RD32(&chip->PRAMDAC0[0x00000500/4], 0);\n    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;\n    NVClk  = (N * chip->CrystalFreqKHz / M) >> P;\n    sim_data.pix_bpp        = (char)pixelDepth;\n    sim_data.enable_video   = 0;\n    sim_data.enable_mp      = 0;\n\n    dev = pci_get_domain_bus_and_slot(domain, 0, 1);\n    pci_read_config_dword(dev, 0x7C, &sim_data.memory_type);\n    pci_dev_put(dev);\n    sim_data.memory_type    = (sim_data.memory_type >> 12) & 1;\n\n    sim_data.memory_width   = 64;\n    sim_data.mem_latency    = 3;\n    sim_data.mem_aligned    = 1;\n    sim_data.mem_page_miss  = 10;\n    sim_data.gr_during_vid  = 0;\n    sim_data.pclk_khz       = VClk;\n    sim_data.mclk_khz       = MClk;\n    sim_data.nvclk_khz      = NVClk;\n    nv10CalcArbitration(&fifo_data, &sim_data);\n    if (fifo_data.valid)\n    {\n        int  b = fifo_data.graphics_burst_size >> 4;\n        *burst = 0;\n        while (b >>= 1)\n\t    (*burst)++;\n        *lwm   = fifo_data.graphics_lwm >> 3;\n    }\n}\n\n \n\n \nstatic int CalcVClock\n(\n    int           clockIn,\n    int          *clockOut,\n    int          *mOut,\n    int          *nOut,\n    int          *pOut,\n    RIVA_HW_INST *chip\n)\n{\n    unsigned lowM, highM, highP;\n    unsigned DeltaNew, DeltaOld;\n    unsigned VClk, Freq;\n    unsigned M, N, P;\n    \n    DeltaOld = 0xFFFFFFFF;\n\n    VClk     = (unsigned)clockIn;\n    \n    if (chip->CrystalFreqKHz == 13500)\n    {\n        lowM  = 7;\n        highM = 13 - (chip->Architecture == NV_ARCH_03);\n    }\n    else\n    {\n        lowM  = 8;\n        highM = 14 - (chip->Architecture == NV_ARCH_03);\n    }                      \n\n    highP = 4 - (chip->Architecture == NV_ARCH_03);\n    for (P = 0; P <= highP; P ++)\n    {\n        Freq = VClk << P;\n        if ((Freq >= 128000) && (Freq <= chip->MaxVClockFreqKHz))\n        {\n            for (M = lowM; M <= highM; M++)\n            {\n                N    = (VClk << P) * M / chip->CrystalFreqKHz;\n                if(N <= 255) {\n                Freq = (chip->CrystalFreqKHz * N / M) >> P;\n                if (Freq > VClk)\n                    DeltaNew = Freq - VClk;\n                else\n                    DeltaNew = VClk - Freq;\n                if (DeltaNew < DeltaOld)\n                {\n                    *mOut     = M;\n                    *nOut     = N;\n                    *pOut     = P;\n                    *clockOut = Freq;\n                    DeltaOld  = DeltaNew;\n                }\n            }\n        }\n    }\n    }\n\n     \n    return (DeltaOld != 0xFFFFFFFF);\n}\n \nint CalcStateExt\n(\n    RIVA_HW_INST  *chip,\n    RIVA_HW_STATE *state,\n    struct pci_dev *pdev,\n    int            bpp,\n    int            width,\n    int            hDisplaySize,\n    int            height,\n    int            dotClock\n)\n{\n    int pixelDepth;\n    int VClk, m, n, p;\n\n     \n    state->bpp    = bpp;     \n    state->width  = width;\n    state->height = height;\n     \n    pixelDepth = (bpp + 1)/8;\n    if (!CalcVClock(dotClock, &VClk, &m, &n, &p, chip))\n    \treturn -EINVAL;\n\n    switch (chip->Architecture)\n    {\n        case NV_ARCH_03:\n            nv3UpdateArbitrationSettings(VClk, \n                                         pixelDepth * 8, \n                                        &(state->arbitration0),\n                                        &(state->arbitration1),\n                                         chip);\n            state->cursor0  = 0x00;\n            state->cursor1  = 0x78;\n            state->cursor2  = 0x00000000;\n            state->pllsel   = 0x10010100;\n            state->config   = ((width + 31)/32)\n                            | (((pixelDepth > 2) ? 3 : pixelDepth) << 8)\n                            | 0x1000;\n            state->general  = 0x00100100;\n            state->repaint1 = hDisplaySize < 1280 ? 0x06 : 0x02;\n            break;\n        case NV_ARCH_04:\n            nv4UpdateArbitrationSettings(VClk, \n                                         pixelDepth * 8, \n                                        &(state->arbitration0),\n                                        &(state->arbitration1),\n                                         chip);\n            state->cursor0  = 0x00;\n            state->cursor1  = 0xFC;\n            state->cursor2  = 0x00000000;\n            state->pllsel   = 0x10000700;\n            state->config   = 0x00001114;\n            state->general  = bpp == 16 ? 0x00101100 : 0x00100100;\n            state->repaint1 = hDisplaySize < 1280 ? 0x04 : 0x00;\n            break;\n        case NV_ARCH_10:\n        case NV_ARCH_20:\n        case NV_ARCH_30:\n            if((chip->Chipset == NV_CHIP_IGEFORCE2) ||\n               (chip->Chipset == NV_CHIP_0x01F0))\n            {\n                nForceUpdateArbitrationSettings(VClk,\n                                          pixelDepth * 8,\n                                         &(state->arbitration0),\n                                         &(state->arbitration1),\n                                          chip, pdev);\n            } else {\n                nv10UpdateArbitrationSettings(VClk, \n                                          pixelDepth * 8, \n                                         &(state->arbitration0),\n                                         &(state->arbitration1),\n                                          chip);\n            }\n            state->cursor0  = 0x80 | (chip->CursorStart >> 17);\n            state->cursor1  = (chip->CursorStart >> 11) << 2;\n            state->cursor2  = chip->CursorStart >> 24;\n            state->pllsel   = 0x10000700;\n            state->config   = NV_RD32(&chip->PFB[0x00000200/4], 0);\n            state->general  = bpp == 16 ? 0x00101100 : 0x00100100;\n            state->repaint1 = hDisplaySize < 1280 ? 0x04 : 0x00;\n            break;\n    }\n\n      \n      \n    if((bpp != 8) && (chip->Architecture != NV_ARCH_03))\n\t    state->general |= 0x00000030;\n\n    state->vpll     = (p << 16) | (n << 8) | m;\n    state->repaint0 = (((width/8)*pixelDepth) & 0x700) >> 3;\n    state->pixel    = pixelDepth > 2   ? 3    : pixelDepth;\n    state->offset0  =\n    state->offset1  =\n    state->offset2  =\n    state->offset3  = 0;\n    state->pitch0   =\n    state->pitch1   =\n    state->pitch2   =\n    state->pitch3   = pixelDepth * width;\n\n    return 0;\n}\n \n#define LOAD_FIXED_STATE(tbl,dev)                                       \\\n    for (i = 0; i < sizeof(tbl##Table##dev)/8; i++)                 \\\n        NV_WR32(&chip->dev[tbl##Table##dev[i][0]], 0, tbl##Table##dev[i][1])\n#define LOAD_FIXED_STATE_8BPP(tbl,dev)                                  \\\n    for (i = 0; i < sizeof(tbl##Table##dev##_8BPP)/8; i++)            \\\n        NV_WR32(&chip->dev[tbl##Table##dev##_8BPP[i][0]], 0, tbl##Table##dev##_8BPP[i][1])\n#define LOAD_FIXED_STATE_15BPP(tbl,dev)                                 \\\n    for (i = 0; i < sizeof(tbl##Table##dev##_15BPP)/8; i++)           \\\n        NV_WR32(&chip->dev[tbl##Table##dev##_15BPP[i][0]], 0, tbl##Table##dev##_15BPP[i][1])\n#define LOAD_FIXED_STATE_16BPP(tbl,dev)                                 \\\n    for (i = 0; i < sizeof(tbl##Table##dev##_16BPP)/8; i++)           \\\n        NV_WR32(&chip->dev[tbl##Table##dev##_16BPP[i][0]], 0, tbl##Table##dev##_16BPP[i][1])\n#define LOAD_FIXED_STATE_32BPP(tbl,dev)                                 \\\n    for (i = 0; i < sizeof(tbl##Table##dev##_32BPP)/8; i++)           \\\n        NV_WR32(&chip->dev[tbl##Table##dev##_32BPP[i][0]], 0, tbl##Table##dev##_32BPP[i][1])\n\nstatic void UpdateFifoState\n(\n    RIVA_HW_INST  *chip\n)\n{\n    int i;\n\n    switch (chip->Architecture)\n    {\n        case NV_ARCH_04:\n            LOAD_FIXED_STATE(nv4,FIFO);\n            chip->Tri03 = NULL;\n            chip->Tri05 = (RivaTexturedTriangle05 __iomem *)&(chip->FIFO[0x0000E000/4]);\n            break;\n        case NV_ARCH_10:\n        case NV_ARCH_20:\n        case NV_ARCH_30:\n             \n            LOAD_FIXED_STATE(nv10tri05,PGRAPH);\n            LOAD_FIXED_STATE(nv10,FIFO);\n            chip->Tri03 = NULL;\n            chip->Tri05 = (RivaTexturedTriangle05 __iomem *)&(chip->FIFO[0x0000E000/4]);\n            break;\n    }\n}\nstatic void LoadStateExt\n(\n    RIVA_HW_INST  *chip,\n    RIVA_HW_STATE *state\n)\n{\n    int i;\n\n     \n    LOAD_FIXED_STATE(Riva,PMC);\n    LOAD_FIXED_STATE(Riva,PTIMER);\n    switch (chip->Architecture)\n    {\n        case NV_ARCH_03:\n             \n            NV_WR32(chip->PFB, 0x00000200, state->config);\n            LOAD_FIXED_STATE(nv3,PFIFO);\n            LOAD_FIXED_STATE(nv3,PRAMIN);\n            LOAD_FIXED_STATE(nv3,PGRAPH);\n            switch (state->bpp)\n            {\n                case 15:\n                case 16:\n                    LOAD_FIXED_STATE_15BPP(nv3,PRAMIN);\n                    LOAD_FIXED_STATE_15BPP(nv3,PGRAPH);\n                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);\n                    break;\n                case 24:\n                case 32:\n                    LOAD_FIXED_STATE_32BPP(nv3,PRAMIN);\n                    LOAD_FIXED_STATE_32BPP(nv3,PGRAPH);\n                    chip->Tri03 = NULL;\n                    break;\n                case 8:\n                default:\n                    LOAD_FIXED_STATE_8BPP(nv3,PRAMIN);\n                    LOAD_FIXED_STATE_8BPP(nv3,PGRAPH);\n                    chip->Tri03 = NULL;\n                    break;\n            }\n            for (i = 0x00000; i < 0x00800; i++)\n                NV_WR32(&chip->PRAMIN[0x00000502 + i], 0, (i << 12) | 0x03);\n            NV_WR32(chip->PGRAPH, 0x00000630, state->offset0);\n            NV_WR32(chip->PGRAPH, 0x00000634, state->offset1);\n            NV_WR32(chip->PGRAPH, 0x00000638, state->offset2);\n            NV_WR32(chip->PGRAPH, 0x0000063C, state->offset3);\n            NV_WR32(chip->PGRAPH, 0x00000650, state->pitch0);\n            NV_WR32(chip->PGRAPH, 0x00000654, state->pitch1);\n            NV_WR32(chip->PGRAPH, 0x00000658, state->pitch2);\n            NV_WR32(chip->PGRAPH, 0x0000065C, state->pitch3);\n            break;\n        case NV_ARCH_04:\n             \n            NV_WR32(chip->PFB, 0x00000200, state->config);\n            LOAD_FIXED_STATE(nv4,PFIFO);\n            LOAD_FIXED_STATE(nv4,PRAMIN);\n            LOAD_FIXED_STATE(nv4,PGRAPH);\n            switch (state->bpp)\n            {\n                case 15:\n                    LOAD_FIXED_STATE_15BPP(nv4,PRAMIN);\n                    LOAD_FIXED_STATE_15BPP(nv4,PGRAPH);\n                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);\n                    break;\n                case 16:\n                    LOAD_FIXED_STATE_16BPP(nv4,PRAMIN);\n                    LOAD_FIXED_STATE_16BPP(nv4,PGRAPH);\n                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);\n                    break;\n                case 24:\n                case 32:\n                    LOAD_FIXED_STATE_32BPP(nv4,PRAMIN);\n                    LOAD_FIXED_STATE_32BPP(nv4,PGRAPH);\n                    chip->Tri03 = NULL;\n                    break;\n                case 8:\n                default:\n                    LOAD_FIXED_STATE_8BPP(nv4,PRAMIN);\n                    LOAD_FIXED_STATE_8BPP(nv4,PGRAPH);\n                    chip->Tri03 = NULL;\n                    break;\n            }\n            NV_WR32(chip->PGRAPH, 0x00000640, state->offset0);\n            NV_WR32(chip->PGRAPH, 0x00000644, state->offset1);\n            NV_WR32(chip->PGRAPH, 0x00000648, state->offset2);\n            NV_WR32(chip->PGRAPH, 0x0000064C, state->offset3);\n            NV_WR32(chip->PGRAPH, 0x00000670, state->pitch0);\n            NV_WR32(chip->PGRAPH, 0x00000674, state->pitch1);\n            NV_WR32(chip->PGRAPH, 0x00000678, state->pitch2);\n            NV_WR32(chip->PGRAPH, 0x0000067C, state->pitch3);\n            break;\n        case NV_ARCH_10:\n        case NV_ARCH_20:\n        case NV_ARCH_30:\n            if(chip->twoHeads) {\n               VGA_WR08(chip->PCIO, 0x03D4, 0x44);\n               VGA_WR08(chip->PCIO, 0x03D5, state->crtcOwner);\n               chip->LockUnlock(chip, 0);\n            }\n\n            LOAD_FIXED_STATE(nv10,PFIFO);\n            LOAD_FIXED_STATE(nv10,PRAMIN);\n            LOAD_FIXED_STATE(nv10,PGRAPH);\n            switch (state->bpp)\n            {\n                case 15:\n                    LOAD_FIXED_STATE_15BPP(nv10,PRAMIN);\n                    LOAD_FIXED_STATE_15BPP(nv10,PGRAPH);\n                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);\n                    break;\n                case 16:\n                    LOAD_FIXED_STATE_16BPP(nv10,PRAMIN);\n                    LOAD_FIXED_STATE_16BPP(nv10,PGRAPH);\n                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);\n                    break;\n                case 24:\n                case 32:\n                    LOAD_FIXED_STATE_32BPP(nv10,PRAMIN);\n                    LOAD_FIXED_STATE_32BPP(nv10,PGRAPH);\n                    chip->Tri03 = NULL;\n                    break;\n                case 8:\n                default:\n                    LOAD_FIXED_STATE_8BPP(nv10,PRAMIN);\n                    LOAD_FIXED_STATE_8BPP(nv10,PGRAPH);\n                    chip->Tri03 = NULL;\n                    break;\n            }\n\n            if(chip->Architecture == NV_ARCH_10) {\n                NV_WR32(chip->PGRAPH, 0x00000640, state->offset0);\n                NV_WR32(chip->PGRAPH, 0x00000644, state->offset1);\n                NV_WR32(chip->PGRAPH, 0x00000648, state->offset2);\n                NV_WR32(chip->PGRAPH, 0x0000064C, state->offset3);\n                NV_WR32(chip->PGRAPH, 0x00000670, state->pitch0);\n                NV_WR32(chip->PGRAPH, 0x00000674, state->pitch1);\n                NV_WR32(chip->PGRAPH, 0x00000678, state->pitch2);\n                NV_WR32(chip->PGRAPH, 0x0000067C, state->pitch3);\n                NV_WR32(chip->PGRAPH, 0x00000680, state->pitch3);\n        } else {\n        NV_WR32(chip->PGRAPH, 0x00000820, state->offset0);\n        NV_WR32(chip->PGRAPH, 0x00000824, state->offset1);\n        NV_WR32(chip->PGRAPH, 0x00000828, state->offset2);\n        NV_WR32(chip->PGRAPH, 0x0000082C, state->offset3);\n        NV_WR32(chip->PGRAPH, 0x00000850, state->pitch0);\n        NV_WR32(chip->PGRAPH, 0x00000854, state->pitch1);\n        NV_WR32(chip->PGRAPH, 0x00000858, state->pitch2);\n        NV_WR32(chip->PGRAPH, 0x0000085C, state->pitch3);\n        NV_WR32(chip->PGRAPH, 0x00000860, state->pitch3);\n        NV_WR32(chip->PGRAPH, 0x00000864, state->pitch3);\n        NV_WR32(chip->PGRAPH, 0x000009A4, NV_RD32(chip->PFB, 0x00000200));\n        NV_WR32(chip->PGRAPH, 0x000009A8, NV_RD32(chip->PFB, 0x00000204));\n        }\n            if(chip->twoHeads) {\n               NV_WR32(chip->PCRTC0, 0x00000860, state->head);\n               NV_WR32(chip->PCRTC0, 0x00002860, state->head2);\n            }\n            NV_WR32(chip->PRAMDAC, 0x00000404, NV_RD32(chip->PRAMDAC, 0x00000404) | (1 << 25));\n\n            NV_WR32(chip->PMC, 0x00008704, 1);\n            NV_WR32(chip->PMC, 0x00008140, 0);\n            NV_WR32(chip->PMC, 0x00008920, 0);\n            NV_WR32(chip->PMC, 0x00008924, 0);\n            NV_WR32(chip->PMC, 0x00008908, 0x01ffffff);\n            NV_WR32(chip->PMC, 0x0000890C, 0x01ffffff);\n            NV_WR32(chip->PMC, 0x00001588, 0);\n\n            NV_WR32(chip->PFB, 0x00000240, 0);\n            NV_WR32(chip->PFB, 0x00000250, 0);\n            NV_WR32(chip->PFB, 0x00000260, 0);\n            NV_WR32(chip->PFB, 0x00000270, 0);\n            NV_WR32(chip->PFB, 0x00000280, 0);\n            NV_WR32(chip->PFB, 0x00000290, 0);\n            NV_WR32(chip->PFB, 0x000002A0, 0);\n            NV_WR32(chip->PFB, 0x000002B0, 0);\n\n            NV_WR32(chip->PGRAPH, 0x00000B00, NV_RD32(chip->PFB, 0x00000240));\n            NV_WR32(chip->PGRAPH, 0x00000B04, NV_RD32(chip->PFB, 0x00000244));\n            NV_WR32(chip->PGRAPH, 0x00000B08, NV_RD32(chip->PFB, 0x00000248));\n            NV_WR32(chip->PGRAPH, 0x00000B0C, NV_RD32(chip->PFB, 0x0000024C));\n            NV_WR32(chip->PGRAPH, 0x00000B10, NV_RD32(chip->PFB, 0x00000250));\n            NV_WR32(chip->PGRAPH, 0x00000B14, NV_RD32(chip->PFB, 0x00000254));\n            NV_WR32(chip->PGRAPH, 0x00000B18, NV_RD32(chip->PFB, 0x00000258));\n            NV_WR32(chip->PGRAPH, 0x00000B1C, NV_RD32(chip->PFB, 0x0000025C));\n            NV_WR32(chip->PGRAPH, 0x00000B20, NV_RD32(chip->PFB, 0x00000260));\n            NV_WR32(chip->PGRAPH, 0x00000B24, NV_RD32(chip->PFB, 0x00000264));\n            NV_WR32(chip->PGRAPH, 0x00000B28, NV_RD32(chip->PFB, 0x00000268));\n            NV_WR32(chip->PGRAPH, 0x00000B2C, NV_RD32(chip->PFB, 0x0000026C));\n            NV_WR32(chip->PGRAPH, 0x00000B30, NV_RD32(chip->PFB, 0x00000270));\n            NV_WR32(chip->PGRAPH, 0x00000B34, NV_RD32(chip->PFB, 0x00000274));\n            NV_WR32(chip->PGRAPH, 0x00000B38, NV_RD32(chip->PFB, 0x00000278));\n            NV_WR32(chip->PGRAPH, 0x00000B3C, NV_RD32(chip->PFB, 0x0000027C));\n            NV_WR32(chip->PGRAPH, 0x00000B40, NV_RD32(chip->PFB, 0x00000280));\n            NV_WR32(chip->PGRAPH, 0x00000B44, NV_RD32(chip->PFB, 0x00000284));\n            NV_WR32(chip->PGRAPH, 0x00000B48, NV_RD32(chip->PFB, 0x00000288));\n            NV_WR32(chip->PGRAPH, 0x00000B4C, NV_RD32(chip->PFB, 0x0000028C));\n            NV_WR32(chip->PGRAPH, 0x00000B50, NV_RD32(chip->PFB, 0x00000290));\n            NV_WR32(chip->PGRAPH, 0x00000B54, NV_RD32(chip->PFB, 0x00000294));\n            NV_WR32(chip->PGRAPH, 0x00000B58, NV_RD32(chip->PFB, 0x00000298));\n            NV_WR32(chip->PGRAPH, 0x00000B5C, NV_RD32(chip->PFB, 0x0000029C));\n            NV_WR32(chip->PGRAPH, 0x00000B60, NV_RD32(chip->PFB, 0x000002A0));\n            NV_WR32(chip->PGRAPH, 0x00000B64, NV_RD32(chip->PFB, 0x000002A4));\n            NV_WR32(chip->PGRAPH, 0x00000B68, NV_RD32(chip->PFB, 0x000002A8));\n            NV_WR32(chip->PGRAPH, 0x00000B6C, NV_RD32(chip->PFB, 0x000002AC));\n            NV_WR32(chip->PGRAPH, 0x00000B70, NV_RD32(chip->PFB, 0x000002B0));\n            NV_WR32(chip->PGRAPH, 0x00000B74, NV_RD32(chip->PFB, 0x000002B4));\n            NV_WR32(chip->PGRAPH, 0x00000B78, NV_RD32(chip->PFB, 0x000002B8));\n            NV_WR32(chip->PGRAPH, 0x00000B7C, NV_RD32(chip->PFB, 0x000002BC));\n            NV_WR32(chip->PGRAPH, 0x00000F40, 0x10000000);\n            NV_WR32(chip->PGRAPH, 0x00000F44, 0x00000000);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000040);\n            NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000008);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000200);\n            for (i = 0; i < (3*16); i++)\n                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000040);\n            NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000800);\n            for (i = 0; i < (16*16); i++)\n                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\n            NV_WR32(chip->PGRAPH, 0x00000F40, 0x30000000);\n            NV_WR32(chip->PGRAPH, 0x00000F44, 0x00000004);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00006400);\n            for (i = 0; i < (59*4); i++)\n                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00006800);\n            for (i = 0; i < (47*4); i++)\n                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00006C00);\n            for (i = 0; i < (3*4); i++)\n                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00007000);\n            for (i = 0; i < (19*4); i++)\n                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00007400);\n            for (i = 0; i < (12*4); i++)\n                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00007800);\n            for (i = 0; i < (12*4); i++)\n                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00004400);\n            for (i = 0; i < (8*4); i++)\n                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000000);\n            for (i = 0; i < 16; i++)\n                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\n            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000040);\n            for (i = 0; i < 4; i++)\n                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\n\n            NV_WR32(chip->PCRTC, 0x00000810, state->cursorConfig);\n\n            if(chip->flatPanel) {\n               if((chip->Chipset & 0x0ff0) == 0x0110) {\n                   NV_WR32(chip->PRAMDAC, 0x0528, state->dither);\n               } else \n               if((chip->Chipset & 0x0ff0) >= 0x0170) {\n                   NV_WR32(chip->PRAMDAC, 0x083C, state->dither);\n               }\n            \n               VGA_WR08(chip->PCIO, 0x03D4, 0x53);\n               VGA_WR08(chip->PCIO, 0x03D5, 0);\n               VGA_WR08(chip->PCIO, 0x03D4, 0x54);\n               VGA_WR08(chip->PCIO, 0x03D5, 0);\n               VGA_WR08(chip->PCIO, 0x03D4, 0x21);\n               VGA_WR08(chip->PCIO, 0x03D5, 0xfa);\n            }\n\n            VGA_WR08(chip->PCIO, 0x03D4, 0x41);\n            VGA_WR08(chip->PCIO, 0x03D5, state->extra);\n    }\n    LOAD_FIXED_STATE(Riva,FIFO);\n    UpdateFifoState(chip);\n     \n    VGA_WR08(chip->PCIO, 0x03D4, 0x19);\n    VGA_WR08(chip->PCIO, 0x03D5, state->repaint0);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x1A);\n    VGA_WR08(chip->PCIO, 0x03D5, state->repaint1);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x25);\n    VGA_WR08(chip->PCIO, 0x03D5, state->screen);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x28);\n    VGA_WR08(chip->PCIO, 0x03D5, state->pixel);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x2D);\n    VGA_WR08(chip->PCIO, 0x03D5, state->horiz);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x1B);\n    VGA_WR08(chip->PCIO, 0x03D5, state->arbitration0);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x20);\n    VGA_WR08(chip->PCIO, 0x03D5, state->arbitration1);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x30);\n    VGA_WR08(chip->PCIO, 0x03D5, state->cursor0);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x31);\n    VGA_WR08(chip->PCIO, 0x03D5, state->cursor1);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x2F);\n    VGA_WR08(chip->PCIO, 0x03D5, state->cursor2);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x39);\n    VGA_WR08(chip->PCIO, 0x03D5, state->interlace);\n\n    if(!chip->flatPanel) {\n       NV_WR32(chip->PRAMDAC0, 0x00000508, state->vpll);\n       NV_WR32(chip->PRAMDAC0, 0x0000050C, state->pllsel);\n       if(chip->twoHeads)\n          NV_WR32(chip->PRAMDAC0, 0x00000520, state->vpll2);\n    }  else {\n       NV_WR32(chip->PRAMDAC, 0x00000848 , state->scale);\n    }  \n    NV_WR32(chip->PRAMDAC, 0x00000600 , state->general);\n\n     \n    NV_WR32(chip->PCRTC, 0x00000140, 0);\n    NV_WR32(chip->PCRTC, 0x00000100, chip->VBlankBit);\n         \n    NV_WR32(chip->PMC, 0x00000140, chip->EnableIRQ & 0x01);\n     \n    chip->CurrentState = state;\n     \n    chip->FifoFreeCount  = 0;\n     \n    chip->FifoEmptyCount = NV_RD32(&chip->Rop->FifoFree, 0);\n}\nstatic void UnloadStateExt\n(\n    RIVA_HW_INST  *chip,\n    RIVA_HW_STATE *state\n)\n{\n     \n    VGA_WR08(chip->PCIO, 0x03D4, 0x19);\n    state->repaint0     = VGA_RD08(chip->PCIO, 0x03D5);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x1A);\n    state->repaint1     = VGA_RD08(chip->PCIO, 0x03D5);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x25);\n    state->screen       = VGA_RD08(chip->PCIO, 0x03D5);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x28);\n    state->pixel        = VGA_RD08(chip->PCIO, 0x03D5);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x2D);\n    state->horiz        = VGA_RD08(chip->PCIO, 0x03D5);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x1B);\n    state->arbitration0 = VGA_RD08(chip->PCIO, 0x03D5);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x20);\n    state->arbitration1 = VGA_RD08(chip->PCIO, 0x03D5);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x30);\n    state->cursor0      = VGA_RD08(chip->PCIO, 0x03D5);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x31);\n    state->cursor1      = VGA_RD08(chip->PCIO, 0x03D5);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x2F);\n    state->cursor2      = VGA_RD08(chip->PCIO, 0x03D5);\n    VGA_WR08(chip->PCIO, 0x03D4, 0x39);\n    state->interlace    = VGA_RD08(chip->PCIO, 0x03D5);\n    state->vpll         = NV_RD32(chip->PRAMDAC0, 0x00000508);\n    state->vpll2        = NV_RD32(chip->PRAMDAC0, 0x00000520);\n    state->pllsel       = NV_RD32(chip->PRAMDAC0, 0x0000050C);\n    state->general      = NV_RD32(chip->PRAMDAC, 0x00000600);\n    state->scale        = NV_RD32(chip->PRAMDAC, 0x00000848);\n    state->config       = NV_RD32(chip->PFB, 0x00000200);\n    switch (chip->Architecture)\n    {\n        case NV_ARCH_03:\n            state->offset0  = NV_RD32(chip->PGRAPH, 0x00000630);\n            state->offset1  = NV_RD32(chip->PGRAPH, 0x00000634);\n            state->offset2  = NV_RD32(chip->PGRAPH, 0x00000638);\n            state->offset3  = NV_RD32(chip->PGRAPH, 0x0000063C);\n            state->pitch0   = NV_RD32(chip->PGRAPH, 0x00000650);\n            state->pitch1   = NV_RD32(chip->PGRAPH, 0x00000654);\n            state->pitch2   = NV_RD32(chip->PGRAPH, 0x00000658);\n            state->pitch3   = NV_RD32(chip->PGRAPH, 0x0000065C);\n            break;\n        case NV_ARCH_04:\n            state->offset0  = NV_RD32(chip->PGRAPH, 0x00000640);\n            state->offset1  = NV_RD32(chip->PGRAPH, 0x00000644);\n            state->offset2  = NV_RD32(chip->PGRAPH, 0x00000648);\n            state->offset3  = NV_RD32(chip->PGRAPH, 0x0000064C);\n            state->pitch0   = NV_RD32(chip->PGRAPH, 0x00000670);\n            state->pitch1   = NV_RD32(chip->PGRAPH, 0x00000674);\n            state->pitch2   = NV_RD32(chip->PGRAPH, 0x00000678);\n            state->pitch3   = NV_RD32(chip->PGRAPH, 0x0000067C);\n            break;\n        case NV_ARCH_10:\n        case NV_ARCH_20:\n        case NV_ARCH_30:\n            state->offset0  = NV_RD32(chip->PGRAPH, 0x00000640);\n            state->offset1  = NV_RD32(chip->PGRAPH, 0x00000644);\n            state->offset2  = NV_RD32(chip->PGRAPH, 0x00000648);\n            state->offset3  = NV_RD32(chip->PGRAPH, 0x0000064C);\n            state->pitch0   = NV_RD32(chip->PGRAPH, 0x00000670);\n            state->pitch1   = NV_RD32(chip->PGRAPH, 0x00000674);\n            state->pitch2   = NV_RD32(chip->PGRAPH, 0x00000678);\n            state->pitch3   = NV_RD32(chip->PGRAPH, 0x0000067C);\n            if(chip->twoHeads) {\n               state->head     = NV_RD32(chip->PCRTC0, 0x00000860);\n               state->head2    = NV_RD32(chip->PCRTC0, 0x00002860);\n               VGA_WR08(chip->PCIO, 0x03D4, 0x44);\n               state->crtcOwner = VGA_RD08(chip->PCIO, 0x03D5);\n            }\n            VGA_WR08(chip->PCIO, 0x03D4, 0x41);\n            state->extra = VGA_RD08(chip->PCIO, 0x03D5);\n            state->cursorConfig = NV_RD32(chip->PCRTC, 0x00000810);\n\n            if((chip->Chipset & 0x0ff0) == 0x0110) {\n                state->dither = NV_RD32(chip->PRAMDAC, 0x0528);\n            } else \n            if((chip->Chipset & 0x0ff0) >= 0x0170) {\n                state->dither = NV_RD32(chip->PRAMDAC, 0x083C);\n            }\n            break;\n    }\n}\nstatic void SetStartAddress\n(\n    RIVA_HW_INST *chip,\n    unsigned      start\n)\n{\n    NV_WR32(chip->PCRTC, 0x800, start);\n}\n\nstatic void SetStartAddress3\n(\n    RIVA_HW_INST *chip,\n    unsigned      start\n)\n{\n    int offset = start >> 2;\n    int pan    = (start & 3) << 1;\n    unsigned char tmp;\n\n     \n    chip->LockUnlock(chip, 0);\n     \n    VGA_WR08(chip->PCIO, 0x3D4, 0x0D); VGA_WR08(chip->PCIO, 0x3D5, offset);\n    offset >>= 8;\n    VGA_WR08(chip->PCIO, 0x3D4, 0x0C); VGA_WR08(chip->PCIO, 0x3D5, offset);\n    offset >>= 8;\n    VGA_WR08(chip->PCIO, 0x3D4, 0x19); tmp = VGA_RD08(chip->PCIO, 0x3D5);\n    VGA_WR08(chip->PCIO, 0x3D5, (offset & 0x01F) | (tmp & ~0x1F));\n    VGA_WR08(chip->PCIO, 0x3D4, 0x2D); tmp = VGA_RD08(chip->PCIO, 0x3D5);\n    VGA_WR08(chip->PCIO, 0x3D5, (offset & 0x60) | (tmp & ~0x60));\n     \n    offset = VGA_RD08(chip->PCIO, chip->IO + 0x0A);\n    VGA_WR08(chip->PCIO, 0x3C0, 0x13);\n    VGA_WR08(chip->PCIO, 0x3C0, pan);\n}\nstatic void nv3SetSurfaces2D\n(\n    RIVA_HW_INST *chip,\n    unsigned     surf0,\n    unsigned     surf1\n)\n{\n    RivaSurface __iomem *Surface =\n\t(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);\n\n    RIVA_FIFO_FREE(*chip,Tri03,5);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000003);\n    NV_WR32(&Surface->Offset, 0, surf0);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000004);\n    NV_WR32(&Surface->Offset, 0, surf1);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000013);\n}\nstatic void nv4SetSurfaces2D\n(\n    RIVA_HW_INST *chip,\n    unsigned     surf0,\n    unsigned     surf1\n)\n{\n    RivaSurface __iomem *Surface =\n\t(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);\n\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000003);\n    NV_WR32(&Surface->Offset, 0, surf0);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000004);\n    NV_WR32(&Surface->Offset, 0, surf1);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);\n}\nstatic void nv10SetSurfaces2D\n(\n    RIVA_HW_INST *chip,\n    unsigned     surf0,\n    unsigned     surf1\n)\n{\n    RivaSurface __iomem *Surface =\n\t(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);\n\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000003);\n    NV_WR32(&Surface->Offset, 0, surf0);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000004);\n    NV_WR32(&Surface->Offset, 0, surf1);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);\n}\nstatic void nv3SetSurfaces3D\n(\n    RIVA_HW_INST *chip,\n    unsigned     surf0,\n    unsigned     surf1\n)\n{\n    RivaSurface __iomem *Surface =\n\t(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);\n\n    RIVA_FIFO_FREE(*chip,Tri03,5);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000005);\n    NV_WR32(&Surface->Offset, 0, surf0);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000006);\n    NV_WR32(&Surface->Offset, 0, surf1);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000013);\n}\nstatic void nv4SetSurfaces3D\n(\n    RIVA_HW_INST *chip,\n    unsigned     surf0,\n    unsigned     surf1\n)\n{\n    RivaSurface __iomem *Surface =\n\t(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);\n\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000005);\n    NV_WR32(&Surface->Offset, 0, surf0);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000006);\n    NV_WR32(&Surface->Offset, 0, surf1);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);\n}\nstatic void nv10SetSurfaces3D\n(\n    RIVA_HW_INST *chip,\n    unsigned     surf0,\n    unsigned     surf1\n)\n{\n    RivaSurface3D __iomem *Surfaces3D =\n\t(RivaSurface3D __iomem *)&(chip->FIFO[0x0000E000/4]);\n\n    RIVA_FIFO_FREE(*chip,Tri03,4);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000007);\n    NV_WR32(&Surfaces3D->RenderBufferOffset, 0, surf0);\n    NV_WR32(&Surfaces3D->ZBufferOffset, 0, surf1);\n    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);\n}\n\n \n\nstatic void nv3GetConfig\n(\n    RIVA_HW_INST *chip\n)\n{\n     \n    if (NV_RD32(&chip->PFB[0x00000000/4], 0) & 0x00000020)\n    {\n        if (((NV_RD32(chip->PMC, 0x00000000) & 0xF0) == 0x20)\n         && ((NV_RD32(chip->PMC, 0x00000000) & 0x0F) >= 0x02))\n        {        \n             \n            chip->RamBandwidthKBytesPerSec = 800000;\n            switch (NV_RD32(chip->PFB, 0x00000000) & 0x03)\n            {\n                case 2:\n                    chip->RamAmountKBytes = 1024 * 4;\n                    break;\n                case 1:\n                    chip->RamAmountKBytes = 1024 * 2;\n                    break;\n                default:\n                    chip->RamAmountKBytes = 1024 * 8;\n                    break;\n            }\n        }            \n        else            \n        {\n            chip->RamBandwidthKBytesPerSec = 1000000;\n            chip->RamAmountKBytes          = 1024 * 8;\n        }            \n    }\n    else\n    {\n         \n        chip->RamBandwidthKBytesPerSec = 1000000;\n        switch (NV_RD32(chip->PFB, 0x00000000) & 0x00000003)\n        {\n            case 0:\n                chip->RamAmountKBytes = 1024 * 8;\n                break;\n            case 2:\n                chip->RamAmountKBytes = 1024 * 4;\n                break;\n            default:\n                chip->RamAmountKBytes = 1024 * 2;\n                break;\n        }\n    }        \n    chip->CrystalFreqKHz   = (NV_RD32(chip->PEXTDEV, 0x00000000) & 0x00000040) ? 14318 : 13500;\n    chip->CURSOR           = &(chip->PRAMIN[0x00008000/4 - 0x0800/4]);\n    chip->VBlankBit        = 0x00000100;\n    chip->MaxVClockFreqKHz = 256000;\n     \n    chip->Busy            = nv3Busy;\n    chip->ShowHideCursor  = ShowHideCursor;\n    chip->LoadStateExt    = LoadStateExt;\n    chip->UnloadStateExt  = UnloadStateExt;\n    chip->SetStartAddress = SetStartAddress3;\n    chip->SetSurfaces2D   = nv3SetSurfaces2D;\n    chip->SetSurfaces3D   = nv3SetSurfaces3D;\n    chip->LockUnlock      = nv3LockUnlock;\n}\nstatic void nv4GetConfig\n(\n    RIVA_HW_INST *chip\n)\n{\n     \n    if (NV_RD32(chip->PFB, 0x00000000) & 0x00000100)\n    {\n        chip->RamAmountKBytes = ((NV_RD32(chip->PFB, 0x00000000) >> 12) & 0x0F) * 1024 * 2\n                              + 1024 * 2;\n    }\n    else\n    {\n        switch (NV_RD32(chip->PFB, 0x00000000) & 0x00000003)\n        {\n            case 0:\n                chip->RamAmountKBytes = 1024 * 32;\n                break;\n            case 1:\n                chip->RamAmountKBytes = 1024 * 4;\n                break;\n            case 2:\n                chip->RamAmountKBytes = 1024 * 8;\n                break;\n            case 3:\n            default:\n                chip->RamAmountKBytes = 1024 * 16;\n                break;\n        }\n    }\n    switch ((NV_RD32(chip->PFB, 0x00000000) >> 3) & 0x00000003)\n    {\n        case 3:\n            chip->RamBandwidthKBytesPerSec = 800000;\n            break;\n        default:\n            chip->RamBandwidthKBytesPerSec = 1000000;\n            break;\n    }\n    chip->CrystalFreqKHz   = (NV_RD32(chip->PEXTDEV, 0x00000000) & 0x00000040) ? 14318 : 13500;\n    chip->CURSOR           = &(chip->PRAMIN[0x00010000/4 - 0x0800/4]);\n    chip->VBlankBit        = 0x00000001;\n    chip->MaxVClockFreqKHz = 350000;\n     \n    chip->Busy            = nv4Busy;\n    chip->ShowHideCursor  = ShowHideCursor;\n    chip->LoadStateExt    = LoadStateExt;\n    chip->UnloadStateExt  = UnloadStateExt;\n    chip->SetStartAddress = SetStartAddress;\n    chip->SetSurfaces2D   = nv4SetSurfaces2D;\n    chip->SetSurfaces3D   = nv4SetSurfaces3D;\n    chip->LockUnlock      = nv4LockUnlock;\n}\nstatic void nv10GetConfig\n(\n    RIVA_HW_INST *chip,\n    struct pci_dev *pdev,\n    unsigned int chipset\n)\n{\n    struct pci_dev* dev;\n    int domain = pci_domain_nr(pdev->bus);\n    u32 amt;\n\n#ifdef __BIG_ENDIAN\n     \n    if(!(NV_RD32(chip->PMC, 0x00000004) & 0x01000001))\n    \tNV_WR32(chip->PMC, 0x00000004, 0x01000001);\n#endif\n\n     \n    if(chipset == NV_CHIP_IGEFORCE2) {\n        dev = pci_get_domain_bus_and_slot(domain, 0, 1);\n        pci_read_config_dword(dev, 0x7C, &amt);\n        pci_dev_put(dev);\n        chip->RamAmountKBytes = (((amt >> 6) & 31) + 1) * 1024;\n    } else if(chipset == NV_CHIP_0x01F0) {\n        dev = pci_get_domain_bus_and_slot(domain, 0, 1);\n        pci_read_config_dword(dev, 0x84, &amt);\n        pci_dev_put(dev);\n        chip->RamAmountKBytes = (((amt >> 4) & 127) + 1) * 1024;\n    } else {\n        switch ((NV_RD32(chip->PFB, 0x0000020C) >> 20) & 0x000000FF)\n        {\n            case 0x02:\n                chip->RamAmountKBytes = 1024 * 2;\n                break;\n            case 0x04:\n                chip->RamAmountKBytes = 1024 * 4;\n                break;\n            case 0x08:\n                chip->RamAmountKBytes = 1024 * 8;\n                break;\n            case 0x10:\n                chip->RamAmountKBytes = 1024 * 16;\n                break;\n            case 0x20:\n                chip->RamAmountKBytes = 1024 * 32;\n                break;\n            case 0x40:\n                chip->RamAmountKBytes = 1024 * 64;\n                break;\n            case 0x80:\n                chip->RamAmountKBytes = 1024 * 128;\n                break;\n            default:\n                chip->RamAmountKBytes = 1024 * 16;\n                break;\n        }\n    }\n    switch ((NV_RD32(chip->PFB, 0x00000000) >> 3) & 0x00000003)\n    {\n        case 3:\n            chip->RamBandwidthKBytesPerSec = 800000;\n            break;\n        default:\n            chip->RamBandwidthKBytesPerSec = 1000000;\n            break;\n    }\n    chip->CrystalFreqKHz = (NV_RD32(chip->PEXTDEV, 0x0000) & (1 << 6)) ?\n\t14318 : 13500;\n\n    switch (chipset & 0x0ff0) {\n    case 0x0170:\n    case 0x0180:\n    case 0x01F0:\n    case 0x0250:\n    case 0x0280:\n    case 0x0300:\n    case 0x0310:\n    case 0x0320:\n    case 0x0330:\n    case 0x0340:\n       if(NV_RD32(chip->PEXTDEV, 0x0000) & (1 << 22))\n           chip->CrystalFreqKHz = 27000;\n       break;\n    default:\n       break;\n    }\n\n    chip->CursorStart      = (chip->RamAmountKBytes - 128) * 1024;\n    chip->CURSOR           = NULL;   \n    chip->VBlankBit        = 0x00000001;\n    chip->MaxVClockFreqKHz = 350000;\n     \n    chip->Busy            = nv10Busy;\n    chip->ShowHideCursor  = ShowHideCursor;\n    chip->LoadStateExt    = LoadStateExt;\n    chip->UnloadStateExt  = UnloadStateExt;\n    chip->SetStartAddress = SetStartAddress;\n    chip->SetSurfaces2D   = nv10SetSurfaces2D;\n    chip->SetSurfaces3D   = nv10SetSurfaces3D;\n    chip->LockUnlock      = nv4LockUnlock;\n\n    switch(chipset & 0x0ff0) {\n    case 0x0110:\n    case 0x0170:\n    case 0x0180:\n    case 0x01F0:\n    case 0x0250:\n    case 0x0280:\n    case 0x0300:\n    case 0x0310:\n    case 0x0320:\n    case 0x0330:\n    case 0x0340:\n        chip->twoHeads = TRUE;\n        break;\n    default:\n        chip->twoHeads = FALSE;\n        break;\n    }\n}\nint RivaGetConfig\n(\n    RIVA_HW_INST *chip,\n    struct pci_dev *pdev,\n    unsigned int chipset\n)\n{\n     \n    chip->Version = RIVA_SW_VERSION;\n     \n    switch (chip->Architecture)\n    {\n        case NV_ARCH_03:\n            nv3GetConfig(chip);\n            break;\n        case NV_ARCH_04:\n            nv4GetConfig(chip);\n            break;\n        case NV_ARCH_10:\n        case NV_ARCH_20:\n        case NV_ARCH_30:\n            nv10GetConfig(chip, pdev, chipset);\n            break;\n        default:\n            return (-1);\n    }\n    chip->Chipset = chipset;\n     \n    chip->Rop    = (RivaRop __iomem         *)&(chip->FIFO[0x00000000/4]);\n    chip->Clip   = (RivaClip __iomem        *)&(chip->FIFO[0x00002000/4]);\n    chip->Patt   = (RivaPattern __iomem     *)&(chip->FIFO[0x00004000/4]);\n    chip->Pixmap = (RivaPixmap __iomem      *)&(chip->FIFO[0x00006000/4]);\n    chip->Blt    = (RivaScreenBlt __iomem   *)&(chip->FIFO[0x00008000/4]);\n    chip->Bitmap = (RivaBitmap __iomem      *)&(chip->FIFO[0x0000A000/4]);\n    chip->Line   = (RivaLine __iomem        *)&(chip->FIFO[0x0000C000/4]);\n    chip->Tri03  = (RivaTexturedTriangle03 __iomem *)&(chip->FIFO[0x0000E000/4]);\n    return (0);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}