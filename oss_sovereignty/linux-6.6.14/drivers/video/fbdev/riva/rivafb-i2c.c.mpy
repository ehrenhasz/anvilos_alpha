{
  "module_name": "rivafb-i2c.c",
  "hash_id": "8c7a6b31283c06537ff254ea02fc6f3d3f04606cfdab524fe9903ce61179316c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/riva/rivafb-i2c.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/fb.h>\n#include <linux/jiffies.h>\n\n#include <asm/io.h>\n\n#include \"rivafb.h\"\n#include \"../edid.h\"\n\nstatic void riva_gpio_setscl(void* data, int state)\n{\n\tstruct riva_i2c_chan \t*chan = data;\n\tstruct riva_par \t*par = chan->par;\n\tu32\t\t\tval;\n\n\tVGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base + 1);\n\tval = VGA_RD08(par->riva.PCIO, 0x3d5) & 0xf0;\n\n\tif (state)\n\t\tval |= 0x20;\n\telse\n\t\tval &= ~0x20;\n\n\tVGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base + 1);\n\tVGA_WR08(par->riva.PCIO, 0x3d5, val | 0x1);\n}\n\nstatic void riva_gpio_setsda(void* data, int state)\n{\n\tstruct riva_i2c_chan \t*chan = data;\n\tstruct riva_par \t*par = chan->par;\n\tu32\t\t\tval;\n\n\tVGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base + 1);\n\tval = VGA_RD08(par->riva.PCIO, 0x3d5) & 0xf0;\n\n\tif (state)\n\t\tval |= 0x10;\n\telse\n\t\tval &= ~0x10;\n\n\tVGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base + 1);\n\tVGA_WR08(par->riva.PCIO, 0x3d5, val | 0x1);\n}\n\nstatic int riva_gpio_getscl(void* data)\n{\n\tstruct riva_i2c_chan \t*chan = data;\n\tstruct riva_par \t*par = chan->par;\n\tu32\t\t\tval = 0;\n\n\tVGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base);\n\tif (VGA_RD08(par->riva.PCIO, 0x3d5) & 0x04)\n\t\tval = 1;\n\n\treturn val;\n}\n\nstatic int riva_gpio_getsda(void* data)\n{\n\tstruct riva_i2c_chan \t*chan = data;\n\tstruct riva_par \t*par = chan->par;\n\tu32\t\t\tval = 0;\n\n\tVGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base);\n\tif (VGA_RD08(par->riva.PCIO, 0x3d5) & 0x08)\n\t\tval = 1;\n\n\treturn val;\n}\n\nstatic int riva_setup_i2c_bus(struct riva_i2c_chan *chan, const char *name,\n\t\t\t      unsigned int i2c_class)\n{\n\tint rc;\n\n\tstrcpy(chan->adapter.name, name);\n\tchan->adapter.owner\t\t= THIS_MODULE;\n\tchan->adapter.class\t\t= i2c_class;\n\tchan->adapter.algo_data\t\t= &chan->algo;\n\tchan->adapter.dev.parent\t= &chan->par->pdev->dev;\n\tchan->algo.setsda\t\t= riva_gpio_setsda;\n\tchan->algo.setscl\t\t= riva_gpio_setscl;\n\tchan->algo.getsda\t\t= riva_gpio_getsda;\n\tchan->algo.getscl\t\t= riva_gpio_getscl;\n\tchan->algo.udelay\t\t= 40;\n\tchan->algo.timeout\t\t= msecs_to_jiffies(2);\n\tchan->algo.data \t\t= chan;\n\n\ti2c_set_adapdata(&chan->adapter, chan);\n\n\t \n\triva_gpio_setsda(chan, 1);\n\triva_gpio_setscl(chan, 1);\n\tudelay(20);\n\n\trc = i2c_bit_add_bus(&chan->adapter);\n\tif (rc == 0)\n\t\tdev_dbg(&chan->par->pdev->dev, \"I2C bus %s registered.\\n\", name);\n\telse {\n\t\tdev_warn(&chan->par->pdev->dev,\n\t\t\t \"Failed to register I2C bus %s.\\n\", name);\n\t\tchan->par = NULL;\n\t}\n\n\treturn rc;\n}\n\nvoid riva_create_i2c_busses(struct riva_par *par)\n{\n\tpar->chan[0].par\t= par;\n\tpar->chan[1].par\t= par;\n\tpar->chan[2].par        = par;\n\n\tpar->chan[0].ddc_base = 0x36;\n\tpar->chan[1].ddc_base = 0x3e;\n\tpar->chan[2].ddc_base = 0x50;\n\triva_setup_i2c_bus(&par->chan[0], \"BUS1\", I2C_CLASS_HWMON);\n\triva_setup_i2c_bus(&par->chan[1], \"BUS2\", 0);\n\triva_setup_i2c_bus(&par->chan[2], \"BUS3\", 0);\n}\n\nvoid riva_delete_i2c_busses(struct riva_par *par)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (!par->chan[i].par)\n\t\t\tcontinue;\n\t\ti2c_del_adapter(&par->chan[i].adapter);\n\t\tpar->chan[i].par = NULL;\n\t}\n}\n\nint riva_probe_i2c_connector(struct riva_par *par, int conn, u8 **out_edid)\n{\n\tu8 *edid = NULL;\n\n\tif (par->chan[conn].par)\n\t\tedid = fb_ddc_read(&par->chan[conn].adapter);\n\n\tif (out_edid)\n\t\t*out_edid = edid;\n\tif (!edid)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}