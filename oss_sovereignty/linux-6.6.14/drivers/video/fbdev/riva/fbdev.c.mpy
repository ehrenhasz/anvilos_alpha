{
  "module_name": "fbdev.c",
  "hash_id": "2211d52085507288ca100cbe64123f78e9fa3388758aaa002e99bc5f823be482",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/riva/fbdev.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/backlight.h>\n#include <linux/bitrev.h>\n#ifdef CONFIG_PMAC_BACKLIGHT\n#include <asm/machdep.h>\n#include <asm/backlight.h>\n#endif\n\n#include \"rivafb.h\"\n#include \"nvreg.h\"\n\n \n#define RIVAFB_VERSION \"0.9.5b\"\n\n \n#ifdef CONFIG_FB_RIVA_DEBUG\n#define NVTRACE          printk\n#else\n#define NVTRACE          if(0) printk\n#endif\n\n#define NVTRACE_ENTER(...)  NVTRACE(\"%s START\\n\", __func__)\n#define NVTRACE_LEAVE(...)  NVTRACE(\"%s END\\n\", __func__)\n\n#ifdef CONFIG_FB_RIVA_DEBUG\n#define assert(expr) \\\n\tif(!(expr)) { \\\n\tprintk( \"Assertion failed! %s,%s,%s,line=%d\\n\",\\\n\t#expr,__FILE__,__func__,__LINE__); \\\n\tBUG(); \\\n\t}\n#else\n#define assert(expr)\n#endif\n\n#define PFX \"rivafb: \"\n\n \n#define SetBitField(value,from,to) SetBF(to,GetBF(value,from))\n#define SetBit(n)\t\t(1<<(n))\n#define Set8Bits(value)\t\t((value)&0xff)\n\n \n#define MAX_CURS\t\t32\n\n \n\nstatic int rivafb_blank(int blank, struct fb_info *info);\n\n \n\nstatic const struct pci_device_id rivafb_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_NVIDIA_SGS, PCI_DEVICE_ID_NVIDIA_SGS_RIVA128,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_TNT,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_TNT2,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_UTNT2,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_VTNT2,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_UVTNT2,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_ITNT2,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE_SDR,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE_DDR,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX2,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_GO,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO2_MXR,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS2,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_ULTRA,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO2_PRO,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_460,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_440,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t\n\t{ PCI_VENDOR_ID_NVIDIA, 0x01f0,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_420,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_440_GO,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_420_GO,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_420_GO_M32,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_500XGL,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_440_GO_M64,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_200,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_550XGL,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_500_GOGL,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_IGEFORCE2,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE3,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE3_1,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE3_2,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO_DDC,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4600,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4400,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4200,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n \t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_900XGL,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_750XGL,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_700XGL,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE_FX_GO_5200,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0, }  \n};\nMODULE_DEVICE_TABLE(pci, rivafb_pci_tbl);\n\n \n\n \nstatic int flatpanel = -1;  \nstatic int forceCRTC = -1;\nstatic bool noaccel  = 0;\nstatic bool nomtrr = 0;\nstatic int backlight = IS_BUILTIN(CONFIG_PMAC_BACKLIGHT);\n\nstatic char *mode_option = NULL;\nstatic bool strictmode       = 0;\n\nstatic struct fb_fix_screeninfo rivafb_fix = {\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.xpanstep\t= 1,\n\t.ypanstep\t= 1,\n};\n\nstatic struct fb_var_screeninfo rivafb_default_var = {\n\t.xres\t\t= 640,\n\t.yres\t\t= 480,\n\t.xres_virtual\t= 640,\n\t.yres_virtual\t= 480,\n\t.bits_per_pixel\t= 8,\n\t.red\t\t= {0, 8, 0},\n\t.green\t\t= {0, 8, 0},\n\t.blue\t\t= {0, 8, 0},\n\t.transp\t\t= {0, 0, 0},\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.pixclock\t= 39721,\n\t.left_margin\t= 40,\n\t.right_margin\t= 24,\n\t.upper_margin\t= 32,\n\t.lower_margin\t= 11,\n\t.hsync_len\t= 96,\n\t.vsync_len\t= 2,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED\n};\n\n \nstatic const struct riva_regs reg_template = {\n\t{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\t \n\t 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n\t 0x41, 0x01, 0x0F, 0x00, 0x00},\n\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\t \n\t 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3,\t \n\t 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\t \n\t 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\t \n\t 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t 0x00,\t\t\t\t\t\t\t \n\t },\n\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,\t \n\t 0xFF},\n\t{0x03, 0x01, 0x0F, 0x00, 0x0E},\t\t\t\t \n\t0xEB\t\t\t\t\t\t\t \n};\n\n \n#ifdef CONFIG_FB_RIVA_BACKLIGHT\n \n#define MIN_LEVEL 0x158\n#define MAX_LEVEL 0x534\n#define LEVEL_STEP ((MAX_LEVEL - MIN_LEVEL) / FB_BACKLIGHT_MAX)\n\nstatic int riva_bl_get_level_brightness(struct riva_par *par,\n\t\tint level)\n{\n\tstruct fb_info *info = pci_get_drvdata(par->pdev);\n\tint nlevel;\n\n\t \n\t \n\tnlevel = MIN_LEVEL + info->bl_curve[level] * LEVEL_STEP;\n\n\tif (nlevel < 0)\n\t\tnlevel = 0;\n\telse if (nlevel < MIN_LEVEL)\n\t\tnlevel = MIN_LEVEL;\n\telse if (nlevel > MAX_LEVEL)\n\t\tnlevel = MAX_LEVEL;\n\n\treturn nlevel;\n}\n\nstatic int riva_bl_update_status(struct backlight_device *bd)\n{\n\tstruct riva_par *par = bl_get_data(bd);\n\tU032 tmp_pcrt, tmp_pmc;\n\tint level = backlight_get_brightness(bd);\n\n\ttmp_pmc = NV_RD32(par->riva.PMC, 0x10F0) & 0x0000FFFF;\n\ttmp_pcrt = NV_RD32(par->riva.PCRTC0, 0x081C) & 0xFFFFFFFC;\n\tif(level > 0) {\n\t\ttmp_pcrt |= 0x1;\n\t\ttmp_pmc |= (1 << 31);  \n\t\ttmp_pmc |= riva_bl_get_level_brightness(par, level) << 16;  \n\t}\n\tNV_WR32(par->riva.PCRTC0, 0x081C, tmp_pcrt);\n\tNV_WR32(par->riva.PMC, 0x10F0, tmp_pmc);\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops riva_bl_ops = {\n\t.update_status\t= riva_bl_update_status,\n};\n\nstatic void riva_bl_init(struct riva_par *par)\n{\n\tstruct backlight_properties props;\n\tstruct fb_info *info = pci_get_drvdata(par->pdev);\n\tstruct backlight_device *bd;\n\tchar name[12];\n\n\tif (!par->FlatPanel)\n\t\treturn;\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n\tif (!machine_is(powermac) ||\n\t    !pmac_has_backlight_type(\"mnca\"))\n\t\treturn;\n#endif\n\n\tsnprintf(name, sizeof(name), \"rivabl%d\", info->node);\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = FB_BACKLIGHT_LEVELS - 1;\n\tbd = backlight_device_register(name, info->device, par, &riva_bl_ops,\n\t\t\t\t       &props);\n\tif (IS_ERR(bd)) {\n\t\tinfo->bl_dev = NULL;\n\t\tprintk(KERN_WARNING \"riva: Backlight registration failed\\n\");\n\t\tgoto error;\n\t}\n\n\tinfo->bl_dev = bd;\n\tfb_bl_default_curve(info, 0,\n\t\tMIN_LEVEL * FB_BACKLIGHT_MAX / MAX_LEVEL,\n\t\tFB_BACKLIGHT_MAX);\n\n\tbd->props.brightness = bd->props.max_brightness;\n\tbd->props.power = FB_BLANK_UNBLANK;\n\tbacklight_update_status(bd);\n\n\tprintk(\"riva: Backlight initialized (%s)\\n\", name);\n\n\treturn;\n\nerror:\n\treturn;\n}\n\nstatic void riva_bl_exit(struct fb_info *info)\n{\n\tstruct backlight_device *bd = info->bl_dev;\n\n\tbacklight_device_unregister(bd);\n\tprintk(\"riva: Backlight unloaded\\n\");\n}\n#else\nstatic inline void riva_bl_init(struct riva_par *par) {}\nstatic inline void riva_bl_exit(struct fb_info *info) {}\n#endif  \n\n \n\nstatic inline void CRTCout(struct riva_par *par, unsigned char index,\n\t\t\t   unsigned char val)\n{\n\tVGA_WR08(par->riva.PCIO, 0x3d4, index);\n\tVGA_WR08(par->riva.PCIO, 0x3d5, val);\n}\n\nstatic inline unsigned char CRTCin(struct riva_par *par,\n\t\t\t\t   unsigned char index)\n{\n\tVGA_WR08(par->riva.PCIO, 0x3d4, index);\n\treturn (VGA_RD08(par->riva.PCIO, 0x3d5));\n}\n\nstatic inline void GRAout(struct riva_par *par, unsigned char index,\n\t\t\t  unsigned char val)\n{\n\tVGA_WR08(par->riva.PVIO, 0x3ce, index);\n\tVGA_WR08(par->riva.PVIO, 0x3cf, val);\n}\n\nstatic inline unsigned char GRAin(struct riva_par *par,\n\t\t\t\t  unsigned char index)\n{\n\tVGA_WR08(par->riva.PVIO, 0x3ce, index);\n\treturn (VGA_RD08(par->riva.PVIO, 0x3cf));\n}\n\nstatic inline void SEQout(struct riva_par *par, unsigned char index,\n\t\t\t  unsigned char val)\n{\n\tVGA_WR08(par->riva.PVIO, 0x3c4, index);\n\tVGA_WR08(par->riva.PVIO, 0x3c5, val);\n}\n\nstatic inline unsigned char SEQin(struct riva_par *par,\n\t\t\t\t  unsigned char index)\n{\n\tVGA_WR08(par->riva.PVIO, 0x3c4, index);\n\treturn (VGA_RD08(par->riva.PVIO, 0x3c5));\n}\n\nstatic inline void ATTRout(struct riva_par *par, unsigned char index,\n\t\t\t   unsigned char val)\n{\n\tVGA_WR08(par->riva.PCIO, 0x3c0, index);\n\tVGA_WR08(par->riva.PCIO, 0x3c0, val);\n}\n\nstatic inline unsigned char ATTRin(struct riva_par *par,\n\t\t\t\t   unsigned char index)\n{\n\tVGA_WR08(par->riva.PCIO, 0x3c0, index);\n\treturn (VGA_RD08(par->riva.PCIO, 0x3c1));\n}\n\nstatic inline void MISCout(struct riva_par *par, unsigned char val)\n{\n\tVGA_WR08(par->riva.PVIO, 0x3c2, val);\n}\n\nstatic inline unsigned char MISCin(struct riva_par *par)\n{\n\treturn (VGA_RD08(par->riva.PVIO, 0x3cc));\n}\n\nstatic inline void reverse_order(u32 *l)\n{\n\tu8 *a = (u8 *)l;\n\ta[0] = bitrev8(a[0]);\n\ta[1] = bitrev8(a[1]);\n\ta[2] = bitrev8(a[2]);\n\ta[3] = bitrev8(a[3]);\n}\n\n \n\n \nstatic void rivafb_load_cursor_image(struct riva_par *par, u8 *data8,\n\t\t\t\t     u16 bg, u16 fg, u32 w, u32 h)\n{\n\tint i, j, k = 0;\n\tu32 b, tmp;\n\tu32 *data = (u32 *)data8;\n\tbg = le16_to_cpu(bg);\n\tfg = le16_to_cpu(fg);\n\n\tw = (w + 1) & ~1;\n\n\tfor (i = 0; i < h; i++) {\n\t\tb = *data++;\n\t\treverse_order(&b);\n\n\t\tfor (j = 0; j < w/2; j++) {\n\t\t\ttmp = 0;\n#if defined (__BIG_ENDIAN)\n\t\t\ttmp = (b & (1 << 31)) ? fg << 16 : bg << 16;\n\t\t\tb <<= 1;\n\t\t\ttmp |= (b & (1 << 31)) ? fg : bg;\n\t\t\tb <<= 1;\n#else\n\t\t\ttmp = (b & 1) ? fg : bg;\n\t\t\tb >>= 1;\n\t\t\ttmp |= (b & 1) ? fg << 16 : bg << 16;\n\t\t\tb >>= 1;\n#endif\n\t\t\twritel(tmp, &par->riva.CURSOR[k++]);\n\t\t}\n\t\tk += (MAX_CURS - w)/2;\n\t}\n}\n\n \n\n \nstatic void riva_wclut(RIVA_HW_INST *chip,\n\t\t       unsigned char regnum, unsigned char red,\n\t\t       unsigned char green, unsigned char blue)\n{\n\tVGA_WR08(chip->PDIO, 0x3c8, regnum);\n\tVGA_WR08(chip->PDIO, 0x3c9, red);\n\tVGA_WR08(chip->PDIO, 0x3c9, green);\n\tVGA_WR08(chip->PDIO, 0x3c9, blue);\n}\n\n \nstatic void riva_rclut(RIVA_HW_INST *chip,\n\t\t       unsigned char regnum, unsigned char *red,\n\t\t       unsigned char *green, unsigned char *blue)\n{\n\n\tVGA_WR08(chip->PDIO, 0x3c7, regnum);\n\t*red = VGA_RD08(chip->PDIO, 0x3c9);\n\t*green = VGA_RD08(chip->PDIO, 0x3c9);\n\t*blue = VGA_RD08(chip->PDIO, 0x3c9);\n}\n\n \n \nstatic void riva_save_state(struct riva_par *par, struct riva_regs *regs)\n{\n\tint i;\n\n\tNVTRACE_ENTER();\n\tpar->riva.LockUnlock(&par->riva, 0);\n\n\tpar->riva.UnloadStateExt(&par->riva, &regs->ext);\n\n\tregs->misc_output = MISCin(par);\n\n\tfor (i = 0; i < NUM_CRT_REGS; i++)\n\t\tregs->crtc[i] = CRTCin(par, i);\n\n\tfor (i = 0; i < NUM_ATC_REGS; i++)\n\t\tregs->attr[i] = ATTRin(par, i);\n\n\tfor (i = 0; i < NUM_GRC_REGS; i++)\n\t\tregs->gra[i] = GRAin(par, i);\n\n\tfor (i = 0; i < NUM_SEQ_REGS; i++)\n\t\tregs->seq[i] = SEQin(par, i);\n\tNVTRACE_LEAVE();\n}\n\n \n \nstatic void riva_load_state(struct riva_par *par, struct riva_regs *regs)\n{\n\tRIVA_HW_STATE *state = &regs->ext;\n\tint i;\n\n\tNVTRACE_ENTER();\n\tCRTCout(par, 0x11, 0x00);\n\n\tpar->riva.LockUnlock(&par->riva, 0);\n\n\tpar->riva.LoadStateExt(&par->riva, state);\n\n\tMISCout(par, regs->misc_output);\n\n\tfor (i = 0; i < NUM_CRT_REGS; i++) {\n\t\tswitch (i) {\n\t\tcase 0x19:\n\t\tcase 0x20 ... 0x40:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCRTCout(par, i, regs->crtc[i]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < NUM_ATC_REGS; i++)\n\t\tATTRout(par, i, regs->attr[i]);\n\n\tfor (i = 0; i < NUM_GRC_REGS; i++)\n\t\tGRAout(par, i, regs->gra[i]);\n\n\tfor (i = 0; i < NUM_SEQ_REGS; i++)\n\t\tSEQout(par, i, regs->seq[i]);\n\tNVTRACE_LEAVE();\n}\n\n \nstatic int riva_load_video_mode(struct fb_info *info)\n{\n\tint bpp, width, hDisplaySize, hDisplay, hStart,\n\t    hEnd, hTotal, height, vDisplay, vStart, vEnd, vTotal, dotClock;\n\tint hBlankStart, hBlankEnd, vBlankStart, vBlankEnd;\n\tint rc;\n\tstruct riva_par *par = info->par;\n\tstruct riva_regs newmode;\n\n\tNVTRACE_ENTER();\n\t \n\trivafb_blank(FB_BLANK_NORMAL, info);\n\n\tbpp = info->var.bits_per_pixel;\n\tif (bpp == 16 && info->var.green.length == 5)\n\t\tbpp = 15;\n\twidth = info->var.xres_virtual;\n\thDisplaySize = info->var.xres;\n\thDisplay = (hDisplaySize / 8) - 1;\n\thStart = (hDisplaySize + info->var.right_margin) / 8 - 1;\n\thEnd = (hDisplaySize + info->var.right_margin +\n\t\tinfo->var.hsync_len) / 8 - 1;\n\thTotal = (hDisplaySize + info->var.right_margin +\n\t\t  info->var.hsync_len + info->var.left_margin) / 8 - 5;\n\thBlankStart = hDisplay;\n\thBlankEnd = hTotal + 4;\n\n\theight = info->var.yres_virtual;\n\tvDisplay = info->var.yres - 1;\n\tvStart = info->var.yres + info->var.lower_margin - 1;\n\tvEnd = info->var.yres + info->var.lower_margin +\n\t       info->var.vsync_len - 1;\n\tvTotal = info->var.yres + info->var.lower_margin +\n\t\t info->var.vsync_len + info->var.upper_margin + 2;\n\tvBlankStart = vDisplay;\n\tvBlankEnd = vTotal + 1;\n\tdotClock = 1000000000 / info->var.pixclock;\n\n\tmemcpy(&newmode, &reg_template, sizeof(struct riva_regs));\n\n\tif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)\n\t\tvTotal |= 1;\n\n\tif (par->FlatPanel) {\n\t\tvStart = vTotal - 3;\n\t\tvEnd = vTotal - 2;\n\t\tvBlankStart = vStart;\n\t\thStart = hTotal - 3;\n\t\thEnd = hTotal - 2;\n\t\thBlankEnd = hTotal + 4;\n\t}\n\n\tnewmode.crtc[0x0] = Set8Bits (hTotal);\n\tnewmode.crtc[0x1] = Set8Bits (hDisplay);\n\tnewmode.crtc[0x2] = Set8Bits (hBlankStart);\n\tnewmode.crtc[0x3] = SetBitField (hBlankEnd, 4: 0, 4:0) | SetBit (7);\n\tnewmode.crtc[0x4] = Set8Bits (hStart);\n\tnewmode.crtc[0x5] = SetBitField (hBlankEnd, 5: 5, 7:7)\n\t\t| SetBitField (hEnd, 4: 0, 4:0);\n\tnewmode.crtc[0x6] = SetBitField (vTotal, 7: 0, 7:0);\n\tnewmode.crtc[0x7] = SetBitField (vTotal, 8: 8, 0:0)\n\t\t| SetBitField (vDisplay, 8: 8, 1:1)\n\t\t| SetBitField (vStart, 8: 8, 2:2)\n\t\t| SetBitField (vBlankStart, 8: 8, 3:3)\n\t\t| SetBit (4)\n\t\t| SetBitField (vTotal, 9: 9, 5:5)\n\t\t| SetBitField (vDisplay, 9: 9, 6:6)\n\t\t| SetBitField (vStart, 9: 9, 7:7);\n\tnewmode.crtc[0x9] = SetBitField (vBlankStart, 9: 9, 5:5)\n\t\t| SetBit (6);\n\tnewmode.crtc[0x10] = Set8Bits (vStart);\n\tnewmode.crtc[0x11] = SetBitField (vEnd, 3: 0, 3:0)\n\t\t| SetBit (5);\n\tnewmode.crtc[0x12] = Set8Bits (vDisplay);\n\tnewmode.crtc[0x13] = (width / 8) * ((bpp + 1) / 8);\n\tnewmode.crtc[0x15] = Set8Bits (vBlankStart);\n\tnewmode.crtc[0x16] = Set8Bits (vBlankEnd);\n\n\tnewmode.ext.screen = SetBitField(hBlankEnd,6:6,4:4)\n\t\t| SetBitField(vBlankStart,10:10,3:3)\n\t\t| SetBitField(vStart,10:10,2:2)\n\t\t| SetBitField(vDisplay,10:10,1:1)\n\t\t| SetBitField(vTotal,10:10,0:0);\n\tnewmode.ext.horiz  = SetBitField(hTotal,8:8,0:0)\n\t\t| SetBitField(hDisplay,8:8,1:1)\n\t\t| SetBitField(hBlankStart,8:8,2:2)\n\t\t| SetBitField(hStart,8:8,3:3);\n\tnewmode.ext.extra  = SetBitField(vTotal,11:11,0:0)\n\t\t| SetBitField(vDisplay,11:11,2:2)\n\t\t| SetBitField(vStart,11:11,4:4)\n\t\t| SetBitField(vBlankStart,11:11,6:6);\n\n\tif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\n\t\tint tmp = (hTotal >> 1) & ~1;\n\t\tnewmode.ext.interlace = Set8Bits(tmp);\n\t\tnewmode.ext.horiz |= SetBitField(tmp, 8:8,4:4);\n\t} else\n\t\tnewmode.ext.interlace = 0xff;  \n\n\tif (par->riva.Architecture >= NV_ARCH_10)\n\t\tpar->riva.CURSOR = (U032 __iomem *)(info->screen_base + par->riva.CursorStart);\n\n\tif (info->var.sync & FB_SYNC_HOR_HIGH_ACT)\n\t\tnewmode.misc_output &= ~0x40;\n\telse\n\t\tnewmode.misc_output |= 0x40;\n\tif (info->var.sync & FB_SYNC_VERT_HIGH_ACT)\n\t\tnewmode.misc_output &= ~0x80;\n\telse\n\t\tnewmode.misc_output |= 0x80;\n\n\trc = CalcStateExt(&par->riva, &newmode.ext, par->pdev, bpp, width,\n\t\t\t  hDisplaySize, height, dotClock);\n\tif (rc)\n\t\tgoto out;\n\n\tnewmode.ext.scale = NV_RD32(par->riva.PRAMDAC, 0x00000848) &\n\t\t0xfff000ff;\n\tif (par->FlatPanel == 1) {\n\t\tnewmode.ext.pixel |= (1 << 7);\n\t\tnewmode.ext.scale |= (1 << 8);\n\t}\n\tif (par->SecondCRTC) {\n\t\tnewmode.ext.head  = NV_RD32(par->riva.PCRTC0, 0x00000860) &\n\t\t\t~0x00001000;\n\t\tnewmode.ext.head2 = NV_RD32(par->riva.PCRTC0, 0x00002860) |\n\t\t\t0x00001000;\n\t\tnewmode.ext.crtcOwner = 3;\n\t\tnewmode.ext.pllsel |= 0x20000800;\n\t\tnewmode.ext.vpll2 = newmode.ext.vpll;\n\t} else if (par->riva.twoHeads) {\n\t\tnewmode.ext.head  =  NV_RD32(par->riva.PCRTC0, 0x00000860) |\n\t\t\t0x00001000;\n\t\tnewmode.ext.head2 =  NV_RD32(par->riva.PCRTC0, 0x00002860) &\n\t\t\t~0x00001000;\n\t\tnewmode.ext.crtcOwner = 0;\n\t\tnewmode.ext.vpll2 = NV_RD32(par->riva.PRAMDAC0, 0x00000520);\n\t}\n\tif (par->FlatPanel == 1) {\n\t\tnewmode.ext.pixel |= (1 << 7);\n\t\tnewmode.ext.scale |= (1 << 8);\n\t}\n\tnewmode.ext.cursorConfig = 0x02000100;\n\tpar->current_state = newmode;\n\triva_load_state(par, &par->current_state);\n\tpar->riva.LockUnlock(&par->riva, 0);  \n\nout:\n\trivafb_blank(FB_BLANK_UNBLANK, info);\n\tNVTRACE_LEAVE();\n\n\treturn rc;\n}\n\nstatic void riva_update_var(struct fb_var_screeninfo *var,\n\t\t\t    const struct fb_videomode *modedb)\n{\n\tNVTRACE_ENTER();\n\tvar->xres = var->xres_virtual = modedb->xres;\n\tvar->yres = modedb->yres;\n        if (var->yres_virtual < var->yres)\n\t    var->yres_virtual = var->yres;\n        var->xoffset = var->yoffset = 0;\n        var->pixclock = modedb->pixclock;\n        var->left_margin = modedb->left_margin;\n        var->right_margin = modedb->right_margin;\n        var->upper_margin = modedb->upper_margin;\n        var->lower_margin = modedb->lower_margin;\n        var->hsync_len = modedb->hsync_len;\n        var->vsync_len = modedb->vsync_len;\n        var->sync = modedb->sync;\n        var->vmode = modedb->vmode;\n\tNVTRACE_LEAVE();\n}\n\n \nstatic int rivafb_do_maximize(struct fb_info *info,\n\t\t\t      struct fb_var_screeninfo *var,\n\t\t\t      int nom, int den)\n{\n\tstatic struct {\n\t\tint xres, yres;\n\t} modes[] = {\n\t\t{1600, 1280},\n\t\t{1280, 1024},\n\t\t{1024, 768},\n\t\t{800, 600},\n\t\t{640, 480},\n\t\t{-1, -1}\n\t};\n\tint i;\n\n\tNVTRACE_ENTER();\n\t \n\tif (var->xres_virtual == -1 && var->yres_virtual == -1) {\n\t\tprintk(KERN_WARNING PFX\n\t\t       \"using maximum available virtual resolution\\n\");\n\t\tfor (i = 0; modes[i].xres != -1; i++) {\n\t\t\tif (modes[i].xres * nom / den * modes[i].yres <\n\t\t\t    info->fix.smem_len)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (modes[i].xres == -1) {\n\t\t\tprintk(KERN_ERR PFX\n\t\t\t       \"could not find a virtual resolution that fits into video memory!!\\n\");\n\t\t\tNVTRACE(\"EXIT - EINVAL error\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvar->xres_virtual = modes[i].xres;\n\t\tvar->yres_virtual = modes[i].yres;\n\n\t\tprintk(KERN_INFO PFX\n\t\t       \"virtual resolution set to maximum of %dx%d\\n\",\n\t\t       var->xres_virtual, var->yres_virtual);\n\t} else if (var->xres_virtual == -1) {\n\t\tvar->xres_virtual = (info->fix.smem_len * den /\n\t\t\t(nom * var->yres_virtual)) & ~15;\n\t\tprintk(KERN_WARNING PFX\n\t\t       \"setting virtual X resolution to %d\\n\", var->xres_virtual);\n\t} else if (var->yres_virtual == -1) {\n\t\tvar->xres_virtual = (var->xres_virtual + 15) & ~15;\n\t\tvar->yres_virtual = info->fix.smem_len * den /\n\t\t\t(nom * var->xres_virtual);\n\t\tprintk(KERN_WARNING PFX\n\t\t       \"setting virtual Y resolution to %d\\n\", var->yres_virtual);\n\t} else {\n\t\tvar->xres_virtual = (var->xres_virtual + 15) & ~15;\n\t\tif (var->xres_virtual * nom / den * var->yres_virtual > info->fix.smem_len) {\n\t\t\tprintk(KERN_ERR PFX\n\t\t\t       \"mode %dx%dx%d rejected...resolution too high to fit into video memory!\\n\",\n\t\t\t       var->xres, var->yres, var->bits_per_pixel);\n\t\t\tNVTRACE(\"EXIT - EINVAL error\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (var->xres_virtual * nom / den >= 8192) {\n\t\tprintk(KERN_WARNING PFX\n\t\t       \"virtual X resolution (%d) is too high, lowering to %d\\n\",\n\t\t       var->xres_virtual, 8192 * den / nom - 16);\n\t\tvar->xres_virtual = 8192 * den / nom - 16;\n\t}\n\n\tif (var->xres_virtual < var->xres) {\n\t\tprintk(KERN_ERR PFX\n\t\t       \"virtual X resolution (%d) is smaller than real\\n\", var->xres_virtual);\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->yres_virtual < var->yres) {\n\t\tprintk(KERN_ERR PFX\n\t\t       \"virtual Y resolution (%d) is smaller than real\\n\", var->yres_virtual);\n\t\treturn -EINVAL;\n\t}\n\tif (var->yres_virtual > 0x7fff/nom)\n\t\tvar->yres_virtual = 0x7fff/nom;\n\tif (var->xres_virtual > 0x7fff/nom)\n\t\tvar->xres_virtual = 0x7fff/nom;\n\tNVTRACE_LEAVE();\n\treturn 0;\n}\n\nstatic void\nriva_set_pattern(struct riva_par *par, int clr0, int clr1, int pat0, int pat1)\n{\n\tRIVA_FIFO_FREE(par->riva, Patt, 4);\n\tNV_WR32(&par->riva.Patt->Color0, 0, clr0);\n\tNV_WR32(&par->riva.Patt->Color1, 0, clr1);\n\tNV_WR32(par->riva.Patt->Monochrome, 0, pat0);\n\tNV_WR32(par->riva.Patt->Monochrome, 4, pat1);\n}\n\n \nstatic inline void wait_for_idle(struct riva_par *par)\n{\n\twhile (par->riva.Busy(&par->riva));\n}\n\n \nstatic void\nriva_set_rop_solid(struct riva_par *par, int rop)\n{\n\triva_set_pattern(par, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);\n        RIVA_FIFO_FREE(par->riva, Rop, 1);\n        NV_WR32(&par->riva.Rop->Rop3, 0, rop);\n\n}\n\nstatic void riva_setup_accel(struct fb_info *info)\n{\n\tstruct riva_par *par = info->par;\n\n\tRIVA_FIFO_FREE(par->riva, Clip, 2);\n\tNV_WR32(&par->riva.Clip->TopLeft, 0, 0x0);\n\tNV_WR32(&par->riva.Clip->WidthHeight, 0,\n\t\t(info->var.xres_virtual & 0xffff) |\n\t\t(info->var.yres_virtual << 16));\n\triva_set_rop_solid(par, 0xcc);\n\twait_for_idle(par);\n}\n\n \nstatic int riva_get_cmap_len(const struct fb_var_screeninfo *var)\n{\n\tint rc = 256;\t\t \n\n\tswitch (var->green.length) {\n\tcase 8:\n\t\trc = 256;\t \n\t\tbreak;\n\tcase 5:\n\t\trc = 32;\t \n\t\tbreak;\n\tcase 6:\n\t\trc = 64;\t \n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn rc;\n}\n\n \n\nstatic int rivafb_open(struct fb_info *info, int user)\n{\n\tstruct riva_par *par = info->par;\n\n\tNVTRACE_ENTER();\n\tmutex_lock(&par->open_lock);\n\tif (!par->ref_count) {\n#ifdef CONFIG_X86\n\t\tmemset(&par->state, 0, sizeof(struct vgastate));\n\t\tpar->state.flags = VGA_SAVE_MODE  | VGA_SAVE_FONTS;\n\t\t \n\t\tif (par->riva.Architecture == NV_ARCH_03)\n\t\t\tpar->state.flags |= VGA_SAVE_CMAP;\n\t\tsave_vga(&par->state);\n#endif\n\t\t \n\t\tCRTCout(par, 0x11, 0xFF);\n\t\tpar->riva.LockUnlock(&par->riva, 0);\n\n\t\triva_save_state(par, &par->initial_state);\n\t}\n\tpar->ref_count++;\n\tmutex_unlock(&par->open_lock);\n\tNVTRACE_LEAVE();\n\treturn 0;\n}\n\nstatic int rivafb_release(struct fb_info *info, int user)\n{\n\tstruct riva_par *par = info->par;\n\n\tNVTRACE_ENTER();\n\tmutex_lock(&par->open_lock);\n\tif (!par->ref_count) {\n\t\tmutex_unlock(&par->open_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (par->ref_count == 1) {\n\t\tpar->riva.LockUnlock(&par->riva, 0);\n\t\tpar->riva.LoadStateExt(&par->riva, &par->initial_state.ext);\n\t\triva_load_state(par, &par->initial_state);\n#ifdef CONFIG_X86\n\t\trestore_vga(&par->state);\n#endif\n\t\tpar->riva.LockUnlock(&par->riva, 1);\n\t}\n\tpar->ref_count--;\n\tmutex_unlock(&par->open_lock);\n\tNVTRACE_LEAVE();\n\treturn 0;\n}\n\nstatic int rivafb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tconst struct fb_videomode *mode;\n\tstruct riva_par *par = info->par;\n\tint nom, den;\t\t \n\tint mode_valid = 0;\n\n\tNVTRACE_ENTER();\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 1 ... 8:\n\t\tvar->red.offset = var->green.offset = var->blue.offset = 0;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tvar->bits_per_pixel = 8;\n\t\tnom = den = 1;\n\t\tbreak;\n\tcase 9 ... 15:\n\t\tvar->green.length = 5;\n\t\tfallthrough;\n\tcase 16:\n\t\tvar->bits_per_pixel = 16;\n\t\t \n\t\tif (par->riva.Architecture == NV_ARCH_03)\n\t\t\tvar->green.length = 5;\n\t\tif (var->green.length == 5) {\n\t\t\t \n\t\t\tvar->red.offset = 10;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length = 5;\n\t\t\tvar->green.length = 5;\n\t\t\tvar->blue.length = 5;\n\t\t} else {\n\t\t\t \n\t\t\tvar->red.offset = 11;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length = 5;\n\t\t\tvar->green.length = 6;\n\t\t\tvar->blue.length = 5;\n\t\t}\n\t\tnom = 2;\n\t\tden = 1;\n\t\tbreak;\n\tcase 17 ... 32:\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tvar->bits_per_pixel = 32;\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tnom = 4;\n\t\tden = 1;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR PFX\n\t\t       \"mode %dx%dx%d rejected...color depth not supported.\\n\",\n\t\t       var->xres, var->yres, var->bits_per_pixel);\n\t\tNVTRACE(\"EXIT, returning -EINVAL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!strictmode) {\n\t\tif (!info->monspecs.vfmax || !info->monspecs.hfmax ||\n\t\t    !info->monspecs.dclkmax || !fb_validate_mode(var, info))\n\t\t\tmode_valid = 1;\n\t}\n\n\t \n\tif (!mode_valid && info->monspecs.gtf) {\n\t\tif (!fb_get_mode(FB_MAXTIMINGS, 0, var, info))\n\t\t\tmode_valid = 1;\n\t}\n\n\tif (!mode_valid) {\n\t\tmode = fb_find_best_mode(var, &info->modelist);\n\t\tif (mode) {\n\t\t\triva_update_var(var, mode);\n\t\t\tmode_valid = 1;\n\t\t}\n\t}\n\n\tif (!mode_valid && info->monspecs.modedb_len)\n\t\treturn -EINVAL;\n\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres_virtual <= var->yres)\n\t\tvar->yres_virtual = -1;\n\tif (rivafb_do_maximize(info, var, nom, den) < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (var->xoffset > var->xres_virtual - var->xres)\n\t\tvar->xoffset = var->xres_virtual - var->xres - 1;\n\n\tif (var->yoffset > var->yres_virtual - var->yres)\n\t\tvar->yoffset = var->yres_virtual - var->yres - 1;\n\n\tvar->red.msb_right =\n\t    var->green.msb_right =\n\t    var->blue.msb_right =\n\t    var->transp.offset = var->transp.length = var->transp.msb_right = 0;\n\tNVTRACE_LEAVE();\n\treturn 0;\n}\n\nstatic int rivafb_set_par(struct fb_info *info)\n{\n\tstruct riva_par *par = info->par;\n\tint rc = 0;\n\n\tNVTRACE_ENTER();\n\t \n\tCRTCout(par, 0x11, 0xFF);\n\tpar->riva.LockUnlock(&par->riva, 0);\n\trc = riva_load_video_mode(info);\n\tif (rc)\n\t\tgoto out;\n\tif(!(info->flags & FBINFO_HWACCEL_DISABLED))\n\t\triva_setup_accel(info);\n\n\tpar->cursor_reset = 1;\n\tinfo->fix.line_length = (info->var.xres_virtual * (info->var.bits_per_pixel >> 3));\n\tinfo->fix.visual = (info->var.bits_per_pixel == 8) ?\n\t\t\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\n\n\tif (info->flags & FBINFO_HWACCEL_DISABLED)\n\t\tinfo->pixmap.scan_align = 1;\n\telse\n\t\tinfo->pixmap.scan_align = 4;\n\nout:\n\tNVTRACE_LEAVE();\n\treturn rc;\n}\n\n \nstatic int rivafb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct riva_par *par = info->par;\n\tunsigned int base;\n\n\tNVTRACE_ENTER();\n\tbase = var->yoffset * info->fix.line_length + var->xoffset;\n\tpar->riva.SetStartAddress(&par->riva, base);\n\tNVTRACE_LEAVE();\n\treturn 0;\n}\n\nstatic int rivafb_blank(int blank, struct fb_info *info)\n{\n\tstruct riva_par *par= info->par;\n\tunsigned char tmp, vesa;\n\n\ttmp = SEQin(par, 0x01) & ~0x20;\t \n\tvesa = CRTCin(par, 0x1a) & ~0xc0;\t \n\n\tNVTRACE_ENTER();\n\n\tif (blank)\n\t\ttmp |= 0x20;\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\n\tcase FB_BLANK_NORMAL:\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tvesa |= 0x80;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tvesa |= 0x40;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tvesa |= 0xc0;\n\t\tbreak;\n\t}\n\n\tSEQout(par, 0x01, tmp);\n\tCRTCout(par, 0x1a, vesa);\n\n\tNVTRACE_LEAVE();\n\n\treturn 0;\n}\n\n \nstatic int rivafb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t  unsigned blue, unsigned transp,\n\t\t\t  struct fb_info *info)\n{\n\tstruct riva_par *par = info->par;\n\tRIVA_HW_INST *chip = &par->riva;\n\tint i;\n\n\tif (regno >= riva_get_cmap_len(&info->var))\n\t\t\treturn -EINVAL;\n\n\tif (info->var.grayscale) {\n\t\t \n\t\tred = green = blue =\n\t\t    (red * 77 + green * 151 + blue * 28) >> 8;\n\t}\n\n\tif (regno < 16 && info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\t((u32 *) info->pseudo_palette)[regno] =\n\t\t\t(regno << info->var.red.offset) |\n\t\t\t(regno << info->var.green.offset) |\n\t\t\t(regno << info->var.blue.offset);\n\t\t \n\t\tif (par->riva.Architecture == NV_ARCH_03) {\n\t\t\tswitch (info->var.bits_per_pixel) {\n\t\t\tcase 16:\n\t\t\t\tpar->palette[regno] = ((red & 0xf800) >> 1) |\n\t\t\t\t\t((green & 0xf800) >> 6) |\n\t\t\t\t\t((blue & 0xf800) >> 11);\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\t\tpar->palette[regno] = ((red & 0xff00) << 8) |\n\t\t\t\t\t((green & 0xff00)) |\n\t\t\t\t\t((blue & 0xff00) >> 8);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\t \n\t\triva_wclut(chip, regno, red >> 8, green >> 8, blue >> 8);\n\t\tbreak;\n\tcase 16:\n\t\tif (info->var.green.length == 5) {\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\triva_wclut(chip, regno*8+i, red >> 8,\n\t\t\t\t\t   green >> 8, blue >> 8);\n\t\t\t}\n\t\t} else {\n\t\t\tu8 r, g, b;\n\n\t\t\tif (regno < 32) {\n\t\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\t\triva_wclut(chip, regno*8+i,\n\t\t\t\t\t\t   red >> 8, green >> 8,\n\t\t\t\t\t\t   blue >> 8);\n\t\t\t\t}\n\t\t\t}\n\t\t\triva_rclut(chip, regno*4, &r, &g, &b);\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\triva_wclut(chip, regno*4+i, r,\n\t\t\t\t\t   green >> 8, b);\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\triva_wclut(chip, regno, red >> 8, green >> 8, blue >> 8);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic void rivafb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct riva_par *par = info->par;\n\tu_int color, rop = 0;\n\n\tif ((info->flags & FBINFO_HWACCEL_DISABLED)) {\n\t\tcfb_fillrect(info, rect);\n\t\treturn;\n\t}\n\n\tif (info->var.bits_per_pixel == 8)\n\t\tcolor = rect->color;\n\telse {\n\t\tif (par->riva.Architecture != NV_ARCH_03)\n\t\t\tcolor = ((u32 *)info->pseudo_palette)[rect->color];\n\t\telse\n\t\t\tcolor = par->palette[rect->color];\n\t}\n\n\tswitch (rect->rop) {\n\tcase ROP_XOR:\n\t\trop = 0x66;\n\t\tbreak;\n\tcase ROP_COPY:\n\tdefault:\n\t\trop = 0xCC;\n\t\tbreak;\n\t}\n\n\triva_set_rop_solid(par, rop);\n\n\tRIVA_FIFO_FREE(par->riva, Bitmap, 1);\n\tNV_WR32(&par->riva.Bitmap->Color1A, 0, color);\n\n\tRIVA_FIFO_FREE(par->riva, Bitmap, 2);\n\tNV_WR32(&par->riva.Bitmap->UnclippedRectangle[0].TopLeft, 0,\n\t\t(rect->dx << 16) | rect->dy);\n\tmb();\n\tNV_WR32(&par->riva.Bitmap->UnclippedRectangle[0].WidthHeight, 0,\n\t\t(rect->width << 16) | rect->height);\n\tmb();\n\triva_set_rop_solid(par, 0xcc);\n\n}\n\n \nstatic void rivafb_copyarea(struct fb_info *info, const struct fb_copyarea *region)\n{\n\tstruct riva_par *par = info->par;\n\n\tif ((info->flags & FBINFO_HWACCEL_DISABLED)) {\n\t\tcfb_copyarea(info, region);\n\t\treturn;\n\t}\n\n\tRIVA_FIFO_FREE(par->riva, Blt, 3);\n\tNV_WR32(&par->riva.Blt->TopLeftSrc, 0,\n\t\t(region->sy << 16) | region->sx);\n\tNV_WR32(&par->riva.Blt->TopLeftDst, 0,\n\t\t(region->dy << 16) | region->dx);\n\tmb();\n\tNV_WR32(&par->riva.Blt->WidthHeight, 0,\n\t\t(region->height << 16) | region->width);\n\tmb();\n}\n\nstatic inline void convert_bgcolor_16(u32 *col)\n{\n\t*col = ((*col & 0x0000F800) << 8)\n\t\t| ((*col & 0x00007E0) << 5)\n\t\t| ((*col & 0x0000001F) << 3)\n\t\t|\t   0xFF000000;\n\tmb();\n}\n\n \nstatic void rivafb_imageblit(struct fb_info *info,\n\t\t\t     const struct fb_image *image)\n{\n\tstruct riva_par *par = info->par;\n\tu32 fgx = 0, bgx = 0, width, tmp;\n\tu8 *cdat = (u8 *) image->data;\n\tvolatile u32 __iomem *d;\n\tint i, size;\n\n\tif ((info->flags & FBINFO_HWACCEL_DISABLED) || image->depth != 1) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tfgx = image->fg_color;\n\t\tbgx = image->bg_color;\n\t\tbreak;\n\tcase 16:\n\tcase 32:\n\t\tif (par->riva.Architecture != NV_ARCH_03) {\n\t\t\tfgx = ((u32 *)info->pseudo_palette)[image->fg_color];\n\t\t\tbgx = ((u32 *)info->pseudo_palette)[image->bg_color];\n\t\t} else {\n\t\t\tfgx = par->palette[image->fg_color];\n\t\t\tbgx = par->palette[image->bg_color];\n\t\t}\n\t\tif (info->var.green.length == 6)\n\t\t\tconvert_bgcolor_16(&bgx);\n\t\tbreak;\n\t}\n\n\tRIVA_FIFO_FREE(par->riva, Bitmap, 7);\n\tNV_WR32(&par->riva.Bitmap->ClipE.TopLeft, 0,\n\t\t(image->dy << 16) | (image->dx & 0xFFFF));\n\tNV_WR32(&par->riva.Bitmap->ClipE.BottomRight, 0,\n\t\t(((image->dy + image->height) << 16) |\n\t\t ((image->dx + image->width) & 0xffff)));\n\tNV_WR32(&par->riva.Bitmap->Color0E, 0, bgx);\n\tNV_WR32(&par->riva.Bitmap->Color1E, 0, fgx);\n\tNV_WR32(&par->riva.Bitmap->WidthHeightInE, 0,\n\t\t(image->height << 16) | ((image->width + 31) & ~31));\n\tNV_WR32(&par->riva.Bitmap->WidthHeightOutE, 0,\n\t\t(image->height << 16) | ((image->width + 31) & ~31));\n\tNV_WR32(&par->riva.Bitmap->PointE, 0,\n\t\t(image->dy << 16) | (image->dx & 0xFFFF));\n\n\td = &par->riva.Bitmap->MonochromeData01E;\n\n\twidth = (image->width + 31)/32;\n\tsize = width * image->height;\n\twhile (size >= 16) {\n\t\tRIVA_FIFO_FREE(par->riva, Bitmap, 16);\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\ttmp = *((u32 *)cdat);\n\t\t\tcdat = (u8 *)((u32 *)cdat + 1);\n\t\t\treverse_order(&tmp);\n\t\t\tNV_WR32(d, i*4, tmp);\n\t\t}\n\t\tsize -= 16;\n\t}\n\tif (size) {\n\t\tRIVA_FIFO_FREE(par->riva, Bitmap, size);\n\t\tfor (i = 0; i < size; i++) {\n\t\t\ttmp = *((u32 *) cdat);\n\t\t\tcdat = (u8 *)((u32 *)cdat + 1);\n\t\t\treverse_order(&tmp);\n\t\t\tNV_WR32(d, i*4, tmp);\n\t\t}\n\t}\n}\n\n \nstatic int rivafb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\tstruct riva_par *par = info->par;\n\tu8 data[MAX_CURS * MAX_CURS/8];\n\tint i, set = cursor->set;\n\tu16 fg, bg;\n\n\tif (cursor->image.width > MAX_CURS || cursor->image.height > MAX_CURS)\n\t\treturn -ENXIO;\n\n\tpar->riva.ShowHideCursor(&par->riva, 0);\n\n\tif (par->cursor_reset) {\n\t\tset = FB_CUR_SETALL;\n\t\tpar->cursor_reset = 0;\n\t}\n\n\tif (set & FB_CUR_SETSIZE)\n\t\tmemset_io(par->riva.CURSOR, 0, MAX_CURS * MAX_CURS * 2);\n\n\tif (set & FB_CUR_SETPOS) {\n\t\tu32 xx, yy, temp;\n\n\t\tyy = cursor->image.dy - info->var.yoffset;\n\t\txx = cursor->image.dx - info->var.xoffset;\n\t\ttemp = xx & 0xFFFF;\n\t\ttemp |= yy << 16;\n\n\t\tNV_WR32(par->riva.PRAMDAC, 0x0000300, temp);\n\t}\n\n\n\tif (set & (FB_CUR_SETSHAPE | FB_CUR_SETCMAP | FB_CUR_SETIMAGE)) {\n\t\tu32 bg_idx = cursor->image.bg_color;\n\t\tu32 fg_idx = cursor->image.fg_color;\n\t\tu32 s_pitch = (cursor->image.width+7) >> 3;\n\t\tu32 d_pitch = MAX_CURS/8;\n\t\tu8 *dat = (u8 *) cursor->image.data;\n\t\tu8 *msk = (u8 *) cursor->mask;\n\t\tu8 *src;\n\n\t\tsrc = kmalloc_array(s_pitch, cursor->image.height, GFP_ATOMIC);\n\n\t\tif (src) {\n\t\t\tswitch (cursor->rop) {\n\t\t\tcase ROP_XOR:\n\t\t\t\tfor (i = 0; i < s_pitch * cursor->image.height; i++)\n\t\t\t\t\tsrc[i] = dat[i] ^ msk[i];\n\t\t\t\tbreak;\n\t\t\tcase ROP_COPY:\n\t\t\tdefault:\n\t\t\t\tfor (i = 0; i < s_pitch * cursor->image.height; i++)\n\t\t\t\t\tsrc[i] = dat[i] & msk[i];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfb_pad_aligned_buffer(data, d_pitch, src, s_pitch,\n\t\t\t\t\t\tcursor->image.height);\n\n\t\t\tbg = ((info->cmap.red[bg_idx] & 0xf8) << 7) |\n\t\t\t\t((info->cmap.green[bg_idx] & 0xf8) << 2) |\n\t\t\t\t((info->cmap.blue[bg_idx] & 0xf8) >> 3) |\n\t\t\t\t1 << 15;\n\n\t\t\tfg = ((info->cmap.red[fg_idx] & 0xf8) << 7) |\n\t\t\t\t((info->cmap.green[fg_idx] & 0xf8) << 2) |\n\t\t\t\t((info->cmap.blue[fg_idx] & 0xf8) >> 3) |\n\t\t\t\t1 << 15;\n\n\t\t\tpar->riva.LockUnlock(&par->riva, 0);\n\n\t\t\trivafb_load_cursor_image(par, data, bg, fg,\n\t\t\t\t\t\t cursor->image.width,\n\t\t\t\t\t\t cursor->image.height);\n\t\t\tkfree(src);\n\t\t}\n\t}\n\n\tif (cursor->enable)\n\t\tpar->riva.ShowHideCursor(&par->riva, 1);\n\n\treturn 0;\n}\n\nstatic int rivafb_sync(struct fb_info *info)\n{\n\tstruct riva_par *par = info->par;\n\n\twait_for_idle(par);\n\treturn 0;\n}\n\n \n\n \nstatic const struct fb_ops riva_fb_ops = {\n\t.owner \t\t= THIS_MODULE,\n\t.fb_open\t= rivafb_open,\n\t.fb_release\t= rivafb_release,\n\t.fb_check_var \t= rivafb_check_var,\n\t.fb_set_par \t= rivafb_set_par,\n\t.fb_setcolreg \t= rivafb_setcolreg,\n\t.fb_pan_display\t= rivafb_pan_display,\n\t.fb_blank \t= rivafb_blank,\n\t.fb_fillrect \t= rivafb_fillrect,\n\t.fb_copyarea \t= rivafb_copyarea,\n\t.fb_imageblit \t= rivafb_imageblit,\n\t.fb_cursor\t= rivafb_cursor,\n\t.fb_sync \t= rivafb_sync,\n};\n\nstatic int riva_set_fbinfo(struct fb_info *info)\n{\n\tunsigned int cmap_len;\n\tstruct riva_par *par = info->par;\n\n\tNVTRACE_ENTER();\n\tinfo->flags = FBINFO_HWACCEL_XPAN\n\t\t    | FBINFO_HWACCEL_YPAN\n\t\t    | FBINFO_HWACCEL_COPYAREA\n\t\t    | FBINFO_HWACCEL_FILLRECT\n\t            | FBINFO_HWACCEL_IMAGEBLIT;\n\n\t \n\tif ((par->riva.Architecture == NV_ARCH_30) || noaccel) {\n\t    \tprintk(KERN_DEBUG PFX \"disabling acceleration\\n\");\n  \t\tinfo->flags |= FBINFO_HWACCEL_DISABLED;\n\t}\n\n\tinfo->var = rivafb_default_var;\n\tinfo->fix.visual = (info->var.bits_per_pixel == 8) ?\n\t\t\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\n\n\tinfo->pseudo_palette = par->pseudo_palette;\n\n\tcmap_len = riva_get_cmap_len(&info->var);\n\tfb_alloc_cmap(&info->cmap, cmap_len, 0);\n\n\tinfo->pixmap.size = 8 * 1024;\n\tinfo->pixmap.buf_align = 4;\n\tinfo->pixmap.access_align = 32;\n\tinfo->pixmap.flags = FB_PIXMAP_SYSTEM;\n\tinfo->var.yres_virtual = -1;\n\tNVTRACE_LEAVE();\n\treturn (rivafb_check_var(&info->var, info));\n}\n\nstatic int riva_get_EDID_OF(struct fb_info *info, struct pci_dev *pd)\n{\n\tstruct riva_par *par = info->par;\n\tstruct device_node *dp;\n\tconst unsigned char *pedid = NULL;\n\tconst unsigned char *disptype = NULL;\n\tstatic char *propnames[] = {\n\t\t\"DFP,EDID\", \"LCD,EDID\", \"EDID\", \"EDID1\", \"EDID,B\", \"EDID,A\", NULL };\n\tint i;\n\n\tNVTRACE_ENTER();\n\tdp = pci_device_to_OF_node(pd);\n\tfor (; dp != NULL; dp = dp->child) {\n\t\tdisptype = of_get_property(dp, \"display-type\", NULL);\n\t\tif (disptype == NULL)\n\t\t\tcontinue;\n\t\tif (strncmp(disptype, \"LCD\", 3) != 0)\n\t\t\tcontinue;\n\t\tfor (i = 0; propnames[i] != NULL; ++i) {\n\t\t\tpedid = of_get_property(dp, propnames[i], NULL);\n\t\t\tif (pedid != NULL) {\n\t\t\t\tpar->EDID = (unsigned char *)pedid;\n\t\t\t\tNVTRACE(\"LCD found.\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tNVTRACE_LEAVE();\n\treturn 0;\n}\n\n#if defined(CONFIG_FB_RIVA_I2C)\nstatic int riva_get_EDID_i2c(struct fb_info *info)\n{\n\tstruct riva_par *par = info->par;\n\tstruct fb_var_screeninfo var;\n\tint i;\n\n\tNVTRACE_ENTER();\n\tpar->riva.LockUnlock(&par->riva, 0);\n\triva_create_i2c_busses(par);\n\tfor (i = 0; i < 3; i++) {\n\t\tif (!par->chan[i].par)\n\t\t\tcontinue;\n\t\triva_probe_i2c_connector(par, i, &par->EDID);\n\t\tif (par->EDID && !fb_parse_edid(par->EDID, &var)) {\n\t\t\tprintk(PFX \"Found EDID Block from BUS %i\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tNVTRACE_LEAVE();\n\treturn (par->EDID) ? 1 : 0;\n}\n#endif  \n\nstatic void riva_update_default_var(struct fb_var_screeninfo *var,\n\t\t\t\t    struct fb_info *info)\n{\n\tstruct fb_monspecs *specs = &info->monspecs;\n\tstruct fb_videomode modedb;\n\n\tNVTRACE_ENTER();\n\t \n\tif (mode_option) {\n\t\tfb_find_mode(var, info, mode_option,\n\t\t\t     specs->modedb, specs->modedb_len,\n\t\t\t     NULL, 8);\n\t} else if (specs->modedb != NULL) {\n\t\t \n\t\tmodedb = specs->modedb[0];\n\t\t \n\t\tif (info->monspecs.misc & FB_MISC_1ST_DETAIL) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < specs->modedb_len; i++) {\n\t\t\t\tif (specs->modedb[i].flag & FB_MODE_IS_FIRST) {\n\t\t\t\t\tmodedb = specs->modedb[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar->bits_per_pixel = 8;\n\t\triva_update_var(var, &modedb);\n\t}\n\tNVTRACE_LEAVE();\n}\n\n\nstatic void riva_get_EDID(struct fb_info *info, struct pci_dev *pdev)\n{\n\tNVTRACE_ENTER();\n\tif (riva_get_EDID_OF(info, pdev)) {\n\t\tNVTRACE_LEAVE();\n\t\treturn;\n\t}\n\tif (IS_ENABLED(CONFIG_OF))\n\t\tprintk(PFX \"could not retrieve EDID from OF\\n\");\n#if defined(CONFIG_FB_RIVA_I2C)\n\tif (!riva_get_EDID_i2c(info))\n\t\tprintk(PFX \"could not retrieve EDID from DDC/I2C\\n\");\n#endif\n\tNVTRACE_LEAVE();\n}\n\n\nstatic void riva_get_edidinfo(struct fb_info *info)\n{\n\tstruct fb_var_screeninfo *var = &rivafb_default_var;\n\tstruct riva_par *par = info->par;\n\n\tfb_edid_to_monspecs(par->EDID, &info->monspecs);\n\tfb_videomode_to_modelist(info->monspecs.modedb, info->monspecs.modedb_len,\n\t\t\t\t &info->modelist);\n\triva_update_default_var(var, info);\n\n\t \n\tif (info->monspecs.input & FB_DISP_DDI)\n\t\tpar->FlatPanel = 1;\n}\n\n \n\nstatic u32 riva_get_arch(struct pci_dev *pd)\n{\n    \tu32 arch = 0;\n\n\tswitch (pd->device & 0x0ff0) {\n\t\tcase 0x0100:    \n\t\tcase 0x0110:    \n\t\tcase 0x0150:    \n\t\tcase 0x0170:    \n\t\tcase 0x0180:    \n\t\tcase 0x01A0:    \n\t\tcase 0x01F0:    \n\t\t     arch =  NV_ARCH_10;\n\t\t     break;\n\t\tcase 0x0200:    \n\t\tcase 0x0250:    \n\t\tcase 0x0280:    \n\t\t     arch =  NV_ARCH_20;\n\t\t     break;\n\t\tcase 0x0300:    \n\t\tcase 0x0310:    \n\t\tcase 0x0320:    \n\t\tcase 0x0330:    \n\t\tcase 0x0340:    \n\t\t     arch =  NV_ARCH_30;\n\t\t     break;\n\t\tcase 0x0020:    \n\t\t     arch =  NV_ARCH_04;\n\t\t     break;\n\t\tcase 0x0010:    \n\t\t     arch =  NV_ARCH_03;\n\t\t     break;\n\t\tdefault:    \n\t\t     break;\n\t}\n\treturn arch;\n}\n\nstatic int rivafb_probe(struct pci_dev *pd, const struct pci_device_id *ent)\n{\n\tstruct riva_par *default_par;\n\tstruct fb_info *info;\n\tint ret;\n\n\tNVTRACE_ENTER();\n\tassert(pd != NULL);\n\n\tret = aperture_remove_conflicting_pci_devices(pd, \"rivafb\");\n\tif (ret)\n\t\treturn ret;\n\n\tinfo = framebuffer_alloc(sizeof(struct riva_par), &pd->dev);\n\tif (!info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_ret;\n\t}\n\tdefault_par = info->par;\n\tdefault_par->pdev = pd;\n\n\tinfo->pixmap.addr = kzalloc(8 * 1024, GFP_KERNEL);\n\tif (info->pixmap.addr == NULL) {\n\t    \tret = -ENOMEM;\n\t\tgoto err_framebuffer_release;\n\t}\n\n\tret = pci_enable_device(pd);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR PFX \"cannot enable PCI device\\n\");\n\t\tgoto err_free_pixmap;\n\t}\n\n\tret = pci_request_regions(pd, \"rivafb\");\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR PFX \"cannot request PCI regions\\n\");\n\t\tgoto err_disable_device;\n\t}\n\n\tmutex_init(&default_par->open_lock);\n\tdefault_par->riva.Architecture = riva_get_arch(pd);\n\n\tdefault_par->Chipset = (pd->vendor << 16) | pd->device;\n\tprintk(KERN_INFO PFX \"nVidia device/chipset %X\\n\",default_par->Chipset);\n\n\tif(default_par->riva.Architecture == 0) {\n\t\tprintk(KERN_ERR PFX \"unknown NV_ARCH\\n\");\n\t\tret=-ENODEV;\n\t\tgoto err_release_region;\n\t}\n\tif(default_par->riva.Architecture == NV_ARCH_10 ||\n\t   default_par->riva.Architecture == NV_ARCH_20 ||\n\t   default_par->riva.Architecture == NV_ARCH_30) {\n\t\tsprintf(rivafb_fix.id, \"NV%x\", (pd->device & 0x0ff0) >> 4);\n\t} else {\n\t\tsprintf(rivafb_fix.id, \"NV%x\", default_par->riva.Architecture);\n\t}\n\n\tdefault_par->FlatPanel = flatpanel;\n\tif (flatpanel == 1)\n\t\tprintk(KERN_INFO PFX \"flatpanel support enabled\\n\");\n\tdefault_par->forceCRTC = forceCRTC;\n\n\trivafb_fix.mmio_len = pci_resource_len(pd, 0);\n\trivafb_fix.smem_len = pci_resource_len(pd, 1);\n\n\t{\n\t\t \n\t\tunsigned short cmd;\n\n\t\tpci_read_config_word(pd, PCI_COMMAND, &cmd);\n\t\tcmd |= (PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\t\tpci_write_config_word(pd, PCI_COMMAND, cmd);\n\t}\n\n\trivafb_fix.mmio_start = pci_resource_start(pd, 0);\n\trivafb_fix.smem_start = pci_resource_start(pd, 1);\n\n\tdefault_par->ctrl_base = ioremap(rivafb_fix.mmio_start,\n\t\t\t\t\t rivafb_fix.mmio_len);\n\tif (!default_par->ctrl_base) {\n\t\tprintk(KERN_ERR PFX \"cannot ioremap MMIO base\\n\");\n\t\tret = -EIO;\n\t\tgoto err_release_region;\n\t}\n\n\tswitch (default_par->riva.Architecture) {\n\tcase NV_ARCH_03:\n\t\t \n\t\tdefault_par->riva.PRAMIN = ioremap(rivafb_fix.smem_start + 0x00C00000, 0x00008000);\n\t\tif (!default_par->riva.PRAMIN) {\n\t\t\tprintk(KERN_ERR PFX \"cannot ioremap PRAMIN region\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto err_iounmap_ctrl_base;\n\t\t}\n\t\tbreak;\n\tcase NV_ARCH_04:\n\tcase NV_ARCH_10:\n\tcase NV_ARCH_20:\n\tcase NV_ARCH_30:\n\t\tdefault_par->riva.PCRTC0 =\n\t\t\t(u32 __iomem *)(default_par->ctrl_base + 0x00600000);\n\t\tdefault_par->riva.PRAMIN =\n\t\t\t(u32 __iomem *)(default_par->ctrl_base + 0x00710000);\n\t\tbreak;\n\t}\n\triva_common_setup(default_par);\n\n\tif (default_par->riva.Architecture == NV_ARCH_03) {\n\t\tdefault_par->riva.PCRTC = default_par->riva.PCRTC0\n\t\t                        = default_par->riva.PGRAPH;\n\t}\n\n\trivafb_fix.smem_len = riva_get_memlen(default_par) * 1024;\n\tdefault_par->dclk_max = riva_get_maxdclk(default_par) * 1000;\n\tinfo->screen_base = ioremap_wc(rivafb_fix.smem_start,\n\t\t\t\t       rivafb_fix.smem_len);\n\tif (!info->screen_base) {\n\t\tprintk(KERN_ERR PFX \"cannot ioremap FB base\\n\");\n\t\tret = -EIO;\n\t\tgoto err_iounmap_pramin;\n\t}\n\n\tif (!nomtrr)\n\t\tdefault_par->wc_cookie =\n\t\t\tarch_phys_wc_add(rivafb_fix.smem_start,\n\t\t\t\t\t rivafb_fix.smem_len);\n\n\tinfo->fbops = &riva_fb_ops;\n\tinfo->fix = rivafb_fix;\n\triva_get_EDID(info, pd);\n\triva_get_edidinfo(info);\n\n\tret=riva_set_fbinfo(info);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR PFX \"error setting initial video mode\\n\");\n\t\tgoto err_iounmap_screen_base;\n\t}\n\n\tfb_destroy_modedb(info->monspecs.modedb);\n\tinfo->monspecs.modedb = NULL;\n\n\tpci_set_drvdata(pd, info);\n\n\tret = register_framebuffer(info);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR PFX\n\t\t\t\"error registering riva framebuffer\\n\");\n\t\tgoto err_iounmap_screen_base;\n\t}\n\n\tif (backlight)\n\t\triva_bl_init(info->par);\n\n\tprintk(KERN_INFO PFX\n\t\t\"PCI nVidia %s framebuffer ver %s (%dMB @ 0x%lX)\\n\",\n\t\tinfo->fix.id,\n\t\tRIVAFB_VERSION,\n\t\tinfo->fix.smem_len / (1024 * 1024),\n\t\tinfo->fix.smem_start);\n\n\tNVTRACE_LEAVE();\n\treturn 0;\n\nerr_iounmap_screen_base:\n#ifdef CONFIG_FB_RIVA_I2C\n\triva_delete_i2c_busses(info->par);\n#endif\n\tiounmap(info->screen_base);\nerr_iounmap_pramin:\n\tif (default_par->riva.Architecture == NV_ARCH_03)\n\t\tiounmap(default_par->riva.PRAMIN);\nerr_iounmap_ctrl_base:\n\tiounmap(default_par->ctrl_base);\nerr_release_region:\n\tpci_release_regions(pd);\nerr_disable_device:\nerr_free_pixmap:\n\tkfree(info->pixmap.addr);\nerr_framebuffer_release:\n\tframebuffer_release(info);\nerr_ret:\n\treturn ret;\n}\n\nstatic void rivafb_remove(struct pci_dev *pd)\n{\n\tstruct fb_info *info = pci_get_drvdata(pd);\n\tstruct riva_par *par = info->par;\n\n\tNVTRACE_ENTER();\n\n#ifdef CONFIG_FB_RIVA_I2C\n\triva_delete_i2c_busses(par);\n\tkfree(par->EDID);\n#endif\n\n\triva_bl_exit(info);\n\tunregister_framebuffer(info);\n\n\tarch_phys_wc_del(par->wc_cookie);\n\tiounmap(par->ctrl_base);\n\tiounmap(info->screen_base);\n\tif (par->riva.Architecture == NV_ARCH_03)\n\t\tiounmap(par->riva.PRAMIN);\n\tpci_release_regions(pd);\n\tkfree(info->pixmap.addr);\n\tframebuffer_release(info);\n\tNVTRACE_LEAVE();\n}\n\n \n\n#ifndef MODULE\nstatic int rivafb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tNVTRACE_ENTER();\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!strncmp(this_opt, \"forceCRTC\", 9)) {\n\t\t\tchar *p;\n\n\t\t\tp = this_opt + 9;\n\t\t\tif (!*p || !*(++p)) continue;\n\t\t\tforceCRTC = *p - '0';\n\t\t\tif (forceCRTC < 0 || forceCRTC > 1)\n\t\t\t\tforceCRTC = -1;\n\t\t} else if (!strncmp(this_opt, \"flatpanel\", 9)) {\n\t\t\tflatpanel = 1;\n\t\t} else if (!strncmp(this_opt, \"backlight:\", 10)) {\n\t\t\tbacklight = simple_strtoul(this_opt+10, NULL, 0);\n\t\t} else if (!strncmp(this_opt, \"nomtrr\", 6)) {\n\t\t\tnomtrr = 1;\n\t\t} else if (!strncmp(this_opt, \"strictmode\", 10)) {\n\t\t\tstrictmode = 1;\n\t\t} else if (!strncmp(this_opt, \"noaccel\", 7)) {\n\t\t\tnoaccel = 1;\n\t\t} else\n\t\t\tmode_option = this_opt;\n\t}\n\tNVTRACE_LEAVE();\n\treturn 0;\n}\n#endif  \n\nstatic struct pci_driver rivafb_driver = {\n\t.name\t\t= \"rivafb\",\n\t.id_table\t= rivafb_pci_tbl,\n\t.probe\t\t= rivafb_probe,\n\t.remove\t\t= rivafb_remove,\n};\n\n\n\n \n\nstatic int rivafb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"rivafb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"rivafb\", &option))\n\t\treturn -ENODEV;\n\trivafb_setup(option);\n#endif\n\treturn pci_register_driver(&rivafb_driver);\n}\n\n\nmodule_init(rivafb_init);\n\nstatic void __exit rivafb_exit(void)\n{\n\tpci_unregister_driver(&rivafb_driver);\n}\n\nmodule_exit(rivafb_exit);\n\nmodule_param(noaccel, bool, 0);\nMODULE_PARM_DESC(noaccel, \"bool: disable acceleration\");\nmodule_param(flatpanel, int, 0);\nMODULE_PARM_DESC(flatpanel, \"Enables experimental flat panel support for some chipsets. (0 or 1=enabled) (default=0)\");\nmodule_param(forceCRTC, int, 0);\nMODULE_PARM_DESC(forceCRTC, \"Forces usage of a particular CRTC in case autodetection fails. (0 or 1) (default=autodetect)\");\nmodule_param(nomtrr, bool, 0);\nMODULE_PARM_DESC(nomtrr, \"Disables MTRR support (0 or 1=disabled) (default=0)\");\nmodule_param(strictmode, bool, 0);\nMODULE_PARM_DESC(strictmode, \"Only use video modes from EDID\");\n\nMODULE_AUTHOR(\"Ani Joshi, maintainer\");\nMODULE_DESCRIPTION(\"Framebuffer driver for nVidia Riva 128, TNT, TNT2, and the GeForce series\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}