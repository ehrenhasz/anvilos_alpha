{
  "module_name": "valkyriefb.c",
  "hash_id": "72e13cf2bb14522534c25a541755fd3f3e94a50e1d87b13d4d99f12dd3f6722e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/valkyriefb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/fb.h>\n#include <linux/selection.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/adb.h>\n#include <linux/cuda.h>\n#include <linux/of_address.h>\n#ifdef CONFIG_MAC\n#include <asm/macintosh.h>\n#endif\n\n#include \"macmodes.h\"\n#include \"valkyriefb.h\"\n\nstatic int default_vmode = VMODE_NVRAM;\nstatic int default_cmode = CMODE_NVRAM;\n\nstruct fb_par_valkyrie {\n\tint\tvmode, cmode;\n\tint\txres, yres;\n\tint\tvxres, vyres;\n\tstruct valkyrie_regvals *init;\n};\n\nstruct fb_info_valkyrie {\n\tstruct fb_info\t\tinfo;\n\tstruct fb_par_valkyrie\tpar;\n\tstruct cmap_regs\t__iomem *cmap_regs;\n\tunsigned long\t\tcmap_regs_phys;\n\n\tstruct valkyrie_regs\t__iomem *valkyrie_regs;\n\tunsigned long\t\tvalkyrie_regs_phys;\n\n\t__u8\t\t\t__iomem *frame_buffer;\n\tunsigned long\t\tframe_buffer_phys;\n\n\tint\t\t\tsense;\n\tunsigned long\t\ttotal_vram;\n\n\tu32\t\t\tpseudo_palette[16];\n};\n\nstatic int valkyriefb_setup(char*);\n\nstatic int valkyriefb_check_var(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info);\nstatic int valkyriefb_set_par(struct fb_info *info);\nstatic int valkyriefb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t     u_int transp, struct fb_info *info);\nstatic int valkyriefb_blank(int blank_mode, struct fb_info *info);\n\nstatic int read_valkyrie_sense(struct fb_info_valkyrie *p);\nstatic void set_valkyrie_clock(unsigned char *params);\nstatic int valkyrie_var_to_par(struct fb_var_screeninfo *var,\n\tstruct fb_par_valkyrie *par, const struct fb_info *fb_info);\n\nstatic int valkyrie_init_info(struct fb_info *info, struct fb_info_valkyrie *p);\nstatic void valkyrie_par_to_fix(struct fb_par_valkyrie *par, struct fb_fix_screeninfo *fix);\nstatic void valkyrie_init_fix(struct fb_fix_screeninfo *fix, struct fb_info_valkyrie *p);\n\nstatic const struct fb_ops valkyriefb_ops = {\n\t.owner =\tTHIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var =\tvalkyriefb_check_var,\n\t.fb_set_par =\tvalkyriefb_set_par,\n\t.fb_setcolreg =\tvalkyriefb_setcolreg,\n\t.fb_blank =\tvalkyriefb_blank,\n};\n\n \nstatic int valkyriefb_set_par(struct fb_info *info)\n{\n\tstruct fb_info_valkyrie *p =\n\t\tcontainer_of(info, struct fb_info_valkyrie, info);\n\tvolatile struct valkyrie_regs __iomem *valkyrie_regs = p->valkyrie_regs;\n\tstruct fb_par_valkyrie *par = info->par;\n\tstruct valkyrie_regvals\t*init;\n\tint err;\n\n\tif ((err = valkyrie_var_to_par(&info->var, par, info)))\n\t\treturn err;\n\n\tvalkyrie_par_to_fix(par, &info->fix);\n\n\t \n\tout_8(&valkyrie_regs->status.r, 0);\n\tudelay(100);\n\n\t \n\tinit = par->init;\n\tout_8(&valkyrie_regs->mode.r, init->mode | 0x80);\n\tout_8(&valkyrie_regs->depth.r, par->cmode + 3);\n\tset_valkyrie_clock(init->clock_params);\n\tudelay(100);\n\n\t \n\tout_8(&valkyrie_regs->mode.r, init->mode);\n\n\treturn 0;\n}\n\nstatic inline int valkyrie_par_to_var(struct fb_par_valkyrie *par,\n\t\t\t\t      struct fb_var_screeninfo *var)\n{\n\treturn mac_vmode_to_var(par->vmode, par->cmode, var);\n}\n\nstatic int\nvalkyriefb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tint err;\n\tstruct fb_par_valkyrie par;\n\n\tif ((err = valkyrie_var_to_par(var, &par, info)))\n\t\treturn err;\n\tvalkyrie_par_to_var(&par, var);\n\treturn 0;\n}\n\n \nstatic int valkyriefb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct fb_info_valkyrie *p =\n\t\tcontainer_of(info, struct fb_info_valkyrie, info);\n\tstruct fb_par_valkyrie *par = info->par;\n\tstruct valkyrie_regvals\t*init = par->init;\n\n\tif (init == NULL)\n\t\treturn 1;\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\t\t\t \n\t\tout_8(&p->valkyrie_regs->mode.r, init->mode);\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\treturn 1;\t \n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\t \n\t\tout_8(&p->valkyrie_regs->mode.r, init->mode | 0x40);\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tout_8(&p->valkyrie_regs->mode.r, 0x66);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int valkyriefb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t     u_int transp, struct fb_info *info)\n{\n\tstruct fb_info_valkyrie *p =\n\t\tcontainer_of(info, struct fb_info_valkyrie, info);\n\tvolatile struct cmap_regs __iomem *cmap_regs = p->cmap_regs;\n\tstruct fb_par_valkyrie *par = info->par;\n\n\tif (regno > 255)\n\t\treturn 1;\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\t \n\tout_8(&p->cmap_regs->addr, regno);\n\tudelay(1);\n\t \n\tout_8(&cmap_regs->lut, red);\n\tout_8(&cmap_regs->lut, green);\n\tout_8(&cmap_regs->lut, blue);\n\n\tif (regno < 16 && par->cmode == CMODE_16)\n\t\t((u32 *)info->pseudo_palette)[regno] =\n\t\t\t(regno << 10) | (regno << 5) | regno;\n\n\treturn 0;\n}\n\nstatic inline int valkyrie_vram_reqd(int video_mode, int color_mode)\n{\n\tint pitch;\n\tstruct valkyrie_regvals *init = valkyrie_reg_init[video_mode-1];\n\n\tif ((pitch = init->pitch[color_mode]) == 0)\n\t\tpitch = 2 * init->pitch[0];\n\treturn init->vres * pitch;\n}\n\nstatic void set_valkyrie_clock(unsigned char *params)\n{\n#ifdef CONFIG_ADB_CUDA\n\tstruct adb_request req;\n\tint i;\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tcuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC,\n\t\t\t     0x50, i + 1, params[i]);\n\t\twhile (!req.complete)\n\t\t\tcuda_poll();\n\t}\n#endif\n}\n\nstatic void __init valkyrie_choose_mode(struct fb_info_valkyrie *p)\n{\n\tp->sense = read_valkyrie_sense(p);\n\tprintk(KERN_INFO \"Monitor sense value = 0x%x\\n\", p->sense);\n\n\t \n#ifdef CONFIG_PPC_PMAC\n\tif (IS_REACHABLE(CONFIG_NVRAM) && default_vmode == VMODE_NVRAM)\n\t\tdefault_vmode = nvram_read_byte(NV_VMODE);\n#endif\n\tif (default_vmode <= 0 || default_vmode > VMODE_MAX ||\n\t    !valkyrie_reg_init[default_vmode - 1]) {\n\t\tdefault_vmode = mac_map_monitor_sense(p->sense);\n\t\tif (!valkyrie_reg_init[default_vmode - 1])\n\t\t\tdefault_vmode = VMODE_640_480_67;\n\t}\n\n#ifdef CONFIG_PPC_PMAC\n\tif (IS_REACHABLE(CONFIG_NVRAM) && default_cmode == CMODE_NVRAM)\n\t\tdefault_cmode = nvram_read_byte(NV_CMODE);\n#endif\n\t \n\tif (default_cmode < CMODE_8 || default_cmode > CMODE_16\n\t    || valkyrie_reg_init[default_vmode-1]->pitch[default_cmode] == 0\n\t    || valkyrie_vram_reqd(default_vmode, default_cmode) > p->total_vram)\n\t\tdefault_cmode = CMODE_8;\n\n\tprintk(KERN_INFO \"using video mode %d and color mode %d.\\n\",\n\t       default_vmode, default_cmode);\n}\n\nstatic int __init valkyriefb_init(void)\n{\n\tstruct fb_info_valkyrie\t*p;\n\tunsigned long frame_buffer_phys, cmap_regs_phys;\n\tint err;\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"valkyriefb\", &option))\n\t\treturn -ENODEV;\n\tvalkyriefb_setup(option);\n\n#ifdef CONFIG_MAC\n\tif (!MACH_IS_MAC)\n\t\treturn -ENODEV;\n\tif (!(mac_bi_data.id == MAC_MODEL_Q630\n\t       \n\t    || mac_bi_data.id == MAC_MODEL_P588))\n\t\treturn -ENODEV;\n\n\t \n\tframe_buffer_phys = 0xf9000000;\n\tcmap_regs_phys = 0x50f24000;\n#else  \n\t{\n\t\tstruct device_node *dp;\n\t\tstruct resource r;\n\n\t\tdp = of_find_node_by_name(NULL, \"valkyrie\");\n\t\tif (!dp)\n\t\t\treturn 0;\n\n\t\tif (of_address_to_resource(dp, 0, &r)) {\n\t\t\tprintk(KERN_ERR \"can't find address for valkyrie\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tframe_buffer_phys = r.start;\n\t\tcmap_regs_phys = r.start + 0x304000;\n\t}\n#endif  \n\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!request_mem_region(frame_buffer_phys, 0x100000, \"valkyriefb\")) {\n\t\tkfree(p);\n\t\treturn 0;\n\t}\n\tp->total_vram = 0x100000;\n\tp->frame_buffer_phys = frame_buffer_phys;\n#ifdef CONFIG_MAC\n\tp->frame_buffer = ioremap(frame_buffer_phys, p->total_vram);\n#else\n\tp->frame_buffer = ioremap_wt(frame_buffer_phys, p->total_vram);\n#endif\n\tp->cmap_regs_phys = cmap_regs_phys;\n\tp->cmap_regs = ioremap(p->cmap_regs_phys, 0x1000);\n\tp->valkyrie_regs_phys = cmap_regs_phys+0x6000;\n\tp->valkyrie_regs = ioremap(p->valkyrie_regs_phys, 0x1000);\n\terr = -ENOMEM;\n\tif (p->frame_buffer == NULL || p->cmap_regs == NULL\n\t    || p->valkyrie_regs == NULL) {\n\t\tprintk(KERN_ERR \"valkyriefb: couldn't map resources\\n\");\n\t\tgoto out_free;\n\t}\n\n\tvalkyrie_choose_mode(p);\n\tmac_vmode_to_var(default_vmode, default_cmode, &p->info.var);\n\terr = valkyrie_init_info(&p->info, p);\n\tif (err < 0)\n\t\tgoto out_free;\n\tvalkyrie_init_fix(&p->info.fix, p);\n\tif (valkyriefb_set_par(&p->info))\n\t\t \n\t\tprintk(KERN_ERR \"valkyriefb: can't set default video mode\\n\");\n\n\tif ((err = register_framebuffer(&p->info)) != 0)\n\t\tgoto out_cmap_free;\n\n\tfb_info(&p->info, \"valkyrie frame buffer device\\n\");\n\treturn 0;\n\n out_cmap_free:\n\tfb_dealloc_cmap(&p->info.cmap);\n out_free:\n\tif (p->frame_buffer)\n\t\tiounmap(p->frame_buffer);\n\tif (p->cmap_regs)\n\t\tiounmap(p->cmap_regs);\n\tif (p->valkyrie_regs)\n\t\tiounmap(p->valkyrie_regs);\n\tkfree(p);\n\treturn err;\n}\n\n \nstatic int read_valkyrie_sense(struct fb_info_valkyrie *p)\n{\n\tint sense, in;\n\n\tout_8(&p->valkyrie_regs->msense.r, 0);    \n\t__delay(20000);\n\tsense = ((in = in_8(&p->valkyrie_regs->msense.r)) & 0x70) << 4;\n\t \n\tout_8(&p->valkyrie_regs->msense.r, 4);    \n\t__delay(20000);\n\tsense |= ((in = in_8(&p->valkyrie_regs->msense.r)) & 0x30);\n\tout_8(&p->valkyrie_regs->msense.r, 2);    \n\t__delay(20000);\n\tsense |= ((in = in_8(&p->valkyrie_regs->msense.r)) & 0x40) >> 3;\n\tsense |= (in & 0x10) >> 2;\n\tout_8(&p->valkyrie_regs->msense.r, 1);    \n\t__delay(20000);\n\tsense |= ((in = in_8(&p->valkyrie_regs->msense.r)) & 0x60) >> 5;\n\n\tout_8(&p->valkyrie_regs->msense.r, 7);\n\n\treturn sense;\n}\n\n \n\n \n\nstatic int valkyrie_var_to_par(struct fb_var_screeninfo *var,\n\tstruct fb_par_valkyrie *par, const struct fb_info *fb_info)\n{\n\tint vmode, cmode;\n\tstruct valkyrie_regvals *init;\n\tstruct fb_info_valkyrie *p =\n\t\tcontainer_of(fb_info, struct fb_info_valkyrie, info);\n\n\tif (mac_var_to_vmode(var, &vmode, &cmode) != 0) {\n\t\tprintk(KERN_ERR \"valkyriefb: can't do %dx%dx%d.\\n\",\n\t\t       var->xres, var->yres, var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (vmode < 1 || vmode > VMODE_MAX || !valkyrie_reg_init[vmode-1]) {\n\t\tprintk(KERN_ERR \"valkyriefb: vmode %d not valid.\\n\", vmode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmode != CMODE_8 && cmode != CMODE_16) {\n\t\tprintk(KERN_ERR \"valkyriefb: cmode %d not valid.\\n\", cmode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->xres_virtual > var->xres || var->yres_virtual > var->yres\n\t    || var->xoffset != 0 || var->yoffset != 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tinit = valkyrie_reg_init[vmode-1];\n\tif (init->pitch[cmode] == 0) {\n\t\tprintk(KERN_ERR \"valkyriefb: vmode %d does not support \"\n\t\t       \"cmode %d.\\n\", vmode, cmode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (valkyrie_vram_reqd(vmode, cmode) > p->total_vram) {\n\t\tprintk(KERN_ERR \"valkyriefb: not enough ram for vmode %d, \"\n\t\t       \"cmode %d.\\n\", vmode, cmode);\n\t\treturn -EINVAL;\n\t}\n\n\tpar->vmode = vmode;\n\tpar->cmode = cmode;\n\tpar->init = init;\n\tpar->xres = var->xres;\n\tpar->yres = var->yres;\n\tpar->vxres = par->xres;\n\tpar->vyres = par->yres;\n\n\treturn 0;\n}\n\nstatic void valkyrie_init_fix(struct fb_fix_screeninfo *fix, struct fb_info_valkyrie *p)\n{\n\tmemset(fix, 0, sizeof(*fix));\n\tstrcpy(fix->id, \"valkyrie\");\n\tfix->mmio_start = p->valkyrie_regs_phys;\n\tfix->mmio_len = sizeof(struct valkyrie_regs);\n\tfix->type = FB_TYPE_PACKED_PIXELS;\n\tfix->smem_start = p->frame_buffer_phys + 0x1000;\n\tfix->smem_len = p->total_vram;\n\n\tfix->type_aux = 0;\n\tfix->ywrapstep = 0;\n\tfix->ypanstep = 0;\n\tfix->xpanstep = 0;\n\n}\n\n \nstatic void valkyrie_par_to_fix(struct fb_par_valkyrie *par,\n\tstruct fb_fix_screeninfo *fix)\n{\n\tfix->smem_len = valkyrie_vram_reqd(par->vmode, par->cmode);\n\tfix->visual = (par->cmode == CMODE_8) ?\n\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\n\tfix->line_length = par->vxres << par->cmode;\n\t\t \n}\n\nstatic int __init valkyrie_init_info(struct fb_info *info,\n\t\tstruct fb_info_valkyrie *p)\n{\n\tinfo->fbops = &valkyriefb_ops;\n\tinfo->screen_base = p->frame_buffer + 0x1000;\n\tinfo->pseudo_palette = p->pseudo_palette;\n\tinfo->par = &p->par;\n\treturn fb_alloc_cmap(&info->cmap, 256, 0);\n}\n\n\n \nstatic int __init valkyriefb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!strncmp(this_opt, \"vmode:\", 6)) {\n\t    \t\tint vmode = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\tif (vmode > 0 && vmode <= VMODE_MAX)\n\t\t\t\tdefault_vmode = vmode;\n\t\t}\n\t\telse if (!strncmp(this_opt, \"cmode:\", 6)) {\n\t\t\tint depth = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\tswitch (depth) {\n\t\t\tcase 8:\n\t\t\t\tdefault_cmode = CMODE_8;\n\t\t\t\tbreak;\n\t\t\tcase 15:\n\t\t\tcase 16:\n\t\t\t\tdefault_cmode = CMODE_16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nmodule_init(valkyriefb_init);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}