{
  "module_name": "tridentfb.c",
  "hash_id": "678aaddb5532c5e8e5c1dbfb98354d06b2fd8c458eb8f300e7a9616070396b91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/tridentfb.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <linux/delay.h>\n#include <video/vga.h>\n#include <video/trident.h>\n\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n\nstruct tridentfb_par {\n\tvoid __iomem *io_virt;\t \n\tu32 pseudo_pal[16];\n\tint chip_id;\n\tint flatpanel;\n\tvoid (*init_accel) (struct tridentfb_par *, int, int);\n\tvoid (*wait_engine) (struct tridentfb_par *);\n\tvoid (*fill_rect)\n\t\t(struct tridentfb_par *par, u32, u32, u32, u32, u32, u32);\n\tvoid (*copy_rect)\n\t\t(struct tridentfb_par *par, u32, u32, u32, u32, u32, u32);\n\tvoid (*image_blit)\n\t\t(struct tridentfb_par *par, const char*,\n\t\t u32, u32, u32, u32, u32, u32);\n\tunsigned char eng_oper;\t \n\tbool ddc_registered;\n\tstruct i2c_adapter ddc_adapter;\n\tstruct i2c_algo_bit_data ddc_algo;\n};\n\nstatic struct fb_fix_screeninfo tridentfb_fix = {\n\t.id = \"Trident\",\n\t.type = FB_TYPE_PACKED_PIXELS,\n\t.ypanstep = 1,\n\t.visual = FB_VISUAL_PSEUDOCOLOR,\n\t.accel = FB_ACCEL_NONE,\n};\n\n \n\n \nstatic char *mode_option;\nstatic int bpp = 8;\n\nstatic int noaccel;\n\nstatic int center;\nstatic int stretch;\n\nstatic int fp;\nstatic int crt;\n\nstatic int memsize;\nstatic int memdiff;\nstatic int nativex;\n\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Initial video mode e.g. '648x480-8@60'\");\nmodule_param_named(mode, mode_option, charp, 0);\nMODULE_PARM_DESC(mode, \"Initial video mode e.g. '648x480-8@60' (deprecated)\");\nmodule_param(bpp, int, 0);\nmodule_param(center, int, 0);\nmodule_param(stretch, int, 0);\nmodule_param(noaccel, int, 0);\nmodule_param(memsize, int, 0);\nmodule_param(memdiff, int, 0);\nmodule_param(nativex, int, 0);\nmodule_param(fp, int, 0);\nMODULE_PARM_DESC(fp, \"Define if flatpanel is connected\");\nmodule_param(crt, int, 0);\nMODULE_PARM_DESC(crt, \"Define if CRT is connected\");\n\nstatic inline int is_oldclock(int id)\n{\n\treturn\t(id == TGUI9440) ||\n\t\t(id == TGUI9660) ||\n\t\t(id == CYBER9320);\n}\n\nstatic inline int is_oldprotect(int id)\n{\n\treturn\tis_oldclock(id) ||\n\t\t(id == PROVIDIA9685) ||\n\t\t(id == CYBER9382) ||\n\t\t(id == CYBER9385);\n}\n\nstatic inline int is_blade(int id)\n{\n\treturn\t(id == BLADE3D) ||\n\t\t(id == CYBERBLADEE4) ||\n\t\t(id == CYBERBLADEi7) ||\n\t\t(id == CYBERBLADEi7D) ||\n\t\t(id == CYBERBLADEi1) ||\n\t\t(id == CYBERBLADEi1D) ||\n\t\t(id == CYBERBLADEAi1) ||\n\t\t(id == CYBERBLADEAi1D);\n}\n\nstatic inline int is_xp(int id)\n{\n\treturn\t(id == CYBERBLADEXPAi1) ||\n\t\t(id == CYBERBLADEXPm8) ||\n\t\t(id == CYBERBLADEXPm16);\n}\n\nstatic inline int is3Dchip(int id)\n{\n\treturn\tis_blade(id) || is_xp(id) ||\n\t\t(id == CYBER9397) || (id == CYBER9397DVD) ||\n\t\t(id == CYBER9520) || (id == CYBER9525DVD) ||\n\t\t(id == IMAGE975) || (id == IMAGE985);\n}\n\nstatic inline int iscyber(int id)\n{\n\tswitch (id) {\n\tcase CYBER9388:\n\tcase CYBER9382:\n\tcase CYBER9385:\n\tcase CYBER9397:\n\tcase CYBER9397DVD:\n\tcase CYBER9520:\n\tcase CYBER9525DVD:\n\tcase CYBERBLADEE4:\n\tcase CYBERBLADEi7D:\n\tcase CYBERBLADEi1:\n\tcase CYBERBLADEi1D:\n\tcase CYBERBLADEAi1:\n\tcase CYBERBLADEAi1D:\n\tcase CYBERBLADEXPAi1:\n\t\treturn 1;\n\n\tcase CYBER9320:\n\tcase CYBERBLADEi7:\t \n\tdefault:\n\t\t \n\t\t \n\t\treturn 0;\n\t}\n}\n\nstatic inline void t_outb(struct tridentfb_par *p, u8 val, u16 reg)\n{\n\tfb_writeb(val, p->io_virt + reg);\n}\n\nstatic inline u8 t_inb(struct tridentfb_par *p, u16 reg)\n{\n\treturn fb_readb(p->io_virt + reg);\n}\n\nstatic inline void writemmr(struct tridentfb_par *par, u16 r, u32 v)\n{\n\tfb_writel(v, par->io_virt + r);\n}\n\nstatic inline u32 readmmr(struct tridentfb_par *par, u16 r)\n{\n\treturn fb_readl(par->io_virt + r);\n}\n\n#define DDC_SDA_TGUI\t\tBIT(0)\n#define DDC_SCL_TGUI\t\tBIT(1)\n#define DDC_SCL_DRIVE_TGUI\tBIT(2)\n#define DDC_SDA_DRIVE_TGUI\tBIT(3)\n#define DDC_MASK_TGUI\t\t(DDC_SCL_DRIVE_TGUI | DDC_SDA_DRIVE_TGUI)\n\nstatic void tridentfb_ddc_setscl_tgui(void *data, int val)\n{\n\tstruct tridentfb_par *par = data;\n\tu8 reg = vga_mm_rcrt(par->io_virt, I2C) & DDC_MASK_TGUI;\n\n\tif (val)\n\t\treg &= ~DDC_SCL_DRIVE_TGUI;  \n\telse\n\t\treg |= DDC_SCL_DRIVE_TGUI;  \n\n\tvga_mm_wcrt(par->io_virt, I2C, reg);\n}\n\nstatic void tridentfb_ddc_setsda_tgui(void *data, int val)\n{\n\tstruct tridentfb_par *par = data;\n\tu8 reg = vga_mm_rcrt(par->io_virt, I2C) & DDC_MASK_TGUI;\n\n\tif (val)\n\t\treg &= ~DDC_SDA_DRIVE_TGUI;  \n\telse\n\t\treg |= DDC_SDA_DRIVE_TGUI;  \n\n\tvga_mm_wcrt(par->io_virt, I2C, reg);\n}\n\nstatic int tridentfb_ddc_getsda_tgui(void *data)\n{\n\tstruct tridentfb_par *par = data;\n\n\treturn !!(vga_mm_rcrt(par->io_virt, I2C) & DDC_SDA_TGUI);\n}\n\n#define DDC_SDA_IN\tBIT(0)\n#define DDC_SCL_OUT\tBIT(1)\n#define DDC_SDA_OUT\tBIT(3)\n#define DDC_SCL_IN\tBIT(6)\n#define DDC_MASK\t(DDC_SCL_OUT | DDC_SDA_OUT)\n\nstatic void tridentfb_ddc_setscl(void *data, int val)\n{\n\tstruct tridentfb_par *par = data;\n\tunsigned char reg;\n\n\treg = vga_mm_rcrt(par->io_virt, I2C) & DDC_MASK;\n\tif (val)\n\t\treg |= DDC_SCL_OUT;\n\telse\n\t\treg &= ~DDC_SCL_OUT;\n\tvga_mm_wcrt(par->io_virt, I2C, reg);\n}\n\nstatic void tridentfb_ddc_setsda(void *data, int val)\n{\n\tstruct tridentfb_par *par = data;\n\tunsigned char reg;\n\n\treg = vga_mm_rcrt(par->io_virt, I2C) & DDC_MASK;\n\tif (!val)\n\t\treg |= DDC_SDA_OUT;\n\telse\n\t\treg &= ~DDC_SDA_OUT;\n\tvga_mm_wcrt(par->io_virt, I2C, reg);\n}\n\nstatic int tridentfb_ddc_getscl(void *data)\n{\n\tstruct tridentfb_par *par = data;\n\n\treturn !!(vga_mm_rcrt(par->io_virt, I2C) & DDC_SCL_IN);\n}\n\nstatic int tridentfb_ddc_getsda(void *data)\n{\n\tstruct tridentfb_par *par = data;\n\n\treturn !!(vga_mm_rcrt(par->io_virt, I2C) & DDC_SDA_IN);\n}\n\nstatic int tridentfb_setup_ddc_bus(struct fb_info *info)\n{\n\tstruct tridentfb_par *par = info->par;\n\n\tstrscpy(par->ddc_adapter.name, info->fix.id,\n\t\tsizeof(par->ddc_adapter.name));\n\tpar->ddc_adapter.owner\t\t= THIS_MODULE;\n\tpar->ddc_adapter.class\t\t= I2C_CLASS_DDC;\n\tpar->ddc_adapter.algo_data\t= &par->ddc_algo;\n\tpar->ddc_adapter.dev.parent\t= info->device;\n\tif (is_oldclock(par->chip_id)) {  \n\t\tpar->ddc_algo.setsda\t= tridentfb_ddc_setsda_tgui;\n\t\tpar->ddc_algo.setscl\t= tridentfb_ddc_setscl_tgui;\n\t\tpar->ddc_algo.getsda\t= tridentfb_ddc_getsda_tgui;\n\t\t \n\t} else {\n\t\tpar->ddc_algo.setsda\t= tridentfb_ddc_setsda;\n\t\tpar->ddc_algo.setscl\t= tridentfb_ddc_setscl;\n\t\tpar->ddc_algo.getsda\t= tridentfb_ddc_getsda;\n\t\tpar->ddc_algo.getscl\t= tridentfb_ddc_getscl;\n\t}\n\tpar->ddc_algo.udelay\t\t= 10;\n\tpar->ddc_algo.timeout\t\t= 20;\n\tpar->ddc_algo.data\t\t= par;\n\n\ti2c_set_adapdata(&par->ddc_adapter, par);\n\n\treturn i2c_bit_add_bus(&par->ddc_adapter);\n}\n\n \n\n#define point(x, y) ((y) << 16 | (x))\n\nstatic void blade_init_accel(struct tridentfb_par *par, int pitch, int bpp)\n{\n\tint v1 = (pitch >> 3) << 20;\n\tint tmp = bpp == 24 ? 2 : (bpp >> 4);\n\tint v2 = v1 | (tmp << 29);\n\n\twritemmr(par, 0x21C0, v2);\n\twritemmr(par, 0x21C4, v2);\n\twritemmr(par, 0x21B8, v2);\n\twritemmr(par, 0x21BC, v2);\n\twritemmr(par, 0x21D0, v1);\n\twritemmr(par, 0x21D4, v1);\n\twritemmr(par, 0x21C8, v1);\n\twritemmr(par, 0x21CC, v1);\n\twritemmr(par, 0x216C, 0);\n}\n\nstatic void blade_wait_engine(struct tridentfb_par *par)\n{\n\twhile (readmmr(par, STATUS) & 0xFA800000)\n\t\tcpu_relax();\n}\n\nstatic void blade_fill_rect(struct tridentfb_par *par,\n\t\t\t    u32 x, u32 y, u32 w, u32 h, u32 c, u32 rop)\n{\n\twritemmr(par, COLOR, c);\n\twritemmr(par, ROP, rop ? ROP_X : ROP_S);\n\twritemmr(par, CMD, 0x20000000 | 1 << 19 | 1 << 4 | 2 << 2);\n\n\twritemmr(par, DST1, point(x, y));\n\twritemmr(par, DST2, point(x + w - 1, y + h - 1));\n}\n\nstatic void blade_image_blit(struct tridentfb_par *par, const char *data,\n\t\t\t     u32 x, u32 y, u32 w, u32 h, u32 c, u32 b)\n{\n\tunsigned size = ((w + 31) >> 5) * h;\n\n\twritemmr(par, COLOR, c);\n\twritemmr(par, BGCOLOR, b);\n\twritemmr(par, CMD, 0xa0000000 | 3 << 19);\n\n\twritemmr(par, DST1, point(x, y));\n\twritemmr(par, DST2, point(x + w - 1, y + h - 1));\n\n\tiowrite32_rep(par->io_virt + 0x10000, data, size);\n}\n\nstatic void blade_copy_rect(struct tridentfb_par *par,\n\t\t\t    u32 x1, u32 y1, u32 x2, u32 y2, u32 w, u32 h)\n{\n\tint direction = 2;\n\tu32 s1 = point(x1, y1);\n\tu32 s2 = point(x1 + w - 1, y1 + h - 1);\n\tu32 d1 = point(x2, y2);\n\tu32 d2 = point(x2 + w - 1, y2 + h - 1);\n\n\tif ((y1 > y2) || ((y1 == y2) && (x1 > x2)))\n\t\tdirection = 0;\n\n\twritemmr(par, ROP, ROP_S);\n\twritemmr(par, CMD, 0xE0000000 | 1 << 19 | 1 << 4 | 1 << 2 | direction);\n\n\twritemmr(par, SRC1, direction ? s2 : s1);\n\twritemmr(par, SRC2, direction ? s1 : s2);\n\twritemmr(par, DST1, direction ? d2 : d1);\n\twritemmr(par, DST2, direction ? d1 : d2);\n}\n\n \n\nstatic void xp_init_accel(struct tridentfb_par *par, int pitch, int bpp)\n{\n\tunsigned char x = bpp == 24 ? 3 : (bpp >> 4);\n\tint v1 = pitch << (bpp == 24 ? 20 : (18 + x));\n\n\tswitch (pitch << (bpp >> 3)) {\n\tcase 8192:\n\tcase 512:\n\t\tx |= 0x00;\n\t\tbreak;\n\tcase 1024:\n\t\tx |= 0x04;\n\t\tbreak;\n\tcase 2048:\n\t\tx |= 0x08;\n\t\tbreak;\n\tcase 4096:\n\t\tx |= 0x0C;\n\t\tbreak;\n\t}\n\n\tt_outb(par, x, 0x2125);\n\n\tpar->eng_oper = x | 0x40;\n\n\twritemmr(par, 0x2154, v1);\n\twritemmr(par, 0x2150, v1);\n\tt_outb(par, 3, 0x2126);\n}\n\nstatic void xp_wait_engine(struct tridentfb_par *par)\n{\n\tint count = 0;\n\tint timeout = 0;\n\n\twhile (t_inb(par, STATUS) & 0x80) {\n\t\tcount++;\n\t\tif (count == 10000000) {\n\t\t\t \n\t\t\tcount = 9990000;\n\t\t\ttimeout++;\n\t\t\tif (timeout == 8) {\n\t\t\t\t \n\t\t\t\tt_outb(par, 0x00, STATUS);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcpu_relax();\n\t}\n}\n\nstatic void xp_fill_rect(struct tridentfb_par *par,\n\t\t\t u32 x, u32 y, u32 w, u32 h, u32 c, u32 rop)\n{\n\twritemmr(par, 0x2127, ROP_P);\n\twritemmr(par, 0x2158, c);\n\twritemmr(par, DRAWFL, 0x4000);\n\twritemmr(par, OLDDIM, point(h, w));\n\twritemmr(par, OLDDST, point(y, x));\n\tt_outb(par, 0x01, OLDCMD);\n\tt_outb(par, par->eng_oper, 0x2125);\n}\n\nstatic void xp_copy_rect(struct tridentfb_par *par,\n\t\t\t u32 x1, u32 y1, u32 x2, u32 y2, u32 w, u32 h)\n{\n\tu32 x1_tmp, x2_tmp, y1_tmp, y2_tmp;\n\tint direction = 0x0004;\n\n\tif ((x1 < x2) && (y1 == y2)) {\n\t\tdirection |= 0x0200;\n\t\tx1_tmp = x1 + w - 1;\n\t\tx2_tmp = x2 + w - 1;\n\t} else {\n\t\tx1_tmp = x1;\n\t\tx2_tmp = x2;\n\t}\n\n\tif (y1 < y2) {\n\t\tdirection |= 0x0100;\n\t\ty1_tmp = y1 + h - 1;\n\t\ty2_tmp = y2 + h - 1;\n\t} else {\n\t\ty1_tmp = y1;\n\t\ty2_tmp = y2;\n\t}\n\n\twritemmr(par, DRAWFL, direction);\n\tt_outb(par, ROP_S, 0x2127);\n\twritemmr(par, OLDSRC, point(y1_tmp, x1_tmp));\n\twritemmr(par, OLDDST, point(y2_tmp, x2_tmp));\n\twritemmr(par, OLDDIM, point(h, w));\n\tt_outb(par, 0x01, OLDCMD);\n}\n\n \nstatic void image_init_accel(struct tridentfb_par *par, int pitch, int bpp)\n{\n\tint tmp = bpp == 24 ? 2: (bpp >> 4);\n\n\twritemmr(par, 0x2120, 0xF0000000);\n\twritemmr(par, 0x2120, 0x40000000 | tmp);\n\twritemmr(par, 0x2120, 0x80000000);\n\twritemmr(par, 0x2144, 0x00000000);\n\twritemmr(par, 0x2148, 0x00000000);\n\twritemmr(par, 0x2150, 0x00000000);\n\twritemmr(par, 0x2154, 0x00000000);\n\twritemmr(par, 0x2120, 0x60000000 | (pitch << 16) | pitch);\n\twritemmr(par, 0x216C, 0x00000000);\n\twritemmr(par, 0x2170, 0x00000000);\n\twritemmr(par, 0x217C, 0x00000000);\n\twritemmr(par, 0x2120, 0x10000000);\n\twritemmr(par, 0x2130, (2047 << 16) | 2047);\n}\n\nstatic void image_wait_engine(struct tridentfb_par *par)\n{\n\twhile (readmmr(par, 0x2164) & 0xF0000000)\n\t\tcpu_relax();\n}\n\nstatic void image_fill_rect(struct tridentfb_par *par,\n\t\t\t    u32 x, u32 y, u32 w, u32 h, u32 c, u32 rop)\n{\n\twritemmr(par, 0x2120, 0x80000000);\n\twritemmr(par, 0x2120, 0x90000000 | ROP_S);\n\n\twritemmr(par, 0x2144, c);\n\n\twritemmr(par, DST1, point(x, y));\n\twritemmr(par, DST2, point(x + w - 1, y + h - 1));\n\n\twritemmr(par, 0x2124, 0x80000000 | 3 << 22 | 1 << 10 | 1 << 9);\n}\n\nstatic void image_copy_rect(struct tridentfb_par *par,\n\t\t\t    u32 x1, u32 y1, u32 x2, u32 y2, u32 w, u32 h)\n{\n\tint direction = 0x4;\n\tu32 s1 = point(x1, y1);\n\tu32 s2 = point(x1 + w - 1, y1 + h - 1);\n\tu32 d1 = point(x2, y2);\n\tu32 d2 = point(x2 + w - 1, y2 + h - 1);\n\n\tif ((y1 > y2) || ((y1 == y2) && (x1 > x2)))\n\t\tdirection = 0;\n\n\twritemmr(par, 0x2120, 0x80000000);\n\twritemmr(par, 0x2120, 0x90000000 | ROP_S);\n\n\twritemmr(par, SRC1, direction ? s2 : s1);\n\twritemmr(par, SRC2, direction ? s1 : s2);\n\twritemmr(par, DST1, direction ? d2 : d1);\n\twritemmr(par, DST2, direction ? d1 : d2);\n\twritemmr(par, 0x2124,\n\t\t 0x80000000 | 1 << 22 | 1 << 10 | 1 << 7 | direction);\n}\n\n \n\nstatic void tgui_init_accel(struct tridentfb_par *par, int pitch, int bpp)\n{\n\tunsigned char x = bpp == 24 ? 3 : (bpp >> 4);\n\n\t \n\twritemmr(par, 0x2148, 0);\n\twritemmr(par, 0x214C, point(4095, 2047));\n\n\tswitch ((pitch * bpp) / 8) {\n\tcase 8192:\n\tcase 512:\n\t\tx |= 0x00;\n\t\tbreak;\n\tcase 1024:\n\t\tx |= 0x04;\n\t\tbreak;\n\tcase 2048:\n\t\tx |= 0x08;\n\t\tbreak;\n\tcase 4096:\n\t\tx |= 0x0C;\n\t\tbreak;\n\t}\n\n\tfb_writew(x, par->io_virt + 0x2122);\n}\n\nstatic void tgui_fill_rect(struct tridentfb_par *par,\n\t\t\t   u32 x, u32 y, u32 w, u32 h, u32 c, u32 rop)\n{\n\tt_outb(par, ROP_P, 0x2127);\n\twritemmr(par, OLDCLR, c);\n\twritemmr(par, DRAWFL, 0x4020);\n\twritemmr(par, OLDDIM, point(w - 1, h - 1));\n\twritemmr(par, OLDDST, point(x, y));\n\tt_outb(par, 1, OLDCMD);\n}\n\nstatic void tgui_copy_rect(struct tridentfb_par *par,\n\t\t\t   u32 x1, u32 y1, u32 x2, u32 y2, u32 w, u32 h)\n{\n\tint flags = 0;\n\tu16 x1_tmp, x2_tmp, y1_tmp, y2_tmp;\n\n\tif ((x1 < x2) && (y1 == y2)) {\n\t\tflags |= 0x0200;\n\t\tx1_tmp = x1 + w - 1;\n\t\tx2_tmp = x2 + w - 1;\n\t} else {\n\t\tx1_tmp = x1;\n\t\tx2_tmp = x2;\n\t}\n\n\tif (y1 < y2) {\n\t\tflags |= 0x0100;\n\t\ty1_tmp = y1 + h - 1;\n\t\ty2_tmp = y2 + h - 1;\n\t} else {\n\t\ty1_tmp = y1;\n\t\ty2_tmp = y2;\n\t}\n\n\twritemmr(par, DRAWFL, 0x4 | flags);\n\tt_outb(par, ROP_S, 0x2127);\n\twritemmr(par, OLDSRC, point(x1_tmp, y1_tmp));\n\twritemmr(par, OLDDST, point(x2_tmp, y2_tmp));\n\twritemmr(par, OLDDIM, point(w - 1, h - 1));\n\tt_outb(par, 1, OLDCMD);\n}\n\n \nstatic void tridentfb_fillrect(struct fb_info *info,\n\t\t\t       const struct fb_fillrect *fr)\n{\n\tstruct tridentfb_par *par = info->par;\n\tint col;\n\n\tif (info->flags & FBINFO_HWACCEL_DISABLED) {\n\t\tcfb_fillrect(info, fr);\n\t\treturn;\n\t}\n\tif (info->var.bits_per_pixel == 8) {\n\t\tcol = fr->color;\n\t\tcol |= col << 8;\n\t\tcol |= col << 16;\n\t} else\n\t\tcol = ((u32 *)(info->pseudo_palette))[fr->color];\n\n\tpar->wait_engine(par);\n\tpar->fill_rect(par, fr->dx, fr->dy, fr->width,\n\t\t       fr->height, col, fr->rop);\n}\n\nstatic void tridentfb_imageblit(struct fb_info *info,\n\t\t\t\tconst struct fb_image *img)\n{\n\tstruct tridentfb_par *par = info->par;\n\tint col, bgcol;\n\n\tif ((info->flags & FBINFO_HWACCEL_DISABLED) || img->depth != 1) {\n\t\tcfb_imageblit(info, img);\n\t\treturn;\n\t}\n\tif (info->var.bits_per_pixel == 8) {\n\t\tcol = img->fg_color;\n\t\tcol |= col << 8;\n\t\tcol |= col << 16;\n\t\tbgcol = img->bg_color;\n\t\tbgcol |= bgcol << 8;\n\t\tbgcol |= bgcol << 16;\n\t} else {\n\t\tcol = ((u32 *)(info->pseudo_palette))[img->fg_color];\n\t\tbgcol = ((u32 *)(info->pseudo_palette))[img->bg_color];\n\t}\n\n\tpar->wait_engine(par);\n\tif (par->image_blit)\n\t\tpar->image_blit(par, img->data, img->dx, img->dy,\n\t\t\t\timg->width, img->height, col, bgcol);\n\telse\n\t\tcfb_imageblit(info, img);\n}\n\nstatic void tridentfb_copyarea(struct fb_info *info,\n\t\t\t       const struct fb_copyarea *ca)\n{\n\tstruct tridentfb_par *par = info->par;\n\n\tif (info->flags & FBINFO_HWACCEL_DISABLED) {\n\t\tcfb_copyarea(info, ca);\n\t\treturn;\n\t}\n\tpar->wait_engine(par);\n\tpar->copy_rect(par, ca->sx, ca->sy, ca->dx, ca->dy,\n\t\t       ca->width, ca->height);\n}\n\nstatic int tridentfb_sync(struct fb_info *info)\n{\n\tstruct tridentfb_par *par = info->par;\n\n\tif (!(info->flags & FBINFO_HWACCEL_DISABLED))\n\t\tpar->wait_engine(par);\n\treturn 0;\n}\n\n \n\nstatic inline unsigned char read3X4(struct tridentfb_par *par, int reg)\n{\n\treturn vga_mm_rcrt(par->io_virt, reg);\n}\n\nstatic inline void write3X4(struct tridentfb_par *par, int reg,\n\t\t\t    unsigned char val)\n{\n\tvga_mm_wcrt(par->io_virt, reg, val);\n}\n\nstatic inline unsigned char read3CE(struct tridentfb_par *par,\n\t\t\t\t    unsigned char reg)\n{\n\treturn vga_mm_rgfx(par->io_virt, reg);\n}\n\nstatic inline void writeAttr(struct tridentfb_par *par, int reg,\n\t\t\t     unsigned char val)\n{\n\tfb_readb(par->io_virt + VGA_IS1_RC);\t \n\tvga_mm_wattr(par->io_virt, reg, val);\n}\n\nstatic inline void write3CE(struct tridentfb_par *par, int reg,\n\t\t\t    unsigned char val)\n{\n\tvga_mm_wgfx(par->io_virt, reg, val);\n}\n\nstatic void enable_mmio(struct tridentfb_par *par)\n{\n\t \n\tvga_io_rseq(0x0B);\n\n\t \n\tvga_io_wseq(NewMode1, 0x80);\n\tif (!is_oldprotect(par->chip_id))\n\t\tvga_io_wseq(Protection, 0x92);\n\n\t \n\toutb(PCIReg, 0x3D4);\n\toutb(inb(0x3D5) | 0x01, 0x3D5);\n}\n\nstatic void disable_mmio(struct tridentfb_par *par)\n{\n\t \n\tvga_mm_rseq(par->io_virt, 0x0B);\n\n\t \n\tvga_mm_wseq(par->io_virt, NewMode1, 0x80);\n\tif (!is_oldprotect(par->chip_id))\n\t\tvga_mm_wseq(par->io_virt, Protection, 0x92);\n\n\t \n\tt_outb(par, PCIReg, 0x3D4);\n\tt_outb(par, t_inb(par, 0x3D5) & ~0x01, 0x3D5);\n}\n\nstatic inline void crtc_unlock(struct tridentfb_par *par)\n{\n\twrite3X4(par, VGA_CRTC_V_SYNC_END,\n\t\t read3X4(par, VGA_CRTC_V_SYNC_END) & 0x7F);\n}\n\n \nstatic int get_nativex(struct tridentfb_par *par)\n{\n\tint x, y, tmp;\n\n\tif (nativex)\n\t\treturn nativex;\n\n\ttmp = (read3CE(par, VertStretch) >> 4) & 3;\n\n\tswitch (tmp) {\n\tcase 0:\n\t\tx = 1280; y = 1024;\n\t\tbreak;\n\tcase 2:\n\t\tx = 1024; y = 768;\n\t\tbreak;\n\tcase 3:\n\t\tx = 800; y = 600;\n\t\tbreak;\n\tcase 1:\n\tdefault:\n\t\tx = 640;  y = 480;\n\t\tbreak;\n\t}\n\n\toutput(\"%dx%d flat panel found\\n\", x, y);\n\treturn x;\n}\n\n \nstatic inline void set_lwidth(struct tridentfb_par *par, int width)\n{\n\twrite3X4(par, VGA_CRTC_OFFSET, width & 0xFF);\n\t \n\t \n\tif (par->chip_id == TGUI9440 || par->chip_id == CYBER9320)\n\t\twrite3X4(par, AddColReg,\n\t\t     (read3X4(par, AddColReg) & 0xEF) | ((width & 0x100) >> 4));\n\telse\n\t\twrite3X4(par, AddColReg,\n\t\t     (read3X4(par, AddColReg) & 0xCF) | ((width & 0x300) >> 4));\n}\n\n \nstatic void screen_stretch(struct tridentfb_par *par)\n{\n\tif (par->chip_id != CYBERBLADEXPAi1)\n\t\twrite3CE(par, BiosReg, 0);\n\telse\n\t\twrite3CE(par, BiosReg, 8);\n\twrite3CE(par, VertStretch, (read3CE(par, VertStretch) & 0x7C) | 1);\n\twrite3CE(par, HorStretch, (read3CE(par, HorStretch) & 0x7C) | 1);\n}\n\n \nstatic inline void screen_center(struct tridentfb_par *par)\n{\n\twrite3CE(par, VertStretch, (read3CE(par, VertStretch) & 0x7C) | 0x80);\n\twrite3CE(par, HorStretch, (read3CE(par, HorStretch) & 0x7C) | 0x80);\n}\n\n \nstatic void set_screen_start(struct tridentfb_par *par, int base)\n{\n\tu8 tmp;\n\twrite3X4(par, VGA_CRTC_START_LO, base & 0xFF);\n\twrite3X4(par, VGA_CRTC_START_HI, (base & 0xFF00) >> 8);\n\ttmp = read3X4(par, CRTCModuleTest) & 0xDF;\n\twrite3X4(par, CRTCModuleTest, tmp | ((base & 0x10000) >> 11));\n\ttmp = read3X4(par, CRTHiOrd) & 0xF8;\n\twrite3X4(par, CRTHiOrd, tmp | ((base & 0xE0000) >> 17));\n}\n\n \nstatic void set_vclk(struct tridentfb_par *par, unsigned long freq)\n{\n\tint m, n, k;\n\tunsigned long fi, d, di;\n\tunsigned char best_m = 0, best_n = 0, best_k = 0;\n\tunsigned char hi, lo;\n\tunsigned char shift = !is_oldclock(par->chip_id) ? 2 : 1;\n\n\td = 20000;\n\tfor (k = shift; k >= 0; k--)\n\t\tfor (m = 1; m < 32; m++) {\n\t\t\tn = ((m + 2) << shift) - 8;\n\t\t\tfor (n = (n < 0 ? 0 : n); n < 122; n++) {\n\t\t\t\tfi = ((14318l * (n + 8)) / (m + 2)) >> k;\n\t\t\t\tdi = abs(fi - freq);\n\t\t\t\tif (di < d || (di == d && k == best_k)) {\n\t\t\t\t\td = di;\n\t\t\t\t\tbest_n = n;\n\t\t\t\t\tbest_m = m;\n\t\t\t\t\tbest_k = k;\n\t\t\t\t}\n\t\t\t\tif (fi > freq)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tif (is_oldclock(par->chip_id)) {\n\t\tlo = best_n | (best_m << 7);\n\t\thi = (best_m >> 1) | (best_k << 4);\n\t} else {\n\t\tlo = best_n;\n\t\thi = best_m | (best_k << 6);\n\t}\n\n\tif (is3Dchip(par->chip_id)) {\n\t\tvga_mm_wseq(par->io_virt, ClockHigh, hi);\n\t\tvga_mm_wseq(par->io_virt, ClockLow, lo);\n\t} else {\n\t\tt_outb(par, lo, 0x43C8);\n\t\tt_outb(par, hi, 0x43C9);\n\t}\n\tdebug(\"VCLK = %X %X\\n\", hi, lo);\n}\n\n \nstatic void set_number_of_lines(struct tridentfb_par *par, int lines)\n{\n\tint tmp = read3CE(par, CyberEnhance) & 0x8F;\n\tif (lines > 1024)\n\t\ttmp |= 0x50;\n\telse if (lines > 768)\n\t\ttmp |= 0x30;\n\telse if (lines > 600)\n\t\ttmp |= 0x20;\n\telse if (lines > 480)\n\t\ttmp |= 0x10;\n\twrite3CE(par, CyberEnhance, tmp);\n}\n\n \nstatic int is_flatpanel(struct tridentfb_par *par)\n{\n\tif (fp)\n\t\treturn 1;\n\tif (crt || !iscyber(par->chip_id))\n\t\treturn 0;\n\treturn (read3CE(par, FPConfig) & 0x10) ? 1 : 0;\n}\n\n \nstatic unsigned int get_memsize(struct tridentfb_par *par)\n{\n\tunsigned char tmp, tmp2;\n\tunsigned int k;\n\n\t \n\tif (memsize)\n\t\tk = memsize * Kb;\n\telse\n\t\tswitch (par->chip_id) {\n\t\tcase CYBER9525DVD:\n\t\t\tk = 2560 * Kb;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttmp = read3X4(par, SPR) & 0x0F;\n\t\t\tswitch (tmp) {\n\n\t\t\tcase 0x01:\n\t\t\t\tk = 512 * Kb;\n\t\t\t\tbreak;\n\t\t\tcase 0x02:\n\t\t\t\tk = 6 * Mb;\t \n\t\t\t\tbreak;\n\t\t\tcase 0x03:\n\t\t\t\tk = 1 * Mb;\n\t\t\t\tbreak;\n\t\t\tcase 0x04:\n\t\t\t\tk = 8 * Mb;\n\t\t\t\tbreak;\n\t\t\tcase 0x06:\n\t\t\t\tk = 10 * Mb;\t \n\t\t\t\tbreak;\n\t\t\tcase 0x07:\n\t\t\t\tk = 2 * Mb;\n\t\t\t\tbreak;\n\t\t\tcase 0x08:\n\t\t\t\tk = 12 * Mb;\t \n\t\t\t\tbreak;\n\t\t\tcase 0x0A:\n\t\t\t\tk = 14 * Mb;\t \n\t\t\t\tbreak;\n\t\t\tcase 0x0C:\n\t\t\t\tk = 16 * Mb;\t \n\t\t\t\tbreak;\n\t\t\tcase 0x0E:\t\t \n\n\t\t\t\ttmp2 = vga_mm_rseq(par->io_virt, 0xC1);\n\t\t\t\tswitch (tmp2) {\n\t\t\t\tcase 0x00:\n\t\t\t\t\tk = 20 * Mb;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x01:\n\t\t\t\t\tk = 24 * Mb;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x10:\n\t\t\t\t\tk = 28 * Mb;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x11:\n\t\t\t\t\tk = 32 * Mb;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tk = 1 * Mb;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 0x0F:\n\t\t\t\tk = 4 * Mb;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tk = 1 * Mb;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tk -= memdiff * Kb;\n\toutput(\"framebuffer size = %d Kb\\n\", k / Kb);\n\treturn k;\n}\n\n \nstatic int tridentfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t       struct fb_info *info)\n{\n\tstruct tridentfb_par *par = info->par;\n\tint bpp = var->bits_per_pixel;\n\tint line_length;\n\tint ramdac = 230000;  \n\tdebug(\"enter\\n\");\n\n\tif (!var->pixclock)\n\t\treturn -EINVAL;\n\n\t \n\tif (bpp == 24)\n\t\tbpp = var->bits_per_pixel = 32;\n\tif (bpp != 8 && bpp != 16 && bpp != 32)\n\t\treturn -EINVAL;\n\tif (par->chip_id == TGUI9440 && bpp == 32)\n\t\treturn -EINVAL;\n\t \n\tif (par->flatpanel && nativex && var->xres > nativex)\n\t\treturn -EINVAL;\n\t \n\tvar->xres = (var->xres + 7) & ~0x7;\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\tif (var->xres_virtual > 4095 || var->yres > 2048)\n\t\treturn -EINVAL;\n\t \n\tif (var->yres_virtual > 0xffff)\n\t\treturn -EINVAL;\n\tline_length = var->xres_virtual * bpp / 8;\n\n\tif (!is3Dchip(par->chip_id) &&\n\t    !(info->flags & FBINFO_HWACCEL_DISABLED)) {\n\t\t \n\t\tif (line_length <= 512)\n\t\t\tvar->xres_virtual = 512 * 8 / bpp;\n\t\telse if (line_length <= 1024)\n\t\t\tvar->xres_virtual = 1024 * 8 / bpp;\n\t\telse if (line_length <= 2048)\n\t\t\tvar->xres_virtual = 2048 * 8 / bpp;\n\t\telse if (line_length <= 4096)\n\t\t\tvar->xres_virtual = 4096 * 8 / bpp;\n\t\telse if (line_length <= 8192)\n\t\t\tvar->xres_virtual = 8192 * 8 / bpp;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tline_length = var->xres_virtual * bpp / 8;\n\t}\n\n\t \n\tif (line_length * (var->yres_virtual - var->yres) > (4 << 20))\n\t\tvar->yres_virtual = ((4 << 20) / line_length) + var->yres;\n\n\tif (line_length * var->yres_virtual > info->fix.smem_len)\n\t\treturn -EINVAL;\n\n\tswitch (bpp) {\n\tcase 8:\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green = var->red;\n\t\tvar->blue = var->red;\n\t\tbreak;\n\tcase 16:\n\t\tvar->red.offset = 11;\n\t\tvar->green.offset = 5;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.length = 5;\n\t\tbreak;\n\tcase 32:\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_xp(par->chip_id))\n\t\tramdac = 350000;\n\n\tswitch (par->chip_id) {\n\tcase TGUI9440:\n\t\tramdac = (bpp >= 16) ? 45000 : 90000;\n\t\tbreak;\n\tcase CYBER9320:\n\tcase TGUI9660:\n\t\tramdac = 135000;\n\t\tbreak;\n\tcase PROVIDIA9685:\n\tcase CYBER9388:\n\tcase CYBER9382:\n\tcase CYBER9385:\n\t\tramdac = 170000;\n\t\tbreak;\n\t}\n\n\t \n\tif (bpp == 32)\n\t\tramdac /= 2;\n\n\tif (PICOS2KHZ(var->pixclock) > ramdac)\n\t\treturn -EINVAL;\n\n\tdebug(\"exit\\n\");\n\n\treturn 0;\n\n}\n\n \nstatic int tridentfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\t struct fb_info *info)\n{\n\tstruct tridentfb_par *par = info->par;\n\tunsigned int offset;\n\n\tdebug(\"enter\\n\");\n\toffset = (var->xoffset + (var->yoffset * info->var.xres_virtual))\n\t\t* info->var.bits_per_pixel / 32;\n\tset_screen_start(par, offset);\n\tdebug(\"exit\\n\");\n\treturn 0;\n}\n\nstatic inline void shadowmode_on(struct tridentfb_par *par)\n{\n\twrite3CE(par, CyberControl, read3CE(par, CyberControl) | 0x81);\n}\n\n \nstatic int tridentfb_set_par(struct fb_info *info)\n{\n\tstruct tridentfb_par *par = info->par;\n\tu32 htotal, hdispend, hsyncstart, hsyncend, hblankstart, hblankend;\n\tu32 vtotal, vdispend, vsyncstart, vsyncend, vblankstart, vblankend;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tint bpp = var->bits_per_pixel;\n\tunsigned char tmp;\n\tunsigned long vclk;\n\n\tdebug(\"enter\\n\");\n\thdispend = var->xres / 8 - 1;\n\thsyncstart = (var->xres + var->right_margin) / 8;\n\thsyncend = (var->xres + var->right_margin + var->hsync_len) / 8;\n\thtotal = (var->xres + var->left_margin + var->right_margin +\n\t\t  var->hsync_len) / 8 - 5;\n\thblankstart = hdispend + 1;\n\thblankend = htotal + 3;\n\n\tvdispend = var->yres - 1;\n\tvsyncstart = var->yres + var->lower_margin;\n\tvsyncend = vsyncstart + var->vsync_len;\n\tvtotal = var->upper_margin + vsyncend - 2;\n\tvblankstart = vdispend + 1;\n\tvblankend = vtotal;\n\n\tif (info->var.vmode & FB_VMODE_INTERLACED) {\n\t\tvtotal /= 2;\n\t\tvdispend /= 2;\n\t\tvsyncstart /= 2;\n\t\tvsyncend /= 2;\n\t\tvblankstart /= 2;\n\t\tvblankend /= 2;\n\t}\n\n\tenable_mmio(par);\n\tcrtc_unlock(par);\n\twrite3CE(par, CyberControl, 8);\n\ttmp = 0xEB;\n\tif (var->sync & FB_SYNC_HOR_HIGH_ACT)\n\t\ttmp &= ~0x40;\n\tif (var->sync & FB_SYNC_VERT_HIGH_ACT)\n\t\ttmp &= ~0x80;\n\n\tif (par->flatpanel && var->xres < nativex) {\n\t\t \n\t\tt_outb(par, tmp | 0xC0, VGA_MIS_W);\n\n\t\tshadowmode_on(par);\n\n\t\tif (center)\n\t\t\tscreen_center(par);\n\t\telse if (stretch)\n\t\t\tscreen_stretch(par);\n\n\t} else {\n\t\tt_outb(par, tmp, VGA_MIS_W);\n\t\twrite3CE(par, CyberControl, 8);\n\t}\n\n\t \n\twrite3X4(par, VGA_CRTC_V_TOTAL, vtotal & 0xFF);\n\twrite3X4(par, VGA_CRTC_V_DISP_END, vdispend & 0xFF);\n\twrite3X4(par, VGA_CRTC_V_SYNC_START, vsyncstart & 0xFF);\n\twrite3X4(par, VGA_CRTC_V_SYNC_END, (vsyncend & 0x0F));\n\twrite3X4(par, VGA_CRTC_V_BLANK_START, vblankstart & 0xFF);\n\twrite3X4(par, VGA_CRTC_V_BLANK_END, vblankend & 0xFF);\n\n\t \n\twrite3X4(par, VGA_CRTC_H_TOTAL, htotal & 0xFF);\n\twrite3X4(par, VGA_CRTC_H_DISP, hdispend & 0xFF);\n\twrite3X4(par, VGA_CRTC_H_SYNC_START, hsyncstart & 0xFF);\n\twrite3X4(par, VGA_CRTC_H_SYNC_END,\n\t\t (hsyncend & 0x1F) | ((hblankend & 0x20) << 2));\n\twrite3X4(par, VGA_CRTC_H_BLANK_START, hblankstart & 0xFF);\n\twrite3X4(par, VGA_CRTC_H_BLANK_END, hblankend & 0x1F);\n\n\t \n\ttmp = 0x10;\n\tif (vtotal & 0x100) tmp |= 0x01;\n\tif (vdispend & 0x100) tmp |= 0x02;\n\tif (vsyncstart & 0x100) tmp |= 0x04;\n\tif (vblankstart & 0x100) tmp |= 0x08;\n\n\tif (vtotal & 0x200) tmp |= 0x20;\n\tif (vdispend & 0x200) tmp |= 0x40;\n\tif (vsyncstart & 0x200) tmp |= 0x80;\n\twrite3X4(par, VGA_CRTC_OVERFLOW, tmp);\n\n\ttmp = read3X4(par, CRTHiOrd) & 0x07;\n\ttmp |= 0x08;\t \n\tif (vtotal & 0x400) tmp |= 0x80;\n\tif (vblankstart & 0x400) tmp |= 0x40;\n\tif (vsyncstart & 0x400) tmp |= 0x20;\n\tif (vdispend & 0x400) tmp |= 0x10;\n\twrite3X4(par, CRTHiOrd, tmp);\n\n\ttmp = (htotal >> 8) & 0x01;\n\ttmp |= (hdispend >> 7) & 0x02;\n\ttmp |= (hsyncstart >> 5) & 0x08;\n\ttmp |= (hblankstart >> 4) & 0x10;\n\twrite3X4(par, HorizOverflow, tmp);\n\n\ttmp = 0x40;\n\tif (vblankstart & 0x200) tmp |= 0x20;\n \n\twrite3X4(par, VGA_CRTC_MAX_SCAN, tmp);\n\n\twrite3X4(par, VGA_CRTC_LINE_COMPARE, 0xFF);\n\twrite3X4(par, VGA_CRTC_PRESET_ROW, 0);\n\twrite3X4(par, VGA_CRTC_MODE, 0xC3);\n\n\twrite3X4(par, LinearAddReg, 0x20);\t \n\n\ttmp = (info->var.vmode & FB_VMODE_INTERLACED) ? 0x84 : 0x80;\n\t \n\twrite3X4(par, CRTCModuleTest, tmp);\n\ttmp = read3CE(par, MiscIntContReg) & ~0x4;\n\tif (info->var.vmode & FB_VMODE_INTERLACED)\n\t\ttmp |= 0x4;\n\twrite3CE(par, MiscIntContReg, tmp);\n\n\t \n\twrite3X4(par, GraphEngReg, 0x80);\n\n\tswitch (bpp) {\n\tcase 8:\n\t\ttmp = 0x00;\n\t\tbreak;\n\tcase 16:\n\t\ttmp = 0x05;\n\t\tbreak;\n\tcase 24:\n\t\ttmp = 0x29;\n\t\tbreak;\n\tcase 32:\n\t\ttmp = 0x09;\n\t\tbreak;\n\t}\n\n\twrite3X4(par, PixelBusReg, tmp);\n\n\ttmp = read3X4(par, DRAMControl);\n\tif (!is_oldprotect(par->chip_id))\n\t\ttmp |= 0x10;\n\tif (iscyber(par->chip_id))\n\t\ttmp |= 0x20;\n\twrite3X4(par, DRAMControl, tmp);\t \n\n\twrite3X4(par, InterfaceSel, read3X4(par, InterfaceSel) | 0x40);\n\tif (!is_xp(par->chip_id))\n\t\twrite3X4(par, Performance, read3X4(par, Performance) | 0x10);\n\t \n\tif (par->chip_id != TGUI9440 && par->chip_id != IMAGE975)\n\t\twrite3X4(par, PCIReg, read3X4(par, PCIReg) | 0x06);\n\n\tvga_mm_wseq(par->io_virt, 0, 3);\n\tvga_mm_wseq(par->io_virt, 1, 1);  \n\t \n\tvga_mm_wseq(par->io_virt, 2, 0x0F);\n\tvga_mm_wseq(par->io_virt, 3, 0);\n\tvga_mm_wseq(par->io_virt, 4, 0x0E);  \n\n\t \n\tvclk = PICOS2KHZ(info->var.pixclock);\n\n\t \n\ttmp = read3CE(par, MiscExtFunc) & 0xF0;\n\tif (bpp == 32 || (par->chip_id == TGUI9440 && bpp == 16)) {\n\t\ttmp |= 8;\n\t\tvclk *= 2;\n\t}\n\tset_vclk(par, vclk);\n\twrite3CE(par, MiscExtFunc, tmp | 0x12);\n\twrite3CE(par, 0x5, 0x40);\t \n\twrite3CE(par, 0x6, 0x05);\t \n\twrite3CE(par, 0x7, 0x0F);\t \n\n\t \n\twriteAttr(par, 0x10, 0x41);\n\twriteAttr(par, 0x12, 0x0F);\t \n\twriteAttr(par, 0x13, 0);\t \n\n\t \n\tfor (tmp = 0; tmp < 0x10; tmp++)\n\t\twriteAttr(par, tmp, tmp);\n\tfb_readb(par->io_virt + VGA_IS1_RC);\t \n\tt_outb(par, 0x20, VGA_ATT_W);\t\t \n\n\tswitch (bpp) {\n\tcase 8:\n\t\ttmp = 0;\n\t\tbreak;\n\tcase 16:\n\t\ttmp = 0x30;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\ttmp = 0xD0;\n\t\tbreak;\n\t}\n\n\tt_inb(par, VGA_PEL_IW);\n\tt_inb(par, VGA_PEL_MSK);\n\tt_inb(par, VGA_PEL_MSK);\n\tt_inb(par, VGA_PEL_MSK);\n\tt_inb(par, VGA_PEL_MSK);\n\tt_outb(par, tmp, VGA_PEL_MSK);\n\tt_inb(par, VGA_PEL_IW);\n\n\tif (par->flatpanel)\n\t\tset_number_of_lines(par, info->var.yres);\n\tinfo->fix.line_length = info->var.xres_virtual * bpp / 8;\n\tset_lwidth(par, info->fix.line_length / 8);\n\n\tif (!(info->flags & FBINFO_HWACCEL_DISABLED))\n\t\tpar->init_accel(par, info->var.xres_virtual, bpp);\n\n\tinfo->fix.visual = (bpp == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\tinfo->cmap.len = (bpp == 8) ? 256 : 16;\n\tdebug(\"exit\\n\");\n\treturn 0;\n}\n\n \nstatic int tridentfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t       unsigned blue, unsigned transp,\n\t\t\t       struct fb_info *info)\n{\n\tint bpp = info->var.bits_per_pixel;\n\tstruct tridentfb_par *par = info->par;\n\n\tif (regno >= info->cmap.len)\n\t\treturn 1;\n\n\tif (bpp == 8) {\n\t\tt_outb(par, 0xFF, VGA_PEL_MSK);\n\t\tt_outb(par, regno, VGA_PEL_IW);\n\n\t\tt_outb(par, red >> 10, VGA_PEL_D);\n\t\tt_outb(par, green >> 10, VGA_PEL_D);\n\t\tt_outb(par, blue >> 10, VGA_PEL_D);\n\n\t} else if (regno < 16) {\n\t\tif (bpp == 16) {\t \n\t\t\tu32 col;\n\n\t\t\tcol = (red & 0xF800) | ((green & 0xFC00) >> 5) |\n\t\t\t\t((blue & 0xF800) >> 11);\n\t\t\tcol |= col << 16;\n\t\t\t((u32 *)(info->pseudo_palette))[regno] = col;\n\t\t} else if (bpp == 32)\t\t \n\t\t\t((u32 *)info->pseudo_palette)[regno] =\n\t\t\t\t((transp & 0xFF00) << 16)\t|\n\t\t\t\t((red & 0xFF00) << 8)\t\t|\n\t\t\t\t((green & 0xFF00))\t\t|\n\t\t\t\t((blue & 0xFF00) >> 8);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int tridentfb_blank(int blank_mode, struct fb_info *info)\n{\n\tunsigned char PMCont, DPMSCont;\n\tstruct tridentfb_par *par = info->par;\n\n\tdebug(\"enter\\n\");\n\tif (par->flatpanel)\n\t\treturn 0;\n\tt_outb(par, 0x04, 0x83C8);  \n\tPMCont = t_inb(par, 0x83C6) & 0xFC;\n\tDPMSCont = read3CE(par, PowerStatus) & 0xFC;\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\t \n\tcase FB_BLANK_NORMAL:\n\t\t \n\t\tPMCont |= 0x03;\n\t\tDPMSCont |= 0x00;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\t \n\t\tPMCont |= 0x02;\n\t\tDPMSCont |= 0x01;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\t \n\t\tPMCont |= 0x02;\n\t\tDPMSCont |= 0x02;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\t \n\t\tPMCont |= 0x00;\n\t\tDPMSCont |= 0x03;\n\t\tbreak;\n\t}\n\n\twrite3CE(par, PowerStatus, DPMSCont);\n\tt_outb(par, 4, 0x83C8);\n\tt_outb(par, PMCont, 0x83C6);\n\n\tdebug(\"exit\\n\");\n\n\t \n\treturn (blank_mode == FB_BLANK_NORMAL) ? 1 : 0;\n}\n\nstatic const struct fb_ops tridentfb_ops = {\n\t.owner = THIS_MODULE,\n\t.fb_setcolreg = tridentfb_setcolreg,\n\t.fb_pan_display = tridentfb_pan_display,\n\t.fb_blank = tridentfb_blank,\n\t.fb_check_var = tridentfb_check_var,\n\t.fb_set_par = tridentfb_set_par,\n\t.fb_fillrect = tridentfb_fillrect,\n\t.fb_copyarea = tridentfb_copyarea,\n\t.fb_imageblit = tridentfb_imageblit,\n\t.fb_sync = tridentfb_sync,\n};\n\nstatic int trident_pci_probe(struct pci_dev *dev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tint err;\n\tunsigned char revision;\n\tstruct fb_info *info;\n\tstruct tridentfb_par *default_par;\n\tint chip3D;\n\tint chip_id;\n\tbool found = false;\n\n\terr = aperture_remove_conflicting_pci_devices(dev, \"tridentfb\");\n\tif (err)\n\t\treturn err;\n\n\terr = pcim_enable_device(dev);\n\tif (err)\n\t\treturn err;\n\n\tinfo = framebuffer_alloc(sizeof(struct tridentfb_par), &dev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tdefault_par = info->par;\n\n\tchip_id = id->device;\n\n\t \n\n\tif (chip_id == TGUI9660) {\n\t\trevision = vga_io_rseq(RevisionID);\n\n\t\tswitch (revision) {\n\t\tcase 0x21:\n\t\t\tchip_id = PROVIDIA9685;\n\t\t\tbreak;\n\t\tcase 0x22:\n\t\tcase 0x23:\n\t\t\tchip_id = CYBER9397;\n\t\t\tbreak;\n\t\tcase 0x2A:\n\t\t\tchip_id = CYBER9397DVD;\n\t\t\tbreak;\n\t\tcase 0x30:\n\t\tcase 0x33:\n\t\tcase 0x34:\n\t\tcase 0x35:\n\t\tcase 0x38:\n\t\tcase 0x3A:\n\t\tcase 0xB3:\n\t\t\tchip_id = CYBER9385;\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x43:\n\t\t\tchip_id = CYBER9382;\n\t\t\tbreak;\n\t\tcase 0x4A:\n\t\t\tchip_id = CYBER9388;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchip3D = is3Dchip(chip_id);\n\n\tif (is_xp(chip_id)) {\n\t\tdefault_par->init_accel = xp_init_accel;\n\t\tdefault_par->wait_engine = xp_wait_engine;\n\t\tdefault_par->fill_rect = xp_fill_rect;\n\t\tdefault_par->copy_rect = xp_copy_rect;\n\t\ttridentfb_fix.accel = FB_ACCEL_TRIDENT_BLADEXP;\n\t} else if (is_blade(chip_id)) {\n\t\tdefault_par->init_accel = blade_init_accel;\n\t\tdefault_par->wait_engine = blade_wait_engine;\n\t\tdefault_par->fill_rect = blade_fill_rect;\n\t\tdefault_par->copy_rect = blade_copy_rect;\n\t\tdefault_par->image_blit = blade_image_blit;\n\t\ttridentfb_fix.accel = FB_ACCEL_TRIDENT_BLADE3D;\n\t} else if (chip3D) {\t\t\t \n\t\tdefault_par->init_accel = image_init_accel;\n\t\tdefault_par->wait_engine = image_wait_engine;\n\t\tdefault_par->fill_rect = image_fill_rect;\n\t\tdefault_par->copy_rect = image_copy_rect;\n\t\ttridentfb_fix.accel = FB_ACCEL_TRIDENT_3DIMAGE;\n\t} else { \t\t\t\t \n\t\tdefault_par->init_accel = tgui_init_accel;\n\t\tdefault_par->wait_engine = xp_wait_engine;\n\t\tdefault_par->fill_rect = tgui_fill_rect;\n\t\tdefault_par->copy_rect = tgui_copy_rect;\n\t\ttridentfb_fix.accel = FB_ACCEL_TRIDENT_TGUI;\n\t}\n\n\tdefault_par->chip_id = chip_id;\n\n\t \n\ttridentfb_fix.mmio_start = pci_resource_start(dev, 1);\n\ttridentfb_fix.mmio_len = pci_resource_len(dev, 1);\n\n\tif (!request_mem_region(tridentfb_fix.mmio_start,\n\t\t\t\ttridentfb_fix.mmio_len, \"tridentfb\")) {\n\t\tdebug(\"request_region failed!\\n\");\n\t\tframebuffer_release(info);\n\t\treturn -1;\n\t}\n\n\tdefault_par->io_virt = ioremap(tridentfb_fix.mmio_start,\n\t\t\t\t\t       tridentfb_fix.mmio_len);\n\n\tif (!default_par->io_virt) {\n\t\tdebug(\"ioremap failed\\n\");\n\t\terr = -1;\n\t\tgoto out_unmap1;\n\t}\n\n\tenable_mmio(default_par);\n\n\t \n\ttridentfb_fix.smem_start = pci_resource_start(dev, 0);\n\ttridentfb_fix.smem_len = get_memsize(default_par);\n\n\tif (!request_mem_region(tridentfb_fix.smem_start,\n\t\t\t\ttridentfb_fix.smem_len, \"tridentfb\")) {\n\t\tdebug(\"request_mem_region failed!\\n\");\n\t\tdisable_mmio(info->par);\n\t\terr = -1;\n\t\tgoto out_unmap1;\n\t}\n\n\tinfo->screen_base = ioremap(tridentfb_fix.smem_start,\n\t\t\t\t\t    tridentfb_fix.smem_len);\n\n\tif (!info->screen_base) {\n\t\tdebug(\"ioremap failed\\n\");\n\t\terr = -1;\n\t\tgoto out_unmap2;\n\t}\n\n\tdefault_par->flatpanel = is_flatpanel(default_par);\n\n\tif (default_par->flatpanel)\n\t\tnativex = get_nativex(default_par);\n\n\tinfo->fix = tridentfb_fix;\n\tinfo->fbops = &tridentfb_ops;\n\tinfo->pseudo_palette = default_par->pseudo_pal;\n\n\tinfo->flags = FBINFO_HWACCEL_YPAN;\n\tif (!noaccel && default_par->init_accel) {\n\t\tinfo->flags &= ~FBINFO_HWACCEL_DISABLED;\n\t\tinfo->flags |= FBINFO_HWACCEL_COPYAREA;\n\t\tinfo->flags |= FBINFO_HWACCEL_FILLRECT;\n\t} else\n\t\tinfo->flags |= FBINFO_HWACCEL_DISABLED;\n\n\tif (is_blade(chip_id) && chip_id != BLADE3D)\n\t\tinfo->flags |= FBINFO_READS_FAST;\n\n\tinfo->pixmap.addr = kmalloc(4096, GFP_KERNEL);\n\tif (!info->pixmap.addr) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unmap2;\n\t}\n\n\tinfo->pixmap.size = 4096;\n\tinfo->pixmap.buf_align = 4;\n\tinfo->pixmap.scan_align = 1;\n\tinfo->pixmap.access_align = 32;\n\tinfo->pixmap.flags = FB_PIXMAP_SYSTEM;\n\tinfo->var.bits_per_pixel = 8;\n\n\tif (default_par->image_blit) {\n\t\tinfo->flags |= FBINFO_HWACCEL_IMAGEBLIT;\n\t\tinfo->pixmap.scan_align = 4;\n\t}\n\n\tif (noaccel) {\n\t\tprintk(KERN_DEBUG \"disabling acceleration\\n\");\n\t\tinfo->flags |= FBINFO_HWACCEL_DISABLED;\n\t\tinfo->pixmap.scan_align = 1;\n\t}\n\n\tif (tridentfb_setup_ddc_bus(info) == 0) {\n\t\tu8 *edid = fb_ddc_read(&default_par->ddc_adapter);\n\n\t\tdefault_par->ddc_registered = true;\n\t\tif (edid) {\n\t\t\tfb_edid_to_monspecs(edid, &info->monspecs);\n\t\t\tkfree(edid);\n\t\t\tif (!info->monspecs.modedb)\n\t\t\t\tdev_err(info->device, \"error getting mode database\\n\");\n\t\t\telse {\n\t\t\t\tconst struct fb_videomode *m;\n\n\t\t\t\tfb_videomode_to_modelist(info->monspecs.modedb,\n\t\t\t\t\t\t info->monspecs.modedb_len,\n\t\t\t\t\t\t &info->modelist);\n\t\t\t\tm = fb_find_best_display(&info->monspecs,\n\t\t\t\t\t\t\t &info->modelist);\n\t\t\t\tif (m) {\n\t\t\t\t\tfb_videomode_to_var(&info->var, m);\n\t\t\t\t\t \n\t\t\t\t\tif (tridentfb_check_var(&info->var,\n\t\t\t\t\t\t\t\tinfo) == 0)\n\t\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!mode_option && !found)\n\t\tmode_option = \"640x480-8@60\";\n\n\t \n\tif (mode_option) {\n\t\terr = fb_find_mode(&info->var, info, mode_option,\n\t\t\t\t   info->monspecs.modedb,\n\t\t\t\t   info->monspecs.modedb_len,\n\t\t\t\t   NULL, info->var.bits_per_pixel);\n\t\tif (!err || err == 4) {\n\t\t\terr = -EINVAL;\n\t\t\tdev_err(info->device, \"mode %s not found\\n\",\n\t\t\t\t\t\t\t\tmode_option);\n\t\t\tfb_destroy_modedb(info->monspecs.modedb);\n\t\t\tinfo->monspecs.modedb = NULL;\n\t\t\tgoto out_unmap2;\n\t\t}\n\t}\n\n\tfb_destroy_modedb(info->monspecs.modedb);\n\tinfo->monspecs.modedb = NULL;\n\n\terr = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (err < 0)\n\t\tgoto out_unmap2;\n\n\tinfo->var.activate |= FB_ACTIVATE_NOW;\n\tinfo->device = &dev->dev;\n\tif (register_framebuffer(info) < 0) {\n\t\tprintk(KERN_ERR \"tridentfb: could not register framebuffer\\n\");\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\terr = -EINVAL;\n\t\tgoto out_unmap2;\n\t}\n\toutput(\"fb%d: %s frame buffer device %dx%d-%dbpp\\n\",\n\t   info->node, info->fix.id, info->var.xres,\n\t   info->var.yres, info->var.bits_per_pixel);\n\n\tpci_set_drvdata(dev, info);\n\treturn 0;\n\nout_unmap2:\n\tif (default_par->ddc_registered)\n\t\ti2c_del_adapter(&default_par->ddc_adapter);\n\tkfree(info->pixmap.addr);\n\tif (info->screen_base)\n\t\tiounmap(info->screen_base);\n\tdisable_mmio(info->par);\nout_unmap1:\n\tif (default_par->io_virt)\n\t\tiounmap(default_par->io_virt);\n\tframebuffer_release(info);\n\treturn err;\n}\n\nstatic void trident_pci_remove(struct pci_dev *dev)\n{\n\tstruct fb_info *info = pci_get_drvdata(dev);\n\tstruct tridentfb_par *par = info->par;\n\n\tunregister_framebuffer(info);\n\tif (par->ddc_registered)\n\t\ti2c_del_adapter(&par->ddc_adapter);\n\tiounmap(par->io_virt);\n\tiounmap(info->screen_base);\n\tkfree(info->pixmap.addr);\n\tfb_dealloc_cmap(&info->cmap);\n\tframebuffer_release(info);\n}\n\n \nstatic const struct pci_device_id trident_devices[] = {\n\t{PCI_VENDOR_ID_TRIDENT,\tBLADE3D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBERBLADEi7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBERBLADEi7D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBERBLADEi1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBERBLADEi1D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBERBLADEAi1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBERBLADEAi1D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBERBLADEE4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tTGUI9440, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tTGUI9660, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tIMAGE975, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tIMAGE985, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBER9320, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBER9388, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBER9520, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBER9525DVD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBER9397, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBER9397DVD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBERBLADEXPAi1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBERBLADEXPm8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_TRIDENT,\tCYBERBLADEXPm16, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, trident_devices);\n\nstatic struct pci_driver tridentfb_pci_driver = {\n\t.name = \"tridentfb\",\n\t.id_table = trident_devices,\n\t.probe = trident_pci_probe,\n\t.remove = trident_pci_remove,\n};\n\n \n#ifndef MODULE\nstatic int __init tridentfb_setup(char *options)\n{\n\tchar *opt;\n\tif (!options || !*options)\n\t\treturn 0;\n\twhile ((opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*opt)\n\t\t\tcontinue;\n\t\tif (!strncmp(opt, \"noaccel\", 7))\n\t\t\tnoaccel = 1;\n\t\telse if (!strncmp(opt, \"fp\", 2))\n\t\t\tfp = 1;\n\t\telse if (!strncmp(opt, \"crt\", 3))\n\t\t\tfp = 0;\n\t\telse if (!strncmp(opt, \"bpp=\", 4))\n\t\t\tbpp = simple_strtoul(opt + 4, NULL, 0);\n\t\telse if (!strncmp(opt, \"center\", 6))\n\t\t\tcenter = 1;\n\t\telse if (!strncmp(opt, \"stretch\", 7))\n\t\t\tstretch = 1;\n\t\telse if (!strncmp(opt, \"memsize=\", 8))\n\t\t\tmemsize = simple_strtoul(opt + 8, NULL, 0);\n\t\telse if (!strncmp(opt, \"memdiff=\", 8))\n\t\t\tmemdiff = simple_strtoul(opt + 8, NULL, 0);\n\t\telse if (!strncmp(opt, \"nativex=\", 8))\n\t\t\tnativex = simple_strtoul(opt + 8, NULL, 0);\n\t\telse\n\t\t\tmode_option = opt;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic int __init tridentfb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"tridentfb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"tridentfb\", &option))\n\t\treturn -ENODEV;\n\ttridentfb_setup(option);\n#endif\n\treturn pci_register_driver(&tridentfb_pci_driver);\n}\n\nstatic void __exit tridentfb_exit(void)\n{\n\tpci_unregister_driver(&tridentfb_pci_driver);\n}\n\nmodule_init(tridentfb_init);\nmodule_exit(tridentfb_exit);\n\nMODULE_AUTHOR(\"Jani Monoses <jani@iv.ro>\");\nMODULE_DESCRIPTION(\"Framebuffer driver for Trident cards\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"cyblafb\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}