{
  "module_name": "sunxvr1000.c",
  "hash_id": "dbd313e5b5e6d657045554b8acb3118e20688a77b635b747cbdfc49aa132d493",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/sunxvr1000.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\nstruct gfb_info {\n\tstruct fb_info\t\t*info;\n\n\tchar __iomem\t\t*fb_base;\n\tunsigned long\t\tfb_base_phys;\n\n\tstruct device_node\t*of_node;\n\n\tunsigned int\t\twidth;\n\tunsigned int\t\theight;\n\tunsigned int\t\tdepth;\n\tunsigned int\t\tfb_size;\n\n\tu32\t\t\tpseudo_palette[16];\n};\n\nstatic int gfb_get_props(struct gfb_info *gp)\n{\n\tgp->width = of_getintprop_default(gp->of_node, \"width\", 0);\n\tgp->height = of_getintprop_default(gp->of_node, \"height\", 0);\n\tgp->depth = of_getintprop_default(gp->of_node, \"depth\", 32);\n\n\tif (!gp->width || !gp->height) {\n\t\tprintk(KERN_ERR \"gfb: Critical properties missing for %pOF\\n\",\n\t\t       gp->of_node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfb_setcolreg(unsigned regno,\n\t\t\t unsigned red, unsigned green, unsigned blue,\n\t\t\t unsigned transp, struct fb_info *info)\n{\n\tu32 value;\n\n\tif (regno < 16) {\n\t\tred >>= 8;\n\t\tgreen >>= 8;\n\t\tblue >>= 8;\n\n\t\tvalue = (blue << 16) | (green << 8) | red;\n\t\t((u32 *)info->pseudo_palette)[regno] = value;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct fb_ops gfb_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_setcolreg\t\t= gfb_setcolreg,\n};\n\nstatic int gfb_set_fbinfo(struct gfb_info *gp)\n{\n\tstruct fb_info *info = gp->info;\n\tstruct fb_var_screeninfo *var = &info->var;\n\n\tinfo->fbops = &gfb_ops;\n\tinfo->screen_base = gp->fb_base;\n\tinfo->screen_size = gp->fb_size;\n\n\tinfo->pseudo_palette = gp->pseudo_palette;\n\n\t \n\tstrscpy(info->fix.id, \"gfb\", sizeof(info->fix.id));\n        info->fix.smem_start = gp->fb_base_phys;\n        info->fix.smem_len = gp->fb_size;\n        info->fix.type = FB_TYPE_PACKED_PIXELS;\n\tif (gp->depth == 32 || gp->depth == 24)\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\telse\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\n\tvar->xres = gp->width;\n\tvar->yres = gp->height;\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = var->yres;\n\tvar->bits_per_pixel = gp->depth;\n\n\tvar->red.offset = 0;\n\tvar->red.length = 8;\n\tvar->green.offset = 8;\n\tvar->green.length = 8;\n\tvar->blue.offset = 16;\n\tvar->blue.length = 8;\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0)) {\n\t\tprintk(KERN_ERR \"gfb: Cannot allocate color map.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n        return 0;\n}\n\nstatic int gfb_probe(struct platform_device *op)\n{\n\tstruct device_node *dp = op->dev.of_node;\n\tstruct fb_info *info;\n\tstruct gfb_info *gp;\n\tint err;\n\n\tinfo = framebuffer_alloc(sizeof(struct gfb_info), &op->dev);\n\tif (!info) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tgp = info->par;\n\tgp->info = info;\n\tgp->of_node = dp;\n\n\tgp->fb_base_phys = op->resource[6].start;\n\n\terr = gfb_get_props(gp);\n\tif (err)\n\t\tgoto err_release_fb;\n\n\t \n\tinfo->fix.line_length = 16384;\n\tgp->fb_size = info->fix.line_length * gp->height;\n\n\tgp->fb_base = of_ioremap(&op->resource[6], 0,\n\t\t\t\t gp->fb_size, \"gfb fb\");\n\tif (!gp->fb_base) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release_fb;\n\t}\n\n\terr = gfb_set_fbinfo(gp);\n\tif (err)\n\t\tgoto err_unmap_fb;\n\n\tprintk(\"gfb: Found device at %pOF\\n\", dp);\n\n\terr = register_framebuffer(info);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"gfb: Could not register framebuffer %pOF\\n\",\n\t\t       dp);\n\t\tgoto err_unmap_fb;\n\t}\n\n\tdev_set_drvdata(&op->dev, info);\n\n\treturn 0;\n\nerr_unmap_fb:\n\tof_iounmap(&op->resource[6], gp->fb_base, gp->fb_size);\n\nerr_release_fb:\n        framebuffer_release(info);\n\nerr_out:\n\treturn err;\n}\n\nstatic const struct of_device_id gfb_match[] = {\n\t{\n\t\t.name = \"SUNW,gfb\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver gfb_driver = {\n\t.probe\t\t= gfb_probe,\n\t.driver = {\n\t\t.name\t\t\t= \"gfb\",\n\t\t.of_match_table\t\t= gfb_match,\n\t\t.suppress_bind_attrs\t= true,\n\t},\n};\n\nstatic int __init gfb_init(void)\n{\n\tif (fb_get_options(\"gfb\", NULL))\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&gfb_driver);\n}\ndevice_initcall(gfb_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}