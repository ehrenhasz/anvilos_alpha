{
  "module_name": "s3c-fb.c",
  "hash_id": "d92e516b9f8ba5908dd0c099884f0d050fdb2825dd61bb9eb556f432eca89e4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/s3c-fb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/clk.h>\n#include <linux/fb.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_data/video_s3c.h>\n\n#include <video/samsung_fimd.h>\n\n \n\n \n\n#ifdef CONFIG_FB_S3C_DEBUG_REGWRITE\n#undef writel\n#define writel(v, r) do { \\\n\tpr_debug(\"%s: %08x => %p\\n\", __func__, (unsigned int)v, r); \\\n\t__raw_writel(v, r); \\\n} while (0)\n#endif  \n\n \n#define S3C_FB_VSYNC_IRQ_EN\t0\n\n#define VSYNC_TIMEOUT_MSEC 50\n\nstruct s3c_fb;\n\n#define VALID_BPP(x) (1 << ((x) - 1))\n\n#define OSD_BASE(win, variant) ((variant).osd + ((win) * (variant).osd_stride))\n#define VIDOSD_A(win, variant) (OSD_BASE(win, variant) + 0x00)\n#define VIDOSD_B(win, variant) (OSD_BASE(win, variant) + 0x04)\n#define VIDOSD_C(win, variant) (OSD_BASE(win, variant) + 0x08)\n#define VIDOSD_D(win, variant) (OSD_BASE(win, variant) + 0x0C)\n\n \nstruct s3c_fb_variant {\n\tunsigned int\tis_2443:1;\n\tunsigned short\tnr_windows;\n\tunsigned int\tvidtcon;\n\tunsigned short\twincon;\n\tunsigned short\twinmap;\n\tunsigned short\tkeycon;\n\tunsigned short\tbuf_start;\n\tunsigned short\tbuf_end;\n\tunsigned short\tbuf_size;\n\tunsigned short\tosd;\n\tunsigned short\tosd_stride;\n\tunsigned short\tpalette[S3C_FB_MAX_WIN];\n\n\tunsigned int\thas_prtcon:1;\n\tunsigned int\thas_shadowcon:1;\n\tunsigned int\thas_blendcon:1;\n\tunsigned int\thas_clksel:1;\n\tunsigned int\thas_fixvclk:1;\n};\n\n \nstruct s3c_fb_win_variant {\n\tunsigned int\thas_osd_c:1;\n\tunsigned int\thas_osd_d:1;\n\tunsigned int\thas_osd_alpha:1;\n\tunsigned int\tpalette_16bpp:1;\n\tunsigned short\tosd_size_off;\n\tunsigned short\tpalette_sz;\n\tu32\t\tvalid_bpp;\n};\n\n \nstruct s3c_fb_driverdata {\n\tstruct s3c_fb_variant\tvariant;\n\tstruct s3c_fb_win_variant *win[S3C_FB_MAX_WIN];\n};\n\n \nstruct s3c_fb_palette {\n\tstruct fb_bitfield\tr;\n\tstruct fb_bitfield\tg;\n\tstruct fb_bitfield\tb;\n\tstruct fb_bitfield\ta;\n};\n\n \nstruct s3c_fb_win {\n\tstruct s3c_fb_pd_win\t*windata;\n\tstruct s3c_fb\t\t*parent;\n\tstruct fb_info\t\t*fbinfo;\n\tstruct s3c_fb_palette\t palette;\n\tstruct s3c_fb_win_variant variant;\n\n\tu32\t\t\t*palette_buffer;\n\tu32\t\t\t pseudo_palette[16];\n\tunsigned int\t\t index;\n};\n\n \nstruct s3c_fb_vsync {\n\twait_queue_head_t\twait;\n\tunsigned int\t\tcount;\n};\n\n \nstruct s3c_fb {\n\tspinlock_t\t\tslock;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*bus_clk;\n\tstruct clk\t\t*lcd_clk;\n\tvoid __iomem\t\t*regs;\n\tstruct s3c_fb_variant\t variant;\n\n\tunsigned char\t\t enabled;\n\tbool\t\t\t output_on;\n\n\tstruct s3c_fb_platdata\t*pdata;\n\tstruct s3c_fb_win\t*windows[S3C_FB_MAX_WIN];\n\n\tint\t\t\t irq_no;\n\tunsigned long\t\t irq_flags;\n\tstruct s3c_fb_vsync\t vsync_info;\n};\n\n \nstatic bool s3c_fb_validate_win_bpp(struct s3c_fb_win *win, unsigned int bpp)\n{\n\treturn win->variant.valid_bpp & VALID_BPP(bpp);\n}\n\n \nstatic int s3c_fb_check_var(struct fb_var_screeninfo *var,\n\t\t\t    struct fb_info *info)\n{\n\tstruct s3c_fb_win *win = info->par;\n\tstruct s3c_fb *sfb = win->parent;\n\n\tdev_dbg(sfb->dev, \"checking parameters\\n\");\n\n\tvar->xres_virtual = max(var->xres_virtual, var->xres);\n\tvar->yres_virtual = max(var->yres_virtual, var->yres);\n\n\tif (!s3c_fb_validate_win_bpp(win, var->bits_per_pixel)) {\n\t\tdev_dbg(sfb->dev, \"win %d: unsupported bpp %d\\n\",\n\t\t\twin->index, var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\t\tif (sfb->variant.palette[win->index] != 0) {\n\t\t\t \n\t\t\tvar->red.offset\t\t= 5;\n\t\t\tvar->green.offset\t= 2;\n\t\t\tvar->blue.offset\t= 0;\n\t\t\tvar->red.length\t\t= 2;\n\t\t\tvar->green.length\t= 3;\n\t\t\tvar->blue.length\t= 2;\n\t\t\tvar->transp.offset\t= 7;\n\t\t\tvar->transp.length\t= 1;\n\t\t} else {\n\t\t\tvar->red.offset\t= 0;\n\t\t\tvar->red.length\t= var->bits_per_pixel;\n\t\t\tvar->green\t= var->red;\n\t\t\tvar->blue\t= var->red;\n\t\t}\n\t\tbreak;\n\n\tcase 19:\n\t\t \n\t\tvar->transp.offset\t= 18;\n\t\tvar->transp.length\t= 1;\n\t\tfallthrough;\n\tcase 18:\n\t\tvar->bits_per_pixel\t= 32;\n\n\t\t \n\t\tvar->red.offset\t\t= 12;\n\t\tvar->green.offset\t= 6;\n\t\tvar->blue.offset\t= 0;\n\t\tvar->red.length\t\t= 6;\n\t\tvar->green.length\t= 6;\n\t\tvar->blue.length\t= 6;\n\t\tbreak;\n\n\tcase 16:\n\t\t \n\t\tvar->red.offset\t\t= 11;\n\t\tvar->green.offset\t= 5;\n\t\tvar->blue.offset\t= 0;\n\t\tvar->red.length\t\t= 5;\n\t\tvar->green.length\t= 6;\n\t\tvar->blue.length\t= 5;\n\t\tbreak;\n\n\tcase 32:\n\tcase 28:\n\tcase 25:\n\t\tvar->transp.length\t= var->bits_per_pixel - 24;\n\t\tvar->transp.offset\t= 24;\n\t\tfallthrough;\n\tcase 24:\n\t\t \n\t\tvar->bits_per_pixel\t= 32;\n\t\tvar->red.offset\t\t= 16;\n\t\tvar->red.length\t\t= 8;\n\t\tvar->green.offset\t= 8;\n\t\tvar->green.length\t= 8;\n\t\tvar->blue.offset\t= 0;\n\t\tvar->blue.length\t= 8;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(sfb->dev, \"invalid bpp\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(sfb->dev, \"%s: verified parameters\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic int s3c_fb_calc_pixclk(struct s3c_fb *sfb, unsigned int pixclk)\n{\n\tunsigned long clk;\n\tunsigned long long tmp;\n\tunsigned int result;\n\n\tif (sfb->variant.has_clksel)\n\t\tclk = clk_get_rate(sfb->bus_clk);\n\telse\n\t\tclk = clk_get_rate(sfb->lcd_clk);\n\n\ttmp = (unsigned long long)clk;\n\ttmp *= pixclk;\n\n\tdo_div(tmp, 1000000000UL);\n\tresult = (unsigned int)tmp / 1000;\n\n\tdev_dbg(sfb->dev, \"pixclk=%u, clk=%lu, div=%d (%lu)\\n\",\n\t\tpixclk, clk, result, result ? clk / result : clk);\n\n\treturn result;\n}\n\n \nstatic int s3c_fb_align_word(unsigned int bpp, unsigned int pix)\n{\n\tint pix_per_word;\n\n\tif (bpp > 16)\n\t\treturn pix;\n\n\tpix_per_word = (8 * 32) / bpp;\n\treturn ALIGN(pix, pix_per_word);\n}\n\n \nstatic void vidosd_set_size(struct s3c_fb_win *win, u32 size)\n{\n\tstruct s3c_fb *sfb = win->parent;\n\n\t \n\tif (win->variant.osd_size_off)\n\t\twritel(size, sfb->regs + OSD_BASE(win->index, sfb->variant)\n\t\t\t\t+ win->variant.osd_size_off);\n}\n\n \nstatic void vidosd_set_alpha(struct s3c_fb_win *win, u32 alpha)\n{\n\tstruct s3c_fb *sfb = win->parent;\n\n\tif (win->variant.has_osd_alpha)\n\t\twritel(alpha, sfb->regs + VIDOSD_C(win->index, sfb->variant));\n}\n\n \nstatic void shadow_protect_win(struct s3c_fb_win *win, bool protect)\n{\n\tstruct s3c_fb *sfb = win->parent;\n\tu32 reg;\n\n\tif (protect) {\n\t\tif (sfb->variant.has_prtcon) {\n\t\t\twritel(PRTCON_PROTECT, sfb->regs + PRTCON);\n\t\t} else if (sfb->variant.has_shadowcon) {\n\t\t\treg = readl(sfb->regs + SHADOWCON);\n\t\t\twritel(reg | SHADOWCON_WINx_PROTECT(win->index),\n\t\t\t\tsfb->regs + SHADOWCON);\n\t\t}\n\t} else {\n\t\tif (sfb->variant.has_prtcon) {\n\t\t\twritel(0, sfb->regs + PRTCON);\n\t\t} else if (sfb->variant.has_shadowcon) {\n\t\t\treg = readl(sfb->regs + SHADOWCON);\n\t\t\twritel(reg & ~SHADOWCON_WINx_PROTECT(win->index),\n\t\t\t\tsfb->regs + SHADOWCON);\n\t\t}\n\t}\n}\n\n \nstatic void s3c_fb_enable(struct s3c_fb *sfb, int enable)\n{\n\tu32 vidcon0 = readl(sfb->regs + VIDCON0);\n\n\tif (enable && !sfb->output_on)\n\t\tpm_runtime_get_sync(sfb->dev);\n\n\tif (enable) {\n\t\tvidcon0 |= VIDCON0_ENVID | VIDCON0_ENVID_F;\n\t} else {\n\t\t \n\n\t\tif (vidcon0 & VIDCON0_ENVID) {\n\t\t\tvidcon0 |= VIDCON0_ENVID;\n\t\t\tvidcon0 &= ~VIDCON0_ENVID_F;\n\t\t}\n\t}\n\n\twritel(vidcon0, sfb->regs + VIDCON0);\n\n\tif (!enable && sfb->output_on)\n\t\tpm_runtime_put_sync(sfb->dev);\n\n\tsfb->output_on = enable;\n}\n\n \nstatic int s3c_fb_set_par(struct fb_info *info)\n{\n\tstruct fb_var_screeninfo *var = &info->var;\n\tstruct s3c_fb_win *win = info->par;\n\tstruct s3c_fb *sfb = win->parent;\n\tvoid __iomem *regs = sfb->regs;\n\tvoid __iomem *buf;\n\tint win_no = win->index;\n\tu32 alpha = 0;\n\tu32 data;\n\tu32 pagewidth;\n\n\tdev_dbg(sfb->dev, \"setting framebuffer parameters\\n\");\n\n\tpm_runtime_get_sync(sfb->dev);\n\n\tshadow_protect_win(win, 1);\n\n\tswitch (var->bits_per_pixel) {\n\tcase 32:\n\tcase 24:\n\tcase 16:\n\tcase 12:\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\tcase 8:\n\t\tif (win->variant.palette_sz >= 256)\n\t\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\telse\n\t\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\tcase 1:\n\t\tinfo->fix.visual = FB_VISUAL_MONO01;\n\t\tbreak;\n\tdefault:\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\t}\n\n\tinfo->fix.line_length = (var->xres_virtual * var->bits_per_pixel) / 8;\n\n\tinfo->fix.xpanstep = info->var.xres_virtual > info->var.xres ? 1 : 0;\n\tinfo->fix.ypanstep = info->var.yres_virtual > info->var.yres ? 1 : 0;\n\n\t \n\twritel(0, regs + WINCON(win_no));\n\n\tif (!sfb->output_on)\n\t\ts3c_fb_enable(sfb, 1);\n\n\t \n\n\t \n\tbuf = regs + win_no * 8;\n\n\twritel(info->fix.smem_start, buf + sfb->variant.buf_start);\n\n\tdata = info->fix.smem_start + info->fix.line_length * var->yres;\n\twritel(data, buf + sfb->variant.buf_end);\n\n\tpagewidth = (var->xres * var->bits_per_pixel) >> 3;\n\tdata = VIDW_BUF_SIZE_OFFSET(info->fix.line_length - pagewidth) |\n\t       VIDW_BUF_SIZE_PAGEWIDTH(pagewidth) |\n\t       VIDW_BUF_SIZE_OFFSET_E(info->fix.line_length - pagewidth) |\n\t       VIDW_BUF_SIZE_PAGEWIDTH_E(pagewidth);\n\twritel(data, regs + sfb->variant.buf_size + (win_no * 4));\n\n\t \n\n\tdata = VIDOSDxA_TOPLEFT_X(0) | VIDOSDxA_TOPLEFT_Y(0) |\n\t       VIDOSDxA_TOPLEFT_X_E(0) | VIDOSDxA_TOPLEFT_Y_E(0);\n\twritel(data, regs + VIDOSD_A(win_no, sfb->variant));\n\n\tdata = VIDOSDxB_BOTRIGHT_X(s3c_fb_align_word(var->bits_per_pixel,\n\t\t\t\t\t\t     var->xres - 1)) |\n\t       VIDOSDxB_BOTRIGHT_Y(var->yres - 1) |\n\t       VIDOSDxB_BOTRIGHT_X_E(s3c_fb_align_word(var->bits_per_pixel,\n\t\t\t\t\t\t     var->xres - 1)) |\n\t       VIDOSDxB_BOTRIGHT_Y_E(var->yres - 1);\n\n\twritel(data, regs + VIDOSD_B(win_no, sfb->variant));\n\n\tdata = var->xres * var->yres;\n\n\talpha = VIDISD14C_ALPHA1_R(0xf) |\n\t\tVIDISD14C_ALPHA1_G(0xf) |\n\t\tVIDISD14C_ALPHA1_B(0xf);\n\n\tvidosd_set_alpha(win, alpha);\n\tvidosd_set_size(win, data);\n\n\t \n\tif (sfb->variant.has_shadowcon) {\n\t\tdata = readl(sfb->regs + SHADOWCON);\n\t\tdata |= SHADOWCON_CHx_ENABLE(win_no);\n\t\twritel(data, sfb->regs + SHADOWCON);\n\t}\n\n\tdata = WINCONx_ENWIN;\n\tsfb->enabled |= (1 << win->index);\n\n\t \n\n\tswitch (var->bits_per_pixel) {\n\tcase 1:\n\t\tdata |= WINCON0_BPPMODE_1BPP;\n\t\tdata |= WINCONx_BITSWP;\n\t\tdata |= WINCONx_BURSTLEN_4WORD;\n\t\tbreak;\n\tcase 2:\n\t\tdata |= WINCON0_BPPMODE_2BPP;\n\t\tdata |= WINCONx_BITSWP;\n\t\tdata |= WINCONx_BURSTLEN_8WORD;\n\t\tbreak;\n\tcase 4:\n\t\tdata |= WINCON0_BPPMODE_4BPP;\n\t\tdata |= WINCONx_BITSWP;\n\t\tdata |= WINCONx_BURSTLEN_8WORD;\n\t\tbreak;\n\tcase 8:\n\t\tif (var->transp.length != 0)\n\t\t\tdata |= WINCON1_BPPMODE_8BPP_1232;\n\t\telse\n\t\t\tdata |= WINCON0_BPPMODE_8BPP_PALETTE;\n\t\tdata |= WINCONx_BURSTLEN_8WORD;\n\t\tdata |= WINCONx_BYTSWP;\n\t\tbreak;\n\tcase 16:\n\t\tif (var->transp.length != 0)\n\t\t\tdata |= WINCON1_BPPMODE_16BPP_A1555;\n\t\telse\n\t\t\tdata |= WINCON0_BPPMODE_16BPP_565;\n\t\tdata |= WINCONx_HAWSWP;\n\t\tdata |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tif (var->red.length == 6) {\n\t\t\tif (var->transp.length != 0)\n\t\t\t\tdata |= WINCON1_BPPMODE_19BPP_A1666;\n\t\t\telse\n\t\t\t\tdata |= WINCON1_BPPMODE_18BPP_666;\n\t\t} else if (var->transp.length == 1)\n\t\t\tdata |= WINCON1_BPPMODE_25BPP_A1888\n\t\t\t\t| WINCON1_BLD_PIX;\n\t\telse if ((var->transp.length == 4) ||\n\t\t\t(var->transp.length == 8))\n\t\t\tdata |= WINCON1_BPPMODE_28BPP_A4888\n\t\t\t\t| WINCON1_BLD_PIX | WINCON1_ALPHA_SEL;\n\t\telse\n\t\t\tdata |= WINCON0_BPPMODE_24BPP_888;\n\n\t\tdata |= WINCONx_WSWP;\n\t\tdata |= WINCONx_BURSTLEN_16WORD;\n\t\tbreak;\n\t}\n\n\t \n\tif (win_no > 0) {\n\t\tu32 keycon0_data = 0, keycon1_data = 0;\n\t\tvoid __iomem *keycon = regs + sfb->variant.keycon;\n\n\t\tkeycon0_data = ~(WxKEYCON0_KEYBL_EN |\n\t\t\t\tWxKEYCON0_KEYEN_F |\n\t\t\t\tWxKEYCON0_DIRCON) | WxKEYCON0_COMPKEY(0);\n\n\t\tkeycon1_data = WxKEYCON1_COLVAL(0xffffff);\n\n\t\tkeycon += (win_no - 1) * 8;\n\n\t\twritel(keycon0_data, keycon + WKEYCON0);\n\t\twritel(keycon1_data, keycon + WKEYCON1);\n\t}\n\n\twritel(data, regs + sfb->variant.wincon + (win_no * 4));\n\twritel(0x0, regs + sfb->variant.winmap + (win_no * 4));\n\n\t \n\tif (sfb->variant.has_blendcon) {\n\t\tdata = readl(sfb->regs + BLENDCON);\n\t\tdata &= ~BLENDCON_NEW_MASK;\n\t\tif (var->transp.length > 4)\n\t\t\tdata |= BLENDCON_NEW_8BIT_ALPHA_VALUE;\n\t\telse\n\t\t\tdata |= BLENDCON_NEW_4BIT_ALPHA_VALUE;\n\t\twritel(data, sfb->regs + BLENDCON);\n\t}\n\n\tshadow_protect_win(win, 0);\n\n\tpm_runtime_put_sync(sfb->dev);\n\n\treturn 0;\n}\n\n \nstatic void s3c_fb_update_palette(struct s3c_fb *sfb,\n\t\t\t\t  struct s3c_fb_win *win,\n\t\t\t\t  unsigned int reg,\n\t\t\t\t  u32 value)\n{\n\tvoid __iomem *palreg;\n\tu32 palcon;\n\n\tpalreg = sfb->regs + sfb->variant.palette[win->index];\n\n\tdev_dbg(sfb->dev, \"%s: win %d, reg %d (%p): %08x\\n\",\n\t\t__func__, win->index, reg, palreg, value);\n\n\twin->palette_buffer[reg] = value;\n\n\tpalcon = readl(sfb->regs + WPALCON);\n\twritel(palcon | WPALCON_PAL_UPDATE, sfb->regs + WPALCON);\n\n\tif (win->variant.palette_16bpp)\n\t\twritew(value, palreg + (reg * 2));\n\telse\n\t\twritel(value, palreg + (reg * 4));\n\n\twritel(palcon, sfb->regs + WPALCON);\n}\n\nstatic inline unsigned int chan_to_field(unsigned int chan,\n\t\t\t\t\t struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\n \nstatic int s3c_fb_setcolreg(unsigned regno,\n\t\t\t    unsigned red, unsigned green, unsigned blue,\n\t\t\t    unsigned transp, struct fb_info *info)\n{\n\tstruct s3c_fb_win *win = info->par;\n\tstruct s3c_fb *sfb = win->parent;\n\tunsigned int val;\n\n\tdev_dbg(sfb->dev, \"%s: win %d: %d => rgb=%d/%d/%d\\n\",\n\t\t__func__, win->index, regno, red, green, blue);\n\n\tpm_runtime_get_sync(sfb->dev);\n\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\t \n\n\t\tif (regno < 16) {\n\t\t\tu32 *pal = info->pseudo_palette;\n\n\t\t\tval  = chan_to_field(red,   &info->var.red);\n\t\t\tval |= chan_to_field(green, &info->var.green);\n\t\t\tval |= chan_to_field(blue,  &info->var.blue);\n\n\t\t\tpal[regno] = val;\n\t\t}\n\t\tbreak;\n\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tif (regno < win->variant.palette_sz) {\n\t\t\tval  = chan_to_field(red, &win->palette.r);\n\t\t\tval |= chan_to_field(green, &win->palette.g);\n\t\t\tval |= chan_to_field(blue, &win->palette.b);\n\n\t\t\ts3c_fb_update_palette(sfb, win, regno, val);\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tpm_runtime_put_sync(sfb->dev);\n\t\treturn 1;\t \n\t}\n\n\tpm_runtime_put_sync(sfb->dev);\n\treturn 0;\n}\n\n \nstatic int s3c_fb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct s3c_fb_win *win = info->par;\n\tstruct s3c_fb *sfb = win->parent;\n\tunsigned int index = win->index;\n\tu32 wincon;\n\tu32 output_on = sfb->output_on;\n\n\tdev_dbg(sfb->dev, \"blank mode %d\\n\", blank_mode);\n\n\tpm_runtime_get_sync(sfb->dev);\n\n\twincon = readl(sfb->regs + sfb->variant.wincon + (index * 4));\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_POWERDOWN:\n\t\twincon &= ~WINCONx_ENWIN;\n\t\tsfb->enabled &= ~(1 << index);\n\t\tfallthrough;\t \n\n\tcase FB_BLANK_NORMAL:\n\t\t \n\t\tshadow_protect_win(win, 1);\n\t\twritel(WINxMAP_MAP | WINxMAP_MAP_COLOUR(0x0),\n\t\t       sfb->regs + sfb->variant.winmap + (index * 4));\n\t\tshadow_protect_win(win, 0);\n\t\tbreak;\n\n\tcase FB_BLANK_UNBLANK:\n\t\tshadow_protect_win(win, 1);\n\t\twritel(0x0, sfb->regs + sfb->variant.winmap + (index * 4));\n\t\tshadow_protect_win(win, 0);\n\t\twincon |= WINCONx_ENWIN;\n\t\tsfb->enabled |= (1 << index);\n\t\tbreak;\n\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tdefault:\n\t\tpm_runtime_put_sync(sfb->dev);\n\t\treturn 1;\n\t}\n\n\tshadow_protect_win(win, 1);\n\twritel(wincon, sfb->regs + sfb->variant.wincon + (index * 4));\n\n\t \n\ts3c_fb_enable(sfb, sfb->enabled ? 1 : 0);\n\tshadow_protect_win(win, 0);\n\n\tpm_runtime_put_sync(sfb->dev);\n\n\treturn output_on == sfb->output_on;\n}\n\n \nstatic int s3c_fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct s3c_fb_win *win\t= info->par;\n\tstruct s3c_fb *sfb\t= win->parent;\n\tvoid __iomem *buf\t= sfb->regs + win->index * 8;\n\tunsigned int start_boff, end_boff;\n\n\tpm_runtime_get_sync(sfb->dev);\n\n\t \n\tstart_boff = var->yoffset * info->fix.line_length;\n\t \n\tif (info->var.bits_per_pixel >= 8) {\n\t\tstart_boff += var->xoffset * (info->var.bits_per_pixel >> 3);\n\t} else {\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 4:\n\t\t\tstart_boff += var->xoffset >> 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart_boff += var->xoffset >> 2;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstart_boff += var->xoffset >> 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(sfb->dev, \"invalid bpp\\n\");\n\t\t\tpm_runtime_put_sync(sfb->dev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\tend_boff = start_boff + info->var.yres * info->fix.line_length;\n\n\t \n\tshadow_protect_win(win, 1);\n\n\twritel(info->fix.smem_start + start_boff, buf + sfb->variant.buf_start);\n\twritel(info->fix.smem_start + end_boff, buf + sfb->variant.buf_end);\n\n\tshadow_protect_win(win, 0);\n\n\tpm_runtime_put_sync(sfb->dev);\n\treturn 0;\n}\n\n \nstatic void s3c_fb_enable_irq(struct s3c_fb *sfb)\n{\n\tvoid __iomem *regs = sfb->regs;\n\tu32 irq_ctrl_reg;\n\n\tif (!test_and_set_bit(S3C_FB_VSYNC_IRQ_EN, &sfb->irq_flags)) {\n\t\t \n\t\tirq_ctrl_reg = readl(regs + VIDINTCON0);\n\n\t\tirq_ctrl_reg |= VIDINTCON0_INT_ENABLE;\n\t\tirq_ctrl_reg |= VIDINTCON0_INT_FRAME;\n\n\t\tirq_ctrl_reg &= ~VIDINTCON0_FRAMESEL0_MASK;\n\t\tirq_ctrl_reg |= VIDINTCON0_FRAMESEL0_VSYNC;\n\t\tirq_ctrl_reg &= ~VIDINTCON0_FRAMESEL1_MASK;\n\t\tirq_ctrl_reg |= VIDINTCON0_FRAMESEL1_NONE;\n\n\t\twritel(irq_ctrl_reg, regs + VIDINTCON0);\n\t}\n}\n\n \nstatic void s3c_fb_disable_irq(struct s3c_fb *sfb)\n{\n\tvoid __iomem *regs = sfb->regs;\n\tu32 irq_ctrl_reg;\n\n\tif (test_and_clear_bit(S3C_FB_VSYNC_IRQ_EN, &sfb->irq_flags)) {\n\t\t \n\t\tirq_ctrl_reg = readl(regs + VIDINTCON0);\n\n\t\tirq_ctrl_reg &= ~VIDINTCON0_INT_FRAME;\n\t\tirq_ctrl_reg &= ~VIDINTCON0_INT_ENABLE;\n\n\t\twritel(irq_ctrl_reg, regs + VIDINTCON0);\n\t}\n}\n\nstatic irqreturn_t s3c_fb_irq(int irq, void *dev_id)\n{\n\tstruct s3c_fb *sfb = dev_id;\n\tvoid __iomem  *regs = sfb->regs;\n\tu32 irq_sts_reg;\n\n\tspin_lock(&sfb->slock);\n\n\tirq_sts_reg = readl(regs + VIDINTCON1);\n\n\tif (irq_sts_reg & VIDINTCON1_INT_FRAME) {\n\n\t\t \n\t\twritel(VIDINTCON1_INT_FRAME, regs + VIDINTCON1);\n\n\t\tsfb->vsync_info.count++;\n\t\twake_up_interruptible(&sfb->vsync_info.wait);\n\t}\n\n\t \n\ts3c_fb_disable_irq(sfb);\n\n\tspin_unlock(&sfb->slock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int s3c_fb_wait_for_vsync(struct s3c_fb *sfb, u32 crtc)\n{\n\tunsigned long count;\n\tint ret;\n\n\tif (crtc != 0)\n\t\treturn -ENODEV;\n\n\tpm_runtime_get_sync(sfb->dev);\n\n\tcount = sfb->vsync_info.count;\n\ts3c_fb_enable_irq(sfb);\n\tret = wait_event_interruptible_timeout(sfb->vsync_info.wait,\n\t\t\t\t       count != sfb->vsync_info.count,\n\t\t\t\t       msecs_to_jiffies(VSYNC_TIMEOUT_MSEC));\n\n\tpm_runtime_put_sync(sfb->dev);\n\n\tif (ret == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int s3c_fb_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct s3c_fb_win *win = info->par;\n\tstruct s3c_fb *sfb = win->parent;\n\tint ret;\n\tu32 crtc;\n\n\tswitch (cmd) {\n\tcase FBIO_WAITFORVSYNC:\n\t\tif (get_user(crtc, (u32 __user *)arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = s3c_fb_wait_for_vsync(sfb, crtc);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct fb_ops s3c_fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= s3c_fb_check_var,\n\t.fb_set_par\t= s3c_fb_set_par,\n\t.fb_blank\t= s3c_fb_blank,\n\t.fb_setcolreg\t= s3c_fb_setcolreg,\n\t.fb_pan_display\t= s3c_fb_pan_display,\n\t.fb_ioctl\t= s3c_fb_ioctl,\n};\n\n \nstatic void s3c_fb_missing_pixclock(struct fb_videomode *mode)\n{\n\tu64 pixclk = 1000000000000ULL;\n\tu32 div;\n\n\tdiv  = mode->left_margin + mode->hsync_len + mode->right_margin +\n\t       mode->xres;\n\tdiv *= mode->upper_margin + mode->vsync_len + mode->lower_margin +\n\t       mode->yres;\n\tdiv *= mode->refresh ? : 60;\n\n\tdo_div(pixclk, div);\n\n\tmode->pixclock = pixclk;\n}\n\n \nstatic int s3c_fb_alloc_memory(struct s3c_fb *sfb, struct s3c_fb_win *win)\n{\n\tstruct s3c_fb_pd_win *windata = win->windata;\n\tunsigned int real_size, virt_size, size;\n\tstruct fb_info *fbi = win->fbinfo;\n\tdma_addr_t map_dma;\n\n\tdev_dbg(sfb->dev, \"allocating memory for display\\n\");\n\n\treal_size = windata->xres * windata->yres;\n\tvirt_size = windata->virtual_x * windata->virtual_y;\n\n\tdev_dbg(sfb->dev, \"real_size=%u (%u.%u), virt_size=%u (%u.%u)\\n\",\n\t\treal_size, windata->xres, windata->yres,\n\t\tvirt_size, windata->virtual_x, windata->virtual_y);\n\n\tsize = (real_size > virt_size) ? real_size : virt_size;\n\tsize *= (windata->max_bpp > 16) ? 32 : windata->max_bpp;\n\tsize /= 8;\n\n\tfbi->fix.smem_len = size;\n\tsize = PAGE_ALIGN(size);\n\n\tdev_dbg(sfb->dev, \"want %u bytes for window\\n\", size);\n\n\tfbi->screen_buffer = dma_alloc_wc(sfb->dev, size, &map_dma, GFP_KERNEL);\n\tif (!fbi->screen_buffer)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(sfb->dev, \"mapped %x to %p\\n\",\n\t\t(unsigned int)map_dma, fbi->screen_buffer);\n\n\tmemset(fbi->screen_buffer, 0x0, size);\n\tfbi->fix.smem_start = map_dma;\n\n\treturn 0;\n}\n\n \nstatic void s3c_fb_free_memory(struct s3c_fb *sfb, struct s3c_fb_win *win)\n{\n\tstruct fb_info *fbi = win->fbinfo;\n\n\tif (fbi->screen_buffer)\n\t\tdma_free_wc(sfb->dev, PAGE_ALIGN(fbi->fix.smem_len),\n\t\t\t    fbi->screen_buffer, fbi->fix.smem_start);\n}\n\n \nstatic void s3c_fb_release_win(struct s3c_fb *sfb, struct s3c_fb_win *win)\n{\n\tu32 data;\n\n\tif (win->fbinfo) {\n\t\tif (sfb->variant.has_shadowcon) {\n\t\t\tdata = readl(sfb->regs + SHADOWCON);\n\t\t\tdata &= ~SHADOWCON_CHx_ENABLE(win->index);\n\t\t\tdata &= ~SHADOWCON_CHx_LOCAL_ENABLE(win->index);\n\t\t\twritel(data, sfb->regs + SHADOWCON);\n\t\t}\n\t\tunregister_framebuffer(win->fbinfo);\n\t\tif (win->fbinfo->cmap.len)\n\t\t\tfb_dealloc_cmap(&win->fbinfo->cmap);\n\t\ts3c_fb_free_memory(sfb, win);\n\t\tframebuffer_release(win->fbinfo);\n\t}\n}\n\n \nstatic int s3c_fb_probe_win(struct s3c_fb *sfb, unsigned int win_no,\n\t\t\t    struct s3c_fb_win_variant *variant,\n\t\t\t    struct s3c_fb_win **res)\n{\n\tstruct fb_videomode initmode;\n\tstruct s3c_fb_pd_win *windata;\n\tstruct s3c_fb_win *win;\n\tstruct fb_info *fbinfo;\n\tint palette_size;\n\tint ret;\n\n\tdev_dbg(sfb->dev, \"probing window %d, variant %p\\n\", win_no, variant);\n\n\tinit_waitqueue_head(&sfb->vsync_info.wait);\n\n\tpalette_size = variant->palette_sz * 4;\n\n\tfbinfo = framebuffer_alloc(sizeof(struct s3c_fb_win) +\n\t\t\t\t   palette_size * sizeof(u32), sfb->dev);\n\tif (!fbinfo)\n\t\treturn -ENOMEM;\n\n\twindata = sfb->pdata->win[win_no];\n\tinitmode = *sfb->pdata->vtiming;\n\n\tWARN_ON(windata->max_bpp == 0);\n\tWARN_ON(windata->xres == 0);\n\tWARN_ON(windata->yres == 0);\n\n\twin = fbinfo->par;\n\t*res = win;\n\twin->variant = *variant;\n\twin->fbinfo = fbinfo;\n\twin->parent = sfb;\n\twin->windata = windata;\n\twin->index = win_no;\n\twin->palette_buffer = (u32 *)(win + 1);\n\n\tret = s3c_fb_alloc_memory(sfb, win);\n\tif (ret) {\n\t\tdev_err(sfb->dev, \"failed to allocate display memory\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (win->variant.palette_16bpp) {\n\t\t \n\t\twin->palette.r.offset = 11;\n\t\twin->palette.r.length = 5;\n\t\twin->palette.g.offset = 5;\n\t\twin->palette.g.length = 6;\n\t\twin->palette.b.offset = 0;\n\t\twin->palette.b.length = 5;\n\n\t} else {\n\t\t \n\t\twin->palette.r.offset = 16;\n\t\twin->palette.r.length = 8;\n\t\twin->palette.g.offset = 8;\n\t\twin->palette.g.length = 8;\n\t\twin->palette.b.offset = 0;\n\t\twin->palette.b.length = 8;\n\t}\n\n\t \n\tinitmode.xres = windata->xres;\n\tinitmode.yres = windata->yres;\n\tfb_videomode_to_var(&fbinfo->var, &initmode);\n\n\tfbinfo->fix.type\t= FB_TYPE_PACKED_PIXELS;\n\tfbinfo->fix.accel\t= FB_ACCEL_NONE;\n\tfbinfo->var.activate\t= FB_ACTIVATE_NOW;\n\tfbinfo->var.vmode\t= FB_VMODE_NONINTERLACED;\n\tfbinfo->var.bits_per_pixel = windata->default_bpp;\n\tfbinfo->fbops\t\t= &s3c_fb_ops;\n\tfbinfo->pseudo_palette  = &win->pseudo_palette;\n\n\t \n\n\tret = s3c_fb_check_var(&fbinfo->var, fbinfo);\n\tif (ret < 0) {\n\t\tdev_err(sfb->dev, \"check_var failed on initial video params\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\tret = fb_alloc_cmap(&fbinfo->cmap, win->variant.palette_sz, 1);\n\tif (ret == 0)\n\t\tfb_set_cmap(&fbinfo->cmap, fbinfo);\n\telse\n\t\tdev_err(sfb->dev, \"failed to allocate fb cmap\\n\");\n\n\ts3c_fb_set_par(fbinfo);\n\n\tdev_dbg(sfb->dev, \"about to register framebuffer\\n\");\n\n\t \n\n\tret = register_framebuffer(fbinfo);\n\tif (ret < 0) {\n\t\tdev_err(sfb->dev, \"failed to register framebuffer\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(sfb->dev, \"window %d: fb %s\\n\", win_no, fbinfo->fix.id);\n\n\treturn 0;\n}\n\n \nstatic void s3c_fb_set_rgb_timing(struct s3c_fb *sfb)\n{\n\tstruct fb_videomode *vmode = sfb->pdata->vtiming;\n\tvoid __iomem *regs = sfb->regs;\n\tint clkdiv;\n\tu32 data;\n\n\tif (!vmode->pixclock)\n\t\ts3c_fb_missing_pixclock(vmode);\n\n\tclkdiv = s3c_fb_calc_pixclk(sfb, vmode->pixclock);\n\n\tdata = sfb->pdata->vidcon0;\n\tdata &= ~(VIDCON0_CLKVAL_F_MASK | VIDCON0_CLKDIR);\n\n\tif (clkdiv > 1)\n\t\tdata |= VIDCON0_CLKVAL_F(clkdiv-1) | VIDCON0_CLKDIR;\n\telse\n\t\tdata &= ~VIDCON0_CLKDIR;\t \n\n\tif (sfb->variant.is_2443)\n\t\tdata |= (1 << 5);\n\twritel(data, regs + VIDCON0);\n\n\tdata = VIDTCON0_VBPD(vmode->upper_margin - 1) |\n\t       VIDTCON0_VFPD(vmode->lower_margin - 1) |\n\t       VIDTCON0_VSPW(vmode->vsync_len - 1);\n\twritel(data, regs + sfb->variant.vidtcon);\n\n\tdata = VIDTCON1_HBPD(vmode->left_margin - 1) |\n\t       VIDTCON1_HFPD(vmode->right_margin - 1) |\n\t       VIDTCON1_HSPW(vmode->hsync_len - 1);\n\twritel(data, regs + sfb->variant.vidtcon + 4);\n\n\tdata = VIDTCON2_LINEVAL(vmode->yres - 1) |\n\t       VIDTCON2_HOZVAL(vmode->xres - 1) |\n\t       VIDTCON2_LINEVAL_E(vmode->yres - 1) |\n\t       VIDTCON2_HOZVAL_E(vmode->xres - 1);\n\twritel(data, regs + sfb->variant.vidtcon + 8);\n}\n\n \nstatic void s3c_fb_clear_win(struct s3c_fb *sfb, int win)\n{\n\tvoid __iomem *regs = sfb->regs;\n\tu32 reg;\n\n\twritel(0, regs + sfb->variant.wincon + (win * 4));\n\twritel(0, regs + VIDOSD_A(win, sfb->variant));\n\twritel(0, regs + VIDOSD_B(win, sfb->variant));\n\twritel(0, regs + VIDOSD_C(win, sfb->variant));\n\n\tif (sfb->variant.has_shadowcon) {\n\t\treg = readl(sfb->regs + SHADOWCON);\n\t\treg &= ~(SHADOWCON_WINx_PROTECT(win) |\n\t\t\tSHADOWCON_CHx_ENABLE(win) |\n\t\t\tSHADOWCON_CHx_LOCAL_ENABLE(win));\n\t\twritel(reg, sfb->regs + SHADOWCON);\n\t}\n}\n\nstatic int s3c_fb_probe(struct platform_device *pdev)\n{\n\tconst struct platform_device_id *platid;\n\tstruct s3c_fb_driverdata *fbdrv;\n\tstruct device *dev = &pdev->dev;\n\tstruct s3c_fb_platdata *pd;\n\tstruct s3c_fb *sfb;\n\tint win;\n\tint ret = 0;\n\tu32 reg;\n\n\tplatid = platform_get_device_id(pdev);\n\tfbdrv = (struct s3c_fb_driverdata *)platid->driver_data;\n\n\tif (fbdrv->variant.nr_windows > S3C_FB_MAX_WIN) {\n\t\tdev_err(dev, \"too many windows, cannot attach\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpd = dev_get_platdata(&pdev->dev);\n\tif (!pd) {\n\t\tdev_err(dev, \"no platform data specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsfb = devm_kzalloc(dev, sizeof(*sfb), GFP_KERNEL);\n\tif (!sfb)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(dev, \"allocate new framebuffer %p\\n\", sfb);\n\n\tsfb->dev = dev;\n\tsfb->pdata = pd;\n\tsfb->variant = fbdrv->variant;\n\n\tspin_lock_init(&sfb->slock);\n\n\tsfb->bus_clk = devm_clk_get(dev, \"lcd\");\n\tif (IS_ERR(sfb->bus_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(sfb->bus_clk),\n\t\t\t\t     \"failed to get bus clock\\n\");\n\n\tclk_prepare_enable(sfb->bus_clk);\n\n\tif (!sfb->variant.has_clksel) {\n\t\tsfb->lcd_clk = devm_clk_get(dev, \"sclk_fimd\");\n\t\tif (IS_ERR(sfb->lcd_clk)) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(sfb->lcd_clk),\n\t\t\t\t\t    \"failed to get lcd clock\\n\");\n\t\t\tgoto err_bus_clk;\n\t\t}\n\n\t\tclk_prepare_enable(sfb->lcd_clk);\n\t}\n\n\tpm_runtime_enable(sfb->dev);\n\n\tsfb->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sfb->regs)) {\n\t\tret = PTR_ERR(sfb->regs);\n\t\tgoto err_lcd_clk;\n\t}\n\n\tsfb->irq_no = platform_get_irq(pdev, 0);\n\tif (sfb->irq_no < 0) {\n\t\tret = -ENOENT;\n\t\tgoto err_lcd_clk;\n\t}\n\n\tret = devm_request_irq(dev, sfb->irq_no, s3c_fb_irq,\n\t\t\t  0, \"s3c_fb\", sfb);\n\tif (ret) {\n\t\tdev_err(dev, \"irq request failed\\n\");\n\t\tgoto err_lcd_clk;\n\t}\n\n\tdev_dbg(dev, \"got resources (regs %p), probing windows\\n\", sfb->regs);\n\n\tplatform_set_drvdata(pdev, sfb);\n\tpm_runtime_get_sync(sfb->dev);\n\n\t \n\n\tpd->setup_gpio();\n\n\twritel(pd->vidcon1, sfb->regs + VIDCON1);\n\n\t \n\tif (sfb->variant.has_fixvclk) {\n\t\treg = readl(sfb->regs + VIDCON1);\n\t\treg &= ~VIDCON1_VCLK_MASK;\n\t\treg |= VIDCON1_VCLK_RUN;\n\t\twritel(reg, sfb->regs + VIDCON1);\n\t}\n\n\t \n\n\tfor (win = 0; win < fbdrv->variant.nr_windows; win++)\n\t\ts3c_fb_clear_win(sfb, win);\n\n\t \n\tfor (win = 0; win < (fbdrv->variant.nr_windows - 1); win++) {\n\t\tvoid __iomem *regs = sfb->regs + sfb->variant.keycon;\n\n\t\tregs += (win * 8);\n\t\twritel(0xffffff, regs + WKEYCON0);\n\t\twritel(0xffffff, regs + WKEYCON1);\n\t}\n\n\ts3c_fb_set_rgb_timing(sfb);\n\n\t \n\n\tfor (win = 0; win < fbdrv->variant.nr_windows; win++) {\n\t\tif (!pd->win[win])\n\t\t\tcontinue;\n\n\t\tret = s3c_fb_probe_win(sfb, win, fbdrv->win[win],\n\t\t\t\t       &sfb->windows[win]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to create window %d\\n\", win);\n\t\t\tfor (; win >= 0; win--)\n\t\t\t\ts3c_fb_release_win(sfb, sfb->windows[win]);\n\t\t\tgoto err_pm_runtime;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, sfb);\n\tpm_runtime_put_sync(sfb->dev);\n\n\treturn 0;\n\nerr_pm_runtime:\n\tpm_runtime_put_sync(sfb->dev);\n\nerr_lcd_clk:\n\tpm_runtime_disable(sfb->dev);\n\n\tif (!sfb->variant.has_clksel)\n\t\tclk_disable_unprepare(sfb->lcd_clk);\n\nerr_bus_clk:\n\tclk_disable_unprepare(sfb->bus_clk);\n\n\treturn ret;\n}\n\n \nstatic void s3c_fb_remove(struct platform_device *pdev)\n{\n\tstruct s3c_fb *sfb = platform_get_drvdata(pdev);\n\tint win;\n\n\tpm_runtime_get_sync(sfb->dev);\n\n\tfor (win = 0; win < S3C_FB_MAX_WIN; win++)\n\t\tif (sfb->windows[win])\n\t\t\ts3c_fb_release_win(sfb, sfb->windows[win]);\n\n\tif (!sfb->variant.has_clksel)\n\t\tclk_disable_unprepare(sfb->lcd_clk);\n\n\tclk_disable_unprepare(sfb->bus_clk);\n\n\tpm_runtime_put_sync(sfb->dev);\n\tpm_runtime_disable(sfb->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int s3c_fb_suspend(struct device *dev)\n{\n\tstruct s3c_fb *sfb = dev_get_drvdata(dev);\n\tstruct s3c_fb_win *win;\n\tint win_no;\n\n\tpm_runtime_get_sync(sfb->dev);\n\n\tfor (win_no = S3C_FB_MAX_WIN - 1; win_no >= 0; win_no--) {\n\t\twin = sfb->windows[win_no];\n\t\tif (!win)\n\t\t\tcontinue;\n\n\t\t \n\t\ts3c_fb_blank(FB_BLANK_POWERDOWN, win->fbinfo);\n\t}\n\n\tif (!sfb->variant.has_clksel)\n\t\tclk_disable_unprepare(sfb->lcd_clk);\n\n\tclk_disable_unprepare(sfb->bus_clk);\n\n\tpm_runtime_put_sync(sfb->dev);\n\n\treturn 0;\n}\n\nstatic int s3c_fb_resume(struct device *dev)\n{\n\tstruct s3c_fb *sfb = dev_get_drvdata(dev);\n\tstruct s3c_fb_platdata *pd = sfb->pdata;\n\tstruct s3c_fb_win *win;\n\tint win_no;\n\tu32 reg;\n\n\tpm_runtime_get_sync(sfb->dev);\n\n\tclk_prepare_enable(sfb->bus_clk);\n\n\tif (!sfb->variant.has_clksel)\n\t\tclk_prepare_enable(sfb->lcd_clk);\n\n\t \n\tpd->setup_gpio();\n\twritel(pd->vidcon1, sfb->regs + VIDCON1);\n\n\t \n\tif (sfb->variant.has_fixvclk) {\n\t\treg = readl(sfb->regs + VIDCON1);\n\t\treg &= ~VIDCON1_VCLK_MASK;\n\t\treg |= VIDCON1_VCLK_RUN;\n\t\twritel(reg, sfb->regs + VIDCON1);\n\t}\n\n\t \n\tfor (win_no = 0; win_no < sfb->variant.nr_windows; win_no++)\n\t\ts3c_fb_clear_win(sfb, win_no);\n\n\tfor (win_no = 0; win_no < sfb->variant.nr_windows - 1; win_no++) {\n\t\tvoid __iomem *regs = sfb->regs + sfb->variant.keycon;\n\t\twin = sfb->windows[win_no];\n\t\tif (!win)\n\t\t\tcontinue;\n\n\t\tshadow_protect_win(win, 1);\n\t\tregs += (win_no * 8);\n\t\twritel(0xffffff, regs + WKEYCON0);\n\t\twritel(0xffffff, regs + WKEYCON1);\n\t\tshadow_protect_win(win, 0);\n\t}\n\n\ts3c_fb_set_rgb_timing(sfb);\n\n\t \n\tfor (win_no = 0; win_no < S3C_FB_MAX_WIN; win_no++) {\n\t\twin = sfb->windows[win_no];\n\t\tif (!win)\n\t\t\tcontinue;\n\n\t\tdev_dbg(dev, \"resuming window %d\\n\", win_no);\n\t\ts3c_fb_set_par(win->fbinfo);\n\t}\n\n\tpm_runtime_put_sync(sfb->dev);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int s3c_fb_runtime_suspend(struct device *dev)\n{\n\tstruct s3c_fb *sfb = dev_get_drvdata(dev);\n\n\tif (!sfb->variant.has_clksel)\n\t\tclk_disable_unprepare(sfb->lcd_clk);\n\n\tclk_disable_unprepare(sfb->bus_clk);\n\n\treturn 0;\n}\n\nstatic int s3c_fb_runtime_resume(struct device *dev)\n{\n\tstruct s3c_fb *sfb = dev_get_drvdata(dev);\n\tstruct s3c_fb_platdata *pd = sfb->pdata;\n\n\tclk_prepare_enable(sfb->bus_clk);\n\n\tif (!sfb->variant.has_clksel)\n\t\tclk_prepare_enable(sfb->lcd_clk);\n\n\t \n\tpd->setup_gpio();\n\twritel(pd->vidcon1, sfb->regs + VIDCON1);\n\n\treturn 0;\n}\n#endif\n\n#define VALID_BPP124 (VALID_BPP(1) | VALID_BPP(2) | VALID_BPP(4))\n#define VALID_BPP1248 (VALID_BPP124 | VALID_BPP(8))\n\nstatic struct s3c_fb_win_variant s3c_fb_data_64xx_wins[] = {\n\t[0] = {\n\t\t.has_osd_c\t= 1,\n\t\t.osd_size_off\t= 0x8,\n\t\t.palette_sz\t= 256,\n\t\t.valid_bpp\t= (VALID_BPP1248 | VALID_BPP(16) |\n\t\t\t\t   VALID_BPP(18) | VALID_BPP(24)),\n\t},\n\t[1] = {\n\t\t.has_osd_c\t= 1,\n\t\t.has_osd_d\t= 1,\n\t\t.osd_size_off\t= 0xc,\n\t\t.has_osd_alpha\t= 1,\n\t\t.palette_sz\t= 256,\n\t\t.valid_bpp\t= (VALID_BPP1248 | VALID_BPP(16) |\n\t\t\t\t   VALID_BPP(18) | VALID_BPP(19) |\n\t\t\t\t   VALID_BPP(24) | VALID_BPP(25) |\n\t\t\t\t   VALID_BPP(28)),\n\t},\n\t[2] = {\n\t\t.has_osd_c\t= 1,\n\t\t.has_osd_d\t= 1,\n\t\t.osd_size_off\t= 0xc,\n\t\t.has_osd_alpha\t= 1,\n\t\t.palette_sz\t= 16,\n\t\t.palette_16bpp\t= 1,\n\t\t.valid_bpp\t= (VALID_BPP1248 | VALID_BPP(16) |\n\t\t\t\t   VALID_BPP(18) | VALID_BPP(19) |\n\t\t\t\t   VALID_BPP(24) | VALID_BPP(25) |\n\t\t\t\t   VALID_BPP(28)),\n\t},\n\t[3] = {\n\t\t.has_osd_c\t= 1,\n\t\t.has_osd_alpha\t= 1,\n\t\t.palette_sz\t= 16,\n\t\t.palette_16bpp\t= 1,\n\t\t.valid_bpp\t= (VALID_BPP124  | VALID_BPP(16) |\n\t\t\t\t   VALID_BPP(18) | VALID_BPP(19) |\n\t\t\t\t   VALID_BPP(24) | VALID_BPP(25) |\n\t\t\t\t   VALID_BPP(28)),\n\t},\n\t[4] = {\n\t\t.has_osd_c\t= 1,\n\t\t.has_osd_alpha\t= 1,\n\t\t.palette_sz\t= 4,\n\t\t.palette_16bpp\t= 1,\n\t\t.valid_bpp\t= (VALID_BPP(1) | VALID_BPP(2) |\n\t\t\t\t   VALID_BPP(16) | VALID_BPP(18) |\n\t\t\t\t   VALID_BPP(19) | VALID_BPP(24) |\n\t\t\t\t   VALID_BPP(25) | VALID_BPP(28)),\n\t},\n};\n\nstatic struct s3c_fb_driverdata s3c_fb_data_64xx = {\n\t.variant = {\n\t\t.nr_windows\t= 5,\n\t\t.vidtcon\t= VIDTCON0,\n\t\t.wincon\t\t= WINCON(0),\n\t\t.winmap\t\t= WINxMAP(0),\n\t\t.keycon\t\t= WKEYCON,\n\t\t.osd\t\t= VIDOSD_BASE,\n\t\t.osd_stride\t= 16,\n\t\t.buf_start\t= VIDW_BUF_START(0),\n\t\t.buf_size\t= VIDW_BUF_SIZE(0),\n\t\t.buf_end\t= VIDW_BUF_END(0),\n\n\t\t.palette = {\n\t\t\t[0] = 0x400,\n\t\t\t[1] = 0x800,\n\t\t\t[2] = 0x300,\n\t\t\t[3] = 0x320,\n\t\t\t[4] = 0x340,\n\t\t},\n\n\t\t.has_prtcon\t= 1,\n\t\t.has_clksel\t= 1,\n\t},\n\t.win[0]\t= &s3c_fb_data_64xx_wins[0],\n\t.win[1]\t= &s3c_fb_data_64xx_wins[1],\n\t.win[2]\t= &s3c_fb_data_64xx_wins[2],\n\t.win[3]\t= &s3c_fb_data_64xx_wins[3],\n\t.win[4]\t= &s3c_fb_data_64xx_wins[4],\n};\n\n \nstatic struct s3c_fb_driverdata s3c_fb_data_s3c2443 = {\n\t.variant = {\n\t\t.nr_windows\t= 2,\n\t\t.is_2443\t= 1,\n\n\t\t.vidtcon\t= 0x08,\n\t\t.wincon\t\t= 0x14,\n\t\t.winmap\t\t= 0xd0,\n\t\t.keycon\t\t= 0xb0,\n\t\t.osd\t\t= 0x28,\n\t\t.osd_stride\t= 12,\n\t\t.buf_start\t= 0x64,\n\t\t.buf_size\t= 0x94,\n\t\t.buf_end\t= 0x7c,\n\n\t\t.palette = {\n\t\t\t[0] = 0x400,\n\t\t\t[1] = 0x800,\n\t\t},\n\t\t.has_clksel\t= 1,\n\t},\n\t.win[0] = &(struct s3c_fb_win_variant) {\n\t\t.palette_sz\t= 256,\n\t\t.valid_bpp\t= VALID_BPP1248 | VALID_BPP(16) | VALID_BPP(24),\n\t},\n\t.win[1] = &(struct s3c_fb_win_variant) {\n\t\t.has_osd_c\t= 1,\n\t\t.has_osd_alpha\t= 1,\n\t\t.palette_sz\t= 256,\n\t\t.valid_bpp\t= (VALID_BPP1248 | VALID_BPP(16) |\n\t\t\t\t   VALID_BPP(18) | VALID_BPP(19) |\n\t\t\t\t   VALID_BPP(24) | VALID_BPP(25) |\n\t\t\t\t   VALID_BPP(28)),\n\t},\n};\n\nstatic const struct platform_device_id s3c_fb_driver_ids[] = {\n\t{\n\t\t.name\t\t= \"s3c-fb\",\n\t\t.driver_data\t= (unsigned long)&s3c_fb_data_64xx,\n\t}, {\n\t\t.name\t\t= \"s3c2443-fb\",\n\t\t.driver_data\t= (unsigned long)&s3c_fb_data_s3c2443,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, s3c_fb_driver_ids);\n\nstatic const struct dev_pm_ops s3cfb_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(s3c_fb_suspend, s3c_fb_resume)\n\tSET_RUNTIME_PM_OPS(s3c_fb_runtime_suspend, s3c_fb_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver s3c_fb_driver = {\n\t.probe\t\t= s3c_fb_probe,\n\t.remove_new\t= s3c_fb_remove,\n\t.id_table\t= s3c_fb_driver_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"s3c-fb\",\n\t\t.pm\t= &s3cfb_pm_ops,\n\t},\n};\n\nmodule_platform_driver(s3c_fb_driver);\n\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>\");\nMODULE_DESCRIPTION(\"Samsung S3C SoC Framebuffer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}