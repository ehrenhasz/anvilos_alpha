{
  "module_name": "vt8500lcdfb.c",
  "hash_id": "d4188818b93f31a6adcbb889de657ea786052bceb35237143430850e6648bd4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/vt8500lcdfb.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/wait.h>\n#include <video/of_display_timing.h>\n\n#include \"vt8500lcdfb.h\"\n#include \"wmt_ge_rops.h\"\n\n#ifdef CONFIG_OF\n#include <linux/of.h>\n#include <linux/of_fdt.h>\n#include <linux/memblock.h>\n#endif\n\n\n#define to_vt8500lcd_info(__info) container_of(__info, \\\n\t\t\t\t\t\tstruct vt8500lcd_info, fb)\n\nstatic int vt8500lcd_set_par(struct fb_info *info)\n{\n\tstruct vt8500lcd_info *fbi = to_vt8500lcd_info(info);\n\tint reg_bpp = 5;  \n\tint i;\n\tunsigned long control0;\n\n\tif (!fbi)\n\t\treturn -EINVAL;\n\n\tif (info->var.bits_per_pixel <= 8) {\n\t\t \n\t\tinfo->var.red.offset    = 0;\n\t\tinfo->var.red.length    = info->var.bits_per_pixel;\n\t\tinfo->var.red.msb_right = 0;\n\n\t\tinfo->var.green.offset  = 0;\n\t\tinfo->var.green.length  = info->var.bits_per_pixel;\n\t\tinfo->var.green.msb_right = 0;\n\n\t\tinfo->var.blue.offset   = 0;\n\t\tinfo->var.blue.length   = info->var.bits_per_pixel;\n\t\tinfo->var.blue.msb_right = 0;\n\n\t\tinfo->var.transp.offset = 0;\n\t\tinfo->var.transp.length = 0;\n\t\tinfo->var.transp.msb_right = 0;\n\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tinfo->fix.line_length = info->var.xres_virtual /\n\t\t\t\t\t\t(8/info->var.bits_per_pixel);\n\t} else {\n\t\t \n\t\tinfo->var.transp.offset = 0;\n\t\tinfo->var.transp.length = 0;\n\t\tinfo->var.transp.msb_right = 0;\n\n\t\tif (info->var.bits_per_pixel == 16) {\n\t\t\t \n\t\t\tinfo->var.red.offset = 11;\n\t\t\tinfo->var.red.length = 5;\n\t\t\tinfo->var.red.msb_right = 0;\n\t\t\tinfo->var.green.offset = 5;\n\t\t\tinfo->var.green.length = 6;\n\t\t\tinfo->var.green.msb_right = 0;\n\t\t\tinfo->var.blue.offset = 0;\n\t\t\tinfo->var.blue.length = 5;\n\t\t\tinfo->var.blue.msb_right = 0;\n\t\t} else {\n\t\t\t \n\t\t\tinfo->var.red.offset = info->var.bits_per_pixel\n\t\t\t\t\t\t\t* 2 / 3;\n\t\t\tinfo->var.red.length = info->var.bits_per_pixel / 3;\n\t\t\tinfo->var.red.msb_right = 0;\n\t\t\tinfo->var.green.offset = info->var.bits_per_pixel / 3;\n\t\t\tinfo->var.green.length = info->var.bits_per_pixel / 3;\n\t\t\tinfo->var.green.msb_right = 0;\n\t\t\tinfo->var.blue.offset = 0;\n\t\t\tinfo->var.blue.length = info->var.bits_per_pixel / 3;\n\t\t\tinfo->var.blue.msb_right = 0;\n\t\t}\n\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tinfo->fix.line_length = info->var.bits_per_pixel > 16 ?\n\t\t\t\t\tinfo->var.xres_virtual << 2 :\n\t\t\t\t\tinfo->var.xres_virtual << 1;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (bpp_values[i] == info->var.bits_per_pixel)\n\t\t\treg_bpp = i;\n\t}\n\n\tcontrol0 = readl(fbi->regbase) & ~0xf;\n\twritel(0, fbi->regbase);\n\twhile (readl(fbi->regbase + 0x38) & 0x10)\n\t\t ;\n\twritel((((info->var.hsync_len - 1) & 0x3f) << 26)\n\t\t| ((info->var.left_margin & 0xff) << 18)\n\t\t| (((info->var.xres - 1) & 0x3ff) << 8)\n\t\t| (info->var.right_margin & 0xff), fbi->regbase + 0x4);\n\twritel((((info->var.vsync_len - 1) & 0x3f) << 26)\n\t\t| ((info->var.upper_margin & 0xff) << 18)\n\t\t| (((info->var.yres - 1) & 0x3ff) << 8)\n\t\t| (info->var.lower_margin & 0xff), fbi->regbase + 0x8);\n\twritel((((info->var.yres - 1) & 0x400) << 2)\n\t\t| ((info->var.xres - 1) & 0x400), fbi->regbase + 0x10);\n\twritel(0x80000000, fbi->regbase + 0x20);\n\twritel(control0 | (reg_bpp << 1) | 0x100, fbi->regbase);\n\n\treturn 0;\n}\n\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\nstatic int vt8500lcd_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t   unsigned blue, unsigned transp,\n\t\t\t   struct fb_info *info) {\n\tstruct vt8500lcd_info *fbi = to_vt8500lcd_info(info);\n\tint ret = 1;\n\tunsigned int val;\n\tif (regno >= 256)\n\t\treturn -EINVAL;\n\n\tif (info->var.grayscale)\n\t\tred = green = blue =\n\t\t\t(19595 * red + 38470 * green + 7471 * blue) >> 16;\n\n\tswitch (fbi->fb.fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\tif (regno < 16) {\n\t\t\tu32 *pal = fbi->fb.pseudo_palette;\n\n\t\t\tval  = chan_to_field(red, &fbi->fb.var.red);\n\t\t\tval |= chan_to_field(green, &fbi->fb.var.green);\n\t\t\tval |= chan_to_field(blue, &fbi->fb.var.blue);\n\n\t\t\tpal[regno] = val;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FB_VISUAL_STATIC_PSEUDOCOLOR:\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\twritew((red & 0xf800)\n\t\t      | ((green >> 5) & 0x7e0)\n\t\t      | ((blue >> 11) & 0x1f),\n\t\t       fbi->palette_cpu + sizeof(u16) * regno);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int vt8500lcd_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tint ret = 0;\n\tstruct vt8500lcd_info *fbi = to_vt8500lcd_info(info);\n\n\tif (cmd == FBIO_WAITFORVSYNC) {\n\t\t \n\t\twritel(0xffffffff ^ (1 << 3), fbi->regbase + 0x3c);\n\t\tret = wait_event_interruptible_timeout(fbi->wait,\n\t\t\treadl(fbi->regbase + 0x38) & (1 << 3), HZ / 10);\n\t\t \n\t\twritel(0xffffffff, fbi->regbase + 0x3c);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn ret;\n}\n\nstatic int vt8500lcd_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info)\n{\n\tunsigned pixlen = info->fix.line_length / info->var.xres_virtual;\n\tunsigned off = pixlen * var->xoffset\n\t\t      + info->fix.line_length * var->yoffset;\n\tstruct vt8500lcd_info *fbi = to_vt8500lcd_info(info);\n\n\twritel((1 << 31)\n\t     | (((info->var.xres_virtual - info->var.xres) * pixlen / 4) << 20)\n\t     | (off >> 2), fbi->regbase + 0x20);\n\treturn 0;\n}\n\n \nstatic int vt8500lcd_blank(int blank, struct fb_info *info)\n{\n\tint i;\n\n\tswitch (blank) {\n\tcase FB_BLANK_POWERDOWN:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_NORMAL:\n\t\tif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR ||\n\t\t    info->fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR)\n\t\t\tfor (i = 0; i < 256; i++)\n\t\t\t\tvt8500lcd_setcolreg(i, 0, 0, 0, 0, info);\n\t\tfallthrough;\n\tcase FB_BLANK_UNBLANK:\n\t\tif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR ||\n\t\t    info->fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR)\n\t\t\tfb_set_cmap(&info->cmap, info);\n\t}\n\treturn 0;\n}\n\nstatic const struct fb_ops vt8500lcd_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_set_par\t= vt8500lcd_set_par,\n\t.fb_setcolreg\t= vt8500lcd_setcolreg,\n\t.fb_fillrect\t= wmt_ge_fillrect,\n\t.fb_copyarea\t= wmt_ge_copyarea,\n\t.fb_imageblit\t= sys_imageblit,\n\t.fb_sync\t= wmt_ge_sync,\n\t.fb_ioctl\t= vt8500lcd_ioctl,\n\t.fb_pan_display\t= vt8500lcd_pan_display,\n\t.fb_blank\t= vt8500lcd_blank,\n};\n\nstatic irqreturn_t vt8500lcd_handle_irq(int irq, void *dev_id)\n{\n\tstruct vt8500lcd_info *fbi = dev_id;\n\n\tif (readl(fbi->regbase + 0x38) & (1 << 3))\n\t\twake_up_interruptible(&fbi->wait);\n\n\twritel(0xffffffff, fbi->regbase + 0x38);\n\treturn IRQ_HANDLED;\n}\n\nstatic int vt8500lcd_probe(struct platform_device *pdev)\n{\n\tstruct vt8500lcd_info *fbi;\n\tstruct resource *res;\n\tstruct display_timings *disp_timing;\n\tvoid *addr;\n\tint irq, ret;\n\n\tstruct fb_videomode\tof_mode;\n\tu32\t\t\tbpp;\n\tdma_addr_t fb_mem_phys;\n\tunsigned long fb_mem_len;\n\tvoid *fb_mem_virt;\n\n\tret = -ENOMEM;\n\tfbi = NULL;\n\n\tfbi = devm_kzalloc(&pdev->dev, sizeof(struct vt8500lcd_info)\n\t\t\t+ sizeof(u32) * 16, GFP_KERNEL);\n\tif (!fbi)\n\t\treturn -ENOMEM;\n\n\tstrcpy(fbi->fb.fix.id, \"VT8500 LCD\");\n\n\tfbi->fb.fix.type\t= FB_TYPE_PACKED_PIXELS;\n\tfbi->fb.fix.xpanstep\t= 0;\n\tfbi->fb.fix.ypanstep\t= 1;\n\tfbi->fb.fix.ywrapstep\t= 0;\n\tfbi->fb.fix.accel\t= FB_ACCEL_NONE;\n\n\tfbi->fb.var.nonstd\t= 0;\n\tfbi->fb.var.activate\t= FB_ACTIVATE_NOW;\n\tfbi->fb.var.height\t= -1;\n\tfbi->fb.var.width\t= -1;\n\tfbi->fb.var.vmode\t= FB_VMODE_NONINTERLACED;\n\n\tfbi->fb.fbops\t\t= &vt8500lcd_ops;\n\tfbi->fb.flags\t\t= FBINFO_HWACCEL_COPYAREA\n\t\t\t\t| FBINFO_HWACCEL_FILLRECT\n\t\t\t\t| FBINFO_HWACCEL_YPAN\n\t\t\t\t| FBINFO_VIRTFB\n\t\t\t\t| FBINFO_PARTIAL_PAN_OK;\n\tfbi->fb.node\t\t= -1;\n\n\taddr = fbi;\n\taddr = addr + sizeof(struct vt8500lcd_info);\n\tfbi->fb.pseudo_palette\t= addr;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"no I/O memory resource defined\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tres = request_mem_region(res->start, resource_size(res), \"vt8500lcd\");\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to request I/O memory\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tfbi->regbase = ioremap(res->start, resource_size(res));\n\tif (fbi->regbase == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to map I/O memory\\n\");\n\t\tret = -EBUSY;\n\t\tgoto failed_free_res;\n\t}\n\n\tdisp_timing = of_get_display_timings(pdev->dev.of_node);\n\tif (!disp_timing) {\n\t\tret = -EINVAL;\n\t\tgoto failed_free_io;\n\t}\n\n\tret = of_get_fb_videomode(pdev->dev.of_node, &of_mode,\n\t\t\t\t\t\t\tOF_USE_NATIVE_MODE);\n\tif (ret)\n\t\tgoto failed_free_io;\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"bits-per-pixel\", &bpp);\n\tif (ret)\n\t\tgoto failed_free_io;\n\n\t \n\tfb_mem_len = of_mode.xres * of_mode.yres * 2 * (bpp / 8);\n\tfb_mem_virt = dma_alloc_coherent(&pdev->dev, fb_mem_len, &fb_mem_phys,\n\t\t\t\tGFP_KERNEL);\n\tif (!fb_mem_virt) {\n\t\tpr_err(\"%s: Failed to allocate framebuffer\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto failed_free_io;\n\t}\n\n\tfbi->fb.fix.smem_start\t= fb_mem_phys;\n\tfbi->fb.fix.smem_len\t= fb_mem_len;\n\tfbi->fb.screen_base\t= fb_mem_virt;\n\n\tfbi->palette_size\t= PAGE_ALIGN(512);\n\tfbi->palette_cpu\t= dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t     fbi->palette_size,\n\t\t\t\t\t\t     &fbi->palette_phys,\n\t\t\t\t\t\t     GFP_KERNEL);\n\tif (fbi->palette_cpu == NULL) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate palette buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_free_io;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tdev_err(&pdev->dev, \"no IRQ defined\\n\");\n\t\tret = -ENODEV;\n\t\tgoto failed_free_palette;\n\t}\n\n\tret = request_irq(irq, vt8500lcd_handle_irq, 0, \"LCD\", fbi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request_irq failed: %d\\n\", ret);\n\t\tret = -EBUSY;\n\t\tgoto failed_free_palette;\n\t}\n\n\tinit_waitqueue_head(&fbi->wait);\n\n\tif (fb_alloc_cmap(&fbi->fb.cmap, 256, 0) < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate color map\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_free_irq;\n\t}\n\n\tfb_videomode_to_var(&fbi->fb.var, &of_mode);\n\n\tfbi->fb.var.xres_virtual\t= of_mode.xres;\n\tfbi->fb.var.yres_virtual\t= of_mode.yres * 2;\n\tfbi->fb.var.bits_per_pixel\t= bpp;\n\n\tret = vt8500lcd_set_par(&fbi->fb);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to set parameters\\n\");\n\t\tgoto failed_free_cmap;\n\t}\n\n\twritel(fbi->fb.fix.smem_start >> 22, fbi->regbase + 0x1c);\n\twritel((fbi->palette_phys & 0xfffffe00) | 1, fbi->regbase + 0x18);\n\n\tplatform_set_drvdata(pdev, fbi);\n\n\tret = register_framebuffer(&fbi->fb);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register framebuffer device: %d\\n\", ret);\n\t\tgoto failed_free_cmap;\n\t}\n\n\t \n\twritel(readl(fbi->regbase) | 1, fbi->regbase);\n\n\treturn 0;\n\nfailed_free_cmap:\n\tif (fbi->fb.cmap.len)\n\t\tfb_dealloc_cmap(&fbi->fb.cmap);\nfailed_free_irq:\n\tfree_irq(irq, fbi);\nfailed_free_palette:\n\tdma_free_coherent(&pdev->dev, fbi->palette_size,\n\t\t\t  fbi->palette_cpu, fbi->palette_phys);\nfailed_free_io:\n\tiounmap(fbi->regbase);\nfailed_free_res:\n\trelease_mem_region(res->start, resource_size(res));\n\treturn ret;\n}\n\nstatic void vt8500lcd_remove(struct platform_device *pdev)\n{\n\tstruct vt8500lcd_info *fbi = platform_get_drvdata(pdev);\n\tstruct resource *res;\n\tint irq;\n\n\tunregister_framebuffer(&fbi->fb);\n\n\twritel(0, fbi->regbase);\n\n\tif (fbi->fb.cmap.len)\n\t\tfb_dealloc_cmap(&fbi->fb.cmap);\n\n\tirq = platform_get_irq(pdev, 0);\n\tfree_irq(irq, fbi);\n\n\tdma_free_coherent(&pdev->dev, fbi->palette_size,\n\t\t\t  fbi->palette_cpu, fbi->palette_phys);\n\n\tiounmap(fbi->regbase);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\trelease_mem_region(res->start, resource_size(res));\n}\n\nstatic const struct of_device_id via_dt_ids[] = {\n\t{ .compatible = \"via,vt8500-fb\", },\n\t{}\n};\n\nstatic struct platform_driver vt8500lcd_driver = {\n\t.probe\t\t= vt8500lcd_probe,\n\t.remove_new\t= vt8500lcd_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"vt8500-lcd\",\n\t\t.of_match_table = of_match_ptr(via_dt_ids),\n\t},\n};\n\nmodule_platform_driver(vt8500lcd_driver);\n\nMODULE_AUTHOR(\"Alexey Charkov <alchark@gmail.com>\");\nMODULE_DESCRIPTION(\"LCD controller driver for VIA VT8500\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(of, via_dt_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}