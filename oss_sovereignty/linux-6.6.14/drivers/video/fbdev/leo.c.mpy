{
  "module_name": "leo.c",
  "hash_id": "6a412ba133918b14a3db8017a5f861985728073eb877e4d7adab70c187081f31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/leo.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/fb.h>\n#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <asm/fbio.h>\n\n#include \"sbuslib.h\"\n\n \n\nstatic int leo_setcolreg(unsigned, unsigned, unsigned, unsigned,\n\t\t\t unsigned, struct fb_info *);\nstatic int leo_blank(int, struct fb_info *);\n\nstatic int leo_mmap(struct fb_info *, struct vm_area_struct *);\nstatic int leo_ioctl(struct fb_info *, unsigned int, unsigned long);\nstatic int leo_pan_display(struct fb_var_screeninfo *, struct fb_info *);\n\n \n\nstatic const struct fb_ops leo_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_setcolreg\t\t= leo_setcolreg,\n\t.fb_blank\t\t= leo_blank,\n\t.fb_pan_display\t\t= leo_pan_display,\n\t.fb_fillrect\t\t= cfb_fillrect,\n\t.fb_copyarea\t\t= cfb_copyarea,\n\t.fb_imageblit\t\t= cfb_imageblit,\n\t.fb_mmap\t\t= leo_mmap,\n\t.fb_ioctl\t\t= leo_ioctl,\n#ifdef CONFIG_COMPAT\n\t.fb_compat_ioctl\t= sbusfb_compat_ioctl,\n#endif\n};\n\n#define LEO_OFF_LC_SS0_KRN\t0x00200000UL\n#define LEO_OFF_LC_SS0_USR\t0x00201000UL\n#define LEO_OFF_LC_SS1_KRN\t0x01200000UL\n#define LEO_OFF_LC_SS1_USR\t0x01201000UL\n#define LEO_OFF_LD_SS0\t\t0x00400000UL\n#define LEO_OFF_LD_SS1\t\t0x01400000UL\n#define LEO_OFF_LD_GBL\t\t0x00401000UL\n#define LEO_OFF_LX_KRN\t\t0x00600000UL\n#define LEO_OFF_LX_CURSOR\t0x00601000UL\n#define LEO_OFF_SS0\t\t0x00800000UL\n#define LEO_OFF_SS1\t\t0x01800000UL\n#define LEO_OFF_UNK\t\t0x00602000UL\n#define LEO_OFF_UNK2\t\t0x00000000UL\n\n#define LEO_CUR_ENABLE\t\t0x00000080\n#define LEO_CUR_UPDATE\t\t0x00000030\n#define LEO_CUR_PROGRESS\t0x00000006\n#define LEO_CUR_UPDATECMAP\t0x00000003\n\n#define LEO_CUR_TYPE_MASK\t0x00000000\n#define LEO_CUR_TYPE_IMAGE\t0x00000020\n#define LEO_CUR_TYPE_CMAP\t0x00000050\n\nstruct leo_cursor {\n\tu8\txxx0[16];\n\tu32\tcur_type;\n\tu32\tcur_misc;\n\tu32\tcur_cursxy;\n\tu32\tcur_data;\n};\n\n#define LEO_KRN_TYPE_CLUT0\t0x00001000\n#define LEO_KRN_TYPE_CLUT1\t0x00001001\n#define LEO_KRN_TYPE_CLUT2\t0x00001002\n#define LEO_KRN_TYPE_WID\t0x00001003\n#define LEO_KRN_TYPE_UNK\t0x00001006\n#define LEO_KRN_TYPE_VIDEO\t0x00002003\n#define LEO_KRN_TYPE_CLUTDATA\t0x00004000\n#define LEO_KRN_CSR_ENABLE\t0x00000008\n#define LEO_KRN_CSR_PROGRESS\t0x00000004\n#define LEO_KRN_CSR_UNK\t\t0x00000002\n#define LEO_KRN_CSR_UNK2\t0x00000001\n\nstruct leo_lx_krn {\n\tu32\tkrn_type;\n\tu32\tkrn_csr;\n\tu32\tkrn_value;\n};\n\nstruct leo_lc_ss0_krn {\n\tu32 \tmisc;\n\tu8\txxx0[0x800-4];\n\tu32\trev;\n};\n\nstruct leo_lc_ss0_usr {\n\tu32\tcsr;\n\tu32\taddrspace;\n\tu32 \tfontmsk;\n\tu32\tfontt;\n\tu32\textent;\n\tu32\tsrc;\n\tu32\tdst;\n\tu32\tcopy;\n\tu32\tfill;\n};\n\nstruct leo_lc_ss1_krn {\n\tu8\tunknown;\n};\n\nstruct leo_lc_ss1_usr {\n\tu8\tunknown;\n};\n\nstruct leo_ld_ss0 {\n\tu8\txxx0[0xe00];\n\tu32\tcsr;\n\tu32\twid;\n\tu32\twmask;\n\tu32\twidclip;\n\tu32\tvclipmin;\n\tu32\tvclipmax;\n\tu32\tpickmin;\t \n\tu32\tpickmax;\t \n\tu32\tfg;\n\tu32\tbg;\n\tu32\tsrc;\t\t \n\tu32\tdst;\t\t \n\tu32\textent;\t\t \n\tu32\txxx1[3];\n\tu32\tsetsem;\t\t \n\tu32\tclrsem;\t\t \n\tu32\tclrpick;\t \n\tu32\tclrdat;\t\t \n\tu32\talpha;\t\t \n\tu8\txxx2[0x2c];\n\tu32\twinbg;\n\tu32\tplanemask;\n\tu32\trop;\n\tu32\tz;\n\tu32\tdczf;\t\t \n\tu32\tdczb;\t\t \n\tu32\tdcs;\t\t \n\tu32\tdczs;\t\t \n\tu32\tpickfb;\t\t \n\tu32\tpickbb;\t\t \n\tu32\tdcfc;\t\t \n\tu32\tforcecol;\t \n\tu32\tdoor[8];\t \n\tu32\tpick[5];\t \n};\n\n#define LEO_SS1_MISC_ENABLE\t0x00000001\n#define LEO_SS1_MISC_STEREO\t0x00000002\nstruct leo_ld_ss1 {\n\tu8\txxx0[0xef4];\n\tu32\tss1_misc;\n};\n\nstruct leo_ld_gbl {\n\tu8\tunknown;\n};\n\nstruct leo_par {\n\tspinlock_t\t\tlock;\n\tstruct leo_lx_krn\t__iomem *lx_krn;\n\tstruct leo_lc_ss0_usr\t__iomem *lc_ss0_usr;\n\tstruct leo_ld_ss0\t__iomem *ld_ss0;\n\tstruct leo_ld_ss1\t__iomem *ld_ss1;\n\tstruct leo_cursor\t__iomem *cursor;\n\tu32\t\t\textent;\n\tu32\t\t\tclut_data[256];\n\n\tu32\t\t\tflags;\n#define LEO_FLAG_BLANKED\t0x00000001\n\n\tunsigned long\t\twhich_io;\n};\n\nstatic void leo_wait(struct leo_lx_krn __iomem *lx_krn)\n{\n\tint i;\n\n\tfor (i = 0;\n\t     (sbus_readl(&lx_krn->krn_csr) & LEO_KRN_CSR_PROGRESS) &&\n\t     i < 300000;\n\t     i++)\n\t\tudelay(1);  \n\treturn;\n}\n\nstatic void leo_switch_from_graph(struct fb_info *info)\n{\n\tstruct leo_par *par = (struct leo_par *) info->par;\n\tstruct leo_ld_ss0 __iomem *ss = par->ld_ss0;\n\tstruct leo_cursor __iomem *cursor = par->cursor;\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tpar->extent = ((info->var.xres - 1) |\n\t\t       ((info->var.yres - 1) << 16));\n\n\tsbus_writel(0xffffffff, &ss->wid);\n\tsbus_writel(0xffff, &ss->wmask);\n\tsbus_writel(0, &ss->vclipmin);\n\tsbus_writel(par->extent, &ss->vclipmax);\n\tsbus_writel(0, &ss->fg);\n\tsbus_writel(0xff000000, &ss->planemask);\n\tsbus_writel(0x310850, &ss->rop);\n\tsbus_writel(0, &ss->widclip);\n\tsbus_writel((info->var.xres-1) | ((info->var.yres-1) << 11),\n\t\t    &par->lc_ss0_usr->extent);\n\tsbus_writel(4, &par->lc_ss0_usr->addrspace);\n\tsbus_writel(0x80000000, &par->lc_ss0_usr->fill);\n\tsbus_writel(0, &par->lc_ss0_usr->fontt);\n\tdo {\n\t\tval = sbus_readl(&par->lc_ss0_usr->csr);\n\t} while (val & 0x20000000);\n\n\t \n\tsbus_writel(1, &ss->wid);\n\tsbus_writel(0x00ffffff, &ss->planemask);\n\tsbus_writel(0x310b90, &ss->rop);\n\tsbus_writel(0, &par->lc_ss0_usr->addrspace);\n\n\t \n\tsbus_writel(sbus_readl(&cursor->cur_misc) & ~LEO_CUR_ENABLE, &cursor->cur_misc);\n\n\tspin_unlock_irqrestore(&par->lock, flags);\n}\n\nstatic int leo_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\t \n\tleo_switch_from_graph(info);\n\n\tif (var->xoffset || var->yoffset || var->vmode)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int leo_setcolreg(unsigned regno,\n\t\t\t unsigned red, unsigned green, unsigned blue,\n\t\t\t unsigned transp, struct fb_info *info)\n{\n\tstruct leo_par *par = (struct leo_par *) info->par;\n\tstruct leo_lx_krn __iomem *lx_krn = par->lx_krn;\n\tunsigned long flags;\n\tu32 val;\n\tint i;\n\n\tif (regno >= 256)\n\t\treturn 1;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\tpar->clut_data[regno] = red | (green << 8) | (blue << 16);\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tleo_wait(lx_krn);\n\n\tsbus_writel(LEO_KRN_TYPE_CLUTDATA, &lx_krn->krn_type);\n\tfor (i = 0; i < 256; i++)\n\t\tsbus_writel(par->clut_data[i], &lx_krn->krn_value);\n\tsbus_writel(LEO_KRN_TYPE_CLUT0, &lx_krn->krn_type);\n\n\tval = sbus_readl(&lx_krn->krn_csr);\n\tval |= (LEO_KRN_CSR_UNK | LEO_KRN_CSR_UNK2);\n\tsbus_writel(val, &lx_krn->krn_csr);\n\n\tspin_unlock_irqrestore(&par->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int leo_blank(int blank, struct fb_info *info)\n{\n\tstruct leo_par *par = (struct leo_par *) info->par;\n\tstruct leo_lx_krn __iomem *lx_krn = par->lx_krn;\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:  \n\t\tval = sbus_readl(&lx_krn->krn_csr);\n\t\tval |= LEO_KRN_CSR_ENABLE;\n\t\tsbus_writel(val, &lx_krn->krn_csr);\n\t\tpar->flags &= ~LEO_FLAG_BLANKED;\n\t\tbreak;\n\n\tcase FB_BLANK_NORMAL:  \n\tcase FB_BLANK_VSYNC_SUSPEND:  \n\tcase FB_BLANK_HSYNC_SUSPEND:  \n\tcase FB_BLANK_POWERDOWN:  \n\t\tval = sbus_readl(&lx_krn->krn_csr);\n\t\tval &= ~LEO_KRN_CSR_ENABLE;\n\t\tsbus_writel(val, &lx_krn->krn_csr);\n\t\tpar->flags |= LEO_FLAG_BLANKED;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&par->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct sbus_mmap_map leo_mmap_map[] = {\n\t{\n\t\t.voff\t= LEO_SS0_MAP,\n\t\t.poff\t= LEO_OFF_SS0,\n\t\t.size\t= 0x800000\n\t},\n\t{\n\t\t.voff\t= LEO_LC_SS0_USR_MAP,\n\t\t.poff\t= LEO_OFF_LC_SS0_USR,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= LEO_LD_SS0_MAP,\n\t\t.poff\t= LEO_OFF_LD_SS0,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= LEO_LX_CURSOR_MAP,\n\t\t.poff\t= LEO_OFF_LX_CURSOR,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= LEO_SS1_MAP,\n\t\t.poff\t= LEO_OFF_SS1,\n\t\t.size\t= 0x800000\n\t},\n\t{\n\t\t.voff\t= LEO_LC_SS1_USR_MAP,\n\t\t.poff\t= LEO_OFF_LC_SS1_USR,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= LEO_LD_SS1_MAP,\n\t\t.poff\t= LEO_OFF_LD_SS1,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= LEO_UNK_MAP,\n\t\t.poff\t= LEO_OFF_UNK,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= LEO_LX_KRN_MAP,\n\t\t.poff\t= LEO_OFF_LX_KRN,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= LEO_LC_SS0_KRN_MAP,\n\t\t.poff\t= LEO_OFF_LC_SS0_KRN,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= LEO_LC_SS1_KRN_MAP,\n\t\t.poff\t= LEO_OFF_LC_SS1_KRN,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= LEO_LD_GBL_MAP,\n\t\t.poff\t= LEO_OFF_LD_GBL,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= LEO_UNK2_MAP,\n\t\t.poff\t= LEO_OFF_UNK2,\n\t\t.size\t= 0x100000\n\t},\n\t{ .size = 0 }\n};\n\nstatic int leo_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct leo_par *par = (struct leo_par *)info->par;\n\n\treturn sbusfb_mmap_helper(leo_mmap_map,\n\t\t\t\t  info->fix.smem_start, info->fix.smem_len,\n\t\t\t\t  par->which_io, vma);\n}\n\nstatic int leo_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\n{\n\treturn sbusfb_ioctl_helper(cmd, arg, info,\n\t\t\t\t   FBTYPE_SUNLEO, 32, info->fix.smem_len);\n}\n\n \n\nstatic void\nleo_init_fix(struct fb_info *info, struct device_node *dp)\n{\n\tsnprintf(info->fix.id, sizeof(info->fix.id), \"%pOFn\", dp);\n\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\n\tinfo->fix.line_length = 8192;\n\n\tinfo->fix.accel = FB_ACCEL_SUN_LEO;\n}\n\nstatic void leo_wid_put(struct fb_info *info, struct fb_wid_list *wl)\n{\n\tstruct leo_par *par = (struct leo_par *) info->par;\n\tstruct leo_lx_krn __iomem *lx_krn = par->lx_krn;\n\tstruct fb_wid_item *wi;\n\tunsigned long flags;\n\tu32 val;\n\tint i, j;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tleo_wait(lx_krn);\n\n\tfor (i = 0, wi = wl->wl_list; i < wl->wl_count; i++, wi++) {\n\t\tswitch (wi->wi_type) {\n\t\tcase FB_WID_DBL_8:\n\t\t\tj = (wi->wi_index & 0xf) + 0x40;\n\t\t\tbreak;\n\n\t\tcase FB_WID_DBL_24:\n\t\t\tj = wi->wi_index & 0x3f;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tsbus_writel(0x5800 + j, &lx_krn->krn_type);\n\t\tsbus_writel(wi->wi_values[0], &lx_krn->krn_value);\n\t}\n\tsbus_writel(LEO_KRN_TYPE_WID, &lx_krn->krn_type);\n\n\tval = sbus_readl(&lx_krn->krn_csr);\n\tval |= (LEO_KRN_CSR_UNK | LEO_KRN_CSR_UNK2);\n\tsbus_writel(val, &lx_krn->krn_csr);\n\n\tspin_unlock_irqrestore(&par->lock, flags);\n}\n\nstatic void leo_init_wids(struct fb_info *info)\n{\n\tstruct fb_wid_item wi;\n\tstruct fb_wid_list wl;\n\n\twl.wl_count = 1;\n\twl.wl_list = &wi;\n\twi.wi_type = FB_WID_DBL_8;\n\twi.wi_index = 0;\n\twi.wi_values [0] = 0x2c0;\n\tleo_wid_put(info, &wl);\n\twi.wi_index = 1;\n\twi.wi_values [0] = 0x30;\n\tleo_wid_put(info, &wl);\n\twi.wi_index = 2;\n\twi.wi_values [0] = 0x20;\n\tleo_wid_put(info, &wl);\n\twi.wi_type = FB_WID_DBL_24;\n\twi.wi_index = 1;\n\twi.wi_values [0] = 0x30;\n\tleo_wid_put(info, &wl);\n}\n\nstatic void leo_init_hw(struct fb_info *info)\n{\n\tstruct leo_par *par = (struct leo_par *) info->par;\n\tu32 val;\n\n\tval = sbus_readl(&par->ld_ss1->ss1_misc);\n\tval |= LEO_SS1_MISC_ENABLE;\n\tsbus_writel(val, &par->ld_ss1->ss1_misc);\n\n\tleo_switch_from_graph(info);\n}\n\nstatic void leo_fixup_var_rgb(struct fb_var_screeninfo *var)\n{\n\tvar->red.offset = 0;\n\tvar->red.length = 8;\n\tvar->green.offset = 8;\n\tvar->green.length = 8;\n\tvar->blue.offset = 16;\n\tvar->blue.length = 8;\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n}\n\nstatic void leo_unmap_regs(struct platform_device *op, struct fb_info *info,\n\t\t\t   struct leo_par *par)\n{\n\tif (par->lc_ss0_usr)\n\t\tof_iounmap(&op->resource[0], par->lc_ss0_usr, 0x1000);\n\tif (par->ld_ss0)\n\t\tof_iounmap(&op->resource[0], par->ld_ss0, 0x1000);\n\tif (par->ld_ss1)\n\t\tof_iounmap(&op->resource[0], par->ld_ss1, 0x1000);\n\tif (par->lx_krn)\n\t\tof_iounmap(&op->resource[0], par->lx_krn, 0x1000);\n\tif (par->cursor)\n\t\tof_iounmap(&op->resource[0],\n\t\t\t   par->cursor, sizeof(struct leo_cursor));\n\tif (info->screen_base)\n\t\tof_iounmap(&op->resource[0], info->screen_base, 0x800000);\n}\n\nstatic int leo_probe(struct platform_device *op)\n{\n\tstruct device_node *dp = op->dev.of_node;\n\tstruct fb_info *info;\n\tstruct leo_par *par;\n\tint linebytes, err;\n\n\tinfo = framebuffer_alloc(sizeof(struct leo_par), &op->dev);\n\n\terr = -ENOMEM;\n\tif (!info)\n\t\tgoto out_err;\n\tpar = info->par;\n\n\tspin_lock_init(&par->lock);\n\n\tinfo->fix.smem_start = op->resource[0].start;\n\tpar->which_io = op->resource[0].flags & IORESOURCE_BITS;\n\n\tsbusfb_fill_var(&info->var, dp, 32);\n\tleo_fixup_var_rgb(&info->var);\n\n\tlinebytes = of_getintprop_default(dp, \"linebytes\",\n\t\t\t\t\t  info->var.xres);\n\tinfo->fix.smem_len = PAGE_ALIGN(linebytes * info->var.yres);\n\n\tpar->lc_ss0_usr =\n\t\tof_ioremap(&op->resource[0], LEO_OFF_LC_SS0_USR,\n\t\t\t   0x1000, \"leolc ss0usr\");\n\tpar->ld_ss0 =\n\t\tof_ioremap(&op->resource[0], LEO_OFF_LD_SS0,\n\t\t\t   0x1000, \"leold ss0\");\n\tpar->ld_ss1 =\n\t\tof_ioremap(&op->resource[0], LEO_OFF_LD_SS1,\n\t\t\t   0x1000, \"leold ss1\");\n\tpar->lx_krn =\n\t\tof_ioremap(&op->resource[0], LEO_OFF_LX_KRN,\n\t\t\t   0x1000, \"leolx krn\");\n\tpar->cursor =\n\t\tof_ioremap(&op->resource[0], LEO_OFF_LX_CURSOR,\n\t\t\t   sizeof(struct leo_cursor), \"leolx cursor\");\n\tinfo->screen_base =\n\t\tof_ioremap(&op->resource[0], LEO_OFF_SS0,\n\t\t\t   0x800000, \"leo ram\");\n\tif (!par->lc_ss0_usr ||\n\t    !par->ld_ss0 ||\n\t    !par->ld_ss1 ||\n\t    !par->lx_krn ||\n\t    !par->cursor ||\n\t    !info->screen_base)\n\t\tgoto out_unmap_regs;\n\n\tinfo->fbops = &leo_ops;\n\tinfo->pseudo_palette = par->clut_data;\n\n\tleo_init_wids(info);\n\tleo_init_hw(info);\n\n\tleo_blank(FB_BLANK_UNBLANK, info);\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0))\n\t\tgoto out_unmap_regs;\n\n\tleo_init_fix(info, dp);\n\n\terr = register_framebuffer(info);\n\tif (err < 0)\n\t\tgoto out_dealloc_cmap;\n\n\tdev_set_drvdata(&op->dev, info);\n\n\tprintk(KERN_INFO \"%pOF: leo at %lx:%lx\\n\",\n\t       dp,\n\t       par->which_io, info->fix.smem_start);\n\n\treturn 0;\n\nout_dealloc_cmap:\n\tfb_dealloc_cmap(&info->cmap);\n\nout_unmap_regs:\n\tleo_unmap_regs(op, info, par);\n\tframebuffer_release(info);\n\nout_err:\n\treturn err;\n}\n\nstatic void leo_remove(struct platform_device *op)\n{\n\tstruct fb_info *info = dev_get_drvdata(&op->dev);\n\tstruct leo_par *par = info->par;\n\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\n\tleo_unmap_regs(op, info, par);\n\n\tframebuffer_release(info);\n}\n\nstatic const struct of_device_id leo_match[] = {\n\t{\n\t\t.name = \"SUNW,leo\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, leo_match);\n\nstatic struct platform_driver leo_driver = {\n\t.driver = {\n\t\t.name = \"leo\",\n\t\t.of_match_table = leo_match,\n\t},\n\t.probe\t\t= leo_probe,\n\t.remove_new\t= leo_remove,\n};\n\nstatic int __init leo_init(void)\n{\n\tif (fb_get_options(\"leofb\", NULL))\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&leo_driver);\n}\n\nstatic void __exit leo_exit(void)\n{\n\tplatform_driver_unregister(&leo_driver);\n}\n\nmodule_init(leo_init);\nmodule_exit(leo_exit);\n\nMODULE_DESCRIPTION(\"framebuffer driver for LEO chipsets\");\nMODULE_AUTHOR(\"David S. Miller <davem@davemloft.net>\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}