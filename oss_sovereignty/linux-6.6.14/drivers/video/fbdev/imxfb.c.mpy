{
  "module_name": "imxfb.c",
  "hash_id": "f60e00c1064aff63cdb2be2016fef2fe7310e265f4b09ad9a70c5f1dda0495bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/imxfb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/cpufreq.h>\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/lcd.h>\n#include <linux/math64.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n\n#include <linux/regulator/consumer.h>\n\n#include <video/of_display_timing.h>\n#include <video/of_videomode.h>\n#include <video/videomode.h>\n\n#define PCR_TFT\t\t(1 << 31)\n#define PCR_COLOR\t(1 << 30)\n#define PCR_BPIX_8\t(3 << 25)\n#define PCR_BPIX_12\t(4 << 25)\n#define PCR_BPIX_16\t(5 << 25)\n#define PCR_BPIX_18\t(6 << 25)\n\nstruct imx_fb_videomode {\n\tstruct fb_videomode mode;\n\tu32 pcr;\n\tbool aus_mode;\n\tunsigned char\tbpp;\n};\n\n \n#define DEBUG_VAR 1\n\n#define DRIVER_NAME \"imx-fb\"\n\n#define LCDC_SSA\t0x00\n\n#define LCDC_SIZE\t0x04\n#define SIZE_XMAX(x)\t((((x) >> 4) & 0x3f) << 20)\n\n#define YMAX_MASK_IMX1\t0x1ff\n#define YMAX_MASK_IMX21\t0x3ff\n\n#define LCDC_VPW\t0x08\n#define VPW_VPW(x)\t((x) & 0x3ff)\n\n#define LCDC_CPOS\t0x0C\n#define CPOS_CC1\t(1<<31)\n#define CPOS_CC0\t(1<<30)\n#define CPOS_OP\t\t(1<<28)\n#define CPOS_CXP(x)\t(((x) & 3ff) << 16)\n\n#define LCDC_LCWHB\t0x10\n#define LCWHB_BK_EN\t(1<<31)\n#define LCWHB_CW(w)\t(((w) & 0x1f) << 24)\n#define LCWHB_CH(h)\t(((h) & 0x1f) << 16)\n#define LCWHB_BD(x)\t((x) & 0xff)\n\n#define LCDC_LCHCC\t0x14\n\n#define LCDC_PCR\t0x18\n\n#define LCDC_HCR\t0x1C\n#define HCR_H_WIDTH(x)\t(((x) & 0x3f) << 26)\n#define HCR_H_WAIT_1(x)\t(((x) & 0xff) << 8)\n#define HCR_H_WAIT_2(x)\t((x) & 0xff)\n\n#define LCDC_VCR\t0x20\n#define VCR_V_WIDTH(x)\t(((x) & 0x3f) << 26)\n#define VCR_V_WAIT_1(x)\t(((x) & 0xff) << 8)\n#define VCR_V_WAIT_2(x)\t((x) & 0xff)\n\n#define LCDC_POS\t0x24\n#define POS_POS(x)\t((x) & 1f)\n\n#define LCDC_LSCR1\t0x28\n \n\n#define LCDC_PWMR\t0x2C\n \n\n#define LCDC_DMACR\t0x30\n \n\n#define LCDC_RMCR\t0x34\n\n#define RMCR_LCDC_EN_MX1\t(1<<1)\n\n#define RMCR_SELF_REF\t(1<<0)\n\n#define LCDC_LCDICR\t0x38\n#define LCDICR_INT_SYN\t(1<<2)\n#define LCDICR_INT_CON\t(1)\n\n#define LCDC_LCDISR\t0x40\n#define LCDISR_UDR_ERR\t(1<<3)\n#define LCDISR_ERR_RES\t(1<<2)\n#define LCDISR_EOF\t(1<<1)\n#define LCDISR_BOF\t(1<<0)\n\n#define IMXFB_LSCR1_DEFAULT 0x00120300\n\n#define LCDC_LAUSCR\t0x80\n#define LAUSCR_AUS_MODE\t(1<<31)\n\n \nstatic const char *fb_mode;\n\n \nstruct imxfb_rgb {\n\tstruct fb_bitfield\tred;\n\tstruct fb_bitfield\tgreen;\n\tstruct fb_bitfield\tblue;\n\tstruct fb_bitfield\ttransp;\n};\n\nenum imxfb_type {\n\tIMX1_FB,\n\tIMX21_FB,\n};\n\nenum imxfb_panel_type {\n\tPANEL_TYPE_MONOCHROME,\n\tPANEL_TYPE_CSTN,\n\tPANEL_TYPE_TFT,\n};\n\nstruct imxfb_info {\n\tstruct platform_device  *pdev;\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*clk_ipg;\n\tstruct clk\t\t*clk_ahb;\n\tstruct clk\t\t*clk_per;\n\tenum imxfb_type\t\tdevtype;\n\tenum imxfb_panel_type\tpanel_type;\n\tbool\t\t\tenabled;\n\n\t \n\tdma_addr_t\t\tmap_dma;\n\tu_int\t\t\tmap_size;\n\n\tu_int\t\t\tpalette_size;\n\n\tdma_addr_t\t\tdbar1;\n\tdma_addr_t\t\tdbar2;\n\n\tu_int\t\t\tpcr;\n\tu_int\t\t\tlauscr;\n\tu_int\t\t\tpwmr;\n\tu_int\t\t\tlscr1;\n\tu_int\t\t\tdmacr;\n\tbool\t\t\tcmap_inverse;\n\tbool\t\t\tcmap_static;\n\n\tstruct imx_fb_videomode *mode;\n\tint\t\t\tnum_modes;\n\n\tstruct regulator\t*lcd_pwr;\n\tint\t\t\tlcd_pwr_enabled;\n};\n\nstatic const struct platform_device_id imxfb_devtype[] = {\n\t{\n\t\t.name = \"imx1-fb\",\n\t\t.driver_data = IMX1_FB,\n\t}, {\n\t\t.name = \"imx21-fb\",\n\t\t.driver_data = IMX21_FB,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(platform, imxfb_devtype);\n\nstatic const struct of_device_id imxfb_of_dev_id[] = {\n\t{\n\t\t.compatible = \"fsl,imx1-fb\",\n\t\t.data = &imxfb_devtype[IMX1_FB],\n\t}, {\n\t\t.compatible = \"fsl,imx21-fb\",\n\t\t.data = &imxfb_devtype[IMX21_FB],\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, imxfb_of_dev_id);\n\nstatic inline int is_imx1_fb(struct imxfb_info *fbi)\n{\n\treturn fbi->devtype == IMX1_FB;\n}\n\n#define IMX_NAME\t\"IMX\"\n\n \n#define MIN_XRES\t64\n#define MIN_YRES\t64\n\n \nstatic struct imxfb_rgb def_rgb_18 = {\n\t.red\t= {.offset = 16, .length = 8,},\n\t.green\t= {.offset = 8, .length = 8,},\n\t.blue\t= {.offset = 0, .length = 8,},\n\t.transp = {.offset = 0, .length = 0,},\n};\n\nstatic struct imxfb_rgb def_rgb_16_tft = {\n\t.red\t= {.offset = 11, .length = 5,},\n\t.green\t= {.offset = 5, .length = 6,},\n\t.blue\t= {.offset = 0, .length = 5,},\n\t.transp = {.offset = 0, .length = 0,},\n};\n\nstatic struct imxfb_rgb def_rgb_16_stn = {\n\t.red\t= {.offset = 8, .length = 4,},\n\t.green\t= {.offset = 4, .length = 4,},\n\t.blue\t= {.offset = 0, .length = 4,},\n\t.transp = {.offset = 0, .length = 0,},\n};\n\nstatic struct imxfb_rgb def_rgb_8 = {\n\t.red\t= {.offset = 0, .length = 8,},\n\t.green\t= {.offset = 0, .length = 8,},\n\t.blue\t= {.offset = 0, .length = 8,},\n\t.transp = {.offset = 0, .length = 0,},\n};\n\nstatic int imxfb_activate_var(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info);\n\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\nstatic int imxfb_setpalettereg(u_int regno, u_int red, u_int green, u_int blue,\n\t\tu_int trans, struct fb_info *info)\n{\n\tstruct imxfb_info *fbi = info->par;\n\tu_int val, ret = 1;\n\n#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)\n\tif (regno < fbi->palette_size) {\n\t\tval = (CNVT_TOHW(red, 4) << 8) |\n\t\t      (CNVT_TOHW(green,4) << 4) |\n\t\t      CNVT_TOHW(blue,  4);\n\n\t\twritel(val, fbi->regs + 0x800 + (regno << 2));\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic int imxfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t   u_int trans, struct fb_info *info)\n{\n\tstruct imxfb_info *fbi = info->par;\n\tunsigned int val;\n\tint ret = 1;\n\n\t \n\tif (fbi->cmap_inverse) {\n\t\tred   = 0xffff - red;\n\t\tgreen = 0xffff - green;\n\t\tblue  = 0xffff - blue;\n\t}\n\n\t \n\tif (info->var.grayscale)\n\t\tred = green = blue = (19595 * red + 38470 * green +\n\t\t\t\t\t7471 * blue) >> 16;\n\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\t \n\t\tif (regno < 16) {\n\t\t\tu32 *pal = info->pseudo_palette;\n\n\t\t\tval  = chan_to_field(red, &info->var.red);\n\t\t\tval |= chan_to_field(green, &info->var.green);\n\t\t\tval |= chan_to_field(blue, &info->var.blue);\n\n\t\t\tpal[regno] = val;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FB_VISUAL_STATIC_PSEUDOCOLOR:\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tret = imxfb_setpalettereg(regno, red, green, blue, trans, info);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct imx_fb_videomode *imxfb_find_mode(struct imxfb_info *fbi)\n{\n\tstruct imx_fb_videomode *m;\n\tint i;\n\n\tif (!fb_mode)\n\t\treturn &fbi->mode[0];\n\n\tfor (i = 0, m = &fbi->mode[0]; i < fbi->num_modes; i++, m++) {\n\t\tif (!strcmp(m->mode.name, fb_mode))\n\t\t\treturn m;\n\t}\n\treturn NULL;\n}\n\n \nstatic int imxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct imxfb_info *fbi = info->par;\n\tstruct imxfb_rgb *rgb;\n\tconst struct imx_fb_videomode *imxfb_mode;\n\tunsigned long lcd_clk;\n\tunsigned long long tmp;\n\tu32 pcr = 0;\n\n\tif (var->xres < MIN_XRES)\n\t\tvar->xres = MIN_XRES;\n\tif (var->yres < MIN_YRES)\n\t\tvar->yres = MIN_YRES;\n\n\timxfb_mode = imxfb_find_mode(fbi);\n\tif (!imxfb_mode)\n\t\treturn -EINVAL;\n\n\tvar->xres\t\t= imxfb_mode->mode.xres;\n\tvar->yres\t\t= imxfb_mode->mode.yres;\n\tvar->bits_per_pixel\t= imxfb_mode->bpp;\n\tvar->pixclock\t\t= imxfb_mode->mode.pixclock;\n\tvar->hsync_len\t\t= imxfb_mode->mode.hsync_len;\n\tvar->left_margin\t= imxfb_mode->mode.left_margin;\n\tvar->right_margin\t= imxfb_mode->mode.right_margin;\n\tvar->vsync_len\t\t= imxfb_mode->mode.vsync_len;\n\tvar->upper_margin\t= imxfb_mode->mode.upper_margin;\n\tvar->lower_margin\t= imxfb_mode->mode.lower_margin;\n\tvar->sync\t\t= imxfb_mode->mode.sync;\n\tvar->xres_virtual\t= max(var->xres_virtual, var->xres);\n\tvar->yres_virtual\t= max(var->yres_virtual, var->yres);\n\n\tpr_debug(\"var->bits_per_pixel=%d\\n\", var->bits_per_pixel);\n\n\tlcd_clk = clk_get_rate(fbi->clk_per);\n\n\ttmp = var->pixclock * (unsigned long long)lcd_clk;\n\n\tdo_div(tmp, 1000000);\n\n\tif (do_div(tmp, 1000000) > 500000)\n\t\ttmp++;\n\n\tpcr = (unsigned int)tmp;\n\n\tif (--pcr > 0x3F) {\n\t\tpcr = 0x3F;\n\t\tprintk(KERN_WARNING \"Must limit pixel clock to %luHz\\n\",\n\t\t\t\tlcd_clk / pcr);\n\t}\n\n\tswitch (var->bits_per_pixel) {\n\tcase 32:\n\t\tpcr |= PCR_BPIX_18;\n\t\trgb = &def_rgb_18;\n\t\tbreak;\n\tcase 16:\n\tdefault:\n\t\tif (is_imx1_fb(fbi))\n\t\t\tpcr |= PCR_BPIX_12;\n\t\telse\n\t\t\tpcr |= PCR_BPIX_16;\n\n\t\tif (imxfb_mode->pcr & PCR_TFT)\n\t\t\trgb = &def_rgb_16_tft;\n\t\telse\n\t\t\trgb = &def_rgb_16_stn;\n\t\tbreak;\n\tcase 8:\n\t\tpcr |= PCR_BPIX_8;\n\t\trgb = &def_rgb_8;\n\t\tbreak;\n\t}\n\n\t \n\tpcr |= imxfb_mode->pcr & ~(0x3f | (7 << 25));\n\n\tfbi->pcr = pcr;\n\t \n\tif (!is_imx1_fb(fbi) && imxfb_mode->aus_mode)\n\t\tfbi->lauscr = LAUSCR_AUS_MODE;\n\n\tif (imxfb_mode->pcr & PCR_TFT)\n\t\tfbi->panel_type = PANEL_TYPE_TFT;\n\telse if (imxfb_mode->pcr & PCR_COLOR)\n\t\tfbi->panel_type = PANEL_TYPE_CSTN;\n\telse\n\t\tfbi->panel_type = PANEL_TYPE_MONOCHROME;\n\n\t \n\tvar->red    = rgb->red;\n\tvar->green  = rgb->green;\n\tvar->blue   = rgb->blue;\n\tvar->transp = rgb->transp;\n\n\tpr_debug(\"RGBT length = %d:%d:%d:%d\\n\",\n\t\tvar->red.length, var->green.length, var->blue.length,\n\t\tvar->transp.length);\n\n\tpr_debug(\"RGBT offset = %d:%d:%d:%d\\n\",\n\t\tvar->red.offset, var->green.offset, var->blue.offset,\n\t\tvar->transp.offset);\n\n\treturn 0;\n}\n\n \nstatic int imxfb_set_par(struct fb_info *info)\n{\n\tstruct imxfb_info *fbi = info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\n\tif (var->bits_per_pixel == 16 || var->bits_per_pixel == 32)\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\telse if (!fbi->cmap_static)\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\telse {\n\t\t \n\t\tinfo->fix.visual = FB_VISUAL_STATIC_PSEUDOCOLOR;\n\t}\n\n\tinfo->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;\n\tfbi->palette_size = var->bits_per_pixel == 8 ? 256 : 16;\n\n\timxfb_activate_var(var, info);\n\n\treturn 0;\n}\n\nstatic int imxfb_enable_controller(struct imxfb_info *fbi)\n{\n\tint ret;\n\n\tif (fbi->enabled)\n\t\treturn 0;\n\n\tpr_debug(\"Enabling LCD controller\\n\");\n\n\twritel(fbi->map_dma, fbi->regs + LCDC_SSA);\n\n\t \n\twritel(0x00000000, fbi->regs + LCDC_POS);\n\n\t \n\twritel(readl(fbi->regs + LCDC_CPOS) & ~(CPOS_CC0 | CPOS_CC1),\n\t\tfbi->regs + LCDC_CPOS);\n\n\t \n\twritel(RMCR_LCDC_EN_MX1, fbi->regs + LCDC_RMCR);\n\n\tret = clk_prepare_enable(fbi->clk_ipg);\n\tif (ret)\n\t\tgoto err_enable_ipg;\n\n\tret = clk_prepare_enable(fbi->clk_ahb);\n\tif (ret)\n\t\tgoto err_enable_ahb;\n\n\tret = clk_prepare_enable(fbi->clk_per);\n\tif (ret)\n\t\tgoto err_enable_per;\n\n\tfbi->enabled = true;\n\treturn 0;\n\nerr_enable_per:\n\tclk_disable_unprepare(fbi->clk_ahb);\nerr_enable_ahb:\n\tclk_disable_unprepare(fbi->clk_ipg);\nerr_enable_ipg:\n\twritel(0, fbi->regs + LCDC_RMCR);\n\n\treturn ret;\n}\n\nstatic void imxfb_disable_controller(struct imxfb_info *fbi)\n{\n\tif (!fbi->enabled)\n\t\treturn;\n\n\tpr_debug(\"Disabling LCD controller\\n\");\n\n\tclk_disable_unprepare(fbi->clk_per);\n\tclk_disable_unprepare(fbi->clk_ahb);\n\tclk_disable_unprepare(fbi->clk_ipg);\n\tfbi->enabled = false;\n\n\twritel(0, fbi->regs + LCDC_RMCR);\n}\n\nstatic int imxfb_blank(int blank, struct fb_info *info)\n{\n\tstruct imxfb_info *fbi = info->par;\n\n\tpr_debug(\"imxfb_blank: blank=%d\\n\", blank);\n\n\tswitch (blank) {\n\tcase FB_BLANK_POWERDOWN:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_NORMAL:\n\t\timxfb_disable_controller(fbi);\n\t\tbreak;\n\n\tcase FB_BLANK_UNBLANK:\n\t\treturn imxfb_enable_controller(fbi);\n\t}\n\treturn 0;\n}\n\nstatic const struct fb_ops imxfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= imxfb_check_var,\n\t.fb_set_par\t= imxfb_set_par,\n\t.fb_setcolreg\t= imxfb_setcolreg,\n\t.fb_blank\t= imxfb_blank,\n};\n\n \nstatic int imxfb_activate_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct imxfb_info *fbi = info->par;\n\tu32 ymax_mask = is_imx1_fb(fbi) ? YMAX_MASK_IMX1 : YMAX_MASK_IMX21;\n\tu8 left_margin_low;\n\n\tpr_debug(\"var: xres=%d hslen=%d lm=%d rm=%d\\n\",\n\t\tvar->xres, var->hsync_len,\n\t\tvar->left_margin, var->right_margin);\n\tpr_debug(\"var: yres=%d vslen=%d um=%d bm=%d\\n\",\n\t\tvar->yres, var->vsync_len,\n\t\tvar->upper_margin, var->lower_margin);\n\n\tif (fbi->panel_type == PANEL_TYPE_TFT)\n\t\tleft_margin_low = 3;\n\telse if (fbi->panel_type == PANEL_TYPE_CSTN)\n\t\tleft_margin_low = 2;\n\telse\n\t\tleft_margin_low = 0;\n\n#if DEBUG_VAR\n\tif (var->xres < 16        || var->xres > 1024)\n\t\tprintk(KERN_ERR \"%s: invalid xres %d\\n\",\n\t\t\tinfo->fix.id, var->xres);\n\tif (var->hsync_len < 1    || var->hsync_len > 64)\n\t\tprintk(KERN_ERR \"%s: invalid hsync_len %d\\n\",\n\t\t\tinfo->fix.id, var->hsync_len);\n\tif (var->left_margin < left_margin_low  || var->left_margin > 255)\n\t\tprintk(KERN_ERR \"%s: invalid left_margin %d\\n\",\n\t\t\tinfo->fix.id, var->left_margin);\n\tif (var->right_margin < 1 || var->right_margin > 255)\n\t\tprintk(KERN_ERR \"%s: invalid right_margin %d\\n\",\n\t\t\tinfo->fix.id, var->right_margin);\n\tif (var->yres < 1 || var->yres > ymax_mask)\n\t\tprintk(KERN_ERR \"%s: invalid yres %d\\n\",\n\t\t\tinfo->fix.id, var->yres);\n\tif (var->vsync_len > 100)\n\t\tprintk(KERN_ERR \"%s: invalid vsync_len %d\\n\",\n\t\t\tinfo->fix.id, var->vsync_len);\n\tif (var->upper_margin > 63)\n\t\tprintk(KERN_ERR \"%s: invalid upper_margin %d\\n\",\n\t\t\tinfo->fix.id, var->upper_margin);\n\tif (var->lower_margin > 255)\n\t\tprintk(KERN_ERR \"%s: invalid lower_margin %d\\n\",\n\t\t\tinfo->fix.id, var->lower_margin);\n#endif\n\n\t \n\twritel(VPW_VPW(var->xres * var->bits_per_pixel / 8 / 4),\n\t\tfbi->regs + LCDC_VPW);\n\n\twritel(HCR_H_WIDTH(var->hsync_len - 1) |\n\t\tHCR_H_WAIT_1(var->right_margin - 1) |\n\t\tHCR_H_WAIT_2(var->left_margin - left_margin_low),\n\t\tfbi->regs + LCDC_HCR);\n\n\twritel(VCR_V_WIDTH(var->vsync_len) |\n\t\tVCR_V_WAIT_1(var->lower_margin) |\n\t\tVCR_V_WAIT_2(var->upper_margin),\n\t\tfbi->regs + LCDC_VCR);\n\n\twritel(SIZE_XMAX(var->xres) | (var->yres & ymax_mask),\n\t\t\tfbi->regs + LCDC_SIZE);\n\n\twritel(fbi->pcr, fbi->regs + LCDC_PCR);\n\tif (fbi->pwmr)\n\t\twritel(fbi->pwmr, fbi->regs + LCDC_PWMR);\n\twritel(fbi->lscr1, fbi->regs + LCDC_LSCR1);\n\n\t \n\tif (fbi->dmacr)\n\t\twritel(fbi->dmacr, fbi->regs + LCDC_DMACR);\n\n\tif (fbi->lauscr)\n\t\twritel(fbi->lauscr, fbi->regs + LCDC_LAUSCR);\n\n\treturn 0;\n}\n\nstatic int imxfb_init_fbinfo(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\tstruct imxfb_info *fbi = info->par;\n\tstruct device_node *np;\n\n\tpr_debug(\"%s\\n\",__func__);\n\n\tinfo->pseudo_palette = devm_kmalloc_array(&pdev->dev, 16,\n\t\t\t\t\t\t  sizeof(u32), GFP_KERNEL);\n\tif (!info->pseudo_palette)\n\t\treturn -ENOMEM;\n\n\tmemset(fbi, 0, sizeof(struct imxfb_info));\n\n\tfbi->devtype = pdev->id_entry->driver_data;\n\n\tstrscpy(info->fix.id, IMX_NAME, sizeof(info->fix.id));\n\n\tinfo->fix.type\t\t\t= FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.type_aux\t\t= 0;\n\tinfo->fix.xpanstep\t\t= 0;\n\tinfo->fix.ypanstep\t\t= 0;\n\tinfo->fix.ywrapstep\t\t= 0;\n\tinfo->fix.accel\t\t\t= FB_ACCEL_NONE;\n\n\tinfo->var.nonstd\t\t= 0;\n\tinfo->var.activate\t\t= FB_ACTIVATE_NOW;\n\tinfo->var.height\t\t= -1;\n\tinfo->var.width\t= -1;\n\tinfo->var.accel_flags\t\t= 0;\n\tinfo->var.vmode\t\t\t= FB_VMODE_NONINTERLACED;\n\n\tinfo->fbops\t\t\t= &imxfb_ops;\n\tinfo->flags\t\t\t= FBINFO_READS_FAST;\n\n\tnp = pdev->dev.of_node;\n\tinfo->var.grayscale = of_property_read_bool(np,\n\t\t\t\t\t\"cmap-greyscale\");\n\tfbi->cmap_inverse = of_property_read_bool(np, \"cmap-inverse\");\n\tfbi->cmap_static = of_property_read_bool(np, \"cmap-static\");\n\n\tfbi->lscr1 = IMXFB_LSCR1_DEFAULT;\n\n\tof_property_read_u32(np, \"fsl,lpccr\", &fbi->pwmr);\n\n\tof_property_read_u32(np, \"fsl,lscr1\", &fbi->lscr1);\n\n\tof_property_read_u32(np, \"fsl,dmacr\", &fbi->dmacr);\n\n\treturn 0;\n}\n\nstatic int imxfb_of_read_mode(struct device *dev, struct device_node *np,\n\t\tstruct imx_fb_videomode *imxfb_mode)\n{\n\tint ret;\n\tstruct fb_videomode *of_mode = &imxfb_mode->mode;\n\tu32 bpp;\n\tu32 pcr;\n\n\tret = of_property_read_string(np, \"model\", &of_mode->name);\n\tif (ret)\n\t\tof_mode->name = NULL;\n\n\tret = of_get_fb_videomode(np, of_mode, OF_USE_NATIVE_MODE);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get videomode from DT\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"bits-per-pixel\", &bpp);\n\tret |= of_property_read_u32(np, \"fsl,pcr\", &pcr);\n\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read bpp and pcr from DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bpp < 1 || bpp > 255) {\n\t\tdev_err(dev, \"Bits per pixel have to be between 1 and 255\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\timxfb_mode->bpp = bpp;\n\timxfb_mode->pcr = pcr;\n\n\t \n\timxfb_mode->aus_mode = of_property_read_bool(np, \"fsl,aus-mode\");\n\n\treturn 0;\n}\n\nstatic int imxfb_lcd_check_fb(struct lcd_device *lcddev, struct fb_info *fi)\n{\n\tstruct imxfb_info *fbi = dev_get_drvdata(&lcddev->dev);\n\n\tif (!fi || fi->par == fbi)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int imxfb_lcd_get_contrast(struct lcd_device *lcddev)\n{\n\tstruct imxfb_info *fbi = dev_get_drvdata(&lcddev->dev);\n\n\treturn fbi->pwmr & 0xff;\n}\n\nstatic int imxfb_lcd_set_contrast(struct lcd_device *lcddev, int contrast)\n{\n\tstruct imxfb_info *fbi = dev_get_drvdata(&lcddev->dev);\n\n\tif (fbi->pwmr && fbi->enabled) {\n\t\tif (contrast > 255)\n\t\t\tcontrast = 255;\n\t\telse if (contrast < 0)\n\t\t\tcontrast = 0;\n\n\t\tfbi->pwmr &= ~0xff;\n\t\tfbi->pwmr |= contrast;\n\n\t\twritel(fbi->pwmr, fbi->regs + LCDC_PWMR);\n\t}\n\n\treturn 0;\n}\n\nstatic int imxfb_lcd_get_power(struct lcd_device *lcddev)\n{\n\tstruct imxfb_info *fbi = dev_get_drvdata(&lcddev->dev);\n\n\tif (!IS_ERR(fbi->lcd_pwr) &&\n\t    !regulator_is_enabled(fbi->lcd_pwr))\n\t\treturn FB_BLANK_POWERDOWN;\n\n\treturn FB_BLANK_UNBLANK;\n}\n\nstatic int imxfb_regulator_set(struct imxfb_info *fbi, int enable)\n{\n\tint ret;\n\n\tif (enable == fbi->lcd_pwr_enabled)\n\t\treturn 0;\n\n\tif (enable)\n\t\tret = regulator_enable(fbi->lcd_pwr);\n\telse\n\t\tret = regulator_disable(fbi->lcd_pwr);\n\n\tif (ret == 0)\n\t\tfbi->lcd_pwr_enabled = enable;\n\n\treturn ret;\n}\n\nstatic int imxfb_lcd_set_power(struct lcd_device *lcddev, int power)\n{\n\tstruct imxfb_info *fbi = dev_get_drvdata(&lcddev->dev);\n\n\tif (!IS_ERR(fbi->lcd_pwr))\n\t\treturn imxfb_regulator_set(fbi, power == FB_BLANK_UNBLANK);\n\n\treturn 0;\n}\n\nstatic struct lcd_ops imxfb_lcd_ops = {\n\t.check_fb\t= imxfb_lcd_check_fb,\n\t.get_contrast\t= imxfb_lcd_get_contrast,\n\t.set_contrast\t= imxfb_lcd_set_contrast,\n\t.get_power\t= imxfb_lcd_get_power,\n\t.set_power\t= imxfb_lcd_set_power,\n};\n\nstatic int imxfb_setup(void)\n{\n\tchar *opt, *options = NULL;\n\n\tif (fb_get_options(\"imxfb\", &options))\n\t\treturn -ENODEV;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*opt)\n\t\t\tcontinue;\n\t\telse\n\t\t\tfb_mode = opt;\n\t}\n\n\treturn 0;\n}\n\nstatic int imxfb_probe(struct platform_device *pdev)\n{\n\tstruct imxfb_info *fbi;\n\tstruct lcd_device *lcd;\n\tstruct fb_info *info;\n\tstruct imx_fb_videomode *m;\n\tconst struct of_device_id *of_id;\n\tstruct device_node *display_np;\n\tint ret, i;\n\tint bytes_per_pixel;\n\n\tdev_info(&pdev->dev, \"i.MX Framebuffer driver\\n\");\n\n\tret = imxfb_setup();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tof_id = of_match_device(imxfb_of_dev_id, &pdev->dev);\n\tif (of_id)\n\t\tpdev->id_entry = of_id->data;\n\n\tinfo = framebuffer_alloc(sizeof(struct imxfb_info), &pdev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tfbi = info->par;\n\n\tplatform_set_drvdata(pdev, info);\n\n\tret = imxfb_init_fbinfo(pdev);\n\tif (ret < 0)\n\t\tgoto failed_init;\n\n\tfb_mode = NULL;\n\n\tdisplay_np = of_parse_phandle(pdev->dev.of_node, \"display\", 0);\n\tif (!display_np) {\n\t\tdev_err(&pdev->dev, \"No display defined in devicetree\\n\");\n\t\tret = -EINVAL;\n\t\tgoto failed_init;\n\t}\n\n\t \n\tfbi->num_modes = 1;\n\n\tfbi->mode = devm_kzalloc(&pdev->dev,\n\t\t\tsizeof(struct imx_fb_videomode), GFP_KERNEL);\n\tif (!fbi->mode) {\n\t\tret = -ENOMEM;\n\t\tof_node_put(display_np);\n\t\tgoto failed_init;\n\t}\n\n\tret = imxfb_of_read_mode(&pdev->dev, display_np, fbi->mode);\n\tof_node_put(display_np);\n\tif (ret)\n\t\tgoto failed_init;\n\n\t \n\tm = &fbi->mode[0];\n\tbytes_per_pixel = (m->bpp + 7) / 8;\n\tfor (i = 0; i < fbi->num_modes; i++, m++)\n\t\tinfo->fix.smem_len = max_t(size_t, info->fix.smem_len,\n\t\t\t\tm->mode.xres * m->mode.yres * bytes_per_pixel);\n\n\tfbi->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(fbi->clk_ipg)) {\n\t\tret = PTR_ERR(fbi->clk_ipg);\n\t\tgoto failed_init;\n\t}\n\n\t \n\tret = clk_prepare_enable(fbi->clk_ipg);\n\tif (ret)\n\t\tgoto failed_init;\n\tclk_disable_unprepare(fbi->clk_ipg);\n\n\tfbi->clk_ahb = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(fbi->clk_ahb)) {\n\t\tret = PTR_ERR(fbi->clk_ahb);\n\t\tgoto failed_init;\n\t}\n\n\tfbi->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(fbi->clk_per)) {\n\t\tret = PTR_ERR(fbi->clk_per);\n\t\tgoto failed_init;\n\t}\n\n\tfbi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(fbi->regs)) {\n\t\tret = PTR_ERR(fbi->regs);\n\t\tgoto failed_init;\n\t}\n\n\tfbi->map_size = PAGE_ALIGN(info->fix.smem_len);\n\tinfo->screen_buffer = dma_alloc_wc(&pdev->dev, fbi->map_size,\n\t\t\t\t\t   &fbi->map_dma, GFP_KERNEL);\n\tif (!info->screen_buffer) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate video RAM\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_init;\n\t}\n\n\tinfo->fix.smem_start = fbi->map_dma;\n\n\tINIT_LIST_HEAD(&info->modelist);\n\tfor (i = 0; i < fbi->num_modes; i++)\n\t\tfb_add_videomode(&fbi->mode[i].mode, &info->modelist);\n\n\t \n\timxfb_check_var(&info->var, info);\n\n\t \n\tret = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (ret < 0)\n\t\tgoto failed_cmap;\n\n\timxfb_set_par(info);\n\tret = register_framebuffer(info);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register framebuffer\\n\");\n\t\tgoto failed_register;\n\t}\n\n\tfbi->lcd_pwr = devm_regulator_get(&pdev->dev, \"lcd\");\n\tif (PTR_ERR(fbi->lcd_pwr) == -EPROBE_DEFER) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto failed_lcd;\n\t}\n\n\tlcd = devm_lcd_device_register(&pdev->dev, \"imxfb-lcd\", &pdev->dev, fbi,\n\t\t\t\t       &imxfb_lcd_ops);\n\tif (IS_ERR(lcd)) {\n\t\tret = PTR_ERR(lcd);\n\t\tgoto failed_lcd;\n\t}\n\n\tlcd->props.max_contrast = 0xff;\n\n\timxfb_enable_controller(fbi);\n\tfbi->pdev = pdev;\n\n\treturn 0;\n\nfailed_lcd:\n\tunregister_framebuffer(info);\nfailed_register:\n\tfb_dealloc_cmap(&info->cmap);\nfailed_cmap:\n\tdma_free_wc(&pdev->dev, fbi->map_size, info->screen_buffer,\n\t\t    fbi->map_dma);\nfailed_init:\n\tframebuffer_release(info);\n\treturn ret;\n}\n\nstatic void imxfb_remove(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\tstruct imxfb_info *fbi = info->par;\n\n\timxfb_disable_controller(fbi);\n\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\tdma_free_wc(&pdev->dev, fbi->map_size, info->screen_buffer,\n\t\t    fbi->map_dma);\n\tframebuffer_release(info);\n}\n\nstatic int imxfb_suspend(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct imxfb_info *fbi = info->par;\n\n\timxfb_disable_controller(fbi);\n\n\treturn 0;\n}\n\nstatic int imxfb_resume(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct imxfb_info *fbi = info->par;\n\n\timxfb_enable_controller(fbi);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(imxfb_pm_ops, imxfb_suspend, imxfb_resume);\n\nstatic struct platform_driver imxfb_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = imxfb_of_dev_id,\n\t\t.pm\t= pm_sleep_ptr(&imxfb_pm_ops),\n\t},\n\t.probe\t\t= imxfb_probe,\n\t.remove_new\t= imxfb_remove,\n\t.id_table\t= imxfb_devtype,\n};\nmodule_platform_driver(imxfb_driver);\n\nMODULE_DESCRIPTION(\"Freescale i.MX framebuffer driver\");\nMODULE_AUTHOR(\"Sascha Hauer, Pengutronix\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}