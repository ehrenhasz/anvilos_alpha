{
  "module_name": "sunxvr500.c",
  "hash_id": "693794977fcdf4333905e491ca109e2a97d9fadd7f2155313b6f0b8265effcdc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/sunxvr500.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/kernel.h>\n#include <linux/fb.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/of.h>\n\n#include <asm/io.h>\n\n \nstruct e3d_info {\n\tstruct fb_info\t\t*info;\n\tstruct pci_dev\t\t*pdev;\n\n\tspinlock_t\t\tlock;\n\n\tchar __iomem\t\t*fb_base;\n\tunsigned long\t\tfb_base_phys;\n\n\tunsigned long\t\tfb8_buf_diff;\n\tunsigned long\t\tregs_base_phys;\n\n\tvoid __iomem\t\t*ramdac;\n\n\tstruct device_node\t*of_node;\n\n\tunsigned int\t\twidth;\n\tunsigned int\t\theight;\n\tunsigned int\t\tdepth;\n\tunsigned int\t\tfb_size;\n\n\tu32\t\t\tfb_base_reg;\n\tu32\t\t\tfb8_0_off;\n\tu32\t\t\tfb8_1_off;\n\n\tu32\t\t\tpseudo_palette[16];\n};\n\nstatic int e3d_get_props(struct e3d_info *ep)\n{\n\tep->width = of_getintprop_default(ep->of_node, \"width\", 0);\n\tep->height = of_getintprop_default(ep->of_node, \"height\", 0);\n\tep->depth = of_getintprop_default(ep->of_node, \"depth\", 8);\n\n\tif (!ep->width || !ep->height) {\n\t\tprintk(KERN_ERR \"e3d: Critical properties missing for %s\\n\",\n\t\t       pci_name(ep->pdev));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n \n#define RAMDAC_VID_WH\t\t0x00000070UL  \n#define RAMDAC_VID_CFG\t\t0x00000074UL  \n#define RAMDAC_VID_32FB_0\t0x00000078UL  \n#define RAMDAC_VID_32FB_1\t0x0000007cUL  \n#define RAMDAC_VID_8FB_0\t0x00000080UL  \n#define RAMDAC_VID_8FB_1\t0x00000084UL  \n#define RAMDAC_VID_XXXFB\t0x00000088UL  \n#define RAMDAC_VID_YYYFB\t0x0000008cUL  \n#define RAMDAC_VID_ZZZFB\t0x00000090UL  \n\n \n#define RAMDAC_INDEX\t\t0x000000bcUL\n#define RAMDAC_DATA\t\t0x000000c0UL\n\nstatic void e3d_clut_write(struct e3d_info *ep, int index, u32 val)\n{\n\tvoid __iomem *ramdac = ep->ramdac;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\twritel(index, ramdac + RAMDAC_INDEX);\n\twritel(val, ramdac + RAMDAC_DATA);\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n}\n\nstatic int e3d_setcolreg(unsigned regno,\n\t\t\t unsigned red, unsigned green, unsigned blue,\n\t\t\t unsigned transp, struct fb_info *info)\n{\n\tstruct e3d_info *ep = info->par;\n\tu32 red_8, green_8, blue_8;\n\tu32 red_10, green_10, blue_10;\n\tu32 value;\n\n\tif (regno >= 256)\n\t\treturn 1;\n\n\tred_8 = red >> 8;\n\tgreen_8 = green >> 8;\n\tblue_8 = blue >> 8;\n\n\tvalue = (blue_8 << 24) | (green_8 << 16) | (red_8 << 8);\n\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16)\n\t\t((u32 *)info->pseudo_palette)[regno] = value;\n\n\n\tred_10 = red >> 6;\n\tgreen_10 = green >> 6;\n\tblue_10 = blue >> 6;\n\n\tvalue = (blue_10 << 20) | (green_10 << 10) | (red_10 << 0);\n\te3d_clut_write(ep, regno, value);\n\n\treturn 0;\n}\n\n \nstatic void e3d_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct e3d_info *ep = info->par;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tcfb_imageblit(info, image);\n\tinfo->screen_base += ep->fb8_buf_diff;\n\tcfb_imageblit(info, image);\n\tinfo->screen_base -= ep->fb8_buf_diff;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n}\n\nstatic void e3d_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct e3d_info *ep = info->par;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tcfb_fillrect(info, rect);\n\tinfo->screen_base += ep->fb8_buf_diff;\n\tcfb_fillrect(info, rect);\n\tinfo->screen_base -= ep->fb8_buf_diff;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n}\n\nstatic void e3d_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tstruct e3d_info *ep = info->par;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tcfb_copyarea(info, area);\n\tinfo->screen_base += ep->fb8_buf_diff;\n\tcfb_copyarea(info, area);\n\tinfo->screen_base -= ep->fb8_buf_diff;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n}\n\nstatic const struct fb_ops e3d_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_setcolreg\t\t= e3d_setcolreg,\n\t.fb_fillrect\t\t= e3d_fillrect,\n\t.fb_copyarea\t\t= e3d_copyarea,\n\t.fb_imageblit\t\t= e3d_imageblit,\n};\n\nstatic int e3d_set_fbinfo(struct e3d_info *ep)\n{\n\tstruct fb_info *info = ep->info;\n\tstruct fb_var_screeninfo *var = &info->var;\n\n\tinfo->fbops = &e3d_ops;\n\tinfo->screen_base = ep->fb_base;\n\tinfo->screen_size = ep->fb_size;\n\n\tinfo->pseudo_palette = ep->pseudo_palette;\n\n\t \n\tstrscpy(info->fix.id, \"e3d\", sizeof(info->fix.id));\n        info->fix.smem_start = ep->fb_base_phys;\n        info->fix.smem_len = ep->fb_size;\n        info->fix.type = FB_TYPE_PACKED_PIXELS;\n\tif (ep->depth == 32 || ep->depth == 24)\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\telse\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\n\tvar->xres = ep->width;\n\tvar->yres = ep->height;\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = var->yres;\n\tvar->bits_per_pixel = ep->depth;\n\n\tvar->red.offset = 8;\n\tvar->red.length = 8;\n\tvar->green.offset = 16;\n\tvar->green.length = 8;\n\tvar->blue.offset = 24;\n\tvar->blue.length = 8;\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0)) {\n\t\tprintk(KERN_ERR \"e3d: Cannot allocate color map.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n        return 0;\n}\n\nstatic int e3d_pci_register(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct device_node *of_node;\n\tconst char *device_type;\n\tstruct fb_info *info;\n\tstruct e3d_info *ep;\n\tunsigned int line_length;\n\tint err;\n\n\terr = aperture_remove_conflicting_pci_devices(pdev, \"e3dfb\");\n\tif (err)\n\t\treturn err;\n\n\tof_node = pci_device_to_OF_node(pdev);\n\tif (!of_node) {\n\t\tprintk(KERN_ERR \"e3d: Cannot find OF node of %s\\n\",\n\t\t       pci_name(pdev));\n\t\treturn -ENODEV;\n\t}\n\n\tdevice_type = of_get_property(of_node, \"device_type\", NULL);\n\tif (!device_type) {\n\t\tprintk(KERN_INFO \"e3d: Ignoring secondary output device \"\n\t\t       \"at %s\\n\", pci_name(pdev));\n\t\treturn -ENODEV;\n\t}\n\n\terr = pci_enable_device(pdev);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"e3d: Cannot enable PCI device %s\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto err_out;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct e3d_info), &pdev->dev);\n\tif (!info) {\n\t\terr = -ENOMEM;\n\t\tgoto err_disable;\n\t}\n\n\tep = info->par;\n\tep->info = info;\n\tep->pdev = pdev;\n\tspin_lock_init(&ep->lock);\n\tep->of_node = of_node;\n\n\t \n\tpci_read_config_dword(pdev, PCI_BASE_ADDRESS_0,\n\t\t\t      &ep->fb_base_reg);\n\tep->fb_base_reg &= PCI_BASE_ADDRESS_MEM_MASK;\n\n\tep->regs_base_phys = pci_resource_start (pdev, 1);\n\terr = pci_request_region(pdev, 1, \"e3d regs\");\n\tif (err < 0) {\n\t\tprintk(\"e3d: Cannot request region 1 for %s\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto err_release_fb;\n\t}\n\tep->ramdac = ioremap(ep->regs_base_phys + 0x8000, 0x1000);\n\tif (!ep->ramdac) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release_pci1;\n\t}\n\n\tep->fb8_0_off = readl(ep->ramdac + RAMDAC_VID_8FB_0);\n\tep->fb8_0_off -= ep->fb_base_reg;\n\n\tep->fb8_1_off = readl(ep->ramdac + RAMDAC_VID_8FB_1);\n\tep->fb8_1_off -= ep->fb_base_reg;\n\n\tep->fb8_buf_diff = ep->fb8_1_off - ep->fb8_0_off;\n\n\tep->fb_base_phys = pci_resource_start (pdev, 0);\n\tep->fb_base_phys += ep->fb8_0_off;\n\n\terr = pci_request_region(pdev, 0, \"e3d framebuffer\");\n\tif (err < 0) {\n\t\tprintk(\"e3d: Cannot request region 0 for %s\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto err_unmap_ramdac;\n\t}\n\n\terr = e3d_get_props(ep);\n\tif (err)\n\t\tgoto err_release_pci0;\n\n\tline_length = (readl(ep->ramdac + RAMDAC_VID_CFG) >> 16) & 0xff;\n\tline_length = 1 << line_length;\n\n\tswitch (ep->depth) {\n\tcase 8:\n\t\tinfo->fix.line_length = line_length;\n\t\tbreak;\n\tcase 16:\n\t\tinfo->fix.line_length = line_length * 2;\n\t\tbreak;\n\tcase 24:\n\t\tinfo->fix.line_length = line_length * 3;\n\t\tbreak;\n\tcase 32:\n\t\tinfo->fix.line_length = line_length * 4;\n\t\tbreak;\n\t}\n\tep->fb_size = info->fix.line_length * ep->height;\n\n\tep->fb_base = ioremap(ep->fb_base_phys, ep->fb_size);\n\tif (!ep->fb_base) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release_pci0;\n\t}\n\n\terr = e3d_set_fbinfo(ep);\n\tif (err)\n\t\tgoto err_unmap_fb;\n\n\tpci_set_drvdata(pdev, info);\n\n\tprintk(\"e3d: Found device at %s\\n\", pci_name(pdev));\n\n\terr = register_framebuffer(info);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"e3d: Could not register framebuffer %s\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto err_free_cmap;\n\t}\n\n\treturn 0;\n\nerr_free_cmap:\n\tfb_dealloc_cmap(&info->cmap);\n\nerr_unmap_fb:\n\tiounmap(ep->fb_base);\n\nerr_release_pci0:\n\tpci_release_region(pdev, 0);\n\nerr_unmap_ramdac:\n\tiounmap(ep->ramdac);\n\nerr_release_pci1:\n\tpci_release_region(pdev, 1);\n\nerr_release_fb:\n        framebuffer_release(info);\n\nerr_disable:\n\tpci_disable_device(pdev);\n\nerr_out:\n\treturn err;\n}\n\nstatic const struct pci_device_id e3d_pci_table[] = {\n\t{\tPCI_DEVICE(PCI_VENDOR_ID_3DLABS, 0x7a0),\t},\n\t{\tPCI_DEVICE(0x1091, 0x7a0),\t\t\t},\n\t{\tPCI_DEVICE(PCI_VENDOR_ID_3DLABS, 0x7a2),\t},\n\t{\t.vendor = PCI_VENDOR_ID_3DLABS,\n\t\t.device = PCI_ANY_ID,\n\t\t.subvendor = PCI_VENDOR_ID_3DLABS,\n\t\t.subdevice = 0x0108,\n\t},\n\t{\t.vendor = PCI_VENDOR_ID_3DLABS,\n\t\t.device = PCI_ANY_ID,\n\t\t.subvendor = PCI_VENDOR_ID_3DLABS,\n\t\t.subdevice = 0x0140,\n\t},\n\t{\t.vendor = PCI_VENDOR_ID_3DLABS,\n\t\t.device = PCI_ANY_ID,\n\t\t.subvendor = PCI_VENDOR_ID_3DLABS,\n\t\t.subdevice = 0x1024,\n\t},\n\t{ 0, }\n};\n\nstatic struct pci_driver e3d_driver = {\n\t.driver = {\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.name\t\t= \"e3d\",\n\t.id_table\t= e3d_pci_table,\n\t.probe\t\t= e3d_pci_register,\n};\n\nstatic int __init e3d_init(void)\n{\n\tif (fb_modesetting_disabled(\"e3d\"))\n\t\treturn -ENODEV;\n\n\tif (fb_get_options(\"e3d\", NULL))\n\t\treturn -ENODEV;\n\n\treturn pci_register_driver(&e3d_driver);\n}\ndevice_initcall(e3d_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}