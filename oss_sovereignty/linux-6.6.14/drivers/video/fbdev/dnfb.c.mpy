{
  "module_name": "dnfb.c",
  "hash_id": "948389850111f5b917c7319cba27650585acfe98468bf531fbc10768c9d96a16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/dnfb.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n\n#include <asm/setup.h>\n#include <asm/irq.h>\n#include <asm/amigahw.h>\n#include <asm/amigaints.h>\n#include <asm/apollohw.h>\n#include <linux/fb.h>\n#include <linux/module.h>\n\n \n\n \n\n#define AP_IOBASE       0x3b0\t \n#define AP_STATUS       isaIO2mem(AP_IOBASE+0)\t \n#define AP_WRITE_ENABLE isaIO2mem(AP_IOBASE+0)\t \n#define AP_DEVICE_ID    isaIO2mem(AP_IOBASE+1)\t \n#define AP_ROP_1        isaIO2mem(AP_IOBASE+2)\t \n#define AP_DIAG_MEM_REQ isaIO2mem(AP_IOBASE+4)\t \n#define AP_CONTROL_0    isaIO2mem(AP_IOBASE+8)\t \n#define AP_CONTROL_1    isaIO2mem(AP_IOBASE+0xa)\t \n#define AP_CONTROL_3A   isaIO2mem(AP_IOBASE+0xe)\t \n#define AP_CONTROL_2    isaIO2mem(AP_IOBASE+0xc)\t \n\n\n#define FRAME_BUFFER_START 0x0FA0000\n#define FRAME_BUFFER_LEN 0x40000\n\n \n#define VECTOR_MODE 0x40\t \n#define DBLT_MODE   0x80\t \n#define NORMAL_MODE 0xE0\t \n#define SHIFT_BITS  0x1F\t \n\t \n\n \n#define AD_BLT      0x80\t \n#define NORMAL      0x80  \t \n#define INVERSE     0x00  \t \n#define PIX_BLT     0x00\t \n\n#define AD_HIBIT        0x40\t \n\n#define ROP_EN          0x10\t \n#define DST_EQ_SRC      0x00\t \n#define nRESET_SYNC     0x08\t \n#define SYNC_ENAB       0x02\t \n\n#define BLANK_DISP      0x00\t \n#define ENAB_DISP       0x01\t \n\n#define NORM_CREG1      (nRESET_SYNC | SYNC_ENAB | ENAB_DISP)\t \n\n \n\n \n\n#define S_DATA_1s   0x00  \t \n#define S_DATA_PIX  0x40  \t \n#define S_DATA_PLN  0xC0  \t \n\n \n#       define RESET_CREG 0x80\t \n\n \n \n#define ROP(r2,r3,r0,r1) ( (U_SHORT)((r0)|((r1)<<4)|((r2)<<8)|((r3)<<12)) )\n#define DEST_ZERO               0x0\n#define SRC_AND_DEST    0x1\n#define SRC_AND_nDEST   0x2\n#define SRC                             0x3\n#define nSRC_AND_DEST   0x4\n#define DEST                    0x5\n#define SRC_XOR_DEST    0x6\n#define SRC_OR_DEST             0x7\n#define SRC_NOR_DEST    0x8\n#define SRC_XNOR_DEST   0x9\n#define nDEST                   0xA\n#define SRC_OR_nDEST    0xB\n#define nSRC                    0xC\n#define nSRC_OR_DEST    0xD\n#define SRC_NAND_DEST   0xE\n#define DEST_ONE                0xF\n\n#define SWAP(A) ((A>>8) | ((A&0xff) <<8))\n\n \n\nstatic int dnfb_blank(int blank, struct fb_info *info);\nstatic void dnfb_copyarea(struct fb_info *info, const struct fb_copyarea *area);\n\nstatic const struct fb_ops dn_fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_blank\t= dnfb_blank,\n\t.fb_fillrect\t= cfb_fillrect,\n\t.fb_copyarea\t= dnfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n};\n\nstatic const struct fb_var_screeninfo dnfb_var = {\n\t.xres\t\t= 1280,\n\t.yres\t\t= 1024,\n\t.xres_virtual\t= 2048,\n\t.yres_virtual\t= 1024,\n\t.bits_per_pixel\t= 1,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\nstatic const struct fb_fix_screeninfo dnfb_fix = {\n\t.id\t\t= \"Apollo Mono\",\n\t.smem_start\t= (FRAME_BUFFER_START + IO_BASE),\n\t.smem_len\t= FRAME_BUFFER_LEN,\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.visual\t\t= FB_VISUAL_MONO10,\n\t.line_length\t= 256,\n};\n\nstatic int dnfb_blank(int blank, struct fb_info *info)\n{\n\tif (blank)\n\t\tout_8(AP_CONTROL_3A, 0x0);\n\telse\n\t\tout_8(AP_CONTROL_3A, 0x1);\n\treturn 0;\n}\n\nstatic\nvoid dnfb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\n\tint incr, y_delta, pre_read = 0, x_end, x_word_count;\n\tuint start_mask, end_mask, dest;\n\tushort *src, dummy;\n\tshort i, j;\n\n\tincr = (area->dy <= area->sy) ? 1 : -1;\n\n\tsrc = (ushort *)(info->screen_base + area->sy * info->fix.line_length +\n\t\t\t(area->sx >> 4));\n\tdest = area->dy * (info->fix.line_length >> 1) + (area->dx >> 4);\n\n\tif (incr > 0) {\n\t\ty_delta = (info->fix.line_length * 8) - area->sx - area->width;\n\t\tx_end = area->dx + area->width - 1;\n\t\tx_word_count = (x_end >> 4) - (area->dx >> 4) + 1;\n\t\tstart_mask = 0xffff0000 >> (area->dx & 0xf);\n\t\tend_mask = 0x7ffff >> (x_end & 0xf);\n\t\tout_8(AP_CONTROL_0,\n\t\t     (((area->dx & 0xf) - (area->sx & 0xf)) % 16) | (0x4 << 5));\n\t\tif ((area->dx & 0xf) < (area->sx & 0xf))\n\t\t\tpre_read = 1;\n\t} else {\n\t\ty_delta = -((info->fix.line_length * 8) - area->sx - area->width);\n\t\tx_end = area->dx - area->width + 1;\n\t\tx_word_count = (area->dx >> 4) - (x_end >> 4) + 1;\n\t\tstart_mask = 0x7ffff >> (area->dx & 0xf);\n\t\tend_mask = 0xffff0000 >> (x_end & 0xf);\n\t\tout_8(AP_CONTROL_0,\n\t\t     ((-((area->sx & 0xf) - (area->dx & 0xf))) % 16) |\n\t\t     (0x4 << 5));\n\t\tif ((area->dx & 0xf) > (area->sx & 0xf))\n\t\t\tpre_read = 1;\n\t}\n\n\tfor (i = 0; i < area->height; i++) {\n\n\t\tout_8(AP_CONTROL_3A, 0xc | (dest >> 16));\n\n\t\tif (pre_read) {\n\t\t\tdummy = *src;\n\t\t\tsrc += incr;\n\t\t}\n\n\t\tif (x_word_count) {\n\t\t\tout_8(AP_WRITE_ENABLE, start_mask);\n\t\t\t*src = dest;\n\t\t\tsrc += incr;\n\t\t\tdest += incr;\n\t\t\tout_8(AP_WRITE_ENABLE, 0);\n\n\t\t\tfor (j = 1; j < (x_word_count - 1); j++) {\n\t\t\t\t*src = dest;\n\t\t\t\tsrc += incr;\n\t\t\t\tdest += incr;\n\t\t\t}\n\n\t\t\tout_8(AP_WRITE_ENABLE, start_mask);\n\t\t\t*src = dest;\n\t\t\tdest += incr;\n\t\t\tsrc += incr;\n\t\t} else {\n\t\t\tout_8(AP_WRITE_ENABLE, start_mask | end_mask);\n\t\t\t*src = dest;\n\t\t\tdest += incr;\n\t\t\tsrc += incr;\n\t\t}\n\t\tsrc += (y_delta / 16);\n\t\tdest += (y_delta / 16);\n\t}\n\tout_8(AP_CONTROL_0, NORMAL_MODE);\n}\n\n \n\nstatic int dnfb_probe(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\tint err = 0;\n\n\tinfo = framebuffer_alloc(0, &dev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->fbops = &dn_fb_ops;\n\tinfo->fix = dnfb_fix;\n\tinfo->var = dnfb_var;\n\tinfo->var.red.length = 1;\n\tinfo->var.red.offset = 0;\n\tinfo->var.green = info->var.blue = info->var.red;\n\tinfo->screen_base = (u_char *) info->fix.smem_start;\n\n\terr = fb_alloc_cmap(&info->cmap, 2, 0);\n\tif (err < 0)\n\t\tgoto release_framebuffer;\n\n\terr = register_framebuffer(info);\n\tif (err < 0) {\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\tgoto release_framebuffer;\n\t}\n\tplatform_set_drvdata(dev, info);\n\n\t \n\tout_8(AP_CONTROL_3A, RESET_CREG);\n\tout_be16(AP_WRITE_ENABLE, 0x0);\n\tout_8(AP_CONTROL_0, NORMAL_MODE);\n\tout_8(AP_CONTROL_1, (AD_BLT | DST_EQ_SRC | NORM_CREG1));\n\tout_8(AP_CONTROL_2, S_DATA_PLN);\n\tout_be16(AP_ROP_1, SWAP(0x3));\n\n\tprintk(\"apollo frame buffer alive and kicking !\\n\");\n\treturn err;\n\nrelease_framebuffer:\n\tframebuffer_release(info);\n\treturn err;\n}\n\nstatic struct platform_driver dnfb_driver = {\n\t.probe\t= dnfb_probe,\n\t.driver\t= {\n\t\t.name\t= \"dnfb\",\n\t},\n};\n\nstatic struct platform_device dnfb_device = {\n\t.name\t= \"dnfb\",\n};\n\nstatic int __init dnfb_init(void)\n{\n\tint ret;\n\n\tif (!MACH_IS_APOLLO)\n\t\treturn -ENODEV;\n\n\tif (fb_get_options(\"dnfb\", NULL))\n\t\treturn -ENODEV;\n\n\tret = platform_driver_register(&dnfb_driver);\n\n\tif (!ret) {\n\t\tret = platform_device_register(&dnfb_device);\n\t\tif (ret)\n\t\t\tplatform_driver_unregister(&dnfb_driver);\n\t}\n\treturn ret;\n}\n\nmodule_init(dnfb_init);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}