{
  "module_name": "pxa168fb.c",
  "hash_id": "9912de7e7b9850d196edbea1c1399322dcafc13d35f6858d2f705a1d29a03b8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/pxa168fb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/fb.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/uaccess.h>\n#include <video/pxa168fb.h>\n\n#include \"pxa168fb.h\"\n\n#define DEFAULT_REFRESH\t\t60\t \n\nstatic int determine_best_pix_fmt(struct fb_var_screeninfo *var)\n{\n\t \n\tif (var->bits_per_pixel == 8)\n\t\treturn PIX_FMT_PSEUDOCOLOR;\n\n\t \n\tif (var->bits_per_pixel == 16 && var->red.length <= 5 &&\n\t    var->green.length <= 6 && var->blue.length <= 5) {\n\t\tif (var->transp.length == 0) {\n\t\t\tif (var->red.offset >= var->blue.offset)\n\t\t\t\treturn PIX_FMT_RGB565;\n\t\t\telse\n\t\t\t\treturn PIX_FMT_BGR565;\n\t\t}\n\n\t\tif (var->transp.length == 1 && var->green.length <= 5) {\n\t\t\tif (var->red.offset >= var->blue.offset)\n\t\t\t\treturn PIX_FMT_RGB1555;\n\t\t\telse\n\t\t\t\treturn PIX_FMT_BGR1555;\n\t\t}\n\t}\n\n\t \n\tif (var->bits_per_pixel <= 32 && var->red.length <= 8 &&\n\t    var->green.length <= 8 && var->blue.length <= 8) {\n\t\tif (var->bits_per_pixel == 24 && var->transp.length == 0) {\n\t\t\tif (var->red.offset >= var->blue.offset)\n\t\t\t\treturn PIX_FMT_RGB888PACK;\n\t\t\telse\n\t\t\t\treturn PIX_FMT_BGR888PACK;\n\t\t}\n\n\t\tif (var->bits_per_pixel == 32 && var->transp.length == 8) {\n\t\t\tif (var->red.offset >= var->blue.offset)\n\t\t\t\treturn PIX_FMT_RGBA888;\n\t\t\telse\n\t\t\t\treturn PIX_FMT_BGRA888;\n\t\t} else {\n\t\t\tif (var->red.offset >= var->blue.offset)\n\t\t\t\treturn PIX_FMT_RGB888UNPACK;\n\t\t\telse\n\t\t\t\treturn PIX_FMT_BGR888UNPACK;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)\n{\n\tswitch (pix_fmt) {\n\tcase PIX_FMT_RGB565:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 11;    var->red.length = 5;\n\t\tvar->green.offset = 5;   var->green.length = 6;\n\t\tvar->blue.offset = 0;    var->blue.length = 5;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIX_FMT_BGR565:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 0;     var->red.length = 5;\n\t\tvar->green.offset = 5;   var->green.length = 6;\n\t\tvar->blue.offset = 11;   var->blue.length = 5;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIX_FMT_RGB1555:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 10;    var->red.length = 5;\n\t\tvar->green.offset = 5;   var->green.length = 5;\n\t\tvar->blue.offset = 0;    var->blue.length = 5;\n\t\tvar->transp.offset = 15; var->transp.length = 1;\n\t\tbreak;\n\tcase PIX_FMT_BGR1555:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 0;     var->red.length = 5;\n\t\tvar->green.offset = 5;   var->green.length = 5;\n\t\tvar->blue.offset = 10;   var->blue.length = 5;\n\t\tvar->transp.offset = 15; var->transp.length = 1;\n\t\tbreak;\n\tcase PIX_FMT_RGB888PACK:\n\t\tvar->bits_per_pixel = 24;\n\t\tvar->red.offset = 16;    var->red.length = 8;\n\t\tvar->green.offset = 8;   var->green.length = 8;\n\t\tvar->blue.offset = 0;    var->blue.length = 8;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIX_FMT_BGR888PACK:\n\t\tvar->bits_per_pixel = 24;\n\t\tvar->red.offset = 0;     var->red.length = 8;\n\t\tvar->green.offset = 8;   var->green.length = 8;\n\t\tvar->blue.offset = 16;   var->blue.length = 8;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIX_FMT_RGBA888:\n\t\tvar->bits_per_pixel = 32;\n\t\tvar->red.offset = 16;    var->red.length = 8;\n\t\tvar->green.offset = 8;   var->green.length = 8;\n\t\tvar->blue.offset = 0;    var->blue.length = 8;\n\t\tvar->transp.offset = 24; var->transp.length = 8;\n\t\tbreak;\n\tcase PIX_FMT_BGRA888:\n\t\tvar->bits_per_pixel = 32;\n\t\tvar->red.offset = 0;     var->red.length = 8;\n\t\tvar->green.offset = 8;   var->green.length = 8;\n\t\tvar->blue.offset = 16;   var->blue.length = 8;\n\t\tvar->transp.offset = 24; var->transp.length = 8;\n\t\tbreak;\n\tcase PIX_FMT_PSEUDOCOLOR:\n\t\tvar->bits_per_pixel = 8;\n\t\tvar->red.offset = 0;     var->red.length = 8;\n\t\tvar->green.offset = 0;   var->green.length = 8;\n\t\tvar->blue.offset = 0;    var->blue.length = 8;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\t}\n}\n\nstatic void set_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var,\n\t\t     struct fb_videomode *mode, int pix_fmt, int ystretch)\n{\n\tstruct fb_info *info = fbi->info;\n\n\tset_pix_fmt(var, pix_fmt);\n\n\tvar->xres = mode->xres;\n\tvar->yres = mode->yres;\n\tvar->xres_virtual = max(var->xres, var->xres_virtual);\n\tif (ystretch)\n\t\tvar->yres_virtual = info->fix.smem_len /\n\t\t\t(var->xres_virtual * (var->bits_per_pixel >> 3));\n\telse\n\t\tvar->yres_virtual = max(var->yres, var->yres_virtual);\n\tvar->grayscale = 0;\n\tvar->accel_flags = FB_ACCEL_NONE;\n\tvar->pixclock = mode->pixclock;\n\tvar->left_margin = mode->left_margin;\n\tvar->right_margin = mode->right_margin;\n\tvar->upper_margin = mode->upper_margin;\n\tvar->lower_margin = mode->lower_margin;\n\tvar->hsync_len = mode->hsync_len;\n\tvar->vsync_len = mode->vsync_len;\n\tvar->sync = mode->sync;\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\tvar->rotate = FB_ROTATE_UR;\n}\n\nstatic int pxa168fb_check_var(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct pxa168fb_info *fbi = info->par;\n\tint pix_fmt;\n\n\t \n\tpix_fmt = determine_best_pix_fmt(var);\n\tif (pix_fmt < 0)\n\t\treturn pix_fmt;\n\tset_pix_fmt(var, pix_fmt);\n\tfbi->pix_fmt = pix_fmt;\n\n\t \n\tif (var->xoffset + var->xres > var->xres_virtual)\n\t\treturn -EINVAL;\n\tif (var->yoffset + var->yres > var->yres_virtual)\n\t\treturn -EINVAL;\n\tif (var->xres + var->right_margin +\n\t    var->hsync_len + var->left_margin > 2048)\n\t\treturn -EINVAL;\n\tif (var->yres + var->lower_margin +\n\t    var->vsync_len + var->upper_margin > 2048)\n\t\treturn -EINVAL;\n\n\t \n\tif (var->xres_virtual * var->yres_virtual *\n\t    (var->bits_per_pixel >> 3) > info->fix.smem_len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic void set_clock_divider(struct pxa168fb_info *fbi,\n\t\t\t      const struct fb_videomode *m)\n{\n\tint divider_int;\n\tint needed_pixclk;\n\tu64 div_result;\n\tu32 x = 0;\n\n\t \n\n\t \n\tif (!m || !m->pixclock || !m->refresh) {\n\t\tdev_err(fbi->dev, \"Input refresh or pixclock is wrong.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tx = 0x80000000;\n\n\t \n\tdiv_result = 1000000000000ll;\n\tdo_div(div_result, m->pixclock);\n\tneeded_pixclk = (u32)div_result;\n\n\tdivider_int = clk_get_rate(fbi->clk) / needed_pixclk;\n\n\t \n\tif (divider_int < 2) {\n\t\tdev_warn(fbi->dev, \"Warning: clock source is too slow. \"\n\t\t\t\t\"Try smaller resolution\\n\");\n\t\tdivider_int = 2;\n\t}\n\n\t \n\tx |= divider_int;\n\twritel(x, fbi->reg_base + LCD_CFG_SCLK_DIV);\n}\n\nstatic void set_dma_control0(struct pxa168fb_info *fbi)\n{\n\tu32 x;\n\n\t \n\tx = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);\n\tx &= ~CFG_GRA_ENA_MASK;\n\tx |= fbi->active ? CFG_GRA_ENA(1) : CFG_GRA_ENA(0);\n\n\t \n\tif (fbi->pix_fmt == PIX_FMT_PSEUDOCOLOR)\n\t\tx |= 0x10000000;\n\n\t \n\tx &= ~(0xF << 16);\n\tx |= (fbi->pix_fmt >> 1) << 16;\n\n\t \n\tx &= ~(1 << 12);\n\tx |= ((fbi->pix_fmt & 1) ^ (fbi->panel_rbswap)) << 12;\n\n\twritel(x, fbi->reg_base + LCD_SPU_DMA_CTRL0);\n}\n\nstatic void set_dma_control1(struct pxa168fb_info *fbi, int sync)\n{\n\tu32 x;\n\n\t \n\tx = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1);\n\tx |= 0x2032ff81;\n\n\t \n\tif (!(sync & FB_SYNC_VERT_HIGH_ACT))\n\t\tx |= 0x08000000;\n\n\twritel(x, fbi->reg_base + LCD_SPU_DMA_CTRL1);\n}\n\nstatic void set_graphics_start(struct fb_info *info, int xoffset, int yoffset)\n{\n\tstruct pxa168fb_info *fbi = info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tint pixel_offset;\n\tunsigned long addr;\n\n\tpixel_offset = (yoffset * var->xres_virtual) + xoffset;\n\n\taddr = fbi->fb_start_dma + (pixel_offset * (var->bits_per_pixel >> 3));\n\twritel(addr, fbi->reg_base + LCD_CFG_GRA_START_ADDR0);\n}\n\nstatic void set_dumb_panel_control(struct fb_info *info)\n{\n\tstruct pxa168fb_info *fbi = info->par;\n\tstruct pxa168fb_mach_info *mi = dev_get_platdata(fbi->dev);\n\tu32 x;\n\n\t \n\tx = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL) & 0x00000001;\n\n\tx |= (fbi->is_blanked ? 0x7 : mi->dumb_mode) << 28;\n\tx |= mi->gpio_output_data << 20;\n\tx |= mi->gpio_output_mask << 12;\n\tx |= mi->panel_rgb_reverse_lanes ? 0x00000080 : 0;\n\tx |= mi->invert_composite_blank ? 0x00000040 : 0;\n\tx |= (info->var.sync & FB_SYNC_COMP_HIGH_ACT) ? 0x00000020 : 0;\n\tx |= mi->invert_pix_val_ena ? 0x00000010 : 0;\n\tx |= (info->var.sync & FB_SYNC_VERT_HIGH_ACT) ? 0 : 0x00000008;\n\tx |= (info->var.sync & FB_SYNC_HOR_HIGH_ACT) ? 0 : 0x00000004;\n\tx |= mi->invert_pixclock ? 0x00000002 : 0;\n\n\twritel(x, fbi->reg_base + LCD_SPU_DUMB_CTRL);\n}\n\nstatic void set_dumb_screen_dimensions(struct fb_info *info)\n{\n\tstruct pxa168fb_info *fbi = info->par;\n\tstruct fb_var_screeninfo *v = &info->var;\n\tint x;\n\tint y;\n\n\tx = v->xres + v->right_margin + v->hsync_len + v->left_margin;\n\ty = v->yres + v->lower_margin + v->vsync_len + v->upper_margin;\n\n\twritel((y << 16) | x, fbi->reg_base + LCD_SPUT_V_H_TOTAL);\n}\n\nstatic int pxa168fb_set_par(struct fb_info *info)\n{\n\tstruct pxa168fb_info *fbi = info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tstruct fb_videomode mode;\n\tu32 x;\n\n\t \n\tif (fbi->pix_fmt == PIX_FMT_PSEUDOCOLOR)\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\telse\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\tinfo->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;\n\tinfo->fix.ypanstep = var->yres;\n\n\t \n\tx = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL);\n\twritel(x & ~1, fbi->reg_base + LCD_SPU_DUMB_CTRL);\n\n\t \n\twritel((var->yres << 16) | var->xres,\n\t\tfbi->reg_base + LCD_SPU_V_H_ACTIVE);\n\n\t \n\tfb_var_to_videomode(&mode, &info->var);\n\n\t \n\tset_clock_divider(fbi, &mode);\n\n\t \n\tset_dma_control0(fbi);\n\tset_dma_control1(fbi, info->var.sync);\n\n\t \n\tx = readl(fbi->reg_base + LCD_CFG_GRA_PITCH);\n\tx = (x & ~0xFFFF) | ((var->xres_virtual * var->bits_per_pixel) >> 3);\n\twritel(x, fbi->reg_base + LCD_CFG_GRA_PITCH);\n\twritel((var->yres << 16) | var->xres,\n\t\tfbi->reg_base + LCD_SPU_GRA_HPXL_VLN);\n\twritel((var->yres << 16) | var->xres,\n\t\tfbi->reg_base + LCD_SPU_GZM_HPXL_VLN);\n\n\t \n\tset_dumb_panel_control(info);\n\tset_dumb_screen_dimensions(info);\n\n\twritel((var->left_margin << 16) | var->right_margin,\n\t\t\tfbi->reg_base + LCD_SPU_H_PORCH);\n\twritel((var->upper_margin << 16) | var->lower_margin,\n\t\t\tfbi->reg_base + LCD_SPU_V_PORCH);\n\n\t \n\tx = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL);\n\twritel(x | 1, fbi->reg_base + LCD_SPU_DUMB_CTRL);\n\n\treturn 0;\n}\n\nstatic unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)\n{\n\treturn ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;\n}\n\nstatic u32 to_rgb(u16 red, u16 green, u16 blue)\n{\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\treturn (red << 16) | (green << 8) | blue;\n}\n\nstatic int\npxa168fb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,\n\t\t unsigned int blue, unsigned int trans, struct fb_info *info)\n{\n\tstruct pxa168fb_info *fbi = info->par;\n\tu32 val;\n\n\tif (info->var.grayscale)\n\t\tred = green = blue = (19595 * red + 38470 * green +\n\t\t\t\t\t7471 * blue) >> 16;\n\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16) {\n\t\tval =  chan_to_field(red,   &info->var.red);\n\t\tval |= chan_to_field(green, &info->var.green);\n\t\tval |= chan_to_field(blue , &info->var.blue);\n\t\tfbi->pseudo_palette[regno] = val;\n\t}\n\n\tif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR && regno < 256) {\n\t\tval = to_rgb(red, green, blue);\n\t\twritel(val, fbi->reg_base + LCD_SPU_SRAM_WRDAT);\n\t\twritel(0x8300 | regno, fbi->reg_base + LCD_SPU_SRAM_CTRL);\n\t}\n\n\treturn 0;\n}\n\nstatic int pxa168fb_blank(int blank, struct fb_info *info)\n{\n\tstruct pxa168fb_info *fbi = info->par;\n\n\tfbi->is_blanked = (blank == FB_BLANK_UNBLANK) ? 0 : 1;\n\tset_dumb_panel_control(info);\n\n\treturn 0;\n}\n\nstatic int pxa168fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info)\n{\n\tset_graphics_start(info, var->xoffset, var->yoffset);\n\n\treturn 0;\n}\n\nstatic irqreturn_t pxa168fb_handle_irq(int irq, void *dev_id)\n{\n\tstruct pxa168fb_info *fbi = dev_id;\n\tu32 isr = readl(fbi->reg_base + SPU_IRQ_ISR);\n\n\tif ((isr & GRA_FRAME_IRQ0_ENA_MASK)) {\n\n\t\twritel(isr & (~GRA_FRAME_IRQ0_ENA_MASK),\n\t\t\tfbi->reg_base + SPU_IRQ_ISR);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic const struct fb_ops pxa168fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= pxa168fb_check_var,\n\t.fb_set_par\t= pxa168fb_set_par,\n\t.fb_setcolreg\t= pxa168fb_setcolreg,\n\t.fb_blank\t= pxa168fb_blank,\n\t.fb_pan_display\t= pxa168fb_pan_display,\n};\n\nstatic void pxa168fb_init_mode(struct fb_info *info,\n\t\t\t      struct pxa168fb_mach_info *mi)\n{\n\tstruct pxa168fb_info *fbi = info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tu32 total_w, total_h, refresh;\n\tu64 div_result;\n\tconst struct fb_videomode *m;\n\n\t \n\trefresh = DEFAULT_REFRESH;\n\n\t \n\tm = fb_find_best_mode(&info->var, &info->modelist);\n\tif (m)\n\t\tfb_videomode_to_var(&info->var, m);\n\n\t \n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = info->fix.smem_len /\n\t\t(var->xres_virtual * (var->bits_per_pixel >> 3));\n\tdev_dbg(fbi->dev, \"pxa168fb: find best mode: res = %dx%d\\n\",\n\t\t\t\tvar->xres, var->yres);\n\n\t \n\ttotal_w = var->xres + var->left_margin + var->right_margin +\n\t\t  var->hsync_len;\n\ttotal_h = var->yres + var->upper_margin + var->lower_margin +\n\t\t  var->vsync_len;\n\n\tdiv_result = 1000000000000ll;\n\tdo_div(div_result, total_w * total_h * refresh);\n\tvar->pixclock = (u32)div_result;\n}\n\nstatic int pxa168fb_probe(struct platform_device *pdev)\n{\n\tstruct pxa168fb_mach_info *mi;\n\tstruct fb_info *info = NULL;\n\tstruct pxa168fb_info *fbi = NULL;\n\tstruct resource *res;\n\tstruct clk *clk;\n\tint irq, ret;\n\n\tmi = dev_get_platdata(&pdev->dev);\n\tif (mi == NULL) {\n\t\tdev_err(&pdev->dev, \"no platform data defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tclk = devm_clk_get(&pdev->dev, \"LCDCLK\");\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(clk),\n\t\t\t\t     \"unable to get LCDCLK\");\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"no IO memory defined\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -ENOENT;\n\n\tinfo = framebuffer_alloc(sizeof(struct pxa168fb_info), &pdev->dev);\n\tif (info == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfbi = info->par;\n\tfbi->info = info;\n\tfbi->clk = clk;\n\tfbi->dev = &pdev->dev;\n\tfbi->panel_rbswap = mi->panel_rbswap;\n\tfbi->is_blanked = 0;\n\tfbi->active = mi->active;\n\n\t \n\tinfo->flags = FBINFO_PARTIAL_PAN_OK |\n\t\t      FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;\n\tinfo->node = -1;\n\tstrscpy(info->fix.id, mi->id, 16);\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.type_aux = 0;\n\tinfo->fix.xpanstep = 0;\n\tinfo->fix.ypanstep = 0;\n\tinfo->fix.ywrapstep = 0;\n\tinfo->fix.mmio_start = res->start;\n\tinfo->fix.mmio_len = resource_size(res);\n\tinfo->fix.accel = FB_ACCEL_NONE;\n\tinfo->fbops = &pxa168fb_ops;\n\tinfo->pseudo_palette = fbi->pseudo_palette;\n\n\t \n\tfbi->reg_base = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t     resource_size(res));\n\tif (fbi->reg_base == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto failed_free_info;\n\t}\n\n\t \n\tinfo->fix.smem_len = PAGE_ALIGN(DEFAULT_FB_SIZE);\n\n\tinfo->screen_base = dma_alloc_wc(fbi->dev, info->fix.smem_len,\n\t\t\t\t\t &fbi->fb_start_dma, GFP_KERNEL);\n\tif (info->screen_base == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto failed_free_info;\n\t}\n\n\tinfo->fix.smem_start = (unsigned long)fbi->fb_start_dma;\n\tset_graphics_start(info, 0, 0);\n\n\t \n\tset_mode(fbi, &info->var, mi->modes, mi->pix_fmt, 1);\n\n\tfb_videomode_to_modelist(mi->modes, mi->num_modes, &info->modelist);\n\n\t \n\tpxa168fb_init_mode(info, mi);\n\n\t \n\tret = pxa168fb_check_var(&info->var, info);\n\tif (ret)\n\t\tgoto failed_free_fbmem;\n\n\t \n\tclk_prepare_enable(fbi->clk);\n\n\tpxa168fb_set_par(info);\n\n\t \n\twritel(0, fbi->reg_base + LCD_SPU_BLANKCOLOR);\n\twritel(mi->io_pin_allocation_mode, fbi->reg_base + SPU_IOPAD_CONTROL);\n\twritel(0, fbi->reg_base + LCD_CFG_GRA_START_ADDR1);\n\twritel(0, fbi->reg_base + LCD_SPU_GRA_OVSA_HPXL_VLN);\n\twritel(0, fbi->reg_base + LCD_SPU_SRAM_PARA0);\n\twritel(CFG_CSB_256x32(0x1)|CFG_CSB_256x24(0x1)|CFG_CSB_256x8(0x1),\n\t\tfbi->reg_base + LCD_SPU_SRAM_PARA1);\n\n\t \n\tif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto failed_free_clk;\n\t}\n\n\t \n\tret = devm_request_irq(&pdev->dev, irq, pxa168fb_handle_irq,\n\t\t\t       IRQF_SHARED, info->fix.id, fbi);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"unable to request IRQ\\n\");\n\t\tret = -ENXIO;\n\t\tgoto failed_free_cmap;\n\t}\n\n\t \n\twritel(GRA_FRAME_IRQ0_ENA(0x1), fbi->reg_base + SPU_IRQ_ENA);\n\n\t \n\tret = register_framebuffer(info);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to register pxa168-fb: %d\\n\", ret);\n\t\tret = -ENXIO;\n\t\tgoto failed_free_cmap;\n\t}\n\n\tplatform_set_drvdata(pdev, fbi);\n\treturn 0;\n\nfailed_free_cmap:\n\tfb_dealloc_cmap(&info->cmap);\nfailed_free_clk:\n\tclk_disable_unprepare(fbi->clk);\nfailed_free_fbmem:\n\tdma_free_wc(fbi->dev, info->fix.smem_len,\n\t\t    info->screen_base, fbi->fb_start_dma);\nfailed_free_info:\n\tframebuffer_release(info);\n\n\tdev_err(&pdev->dev, \"frame buffer device init failed with %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void pxa168fb_remove(struct platform_device *pdev)\n{\n\tstruct pxa168fb_info *fbi = platform_get_drvdata(pdev);\n\tstruct fb_info *info;\n\tunsigned int data;\n\n\tif (!fbi)\n\t\treturn;\n\n\t \n\tdata = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);\n\tdata &= ~CFG_GRA_ENA_MASK;\n\twritel(data, fbi->reg_base + LCD_SPU_DMA_CTRL0);\n\n\tinfo = fbi->info;\n\n\tunregister_framebuffer(info);\n\n\twritel(GRA_FRAME_IRQ0_ENA(0x0), fbi->reg_base + SPU_IRQ_ENA);\n\n\tif (info->cmap.len)\n\t\tfb_dealloc_cmap(&info->cmap);\n\n\tdma_free_wc(fbi->dev, info->fix.smem_len,\n\t\t    info->screen_base, info->fix.smem_start);\n\n\tclk_disable_unprepare(fbi->clk);\n\n\tframebuffer_release(info);\n}\n\nstatic struct platform_driver pxa168fb_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"pxa168-fb\",\n\t},\n\t.probe\t\t= pxa168fb_probe,\n\t.remove_new\t= pxa168fb_remove,\n};\n\nmodule_platform_driver(pxa168fb_driver);\n\nMODULE_AUTHOR(\"Lennert Buytenhek <buytenh@marvell.com> \"\n\t      \"Green Wan <gwan@marvell.com>\");\nMODULE_DESCRIPTION(\"Framebuffer driver for PXA168/910\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}