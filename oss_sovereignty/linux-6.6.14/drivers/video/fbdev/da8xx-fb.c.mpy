{
  "module_name": "da8xx-fb.c",
  "hash_id": "aaf852cd31f24704985e49c1cb2322dd4e2cda77c704a1ce2f74198f0c1f6708",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/da8xx-fb.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fb.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n#include <linux/pm_runtime.h>\n#include <linux/interrupt.h>\n#include <linux/wait.h>\n#include <linux/clk.h>\n#include <linux/cpufreq.h>\n#include <linux/console.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/lcm.h>\n#include <video/da8xx-fb.h>\n#include <asm/div64.h>\n\n#define DRIVER_NAME \"da8xx_lcdc\"\n\n#define LCD_VERSION_1\t1\n#define LCD_VERSION_2\t2\n\n \n#define LCD_END_OF_FRAME1\t\tBIT(9)\n#define LCD_END_OF_FRAME0\t\tBIT(8)\n#define LCD_PL_LOAD_DONE\t\tBIT(6)\n#define LCD_FIFO_UNDERFLOW\t\tBIT(5)\n#define LCD_SYNC_LOST\t\t\tBIT(2)\n#define LCD_FRAME_DONE\t\t\tBIT(0)\n\n \n#define LCD_DMA_BURST_SIZE(x)\t\t((x) << 4)\n#define LCD_DMA_BURST_1\t\t\t0x0\n#define LCD_DMA_BURST_2\t\t\t0x1\n#define LCD_DMA_BURST_4\t\t\t0x2\n#define LCD_DMA_BURST_8\t\t\t0x3\n#define LCD_DMA_BURST_16\t\t0x4\n#define LCD_V1_END_OF_FRAME_INT_ENA\tBIT(2)\n#define LCD_V2_END_OF_FRAME0_INT_ENA\tBIT(8)\n#define LCD_V2_END_OF_FRAME1_INT_ENA\tBIT(9)\n#define LCD_DUAL_FRAME_BUFFER_ENABLE\tBIT(0)\n\n \n#define LCD_CLK_DIVISOR(x)\t\t((x) << 8)\n#define LCD_RASTER_MODE\t\t\t0x01\n\n \n#define LCD_PALETTE_LOAD_MODE(x)\t((x) << 20)\n#define PALETTE_AND_DATA\t\t0x00\n#define PALETTE_ONLY\t\t\t0x01\n#define DATA_ONLY\t\t\t0x02\n\n#define LCD_MONO_8BIT_MODE\t\tBIT(9)\n#define LCD_RASTER_ORDER\t\tBIT(8)\n#define LCD_TFT_MODE\t\t\tBIT(7)\n#define LCD_V1_UNDERFLOW_INT_ENA\tBIT(6)\n#define LCD_V2_UNDERFLOW_INT_ENA\tBIT(5)\n#define LCD_V1_PL_INT_ENA\t\tBIT(4)\n#define LCD_V2_PL_INT_ENA\t\tBIT(6)\n#define LCD_MONOCHROME_MODE\t\tBIT(1)\n#define LCD_RASTER_ENABLE\t\tBIT(0)\n#define LCD_TFT_ALT_ENABLE\t\tBIT(23)\n#define LCD_STN_565_ENABLE\t\tBIT(24)\n#define LCD_V2_DMA_CLK_EN\t\tBIT(2)\n#define LCD_V2_LIDD_CLK_EN\t\tBIT(1)\n#define LCD_V2_CORE_CLK_EN\t\tBIT(0)\n#define LCD_V2_LPP_B10\t\t\t26\n#define LCD_V2_TFT_24BPP_MODE\t\tBIT(25)\n#define LCD_V2_TFT_24BPP_UNPACK\t\tBIT(26)\n\n \n#define LCD_AC_BIAS_TRANSITIONS_PER_INT(x)\t((x) << 16)\n#define LCD_AC_BIAS_FREQUENCY(x)\t\t((x) << 8)\n#define LCD_SYNC_CTRL\t\t\t\tBIT(25)\n#define LCD_SYNC_EDGE\t\t\t\tBIT(24)\n#define LCD_INVERT_PIXEL_CLOCK\t\t\tBIT(22)\n#define LCD_INVERT_LINE_CLOCK\t\t\tBIT(21)\n#define LCD_INVERT_FRAME_CLOCK\t\t\tBIT(20)\n\n \n#define  LCD_PID_REG\t\t\t\t0x0\n#define  LCD_CTRL_REG\t\t\t\t0x4\n#define  LCD_STAT_REG\t\t\t\t0x8\n#define  LCD_RASTER_CTRL_REG\t\t\t0x28\n#define  LCD_RASTER_TIMING_0_REG\t\t0x2C\n#define  LCD_RASTER_TIMING_1_REG\t\t0x30\n#define  LCD_RASTER_TIMING_2_REG\t\t0x34\n#define  LCD_DMA_CTRL_REG\t\t\t0x40\n#define  LCD_DMA_FRM_BUF_BASE_ADDR_0_REG\t0x44\n#define  LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG\t0x48\n#define  LCD_DMA_FRM_BUF_BASE_ADDR_1_REG\t0x4C\n#define  LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG\t0x50\n\n \n#define  LCD_RAW_STAT_REG\t\t\t0x58\n#define  LCD_MASKED_STAT_REG\t\t\t0x5c\n#define  LCD_INT_ENABLE_SET_REG\t\t\t0x60\n#define  LCD_INT_ENABLE_CLR_REG\t\t\t0x64\n#define  LCD_END_OF_INT_IND_REG\t\t\t0x68\n\n \n#define  LCD_CLK_ENABLE_REG\t\t\t0x6c\n#define  LCD_CLK_RESET_REG\t\t\t0x70\n#define  LCD_CLK_MAIN_RESET\t\t\tBIT(3)\n\n#define LCD_NUM_BUFFERS\t2\n\n#define PALETTE_SIZE\t256\n\n#define\tCLK_MIN_DIV\t2\n#define\tCLK_MAX_DIV\t255\n\nstatic void __iomem *da8xx_fb_reg_base;\nstatic unsigned int lcd_revision;\nstatic irq_handler_t lcdc_irq_handler;\nstatic wait_queue_head_t frame_done_wq;\nstatic int frame_done_flag;\n\nstatic unsigned int lcdc_read(unsigned int addr)\n{\n\treturn (unsigned int)__raw_readl(da8xx_fb_reg_base + (addr));\n}\n\nstatic void lcdc_write(unsigned int val, unsigned int addr)\n{\n\t__raw_writel(val, da8xx_fb_reg_base + (addr));\n}\n\nstruct da8xx_fb_par {\n\tstruct device\t\t*dev;\n\tdma_addr_t\t\tp_palette_base;\n\tunsigned char *v_palette_base;\n\tdma_addr_t\t\tvram_phys;\n\tunsigned long\t\tvram_size;\n\tvoid\t\t\t*vram_virt;\n\tunsigned int\t\tdma_start;\n\tunsigned int\t\tdma_end;\n\tstruct clk *lcdc_clk;\n\tint irq;\n\tunsigned int palette_sz;\n\tint blank;\n\twait_queue_head_t\tvsync_wait;\n\tint\t\t\tvsync_flag;\n\tint\t\t\tvsync_timeout;\n\tspinlock_t\t\tlock_for_chan_update;\n\n\t \n\tunsigned int\t\twhich_dma_channel_done;\n#ifdef CONFIG_CPU_FREQ\n\tstruct notifier_block\tfreq_transition;\n#endif\n\tunsigned int\t\tlcdc_clk_rate;\n\tstruct regulator\t*lcd_supply;\n\tu32 pseudo_palette[16];\n\tstruct fb_videomode\tmode;\n\tstruct lcd_ctrl_config\tcfg;\n};\n\nstatic struct fb_var_screeninfo da8xx_fb_var;\n\nstatic struct fb_fix_screeninfo da8xx_fb_fix = {\n\t.id = \"DA8xx FB Drv\",\n\t.type = FB_TYPE_PACKED_PIXELS,\n\t.type_aux = 0,\n\t.visual = FB_VISUAL_PSEUDOCOLOR,\n\t.xpanstep = 0,\n\t.ypanstep = 1,\n\t.ywrapstep = 0,\n\t.accel = FB_ACCEL_NONE\n};\n\nstatic struct fb_videomode known_lcd_panels[] = {\n\t \n\t[0] = {\n\t\t.name           = \"Sharp_LCD035Q3DG01\",\n\t\t.xres           = 320,\n\t\t.yres           = 240,\n\t\t.pixclock       = KHZ2PICOS(4607),\n\t\t.left_margin    = 6,\n\t\t.right_margin   = 8,\n\t\t.upper_margin   = 2,\n\t\t.lower_margin   = 2,\n\t\t.hsync_len      = 0,\n\t\t.vsync_len      = 0,\n\t\t.sync           = FB_SYNC_CLK_INVERT,\n\t},\n\t \n\t[1] = {\n\t\t.name           = \"Sharp_LK043T1DG01\",\n\t\t.xres           = 480,\n\t\t.yres           = 272,\n\t\t.pixclock       = KHZ2PICOS(7833),\n\t\t.left_margin    = 2,\n\t\t.right_margin   = 2,\n\t\t.upper_margin   = 2,\n\t\t.lower_margin   = 2,\n\t\t.hsync_len      = 41,\n\t\t.vsync_len      = 10,\n\t\t.sync           = 0,\n\t\t.flag           = 0,\n\t},\n\t[2] = {\n\t\t \n\t\t.name           = \"SP10Q010\",\n\t\t.xres           = 320,\n\t\t.yres           = 240,\n\t\t.pixclock       = KHZ2PICOS(7833),\n\t\t.left_margin    = 10,\n\t\t.right_margin   = 10,\n\t\t.upper_margin   = 10,\n\t\t.lower_margin   = 10,\n\t\t.hsync_len      = 10,\n\t\t.vsync_len      = 10,\n\t\t.sync           = 0,\n\t\t.flag           = 0,\n\t},\n\t[3] = {\n\t\t \n\t\t.name           = \"Densitron_84-0023-001T\",\n\t\t.xres           = 320,\n\t\t.yres           = 240,\n\t\t.pixclock       = KHZ2PICOS(6400),\n\t\t.left_margin    = 0,\n\t\t.right_margin   = 0,\n\t\t.upper_margin   = 0,\n\t\t.lower_margin   = 0,\n\t\t.hsync_len      = 30,\n\t\t.vsync_len      = 3,\n\t\t.sync           = 0,\n\t},\n};\n\nstatic bool da8xx_fb_is_raster_enabled(void)\n{\n\treturn !!(lcdc_read(LCD_RASTER_CTRL_REG) & LCD_RASTER_ENABLE);\n}\n\n \nstatic void lcd_enable_raster(void)\n{\n\tu32 reg;\n\n\t \n\tif (lcd_revision == LCD_VERSION_2)\n\t\t \n\t\tlcdc_write(LCD_CLK_MAIN_RESET, LCD_CLK_RESET_REG);\n\tmdelay(1);\n\n\t \n\tif (lcd_revision == LCD_VERSION_2)\n\t\tlcdc_write(0, LCD_CLK_RESET_REG);\n\tmdelay(1);\n\n\t \n\treg = lcdc_read(LCD_RASTER_CTRL_REG);\n\tif (!(reg & LCD_RASTER_ENABLE))\n\t\tlcdc_write(reg | LCD_RASTER_ENABLE, LCD_RASTER_CTRL_REG);\n}\n\n \nstatic void lcd_disable_raster(enum da8xx_frame_complete wait_for_frame_done)\n{\n\tu32 reg;\n\tint ret;\n\n\treg = lcdc_read(LCD_RASTER_CTRL_REG);\n\tif (reg & LCD_RASTER_ENABLE)\n\t\tlcdc_write(reg & ~LCD_RASTER_ENABLE, LCD_RASTER_CTRL_REG);\n\telse\n\t\t \n\t\treturn;\n\n\tif ((wait_for_frame_done == DA8XX_FRAME_WAIT) &&\n\t\t\t(lcd_revision == LCD_VERSION_2)) {\n\t\tframe_done_flag = 0;\n\t\tret = wait_event_interruptible_timeout(frame_done_wq,\n\t\t\t\tframe_done_flag != 0,\n\t\t\t\tmsecs_to_jiffies(50));\n\t\tif (ret == 0)\n\t\t\tpr_err(\"LCD Controller timed out\\n\");\n\t}\n}\n\nstatic void lcd_blit(int load_mode, struct da8xx_fb_par *par)\n{\n\tu32 start;\n\tu32 end;\n\tu32 reg_ras;\n\tu32 reg_dma;\n\tu32 reg_int;\n\n\t \n\treg_ras = lcdc_read(LCD_RASTER_CTRL_REG);\n\treg_ras &= ~(3 << 20);\n\n\treg_dma  = lcdc_read(LCD_DMA_CTRL_REG);\n\n\tif (load_mode == LOAD_DATA) {\n\t\tstart    = par->dma_start;\n\t\tend      = par->dma_end;\n\n\t\treg_ras |= LCD_PALETTE_LOAD_MODE(DATA_ONLY);\n\t\tif (lcd_revision == LCD_VERSION_1) {\n\t\t\treg_dma |= LCD_V1_END_OF_FRAME_INT_ENA;\n\t\t} else {\n\t\t\treg_int = lcdc_read(LCD_INT_ENABLE_SET_REG) |\n\t\t\t\tLCD_V2_END_OF_FRAME0_INT_ENA |\n\t\t\t\tLCD_V2_END_OF_FRAME1_INT_ENA |\n\t\t\t\tLCD_FRAME_DONE | LCD_SYNC_LOST;\n\t\t\tlcdc_write(reg_int, LCD_INT_ENABLE_SET_REG);\n\t\t}\n\t\treg_dma |= LCD_DUAL_FRAME_BUFFER_ENABLE;\n\n\t\tlcdc_write(start, LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\n\t\tlcdc_write(end, LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\n\t\tlcdc_write(start, LCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\n\t\tlcdc_write(end, LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\n\t} else if (load_mode == LOAD_PALETTE) {\n\t\tstart    = par->p_palette_base;\n\t\tend      = start + par->palette_sz - 1;\n\n\t\treg_ras |= LCD_PALETTE_LOAD_MODE(PALETTE_ONLY);\n\n\t\tif (lcd_revision == LCD_VERSION_1) {\n\t\t\treg_ras |= LCD_V1_PL_INT_ENA;\n\t\t} else {\n\t\t\treg_int = lcdc_read(LCD_INT_ENABLE_SET_REG) |\n\t\t\t\tLCD_V2_PL_INT_ENA;\n\t\t\tlcdc_write(reg_int, LCD_INT_ENABLE_SET_REG);\n\t\t}\n\n\t\tlcdc_write(start, LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\n\t\tlcdc_write(end, LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\n\t}\n\n\tlcdc_write(reg_dma, LCD_DMA_CTRL_REG);\n\tlcdc_write(reg_ras, LCD_RASTER_CTRL_REG);\n\n\t \n\tlcd_enable_raster();\n}\n\n \nstatic int lcd_cfg_dma(int burst_size, int fifo_th)\n{\n\tu32 reg;\n\n\treg = lcdc_read(LCD_DMA_CTRL_REG) & 0x00000001;\n\tswitch (burst_size) {\n\tcase 1:\n\t\treg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_1);\n\t\tbreak;\n\tcase 2:\n\t\treg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_2);\n\t\tbreak;\n\tcase 4:\n\t\treg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_4);\n\t\tbreak;\n\tcase 8:\n\t\treg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_8);\n\t\tbreak;\n\tcase 16:\n\tdefault:\n\t\treg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_16);\n\t\tbreak;\n\t}\n\n\treg |= (fifo_th << 8);\n\n\tlcdc_write(reg, LCD_DMA_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic void lcd_cfg_ac_bias(int period, int transitions_per_int)\n{\n\tu32 reg;\n\n\t \n\treg = lcdc_read(LCD_RASTER_TIMING_2_REG) & 0xFFF00000;\n\treg |= LCD_AC_BIAS_FREQUENCY(period) |\n\t\tLCD_AC_BIAS_TRANSITIONS_PER_INT(transitions_per_int);\n\tlcdc_write(reg, LCD_RASTER_TIMING_2_REG);\n}\n\nstatic void lcd_cfg_horizontal_sync(int back_porch, int pulse_width,\n\t\tint front_porch)\n{\n\tu32 reg;\n\n\treg = lcdc_read(LCD_RASTER_TIMING_0_REG) & 0x3ff;\n\treg |= (((back_porch-1) & 0xff) << 24)\n\t    | (((front_porch-1) & 0xff) << 16)\n\t    | (((pulse_width-1) & 0x3f) << 10);\n\tlcdc_write(reg, LCD_RASTER_TIMING_0_REG);\n\n\t \n\tif (lcd_revision == LCD_VERSION_2) {\n\t\t \n\t\treg = lcdc_read(LCD_RASTER_TIMING_2_REG) & ~0x780000ff;\n\t\treg |= ((front_porch-1) & 0x300) >> 8;\n\t\treg |= ((back_porch-1) & 0x300) >> 4;\n\t\treg |= ((pulse_width-1) & 0x3c0) << 21;\n\t\tlcdc_write(reg, LCD_RASTER_TIMING_2_REG);\n\t}\n}\n\nstatic void lcd_cfg_vertical_sync(int back_porch, int pulse_width,\n\t\tint front_porch)\n{\n\tu32 reg;\n\n\treg = lcdc_read(LCD_RASTER_TIMING_1_REG) & 0x3ff;\n\treg |= ((back_porch & 0xff) << 24)\n\t    | ((front_porch & 0xff) << 16)\n\t    | (((pulse_width-1) & 0x3f) << 10);\n\tlcdc_write(reg, LCD_RASTER_TIMING_1_REG);\n}\n\nstatic int lcd_cfg_display(const struct lcd_ctrl_config *cfg,\n\t\tstruct fb_videomode *panel)\n{\n\tu32 reg;\n\tu32 reg_int;\n\n\treg = lcdc_read(LCD_RASTER_CTRL_REG) & ~(LCD_TFT_MODE |\n\t\t\t\t\t\tLCD_MONO_8BIT_MODE |\n\t\t\t\t\t\tLCD_MONOCHROME_MODE);\n\n\tswitch (cfg->panel_shade) {\n\tcase MONOCHROME:\n\t\treg |= LCD_MONOCHROME_MODE;\n\t\tif (cfg->mono_8bit_mode)\n\t\t\treg |= LCD_MONO_8BIT_MODE;\n\t\tbreak;\n\tcase COLOR_ACTIVE:\n\t\treg |= LCD_TFT_MODE;\n\t\tif (cfg->tft_alt_mode)\n\t\t\treg |= LCD_TFT_ALT_ENABLE;\n\t\tbreak;\n\n\tcase COLOR_PASSIVE:\n\t\t \n\t\tlcd_cfg_ac_bias(cfg->ac_bias, cfg->ac_bias_intrpt);\n\t\tif (cfg->bpp == 12 && cfg->stn_565_mode)\n\t\t\treg |= LCD_STN_565_ENABLE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (lcd_revision == LCD_VERSION_1) {\n\t\treg |= LCD_V1_UNDERFLOW_INT_ENA;\n\t} else {\n\t\treg_int = lcdc_read(LCD_INT_ENABLE_SET_REG) |\n\t\t\tLCD_V2_UNDERFLOW_INT_ENA;\n\t\tlcdc_write(reg_int, LCD_INT_ENABLE_SET_REG);\n\t}\n\n\tlcdc_write(reg, LCD_RASTER_CTRL_REG);\n\n\treg = lcdc_read(LCD_RASTER_TIMING_2_REG);\n\n\treg |= LCD_SYNC_CTRL;\n\n\tif (cfg->sync_edge)\n\t\treg |= LCD_SYNC_EDGE;\n\telse\n\t\treg &= ~LCD_SYNC_EDGE;\n\n\tif ((panel->sync & FB_SYNC_HOR_HIGH_ACT) == 0)\n\t\treg |= LCD_INVERT_LINE_CLOCK;\n\telse\n\t\treg &= ~LCD_INVERT_LINE_CLOCK;\n\n\tif ((panel->sync & FB_SYNC_VERT_HIGH_ACT) == 0)\n\t\treg |= LCD_INVERT_FRAME_CLOCK;\n\telse\n\t\treg &= ~LCD_INVERT_FRAME_CLOCK;\n\n\tlcdc_write(reg, LCD_RASTER_TIMING_2_REG);\n\n\treturn 0;\n}\n\nstatic int lcd_cfg_frame_buffer(struct da8xx_fb_par *par, u32 width, u32 height,\n\t\tu32 bpp, u32 raster_order)\n{\n\tu32 reg;\n\n\tif (bpp > 16 && lcd_revision == LCD_VERSION_1)\n\t\treturn -EINVAL;\n\n\t \n\t \n\tif (lcd_revision == LCD_VERSION_1) {\n\t\t \n\t\twidth &= 0x3f0;\n\t} else {\n\t\t \n\t\twidth &= 0x7f0;\n\t}\n\n\treg = lcdc_read(LCD_RASTER_TIMING_0_REG);\n\treg &= 0xfffffc00;\n\tif (lcd_revision == LCD_VERSION_1) {\n\t\treg |= ((width >> 4) - 1) << 4;\n\t} else {\n\t\twidth = (width >> 4) - 1;\n\t\treg |= ((width & 0x3f) << 4) | ((width & 0x40) >> 3);\n\t}\n\tlcdc_write(reg, LCD_RASTER_TIMING_0_REG);\n\n\t \n\t \n\treg = lcdc_read(LCD_RASTER_TIMING_1_REG);\n\treg = ((height - 1) & 0x3ff) | (reg & 0xfffffc00);\n\tlcdc_write(reg, LCD_RASTER_TIMING_1_REG);\n\n\t \n\tif (lcd_revision == LCD_VERSION_2) {\n\t\treg = lcdc_read(LCD_RASTER_TIMING_2_REG);\n\t\treg |= ((height - 1) & 0x400) << 16;\n\t\tlcdc_write(reg, LCD_RASTER_TIMING_2_REG);\n\t}\n\n\t \n\treg = lcdc_read(LCD_RASTER_CTRL_REG) & ~(1 << 8);\n\tif (raster_order)\n\t\treg |= LCD_RASTER_ORDER;\n\n\tpar->palette_sz = 16 * 2;\n\n\tswitch (bpp) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 16:\n\t\tbreak;\n\tcase 24:\n\t\treg |= LCD_V2_TFT_24BPP_MODE;\n\t\tbreak;\n\tcase 32:\n\t\treg |= LCD_V2_TFT_24BPP_MODE;\n\t\treg |= LCD_V2_TFT_24BPP_UNPACK;\n\t\tbreak;\n\tcase 8:\n\t\tpar->palette_sz = 256 * 2;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlcdc_write(reg, LCD_RASTER_CTRL_REG);\n\n\treturn 0;\n}\n\n#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)\nstatic int fb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t      unsigned blue, unsigned transp,\n\t\t\t      struct fb_info *info)\n{\n\tstruct da8xx_fb_par *par = info->par;\n\tunsigned short *palette = (unsigned short *) par->v_palette_base;\n\tu_short pal;\n\tint update_hw = 0;\n\n\tif (regno > 255)\n\t\treturn 1;\n\n\tif (info->fix.visual == FB_VISUAL_DIRECTCOLOR)\n\t\treturn 1;\n\n\tif (info->var.bits_per_pixel > 16 && lcd_revision == LCD_VERSION_1)\n\t\treturn -EINVAL;\n\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\tred = CNVT_TOHW(red, info->var.red.length);\n\t\tgreen = CNVT_TOHW(green, info->var.green.length);\n\t\tblue = CNVT_TOHW(blue, info->var.blue.length);\n\t\tbreak;\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 4:\n\t\t\tif (regno > 15)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (info->var.grayscale) {\n\t\t\t\tpal = regno;\n\t\t\t} else {\n\t\t\t\tred >>= 4;\n\t\t\t\tgreen >>= 8;\n\t\t\t\tblue >>= 12;\n\n\t\t\t\tpal = red & 0x0f00;\n\t\t\t\tpal |= green & 0x00f0;\n\t\t\t\tpal |= blue & 0x000f;\n\t\t\t}\n\t\t\tif (regno == 0)\n\t\t\t\tpal |= 0x2000;\n\t\t\tpalette[regno] = pal;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\tred >>= 4;\n\t\t\tgreen >>= 8;\n\t\t\tblue >>= 12;\n\n\t\t\tpal = (red & 0x0f00);\n\t\t\tpal |= (green & 0x00f0);\n\t\t\tpal |= (blue & 0x000f);\n\n\t\t\tif (palette[regno] != pal) {\n\t\t\t\tupdate_hw = 1;\n\t\t\t\tpalette[regno] = pal;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\tu32 v;\n\n\t\tif (regno > 15)\n\t\t\treturn -EINVAL;\n\n\t\tv = (red << info->var.red.offset) |\n\t\t\t(green << info->var.green.offset) |\n\t\t\t(blue << info->var.blue.offset);\n\n\t\t((u32 *) (info->pseudo_palette))[regno] = v;\n\t\tif (palette[0] != 0x4000) {\n\t\t\tupdate_hw = 1;\n\t\t\tpalette[0] = 0x4000;\n\t\t}\n\t}\n\n\t \n\tif (update_hw)\n\t\tlcd_blit(LOAD_PALETTE, par);\n\n\treturn 0;\n}\n#undef CNVT_TOHW\n\nstatic void da8xx_fb_lcd_reset(void)\n{\n\t \n\tlcdc_write(0, LCD_DMA_CTRL_REG);\n\tlcdc_write(0, LCD_RASTER_CTRL_REG);\n\n\tif (lcd_revision == LCD_VERSION_2) {\n\t\tlcdc_write(0, LCD_INT_ENABLE_SET_REG);\n\t\t \n\t\tlcdc_write(LCD_CLK_MAIN_RESET, LCD_CLK_RESET_REG);\n\t\tlcdc_write(0, LCD_CLK_RESET_REG);\n\t}\n}\n\nstatic int da8xx_fb_config_clk_divider(struct da8xx_fb_par *par,\n\t\t\t\t\t      unsigned lcdc_clk_div,\n\t\t\t\t\t      unsigned lcdc_clk_rate)\n{\n\tint ret;\n\n\tif (par->lcdc_clk_rate != lcdc_clk_rate) {\n\t\tret = clk_set_rate(par->lcdc_clk, lcdc_clk_rate);\n\t\tif (ret) {\n\t\t\tdev_err(par->dev,\n\t\t\t\t\"unable to set clock rate at %u\\n\",\n\t\t\t\tlcdc_clk_rate);\n\t\t\treturn ret;\n\t\t}\n\t\tpar->lcdc_clk_rate = clk_get_rate(par->lcdc_clk);\n\t}\n\n\t \n\tlcdc_write(LCD_CLK_DIVISOR(lcdc_clk_div) |\n\t\t\t(LCD_RASTER_MODE & 0x1), LCD_CTRL_REG);\n\n\tif (lcd_revision == LCD_VERSION_2)\n\t\tlcdc_write(LCD_V2_DMA_CLK_EN | LCD_V2_LIDD_CLK_EN |\n\t\t\t\tLCD_V2_CORE_CLK_EN, LCD_CLK_ENABLE_REG);\n\n\treturn 0;\n}\n\nstatic unsigned int da8xx_fb_calc_clk_divider(struct da8xx_fb_par *par,\n\t\t\t\t\t      unsigned pixclock,\n\t\t\t\t\t      unsigned *lcdc_clk_rate)\n{\n\tunsigned lcdc_clk_div;\n\n\tpixclock = PICOS2KHZ(pixclock) * 1000;\n\n\t*lcdc_clk_rate = par->lcdc_clk_rate;\n\n\tif (pixclock < (*lcdc_clk_rate / CLK_MAX_DIV)) {\n\t\t*lcdc_clk_rate = clk_round_rate(par->lcdc_clk,\n\t\t\t\t\t\tpixclock * CLK_MAX_DIV);\n\t\tlcdc_clk_div = CLK_MAX_DIV;\n\t} else if (pixclock > (*lcdc_clk_rate / CLK_MIN_DIV)) {\n\t\t*lcdc_clk_rate = clk_round_rate(par->lcdc_clk,\n\t\t\t\t\t\tpixclock * CLK_MIN_DIV);\n\t\tlcdc_clk_div = CLK_MIN_DIV;\n\t} else {\n\t\tlcdc_clk_div = *lcdc_clk_rate / pixclock;\n\t}\n\n\treturn lcdc_clk_div;\n}\n\nstatic int da8xx_fb_calc_config_clk_divider(struct da8xx_fb_par *par,\n\t\t\t\t\t    struct fb_videomode *mode)\n{\n\tunsigned lcdc_clk_rate;\n\tunsigned lcdc_clk_div = da8xx_fb_calc_clk_divider(par, mode->pixclock,\n\t\t\t\t\t\t\t  &lcdc_clk_rate);\n\n\treturn da8xx_fb_config_clk_divider(par, lcdc_clk_div, lcdc_clk_rate);\n}\n\nstatic unsigned da8xx_fb_round_clk(struct da8xx_fb_par *par,\n\t\t\t\t\t  unsigned pixclock)\n{\n\tunsigned lcdc_clk_div, lcdc_clk_rate;\n\n\tlcdc_clk_div = da8xx_fb_calc_clk_divider(par, pixclock, &lcdc_clk_rate);\n\treturn KHZ2PICOS(lcdc_clk_rate / (1000 * lcdc_clk_div));\n}\n\nstatic int lcd_init(struct da8xx_fb_par *par, const struct lcd_ctrl_config *cfg,\n\t\tstruct fb_videomode *panel)\n{\n\tu32 bpp;\n\tint ret = 0;\n\n\tret = da8xx_fb_calc_config_clk_divider(par, panel);\n\tif (ret) {\n\t\tdev_err(par->dev, \"unable to configure clock\\n\");\n\t\treturn ret;\n\t}\n\n\tif (panel->sync & FB_SYNC_CLK_INVERT)\n\t\tlcdc_write((lcdc_read(LCD_RASTER_TIMING_2_REG) |\n\t\t\tLCD_INVERT_PIXEL_CLOCK), LCD_RASTER_TIMING_2_REG);\n\telse\n\t\tlcdc_write((lcdc_read(LCD_RASTER_TIMING_2_REG) &\n\t\t\t~LCD_INVERT_PIXEL_CLOCK), LCD_RASTER_TIMING_2_REG);\n\n\t \n\tret = lcd_cfg_dma(cfg->dma_burst_sz, cfg->fifo_th);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tlcd_cfg_vertical_sync(panel->upper_margin, panel->vsync_len,\n\t\t\tpanel->lower_margin);\n\tlcd_cfg_horizontal_sync(panel->left_margin, panel->hsync_len,\n\t\t\tpanel->right_margin);\n\n\t \n\tret = lcd_cfg_display(cfg, panel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbpp = cfg->bpp;\n\n\tif (bpp == 12)\n\t\tbpp = 16;\n\tret = lcd_cfg_frame_buffer(par, (unsigned int)panel->xres,\n\t\t\t\t(unsigned int)panel->yres, bpp,\n\t\t\t\tcfg->raster_order);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tlcdc_write((lcdc_read(LCD_RASTER_CTRL_REG) & 0xfff00fff) |\n\t\t       (cfg->fdd << 12), LCD_RASTER_CTRL_REG);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t lcdc_irq_handler_rev02(int irq, void *arg)\n{\n\tstruct da8xx_fb_par *par = arg;\n\tu32 stat = lcdc_read(LCD_MASKED_STAT_REG);\n\n\tif ((stat & LCD_SYNC_LOST) && (stat & LCD_FIFO_UNDERFLOW)) {\n\t\tlcd_disable_raster(DA8XX_FRAME_NOWAIT);\n\t\tlcdc_write(stat, LCD_MASKED_STAT_REG);\n\t\tlcd_enable_raster();\n\t} else if (stat & LCD_PL_LOAD_DONE) {\n\t\t \n\t\tlcd_disable_raster(DA8XX_FRAME_NOWAIT);\n\n\t\tlcdc_write(stat, LCD_MASKED_STAT_REG);\n\n\t\t \n\t\tlcdc_write(LCD_V2_PL_INT_ENA, LCD_INT_ENABLE_CLR_REG);\n\n\t\t \n\t\tlcd_blit(LOAD_DATA, par);\n\t} else {\n\t\tlcdc_write(stat, LCD_MASKED_STAT_REG);\n\n\t\tif (stat & LCD_END_OF_FRAME0) {\n\t\t\tpar->which_dma_channel_done = 0;\n\t\t\tlcdc_write(par->dma_start,\n\t\t\t\t   LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\n\t\t\tlcdc_write(par->dma_end,\n\t\t\t\t   LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\n\t\t\tpar->vsync_flag = 1;\n\t\t\twake_up_interruptible(&par->vsync_wait);\n\t\t}\n\n\t\tif (stat & LCD_END_OF_FRAME1) {\n\t\t\tpar->which_dma_channel_done = 1;\n\t\t\tlcdc_write(par->dma_start,\n\t\t\t\t   LCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\n\t\t\tlcdc_write(par->dma_end,\n\t\t\t\t   LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\n\t\t\tpar->vsync_flag = 1;\n\t\t\twake_up_interruptible(&par->vsync_wait);\n\t\t}\n\n\t\t \n\t\tif (stat & BIT(0)) {\n\t\t\tframe_done_flag = 1;\n\t\t\twake_up_interruptible(&frame_done_wq);\n\t\t}\n\t}\n\n\tlcdc_write(0, LCD_END_OF_INT_IND_REG);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t lcdc_irq_handler_rev01(int irq, void *arg)\n{\n\tstruct da8xx_fb_par *par = arg;\n\tu32 stat = lcdc_read(LCD_STAT_REG);\n\tu32 reg_ras;\n\n\tif ((stat & LCD_SYNC_LOST) && (stat & LCD_FIFO_UNDERFLOW)) {\n\t\tlcd_disable_raster(DA8XX_FRAME_NOWAIT);\n\t\tlcdc_write(stat, LCD_STAT_REG);\n\t\tlcd_enable_raster();\n\t} else if (stat & LCD_PL_LOAD_DONE) {\n\t\t \n\t\tlcd_disable_raster(DA8XX_FRAME_NOWAIT);\n\n\t\tlcdc_write(stat, LCD_STAT_REG);\n\n\t\t \n\t\treg_ras  = lcdc_read(LCD_RASTER_CTRL_REG);\n\t\treg_ras &= ~LCD_V1_PL_INT_ENA;\n\t\tlcdc_write(reg_ras, LCD_RASTER_CTRL_REG);\n\n\t\t \n\t\tlcd_blit(LOAD_DATA, par);\n\t} else {\n\t\tlcdc_write(stat, LCD_STAT_REG);\n\n\t\tif (stat & LCD_END_OF_FRAME0) {\n\t\t\tpar->which_dma_channel_done = 0;\n\t\t\tlcdc_write(par->dma_start,\n\t\t\t\t   LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\n\t\t\tlcdc_write(par->dma_end,\n\t\t\t\t   LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\n\t\t\tpar->vsync_flag = 1;\n\t\t\twake_up_interruptible(&par->vsync_wait);\n\t\t}\n\n\t\tif (stat & LCD_END_OF_FRAME1) {\n\t\t\tpar->which_dma_channel_done = 1;\n\t\t\tlcdc_write(par->dma_start,\n\t\t\t\t   LCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\n\t\t\tlcdc_write(par->dma_end,\n\t\t\t\t   LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\n\t\t\tpar->vsync_flag = 1;\n\t\t\twake_up_interruptible(&par->vsync_wait);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fb_check_var(struct fb_var_screeninfo *var,\n\t\t\tstruct fb_info *info)\n{\n\tint err = 0;\n\tstruct da8xx_fb_par *par = info->par;\n\tint bpp = var->bits_per_pixel >> 3;\n\tunsigned long line_size = var->xres_virtual * bpp;\n\n\tif (var->bits_per_pixel > 16 && lcd_revision == LCD_VERSION_1)\n\t\treturn -EINVAL;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 1:\n\tcase 8:\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tvar->nonstd = 0;\n\t\tbreak;\n\tcase 4:\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 4;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 4;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 4;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tvar->nonstd = FB_NONSTD_REV_PIX_IN_B;\n\t\tbreak;\n\tcase 16:\t\t \n\t\tvar->red.offset = 11;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tvar->nonstd = 0;\n\t\tbreak;\n\tcase 24:\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->nonstd = 0;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->nonstd = 0;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.msb_right = 0;\n\tvar->transp.msb_right = 0;\n\n\tif (line_size * var->yres_virtual > par->vram_size)\n\t\tvar->yres_virtual = par->vram_size / line_size;\n\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres = var->yres_virtual;\n\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres = var->xres_virtual;\n\n\tif (var->xres + var->xoffset > var->xres_virtual)\n\t\tvar->xoffset = var->xres_virtual - var->xres;\n\tif (var->yres + var->yoffset > var->yres_virtual)\n\t\tvar->yoffset = var->yres_virtual - var->yres;\n\n\tvar->pixclock = da8xx_fb_round_clk(par, var->pixclock);\n\n\treturn err;\n}\n\n#ifdef CONFIG_CPU_FREQ\nstatic int lcd_da8xx_cpufreq_transition(struct notifier_block *nb,\n\t\t\t\t     unsigned long val, void *data)\n{\n\tstruct da8xx_fb_par *par;\n\n\tpar = container_of(nb, struct da8xx_fb_par, freq_transition);\n\tif (val == CPUFREQ_POSTCHANGE) {\n\t\tif (par->lcdc_clk_rate != clk_get_rate(par->lcdc_clk)) {\n\t\t\tpar->lcdc_clk_rate = clk_get_rate(par->lcdc_clk);\n\t\t\tlcd_disable_raster(DA8XX_FRAME_WAIT);\n\t\t\tda8xx_fb_calc_config_clk_divider(par, &par->mode);\n\t\t\tif (par->blank == FB_BLANK_UNBLANK)\n\t\t\t\tlcd_enable_raster();\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lcd_da8xx_cpufreq_register(struct da8xx_fb_par *par)\n{\n\tpar->freq_transition.notifier_call = lcd_da8xx_cpufreq_transition;\n\n\treturn cpufreq_register_notifier(&par->freq_transition,\n\t\t\t\t\t CPUFREQ_TRANSITION_NOTIFIER);\n}\n\nstatic void lcd_da8xx_cpufreq_deregister(struct da8xx_fb_par *par)\n{\n\tcpufreq_unregister_notifier(&par->freq_transition,\n\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n}\n#endif\n\nstatic void fb_remove(struct platform_device *dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\tstruct da8xx_fb_par *par = info->par;\n\tint ret;\n\n#ifdef CONFIG_CPU_FREQ\n\tlcd_da8xx_cpufreq_deregister(par);\n#endif\n\tif (par->lcd_supply) {\n\t\tret = regulator_disable(par->lcd_supply);\n\t\tif (ret)\n\t\t\tdev_warn(&dev->dev, \"Failed to disable regulator (%pe)\\n\",\n\t\t\t\t ERR_PTR(ret));\n\t}\n\n\tlcd_disable_raster(DA8XX_FRAME_WAIT);\n\tlcdc_write(0, LCD_RASTER_CTRL_REG);\n\n\t \n\tlcdc_write(0, LCD_DMA_CTRL_REG);\n\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\tpm_runtime_put_sync(&dev->dev);\n\tpm_runtime_disable(&dev->dev);\n\tframebuffer_release(info);\n}\n\n \nstatic int fb_wait_for_vsync(struct fb_info *info)\n{\n\tstruct da8xx_fb_par *par = info->par;\n\tint ret;\n\n\t \n\tpar->vsync_flag = 0;\n\tret = wait_event_interruptible_timeout(par->vsync_wait,\n\t\t\t\t\t       par->vsync_flag != 0,\n\t\t\t\t\t       par->vsync_timeout);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int fb_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct lcd_sync_arg sync_arg;\n\n\tswitch (cmd) {\n\tcase FBIOGET_CONTRAST:\n\tcase FBIOPUT_CONTRAST:\n\tcase FBIGET_BRIGHTNESS:\n\tcase FBIPUT_BRIGHTNESS:\n\tcase FBIGET_COLOR:\n\tcase FBIPUT_COLOR:\n\t\treturn -ENOTTY;\n\tcase FBIPUT_HSYNC:\n\t\tif (copy_from_user(&sync_arg, (char *)arg,\n\t\t\t\tsizeof(struct lcd_sync_arg)))\n\t\t\treturn -EFAULT;\n\t\tlcd_cfg_horizontal_sync(sync_arg.back_porch,\n\t\t\t\t\tsync_arg.pulse_width,\n\t\t\t\t\tsync_arg.front_porch);\n\t\tbreak;\n\tcase FBIPUT_VSYNC:\n\t\tif (copy_from_user(&sync_arg, (char *)arg,\n\t\t\t\tsizeof(struct lcd_sync_arg)))\n\t\t\treturn -EFAULT;\n\t\tlcd_cfg_vertical_sync(sync_arg.back_porch,\n\t\t\t\t\tsync_arg.pulse_width,\n\t\t\t\t\tsync_arg.front_porch);\n\t\tbreak;\n\tcase FBIO_WAITFORVSYNC:\n\t\treturn fb_wait_for_vsync(info);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cfb_blank(int blank, struct fb_info *info)\n{\n\tstruct da8xx_fb_par *par = info->par;\n\tint ret = 0;\n\n\tif (par->blank == blank)\n\t\treturn 0;\n\n\tpar->blank = blank;\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\n\t\tlcd_enable_raster();\n\n\t\tif (par->lcd_supply) {\n\t\t\tret = regulator_enable(par->lcd_supply);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_POWERDOWN:\n\t\tif (par->lcd_supply) {\n\t\t\tret = regulator_disable(par->lcd_supply);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tlcd_disable_raster(DA8XX_FRAME_WAIT);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int da8xx_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *fbi)\n{\n\tint ret = 0;\n\tstruct fb_var_screeninfo new_var;\n\tstruct da8xx_fb_par         *par = fbi->par;\n\tstruct fb_fix_screeninfo    *fix = &fbi->fix;\n\tunsigned int end;\n\tunsigned int start;\n\tunsigned long irq_flags;\n\n\tif (var->xoffset != fbi->var.xoffset ||\n\t\t\tvar->yoffset != fbi->var.yoffset) {\n\t\tmemcpy(&new_var, &fbi->var, sizeof(new_var));\n\t\tnew_var.xoffset = var->xoffset;\n\t\tnew_var.yoffset = var->yoffset;\n\t\tif (fb_check_var(&new_var, fbi))\n\t\t\tret = -EINVAL;\n\t\telse {\n\t\t\tmemcpy(&fbi->var, &new_var, sizeof(new_var));\n\n\t\t\tstart\t= fix->smem_start +\n\t\t\t\tnew_var.yoffset * fix->line_length +\n\t\t\t\tnew_var.xoffset * fbi->var.bits_per_pixel / 8;\n\t\t\tend\t= start + fbi->var.yres * fix->line_length - 1;\n\t\t\tpar->dma_start\t= start;\n\t\t\tpar->dma_end\t= end;\n\t\t\tspin_lock_irqsave(&par->lock_for_chan_update,\n\t\t\t\t\tirq_flags);\n\t\t\tif (par->which_dma_channel_done == 0) {\n\t\t\t\tlcdc_write(par->dma_start,\n\t\t\t\t\t   LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\n\t\t\t\tlcdc_write(par->dma_end,\n\t\t\t\t\t   LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\n\t\t\t} else if (par->which_dma_channel_done == 1) {\n\t\t\t\tlcdc_write(par->dma_start,\n\t\t\t\t\t   LCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\n\t\t\t\tlcdc_write(par->dma_end,\n\t\t\t\t\t   LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&par->lock_for_chan_update,\n\t\t\t\t\tirq_flags);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int da8xxfb_set_par(struct fb_info *info)\n{\n\tstruct da8xx_fb_par *par = info->par;\n\tint ret;\n\tbool raster = da8xx_fb_is_raster_enabled();\n\n\tif (raster)\n\t\tlcd_disable_raster(DA8XX_FRAME_WAIT);\n\n\tfb_var_to_videomode(&par->mode, &info->var);\n\n\tpar->cfg.bpp = info->var.bits_per_pixel;\n\n\tinfo->fix.visual = (par->cfg.bpp <= 8) ?\n\t\t\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\tinfo->fix.line_length = (par->mode.xres * par->cfg.bpp) / 8;\n\n\tret = lcd_init(par, &par->cfg, &par->mode);\n\tif (ret < 0) {\n\t\tdev_err(par->dev, \"lcd init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpar->dma_start = info->fix.smem_start +\n\t\t\t info->var.yoffset * info->fix.line_length +\n\t\t\t info->var.xoffset * info->var.bits_per_pixel / 8;\n\tpar->dma_end   = par->dma_start +\n\t\t\t info->var.yres * info->fix.line_length - 1;\n\n\tlcdc_write(par->dma_start, LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\n\tlcdc_write(par->dma_end, LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\n\tlcdc_write(par->dma_start, LCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\n\tlcdc_write(par->dma_end, LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\n\n\tif (raster)\n\t\tlcd_enable_raster();\n\n\treturn 0;\n}\n\nstatic const struct fb_ops da8xx_fb_ops = {\n\t.owner = THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var = fb_check_var,\n\t.fb_set_par = da8xxfb_set_par,\n\t.fb_setcolreg = fb_setcolreg,\n\t.fb_pan_display = da8xx_pan_display,\n\t.fb_ioctl = fb_ioctl,\n\t.fb_blank = cfb_blank,\n};\n\nstatic struct fb_videomode *da8xx_fb_get_videomode(struct platform_device *dev)\n{\n\tstruct da8xx_lcdc_platform_data *fb_pdata = dev_get_platdata(&dev->dev);\n\tstruct fb_videomode *lcdc_info;\n\tint i;\n\n\tfor (i = 0, lcdc_info = known_lcd_panels;\n\t\ti < ARRAY_SIZE(known_lcd_panels); i++, lcdc_info++) {\n\t\tif (strcmp(fb_pdata->type, lcdc_info->name) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(known_lcd_panels)) {\n\t\tdev_err(&dev->dev, \"no panel found\\n\");\n\t\treturn NULL;\n\t}\n\tdev_info(&dev->dev, \"found %s panel\\n\", lcdc_info->name);\n\n\treturn lcdc_info;\n}\n\nstatic int fb_probe(struct platform_device *device)\n{\n\tstruct da8xx_lcdc_platform_data *fb_pdata =\n\t\t\t\t\t\tdev_get_platdata(&device->dev);\n\tstruct lcd_ctrl_config *lcd_cfg;\n\tstruct fb_videomode *lcdc_info;\n\tstruct fb_info *da8xx_fb_info;\n\tstruct da8xx_fb_par *par;\n\tstruct clk *tmp_lcdc_clk;\n\tint ret;\n\tunsigned long ulcm;\n\n\tif (fb_pdata == NULL) {\n\t\tdev_err(&device->dev, \"Can not get platform data\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tlcdc_info = da8xx_fb_get_videomode(device);\n\tif (lcdc_info == NULL)\n\t\treturn -ENODEV;\n\n\tda8xx_fb_reg_base = devm_platform_ioremap_resource(device, 0);\n\tif (IS_ERR(da8xx_fb_reg_base))\n\t\treturn PTR_ERR(da8xx_fb_reg_base);\n\n\ttmp_lcdc_clk = devm_clk_get(&device->dev, \"fck\");\n\tif (IS_ERR(tmp_lcdc_clk))\n\t\treturn dev_err_probe(&device->dev, PTR_ERR(tmp_lcdc_clk),\n\t\t\t\t     \"Can not get device clock\\n\");\n\n\tpm_runtime_enable(&device->dev);\n\tpm_runtime_get_sync(&device->dev);\n\n\t \n\tswitch (lcdc_read(LCD_PID_REG)) {\n\tcase 0x4C100102:\n\t\tlcd_revision = LCD_VERSION_1;\n\t\tbreak;\n\tcase 0x4F200800:\n\tcase 0x4F201000:\n\t\tlcd_revision = LCD_VERSION_2;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&device->dev, \"Unknown PID Reg value 0x%x, \"\n\t\t\t\t\"defaulting to LCD revision 1\\n\",\n\t\t\t\tlcdc_read(LCD_PID_REG));\n\t\tlcd_revision = LCD_VERSION_1;\n\t\tbreak;\n\t}\n\n\tlcd_cfg = (struct lcd_ctrl_config *)fb_pdata->controller_data;\n\n\tif (!lcd_cfg) {\n\t\tret = -EINVAL;\n\t\tgoto err_pm_runtime_disable;\n\t}\n\n\tda8xx_fb_info = framebuffer_alloc(sizeof(struct da8xx_fb_par),\n\t\t\t\t\t&device->dev);\n\tif (!da8xx_fb_info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pm_runtime_disable;\n\t}\n\n\tpar = da8xx_fb_info->par;\n\tpar->dev = &device->dev;\n\tpar->lcdc_clk = tmp_lcdc_clk;\n\tpar->lcdc_clk_rate = clk_get_rate(par->lcdc_clk);\n\n\tpar->lcd_supply = devm_regulator_get_optional(&device->dev, \"lcd\");\n\tif (IS_ERR(par->lcd_supply)) {\n\t\tif (PTR_ERR(par->lcd_supply) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto err_release_fb;\n\t\t}\n\n\t\tpar->lcd_supply = NULL;\n\t} else {\n\t\tret = regulator_enable(par->lcd_supply);\n\t\tif (ret)\n\t\t\tgoto err_release_fb;\n\t}\n\n\tfb_videomode_to_var(&da8xx_fb_var, lcdc_info);\n\tpar->cfg = *lcd_cfg;\n\n\tda8xx_fb_lcd_reset();\n\n\t \n\tpar->vram_size = lcdc_info->xres * lcdc_info->yres * lcd_cfg->bpp;\n\tulcm = lcm((lcdc_info->xres * lcd_cfg->bpp)/8, PAGE_SIZE);\n\tpar->vram_size = roundup(par->vram_size/8, ulcm);\n\tpar->vram_size = par->vram_size * LCD_NUM_BUFFERS;\n\n\tpar->vram_virt = dmam_alloc_coherent(par->dev,\n\t\t\t\t\t     par->vram_size,\n\t\t\t\t\t     &par->vram_phys,\n\t\t\t\t\t     GFP_KERNEL | GFP_DMA);\n\tif (!par->vram_virt) {\n\t\tdev_err(&device->dev,\n\t\t\t\"GLCD: kmalloc for frame buffer failed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_disable_reg;\n\t}\n\n\tda8xx_fb_info->screen_base = (char __iomem *) par->vram_virt;\n\tda8xx_fb_fix.smem_start    = par->vram_phys;\n\tda8xx_fb_fix.smem_len      = par->vram_size;\n\tda8xx_fb_fix.line_length   = (lcdc_info->xres * lcd_cfg->bpp) / 8;\n\n\tpar->dma_start = par->vram_phys;\n\tpar->dma_end   = par->dma_start + lcdc_info->yres *\n\t\tda8xx_fb_fix.line_length - 1;\n\n\t \n\tpar->v_palette_base = dmam_alloc_coherent(par->dev, PALETTE_SIZE,\n\t\t\t\t\t\t  &par->p_palette_base,\n\t\t\t\t\t\t  GFP_KERNEL | GFP_DMA);\n\tif (!par->v_palette_base) {\n\t\tdev_err(&device->dev,\n\t\t\t\"GLCD: kmalloc for palette buffer failed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_release_fb;\n\t}\n\n\tpar->irq = platform_get_irq(device, 0);\n\tif (par->irq < 0) {\n\t\tret = -ENOENT;\n\t\tgoto err_release_fb;\n\t}\n\n\tda8xx_fb_var.grayscale =\n\t    lcd_cfg->panel_shade == MONOCHROME ? 1 : 0;\n\tda8xx_fb_var.bits_per_pixel = lcd_cfg->bpp;\n\n\t \n\tda8xx_fb_info->fix = da8xx_fb_fix;\n\tda8xx_fb_info->var = da8xx_fb_var;\n\tda8xx_fb_info->fbops = &da8xx_fb_ops;\n\tda8xx_fb_info->pseudo_palette = par->pseudo_palette;\n\tda8xx_fb_info->fix.visual = (da8xx_fb_info->var.bits_per_pixel <= 8) ?\n\t\t\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\n\tret = fb_alloc_cmap(&da8xx_fb_info->cmap, PALETTE_SIZE, 0);\n\tif (ret)\n\t\tgoto err_disable_reg;\n\tda8xx_fb_info->cmap.len = par->palette_sz;\n\n\t \n\tda8xx_fb_var.activate = FB_ACTIVATE_FORCE;\n\tfb_set_var(da8xx_fb_info, &da8xx_fb_var);\n\n\tplatform_set_drvdata(device, da8xx_fb_info);\n\n\t \n\tinit_waitqueue_head(&par->vsync_wait);\n\tpar->vsync_timeout = HZ / 5;\n\tpar->which_dma_channel_done = -1;\n\tspin_lock_init(&par->lock_for_chan_update);\n\n\t \n\tif (register_framebuffer(da8xx_fb_info) < 0) {\n\t\tdev_err(&device->dev,\n\t\t\t\"GLCD: Frame Buffer Registration Failed!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_dealloc_cmap;\n\t}\n\n#ifdef CONFIG_CPU_FREQ\n\tret = lcd_da8xx_cpufreq_register(par);\n\tif (ret) {\n\t\tdev_err(&device->dev, \"failed to register cpufreq\\n\");\n\t\tgoto err_cpu_freq;\n\t}\n#endif\n\n\tif (lcd_revision == LCD_VERSION_1)\n\t\tlcdc_irq_handler = lcdc_irq_handler_rev01;\n\telse {\n\t\tinit_waitqueue_head(&frame_done_wq);\n\t\tlcdc_irq_handler = lcdc_irq_handler_rev02;\n\t}\n\n\tret = devm_request_irq(&device->dev, par->irq, lcdc_irq_handler, 0,\n\t\t\t       DRIVER_NAME, par);\n\tif (ret)\n\t\tgoto irq_freq;\n\treturn 0;\n\nirq_freq:\n#ifdef CONFIG_CPU_FREQ\n\tlcd_da8xx_cpufreq_deregister(par);\nerr_cpu_freq:\n#endif\n\tunregister_framebuffer(da8xx_fb_info);\n\nerr_dealloc_cmap:\n\tfb_dealloc_cmap(&da8xx_fb_info->cmap);\n\nerr_disable_reg:\n\tif (par->lcd_supply)\n\t\tregulator_disable(par->lcd_supply);\nerr_release_fb:\n\tframebuffer_release(da8xx_fb_info);\n\nerr_pm_runtime_disable:\n\tpm_runtime_put_sync(&device->dev);\n\tpm_runtime_disable(&device->dev);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic struct lcdc_context {\n\tu32 clk_enable;\n\tu32 ctrl;\n\tu32 dma_ctrl;\n\tu32 raster_timing_0;\n\tu32 raster_timing_1;\n\tu32 raster_timing_2;\n\tu32 int_enable_set;\n\tu32 dma_frm_buf_base_addr_0;\n\tu32 dma_frm_buf_ceiling_addr_0;\n\tu32 dma_frm_buf_base_addr_1;\n\tu32 dma_frm_buf_ceiling_addr_1;\n\tu32 raster_ctrl;\n} reg_context;\n\nstatic void lcd_context_save(void)\n{\n\tif (lcd_revision == LCD_VERSION_2) {\n\t\treg_context.clk_enable = lcdc_read(LCD_CLK_ENABLE_REG);\n\t\treg_context.int_enable_set = lcdc_read(LCD_INT_ENABLE_SET_REG);\n\t}\n\n\treg_context.ctrl = lcdc_read(LCD_CTRL_REG);\n\treg_context.dma_ctrl = lcdc_read(LCD_DMA_CTRL_REG);\n\treg_context.raster_timing_0 = lcdc_read(LCD_RASTER_TIMING_0_REG);\n\treg_context.raster_timing_1 = lcdc_read(LCD_RASTER_TIMING_1_REG);\n\treg_context.raster_timing_2 = lcdc_read(LCD_RASTER_TIMING_2_REG);\n\treg_context.dma_frm_buf_base_addr_0 =\n\t\tlcdc_read(LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\n\treg_context.dma_frm_buf_ceiling_addr_0 =\n\t\tlcdc_read(LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\n\treg_context.dma_frm_buf_base_addr_1 =\n\t\tlcdc_read(LCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\n\treg_context.dma_frm_buf_ceiling_addr_1 =\n\t\tlcdc_read(LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\n\treg_context.raster_ctrl = lcdc_read(LCD_RASTER_CTRL_REG);\n\treturn;\n}\n\nstatic void lcd_context_restore(void)\n{\n\tif (lcd_revision == LCD_VERSION_2) {\n\t\tlcdc_write(reg_context.clk_enable, LCD_CLK_ENABLE_REG);\n\t\tlcdc_write(reg_context.int_enable_set, LCD_INT_ENABLE_SET_REG);\n\t}\n\n\tlcdc_write(reg_context.ctrl, LCD_CTRL_REG);\n\tlcdc_write(reg_context.dma_ctrl, LCD_DMA_CTRL_REG);\n\tlcdc_write(reg_context.raster_timing_0, LCD_RASTER_TIMING_0_REG);\n\tlcdc_write(reg_context.raster_timing_1, LCD_RASTER_TIMING_1_REG);\n\tlcdc_write(reg_context.raster_timing_2, LCD_RASTER_TIMING_2_REG);\n\tlcdc_write(reg_context.dma_frm_buf_base_addr_0,\n\t\t\tLCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\n\tlcdc_write(reg_context.dma_frm_buf_ceiling_addr_0,\n\t\t\tLCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\n\tlcdc_write(reg_context.dma_frm_buf_base_addr_1,\n\t\t\tLCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\n\tlcdc_write(reg_context.dma_frm_buf_ceiling_addr_1,\n\t\t\tLCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\n\tlcdc_write(reg_context.raster_ctrl, LCD_RASTER_CTRL_REG);\n\treturn;\n}\n\nstatic int fb_suspend(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct da8xx_fb_par *par = info->par;\n\tint ret;\n\n\tconsole_lock();\n\tif (par->lcd_supply) {\n\t\tret = regulator_disable(par->lcd_supply);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfb_set_suspend(info, 1);\n\tlcd_disable_raster(DA8XX_FRAME_WAIT);\n\tlcd_context_save();\n\tpm_runtime_put_sync(dev);\n\tconsole_unlock();\n\n\treturn 0;\n}\nstatic int fb_resume(struct device *dev)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct da8xx_fb_par *par = info->par;\n\tint ret;\n\n\tconsole_lock();\n\tpm_runtime_get_sync(dev);\n\tlcd_context_restore();\n\tif (par->blank == FB_BLANK_UNBLANK) {\n\t\tlcd_enable_raster();\n\n\t\tif (par->lcd_supply) {\n\t\t\tret = regulator_enable(par->lcd_supply);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfb_set_suspend(info, 0);\n\tconsole_unlock();\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(fb_pm_ops, fb_suspend, fb_resume);\n\nstatic struct platform_driver da8xx_fb_driver = {\n\t.probe = fb_probe,\n\t.remove_new = fb_remove,\n\t.driver = {\n\t\t   .name = DRIVER_NAME,\n\t\t   .pm\t= &fb_pm_ops,\n\t\t   },\n};\nmodule_platform_driver(da8xx_fb_driver);\n\nMODULE_DESCRIPTION(\"Framebuffer driver for TI da8xx/omap-l1xx\");\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}