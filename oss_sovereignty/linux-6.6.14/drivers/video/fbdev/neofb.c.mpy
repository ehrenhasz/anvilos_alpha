{
  "module_name": "neofb.c",
  "hash_id": "436a26e07812cd205167d756bc07f8df20e5d7ebdfa492829ce8662987f8de27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/neofb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#ifdef CONFIG_TOSHIBA\n#include <linux/toshiba.h>\n#endif\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <video/vga.h>\n#include <video/neomagic.h>\n\n#define NEOFB_VERSION \"0.4.2\"\n\n \n\nstatic bool internal;\nstatic bool external;\nstatic bool libretto;\nstatic bool nostretch;\nstatic bool nopciburst;\nstatic char *mode_option = NULL;\n\n#ifdef MODULE\n\nMODULE_AUTHOR(\"(c) 2001-2002  Denis Oliver Kropp <dok@convergence.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"FBDev driver for NeoMagic PCI Chips\");\nmodule_param(internal, bool, 0);\nMODULE_PARM_DESC(internal, \"Enable output on internal LCD Display.\");\nmodule_param(external, bool, 0);\nMODULE_PARM_DESC(external, \"Enable output on external CRT.\");\nmodule_param(libretto, bool, 0);\nMODULE_PARM_DESC(libretto, \"Force Libretto 100/110 800x480 LCD.\");\nmodule_param(nostretch, bool, 0);\nMODULE_PARM_DESC(nostretch,\n\t\t \"Disable stretching of modes smaller than LCD.\");\nmodule_param(nopciburst, bool, 0);\nMODULE_PARM_DESC(nopciburst, \"Disable PCI burst mode.\");\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Preferred video mode ('640x480-8@60', etc)\");\n\n#endif\n\n\n \n\nstatic biosMode bios8[] = {\n\t{320, 240, 0x40},\n\t{300, 400, 0x42},\n\t{640, 400, 0x20},\n\t{640, 480, 0x21},\n\t{800, 600, 0x23},\n\t{1024, 768, 0x25},\n};\n\nstatic biosMode bios16[] = {\n\t{320, 200, 0x2e},\n\t{320, 240, 0x41},\n\t{300, 400, 0x43},\n\t{640, 480, 0x31},\n\t{800, 600, 0x34},\n\t{1024, 768, 0x37},\n};\n\nstatic biosMode bios24[] = {\n\t{640, 480, 0x32},\n\t{800, 600, 0x35},\n\t{1024, 768, 0x38}\n};\n\n#ifdef NO_32BIT_SUPPORT_YET\n \nstatic biosMode bios32[] = {\n\t{640, 480, 0x33},\n\t{800, 600, 0x36},\n\t{1024, 768, 0x39}\n};\n#endif\n\nstatic inline void write_le32(int regindex, u32 val, const struct neofb_par *par)\n{\n\twritel(val, par->neo2200 + par->cursorOff + regindex);\n}\n\nstatic int neoFindMode(int xres, int yres, int depth)\n{\n\tint xres_s;\n\tint i, size;\n\tbiosMode *mode;\n\n\tswitch (depth) {\n\tcase 8:\n\t\tsize = ARRAY_SIZE(bios8);\n\t\tmode = bios8;\n\t\tbreak;\n\tcase 16:\n\t\tsize = ARRAY_SIZE(bios16);\n\t\tmode = bios16;\n\t\tbreak;\n\tcase 24:\n\t\tsize = ARRAY_SIZE(bios24);\n\t\tmode = bios24;\n\t\tbreak;\n#ifdef NO_32BIT_SUPPORT_YET\n\tcase 32:\n\t\tsize = ARRAY_SIZE(bios32);\n\t\tmode = bios32;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (xres <= mode[i].x_res) {\n\t\t\txres_s = mode[i].x_res;\n\t\t\tfor (; i < size; i++) {\n\t\t\t\tif (mode[i].x_res != xres_s)\n\t\t\t\t\treturn mode[i - 1].mode;\n\t\t\t\tif (yres <= mode[i].y_res)\n\t\t\t\t\treturn mode[i].mode;\n\t\t\t}\n\t\t}\n\t}\n\treturn mode[size - 1].mode;\n}\n\n \n#define MAX_N 127\n#define MAX_D 31\n#define MAX_F 1\n\nstatic void neoCalcVCLK(const struct fb_info *info,\n\t\t\tstruct neofb_par *par, long freq)\n{\n\tint n, d, f;\n\tint n_best = 0, d_best = 0, f_best = 0;\n\tlong f_best_diff = 0x7ffff;\n\n\tfor (f = 0; f <= MAX_F; f++)\n\t\tfor (d = 0; d <= MAX_D; d++)\n\t\t\tfor (n = 0; n <= MAX_N; n++) {\n\t\t\t\tlong f_out;\n\t\t\t\tlong f_diff;\n\n\t\t\t\tf_out = ((14318 * (n + 1)) / (d + 1)) >> f;\n\t\t\t\tf_diff = abs(f_out - freq);\n\t\t\t\tif (f_diff <= f_best_diff) {\n\t\t\t\t\tf_best_diff = f_diff;\n\t\t\t\t\tn_best = n;\n\t\t\t\t\td_best = d;\n\t\t\t\t\tf_best = f;\n\t\t\t\t}\n\t\t\t\tif (f_out > freq)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\tif (info->fix.accel == FB_ACCEL_NEOMAGIC_NM2200 ||\n\t    info->fix.accel == FB_ACCEL_NEOMAGIC_NM2230 ||\n\t    info->fix.accel == FB_ACCEL_NEOMAGIC_NM2360 ||\n\t    info->fix.accel == FB_ACCEL_NEOMAGIC_NM2380) {\n\t\t \n\t\tpar->VCLK3NumeratorLow = n_best;\n\t\tpar->VCLK3NumeratorHigh = (f_best << 7);\n\t} else\n\t\tpar->VCLK3NumeratorLow = n_best | (f_best << 7);\n\n\tpar->VCLK3Denominator = d_best;\n\n#ifdef NEOFB_DEBUG\n\tprintk(KERN_DEBUG \"neoVCLK: f:%ld NumLow=%d NumHi=%d Den=%d Df=%ld\\n\",\n\t       freq,\n\t       par->VCLK3NumeratorLow,\n\t       par->VCLK3NumeratorHigh,\n\t       par->VCLK3Denominator, f_best_diff);\n#endif\n}\n\n \n\nstatic int vgaHWInit(const struct fb_var_screeninfo *var,\n\t\t     struct neofb_par *par)\n{\n\tint hsync_end = var->xres + var->right_margin + var->hsync_len;\n\tint htotal = (hsync_end + var->left_margin) >> 3;\n\tint vsync_start = var->yres + var->lower_margin;\n\tint vsync_end = vsync_start + var->vsync_len;\n\tint vtotal = vsync_end + var->upper_margin;\n\n\tpar->MiscOutReg = 0x23;\n\n\tif (!(var->sync & FB_SYNC_HOR_HIGH_ACT))\n\t\tpar->MiscOutReg |= 0x40;\n\n\tif (!(var->sync & FB_SYNC_VERT_HIGH_ACT))\n\t\tpar->MiscOutReg |= 0x80;\n\n\t \n\tpar->Sequencer[0] = 0x00;\n\tpar->Sequencer[1] = 0x01;\n\tpar->Sequencer[2] = 0x0F;\n\tpar->Sequencer[3] = 0x00;\t \n\tpar->Sequencer[4] = 0x0E;\t \n\n\t \n\tpar->CRTC[0] = htotal - 5;\n\tpar->CRTC[1] = (var->xres >> 3) - 1;\n\tpar->CRTC[2] = (var->xres >> 3) - 1;\n\tpar->CRTC[3] = ((htotal - 1) & 0x1F) | 0x80;\n\tpar->CRTC[4] = ((var->xres + var->right_margin) >> 3);\n\tpar->CRTC[5] = (((htotal - 1) & 0x20) << 2)\n\t    | (((hsync_end >> 3)) & 0x1F);\n\tpar->CRTC[6] = (vtotal - 2) & 0xFF;\n\tpar->CRTC[7] = (((vtotal - 2) & 0x100) >> 8)\n\t    | (((var->yres - 1) & 0x100) >> 7)\n\t    | ((vsync_start & 0x100) >> 6)\n\t    | (((var->yres - 1) & 0x100) >> 5)\n\t    | 0x10 | (((vtotal - 2) & 0x200) >> 4)\n\t    | (((var->yres - 1) & 0x200) >> 3)\n\t    | ((vsync_start & 0x200) >> 2);\n\tpar->CRTC[8] = 0x00;\n\tpar->CRTC[9] = (((var->yres - 1) & 0x200) >> 4) | 0x40;\n\n\tif (var->vmode & FB_VMODE_DOUBLE)\n\t\tpar->CRTC[9] |= 0x80;\n\n\tpar->CRTC[10] = 0x00;\n\tpar->CRTC[11] = 0x00;\n\tpar->CRTC[12] = 0x00;\n\tpar->CRTC[13] = 0x00;\n\tpar->CRTC[14] = 0x00;\n\tpar->CRTC[15] = 0x00;\n\tpar->CRTC[16] = vsync_start & 0xFF;\n\tpar->CRTC[17] = (vsync_end & 0x0F) | 0x20;\n\tpar->CRTC[18] = (var->yres - 1) & 0xFF;\n\tpar->CRTC[19] = var->xres_virtual >> 4;\n\tpar->CRTC[20] = 0x00;\n\tpar->CRTC[21] = (var->yres - 1) & 0xFF;\n\tpar->CRTC[22] = (vtotal - 1) & 0xFF;\n\tpar->CRTC[23] = 0xC3;\n\tpar->CRTC[24] = 0xFF;\n\n\t \n\n\t \n\tpar->Graphics[0] = 0x00;\n\tpar->Graphics[1] = 0x00;\n\tpar->Graphics[2] = 0x00;\n\tpar->Graphics[3] = 0x00;\n\tpar->Graphics[4] = 0x00;\n\tpar->Graphics[5] = 0x40;\n\tpar->Graphics[6] = 0x05;\t \n\tpar->Graphics[7] = 0x0F;\n\tpar->Graphics[8] = 0xFF;\n\n\n\tpar->Attribute[0] = 0x00;\t \n\tpar->Attribute[1] = 0x01;\n\tpar->Attribute[2] = 0x02;\n\tpar->Attribute[3] = 0x03;\n\tpar->Attribute[4] = 0x04;\n\tpar->Attribute[5] = 0x05;\n\tpar->Attribute[6] = 0x06;\n\tpar->Attribute[7] = 0x07;\n\tpar->Attribute[8] = 0x08;\n\tpar->Attribute[9] = 0x09;\n\tpar->Attribute[10] = 0x0A;\n\tpar->Attribute[11] = 0x0B;\n\tpar->Attribute[12] = 0x0C;\n\tpar->Attribute[13] = 0x0D;\n\tpar->Attribute[14] = 0x0E;\n\tpar->Attribute[15] = 0x0F;\n\tpar->Attribute[16] = 0x41;\n\tpar->Attribute[17] = 0xFF;\n\tpar->Attribute[18] = 0x0F;\n\tpar->Attribute[19] = 0x00;\n\tpar->Attribute[20] = 0x00;\n\treturn 0;\n}\n\nstatic void vgaHWLock(struct vgastate *state)\n{\n\t \n\tvga_wcrt(state->vgabase, 0x11, vga_rcrt(state->vgabase, 0x11) | 0x80);\n}\n\nstatic void vgaHWUnlock(void)\n{\n\t \n\tvga_wcrt(NULL, 0x11, vga_rcrt(NULL, 0x11) & ~0x80);\n}\n\nstatic void neoLock(struct vgastate *state)\n{\n\tvga_wgfx(state->vgabase, 0x09, 0x00);\n\tvgaHWLock(state);\n}\n\nstatic void neoUnlock(void)\n{\n\tvgaHWUnlock();\n\tvga_wgfx(NULL, 0x09, 0x26);\n}\n\n \nstatic int paletteEnabled = 0;\n\nstatic inline void VGAenablePalette(void)\n{\n\tvga_r(NULL, VGA_IS1_RC);\n\tvga_w(NULL, VGA_ATT_W, 0x00);\n\tpaletteEnabled = 1;\n}\n\nstatic inline void VGAdisablePalette(void)\n{\n\tvga_r(NULL, VGA_IS1_RC);\n\tvga_w(NULL, VGA_ATT_W, 0x20);\n\tpaletteEnabled = 0;\n}\n\nstatic inline void VGAwATTR(u8 index, u8 value)\n{\n\tif (paletteEnabled)\n\t\tindex &= ~0x20;\n\telse\n\t\tindex |= 0x20;\n\n\tvga_r(NULL, VGA_IS1_RC);\n\tvga_wattr(NULL, index, value);\n}\n\nstatic void vgaHWProtect(int on)\n{\n\tunsigned char tmp;\n\n\ttmp = vga_rseq(NULL, 0x01);\n\tif (on) {\n\t\t \n\t\tvga_wseq(NULL, 0x00, 0x01);\t\t \n\t\tvga_wseq(NULL, 0x01, tmp | 0x20);\t \n\n\t\tVGAenablePalette();\n\t} else {\n\t\t \n\t\tvga_wseq(NULL, 0x01, tmp & ~0x20);\t \n\t\tvga_wseq(NULL, 0x00, 0x03);\t\t \n\n\t\tVGAdisablePalette();\n\t}\n}\n\nstatic void vgaHWRestore(const struct fb_info *info,\n\t\t\t const struct neofb_par *par)\n{\n\tint i;\n\n\tvga_w(NULL, VGA_MIS_W, par->MiscOutReg);\n\n\tfor (i = 1; i < 5; i++)\n\t\tvga_wseq(NULL, i, par->Sequencer[i]);\n\n\t \n\tvga_wcrt(NULL, 17, par->CRTC[17] & ~0x80);\n\n\tfor (i = 0; i < 25; i++)\n\t\tvga_wcrt(NULL, i, par->CRTC[i]);\n\n\tfor (i = 0; i < 9; i++)\n\t\tvga_wgfx(NULL, i, par->Graphics[i]);\n\n\tVGAenablePalette();\n\n\tfor (i = 0; i < 21; i++)\n\t\tVGAwATTR(i, par->Attribute[i]);\n\n\tVGAdisablePalette();\n}\n\n\n \n\n \nstatic inline int neo2200_sync(struct fb_info *info)\n{\n\tstruct neofb_par *par = info->par;\n\n\twhile (readl(&par->neo2200->bltStat) & 1)\n\t\tcpu_relax();\n\treturn 0;\n}\n\nstatic inline void neo2200_wait_fifo(struct fb_info *info,\n\t\t\t\t     int requested_fifo_space)\n{\n\t\n\t\n\n\t \n\n\tneo2200_sync(info);\n}\n\nstatic inline void neo2200_accel_init(struct fb_info *info,\n\t\t\t\t      struct fb_var_screeninfo *var)\n{\n\tstruct neofb_par *par = info->par;\n\tNeo2200 __iomem *neo2200 = par->neo2200;\n\tu32 bltMod, pitch;\n\n\tneo2200_sync(info);\n\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tbltMod = NEO_MODE1_DEPTH8;\n\t\tpitch = var->xres_virtual;\n\t\tbreak;\n\tcase 15:\n\tcase 16:\n\t\tbltMod = NEO_MODE1_DEPTH16;\n\t\tpitch = var->xres_virtual * 2;\n\t\tbreak;\n\tcase 24:\n\t\tbltMod = NEO_MODE1_DEPTH24;\n\t\tpitch = var->xres_virtual * 3;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR\n\t\t       \"neofb: neo2200_accel_init: unexpected bits per pixel!\\n\");\n\t\treturn;\n\t}\n\n\twritel(bltMod << 16, &neo2200->bltStat);\n\twritel((pitch << 16) | pitch, &neo2200->pitch);\n}\n\n \n\nstatic int\nneofb_open(struct fb_info *info, int user)\n{\n\tstruct neofb_par *par = info->par;\n\n\tif (!par->ref_count) {\n\t\tmemset(&par->state, 0, sizeof(struct vgastate));\n\t\tpar->state.flags = VGA_SAVE_MODE | VGA_SAVE_FONTS;\n\t\tsave_vga(&par->state);\n\t}\n\tpar->ref_count++;\n\n\treturn 0;\n}\n\nstatic int\nneofb_release(struct fb_info *info, int user)\n{\n\tstruct neofb_par *par = info->par;\n\n\tif (!par->ref_count)\n\t\treturn -EINVAL;\n\n\tif (par->ref_count == 1) {\n\t\trestore_vga(&par->state);\n\t}\n\tpar->ref_count--;\n\n\treturn 0;\n}\n\nstatic int\nneofb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct neofb_par *par = info->par;\n\tint memlen, vramlen;\n\tint mode_ok = 0;\n\n\tDBG(\"neofb_check_var\");\n\n\tif (!var->pixclock || PICOS2KHZ(var->pixclock) > par->maxClock)\n\t\treturn -EINVAL;\n\n\t \n\tif (par->internal_display &&\n            ((var->xres > par->NeoPanelWidth) ||\n\t     (var->yres > par->NeoPanelHeight))) {\n\t\tprintk(KERN_INFO\n\t\t       \"Mode (%dx%d) larger than the LCD panel (%dx%d)\\n\",\n\t\t       var->xres, var->yres, par->NeoPanelWidth,\n\t\t       par->NeoPanelHeight);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!par->internal_display)\n\t\tmode_ok = 1;\n\telse {\n\t\tswitch (var->xres) {\n\t\tcase 1280:\n\t\t\tif (var->yres == 1024)\n\t\t\t\tmode_ok = 1;\n\t\t\tbreak;\n\t\tcase 1024:\n\t\t\tif (var->yres == 768)\n\t\t\t\tmode_ok = 1;\n\t\t\tbreak;\n\t\tcase 800:\n\t\t\tif (var->yres == (par->libretto ? 480 : 600))\n\t\t\t\tmode_ok = 1;\n\t\t\tbreak;\n\t\tcase 640:\n\t\t\tif (var->yres == 480)\n\t\t\t\tmode_ok = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!mode_ok) {\n\t\tprintk(KERN_INFO\n\t\t       \"Mode (%dx%d) won't display properly on LCD\\n\",\n\t\t       var->xres, var->yres);\n\t\treturn -EINVAL;\n\t}\n\n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.msb_right = 0;\n\tvar->transp.msb_right = 0;\n\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\t\t \n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\n\tcase 16:\t\t \n\t\tvar->red.offset = 11;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tbreak;\n\n\tcase 24:\t\t \n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\n#ifdef NO_32BIT_SUPPORT_YET\n\tcase 32:\t\t \n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tprintk(KERN_WARNING \"neofb: no support for %dbpp\\n\",\n\t\t       var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\tvramlen = info->fix.smem_len;\n\tif (vramlen > 4 * 1024 * 1024)\n\t\tvramlen = 4 * 1024 * 1024;\n\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\n\tmemlen = var->xres_virtual * var->bits_per_pixel * var->yres_virtual >> 3;\n\n\tif (memlen > vramlen) {\n\t\tvar->yres_virtual =  vramlen * 8 / (var->xres_virtual *\n\t\t\t\t   \tvar->bits_per_pixel);\n\t\tmemlen = var->xres_virtual * var->bits_per_pixel *\n\t\t\t\tvar->yres_virtual / 8;\n\t}\n\n\t \n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres = var->yres_virtual;\n\tif (var->xoffset + var->xres > var->xres_virtual)\n\t\tvar->xoffset = var->xres_virtual - var->xres;\n\tif (var->yoffset + var->yres > var->yres_virtual)\n\t\tvar->yoffset = var->yres_virtual - var->yres;\n\n\tvar->nonstd = 0;\n\tvar->height = -1;\n\tvar->width = -1;\n\n\tif (var->bits_per_pixel >= 24 || !par->neo2200)\n\t\tvar->accel_flags &= ~FB_ACCELF_TEXT;\n\treturn 0;\n}\n\nstatic int neofb_set_par(struct fb_info *info)\n{\n\tstruct neofb_par *par = info->par;\n\tunsigned char temp;\n\tint i, clock_hi = 0;\n\tint lcd_stretch;\n\tint hoffset, voffset;\n\tint vsync_start, vtotal;\n\n\tDBG(\"neofb_set_par\");\n\n\tneoUnlock();\n\n\tvgaHWProtect(1);\t \n\n\tvsync_start = info->var.yres + info->var.lower_margin;\n\tvtotal = vsync_start + info->var.vsync_len + info->var.upper_margin;\n\n\t \n\n\tif (vgaHWInit(&info->var, par))\n\t\treturn -EINVAL;\n\n\t \n\tpar->Attribute[16] = 0x01;\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tpar->CRTC[0x13] = info->var.xres_virtual >> 3;\n\t\tpar->ExtCRTOffset = info->var.xres_virtual >> 11;\n\t\tpar->ExtColorModeSelect = 0x11;\n\t\tbreak;\n\tcase 16:\n\t\tpar->CRTC[0x13] = info->var.xres_virtual >> 2;\n\t\tpar->ExtCRTOffset = info->var.xres_virtual >> 10;\n\t\tpar->ExtColorModeSelect = 0x13;\n\t\tbreak;\n\tcase 24:\n\t\tpar->CRTC[0x13] = (info->var.xres_virtual * 3) >> 3;\n\t\tpar->ExtCRTOffset = (info->var.xres_virtual * 3) >> 11;\n\t\tpar->ExtColorModeSelect = 0x14;\n\t\tbreak;\n#ifdef NO_32BIT_SUPPORT_YET\n\tcase 32:\t\t \n\t\tpar->CRTC[0x13] = info->var.xres_virtual >> 1;\n\t\tpar->ExtCRTOffset = info->var.xres_virtual >> 9;\n\t\tpar->ExtColorModeSelect = 0x15;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpar->ExtCRTDispAddr = 0x10;\n\n\t \n\tpar->VerticalExt = (((vtotal - 2) & 0x400) >> 10)\n\t    | (((info->var.yres - 1) & 0x400) >> 9)\n\t    | (((vsync_start) & 0x400) >> 8)\n\t    | (((vsync_start) & 0x400) >> 7);\n\n\t \n\tif (par->pci_burst)\n\t\tpar->SysIfaceCntl1 = 0x30;\n\telse\n\t\tpar->SysIfaceCntl1 = 0x00;\n\n\tpar->SysIfaceCntl2 = 0xc0;\t \n\n\t \n\tpar->PanelDispCntlRegRead = 1;\n\n\t \n\tpar->PanelDispCntlReg1 = 0x00;\n\tif (par->internal_display)\n\t\tpar->PanelDispCntlReg1 |= 0x02;\n\tif (par->external_display)\n\t\tpar->PanelDispCntlReg1 |= 0x01;\n\n\t \n\tif (par->PanelDispCntlReg1 == 0x00) {\n\t\t \n\t\tpar->PanelDispCntlReg1 = vga_rgfx(NULL, 0x20) & 0x03;\n\t}\n\n\t \n\tswitch (info->var.xres) {\n\tcase 1280:\n\t\tpar->PanelDispCntlReg1 |= 0x60;\n\t\tbreak;\n\tcase 1024:\n\t\tpar->PanelDispCntlReg1 |= 0x40;\n\t\tbreak;\n\tcase 800:\n\t\tpar->PanelDispCntlReg1 |= 0x20;\n\t\tbreak;\n\tcase 640:\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (par->PanelDispCntlReg1 & 0x03) {\n\tcase 0x01:\t\t \n\t\tpar->GeneralLockReg = 0x00;\n\t\t \n\t\tpar->ProgramVCLK = 1;\n\t\tbreak;\n\tcase 0x02:\t\t \n\tcase 0x03:\t\t \n\t\tpar->GeneralLockReg = 0x01;\n\t\t \n\t\tpar->ProgramVCLK = 0;\n\t\tbreak;\n\t}\n\n\t \n\tpar->PanelDispCntlReg2 = 0x00;\n\tpar->PanelDispCntlReg3 = 0x00;\n\n\tif (par->lcd_stretch && (par->PanelDispCntlReg1 == 0x02) &&\t \n\t    (info->var.xres != par->NeoPanelWidth)) {\n\t\tswitch (info->var.xres) {\n\t\tcase 320:\t \n\t\tcase 400:\t \n\t\tcase 640:\n\t\tcase 800:\n\t\tcase 1024:\n\t\t\tlcd_stretch = 1;\n\t\t\tpar->PanelDispCntlReg2 |= 0xC6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlcd_stretch = 0;\n\t\t\t \n\t\t}\n\t} else\n\t\tlcd_stretch = 0;\n\n\t \n\tpar->PanelVertCenterReg1 = 0x00;\n\tpar->PanelVertCenterReg2 = 0x00;\n\tpar->PanelVertCenterReg3 = 0x00;\n\tpar->PanelVertCenterReg4 = 0x00;\n\tpar->PanelVertCenterReg5 = 0x00;\n\tpar->PanelHorizCenterReg1 = 0x00;\n\tpar->PanelHorizCenterReg2 = 0x00;\n\tpar->PanelHorizCenterReg3 = 0x00;\n\tpar->PanelHorizCenterReg4 = 0x00;\n\tpar->PanelHorizCenterReg5 = 0x00;\n\n\n\tif (par->PanelDispCntlReg1 & 0x02) {\n\t\tif (info->var.xres == par->NeoPanelWidth) {\n\t\t\t \n\t\t} else {\n\t\t\tpar->PanelDispCntlReg2 |= 0x01;\n\t\t\tpar->PanelDispCntlReg3 |= 0x10;\n\n\t\t\t \n\t\t\tif (!lcd_stretch) {\n\t\t\t\thoffset =\n\t\t\t\t    ((par->NeoPanelWidth -\n\t\t\t\t      info->var.xres) >> 4) - 1;\n\t\t\t\tvoffset =\n\t\t\t\t    ((par->NeoPanelHeight -\n\t\t\t\t      info->var.yres) >> 1) - 2;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\thoffset = 0;\n\t\t\t\tvoffset = 0;\n\t\t\t}\n\n\t\t\tswitch (info->var.xres) {\n\t\t\tcase 320:\t \n\t\t\t\tpar->PanelHorizCenterReg3 = hoffset;\n\t\t\t\tpar->PanelVertCenterReg2 = voffset;\n\t\t\t\tbreak;\n\t\t\tcase 400:\t \n\t\t\t\tpar->PanelHorizCenterReg4 = hoffset;\n\t\t\t\tpar->PanelVertCenterReg1 = voffset;\n\t\t\t\tbreak;\n\t\t\tcase 640:\n\t\t\t\tpar->PanelHorizCenterReg1 = hoffset;\n\t\t\t\tpar->PanelVertCenterReg3 = voffset;\n\t\t\t\tbreak;\n\t\t\tcase 800:\n\t\t\t\tpar->PanelHorizCenterReg2 = hoffset;\n\t\t\t\tpar->PanelVertCenterReg4 = voffset;\n\t\t\t\tbreak;\n\t\t\tcase 1024:\n\t\t\t\tpar->PanelHorizCenterReg5 = hoffset;\n\t\t\t\tpar->PanelVertCenterReg5 = voffset;\n\t\t\t\tbreak;\n\t\t\tcase 1280:\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpar->biosMode =\n\t    neoFindMode(info->var.xres, info->var.yres,\n\t\t\tinfo->var.bits_per_pixel);\n\n\t \n\tneoCalcVCLK(info, par, PICOS2KHZ(info->var.pixclock));\n\n\t \n\tpar->MiscOutReg |= 0x0C;\n\n\t \n\t \n\n\t \n\tvga_wgfx(NULL, 0x15, 0x00);\n\n\t \n\tvga_wgfx(NULL, 0x0A, par->GeneralLockReg);\n\n\t \n\ttemp = vga_rgfx(NULL, 0x90);\n\tswitch (info->fix.accel) {\n\tcase FB_ACCEL_NEOMAGIC_NM2070:\n\t\ttemp &= 0xF0;\t \n\t\ttemp |= (par->ExtColorModeSelect & ~0xF0);\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2090:\n\tcase FB_ACCEL_NEOMAGIC_NM2093:\n\tcase FB_ACCEL_NEOMAGIC_NM2097:\n\tcase FB_ACCEL_NEOMAGIC_NM2160:\n\tcase FB_ACCEL_NEOMAGIC_NM2200:\n\tcase FB_ACCEL_NEOMAGIC_NM2230:\n\tcase FB_ACCEL_NEOMAGIC_NM2360:\n\tcase FB_ACCEL_NEOMAGIC_NM2380:\n\t\ttemp &= 0x70;\t \n\t\ttemp |= (par->ExtColorModeSelect & ~0x70);\n\t\tbreak;\n\t}\n\n\tvga_wgfx(NULL, 0x90, temp);\n\n\t \n\t\n\n\t \n\ttemp = vga_rgfx(NULL, 0x25);\n\ttemp &= 0x39;\n\tvga_wgfx(NULL, 0x25, temp);\n\n\t \n\tmdelay(200);\n\n\t \n\tvgaHWRestore(info, par);\n\n\t \n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\t \n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\tcase 16:\n\t\t \n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\toutb(i, 0x3c8);\n\n\t\t\toutb(i << 1, 0x3c9);\n\t\t\toutb(i, 0x3c9);\n\t\t\toutb(i << 1, 0x3c9);\n\t\t}\n\t\tbreak;\n\tcase 24:\n#ifdef NO_32BIT_SUPPORT_YET\n\tcase 32:\n#endif\n\t\t \n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\toutb(i, 0x3c8);\n\n\t\t\toutb(i, 0x3c9);\n\t\t\toutb(i, 0x3c9);\n\t\t\toutb(i, 0x3c9);\n\t\t}\n\t\tbreak;\n\t}\n\n\tvga_wgfx(NULL, 0x0E, par->ExtCRTDispAddr);\n\tvga_wgfx(NULL, 0x0F, par->ExtCRTOffset);\n\ttemp = vga_rgfx(NULL, 0x10);\n\ttemp &= 0x0F;\t\t \n\ttemp |= (par->SysIfaceCntl1 & ~0x0F);\t \n\tvga_wgfx(NULL, 0x10, temp);\n\n\tvga_wgfx(NULL, 0x11, par->SysIfaceCntl2);\n\tvga_wgfx(NULL, 0x15, 0   );\n\tvga_wgfx(NULL, 0x16, 0   );\n\n\ttemp = vga_rgfx(NULL, 0x20);\n\tswitch (info->fix.accel) {\n\tcase FB_ACCEL_NEOMAGIC_NM2070:\n\t\ttemp &= 0xFC;\t \n\t\ttemp |= (par->PanelDispCntlReg1 & ~0xFC);\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2090:\n\tcase FB_ACCEL_NEOMAGIC_NM2093:\n\tcase FB_ACCEL_NEOMAGIC_NM2097:\n\tcase FB_ACCEL_NEOMAGIC_NM2160:\n\t\ttemp &= 0xDC;\t \n\t\ttemp |= (par->PanelDispCntlReg1 & ~0xDC);\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2200:\n\tcase FB_ACCEL_NEOMAGIC_NM2230:\n\tcase FB_ACCEL_NEOMAGIC_NM2360:\n\tcase FB_ACCEL_NEOMAGIC_NM2380:\n\t\ttemp &= 0x98;\t \n\t\ttemp |= (par->PanelDispCntlReg1 & ~0x98);\n\t\tbreak;\n\t}\n\tvga_wgfx(NULL, 0x20, temp);\n\n\ttemp = vga_rgfx(NULL, 0x25);\n\ttemp &= 0x38;\t\t \n\ttemp |= (par->PanelDispCntlReg2 & ~0x38);\n\tvga_wgfx(NULL, 0x25, temp);\n\n\tif (info->fix.accel != FB_ACCEL_NEOMAGIC_NM2070) {\n\t\ttemp = vga_rgfx(NULL, 0x30);\n\t\ttemp &= 0xEF;\t \n\t\ttemp |= (par->PanelDispCntlReg3 & ~0xEF);\n\t\tvga_wgfx(NULL, 0x30, temp);\n\t}\n\n\tvga_wgfx(NULL, 0x28, par->PanelVertCenterReg1);\n\tvga_wgfx(NULL, 0x29, par->PanelVertCenterReg2);\n\tvga_wgfx(NULL, 0x2a, par->PanelVertCenterReg3);\n\n\tif (info->fix.accel != FB_ACCEL_NEOMAGIC_NM2070) {\n\t\tvga_wgfx(NULL, 0x32, par->PanelVertCenterReg4);\n\t\tvga_wgfx(NULL, 0x33, par->PanelHorizCenterReg1);\n\t\tvga_wgfx(NULL, 0x34, par->PanelHorizCenterReg2);\n\t\tvga_wgfx(NULL, 0x35, par->PanelHorizCenterReg3);\n\t}\n\n\tif (info->fix.accel == FB_ACCEL_NEOMAGIC_NM2160)\n\t\tvga_wgfx(NULL, 0x36, par->PanelHorizCenterReg4);\n\n\tif (info->fix.accel == FB_ACCEL_NEOMAGIC_NM2200 ||\n\t    info->fix.accel == FB_ACCEL_NEOMAGIC_NM2230 ||\n\t    info->fix.accel == FB_ACCEL_NEOMAGIC_NM2360 ||\n\t    info->fix.accel == FB_ACCEL_NEOMAGIC_NM2380) {\n\t\tvga_wgfx(NULL, 0x36, par->PanelHorizCenterReg4);\n\t\tvga_wgfx(NULL, 0x37, par->PanelVertCenterReg5);\n\t\tvga_wgfx(NULL, 0x38, par->PanelHorizCenterReg5);\n\n\t\tclock_hi = 1;\n\t}\n\n\t \n\tif (par->ProgramVCLK && ((vga_rgfx(NULL, 0x9B) != par->VCLK3NumeratorLow)\n\t\t\t\t || (vga_rgfx(NULL, 0x9F) != par->VCLK3Denominator)\n\t\t\t\t || (clock_hi && ((vga_rgfx(NULL, 0x8F) & ~0x0f)\n\t\t\t\t\t\t  != (par->VCLK3NumeratorHigh &\n\t\t\t\t\t\t      ~0x0F))))) {\n\t\tvga_wgfx(NULL, 0x9B, par->VCLK3NumeratorLow);\n\t\tif (clock_hi) {\n\t\t\ttemp = vga_rgfx(NULL, 0x8F);\n\t\t\ttemp &= 0x0F;\t \n\t\t\ttemp |= (par->VCLK3NumeratorHigh & ~0x0F);\n\t\t\tvga_wgfx(NULL, 0x8F, temp);\n\t\t}\n\t\tvga_wgfx(NULL, 0x9F, par->VCLK3Denominator);\n\t}\n\n\tif (par->biosMode)\n\t\tvga_wcrt(NULL, 0x23, par->biosMode);\n\n\tvga_wgfx(NULL, 0x93, 0xc0);\t \n\n\t \n\tif (info->fix.accel == FB_ACCEL_NEOMAGIC_NM2200 ||\n\t    info->fix.accel == FB_ACCEL_NEOMAGIC_NM2230 ||\n\t    info->fix.accel == FB_ACCEL_NEOMAGIC_NM2360 ||\n\t    info->fix.accel == FB_ACCEL_NEOMAGIC_NM2380) {\n\t\tvga_wcrt(NULL, 0x70, par->VerticalExt);\n\t}\n\n\tvgaHWProtect(0);\t \n\n\t \n\tneoLock(&par->state);\n\n\tinfo->fix.line_length =\n\t    info->var.xres_virtual * (info->var.bits_per_pixel >> 3);\n\n\tswitch (info->fix.accel) {\n\t\tcase FB_ACCEL_NEOMAGIC_NM2200:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2230:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2360:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2380:\n\t\t\tneo2200_accel_init(info, &info->var);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int neofb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tstruct neofb_par *par = info->par;\n\tstruct vgastate *state = &par->state;\n\tint oldExtCRTDispAddr;\n\tint Base;\n\n\tDBG(\"neofb_update_start\");\n\n\tBase = (var->yoffset * info->var.xres_virtual + var->xoffset) >> 2;\n\tBase *= (info->var.bits_per_pixel + 7) / 8;\n\n\tneoUnlock();\n\n\t \n\tvga_wcrt(state->vgabase, 0x0C, (Base & 0x00FF00) >> 8);\n\tvga_wcrt(state->vgabase, 0x0D, (Base & 0x00FF));\n\n\t \n\toldExtCRTDispAddr = vga_rgfx(NULL, 0x0E);\n\tvga_wgfx(state->vgabase, 0x0E, (((Base >> 16) & 0x0f) | (oldExtCRTDispAddr & 0xf0)));\n\n\tneoLock(state);\n\n\treturn 0;\n}\n\nstatic int neofb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t   u_int transp, struct fb_info *fb)\n{\n\tif (regno >= fb->cmap.len || regno > 255)\n\t\treturn -EINVAL;\n\n\tif (fb->var.bits_per_pixel <= 8) {\n\t\toutb(regno, 0x3c8);\n\n\t\toutb(red >> 10, 0x3c9);\n\t\toutb(green >> 10, 0x3c9);\n\t\toutb(blue >> 10, 0x3c9);\n\t} else if (regno < 16) {\n\t\tswitch (fb->var.bits_per_pixel) {\n\t\tcase 16:\n\t\t\t((u32 *) fb->pseudo_palette)[regno] =\n\t\t\t\t((red & 0xf800)) | ((green & 0xfc00) >> 5) |\n\t\t\t\t((blue & 0xf800) >> 11);\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\t((u32 *) fb->pseudo_palette)[regno] =\n\t\t\t\t((red & 0xff00) << 8) | ((green & 0xff00)) |\n\t\t\t\t((blue & 0xff00) >> 8);\n\t\t\tbreak;\n#ifdef NO_32BIT_SUPPORT_YET\n\t\tcase 32:\n\t\t\t((u32 *) fb->pseudo_palette)[regno] =\n\t\t\t\t((transp & 0xff00) << 16) | ((red & 0xff00) << 8) |\n\t\t\t\t((green & 0xff00)) | ((blue & 0xff00) >> 8);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int neofb_blank(int blank_mode, struct fb_info *info)\n{\n\t \n\tstruct neofb_par *par = info->par;\n\tint seqflags, lcdflags, dpmsflags, reg, tmpdisp;\n\n\t \n\tneoUnlock();\n\ttmpdisp = vga_rgfx(NULL, 0x20) & 0x03;\n\tneoLock(&par->state);\n\n\t \n\tif (par->PanelDispCntlRegRead) {\n\t\tpar->PanelDispCntlReg1 = tmpdisp;\n\t}\n\tpar->PanelDispCntlRegRead = !blank_mode;\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_POWERDOWN:\t \n\t\tseqflags = VGA_SR01_SCREEN_OFF;  \n\t\tlcdflags = 0;\t\t\t \n\t\tdpmsflags = NEO_GR01_SUPPRESS_HSYNC |\n\t\t\t    NEO_GR01_SUPPRESS_VSYNC;\n#ifdef CONFIG_TOSHIBA\n\t\t \n\t\t \n\t\t{\n\t\t\tSMMRegisters regs;\n\n\t\t\tregs.eax = 0xff00;  \n\t\t\tregs.ebx = 0x0002;  \n\t\t\tregs.ecx = 0x0000;  \n\t\t\ttosh_smm(&regs);\n\t\t}\n#endif\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\t\t \n\t\tseqflags = VGA_SR01_SCREEN_OFF;\t \n\t\tlcdflags = 0;\t\t\t \n\t\tdpmsflags = NEO_GR01_SUPPRESS_HSYNC;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\t\t \n\t\tseqflags = VGA_SR01_SCREEN_OFF;\t \n\t\tlcdflags = 0;\t\t\t \n\t\tdpmsflags = NEO_GR01_SUPPRESS_VSYNC;\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\t\t \n\t\tseqflags = VGA_SR01_SCREEN_OFF;\t \n\t\t \n\t\tlcdflags = ((par->PanelDispCntlReg1 | tmpdisp) & 0x02);  \n\t\tdpmsflags = 0x00;\t \n\t\tbreak;\n\tcase FB_BLANK_UNBLANK:\t\t \n\t\tseqflags = 0;\t\t\t \n\t\tlcdflags = ((par->PanelDispCntlReg1 | tmpdisp) & 0x02);  \n\t\tdpmsflags = 0x00;\t \n#ifdef CONFIG_TOSHIBA\n\t\t \n\t\t \n\t\t{\n\t\t\tSMMRegisters regs;\n\n\t\t\tregs.eax = 0xff00;  \n\t\t\tregs.ebx = 0x0002;  \n\t\t\tregs.ecx = 0x0001;  \n\t\t\ttosh_smm(&regs);\n\t\t}\n#endif\n\t\tbreak;\n\tdefault:\t \n\t\treturn 1;\n\t}\n\n\tneoUnlock();\n\treg = (vga_rseq(NULL, 0x01) & ~0x20) | seqflags;\n\tvga_wseq(NULL, 0x01, reg);\n\treg = (vga_rgfx(NULL, 0x20) & ~0x02) | lcdflags;\n\tvga_wgfx(NULL, 0x20, reg);\n\treg = (vga_rgfx(NULL, 0x01) & ~0xF0) | 0x80 | dpmsflags;\n\tvga_wgfx(NULL, 0x01, reg);\n\tneoLock(&par->state);\n\treturn 0;\n}\n\nstatic void\nneo2200_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct neofb_par *par = info->par;\n\tu_long dst, rop;\n\n\tdst = rect->dx + rect->dy * info->var.xres_virtual;\n\trop = rect->rop ? 0x060000 : 0x0c0000;\n\n\tneo2200_wait_fifo(info, 4);\n\n\t \n\twritel(NEO_BC3_FIFO_EN |\n\t       NEO_BC0_SRC_IS_FG | NEO_BC3_SKIP_MAPPING |\n\t        \n\t        \n\t       rop, &par->neo2200->bltCntl);\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\twritel(rect->color, &par->neo2200->fgColor);\n\t\tbreak;\n\tcase 16:\n\tcase 24:\n\t\twritel(((u32 *) (info->pseudo_palette))[rect->color],\n\t\t       &par->neo2200->fgColor);\n\t\tbreak;\n\t}\n\n\twritel(dst * ((info->var.bits_per_pixel + 7) >> 3),\n\t       &par->neo2200->dstStart);\n\twritel((rect->height << 16) | (rect->width & 0xffff),\n\t       &par->neo2200->xyExt);\n}\n\nstatic void\nneo2200_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tu32 sx = area->sx, sy = area->sy, dx = area->dx, dy = area->dy;\n\tstruct neofb_par *par = info->par;\n\tu_long src, dst, bltCntl;\n\n\tbltCntl = NEO_BC3_FIFO_EN | NEO_BC3_SKIP_MAPPING | 0x0C0000;\n\n\tif ((dy > sy) || ((dy == sy) && (dx > sx))) {\n\t\t \n\t\tsy += (area->height - 1);\n\t\tdy += (area->height - 1);\n\t\tsx += (area->width - 1);\n\t\tdx += (area->width - 1);\n\n\t\tbltCntl |= NEO_BC0_X_DEC | NEO_BC0_DST_Y_DEC | NEO_BC0_SRC_Y_DEC;\n\t}\n\n\tsrc = sx * (info->var.bits_per_pixel >> 3) + sy*info->fix.line_length;\n\tdst = dx * (info->var.bits_per_pixel >> 3) + dy*info->fix.line_length;\n\n\tneo2200_wait_fifo(info, 4);\n\n\t \n\twritel(bltCntl, &par->neo2200->bltCntl);\n\n\twritel(src, &par->neo2200->srcStart);\n\twritel(dst, &par->neo2200->dstStart);\n\twritel((area->height << 16) | (area->width & 0xffff),\n\t       &par->neo2200->xyExt);\n}\n\nstatic void\nneo2200_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct neofb_par *par = info->par;\n\tint s_pitch = (image->width * image->depth + 7) >> 3;\n\tint scan_align = info->pixmap.scan_align - 1;\n\tint buf_align = info->pixmap.buf_align - 1;\n\tint bltCntl_flags, d_pitch, data_len;\n\n\t \n\td_pitch = (s_pitch + scan_align) & ~scan_align;\n\tdata_len = ((d_pitch * image->height) + buf_align) & ~buf_align;\n\n\tneo2200_sync(info);\n\n\tif (image->depth == 1) {\n\t\tif (info->var.bits_per_pixel == 24 && image->width < 16) {\n\t\t\t \n\t\t\tcfb_imageblit(info, image);\n\t\t\treturn;\n\t\t}\n\t\tbltCntl_flags = NEO_BC0_SRC_MONO;\n\t} else if (image->depth == info->var.bits_per_pixel) {\n\t\tbltCntl_flags = 0;\n\t} else {\n\t\t \n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\twritel(image->fg_color, &par->neo2200->fgColor);\n\t\twritel(image->bg_color, &par->neo2200->bgColor);\n\t\tbreak;\n\tcase 16:\n\tcase 24:\n\t\twritel(((u32 *) (info->pseudo_palette))[image->fg_color],\n\t\t       &par->neo2200->fgColor);\n\t\twritel(((u32 *) (info->pseudo_palette))[image->bg_color],\n\t\t       &par->neo2200->bgColor);\n\t\tbreak;\n\t}\n\n\twritel(NEO_BC0_SYS_TO_VID |\n\t\tNEO_BC3_SKIP_MAPPING | bltCntl_flags |\n\t\t\n\t\t0x0c0000, &par->neo2200->bltCntl);\n\n\twritel(0, &par->neo2200->srcStart);\n\n\twritel(((image->dx & 0xffff) * (info->var.bits_per_pixel >> 3) +\n\t\timage->dy * info->fix.line_length), &par->neo2200->dstStart);\n\twritel((image->height << 16) | (image->width & 0xffff),\n\t       &par->neo2200->xyExt);\n\n\tmemcpy_toio(par->mmio_vbase + 0x100000, image->data, data_len);\n}\n\nstatic void\nneofb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tswitch (info->fix.accel) {\n\t\tcase FB_ACCEL_NEOMAGIC_NM2200:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2230:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2360:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2380:\n\t\t\tneo2200_fillrect(info, rect);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcfb_fillrect(info, rect);\n\t\t\tbreak;\n\t}\n}\n\nstatic void\nneofb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tswitch (info->fix.accel) {\n\t\tcase FB_ACCEL_NEOMAGIC_NM2200:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2230:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2360:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2380:\n\t\t\tneo2200_copyarea(info, area);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcfb_copyarea(info, area);\n\t\t\tbreak;\n\t}\n}\n\nstatic void\nneofb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tswitch (info->fix.accel) {\n\t\tcase FB_ACCEL_NEOMAGIC_NM2200:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2230:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2360:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2380:\n\t\t\tneo2200_imageblit(info, image);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcfb_imageblit(info, image);\n\t\t\tbreak;\n\t}\n}\n\nstatic int\nneofb_sync(struct fb_info *info)\n{\n\tswitch (info->fix.accel) {\n\t\tcase FB_ACCEL_NEOMAGIC_NM2200:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2230:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2360:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2380:\n\t\t\tneo2200_sync(info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \n\nstatic const struct fb_ops neofb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= neofb_open,\n\t.fb_release\t= neofb_release,\n\t.fb_check_var\t= neofb_check_var,\n\t.fb_set_par\t= neofb_set_par,\n\t.fb_setcolreg\t= neofb_setcolreg,\n\t.fb_pan_display\t= neofb_pan_display,\n\t.fb_blank\t= neofb_blank,\n\t.fb_sync\t= neofb_sync,\n\t.fb_fillrect\t= neofb_fillrect,\n\t.fb_copyarea\t= neofb_copyarea,\n\t.fb_imageblit\t= neofb_imageblit,\n};\n\n \n\nstatic struct fb_videomode mode800x480 = {\n\t.xres           = 800,\n\t.yres           = 480,\n\t.pixclock       = 25000,\n\t.left_margin    = 88,\n\t.right_margin   = 40,\n\t.upper_margin   = 23,\n\t.lower_margin   = 1,\n\t.hsync_len      = 128,\n\t.vsync_len      = 4,\n\t.sync           = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t.vmode          = FB_VMODE_NONINTERLACED\n};\n\nstatic int neo_map_mmio(struct fb_info *info, struct pci_dev *dev)\n{\n\tstruct neofb_par *par = info->par;\n\n\tDBG(\"neo_map_mmio\");\n\n\tswitch (info->fix.accel) {\n\t\tcase FB_ACCEL_NEOMAGIC_NM2070:\n\t\t\tinfo->fix.mmio_start = pci_resource_start(dev, 0)+\n\t\t\t\t0x100000;\n\t\t\tbreak;\n\t\tcase FB_ACCEL_NEOMAGIC_NM2090:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2093:\n\t\t\tinfo->fix.mmio_start = pci_resource_start(dev, 0)+\n\t\t\t\t0x200000;\n\t\t\tbreak;\n\t\tcase FB_ACCEL_NEOMAGIC_NM2160:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2097:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2200:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2230:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2360:\n\t\tcase FB_ACCEL_NEOMAGIC_NM2380:\n\t\t\tinfo->fix.mmio_start = pci_resource_start(dev, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo->fix.mmio_start = pci_resource_start(dev, 0);\n\t}\n\tinfo->fix.mmio_len = MMIO_SIZE;\n\n\tif (!request_mem_region\n\t    (info->fix.mmio_start, MMIO_SIZE, \"memory mapped I/O\")) {\n\t\tprintk(\"neofb: memory mapped IO in use\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tpar->mmio_vbase = ioremap(info->fix.mmio_start, MMIO_SIZE);\n\tif (!par->mmio_vbase) {\n\t\tprintk(\"neofb: unable to map memory mapped IO\\n\");\n\t\trelease_mem_region(info->fix.mmio_start,\n\t\t\t\t   info->fix.mmio_len);\n\t\treturn -ENOMEM;\n\t} else\n\t\tprintk(KERN_INFO \"neofb: mapped io at %p\\n\",\n\t\t       par->mmio_vbase);\n\treturn 0;\n}\n\nstatic void neo_unmap_mmio(struct fb_info *info)\n{\n\tstruct neofb_par *par = info->par;\n\n\tDBG(\"neo_unmap_mmio\");\n\n\tiounmap(par->mmio_vbase);\n\tpar->mmio_vbase = NULL;\n\n\trelease_mem_region(info->fix.mmio_start,\n\t\t\t   info->fix.mmio_len);\n}\n\nstatic int neo_map_video(struct fb_info *info, struct pci_dev *dev,\n\t\t\t int video_len)\n{\n\t\n\tstruct neofb_par *par = info->par;\n\n\tDBG(\"neo_map_video\");\n\n\tinfo->fix.smem_start = pci_resource_start(dev, 0);\n\tinfo->fix.smem_len = video_len;\n\n\tif (!request_mem_region(info->fix.smem_start, info->fix.smem_len,\n\t\t\t\t\"frame buffer\")) {\n\t\tprintk(\"neofb: frame buffer in use\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tinfo->screen_base =\n\t    ioremap_wc(info->fix.smem_start, info->fix.smem_len);\n\tif (!info->screen_base) {\n\t\tprintk(\"neofb: unable to map screen memory\\n\");\n\t\trelease_mem_region(info->fix.smem_start,\n\t\t\t\t   info->fix.smem_len);\n\t\treturn -ENOMEM;\n\t} else\n\t\tprintk(KERN_INFO \"neofb: mapped framebuffer at %p\\n\",\n\t\t       info->screen_base);\n\n\tpar->wc_cookie = arch_phys_wc_add(info->fix.smem_start,\n\t\t\t\t\t  pci_resource_len(dev, 0));\n\n\t \n\tmemset_io(info->screen_base, 0, info->fix.smem_len);\n\n\t \n\treturn 0;\n}\n\nstatic void neo_unmap_video(struct fb_info *info)\n{\n\tstruct neofb_par *par = info->par;\n\n\tDBG(\"neo_unmap_video\");\n\n\tarch_phys_wc_del(par->wc_cookie);\n\tiounmap(info->screen_base);\n\tinfo->screen_base = NULL;\n\n\trelease_mem_region(info->fix.smem_start,\n\t\t\t   info->fix.smem_len);\n}\n\nstatic int neo_scan_monitor(struct fb_info *info)\n{\n\tstruct neofb_par *par = info->par;\n\tunsigned char type, display;\n\tint w;\n\n\t\n\tinfo->monspecs.modedb = kmalloc(sizeof(struct fb_videomode), GFP_KERNEL);\n\tif (!info->monspecs.modedb)\n\t\treturn -ENOMEM;\n\tinfo->monspecs.modedb_len = 1;\n\n\t \n\tvga_wgfx(NULL, 0x09, 0x26);\n\ttype = vga_rgfx(NULL, 0x21);\n\tdisplay = vga_rgfx(NULL, 0x20);\n\tif (!par->internal_display && !par->external_display) {\n\t\tpar->internal_display = display & 2 || !(display & 3) ? 1 : 0;\n\t\tpar->external_display = display & 1;\n\t\tprintk (KERN_INFO \"Autodetected %s display\\n\",\n\t\t\tpar->internal_display && par->external_display ? \"simultaneous\" :\n\t\t\tpar->internal_display ? \"internal\" : \"external\");\n\t}\n\n\t \n\tw = vga_rgfx(NULL, 0x20);\n\tvga_wgfx(NULL, 0x09, 0x00);\n\tswitch ((w & 0x18) >> 3) {\n\tcase 0x00:\n\t\t\n\t\tpar->NeoPanelWidth = 640;\n\t\tpar->NeoPanelHeight = 480;\n\t\tmemcpy(info->monspecs.modedb, &vesa_modes[3], sizeof(struct fb_videomode));\n\t\tbreak;\n\tcase 0x01:\n\t\tpar->NeoPanelWidth = 800;\n\t\tif (par->libretto) {\n\t\t\tpar->NeoPanelHeight = 480;\n\t\t\tmemcpy(info->monspecs.modedb, &mode800x480, sizeof(struct fb_videomode));\n\t\t} else {\n\t\t\t\n\t\t\tpar->NeoPanelHeight = 600;\n\t\t\tmemcpy(info->monspecs.modedb, &vesa_modes[8], sizeof(struct fb_videomode));\n\t\t}\n\t\tbreak;\n\tcase 0x02:\n\t\t\n\t\tpar->NeoPanelWidth = 1024;\n\t\tpar->NeoPanelHeight = 768;\n\t\tmemcpy(info->monspecs.modedb, &vesa_modes[13], sizeof(struct fb_videomode));\n\t\tbreak;\n\tcase 0x03:\n\t\t \n#ifdef NOT_DONE\n\t\tpar->NeoPanelWidth = 1280;\n\t\tpar->NeoPanelHeight = 1024;\n\t\tmemcpy(info->monspecs.modedb, &vesa_modes[20], sizeof(struct fb_videomode));\n\t\tbreak;\n#else\n\t\tprintk(KERN_ERR\n\t\t       \"neofb: Only 640x480, 800x600/480 and 1024x768 panels are currently supported\\n\");\n\t\tkfree(info->monspecs.modedb);\n\t\treturn -1;\n#endif\n\tdefault:\n\t\t\n\t\tpar->NeoPanelWidth = 640;\n\t\tpar->NeoPanelHeight = 480;\n\t\tmemcpy(info->monspecs.modedb, &vesa_modes[3], sizeof(struct fb_videomode));\n\t\tbreak;\n\t}\n\n\tprintk(KERN_INFO \"Panel is a %dx%d %s %s display\\n\",\n\t       par->NeoPanelWidth,\n\t       par->NeoPanelHeight,\n\t       (type & 0x02) ? \"color\" : \"monochrome\",\n\t       (type & 0x10) ? \"TFT\" : \"dual scan\");\n\treturn 0;\n}\n\nstatic int neo_init_hw(struct fb_info *info)\n{\n\tstruct neofb_par *par = info->par;\n\tint videoRam = 896;\n\tint maxClock = 65000;\n\tint CursorOff = 0x100;\n\n\tDBG(\"neo_init_hw\");\n\n\tneoUnlock();\n\n#if 0\n\tprintk(KERN_DEBUG \"--- Neo extended register dump ---\\n\");\n\tfor (int w = 0; w < 0x85; w++)\n\t\tprintk(KERN_DEBUG \"CR %p: %p\\n\", (void *) w,\n\t\t       (void *) vga_rcrt(NULL, w));\n\tfor (int w = 0; w < 0xC7; w++)\n\t\tprintk(KERN_DEBUG \"GR %p: %p\\n\", (void *) w,\n\t\t       (void *) vga_rgfx(NULL, w));\n#endif\n\tswitch (info->fix.accel) {\n\tcase FB_ACCEL_NEOMAGIC_NM2070:\n\t\tvideoRam = 896;\n\t\tmaxClock = 65000;\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2090:\n\tcase FB_ACCEL_NEOMAGIC_NM2093:\n\tcase FB_ACCEL_NEOMAGIC_NM2097:\n\t\tvideoRam = 1152;\n\t\tmaxClock = 80000;\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2160:\n\t\tvideoRam = 2048;\n\t\tmaxClock = 90000;\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2200:\n\t\tvideoRam = 2560;\n\t\tmaxClock = 110000;\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2230:\n\t\tvideoRam = 3008;\n\t\tmaxClock = 110000;\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2360:\n\t\tvideoRam = 4096;\n\t\tmaxClock = 110000;\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2380:\n\t\tvideoRam = 6144;\n\t\tmaxClock = 110000;\n\t\tbreak;\n\t}\n\tswitch (info->fix.accel) {\n\tcase FB_ACCEL_NEOMAGIC_NM2070:\n\tcase FB_ACCEL_NEOMAGIC_NM2090:\n\tcase FB_ACCEL_NEOMAGIC_NM2093:\n\t\tCursorOff = 0x100;\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2097:\n\tcase FB_ACCEL_NEOMAGIC_NM2160:\n\t\tCursorOff = 0x100;\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2200:\n\tcase FB_ACCEL_NEOMAGIC_NM2230:\n\tcase FB_ACCEL_NEOMAGIC_NM2360:\n\tcase FB_ACCEL_NEOMAGIC_NM2380:\n\t\tCursorOff = 0x1000;\n\n\t\tpar->neo2200 = (Neo2200 __iomem *) par->mmio_vbase;\n\t\tbreak;\n\t}\n \n\tpar->maxClock = maxClock;\n\tpar->cursorOff = CursorOff;\n\treturn videoRam * 1024;\n}\n\n\nstatic struct fb_info *neo_alloc_fb_info(struct pci_dev *dev,\n\t\t\t\t\t const struct pci_device_id *id)\n{\n\tstruct fb_info *info;\n\tstruct neofb_par *par;\n\n\tinfo = framebuffer_alloc(sizeof(struct neofb_par), &dev->dev);\n\n\tif (!info)\n\t\treturn NULL;\n\n\tpar = info->par;\n\n\tinfo->fix.accel = id->driver_data;\n\n\tpar->pci_burst = !nopciburst;\n\tpar->lcd_stretch = !nostretch;\n\tpar->libretto = libretto;\n\n\tpar->internal_display = internal;\n\tpar->external_display = external;\n\tinfo->flags = FBINFO_HWACCEL_YPAN;\n\n\tswitch (info->fix.accel) {\n\tcase FB_ACCEL_NEOMAGIC_NM2070:\n\t\tstrscpy(info->fix.id, \"MagicGraph128\", sizeof(info->fix.id));\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2090:\n\t\tstrscpy(info->fix.id, \"MagicGraph128V\", sizeof(info->fix.id));\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2093:\n\t\tstrscpy(info->fix.id, \"MagicGraph128ZV\", sizeof(info->fix.id));\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2097:\n\t\tstrscpy(info->fix.id, \"Mag.Graph128ZV+\", sizeof(info->fix.id));\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2160:\n\t\tstrscpy(info->fix.id, \"MagicGraph128XD\", sizeof(info->fix.id));\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2200:\n\t\tstrscpy(info->fix.id, \"MagicGraph256AV\", sizeof(info->fix.id));\n\t\tinfo->flags |= FBINFO_HWACCEL_IMAGEBLIT |\n\t\t               FBINFO_HWACCEL_COPYAREA |\n                \t       FBINFO_HWACCEL_FILLRECT;\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2230:\n\t\tstrscpy(info->fix.id, \"Mag.Graph256AV+\", sizeof(info->fix.id));\n\t\tinfo->flags |= FBINFO_HWACCEL_IMAGEBLIT |\n\t\t               FBINFO_HWACCEL_COPYAREA |\n                \t       FBINFO_HWACCEL_FILLRECT;\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2360:\n\t\tstrscpy(info->fix.id, \"MagicGraph256ZX\", sizeof(info->fix.id));\n\t\tinfo->flags |= FBINFO_HWACCEL_IMAGEBLIT |\n\t\t               FBINFO_HWACCEL_COPYAREA |\n                \t       FBINFO_HWACCEL_FILLRECT;\n\t\tbreak;\n\tcase FB_ACCEL_NEOMAGIC_NM2380:\n\t\tstrscpy(info->fix.id, \"Mag.Graph256XL+\", sizeof(info->fix.id));\n\t\tinfo->flags |= FBINFO_HWACCEL_IMAGEBLIT |\n\t\t               FBINFO_HWACCEL_COPYAREA |\n                \t       FBINFO_HWACCEL_FILLRECT;\n\t\tbreak;\n\t}\n\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.type_aux = 0;\n\tinfo->fix.xpanstep = 0;\n\tinfo->fix.ypanstep = 4;\n\tinfo->fix.ywrapstep = 0;\n\tinfo->fix.accel = id->driver_data;\n\n\tinfo->fbops = &neofb_ops;\n\tinfo->pseudo_palette = par->palette;\n\treturn info;\n}\n\nstatic void neo_free_fb_info(struct fb_info *info)\n{\n\tif (info) {\n\t\t \n\t\tfb_dealloc_cmap(&info->cmap);\n\t\tframebuffer_release(info);\n\t}\n}\n\n \n\nstatic int neofb_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct fb_info *info;\n\tu_int h_sync, v_sync;\n\tint video_len, err;\n\n\tDBG(\"neofb_probe\");\n\n\terr = aperture_remove_conflicting_pci_devices(dev, \"neofb\");\n\tif (err)\n\t\treturn err;\n\n\terr = pci_enable_device(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tinfo = neo_alloc_fb_info(dev, id);\n\tif (!info)\n\t\treturn err;\n\n\terr = neo_map_mmio(info, dev);\n\tif (err)\n\t\tgoto err_map_mmio;\n\n\terr = neo_scan_monitor(info);\n\tif (err)\n\t\tgoto err_scan_monitor;\n\n\tvideo_len = neo_init_hw(info);\n\tif (video_len < 0) {\n\t\terr = video_len;\n\t\tgoto err_init_hw;\n\t}\n\n\terr = neo_map_video(info, dev, video_len);\n\tif (err)\n\t\tgoto err_init_hw;\n\n\tif (!fb_find_mode(&info->var, info, mode_option, NULL, 0,\n\t\t\tinfo->monspecs.modedb, 16)) {\n\t\tprintk(KERN_ERR \"neofb: Unable to find usable video mode.\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_map_video;\n\t}\n\n\t \n\th_sync = 1953125000 / info->var.pixclock;\n\th_sync =\n\t    h_sync * 512 / (info->var.xres + info->var.left_margin +\n\t\t\t    info->var.right_margin + info->var.hsync_len);\n\tv_sync =\n\t    h_sync / (info->var.yres + info->var.upper_margin +\n\t\t      info->var.lower_margin + info->var.vsync_len);\n\n\tprintk(KERN_INFO \"neofb v\" NEOFB_VERSION\n\t       \": %dkB VRAM, using %dx%d, %d.%03dkHz, %dHz\\n\",\n\t       info->fix.smem_len >> 10, info->var.xres,\n\t       info->var.yres, h_sync / 1000, h_sync % 1000, v_sync);\n\n\terr = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (err < 0)\n\t\tgoto err_map_video;\n\n\terr = register_framebuffer(info);\n\tif (err < 0)\n\t\tgoto err_reg_fb;\n\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\n\t \n\tpci_set_drvdata(dev, info);\n\treturn 0;\n\nerr_reg_fb:\n\tfb_dealloc_cmap(&info->cmap);\nerr_map_video:\n\tneo_unmap_video(info);\nerr_init_hw:\n\tfb_destroy_modedb(info->monspecs.modedb);\nerr_scan_monitor:\n\tneo_unmap_mmio(info);\nerr_map_mmio:\n\tneo_free_fb_info(info);\n\treturn err;\n}\n\nstatic void neofb_remove(struct pci_dev *dev)\n{\n\tstruct fb_info *info = pci_get_drvdata(dev);\n\n\tDBG(\"neofb_remove\");\n\n\tif (info) {\n\t\tunregister_framebuffer(info);\n\n\t\tneo_unmap_video(info);\n\t\tfb_destroy_modedb(info->monspecs.modedb);\n\t\tneo_unmap_mmio(info);\n\t\tneo_free_fb_info(info);\n\t}\n}\n\nstatic const struct pci_device_id neofb_devices[] = {\n\t{PCI_VENDOR_ID_NEOMAGIC, PCI_CHIP_NM2070,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_NEOMAGIC_NM2070},\n\n\t{PCI_VENDOR_ID_NEOMAGIC, PCI_CHIP_NM2090,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_NEOMAGIC_NM2090},\n\n\t{PCI_VENDOR_ID_NEOMAGIC, PCI_CHIP_NM2093,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_NEOMAGIC_NM2093},\n\n\t{PCI_VENDOR_ID_NEOMAGIC, PCI_CHIP_NM2097,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_NEOMAGIC_NM2097},\n\n\t{PCI_VENDOR_ID_NEOMAGIC, PCI_CHIP_NM2160,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_NEOMAGIC_NM2160},\n\n\t{PCI_VENDOR_ID_NEOMAGIC, PCI_CHIP_NM2200,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_NEOMAGIC_NM2200},\n\n\t{PCI_VENDOR_ID_NEOMAGIC, PCI_CHIP_NM2230,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_NEOMAGIC_NM2230},\n\n\t{PCI_VENDOR_ID_NEOMAGIC, PCI_CHIP_NM2360,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_NEOMAGIC_NM2360},\n\n\t{PCI_VENDOR_ID_NEOMAGIC, PCI_CHIP_NM2380,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, FB_ACCEL_NEOMAGIC_NM2380},\n\n\t{0, 0, 0, 0, 0, 0, 0}\n};\n\nMODULE_DEVICE_TABLE(pci, neofb_devices);\n\nstatic struct pci_driver neofb_driver = {\n\t.name =\t\t\"neofb\",\n\t.id_table =\tneofb_devices,\n\t.probe =\tneofb_probe,\n\t.remove =\tneofb_remove,\n};\n\n \n\n#ifndef MODULE\nstatic int __init neofb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tDBG(\"neofb_setup\");\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\n\t\tif (!strncmp(this_opt, \"internal\", 8))\n\t\t\tinternal = 1;\n\t\telse if (!strncmp(this_opt, \"external\", 8))\n\t\t\texternal = 1;\n\t\telse if (!strncmp(this_opt, \"nostretch\", 9))\n\t\t\tnostretch = 1;\n\t\telse if (!strncmp(this_opt, \"nopciburst\", 10))\n\t\t\tnopciburst = 1;\n\t\telse if (!strncmp(this_opt, \"libretto\", 8))\n\t\t\tlibretto = 1;\n\t\telse\n\t\t\tmode_option = this_opt;\n\t}\n\treturn 0;\n}\n#endif   \n\nstatic int __init neofb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"neofb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"neofb\", &option))\n\t\treturn -ENODEV;\n\tneofb_setup(option);\n#endif\n\treturn pci_register_driver(&neofb_driver);\n}\n\nmodule_init(neofb_init);\n\n#ifdef MODULE\nstatic void __exit neofb_exit(void)\n{\n\tpci_unregister_driver(&neofb_driver);\n}\n\nmodule_exit(neofb_exit);\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}