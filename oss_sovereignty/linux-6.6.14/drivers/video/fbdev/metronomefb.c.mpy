{
  "module_name": "metronomefb.c",
  "hash_id": "2331925ed1187ba9a3abe3b45169ed52bd617ad329fd40620166af959a5639c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/metronomefb.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/list.h>\n#include <linux/firmware.h>\n#include <linux/dma-mapping.h>\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n\n#include <video/metronomefb.h>\n\n#include <asm/unaligned.h>\n\n \n#define DPY_W 832\n#define DPY_H 622\n\nstatic int user_wfm_size;\n\n \nstruct epd_frame {\n\tint fw;  \n\tint fh;  \n\tu16 config[4];\n\tint wfm_size;\n};\n\nstatic struct epd_frame epd_frame_table[] = {\n\t{\n\t\t.fw = 832,\n\t\t.fh = 622,\n\t\t.config = {\n\t\t\t15  \n\t\t\t| 2 << 8  \n\t\t\t| 0 << 11  \n\t\t\t| 0 << 12  \n\t\t\t| 0 << 15,  \n\t\t\t42  \n\t\t\t| 1 << 8  \n\t\t\t| 1 << 9  \n\t\t\t| 0 << 15,  \n\t\t\t18  \n\t\t\t| 0 << 15,  \n\t\t\t599  \n\t\t\t| 0 << 11  \n\t\t\t| 0 << 12,  \n\t\t},\n\t\t.wfm_size = 47001,\n\t},\n\t{\n\t\t.fw = 1088,\n\t\t.fh = 791,\n\t\t.config = {\n\t\t\t0x0104,\n\t\t\t0x031f,\n\t\t\t0x0088,\n\t\t\t0x02ff,\n\t\t},\n\t\t.wfm_size = 46770,\n\t},\n\t{\n\t\t.fw = 1200,\n\t\t.fh = 842,\n\t\t.config = {\n\t\t\t0x0101,\n\t\t\t0x030e,\n\t\t\t0x0012,\n\t\t\t0x0280,\n\t\t},\n\t\t.wfm_size = 46770,\n\t},\n};\n\nstatic struct fb_fix_screeninfo metronomefb_fix = {\n\t.id =\t\t\"metronomefb\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_STATIC_PSEUDOCOLOR,\n\t.xpanstep =\t0,\n\t.ypanstep =\t0,\n\t.ywrapstep =\t0,\n\t.line_length =\tDPY_W,\n\t.accel =\tFB_ACCEL_NONE,\n};\n\nstatic struct fb_var_screeninfo metronomefb_var = {\n\t.xres\t\t= DPY_W,\n\t.yres\t\t= DPY_H,\n\t.xres_virtual\t= DPY_W,\n\t.yres_virtual\t= DPY_H,\n\t.bits_per_pixel\t= 8,\n\t.grayscale\t= 1,\n\t.nonstd\t\t= 1,\n\t.red =\t\t{ 4, 3, 0 },\n\t.green =\t{ 0, 0, 0 },\n\t.blue =\t\t{ 0, 0, 0 },\n\t.transp =\t{ 0, 0, 0 },\n};\n\n \nstruct waveform_hdr {\n\tu8 stuff[32];\n\n\tu8 wmta[3];\n\tu8 fvsn;\n\n\tu8 luts;\n\tu8 mc;\n\tu8 trc;\n\tu8 stuff3;\n\n\tu8 endb;\n\tu8 swtb;\n\tu8 stuff2a[2];\n\n\tu8 stuff2b[3];\n\tu8 wfm_cs;\n} __attribute__ ((packed));\n\n \nstatic u8 calc_cksum(int start, int end, u8 *mem)\n{\n\tu8 tmp = 0;\n\tint i;\n\n\tfor (i = start; i < end; i++)\n\t\ttmp += mem[i];\n\n\treturn tmp;\n}\n\nstatic u16 calc_img_cksum(u16 *start, int length)\n{\n\tu16 tmp = 0;\n\n\twhile (length--)\n\t\ttmp += *start++;\n\n\treturn tmp;\n}\n\n \nstatic int load_waveform(u8 *mem, size_t size, int m, int t,\n\t\t\t struct metronomefb_par *par)\n{\n\tint tta;\n\tint wmta;\n\tint trn = 0;\n\tint i;\n\tunsigned char v;\n\tu8 cksum;\n\tint cksum_idx;\n\tint wfm_idx, owfm_idx;\n\tint mem_idx = 0;\n\tstruct waveform_hdr *wfm_hdr;\n\tu8 *metromem = par->metromem_wfm;\n\tstruct device *dev = par->info->device;\n\n\tif (user_wfm_size)\n\t\tepd_frame_table[par->dt].wfm_size = user_wfm_size;\n\n\tif (size != epd_frame_table[par->dt].wfm_size) {\n\t\tdev_err(dev, \"Error: unexpected size %zd != %d\\n\", size,\n\t\t\t\t\tepd_frame_table[par->dt].wfm_size);\n\t\treturn -EINVAL;\n\t}\n\n\twfm_hdr = (struct waveform_hdr *) mem;\n\n\tif (wfm_hdr->fvsn != 1) {\n\t\tdev_err(dev, \"Error: bad fvsn %x\\n\", wfm_hdr->fvsn);\n\t\treturn -EINVAL;\n\t}\n\tif (wfm_hdr->luts != 0) {\n\t\tdev_err(dev, \"Error: bad luts %x\\n\", wfm_hdr->luts);\n\t\treturn -EINVAL;\n\t}\n\tcksum = calc_cksum(32, 47, mem);\n\tif (cksum != wfm_hdr->wfm_cs) {\n\t\tdev_err(dev, \"Error: bad cksum %x != %x\\n\", cksum,\n\t\t\t\t\twfm_hdr->wfm_cs);\n\t\treturn -EINVAL;\n\t}\n\twfm_hdr->mc += 1;\n\twfm_hdr->trc += 1;\n\tfor (i = 0; i < 5; i++) {\n\t\tif (*(wfm_hdr->stuff2a + i) != 0) {\n\t\t\tdev_err(dev, \"Error: unexpected value in padding\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif ((sizeof(*wfm_hdr) + wfm_hdr->trc) > size)\n\t\treturn -EINVAL;\n\n\tfor (i = sizeof(*wfm_hdr); i <= sizeof(*wfm_hdr) + wfm_hdr->trc; i++) {\n\t\tif (mem[i] > t) {\n\t\t\ttrn = i - sizeof(*wfm_hdr) - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tcksum_idx = sizeof(*wfm_hdr) + wfm_hdr->trc + 1;\n\tif (cksum_idx >= size)\n\t\treturn -EINVAL;\n\tcksum = calc_cksum(sizeof(*wfm_hdr), cksum_idx, mem);\n\tif (cksum != mem[cksum_idx]) {\n\t\tdev_err(dev, \"Error: bad temperature range table cksum\"\n\t\t\t\t\" %x != %x\\n\", cksum, mem[cksum_idx]);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twmta = get_unaligned_le32(wfm_hdr->wmta) & 0x00FFFFFF;\n\tcksum_idx = wmta + m*4 + 3;\n\tif (cksum_idx >= size)\n\t\treturn -EINVAL;\n\tcksum = calc_cksum(cksum_idx - 3, cksum_idx, mem);\n\tif (cksum != mem[cksum_idx]) {\n\t\tdev_err(dev, \"Error: bad mode table address cksum\"\n\t\t\t\t\" %x != %x\\n\", cksum, mem[cksum_idx]);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttta = get_unaligned_le32(mem + wmta + m * 4) & 0x00FFFFFF;\n\tcksum_idx = tta + trn*4 + 3;\n\tif (cksum_idx >= size)\n\t\treturn -EINVAL;\n\tcksum = calc_cksum(cksum_idx - 3, cksum_idx, mem);\n\tif (cksum != mem[cksum_idx]) {\n\t\tdev_err(dev, \"Error: bad temperature table address cksum\"\n\t\t\t\" %x != %x\\n\", cksum, mem[cksum_idx]);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twfm_idx = get_unaligned_le32(mem + tta + trn * 4) & 0x00FFFFFF;\n\towfm_idx = wfm_idx;\n\tif (wfm_idx >= size)\n\t\treturn -EINVAL;\n\twhile (wfm_idx < size) {\n\t\tunsigned char rl;\n\t\tv = mem[wfm_idx++];\n\t\tif (v == wfm_hdr->swtb) {\n\t\t\twhile (((v = mem[wfm_idx++]) != wfm_hdr->swtb) &&\n\t\t\t\twfm_idx < size)\n\t\t\t\tmetromem[mem_idx++] = v;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (v == wfm_hdr->endb)\n\t\t\tbreak;\n\n\t\trl = mem[wfm_idx++];\n\t\tfor (i = 0; i <= rl; i++)\n\t\t\tmetromem[mem_idx++] = v;\n\t}\n\n\tcksum_idx = wfm_idx;\n\tif (cksum_idx >= size)\n\t\treturn -EINVAL;\n\tcksum = calc_cksum(owfm_idx, cksum_idx, mem);\n\tif (cksum != mem[cksum_idx]) {\n\t\tdev_err(dev, \"Error: bad waveform data cksum\"\n\t\t\t\t\" %x != %x\\n\", cksum, mem[cksum_idx]);\n\t\treturn -EINVAL;\n\t}\n\tpar->frame_count = (mem_idx/64);\n\n\treturn 0;\n}\n\nstatic int metronome_display_cmd(struct metronomefb_par *par)\n{\n\tint i;\n\tu16 cs;\n\tu16 opcode;\n\tstatic u8 borderval;\n\n\t \n\n\tif (par->metromem_cmd->opcode == 0xCC40)\n\t\topcode = cs = 0xCC41;\n\telse\n\t\topcode = cs = 0xCC40;\n\n\t \n\ti = 0;\n\tpar->metromem_cmd->args[i] = \t1 << 3  \n\t\t\t\t\t| ((borderval++ % 4) & 0x0F) << 4\n\t\t\t\t\t| (par->frame_count - 1) << 8;\n\tcs += par->metromem_cmd->args[i++];\n\n\t \n\tmemset((u8 *) (par->metromem_cmd->args + i), 0, (32-i)*2);\n\n\tpar->metromem_cmd->csum = cs;\n\tpar->metromem_cmd->opcode = opcode;  \n\n\treturn par->board->met_wait_event_intr(par);\n}\n\nstatic int metronome_powerup_cmd(struct metronomefb_par *par)\n{\n\tint i;\n\tu16 cs;\n\n\t \n\tpar->metromem_cmd->opcode = 0x1234;  \n\tcs = par->metromem_cmd->opcode;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tpar->metromem_cmd->args[i] = 1024;\n\t\tcs += par->metromem_cmd->args[i];\n\t}\n\n\t \n\tmemset(&par->metromem_cmd->args[i], 0,\n\t       (ARRAY_SIZE(par->metromem_cmd->args) - i) * 2);\n\n\tpar->metromem_cmd->csum = cs;\n\n\tmsleep(1);\n\tpar->board->set_rst(par, 1);\n\n\tmsleep(1);\n\tpar->board->set_stdby(par, 1);\n\n\treturn par->board->met_wait_event(par);\n}\n\nstatic int metronome_config_cmd(struct metronomefb_par *par)\n{\n\t \n\n\tmemcpy(par->metromem_cmd->args, epd_frame_table[par->dt].config,\n\t\tsizeof(epd_frame_table[par->dt].config));\n\t \n\tmemset(&par->metromem_cmd->args[4], 0,\n\t       (ARRAY_SIZE(par->metromem_cmd->args) - 4) * 2);\n\n\tpar->metromem_cmd->csum = 0xCC10;\n\tpar->metromem_cmd->csum += calc_img_cksum(par->metromem_cmd->args, 4);\n\tpar->metromem_cmd->opcode = 0xCC10;  \n\n\treturn par->board->met_wait_event(par);\n}\n\nstatic int metronome_init_cmd(struct metronomefb_par *par)\n{\n\tint i;\n\tu16 cs;\n\n\t \n\n\tcs = 0xCC20;\n\n\t \n\ti = 0;\n\tpar->metromem_cmd->args[i] = 0;\n\tcs += par->metromem_cmd->args[i++];\n\n\t \n\tmemset((u8 *) (par->metromem_cmd->args + i), 0, (32-i)*2);\n\n\tpar->metromem_cmd->csum = cs;\n\tpar->metromem_cmd->opcode = 0xCC20;  \n\n\treturn par->board->met_wait_event(par);\n}\n\nstatic int metronome_init_regs(struct metronomefb_par *par)\n{\n\tint res;\n\n\tres = par->board->setup_io(par);\n\tif (res)\n\t\treturn res;\n\n\tres = metronome_powerup_cmd(par);\n\tif (res)\n\t\treturn res;\n\n\tres = metronome_config_cmd(par);\n\tif (res)\n\t\treturn res;\n\n\tres = metronome_init_cmd(par);\n\n\treturn res;\n}\n\nstatic void metronomefb_dpy_update(struct metronomefb_par *par)\n{\n\tint fbsize;\n\tu16 cksum;\n\tunsigned char *buf = par->info->screen_buffer;\n\n\tfbsize = par->info->fix.smem_len;\n\t \n\tmemcpy(par->metromem_img, buf, fbsize);\n\n\tcksum = calc_img_cksum((u16 *) par->metromem_img, fbsize/2);\n\t*((u16 *)(par->metromem_img) + fbsize/2) = cksum;\n\tmetronome_display_cmd(par);\n}\n\nstatic u16 metronomefb_dpy_update_page(struct metronomefb_par *par, int index)\n{\n\tint i;\n\tu16 csum = 0;\n\tu16 *buf = (u16 *)(par->info->screen_buffer + index);\n\tu16 *img = (u16 *)(par->metromem_img + index);\n\n\t \n\tfor (i = 0; i < PAGE_SIZE/2; i++) {\n\t\t*(img + i) = (buf[i] << 5) & 0xE0E0;\n\t\tcsum += *(img + i);\n\t}\n\treturn csum;\n}\n\n \nstatic void metronomefb_dpy_deferred_io(struct fb_info *info, struct list_head *pagereflist)\n{\n\tu16 cksum;\n\tstruct fb_deferred_io_pageref *pageref;\n\tstruct metronomefb_par *par = info->par;\n\n\t \n\tlist_for_each_entry(pageref, pagereflist, list) {\n\t\tunsigned long pgoffset = pageref->offset >> PAGE_SHIFT;\n\t\tcksum = metronomefb_dpy_update_page(par, pageref->offset);\n\t\tpar->metromem_img_csum -= par->csum_table[pgoffset];\n\t\tpar->csum_table[pgoffset] = cksum;\n\t\tpar->metromem_img_csum += cksum;\n\t}\n\n\tmetronome_display_cmd(par);\n}\n\nstatic void metronomefb_defio_damage_range(struct fb_info *info, off_t off, size_t len)\n{\n\tstruct metronomefb_par *par = info->par;\n\n\tmetronomefb_dpy_update(par);\n}\n\nstatic void metronomefb_defio_damage_area(struct fb_info *info, u32 x, u32 y,\n\t\t\t\t\t  u32 width, u32 height)\n{\n\tstruct metronomefb_par *par = info->par;\n\n\tmetronomefb_dpy_update(par);\n}\n\nFB_GEN_DEFAULT_DEFERRED_SYSMEM_OPS(metronomefb,\n\t\t\t\t   metronomefb_defio_damage_range,\n\t\t\t\t   metronomefb_defio_damage_area)\n\nstatic const struct fb_ops metronomefb_ops = {\n\t.owner\t= THIS_MODULE,\n\tFB_DEFAULT_DEFERRED_OPS(metronomefb),\n};\n\nstatic struct fb_deferred_io metronomefb_defio = {\n\t.delay\t\t\t= HZ,\n\t.sort_pagereflist\t= true,\n\t.deferred_io\t\t= metronomefb_dpy_deferred_io,\n};\n\nstatic int metronomefb_probe(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\tstruct metronome_board *board;\n\tint retval = -ENOMEM;\n\tint videomemorysize;\n\tunsigned char *videomemory;\n\tstruct metronomefb_par *par;\n\tconst struct firmware *fw_entry;\n\tint i;\n\tint panel_type;\n\tint fw, fh;\n\tint epd_dt_index;\n\n\t \n\tboard = dev->dev.platform_data;\n\tif (!board)\n\t\treturn -EINVAL;\n\n\t \n\tif (!try_module_get(board->owner))\n\t\treturn -ENODEV;\n\n\tinfo = framebuffer_alloc(sizeof(struct metronomefb_par), &dev->dev);\n\tif (!info)\n\t\tgoto err;\n\n\t \n\n\tpanel_type = board->get_panel_type();\n\tswitch (panel_type) {\n\tcase 6:\n\t\tepd_dt_index = 0;\n\t\tbreak;\n\tcase 8:\n\t\tepd_dt_index = 1;\n\t\tbreak;\n\tcase 97:\n\t\tepd_dt_index = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->dev, \"Unexpected panel type. Defaulting to 6\\n\");\n\t\tepd_dt_index = 0;\n\t\tbreak;\n\t}\n\n\tfw = epd_frame_table[epd_dt_index].fw;\n\tfh = epd_frame_table[epd_dt_index].fh;\n\n\t \n\tvideomemorysize = PAGE_SIZE + (fw * fh);\n\tvideomemory = vzalloc(videomemorysize);\n\tif (!videomemory)\n\t\tgoto err_fb_rel;\n\n\tinfo->screen_buffer = videomemory;\n\tinfo->fbops = &metronomefb_ops;\n\n\tmetronomefb_fix.line_length = fw;\n\tmetronomefb_var.xres = fw;\n\tmetronomefb_var.yres = fh;\n\tmetronomefb_var.xres_virtual = fw;\n\tmetronomefb_var.yres_virtual = fh;\n\tinfo->var = metronomefb_var;\n\tinfo->fix = metronomefb_fix;\n\tinfo->fix.smem_len = videomemorysize;\n\tpar = info->par;\n\tpar->info = info;\n\tpar->board = board;\n\tpar->dt = epd_dt_index;\n\tinit_waitqueue_head(&par->waitq);\n\n\t \n\tpar->csum_table = vmalloc(videomemorysize/PAGE_SIZE);\n\tif (!par->csum_table)\n\t\tgoto err_vfree;\n\n\t \n\tretval = board->setup_fb(par);\n\tif (retval) {\n\t\tdev_err(&dev->dev, \"Failed to setup fb\\n\");\n\t\tgoto err_csum_table;\n\t}\n\n\t \n\tif ((!par->metromem_wfm) ||  (!par->metromem_img) ||\n\t\t(!par->metromem_dma)) {\n\t\tdev_err(&dev->dev, \"fb access failure\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_csum_table;\n\t}\n\n\tinfo->fix.smem_start = par->metromem_dma;\n\n\t \n\tretval = request_firmware(&fw_entry, \"metronome.wbf\", &dev->dev);\n\tif (retval < 0) {\n\t\tdev_err(&dev->dev, \"Failed to get waveform\\n\");\n\t\tgoto err_csum_table;\n\t}\n\n\tretval = load_waveform((u8 *) fw_entry->data, fw_entry->size, 3, 31,\n\t\t\t\tpar);\n\trelease_firmware(fw_entry);\n\tif (retval < 0) {\n\t\tdev_err(&dev->dev, \"Failed processing waveform\\n\");\n\t\tgoto err_csum_table;\n\t}\n\n\tretval = board->setup_irq(info);\n\tif (retval)\n\t\tgoto err_csum_table;\n\n\tretval = metronome_init_regs(par);\n\tif (retval < 0)\n\t\tgoto err_free_irq;\n\n\tinfo->flags = FBINFO_VIRTFB;\n\n\tinfo->fbdefio = &metronomefb_defio;\n\tfb_deferred_io_init(info);\n\n\tretval = fb_alloc_cmap(&info->cmap, 8, 0);\n\tif (retval < 0) {\n\t\tdev_err(&dev->dev, \"Failed to allocate colormap\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\t \n\tfor (i = 0; i < 8; i++)\n\t\tinfo->cmap.red[i] = (((2*i)+1)*(0xFFFF))/16;\n\tmemcpy(info->cmap.green, info->cmap.red, sizeof(u16)*8);\n\tmemcpy(info->cmap.blue, info->cmap.red, sizeof(u16)*8);\n\n\tretval = register_framebuffer(info);\n\tif (retval < 0)\n\t\tgoto err_cmap;\n\n\tplatform_set_drvdata(dev, info);\n\n\tdev_dbg(&dev->dev,\n\t\t\"fb%d: Metronome frame buffer device, using %dK of video\"\n\t\t\" memory\\n\", info->node, videomemorysize >> 10);\n\n\treturn 0;\n\nerr_cmap:\n\tfb_dealloc_cmap(&info->cmap);\nerr_free_irq:\n\tboard->cleanup(par);\nerr_csum_table:\n\tvfree(par->csum_table);\nerr_vfree:\n\tvfree(videomemory);\nerr_fb_rel:\n\tframebuffer_release(info);\nerr:\n\tmodule_put(board->owner);\n\treturn retval;\n}\n\nstatic void metronomefb_remove(struct platform_device *dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\n\tif (info) {\n\t\tstruct metronomefb_par *par = info->par;\n\n\t\tunregister_framebuffer(info);\n\t\tfb_deferred_io_cleanup(info);\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\tpar->board->cleanup(par);\n\t\tvfree(par->csum_table);\n\t\tvfree(info->screen_buffer);\n\t\tmodule_put(par->board->owner);\n\t\tdev_dbg(&dev->dev, \"calling release\\n\");\n\t\tframebuffer_release(info);\n\t}\n}\n\nstatic struct platform_driver metronomefb_driver = {\n\t.probe\t= metronomefb_probe,\n\t.remove_new = metronomefb_remove,\n\t.driver\t= {\n\t\t.name\t= \"metronomefb\",\n\t},\n};\nmodule_platform_driver(metronomefb_driver);\n\nmodule_param(user_wfm_size, uint, 0);\nMODULE_PARM_DESC(user_wfm_size, \"Set custom waveform size\");\n\nMODULE_DESCRIPTION(\"fbdev driver for Metronome controller\");\nMODULE_AUTHOR(\"Jaya Kumar\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(\"metronome.wbf\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}