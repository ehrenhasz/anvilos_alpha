{
  "module_name": "cyber2000fb.c",
  "hash_id": "78e273f4a426503249206c7bf3137d49c789a9732e21a2b0f02bb4e7576a97d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/cyber2000fb.c",
  "human_readable_source": "\n \n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n\n#ifdef __arm__\n#include <asm/mach-types.h>\n#endif\n\n#include \"cyber2000fb.h\"\n\nstruct cfb_info {\n\tstruct fb_info\t\tfb;\n\tstruct display_switch\t*dispsw;\n\tunsigned char\t\t__iomem *region;\n\tunsigned char\t\t__iomem *regs;\n\tu_int\t\t\tid;\n\tu_int\t\t\tirq;\n\tint\t\t\tfunc_use_count;\n\tu_long\t\t\tref_ps;\n\n\t \n\tu_int\t\t\tdivisors[4];\n\n\tstruct {\n\t\tu8 red, green, blue;\n\t} palette[NR_PALETTE];\n\n\tu_char\t\t\tmem_ctl1;\n\tu_char\t\t\tmem_ctl2;\n\tu_char\t\t\tmclk_mult;\n\tu_char\t\t\tmclk_div;\n\t \n\tu_char\t\t\tramdac_ctrl;\n\tu_char\t\t\tramdac_powerdown;\n\n\tu32\t\t\tpseudo_palette[16];\n\n\tspinlock_t\t\treg_b0_lock;\n\n#ifdef CONFIG_FB_CYBER2000_DDC\n\tbool\t\t\tddc_registered;\n\tstruct i2c_adapter\tddc_adapter;\n\tstruct i2c_algo_bit_data\tddc_algo;\n#endif\n\n#ifdef CONFIG_FB_CYBER2000_I2C\n\tstruct i2c_adapter\ti2c_adapter;\n\tstruct i2c_algo_bit_data i2c_algo;\n#endif\n};\n\nstatic char *default_font = \"Acorn8x8\";\nmodule_param(default_font, charp, 0);\nMODULE_PARM_DESC(default_font, \"Default font name\");\n\n \n#define cyber2000fb_writel(val, reg, cfb)\twritel(val, (cfb)->regs + (reg))\n#define cyber2000fb_writew(val, reg, cfb)\twritew(val, (cfb)->regs + (reg))\n#define cyber2000fb_writeb(val, reg, cfb)\twriteb(val, (cfb)->regs + (reg))\n\n#define cyber2000fb_readb(reg, cfb)\t\treadb((cfb)->regs + (reg))\n\nstatic inline void\ncyber2000_crtcw(unsigned int reg, unsigned int val, struct cfb_info *cfb)\n{\n\tcyber2000fb_writew((reg & 255) | val << 8, 0x3d4, cfb);\n}\n\nstatic inline void\ncyber2000_grphw(unsigned int reg, unsigned int val, struct cfb_info *cfb)\n{\n\tcyber2000fb_writew((reg & 255) | val << 8, 0x3ce, cfb);\n}\n\nstatic inline unsigned int\ncyber2000_grphr(unsigned int reg, struct cfb_info *cfb)\n{\n\tcyber2000fb_writeb(reg, 0x3ce, cfb);\n\treturn cyber2000fb_readb(0x3cf, cfb);\n}\n\nstatic inline void\ncyber2000_attrw(unsigned int reg, unsigned int val, struct cfb_info *cfb)\n{\n\tcyber2000fb_readb(0x3da, cfb);\n\tcyber2000fb_writeb(reg, 0x3c0, cfb);\n\tcyber2000fb_readb(0x3c1, cfb);\n\tcyber2000fb_writeb(val, 0x3c0, cfb);\n}\n\nstatic inline void\ncyber2000_seqw(unsigned int reg, unsigned int val, struct cfb_info *cfb)\n{\n\tcyber2000fb_writew((reg & 255) | val << 8, 0x3c4, cfb);\n}\n\n \n\n \nstatic void\ncyber2000fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct cfb_info *cfb = container_of(info, struct cfb_info, fb);\n\tunsigned long dst, col;\n\n\tif (!(cfb->fb.var.accel_flags & FB_ACCELF_TEXT)) {\n\t\tcfb_fillrect(info, rect);\n\t\treturn;\n\t}\n\n\tcyber2000fb_writeb(0, CO_REG_CONTROL, cfb);\n\tcyber2000fb_writew(rect->width - 1, CO_REG_PIXWIDTH, cfb);\n\tcyber2000fb_writew(rect->height - 1, CO_REG_PIXHEIGHT, cfb);\n\n\tcol = rect->color;\n\tif (cfb->fb.var.bits_per_pixel > 8)\n\t\tcol = ((u32 *)cfb->fb.pseudo_palette)[col];\n\tcyber2000fb_writel(col, CO_REG_FGCOLOUR, cfb);\n\n\tdst = rect->dx + rect->dy * cfb->fb.var.xres_virtual;\n\tif (cfb->fb.var.bits_per_pixel == 24) {\n\t\tcyber2000fb_writeb(dst, CO_REG_X_PHASE, cfb);\n\t\tdst *= 3;\n\t}\n\n\tcyber2000fb_writel(dst, CO_REG_DEST_PTR, cfb);\n\tcyber2000fb_writeb(CO_FG_MIX_SRC, CO_REG_FGMIX, cfb);\n\tcyber2000fb_writew(CO_CMD_L_PATTERN_FGCOL, CO_REG_CMD_L, cfb);\n\tcyber2000fb_writew(CO_CMD_H_BLITTER, CO_REG_CMD_H, cfb);\n}\n\nstatic void\ncyber2000fb_copyarea(struct fb_info *info, const struct fb_copyarea *region)\n{\n\tstruct cfb_info *cfb = container_of(info, struct cfb_info, fb);\n\tunsigned int cmd = CO_CMD_L_PATTERN_FGCOL;\n\tunsigned long src, dst;\n\n\tif (!(cfb->fb.var.accel_flags & FB_ACCELF_TEXT)) {\n\t\tcfb_copyarea(info, region);\n\t\treturn;\n\t}\n\n\tcyber2000fb_writeb(0, CO_REG_CONTROL, cfb);\n\tcyber2000fb_writew(region->width - 1, CO_REG_PIXWIDTH, cfb);\n\tcyber2000fb_writew(region->height - 1, CO_REG_PIXHEIGHT, cfb);\n\n\tsrc = region->sx + region->sy * cfb->fb.var.xres_virtual;\n\tdst = region->dx + region->dy * cfb->fb.var.xres_virtual;\n\n\tif (region->sx < region->dx) {\n\t\tsrc += region->width - 1;\n\t\tdst += region->width - 1;\n\t\tcmd |= CO_CMD_L_INC_LEFT;\n\t}\n\n\tif (region->sy < region->dy) {\n\t\tsrc += (region->height - 1) * cfb->fb.var.xres_virtual;\n\t\tdst += (region->height - 1) * cfb->fb.var.xres_virtual;\n\t\tcmd |= CO_CMD_L_INC_UP;\n\t}\n\n\tif (cfb->fb.var.bits_per_pixel == 24) {\n\t\tcyber2000fb_writeb(dst, CO_REG_X_PHASE, cfb);\n\t\tsrc *= 3;\n\t\tdst *= 3;\n\t}\n\tcyber2000fb_writel(src, CO_REG_SRC1_PTR, cfb);\n\tcyber2000fb_writel(dst, CO_REG_DEST_PTR, cfb);\n\tcyber2000fb_writew(CO_FG_MIX_SRC, CO_REG_FGMIX, cfb);\n\tcyber2000fb_writew(cmd, CO_REG_CMD_L, cfb);\n\tcyber2000fb_writew(CO_CMD_H_FGSRCMAP | CO_CMD_H_BLITTER,\n\t\t\t   CO_REG_CMD_H, cfb);\n}\n\nstatic void\ncyber2000fb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tcfb_imageblit(info, image);\n\treturn;\n}\n\nstatic int cyber2000fb_sync(struct fb_info *info)\n{\n\tstruct cfb_info *cfb = container_of(info, struct cfb_info, fb);\n\tint count = 100000;\n\n\tif (!(cfb->fb.var.accel_flags & FB_ACCELF_TEXT))\n\t\treturn 0;\n\n\twhile (cyber2000fb_readb(CO_REG_CONTROL, cfb) & CO_CTRL_BUSY) {\n\t\tif (!count--) {\n\t\t\tdebug_printf(\"accel_wait timed out\\n\");\n\t\t\tcyber2000fb_writeb(0, CO_REG_CONTROL, cfb);\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn 0;\n}\n\n \n\nstatic inline u32 convert_bitfield(u_int val, struct fb_bitfield *bf)\n{\n\tu_int mask = (1 << bf->length) - 1;\n\n\treturn (val >> (16 - bf->length) & mask) << bf->offset;\n}\n\n \nstatic int\ncyber2000fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t      u_int transp, struct fb_info *info)\n{\n\tstruct cfb_info *cfb = container_of(info, struct cfb_info, fb);\n\tstruct fb_var_screeninfo *var = &cfb->fb.var;\n\tu32 pseudo_val;\n\tint ret = 1;\n\n\tswitch (cfb->fb.fix.visual) {\n\tdefault:\n\t\treturn 1;\n\n\t \n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tif (regno >= NR_PALETTE)\n\t\t\treturn 1;\n\n\t\tred >>= 8;\n\t\tgreen >>= 8;\n\t\tblue >>= 8;\n\n\t\tcfb->palette[regno].red = red;\n\t\tcfb->palette[regno].green = green;\n\t\tcfb->palette[regno].blue = blue;\n\n\t\tcyber2000fb_writeb(regno, 0x3c8, cfb);\n\t\tcyber2000fb_writeb(red, 0x3c9, cfb);\n\t\tcyber2000fb_writeb(green, 0x3c9, cfb);\n\t\tcyber2000fb_writeb(blue, 0x3c9, cfb);\n\t\treturn 0;\n\n\t \n\tcase FB_VISUAL_DIRECTCOLOR:\n\t\tred >>= 8;\n\t\tgreen >>= 8;\n\t\tblue >>= 8;\n\n\t\tif (var->green.length == 6 && regno < 64) {\n\t\t\tcfb->palette[regno << 2].green = green;\n\n\t\t\t \n\t\t\tcyber2000fb_writeb(regno << 2, 0x3c8, cfb);\n\t\t\tcyber2000fb_writeb(cfb->palette[regno >> 1].red,\n\t\t\t\t\t   0x3c9, cfb);\n\t\t\tcyber2000fb_writeb(green, 0x3c9, cfb);\n\t\t\tcyber2000fb_writeb(cfb->palette[regno >> 1].blue,\n\t\t\t\t\t   0x3c9, cfb);\n\n\t\t\tgreen = cfb->palette[regno << 3].green;\n\n\t\t\tret = 0;\n\t\t}\n\n\t\tif (var->green.length >= 5 && regno < 32) {\n\t\t\tcfb->palette[regno << 3].red = red;\n\t\t\tcfb->palette[regno << 3].green = green;\n\t\t\tcfb->palette[regno << 3].blue = blue;\n\n\t\t\t \n\t\t\tcyber2000fb_writeb(regno << 3, 0x3c8, cfb);\n\t\t\tcyber2000fb_writeb(red, 0x3c9, cfb);\n\t\t\tcyber2000fb_writeb(green, 0x3c9, cfb);\n\t\t\tcyber2000fb_writeb(blue, 0x3c9, cfb);\n\t\t\tret = 0;\n\t\t}\n\n\t\tif (var->green.length == 4 && regno < 16) {\n\t\t\tcfb->palette[regno << 4].red = red;\n\t\t\tcfb->palette[regno << 4].green = green;\n\t\t\tcfb->palette[regno << 4].blue = blue;\n\n\t\t\t \n\t\t\tcyber2000fb_writeb(regno << 4, 0x3c8, cfb);\n\t\t\tcyber2000fb_writeb(red, 0x3c9, cfb);\n\t\t\tcyber2000fb_writeb(green, 0x3c9, cfb);\n\t\t\tcyber2000fb_writeb(blue, 0x3c9, cfb);\n\t\t\tret = 0;\n\t\t}\n\n\t\t \n\t\tpseudo_val = regno << var->red.offset |\n\t\t\t     regno << var->green.offset |\n\t\t\t     regno << var->blue.offset;\n\t\tbreak;\n\n\t \n\tcase FB_VISUAL_TRUECOLOR:\n\t\tpseudo_val = convert_bitfield(transp ^ 0xffff, &var->transp);\n\t\tpseudo_val |= convert_bitfield(red, &var->red);\n\t\tpseudo_val |= convert_bitfield(green, &var->green);\n\t\tpseudo_val |= convert_bitfield(blue, &var->blue);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t \n\tif (regno < 16)\n\t\t((u32 *)cfb->fb.pseudo_palette)[regno] = pseudo_val;\n\n\treturn ret;\n}\n\nstruct par_info {\n\t \n\tu_char\tclock_mult;\n\tu_char\tclock_div;\n\tu_char\textseqmisc;\n\tu_char\tco_pixfmt;\n\tu_char\tcrtc_ofl;\n\tu_char\tcrtc[19];\n\tu_int\twidth;\n\tu_int\tpitch;\n\tu_int\tfetch;\n\n\t \n\tu_char\tramdac;\n};\n\nstatic const u_char crtc_idx[] = {\n\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t0x08, 0x09,\n\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18\n};\n\nstatic void cyber2000fb_write_ramdac_ctrl(struct cfb_info *cfb)\n{\n\tunsigned int i;\n\tunsigned int val = cfb->ramdac_ctrl | cfb->ramdac_powerdown;\n\n\tcyber2000fb_writeb(0x56, 0x3ce, cfb);\n\ti = cyber2000fb_readb(0x3cf, cfb);\n\tcyber2000fb_writeb(i | 4, 0x3cf, cfb);\n\tcyber2000fb_writeb(val, 0x3c6, cfb);\n\tcyber2000fb_writeb(i, 0x3cf, cfb);\n\t \n\tcyber2000fb_readb(0x3cf, cfb);\n}\n\nstatic void cyber2000fb_set_timing(struct cfb_info *cfb, struct par_info *hw)\n{\n\tu_int i;\n\n\t \n\tfor (i = 0; i < NR_PALETTE; i++) {\n\t\tcyber2000fb_writeb(i, 0x3c8, cfb);\n\t\tcyber2000fb_writeb(0, 0x3c9, cfb);\n\t\tcyber2000fb_writeb(0, 0x3c9, cfb);\n\t\tcyber2000fb_writeb(0, 0x3c9, cfb);\n\t}\n\n\tcyber2000fb_writeb(0xef, 0x3c2, cfb);\n\tcyber2000_crtcw(0x11, 0x0b, cfb);\n\tcyber2000_attrw(0x11, 0x00, cfb);\n\n\tcyber2000_seqw(0x00, 0x01, cfb);\n\tcyber2000_seqw(0x01, 0x01, cfb);\n\tcyber2000_seqw(0x02, 0x0f, cfb);\n\tcyber2000_seqw(0x03, 0x00, cfb);\n\tcyber2000_seqw(0x04, 0x0e, cfb);\n\tcyber2000_seqw(0x00, 0x03, cfb);\n\n\tfor (i = 0; i < sizeof(crtc_idx); i++)\n\t\tcyber2000_crtcw(crtc_idx[i], hw->crtc[i], cfb);\n\n\tfor (i = 0x0a; i < 0x10; i++)\n\t\tcyber2000_crtcw(i, 0, cfb);\n\n\tcyber2000_grphw(EXT_CRT_VRTOFL, hw->crtc_ofl, cfb);\n\tcyber2000_grphw(0x00, 0x00, cfb);\n\tcyber2000_grphw(0x01, 0x00, cfb);\n\tcyber2000_grphw(0x02, 0x00, cfb);\n\tcyber2000_grphw(0x03, 0x00, cfb);\n\tcyber2000_grphw(0x04, 0x00, cfb);\n\tcyber2000_grphw(0x05, 0x60, cfb);\n\tcyber2000_grphw(0x06, 0x05, cfb);\n\tcyber2000_grphw(0x07, 0x0f, cfb);\n\tcyber2000_grphw(0x08, 0xff, cfb);\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tcyber2000_attrw(i, i, cfb);\n\n\tcyber2000_attrw(0x10, 0x01, cfb);\n\tcyber2000_attrw(0x11, 0x00, cfb);\n\tcyber2000_attrw(0x12, 0x0f, cfb);\n\tcyber2000_attrw(0x13, 0x00, cfb);\n\tcyber2000_attrw(0x14, 0x00, cfb);\n\n\t \n\tspin_lock(&cfb->reg_b0_lock);\n\tcyber2000_grphw(EXT_DCLK_MULT, hw->clock_mult, cfb);\n\tcyber2000_grphw(EXT_DCLK_DIV, hw->clock_div, cfb);\n\tcyber2000_grphw(EXT_MCLK_MULT, cfb->mclk_mult, cfb);\n\tcyber2000_grphw(EXT_MCLK_DIV, cfb->mclk_div, cfb);\n\tcyber2000_grphw(0x90, 0x01, cfb);\n\tcyber2000_grphw(0xb9, 0x80, cfb);\n\tcyber2000_grphw(0xb9, 0x00, cfb);\n\tspin_unlock(&cfb->reg_b0_lock);\n\n\tcfb->ramdac_ctrl = hw->ramdac;\n\tcyber2000fb_write_ramdac_ctrl(cfb);\n\n\tcyber2000fb_writeb(0x20, 0x3c0, cfb);\n\tcyber2000fb_writeb(0xff, 0x3c6, cfb);\n\n\tcyber2000_grphw(0x14, hw->fetch, cfb);\n\tcyber2000_grphw(0x15, ((hw->fetch >> 8) & 0x03) |\n\t\t\t      ((hw->pitch >> 4) & 0x30), cfb);\n\tcyber2000_grphw(EXT_SEQ_MISC, hw->extseqmisc, cfb);\n\n\t \n\tcyber2000fb_writew(hw->width, CO_REG_SRC_WIDTH, cfb);\n\tcyber2000fb_writew(hw->width, CO_REG_DEST_WIDTH, cfb);\n\tcyber2000fb_writeb(hw->co_pixfmt, CO_REG_PIXFMT, cfb);\n}\n\nstatic inline int\ncyber2000fb_update_start(struct cfb_info *cfb, struct fb_var_screeninfo *var)\n{\n\tu_int base = var->yoffset * var->xres_virtual + var->xoffset;\n\n\tbase *= var->bits_per_pixel;\n\n\t \n\tbase >>= 5;\n\n\tif (base >= 1 << 20)\n\t\treturn -EINVAL;\n\n\tcyber2000_grphw(0x10, base >> 16 | 0x10, cfb);\n\tcyber2000_crtcw(0x0c, base >> 8, cfb);\n\tcyber2000_crtcw(0x0d, base, cfb);\n\n\treturn 0;\n}\n\nstatic int\ncyber2000fb_decode_crtc(struct par_info *hw, struct cfb_info *cfb,\n\t\t\tstruct fb_var_screeninfo *var)\n{\n\tu_int Htotal, Hblankend, Hsyncend;\n\tu_int Vtotal, Vdispend, Vblankstart, Vblankend, Vsyncstart, Vsyncend;\n#define ENCODE_BIT(v, b1, m, b2) ((((v) >> (b1)) & (m)) << (b2))\n\n\thw->crtc[13] = hw->pitch;\n\thw->crtc[17] = 0xe3;\n\thw->crtc[14] = 0;\n\thw->crtc[8]  = 0;\n\n\tHtotal     = var->xres + var->right_margin +\n\t\t     var->hsync_len + var->left_margin;\n\n\tif (Htotal > 2080)\n\t\treturn -EINVAL;\n\n\thw->crtc[0] = (Htotal >> 3) - 5;\n\thw->crtc[1] = (var->xres >> 3) - 1;\n\thw->crtc[2] = var->xres >> 3;\n\thw->crtc[4] = (var->xres + var->right_margin) >> 3;\n\n\tHblankend   = (Htotal - 4 * 8) >> 3;\n\n\thw->crtc[3] = ENCODE_BIT(Hblankend,  0, 0x1f,  0) |\n\t\t      ENCODE_BIT(1,          0, 0x01,  7);\n\n\tHsyncend    = (var->xres + var->right_margin + var->hsync_len) >> 3;\n\n\thw->crtc[5] = ENCODE_BIT(Hsyncend,   0, 0x1f,  0) |\n\t\t      ENCODE_BIT(Hblankend,  5, 0x01,  7);\n\n\tVdispend    = var->yres - 1;\n\tVsyncstart  = var->yres + var->lower_margin;\n\tVsyncend    = var->yres + var->lower_margin + var->vsync_len;\n\tVtotal      = var->yres + var->lower_margin + var->vsync_len +\n\t\t      var->upper_margin - 2;\n\n\tif (Vtotal > 2047)\n\t\treturn -EINVAL;\n\n\tVblankstart = var->yres + 6;\n\tVblankend   = Vtotal - 10;\n\n\thw->crtc[6]  = Vtotal;\n\thw->crtc[7]  = ENCODE_BIT(Vtotal,     8, 0x01,  0) |\n\t\t\tENCODE_BIT(Vdispend,   8, 0x01,  1) |\n\t\t\tENCODE_BIT(Vsyncstart, 8, 0x01,  2) |\n\t\t\tENCODE_BIT(Vblankstart, 8, 0x01,  3) |\n\t\t\tENCODE_BIT(1,          0, 0x01,  4) |\n\t\t\tENCODE_BIT(Vtotal,     9, 0x01,  5) |\n\t\t\tENCODE_BIT(Vdispend,   9, 0x01,  6) |\n\t\t\tENCODE_BIT(Vsyncstart, 9, 0x01,  7);\n\thw->crtc[9]  = ENCODE_BIT(0,          0, 0x1f,  0) |\n\t\t\tENCODE_BIT(Vblankstart, 9, 0x01,  5) |\n\t\t\tENCODE_BIT(1,          0, 0x01,  6);\n\thw->crtc[10] = Vsyncstart;\n\thw->crtc[11] = ENCODE_BIT(Vsyncend,   0, 0x0f,  0) |\n\t\t       ENCODE_BIT(1,          0, 0x01,  7);\n\thw->crtc[12] = Vdispend;\n\thw->crtc[15] = Vblankstart;\n\thw->crtc[16] = Vblankend;\n\thw->crtc[18] = 0xff;\n\n\t \n\thw->crtc_ofl =\n\t\tENCODE_BIT(Vtotal, 10, 0x01, 0) |\n\t\tENCODE_BIT(Vdispend, 10, 0x01, 1) |\n\t\tENCODE_BIT(Vsyncstart, 10, 0x01, 2) |\n\t\tENCODE_BIT(Vblankstart, 10, 0x01, 3) |\n\t\tEXT_CRT_VRTOFL_LINECOMP10;\n\n\t \n\t \n\tif ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)\n\t\thw->crtc_ofl |= EXT_CRT_VRTOFL_INTERLACE;\n\n\treturn 0;\n}\n\n \nstatic int\ncyber2000fb_decode_clock(struct par_info *hw, struct cfb_info *cfb,\n\t\t\t struct fb_var_screeninfo *var)\n{\n\tu_long pll_ps = var->pixclock;\n\tconst u_long ref_ps = cfb->ref_ps;\n\tu_int div2, t_div1, best_div1, best_mult;\n\tint best_diff;\n\tint vco;\n\n\t \n\tfor (div2 = 0; div2 < 4; div2++) {\n\t\tu_long new_pll;\n\n\t\tnew_pll = pll_ps / cfb->divisors[div2];\n\t\tif (8696 > new_pll && new_pll > 3846) {\n\t\t\tpll_ps = new_pll;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (div2 == 4)\n\t\treturn -EINVAL;\n\n\t \n\tbest_diff = 0x7fffffff;\n\tbest_mult = 2;\n\tbest_div1 = 32;\n\tfor (t_div1 = 2; t_div1 < 32; t_div1 += 1) {\n\t\tu_int rr, t_mult, t_pll_ps;\n\t\tint diff;\n\n\t\t \n\t\trr = ref_ps * t_div1;\n\t\tt_mult = (rr + pll_ps / 2) / pll_ps;\n\n\t\t \n\t\tif (t_mult > 256 || t_mult < 2)\n\t\t\tcontinue;\n\n\t\t \n\t\tt_pll_ps = (rr + t_mult / 2) / t_mult;\n\t\tdiff = pll_ps - t_pll_ps;\n\t\tif (diff < 0)\n\t\t\tdiff = -diff;\n\n\t\tif (diff < best_diff) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_mult = t_mult;\n\t\t\tbest_div1 = t_div1;\n\t\t}\n\n\t\t \n\t\tif (diff == 0)\n\t\t\tbreak;\n\t}\n\n\t \n\thw->clock_mult = best_mult - 1;\n\thw->clock_div  = div2 << 6 | (best_div1 - 1);\n\n\tvco = ref_ps * best_div1 / best_mult;\n\tif ((ref_ps == 40690) && (vco < 5556))\n\t\t \n\t\thw->clock_div |= EXT_DCLK_DIV_VFSEL;\n\n\treturn 0;\n}\n\n \nstatic int\ncyber2000fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct cfb_info *cfb = container_of(info, struct cfb_info, fb);\n\tstruct par_info hw;\n\tunsigned int mem;\n\tint err;\n\n\tvar->transp.msb_right\t= 0;\n\tvar->red.msb_right\t= 0;\n\tvar->green.msb_right\t= 0;\n\tvar->blue.msb_right\t= 0;\n\tvar->transp.offset\t= 0;\n\tvar->transp.length\t= 0;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\t \n\t\tvar->red.offset\t\t= 0;\n\t\tvar->red.length\t\t= 8;\n\t\tvar->green.offset\t= 0;\n\t\tvar->green.length\t= 8;\n\t\tvar->blue.offset\t= 0;\n\t\tvar->blue.length\t= 8;\n\t\tbreak;\n\n\tcase 16: \n\t\tswitch (var->green.length) {\n\t\tcase 6:  \n\t\t\tvar->red.offset\t\t= 11;\n\t\t\tvar->red.length\t\t= 5;\n\t\t\tvar->green.offset\t= 5;\n\t\t\tvar->green.length\t= 6;\n\t\t\tvar->blue.offset\t= 0;\n\t\t\tvar->blue.length\t= 5;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase 5:  \n\t\t\tvar->red.offset\t\t= 10;\n\t\t\tvar->red.length\t\t= 5;\n\t\t\tvar->green.offset\t= 5;\n\t\t\tvar->green.length\t= 5;\n\t\t\tvar->blue.offset\t= 0;\n\t\t\tvar->blue.length\t= 5;\n\t\t\tbreak;\n\n\t\tcase 4:  \n\t\t\tvar->transp.offset\t= 12;\n\t\t\tvar->transp.length\t= 4;\n\t\t\tvar->red.offset\t\t= 8;\n\t\t\tvar->red.length\t\t= 4;\n\t\t\tvar->green.offset\t= 4;\n\t\t\tvar->green.length\t= 4;\n\t\t\tvar->blue.offset\t= 0;\n\t\t\tvar->blue.length\t= 4;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 24: \n\t\tvar->red.offset\t\t= 16;\n\t\tvar->red.length\t\t= 8;\n\t\tvar->green.offset\t= 8;\n\t\tvar->green.length\t= 8;\n\t\tvar->blue.offset\t= 0;\n\t\tvar->blue.length\t= 8;\n\t\tbreak;\n\n\tcase 32: \n\t\tvar->transp.offset\t= 24;\n\t\tvar->transp.length\t= 8;\n\t\tvar->red.offset\t\t= 16;\n\t\tvar->red.length\t\t= 8;\n\t\tvar->green.offset\t= 8;\n\t\tvar->green.length\t= 8;\n\t\tvar->blue.offset\t= 0;\n\t\tvar->blue.length\t= 8;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmem = var->xres_virtual * var->yres_virtual * (var->bits_per_pixel / 8);\n\tif (mem > cfb->fb.fix.smem_len)\n\t\tvar->yres_virtual = cfb->fb.fix.smem_len * 8 /\n\t\t\t\t    (var->bits_per_pixel * var->xres_virtual);\n\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres = var->yres_virtual;\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres = var->xres_virtual;\n\n\terr = cyber2000fb_decode_clock(&hw, cfb, var);\n\tif (err)\n\t\treturn err;\n\n\terr = cyber2000fb_decode_crtc(&hw, cfb, var);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int cyber2000fb_set_par(struct fb_info *info)\n{\n\tstruct cfb_info *cfb = container_of(info, struct cfb_info, fb);\n\tstruct fb_var_screeninfo *var = &cfb->fb.var;\n\tstruct par_info hw;\n\tunsigned int mem;\n\n\thw.width = var->xres_virtual;\n\thw.ramdac = RAMDAC_VREFEN | RAMDAC_DAC8BIT;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\thw.co_pixfmt\t\t= CO_PIXFMT_8BPP;\n\t\thw.pitch\t\t= hw.width >> 3;\n\t\thw.extseqmisc\t\t= EXT_SEQ_MISC_8;\n\t\tbreak;\n\n\tcase 16:\n\t\thw.co_pixfmt\t\t= CO_PIXFMT_16BPP;\n\t\thw.pitch\t\t= hw.width >> 2;\n\n\t\tswitch (var->green.length) {\n\t\tcase 6:  \n\t\t\thw.extseqmisc\t= EXT_SEQ_MISC_16_RGB565;\n\t\t\tbreak;\n\t\tcase 5:  \n\t\t\thw.extseqmisc\t= EXT_SEQ_MISC_16_RGB555;\n\t\t\tbreak;\n\t\tcase 4:  \n\t\t\thw.extseqmisc\t= EXT_SEQ_MISC_16_RGB444;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tbreak;\n\n\tcase 24: \n\t\thw.co_pixfmt\t\t= CO_PIXFMT_24BPP;\n\t\thw.width\t\t*= 3;\n\t\thw.pitch\t\t= hw.width >> 3;\n\t\thw.ramdac\t\t|= (RAMDAC_BYPASS | RAMDAC_RAMPWRDN);\n\t\thw.extseqmisc\t\t= EXT_SEQ_MISC_24_RGB888;\n\t\tbreak;\n\n\tcase 32: \n\t\thw.co_pixfmt\t\t= CO_PIXFMT_32BPP;\n\t\thw.pitch\t\t= hw.width >> 1;\n\t\thw.ramdac\t\t|= (RAMDAC_BYPASS | RAMDAC_RAMPWRDN);\n\t\thw.extseqmisc\t\t= EXT_SEQ_MISC_32;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t \n\tBUG_ON(cyber2000fb_decode_clock(&hw, cfb, var) != 0);\n\tBUG_ON(cyber2000fb_decode_crtc(&hw, cfb, var) != 0);\n\n\thw.width -= 1;\n\thw.fetch = hw.pitch;\n\tif (!(cfb->mem_ctl2 & MEM_CTL2_64BIT))\n\t\thw.fetch <<= 1;\n\thw.fetch += 1;\n\n\tcfb->fb.fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;\n\n\t \n\tmem = cfb->fb.fix.line_length * var->yres_virtual;\n\tBUG_ON(mem > cfb->fb.fix.smem_len);\n\n\t \n\tif (var->bits_per_pixel == 8)\n\t\tcfb->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\telse if (hw.ramdac & RAMDAC_BYPASS)\n\t\tcfb->fb.fix.visual = FB_VISUAL_TRUECOLOR;\n\telse\n\t\tcfb->fb.fix.visual = FB_VISUAL_DIRECTCOLOR;\n\n\tcyber2000fb_set_timing(cfb, &hw);\n\tcyber2000fb_update_start(cfb, var);\n\n\treturn 0;\n}\n\n \nstatic int\ncyber2000fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct cfb_info *cfb = container_of(info, struct cfb_info, fb);\n\n\tif (cyber2000fb_update_start(cfb, var))\n\t\treturn -EINVAL;\n\n\tcfb->fb.var.xoffset = var->xoffset;\n\tcfb->fb.var.yoffset = var->yoffset;\n\n\tif (var->vmode & FB_VMODE_YWRAP) {\n\t\tcfb->fb.var.vmode |= FB_VMODE_YWRAP;\n\t} else {\n\t\tcfb->fb.var.vmode &= ~FB_VMODE_YWRAP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cyber2000fb_blank(int blank, struct fb_info *info)\n{\n\tstruct cfb_info *cfb = container_of(info, struct cfb_info, fb);\n\tunsigned int sync = 0;\n\tint i;\n\n\tswitch (blank) {\n\tcase FB_BLANK_POWERDOWN:\t \n\t\tsync = EXT_SYNC_CTL_VS_0 | EXT_SYNC_CTL_HS_0;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\t \n\t\tsync = EXT_SYNC_CTL_VS_NORMAL | EXT_SYNC_CTL_HS_0;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\t \n\t\tsync = EXT_SYNC_CTL_VS_0 | EXT_SYNC_CTL_HS_NORMAL;\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\t\t \n\tdefault:\t\t\t \n\t\tbreak;\n\t}\n\n\tcyber2000_grphw(EXT_SYNC_CTL, sync, cfb);\n\n\tif (blank <= 1) {\n\t\t \n\t\tcfb->ramdac_powerdown &= ~(RAMDAC_DACPWRDN | RAMDAC_BYPASS |\n\t\t\t\t\t   RAMDAC_RAMPWRDN);\n\t\tcyber2000fb_write_ramdac_ctrl(cfb);\n\t}\n\n\t \n\tif (blank) {\t \n\t\tfor (i = 0; i < NR_PALETTE; i++) {\n\t\t\tcyber2000fb_writeb(i, 0x3c8, cfb);\n\t\t\tcyber2000fb_writeb(0, 0x3c9, cfb);\n\t\t\tcyber2000fb_writeb(0, 0x3c9, cfb);\n\t\t\tcyber2000fb_writeb(0, 0x3c9, cfb);\n\t\t}\n\t} else {\t \n\t\tfor (i = 0; i < NR_PALETTE; i++) {\n\t\t\tcyber2000fb_writeb(i, 0x3c8, cfb);\n\t\t\tcyber2000fb_writeb(cfb->palette[i].red, 0x3c9, cfb);\n\t\t\tcyber2000fb_writeb(cfb->palette[i].green, 0x3c9, cfb);\n\t\t\tcyber2000fb_writeb(cfb->palette[i].blue, 0x3c9, cfb);\n\t\t}\n\t}\n\n\tif (blank >= 2) {\n\t\t \n\t\tcfb->ramdac_powerdown |= RAMDAC_DACPWRDN | RAMDAC_BYPASS |\n\t\t\t\t\t RAMDAC_RAMPWRDN;\n\t\tcyber2000fb_write_ramdac_ctrl(cfb);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct fb_ops cyber2000fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= cyber2000fb_check_var,\n\t.fb_set_par\t= cyber2000fb_set_par,\n\t.fb_setcolreg\t= cyber2000fb_setcolreg,\n\t.fb_blank\t= cyber2000fb_blank,\n\t.fb_pan_display\t= cyber2000fb_pan_display,\n\t.fb_fillrect\t= cyber2000fb_fillrect,\n\t.fb_copyarea\t= cyber2000fb_copyarea,\n\t.fb_imageblit\t= cyber2000fb_imageblit,\n\t.fb_sync\t= cyber2000fb_sync,\n};\n\n \nstatic struct cfb_info *int_cfb_info;\n\n \nvoid cyber2000fb_enable_extregs(struct cfb_info *cfb)\n{\n\tcfb->func_use_count += 1;\n\n\tif (cfb->func_use_count == 1) {\n\t\tint old;\n\n\t\told = cyber2000_grphr(EXT_FUNC_CTL, cfb);\n\t\told |= EXT_FUNC_CTL_EXTREGENBL;\n\t\tcyber2000_grphw(EXT_FUNC_CTL, old, cfb);\n\t}\n}\nEXPORT_SYMBOL(cyber2000fb_enable_extregs);\n\n \nvoid cyber2000fb_disable_extregs(struct cfb_info *cfb)\n{\n\tif (cfb->func_use_count == 1) {\n\t\tint old;\n\n\t\told = cyber2000_grphr(EXT_FUNC_CTL, cfb);\n\t\told &= ~EXT_FUNC_CTL_EXTREGENBL;\n\t\tcyber2000_grphw(EXT_FUNC_CTL, old, cfb);\n\t}\n\n\tif (cfb->func_use_count == 0)\n\t\tprintk(KERN_ERR \"disable_extregs: count = 0\\n\");\n\telse\n\t\tcfb->func_use_count -= 1;\n}\nEXPORT_SYMBOL(cyber2000fb_disable_extregs);\n\n \nint cyber2000fb_attach(struct cyberpro_info *info, int idx)\n{\n\tif (int_cfb_info != NULL) {\n\t\tinfo->dev\t      = int_cfb_info->fb.device;\n#ifdef CONFIG_FB_CYBER2000_I2C\n\t\tinfo->i2c\t      = &int_cfb_info->i2c_adapter;\n#else\n\t\tinfo->i2c\t      = NULL;\n#endif\n\t\tinfo->regs\t      = int_cfb_info->regs;\n\t\tinfo->irq             = int_cfb_info->irq;\n\t\tinfo->fb\t      = int_cfb_info->fb.screen_base;\n\t\tinfo->fb_size\t      = int_cfb_info->fb.fix.smem_len;\n\t\tinfo->info\t      = int_cfb_info;\n\n\t\tstrscpy(info->dev_name, int_cfb_info->fb.fix.id,\n\t\t\tsizeof(info->dev_name));\n\t}\n\n\treturn int_cfb_info != NULL;\n}\nEXPORT_SYMBOL(cyber2000fb_attach);\n\n \nvoid cyber2000fb_detach(int idx)\n{\n}\nEXPORT_SYMBOL(cyber2000fb_detach);\n\n#ifdef CONFIG_FB_CYBER2000_DDC\n\n#define DDC_REG\t\t0xb0\n#define DDC_SCL_OUT\t(1 << 0)\n#define DDC_SDA_OUT\t(1 << 4)\n#define DDC_SCL_IN\t(1 << 2)\n#define DDC_SDA_IN\t(1 << 6)\n\nstatic void cyber2000fb_enable_ddc(struct cfb_info *cfb)\n\t__acquires(&cfb->reg_b0_lock)\n{\n\tspin_lock(&cfb->reg_b0_lock);\n\tcyber2000fb_writew(0x1bf, 0x3ce, cfb);\n}\n\nstatic void cyber2000fb_disable_ddc(struct cfb_info *cfb)\n\t__releases(&cfb->reg_b0_lock)\n{\n\tcyber2000fb_writew(0x0bf, 0x3ce, cfb);\n\tspin_unlock(&cfb->reg_b0_lock);\n}\n\n\nstatic void cyber2000fb_ddc_setscl(void *data, int val)\n{\n\tstruct cfb_info *cfb = data;\n\tunsigned char reg;\n\n\tcyber2000fb_enable_ddc(cfb);\n\treg = cyber2000_grphr(DDC_REG, cfb);\n\tif (!val)\t \n\t\treg |= DDC_SCL_OUT;\n\telse\n\t\treg &= ~DDC_SCL_OUT;\n\tcyber2000_grphw(DDC_REG, reg, cfb);\n\tcyber2000fb_disable_ddc(cfb);\n}\n\nstatic void cyber2000fb_ddc_setsda(void *data, int val)\n{\n\tstruct cfb_info *cfb = data;\n\tunsigned char reg;\n\n\tcyber2000fb_enable_ddc(cfb);\n\treg = cyber2000_grphr(DDC_REG, cfb);\n\tif (!val)\t \n\t\treg |= DDC_SDA_OUT;\n\telse\n\t\treg &= ~DDC_SDA_OUT;\n\tcyber2000_grphw(DDC_REG, reg, cfb);\n\tcyber2000fb_disable_ddc(cfb);\n}\n\nstatic int cyber2000fb_ddc_getscl(void *data)\n{\n\tstruct cfb_info *cfb = data;\n\tint retval;\n\n\tcyber2000fb_enable_ddc(cfb);\n\tretval = !!(cyber2000_grphr(DDC_REG, cfb) & DDC_SCL_IN);\n\tcyber2000fb_disable_ddc(cfb);\n\n\treturn retval;\n}\n\nstatic int cyber2000fb_ddc_getsda(void *data)\n{\n\tstruct cfb_info *cfb = data;\n\tint retval;\n\n\tcyber2000fb_enable_ddc(cfb);\n\tretval = !!(cyber2000_grphr(DDC_REG, cfb) & DDC_SDA_IN);\n\tcyber2000fb_disable_ddc(cfb);\n\n\treturn retval;\n}\n\nstatic int cyber2000fb_setup_ddc_bus(struct cfb_info *cfb)\n{\n\tstrscpy(cfb->ddc_adapter.name, cfb->fb.fix.id,\n\t\tsizeof(cfb->ddc_adapter.name));\n\tcfb->ddc_adapter.owner\t\t= THIS_MODULE;\n\tcfb->ddc_adapter.class\t\t= I2C_CLASS_DDC;\n\tcfb->ddc_adapter.algo_data\t= &cfb->ddc_algo;\n\tcfb->ddc_adapter.dev.parent\t= cfb->fb.device;\n\tcfb->ddc_algo.setsda\t\t= cyber2000fb_ddc_setsda;\n\tcfb->ddc_algo.setscl\t\t= cyber2000fb_ddc_setscl;\n\tcfb->ddc_algo.getsda\t\t= cyber2000fb_ddc_getsda;\n\tcfb->ddc_algo.getscl\t\t= cyber2000fb_ddc_getscl;\n\tcfb->ddc_algo.udelay\t\t= 10;\n\tcfb->ddc_algo.timeout\t\t= 20;\n\tcfb->ddc_algo.data\t\t= cfb;\n\n\ti2c_set_adapdata(&cfb->ddc_adapter, cfb);\n\n\treturn i2c_bit_add_bus(&cfb->ddc_adapter);\n}\n#endif  \n\n#ifdef CONFIG_FB_CYBER2000_I2C\nstatic void cyber2000fb_i2c_setsda(void *data, int state)\n{\n\tstruct cfb_info *cfb = data;\n\tunsigned int latch2;\n\n\tspin_lock(&cfb->reg_b0_lock);\n\tlatch2 = cyber2000_grphr(EXT_LATCH2, cfb);\n\tlatch2 &= EXT_LATCH2_I2C_CLKEN;\n\tif (state)\n\t\tlatch2 |= EXT_LATCH2_I2C_DATEN;\n\tcyber2000_grphw(EXT_LATCH2, latch2, cfb);\n\tspin_unlock(&cfb->reg_b0_lock);\n}\n\nstatic void cyber2000fb_i2c_setscl(void *data, int state)\n{\n\tstruct cfb_info *cfb = data;\n\tunsigned int latch2;\n\n\tspin_lock(&cfb->reg_b0_lock);\n\tlatch2 = cyber2000_grphr(EXT_LATCH2, cfb);\n\tlatch2 &= EXT_LATCH2_I2C_DATEN;\n\tif (state)\n\t\tlatch2 |= EXT_LATCH2_I2C_CLKEN;\n\tcyber2000_grphw(EXT_LATCH2, latch2, cfb);\n\tspin_unlock(&cfb->reg_b0_lock);\n}\n\nstatic int cyber2000fb_i2c_getsda(void *data)\n{\n\tstruct cfb_info *cfb = data;\n\tint ret;\n\n\tspin_lock(&cfb->reg_b0_lock);\n\tret = !!(cyber2000_grphr(EXT_LATCH2, cfb) & EXT_LATCH2_I2C_DAT);\n\tspin_unlock(&cfb->reg_b0_lock);\n\n\treturn ret;\n}\n\nstatic int cyber2000fb_i2c_getscl(void *data)\n{\n\tstruct cfb_info *cfb = data;\n\tint ret;\n\n\tspin_lock(&cfb->reg_b0_lock);\n\tret = !!(cyber2000_grphr(EXT_LATCH2, cfb) & EXT_LATCH2_I2C_CLK);\n\tspin_unlock(&cfb->reg_b0_lock);\n\n\treturn ret;\n}\n\nstatic int cyber2000fb_i2c_register(struct cfb_info *cfb)\n{\n\tstrscpy(cfb->i2c_adapter.name, cfb->fb.fix.id,\n\t\tsizeof(cfb->i2c_adapter.name));\n\tcfb->i2c_adapter.owner = THIS_MODULE;\n\tcfb->i2c_adapter.algo_data = &cfb->i2c_algo;\n\tcfb->i2c_adapter.dev.parent = cfb->fb.device;\n\tcfb->i2c_algo.setsda = cyber2000fb_i2c_setsda;\n\tcfb->i2c_algo.setscl = cyber2000fb_i2c_setscl;\n\tcfb->i2c_algo.getsda = cyber2000fb_i2c_getsda;\n\tcfb->i2c_algo.getscl = cyber2000fb_i2c_getscl;\n\tcfb->i2c_algo.udelay = 5;\n\tcfb->i2c_algo.timeout = msecs_to_jiffies(100);\n\tcfb->i2c_algo.data = cfb;\n\n\treturn i2c_bit_add_bus(&cfb->i2c_adapter);\n}\n\nstatic void cyber2000fb_i2c_unregister(struct cfb_info *cfb)\n{\n\ti2c_del_adapter(&cfb->i2c_adapter);\n}\n#else\n#define cyber2000fb_i2c_register(cfb)\t(0)\n#define cyber2000fb_i2c_unregister(cfb)\tdo { } while (0)\n#endif\n\n \nstatic const struct fb_videomode cyber2000fb_default_mode = {\n\t.refresh\t= 60,\n\t.xres\t\t= 640,\n\t.yres\t\t= 480,\n\t.pixclock\t= 39722,\n\t.left_margin\t= 56,\n\t.right_margin\t= 16,\n\t.upper_margin\t= 34,\n\t.lower_margin\t= 9,\n\t.hsync_len\t= 88,\n\t.vsync_len\t= 2,\n\t.sync\t\t= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED\n};\n\nstatic char igs_regs[] = {\n\tEXT_CRT_IRQ,\t\t0,\n\tEXT_CRT_TEST,\t\t0,\n\tEXT_SYNC_CTL,\t\t0,\n\tEXT_SEG_WRITE_PTR,\t0,\n\tEXT_SEG_READ_PTR,\t0,\n\tEXT_BIU_MISC,\t\tEXT_BIU_MISC_LIN_ENABLE |\n\t\t\t\tEXT_BIU_MISC_COP_ENABLE |\n\t\t\t\tEXT_BIU_MISC_COP_BFC,\n\tEXT_FUNC_CTL,\t\t0,\n\tCURS_H_START,\t\t0,\n\tCURS_H_START + 1,\t0,\n\tCURS_H_PRESET,\t\t0,\n\tCURS_V_START,\t\t0,\n\tCURS_V_START + 1,\t0,\n\tCURS_V_PRESET,\t\t0,\n\tCURS_CTL,\t\t0,\n\tEXT_ATTRIB_CTL,\t\tEXT_ATTRIB_CTL_EXT,\n\tEXT_OVERSCAN_RED,\t0,\n\tEXT_OVERSCAN_GREEN,\t0,\n\tEXT_OVERSCAN_BLUE,\t0,\n\n\t \n\tEXT_MEM_CTL0,\t\tEXT_MEM_CTL0_7CLK |\n\t\t\t\tEXT_MEM_CTL0_RAS_1 |\n\t\t\t\tEXT_MEM_CTL0_MULTCAS,\n\tEXT_HIDDEN_CTL1,\t0x30,\n\tEXT_FIFO_CTL,\t\t0x0b,\n\tEXT_FIFO_CTL + 1,\t0x17,\n\t0x76,\t\t\t0x00,\n\tEXT_HIDDEN_CTL4,\t0xc8\n};\n\n \nstatic void cyberpro_init_hw(struct cfb_info *cfb)\n{\n\tint i;\n\n\tfor (i = 0; i < sizeof(igs_regs); i += 2)\n\t\tcyber2000_grphw(igs_regs[i], igs_regs[i + 1], cfb);\n\n\tif (cfb->id == ID_CYBERPRO_5000) {\n\t\tunsigned char val;\n\t\tcyber2000fb_writeb(0xba, 0x3ce, cfb);\n\t\tval = cyber2000fb_readb(0x3cf, cfb) & 0x80;\n\t\tcyber2000fb_writeb(val, 0x3cf, cfb);\n\t}\n}\n\nstatic struct cfb_info *cyberpro_alloc_fb_info(unsigned int id, char *name)\n{\n\tstruct cfb_info *cfb;\n\n\tcfb = kzalloc(sizeof(struct cfb_info), GFP_KERNEL);\n\tif (!cfb)\n\t\treturn NULL;\n\n\n\tcfb->id\t\t\t= id;\n\n\tif (id == ID_CYBERPRO_5000)\n\t\tcfb->ref_ps\t= 40690;  \n\telse\n\t\tcfb->ref_ps\t= 69842;  \n\n\tcfb->divisors[0]\t= 1;\n\tcfb->divisors[1]\t= 2;\n\tcfb->divisors[2]\t= 4;\n\n\tif (id == ID_CYBERPRO_2000)\n\t\tcfb->divisors[3] = 8;\n\telse\n\t\tcfb->divisors[3] = 6;\n\n\tstrcpy(cfb->fb.fix.id, name);\n\n\tcfb->fb.fix.type\t= FB_TYPE_PACKED_PIXELS;\n\tcfb->fb.fix.type_aux\t= 0;\n\tcfb->fb.fix.xpanstep\t= 0;\n\tcfb->fb.fix.ypanstep\t= 1;\n\tcfb->fb.fix.ywrapstep\t= 0;\n\n\tswitch (id) {\n\tcase ID_IGA_1682:\n\t\tcfb->fb.fix.accel = 0;\n\t\tbreak;\n\n\tcase ID_CYBERPRO_2000:\n\t\tcfb->fb.fix.accel = FB_ACCEL_IGS_CYBER2000;\n\t\tbreak;\n\n\tcase ID_CYBERPRO_2010:\n\t\tcfb->fb.fix.accel = FB_ACCEL_IGS_CYBER2010;\n\t\tbreak;\n\n\tcase ID_CYBERPRO_5000:\n\t\tcfb->fb.fix.accel = FB_ACCEL_IGS_CYBER5000;\n\t\tbreak;\n\t}\n\n\tcfb->fb.var.nonstd\t= 0;\n\tcfb->fb.var.activate\t= FB_ACTIVATE_NOW;\n\tcfb->fb.var.height\t= -1;\n\tcfb->fb.var.width\t= -1;\n\tcfb->fb.var.accel_flags\t= FB_ACCELF_TEXT;\n\n\tcfb->fb.fbops\t\t= &cyber2000fb_ops;\n\tcfb->fb.flags\t\t= FBINFO_HWACCEL_YPAN;\n\tcfb->fb.pseudo_palette\t= cfb->pseudo_palette;\n\n\tspin_lock_init(&cfb->reg_b0_lock);\n\n\tfb_alloc_cmap(&cfb->fb.cmap, NR_PALETTE, 0);\n\n\treturn cfb;\n}\n\nstatic void cyberpro_free_fb_info(struct cfb_info *cfb)\n{\n\tif (cfb) {\n\t\t \n\t\tfb_alloc_cmap(&cfb->fb.cmap, 0, 0);\n\n\t\tkfree(cfb);\n\t}\n}\n\n \n#ifndef MODULE\nstatic int cyber2000fb_setup(char *options)\n{\n\tchar *opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*opt)\n\t\t\tcontinue;\n\n\t\tif (strncmp(opt, \"font:\", 5) == 0) {\n\t\t\tstatic char default_font_storage[40];\n\n\t\t\tstrscpy(default_font_storage, opt + 5,\n\t\t\t\tsizeof(default_font_storage));\n\t\t\tdefault_font = default_font_storage;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(KERN_ERR \"CyberPro20x0: unknown parameter: %s\\n\", opt);\n\t}\n\treturn 0;\n}\n#endif   \n\n \nstatic int cyberpro_common_probe(struct cfb_info *cfb)\n{\n\tu_long smem_size;\n\tu_int h_sync, v_sync;\n\tint err;\n\n\tcyberpro_init_hw(cfb);\n\n\t \n\tcfb->mem_ctl1 = cyber2000_grphr(EXT_MEM_CTL1, cfb);\n\tcfb->mem_ctl2 = cyber2000_grphr(EXT_MEM_CTL2, cfb);\n\n\t \n\tswitch (cfb->mem_ctl2 & MEM_CTL2_SIZE_MASK) {\n\tcase MEM_CTL2_SIZE_4MB:\n\t\tsmem_size = 0x00400000;\n\t\tbreak;\n\tcase MEM_CTL2_SIZE_2MB:\n\t\tsmem_size = 0x00200000;\n\t\tbreak;\n\tcase MEM_CTL2_SIZE_1MB:\n\t\tsmem_size = 0x00100000;\n\t\tbreak;\n\tdefault:\n\t\tsmem_size = 0x00100000;\n\t\tbreak;\n\t}\n\n\tcfb->fb.fix.smem_len   = smem_size;\n\tcfb->fb.fix.mmio_len   = MMIO_SIZE;\n\tcfb->fb.screen_base    = cfb->region;\n\n#ifdef CONFIG_FB_CYBER2000_DDC\n\tif (cyber2000fb_setup_ddc_bus(cfb) == 0)\n\t\tcfb->ddc_registered = true;\n#endif\n\n\terr = -EINVAL;\n\tif (!fb_find_mode(&cfb->fb.var, &cfb->fb, NULL, NULL, 0,\n\t\t\t  &cyber2000fb_default_mode, 8)) {\n\t\tprintk(KERN_ERR \"%s: no valid mode found\\n\", cfb->fb.fix.id);\n\t\tgoto failed;\n\t}\n\n\tcfb->fb.var.yres_virtual = cfb->fb.fix.smem_len * 8 /\n\t\t\t(cfb->fb.var.bits_per_pixel * cfb->fb.var.xres_virtual);\n\n\tif (cfb->fb.var.yres_virtual < cfb->fb.var.yres)\n\t\tcfb->fb.var.yres_virtual = cfb->fb.var.yres;\n\n \n\n\t \n\th_sync = 1953125000 / cfb->fb.var.pixclock;\n\th_sync = h_sync * 512 / (cfb->fb.var.xres + cfb->fb.var.left_margin +\n\t\t cfb->fb.var.right_margin + cfb->fb.var.hsync_len);\n\tv_sync = h_sync / (cfb->fb.var.yres + cfb->fb.var.upper_margin +\n\t\t cfb->fb.var.lower_margin + cfb->fb.var.vsync_len);\n\n\tprintk(KERN_INFO \"%s: %dKiB VRAM, using %dx%d, %d.%03dkHz, %dHz\\n\",\n\t\tcfb->fb.fix.id, cfb->fb.fix.smem_len >> 10,\n\t\tcfb->fb.var.xres, cfb->fb.var.yres,\n\t\th_sync / 1000, h_sync % 1000, v_sync);\n\n\terr = cyber2000fb_i2c_register(cfb);\n\tif (err)\n\t\tgoto failed;\n\n\terr = register_framebuffer(&cfb->fb);\n\tif (err)\n\t\tcyber2000fb_i2c_unregister(cfb);\n\nfailed:\n#ifdef CONFIG_FB_CYBER2000_DDC\n\tif (err && cfb->ddc_registered)\n\t\ti2c_del_adapter(&cfb->ddc_adapter);\n#endif\n\treturn err;\n}\n\nstatic void cyberpro_common_remove(struct cfb_info *cfb)\n{\n\tunregister_framebuffer(&cfb->fb);\n#ifdef CONFIG_FB_CYBER2000_DDC\n\tif (cfb->ddc_registered)\n\t\ti2c_del_adapter(&cfb->ddc_adapter);\n#endif\n\tcyber2000fb_i2c_unregister(cfb);\n}\n\nstatic void cyberpro_common_resume(struct cfb_info *cfb)\n{\n\tcyberpro_init_hw(cfb);\n\n\t \n\tcyber2000_grphw(EXT_MEM_CTL1, cfb->mem_ctl1, cfb);\n\tcyber2000_grphw(EXT_MEM_CTL2, cfb->mem_ctl2, cfb);\n\n\t \n\tcyber2000fb_set_par(&cfb->fb);\n}\n\n \nstatic int cyberpro_pci_enable_mmio(struct cfb_info *cfb)\n{\n\tunsigned char val;\n\n#if defined(__sparc_v9__)\n#error \"You lose, consult DaveM.\"\n#elif defined(__sparc__)\n\t \n\tunsigned char __iomem *iop;\n\n\tiop = ioremap(0x3000000, 0x5000);\n\tif (iop == NULL) {\n\t\tprintk(KERN_ERR \"iga5000: cannot map I/O\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twriteb(0x18, iop + 0x46e8);\n\twriteb(0x01, iop + 0x102);\n\twriteb(0x08, iop + 0x46e8);\n\twriteb(EXT_BIU_MISC, iop + 0x3ce);\n\twriteb(EXT_BIU_MISC_LIN_ENABLE, iop + 0x3cf);\n\n\tiounmap(iop);\n#else\n\t \n\toutb(0x18, 0x46e8);\n\toutb(0x01, 0x102);\n\toutb(0x08, 0x46e8);\n\toutb(EXT_BIU_MISC, 0x3ce);\n\toutb(EXT_BIU_MISC_LIN_ENABLE, 0x3cf);\n#endif\n\n\t \n\tif (cfb->id == ID_CYBERPRO_2010) {\n\t\tprintk(KERN_INFO \"%s: NOT enabling PCI bursts\\n\",\n\t\t       cfb->fb.fix.id);\n\t} else {\n\t\tval = cyber2000_grphr(EXT_BUS_CTL, cfb);\n\t\tif (!(val & EXT_BUS_CTL_PCIBURST_WRITE)) {\n\t\t\tprintk(KERN_INFO \"%s: enabling PCI bursts\\n\",\n\t\t\t\tcfb->fb.fix.id);\n\n\t\t\tval |= EXT_BUS_CTL_PCIBURST_WRITE;\n\n\t\t\tif (cfb->id == ID_CYBERPRO_5000)\n\t\t\t\tval |= EXT_BUS_CTL_PCIBURST_READ;\n\n\t\t\tcyber2000_grphw(EXT_BUS_CTL, val, cfb);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cyberpro_pci_probe(struct pci_dev *dev,\n\t\t\t      const struct pci_device_id *id)\n{\n\tstruct cfb_info *cfb;\n\tchar name[16];\n\tint err;\n\n\tsprintf(name, \"CyberPro%4X\", id->device);\n\n\terr = aperture_remove_conflicting_pci_devices(dev, name);\n\tif (err)\n\t\treturn err;\n\n\terr = pci_enable_device(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tcfb = cyberpro_alloc_fb_info(id->driver_data, name);\n\tif (!cfb)\n\t\tgoto failed_release;\n\n\terr = pci_request_regions(dev, cfb->fb.fix.id);\n\tif (err)\n\t\tgoto failed_regions;\n\n\tcfb->irq = dev->irq;\n\tcfb->region = pci_ioremap_bar(dev, 0);\n\tif (!cfb->region) {\n\t\terr = -ENOMEM;\n\t\tgoto failed_ioremap;\n\t}\n\n\tcfb->regs = cfb->region + MMIO_OFFSET;\n\tcfb->fb.device = &dev->dev;\n\tcfb->fb.fix.mmio_start = pci_resource_start(dev, 0) + MMIO_OFFSET;\n\tcfb->fb.fix.smem_start = pci_resource_start(dev, 0);\n\n\t \n\terr = cyberpro_pci_enable_mmio(cfb);\n\tif (err)\n\t\tgoto failed;\n\n\t \n\tcfb->mclk_mult = cyber2000_grphr(EXT_MCLK_MULT, cfb);\n\tcfb->mclk_div  = cyber2000_grphr(EXT_MCLK_DIV, cfb);\n\n#ifdef __arm__\n\t \n\tif (machine_is_netwinder()) {\n\t\tcfb->mclk_mult = 0xdb;\n\t\tcfb->mclk_div  = 0x54;\n\t}\n#endif\n\n\terr = cyberpro_common_probe(cfb);\n\tif (err)\n\t\tgoto failed;\n\n\t \n\tpci_set_drvdata(dev, cfb);\n\tif (int_cfb_info == NULL)\n\t\tint_cfb_info = cfb;\n\n\treturn 0;\n\nfailed:\n\tiounmap(cfb->region);\nfailed_ioremap:\n\tpci_release_regions(dev);\nfailed_regions:\n\tcyberpro_free_fb_info(cfb);\nfailed_release:\n\tpci_disable_device(dev);\n\treturn err;\n}\n\nstatic void cyberpro_pci_remove(struct pci_dev *dev)\n{\n\tstruct cfb_info *cfb = pci_get_drvdata(dev);\n\n\tif (cfb) {\n\t\tcyberpro_common_remove(cfb);\n\t\tiounmap(cfb->region);\n\t\tcyberpro_free_fb_info(cfb);\n\n\t\tif (cfb == int_cfb_info)\n\t\t\tint_cfb_info = NULL;\n\n\t\tpci_release_regions(dev);\n\t\tpci_disable_device(dev);\n\t}\n}\n\nstatic int __maybe_unused cyberpro_pci_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\n \nstatic int __maybe_unused cyberpro_pci_resume(struct device *dev)\n{\n\tstruct cfb_info *cfb = dev_get_drvdata(dev);\n\n\tif (cfb) {\n\t\tcyberpro_pci_enable_mmio(cfb);\n\t\tcyberpro_common_resume(cfb);\n\t}\n\n\treturn 0;\n}\n\nstatic struct pci_device_id cyberpro_pci_table[] = {\n \n\t{ PCI_VENDOR_ID_INTERG, PCI_DEVICE_ID_INTERG_2000,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, ID_CYBERPRO_2000 },\n\t{ PCI_VENDOR_ID_INTERG, PCI_DEVICE_ID_INTERG_2010,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, ID_CYBERPRO_2010 },\n\t{ PCI_VENDOR_ID_INTERG, PCI_DEVICE_ID_INTERG_5000,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, ID_CYBERPRO_5000 },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, cyberpro_pci_table);\n\nstatic SIMPLE_DEV_PM_OPS(cyberpro_pci_pm_ops,\n\t\t\t cyberpro_pci_suspend,\n\t\t\t cyberpro_pci_resume);\n\nstatic struct pci_driver cyberpro_driver = {\n\t.name\t\t= \"CyberPro\",\n\t.probe\t\t= cyberpro_pci_probe,\n\t.remove\t\t= cyberpro_pci_remove,\n\t.driver.pm\t= &cyberpro_pci_pm_ops,\n\t.id_table\t= cyberpro_pci_table\n};\n\n \nstatic int __init cyber2000fb_init(void)\n{\n\tint ret = -1, err;\n\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"CyberPro\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"cyber2000fb\", &option))\n\t\treturn -ENODEV;\n\tcyber2000fb_setup(option);\n#endif\n\n\terr = pci_register_driver(&cyberpro_driver);\n\tif (!err)\n\t\tret = 0;\n\n\treturn ret ? err : 0;\n}\nmodule_init(cyber2000fb_init);\n\nstatic void __exit cyberpro_exit(void)\n{\n\tpci_unregister_driver(&cyberpro_driver);\n}\nmodule_exit(cyberpro_exit);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"CyberPro 2000, 2010 and 5000 framebuffer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}