{
  "module_name": "i810-i2c.c",
  "hash_id": "2b2f5cb20afb822d3120f9e82bc3890cc08a474566a69760ac657482de32d0e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/i810/i810-i2c.c",
  "human_readable_source": "  \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <linux/pci.h>\n#include <linux/fb.h>\n#include \"i810.h\"\n#include \"i810_regs.h\"\n#include \"i810_main.h\"\n#include \"../edid.h\"\n\n \n#define SCL_DIR_MASK\t\t0x0001\n#define SCL_DIR\t\t\t0x0002\n#define SCL_VAL_MASK\t\t0x0004\n#define SCL_VAL_OUT\t\t0x0008\n#define SCL_VAL_IN\t\t0x0010\n#define SDA_DIR_MASK\t\t0x0100\n#define SDA_DIR\t\t\t0x0200\n#define SDA_VAL_MASK\t\t0x0400\n#define SDA_VAL_OUT\t\t0x0800\n#define SDA_VAL_IN\t\t0x1000\n\n#define DEBUG   \n\n#ifdef DEBUG\n#define DPRINTK(fmt, args...) printk(fmt,## args)\n#else\n#define DPRINTK(fmt, args...)\n#endif\n\nstatic void i810i2c_setscl(void *data, int state)\n{\n        struct i810fb_i2c_chan    *chan = data;\n        struct i810fb_par         *par = chan->par;\n\tu8                        __iomem *mmio = par->mmio_start_virtual;\n\n\tif (state)\n\t\ti810_writel(mmio, chan->ddc_base, SCL_DIR_MASK | SCL_VAL_MASK);\n\telse\n\t\ti810_writel(mmio, chan->ddc_base, SCL_DIR | SCL_DIR_MASK | SCL_VAL_MASK);\n\ti810_readl(mmio, chan->ddc_base);\t \n}\n\nstatic void i810i2c_setsda(void *data, int state)\n{\n        struct i810fb_i2c_chan    *chan = data;\n        struct i810fb_par         *par = chan->par;\n\tu8                        __iomem *mmio = par->mmio_start_virtual;\n\n\tif (state)\n\t\ti810_writel(mmio, chan->ddc_base, SDA_DIR_MASK | SDA_VAL_MASK);\n\telse\n\t\ti810_writel(mmio, chan->ddc_base, SDA_DIR | SDA_DIR_MASK | SDA_VAL_MASK);\n\ti810_readl(mmio, chan->ddc_base);\t \n}\n\nstatic int i810i2c_getscl(void *data)\n{\n        struct i810fb_i2c_chan    *chan = data;\n        struct i810fb_par         *par = chan->par;\n\tu8                        __iomem *mmio = par->mmio_start_virtual;\n\n\ti810_writel(mmio, chan->ddc_base, SCL_DIR_MASK);\n\ti810_writel(mmio, chan->ddc_base, 0);\n\treturn ((i810_readl(mmio, chan->ddc_base) & SCL_VAL_IN) != 0);\n}\n\nstatic int i810i2c_getsda(void *data)\n{\n        struct i810fb_i2c_chan    *chan = data;\n        struct i810fb_par         *par = chan->par;\n\tu8                        __iomem *mmio = par->mmio_start_virtual;\n\n\ti810_writel(mmio, chan->ddc_base, SDA_DIR_MASK);\n\ti810_writel(mmio, chan->ddc_base, 0);\n\treturn ((i810_readl(mmio, chan->ddc_base) & SDA_VAL_IN) != 0);\n}\n\nstatic int i810_setup_i2c_bus(struct i810fb_i2c_chan *chan, const char *name)\n{\n        int rc;\n\n        strcpy(chan->adapter.name, name);\n        chan->adapter.owner             = THIS_MODULE;\n        chan->adapter.algo_data         = &chan->algo;\n        chan->adapter.dev.parent        = &chan->par->dev->dev;\n\tchan->algo.setsda               = i810i2c_setsda;\n\tchan->algo.setscl               = i810i2c_setscl;\n\tchan->algo.getsda               = i810i2c_getsda;\n\tchan->algo.getscl               = i810i2c_getscl;\n\tchan->algo.udelay               = 10;\n        chan->algo.timeout              = (HZ/2);\n        chan->algo.data                 = chan;\n\n        i2c_set_adapdata(&chan->adapter, chan);\n\n         \n        chan->algo.setsda(chan, 1);\n        chan->algo.setscl(chan, 1);\n        udelay(20);\n\n        rc = i2c_bit_add_bus(&chan->adapter);\n\n        if (rc == 0)\n                dev_dbg(&chan->par->dev->dev, \"I2C bus %s registered.\\n\",name);\n        else {\n                dev_warn(&chan->par->dev->dev, \"Failed to register I2C bus \"\n\t\t\t \"%s.\\n\", name);\n\t\tchan->par = NULL;\n\t}\n\n        return rc;\n}\n\nvoid i810_create_i2c_busses(struct i810fb_par *par)\n{\n        par->chan[0].par        = par;\n\tpar->chan[1].par        = par;\n\tpar->chan[2].par        = par;\n\n\tpar->chan[0].ddc_base = GPIOA;\n\ti810_setup_i2c_bus(&par->chan[0], \"I810-DDC\");\n\tpar->chan[1].ddc_base = GPIOB;\n\ti810_setup_i2c_bus(&par->chan[1], \"I810-I2C\");\n\tpar->chan[2].ddc_base = GPIOC;\n\ti810_setup_i2c_bus(&par->chan[2], \"I810-GPIOC\");\n}\n\nvoid i810_delete_i2c_busses(struct i810fb_par *par)\n{\n        if (par->chan[0].par)\n\t\ti2c_del_adapter(&par->chan[0].adapter);\n        par->chan[0].par = NULL;\n\n\tif (par->chan[1].par)\n\t\ti2c_del_adapter(&par->chan[1].adapter);\n\tpar->chan[1].par = NULL;\n\n\tif (par->chan[2].par)\n\t\ti2c_del_adapter(&par->chan[2].adapter);\n\tpar->chan[2].par = NULL;\n}\n\nint i810_probe_i2c_connector(struct fb_info *info, u8 **out_edid, int conn)\n{\n\tstruct i810fb_par *par = info->par;\n        u8 *edid = NULL;\n\n\tDPRINTK(\"i810-i2c: Probe DDC%i Bus\\n\", conn+1);\n\tif (conn < par->ddc_num) {\n\t\tedid = fb_ddc_read(&par->chan[conn].adapter);\n\t} else {\n\t\tconst u8 *e = fb_firmware_edid(info->device);\n\n\t\tif (e != NULL) {\n\t\t\tDPRINTK(\"i810-i2c: Getting EDID from BIOS\\n\");\n\t\t\tedid = kmemdup(e, EDID_LENGTH, GFP_KERNEL);\n\t\t}\n\t}\n\n\t*out_edid = edid;\n\n        return (edid) ? 0 : 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}