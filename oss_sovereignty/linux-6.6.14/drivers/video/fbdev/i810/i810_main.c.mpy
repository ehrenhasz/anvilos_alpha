{
  "module_name": "i810_main.c",
  "hash_id": "301606d06f5045f6c35638f7faafe42f3d626e6cd198ba54f15c234a330a18ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/i810/i810_main.c",
  "human_readable_source": "  \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/resource.h>\n#include <linux/unistd.h>\n#include <linux/console.h>\n#include <linux/io.h>\n\n#include <asm/io.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n\n#include \"i810_regs.h\"\n#include \"i810.h\"\n#include \"i810_main.h\"\n\n \nstatic u32 v_offset_default;  \nstatic u32 voffset;\n\nstatic int i810fb_cursor(struct fb_info *info, struct fb_cursor *cursor);\nstatic int i810fb_init_pci(struct pci_dev *dev,\n\t\t\t   const struct pci_device_id *entry);\nstatic void i810fb_remove_pci(struct pci_dev *dev);\nstatic int i810fb_resume(struct pci_dev *dev);\nstatic int i810fb_suspend(struct pci_dev *dev, pm_message_t state);\n\n \nstatic int i810fb_set_par    (struct fb_info *info);\nstatic int i810fb_getcolreg  (u8 regno, u8 *red, u8 *green, u8 *blue,\n\t\t\t      u8 *transp, struct fb_info *info);\nstatic int i810fb_setcolreg  (unsigned regno, unsigned red, unsigned green, unsigned blue,\n\t\t\t      unsigned transp, struct fb_info *info);\nstatic int i810fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info);\nstatic int i810fb_blank      (int blank_mode, struct fb_info *info);\n\n \nstatic void i810fb_release_resource       (struct fb_info *info, struct i810fb_par *par);\n\n \nstatic const char * const i810_pci_list[] = {\n\t\"Intel(R) 810 Framebuffer Device\"                                 ,\n\t\"Intel(R) 810-DC100 Framebuffer Device\"                           ,\n\t\"Intel(R) 810E Framebuffer Device\"                                ,\n\t\"Intel(R) 815 (Internal Graphics 100Mhz FSB) Framebuffer Device\"  ,\n\t\"Intel(R) 815 (Internal Graphics only) Framebuffer Device\"        ,\n\t\"Intel(R) 815 (Internal Graphics with AGP) Framebuffer Device\"\n};\n\nstatic const struct pci_device_id i810fb_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82810_IG1,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82810_IG3,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1  },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82810E_IG,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2 },\n\t \n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82815_100,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 3 },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82815_NOAGP,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 4 },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82815_CGC,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 5 },\n\t{ 0 },\n};\n\nstatic struct pci_driver i810fb_driver = {\n\t.name     =\t\"i810fb\",\n\t.id_table =\ti810fb_pci_tbl,\n\t.probe    =\ti810fb_init_pci,\n\t.remove   =\ti810fb_remove_pci,\n\t.suspend  =     i810fb_suspend,\n\t.resume   =     i810fb_resume,\n};\n\nstatic char *mode_option = NULL;\nstatic int vram = 4;\nstatic int bpp = 8;\nstatic bool mtrr;\nstatic bool accel;\nstatic int hsync1;\nstatic int hsync2;\nstatic int vsync1;\nstatic int vsync2;\nstatic int xres;\nstatic int yres;\nstatic int vyres;\nstatic bool sync;\nstatic bool extvga;\nstatic bool dcolor;\nstatic bool ddc3;\n\n \n\n \n\n \nstatic void i810_screen_off(u8 __iomem *mmio, u8 mode)\n{\n\tu32 count = WAIT_COUNT;\n\tu8 val;\n\n\ti810_writeb(SR_INDEX, mmio, SR01);\n\tval = i810_readb(SR_DATA, mmio);\n\tval = (mode == OFF) ? val | SCR_OFF :\n\t\tval & ~SCR_OFF;\n\n\twhile((i810_readw(DISP_SL, mmio) & 0xFFF) && count--);\n\ti810_writeb(SR_INDEX, mmio, SR01);\n\ti810_writeb(SR_DATA, mmio, val);\n}\n\n \nstatic void i810_dram_off(u8 __iomem *mmio, u8 mode)\n{\n\tu8 val;\n\n\tval = i810_readb(DRAMCH, mmio);\n\tval &= DRAM_OFF;\n\tval = (mode == OFF) ? val : val | DRAM_ON;\n\ti810_writeb(DRAMCH, mmio, val);\n}\n\n \nstatic void i810_protect_regs(u8 __iomem *mmio, int mode)\n{\n\tu8 reg;\n\n\ti810_writeb(CR_INDEX_CGA, mmio, CR11);\n\treg = i810_readb(CR_DATA_CGA, mmio);\n\treg = (mode == OFF) ? reg & ~0x80 :\n\t\treg | 0x80;\n\n\ti810_writeb(CR_INDEX_CGA, mmio, CR11);\n\ti810_writeb(CR_DATA_CGA, mmio, reg);\n}\n\n \nstatic void i810_load_pll(struct i810fb_par *par)\n{\n\tu32 tmp1, tmp2;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\ttmp1 = par->regs.M | par->regs.N << 16;\n\ttmp2 = i810_readl(DCLK_2D, mmio);\n\ttmp2 &= ~MN_MASK;\n\ti810_writel(DCLK_2D, mmio, tmp1 | tmp2);\n\n\ttmp1 = par->regs.P;\n\ttmp2 = i810_readl(DCLK_0DS, mmio);\n\ttmp2 &= ~(P_OR << 16);\n\ti810_writel(DCLK_0DS, mmio, (tmp1 << 16) | tmp2);\n\n\ti810_writeb(MSR_WRITE, mmio, par->regs.msr | 0xC8 | 1);\n\n}\n\n \nstatic void i810_load_vga(struct i810fb_par *par)\n{\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\t \n\ti810_writeb(CR_INDEX_CGA, mmio, CR70);\n\ti810_writeb(CR_DATA_CGA, mmio, par->interlace);\n\n\ti810_writeb(CR_INDEX_CGA, mmio, CR00);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr00);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR01);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr01);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR02);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr02);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR03);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr03);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR04);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr04);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR05);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr05);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR06);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr06);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR09);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr09);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR10);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr10);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR11);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr11);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR12);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr12);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR15);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr15);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR16);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr16);\n}\n\n \nstatic void i810_load_vgax(struct i810fb_par *par)\n{\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\ti810_writeb(CR_INDEX_CGA, mmio, CR30);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr30);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR31);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr31);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR32);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr32);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR33);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr33);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR35);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr35);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR39);\n\ti810_writeb(CR_DATA_CGA, mmio, par->regs.cr39);\n}\n\n \nstatic void i810_load_2d(struct i810fb_par *par)\n{\n\tu32 tmp;\n\tu8 tmp8;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n  \ti810_writel(FW_BLC, mmio, par->watermark);\n\ttmp = i810_readl(PIXCONF, mmio);\n\ttmp |= 1 | 1 << 20;\n\ti810_writel(PIXCONF, mmio, tmp);\n\n\ti810_writel(OVRACT, mmio, par->ovract);\n\n\ti810_writeb(GR_INDEX, mmio, GR10);\n\ttmp8 = i810_readb(GR_DATA, mmio);\n\ttmp8 |= 2;\n\ti810_writeb(GR_INDEX, mmio, GR10);\n\ti810_writeb(GR_DATA, mmio, tmp8);\n}\n\n \nstatic void i810_hires(u8 __iomem *mmio)\n{\n\tu8 val;\n\n\ti810_writeb(CR_INDEX_CGA, mmio, CR80);\n\tval = i810_readb(CR_DATA_CGA, mmio);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR80);\n\ti810_writeb(CR_DATA_CGA, mmio, val | 1);\n\t \n\ti810_writel(MEM_MODE, mmio, i810_readl(MEM_MODE, mmio) | 4);\n}\n\n \nstatic void i810_load_pitch(struct i810fb_par *par)\n{\n\tu32 tmp, pitch;\n\tu8 val;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\tpitch = par->pitch >> 3;\n\ti810_writeb(SR_INDEX, mmio, SR01);\n\tval = i810_readb(SR_DATA, mmio);\n\tval &= 0xE0;\n\tval |= 1 | 1 << 2;\n\ti810_writeb(SR_INDEX, mmio, SR01);\n\ti810_writeb(SR_DATA, mmio, val);\n\n\ttmp = pitch & 0xFF;\n\ti810_writeb(CR_INDEX_CGA, mmio, CR13);\n\ti810_writeb(CR_DATA_CGA, mmio, (u8) tmp);\n\n\ttmp = pitch >> 8;\n\ti810_writeb(CR_INDEX_CGA, mmio, CR41);\n\tval = i810_readb(CR_DATA_CGA, mmio) & ~0x0F;\n\ti810_writeb(CR_INDEX_CGA, mmio, CR41);\n\ti810_writeb(CR_DATA_CGA, mmio, (u8) tmp | val);\n}\n\n \nstatic void i810_load_color(struct i810fb_par *par)\n{\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\tu32 reg1;\n\tu16 reg2;\n\n\treg1 = i810_readl(PIXCONF, mmio) & ~(0xF0000 | 1 << 27);\n\treg2 = i810_readw(BLTCNTL, mmio) & ~0x30;\n\n\treg1 |= 0x8000 | par->pixconf;\n\treg2 |= par->bltcntl;\n\ti810_writel(PIXCONF, mmio, reg1);\n\ti810_writew(BLTCNTL, mmio, reg2);\n}\n\n \nstatic void i810_load_regs(struct i810fb_par *par)\n{\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\ti810_screen_off(mmio, OFF);\n\ti810_protect_regs(mmio, OFF);\n\ti810_dram_off(mmio, OFF);\n\ti810_load_pll(par);\n\ti810_load_vga(par);\n\ti810_load_vgax(par);\n\ti810_dram_off(mmio, ON);\n\ti810_load_2d(par);\n\ti810_hires(mmio);\n\ti810_screen_off(mmio, ON);\n\ti810_protect_regs(mmio, ON);\n\ti810_load_color(par);\n\ti810_load_pitch(par);\n}\n\nstatic void i810_write_dac(u8 regno, u8 red, u8 green, u8 blue,\n\t\t\t  u8 __iomem *mmio)\n{\n\ti810_writeb(CLUT_INDEX_WRITE, mmio, regno);\n\ti810_writeb(CLUT_DATA, mmio, red);\n\ti810_writeb(CLUT_DATA, mmio, green);\n\ti810_writeb(CLUT_DATA, mmio, blue);\n}\n\nstatic void i810_read_dac(u8 regno, u8 *red, u8 *green, u8 *blue,\n\t\t\t  u8 __iomem *mmio)\n{\n\ti810_writeb(CLUT_INDEX_READ, mmio, regno);\n\t*red = i810_readb(CLUT_DATA, mmio);\n\t*green = i810_readb(CLUT_DATA, mmio);\n\t*blue = i810_readb(CLUT_DATA, mmio);\n}\n\n \nstatic void i810_restore_pll(struct i810fb_par *par)\n{\n\tu32 tmp1, tmp2;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\ttmp1 = par->hw_state.dclk_2d;\n\ttmp2 = i810_readl(DCLK_2D, mmio);\n\ttmp1 &= ~MN_MASK;\n\ttmp2 &= MN_MASK;\n\ti810_writel(DCLK_2D, mmio, tmp1 | tmp2);\n\n\ttmp1 = par->hw_state.dclk_1d;\n\ttmp2 = i810_readl(DCLK_1D, mmio);\n\ttmp1 &= ~MN_MASK;\n\ttmp2 &= MN_MASK;\n\ti810_writel(DCLK_1D, mmio, tmp1 | tmp2);\n\n\ti810_writel(DCLK_0DS, mmio, par->hw_state.dclk_0ds);\n}\n\nstatic void i810_restore_dac(struct i810fb_par *par)\n{\n\tu32 tmp1, tmp2;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\ttmp1 = par->hw_state.pixconf;\n\ttmp2 = i810_readl(PIXCONF, mmio);\n\ttmp1 &= DAC_BIT;\n\ttmp2 &= ~DAC_BIT;\n\ti810_writel(PIXCONF, mmio, tmp1 | tmp2);\n}\n\nstatic void i810_restore_vgax(struct i810fb_par *par)\n{\n\tu8 i, j;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\tfor (i = 0; i < 4; i++) {\n\t\ti810_writeb(CR_INDEX_CGA, mmio, CR30+i);\n\t\ti810_writeb(CR_DATA_CGA, mmio, *(&(par->hw_state.cr30) + i));\n\t}\n\ti810_writeb(CR_INDEX_CGA, mmio, CR35);\n\ti810_writeb(CR_DATA_CGA, mmio, par->hw_state.cr35);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR39);\n\ti810_writeb(CR_DATA_CGA, mmio, par->hw_state.cr39);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR41);\n\ti810_writeb(CR_DATA_CGA, mmio, par->hw_state.cr39);\n\n\t \n\ti810_writeb(CR_INDEX_CGA, mmio, CR70);\n\ti = par->hw_state.cr70;\n\ti &= INTERLACE_BIT;\n\tj = i810_readb(CR_DATA_CGA, mmio);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR70);\n\ti810_writeb(CR_DATA_CGA, mmio, j | i);\n\n\ti810_writeb(CR_INDEX_CGA, mmio, CR80);\n\ti810_writeb(CR_DATA_CGA, mmio, par->hw_state.cr80);\n\ti810_writeb(MSR_WRITE, mmio, par->hw_state.msr);\n\ti810_writeb(SR_INDEX, mmio, SR01);\n\ti = (par->hw_state.sr01) & ~0xE0 ;\n\tj = i810_readb(SR_DATA, mmio) & 0xE0;\n\ti810_writeb(SR_INDEX, mmio, SR01);\n\ti810_writeb(SR_DATA, mmio, i | j);\n}\n\nstatic void i810_restore_vga(struct i810fb_par *par)\n{\n\tu8 i;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\tfor (i = 0; i < 10; i++) {\n\t\ti810_writeb(CR_INDEX_CGA, mmio, CR00 + i);\n\t\ti810_writeb(CR_DATA_CGA, mmio, *((&par->hw_state.cr00) + i));\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\ti810_writeb(CR_INDEX_CGA, mmio, CR10 + i);\n\t\ti810_writeb(CR_DATA_CGA, mmio, *((&par->hw_state.cr10) + i));\n\t}\n}\n\nstatic void i810_restore_addr_map(struct i810fb_par *par)\n{\n\tu8 tmp;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\ti810_writeb(GR_INDEX, mmio, GR10);\n\ttmp = i810_readb(GR_DATA, mmio);\n\ttmp &= ADDR_MAP_MASK;\n\ttmp |= par->hw_state.gr10;\n\ti810_writeb(GR_INDEX, mmio, GR10);\n\ti810_writeb(GR_DATA, mmio, tmp);\n}\n\nstatic void i810_restore_2d(struct i810fb_par *par)\n{\n\tu32 tmp_long;\n\tu16 tmp_word;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\ttmp_word = i810_readw(BLTCNTL, mmio);\n\ttmp_word &= ~(3 << 4);\n\ttmp_word |= par->hw_state.bltcntl;\n\ti810_writew(BLTCNTL, mmio, tmp_word);\n\n\ti810_dram_off(mmio, OFF);\n\ti810_writel(PIXCONF, mmio, par->hw_state.pixconf);\n\ti810_dram_off(mmio, ON);\n\n\ttmp_word = i810_readw(HWSTAM, mmio);\n\ttmp_word &= 3 << 13;\n\ttmp_word |= par->hw_state.hwstam;\n\ti810_writew(HWSTAM, mmio, tmp_word);\n\n\ttmp_long = i810_readl(FW_BLC, mmio);\n\ttmp_long &= FW_BLC_MASK;\n\ttmp_long |= par->hw_state.fw_blc;\n\ti810_writel(FW_BLC, mmio, tmp_long);\n\n\ti810_writel(HWS_PGA, mmio, par->hw_state.hws_pga);\n\ti810_writew(IER, mmio, par->hw_state.ier);\n\ti810_writew(IMR, mmio, par->hw_state.imr);\n\ti810_writel(DPLYSTAS, mmio, par->hw_state.dplystas);\n}\n\nstatic void i810_restore_vga_state(struct i810fb_par *par)\n{\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\ti810_screen_off(mmio, OFF);\n\ti810_protect_regs(mmio, OFF);\n\ti810_dram_off(mmio, OFF);\n\ti810_restore_pll(par);\n\ti810_restore_dac(par);\n\ti810_restore_vga(par);\n\ti810_restore_vgax(par);\n\ti810_restore_addr_map(par);\n\ti810_dram_off(mmio, ON);\n\ti810_restore_2d(par);\n\ti810_screen_off(mmio, ON);\n\ti810_protect_regs(mmio, ON);\n}\n\n \n\nstatic void i810_save_vgax(struct i810fb_par *par)\n{\n\tu8 i;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\tfor (i = 0; i < 4; i++) {\n\t\ti810_writeb(CR_INDEX_CGA, mmio, CR30 + i);\n\t\t*(&(par->hw_state.cr30) + i) = i810_readb(CR_DATA_CGA, mmio);\n\t}\n\ti810_writeb(CR_INDEX_CGA, mmio, CR35);\n\tpar->hw_state.cr35 = i810_readb(CR_DATA_CGA, mmio);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR39);\n\tpar->hw_state.cr39 = i810_readb(CR_DATA_CGA, mmio);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR41);\n\tpar->hw_state.cr41 = i810_readb(CR_DATA_CGA, mmio);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR70);\n\tpar->hw_state.cr70 = i810_readb(CR_DATA_CGA, mmio);\n\tpar->hw_state.msr = i810_readb(MSR_READ, mmio);\n\ti810_writeb(CR_INDEX_CGA, mmio, CR80);\n\tpar->hw_state.cr80 = i810_readb(CR_DATA_CGA, mmio);\n\ti810_writeb(SR_INDEX, mmio, SR01);\n\tpar->hw_state.sr01 = i810_readb(SR_DATA, mmio);\n}\n\nstatic void i810_save_vga(struct i810fb_par *par)\n{\n\tu8 i;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\tfor (i = 0; i < 10; i++) {\n\t\ti810_writeb(CR_INDEX_CGA, mmio, CR00 + i);\n\t\t*((&par->hw_state.cr00) + i) = i810_readb(CR_DATA_CGA, mmio);\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\ti810_writeb(CR_INDEX_CGA, mmio, CR10 + i);\n\t\t*((&par->hw_state.cr10) + i) = i810_readb(CR_DATA_CGA, mmio);\n\t}\n}\n\nstatic void i810_save_2d(struct i810fb_par *par)\n{\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\tpar->hw_state.dclk_2d = i810_readl(DCLK_2D, mmio);\n\tpar->hw_state.dclk_1d = i810_readl(DCLK_1D, mmio);\n\tpar->hw_state.dclk_0ds = i810_readl(DCLK_0DS, mmio);\n\tpar->hw_state.pixconf = i810_readl(PIXCONF, mmio);\n\tpar->hw_state.fw_blc = i810_readl(FW_BLC, mmio);\n\tpar->hw_state.bltcntl = i810_readw(BLTCNTL, mmio);\n\tpar->hw_state.hwstam = i810_readw(HWSTAM, mmio);\n\tpar->hw_state.hws_pga = i810_readl(HWS_PGA, mmio);\n\tpar->hw_state.ier = i810_readw(IER, mmio);\n\tpar->hw_state.imr = i810_readw(IMR, mmio);\n\tpar->hw_state.dplystas = i810_readl(DPLYSTAS, mmio);\n}\n\nstatic void i810_save_vga_state(struct i810fb_par *par)\n{\n\ti810_save_vga(par);\n\ti810_save_vgax(par);\n\ti810_save_2d(par);\n}\n\n \n \nstatic u32 get_line_length(struct i810fb_par *par, int xres_virtual, int bpp)\n{\n   \tu32 length;\n\n\tlength = xres_virtual*bpp;\n\tlength = (length+31)&-32;\n\tlength >>= 3;\n\treturn length;\n}\n\n \nstatic void i810_calc_dclk(u32 freq, u32 *m, u32 *n, u32 *p)\n{\n\tu32 m_reg, n_reg, p_divisor, n_target_max;\n\tu32 m_target, n_target, p_target, n_best, m_best, mod;\n\tu32 f_out, target_freq, diff = 0, mod_min, diff_min;\n\n\tdiff_min = mod_min = 0xFFFFFFFF;\n\tn_best = m_best = m_target = f_out = 0;\n\n\ttarget_freq =  freq;\n\tn_target_max = 30;\n\n\t \n\tp_divisor = 1;\n\tp_target = 0;\n\twhile(!((1000000 * p_divisor)/(16 * 24 * target_freq)) &&\n\t      p_divisor <= 32) {\n\t\tp_divisor <<= 1;\n\t\tp_target++;\n\t}\n\n\tn_reg = m_reg = n_target = 3;\n\twhile (diff_min && mod_min && (n_target < n_target_max)) {\n\t\tf_out = (p_divisor * n_reg * 1000000)/(4 * 24 * m_reg);\n\t\tmod = (p_divisor * n_reg * 1000000) % (4 * 24 * m_reg);\n\t\tm_target = m_reg;\n\t\tn_target = n_reg;\n\t\tif (f_out <= target_freq) {\n\t\t\tn_reg++;\n\t\t\tdiff = target_freq - f_out;\n\t\t} else {\n\t\t\tm_reg++;\n\t\t\tdiff = f_out - target_freq;\n\t\t}\n\n\t\tif (diff_min > diff) {\n\t\t\tdiff_min = diff;\n\t\t\tn_best = n_target;\n\t\t\tm_best = m_target;\n\t\t}\n\n\t\tif (!diff && mod_min > mod) {\n\t\t\tmod_min = mod;\n\t\t\tn_best = n_target;\n\t\t\tm_best = m_target;\n\t\t}\n\t}\n\tif (m) *m = (m_best - 2) & 0x3FF;\n\tif (n) *n = (n_best - 2) & 0x3FF;\n\tif (p) *p = (p_target << 4);\n}\n\n \n\n \nstatic void i810_enable_cursor(u8 __iomem *mmio, int mode)\n{\n\tu32 temp;\n\n\ttemp = i810_readl(PIXCONF, mmio);\n\ttemp = (mode == ON) ? temp | CURSOR_ENABLE_MASK :\n\t\ttemp & ~CURSOR_ENABLE_MASK;\n\n\ti810_writel(PIXCONF, mmio, temp);\n}\n\nstatic void i810_reset_cursor_image(struct i810fb_par *par)\n{\n\tu8 __iomem *addr = par->cursor_heap.virtual;\n\tint i, j;\n\n\tfor (i = 64; i--; ) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\ti810_writeb(j, addr, 0xff);\n\t\t\ti810_writeb(j+8, addr, 0x00);\n\t\t}\n\t\taddr +=16;\n\t}\n}\n\nstatic void i810_load_cursor_image(int width, int height, u8 *data,\n\t\t\t\t   struct i810fb_par *par)\n{\n\tu8 __iomem *addr = par->cursor_heap.virtual;\n\tint i, j, w = width/8;\n\tint mod = width % 8, t_mask, d_mask;\n\n\tt_mask = 0xff >> mod;\n\td_mask = ~(0xff >> mod);\n\tfor (i = height; i--; ) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\ti810_writeb(j+0, addr, 0x00);\n\t\t\ti810_writeb(j+8, addr, *data++);\n\t\t}\n\t\tif (mod) {\n\t\t\ti810_writeb(j+0, addr, t_mask);\n\t\t\ti810_writeb(j+8, addr, *data++ & d_mask);\n\t\t}\n\t\taddr += 16;\n\t}\n}\n\nstatic void i810_load_cursor_colors(int fg, int bg, struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\tu8 red, green, blue, trans, temp;\n\n\ti810fb_getcolreg(bg, &red, &green, &blue, &trans, info);\n\n\ttemp = i810_readb(PIXCONF1, mmio);\n\ti810_writeb(PIXCONF1, mmio, temp | EXTENDED_PALETTE);\n\n\ti810_write_dac(4, red, green, blue, mmio);\n\n\ti810_writeb(PIXCONF1, mmio, temp);\n\n\ti810fb_getcolreg(fg, &red, &green, &blue, &trans, info);\n\ttemp = i810_readb(PIXCONF1, mmio);\n\ti810_writeb(PIXCONF1, mmio, temp | EXTENDED_PALETTE);\n\n\ti810_write_dac(5, red, green, blue, mmio);\n\n\ti810_writeb(PIXCONF1, mmio, temp);\n}\n\n \nstatic void i810_init_cursor(struct i810fb_par *par)\n{\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\ti810_enable_cursor(mmio, OFF);\n\ti810_writel(CURBASE, mmio, par->cursor_heap.physical);\n\ti810_writew(CURCNTR, mmio, COORD_ACTIVE | CURSOR_MODE_64_XOR);\n}\n\n \n \nstatic void i810_round_off(struct fb_var_screeninfo *var)\n{\n\tu32 xres, yres, vxres, vyres;\n\n\t \n\n\txres = var->xres;\n\tyres = var->yres;\n\tvxres = var->xres_virtual;\n\tvyres = var->yres_virtual;\n\n\tvar->bits_per_pixel += 7;\n\tvar->bits_per_pixel &= ~7;\n\n\tif (var->bits_per_pixel < 8)\n\t\tvar->bits_per_pixel = 8;\n\tif (var->bits_per_pixel > 32)\n\t\tvar->bits_per_pixel = 32;\n\n\tround_off_xres(&xres);\n\tif (xres < 40)\n\t\txres = 40;\n\tif (xres > 2048)\n\t\txres = 2048;\n\txres = (xres + 7) & ~7;\n\n\tif (vxres < xres)\n\t\tvxres = xres;\n\n\tround_off_yres(&xres, &yres);\n\tif (yres < 1)\n\t\tyres = 1;\n\tif (yres >= 2048)\n\t\tyres = 2048;\n\n\tif (vyres < yres)\n\t\tvyres = yres;\n\n\tif (var->bits_per_pixel == 32)\n\t\tvar->accel_flags = 0;\n\n\t \n\tvar->left_margin = (var->left_margin + 4) & ~7;\n\tvar->right_margin = (var->right_margin + 4) & ~7;\n\tvar->hsync_len = (var->hsync_len + 4) & ~7;\n\n\tif (var->vmode & FB_VMODE_INTERLACED) {\n\t\tif (!((yres + var->upper_margin + var->vsync_len +\n\t\t       var->lower_margin) & 1))\n\t\t\tvar->upper_margin++;\n\t}\n\n\tvar->xres = xres;\n\tvar->yres = yres;\n\tvar->xres_virtual = vxres;\n\tvar->yres_virtual = vyres;\n}\n\n \nstatic void set_color_bitfields(struct fb_var_screeninfo *var)\n{\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 16:\n\t\tvar->green.length = (var->green.length == 5) ? 5 : 6;\n\t\tvar->red.length = 5;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.length = 6 - var->green.length;\n\t\tvar->blue.offset = 0;\n\t\tvar->green.offset = 5;\n\t\tvar->red.offset = 5 + var->green.length;\n\t\tvar->transp.offset =  (5 + var->red.offset) & 15;\n\t\tbreak;\n\tcase 24:\t \n\tcase 32:\t \n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.length = var->bits_per_pixel - 24;\n\t\tvar->transp.offset = (var->transp.length) ? 24 : 0;\n\t\tbreak;\n\t}\n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.msb_right = 0;\n\tvar->transp.msb_right = 0;\n}\n\n \nstatic int i810_check_params(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\tint line_length, vidmem, mode_valid = 0, retval = 0;\n\tu32 vyres = var->yres_virtual, vxres = var->xres_virtual;\n\n\t \n\tline_length = get_line_length(par, vxres, var->bits_per_pixel);\n\tvidmem = line_length*vyres;\n\n\tif (vidmem > par->fb.size) {\n\t\tvyres = par->fb.size/line_length;\n\t\tif (vyres < var->yres) {\n\t\t\tvyres = info->var.yres;\n\t\t\tvxres = par->fb.size/vyres;\n\t\t\tvxres /= var->bits_per_pixel >> 3;\n\t\t\tline_length = get_line_length(par, vxres,\n\t\t\t\t\t\t      var->bits_per_pixel);\n\t\t\tvidmem = line_length * info->var.yres;\n\t\t\tif (vxres < var->xres) {\n\t\t\t\tprintk(\"i810fb: required video memory, \"\n\t\t\t\t       \"%d bytes, for %dx%d-%d (virtual) \"\n\t\t\t\t       \"is out of range\\n\",\n\t\t\t\t       vidmem, vxres, vyres,\n\t\t\t\t       var->bits_per_pixel);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar->xres_virtual = vxres;\n\tvar->yres_virtual = vyres;\n\n\t \n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tinfo->monspecs.dclkmax = 234000000;\n\t\tbreak;\n\tcase 16:\n\t\tinfo->monspecs.dclkmax = 229000000;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tinfo->monspecs.dclkmax = 204000000;\n\t\tbreak;\n\t}\n\n\tinfo->monspecs.dclkmin = 15000000;\n\n\tif (!fb_validate_mode(var, info))\n\t\tmode_valid = 1;\n\n#ifdef CONFIG_FB_I810_I2C\n\tif (!mode_valid && info->monspecs.gtf &&\n\t    !fb_get_mode(FB_MAXTIMINGS, 0, var, info))\n\t\tmode_valid = 1;\n\n\tif (!mode_valid && info->monspecs.modedb_len) {\n\t\tconst struct fb_videomode *mode;\n\n\t\tmode = fb_find_best_mode(var, &info->modelist);\n\t\tif (mode) {\n\t\t\tfb_videomode_to_var(var, mode);\n\t\t\tmode_valid = 1;\n\t\t}\n\t}\n#endif\n\tif (!mode_valid && info->monspecs.modedb_len == 0) {\n\t\tif (fb_get_mode(FB_MAXTIMINGS, 0, var, info)) {\n\t\t\tint default_sync = (info->monspecs.hfmin-HFMIN)\n\t\t\t\t|(info->monspecs.hfmax-HFMAX)\n\t\t\t\t|(info->monspecs.vfmin-VFMIN)\n\t\t\t\t|(info->monspecs.vfmax-VFMAX);\n\t\t\tprintk(\"i810fb: invalid video mode%s\\n\",\n\t\t\t       default_sync ? \"\" : \". Specifying \"\n\t\t\t       \"vsyncN/hsyncN parameters may help\");\n\t\t\tretval = -EINVAL;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n \nstatic int encode_fix(struct fb_fix_screeninfo *fix, struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\n    \tmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\n\n    \tstrcpy(fix->id, \"I810\");\n\tmutex_lock(&info->mm_lock);\n    \tfix->smem_start = par->fb.physical;\n    \tfix->smem_len = par->fb.size;\n\tmutex_unlock(&info->mm_lock);\n    \tfix->type = FB_TYPE_PACKED_PIXELS;\n    \tfix->type_aux = 0;\n\tfix->xpanstep = 8;\n\tfix->ypanstep = 1;\n\n    \tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t    \tfix->visual = FB_VISUAL_PSEUDOCOLOR;\n\t    \tbreak;\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tif (info->var.nonstd)\n\t\t\tfix->visual = FB_VISUAL_DIRECTCOLOR;\n\t\telse\n\t\t\tfix->visual = FB_VISUAL_TRUECOLOR;\n\t    \tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n    \tfix->ywrapstep = 0;\n\tfix->line_length = par->pitch;\n\tfix->mmio_start = par->mmio_start_phys;\n\tfix->mmio_len = MMIO_SIZE;\n\tfix->accel = FB_ACCEL_I810;\n\n\treturn 0;\n}\n\n \nstatic void decode_var(const struct fb_var_screeninfo *var,\n\t\t       struct i810fb_par *par)\n{\n\tu32 xres, yres, vxres, vyres;\n\n\txres = var->xres;\n\tyres = var->yres;\n\tvxres = var->xres_virtual;\n\tvyres = var->yres_virtual;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tpar->pixconf = PIXCONF8;\n\t\tpar->bltcntl = 0;\n\t\tpar->depth = 1;\n\t\tpar->blit_bpp = BPP8;\n\t\tbreak;\n\tcase 16:\n\t\tif (var->green.length == 5)\n\t\t\tpar->pixconf = PIXCONF15;\n\t\telse\n\t\t\tpar->pixconf = PIXCONF16;\n\t\tpar->bltcntl = 16;\n\t\tpar->depth = 2;\n\t\tpar->blit_bpp = BPP16;\n\t\tbreak;\n\tcase 24:\n\t\tpar->pixconf = PIXCONF24;\n\t\tpar->bltcntl = 32;\n\t\tpar->depth = 3;\n\t\tpar->blit_bpp = BPP24;\n\t\tbreak;\n\tcase 32:\n\t\tpar->pixconf = PIXCONF32;\n\t\tpar->bltcntl = 0;\n\t\tpar->depth = 4;\n\t\tpar->blit_bpp = 3 << 24;\n\t\tbreak;\n\t}\n\tif (var->nonstd && var->bits_per_pixel != 8)\n\t\tpar->pixconf |= 1 << 27;\n\n\ti810_calc_dclk(var->pixclock, &par->regs.M,\n\t\t       &par->regs.N, &par->regs.P);\n\ti810fb_encode_registers(var, par, xres, yres);\n\n\tpar->watermark = i810_get_watermark(var, par);\n\tpar->pitch = get_line_length(par, vxres, var->bits_per_pixel);\n}\n\n \nstatic int i810fb_getcolreg(u8 regno, u8 *red, u8 *green, u8 *blue,\n\t\t\t    u8 *transp, struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\tu8 temp;\n\n\tif (info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\tif ((info->var.green.length == 5 && regno > 31) ||\n\t\t    (info->var.green.length == 6 && regno > 63))\n\t\t\treturn 1;\n\t}\n\n\ttemp = i810_readb(PIXCONF1, mmio);\n\ti810_writeb(PIXCONF1, mmio, temp & ~EXTENDED_PALETTE);\n\n\tif (info->fix.visual == FB_VISUAL_DIRECTCOLOR &&\n\t    info->var.green.length == 5)\n\t\ti810_read_dac(regno * 8, red, green, blue, mmio);\n\n\telse if (info->fix.visual == FB_VISUAL_DIRECTCOLOR &&\n\t\t info->var.green.length == 6) {\n\t\tu8 tmp;\n\n\t\ti810_read_dac(regno * 8, red, &tmp, blue, mmio);\n\t\ti810_read_dac(regno * 4, &tmp, green, &tmp, mmio);\n\t}\n\telse\n\t\ti810_read_dac(regno, red, green, blue, mmio);\n\n    \t*transp = 0;\n\ti810_writeb(PIXCONF1, mmio, temp);\n\n    \treturn 0;\n}\n\n \n\nstatic int i810fb_open(struct fb_info *info, int user)\n{\n\tstruct i810fb_par *par = info->par;\n\n\tmutex_lock(&par->open_lock);\n\tif (par->use_count == 0) {\n\t\tmemset(&par->state, 0, sizeof(struct vgastate));\n\t\tpar->state.flags = VGA_SAVE_CMAP;\n\t\tpar->state.vgabase = par->mmio_start_virtual;\n\t\tsave_vga(&par->state);\n\n\t\ti810_save_vga_state(par);\n\t}\n\n\tpar->use_count++;\n\tmutex_unlock(&par->open_lock);\n\n\treturn 0;\n}\n\nstatic int i810fb_release(struct fb_info *info, int user)\n{\n\tstruct i810fb_par *par = info->par;\n\n\tmutex_lock(&par->open_lock);\n\tif (par->use_count == 0) {\n\t\tmutex_unlock(&par->open_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (par->use_count == 1) {\n\t\ti810_restore_vga_state(par);\n\t\trestore_vga(&par->state);\n\t}\n\n\tpar->use_count--;\n\tmutex_unlock(&par->open_lock);\n\n\treturn 0;\n}\n\n\nstatic int i810fb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t    unsigned blue, unsigned transp,\n\t\t\t    struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\tu8 temp;\n\tint i;\n\n \tif (regno > 255) return 1;\n\n\tif (info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\tif ((info->var.green.length == 5 && regno > 31) ||\n\t\t    (info->var.green.length == 6 && regno > 63))\n\t\t\treturn 1;\n\t}\n\n\tif (info->var.grayscale)\n\t\tred = green = blue = (19595 * red + 38470 * green +\n\t\t\t\t      7471 * blue) >> 16;\n\n\ttemp = i810_readb(PIXCONF1, mmio);\n\ti810_writeb(PIXCONF1, mmio, temp & ~EXTENDED_PALETTE);\n\n\tif (info->fix.visual == FB_VISUAL_DIRECTCOLOR &&\n\t    info->var.green.length == 5) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\ti810_write_dac((u8) (regno * 8) + i, (u8) red,\n\t\t\t\t       (u8) green, (u8) blue, mmio);\n\t} else if (info->fix.visual == FB_VISUAL_DIRECTCOLOR &&\n\t\t info->var.green.length == 6) {\n\t\tu8 r, g, b;\n\n\t\tif (regno < 32) {\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\ti810_write_dac((u8) (regno * 8) + i,\n\t\t\t\t\t       (u8) red, (u8) green,\n\t\t\t\t\t       (u8) blue, mmio);\n\t\t}\n\t\ti810_read_dac((u8) (regno*4), &r, &g, &b, mmio);\n\t\tfor (i = 0; i < 4; i++)\n\t\t\ti810_write_dac((u8) (regno*4) + i, r, (u8) green,\n\t\t\t\t       b, mmio);\n\t} else if (info->fix.visual == FB_VISUAL_PSEUDOCOLOR) {\n\t\ti810_write_dac((u8) regno, (u8) red, (u8) green,\n\t\t\t       (u8) blue, mmio);\n\t}\n\n\ti810_writeb(PIXCONF1, mmio, temp);\n\n\tif (regno < 16) {\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 16:\n\t\t\tif (info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\t\t\tif (info->var.green.length == 5)\n\t\t\t\t\t((u32 *)info->pseudo_palette)[regno] =\n\t\t\t\t\t\t(regno << 10) | (regno << 5) |\n\t\t\t\t\t\tregno;\n\t\t\t\telse\n\t\t\t\t\t((u32 *)info->pseudo_palette)[regno] =\n\t\t\t\t\t\t(regno << 11) | (regno << 5) |\n\t\t\t\t\t\tregno;\n\t\t\t} else {\n\t\t\t\tif (info->var.green.length == 5) {\n\t\t\t\t\t \n\t\t\t\t\t((u32 *)info->pseudo_palette)[regno] =\n\t\t\t\t\t\t((red & 0xf800) >> 1) |\n\t\t\t\t\t\t((green & 0xf800) >> 6) |\n\t\t\t\t\t\t((blue & 0xf800) >> 11);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\t((u32 *)info->pseudo_palette)[regno] =\n\t\t\t\t\t\t(red & 0xf800) |\n\t\t\t\t\t\t((green & 0xf800) >> 5) |\n\t\t\t\t\t\t((blue & 0xf800) >> 11);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 24:\t \n\t\tcase 32:\t \n\t\t\tif (info->fix.visual == FB_VISUAL_DIRECTCOLOR)\n\t\t\t\t((u32 *)info->pseudo_palette)[regno] =\n\t\t\t\t\t(regno << 16) | (regno << 8) |\n\t\t\t\t\tregno;\n\t\t\telse\n\t\t\t\t((u32 *)info->pseudo_palette)[regno] =\n\t\t\t\t\t((red & 0xff00) << 8) |\n\t\t\t\t\t(green & 0xff00) |\n\t\t\t\t\t((blue & 0xff00) >> 8);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int i810fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\tu32 total;\n\n\ttotal = var->xoffset * par->depth +\n\t\tvar->yoffset * info->fix.line_length;\n\ti810fb_load_front(total, info);\n\n\treturn 0;\n}\n\nstatic int i810fb_blank (int blank_mode, struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\tint mode = 0, pwr, scr_off = 0;\n\n\tpwr = i810_readl(PWR_CLKC, mmio);\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\tmode = POWERON;\n\t\tpwr |= 1;\n\t\tscr_off = ON;\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\tmode = POWERON;\n\t\tpwr |= 1;\n\t\tscr_off = OFF;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tmode = STANDBY;\n\t\tpwr |= 1;\n\t\tscr_off = OFF;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tmode = SUSPEND;\n\t\tpwr |= 1;\n\t\tscr_off = OFF;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tmode = POWERDOWN;\n\t\tpwr &= ~1;\n\t\tscr_off = OFF;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ti810_screen_off(mmio, scr_off);\n\ti810_writel(HVSYNC, mmio, mode);\n\ti810_writel(PWR_CLKC, mmio, pwr);\n\n\treturn 0;\n}\n\nstatic int i810fb_set_par(struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\n\tdecode_var(&info->var, par);\n\ti810_load_regs(par);\n\ti810_init_cursor(par);\n\tencode_fix(&info->fix, info);\n\n\tif (info->var.accel_flags && !(par->dev_flags & LOCKUP)) {\n\t\tinfo->flags = FBINFO_HWACCEL_YPAN |\n\t\tFBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |\n\t\tFBINFO_HWACCEL_IMAGEBLIT;\n\t\tinfo->pixmap.scan_align = 2;\n\t} else {\n\t\tinfo->pixmap.scan_align = 1;\n\t\tinfo->flags = FBINFO_HWACCEL_YPAN;\n\t}\n\treturn 0;\n}\n\nstatic int i810fb_check_var(struct fb_var_screeninfo *var,\n\t\t\t    struct fb_info *info)\n{\n\tint err;\n\n\tif (IS_DVT) {\n\t\tvar->vmode &= ~FB_VMODE_MASK;\n\t\tvar->vmode |= FB_VMODE_NONINTERLACED;\n\t}\n\tif (var->vmode & FB_VMODE_DOUBLE) {\n\t\tvar->vmode &= ~FB_VMODE_MASK;\n\t\tvar->vmode |= FB_VMODE_NONINTERLACED;\n\t}\n\n\ti810_round_off(var);\n\tif ((err = i810_check_params(var, info)))\n\t\treturn err;\n\n\ti810fb_fill_var_timings(var);\n\tset_color_bitfields(var);\n\treturn 0;\n}\n\nstatic int i810fb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\tstruct i810fb_par *par = info->par;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\tif (par->dev_flags & LOCKUP)\n\t\treturn -ENXIO;\n\n\tif (cursor->image.width > 64 || cursor->image.height > 64)\n\t\treturn -ENXIO;\n\n\tif ((i810_readl(CURBASE, mmio) & 0xf) != par->cursor_heap.physical) {\n\t\ti810_init_cursor(par);\n\t\tcursor->set |= FB_CUR_SETALL;\n\t}\n\n\ti810_enable_cursor(mmio, OFF);\n\n\tif (cursor->set & FB_CUR_SETPOS) {\n\t\tu32 tmp;\n\n\t\ttmp = (cursor->image.dx - info->var.xoffset) & 0xffff;\n\t\ttmp |= (cursor->image.dy - info->var.yoffset) << 16;\n\t\ti810_writel(CURPOS, mmio, tmp);\n\t}\n\n\tif (cursor->set & FB_CUR_SETSIZE)\n\t\ti810_reset_cursor_image(par);\n\n\tif (cursor->set & FB_CUR_SETCMAP)\n\t\ti810_load_cursor_colors(cursor->image.fg_color,\n\t\t\t\t\tcursor->image.bg_color,\n\t\t\t\t\tinfo);\n\n\tif (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\n\t\tint size = ((cursor->image.width + 7) >> 3) *\n\t\t\tcursor->image.height;\n\t\tint i;\n\t\tu8 *data = kmalloc(64 * 8, GFP_ATOMIC);\n\n\t\tif (data == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tswitch (cursor->rop) {\n\t\tcase ROP_XOR:\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\tdata[i] = cursor->image.data[i] ^ cursor->mask[i];\n\t\t\tbreak;\n\t\tcase ROP_COPY:\n\t\tdefault:\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\tdata[i] = cursor->image.data[i] & cursor->mask[i];\n\t\t\tbreak;\n\t\t}\n\n\t\ti810_load_cursor_image(cursor->image.width,\n\t\t\t\t       cursor->image.height, data,\n\t\t\t\t       par);\n\t\tkfree(data);\n\t}\n\n\tif (cursor->enable)\n\t\ti810_enable_cursor(mmio, ON);\n\n\treturn 0;\n}\n\nstatic const struct fb_ops i810fb_ops = {\n\t.owner =             THIS_MODULE,\n\t.fb_open =           i810fb_open,\n\t.fb_release =        i810fb_release,\n\t.fb_check_var =      i810fb_check_var,\n\t.fb_set_par =        i810fb_set_par,\n\t.fb_setcolreg =      i810fb_setcolreg,\n\t.fb_blank =          i810fb_blank,\n\t.fb_pan_display =    i810fb_pan_display,\n\t.fb_fillrect =       i810fb_fillrect,\n\t.fb_copyarea =       i810fb_copyarea,\n\t.fb_imageblit =      i810fb_imageblit,\n\t.fb_cursor =         i810fb_cursor,\n\t.fb_sync =           i810fb_sync,\n};\n\n \nstatic int i810fb_suspend(struct pci_dev *dev, pm_message_t mesg)\n{\n\tstruct fb_info *info = pci_get_drvdata(dev);\n\tstruct i810fb_par *par = info->par;\n\n\tpar->cur_state = mesg.event;\n\n\tswitch (mesg.event) {\n\tcase PM_EVENT_FREEZE:\n\tcase PM_EVENT_PRETHAW:\n\t\tdev->dev.power.power_state = mesg;\n\t\treturn 0;\n\t}\n\n\tconsole_lock();\n\tfb_set_suspend(info, 1);\n\n\tif (info->fbops->fb_sync)\n\t\tinfo->fbops->fb_sync(info);\n\n\ti810fb_blank(FB_BLANK_POWERDOWN, info);\n\tagp_unbind_memory(par->i810_gtt.i810_fb_memory);\n\tagp_unbind_memory(par->i810_gtt.i810_cursor_memory);\n\n\tpci_save_state(dev);\n\tpci_disable_device(dev);\n\tpci_set_power_state(dev, pci_choose_state(dev, mesg));\n\tconsole_unlock();\n\n\treturn 0;\n}\n\nstatic int i810fb_resume(struct pci_dev *dev)\n{\n\tstruct fb_info *info = pci_get_drvdata(dev);\n\tstruct i810fb_par *par = info->par;\n\tint cur_state = par->cur_state;\n\n\tpar->cur_state = PM_EVENT_ON;\n\n\tif (cur_state == PM_EVENT_FREEZE) {\n\t\tpci_set_power_state(dev, PCI_D0);\n\t\treturn 0;\n\t}\n\n\tconsole_lock();\n\tpci_set_power_state(dev, PCI_D0);\n\tpci_restore_state(dev);\n\n\tif (pci_enable_device(dev))\n\t\tgoto fail;\n\n\tpci_set_master(dev);\n\tagp_bind_memory(par->i810_gtt.i810_fb_memory,\n\t\t\tpar->fb.offset);\n\tagp_bind_memory(par->i810_gtt.i810_cursor_memory,\n\t\t\tpar->cursor_heap.offset);\n\ti810fb_set_par(info);\n\tfb_set_suspend (info, 0);\n\tinfo->fbops->fb_blank(VESA_NO_BLANKING, info);\nfail:\n\tconsole_unlock();\n\treturn 0;\n}\n \n\nstatic void i810_fix_pointers(struct i810fb_par *par)\n{\n      \tpar->fb.physical = par->aperture.physical+(par->fb.offset << 12);\n\tpar->fb.virtual = par->aperture.virtual+(par->fb.offset << 12);\n\tpar->iring.physical = par->aperture.physical +\n\t\t(par->iring.offset << 12);\n\tpar->iring.virtual = par->aperture.virtual +\n\t\t(par->iring.offset << 12);\n\tpar->cursor_heap.virtual = par->aperture.virtual+\n\t\t(par->cursor_heap.offset << 12);\n}\n\nstatic void i810_fix_offsets(struct i810fb_par *par)\n{\n\tif (vram + 1 > par->aperture.size >> 20)\n\t\tvram = (par->aperture.size >> 20) - 1;\n\tif (v_offset_default > (par->aperture.size >> 20))\n\t\tv_offset_default = (par->aperture.size >> 20);\n\tif (vram + v_offset_default + 1 > par->aperture.size >> 20)\n\t\tv_offset_default = (par->aperture.size >> 20) - (vram + 1);\n\n\tpar->fb.size = vram << 20;\n\tpar->fb.offset = v_offset_default << 20;\n\tpar->fb.offset >>= 12;\n\n\tpar->iring.offset = par->fb.offset + (par->fb.size >> 12);\n\tpar->iring.size = RINGBUFFER_SIZE;\n\n\tpar->cursor_heap.offset = par->iring.offset + (RINGBUFFER_SIZE >> 12);\n\tpar->cursor_heap.size = 4096;\n}\n\nstatic int i810_alloc_agp_mem(struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\tint size;\n\tstruct agp_bridge_data *bridge;\n\n\ti810_fix_offsets(par);\n\tsize = par->fb.size + par->iring.size;\n\n\tif (!(bridge = agp_backend_acquire(par->dev))) {\n\t\tprintk(\"i810fb_alloc_fbmem: cannot acquire agpgart\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!(par->i810_gtt.i810_fb_memory =\n\t      agp_allocate_memory(bridge, size >> 12, AGP_NORMAL_MEMORY))) {\n\t\tprintk(\"i810fb_alloc_fbmem: can't allocate framebuffer \"\n\t\t       \"memory\\n\");\n\t\tagp_backend_release(bridge);\n\t\treturn -ENOMEM;\n\t}\n\tif (agp_bind_memory(par->i810_gtt.i810_fb_memory,\n\t\t\t    par->fb.offset)) {\n\t\tprintk(\"i810fb_alloc_fbmem: can't bind framebuffer memory\\n\");\n\t\tagp_backend_release(bridge);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!(par->i810_gtt.i810_cursor_memory =\n\t      agp_allocate_memory(bridge, par->cursor_heap.size >> 12,\n\t\t\t\t  AGP_PHYSICAL_MEMORY))) {\n\t\tprintk(\"i810fb_alloc_cursormem:  can't allocate \"\n\t\t       \"cursor memory\\n\");\n\t\tagp_backend_release(bridge);\n\t\treturn -ENOMEM;\n\t}\n\tif (agp_bind_memory(par->i810_gtt.i810_cursor_memory,\n\t\t\t    par->cursor_heap.offset)) {\n\t\tprintk(\"i810fb_alloc_cursormem: cannot bind cursor memory\\n\");\n\t\tagp_backend_release(bridge);\n\t\treturn -EBUSY;\n\t}\n\n\tpar->cursor_heap.physical = par->i810_gtt.i810_cursor_memory->physical;\n\n\ti810_fix_pointers(par);\n\n\tagp_backend_release(bridge);\n\n\treturn 0;\n}\n\n \n\n \nstatic void i810_init_monspecs(struct fb_info *info)\n{\n\tif (!hsync1)\n\t\thsync1 = HFMIN;\n\tif (!hsync2)\n\t\thsync2 = HFMAX;\n\tif (!info->monspecs.hfmax)\n\t\tinfo->monspecs.hfmax = hsync2;\n\tif (!info->monspecs.hfmin)\n\t\tinfo->monspecs.hfmin = hsync1;\n\tif (hsync2 < hsync1)\n\t\tinfo->monspecs.hfmin = hsync2;\n\n\tif (!vsync1)\n\t\tvsync1 = VFMIN;\n\tif (!vsync2)\n\t\tvsync2 = VFMAX;\n\tif (IS_DVT && vsync1 < 60)\n\t\tvsync1 = 60;\n\tif (!info->monspecs.vfmax)\n\t\tinfo->monspecs.vfmax = vsync2;\n\tif (!info->monspecs.vfmin)\n\t\tinfo->monspecs.vfmin = vsync1;\n\tif (vsync2 < vsync1)\n\t\tinfo->monspecs.vfmin = vsync2;\n}\n\n \nstatic void i810_init_defaults(struct i810fb_par *par, struct fb_info *info)\n{\n\tmutex_init(&par->open_lock);\n\n\tif (voffset)\n\t\tv_offset_default = voffset;\n\telse if (par->aperture.size > 32 * 1024 * 1024)\n\t\tv_offset_default = 16;\n\telse\n\t\tv_offset_default = 8;\n\n\tif (!vram)\n\t\tvram = 1;\n\n\tif (accel)\n\t\tpar->dev_flags |= HAS_ACCELERATION;\n\n\tif (sync)\n\t\tpar->dev_flags |= ALWAYS_SYNC;\n\n\tpar->ddc_num = (ddc3 ? 3 : 2);\n\n\tif (bpp < 8)\n\t\tbpp = 8;\n\n\tpar->i810fb_ops = i810fb_ops;\n\n\tif (xres)\n\t\tinfo->var.xres = xres;\n\telse\n\t\tinfo->var.xres = 640;\n\n\tif (yres)\n\t\tinfo->var.yres = yres;\n\telse\n\t\tinfo->var.yres = 480;\n\n\tif (!vyres)\n\t\tvyres = (vram << 20)/(info->var.xres*bpp >> 3);\n\n\tinfo->var.yres_virtual = vyres;\n\tinfo->var.bits_per_pixel = bpp;\n\n\tif (dcolor)\n\t\tinfo->var.nonstd = 1;\n\n\tif (par->dev_flags & HAS_ACCELERATION)\n\t\tinfo->var.accel_flags = 1;\n\n\ti810_init_monspecs(info);\n}\n\n \nstatic void i810_init_device(struct i810fb_par *par)\n{\n\tu8 reg;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\tif (mtrr)\n\t\tpar->wc_cookie= arch_phys_wc_add((u32) par->aperture.physical,\n\t\t\t\t\t\t par->aperture.size);\n\n\ti810_init_cursor(par);\n\n\t \n\tif (extvga) {\n\t\ti810_writel(HVSYNC, mmio, 0);\n\t\ti810_writel(PWR_CLKC, mmio, 3);\n\t}\n\n\tpci_read_config_byte(par->dev, 0x50, &reg);\n\treg &= FREQ_MASK;\n\tpar->mem_freq = (reg) ? 133 : 100;\n\n}\n\nstatic int i810_allocate_pci_resource(struct i810fb_par *par,\n\t\t\t\t      const struct pci_device_id *entry)\n{\n\tint err;\n\n\tif ((err = pci_enable_device(par->dev))) {\n\t\tprintk(\"i810fb_init: cannot enable device\\n\");\n\t\treturn err;\n\t}\n\tpar->res_flags |= PCI_DEVICE_ENABLED;\n\n\tif (pci_resource_len(par->dev, 0) > 512 * 1024) {\n\t\tpar->aperture.physical = pci_resource_start(par->dev, 0);\n\t\tpar->aperture.size = pci_resource_len(par->dev, 0);\n\t\tpar->mmio_start_phys = pci_resource_start(par->dev, 1);\n\t} else {\n\t\tpar->aperture.physical = pci_resource_start(par->dev, 1);\n\t\tpar->aperture.size = pci_resource_len(par->dev, 1);\n\t\tpar->mmio_start_phys = pci_resource_start(par->dev, 0);\n\t}\n\tif (!par->aperture.size) {\n\t\tprintk(\"i810fb_init: device is disabled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!request_mem_region(par->aperture.physical,\n\t\t\t\tpar->aperture.size,\n\t\t\t\ti810_pci_list[entry->driver_data])) {\n\t\tprintk(\"i810fb_init: cannot request framebuffer region\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpar->res_flags |= FRAMEBUFFER_REQ;\n\n\tpar->aperture.virtual = ioremap_wc(par->aperture.physical,\n\t\t\t\t\t   par->aperture.size);\n\tif (!par->aperture.virtual) {\n\t\tprintk(\"i810fb_init: cannot remap framebuffer region\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!request_mem_region(par->mmio_start_phys,\n\t\t\t\tMMIO_SIZE,\n\t\t\t\ti810_pci_list[entry->driver_data])) {\n\t\tprintk(\"i810fb_init: cannot request mmio region\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpar->res_flags |= MMIO_REQ;\n\n\tpar->mmio_start_virtual = ioremap(par->mmio_start_phys,\n\t\t\t\t\t\t  MMIO_SIZE);\n\tif (!par->mmio_start_virtual) {\n\t\tprintk(\"i810fb_init: cannot remap mmio region\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void i810fb_find_init_mode(struct fb_info *info)\n{\n\tstruct fb_videomode mode;\n\tstruct fb_var_screeninfo var;\n\tstruct fb_monspecs *specs = &info->monspecs;\n\tint found = 0;\n#ifdef CONFIG_FB_I810_I2C\n\tint i;\n\tint err = 1;\n\tstruct i810fb_par *par = info->par;\n#endif\n\n\tINIT_LIST_HEAD(&info->modelist);\n\tmemset(&mode, 0, sizeof(struct fb_videomode));\n\tvar = info->var;\n#ifdef CONFIG_FB_I810_I2C\n\ti810_create_i2c_busses(par);\n\n\tfor (i = 0; i < par->ddc_num + 1; i++) {\n\t\terr = i810_probe_i2c_connector(info, &par->edid, i);\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\tif (!err)\n\t\tprintk(\"i810fb_init_pci: DDC probe successful\\n\");\n\n\tfb_edid_to_monspecs(par->edid, specs);\n\n\tif (specs->modedb == NULL)\n\t\tprintk(\"i810fb_init_pci: Unable to get Mode Database\\n\");\n\n\tfb_videomode_to_modelist(specs->modedb, specs->modedb_len,\n\t\t\t\t &info->modelist);\n\tif (specs->modedb != NULL) {\n\t\tconst struct fb_videomode *m;\n\n\t\tif (xres && yres) {\n\t\t\tif ((m = fb_find_best_mode(&var, &info->modelist))) {\n\t\t\t\tmode = *m;\n\t\t\t\tfound  = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tm = fb_find_best_display(&info->monspecs, &info->modelist);\n\t\t\tmode = *m;\n\t\t\tfound = 1;\n\t\t}\n\n\t\tfb_videomode_to_var(&var, &mode);\n\t}\n#endif\n\tif (mode_option)\n\t\tfb_find_mode(&var, info, mode_option, specs->modedb,\n\t\t\t     specs->modedb_len, (found) ? &mode : NULL,\n\t\t\t     info->var.bits_per_pixel);\n\n\tinfo->var = var;\n\tfb_destroy_modedb(specs->modedb);\n\tspecs->modedb = NULL;\n}\n\n#ifndef MODULE\nstatic int i810fb_setup(char *options)\n{\n\tchar *this_opt, *suffix = NULL;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!strncmp(this_opt, \"mtrr\", 4))\n\t\t\tmtrr = true;\n\t\telse if (!strncmp(this_opt, \"accel\", 5))\n\t\t\taccel = true;\n\t\telse if (!strncmp(this_opt, \"extvga\", 6))\n\t\t\textvga = true;\n\t\telse if (!strncmp(this_opt, \"sync\", 4))\n\t\t\tsync = true;\n\t\telse if (!strncmp(this_opt, \"vram:\", 5))\n\t\t\tvram = (simple_strtoul(this_opt+5, NULL, 0));\n\t\telse if (!strncmp(this_opt, \"voffset:\", 8))\n\t\t\tvoffset = (simple_strtoul(this_opt+8, NULL, 0));\n\t\telse if (!strncmp(this_opt, \"xres:\", 5))\n\t\t\txres = simple_strtoul(this_opt+5, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"yres:\", 5))\n\t\t\tyres = simple_strtoul(this_opt+5, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"vyres:\", 6))\n\t\t\tvyres = simple_strtoul(this_opt+6, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"bpp:\", 4))\n\t\t\tbpp = simple_strtoul(this_opt+4, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"hsync1:\", 7)) {\n\t\t\thsync1 = simple_strtoul(this_opt+7, &suffix, 0);\n\t\t\tif (strncmp(suffix, \"H\", 1))\n\t\t\t\thsync1 *= 1000;\n\t\t} else if (!strncmp(this_opt, \"hsync2:\", 7)) {\n\t\t\thsync2 = simple_strtoul(this_opt+7, &suffix, 0);\n\t\t\tif (strncmp(suffix, \"H\", 1))\n\t\t\t\thsync2 *= 1000;\n\t\t} else if (!strncmp(this_opt, \"vsync1:\", 7))\n\t\t\tvsync1 = simple_strtoul(this_opt+7, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"vsync2:\", 7))\n\t\t\tvsync2 = simple_strtoul(this_opt+7, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"dcolor\", 6))\n\t\t\tdcolor = true;\n\t\telse if (!strncmp(this_opt, \"ddc3\", 4))\n\t\t\tddc3 = true;\n\t\telse\n\t\t\tmode_option = this_opt;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic int i810fb_init_pci(struct pci_dev *dev,\n\t\t\t   const struct pci_device_id *entry)\n{\n\tstruct fb_info    *info;\n\tstruct i810fb_par *par = NULL;\n\tstruct fb_videomode mode;\n\tint err = -1, vfreq, hfreq, pixclock;\n\n\terr = aperture_remove_conflicting_pci_devices(dev, \"i810fb\");\n\tif (err)\n\t\treturn err;\n\n\tinfo = framebuffer_alloc(sizeof(struct i810fb_par), &dev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tpar->dev = dev;\n\n\tif (!(info->pixmap.addr = kzalloc(8*1024, GFP_KERNEL))) {\n\t\ti810fb_release_resource(info, par);\n\t\treturn -ENOMEM;\n\t}\n\tinfo->pixmap.size = 8*1024;\n\tinfo->pixmap.buf_align = 8;\n\tinfo->pixmap.access_align = 32;\n\tinfo->pixmap.flags = FB_PIXMAP_SYSTEM;\n\n\tif ((err = i810_allocate_pci_resource(par, entry))) {\n\t\ti810fb_release_resource(info, par);\n\t\treturn err;\n\t}\n\n\ti810_init_defaults(par, info);\n\n\tif ((err = i810_alloc_agp_mem(info))) {\n\t\ti810fb_release_resource(info, par);\n\t\treturn err;\n\t}\n\n\ti810_init_device(par);\n\n\tinfo->screen_base = par->fb.virtual;\n\tinfo->fbops = &par->i810fb_ops;\n\tinfo->pseudo_palette = par->pseudo_palette;\n\tfb_alloc_cmap(&info->cmap, 256, 0);\n\ti810fb_find_init_mode(info);\n\n\tif ((err = info->fbops->fb_check_var(&info->var, info))) {\n\t\ti810fb_release_resource(info, par);\n\t\treturn err;\n\t}\n\n\tfb_var_to_videomode(&mode, &info->var);\n\tfb_add_videomode(&mode, &info->modelist);\n\n\ti810fb_init_ringbuffer(info);\n\terr = register_framebuffer(info);\n\n\tif (err < 0) {\n    \t\ti810fb_release_resource(info, par);\n\t\tprintk(\"i810fb_init: cannot register framebuffer device\\n\");\n    \t\treturn err;\n    \t}\n\n\tpci_set_drvdata(dev, info);\n\tpixclock = 1000000000/(info->var.pixclock);\n\tpixclock *= 1000;\n\thfreq = pixclock/(info->var.xres + info->var.left_margin +\n\t\t\t  info->var.hsync_len + info->var.right_margin);\n\tvfreq = hfreq/(info->var.yres + info->var.upper_margin +\n\t\t       info->var.vsync_len + info->var.lower_margin);\n\n      \tprintk(\"I810FB: fb%d         : %s v%d.%d.%d%s\\n\"\n      \t       \"I810FB: Video RAM   : %dK\\n\"\n\t       \"I810FB: Monitor     : H: %d-%d KHz V: %d-%d Hz\\n\"\n\t       \"I810FB: Mode        : %dx%d-%dbpp@%dHz\\n\",\n\t       info->node,\n\t       i810_pci_list[entry->driver_data],\n\t       VERSION_MAJOR, VERSION_MINOR, VERSION_TEENIE, BRANCH_VERSION,\n\t       (int) par->fb.size>>10, info->monspecs.hfmin/1000,\n\t       info->monspecs.hfmax/1000, info->monspecs.vfmin,\n\t       info->monspecs.vfmax, info->var.xres,\n\t       info->var.yres, info->var.bits_per_pixel, vfreq);\n\treturn 0;\n}\n\n \n\nstatic void i810fb_release_resource(struct fb_info *info,\n\t\t\t\t    struct i810fb_par *par)\n{\n\tstruct gtt_data *gtt = &par->i810_gtt;\n\tarch_phys_wc_del(par->wc_cookie);\n\n\ti810_delete_i2c_busses(par);\n\n\tif (par->i810_gtt.i810_cursor_memory)\n\t\tagp_free_memory(gtt->i810_cursor_memory);\n\tif (par->i810_gtt.i810_fb_memory)\n\t\tagp_free_memory(gtt->i810_fb_memory);\n\n\tif (par->mmio_start_virtual)\n\t\tiounmap(par->mmio_start_virtual);\n\tif (par->aperture.virtual)\n\t\tiounmap(par->aperture.virtual);\n\tkfree(par->edid);\n\tif (par->res_flags & FRAMEBUFFER_REQ)\n\t\trelease_mem_region(par->aperture.physical,\n\t\t\t\t   par->aperture.size);\n\tif (par->res_flags & MMIO_REQ)\n\t\trelease_mem_region(par->mmio_start_phys, MMIO_SIZE);\n\n\tframebuffer_release(info);\n\n}\n\nstatic void i810fb_remove_pci(struct pci_dev *dev)\n{\n\tstruct fb_info *info = pci_get_drvdata(dev);\n\tstruct i810fb_par *par = info->par;\n\n\tunregister_framebuffer(info);\n\ti810fb_release_resource(info, par);\n\tprintk(\"cleanup_module:  unloaded i810 framebuffer device\\n\");\n}\n\n#ifndef MODULE\nstatic int i810fb_init(void)\n{\n\tchar *option = NULL;\n\n\tif (fb_modesetting_disabled(\"i810fb\"))\n\t\treturn -ENODEV;\n\n\tif (fb_get_options(\"i810fb\", &option))\n\t\treturn -ENODEV;\n\ti810fb_setup(option);\n\n\treturn pci_register_driver(&i810fb_driver);\n}\n#endif\n\n \n\n#ifdef MODULE\n\nstatic int i810fb_init(void)\n{\n\tif (fb_modesetting_disabled(\"i810fb\"))\n\t\treturn -ENODEV;\n\n\thsync1 *= 1000;\n\thsync2 *= 1000;\n\n\treturn pci_register_driver(&i810fb_driver);\n}\n\nmodule_param(vram, int, 0);\nMODULE_PARM_DESC(vram, \"System RAM to allocate to framebuffer in MiB\"\n\t\t \" (default=4)\");\nmodule_param(voffset, int, 0);\nMODULE_PARM_DESC(voffset, \"at what offset to place start of framebuffer \"\n                 \"memory (0 to maximum aperture size), in MiB (default = 48)\");\nmodule_param(bpp, int, 0);\nMODULE_PARM_DESC(bpp, \"Color depth for display in bits per pixel\"\n\t\t \" (default = 8)\");\nmodule_param(xres, int, 0);\nMODULE_PARM_DESC(xres, \"Horizontal resolution in pixels (default = 640)\");\nmodule_param(yres, int, 0);\nMODULE_PARM_DESC(yres, \"Vertical resolution in scanlines (default = 480)\");\nmodule_param(vyres,int, 0);\nMODULE_PARM_DESC(vyres, \"Virtual vertical resolution in scanlines\"\n\t\t \" (default = 480)\");\nmodule_param(hsync1, int, 0);\nMODULE_PARM_DESC(hsync1, \"Minimum horizontal frequency of monitor in KHz\"\n\t\t \" (default = 29)\");\nmodule_param(hsync2, int, 0);\nMODULE_PARM_DESC(hsync2, \"Maximum horizontal frequency of monitor in KHz\"\n\t\t \" (default = 30)\");\nmodule_param(vsync1, int, 0);\nMODULE_PARM_DESC(vsync1, \"Minimum vertical frequency of monitor in Hz\"\n\t\t \" (default = 50)\");\nmodule_param(vsync2, int, 0);\nMODULE_PARM_DESC(vsync2, \"Maximum vertical frequency of monitor in Hz\"\n\t\t \" (default = 60)\");\nmodule_param(accel, bool, 0);\nMODULE_PARM_DESC(accel, \"Use Acceleration (BLIT) engine (default = 0)\");\nmodule_param(mtrr, bool, 0);\nMODULE_PARM_DESC(mtrr, \"Use MTRR (default = 0)\");\nmodule_param(extvga, bool, 0);\nMODULE_PARM_DESC(extvga, \"Enable external VGA connector (default = 0)\");\nmodule_param(sync, bool, 0);\nMODULE_PARM_DESC(sync, \"wait for accel engine to finish drawing\"\n\t\t \" (default = 0)\");\nmodule_param(dcolor, bool, 0);\nMODULE_PARM_DESC(dcolor, \"use DirectColor visuals\"\n\t\t \" (default = 0 = TrueColor)\");\nmodule_param(ddc3, bool, 0);\nMODULE_PARM_DESC(ddc3, \"Probe DDC bus 3 (default = 0 = no)\");\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Specify initial video mode\");\n\nMODULE_AUTHOR(\"Tony A. Daplas\");\nMODULE_DESCRIPTION(\"Framebuffer device for the Intel 810/815 and\"\n\t\t   \" compatible cards\");\nMODULE_LICENSE(\"GPL\");\n\nstatic void __exit i810fb_exit(void)\n{\n\tpci_unregister_driver(&i810fb_driver);\n}\nmodule_exit(i810fb_exit);\n\n#endif  \n\nmodule_init(i810fb_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}