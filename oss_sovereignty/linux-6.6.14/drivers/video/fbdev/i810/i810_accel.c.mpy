{
  "module_name": "i810_accel.c",
  "hash_id": "06acc36ea6a7966bdde02fe7f462a4aafc67569f11c8119aa5c4eef6aa9517c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/i810/i810_accel.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fb.h>\n\n#include \"i810_regs.h\"\n#include \"i810.h\"\n#include \"i810_main.h\"\n\nstatic u32 i810fb_rop[] = {\n\tCOLOR_COPY_ROP,  \n\tXOR_ROP          \n};\n\n \n#define PUT_RING(n) {                                        \\\n\ti810_writel(par->cur_tail, par->iring.virtual, n);   \\\n        par->cur_tail += 4;                                  \\\n        par->cur_tail &= RING_SIZE_MASK;                     \\\n}                                                                      \n\nextern void flush_cache(void);\n\n \n\n \nstatic inline void i810_report_error(u8 __iomem *mmio)\n{\n\tprintk(\"IIR     : 0x%04x\\n\"\n\t       \"EIR     : 0x%04x\\n\"\n\t       \"PGTBL_ER: 0x%04x\\n\"\n\t       \"IPEIR   : 0x%04x\\n\"\n\t       \"IPEHR   : 0x%04x\\n\",\n\t       i810_readw(IIR, mmio),\n\t       i810_readb(EIR, mmio),\n\t       i810_readl(PGTBL_ER, mmio),\n\t       i810_readl(IPEIR, mmio), \n\t       i810_readl(IPEHR, mmio));\n}\n\n \t\nstatic inline int wait_for_space(struct fb_info *info, u32 space)\n{\n\tstruct i810fb_par *par = info->par;\n\tu32 head, count = WAIT_COUNT, tail;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\ttail = par->cur_tail;\n\twhile (count--) {\n\t\thead = i810_readl(IRING + 4, mmio) & RBUFFER_HEAD_MASK;\t\n\t\tif ((tail == head) || \n\t\t    (tail > head && \n\t\t     (par->iring.size - tail + head) >= space) || \n\t\t    (tail < head && (head - tail) >= space)) {\n\t\t\treturn 0;\t\n\t\t}\n\t}\n\tprintk(\"ringbuffer lockup!!!\\n\");\n\ti810_report_error(mmio); \n\tpar->dev_flags |= LOCKUP;\n\tinfo->pixmap.scan_align = 1;\n\treturn 1;\n}\n\n \nstatic inline int wait_for_engine_idle(struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\tint count = WAIT_COUNT;\n\n\tif (wait_for_space(info, par->iring.size))  \n\t\treturn 1;\n\n\twhile((i810_readw(INSTDONE, mmio) & 0x7B) != 0x7B && --count); \n\tif (count) return 0;\n\n\tprintk(\"accel engine lockup!!!\\n\");\n\tprintk(\"INSTDONE: 0x%04x\\n\", i810_readl(INSTDONE, mmio));\n\ti810_report_error(mmio); \n\tpar->dev_flags |= LOCKUP;\n\tinfo->pixmap.scan_align = 1;\n\treturn 1;\n}\n\n  \nstatic inline u32 begin_iring(struct fb_info *info, u32 space)\n{\n\tstruct i810fb_par *par = info->par;\n\n\tif (par->dev_flags & ALWAYS_SYNC) \n\t\twait_for_engine_idle(info);\n\treturn wait_for_space(info, space);\n}\n\n \nstatic inline void end_iring(struct i810fb_par *par)\n{\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\ti810_writel(IRING, mmio, par->cur_tail);\n}\n\n \nstatic inline void source_copy_blit(int dwidth, int dheight, int dpitch, \n\t\t\t\t    int xdir, int src, int dest, int rop, \n\t\t\t\t    int blit_bpp, struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\n\tif (begin_iring(info, 24 + IRING_PAD)) return;\n\n\tPUT_RING(BLIT | SOURCE_COPY_BLIT | 4);\n\tPUT_RING(xdir | rop << 16 | dpitch | DYN_COLOR_EN | blit_bpp);\n\tPUT_RING(dheight << 16 | dwidth);\n\tPUT_RING(dest);\n\tPUT_RING(dpitch);\n\tPUT_RING(src);\n\n\tend_iring(par);\n}\t\n\n \nstatic inline void color_blit(int width, int height, int pitch,  int dest, \n\t\t\t      int rop, int what, int blit_bpp, \n\t\t\t      struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\n\tif (begin_iring(info, 24 + IRING_PAD)) return;\n\n\tPUT_RING(BLIT | COLOR_BLT | 3);\n\tPUT_RING(rop << 16 | pitch | SOLIDPATTERN | DYN_COLOR_EN | blit_bpp);\n\tPUT_RING(height << 16 | width);\n\tPUT_RING(dest);\n\tPUT_RING(what);\n\tPUT_RING(NOP);\n\n\tend_iring(par);\n}\n \n \nstatic inline void mono_src_copy_imm_blit(int dwidth, int dheight, int dpitch,\n\t\t\t\t\t  int dsize, int blit_bpp, int rop,\n\t\t\t\t\t  int dest, const u32 *src, int bg,\n\t\t\t\t\t  int fg, struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\n\tif (begin_iring(info, 24 + (dsize << 2) + IRING_PAD)) return;\n\n\tPUT_RING(BLIT | MONO_SOURCE_COPY_IMMEDIATE | (4 + dsize));\n\tPUT_RING(DYN_COLOR_EN | blit_bpp | rop << 16 | dpitch);\n\tPUT_RING(dheight << 16 | dwidth);\n\tPUT_RING(dest);\n\tPUT_RING(bg);\n\tPUT_RING(fg);\n\twhile (dsize--) \n\t\tPUT_RING(*src++);\n\n\tend_iring(par);\n}\n\nstatic inline void load_front(int offset, struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\n\tif (begin_iring(info, 8 + IRING_PAD)) return;\n\n\tPUT_RING(PARSER | FLUSH);\n\tPUT_RING(NOP);\n\n\tend_iring(par);\n\n\tif (begin_iring(info, 8 + IRING_PAD)) return;\n\n\tPUT_RING(PARSER | FRONT_BUFFER | ((par->pitch >> 3) << 8));\n\tPUT_RING((par->fb.offset << 12) + offset);\n\n\tend_iring(par);\n}\n\n \nstatic inline void i810fb_iring_enable(struct i810fb_par *par, u32 mode)\n{\n\tu32 tmp;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\ttmp = i810_readl(IRING + 12, mmio);\n\tif (mode == OFF) \n\t\ttmp &= ~1;\n\telse \n\t\ttmp |= 1;\n\tflush_cache();\n\ti810_writel(IRING + 12, mmio, tmp);\n}       \n\nvoid i810fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct i810fb_par *par = info->par;\n\tu32 dx, dy, width, height, dest, rop = 0, color = 0;\n\n\tif (!info->var.accel_flags || par->dev_flags & LOCKUP ||\n\t    par->depth == 4) {\n\t\tcfb_fillrect(info, rect);\n\t\treturn;\n\t}\n\n\tif (par->depth == 1) \n\t\tcolor = rect->color;\n\telse \n\t\tcolor = ((u32 *) (info->pseudo_palette))[rect->color];\n\n\trop = i810fb_rop[rect->rop];\n\n\tdx = rect->dx * par->depth;\n\twidth = rect->width * par->depth;\n\tdy = rect->dy;\n\theight = rect->height;\n\n\tdest = info->fix.smem_start + (dy * info->fix.line_length) + dx;\n\tcolor_blit(width, height, info->fix.line_length, dest, rop, color, \n\t\t   par->blit_bpp, info);\n}\n\t\nvoid i810fb_copyarea(struct fb_info *info, const struct fb_copyarea *region) \n{\n\tstruct i810fb_par *par = info->par;\n\tu32 sx, sy, dx, dy, pitch, width, height, src, dest, xdir;\n\n\tif (!info->var.accel_flags || par->dev_flags & LOCKUP ||\n\t    par->depth == 4) {\n\t\tcfb_copyarea(info, region);\n\t\treturn;\n\t}\n\n\tdx = region->dx * par->depth;\n\tsx = region->sx * par->depth;\n\twidth = region->width * par->depth;\n\tsy = region->sy;\n\tdy = region->dy;\n\theight = region->height;\n\n\tif (dx <= sx) {\n\t\txdir = INCREMENT;\n\t}\n\telse {\n\t\txdir = DECREMENT;\n\t\tsx += width - 1;\n\t\tdx += width - 1;\n\t}\n\tif (dy <= sy) {\n\t\tpitch = info->fix.line_length;\n\t}\n\telse {\n\t\tpitch = (-(info->fix.line_length)) & 0xFFFF;\n\t\tsy += height - 1;\n\t\tdy += height - 1;\n\t}\n\tsrc = info->fix.smem_start + (sy * info->fix.line_length) + sx;\n\tdest = info->fix.smem_start + (dy * info->fix.line_length) + dx;\n\n\tsource_copy_blit(width, height, pitch, xdir, src, dest,\n\t\t\t PAT_COPY_ROP, par->blit_bpp, info);\n}\n\nvoid i810fb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct i810fb_par *par = info->par;\n\tu32 fg = 0, bg = 0, size, dst;\n\t\n\tif (!info->var.accel_flags || par->dev_flags & LOCKUP ||\n\t    par->depth == 4 || image->depth != 1) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tfg = image->fg_color;\n\t\tbg = image->bg_color;\n\t\tbreak;\n\tcase 16:\n\tcase 24:\n\t\tfg = ((u32 *)(info->pseudo_palette))[image->fg_color];\n\t\tbg = ((u32 *)(info->pseudo_palette))[image->bg_color];\n\t\tbreak;\n\t}\t\n\t\n\tdst = info->fix.smem_start + (image->dy * info->fix.line_length) + \n\t\t(image->dx * par->depth);\n\n\tsize = (image->width+7)/8 + 1;\n\tsize &= ~1;\n\tsize *= image->height;\n\tsize += 7;\n\tsize &= ~7;\n\tmono_src_copy_imm_blit(image->width * par->depth, \n\t\t\t       image->height, info->fix.line_length, \n\t\t\t       size/4, par->blit_bpp,\n\t\t\t       PAT_COPY_ROP, dst, (u32 *) image->data, \n\t\t\t       bg, fg, info);\n} \n\nint i810fb_sync(struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\t\n\tif (!info->var.accel_flags || par->dev_flags & LOCKUP)\n\t\treturn 0;\n\n\treturn wait_for_engine_idle(info);\n}\n\nvoid i810fb_load_front(u32 offset, struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\n\tif (!info->var.accel_flags || par->dev_flags & LOCKUP)\n\t\ti810_writel(DPLYBASE, mmio, par->fb.physical + offset);\n\telse \n\t\tload_front(offset, info);\n}\n\n \nvoid i810fb_init_ringbuffer(struct fb_info *info)\n{\n\tstruct i810fb_par *par = info->par;\n\tu32 tmp1, tmp2;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\t\n\twait_for_engine_idle(info);\n\ti810fb_iring_enable(par, OFF);\n\ti810_writel(IRING, mmio, 0);\n\ti810_writel(IRING + 4, mmio, 0);\n\tpar->cur_tail = 0;\n\n\ttmp2 = i810_readl(IRING + 8, mmio) & ~RBUFFER_START_MASK; \n\ttmp1 = par->iring.physical;\n\ti810_writel(IRING + 8, mmio, tmp2 | tmp1);\n\n\ttmp1 = i810_readl(IRING + 12, mmio);\n\ttmp1 &= ~RBUFFER_SIZE_MASK;\n\ttmp2 = (par->iring.size - I810_PAGESIZE) & RBUFFER_SIZE_MASK;\n\ti810_writel(IRING + 12, mmio, tmp1 | tmp2);\n\ti810fb_iring_enable(par, ON);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}