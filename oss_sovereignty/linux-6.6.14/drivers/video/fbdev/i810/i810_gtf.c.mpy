{
  "module_name": "i810_gtf.c",
  "hash_id": "f7b4e24e50e198ff17fe483a9e4238aedc48ea7be66559666c3b188a39fb955b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/i810/i810_gtf.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n\n#include \"i810_regs.h\"\n#include \"i810.h\"\n#include \"i810_main.h\"\n\n \n\nstruct wm_info {\n   u32 freq;\n   u32  wm;\n};\n\nstatic struct wm_info i810_wm_8_100[] = {\n\t{ 15, 0x0070c000 },  { 19, 0x0070c000 },  { 25, 0x22003000 },\n\t{ 28, 0x22003000 },  { 31, 0x22003000 },  { 36, 0x22007000 },\n\t{ 40, 0x22007000 },  { 45, 0x22007000 },  { 49, 0x22008000 },\n\t{ 50, 0x22008000 },  { 56, 0x22008000 },  { 65, 0x22008000 },\n\t{ 75, 0x22008000 },  { 78, 0x22008000 },  { 80, 0x22008000 },\n\t{ 94, 0x22008000 },  { 96, 0x22107000 },  { 99, 0x22107000 },\n\t{ 108, 0x22107000 }, { 121, 0x22107000 }, { 128, 0x22107000 },\n\t{ 132, 0x22109000 }, { 135, 0x22109000 }, { 157, 0x2210b000 },\n\t{ 162, 0x2210b000 }, { 175, 0x2210b000 }, { 189, 0x2220e000 },\n\t{ 195, 0x2220e000 }, { 202, 0x2220e000 }, { 204, 0x2220e000 },\n\t{ 218, 0x2220f000 }, { 229, 0x22210000 }, { 234, 0x22210000 }, \n};\n\nstatic struct wm_info i810_wm_16_100[] = {\n\t{ 15, 0x0070c000 },  { 19, 0x0020c000 },  { 25, 0x22006000 },\n\t{ 28, 0x22006000 },  { 31, 0x22007000 },  { 36, 0x22007000 },\n\t{ 40, 0x22007000 },  { 45, 0x22007000 },  { 49, 0x22009000 },\n\t{ 50, 0x22009000 },  { 56, 0x22108000 },  { 65, 0x2210e000 },\n\t{ 75, 0x2210e000 },  { 78, 0x2210e000 },  { 80, 0x22210000 },\n\t{ 94, 0x22210000 },  { 96, 0x22210000 },  { 99, 0x22210000 },\n\t{ 108, 0x22210000 }, { 121, 0x22210000 }, { 128, 0x22210000 },\n\t{ 132, 0x22314000 }, { 135, 0x22314000 }, { 157, 0x22415000 },\n\t{ 162, 0x22416000 }, { 175, 0x22416000 }, { 189, 0x22416000 },\n\t{ 195, 0x22416000 }, { 202, 0x22416000 }, { 204, 0x22416000 },\n\t{ 218, 0x22416000 }, { 229, 0x22416000 },\n};\n\nstatic struct wm_info i810_wm_24_100[] = {\n\t{ 15, 0x0020c000 },  { 19, 0x0040c000 },  { 25, 0x22009000 },\n\t{ 28, 0x22009000 },  { 31, 0x2200a000 },  { 36, 0x2210c000 },\n\t{ 40, 0x2210c000 },  { 45, 0x2210c000 },  { 49, 0x22111000 },\n\t{ 50, 0x22111000 },  { 56, 0x22111000 },  { 65, 0x22214000 },\n\t{ 75, 0x22214000 },  { 78, 0x22215000 },  { 80, 0x22216000 },\n\t{ 94, 0x22218000 },  { 96, 0x22418000 },  { 99, 0x22418000 },\n\t{ 108, 0x22418000 }, { 121, 0x22418000 }, { 128, 0x22419000 },\n\t{ 132, 0x22519000 }, { 135, 0x4441d000 }, { 157, 0x44419000 },\n\t{ 162, 0x44419000 }, { 175, 0x44419000 }, { 189, 0x44419000 },\n\t{ 195, 0x44419000 }, { 202, 0x44419000 }, { 204, 0x44419000 },\n};\n\nstatic struct wm_info i810_wm_8_133[] = {\n\t{ 15, 0x0070c000 },  { 19, 0x0070c000 },  { 25, 0x22003000 },\n\t{ 28, 0x22003000 },  { 31, 0x22003000 },  { 36, 0x22007000 },\n\t{ 40, 0x22007000 },  { 45, 0x22007000 },  { 49, 0x22008000 },\n\t{ 50, 0x22008000 },  { 56, 0x22008000 },  { 65, 0x22008000 },\n\t{ 75, 0x22008000 },  { 78, 0x22008000 },  { 80, 0x22008000 },\n\t{ 94, 0x22008000 },  { 96, 0x22107000 },  { 99, 0x22107000 },\n\t{ 108, 0x22107000 }, { 121, 0x22107000 }, { 128, 0x22107000 },\n\t{ 132, 0x22109000 }, { 135, 0x22109000 }, { 157, 0x2210b000 },\n\t{ 162, 0x2210b000 }, { 175, 0x2210b000 }, { 189, 0x2220e000 },\n\t{ 195, 0x2220e000 }, { 202, 0x2220e000 }, { 204, 0x2220e000 },\n\t{ 218, 0x2220f000 }, { 229, 0x22210000 }, { 234, 0x22210000 }, \n};\n\nstatic struct wm_info i810_wm_16_133[] = {\n\t{ 15, 0x0020c000 },  { 19, 0x0020c000 },  { 25, 0x22006000 },\n\t{ 28, 0x22006000 },  { 31, 0x22007000 },  { 36, 0x22007000 },\n\t{ 40, 0x22007000 },  { 45, 0x22007000 },  { 49, 0x22009000 },\n\t{ 50, 0x22009000 },  { 56, 0x22108000 },  { 65, 0x2210e000 },\n\t{ 75, 0x2210e000 },  { 78, 0x2210e000 },  { 80, 0x22210000 },\n\t{ 94, 0x22210000 },  { 96, 0x22210000 },  { 99, 0x22210000 },\n\t{ 108, 0x22210000 }, { 121, 0x22210000 }, { 128, 0x22210000 },\n\t{ 132, 0x22314000 }, { 135, 0x22314000 }, { 157, 0x22415000 },\n\t{ 162, 0x22416000 }, { 175, 0x22416000 }, { 189, 0x22416000 },\n\t{ 195, 0x22416000 }, { 202, 0x22416000 }, { 204, 0x22416000 },\n\t{ 218, 0x22416000 }, { 229, 0x22416000 },\n};\n\nstatic struct wm_info i810_wm_24_133[] = {\n\t{ 15, 0x0020c000 },  { 19, 0x00408000 },  { 25, 0x22009000 },\n\t{ 28, 0x22009000 },  { 31, 0x2200a000 },  { 36, 0x2210c000 },\n\t{ 40, 0x2210c000 },  { 45, 0x2210c000 },  { 49, 0x22111000 },\n\t{ 50, 0x22111000 },  { 56, 0x22111000 },  { 65, 0x22214000 },\n\t{ 75, 0x22214000 },  { 78, 0x22215000 },  { 80, 0x22216000 },\n\t{ 94, 0x22218000 },  { 96, 0x22418000 },  { 99, 0x22418000 },\n\t{ 108, 0x22418000 }, { 121, 0x22418000 }, { 128, 0x22419000 },\n\t{ 132, 0x22519000 }, { 135, 0x4441d000 }, { 157, 0x44419000 },\n\t{ 162, 0x44419000 }, { 175, 0x44419000 }, { 189, 0x44419000 },\n\t{ 195, 0x44419000 }, { 202, 0x44419000 }, { 204, 0x44419000 },\n};\n\nvoid round_off_xres(u32 *xres) { }\nvoid round_off_yres(u32 *xres, u32 *yres) { }\n\n \nvoid i810fb_encode_registers(const struct fb_var_screeninfo *var,\n\t\t\t     struct i810fb_par *par, u32 xres, u32 yres)\n{\n\tint n, blank_s, blank_e;\n\tu8 __iomem *mmio = par->mmio_start_virtual;\n\tu8 msr = 0;\n\n\t \n\t \n\tn = ((xres + var->right_margin + var->hsync_len + \n\t      var->left_margin) >> 3) - 5;\n\tpar->regs.cr00 =  (u8) n;\n\tpar->regs.cr35 = (u8) ((n >> 8) & 1);\n\t\n\t \n\tpar->regs.cr01 = (u8) ((xres >> 3) - 1);\n\n\t \n\tblank_e = (xres + var->right_margin + var->hsync_len + \n\t\t   var->left_margin) >> 3;\n\tblank_e--;\n\tblank_s = blank_e - 127;\n\tif (blank_s < (xres >> 3))\n\t\tblank_s = xres >> 3;\n\tpar->regs.cr02 = (u8) blank_s;\n\tpar->regs.cr03 = (u8) (blank_e & 0x1F);\n\tpar->regs.cr05 = (u8) ((blank_e & (1 << 5)) << 2);\n\tpar->regs.cr39 = (u8) ((blank_e >> 6) & 1);\n\n\t \n\tpar->regs.cr04 = (u8) ((xres + var->right_margin) >> 3);\n\tpar->regs.cr05 |= (u8) (((xres + var->right_margin + \n\t\t\t\t  var->hsync_len) >> 3) & 0x1F);\n\t\n       \t \n\t \n\tn = yres + var->lower_margin + var->vsync_len + var->upper_margin - 2;\n\tpar->regs.cr06 = (u8) (n & 0xFF);\n\tpar->regs.cr30 = (u8) ((n >> 8) & 0x0F);\n\n\t  \n\tn = yres + var->lower_margin;\n\tpar->regs.cr10 = (u8) (n & 0xFF);\n\tpar->regs.cr32 = (u8) ((n >> 8) & 0x0F);\n\tpar->regs.cr11 = i810_readb(CR11, mmio) & ~0x0F;\n\tpar->regs.cr11 |= (u8) ((yres + var->lower_margin + \n\t\t\t\t var->vsync_len) & 0x0F);\n\n\t \n\tn = yres - 1;\n\tpar->regs.cr12 = (u8) (n & 0xFF);\n\tpar->regs.cr31 = (u8) ((n >> 8) & 0x0F);\n\t\n\t \n\tblank_e = yres + var->lower_margin + var->vsync_len + \n\t\tvar->upper_margin;\n\tblank_e--;\n\tblank_s = blank_e - 127;\n\tif (blank_s < yres)\n\t\tblank_s = yres;\n\tpar->regs.cr15 = (u8) (blank_s & 0xFF);\n\tpar->regs.cr33 = (u8) ((blank_s >> 8) & 0x0F);\n\tpar->regs.cr16 = (u8) (blank_e & 0xFF);\n\tpar->regs.cr09 = 0;\t\n\n\t \n\tif (!(var->sync & FB_SYNC_HOR_HIGH_ACT))\n\t\tmsr |= 1 << 6;\n\tif (!(var->sync & FB_SYNC_VERT_HIGH_ACT))\n\t\tmsr |= 1 << 7;\n\tpar->regs.msr = msr;\n\n\t \n\tif (var->vmode & FB_VMODE_INTERLACED) \n\t\tpar->interlace = (1 << 7) | ((u8) (var->yres >> 4));\n\telse \n\t\tpar->interlace = 0;\n\n\tif (var->vmode & FB_VMODE_DOUBLE)\n\t\tpar->regs.cr09 |= 1 << 7;\n\n\t \n\tpar->ovract = ((var->xres + var->right_margin + var->hsync_len + \n\t\t\tvar->left_margin - 32) | ((var->xres - 32) << 16));\n}\t\n\nvoid i810fb_fill_var_timings(struct fb_var_screeninfo *var) { }\n\n \nu32 i810_get_watermark(const struct fb_var_screeninfo *var,\n\t\t       struct i810fb_par *par)\n{\n\tstruct wm_info *wmark = NULL;\n\tu32 i, size = 0, pixclock, wm_best = 0, min, diff;\n\n\tif (par->mem_freq == 100) {\n\t\tswitch (var->bits_per_pixel) { \n\t\tcase 8:\n\t\t\twmark = i810_wm_8_100;\n\t\t\tsize = ARRAY_SIZE(i810_wm_8_100);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\twmark = i810_wm_16_100;\n\t\t\tsize = ARRAY_SIZE(i810_wm_16_100);\n\t\t\tbreak;\n\t\tcase 24:\n\t\tcase 32:\n\t\t\twmark = i810_wm_24_100;\n\t\t\tsize = ARRAY_SIZE(i810_wm_24_100);\n\t\t}\n\t} else {\n\t\tswitch(var->bits_per_pixel) {\n\t\tcase 8:\n\t\t\twmark = i810_wm_8_133;\n\t\t\tsize = ARRAY_SIZE(i810_wm_8_133);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\twmark = i810_wm_16_133;\n\t\t\tsize = ARRAY_SIZE(i810_wm_16_133);\n\t\t\tbreak;\n\t\tcase 24:\n\t\tcase 32:\n\t\t\twmark = i810_wm_24_133;\n\t\t\tsize = ARRAY_SIZE(i810_wm_24_133);\n\t\t}\n\t}\n\n\tpixclock = 1000000/var->pixclock;\n\tmin = ~0;\n\tfor (i = 0; i < size; i++) {\n\t\tif (pixclock <= wmark[i].freq) \n\t\t\tdiff = wmark[i].freq - pixclock;\n\t\telse \n\t\t\tdiff = pixclock - wmark[i].freq;\n\t\tif (diff < min) {\n\t\t\twm_best = wmark[i].wm;\n\t\t\tmin = diff;\n\t\t}\n\t}\n\treturn wm_best;\t\t\n}\t\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}