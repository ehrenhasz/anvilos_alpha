{
  "module_name": "hyperv_fb.c",
  "hash_id": "3272db1e7b88cc0bda8b7804b79dd24cfc53199cb5b74acc09d736521e4f0537",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/hyperv_fb.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/screen_info.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/completion.h>\n#include <linux/fb.h>\n#include <linux/pci.h>\n#include <linux/panic_notifier.h>\n#include <linux/efi.h>\n#include <linux/console.h>\n\n#include <linux/hyperv.h>\n\n \n#define MAX_VMBUS_PKT_SIZE 0x4000\n\n#define SYNTHVID_VERSION(major, minor) ((minor) << 16 | (major))\n \n#define SYNTHVID_VERSION_WIN7 SYNTHVID_VERSION(3, 0)\n#define SYNTHVID_VERSION_WIN8 SYNTHVID_VERSION(3, 2)\n#define SYNTHVID_VERSION_WIN10 SYNTHVID_VERSION(3, 5)\n\n#define SYNTHVID_VER_GET_MAJOR(ver) (ver & 0x0000ffff)\n#define SYNTHVID_VER_GET_MINOR(ver) ((ver & 0xffff0000) >> 16)\n\n#define SYNTHVID_DEPTH_WIN8 32\n#define SYNTHVID_FB_SIZE_WIN8 (8 * 1024 * 1024)\n\nenum pipe_msg_type {\n\tPIPE_MSG_INVALID,\n\tPIPE_MSG_DATA,\n\tPIPE_MSG_MAX\n};\n\nstruct pipe_msg_hdr {\n\tu32 type;\n\tu32 size;  \n} __packed;\n\n\nenum synthvid_msg_type {\n\tSYNTHVID_ERROR\t\t\t= 0,\n\tSYNTHVID_VERSION_REQUEST\t= 1,\n\tSYNTHVID_VERSION_RESPONSE\t= 2,\n\tSYNTHVID_VRAM_LOCATION\t\t= 3,\n\tSYNTHVID_VRAM_LOCATION_ACK\t= 4,\n\tSYNTHVID_SITUATION_UPDATE\t= 5,\n\tSYNTHVID_SITUATION_UPDATE_ACK\t= 6,\n\tSYNTHVID_POINTER_POSITION\t= 7,\n\tSYNTHVID_POINTER_SHAPE\t\t= 8,\n\tSYNTHVID_FEATURE_CHANGE\t\t= 9,\n\tSYNTHVID_DIRT\t\t\t= 10,\n\tSYNTHVID_RESOLUTION_REQUEST\t= 13,\n\tSYNTHVID_RESOLUTION_RESPONSE\t= 14,\n\n\tSYNTHVID_MAX\t\t\t= 15\n};\n\n#define\t\tSYNTHVID_EDID_BLOCK_SIZE\t128\n#define\t\tSYNTHVID_MAX_RESOLUTION_COUNT\t64\n\nstruct hvd_screen_info {\n\tu16 width;\n\tu16 height;\n} __packed;\n\nstruct synthvid_msg_hdr {\n\tu32 type;\n\tu32 size;   \n} __packed;\n\nstruct synthvid_version_req {\n\tu32 version;\n} __packed;\n\nstruct synthvid_version_resp {\n\tu32 version;\n\tu8 is_accepted;\n\tu8 max_video_outputs;\n} __packed;\n\nstruct synthvid_supported_resolution_req {\n\tu8 maximum_resolution_count;\n} __packed;\n\nstruct synthvid_supported_resolution_resp {\n\tu8 edid_block[SYNTHVID_EDID_BLOCK_SIZE];\n\tu8 resolution_count;\n\tu8 default_resolution_index;\n\tu8 is_standard;\n\tstruct hvd_screen_info\n\t\tsupported_resolution[SYNTHVID_MAX_RESOLUTION_COUNT];\n} __packed;\n\nstruct synthvid_vram_location {\n\tu64 user_ctx;\n\tu8 is_vram_gpa_specified;\n\tu64 vram_gpa;\n} __packed;\n\nstruct synthvid_vram_location_ack {\n\tu64 user_ctx;\n} __packed;\n\nstruct video_output_situation {\n\tu8 active;\n\tu32 vram_offset;\n\tu8 depth_bits;\n\tu32 width_pixels;\n\tu32 height_pixels;\n\tu32 pitch_bytes;\n} __packed;\n\nstruct synthvid_situation_update {\n\tu64 user_ctx;\n\tu8 video_output_count;\n\tstruct video_output_situation video_output[1];\n} __packed;\n\nstruct synthvid_situation_update_ack {\n\tu64 user_ctx;\n} __packed;\n\nstruct synthvid_pointer_position {\n\tu8 is_visible;\n\tu8 video_output;\n\ts32 image_x;\n\ts32 image_y;\n} __packed;\n\n\n#define CURSOR_MAX_X 96\n#define CURSOR_MAX_Y 96\n#define CURSOR_ARGB_PIXEL_SIZE 4\n#define CURSOR_MAX_SIZE (CURSOR_MAX_X * CURSOR_MAX_Y * CURSOR_ARGB_PIXEL_SIZE)\n#define CURSOR_COMPLETE (-1)\n\nstruct synthvid_pointer_shape {\n\tu8 part_idx;\n\tu8 is_argb;\n\tu32 width;  \n\tu32 height;  \n\tu32 hot_x;  \n\tu32 hot_y;\n\tu8 data[4];\n} __packed;\n\nstruct synthvid_feature_change {\n\tu8 is_dirt_needed;\n\tu8 is_ptr_pos_needed;\n\tu8 is_ptr_shape_needed;\n\tu8 is_situ_needed;\n} __packed;\n\nstruct rect {\n\ts32 x1, y1;  \n\ts32 x2, y2;  \n} __packed;\n\nstruct synthvid_dirt {\n\tu8 video_output;\n\tu8 dirt_count;\n\tstruct rect rect[1];\n} __packed;\n\nstruct synthvid_msg {\n\tstruct pipe_msg_hdr pipe_hdr;\n\tstruct synthvid_msg_hdr vid_hdr;\n\tunion {\n\t\tstruct synthvid_version_req ver_req;\n\t\tstruct synthvid_version_resp ver_resp;\n\t\tstruct synthvid_vram_location vram;\n\t\tstruct synthvid_vram_location_ack vram_ack;\n\t\tstruct synthvid_situation_update situ;\n\t\tstruct synthvid_situation_update_ack situ_ack;\n\t\tstruct synthvid_pointer_position ptr_pos;\n\t\tstruct synthvid_pointer_shape ptr_shape;\n\t\tstruct synthvid_feature_change feature_chg;\n\t\tstruct synthvid_dirt dirt;\n\t\tstruct synthvid_supported_resolution_req resolution_req;\n\t\tstruct synthvid_supported_resolution_resp resolution_resp;\n\t};\n} __packed;\n\n\n \n#define HVFB_WIDTH 1152  \n#define HVFB_HEIGHT 864  \n#define HVFB_WIDTH_MIN 640\n#define HVFB_HEIGHT_MIN 480\n\n#define RING_BUFSIZE (256 * 1024)\n#define VSP_TIMEOUT (10 * HZ)\n#define HVFB_UPDATE_DELAY (HZ / 20)\n#define HVFB_ONDEMAND_THROTTLE (HZ / 20)\n\nstruct hvfb_par {\n\tstruct fb_info *info;\n\tstruct resource *mem;\n\tbool fb_ready;  \n\tstruct completion wait;\n\tu32 synthvid_version;\n\n\tstruct delayed_work dwork;\n\tbool update;\n\tbool update_saved;  \n\n\tu32 pseudo_palette[16];\n\tu8 init_buf[MAX_VMBUS_PKT_SIZE];\n\tu8 recv_buf[MAX_VMBUS_PKT_SIZE];\n\n\t \n\tbool synchronous_fb;\n\n\t \n\tbool need_docopy;\n\n\tstruct notifier_block hvfb_panic_nb;\n\n\t \n\tunsigned char *dio_vp;\n\tunsigned char *mmio_vp;\n\tphys_addr_t mmio_pp;\n\n\t \n\tint x1, y1, x2, y2;\n\tbool delayed_refresh;\n\tspinlock_t delayed_refresh_lock;\n};\n\nstatic uint screen_width = HVFB_WIDTH;\nstatic uint screen_height = HVFB_HEIGHT;\nstatic uint screen_depth;\nstatic uint screen_fb_size;\nstatic uint dio_fb_size;  \n\n \nstatic inline int synthvid_send(struct hv_device *hdev,\n\t\t\t\tstruct synthvid_msg *msg)\n{\n\tstatic atomic64_t request_id = ATOMIC64_INIT(0);\n\tint ret;\n\n\tmsg->pipe_hdr.type = PIPE_MSG_DATA;\n\tmsg->pipe_hdr.size = msg->vid_hdr.size;\n\n\tret = vmbus_sendpacket(hdev->channel, msg,\n\t\t\t       msg->vid_hdr.size + sizeof(struct pipe_msg_hdr),\n\t\t\t       atomic64_inc_return(&request_id),\n\t\t\t       VM_PKT_DATA_INBAND, 0);\n\n\tif (ret)\n\t\tpr_err_ratelimited(\"Unable to send packet via vmbus; error %d\\n\", ret);\n\n\treturn ret;\n}\n\n\n \nstatic int synthvid_send_situ(struct hv_device *hdev)\n{\n\tstruct fb_info *info = hv_get_drvdata(hdev);\n\tstruct synthvid_msg msg;\n\n\tif (!info)\n\t\treturn -ENODEV;\n\n\tmemset(&msg, 0, sizeof(struct synthvid_msg));\n\n\tmsg.vid_hdr.type = SYNTHVID_SITUATION_UPDATE;\n\tmsg.vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_situation_update);\n\tmsg.situ.user_ctx = 0;\n\tmsg.situ.video_output_count = 1;\n\tmsg.situ.video_output[0].active = 1;\n\tmsg.situ.video_output[0].vram_offset = 0;\n\tmsg.situ.video_output[0].depth_bits = info->var.bits_per_pixel;\n\tmsg.situ.video_output[0].width_pixels = info->var.xres;\n\tmsg.situ.video_output[0].height_pixels = info->var.yres;\n\tmsg.situ.video_output[0].pitch_bytes = info->fix.line_length;\n\n\tsynthvid_send(hdev, &msg);\n\n\treturn 0;\n}\n\n \nstatic int synthvid_send_ptr(struct hv_device *hdev)\n{\n\tstruct synthvid_msg msg;\n\n\tmemset(&msg, 0, sizeof(struct synthvid_msg));\n\tmsg.vid_hdr.type = SYNTHVID_POINTER_POSITION;\n\tmsg.vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_pointer_position);\n\tmsg.ptr_pos.is_visible = 1;\n\tmsg.ptr_pos.video_output = 0;\n\tmsg.ptr_pos.image_x = 0;\n\tmsg.ptr_pos.image_y = 0;\n\tsynthvid_send(hdev, &msg);\n\n\tmemset(&msg, 0, sizeof(struct synthvid_msg));\n\tmsg.vid_hdr.type = SYNTHVID_POINTER_SHAPE;\n\tmsg.vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_pointer_shape);\n\tmsg.ptr_shape.part_idx = CURSOR_COMPLETE;\n\tmsg.ptr_shape.is_argb = 1;\n\tmsg.ptr_shape.width = 1;\n\tmsg.ptr_shape.height = 1;\n\tmsg.ptr_shape.hot_x = 0;\n\tmsg.ptr_shape.hot_y = 0;\n\tmsg.ptr_shape.data[0] = 0;\n\tmsg.ptr_shape.data[1] = 1;\n\tmsg.ptr_shape.data[2] = 1;\n\tmsg.ptr_shape.data[3] = 1;\n\tsynthvid_send(hdev, &msg);\n\n\treturn 0;\n}\n\n \nstatic int\nsynthvid_update(struct fb_info *info, int x1, int y1, int x2, int y2)\n{\n\tstruct hv_device *hdev = device_to_hv_device(info->device);\n\tstruct synthvid_msg msg;\n\n\tmemset(&msg, 0, sizeof(struct synthvid_msg));\n\tif (x2 == INT_MAX)\n\t\tx2 = info->var.xres;\n\tif (y2 == INT_MAX)\n\t\ty2 = info->var.yres;\n\n\tmsg.vid_hdr.type = SYNTHVID_DIRT;\n\tmsg.vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_dirt);\n\tmsg.dirt.video_output = 0;\n\tmsg.dirt.dirt_count = 1;\n\tmsg.dirt.rect[0].x1 = (x1 > x2) ? 0 : x1;\n\tmsg.dirt.rect[0].y1 = (y1 > y2) ? 0 : y1;\n\tmsg.dirt.rect[0].x2 =\n\t\t(x2 < x1 || x2 > info->var.xres) ? info->var.xres : x2;\n\tmsg.dirt.rect[0].y2 =\n\t\t(y2 < y1 || y2 > info->var.yres) ? info->var.yres : y2;\n\n\tsynthvid_send(hdev, &msg);\n\n\treturn 0;\n}\n\nstatic void hvfb_docopy(struct hvfb_par *par,\n\t\t\tunsigned long offset,\n\t\t\tunsigned long size)\n{\n\tif (!par || !par->mmio_vp || !par->dio_vp || !par->fb_ready ||\n\t    size == 0 || offset >= dio_fb_size)\n\t\treturn;\n\n\tif (offset + size > dio_fb_size)\n\t\tsize = dio_fb_size - offset;\n\n\tmemcpy(par->mmio_vp + offset, par->dio_vp + offset, size);\n}\n\n \nstatic void synthvid_deferred_io(struct fb_info *p, struct list_head *pagereflist)\n{\n\tstruct hvfb_par *par = p->par;\n\tstruct fb_deferred_io_pageref *pageref;\n\tunsigned long start, end;\n\tint y1, y2, miny, maxy;\n\n\tminy = INT_MAX;\n\tmaxy = 0;\n\n\t \n\tlist_for_each_entry(pageref, pagereflist, list) {\n\t\tstart = pageref->offset;\n\t\tend = start + PAGE_SIZE - 1;\n\t\ty1 = start / p->fix.line_length;\n\t\ty2 = end / p->fix.line_length;\n\t\tminy = min_t(int, miny, y1);\n\t\tmaxy = max_t(int, maxy, y2);\n\n\t\t \n\t\tif (par->fb_ready && par->need_docopy)\n\t\t\thvfb_docopy(par, start, PAGE_SIZE);\n\t}\n\n\tif (par->fb_ready && par->update)\n\t\tsynthvid_update(p, 0, miny, p->var.xres, maxy + 1);\n}\n\nstatic struct fb_deferred_io synthvid_defio = {\n\t.delay\t\t= HZ / 20,\n\t.deferred_io\t= synthvid_deferred_io,\n};\n\n \nstatic void synthvid_recv_sub(struct hv_device *hdev)\n{\n\tstruct fb_info *info = hv_get_drvdata(hdev);\n\tstruct hvfb_par *par;\n\tstruct synthvid_msg *msg;\n\n\tif (!info)\n\t\treturn;\n\n\tpar = info->par;\n\tmsg = (struct synthvid_msg *)par->recv_buf;\n\n\t \n\tif (msg->vid_hdr.type == SYNTHVID_VERSION_RESPONSE ||\n\t    msg->vid_hdr.type == SYNTHVID_RESOLUTION_RESPONSE ||\n\t    msg->vid_hdr.type == SYNTHVID_VRAM_LOCATION_ACK) {\n\t\tmemcpy(par->init_buf, msg, MAX_VMBUS_PKT_SIZE);\n\t\tcomplete(&par->wait);\n\t\treturn;\n\t}\n\n\t \n\tif (msg->vid_hdr.type == SYNTHVID_FEATURE_CHANGE) {\n\t\tif (par->fb_ready) {\n\t\t\tsynthvid_send_ptr(hdev);\n\t\t\tsynthvid_send_situ(hdev);\n\t\t}\n\n\t\tpar->update = msg->feature_chg.is_dirt_needed;\n\t\tif (par->update)\n\t\t\tschedule_delayed_work(&par->dwork, HVFB_UPDATE_DELAY);\n\t}\n}\n\n \nstatic void synthvid_receive(void *ctx)\n{\n\tstruct hv_device *hdev = ctx;\n\tstruct fb_info *info = hv_get_drvdata(hdev);\n\tstruct hvfb_par *par;\n\tstruct synthvid_msg *recv_buf;\n\tu32 bytes_recvd;\n\tu64 req_id;\n\tint ret;\n\n\tif (!info)\n\t\treturn;\n\n\tpar = info->par;\n\trecv_buf = (struct synthvid_msg *)par->recv_buf;\n\n\tdo {\n\t\tret = vmbus_recvpacket(hdev->channel, recv_buf,\n\t\t\t\t       MAX_VMBUS_PKT_SIZE,\n\t\t\t\t       &bytes_recvd, &req_id);\n\t\tif (bytes_recvd > 0 &&\n\t\t    recv_buf->pipe_hdr.type == PIPE_MSG_DATA)\n\t\t\tsynthvid_recv_sub(hdev);\n\t} while (bytes_recvd > 0 && ret == 0);\n}\n\n \nstatic inline bool synthvid_ver_ge(u32 ver1, u32 ver2)\n{\n\tif (SYNTHVID_VER_GET_MAJOR(ver1) > SYNTHVID_VER_GET_MAJOR(ver2) ||\n\t    (SYNTHVID_VER_GET_MAJOR(ver1) == SYNTHVID_VER_GET_MAJOR(ver2) &&\n\t     SYNTHVID_VER_GET_MINOR(ver1) >= SYNTHVID_VER_GET_MINOR(ver2)))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int synthvid_negotiate_ver(struct hv_device *hdev, u32 ver)\n{\n\tstruct fb_info *info = hv_get_drvdata(hdev);\n\tstruct hvfb_par *par = info->par;\n\tstruct synthvid_msg *msg = (struct synthvid_msg *)par->init_buf;\n\tint ret = 0;\n\tunsigned long t;\n\n\tmemset(msg, 0, sizeof(struct synthvid_msg));\n\tmsg->vid_hdr.type = SYNTHVID_VERSION_REQUEST;\n\tmsg->vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_version_req);\n\tmsg->ver_req.version = ver;\n\tsynthvid_send(hdev, msg);\n\n\tt = wait_for_completion_timeout(&par->wait, VSP_TIMEOUT);\n\tif (!t) {\n\t\tpr_err(\"Time out on waiting version response\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\tif (!msg->ver_resp.is_accepted) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tpar->synthvid_version = ver;\n\tpr_info(\"Synthvid Version major %d, minor %d\\n\",\n\t\tSYNTHVID_VER_GET_MAJOR(ver), SYNTHVID_VER_GET_MINOR(ver));\n\nout:\n\treturn ret;\n}\n\n \nstatic int synthvid_get_supported_resolution(struct hv_device *hdev)\n{\n\tstruct fb_info *info = hv_get_drvdata(hdev);\n\tstruct hvfb_par *par = info->par;\n\tstruct synthvid_msg *msg = (struct synthvid_msg *)par->init_buf;\n\tint ret = 0;\n\tunsigned long t;\n\tu8 index;\n\n\tmemset(msg, 0, sizeof(struct synthvid_msg));\n\tmsg->vid_hdr.type = SYNTHVID_RESOLUTION_REQUEST;\n\tmsg->vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_supported_resolution_req);\n\n\tmsg->resolution_req.maximum_resolution_count =\n\t\tSYNTHVID_MAX_RESOLUTION_COUNT;\n\tsynthvid_send(hdev, msg);\n\n\tt = wait_for_completion_timeout(&par->wait, VSP_TIMEOUT);\n\tif (!t) {\n\t\tpr_err(\"Time out on waiting resolution response\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tif (msg->resolution_resp.resolution_count == 0) {\n\t\tpr_err(\"No supported resolutions\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tindex = msg->resolution_resp.default_resolution_index;\n\tif (index >= msg->resolution_resp.resolution_count) {\n\t\tpr_err(\"Invalid resolution index: %d\\n\", index);\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tscreen_width =\n\t\tmsg->resolution_resp.supported_resolution[index].width;\n\tscreen_height =\n\t\tmsg->resolution_resp.supported_resolution[index].height;\n\nout:\n\treturn ret;\n}\n\n \nstatic int synthvid_connect_vsp(struct hv_device *hdev)\n{\n\tstruct fb_info *info = hv_get_drvdata(hdev);\n\tstruct hvfb_par *par = info->par;\n\tint ret;\n\n\tret = vmbus_open(hdev->channel, RING_BUFSIZE, RING_BUFSIZE,\n\t\t\t NULL, 0, synthvid_receive, hdev);\n\tif (ret) {\n\t\tpr_err(\"Unable to open vmbus channel\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tswitch (vmbus_proto_version) {\n\tcase VERSION_WIN10:\n\tcase VERSION_WIN10_V5:\n\t\tret = synthvid_negotiate_ver(hdev, SYNTHVID_VERSION_WIN10);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase VERSION_WIN8:\n\tcase VERSION_WIN8_1:\n\t\tret = synthvid_negotiate_ver(hdev, SYNTHVID_VERSION_WIN8);\n\t\tbreak;\n\tdefault:\n\t\tret = synthvid_negotiate_ver(hdev, SYNTHVID_VERSION_WIN10);\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tpr_err(\"Synthetic video device version not accepted\\n\");\n\t\tgoto error;\n\t}\n\n\tscreen_depth = SYNTHVID_DEPTH_WIN8;\n\tif (synthvid_ver_ge(par->synthvid_version, SYNTHVID_VERSION_WIN10)) {\n\t\tret = synthvid_get_supported_resolution(hdev);\n\t\tif (ret)\n\t\t\tpr_info(\"Failed to get supported resolution from host, use default\\n\");\n\t}\n\n\tscreen_fb_size = hdev->channel->offermsg.offer.\n\t\t\t\tmmio_megabytes * 1024 * 1024;\n\n\treturn 0;\n\nerror:\n\tvmbus_close(hdev->channel);\n\treturn ret;\n}\n\n \nstatic int synthvid_send_config(struct hv_device *hdev)\n{\n\tstruct fb_info *info = hv_get_drvdata(hdev);\n\tstruct hvfb_par *par = info->par;\n\tstruct synthvid_msg *msg = (struct synthvid_msg *)par->init_buf;\n\tint ret = 0;\n\tunsigned long t;\n\n\t \n\tmemset(msg, 0, sizeof(struct synthvid_msg));\n\tmsg->vid_hdr.type = SYNTHVID_VRAM_LOCATION;\n\tmsg->vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\n\t\tsizeof(struct synthvid_vram_location);\n\tmsg->vram.user_ctx = msg->vram.vram_gpa = par->mmio_pp;\n\tmsg->vram.is_vram_gpa_specified = 1;\n\tsynthvid_send(hdev, msg);\n\n\tt = wait_for_completion_timeout(&par->wait, VSP_TIMEOUT);\n\tif (!t) {\n\t\tpr_err(\"Time out on waiting vram location ack\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\tif (msg->vram_ack.user_ctx != par->mmio_pp) {\n\t\tpr_err(\"Unable to set VRAM location\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tsynthvid_send_ptr(hdev);\n\tsynthvid_send_situ(hdev);\n\nout:\n\treturn ret;\n}\n\n\n \nstatic void hvfb_update_work(struct work_struct *w)\n{\n\tstruct hvfb_par *par = container_of(w, struct hvfb_par, dwork.work);\n\tstruct fb_info *info = par->info;\n\tunsigned long flags;\n\tint x1, x2, y1, y2;\n\tint j;\n\n\tspin_lock_irqsave(&par->delayed_refresh_lock, flags);\n\t \n\tpar->delayed_refresh = false;\n\n\t \n\tx1 = par->x1;\n\tx2 = par->x2;\n\ty1 = par->y1;\n\ty2 = par->y2;\n\n\t \n\tpar->x1 = par->y1 = INT_MAX;\n\tpar->x2 = par->y2 = 0;\n\n\tspin_unlock_irqrestore(&par->delayed_refresh_lock, flags);\n\n\tif (x1 > info->var.xres || x2 > info->var.xres ||\n\t    y1 > info->var.yres || y2 > info->var.yres || x2 <= x1)\n\t\treturn;\n\n\t \n\tif (par->need_docopy)\n\t\tfor (j = y1; j < y2; j++)\n\t\t\thvfb_docopy(par,\n\t\t\t\t    j * info->fix.line_length +\n\t\t\t\t    (x1 * screen_depth / 8),\n\t\t\t\t    (x2 - x1) * screen_depth / 8);\n\n\t \n\tif (par->fb_ready && par->update)\n\t\tsynthvid_update(info, x1, y1, x2, y2);\n}\n\n \nstatic void hvfb_ondemand_refresh_throttle(struct hvfb_par *par,\n\t\t\t\t\t   int x1, int y1, int w, int h)\n{\n\tunsigned long flags;\n\tint x2 = x1 + w;\n\tint y2 = y1 + h;\n\n\tspin_lock_irqsave(&par->delayed_refresh_lock, flags);\n\n\t \n\tpar->x1 = min_t(int, par->x1, x1);\n\tpar->y1 = min_t(int, par->y1, y1);\n\tpar->x2 = max_t(int, par->x2, x2);\n\tpar->y2 = max_t(int, par->y2, y2);\n\n\t \n\tif (par->delayed_refresh == false) {\n\t\tschedule_delayed_work(&par->dwork,\n\t\t\t\t      HVFB_ONDEMAND_THROTTLE);\n\t\tpar->delayed_refresh = true;\n\t}\n\n\tspin_unlock_irqrestore(&par->delayed_refresh_lock, flags);\n}\n\nstatic int hvfb_on_panic(struct notifier_block *nb,\n\t\t\t unsigned long e, void *p)\n{\n\tstruct hv_device *hdev;\n\tstruct hvfb_par *par;\n\tstruct fb_info *info;\n\n\tpar = container_of(nb, struct hvfb_par, hvfb_panic_nb);\n\tinfo = par->info;\n\thdev = device_to_hv_device(info->device);\n\n\tif (hv_ringbuffer_spinlock_busy(hdev->channel))\n\t\treturn NOTIFY_DONE;\n\n\tpar->synchronous_fb = true;\n\tif (par->need_docopy)\n\t\thvfb_docopy(par, 0, dio_fb_size);\n\tsynthvid_update(info, 0, 0, INT_MAX, INT_MAX);\n\n\treturn NOTIFY_DONE;\n}\n\n \n\nstatic int hvfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tif (var->xres < HVFB_WIDTH_MIN || var->yres < HVFB_HEIGHT_MIN ||\n\t    var->xres > screen_width || var->yres >  screen_height ||\n\t    var->bits_per_pixel != screen_depth)\n\t\treturn -EINVAL;\n\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = var->yres;\n\n\treturn 0;\n}\n\nstatic int hvfb_set_par(struct fb_info *info)\n{\n\tstruct hv_device *hdev = device_to_hv_device(info->device);\n\n\treturn synthvid_send_situ(hdev);\n}\n\n\nstatic inline u32 chan_to_field(u32 chan, struct fb_bitfield *bf)\n{\n\treturn ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;\n}\n\nstatic int hvfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t  unsigned blue, unsigned transp, struct fb_info *info)\n{\n\tu32 *pal = info->pseudo_palette;\n\n\tif (regno > 15)\n\t\treturn -EINVAL;\n\n\tpal[regno] = chan_to_field(red, &info->var.red)\n\t\t| chan_to_field(green, &info->var.green)\n\t\t| chan_to_field(blue, &info->var.blue)\n\t\t| chan_to_field(transp, &info->var.transp);\n\n\treturn 0;\n}\n\nstatic int hvfb_blank(int blank, struct fb_info *info)\n{\n\treturn 1;\t \n}\n\nstatic void hvfb_cfb_fillrect(struct fb_info *p,\n\t\t\t      const struct fb_fillrect *rect)\n{\n\tstruct hvfb_par *par = p->par;\n\n\tcfb_fillrect(p, rect);\n\tif (par->synchronous_fb)\n\t\tsynthvid_update(p, 0, 0, INT_MAX, INT_MAX);\n\telse\n\t\thvfb_ondemand_refresh_throttle(par, rect->dx, rect->dy,\n\t\t\t\t\t       rect->width, rect->height);\n}\n\nstatic void hvfb_cfb_copyarea(struct fb_info *p,\n\t\t\t      const struct fb_copyarea *area)\n{\n\tstruct hvfb_par *par = p->par;\n\n\tcfb_copyarea(p, area);\n\tif (par->synchronous_fb)\n\t\tsynthvid_update(p, 0, 0, INT_MAX, INT_MAX);\n\telse\n\t\thvfb_ondemand_refresh_throttle(par, area->dx, area->dy,\n\t\t\t\t\t       area->width, area->height);\n}\n\nstatic void hvfb_cfb_imageblit(struct fb_info *p,\n\t\t\t       const struct fb_image *image)\n{\n\tstruct hvfb_par *par = p->par;\n\n\tcfb_imageblit(p, image);\n\tif (par->synchronous_fb)\n\t\tsynthvid_update(p, 0, 0, INT_MAX, INT_MAX);\n\telse\n\t\thvfb_ondemand_refresh_throttle(par, image->dx, image->dy,\n\t\t\t\t\t       image->width, image->height);\n}\n\nstatic const struct fb_ops hvfb_ops = {\n\t.owner = THIS_MODULE,\n\t.fb_check_var = hvfb_check_var,\n\t.fb_set_par = hvfb_set_par,\n\t.fb_setcolreg = hvfb_setcolreg,\n\t.fb_fillrect = hvfb_cfb_fillrect,\n\t.fb_copyarea = hvfb_cfb_copyarea,\n\t.fb_imageblit = hvfb_cfb_imageblit,\n\t.fb_blank = hvfb_blank,\n\t.fb_mmap = fb_deferred_io_mmap,\n};\n\n\n \nstatic void hvfb_get_option(struct fb_info *info)\n{\n\tstruct hvfb_par *par = info->par;\n\tchar *opt = NULL, *p;\n\tuint x = 0, y = 0;\n\n\tif (fb_get_options(KBUILD_MODNAME, &opt) || !opt || !*opt)\n\t\treturn;\n\n\tp = strsep(&opt, \"x\");\n\tif (!*p || kstrtouint(p, 0, &x) ||\n\t    !opt || !*opt || kstrtouint(opt, 0, &y)) {\n\t\tpr_err(\"Screen option is invalid: skipped\\n\");\n\t\treturn;\n\t}\n\n\tif (x < HVFB_WIDTH_MIN || y < HVFB_HEIGHT_MIN ||\n\t    (synthvid_ver_ge(par->synthvid_version, SYNTHVID_VERSION_WIN10) &&\n\t    (x * y * screen_depth / 8 > screen_fb_size)) ||\n\t    (par->synthvid_version == SYNTHVID_VERSION_WIN8 &&\n\t     x * y * screen_depth / 8 > SYNTHVID_FB_SIZE_WIN8)) {\n\t\tpr_err(\"Screen resolution option is out of range: skipped\\n\");\n\t\treturn;\n\t}\n\n\tscreen_width = x;\n\tscreen_height = y;\n\treturn;\n}\n\n \nstatic phys_addr_t hvfb_get_phymem(struct hv_device *hdev,\n\t\t\t\t   unsigned int request_size)\n{\n\tstruct page *page = NULL;\n\tdma_addr_t dma_handle;\n\tvoid *vmem;\n\tphys_addr_t paddr = 0;\n\tunsigned int order = get_order(request_size);\n\n\tif (request_size == 0)\n\t\treturn -1;\n\n\tif (order <= MAX_ORDER) {\n\t\t \n\t\tpage = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);\n\t\tif (!page)\n\t\t\treturn -1;\n\n\t\tpaddr = (page_to_pfn(page) << PAGE_SHIFT);\n\t} else {\n\t\t \n\t\thdev->device.coherent_dma_mask = DMA_BIT_MASK(64);\n\n\t\tvmem = dma_alloc_coherent(&hdev->device,\n\t\t\t\t\t  round_up(request_size, PAGE_SIZE),\n\t\t\t\t\t  &dma_handle,\n\t\t\t\t\t  GFP_KERNEL | __GFP_NOWARN);\n\n\t\tif (!vmem)\n\t\t\treturn -1;\n\n\t\tpaddr = virt_to_phys(vmem);\n\t}\n\n\treturn paddr;\n}\n\n \nstatic void hvfb_release_phymem(struct hv_device *hdev,\n\t\t\t\tphys_addr_t paddr, unsigned int size)\n{\n\tunsigned int order = get_order(size);\n\n\tif (order <= MAX_ORDER)\n\t\t__free_pages(pfn_to_page(paddr >> PAGE_SHIFT), order);\n\telse\n\t\tdma_free_coherent(&hdev->device,\n\t\t\t\t  round_up(size, PAGE_SIZE),\n\t\t\t\t  phys_to_virt(paddr),\n\t\t\t\t  paddr);\n}\n\n\n \nstatic int hvfb_getmem(struct hv_device *hdev, struct fb_info *info)\n{\n\tstruct hvfb_par *par = info->par;\n\tstruct pci_dev *pdev  = NULL;\n\tvoid __iomem *fb_virt;\n\tint gen2vm = efi_enabled(EFI_BOOT);\n\tresource_size_t base, size;\n\tphys_addr_t paddr;\n\tint ret;\n\n\tif (!gen2vm) {\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_MICROSOFT,\n\t\t\tPCI_DEVICE_ID_HYPERV_VIDEO, NULL);\n\t\tif (!pdev) {\n\t\t\tpr_err(\"Unable to find PCI Hyper-V video\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tbase = pci_resource_start(pdev, 0);\n\t\tsize = pci_resource_len(pdev, 0);\n\n\t\t \n\t\tpaddr = hvfb_get_phymem(hdev, screen_fb_size);\n\t\tif (paddr != (phys_addr_t) -1) {\n\t\t\tpar->mmio_pp = paddr;\n\t\t\tpar->mmio_vp = par->dio_vp = __va(paddr);\n\n\t\t\tinfo->fix.smem_start = paddr;\n\t\t\tinfo->fix.smem_len = screen_fb_size;\n\t\t\tinfo->screen_base = par->mmio_vp;\n\t\t\tinfo->screen_size = screen_fb_size;\n\n\t\t\tpar->need_docopy = false;\n\t\t\tgoto getmem_done;\n\t\t}\n\t\tpr_info(\"Unable to allocate enough contiguous physical memory on Gen 1 VM. Using MMIO instead.\\n\");\n\t} else {\n\t\tbase = screen_info.lfb_base;\n\t\tsize = screen_info.lfb_size;\n\t}\n\n\t \n\tdio_fb_size =\n\t\tscreen_width * screen_height * screen_depth / 8;\n\n\tret = vmbus_allocate_mmio(&par->mem, hdev, 0, -1,\n\t\t\t\t  screen_fb_size, 0x100000, true);\n\tif (ret != 0) {\n\t\tpr_err(\"Unable to allocate framebuffer memory\\n\");\n\t\tgoto err1;\n\t}\n\n\t \n\tfb_virt = ioremap_cache(par->mem->start, screen_fb_size);\n\tif (!fb_virt)\n\t\tgoto err2;\n\n\t \n\tpar->dio_vp = vzalloc(round_up(dio_fb_size, PAGE_SIZE));\n\tif (par->dio_vp == NULL)\n\t\tgoto err3;\n\n\t \n\tpar->mmio_pp = par->mem->start;\n\t \n\tpar->mmio_vp = (unsigned char *) fb_virt;\n\n\tinfo->fix.smem_start = par->mem->start;\n\tinfo->fix.smem_len = dio_fb_size;\n\tinfo->screen_base = par->dio_vp;\n\tinfo->screen_size = dio_fb_size;\n\ngetmem_done:\n\taperture_remove_conflicting_devices(base, size, KBUILD_MODNAME);\n\n\tif (gen2vm) {\n\t\t \n\t\tscreen_info.lfb_size = 0;\n\t\tscreen_info.lfb_base = 0;\n\t\tscreen_info.orig_video_isVGA = 0;\n\t} else {\n\t\tpci_dev_put(pdev);\n\t}\n\n\treturn 0;\n\nerr3:\n\tiounmap(fb_virt);\nerr2:\n\tvmbus_free_mmio(par->mem->start, screen_fb_size);\n\tpar->mem = NULL;\nerr1:\n\tif (!gen2vm)\n\t\tpci_dev_put(pdev);\n\n\treturn -ENOMEM;\n}\n\n \nstatic void hvfb_putmem(struct hv_device *hdev, struct fb_info *info)\n{\n\tstruct hvfb_par *par = info->par;\n\n\tif (par->need_docopy) {\n\t\tvfree(par->dio_vp);\n\t\tiounmap(info->screen_base);\n\t\tvmbus_free_mmio(par->mem->start, screen_fb_size);\n\t} else {\n\t\thvfb_release_phymem(hdev, info->fix.smem_start,\n\t\t\t\t    screen_fb_size);\n\t}\n\n\tpar->mem = NULL;\n}\n\n\nstatic int hvfb_probe(struct hv_device *hdev,\n\t\t      const struct hv_vmbus_device_id *dev_id)\n{\n\tstruct fb_info *info;\n\tstruct hvfb_par *par;\n\tint ret;\n\n\tinfo = framebuffer_alloc(sizeof(struct hvfb_par), &hdev->device);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tpar->info = info;\n\tpar->fb_ready = false;\n\tpar->need_docopy = true;\n\tinit_completion(&par->wait);\n\tINIT_DELAYED_WORK(&par->dwork, hvfb_update_work);\n\n\tpar->delayed_refresh = false;\n\tspin_lock_init(&par->delayed_refresh_lock);\n\tpar->x1 = par->y1 = INT_MAX;\n\tpar->x2 = par->y2 = 0;\n\n\t \n\thv_set_drvdata(hdev, info);\n\tret = synthvid_connect_vsp(hdev);\n\tif (ret) {\n\t\tpr_err(\"Unable to connect to VSP\\n\");\n\t\tgoto error1;\n\t}\n\n\thvfb_get_option(info);\n\tpr_info(\"Screen resolution: %dx%d, Color depth: %d, Frame buffer size: %d\\n\",\n\t\tscreen_width, screen_height, screen_depth, screen_fb_size);\n\n\tret = hvfb_getmem(hdev, info);\n\tif (ret) {\n\t\tpr_err(\"No memory for framebuffer\\n\");\n\t\tgoto error2;\n\t}\n\n\t \n\tinfo->var.xres_virtual = info->var.xres = screen_width;\n\tinfo->var.yres_virtual = info->var.yres = screen_height;\n\tinfo->var.bits_per_pixel = screen_depth;\n\n\tif (info->var.bits_per_pixel == 16) {\n\t\tinfo->var.red = (struct fb_bitfield){11, 5, 0};\n\t\tinfo->var.green = (struct fb_bitfield){5, 6, 0};\n\t\tinfo->var.blue = (struct fb_bitfield){0, 5, 0};\n\t\tinfo->var.transp = (struct fb_bitfield){0, 0, 0};\n\t} else {\n\t\tinfo->var.red = (struct fb_bitfield){16, 8, 0};\n\t\tinfo->var.green = (struct fb_bitfield){8, 8, 0};\n\t\tinfo->var.blue = (struct fb_bitfield){0, 8, 0};\n\t\tinfo->var.transp = (struct fb_bitfield){24, 8, 0};\n\t}\n\n\tinfo->var.activate = FB_ACTIVATE_NOW;\n\tinfo->var.height = -1;\n\tinfo->var.width = -1;\n\tinfo->var.vmode = FB_VMODE_NONINTERLACED;\n\n\tstrcpy(info->fix.id, KBUILD_MODNAME);\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\tinfo->fix.line_length = screen_width * screen_depth / 8;\n\tinfo->fix.accel = FB_ACCEL_NONE;\n\n\tinfo->fbops = &hvfb_ops;\n\tinfo->pseudo_palette = par->pseudo_palette;\n\n\t \n\tinfo->fbdefio = &synthvid_defio;\n\tfb_deferred_io_init(info);\n\n\t \n\tret = synthvid_send_config(hdev);\n\tif (ret)\n\t\tgoto error;\n\n\tret = register_framebuffer(info);\n\tif (ret) {\n\t\tpr_err(\"Unable to register framebuffer\\n\");\n\t\tgoto error;\n\t}\n\n\tpar->fb_ready = true;\n\n\tpar->synchronous_fb = false;\n\n\t \n\tpar->hvfb_panic_nb.notifier_call = hvfb_on_panic;\n\tpar->hvfb_panic_nb.priority = INT_MIN + 10,\n\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t       &par->hvfb_panic_nb);\n\n\treturn 0;\n\nerror:\n\tfb_deferred_io_cleanup(info);\n\thvfb_putmem(hdev, info);\nerror2:\n\tvmbus_close(hdev->channel);\nerror1:\n\tcancel_delayed_work_sync(&par->dwork);\n\thv_set_drvdata(hdev, NULL);\n\tframebuffer_release(info);\n\treturn ret;\n}\n\nstatic void hvfb_remove(struct hv_device *hdev)\n{\n\tstruct fb_info *info = hv_get_drvdata(hdev);\n\tstruct hvfb_par *par = info->par;\n\n\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t &par->hvfb_panic_nb);\n\n\tpar->update = false;\n\tpar->fb_ready = false;\n\n\tfb_deferred_io_cleanup(info);\n\n\tunregister_framebuffer(info);\n\tcancel_delayed_work_sync(&par->dwork);\n\n\tvmbus_close(hdev->channel);\n\thv_set_drvdata(hdev, NULL);\n\n\thvfb_putmem(hdev, info);\n\tframebuffer_release(info);\n}\n\nstatic int hvfb_suspend(struct hv_device *hdev)\n{\n\tstruct fb_info *info = hv_get_drvdata(hdev);\n\tstruct hvfb_par *par = info->par;\n\n\tconsole_lock();\n\n\t \n\tfb_set_suspend(info, 1);\n\n\tcancel_delayed_work_sync(&par->dwork);\n\tcancel_delayed_work_sync(&info->deferred_work);\n\n\tpar->update_saved = par->update;\n\tpar->update = false;\n\tpar->fb_ready = false;\n\n\tvmbus_close(hdev->channel);\n\n\tconsole_unlock();\n\n\treturn 0;\n}\n\nstatic int hvfb_resume(struct hv_device *hdev)\n{\n\tstruct fb_info *info = hv_get_drvdata(hdev);\n\tstruct hvfb_par *par = info->par;\n\tint ret;\n\n\tconsole_lock();\n\n\tret = synthvid_connect_vsp(hdev);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tret = synthvid_send_config(hdev);\n\tif (ret != 0) {\n\t\tvmbus_close(hdev->channel);\n\t\tgoto out;\n\t}\n\n\tpar->fb_ready = true;\n\tpar->update = par->update_saved;\n\n\tschedule_delayed_work(&info->deferred_work, info->fbdefio->delay);\n\tschedule_delayed_work(&par->dwork, HVFB_UPDATE_DELAY);\n\n\t \n\tfb_set_suspend(info, 0);\n\nout:\n\tconsole_unlock();\n\n\treturn ret;\n}\n\n\nstatic const struct pci_device_id pci_stub_id_table[] = {\n\t{\n\t\t.vendor      = PCI_VENDOR_ID_MICROSOFT,\n\t\t.device      = PCI_DEVICE_ID_HYPERV_VIDEO,\n\t},\n\t{   }\n};\n\nstatic const struct hv_vmbus_device_id id_table[] = {\n\t \n\t{HV_SYNTHVID_GUID},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, pci_stub_id_table);\nMODULE_DEVICE_TABLE(vmbus, id_table);\n\nstatic struct hv_driver hvfb_drv = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = id_table,\n\t.probe = hvfb_probe,\n\t.remove = hvfb_remove,\n\t.suspend = hvfb_suspend,\n\t.resume = hvfb_resume,\n\t.driver = {\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int hvfb_pci_stub_probe(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *ent)\n{\n\treturn 0;\n}\n\nstatic void hvfb_pci_stub_remove(struct pci_dev *pdev)\n{\n}\n\nstatic struct pci_driver hvfb_pci_stub_driver = {\n\t.name =\t\tKBUILD_MODNAME,\n\t.id_table =\tpci_stub_id_table,\n\t.probe =\thvfb_pci_stub_probe,\n\t.remove =\thvfb_pci_stub_remove,\n\t.driver = {\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t}\n};\n\nstatic int __init hvfb_drv_init(void)\n{\n\tint ret;\n\n\tif (fb_modesetting_disabled(\"hyper_fb\"))\n\t\treturn -ENODEV;\n\n\tret = vmbus_driver_register(&hvfb_drv);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = pci_register_driver(&hvfb_pci_stub_driver);\n\tif (ret != 0) {\n\t\tvmbus_driver_unregister(&hvfb_drv);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit hvfb_drv_exit(void)\n{\n\tpci_unregister_driver(&hvfb_pci_stub_driver);\n\tvmbus_driver_unregister(&hvfb_drv);\n}\n\nmodule_init(hvfb_drv_init);\nmodule_exit(hvfb_drv_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Microsoft Hyper-V Synthetic Video Frame Buffer Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}