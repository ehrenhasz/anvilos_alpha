{
  "module_name": "sstfb.c",
  "hash_id": "55c760d14ef33186e13fd0d5a75d42ed48890237a3ad5ea82e381c3d10a991e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/sstfb.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n#undef SST_DEBUG\n\n\n \n\n#include <linux/aperture.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/fb.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <video/sstfb.h>\n\n\n \n\nstatic bool vgapass;\t\t \nstatic int mem;\t\t\t \nstatic bool clipping = 1;\t \nstatic int gfxclk;\t\t \nstatic bool slowpci;\t\t \n\n \n#define DEFAULT_VIDEO_MODE \"640x480@60\"\n\nstatic char *mode_option = DEFAULT_VIDEO_MODE;\n\nenum {\n\tID_VOODOO1 = 0,\n\tID_VOODOO2 = 1,\n};\n\n#define IS_VOODOO2(par) ((par)->type == ID_VOODOO2)\n\nstatic struct sst_spec voodoo_spec[] = {\n { .name = \"Voodoo Graphics\", .default_gfx_clock = 50000, .max_gfxclk = 60 },\n { .name = \"Voodoo2\",\t      .default_gfx_clock = 75000, .max_gfxclk = 85 },\n};\n\n\n \n\n#if (SST_DEBUG_REG > 0)\nstatic void sst_dbg_print_read_reg(u32 reg, u32 val) {\n\tconst char *regname;\n\tswitch (reg) {\n\tcase FBIINIT0:\tregname = \"FbiInit0\"; break;\n\tcase FBIINIT1:\tregname = \"FbiInit1\"; break;\n\tcase FBIINIT2:\tregname = \"FbiInit2\"; break;\n\tcase FBIINIT3:\tregname = \"FbiInit3\"; break;\n\tcase FBIINIT4:\tregname = \"FbiInit4\"; break;\n\tcase FBIINIT5:\tregname = \"FbiInit5\"; break;\n\tcase FBIINIT6:\tregname = \"FbiInit6\"; break;\n\tdefault:\tregname = NULL;       break;\n\t}\n\tif (regname == NULL)\n\t\tr_ddprintk(\"sst_read(%#x): %#x\\n\", reg, val);\n\telse\n\t\tr_dprintk(\" sst_read(%s): %#x\\n\", regname, val);\n}\n\nstatic void sst_dbg_print_write_reg(u32 reg, u32 val) {\n\tconst char *regname;\n\tswitch (reg) {\n\tcase FBIINIT0:\tregname = \"FbiInit0\"; break;\n\tcase FBIINIT1:\tregname = \"FbiInit1\"; break;\n\tcase FBIINIT2:\tregname = \"FbiInit2\"; break;\n\tcase FBIINIT3:\tregname = \"FbiInit3\"; break;\n\tcase FBIINIT4:\tregname = \"FbiInit4\"; break;\n\tcase FBIINIT5:\tregname = \"FbiInit5\"; break;\n\tcase FBIINIT6:\tregname = \"FbiInit6\"; break;\n\tdefault:\tregname = NULL;       break;\n\t}\n\tif (regname == NULL)\n\t\tr_ddprintk(\"sst_write(%#x, %#x)\\n\", reg, val);\n\telse\n\t\tr_dprintk(\" sst_write(%s, %#x)\\n\", regname, val);\n}\n#else  \n#  define sst_dbg_print_read_reg(reg, val)\tdo {} while(0)\n#  define sst_dbg_print_write_reg(reg, val)\tdo {} while(0)\n#endif  \n\n \n\n \n#define sst_read(reg)\t\t__sst_read(par->mmio_vbase, reg)\n#define sst_write(reg,val)\t__sst_write(par->mmio_vbase, reg, val)\n#define sst_set_bits(reg,val)\t__sst_set_bits(par->mmio_vbase, reg, val)\n#define sst_unset_bits(reg,val)\t__sst_unset_bits(par->mmio_vbase, reg, val)\n#define sst_dac_read(reg)\t__sst_dac_read(par->mmio_vbase, reg)\n#define sst_dac_write(reg,val)\t__sst_dac_write(par->mmio_vbase, reg, val)\n#define dac_i_read(reg)\t\t__dac_i_read(par->mmio_vbase, reg)\n#define dac_i_write(reg,val)\t__dac_i_write(par->mmio_vbase, reg, val)\n\nstatic inline u32 __sst_read(u8 __iomem *vbase, u32 reg)\n{\n\tu32 ret = readl(vbase + reg);\n\tsst_dbg_print_read_reg(reg, ret);\n\treturn ret;\n}\n\nstatic inline void __sst_write(u8 __iomem *vbase, u32 reg, u32 val)\n{\n\tsst_dbg_print_write_reg(reg, val);\n\twritel(val, vbase + reg);\n}\n\nstatic inline void __sst_set_bits(u8 __iomem *vbase, u32 reg, u32 val)\n{\n\tr_dprintk(\"sst_set_bits(%#x, %#x)\\n\", reg, val);\n\t__sst_write(vbase, reg, __sst_read(vbase, reg) | val);\n}\n\nstatic inline void __sst_unset_bits(u8 __iomem *vbase, u32 reg, u32 val)\n{\n\tr_dprintk(\"sst_unset_bits(%#x, %#x)\\n\", reg, val);\n\t__sst_write(vbase, reg, __sst_read(vbase, reg) & ~val);\n}\n\n \n\n#define sst_wait_idle() __sst_wait_idle(par->mmio_vbase)\n\nstatic int __sst_wait_idle(u8 __iomem *vbase)\n{\n\tint count = 0;\n\n\t \n\n\twhile(1) {\n\t\tif (__sst_read(vbase, STATUS) & STATUS_FBI_BUSY) {\n\t\t\tf_dddprintk(\"status: busy\\n\");\n \n\t\t\tcount = 0;\n\t\t} else {\n\t\t\tcount++;\n\t\t\tf_dddprintk(\"status: idle(%d)\\n\", count);\n\t\t}\n\t\tif (count >= 5) return 1;\n \n\t}\n}\n\n\n \n \nstatic u8 __sst_dac_read(u8 __iomem *vbase, u8 reg)\n{\n\tu8 ret;\n\n\treg &= 0x07;\n\t__sst_write(vbase, DAC_DATA, ((u32)reg << 8) | DAC_READ_CMD );\n\t__sst_wait_idle(vbase);\n\t \n\tret = __sst_read(vbase, DAC_READ) & 0xff;\n\tr_dprintk(\"sst_dac_read(%#x): %#x\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic void __sst_dac_write(u8 __iomem *vbase, u8 reg, u8 val)\n{\n\tr_dprintk(\"sst_dac_write(%#x, %#x)\\n\", reg, val);\n\treg &= 0x07;\n\t__sst_write(vbase, DAC_DATA,(((u32)reg << 8)) | (u32)val);\n\t__sst_wait_idle(vbase);\n}\n\n \nstatic u32 __dac_i_read(u8 __iomem *vbase, u8 reg)\n{\n\tu32 ret;\n\n\t__sst_dac_write(vbase, DACREG_ADDR_I, reg);\n\tret = __sst_dac_read(vbase, DACREG_DATA_I);\n\tr_dprintk(\"sst_dac_read_i(%#x): %#x\\n\", reg, ret);\n\treturn ret;\n}\nstatic void __dac_i_write(u8 __iomem *vbase, u8 reg,u8 val)\n{\n\tr_dprintk(\"sst_dac_write_i(%#x, %#x)\\n\", reg, val);\n\t__sst_dac_write(vbase, DACREG_ADDR_I, reg);\n\t__sst_dac_write(vbase, DACREG_DATA_I, val);\n}\n\n \nstatic int sst_calc_pll(const int freq, int *freq_out, struct pll_timing *t)\n{\n\tint m, m2, n, p, best_err, fout;\n\tint best_n = -1;\n\tint best_m = -1;\n\n\tbest_err = freq;\n\tp = 3;\n\t \n\twhile (((1 << p) * freq > VCO_MAX) && (p >= 0))\n\t\tp--;\n\tif (p == -1)\n\t\treturn -EINVAL;\n\tfor (n = 1; n < 32; n++) {\n\t\t \n\t\tm2 = (2 * freq * (1 << p) * (n + 2) ) / DAC_FREF - 4 ;\n\n\t\tm = (m2 % 2 ) ? m2/2+1 : m2/2 ;\n\t\tif (m >= 128)\n\t\t\tbreak;\n\t\tfout = (DAC_FREF * (m + 2)) / ((1 << p) * (n + 2));\n\t\tif ((abs(fout - freq) < best_err) && (m > 0)) {\n\t\t\tbest_n = n;\n\t\t\tbest_m = m;\n\t\t\tbest_err = abs(fout - freq);\n\t\t\t \n\t\t\tif (200*best_err < freq) break;\n\t\t}\n\t}\n\tif (best_n == -1)   \n\t\treturn -EINVAL;\n\tt->p = p;\n\tt->n = best_n;\n\tt->m = best_m;\n\t*freq_out = (DAC_FREF * (t->m + 2)) / ((1 << t->p) * (t->n + 2));\n\tf_ddprintk (\"m: %d, n: %d, p: %d, F: %dKhz\\n\",\n\t\t  t->m, t->n, t->p, *freq_out);\n\treturn 0;\n}\n\n \nstatic void sstfb_clear_screen(struct fb_info *info)\n{\n\t \n\tfb_memset_io(info->screen_base, 0, info->fix.smem_len);\n}\n\n\n \n\nstatic int sstfb_check_var(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info)\n{\n\tstruct sstfb_par *par = info->par;\n\tint hSyncOff   = var->xres + var->right_margin + var->left_margin;\n\tint vSyncOff   = var->yres + var->lower_margin + var->upper_margin;\n\tint vBackPorch = var->left_margin, yDim = var->yres;\n\tint vSyncOn    = var->vsync_len;\n\tint tiles_in_X, real_length;\n\tunsigned int freq;\n\n\tif (sst_calc_pll(PICOS2KHZ(var->pixclock), &freq, &par->pll)) {\n\t\tprintk(KERN_ERR \"sstfb: Pixclock at %ld KHZ out of range\\n\",\n\t\t\t\tPICOS2KHZ(var->pixclock));\n\t\treturn -EINVAL;\n\t}\n\tvar->pixclock = KHZ2PICOS(freq);\n\n\tif (var->vmode & FB_VMODE_INTERLACED)\n\t\tvBackPorch += (vBackPorch % 2);\n\tif (var->vmode & FB_VMODE_DOUBLE) {\n\t\tvBackPorch <<= 1;\n\t\tyDim <<=1;\n\t\tvSyncOn <<=1;\n\t\tvSyncOff <<=1;\n\t}\n\n\tswitch (var->bits_per_pixel) {\n\tcase 0 ... 16 :\n\t\tvar->bits_per_pixel = 16;\n\t\tbreak;\n\tdefault :\n\t\tprintk(KERN_ERR \"sstfb: Unsupported bpp %d\\n\", var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (var->xres <= 1 || yDim <= 0 || var->hsync_len <= 1  ||\n\t    hSyncOff <= 1  || var->left_margin <= 2  || vSyncOn <= 0 ||\n\t    vSyncOff <= 0 || vBackPorch <= 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_VOODOO2(par)) {\n\t\t \n\t\ttiles_in_X = (var->xres + 63 ) / 64 * 2;\n\n\t\tif (var->xres  > POW2(11) || yDim >= POW2(11)) {\n\t\t\tprintk(KERN_ERR \"sstfb: Unsupported resolution %dx%d\\n\",\n\t\t\t         var->xres, var->yres);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (var->hsync_len > POW2(9) || hSyncOff > POW2(11) ||\n\t\t    var->left_margin - 2 >= POW2(9) || vSyncOn >= POW2(13) ||\n\t\t    vSyncOff >= POW2(13) || vBackPorch >= POW2(9) ||\n\t\t    tiles_in_X >= POW2(6) || tiles_in_X <= 0) {\n\t\t\tprintk(KERN_ERR \"sstfb: Unsupported timings\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\ttiles_in_X = (var->xres + 63 ) / 64;\n\n\t\tif (var->vmode) {\n\t\t\tprintk(KERN_ERR \"sstfb: Interlace/doublescan not supported %#x\\n\",\n\t\t\t\tvar->vmode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (var->xres > POW2(10) || var->yres >= POW2(10)) {\n\t\t\tprintk(KERN_ERR \"sstfb: Unsupported resolution %dx%d\\n\",\n\t\t\t         var->xres, var->yres);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (var->hsync_len > POW2(8) || hSyncOff - 1 > POW2(10) ||\n\t\t    var->left_margin - 2 >= POW2(8) || vSyncOn >= POW2(12) ||\n\t\t    vSyncOff >= POW2(12) || vBackPorch >= POW2(8) ||\n\t\t    tiles_in_X >= POW2(4) || tiles_in_X <= 0) {\n\t\t\tprintk(KERN_ERR \"sstfb: Unsupported timings\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\t \n\treal_length = tiles_in_X  * (IS_VOODOO2(par) ? 32 : 64 )\n\t              * ((var->bits_per_pixel == 16) ? 2 : 4);\n\n\tif (real_length * yDim > info->fix.smem_len) {\n\t\tprintk(KERN_ERR \"sstfb: Not enough video memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tvar->sync &= (FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT);\n\tvar->vmode &= (FB_VMODE_INTERLACED | FB_VMODE_DOUBLE);\n\tvar->xoffset = 0;\n\tvar->yoffset = 0;\n\tvar->height  = -1;\n\tvar->width   = -1;\n\n\t \n\t \n\n\tswitch (var->bits_per_pixel) {\n\tcase 16:\t \n\t\tvar->red.length    = 5;\n\t\tvar->green.length  = 6;\n\t\tvar->blue.length   = 5;\n\t\tvar->transp.length = 0;\n\n\t\tvar->red.offset    = 11;\n\t\tvar->green.offset  = 5;\n\t\tvar->blue.offset   = 0;\n\t\tvar->transp.offset = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int sstfb_set_par(struct fb_info *info)\n{\n\tstruct sstfb_par *par = info->par;\n\tu32 lfbmode, fbiinit1, fbiinit2, fbiinit3, fbiinit5, fbiinit6=0;\n\tstruct pci_dev *sst_dev = par->dev;\n\tunsigned int freq;\n\tint ntiles;\n\n\tpar->hSyncOff\t= info->var.xres + info->var.right_margin + info->var.left_margin;\n\n\tpar->yDim \t= info->var.yres;\n\tpar->vSyncOn \t= info->var.vsync_len;\n\tpar->vSyncOff\t= info->var.yres + info->var.lower_margin + info->var.upper_margin;\n\tpar->vBackPorch = info->var.upper_margin;\n\n\t \n\tsst_calc_pll(PICOS2KHZ(info->var.pixclock), &freq, &par->pll);\n\n\tif (info->var.vmode & FB_VMODE_INTERLACED)\n\t\tpar->vBackPorch += (par->vBackPorch % 2);\n\tif (info->var.vmode & FB_VMODE_DOUBLE) {\n\t\tpar->vBackPorch <<= 1;\n\t\tpar->yDim <<=1;\n\t\tpar->vSyncOn <<=1;\n\t\tpar->vSyncOff <<=1;\n\t}\n\n\tif (IS_VOODOO2(par)) {\n\t\t \n\t\tpar->tiles_in_X = (info->var.xres + 63 ) / 64 * 2;\n\t} else {\n\t\t \n\t\tpar->tiles_in_X = (info->var.xres + 63 ) / 64;\n\t}\n\n\tf_ddprintk(\"hsync_len hSyncOff vsync_len vSyncOff\\n\");\n\tf_ddprintk(\"%-7d %-8d %-7d %-8d\\n\",\n\t           info->var.hsync_len, par->hSyncOff,\n\t           par->vSyncOn, par->vSyncOff);\n\tf_ddprintk(\"left_margin upper_margin xres yres Freq\\n\");\n\tf_ddprintk(\"%-10d %-10d %-4d %-4d %-8ld\\n\",\n\t           info->var.left_margin, info->var.upper_margin,\n\t           info->var.xres, info->var.yres, PICOS2KHZ(info->var.pixclock));\n\n\tsst_write(NOPCMD, 0);\n\tsst_wait_idle();\n\tpci_write_config_dword(sst_dev, PCI_INIT_ENABLE, PCI_EN_INIT_WR);\n\tsst_set_bits(FBIINIT1, VIDEO_RESET);\n\tsst_set_bits(FBIINIT0, FBI_RESET | FIFO_RESET);\n\tsst_unset_bits(FBIINIT2, EN_DRAM_REFRESH);\n\tsst_wait_idle();\n\n\t \n\n\tsst_write(BACKPORCH, par->vBackPorch << 16 | (info->var.left_margin - 2));\n\tsst_write(VIDEODIMENSIONS, par->yDim << 16 | (info->var.xres - 1));\n\tsst_write(HSYNC, (par->hSyncOff - 1) << 16 | (info->var.hsync_len - 1));\n\tsst_write(VSYNC,       par->vSyncOff << 16 | par->vSyncOn);\n\n\tfbiinit2 = sst_read(FBIINIT2);\n\tfbiinit3 = sst_read(FBIINIT3);\n\n\t \n\tpci_write_config_dword(sst_dev, PCI_INIT_ENABLE,\n\t                       PCI_EN_INIT_WR | PCI_REMAP_DAC );\n\n\tpar->dac_sw.set_vidmod(info, info->var.bits_per_pixel);\n\n\t \n\tpar->dac_sw.set_pll(info, &par->pll, VID_CLOCK);\n\n\t \n\tpci_write_config_dword(sst_dev, PCI_INIT_ENABLE,\n\t                       PCI_EN_INIT_WR);\n\n\t \n\tsst_write(FBIINIT2,fbiinit2);\n\tsst_write(FBIINIT3,fbiinit3);\n\n\tfbiinit1 = (sst_read(FBIINIT1) & VIDEO_MASK)\n\t            | EN_DATA_OE\n\t            | EN_BLANK_OE\n\t            | EN_HVSYNC_OE\n\t            | EN_DCLK_OE\n\t\t  \n\t            | SEL_INPUT_VCLK_2X\n\t\t  ;\n \n\n\tntiles = par->tiles_in_X;\n\tif (IS_VOODOO2(par)) {\n\t\tfbiinit1 |= ((ntiles & 0x20) >> 5) << TILES_IN_X_MSB_SHIFT\n\t\t            | ((ntiles & 0x1e) >> 1) << TILES_IN_X_SHIFT;\n \n\t\tfbiinit6 = (ntiles & 0x1) << TILES_IN_X_LSB_SHIFT;\n\t}\n\telse\n\t\tfbiinit1 |= ntiles << TILES_IN_X_SHIFT;\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 16:\n\t\tfbiinit1 |=  SEL_SOURCE_VCLK_2X_SEL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsst_write(FBIINIT1, fbiinit1);\n\tif (IS_VOODOO2(par)) {\n\t\tsst_write(FBIINIT6, fbiinit6);\n\t\tfbiinit5=sst_read(FBIINIT5) & FBIINIT5_MASK ;\n\t\tif (info->var.vmode & FB_VMODE_INTERLACED)\n\t\t\tfbiinit5 |= INTERLACE;\n\t\tif (info->var.vmode & FB_VMODE_DOUBLE)\n\t\t\tfbiinit5 |= VDOUBLESCAN;\n\t\tif (info->var.sync & FB_SYNC_HOR_HIGH_ACT)\n\t\t\tfbiinit5 |= HSYNC_HIGH;\n\t\tif (info->var.sync & FB_SYNC_VERT_HIGH_ACT)\n\t\t\tfbiinit5 |= VSYNC_HIGH;\n\t\tsst_write(FBIINIT5, fbiinit5);\n\t}\n\tsst_wait_idle();\n\tsst_unset_bits(FBIINIT1, VIDEO_RESET);\n\tsst_unset_bits(FBIINIT0, FBI_RESET | FIFO_RESET);\n\tsst_set_bits(FBIINIT2, EN_DRAM_REFRESH);\n\t \n\tpci_write_config_dword(sst_dev, PCI_INIT_ENABLE, PCI_EN_FIFO_WR);\n\n\t \n\tswitch (info->var.bits_per_pixel) {\n\tcase 16:\n\t\tlfbmode = LFB_565;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n#if defined(__BIG_ENDIAN)\n\t \n\tlfbmode |= ( LFB_WORD_SWIZZLE_WR | LFB_BYTE_SWIZZLE_WR |\n\t\t     LFB_WORD_SWIZZLE_RD | LFB_BYTE_SWIZZLE_RD );\n#endif\n\n\tif (clipping) {\n\t\tsst_write(LFBMODE, lfbmode | EN_PXL_PIPELINE);\n\t \n\t \n\t\tf_ddprintk(\"setting clipping dimensions 0..%d, 0..%d\\n\",\n\t\t            info->var.xres - 1, par->yDim - 1);\n\n\t\tsst_write(CLIP_LEFT_RIGHT, info->var.xres);\n\t\tsst_write(CLIP_LOWY_HIGHY, par->yDim);\n\t\tsst_set_bits(FBZMODE, EN_CLIPPING | EN_RGB_WRITE);\n\t} else {\n\t\t \n\t\tsst_write(LFBMODE, lfbmode);\n\t}\n\treturn 0;\n}\n\n \nstatic int sstfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n                           u_int transp, struct fb_info *info)\n{\n\tstruct sstfb_par *par = info->par;\n\tu32 col;\n\n\tf_dddprintk(\"sstfb_setcolreg\\n\");\n\tf_dddprintk(\"%-2d rgbt: %#x, %#x, %#x, %#x\\n\",\n\t            regno, red, green, blue, transp);\n\tif (regno > 15)\n\t\treturn 0;\n\n\tred    >>= (16 - info->var.red.length);\n\tgreen  >>= (16 - info->var.green.length);\n\tblue   >>= (16 - info->var.blue.length);\n\ttransp >>= (16 - info->var.transp.length);\n\tcol = (red << info->var.red.offset)\n\t    | (green << info->var.green.offset)\n\t    | (blue  << info->var.blue.offset)\n\t    | (transp << info->var.transp.offset);\n\n\tpar->palette[regno] = col;\n\n\treturn 0;\n}\n\nstatic void sstfb_setvgapass( struct fb_info *info, int enable )\n{\n\tstruct sstfb_par *par = info->par;\n\tstruct pci_dev *sst_dev = par->dev;\n\tu32 fbiinit0, tmp;\n\n\tenable = enable ? 1:0;\n\tif (par->vgapass == enable)\n\t\treturn;\n\tpar->vgapass = enable;\n\n\tpci_read_config_dword(sst_dev, PCI_INIT_ENABLE, &tmp);\n\tpci_write_config_dword(sst_dev, PCI_INIT_ENABLE,\n\t\t\t       tmp | PCI_EN_INIT_WR );\n\tfbiinit0 = sst_read (FBIINIT0);\n\tif (par->vgapass) {\n\t\tsst_write(FBIINIT0, fbiinit0 & ~DIS_VGA_PASSTHROUGH);\n\t\tfb_info(info, \"Enabling VGA pass-through\\n\");\n\t} else {\n\t\tsst_write(FBIINIT0, fbiinit0 | DIS_VGA_PASSTHROUGH);\n\t\tfb_info(info, \"Disabling VGA pass-through\\n\");\n\t}\n\tpci_write_config_dword(sst_dev, PCI_INIT_ENABLE, tmp);\n}\n\nstatic ssize_t store_vgapass(struct device *device, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct fb_info *info = dev_get_drvdata(device);\n\tchar ** last = NULL;\n\tint val;\n\n\tval = simple_strtoul(buf, last, 0);\n\tsstfb_setvgapass(info, val);\n\n\treturn count;\n}\n\nstatic ssize_t show_vgapass(struct device *device, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct fb_info *info = dev_get_drvdata(device);\n\tstruct sstfb_par *par = info->par;\n\treturn sprintf(buf, \"%d\\n\", par->vgapass);\n}\n\nstatic struct device_attribute device_attrs[] = {\n\t__ATTR(vgapass, S_IRUGO|S_IWUSR, show_vgapass, store_vgapass)\n\t};\n\nstatic int sstfb_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct sstfb_par *par;\n\tu32 val;\n\n\tswitch (cmd) {\n\t \n\tcase SSTFB_SET_VGAPASS:\n\t\tif (copy_from_user(&val, (void __user *)arg, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tsstfb_setvgapass(info, val);\n\t\treturn 0;\n\tcase SSTFB_GET_VGAPASS:\n\t\tpar = info->par;\n\t\tval = par->vgapass;\n\t\tif (copy_to_user((void __user *)arg, &val, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n\n \n#if 0\nstatic void sstfb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tstruct sstfb_par *par = info->par;\n\tu32 stride = info->fix.line_length;\n\n\tif (!IS_VOODOO2(par))\n\t\treturn;\n\n\tsst_write(BLTSRCBASEADDR, 0);\n\tsst_write(BLTDSTBASEADDR, 0);\n\tsst_write(BLTROP, BLTROP_COPY);\n\tsst_write(BLTXYSTRIDES, stride | (stride << 16));\n\tsst_write(BLTSRCXY, area->sx | (area->sy << 16));\n\tsst_write(BLTDSTXY, area->dx | (area->dy << 16));\n\tsst_write(BLTSIZE, area->width | (area->height << 16));\n\tsst_write(BLTCOMMAND, BLT_SCR2SCR_BITBLT | LAUNCH_BITBLT |\n\t\t(BLT_16BPP_FMT << 3)   | BIT(15) );\n\tsst_wait_idle();\n}\n#endif\n\n\n \n#if 0\nstatic void sstfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct sstfb_par *par = info->par;\n\tu32 stride = info->fix.line_length;\n\n\tif (!IS_VOODOO2(par))\n\t\treturn;\n\n\tsst_write(BLTCLIPX, info->var.xres);\n\tsst_write(BLTCLIPY, info->var.yres);\n\n\tsst_write(BLTDSTBASEADDR, 0);\n\tsst_write(BLTCOLOR, rect->color);\n\tsst_write(BLTROP, rect->rop == ROP_COPY ? BLTROP_COPY : BLTROP_XOR);\n\tsst_write(BLTXYSTRIDES, stride | (stride << 16));\n\tsst_write(BLTDSTXY, rect->dx | (rect->dy << 16));\n\tsst_write(BLTSIZE, rect->width | (rect->height << 16));\n\tsst_write(BLTCOMMAND, BLT_RECFILL_BITBLT | LAUNCH_BITBLT\n\t\t | (BLT_16BPP_FMT << 3)   | BIT(15) | BIT(16) );\n\tsst_wait_idle();\n}\n#endif\n\n\n\n \nstatic int sst_get_memsize(struct fb_info *info, __u32 *memsize)\n{\n\tu8 __iomem *fbbase_virt = info->screen_base;\n\n\t \n\tif (mem >= 1  && mem <= 4) {\n\t\t*memsize = (mem * 0x100000);\n\t\tprintk(KERN_INFO \"supplied memsize: %#x\\n\", *memsize);\n\t\treturn 1;\n\t}\n\n\twritel(0xdeadbeef, fbbase_virt);\n\twritel(0xdeadbeef, fbbase_virt+0x100000);\n\twritel(0xdeadbeef, fbbase_virt+0x200000);\n\tf_ddprintk(\"0MB: %#x, 1MB: %#x, 2MB: %#x\\n\",\n\t           readl(fbbase_virt), readl(fbbase_virt + 0x100000),\n\t           readl(fbbase_virt + 0x200000));\n\n\twritel(0xabcdef01, fbbase_virt);\n\n\tf_ddprintk(\"0MB: %#x, 1MB: %#x, 2MB: %#x\\n\",\n\t           readl(fbbase_virt), readl(fbbase_virt + 0x100000),\n\t           readl(fbbase_virt + 0x200000));\n\n\t \n\tif (readl(fbbase_virt + 0x200000) == 0xdeadbeef)\n\t\t*memsize = 0x400000;\n\telse if (readl(fbbase_virt + 0x100000) == 0xdeadbeef)\n\t\t*memsize = 0x200000;\n\telse\n\t\t*memsize = 0x100000;\n\tf_ddprintk(\"detected memsize: %dMB\\n\", *memsize >> 20);\n\treturn 1;\n}\n\n\n \n\n \n \n\nstatic int sst_detect_att(struct fb_info *info)\n{\n\tstruct sstfb_par *par = info->par;\n\tint i, mir, dir;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tsst_dac_write(DACREG_WMA, 0); \t \n\t\tsst_dac_read(DACREG_RMR);\t \n\t\tsst_dac_read(DACREG_RMR);\n\t\tsst_dac_read(DACREG_RMR);\n\t\tsst_dac_read(DACREG_RMR);\n\t\t \n\t\tsst_dac_read(DACREG_RMR);\n\t\t \n\t\tmir = sst_dac_read(DACREG_RMR);\n\t\t \n\t\tdir = sst_dac_read(DACREG_RMR);\n\t\tf_ddprintk(\"mir: %#x, dir: %#x\\n\", mir, dir);\n\t\tif (mir == DACREG_MIR_ATT && dir == DACREG_DIR_ATT) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sst_detect_ti(struct fb_info *info)\n{\n\tstruct sstfb_par *par = info->par;\n\tint i, mir, dir;\n\n\tfor (i = 0; i<3; i++) {\n\t\tsst_dac_write(DACREG_WMA, 0); \t \n\t\tsst_dac_read(DACREG_RMR);\t \n\t\tsst_dac_read(DACREG_RMR);\n\t\tsst_dac_read(DACREG_RMR);\n\t\tsst_dac_read(DACREG_RMR);\n\t\t \n\t\tsst_dac_read(DACREG_RMR);\n\t\t \n\t\tmir = sst_dac_read(DACREG_RMR);\n\t\t \n\t\tdir = sst_dac_read(DACREG_RMR);\n\t\tf_ddprintk(\"mir: %#x, dir: %#x\\n\", mir, dir);\n\t\tif ((mir == DACREG_MIR_TI ) && (dir == DACREG_DIR_TI)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int sst_detect_ics(struct fb_info *info)\n{\n\tstruct sstfb_par *par = info->par;\n\tint m_clk0_1, m_clk0_7, m_clk1_b;\n\tint n_clk0_1, n_clk0_7, n_clk1_b;\n\tint i;\n\n\tfor (i = 0; i<5; i++ ) {\n\t\tsst_dac_write(DACREG_ICS_PLLRMA, 0x1);\t \n\t\tm_clk0_1 = sst_dac_read(DACREG_ICS_PLLDATA);\n\t\tn_clk0_1 = sst_dac_read(DACREG_ICS_PLLDATA);\n\t\tsst_dac_write(DACREG_ICS_PLLRMA, 0x7);\t \n\t\tm_clk0_7 = sst_dac_read(DACREG_ICS_PLLDATA);\n\t\tn_clk0_7 = sst_dac_read(DACREG_ICS_PLLDATA);\n\t\tsst_dac_write(DACREG_ICS_PLLRMA, 0xb);\t \n\t\tm_clk1_b= sst_dac_read(DACREG_ICS_PLLDATA);\n\t\tn_clk1_b= sst_dac_read(DACREG_ICS_PLLDATA);\n\t\tf_ddprintk(\"m_clk0_1: %#x, m_clk0_7: %#x, m_clk1_b: %#x\\n\",\n\t\t\tm_clk0_1, m_clk0_7, m_clk1_b);\n\t\tf_ddprintk(\"n_clk0_1: %#x, n_clk0_7: %#x, n_clk1_b: %#x\\n\",\n\t\t\tn_clk0_1, n_clk0_7, n_clk1_b);\n\t\tif ((   m_clk0_1 == DACREG_ICS_PLL_CLK0_1_INI)\n\t\t    && (m_clk0_7 == DACREG_ICS_PLL_CLK0_7_INI)\n\t\t    && (m_clk1_b == DACREG_ICS_PLL_CLK1_B_INI)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \n\nstatic int sst_set_pll_att_ti(struct fb_info *info,\n\t\tconst struct pll_timing *t, const int clock)\n{\n\tstruct sstfb_par *par = info->par;\n\tu8 cr0, cc;\n\n\t \n\tsst_dac_write(DACREG_WMA, 0); \t \n\tsst_dac_read(DACREG_RMR);\t \n\tsst_dac_read(DACREG_RMR);\t \n\tsst_dac_read(DACREG_RMR);\t \n\tsst_dac_read(DACREG_RMR);\t \n\tcr0 = sst_dac_read(DACREG_RMR);\t \n\n\tsst_dac_write(DACREG_WMA, 0);\n\tsst_dac_read(DACREG_RMR);\n\tsst_dac_read(DACREG_RMR);\n\tsst_dac_read(DACREG_RMR);\n\tsst_dac_read(DACREG_RMR);\n\tsst_dac_write(DACREG_RMR, (cr0 & 0xf0)\n\t              | DACREG_CR0_EN_INDEXED\n\t              | DACREG_CR0_8BIT\n\t              | DACREG_CR0_PWDOWN );\n\t \n\n\tudelay(300);\n\tcc = dac_i_read(DACREG_CC_I);\n\tswitch (clock) {\n\tcase VID_CLOCK:\n\t\tdac_i_write(DACREG_AC0_I, t->m);\n\t\tdac_i_write(DACREG_AC1_I, t->p << 6 | t->n);\n\t\tdac_i_write(DACREG_CC_I,\n\t\t            (cc & 0x0f) | DACREG_CC_CLKA | DACREG_CC_CLKA_C);\n\t\tbreak;\n\tcase GFX_CLOCK:\n\t\tdac_i_write(DACREG_BD0_I, t->m);\n\t\tdac_i_write(DACREG_BD1_I, t->p << 6 | t->n);\n\t\tdac_i_write(DACREG_CC_I,\n\t\t            (cc & 0xf0) | DACREG_CC_CLKB | DACREG_CC_CLKB_D);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: wrong clock code '%d'\\n\",\n\t\t        __func__, clock);\n\t\treturn 0;\n\t\t}\n\tudelay(300);\n\n\t \n\tdac_i_write(DACREG_CR0_I,\n\t            cr0 & ~DACREG_CR0_PWDOWN & ~DACREG_CR0_EN_INDEXED);\n\treturn 1;\n}\n\nstatic int sst_set_pll_ics(struct fb_info *info,\n\t\tconst struct pll_timing *t, const int clock)\n{\n\tstruct sstfb_par *par = info->par;\n\tu8 pll_ctrl;\n\n\tsst_dac_write(DACREG_ICS_PLLRMA, DACREG_ICS_PLL_CTRL);\n\tpll_ctrl = sst_dac_read(DACREG_ICS_PLLDATA);\n\tswitch(clock) {\n\tcase VID_CLOCK:\n\t\tsst_dac_write(DACREG_ICS_PLLWMA, 0x0);\t \n\t\tsst_dac_write(DACREG_ICS_PLLDATA, t->m);\n\t\tsst_dac_write(DACREG_ICS_PLLDATA, t->p << 5 | t->n);\n\t\t \n\t\tsst_dac_write(DACREG_ICS_PLLWMA, DACREG_ICS_PLL_CTRL);\n\t\tsst_dac_write(DACREG_ICS_PLLDATA,\n\t\t              (pll_ctrl & 0xd8)\n\t\t              | DACREG_ICS_CLK0\n\t\t              | DACREG_ICS_CLK0_0);\n\t\tbreak;\n\tcase GFX_CLOCK :\n\t\tsst_dac_write(DACREG_ICS_PLLWMA, 0xa);\t \n\t\tsst_dac_write(DACREG_ICS_PLLDATA, t->m);\n\t\tsst_dac_write(DACREG_ICS_PLLDATA, t->p << 5 | t->n);\n\t\t \n\t\tsst_dac_write(DACREG_ICS_PLLWMA, DACREG_ICS_PLL_CTRL);\n\t\tsst_dac_write(DACREG_ICS_PLLDATA,\n\t\t              (pll_ctrl & 0xef) | DACREG_ICS_CLK1_A);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: wrong clock code '%d'\\n\",\n\t\t        __func__, clock);\n\t\treturn 0;\n\t\t}\n\tudelay(300);\n\treturn 1;\n}\n\nstatic void sst_set_vidmod_att_ti(struct fb_info *info, const int bpp)\n{\n\tstruct sstfb_par *par = info->par;\n\tu8 cr0;\n\n\tsst_dac_write(DACREG_WMA, 0); \t \n\tsst_dac_read(DACREG_RMR);\t \n\tsst_dac_read(DACREG_RMR);\n\tsst_dac_read(DACREG_RMR);\n\tsst_dac_read(DACREG_RMR);\n\t \n\tcr0 = sst_dac_read(DACREG_RMR);\n\n\tsst_dac_write(DACREG_WMA, 0); \t \n\tsst_dac_read(DACREG_RMR);\t \n\tsst_dac_read(DACREG_RMR);\n\tsst_dac_read(DACREG_RMR);\n\tsst_dac_read(DACREG_RMR);\n\t \n\tswitch(bpp) {\n\tcase 16:\n\t\tsst_dac_write(DACREG_RMR, (cr0 & 0x0f) | DACREG_CR0_16BPP);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: bad depth '%u'\\n\", __func__, bpp);\n\t\tbreak;\n\t}\n}\n\nstatic void sst_set_vidmod_ics(struct fb_info *info, const int bpp)\n{\n\tstruct sstfb_par *par = info->par;\n\n\tswitch(bpp) {\n\tcase 16:\n\t\tsst_dac_write(DACREG_ICS_CMD, DACREG_ICS_CMD_16BPP);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: bad depth '%u'\\n\", __func__, bpp);\n\t\tbreak;\n\t}\n}\n\n \n\n\nstatic struct dac_switch dacs[] = {\n\t{\t.name\t\t= \"TI TVP3409\",\n\t\t.detect\t\t= sst_detect_ti,\n\t\t.set_pll\t= sst_set_pll_att_ti,\n\t\t.set_vidmod\t= sst_set_vidmod_att_ti },\n\n\t{\t.name\t\t= \"AT&T ATT20C409\",\n\t\t.detect\t\t= sst_detect_att,\n\t\t.set_pll\t= sst_set_pll_att_ti,\n\t\t.set_vidmod\t= sst_set_vidmod_att_ti },\n\t{\t.name\t\t= \"ICS ICS5342\",\n\t\t.detect\t\t= sst_detect_ics,\n\t\t.set_pll\t= sst_set_pll_ics,\n\t\t.set_vidmod\t= sst_set_vidmod_ics },\n};\n\nstatic int sst_detect_dactype(struct fb_info *info, struct sstfb_par *par)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(dacs); i++) {\n\t\tret = dacs[i].detect(info);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tif (!ret)\n\t\treturn 0;\n\tf_dprintk(\"%s found %s\\n\", __func__, dacs[i].name);\n\tpar->dac_sw = dacs[i];\n\treturn 1;\n}\n\n \nstatic int sst_init(struct fb_info *info, struct sstfb_par *par)\n{\n\tu32 fbiinit0, fbiinit1, fbiinit4;\n\tstruct pci_dev *dev = par->dev;\n\tstruct pll_timing gfx_timings;\n\tstruct sst_spec *spec;\n\tint Fout;\n\tint gfx_clock;\n\n\tspec = &voodoo_spec[par->type];\n\tf_ddprintk(\" fbiinit0   fbiinit1   fbiinit2   fbiinit3   fbiinit4  \"\n\t           \" fbiinit6\\n\");\n\tf_ddprintk(\"%0#10x %0#10x %0#10x %0#10x %0#10x %0#10x\\n\",\n\t            sst_read(FBIINIT0), sst_read(FBIINIT1), sst_read(FBIINIT2),\n\t            sst_read(FBIINIT3), sst_read(FBIINIT4), sst_read(FBIINIT6));\n\t \n\tpci_write_config_dword(dev, PCI_VCLK_DISABLE, 0);\n\n\t \n\tpci_write_config_dword(dev, PCI_INIT_ENABLE, PCI_EN_INIT_WR);\n\t \n\tsst_set_bits(FBIINIT1, VIDEO_RESET);\n\tsst_wait_idle();\n\t \n\tsst_set_bits(FBIINIT0, FBI_RESET | FIFO_RESET);\n\tsst_wait_idle();\n\n\t \n\t \n\t \n\t \n\n\t \n\tsst_unset_bits(FBIINIT2, EN_DRAM_REFRESH);\n\tsst_wait_idle();\n\t \n\tpci_write_config_dword(dev, PCI_INIT_ENABLE,\n\t\t\t\tPCI_EN_INIT_WR | PCI_REMAP_DAC );\n\t \n\tif (!sst_detect_dactype(info, par)) {\n\t\tprintk(KERN_ERR \"sstfb: unknown dac type.\\n\");\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tgfx_clock = spec->default_gfx_clock;\n\tif ((gfxclk >10 ) && (gfxclk < spec->max_gfxclk)) {\n\t\tprintk(KERN_INFO \"sstfb: Using supplied graphic freq : %dMHz\\n\", gfxclk);\n\t\t gfx_clock = gfxclk *1000;\n\t} else if (gfxclk) {\n\t\tprintk(KERN_WARNING \"sstfb: %dMhz is way out of spec! Using default\\n\", gfxclk);\n\t}\n\n\tsst_calc_pll(gfx_clock, &Fout, &gfx_timings);\n\tpar->dac_sw.set_pll(info, &gfx_timings, GFX_CLOCK);\n\n\t \n\tpci_write_config_dword(dev, PCI_INIT_ENABLE,\n\t                       PCI_EN_INIT_WR| PCI_EN_FIFO_WR );\n\t \n\t \n\tfbiinit0 = FBIINIT0_DEFAULT;\n\tfbiinit1 = FBIINIT1_DEFAULT;\n\tfbiinit4 = FBIINIT4_DEFAULT;\n\tpar->vgapass = vgapass;\n\tif (par->vgapass)\n\t\tfbiinit0 &= ~DIS_VGA_PASSTHROUGH;\n\telse\n\t\tfbiinit0 |= DIS_VGA_PASSTHROUGH;\n\tif (slowpci) {\n\t\tfbiinit1 |= SLOW_PCI_WRITES;\n\t\tfbiinit4 |= SLOW_PCI_READS;\n\t} else {\n\t\tfbiinit1 &= ~SLOW_PCI_WRITES;\n\t\tfbiinit4 &= ~SLOW_PCI_READS;\n\t}\n\tsst_write(FBIINIT0, fbiinit0);\n\tsst_wait_idle();\n\tsst_write(FBIINIT1, fbiinit1);\n\tsst_wait_idle();\n\tsst_write(FBIINIT2, FBIINIT2_DEFAULT);\n\tsst_wait_idle();\n\tsst_write(FBIINIT3, FBIINIT3_DEFAULT);\n\tsst_wait_idle();\n\tsst_write(FBIINIT4, fbiinit4);\n\tsst_wait_idle();\n\tif (IS_VOODOO2(par)) {\n\t\tsst_write(FBIINIT6, FBIINIT6_DEFAULT);\n\t\tsst_wait_idle();\n\t}\n\n\tpci_write_config_dword(dev, PCI_INIT_ENABLE, PCI_EN_FIFO_WR);\n\tpci_write_config_dword(dev, PCI_VCLK_ENABLE, 0);\n\treturn 1;\n}\n\nstatic void sst_shutdown(struct fb_info *info)\n{\n\tstruct sstfb_par *par = info->par;\n\tstruct pci_dev *dev = par->dev;\n\tstruct pll_timing gfx_timings;\n\tint Fout;\n\n\t \n\tpci_write_config_dword(dev, PCI_INIT_ENABLE, PCI_EN_INIT_WR);\n\tsst_set_bits(FBIINIT1, VIDEO_RESET | EN_BLANKING);\n\tsst_unset_bits(FBIINIT2, EN_DRAM_REFRESH);\n\tsst_set_bits(FBIINIT0, FBI_RESET | FIFO_RESET);\n\tsst_wait_idle();\n\tpci_write_config_dword(dev, PCI_INIT_ENABLE,\n\t                       PCI_EN_INIT_WR | PCI_REMAP_DAC);\n\t \n\tsst_calc_pll(20000, &Fout, &gfx_timings);\n\tpar->dac_sw.set_pll(info, &gfx_timings, GFX_CLOCK);\n\t \n\tpci_write_config_dword(dev, PCI_INIT_ENABLE,\n\t                       PCI_EN_INIT_WR);\n\tsst_unset_bits(FBIINIT0, FBI_RESET | FIFO_RESET | DIS_VGA_PASSTHROUGH);\n\tpci_write_config_dword(dev, PCI_VCLK_DISABLE,0);\n\t \n\tpci_write_config_dword(dev, PCI_INIT_ENABLE, 0);\n\n}\n\n \nstatic int sstfb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt) continue;\n\n\t\tf_ddprintk(\"option %s\\n\", this_opt);\n\n\t\tif (!strcmp(this_opt, \"vganopass\"))\n\t\t\tvgapass = 0;\n\t\telse if (!strcmp(this_opt, \"vgapass\"))\n\t\t\tvgapass = 1;\n\t\telse if (!strcmp(this_opt, \"clipping\"))\n\t\t        clipping = 1;\n\t\telse if (!strcmp(this_opt, \"noclipping\"))\n\t\t        clipping = 0;\n\t\telse if (!strcmp(this_opt, \"fastpci\"))\n\t\t        slowpci = 0;\n\t\telse if (!strcmp(this_opt, \"slowpci\"))\n\t\t        slowpci = 1;\n\t\telse if (!strncmp(this_opt, \"mem:\",4))\n\t\t\tmem = simple_strtoul (this_opt+4, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"gfxclk:\",7))\n\t\t\tgfxclk = simple_strtoul (this_opt+7, NULL, 0);\n\t\telse\n\t\t\tmode_option = this_opt;\n\t}\n\treturn 0;\n}\n\n\nstatic const struct fb_ops sstfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= sstfb_check_var,\n\t.fb_set_par\t= sstfb_set_par,\n\t.fb_setcolreg\t= sstfb_setcolreg,\n\t.fb_ioctl\t= sstfb_ioctl,\n};\n\nstatic int sstfb_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct fb_info *info;\n\tstruct fb_fix_screeninfo *fix;\n\tstruct sstfb_par *par;\n\tstruct sst_spec *spec;\n\tint err;\n\n\terr = aperture_remove_conflicting_pci_devices(pdev, \"sstfb\");\n\tif (err)\n\t\treturn err;\n\n\t \n\tif ((err=pci_enable_device(pdev))) {\n\t\tprintk(KERN_ERR \"cannot enable device\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tinfo = framebuffer_alloc(sizeof(struct sstfb_par), &pdev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pdev, info);\n\n\tpar  = info->par;\n\tfix  = &info->fix;\n\n\tpar->type = id->driver_data;\n\tspec = &voodoo_spec[par->type];\n\tf_ddprintk(\"found device : %s\\n\", spec->name);\n\n\tpar->dev = pdev;\n\tpar->revision = pdev->revision;\n\n\tfix->mmio_start = pci_resource_start(pdev,0);\n\tfix->mmio_len\t= 0x400000;\n\tfix->smem_start = fix->mmio_start + 0x400000;\n\n\tif (!request_mem_region(fix->mmio_start, fix->mmio_len, \"sstfb MMIO\")) {\n\t\tprintk(KERN_ERR \"sstfb: cannot reserve mmio memory\\n\");\n\t\tgoto fail_mmio_mem;\n\t}\n\n\tif (!request_mem_region(fix->smem_start, 0x400000,\"sstfb FB\")) {\n\t\tprintk(KERN_ERR \"sstfb: cannot reserve fb memory\\n\");\n\t\tgoto fail_fb_mem;\n\t}\n\n\tpar->mmio_vbase = ioremap(fix->mmio_start,\n\t\t\t\t\tfix->mmio_len);\n\tif (!par->mmio_vbase) {\n\t\tprintk(KERN_ERR \"sstfb: cannot remap register area %#lx\\n\",\n\t\t        fix->mmio_start);\n\t\tgoto fail_mmio_remap;\n\t}\n\tinfo->screen_base = ioremap(fix->smem_start, 0x400000);\n\tif (!info->screen_base) {\n\t\tprintk(KERN_ERR \"sstfb: cannot remap framebuffer %#lx\\n\",\n\t\t        fix->smem_start);\n\t\tgoto fail_fb_remap;\n\t}\n\n\tif (!sst_init(info, par)) {\n\t\tprintk(KERN_ERR \"sstfb: Init failed\\n\");\n\t\tgoto fail;\n\t}\n\tsst_get_memsize(info, &fix->smem_len);\n\tstrscpy(fix->id, spec->name, sizeof(fix->id));\n\n\tprintk(KERN_INFO \"%s (revision %d) with %s dac\\n\",\n\t\tfix->id, par->revision, par->dac_sw.name);\n\tprintk(KERN_INFO \"framebuffer at %#lx, mapped to 0x%p, size %dMB\\n\",\n\t        fix->smem_start, info->screen_base,\n\t        fix->smem_len >> 20);\n\n\tf_ddprintk(\"regbase_virt: %p\\n\", par->mmio_vbase);\n\tf_ddprintk(\"membase_phys: %#lx\\n\", fix->smem_start);\n\tf_ddprintk(\"fbbase_virt: %p\\n\", info->screen_base);\n\n\tinfo->fbops\t= &sstfb_ops;\n\tinfo->pseudo_palette = par->palette;\n\n\tfix->type\t= FB_TYPE_PACKED_PIXELS;\n\tfix->visual\t= FB_VISUAL_TRUECOLOR;\n\tfix->accel\t= FB_ACCEL_NONE;   \n\t \n\tfix->line_length = 2048;  \n\n\tfb_find_mode(&info->var, info, mode_option, NULL, 0, NULL, 16);\n\n\tif (sstfb_check_var(&info->var, info)) {\n\t\tprintk(KERN_ERR \"sstfb: invalid video mode.\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (sstfb_set_par(info)) {\n\t\tprintk(KERN_ERR \"sstfb: can't set default video mode.\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0)) {\n\t\tprintk(KERN_ERR \"sstfb: can't alloc cmap memory.\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tinfo->device = &pdev->dev;\n\tif (register_framebuffer(info) < 0) {\n\t\tprintk(KERN_ERR \"sstfb: can't register framebuffer.\\n\");\n\t\tgoto fail_register;\n\t}\n\n\tsstfb_clear_screen(info);\n\n\tif (device_create_file(info->dev, &device_attrs[0]))\n\t\tprintk(KERN_WARNING \"sstfb: can't create sysfs entry.\\n\");\n\n\n\tfb_info(info, \"%s frame buffer device at 0x%p\\n\",\n\t\tfix->id, info->screen_base);\n\n\treturn 0;\n\nfail_register:\n\tfb_dealloc_cmap(&info->cmap);\nfail:\n\tiounmap(info->screen_base);\nfail_fb_remap:\n\tiounmap(par->mmio_vbase);\nfail_mmio_remap:\n\trelease_mem_region(fix->smem_start, 0x400000);\nfail_fb_mem:\n\trelease_mem_region(fix->mmio_start, info->fix.mmio_len);\nfail_mmio_mem:\n\tframebuffer_release(info);\n\treturn -ENXIO; \t \n}\n\nstatic void sstfb_remove(struct pci_dev *pdev)\n{\n\tstruct sstfb_par *par;\n\tstruct fb_info *info;\n\n\tinfo = pci_get_drvdata(pdev);\n\tpar = info->par;\n\n\tdevice_remove_file(info->dev, &device_attrs[0]);\n\tsst_shutdown(info);\n\tiounmap(info->screen_base);\n\tiounmap(par->mmio_vbase);\n\trelease_mem_region(info->fix.smem_start, 0x400000);\n\trelease_mem_region(info->fix.mmio_start, info->fix.mmio_len);\n\tfb_dealloc_cmap(&info->cmap);\n\tunregister_framebuffer(info);\n\tframebuffer_release(info);\n}\n\n\nstatic const struct pci_device_id sstfb_id_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_3DFX, PCI_DEVICE_ID_3DFX_VOODOO ),\n\t\t.driver_data = ID_VOODOO1, },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_3DFX, PCI_DEVICE_ID_3DFX_VOODOO2),\n\t\t.driver_data = ID_VOODOO2, },\n\t{ 0 },\n};\n\nstatic struct pci_driver sstfb_driver = {\n\t.name\t\t= \"sstfb\",\n\t.id_table\t= sstfb_id_tbl,\n\t.probe\t\t= sstfb_probe,\n\t.remove\t\t= sstfb_remove,\n};\n\n\nstatic int sstfb_init(void)\n{\n\tchar *option = NULL;\n\n\tif (fb_modesetting_disabled(\"sstfb\"))\n\t\treturn -ENODEV;\n\n\tif (fb_get_options(\"sstfb\", &option))\n\t\treturn -ENODEV;\n\tsstfb_setup(option);\n\n\treturn pci_register_driver(&sstfb_driver);\n}\n\nstatic void sstfb_exit(void)\n{\n\tpci_unregister_driver(&sstfb_driver);\n}\n\n\nmodule_init(sstfb_init);\nmodule_exit(sstfb_exit);\n\nMODULE_AUTHOR(\"(c) 2000,2002 Ghozlane Toumi <gtoumi@laposte.net>\");\nMODULE_DESCRIPTION(\"FBDev driver for 3dfx Voodoo Graphics and Voodoo2 based video boards\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(mem, int, 0);\nMODULE_PARM_DESC(mem, \"Size of frame buffer memory in MB (1, 2, 4 MB, default=autodetect)\");\nmodule_param(vgapass, bool, 0);\nMODULE_PARM_DESC(vgapass, \"Enable VGA PassThrough mode (0 or 1) (default=0)\");\nmodule_param(clipping, bool, 0);\nMODULE_PARM_DESC(clipping, \"Enable clipping (slower, safer) (0 or 1) (default=1)\");\nmodule_param(gfxclk, int, 0);\nMODULE_PARM_DESC(gfxclk, \"Force graphic chip frequency in MHz. DANGEROUS. (default=auto)\");\nmodule_param(slowpci, bool, 0);\nMODULE_PARM_DESC(slowpci, \"Uses slow PCI settings (0 or 1) (default=0)\");\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Initial video mode (default=\" DEFAULT_VIDEO_MODE \")\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}