{
  "module_name": "pmag-ba-fb.c",
  "hash_id": "538a648d3d3076ff38ab747f15e6c36c8f21030b3d4569d6404da3587a6cd839",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/pmag-ba-fb.c",
  "human_readable_source": " \n\n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/tc.h>\n#include <linux/types.h>\n\n#include <asm/io.h>\n\n#include <video/pmag-ba-fb.h>\n\n\nstruct pmagbafb_par {\n\tvolatile void __iomem *mmio;\n\tvolatile u32 __iomem *dac;\n};\n\n\nstatic const struct fb_var_screeninfo pmagbafb_defined = {\n\t.xres\t\t= 1024,\n\t.yres\t\t= 864,\n\t.xres_virtual\t= 1024,\n\t.yres_virtual\t= 864,\n\t.bits_per_pixel\t= 8,\n\t.red.length\t= 8,\n\t.green.length\t= 8,\n\t.blue.length\t= 8,\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.accel_flags\t= FB_ACCEL_NONE,\n\t.pixclock\t= 14452,\n\t.left_margin\t= 116,\n\t.right_margin\t= 12,\n\t.upper_margin\t= 34,\n\t.lower_margin\t= 0,\n\t.hsync_len\t= 128,\n\t.vsync_len\t= 3,\n\t.sync\t\t= FB_SYNC_ON_GREEN,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\nstatic const struct fb_fix_screeninfo pmagbafb_fix = {\n\t.id\t\t= \"PMAG-BA\",\n\t.smem_len\t= (1024 * 1024),\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.visual\t\t= FB_VISUAL_PSEUDOCOLOR,\n\t.line_length\t= 1024,\n\t.mmio_len\t= PMAG_BA_SIZE - PMAG_BA_BT459,\n};\n\n\nstatic inline void dac_write(struct pmagbafb_par *par, unsigned int reg, u8 v)\n{\n\twriteb(v, par->dac + reg / 4);\n}\n\nstatic inline u8 dac_read(struct pmagbafb_par *par, unsigned int reg)\n{\n\treturn readb(par->dac + reg / 4);\n}\n\n\n \nstatic int pmagbafb_setcolreg(unsigned int regno, unsigned int red,\n\t\t\t      unsigned int green, unsigned int blue,\n\t\t\t      unsigned int transp, struct fb_info *info)\n{\n\tstruct pmagbafb_par *par = info->par;\n\n\tif (regno >= info->cmap.len)\n\t\treturn 1;\n\n\tred   >>= 8;\t \n\tgreen >>= 8;\t \n\tblue  >>= 8;\t \n\n\tmb();\n\tdac_write(par, BT459_ADDR_LO, regno);\n\tdac_write(par, BT459_ADDR_HI, 0x00);\n\twmb();\n\tdac_write(par, BT459_CMAP, red);\n\twmb();\n\tdac_write(par, BT459_CMAP, green);\n\twmb();\n\tdac_write(par, BT459_CMAP, blue);\n\n\treturn 0;\n}\n\nstatic const struct fb_ops pmagbafb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_setcolreg\t= pmagbafb_setcolreg,\n};\n\n\n \nstatic void pmagbafb_erase_cursor(struct fb_info *info)\n{\n\tstruct pmagbafb_par *par = info->par;\n\n\tmb();\n\tdac_write(par, BT459_ADDR_LO, 0x00);\n\tdac_write(par, BT459_ADDR_HI, 0x03);\n\twmb();\n\tdac_write(par, BT459_DATA, 0x00);\n}\n\n\nstatic int pmagbafb_probe(struct device *dev)\n{\n\tstruct tc_dev *tdev = to_tc_dev(dev);\n\tresource_size_t start, len;\n\tstruct fb_info *info;\n\tstruct pmagbafb_par *par;\n\tint err;\n\n\tinfo = framebuffer_alloc(sizeof(struct pmagbafb_par), dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tdev_set_drvdata(dev, info);\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\n\t\tprintk(KERN_ERR \"%s: Cannot allocate color map\\n\",\n\t\t       dev_name(dev));\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tinfo->fbops = &pmagbafb_ops;\n\tinfo->fix = pmagbafb_fix;\n\tinfo->var = pmagbafb_defined;\n\n\t \n\tstart = tdev->resource.start;\n\tlen = tdev->resource.end - start + 1;\n\tif (!request_mem_region(start, len, dev_name(dev))) {\n\t\tprintk(KERN_ERR \"%s: Cannot reserve FB region\\n\",\n\t\t       dev_name(dev));\n\t\terr = -EBUSY;\n\t\tgoto err_cmap;\n\t}\n\n\t \n\tinfo->fix.mmio_start = start;\n\tpar->mmio = ioremap(info->fix.mmio_start, info->fix.mmio_len);\n\tif (!par->mmio) {\n\t\tprintk(KERN_ERR \"%s: Cannot map MMIO\\n\", dev_name(dev));\n\t\terr = -ENOMEM;\n\t\tgoto err_resource;\n\t}\n\tpar->dac = par->mmio + PMAG_BA_BT459;\n\n\t \n\tinfo->fix.smem_start = start + PMAG_BA_FBMEM;\n\tinfo->screen_base = ioremap(info->fix.smem_start,\n\t\t\t\t\t    info->fix.smem_len);\n\tif (!info->screen_base) {\n\t\tprintk(KERN_ERR \"%s: Cannot map FB\\n\", dev_name(dev));\n\t\terr = -ENOMEM;\n\t\tgoto err_mmio_map;\n\t}\n\tinfo->screen_size = info->fix.smem_len;\n\n\tpmagbafb_erase_cursor(info);\n\n\terr = register_framebuffer(info);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"%s: Cannot register framebuffer\\n\",\n\t\t       dev_name(dev));\n\t\tgoto err_smem_map;\n\t}\n\n\tget_device(dev);\n\n\tfb_info(info, \"%s frame buffer device at %s\\n\",\n\t\tinfo->fix.id, dev_name(dev));\n\n\treturn 0;\n\n\nerr_smem_map:\n\tiounmap(info->screen_base);\n\nerr_mmio_map:\n\tiounmap(par->mmio);\n\nerr_resource:\n\trelease_mem_region(start, len);\n\nerr_cmap:\n\tfb_dealloc_cmap(&info->cmap);\n\nerr_alloc:\n\tframebuffer_release(info);\n\treturn err;\n}\n\nstatic int pmagbafb_remove(struct device *dev)\n{\n\tstruct tc_dev *tdev = to_tc_dev(dev);\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct pmagbafb_par *par = info->par;\n\tresource_size_t start, len;\n\n\tput_device(dev);\n\tunregister_framebuffer(info);\n\tiounmap(info->screen_base);\n\tiounmap(par->mmio);\n\tstart = tdev->resource.start;\n\tlen = tdev->resource.end - start + 1;\n\trelease_mem_region(start, len);\n\tfb_dealloc_cmap(&info->cmap);\n\tframebuffer_release(info);\n\treturn 0;\n}\n\n\n \nstatic const struct tc_device_id pmagbafb_tc_table[] = {\n\t{ \"DEC     \", \"PMAG-BA \" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(tc, pmagbafb_tc_table);\n\nstatic struct tc_driver pmagbafb_driver = {\n\t.id_table\t= pmagbafb_tc_table,\n\t.driver\t\t= {\n\t\t.name\t= \"pmagbafb\",\n\t\t.bus\t= &tc_bus_type,\n\t\t.probe\t= pmagbafb_probe,\n\t\t.remove\t= pmagbafb_remove,\n\t},\n};\n\nstatic int __init pmagbafb_init(void)\n{\n#ifndef MODULE\n\tif (fb_get_options(\"pmagbafb\", NULL))\n\t\treturn -ENXIO;\n#endif\n\treturn tc_register_driver(&pmagbafb_driver);\n}\n\nstatic void __exit pmagbafb_exit(void)\n{\n\ttc_unregister_driver(&pmagbafb_driver);\n}\n\n\nmodule_init(pmagbafb_init);\nmodule_exit(pmagbafb_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}