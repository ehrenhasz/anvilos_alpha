{
  "module_name": "mmpfb.c",
  "hash_id": "b168e434b64866fa0e9b60b7424249cbfb9b60d02e7c30034382961145e5dfb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/mmp/fb/mmpfb.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include \"mmpfb.h\"\n\nstatic int var_to_pixfmt(struct fb_var_screeninfo *var)\n{\n\t \n\tif (var->bits_per_pixel == 8)\n\t\treturn PIXFMT_PSEUDOCOLOR;\n\n\t \n\tif (var->bits_per_pixel == 16 && var->red.length == 8 &&\n\t\t\tvar->green.length == 4 && var->blue.length == 4) {\n\t\tif (var->green.offset >= var->blue.offset)\n\t\t\treturn PIXFMT_YUV422P;\n\t\telse\n\t\t\treturn PIXFMT_YVU422P;\n\t}\n\n\t \n\tif (var->bits_per_pixel == 12 && var->red.length == 8 &&\n\t\t\tvar->green.length == 2 && var->blue.length == 2) {\n\t\tif (var->green.offset >= var->blue.offset)\n\t\t\treturn PIXFMT_YUV420P;\n\t\telse\n\t\t\treturn PIXFMT_YVU420P;\n\t}\n\n\t \n\tif (var->bits_per_pixel == 16 && var->red.length == 16 &&\n\t\t\tvar->green.length == 16 && var->blue.length == 16) {\n\t\tif (var->red.offset == 0)\n\t\t\treturn PIXFMT_YUYV;\n\t\telse if (var->green.offset >= var->blue.offset)\n\t\t\treturn PIXFMT_UYVY;\n\t\telse\n\t\t\treturn PIXFMT_VYUY;\n\t}\n\n\t \n\tif (var->bits_per_pixel == 16 && var->red.length <= 5 &&\n\t\t\tvar->green.length <= 6 && var->blue.length <= 5) {\n\t\tif (var->transp.length == 0) {\n\t\t\tif (var->red.offset >= var->blue.offset)\n\t\t\t\treturn PIXFMT_RGB565;\n\t\t\telse\n\t\t\t\treturn PIXFMT_BGR565;\n\t\t}\n\t}\n\n\t \n\tif (var->bits_per_pixel <= 32 && var->red.length <= 8 &&\n\t\t\tvar->green.length <= 8 && var->blue.length <= 8) {\n\t\tif (var->bits_per_pixel == 24 && var->transp.length == 0) {\n\t\t\tif (var->red.offset >= var->blue.offset)\n\t\t\t\treturn PIXFMT_RGB888PACK;\n\t\t\telse\n\t\t\t\treturn PIXFMT_BGR888PACK;\n\t\t}\n\n\t\tif (var->bits_per_pixel == 32 && var->transp.offset == 24) {\n\t\t\tif (var->red.offset >= var->blue.offset)\n\t\t\t\treturn PIXFMT_RGBA888;\n\t\t\telse\n\t\t\t\treturn PIXFMT_BGRA888;\n\t\t} else {\n\t\t\tif (var->red.offset >= var->blue.offset)\n\t\t\t\treturn PIXFMT_RGB888UNPACK;\n\t\t\telse\n\t\t\t\treturn PIXFMT_BGR888UNPACK;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void pixfmt_to_var(struct fb_var_screeninfo *var, int pix_fmt)\n{\n\tswitch (pix_fmt) {\n\tcase PIXFMT_RGB565:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 11;\tvar->red.length = 5;\n\t\tvar->green.offset = 5;   var->green.length = 6;\n\t\tvar->blue.offset = 0;\tvar->blue.length = 5;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_BGR565:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 0;\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\t var->green.length = 6;\n\t\tvar->blue.offset = 11;\tvar->blue.length = 5;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_RGB888UNPACK:\n\t\tvar->bits_per_pixel = 32;\n\t\tvar->red.offset = 16;\tvar->red.length = 8;\n\t\tvar->green.offset = 8;   var->green.length = 8;\n\t\tvar->blue.offset = 0;\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_BGR888UNPACK:\n\t\tvar->bits_per_pixel = 32;\n\t\tvar->red.offset = 0;\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\t var->green.length = 8;\n\t\tvar->blue.offset = 16;\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_RGBA888:\n\t\tvar->bits_per_pixel = 32;\n\t\tvar->red.offset = 16;\tvar->red.length = 8;\n\t\tvar->green.offset = 8;   var->green.length = 8;\n\t\tvar->blue.offset = 0;\tvar->blue.length = 8;\n\t\tvar->transp.offset = 24; var->transp.length = 8;\n\t\tbreak;\n\tcase PIXFMT_BGRA888:\n\t\tvar->bits_per_pixel = 32;\n\t\tvar->red.offset = 0;\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\t var->green.length = 8;\n\t\tvar->blue.offset = 16;\tvar->blue.length = 8;\n\t\tvar->transp.offset = 24; var->transp.length = 8;\n\t\tbreak;\n\tcase PIXFMT_RGB888PACK:\n\t\tvar->bits_per_pixel = 24;\n\t\tvar->red.offset = 16;\tvar->red.length = 8;\n\t\tvar->green.offset = 8;   var->green.length = 8;\n\t\tvar->blue.offset = 0;\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_BGR888PACK:\n\t\tvar->bits_per_pixel = 24;\n\t\tvar->red.offset = 0;\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\t var->green.length = 8;\n\t\tvar->blue.offset = 16;\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_YUV420P:\n\t\tvar->bits_per_pixel = 12;\n\t\tvar->red.offset = 4;\t var->red.length = 8;\n\t\tvar->green.offset = 2;   var->green.length = 2;\n\t\tvar->blue.offset = 0;   var->blue.length = 2;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_YVU420P:\n\t\tvar->bits_per_pixel = 12;\n\t\tvar->red.offset = 4;\t var->red.length = 8;\n\t\tvar->green.offset = 0;\t var->green.length = 2;\n\t\tvar->blue.offset = 2;\tvar->blue.length = 2;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_YUV422P:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 8;\t var->red.length = 8;\n\t\tvar->green.offset = 4;   var->green.length = 4;\n\t\tvar->blue.offset = 0;   var->blue.length = 4;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_YVU422P:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 8;\t var->red.length = 8;\n\t\tvar->green.offset = 0;\t var->green.length = 4;\n\t\tvar->blue.offset = 4;\tvar->blue.length = 4;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_UYVY:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 8;\t var->red.length = 16;\n\t\tvar->green.offset = 4;   var->green.length = 16;\n\t\tvar->blue.offset = 0;   var->blue.length = 16;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_VYUY:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 8;\t var->red.length = 16;\n\t\tvar->green.offset = 0;\t var->green.length = 16;\n\t\tvar->blue.offset = 4;\tvar->blue.length = 16;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_YUYV:\n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 0;\t var->red.length = 16;\n\t\tvar->green.offset = 4;\t var->green.length = 16;\n\t\tvar->blue.offset = 8;\tvar->blue.length = 16;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\tcase PIXFMT_PSEUDOCOLOR:\n\t\tvar->bits_per_pixel = 8;\n\t\tvar->red.offset = 0;\t var->red.length = 8;\n\t\tvar->green.offset = 0;   var->green.length = 8;\n\t\tvar->blue.offset = 0;\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;  var->transp.length = 0;\n\t\tbreak;\n\t}\n}\n\n \nstatic void fbmode_to_mmpmode(struct mmp_mode *mode,\n\t\tstruct fb_videomode *videomode, int output_fmt)\n{\n\tu64 div_result = 1000000000000ll;\n\tmode->name = videomode->name;\n\tmode->refresh = videomode->refresh;\n\tmode->xres = videomode->xres;\n\tmode->yres = videomode->yres;\n\n\tdo_div(div_result, videomode->pixclock);\n\tmode->pixclock_freq = (u32)div_result;\n\n\tmode->left_margin = videomode->left_margin;\n\tmode->right_margin = videomode->right_margin;\n\tmode->upper_margin = videomode->upper_margin;\n\tmode->lower_margin = videomode->lower_margin;\n\tmode->hsync_len = videomode->hsync_len;\n\tmode->vsync_len = videomode->vsync_len;\n\tmode->hsync_invert = !!(videomode->sync & FB_SYNC_HOR_HIGH_ACT);\n\tmode->vsync_invert = !!(videomode->sync & FB_SYNC_VERT_HIGH_ACT);\n\t \n\tmode->invert_pixclock = !!(videomode->vmode & 8);\n\tmode->pix_fmt_out = output_fmt;\n}\n\nstatic void mmpmode_to_fbmode(struct fb_videomode *videomode,\n\t\tstruct mmp_mode *mode)\n{\n\tu64 div_result = 1000000000000ll;\n\n\tvideomode->name = mode->name;\n\tvideomode->refresh = mode->refresh;\n\tvideomode->xres = mode->xres;\n\tvideomode->yres = mode->yres;\n\n\tdo_div(div_result, mode->pixclock_freq);\n\tvideomode->pixclock = (u32)div_result;\n\n\tvideomode->left_margin = mode->left_margin;\n\tvideomode->right_margin = mode->right_margin;\n\tvideomode->upper_margin = mode->upper_margin;\n\tvideomode->lower_margin = mode->lower_margin;\n\tvideomode->hsync_len = mode->hsync_len;\n\tvideomode->vsync_len = mode->vsync_len;\n\tvideomode->sync = (mode->hsync_invert ? FB_SYNC_HOR_HIGH_ACT : 0)\n\t\t| (mode->vsync_invert ? FB_SYNC_VERT_HIGH_ACT : 0);\n\tvideomode->vmode = mode->invert_pixclock ? 8 : 0;\n}\n\nstatic int mmpfb_check_var(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info)\n{\n\tstruct mmpfb_info *fbi = info->par;\n\n\tif (var->bits_per_pixel == 8)\n\t\treturn -EINVAL;\n\t \n\tif (var->xoffset + var->xres > var->xres_virtual)\n\t\treturn -EINVAL;\n\tif (var->yoffset + var->yres > var->yres_virtual)\n\t\treturn -EINVAL;\n\n\t \n\tif (var->xres_virtual * var->yres_virtual *\n\t\t\t(var->bits_per_pixel >> 3) > fbi->fb_size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)\n{\n\treturn ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;\n}\n\nstatic u32 to_rgb(u16 red, u16 green, u16 blue)\n{\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\treturn (red << 16) | (green << 8) | blue;\n}\n\nstatic int mmpfb_setcolreg(unsigned int regno, unsigned int red,\n\t\tunsigned int green, unsigned int blue,\n\t\tunsigned int trans, struct fb_info *info)\n{\n\tstruct mmpfb_info *fbi = info->par;\n\tu32 val;\n\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16) {\n\t\tval =  chan_to_field(red,   &info->var.red);\n\t\tval |= chan_to_field(green, &info->var.green);\n\t\tval |= chan_to_field(blue , &info->var.blue);\n\t\tfbi->pseudo_palette[regno] = val;\n\t}\n\n\tif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR && regno < 256) {\n\t\tval = to_rgb(red, green, blue);\n\t\t \n\t}\n\n\treturn 0;\n}\n\nstatic int mmpfb_pan_display(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info)\n{\n\tstruct mmpfb_info *fbi = info->par;\n\tstruct mmp_addr addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.phys[0] = (var->yoffset * var->xres_virtual + var->xoffset)\n\t\t* var->bits_per_pixel / 8 + fbi->fb_start_dma;\n\tmmp_overlay_set_addr(fbi->overlay, &addr);\n\n\treturn 0;\n}\n\nstatic int var_update(struct fb_info *info)\n{\n\tstruct mmpfb_info *fbi = info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tstruct fb_videomode *m;\n\tint pix_fmt;\n\n\t \n\tpix_fmt = var_to_pixfmt(var);\n\tif (pix_fmt < 0)\n\t\treturn -EINVAL;\n\tpixfmt_to_var(var, pix_fmt);\n\tfbi->pix_fmt = pix_fmt;\n\n\t \n\tm = (struct fb_videomode *)fb_match_mode(var, &info->modelist);\n\tif (!m) {\n\t\tdev_err(fbi->dev, \"set par: no match mode, use best mode\\n\");\n\t\tm = (struct fb_videomode *)fb_find_best_mode(var,\n\t\t\t\t&info->modelist);\n\t\tfb_videomode_to_var(var, m);\n\t}\n\tmemcpy(&fbi->mode, m, sizeof(struct fb_videomode));\n\n\t \n\tvar->yres_virtual = var->yres * 2;\n\tinfo->fix.visual = (pix_fmt == PIXFMT_PSEUDOCOLOR) ?\n\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\tinfo->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;\n\tinfo->fix.ypanstep = var->yres;\n\treturn 0;\n}\n\nstatic void mmpfb_set_win(struct fb_info *info)\n{\n\tstruct mmpfb_info *fbi = info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tstruct mmp_win win;\n\tu32 stride;\n\n\tmemset(&win, 0, sizeof(win));\n\twin.xsrc = win.xdst = fbi->mode.xres;\n\twin.ysrc = win.ydst = fbi->mode.yres;\n\twin.pix_fmt = fbi->pix_fmt;\n\tstride = pixfmt_to_stride(win.pix_fmt);\n\twin.pitch[0] = var->xres_virtual * stride;\n\twin.pitch[1] = win.pitch[2] =\n\t\t(stride == 1) ? (var->xres_virtual >> 1) : 0;\n\tmmp_overlay_set_win(fbi->overlay, &win);\n}\n\nstatic int mmpfb_set_par(struct fb_info *info)\n{\n\tstruct mmpfb_info *fbi = info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tstruct mmp_addr addr;\n\tstruct mmp_mode mode;\n\tint ret;\n\n\tret = var_update(info);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tfbmode_to_mmpmode(&mode, &fbi->mode, fbi->output_fmt);\n\tmmp_path_set_mode(fbi->path, &mode);\n\n\t \n\tmmpfb_set_win(info);\n\n\t \n\tmemset(&addr, 0, sizeof(addr));\n\taddr.phys[0] = (var->yoffset * var->xres_virtual + var->xoffset)\n\t\t* var->bits_per_pixel / 8 + fbi->fb_start_dma;\n\tmmp_overlay_set_addr(fbi->overlay, &addr);\n\n\treturn 0;\n}\n\nstatic void mmpfb_power(struct mmpfb_info *fbi, int power)\n{\n\tstruct mmp_addr addr;\n\tstruct fb_var_screeninfo *var = &fbi->fb_info->var;\n\n\t \n\tif (power) {\n\t\t \n\t\tmmpfb_set_win(fbi->fb_info);\n\n\t\t \n\t\tmemset(&addr, 0, sizeof(addr));\n\t\taddr.phys[0] = fbi->fb_start_dma +\n\t\t\t(var->yoffset * var->xres_virtual + var->xoffset)\n\t\t\t* var->bits_per_pixel / 8;\n\t\tmmp_overlay_set_addr(fbi->overlay, &addr);\n\t}\n\tmmp_overlay_set_onoff(fbi->overlay, power);\n}\n\nstatic int mmpfb_blank(int blank, struct fb_info *info)\n{\n\tstruct mmpfb_info *fbi = info->par;\n\n\tmmpfb_power(fbi, (blank == FB_BLANK_UNBLANK));\n\n\treturn 0;\n}\n\nstatic const struct fb_ops mmpfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_blank\t= mmpfb_blank,\n\t.fb_check_var\t= mmpfb_check_var,\n\t.fb_set_par\t= mmpfb_set_par,\n\t.fb_setcolreg\t= mmpfb_setcolreg,\n\t.fb_pan_display\t= mmpfb_pan_display,\n};\n\nstatic int modes_setup(struct mmpfb_info *fbi)\n{\n\tstruct fb_videomode *videomodes;\n\tstruct mmp_mode *mmp_modes;\n\tstruct fb_info *info = fbi->fb_info;\n\tint videomode_num, i;\n\n\t \n\tvideomode_num = mmp_path_get_modelist(fbi->path, &mmp_modes);\n\tif (!videomode_num) {\n\t\tdev_warn(fbi->dev, \"can't get videomode num\\n\");\n\t\treturn 0;\n\t}\n\t \n\tvideomodes = kcalloc(videomode_num, sizeof(struct fb_videomode),\n\t\t\t     GFP_KERNEL);\n\tif (!videomodes)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < videomode_num; i++)\n\t\tmmpmode_to_fbmode(&videomodes[i], &mmp_modes[i]);\n\tfb_videomode_to_modelist(videomodes, videomode_num, &info->modelist);\n\n\t \n\tmemcpy(&fbi->mode, &videomodes[0], sizeof(struct fb_videomode));\n\tfbi->output_fmt = mmp_modes[0].pix_fmt_out;\n\tfb_videomode_to_var(&info->var, &fbi->mode);\n\tmmp_path_set_mode(fbi->path, &mmp_modes[0]);\n\n\tkfree(videomodes);\n\treturn videomode_num;\n}\n\nstatic int fb_info_setup(struct fb_info *info,\n\t\t\tstruct mmpfb_info *fbi)\n{\n\tint ret = 0;\n\t \n\tinfo->flags = FBINFO_PARTIAL_PAN_OK |\n\t\tFBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;\n\tinfo->node = -1;\n\tstrcpy(info->fix.id, fbi->name);\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.type_aux = 0;\n\tinfo->fix.xpanstep = 0;\n\tinfo->fix.ypanstep = info->var.yres;\n\tinfo->fix.ywrapstep = 0;\n\tinfo->fix.accel = FB_ACCEL_NONE;\n\tinfo->fix.smem_start = fbi->fb_start_dma;\n\tinfo->fix.smem_len = fbi->fb_size;\n\tinfo->fix.visual = (fbi->pix_fmt == PIXFMT_PSEUDOCOLOR) ?\n\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\tinfo->fix.line_length = info->var.xres_virtual *\n\t\tinfo->var.bits_per_pixel / 8;\n\tinfo->fbops = &mmpfb_ops;\n\tinfo->pseudo_palette = fbi->pseudo_palette;\n\tinfo->screen_buffer = fbi->fb_start;\n\tinfo->screen_size = fbi->fb_size;\n\n\t \n\tif (fb_alloc_cmap(&info->cmap, 256, 0) < 0)\n\t\tret = -ENOMEM;\n\n\treturn ret;\n}\n\nstatic void fb_info_clear(struct fb_info *info)\n{\n\tfb_dealloc_cmap(&info->cmap);\n}\n\nstatic int mmpfb_probe(struct platform_device *pdev)\n{\n\tstruct mmp_buffer_driver_mach_info *mi;\n\tstruct fb_info *info;\n\tstruct mmpfb_info *fbi;\n\tint ret, modes_num;\n\n\tmi = pdev->dev.platform_data;\n\tif (mi == NULL) {\n\t\tdev_err(&pdev->dev, \"no platform data defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tinfo = framebuffer_alloc(sizeof(struct mmpfb_info), &pdev->dev);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\tfbi = info->par;\n\n\t \n\tfbi->fb_info = info;\n\tplatform_set_drvdata(pdev, fbi);\n\tfbi->dev = &pdev->dev;\n\tfbi->name = mi->name;\n\tfbi->pix_fmt = mi->default_pixfmt;\n\tpixfmt_to_var(&info->var, fbi->pix_fmt);\n\tmutex_init(&fbi->access_ok);\n\n\t \n\tfbi->path = mmp_get_path(mi->path_name);\n\tif (!fbi->path) {\n\t\tdev_err(&pdev->dev, \"can't get the path %s\\n\", mi->path_name);\n\t\tret = -EINVAL;\n\t\tgoto failed_destroy_mutex;\n\t}\n\n\tdev_info(fbi->dev, \"path %s get\\n\", fbi->path->name);\n\n\t \n\tfbi->overlay = mmp_path_get_overlay(fbi->path, mi->overlay_id);\n\tif (!fbi->overlay) {\n\t\tret = -EINVAL;\n\t\tgoto failed_destroy_mutex;\n\t}\n\t \n\tmmp_overlay_set_fetch(fbi->overlay, mi->dmafetch_id);\n\n\tmodes_num = modes_setup(fbi);\n\tif (modes_num < 0) {\n\t\tret = modes_num;\n\t\tgoto failed_destroy_mutex;\n\t}\n\n\t \n\tif (modes_num > 0) {\n\t\t \n\t\tinfo->var.yres_virtual = info->var.yres * 2;\n\n\t\t \n\t\tfbi->fb_size = info->var.xres_virtual * info->var.yres_virtual\n\t\t\t\t* info->var.bits_per_pixel / 8;\n\t} else {\n\t\tfbi->fb_size = MMPFB_DEFAULT_SIZE;\n\t}\n\n\tfbi->fb_start = dma_alloc_coherent(&pdev->dev, PAGE_ALIGN(fbi->fb_size),\n\t\t\t\t&fbi->fb_start_dma, GFP_KERNEL);\n\tif (fbi->fb_start == NULL) {\n\t\tdev_err(&pdev->dev, \"can't alloc framebuffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_destroy_mutex;\n\t}\n\tdev_info(fbi->dev, \"fb %dk allocated\\n\", fbi->fb_size/1024);\n\n\t \n\tif (modes_num > 0)\n\t\tmmpfb_power(fbi, 1);\n\n\tret = fb_info_setup(info, fbi);\n\tif (ret < 0)\n\t\tgoto failed_free_buff;\n\n\tret = register_framebuffer(info);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to register fb: %d\\n\", ret);\n\t\tret = -ENXIO;\n\t\tgoto failed_clear_info;\n\t}\n\n\tdev_info(fbi->dev, \"loaded to /dev/fb%d <%s>.\\n\",\n\t\tinfo->node, info->fix.id);\n\n#ifdef CONFIG_LOGO\n\tif (fbi->fb_start) {\n\t\tfb_prepare_logo(info, 0);\n\t\tfb_show_logo(info, 0);\n\t}\n#endif\n\n\treturn 0;\n\nfailed_clear_info:\n\tfb_info_clear(info);\nfailed_free_buff:\n\tdma_free_coherent(&pdev->dev, PAGE_ALIGN(fbi->fb_size), fbi->fb_start,\n\t\tfbi->fb_start_dma);\nfailed_destroy_mutex:\n\tmutex_destroy(&fbi->access_ok);\n\tdev_err(fbi->dev, \"mmp-fb: frame buffer device init failed\\n\");\n\n\tframebuffer_release(info);\n\n\treturn ret;\n}\n\nstatic struct platform_driver mmpfb_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"mmp-fb\",\n\t},\n\t.probe\t\t= mmpfb_probe,\n};\n\nstatic int mmpfb_init(void)\n{\n\treturn platform_driver_register(&mmpfb_driver);\n}\nmodule_init(mmpfb_init);\n\nMODULE_AUTHOR(\"Zhou Zhu <zhou.zhu@marvell.com>\");\nMODULE_DESCRIPTION(\"Framebuffer driver for Marvell displays\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}