{
  "module_name": "core.c",
  "hash_id": "231fddb0ebd2003b6ae36fcb8c4768c242db1b9f6d5fd6405e33c8dfa372a34d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/mmp/core.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <video/mmp_disp.h>\n\nstatic struct mmp_overlay *path_get_overlay(struct mmp_path *path,\n\t\tint overlay_id)\n{\n\tif (path && overlay_id < path->overlay_num)\n\t\treturn &path->overlays[overlay_id];\n\treturn NULL;\n}\n\nstatic int path_check_status(struct mmp_path *path)\n{\n\tint i;\n\tfor (i = 0; i < path->overlay_num; i++)\n\t\tif (path->overlays[i].status)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int path_get_modelist(struct mmp_path *path,\n\t\tstruct mmp_mode **modelist)\n{\n\tBUG_ON(!path || !modelist);\n\n\tif (path->panel && path->panel->get_modelist)\n\t\treturn path->panel->get_modelist(path->panel, modelist);\n\n\treturn 0;\n}\n\n \nstatic LIST_HEAD(panel_list);\nstatic LIST_HEAD(path_list);\nstatic DEFINE_MUTEX(disp_lock);\n\n \nvoid mmp_register_panel(struct mmp_panel *panel)\n{\n\tstruct mmp_path *path;\n\n\tmutex_lock(&disp_lock);\n\n\t \n\tlist_add_tail(&panel->node, &panel_list);\n\n\t \n\tlist_for_each_entry(path, &path_list, node) {\n\t\tif (!strcmp(panel->plat_path_name, path->name)) {\n\t\t\tdev_info(panel->dev, \"connect to path %s\\n\",\n\t\t\t\tpath->name);\n\t\t\tpath->panel = panel;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&disp_lock);\n}\nEXPORT_SYMBOL_GPL(mmp_register_panel);\n\n \nvoid mmp_unregister_panel(struct mmp_panel *panel)\n{\n\tstruct mmp_path *path;\n\n\tmutex_lock(&disp_lock);\n\tlist_del(&panel->node);\n\n\tlist_for_each_entry(path, &path_list, node) {\n\t\tif (path->panel && path->panel == panel) {\n\t\t\tdev_info(panel->dev, \"disconnect from path %s\\n\",\n\t\t\t\tpath->name);\n\t\t\tpath->panel = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&disp_lock);\n}\nEXPORT_SYMBOL_GPL(mmp_unregister_panel);\n\n \nstruct mmp_path *mmp_get_path(const char *name)\n{\n\tstruct mmp_path *path = NULL, *iter;\n\n\tmutex_lock(&disp_lock);\n\tlist_for_each_entry(iter, &path_list, node) {\n\t\tif (!strcmp(name, iter->name)) {\n\t\t\tpath = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&disp_lock);\n\n\treturn path;\n}\nEXPORT_SYMBOL_GPL(mmp_get_path);\n\n \nstruct mmp_path *mmp_register_path(struct mmp_path_info *info)\n{\n\tint i;\n\tstruct mmp_path *path = NULL;\n\tstruct mmp_panel *panel;\n\n\tpath = kzalloc(struct_size(path, overlays, info->overlay_num),\n\t\t       GFP_KERNEL);\n\tif (!path)\n\t\treturn NULL;\n\n\t \n\tmutex_init(&path->access_ok);\n\tpath->dev = info->dev;\n\tpath->id = info->id;\n\tpath->name = info->name;\n\tpath->output_type = info->output_type;\n\tpath->overlay_num = info->overlay_num;\n\tpath->plat_data = info->plat_data;\n\tpath->ops.set_mode = info->set_mode;\n\n\tmutex_lock(&disp_lock);\n\t \n\tlist_for_each_entry(panel, &panel_list, node) {\n\t\tif (!strcmp(info->name, panel->plat_path_name)) {\n\t\t\tdev_info(path->dev, \"get panel %s\\n\", panel->name);\n\t\t\tpath->panel = panel;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdev_info(path->dev, \"register %s, overlay_num %d\\n\",\n\t\t\tpath->name, path->overlay_num);\n\n\t \n\tif (!path->ops.check_status)\n\t\tpath->ops.check_status = path_check_status;\n\tif (!path->ops.get_overlay)\n\t\tpath->ops.get_overlay = path_get_overlay;\n\tif (!path->ops.get_modelist)\n\t\tpath->ops.get_modelist = path_get_modelist;\n\n\t \n\tfor (i = 0; i < path->overlay_num; i++) {\n\t\tpath->overlays[i].path = path;\n\t\tpath->overlays[i].id = i;\n\t\tmutex_init(&path->overlays[i].access_ok);\n\t\tpath->overlays[i].ops = info->overlay_ops;\n\t}\n\n\t \n\tlist_add_tail(&path->node, &path_list);\n\n\tmutex_unlock(&disp_lock);\n\treturn path;\n}\nEXPORT_SYMBOL_GPL(mmp_register_path);\n\n \nvoid mmp_unregister_path(struct mmp_path *path)\n{\n\tint i;\n\n\tif (!path)\n\t\treturn;\n\n\tmutex_lock(&disp_lock);\n\t \n\tlist_del(&path->node);\n\n\t \n\tfor (i = 0; i < path->overlay_num; i++)\n\t\tmutex_destroy(&path->overlays[i].access_ok);\n\n\tmutex_destroy(&path->access_ok);\n\n\tkfree(path);\n\tmutex_unlock(&disp_lock);\n}\nEXPORT_SYMBOL_GPL(mmp_unregister_path);\n\nMODULE_AUTHOR(\"Zhou Zhu <zzhu3@marvell.com>\");\nMODULE_DESCRIPTION(\"Marvell MMP display framework\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}