{
  "module_name": "mmp_spi.c",
  "hash_id": "28e314c84a77f44a1460ae429d783e2bf9aec17c5dc84111f65cdbb13549b34d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/mmp/hw/mmp_spi.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/spi/spi.h>\n#include \"mmp_ctrl.h\"\n\n \nstatic inline int lcd_spi_write(struct spi_device *spi, u32 data)\n{\n\tint timeout = 100000, isr, ret = 0;\n\tu32 tmp;\n\tvoid __iomem *reg_base = (void __iomem *)\n\t\t*(void **)spi_master_get_devdata(spi->master);\n\n\t \n\twritel_relaxed(~SPI_IRQ_MASK, reg_base + SPU_IRQ_ISR);\n\n\tswitch (spi->bits_per_word) {\n\tcase 8:\n\t\twritel_relaxed((u8)data, reg_base + LCD_SPU_SPI_TXDATA);\n\t\tbreak;\n\tcase 16:\n\t\twritel_relaxed((u16)data, reg_base + LCD_SPU_SPI_TXDATA);\n\t\tbreak;\n\tcase 32:\n\t\twritel_relaxed((u32)data, reg_base + LCD_SPU_SPI_TXDATA);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&spi->dev, \"Wrong spi bit length\\n\");\n\t}\n\n\t \n\ttmp = readl_relaxed(reg_base + LCD_SPU_SPI_CTRL);\n\ttmp &= ~CFG_SPI_START_MASK;\n\ttmp |= CFG_SPI_START(1);\n\twritel(tmp, reg_base + LCD_SPU_SPI_CTRL);\n\n\tisr = readl_relaxed(reg_base + SPU_IRQ_ISR);\n\twhile (!(isr & SPI_IRQ_ENA_MASK)) {\n\t\tudelay(100);\n\t\tisr = readl_relaxed(reg_base + SPU_IRQ_ISR);\n\t\tif (!--timeout) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tdev_err(&spi->dev, \"spi cmd send time out\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttmp = readl_relaxed(reg_base + LCD_SPU_SPI_CTRL);\n\ttmp &= ~CFG_SPI_START_MASK;\n\ttmp |= CFG_SPI_START(0);\n\twritel_relaxed(tmp, reg_base + LCD_SPU_SPI_CTRL);\n\n\twritel_relaxed(~SPI_IRQ_MASK, reg_base + SPU_IRQ_ISR);\n\n\treturn ret;\n}\n\nstatic int lcd_spi_setup(struct spi_device *spi)\n{\n\tvoid __iomem *reg_base = (void __iomem *)\n\t\t*(void **)spi_master_get_devdata(spi->master);\n\tu32 tmp;\n\n\ttmp = CFG_SCLKCNT(16) |\n\t\tCFG_TXBITS(spi->bits_per_word) |\n\t\tCFG_SPI_SEL(1) | CFG_SPI_ENA(1) |\n\t\tCFG_SPI_3W4WB(1);\n\twritel(tmp, reg_base + LCD_SPU_SPI_CTRL);\n\n\t \n\ttmp = readl_relaxed(reg_base + SPU_IOPAD_CONTROL);\n\tif ((tmp & CFG_IOPADMODE_MASK) != IOPAD_DUMB18SPI)\n\t\twritel_relaxed(IOPAD_DUMB18SPI |\n\t\t\t(tmp & ~CFG_IOPADMODE_MASK),\n\t\t\treg_base + SPU_IOPAD_CONTROL);\n\tudelay(20);\n\treturn 0;\n}\n\nstatic int lcd_spi_one_transfer(struct spi_device *spi, struct spi_message *m)\n{\n\tstruct spi_transfer *t;\n\tint i;\n\n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\tswitch (spi->bits_per_word) {\n\t\tcase 8:\n\t\t\tfor (i = 0; i < t->len; i++)\n\t\t\t\tlcd_spi_write(spi, ((u8 *)t->tx_buf)[i]);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tfor (i = 0; i < t->len/2; i++)\n\t\t\t\tlcd_spi_write(spi, ((u16 *)t->tx_buf)[i]);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tfor (i = 0; i < t->len/4; i++)\n\t\t\t\tlcd_spi_write(spi, ((u32 *)t->tx_buf)[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&spi->dev, \"Wrong spi bit length\\n\");\n\t\t}\n\t}\n\n\tm->status = 0;\n\tif (m->complete)\n\t\tm->complete(m->context);\n\treturn 0;\n}\n\nint lcd_spi_register(struct mmphw_ctrl *ctrl)\n{\n\tstruct spi_master *master;\n\tvoid **p_regbase;\n\tint err;\n\n\tmaster = spi_alloc_master(ctrl->dev, sizeof(void *));\n\tif (!master) {\n\t\tdev_err(ctrl->dev, \"unable to allocate SPI master\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tp_regbase = spi_master_get_devdata(master);\n\t*p_regbase = (void __force *)ctrl->reg_base;\n\n\t \n\tmaster->bus_num = 5;\n\tmaster->num_chipselect = 1;\n\tmaster->setup = lcd_spi_setup;\n\tmaster->transfer = lcd_spi_one_transfer;\n\n\terr = spi_register_master(master);\n\tif (err < 0) {\n\t\tdev_err(ctrl->dev, \"unable to register SPI master\\n\");\n\t\tspi_master_put(master);\n\t\treturn err;\n\t}\n\n\tdev_info(&master->dev, \"registered\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}