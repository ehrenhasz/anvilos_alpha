{
  "module_name": "mmp_ctrl.c",
  "hash_id": "234da0b7547a9ee9dd85b76369afee70bd4501c0002f67c9009ce048749b332c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/mmp/hw/mmp_ctrl.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/io.h>\n\n#include \"mmp_ctrl.h\"\n\nstatic irqreturn_t ctrl_handle_irq(int irq, void *dev_id)\n{\n\tstruct mmphw_ctrl *ctrl = (struct mmphw_ctrl *)dev_id;\n\tu32 isr, imask, tmp;\n\n\tisr = readl_relaxed(ctrl->reg_base + SPU_IRQ_ISR);\n\timask = readl_relaxed(ctrl->reg_base + SPU_IRQ_ENA);\n\n\tdo {\n\t\t \n\t\ttmp = readl_relaxed(ctrl->reg_base + SPU_IRQ_ISR);\n\t\tif (tmp & isr)\n\t\t\twritel_relaxed(~isr, ctrl->reg_base + SPU_IRQ_ISR);\n\t} while ((isr = readl_relaxed(ctrl->reg_base + SPU_IRQ_ISR)) & imask);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 fmt_to_reg(struct mmp_overlay *overlay, int pix_fmt)\n{\n\tu32 rbswap = 0, uvswap = 0, yuvswap = 0,\n\t\tcsc_en = 0, val = 0,\n\t\tvid = overlay_is_vid(overlay);\n\n\tswitch (pix_fmt) {\n\tcase PIXFMT_RGB565:\n\tcase PIXFMT_RGB1555:\n\tcase PIXFMT_RGB888PACK:\n\tcase PIXFMT_RGB888UNPACK:\n\tcase PIXFMT_RGBA888:\n\t\trbswap = 1;\n\t\tbreak;\n\tcase PIXFMT_VYUY:\n\tcase PIXFMT_YVU422P:\n\tcase PIXFMT_YVU420P:\n\t\tuvswap = 1;\n\t\tbreak;\n\tcase PIXFMT_YUYV:\n\t\tyuvswap = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (pix_fmt) {\n\tcase PIXFMT_RGB565:\n\tcase PIXFMT_BGR565:\n\t\tbreak;\n\tcase PIXFMT_RGB1555:\n\tcase PIXFMT_BGR1555:\n\t\tval = 0x1;\n\t\tbreak;\n\tcase PIXFMT_RGB888PACK:\n\tcase PIXFMT_BGR888PACK:\n\t\tval = 0x2;\n\t\tbreak;\n\tcase PIXFMT_RGB888UNPACK:\n\tcase PIXFMT_BGR888UNPACK:\n\t\tval = 0x3;\n\t\tbreak;\n\tcase PIXFMT_RGBA888:\n\tcase PIXFMT_BGRA888:\n\t\tval = 0x4;\n\t\tbreak;\n\tcase PIXFMT_UYVY:\n\tcase PIXFMT_VYUY:\n\tcase PIXFMT_YUYV:\n\t\tval = 0x5;\n\t\tcsc_en = 1;\n\t\tbreak;\n\tcase PIXFMT_YUV422P:\n\tcase PIXFMT_YVU422P:\n\t\tval = 0x6;\n\t\tcsc_en = 1;\n\t\tbreak;\n\tcase PIXFMT_YUV420P:\n\tcase PIXFMT_YVU420P:\n\t\tval = 0x7;\n\t\tcsc_en = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (dma_palette(0) | dma_fmt(vid, val) |\n\t\tdma_swaprb(vid, rbswap) | dma_swapuv(vid, uvswap) |\n\t\tdma_swapyuv(vid, yuvswap) | dma_csc(vid, csc_en));\n}\n\nstatic void dmafetch_set_fmt(struct mmp_overlay *overlay)\n{\n\tu32 tmp;\n\tstruct mmp_path *path = overlay->path;\n\ttmp = readl_relaxed(ctrl_regs(path) + dma_ctrl(0, path->id));\n\ttmp &= ~dma_mask(overlay_is_vid(overlay));\n\ttmp |= fmt_to_reg(overlay, overlay->win.pix_fmt);\n\twritel_relaxed(tmp, ctrl_regs(path) + dma_ctrl(0, path->id));\n}\n\nstatic void overlay_set_win(struct mmp_overlay *overlay, struct mmp_win *win)\n{\n\tstruct lcd_regs *regs = path_regs(overlay->path);\n\n\t \n\tmemcpy(&overlay->win, win, sizeof(struct mmp_win));\n\n\tmutex_lock(&overlay->access_ok);\n\n\tif (overlay_is_vid(overlay)) {\n\t\twritel_relaxed(win->pitch[0],\n\t\t\t\t(void __iomem *)&regs->v_pitch_yc);\n\t\twritel_relaxed(win->pitch[2] << 16 | win->pitch[1],\n\t\t\t\t(void __iomem *)&regs->v_pitch_uv);\n\n\t\twritel_relaxed((win->ysrc << 16) | win->xsrc,\n\t\t\t\t(void __iomem *)&regs->v_size);\n\t\twritel_relaxed((win->ydst << 16) | win->xdst,\n\t\t\t\t(void __iomem *)&regs->v_size_z);\n\t\twritel_relaxed(win->ypos << 16 | win->xpos,\n\t\t\t\t(void __iomem *)&regs->v_start);\n\t} else {\n\t\twritel_relaxed(win->pitch[0], (void __iomem *)&regs->g_pitch);\n\n\t\twritel_relaxed((win->ysrc << 16) | win->xsrc,\n\t\t\t\t(void __iomem *)&regs->g_size);\n\t\twritel_relaxed((win->ydst << 16) | win->xdst,\n\t\t\t\t(void __iomem *)&regs->g_size_z);\n\t\twritel_relaxed(win->ypos << 16 | win->xpos,\n\t\t\t\t(void __iomem *)&regs->g_start);\n\t}\n\n\tdmafetch_set_fmt(overlay);\n\tmutex_unlock(&overlay->access_ok);\n}\n\nstatic void dmafetch_onoff(struct mmp_overlay *overlay, int on)\n{\n\tu32 mask = overlay_is_vid(overlay) ? CFG_DMA_ENA_MASK :\n\t\t   CFG_GRA_ENA_MASK;\n\tu32 enable = overlay_is_vid(overlay) ? CFG_DMA_ENA(1) : CFG_GRA_ENA(1);\n\tu32 tmp;\n\tstruct mmp_path *path = overlay->path;\n\n\tmutex_lock(&overlay->access_ok);\n\ttmp = readl_relaxed(ctrl_regs(path) + dma_ctrl(0, path->id));\n\ttmp &= ~mask;\n\ttmp |= (on ? enable : 0);\n\twritel(tmp, ctrl_regs(path) + dma_ctrl(0, path->id));\n\tmutex_unlock(&overlay->access_ok);\n}\n\nstatic void path_enabledisable(struct mmp_path *path, int on)\n{\n\tu32 tmp;\n\tmutex_lock(&path->access_ok);\n\ttmp = readl_relaxed(ctrl_regs(path) + LCD_SCLK(path));\n\tif (on)\n\t\ttmp &= ~SCLK_DISABLE;\n\telse\n\t\ttmp |= SCLK_DISABLE;\n\twritel_relaxed(tmp, ctrl_regs(path) + LCD_SCLK(path));\n\tmutex_unlock(&path->access_ok);\n}\n\nstatic void path_onoff(struct mmp_path *path, int on)\n{\n\tif (path->status == on) {\n\t\tdev_info(path->dev, \"path %s is already %s\\n\",\n\t\t\t\tpath->name, stat_name(path->status));\n\t\treturn;\n\t}\n\n\tif (on) {\n\t\tpath_enabledisable(path, 1);\n\n\t\tif (path->panel && path->panel->set_onoff)\n\t\t\tpath->panel->set_onoff(path->panel, 1);\n\t} else {\n\t\tif (path->panel && path->panel->set_onoff)\n\t\t\tpath->panel->set_onoff(path->panel, 0);\n\n\t\tpath_enabledisable(path, 0);\n\t}\n\tpath->status = on;\n}\n\nstatic void overlay_set_onoff(struct mmp_overlay *overlay, int on)\n{\n\tif (overlay->status == on) {\n\t\tdev_info(overlay_to_ctrl(overlay)->dev, \"overlay %s is already %s\\n\",\n\t\t\toverlay->path->name, stat_name(overlay->status));\n\t\treturn;\n\t}\n\toverlay->status = on;\n\tdmafetch_onoff(overlay, on);\n\tif (overlay->path->ops.check_status(overlay->path)\n\t\t\t!= overlay->path->status)\n\t\tpath_onoff(overlay->path, on);\n}\n\nstatic void overlay_set_fetch(struct mmp_overlay *overlay, int fetch_id)\n{\n\toverlay->dmafetch_id = fetch_id;\n}\n\nstatic int overlay_set_addr(struct mmp_overlay *overlay, struct mmp_addr *addr)\n{\n\tstruct lcd_regs *regs = path_regs(overlay->path);\n\n\t \n\tmemcpy(&overlay->addr, addr, sizeof(struct mmp_addr));\n\n\tif (overlay_is_vid(overlay)) {\n\t\twritel_relaxed(addr->phys[0], (void __iomem *)&regs->v_y0);\n\t\twritel_relaxed(addr->phys[1], (void __iomem *)&regs->v_u0);\n\t\twritel_relaxed(addr->phys[2], (void __iomem *)&regs->v_v0);\n\t} else\n\t\twritel_relaxed(addr->phys[0], (void __iomem *)&regs->g_0);\n\n\treturn overlay->addr.phys[0];\n}\n\nstatic void path_set_mode(struct mmp_path *path, struct mmp_mode *mode)\n{\n\tstruct lcd_regs *regs = path_regs(path);\n\tu32 total_x, total_y, vsync_ctrl, tmp, sclk_src, sclk_div,\n\t\tlink_config = path_to_path_plat(path)->link_config,\n\t\tdsi_rbswap = path_to_path_plat(path)->link_config;\n\n\t \n\tmemcpy(&path->mode, mode, sizeof(struct mmp_mode));\n\n\tmutex_lock(&path->access_ok);\n\n\t \n\ttmp = readl_relaxed(ctrl_regs(path) + intf_ctrl(path->id)) & 0x1;\n\ttmp |= mode->vsync_invert ? 0 : 0x8;\n\ttmp |= mode->hsync_invert ? 0 : 0x4;\n\ttmp |= link_config & CFG_DUMBMODE_MASK;\n\ttmp |= CFG_DUMB_ENA(1);\n\twritel_relaxed(tmp, ctrl_regs(path) + intf_ctrl(path->id));\n\n\t \n\ttmp = readl_relaxed(ctrl_regs(path) + intf_rbswap_ctrl(path->id)) &\n\t\t(~(CFG_INTFRBSWAP_MASK));\n\ttmp |= dsi_rbswap & CFG_INTFRBSWAP_MASK;\n\twritel_relaxed(tmp, ctrl_regs(path) + intf_rbswap_ctrl(path->id));\n\n\twritel_relaxed((mode->yres << 16) | mode->xres,\n\t\t(void __iomem *)&regs->screen_active);\n\twritel_relaxed((mode->left_margin << 16) | mode->right_margin,\n\t\t(void __iomem *)&regs->screen_h_porch);\n\twritel_relaxed((mode->upper_margin << 16) | mode->lower_margin,\n\t\t(void __iomem *)&regs->screen_v_porch);\n\ttotal_x = mode->xres + mode->left_margin + mode->right_margin +\n\t\tmode->hsync_len;\n\ttotal_y = mode->yres + mode->upper_margin + mode->lower_margin +\n\t\tmode->vsync_len;\n\twritel_relaxed((total_y << 16) | total_x,\n\t\t(void __iomem *)&regs->screen_size);\n\n\t \n\tif (path->output_type == PATH_OUT_DSI)\n\t\tvsync_ctrl = 0x01330133;\n\telse\n\t\tvsync_ctrl = ((mode->xres + mode->right_margin) << 16)\n\t\t\t\t\t| (mode->xres + mode->right_margin);\n\twritel_relaxed(vsync_ctrl, (void __iomem *)&regs->vsync_ctrl);\n\n\t \n\tsclk_src = clk_get_rate(path_to_ctrl(path)->clk);\n\tsclk_div = sclk_src / mode->pixclock_freq;\n\tif (sclk_div * mode->pixclock_freq < sclk_src)\n\t\tsclk_div++;\n\n\tdev_info(path->dev, \"%s sclk_src %d sclk_div 0x%x pclk %d\\n\",\n\t\t\t__func__, sclk_src, sclk_div, mode->pixclock_freq);\n\n\ttmp = readl_relaxed(ctrl_regs(path) + LCD_SCLK(path));\n\ttmp &= ~CLK_INT_DIV_MASK;\n\ttmp |= sclk_div;\n\twritel_relaxed(tmp, ctrl_regs(path) + LCD_SCLK(path));\n\n\tmutex_unlock(&path->access_ok);\n}\n\nstatic struct mmp_overlay_ops mmphw_overlay_ops = {\n\t.set_fetch = overlay_set_fetch,\n\t.set_onoff = overlay_set_onoff,\n\t.set_win = overlay_set_win,\n\t.set_addr = overlay_set_addr,\n};\n\nstatic void ctrl_set_default(struct mmphw_ctrl *ctrl)\n{\n\tu32 tmp, irq_mask;\n\n\t \n\ttmp = readl_relaxed(ctrl->reg_base + LCD_TOP_CTRL);\n\ttmp |= 0xfff0;\n\twritel_relaxed(tmp, ctrl->reg_base + LCD_TOP_CTRL);\n\n\n\t \n\tirq_mask = path_imasks(0) | err_imask(0) |\n\t\t   path_imasks(1) | err_imask(1);\n\ttmp = readl_relaxed(ctrl->reg_base + SPU_IRQ_ENA);\n\ttmp &= ~irq_mask;\n\ttmp |= irq_mask;\n\twritel_relaxed(tmp, ctrl->reg_base + SPU_IRQ_ENA);\n}\n\nstatic void path_set_default(struct mmp_path *path)\n{\n\tstruct lcd_regs *regs = path_regs(path);\n\tu32 dma_ctrl1, mask, tmp, path_config;\n\n\tpath_config = path_to_path_plat(path)->path_config;\n\n\t \n\tif (PATH_OUT_PARALLEL == path->output_type) {\n\t\tmask = CFG_IOPADMODE_MASK | CFG_BURST_MASK | CFG_BOUNDARY_MASK;\n\t\ttmp = readl_relaxed(ctrl_regs(path) + SPU_IOPAD_CONTROL);\n\t\ttmp &= ~mask;\n\t\ttmp |= path_config;\n\t\twritel_relaxed(tmp, ctrl_regs(path) + SPU_IOPAD_CONTROL);\n\t}\n\n\t \n\ttmp = readl_relaxed(ctrl_regs(path) + LCD_SCLK(path));\n\ttmp &= ~SCLK_SRC_SEL_MASK;\n\ttmp |= path_config;\n\twritel_relaxed(tmp, ctrl_regs(path) + LCD_SCLK(path));\n\n\t \n\tdma_ctrl1 = 0x2032ff81;\n\n\tdma_ctrl1 |= CFG_VSYNC_INV_MASK;\n\twritel_relaxed(dma_ctrl1, ctrl_regs(path) + dma_ctrl(1, path->id));\n\n\t \n\twritel_relaxed(0x00000000, (void __iomem *)&regs->blank_color);\n\twritel_relaxed(0x00000000, (void __iomem *)&regs->g_1);\n\twritel_relaxed(0x00000000, (void __iomem *)&regs->g_start);\n\n\t \n\tmask = CFG_GRA_HSMOOTH_MASK | CFG_DMA_HSMOOTH_MASK | CFG_ARBFAST_ENA(1);\n\ttmp = readl_relaxed(ctrl_regs(path) + dma_ctrl(0, path->id));\n\ttmp |= mask;\n\tif (PATH_TV == path->id)\n\t\ttmp &= ~CFG_ARBFAST_ENA(1);\n\twritel_relaxed(tmp, ctrl_regs(path) + dma_ctrl(0, path->id));\n}\n\nstatic int path_init(struct mmphw_path_plat *path_plat,\n\t\tstruct mmp_mach_path_config *config)\n{\n\tstruct mmphw_ctrl *ctrl = path_plat->ctrl;\n\tstruct mmp_path_info *path_info;\n\tstruct mmp_path *path = NULL;\n\n\tdev_info(ctrl->dev, \"%s: %s\\n\", __func__, config->name);\n\n\t \n\tpath_info = kzalloc(sizeof(*path_info), GFP_KERNEL);\n\tif (!path_info)\n\t\treturn 0;\n\n\tpath_info->name = config->name;\n\tpath_info->id = path_plat->id;\n\tpath_info->dev = ctrl->dev;\n\tpath_info->overlay_num = config->overlay_num;\n\tpath_info->overlay_ops = &mmphw_overlay_ops;\n\tpath_info->set_mode = path_set_mode;\n\tpath_info->plat_data = path_plat;\n\n\t \n\tpath = mmp_register_path(path_info);\n\tif (!path) {\n\t\tkfree(path_info);\n\t\treturn 0;\n\t}\n\tpath_plat->path = path;\n\tpath_plat->path_config = config->path_config;\n\tpath_plat->link_config = config->link_config;\n\tpath_plat->dsi_rbswap = config->dsi_rbswap;\n\tpath_set_default(path);\n\n\tkfree(path_info);\n\treturn 1;\n}\n\nstatic void path_deinit(struct mmphw_path_plat *path_plat)\n{\n\tif (!path_plat)\n\t\treturn;\n\n\tmmp_unregister_path(path_plat->path);\n}\n\nstatic int mmphw_probe(struct platform_device *pdev)\n{\n\tstruct mmp_mach_plat_info *mi;\n\tstruct resource *res;\n\tint ret, i, irq;\n\tstruct mmphw_path_plat *path_plat;\n\tstruct mmphw_ctrl *ctrl = NULL;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"%s: no IO memory defined\\n\", __func__);\n\t\tret = -ENOENT;\n\t\tgoto failed;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = -ENOENT;\n\t\tgoto failed;\n\t}\n\n\t \n\tmi = pdev->dev.platform_data;\n\tif (mi == NULL || !mi->path_num || !mi->paths) {\n\t\tdev_err(&pdev->dev, \"%s: no platform data defined\\n\", __func__);\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\t \n\tctrl = devm_kzalloc(&pdev->dev,\n\t\t\t    struct_size(ctrl, path_plats, mi->path_num),\n\t\t\t    GFP_KERNEL);\n\tif (!ctrl) {\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tctrl->name = mi->name;\n\tctrl->path_num = mi->path_num;\n\tctrl->dev = &pdev->dev;\n\tctrl->irq = irq;\n\tplatform_set_drvdata(pdev, ctrl);\n\tmutex_init(&ctrl->access_ok);\n\n\t \n\tif (!devm_request_mem_region(ctrl->dev, res->start,\n\t\t\tresource_size(res), ctrl->name)) {\n\t\tdev_err(ctrl->dev,\n\t\t\t\"can't request region for resource %pR\\n\", res);\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\tctrl->reg_base = devm_ioremap(ctrl->dev,\n\t\t\tres->start, resource_size(res));\n\tif (ctrl->reg_base == NULL) {\n\t\tdev_err(ctrl->dev, \"%s: res %pR map failed\\n\", __func__, res);\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\t \n\tret = devm_request_irq(ctrl->dev, ctrl->irq, ctrl_handle_irq,\n\t\tIRQF_SHARED, \"lcd_controller\", ctrl);\n\tif (ret < 0) {\n\t\tdev_err(ctrl->dev, \"%s unable to request IRQ %d\\n\",\n\t\t\t\t__func__, ctrl->irq);\n\t\tret = -ENXIO;\n\t\tgoto failed;\n\t}\n\n\t \n\tctrl->clk = devm_clk_get(ctrl->dev, mi->clk_name);\n\tif (IS_ERR(ctrl->clk)) {\n\t\tret = PTR_ERR(ctrl->clk);\n\t\tdev_err_probe(ctrl->dev, ret,\n\t\t\t      \"unable to get clk %s\\n\", mi->clk_name);\n\t\tgoto failed;\n\t}\n\tret = clk_prepare_enable(ctrl->clk);\n\tif (ret)\n\t\tgoto failed;\n\n\t \n\tctrl_set_default(ctrl);\n\n\t \n\tfor (i = 0; i < ctrl->path_num; i++) {\n\t\t \n\t\tpath_plat = &ctrl->path_plats[i];\n\t\tpath_plat->id = i;\n\t\tpath_plat->ctrl = ctrl;\n\n\t\t \n\t\tif (!path_init(path_plat, &mi->paths[i])) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed_path_init;\n\t\t}\n\t}\n\n#ifdef CONFIG_MMP_DISP_SPI\n\tret = lcd_spi_register(ctrl);\n\tif (ret < 0)\n\t\tgoto failed_path_init;\n#endif\n\n\tdev_info(ctrl->dev, \"device init done\\n\");\n\n\treturn 0;\n\nfailed_path_init:\n\tfor (i = 0; i < ctrl->path_num; i++) {\n\t\tpath_plat = &ctrl->path_plats[i];\n\t\tpath_deinit(path_plat);\n\t}\n\n\tclk_disable_unprepare(ctrl->clk);\nfailed:\n\tdev_err(&pdev->dev, \"device init failed\\n\");\n\n\treturn ret;\n}\n\nstatic struct platform_driver mmphw_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"mmp-disp\",\n\t},\n\t.probe\t\t= mmphw_probe,\n};\n\nstatic int mmphw_init(void)\n{\n\treturn platform_driver_register(&mmphw_driver);\n}\nmodule_init(mmphw_init);\n\nMODULE_AUTHOR(\"Li Guoqing<ligq@marvell.com>\");\nMODULE_DESCRIPTION(\"Framebuffer driver for mmp\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}