{
  "module_name": "wm8505fb.c",
  "hash_id": "e6e03e95db952d1292b4a33956e26365a0d42ec2bd6a67907622574cb3ea84a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/wm8505fb.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/fb.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/memblock.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_fdt.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/wait.h>\n#include <video/of_display_timing.h>\n\n#include \"wm8505fb_regs.h\"\n#include \"wmt_ge_rops.h\"\n\n#define DRIVER_NAME \"wm8505-fb\"\n\n#define to_wm8505fb_info(__info) container_of(__info, \\\n\t\t\t\t\t\tstruct wm8505fb_info, fb)\nstruct wm8505fb_info {\n\tstruct fb_info\t\tfb;\n\tvoid __iomem\t\t*regbase;\n\tunsigned int\t\tcontrast;\n};\n\n\nstatic int wm8505fb_init_hw(struct fb_info *info)\n{\n\tstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\n\n\tint i;\n\n\t \n\tfor (i = 0; i < 0x200; i += 4)\n\t\twritel(0, fbi->regbase + i);\n\n\t \n\twritel(fbi->fb.fix.smem_start, fbi->regbase + WMT_GOVR_FBADDR);\n\twritel(fbi->fb.fix.smem_start, fbi->regbase + WMT_GOVR_FBADDR1);\n\n\t \n\twritel(0x31c,\t\t       fbi->regbase + WMT_GOVR_COLORSPACE);\n\twritel(1,\t\t       fbi->regbase + WMT_GOVR_COLORSPACE1);\n\n\t \n\twritel(info->var.xres,\t       fbi->regbase + WMT_GOVR_XRES);\n\twritel(info->var.xres_virtual, fbi->regbase + WMT_GOVR_XRES_VIRTUAL);\n\n\t \n\twritel(0xf,\t\t       fbi->regbase + WMT_GOVR_FHI);\n\twritel(4,\t\t       fbi->regbase + WMT_GOVR_DVO_SET);\n\twritel(1,\t\t       fbi->regbase + WMT_GOVR_MIF_ENABLE);\n\twritel(1,\t\t       fbi->regbase + WMT_GOVR_REG_UPDATE);\n\n\treturn 0;\n}\n\nstatic int wm8505fb_set_timing(struct fb_info *info)\n{\n\tstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\n\n\tint h_start = info->var.left_margin;\n\tint h_end = h_start + info->var.xres;\n\tint h_all = h_end + info->var.right_margin;\n\tint h_sync = info->var.hsync_len;\n\n\tint v_start = info->var.upper_margin;\n\tint v_end = v_start + info->var.yres;\n\tint v_all = v_end + info->var.lower_margin;\n\tint v_sync = info->var.vsync_len;\n\n\twritel(0, fbi->regbase + WMT_GOVR_TG);\n\n\twritel(h_start, fbi->regbase + WMT_GOVR_TIMING_H_START);\n\twritel(h_end,   fbi->regbase + WMT_GOVR_TIMING_H_END);\n\twritel(h_all,   fbi->regbase + WMT_GOVR_TIMING_H_ALL);\n\twritel(h_sync,  fbi->regbase + WMT_GOVR_TIMING_H_SYNC);\n\n\twritel(v_start, fbi->regbase + WMT_GOVR_TIMING_V_START);\n\twritel(v_end,   fbi->regbase + WMT_GOVR_TIMING_V_END);\n\twritel(v_all,   fbi->regbase + WMT_GOVR_TIMING_V_ALL);\n\twritel(v_sync,  fbi->regbase + WMT_GOVR_TIMING_V_SYNC);\n\n\twritel(1, fbi->regbase + WMT_GOVR_TG);\n\n\treturn 0;\n}\n\n\nstatic int wm8505fb_set_par(struct fb_info *info)\n{\n\tstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\n\n\tif (!fbi)\n\t\treturn -EINVAL;\n\n\tif (info->var.bits_per_pixel == 32) {\n\t\tinfo->var.red.offset = 16;\n\t\tinfo->var.red.length = 8;\n\t\tinfo->var.red.msb_right = 0;\n\t\tinfo->var.green.offset = 8;\n\t\tinfo->var.green.length = 8;\n\t\tinfo->var.green.msb_right = 0;\n\t\tinfo->var.blue.offset = 0;\n\t\tinfo->var.blue.length = 8;\n\t\tinfo->var.blue.msb_right = 0;\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tinfo->fix.line_length = info->var.xres_virtual << 2;\n\t} else if (info->var.bits_per_pixel == 16) {\n\t\tinfo->var.red.offset = 11;\n\t\tinfo->var.red.length = 5;\n\t\tinfo->var.red.msb_right = 0;\n\t\tinfo->var.green.offset = 5;\n\t\tinfo->var.green.length = 6;\n\t\tinfo->var.green.msb_right = 0;\n\t\tinfo->var.blue.offset = 0;\n\t\tinfo->var.blue.length = 5;\n\t\tinfo->var.blue.msb_right = 0;\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tinfo->fix.line_length = info->var.xres_virtual << 1;\n\t}\n\n\twm8505fb_set_timing(info);\n\n\twritel(fbi->contrast<<16 | fbi->contrast<<8 | fbi->contrast,\n\t\tfbi->regbase + WMT_GOVR_CONTRAST);\n\n\treturn 0;\n}\n\nstatic ssize_t contrast_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\n\n\treturn sprintf(buf, \"%u\\n\", fbi->contrast);\n}\n\nstatic ssize_t contrast_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct fb_info *info = dev_get_drvdata(dev);\n\tstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\n\tunsigned long tmp;\n\n\tif (kstrtoul(buf, 10, &tmp) || (tmp > 0xff))\n\t\treturn -EINVAL;\n\tfbi->contrast = tmp;\n\n\twm8505fb_set_par(info);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(contrast);\n\nstatic struct attribute *wm8505fb_attrs[] = {\n\t&dev_attr_contrast.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(wm8505fb);\n\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\nstatic int wm8505fb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t   unsigned blue, unsigned transp,\n\t\t\t   struct fb_info *info) {\n\tstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\n\tint ret = 1;\n\tunsigned int val;\n\tif (regno >= 256)\n\t\treturn -EINVAL;\n\n\tif (info->var.grayscale)\n\t\tred = green = blue =\n\t\t\t(19595 * red + 38470 * green + 7471 * blue) >> 16;\n\n\tswitch (fbi->fb.fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\tif (regno < 16) {\n\t\t\tu32 *pal = info->pseudo_palette;\n\n\t\t\tval  = chan_to_field(red, &fbi->fb.var.red);\n\t\t\tval |= chan_to_field(green, &fbi->fb.var.green);\n\t\t\tval |= chan_to_field(blue, &fbi->fb.var.blue);\n\n\t\t\tpal[regno] = val;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int wm8505fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info)\n{\n\tstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\n\n\twritel(var->xoffset, fbi->regbase + WMT_GOVR_XPAN);\n\twritel(var->yoffset, fbi->regbase + WMT_GOVR_YPAN);\n\treturn 0;\n}\n\nstatic int wm8505fb_blank(int blank, struct fb_info *info)\n{\n\tstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\n\t\twm8505fb_set_timing(info);\n\t\tbreak;\n\tdefault:\n\t\twritel(0,  fbi->regbase + WMT_GOVR_TIMING_V_SYNC);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct fb_ops wm8505fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_set_par\t= wm8505fb_set_par,\n\t.fb_setcolreg\t= wm8505fb_setcolreg,\n\t.fb_fillrect\t= wmt_ge_fillrect,\n\t.fb_copyarea\t= wmt_ge_copyarea,\n\t.fb_imageblit\t= sys_imageblit,\n\t.fb_sync\t= wmt_ge_sync,\n\t.fb_pan_display\t= wm8505fb_pan_display,\n\t.fb_blank\t= wm8505fb_blank,\n};\n\nstatic int wm8505fb_probe(struct platform_device *pdev)\n{\n\tstruct wm8505fb_info\t*fbi;\n\tstruct display_timings *disp_timing;\n\tvoid\t\t\t*addr;\n\tint ret;\n\n\tstruct fb_videomode\tmode;\n\tu32\t\t\tbpp;\n\tdma_addr_t fb_mem_phys;\n\tunsigned long fb_mem_len;\n\tvoid *fb_mem_virt;\n\n\tfbi = devm_kzalloc(&pdev->dev, sizeof(struct wm8505fb_info) +\n\t\t\tsizeof(u32) * 16, GFP_KERNEL);\n\tif (!fbi)\n\t\treturn -ENOMEM;\n\n\tstrcpy(fbi->fb.fix.id, DRIVER_NAME);\n\n\tfbi->fb.fix.type\t= FB_TYPE_PACKED_PIXELS;\n\tfbi->fb.fix.xpanstep\t= 1;\n\tfbi->fb.fix.ypanstep\t= 1;\n\tfbi->fb.fix.ywrapstep\t= 0;\n\tfbi->fb.fix.accel\t= FB_ACCEL_NONE;\n\n\tfbi->fb.fbops\t\t= &wm8505fb_ops;\n\tfbi->fb.flags\t\t= FBINFO_HWACCEL_COPYAREA\n\t\t\t\t| FBINFO_HWACCEL_FILLRECT\n\t\t\t\t| FBINFO_HWACCEL_XPAN\n\t\t\t\t| FBINFO_HWACCEL_YPAN\n\t\t\t\t| FBINFO_VIRTFB\n\t\t\t\t| FBINFO_PARTIAL_PAN_OK;\n\tfbi->fb.node\t\t= -1;\n\n\taddr = fbi;\n\taddr = addr + sizeof(struct wm8505fb_info);\n\tfbi->fb.pseudo_palette\t= addr;\n\n\tfbi->regbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(fbi->regbase))\n\t\treturn PTR_ERR(fbi->regbase);\n\n\tdisp_timing = of_get_display_timings(pdev->dev.of_node);\n\tif (!disp_timing)\n\t\treturn -EINVAL;\n\n\tret = of_get_fb_videomode(pdev->dev.of_node, &mode, OF_USE_NATIVE_MODE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"bits-per-pixel\", &bpp);\n\tif (ret)\n\t\treturn ret;\n\n\tfb_videomode_to_var(&fbi->fb.var, &mode);\n\n\tfbi->fb.var.nonstd\t\t= 0;\n\tfbi->fb.var.activate\t\t= FB_ACTIVATE_NOW;\n\n\tfbi->fb.var.height\t\t= -1;\n\tfbi->fb.var.width\t\t= -1;\n\n\t \n\tfb_mem_len = mode.xres * mode.yres * 2 * (bpp / 8);\n\tfb_mem_virt = dmam_alloc_coherent(&pdev->dev, fb_mem_len, &fb_mem_phys,\n\t\t\t\tGFP_KERNEL);\n\tif (!fb_mem_virt) {\n\t\tpr_err(\"%s: Failed to allocate framebuffer\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfbi->fb.var.xres_virtual\t= mode.xres;\n\tfbi->fb.var.yres_virtual\t= mode.yres * 2;\n\tfbi->fb.var.bits_per_pixel\t= bpp;\n\n\tfbi->fb.fix.smem_start\t\t= fb_mem_phys;\n\tfbi->fb.fix.smem_len\t\t= fb_mem_len;\n\tfbi->fb.screen_buffer\t\t= fb_mem_virt;\n\tfbi->fb.screen_size\t\t= fb_mem_len;\n\n\tfbi->contrast = 0x10;\n\tret = wm8505fb_set_par(&fbi->fb);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to set parameters\\n\");\n\t\treturn ret;\n\t}\n\n\tif (fb_alloc_cmap(&fbi->fb.cmap, 256, 0) < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate color map\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twm8505fb_init_hw(&fbi->fb);\n\n\tplatform_set_drvdata(pdev, fbi);\n\n\tret = register_framebuffer(&fbi->fb);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register framebuffer device: %d\\n\", ret);\n\t\tif (fbi->fb.cmap.len)\n\t\t\tfb_dealloc_cmap(&fbi->fb.cmap);\n\t\treturn ret;\n\t}\n\n\tfb_info(&fbi->fb, \"%s frame buffer at 0x%lx-0x%lx\\n\",\n\t\tfbi->fb.fix.id, fbi->fb.fix.smem_start,\n\t\tfbi->fb.fix.smem_start + fbi->fb.fix.smem_len - 1);\n\n\treturn 0;\n}\n\nstatic void wm8505fb_remove(struct platform_device *pdev)\n{\n\tstruct wm8505fb_info *fbi = platform_get_drvdata(pdev);\n\n\tunregister_framebuffer(&fbi->fb);\n\n\twritel(0, fbi->regbase);\n\n\tif (fbi->fb.cmap.len)\n\t\tfb_dealloc_cmap(&fbi->fb.cmap);\n}\n\nstatic const struct of_device_id wmt_dt_ids[] = {\n\t{ .compatible = \"wm,wm8505-fb\", },\n\t{}\n};\n\nstatic struct platform_driver wm8505fb_driver = {\n\t.probe\t\t= wm8505fb_probe,\n\t.remove_new\t= wm8505fb_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = wmt_dt_ids,\n\t\t.dev_groups\t= wm8505fb_groups,\n\t},\n};\n\nmodule_platform_driver(wm8505fb_driver);\n\nMODULE_AUTHOR(\"Ed Spiridonov <edo.rus@gmail.com>\");\nMODULE_DESCRIPTION(\"Framebuffer driver for WMT WM8505\");\nMODULE_DEVICE_TABLE(of, wmt_dt_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}