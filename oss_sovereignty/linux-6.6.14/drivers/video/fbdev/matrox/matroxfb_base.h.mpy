{
  "module_name": "matroxfb_base.h",
  "hash_id": "11219a63a9a1851b781f75afff19a02f366fab75848178e25596832b78a1c8d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/matrox/matroxfb_base.h",
  "human_readable_source": " \n \n#ifndef __MATROXFB_H__\n#define __MATROXFB_H__\n\n \n#undef MATROXFB_DEBUG\n\n \n \n#undef MATROXFB_DEBUG_HEAVY\n\n \n \n#undef MATROXFB_DEBUG_LOOP\n\n \n#undef MATROXFB_DEBUG_REG\n\n \n#undef MATROXFB_USE_SPINLOCKS\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/console.h>\n#include <linux/selection.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/kd.h>\n\n#include <asm/io.h>\n#include <asm/unaligned.h>\n\n#if defined(CONFIG_PPC_PMAC)\n#include \"../macmodes.h\"\n#endif\n\n#ifdef MATROXFB_DEBUG\n\n#define DEBUG\n#define DBG(x)\t\tprintk(KERN_DEBUG \"matroxfb: %s\\n\", (x));\n\n#ifdef MATROXFB_DEBUG_HEAVY\n#define DBG_HEAVY(x)\tDBG(x)\n#else  \n#define DBG_HEAVY(x)\t \n#endif  \n\n#ifdef MATROXFB_DEBUG_LOOP\n#define DBG_LOOP(x)\tDBG(x)\n#else  \n#define DBG_LOOP(x)\t \n#endif  \n\n#ifdef MATROXFB_DEBUG_REG\n#define DBG_REG(x)\tDBG(x)\n#else  \n#define DBG_REG(x)\t \n#endif  \n\n#else  \n\n#define DBG(x)\t\t \n#define DBG_HEAVY(x)\t \n#define DBG_REG(x)\t \n#define DBG_LOOP(x)\t \n\n#endif  \n\n#ifdef DEBUG\n#define dprintk(X...)\tprintk(X)\n#else\n#define dprintk(X...)\tno_printk(X)\n#endif\n\n#ifndef PCI_SS_VENDOR_ID_SIEMENS_NIXDORF\n#define PCI_SS_VENDOR_ID_SIEMENS_NIXDORF\t0x110A\n#endif\n#ifndef PCI_SS_VENDOR_ID_MATROX\n#define PCI_SS_VENDOR_ID_MATROX\t\tPCI_VENDOR_ID_MATROX\n#endif\n\n#ifndef PCI_SS_ID_MATROX_PRODUCTIVA_G100_AGP\n#define PCI_SS_ID_MATROX_GENERIC\t\t0xFF00\n#define PCI_SS_ID_MATROX_PRODUCTIVA_G100_AGP\t0xFF01\n#define PCI_SS_ID_MATROX_MYSTIQUE_G200_AGP\t0xFF02\n#define PCI_SS_ID_MATROX_MILLENIUM_G200_AGP\t0xFF03\n#define PCI_SS_ID_MATROX_MARVEL_G200_AGP\t0xFF04\n#define PCI_SS_ID_MATROX_MGA_G100_PCI\t\t0xFF05\n#define PCI_SS_ID_MATROX_MGA_G100_AGP\t\t0x1001\n#define PCI_SS_ID_MATROX_MILLENNIUM_G400_MAX_AGP\t0x2179\n#define PCI_SS_ID_SIEMENS_MGA_G100_AGP\t\t0x001E  \n#define PCI_SS_ID_SIEMENS_MGA_G200_AGP\t\t0x0032  \n#endif\n\n#define MX_VISUAL_TRUECOLOR\tFB_VISUAL_DIRECTCOLOR\n#define MX_VISUAL_DIRECTCOLOR\tFB_VISUAL_TRUECOLOR\n#define MX_VISUAL_PSEUDOCOLOR\tFB_VISUAL_PSEUDOCOLOR\n\n#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)\n\n \n#undef NEED_DAC1064\n#if defined(CONFIG_FB_MATROX_MYSTIQUE) || defined(CONFIG_FB_MATROX_G)\n#define NEED_DAC1064 1\n#endif\n\ntypedef struct {\n\tvoid __iomem*\tvaddr;\n} vaddr_t;\n\nstatic inline unsigned int mga_readb(vaddr_t va, unsigned int offs) {\n\treturn readb(va.vaddr + offs);\n}\n\nstatic inline void mga_writeb(vaddr_t va, unsigned int offs, u_int8_t value) {\n\twriteb(value, va.vaddr + offs);\n}\n\nstatic inline void mga_writew(vaddr_t va, unsigned int offs, u_int16_t value) {\n\twritew(value, va.vaddr + offs);\n}\n\nstatic inline u_int32_t mga_readl(vaddr_t va, unsigned int offs) {\n\treturn readl(va.vaddr + offs);\n}\n\nstatic inline void mga_writel(vaddr_t va, unsigned int offs, u_int32_t value) {\n\twritel(value, va.vaddr + offs);\n}\n\nstatic inline void mga_memcpy_toio(vaddr_t va, const void* src, int len) {\n#if defined(__alpha__) || defined(__i386__) || defined(__x86_64__)\n\t \n\tiowrite32_rep(va.vaddr, src, len >> 2);\n#else\n        u_int32_t __iomem* addr = va.vaddr;\n\n\tif ((unsigned long)src & 3) {\n\t\twhile (len >= 4) {\n\t\t\tfb_writel(get_unaligned((u32 *)src), addr);\n\t\t\taddr++;\n\t\t\tlen -= 4;\n\t\t\tsrc += 4;\n\t\t}\n\t} else {\n\t\twhile (len >= 4) {\n\t\t\tfb_writel(*(u32 *)src, addr);\n\t\t\taddr++;\n\t\t\tlen -= 4;\n\t\t\tsrc += 4;\n\t\t}\n\t}\n#endif\n}\n\nstatic inline void vaddr_add(vaddr_t* va, unsigned long offs) {\n\tva->vaddr += offs;\n}\n\nstatic inline void __iomem* vaddr_va(vaddr_t va) {\n\treturn va.vaddr;\n}\n\nstruct my_timming {\n\tunsigned int pixclock;\n\tint mnp;\n\tunsigned int crtc;\n\tunsigned int HDisplay;\n\tunsigned int HSyncStart;\n\tunsigned int HSyncEnd;\n\tunsigned int HTotal;\n\tunsigned int VDisplay;\n\tunsigned int VSyncStart;\n\tunsigned int VSyncEnd;\n\tunsigned int VTotal;\n\tunsigned int sync;\n\tint\t     dblscan;\n\tint\t     interlaced;\n\tunsigned int delay;\t \n};\n\nenum { M_SYSTEM_PLL, M_PIXEL_PLL_A, M_PIXEL_PLL_B, M_PIXEL_PLL_C, M_VIDEO_PLL };\n\nstruct matrox_pll_cache {\n\tunsigned int\tvalid;\n\tstruct {\n\t\tunsigned int\tmnp_key;\n\t\tunsigned int\tmnp_value;\n\t\t      } data[4];\n};\n\nstruct matrox_pll_limits {\n\tunsigned int\tvcomin;\n\tunsigned int\tvcomax;\n};\n\nstruct matrox_pll_features {\n\tunsigned int\tvco_freq_min;\n\tunsigned int\tref_freq;\n\tunsigned int\tfeed_div_min;\n\tunsigned int\tfeed_div_max;\n\tunsigned int\tin_div_min;\n\tunsigned int\tin_div_max;\n\tunsigned int\tpost_shift_max;\n};\n\nstruct matroxfb_par\n{\n\tunsigned int\tfinal_bppShift;\n\tunsigned int\tcmap_len;\n\tstruct {\n\t\tunsigned int bytes;\n\t\tunsigned int pixels;\n\t\tunsigned int chunks;\n\t\t      } ydstorg;\n};\n\nstruct matrox_fb_info;\n\nstruct matrox_DAC1064_features {\n\tu_int8_t\txvrefctrl;\n\tu_int8_t\txmiscctrl;\n};\n\n \nstruct mavenregs {\n\tu_int8_t regs[256];\n\tint\t mode;\n\tint\t vlines;\n\tint\t xtal;\n\tint\t fv;\n\n\tu_int16_t htotal;\n\tu_int16_t hcorr;\n};\n\nstruct matrox_crtc2 {\n\tu_int32_t ctl;\n};\n\nstruct matrox_hw_state {\n\tu_int32_t\tMXoptionReg;\n\tunsigned char\tDACclk[6];\n\tunsigned char\tDACreg[80];\n\tunsigned char\tMiscOutReg;\n\tunsigned char\tDACpal[768];\n\tunsigned char\tCRTC[25];\n\tunsigned char\tCRTCEXT[9];\n\tunsigned char\tSEQ[5];\n\t \n\tunsigned char\tGCTL[9];\n\t \n\tunsigned char\tATTR[21];\n\n\t \n\tstruct mavenregs\tmaven;\n\n\tstruct matrox_crtc2\tcrtc2;\n};\n\nstruct matrox_accel_data {\n#ifdef CONFIG_FB_MATROX_MILLENIUM\n\tunsigned char\tramdac_rev;\n#endif\n\tu_int32_t\tm_dwg_rect;\n\tu_int32_t\tm_opmode;\n\tu_int32_t\tm_access;\n\tu_int32_t\tm_pitch;\n};\n\nstruct v4l2_queryctrl;\nstruct v4l2_control;\n\nstruct matrox_altout {\n\tconst char\t*name;\n\tint\t\t(*compute)(void* altout_dev, struct my_timming* input);\n\tint\t\t(*program)(void* altout_dev);\n\tint\t\t(*start)(void* altout_dev);\n\tint\t\t(*verifymode)(void* altout_dev, u_int32_t mode);\n\tint\t\t(*getqueryctrl)(void* altout_dev,\n\t\t\t\t\tstruct v4l2_queryctrl* ctrl);\n\tint\t\t(*getctrl)(void *altout_dev,\n\t\t\t\t   struct v4l2_control* ctrl);\n\tint\t\t(*setctrl)(void *altout_dev,\n\t\t\t\t   struct v4l2_control* ctrl);\n};\n\n#define MATROXFB_SRC_NONE\t0\n#define MATROXFB_SRC_CRTC1\t1\n#define MATROXFB_SRC_CRTC2\t2\n\nenum mga_chip { MGA_2064, MGA_2164, MGA_1064, MGA_1164, MGA_G100, MGA_G200, MGA_G400, MGA_G450, MGA_G550 };\n\nstruct matrox_bios {\n\tunsigned int\tbios_valid : 1;\n\tunsigned int\tpins_len;\n\tunsigned char\tpins[128];\n\tstruct {\n\t\tunsigned char vMaj, vMin, vRev;\n\t\t      } version;\n\tstruct {\n\t\tunsigned char state, tvout;\n\t\t      } output;\n};\n\nstruct matrox_switch;\nstruct matroxfb_driver;\nstruct matroxfb_dh_fb_info;\n\nstruct matrox_vsync {\n\twait_queue_head_t\twait;\n\tunsigned int\t\tcnt;\n};\n\nstruct matrox_fb_info {\n\tstruct fb_info\t\tfbcon;\n\n\tstruct list_head\tnext_fb;\n\n\tint\t\t\tdead;\n\tint                     initialized;\n\tunsigned int\t\tusecount;\n\n\tunsigned int\t\tuserusecount;\n\tunsigned long\t\tirq_flags;\n\n\tstruct matroxfb_par\tcurr;\n\tstruct matrox_hw_state\thw;\n\n\tstruct matrox_accel_data accel;\n\n\tstruct pci_dev*\t\tpcidev;\n\n\tstruct {\n\t\tstruct matrox_vsync\tvsync;\n\t\tunsigned int\tpixclock;\n\t\tint\t\tmnp;\n\t\tint\t\tpanpos;\n\t\t\t      } crtc1;\n\tstruct {\n\t\tstruct matrox_vsync\tvsync;\n\t\tunsigned int \tpixclock;\n\t\tint\t\tmnp;\n\tstruct matroxfb_dh_fb_info*\tinfo;\n\tstruct rw_semaphore\tlock;\n\t\t\t      } crtc2;\n\tstruct {\n\tstruct rw_semaphore\tlock;\n\tstruct {\n\t\tint brightness, contrast, saturation, hue, gamma;\n\t\tint testout, deflicker;\n\t\t\t\t} tvo_params;\n\t\t\t      } altout;\n#define MATROXFB_MAX_OUTPUTS\t\t3\n\tstruct {\n\tunsigned int\t\tsrc;\n\tstruct matrox_altout*\toutput;\n\tvoid*\t\t\tdata;\n\tunsigned int\t\tmode;\n\tunsigned int\t\tdefault_src;\n\t\t\t      } outputs[MATROXFB_MAX_OUTPUTS];\n\n#define MATROXFB_MAX_FB_DRIVERS\t\t5\n\tstruct matroxfb_driver* (drivers[MATROXFB_MAX_FB_DRIVERS]);\n\tvoid*\t\t\t(drivers_data[MATROXFB_MAX_FB_DRIVERS]);\n\tunsigned int\t\tdrivers_count;\n\n\tstruct {\n\tunsigned long\tbase;\t \n\tvaddr_t\t\tvbase;\t \n\tunsigned int\tlen;\n\tunsigned int\tlen_usable;\n\tunsigned int\tlen_maximum;\n\t\t      } video;\n\n\tstruct {\n\tunsigned long\tbase;\t \n\tvaddr_t\t\tvbase;\t \n\tunsigned int\tlen;\n\t\t      } mmio;\n\n\tunsigned int\tmax_pixel_clock;\n\tunsigned int\tmax_pixel_clock_panellink;\n\n\tstruct matrox_switch*\thw_switch;\n\n\tstruct {\n\t\tstruct matrox_pll_features pll;\n\t\tstruct matrox_DAC1064_features DAC1064;\n\t\t\t      } features;\n\tstruct {\n\t\tspinlock_t\tDAC;\n\t\tspinlock_t\taccel;\n\t\t\t      } lock;\n\n\tenum mga_chip\t\tchip;\n\n\tint\t\t\tinterleave;\n\tint\t\t\tmillenium;\n\tint\t\t\tmilleniumII;\n\tstruct {\n\t\tint\t\tcfb4;\n\t\tconst int*\tvxres;\n\t\tint\t\tcross4MB;\n\t\tint\t\ttext;\n\t\tint\t\tplnwt;\n\t\tint\t\tsrcorg;\n\t\t\t      } capable;\n\tint\t\t\twc_cookie;\n\tstruct {\n\t\tint\t\tprecise_width;\n\t\tint\t\tmga_24bpp_fix;\n\t\tint\t\tnovga;\n\t\tint\t\tnobios;\n\t\tint\t\tnopciretry;\n\t\tint\t\tnoinit;\n\t\tint\t\tsgram;\n\t\tint\t\tsupport32MB;\n\n\t\tint\t\taccelerator;\n\t\tint\t\ttext_type_aux;\n\t\tint\t\tvideo64bits;\n\t\tint\t\tcrtc2;\n\t\tint\t\tmaven_capable;\n\t\tunsigned int\tvgastep;\n\t\tunsigned int\ttextmode;\n\t\tunsigned int\ttextstep;\n\t\tunsigned int\ttextvram;\t \n\t\tunsigned int\tydstorg;\t \n\t\t\t\t\t\t \n\t\tint\t\tmemtype;\n\t\tint\t\tg450dac;\n\t\tint\t\tdfp_type;\n\t\tint\t\tpanellink;\t \n\t\tint\t\tdualhead;\n\t\tunsigned int\tfbResource;\n\t\t\t      } devflags;\n\tstruct fb_ops\t\tfbops;\n\tstruct matrox_bios\tbios;\n\tstruct {\n\t\tstruct matrox_pll_limits\tpixel;\n\t\tstruct matrox_pll_limits\tsystem;\n\t\tstruct matrox_pll_limits\tvideo;\n\t\t\t      } limits;\n\tstruct {\n\t\tstruct matrox_pll_cache\tpixel;\n\t\tstruct matrox_pll_cache\tsystem;\n\t\tstruct matrox_pll_cache\tvideo;\n\t\t\t\t      } cache;\n\tstruct {\n\t\tstruct {\n\t\t\tunsigned int\tvideo;\n\t\t\tunsigned int\tsystem;\n\t\t\t\t      } pll;\n\t\tstruct {\n\t\t\tu_int32_t\topt;\n\t\t\tu_int32_t\topt2;\n\t\t\tu_int32_t\topt3;\n\t\t\tu_int32_t\tmctlwtst;\n\t\t\tu_int32_t\tmctlwtst_core;\n\t\t\tu_int32_t\tmemmisc;\n\t\t\tu_int32_t\tmemrdbk;\n\t\t\tu_int32_t\tmaccess;\n\t\t\t\t      } reg;\n\t\tstruct {\n\t\t\tunsigned int\tddr:1,\n\t\t\t                emrswen:1,\n\t\t\t\t\tdll:1;\n\t\t\t\t      } memory;\n\t\t\t      } values;\n\tu_int32_t cmap[16];\n};\n\n#define info2minfo(info) container_of(info, struct matrox_fb_info, fbcon)\n\nstruct matrox_switch {\n\tint\t(*preinit)(struct matrox_fb_info *minfo);\n\tvoid\t(*reset)(struct matrox_fb_info *minfo);\n\tint\t(*init)(struct matrox_fb_info *minfo, struct my_timming*);\n\tvoid\t(*restore)(struct matrox_fb_info *minfo);\n};\n\nstruct matroxfb_driver {\n\tstruct list_head\tnode;\n\tchar*\t\t\tname;\n\tvoid*\t\t\t(*probe)(struct matrox_fb_info* info);\n\tvoid\t\t\t(*remove)(struct matrox_fb_info* info, void* data);\n};\n\nint matroxfb_register_driver(struct matroxfb_driver* drv);\nvoid matroxfb_unregister_driver(struct matroxfb_driver* drv);\n\n#define PCI_OPTION_REG\t0x40\n#define   PCI_OPTION_ENABLE_ROM\t\t0x40000000\n\n#define PCI_MGA_INDEX\t0x44\n#define PCI_MGA_DATA\t0x48\n#define PCI_OPTION2_REG\t0x50\n#define PCI_OPTION3_REG\t0x54\n#define PCI_MEMMISC_REG\t0x58\n\n#define M_DWGCTL\t0x1C00\n#define M_MACCESS\t0x1C04\n#define M_CTLWTST\t0x1C08\n\n#define M_PLNWT\t\t0x1C1C\n\n#define M_BCOL\t\t0x1C20\n#define M_FCOL\t\t0x1C24\n\n#define M_SGN\t\t0x1C58\n#define M_LEN\t\t0x1C5C\n#define M_AR0\t\t0x1C60\n#define M_AR1\t\t0x1C64\n#define M_AR2\t\t0x1C68\n#define M_AR3\t\t0x1C6C\n#define M_AR4\t\t0x1C70\n#define M_AR5\t\t0x1C74\n#define M_AR6\t\t0x1C78\n\n#define M_CXBNDRY\t0x1C80\n#define M_FXBNDRY\t0x1C84\n#define M_YDSTLEN\t0x1C88\n#define M_PITCH\t\t0x1C8C\n#define M_YDST\t\t0x1C90\n#define M_YDSTORG\t0x1C94\n#define M_YTOP\t\t0x1C98\n#define M_YBOT\t\t0x1C9C\n\n \n#define M_CACHEFLUSH\t0x1FFF\n\n#define M_EXEC\t\t0x0100\n\n#define M_DWG_TRAP\t0x04\n#define M_DWG_BITBLT\t0x08\n#define M_DWG_ILOAD\t0x09\n\n#define M_DWG_LINEAR\t0x0080\n#define M_DWG_SOLID\t0x0800\n#define M_DWG_ARZERO\t0x1000\n#define M_DWG_SGNZERO\t0x2000\n#define M_DWG_SHIFTZERO\t0x4000\n\n#define M_DWG_REPLACE\t0x000C0000\n#define M_DWG_REPLACE2\t(M_DWG_REPLACE | 0x40)\n#define M_DWG_XOR\t0x00060010\n\n#define M_DWG_BFCOL\t0x04000000\n#define M_DWG_BMONOWF\t0x08000000\n\n#define M_DWG_TRANSC\t0x40000000\n\n#define M_FIFOSTATUS\t0x1E10\n#define M_STATUS\t0x1E14\n#define M_ICLEAR\t0x1E18\n#define M_IEN\t\t0x1E1C\n\n#define M_VCOUNT\t0x1E20\n\n#define M_RESET\t\t0x1E40\n#define M_MEMRDBK\t0x1E44\n\n#define M_AGP2PLL\t0x1E4C\n\n#define M_OPMODE\t0x1E54\n#define     M_OPMODE_DMA_GEN_WRITE\t0x00\n#define     M_OPMODE_DMA_BLIT\t\t0x04\n#define     M_OPMODE_DMA_VECTOR_WRITE\t0x08\n#define     M_OPMODE_DMA_LE\t\t0x0000\t\t \n#define     M_OPMODE_DMA_BE_8BPP\t0x0000\n#define     M_OPMODE_DMA_BE_16BPP\t0x0100\n#define     M_OPMODE_DMA_BE_32BPP\t0x0200\n#define     M_OPMODE_DIR_LE\t\t0x000000\t \n#define     M_OPMODE_DIR_BE_8BPP\t0x000000\n#define     M_OPMODE_DIR_BE_16BPP\t0x010000\n#define     M_OPMODE_DIR_BE_32BPP\t0x020000\n\n#define M_ATTR_INDEX\t0x1FC0\n#define M_ATTR_DATA\t0x1FC1\n\n#define M_MISC_REG\t0x1FC2\n#define M_3C2_RD\t0x1FC2\n\n#define M_SEQ_INDEX\t0x1FC4\n#define M_SEQ_DATA\t0x1FC5\n#define     M_SEQ1\t\t0x01\n#define        M_SEQ1_SCROFF\t\t0x20\n\n#define M_MISC_REG_READ\t0x1FCC\n\n#define M_GRAPHICS_INDEX 0x1FCE\n#define M_GRAPHICS_DATA\t0x1FCF\n\n#define M_CRTC_INDEX\t0x1FD4\n\n#define M_ATTR_RESET\t0x1FDA\n#define M_3DA_WR\t0x1FDA\n#define M_INSTS1\t0x1FDA\n\n#define M_EXTVGA_INDEX\t0x1FDE\n#define M_EXTVGA_DATA\t0x1FDF\n\n \n#define M_SRCORG\t0x2CB4\n#define M_DSTORG\t0x2CB8\n\n#define M_RAMDAC_BASE\t0x3C00\n\n \n#define M_DAC_REG\t(M_RAMDAC_BASE+0)\n#define M_DAC_VAL\t(M_RAMDAC_BASE+1)\n#define M_PALETTE_MASK\t(M_RAMDAC_BASE+2)\n\n#define M_X_INDEX\t0x00\n#define M_X_DATAREG\t0x0A\n\n#define DAC_XGENIOCTRL\t\t0x2A\n#define DAC_XGENIODATA\t\t0x2B\n\n#define M_C2CTL\t\t0x3C10\n\n#define MX_OPTION_BSWAP         0x00000000\n\n#ifdef __LITTLE_ENDIAN\n#define M_OPMODE_4BPP\t(M_OPMODE_DMA_LE | M_OPMODE_DIR_LE | M_OPMODE_DMA_BLIT)\n#define M_OPMODE_8BPP\t(M_OPMODE_DMA_LE | M_OPMODE_DIR_LE | M_OPMODE_DMA_BLIT)\n#define M_OPMODE_16BPP\t(M_OPMODE_DMA_LE | M_OPMODE_DIR_LE | M_OPMODE_DMA_BLIT)\n#define M_OPMODE_24BPP\t(M_OPMODE_DMA_LE | M_OPMODE_DIR_LE | M_OPMODE_DMA_BLIT)\n#define M_OPMODE_32BPP\t(M_OPMODE_DMA_LE | M_OPMODE_DIR_LE | M_OPMODE_DMA_BLIT)\n#else\n#ifdef __BIG_ENDIAN\n#define M_OPMODE_4BPP\t(M_OPMODE_DMA_LE | M_OPMODE_DIR_LE       | M_OPMODE_DMA_BLIT)\t \n#define M_OPMODE_8BPP\t(M_OPMODE_DMA_LE | M_OPMODE_DIR_BE_8BPP  | M_OPMODE_DMA_BLIT)\n#define M_OPMODE_16BPP\t(M_OPMODE_DMA_LE | M_OPMODE_DIR_BE_16BPP | M_OPMODE_DMA_BLIT)\n#define M_OPMODE_24BPP\t(M_OPMODE_DMA_LE | M_OPMODE_DIR_BE_8BPP  | M_OPMODE_DMA_BLIT)\t \n#define M_OPMODE_32BPP\t(M_OPMODE_DMA_LE | M_OPMODE_DIR_BE_32BPP | M_OPMODE_DMA_BLIT)\n#else\n#error \"Byte ordering have to be defined. Cannot continue.\"\n#endif\n#endif\n\n#define mga_inb(addr)\t\tmga_readb(minfo->mmio.vbase, (addr))\n#define mga_inl(addr)\t\tmga_readl(minfo->mmio.vbase, (addr))\n#define mga_outb(addr,val)\tmga_writeb(minfo->mmio.vbase, (addr), (val))\n#define mga_outw(addr,val)\tmga_writew(minfo->mmio.vbase, (addr), (val))\n#define mga_outl(addr,val)\tmga_writel(minfo->mmio.vbase, (addr), (val))\n#define mga_readr(port,idx)\t(mga_outb((port),(idx)), mga_inb((port)+1))\n#define mga_setr(addr,port,val)\tmga_outw(addr, ((val)<<8) | (port))\n\n#define mga_fifo(n)\tdo {} while ((mga_inl(M_FIFOSTATUS) & 0xFF) < (n))\n\n#define WaitTillIdle()\tdo { mga_inl(M_STATUS); do {} while (mga_inl(M_STATUS) & 0x10000); } while (0)\n\n \n#ifdef CONFIG_FB_MATROX_MILLENIUM\n#define isInterleave(x)\t (x->interleave)\n#define isMillenium(x)\t (x->millenium)\n#define isMilleniumII(x) (x->milleniumII)\n#else\n#define isInterleave(x)  (0)\n#define isMillenium(x)\t (0)\n#define isMilleniumII(x) (0)\n#endif\n\n#define matroxfb_DAC_lock()                   spin_lock(&minfo->lock.DAC)\n#define matroxfb_DAC_unlock()                 spin_unlock(&minfo->lock.DAC)\n#define matroxfb_DAC_lock_irqsave(flags)      spin_lock_irqsave(&minfo->lock.DAC, flags)\n#define matroxfb_DAC_unlock_irqrestore(flags) spin_unlock_irqrestore(&minfo->lock.DAC, flags)\nextern void matroxfb_DAC_out(const struct matrox_fb_info *minfo, int reg,\n\t\t\t     int val);\nextern int matroxfb_DAC_in(const struct matrox_fb_info *minfo, int reg);\nextern void matroxfb_var2my(struct fb_var_screeninfo* fvsi, struct my_timming* mt);\nextern int matroxfb_wait_for_sync(struct matrox_fb_info *minfo, u_int32_t crtc);\nextern int matroxfb_enable_irq(struct matrox_fb_info *minfo, int reenable);\n\n#ifdef MATROXFB_USE_SPINLOCKS\n#define CRITBEGIN  spin_lock_irqsave(&minfo->lock.accel, critflags);\n#define CRITEND\t   spin_unlock_irqrestore(&minfo->lock.accel, critflags);\n#define CRITFLAGS  unsigned long critflags;\n#else\n#define CRITBEGIN\n#define CRITEND\n#define CRITFLAGS\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}