{
  "module_name": "matroxfb_g450.c",
  "hash_id": "b38ebcb45a3e4228696301c8fa1d1a346453b5a73b2769c1f889ce7c61a3b69e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/matrox/matroxfb_g450.c",
  "human_readable_source": "\n \n\n#include \"matroxfb_base.h\"\n#include \"matroxfb_misc.h\"\n#include \"matroxfb_DAC1064.h\"\n#include \"g450_pll.h\"\n#include <linux/matroxfb.h>\n#include <asm/div64.h>\n\n#include \"matroxfb_g450.h\"\n\n \nstruct mctl {\n\tstruct v4l2_queryctrl desc;\n\tsize_t control;\n};\n\n#define BLMIN\t0xF3\n#define WLMAX\t0x3FF\n\nstatic const struct mctl g450_controls[] =\n{\t{ { V4L2_CID_BRIGHTNESS, V4L2_CTRL_TYPE_INTEGER, \n\t  \"brightness\",\n\t  0, WLMAX-BLMIN, 1, 370-BLMIN, \n\t  0,\n\t}, offsetof(struct matrox_fb_info, altout.tvo_params.brightness) },\n\t{ { V4L2_CID_CONTRAST, V4L2_CTRL_TYPE_INTEGER, \n\t  \"contrast\",\n\t  0, 1023, 1, 127, \n\t  0,\n\t}, offsetof(struct matrox_fb_info, altout.tvo_params.contrast) },\n\t{ { V4L2_CID_SATURATION, V4L2_CTRL_TYPE_INTEGER,\n\t  \"saturation\",\n\t  0, 255, 1, 165, \n\t  0,\n\t}, offsetof(struct matrox_fb_info, altout.tvo_params.saturation) },\n\t{ { V4L2_CID_HUE, V4L2_CTRL_TYPE_INTEGER,\n\t  \"hue\",\n\t  0, 255, 1, 0, \n\t  0,\n\t}, offsetof(struct matrox_fb_info, altout.tvo_params.hue) },\n\t{ { MATROXFB_CID_TESTOUT, V4L2_CTRL_TYPE_BOOLEAN,\n\t  \"test output\",\n\t  0, 1, 1, 0, \n\t  0,\n\t}, offsetof(struct matrox_fb_info, altout.tvo_params.testout) },\n};\n\n#define G450CTRLS ARRAY_SIZE(g450_controls)\n\n \nstatic int get_ctrl_id(__u32 v4l2_id) {\n\tint i;\n\n\tfor (i = 0; i < G450CTRLS; i++) {\n\t\tif (v4l2_id < g450_controls[i].desc.id) {\n\t\t\tif (g450_controls[i].desc.id == 0x08000000) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (v4l2_id == g450_controls[i].desc.id) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic inline int *get_ctrl_ptr(struct matrox_fb_info *minfo, unsigned int idx)\n{\n\treturn (int*)((char*)minfo + g450_controls[idx].control);\n}\n\nstatic void tvo_fill_defaults(struct matrox_fb_info *minfo)\n{\n\tunsigned int i;\n\t\n\tfor (i = 0; i < G450CTRLS; i++) {\n\t\t*get_ctrl_ptr(minfo, i) = g450_controls[i].desc.default_value;\n\t}\n}\n\nstatic int cve2_get_reg(struct matrox_fb_info *minfo, int reg)\n{\n\tunsigned long flags;\n\tint val;\n\t\n\tmatroxfb_DAC_lock_irqsave(flags);\n\tmatroxfb_DAC_out(minfo, 0x87, reg);\n\tval = matroxfb_DAC_in(minfo, 0x88);\n\tmatroxfb_DAC_unlock_irqrestore(flags);\n\treturn val;\n}\n\nstatic void cve2_set_reg(struct matrox_fb_info *minfo, int reg, int val)\n{\n\tunsigned long flags;\n\n\tmatroxfb_DAC_lock_irqsave(flags);\n\tmatroxfb_DAC_out(minfo, 0x87, reg);\n\tmatroxfb_DAC_out(minfo, 0x88, val);\n\tmatroxfb_DAC_unlock_irqrestore(flags);\n}\n\nstatic void cve2_set_reg10(struct matrox_fb_info *minfo, int reg, int val)\n{\n\tunsigned long flags;\n\n\tmatroxfb_DAC_lock_irqsave(flags);\n\tmatroxfb_DAC_out(minfo, 0x87, reg);\n\tmatroxfb_DAC_out(minfo, 0x88, val >> 2);\n\tmatroxfb_DAC_out(minfo, 0x87, reg + 1);\n\tmatroxfb_DAC_out(minfo, 0x88, val & 3);\n\tmatroxfb_DAC_unlock_irqrestore(flags);\n}\n\nstatic void g450_compute_bwlevel(const struct matrox_fb_info *minfo, int *bl,\n\t\t\t\t int *wl)\n{\n\tconst int b = minfo->altout.tvo_params.brightness + BLMIN;\n\tconst int c = minfo->altout.tvo_params.contrast;\n\n\t*bl = max(b - c, BLMIN);\n\t*wl = min(b + c, WLMAX);\n}\n\nstatic int g450_query_ctrl(void* md, struct v4l2_queryctrl *p) {\n\tint i;\n\t\n\ti = get_ctrl_id(p->id);\n\tif (i >= 0) {\n\t\t*p = g450_controls[i].desc;\n\t\treturn 0;\n\t}\n\tif (i == -ENOENT) {\n\t\tstatic const struct v4l2_queryctrl disctrl = \n\t\t\t{ .flags = V4L2_CTRL_FLAG_DISABLED };\n\t\t\t\n\t\ti = p->id;\n\t\t*p = disctrl;\n\t\tp->id = i;\n\t\tsprintf(p->name, \"Ctrl #%08X\", i);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int g450_set_ctrl(void* md, struct v4l2_control *p) {\n\tint i;\n\tstruct matrox_fb_info *minfo = md;\n\t\n\ti = get_ctrl_id(p->id);\n\tif (i < 0) return -EINVAL;\n\n\t \n\tif (p->value == *get_ctrl_ptr(minfo, i)) return 0;\n\n\t \n\tif (p->value > g450_controls[i].desc.maximum) return -EINVAL;\n\tif (p->value < g450_controls[i].desc.minimum) return -EINVAL;\n\n\t \n\t*get_ctrl_ptr(minfo, i) = p->value;\n\n\tswitch (p->id) {\n\t\tcase V4L2_CID_BRIGHTNESS:\n\t\tcase V4L2_CID_CONTRAST:\n\t\t\t{\n\t\t\t\tint blacklevel, whitelevel;\n\t\t\t\tg450_compute_bwlevel(minfo, &blacklevel, &whitelevel);\n\t\t\t\tcve2_set_reg10(minfo, 0x0e, blacklevel);\n\t\t\t\tcve2_set_reg10(minfo, 0x1e, whitelevel);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_CID_SATURATION:\n\t\t\tcve2_set_reg(minfo, 0x20, p->value);\n\t\t\tcve2_set_reg(minfo, 0x22, p->value);\n\t\t\tbreak;\n\t\tcase V4L2_CID_HUE:\n\t\t\tcve2_set_reg(minfo, 0x25, p->value);\n\t\t\tbreak;\n\t\tcase MATROXFB_CID_TESTOUT:\n\t\t\t{\n\t\t\t\tunsigned char val = cve2_get_reg(minfo, 0x05);\n\t\t\t\tif (p->value) val |=  0x02;\n\t\t\t\telse          val &= ~0x02;\n\t\t\t\tcve2_set_reg(minfo, 0x05, val);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t\n\n\treturn 0;\n}\n\nstatic int g450_get_ctrl(void* md, struct v4l2_control *p) {\n\tint i;\n\tstruct matrox_fb_info *minfo = md;\n\t\n\ti = get_ctrl_id(p->id);\n\tif (i < 0) return -EINVAL;\n\tp->value = *get_ctrl_ptr(minfo, i);\n\treturn 0;\n}\n\nstruct output_desc {\n\tunsigned int\th_vis;\n\tunsigned int\th_f_porch;\n\tunsigned int\th_sync;\n\tunsigned int\th_b_porch;\n\tunsigned long long int\tchromasc;\n\tunsigned int\tburst;\n\tunsigned int\tv_total;\n};\n\nstatic void computeRegs(struct matrox_fb_info *minfo, struct mavenregs *r,\n\t\t\tstruct my_timming *mt, const struct output_desc *outd)\n{\n\tu_int32_t chromasc;\n\tu_int32_t hlen;\n\tu_int32_t hsl;\n\tu_int32_t hbp;\n\tu_int32_t hfp;\n\tu_int32_t hvis;\n\tunsigned int pixclock;\n\tunsigned long long piic;\n\tint mnp;\n\tint over;\n\t\n\tr->regs[0x80] = 0x03;\t \n\n\thvis = ((mt->HDisplay << 1) + 3) & ~3;\n\t\n\tif (hvis >= 2048) {\n\t\thvis = 2044;\n\t}\n\t\n\tpiic = 1000000000ULL * hvis;\n\tdo_div(piic, outd->h_vis);\n\n\tdprintk(KERN_DEBUG \"Want %u kHz pixclock\\n\", (unsigned int)piic);\n\t\n\tmnp = matroxfb_g450_setclk(minfo, piic, M_VIDEO_PLL);\n\t\n\tmt->mnp = mnp;\n\tmt->pixclock = g450_mnp2f(minfo, mnp);\n\n\tdprintk(KERN_DEBUG \"MNP=%08X\\n\", mnp);\n\n\tpixclock = 1000000000U / mt->pixclock;\n\n\tdprintk(KERN_DEBUG \"Got %u ps pixclock\\n\", pixclock);\n\n\tpiic = outd->chromasc;\n\tdo_div(piic, mt->pixclock);\n\tchromasc = piic;\n\t\n\tdprintk(KERN_DEBUG \"Chroma is %08X\\n\", chromasc);\n\n\tr->regs[0] = piic >> 24;\n\tr->regs[1] = piic >> 16;\n\tr->regs[2] = piic >>  8;\n\tr->regs[3] = piic >>  0;\n\thbp = (((outd->h_b_porch + pixclock) / pixclock)) & ~1;\n\thfp = (((outd->h_f_porch + pixclock) / pixclock)) & ~1;\n\thsl = (((outd->h_sync + pixclock) / pixclock)) & ~1;\n\thlen = hvis + hfp + hsl + hbp;\n\tover = hlen & 0x0F;\n\t\n\tdprintk(KERN_DEBUG \"WL: vis=%u, hf=%u, hs=%u, hb=%u, total=%u\\n\", hvis, hfp, hsl, hbp, hlen);\n\n\tif (over) {\n\t\thfp -= over;\n\t\thlen -= over;\n\t\tif (over <= 2) {\n\t\t} else if (over < 10) {\n\t\t\thfp += 4;\n\t\t\thlen += 4;\n\t\t} else {\n\t\t\thfp += 16;\n\t\t\thlen += 16;\n\t\t}\n\t}\n\n\t \n\tr->regs[0x08] = hsl;\n\tr->regs[0x09] = (outd->burst + pixclock - 1) / pixclock;\t \n\tr->regs[0x0A] = hbp;\n\tr->regs[0x2C] = hfp;\n\tr->regs[0x31] = hvis / 8;\n\tr->regs[0x32] = hvis & 7;\n\t\n\tdprintk(KERN_DEBUG \"PG: vis=%04X, hf=%02X, hs=%02X, hb=%02X, total=%04X\\n\", hvis, hfp, hsl, hbp, hlen);\n\n\tr->regs[0x84] = 1;\t \n\tr->regs[0x85] = 0;\n\thvis = hvis >> 1;\n\thlen = hlen >> 1;\n\t\n\tdprintk(KERN_DEBUG \"hlen=%u hvis=%u\\n\", hlen, hvis);\n\n\tmt->interlaced = 1;\n\n\tmt->HDisplay = hvis & ~7;\n\tmt->HSyncStart = mt->HDisplay + 8;\n\tmt->HSyncEnd = (hlen & ~7) - 8;\n\tmt->HTotal = hlen;\n\n\t{\n\t\tint upper;\n\t\tunsigned int vtotal;\n\t\tunsigned int vsyncend;\n\t\tunsigned int vdisplay;\n\t\t\n\t\tvtotal = mt->VTotal;\n\t\tvsyncend = mt->VSyncEnd;\n\t\tvdisplay = mt->VDisplay;\n\t\tif (vtotal < outd->v_total) {\n\t\t\tunsigned int yovr = outd->v_total - vtotal;\n\t\t\t\n\t\t\tvsyncend += yovr >> 1;\n\t\t} else if (vtotal > outd->v_total) {\n\t\t\tvdisplay = outd->v_total - 4;\n\t\t\tvsyncend = outd->v_total;\n\t\t}\n\t\tupper = (outd->v_total - vsyncend) >> 1;\t \n\t\tr->regs[0x17] = outd->v_total / 4;\n\t\tr->regs[0x18] = outd->v_total & 3;\n\t\tr->regs[0x33] = upper - 1;\t \n\t\tr->regs[0x82] = upper;\t\t \n\t\tr->regs[0x83] = upper >> 8;\n\t\t\n\t\tmt->VDisplay = vdisplay;\n\t\tmt->VSyncStart = outd->v_total - 2;\n\t\tmt->VSyncEnd = outd->v_total;\n\t\tmt->VTotal = outd->v_total;\n\t}\n}\n\nstatic void cve2_init_TVdata(int norm, struct mavenregs* data, const struct output_desc** outd) {\n\tstatic const struct output_desc paloutd = {\n\t\t.h_vis\t   = 52148148,\t\n\t\t.h_f_porch =  1407407,\t\n\t\t.h_sync    =  4666667,\t\n\t\t.h_b_porch =  5777778,\t\n\t\t.chromasc  = 19042247534182ULL,\t\n\t\t.burst     =  2518518,\t\n\t\t.v_total   =      625,\n\t};\n\tstatic const struct output_desc ntscoutd = {\n\t\t.h_vis     = 52888889,\t\n\t\t.h_f_porch =  1333333,\t\n\t\t.h_sync    =  4666667,\t\n\t\t.h_b_porch =  4666667,\t\n\t\t.chromasc  = 15374030659475ULL,\t\n\t\t.burst     =  2418418,\t\n\t\t.v_total   =      525,\t\n\t};\n\n\tstatic const struct mavenregs palregs = { {\n\t\t0x2A, 0x09, 0x8A, 0xCB,\t \n\t\t0x00,\n\t\t0x00,\t \n\t\t0xF9,\t \n\t\t0x00,\t \n\t\t0x7E,\t \n\t\t0x44,\t \n\t\t0x9C,\t \n\t\t0x2E,\t \n\t\t0x21,\t \n\t\t0x00,\t \n\n\t\t0x3C, 0x03,\n\t\t0x3C, 0x03,  \n\t\t0x1A,\t \n\t\t0x2A,\t \n\t\t0x1C, 0x3D, 0x14,  \n\t\t0x9C, 0x01,  \n\t\t0x00,\t \n\t\t0xFE,\t \n\t\t0x7E,\t \n\t\t0x60,\t \n\t\t0x05,\t \n\n\t\t0xAD, 0x03,\n\n\t\t0xA5,\n\t\t0x07,\t \n\n\t\t0xA5,\n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x08,\t \n\t\t0x04,\t \n\t\t0x00,\t \n\t\t0x1A,\t \n\t\t0x55, 0x01,  \n\t\t0x26,\t \n\t\t0x07, 0x7E,  \n\t\t0x02, 0x54,  \n\t\t0xB0, 0x00,  \n\t\t0x14,\t \n\t\t0x49,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0xA3,\t \n\t\t0xC8,\t \n\t\t0x22,\t \n\t\t0x02,\t \n\t\t0x22,\t \n\t\t0x3F, 0x03,  \n\t\t0x00,\t \n\t\t0x00,\t \n\t} };\n\tstatic const struct mavenregs ntscregs = { {\n\t\t0x21, 0xF0, 0x7C, 0x1F,\t \n\t\t0x00,\n\t\t0x00,\t \n\t\t0xF9,\t \n\t\t0x00,\t \n\t\t0x7E,\t \n\t\t0x43,\t \n\t\t0x7E,\t \n\t\t0x3D,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x41, 0x00,  \n\t\t0x3C, 0x00,  \n\t\t0x17,\t \n\t\t0x21,\t \n\t\t0x1B, 0x1B, 0x24,  \n\t\t0x83, 0x01,  \n\t\t0x00,\t \n\t\t0x0F,\t \n\t\t0x0F,\t \n\t\t0x60,\t \n\t\t0x05,\t \n\t\t\n\t\t0xC0, 0x02,  \n\t\t\n\t\t0x9C,\t \n\t\t0x04,\t \n\t\t\n\t\t0x9C,\t \n\t\t0x01,\t \n\t\t0x02,\t \n\t\t0x00,\t \n\t\t0x0A,\t \n\t\t0x05,\t \n\t\t0x00,\t \n\t\t0x10,\t \n\t\t0xFF, 0x03,  \n\t\t0x24,\t \n\t\t0x0F, 0x78,  \n\t\t0x00, 0x00,  \n\t\t0xB2, 0x04,  \n\t\t0x14,\t \n\t\t0x02,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0xA3,\t \n\t\t0xC8,\t \n\t\t0x15,\t \n\t\t0x05,\t \n\t\t0x3B,\t \n\t\t0x3C, 0x00,  \n\t\t0x00,\t \n\t\t0x00,\t \n\t} };\n\n\tif (norm == MATROXFB_OUTPUT_MODE_PAL) {\n\t\t*data = palregs;\n\t\t*outd = &paloutd;\n\t} else {\n  \t\t*data = ntscregs;\n\t\t*outd = &ntscoutd;\n\t}\n \treturn;\n}\n\n#define LR(x) cve2_set_reg(minfo, (x), m->regs[(x)])\nstatic void cve2_init_TV(struct matrox_fb_info *minfo,\n\t\t\t const struct mavenregs *m)\n{\n\tint i;\n\n\tLR(0x80);\n\tLR(0x82); LR(0x83);\n\tLR(0x84); LR(0x85);\n\t\n\tcve2_set_reg(minfo, 0x3E, 0x01);\n\t\n\tfor (i = 0; i < 0x3E; i++) {\n\t\tLR(i);\n\t}\n\tcve2_set_reg(minfo, 0x3E, 0x00);\n}\n\nstatic int matroxfb_g450_compute(void* md, struct my_timming* mt) {\n\tstruct matrox_fb_info *minfo = md;\n\n\tdprintk(KERN_DEBUG \"Computing, mode=%u\\n\", minfo->outputs[1].mode);\n\n\tif (mt->crtc == MATROXFB_SRC_CRTC2 &&\n\t    minfo->outputs[1].mode != MATROXFB_OUTPUT_MODE_MONITOR) {\n\t\tconst struct output_desc* outd;\n\n\t\tcve2_init_TVdata(minfo->outputs[1].mode, &minfo->hw.maven, &outd);\n\t\t{\n\t\t\tint blacklevel, whitelevel;\n\t\t\tg450_compute_bwlevel(minfo, &blacklevel, &whitelevel);\n\t\t\tminfo->hw.maven.regs[0x0E] = blacklevel >> 2;\n\t\t\tminfo->hw.maven.regs[0x0F] = blacklevel & 3;\n\t\t\tminfo->hw.maven.regs[0x1E] = whitelevel >> 2;\n\t\t\tminfo->hw.maven.regs[0x1F] = whitelevel & 3;\n\n\t\t\tminfo->hw.maven.regs[0x20] =\n\t\t\tminfo->hw.maven.regs[0x22] = minfo->altout.tvo_params.saturation;\n\n\t\t\tminfo->hw.maven.regs[0x25] = minfo->altout.tvo_params.hue;\n\n\t\t\tif (minfo->altout.tvo_params.testout) {\n\t\t\t\tminfo->hw.maven.regs[0x05] |= 0x02;\n\t\t\t}\n\t\t}\n\t\tcomputeRegs(minfo, &minfo->hw.maven, mt, outd);\n\t} else if (mt->mnp < 0) {\n\t\t \n\t\tmt->mnp = matroxfb_g450_setclk(minfo, mt->pixclock, (mt->crtc == MATROXFB_SRC_CRTC1) ? M_PIXEL_PLL_C : M_VIDEO_PLL);\n\t\tmt->pixclock = g450_mnp2f(minfo, mt->mnp);\n\t}\n\tdprintk(KERN_DEBUG \"Pixclock = %u\\n\", mt->pixclock);\n\treturn 0;\n}\n\nstatic int matroxfb_g450_program(void* md) {\n\tstruct matrox_fb_info *minfo = md;\n\t\n\tif (minfo->outputs[1].mode != MATROXFB_OUTPUT_MODE_MONITOR) {\n\t\tcve2_init_TV(minfo, &minfo->hw.maven);\n\t}\n\treturn 0;\n}\n\nstatic int matroxfb_g450_verify_mode(void* md, u_int32_t arg) {\n\tswitch (arg) {\n\t\tcase MATROXFB_OUTPUT_MODE_PAL:\n\t\tcase MATROXFB_OUTPUT_MODE_NTSC:\n\t\tcase MATROXFB_OUTPUT_MODE_MONITOR:\n\t\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int g450_dvi_compute(void* md, struct my_timming* mt) {\n\tstruct matrox_fb_info *minfo = md;\n\n\tif (mt->mnp < 0) {\n\t\tmt->mnp = matroxfb_g450_setclk(minfo, mt->pixclock, (mt->crtc == MATROXFB_SRC_CRTC1) ? M_PIXEL_PLL_C : M_VIDEO_PLL);\n\t\tmt->pixclock = g450_mnp2f(minfo, mt->mnp);\n\t}\n\treturn 0;\n}\n\nstatic struct matrox_altout matroxfb_g450_altout = {\n\t.name\t\t= \"Secondary output\",\n\t.compute\t= matroxfb_g450_compute,\n\t.program\t= matroxfb_g450_program,\n\t.verifymode\t= matroxfb_g450_verify_mode,\n\t.getqueryctrl\t= g450_query_ctrl,\n\t.getctrl\t= g450_get_ctrl,\n\t.setctrl\t= g450_set_ctrl,\n};\n\nstatic struct matrox_altout matroxfb_g450_dvi = {\n\t.name\t\t= \"DVI output\",\n\t.compute\t= g450_dvi_compute,\n};\n\nvoid matroxfb_g450_connect(struct matrox_fb_info *minfo)\n{\n\tif (minfo->devflags.g450dac) {\n\t\tdown_write(&minfo->altout.lock);\n\t\ttvo_fill_defaults(minfo);\n\t\tminfo->outputs[1].src = minfo->outputs[1].default_src;\n\t\tminfo->outputs[1].data = minfo;\n\t\tminfo->outputs[1].output = &matroxfb_g450_altout;\n\t\tminfo->outputs[1].mode = MATROXFB_OUTPUT_MODE_MONITOR;\n\t\tminfo->outputs[2].src = minfo->outputs[2].default_src;\n\t\tminfo->outputs[2].data = minfo;\n\t\tminfo->outputs[2].output = &matroxfb_g450_dvi;\n\t\tminfo->outputs[2].mode = MATROXFB_OUTPUT_MODE_MONITOR;\n\t\tup_write(&minfo->altout.lock);\n\t}\n}\n\nvoid matroxfb_g450_shutdown(struct matrox_fb_info *minfo)\n{\n\tif (minfo->devflags.g450dac) {\n\t\tdown_write(&minfo->altout.lock);\n\t\tminfo->outputs[1].src = MATROXFB_SRC_NONE;\n\t\tminfo->outputs[1].output = NULL;\n\t\tminfo->outputs[1].data = NULL;\n\t\tminfo->outputs[1].mode = MATROXFB_OUTPUT_MODE_MONITOR;\n\t\tminfo->outputs[2].src = MATROXFB_SRC_NONE;\n\t\tminfo->outputs[2].output = NULL;\n\t\tminfo->outputs[2].data = NULL;\n\t\tminfo->outputs[2].mode = MATROXFB_OUTPUT_MODE_MONITOR;\n\t\tup_write(&minfo->altout.lock);\n\t}\n}\n\nEXPORT_SYMBOL(matroxfb_g450_connect);\nEXPORT_SYMBOL(matroxfb_g450_shutdown);\n\nMODULE_AUTHOR(\"(c) 2000-2002 Petr Vandrovec <vandrove@vc.cvut.cz>\");\nMODULE_DESCRIPTION(\"Matrox G450/G550 output driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}