{
  "module_name": "matroxfb_misc.c",
  "hash_id": "1e5a8442072f6457a4de9f84207bb2a62e4cbaf639fb3f3e414405ec30c83012",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/matrox/matroxfb_misc.c",
  "human_readable_source": "\n \n\n\n#include \"matroxfb_misc.h\"\n#include <linux/interrupt.h>\n#include <linux/matroxfb.h>\n\nvoid matroxfb_DAC_out(const struct matrox_fb_info *minfo, int reg, int val)\n{\n\tDBG_REG(__func__)\n\tmga_outb(M_RAMDAC_BASE+M_X_INDEX, reg);\n\tmga_outb(M_RAMDAC_BASE+M_X_DATAREG, val);\n}\n\nint matroxfb_DAC_in(const struct matrox_fb_info *minfo, int reg)\n{\n\tDBG_REG(__func__)\n\tmga_outb(M_RAMDAC_BASE+M_X_INDEX, reg);\n\treturn mga_inb(M_RAMDAC_BASE+M_X_DATAREG);\n}\n\nvoid matroxfb_var2my(struct fb_var_screeninfo* var, struct my_timming* mt) {\n\tunsigned int pixclock = var->pixclock;\n\n\tDBG(__func__)\n\n\tif (!pixclock) pixclock = 10000;\t \n\tmt->pixclock = 1000000000 / pixclock;\n\tif (mt->pixclock < 1) mt->pixclock = 1;\n\tmt->mnp = -1;\n\tmt->dblscan = var->vmode & FB_VMODE_DOUBLE;\n\tmt->interlaced = var->vmode & FB_VMODE_INTERLACED;\n\tmt->HDisplay = var->xres;\n\tmt->HSyncStart = mt->HDisplay + var->right_margin;\n\tmt->HSyncEnd = mt->HSyncStart + var->hsync_len;\n\tmt->HTotal = mt->HSyncEnd + var->left_margin;\n\tmt->VDisplay = var->yres;\n\tmt->VSyncStart = mt->VDisplay + var->lower_margin;\n\tmt->VSyncEnd = mt->VSyncStart + var->vsync_len;\n\tmt->VTotal = mt->VSyncEnd + var->upper_margin;\n\tmt->sync = var->sync;\n}\n\nint matroxfb_PLL_calcclock(const struct matrox_pll_features* pll, unsigned int freq, unsigned int fmax,\n\t\tunsigned int* in, unsigned int* feed, unsigned int* post) {\n\tunsigned int bestdiff = ~0;\n\tunsigned int bestvco = 0;\n\tunsigned int fxtal = pll->ref_freq;\n\tunsigned int fwant;\n\tunsigned int p;\n\n\tDBG(__func__)\n\n\tfwant = freq;\n\n#ifdef DEBUG\n\tprintk(KERN_ERR \"post_shift_max: %d\\n\", pll->post_shift_max);\n\tprintk(KERN_ERR \"ref_freq: %d\\n\", pll->ref_freq);\n\tprintk(KERN_ERR \"freq: %d\\n\", freq);\n\tprintk(KERN_ERR \"vco_freq_min: %d\\n\", pll->vco_freq_min);\n\tprintk(KERN_ERR \"in_div_min: %d\\n\", pll->in_div_min);\n\tprintk(KERN_ERR \"in_div_max: %d\\n\", pll->in_div_max);\n\tprintk(KERN_ERR \"feed_div_min: %d\\n\", pll->feed_div_min);\n\tprintk(KERN_ERR \"feed_div_max: %d\\n\", pll->feed_div_max);\n\tprintk(KERN_ERR \"fmax: %d\\n\", fmax);\n#endif\n\tfor (p = 1; p <= pll->post_shift_max; p++) {\n\t\tif (fwant * 2 > fmax)\n\t\t\tbreak;\n\t\tfwant *= 2;\n\t}\n\tif (fwant < pll->vco_freq_min) fwant = pll->vco_freq_min;\n\tif (fwant > fmax) fwant = fmax;\n\tfor (; p-- > 0; fwant >>= 1, bestdiff >>= 1) {\n\t\tunsigned int m;\n\n\t\tif (fwant < pll->vco_freq_min) break;\n\t\tfor (m = pll->in_div_min; m <= pll->in_div_max; m++) {\n\t\t\tunsigned int diff, fvco;\n\t\t\tunsigned int n;\n\n\t\t\tn = (fwant * (m + 1) + (fxtal >> 1)) / fxtal - 1;\n\t\t\tif (n > pll->feed_div_max)\n\t\t\t\tbreak;\n\t\t\tif (n < pll->feed_div_min)\n\t\t\t\tn = pll->feed_div_min;\n\t\t\tfvco = (fxtal * (n + 1)) / (m + 1);\n\t\t\tif (fvco < fwant)\n\t\t\t\tdiff = fwant - fvco;\n\t\t\telse\n\t\t\t\tdiff = fvco - fwant;\n\t\t\tif (diff < bestdiff) {\n\t\t\t\tbestdiff = diff;\n\t\t\t\t*post = p;\n\t\t\t\t*in = m;\n\t\t\t\t*feed = n;\n\t\t\t\tbestvco = fvco;\n\t\t\t}\n\t\t}\n\t}\n\tdprintk(KERN_ERR \"clk: %02X %02X %02X %d %d %d\\n\", *in, *feed, *post, fxtal, bestvco, fwant);\n\treturn bestvco;\n}\n\nint matroxfb_vgaHWinit(struct matrox_fb_info *minfo, struct my_timming *m)\n{\n\tunsigned int hd, hs, he, hbe, ht;\n\tunsigned int vd, vs, ve, vt, lc;\n\tunsigned int wd;\n\tunsigned int divider;\n\tint i;\n\tstruct matrox_hw_state * const hw = &minfo->hw;\n\n\tDBG(__func__)\n\n\thw->SEQ[0] = 0x00;\n\thw->SEQ[1] = 0x01;\t \n\thw->SEQ[2] = 0x0F;\t \n\thw->SEQ[3] = 0x00;\n\thw->SEQ[4] = 0x0E;\n\t \n\tif (m->dblscan) {\n\t\tm->VTotal <<= 1;\n\t\tm->VDisplay <<= 1;\n\t\tm->VSyncStart <<= 1;\n\t\tm->VSyncEnd <<= 1;\n\t}\n\tif (m->interlaced) {\n\t\tm->VTotal >>= 1;\n\t\tm->VDisplay >>= 1;\n\t\tm->VSyncStart >>= 1;\n\t\tm->VSyncEnd >>= 1;\n\t}\n\n\t \n\thw->GCTL[0] = 0x00;\n\thw->GCTL[1] = 0x00;\n\thw->GCTL[2] = 0x00;\n\thw->GCTL[3] = 0x00;\n\thw->GCTL[4] = 0x00;\n\thw->GCTL[5] = 0x40;\n\thw->GCTL[6] = 0x05;\n\thw->GCTL[7] = 0x0F;\n\thw->GCTL[8] = 0xFF;\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\thw->ATTR[i] = i;\n\thw->ATTR[16] = 0x41;\n\thw->ATTR[17] = 0xFF;\n\thw->ATTR[18] = 0x0F;\n\thw->ATTR[19] = 0x00;\n\thw->ATTR[20] = 0x00;\n\n\thd = m->HDisplay >> 3;\n\ths = m->HSyncStart >> 3;\n\the = m->HSyncEnd >> 3;\n\tht = m->HTotal >> 3;\n\t \n\t \n\t \n\tdivider = minfo->curr.final_bppShift;\n\twhile (divider & 3) {\n\t\thd >>= 1;\n\t\ths >>= 1;\n\t\the >>= 1;\n\t\tht >>= 1;\n\t\tdivider <<= 1;\n\t}\n\tdivider = divider / 4;\n\t \n\twhile (divider > 8) {\n\t\thd <<= 1;\n\t\ths <<= 1;\n\t\the <<= 1;\n\t\tht <<= 1;\n\t\tdivider >>= 1;\n\t}\n\thd = hd - 1;\n\ths = hs - 1;\n\the = he - 1;\n\tht = ht - 1;\n\tvd = m->VDisplay - 1;\n\tvs = m->VSyncStart - 1;\n\tve = m->VSyncEnd - 1;\n\tvt = m->VTotal - 2;\n\tlc = vd;\n\t \n\tif (((ht & 0x07) == 0x06) || ((ht & 0x0F) == 0x04))\n\t\tht++;\n\thbe = ht;\n\twd = minfo->fbcon.var.xres_virtual * minfo->curr.final_bppShift / 64;\n\n\thw->CRTCEXT[0] = 0;\n\thw->CRTCEXT[5] = 0;\n\tif (m->interlaced) {\n\t\thw->CRTCEXT[0] = 0x80;\n\t\thw->CRTCEXT[5] = (hs + he - ht) >> 1;\n\t\tif (!m->dblscan)\n\t\t\twd <<= 1;\n\t\tvt &= ~1;\n\t}\n\thw->CRTCEXT[0] |=  (wd & 0x300) >> 4;\n\thw->CRTCEXT[1] = (((ht - 4) & 0x100) >> 8) |\n\t\t\t  ((hd      & 0x100) >> 7) |  \n\t\t\t  ((hs      & 0x100) >> 6) |  \n\t\t\t   (hbe     & 0x040);\t  \n\t \n\tif (minfo->outputs[1].src == MATROXFB_SRC_CRTC1)\n\t\thw->CRTCEXT[1] |= 0x88;\t\t \n\thw->CRTCEXT[2] =  ((vt & 0xC00) >> 10) |\n\t\t\t  ((vd & 0x400) >>  8) |\t \n\t\t\t  ((vd & 0xC00) >>  7) |\t \n\t\t\t  ((vs & 0xC00) >>  5) |\n\t\t\t  ((lc & 0x400) >>  3);\n\thw->CRTCEXT[3] = (divider - 1) | 0x80;\n\thw->CRTCEXT[4] = 0;\n\n\thw->CRTC[0] = ht-4;\n\thw->CRTC[1] = hd;\n\thw->CRTC[2] = hd;\n\thw->CRTC[3] = (hbe & 0x1F) | 0x80;\n\thw->CRTC[4] = hs;\n\thw->CRTC[5] = ((hbe & 0x20) << 2) | (he & 0x1F);\n\thw->CRTC[6] = vt & 0xFF;\n\thw->CRTC[7] = ((vt & 0x100) >> 8) |\n\t\t      ((vd & 0x100) >> 7) |\n\t\t      ((vs & 0x100) >> 6) |\n\t\t      ((vd & 0x100) >> 5) |\n\t\t      ((lc & 0x100) >> 4) |\n\t\t      ((vt & 0x200) >> 4) |\n\t\t      ((vd & 0x200) >> 3) |\n\t\t      ((vs & 0x200) >> 2);\n\thw->CRTC[8] = 0x00;\n\thw->CRTC[9] = ((vd & 0x200) >> 4) |\n\t\t      ((lc & 0x200) >> 3);\n\tif (m->dblscan && !m->interlaced)\n\t\thw->CRTC[9] |= 0x80;\n\tfor (i = 10; i < 16; i++)\n\t\thw->CRTC[i] = 0x00;\n\thw->CRTC[16] = vs  ;\n\thw->CRTC[17] = (ve & 0x0F) | 0x20;\n\thw->CRTC[18] = vd  ;\n\thw->CRTC[19] = wd  ;\n\thw->CRTC[20] = 0x00;\n\thw->CRTC[21] = vd  ;\n\thw->CRTC[22] = (vt + 1)  ;\n\thw->CRTC[23] = 0xC3;\n\thw->CRTC[24] = lc;\n\treturn 0;\n};\n\nvoid matroxfb_vgaHWrestore(struct matrox_fb_info *minfo)\n{\n\tint i;\n\tstruct matrox_hw_state * const hw = &minfo->hw;\n\tCRITFLAGS\n\n\tDBG(__func__)\n\n\tdprintk(KERN_INFO \"MiscOutReg: %02X\\n\", hw->MiscOutReg);\n\tdprintk(KERN_INFO \"SEQ regs:   \");\n\tfor (i = 0; i < 5; i++)\n\t\tdprintk(\"%02X:\", hw->SEQ[i]);\n\tdprintk(\"\\n\");\n\tdprintk(KERN_INFO \"GDC regs:   \");\n\tfor (i = 0; i < 9; i++)\n\t\tdprintk(\"%02X:\", hw->GCTL[i]);\n\tdprintk(\"\\n\");\n\tdprintk(KERN_INFO \"CRTC regs: \");\n\tfor (i = 0; i < 25; i++)\n\t\tdprintk(\"%02X:\", hw->CRTC[i]);\n\tdprintk(\"\\n\");\n\tdprintk(KERN_INFO \"ATTR regs: \");\n\tfor (i = 0; i < 21; i++)\n\t\tdprintk(\"%02X:\", hw->ATTR[i]);\n\tdprintk(\"\\n\");\n\n\tCRITBEGIN\n\n\tmga_inb(M_ATTR_RESET);\n\tmga_outb(M_ATTR_INDEX, 0);\n\tmga_outb(M_MISC_REG, hw->MiscOutReg);\n\tfor (i = 1; i < 5; i++)\n\t\tmga_setr(M_SEQ_INDEX, i, hw->SEQ[i]);\n\tmga_setr(M_CRTC_INDEX, 17, hw->CRTC[17] & 0x7F);\n\tfor (i = 0; i < 25; i++)\n\t\tmga_setr(M_CRTC_INDEX, i, hw->CRTC[i]);\n\tfor (i = 0; i < 9; i++)\n\t\tmga_setr(M_GRAPHICS_INDEX, i, hw->GCTL[i]);\n\tfor (i = 0; i < 21; i++) {\n\t\tmga_inb(M_ATTR_RESET);\n\t\tmga_outb(M_ATTR_INDEX, i);\n\t\tmga_outb(M_ATTR_INDEX, hw->ATTR[i]);\n\t}\n\tmga_outb(M_PALETTE_MASK, 0xFF);\n\tmga_outb(M_DAC_REG, 0x00);\n\tfor (i = 0; i < 768; i++)\n\t\tmga_outb(M_DAC_VAL, hw->DACpal[i]);\n\tmga_inb(M_ATTR_RESET);\n\tmga_outb(M_ATTR_INDEX, 0x20);\n\n\tCRITEND\n}\n\nstatic void get_pins(unsigned char __iomem* pins, struct matrox_bios* bd) {\n\tunsigned int b0 = readb(pins);\n\t\n\tif (b0 == 0x2E && readb(pins+1) == 0x41) {\n\t\tunsigned int pins_len = readb(pins+2);\n\t\tunsigned int i;\n\t\tunsigned char cksum;\n\t\tunsigned char* dst = bd->pins;\n\n\t\tif (pins_len < 3 || pins_len > 128) {\n\t\t\treturn;\n\t\t}\n\t\t*dst++ = 0x2E;\n\t\t*dst++ = 0x41;\n\t\t*dst++ = pins_len;\n\t\tcksum = 0x2E + 0x41 + pins_len;\n\t\tfor (i = 3; i < pins_len; i++) {\n\t\t\tcksum += *dst++ = readb(pins+i);\n\t\t}\n\t\tif (cksum) {\n\t\t\treturn;\n\t\t}\n\t\tbd->pins_len = pins_len;\n\t} else if (b0 == 0x40 && readb(pins+1) == 0x00) {\n\t\tunsigned int i;\n\t\tunsigned char* dst = bd->pins;\n\n\t\t*dst++ = 0x40;\n\t\t*dst++ = 0;\n\t\tfor (i = 2; i < 0x40; i++) {\n\t\t\t*dst++ = readb(pins+i);\n\t\t}\n\t\tbd->pins_len = 0x40;\n\t}\n}\n\nstatic void get_bios_version(unsigned char __iomem * vbios, struct matrox_bios* bd) {\n\tunsigned int pcir_offset;\n\t\n\tpcir_offset = readb(vbios + 24) | (readb(vbios + 25) << 8);\n\tif (pcir_offset >= 26 && pcir_offset < 0xFFE0 &&\n\t    readb(vbios + pcir_offset    ) == 'P' &&\n\t    readb(vbios + pcir_offset + 1) == 'C' &&\n\t    readb(vbios + pcir_offset + 2) == 'I' &&\n\t    readb(vbios + pcir_offset + 3) == 'R') {\n\t\tunsigned char h;\n\n\t\th = readb(vbios + pcir_offset + 0x12);\n\t\tbd->version.vMaj = (h >> 4) & 0xF;\n\t\tbd->version.vMin = h & 0xF;\n\t\tbd->version.vRev = readb(vbios + pcir_offset + 0x13);\n\t} else {\n\t\tunsigned char h;\n\n\t\th = readb(vbios + 5);\n\t\tbd->version.vMaj = (h >> 4) & 0xF;\n\t\tbd->version.vMin = h & 0xF;\n\t\tbd->version.vRev = 0;\n\t}\n}\n\nstatic void get_bios_output(unsigned char __iomem* vbios, struct matrox_bios* bd) {\n\tunsigned char b;\n\t\n\tb = readb(vbios + 0x7FF1);\n\tif (b == 0xFF) {\n\t\tb = 0;\n\t}\n\tbd->output.state = b;\n}\n\nstatic void get_bios_tvout(unsigned char __iomem* vbios, struct matrox_bios* bd) {\n\tunsigned int i;\n\t\n\t \n\tbd->output.tvout = 0;\n\tif (readb(vbios + 0x1D) != 'I' ||\n\t    readb(vbios + 0x1E) != 'B' ||\n\t    readb(vbios + 0x1F) != 'M' ||\n\t    readb(vbios + 0x20) != ' ') {\n\t    \treturn;\n\t}\n\tfor (i = 0x2D; i < 0x2D + 128; i++) {\n\t\tunsigned char b = readb(vbios + i);\n\t\t\n\t\tif (b == '(' && readb(vbios + i + 1) == 'V') {\n\t\t\tif (readb(vbios + i + 6) == 'T' &&\n\t\t\t    readb(vbios + i + 7) == 'V' &&\n\t\t\t    readb(vbios + i + 8) == 'O') {\n\t\t\t\tbd->output.tvout = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (b == 0)\n\t\t\tbreak;\n\t}\n}\n\nstatic void parse_bios(unsigned char __iomem* vbios, struct matrox_bios* bd) {\n\tunsigned int pins_offset;\n\t\n\tif (readb(vbios) != 0x55 || readb(vbios + 1) != 0xAA) {\n\t\treturn;\n\t}\n\tbd->bios_valid = 1;\n\tget_bios_version(vbios, bd);\n\tget_bios_output(vbios, bd);\n\tget_bios_tvout(vbios, bd);\n#if defined(__powerpc__)\n\t \n\tfor ( pins_offset = 0 ; pins_offset <= 0xFF80 ; pins_offset++ ) {\n\t\tunsigned char header[3];\n\n\t\theader[0] = readb(vbios + pins_offset);\n\t\theader[1] = readb(vbios + pins_offset + 1);\n\t\theader[2] = readb(vbios + pins_offset + 2);\n\t\tif ( (header[0] == 0x2E) && (header[1] == 0x41)\n\t\t     && ((header[2] == 0x40) || (header[2] == 0x80)) ) {\n\t\t\tprintk(KERN_INFO \"PInS data found at offset %u\\n\",\n\t\t\t       pins_offset);\n\t\t\tget_pins(vbios + pins_offset, bd);\n\t\t\tbreak;\n\t\t}\n\t}\n#else\n\tpins_offset = readb(vbios + 0x7FFC) | (readb(vbios + 0x7FFD) << 8);\n\tif (pins_offset <= 0xFF80) {\n\t\tget_pins(vbios + pins_offset, bd);\n\t}\n#endif\n}\n\nstatic int parse_pins1(struct matrox_fb_info *minfo,\n\t\t       const struct matrox_bios *bd)\n{\n\tunsigned int maxdac;\n\n\tswitch (bd->pins[22]) {\n\t\tcase 0:\t\tmaxdac = 175000; break;\n\t\tcase 1:\t\tmaxdac = 220000; break;\n\t\tdefault:\tmaxdac = 240000; break;\n\t}\n\tif (get_unaligned_le16(bd->pins + 24)) {\n\t\tmaxdac = get_unaligned_le16(bd->pins + 24) * 10;\n\t}\n\tminfo->limits.pixel.vcomax = maxdac;\n\tminfo->values.pll.system = get_unaligned_le16(bd->pins + 28) ?\n\t\tget_unaligned_le16(bd->pins + 28) * 10 : 50000;\n\t \n\tminfo->features.pll.ref_freq = 14318;\n\tminfo->values.reg.mctlwtst\t= 0x00030101;\n\treturn 0;\n}\n\nstatic void default_pins1(struct matrox_fb_info *minfo)\n{\n\t \n\tminfo->limits.pixel.vcomax\t= 220000;\n\tminfo->values.pll.system\t=  50000;\n\tminfo->features.pll.ref_freq\t=  14318;\n\tminfo->values.reg.mctlwtst\t= 0x00030101;\n}\n\nstatic int parse_pins2(struct matrox_fb_info *minfo,\n\t\t       const struct matrox_bios *bd)\n{\n\tminfo->limits.pixel.vcomax\t=\n\tminfo->limits.system.vcomax\t= (bd->pins[41] == 0xFF) ? 230000 : ((bd->pins[41] + 100) * 1000);\n\tminfo->values.reg.mctlwtst\t= ((bd->pins[51] & 0x01) ? 0x00000001 : 0) |\n\t\t\t\t\t  ((bd->pins[51] & 0x02) ? 0x00000100 : 0) |\n\t\t\t\t\t  ((bd->pins[51] & 0x04) ? 0x00010000 : 0) |\n\t\t\t\t\t  ((bd->pins[51] & 0x08) ? 0x00020000 : 0);\n\tminfo->values.pll.system\t= (bd->pins[43] == 0xFF) ? 50000 : ((bd->pins[43] + 100) * 1000);\n\tminfo->features.pll.ref_freq\t= 14318;\n\treturn 0;\n}\n\nstatic void default_pins2(struct matrox_fb_info *minfo)\n{\n\t \n\tminfo->limits.pixel.vcomax\t=\n\tminfo->limits.system.vcomax\t= 230000;\n\tminfo->values.reg.mctlwtst\t= 0x00030101;\n\tminfo->values.pll.system\t=  50000;\n\tminfo->features.pll.ref_freq\t=  14318;\n}\n\nstatic int parse_pins3(struct matrox_fb_info *minfo,\n\t\t       const struct matrox_bios *bd)\n{\n\tminfo->limits.pixel.vcomax\t=\n\tminfo->limits.system.vcomax\t= (bd->pins[36] == 0xFF) ? 230000\t\t\t: ((bd->pins[36] + 100) * 1000);\n\tminfo->values.reg.mctlwtst\t= get_unaligned_le32(bd->pins + 48) == 0xFFFFFFFF ?\n\t\t0x01250A21 : get_unaligned_le32(bd->pins + 48);\n\t \n\tminfo->values.reg.memrdbk\t= ((bd->pins[57] << 21) & 0x1E000000) |\n\t\t\t\t\t  ((bd->pins[57] << 22) & 0x00C00000) |\n\t\t\t\t\t  ((bd->pins[56] <<  1) & 0x000001E0) |\n\t\t\t\t\t  ( bd->pins[56]        & 0x0000000F);\n\tminfo->values.reg.opt\t\t= (bd->pins[54] & 7) << 10;\n\tminfo->values.reg.opt2\t\t= bd->pins[58] << 12;\n\tminfo->features.pll.ref_freq\t= (bd->pins[52] & 0x20) ? 14318 : 27000;\n\treturn 0;\n}\n\nstatic void default_pins3(struct matrox_fb_info *minfo)\n{\n\t \n\tminfo->limits.pixel.vcomax\t=\n\tminfo->limits.system.vcomax\t= 230000;\n\tminfo->values.reg.mctlwtst\t= 0x01250A21;\n\tminfo->values.reg.memrdbk\t= 0x00000000;\n\tminfo->values.reg.opt\t\t= 0x00000C00;\n\tminfo->values.reg.opt2\t\t= 0x00000000;\n\tminfo->features.pll.ref_freq\t=  27000;\n}\n\nstatic int parse_pins4(struct matrox_fb_info *minfo,\n\t\t       const struct matrox_bios *bd)\n{\n\tminfo->limits.pixel.vcomax\t= (bd->pins[ 39] == 0xFF) ? 230000\t\t\t: bd->pins[ 39] * 4000;\n\tminfo->limits.system.vcomax\t= (bd->pins[ 38] == 0xFF) ? minfo->limits.pixel.vcomax\t: bd->pins[ 38] * 4000;\n\tminfo->values.reg.mctlwtst\t= get_unaligned_le32(bd->pins + 71);\n\tminfo->values.reg.memrdbk\t= ((bd->pins[87] << 21) & 0x1E000000) |\n\t\t\t\t\t  ((bd->pins[87] << 22) & 0x00C00000) |\n\t\t\t\t\t  ((bd->pins[86] <<  1) & 0x000001E0) |\n\t\t\t\t\t  ( bd->pins[86]        & 0x0000000F);\n\tminfo->values.reg.opt\t\t= ((bd->pins[53] << 15) & 0x00400000) |\n\t\t\t\t\t  ((bd->pins[53] << 22) & 0x10000000) |\n\t\t\t\t\t  ((bd->pins[53] <<  7) & 0x00001C00);\n\tminfo->values.reg.opt3\t\t= get_unaligned_le32(bd->pins + 67);\n\tminfo->values.pll.system\t= (bd->pins[ 65] == 0xFF) ? 200000 \t\t\t: bd->pins[ 65] * 4000;\n\tminfo->features.pll.ref_freq\t= (bd->pins[ 92] & 0x01) ? 14318 : 27000;\n\treturn 0;\n}\n\nstatic void default_pins4(struct matrox_fb_info *minfo)\n{\n\t \n\tminfo->limits.pixel.vcomax\t=\n\tminfo->limits.system.vcomax\t= 252000;\n\tminfo->values.reg.mctlwtst\t= 0x04A450A1;\n\tminfo->values.reg.memrdbk\t= 0x000000E7;\n\tminfo->values.reg.opt\t\t= 0x10000400;\n\tminfo->values.reg.opt3\t\t= 0x0190A419;\n\tminfo->values.pll.system\t= 200000;\n\tminfo->features.pll.ref_freq\t= 27000;\n}\n\nstatic int parse_pins5(struct matrox_fb_info *minfo,\n\t\t       const struct matrox_bios *bd)\n{\n\tunsigned int mult;\n\t\n\tmult = bd->pins[4]?8000:6000;\n\t\n\tminfo->limits.pixel.vcomax\t= (bd->pins[ 38] == 0xFF) ? 600000\t\t\t: bd->pins[ 38] * mult;\n\tminfo->limits.system.vcomax\t= (bd->pins[ 36] == 0xFF) ? minfo->limits.pixel.vcomax\t: bd->pins[ 36] * mult;\n\tminfo->limits.video.vcomax\t= (bd->pins[ 37] == 0xFF) ? minfo->limits.system.vcomax\t: bd->pins[ 37] * mult;\n\tminfo->limits.pixel.vcomin\t= (bd->pins[123] == 0xFF) ? 256000\t\t\t: bd->pins[123] * mult;\n\tminfo->limits.system.vcomin\t= (bd->pins[121] == 0xFF) ? minfo->limits.pixel.vcomin\t: bd->pins[121] * mult;\n\tminfo->limits.video.vcomin\t= (bd->pins[122] == 0xFF) ? minfo->limits.system.vcomin\t: bd->pins[122] * mult;\n\tminfo->values.pll.system\t=\n\tminfo->values.pll.video\t\t= (bd->pins[ 92] == 0xFF) ? 284000\t\t\t: bd->pins[ 92] * 4000;\n\tminfo->values.reg.opt\t\t= get_unaligned_le32(bd->pins + 48);\n\tminfo->values.reg.opt2\t\t= get_unaligned_le32(bd->pins + 52);\n\tminfo->values.reg.opt3\t\t= get_unaligned_le32(bd->pins + 94);\n\tminfo->values.reg.mctlwtst\t= get_unaligned_le32(bd->pins + 98);\n\tminfo->values.reg.memmisc\t= get_unaligned_le32(bd->pins + 102);\n\tminfo->values.reg.memrdbk\t= get_unaligned_le32(bd->pins + 106);\n\tminfo->features.pll.ref_freq\t= (bd->pins[110] & 0x01) ? 14318 : 27000;\n\tminfo->values.memory.ddr\t= (bd->pins[114] & 0x60) == 0x20;\n\tminfo->values.memory.dll\t= (bd->pins[115] & 0x02) != 0;\n\tminfo->values.memory.emrswen\t= (bd->pins[115] & 0x01) != 0;\n\tminfo->values.reg.maccess\t= minfo->values.memory.emrswen ? 0x00004000 : 0x00000000;\n\tif (bd->pins[115] & 4) {\n\t\tminfo->values.reg.mctlwtst_core = minfo->values.reg.mctlwtst;\n\t} else {\n\t\tstatic const u8 wtst_xlat[] = {\n\t\t\t0, 1, 5, 6, 7, 5, 2, 3\n\t\t};\n\n\t\tminfo->values.reg.mctlwtst_core = (minfo->values.reg.mctlwtst & ~7) |\n\t\t\t\t\t\t  wtst_xlat[minfo->values.reg.mctlwtst & 7];\n\t}\n\tminfo->max_pixel_clock_panellink = bd->pins[47] * 4000;\n\treturn 0;\n}\n\nstatic void default_pins5(struct matrox_fb_info *minfo)\n{\n\t \n\tminfo->limits.pixel.vcomax\t=\n\tminfo->limits.system.vcomax\t=\n\tminfo->limits.video.vcomax\t= 600000;\n\tminfo->limits.pixel.vcomin\t=\n\tminfo->limits.system.vcomin\t=\n\tminfo->limits.video.vcomin\t= 256000;\n\tminfo->values.pll.system\t=\n\tminfo->values.pll.video\t\t= 284000;\n\tminfo->values.reg.opt\t\t= 0x404A1160;\n\tminfo->values.reg.opt2\t\t= 0x0000AC00;\n\tminfo->values.reg.opt3\t\t= 0x0090A409;\n\tminfo->values.reg.mctlwtst_core\t=\n\tminfo->values.reg.mctlwtst\t= 0x0C81462B;\n\tminfo->values.reg.memmisc\t= 0x80000004;\n\tminfo->values.reg.memrdbk\t= 0x01001103;\n\tminfo->features.pll.ref_freq\t= 27000;\n\tminfo->values.memory.ddr\t= 1;\n\tminfo->values.memory.dll\t= 1;\n\tminfo->values.memory.emrswen\t= 1;\n\tminfo->values.reg.maccess\t= 0x00004000;\n}\n\nstatic int matroxfb_set_limits(struct matrox_fb_info *minfo,\n\t\t\t       const struct matrox_bios *bd)\n{\n\tunsigned int pins_version;\n\tstatic const unsigned int pinslen[] = { 64, 64, 64, 128, 128 };\n\n\tswitch (minfo->chip) {\n\t\tcase MGA_2064:\tdefault_pins1(minfo); break;\n\t\tcase MGA_2164:\n\t\tcase MGA_1064:\n\t\tcase MGA_1164:\tdefault_pins2(minfo); break;\n\t\tcase MGA_G100:\n\t\tcase MGA_G200:\tdefault_pins3(minfo); break;\n\t\tcase MGA_G400:\tdefault_pins4(minfo); break;\n\t\tcase MGA_G450:\n\t\tcase MGA_G550:\tdefault_pins5(minfo); break;\n\t}\n\tif (!bd->bios_valid) {\n\t\tprintk(KERN_INFO \"matroxfb: Your Matrox device does not have BIOS\\n\");\n\t\treturn -1;\n\t}\n\tif (bd->pins_len < 64) {\n\t\tprintk(KERN_INFO \"matroxfb: BIOS on your Matrox device does not contain powerup info\\n\");\n\t\treturn -1;\n\t}\n\tif (bd->pins[0] == 0x2E && bd->pins[1] == 0x41) {\n\t\tpins_version = bd->pins[5];\n\t\tif (pins_version < 2 || pins_version > 5) {\n\t\t\tprintk(KERN_INFO \"matroxfb: Unknown version (%u) of powerup info\\n\", pins_version);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tpins_version = 1;\n\t}\n\tif (bd->pins_len != pinslen[pins_version - 1]) {\n\t\tprintk(KERN_INFO \"matroxfb: Invalid powerup info\\n\");\n\t\treturn -1;\n\t}\n\tswitch (pins_version) {\n\t\tcase 1:\n\t\t\treturn parse_pins1(minfo, bd);\n\t\tcase 2:\n\t\t\treturn parse_pins2(minfo, bd);\n\t\tcase 3:\n\t\t\treturn parse_pins3(minfo, bd);\n\t\tcase 4:\n\t\t\treturn parse_pins4(minfo, bd);\n\t\tcase 5:\n\t\t\treturn parse_pins5(minfo, bd);\n\t\tdefault:\n\t\t\tprintk(KERN_DEBUG \"matroxfb: Powerup info version %u is not yet supported\\n\", pins_version);\n\t\t\treturn -1;\n\t}\n}\n\nvoid matroxfb_read_pins(struct matrox_fb_info *minfo)\n{\n\tu32 opt;\n\tu32 biosbase;\n\tu32 fbbase;\n\tstruct pci_dev *pdev = minfo->pcidev;\n\t\n\tmemset(&minfo->bios, 0, sizeof(minfo->bios));\n\tpci_read_config_dword(pdev, PCI_OPTION_REG, &opt);\n\tpci_write_config_dword(pdev, PCI_OPTION_REG, opt | PCI_OPTION_ENABLE_ROM);\n\tpci_read_config_dword(pdev, PCI_ROM_ADDRESS, &biosbase);\n\tpci_read_config_dword(pdev, minfo->devflags.fbResource, &fbbase);\n\tpci_write_config_dword(pdev, PCI_ROM_ADDRESS, (fbbase & PCI_ROM_ADDRESS_MASK) | PCI_ROM_ADDRESS_ENABLE);\n\tparse_bios(vaddr_va(minfo->video.vbase), &minfo->bios);\n\tpci_write_config_dword(pdev, PCI_ROM_ADDRESS, biosbase);\n\tpci_write_config_dword(pdev, PCI_OPTION_REG, opt);\n#ifdef CONFIG_X86\n\tif (!minfo->bios.bios_valid) {\n\t\tunsigned char __iomem* b;\n\n\t\tb = ioremap(0x000C0000, 65536);\n\t\tif (!b) {\n\t\t\tprintk(KERN_INFO \"matroxfb: Unable to map legacy BIOS\\n\");\n\t\t} else {\n\t\t\tunsigned int ven = readb(b+0x64+0) | (readb(b+0x64+1) << 8);\n\t\t\tunsigned int dev = readb(b+0x64+2) | (readb(b+0x64+3) << 8);\n\t\t\t\n\t\t\tif (ven != pdev->vendor || dev != pdev->device) {\n\t\t\t\tprintk(KERN_INFO \"matroxfb: Legacy BIOS is for %04X:%04X, while this device is %04X:%04X\\n\",\n\t\t\t\t\tven, dev, pdev->vendor, pdev->device);\n\t\t\t} else {\n\t\t\t\tparse_bios(b, &minfo->bios);\n\t\t\t}\n\t\t\tiounmap(b);\n\t\t}\n\t}\n#endif\n\tmatroxfb_set_limits(minfo, &minfo->bios);\n\tprintk(KERN_INFO \"PInS memtype = %u\\n\",\n\t       (minfo->values.reg.opt & 0x1C00) >> 10);\n}\n\nEXPORT_SYMBOL(matroxfb_DAC_in);\nEXPORT_SYMBOL(matroxfb_DAC_out);\nEXPORT_SYMBOL(matroxfb_var2my);\nEXPORT_SYMBOL(matroxfb_PLL_calcclock);\nEXPORT_SYMBOL(matroxfb_vgaHWinit);\t\t \nEXPORT_SYMBOL(matroxfb_vgaHWrestore);\t\t \nEXPORT_SYMBOL(matroxfb_read_pins);\n\nMODULE_AUTHOR(\"(c) 1999-2002 Petr Vandrovec <vandrove@vc.cvut.cz>\");\nMODULE_DESCRIPTION(\"Miscellaneous support for Matrox video cards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}