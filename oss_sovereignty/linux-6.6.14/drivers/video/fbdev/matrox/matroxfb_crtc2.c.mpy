{
  "module_name": "matroxfb_crtc2.c",
  "hash_id": "d940b1dd59a7c6867327082f86be96567832f115456117d52abe481a3dd20eb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/matrox/matroxfb_crtc2.c",
  "human_readable_source": "\n \n\n#include \"matroxfb_maven.h\"\n#include \"matroxfb_crtc2.h\"\n#include \"matroxfb_misc.h\"\n#include \"matroxfb_DAC1064.h\"\n#include <linux/matroxfb.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n \n\nstatic int mem = 8192;\n\nmodule_param(mem, int, 0);\nMODULE_PARM_DESC(mem, \"Memory size reserved for dualhead (default=8MB)\");\n\n \n\nstatic int matroxfb_dh_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\tunsigned blue, unsigned transp, struct fb_info* info) {\n\tu_int32_t col;\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\n\n\tif (regno >= 16)\n\t\treturn 1;\n\tif (m2info->fbcon.var.grayscale) {\n\t\t \n\t\tred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n\t}\n\tred = CNVT_TOHW(red, m2info->fbcon.var.red.length);\n\tgreen = CNVT_TOHW(green, m2info->fbcon.var.green.length);\n\tblue = CNVT_TOHW(blue, m2info->fbcon.var.blue.length);\n\ttransp = CNVT_TOHW(transp, m2info->fbcon.var.transp.length);\n\n\tcol = (red << m2info->fbcon.var.red.offset)     |\n\t      (green << m2info->fbcon.var.green.offset) |\n\t      (blue << m2info->fbcon.var.blue.offset)   |\n\t      (transp << m2info->fbcon.var.transp.offset);\n\n\tswitch (m2info->fbcon.var.bits_per_pixel) {\n\t\tcase 16:\n\t\t\tm2info->cmap[regno] = col | (col << 16);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tm2info->cmap[regno] = col;\n\t\t\tbreak;\n\t}\n\treturn 0;\n#undef m2info\n}\n\nstatic void matroxfb_dh_restore(struct matroxfb_dh_fb_info* m2info,\n\t\tstruct my_timming* mt,\n\t\tint mode,\n\t\tunsigned int pos) {\n\tu_int32_t tmp;\n\tu_int32_t datactl;\n\tstruct matrox_fb_info *minfo = m2info->primary_dev;\n\n\tswitch (mode) {\n\t\tcase 15:\n\t\t\ttmp = 0x00200000;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\ttmp = 0x00400000;\n\t\t\tbreak;\n \n\t\tdefault:\n\t\t\ttmp = 0x00800000;\n\t\t\tbreak;\n\t}\n\ttmp |= 0x00000001;\t \n\tdatactl = 0;\n\tif (minfo->outputs[1].src == MATROXFB_SRC_CRTC2) {\n\t\tif (minfo->devflags.g450dac) {\n\t\t\ttmp |= 0x00000006;  \n\t\t\t \n\t\t\tif (minfo->outputs[1].mode != MATROXFB_OUTPUT_MODE_MONITOR) {\n\t\t\t\ttmp |=  0xC0001000;  \n\t\t\t}\n\t\t} else {\n\t\t\ttmp |= 0x00000002;  \n\t\t\ttmp |= 0xC0000000;  \n\t\t\t \n\t\t}\n\t} else if (minfo->outputs[0].src == MATROXFB_SRC_CRTC2) {\n\t\ttmp |= 0x00000004;  \n\t\t \n\t}\n\tif (minfo->outputs[0].src == MATROXFB_SRC_CRTC2) {\n\t\ttmp |= 0x00100000;\t \n\t}\n\tif (mt->interlaced) {\n\t\ttmp |= 0x02000000;\t \n\t\tmt->VDisplay >>= 1;\n\t\tmt->VSyncStart >>= 1;\n\t\tmt->VSyncEnd >>= 1;\n\t\tmt->VTotal >>= 1;\n\t}\n\tif ((mt->HTotal & 7) == 2) {\n\t\tdatactl |= 0x00000010;\n\t\tmt->HTotal &= ~7;\n\t}\n\ttmp |= 0x10000000;\t \n\tmga_outl(0x3C14, ((mt->HDisplay - 8) << 16) | (mt->HTotal - 8));\n\tmga_outl(0x3C18, ((mt->HSyncEnd - 8) << 16) | (mt->HSyncStart - 8));\n\tmga_outl(0x3C1C, ((mt->VDisplay - 1) << 16) | (mt->VTotal - 1));\n\tmga_outl(0x3C20, ((mt->VSyncEnd - 1) << 16) | (mt->VSyncStart - 1));\n\tmga_outl(0x3C24, ((mt->VSyncStart) << 16) | (mt->HSyncStart));\t \n\t{\n\t\tu_int32_t linelen = m2info->fbcon.var.xres_virtual * (m2info->fbcon.var.bits_per_pixel >> 3);\n\t\tif (tmp & 0x02000000) {\n\t\t\t \n\t\t\tmga_outl(0x3C2C, pos);\t\t\t \n\t\t\tmga_outl(0x3C28, pos + linelen);\t \n\t\t\tlinelen <<= 1;\n\t\t\tm2info->interlaced = 1;\n\t\t} else {\n\t\t\tmga_outl(0x3C28, pos);\t\t \n\t\t\tm2info->interlaced = 0;\n\t\t}\n\t\tmga_outl(0x3C40, linelen);\n\t}\n\tmga_outl(0x3C4C, datactl);\t \n\tif (tmp & 0x02000000) {\n\t\tint i;\n\n\t\tmga_outl(0x3C10, tmp & ~0x02000000);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tunsigned int nl;\n\t\t\tunsigned int lastl = 0;\n\n\t\t\twhile ((nl = mga_inl(0x3C48) & 0xFFF) >= lastl) {\n\t\t\t\tlastl = nl;\n\t\t\t}\n\t\t}\n\t}\n\tmga_outl(0x3C10, tmp);\n\tminfo->hw.crtc2.ctl = tmp;\n\n\ttmp = mt->VDisplay << 16;\t \n\tif (mt->sync & FB_SYNC_HOR_HIGH_ACT)\n\t\ttmp |= 0x00000100;\n\tif (mt->sync & FB_SYNC_VERT_HIGH_ACT)\n\t\ttmp |= 0x00000200;\n\tmga_outl(0x3C44, tmp);\n}\n\nstatic void matroxfb_dh_disable(struct matroxfb_dh_fb_info* m2info) {\n\tstruct matrox_fb_info *minfo = m2info->primary_dev;\n\n\tmga_outl(0x3C10, 0x00000004);\t \n\tminfo->hw.crtc2.ctl = 0x00000004;\n}\n\nstatic void matroxfb_dh_pan_var(struct matroxfb_dh_fb_info* m2info,\n\t\tstruct fb_var_screeninfo* var) {\n\tunsigned int pos;\n\tunsigned int linelen;\n\tunsigned int pixelsize;\n\tstruct matrox_fb_info *minfo = m2info->primary_dev;\n\n\tm2info->fbcon.var.xoffset = var->xoffset;\n\tm2info->fbcon.var.yoffset = var->yoffset;\n\tpixelsize = m2info->fbcon.var.bits_per_pixel >> 3;\n\tlinelen = m2info->fbcon.var.xres_virtual * pixelsize;\n\tpos = m2info->fbcon.var.yoffset * linelen + m2info->fbcon.var.xoffset * pixelsize;\n\tpos += m2info->video.offbase;\n\tif (m2info->interlaced) {\n\t\tmga_outl(0x3C2C, pos);\n\t\tmga_outl(0x3C28, pos + linelen);\n\t} else {\n\t\tmga_outl(0x3C28, pos);\n\t}\n}\n\nstatic int matroxfb_dh_decode_var(struct matroxfb_dh_fb_info* m2info,\n\t\tstruct fb_var_screeninfo* var,\n\t\tint *visual,\n\t\tint *video_cmap_len,\n\t\tint *mode) {\n\tunsigned int mask;\n\tunsigned int memlen;\n\tunsigned int vramlen;\n\n\tswitch (var->bits_per_pixel) {\n\t\tcase 16:\tmask = 0x1F;\n\t\t\t\tbreak;\n\t\tcase 32:\tmask = 0x0F;\n\t\t\t\tbreak;\n\t\tdefault:\treturn -EINVAL;\n\t}\n\tvramlen = m2info->video.len_usable;\n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres_virtual = var->yres;\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\tvar->xres_virtual = (var->xres_virtual + mask) & ~mask;\n\tif (var->yres_virtual > 32767)\n\t\treturn -EINVAL;\n\tmemlen = var->xres_virtual * var->yres_virtual * (var->bits_per_pixel >> 3);\n\tif (memlen > vramlen)\n\t\treturn -EINVAL;\n\tif (var->xoffset + var->xres > var->xres_virtual)\n\t\tvar->xoffset = var->xres_virtual - var->xres;\n\tif (var->yoffset + var->yres > var->yres_virtual)\n\t\tvar->yoffset = var->yres_virtual - var->yres;\n\n\tvar->xres &= ~7;\n\tvar->left_margin &= ~7;\n\tvar->right_margin &= ~7;\n\tvar->hsync_len &= ~7;\n\n\t*mode = var->bits_per_pixel;\n\tif (var->bits_per_pixel == 16) {\n\t\tif (var->green.length == 5) {\n\t\t\tvar->red.offset = 10;\n\t\t\tvar->red.length = 5;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->green.length = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->blue.length = 5;\n\t\t\tvar->transp.offset = 15;\n\t\t\tvar->transp.length = 1;\n\t\t\t*mode = 15;\n\t\t} else {\n\t\t\tvar->red.offset = 11;\n\t\t\tvar->red.length = 5;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->green.length = 6;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->blue.length = 5;\n\t\t\tvar->transp.offset = 0;\n\t\t\tvar->transp.length = 0;\n\t\t}\n\t} else {\n\t\t\tvar->red.offset = 16;\n\t\t\tvar->red.length = 8;\n\t\t\tvar->green.offset = 8;\n\t\t\tvar->green.length = 8;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->blue.length = 8;\n\t\t\tvar->transp.offset = 24;\n\t\t\tvar->transp.length = 8;\n\t}\n\t*visual = FB_VISUAL_TRUECOLOR;\n\t*video_cmap_len = 16;\n\treturn 0;\n}\n\nstatic int matroxfb_dh_open(struct fb_info* info, int user) {\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\n\tstruct matrox_fb_info *minfo = m2info->primary_dev;\n\n\tif (minfo) {\n\t\tint err;\n\n\t\tif (minfo->dead) {\n\t\t\treturn -ENXIO;\n\t\t}\n\t\terr = minfo->fbops.fb_open(&minfo->fbcon, user);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n#undef m2info\n}\n\nstatic int matroxfb_dh_release(struct fb_info* info, int user) {\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\n\tint err = 0;\n\tstruct matrox_fb_info *minfo = m2info->primary_dev;\n\n\tif (minfo) {\n\t\terr = minfo->fbops.fb_release(&minfo->fbcon, user);\n\t}\n\treturn err;\n#undef m2info\n}\n\n \nstatic void matroxfb_dh_init_fix(struct matroxfb_dh_fb_info *m2info)\n{\n\tstruct fb_fix_screeninfo *fix = &m2info->fbcon.fix;\n\n\tstrcpy(fix->id, \"MATROX DH\");\n\n\tfix->smem_start = m2info->video.base;\n\tfix->smem_len = m2info->video.len_usable;\n\tfix->ypanstep = 1;\n\tfix->ywrapstep = 0;\n\tfix->xpanstep = 8;\t \n\tfix->mmio_start = m2info->mmio.base;\n\tfix->mmio_len = m2info->mmio.len;\n\tfix->accel = 0;\t\t \n}\n\nstatic int matroxfb_dh_check_var(struct fb_var_screeninfo* var, struct fb_info* info) {\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\n\tint visual;\n\tint cmap_len;\n\tint mode;\n\n\treturn matroxfb_dh_decode_var(m2info, var, &visual, &cmap_len, &mode);\n#undef m2info\n}\n\nstatic int matroxfb_dh_set_par(struct fb_info* info) {\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\n\tint visual;\n\tint cmap_len;\n\tint mode;\n\tint err;\n\tstruct fb_var_screeninfo* var = &info->var;\n\tstruct matrox_fb_info *minfo = m2info->primary_dev;\n\n\tif ((err = matroxfb_dh_decode_var(m2info, var, &visual, &cmap_len, &mode)) != 0)\n\t\treturn err;\n\t \n\t{\n\t\tm2info->fbcon.screen_base = vaddr_va(m2info->video.vbase);\n\t\tm2info->fbcon.fix.visual = visual;\n\t\tm2info->fbcon.fix.type = FB_TYPE_PACKED_PIXELS;\n\t\tm2info->fbcon.fix.type_aux = 0;\n\t\tm2info->fbcon.fix.line_length = (var->xres_virtual * var->bits_per_pixel) >> 3;\n\t}\n\t{\n\t\tstruct my_timming mt;\n\t\tunsigned int pos;\n\t\tint out;\n\t\tint cnt;\n\n\t\tmatroxfb_var2my(&m2info->fbcon.var, &mt);\n\t\tmt.crtc = MATROXFB_SRC_CRTC2;\n\t\t \n\t\tmt.delay = 34;\n\n\t\tpos = (m2info->fbcon.var.yoffset * m2info->fbcon.var.xres_virtual + m2info->fbcon.var.xoffset) * m2info->fbcon.var.bits_per_pixel >> 3;\n\t\tpos += m2info->video.offbase;\n\t\tcnt = 0;\n\t\tdown_read(&minfo->altout.lock);\n\t\tfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\n\t\t\tif (minfo->outputs[out].src == MATROXFB_SRC_CRTC2) {\n\t\t\t\tcnt++;\n\t\t\t\tif (minfo->outputs[out].output->compute) {\n\t\t\t\t\tminfo->outputs[out].output->compute(minfo->outputs[out].data, &mt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tminfo->crtc2.pixclock = mt.pixclock;\n\t\tminfo->crtc2.mnp = mt.mnp;\n\t\tup_read(&minfo->altout.lock);\n\t\tif (cnt) {\n\t\t\tmatroxfb_dh_restore(m2info, &mt, mode, pos);\n\t\t} else {\n\t\t\tmatroxfb_dh_disable(m2info);\n\t\t}\n\t\tDAC1064_global_init(minfo);\n\t\tDAC1064_global_restore(minfo);\n\t\tdown_read(&minfo->altout.lock);\n\t\tfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\n\t\t\tif (minfo->outputs[out].src == MATROXFB_SRC_CRTC2 &&\n\t\t\t    minfo->outputs[out].output->program) {\n\t\t\t\tminfo->outputs[out].output->program(minfo->outputs[out].data);\n\t\t\t}\n\t\t}\n\t\tfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\n\t\t\tif (minfo->outputs[out].src == MATROXFB_SRC_CRTC2 &&\n\t\t\t    minfo->outputs[out].output->start) {\n\t\t\t\tminfo->outputs[out].output->start(minfo->outputs[out].data);\n\t\t\t}\n\t\t}\n\t\tup_read(&minfo->altout.lock);\n\t}\n\tm2info->initialized = 1;\n\treturn 0;\n#undef m2info\n}\n\nstatic int matroxfb_dh_pan_display(struct fb_var_screeninfo* var, struct fb_info* info) {\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\n\tmatroxfb_dh_pan_var(m2info, var);\n\treturn 0;\n#undef m2info\n}\n\nstatic int matroxfb_dh_get_vblank(const struct matroxfb_dh_fb_info* m2info, struct fb_vblank* vblank) {\n\tstruct matrox_fb_info *minfo = m2info->primary_dev;\n\n\tmatroxfb_enable_irq(minfo, 0);\n\tmemset(vblank, 0, sizeof(*vblank));\n\tvblank->flags = FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VBLANK;\n\t \n\tvblank->vcount = mga_inl(0x3C48) & 0x000007FF;\n\t \n\tif (vblank->vcount >= m2info->fbcon.var.yres)\n\t\tvblank->flags |= FB_VBLANK_VBLANKING;\n\tif (test_bit(0, &minfo->irq_flags)) {\n                vblank->flags |= FB_VBLANK_HAVE_COUNT;\n                 \n\t\tvblank->count = minfo->crtc2.vsync.cnt;\n        }\n\treturn 0;\n}\n\nstatic int matroxfb_dh_ioctl(struct fb_info *info,\n\t\tunsigned int cmd,\n\t\tunsigned long arg)\n{\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\n\tstruct matrox_fb_info *minfo = m2info->primary_dev;\n\n\tDBG(__func__)\n\n\tswitch (cmd) {\n\t\tcase FBIOGET_VBLANK:\n\t\t\t{\n\t\t\t\tstruct fb_vblank vblank;\n\t\t\t\tint err;\n\n\t\t\t\terr = matroxfb_dh_get_vblank(m2info, &vblank);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tcase FBIO_WAITFORVSYNC:\n\t\t\t{\n\t\t\t\tu_int32_t crt;\n\n\t\t\t\tif (get_user(crt, (u_int32_t __user *)arg))\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\tif (crt != 0)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\treturn matroxfb_wait_for_sync(minfo, 1);\n\t\t\t}\n\t\tcase MATROXFB_SET_OUTPUT_MODE:\n\t\tcase MATROXFB_GET_OUTPUT_MODE:\n\t\tcase MATROXFB_GET_ALL_OUTPUTS:\n\t\t\t{\n\t\t\t\treturn minfo->fbcon.fbops->fb_ioctl(&minfo->fbcon, cmd, arg);\n\t\t\t}\n\t\tcase MATROXFB_SET_OUTPUT_CONNECTION:\n\t\t\t{\n\t\t\t\tu_int32_t tmp;\n\t\t\t\tint out;\n\t\t\t\tint changes;\n\n\t\t\t\tif (get_user(tmp, (u_int32_t __user *)arg))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tfor (out = 0; out < 32; out++) {\n\t\t\t\t\tif (tmp & (1 << out)) {\n\t\t\t\t\t\tif (out >= MATROXFB_MAX_OUTPUTS)\n\t\t\t\t\t\t\treturn -ENXIO;\n\t\t\t\t\t\tif (!minfo->outputs[out].output)\n\t\t\t\t\t\t\treturn -ENXIO;\n\t\t\t\t\t\tswitch (minfo->outputs[out].src) {\n\t\t\t\t\t\t\tcase MATROXFB_SRC_NONE:\n\t\t\t\t\t\t\tcase MATROXFB_SRC_CRTC2:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn -EBUSY;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (minfo->devflags.panellink) {\n\t\t\t\t\tif (tmp & MATROXFB_OUTPUT_CONN_DFP)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tif ((minfo->outputs[2].src == MATROXFB_SRC_CRTC1) && tmp)\n\t\t\t\t\t\treturn -EBUSY;\n\t\t\t\t}\n\t\t\t\tchanges = 0;\n\t\t\t\tfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\n\t\t\t\t\tif (tmp & (1 << out)) {\n\t\t\t\t\t\tif (minfo->outputs[out].src != MATROXFB_SRC_CRTC2) {\n\t\t\t\t\t\t\tchanges = 1;\n\t\t\t\t\t\t\tminfo->outputs[out].src = MATROXFB_SRC_CRTC2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (minfo->outputs[out].src == MATROXFB_SRC_CRTC2) {\n\t\t\t\t\t\tchanges = 1;\n\t\t\t\t\t\tminfo->outputs[out].src = MATROXFB_SRC_NONE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!changes)\n\t\t\t\t\treturn 0;\n\t\t\t\tmatroxfb_dh_set_par(info);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tcase MATROXFB_GET_OUTPUT_CONNECTION:\n\t\t\t{\n\t\t\t\tu_int32_t conn = 0;\n\t\t\t\tint out;\n\n\t\t\t\tfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\n\t\t\t\t\tif (minfo->outputs[out].src == MATROXFB_SRC_CRTC2) {\n\t\t\t\t\t\tconn |= 1 << out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (put_user(conn, (u_int32_t __user *)arg))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tcase MATROXFB_GET_AVAILABLE_OUTPUTS:\n\t\t\t{\n\t\t\t\tu_int32_t tmp = 0;\n\t\t\t\tint out;\n\n\t\t\t\tfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\n\t\t\t\t\tif (minfo->outputs[out].output) {\n\t\t\t\t\t\tswitch (minfo->outputs[out].src) {\n\t\t\t\t\t\t\tcase MATROXFB_SRC_NONE:\n\t\t\t\t\t\t\tcase MATROXFB_SRC_CRTC2:\n\t\t\t\t\t\t\t\ttmp |= 1 << out;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (minfo->devflags.panellink) {\n\t\t\t\t\ttmp &= ~MATROXFB_OUTPUT_CONN_DFP;\n\t\t\t\t\tif (minfo->outputs[2].src == MATROXFB_SRC_CRTC1) {\n\t\t\t\t\t\ttmp = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (put_user(tmp, (u_int32_t __user *)arg))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t}\n\treturn -ENOTTY;\n#undef m2info\n}\n\nstatic int matroxfb_dh_blank(int blank, struct fb_info* info) {\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\n\tswitch (blank) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tdefault:;\n\t}\n\t \n\treturn 0;\n#undef m2info\n}\n\nstatic const struct fb_ops matroxfb_dh_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.fb_open =\tmatroxfb_dh_open,\n\t.fb_release =\tmatroxfb_dh_release,\n\t.fb_check_var =\tmatroxfb_dh_check_var,\n\t.fb_set_par =\tmatroxfb_dh_set_par,\n\t.fb_setcolreg =\tmatroxfb_dh_setcolreg,\n\t.fb_pan_display =matroxfb_dh_pan_display,\n\t.fb_blank =\tmatroxfb_dh_blank,\n\t.fb_ioctl =\tmatroxfb_dh_ioctl,\n\t.fb_fillrect =\tcfb_fillrect,\n\t.fb_copyarea =\tcfb_copyarea,\n\t.fb_imageblit =\tcfb_imageblit,\n};\n\nstatic struct fb_var_screeninfo matroxfb_dh_defined = {\n\t\t640,480,640,480, \n\t\t0,0,\t\t \n\t\t32,\t\t \n\t\t0,\t\t \n\t\t{0,0,0},\t \n\t\t{0,0,0},\t \n\t\t{0,0,0},\t \n\t\t{0,0,0},\t \n\t\t0,\t\t \n\t\tFB_ACTIVATE_NOW,\n\t\t-1,-1,\t\t \n\t\t0,\t\t \n\t\t39721L,48L,16L,33L,10L,\n\t\t96L,2,0,\t \n\t\tFB_VMODE_NONINTERLACED,\n};\n\nstatic int matroxfb_dh_regit(const struct matrox_fb_info *minfo,\n\t\t\t     struct matroxfb_dh_fb_info *m2info)\n{\n#define minfo (m2info->primary_dev)\n\tvoid* oldcrtc2;\n\n\tm2info->fbcon.fbops = &matroxfb_dh_ops;\n\tm2info->fbcon.flags = FBINFO_HWACCEL_XPAN |\n\t\t\t      FBINFO_HWACCEL_YPAN;\n\tm2info->fbcon.pseudo_palette = m2info->cmap;\n\tfb_alloc_cmap(&m2info->fbcon.cmap, 256, 1);\n\n\tif (mem < 64)\n\t\tmem *= 1024;\n\tif (mem < 64*1024)\n\t\tmem *= 1024;\n\tmem &= ~0x00000FFF;\t \n\tif (minfo->video.len_usable + mem <= minfo->video.len)\n\t\tm2info->video.offbase = minfo->video.len - mem;\n\telse if (minfo->video.len < mem) {\n\t\treturn -ENOMEM;\n\t} else {  \n\t\tm2info->video.borrowed = mem;\n\t\tminfo->video.len_usable -= mem;\n\t\tm2info->video.offbase = minfo->video.len_usable;\n\t}\n\tm2info->video.base = minfo->video.base + m2info->video.offbase;\n\tm2info->video.len = m2info->video.len_usable = m2info->video.len_maximum = mem;\n\tm2info->video.vbase.vaddr = vaddr_va(minfo->video.vbase) + m2info->video.offbase;\n\tm2info->mmio.base = minfo->mmio.base;\n\tm2info->mmio.vbase = minfo->mmio.vbase;\n\tm2info->mmio.len = minfo->mmio.len;\n\n\tmatroxfb_dh_init_fix(m2info);\n\tif (register_framebuffer(&m2info->fbcon)) {\n\t\treturn -ENXIO;\n\t}\n\tif (!m2info->initialized)\n\t\tfb_set_var(&m2info->fbcon, &matroxfb_dh_defined);\n\tdown_write(&minfo->crtc2.lock);\n\toldcrtc2 = minfo->crtc2.info;\n\tminfo->crtc2.info = m2info;\n\tup_write(&minfo->crtc2.lock);\n\tif (oldcrtc2) {\n\t\tprintk(KERN_ERR \"matroxfb_crtc2: Internal consistency check failed: crtc2 already present: %p\\n\",\n\t\t\toldcrtc2);\n\t}\n\treturn 0;\n#undef minfo\n}\n\n \n\nstatic int matroxfb_dh_registerfb(struct matroxfb_dh_fb_info* m2info) {\n#define minfo (m2info->primary_dev)\n\tif (matroxfb_dh_regit(minfo, m2info)) {\n\t\tprintk(KERN_ERR \"matroxfb_crtc2: secondary head failed to register\\n\");\n\t\treturn -1;\n\t}\n\tprintk(KERN_INFO \"matroxfb_crtc2: secondary head of fb%u was registered as fb%u\\n\",\n\t\tminfo->fbcon.node, m2info->fbcon.node);\n\tm2info->fbcon_registered = 1;\n\treturn 0;\n#undef minfo\n}\n\nstatic void matroxfb_dh_deregisterfb(struct matroxfb_dh_fb_info* m2info) {\n#define minfo (m2info->primary_dev)\n\tif (m2info->fbcon_registered) {\n\t\tint id;\n\t\tstruct matroxfb_dh_fb_info* crtc2;\n\n\t\tdown_write(&minfo->crtc2.lock);\n\t\tcrtc2 = minfo->crtc2.info;\n\t\tif (crtc2 == m2info)\n\t\t\tminfo->crtc2.info = NULL;\n\t\tup_write(&minfo->crtc2.lock);\n\t\tif (crtc2 != m2info) {\n\t\t\tprintk(KERN_ERR \"matroxfb_crtc2: Internal consistency check failed: crtc2 mismatch at unload: %p != %p\\n\",\n\t\t\t\tcrtc2, m2info);\n\t\t\tprintk(KERN_ERR \"matroxfb_crtc2: Expect kernel crash after module unload.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tid = m2info->fbcon.node;\n\t\tunregister_framebuffer(&m2info->fbcon);\n\t\t \n\t\tminfo->video.len_usable += m2info->video.borrowed;\n\t\tprintk(KERN_INFO \"matroxfb_crtc2: fb%u unregistered\\n\", id);\n\t\tm2info->fbcon_registered = 0;\n\t}\n#undef minfo\n}\n\nstatic void* matroxfb_crtc2_probe(struct matrox_fb_info* minfo) {\n\tstruct matroxfb_dh_fb_info* m2info;\n\n\t \n\tif (!minfo->devflags.crtc2)\n\t\treturn NULL;\n\tm2info = kzalloc(sizeof(*m2info), GFP_KERNEL);\n\tif (!m2info)\n\t\treturn NULL;\n\n\tm2info->primary_dev = minfo;\n\tif (matroxfb_dh_registerfb(m2info)) {\n\t\tkfree(m2info);\n\t\tprintk(KERN_ERR \"matroxfb_crtc2: CRTC2 framebuffer failed to register\\n\");\n\t\treturn NULL;\n\t}\n\treturn m2info;\n}\n\nstatic void matroxfb_crtc2_remove(struct matrox_fb_info* minfo, void* crtc2) {\n\tmatroxfb_dh_deregisterfb(crtc2);\n\tkfree(crtc2);\n}\n\nstatic struct matroxfb_driver crtc2 = {\n\t\t.name =\t\t\"Matrox G400 CRTC2\",\n\t\t.probe =\tmatroxfb_crtc2_probe,\n\t\t.remove =\tmatroxfb_crtc2_remove };\n\nstatic int matroxfb_crtc2_init(void) {\n\tif (fb_get_options(\"matrox_crtc2fb\", NULL))\n\t\treturn -ENODEV;\n\n\tmatroxfb_register_driver(&crtc2);\n\treturn 0;\n}\n\nstatic void matroxfb_crtc2_exit(void) {\n\tmatroxfb_unregister_driver(&crtc2);\n}\n\nMODULE_AUTHOR(\"(c) 1999-2002 Petr Vandrovec <vandrove@vc.cvut.cz>\");\nMODULE_DESCRIPTION(\"Matrox G400 CRTC2 driver\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(matroxfb_crtc2_init);\nmodule_exit(matroxfb_crtc2_exit);\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}