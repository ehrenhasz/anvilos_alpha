{
  "module_name": "matroxfb_accel.c",
  "hash_id": "bc12626f2d58192b89fac03c8fdb3db3389d89cf75485f1d105d91d3a6c68791",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/matrox/matroxfb_accel.c",
  "human_readable_source": "\n \n\n#include \"matroxfb_accel.h\"\n#include \"matroxfb_DAC1064.h\"\n#include \"matroxfb_Ti3026.h\"\n#include \"matroxfb_misc.h\"\n\n#define curr_ydstorg(x)\t((x)->curr.ydstorg.pixels)\n\n#define mga_ydstlen(y,l) mga_outl(M_YDSTLEN | M_EXEC, ((y) << 16) | (l))\n\nstatic inline void matrox_cfb4_pal(u_int32_t* pal) {\n\tunsigned int i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tpal[i] = i * 0x11111111U;\n\t}\n}\n\nstatic inline void matrox_cfb8_pal(u_int32_t* pal) {\n\tunsigned int i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tpal[i] = i * 0x01010101U;\n\t}\n}\n\nstatic void matroxfb_copyarea(struct fb_info* info, const struct fb_copyarea* area);\nstatic void matroxfb_fillrect(struct fb_info* info, const struct fb_fillrect* rect);\nstatic void matroxfb_imageblit(struct fb_info* info, const struct fb_image* image);\nstatic void matroxfb_cfb4_fillrect(struct fb_info* info, const struct fb_fillrect* rect);\nstatic void matroxfb_cfb4_copyarea(struct fb_info* info, const struct fb_copyarea* area);\n\nvoid matrox_cfbX_init(struct matrox_fb_info *minfo)\n{\n\tu_int32_t maccess;\n\tu_int32_t mpitch;\n\tu_int32_t mopmode;\n\tint accel;\n\n\tDBG(__func__)\n\n\tmpitch = minfo->fbcon.var.xres_virtual;\n\n\tminfo->fbops.fb_copyarea = cfb_copyarea;\n\tminfo->fbops.fb_fillrect = cfb_fillrect;\n\tminfo->fbops.fb_imageblit = cfb_imageblit;\n\tminfo->fbops.fb_cursor = NULL;\n\n\taccel = (minfo->fbcon.var.accel_flags & FB_ACCELF_TEXT) == FB_ACCELF_TEXT;\n\n\tswitch (minfo->fbcon.var.bits_per_pixel) {\n\t\tcase 4:\t\tmaccess = 0x00000000;\t \n\t\t\t\tmpitch = (mpitch >> 1) | 0x8000;  \n\t\t\t\tmopmode = M_OPMODE_4BPP;\n\t\t\t\tmatrox_cfb4_pal(minfo->cmap);\n\t\t\t\tif (accel && !(mpitch & 1)) {\n\t\t\t\t\tminfo->fbops.fb_copyarea = matroxfb_cfb4_copyarea;\n\t\t\t\t\tminfo->fbops.fb_fillrect = matroxfb_cfb4_fillrect;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\tcase 8:\t\tmaccess = 0x00000000;\n\t\t\t\tmopmode = M_OPMODE_8BPP;\n\t\t\t\tmatrox_cfb8_pal(minfo->cmap);\n\t\t\t\tif (accel) {\n\t\t\t\t\tminfo->fbops.fb_copyarea = matroxfb_copyarea;\n\t\t\t\t\tminfo->fbops.fb_fillrect = matroxfb_fillrect;\n\t\t\t\t\tminfo->fbops.fb_imageblit = matroxfb_imageblit;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\tcase 16:\tif (minfo->fbcon.var.green.length == 5)\n\t\t\t\t\tmaccess = 0xC0000001;\n\t\t\t\telse\n\t\t\t\t\tmaccess = 0x40000001;\n\t\t\t\tmopmode = M_OPMODE_16BPP;\n\t\t\t\tif (accel) {\n\t\t\t\t\tminfo->fbops.fb_copyarea = matroxfb_copyarea;\n\t\t\t\t\tminfo->fbops.fb_fillrect = matroxfb_fillrect;\n\t\t\t\t\tminfo->fbops.fb_imageblit = matroxfb_imageblit;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\tcase 24:\tmaccess = 0x00000003;\n\t\t\t\tmopmode = M_OPMODE_24BPP;\n\t\t\t\tif (accel) {\n\t\t\t\t\tminfo->fbops.fb_copyarea = matroxfb_copyarea;\n\t\t\t\t\tminfo->fbops.fb_fillrect = matroxfb_fillrect;\n\t\t\t\t\tminfo->fbops.fb_imageblit = matroxfb_imageblit;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\tcase 32:\tmaccess = 0x00000002;\n\t\t\t\tmopmode = M_OPMODE_32BPP;\n\t\t\t\tif (accel) {\n\t\t\t\t\tminfo->fbops.fb_copyarea = matroxfb_copyarea;\n\t\t\t\t\tminfo->fbops.fb_fillrect = matroxfb_fillrect;\n\t\t\t\t\tminfo->fbops.fb_imageblit = matroxfb_imageblit;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\tdefault:\tmaccess = 0x00000000;\n\t\t\t\tmopmode = 0x00000000;\n\t\t\t\tbreak;\t \n\t}\n\tmga_fifo(8);\n\tmga_outl(M_PITCH, mpitch);\n\tmga_outl(M_YDSTORG, curr_ydstorg(minfo));\n\tif (minfo->capable.plnwt)\n\t\tmga_outl(M_PLNWT, -1);\n\tif (minfo->capable.srcorg) {\n\t\tmga_outl(M_SRCORG, 0);\n\t\tmga_outl(M_DSTORG, 0);\n\t}\n\tmga_outl(M_OPMODE, mopmode);\n\tmga_outl(M_CXBNDRY, 0xFFFF0000);\n\tmga_outl(M_YTOP, 0);\n\tmga_outl(M_YBOT, 0x01FFFFFF);\n\tmga_outl(M_MACCESS, maccess);\n\tminfo->accel.m_dwg_rect = M_DWG_TRAP | M_DWG_SOLID | M_DWG_ARZERO | M_DWG_SGNZERO | M_DWG_SHIFTZERO;\n\tif (isMilleniumII(minfo)) minfo->accel.m_dwg_rect |= M_DWG_TRANSC;\n\tminfo->accel.m_opmode = mopmode;\n\tminfo->accel.m_access = maccess;\n\tminfo->accel.m_pitch = mpitch;\n}\n\nEXPORT_SYMBOL(matrox_cfbX_init);\n\nstatic void matrox_accel_restore_maccess(struct matrox_fb_info *minfo)\n{\n\tmga_outl(M_MACCESS, minfo->accel.m_access);\n\tmga_outl(M_PITCH, minfo->accel.m_pitch);\n}\n\nstatic void matrox_accel_bmove(struct matrox_fb_info *minfo, int vxres, int sy,\n\t\t\t       int sx, int dy, int dx, int height, int width)\n{\n\tint start, end;\n\tCRITFLAGS\n\n\tDBG(__func__)\n\n\tCRITBEGIN\n\n\tif ((dy < sy) || ((dy == sy) && (dx <= sx))) {\n\t\tmga_fifo(4);\n\t\tmatrox_accel_restore_maccess(minfo);\n\t\tmga_outl(M_DWGCTL, M_DWG_BITBLT | M_DWG_SHIFTZERO | M_DWG_SGNZERO |\n\t\t\t M_DWG_BFCOL | M_DWG_REPLACE);\n\t\tmga_outl(M_AR5, vxres);\n\t\twidth--;\n\t\tstart = sy*vxres+sx+curr_ydstorg(minfo);\n\t\tend = start+width;\n\t} else {\n\t\tmga_fifo(5);\n\t\tmatrox_accel_restore_maccess(minfo);\n\t\tmga_outl(M_DWGCTL, M_DWG_BITBLT | M_DWG_SHIFTZERO | M_DWG_BFCOL | M_DWG_REPLACE);\n\t\tmga_outl(M_SGN, 5);\n\t\tmga_outl(M_AR5, -vxres);\n\t\twidth--;\n\t\tend = (sy+height-1)*vxres+sx+curr_ydstorg(minfo);\n\t\tstart = end+width;\n\t\tdy += height-1;\n\t}\n\tmga_fifo(6);\n\tmatrox_accel_restore_maccess(minfo);\n\tmga_outl(M_AR0, end);\n\tmga_outl(M_AR3, start);\n\tmga_outl(M_FXBNDRY, ((dx+width)<<16) | dx);\n\tmga_ydstlen(dy, height);\n\tWaitTillIdle();\n\n\tCRITEND\n}\n\nstatic void matrox_accel_bmove_lin(struct matrox_fb_info *minfo, int vxres,\n\t\t\t\t   int sy, int sx, int dy, int dx, int height,\n\t\t\t\t   int width)\n{\n\tint start, end;\n\tCRITFLAGS\n\n\tDBG(__func__)\n\n\tCRITBEGIN\n\n\tif ((dy < sy) || ((dy == sy) && (dx <= sx))) {\n\t\tmga_fifo(4);\n\t\tmatrox_accel_restore_maccess(minfo);\n\t\tmga_outl(M_DWGCTL, M_DWG_BITBLT | M_DWG_SHIFTZERO | M_DWG_SGNZERO |\n\t\t\tM_DWG_BFCOL | M_DWG_REPLACE);\n\t\tmga_outl(M_AR5, vxres);\n\t\twidth--;\n\t\tstart = sy*vxres+sx+curr_ydstorg(minfo);\n\t\tend = start+width;\n\t} else {\n\t\tmga_fifo(5);\n\t\tmatrox_accel_restore_maccess(minfo);\n\t\tmga_outl(M_DWGCTL, M_DWG_BITBLT | M_DWG_SHIFTZERO | M_DWG_BFCOL | M_DWG_REPLACE);\n\t\tmga_outl(M_SGN, 5);\n\t\tmga_outl(M_AR5, -vxres);\n\t\twidth--;\n\t\tend = (sy+height-1)*vxres+sx+curr_ydstorg(minfo);\n\t\tstart = end+width;\n\t\tdy += height-1;\n\t}\n\tmga_fifo(7);\n\tmatrox_accel_restore_maccess(minfo);\n\tmga_outl(M_AR0, end);\n\tmga_outl(M_AR3, start);\n\tmga_outl(M_FXBNDRY, ((dx+width)<<16) | dx);\n\tmga_outl(M_YDST, dy*vxres >> 5);\n\tmga_outl(M_LEN | M_EXEC, height);\n\tWaitTillIdle();\n\n\tCRITEND\n}\n\nstatic void matroxfb_cfb4_copyarea(struct fb_info* info, const struct fb_copyarea* area) {\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tif ((area->sx | area->dx | area->width) & 1)\n\t\tcfb_copyarea(info, area);\n\telse\n\t\tmatrox_accel_bmove_lin(minfo, minfo->fbcon.var.xres_virtual >> 1, area->sy, area->sx >> 1, area->dy, area->dx >> 1, area->height, area->width >> 1);\n}\n\nstatic void matroxfb_copyarea(struct fb_info* info, const struct fb_copyarea* area) {\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tmatrox_accel_bmove(minfo, minfo->fbcon.var.xres_virtual, area->sy, area->sx, area->dy, area->dx, area->height, area->width);\n}\n\nstatic void matroxfb_accel_clear(struct matrox_fb_info *minfo, u_int32_t color,\n\t\t\t\t int sy, int sx, int height, int width)\n{\n\tCRITFLAGS\n\n\tDBG(__func__)\n\n\tCRITBEGIN\n\n\tmga_fifo(7);\n\tmatrox_accel_restore_maccess(minfo);\n\tmga_outl(M_DWGCTL, minfo->accel.m_dwg_rect | M_DWG_REPLACE);\n\tmga_outl(M_FCOL, color);\n\tmga_outl(M_FXBNDRY, ((sx + width) << 16) | sx);\n\tmga_ydstlen(sy, height);\n\tWaitTillIdle();\n\n\tCRITEND\n}\n\nstatic void matroxfb_fillrect(struct fb_info* info, const struct fb_fillrect* rect) {\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tswitch (rect->rop) {\n\t\tcase ROP_COPY:\n\t\t\tmatroxfb_accel_clear(minfo, ((u_int32_t *)info->pseudo_palette)[rect->color], rect->dy, rect->dx, rect->height, rect->width);\n\t\t\tbreak;\n\t}\n}\n\nstatic void matroxfb_cfb4_clear(struct matrox_fb_info *minfo, u_int32_t bgx,\n\t\t\t\tint sy, int sx, int height, int width)\n{\n\tint whattodo;\n\tCRITFLAGS\n\n\tDBG(__func__)\n\n\tCRITBEGIN\n\n\twhattodo = 0;\n\tif (sx & 1) {\n\t\tsx ++;\n\t\tif (!width) return;\n\t\twidth --;\n\t\twhattodo = 1;\n\t}\n\tif (width & 1) {\n\t\twhattodo |= 2;\n\t}\n\twidth >>= 1;\n\tsx >>= 1;\n\tif (width) {\n\t\tmga_fifo(7);\n\t\tmatrox_accel_restore_maccess(minfo);\n\t\tmga_outl(M_DWGCTL, minfo->accel.m_dwg_rect | M_DWG_REPLACE2);\n\t\tmga_outl(M_FCOL, bgx);\n\t\tmga_outl(M_FXBNDRY, ((sx + width) << 16) | sx);\n\t\tmga_outl(M_YDST, sy * minfo->fbcon.var.xres_virtual >> 6);\n\t\tmga_outl(M_LEN | M_EXEC, height);\n\t\tWaitTillIdle();\n\t}\n\tif (whattodo) {\n\t\tu_int32_t step = minfo->fbcon.var.xres_virtual >> 1;\n\t\tvaddr_t vbase = minfo->video.vbase;\n\t\tif (whattodo & 1) {\n\t\t\tunsigned int uaddr = sy * step + sx - 1;\n\t\t\tu_int32_t loop;\n\t\t\tu_int8_t bgx2 = bgx & 0xF0;\n\t\t\tfor (loop = height; loop > 0; loop --) {\n\t\t\t\tmga_writeb(vbase, uaddr, (mga_readb(vbase, uaddr) & 0x0F) | bgx2);\n\t\t\t\tuaddr += step;\n\t\t\t}\n\t\t}\n\t\tif (whattodo & 2) {\n\t\t\tunsigned int uaddr = sy * step + sx + width;\n\t\t\tu_int32_t loop;\n\t\t\tu_int8_t bgx2 = bgx & 0x0F;\n\t\t\tfor (loop = height; loop > 0; loop --) {\n\t\t\t\tmga_writeb(vbase, uaddr, (mga_readb(vbase, uaddr) & 0xF0) | bgx2);\n\t\t\t\tuaddr += step;\n\t\t\t}\n\t\t}\n\t}\n\n\tCRITEND\n}\n\nstatic void matroxfb_cfb4_fillrect(struct fb_info* info, const struct fb_fillrect* rect) {\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tswitch (rect->rop) {\n\t\tcase ROP_COPY:\n\t\t\tmatroxfb_cfb4_clear(minfo, ((u_int32_t *)info->pseudo_palette)[rect->color], rect->dy, rect->dx, rect->height, rect->width);\n\t\t\tbreak;\n\t}\n}\n\nstatic void matroxfb_1bpp_imageblit(struct matrox_fb_info *minfo, u_int32_t fgx,\n\t\t\t\t    u_int32_t bgx, const u_int8_t *chardata,\n\t\t\t\t    int width, int height, int yy, int xx)\n{\n\tu_int32_t step;\n\tu_int32_t ydstlen;\n\tu_int32_t xlen;\n\tu_int32_t ar0;\n\tu_int32_t charcell;\n\tu_int32_t fxbndry;\n\tvaddr_t mmio;\n\tint easy;\n\tCRITFLAGS\n\n\tDBG_HEAVY(__func__);\n\n\tstep = (width + 7) >> 3;\n\tcharcell = height * step;\n\txlen = (charcell + 3) & ~3;\n\tydstlen = (yy << 16) | height;\n\tif (width == step << 3) {\n\t\tar0 = height * width - 1;\n\t\teasy = 1;\n\t} else {\n\t\tar0 = width - 1;\n\t\teasy = 0;\n\t}\n\n\tCRITBEGIN\n\n\tmga_fifo(5);\n\tmatrox_accel_restore_maccess(minfo);\n\tif (easy)\n\t\tmga_outl(M_DWGCTL, M_DWG_ILOAD | M_DWG_SGNZERO | M_DWG_SHIFTZERO | M_DWG_BMONOWF | M_DWG_LINEAR | M_DWG_REPLACE);\n\telse\n\t\tmga_outl(M_DWGCTL, M_DWG_ILOAD | M_DWG_SGNZERO | M_DWG_SHIFTZERO | M_DWG_BMONOWF | M_DWG_REPLACE);\n\tmga_outl(M_FCOL, fgx);\n\tmga_outl(M_BCOL, bgx);\n\tfxbndry = ((xx + width - 1) << 16) | xx;\n\tmmio = minfo->mmio.vbase;\n\n\tmga_fifo(8);\n\tmatrox_accel_restore_maccess(minfo);\n\tmga_writel(mmio, M_FXBNDRY, fxbndry);\n\tmga_writel(mmio, M_AR0, ar0);\n\tmga_writel(mmio, M_AR3, 0);\n\tif (easy) {\n\t\tmga_writel(mmio, M_YDSTLEN | M_EXEC, ydstlen);\n\t\tmga_memcpy_toio(mmio, chardata, xlen);\n\t} else {\n\t\tmga_writel(mmio, M_AR5, 0);\n\t\tmga_writel(mmio, M_YDSTLEN | M_EXEC, ydstlen);\n\t\tif ((step & 3) == 0) {\n\t\t\t \n\t\t\tmga_memcpy_toio(mmio, chardata, charcell);\n\t\t} else if (step == 1) {\n\t\t\t \n\t\t\twhile (height--) {\n#if defined(__BIG_ENDIAN)\n\t\t\t\tfb_writel((*chardata) << 24, mmio.vaddr);\n#else\n\t\t\t\tfb_writel(*chardata, mmio.vaddr);\n#endif\n\t\t\t\tchardata++;\n\t\t\t}\n\t\t} else if (step == 2) {\n\t\t\t \n\t\t\twhile (height--) {\n#if defined(__BIG_ENDIAN)\n\t\t\t\tfb_writel((*(u_int16_t*)chardata) << 16, mmio.vaddr);\n#else\n\t\t\t\tfb_writel(*(u_int16_t*)chardata, mmio.vaddr);\n#endif\n\t\t\t\tchardata += 2;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\twhile (height--) {\n\t\t\t\tsize_t i;\n\n\t\t\t\tfor (i = 0; i < step; i += 4) {\n\t\t\t\t\t \n\t\t\t\t\tfb_writel(get_unaligned((u_int32_t*)(chardata + i)),mmio.vaddr);\n\t\t\t\t}\n\t\t\t\tchardata += step;\n\t\t\t}\n\t\t}\n\t}\n\tWaitTillIdle();\n\tCRITEND\n}\n\n\nstatic void matroxfb_imageblit(struct fb_info* info, const struct fb_image* image) {\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tDBG_HEAVY(__func__);\n\n\tif (image->depth == 1) {\n\t\tu_int32_t fgx, bgx;\n\n\t\tfgx = ((u_int32_t*)info->pseudo_palette)[image->fg_color];\n\t\tbgx = ((u_int32_t*)info->pseudo_palette)[image->bg_color];\n\t\tmatroxfb_1bpp_imageblit(minfo, fgx, bgx, image->data, image->width, image->height, image->dy, image->dx);\n\t} else {\n\t\t \n\t\tcfb_imageblit(info, image);\n\t}\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}