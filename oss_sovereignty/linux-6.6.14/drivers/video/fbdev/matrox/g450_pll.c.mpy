{
  "module_name": "g450_pll.c",
  "hash_id": "aaa2b34cc7654e94af52a6315ab7ac622349ef912e6fa865ce35d641486b18a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/matrox/g450_pll.c",
  "human_readable_source": " \n\n#include \"g450_pll.h\"\n#include \"matroxfb_DAC1064.h\"\n\nstatic inline unsigned int g450_vco2f(unsigned char p, unsigned int fvco) {\n\treturn (p & 0x40) ? fvco : fvco >> ((p & 3) + 1);\n}\n\nstatic inline unsigned int g450_f2vco(unsigned char p, unsigned int fin) {\n\treturn (p & 0x40) ? fin : fin << ((p & 3) + 1);\n}\n\nstatic unsigned int g450_mnp2vco(const struct matrox_fb_info *minfo,\n\t\t\t\t unsigned int mnp)\n{\n\tunsigned int m, n;\n\n\tm = ((mnp >> 16) & 0x0FF) + 1;\n\tn = ((mnp >>  7) & 0x1FE) + 4;\n\treturn (minfo->features.pll.ref_freq * n + (m >> 1)) / m;\n}\n\nunsigned int g450_mnp2f(const struct matrox_fb_info *minfo, unsigned int mnp)\n{\n\treturn g450_vco2f(mnp, g450_mnp2vco(minfo, mnp));\n}\n\nstatic inline unsigned int pll_freq_delta(unsigned int f1, unsigned int f2) {\n\tif (f2 < f1) {\n    \t\tf2 = f1 - f2;\n\t} else {\n\t\tf2 = f2 - f1;\n\t}\n\treturn f2;\n}\n\n#define NO_MORE_MNP\t0x01FFFFFF\n#define G450_MNP_FREQBITS\t(0xFFFFFF43)\t \n\nstatic unsigned int g450_nextpll(const struct matrox_fb_info *minfo,\n\t\t\t\t const struct matrox_pll_limits *pi,\n\t\t\t\t unsigned int *fvco, unsigned int mnp)\n{\n\tunsigned int m, n, p;\n\tunsigned int tvco = *fvco;\n\n\tm = (mnp >> 16) & 0xFF;\n\tp = mnp & 0xFF;\n\n\tdo {\n\t\tif (m == 0 || m == 0xFF) {\n\t\t\tif (m == 0) {\n\t\t\t\tif (p & 0x40) {\n\t\t\t\t\treturn NO_MORE_MNP;\n\t\t\t\t}\n\t\t\t        if (p & 3) {\n\t\t\t\t\tp--;\n\t\t\t\t} else {\n\t\t\t\t\tp = 0x40;\n\t\t\t\t}\n\t\t\t\ttvco >>= 1;\n\t\t\t\tif (tvco < pi->vcomin) {\n\t\t\t\t\treturn NO_MORE_MNP;\n\t\t\t\t}\n\t\t\t\t*fvco = tvco;\n\t\t\t}\n\n\t\t\tp &= 0x43;\n\t\t\tif (tvco < 550000) {\n \n\t\t\t} else if (tvco < 700000) {\n\t\t\t\tp |= 0x08;\n\t\t\t} else if (tvco < 1000000) {\n\t\t\t\tp |= 0x10;\n\t\t\t} else if (tvco < 1150000) {\n\t\t\t\tp |= 0x18;\n\t\t\t} else {\n\t\t\t\tp |= 0x20;\n\t\t\t}\n\t\t\tm = 9;\n\t\t} else {\n\t\t\tm--;\n\t\t}\n\t\tn = ((tvco * (m+1) + minfo->features.pll.ref_freq) / (minfo->features.pll.ref_freq * 2)) - 2;\n\t} while (n < 0x03 || n > 0x7A);\n\treturn (m << 16) | (n << 8) | p;\n}\n\nstatic unsigned int g450_firstpll(const struct matrox_fb_info *minfo,\n\t\t\t\t  const struct matrox_pll_limits *pi,\n\t\t\t\t  unsigned int *vco, unsigned int fout)\n{\n\tunsigned int p;\n\tunsigned int vcomax;\n\n\tvcomax = pi->vcomax;\n\tif (fout > (vcomax / 2)) {\n\t\tif (fout > vcomax) {\n\t\t\t*vco = vcomax;\n\t\t} else {\n\t\t\t*vco = fout;\n\t\t}\n\t\tp = 0x40;\n\t} else {\n\t\tunsigned int tvco;\n\n\t\tp = 3;\n\t\ttvco = g450_f2vco(p, fout);\n\t\twhile (p && (tvco > vcomax)) {\n\t\t\tp--;\n\t\t\ttvco >>= 1;\n\t\t}\n\t\tif (tvco < pi->vcomin) {\n\t\t\ttvco = pi->vcomin;\n\t\t}\n\t\t*vco = tvco;\n\t}\n\treturn g450_nextpll(minfo, pi, vco, 0xFF0000 | p);\n}\n\nstatic inline unsigned int g450_setpll(const struct matrox_fb_info *minfo,\n\t\t\t\t       unsigned int mnp, unsigned int pll)\n{\n\tswitch (pll) {\n\t\tcase M_PIXEL_PLL_A:\n\t\t\tmatroxfb_DAC_out(minfo, M1064_XPIXPLLAM, mnp >> 16);\n\t\t\tmatroxfb_DAC_out(minfo, M1064_XPIXPLLAN, mnp >> 8);\n\t\t\tmatroxfb_DAC_out(minfo, M1064_XPIXPLLAP, mnp);\n\t\t\treturn M1064_XPIXPLLSTAT;\n\n\t\tcase M_PIXEL_PLL_B:\n\t\t\tmatroxfb_DAC_out(minfo, M1064_XPIXPLLBM, mnp >> 16);\n\t\t\tmatroxfb_DAC_out(minfo, M1064_XPIXPLLBN, mnp >> 8);\n\t\t\tmatroxfb_DAC_out(minfo, M1064_XPIXPLLBP, mnp);\n\t\t\treturn M1064_XPIXPLLSTAT;\n\n\t\tcase M_PIXEL_PLL_C:\n\t\t\tmatroxfb_DAC_out(minfo, M1064_XPIXPLLCM, mnp >> 16);\n\t\t\tmatroxfb_DAC_out(minfo, M1064_XPIXPLLCN, mnp >> 8);\n\t\t\tmatroxfb_DAC_out(minfo, M1064_XPIXPLLCP, mnp);\n\t\t\treturn M1064_XPIXPLLSTAT;\n\n\t\tcase M_SYSTEM_PLL:\n\t\t\tmatroxfb_DAC_out(minfo, DAC1064_XSYSPLLM, mnp >> 16);\n\t\t\tmatroxfb_DAC_out(minfo, DAC1064_XSYSPLLN, mnp >> 8);\n\t\t\tmatroxfb_DAC_out(minfo, DAC1064_XSYSPLLP, mnp);\n\t\t\treturn DAC1064_XSYSPLLSTAT;\n\n\t\tcase M_VIDEO_PLL:\n\t\t\tmatroxfb_DAC_out(minfo, M1064_XVIDPLLM, mnp >> 16);\n\t\t\tmatroxfb_DAC_out(minfo, M1064_XVIDPLLN, mnp >> 8);\n\t\t\tmatroxfb_DAC_out(minfo, M1064_XVIDPLLP, mnp);\n\t\t\treturn M1064_XVIDPLLSTAT;\n\t}\n\treturn 0;\n}\n\nstatic inline unsigned int g450_cmppll(const struct matrox_fb_info *minfo,\n\t\t\t\t       unsigned int mnp, unsigned int pll)\n{\n\tunsigned char m = mnp >> 16;\n\tunsigned char n = mnp >> 8;\n\tunsigned char p = mnp;\n\n\tswitch (pll) {\n\t\tcase M_PIXEL_PLL_A:\n\t\t\treturn (matroxfb_DAC_in(minfo, M1064_XPIXPLLAM) != m ||\n\t\t\t\tmatroxfb_DAC_in(minfo, M1064_XPIXPLLAN) != n ||\n\t\t\t\tmatroxfb_DAC_in(minfo, M1064_XPIXPLLAP) != p);\n\n\t\tcase M_PIXEL_PLL_B:\n\t\t\treturn (matroxfb_DAC_in(minfo, M1064_XPIXPLLBM) != m ||\n\t\t\t\tmatroxfb_DAC_in(minfo, M1064_XPIXPLLBN) != n ||\n\t\t\t\tmatroxfb_DAC_in(minfo, M1064_XPIXPLLBP) != p);\n\n\t\tcase M_PIXEL_PLL_C:\n\t\t\treturn (matroxfb_DAC_in(minfo, M1064_XPIXPLLCM) != m ||\n\t\t\t\tmatroxfb_DAC_in(minfo, M1064_XPIXPLLCN) != n ||\n\t\t\t\tmatroxfb_DAC_in(minfo, M1064_XPIXPLLCP) != p);\n\n\t\tcase M_SYSTEM_PLL:\n\t\t\treturn (matroxfb_DAC_in(minfo, DAC1064_XSYSPLLM) != m ||\n\t\t\t\tmatroxfb_DAC_in(minfo, DAC1064_XSYSPLLN) != n ||\n\t\t\t\tmatroxfb_DAC_in(minfo, DAC1064_XSYSPLLP) != p);\n\n\t\tcase M_VIDEO_PLL:\n\t\t\treturn (matroxfb_DAC_in(minfo, M1064_XVIDPLLM) != m ||\n\t\t\t\tmatroxfb_DAC_in(minfo, M1064_XVIDPLLN) != n ||\n\t\t\t\tmatroxfb_DAC_in(minfo, M1064_XVIDPLLP) != p);\n\t}\n\treturn 1;\n}\n\nstatic inline int g450_isplllocked(const struct matrox_fb_info *minfo,\n\t\t\t\t   unsigned int regidx)\n{\n\tunsigned int j;\n\n\tfor (j = 0; j < 1000; j++) {\n\t\tif (matroxfb_DAC_in(minfo, regidx) & 0x40) {\n\t\t\tunsigned int r = 0;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tr += matroxfb_DAC_in(minfo, regidx) & 0x40;\n\t\t\t}\n\t\t\treturn r >= (90 * 0x40);\n\t\t}\n\t\t \n\t}\n\treturn 0;\n}\n\nstatic int g450_testpll(const struct matrox_fb_info *minfo, unsigned int mnp,\n\t\t\tunsigned int pll)\n{\n\treturn g450_isplllocked(minfo, g450_setpll(minfo, mnp, pll));\n}\n\nstatic void updatehwstate_clk(struct matrox_hw_state* hw, unsigned int mnp, unsigned int pll) {\n\tswitch (pll) {\n\t\tcase M_SYSTEM_PLL:\n\t\t\thw->DACclk[3] = mnp >> 16;\n\t\t\thw->DACclk[4] = mnp >> 8;\n\t\t\thw->DACclk[5] = mnp;\n\t\t\tbreak;\n\t}\n}\n\nvoid matroxfb_g450_setpll_cond(struct matrox_fb_info *minfo, unsigned int mnp,\n\t\t\t       unsigned int pll)\n{\n\tif (g450_cmppll(minfo, mnp, pll)) {\n\t\tg450_setpll(minfo, mnp, pll);\n\t}\n}\n\nstatic inline unsigned int g450_findworkingpll(struct matrox_fb_info *minfo,\n\t\t\t\t\t       unsigned int pll,\n\t\t\t\t\t       unsigned int *mnparray,\n\t\t\t\t\t       unsigned int mnpcount)\n{\n\tunsigned int found = 0;\n\tunsigned int idx;\n\tunsigned int mnpfound = mnparray[0];\n\t\t\n\tfor (idx = 0; idx < mnpcount; idx++) {\n\t\tunsigned int sarray[3];\n\t\tunsigned int *sptr;\n\t\t{\n\t\t\tunsigned int mnp;\n\t\t\n\t\t\tsptr = sarray;\n\t\t\tmnp = mnparray[idx];\n\t\t\tif (mnp & 0x38) {\n\t\t\t\t*sptr++ = mnp - 8;\n\t\t\t}\n\t\t\tif ((mnp & 0x38) != 0x38) {\n\t\t\t\t*sptr++ = mnp + 8;\n\t\t\t}\n\t\t\t*sptr = mnp;\n\t\t}\n\t\twhile (sptr >= sarray) {\n\t\t\tunsigned int mnp = *sptr--;\n\t\t\n\t\t\tif (g450_testpll(minfo, mnp - 0x0300, pll) &&\n\t\t\t    g450_testpll(minfo, mnp + 0x0300, pll) &&\n\t\t\t    g450_testpll(minfo, mnp - 0x0200, pll) &&\n\t\t\t    g450_testpll(minfo, mnp + 0x0200, pll) &&\n\t\t\t    g450_testpll(minfo, mnp - 0x0100, pll) &&\n\t\t\t    g450_testpll(minfo, mnp + 0x0100, pll)) {\n\t\t\t\tif (g450_testpll(minfo, mnp, pll)) {\n\t\t\t\t\treturn mnp;\n\t\t\t\t}\n\t\t\t} else if (!found && g450_testpll(minfo, mnp, pll)) {\n\t\t\t\tmnpfound = mnp;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t}\n\tg450_setpll(minfo, mnpfound, pll);\n\treturn mnpfound;\n}\n\nstatic void g450_addcache(struct matrox_pll_cache* ci, unsigned int mnp_key, unsigned int mnp_value) {\n\tif (++ci->valid > ARRAY_SIZE(ci->data)) {\n\t\tci->valid = ARRAY_SIZE(ci->data);\n\t}\n\tmemmove(ci->data + 1, ci->data, (ci->valid - 1) * sizeof(*ci->data));\n\tci->data[0].mnp_key = mnp_key & G450_MNP_FREQBITS;\n\tci->data[0].mnp_value = mnp_value;\n}\n\nstatic int g450_checkcache(struct matrox_fb_info *minfo,\n\t\t\t   struct matrox_pll_cache *ci, unsigned int mnp_key)\n{\n\tunsigned int i;\n\t\n\tmnp_key &= G450_MNP_FREQBITS;\n\tfor (i = 0; i < ci->valid; i++) {\n\t\tif (ci->data[i].mnp_key == mnp_key) {\n\t\t\tunsigned int mnp;\n\t\t\t\n\t\t\tmnp = ci->data[i].mnp_value;\n\t\t\tif (i) {\n\t\t\t\tmemmove(ci->data + 1, ci->data, i * sizeof(*ci->data));\n\t\t\t\tci->data[0].mnp_key = mnp_key;\n\t\t\t\tci->data[0].mnp_value = mnp;\n\t\t\t}\n\t\t\treturn mnp;\n\t\t}\n\t}\n\treturn NO_MORE_MNP;\n}\n\nstatic int __g450_setclk(struct matrox_fb_info *minfo, unsigned int fout,\n\t\t\t unsigned int pll, unsigned int *mnparray,\n\t\t\t unsigned int *deltaarray)\n{\n\tunsigned int mnpcount;\n\tconst struct matrox_pll_limits* pi;\n\tstruct matrox_pll_cache* ci;\n\n\tswitch (pll) {\n\t\tcase M_PIXEL_PLL_A:\n\t\tcase M_PIXEL_PLL_B:\n\t\tcase M_PIXEL_PLL_C:\n\t\t\t{\n\t\t\t\tu_int8_t tmp, xpwrctrl;\n\t\t\t\tunsigned long flags;\n\t\t\t\t\n\t\t\t\tmatroxfb_DAC_lock_irqsave(flags);\n\n\t\t\t\txpwrctrl = matroxfb_DAC_in(minfo, M1064_XPWRCTRL);\n\t\t\t\tmatroxfb_DAC_out(minfo, M1064_XPWRCTRL, xpwrctrl & ~M1064_XPWRCTRL_PANELPDN);\n\t\t\t\tmga_outb(M_SEQ_INDEX, M_SEQ1);\n\t\t\t\tmga_outb(M_SEQ_DATA, mga_inb(M_SEQ_DATA) | M_SEQ1_SCROFF);\n\t\t\t\ttmp = matroxfb_DAC_in(minfo, M1064_XPIXCLKCTRL);\n\t\t\t\ttmp |= M1064_XPIXCLKCTRL_DIS;\n\t\t\t\tif (!(tmp & M1064_XPIXCLKCTRL_PLL_UP)) {\n\t\t\t\t\ttmp |= M1064_XPIXCLKCTRL_PLL_UP;\n\t\t\t\t}\n\t\t\t\tmatroxfb_DAC_out(minfo, M1064_XPIXCLKCTRL, tmp);\n\t\t\t\t \n\t\t\t\tif (fout >= minfo->max_pixel_clock_panellink)\n\t\t\t\t\ttmp = 0;\n\t\t\t\telse tmp =\n\t\t\t\t\tM1064_XDVICLKCTRL_DVIDATAPATHSEL |\n\t\t\t\t\tM1064_XDVICLKCTRL_C1DVICLKSEL |\n\t\t\t\t\tM1064_XDVICLKCTRL_C1DVICLKEN |\n\t\t\t\t\tM1064_XDVICLKCTRL_DVILOOPCTL |\n\t\t\t\t\tM1064_XDVICLKCTRL_P1LOOPBWDTCTL;\n                                 \n\t\t\t\t \n\t\t\t\tmatroxfb_DAC_out(minfo, M1064_XPWRCTRL,\n\t\t\t\t\t\t xpwrctrl);\n\n\t\t\t\tmatroxfb_DAC_unlock_irqrestore(flags);\n\t\t\t}\n\t\t\t{\n\t\t\t\tu_int8_t misc;\n\t\t\n\t\t\t\tmisc = mga_inb(M_MISC_REG_READ) & ~0x0C;\n\t\t\t\tswitch (pll) {\n\t\t\t\t\tcase M_PIXEL_PLL_A:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase M_PIXEL_PLL_B:\n\t\t\t\t\t\tmisc |=  0x04;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmisc |=  0x0C;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmga_outb(M_MISC_REG, misc);\n\t\t\t}\n\t\t\tpi = &minfo->limits.pixel;\n\t\t\tci = &minfo->cache.pixel;\n\t\t\tbreak;\n\t\tcase M_SYSTEM_PLL:\n\t\t\t{\n\t\t\t\tu_int32_t opt;\n\n\t\t\t\tpci_read_config_dword(minfo->pcidev, PCI_OPTION_REG, &opt);\n\t\t\t\tif (!(opt & 0x20)) {\n\t\t\t\t\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, opt | 0x20);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpi = &minfo->limits.system;\n\t\t\tci = &minfo->cache.system;\n\t\t\tbreak;\n\t\tcase M_VIDEO_PLL:\n\t\t\t{\n\t\t\t\tu_int8_t tmp;\n\t\t\t\tunsigned int mnp;\n\t\t\t\tunsigned long flags;\n\t\t\t\t\n\t\t\t\tmatroxfb_DAC_lock_irqsave(flags);\n\t\t\t\ttmp = matroxfb_DAC_in(minfo, M1064_XPWRCTRL);\n\t\t\t\tif (!(tmp & 2)) {\n\t\t\t\t\tmatroxfb_DAC_out(minfo, M1064_XPWRCTRL, tmp | 2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmnp = matroxfb_DAC_in(minfo, M1064_XPIXPLLCM) << 16;\n\t\t\t\tmnp |= matroxfb_DAC_in(minfo, M1064_XPIXPLLCN) << 8;\n\t\t\t\tmatroxfb_DAC_unlock_irqrestore(flags);\n\t\t\t}\n\t\t\tpi = &minfo->limits.video;\n\t\t\tci = &minfo->cache.video;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tmnpcount = 0;\n\t{\n\t\tunsigned int mnp;\n\t\tunsigned int xvco;\n\n\t\tfor (mnp = g450_firstpll(minfo, pi, &xvco, fout); mnp != NO_MORE_MNP; mnp = g450_nextpll(minfo, pi, &xvco, mnp)) {\n\t\t\tunsigned int idx;\n\t\t\tunsigned int vco;\n\t\t\tunsigned int delta;\n\n\t\t\tvco = g450_mnp2vco(minfo, mnp);\n\t\t\tdelta = pll_freq_delta(fout, g450_vco2f(mnp, vco));\n\t\t\tfor (idx = mnpcount; idx > 0; idx--) {\n\t\t\t\t \n\t\t\t\tif (delta <= deltaarray[idx-1]) {\n\t\t\t\t\t \n\t\t\t\t\tif (delta == deltaarray[idx-1]\n\t\t\t\t\t    && vco != g450_mnp2vco(minfo, mnparray[idx-1])\n\t\t\t\t\t    && vco < (pi->vcomin * 17 / 16)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmnparray[idx] = mnparray[idx-1];\n\t\t\t\t\tdeltaarray[idx] = deltaarray[idx-1];\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmnparray[idx] = mnp;\n\t\t\tdeltaarray[idx] = delta;\n\t\t\tmnpcount++;\n\t\t}\n\t}\n\t \n\tif (!mnpcount) {\n\t\treturn -EBUSY;\n\t}\n\t{\n\t\tunsigned long flags;\n\t\tunsigned int mnp;\n\t\t\n\t\tmatroxfb_DAC_lock_irqsave(flags);\n\t\tmnp = g450_checkcache(minfo, ci, mnparray[0]);\n\t\tif (mnp != NO_MORE_MNP) {\n\t\t\tmatroxfb_g450_setpll_cond(minfo, mnp, pll);\n\t\t} else {\n\t\t\tmnp = g450_findworkingpll(minfo, pll, mnparray, mnpcount);\n\t\t\tg450_addcache(ci, mnparray[0], mnp);\n\t\t}\n\t\tupdatehwstate_clk(&minfo->hw, mnp, pll);\n\t\tmatroxfb_DAC_unlock_irqrestore(flags);\n\t\treturn mnp;\n\t}\n}\n\n \n#define MNP_TABLE_SIZE  64\n\nint matroxfb_g450_setclk(struct matrox_fb_info *minfo, unsigned int fout,\n\t\t\t unsigned int pll)\n{\n\tunsigned int* arr;\n\t\n\tarr = kmalloc(sizeof(*arr) * MNP_TABLE_SIZE * 2, GFP_KERNEL);\n\tif (arr) {\n\t\tint r;\n\n\t\tr = __g450_setclk(minfo, fout, pll, arr, arr + MNP_TABLE_SIZE);\n\t\tkfree(arr);\n\t\treturn r;\n\t}\n\treturn -ENOMEM;\n}\n\nEXPORT_SYMBOL(matroxfb_g450_setclk);\nEXPORT_SYMBOL(g450_mnp2f);\nEXPORT_SYMBOL(matroxfb_g450_setpll_cond);\n\nMODULE_AUTHOR(\"(c) 2001-2002 Petr Vandrovec <vandrove@vc.cvut.cz>\");\nMODULE_DESCRIPTION(\"Matrox G450/G550 PLL driver\");\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}