{
  "module_name": "i2c-matroxfb.c",
  "hash_id": "3afe4eedc03b31d8cb0d92f309e2b38083f9c0a0dc72abc8293d2ea3878910db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/matrox/i2c-matroxfb.c",
  "human_readable_source": "\n \n\n#include \"matroxfb_base.h\"\n#include \"matroxfb_maven.h\"\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/i2c-algo-bit.h>\n\n \n#define MAT_CLK\t\t0x20\n#define MAT_DATA\t0x10\n \n#define DDC1_CLK\t0x08\n#define DDC1_DATA\t0x02\n \n#define DDC1B_CLK\t0x10\n#define DDC1B_DATA\t0x04\n \n#define DDC2_CLK\t0x04\n#define DDC2_DATA\t0x01\n\n \n\nstruct matroxfb_dh_maven_info {\n\tstruct i2c_bit_adapter\tmaven;\n\tstruct i2c_bit_adapter\tddc1;\n\tstruct i2c_bit_adapter\tddc2;\n};\n\nstatic int matroxfb_read_gpio(struct matrox_fb_info* minfo) {\n\tunsigned long flags;\n\tint v;\n\n\tmatroxfb_DAC_lock_irqsave(flags);\n\tv = matroxfb_DAC_in(minfo, DAC_XGENIODATA);\n\tmatroxfb_DAC_unlock_irqrestore(flags);\n\treturn v;\n}\n\nstatic void matroxfb_set_gpio(struct matrox_fb_info* minfo, int mask, int val) {\n\tunsigned long flags;\n\tint v;\n\n\tmatroxfb_DAC_lock_irqsave(flags);\n\tv = (matroxfb_DAC_in(minfo, DAC_XGENIOCTRL) & mask) | val;\n\tmatroxfb_DAC_out(minfo, DAC_XGENIOCTRL, v);\n\t \n\tmatroxfb_DAC_out(minfo, DAC_XGENIODATA, 0x00);\n\tmatroxfb_DAC_unlock_irqrestore(flags);\n}\n\n \nstatic inline void matroxfb_i2c_set(struct matrox_fb_info* minfo, int mask, int state) {\n\tif (state)\n\t\tstate = 0;\n\telse\n\t\tstate = mask;\n\tmatroxfb_set_gpio(minfo, ~mask, state);\n}\n\nstatic void matroxfb_gpio_setsda(void* data, int state) {\n\tstruct i2c_bit_adapter* b = data;\n\tmatroxfb_i2c_set(b->minfo, b->mask.data, state);\n}\n\nstatic void matroxfb_gpio_setscl(void* data, int state) {\n\tstruct i2c_bit_adapter* b = data;\n\tmatroxfb_i2c_set(b->minfo, b->mask.clock, state);\n}\n\nstatic int matroxfb_gpio_getsda(void* data) {\n\tstruct i2c_bit_adapter* b = data;\n\treturn (matroxfb_read_gpio(b->minfo) & b->mask.data) ? 1 : 0;\n}\n\nstatic int matroxfb_gpio_getscl(void* data) {\n\tstruct i2c_bit_adapter* b = data;\n\treturn (matroxfb_read_gpio(b->minfo) & b->mask.clock) ? 1 : 0;\n}\n\nstatic const struct i2c_algo_bit_data matrox_i2c_algo_template =\n{\n\t.setsda\t\t= matroxfb_gpio_setsda,\n\t.setscl\t\t= matroxfb_gpio_setscl,\n\t.getsda\t\t= matroxfb_gpio_getsda,\n\t.getscl\t\t= matroxfb_gpio_getscl,\n\t.udelay\t\t= 10,\n\t.timeout\t= 100,\n};\n\nstatic int i2c_bus_reg(struct i2c_bit_adapter* b, struct matrox_fb_info* minfo, \n\t\tunsigned int data, unsigned int clock, const char *name,\n\t\tint class)\n{\n\tint err;\n\n\tb->minfo = minfo;\n\tb->mask.data = data;\n\tb->mask.clock = clock;\n\tb->adapter.owner = THIS_MODULE;\n\tsnprintf(b->adapter.name, sizeof(b->adapter.name), name,\n\t\tminfo->fbcon.node);\n\ti2c_set_adapdata(&b->adapter, b);\n\tb->adapter.class = class;\n\tb->adapter.algo_data = &b->bac;\n\tb->adapter.dev.parent = &minfo->pcidev->dev;\n\tb->bac = matrox_i2c_algo_template;\n\tb->bac.data = b;\n\terr = i2c_bit_add_bus(&b->adapter);\n\tb->initialized = !err;\n\treturn err;\n}\n\nstatic void i2c_bit_bus_del(struct i2c_bit_adapter* b) {\n\tif (b->initialized) {\n\t\ti2c_del_adapter(&b->adapter);\n\t\tb->initialized = 0;\n\t}\n}\n\nstatic inline void i2c_maven_done(struct matroxfb_dh_maven_info* minfo2) {\n\ti2c_bit_bus_del(&minfo2->maven);\n}\n\nstatic inline void i2c_ddc1_done(struct matroxfb_dh_maven_info* minfo2) {\n\ti2c_bit_bus_del(&minfo2->ddc1);\n}\n\nstatic inline void i2c_ddc2_done(struct matroxfb_dh_maven_info* minfo2) {\n\ti2c_bit_bus_del(&minfo2->ddc2);\n}\n\nstatic void* i2c_matroxfb_probe(struct matrox_fb_info* minfo) {\n\tint err;\n\tunsigned long flags;\n\tstruct matroxfb_dh_maven_info* m2info;\n\n\tm2info = kzalloc(sizeof(*m2info), GFP_KERNEL);\n\tif (!m2info)\n\t\treturn NULL;\n\n\tmatroxfb_DAC_lock_irqsave(flags);\n\tmatroxfb_DAC_out(minfo, DAC_XGENIODATA, 0xFF);\n\tmatroxfb_DAC_out(minfo, DAC_XGENIOCTRL, 0x00);\n\tmatroxfb_DAC_unlock_irqrestore(flags);\n\n\tswitch (minfo->chip) {\n\t\tcase MGA_2064:\n\t\tcase MGA_2164:\n\t\t\terr = i2c_bus_reg(&m2info->ddc1, minfo,\n\t\t\t\t\t  DDC1B_DATA, DDC1B_CLK,\n\t\t\t\t\t  \"DDC:fb%u #0\", I2C_CLASS_DDC);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = i2c_bus_reg(&m2info->ddc1, minfo,\n\t\t\t\t\t  DDC1_DATA, DDC1_CLK,\n\t\t\t\t\t  \"DDC:fb%u #0\", I2C_CLASS_DDC);\n\t\t\tbreak;\n\t}\n\tif (err)\n\t\tgoto fail_ddc1;\n\tif (minfo->devflags.dualhead) {\n\t\terr = i2c_bus_reg(&m2info->ddc2, minfo,\n\t\t\t\t  DDC2_DATA, DDC2_CLK,\n\t\t\t\t  \"DDC:fb%u #1\", I2C_CLASS_DDC);\n\t\tif (err == -ENODEV) {\n\t\t\tprintk(KERN_INFO \"i2c-matroxfb: VGA->TV plug detected, DDC unavailable.\\n\");\n\t\t} else if (err)\n\t\t\tprintk(KERN_INFO \"i2c-matroxfb: Could not register secondary output i2c bus. Continuing anyway.\\n\");\n\t\t \n\t\terr = i2c_bus_reg(&m2info->maven, minfo,\n\t\t\t\t  MAT_DATA, MAT_CLK, \"MAVEN:fb%u\", 0);\n\t\tif (err)\n\t\t\tprintk(KERN_INFO \"i2c-matroxfb: Could not register Maven i2c bus. Continuing anyway.\\n\");\n\t\telse {\n\t\t\tstruct i2c_board_info maven_info = {\n\t\t\t\tI2C_BOARD_INFO(\"maven\", 0x1b),\n\t\t\t};\n\t\t\tunsigned short const addr_list[2] = {\n\t\t\t\t0x1b, I2C_CLIENT_END\n\t\t\t};\n\n\t\t\ti2c_new_scanned_device(&m2info->maven.adapter,\n\t\t\t\t\t       &maven_info, addr_list, NULL);\n\t\t}\n\t}\n\treturn m2info;\nfail_ddc1:;\n\tkfree(m2info);\n\tprintk(KERN_ERR \"i2c-matroxfb: Could not register primary adapter DDC bus.\\n\");\n\treturn NULL;\n}\n\nstatic void i2c_matroxfb_remove(struct matrox_fb_info* minfo, void* data) {\n\tstruct matroxfb_dh_maven_info* m2info = data;\n\n\ti2c_maven_done(m2info);\n\ti2c_ddc2_done(m2info);\n\ti2c_ddc1_done(m2info);\n\tkfree(m2info);\n}\n\nstatic struct matroxfb_driver i2c_matroxfb = {\n\t.node =\t\tLIST_HEAD_INIT(i2c_matroxfb.node),\n\t.name =\t\t\"i2c-matroxfb\",\n\t.probe = \ti2c_matroxfb_probe,\n\t.remove =\ti2c_matroxfb_remove,\n};\n\nstatic int __init i2c_matroxfb_init(void) {\n\tif (matroxfb_register_driver(&i2c_matroxfb)) {\n\t\tprintk(KERN_ERR \"i2c-matroxfb: failed to register driver\\n\");\n\t\treturn -ENXIO;\n\t}\n\treturn 0;\n}\n\nstatic void __exit i2c_matroxfb_exit(void) {\n\tmatroxfb_unregister_driver(&i2c_matroxfb);\n}\n\nMODULE_AUTHOR(\"(c) 1999-2002 Petr Vandrovec <vandrove@vc.cvut.cz>\");\nMODULE_DESCRIPTION(\"Support module providing I2C buses present on Matrox videocards\");\n\nmodule_init(i2c_matroxfb_init);\nmodule_exit(i2c_matroxfb_exit);\n \nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}