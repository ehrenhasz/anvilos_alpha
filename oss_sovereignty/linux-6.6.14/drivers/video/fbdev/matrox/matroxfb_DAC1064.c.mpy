{
  "module_name": "matroxfb_DAC1064.c",
  "hash_id": "4d54afae3c00218490a516cfd987506509d231a76c7820245d820a0e4165514d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/matrox/matroxfb_DAC1064.c",
  "human_readable_source": "\n \n\n\n#include \"matroxfb_DAC1064.h\"\n#include \"matroxfb_misc.h\"\n#include \"matroxfb_accel.h\"\n#include \"g450_pll.h\"\n#include <linux/matroxfb.h>\n\n#ifdef NEED_DAC1064\n#define outDAC1064 matroxfb_DAC_out\n#define inDAC1064 matroxfb_DAC_in\n\n#define DAC1064_OPT_SCLK_PCI\t0x00\n#define DAC1064_OPT_SCLK_PLL\t0x01\n#define DAC1064_OPT_SCLK_EXT\t0x02\n#define DAC1064_OPT_SCLK_MASK\t0x03\n#define DAC1064_OPT_GDIV1\t0x04\t \n#define DAC1064_OPT_GDIV3\t0x00\n#define DAC1064_OPT_MDIV1\t0x08\n#define DAC1064_OPT_MDIV2\t0x00\n#define DAC1064_OPT_RESERVED\t0x10\n\nstatic void DAC1064_calcclock(const struct matrox_fb_info *minfo,\n\t\t\t      unsigned int freq, unsigned int fmax,\n\t\t\t      unsigned int *in, unsigned int *feed,\n\t\t\t      unsigned int *post)\n{\n\tunsigned int fvco;\n\tunsigned int p;\n\n\tDBG(__func__)\n\t\n\t \n\n\tfvco = PLL_calcclock(minfo, freq, fmax, in, feed, &p);\n\t\n\tp = (1 << p) - 1;\n\tif (fvco <= 100000)\n\t\t;\n\telse if (fvco <= 140000)\n\t\tp |= 0x08;\n\telse if (fvco <= 180000)\n\t\tp |= 0x10;\n\telse\n\t\tp |= 0x18;\n\t*post = p;\n}\n\n \nstatic const unsigned char MGA1064_DAC_regs[] = {\n\t\tM1064_XCURADDL, M1064_XCURADDH, M1064_XCURCTRL,\n\t\tM1064_XCURCOL0RED, M1064_XCURCOL0GREEN, M1064_XCURCOL0BLUE,\n\t\tM1064_XCURCOL1RED, M1064_XCURCOL1GREEN, M1064_XCURCOL1BLUE,\n\t\tM1064_XCURCOL2RED, M1064_XCURCOL2GREEN, M1064_XCURCOL2BLUE,\n\t\tDAC1064_XVREFCTRL, M1064_XMULCTRL, M1064_XPIXCLKCTRL, M1064_XGENCTRL,\n\t\tM1064_XMISCCTRL,\n\t\tM1064_XGENIOCTRL, M1064_XGENIODATA, M1064_XZOOMCTRL, M1064_XSENSETEST,\n\t\tM1064_XCRCBITSEL,\n\t\tM1064_XCOLKEYMASKL, M1064_XCOLKEYMASKH, M1064_XCOLKEYL, M1064_XCOLKEYH };\n\nstatic const unsigned char MGA1064_DAC[] = {\n\t\t0x00, 0x00, M1064_XCURCTRL_DIS,\n\t\t0x00, 0x00, 0x00, \t \n\t\t0xFF, 0xFF, 0xFF,\t \n\t\t0xFF, 0x00, 0x00,\t \n\t\t0x00, 0,\n\t\tM1064_XPIXCLKCTRL_PLL_UP | M1064_XPIXCLKCTRL_EN | M1064_XPIXCLKCTRL_SRC_PLL,\n\t\tM1064_XGENCTRL_VS_0 | M1064_XGENCTRL_ALPHA_DIS | M1064_XGENCTRL_BLACK_0IRE | M1064_XGENCTRL_NO_SYNC_ON_GREEN,\n\t\tM1064_XMISCCTRL_DAC_8BIT,\n\t\t0x00, 0x00, M1064_XZOOMCTRL_1, M1064_XSENSETEST_BCOMP | M1064_XSENSETEST_GCOMP | M1064_XSENSETEST_RCOMP | M1064_XSENSETEST_PDOWN,\n\t\t0x00,\n\t\t0x00, 0x00, 0xFF, 0xFF};\n\nstatic void DAC1064_setpclk(struct matrox_fb_info *minfo, unsigned long fout)\n{\n\tunsigned int m, n, p;\n\n\tDBG(__func__)\n\n\tDAC1064_calcclock(minfo, fout, minfo->max_pixel_clock, &m, &n, &p);\n\tminfo->hw.DACclk[0] = m;\n\tminfo->hw.DACclk[1] = n;\n\tminfo->hw.DACclk[2] = p;\n}\n\nstatic void DAC1064_setmclk(struct matrox_fb_info *minfo, int oscinfo,\n\t\t\t    unsigned long fmem)\n{\n\tu_int32_t mx;\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n\tDBG(__func__)\n\n\tif (minfo->devflags.noinit) {\n\t\t \n\t\thw->DACclk[3] = inDAC1064(minfo, DAC1064_XSYSPLLM);\n\t\thw->DACclk[4] = inDAC1064(minfo, DAC1064_XSYSPLLN);\n\t\thw->DACclk[5] = inDAC1064(minfo, DAC1064_XSYSPLLP);\n\t\treturn;\n\t}\n\tmx = hw->MXoptionReg | 0x00000004;\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, mx);\n\tmx &= ~0x000000BB;\n\tif (oscinfo & DAC1064_OPT_GDIV1)\n\t\tmx |= 0x00000008;\n\tif (oscinfo & DAC1064_OPT_MDIV1)\n\t\tmx |= 0x00000010;\n\tif (oscinfo & DAC1064_OPT_RESERVED)\n\t\tmx |= 0x00000080;\n\tif ((oscinfo & DAC1064_OPT_SCLK_MASK) == DAC1064_OPT_SCLK_PLL) {\n\t\t \n\t\tint clk;\n\t\tunsigned int m, n, p;\n\n\t\t \n\t\tmx |= 0x00000020;\n\t\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, mx);\n\t\tmx &= ~0x00000004;\n\t\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, mx);\n\n\t\t \n\t\t \n\t\tDAC1064_calcclock(minfo, fmem, minfo->max_pixel_clock, &m, &n, &p);\n\t\toutDAC1064(minfo, DAC1064_XSYSPLLM, hw->DACclk[3] = m);\n\t\toutDAC1064(minfo, DAC1064_XSYSPLLN, hw->DACclk[4] = n);\n\t\toutDAC1064(minfo, DAC1064_XSYSPLLP, hw->DACclk[5] = p);\n\t\tfor (clk = 65536; clk; --clk) {\n\t\t\tif (inDAC1064(minfo, DAC1064_XSYSPLLSTAT) & 0x40)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!clk)\n\t\t\tprintk(KERN_ERR \"matroxfb: aiee, SYSPLL not locked\\n\");\n\t\t \n\t\tmx |= 0x00000005;\n\t} else {\n\t\t \n\t\tmx |= oscinfo & DAC1064_OPT_SCLK_MASK;\n\t}\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, mx);\n\tmx &= ~0x00000004;\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, mx);\n\thw->MXoptionReg = mx;\n}\n\n#ifdef CONFIG_FB_MATROX_G\nstatic void g450_set_plls(struct matrox_fb_info *minfo)\n{\n\tu_int32_t c2_ctl;\n\tunsigned int pxc;\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\tint pixelmnp;\n\tint videomnp;\n\t\n\tc2_ctl = hw->crtc2.ctl & ~0x4007;\t \n\tc2_ctl |= 0x0001;\t\t\t \n\thw->DACreg[POS1064_XPWRCTRL] &= ~0x02;\t \n\tpixelmnp = minfo->crtc1.mnp;\n\tvideomnp = minfo->crtc2.mnp;\n\tif (videomnp < 0) {\n\t\tc2_ctl &= ~0x0001;\t\t\t \n\t\thw->DACreg[POS1064_XPWRCTRL] &= ~0x10;\t \n\t} else if (minfo->crtc2.pixclock == minfo->features.pll.ref_freq) {\n\t\tc2_ctl |=  0x4002;\t \n\t} else if (videomnp == pixelmnp) {\n\t\tc2_ctl |=  0x0004;\t \n\t} else {\n\t\tif (0 == ((videomnp ^ pixelmnp) & 0xFFFFFF00)) {\n\t\t\t \n\t\t\tpixelmnp += 0x000100;\n\t\t}\n\t\tc2_ctl |=  0x0006;\t \n\t\thw->DACreg[POS1064_XPWRCTRL] |= 0x02;\n\t\t\n\t\toutDAC1064(minfo, M1064_XPWRCTRL, hw->DACreg[POS1064_XPWRCTRL]);\n\t\tmatroxfb_g450_setpll_cond(minfo, videomnp, M_VIDEO_PLL);\n\t}\n\n\thw->DACreg[POS1064_XPIXCLKCTRL] &= ~M1064_XPIXCLKCTRL_PLL_UP;\n\tif (pixelmnp >= 0) {\n\t\thw->DACreg[POS1064_XPIXCLKCTRL] |= M1064_XPIXCLKCTRL_PLL_UP;\n\t\t\n\t\toutDAC1064(minfo, M1064_XPIXCLKCTRL, hw->DACreg[POS1064_XPIXCLKCTRL]);\n\t\tmatroxfb_g450_setpll_cond(minfo, pixelmnp, M_PIXEL_PLL_C);\n\t}\n\tif (c2_ctl != hw->crtc2.ctl) {\n\t\thw->crtc2.ctl = c2_ctl;\n\t\tmga_outl(0x3C10, c2_ctl);\n\t}\n\n\tpxc = minfo->crtc1.pixclock;\n\tif (pxc == 0 || minfo->outputs[2].src == MATROXFB_SRC_CRTC2) {\n\t\tpxc = minfo->crtc2.pixclock;\n\t}\n\tif (minfo->chip == MGA_G550) {\n\t\tif (pxc < 45000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x00;\t \n\t\t} else if (pxc < 55000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x08;\t \n\t\t} else if (pxc < 70000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x10;\t \n\t\t} else if (pxc < 85000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x18;\t \n\t\t} else if (pxc < 100000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x20;\t \n\t\t} else if (pxc < 115000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x28;\t \n\t\t} else if (pxc < 125000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x30;\t \n\t\t} else {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x38;\t \n\t\t}\n\t} else {\n\t\t \n\t\tif (pxc < 45000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x00;\t \n\t\t} else if (pxc < 65000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x08;\t \n\t\t} else if (pxc < 85000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x10;\t \n\t\t} else if (pxc < 105000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x18;\t \n\t\t} else if (pxc < 135000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x20;\t \n\t\t} else if (pxc < 160000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x28;\t \n\t\t} else if (pxc < 175000) {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x30;\t \n\t\t} else {\n\t\t\thw->DACreg[POS1064_XPANMODE] = 0x38;\t \n\t\t}\n\t}\n}\n#endif\n\nvoid DAC1064_global_init(struct matrox_fb_info *minfo)\n{\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n\thw->DACreg[POS1064_XMISCCTRL] &= M1064_XMISCCTRL_DAC_WIDTHMASK;\n\thw->DACreg[POS1064_XMISCCTRL] |= M1064_XMISCCTRL_LUT_EN;\n\thw->DACreg[POS1064_XPIXCLKCTRL] = M1064_XPIXCLKCTRL_PLL_UP | M1064_XPIXCLKCTRL_EN | M1064_XPIXCLKCTRL_SRC_PLL;\n#ifdef CONFIG_FB_MATROX_G\n\tif (minfo->devflags.g450dac) {\n\t\thw->DACreg[POS1064_XPWRCTRL] = 0x1F;\t \n\t\thw->DACreg[POS1064_XOUTPUTCONN] = 0x00;\t \n\t\thw->DACreg[POS1064_XMISCCTRL] |= M1064_XMISCCTRL_DAC_EN;\n\t\tswitch (minfo->outputs[0].src) {\n\t\t\tcase MATROXFB_SRC_CRTC1:\n\t\t\tcase MATROXFB_SRC_CRTC2:\n\t\t\t\thw->DACreg[POS1064_XOUTPUTCONN] |= 0x01;\t \n\t\t\t\tbreak;\n\t\t\tcase MATROXFB_SRC_NONE:\n\t\t\t\thw->DACreg[POS1064_XMISCCTRL] &= ~M1064_XMISCCTRL_DAC_EN;\n\t\t\t\tbreak;\n\t\t}\n\t\tswitch (minfo->outputs[1].src) {\n\t\t\tcase MATROXFB_SRC_CRTC1:\n\t\t\t\thw->DACreg[POS1064_XOUTPUTCONN] |= 0x04;\n\t\t\t\tbreak;\n\t\t\tcase MATROXFB_SRC_CRTC2:\n\t\t\t\tif (minfo->outputs[1].mode == MATROXFB_OUTPUT_MODE_MONITOR) {\n\t\t\t\t\thw->DACreg[POS1064_XOUTPUTCONN] |= 0x08;\n\t\t\t\t} else {\n\t\t\t\t\thw->DACreg[POS1064_XOUTPUTCONN] |= 0x0C;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MATROXFB_SRC_NONE:\n\t\t\t\thw->DACreg[POS1064_XPWRCTRL] &= ~0x01;\t\t \n\t\t\t\tbreak;\n\t\t}\n\t\tswitch (minfo->outputs[2].src) {\n\t\t\tcase MATROXFB_SRC_CRTC1:\n\t\t\t\thw->DACreg[POS1064_XOUTPUTCONN] |= 0x20;\n\t\t\t\tbreak;\n\t\t\tcase MATROXFB_SRC_CRTC2:\n\t\t\t\thw->DACreg[POS1064_XOUTPUTCONN] |= 0x40;\n\t\t\t\tbreak;\n\t\t\tcase MATROXFB_SRC_NONE:\n#if 0\n\t\t\t\t \t\t\t\n\t\t\t\thw->DACreg[POS1064_XPWRCTRL] &= ~0x04;\t\t \n#endif\t\t\t\t\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tg450_set_plls(minfo);\n\t} else\n#endif\n\t{\n\t\tif (minfo->outputs[1].src == MATROXFB_SRC_CRTC1) {\n\t\t\thw->DACreg[POS1064_XPIXCLKCTRL] = M1064_XPIXCLKCTRL_PLL_UP | M1064_XPIXCLKCTRL_EN | M1064_XPIXCLKCTRL_SRC_EXT;\n\t\t\thw->DACreg[POS1064_XMISCCTRL] |= GX00_XMISCCTRL_MFC_MAFC | G400_XMISCCTRL_VDO_MAFC12;\n\t\t} else if (minfo->outputs[1].src == MATROXFB_SRC_CRTC2) {\n\t\t\thw->DACreg[POS1064_XMISCCTRL] |= GX00_XMISCCTRL_MFC_MAFC | G400_XMISCCTRL_VDO_C2_MAFC12;\n\t\t} else if (minfo->outputs[2].src == MATROXFB_SRC_CRTC1)\n\t\t\thw->DACreg[POS1064_XMISCCTRL] |= GX00_XMISCCTRL_MFC_PANELLINK | G400_XMISCCTRL_VDO_MAFC12;\n\t\telse\n\t\t\thw->DACreg[POS1064_XMISCCTRL] |= GX00_XMISCCTRL_MFC_DIS;\n\n\t\tif (minfo->outputs[0].src != MATROXFB_SRC_NONE)\n\t\t\thw->DACreg[POS1064_XMISCCTRL] |= M1064_XMISCCTRL_DAC_EN;\n\t}\n}\n\nvoid DAC1064_global_restore(struct matrox_fb_info *minfo)\n{\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n\toutDAC1064(minfo, M1064_XPIXCLKCTRL, hw->DACreg[POS1064_XPIXCLKCTRL]);\n\toutDAC1064(minfo, M1064_XMISCCTRL, hw->DACreg[POS1064_XMISCCTRL]);\n\tif (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG400) {\n\t\toutDAC1064(minfo, 0x20, 0x04);\n\t\toutDAC1064(minfo, 0x1F, minfo->devflags.dfp_type);\n\t\tif (minfo->devflags.g450dac) {\n\t\t\toutDAC1064(minfo, M1064_XSYNCCTRL, 0xCC);\n\t\t\toutDAC1064(minfo, M1064_XPWRCTRL, hw->DACreg[POS1064_XPWRCTRL]);\n\t\t\toutDAC1064(minfo, M1064_XPANMODE, hw->DACreg[POS1064_XPANMODE]);\n\t\t\toutDAC1064(minfo, M1064_XOUTPUTCONN, hw->DACreg[POS1064_XOUTPUTCONN]);\n\t\t}\n\t}\n}\n\nstatic int DAC1064_init_1(struct matrox_fb_info *minfo, struct my_timming *m)\n{\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n\tDBG(__func__)\n\n\tmemcpy(hw->DACreg, MGA1064_DAC, sizeof(MGA1064_DAC_regs));\n\tswitch (minfo->fbcon.var.bits_per_pixel) {\n\t\t \n\t\tcase 8:\n\t\t\thw->DACreg[POS1064_XMULCTRL] = M1064_XMULCTRL_DEPTH_8BPP | M1064_XMULCTRL_GRAPHICS_PALETIZED;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tif (minfo->fbcon.var.green.length == 5)\n\t\t\t\thw->DACreg[POS1064_XMULCTRL] = M1064_XMULCTRL_DEPTH_15BPP_1BPP | M1064_XMULCTRL_GRAPHICS_PALETIZED;\n\t\t\telse\n\t\t\t\thw->DACreg[POS1064_XMULCTRL] = M1064_XMULCTRL_DEPTH_16BPP | M1064_XMULCTRL_GRAPHICS_PALETIZED;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\thw->DACreg[POS1064_XMULCTRL] = M1064_XMULCTRL_DEPTH_24BPP | M1064_XMULCTRL_GRAPHICS_PALETIZED;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\thw->DACreg[POS1064_XMULCTRL] = M1064_XMULCTRL_DEPTH_32BPP | M1064_XMULCTRL_GRAPHICS_PALETIZED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\t \n\t}\n\thw->DACreg[POS1064_XVREFCTRL] = minfo->features.DAC1064.xvrefctrl;\n\thw->DACreg[POS1064_XGENCTRL] &= ~M1064_XGENCTRL_SYNC_ON_GREEN_MASK;\n\thw->DACreg[POS1064_XGENCTRL] |= (m->sync & FB_SYNC_ON_GREEN)?M1064_XGENCTRL_SYNC_ON_GREEN:M1064_XGENCTRL_NO_SYNC_ON_GREEN;\n\thw->DACreg[POS1064_XCURADDL] = 0;\n\thw->DACreg[POS1064_XCURADDH] = 0;\n\n\tDAC1064_global_init(minfo);\n\treturn 0;\n}\n\nstatic int DAC1064_init_2(struct matrox_fb_info *minfo, struct my_timming *m)\n{\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n\tDBG(__func__)\n\n\tif (minfo->fbcon.var.bits_per_pixel > 16) {\t \n\t\tint i;\n\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\thw->DACpal[i * 3 + 0] = i;\n\t\t\thw->DACpal[i * 3 + 1] = i;\n\t\t\thw->DACpal[i * 3 + 2] = i;\n\t\t}\n\t} else if (minfo->fbcon.var.bits_per_pixel > 8) {\n\t\tif (minfo->fbcon.var.green.length == 5) {\t \n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 32; i++) {\n\t\t\t\t \n\t\t\t\thw->DACpal[i * 3 + 0] = i << 3;\n\t\t\t\thw->DACpal[i * 3 + 1] = i << 3;\n\t\t\t\thw->DACpal[i * 3 + 2] = i << 3;\n\t\t\t\t \n\t\t\t\thw->DACpal[(i + 128) * 3 + 0] = i << 3;\n\t\t\t\thw->DACpal[(i + 128) * 3 + 1] = i << 3;\n\t\t\t\thw->DACpal[(i + 128) * 3 + 2] = i << 3;\n\t\t\t}\n\t\t} else {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 64; i++) {\t\t \n\t\t\t\thw->DACpal[i * 3 + 0] = i << 3;\n\t\t\t\thw->DACpal[i * 3 + 1] = i << 2;\n\t\t\t\thw->DACpal[i * 3 + 2] = i << 3;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmemset(hw->DACpal, 0, 768);\n\t}\n\treturn 0;\n}\n\nstatic void DAC1064_restore_1(struct matrox_fb_info *minfo)\n{\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n\tCRITFLAGS\n\n\tDBG(__func__)\n\n\tCRITBEGIN\n\n\tif ((inDAC1064(minfo, DAC1064_XSYSPLLM) != hw->DACclk[3]) ||\n\t    (inDAC1064(minfo, DAC1064_XSYSPLLN) != hw->DACclk[4]) ||\n\t    (inDAC1064(minfo, DAC1064_XSYSPLLP) != hw->DACclk[5])) {\n\t\toutDAC1064(minfo, DAC1064_XSYSPLLM, hw->DACclk[3]);\n\t\toutDAC1064(minfo, DAC1064_XSYSPLLN, hw->DACclk[4]);\n\t\toutDAC1064(minfo, DAC1064_XSYSPLLP, hw->DACclk[5]);\n\t}\n\t{\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < sizeof(MGA1064_DAC_regs); i++) {\n\t\t\tif ((i != POS1064_XPIXCLKCTRL) && (i != POS1064_XMISCCTRL))\n\t\t\t\toutDAC1064(minfo, MGA1064_DAC_regs[i], hw->DACreg[i]);\n\t\t}\n\t}\n\n\tDAC1064_global_restore(minfo);\n\n\tCRITEND\n};\n\nstatic void DAC1064_restore_2(struct matrox_fb_info *minfo)\n{\n#ifdef DEBUG\n\tunsigned int i;\n#endif\n\n\tDBG(__func__)\n\n#ifdef DEBUG\n\tdprintk(KERN_DEBUG \"DAC1064regs \");\n\tfor (i = 0; i < sizeof(MGA1064_DAC_regs); i++) {\n\t\tdprintk(\"R%02X=%02X \", MGA1064_DAC_regs[i], minfo->hw.DACreg[i]);\n\t\tif ((i & 0x7) == 0x7) dprintk(KERN_DEBUG \"continuing... \");\n\t}\n\tdprintk(KERN_DEBUG \"DAC1064clk \");\n\tfor (i = 0; i < 6; i++)\n\t\tdprintk(\"C%02X=%02X \", i, minfo->hw.DACclk[i]);\n\tdprintk(\"\\n\");\n#endif\n}\n\nstatic int m1064_compute(void* out, struct my_timming* m) {\n#define minfo ((struct matrox_fb_info*)out)\n\t{\n\t\tint i;\n\t\tint tmout;\n\t\tCRITFLAGS\n\n\t\tDAC1064_setpclk(minfo, m->pixclock);\n\n\t\tCRITBEGIN\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\toutDAC1064(minfo, M1064_XPIXPLLCM + i, minfo->hw.DACclk[i]);\n\t\tfor (tmout = 500000; tmout; tmout--) {\n\t\t\tif (inDAC1064(minfo, M1064_XPIXPLLSTAT) & 0x40)\n\t\t\t\tbreak;\n\t\t\tudelay(10);\n\t\t}\n\n\t\tCRITEND\n\n\t\tif (!tmout)\n\t\t\tprintk(KERN_ERR \"matroxfb: Pixel PLL not locked after 5 secs\\n\");\n\t}\n#undef minfo\n\treturn 0;\n}\n\nstatic struct matrox_altout m1064 = {\n\t.name\t = \"Primary output\",\n\t.compute = m1064_compute,\n};\n\n#ifdef CONFIG_FB_MATROX_G\nstatic int g450_compute(void* out, struct my_timming* m) {\n#define minfo ((struct matrox_fb_info*)out)\n\tif (m->mnp < 0) {\n\t\tm->mnp = matroxfb_g450_setclk(minfo, m->pixclock, (m->crtc == MATROXFB_SRC_CRTC1) ? M_PIXEL_PLL_C : M_VIDEO_PLL);\n\t\tif (m->mnp >= 0) {\n\t\t\tm->pixclock = g450_mnp2f(minfo, m->mnp);\n\t\t}\n\t}\n#undef minfo\n\treturn 0;\n}\n\nstatic struct matrox_altout g450out = {\n\t.name\t = \"Primary output\",\n\t.compute = g450_compute,\n};\n#endif\n\n#endif  \n\n#ifdef CONFIG_FB_MATROX_MYSTIQUE\nstatic int MGA1064_init(struct matrox_fb_info *minfo, struct my_timming *m)\n{\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n\tDBG(__func__)\n\n\tif (DAC1064_init_1(minfo, m)) return 1;\n\tif (matroxfb_vgaHWinit(minfo, m)) return 1;\n\n\thw->MiscOutReg = 0xCB;\n\tif (m->sync & FB_SYNC_HOR_HIGH_ACT)\n\t\thw->MiscOutReg &= ~0x40;\n\tif (m->sync & FB_SYNC_VERT_HIGH_ACT)\n\t\thw->MiscOutReg &= ~0x80;\n\tif (m->sync & FB_SYNC_COMP_HIGH_ACT)  \n\t\thw->CRTCEXT[3] |= 0x40;\n\n\tif (DAC1064_init_2(minfo, m)) return 1;\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_FB_MATROX_G\nstatic int MGAG100_init(struct matrox_fb_info *minfo, struct my_timming *m)\n{\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n\tDBG(__func__)\n\n\tif (DAC1064_init_1(minfo, m)) return 1;\n\thw->MXoptionReg &= ~0x2000;\n\tif (matroxfb_vgaHWinit(minfo, m)) return 1;\n\n\thw->MiscOutReg = 0xEF;\n\tif (m->sync & FB_SYNC_HOR_HIGH_ACT)\n\t\thw->MiscOutReg &= ~0x40;\n\tif (m->sync & FB_SYNC_VERT_HIGH_ACT)\n\t\thw->MiscOutReg &= ~0x80;\n\tif (m->sync & FB_SYNC_COMP_HIGH_ACT)  \n\t\thw->CRTCEXT[3] |= 0x40;\n\n\tif (DAC1064_init_2(minfo, m)) return 1;\n\treturn 0;\n}\n#endif\t \n\n#ifdef CONFIG_FB_MATROX_MYSTIQUE\nstatic void MGA1064_ramdac_init(struct matrox_fb_info *minfo)\n{\n\n\tDBG(__func__)\n\n\t \n\tminfo->features.pll.vco_freq_min = 62000;\n\tminfo->features.pll.ref_freq\t = 14318;\n\tminfo->features.pll.feed_div_min = 100;\n\tminfo->features.pll.feed_div_max = 127;\n\tminfo->features.pll.in_div_min\t = 1;\n\tminfo->features.pll.in_div_max\t = 31;\n\tminfo->features.pll.post_shift_max = 3;\n\tminfo->features.DAC1064.xvrefctrl = DAC1064_XVREFCTRL_EXTERNAL;\n\t \n\tDAC1064_setmclk(minfo, DAC1064_OPT_MDIV2 | DAC1064_OPT_GDIV3 | DAC1064_OPT_SCLK_PLL, 133333);\n}\n#endif\n\n#ifdef CONFIG_FB_MATROX_G\n \nstatic int x7AF4 = 0x10;\t \n\t\t\t\t \n#if 0\nstatic int def50 = 0;\t \n#endif\n\nstatic void MGAG100_progPixClock(const struct matrox_fb_info *minfo, int flags,\n\t\t\t\t int m, int n, int p)\n{\n\tint reg;\n\tint selClk;\n\tint clk;\n\n\tDBG(__func__)\n\n\toutDAC1064(minfo, M1064_XPIXCLKCTRL, inDAC1064(minfo, M1064_XPIXCLKCTRL) | M1064_XPIXCLKCTRL_DIS |\n\t\t   M1064_XPIXCLKCTRL_PLL_UP);\n\tswitch (flags & 3) {\n\t\tcase 0:\t\treg = M1064_XPIXPLLAM; break;\n\t\tcase 1:\t\treg = M1064_XPIXPLLBM; break;\n\t\tdefault:\treg = M1064_XPIXPLLCM; break;\n\t}\n\toutDAC1064(minfo, reg++, m);\n\toutDAC1064(minfo, reg++, n);\n\toutDAC1064(minfo, reg, p);\n\tselClk = mga_inb(M_MISC_REG_READ) & ~0xC;\n\t \n\t \n\t \n\tswitch (flags & 0x03) {\n\t\tcase 0x00:\tbreak;\n\t\tcase 0x01:\tselClk |= 4; break;\n\t\tdefault:\tselClk |= 0x0C; break;\n\t}\n\tmga_outb(M_MISC_REG, selClk);\n\tfor (clk = 500000; clk; clk--) {\n\t\tif (inDAC1064(minfo, M1064_XPIXPLLSTAT) & 0x40)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif (!clk)\n\t\tprintk(KERN_ERR \"matroxfb: Pixel PLL%c not locked after usual time\\n\", (reg-M1064_XPIXPLLAM-2)/4 + 'A');\n\tselClk = inDAC1064(minfo, M1064_XPIXCLKCTRL) & ~M1064_XPIXCLKCTRL_SRC_MASK;\n\tswitch (flags & 0x0C) {\n\t\tcase 0x00:\tselClk |= M1064_XPIXCLKCTRL_SRC_PCI; break;\n\t\tcase 0x04:\tselClk |= M1064_XPIXCLKCTRL_SRC_PLL; break;\n\t\tdefault:\tselClk |= M1064_XPIXCLKCTRL_SRC_EXT; break;\n\t}\n\toutDAC1064(minfo, M1064_XPIXCLKCTRL, selClk);\n\toutDAC1064(minfo, M1064_XPIXCLKCTRL, inDAC1064(minfo, M1064_XPIXCLKCTRL) & ~M1064_XPIXCLKCTRL_DIS);\n}\n\nstatic void MGAG100_setPixClock(const struct matrox_fb_info *minfo, int flags,\n\t\t\t\tint freq)\n{\n\tunsigned int m, n, p;\n\n\tDBG(__func__)\n\n\tDAC1064_calcclock(minfo, freq, minfo->max_pixel_clock, &m, &n, &p);\n\tMGAG100_progPixClock(minfo, flags, m, n, p);\n}\n#endif\n\n#ifdef CONFIG_FB_MATROX_MYSTIQUE\nstatic int MGA1064_preinit(struct matrox_fb_info *minfo)\n{\n\tstatic const int vxres_mystique[] = { 512,        640, 768,  800,  832,  960,\n\t\t\t\t\t     1024, 1152, 1280,      1600, 1664, 1920,\n\t\t\t\t\t     2048,    0};\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n\tDBG(__func__)\n\n\t \n\tminfo->capable.text = 1;\n\tminfo->capable.vxres = vxres_mystique;\n\n\tminfo->outputs[0].output = &m1064;\n\tminfo->outputs[0].src = minfo->outputs[0].default_src;\n\tminfo->outputs[0].data = minfo;\n\tminfo->outputs[0].mode = MATROXFB_OUTPUT_MODE_MONITOR;\n\n\tif (minfo->devflags.noinit)\n\t\treturn 0;\t \n\thw->MXoptionReg &= 0xC0000100;\n\thw->MXoptionReg |= 0x00094E20;\n\tif (minfo->devflags.novga)\n\t\thw->MXoptionReg &= ~0x00000100;\n\tif (minfo->devflags.nobios)\n\t\thw->MXoptionReg &= ~0x40000000;\n\tif (minfo->devflags.nopciretry)\n\t\thw->MXoptionReg |=  0x20000000;\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\n\tmga_setr(M_SEQ_INDEX, 0x01, 0x20);\n\tmga_outl(M_CTLWTST, 0x00000000);\n\tudelay(200);\n\tmga_outl(M_MACCESS, 0x00008000);\n\tudelay(100);\n\tmga_outl(M_MACCESS, 0x0000C000);\n\treturn 0;\n}\n\nstatic void MGA1064_reset(struct matrox_fb_info *minfo)\n{\n\n\tDBG(__func__);\n\n\tMGA1064_ramdac_init(minfo);\n}\n#endif\n\n#ifdef CONFIG_FB_MATROX_G\nstatic void g450_mclk_init(struct matrox_fb_info *minfo)\n{\n\t \n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg | 4);\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION3_REG, minfo->values.reg.opt3 & ~0x00300C03);\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\n\n\tif (((minfo->values.reg.opt3 & 0x000003) == 0x000003) ||\n\t    ((minfo->values.reg.opt3 & 0x000C00) == 0x000C00) ||\n\t    ((minfo->values.reg.opt3 & 0x300000) == 0x300000)) {\n\t\tmatroxfb_g450_setclk(minfo, minfo->values.pll.video, M_VIDEO_PLL);\n\t} else {\n\t\tunsigned long flags;\n\t\tunsigned int pwr;\n\t\t\n\t\tmatroxfb_DAC_lock_irqsave(flags);\n\t\tpwr = inDAC1064(minfo, M1064_XPWRCTRL) & ~0x02;\n\t\toutDAC1064(minfo, M1064_XPWRCTRL, pwr);\n\t\tmatroxfb_DAC_unlock_irqrestore(flags);\n\t}\n\tmatroxfb_g450_setclk(minfo, minfo->values.pll.system, M_SYSTEM_PLL);\n\t\n\t \n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg | 4);\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION3_REG, minfo->values.reg.opt3);\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\n\n}\n\nstatic void g450_memory_init(struct matrox_fb_info *minfo)\n{\n\t \n\tminfo->hw.MXoptionReg &= ~0x001F8000;\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\n\t\n\t \n\tminfo->hw.MXoptionReg &= ~0x00207E00;\n\tminfo->hw.MXoptionReg |= 0x00207E00 & minfo->values.reg.opt;\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION2_REG, minfo->values.reg.opt2);\n\t\n\tmga_outl(M_CTLWTST, minfo->values.reg.mctlwtst);\n\t\n\t \n\tpci_write_config_dword(minfo->pcidev, PCI_MEMMISC_REG, minfo->values.reg.memmisc & ~0x80000000U);\n\tmga_outl(M_MEMRDBK, minfo->values.reg.memrdbk);\n\tmga_outl(M_MACCESS, minfo->values.reg.maccess);\n\t \n\tpci_write_config_dword(minfo->pcidev, PCI_MEMMISC_REG, minfo->values.reg.memmisc | 0x80000000U);\n\n\tudelay(200);\n\t\n\tif (minfo->values.memory.ddr && (!minfo->values.memory.emrswen || !minfo->values.memory.dll)) {\n\t\tmga_outl(M_MEMRDBK, minfo->values.reg.memrdbk & ~0x1000);\n\t}\n\tmga_outl(M_MACCESS, minfo->values.reg.maccess | 0x8000);\n\t\n\tudelay(200);\n\t\n\tminfo->hw.MXoptionReg |= 0x001F8000 & minfo->values.reg.opt;\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\n\t\n\t \n\tmga_outl(M_PLNWT, 0);\n\tmga_outl(M_PLNWT, ~0);\n\t\n\tif (minfo->values.reg.mctlwtst != minfo->values.reg.mctlwtst_core) {\n\t\tmga_outl(M_CTLWTST, minfo->values.reg.mctlwtst_core);\n\t}\n\t\n}\n\nstatic void g450_preinit(struct matrox_fb_info *minfo)\n{\n\tu_int32_t c2ctl;\n\tu_int8_t curctl;\n\tu_int8_t c1ctl;\n\t\n\t \n\tminfo->hw.MXoptionReg &= 0xC0000100;\n\tminfo->hw.MXoptionReg |= 0x00000020;\n\tif (minfo->devflags.novga)\n\t\tminfo->hw.MXoptionReg &= ~0x00000100;\n\tif (minfo->devflags.nobios)\n\t\tminfo->hw.MXoptionReg &= ~0x40000000;\n\tif (minfo->devflags.nopciretry)\n\t\tminfo->hw.MXoptionReg |=  0x20000000;\n\tminfo->hw.MXoptionReg |= minfo->values.reg.opt & 0x03400040;\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\n\n\t \n\t\t\n\t \n\tc2ctl = mga_inl(M_C2CTL);\n\tmga_outl(M_C2CTL, c2ctl & ~1);\n\t \n\tcurctl = inDAC1064(minfo, M1064_XCURCTRL);\n\toutDAC1064(minfo, M1064_XCURCTRL, 0);\n\t \n\tc1ctl = mga_readr(M_SEQ_INDEX, 1);\n\tmga_setr(M_SEQ_INDEX, 1, c1ctl | 0x20);\n\n\tg450_mclk_init(minfo);\n\tg450_memory_init(minfo);\n\t\n\t \n\tmatroxfb_g450_setclk(minfo, 25175, M_PIXEL_PLL_A);\n\tmatroxfb_g450_setclk(minfo, 28322, M_PIXEL_PLL_B);\n\n\t \n\tmga_setr(M_SEQ_INDEX, 1, c1ctl);\n\t\n\t \n\toutDAC1064(minfo, M1064_XCURCTRL, curctl);\n\n\t \n\tmga_outl(M_C2CTL, c2ctl);\n\t\n\treturn;\n}\n\nstatic int MGAG100_preinit(struct matrox_fb_info *minfo)\n{\n\tstatic const int vxres_g100[] = {  512,        640, 768,  800,  832,  960,\n                                          1024, 1152, 1280,      1600, 1664, 1920,\n                                          2048, 0};\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n        u_int32_t reg50;\n#if 0\n\tu_int32_t q;\n#endif\n\n\tDBG(__func__)\n\n\t \n\tif (minfo->devflags.g450dac) {\n\t\tminfo->features.pll.vco_freq_min = 130000;\t \n\t} else {\n\t\tminfo->features.pll.vco_freq_min = 62000;\n\t}\n\tif (!minfo->features.pll.ref_freq) {\n\t\tminfo->features.pll.ref_freq\t = 27000;\n\t}\n\tminfo->features.pll.feed_div_min = 7;\n\tminfo->features.pll.feed_div_max = 127;\n\tminfo->features.pll.in_div_min\t = 1;\n\tminfo->features.pll.in_div_max\t = 31;\n\tminfo->features.pll.post_shift_max = 3;\n\tminfo->features.DAC1064.xvrefctrl = DAC1064_XVREFCTRL_G100_DEFAULT;\n\t \n\tminfo->capable.text = 1;\n\tminfo->capable.vxres = vxres_g100;\n\tminfo->capable.plnwt = minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG100\n\t\t\t? minfo->devflags.sgram : 1;\n\n\tif (minfo->devflags.g450dac) {\n\t\tminfo->outputs[0].output = &g450out;\n\t} else {\n\t\tminfo->outputs[0].output = &m1064;\n\t}\n\tminfo->outputs[0].src = minfo->outputs[0].default_src;\n\tminfo->outputs[0].data = minfo;\n\tminfo->outputs[0].mode = MATROXFB_OUTPUT_MODE_MONITOR;\n\n\tif (minfo->devflags.g450dac) {\n\t\t \n\t\tmga_outl(0x1C0C, 0);\n\t}\n\tif (minfo->devflags.noinit)\n\t\treturn 0;\n\tif (minfo->devflags.g450dac) {\n\t\tg450_preinit(minfo);\n\t\treturn 0;\n\t}\n\thw->MXoptionReg &= 0xC0000100;\n\thw->MXoptionReg |= 0x00000020;\n\tif (minfo->devflags.novga)\n\t\thw->MXoptionReg &= ~0x00000100;\n\tif (minfo->devflags.nobios)\n\t\thw->MXoptionReg &= ~0x40000000;\n\tif (minfo->devflags.nopciretry)\n\t\thw->MXoptionReg |=  0x20000000;\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\n\tDAC1064_setmclk(minfo, DAC1064_OPT_MDIV2 | DAC1064_OPT_GDIV3 | DAC1064_OPT_SCLK_PCI, 133333);\n\n\tif (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG100) {\n\t\tpci_read_config_dword(minfo->pcidev, PCI_OPTION2_REG, &reg50);\n\t\treg50 &= ~0x3000;\n\t\tpci_write_config_dword(minfo->pcidev, PCI_OPTION2_REG, reg50);\n\n\t\thw->MXoptionReg |= 0x1080;\n\t\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\n\t\tmga_outl(M_CTLWTST, minfo->values.reg.mctlwtst);\n\t\tudelay(100);\n\t\tmga_outb(0x1C05, 0x00);\n\t\tmga_outb(0x1C05, 0x80);\n\t\tudelay(100);\n\t\tmga_outb(0x1C05, 0x40);\n\t\tmga_outb(0x1C05, 0xC0);\n\t\tudelay(100);\n\t\treg50 &= ~0xFF;\n\t\treg50 |=  0x07;\n\t\tpci_write_config_dword(minfo->pcidev, PCI_OPTION2_REG, reg50);\n\t\t \n\t\tmga_outb(M_GRAPHICS_INDEX, 6);\n\t\tmga_outb(M_GRAPHICS_DATA, (mga_inb(M_GRAPHICS_DATA) & 3) | 4);\n\t\tmga_setr(M_EXTVGA_INDEX, 0x03, 0x81);\n\t\tmga_setr(M_EXTVGA_INDEX, 0x04, 0x00);\n\t\tmga_writeb(minfo->video.vbase, 0x0000, 0xAA);\n\t\tmga_writeb(minfo->video.vbase, 0x0800, 0x55);\n\t\tmga_writeb(minfo->video.vbase, 0x4000, 0x55);\n#if 0\n\t\tif (mga_readb(minfo->video.vbase, 0x0000) != 0xAA) {\n\t\t\thw->MXoptionReg &= ~0x1000;\n\t\t}\n#endif\n\t\thw->MXoptionReg |= 0x00078020;\n\t} else if (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG200) {\n\t\tpci_read_config_dword(minfo->pcidev, PCI_OPTION2_REG, &reg50);\n\t\treg50 &= ~0x3000;\n\t\tpci_write_config_dword(minfo->pcidev, PCI_OPTION2_REG, reg50);\n\n\t\tif (minfo->devflags.memtype == -1)\n\t\t\thw->MXoptionReg |= minfo->values.reg.opt & 0x1C00;\n\t\telse\n\t\t\thw->MXoptionReg |= (minfo->devflags.memtype & 7) << 10;\n\t\tif (minfo->devflags.sgram)\n\t\t\thw->MXoptionReg |= 0x4000;\n\t\tmga_outl(M_CTLWTST, minfo->values.reg.mctlwtst);\n\t\tmga_outl(M_MEMRDBK, minfo->values.reg.memrdbk);\n\t\tudelay(200);\n\t\tmga_outl(M_MACCESS, 0x00000000);\n\t\tmga_outl(M_MACCESS, 0x00008000);\n\t\tudelay(100);\n\t\tmga_outw(M_MEMRDBK, minfo->values.reg.memrdbk);\n\t\thw->MXoptionReg |= 0x00078020;\n\t} else {\n\t\tpci_read_config_dword(minfo->pcidev, PCI_OPTION2_REG, &reg50);\n\t\treg50 &= ~0x00000100;\n\t\treg50 |=  0x00000000;\n\t\tpci_write_config_dword(minfo->pcidev, PCI_OPTION2_REG, reg50);\n\n\t\tif (minfo->devflags.memtype == -1)\n\t\t\thw->MXoptionReg |= minfo->values.reg.opt & 0x1C00;\n\t\telse\n\t\t\thw->MXoptionReg |= (minfo->devflags.memtype & 7) << 10;\n\t\tif (minfo->devflags.sgram)\n\t\t\thw->MXoptionReg |= 0x4000;\n\t\tmga_outl(M_CTLWTST, minfo->values.reg.mctlwtst);\n\t\tmga_outl(M_MEMRDBK, minfo->values.reg.memrdbk);\n\t\tudelay(200);\n\t\tmga_outl(M_MACCESS, 0x00000000);\n\t\tmga_outl(M_MACCESS, 0x00008000);\n\t\tudelay(100);\n\t\tmga_outl(M_MEMRDBK, minfo->values.reg.memrdbk);\n\t\thw->MXoptionReg |= 0x00040020;\n\t}\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\n\treturn 0;\n}\n\nstatic void MGAG100_reset(struct matrox_fb_info *minfo)\n{\n\tu_int8_t b;\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n\tDBG(__func__)\n\n\t{\n#ifdef G100_BROKEN_IBM_82351\n\t\tu_int32_t d;\n\n\t\tfind 1014/22 (IBM/82351);  \n\t\tpci_read_config_byte(ibm, PCI_SECONDARY_BUS, &b);\n\t\tif (b == minfo->pcidev->bus->number) {\n\t\t\tpci_write_config_byte(ibm, PCI_COMMAND+1, 0);\t \n\t\t\tpci_write_config_byte(ibm, 0x41, 0xF4);\t\t \n\t\t\tpci_write_config_byte(ibm, PCI_IO_BASE, 0xF0);\t \n\t\t\tpci_write_config_byte(ibm, PCI_IO_LIMIT, 0x00);\t \n\t\t}\n#endif\n\t\tif (!minfo->devflags.noinit) {\n\t\t\tif (x7AF4 & 8) {\n\t\t\t\thw->MXoptionReg |= 0x40;\t \n\t\t\t\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\n\t\t\t}\n\t\t\tmga_setr(M_EXTVGA_INDEX, 0x06, 0x00);\n\t\t}\n\t}\n\tif (minfo->devflags.g450dac) {\n\t\t \n\t\thw->DACclk[3] = inDAC1064(minfo, DAC1064_XSYSPLLM);\n\t\thw->DACclk[4] = inDAC1064(minfo, DAC1064_XSYSPLLN);\n\t\thw->DACclk[5] = inDAC1064(minfo, DAC1064_XSYSPLLP);\n\t} else {\n\t\tDAC1064_setmclk(minfo, DAC1064_OPT_RESERVED | DAC1064_OPT_MDIV2 | DAC1064_OPT_GDIV1 | DAC1064_OPT_SCLK_PLL, 133333);\n\t}\n\tif (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG400) {\n\t\tif (minfo->devflags.dfp_type == -1) {\n\t\t\tminfo->devflags.dfp_type = inDAC1064(minfo, 0x1F);\n\t\t}\n\t}\n\tif (minfo->devflags.noinit)\n\t\treturn;\n\tif (minfo->devflags.g450dac) {\n\t} else {\n\t\tMGAG100_setPixClock(minfo, 4, 25175);\n\t\tMGAG100_setPixClock(minfo, 5, 28322);\n\t\tif (x7AF4 & 0x10) {\n\t\t\tb = inDAC1064(minfo, M1064_XGENIODATA) & ~1;\n\t\t\toutDAC1064(minfo, M1064_XGENIODATA, b);\n\t\t\tb = inDAC1064(minfo, M1064_XGENIOCTRL) | 1;\n\t\t\toutDAC1064(minfo, M1064_XGENIOCTRL, b);\n\t\t}\n\t}\n}\n#endif\n\n#ifdef CONFIG_FB_MATROX_MYSTIQUE\nstatic void MGA1064_restore(struct matrox_fb_info *minfo)\n{\n\tint i;\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n\tCRITFLAGS\n\n\tDBG(__func__)\n\n\tCRITBEGIN\n\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\n\tmga_outb(M_IEN, 0x00);\n\tmga_outb(M_CACHEFLUSH, 0x00);\n\n\tCRITEND\n\n\tDAC1064_restore_1(minfo);\n\tmatroxfb_vgaHWrestore(minfo);\n\tminfo->crtc1.panpos = -1;\n\tfor (i = 0; i < 6; i++)\n\t\tmga_setr(M_EXTVGA_INDEX, i, hw->CRTCEXT[i]);\n\tDAC1064_restore_2(minfo);\n}\n#endif\n\n#ifdef CONFIG_FB_MATROX_G\nstatic void MGAG100_restore(struct matrox_fb_info *minfo)\n{\n\tint i;\n\tstruct matrox_hw_state *hw = &minfo->hw;\n\n\tCRITFLAGS\n\n\tDBG(__func__)\n\n\tCRITBEGIN\n\n\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\n\tCRITEND\n\n\tDAC1064_restore_1(minfo);\n\tmatroxfb_vgaHWrestore(minfo);\n\tif (minfo->devflags.support32MB)\n\t\tmga_setr(M_EXTVGA_INDEX, 8, hw->CRTCEXT[8]);\n\tminfo->crtc1.panpos = -1;\n\tfor (i = 0; i < 6; i++)\n\t\tmga_setr(M_EXTVGA_INDEX, i, hw->CRTCEXT[i]);\n\tDAC1064_restore_2(minfo);\n}\n#endif\n\n#ifdef CONFIG_FB_MATROX_MYSTIQUE\nstruct matrox_switch matrox_mystique = {\n\t.preinit\t= MGA1064_preinit,\n\t.reset\t\t= MGA1064_reset,\n\t.init\t\t= MGA1064_init,\n\t.restore\t= MGA1064_restore,\n};\nEXPORT_SYMBOL(matrox_mystique);\n#endif\n\n#ifdef CONFIG_FB_MATROX_G\nstruct matrox_switch matrox_G100 = {\n\t.preinit\t= MGAG100_preinit,\n\t.reset\t\t= MGAG100_reset,\n\t.init\t\t= MGAG100_init,\n\t.restore\t= MGAG100_restore,\n};\nEXPORT_SYMBOL(matrox_G100);\n#endif\n\n#ifdef NEED_DAC1064\nEXPORT_SYMBOL(DAC1064_global_init);\nEXPORT_SYMBOL(DAC1064_global_restore);\n#endif\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}