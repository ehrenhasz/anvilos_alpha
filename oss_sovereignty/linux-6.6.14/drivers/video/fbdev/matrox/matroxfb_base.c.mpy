{
  "module_name": "matroxfb_base.c",
  "hash_id": "61a312ac78e9395f44adaa670b017a45f5b0e634cde82fea4f0a09c3944dcffe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/matrox/matroxfb_base.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/version.h>\n\n#include \"matroxfb_base.h\"\n#include \"matroxfb_misc.h\"\n#include \"matroxfb_accel.h\"\n#include \"matroxfb_DAC1064.h\"\n#include \"matroxfb_Ti3026.h\"\n#include \"matroxfb_maven.h\"\n#include \"matroxfb_crtc2.h\"\n#include \"matroxfb_g450.h\"\n#include <linux/matroxfb.h>\n#include <linux/interrupt.h>\n#include <linux/nvram.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#ifdef CONFIG_PPC_PMAC\n#include <asm/machdep.h>\nstatic int default_vmode = VMODE_NVRAM;\nstatic int default_cmode = CMODE_NVRAM;\n#endif\n\nstatic void matroxfb_unregister_device(struct matrox_fb_info* minfo);\n\n \n\n \n\n \n\nstatic struct fb_var_screeninfo vesafb_defined = {\n\t640,480,640,480, \n\t0,0,\t\t \n\t8,\t\t \n\t0,\t\t \n\t{0,0,0},\t \n\t{0,0,0},\t \n\t{0,0,0},\t \n\t{0,0,0},\t \n\t0,\t\t \n\tFB_ACTIVATE_NOW,\n\t-1,-1,\n\tFB_ACCELF_TEXT,\t \n\t39721L,48L,16L,33L,10L,\n\t96L,2L,~0,\t \n\tFB_VMODE_NONINTERLACED,\n};\n\n\n\n \nstatic void update_crtc2(struct matrox_fb_info *minfo, unsigned int pos)\n{\n\tstruct matroxfb_dh_fb_info *info = minfo->crtc2.info;\n\n\t \n\tif (info && (info->fbcon.var.bits_per_pixel == minfo->fbcon.var.bits_per_pixel)\n\t\t && (info->fbcon.var.xres_virtual == minfo->fbcon.var.xres_virtual)\n\t\t && (info->fbcon.var.green.length == minfo->fbcon.var.green.length)\n\t\t ) {\n\t\tswitch (minfo->fbcon.var.bits_per_pixel) {\n\t\t\tcase 16:\n\t\t\tcase 32:\n\t\t\t\tpos = pos * 8;\n\t\t\t\tif (info->interlaced) {\n\t\t\t\t\tmga_outl(0x3C2C, pos);\n\t\t\t\t\tmga_outl(0x3C28, pos + minfo->fbcon.var.xres_virtual * minfo->fbcon.var.bits_per_pixel / 8);\n\t\t\t\t} else {\n\t\t\t\t\tmga_outl(0x3C28, pos);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void matroxfb_crtc1_panpos(struct matrox_fb_info *minfo)\n{\n\tif (minfo->crtc1.panpos >= 0) {\n\t\tunsigned long flags;\n\t\tint panpos;\n\n\t\tmatroxfb_DAC_lock_irqsave(flags);\n\t\tpanpos = minfo->crtc1.panpos;\n\t\tif (panpos >= 0) {\n\t\t\tunsigned int extvga_reg;\n\n\t\t\tminfo->crtc1.panpos = -1;  \n\t\t\textvga_reg = mga_inb(M_EXTVGA_INDEX);\n\t\t\tmga_setr(M_EXTVGA_INDEX, 0x00, panpos);\n\t\t\tif (extvga_reg != 0x00) {\n\t\t\t\tmga_outb(M_EXTVGA_INDEX, extvga_reg);\n\t\t\t}\n\t\t}\n\t\tmatroxfb_DAC_unlock_irqrestore(flags);\n\t}\n}\n\nstatic irqreturn_t matrox_irq(int irq, void *dev_id)\n{\n\tu_int32_t status;\n\tint handled = 0;\n\tstruct matrox_fb_info *minfo = dev_id;\n\n\tstatus = mga_inl(M_STATUS);\n\n\tif (status & 0x20) {\n\t\tmga_outl(M_ICLEAR, 0x20);\n\t\tminfo->crtc1.vsync.cnt++;\n\t\tmatroxfb_crtc1_panpos(minfo);\n\t\twake_up_interruptible(&minfo->crtc1.vsync.wait);\n\t\thandled = 1;\n\t}\n\tif (status & 0x200) {\n\t\tmga_outl(M_ICLEAR, 0x200);\n\t\tminfo->crtc2.vsync.cnt++;\n\t\twake_up_interruptible(&minfo->crtc2.vsync.wait);\n\t\thandled = 1;\n\t}\n\treturn IRQ_RETVAL(handled);\n}\n\nint matroxfb_enable_irq(struct matrox_fb_info *minfo, int reenable)\n{\n\tu_int32_t bm;\n\n\tif (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG400)\n\t\tbm = 0x220;\n\telse\n\t\tbm = 0x020;\n\n\tif (!test_and_set_bit(0, &minfo->irq_flags)) {\n\t\tif (request_irq(minfo->pcidev->irq, matrox_irq,\n\t\t\t\tIRQF_SHARED, \"matroxfb\", minfo)) {\n\t\t\tclear_bit(0, &minfo->irq_flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tmga_outl(M_ICLEAR, bm);\n\t\tmga_outl(M_IEN, mga_inl(M_IEN) | bm);\n\t} else if (reenable) {\n\t\tu_int32_t ien;\n\n\t\tien = mga_inl(M_IEN);\n\t\tif ((ien & bm) != bm) {\n\t\t\tprintk(KERN_DEBUG \"matroxfb: someone disabled IRQ [%08X]\\n\", ien);\n\t\t\tmga_outl(M_IEN, ien | bm);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void matroxfb_disable_irq(struct matrox_fb_info *minfo)\n{\n\tif (test_and_clear_bit(0, &minfo->irq_flags)) {\n\t\t \n\t\tmatroxfb_crtc1_panpos(minfo);\n\t\tif (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG400)\n\t\t\tmga_outl(M_IEN, mga_inl(M_IEN) & ~0x220);\n\t\telse\n\t\t\tmga_outl(M_IEN, mga_inl(M_IEN) & ~0x20);\n\t\tfree_irq(minfo->pcidev->irq, minfo);\n\t}\n}\n\nint matroxfb_wait_for_sync(struct matrox_fb_info *minfo, u_int32_t crtc)\n{\n\tstruct matrox_vsync *vs;\n\tunsigned int cnt;\n\tint ret;\n\n\tswitch (crtc) {\n\t\tcase 0:\n\t\t\tvs = &minfo->crtc1.vsync;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (minfo->devflags.accelerator != FB_ACCEL_MATROX_MGAG400) {\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tvs = &minfo->crtc2.vsync;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t}\n\tret = matroxfb_enable_irq(minfo, 0);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tcnt = vs->cnt;\n\tret = wait_event_interruptible_timeout(vs->wait, cnt != vs->cnt, HZ/10);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\tif (ret == 0) {\n\t\tmatroxfb_enable_irq(minfo, 1);\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\n \n\nstatic void matrox_pan_var(struct matrox_fb_info *minfo,\n\t\t\t   struct fb_var_screeninfo *var)\n{\n\tunsigned int pos;\n\tunsigned short p0, p1, p2;\n\tunsigned int p3;\n\tint vbl;\n\tunsigned long flags;\n\n\tCRITFLAGS\n\n\tDBG(__func__)\n\n\tif (minfo->dead)\n\t\treturn;\n\n\tminfo->fbcon.var.xoffset = var->xoffset;\n\tminfo->fbcon.var.yoffset = var->yoffset;\n\tpos = (minfo->fbcon.var.yoffset * minfo->fbcon.var.xres_virtual + minfo->fbcon.var.xoffset) * minfo->curr.final_bppShift / 32;\n\tpos += minfo->curr.ydstorg.chunks;\n\tp0 = minfo->hw.CRTC[0x0D] = pos & 0xFF;\n\tp1 = minfo->hw.CRTC[0x0C] = (pos & 0xFF00) >> 8;\n\tp2 = minfo->hw.CRTCEXT[0] = (minfo->hw.CRTCEXT[0] & 0xB0) | ((pos >> 16) & 0x0F) | ((pos >> 14) & 0x40);\n\tp3 = minfo->hw.CRTCEXT[8] = pos >> 21;\n\n\t \n\tvbl = (var->activate & FB_ACTIVATE_VBL) && (matroxfb_enable_irq(minfo, 0) == 0);\n\n\tCRITBEGIN\n\n\tmatroxfb_DAC_lock_irqsave(flags);\n\tmga_setr(M_CRTC_INDEX, 0x0D, p0);\n\tmga_setr(M_CRTC_INDEX, 0x0C, p1);\n\tif (minfo->devflags.support32MB)\n\t\tmga_setr(M_EXTVGA_INDEX, 0x08, p3);\n\tif (vbl) {\n\t\tminfo->crtc1.panpos = p2;\n\t} else {\n\t\t \n\t\tminfo->crtc1.panpos = -1;\n\t\tmga_setr(M_EXTVGA_INDEX, 0x00, p2);\n\t}\n\tmatroxfb_DAC_unlock_irqrestore(flags);\n\n\tupdate_crtc2(minfo, pos);\n\n\tCRITEND\n}\n\nstatic void matroxfb_remove(struct matrox_fb_info *minfo, int dummy)\n{\n\t \n\n\tminfo->dead = 1;\n\tif (minfo->usecount) {\n\t\t \n\t\treturn;\n\t}\n\tmatroxfb_unregister_device(minfo);\n\tunregister_framebuffer(&minfo->fbcon);\n\tmatroxfb_g450_shutdown(minfo);\n\tarch_phys_wc_del(minfo->wc_cookie);\n\tiounmap(minfo->mmio.vbase.vaddr);\n\tiounmap(minfo->video.vbase.vaddr);\n\trelease_mem_region(minfo->video.base, minfo->video.len_maximum);\n\trelease_mem_region(minfo->mmio.base, 16384);\n\tkfree(minfo);\n}\n\n\t \n\nstatic int matroxfb_open(struct fb_info *info, int user)\n{\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tDBG_LOOP(__func__)\n\n\tif (minfo->dead) {\n\t\treturn -ENXIO;\n\t}\n\tminfo->usecount++;\n\tif (user) {\n\t\tminfo->userusecount++;\n\t}\n\treturn(0);\n}\n\nstatic int matroxfb_release(struct fb_info *info, int user)\n{\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tDBG_LOOP(__func__)\n\n\tif (user) {\n\t\tif (0 == --minfo->userusecount) {\n\t\t\tmatroxfb_disable_irq(minfo);\n\t\t}\n\t}\n\tif (!(--minfo->usecount) && minfo->dead) {\n\t\tmatroxfb_remove(minfo, 0);\n\t}\n\treturn(0);\n}\n\nstatic int matroxfb_pan_display(struct fb_var_screeninfo *var,\n\t\tstruct fb_info* info) {\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tDBG(__func__)\n\n\tmatrox_pan_var(minfo, var);\n\treturn 0;\n}\n\nstatic int matroxfb_get_final_bppShift(const struct matrox_fb_info *minfo,\n\t\t\t\t       int bpp)\n{\n\tint bppshft2;\n\n\tDBG(__func__)\n\n\tbppshft2 = bpp;\n\tif (!bppshft2) {\n\t\treturn 8;\n\t}\n\tif (isInterleave(minfo))\n\t\tbppshft2 >>= 1;\n\tif (minfo->devflags.video64bits)\n\t\tbppshft2 >>= 1;\n\treturn bppshft2;\n}\n\nstatic int matroxfb_test_and_set_rounding(const struct matrox_fb_info *minfo,\n\t\t\t\t\t  int xres, int bpp)\n{\n\tint over;\n\tint rounding;\n\n\tDBG(__func__)\n\n\tswitch (bpp) {\n\t\tcase 0:\t\treturn xres;\n\t\tcase 4:\t\trounding = 128;\n\t\t\t\tbreak;\n\t\tcase 8:\t\trounding = 64;\t \n\t\t\t\tbreak;\n\t\tcase 16:\trounding = 32;\n\t\t\t\tbreak;\n\t\tcase 24:\trounding = 64;\t \n\t\t\t\tbreak;\n\t\tdefault:\trounding = 16;\n\t\t\t\t \n\t\t\t\tif (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG400)\n\t\t\t\t\trounding = 32;\n\t\t\t\tbreak;\n\t}\n\tif (isInterleave(minfo)) {\n\t\trounding *= 2;\n\t}\n\tover = xres % rounding;\n\tif (over)\n\t\txres += rounding-over;\n\treturn xres;\n}\n\nstatic int matroxfb_pitch_adjust(const struct matrox_fb_info *minfo, int xres,\n\t\t\t\t int bpp)\n{\n\tconst int* width;\n\tint xres_new;\n\n\tDBG(__func__)\n\n\tif (!bpp) return xres;\n\n\twidth = minfo->capable.vxres;\n\n\tif (minfo->devflags.precise_width) {\n\t\twhile (*width) {\n\t\t\tif ((*width >= xres) && (matroxfb_test_and_set_rounding(minfo, *width, bpp) == *width)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twidth++;\n\t\t}\n\t\txres_new = *width;\n\t} else {\n\t\txres_new = matroxfb_test_and_set_rounding(minfo, xres, bpp);\n\t}\n\treturn xres_new;\n}\n\nstatic int matroxfb_get_cmap_len(struct fb_var_screeninfo *var) {\n\n\tDBG(__func__)\n\n\tswitch (var->bits_per_pixel) {\n\t\tcase 4:\n\t\t\treturn 16;\t \n\t\tcase 8:\n\t\t\treturn 256;\t \n\t\tcase 16:\n\t\t\treturn 16;\t \n\t\t\t\t\t \n\t\tcase 24:\n\t\t\treturn 16;\t \n\t\t\t\t\t \n\t\tcase 32:\n\t\t\treturn 16;\t \n\t\t\t\t\t \n\t}\n\treturn 16;\t \n}\n\nstatic int matroxfb_decode_var(const struct matrox_fb_info *minfo,\n\t\t\t       struct fb_var_screeninfo *var, int *visual,\n\t\t\t       int *video_cmap_len, unsigned int* ydstorg)\n{\n\tstruct RGBT {\n\t\tunsigned char bpp;\n\t\tstruct {\n\t\t\tunsigned char offset,\n\t\t\t\t      length;\n\t\t} red,\n\t\t  green,\n\t\t  blue,\n\t\t  transp;\n\t\tsigned char visual;\n\t};\n\tstatic const struct RGBT table[]= {\n\t\t{ 8,{ 0,8},{0,8},{0,8},{ 0,0},MX_VISUAL_PSEUDOCOLOR},\n\t\t{15,{10,5},{5,5},{0,5},{15,1},MX_VISUAL_DIRECTCOLOR},\n\t\t{16,{11,5},{5,6},{0,5},{ 0,0},MX_VISUAL_DIRECTCOLOR},\n\t\t{24,{16,8},{8,8},{0,8},{ 0,0},MX_VISUAL_DIRECTCOLOR},\n\t\t{32,{16,8},{8,8},{0,8},{24,8},MX_VISUAL_DIRECTCOLOR}\n\t};\n\tstruct RGBT const *rgbt;\n\tunsigned int bpp = var->bits_per_pixel;\n\tunsigned int vramlen;\n\tunsigned int memlen;\n\n\tDBG(__func__)\n\n\tswitch (bpp) {\n\t\tcase 4:\t if (!minfo->capable.cfb4) return -EINVAL;\n\t\t\t break;\n\t\tcase 8:\t break;\n\t\tcase 16: break;\n\t\tcase 24: break;\n\t\tcase 32: break;\n\t\tdefault: return -EINVAL;\n\t}\n\t*ydstorg = 0;\n\tvramlen = minfo->video.len_usable;\n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres_virtual = var->yres;\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres_virtual = var->xres;\n\n\tvar->xres_virtual = matroxfb_pitch_adjust(minfo, var->xres_virtual, bpp);\n\tmemlen = var->xres_virtual * bpp * var->yres_virtual / 8;\n\tif (memlen > vramlen) {\n\t\tvar->yres_virtual = vramlen * 8 / (var->xres_virtual * bpp);\n\t\tmemlen = var->xres_virtual * bpp * var->yres_virtual / 8;\n\t}\n\t \n\t \n\t \n\tif (!minfo->capable.cross4MB && (memlen > 0x400000)) {\n\t\tif (bpp == 24) {\n\t\t\t \n\t\t} else {\n\t\t\tunsigned int linelen;\n\t\t\tunsigned int m1 = linelen = var->xres_virtual * bpp / 8;\n\t\t\tunsigned int m2 = PAGE_SIZE;\t \n\t\t\tunsigned int max_yres;\n\n\t\t\twhile (m1) {\n\t\t\t\twhile (m2 >= m1) m2 -= m1;\n\t\t\t\tswap(m1, m2);\n\t\t\t}\n\t\t\tm2 = linelen * PAGE_SIZE / m2;\n\t\t\t*ydstorg = m2 = 0x400000 % m2;\n\t\t\tmax_yres = (vramlen - m2) / linelen;\n\t\t\tif (var->yres_virtual > max_yres)\n\t\t\t\tvar->yres_virtual = max_yres;\n\t\t}\n\t}\n\t \n\tif (var->yres_virtual > 32767)\n\t\tvar->yres_virtual = 32767;\n\t \n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres = var->yres_virtual;\n\tif (var->xres_virtual < var->xres)\n\t\tvar->xres = var->xres_virtual;\n\tif (var->xoffset + var->xres > var->xres_virtual)\n\t\tvar->xoffset = var->xres_virtual - var->xres;\n\tif (var->yoffset + var->yres > var->yres_virtual)\n\t\tvar->yoffset = var->yres_virtual - var->yres;\n\n\tif (bpp == 16 && var->green.length == 5) {\n\t\tbpp--;  \n\t}\n\n\tfor (rgbt = table; rgbt->bpp < bpp; rgbt++);\n#define\tSETCLR(clr)\\\n\tvar->clr.offset = rgbt->clr.offset;\\\n\tvar->clr.length = rgbt->clr.length\n\tSETCLR(red);\n\tSETCLR(green);\n\tSETCLR(blue);\n\tSETCLR(transp);\n#undef\tSETCLR\n\t*visual = rgbt->visual;\n\n\tif (bpp > 8)\n\t\tdprintk(\"matroxfb: truecolor: \"\n\t\t\t\"size=%d:%d:%d:%d, shift=%d:%d:%d:%d\\n\",\n\t\t\tvar->transp.length, var->red.length, var->green.length, var->blue.length,\n\t\t\tvar->transp.offset, var->red.offset, var->green.offset, var->blue.offset);\n\n\t*video_cmap_len = matroxfb_get_cmap_len(var);\n\tdprintk(KERN_INFO \"requested %d*%d/%dbpp (%d*%d)\\n\", var->xres, var->yres, var->bits_per_pixel,\n\t\t\t\tvar->xres_virtual, var->yres_virtual);\n\treturn 0;\n}\n\nstatic int matroxfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t      unsigned blue, unsigned transp,\n\t\t\t      struct fb_info *fb_info)\n{\n\tstruct matrox_fb_info* minfo = container_of(fb_info, struct matrox_fb_info, fbcon);\n\n\tDBG(__func__)\n\n\t \n\n\tif (regno >= minfo->curr.cmap_len)\n\t\treturn 1;\n\n\tif (minfo->fbcon.var.grayscale) {\n\t\t \n\t\tred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n\t}\n\n\tred = CNVT_TOHW(red, minfo->fbcon.var.red.length);\n\tgreen = CNVT_TOHW(green, minfo->fbcon.var.green.length);\n\tblue = CNVT_TOHW(blue, minfo->fbcon.var.blue.length);\n\ttransp = CNVT_TOHW(transp, minfo->fbcon.var.transp.length);\n\n\tswitch (minfo->fbcon.var.bits_per_pixel) {\n\tcase 4:\n\tcase 8:\n\t\tmga_outb(M_DAC_REG, regno);\n\t\tmga_outb(M_DAC_VAL, red);\n\t\tmga_outb(M_DAC_VAL, green);\n\t\tmga_outb(M_DAC_VAL, blue);\n\t\tbreak;\n\tcase 16:\n\t\tif (regno >= 16)\n\t\t\tbreak;\n\t\t{\n\t\t\tu_int16_t col =\n\t\t\t\t(red << minfo->fbcon.var.red.offset)     |\n\t\t\t\t(green << minfo->fbcon.var.green.offset) |\n\t\t\t\t(blue << minfo->fbcon.var.blue.offset)   |\n\t\t\t\t(transp << minfo->fbcon.var.transp.offset);  \n\t\t\tminfo->cmap[regno] = col | (col << 16);\n\t\t}\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tif (regno >= 16)\n\t\t\tbreak;\n\t\tminfo->cmap[regno] =\n\t\t\t(red   << minfo->fbcon.var.red.offset)   |\n\t\t\t(green << minfo->fbcon.var.green.offset) |\n\t\t\t(blue  << minfo->fbcon.var.blue.offset)  |\n\t\t\t(transp << minfo->fbcon.var.transp.offset);\t \n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void matroxfb_init_fix(struct matrox_fb_info *minfo)\n{\n\tstruct fb_fix_screeninfo *fix = &minfo->fbcon.fix;\n\tDBG(__func__)\n\n\tstrcpy(fix->id,\"MATROX\");\n\n\tfix->xpanstep = 8;\t \n\tfix->ypanstep = 1;\n\tfix->ywrapstep = 0;\n\tfix->mmio_start = minfo->mmio.base;\n\tfix->mmio_len = minfo->mmio.len;\n\tfix->accel = minfo->devflags.accelerator;\n}\n\nstatic void matroxfb_update_fix(struct matrox_fb_info *minfo)\n{\n\tstruct fb_fix_screeninfo *fix = &minfo->fbcon.fix;\n\tDBG(__func__)\n\n\tmutex_lock(&minfo->fbcon.mm_lock);\n\tfix->smem_start = minfo->video.base + minfo->curr.ydstorg.bytes;\n\tfix->smem_len = minfo->video.len_usable - minfo->curr.ydstorg.bytes;\n\tmutex_unlock(&minfo->fbcon.mm_lock);\n}\n\nstatic int matroxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tint err;\n\tint visual;\n\tint cmap_len;\n\tunsigned int ydstorg;\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tif (minfo->dead) {\n\t\treturn -ENXIO;\n\t}\n\tif ((err = matroxfb_decode_var(minfo, var, &visual, &cmap_len, &ydstorg)) != 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int matroxfb_set_par(struct fb_info *info)\n{\n\tint err;\n\tint visual;\n\tint cmap_len;\n\tunsigned int ydstorg;\n\tstruct fb_var_screeninfo *var;\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tDBG(__func__)\n\n\tif (minfo->dead) {\n\t\treturn -ENXIO;\n\t}\n\n\tvar = &info->var;\n\tif ((err = matroxfb_decode_var(minfo, var, &visual, &cmap_len, &ydstorg)) != 0)\n\t\treturn err;\n\tminfo->fbcon.screen_base = vaddr_va(minfo->video.vbase) + ydstorg;\n\tmatroxfb_update_fix(minfo);\n\tminfo->fbcon.fix.visual = visual;\n\tminfo->fbcon.fix.type = FB_TYPE_PACKED_PIXELS;\n\tminfo->fbcon.fix.type_aux = 0;\n\tminfo->fbcon.fix.line_length = (var->xres_virtual * var->bits_per_pixel) >> 3;\n\t{\n\t\tunsigned int pos;\n\n\t\tminfo->curr.cmap_len = cmap_len;\n\t\tydstorg += minfo->devflags.ydstorg;\n\t\tminfo->curr.ydstorg.bytes = ydstorg;\n\t\tminfo->curr.ydstorg.chunks = ydstorg >> (isInterleave(minfo) ? 3 : 2);\n\t\tif (var->bits_per_pixel == 4)\n\t\t\tminfo->curr.ydstorg.pixels = ydstorg;\n\t\telse\n\t\t\tminfo->curr.ydstorg.pixels = (ydstorg * 8) / var->bits_per_pixel;\n\t\tminfo->curr.final_bppShift = matroxfb_get_final_bppShift(minfo, var->bits_per_pixel);\n\t\t{\tstruct my_timming mt;\n\t\t\tstruct matrox_hw_state* hw;\n\t\t\tint out;\n\n\t\t\tmatroxfb_var2my(var, &mt);\n\t\t\tmt.crtc = MATROXFB_SRC_CRTC1;\n\t\t\t \n\t\t\tswitch (var->bits_per_pixel) {\n\t\t\t\tcase  0:\tmt.delay = 31 + 0; break;\n\t\t\t\tcase 16:\tmt.delay = 21 + 8; break;\n\t\t\t\tcase 24:\tmt.delay = 17 + 8; break;\n\t\t\t\tcase 32:\tmt.delay = 16 + 8; break;\n\t\t\t\tdefault:\tmt.delay = 31 + 8; break;\n\t\t\t}\n\n\t\t\thw = &minfo->hw;\n\n\t\t\tdown_read(&minfo->altout.lock);\n\t\t\tfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\n\t\t\t\tif (minfo->outputs[out].src == MATROXFB_SRC_CRTC1 &&\n\t\t\t\t    minfo->outputs[out].output->compute) {\n\t\t\t\t\tminfo->outputs[out].output->compute(minfo->outputs[out].data, &mt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tup_read(&minfo->altout.lock);\n\t\t\tminfo->crtc1.pixclock = mt.pixclock;\n\t\t\tminfo->crtc1.mnp = mt.mnp;\n\t\t\tminfo->hw_switch->init(minfo, &mt);\n\t\t\tpos = (var->yoffset * var->xres_virtual + var->xoffset) * minfo->curr.final_bppShift / 32;\n\t\t\tpos += minfo->curr.ydstorg.chunks;\n\n\t\t\thw->CRTC[0x0D] = pos & 0xFF;\n\t\t\thw->CRTC[0x0C] = (pos & 0xFF00) >> 8;\n\t\t\thw->CRTCEXT[0] = (hw->CRTCEXT[0] & 0xF0) | ((pos >> 16) & 0x0F) | ((pos >> 14) & 0x40);\n\t\t\thw->CRTCEXT[8] = pos >> 21;\n\t\t\tminfo->hw_switch->restore(minfo);\n\t\t\tupdate_crtc2(minfo, pos);\n\t\t\tdown_read(&minfo->altout.lock);\n\t\t\tfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\n\t\t\t\tif (minfo->outputs[out].src == MATROXFB_SRC_CRTC1 &&\n\t\t\t\t    minfo->outputs[out].output->program) {\n\t\t\t\t\tminfo->outputs[out].output->program(minfo->outputs[out].data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\n\t\t\t\tif (minfo->outputs[out].src == MATROXFB_SRC_CRTC1 &&\n\t\t\t\t    minfo->outputs[out].output->start) {\n\t\t\t\t\tminfo->outputs[out].output->start(minfo->outputs[out].data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tup_read(&minfo->altout.lock);\n\t\t\tmatrox_cfbX_init(minfo);\n\t\t}\n\t}\n\tminfo->initialized = 1;\n\treturn 0;\n}\n\nstatic int matroxfb_get_vblank(struct matrox_fb_info *minfo,\n\t\t\t       struct fb_vblank *vblank)\n{\n\tunsigned int sts1;\n\n\tmatroxfb_enable_irq(minfo, 0);\n\tmemset(vblank, 0, sizeof(*vblank));\n\tvblank->flags = FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC |\n\t\t\tFB_VBLANK_HAVE_VBLANK | FB_VBLANK_HAVE_HBLANK;\n\tsts1 = mga_inb(M_INSTS1);\n\tvblank->vcount = mga_inl(M_VCOUNT);\n\t \n\tif (sts1 & 1)\n\t\tvblank->flags |= FB_VBLANK_HBLANKING;\n\tif (sts1 & 8)\n\t\tvblank->flags |= FB_VBLANK_VSYNCING;\n\tif (vblank->vcount >= minfo->fbcon.var.yres)\n\t\tvblank->flags |= FB_VBLANK_VBLANKING;\n\tif (test_bit(0, &minfo->irq_flags)) {\n\t\tvblank->flags |= FB_VBLANK_HAVE_COUNT;\n\t\t \n\t\tvblank->count = minfo->crtc1.vsync.cnt;\n\t}\n\treturn 0;\n}\n\nstatic struct matrox_altout panellink_output = {\n\t.name\t = \"Panellink output\",\n};\n\nstatic int matroxfb_ioctl(struct fb_info *info,\n\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tDBG(__func__)\n\n\tif (minfo->dead) {\n\t\treturn -ENXIO;\n\t}\n\n\tswitch (cmd) {\n\t\tcase FBIOGET_VBLANK:\n\t\t\t{\n\t\t\t\tstruct fb_vblank vblank;\n\t\t\t\tint err;\n\n\t\t\t\terr = matroxfb_get_vblank(minfo, &vblank);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tif (copy_to_user(argp, &vblank, sizeof(vblank)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tcase FBIO_WAITFORVSYNC:\n\t\t\t{\n\t\t\t\tu_int32_t crt;\n\n\t\t\t\tif (get_user(crt, (u_int32_t __user *)arg))\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\treturn matroxfb_wait_for_sync(minfo, crt);\n\t\t\t}\n\t\tcase MATROXFB_SET_OUTPUT_MODE:\n\t\t\t{\n\t\t\t\tstruct matroxioc_output_mode mom;\n\t\t\t\tstruct matrox_altout *oproc;\n\t\t\t\tint val;\n\n\t\t\t\tif (copy_from_user(&mom, argp, sizeof(mom)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (mom.output >= MATROXFB_MAX_OUTPUTS)\n\t\t\t\t\treturn -ENXIO;\n\t\t\t\tdown_read(&minfo->altout.lock);\n\t\t\t\toproc = minfo->outputs[mom.output].output;\n\t\t\t\tif (!oproc) {\n\t\t\t\t\tval = -ENXIO;\n\t\t\t\t} else if (!oproc->verifymode) {\n\t\t\t\t\tif (mom.mode == MATROXFB_OUTPUT_MODE_MONITOR) {\n\t\t\t\t\t\tval = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval = -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tval = oproc->verifymode(minfo->outputs[mom.output].data, mom.mode);\n\t\t\t\t}\n\t\t\t\tif (!val) {\n\t\t\t\t\tif (minfo->outputs[mom.output].mode != mom.mode) {\n\t\t\t\t\t\tminfo->outputs[mom.output].mode = mom.mode;\n\t\t\t\t\t\tval = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tup_read(&minfo->altout.lock);\n\t\t\t\tif (val != 1)\n\t\t\t\t\treturn val;\n\t\t\t\tswitch (minfo->outputs[mom.output].src) {\n\t\t\t\t\tcase MATROXFB_SRC_CRTC1:\n\t\t\t\t\t\tmatroxfb_set_par(info);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MATROXFB_SRC_CRTC2:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct matroxfb_dh_fb_info* crtc2;\n\n\t\t\t\t\t\t\tdown_read(&minfo->crtc2.lock);\n\t\t\t\t\t\t\tcrtc2 = minfo->crtc2.info;\n\t\t\t\t\t\t\tif (crtc2)\n\t\t\t\t\t\t\t\tcrtc2->fbcon.fbops->fb_set_par(&crtc2->fbcon);\n\t\t\t\t\t\t\tup_read(&minfo->crtc2.lock);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tcase MATROXFB_GET_OUTPUT_MODE:\n\t\t\t{\n\t\t\t\tstruct matroxioc_output_mode mom;\n\t\t\t\tstruct matrox_altout *oproc;\n\t\t\t\tint val;\n\n\t\t\t\tif (copy_from_user(&mom, argp, sizeof(mom)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (mom.output >= MATROXFB_MAX_OUTPUTS)\n\t\t\t\t\treturn -ENXIO;\n\t\t\t\tdown_read(&minfo->altout.lock);\n\t\t\t\toproc = minfo->outputs[mom.output].output;\n\t\t\t\tif (!oproc) {\n\t\t\t\t\tval = -ENXIO;\n\t\t\t\t} else {\n\t\t\t\t\tmom.mode = minfo->outputs[mom.output].mode;\n\t\t\t\t\tval = 0;\n\t\t\t\t}\n\t\t\t\tup_read(&minfo->altout.lock);\n\t\t\t\tif (val)\n\t\t\t\t\treturn val;\n\t\t\t\tif (copy_to_user(argp, &mom, sizeof(mom)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tcase MATROXFB_SET_OUTPUT_CONNECTION:\n\t\t\t{\n\t\t\t\tu_int32_t tmp;\n\t\t\t\tint i;\n\t\t\t\tint changes;\n\n\t\t\t\tif (copy_from_user(&tmp, argp, sizeof(tmp)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tfor (i = 0; i < 32; i++) {\n\t\t\t\t\tif (tmp & (1 << i)) {\n\t\t\t\t\t\tif (i >= MATROXFB_MAX_OUTPUTS)\n\t\t\t\t\t\t\treturn -ENXIO;\n\t\t\t\t\t\tif (!minfo->outputs[i].output)\n\t\t\t\t\t\t\treturn -ENXIO;\n\t\t\t\t\t\tswitch (minfo->outputs[i].src) {\n\t\t\t\t\t\t\tcase MATROXFB_SRC_NONE:\n\t\t\t\t\t\t\tcase MATROXFB_SRC_CRTC1:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn -EBUSY;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (minfo->devflags.panellink) {\n\t\t\t\t\tif (tmp & MATROXFB_OUTPUT_CONN_DFP) {\n\t\t\t\t\t\tif (tmp & MATROXFB_OUTPUT_CONN_SECONDARY)\n\t\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t\tfor (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {\n\t\t\t\t\t\t\tif (minfo->outputs[i].src == MATROXFB_SRC_CRTC2) {\n\t\t\t\t\t\t\t\treturn -EBUSY;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchanges = 0;\n\t\t\t\tfor (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {\n\t\t\t\t\tif (tmp & (1 << i)) {\n\t\t\t\t\t\tif (minfo->outputs[i].src != MATROXFB_SRC_CRTC1) {\n\t\t\t\t\t\t\tchanges = 1;\n\t\t\t\t\t\t\tminfo->outputs[i].src = MATROXFB_SRC_CRTC1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (minfo->outputs[i].src == MATROXFB_SRC_CRTC1) {\n\t\t\t\t\t\tchanges = 1;\n\t\t\t\t\t\tminfo->outputs[i].src = MATROXFB_SRC_NONE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!changes)\n\t\t\t\t\treturn 0;\n\t\t\t\tmatroxfb_set_par(info);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tcase MATROXFB_GET_OUTPUT_CONNECTION:\n\t\t\t{\n\t\t\t\tu_int32_t conn = 0;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {\n\t\t\t\t\tif (minfo->outputs[i].src == MATROXFB_SRC_CRTC1) {\n\t\t\t\t\t\tconn |= 1 << i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (put_user(conn, (u_int32_t __user *)arg))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tcase MATROXFB_GET_AVAILABLE_OUTPUTS:\n\t\t\t{\n\t\t\t\tu_int32_t conn = 0;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {\n\t\t\t\t\tif (minfo->outputs[i].output) {\n\t\t\t\t\t\tswitch (minfo->outputs[i].src) {\n\t\t\t\t\t\t\tcase MATROXFB_SRC_NONE:\n\t\t\t\t\t\t\tcase MATROXFB_SRC_CRTC1:\n\t\t\t\t\t\t\t\tconn |= 1 << i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (minfo->devflags.panellink) {\n\t\t\t\t\tif (conn & MATROXFB_OUTPUT_CONN_DFP)\n\t\t\t\t\t\tconn &= ~MATROXFB_OUTPUT_CONN_SECONDARY;\n\t\t\t\t\tif (conn & MATROXFB_OUTPUT_CONN_SECONDARY)\n\t\t\t\t\t\tconn &= ~MATROXFB_OUTPUT_CONN_DFP;\n\t\t\t\t}\n\t\t\t\tif (put_user(conn, (u_int32_t __user *)arg))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tcase MATROXFB_GET_ALL_OUTPUTS:\n\t\t\t{\n\t\t\t\tu_int32_t conn = 0;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {\n\t\t\t\t\tif (minfo->outputs[i].output) {\n\t\t\t\t\t\tconn |= 1 << i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (put_user(conn, (u_int32_t __user *)arg))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tcase VIDIOC_QUERYCAP:\n\t\t\t{\n\t\t\t\tstruct v4l2_capability r;\n\n\t\t\t\tmemset(&r, 0, sizeof(r));\n\t\t\t\tstrcpy(r.driver, \"matroxfb\");\n\t\t\t\tstrcpy(r.card, \"Matrox\");\n\t\t\t\tsprintf(r.bus_info, \"PCI:%s\", pci_name(minfo->pcidev));\n\t\t\t\tr.version = KERNEL_VERSION(1,0,0);\n\t\t\t\tr.capabilities = V4L2_CAP_VIDEO_OUTPUT;\n\t\t\t\tif (copy_to_user(argp, &r, sizeof(r)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\tcase VIDIOC_QUERYCTRL:\n\t\t\t{\n\t\t\t\tstruct v4l2_queryctrl qctrl;\n\t\t\t\tint err;\n\n\t\t\t\tif (copy_from_user(&qctrl, argp, sizeof(qctrl)))\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\tdown_read(&minfo->altout.lock);\n\t\t\t\tif (!minfo->outputs[1].output) {\n\t\t\t\t\terr = -ENXIO;\n\t\t\t\t} else if (minfo->outputs[1].output->getqueryctrl) {\n\t\t\t\t\terr = minfo->outputs[1].output->getqueryctrl(minfo->outputs[1].data, &qctrl);\n\t\t\t\t} else {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t}\n\t\t\t\tup_read(&minfo->altout.lock);\n\t\t\t\tif (err >= 0 &&\n\t\t\t\t    copy_to_user(argp, &qctrl, sizeof(qctrl)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn err;\n\t\t\t}\n\t\tcase VIDIOC_G_CTRL:\n\t\t\t{\n\t\t\t\tstruct v4l2_control ctrl;\n\t\t\t\tint err;\n\n\t\t\t\tif (copy_from_user(&ctrl, argp, sizeof(ctrl)))\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\tdown_read(&minfo->altout.lock);\n\t\t\t\tif (!minfo->outputs[1].output) {\n\t\t\t\t\terr = -ENXIO;\n\t\t\t\t} else if (minfo->outputs[1].output->getctrl) {\n\t\t\t\t\terr = minfo->outputs[1].output->getctrl(minfo->outputs[1].data, &ctrl);\n\t\t\t\t} else {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t}\n\t\t\t\tup_read(&minfo->altout.lock);\n\t\t\t\tif (err >= 0 &&\n\t\t\t\t    copy_to_user(argp, &ctrl, sizeof(ctrl)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn err;\n\t\t\t}\n\t\tcase VIDIOC_S_CTRL:\n\t\t\t{\n\t\t\t\tstruct v4l2_control ctrl;\n\t\t\t\tint err;\n\n\t\t\t\tif (copy_from_user(&ctrl, argp, sizeof(ctrl)))\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\tdown_read(&minfo->altout.lock);\n\t\t\t\tif (!minfo->outputs[1].output) {\n\t\t\t\t\terr = -ENXIO;\n\t\t\t\t} else if (minfo->outputs[1].output->setctrl) {\n\t\t\t\t\terr = minfo->outputs[1].output->setctrl(minfo->outputs[1].data, &ctrl);\n\t\t\t\t} else {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t}\n\t\t\t\tup_read(&minfo->altout.lock);\n\t\t\t\treturn err;\n\t\t\t}\n\t}\n\treturn -ENOTTY;\n}\n\n \n\nstatic int matroxfb_blank(int blank, struct fb_info *info)\n{\n\tint seq;\n\tint crtc;\n\tCRITFLAGS\n\tstruct matrox_fb_info *minfo = info2minfo(info);\n\n\tDBG(__func__)\n\n\tif (minfo->dead)\n\t\treturn 1;\n\n\tswitch (blank) {\n\tcase FB_BLANK_NORMAL:  seq = 0x20; crtc = 0x00; break;  \n\tcase FB_BLANK_VSYNC_SUSPEND:  seq = 0x20; crtc = 0x10; break;\n\tcase FB_BLANK_HSYNC_SUSPEND:  seq = 0x20; crtc = 0x20; break;\n\tcase FB_BLANK_POWERDOWN:  seq = 0x20; crtc = 0x30; break;\n\tdefault: seq = 0x00; crtc = 0x00; break;\n\t}\n\n\tCRITBEGIN\n\n\tmga_outb(M_SEQ_INDEX, 1);\n\tmga_outb(M_SEQ_DATA, (mga_inb(M_SEQ_DATA) & ~0x20) | seq);\n\tmga_outb(M_EXTVGA_INDEX, 1);\n\tmga_outb(M_EXTVGA_DATA, (mga_inb(M_EXTVGA_DATA) & ~0x30) | crtc);\n\n\tCRITEND\n\treturn 0;\n}\n\nstatic const struct fb_ops matroxfb_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.fb_open =\tmatroxfb_open,\n\t.fb_release =\tmatroxfb_release,\n\t.fb_check_var =\tmatroxfb_check_var,\n\t.fb_set_par =\tmatroxfb_set_par,\n\t.fb_setcolreg =\tmatroxfb_setcolreg,\n\t.fb_pan_display =matroxfb_pan_display,\n\t.fb_blank =\tmatroxfb_blank,\n\t.fb_ioctl =\tmatroxfb_ioctl,\n \n \n \n \n};\n\n#define RSDepth(X)\t(((X) >> 8) & 0x0F)\n#define RS8bpp\t\t0x1\n#define RS15bpp\t\t0x2\n#define RS16bpp\t\t0x3\n#define RS32bpp\t\t0x4\n#define RS4bpp\t\t0x5\n#define RS24bpp\t\t0x6\n#define RSText\t\t0x7\n#define RSText8\t\t0x8\n \nstatic struct { struct fb_bitfield red, green, blue, transp; int bits_per_pixel; } colors[] = {\n\t{ {  0, 8, 0}, { 0, 8, 0}, { 0, 8, 0}, {  0, 0, 0},  8 },\n\t{ { 10, 5, 0}, { 5, 5, 0}, { 0, 5, 0}, { 15, 1, 0}, 16 },\n\t{ { 11, 5, 0}, { 5, 6, 0}, { 0, 5, 0}, {  0, 0, 0}, 16 },\n\t{ { 16, 8, 0}, { 8, 8, 0}, { 0, 8, 0}, { 24, 8, 0}, 32 },\n\t{ {  0, 8, 0}, { 0, 8, 0}, { 0, 8, 0}, {  0, 0, 0},  4 },\n\t{ { 16, 8, 0}, { 8, 8, 0}, { 0, 8, 0}, {  0, 0, 0}, 24 },\n\t{ {  0, 6, 0}, { 0, 6, 0}, { 0, 6, 0}, {  0, 0, 0},  0 },\t \n\t{ {  0, 6, 0}, { 0, 6, 0}, { 0, 6, 0}, {  0, 0, 0},  0 },\t \n};\n\n \nstatic unsigned int mem;\t\t \nstatic int option_precise_width = 1;\t \nstatic int inv24;\t\t\t \nstatic int cross4MB = -1;\t\t \nstatic int disabled;\t\t\t \nstatic int noaccel;\t\t\t \nstatic int nopan;\t\t\t \nstatic int no_pci_retry;\t\t \nstatic int novga;\t\t\t \nstatic int nobios;\t\t\t \nstatic int noinit = 1;\t\t\t \nstatic int inverse;\t\t\t \nstatic int sgram;\t\t\t \nstatic int mtrr = 1;\t\t\t \nstatic int grayscale;\t\t\t \nstatic int dev = -1;\t\t\t \nstatic unsigned int vesa = ~0;\t\t \nstatic int depth = -1;\t\t\t \nstatic unsigned int xres;\t\t \nstatic unsigned int yres;\t\t \nstatic unsigned int upper = ~0;\t\t \nstatic unsigned int lower = ~0;\t\t \nstatic unsigned int vslen;\t\t \nstatic unsigned int left = ~0;\t\t \nstatic unsigned int right = ~0;\t\t \nstatic unsigned int hslen;\t\t \nstatic unsigned int pixclock;\t\t \nstatic int sync = -1;\t\t\t \nstatic unsigned int fv;\t\t\t \nstatic unsigned int fh;\t\t\t \nstatic unsigned int maxclk;\t\t \nstatic int dfp;\t\t\t\t \nstatic int dfp_type = -1;\t\t \nstatic int memtype = -1;\t\t \nstatic char outputs[8];\t\t\t \n\n#ifndef MODULE\nstatic char videomode[64];\t\t \n#endif\n\nstatic int matroxfb_getmemory(struct matrox_fb_info *minfo,\n\t\t\t      unsigned int maxSize, unsigned int *realSize)\n{\n\tvaddr_t vm;\n\tunsigned int offs;\n\tunsigned int offs2;\n\tunsigned char orig;\n\tunsigned char bytes[32];\n\tunsigned char* tmp;\n\n\tDBG(__func__)\n\n\tvm = minfo->video.vbase;\n\tmaxSize &= ~0x1FFFFF;\t \n\t \n\tif (maxSize < 0x0200000) return 0;\n\tif (maxSize > 0x2000000) maxSize = 0x2000000;\n\n\tmga_outb(M_EXTVGA_INDEX, 0x03);\n\torig = mga_inb(M_EXTVGA_DATA);\n\tmga_outb(M_EXTVGA_DATA, orig | 0x80);\n\n\ttmp = bytes;\n\tfor (offs = 0x100000; offs < maxSize; offs += 0x200000)\n\t\t*tmp++ = mga_readb(vm, offs);\n\tfor (offs = 0x100000; offs < maxSize; offs += 0x200000)\n\t\tmga_writeb(vm, offs, 0x02);\n\tmga_outb(M_CACHEFLUSH, 0x00);\n\tfor (offs = 0x100000; offs < maxSize; offs += 0x200000) {\n\t\tif (mga_readb(vm, offs) != 0x02)\n\t\t\tbreak;\n\t\tmga_writeb(vm, offs, mga_readb(vm, offs) - 0x02);\n\t\tif (mga_readb(vm, offs))\n\t\t\tbreak;\n\t}\n\ttmp = bytes;\n\tfor (offs2 = 0x100000; offs2 < maxSize; offs2 += 0x200000)\n\t\tmga_writeb(vm, offs2, *tmp++);\n\n\tmga_outb(M_EXTVGA_INDEX, 0x03);\n\tmga_outb(M_EXTVGA_DATA, orig);\n\n\t*realSize = offs - 0x100000;\n#ifdef CONFIG_FB_MATROX_MILLENIUM\n\tminfo->interleave = !(!isMillenium(minfo) || ((offs - 0x100000) & 0x3FFFFF));\n#endif\n\treturn 1;\n}\n\nstruct video_board {\n\tint maxvram;\n\tint maxdisplayable;\n\tint accelID;\n\tstruct matrox_switch* lowlevel;\n\t\t };\n#ifdef CONFIG_FB_MATROX_MILLENIUM\nstatic struct video_board vbMillennium = {\n\t.maxvram = 0x0800000,\n\t.maxdisplayable = 0x0800000,\n\t.accelID = FB_ACCEL_MATROX_MGA2064W,\n\t.lowlevel = &matrox_millennium\n};\n\nstatic struct video_board vbMillennium2 = {\n\t.maxvram = 0x1000000,\n\t.maxdisplayable = 0x0800000,\n\t.accelID = FB_ACCEL_MATROX_MGA2164W,\n\t.lowlevel = &matrox_millennium\n};\n\nstatic struct video_board vbMillennium2A = {\n\t.maxvram = 0x1000000,\n\t.maxdisplayable = 0x0800000,\n\t.accelID = FB_ACCEL_MATROX_MGA2164W_AGP,\n\t.lowlevel = &matrox_millennium\n};\n#endif\t \n#ifdef CONFIG_FB_MATROX_MYSTIQUE\nstatic struct video_board vbMystique = {\n\t.maxvram = 0x0800000,\n\t.maxdisplayable = 0x0800000,\n\t.accelID = FB_ACCEL_MATROX_MGA1064SG,\n\t.lowlevel = &matrox_mystique\n};\n#endif\t \n#ifdef CONFIG_FB_MATROX_G\nstatic struct video_board vbG100 = {\n\t.maxvram = 0x0800000,\n\t.maxdisplayable = 0x0800000,\n\t.accelID = FB_ACCEL_MATROX_MGAG100,\n\t.lowlevel = &matrox_G100\n};\n\nstatic struct video_board vbG200 = {\n\t.maxvram = 0x1000000,\n\t.maxdisplayable = 0x1000000,\n\t.accelID = FB_ACCEL_MATROX_MGAG200,\n\t.lowlevel = &matrox_G100\n};\nstatic struct video_board vbG200eW = {\n\t.maxvram = 0x1000000,\n\t.maxdisplayable = 0x0800000,\n\t.accelID = FB_ACCEL_MATROX_MGAG200,\n\t.lowlevel = &matrox_G100\n};\n \nstatic struct video_board vbG400 = {\n\t.maxvram = 0x2000000,\n\t.maxdisplayable = 0x1000000,\n\t.accelID = FB_ACCEL_MATROX_MGAG400,\n\t.lowlevel = &matrox_G100\n};\n#endif\n\n#define DEVF_VIDEO64BIT\t\t0x0001\n#define\tDEVF_SWAPS\t\t0x0002\n#define DEVF_SRCORG\t\t0x0004\n#define DEVF_DUALHEAD\t\t0x0008\n#define DEVF_CROSS4MB\t\t0x0010\n#define DEVF_TEXT4B\t\t0x0020\n \n \n#define DEVF_SUPPORT32MB\t0x0100\n#define DEVF_ANY_VXRES\t\t0x0200\n#define DEVF_TEXT16B\t\t0x0400\n#define DEVF_CRTC2\t\t0x0800\n#define DEVF_MAVEN_CAPABLE\t0x1000\n#define DEVF_PANELLINK_CAPABLE\t0x2000\n#define DEVF_G450DAC\t\t0x4000\n\n#define DEVF_GCORE\t(DEVF_VIDEO64BIT | DEVF_SWAPS | DEVF_CROSS4MB)\n#define DEVF_G2CORE\t(DEVF_GCORE | DEVF_ANY_VXRES | DEVF_MAVEN_CAPABLE | DEVF_PANELLINK_CAPABLE | DEVF_SRCORG | DEVF_DUALHEAD)\n#define DEVF_G100\t(DEVF_GCORE)  \n#define DEVF_G200\t(DEVF_G2CORE)\n#define DEVF_G400\t(DEVF_G2CORE | DEVF_SUPPORT32MB | DEVF_TEXT16B | DEVF_CRTC2)\n \n#define DEVF_G450\t(DEVF_GCORE | DEVF_ANY_VXRES | DEVF_SUPPORT32MB | DEVF_TEXT16B | DEVF_CRTC2 | DEVF_G450DAC | DEVF_SRCORG | DEVF_DUALHEAD)\n#define DEVF_G550\t(DEVF_G450)\n\nstatic struct board {\n\tunsigned short vendor, device, rev, svid, sid;\n\tunsigned int flags;\n\tunsigned int maxclk;\n\tenum mga_chip chip;\n\tstruct video_board* base;\n\tconst char* name;\n\t\t} dev_list[] = {\n#ifdef CONFIG_FB_MATROX_MILLENIUM\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_MIL,\t0xFF,\n\t\t0,\t\t\t0,\n\t\tDEVF_TEXT4B,\n\t\t230000,\n\t\tMGA_2064,\n\t\t&vbMillennium,\n\t\t\"Millennium (PCI)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_MIL_2,\t0xFF,\n\t\t0,\t\t\t0,\n\t\tDEVF_SWAPS,\n\t\t220000,\n\t\tMGA_2164,\n\t\t&vbMillennium2,\n\t\t\"Millennium II (PCI)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_MIL_2_AGP,\t0xFF,\n\t\t0,\t\t\t0,\n\t\tDEVF_SWAPS,\n\t\t250000,\n\t\tMGA_2164,\n\t\t&vbMillennium2A,\n\t\t\"Millennium II (AGP)\"},\n#endif\n#ifdef CONFIG_FB_MATROX_MYSTIQUE\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_MYS,\t0x02,\n\t\t0,\t\t\t0,\n\t\tDEVF_VIDEO64BIT | DEVF_CROSS4MB,\n\t\t180000,\n\t\tMGA_1064,\n\t\t&vbMystique,\n\t\t\"Mystique (PCI)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_MYS,\t0xFF,\n\t\t0,\t\t\t0,\n\t\tDEVF_VIDEO64BIT | DEVF_SWAPS | DEVF_CROSS4MB,\n\t\t220000,\n\t\tMGA_1164,\n\t\t&vbMystique,\n\t\t\"Mystique 220 (PCI)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_MYS_AGP,\t0x02,\n\t\t0,\t\t\t0,\n\t\tDEVF_VIDEO64BIT | DEVF_CROSS4MB,\n\t\t180000,\n\t\tMGA_1064,\n\t\t&vbMystique,\n\t\t\"Mystique (AGP)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_MYS_AGP,\t0xFF,\n\t\t0,\t\t\t0,\n\t\tDEVF_VIDEO64BIT | DEVF_SWAPS | DEVF_CROSS4MB,\n\t\t220000,\n\t\tMGA_1164,\n\t\t&vbMystique,\n\t\t\"Mystique 220 (AGP)\"},\n#endif\n#ifdef CONFIG_FB_MATROX_G\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G100_MM,\t0xFF,\n\t\t0,\t\t\t0,\n\t\tDEVF_G100,\n\t\t230000,\n\t\tMGA_G100,\n\t\t&vbG100,\n\t\t\"MGA-G100 (PCI)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G100_AGP,\t0xFF,\n\t\t0,\t\t\t0,\n\t\tDEVF_G100,\n\t\t230000,\n\t\tMGA_G100,\n\t\t&vbG100,\n\t\t\"MGA-G100 (AGP)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G200_PCI,\t0xFF,\n\t\t0,\t\t\t0,\n\t\tDEVF_G200,\n\t\t250000,\n\t\tMGA_G200,\n\t\t&vbG200,\n\t\t\"MGA-G200 (PCI)\"},\n\t{PCI_VENDOR_ID_MATROX,\t0x0532,\t0xFF,\n\t\t0,\t\t\t0,\n\t\tDEVF_G200,\n\t\t250000,\n\t\tMGA_G200,\n\t\t&vbG200eW,\n\t\t\"MGA-G200eW (PCI)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G200_AGP,\t0xFF,\n\t\tPCI_SS_VENDOR_ID_MATROX,\tPCI_SS_ID_MATROX_GENERIC,\n\t\tDEVF_G200,\n\t\t220000,\n\t\tMGA_G200,\n\t\t&vbG200,\n\t\t\"MGA-G200 (AGP)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G200_AGP,\t0xFF,\n\t\tPCI_SS_VENDOR_ID_MATROX,\tPCI_SS_ID_MATROX_MYSTIQUE_G200_AGP,\n\t\tDEVF_G200,\n\t\t230000,\n\t\tMGA_G200,\n\t\t&vbG200,\n\t\t\"Mystique G200 (AGP)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G200_AGP,\t0xFF,\n\t\tPCI_SS_VENDOR_ID_MATROX,\tPCI_SS_ID_MATROX_MILLENIUM_G200_AGP,\n\t\tDEVF_G200,\n\t\t250000,\n\t\tMGA_G200,\n\t\t&vbG200,\n\t\t\"Millennium G200 (AGP)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G200_AGP,\t0xFF,\n\t\tPCI_SS_VENDOR_ID_MATROX,\tPCI_SS_ID_MATROX_MARVEL_G200_AGP,\n\t\tDEVF_G200,\n\t\t230000,\n\t\tMGA_G200,\n\t\t&vbG200,\n\t\t\"Marvel G200 (AGP)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G200_AGP,\t0xFF,\n\t\tPCI_SS_VENDOR_ID_SIEMENS_NIXDORF,\tPCI_SS_ID_SIEMENS_MGA_G200_AGP,\n\t\tDEVF_G200,\n\t\t230000,\n\t\tMGA_G200,\n\t\t&vbG200,\n\t\t\"MGA-G200 (AGP)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G200_AGP,\t0xFF,\n\t\t0,\t\t\t0,\n\t\tDEVF_G200,\n\t\t230000,\n\t\tMGA_G200,\n\t\t&vbG200,\n\t\t\"G200 (AGP)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G400,\t0x80,\n\t\tPCI_SS_VENDOR_ID_MATROX,\tPCI_SS_ID_MATROX_MILLENNIUM_G400_MAX_AGP,\n\t\tDEVF_G400,\n\t\t360000,\n\t\tMGA_G400,\n\t\t&vbG400,\n\t\t\"Millennium G400 MAX (AGP)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G400,\t0x80,\n\t\t0,\t\t\t0,\n\t\tDEVF_G400,\n\t\t300000,\n\t\tMGA_G400,\n\t\t&vbG400,\n\t\t\"G400 (AGP)\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G400,\t0xFF,\n\t\t0,\t\t\t0,\n\t\tDEVF_G450,\n\t\t360000,\n\t\tMGA_G450,\n\t\t&vbG400,\n\t\t\"G450\"},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G550,\t0xFF,\n\t\t0,\t\t\t0,\n\t\tDEVF_G550,\n\t\t360000,\n\t\tMGA_G550,\n\t\t&vbG400,\n\t\t\"G550\"},\n#endif\n\t{0,\t\t\t0,\t\t\t\t0xFF,\n\t\t0,\t\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\tNULL,\n\t\tNULL}};\n\n#ifndef MODULE\nstatic const struct fb_videomode defaultmode = {\n\t \n\tNULL, 60, 640, 480, 39721, 40, 24, 32, 11, 96, 2,\n\t0, FB_VMODE_NONINTERLACED\n};\n\nstatic int hotplug = 0;\n#endif  \n\nstatic void setDefaultOutputs(struct matrox_fb_info *minfo)\n{\n\tunsigned int i;\n\tconst char* ptr;\n\n\tminfo->outputs[0].default_src = MATROXFB_SRC_CRTC1;\n\tif (minfo->devflags.g450dac) {\n\t\tminfo->outputs[1].default_src = MATROXFB_SRC_CRTC1;\n\t\tminfo->outputs[2].default_src = MATROXFB_SRC_CRTC1;\n\t} else if (dfp) {\n\t\tminfo->outputs[2].default_src = MATROXFB_SRC_CRTC1;\n\t}\n\tptr = outputs;\n\tfor (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {\n\t\tchar c = *ptr++;\n\n\t\tif (c == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == '0') {\n\t\t\tminfo->outputs[i].default_src = MATROXFB_SRC_NONE;\n\t\t} else if (c == '1') {\n\t\t\tminfo->outputs[i].default_src = MATROXFB_SRC_CRTC1;\n\t\t} else if (c == '2' && minfo->devflags.crtc2) {\n\t\t\tminfo->outputs[i].default_src = MATROXFB_SRC_CRTC2;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"matroxfb: Unknown outputs setting\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\toutputs[0] = 0;\n}\n\nstatic int initMatrox2(struct matrox_fb_info *minfo, struct board *b)\n{\n\tunsigned long ctrlptr_phys = 0;\n\tunsigned long video_base_phys = 0;\n\tunsigned int memsize;\n\tint err;\n\n\tstatic const struct pci_device_id intel_82437[] = {\n\t\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82437) },\n\t\t{ },\n\t};\n\n\tDBG(__func__)\n\n\t \n\tvesafb_defined.accel_flags = FB_ACCELF_TEXT;\n\n\tminfo->hw_switch = b->base->lowlevel;\n\tminfo->devflags.accelerator = b->base->accelID;\n\tminfo->max_pixel_clock = b->maxclk;\n\n\tprintk(KERN_INFO \"matroxfb: Matrox %s detected\\n\", b->name);\n\tminfo->capable.plnwt = 1;\n\tminfo->chip = b->chip;\n\tminfo->capable.srcorg = b->flags & DEVF_SRCORG;\n\tminfo->devflags.video64bits = b->flags & DEVF_VIDEO64BIT;\n\tif (b->flags & DEVF_TEXT4B) {\n\t\tminfo->devflags.vgastep = 4;\n\t\tminfo->devflags.textmode = 4;\n\t\tminfo->devflags.text_type_aux = FB_AUX_TEXT_MGA_STEP16;\n\t} else if (b->flags & DEVF_TEXT16B) {\n\t\tminfo->devflags.vgastep = 16;\n\t\tminfo->devflags.textmode = 1;\n\t\tminfo->devflags.text_type_aux = FB_AUX_TEXT_MGA_STEP16;\n\t} else {\n\t\tminfo->devflags.vgastep = 8;\n\t\tminfo->devflags.textmode = 1;\n\t\tminfo->devflags.text_type_aux = FB_AUX_TEXT_MGA_STEP8;\n\t}\n\tminfo->devflags.support32MB = (b->flags & DEVF_SUPPORT32MB) != 0;\n\tminfo->devflags.precise_width = !(b->flags & DEVF_ANY_VXRES);\n\tminfo->devflags.crtc2 = (b->flags & DEVF_CRTC2) != 0;\n\tminfo->devflags.maven_capable = (b->flags & DEVF_MAVEN_CAPABLE) != 0;\n\tminfo->devflags.dualhead = (b->flags & DEVF_DUALHEAD) != 0;\n\tminfo->devflags.dfp_type = dfp_type;\n\tminfo->devflags.g450dac = (b->flags & DEVF_G450DAC) != 0;\n\tminfo->devflags.textstep = minfo->devflags.vgastep * minfo->devflags.textmode;\n\tminfo->devflags.textvram = 65536 / minfo->devflags.textmode;\n\tsetDefaultOutputs(minfo);\n\tif (b->flags & DEVF_PANELLINK_CAPABLE) {\n\t\tminfo->outputs[2].data = minfo;\n\t\tminfo->outputs[2].output = &panellink_output;\n\t\tminfo->outputs[2].src = minfo->outputs[2].default_src;\n\t\tminfo->outputs[2].mode = MATROXFB_OUTPUT_MODE_MONITOR;\n\t\tminfo->devflags.panellink = 1;\n\t}\n\n\tif (minfo->capable.cross4MB < 0)\n\t\tminfo->capable.cross4MB = b->flags & DEVF_CROSS4MB;\n\tif (b->flags & DEVF_SWAPS) {\n\t\tctrlptr_phys = pci_resource_start(minfo->pcidev, 1);\n\t\tvideo_base_phys = pci_resource_start(minfo->pcidev, 0);\n\t\tminfo->devflags.fbResource = PCI_BASE_ADDRESS_0;\n\t} else {\n\t\tctrlptr_phys = pci_resource_start(minfo->pcidev, 0);\n\t\tvideo_base_phys = pci_resource_start(minfo->pcidev, 1);\n\t\tminfo->devflags.fbResource = PCI_BASE_ADDRESS_1;\n\t}\n\terr = -EINVAL;\n\tif (!ctrlptr_phys) {\n\t\tprintk(KERN_ERR \"matroxfb: control registers are not available, matroxfb disabled\\n\");\n\t\tgoto fail;\n\t}\n\tif (!video_base_phys) {\n\t\tprintk(KERN_ERR \"matroxfb: video RAM is not available in PCI address space, matroxfb disabled\\n\");\n\t\tgoto fail;\n\t}\n\tmemsize = b->base->maxvram;\n\tif (!request_mem_region(ctrlptr_phys, 16384, \"matroxfb MMIO\")) {\n\t\tgoto fail;\n\t}\n\tif (!request_mem_region(video_base_phys, memsize, \"matroxfb FB\")) {\n\t\tgoto failCtrlMR;\n\t}\n\tminfo->video.len_maximum = memsize;\n\t \n\tif (mem < 1024) mem *= 1024;\n\tif (mem < 0x00100000) mem *= 1024;\n\n\tif (mem && (mem < memsize))\n\t\tmemsize = mem;\n\terr = -ENOMEM;\n\n\tminfo->mmio.vbase.vaddr = ioremap(ctrlptr_phys, 16384);\n\tif (!minfo->mmio.vbase.vaddr) {\n\t\tprintk(KERN_ERR \"matroxfb: cannot ioremap(%lX, 16384), matroxfb disabled\\n\", ctrlptr_phys);\n\t\tgoto failVideoMR;\n\t}\n\tminfo->mmio.base = ctrlptr_phys;\n\tminfo->mmio.len = 16384;\n\tminfo->video.base = video_base_phys;\n\tminfo->video.vbase.vaddr = ioremap_wc(video_base_phys, memsize);\n\tif (!minfo->video.vbase.vaddr) {\n\t\tprintk(KERN_ERR \"matroxfb: cannot ioremap(%lX, %d), matroxfb disabled\\n\",\n\t\t\tvideo_base_phys, memsize);\n\t\tgoto failCtrlIO;\n\t}\n\t{\n\t\tu_int32_t cmd;\n\t\tu_int32_t mga_option;\n\n\t\tpci_read_config_dword(minfo->pcidev, PCI_OPTION_REG, &mga_option);\n\t\tpci_read_config_dword(minfo->pcidev, PCI_COMMAND, &cmd);\n\t\tmga_option &= 0x7FFFFFFF;  \n\t\tmga_option |= MX_OPTION_BSWAP;\n\t\t \n\t\tcmd &= ~PCI_COMMAND_VGA_PALETTE;\n\t\tif (pci_dev_present(intel_82437)) {\n\t\t\tif (!(mga_option & 0x20000000) && !minfo->devflags.nopciretry) {\n\t\t\t\tprintk(KERN_WARNING \"matroxfb: Disabling PCI retries due to i82437 present\\n\");\n\t\t\t}\n\t\t\tmga_option |= 0x20000000;\n\t\t\tminfo->devflags.nopciretry = 1;\n\t\t}\n\t\tpci_write_config_dword(minfo->pcidev, PCI_COMMAND, cmd);\n\t\tpci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, mga_option);\n\t\tminfo->hw.MXoptionReg = mga_option;\n\n\t\t \n\t\t \n\t\tpci_write_config_dword(minfo->pcidev, PCI_MGA_INDEX, 0x00003C00);\n\t}\n\n\terr = -ENXIO;\n\tmatroxfb_read_pins(minfo);\n\tif (minfo->hw_switch->preinit(minfo)) {\n\t\tgoto failVideoIO;\n\t}\n\n\terr = -ENOMEM;\n\tif (!matroxfb_getmemory(minfo, memsize, &minfo->video.len) || !minfo->video.len) {\n\t\tprintk(KERN_ERR \"matroxfb: cannot determine memory size\\n\");\n\t\tgoto failVideoIO;\n\t}\n\tminfo->devflags.ydstorg = 0;\n\n\tminfo->video.base = video_base_phys;\n\tminfo->video.len_usable = minfo->video.len;\n\tif (minfo->video.len_usable > b->base->maxdisplayable)\n\t\tminfo->video.len_usable = b->base->maxdisplayable;\n\tif (mtrr)\n\t\tminfo->wc_cookie = arch_phys_wc_add(video_base_phys,\n\t\t\t\t\t\t    minfo->video.len);\n\n\tif (!minfo->devflags.novga)\n\t\trequest_region(0x3C0, 32, \"matrox\");\n\tmatroxfb_g450_connect(minfo);\n\tminfo->hw_switch->reset(minfo);\n\n\tminfo->fbcon.monspecs.hfmin = 0;\n\tminfo->fbcon.monspecs.hfmax = fh;\n\tminfo->fbcon.monspecs.vfmin = 0;\n\tminfo->fbcon.monspecs.vfmax = fv;\n\tminfo->fbcon.monspecs.dpms = 0;\t \n\n\t \n\tvesafb_defined.red = colors[depth-1].red;\n\tvesafb_defined.green = colors[depth-1].green;\n\tvesafb_defined.blue = colors[depth-1].blue;\n\tvesafb_defined.bits_per_pixel = colors[depth-1].bits_per_pixel;\n\tvesafb_defined.grayscale = grayscale;\n\tvesafb_defined.vmode = 0;\n\tif (noaccel)\n\t\tvesafb_defined.accel_flags &= ~FB_ACCELF_TEXT;\n\n\tminfo->fbops = matroxfb_ops;\n\tminfo->fbcon.fbops = &minfo->fbops;\n\tminfo->fbcon.pseudo_palette = minfo->cmap;\n\tminfo->fbcon.flags = FBINFO_PARTIAL_PAN_OK | \t  \n\t\t\t\t      FBINFO_HWACCEL_COPYAREA |   \n\t\t\t\t      FBINFO_HWACCEL_FILLRECT |   \n\t\t\t\t      FBINFO_HWACCEL_IMAGEBLIT |  \n\t\t\t\t      FBINFO_HWACCEL_XPAN |       \n\t\t\t\t      FBINFO_HWACCEL_YPAN |       \n\t\t\t\t      FBINFO_READS_FAST;\n\tminfo->video.len_usable &= PAGE_MASK;\n\tfb_alloc_cmap(&minfo->fbcon.cmap, 256, 1);\n\n#ifndef MODULE\n\t \n\tif (!hotplug) {\n\t\tfb_find_mode(&vesafb_defined, &minfo->fbcon, videomode[0] ? videomode : NULL,\n\t\t\tNULL, 0, &defaultmode, vesafb_defined.bits_per_pixel);\n\t}\n#endif  \n\n\t \n\tif (hslen)\n\t\tvesafb_defined.hsync_len = hslen;\n\tif (vslen)\n\t\tvesafb_defined.vsync_len = vslen;\n\tif (left != ~0)\n\t\tvesafb_defined.left_margin = left;\n\tif (right != ~0)\n\t\tvesafb_defined.right_margin = right;\n\tif (upper != ~0)\n\t\tvesafb_defined.upper_margin = upper;\n\tif (lower != ~0)\n\t\tvesafb_defined.lower_margin = lower;\n\tif (xres)\n\t\tvesafb_defined.xres = xres;\n\tif (yres)\n\t\tvesafb_defined.yres = yres;\n\tif (sync != -1)\n\t\tvesafb_defined.sync = sync;\n\telse if (vesafb_defined.sync == ~0) {\n\t\tvesafb_defined.sync = 0;\n\t\tif (yres < 400)\n\t\t\tvesafb_defined.sync |= FB_SYNC_HOR_HIGH_ACT;\n\t\telse if (yres < 480)\n\t\t\tvesafb_defined.sync |= FB_SYNC_VERT_HIGH_ACT;\n\t}\n\n\t \n\t{\n\t\tunsigned int tmp;\n\n\t\tif (fv) {\n\t\t\ttmp = fv * (vesafb_defined.upper_margin + vesafb_defined.yres\n\t\t\t\t  + vesafb_defined.lower_margin + vesafb_defined.vsync_len);\n\t\t\tif ((tmp < fh) || (fh == 0)) fh = tmp;\n\t\t}\n\t\tif (fh) {\n\t\t\ttmp = fh * (vesafb_defined.left_margin + vesafb_defined.xres\n\t\t\t\t  + vesafb_defined.right_margin + vesafb_defined.hsync_len);\n\t\t\tif ((tmp < maxclk) || (maxclk == 0)) maxclk = tmp;\n\t\t}\n\t\ttmp = (maxclk + 499) / 500;\n\t\tif (tmp) {\n\t\t\ttmp = (2000000000 + tmp) / tmp;\n\t\t\tif (tmp > pixclock) pixclock = tmp;\n\t\t}\n\t}\n\tif (pixclock) {\n\t\tif (pixclock < 2000)\t\t \n\t\t\tpixclock = 4000;\t \n\t\tif (pixclock > 1000000)\n\t\t\tpixclock = 1000000;\t \n\t\tvesafb_defined.pixclock = pixclock;\n\t}\n\n\t \n#if defined(CONFIG_PPC_PMAC)\n#ifndef MODULE\n\tif (machine_is(powermac)) {\n\t\tstruct fb_var_screeninfo var;\n\n\t\tif (default_vmode <= 0 || default_vmode > VMODE_MAX)\n\t\t\tdefault_vmode = VMODE_640_480_60;\n#if defined(CONFIG_PPC32)\n\t\tif (IS_REACHABLE(CONFIG_NVRAM) && default_cmode == CMODE_NVRAM)\n\t\t\tdefault_cmode = nvram_read_byte(NV_CMODE);\n#endif\n\t\tif (default_cmode < CMODE_8 || default_cmode > CMODE_32)\n\t\t\tdefault_cmode = CMODE_8;\n\t\tif (!mac_vmode_to_var(default_vmode, default_cmode, &var)) {\n\t\t\tvar.accel_flags = vesafb_defined.accel_flags;\n\t\t\tvar.xoffset = var.yoffset = 0;\n\t\t\t \n\t\t\tvesafb_defined = var;\n\t\t}\n\t}\n#endif  \n#endif  \n\tvesafb_defined.xres_virtual = vesafb_defined.xres;\n\tif (nopan) {\n\t\tvesafb_defined.yres_virtual = vesafb_defined.yres;\n\t} else {\n\t\tvesafb_defined.yres_virtual = 65536;  \n\t}\n\tmatroxfb_init_fix(minfo);\n\tminfo->fbcon.screen_base = vaddr_va(minfo->video.vbase);\n\t \n\tmatroxfb_check_var(&vesafb_defined, &minfo->fbcon);\n\t \n\tminfo->fbcon.var = vesafb_defined;\n\terr = -EINVAL;\n\n\tprintk(KERN_INFO \"matroxfb: %dx%dx%dbpp (virtual: %dx%d)\\n\",\n\t\tvesafb_defined.xres, vesafb_defined.yres, vesafb_defined.bits_per_pixel,\n\t\tvesafb_defined.xres_virtual, vesafb_defined.yres_virtual);\n\tprintk(KERN_INFO \"matroxfb: framebuffer at 0x%lX, mapped to 0x%p, size %d\\n\",\n\t\tminfo->video.base, vaddr_va(minfo->video.vbase), minfo->video.len);\n\n \n\n\tminfo->fbcon.device = &minfo->pcidev->dev;\n\tif (register_framebuffer(&minfo->fbcon) < 0) {\n\t\tgoto failVideoIO;\n\t}\n\tfb_info(&minfo->fbcon, \"%s frame buffer device\\n\", minfo->fbcon.fix.id);\n\n\t \n\tif (!minfo->initialized) {\n\t\tfb_info(&minfo->fbcon, \"initializing hardware\\n\");\n\t\t \n\t\tvesafb_defined.activate |= FB_ACTIVATE_FORCE;\n\t\tfb_set_var(&minfo->fbcon, &vesafb_defined);\n\t}\n\n\treturn 0;\nfailVideoIO:;\n\tmatroxfb_g450_shutdown(minfo);\n\tiounmap(minfo->video.vbase.vaddr);\nfailCtrlIO:;\n\tiounmap(minfo->mmio.vbase.vaddr);\nfailVideoMR:;\n\trelease_mem_region(video_base_phys, minfo->video.len_maximum);\nfailCtrlMR:;\n\trelease_mem_region(ctrlptr_phys, 16384);\nfail:;\n\treturn err;\n}\n\nstatic LIST_HEAD(matroxfb_list);\nstatic LIST_HEAD(matroxfb_driver_list);\n\n#define matroxfb_l(x) list_entry(x, struct matrox_fb_info, next_fb)\n#define matroxfb_driver_l(x) list_entry(x, struct matroxfb_driver, node)\nint matroxfb_register_driver(struct matroxfb_driver* drv) {\n\tstruct matrox_fb_info* minfo;\n\n\tlist_add(&drv->node, &matroxfb_driver_list);\n\tlist_for_each_entry(minfo, &matroxfb_list, next_fb) {\n\t\tvoid* p;\n\n\t\tif (minfo->drivers_count == MATROXFB_MAX_FB_DRIVERS)\n\t\t\tcontinue;\n\t\tp = drv->probe(minfo);\n\t\tif (p) {\n\t\t\tminfo->drivers_data[minfo->drivers_count] = p;\n\t\t\tminfo->drivers[minfo->drivers_count++] = drv;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid matroxfb_unregister_driver(struct matroxfb_driver* drv) {\n\tstruct matrox_fb_info* minfo;\n\n\tlist_del(&drv->node);\n\tlist_for_each_entry(minfo, &matroxfb_list, next_fb) {\n\t\tint i;\n\n\t\tfor (i = 0; i < minfo->drivers_count; ) {\n\t\t\tif (minfo->drivers[i] == drv) {\n\t\t\t\tif (drv && drv->remove)\n\t\t\t\t\tdrv->remove(minfo, minfo->drivers_data[i]);\n\t\t\t\tminfo->drivers[i] = minfo->drivers[--minfo->drivers_count];\n\t\t\t\tminfo->drivers_data[i] = minfo->drivers_data[minfo->drivers_count];\n\t\t\t} else\n\t\t\t\ti++;\n\t\t}\n\t}\n}\n\nstatic void matroxfb_register_device(struct matrox_fb_info* minfo) {\n\tstruct matroxfb_driver* drv;\n\tint i = 0;\n\tlist_add(&minfo->next_fb, &matroxfb_list);\n\tfor (drv = matroxfb_driver_l(matroxfb_driver_list.next);\n\t     drv != matroxfb_driver_l(&matroxfb_driver_list);\n\t     drv = matroxfb_driver_l(drv->node.next)) {\n\t\tif (drv->probe) {\n\t\t\tvoid *p = drv->probe(minfo);\n\t\t\tif (p) {\n\t\t\t\tminfo->drivers_data[i] = p;\n\t\t\t\tminfo->drivers[i++] = drv;\n\t\t\t\tif (i == MATROXFB_MAX_FB_DRIVERS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tminfo->drivers_count = i;\n}\n\nstatic void matroxfb_unregister_device(struct matrox_fb_info* minfo) {\n\tint i;\n\n\tlist_del(&minfo->next_fb);\n\tfor (i = 0; i < minfo->drivers_count; i++) {\n\t\tstruct matroxfb_driver* drv = minfo->drivers[i];\n\n\t\tif (drv && drv->remove)\n\t\t\tdrv->remove(minfo, minfo->drivers_data[i]);\n\t}\n}\n\nstatic int matroxfb_probe(struct pci_dev* pdev, const struct pci_device_id* dummy) {\n\tstruct board* b;\n\tu_int16_t svid;\n\tu_int16_t sid;\n\tstruct matrox_fb_info* minfo;\n\tint err;\n\tu_int32_t cmd;\n\tDBG(__func__)\n\n\terr = aperture_remove_conflicting_pci_devices(pdev, \"matroxfb\");\n\tif (err)\n\t\treturn err;\n\n\tsvid = pdev->subsystem_vendor;\n\tsid = pdev->subsystem_device;\n\tfor (b = dev_list; b->vendor; b++) {\n\t\tif ((b->vendor != pdev->vendor) || (b->device != pdev->device) || (b->rev < pdev->revision)) continue;\n\t\tif (b->svid)\n\t\t\tif ((b->svid != svid) || (b->sid != sid)) continue;\n\t\tbreak;\n\t}\n\t \n\tif (!b->vendor)\n\t\treturn -ENODEV;\n\tif (dev > 0) {\n\t\t \n\t\tdev--;\n\t\treturn -ENODEV;\n\t}\n\tpci_read_config_dword(pdev, PCI_COMMAND, &cmd);\n\tif (pci_enable_device(pdev)) {\n\t\treturn -1;\n\t}\n\n\tminfo = kzalloc(sizeof(*minfo), GFP_KERNEL);\n\tif (!minfo)\n\t\treturn -ENOMEM;\n\n\tminfo->pcidev = pdev;\n\tminfo->dead = 0;\n\tminfo->usecount = 0;\n\tminfo->userusecount = 0;\n\n\tpci_set_drvdata(pdev, minfo);\n\t \n\tminfo->devflags.memtype = memtype;\n\tif (memtype != -1)\n\t\tnoinit = 0;\n\tif (cmd & PCI_COMMAND_MEMORY) {\n\t\tminfo->devflags.novga = novga;\n\t\tminfo->devflags.nobios = nobios;\n\t\tminfo->devflags.noinit = noinit;\n\t\t \n\t\tnovga = 1;\n\t\tnobios = 1;\n\t\tnoinit = 0;\n\t} else {\n\t\tminfo->devflags.novga = 1;\n\t\tminfo->devflags.nobios = 1;\n\t\tminfo->devflags.noinit = 0;\n\t}\n\n\tminfo->devflags.nopciretry = no_pci_retry;\n\tminfo->devflags.mga_24bpp_fix = inv24;\n\tminfo->devflags.precise_width = option_precise_width;\n\tminfo->devflags.sgram = sgram;\n\tminfo->capable.cross4MB = cross4MB;\n\n\tspin_lock_init(&minfo->lock.DAC);\n\tspin_lock_init(&minfo->lock.accel);\n\tinit_rwsem(&minfo->crtc2.lock);\n\tinit_rwsem(&minfo->altout.lock);\n\tmutex_init(&minfo->fbcon.mm_lock);\n\tminfo->irq_flags = 0;\n\tinit_waitqueue_head(&minfo->crtc1.vsync.wait);\n\tinit_waitqueue_head(&minfo->crtc2.vsync.wait);\n\tminfo->crtc1.panpos = -1;\n\n\terr = initMatrox2(minfo, b);\n\tif (!err) {\n\t\tmatroxfb_register_device(minfo);\n\t\treturn 0;\n\t}\n\tkfree(minfo);\n\treturn -1;\n}\n\nstatic void pci_remove_matrox(struct pci_dev* pdev) {\n\tstruct matrox_fb_info* minfo;\n\n\tminfo = pci_get_drvdata(pdev);\n\tmatroxfb_remove(minfo, 1);\n}\n\nstatic const struct pci_device_id matroxfb_devices[] = {\n#ifdef CONFIG_FB_MATROX_MILLENIUM\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_MIL,\n\t\tPCI_ANY_ID,\tPCI_ANY_ID,\t0, 0, 0},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_MIL_2,\n\t\tPCI_ANY_ID,\tPCI_ANY_ID,\t0, 0, 0},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_MIL_2_AGP,\n\t\tPCI_ANY_ID,\tPCI_ANY_ID,\t0, 0, 0},\n#endif\n#ifdef CONFIG_FB_MATROX_MYSTIQUE\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_MYS,\n\t\tPCI_ANY_ID,\tPCI_ANY_ID,\t0, 0, 0},\n#endif\n#ifdef CONFIG_FB_MATROX_G\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G100_MM,\n\t\tPCI_ANY_ID,\tPCI_ANY_ID,\t0, 0, 0},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G100_AGP,\n\t\tPCI_ANY_ID,\tPCI_ANY_ID,\t0, 0, 0},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G200_PCI,\n\t\tPCI_ANY_ID,\tPCI_ANY_ID,\t0, 0, 0},\n\t{PCI_VENDOR_ID_MATROX,\t0x0532,\n\t\tPCI_ANY_ID,\tPCI_ANY_ID,\t0, 0, 0},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G200_AGP,\n\t\tPCI_ANY_ID,\tPCI_ANY_ID,\t0, 0, 0},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G400,\n\t\tPCI_ANY_ID,\tPCI_ANY_ID,\t0, 0, 0},\n\t{PCI_VENDOR_ID_MATROX,\tPCI_DEVICE_ID_MATROX_G550,\n\t\tPCI_ANY_ID,\tPCI_ANY_ID,\t0, 0, 0},\n#endif\n\t{0,\t\t\t0,\n\t\t0,\t\t0,\t\t0, 0, 0}\n};\n\nMODULE_DEVICE_TABLE(pci, matroxfb_devices);\n\n\nstatic struct pci_driver matroxfb_driver = {\n\t.name =\t\t\"matroxfb\",\n\t.id_table =\tmatroxfb_devices,\n\t.probe =\tmatroxfb_probe,\n\t.remove =\tpci_remove_matrox,\n};\n\n \n\n#define RSResolution(X)\t((X) & 0x0F)\n#define RS640x400\t1\n#define RS640x480\t2\n#define RS800x600\t3\n#define RS1024x768\t4\n#define RS1280x1024\t5\n#define RS1600x1200\t6\n#define RS768x576\t7\n#define RS960x720\t8\n#define RS1152x864\t9\n#define RS1408x1056\t10\n#define RS640x350\t11\n#define RS1056x344\t12\t \n#define RS1056x400\t13\t \n#define RS1056x480\t14\t \n#define RSNoxNo\t\t15\n \nstatic struct { int xres, yres, left, right, upper, lower, hslen, vslen, vfreq; } timmings[] __initdata = {\n\t{  640,  400,  48, 16, 39,  8,  96, 2, 70 },\n\t{  640,  480,  48, 16, 33, 10,  96, 2, 60 },\n\t{  800,  600, 144, 24, 28,  8, 112, 6, 60 },\n\t{ 1024,  768, 160, 32, 30,  4, 128, 4, 60 },\n\t{ 1280, 1024, 224, 32, 32,  4, 136, 4, 60 },\n\t{ 1600, 1200, 272, 48, 32,  5, 152, 5, 60 },\n\t{  768,  576, 144, 16, 28,  6, 112, 4, 60 },\n\t{  960,  720, 144, 24, 28,  8, 112, 4, 60 },\n\t{ 1152,  864, 192, 32, 30,  4, 128, 4, 60 },\n\t{ 1408, 1056, 256, 40, 32,  5, 144, 5, 60 },\n\t{  640,  350,  48, 16, 39,  8,  96, 2, 70 },\n\t{ 1056,  344,  96, 24, 59, 44, 160, 2, 70 },\n\t{ 1056,  400,  96, 24, 39,  8, 160, 2, 70 },\n\t{ 1056,  480,  96, 24, 36, 12, 160, 3, 60 },\n\t{    0,    0,  ~0, ~0, ~0, ~0,   0, 0,  0 }\n};\n\n#define RSCreate(X,Y)\t((X) | ((Y) << 8))\nstatic struct { unsigned int vesa; unsigned int info; } *RSptr, vesamap[] __initdata = {\n \n\t{    ~0, RSCreate(RSNoxNo,     RS8bpp ) },\n\t{ 0x101, RSCreate(RS640x480,   RS8bpp ) },\n\t{ 0x100, RSCreate(RS640x400,   RS8bpp ) },\n\t{ 0x180, RSCreate(RS768x576,   RS8bpp ) },\n\t{ 0x103, RSCreate(RS800x600,   RS8bpp ) },\n\t{ 0x188, RSCreate(RS960x720,   RS8bpp ) },\n\t{ 0x105, RSCreate(RS1024x768,  RS8bpp ) },\n\t{ 0x190, RSCreate(RS1152x864,  RS8bpp ) },\n\t{ 0x107, RSCreate(RS1280x1024, RS8bpp ) },\n\t{ 0x198, RSCreate(RS1408x1056, RS8bpp ) },\n\t{ 0x11C, RSCreate(RS1600x1200, RS8bpp ) },\n\t{ 0x110, RSCreate(RS640x480,   RS15bpp) },\n\t{ 0x181, RSCreate(RS768x576,   RS15bpp) },\n\t{ 0x113, RSCreate(RS800x600,   RS15bpp) },\n\t{ 0x189, RSCreate(RS960x720,   RS15bpp) },\n\t{ 0x116, RSCreate(RS1024x768,  RS15bpp) },\n\t{ 0x191, RSCreate(RS1152x864,  RS15bpp) },\n\t{ 0x119, RSCreate(RS1280x1024, RS15bpp) },\n\t{ 0x199, RSCreate(RS1408x1056, RS15bpp) },\n\t{ 0x11D, RSCreate(RS1600x1200, RS15bpp) },\n\t{ 0x111, RSCreate(RS640x480,   RS16bpp) },\n\t{ 0x182, RSCreate(RS768x576,   RS16bpp) },\n\t{ 0x114, RSCreate(RS800x600,   RS16bpp) },\n\t{ 0x18A, RSCreate(RS960x720,   RS16bpp) },\n\t{ 0x117, RSCreate(RS1024x768,  RS16bpp) },\n\t{ 0x192, RSCreate(RS1152x864,  RS16bpp) },\n\t{ 0x11A, RSCreate(RS1280x1024, RS16bpp) },\n\t{ 0x19A, RSCreate(RS1408x1056, RS16bpp) },\n\t{ 0x11E, RSCreate(RS1600x1200, RS16bpp) },\n\t{ 0x1B2, RSCreate(RS640x480,   RS24bpp) },\n\t{ 0x184, RSCreate(RS768x576,   RS24bpp) },\n\t{ 0x1B5, RSCreate(RS800x600,   RS24bpp) },\n\t{ 0x18C, RSCreate(RS960x720,   RS24bpp) },\n\t{ 0x1B8, RSCreate(RS1024x768,  RS24bpp) },\n\t{ 0x194, RSCreate(RS1152x864,  RS24bpp) },\n\t{ 0x1BB, RSCreate(RS1280x1024, RS24bpp) },\n\t{ 0x19C, RSCreate(RS1408x1056, RS24bpp) },\n\t{ 0x1BF, RSCreate(RS1600x1200, RS24bpp) },\n\t{ 0x112, RSCreate(RS640x480,   RS32bpp) },\n\t{ 0x183, RSCreate(RS768x576,   RS32bpp) },\n\t{ 0x115, RSCreate(RS800x600,   RS32bpp) },\n\t{ 0x18B, RSCreate(RS960x720,   RS32bpp) },\n\t{ 0x118, RSCreate(RS1024x768,  RS32bpp) },\n\t{ 0x193, RSCreate(RS1152x864,  RS32bpp) },\n\t{ 0x11B, RSCreate(RS1280x1024, RS32bpp) },\n\t{ 0x19B, RSCreate(RS1408x1056, RS32bpp) },\n\t{ 0x11F, RSCreate(RS1600x1200, RS32bpp) },\n\t{ 0x010, RSCreate(RS640x350,   RS4bpp ) },\n\t{ 0x012, RSCreate(RS640x480,   RS4bpp ) },\n\t{ 0x102, RSCreate(RS800x600,   RS4bpp ) },\n\t{ 0x104, RSCreate(RS1024x768,  RS4bpp ) },\n\t{ 0x106, RSCreate(RS1280x1024, RS4bpp ) },\n\t{     0, 0\t\t\t\t}};\n\nstatic void __init matroxfb_init_params(void) {\n\t \n\tif (fh < 1000)\n\t\tfh *= 1000;\t \n\t \n\tif (maxclk < 1000) maxclk *= 1000;\t \n\tif (maxclk < 1000000) maxclk *= 1000;\t \n\t \n\tif (vesa != ~0)\n\t\tvesa &= 0x1DFF;\t\t \n\n\t \n\tfor (RSptr = vesamap; RSptr->vesa; RSptr++) {\n\t\tif (RSptr->vesa == vesa) break;\n\t}\n\tif (!RSptr->vesa) {\n\t\tprintk(KERN_ERR \"Invalid vesa mode 0x%04X\\n\", vesa);\n\t\tRSptr = vesamap;\n\t}\n\t{\n\t\tint res = RSResolution(RSptr->info)-1;\n\t\tif (left == ~0)\n\t\t\tleft = timmings[res].left;\n\t\tif (!xres)\n\t\t\txres = timmings[res].xres;\n\t\tif (right == ~0)\n\t\t\tright = timmings[res].right;\n\t\tif (!hslen)\n\t\t\thslen = timmings[res].hslen;\n\t\tif (upper == ~0)\n\t\t\tupper = timmings[res].upper;\n\t\tif (!yres)\n\t\t\tyres = timmings[res].yres;\n\t\tif (lower == ~0)\n\t\t\tlower = timmings[res].lower;\n\t\tif (!vslen)\n\t\t\tvslen = timmings[res].vslen;\n\t\tif (!(fv||fh||maxclk||pixclock))\n\t\t\tfv = timmings[res].vfreq;\n\t\tif (depth == -1)\n\t\t\tdepth = RSDepth(RSptr->info);\n\t}\n}\n\nstatic int __init matrox_init(void) {\n\tint err;\n\n\tif (fb_modesetting_disabled(\"matroxfb\"))\n\t\treturn -ENODEV;\n\n\tmatroxfb_init_params();\n\terr = pci_register_driver(&matroxfb_driver);\n\tdev = -1;\t \n\treturn err;\n}\n\n \n\nstatic void __exit matrox_done(void) {\n\tpci_unregister_driver(&matroxfb_driver);\n}\n\n#ifndef MODULE\n\n \n\nstatic int __init matroxfb_setup(char *options) {\n\tchar *this_opt;\n\n\tDBG(__func__)\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt) continue;\n\n\t\tdprintk(\"matroxfb_setup: option %s\\n\", this_opt);\n\n\t\tif (!strncmp(this_opt, \"dev:\", 4))\n\t\t\tdev = simple_strtoul(this_opt+4, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"depth:\", 6)) {\n\t\t\tswitch (simple_strtoul(this_opt+6, NULL, 0)) {\n\t\t\t\tcase 0: depth = RSText; break;\n\t\t\t\tcase 4: depth = RS4bpp; break;\n\t\t\t\tcase 8: depth = RS8bpp; break;\n\t\t\t\tcase 15:depth = RS15bpp; break;\n\t\t\t\tcase 16:depth = RS16bpp; break;\n\t\t\t\tcase 24:depth = RS24bpp; break;\n\t\t\t\tcase 32:depth = RS32bpp; break;\n\t\t\t\tdefault:\n\t\t\t\t\tprintk(KERN_ERR \"matroxfb: unsupported color depth\\n\");\n\t\t\t}\n\t\t} else if (!strncmp(this_opt, \"xres:\", 5))\n\t\t\txres = simple_strtoul(this_opt+5, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"yres:\", 5))\n\t\t\tyres = simple_strtoul(this_opt+5, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"vslen:\", 6))\n\t\t\tvslen = simple_strtoul(this_opt+6, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"hslen:\", 6))\n\t\t\thslen = simple_strtoul(this_opt+6, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"left:\", 5))\n\t\t\tleft = simple_strtoul(this_opt+5, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"right:\", 6))\n\t\t\tright = simple_strtoul(this_opt+6, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"upper:\", 6))\n\t\t\tupper = simple_strtoul(this_opt+6, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"lower:\", 6))\n\t\t\tlower = simple_strtoul(this_opt+6, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"pixclock:\", 9))\n\t\t\tpixclock = simple_strtoul(this_opt+9, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"sync:\", 5))\n\t\t\tsync = simple_strtoul(this_opt+5, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"vesa:\", 5))\n\t\t\tvesa = simple_strtoul(this_opt+5, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"maxclk:\", 7))\n\t\t\tmaxclk = simple_strtoul(this_opt+7, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"fh:\", 3))\n\t\t\tfh = simple_strtoul(this_opt+3, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"fv:\", 3))\n\t\t\tfv = simple_strtoul(this_opt+3, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"mem:\", 4))\n\t\t\tmem = simple_strtoul(this_opt+4, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"mode:\", 5))\n\t\t\tstrscpy(videomode, this_opt + 5, sizeof(videomode));\n\t\telse if (!strncmp(this_opt, \"outputs:\", 8))\n\t\t\tstrscpy(outputs, this_opt + 8, sizeof(outputs));\n\t\telse if (!strncmp(this_opt, \"dfp:\", 4)) {\n\t\t\tdfp_type = simple_strtoul(this_opt+4, NULL, 0);\n\t\t\tdfp = 1;\n\t\t}\n#ifdef CONFIG_PPC_PMAC\n\t\telse if (!strncmp(this_opt, \"vmode:\", 6)) {\n\t\t\tunsigned int vmode = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\tif (vmode > 0 && vmode <= VMODE_MAX)\n\t\t\t\tdefault_vmode = vmode;\n\t\t} else if (!strncmp(this_opt, \"cmode:\", 6)) {\n\t\t\tunsigned int cmode = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\tswitch (cmode) {\n\t\t\t\tcase 0:\n\t\t\t\tcase 8:\n\t\t\t\t\tdefault_cmode = CMODE_8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 15:\n\t\t\t\tcase 16:\n\t\t\t\t\tdefault_cmode = CMODE_16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\tcase 32:\n\t\t\t\t\tdefault_cmode = CMODE_32;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t\telse if (!strcmp(this_opt, \"disabled\"))\t \n\t\t\tdisabled = 1;\n\t\telse if (!strcmp(this_opt, \"enabled\"))\t \n\t\t\tdisabled = 0;\n\t\telse if (!strcmp(this_opt, \"sgram\"))\t \n\t\t\tsgram = 1;\n\t\telse if (!strcmp(this_opt, \"sdram\"))\n\t\t\tsgram = 0;\n\t\telse if (!strncmp(this_opt, \"memtype:\", 8))\n\t\t\tmemtype = simple_strtoul(this_opt+8, NULL, 0);\n\t\telse {\n\t\t\tint value = 1;\n\n\t\t\tif (!strncmp(this_opt, \"no\", 2)) {\n\t\t\t\tvalue = 0;\n\t\t\t\tthis_opt += 2;\n\t\t\t}\n\t\t\tif (! strcmp(this_opt, \"inverse\"))\n\t\t\t\tinverse = value;\n\t\t\telse if (!strcmp(this_opt, \"accel\"))\n\t\t\t\tnoaccel = !value;\n\t\t\telse if (!strcmp(this_opt, \"pan\"))\n\t\t\t\tnopan = !value;\n\t\t\telse if (!strcmp(this_opt, \"pciretry\"))\n\t\t\t\tno_pci_retry = !value;\n\t\t\telse if (!strcmp(this_opt, \"vga\"))\n\t\t\t\tnovga = !value;\n\t\t\telse if (!strcmp(this_opt, \"bios\"))\n\t\t\t\tnobios = !value;\n\t\t\telse if (!strcmp(this_opt, \"init\"))\n\t\t\t\tnoinit = !value;\n\t\t\telse if (!strcmp(this_opt, \"mtrr\"))\n\t\t\t\tmtrr = value;\n\t\t\telse if (!strcmp(this_opt, \"inv24\"))\n\t\t\t\tinv24 = value;\n\t\t\telse if (!strcmp(this_opt, \"cross4MB\"))\n\t\t\t\tcross4MB = value;\n\t\t\telse if (!strcmp(this_opt, \"grayscale\"))\n\t\t\t\tgrayscale = value;\n\t\t\telse if (!strcmp(this_opt, \"dfp\"))\n\t\t\t\tdfp = value;\n\t\t\telse {\n\t\t\t\tstrscpy(videomode, this_opt, sizeof(videomode));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int __initdata initialized = 0;\n\nstatic int __init matroxfb_init(void)\n{\n\tchar *option = NULL;\n\tint err = 0;\n\n\tDBG(__func__)\n\n\tif (fb_get_options(\"matroxfb\", &option))\n\t\treturn -ENODEV;\n\tmatroxfb_setup(option);\n\n\tif (disabled)\n\t\treturn -ENXIO;\n\tif (!initialized) {\n\t\tinitialized = 1;\n\t\terr = matrox_init();\n\t}\n\thotplug = 1;\n\t \n\treturn err;\n}\n\n#else\n\n \n\nMODULE_AUTHOR(\"(c) 1998-2002 Petr Vandrovec <vandrove@vc.cvut.cz>\");\nMODULE_DESCRIPTION(\"Accelerated FBDev driver for Matrox Millennium/Mystique/G100/G200/G400/G450/G550\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(mem, int, 0);\nMODULE_PARM_DESC(mem, \"Size of available memory in MB, KB or B (2,4,8,12,16MB, default=autodetect)\");\nmodule_param(disabled, int, 0);\nMODULE_PARM_DESC(disabled, \"Disabled (0 or 1=disabled) (default=0)\");\nmodule_param(noaccel, int, 0);\nMODULE_PARM_DESC(noaccel, \"Do not use accelerating engine (0 or 1=disabled) (default=0)\");\nmodule_param(nopan, int, 0);\nMODULE_PARM_DESC(nopan, \"Disable pan on startup (0 or 1=disabled) (default=0)\");\nmodule_param(no_pci_retry, int, 0);\nMODULE_PARM_DESC(no_pci_retry, \"PCI retries enabled (0 or 1=disabled) (default=0)\");\nmodule_param(novga, int, 0);\nMODULE_PARM_DESC(novga, \"VGA I/O (0x3C0-0x3DF) disabled (0 or 1=disabled) (default=0)\");\nmodule_param(nobios, int, 0);\nMODULE_PARM_DESC(nobios, \"Disables ROM BIOS (0 or 1=disabled) (default=do not change BIOS state)\");\nmodule_param(noinit, int, 0);\nMODULE_PARM_DESC(noinit, \"Disables W/SG/SD-RAM and bus interface initialization (0 or 1=do not initialize) (default=0)\");\nmodule_param(memtype, int, 0);\nMODULE_PARM_DESC(memtype, \"Memory type for G200/G400 (see Documentation/fb/matroxfb.rst for explanation) (default=3 for G200, 0 for G400)\");\nmodule_param(mtrr, int, 0);\nMODULE_PARM_DESC(mtrr, \"This speeds up video memory accesses (0=disabled or 1) (default=1)\");\nmodule_param(sgram, int, 0);\nMODULE_PARM_DESC(sgram, \"Indicates that G100/G200/G400 has SGRAM memory (0=SDRAM, 1=SGRAM) (default=0)\");\nmodule_param(inv24, int, 0);\nMODULE_PARM_DESC(inv24, \"Inverts clock polarity for 24bpp and loop frequency > 100MHz (default=do not invert polarity)\");\nmodule_param(inverse, int, 0);\nMODULE_PARM_DESC(inverse, \"Inverse (0 or 1) (default=0)\");\nmodule_param(dev, int, 0);\nMODULE_PARM_DESC(dev, \"Multihead support, attach to device ID (0..N) (default=all working)\");\nmodule_param(vesa, int, 0);\nMODULE_PARM_DESC(vesa, \"Startup videomode (0x000-0x1FF) (default=0x101)\");\nmodule_param(xres, int, 0);\nMODULE_PARM_DESC(xres, \"Horizontal resolution (px), overrides xres from vesa (default=vesa)\");\nmodule_param(yres, int, 0);\nMODULE_PARM_DESC(yres, \"Vertical resolution (scans), overrides yres from vesa (default=vesa)\");\nmodule_param(upper, int, 0);\nMODULE_PARM_DESC(upper, \"Upper blank space (scans), overrides upper from vesa (default=vesa)\");\nmodule_param(lower, int, 0);\nMODULE_PARM_DESC(lower, \"Lower blank space (scans), overrides lower from vesa (default=vesa)\");\nmodule_param(vslen, int, 0);\nMODULE_PARM_DESC(vslen, \"Vertical sync length (scans), overrides lower from vesa (default=vesa)\");\nmodule_param(left, int, 0);\nMODULE_PARM_DESC(left, \"Left blank space (px), overrides left from vesa (default=vesa)\");\nmodule_param(right, int, 0);\nMODULE_PARM_DESC(right, \"Right blank space (px), overrides right from vesa (default=vesa)\");\nmodule_param(hslen, int, 0);\nMODULE_PARM_DESC(hslen, \"Horizontal sync length (px), overrides hslen from vesa (default=vesa)\");\nmodule_param(pixclock, int, 0);\nMODULE_PARM_DESC(pixclock, \"Pixelclock (ns), overrides pixclock from vesa (default=vesa)\");\nmodule_param(sync, int, 0);\nMODULE_PARM_DESC(sync, \"Sync polarity, overrides sync from vesa (default=vesa)\");\nmodule_param(depth, int, 0);\nMODULE_PARM_DESC(depth, \"Color depth (0=text,8,15,16,24,32) (default=vesa)\");\nmodule_param(maxclk, int, 0);\nMODULE_PARM_DESC(maxclk, \"Startup maximal clock, 0-999MHz, 1000-999999kHz, 1000000-INF Hz\");\nmodule_param(fh, int, 0);\nMODULE_PARM_DESC(fh, \"Startup horizontal frequency, 0-999kHz, 1000-INF Hz\");\nmodule_param(fv, int, 0);\nMODULE_PARM_DESC(fv, \"Startup vertical frequency, 0-INF Hz\\n\"\n\"You should specify \\\"fv:max_monitor_vsync,fh:max_monitor_hsync,maxclk:max_monitor_dotclock\\\"\");\nmodule_param(grayscale, int, 0);\nMODULE_PARM_DESC(grayscale, \"Sets display into grayscale. Works perfectly with paletized videomode (4, 8bpp), some limitations apply to 16, 24 and 32bpp videomodes (default=nograyscale)\");\nmodule_param(cross4MB, int, 0);\nMODULE_PARM_DESC(cross4MB, \"Specifies that 4MB boundary can be in middle of line. (default=autodetected)\");\nmodule_param(dfp, int, 0);\nMODULE_PARM_DESC(dfp, \"Specifies whether to use digital flat panel interface of G200/G400 (0 or 1) (default=0)\");\nmodule_param(dfp_type, int, 0);\nMODULE_PARM_DESC(dfp_type, \"Specifies DFP interface type (0 to 255) (default=read from hardware)\");\nmodule_param_string(outputs, outputs, sizeof(outputs), 0);\nMODULE_PARM_DESC(outputs, \"Specifies which CRTC is mapped to which output (string of up to three letters, consisting of 0 (disabled), 1 (CRTC1), 2 (CRTC2)) (default=111 for Gx50, 101 for G200/G400 with DFP, and 100 for all other devices)\");\n#ifdef CONFIG_PPC_PMAC\nmodule_param_named(vmode, default_vmode, int, 0);\nMODULE_PARM_DESC(vmode, \"Specify the vmode mode number that should be used (640x480 default)\");\nmodule_param_named(cmode, default_cmode, int, 0);\nMODULE_PARM_DESC(cmode, \"Specify the video depth that should be used (8bit default)\");\n#endif\n\nstatic int __init matroxfb_init(void){\n\n\tDBG(__func__)\n\n\tif (disabled)\n\t\treturn -ENXIO;\n\n\tif (depth == 0)\n\t\tdepth = RSText;\n\telse if (depth == 4)\n\t\tdepth = RS4bpp;\n\telse if (depth == 8)\n\t\tdepth = RS8bpp;\n\telse if (depth == 15)\n\t\tdepth = RS15bpp;\n\telse if (depth == 16)\n\t\tdepth = RS16bpp;\n\telse if (depth == 24)\n\t\tdepth = RS24bpp;\n\telse if (depth == 32)\n\t\tdepth = RS32bpp;\n\telse if (depth != -1) {\n\t\tprintk(KERN_ERR \"matroxfb: depth %d is not supported, using default\\n\", depth);\n\t\tdepth = -1;\n\t}\n\tmatrox_init();\n\t \n\treturn 0;\n}\n#endif\t \n\nmodule_init(matroxfb_init);\nmodule_exit(matrox_done);\nEXPORT_SYMBOL(matroxfb_register_driver);\nEXPORT_SYMBOL(matroxfb_unregister_driver);\nEXPORT_SYMBOL(matroxfb_wait_for_sync);\nEXPORT_SYMBOL(matroxfb_enable_irq);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}