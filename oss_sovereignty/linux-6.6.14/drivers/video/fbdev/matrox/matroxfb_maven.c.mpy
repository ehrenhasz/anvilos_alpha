{
  "module_name": "matroxfb_maven.c",
  "hash_id": "6d338f66882cbf65dfe9f22fa2c7bb36484cc6c1c6cc8c7522c5c550f474b228",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/matrox/matroxfb_maven.c",
  "human_readable_source": "\n \n\n#include \"matroxfb_maven.h\"\n#include \"matroxfb_misc.h\"\n#include \"matroxfb_DAC1064.h\"\n#include <linux/i2c.h>\n#include <linux/matroxfb.h>\n#include <linux/slab.h>\n#include <asm/div64.h>\n\n#define MGATVO_B\t1\n#define MGATVO_C\t2\n\nstatic const struct maven_gamma {\n  unsigned char reg83;\n  unsigned char reg84;\n  unsigned char reg85;\n  unsigned char reg86;\n  unsigned char reg87;\n  unsigned char reg88;\n  unsigned char reg89;\n  unsigned char reg8a;\n  unsigned char reg8b;\n} maven_gamma[] = {\n  { 131, 57, 223, 15, 117, 212, 251, 91, 156},\n  { 133, 61, 128, 63, 180, 147, 195, 100, 180},\n  { 131, 19, 63, 31, 50, 66, 171, 64, 176},\n  { 0, 0, 0, 31, 16, 16, 16, 100, 200},\n  { 8, 23, 47, 73, 147, 244, 220, 80, 195},\n  { 22, 43, 64, 80, 147, 115, 58, 85, 168},\n  { 34, 60, 80, 214, 147, 212, 188, 85, 167},\n  { 45, 77, 96, 216, 147, 99, 91, 85, 159},\n  { 56, 76, 112, 107, 147, 212, 148, 64, 144},\n  { 65, 91, 128, 137, 147, 196, 17, 69, 148},\n  { 72, 104, 136, 138, 147, 180, 245, 73, 147},\n  { 87, 116, 143, 126, 16, 83, 229, 77, 144},\n  { 95, 119, 152, 254, 244, 83, 221, 77, 151},\n  { 100, 129, 159, 156, 244, 148, 197, 77, 160},\n  { 105, 141, 167, 247, 244, 132, 181, 84, 166},\n  { 105, 147, 168, 247, 244, 245, 181, 90, 170},\n  { 120, 153, 175, 248, 212, 229, 165, 90, 180},\n  { 119, 156, 176, 248, 244, 229, 84, 74, 160},\n  { 119, 158, 183, 248, 244, 229, 149, 78, 165}\n};\n\n \nstruct mctl {\n\tstruct v4l2_queryctrl desc;\n\tsize_t control;\n};\n\n#define BLMIN\t0x0FF\n#define WLMAX\t0x3FF\n\nstatic const struct mctl maven_controls[] =\n{\t{ { V4L2_CID_BRIGHTNESS, V4L2_CTRL_TYPE_INTEGER,\n\t  \"brightness\",\n\t  0, WLMAX - BLMIN, 1, 379 - BLMIN, \n\t  0,\n\t}, offsetof(struct matrox_fb_info, altout.tvo_params.brightness) },\n\t{ { V4L2_CID_CONTRAST, V4L2_CTRL_TYPE_INTEGER,\n\t  \"contrast\",\n\t  0, 1023, 1, 127,\n\t  0,\n\t}, offsetof(struct matrox_fb_info, altout.tvo_params.contrast) },\n\t{ { V4L2_CID_SATURATION, V4L2_CTRL_TYPE_INTEGER,\n\t  \"saturation\",\n\t  0, 255, 1, 155,\n\t  0,\n\t}, offsetof(struct matrox_fb_info, altout.tvo_params.saturation) },\n\t{ { V4L2_CID_HUE, V4L2_CTRL_TYPE_INTEGER,\n\t  \"hue\",\n\t  0, 255, 1, 0,\n\t  0,\n\t}, offsetof(struct matrox_fb_info, altout.tvo_params.hue) },\n\t{ { V4L2_CID_GAMMA, V4L2_CTRL_TYPE_INTEGER,\n\t  \"gamma\",\n\t  0, ARRAY_SIZE(maven_gamma) - 1, 1, 3,\n\t  0,\n\t}, offsetof(struct matrox_fb_info, altout.tvo_params.gamma) },\n\t{ { MATROXFB_CID_TESTOUT, V4L2_CTRL_TYPE_BOOLEAN,\n\t  \"test output\",\n\t  0, 1, 1, 0,\n\t  0,\n\t}, offsetof(struct matrox_fb_info, altout.tvo_params.testout) },\n\t{ { MATROXFB_CID_DEFLICKER, V4L2_CTRL_TYPE_INTEGER,\n\t  \"deflicker mode\",\n\t  0, 2, 1, 0,\n\t  0,\n\t}, offsetof(struct matrox_fb_info, altout.tvo_params.deflicker) },\n\n};\n\n#define MAVCTRLS ARRAY_SIZE(maven_controls)\n\n \nstatic int get_ctrl_id(__u32 v4l2_id) {\n\tint i;\n\n\tfor (i = 0; i < MAVCTRLS; i++) {\n\t\tif (v4l2_id < maven_controls[i].desc.id) {\n\t\t\tif (maven_controls[i].desc.id == 0x08000000) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (v4l2_id == maven_controls[i].desc.id) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstruct maven_data {\n\tstruct matrox_fb_info*\t\tprimary_head;\n\tstruct i2c_client\t\t*client;\n\tint\t\t\t\tversion;\n};\n\nstatic int* get_ctrl_ptr(struct maven_data* md, int idx) {\n\treturn (int*)((char*)(md->primary_head) + maven_controls[idx].control);\n}\n\nstatic int maven_get_reg(struct i2c_client* c, char reg) {\n\tchar dst;\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = c->addr,\n\t\t\t.flags = I2C_M_REV_DIR_ADDR,\n\t\t\t.len = sizeof(reg),\n\t\t\t.buf = &reg\n\t\t},\n\t\t{\n\t\t\t.addr = c->addr,\n\t\t\t.flags = I2C_M_RD | I2C_M_NOSTART,\n\t\t\t.len = sizeof(dst),\n\t\t\t.buf = &dst\n\t\t}\n\t};\n\ts32 err;\n\n\terr = i2c_transfer(c->adapter, msgs, 2);\n\tif (err < 0)\n\t\tprintk(KERN_INFO \"ReadReg(%d) failed\\n\", reg);\n\treturn dst & 0xFF;\n}\n\nstatic int maven_set_reg(struct i2c_client* c, int reg, int val) {\n\ts32 err;\n\n\terr = i2c_smbus_write_byte_data(c, reg, val);\n\tif (err)\n\t\tprintk(KERN_INFO \"WriteReg(%d) failed\\n\", reg);\n\treturn err;\n}\n\nstatic int maven_set_reg_pair(struct i2c_client* c, int reg, int val) {\n\ts32 err;\n\n\terr = i2c_smbus_write_word_data(c, reg, val);\n\tif (err)\n\t\tprintk(KERN_INFO \"WriteRegPair(%d) failed\\n\", reg);\n\treturn err;\n}\n\nstatic const struct matrox_pll_features maven_pll = {\n\t50000,\n\t27000,\n\t4, 127,\n\t2, 31,\n\t3\n};\n\nstruct matrox_pll_features2 {\n\tunsigned int\tvco_freq_min;\n\tunsigned int\tvco_freq_max;\n\tunsigned int\tfeed_div_min;\n\tunsigned int\tfeed_div_max;\n\tunsigned int\tin_div_min;\n\tunsigned int\tin_div_max;\n\tunsigned int\tpost_shift_max;\n};\n\nstruct matrox_pll_ctl {\n\tunsigned int\tref_freq;\n\tunsigned int\tden;\n};\n\nstatic const struct matrox_pll_features2 maven1000_pll = {\n\t.vco_freq_min = 50000000,\n\t.vco_freq_max = 300000000,\n\t.feed_div_min = 5,\n\t.feed_div_max = 128,\n\t.in_div_min = 3,\n\t.in_div_max = 32,\n\t.post_shift_max = 3\n};\n\nstatic const struct matrox_pll_ctl maven_PAL = {\n\t.ref_freq = 540000,\n\t.den = 50\n};\n\nstatic const struct matrox_pll_ctl maven_NTSC = {\n\t.ref_freq = 450450,\t \n\t.den = 60\n};\n\nstatic int matroxfb_PLL_mavenclock(const struct matrox_pll_features2* pll,\n\t\tconst struct matrox_pll_ctl* ctl,\n\t\tunsigned int htotal, unsigned int vtotal,\n\t\tunsigned int* in, unsigned int* feed, unsigned int* post,\n\t\tunsigned int* h2) {\n\tunsigned int besth2 = 0;\n\tunsigned int fxtal = ctl->ref_freq;\n\tunsigned int fmin = pll->vco_freq_min / ctl->den;\n\tunsigned int fwant;\n\tunsigned int p;\n\tunsigned int scrlen;\n\tunsigned int fmax;\n\n\tDBG(__func__)\n\n\tscrlen = htotal * (vtotal - 1);\n\tfwant = htotal * vtotal;\n\tfmax = pll->vco_freq_max / ctl->den;\n\n\tdprintk(KERN_DEBUG \"want: %u, xtal: %u, h: %u, v: %u, fmax: %u\\n\",\n\t\tfwant, fxtal, htotal, vtotal, fmax);\n\tfor (p = 1; p <= pll->post_shift_max; p++) {\n\t\tif (fwant * 2 > fmax)\n\t\t\tbreak;\n\t\tfwant *= 2;\n\t}\n\tif (fwant > fmax)\n\t\treturn 0;\n\tfor (; p-- > 0; fwant >>= 1) {\n\t\tunsigned int m;\n\n\t\tif (fwant < fmin) break;\n\t\tfor (m = pll->in_div_min; m <= pll->in_div_max; m++) {\n\t\t\tunsigned int n;\n\t\t\tunsigned int dvd;\n\t\t\tunsigned int ln;\n\n\t\t\tn = (fwant * m) / fxtal;\n\t\t\tif (n < pll->feed_div_min)\n\t\t\t\tcontinue;\n\t\t\tif (n > pll->feed_div_max)\n\t\t\t\tbreak;\n\n\t\t\tln = fxtal * n;\n\t\t\tdvd = m << p;\n\n\t\t\tif (ln % dvd)\n\t\t\t\tcontinue;\n\t\t\tln = ln / dvd;\n\n\t\t\tif (ln < scrlen + 2)\n\t\t\t\tcontinue;\n\t\t\tln = ln - scrlen;\n\t\t\tif (ln > htotal)\n\t\t\t\tcontinue;\n\t\t\tdprintk(KERN_DEBUG \"Match: %u / %u / %u / %u\\n\", n, m, p, ln);\n\t\t\tif (ln > besth2) {\n\t\t\t\tdprintk(KERN_DEBUG \"Better...\\n\");\n\t\t\t\t*h2 = besth2 = ln;\n\t\t\t\t*post = p;\n\t\t\t\t*in = m;\n\t\t\t\t*feed = n;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (besth2 < 2)\n\t\treturn 0;\n\n\tdprintk(KERN_ERR \"clk: %02X %02X %02X %d %d\\n\", *in, *feed, *post, fxtal, fwant);\n\treturn fxtal * (*feed) / (*in) * ctl->den;\n}\n\nstatic int matroxfb_mavenclock(const struct matrox_pll_ctl *ctl,\n\t\tunsigned int htotal, unsigned int vtotal,\n\t\tunsigned int* in, unsigned int* feed, unsigned int* post,\n\t\tunsigned int* htotal2) {\n\tunsigned int fvco;\n\tunsigned int p;\n\n\tfvco = matroxfb_PLL_mavenclock(&maven1000_pll, ctl, htotal, vtotal, in, feed, &p, htotal2);\n\tif (!fvco)\n\t\treturn -EINVAL;\n\tp = (1 << p) - 1;\n\tif (fvco <= 100000000)\n\t\t;\n\telse if (fvco <= 140000000)\n\t\tp |= 0x08;\n\telse if (fvco <= 180000000)\n\t\tp |= 0x10;\n\telse\n\t\tp |= 0x18;\n\t*post = p;\n\treturn 0;\n}\n\nstatic void DAC1064_calcclock(unsigned int freq, unsigned int fmax,\n\t\tunsigned int* in, unsigned int* feed, unsigned int* post) {\n\tunsigned int fvco;\n\tunsigned int p;\n\n\tfvco = matroxfb_PLL_calcclock(&maven_pll, freq, fmax, in, feed, &p);\n\tp = (1 << p) - 1;\n\tif (fvco <= 100000)\n\t\t;\n\telse if (fvco <= 140000)\n\t\tp |= 0x08;\n\telse if (fvco <= 180000)\n\t\tp |= 0x10;\n\telse\n\t\tp |= 0x18;\n\t*post = p;\n\treturn;\n}\n\nstatic unsigned char maven_compute_deflicker (const struct maven_data* md) {\n\tunsigned char df;\n\t\n\tdf = (md->version == MGATVO_B?0x40:0x00);\n\tswitch (md->primary_head->altout.tvo_params.deflicker) {\n\t\tcase 0:\n \n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdf |= 0xB1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdf |= 0xA2;\n\t\t\tbreak;\n\t}\n\treturn df;\n}\n\nstatic void maven_compute_bwlevel (const struct maven_data* md,\n\t\t\t\t   int *bl, int *wl) {\n\tconst int b = md->primary_head->altout.tvo_params.brightness + BLMIN;\n\tconst int c = md->primary_head->altout.tvo_params.contrast;\n\n\t*bl = max(b - c, BLMIN);\n\t*wl = min(b + c, WLMAX);\n}\n\nstatic const struct maven_gamma* maven_compute_gamma (const struct maven_data* md) {\n \treturn maven_gamma + md->primary_head->altout.tvo_params.gamma;\n}\n\n\nstatic void maven_init_TVdata(const struct maven_data* md, struct mavenregs* data) {\n\tstatic struct mavenregs palregs = { {\n\t\t0x2A, 0x09, 0x8A, 0xCB,\t \n\t\t0x00,\n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x7E,\t \n\t\t0x44,\t \n\t\t0x9C,\t \n\t\t0x2E,\t \n\t\t0x21,\t \n\t\t0x00,\t \n\t\t0x3F, 0x03,  \n\t\t0x3F, 0x03,  \n\t\t0x1A,\t \n\t\t0x2A,\t \n\t\t0x1C, 0x3D, 0x14,  \n\t\t0x9C, 0x01,  \n\t\t0x00,\t \n\t\t0xFE,\t \n\t\t0x7E,\t \n\t\t0x60,\t \n\t\t0x05,\t \n\t\t0x89, 0x03,  \n\t\t0x72,\t \n\t\t0x07,\t \n\t\t0x72,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x08,\t \n\t\t0x04,\t \n\t\t0x00,\t \n\t\t0x1A,\t \n\t\t0x55, 0x01,  \n\t\t0x26,\t \n\t\t0x07, 0x7E,  \n\t\t0x02, 0x54,  \n\t\t0xB0, 0x00,  \n\t\t0x14,\t \n\t\t0x49,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0xA3,\t \n\t\t0xC8,\t \n\t\t0x22,\t \n\t\t0x02,\t \n\t\t0x22,\t \n\t\t0x3F, 0x03,  \n\t\t0x00,\t \n\t\t0x00,\t \n\t}, MATROXFB_OUTPUT_MODE_PAL, 625, 50 };\n\tstatic struct mavenregs ntscregs = { {\n\t\t0x21, 0xF0, 0x7C, 0x1F,\t \n\t\t0x00,\n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x7E,\t \n\t\t0x43,\t \n\t\t0x7E,\t \n\t\t0x3D,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x41, 0x00,  \n\t\t0x3C, 0x00,  \n\t\t0x17,\t \n\t\t0x21,\t \n\t\t0x1B, 0x1B, 0x24,  \n\t\t0x83, 0x01,  \n\t\t0x00,\t \n\t\t0x0F,\t \n\t\t0x0F,\t \n\t\t0x60,\t \n\t\t0x05,\t \n\t\t0x89, 0x02,  \n\t\t0x5F,\t \n\t\t0x04,\t \n\t\t0x5F,\t \n\t\t0x01,\t \n\t\t0x02,\t \n\t\t0x00,\t \n\t\t0x0A,\t \n\t\t0x05,\t \n\t\t0x00,\t \n\t\t0x10,\t \n\t\t0xFF, 0x03,  \n\t\t0x24,\t \n\t\t0x0F, 0x78,  \n\t\t0x00, 0x00,  \n\t\t0xB2, 0x04,  \n\t\t0x14,\t \n\t\t0x02,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0xA3,\t \n\t\t0xC8,\t \n\t\t0x15,\t \n\t\t0x05,\t \n\t\t0x3B,\t \n\t\t0x3C, 0x00,  \n\t\t0x00,\t \n\t\t0x00,\t \n\t}, MATROXFB_OUTPUT_MODE_NTSC, 525, 60 };\n\tstruct matrox_fb_info *minfo = md->primary_head;\n\n\tif (minfo->outputs[1].mode == MATROXFB_OUTPUT_MODE_PAL)\n\t\t*data = palregs;\n\telse\n\t\t*data = ntscregs;\n\n\t \n\tdata->regs[0x93] = maven_compute_deflicker(md);\n \n\t \n\t{\n\t\tconst struct maven_gamma* g;\n\t\tg = maven_compute_gamma(md);\n\t\tdata->regs[0x83] = g->reg83;\n\t\tdata->regs[0x84] = g->reg84;\n\t\tdata->regs[0x85] = g->reg85;\n\t\tdata->regs[0x86] = g->reg86;\n\t\tdata->regs[0x87] = g->reg87;\n\t\tdata->regs[0x88] = g->reg88;\n\t\tdata->regs[0x89] = g->reg89;\n\t\tdata->regs[0x8A] = g->reg8a;\n\t\tdata->regs[0x8B] = g->reg8b;\n\t}\n \n\t \n\t{\n\t\tint bl, wl;\n\t\tmaven_compute_bwlevel (md, &bl, &wl);\n\t\tdata->regs[0x0e] = bl >> 2;\n\t\tdata->regs[0x0f] = bl & 3;\n\t\tdata->regs[0x1e] = wl >> 2;\n\t\tdata->regs[0x1f] = wl & 3;\n\t}\n\n\t \n\t{\n\t\tdata->regs[0x20] =\n\t\tdata->regs[0x22] = minfo->altout.tvo_params.saturation;\n\t}\n \n\t \n\tdata->regs[0x25] = minfo->altout.tvo_params.hue;\n\treturn;\n}\n\n#define LR(x) maven_set_reg(c, (x), m->regs[(x)])\n#define LRP(x) maven_set_reg_pair(c, (x), m->regs[(x)] | (m->regs[(x)+1] << 8))\nstatic void maven_init_TV(struct i2c_client* c, const struct mavenregs* m) {\n\tint val;\n\n\n\tmaven_set_reg(c, 0x3E, 0x01);\n\tmaven_get_reg(c, 0x82);\t \n\tmaven_set_reg(c, 0x8C, 0x00);\n\tmaven_get_reg(c, 0x94);\t \n\tmaven_set_reg(c, 0x94, 0xA2);\n\t \n\n\tmaven_set_reg_pair(c, 0x8E, 0x1EFF);\n\tmaven_set_reg(c, 0xC6, 0x01);\n\n\t \n\n\tmaven_get_reg(c, 0x06);\n\tmaven_set_reg(c, 0x06, 0xF9);\t \n\n\t \n\n\t \n\t \n\tLR(0x00); LR(0x01); LR(0x02); LR(0x03);\n\n\tLR(0x04);\n\n\tLR(0x2C);\n\tLR(0x08);\n\tLR(0x0A);\n\tLR(0x09);\n\tLR(0x29);\n\tLRP(0x31);\n\tLRP(0x17);\n\tLR(0x0B);\n\tLR(0x0C);\n\tif (m->mode == MATROXFB_OUTPUT_MODE_PAL) {\n\t\tmaven_set_reg(c, 0x35, 0x10);  \n\t} else {\n\t\tmaven_set_reg(c, 0x35, 0x0F);  \n\t}\n\n\tLRP(0x10);\n\n\tLRP(0x0E);\n\tLRP(0x1E);\n\n\tLR(0x20);\t \n\tLR(0x22);\t \n\tLR(0x25);\t \n\tLR(0x34);\n\tLR(0x33);\n\tLR(0x19);\n\tLR(0x12);\n\tLR(0x3B);\n\tLR(0x13);\n\tLR(0x39);\n\tLR(0x1D);\n\tLR(0x3A);\n\tLR(0x24);\n\tLR(0x14);\n\tLR(0x15);\n\tLR(0x16);\n\tLRP(0x2D);\n\tLRP(0x2F);\n\tLR(0x1A);\n\tLR(0x1B);\n\tLR(0x1C);\n\tLR(0x23);\n\tLR(0x26);\n\tLR(0x28);\n\tLR(0x27);\n\tLR(0x21);\n\tLRP(0x2A);\n\tif (m->mode == MATROXFB_OUTPUT_MODE_PAL)\n\t\tmaven_set_reg(c, 0x35, 0x1D);\t \n\telse\n\t\tmaven_set_reg(c, 0x35, 0x1C);\n\n\tLRP(0x3C);\n\tLR(0x37);\n\tLR(0x38);\n\tmaven_set_reg(c, 0xB3, 0x01);\n\n\tmaven_get_reg(c, 0xB0);\t \n\tmaven_set_reg(c, 0xB0, 0x08);\t \n\tmaven_get_reg(c, 0xB9);\t \n\tmaven_set_reg(c, 0xB9, 0x78);\n\tmaven_get_reg(c, 0xBF);\t \n\tmaven_set_reg(c, 0xBF, 0x02);\n\tmaven_get_reg(c, 0x94);\t \n\tmaven_set_reg(c, 0x94, 0xB3);\n\n\tLR(0x80);  \n\tLR(0x81);\n\tLR(0x82);\n\n\tmaven_set_reg(c, 0x8C, 0x20);\n\tmaven_get_reg(c, 0x8D);\n\tmaven_set_reg(c, 0x8D, 0x10);\n\n\tLR(0x90);  \n\tLR(0x91);\n\tLR(0x92);\n\n\tLRP(0x9A);  \n\tLRP(0x9C);  \n\tLRP(0x9E);  \n\tLRP(0xA0);  \n\tLRP(0xA2);  \n\tLRP(0xA4);  \n\tLRP(0xA6);  \n\tLRP(0xA8);  \n\tLRP(0x98);  \n\tLRP(0xAE);  \n\tLRP(0x96);  \n\tLRP(0xAA);  \n\tLRP(0xAC);  \n\n\tLR(0xBE);\n\tLR(0xC2);\n\n\tmaven_get_reg(c, 0x8D);\n\tmaven_set_reg(c, 0x8D, 0x04);\n\n\tLR(0x20);\t \n\tLR(0x22);\t \n\tLR(0x93);\t \n\tLR(0x20);\t \n\tLR(0x22);\t \n\tLR(0x25);\t \n\tLRP(0x0E);\n\tLRP(0x1E);\n\tLRP(0x0E);\t \n\tLRP(0x1E);\t \n\n\t \n\tLR(0x83);\n\tLR(0x84);\n\tLR(0x85);\n\tLR(0x86);\n\tLR(0x87);\n\tLR(0x88);\n\tLR(0x89);\n\tLR(0x8A);\n\tLR(0x8B);\n\n\tval = maven_get_reg(c, 0x8D);\n\tval &= 0x14;\t\t\t \n\tmaven_set_reg(c, 0x8D, val);\n\n\tLR(0x33);\n\tLR(0x19);\n\tLR(0x12);\n\tLR(0x3B);\n\tLR(0x13);\n\tLR(0x39);\n\tLR(0x1D);\n\tLR(0x3A);\n\tLR(0x24);\n\tLR(0x14);\n\tLR(0x15);\n\tLR(0x16);\n\tLRP(0x2D);\n\tLRP(0x2F);\n\tLR(0x1A);\n\tLR(0x1B);\n\tLR(0x1C);\n\tLR(0x23);\n\tLR(0x26);\n\tLR(0x28);\n\tLR(0x27);\n\tLR(0x21);\n\tLRP(0x2A);\n\tif (m->mode == MATROXFB_OUTPUT_MODE_PAL)\n\t\tmaven_set_reg(c, 0x35, 0x1D);\n\telse\n\t\tmaven_set_reg(c, 0x35, 0x1C);\n\tLRP(0x3C);\n\tLR(0x37);\n\tLR(0x38);\n\n\tmaven_get_reg(c, 0xB0);\n\tLR(0xB0);\t \n\tLR(0x90);\n\tLR(0xBE);\n\tLR(0xC2);\n\n\tLRP(0x9A);\n\tLRP(0xA2);\n\tLRP(0x9E);\n\tLRP(0xA6);\n\tLRP(0xAA);\n\tLRP(0xAC);\n\tmaven_set_reg(c, 0x3E, 0x00);\n\tmaven_set_reg(c, 0x95, 0x20);\n}\n\nstatic int maven_find_exact_clocks(unsigned int ht, unsigned int vt,\n\t\tstruct mavenregs* m) {\n\tunsigned int x;\n\tunsigned int err = ~0;\n\n\t \n\tm->regs[0x80] = 0x0F;\n\tm->regs[0x81] = 0x07;\n\tm->regs[0x82] = 0x81;\n\n\tfor (x = 0; x < 8; x++) {\n\t\tunsigned int c;\n\t\tunsigned int a, b,\n\t\t\t     h2;\n\t\tunsigned int h = ht + 2 + x;\n\n\t\tif (!matroxfb_mavenclock((m->mode == MATROXFB_OUTPUT_MODE_PAL) ? &maven_PAL : &maven_NTSC, h, vt, &a, &b, &c, &h2)) {\n\t\t\tunsigned int diff = h - h2;\n\n\t\t\tif (diff < err) {\n\t\t\t\terr = diff;\n\t\t\t\tm->regs[0x80] = a - 1;\n\t\t\t\tm->regs[0x81] = b - 1;\n\t\t\t\tm->regs[0x82] = c | 0x80;\n\t\t\t\tm->hcorr = h2 - 2;\n\t\t\t\tm->htotal = h - 2;\n\t\t\t}\n\t\t}\n\t}\n\treturn err != ~0U;\n}\n\nstatic inline int maven_compute_timming(struct maven_data* md,\n\t\tstruct my_timming* mt,\n\t\tstruct mavenregs* m) {\n\tunsigned int tmpi;\n\tunsigned int a, bv, c;\n\tstruct matrox_fb_info *minfo = md->primary_head;\n\n\tm->mode = minfo->outputs[1].mode;\n\tif (m->mode != MATROXFB_OUTPUT_MODE_MONITOR) {\n\t\tunsigned int lmargin;\n\t\tunsigned int umargin;\n\t\tunsigned int vslen;\n\t\tunsigned int hcrt;\n\t\tunsigned int slen;\n\n\t\tmaven_init_TVdata(md, m);\n\n\t\tif (maven_find_exact_clocks(mt->HTotal, mt->VTotal, m) == 0)\n\t\t\treturn -EINVAL;\n\n\t\tlmargin = mt->HTotal - mt->HSyncEnd;\n\t\tslen = mt->HSyncEnd - mt->HSyncStart;\n\t\thcrt = mt->HTotal - slen - mt->delay;\n\t\tumargin = mt->VTotal - mt->VSyncEnd;\n\t\tvslen = mt->VSyncEnd - mt->VSyncStart;\n\n\t\tif (m->hcorr < mt->HTotal)\n\t\t\thcrt += m->hcorr;\n\t\tif (hcrt > mt->HTotal)\n\t\t\thcrt -= mt->HTotal;\n\t\tif (hcrt + 2 > mt->HTotal)\n\t\t\thcrt = 0;\t \n\n\t\t \n\t\t \n\t\tm->regs[0x96] = m->hcorr;\n\t\tm->regs[0x97] = m->hcorr >> 8;\n\t\t \n\t\tm->regs[0x98] = 0x00; m->regs[0x99] = 0x00;\n\t\t \n\t\tm->regs[0x9A] = lmargin;\t \n\t\tm->regs[0x9B] = lmargin >> 8;\t \n\t\t \n\t\tm->regs[0x9C] = 0x04;\n\t\tm->regs[0x9D] = 0x00;\n\t\t \n\t\tm->regs[0xA0] = m->htotal;\n\t\tm->regs[0xA1] = m->htotal >> 8;\n\t\t \n\t\tm->regs[0xA2] = mt->VTotal - mt->VSyncStart - 1;\t \n\t\tm->regs[0xA3] = (mt->VTotal - mt->VSyncStart - 1) >> 8;\n\t\t \n\t\tif (md->version == MGATVO_B) {\n\t\t\tm->regs[0xA4] = 0x04;\n\t\t\tm->regs[0xA5] = 0x00;\n\t\t} else {\n\t\t\tm->regs[0xA4] = 0x01;\n\t\t\tm->regs[0xA5] = 0x00;\n\t\t}\n\t\t \n\t\tm->regs[0xA6] = 0x00;\n\t\tm->regs[0xA7] = 0x00;\n\t\t \n\t\tm->regs[0xA8] = mt->VTotal - 1;\n\t\tm->regs[0xA9] = (mt->VTotal - 1) >> 8;\n\t\t \n\t\tm->regs[0xAA] = hcrt;\t\t \n\t\tm->regs[0xAB] = hcrt >> 8;\n\t\t \n\t\tm->regs[0xAC] = mt->VTotal - 2;\n\t\tm->regs[0xAD] = (mt->VTotal - 2) >> 8;\n\t\t \n\t\tm->regs[0xAE] = 0x01;  \n\t\tm->regs[0xAF] = 0x00;\n\t\t{\n\t\t\tint hdec;\n\t\t\tint hlen;\n\t\t\tunsigned int ibmin = 4 + lmargin + mt->HDisplay;\n\t\t\tunsigned int ib;\n\t\t\tint i;\n\n\t\t\t \n\t\t\t \n\t\t\tif (mt->HTotal)\n\t\t\t\thdec = 94208 / (mt->HTotal);\n\t\t\telse\n\t\t\t\thdec = 0x81;\n\t\t\tif (hdec > 0x81)\n\t\t\t\thdec = 0x81;\n\t\t\tif (hdec < 0x41)\n\t\t\t\thdec = 0x41;\n\t\t\thdec--;\n\t\t\thlen = 98304 - 128 - ((lmargin + mt->HDisplay - 8) * hdec);\n\t\t\tif (hlen < 0)\n\t\t\t\thlen = 0;\n\t\t\thlen = hlen >> 8;\n\t\t\tif (hlen > 0xFF)\n\t\t\t\thlen = 0xFF;\n\t\t\t \n\t\t\ti = 1;\n\t\t\tdo {\n\t\t\t\tib = ((0x3C0000 * i - 0x8000)/ hdec + 0x05E7) >> 8;\n\t\t\t\ti++;\n\t\t\t} while (ib < ibmin);\n\t\t\tif (ib >= m->htotal + 2) {\n\t\t\t\tib = ibmin;\n\t\t\t}\n\n\t\t\tm->regs[0x90] = hdec;\t \n\t\t\tm->regs[0xC2] = hlen;\n\t\t\t \n\t\t\tm->regs[0x9E] = ib;\n\t\t\tm->regs[0x9F] = ib >> 8;\n\t\t}\n\t\t{\n\t\t\tint vdec;\n\t\t\tint vlen;\n\n#define MATROX_USE64BIT_DIVIDE\n\t\t\tif (mt->VTotal) {\n#ifdef MATROX_USE64BIT_DIVIDE\n\t\t\t\tu64 f1;\n\t\t\t\tu32 a;\n\t\t\t\tu32 b;\n\n\t\t\t\ta = m->vlines * (m->htotal + 2);\n\t\t\t\tb = (mt->VTotal - 1) * (m->htotal + 2) + m->hcorr + 2;\n\n\t\t\t\tf1 = ((u64)a) << 15;\t \n\t\t\t\tdo_div(f1, b);\n\t\t\t\tvdec = f1;\n#else\n\t\t\t\tvdec = m->vlines * 32768 / mt->VTotal;\n#endif\n\t\t\t} else\n\t\t\t\tvdec = 0x8000;\n\t\t\tif (vdec > 0x8000)\n\t\t\t\tvdec = 0x8000;\n\t\t\tvlen = (vslen + umargin + mt->VDisplay) * vdec;\n\t\t\tvlen = (vlen >> 16) - 146;  \n\t\t\tif (vlen < 0)\n\t\t\t\tvlen = 0;\n\t\t\tif (vlen > 0xFF)\n\t\t\t\tvlen = 0xFF;\n\t\t\tvdec--;\n\t\t\tm->regs[0x91] = vdec;\n\t\t\tm->regs[0x92] = vdec >> 8;\n\t\t\tm->regs[0xBE] = vlen;\n\t\t}\n\t\tm->regs[0xB0] = 0x08;\t \n\t\treturn 0;\n\t}\n\n\tDAC1064_calcclock(mt->pixclock, 450000, &a, &bv, &c);\n\tm->regs[0x80] = a;\n\tm->regs[0x81] = bv;\n\tm->regs[0x82] = c | 0x80;\n\n\tm->regs[0xB3] = 0x01;\n\tm->regs[0x94] = 0xB2;\n\n\t \n\tm->regs[0x96] = mt->HTotal;\n\tm->regs[0x97] = mt->HTotal >> 8;\n\t \n\tm->regs[0x98] = 0x00;\n\tm->regs[0x99] = 0x00;\n\t \n\ttmpi = mt->HSyncEnd - mt->HSyncStart;\n\tm->regs[0x9A] = tmpi;\n\tm->regs[0x9B] = tmpi >> 8;\n\t \n\ttmpi = mt->HTotal - mt->HSyncStart;\n\tm->regs[0x9C] = tmpi;\n\tm->regs[0x9D] = tmpi >> 8;\n\t \n\ttmpi += mt->HDisplay;\n\tm->regs[0x9E] = tmpi;\n\tm->regs[0x9F] = tmpi >> 8;\n\t \n\ttmpi = mt->HTotal + 1;\n\tm->regs[0xA0] = tmpi;\n\tm->regs[0xA1] = tmpi >> 8;\n\t \n\ttmpi = mt->VSyncEnd - mt->VSyncStart - 1;\n\tm->regs[0xA2] = tmpi;\n\tm->regs[0xA3] = tmpi >> 8;\n\t \n\ttmpi = mt->VTotal - mt->VSyncStart;\n\tm->regs[0xA4] = tmpi;\n\tm->regs[0xA5] = tmpi >> 8;\n\t \n\ttmpi = mt->VTotal - 1;\n\tm->regs[0xA6] = tmpi;\n\tm->regs[0xA7] = tmpi >> 8;\n\t \n\tm->regs[0xA8] = tmpi;\n\tm->regs[0xA9] = tmpi >> 8;\n\t \n\ttmpi = mt->HTotal - mt->delay;\n\tm->regs[0xAA] = tmpi;\n\tm->regs[0xAB] = tmpi >> 8;\n\t \n\ttmpi = mt->VTotal - 2;\n\tm->regs[0xAC] = tmpi;\n\tm->regs[0xAD] = tmpi >> 8;\n\t \n\tm->regs[0xAE] = 0x00;\n\tm->regs[0xAF] = 0x00;\n\n\tm->regs[0xB0] = 0x03;\t \n\tm->regs[0xB1] = 0xA0;\t \n\tm->regs[0x8C] = 0x20;\t \n\tm->regs[0x8D] = 0x04;\t \n\tm->regs[0xB9] = 0x1A;\t \n\tm->regs[0xBF] = 0x22;\t \n\n\treturn 0;\n}\n\nstatic int maven_program_timming(struct maven_data* md,\n\t\tconst struct mavenregs* m) {\n\tstruct i2c_client *c = md->client;\n\n\tif (m->mode == MATROXFB_OUTPUT_MODE_MONITOR) {\n\t\tLR(0x80);\n\t\tLR(0x81);\n\t\tLR(0x82);\n\n\t\tLR(0xB3);\n\t\tLR(0x94);\n\n\t\tLRP(0x96);\n\t\tLRP(0x98);\n\t\tLRP(0x9A);\n\t\tLRP(0x9C);\n\t\tLRP(0x9E);\n\t\tLRP(0xA0);\n\t\tLRP(0xA2);\n\t\tLRP(0xA4);\n\t\tLRP(0xA6);\n\t\tLRP(0xA8);\n\t\tLRP(0xAA);\n\t\tLRP(0xAC);\n\t\tLRP(0xAE);\n\n\t\tLR(0xB0);\t \n\t\tLR(0xB1);\t \n\t\tLR(0x8C);\t \n\t\tLR(0x8D);\t \n\t\tLR(0xB9);\t \n\t\tLR(0xBF);\t \n\t} else {\n\t\tmaven_init_TV(c, m);\n\t}\n\treturn 0;\n}\n\nstatic inline int maven_resync(struct maven_data* md) {\n\tstruct i2c_client *c = md->client;\n\tmaven_set_reg(c, 0x95, 0x20);\t \n\treturn 0;\n}\n\nstatic int maven_get_queryctrl (struct maven_data* md, \n\t\t\t\tstruct v4l2_queryctrl *p) {\n\tint i;\n\t\n\ti = get_ctrl_id(p->id);\n\tif (i >= 0) {\n\t\t*p = maven_controls[i].desc;\n\t\treturn 0;\n\t}\n\tif (i == -ENOENT) {\n\t\tstatic const struct v4l2_queryctrl disctrl = \n\t\t\t{ .flags = V4L2_CTRL_FLAG_DISABLED };\n\t\t\t\n\t\ti = p->id;\n\t\t*p = disctrl;\n\t\tp->id = i;\n\t\tsprintf(p->name, \"Ctrl #%08X\", i);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int maven_set_control (struct maven_data* md, \n\t\t\t      struct v4l2_control *p) {\n\tint i;\n\t\n\ti = get_ctrl_id(p->id);\n\tif (i < 0) return -EINVAL;\n\n\t \n\tif (p->value == *get_ctrl_ptr(md, i)) return 0;\n\n\t \n\tif (p->value > maven_controls[i].desc.maximum) return -EINVAL;\n\tif (p->value < maven_controls[i].desc.minimum) return -EINVAL;\n\n\t \n\t*get_ctrl_ptr(md, i) = p->value;\n\n\tswitch (p->id) {\n\t\tcase V4L2_CID_BRIGHTNESS:\n\t\tcase V4L2_CID_CONTRAST:\n\t\t{\n\t\t  int blacklevel, whitelevel;\n\t\t  maven_compute_bwlevel(md, &blacklevel, &whitelevel);\n\t\t  blacklevel = (blacklevel >> 2) | ((blacklevel & 3) << 8);\n\t\t  whitelevel = (whitelevel >> 2) | ((whitelevel & 3) << 8);\n\t\t  maven_set_reg_pair(md->client, 0x0e, blacklevel);\n\t\t  maven_set_reg_pair(md->client, 0x1e, whitelevel);\n\t\t}\n\t\tbreak;\n\t\tcase V4L2_CID_SATURATION:\n\t\t{\n\t\t  maven_set_reg(md->client, 0x20, p->value);\n\t\t  maven_set_reg(md->client, 0x22, p->value);\n\t\t}\n\t\tbreak;\n\t\tcase V4L2_CID_HUE:\n\t\t{\n\t\t  maven_set_reg(md->client, 0x25, p->value);\n\t\t}\n\t\tbreak;\n\t\tcase V4L2_CID_GAMMA:\n\t\t{\n\t\t  const struct maven_gamma* g;\n\t\t  g = maven_compute_gamma(md);\n\t\t  maven_set_reg(md->client, 0x83, g->reg83);\n\t\t  maven_set_reg(md->client, 0x84, g->reg84);\n\t\t  maven_set_reg(md->client, 0x85, g->reg85);\n\t\t  maven_set_reg(md->client, 0x86, g->reg86);\n\t\t  maven_set_reg(md->client, 0x87, g->reg87);\n\t\t  maven_set_reg(md->client, 0x88, g->reg88);\n\t\t  maven_set_reg(md->client, 0x89, g->reg89);\n\t\t  maven_set_reg(md->client, 0x8a, g->reg8a);\n\t\t  maven_set_reg(md->client, 0x8b, g->reg8b);\n\t\t}\n\t\tbreak;\n\t\tcase MATROXFB_CID_TESTOUT:\n\t\t{\n\t\t\tunsigned char val \n\t\t\t  = maven_get_reg(md->client, 0x8d);\n\t\t\tif (p->value) val |= 0x10;\n\t\t\telse          val &= ~0x10;\n\t\t\tmaven_set_reg(md->client, 0x8d, val);\n\t\t}\n\t\tbreak;\n\t\tcase MATROXFB_CID_DEFLICKER:\n\t\t{\n\t\t  maven_set_reg(md->client, 0x93, maven_compute_deflicker(md));\n\t\t}\n\t\tbreak;\n\t}\n\t\n\n\treturn 0;\n}\n\nstatic int maven_get_control (struct maven_data* md, \n\t\t\t      struct v4l2_control *p) {\n\tint i;\n\t\n\ti = get_ctrl_id(p->id);\n\tif (i < 0) return -EINVAL;\n\tp->value = *get_ctrl_ptr(md, i);\n\treturn 0;\n}\n\n \n\nstatic int maven_out_compute(void* md, struct my_timming* mt) {\n#define mdinfo ((struct maven_data*)md)\n#define minfo (mdinfo->primary_head)\n\treturn maven_compute_timming(md, mt, &minfo->hw.maven);\n#undef minfo\n#undef mdinfo\n}\n\nstatic int maven_out_program(void* md) {\n#define mdinfo ((struct maven_data*)md)\n#define minfo (mdinfo->primary_head)\n\treturn maven_program_timming(md, &minfo->hw.maven);\n#undef minfo\n#undef mdinfo\n}\n\nstatic int maven_out_start(void* md) {\n\treturn maven_resync(md);\n}\n\nstatic int maven_out_verify_mode(void* md, u_int32_t arg) {\n\tswitch (arg) {\n\t\tcase MATROXFB_OUTPUT_MODE_PAL:\n\t\tcase MATROXFB_OUTPUT_MODE_NTSC:\n\t\tcase MATROXFB_OUTPUT_MODE_MONITOR:\n\t\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int maven_out_get_queryctrl(void* md, struct v4l2_queryctrl* p) {\n        return maven_get_queryctrl(md, p);\n}\n\nstatic int maven_out_get_ctrl(void* md, struct v4l2_control* p) {\n\treturn maven_get_control(md, p);\n}\n\nstatic int maven_out_set_ctrl(void* md, struct v4l2_control* p) {\n\treturn maven_set_control(md, p);\n}\n\nstatic struct matrox_altout maven_altout = {\n\t.name\t\t= \"Secondary output\",\n\t.compute\t= maven_out_compute,\n\t.program\t= maven_out_program,\n\t.start\t\t= maven_out_start,\n\t.verifymode\t= maven_out_verify_mode,\n\t.getqueryctrl\t= maven_out_get_queryctrl,\n\t.getctrl\t= maven_out_get_ctrl,\n\t.setctrl\t= maven_out_set_ctrl,\n};\n\nstatic int maven_init_client(struct i2c_client* clnt) {\n\tstruct maven_data* md = i2c_get_clientdata(clnt);\n\tstruct matrox_fb_info *minfo = container_of(clnt->adapter,\n\t\t\t\t\t\t    struct i2c_bit_adapter,\n\t\t\t\t\t\t    adapter)->minfo;\n\n\tmd->primary_head = minfo;\n\tmd->client = clnt;\n\tdown_write(&minfo->altout.lock);\n\tminfo->outputs[1].output = &maven_altout;\n\tminfo->outputs[1].src = minfo->outputs[1].default_src;\n\tminfo->outputs[1].data = md;\n\tminfo->outputs[1].mode = MATROXFB_OUTPUT_MODE_MONITOR;\n\tup_write(&minfo->altout.lock);\n\tif (maven_get_reg(clnt, 0xB2) < 0x14) {\n\t\tmd->version = MGATVO_B;\n\t\t \n\t} else {\n\t\tmd->version = MGATVO_C;\n\t}\n\t \n\t{\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < MAVCTRLS; ++i) {\n\t\t\t*get_ctrl_ptr(md, i) = maven_controls[i].desc.default_value;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int maven_shutdown_client(struct i2c_client* clnt) {\n\tstruct maven_data* md = i2c_get_clientdata(clnt);\n\n\tif (md->primary_head) {\n\t\tstruct matrox_fb_info *minfo = md->primary_head;\n\n\t\tdown_write(&minfo->altout.lock);\n\t\tminfo->outputs[1].src = MATROXFB_SRC_NONE;\n\t\tminfo->outputs[1].output = NULL;\n\t\tminfo->outputs[1].data = NULL;\n\t\tminfo->outputs[1].mode = MATROXFB_OUTPUT_MODE_MONITOR;\n\t\tup_write(&minfo->altout.lock);\n\t\tmd->primary_head = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int maven_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint err = -ENODEV;\n\tstruct maven_data* data;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WRITE_WORD_DATA |\n\t\t\t\t\t      I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t\t      I2C_FUNC_NOSTART |\n\t\t\t\t\t      I2C_FUNC_PROTOCOL_MANGLING))\n\t\tgoto ERROR0;\n\tif (!(data = kzalloc(sizeof(*data), GFP_KERNEL))) {\n\t\terr = -ENOMEM;\n\t\tgoto ERROR0;\n\t}\n\ti2c_set_clientdata(client, data);\n\terr = maven_init_client(client);\n\tif (err)\n\t\tgoto ERROR4;\n\treturn 0;\nERROR4:;\n\tkfree(data);\nERROR0:;\n\treturn err;\n}\n\nstatic void maven_remove(struct i2c_client *client)\n{\n\tmaven_shutdown_client(client);\n\tkfree(i2c_get_clientdata(client));\n}\n\nstatic const struct i2c_device_id maven_id[] = {\n\t{ \"maven\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, maven_id);\n\nstatic struct i2c_driver maven_driver={\n\t.driver = {\n\t\t.name\t= \"maven\",\n\t},\n\t.probe\t\t= maven_probe,\n\t.remove\t\t= maven_remove,\n\t.id_table\t= maven_id,\n};\n\nmodule_i2c_driver(maven_driver);\nMODULE_AUTHOR(\"(c) 1999-2002 Petr Vandrovec <vandrove@vc.cvut.cz>\");\nMODULE_DESCRIPTION(\"Matrox G200/G400 Matrox MGA-TVO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}