{
  "module_name": "imsttfb.c",
  "hash_id": "62c6c4b9aeb9fc1709499fba33f64a1f1fc3c88c6257bf29883386055eccaf01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/imsttfb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#if defined(CONFIG_PPC_PMAC)\n#include <linux/nvram.h>\n#include \"macmodes.h\"\n#endif\n\n#ifndef __powerpc__\n#define eieio()\t\t \n#endif\n\n \nenum {\n\tS1SA\t=  0,  \n\tS2SA\t=  1,  \n\tSP\t=  2,  \n\tDSA\t=  3,  \n\tCNT\t=  4,  \n\tDP_OCTL\t=  5,  \n\tCLR\t=  6,  \n\tBI\t=  8,  \n\tMBC\t=  9,  \n\tBLTCTL\t= 10,  \n\n\t \n\tHES\t= 12,  \n\tHEB\t= 13,  \n\tHSB\t= 14,  \n\tHT\t= 15,  \n\tVES\t= 16,  \n\tVEB\t= 17,  \n\tVSB\t= 18,  \n\tVT\t= 19,  \n\tHCIV\t= 20,  \n\tVCIV\t= 21,  \n\tTCDR\t= 22,  \n\tVIL\t= 23,  \n\tSTGCTL\t= 24,  \n\n\t \n\tSSR\t= 25,  \n\tHRIR\t= 26,  \n\tSPR\t= 27,  \n\tCMR\t= 28,  \n\tSRGCTL\t= 29,  \n\n\t \n\tRRCIV\t= 30,  \n\tRRSC\t= 31,  \n\tRRCR\t= 34,  \n\n\t \n\tGIOE\t= 32,  \n\tGIO\t= 33,  \n\tSCR\t= 35,  \n\tSSTATUS\t= 36,  \n\tPRC\t= 37,  \n\n#if 0\n\t \n\tDVID\t= 0x00000000L,\n\tSC\t= 0x00000004L,\n\tCCR\t= 0x00000008L,\n\tOG\t= 0x0000000CL,\n\tBARM\t= 0x00000010L,\n\tBARER\t= 0x00000030L,\n#endif\n};\n\n \nenum {\n\tPADDRW\t= 0x00,\n\tPDATA\t= 0x04,\n\tPPMASK\t= 0x08,\n\tPADDRR\t= 0x0c,\n\tPIDXLO\t= 0x10,\n\tPIDXHI\t= 0x14,\n\tPIDXDATA= 0x18,\n\tPIDXCTL\t= 0x1c\n};\n\n \nenum {\n\tCLKCTL\t\t= 0x02,\t \n\tSYNCCTL\t\t= 0x03,\t \n\tHSYNCPOS\t= 0x04,\t \n\tPWRMNGMT\t= 0x05,\t \n\tDACOP\t\t= 0x06,\t \n\tPALETCTL\t= 0x07,\t \n\tSYSCLKCTL\t= 0x08,\t \n\tPIXFMT\t\t= 0x0a,\t \n\tBPP8\t\t= 0x0b,\t \n\tBPP16\t\t= 0x0c,  \n\tBPP24\t\t= 0x0d,\t \n\tBPP32\t\t= 0x0e,\t \n\tPIXCTL1\t\t= 0x10,  \n\tPIXCTL2\t\t= 0x11,\t \n\tSYSCLKN\t\t= 0x15,\t \n\tSYSCLKM\t\t= 0x16,\t \n\tSYSCLKP\t\t= 0x17,\t \n\tSYSCLKC\t\t= 0x18,\t \n\t \n\tPIXM0\t\t= 0x20,\t \n\tPIXN0\t\t= 0x21,\t \n\tPIXP0\t\t= 0x22,\t \n\tPIXC0\t\t= 0x23,\t \n\tCURSCTL\t\t= 0x30,\t \n\tCURSXLO\t\t= 0x31,\t \n\tCURSXHI\t\t= 0x32,\t \n\tCURSYLO\t\t= 0x33,\t \n\tCURSYHI\t\t= 0x34,\t \n\tCURSHOTX\t= 0x35,\t \n\tCURSHOTY\t= 0x36,\t \n\tCURSACCTL\t= 0x37,\t \n\tCURSACATTR\t= 0x38,\t \n\tCURS1R\t\t= 0x40,\t \n\tCURS1G\t\t= 0x41,\t \n\tCURS1B\t\t= 0x42,\t \n\tCURS2R\t\t= 0x43,\t \n\tCURS2G\t\t= 0x44,\t \n\tCURS2B\t\t= 0x45,\t \n\tCURS3R\t\t= 0x46,\t \n\tCURS3G\t\t= 0x47,\t \n\tCURS3B\t\t= 0x48,\t \n\tBORDR\t\t= 0x60,\t \n\tBORDG\t\t= 0x61,\t \n\tBORDB\t\t= 0x62,\t \n\tMISCTL1\t\t= 0x70,\t \n\tMISCTL2\t\t= 0x71,\t \n\tMISCTL3\t\t= 0x72,\t \n\tKEYCTL\t\t= 0x78\t \n};\n\n \nenum {\n\tTVPADDRW = 0x00,\t \n\tTVPPDATA = 0x04,\t \n\tTVPPMASK = 0x08,\t \n\tTVPPADRR = 0x0c,\t \n\tTVPCADRW = 0x10,\t \n\tTVPCDATA = 0x14,\t \n\t\t\t\t \n\tTVPCADRR = 0x1c,\t \n\t\t\t\t \n\tTVPDCCTL = 0x24,\t \n\tTVPIDATA = 0x28,\t \n\tTVPCRDAT = 0x2c,\t \n\tTVPCXPOL = 0x30,\t \n\tTVPCXPOH = 0x34,\t \n\tTVPCYPOL = 0x38,\t \n\tTVPCYPOH = 0x3c,\t \n};\n\n \nenum {\n\tTVPIRREV = 0x01,\t \n\tTVPIRICC = 0x06,\t \n\tTVPIRBRC = 0x07,\t \n\tTVPIRLAC = 0x0f,\t \n\tTVPIRTCC = 0x18,\t \n\tTVPIRMXC = 0x19,\t \n\tTVPIRCLS = 0x1a,\t \n\tTVPIRPPG = 0x1c,\t \n\tTVPIRGEC = 0x1d,\t \n\tTVPIRMIC = 0x1e,\t \n\tTVPIRPLA = 0x2c,\t \n\tTVPIRPPD = 0x2d,\t \n\tTVPIRMPD = 0x2e,\t \n\tTVPIRLPD = 0x2f,\t \n\tTVPIRCKL = 0x30,\t \n\tTVPIRCKH = 0x31,\t \n\tTVPIRCRL = 0x32,\t \n\tTVPIRCRH = 0x33,\t \n\tTVPIRCGL = 0x34,\t \n\tTVPIRCGH = 0x35,\t \n\tTVPIRCBL = 0x36,\t \n\tTVPIRCBH = 0x37,\t \n\tTVPIRCKC = 0x38,\t \n\tTVPIRMLC = 0x39,\t \n\tTVPIRSEN = 0x3a,\t \n\tTVPIRTMD = 0x3b,\t \n\tTVPIRRML = 0x3c,\t \n\tTVPIRRMM = 0x3d,\t \n\tTVPIRRMS = 0x3e,\t \n\tTVPIRDID = 0x3f,\t \n\tTVPIRRES = 0xff\t\t \n};\n\nstruct initvalues {\n\t__u8 addr, value;\n};\n\nstatic struct initvalues ibm_initregs[] = {\n\t{ CLKCTL,\t0x21 },\n\t{ SYNCCTL,\t0x00 },\n\t{ HSYNCPOS,\t0x00 },\n\t{ PWRMNGMT,\t0x00 },\n\t{ DACOP,\t0x02 },\n\t{ PALETCTL,\t0x00 },\n\t{ SYSCLKCTL,\t0x01 },\n\n\t \n\t{ BPP8,\t\t0x00 },\n\t{ BPP16,\t0x01 },\n\t{ BPP24,\t0x00 },\n\t{ BPP32,\t0x00 },\n\n\t{ PIXCTL1,\t0x05 },\n\t{ PIXCTL2,\t0x00 },\n\t{ SYSCLKN,\t0x08 },\n\t{ SYSCLKM,\t0x4f },\n\t{ SYSCLKP,\t0x00 },\n\t{ SYSCLKC,\t0x00 },\n\t{ CURSCTL,\t0x00 },\n\t{ CURSACCTL,\t0x01 },\n\t{ CURSACATTR,\t0xa8 },\n\t{ CURS1R,\t0xff },\n\t{ CURS1G,\t0xff },\n\t{ CURS1B,\t0xff },\n\t{ CURS2R,\t0xff },\n\t{ CURS2G,\t0xff },\n\t{ CURS2B,\t0xff },\n\t{ CURS3R,\t0xff },\n\t{ CURS3G,\t0xff },\n\t{ CURS3B,\t0xff },\n\t{ BORDR,\t0xff },\n\t{ BORDG,\t0xff },\n\t{ BORDB,\t0xff },\n\t{ MISCTL1,\t0x01 },\n\t{ MISCTL2,\t0x45 },\n\t{ MISCTL3,\t0x00 },\n\t{ KEYCTL,\t0x00 }\n};\n\nstatic struct initvalues tvp_initregs[] = {\n\t{ TVPIRICC,\t0x00 },\n\t{ TVPIRBRC,\t0xe4 },\n\t{ TVPIRLAC,\t0x06 },\n\t{ TVPIRTCC,\t0x80 },\n\t{ TVPIRMXC,\t0x4d },\n\t{ TVPIRCLS,\t0x05 },\n\t{ TVPIRPPG,\t0x00 },\n\t{ TVPIRGEC,\t0x00 },\n\t{ TVPIRMIC,\t0x08 },\n\t{ TVPIRCKL,\t0xff },\n\t{ TVPIRCKH,\t0xff },\n\t{ TVPIRCRL,\t0xff },\n\t{ TVPIRCRH,\t0xff },\n\t{ TVPIRCGL,\t0xff },\n\t{ TVPIRCGH,\t0xff },\n\t{ TVPIRCBL,\t0xff },\n\t{ TVPIRCBH,\t0xff },\n\t{ TVPIRCKC,\t0x00 },\n\t{ TVPIRPLA,\t0x00 },\n\t{ TVPIRPPD,\t0xc0 },\n\t{ TVPIRPPD,\t0xd5 },\n\t{ TVPIRPPD,\t0xea },\n\t{ TVPIRPLA,\t0x00 },\n\t{ TVPIRMPD,\t0xb9 },\n\t{ TVPIRMPD,\t0x3a },\n\t{ TVPIRMPD,\t0xb1 },\n\t{ TVPIRPLA,\t0x00 },\n\t{ TVPIRLPD,\t0xc1 },\n\t{ TVPIRLPD,\t0x3d },\n\t{ TVPIRLPD,\t0xf3 },\n};\n\nstruct imstt_regvals {\n\t__u32 pitch;\n\t__u16 hes, heb, hsb, ht, ves, veb, vsb, vt, vil;\n\t__u8 pclk_m, pclk_n, pclk_p;\n\t \n\t__u8 mlc[3];\t \n\t__u8 lckl_p[3];\t \n};\n\nstruct imstt_par {\n\tstruct imstt_regvals init;\n\t__u32 __iomem *dc_regs;\n\tunsigned long cmap_regs_phys;\n\t__u8 *cmap_regs;\n\t__u32 ramdac;\n\t__u32 palette[16];\n};\n\nenum {\n\tIBM = 0,\n\tTVP = 1\n};\n\n#define INIT_BPP\t\t8\n#define INIT_XRES\t\t640\n#define INIT_YRES\t\t480\n\nstatic int inverse = 0;\nstatic char fontname[40] __initdata = { 0 };\n#if defined(CONFIG_PPC_PMAC)\nstatic signed char init_vmode = -1, init_cmode = -1;\n#endif\n\nstatic struct imstt_regvals tvp_reg_init_2 = {\n\t512,\n\t0x0002, 0x0006, 0x0026, 0x0028, 0x0003, 0x0016, 0x0196, 0x0197, 0x0196,\n\t0xec, 0x2a, 0xf3,\n\t{ 0x3c, 0x3b, 0x39 }, { 0xf3, 0xf3, 0xf3 }\n};\n\nstatic struct imstt_regvals tvp_reg_init_6 = {\n\t640,\n\t0x0004, 0x0009, 0x0031, 0x0036, 0x0003, 0x002a, 0x020a, 0x020d, 0x020a,\n\t0xef, 0x2e, 0xb2,\n\t{ 0x39, 0x39, 0x38 }, { 0xf3, 0xf3, 0xf3 }\n};\n\nstatic struct imstt_regvals tvp_reg_init_12 = {\n\t800,\n\t0x0005, 0x000e, 0x0040, 0x0042, 0x0003, 0x018, 0x270, 0x271, 0x270,\n\t0xf6, 0x2e, 0xf2,\n\t{ 0x3a, 0x39, 0x38 }, { 0xf3, 0xf3, 0xf3 }\n};\n\nstatic struct imstt_regvals tvp_reg_init_13 = {\n\t832,\n\t0x0004, 0x0011, 0x0045, 0x0048, 0x0003, 0x002a, 0x029a, 0x029b, 0x0000,\n\t0xfe, 0x3e, 0xf1,\n\t{ 0x39, 0x38, 0x38 }, { 0xf3, 0xf3, 0xf2 }\n};\n\nstatic struct imstt_regvals tvp_reg_init_17 = {\n\t1024,\n\t0x0006, 0x0210, 0x0250, 0x0053, 0x1003, 0x0021, 0x0321, 0x0324, 0x0000,\n\t0xfc, 0x3a, 0xf1,\n\t{ 0x39, 0x38, 0x38 }, { 0xf3, 0xf3, 0xf2 }\n};\n\nstatic struct imstt_regvals tvp_reg_init_18 = {\n\t1152,\n  \t0x0009, 0x0011, 0x059, 0x5b, 0x0003, 0x0031, 0x0397, 0x039a, 0x0000,\n\t0xfd, 0x3a, 0xf1,\n\t{ 0x39, 0x38, 0x38 }, { 0xf3, 0xf3, 0xf2 }\n};\n\nstatic struct imstt_regvals tvp_reg_init_19 = {\n\t1280,\n\t0x0009, 0x0016, 0x0066, 0x0069, 0x0003, 0x0027, 0x03e7, 0x03e8, 0x03e7,\n\t0xf7, 0x36, 0xf0,\n\t{ 0x38, 0x38, 0x38 }, { 0xf3, 0xf2, 0xf1 }\n};\n\nstatic struct imstt_regvals tvp_reg_init_20 = {\n\t1280,\n\t0x0009, 0x0018, 0x0068, 0x006a, 0x0003, 0x0029, 0x0429, 0x042a, 0x0000,\n\t0xf0, 0x2d, 0xf0,\n\t{ 0x38, 0x38, 0x38 }, { 0xf3, 0xf2, 0xf1 }\n};\n\n \nstatic int imsttfb_probe(struct pci_dev *pdev, const struct pci_device_id *ent);\nstatic void imsttfb_remove(struct pci_dev *pdev);\n\n \nstatic inline u32 read_reg_le32(volatile u32 __iomem *base, int regindex)\n{\n#ifdef __powerpc__\n\treturn in_le32(base + regindex);\n#else\n\treturn readl(base + regindex);\n#endif\n}\n\nstatic inline void write_reg_le32(volatile u32 __iomem *base, int regindex, u32 val)\n{\n#ifdef __powerpc__\n\tout_le32(base + regindex, val);\n#else\n\twritel(val, base + regindex);\n#endif\n}\n\nstatic __u32\ngetclkMHz(struct imstt_par *par)\n{\n\t__u32 clk_m, clk_n, clk_p;\n\n\tclk_m = par->init.pclk_m;\n\tclk_n = par->init.pclk_n;\n\tclk_p = par->init.pclk_p;\n\n\treturn 20 * (clk_m + 1) / ((clk_n + 1) * (clk_p ? 2 * clk_p : 1));\n}\n\nstatic void\nsetclkMHz(struct imstt_par *par, __u32 MHz)\n{\n\t__u32 clk_m, clk_n, x, stage, spilled;\n\n\tclk_m = clk_n = 0;\n\tstage = spilled = 0;\n\tfor (;;) {\n\t\tswitch (stage) {\n\t\t\tcase 0:\n\t\t\t\tclk_m++;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tclk_n++;\n\t\t\t\tbreak;\n\t\t}\n\t\tx = 20 * (clk_m + 1) / (clk_n + 1);\n\t\tif (x == MHz)\n\t\t\tbreak;\n\t\tif (x > MHz) {\n\t\t\tspilled = 1;\n\t\t\tstage = 1;\n\t\t} else if (spilled && x < MHz) {\n\t\t\tstage = 0;\n\t\t}\n\t}\n\n\tpar->init.pclk_m = clk_m;\n\tpar->init.pclk_n = clk_n;\n\tpar->init.pclk_p = 0;\n}\n\nstatic struct imstt_regvals *\ncompute_imstt_regvals_ibm(struct imstt_par *par, int xres, int yres)\n{\n\tstruct imstt_regvals *init = &par->init;\n\t__u32 MHz, hes, heb, veb, htp, vtp;\n\n\tswitch (xres) {\n\t\tcase 640:\n\t\t\thes = 0x0008; heb = 0x0012; veb = 0x002a; htp = 10; vtp = 2;\n\t\t\tMHz = 30   ;\n\t\t\tbreak;\n\t\tcase 832:\n\t\t\thes = 0x0005; heb = 0x0020; veb = 0x0028; htp = 8; vtp = 3;\n\t\t\tMHz = 57   ;\n\t\t\tbreak;\n\t\tcase 1024:\n\t\t\thes = 0x000a; heb = 0x001c; veb = 0x0020; htp = 8; vtp = 3;\n\t\t\tMHz = 80;\n\t\t\tbreak;\n\t\tcase 1152:\n\t\t\thes = 0x0012; heb = 0x0022; veb = 0x0031; htp = 4; vtp = 3;\n\t\t\tMHz = 101   ;\n\t\t\tbreak;\n\t\tcase 1280:\n\t\t\thes = 0x0012; heb = 0x002f; veb = 0x0029; htp = 4; vtp = 1;\n\t\t\tMHz = yres == 960 ? 126 : 135;\n\t\t\tbreak;\n\t\tcase 1600:\n\t\t\thes = 0x0018; heb = 0x0040; veb = 0x002a; htp = 4; vtp = 3;\n\t\t\tMHz = 200;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn NULL;\n\t}\n\n\tsetclkMHz(par, MHz);\n\n\tinit->hes = hes;\n\tinit->heb = heb;\n\tinit->hsb = init->heb + (xres >> 3);\n\tinit->ht = init->hsb + htp;\n\tinit->ves = 0x0003;\n\tinit->veb = veb;\n\tinit->vsb = init->veb + yres;\n\tinit->vt = init->vsb + vtp;\n\tinit->vil = init->vsb;\n\n\tinit->pitch = xres;\n\treturn init;\n}\n\nstatic struct imstt_regvals *\ncompute_imstt_regvals_tvp(struct imstt_par *par, int xres, int yres)\n{\n\tstruct imstt_regvals *init;\n\n\tswitch (xres) {\n\t\tcase 512:\n\t\t\tinit = &tvp_reg_init_2;\n\t\t\tbreak;\n\t\tcase 640:\n\t\t\tinit = &tvp_reg_init_6;\n\t\t\tbreak;\n\t\tcase 800:\n\t\t\tinit = &tvp_reg_init_12;\n\t\t\tbreak;\n\t\tcase 832:\n\t\t\tinit = &tvp_reg_init_13;\n\t\t\tbreak;\n\t\tcase 1024:\n\t\t\tinit = &tvp_reg_init_17;\n\t\t\tbreak;\n\t\tcase 1152:\n\t\t\tinit = &tvp_reg_init_18;\n\t\t\tbreak;\n\t\tcase 1280:\n\t\t\tinit = yres == 960 ? &tvp_reg_init_19 : &tvp_reg_init_20;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn NULL;\n\t}\n\tpar->init = *init;\n\treturn init;\n}\n\nstatic struct imstt_regvals *\ncompute_imstt_regvals (struct imstt_par *par, u_int xres, u_int yres)\n{\n\tif (par->ramdac == IBM)\n\t\treturn compute_imstt_regvals_ibm(par, xres, yres);\n\telse\n\t\treturn compute_imstt_regvals_tvp(par, xres, yres);\n}\n\nstatic void\nset_imstt_regvals_ibm (struct imstt_par *par, u_int bpp)\n{\n\tstruct imstt_regvals *init = &par->init;\n\t__u8 pformat = (bpp >> 3) + 2;\n\n\tpar->cmap_regs[PIDXHI] = 0;\t\teieio();\n\tpar->cmap_regs[PIDXLO] = PIXM0;\t\teieio();\n\tpar->cmap_regs[PIDXDATA] = init->pclk_m;eieio();\n\tpar->cmap_regs[PIDXLO] = PIXN0;\t\teieio();\n\tpar->cmap_regs[PIDXDATA] = init->pclk_n;eieio();\n\tpar->cmap_regs[PIDXLO] = PIXP0;\t\teieio();\n\tpar->cmap_regs[PIDXDATA] = init->pclk_p;eieio();\n\tpar->cmap_regs[PIDXLO] = PIXC0;\t\teieio();\n\tpar->cmap_regs[PIDXDATA] = 0x02;\teieio();\n\n\tpar->cmap_regs[PIDXLO] = PIXFMT;\teieio();\n\tpar->cmap_regs[PIDXDATA] = pformat;\teieio();\n}\n\nstatic void\nset_imstt_regvals_tvp (struct imstt_par *par, u_int bpp)\n{\n\tstruct imstt_regvals *init = &par->init;\n\t__u8 tcc, mxc, lckl_n, mic;\n\t__u8 mlc, lckl_p;\n\n\tswitch (bpp) {\n\t\tdefault:\n\t\tcase 8:\n\t\t\ttcc = 0x80;\n\t\t\tmxc = 0x4d;\n\t\t\tlckl_n = 0xc1;\n\t\t\tmlc = init->mlc[0];\n\t\t\tlckl_p = init->lckl_p[0];\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\ttcc = 0x44;\n\t\t\tmxc = 0x55;\n\t\t\tlckl_n = 0xe1;\n\t\t\tmlc = init->mlc[1];\n\t\t\tlckl_p = init->lckl_p[1];\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\ttcc = 0x5e;\n\t\t\tmxc = 0x5d;\n\t\t\tlckl_n = 0xf1;\n\t\t\tmlc = init->mlc[2];\n\t\t\tlckl_p = init->lckl_p[2];\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\ttcc = 0x46;\n\t\t\tmxc = 0x5d;\n\t\t\tlckl_n = 0xf1;\n\t\t\tmlc = init->mlc[2];\n\t\t\tlckl_p = init->lckl_p[2];\n\t\t\tbreak;\n\t}\n\tmic = 0x08;\n\n\tpar->cmap_regs[TVPADDRW] = TVPIRPLA;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = 0x00;\t\teieio();\n\tpar->cmap_regs[TVPADDRW] = TVPIRPPD;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = init->pclk_m;\teieio();\n\tpar->cmap_regs[TVPADDRW] = TVPIRPPD;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = init->pclk_n;\teieio();\n\tpar->cmap_regs[TVPADDRW] = TVPIRPPD;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = init->pclk_p;\teieio();\n\n\tpar->cmap_regs[TVPADDRW] = TVPIRTCC;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = tcc;\t\t\teieio();\n\tpar->cmap_regs[TVPADDRW] = TVPIRMXC;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = mxc;\t\t\teieio();\n\tpar->cmap_regs[TVPADDRW] = TVPIRMIC;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = mic;\t\t\teieio();\n\n\tpar->cmap_regs[TVPADDRW] = TVPIRPLA;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = 0x00;\t\teieio();\n\tpar->cmap_regs[TVPADDRW] = TVPIRLPD;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = lckl_n;\t\teieio();\n\n\tpar->cmap_regs[TVPADDRW] = TVPIRPLA;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = 0x15;\t\teieio();\n\tpar->cmap_regs[TVPADDRW] = TVPIRMLC;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = mlc;\t\t\teieio();\n\n\tpar->cmap_regs[TVPADDRW] = TVPIRPLA;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = 0x2a;\t\teieio();\n\tpar->cmap_regs[TVPADDRW] = TVPIRLPD;\t\teieio();\n\tpar->cmap_regs[TVPIDATA] = lckl_p;\t\teieio();\n}\n\nstatic void\nset_imstt_regvals (struct fb_info *info, u_int bpp)\n{\n\tstruct imstt_par *par = info->par;\n\tstruct imstt_regvals *init = &par->init;\n\t__u32 ctl, pitch, byteswap, scr;\n\n\tif (par->ramdac == IBM)\n\t\tset_imstt_regvals_ibm(par, bpp);\n\telse\n\t\tset_imstt_regvals_tvp(par, bpp);\n\n   \n\tswitch (bpp) {\n\t\tdefault:\n\t\tcase 8:\n\t\t\tctl = 0x17b1;\n\t\t\tpitch = init->pitch >> 2;\n\t\t\tbyteswap = 0x000;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tctl = 0x17b3;\n\t\t\tpitch = init->pitch >> 1;\n\t\t\tbyteswap = 0x100;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tctl = 0x17b9;\n\t\t\tpitch = init->pitch - (init->pitch >> 2);\n\t\t\tbyteswap = 0x200;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tctl = 0x17b5;\n\t\t\tpitch = init->pitch;\n\t\t\tbyteswap = 0x300;\n\t\t\tbreak;\n\t}\n\tif (par->ramdac == TVP)\n\t\tctl -= 0x30;\n\n\twrite_reg_le32(par->dc_regs, HES, init->hes);\n\twrite_reg_le32(par->dc_regs, HEB, init->heb);\n\twrite_reg_le32(par->dc_regs, HSB, init->hsb);\n\twrite_reg_le32(par->dc_regs, HT, init->ht);\n\twrite_reg_le32(par->dc_regs, VES, init->ves);\n\twrite_reg_le32(par->dc_regs, VEB, init->veb);\n\twrite_reg_le32(par->dc_regs, VSB, init->vsb);\n\twrite_reg_le32(par->dc_regs, VT, init->vt);\n\twrite_reg_le32(par->dc_regs, VIL, init->vil);\n\twrite_reg_le32(par->dc_regs, HCIV, 1);\n\twrite_reg_le32(par->dc_regs, VCIV, 1);\n\twrite_reg_le32(par->dc_regs, TCDR, 4);\n\twrite_reg_le32(par->dc_regs, RRCIV, 1);\n\twrite_reg_le32(par->dc_regs, RRSC, 0x980);\n\twrite_reg_le32(par->dc_regs, RRCR, 0x11);\n\n\tif (par->ramdac == IBM) {\n\t\twrite_reg_le32(par->dc_regs, HRIR, 0x0100);\n\t\twrite_reg_le32(par->dc_regs, CMR, 0x00ff);\n\t\twrite_reg_le32(par->dc_regs, SRGCTL, 0x0073);\n\t} else {\n\t\twrite_reg_le32(par->dc_regs, HRIR, 0x0200);\n\t\twrite_reg_le32(par->dc_regs, CMR, 0x01ff);\n\t\twrite_reg_le32(par->dc_regs, SRGCTL, 0x0003);\n\t}\n\n\tswitch (info->fix.smem_len) {\n\t\tcase 0x200000:\n\t\t\tscr = 0x059d | byteswap;\n\t\t\tbreak;\n\t\t \n\t\tdefault:\n\t\t\tpitch >>= 1;\n\t\t\tscr = 0x150dd | byteswap;\n\t\t\tbreak;\n\t}\n\n\twrite_reg_le32(par->dc_regs, SCR, scr);\n\twrite_reg_le32(par->dc_regs, SPR, pitch);\n\twrite_reg_le32(par->dc_regs, STGCTL, ctl);\n}\n\nstatic inline void\nset_offset (struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct imstt_par *par = info->par;\n\t__u32 off = var->yoffset * (info->fix.line_length >> 3)\n\t\t    + ((var->xoffset * (info->var.bits_per_pixel >> 3)) >> 3);\n\twrite_reg_le32(par->dc_regs, SSR, off);\n}\n\nstatic inline void\nset_555 (struct imstt_par *par)\n{\n\tif (par->ramdac == IBM) {\n\t\tpar->cmap_regs[PIDXHI] = 0;\t\teieio();\n\t\tpar->cmap_regs[PIDXLO] = BPP16;\t\teieio();\n\t\tpar->cmap_regs[PIDXDATA] = 0x01;\teieio();\n\t} else {\n\t\tpar->cmap_regs[TVPADDRW] = TVPIRTCC;\teieio();\n\t\tpar->cmap_regs[TVPIDATA] = 0x44;\teieio();\n\t}\n}\n\nstatic inline void\nset_565 (struct imstt_par *par)\n{\n\tif (par->ramdac == IBM) {\n\t\tpar->cmap_regs[PIDXHI] = 0;\t\teieio();\n\t\tpar->cmap_regs[PIDXLO] = BPP16;\t\teieio();\n\t\tpar->cmap_regs[PIDXDATA] = 0x03;\teieio();\n\t} else {\n\t\tpar->cmap_regs[TVPADDRW] = TVPIRTCC;\teieio();\n\t\tpar->cmap_regs[TVPIDATA] = 0x45;\teieio();\n\t}\n}\n\nstatic int\nimsttfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tif ((var->bits_per_pixel != 8 && var->bits_per_pixel != 16\n\t    && var->bits_per_pixel != 24 && var->bits_per_pixel != 32)\n\t    || var->xres_virtual < var->xres || var->yres_virtual < var->yres\n\t    || var->nonstd\n\t    || (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)\n\t\treturn -EINVAL;\n\n\tif ((var->xres * var->yres) * (var->bits_per_pixel >> 3) > info->fix.smem_len\n\t    || (var->xres_virtual * var->yres_virtual) * (var->bits_per_pixel >> 3) > info->fix.smem_len)\n\t\treturn -EINVAL;\n\n\tswitch (var->bits_per_pixel) {\n\t\tcase 8:\n\t\t\tvar->red.offset = 0;\n\t\t\tvar->red.length = 8;\n\t\t\tvar->green.offset = 0;\n\t\t\tvar->green.length = 8;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->blue.length = 8;\n\t\t\tvar->transp.offset = 0;\n\t\t\tvar->transp.length = 0;\n\t\t\tbreak;\n\t\tcase 16:\t \n\t\t\tif (var->green.length != 6)\n\t\t\t\tvar->red.offset = 10;\n\t\t\tvar->red.length = 5;\n\t\t\tvar->green.offset = 5;\n\t\t\tif (var->green.length != 6)\n\t\t\t\tvar->green.length = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->blue.length = 5;\n\t\t\tvar->transp.offset = 0;\n\t\t\tvar->transp.length = 0;\n\t\t\tbreak;\n\t\tcase 24:\t \n\t\t\tvar->red.offset = 16;\n\t\t\tvar->red.length = 8;\n\t\t\tvar->green.offset = 8;\n\t\t\tvar->green.length = 8;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->blue.length = 8;\n\t\t\tvar->transp.offset = 0;\n\t\t\tvar->transp.length = 0;\n\t\t\tbreak;\n\t\tcase 32:\t \n\t\t\tvar->red.offset = 16;\n\t\t\tvar->red.length = 8;\n\t\t\tvar->green.offset = 8;\n\t\t\tvar->green.length = 8;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->blue.length = 8;\n\t\t\tvar->transp.offset = 24;\n\t\t\tvar->transp.length = 8;\n\t\t\tbreak;\n\t}\n\n\tif (var->yres == var->yres_virtual) {\n\t\t__u32 vram = (info->fix.smem_len - (PAGE_SIZE << 2));\n\t\tvar->yres_virtual = ((vram << 3) / var->bits_per_pixel) / var->xres_virtual;\n\t\tif (var->yres_virtual < var->yres)\n\t\t\tvar->yres_virtual = var->yres;\n\t}\n\n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.msb_right = 0;\n\tvar->transp.msb_right = 0;\n\tvar->height = -1;\n\tvar->width = -1;\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\tvar->left_margin = var->right_margin = 16;\n\tvar->upper_margin = var->lower_margin = 16;\n\tvar->hsync_len = var->vsync_len = 8;\n\treturn 0;\n}\n\nstatic int\nimsttfb_set_par(struct fb_info *info)\n{\n\tstruct imstt_par *par = info->par;\n\n\tif (!compute_imstt_regvals(par, info->var.xres, info->var.yres))\n\t\treturn -EINVAL;\n\n\tif (info->var.green.length == 6)\n\t\tset_565(par);\n\telse\n\t\tset_555(par);\n\tset_imstt_regvals(info, info->var.bits_per_pixel);\n\tinfo->var.pixclock = 1000000 / getclkMHz(par);\n\treturn 0;\n}\n\nstatic int\nimsttfb_setcolreg (u_int regno, u_int red, u_int green, u_int blue,\n\t\t   u_int transp, struct fb_info *info)\n{\n\tstruct imstt_par *par = info->par;\n\tu_int bpp = info->var.bits_per_pixel;\n\n\tif (regno > 255)\n\t\treturn 1;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\t \n\tif (0 && bpp == 16)\t \n\t\tpar->cmap_regs[PADDRW] = regno << 3;\n\telse\n\t\tpar->cmap_regs[PADDRW] = regno;\n\teieio();\n\n\tpar->cmap_regs[PDATA] = red;\teieio();\n\tpar->cmap_regs[PDATA] = green;\teieio();\n\tpar->cmap_regs[PDATA] = blue;\teieio();\n\n\tif (regno < 16)\n\t\tswitch (bpp) {\n\t\t\tcase 16:\n\t\t\t\tpar->palette[regno] =\n\t\t\t\t\t(regno << (info->var.green.length ==\n\t\t\t\t\t5 ? 10 : 11)) | (regno << 5) | regno;\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tpar->palette[regno] =\n\t\t\t\t\t(regno << 16) | (regno << 8) | regno;\n\t\t\t\tbreak;\n\t\t\tcase 32: {\n\t\t\t\tint i = (regno << 8) | regno;\n\t\t\t\tpar->palette[regno] = (i << 16) |i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nstatic int\nimsttfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tif (var->xoffset + info->var.xres > info->var.xres_virtual\n\t    || var->yoffset + info->var.yres > info->var.yres_virtual)\n\t\treturn -EINVAL;\n\n\tinfo->var.xoffset = var->xoffset;\n\tinfo->var.yoffset = var->yoffset;\n\tset_offset(var, info);\n\treturn 0;\n}\n\nstatic int\nimsttfb_blank(int blank, struct fb_info *info)\n{\n\tstruct imstt_par *par = info->par;\n\t__u32 ctrl;\n\n\tctrl = read_reg_le32(par->dc_regs, STGCTL);\n\tif (blank > 0) {\n\t\tswitch (blank) {\n\t\tcase FB_BLANK_NORMAL:\n\t\tcase FB_BLANK_POWERDOWN:\n\t\t\tctrl &= ~0x00000380;\n\t\t\tif (par->ramdac == IBM) {\n\t\t\t\tpar->cmap_regs[PIDXHI] = 0;\t\teieio();\n\t\t\t\tpar->cmap_regs[PIDXLO] = MISCTL2;\teieio();\n\t\t\t\tpar->cmap_regs[PIDXDATA] = 0x55;\teieio();\n\t\t\t\tpar->cmap_regs[PIDXLO] = MISCTL1;\teieio();\n\t\t\t\tpar->cmap_regs[PIDXDATA] = 0x11;\teieio();\n\t\t\t\tpar->cmap_regs[PIDXLO] = SYNCCTL;\teieio();\n\t\t\t\tpar->cmap_regs[PIDXDATA] = 0x0f;\teieio();\n\t\t\t\tpar->cmap_regs[PIDXLO] = PWRMNGMT;\teieio();\n\t\t\t\tpar->cmap_regs[PIDXDATA] = 0x1f;\teieio();\n\t\t\t\tpar->cmap_regs[PIDXLO] = CLKCTL;\teieio();\n\t\t\t\tpar->cmap_regs[PIDXDATA] = 0xc0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\t\tctrl &= ~0x00000020;\n\t\t\tbreak;\n\t\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\t\tctrl &= ~0x00000010;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (par->ramdac == IBM) {\n\t\t\tctrl |= 0x000017b0;\n\t\t\tpar->cmap_regs[PIDXHI] = 0;\t\teieio();\n\t\t\tpar->cmap_regs[PIDXLO] = CLKCTL;\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = 0x01;\teieio();\n\t\t\tpar->cmap_regs[PIDXLO] = PWRMNGMT;\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = 0x00;\teieio();\n\t\t\tpar->cmap_regs[PIDXLO] = SYNCCTL;\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = 0x00;\teieio();\n\t\t\tpar->cmap_regs[PIDXLO] = MISCTL1;\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = 0x01;\teieio();\n\t\t\tpar->cmap_regs[PIDXLO] = MISCTL2;\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = 0x45;\teieio();\n\t\t} else\n\t\t\tctrl |= 0x00001780;\n\t}\n\twrite_reg_le32(par->dc_regs, STGCTL, ctrl);\n\treturn 0;\n}\n\nstatic void\nimsttfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct imstt_par *par = info->par;\n\t__u32 Bpp, line_pitch, bgc, dx, dy, width, height;\n\n\tbgc = rect->color;\n\tbgc |= (bgc << 8);\n\tbgc |= (bgc << 16);\n\n\tBpp = info->var.bits_per_pixel >> 3,\n\tline_pitch = info->fix.line_length;\n\n\tdy = rect->dy * line_pitch;\n\tdx = rect->dx * Bpp;\n\theight = rect->height;\n\theight--;\n\twidth = rect->width * Bpp;\n\twidth--;\n\n\tif (rect->rop == ROP_COPY) {\n\t\twhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x80);\n\t\twrite_reg_le32(par->dc_regs, DSA, dy + dx);\n\t\twrite_reg_le32(par->dc_regs, CNT, (height << 16) | width);\n\t\twrite_reg_le32(par->dc_regs, DP_OCTL, line_pitch);\n\t\twrite_reg_le32(par->dc_regs, BI, 0xffffffff);\n\t\twrite_reg_le32(par->dc_regs, MBC, 0xffffffff);\n\t\twrite_reg_le32(par->dc_regs, CLR, bgc);\n\t\twrite_reg_le32(par->dc_regs, BLTCTL, 0x840);  \n\t\twhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x80);\n\t\twhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x40);\n\t} else {\n\t\twhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x80);\n\t\twrite_reg_le32(par->dc_regs, DSA, dy + dx);\n\t\twrite_reg_le32(par->dc_regs, S1SA, dy + dx);\n\t\twrite_reg_le32(par->dc_regs, CNT, (height << 16) | width);\n\t\twrite_reg_le32(par->dc_regs, DP_OCTL, line_pitch);\n\t\twrite_reg_le32(par->dc_regs, SP, line_pitch);\n\t\twrite_reg_le32(par->dc_regs, BLTCTL, 0x40005);\n\t\twhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x80);\n\t\twhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x40);\n\t}\n}\n\nstatic void\nimsttfb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tstruct imstt_par *par = info->par;\n\t__u32 Bpp, line_pitch, fb_offset_old, fb_offset_new, sp, dp_octl;\n \t__u32 cnt, bltctl, sx, sy, dx, dy, height, width;\n\n\tBpp = info->var.bits_per_pixel >> 3,\n\n\tsx = area->sx * Bpp;\n\tsy = area->sy;\n\tdx = area->dx * Bpp;\n\tdy = area->dy;\n\theight = area->height;\n\theight--;\n\twidth = area->width * Bpp;\n\twidth--;\n\n\tline_pitch = info->fix.line_length;\n\tbltctl = 0x05;\n\tsp = line_pitch << 16;\n\tcnt = height << 16;\n\n\tif (sy < dy) {\n\t\tsy += height;\n\t\tdy += height;\n\t\tsp |= -(line_pitch) & 0xffff;\n\t\tdp_octl = -(line_pitch) & 0xffff;\n\t} else {\n\t\tsp |= line_pitch;\n\t\tdp_octl = line_pitch;\n\t}\n\tif (sx < dx) {\n\t\tsx += width;\n\t\tdx += width;\n\t\tbltctl |= 0x80;\n\t\tcnt |= -(width) & 0xffff;\n\t} else {\n\t\tcnt |= width;\n\t}\n\tfb_offset_old = sy * line_pitch + sx;\n\tfb_offset_new = dy * line_pitch + dx;\n\n\twhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x80);\n\twrite_reg_le32(par->dc_regs, S1SA, fb_offset_old);\n\twrite_reg_le32(par->dc_regs, SP, sp);\n\twrite_reg_le32(par->dc_regs, DSA, fb_offset_new);\n\twrite_reg_le32(par->dc_regs, CNT, cnt);\n\twrite_reg_le32(par->dc_regs, DP_OCTL, dp_octl);\n\twrite_reg_le32(par->dc_regs, BLTCTL, bltctl);\n\twhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x80);\n\twhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x40);\n}\n\n#if 0\nstatic int\nimsttfb_load_cursor_image(struct imstt_par *par, int width, int height, __u8 fgc)\n{\n\tu_int x, y;\n\n\tif (width > 32 || height > 32)\n\t\treturn -EINVAL;\n\n\tif (par->ramdac == IBM) {\n\t\tpar->cmap_regs[PIDXHI] = 1;\teieio();\n\t\tfor (x = 0; x < 0x100; x++) {\n\t\t\tpar->cmap_regs[PIDXLO] = x;\t\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = 0x00;\teieio();\n\t\t}\n\t\tpar->cmap_regs[PIDXHI] = 1;\teieio();\n\t\tfor (y = 0; y < height; y++)\n\t\t\tfor (x = 0; x < width >> 2; x++) {\n\t\t\t\tpar->cmap_regs[PIDXLO] = x + y * 8;\teieio();\n\t\t\t\tpar->cmap_regs[PIDXDATA] = 0xff;\teieio();\n\t\t\t}\n\t\tpar->cmap_regs[PIDXHI] = 0;\t\teieio();\n\t\tpar->cmap_regs[PIDXLO] = CURS1R;\teieio();\n\t\tpar->cmap_regs[PIDXDATA] = fgc;\t\teieio();\n\t\tpar->cmap_regs[PIDXLO] = CURS1G;\teieio();\n\t\tpar->cmap_regs[PIDXDATA] = fgc;\t\teieio();\n\t\tpar->cmap_regs[PIDXLO] = CURS1B;\teieio();\n\t\tpar->cmap_regs[PIDXDATA] = fgc;\t\teieio();\n\t\tpar->cmap_regs[PIDXLO] = CURS2R;\teieio();\n\t\tpar->cmap_regs[PIDXDATA] = fgc;\t\teieio();\n\t\tpar->cmap_regs[PIDXLO] = CURS2G;\teieio();\n\t\tpar->cmap_regs[PIDXDATA] = fgc;\t\teieio();\n\t\tpar->cmap_regs[PIDXLO] = CURS2B;\teieio();\n\t\tpar->cmap_regs[PIDXDATA] = fgc;\t\teieio();\n\t\tpar->cmap_regs[PIDXLO] = CURS3R;\teieio();\n\t\tpar->cmap_regs[PIDXDATA] = fgc;\t\teieio();\n\t\tpar->cmap_regs[PIDXLO] = CURS3G;\teieio();\n\t\tpar->cmap_regs[PIDXDATA] = fgc;\t\teieio();\n\t\tpar->cmap_regs[PIDXLO] = CURS3B;\teieio();\n\t\tpar->cmap_regs[PIDXDATA] = fgc;\t\teieio();\n\t} else {\n\t\tpar->cmap_regs[TVPADDRW] = TVPIRICC;\teieio();\n\t\tpar->cmap_regs[TVPIDATA] &= 0x03;\teieio();\n\t\tpar->cmap_regs[TVPADDRW] = 0;\t\teieio();\n\t\tfor (x = 0; x < 0x200; x++) {\n\t\t\tpar->cmap_regs[TVPCRDAT] = 0x00;\teieio();\n\t\t}\n\t\tfor (x = 0; x < 0x200; x++) {\n\t\t\tpar->cmap_regs[TVPCRDAT] = 0xff;\teieio();\n\t\t}\n\t\tpar->cmap_regs[TVPADDRW] = TVPIRICC;\teieio();\n\t\tpar->cmap_regs[TVPIDATA] &= 0x03;\teieio();\n\t\tfor (y = 0; y < height; y++)\n\t\t\tfor (x = 0; x < width >> 3; x++) {\n\t\t\t\tpar->cmap_regs[TVPADDRW] = x + y * 8;\teieio();\n\t\t\t\tpar->cmap_regs[TVPCRDAT] = 0xff;\t\teieio();\n\t\t\t}\n\t\tpar->cmap_regs[TVPADDRW] = TVPIRICC;\teieio();\n\t\tpar->cmap_regs[TVPIDATA] |= 0x08;\teieio();\n\t\tfor (y = 0; y < height; y++)\n\t\t\tfor (x = 0; x < width >> 3; x++) {\n\t\t\t\tpar->cmap_regs[TVPADDRW] = x + y * 8;\teieio();\n\t\t\t\tpar->cmap_regs[TVPCRDAT] = 0xff;\t\teieio();\n\t\t\t}\n\t\tpar->cmap_regs[TVPCADRW] = 0x00;\teieio();\n\t\tfor (x = 0; x < 12; x++) {\n\t\t\tpar->cmap_regs[TVPCDATA] = fgc;\n\t\t\teieio();\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void\nimstt_set_cursor(struct imstt_par *par, struct fb_image *d, int on)\n{\n\tif (par->ramdac == IBM) {\n\t\tpar->cmap_regs[PIDXHI] = 0;\teieio();\n\t\tif (!on) {\n\t\t\tpar->cmap_regs[PIDXLO] = CURSCTL;\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = 0x00;\teieio();\n\t\t} else {\n\t\t\tpar->cmap_regs[PIDXLO] = CURSXHI;\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = d->dx >> 8;\teieio();\n\t\t\tpar->cmap_regs[PIDXLO] = CURSXLO;\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = d->dx & 0xff;eieio();\n\t\t\tpar->cmap_regs[PIDXLO] = CURSYHI;\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = d->dy >> 8;\teieio();\n\t\t\tpar->cmap_regs[PIDXLO] = CURSYLO;\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = d->dy & 0xff;eieio();\n\t\t\tpar->cmap_regs[PIDXLO] = CURSCTL;\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = 0x02;\teieio();\n\t\t}\n\t} else {\n\t\tif (!on) {\n\t\t\tpar->cmap_regs[TVPADDRW] = TVPIRICC;\teieio();\n\t\t\tpar->cmap_regs[TVPIDATA] = 0x00;\teieio();\n\t\t} else {\n\t\t\t__u16 x = d->dx + 0x40, y = d->dy + 0x40;\n\n\t\t\tpar->cmap_regs[TVPCXPOH] = x >> 8;\teieio();\n\t\t\tpar->cmap_regs[TVPCXPOL] = x & 0xff;\teieio();\n\t\t\tpar->cmap_regs[TVPCYPOH] = y >> 8;\teieio();\n\t\t\tpar->cmap_regs[TVPCYPOL] = y & 0xff;\teieio();\n\t\t\tpar->cmap_regs[TVPADDRW] = TVPIRICC;\teieio();\n\t\t\tpar->cmap_regs[TVPIDATA] = 0x02;\teieio();\n\t\t}\n\t}\n}\n\nstatic int\nimsttfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\tstruct imstt_par *par = info->par;\n        u32 flags = cursor->set, fg, bg, xx, yy;\n\n\tif (cursor->dest == NULL && cursor->rop == ROP_XOR)\n\t\treturn 1;\n\n\timstt_set_cursor(info, cursor, 0);\n\n\tif (flags & FB_CUR_SETPOS) {\n\t\txx = cursor->image.dx - info->var.xoffset;\n\t\tyy = cursor->image.dy - info->var.yoffset;\n\t}\n\n\tif (flags & FB_CUR_SETSIZE) {\n        }\n\n        if (flags & (FB_CUR_SETSHAPE | FB_CUR_SETCMAP)) {\n                int fg_idx = cursor->image.fg_color;\n                int width = (cursor->image.width+7)/8;\n                u8 *dat = (u8 *) cursor->image.data;\n                u8 *dst = (u8 *) cursor->dest;\n                u8 *msk = (u8 *) cursor->mask;\n\n                switch (cursor->rop) {\n                case ROP_XOR:\n                        for (i = 0; i < cursor->image.height; i++) {\n                                for (j = 0; j < width; j++) {\n                                        d_idx = i * MAX_CURS/8  + j;\n                                        data[d_idx] =  byte_rev[dat[s_idx] ^\n                                                                dst[s_idx]];\n                                        mask[d_idx] = byte_rev[msk[s_idx]];\n                                        s_idx++;\n                                }\n                        }\n                        break;\n                case ROP_COPY:\n                default:\n                        for (i = 0; i < cursor->image.height; i++) {\n                                for (j = 0; j < width; j++) {\n                                        d_idx = i * MAX_CURS/8 + j;\n                                        data[d_idx] = byte_rev[dat[s_idx]];\n                                        mask[d_idx] = byte_rev[msk[s_idx]];\n                                        s_idx++;\n                                }\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tfg = ((info->cmap.red[fg_idx] & 0xf8) << 7) |\n                     ((info->cmap.green[fg_idx] & 0xf8) << 2) |\n                     ((info->cmap.blue[fg_idx] & 0xf8) >> 3) | 1 << 15;\n\n\t\timsttfb_load_cursor_image(par, xx, yy, fgc);\n\t}\n\tif (cursor->enable)\n\t\timstt_set_cursor(info, cursor, 1);\n\treturn 0;\n}\n#endif\n\n#define FBIMSTT_SETREG\t\t0x545401\n#define FBIMSTT_GETREG\t\t0x545402\n#define FBIMSTT_SETCMAPREG\t0x545403\n#define FBIMSTT_GETCMAPREG\t0x545404\n#define FBIMSTT_SETIDXREG\t0x545405\n#define FBIMSTT_GETIDXREG\t0x545406\n\nstatic int\nimsttfb_ioctl(struct fb_info *info, u_int cmd, u_long arg)\n{\n\tstruct imstt_par *par = info->par;\n\tvoid __user *argp = (void __user *)arg;\n\t__u32 reg[2];\n\t__u8 idx[2];\n\n\tswitch (cmd) {\n\t\tcase FBIMSTT_SETREG:\n\t\t\tif (copy_from_user(reg, argp, 8) || reg[0] > (0x1000 - sizeof(reg[0])) / sizeof(reg[0]))\n\t\t\t\treturn -EFAULT;\n\t\t\twrite_reg_le32(par->dc_regs, reg[0], reg[1]);\n\t\t\treturn 0;\n\t\tcase FBIMSTT_GETREG:\n\t\t\tif (copy_from_user(reg, argp, 4) || reg[0] > (0x1000 - sizeof(reg[0])) / sizeof(reg[0]))\n\t\t\t\treturn -EFAULT;\n\t\t\treg[1] = read_reg_le32(par->dc_regs, reg[0]);\n\t\t\tif (copy_to_user((void __user *)(arg + 4), &reg[1], 4))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\tcase FBIMSTT_SETCMAPREG:\n\t\t\tif (copy_from_user(reg, argp, 8) || reg[0] > (0x1000 - sizeof(reg[0])) / sizeof(reg[0]))\n\t\t\t\treturn -EFAULT;\n\t\t\twrite_reg_le32(((u_int __iomem *)par->cmap_regs), reg[0], reg[1]);\n\t\t\treturn 0;\n\t\tcase FBIMSTT_GETCMAPREG:\n\t\t\tif (copy_from_user(reg, argp, 4) || reg[0] > (0x1000 - sizeof(reg[0])) / sizeof(reg[0]))\n\t\t\t\treturn -EFAULT;\n\t\t\treg[1] = read_reg_le32(((u_int __iomem *)par->cmap_regs), reg[0]);\n\t\t\tif (copy_to_user((void __user *)(arg + 4), &reg[1], 4))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\tcase FBIMSTT_SETIDXREG:\n\t\t\tif (copy_from_user(idx, argp, 2))\n\t\t\t\treturn -EFAULT;\n\t\t\tpar->cmap_regs[PIDXHI] = 0;\t\teieio();\n\t\t\tpar->cmap_regs[PIDXLO] = idx[0];\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = idx[1];\teieio();\n\t\t\treturn 0;\n\t\tcase FBIMSTT_GETIDXREG:\n\t\t\tif (copy_from_user(idx, argp, 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tpar->cmap_regs[PIDXHI] = 0;\t\teieio();\n\t\t\tpar->cmap_regs[PIDXLO] = idx[0];\teieio();\n\t\t\tidx[1] = par->cmap_regs[PIDXDATA];\n\t\t\tif (copy_to_user((void __user *)(arg + 1), &idx[1], 1))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic const struct pci_device_id imsttfb_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_IMS, PCI_DEVICE_ID_IMS_TT128,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, IBM },\n\t{ PCI_VENDOR_ID_IMS, PCI_DEVICE_ID_IMS_TT3D,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, TVP },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, imsttfb_pci_tbl);\n\nstatic struct pci_driver imsttfb_pci_driver = {\n\t.name =\t\t\"imsttfb\",\n\t.id_table =\timsttfb_pci_tbl,\n\t.probe =\timsttfb_probe,\n\t.remove =\timsttfb_remove,\n};\n\nstatic const struct fb_ops imsttfb_ops = {\n\t.owner \t\t= THIS_MODULE,\n\t.fb_check_var\t= imsttfb_check_var,\n\t.fb_set_par \t= imsttfb_set_par,\n\t.fb_setcolreg \t= imsttfb_setcolreg,\n\t.fb_pan_display = imsttfb_pan_display,\n\t.fb_blank \t= imsttfb_blank,\n\t.fb_fillrect\t= imsttfb_fillrect,\n\t.fb_copyarea\t= imsttfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n\t.fb_ioctl \t= imsttfb_ioctl,\n};\n\nstatic int init_imstt(struct fb_info *info)\n{\n\tstruct imstt_par *par = info->par;\n\t__u32 i, tmp, *ip, *end;\n\n\ttmp = read_reg_le32(par->dc_regs, PRC);\n\tif (par->ramdac == IBM)\n\t\tinfo->fix.smem_len = (tmp & 0x0004) ? 0x400000 : 0x200000;\n\telse\n\t\tinfo->fix.smem_len = 0x800000;\n\n\tip = (__u32 *)info->screen_base;\n\tend = (__u32 *)(info->screen_base + info->fix.smem_len);\n\twhile (ip < end)\n\t\t*ip++ = 0;\n\n\t \n\ttmp = read_reg_le32(par->dc_regs, STGCTL);\n\twrite_reg_le32(par->dc_regs, STGCTL, tmp & ~0x1);\n\twrite_reg_le32(par->dc_regs, SSR, 0);\n\n\t \n\tif (par->ramdac == IBM) {\n\t\tpar->cmap_regs[PPMASK] = 0xff;\n\t\teieio();\n\t\tpar->cmap_regs[PIDXHI] = 0;\n\t\teieio();\n\t\tfor (i = 0; i < ARRAY_SIZE(ibm_initregs); i++) {\n\t\t\tpar->cmap_regs[PIDXLO] = ibm_initregs[i].addr;\n\t\t\teieio();\n\t\t\tpar->cmap_regs[PIDXDATA] = ibm_initregs[i].value;\n\t\t\teieio();\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(tvp_initregs); i++) {\n\t\t\tpar->cmap_regs[TVPADDRW] = tvp_initregs[i].addr;\n\t\t\teieio();\n\t\t\tpar->cmap_regs[TVPIDATA] = tvp_initregs[i].value;\n\t\t\teieio();\n\t\t}\n\t}\n\n#if defined(CONFIG_PPC_PMAC) && defined(CONFIG_PPC32)\n\tif (IS_REACHABLE(CONFIG_NVRAM) && machine_is(powermac)) {\n\t\tint vmode = init_vmode, cmode = init_cmode;\n\n\t\tif (vmode == -1) {\n\t\t\tvmode = nvram_read_byte(NV_VMODE);\n\t\t\tif (vmode <= 0 || vmode > VMODE_MAX)\n\t\t\t\tvmode = VMODE_640_480_67;\n\t\t}\n\t\tif (cmode == -1) {\n\t\t\tcmode = nvram_read_byte(NV_CMODE);\n\t\t\tif (cmode < CMODE_8 || cmode > CMODE_32)\n\t\t\t\tcmode = CMODE_8;\n\t\t}\n\t\tif (mac_vmode_to_var(vmode, cmode, &info->var)) {\n\t\t\tinfo->var.xres = info->var.xres_virtual = INIT_XRES;\n\t\t\tinfo->var.yres = info->var.yres_virtual = INIT_YRES;\n\t\t\tinfo->var.bits_per_pixel = INIT_BPP;\n\t\t}\n\t} else\n#endif\n\t{\n\t\tinfo->var.xres = info->var.xres_virtual = INIT_XRES;\n\t\tinfo->var.yres = info->var.yres_virtual = INIT_YRES;\n\t\tinfo->var.bits_per_pixel = INIT_BPP;\n\t}\n\n\tif ((info->var.xres * info->var.yres) * (info->var.bits_per_pixel >> 3) > info->fix.smem_len\n\t    || !(compute_imstt_regvals(par, info->var.xres, info->var.yres))) {\n\t\tprintk(\"imsttfb: %ux%ux%u not supported\\n\", info->var.xres, info->var.yres, info->var.bits_per_pixel);\n\t\treturn -ENODEV;\n\t}\n\n\tsprintf(info->fix.id, \"IMS TT (%s)\", par->ramdac == IBM ? \"IBM\" : \"TVP\");\n\tinfo->fix.mmio_len = 0x1000;\n\tinfo->fix.accel = FB_ACCEL_IMS_TWINTURBO;\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = info->var.bits_per_pixel == 8 ? FB_VISUAL_PSEUDOCOLOR\n\t\t\t\t\t\t\t: FB_VISUAL_DIRECTCOLOR;\n\tinfo->fix.line_length = info->var.xres * (info->var.bits_per_pixel >> 3);\n\tinfo->fix.xpanstep = 8;\n\tinfo->fix.ypanstep = 1;\n\tinfo->fix.ywrapstep = 0;\n\n\tinfo->var.accel_flags = FB_ACCELF_TEXT;\n\n\n\n\tif (info->var.green.length == 6)\n\t\tset_565(par);\n\telse\n\t\tset_555(par);\n\tset_imstt_regvals(info, info->var.bits_per_pixel);\n\n\tinfo->var.pixclock = 1000000 / getclkMHz(par);\n\n\tinfo->fbops = &imsttfb_ops;\n\tinfo->flags = FBINFO_HWACCEL_COPYAREA |\n\t              FBINFO_HWACCEL_FILLRECT |\n\t              FBINFO_HWACCEL_YPAN;\n\n\tif (fb_alloc_cmap(&info->cmap, 0, 0))\n\t\treturn -ENODEV;\n\n\tif (register_framebuffer(info) < 0) {\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\treturn -ENODEV;\n\t}\n\n\ttmp = (read_reg_le32(par->dc_regs, SSTATUS) & 0x0f00) >> 8;\n\tfb_info(info, \"%s frame buffer; %uMB vram; chip version %u\\n\",\n\t\tinfo->fix.id, info->fix.smem_len >> 20, tmp);\n\treturn 0;\n}\n\nstatic int imsttfb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tunsigned long addr, size;\n\tstruct imstt_par *par;\n\tstruct fb_info *info;\n\tstruct device_node *dp;\n\tint ret;\n\n\tret = aperture_remove_conflicting_pci_devices(pdev, \"imsttfb\");\n\tif (ret)\n\t\treturn ret;\n\tret = -ENOMEM;\n\n\tdp = pci_device_to_OF_node(pdev);\n\tif(dp)\n\t\tprintk(KERN_INFO \"%s: OF name %pOFn\\n\",__func__, dp);\n\telse if (IS_ENABLED(CONFIG_OF))\n\t\tprintk(KERN_ERR \"imsttfb: no OF node for pci device\\n\");\n\n\tinfo = framebuffer_alloc(sizeof(struct imstt_par), &pdev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\n\taddr = pci_resource_start (pdev, 0);\n\tsize = pci_resource_len (pdev, 0);\n\n\tif (!request_mem_region(addr, size, \"imsttfb\")) {\n\t\tprintk(KERN_ERR \"imsttfb: Can't reserve memory region\\n\");\n\t\tret = -ENODEV;\n\t\tgoto release_info;\n\t}\n\n\tswitch (pdev->device) {\n\t\tcase PCI_DEVICE_ID_IMS_TT128:  \n\t\t\tpar->ramdac = IBM;\n\t\t\tif (of_node_name_eq(dp, \"IMS,tt128mb8\") ||\n\t\t\t    of_node_name_eq(dp, \"IMS,tt128mb8A\"))\n\t\t\t\tpar->ramdac = TVP;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_IMS_TT3D:   \n\t\t\tpar->ramdac = TVP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_INFO \"imsttfb: Device 0x%x unknown, \"\n\t\t\t\t\t \"contact maintainer.\\n\", pdev->device);\n\t\t\tret = -ENODEV;\n\t\t\tgoto release_mem_region;\n\t}\n\n\tinfo->fix.smem_start = addr;\n\tinfo->screen_base = (__u8 *)ioremap(addr, par->ramdac == IBM ?\n\t\t\t\t\t    0x400000 : 0x800000);\n\tif (!info->screen_base)\n\t\tgoto release_mem_region;\n\tinfo->fix.mmio_start = addr + 0x800000;\n\tpar->dc_regs = ioremap(addr + 0x800000, 0x1000);\n\tif (!par->dc_regs)\n\t\tgoto unmap_screen_base;\n\tpar->cmap_regs_phys = addr + 0x840000;\n\tpar->cmap_regs = (__u8 *)ioremap(addr + 0x840000, 0x1000);\n\tif (!par->cmap_regs)\n\t\tgoto unmap_dc_regs;\n\tinfo->pseudo_palette = par->palette;\n\tret = init_imstt(info);\n\tif (ret)\n\t\tgoto unmap_cmap_regs;\n\n\tpci_set_drvdata(pdev, info);\n\treturn 0;\n\nunmap_cmap_regs:\n\tiounmap(par->cmap_regs);\nunmap_dc_regs:\n\tiounmap(par->dc_regs);\nunmap_screen_base:\n\tiounmap(info->screen_base);\nrelease_mem_region:\n\trelease_mem_region(addr, size);\nrelease_info:\n\tframebuffer_release(info);\n\treturn ret;\n}\n\nstatic void imsttfb_remove(struct pci_dev *pdev)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct imstt_par *par = info->par;\n\tint size = pci_resource_len(pdev, 0);\n\n\tunregister_framebuffer(info);\n\tiounmap(par->cmap_regs);\n\tiounmap(par->dc_regs);\n\tiounmap(info->screen_base);\n\trelease_mem_region(info->fix.smem_start, size);\n\tframebuffer_release(info);\n}\n\n#ifndef MODULE\nstatic int __init\nimsttfb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!strncmp(this_opt, \"font:\", 5)) {\n\t\t\tchar *p;\n\t\t\tint i;\n\n\t\t\tp = this_opt + 5;\n\t\t\tfor (i = 0; i < sizeof(fontname) - 1; i++)\n\t\t\t\tif (!*p || *p == ' ' || *p == ',')\n\t\t\t\t\tbreak;\n\t\t\tmemcpy(fontname, this_opt + 5, i);\n\t\t\tfontname[i] = 0;\n\t\t} else if (!strncmp(this_opt, \"inverse\", 7)) {\n\t\t\tinverse = 1;\n\t\t\tfb_invert_cmaps();\n\t\t}\n#if defined(CONFIG_PPC_PMAC)\n\t\telse if (!strncmp(this_opt, \"vmode:\", 6)) {\n\t\t\tint vmode = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\tif (vmode > 0 && vmode <= VMODE_MAX)\n\t\t\t\tinit_vmode = vmode;\n\t\t} else if (!strncmp(this_opt, \"cmode:\", 6)) {\n\t\t\tint cmode = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\tswitch (cmode) {\n\t\t\t\tcase CMODE_8:\n\t\t\t\tcase 8:\n\t\t\t\t\tinit_cmode = CMODE_8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CMODE_16:\n\t\t\t\tcase 15:\n\t\t\t\tcase 16:\n\t\t\t\t\tinit_cmode = CMODE_16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CMODE_32:\n\t\t\t\tcase 24:\n\t\t\t\tcase 32:\n\t\t\t\t\tinit_cmode = CMODE_32;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\treturn 0;\n}\n\n#endif  \n\nstatic int __init imsttfb_init(void)\n{\n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"imsttfb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"imsttfb\", &option))\n\t\treturn -ENODEV;\n\n\timsttfb_setup(option);\n#endif\n\treturn pci_register_driver(&imsttfb_pci_driver);\n}\n\nstatic void __exit imsttfb_exit(void)\n{\n\tpci_unregister_driver(&imsttfb_pci_driver);\n}\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(imsttfb_init);\nmodule_exit(imsttfb_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}