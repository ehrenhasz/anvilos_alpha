{
  "module_name": "c2p_planar.c",
  "hash_id": "126b0d0cfc3fe035eab0ea2156191f0ecc773cf6684b2394cbce4e8c2735c894",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/c2p_planar.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/string.h>\n\n#include <asm/unaligned.h>\n\n#include \"c2p.h\"\n#include \"c2p_core.h\"\n\n\n     \n\nstatic void c2p_32x8(u32 d[8])\n{\n\ttransp8(d, 16, 4);\n\ttransp8(d, 8, 2);\n\ttransp8(d, 4, 1);\n\ttransp8(d, 2, 4);\n\ttransp8(d, 1, 2);\n}\n\n\n     \n\nstatic const int perm_c2p_32x8[8] = { 7, 5, 3, 1, 6, 4, 2, 0 };\n\n\n     \n\nstatic inline void store_planar(void *dst, u32 dst_inc, u32 bpp, u32 d[8])\n{\n\tint i;\n\n\tfor (i = 0; i < bpp; i++, dst += dst_inc)\n\t\tput_unaligned_be32(d[perm_c2p_32x8[i]], dst);\n}\n\n\n     \n\nstatic inline void store_planar_masked(void *dst, u32 dst_inc, u32 bpp,\n\t\t\t\t       u32 d[8], u32 mask)\n{\n\tint i;\n\n\tfor (i = 0; i < bpp; i++, dst += dst_inc)\n\t\tput_unaligned_be32(comp(d[perm_c2p_32x8[i]],\n\t\t\t\t\tget_unaligned_be32(dst), mask),\n\t\t\t\t   dst);\n}\n\n\n     \n\nvoid c2p_planar(void *dst, const void *src, u32 dx, u32 dy, u32 width,\n\t\tu32 height, u32 dst_nextline, u32 dst_nextplane,\n\t\tu32 src_nextline, u32 bpp)\n{\n\tunion {\n\t\tu8 pixels[32];\n\t\tu32 words[8];\n\t} d;\n\tu32 dst_idx, first, last, w;\n\tconst u8 *c;\n\tvoid *p;\n\n\tdst += dy*dst_nextline+(dx & ~31);\n\tdst_idx = dx % 32;\n\tfirst = 0xffffffffU >> dst_idx;\n\tlast = ~(0xffffffffU >> ((dst_idx+width) % 32));\n\twhile (height--) {\n\t\tc = src;\n\t\tp = dst;\n\t\tw = width;\n\t\tif (dst_idx+width <= 32) {\n\t\t\t \n\t\t\tfirst &= last;\n\t\t\tmemset(d.pixels, 0, sizeof(d));\n\t\t\tmemcpy(d.pixels+dst_idx, c, width);\n\t\t\tc += width;\n\t\t\tc2p_32x8(d.words);\n\t\t\tstore_planar_masked(p, dst_nextplane, bpp, d.words,\n\t\t\t\t\t    first);\n\t\t\tp += 4;\n\t\t} else {\n\t\t\t \n\t\t\tw = width;\n\t\t\t \n\t\t\tif (dst_idx) {\n\t\t\t\tw = 32 - dst_idx;\n\t\t\t\tmemset(d.pixels, 0, dst_idx);\n\t\t\t\tmemcpy(d.pixels+dst_idx, c, w);\n\t\t\t\tc += w;\n\t\t\t\tc2p_32x8(d.words);\n\t\t\t\tstore_planar_masked(p, dst_nextplane, bpp,\n\t\t\t\t\t\t    d.words, first);\n\t\t\t\tp += 4;\n\t\t\t\tw = width-w;\n\t\t\t}\n\t\t\t \n\t\t\twhile (w >= 32) {\n\t\t\t\tmemcpy(d.pixels, c, 32);\n\t\t\t\tc += 32;\n\t\t\t\tc2p_32x8(d.words);\n\t\t\t\tstore_planar(p, dst_nextplane, bpp, d.words);\n\t\t\t\tp += 4;\n\t\t\t\tw -= 32;\n\t\t\t}\n\t\t\t \n\t\t\tw %= 32;\n\t\t\tif (w > 0) {\n\t\t\t\tmemcpy(d.pixels, c, w);\n\t\t\t\tmemset(d.pixels+w, 0, 32-w);\n\t\t\t\tc2p_32x8(d.words);\n\t\t\t\tstore_planar_masked(p, dst_nextplane, bpp,\n\t\t\t\t\t\t    d.words, last);\n\t\t\t}\n\t\t}\n\t\tsrc += src_nextline;\n\t\tdst += dst_nextline;\n\t}\n}\nEXPORT_SYMBOL_GPL(c2p_planar);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}