{
  "module_name": "gxt4500.c",
  "hash_id": "6a67bc813dcf30c76bcc3b2fee5469870fa707fd7cc275ec110c3c0786f16148",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/gxt4500.c",
  "human_readable_source": "\n \n\n#include <linux/aperture.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/fb.h>\n#include <linux/console.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n\n#define PCI_DEVICE_ID_IBM_GXT4500P\t0x21c\n#define PCI_DEVICE_ID_IBM_GXT6500P\t0x21b\n#define PCI_DEVICE_ID_IBM_GXT4000P\t0x16e\n#define PCI_DEVICE_ID_IBM_GXT6000P\t0x170\n\n \n\n \n#define CFG_ENDIAN0\t\t0x40\n\n \n#define STATUS\t\t\t0x1000\n#define CTRL_REG0\t\t0x1004\n#define   CR0_HALT_DMA\t\t\t0x4\n#define   CR0_RASTER_RESET\t\t0x8\n#define   CR0_GEOM_RESET\t\t0x10\n#define   CR0_MEM_CTRLER_RESET\t\t0x20\n\n \n#define FB_AB_CTRL\t\t0x1100\n#define FB_CD_CTRL\t\t0x1104\n#define FB_WID_CTRL\t\t0x1108\n#define FB_Z_CTRL\t\t0x110c\n#define FB_VGA_CTRL\t\t0x1110\n#define REFRESH_AB_CTRL\t\t0x1114\n#define REFRESH_CD_CTRL\t\t0x1118\n#define FB_OVL_CTRL\t\t0x111c\n#define   FB_CTRL_TYPE\t\t\t0x80000000\n#define   FB_CTRL_WIDTH_MASK\t\t0x007f0000\n#define   FB_CTRL_WIDTH_SHIFT\t\t16\n#define   FB_CTRL_START_SEG_MASK\t0x00003fff\n\n#define REFRESH_START\t\t0x1098\n#define REFRESH_SIZE\t\t0x109c\n\n \n#define DFA_FB_A\t\t0x11e0\n#define DFA_FB_B\t\t0x11e4\n#define DFA_FB_C\t\t0x11e8\n#define DFA_FB_D\t\t0x11ec\n#define   DFA_FB_ENABLE\t\t\t0x80000000\n#define   DFA_FB_BASE_MASK\t\t0x03f00000\n#define   DFA_FB_STRIDE_1k\t\t0x00000000\n#define   DFA_FB_STRIDE_2k\t\t0x00000010\n#define   DFA_FB_STRIDE_4k\t\t0x00000020\n#define   DFA_PIX_8BIT\t\t\t0x00000000\n#define   DFA_PIX_16BIT_565\t\t0x00000001\n#define   DFA_PIX_16BIT_1555\t\t0x00000002\n#define   DFA_PIX_24BIT\t\t\t0x00000004\n#define   DFA_PIX_32BIT\t\t\t0x00000005\n\n \nstatic const unsigned char pixsize[] = {\n\t1, 2, 2, 2, 4, 4\n};\n\n \n#define DTG_CONTROL\t\t0x1900\n#define   DTG_CTL_SCREEN_REFRESH\t2\n#define   DTG_CTL_ENABLE\t\t1\n#define DTG_HORIZ_EXTENT\t0x1904\n#define DTG_HORIZ_DISPLAY\t0x1908\n#define DTG_HSYNC_START\t\t0x190c\n#define DTG_HSYNC_END\t\t0x1910\n#define DTG_HSYNC_END_COMP\t0x1914\n#define DTG_VERT_EXTENT\t\t0x1918\n#define DTG_VERT_DISPLAY\t0x191c\n#define DTG_VSYNC_START\t\t0x1920\n#define DTG_VSYNC_END\t\t0x1924\n#define DTG_VERT_SHORT\t\t0x1928\n\n \n#define DISP_CTL\t\t0x402c\n#define   DISP_CTL_OFF\t\t\t2\n#define SYNC_CTL\t\t0x4034\n#define   SYNC_CTL_SYNC_ON_RGB\t\t1\n#define   SYNC_CTL_SYNC_OFF\t\t2\n#define   SYNC_CTL_HSYNC_INV\t\t8\n#define   SYNC_CTL_VSYNC_INV\t\t0x10\n#define   SYNC_CTL_HSYNC_OFF\t\t0x20\n#define   SYNC_CTL_VSYNC_OFF\t\t0x40\n\n#define PLL_M\t\t\t0x4040\n#define PLL_N\t\t\t0x4044\n#define PLL_POSTDIV\t\t0x4048\n#define PLL_C\t\t\t0x404c\n\n \n#define CURSOR_X\t\t0x4078\n#define CURSOR_Y\t\t0x407c\n#define CURSOR_HOTSPOT\t\t0x4080\n#define CURSOR_MODE\t\t0x4084\n#define   CURSOR_MODE_OFF\t\t0\n#define   CURSOR_MODE_4BPP\t\t1\n#define CURSOR_PIXMAP\t\t0x5000\n#define CURSOR_CMAP\t\t0x7400\n\n \n#define WAT_FMT\t\t\t0x4100\n#define   WAT_FMT_24BIT\t\t\t0\n#define   WAT_FMT_16BIT_565\t\t1\n#define   WAT_FMT_16BIT_1555\t\t2\n#define   WAT_FMT_32BIT\t\t\t3\t \n#define   WAT_FMT_8BIT_332\t\t9\n#define   WAT_FMT_8BIT\t\t\t0xa\n#define   WAT_FMT_NO_CMAP\t\t4\t \n#define WAT_CMAP_OFFSET\t\t0x4104\t\t \n#define WAT_CTRL\t\t0x4108\n#define   WAT_CTRL_SEL_B\t\t1\t \n#define   WAT_CTRL_NO_INC\t\t2\n#define WAT_GAMMA_CTRL\t\t0x410c\n#define   WAT_GAMMA_DISABLE\t\t1\t \n#define WAT_OVL_CTRL\t\t0x430c\t\t \n\n \nstatic const unsigned char watfmt[] = {\n\tWAT_FMT_8BIT, WAT_FMT_16BIT_565, WAT_FMT_16BIT_1555, 0,\n\tWAT_FMT_24BIT, WAT_FMT_32BIT\n};\n\n \n#define CMAP\t\t\t0x6000\n\n#define readreg(par, reg)\treadl((par)->regs + (reg))\n#define writereg(par, reg, val)\twritel((val), (par)->regs + (reg))\n\nstruct gxt4500_par {\n\tvoid __iomem *regs;\n\tint wc_cookie;\n\tint pixfmt;\t\t \n\n\t \n\tint refclk_ps;\t\t \n\tint pll_m;\t\t \n\tint pll_n;\t\t \n\tint pll_pd1;\t\t \n\tint pll_pd2;\t\t \n\n\tu32 pseudo_palette[16];\t \n};\n\n \nstatic char *mode_option;\n\n \nstatic const struct fb_videomode defaultmode = {\n\t.refresh = 60,\n\t.xres = 1280,\n\t.yres = 1024,\n\t.pixclock = 9295,\n\t.left_margin = 248,\n\t.right_margin = 48,\n\t.upper_margin = 38,\n\t.lower_margin = 1,\n\t.hsync_len = 112,\n\t.vsync_len = 3,\n\t.vmode = FB_VMODE_NONINTERLACED\n};\n\n \nenum gxt_cards {\n\tGXT4500P,\n\tGXT6500P,\n\tGXT4000P,\n\tGXT6000P\n};\n\n \nstatic const struct cardinfo {\n\tint\trefclk_ps;\t \n\tconst char *cardname;\n} cardinfo[] = {\n\t[GXT4500P] = { .refclk_ps = 9259, .cardname = \"IBM GXT4500P\" },\n\t[GXT6500P] = { .refclk_ps = 9259, .cardname = \"IBM GXT6500P\" },\n\t[GXT4000P] = { .refclk_ps = 40000, .cardname = \"IBM GXT4000P\" },\n\t[GXT6000P] = { .refclk_ps = 40000, .cardname = \"IBM GXT6000P\" },\n};\n\n \n\nstatic const unsigned char mdivtab[] = {\n \t\t      0x3f, 0x00, 0x20, 0x10, 0x28, 0x14, 0x2a, 0x15, 0x0a,\n \t0x25, 0x32, 0x19, 0x0c, 0x26, 0x13, 0x09, 0x04, 0x22, 0x11,\n \t0x08, 0x24, 0x12, 0x29, 0x34, 0x1a, 0x2d, 0x36, 0x1b, 0x0d,\n \t0x06, 0x23, 0x31, 0x38, 0x1c, 0x2e, 0x17, 0x0b, 0x05, 0x02,\n \t0x21, 0x30, 0x18, 0x2c, 0x16, 0x2b, 0x35, 0x3a, 0x1d, 0x0e,\n \t0x27, 0x33, 0x39, 0x3c, 0x1e, 0x2f, 0x37, 0x3b, 0x3d, 0x3e,\n \t0x1f, 0x0f, 0x07, 0x03, 0x01,\n};\n\nstatic const unsigned char ndivtab[] = {\n \t\t            0x00, 0x80, 0xc0, 0xe0, 0xf0, 0x78, 0xbc, 0x5e,\n \t0x2f, 0x17, 0x0b, 0x85, 0xc2, 0xe1, 0x70, 0x38, 0x9c, 0x4e,\n \t0xa7, 0xd3, 0xe9, 0xf4, 0xfa, 0xfd, 0xfe, 0x7f, 0xbf, 0xdf,\n \t0xef, 0x77, 0x3b, 0x1d, 0x8e, 0xc7, 0xe3, 0x71, 0xb8, 0xdc,\n \t0x6e, 0xb7, 0x5b, 0x2d, 0x16, 0x8b, 0xc5, 0xe2, 0xf1, 0xf8,\n \t0xfc, 0x7e, 0x3f, 0x9f, 0xcf, 0x67, 0xb3, 0xd9, 0x6c, 0xb6,\n \t0xdb, 0x6d, 0x36, 0x9b, 0x4d, 0x26, 0x13, 0x89, 0xc4, 0x62,\n \t0xb1, 0xd8, 0xec, 0xf6, 0xfb, 0x7d, 0xbe, 0x5f, 0xaf, 0x57,\n \t0x2b, 0x95, 0x4a, 0x25, 0x92, 0x49, 0xa4, 0x52, 0x29, 0x94,\n \t0xca, 0x65, 0xb2, 0x59, 0x2c, 0x96, 0xcb, 0xe5, 0xf2, 0x79,\n \t0x3c, 0x1e, 0x0f, 0x07, 0x83, 0x41, 0x20, 0x90, 0x48, 0x24,\n \t0x12, 0x09, 0x84, 0x42, 0xa1, 0x50, 0x28, 0x14, 0x8a, 0x45,\n \t0xa2, 0xd1, 0xe8, 0x74, 0xba, 0xdd, 0xee, 0xf7, 0x7b, 0x3d,\n \t0x9e, 0x4f, 0x27, 0x93, 0xc9, 0xe4, 0x72, 0x39, 0x1c, 0x0e,\n \t0x87, 0xc3, 0x61, 0x30, 0x18, 0x8c, 0xc6, 0x63, 0x31, 0x98,\n \t0xcc, 0xe6, 0x73, 0xb9, 0x5c, 0x2e, 0x97, 0x4b, 0xa5, 0xd2,\n \t0x69,\n};\n\nstatic int calc_pll(int period_ps, struct gxt4500_par *par)\n{\n\tint m, n, pdiv1, pdiv2, postdiv;\n\tint pll_period, best_error, t, intf;\n\n\t \n\tif (period_ps < 3333 || period_ps > 200000)\n\t\treturn -1;\n\n\tbest_error = 1000000;\n\tfor (pdiv1 = 1; pdiv1 <= 8; ++pdiv1) {\n\t\tfor (pdiv2 = 1; pdiv2 <= pdiv1; ++pdiv2) {\n\t\t\tpostdiv = pdiv1 * pdiv2;\n\t\t\tpll_period = DIV_ROUND_UP(period_ps, postdiv);\n\t\t\t \n\t\t\tif (pll_period < 1666 || pll_period > 2857)\n\t\t\t\tcontinue;\n\t\t\tfor (m = 1; m <= 64; ++m) {\n\t\t\t\tintf = m * par->refclk_ps;\n\t\t\t\tif (intf > 500000)\n\t\t\t\t\tbreak;\n\t\t\t\tn = intf * postdiv / period_ps;\n\t\t\t\tif (n < 3 || n > 160)\n\t\t\t\t\tcontinue;\n\t\t\t\tt = par->refclk_ps * m * postdiv / n;\n\t\t\t\tt -= period_ps;\n\t\t\t\tif (t >= 0 && t < best_error) {\n\t\t\t\t\tpar->pll_m = m;\n\t\t\t\t\tpar->pll_n = n;\n\t\t\t\t\tpar->pll_pd1 = pdiv1;\n\t\t\t\t\tpar->pll_pd2 = pdiv2;\n\t\t\t\t\tbest_error = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (best_error == 1000000)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int calc_pixclock(struct gxt4500_par *par)\n{\n\treturn par->refclk_ps * par->pll_m * par->pll_pd1 * par->pll_pd2\n\t\t/ par->pll_n;\n}\n\nstatic int gxt4500_var_to_par(struct fb_var_screeninfo *var,\n\t\t\t      struct gxt4500_par *par)\n{\n\tif (var->xres + var->xoffset > var->xres_virtual ||\n\t    var->yres + var->yoffset > var->yres_virtual ||\n\t    var->xres_virtual > 4096)\n\t\treturn -EINVAL;\n\tif ((var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)\n\t\treturn -EINVAL;\n\n\tif (calc_pll(var->pixclock, par) < 0)\n\t\treturn -EINVAL;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 32:\n\t\tif (var->transp.length)\n\t\t\tpar->pixfmt = DFA_PIX_32BIT;\n\t\telse\n\t\t\tpar->pixfmt = DFA_PIX_24BIT;\n\t\tbreak;\n\tcase 24:\n\t\tpar->pixfmt = DFA_PIX_24BIT;\n\t\tbreak;\n\tcase 16:\n\t\tif (var->green.length == 5)\n\t\t\tpar->pixfmt = DFA_PIX_16BIT_1555;\n\t\telse\n\t\t\tpar->pixfmt = DFA_PIX_16BIT_565;\n\t\tbreak;\n\tcase 8:\n\t\tpar->pixfmt = DFA_PIX_8BIT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct fb_bitfield eightbits = {0, 8};\nstatic const struct fb_bitfield nobits = {0, 0};\n\nstatic void gxt4500_unpack_pixfmt(struct fb_var_screeninfo *var,\n\t\t\t\t  int pixfmt)\n{\n\tvar->bits_per_pixel = pixsize[pixfmt] * 8;\n\tvar->red = eightbits;\n\tvar->green = eightbits;\n\tvar->blue = eightbits;\n\tvar->transp = nobits;\n\n\tswitch (pixfmt) {\n\tcase DFA_PIX_16BIT_565:\n\t\tvar->red.length = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.length = 5;\n\t\tbreak;\n\tcase DFA_PIX_16BIT_1555:\n\t\tvar->red.length = 5;\n\t\tvar->green.length = 5;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.length = 1;\n\t\tbreak;\n\tcase DFA_PIX_32BIT:\n\t\tvar->transp.length = 8;\n\t\tbreak;\n\t}\n\tif (pixfmt != DFA_PIX_8BIT) {\n\t\tvar->blue.offset = 0;\n\t\tvar->green.offset = var->blue.length;\n\t\tvar->red.offset = var->green.offset + var->green.length;\n\t\tif (var->transp.length)\n\t\t\tvar->transp.offset =\n\t\t\t\tvar->red.offset + var->red.length;\n\t}\n}\n\nstatic int gxt4500_check_var(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tstruct gxt4500_par par;\n\tint err;\n\n\tpar = *(struct gxt4500_par *)info->par;\n\terr = gxt4500_var_to_par(var, &par);\n\tif (!err) {\n\t\tvar->pixclock = calc_pixclock(&par);\n\t\tgxt4500_unpack_pixfmt(var, par.pixfmt);\n\t}\n\treturn err;\n}\n\nstatic int gxt4500_set_par(struct fb_info *info)\n{\n\tstruct gxt4500_par *par = info->par;\n\tstruct fb_var_screeninfo *var = &info->var;\n\tint err;\n\tu32 ctrlreg, tmp;\n\tunsigned int dfa_ctl, pixfmt, stride;\n\tunsigned int wid_tiles, i;\n\tunsigned int prefetch_pix, htot;\n\tstruct gxt4500_par save_par;\n\n\tsave_par = *par;\n\terr = gxt4500_var_to_par(var, par);\n\tif (err) {\n\t\t*par = save_par;\n\t\treturn err;\n\t}\n\n\t \n\tctrlreg = readreg(par, DTG_CONTROL);\n\tctrlreg &= ~(DTG_CTL_ENABLE | DTG_CTL_SCREEN_REFRESH);\n\twritereg(par, DTG_CONTROL, ctrlreg);\n\n\t \n\ttmp = readreg(par, PLL_C) & ~0x7f;\n\tif (par->pll_n < 38)\n\t\ttmp |= 0x29;\n\tif (par->pll_n < 69)\n\t\ttmp |= 0x35;\n\telse if (par->pll_n < 100)\n\t\ttmp |= 0x76;\n\telse\n\t\ttmp |= 0x7e;\n\twritereg(par, PLL_C, tmp);\n\twritereg(par, PLL_M, mdivtab[par->pll_m - 1]);\n\twritereg(par, PLL_N, ndivtab[par->pll_n - 2]);\n\ttmp = ((8 - par->pll_pd2) << 3) | (8 - par->pll_pd1);\n\tif (par->pll_pd1 == 8 || par->pll_pd2 == 8) {\n\t\t \n\t\twritereg(par, PLL_POSTDIV, tmp | 0x9);\n\t\tudelay(1);\n\t}\n\twritereg(par, PLL_POSTDIV, tmp);\n\tmsleep(20);\n\n\t \n\twritereg(par, CURSOR_MODE, CURSOR_MODE_OFF);\n\n\t \n\twritereg(par, CTRL_REG0, CR0_RASTER_RESET | (CR0_RASTER_RESET << 16));\n\tudelay(10);\n\twritereg(par, CTRL_REG0, CR0_RASTER_RESET << 16);\n\n\t \n\thtot = var->xres + var->left_margin + var->right_margin +\n\t\tvar->hsync_len;\n\twritereg(par, DTG_HORIZ_EXTENT, htot - 1);\n\twritereg(par, DTG_HORIZ_DISPLAY, var->xres - 1);\n\twritereg(par, DTG_HSYNC_START, var->xres + var->right_margin - 1);\n\twritereg(par, DTG_HSYNC_END,\n\t\t var->xres + var->right_margin + var->hsync_len - 1);\n\twritereg(par, DTG_HSYNC_END_COMP,\n\t\t var->xres + var->right_margin + var->hsync_len - 1);\n\twritereg(par, DTG_VERT_EXTENT,\n\t\t var->yres + var->upper_margin + var->lower_margin +\n\t\t var->vsync_len - 1);\n\twritereg(par, DTG_VERT_DISPLAY, var->yres - 1);\n\twritereg(par, DTG_VSYNC_START, var->yres + var->lower_margin - 1);\n\twritereg(par, DTG_VSYNC_END,\n\t\t var->yres + var->lower_margin + var->vsync_len - 1);\n\tprefetch_pix = 3300000 / var->pixclock;\n\tif (prefetch_pix >= htot)\n\t\tprefetch_pix = htot - 1;\n\twritereg(par, DTG_VERT_SHORT, htot - prefetch_pix - 1);\n\tctrlreg |= DTG_CTL_ENABLE | DTG_CTL_SCREEN_REFRESH;\n\twritereg(par, DTG_CONTROL, ctrlreg);\n\n\t \n\tif (var->xres_virtual > 2048) {\n\t\tstride = 4096;\n\t\tdfa_ctl = DFA_FB_STRIDE_4k;\n\t} else if (var->xres_virtual > 1024) {\n\t\tstride = 2048;\n\t\tdfa_ctl = DFA_FB_STRIDE_2k;\n\t} else {\n\t\tstride = 1024;\n\t\tdfa_ctl = DFA_FB_STRIDE_1k;\n\t}\n\n\t \n\twid_tiles = (var->xres_virtual + 63) >> 6;\n\n\t \n\twritereg(par, FB_AB_CTRL, FB_CTRL_TYPE | (wid_tiles << 16) | 0);\n\twritereg(par, REFRESH_AB_CTRL, FB_CTRL_TYPE | (wid_tiles << 16) | 0);\n\twritereg(par, FB_CD_CTRL, FB_CTRL_TYPE | (wid_tiles << 16) | 0);\n\twritereg(par, REFRESH_CD_CTRL, FB_CTRL_TYPE | (wid_tiles << 16) | 0);\n\twritereg(par, REFRESH_START, (var->xoffset << 16) | var->yoffset);\n\twritereg(par, REFRESH_SIZE, (var->xres << 16) | var->yres);\n\n\t \n\n\tpixfmt = par->pixfmt;\n\tdfa_ctl |= DFA_FB_ENABLE | pixfmt;\n\twritereg(par, DFA_FB_A, dfa_ctl);\n\n\t \n\tfor (i = 0; i < 32; ++i) {\n\t\twritereg(par, WAT_FMT + (i << 4), watfmt[pixfmt]);\n\t\twritereg(par, WAT_CMAP_OFFSET + (i << 4), 0);\n\t\twritereg(par, WAT_CTRL + (i << 4), 0);\n\t\twritereg(par, WAT_GAMMA_CTRL + (i << 4), WAT_GAMMA_DISABLE);\n\t}\n\n\t \n\tctrlreg = readreg(par, SYNC_CTL) &\n\t\t~(SYNC_CTL_SYNC_ON_RGB | SYNC_CTL_HSYNC_INV |\n\t\t  SYNC_CTL_VSYNC_INV);\n\tif (var->sync & FB_SYNC_ON_GREEN)\n\t\tctrlreg |= SYNC_CTL_SYNC_ON_RGB;\n\tif (!(var->sync & FB_SYNC_HOR_HIGH_ACT))\n\t\tctrlreg |= SYNC_CTL_HSYNC_INV;\n\tif (!(var->sync & FB_SYNC_VERT_HIGH_ACT))\n\t\tctrlreg |= SYNC_CTL_VSYNC_INV;\n\twritereg(par, SYNC_CTL, ctrlreg);\n\n\tinfo->fix.line_length = stride * pixsize[pixfmt];\n\tinfo->fix.visual = (pixfmt == DFA_PIX_8BIT)? FB_VISUAL_PSEUDOCOLOR:\n\t\tFB_VISUAL_DIRECTCOLOR;\n\n\treturn 0;\n}\n\nstatic int gxt4500_setcolreg(unsigned int reg, unsigned int red,\n\t\t\t     unsigned int green, unsigned int blue,\n\t\t\t     unsigned int transp, struct fb_info *info)\n{\n\tu32 cmap_entry;\n\tstruct gxt4500_par *par = info->par;\n\n\tif (reg > 1023)\n\t\treturn 1;\n\tcmap_entry = ((transp & 0xff00) << 16) | ((red & 0xff00) << 8) |\n\t\t(green & 0xff00) | (blue >> 8);\n\twritereg(par, CMAP + reg * 4, cmap_entry);\n\n\tif (reg < 16 && par->pixfmt != DFA_PIX_8BIT) {\n\t\tu32 *pal = info->pseudo_palette;\n\t\tu32 val = reg;\n\t\tswitch (par->pixfmt) {\n\t\tcase DFA_PIX_16BIT_565:\n\t\t\tval |= (reg << 11) | (reg << 5);\n\t\t\tbreak;\n\t\tcase DFA_PIX_16BIT_1555:\n\t\t\tval |= (reg << 10) | (reg << 5);\n\t\t\tbreak;\n\t\tcase DFA_PIX_32BIT:\n\t\t\tval |= (reg << 24);\n\t\t\tfallthrough;\n\t\tcase DFA_PIX_24BIT:\n\t\t\tval |= (reg << 16) | (reg << 8);\n\t\t\tbreak;\n\t\t}\n\t\tpal[reg] = val;\n\t}\n\n\treturn 0;\n}\n\nstatic int gxt4500_pan_display(struct fb_var_screeninfo *var,\n\t\t\t       struct fb_info *info)\n{\n\tstruct gxt4500_par *par = info->par;\n\n\tif (var->xoffset & 7)\n\t\treturn -EINVAL;\n\tif (var->xoffset + info->var.xres > info->var.xres_virtual ||\n\t    var->yoffset + info->var.yres > info->var.yres_virtual)\n\t\treturn -EINVAL;\n\n\twritereg(par, REFRESH_START, (var->xoffset << 16) | var->yoffset);\n\treturn 0;\n}\n\nstatic int gxt4500_blank(int blank, struct fb_info *info)\n{\n\tstruct gxt4500_par *par = info->par;\n\tint ctrl, dctl;\n\n\tctrl = readreg(par, SYNC_CTL);\n\tctrl &= ~(SYNC_CTL_SYNC_OFF | SYNC_CTL_HSYNC_OFF | SYNC_CTL_VSYNC_OFF);\n\tdctl = readreg(par, DISP_CTL);\n\tdctl |= DISP_CTL_OFF;\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\n\t\tdctl &= ~DISP_CTL_OFF;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tctrl |= SYNC_CTL_SYNC_OFF;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tctrl |= SYNC_CTL_HSYNC_OFF;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tctrl |= SYNC_CTL_VSYNC_OFF;\n\t\tbreak;\n\tdefault: ;\n\t}\n\twritereg(par, SYNC_CTL, ctrl);\n\twritereg(par, DISP_CTL, dctl);\n\n\treturn 0;\n}\n\nstatic const struct fb_fix_screeninfo gxt4500_fix = {\n\t.id = \"IBM GXT4500P\",\n\t.type = FB_TYPE_PACKED_PIXELS,\n\t.visual = FB_VISUAL_PSEUDOCOLOR,\n\t.xpanstep = 8,\n\t.ypanstep = 1,\n\t.mmio_len = 0x20000,\n};\n\nstatic const struct fb_ops gxt4500_ops = {\n\t.owner = THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var = gxt4500_check_var,\n\t.fb_set_par = gxt4500_set_par,\n\t.fb_setcolreg = gxt4500_setcolreg,\n\t.fb_pan_display = gxt4500_pan_display,\n\t.fb_blank = gxt4500_blank,\n};\n\n \nstatic int gxt4500_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint err;\n\tunsigned long reg_phys, fb_phys;\n\tstruct gxt4500_par *par;\n\tstruct fb_info *info;\n\tstruct fb_var_screeninfo var;\n\tenum gxt_cards cardtype;\n\n\terr = aperture_remove_conflicting_pci_devices(pdev, \"gxt4500fb\");\n\tif (err)\n\t\treturn err;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"gxt4500: cannot enable PCI device: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\treg_phys = pci_resource_start(pdev, 0);\n\tif (!request_mem_region(reg_phys, pci_resource_len(pdev, 0),\n\t\t\t\t\"gxt4500 regs\")) {\n\t\tdev_err(&pdev->dev, \"gxt4500: cannot get registers\\n\");\n\t\tgoto err_nodev;\n\t}\n\n\tfb_phys = pci_resource_start(pdev, 1);\n\tif (!request_mem_region(fb_phys, pci_resource_len(pdev, 1),\n\t\t\t\t\"gxt4500 FB\")) {\n\t\tdev_err(&pdev->dev, \"gxt4500: cannot get framebuffer\\n\");\n\t\tgoto err_free_regs;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct gxt4500_par), &pdev->dev);\n\tif (!info)\n\t\tgoto err_free_fb;\n\n\tpar = info->par;\n\tcardtype = ent->driver_data;\n\tpar->refclk_ps = cardinfo[cardtype].refclk_ps;\n\tinfo->fix = gxt4500_fix;\n\tstrscpy(info->fix.id, cardinfo[cardtype].cardname,\n\t\tsizeof(info->fix.id));\n\tinfo->pseudo_palette = par->pseudo_palette;\n\n\tinfo->fix.mmio_start = reg_phys;\n\tpar->regs = pci_ioremap_bar(pdev, 0);\n\tif (!par->regs) {\n\t\tdev_err(&pdev->dev, \"gxt4500: cannot map registers\\n\");\n\t\tgoto err_free_all;\n\t}\n\n\tinfo->fix.smem_start = fb_phys;\n\tinfo->fix.smem_len = pci_resource_len(pdev, 1);\n\tinfo->screen_base = pci_ioremap_wc_bar(pdev, 1);\n\tif (!info->screen_base) {\n\t\tdev_err(&pdev->dev, \"gxt4500: cannot map framebuffer\\n\");\n\t\tgoto err_unmap_regs;\n\t}\n\n\tpci_set_drvdata(pdev, info);\n\n\tpar->wc_cookie = arch_phys_wc_add(info->fix.smem_start,\n\t\t\t\t\t  info->fix.smem_len);\n\n#ifdef __BIG_ENDIAN\n\t \n\tpci_write_config_dword(pdev, CFG_ENDIAN0, 0x333300);\n#else  \n\t \n\tpci_write_config_dword(pdev, CFG_ENDIAN0, 0x2300);\n \n\tpci_write_config_dword(pdev, CFG_ENDIAN0 + 8, 0x98530000);\n#endif\n\n\tinfo->fbops = &gxt4500_ops;\n\tinfo->flags = FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;\n\n\terr = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"gxt4500: cannot allocate cmap\\n\");\n\t\tgoto err_unmap_all;\n\t}\n\n\tgxt4500_blank(FB_BLANK_UNBLANK, info);\n\n\tif (!fb_find_mode(&var, info, mode_option, NULL, 0, &defaultmode, 8)) {\n\t\tdev_err(&pdev->dev, \"gxt4500: cannot find valid video mode\\n\");\n\t\tgoto err_free_cmap;\n\t}\n\tinfo->var = var;\n\tif (gxt4500_set_par(info)) {\n\t\tprintk(KERN_ERR \"gxt4500: cannot set video mode\\n\");\n\t\tgoto err_free_cmap;\n\t}\n\n\tif (register_framebuffer(info) < 0) {\n\t\tdev_err(&pdev->dev, \"gxt4500: cannot register framebuffer\\n\");\n\t\tgoto err_free_cmap;\n\t}\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\n\treturn 0;\n\n err_free_cmap:\n\tfb_dealloc_cmap(&info->cmap);\n err_unmap_all:\n\tiounmap(info->screen_base);\n err_unmap_regs:\n\tiounmap(par->regs);\n err_free_all:\n\tframebuffer_release(info);\n err_free_fb:\n\trelease_mem_region(fb_phys, pci_resource_len(pdev, 1));\n err_free_regs:\n\trelease_mem_region(reg_phys, pci_resource_len(pdev, 0));\n err_nodev:\n\treturn -ENODEV;\n}\n\nstatic void gxt4500_remove(struct pci_dev *pdev)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct gxt4500_par *par;\n\n\tif (!info)\n\t\treturn;\n\tpar = info->par;\n\tunregister_framebuffer(info);\n\tarch_phys_wc_del(par->wc_cookie);\n\tfb_dealloc_cmap(&info->cmap);\n\tiounmap(par->regs);\n\tiounmap(info->screen_base);\n\trelease_mem_region(pci_resource_start(pdev, 0),\n\t\t\t   pci_resource_len(pdev, 0));\n\trelease_mem_region(pci_resource_start(pdev, 1),\n\t\t\t   pci_resource_len(pdev, 1));\n\tframebuffer_release(info);\n}\n\n \nstatic const struct pci_device_id gxt4500_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_GXT4500P),\n\t  .driver_data = GXT4500P },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_GXT6500P),\n\t  .driver_data = GXT6500P },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_GXT4000P),\n\t  .driver_data = GXT4000P },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_GXT6000P),\n\t  .driver_data = GXT6000P },\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, gxt4500_pci_tbl);\n\nstatic struct pci_driver gxt4500_driver = {\n\t.name = \"gxt4500\",\n\t.id_table = gxt4500_pci_tbl,\n\t.probe = gxt4500_probe,\n\t.remove = gxt4500_remove,\n};\n\nstatic int gxt4500_init(void)\n{\n\tif (fb_modesetting_disabled(\"gxt4500\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"gxt4500\", &mode_option))\n\t\treturn -ENODEV;\n#endif\n\n\treturn pci_register_driver(&gxt4500_driver);\n}\nmodule_init(gxt4500_init);\n\nstatic void __exit gxt4500_exit(void)\n{\n\tpci_unregister_driver(&gxt4500_driver);\n}\nmodule_exit(gxt4500_exit);\n\nMODULE_AUTHOR(\"Paul Mackerras <paulus@samba.org>\");\nMODULE_DESCRIPTION(\"FBDev driver for IBM GXT4500P/6500P and GXT4000P/6000P\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Specify resolution as \\\"<xres>x<yres>[-<bpp>][@<refresh>]\\\"\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}