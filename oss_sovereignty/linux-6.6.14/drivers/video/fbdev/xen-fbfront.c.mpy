{
  "module_name": "xen-fbfront.c",
  "hash_id": "a8a86e7566778ab3dbd666f908f0287aca5b2333997aa89deb73517ce8f92fb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/xen-fbfront.c",
  "human_readable_source": " \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/console.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/fb.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n\n#include <asm/xen/hypervisor.h>\n\n#include <xen/xen.h>\n#include <xen/events.h>\n#include <xen/page.h>\n#include <xen/interface/io/fbif.h>\n#include <xen/interface/io/protocols.h>\n#include <xen/xenbus.h>\n#include <xen/platform_pci.h>\n\nstruct xenfb_info {\n\tunsigned char\t\t*fb;\n\tstruct fb_info\t\t*fb_info;\n\tint\t\t\tx1, y1, x2, y2;\t \n\tspinlock_t\t\tdirty_lock;\n\tint\t\t\tnr_pages;\n\tint\t\t\tirq;\n\tstruct xenfb_page\t*page;\n\tunsigned long \t\t*gfns;\n\tint\t\t\tupdate_wanted;  \n\tint\t\t\tfeature_resize;  \n\tstruct xenfb_resize\tresize;\t\t \n\tint\t\t\tresize_dpy;\t \n\tspinlock_t\t\tresize_lock;\n\n\tstruct xenbus_device\t*xbdev;\n};\n\n#define XENFB_DEFAULT_FB_LEN (XENFB_WIDTH * XENFB_HEIGHT * XENFB_DEPTH / 8)\n\nenum { KPARAM_MEM, KPARAM_WIDTH, KPARAM_HEIGHT, KPARAM_CNT };\nstatic int video[KPARAM_CNT] = { 2, XENFB_WIDTH, XENFB_HEIGHT };\nmodule_param_array(video, int, NULL, 0);\nMODULE_PARM_DESC(video,\n\t\"Video memory size in MB, width, height in pixels (default 2,800,600)\");\n\nstatic void xenfb_make_preferred_console(void);\nstatic void xenfb_remove(struct xenbus_device *);\nstatic void xenfb_init_shared_page(struct xenfb_info *, struct fb_info *);\nstatic int xenfb_connect_backend(struct xenbus_device *, struct xenfb_info *);\nstatic void xenfb_disconnect_backend(struct xenfb_info *);\n\nstatic void xenfb_send_event(struct xenfb_info *info,\n\t\t\t     union xenfb_out_event *event)\n{\n\tu32 prod;\n\n\tprod = info->page->out_prod;\n\t \n\tmb();\t\t\t \n\tXENFB_OUT_RING_REF(info->page, prod) = *event;\n\twmb();\t\t\t \n\tinfo->page->out_prod = prod + 1;\n\n\tnotify_remote_via_irq(info->irq);\n}\n\nstatic void xenfb_do_update(struct xenfb_info *info,\n\t\t\t    int x, int y, int w, int h)\n{\n\tunion xenfb_out_event event;\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.type = XENFB_TYPE_UPDATE;\n\tevent.update.x = x;\n\tevent.update.y = y;\n\tevent.update.width = w;\n\tevent.update.height = h;\n\n\t \n\txenfb_send_event(info, &event);\n}\n\nstatic void xenfb_do_resize(struct xenfb_info *info)\n{\n\tunion xenfb_out_event event;\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.resize = info->resize;\n\n\t \n\txenfb_send_event(info, &event);\n}\n\nstatic int xenfb_queue_full(struct xenfb_info *info)\n{\n\tu32 cons, prod;\n\n\tprod = info->page->out_prod;\n\tcons = info->page->out_cons;\n\treturn prod - cons == XENFB_OUT_RING_LEN;\n}\n\nstatic void xenfb_handle_resize_dpy(struct xenfb_info *info)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->resize_lock, flags);\n\tif (info->resize_dpy) {\n\t\tif (!xenfb_queue_full(info)) {\n\t\t\tinfo->resize_dpy = 0;\n\t\t\txenfb_do_resize(info);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&info->resize_lock, flags);\n}\n\nstatic void xenfb_refresh(struct xenfb_info *info,\n\t\t\t  int x1, int y1, int w, int h)\n{\n\tunsigned long flags;\n\tint x2 = x1 + w - 1;\n\tint y2 = y1 + h - 1;\n\n\txenfb_handle_resize_dpy(info);\n\n\tif (!info->update_wanted)\n\t\treturn;\n\n\tspin_lock_irqsave(&info->dirty_lock, flags);\n\n\t \n\tif (info->y1 < y1)\n\t\ty1 = info->y1;\n\tif (info->y2 > y2)\n\t\ty2 = info->y2;\n\tif (info->x1 < x1)\n\t\tx1 = info->x1;\n\tif (info->x2 > x2)\n\t\tx2 = info->x2;\n\n\tif (xenfb_queue_full(info)) {\n\t\t \n\t\tinfo->x1 = x1;\n\t\tinfo->x2 = x2;\n\t\tinfo->y1 = y1;\n\t\tinfo->y2 = y2;\n\t\tspin_unlock_irqrestore(&info->dirty_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tinfo->x1 = info->y1 = INT_MAX;\n\tinfo->x2 = info->y2 = 0;\n\n\tspin_unlock_irqrestore(&info->dirty_lock, flags);\n\n\tif (x1 <= x2 && y1 <= y2)\n\t\txenfb_do_update(info, x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n}\n\nstatic void xenfb_deferred_io(struct fb_info *fb_info, struct list_head *pagereflist)\n{\n\tstruct xenfb_info *info = fb_info->par;\n\tstruct fb_deferred_io_pageref *pageref;\n\tunsigned long beg, end;\n\tint y1, y2, miny, maxy;\n\n\tminy = INT_MAX;\n\tmaxy = 0;\n\tlist_for_each_entry(pageref, pagereflist, list) {\n\t\tbeg = pageref->offset;\n\t\tend = beg + PAGE_SIZE - 1;\n\t\ty1 = beg / fb_info->fix.line_length;\n\t\ty2 = end / fb_info->fix.line_length;\n\t\tif (y2 >= fb_info->var.yres)\n\t\t\ty2 = fb_info->var.yres - 1;\n\t\tif (miny > y1)\n\t\t\tminy = y1;\n\t\tif (maxy < y2)\n\t\t\tmaxy = y2;\n\t}\n\txenfb_refresh(info, 0, miny, fb_info->var.xres, maxy - miny + 1);\n}\n\nstatic struct fb_deferred_io xenfb_defio = {\n\t.delay\t\t= HZ / 20,\n\t.deferred_io\t= xenfb_deferred_io,\n};\n\nstatic int xenfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t   unsigned blue, unsigned transp,\n\t\t\t   struct fb_info *info)\n{\n\tu32 v;\n\n\tif (regno > info->cmap.len)\n\t\treturn 1;\n\n#define CNVT_TOHW(val, width) ((((val)<<(width))+0x7FFF-(val))>>16)\n\tred = CNVT_TOHW(red, info->var.red.length);\n\tgreen = CNVT_TOHW(green, info->var.green.length);\n\tblue = CNVT_TOHW(blue, info->var.blue.length);\n#undef CNVT_TOHW\n\n\tv = (red << info->var.red.offset) |\n\t    (green << info->var.green.offset) |\n\t    (blue << info->var.blue.offset);\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\t((u32 *)info->pseudo_palette)[regno] = v;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nxenfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct xenfb_info *xenfb_info;\n\tint required_mem_len;\n\n\txenfb_info = info->par;\n\n\tif (!xenfb_info->feature_resize) {\n\t\tif (var->xres == video[KPARAM_WIDTH] &&\n\t\t    var->yres == video[KPARAM_HEIGHT] &&\n\t\t    var->bits_per_pixel == xenfb_info->page->depth) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (var->xres > video[KPARAM_WIDTH] || var->yres > video[KPARAM_HEIGHT])\n\t\treturn -EINVAL;\n\n\trequired_mem_len = var->xres * var->yres * xenfb_info->page->depth / 8;\n\tif (var->bits_per_pixel == xenfb_info->page->depth &&\n\t    var->xres <= info->fix.line_length / (XENFB_DEPTH / 8) &&\n\t    required_mem_len <= info->fix.smem_len) {\n\t\tvar->xres_virtual = var->xres;\n\t\tvar->yres_virtual = var->yres;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int xenfb_set_par(struct fb_info *info)\n{\n\tstruct xenfb_info *xenfb_info;\n\tunsigned long flags;\n\n\txenfb_info = info->par;\n\n\tspin_lock_irqsave(&xenfb_info->resize_lock, flags);\n\txenfb_info->resize.type = XENFB_TYPE_RESIZE;\n\txenfb_info->resize.width = info->var.xres;\n\txenfb_info->resize.height = info->var.yres;\n\txenfb_info->resize.stride = info->fix.line_length;\n\txenfb_info->resize.depth = info->var.bits_per_pixel;\n\txenfb_info->resize.offset = 0;\n\txenfb_info->resize_dpy = 1;\n\tspin_unlock_irqrestore(&xenfb_info->resize_lock, flags);\n\treturn 0;\n}\n\nstatic void xenfb_defio_damage_range(struct fb_info *info, off_t off, size_t len)\n{\n\tstruct xenfb_info *xenfb_info = info->par;\n\n\txenfb_refresh(xenfb_info, 0, 0, xenfb_info->page->width, xenfb_info->page->height);\n}\n\nstatic void xenfb_defio_damage_area(struct fb_info *info, u32 x, u32 y,\n\t\t\t\t    u32 width, u32 height)\n{\n\tstruct xenfb_info *xenfb_info = info->par;\n\n\txenfb_refresh(xenfb_info, x, y, width, height);\n}\n\nFB_GEN_DEFAULT_DEFERRED_SYSMEM_OPS(xenfb,\n\t\t\t\t   xenfb_defio_damage_range,\n\t\t\t\t   xenfb_defio_damage_area)\n\nstatic const struct fb_ops xenfb_fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_DEFERRED_OPS(xenfb),\n\t.fb_setcolreg\t= xenfb_setcolreg,\n\t.fb_check_var\t= xenfb_check_var,\n\t.fb_set_par     = xenfb_set_par,\n};\n\nstatic irqreturn_t xenfb_event_handler(int rq, void *dev_id)\n{\n\t \n\tstruct xenfb_info *info = dev_id;\n\tstruct xenfb_page *page = info->page;\n\n\tif (page->in_cons != page->in_prod) {\n\t\tinfo->page->in_cons = info->page->in_prod;\n\t\tnotify_remote_via_irq(info->irq);\n\t}\n\n\t \n\txenfb_refresh(info, INT_MAX, INT_MAX, -INT_MAX, -INT_MAX);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xenfb_probe(struct xenbus_device *dev,\n\t\t       const struct xenbus_device_id *id)\n{\n\tstruct xenfb_info *info;\n\tstruct fb_info *fb_info;\n\tint fb_size;\n\tint val;\n\tint ret = 0;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (info == NULL) {\n\t\txenbus_dev_fatal(dev, -ENOMEM, \"allocating info structure\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (xenbus_scanf(XBT_NIL, dev->otherend, \"videoram\", \"%d\", &val) == 1) {\n\t\tif (val < video[KPARAM_MEM])\n\t\t\tvideo[KPARAM_MEM] = val;\n\t}\n\n\tvideo[KPARAM_WIDTH] = xenbus_read_unsigned(dev->otherend, \"width\",\n\t\t\t\t\t\t   video[KPARAM_WIDTH]);\n\tvideo[KPARAM_HEIGHT] = xenbus_read_unsigned(dev->otherend, \"height\",\n\t\t\t\t\t\t    video[KPARAM_HEIGHT]);\n\n\t \n\tfb_size = video[KPARAM_MEM] * 1024 * 1024;\n\tif (video[KPARAM_WIDTH] * video[KPARAM_HEIGHT] * XENFB_DEPTH / 8\n\t    > fb_size) {\n\t\tpr_warn(\"display parameters %d,%d,%d invalid, use defaults\\n\",\n\t\t\tvideo[KPARAM_MEM], video[KPARAM_WIDTH],\n\t\t\tvideo[KPARAM_HEIGHT]);\n\t\tvideo[KPARAM_WIDTH] = XENFB_WIDTH;\n\t\tvideo[KPARAM_HEIGHT] = XENFB_HEIGHT;\n\t\tfb_size = XENFB_DEFAULT_FB_LEN;\n\t}\n\n\tdev_set_drvdata(&dev->dev, info);\n\tinfo->xbdev = dev;\n\tinfo->irq = -1;\n\tinfo->x1 = info->y1 = INT_MAX;\n\tspin_lock_init(&info->dirty_lock);\n\tspin_lock_init(&info->resize_lock);\n\n\tinfo->fb = vzalloc(fb_size);\n\tif (info->fb == NULL)\n\t\tgoto error_nomem;\n\n\tinfo->nr_pages = (fb_size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\tinfo->gfns = vmalloc(array_size(sizeof(unsigned long), info->nr_pages));\n\tif (!info->gfns)\n\t\tgoto error_nomem;\n\n\t \n\tinfo->page = (void *)__get_free_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!info->page)\n\t\tgoto error_nomem;\n\n\t \n\tfb_info = framebuffer_alloc(sizeof(u32) * 256, NULL);\n\tif (fb_info == NULL)\n\t\tgoto error_nomem;\n\n\t \n\tfb_info->pseudo_palette = fb_info->par;\n\tfb_info->par = info;\n\n\tfb_info->screen_buffer = info->fb;\n\n\tfb_info->fbops = &xenfb_fb_ops;\n\tfb_info->var.xres_virtual = fb_info->var.xres = video[KPARAM_WIDTH];\n\tfb_info->var.yres_virtual = fb_info->var.yres = video[KPARAM_HEIGHT];\n\tfb_info->var.bits_per_pixel = XENFB_DEPTH;\n\n\tfb_info->var.red = (struct fb_bitfield){16, 8, 0};\n\tfb_info->var.green = (struct fb_bitfield){8, 8, 0};\n\tfb_info->var.blue = (struct fb_bitfield){0, 8, 0};\n\n\tfb_info->var.activate = FB_ACTIVATE_NOW;\n\tfb_info->var.height = -1;\n\tfb_info->var.width = -1;\n\tfb_info->var.vmode = FB_VMODE_NONINTERLACED;\n\n\tfb_info->fix.visual = FB_VISUAL_TRUECOLOR;\n\tfb_info->fix.line_length = fb_info->var.xres * XENFB_DEPTH / 8;\n\tfb_info->fix.smem_start = 0;\n\tfb_info->fix.smem_len = fb_size;\n\tstrcpy(fb_info->fix.id, \"xen\");\n\tfb_info->fix.type = FB_TYPE_PACKED_PIXELS;\n\tfb_info->fix.accel = FB_ACCEL_NONE;\n\n\tfb_info->flags = FBINFO_VIRTFB;\n\n\tret = fb_alloc_cmap(&fb_info->cmap, 256, 0);\n\tif (ret < 0) {\n\t\tframebuffer_release(fb_info);\n\t\txenbus_dev_fatal(dev, ret, \"fb_alloc_cmap\");\n\t\tgoto error;\n\t}\n\n\tfb_info->fbdefio = &xenfb_defio;\n\tfb_deferred_io_init(fb_info);\n\n\txenfb_init_shared_page(info, fb_info);\n\n\tret = xenfb_connect_backend(dev, info);\n\tif (ret < 0) {\n\t\txenbus_dev_fatal(dev, ret, \"xenfb_connect_backend\");\n\t\tgoto error_fb;\n\t}\n\n\tret = register_framebuffer(fb_info);\n\tif (ret) {\n\t\txenbus_dev_fatal(dev, ret, \"register_framebuffer\");\n\t\tgoto error_fb;\n\t}\n\tinfo->fb_info = fb_info;\n\n\txenfb_make_preferred_console();\n\treturn 0;\n\nerror_fb:\n\tfb_deferred_io_cleanup(fb_info);\n\tfb_dealloc_cmap(&fb_info->cmap);\n\tframebuffer_release(fb_info);\nerror_nomem:\n\tif (!ret) {\n\t\tret = -ENOMEM;\n\t\txenbus_dev_fatal(dev, ret, \"allocating device memory\");\n\t}\nerror:\n\txenfb_remove(dev);\n\treturn ret;\n}\n\nstatic void xenfb_make_preferred_console(void)\n{\n\tstruct console *c;\n\n\tif (console_set_on_cmdline)\n\t\treturn;\n\n\tconsole_list_lock();\n\tfor_each_console(c) {\n\t\tif (!strcmp(c->name, \"tty\") && c->index == 0)\n\t\t\tbreak;\n\t}\n\tif (c)\n\t\tconsole_force_preferred_locked(c);\n\tconsole_list_unlock();\n}\n\nstatic int xenfb_resume(struct xenbus_device *dev)\n{\n\tstruct xenfb_info *info = dev_get_drvdata(&dev->dev);\n\n\txenfb_disconnect_backend(info);\n\txenfb_init_shared_page(info, info->fb_info);\n\treturn xenfb_connect_backend(dev, info);\n}\n\nstatic void xenfb_remove(struct xenbus_device *dev)\n{\n\tstruct xenfb_info *info = dev_get_drvdata(&dev->dev);\n\n\txenfb_disconnect_backend(info);\n\tif (info->fb_info) {\n\t\tfb_deferred_io_cleanup(info->fb_info);\n\t\tunregister_framebuffer(info->fb_info);\n\t\tfb_dealloc_cmap(&info->fb_info->cmap);\n\t\tframebuffer_release(info->fb_info);\n\t}\n\tfree_page((unsigned long)info->page);\n\tvfree(info->gfns);\n\tvfree(info->fb);\n\tkfree(info);\n}\n\nstatic unsigned long vmalloc_to_gfn(void *address)\n{\n\treturn xen_page_to_gfn(vmalloc_to_page(address));\n}\n\nstatic void xenfb_init_shared_page(struct xenfb_info *info,\n\t\t\t\t   struct fb_info *fb_info)\n{\n\tint i;\n\tint epd = PAGE_SIZE / sizeof(info->gfns[0]);\n\n\tfor (i = 0; i < info->nr_pages; i++)\n\t\tinfo->gfns[i] = vmalloc_to_gfn(info->fb + i * PAGE_SIZE);\n\n\tfor (i = 0; i * epd < info->nr_pages; i++)\n\t\tinfo->page->pd[i] = vmalloc_to_gfn(&info->gfns[i * epd]);\n\n\tinfo->page->width = fb_info->var.xres;\n\tinfo->page->height = fb_info->var.yres;\n\tinfo->page->depth = fb_info->var.bits_per_pixel;\n\tinfo->page->line_length = fb_info->fix.line_length;\n\tinfo->page->mem_length = fb_info->fix.smem_len;\n\tinfo->page->in_cons = info->page->in_prod = 0;\n\tinfo->page->out_cons = info->page->out_prod = 0;\n}\n\nstatic int xenfb_connect_backend(struct xenbus_device *dev,\n\t\t\t\t struct xenfb_info *info)\n{\n\tint ret, evtchn, irq;\n\tstruct xenbus_transaction xbt;\n\n\tret = xenbus_alloc_evtchn(dev, &evtchn);\n\tif (ret)\n\t\treturn ret;\n\tirq = bind_evtchn_to_irqhandler(evtchn, xenfb_event_handler,\n\t\t\t\t\t0, dev->devicetype, info);\n\tif (irq < 0) {\n\t\txenbus_free_evtchn(dev, evtchn);\n\t\txenbus_dev_fatal(dev, ret, \"bind_evtchn_to_irqhandler\");\n\t\treturn irq;\n\t}\n again:\n\tret = xenbus_transaction_start(&xbt);\n\tif (ret) {\n\t\txenbus_dev_fatal(dev, ret, \"starting transaction\");\n\t\tgoto unbind_irq;\n\t}\n\tret = xenbus_printf(xbt, dev->nodename, \"page-ref\", \"%lu\",\n\t\t\t    virt_to_gfn(info->page));\n\tif (ret)\n\t\tgoto error_xenbus;\n\tret = xenbus_printf(xbt, dev->nodename, \"event-channel\", \"%u\",\n\t\t\t    evtchn);\n\tif (ret)\n\t\tgoto error_xenbus;\n\tret = xenbus_printf(xbt, dev->nodename, \"protocol\", \"%s\",\n\t\t\t    XEN_IO_PROTO_ABI_NATIVE);\n\tif (ret)\n\t\tgoto error_xenbus;\n\tret = xenbus_printf(xbt, dev->nodename, \"feature-update\", \"1\");\n\tif (ret)\n\t\tgoto error_xenbus;\n\tret = xenbus_transaction_end(xbt, 0);\n\tif (ret) {\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\t\txenbus_dev_fatal(dev, ret, \"completing transaction\");\n\t\tgoto unbind_irq;\n\t}\n\n\txenbus_switch_state(dev, XenbusStateInitialised);\n\tinfo->irq = irq;\n\treturn 0;\n\n error_xenbus:\n\txenbus_transaction_end(xbt, 1);\n\txenbus_dev_fatal(dev, ret, \"writing xenstore\");\n unbind_irq:\n\tunbind_from_irqhandler(irq, info);\n\treturn ret;\n}\n\nstatic void xenfb_disconnect_backend(struct xenfb_info *info)\n{\n\t \n\tinfo->update_wanted = 0;\n\tif (info->irq >= 0)\n\t\tunbind_from_irqhandler(info->irq, info);\n\tinfo->irq = -1;\n}\n\nstatic void xenfb_backend_changed(struct xenbus_device *dev,\n\t\t\t\t  enum xenbus_state backend_state)\n{\n\tstruct xenfb_info *info = dev_get_drvdata(&dev->dev);\n\n\tswitch (backend_state) {\n\tcase XenbusStateInitialising:\n\tcase XenbusStateInitialised:\n\tcase XenbusStateReconfiguring:\n\tcase XenbusStateReconfigured:\n\tcase XenbusStateUnknown:\n\t\tbreak;\n\n\tcase XenbusStateInitWait:\n\t\txenbus_switch_state(dev, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateConnected:\n\t\t \n\t\tif (dev->state != XenbusStateConnected)\n\t\t\t \n\t\t\txenbus_switch_state(dev, XenbusStateConnected);\n\n\t\tif (xenbus_read_unsigned(info->xbdev->otherend,\n\t\t\t\t\t \"request-update\", 0))\n\t\t\tinfo->update_wanted = 1;\n\n\t\tinfo->feature_resize = xenbus_read_unsigned(dev->otherend,\n\t\t\t\t\t\t\t\"feature-resize\", 0);\n\t\tbreak;\n\n\tcase XenbusStateClosed:\n\t\tif (dev->state == XenbusStateClosed)\n\t\t\tbreak;\n\t\tfallthrough;\t \n\tcase XenbusStateClosing:\n\t\txenbus_frontend_closed(dev);\n\t\tbreak;\n\t}\n}\n\nstatic const struct xenbus_device_id xenfb_ids[] = {\n\t{ \"vfb\" },\n\t{ \"\" }\n};\n\nstatic struct xenbus_driver xenfb_driver = {\n\t.ids = xenfb_ids,\n\t.probe = xenfb_probe,\n\t.remove = xenfb_remove,\n\t.resume = xenfb_resume,\n\t.otherend_changed = xenfb_backend_changed,\n\t.not_essential = true,\n};\n\nstatic int __init xenfb_init(void)\n{\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\t \n\tif (xen_initial_domain())\n\t\treturn -ENODEV;\n\n\tif (!xen_has_pv_devices())\n\t\treturn -ENODEV;\n\n\treturn xenbus_register_frontend(&xenfb_driver);\n}\n\nstatic void __exit xenfb_cleanup(void)\n{\n\txenbus_unregister_driver(&xenfb_driver);\n}\n\nmodule_init(xenfb_init);\nmodule_exit(xenfb_cleanup);\n\nMODULE_DESCRIPTION(\"Xen virtual framebuffer device frontend\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"xen:vfb\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}