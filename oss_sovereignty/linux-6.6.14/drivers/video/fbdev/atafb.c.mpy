{
  "module_name": "atafb.c",
  "hash_id": "5ccd96a357800e0f9817b072d5a2a48753b89ddc3c911b1f019f64a5e11f0356",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/atafb.c",
  "human_readable_source": " \n\n#define ATAFB_TT\n#define ATAFB_STE\n#define ATAFB_EXT\n#define ATAFB_FALCON\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n\n#include <asm/setup.h>\n#include <linux/uaccess.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n\n#include <asm/atarihw.h>\n#include <asm/atariints.h>\n#include <asm/atari_stram.h>\n\n#include <linux/fb.h>\n#include <asm/atarikb.h>\n\n#include \"c2p.h\"\n#include \"atafb.h\"\n\n#define SWITCH_ACIA 0x01\t\t \n#define SWITCH_SND6 0x40\n#define SWITCH_SND7 0x80\n#define SWITCH_NONE 0x00\n\n\nstatic int default_par;\t\t \n\nstatic unsigned long default_mem_req;\n\nstatic int hwscroll = -1;\n\nstatic int use_hwscroll = 1;\n\nstatic int sttt_xres = 640, st_yres = 400, tt_yres = 480;\nstatic int sttt_xres_virtual = 640, sttt_yres_virtual = 400;\nstatic int ovsc_offset, ovsc_addlen;\n\n\t \n\nstatic struct atafb_par {\n\tvoid *screen_base;\n\tint yres_virtual;\n\tu_long next_line;\n#if defined ATAFB_TT || defined ATAFB_STE\n\tunion {\n\t\tstruct {\n\t\t\tint mode;\n\t\t\tint sync;\n\t\t} tt, st;\n#endif\n#ifdef ATAFB_FALCON\n\t\tstruct falcon_hw {\n\t\t\t \n\t\t\tshort sync;\n\t\t\tshort line_width;\n\t\t\tshort line_offset;\n\t\t\tshort st_shift;\n\t\t\tshort f_shift;\n\t\t\tshort vid_control;\n\t\t\tshort vid_mode;\n\t\t\tshort xoffset;\n\t\t\tshort hht, hbb, hbe, hdb, hde, hss;\n\t\t\tshort vft, vbb, vbe, vdb, vde, vss;\n\t\t\t \n\t\t\tshort mono;\n\t\t\tshort ste_mode;\n\t\t\tshort bpp;\n\t\t\tu32 pseudo_palette[16];\n\t\t} falcon;\n#endif\n\t\t \n\t} hw;\n} current_par;\n\n \nstatic int DontCalcRes = 0;\n\n#ifdef ATAFB_FALCON\n#define HHT hw.falcon.hht\n#define HBB hw.falcon.hbb\n#define HBE hw.falcon.hbe\n#define HDB hw.falcon.hdb\n#define HDE hw.falcon.hde\n#define HSS hw.falcon.hss\n#define VFT hw.falcon.vft\n#define VBB hw.falcon.vbb\n#define VBE hw.falcon.vbe\n#define VDB hw.falcon.vdb\n#define VDE hw.falcon.vde\n#define VSS hw.falcon.vss\n#define VCO_CLOCK25\t\t0x04\n#define VCO_CSYPOS\t\t0x10\n#define VCO_VSYPOS\t\t0x20\n#define VCO_HSYPOS\t\t0x40\n#define VCO_SHORTOFFS\t0x100\n#define VMO_DOUBLE\t\t0x01\n#define VMO_INTER\t\t0x02\n#define VMO_PREMASK\t\t0x0c\n#endif\n\nstatic struct fb_info fb_info = {\n\t.fix = {\n\t\t.id\t= \"Atari \",\n\t\t.visual\t= FB_VISUAL_PSEUDOCOLOR,\n\t\t.accel\t= FB_ACCEL_NONE,\n\t}\n};\n\nstatic void *screen_base;\t \nstatic unsigned long phys_screen_base;\t \n\nstatic int screen_len;\n\nstatic int current_par_valid;\n\nstatic int mono_moni;\n\n\n#ifdef ATAFB_EXT\n\n \nstatic unsigned int external_xres;\nstatic unsigned int external_xres_virtual;\nstatic unsigned int external_yres;\n\n \nstatic unsigned int external_depth;\nstatic int external_pmode;\nstatic void *external_screen_base;\nstatic unsigned long external_addr;\nstatic unsigned long external_len;\nstatic unsigned long external_vgaiobase;\nstatic unsigned int external_bitspercol = 6;\n\n \nenum cardtype { IS_VGA, IS_MV300 };\nstatic enum cardtype external_card_type = IS_VGA;\n\n \nstatic int MV300_reg_1bit[2] = {\n\t0, 1\n};\nstatic int MV300_reg_4bit[16] = {\n\t0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15\n};\nstatic int MV300_reg_8bit[256] = {\n\t0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240,\n\t8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248,\n\t4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244,\n\t12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252,\n\t2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242,\n\t10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250,\n\t6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246,\n\t14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254,\n\t1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241,\n\t9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249,\n\t5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245,\n\t13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253,\n\t3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243,\n\t11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251,\n\t7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247,\n\t15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255\n};\n\nstatic int *MV300_reg = MV300_reg_8bit;\n#endif  \n\n\n \n\n\n \n\nstatic struct fb_hwswitch {\n\tint (*detect)(void);\n\tint (*encode_fix)(struct fb_fix_screeninfo *fix,\n\t\t\t  struct atafb_par *par);\n\tint (*decode_var)(struct fb_var_screeninfo *var,\n\t\t\t  struct atafb_par *par);\n\tint (*encode_var)(struct fb_var_screeninfo *var,\n\t\t\t  struct atafb_par *par);\n\tvoid (*get_par)(struct atafb_par *par);\n\tvoid (*set_par)(struct atafb_par *par);\n\tvoid (*set_screen_base)(void *s_base);\n\tint (*blank)(int blank_mode);\n\tint (*pan_display)(struct fb_var_screeninfo *var,\n\t\t\t   struct fb_info *info);\n} *fbhw;\n\nstatic char *autodetect_names[] = { \"autodetect\", NULL };\nstatic char *stlow_names[] = { \"stlow\", NULL };\nstatic char *stmid_names[] = { \"stmid\", \"default5\", NULL };\nstatic char *sthigh_names[] = { \"sthigh\", \"default4\", NULL };\nstatic char *ttlow_names[] = { \"ttlow\", NULL };\nstatic char *ttmid_names[] = { \"ttmid\", \"default1\", NULL };\nstatic char *tthigh_names[] = { \"tthigh\", \"default2\", NULL };\nstatic char *vga2_names[] = { \"vga2\", NULL };\nstatic char *vga4_names[] = { \"vga4\", NULL };\nstatic char *vga16_names[] = { \"vga16\", \"default3\", NULL };\nstatic char *vga256_names[] = { \"vga256\", NULL };\nstatic char *falh2_names[] = { \"falh2\", NULL };\nstatic char *falh16_names[] = { \"falh16\", NULL };\n\nstatic char **fb_var_names[] = {\n\tautodetect_names,\n\tstlow_names,\n\tstmid_names,\n\tsthigh_names,\n\tttlow_names,\n\tttmid_names,\n\ttthigh_names,\n\tvga2_names,\n\tvga4_names,\n\tvga16_names,\n\tvga256_names,\n\tfalh2_names,\n\tfalh16_names,\n\tNULL\n};\n\nstatic struct fb_var_screeninfo atafb_predefined[] = {\n\t \n\t{  \n\t  0, 0, 0, 0, 0, 0, 0, 0,\t\t \n\t  {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0},\t \n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{  \n\t  320, 200, 320, 0, 0, 0, 4, 0,\n\t  {0, 4, 0}, {0, 4, 0}, {0, 4, 0}, {0, 0, 0},\n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{  \n\t  640, 200, 640, 0, 0, 0, 2, 0,\n\t  {0, 4, 0}, {0, 4, 0}, {0, 4, 0}, {0, 0, 0},\n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{  \n\t  640, 400, 640, 0, 0, 0, 1, 0,\n\t  {0, 4, 0}, {0, 4, 0}, {0, 4, 0}, {0, 0, 0},\n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{  \n\t  320, 480, 320, 0, 0, 0, 8, 0,\n\t  {0, 4, 0}, {0, 4, 0}, {0, 4, 0}, {0, 0, 0},\n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{  \n\t  640, 480, 640, 0, 0, 0, 4, 0,\n\t  {0, 4, 0}, {0, 4, 0}, {0, 4, 0}, {0, 0, 0},\n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{  \n\t  1280, 960, 1280, 0, 0, 0, 1, 0,\n\t  {0, 4, 0}, {0, 4, 0}, {0, 4, 0}, {0, 0, 0},\n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{  \n\t  640, 480, 640, 0, 0, 0, 1, 0,\n\t  {0, 6, 0}, {0, 6, 0}, {0, 6, 0}, {0, 0, 0},\n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{  \n\t  640, 480, 640, 0, 0, 0, 2, 0,\n\t  {0, 4, 0}, {0, 4, 0}, {0, 4, 0}, {0, 0, 0},\n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{  \n\t  640, 480, 640, 0, 0, 0, 4, 0,\n\t  {0, 6, 0}, {0, 6, 0}, {0, 6, 0}, {0, 0, 0},\n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{  \n\t  640, 480, 640, 0, 0, 0, 8, 0,\n\t  {0, 6, 0}, {0, 6, 0}, {0, 6, 0}, {0, 0, 0},\n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{  \n\t  896, 608, 896, 0, 0, 0, 1, 0,\n\t  {0, 6, 0}, {0, 6, 0}, {0, 6, 0}, {0, 0, 0},\n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{  \n\t  896, 608, 896, 0, 0, 0, 4, 0,\n\t  {0, 6, 0}, {0, 6, 0}, {0, 6, 0}, {0, 0, 0},\n\t  0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 },\n};\n\nstatic int num_atafb_predefined = ARRAY_SIZE(atafb_predefined);\n\nstatic struct fb_videomode atafb_modedb[] __initdata = {\n\t \n\n\t \n\n\t{\n\t\t \n\t\t\"st-low\", 60, 320, 200, 32000, 32, 16, 31, 14, 96, 4,\n\t\t0, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\t\"st-mid\", 60, 640, 200, 32000, 32, 16, 31, 14, 96, 4,\n\t\t0, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\t\"st-high\", 63, 640, 400, 32000, 128, 0, 40, 14, 128, 4,\n\t\t0, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\t\"tt-low\", 60, 320, 480, 31041, 120, 100, 8, 16, 140, 30,\n\t\t0, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\t\"tt-mid\", 60, 640, 480, 31041, 120, 100, 8, 16, 140, 30,\n\t\t0, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\t\"tt-high\", 72, 1280, 960, 7760, 260, 60, 36, 4, 192, 4,\n\t\t0, FB_VMODE_NONINTERLACED\n\t},\n\n\t \n\n\t{\n\t\t \n\t\t\"vga\", 60, 640, 480, 39721, 42, 18, 31, 11, 100, 3,\n\t\t0, FB_VMODE_NONINTERLACED\n\t}, {\n\t\t \n\t\t\"vga70\", 70, 640, 400, 39721, 42, 18, 31, 11, 100, 3,\n\t\tFB_SYNC_VERT_HIGH_ACT | FB_SYNC_COMP_HIGH_ACT, FB_VMODE_NONINTERLACED\n\t},\n\n\t \n\n\t{\n\t\t \n\t\t\"falh\", 60, 896, 608, 32000, 18, 42, 31, 1, 96,3,\n\t\t0, FB_VMODE_NONINTERLACED\n\t},\n};\n\n#define NUM_TOTAL_MODES  ARRAY_SIZE(atafb_modedb)\n\nstatic char *mode_option __initdata = NULL;\n\n  \n\n#define DEFMODE_TT\t5\t\t \n#define DEFMODE_F30\t7\t\t \n#define DEFMODE_STE\t2\t\t \n#define DEFMODE_EXT\t6\t\t \n\n\nstatic int get_video_mode(char *vname)\n{\n\tchar ***name_list;\n\tchar **name;\n\tint i;\n\n\tname_list = fb_var_names;\n\tfor (i = 0; i < num_atafb_predefined; i++) {\n\t\tname = *name_list++;\n\t\tif (!name || !*name)\n\t\t\tbreak;\n\t\twhile (*name) {\n\t\t\tif (!strcmp(vname, *name))\n\t\t\t\treturn i + 1;\n\t\t\tname++;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n \n\n#ifdef ATAFB_TT\n\nstatic int tt_encode_fix(struct fb_fix_screeninfo *fix, struct atafb_par *par)\n{\n\tint mode;\n\n\tstrcpy(fix->id, \"Atari Builtin\");\n\tfix->smem_start = phys_screen_base;\n\tfix->smem_len = screen_len;\n\tfix->type = FB_TYPE_INTERLEAVED_PLANES;\n\tfix->type_aux = 2;\n\tfix->visual = FB_VISUAL_PSEUDOCOLOR;\n\tmode = par->hw.tt.mode & TT_SHIFTER_MODEMASK;\n\tif (mode == TT_SHIFTER_TTHIGH || mode == TT_SHIFTER_STHIGH) {\n\t\tfix->type = FB_TYPE_PACKED_PIXELS;\n\t\tfix->type_aux = 0;\n\t\tif (mode == TT_SHIFTER_TTHIGH)\n\t\t\tfix->visual = FB_VISUAL_MONO01;\n\t}\n\tfix->xpanstep = 0;\n\tfix->ypanstep = 1;\n\tfix->ywrapstep = 0;\n\tfix->line_length = par->next_line;\n\tfix->accel = FB_ACCEL_ATARIBLITT;\n\treturn 0;\n}\n\nstatic int tt_decode_var(struct fb_var_screeninfo *var, struct atafb_par *par)\n{\n\tint xres = var->xres;\n\tint yres = var->yres;\n\tint bpp = var->bits_per_pixel;\n\tint linelen;\n\tint yres_virtual = var->yres_virtual;\n\n\tif (mono_moni) {\n\t\tif (bpp > 1 || xres > sttt_xres * 2 || yres > tt_yres * 2)\n\t\t\treturn -EINVAL;\n\t\tpar->hw.tt.mode = TT_SHIFTER_TTHIGH;\n\t\txres = sttt_xres * 2;\n\t\tyres = tt_yres * 2;\n\t\tbpp = 1;\n\t} else {\n\t\tif (bpp > 8 || xres > sttt_xres || yres > tt_yres)\n\t\t\treturn -EINVAL;\n\t\tif (bpp > 4) {\n\t\t\tif (xres > sttt_xres / 2 || yres > tt_yres)\n\t\t\t\treturn -EINVAL;\n\t\t\tpar->hw.tt.mode = TT_SHIFTER_TTLOW;\n\t\t\txres = sttt_xres / 2;\n\t\t\tyres = tt_yres;\n\t\t\tbpp = 8;\n\t\t} else if (bpp > 2) {\n\t\t\tif (xres > sttt_xres || yres > tt_yres)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (xres > sttt_xres / 2 || yres > st_yres / 2) {\n\t\t\t\tpar->hw.tt.mode = TT_SHIFTER_TTMID;\n\t\t\t\txres = sttt_xres;\n\t\t\t\tyres = tt_yres;\n\t\t\t\tbpp = 4;\n\t\t\t} else {\n\t\t\t\tpar->hw.tt.mode = TT_SHIFTER_STLOW;\n\t\t\t\txres = sttt_xres / 2;\n\t\t\t\tyres = st_yres / 2;\n\t\t\t\tbpp = 4;\n\t\t\t}\n\t\t} else if (bpp > 1) {\n\t\t\tif (xres > sttt_xres || yres > st_yres / 2)\n\t\t\t\treturn -EINVAL;\n\t\t\tpar->hw.tt.mode = TT_SHIFTER_STMID;\n\t\t\txres = sttt_xres;\n\t\t\tyres = st_yres / 2;\n\t\t\tbpp = 2;\n\t\t} else if (var->xres > sttt_xres || var->yres > st_yres) {\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tpar->hw.tt.mode = TT_SHIFTER_STHIGH;\n\t\t\txres = sttt_xres;\n\t\t\tyres = st_yres;\n\t\t\tbpp = 1;\n\t\t}\n\t}\n\tif (yres_virtual <= 0)\n\t\tyres_virtual = 0;\n\telse if (yres_virtual < yres)\n\t\tyres_virtual = yres;\n\tif (var->sync & FB_SYNC_EXT)\n\t\tpar->hw.tt.sync = 0;\n\telse\n\t\tpar->hw.tt.sync = 1;\n\tlinelen = xres * bpp / 8;\n\tif (yres_virtual * linelen > screen_len && screen_len)\n\t\treturn -EINVAL;\n\tif (yres * linelen > screen_len && screen_len)\n\t\treturn -EINVAL;\n\tif (var->yoffset + yres > yres_virtual && yres_virtual)\n\t\treturn -EINVAL;\n\tpar->yres_virtual = yres_virtual;\n\tpar->screen_base = screen_base + var->yoffset * linelen;\n\tpar->next_line = linelen;\n\treturn 0;\n}\n\nstatic int tt_encode_var(struct fb_var_screeninfo *var, struct atafb_par *par)\n{\n\tint linelen;\n\tmemset(var, 0, sizeof(struct fb_var_screeninfo));\n\tvar->red.offset = 0;\n\tvar->red.length = 4;\n\tvar->red.msb_right = 0;\n\tvar->grayscale = 0;\n\n\tvar->pixclock = 31041;\n\tvar->left_margin = 120;\t\t \n\tvar->right_margin = 100;\n\tvar->upper_margin = 8;\n\tvar->lower_margin = 16;\n\tvar->hsync_len = 140;\n\tvar->vsync_len = 30;\n\n\tvar->height = -1;\n\tvar->width = -1;\n\n\tif (par->hw.tt.sync & 1)\n\t\tvar->sync = 0;\n\telse\n\t\tvar->sync = FB_SYNC_EXT;\n\n\tswitch (par->hw.tt.mode & TT_SHIFTER_MODEMASK) {\n\tcase TT_SHIFTER_STLOW:\n\t\tvar->xres = sttt_xres / 2;\n\t\tvar->xres_virtual = sttt_xres_virtual / 2;\n\t\tvar->yres = st_yres / 2;\n\t\tvar->bits_per_pixel = 4;\n\t\tbreak;\n\tcase TT_SHIFTER_STMID:\n\t\tvar->xres = sttt_xres;\n\t\tvar->xres_virtual = sttt_xres_virtual;\n\t\tvar->yres = st_yres / 2;\n\t\tvar->bits_per_pixel = 2;\n\t\tbreak;\n\tcase TT_SHIFTER_STHIGH:\n\t\tvar->xres = sttt_xres;\n\t\tvar->xres_virtual = sttt_xres_virtual;\n\t\tvar->yres = st_yres;\n\t\tvar->bits_per_pixel = 1;\n\t\tbreak;\n\tcase TT_SHIFTER_TTLOW:\n\t\tvar->xres = sttt_xres / 2;\n\t\tvar->xres_virtual = sttt_xres_virtual / 2;\n\t\tvar->yres = tt_yres;\n\t\tvar->bits_per_pixel = 8;\n\t\tbreak;\n\tcase TT_SHIFTER_TTMID:\n\t\tvar->xres = sttt_xres;\n\t\tvar->xres_virtual = sttt_xres_virtual;\n\t\tvar->yres = tt_yres;\n\t\tvar->bits_per_pixel = 4;\n\t\tbreak;\n\tcase TT_SHIFTER_TTHIGH:\n\t\tvar->red.length = 0;\n\t\tvar->xres = sttt_xres * 2;\n\t\tvar->xres_virtual = sttt_xres_virtual * 2;\n\t\tvar->yres = tt_yres * 2;\n\t\tvar->bits_per_pixel = 1;\n\t\tbreak;\n\t}\n\tvar->blue = var->green = var->red;\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\tvar->transp.msb_right = 0;\n\tlinelen = var->xres_virtual * var->bits_per_pixel / 8;\n\tif (!use_hwscroll)\n\t\tvar->yres_virtual = var->yres;\n\telse if (screen_len) {\n\t\tif (par->yres_virtual)\n\t\t\tvar->yres_virtual = par->yres_virtual;\n\t\telse\n\t\t\t \n\t\t\tvar->yres_virtual = screen_len / linelen;\n\t} else {\n\t\tif (hwscroll < 0)\n\t\t\tvar->yres_virtual = 2 * var->yres;\n\t\telse\n\t\t\tvar->yres_virtual = var->yres + hwscroll * 16;\n\t}\n\tvar->xoffset = 0;\n\tif (screen_base)\n\t\tvar->yoffset = (par->screen_base - screen_base) / linelen;\n\telse\n\t\tvar->yoffset = 0;\n\tvar->nonstd = 0;\n\tvar->activate = 0;\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\treturn 0;\n}\n\nstatic void tt_get_par(struct atafb_par *par)\n{\n\tunsigned long addr;\n\tpar->hw.tt.mode = shifter_tt.tt_shiftmode;\n\tpar->hw.tt.sync = shifter_st.syncmode;\n\taddr = ((shifter_st.bas_hi & 0xff) << 16) |\n\t       ((shifter_st.bas_md & 0xff) << 8)  |\n\t       ((shifter_st.bas_lo & 0xff));\n\tpar->screen_base = atari_stram_to_virt(addr);\n}\n\nstatic void tt_set_par(struct atafb_par *par)\n{\n\tshifter_tt.tt_shiftmode = par->hw.tt.mode;\n\tshifter_st.syncmode = par->hw.tt.sync;\n\t \n\tif (current_par.screen_base != par->screen_base)\n\t\tfbhw->set_screen_base(par->screen_base);\n}\n\nstatic int tt_setcolreg(unsigned int regno, unsigned int red,\n\t\t\tunsigned int green, unsigned int blue,\n\t\t\tunsigned int transp, struct fb_info *info)\n{\n\tif ((shifter_tt.tt_shiftmode & TT_SHIFTER_MODEMASK) == TT_SHIFTER_STHIGH)\n\t\tregno += 254;\n\tif (regno > 255)\n\t\treturn 1;\n\ttt_palette[regno] = (((red >> 12) << 8) | ((green >> 12) << 4) |\n\t\t\t     (blue >> 12));\n\tif ((shifter_tt.tt_shiftmode & TT_SHIFTER_MODEMASK) ==\n\t    TT_SHIFTER_STHIGH && regno == 254)\n\t\ttt_palette[0] = 0;\n\treturn 0;\n}\n\nstatic int tt_detect(void)\n{\n\tstruct atafb_par par;\n\n\t \n\tif (ATARIHW_PRESENT(PCM_8BIT)) {\n\t\ttt_dmasnd.ctrl = DMASND_CTRL_OFF;\n\t\tudelay(20);\t\t \n\t}\n\tmono_moni = (st_mfp.par_dt_reg & 0x80) == 0;\n\n\ttt_get_par(&par);\n\ttt_encode_var(&atafb_predefined[0], &par);\n\n\treturn 1;\n}\n\n#endif  \n\n \n\n#ifdef ATAFB_FALCON\n\nstatic int mon_type;\t\t \nstatic int f030_bus_width;\t \n#define F_MON_SM\t0\n#define F_MON_SC\t1\n#define F_MON_VGA\t2\n#define F_MON_TV\t3\n\nstatic struct pixel_clock {\n\tunsigned long f;\t \n\tunsigned long t;\t \n\tint right, hsync, left;\t \n\t \n\tint sync_mask;\t\t \n\tint control_mask;\t \n} f25 = {\n\t25175000, 39721, 18, 0, 42, 0x0, VCO_CLOCK25\n}, f32 = {\n\t32000000, 31250, 18, 0, 42, 0x0, 0\n}, fext = {\n\t0, 0, 18, 0, 42, 0x1, 0\n};\n\n \nstatic int vdl_prescale[4][3] = {\n\t{ 4,2,1 }, { 4,2,1 }, { 4,2,2 }, { 4,2,1 }\n};\n\n \nstatic long h_syncs[4] = { 3000000, 4875000, 4000000, 4875000 };\n\nstatic inline int hxx_prescale(struct falcon_hw *hw)\n{\n\treturn hw->ste_mode ? 16\n\t\t\t    : vdl_prescale[mon_type][hw->vid_mode >> 2 & 0x3];\n}\n\nstatic int falcon_encode_fix(struct fb_fix_screeninfo *fix,\n\t\t\t     struct atafb_par *par)\n{\n\tstrcpy(fix->id, \"Atari Builtin\");\n\tfix->smem_start = phys_screen_base;\n\tfix->smem_len = screen_len;\n\tfix->type = FB_TYPE_INTERLEAVED_PLANES;\n\tfix->type_aux = 2;\n\tfix->visual = FB_VISUAL_PSEUDOCOLOR;\n\tfix->xpanstep = 1;\n\tfix->ypanstep = 1;\n\tfix->ywrapstep = 0;\n\tif (par->hw.falcon.mono) {\n\t\tfix->type = FB_TYPE_PACKED_PIXELS;\n\t\tfix->type_aux = 0;\n\t\t \n\t\tfix->xpanstep = 32;\n\t} else if (par->hw.falcon.f_shift & 0x100) {\n\t\tfix->type = FB_TYPE_PACKED_PIXELS;\n\t\tfix->type_aux = 0;\n\t\t \n\t\tfix->visual = FB_VISUAL_TRUECOLOR;\n\t\tfix->xpanstep = 2;\n\t}\n\tfix->line_length = par->next_line;\n\tfix->accel = FB_ACCEL_ATARIBLITT;\n\treturn 0;\n}\n\nstatic int falcon_decode_var(struct fb_var_screeninfo *var,\n\t\t\t     struct atafb_par *par)\n{\n\tint bpp = var->bits_per_pixel;\n\tint xres = var->xres;\n\tint yres = var->yres;\n\tint xres_virtual = var->xres_virtual;\n\tint yres_virtual = var->yres_virtual;\n\tint left_margin, right_margin, hsync_len;\n\tint upper_margin, lower_margin, vsync_len;\n\tint linelen;\n\tint interlace = 0, doubleline = 0;\n\tstruct pixel_clock *pclock;\n\tint plen;\t\t\t \n\tint xstretch;\n\tint prescale;\n\tint longoffset = 0;\n\tint hfreq, vfreq;\n\tint hdb_off, hde_off, base_off;\n\tint gstart, gend1, gend2, align;\n\n \n\n\t \n\tif (!xres || !yres || !bpp)\n\t\treturn -EINVAL;\n\n\tif (mon_type == F_MON_SM && bpp != 1)\n\t\treturn -EINVAL;\n\n\tif (bpp <= 1) {\n\t\tbpp = 1;\n\t\tpar->hw.falcon.f_shift = 0x400;\n\t\tpar->hw.falcon.st_shift = 0x200;\n\t} else if (bpp <= 2) {\n\t\tbpp = 2;\n\t\tpar->hw.falcon.f_shift = 0x000;\n\t\tpar->hw.falcon.st_shift = 0x100;\n\t} else if (bpp <= 4) {\n\t\tbpp = 4;\n\t\tpar->hw.falcon.f_shift = 0x000;\n\t\tpar->hw.falcon.st_shift = 0x000;\n\t} else if (bpp <= 8) {\n\t\tbpp = 8;\n\t\tpar->hw.falcon.f_shift = 0x010;\n\t} else if (bpp <= 16) {\n\t\tbpp = 16;\t\t \n\t\tpar->hw.falcon.f_shift = 0x100;\t \n\t} else\n\t\treturn -EINVAL;\n\tpar->hw.falcon.bpp = bpp;\n\n\tif (mon_type == F_MON_SM || DontCalcRes) {\n\t\t \n\t\tstruct fb_var_screeninfo *myvar = &atafb_predefined[0];\n\n\t\tif (bpp > myvar->bits_per_pixel ||\n\t\t    var->xres > myvar->xres ||\n\t\t    var->yres > myvar->yres)\n\t\t\treturn -EINVAL;\n\t\tfbhw->get_par(par);\t \n\t\tgoto set_screen_base;\t \n\t}\n\n\t \n\tif (xres <= 320)\n\t\txres = 320;\n\telse if (xres <= 640 && bpp != 16)\n\t\txres = 640;\n\tif (yres <= 200)\n\t\tyres = 200;\n\telse if (yres <= 240)\n\t\tyres = 240;\n\telse if (yres <= 400)\n\t\tyres = 400;\n\n\t \n\tpar->hw.falcon.ste_mode = bpp == 2;\n\tpar->hw.falcon.mono = bpp == 1;\n\n\t \n\tif (par->hw.falcon.ste_mode)\n\t\txres = (xres + 63) & ~63;\n\telse if (bpp == 1)\n\t\txres = (xres + 31) & ~31;\n\telse\n\t\txres = (xres + 15) & ~15;\n\tif (yres >= 400)\n\t\tyres = (yres + 15) & ~15;\n\telse\n\t\tyres = (yres + 7) & ~7;\n\n\tif (xres_virtual < xres)\n\t\txres_virtual = xres;\n\telse if (bpp == 1)\n\t\txres_virtual = (xres_virtual + 31) & ~31;\n\telse\n\t\txres_virtual = (xres_virtual + 15) & ~15;\n\n\tif (yres_virtual <= 0)\n\t\tyres_virtual = 0;\n\telse if (yres_virtual < yres)\n\t\tyres_virtual = yres;\n\n\tpar->hw.falcon.line_width = bpp * xres / 16;\n\tpar->hw.falcon.line_offset = bpp * (xres_virtual - xres) / 16;\n\n\t \n\txstretch = (xres < 640) ? 2 : 1;\n\n#if 0  \n\tif (mon_type == F_MON_SM) {\n\t\tif (xres != 640 && yres != 400)\n\t\t\treturn -EINVAL;\n\t\tplen = 1;\n\t\tpclock = &f32;\n\t\t \n\t\tpar->hw.falcon.ste_mode = 1;\n\t\tpar->hw.falcon.f_shift = 0x000;\n\t\tpar->hw.falcon.st_shift = 0x200;\n\t\tleft_margin = hsync_len = 128 / plen;\n\t\tright_margin = 0;\n\t\t \n\t} else\n#endif\n\tif (mon_type == F_MON_SC || mon_type == F_MON_TV) {\n\t\tplen = 2 * xstretch;\n\t\tif (var->pixclock > f32.t * plen)\n\t\t\treturn -EINVAL;\n\t\tpclock = &f32;\n\t\tif (yres > 240)\n\t\t\tinterlace = 1;\n\t\tif (var->pixclock == 0) {\n\t\t\t \n\t\t\tleft_margin = 32;\n\t\t\tright_margin = 18;\n\t\t\thsync_len = pclock->hsync / plen;\n\t\t\tupper_margin = 31;\n\t\t\tlower_margin = 14;\n\t\t\tvsync_len = interlace ? 3 : 4;\n\t\t} else {\n\t\t\tleft_margin = var->left_margin;\n\t\t\tright_margin = var->right_margin;\n\t\t\thsync_len = var->hsync_len;\n\t\t\tupper_margin = var->upper_margin;\n\t\t\tlower_margin = var->lower_margin;\n\t\t\tvsync_len = var->vsync_len;\n\t\t\tif (var->vmode & FB_VMODE_INTERLACED) {\n\t\t\t\tupper_margin = (upper_margin + 1) / 2;\n\t\t\t\tlower_margin = (lower_margin + 1) / 2;\n\t\t\t\tvsync_len = (vsync_len + 1) / 2;\n\t\t\t} else if (var->vmode & FB_VMODE_DOUBLE) {\n\t\t\t\tupper_margin *= 2;\n\t\t\t\tlower_margin *= 2;\n\t\t\t\tvsync_len *= 2;\n\t\t\t}\n\t\t}\n\t} else {\t\t\t \n\t\tif (bpp == 16)\n\t\t\txstretch = 2;\t \n\t\t \n\t\tif (var->pixclock == 0) {\n\t\t\t \n\t\t\tplen = 1 * xstretch;\n\t\t\tif ((plen * xres + f25.right + f25.hsync + f25.left) *\n\t\t\t    fb_info.monspecs.hfmin < f25.f)\n\t\t\t\tpclock = &f25;\n\t\t\telse if ((plen * xres + f32.right + f32.hsync +\n\t\t\t\t  f32.left) * fb_info.monspecs.hfmin < f32.f)\n\t\t\t\tpclock = &f32;\n\t\t\telse if ((plen * xres + fext.right + fext.hsync +\n\t\t\t\t  fext.left) * fb_info.monspecs.hfmin < fext.f &&\n\t\t\t         fext.f)\n\t\t\t\tpclock = &fext;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\n\t\t\tleft_margin = pclock->left / plen;\n\t\t\tright_margin = pclock->right / plen;\n\t\t\thsync_len = pclock->hsync / plen;\n\t\t\tupper_margin = 31;\n\t\t\tlower_margin = 11;\n\t\t\tvsync_len = 3;\n\t\t} else {\n\t\t\t \n\t\t\tint i;\n\t\t\tunsigned long pcl = ULONG_MAX;\n\t\t\tpclock = 0;\n\t\t\tfor (i = 1; i <= 4; i *= 2) {\n\t\t\t\tif (f25.t * i >= var->pixclock &&\n\t\t\t\t    f25.t * i < pcl) {\n\t\t\t\t\tpcl = f25.t * i;\n\t\t\t\t\tpclock = &f25;\n\t\t\t\t}\n\t\t\t\tif (f32.t * i >= var->pixclock &&\n\t\t\t\t    f32.t * i < pcl) {\n\t\t\t\t\tpcl = f32.t * i;\n\t\t\t\t\tpclock = &f32;\n\t\t\t\t}\n\t\t\t\tif (fext.t && fext.t * i >= var->pixclock &&\n\t\t\t\t    fext.t * i < pcl) {\n\t\t\t\t\tpcl = fext.t * i;\n\t\t\t\t\tpclock = &fext;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!pclock)\n\t\t\t\treturn -EINVAL;\n\t\t\tplen = pcl / pclock->t;\n\n\t\t\tleft_margin = var->left_margin;\n\t\t\tright_margin = var->right_margin;\n\t\t\thsync_len = var->hsync_len;\n\t\t\tupper_margin = var->upper_margin;\n\t\t\tlower_margin = var->lower_margin;\n\t\t\tvsync_len = var->vsync_len;\n\t\t\t \n\t\t\tif (var->vmode & FB_VMODE_INTERLACED) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tupper_margin = (upper_margin + 1) / 2;\n\t\t\t\tlower_margin = (lower_margin + 1) / 2;\n\t\t\t\tvsync_len = (vsync_len + 1) / 2;\n\t\t\t} else if (var->vmode & FB_VMODE_DOUBLE) {\n\t\t\t\t \n\t\t\t\tupper_margin *= 2;\n\t\t\t\tlower_margin *= 2;\n\t\t\t\tvsync_len *= 2;\n\t\t\t}\n\t\t}\n\t\tif (pclock == &fext)\n\t\t\tlongoffset = 1;\t \n\t}\n\t \n\t \n\tif (pclock->f / plen / 8 * bpp > 32000000L)\n\t\treturn -EINVAL;\n\n\tif (vsync_len < 1)\n\t\tvsync_len = 1;\n\n\t \n\tright_margin += hsync_len;\n\tlower_margin += vsync_len;\n\n\t \nagain:\n\t \n\tpar->hw.falcon.vid_control = mon_type | f030_bus_width;\n\tif (!longoffset)\n\t\tpar->hw.falcon.vid_control |= VCO_SHORTOFFS;\t \n\tif (var->sync & FB_SYNC_HOR_HIGH_ACT)\n\t\tpar->hw.falcon.vid_control |= VCO_HSYPOS;\n\tif (var->sync & FB_SYNC_VERT_HIGH_ACT)\n\t\tpar->hw.falcon.vid_control |= VCO_VSYPOS;\n\t \n\tpar->hw.falcon.vid_control |= pclock->control_mask;\n\t \n\tpar->hw.falcon.sync = pclock->sync_mask | 0x2;\n\t \n\tpar->hw.falcon.vid_mode = (2 / plen) << 2;\n\tif (doubleline)\n\t\tpar->hw.falcon.vid_mode |= VMO_DOUBLE;\n\tif (interlace)\n\t\tpar->hw.falcon.vid_mode |= VMO_INTER;\n\n\t \n\t \n{\n\tprescale = hxx_prescale(&par->hw.falcon);\n\tbase_off = par->hw.falcon.vid_control & VCO_SHORTOFFS ? 64 : 128;\n\n\t \n\t \n\tif (par->hw.falcon.f_shift & 0x100) {\n\t\talign = 1;\n\t\thde_off = 0;\n\t\thdb_off = (base_off + 16 * plen) + prescale;\n\t} else {\n\t\talign = 128 / bpp;\n\t\thde_off = ((128 / bpp + 2) * plen);\n\t\tif (par->hw.falcon.ste_mode)\n\t\t\thdb_off = (64 + base_off + (128 / bpp + 2) * plen) + prescale;\n\t\telse\n\t\t\thdb_off = (base_off + (128 / bpp + 18) * plen) + prescale;\n\t}\n\n\tgstart = (prescale / 2 + plen * left_margin) / prescale;\n\t \n\tgend1 = gstart + roundup(xres, align) * plen / prescale;\n\t \n\tgend2 = gstart + xres * plen / prescale;\n\tpar->HHT = plen * (left_margin + xres + right_margin) /\n\t\t\t   (2 * prescale) - 2;\n \n\n\tpar->HDB = gstart - hdb_off / prescale;\n\tpar->HBE = gstart;\n\tif (par->HDB < 0)\n\t\tpar->HDB += par->HHT + 2 + 0x200;\n\tpar->HDE = gend1 - par->HHT - 2 - hde_off / prescale;\n\tpar->HBB = gend2 - par->HHT - 2;\n#if 0\n\t \n\tif ((par->HDB & 0x200) && (par->HDB & ~0x200) - par->HDE <= 5) {\n\t\t \n\t}\n#endif\n\tif (hde_off % prescale)\n\t\tpar->HBB++;\t\t \n\tpar->HSS = par->HHT + 2 - plen * hsync_len / prescale;\n\tif (par->HSS < par->HBB)\n\t\tpar->HSS = par->HBB;\n}\n\n\t \n\thfreq = pclock->f / ((par->HHT + 2) * prescale * 2);\n\tif (hfreq > fb_info.monspecs.hfmax && mon_type != F_MON_VGA) {\n\t\t \n\t\t \n\t\tleft_margin += 1;\n\t\tright_margin += 1;\n\t\tgoto again;\n\t}\n\tif (hfreq > fb_info.monspecs.hfmax || hfreq < fb_info.monspecs.hfmin)\n\t\treturn -EINVAL;\n\n\t \n\t \n\tpar->VBE = (upper_margin * 2 + 1);  \n\tpar->VDB = par->VBE;\n\tpar->VDE = yres;\n\tif (!interlace)\n\t\tpar->VDE <<= 1;\n\tif (doubleline)\n\t\tpar->VDE <<= 1;\t\t \n\tpar->VDE += par->VDB;\n\tpar->VBB = par->VDE;\n\tpar->VFT = par->VBB + (lower_margin * 2 - 1) - 1;\n\tpar->VSS = par->VFT + 1 - (vsync_len * 2 - 1);\n\t \n\tif (interlace) {\n\t\tpar->VBB++;\n\t\tpar->VSS++;\n\t\tpar->VFT++;\n\t}\n\n\t \n\t \n\tvfreq = (hfreq * 2) / (par->VFT + 1);\n\tif (vfreq > fb_info.monspecs.vfmax && !doubleline && !interlace) {\n\t\t \n\t\tdoubleline = 1;\n\t\tgoto again;\n\t} else if (vfreq < fb_info.monspecs.vfmin && !interlace && !doubleline) {\n\t\t \n\t\tinterlace = 1;\n\t\tgoto again;\n\t} else if (vfreq < fb_info.monspecs.vfmin && doubleline) {\n\t\t \n\t\tint lines;\n\t\tdoubleline = 0;\n\t\tfor (lines = 0;\n\t\t     (hfreq * 2) / (par->VFT + 1 + 4 * lines - 2 * yres) >\n\t\t     fb_info.monspecs.vfmax;\n\t\t     lines++)\n\t\t\t;\n\t\tupper_margin += lines;\n\t\tlower_margin += lines;\n\t\tgoto again;\n\t} else if (vfreq > fb_info.monspecs.vfmax && doubleline) {\n\t\t \n\t\tint lines;\n\t\tfor (lines = 0;\n\t\t     (hfreq * 2) / (par->VFT + 1 + 4 * lines) >\n\t\t     fb_info.monspecs.vfmax;\n\t\t     lines += 2)\n\t\t\t;\n\t\tupper_margin += lines;\n\t\tlower_margin += lines;\n\t\tgoto again;\n\t} else if (vfreq > fb_info.monspecs.vfmax && interlace) {\n\t\t \n\t\tint lines;\n\t\tfor (lines = 0;\n\t\t     (hfreq * 2) / (par->VFT + 1 + 4 * lines) >\n\t\t     fb_info.monspecs.vfmax;\n\t\t     lines++)\n\t\t\t;\n\t\tupper_margin += lines;\n\t\tlower_margin += lines;\n\t\tgoto again;\n\t} else if (vfreq < fb_info.monspecs.vfmin ||\n\t\t   vfreq > fb_info.monspecs.vfmax)\n\t\treturn -EINVAL;\n\nset_screen_base:\n\tlinelen = xres_virtual * bpp / 8;\n\tif (yres_virtual * linelen > screen_len && screen_len)\n\t\treturn -EINVAL;\n\tif (yres * linelen > screen_len && screen_len)\n\t\treturn -EINVAL;\n\tif (var->yoffset + yres > yres_virtual && yres_virtual)\n\t\treturn -EINVAL;\n\tpar->yres_virtual = yres_virtual;\n\tpar->screen_base = screen_base + var->yoffset * linelen;\n\tpar->hw.falcon.xoffset = 0;\n\n\tpar->next_line = linelen;\n\n\treturn 0;\n}\n\nstatic int falcon_encode_var(struct fb_var_screeninfo *var,\n\t\t\t     struct atafb_par *par)\n{\n \n\tint linelen;\n\tint prescale, plen;\n\tint hdb_off, hde_off, base_off;\n\tstruct falcon_hw *hw = &par->hw.falcon;\n\n\tmemset(var, 0, sizeof(struct fb_var_screeninfo));\n\t \n\tvar->pixclock = hw->sync & 0x1 ? fext.t :\n\t                hw->vid_control & VCO_CLOCK25 ? f25.t : f32.t;\n\n\tvar->height = -1;\n\tvar->width = -1;\n\n\tvar->sync = 0;\n\tif (hw->vid_control & VCO_HSYPOS)\n\t\tvar->sync |= FB_SYNC_HOR_HIGH_ACT;\n\tif (hw->vid_control & VCO_VSYPOS)\n\t\tvar->sync |= FB_SYNC_VERT_HIGH_ACT;\n\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\tif (hw->vid_mode & VMO_INTER)\n\t\tvar->vmode |= FB_VMODE_INTERLACED;\n\tif (hw->vid_mode & VMO_DOUBLE)\n\t\tvar->vmode |= FB_VMODE_DOUBLE;\n\n\t \n\tvar->yres = hw->vde - hw->vdb;\n\tif (!(var->vmode & FB_VMODE_INTERLACED))\n\t\tvar->yres >>= 1;\n\tif (var->vmode & FB_VMODE_DOUBLE)\n\t\tvar->yres >>= 1;\n\n\t \n\tif (hw->f_shift & 0x400)\t \n\t\tvar->bits_per_pixel = 1;\n\telse if (hw->f_shift & 0x100)\t \n\t\tvar->bits_per_pixel = 16;\n\telse if (hw->f_shift & 0x010)\t \n\t\tvar->bits_per_pixel = 8;\n\telse if (hw->st_shift == 0)\n\t\tvar->bits_per_pixel = 4;\n\telse if (hw->st_shift == 0x100)\n\t\tvar->bits_per_pixel = 2;\n\telse\t\t\t\t \n\t\tvar->bits_per_pixel = 1;\n\n\tvar->xres = hw->line_width * 16 / var->bits_per_pixel;\n\tvar->xres_virtual = var->xres + hw->line_offset * 16 / var->bits_per_pixel;\n\tif (hw->xoffset)\n\t\tvar->xres_virtual += 16;\n\n\tif (var->bits_per_pixel == 16) {\n\t\tvar->red.offset = 11;\n\t\tvar->red.length = 5;\n\t\tvar->red.msb_right = 0;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->green.msb_right = 0;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tvar->blue.msb_right = 0;\n\t} else {\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = hw->ste_mode ? 4 : 6;\n\t\tif (var->red.length > var->bits_per_pixel)\n\t\t\tvar->red.length = var->bits_per_pixel;\n\t\tvar->red.msb_right = 0;\n\t\tvar->grayscale = 0;\n\t\tvar->blue = var->green = var->red;\n\t}\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\tvar->transp.msb_right = 0;\n\n\tlinelen = var->xres_virtual * var->bits_per_pixel / 8;\n\tif (screen_len) {\n\t\tif (par->yres_virtual)\n\t\t\tvar->yres_virtual = par->yres_virtual;\n\t\telse\n\t\t\t \n\t\t\tvar->yres_virtual = screen_len / linelen;\n\t} else {\n\t\tif (hwscroll < 0)\n\t\t\tvar->yres_virtual = 2 * var->yres;\n\t\telse\n\t\t\tvar->yres_virtual = var->yres + hwscroll * 16;\n\t}\n\tvar->xoffset = 0;\t\t \n\n\t \n\tprescale = hxx_prescale(hw);\n\tplen = 4 >> (hw->vid_mode >> 2 & 0x3);\n\tbase_off = hw->vid_control & VCO_SHORTOFFS ? 64 : 128;\n\tif (hw->f_shift & 0x100) {\n\t\thde_off = 0;\n\t\thdb_off = (base_off + 16 * plen) + prescale;\n\t} else {\n\t\thde_off = ((128 / var->bits_per_pixel + 2) * plen);\n\t\tif (hw->ste_mode)\n\t\t\thdb_off = (64 + base_off + (128 / var->bits_per_pixel + 2) * plen)\n\t\t\t\t\t + prescale;\n\t\telse\n\t\t\thdb_off = (base_off + (128 / var->bits_per_pixel + 18) * plen)\n\t\t\t\t\t + prescale;\n\t}\n\n\t \n\tvar->left_margin = hdb_off + prescale * ((hw->hdb & 0x1ff) -\n\t\t\t\t\t   (hw->hdb & 0x200 ? 2 + hw->hht : 0));\n\tif (hw->ste_mode || mon_type != F_MON_VGA)\n\t\tvar->right_margin = prescale * (hw->hht + 2 - hw->hde) - hde_off;\n\telse\n\t\t \n\t\tvar->right_margin = prescale * (hw->hht + 2 - hw->hbb);\n\tvar->hsync_len = prescale * (hw->hht + 2 - hw->hss);\n\n\t \n\tvar->upper_margin = hw->vdb / 2;\t \n\tvar->lower_margin = (hw->vft + 1 - hw->vde + 1) / 2;\t \n\tvar->vsync_len = (hw->vft + 1 - hw->vss + 1) / 2;\t \n\tif (var->vmode & FB_VMODE_INTERLACED) {\n\t\tvar->upper_margin *= 2;\n\t\tvar->lower_margin *= 2;\n\t\tvar->vsync_len *= 2;\n\t} else if (var->vmode & FB_VMODE_DOUBLE) {\n\t\tvar->upper_margin = (var->upper_margin + 1) / 2;\n\t\tvar->lower_margin = (var->lower_margin + 1) / 2;\n\t\tvar->vsync_len = (var->vsync_len + 1) / 2;\n\t}\n\n\tvar->pixclock *= plen;\n\tvar->left_margin /= plen;\n\tvar->right_margin /= plen;\n\tvar->hsync_len /= plen;\n\n\tvar->right_margin -= var->hsync_len;\n\tvar->lower_margin -= var->vsync_len;\n\n\tif (screen_base)\n\t\tvar->yoffset = (par->screen_base - screen_base) / linelen;\n\telse\n\t\tvar->yoffset = 0;\n\tvar->nonstd = 0;\t\t \n\tvar->activate = 0;\n\treturn 0;\n}\n\nstatic int f_change_mode;\nstatic struct falcon_hw f_new_mode;\nstatic int f_pan_display;\n\nstatic void falcon_get_par(struct atafb_par *par)\n{\n\tunsigned long addr;\n\tstruct falcon_hw *hw = &par->hw.falcon;\n\n\thw->line_width = shifter_f030.scn_width;\n\thw->line_offset = shifter_f030.off_next;\n\thw->st_shift = videl.st_shift & 0x300;\n\thw->f_shift = videl.f_shift;\n\thw->vid_control = videl.control;\n\thw->vid_mode = videl.mode;\n\thw->sync = shifter_st.syncmode & 0x1;\n\thw->xoffset = videl.xoffset & 0xf;\n\thw->hht = videl.hht;\n\thw->hbb = videl.hbb;\n\thw->hbe = videl.hbe;\n\thw->hdb = videl.hdb;\n\thw->hde = videl.hde;\n\thw->hss = videl.hss;\n\thw->vft = videl.vft;\n\thw->vbb = videl.vbb;\n\thw->vbe = videl.vbe;\n\thw->vdb = videl.vdb;\n\thw->vde = videl.vde;\n\thw->vss = videl.vss;\n\n\taddr = (shifter_st.bas_hi & 0xff) << 16 |\n\t       (shifter_st.bas_md & 0xff) << 8  |\n\t       (shifter_st.bas_lo & 0xff);\n\tpar->screen_base = atari_stram_to_virt(addr);\n\n\t \n\thw->ste_mode = (hw->f_shift & 0x510) == 0 && hw->st_shift == 0x100;\n\thw->mono = (hw->f_shift & 0x400) ||\n\t           ((hw->f_shift & 0x510) == 0 && hw->st_shift == 0x200);\n}\n\nstatic void falcon_set_par(struct atafb_par *par)\n{\n\tf_change_mode = 0;\n\n\t \n\tif (current_par.screen_base != par->screen_base)\n\t\tfbhw->set_screen_base(par->screen_base);\n\n\t \n\tif (DontCalcRes)\n\t\treturn;\n\n\t \n\tf_new_mode = par->hw.falcon;\n\tf_change_mode = 1;\n}\n\nstatic irqreturn_t falcon_vbl_switcher(int irq, void *dummy)\n{\n\tstruct falcon_hw *hw = &f_new_mode;\n\n\tif (f_change_mode) {\n\t\tf_change_mode = 0;\n\n\t\tif (hw->sync & 0x1) {\n\t\t\t \n\t\t\t*(volatile unsigned short *)0xffff9202 = 0xffbf;\n\t\t} else {\n\t\t\t \n\t\t\t*(volatile unsigned short *)0xffff9202;\n\t\t}\n\t\tshifter_st.syncmode = hw->sync;\n\n\t\tvidel.hht = hw->hht;\n\t\tvidel.hbb = hw->hbb;\n\t\tvidel.hbe = hw->hbe;\n\t\tvidel.hdb = hw->hdb;\n\t\tvidel.hde = hw->hde;\n\t\tvidel.hss = hw->hss;\n\t\tvidel.vft = hw->vft;\n\t\tvidel.vbb = hw->vbb;\n\t\tvidel.vbe = hw->vbe;\n\t\tvidel.vdb = hw->vdb;\n\t\tvidel.vde = hw->vde;\n\t\tvidel.vss = hw->vss;\n\n\t\tvidel.f_shift = 0;\t \n\t\tif (hw->ste_mode) {\n\t\t\tvidel.st_shift = hw->st_shift;\t \n\t\t} else {\n\t\t\t \n\t\t\tvidel.st_shift = 0;\n\t\t\t \n\t\t\tvidel.f_shift = hw->f_shift;\n\t\t}\n\t\t \n\t\tvidel.xoffset = hw->xoffset;\n\t\tshifter_f030.scn_width = hw->line_width;\n\t\tshifter_f030.off_next = hw->line_offset;\n\t\tvidel.control = hw->vid_control;\n\t\tvidel.mode = hw->vid_mode;\n\t}\n\tif (f_pan_display) {\n\t\tf_pan_display = 0;\n\t\tvidel.xoffset = current_par.hw.falcon.xoffset;\n\t\tshifter_f030.off_next = current_par.hw.falcon.line_offset;\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int falcon_pan_display(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct atafb_par *par = info->par;\n\n\tint xoffset;\n\tint bpp = info->var.bits_per_pixel;\n\n\tif (bpp == 1)\n\t\tvar->xoffset = round_up(var->xoffset, 32);\n\tif (bpp != 16)\n\t\tpar->hw.falcon.xoffset = var->xoffset & 15;\n\telse {\n\t\tpar->hw.falcon.xoffset = 0;\n\t\tvar->xoffset = round_up(var->xoffset, 2);\n\t}\n\tpar->hw.falcon.line_offset = bpp *\n\t\t(info->var.xres_virtual - info->var.xres) / 16;\n\tif (par->hw.falcon.xoffset)\n\t\tpar->hw.falcon.line_offset -= bpp;\n\txoffset = var->xoffset - par->hw.falcon.xoffset;\n\n\tpar->screen_base = screen_base +\n\t        (var->yoffset * info->var.xres_virtual + xoffset) * bpp / 8;\n\tif (fbhw->set_screen_base)\n\t\tfbhw->set_screen_base(par->screen_base);\n\telse\n\t\treturn -EINVAL;\t\t \n\tf_pan_display = 1;\n\treturn 0;\n}\n\nstatic int falcon_setcolreg(unsigned int regno, unsigned int red,\n\t\t\t    unsigned int green, unsigned int blue,\n\t\t\t    unsigned int transp, struct fb_info *info)\n{\n\tif (regno > 255)\n\t\treturn 1;\n\tf030_col[regno] = (((red & 0xfc00) << 16) |\n\t\t\t   ((green & 0xfc00) << 8) |\n\t\t\t   ((blue & 0xfc00) >> 8));\n\tif (regno < 16) {\n\t\tshifter_tt.color_reg[regno] =\n\t\t\t((((red & 0xe000) >> 13)   | ((red & 0x1000) >> 12)) << 8)   |\n\t\t\t((((green & 0xe000) >> 13) | ((green & 0x1000) >> 12)) << 4) |\n\t\t\t   ((blue & 0xe000) >> 13) | ((blue & 0x1000) >> 12);\n\t\t((u32 *)info->pseudo_palette)[regno] = ((red & 0xf800) |\n\t\t\t\t\t\t       ((green & 0xfc00) >> 5) |\n\t\t\t\t\t\t       ((blue & 0xf800) >> 11));\n\t}\n\treturn 0;\n}\n\nstatic int falcon_blank(int blank_mode)\n{\n\t \n\tint vdb, vss, hbe, hss;\n\n\tif (mon_type == F_MON_SM)\t \n\t\treturn 1;\n\n\tvdb = current_par.VDB;\n\tvss = current_par.VSS;\n\thbe = current_par.HBE;\n\thss = current_par.HSS;\n\n\tif (blank_mode >= 1) {\n\t\t \n\t\tvdb = current_par.VFT + 1;\n\t\t \n\t\thbe = current_par.HHT + 2;\n\t}\n\t \n\tif (mon_type == F_MON_VGA) {\n\t\tif (blank_mode == 2 || blank_mode == 4)\n\t\t\tvss = current_par.VFT + 1;\n\t\tif (blank_mode == 3 || blank_mode == 4)\n\t\t\thss = current_par.HHT + 2;\n\t}\n\n\tvidel.vdb = vdb;\n\tvidel.vss = vss;\n\tvidel.hbe = hbe;\n\tvidel.hss = hss;\n\n\treturn 0;\n}\n\nstatic int falcon_detect(void)\n{\n\tstruct atafb_par par;\n\tunsigned char fhw;\n\n\t \n\tfhw = *(unsigned char *)0xffff8006;\n\tmon_type = fhw >> 6 & 0x3;\n\t \n\tf030_bus_width = fhw << 6 & 0x80;\n\tswitch (mon_type) {\n\tcase F_MON_SM:\n\t\tfb_info.monspecs.vfmin = 70;\n\t\tfb_info.monspecs.vfmax = 72;\n\t\tfb_info.monspecs.hfmin = 35713;\n\t\tfb_info.monspecs.hfmax = 35715;\n\t\tbreak;\n\tcase F_MON_SC:\n\tcase F_MON_TV:\n\t\t \n\t\tfb_info.monspecs.vfmin = 49;\t \n\t\tfb_info.monspecs.vfmax = 60;\n\t\tfb_info.monspecs.hfmin = 15620;\n\t\tfb_info.monspecs.hfmax = 15755;\n\t\tbreak;\n\t}\n\t \n\tf25.hsync = h_syncs[mon_type] / f25.t;\n\tf32.hsync = h_syncs[mon_type] / f32.t;\n\tif (fext.t)\n\t\tfext.hsync = h_syncs[mon_type] / fext.t;\n\n\tfalcon_get_par(&par);\n\tfalcon_encode_var(&atafb_predefined[0], &par);\n\n\t \n\treturn 1;\n}\n\n#endif  \n\n \n\n#ifdef ATAFB_STE\n\nstatic int stste_encode_fix(struct fb_fix_screeninfo *fix,\n\t\t\t    struct atafb_par *par)\n{\n\tint mode;\n\n\tstrcpy(fix->id, \"Atari Builtin\");\n\tfix->smem_start = phys_screen_base;\n\tfix->smem_len = screen_len;\n\tfix->type = FB_TYPE_INTERLEAVED_PLANES;\n\tfix->type_aux = 2;\n\tfix->visual = FB_VISUAL_PSEUDOCOLOR;\n\tmode = par->hw.st.mode & 3;\n\tif (mode == ST_HIGH) {\n\t\tfix->type = FB_TYPE_PACKED_PIXELS;\n\t\tfix->type_aux = 0;\n\t\tfix->visual = FB_VISUAL_MONO10;\n\t}\n\tif (ATARIHW_PRESENT(EXTD_SHIFTER)) {\n\t\tfix->xpanstep = 16;\n\t\tfix->ypanstep = 1;\n\t} else {\n\t\tfix->xpanstep = 0;\n\t\tfix->ypanstep = 0;\n\t}\n\tfix->ywrapstep = 0;\n\tfix->line_length = par->next_line;\n\tfix->accel = FB_ACCEL_ATARIBLITT;\n\treturn 0;\n}\n\nstatic int stste_decode_var(struct fb_var_screeninfo *var,\n\t\t\t    struct atafb_par *par)\n{\n\tint xres = var->xres;\n\tint yres = var->yres;\n\tint bpp = var->bits_per_pixel;\n\tint linelen;\n\tint yres_virtual = var->yres_virtual;\n\n\tif (mono_moni) {\n\t\tif (bpp > 1 || xres > sttt_xres || yres > st_yres)\n\t\t\treturn -EINVAL;\n\t\tpar->hw.st.mode = ST_HIGH;\n\t\txres = sttt_xres;\n\t\tyres = st_yres;\n\t\tbpp = 1;\n\t} else {\n\t\tif (bpp > 4 || xres > sttt_xres || yres > st_yres)\n\t\t\treturn -EINVAL;\n\t\tif (bpp > 2) {\n\t\t\tif (xres > sttt_xres / 2 || yres > st_yres / 2)\n\t\t\t\treturn -EINVAL;\n\t\t\tpar->hw.st.mode = ST_LOW;\n\t\t\txres = sttt_xres / 2;\n\t\t\tyres = st_yres / 2;\n\t\t\tbpp = 4;\n\t\t} else if (bpp > 1) {\n\t\t\tif (xres > sttt_xres || yres > st_yres / 2)\n\t\t\t\treturn -EINVAL;\n\t\t\tpar->hw.st.mode = ST_MID;\n\t\t\txres = sttt_xres;\n\t\t\tyres = st_yres / 2;\n\t\t\tbpp = 2;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\tif (yres_virtual <= 0)\n\t\tyres_virtual = 0;\n\telse if (yres_virtual < yres)\n\t\tyres_virtual = yres;\n\tif (var->sync & FB_SYNC_EXT)\n\t\tpar->hw.st.sync = (par->hw.st.sync & ~1) | 1;\n\telse\n\t\tpar->hw.st.sync = (par->hw.st.sync & ~1);\n\tlinelen = xres * bpp / 8;\n\tif (yres_virtual * linelen > screen_len && screen_len)\n\t\treturn -EINVAL;\n\tif (yres * linelen > screen_len && screen_len)\n\t\treturn -EINVAL;\n\tif (var->yoffset + yres > yres_virtual && yres_virtual)\n\t\treturn -EINVAL;\n\tpar->yres_virtual = yres_virtual;\n\tpar->screen_base = screen_base + var->yoffset * linelen;\n\tpar->next_line = linelen;\n\treturn 0;\n}\n\nstatic int stste_encode_var(struct fb_var_screeninfo *var,\n\t\t\t    struct atafb_par *par)\n{\n\tint linelen;\n\tmemset(var, 0, sizeof(struct fb_var_screeninfo));\n\tvar->red.offset = 0;\n\tvar->red.length = ATARIHW_PRESENT(EXTD_SHIFTER) ? 4 : 3;\n\tvar->red.msb_right = 0;\n\tvar->grayscale = 0;\n\n\tvar->pixclock = 31041;\n\tvar->left_margin = 120;\t\t \n\tvar->right_margin = 100;\n\tvar->upper_margin = 8;\n\tvar->lower_margin = 16;\n\tvar->hsync_len = 140;\n\tvar->vsync_len = 30;\n\n\tvar->height = -1;\n\tvar->width = -1;\n\n\tif (!(par->hw.st.sync & 1))\n\t\tvar->sync = 0;\n\telse\n\t\tvar->sync = FB_SYNC_EXT;\n\n\tswitch (par->hw.st.mode & 3) {\n\tcase ST_LOW:\n\t\tvar->xres = sttt_xres / 2;\n\t\tvar->yres = st_yres / 2;\n\t\tvar->bits_per_pixel = 4;\n\t\tbreak;\n\tcase ST_MID:\n\t\tvar->xres = sttt_xres;\n\t\tvar->yres = st_yres / 2;\n\t\tvar->bits_per_pixel = 2;\n\t\tbreak;\n\tcase ST_HIGH:\n\t\tvar->xres = sttt_xres;\n\t\tvar->yres = st_yres;\n\t\tvar->bits_per_pixel = 1;\n\t\tbreak;\n\t}\n\tvar->blue = var->green = var->red;\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\tvar->transp.msb_right = 0;\n\tvar->xres_virtual = sttt_xres_virtual;\n\tlinelen = var->xres_virtual * var->bits_per_pixel / 8;\n\tovsc_addlen = linelen * (sttt_yres_virtual - st_yres);\n\n\tif (!use_hwscroll)\n\t\tvar->yres_virtual = var->yres;\n\telse if (screen_len) {\n\t\tif (par->yres_virtual)\n\t\t\tvar->yres_virtual = par->yres_virtual;\n\t\telse\n\t\t\t \n\t\t\tvar->yres_virtual = screen_len / linelen;\n\t} else {\n\t\tif (hwscroll < 0)\n\t\t\tvar->yres_virtual = 2 * var->yres;\n\t\telse\n\t\t\tvar->yres_virtual = var->yres + hwscroll * 16;\n\t}\n\tvar->xoffset = 0;\n\tif (screen_base)\n\t\tvar->yoffset = (par->screen_base - screen_base) / linelen;\n\telse\n\t\tvar->yoffset = 0;\n\tvar->nonstd = 0;\n\tvar->activate = 0;\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\treturn 0;\n}\n\nstatic void stste_get_par(struct atafb_par *par)\n{\n\tunsigned long addr;\n\tpar->hw.st.mode = shifter_tt.st_shiftmode;\n\tpar->hw.st.sync = shifter_st.syncmode;\n\taddr = ((shifter_st.bas_hi & 0xff) << 16) |\n\t       ((shifter_st.bas_md & 0xff) << 8);\n\tif (ATARIHW_PRESENT(EXTD_SHIFTER))\n\t\taddr |= (shifter_st.bas_lo & 0xff);\n\tpar->screen_base = atari_stram_to_virt(addr);\n}\n\nstatic void stste_set_par(struct atafb_par *par)\n{\n\tshifter_tt.st_shiftmode = par->hw.st.mode;\n\tshifter_st.syncmode = par->hw.st.sync;\n\t \n\tif (current_par.screen_base != par->screen_base)\n\t\tfbhw->set_screen_base(par->screen_base);\n}\n\nstatic int stste_setcolreg(unsigned int regno, unsigned int red,\n\t\t\t   unsigned int green, unsigned int blue,\n\t\t\t   unsigned int transp, struct fb_info *info)\n{\n\tif (regno > 15)\n\t\treturn 1;\n\tred >>= 12;\n\tblue >>= 12;\n\tgreen >>= 12;\n\tif (ATARIHW_PRESENT(EXTD_SHIFTER))\n\t\tshifter_tt.color_reg[regno] =\n\t\t\t((((red & 0xe)   >> 1) | ((red & 1)   << 3)) << 8) |\n\t\t\t((((green & 0xe) >> 1) | ((green & 1) << 3)) << 4) |\n\t\t\t  ((blue & 0xe)  >> 1) | ((blue & 1)  << 3);\n\telse\n\t\tshifter_tt.color_reg[regno] =\n\t\t\t((red & 0xe) << 7) |\n\t\t\t((green & 0xe) << 3) |\n\t\t\t((blue & 0xe) >> 1);\n\treturn 0;\n}\n\nstatic int stste_detect(void)\n{\n\tstruct atafb_par par;\n\n\t \n\tif (ATARIHW_PRESENT(PCM_8BIT)) {\n\t\ttt_dmasnd.ctrl = DMASND_CTRL_OFF;\n\t\tudelay(20);\t\t \n\t}\n\tmono_moni = (st_mfp.par_dt_reg & 0x80) == 0;\n\n\tstste_get_par(&par);\n\tstste_encode_var(&atafb_predefined[0], &par);\n\n\tif (!ATARIHW_PRESENT(EXTD_SHIFTER))\n\t\tuse_hwscroll = 0;\n\treturn 1;\n}\n\nstatic void stste_set_screen_base(void *s_base)\n{\n\tunsigned long addr;\n\taddr = atari_stram_to_phys(s_base);\n\t \n\tshifter_st.bas_hi = (unsigned char)((addr & 0xff0000) >> 16);\n\tshifter_st.bas_md = (unsigned char)((addr & 0x00ff00) >> 8);\n\tif (ATARIHW_PRESENT(EXTD_SHIFTER))\n\t\tshifter_st.bas_lo = (unsigned char)(addr & 0x0000ff);\n}\n\n#endif  \n\n \n\n#define LINE_DELAY  (mono_moni ? 30 : 70)\n#define SYNC_DELAY  (mono_moni ? 1500 : 2000)\n\n \nstatic void st_ovsc_switch(void)\n{\n\tunsigned long flags;\n\tregister unsigned char old, new;\n\n\tif (!(atari_switches & ATARI_SWITCH_OVSC_MASK))\n\t\treturn;\n\tlocal_irq_save(flags);\n\n\tst_mfp.tim_ct_b = 0x10;\n\tst_mfp.active_edge |= 8;\n\tst_mfp.tim_ct_b = 0;\n\tst_mfp.tim_dt_b = 0xf0;\n\tst_mfp.tim_ct_b = 8;\n\twhile (st_mfp.tim_dt_b > 1)\t \n\t\t;\n\tnew = st_mfp.tim_dt_b;\n\tdo {\n\t\tudelay(LINE_DELAY);\n\t\told = new;\n\t\tnew = st_mfp.tim_dt_b;\n\t} while (old != new);\n\tst_mfp.tim_ct_b = 0x10;\n\tudelay(SYNC_DELAY);\n\n\tif (atari_switches & ATARI_SWITCH_OVSC_IKBD)\n\t\tacia.key_ctrl = ACIA_DIV64 | ACIA_D8N1S | ACIA_RHTID | ACIA_RIE;\n\tif (atari_switches & ATARI_SWITCH_OVSC_MIDI)\n\t\tacia.mid_ctrl = ACIA_DIV16 | ACIA_D8N1S | ACIA_RHTID;\n\tif (atari_switches & (ATARI_SWITCH_OVSC_SND6|ATARI_SWITCH_OVSC_SND7)) {\n\t\tsound_ym.rd_data_reg_sel = 14;\n\t\tsound_ym.wd_data = sound_ym.rd_data_reg_sel |\n\t\t\t\t   ((atari_switches & ATARI_SWITCH_OVSC_SND6) ? 0x40:0) |\n\t\t\t\t   ((atari_switches & ATARI_SWITCH_OVSC_SND7) ? 0x80:0);\n\t}\n\tlocal_irq_restore(flags);\n}\n\n \n\n#ifdef ATAFB_EXT\n\nstatic int ext_encode_fix(struct fb_fix_screeninfo *fix, struct atafb_par *par)\n{\n\tstrcpy(fix->id, \"Unknown Extern\");\n\tfix->smem_start = external_addr;\n\tfix->smem_len = PAGE_ALIGN(external_len);\n\tif (external_depth == 1) {\n\t\tfix->type = FB_TYPE_PACKED_PIXELS;\n\t\t \n\t\tfix->visual =\n\t\t\t(external_pmode == FB_TYPE_INTERLEAVED_PLANES ||\n\t\t\t external_pmode == FB_TYPE_PACKED_PIXELS) ?\n\t\t\t\tFB_VISUAL_MONO10 : FB_VISUAL_MONO01;\n\t} else {\n\t\t \n\t\tint visual = external_vgaiobase ?\n\t\t\t\t\t FB_VISUAL_PSEUDOCOLOR :\n\t\t\t\t\t FB_VISUAL_STATIC_PSEUDOCOLOR;\n\t\tswitch (external_pmode) {\n\t\tcase -1:\t\t \n\t\t\tfix->type = FB_TYPE_PACKED_PIXELS;\n\t\t\tfix->visual = FB_VISUAL_TRUECOLOR;\n\t\t\tbreak;\n\t\tcase FB_TYPE_PACKED_PIXELS:\n\t\t\tfix->type = FB_TYPE_PACKED_PIXELS;\n\t\t\tfix->visual = visual;\n\t\t\tbreak;\n\t\tcase FB_TYPE_PLANES:\n\t\t\tfix->type = FB_TYPE_PLANES;\n\t\t\tfix->visual = visual;\n\t\t\tbreak;\n\t\tcase FB_TYPE_INTERLEAVED_PLANES:\n\t\t\tfix->type = FB_TYPE_INTERLEAVED_PLANES;\n\t\t\tfix->type_aux = 2;\n\t\t\tfix->visual = visual;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfix->xpanstep = 0;\n\tfix->ypanstep = 0;\n\tfix->ywrapstep = 0;\n\tfix->line_length = par->next_line;\n\treturn 0;\n}\n\nstatic int ext_decode_var(struct fb_var_screeninfo *var, struct atafb_par *par)\n{\n\tstruct fb_var_screeninfo *myvar = &atafb_predefined[0];\n\n\tif (var->bits_per_pixel > myvar->bits_per_pixel ||\n\t    var->xres > myvar->xres ||\n\t    var->xres_virtual > myvar->xres_virtual ||\n\t    var->yres > myvar->yres ||\n\t    var->xoffset > 0 ||\n\t    var->yoffset > 0)\n\t\treturn -EINVAL;\n\n\tpar->next_line = external_xres_virtual * external_depth / 8;\n\treturn 0;\n}\n\nstatic int ext_encode_var(struct fb_var_screeninfo *var, struct atafb_par *par)\n{\n\tmemset(var, 0, sizeof(struct fb_var_screeninfo));\n\tvar->red.offset = 0;\n\tvar->red.length = (external_pmode == -1) ? external_depth / 3 :\n\t\t\t(external_vgaiobase ? external_bitspercol : 0);\n\tvar->red.msb_right = 0;\n\tvar->grayscale = 0;\n\n\tvar->pixclock = 31041;\n\tvar->left_margin = 120;\t\t \n\tvar->right_margin = 100;\n\tvar->upper_margin = 8;\n\tvar->lower_margin = 16;\n\tvar->hsync_len = 140;\n\tvar->vsync_len = 30;\n\n\tvar->height = -1;\n\tvar->width = -1;\n\n\tvar->sync = 0;\n\n\tvar->xres = external_xres;\n\tvar->yres = external_yres;\n\tvar->xres_virtual = external_xres_virtual;\n\tvar->bits_per_pixel = external_depth;\n\n\tvar->blue = var->green = var->red;\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\tvar->transp.msb_right = 0;\n\tvar->yres_virtual = var->yres;\n\tvar->xoffset = 0;\n\tvar->yoffset = 0;\n\tvar->nonstd = 0;\n\tvar->activate = 0;\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\treturn 0;\n}\n\nstatic void ext_get_par(struct atafb_par *par)\n{\n\tpar->screen_base = external_screen_base;\n}\n\nstatic void ext_set_par(struct atafb_par *par)\n{\n}\n\n#define OUTB(port,val) \\\n\t*((unsigned volatile char *) ((port)+external_vgaiobase)) = (val)\n#define INB(port) \\\n\t(*((unsigned volatile char *) ((port)+external_vgaiobase)))\n#define DACDelay\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tunsigned char tmp = INB(0x3da);\t\\\n\t\ttmp = INB(0x3da);\t\t\t\\\n\t} while (0)\n\nstatic int ext_setcolreg(unsigned int regno, unsigned int red,\n\t\t\t unsigned int green, unsigned int blue,\n\t\t\t unsigned int transp, struct fb_info *info)\n{\n\tunsigned char colmask = (1 << external_bitspercol) - 1;\n\n\tif (!external_vgaiobase)\n\t\treturn 1;\n\n\tif (regno > 255)\n\t\treturn 1;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\tswitch (external_card_type) {\n\tcase IS_VGA:\n\t\tOUTB(0x3c8, regno);\n\t\tDACDelay;\n\t\tOUTB(0x3c9, red & colmask);\n\t\tDACDelay;\n\t\tOUTB(0x3c9, green & colmask);\n\t\tDACDelay;\n\t\tOUTB(0x3c9, blue & colmask);\n\t\tDACDelay;\n\t\treturn 0;\n\n\tcase IS_MV300:\n\t\tOUTB((MV300_reg[regno] << 2) + 1, red);\n\t\tOUTB((MV300_reg[regno] << 2) + 1, green);\n\t\tOUTB((MV300_reg[regno] << 2) + 1, blue);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int ext_detect(void)\n{\n\tstruct fb_var_screeninfo *myvar = &atafb_predefined[0];\n\tstruct atafb_par dummy_par;\n\n\tmyvar->xres = external_xres;\n\tmyvar->xres_virtual = external_xres_virtual;\n\tmyvar->yres = external_yres;\n\tmyvar->bits_per_pixel = external_depth;\n\text_encode_var(myvar, &dummy_par);\n\treturn 1;\n}\n\n#endif  \n\n \n\nstatic void set_screen_base(void *s_base)\n{\n\tunsigned long addr;\n\n\taddr = atari_stram_to_phys(s_base);\n\t \n\tshifter_st.bas_hi = (unsigned char)((addr & 0xff0000) >> 16);\n\tshifter_st.bas_md = (unsigned char)((addr & 0x00ff00) >> 8);\n\tshifter_st.bas_lo = (unsigned char)(addr & 0x0000ff);\n}\n\nstatic int pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct atafb_par *par = info->par;\n\n\tif (!fbhw->set_screen_base ||\n\t    (!ATARIHW_PRESENT(EXTD_SHIFTER) && var->xoffset))\n\t\treturn -EINVAL;\n\tvar->xoffset = round_up(var->xoffset, 16);\n\tpar->screen_base = screen_base +\n\t        (var->yoffset * info->var.xres_virtual + var->xoffset)\n\t        * info->var.bits_per_pixel / 8;\n\tfbhw->set_screen_base(par->screen_base);\n\treturn 0;\n}\n\n \n\n#ifdef ATAFB_TT\nstatic struct fb_hwswitch tt_switch = {\n\t.detect\t\t= tt_detect,\n\t.encode_fix\t= tt_encode_fix,\n\t.decode_var\t= tt_decode_var,\n\t.encode_var\t= tt_encode_var,\n\t.get_par\t= tt_get_par,\n\t.set_par\t= tt_set_par,\n\t.set_screen_base = set_screen_base,\n\t.pan_display\t= pan_display,\n};\n#endif\n\n#ifdef ATAFB_FALCON\nstatic struct fb_hwswitch falcon_switch = {\n\t.detect\t\t= falcon_detect,\n\t.encode_fix\t= falcon_encode_fix,\n\t.decode_var\t= falcon_decode_var,\n\t.encode_var\t= falcon_encode_var,\n\t.get_par\t= falcon_get_par,\n\t.set_par\t= falcon_set_par,\n\t.set_screen_base = set_screen_base,\n\t.blank\t\t= falcon_blank,\n\t.pan_display\t= falcon_pan_display,\n};\n#endif\n\n#ifdef ATAFB_STE\nstatic struct fb_hwswitch st_switch = {\n\t.detect\t\t= stste_detect,\n\t.encode_fix\t= stste_encode_fix,\n\t.decode_var\t= stste_decode_var,\n\t.encode_var\t= stste_encode_var,\n\t.get_par\t= stste_get_par,\n\t.set_par\t= stste_set_par,\n\t.set_screen_base = stste_set_screen_base,\n\t.pan_display\t= pan_display\n};\n#endif\n\n#ifdef ATAFB_EXT\nstatic struct fb_hwswitch ext_switch = {\n\t.detect\t\t= ext_detect,\n\t.encode_fix\t= ext_encode_fix,\n\t.decode_var\t= ext_decode_var,\n\t.encode_var\t= ext_encode_var,\n\t.get_par\t= ext_get_par,\n\t.set_par\t= ext_set_par,\n};\n#endif\n\nstatic void ata_get_par(struct atafb_par *par)\n{\n\tif (current_par_valid)\n\t\t*par = current_par;\n\telse\n\t\tfbhw->get_par(par);\n}\n\nstatic void ata_set_par(struct atafb_par *par)\n{\n\tfbhw->set_par(par);\n\tcurrent_par = *par;\n\tcurrent_par_valid = 1;\n}\n\n\n \n \n \n\n \n\nstatic int do_fb_set_var(struct fb_var_screeninfo *var, int isactive)\n{\n\tint err, activate;\n\tstruct atafb_par par;\n\n\terr = fbhw->decode_var(var, &par);\n\tif (err)\n\t\treturn err;\n\tactivate = var->activate;\n\tif (((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW) && isactive)\n\t\tata_set_par(&par);\n\tfbhw->encode_var(var, &par);\n\tvar->activate = activate;\n\treturn 0;\n}\n\n \nstatic int atafb_get_fix(struct fb_fix_screeninfo *fix, struct fb_info *info)\n{\n\tstruct atafb_par par;\n\tint err;\n\t\n\terr = fbhw->decode_var(&info->var, &par);\n\tif (err)\n\t\treturn err;\n\tmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\n\terr = fbhw->encode_fix(fix, &par);\n\treturn err;\n}\n\nstatic int atafb_get_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct atafb_par par;\n\n\tata_get_par(&par);\n\tfbhw->encode_var(var, &par);\n\n\treturn 0;\n}\n\n\n\n\nstatic void atafb_set_disp(struct fb_info *info)\n{\n\tatafb_get_var(&info->var, info);\n\tatafb_get_fix(&info->fix, info);\n\n\t \n\tinfo->screen_base = (external_addr ? external_screen_base :\n\t\t\t\tatari_stram_to_virt(info->fix.smem_start));\n}\n\nstatic int\natafb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tif (!fbhw->pan_display)\n\t\treturn -EINVAL;\n\n\treturn fbhw->pan_display(var, info);\n}\n\n \n\nstatic void atafb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct atafb_par *par = info->par;\n\tint x2, y2;\n\tu32 width, height;\n\n\tif (!rect->width || !rect->height)\n\t\treturn;\n\n#ifdef ATAFB_FALCON\n\tif (info->var.bits_per_pixel == 16) {\n\t\tcfb_fillrect(info, rect);\n\t\treturn;\n\t}\n#endif\n\n\t \n\tx2 = rect->dx + rect->width;\n\ty2 = rect->dy + rect->height;\n\tx2 = x2 < info->var.xres_virtual ? x2 : info->var.xres_virtual;\n\ty2 = y2 < info->var.yres_virtual ? y2 : info->var.yres_virtual;\n\twidth = x2 - rect->dx;\n\theight = y2 - rect->dy;\n\n\tif (info->var.bits_per_pixel == 1)\n\t\tatafb_mfb_fillrect(info, par->next_line, rect->color,\n\t\t\t\t   rect->dy, rect->dx, height, width);\n\telse if (info->var.bits_per_pixel == 2)\n\t\tatafb_iplan2p2_fillrect(info, par->next_line, rect->color,\n\t\t\t\t\trect->dy, rect->dx, height, width);\n\telse if (info->var.bits_per_pixel == 4)\n\t\tatafb_iplan2p4_fillrect(info, par->next_line, rect->color,\n\t\t\t\t\trect->dy, rect->dx, height, width);\n\telse\n\t\tatafb_iplan2p8_fillrect(info, par->next_line, rect->color,\n\t\t\t\t\trect->dy, rect->dx, height, width);\n\n\treturn;\n}\n\nstatic void atafb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tstruct atafb_par *par = info->par;\n\tint x2, y2;\n\tu32 dx, dy, sx, sy, width, height;\n\tint rev_copy = 0;\n\n#ifdef ATAFB_FALCON\n\tif (info->var.bits_per_pixel == 16) {\n\t\tcfb_copyarea(info, area);\n\t\treturn;\n\t}\n#endif\n\n\t \n\tx2 = area->dx + area->width;\n\ty2 = area->dy + area->height;\n\tdx = area->dx > 0 ? area->dx : 0;\n\tdy = area->dy > 0 ? area->dy : 0;\n\tx2 = x2 < info->var.xres_virtual ? x2 : info->var.xres_virtual;\n\ty2 = y2 < info->var.yres_virtual ? y2 : info->var.yres_virtual;\n\twidth = x2 - dx;\n\theight = y2 - dy;\n\n\tif (area->sx + dx < area->dx || area->sy + dy < area->dy)\n\t\treturn;\n\n\t \n\tsx = area->sx + (dx - area->dx);\n\tsy = area->sy + (dy - area->dy);\n\n\t \n\tif (sx + width > info->var.xres_virtual ||\n\t\t\tsy + height > info->var.yres_virtual)\n\t\treturn;\n\n\tif (dy > sy || (dy == sy && dx > sx)) {\n\t\tdy += height;\n\t\tsy += height;\n\t\trev_copy = 1;\n\t}\n\n\tif (info->var.bits_per_pixel == 1)\n\t\tatafb_mfb_copyarea(info, par->next_line, sy, sx, dy, dx, height, width);\n\telse if (info->var.bits_per_pixel == 2)\n\t\tatafb_iplan2p2_copyarea(info, par->next_line, sy, sx, dy, dx, height, width);\n\telse if (info->var.bits_per_pixel == 4)\n\t\tatafb_iplan2p4_copyarea(info, par->next_line, sy, sx, dy, dx, height, width);\n\telse\n\t\tatafb_iplan2p8_copyarea(info, par->next_line, sy, sx, dy, dx, height, width);\n\n\treturn;\n}\n\nstatic void atafb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct atafb_par *par = info->par;\n\tint x2, y2;\n\tconst char *src;\n\tu32 dx, dy, width, height, pitch;\n\n#ifdef ATAFB_FALCON\n\tif (info->var.bits_per_pixel == 16) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n#endif\n\n\t \n\tx2 = image->dx + image->width;\n\ty2 = image->dy + image->height;\n\tdx = image->dx;\n\tdy = image->dy;\n\tx2 = x2 < info->var.xres_virtual ? x2 : info->var.xres_virtual;\n\ty2 = y2 < info->var.yres_virtual ? y2 : info->var.yres_virtual;\n\twidth = x2 - dx;\n\theight = y2 - dy;\n\n\tif (image->depth == 1) {\n\t\t\n\t\tsrc = image->data;\n\t\tpitch = (image->width + 7) / 8;\n\t\twhile (height--) {\n\n\t\t\tif (info->var.bits_per_pixel == 1)\n\t\t\t\tatafb_mfb_linefill(info, par->next_line,\n\t\t\t\t\t\t   dy, dx, width, src,\n\t\t\t\t\t\t   image->bg_color, image->fg_color);\n\t\t\telse if (info->var.bits_per_pixel == 2)\n\t\t\t\tatafb_iplan2p2_linefill(info, par->next_line,\n\t\t\t\t\t\t\tdy, dx, width, src,\n\t\t\t\t\t\t\timage->bg_color, image->fg_color);\n\t\t\telse if (info->var.bits_per_pixel == 4)\n\t\t\t\tatafb_iplan2p4_linefill(info, par->next_line,\n\t\t\t\t\t\t\tdy, dx, width, src,\n\t\t\t\t\t\t\timage->bg_color, image->fg_color);\n\t\t\telse\n\t\t\t\tatafb_iplan2p8_linefill(info, par->next_line,\n\t\t\t\t\t\t\tdy, dx, width, src,\n\t\t\t\t\t\t\timage->bg_color, image->fg_color);\n\t\t\tdy++;\n\t\t\tsrc += pitch;\n\t\t}\n\t} else {\n\t\tc2p_iplan2(info->screen_base, image->data, dx, dy, width,\n\t\t\t   height, par->next_line, image->width,\n\t\t\t   info->var.bits_per_pixel);\n\t}\n}\n\nstatic int\natafb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n#ifdef FBCMD_GET_CURRENTPAR\n\tcase FBCMD_GET_CURRENTPAR:\n\t\tif (copy_to_user((void *)arg, &current_par,\n\t\t\t\t sizeof(struct atafb_par)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n#endif\n#ifdef FBCMD_SET_CURRENTPAR\n\tcase FBCMD_SET_CURRENTPAR:\n\t\tif (copy_from_user(&current_par, (void *)arg,\n\t\t\t\t   sizeof(struct atafb_par)))\n\t\t\treturn -EFAULT;\n\t\tata_set_par(&current_par);\n\t\treturn 0;\n#endif\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int atafb_blank(int blank, struct fb_info *info)\n{\n\tunsigned short black[16];\n\tstruct fb_cmap cmap;\n\tif (fbhw->blank && !fbhw->blank(blank))\n\t\treturn 1;\n\tif (blank) {\n\t\tmemset(black, 0, 16 * sizeof(unsigned short));\n\t\tcmap.red = black;\n\t\tcmap.green = black;\n\t\tcmap.blue = black;\n\t\tcmap.transp = NULL;\n\t\tcmap.start = 0;\n\t\tcmap.len = 16;\n\t\tfb_set_cmap(&cmap, info);\n\t}\n#if 0\n\telse\n\t\tdo_install_cmap(info);\n#endif\n\treturn 0;\n}\n\n\t \n\n\t  \nstatic int atafb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tint err;\n\tstruct atafb_par par;\n\n\t \n\t\n\terr = fbhw->decode_var(var, &par);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfbhw->encode_var(var, &par);\n\treturn 0;\n}\n\n\t \nstatic int atafb_set_par(struct fb_info *info)\n{\n\tstruct atafb_par *par = info->par;\n\n\t \n\tfbhw->decode_var(&info->var, par);\n\tmutex_lock(&info->mm_lock);\n\tfbhw->encode_fix(&info->fix, par);\n\tmutex_unlock(&info->mm_lock);\n\n\t \n\tata_set_par(par);\n\n\treturn 0;\n}\n\n\nstatic struct fb_ops atafb_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.fb_check_var\t= atafb_check_var,\n\t.fb_set_par\t= atafb_set_par,\n\t.fb_blank =\tatafb_blank,\n\t.fb_pan_display\t= atafb_pan_display,\n\t.fb_fillrect\t= atafb_fillrect,\n\t.fb_copyarea\t= atafb_copyarea,\n\t.fb_imageblit\t= atafb_imageblit,\n\t.fb_ioctl =\tatafb_ioctl,\n};\n\nstatic void check_default_par(int detected_mode)\n{\n\tchar default_name[10];\n\tint i;\n\tstruct fb_var_screeninfo var;\n\tunsigned long min_mem;\n\n\t \n\tif (default_par) {\n\t\tvar = atafb_predefined[default_par - 1];\n\t\tvar.activate = FB_ACTIVATE_TEST;\n\t\tif (do_fb_set_var(&var, 1))\n\t\t\tdefault_par = 0;\t \n\t}\n\t \n\tif (!default_par) {\n\t\tvar = atafb_predefined[detected_mode - 1];  \n\t\tvar.activate = FB_ACTIVATE_TEST;\n\t\tif (!do_fb_set_var(&var, 1))\n\t\t\tdefault_par = detected_mode;\n\t}\n\t \n\tif (!default_par) {\n\t\t \n\t\tfor (i = 1; i < 10; i++) {\n\t\t\tsprintf(default_name,\"default%d\", i);\n\t\t\tdefault_par = get_video_mode(default_name);\n\t\t\tif (!default_par)\n\t\t\t\tpanic(\"can't set default video mode\");\n\t\t\tvar = atafb_predefined[default_par - 1];\n\t\t\tvar.activate = FB_ACTIVATE_TEST;\n\t\t\tif (!do_fb_set_var(&var,1))\n\t\t\t\tbreak;\t \n\t\t}\n\t}\n\tmin_mem = var.xres_virtual * var.yres_virtual * var.bits_per_pixel / 8;\n\tif (default_mem_req < min_mem)\n\t\tdefault_mem_req = min_mem;\n}\n\n#ifdef ATAFB_EXT\nstatic void __init atafb_setup_ext(char *spec)\n{\n\tint xres, xres_virtual, yres, depth, planes;\n\tunsigned long addr, len;\n\tchar *p;\n\n\t \n\tp = strsep(&spec, \";\");\n\tif (!p || !*p)\n\t\treturn;\n\txres_virtual = xres = simple_strtoul(p, NULL, 10);\n\tif (xres <= 0)\n\t\treturn;\n\n\tp = strsep(&spec, \";\");\n\tif (!p || !*p)\n\t\treturn;\n\tyres = simple_strtoul(p, NULL, 10);\n\tif (yres <= 0)\n\t\treturn;\n\n\tp = strsep(&spec, \";\");\n\tif (!p || !*p)\n\t\treturn;\n\tdepth = simple_strtoul(p, NULL, 10);\n\tif (depth != 1 && depth != 2 && depth != 4 && depth != 8 &&\n\t    depth != 16 && depth != 24)\n\t\treturn;\n\n\tp = strsep(&spec, \";\");\n\tif (!p || !*p)\n\t\treturn;\n\tif (*p == 'i')\n\t\tplanes = FB_TYPE_INTERLEAVED_PLANES;\n\telse if (*p == 'p')\n\t\tplanes = FB_TYPE_PACKED_PIXELS;\n\telse if (*p == 'n')\n\t\tplanes = FB_TYPE_PLANES;\n\telse if (*p == 't')\n\t\tplanes = -1;\t\t \n\telse\n\t\treturn;\n\n\tp = strsep(&spec, \";\");\n\tif (!p || !*p)\n\t\treturn;\n\taddr = simple_strtoul(p, NULL, 0);\n\n\tp = strsep(&spec, \";\");\n\tif (!p || !*p)\n\t\tlen = xres * yres * depth / 8;\n\telse\n\t\tlen = simple_strtoul(p, NULL, 0);\n\n\tp = strsep(&spec, \";\");\n\tif (p && *p)\n\t\texternal_vgaiobase = simple_strtoul(p, NULL, 0);\n\n\tp = strsep(&spec, \";\");\n\tif (p && *p) {\n\t\texternal_bitspercol = simple_strtoul(p, NULL, 0);\n\t\tif (external_bitspercol > 8)\n\t\t\texternal_bitspercol = 8;\n\t\telse if (external_bitspercol < 1)\n\t\t\texternal_bitspercol = 1;\n\t}\n\n\tp = strsep(&spec, \";\");\n\tif (p && *p) {\n\t\tif (!strcmp(p, \"vga\"))\n\t\t\texternal_card_type = IS_VGA;\n\t\tif (!strcmp(p, \"mv300\"))\n\t\t\texternal_card_type = IS_MV300;\n\t}\n\n\tp = strsep(&spec, \";\");\n\tif (p && *p) {\n\t\txres_virtual = simple_strtoul(p, NULL, 10);\n\t\tif (xres_virtual < xres)\n\t\t\txres_virtual = xres;\n\t\tif (xres_virtual * yres * depth / 8 > len)\n\t\t\tlen = xres_virtual * yres * depth / 8;\n\t}\n\n\texternal_xres = xres;\n\texternal_xres_virtual = xres_virtual;\n\texternal_yres = yres;\n\texternal_depth = depth;\n\texternal_pmode = planes;\n\texternal_addr = addr;\n\texternal_len = len;\n\n\tif (external_card_type == IS_MV300) {\n\t\tswitch (external_depth) {\n\t\tcase 1:\n\t\t\tMV300_reg = MV300_reg_1bit;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tMV300_reg = MV300_reg_4bit;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tMV300_reg = MV300_reg_8bit;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n#endif  \n\nstatic void __init atafb_setup_int(char *spec)\n{\n\t \n\tint xres;\n\tchar *p;\n\n\tif (!(p = strsep(&spec, \";\")) || !*p)\n\t\treturn;\n\txres = simple_strtoul(p, NULL, 10);\n\tif (!(p = strsep(&spec, \";\")) || !*p)\n\t\treturn;\n\tsttt_xres = xres;\n\ttt_yres = st_yres = simple_strtoul(p, NULL, 10);\n\tif ((p = strsep(&spec, \";\")) && *p)\n\t\tsttt_xres_virtual = simple_strtoul(p, NULL, 10);\n\tif ((p = strsep(&spec, \";\")) && *p)\n\t\tsttt_yres_virtual = simple_strtoul(p, NULL, 0);\n\tif ((p = strsep(&spec, \";\")) && *p)\n\t\tovsc_offset = simple_strtoul(p, NULL, 0);\n\n\tif (ovsc_offset || (sttt_yres_virtual != st_yres))\n\t\tuse_hwscroll = 0;\n}\n\n#ifdef ATAFB_FALCON\nstatic void __init atafb_setup_mcap(char *spec)\n{\n\tchar *p;\n\tint vmin, vmax, hmin, hmax;\n\n\t \n\tif (!(p = strsep(&spec, \";\")) || !*p)\n\t\treturn;\n\tvmin = simple_strtoul(p, NULL, 10);\n\tif (vmin <= 0)\n\t\treturn;\n\tif (!(p = strsep(&spec, \";\")) || !*p)\n\t\treturn;\n\tvmax = simple_strtoul(p, NULL, 10);\n\tif (vmax <= 0 || vmax <= vmin)\n\t\treturn;\n\tif (!(p = strsep(&spec, \";\")) || !*p)\n\t\treturn;\n\thmin = 1000 * simple_strtoul(p, NULL, 10);\n\tif (hmin <= 0)\n\t\treturn;\n\tif (!(p = strsep(&spec, \"\")) || !*p)\n\t\treturn;\n\thmax = 1000 * simple_strtoul(p, NULL, 10);\n\tif (hmax <= 0 || hmax <= hmin)\n\t\treturn;\n\n\tfb_info.monspecs.vfmin = vmin;\n\tfb_info.monspecs.vfmax = vmax;\n\tfb_info.monspecs.hfmin = hmin;\n\tfb_info.monspecs.hfmax = hmax;\n}\n#endif  \n\nstatic void __init atafb_setup_user(char *spec)\n{\n\t \n\tchar *p;\n\tint xres, yres, depth, temp;\n\n\tp = strsep(&spec, \";\");\n\tif (!p || !*p)\n\t\treturn;\n\txres = simple_strtoul(p, NULL, 10);\n\tp = strsep(&spec, \";\");\n\tif (!p || !*p)\n\t\treturn;\n\tyres = simple_strtoul(p, NULL, 10);\n\tp = strsep(&spec, \"\");\n\tif (!p || !*p)\n\t\treturn;\n\tdepth = simple_strtoul(p, NULL, 10);\n\ttemp = get_video_mode(\"user0\");\n\tif (temp) {\n\t\tdefault_par = temp;\n\t\tatafb_predefined[default_par - 1].xres = xres;\n\t\tatafb_predefined[default_par - 1].yres = yres;\n\t\tatafb_predefined[default_par - 1].bits_per_pixel = depth;\n\t}\n}\n\nstatic int __init atafb_setup(char *options)\n{\n\tchar *this_opt;\n\tint temp;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\t\tif ((temp = get_video_mode(this_opt))) {\n\t\t\tdefault_par = temp;\n\t\t\tmode_option = this_opt;\n\t\t} else if (!strcmp(this_opt, \"inverse\"))\n\t\t\tfb_invert_cmaps();\n\t\telse if (!strncmp(this_opt, \"hwscroll_\", 9)) {\n\t\t\thwscroll = simple_strtoul(this_opt + 9, NULL, 10);\n\t\t\tif (hwscroll < 0)\n\t\t\t\thwscroll = 0;\n\t\t\tif (hwscroll > 200)\n\t\t\t\thwscroll = 200;\n\t\t}\n#ifdef ATAFB_EXT\n\t\telse if (!strcmp(this_opt, \"mv300\")) {\n\t\t\texternal_bitspercol = 8;\n\t\t\texternal_card_type = IS_MV300;\n\t\t} else if (!strncmp(this_opt, \"external:\", 9))\n\t\t\tatafb_setup_ext(this_opt + 9);\n#endif\n\t\telse if (!strncmp(this_opt, \"internal:\", 9))\n\t\t\tatafb_setup_int(this_opt + 9);\n#ifdef ATAFB_FALCON\n\t\telse if (!strncmp(this_opt, \"eclock:\", 7)) {\n\t\t\tfext.f = simple_strtoul(this_opt + 7, NULL, 10);\n\t\t\t \n\t\t\tfext.t = 1000000000 / fext.f;\n\t\t\tfext.f *= 1000;\n\t\t} else if (!strncmp(this_opt, \"monitorcap:\", 11))\n\t\t\tatafb_setup_mcap(this_opt + 11);\n#endif\n\t\telse if (!strcmp(this_opt, \"keep\"))\n\t\t\tDontCalcRes = 1;\n\t\telse if (!strncmp(this_opt, \"R\", 1))\n\t\t\tatafb_setup_user(this_opt + 1);\n\t}\n\treturn 0;\n}\n\nstatic int __init atafb_probe(struct platform_device *pdev)\n{\n\tint pad, detected_mode, error;\n\tunsigned int defmode = 0;\n\tunsigned long mem_req;\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"atafb\", &option))\n\t\treturn -ENODEV;\n\tatafb_setup(option);\n\tdev_dbg(&pdev->dev, \"%s: start\\n\", __func__);\n\n\tdo {\n#ifdef ATAFB_EXT\n\t\tif (external_addr) {\n\t\t\tdev_dbg(&pdev->dev, \"initializing external hw\\n\");\n\t\t\tfbhw = &ext_switch;\n\t\t\tatafb_ops.fb_setcolreg = &ext_setcolreg;\n\t\t\tdefmode = DEFMODE_EXT;\n\t\t\tbreak;\n\t\t}\n#endif\n#ifdef ATAFB_TT\n\t\tif (ATARIHW_PRESENT(TT_SHIFTER)) {\n\t\t\tdev_dbg(&pdev->dev, \"initializing TT hw\\n\");\n\t\t\tfbhw = &tt_switch;\n\t\t\tatafb_ops.fb_setcolreg = &tt_setcolreg;\n\t\t\tdefmode = DEFMODE_TT;\n\t\t\tbreak;\n\t\t}\n#endif\n#ifdef ATAFB_FALCON\n\t\tif (ATARIHW_PRESENT(VIDEL_SHIFTER)) {\n\t\t\tdev_dbg(&pdev->dev, \"initializing Falcon hw\\n\");\n\t\t\tfbhw = &falcon_switch;\n\t\t\tatafb_ops.fb_setcolreg = &falcon_setcolreg;\n\t\t\terror = request_irq(IRQ_AUTO_4, falcon_vbl_switcher, 0,\n\t\t\t\t\t    \"framebuffer:modeswitch\",\n\t\t\t\t\t    falcon_vbl_switcher);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tdefmode = DEFMODE_F30;\n\t\t\tbreak;\n\t\t}\n#endif\n#ifdef ATAFB_STE\n\t\tif (ATARIHW_PRESENT(STND_SHIFTER) ||\n\t\t    ATARIHW_PRESENT(EXTD_SHIFTER)) {\n\t\t\tdev_dbg(&pdev->dev, \"initializing ST/E hw\\n\");\n\t\t\tfbhw = &st_switch;\n\t\t\tatafb_ops.fb_setcolreg = &stste_setcolreg;\n\t\t\tdefmode = DEFMODE_STE;\n\t\t\tbreak;\n\t\t}\n\t\tfbhw = &st_switch;\n\t\tatafb_ops.fb_setcolreg = &stste_setcolreg;\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Cannot determine video hardware; defaulting to ST(e)\\n\");\n#else  \n\t\t \n\t\t \n\t\tpanic(\"Cannot initialize video hardware\");\n#endif\n\t} while (0);\n\n\t \n\t \n\tif (fb_info.monspecs.hfmin == 0) {\n\t\tfb_info.monspecs.hfmin = 31000;\n\t\tfb_info.monspecs.hfmax = 32000;\n\t\tfb_info.monspecs.vfmin = 58;\n\t\tfb_info.monspecs.vfmax = 62;\n\t}\n\n\tdetected_mode = fbhw->detect();\n\tcheck_default_par(detected_mode);\n#ifdef ATAFB_EXT\n\tif (!external_addr) {\n#endif  \n\t\tmem_req = default_mem_req + ovsc_offset + ovsc_addlen;\n\t\tmem_req = PAGE_ALIGN(mem_req) + PAGE_SIZE;\n\t\tscreen_base = atari_stram_alloc(mem_req, \"atafb\");\n\t\tif (!screen_base)\n\t\t\tpanic(\"Cannot allocate screen memory\");\n\t\tmemset(screen_base, 0, mem_req);\n\t\tpad = -(unsigned long)screen_base & (PAGE_SIZE - 1);\n\t\tscreen_base += pad;\n\t\tphys_screen_base = atari_stram_to_phys(screen_base + ovsc_offset);\n\t\tscreen_len = (mem_req - pad - ovsc_offset) & PAGE_MASK;\n\t\tst_ovsc_switch();\n\t\tif (CPU_IS_040_OR_060) {\n\t\t\t \n\t\t\tcache_push(atari_stram_to_phys(screen_base), screen_len);\n\t\t\tkernel_set_cachemode(screen_base, screen_len,\n\t\t\t\t\t     IOMAP_WRITETHROUGH);\n\t\t}\n\t\tdev_info(&pdev->dev, \"phys_screen_base %lx screen_len %d\\n\",\n\t\t\t phys_screen_base, screen_len);\n#ifdef ATAFB_EXT\n\t} else {\n\t\t \n\t\texternal_screen_base = ioremap_wt(external_addr, external_len);\n\t\tif (external_vgaiobase)\n\t\t\texternal_vgaiobase =\n\t\t\t  (unsigned long)ioremap(external_vgaiobase, 0x10000);\n\t\tscreen_base = external_screen_base;\n\t\tphys_screen_base = external_addr;\n\t\tscreen_len = external_len & PAGE_MASK;\n\t\tmemset (screen_base, 0, external_len);\n\t}\n#endif  \n\n\n\tfb_info.fbops = &atafb_ops;\n\t\n\tdo_fb_set_var(&atafb_predefined[default_par - 1], 1);\n\t\n\tata_get_par(&current_par);\n\tfb_info.par = &current_par;\n\t\n\t\n\tatafb_get_var(&fb_info.var, &fb_info);\n\n#ifdef ATAFB_FALCON\n\tfb_info.pseudo_palette = current_par.hw.falcon.pseudo_palette;\n#endif\n\n\tif (!fb_find_mode(&fb_info.var, &fb_info, mode_option, atafb_modedb,\n\t\t\t  NUM_TOTAL_MODES, &atafb_modedb[defmode],\n\t\t\t  fb_info.var.bits_per_pixel)) {\n\t\treturn -EINVAL;\n\t}\n\n\tfb_videomode_to_modelist(atafb_modedb, NUM_TOTAL_MODES,\n\t\t\t\t &fb_info.modelist);\n\n\tatafb_set_disp(&fb_info);\n\n\tfb_alloc_cmap(&(fb_info.cmap), 1 << fb_info.var.bits_per_pixel, 0);\n\n\n\tdev_info(&pdev->dev, \"Determined %dx%d, depth %d\\n\", fb_info.var.xres,\n\t\t fb_info.var.yres, fb_info.var.bits_per_pixel);\n\tif ((fb_info.var.xres != fb_info.var.xres_virtual) ||\n\t    (fb_info.var.yres != fb_info.var.yres_virtual))\n\t\tdev_info(&pdev->dev, \"   virtual %dx%d\\n\",\n\t\t\t fb_info.var.xres_virtual, fb_info.var.yres_virtual);\n\n\tif (register_framebuffer(&fb_info) < 0) {\n#ifdef ATAFB_EXT\n\t\tif (external_addr) {\n\t\t\tiounmap(external_screen_base);\n\t\t\texternal_addr = 0;\n\t\t}\n\t\tif (external_vgaiobase) {\n\t\t\tiounmap((void*)external_vgaiobase);\n\t\t\texternal_vgaiobase = 0;\n\t\t}\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\tfb_info(&fb_info, \"frame buffer device, using %dK of video memory\\n\",\n\t\tscreen_len >> 10);\n\n\t \n\treturn 0;\n}\n\nstatic void atafb_shutdown(struct platform_device *pdev)\n{\n\t \n\tif (fbhw->blank)\n\t\tfbhw->blank(0);\n}\n\nstatic struct platform_driver atafb_driver = {\n\t.shutdown\t= atafb_shutdown,\n\t.driver\t= {\n\t\t.name\t= \"atafb\",\n\t},\n};\n\nstatic int __init atafb_init(void)\n{\n\tstruct platform_device *pdev;\n\n\tif (!MACH_IS_ATARI)\n\t\treturn -ENODEV;\n\n\tpdev = platform_device_register_simple(\"atafb\", -1, NULL, 0);\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\treturn platform_driver_probe(&atafb_driver, atafb_probe);\n}\n\ndevice_initcall(atafb_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}