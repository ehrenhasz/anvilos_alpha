{
  "module_name": "pm3fb.c",
  "hash_id": "4485f2f3581baa4696aadea8851c454372cc2ebe412a51c3512da27aeb58604e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/pm3fb.c",
  "human_readable_source": " \n\n#include <linux/aperture.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n\n#include <video/pm3fb.h>\n\n#if !defined(CONFIG_PCI)\n#error \"Only generic PCI cards supported.\"\n#endif\n\n#undef PM3FB_MASTER_DEBUG\n#ifdef PM3FB_MASTER_DEBUG\n#define DPRINTK(a, b...)\t\\\n\tprintk(KERN_DEBUG \"pm3fb: %s: \" a, __func__ , ## b)\n#else\n#define DPRINTK(a, b...)\tno_printk(a, ##b)\n#endif\n\n#define PM3_PIXMAP_SIZE\t(2048 * 4)\n\n \nstatic int hwcursor = 1;\nstatic char *mode_option;\nstatic bool noaccel;\nstatic bool nomtrr;\n\n \nstruct pm3_par {\n\tunsigned char\t__iomem *v_regs; \n\tu32\t\tvideo;\t\t \n\tu32\t\tbase;\t\t \n\tu32\t\tpalette[16];\n\tint\t\twc_cookie;\n};\n\n \nstatic struct fb_fix_screeninfo pm3fb_fix = {\n\t.id =\t\t\"Permedia3\",\n\t.type =\t\tFB_TYPE_PACKED_PIXELS,\n\t.visual =\tFB_VISUAL_PSEUDOCOLOR,\n\t.xpanstep =\t1,\n\t.ypanstep =\t1,\n\t.ywrapstep =\t0,\n\t.accel =\tFB_ACCEL_3DLABS_PERMEDIA3,\n};\n\n \n\nstatic inline u32 PM3_READ_REG(struct pm3_par *par, s32 off)\n{\n\treturn fb_readl(par->v_regs + off);\n}\n\nstatic inline void PM3_WRITE_REG(struct pm3_par *par, s32 off, u32 v)\n{\n\tfb_writel(v, par->v_regs + off);\n}\n\nstatic inline void PM3_WAIT(struct pm3_par *par, u32 n)\n{\n\twhile (PM3_READ_REG(par, PM3InFIFOSpace) < n)\n\t\tcpu_relax();\n}\n\nstatic inline void PM3_WRITE_DAC_REG(struct pm3_par *par, unsigned r, u8 v)\n{\n\tPM3_WAIT(par, 3);\n\tPM3_WRITE_REG(par, PM3RD_IndexHigh, (r >> 8) & 0xff);\n\tPM3_WRITE_REG(par, PM3RD_IndexLow, r & 0xff);\n\twmb();\n\tPM3_WRITE_REG(par, PM3RD_IndexedData, v);\n\twmb();\n}\n\nstatic inline void pm3fb_set_color(struct pm3_par *par, unsigned char regno,\n\t\t\tunsigned char r, unsigned char g, unsigned char b)\n{\n\tPM3_WAIT(par, 4);\n\tPM3_WRITE_REG(par, PM3RD_PaletteWriteAddress, regno);\n\twmb();\n\tPM3_WRITE_REG(par, PM3RD_PaletteData, r);\n\twmb();\n\tPM3_WRITE_REG(par, PM3RD_PaletteData, g);\n\twmb();\n\tPM3_WRITE_REG(par, PM3RD_PaletteData, b);\n\twmb();\n}\n\nstatic void pm3fb_clear_colormap(struct pm3_par *par,\n\t\t\tunsigned char r, unsigned char g, unsigned char b)\n{\n\tint i;\n\n\tfor (i = 0; i < 256 ; i++)\n\t\tpm3fb_set_color(par, i, r, g, b);\n\n}\n\n \nstatic void pm3fb_calculate_clock(unsigned long reqclock,\n\t\t\t\tunsigned char *prescale,\n\t\t\t\tunsigned char *feedback,\n\t\t\t\tunsigned char *postscale)\n{\n\tint f, pre, post;\n\tunsigned long freq;\n\tlong freqerr = 1000;\n\tlong currerr;\n\n\tfor (f = 1; f < 256; f++) {\n\t\tfor (pre = 1; pre < 256; pre++) {\n\t\t\tfor (post = 0; post < 5; post++) {\n\t\t\t\tfreq = ((2*PM3_REF_CLOCK * f) >> post) / pre;\n\t\t\t\tcurrerr = (reqclock > freq)\n\t\t\t\t\t? reqclock - freq\n\t\t\t\t\t: freq - reqclock;\n\t\t\t\tif (currerr < freqerr) {\n\t\t\t\t\tfreqerr = currerr;\n\t\t\t\t\t*feedback = f;\n\t\t\t\t\t*prescale = pre;\n\t\t\t\t\t*postscale = post;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic inline int pm3fb_depth(const struct fb_var_screeninfo *var)\n{\n\tif (var->bits_per_pixel == 16)\n\t\treturn var->red.length + var->green.length\n\t\t\t+ var->blue.length;\n\n\treturn var->bits_per_pixel;\n}\n\nstatic inline int pm3fb_shift_bpp(unsigned bpp, int v)\n{\n\tswitch (bpp) {\n\tcase 8:\n\t\treturn (v >> 4);\n\tcase 16:\n\t\treturn (v >> 3);\n\tcase 32:\n\t\treturn (v >> 2);\n\t}\n\tDPRINTK(\"Unsupported depth %u\\n\", bpp);\n\treturn 0;\n}\n\n \nstatic int pm3fb_sync(struct fb_info *info)\n{\n\tstruct pm3_par *par = info->par;\n\n\tPM3_WAIT(par, 2);\n\tPM3_WRITE_REG(par, PM3FilterMode, PM3FilterModeSync);\n\tPM3_WRITE_REG(par, PM3Sync, 0);\n\tmb();\n\tdo {\n\t\twhile ((PM3_READ_REG(par, PM3OutFIFOWords)) == 0)\n\t\t\tcpu_relax();\n\t} while ((PM3_READ_REG(par, PM3OutputFifo)) != PM3Sync_Tag);\n\n\treturn 0;\n}\n\nstatic void pm3fb_init_engine(struct fb_info *info)\n{\n\tstruct pm3_par *par = info->par;\n\tconst u32 width = (info->var.xres_virtual + 7) & ~7;\n\n\tPM3_WAIT(par, 50);\n\tPM3_WRITE_REG(par, PM3FilterMode, PM3FilterModeSync);\n\tPM3_WRITE_REG(par, PM3StatisticMode, 0x0);\n\tPM3_WRITE_REG(par, PM3DeltaMode, 0x0);\n\tPM3_WRITE_REG(par, PM3RasterizerMode, 0x0);\n\tPM3_WRITE_REG(par, PM3ScissorMode, 0x0);\n\tPM3_WRITE_REG(par, PM3LineStippleMode, 0x0);\n\tPM3_WRITE_REG(par, PM3AreaStippleMode, 0x0);\n\tPM3_WRITE_REG(par, PM3GIDMode, 0x0);\n\tPM3_WRITE_REG(par, PM3DepthMode, 0x0);\n\tPM3_WRITE_REG(par, PM3StencilMode, 0x0);\n\tPM3_WRITE_REG(par, PM3StencilData, 0x0);\n\tPM3_WRITE_REG(par, PM3ColorDDAMode, 0x0);\n\tPM3_WRITE_REG(par, PM3TextureCoordMode, 0x0);\n\tPM3_WRITE_REG(par, PM3TextureIndexMode0, 0x0);\n\tPM3_WRITE_REG(par, PM3TextureIndexMode1, 0x0);\n\tPM3_WRITE_REG(par, PM3TextureReadMode, 0x0);\n\tPM3_WRITE_REG(par, PM3LUTMode, 0x0);\n\tPM3_WRITE_REG(par, PM3TextureFilterMode, 0x0);\n\tPM3_WRITE_REG(par, PM3TextureCompositeMode, 0x0);\n\tPM3_WRITE_REG(par, PM3TextureApplicationMode, 0x0);\n\tPM3_WRITE_REG(par, PM3TextureCompositeColorMode1, 0x0);\n\tPM3_WRITE_REG(par, PM3TextureCompositeAlphaMode1, 0x0);\n\tPM3_WRITE_REG(par, PM3TextureCompositeColorMode0, 0x0);\n\tPM3_WRITE_REG(par, PM3TextureCompositeAlphaMode0, 0x0);\n\tPM3_WRITE_REG(par, PM3FogMode, 0x0);\n\tPM3_WRITE_REG(par, PM3ChromaTestMode, 0x0);\n\tPM3_WRITE_REG(par, PM3AlphaTestMode, 0x0);\n\tPM3_WRITE_REG(par, PM3AntialiasMode, 0x0);\n\tPM3_WRITE_REG(par, PM3YUVMode, 0x0);\n\tPM3_WRITE_REG(par, PM3AlphaBlendColorMode, 0x0);\n\tPM3_WRITE_REG(par, PM3AlphaBlendAlphaMode, 0x0);\n\tPM3_WRITE_REG(par, PM3DitherMode, 0x0);\n\tPM3_WRITE_REG(par, PM3LogicalOpMode, 0x0);\n\tPM3_WRITE_REG(par, PM3RouterMode, 0x0);\n\tPM3_WRITE_REG(par, PM3Window, 0x0);\n\n\tPM3_WRITE_REG(par, PM3Config2D, 0x0);\n\n\tPM3_WRITE_REG(par, PM3SpanColorMask, 0xffffffff);\n\n\tPM3_WRITE_REG(par, PM3XBias, 0x0);\n\tPM3_WRITE_REG(par, PM3YBias, 0x0);\n\tPM3_WRITE_REG(par, PM3DeltaControl, 0x0);\n\n\tPM3_WRITE_REG(par, PM3BitMaskPattern, 0xffffffff);\n\n\tPM3_WRITE_REG(par, PM3FBDestReadEnables,\n\t\t\t   PM3FBDestReadEnables_E(0xff) |\n\t\t\t   PM3FBDestReadEnables_R(0xff) |\n\t\t\t   PM3FBDestReadEnables_ReferenceAlpha(0xff));\n\tPM3_WRITE_REG(par, PM3FBDestReadBufferAddr0, 0x0);\n\tPM3_WRITE_REG(par, PM3FBDestReadBufferOffset0, 0x0);\n\tPM3_WRITE_REG(par, PM3FBDestReadBufferWidth0,\n\t\t\t   PM3FBDestReadBufferWidth_Width(width));\n\n\tPM3_WRITE_REG(par, PM3FBDestReadMode,\n\t\t\t   PM3FBDestReadMode_ReadEnable |\n\t\t\t   PM3FBDestReadMode_Enable0);\n\tPM3_WRITE_REG(par, PM3FBSourceReadBufferAddr, 0x0);\n\tPM3_WRITE_REG(par, PM3FBSourceReadBufferOffset, 0x0);\n\tPM3_WRITE_REG(par, PM3FBSourceReadBufferWidth,\n\t\t\t   PM3FBSourceReadBufferWidth_Width(width));\n\tPM3_WRITE_REG(par, PM3FBSourceReadMode,\n\t\t\t   PM3FBSourceReadMode_Blocking |\n\t\t\t   PM3FBSourceReadMode_ReadEnable);\n\n\tPM3_WAIT(par, 2);\n\t{\n\t\t \n\t\tunsigned long rm = 1 | (3 << 7);\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 8:\n\t\t\tPM3_WRITE_REG(par, PM3PixelSize,\n\t\t\t\t\t   PM3PixelSize_GLOBAL_8BIT);\n#ifdef __BIG_ENDIAN\n\t\t\trm |= 3 << 15;\n#endif\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tPM3_WRITE_REG(par, PM3PixelSize,\n\t\t\t\t\t   PM3PixelSize_GLOBAL_16BIT);\n#ifdef __BIG_ENDIAN\n\t\t\trm |= 2 << 15;\n#endif\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tPM3_WRITE_REG(par, PM3PixelSize,\n\t\t\t\t\t   PM3PixelSize_GLOBAL_32BIT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINTK(\"Unsupported depth %d\\n\",\n\t\t\t\tinfo->var.bits_per_pixel);\n\t\t\tbreak;\n\t\t}\n\t\tPM3_WRITE_REG(par, PM3RasterizerMode, rm);\n\t}\n\n\tPM3_WAIT(par, 20);\n\tPM3_WRITE_REG(par, PM3FBSoftwareWriteMask, 0xffffffff);\n\tPM3_WRITE_REG(par, PM3FBHardwareWriteMask, 0xffffffff);\n\tPM3_WRITE_REG(par, PM3FBWriteMode,\n\t\t\t   PM3FBWriteMode_WriteEnable |\n\t\t\t   PM3FBWriteMode_OpaqueSpan |\n\t\t\t   PM3FBWriteMode_Enable0);\n\tPM3_WRITE_REG(par, PM3FBWriteBufferAddr0, 0x0);\n\tPM3_WRITE_REG(par, PM3FBWriteBufferOffset0, 0x0);\n\tPM3_WRITE_REG(par, PM3FBWriteBufferWidth0,\n\t\t\t   PM3FBWriteBufferWidth_Width(width));\n\n\tPM3_WRITE_REG(par, PM3SizeOfFramebuffer, 0x0);\n\t{\n\t\t \n\t\tunsigned long sofb = info->screen_size /\n\t\t\tinfo->fix.line_length;\n\t\tif (sofb > 4095)\n\t\t\tPM3_WRITE_REG(par, PM3SizeOfFramebuffer, 4095);\n\t\telse\n\t\t\tPM3_WRITE_REG(par, PM3SizeOfFramebuffer, sofb);\n\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 8:\n\t\t\tPM3_WRITE_REG(par, PM3DitherMode,\n\t\t\t\t\t   (1 << 10) | (2 << 3));\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tPM3_WRITE_REG(par, PM3DitherMode,\n\t\t\t\t\t   (1 << 10) | (1 << 3));\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tPM3_WRITE_REG(par, PM3DitherMode,\n\t\t\t\t\t   (1 << 10) | (0 << 3));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINTK(\"Unsupported depth %d\\n\",\n\t\t\t\tinfo->var.bits_per_pixel);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tPM3_WRITE_REG(par, PM3dXDom, 0x0);\n\tPM3_WRITE_REG(par, PM3dXSub, 0x0);\n\tPM3_WRITE_REG(par, PM3dY, 1 << 16);\n\tPM3_WRITE_REG(par, PM3StartXDom, 0x0);\n\tPM3_WRITE_REG(par, PM3StartXSub, 0x0);\n\tPM3_WRITE_REG(par, PM3StartY, 0x0);\n\tPM3_WRITE_REG(par, PM3Count, 0x0);\n\n \n\tPM3_WRITE_REG(par, PM3LBDestReadMode, 0x0);\n\tPM3_WRITE_REG(par, PM3LBDestReadEnables, 0x0);\n\tPM3_WRITE_REG(par, PM3LBSourceReadMode, 0x0);\n\tPM3_WRITE_REG(par, PM3LBWriteMode, 0x0);\n\n\tpm3fb_sync(info);\n}\n\nstatic void pm3fb_fillrect(struct fb_info *info,\n\t\t\t\tconst struct fb_fillrect *region)\n{\n\tstruct pm3_par *par = info->par;\n\tstruct fb_fillrect modded;\n\tint vxres, vyres;\n\tint rop;\n\tu32 color = (info->fix.visual == FB_VISUAL_TRUECOLOR) ?\n\t\t((u32 *)info->pseudo_palette)[region->color] : region->color;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\tif (info->flags & FBINFO_HWACCEL_DISABLED) {\n\t\tcfb_fillrect(info, region);\n\t\treturn;\n\t}\n\tif (region->rop == ROP_COPY )\n\t\trop = PM3Config2D_ForegroundROP(0x3);  \n\telse\n\t\trop = PM3Config2D_ForegroundROP(0x6) |  \n\t\t\tPM3Config2D_FBDestReadEnable;\n\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\n\tmemcpy(&modded, region, sizeof(struct fb_fillrect));\n\n\tif (!modded.width || !modded.height ||\n\t    modded.dx >= vxres || modded.dy >= vyres)\n\t\treturn;\n\n\tif (modded.dx + modded.width  > vxres)\n\t\tmodded.width  = vxres - modded.dx;\n\tif (modded.dy + modded.height > vyres)\n\t\tmodded.height = vyres - modded.dy;\n\n\tif (info->var.bits_per_pixel == 8)\n\t\tcolor |= color << 8;\n\tif (info->var.bits_per_pixel <= 16)\n\t\tcolor |= color << 16;\n\n\tPM3_WAIT(par, 4);\n\t \n\tPM3_WRITE_REG(par, PM3Config2D,\n\t\t\tPM3Config2D_UseConstantSource |\n\t\t\tPM3Config2D_ForegroundROPEnable |\n\t\t\trop |\n\t\t\tPM3Config2D_FBWriteEnable);\n\n\tPM3_WRITE_REG(par, PM3ForegroundColor, color);\n\n\tPM3_WRITE_REG(par, PM3RectanglePosition,\n\t\t\tPM3RectanglePosition_XOffset(modded.dx) |\n\t\t\tPM3RectanglePosition_YOffset(modded.dy));\n\n\tPM3_WRITE_REG(par, PM3Render2D,\n\t\t      PM3Render2D_XPositive |\n\t\t      PM3Render2D_YPositive |\n\t\t      PM3Render2D_Operation_Normal |\n\t\t      PM3Render2D_SpanOperation |\n\t\t      PM3Render2D_Width(modded.width) |\n\t\t      PM3Render2D_Height(modded.height));\n}\n\nstatic void pm3fb_copyarea(struct fb_info *info,\n\t\t\t\tconst struct fb_copyarea *area)\n{\n\tstruct pm3_par *par = info->par;\n\tstruct fb_copyarea modded;\n\tu32 vxres, vyres;\n\tint x_align, o_x, o_y;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\tif (info->flags & FBINFO_HWACCEL_DISABLED) {\n\t\tcfb_copyarea(info, area);\n\t\treturn;\n\t}\n\n\tmemcpy(&modded, area, sizeof(struct fb_copyarea));\n\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\n\tif (!modded.width || !modded.height ||\n\t    modded.sx >= vxres || modded.sy >= vyres ||\n\t    modded.dx >= vxres || modded.dy >= vyres)\n\t\treturn;\n\n\tif (modded.sx + modded.width > vxres)\n\t\tmodded.width = vxres - modded.sx;\n\tif (modded.dx + modded.width > vxres)\n\t\tmodded.width = vxres - modded.dx;\n\tif (modded.sy + modded.height > vyres)\n\t\tmodded.height = vyres - modded.sy;\n\tif (modded.dy + modded.height > vyres)\n\t\tmodded.height = vyres - modded.dy;\n\n\to_x = modded.sx - modded.dx;\t \n\to_y = modded.sy - modded.dy;\t \n\n\tx_align = (modded.sx & 0x1f);\n\n\tPM3_WAIT(par, 6);\n\n\tPM3_WRITE_REG(par, PM3Config2D,\n\t\t\tPM3Config2D_UserScissorEnable |\n\t\t\tPM3Config2D_ForegroundROPEnable |\n\t\t\tPM3Config2D_Blocking |\n\t\t\tPM3Config2D_ForegroundROP(0x3) |  \n\t\t\tPM3Config2D_FBWriteEnable);\n\n\tPM3_WRITE_REG(par, PM3ScissorMinXY,\n\t\t\t((modded.dy & 0x0fff) << 16) | (modded.dx & 0x0fff));\n\tPM3_WRITE_REG(par, PM3ScissorMaxXY,\n\t\t\t(((modded.dy + modded.height) & 0x0fff) << 16) |\n\t\t\t((modded.dx + modded.width) & 0x0fff));\n\n\tPM3_WRITE_REG(par, PM3FBSourceReadBufferOffset,\n\t\t\tPM3FBSourceReadBufferOffset_XOffset(o_x) |\n\t\t\tPM3FBSourceReadBufferOffset_YOffset(o_y));\n\n\tPM3_WRITE_REG(par, PM3RectanglePosition,\n\t\t\tPM3RectanglePosition_XOffset(modded.dx - x_align) |\n\t\t\tPM3RectanglePosition_YOffset(modded.dy));\n\n\tPM3_WRITE_REG(par, PM3Render2D,\n\t\t\t((modded.sx > modded.dx) ? PM3Render2D_XPositive : 0) |\n\t\t\t((modded.sy > modded.dy) ? PM3Render2D_YPositive : 0) |\n\t\t\tPM3Render2D_Operation_Normal |\n\t\t\tPM3Render2D_SpanOperation |\n\t\t\tPM3Render2D_FBSourceReadEnable |\n\t\t\tPM3Render2D_Width(modded.width + x_align) |\n\t\t\tPM3Render2D_Height(modded.height));\n}\n\nstatic void pm3fb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct pm3_par *par = info->par;\n\tu32 height = image->height;\n\tu32 fgx, bgx;\n\tconst u32 *src = (const u32 *)image->data;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\tif (info->flags & FBINFO_HWACCEL_DISABLED) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tfgx = image->fg_color;\n\t\tbgx = image->bg_color;\n\t\tbreak;\n\tcase FB_VISUAL_TRUECOLOR:\n\tdefault:\n\t\tfgx = par->palette[image->fg_color];\n\t\tbgx = par->palette[image->bg_color];\n\t\tbreak;\n\t}\n\tif (image->depth != 1) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tfgx |= fgx << 8;\n\t\tbgx |= bgx << 8;\n\t}\n\tif (info->var.bits_per_pixel <= 16) {\n\t\tfgx |= fgx << 16;\n\t\tbgx |= bgx << 16;\n\t}\n\n\tPM3_WAIT(par, 7);\n\n\tPM3_WRITE_REG(par, PM3ForegroundColor, fgx);\n\tPM3_WRITE_REG(par, PM3BackgroundColor, bgx);\n\n\t \n\tPM3_WRITE_REG(par, PM3Config2D,\n\t\t\tPM3Config2D_UserScissorEnable |\n\t\t\tPM3Config2D_UseConstantSource |\n\t\t\tPM3Config2D_ForegroundROPEnable |\n\t\t\tPM3Config2D_ForegroundROP(0x3) |\n\t\t\tPM3Config2D_OpaqueSpan |\n\t\t\tPM3Config2D_FBWriteEnable);\n\tPM3_WRITE_REG(par, PM3ScissorMinXY,\n\t\t\t((image->dy & 0x0fff) << 16) | (image->dx & 0x0fff));\n\tPM3_WRITE_REG(par, PM3ScissorMaxXY,\n\t\t\t(((image->dy + image->height) & 0x0fff) << 16) |\n\t\t\t((image->dx + image->width) & 0x0fff));\n\tPM3_WRITE_REG(par, PM3RectanglePosition,\n\t\t\tPM3RectanglePosition_XOffset(image->dx) |\n\t\t\tPM3RectanglePosition_YOffset(image->dy));\n\tPM3_WRITE_REG(par, PM3Render2D,\n\t\t\tPM3Render2D_XPositive |\n\t\t\tPM3Render2D_YPositive |\n\t\t\tPM3Render2D_Operation_SyncOnBitMask |\n\t\t\tPM3Render2D_SpanOperation |\n\t\t\tPM3Render2D_Width(image->width) |\n\t\t\tPM3Render2D_Height(image->height));\n\n\n\twhile (height--) {\n\t\tint width = ((image->width + 7) >> 3)\n\t\t\t\t+ info->pixmap.scan_align - 1;\n\t\twidth >>= 2;\n\n\t\twhile (width >= PM3_FIFO_SIZE) {\n\t\t\tint i = PM3_FIFO_SIZE - 1;\n\n\t\t\tPM3_WAIT(par, PM3_FIFO_SIZE);\n\t\t\twhile (i--) {\n\t\t\t\tPM3_WRITE_REG(par, PM3BitMaskPattern, *src);\n\t\t\t\tsrc++;\n\t\t\t}\n\t\t\twidth -= PM3_FIFO_SIZE - 1;\n\t\t}\n\n\t\tPM3_WAIT(par, width + 1);\n\t\twhile (width--) {\n\t\t\tPM3_WRITE_REG(par, PM3BitMaskPattern, *src);\n\t\t\tsrc++;\n\t\t}\n\t}\n}\n \n\n \nstatic const u8 cursor_bits_lookup[16] = {\n\t0x00, 0x40, 0x10, 0x50, 0x04, 0x44, 0x14, 0x54,\n\t0x01, 0x41, 0x11, 0x51, 0x05, 0x45, 0x15, 0x55\n};\n\nstatic int pm3fb_cursor(struct fb_info *info, struct fb_cursor *cursor)\n{\n\tstruct pm3_par *par = info->par;\n\tu8 mode;\n\n\tif (!hwcursor)\n\t\treturn -EINVAL;\t \n\n\t \n\tif (cursor->image.width > 64 ||\n\t    cursor->image.height > 64 ||\n\t    cursor->image.depth > 1)\n\t\treturn -EINVAL;\n\n\tmode = PM3RD_CursorMode_TYPE_X;\n\tif (cursor->enable)\n\t\t mode |= PM3RD_CursorMode_CURSOR_ENABLE;\n\n\tPM3_WRITE_DAC_REG(par, PM3RD_CursorMode, mode);\n\n\t \n\tif (!cursor->set)\n\t\treturn 0;\n\n\tif (cursor->set & FB_CUR_SETPOS) {\n\t\tint x = cursor->image.dx - info->var.xoffset;\n\t\tint y = cursor->image.dy - info->var.yoffset;\n\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_CursorXLow, x & 0xff);\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_CursorXHigh, (x >> 8) & 0xf);\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_CursorYLow, y & 0xff);\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_CursorYHigh, (y >> 8) & 0xf);\n\t}\n\n\tif (cursor->set & FB_CUR_SETHOT) {\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_CursorHotSpotX,\n\t\t\t\t  cursor->hot.x & 0x3f);\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_CursorHotSpotY,\n\t\t\t\t  cursor->hot.y & 0x3f);\n\t}\n\n\tif (cursor->set & FB_CUR_SETCMAP) {\n\t\tu32 fg_idx = cursor->image.fg_color;\n\t\tu32 bg_idx = cursor->image.bg_color;\n\t\tstruct fb_cmap cmap = info->cmap;\n\n\t\t \n\t\tPM3_WRITE_DAC_REG(par, PM3RD_CursorPalette(39),\n\t\t\t\t  cmap.red[fg_idx] >> 8 );\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_CursorPalette(40),\n\t\t\t\t  cmap.green[fg_idx] >> 8 );\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_CursorPalette(41),\n\t\t\t\t  cmap.blue[fg_idx] >> 8 );\n\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_CursorPalette(42),\n\t\t\t\t  cmap.red[bg_idx] >> 8 );\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_CursorPalette(43),\n\t\t\t\t  cmap.green[bg_idx] >> 8 );\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_CursorPalette(44),\n\t\t\t\t  cmap.blue[bg_idx] >> 8 );\n\t}\n\n\tif (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\n\t\tu8 *bitmap = (u8 *)cursor->image.data;\n\t\tu8 *mask = (u8 *)cursor->mask;\n\t\tint i;\n\t\tint pos = PM3RD_CursorPattern(0);\n\n\t\tfor (i = 0; i < cursor->image.height; i++) {\n\t\t\tint j = (cursor->image.width + 7) >> 3;\n\t\t\tint k = 8 - j;\n\n\t\t\tfor (; j > 0; j--) {\n\t\t\t\tu8 data = *bitmap ^ *mask;\n\n\t\t\t\tif (cursor->rop == ROP_COPY)\n\t\t\t\t\tdata = *mask & *bitmap;\n\t\t\t\t \n\t\t\t\tPM3_WRITE_DAC_REG(par, pos++,\n\t\t\t\t\tcursor_bits_lookup[data >> 4] |\n\t\t\t\t\t(cursor_bits_lookup[*mask >> 4] << 1));\n\t\t\t\t \n\t\t\t\tPM3_WRITE_DAC_REG(par, pos++,\n\t\t\t\t\tcursor_bits_lookup[data & 0xf] |\n\t\t\t\t\t(cursor_bits_lookup[*mask & 0xf] << 1));\n\t\t\t\tbitmap++;\n\t\t\t\tmask++;\n\t\t\t}\n\t\t\tfor (; k > 0; k--) {\n\t\t\t\tPM3_WRITE_DAC_REG(par, pos++, 0);\n\t\t\t\tPM3_WRITE_DAC_REG(par, pos++, 0);\n\t\t\t}\n\t\t}\n\t\twhile (pos < PM3RD_CursorPattern(1024))\n\t\t\tPM3_WRITE_DAC_REG(par, pos++, 0);\n\t}\n\treturn 0;\n}\n\n \nstatic void pm3fb_write_mode(struct fb_info *info)\n{\n\tstruct pm3_par *par = info->par;\n\tchar tempsync = 0x00;\n\tchar tempmisc = 0x00;\n\tconst u32 hsstart = info->var.right_margin;\n\tconst u32 hsend = hsstart + info->var.hsync_len;\n\tconst u32 hbend = hsend + info->var.left_margin;\n\tconst u32 xres = (info->var.xres + 31) & ~31;\n\tconst u32 htotal = xres + hbend;\n\tconst u32 vsstart = info->var.lower_margin;\n\tconst u32 vsend = vsstart + info->var.vsync_len;\n\tconst u32 vbend = vsend + info->var.upper_margin;\n\tconst u32 vtotal = info->var.yres + vbend;\n\tconst u32 width = (info->var.xres_virtual + 7) & ~7;\n\tconst unsigned bpp = info->var.bits_per_pixel;\n\n\tPM3_WAIT(par, 20);\n\tPM3_WRITE_REG(par, PM3MemBypassWriteMask, 0xffffffff);\n\tPM3_WRITE_REG(par, PM3Aperture0, 0x00000000);\n\tPM3_WRITE_REG(par, PM3Aperture1, 0x00000000);\n\tPM3_WRITE_REG(par, PM3FIFODis, 0x00000007);\n\n\tPM3_WRITE_REG(par, PM3HTotal,\n\t\t\t   pm3fb_shift_bpp(bpp, htotal - 1));\n\tPM3_WRITE_REG(par, PM3HsEnd,\n\t\t\t   pm3fb_shift_bpp(bpp, hsend));\n\tPM3_WRITE_REG(par, PM3HsStart,\n\t\t\t   pm3fb_shift_bpp(bpp, hsstart));\n\tPM3_WRITE_REG(par, PM3HbEnd,\n\t\t\t   pm3fb_shift_bpp(bpp, hbend));\n\tPM3_WRITE_REG(par, PM3HgEnd,\n\t\t\t   pm3fb_shift_bpp(bpp, hbend));\n\tPM3_WRITE_REG(par, PM3ScreenStride,\n\t\t\t   pm3fb_shift_bpp(bpp, width));\n\tPM3_WRITE_REG(par, PM3VTotal, vtotal - 1);\n\tPM3_WRITE_REG(par, PM3VsEnd, vsend - 1);\n\tPM3_WRITE_REG(par, PM3VsStart, vsstart - 1);\n\tPM3_WRITE_REG(par, PM3VbEnd, vbend);\n\n\tswitch (bpp) {\n\tcase 8:\n\t\tPM3_WRITE_REG(par, PM3ByAperture1Mode,\n\t\t\t\t   PM3ByApertureMode_PIXELSIZE_8BIT);\n\t\tPM3_WRITE_REG(par, PM3ByAperture2Mode,\n\t\t\t\t   PM3ByApertureMode_PIXELSIZE_8BIT);\n\t\tbreak;\n\n\tcase 16:\n#ifndef __BIG_ENDIAN\n\t\tPM3_WRITE_REG(par, PM3ByAperture1Mode,\n\t\t\t\t   PM3ByApertureMode_PIXELSIZE_16BIT);\n\t\tPM3_WRITE_REG(par, PM3ByAperture2Mode,\n\t\t\t\t   PM3ByApertureMode_PIXELSIZE_16BIT);\n#else\n\t\tPM3_WRITE_REG(par, PM3ByAperture1Mode,\n\t\t\t\t   PM3ByApertureMode_PIXELSIZE_16BIT |\n\t\t\t\t   PM3ByApertureMode_BYTESWAP_BADC);\n\t\tPM3_WRITE_REG(par, PM3ByAperture2Mode,\n\t\t\t\t   PM3ByApertureMode_PIXELSIZE_16BIT |\n\t\t\t\t   PM3ByApertureMode_BYTESWAP_BADC);\n#endif  \n\t\tbreak;\n\n\tcase 32:\n#ifndef __BIG_ENDIAN\n\t\tPM3_WRITE_REG(par, PM3ByAperture1Mode,\n\t\t\t\t   PM3ByApertureMode_PIXELSIZE_32BIT);\n\t\tPM3_WRITE_REG(par, PM3ByAperture2Mode,\n\t\t\t\t   PM3ByApertureMode_PIXELSIZE_32BIT);\n#else\n\t\tPM3_WRITE_REG(par, PM3ByAperture1Mode,\n\t\t\t\t   PM3ByApertureMode_PIXELSIZE_32BIT |\n\t\t\t\t   PM3ByApertureMode_BYTESWAP_DCBA);\n\t\tPM3_WRITE_REG(par, PM3ByAperture2Mode,\n\t\t\t\t   PM3ByApertureMode_PIXELSIZE_32BIT |\n\t\t\t\t   PM3ByApertureMode_BYTESWAP_DCBA);\n#endif  \n\t\tbreak;\n\n\tdefault:\n\t\tDPRINTK(\"Unsupported depth %d\\n\", bpp);\n\t\tbreak;\n\t}\n\n\t \n\t{\n\t\tunsigned int video = par->video;\n\n\t\tvideo &= ~(PM3VideoControl_HSYNC_MASK |\n\t\t\t   PM3VideoControl_VSYNC_MASK);\n\t\tvideo |= PM3VideoControl_HSYNC_ACTIVE_HIGH |\n\t\t\t PM3VideoControl_VSYNC_ACTIVE_HIGH;\n\t\tPM3_WRITE_REG(par, PM3VideoControl, video);\n\t}\n\tPM3_WRITE_REG(par, PM3VClkCtl,\n\t\t\t   (PM3_READ_REG(par, PM3VClkCtl) & 0xFFFFFFFC));\n\tPM3_WRITE_REG(par, PM3ScreenBase, par->base);\n\tPM3_WRITE_REG(par, PM3ChipConfig,\n\t\t\t   (PM3_READ_REG(par, PM3ChipConfig) & 0xFFFFFFFD));\n\n\twmb();\n\t{\n\t\tunsigned char m;\t \n\t\tunsigned char n;\t \n\t\tunsigned char p;\t \n\t\tunsigned long pixclock = PICOS2KHZ(info->var.pixclock);\n\n\t\t(void)pm3fb_calculate_clock(pixclock, &m, &n, &p);\n\n\t\tDPRINTK(\"Pixclock: %ld, Pre: %d, Feedback: %d, Post: %d\\n\",\n\t\t\tpixclock, (int) m, (int) n, (int) p);\n\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_DClk0PreScale, m);\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_DClk0FeedbackScale, n);\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_DClk0PostScale, p);\n\t}\n\t \n\t \n\tif ((par->video & PM3VideoControl_HSYNC_MASK) ==\n\t    PM3VideoControl_HSYNC_ACTIVE_HIGH)\n\t\ttempsync |= PM3RD_SyncControl_HSYNC_ACTIVE_HIGH;\n\tif ((par->video & PM3VideoControl_VSYNC_MASK) ==\n\t    PM3VideoControl_VSYNC_ACTIVE_HIGH)\n\t\ttempsync |= PM3RD_SyncControl_VSYNC_ACTIVE_HIGH;\n\n\tPM3_WRITE_DAC_REG(par, PM3RD_SyncControl, tempsync);\n\tDPRINTK(\"PM3RD_SyncControl: %d\\n\", tempsync);\n\n\tPM3_WRITE_DAC_REG(par, PM3RD_DACControl, 0x00);\n\n\tswitch (pm3fb_depth(&info->var)) {\n\tcase 8:\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_PixelSize,\n\t\t\t\t  PM3RD_PixelSize_8_BIT_PIXELS);\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_ColorFormat,\n\t\t\t\t  PM3RD_ColorFormat_CI8_COLOR |\n\t\t\t\t  PM3RD_ColorFormat_COLOR_ORDER_BLUE_LOW);\n\t\ttempmisc |= PM3RD_MiscControl_HIGHCOLOR_RES_ENABLE;\n\t\tbreak;\n\tcase 12:\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_PixelSize,\n\t\t\t\t  PM3RD_PixelSize_16_BIT_PIXELS);\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_ColorFormat,\n\t\t\t\t  PM3RD_ColorFormat_4444_COLOR |\n\t\t\t\t  PM3RD_ColorFormat_COLOR_ORDER_BLUE_LOW |\n\t\t\t\t  PM3RD_ColorFormat_LINEAR_COLOR_EXT_ENABLE);\n\t\ttempmisc |= PM3RD_MiscControl_DIRECTCOLOR_ENABLE |\n\t\t\tPM3RD_MiscControl_HIGHCOLOR_RES_ENABLE;\n\t\tbreak;\n\tcase 15:\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_PixelSize,\n\t\t\t\t  PM3RD_PixelSize_16_BIT_PIXELS);\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_ColorFormat,\n\t\t\t\t  PM3RD_ColorFormat_5551_FRONT_COLOR |\n\t\t\t\t  PM3RD_ColorFormat_COLOR_ORDER_BLUE_LOW |\n\t\t\t\t  PM3RD_ColorFormat_LINEAR_COLOR_EXT_ENABLE);\n\t\ttempmisc |= PM3RD_MiscControl_DIRECTCOLOR_ENABLE |\n\t\t\tPM3RD_MiscControl_HIGHCOLOR_RES_ENABLE;\n\t\tbreak;\n\tcase 16:\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_PixelSize,\n\t\t\t\t  PM3RD_PixelSize_16_BIT_PIXELS);\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_ColorFormat,\n\t\t\t\t  PM3RD_ColorFormat_565_FRONT_COLOR |\n\t\t\t\t  PM3RD_ColorFormat_COLOR_ORDER_BLUE_LOW |\n\t\t\t\t  PM3RD_ColorFormat_LINEAR_COLOR_EXT_ENABLE);\n\t\ttempmisc |= PM3RD_MiscControl_DIRECTCOLOR_ENABLE |\n\t\t\tPM3RD_MiscControl_HIGHCOLOR_RES_ENABLE;\n\t\tbreak;\n\tcase 32:\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_PixelSize,\n\t\t\t\t  PM3RD_PixelSize_32_BIT_PIXELS);\n\t\tPM3_WRITE_DAC_REG(par, PM3RD_ColorFormat,\n\t\t\t\t  PM3RD_ColorFormat_8888_COLOR |\n\t\t\t\t  PM3RD_ColorFormat_COLOR_ORDER_BLUE_LOW);\n\t\ttempmisc |= PM3RD_MiscControl_DIRECTCOLOR_ENABLE |\n\t\t\tPM3RD_MiscControl_HIGHCOLOR_RES_ENABLE;\n\t\tbreak;\n\t}\n\tPM3_WRITE_DAC_REG(par, PM3RD_MiscControl, tempmisc);\n}\n\n \nstatic int pm3fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tu32 lpitch;\n\tunsigned bpp = var->red.length + var->green.length\n\t\t\t+ var->blue.length + var->transp.length;\n\n\tif (bpp != var->bits_per_pixel) {\n\t\t \n\n\t\tswitch (var->bits_per_pixel) {\n\t\tcase 8:\n\t\t\tvar->red.length = 8;\n\t\t\tvar->green.length = 8;\n\t\t\tvar->blue.length = 8;\n\t\t\tvar->red.offset = 0;\n\t\t\tvar->green.offset = 0;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->transp.offset = 0;\n\t\t\tvar->transp.length = 0;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tvar->red.length = 5;\n\t\t\tvar->blue.length = 5;\n\t\t\tvar->green.length = 6;\n\t\t\tvar->transp.length = 0;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tvar->red.length = 8;\n\t\t\tvar->green.length = 8;\n\t\t\tvar->blue.length = 8;\n\t\t\tvar->transp.length = 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINTK(\"depth not supported: %u\\n\",\n\t\t\t\tvar->bits_per_pixel);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\tif (var->bits_per_pixel > 8 ) {\n\t\tvar->blue.offset = 0;\n\t\tvar->green.offset = var->blue.length;\n\t\tvar->red.offset = var->green.offset + var->green.length;\n\t\tvar->transp.offset = var->red.offset + var->red.length;\n\t}\n\tvar->height = -1;\n\tvar->width = -1;\n\n\tif (var->xres != var->xres_virtual) {\n\t\tDPRINTK(\"virtual x resolution != \"\n\t\t\t\"physical x resolution not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->yres > var->yres_virtual) {\n\t\tDPRINTK(\"virtual y resolution < \"\n\t\t\t\"physical y resolution not possible\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->xoffset) {\n\t\tDPRINTK(\"xoffset not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\n\t\tDPRINTK(\"interlace not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvar->xres = (var->xres + 31) & ~31;  \n\tlpitch = var->xres * ((var->bits_per_pixel + 7) >> 3);\n\n\tif (var->xres < 200 || var->xres > 2048) {\n\t\tDPRINTK(\"width not supported: %u\\n\", var->xres);\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->yres < 200 || var->yres > 4095) {\n\t\tDPRINTK(\"height not supported: %u\\n\", var->yres);\n\t\treturn -EINVAL;\n\t}\n\n\tif (lpitch * var->yres_virtual > info->fix.smem_len) {\n\t\tDPRINTK(\"no memory for screen (%ux%ux%u)\\n\",\n\t\t\tvar->xres, var->yres_virtual, var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\tif (PICOS2KHZ(var->pixclock) > PM3_MAX_PIXCLOCK) {\n\t\tDPRINTK(\"pixclock too high (%ldKHz)\\n\",\n\t\t\tPICOS2KHZ(var->pixclock));\n\t\treturn -EINVAL;\n\t}\n\n\tvar->accel_flags = 0;\t \n\n\tDPRINTK(\"Checking graphics mode at %dx%d depth %d\\n\",\n\t\tvar->xres, var->yres, var->bits_per_pixel);\n\treturn 0;\n}\n\nstatic int pm3fb_set_par(struct fb_info *info)\n{\n\tstruct pm3_par *par = info->par;\n\tconst u32 xres = (info->var.xres + 31) & ~31;\n\tconst unsigned bpp = info->var.bits_per_pixel;\n\n\tpar->base = pm3fb_shift_bpp(bpp, (info->var.yoffset * xres)\n\t\t\t\t\t+ info->var.xoffset);\n\tpar->video = 0;\n\n\tif (info->var.sync & FB_SYNC_HOR_HIGH_ACT)\n\t\tpar->video |= PM3VideoControl_HSYNC_ACTIVE_HIGH;\n\telse\n\t\tpar->video |= PM3VideoControl_HSYNC_ACTIVE_LOW;\n\n\tif (info->var.sync & FB_SYNC_VERT_HIGH_ACT)\n\t\tpar->video |= PM3VideoControl_VSYNC_ACTIVE_HIGH;\n\telse\n\t\tpar->video |= PM3VideoControl_VSYNC_ACTIVE_LOW;\n\n\tif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE)\n\t\tpar->video |= PM3VideoControl_LINE_DOUBLE_ON;\n\n\tif ((info->var.activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW)\n\t\tpar->video |= PM3VideoControl_ENABLE;\n\telse\n\t\tDPRINTK(\"PM3Video disabled\\n\");\n\n\tswitch (bpp) {\n\tcase 8:\n\t\tpar->video |= PM3VideoControl_PIXELSIZE_8BIT;\n\t\tbreak;\n\tcase 16:\n\t\tpar->video |= PM3VideoControl_PIXELSIZE_16BIT;\n\t\tbreak;\n\tcase 32:\n\t\tpar->video |= PM3VideoControl_PIXELSIZE_32BIT;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTK(\"Unsupported depth\\n\");\n\t\tbreak;\n\t}\n\n\tinfo->fix.visual =\n\t\t(bpp == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\tinfo->fix.line_length = ((info->var.xres_virtual + 7)  >> 3) * bpp;\n\n \n\tpm3fb_clear_colormap(par, 0, 0, 0);\n\tPM3_WRITE_DAC_REG(par, PM3RD_CursorMode, 0);\n\tpm3fb_init_engine(info);\n\tpm3fb_write_mode(info);\n\treturn 0;\n}\n\nstatic int pm3fb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t   unsigned blue, unsigned transp,\n\t\t\t   struct fb_info *info)\n{\n\tstruct pm3_par *par = info->par;\n\n\tif (regno >= 256)   \n\t   return -EINVAL;\n\n\t \n\t \n\tif (info->var.grayscale)\n\t   red = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n\n\t \n\n\t \n#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)\n\tred = CNVT_TOHW(red, info->var.red.length);\n\tgreen = CNVT_TOHW(green, info->var.green.length);\n\tblue = CNVT_TOHW(blue, info->var.blue.length);\n\ttransp = CNVT_TOHW(transp, info->var.transp.length);\n#undef CNVT_TOHW\n\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\n\tinfo->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\tu32 v;\n\n\t\tif (regno >= 16)\n\t\t\treturn -EINVAL;\n\n\t\tv = (red << info->var.red.offset) |\n\t\t\t(green << info->var.green.offset) |\n\t\t\t(blue << info->var.blue.offset) |\n\t\t\t(transp << info->var.transp.offset);\n\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 8:\n\t\t\tbreak;\n\t\tcase 16:\n\t\tcase 32:\n\t\t\t((u32 *)(info->pseudo_palette))[regno] = v;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t} else if (info->fix.visual == FB_VISUAL_PSEUDOCOLOR)\n\t\tpm3fb_set_color(par, regno, red, green, blue);\n\n\treturn 0;\n}\n\nstatic int pm3fb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\t struct fb_info *info)\n{\n\tstruct pm3_par *par = info->par;\n\tconst u32 xres = (info->var.xres + 31) & ~31;\n\n\tpar->base = pm3fb_shift_bpp(info->var.bits_per_pixel,\n\t\t\t\t\t(var->yoffset * xres)\n\t\t\t\t\t+ var->xoffset);\n\tPM3_WAIT(par, 1);\n\tPM3_WRITE_REG(par, PM3ScreenBase, par->base);\n\treturn 0;\n}\n\nstatic int pm3fb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct pm3_par *par = info->par;\n\tu32 video = par->video;\n\n\t \n\tvideo &= ~(PM3VideoControl_HSYNC_MASK |\n\t\t   PM3VideoControl_VSYNC_MASK);\n\tvideo |= PM3VideoControl_HSYNC_ACTIVE_HIGH |\n\t\t PM3VideoControl_VSYNC_ACTIVE_HIGH;\n\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\tvideo |= PM3VideoControl_ENABLE;\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\tvideo &= ~PM3VideoControl_ENABLE;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tvideo &= ~(PM3VideoControl_HSYNC_MASK |\n\t\t\t  PM3VideoControl_BLANK_ACTIVE_LOW);\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tvideo &= ~(PM3VideoControl_VSYNC_MASK |\n\t\t\t  PM3VideoControl_BLANK_ACTIVE_LOW);\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tvideo &= ~(PM3VideoControl_HSYNC_MASK |\n\t\t\t  PM3VideoControl_VSYNC_MASK |\n\t\t\t  PM3VideoControl_BLANK_ACTIVE_LOW);\n\t\tbreak;\n\tdefault:\n\t\tDPRINTK(\"Unsupported blanking %d\\n\", blank_mode);\n\t\treturn 1;\n\t}\n\n\tPM3_WAIT(par, 1);\n\tPM3_WRITE_REG(par, PM3VideoControl, video);\n\treturn 0;\n}\n\n\t \n\nstatic const struct fb_ops pm3fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= pm3fb_check_var,\n\t.fb_set_par\t= pm3fb_set_par,\n\t.fb_setcolreg\t= pm3fb_setcolreg,\n\t.fb_pan_display\t= pm3fb_pan_display,\n\t.fb_fillrect\t= pm3fb_fillrect,\n\t.fb_copyarea\t= pm3fb_copyarea,\n\t.fb_imageblit\t= pm3fb_imageblit,\n\t.fb_blank\t= pm3fb_blank,\n\t.fb_sync\t= pm3fb_sync,\n\t.fb_cursor\t= pm3fb_cursor,\n};\n\n \n\n\t \n\n \n \nstatic unsigned long pm3fb_size_memory(struct pm3_par *par)\n{\n\tunsigned long\tmemsize = 0;\n\tunsigned long\ttempBypass, i, temp1, temp2;\n\tunsigned char\t__iomem *screen_mem;\n\n\tpm3fb_fix.smem_len = 64 * 1024l * 1024;  \n\t \n\tif (!request_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len,\n\t\t\t\t \"pm3fb smem\")) {\n\t\tprintk(KERN_WARNING \"pm3fb: Can't reserve smem.\\n\");\n\t\treturn 0;\n\t}\n\tscreen_mem =\n\t\tioremap(pm3fb_fix.smem_start, pm3fb_fix.smem_len);\n\tif (!screen_mem) {\n\t\tprintk(KERN_WARNING \"pm3fb: Can't ioremap smem area.\\n\");\n\t\trelease_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len);\n\t\treturn 0;\n\t}\n\n\t \n\t \n\n\ttempBypass = PM3_READ_REG(par, PM3MemBypassWriteMask);\n\n\tDPRINTK(\"PM3MemBypassWriteMask was: 0x%08lx\\n\", tempBypass);\n\n\tPM3_WAIT(par, 1);\n\tPM3_WRITE_REG(par, PM3MemBypassWriteMask, 0xFFFFFFFF);\n\n\t \n\tfor (i = 0; i < 32; i++) {\n\t\tfb_writel(i * 0x00345678,\n\t\t\t  (screen_mem + (i * 1048576)));\n\t\tmb();\n\t\ttemp1 = fb_readl((screen_mem + (i * 1048576)));\n\n\t\t \n\t\tif (temp1 == (i * 0x00345678))\n\t\t\tmemsize = i;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tDPRINTK(\"First detect pass already got %ld MB\\n\", memsize + 1);\n\n\tif (memsize + 1 == i) {\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\t \n\t\t\twritel(0x0000000, (screen_mem + (i * 1048576)));\n\t\t}\n\t\twmb();\n\n\t\tfor (i = 32; i < 64; i++) {\n\t\t\tfb_writel(i * 0x00345678,\n\t\t\t\t  (screen_mem + (i * 1048576)));\n\t\t\tmb();\n\t\t\ttemp1 =\n\t\t\t    fb_readl((screen_mem + (i * 1048576)));\n\t\t\ttemp2 =\n\t\t\t    fb_readl((screen_mem + ((i - 32) * 1048576)));\n\t\t\t \n\t\t\tif ((temp1 == (i * 0x00345678)) && (temp2 == 0))\n\t\t\t\tmemsize = i;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tDPRINTK(\"Second detect pass got %ld MB\\n\", memsize + 1);\n\n\tPM3_WAIT(par, 1);\n\tPM3_WRITE_REG(par, PM3MemBypassWriteMask, tempBypass);\n\n\tiounmap(screen_mem);\n\trelease_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len);\n\tmemsize = 1048576 * (memsize + 1);\n\n\tDPRINTK(\"Returning 0x%08lx bytes\\n\", memsize);\n\n\treturn memsize;\n}\n\nstatic int pm3fb_probe(struct pci_dev *dev, const struct pci_device_id *ent)\n{\n\tstruct fb_info *info;\n\tstruct pm3_par *par;\n\tstruct device *device = &dev->dev;  \n\tint err;\n\tint retval = -ENXIO;\n\n\terr = aperture_remove_conflicting_pci_devices(dev, \"pm3fb\");\n\tif (err)\n\t\treturn err;\n\n\terr = pci_enable_device(dev);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"pm3fb: Can't enable PCI dev: %d\\n\", err);\n\t\treturn err;\n\t}\n\t \n\tinfo = framebuffer_alloc(sizeof(struct pm3_par), device);\n\n\tif (!info)\n\t\treturn -ENOMEM;\n\tpar = info->par;\n\n\t \n\tpm3fb_fix.mmio_start = pci_resource_start(dev, 0);\n\tpm3fb_fix.mmio_len = PM3_REGS_SIZE;\n#if defined(__BIG_ENDIAN)\n\tpm3fb_fix.mmio_start += PM3_REGS_SIZE;\n\tDPRINTK(\"Adjusting register base for big-endian.\\n\");\n#endif\n\n\t \n\tif (!request_mem_region(pm3fb_fix.mmio_start, pm3fb_fix.mmio_len,\n\t\t\t\t \"pm3fb regbase\")) {\n\t\tprintk(KERN_WARNING \"pm3fb: Can't reserve regbase.\\n\");\n\t\tgoto err_exit_neither;\n\t}\n\tpar->v_regs =\n\t\tioremap(pm3fb_fix.mmio_start, pm3fb_fix.mmio_len);\n\tif (!par->v_regs) {\n\t\tprintk(KERN_WARNING \"pm3fb: Can't remap %s register area.\\n\",\n\t\t\tpm3fb_fix.id);\n\t\trelease_mem_region(pm3fb_fix.mmio_start, pm3fb_fix.mmio_len);\n\t\tgoto err_exit_neither;\n\t}\n\n\t \n\tpm3fb_fix.smem_start = pci_resource_start(dev, 1);\n\tpm3fb_fix.smem_len = pm3fb_size_memory(par);\n\tif (!pm3fb_fix.smem_len) {\n\t\tprintk(KERN_WARNING \"pm3fb: Can't find memory on board.\\n\");\n\t\tgoto err_exit_mmio;\n\t}\n\tif (!request_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len,\n\t\t\t\t \"pm3fb smem\")) {\n\t\tprintk(KERN_WARNING \"pm3fb: Can't reserve smem.\\n\");\n\t\tgoto err_exit_mmio;\n\t}\n\tinfo->screen_base = ioremap_wc(pm3fb_fix.smem_start,\n\t\t\t\t       pm3fb_fix.smem_len);\n\tif (!info->screen_base) {\n\t\tprintk(KERN_WARNING \"pm3fb: Can't ioremap smem area.\\n\");\n\t\trelease_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len);\n\t\tgoto err_exit_mmio;\n\t}\n\tinfo->screen_size = pm3fb_fix.smem_len;\n\n\tif (!nomtrr)\n\t\tpar->wc_cookie = arch_phys_wc_add(pm3fb_fix.smem_start,\n\t\t\t\t\t\t  pm3fb_fix.smem_len);\n\tinfo->fbops = &pm3fb_ops;\n\n\tpar->video = PM3_READ_REG(par, PM3VideoControl);\n\n\tinfo->fix = pm3fb_fix;\n\tinfo->pseudo_palette = par->palette;\n\tinfo->flags = FBINFO_HWACCEL_XPAN |\n\t\t\tFBINFO_HWACCEL_YPAN |\n\t\t\tFBINFO_HWACCEL_COPYAREA |\n\t\t\tFBINFO_HWACCEL_IMAGEBLIT |\n\t\t\tFBINFO_HWACCEL_FILLRECT;\n\n\tif (noaccel) {\n\t\tprintk(KERN_DEBUG \"disabling acceleration\\n\");\n\t\tinfo->flags |= FBINFO_HWACCEL_DISABLED;\n\t}\n\tinfo->pixmap.addr = kmalloc(PM3_PIXMAP_SIZE, GFP_KERNEL);\n\tif (!info->pixmap.addr) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_exit_pixmap;\n\t}\n\tinfo->pixmap.size = PM3_PIXMAP_SIZE;\n\tinfo->pixmap.buf_align = 4;\n\tinfo->pixmap.scan_align = 4;\n\tinfo->pixmap.access_align = 32;\n\tinfo->pixmap.flags = FB_PIXMAP_SYSTEM;\n\n\t \n\tif (!mode_option)\n\t\tmode_option = \"640x480@60\";\n\n\tretval = fb_find_mode(&info->var, info, mode_option, NULL, 0, NULL, 8);\n\n\tif (!retval || retval == 4) {\n\t\tretval = -EINVAL;\n\t\tgoto err_exit_both;\n\t}\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_exit_both;\n\t}\n\n\t \n\tpm3fb_check_var(&info->var, info);\n\n\tif (register_framebuffer(info) < 0) {\n\t\tretval = -EINVAL;\n\t\tgoto err_exit_all;\n\t}\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\tpci_set_drvdata(dev, info);\n\treturn 0;\n\n err_exit_all:\n\tfb_dealloc_cmap(&info->cmap);\n err_exit_both:\n\tkfree(info->pixmap.addr);\n err_exit_pixmap:\n\tiounmap(info->screen_base);\n\trelease_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len);\n err_exit_mmio:\n\tiounmap(par->v_regs);\n\trelease_mem_region(pm3fb_fix.mmio_start, pm3fb_fix.mmio_len);\n err_exit_neither:\n\tframebuffer_release(info);\n\treturn retval;\n}\n\n\t \nstatic void pm3fb_remove(struct pci_dev *dev)\n{\n\tstruct fb_info *info = pci_get_drvdata(dev);\n\n\tif (info) {\n\t\tstruct fb_fix_screeninfo *fix = &info->fix;\n\t\tstruct pm3_par *par = info->par;\n\n\t\tunregister_framebuffer(info);\n\t\tfb_dealloc_cmap(&info->cmap);\n\n\t\tarch_phys_wc_del(par->wc_cookie);\n\t\tiounmap(info->screen_base);\n\t\trelease_mem_region(fix->smem_start, fix->smem_len);\n\t\tiounmap(par->v_regs);\n\t\trelease_mem_region(fix->mmio_start, fix->mmio_len);\n\n\t\tkfree(info->pixmap.addr);\n\t\tframebuffer_release(info);\n\t}\n}\n\nstatic const struct pci_device_id pm3fb_id_table[] = {\n\t{ PCI_VENDOR_ID_3DLABS, 0x0a,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0, }\n};\n\n \nstatic struct pci_driver pm3fb_driver = {\n\t.name =\t\t\"pm3fb\",\n\t.id_table =\tpm3fb_id_table,\n\t.probe =\tpm3fb_probe,\n\t.remove =\tpm3fb_remove,\n};\n\nMODULE_DEVICE_TABLE(pci, pm3fb_id_table);\n\n#ifndef MODULE\n\t \n\n \nstatic int __init pm3fb_setup(char *options)\n{\n\tchar *this_opt;\n\n\t \n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt)\n\t\t\tcontinue;\n\t\telse if (!strncmp(this_opt, \"noaccel\", 7))\n\t\t\tnoaccel = 1;\n\t\telse if (!strncmp(this_opt, \"hwcursor=\", 9))\n\t\t\thwcursor = simple_strtoul(this_opt + 9, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"nomtrr\", 6))\n\t\t\tnomtrr = 1;\n\t\telse\n\t\t\tmode_option = this_opt;\n\t}\n\treturn 0;\n}\n#endif  \n\nstatic int __init pm3fb_init(void)\n{\n\t \n#ifndef MODULE\n\tchar *option = NULL;\n#endif\n\n\tif (fb_modesetting_disabled(\"pm3fb\"))\n\t\treturn -ENODEV;\n\n#ifndef MODULE\n\tif (fb_get_options(\"pm3fb\", &option))\n\t\treturn -ENODEV;\n\tpm3fb_setup(option);\n#endif\n\n\treturn pci_register_driver(&pm3fb_driver);\n}\n\n#ifdef MODULE\nstatic void __exit pm3fb_exit(void)\n{\n\tpci_unregister_driver(&pm3fb_driver);\n}\n\nmodule_exit(pm3fb_exit);\n#endif\nmodule_init(pm3fb_init);\n\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option, \"Initial video mode e.g. '648x480-8@60'\");\nmodule_param(noaccel, bool, 0);\nMODULE_PARM_DESC(noaccel, \"Disable acceleration\");\nmodule_param(hwcursor, int, 0644);\nMODULE_PARM_DESC(hwcursor, \"Enable hardware cursor \"\n\t\t\t\"(1=enable, 0=disable, default=1)\");\nmodule_param(nomtrr, bool, 0);\nMODULE_PARM_DESC(nomtrr, \"Disable MTRR support (0 or 1=disabled) (default=0)\");\n\nMODULE_DESCRIPTION(\"Permedia3 framebuffer device driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}