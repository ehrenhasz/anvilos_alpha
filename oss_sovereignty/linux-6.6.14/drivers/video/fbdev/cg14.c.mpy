{
  "module_name": "cg14.c",
  "hash_id": "6dad309b03f2cdc0db78971d66acceb7cbf986041e9bd1f0a22534b32ee76aad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/cg14.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/fb.h>\n#include <linux/mm.h>\n#include <linux/uaccess.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <asm/io.h>\n#include <asm/fbio.h>\n\n#include \"sbuslib.h\"\n\n \n\nstatic int cg14_setcolreg(unsigned, unsigned, unsigned, unsigned,\n\t\t\t unsigned, struct fb_info *);\n\nstatic int cg14_mmap(struct fb_info *, struct vm_area_struct *);\nstatic int cg14_ioctl(struct fb_info *, unsigned int, unsigned long);\nstatic int cg14_pan_display(struct fb_var_screeninfo *, struct fb_info *);\n\n \n\nstatic const struct fb_ops cg14_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_setcolreg\t\t= cg14_setcolreg,\n\t.fb_pan_display\t\t= cg14_pan_display,\n\t.fb_fillrect\t\t= cfb_fillrect,\n\t.fb_copyarea\t\t= cfb_copyarea,\n\t.fb_imageblit\t\t= cfb_imageblit,\n\t.fb_mmap\t\t= cg14_mmap,\n\t.fb_ioctl\t\t= cg14_ioctl,\n#ifdef CONFIG_COMPAT\n\t.fb_compat_ioctl\t= sbusfb_compat_ioctl,\n#endif\n};\n\n#define CG14_MCR_INTENABLE_SHIFT\t7\n#define CG14_MCR_INTENABLE_MASK\t\t0x80\n#define CG14_MCR_VIDENABLE_SHIFT\t6\n#define CG14_MCR_VIDENABLE_MASK\t\t0x40\n#define CG14_MCR_PIXMODE_SHIFT\t\t4\n#define CG14_MCR_PIXMODE_MASK\t\t0x30\n#define CG14_MCR_TMR_SHIFT\t\t2\n#define CG14_MCR_TMR_MASK\t\t0x0c\n#define CG14_MCR_TMENABLE_SHIFT\t\t1\n#define CG14_MCR_TMENABLE_MASK\t\t0x02\n#define CG14_MCR_RESET_SHIFT\t\t0\n#define CG14_MCR_RESET_MASK\t\t0x01\n#define CG14_REV_REVISION_SHIFT\t\t4\n#define CG14_REV_REVISION_MASK\t\t0xf0\n#define CG14_REV_IMPL_SHIFT\t\t0\n#define CG14_REV_IMPL_MASK\t\t0x0f\n#define CG14_VBR_FRAMEBASE_SHIFT\t12\n#define CG14_VBR_FRAMEBASE_MASK\t\t0x00fff000\n#define CG14_VMCR1_SETUP_SHIFT\t\t0\n#define CG14_VMCR1_SETUP_MASK\t\t0x000001ff\n#define CG14_VMCR1_VCONFIG_SHIFT\t9\n#define CG14_VMCR1_VCONFIG_MASK\t\t0x00000e00\n#define CG14_VMCR2_REFRESH_SHIFT\t0\n#define CG14_VMCR2_REFRESH_MASK\t\t0x00000001\n#define CG14_VMCR2_TESTROWCNT_SHIFT\t1\n#define CG14_VMCR2_TESTROWCNT_MASK\t0x00000002\n#define CG14_VMCR2_FBCONFIG_SHIFT\t2\n#define CG14_VMCR2_FBCONFIG_MASK\t0x0000000c\n#define CG14_VCR_REFRESHREQ_SHIFT\t0\n#define CG14_VCR_REFRESHREQ_MASK\t0x000003ff\n#define CG14_VCR1_REFRESHENA_SHIFT\t10\n#define CG14_VCR1_REFRESHENA_MASK\t0x00000400\n#define CG14_VCA_CAD_SHIFT\t\t0\n#define CG14_VCA_CAD_MASK\t\t0x000003ff\n#define CG14_VCA_VERS_SHIFT\t\t10\n#define CG14_VCA_VERS_MASK\t\t0x00000c00\n#define CG14_VCA_RAMSPEED_SHIFT\t\t12\n#define CG14_VCA_RAMSPEED_MASK\t\t0x00001000\n#define CG14_VCA_8MB_SHIFT\t\t13\n#define CG14_VCA_8MB_MASK\t\t0x00002000\n\n#define CG14_MCR_PIXMODE_8\t\t0\n#define CG14_MCR_PIXMODE_16\t\t2\n#define CG14_MCR_PIXMODE_32\t\t3\n\nstruct cg14_regs{\n\tu8 mcr;\t \n\tu8 ppr;\t \n\tu8 tms[2];\t \n\tu8 msr;\t \n\tu8 fsr;\t \n\tu8 rev;\t \n\tu8 ccr;\t \n\tu32 tmr;\t \n\tu8 mod;\t \n\tu8 acr;\t \n\tu8 xxx0[6];\n\tu16 hct;\t \n\tu16 vct;\t \n\tu16 hbs;\t \n\tu16 hbc;\t \n\tu16 hss;\t \n\tu16 hsc;\t \n\tu16 csc;\t \n\tu16 vbs;\t \n\tu16 vbc;\t \n\tu16 vss;\t \n\tu16 vsc;\t \n\tu16 xcs;\n\tu16 xcc;\n\tu16 fsa;\t \n\tu16 adr;\t \n\tu8 xxx1[0xce];\n\tu8 pcg[0x100];  \n\tu32 vbr;\t \n\tu32 vmcr;\t \n\tu32 vcr;\t \n\tu32 vca;\t \n};\n\n#define CG14_CCR_ENABLE\t0x04\n#define CG14_CCR_SELECT 0x02\t \n\nstruct cg14_cursor {\n\tu32 cpl0[32];\t \n\tu32 cpl1[32];   \n\tu8 ccr;\t \n\tu8 xxx0[3];\n\tu16 cursx;\t \n\tu16 cursy;\t \n\tu32 color0;\n\tu32 color1;\n\tu32 xxx1[0x1bc];\n\tu32 cpl0i[32];\t \n\tu32 cpl1i[32];  \n};\n\nstruct cg14_dac {\n\tu8 addr;\t \n\tu8 xxx0[255];\n\tu8 glut;\t \n\tu8 xxx1[255];\n\tu8 select;\t \n\tu8 xxx2[255];\n\tu8 mode;\t \n};\n\nstruct cg14_xlut{\n\tu8 x_xlut [256];\n\tu8 x_xlutd [256];\n\tu8 xxx0[0x600];\n\tu8 x_xlut_inc [256];\n\tu8 x_xlutd_inc [256];\n};\n\n \n \nstruct cg14_clut {\n\tu32 c_clut [256];\n\tu32 c_clutd [256];     \n\tu32 c_clut_inc [256];\n\tu32 c_clutd_inc [256];\n};\n\n#define CG14_MMAP_ENTRIES\t16\n\nstruct cg14_par {\n\tspinlock_t\t\tlock;\n\tstruct cg14_regs\t__iomem *regs;\n\tstruct cg14_clut\t__iomem *clut;\n\tstruct cg14_cursor\t__iomem *cursor;\n\n\tu32\t\t\tflags;\n#define CG14_FLAG_BLANKED\t0x00000001\n\n\tunsigned long\t\tiospace;\n\n\tstruct sbus_mmap_map\tmmap_map[CG14_MMAP_ENTRIES];\n\n\tint\t\t\tmode;\n\tint\t\t\tramsize;\n};\n\nstatic void __cg14_reset(struct cg14_par *par)\n{\n\tstruct cg14_regs __iomem *regs = par->regs;\n\tu8 val;\n\n\tval = sbus_readb(&regs->mcr);\n\tval &= ~(CG14_MCR_PIXMODE_MASK);\n\tsbus_writeb(val, &regs->mcr);\n}\n\nstatic int cg14_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct cg14_par *par = (struct cg14_par *) info->par;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&par->lock, flags);\n\t__cg14_reset(par);\n\tspin_unlock_irqrestore(&par->lock, flags);\n\n\tif (var->xoffset || var->yoffset || var->vmode)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int cg14_setcolreg(unsigned regno,\n\t\t\t  unsigned red, unsigned green, unsigned blue,\n\t\t\t  unsigned transp, struct fb_info *info)\n{\n\tstruct cg14_par *par = (struct cg14_par *) info->par;\n\tstruct cg14_clut __iomem *clut = par->clut;\n\tunsigned long flags;\n\tu32 val;\n\n\tif (regno >= 256)\n\t\treturn 1;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\tval = (red | (green << 8) | (blue << 16));\n\n\tspin_lock_irqsave(&par->lock, flags);\n\tsbus_writel(val, &clut->c_clut[regno]);\n\tspin_unlock_irqrestore(&par->lock, flags);\n\n\treturn 0;\n}\n\nstatic int cg14_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct cg14_par *par = (struct cg14_par *) info->par;\n\n\treturn sbusfb_mmap_helper(par->mmap_map,\n\t\t\t\t  info->fix.smem_start, info->fix.smem_len,\n\t\t\t\t  par->iospace, vma);\n}\n\nstatic int cg14_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\n{\n\tstruct cg14_par *par = (struct cg14_par *) info->par;\n\tstruct cg14_regs __iomem *regs = par->regs;\n\tstruct mdi_cfginfo kmdi, __user *mdii;\n\tunsigned long flags;\n\tint cur_mode, mode, ret = 0;\n\n\tswitch (cmd) {\n\tcase MDI_RESET:\n\t\tspin_lock_irqsave(&par->lock, flags);\n\t\t__cg14_reset(par);\n\t\tspin_unlock_irqrestore(&par->lock, flags);\n\t\tbreak;\n\n\tcase MDI_GET_CFGINFO:\n\t\tmemset(&kmdi, 0, sizeof(kmdi));\n\n\t\tspin_lock_irqsave(&par->lock, flags);\n\t\tkmdi.mdi_type = FBTYPE_MDICOLOR;\n\t\tkmdi.mdi_height = info->var.yres;\n\t\tkmdi.mdi_width = info->var.xres;\n\t\tkmdi.mdi_mode = par->mode;\n\t\tkmdi.mdi_pixfreq = 72;  \n\t\tkmdi.mdi_size = par->ramsize;\n\t\tspin_unlock_irqrestore(&par->lock, flags);\n\n\t\tmdii = (struct mdi_cfginfo __user *) arg;\n\t\tif (copy_to_user(mdii, &kmdi, sizeof(kmdi)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase MDI_SET_PIXELMODE:\n\t\tif (get_user(mode, (int __user *) arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock_irqsave(&par->lock, flags);\n\t\tcur_mode = sbus_readb(&regs->mcr);\n\t\tcur_mode &= ~CG14_MCR_PIXMODE_MASK;\n\t\tswitch(mode) {\n\t\tcase MDI_32_PIX:\n\t\t\tcur_mode |= (CG14_MCR_PIXMODE_32 <<\n\t\t\t\t     CG14_MCR_PIXMODE_SHIFT);\n\t\t\tbreak;\n\n\t\tcase MDI_16_PIX:\n\t\t\tcur_mode |= (CG14_MCR_PIXMODE_16 <<\n\t\t\t\t     CG14_MCR_PIXMODE_SHIFT);\n\t\t\tbreak;\n\n\t\tcase MDI_8_PIX:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -ENOSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ret) {\n\t\t\tsbus_writeb(cur_mode, &regs->mcr);\n\t\t\tpar->mode = mode;\n\t\t}\n\t\tspin_unlock_irqrestore(&par->lock, flags);\n\t\tbreak;\n\n\tdefault:\n\t\tret = sbusfb_ioctl_helper(cmd, arg, info,\n\t\t\t\t\t  FBTYPE_MDICOLOR, 8,\n\t\t\t\t\t  info->fix.smem_len);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic void cg14_init_fix(struct fb_info *info, int linebytes,\n\t\t\t  struct device_node *dp)\n{\n\tsnprintf(info->fix.id, sizeof(info->fix.id), \"%pOFn\", dp);\n\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\n\tinfo->fix.line_length = linebytes;\n\n\tinfo->fix.accel = FB_ACCEL_SUN_CG14;\n}\n\nstatic struct sbus_mmap_map __cg14_mmap_map[CG14_MMAP_ENTRIES] = {\n\t{\n\t\t.voff\t= CG14_REGS,\n\t\t.poff\t= 0x80000000,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= CG14_XLUT,\n\t\t.poff\t= 0x80003000,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= CG14_CLUT1,\n\t\t.poff\t= 0x80004000,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= CG14_CLUT2,\n\t\t.poff\t= 0x80005000,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= CG14_CLUT3,\n\t\t.poff\t= 0x80006000,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= CG3_MMAP_OFFSET - 0x7000,\n\t\t.poff\t= 0x80000000,\n\t\t.size\t= 0x7000\n\t},\n\t{\n\t\t.voff\t= CG3_MMAP_OFFSET,\n\t\t.poff\t= 0x00000000,\n\t\t.size\t= SBUS_MMAP_FBSIZE(1)\n\t},\n\t{\n\t\t.voff\t= MDI_CURSOR_MAP,\n\t\t.poff\t= 0x80001000,\n\t\t.size\t= 0x1000\n\t},\n\t{\n\t\t.voff\t= MDI_CHUNKY_BGR_MAP,\n\t\t.poff\t= 0x01000000,\n\t\t.size\t= 0x400000\n\t},\n\t{\n\t\t.voff\t= MDI_PLANAR_X16_MAP,\n\t\t.poff\t= 0x02000000,\n\t\t.size\t= 0x200000\n\t},\n\t{\n\t\t.voff\t= MDI_PLANAR_C16_MAP,\n\t\t.poff\t= 0x02800000,\n\t\t.size\t= 0x200000\n\t},\n\t{\n\t\t.voff\t= MDI_PLANAR_X32_MAP,\n\t\t.poff\t= 0x03000000,\n\t\t.size\t= 0x100000\n\t},\n\t{\n\t\t.voff\t= MDI_PLANAR_B32_MAP,\n\t\t.poff\t= 0x03400000,\n\t\t.size\t= 0x100000\n\t},\n\t{\n\t\t.voff\t= MDI_PLANAR_G32_MAP,\n\t\t.poff\t= 0x03800000,\n\t\t.size\t= 0x100000\n\t},\n\t{\n\t\t.voff\t= MDI_PLANAR_R32_MAP,\n\t\t.poff\t= 0x03c00000,\n\t\t.size\t= 0x100000\n\t},\n\t{ .size = 0 }\n};\n\nstatic void cg14_unmap_regs(struct platform_device *op, struct fb_info *info,\n\t\t\t    struct cg14_par *par)\n{\n\tif (par->regs)\n\t\tof_iounmap(&op->resource[0],\n\t\t\t   par->regs, sizeof(struct cg14_regs));\n\tif (par->clut)\n\t\tof_iounmap(&op->resource[0],\n\t\t\t   par->clut, sizeof(struct cg14_clut));\n\tif (par->cursor)\n\t\tof_iounmap(&op->resource[0],\n\t\t\t   par->cursor, sizeof(struct cg14_cursor));\n\tif (info->screen_base)\n\t\tof_iounmap(&op->resource[1],\n\t\t\t   info->screen_base, info->fix.smem_len);\n}\n\nstatic int cg14_probe(struct platform_device *op)\n{\n\tstruct device_node *dp = op->dev.of_node;\n\tstruct fb_info *info;\n\tstruct cg14_par *par;\n\tint is_8mb, linebytes, i, err;\n\n\tinfo = framebuffer_alloc(sizeof(struct cg14_par), &op->dev);\n\n\terr = -ENOMEM;\n\tif (!info)\n\t\tgoto out_err;\n\tpar = info->par;\n\n\tspin_lock_init(&par->lock);\n\n\tsbusfb_fill_var(&info->var, dp, 8);\n\tinfo->var.red.length = 8;\n\tinfo->var.green.length = 8;\n\tinfo->var.blue.length = 8;\n\n\tlinebytes = of_getintprop_default(dp, \"linebytes\",\n\t\t\t\t\t  info->var.xres);\n\tinfo->fix.smem_len = PAGE_ALIGN(linebytes * info->var.yres);\n\n\tif (of_node_name_eq(dp->parent, \"sbus\") ||\n\t    of_node_name_eq(dp->parent, \"sbi\")) {\n\t\tinfo->fix.smem_start = op->resource[0].start;\n\t\tpar->iospace = op->resource[0].flags & IORESOURCE_BITS;\n\t} else {\n\t\tinfo->fix.smem_start = op->resource[1].start;\n\t\tpar->iospace = op->resource[0].flags & IORESOURCE_BITS;\n\t}\n\n\tpar->regs = of_ioremap(&op->resource[0], 0,\n\t\t\t       sizeof(struct cg14_regs), \"cg14 regs\");\n\tpar->clut = of_ioremap(&op->resource[0], CG14_CLUT1,\n\t\t\t       sizeof(struct cg14_clut), \"cg14 clut\");\n\tpar->cursor = of_ioremap(&op->resource[0], CG14_CURSORREGS,\n\t\t\t\t sizeof(struct cg14_cursor), \"cg14 cursor\");\n\n\tinfo->screen_base = of_ioremap(&op->resource[1], 0,\n\t\t\t\t       info->fix.smem_len, \"cg14 ram\");\n\n\tif (!par->regs || !par->clut || !par->cursor || !info->screen_base)\n\t\tgoto out_unmap_regs;\n\n\tis_8mb = (resource_size(&op->resource[1]) == (8 * 1024 * 1024));\n\n\tBUILD_BUG_ON(sizeof(par->mmap_map) != sizeof(__cg14_mmap_map));\n\n\tmemcpy(&par->mmap_map, &__cg14_mmap_map, sizeof(par->mmap_map));\n\n\tfor (i = 0; i < CG14_MMAP_ENTRIES; i++) {\n\t\tstruct sbus_mmap_map *map = &par->mmap_map[i];\n\n\t\tif (!map->size)\n\t\t\tbreak;\n\t\tif (map->poff & 0x80000000)\n\t\t\tmap->poff = (map->poff & 0x7fffffff) +\n\t\t\t\t(op->resource[0].start -\n\t\t\t\t op->resource[1].start);\n\t\tif (is_8mb &&\n\t\t    map->size >= 0x100000 &&\n\t\t    map->size <= 0x400000)\n\t\t\tmap->size *= 2;\n\t}\n\n\tpar->mode = MDI_8_PIX;\n\tpar->ramsize = (is_8mb ? 0x800000 : 0x400000);\n\n\tinfo->flags = FBINFO_HWACCEL_YPAN;\n\tinfo->fbops = &cg14_ops;\n\n\t__cg14_reset(par);\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0))\n\t\tgoto out_unmap_regs;\n\n\tfb_set_cmap(&info->cmap, info);\n\n\tcg14_init_fix(info, linebytes, dp);\n\n\terr = register_framebuffer(info);\n\tif (err < 0)\n\t\tgoto out_dealloc_cmap;\n\n\tdev_set_drvdata(&op->dev, info);\n\n\tprintk(KERN_INFO \"%pOF: cgfourteen at %lx:%lx, %dMB\\n\",\n\t       dp,\n\t       par->iospace, info->fix.smem_start,\n\t       par->ramsize >> 20);\n\n\treturn 0;\n\nout_dealloc_cmap:\n\tfb_dealloc_cmap(&info->cmap);\n\nout_unmap_regs:\n\tcg14_unmap_regs(op, info, par);\n\tframebuffer_release(info);\n\nout_err:\n\treturn err;\n}\n\nstatic void cg14_remove(struct platform_device *op)\n{\n\tstruct fb_info *info = dev_get_drvdata(&op->dev);\n\tstruct cg14_par *par = info->par;\n\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\n\tcg14_unmap_regs(op, info, par);\n\n\tframebuffer_release(info);\n}\n\nstatic const struct of_device_id cg14_match[] = {\n\t{\n\t\t.name = \"cgfourteen\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cg14_match);\n\nstatic struct platform_driver cg14_driver = {\n\t.driver = {\n\t\t.name = \"cg14\",\n\t\t.of_match_table = cg14_match,\n\t},\n\t.probe\t\t= cg14_probe,\n\t.remove_new\t= cg14_remove,\n};\n\nstatic int __init cg14_init(void)\n{\n\tif (fb_get_options(\"cg14fb\", NULL))\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&cg14_driver);\n}\n\nstatic void __exit cg14_exit(void)\n{\n\tplatform_driver_unregister(&cg14_driver);\n}\n\nmodule_init(cg14_init);\nmodule_exit(cg14_exit);\n\nMODULE_DESCRIPTION(\"framebuffer driver for CGfourteen chipsets\");\nMODULE_AUTHOR(\"David S. Miller <davem@davemloft.net>\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}