{
  "module_name": "ep93xx-fb.c",
  "hash_id": "26ee0015f467377575fd334afe2b3be748aff1d4624d56b280d0a649530d1c90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/ep93xx-fb.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/fb.h>\n#include <linux/io.h>\n\n#include <linux/platform_data/video-ep93xx.h>\n\n \n#define EP93XXFB_VLINES_TOTAL\t\t\t0x0000\t \n#define EP93XXFB_VSYNC\t\t\t\t0x0004\t \n#define EP93XXFB_VACTIVE\t\t\t0x0008\t \n#define EP93XXFB_VBLANK\t\t\t\t0x0228\t \n#define EP93XXFB_VCLK\t\t\t\t0x000c\t \n\n \n#define EP93XXFB_HCLKS_TOTAL\t\t\t0x0010\t \n#define EP93XXFB_HSYNC\t\t\t\t0x0014\t \n#define EP93XXFB_HACTIVE\t\t\t0x0018\t \n#define EP93XXFB_HBLANK\t\t\t\t0x022c\t \n#define EP93XXFB_HCLK\t\t\t\t0x001c\t \n\n \n#define EP93XXFB_SCREEN_PAGE\t\t\t0x0028\n#define EP93XXFB_SCREEN_HPAGE\t\t\t0x002c\n#define EP93XXFB_SCREEN_LINES\t\t\t0x0030\n#define EP93XXFB_LINE_LENGTH\t\t\t0x0034\n#define EP93XXFB_VLINE_STEP\t\t\t0x0038\n#define EP93XXFB_LINE_CARRY\t\t\t0x003c\t \n#define EP93XXFB_EOL_OFFSET\t\t\t0x0230\n\n \n#define EP93XXFB_BRIGHTNESS\t\t\t0x0020\n#define EP93XXFB_ATTRIBS\t\t\t0x0024\t \n#define EP93XXFB_SWLOCK\t\t\t\t0x007c\t \n#define EP93XXFB_AC_RATE\t\t\t0x0214\n#define EP93XXFB_FIFO_LEVEL\t\t\t0x0234\n#define EP93XXFB_PIXELMODE\t\t\t0x0054\n#define EP93XXFB_PIXELMODE_32BPP\t\t(0x7 << 0)\n#define EP93XXFB_PIXELMODE_24BPP\t\t(0x6 << 0)\n#define EP93XXFB_PIXELMODE_16BPP\t\t(0x4 << 0)\n#define EP93XXFB_PIXELMODE_8BPP\t\t\t(0x2 << 0)\n#define EP93XXFB_PIXELMODE_SHIFT_1P_24B\t\t(0x0 << 3)\n#define EP93XXFB_PIXELMODE_SHIFT_1P_18B\t\t(0x1 << 3)\n#define EP93XXFB_PIXELMODE_COLOR_LUT\t\t(0x0 << 10)\n#define EP93XXFB_PIXELMODE_COLOR_888\t\t(0x4 << 10)\n#define EP93XXFB_PIXELMODE_COLOR_555\t\t(0x5 << 10)\n#define EP93XXFB_PARL_IF_OUT\t\t\t0x0058\n#define EP93XXFB_PARL_IF_IN\t\t\t0x005c\n\n \n#define EP93XXFB_BLINK_RATE\t\t\t0x0040\n#define EP93XXFB_BLINK_MASK\t\t\t0x0044\n#define EP93XXFB_BLINK_PATTRN\t\t\t0x0048\n#define EP93XXFB_PATTRN_MASK\t\t\t0x004c\n#define EP93XXFB_BKGRND_OFFSET\t\t\t0x0050\n\n \n#define EP93XXFB_CURSOR_ADR_START\t\t0x0060\n#define EP93XXFB_CURSOR_ADR_RESET\t\t0x0064\n#define EP93XXFB_CURSOR_SIZE\t\t\t0x0068\n#define EP93XXFB_CURSOR_COLOR1\t\t\t0x006c\n#define EP93XXFB_CURSOR_COLOR2\t\t\t0x0070\n#define EP93XXFB_CURSOR_BLINK_COLOR1\t\t0x021c\n#define EP93XXFB_CURSOR_BLINK_COLOR2\t\t0x0220\n#define EP93XXFB_CURSOR_XY_LOC\t\t\t0x0074\n#define EP93XXFB_CURSOR_DSCAN_HY_LOC\t\t0x0078\n#define EP93XXFB_CURSOR_BLINK_RATE_CTRL\t\t0x0224\n\n \n#define EP93XXFB_GRY_SCL_LUTR\t\t\t0x0080\n#define EP93XXFB_GRY_SCL_LUTG\t\t\t0x0280\n#define EP93XXFB_GRY_SCL_LUTB\t\t\t0x0300\n#define EP93XXFB_LUT_SW_CONTROL\t\t\t0x0218\n#define EP93XXFB_LUT_SW_CONTROL_SWTCH\t\t(1 << 0)\n#define EP93XXFB_LUT_SW_CONTROL_SSTAT\t\t(1 << 1)\n#define EP93XXFB_COLOR_LUT\t\t\t0x0400\n\n \n#define EP93XXFB_VID_SIG_RSLT_VAL\t\t0x0200\n#define EP93XXFB_VID_SIG_CTRL\t\t\t0x0204\n#define EP93XXFB_VSIG\t\t\t\t0x0208\n#define EP93XXFB_HSIG\t\t\t\t0x020c\n#define EP93XXFB_SIG_CLR_STR\t\t\t0x0210\n\n \n#define EP93XXFB_MIN_XRES\t\t\t64\n#define EP93XXFB_MIN_YRES\t\t\t64\n#define EP93XXFB_MAX_XRES\t\t\t1024\n#define EP93XXFB_MAX_YRES\t\t\t768\n\nstruct ep93xx_fbi {\n\tstruct ep93xxfb_mach_info\t*mach_info;\n\tstruct clk\t\t\t*clk;\n\tstruct resource\t\t\t*res;\n\tvoid __iomem\t\t\t*mmio_base;\n\tunsigned int\t\t\tpseudo_palette[256];\n};\n\nstatic int check_screenpage_bug = 1;\nmodule_param(check_screenpage_bug, int, 0644);\nMODULE_PARM_DESC(check_screenpage_bug,\n\t\t \"Check for bit 27 screen page bug. Default = 1\");\n\nstatic inline unsigned int ep93xxfb_readl(struct ep93xx_fbi *fbi,\n\t\t\t\t\t  unsigned int off)\n{\n\treturn __raw_readl(fbi->mmio_base + off);\n}\n\nstatic inline void ep93xxfb_writel(struct ep93xx_fbi *fbi,\n\t\t\t\t   unsigned int val, unsigned int off)\n{\n\t__raw_writel(val, fbi->mmio_base + off);\n}\n\n \nstatic inline void ep93xxfb_out_locked(struct ep93xx_fbi *fbi,\n\t\t\t\t       unsigned int val, unsigned int reg)\n{\n\t \n\tep93xxfb_writel(fbi, 0xaa, EP93XXFB_SWLOCK);\n\tep93xxfb_writel(fbi, val, reg);\n}\n\nstatic void ep93xxfb_set_video_attribs(struct fb_info *info)\n{\n\tstruct ep93xx_fbi *fbi = info->par;\n\tunsigned int attribs;\n\n\tattribs = EP93XXFB_ENABLE;\n\tattribs |= fbi->mach_info->flags;\n\tep93xxfb_out_locked(fbi, attribs, EP93XXFB_ATTRIBS);\n}\n\nstatic int ep93xxfb_set_pixelmode(struct fb_info *info)\n{\n\tstruct ep93xx_fbi *fbi = info->par;\n\tunsigned int val;\n\n\tinfo->var.transp.offset = 0;\n\tinfo->var.transp.length = 0;\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tval = EP93XXFB_PIXELMODE_8BPP | EP93XXFB_PIXELMODE_COLOR_LUT |\n\t\t\tEP93XXFB_PIXELMODE_SHIFT_1P_18B;\n\n\t\tinfo->var.red.offset\t= 0;\n\t\tinfo->var.red.length\t= 8;\n\t\tinfo->var.green.offset\t= 0;\n\t\tinfo->var.green.length\t= 8;\n\t\tinfo->var.blue.offset\t= 0;\n\t\tinfo->var.blue.length\t= 8;\n\t\tinfo->fix.visual \t= FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\n\tcase 16:\n\t\tval = EP93XXFB_PIXELMODE_16BPP | EP93XXFB_PIXELMODE_COLOR_555 |\n\t\t\tEP93XXFB_PIXELMODE_SHIFT_1P_18B;\n\n\t\tinfo->var.red.offset\t= 11;\n\t\tinfo->var.red.length\t= 5;\n\t\tinfo->var.green.offset\t= 5;\n\t\tinfo->var.green.length\t= 6;\n\t\tinfo->var.blue.offset\t= 0;\n\t\tinfo->var.blue.length\t= 5;\n\t\tinfo->fix.visual \t= FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\n\tcase 24:\n\t\tval = EP93XXFB_PIXELMODE_24BPP | EP93XXFB_PIXELMODE_COLOR_888 |\n\t\t\tEP93XXFB_PIXELMODE_SHIFT_1P_24B;\n\n\t\tinfo->var.red.offset\t= 16;\n\t\tinfo->var.red.length\t= 8;\n\t\tinfo->var.green.offset\t= 8;\n\t\tinfo->var.green.length\t= 8;\n\t\tinfo->var.blue.offset\t= 0;\n\t\tinfo->var.blue.length\t= 8;\n\t\tinfo->fix.visual \t= FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\n\tcase 32:\n\t\tval = EP93XXFB_PIXELMODE_32BPP | EP93XXFB_PIXELMODE_COLOR_888 |\n\t\t\tEP93XXFB_PIXELMODE_SHIFT_1P_24B;\n\n\t\tinfo->var.red.offset\t= 16;\n\t\tinfo->var.red.length\t= 8;\n\t\tinfo->var.green.offset\t= 8;\n\t\tinfo->var.green.length\t= 8;\n\t\tinfo->var.blue.offset\t= 0;\n\t\tinfo->var.blue.length\t= 8;\n\t\tinfo->fix.visual \t= FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tep93xxfb_writel(fbi, val, EP93XXFB_PIXELMODE);\n\treturn 0;\n}\n\nstatic void ep93xxfb_set_timing(struct fb_info *info)\n{\n\tstruct ep93xx_fbi *fbi = info->par;\n\tunsigned int vlines_total, hclks_total, start, stop;\n\n\tvlines_total = info->var.yres + info->var.upper_margin +\n\t\tinfo->var.lower_margin + info->var.vsync_len - 1;\n\n\thclks_total = info->var.xres + info->var.left_margin +\n\t\tinfo->var.right_margin + info->var.hsync_len - 1;\n\n\tep93xxfb_out_locked(fbi, vlines_total, EP93XXFB_VLINES_TOTAL);\n\tep93xxfb_out_locked(fbi, hclks_total, EP93XXFB_HCLKS_TOTAL);\n\n\tstart = vlines_total;\n\tstop = vlines_total - info->var.vsync_len;\n\tep93xxfb_out_locked(fbi, start | (stop << 16), EP93XXFB_VSYNC);\n\n\tstart = vlines_total - info->var.vsync_len - info->var.upper_margin;\n\tstop = info->var.lower_margin - 1;\n\tep93xxfb_out_locked(fbi, start | (stop << 16), EP93XXFB_VBLANK);\n\tep93xxfb_out_locked(fbi, start | (stop << 16), EP93XXFB_VACTIVE);\n\n\tstart = vlines_total;\n\tstop = vlines_total + 1;\n\tep93xxfb_out_locked(fbi, start | (stop << 16), EP93XXFB_VCLK);\n\n\tstart = hclks_total;\n\tstop = hclks_total - info->var.hsync_len;\n\tep93xxfb_out_locked(fbi, start | (stop << 16), EP93XXFB_HSYNC);\n\n\tstart = hclks_total - info->var.hsync_len - info->var.left_margin;\n\tstop = info->var.right_margin - 1;\n\tep93xxfb_out_locked(fbi, start | (stop << 16), EP93XXFB_HBLANK);\n\tep93xxfb_out_locked(fbi, start | (stop << 16), EP93XXFB_HACTIVE);\n\n\tstart = hclks_total;\n\tstop = hclks_total;\n\tep93xxfb_out_locked(fbi, start | (stop << 16), EP93XXFB_HCLK);\n\n\tep93xxfb_out_locked(fbi, 0x0, EP93XXFB_LINE_CARRY);\n}\n\nstatic int ep93xxfb_set_par(struct fb_info *info)\n{\n\tstruct ep93xx_fbi *fbi = info->par;\n\n\tclk_set_rate(fbi->clk, 1000 * PICOS2KHZ(info->var.pixclock));\n\n\tep93xxfb_set_timing(info);\n\n\tinfo->fix.line_length = info->var.xres_virtual *\n\t\tinfo->var.bits_per_pixel / 8;\n\n\tep93xxfb_writel(fbi, info->fix.smem_start, EP93XXFB_SCREEN_PAGE);\n\tep93xxfb_writel(fbi, info->var.yres - 1, EP93XXFB_SCREEN_LINES);\n\tep93xxfb_writel(fbi, ((info->var.xres * info->var.bits_per_pixel)\n\t\t\t      / 32) - 1, EP93XXFB_LINE_LENGTH);\n\tep93xxfb_writel(fbi, info->fix.line_length / 4, EP93XXFB_VLINE_STEP);\n\tep93xxfb_set_video_attribs(info);\n\treturn 0;\n}\n\nstatic int ep93xxfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tint err;\n\n\terr = ep93xxfb_set_pixelmode(info);\n\tif (err)\n\t\treturn err;\n\n\tvar->xres = max_t(unsigned int, var->xres, EP93XXFB_MIN_XRES);\n\tvar->xres = min_t(unsigned int, var->xres, EP93XXFB_MAX_XRES);\n\tvar->xres_virtual = max(var->xres_virtual, var->xres);\n\n\tvar->yres = max_t(unsigned int, var->yres, EP93XXFB_MIN_YRES);\n\tvar->yres = min_t(unsigned int, var->yres, EP93XXFB_MAX_YRES);\n\tvar->yres_virtual = max(var->yres_virtual, var->yres);\n\n\treturn 0;\n}\n\nstatic int ep93xxfb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tunsigned int offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (offset < info->fix.smem_len) {\n\t\treturn dma_mmap_wc(info->device, vma, info->screen_base,\n\t\t\t\t   info->fix.smem_start, info->fix.smem_len);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ep93xxfb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct ep93xx_fbi *fbi = info->par;\n\tunsigned int attribs = ep93xxfb_readl(fbi, EP93XXFB_ATTRIBS);\n\n\tif (blank_mode) {\n\t\tif (fbi->mach_info->blank)\n\t\t\tfbi->mach_info->blank(blank_mode, info);\n\t\tep93xxfb_out_locked(fbi, attribs & ~EP93XXFB_ENABLE,\n\t\t\t\t    EP93XXFB_ATTRIBS);\n\t\tclk_disable(fbi->clk);\n\t} else {\n\t\tclk_enable(fbi->clk);\n\t\tep93xxfb_out_locked(fbi, attribs | EP93XXFB_ENABLE,\n\t\t\t\t    EP93XXFB_ATTRIBS);\n\t\tif (fbi->mach_info->blank)\n\t\t\tfbi->mach_info->blank(blank_mode, info);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int ep93xxfb_convert_color(int val, int width)\n{\n\treturn ((val << width) + 0x7fff - val) >> 16;\n}\n\nstatic int ep93xxfb_setcolreg(unsigned int regno, unsigned int red,\n\t\t\t      unsigned int green, unsigned int blue,\n\t\t\t      unsigned int transp, struct fb_info *info)\n{\n\tstruct ep93xx_fbi *fbi = info->par;\n\tunsigned int *pal = info->pseudo_palette;\n\tunsigned int ctrl, i, rgb, lut_current, lut_stat;\n\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tif (regno > 255)\n\t\t\treturn 1;\n\t\trgb = ((red & 0xff00) << 8) | (green & 0xff00) |\n\t\t\t((blue & 0xff00) >> 8);\n\n\t\tpal[regno] = rgb;\n\t\tep93xxfb_writel(fbi, rgb, (EP93XXFB_COLOR_LUT + (regno << 2)));\n\t\tctrl = ep93xxfb_readl(fbi, EP93XXFB_LUT_SW_CONTROL);\n\t\tlut_stat = !!(ctrl & EP93XXFB_LUT_SW_CONTROL_SSTAT);\n\t\tlut_current = !!(ctrl & EP93XXFB_LUT_SW_CONTROL_SWTCH);\n\n\t\tif (lut_stat == lut_current) {\n\t\t\tfor (i = 0; i < 256; i++) {\n\t\t\t\tep93xxfb_writel(fbi, pal[i],\n\t\t\t\t\tEP93XXFB_COLOR_LUT + (i << 2));\n\t\t\t}\n\n\t\t\tep93xxfb_writel(fbi,\n\t\t\t\t\tctrl ^ EP93XXFB_LUT_SW_CONTROL_SWTCH,\n\t\t\t\t\tEP93XXFB_LUT_SW_CONTROL);\n\t\t}\n\t\tbreak;\n\n\tcase FB_VISUAL_TRUECOLOR:\n\t\tif (regno > 16)\n\t\t\treturn 1;\n\n\t\tred = ep93xxfb_convert_color(red, info->var.red.length);\n\t\tgreen = ep93xxfb_convert_color(green, info->var.green.length);\n\t\tblue = ep93xxfb_convert_color(blue, info->var.blue.length);\n\t\ttransp = ep93xxfb_convert_color(transp,\n\t\t\t\t\t\tinfo->var.transp.length);\n\n\t\tpal[regno] = (red << info->var.red.offset) |\n\t\t\t(green << info->var.green.offset) |\n\t\t\t(blue << info->var.blue.offset) |\n\t\t\t(transp << info->var.transp.offset);\n\t\tbreak;\n\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct fb_ops ep93xxfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= ep93xxfb_check_var,\n\t.fb_set_par\t= ep93xxfb_set_par,\n\t.fb_blank\t= ep93xxfb_blank,\n\t.fb_fillrect\t= cfb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n\t.fb_setcolreg\t= ep93xxfb_setcolreg,\n\t.fb_mmap\t= ep93xxfb_mmap,\n};\n\nstatic int ep93xxfb_alloc_videomem(struct fb_info *info)\n{\n\tchar __iomem *virt_addr;\n\tdma_addr_t phys_addr;\n\tunsigned int fb_size;\n\n\t \n\tfb_size = EP93XXFB_MAX_XRES * EP93XXFB_MAX_YRES * 2;\n\n\tvirt_addr = dma_alloc_wc(info->device, fb_size, &phys_addr, GFP_KERNEL);\n\tif (!virt_addr)\n\t\treturn -ENOMEM;\n\n\t \n\tif (check_screenpage_bug && phys_addr & (1 << 27)) {\n\t\tfb_err(info, \"ep93xx framebuffer bug. phys addr (0x%x) \"\n\t\t       \"has bit 27 set: cannot init framebuffer\\n\",\n\t\t       phys_addr);\n\n\t\tdma_free_coherent(info->device, fb_size, virt_addr, phys_addr);\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo->fix.smem_start = phys_addr;\n\tinfo->fix.smem_len = fb_size;\n\tinfo->screen_base = virt_addr;\n\n\treturn 0;\n}\n\nstatic void ep93xxfb_dealloc_videomem(struct fb_info *info)\n{\n\tif (info->screen_base)\n\t\tdma_free_coherent(info->device, info->fix.smem_len,\n\t\t\t\t  info->screen_base, info->fix.smem_start);\n}\n\nstatic int ep93xxfb_probe(struct platform_device *pdev)\n{\n\tstruct ep93xxfb_mach_info *mach_info = dev_get_platdata(&pdev->dev);\n\tstruct fb_info *info;\n\tstruct ep93xx_fbi *fbi;\n\tstruct resource *res;\n\tchar *video_mode;\n\tint err;\n\n\tif (!mach_info)\n\t\treturn -EINVAL;\n\n\tinfo = framebuffer_alloc(sizeof(struct ep93xx_fbi), &pdev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, info);\n\tfbi = info->par;\n\tfbi->mach_info = mach_info;\n\n\terr = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (err)\n\t\tgoto failed_cmap;\n\n\terr = ep93xxfb_alloc_videomem(info);\n\tif (err)\n\t\tgoto failed_videomem;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\terr = -ENXIO;\n\t\tgoto failed_resource;\n\t}\n\n\t \n\tfbi->res = res;\n\tfbi->mmio_base = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t      resource_size(res));\n\tif (!fbi->mmio_base) {\n\t\terr = -ENXIO;\n\t\tgoto failed_resource;\n\t}\n\n\tstrcpy(info->fix.id, pdev->name);\n\tinfo->fbops\t\t= &ep93xxfb_ops;\n\tinfo->fix.type\t\t= FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.accel\t\t= FB_ACCEL_NONE;\n\tinfo->var.activate\t= FB_ACTIVATE_NOW;\n\tinfo->var.vmode\t\t= FB_VMODE_NONINTERLACED;\n\tinfo->node\t\t= -1;\n\tinfo->state\t\t= FBINFO_STATE_RUNNING;\n\tinfo->pseudo_palette\t= &fbi->pseudo_palette;\n\n\tfb_get_options(\"ep93xx-fb\", &video_mode);\n\terr = fb_find_mode(&info->var, info, video_mode,\n\t\t\t   NULL, 0, NULL, 16);\n\tif (err == 0) {\n\t\tfb_err(info, \"No suitable video mode found\\n\");\n\t\terr = -EINVAL;\n\t\tgoto failed_resource;\n\t}\n\n\tif (mach_info->setup) {\n\t\terr = mach_info->setup(pdev);\n\t\tif (err)\n\t\t\tgoto failed_resource;\n\t}\n\n\terr = ep93xxfb_check_var(&info->var, info);\n\tif (err)\n\t\tgoto failed_check;\n\n\tfbi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(fbi->clk)) {\n\t\terr = PTR_ERR(fbi->clk);\n\t\tfbi->clk = NULL;\n\t\tgoto failed_check;\n\t}\n\n\tep93xxfb_set_par(info);\n\terr = clk_prepare_enable(fbi->clk);\n\tif (err)\n\t\tgoto failed_check;\n\n\terr = register_framebuffer(info);\n\tif (err)\n\t\tgoto failed_framebuffer;\n\n\tfb_info(info, \"registered. Mode = %dx%d-%d\\n\",\n\t\tinfo->var.xres, info->var.yres, info->var.bits_per_pixel);\n\treturn 0;\n\nfailed_framebuffer:\n\tclk_disable_unprepare(fbi->clk);\nfailed_check:\n\tif (fbi->mach_info->teardown)\n\t\tfbi->mach_info->teardown(pdev);\nfailed_resource:\n\tep93xxfb_dealloc_videomem(info);\nfailed_videomem:\n\tfb_dealloc_cmap(&info->cmap);\nfailed_cmap:\n\tkfree(info);\n\n\treturn err;\n}\n\nstatic void ep93xxfb_remove(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\tstruct ep93xx_fbi *fbi = info->par;\n\n\tunregister_framebuffer(info);\n\tclk_disable_unprepare(fbi->clk);\n\tep93xxfb_dealloc_videomem(info);\n\tfb_dealloc_cmap(&info->cmap);\n\n\tif (fbi->mach_info->teardown)\n\t\tfbi->mach_info->teardown(pdev);\n\n\tkfree(info);\n}\n\nstatic struct platform_driver ep93xxfb_driver = {\n\t.probe\t\t= ep93xxfb_probe,\n\t.remove_new\t= ep93xxfb_remove,\n\t.driver = {\n\t\t.name\t= \"ep93xx-fb\",\n\t},\n};\nmodule_platform_driver(ep93xxfb_driver);\n\nMODULE_DESCRIPTION(\"EP93XX Framebuffer Driver\");\nMODULE_ALIAS(\"platform:ep93xx-fb\");\nMODULE_AUTHOR(\"Ryan Mallon, \"\n\t      \"H Hartley Sweeten <hsweeten@visionengravers.com\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}