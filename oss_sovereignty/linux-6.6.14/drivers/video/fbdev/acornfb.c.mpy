{
  "module_name": "acornfb.c",
  "hash_id": "bc5b3db0f80ee0a58c1260f6f71b8db2ae5ba0582fad8ae002b3b786841e942c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/acornfb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fb.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/gfp.h>\n\n#include <mach/hardware.h>\n#include <asm/irq.h>\n#include <asm/mach-types.h>\n\n#include \"acornfb.h\"\n\n \n#define DEFAULT_XRES\t640\n#define DEFAULT_YRES\t480\n#define DEFAULT_BPP\t4\n\n \n#undef DEBUG_MODE_SELECTION\n\n \n#define NR_MONTYPES\t6\nstatic struct fb_monspecs monspecs[NR_MONTYPES] = {\n\t{\t \n\t\t.hfmin\t= 15469,\n\t\t.hfmax\t= 15781,\n\t\t.vfmin\t= 49,\n\t\t.vfmax\t= 51,\n\t}, {\t \n\t\t.hfmin\t= 0,\n\t\t.hfmax\t= 99999,\n\t\t.vfmin\t= 0,\n\t\t.vfmax\t= 199,\n\t}, {\t \n\t\t.hfmin\t= 58608,\n\t\t.hfmax\t= 58608,\n\t\t.vfmin\t= 64,\n\t\t.vfmax\t= 64,\n\t}, {\t \n\t\t.hfmin\t= 30000,\n\t\t.hfmax\t= 70000,\n\t\t.vfmin\t= 60,\n\t\t.vfmax\t= 60,\n\t}, {\t \n\t\t.hfmin\t= 30000,\n\t\t.hfmax\t= 70000,\n\t\t.vfmin\t= 56,\n\t\t.vfmax\t= 75,\n\t}, {\n\t\t.hfmin\t= 30000,\n\t\t.hfmax\t= 70000,\n\t\t.vfmin\t= 60,\n\t\t.vfmax\t= 60,\n\t}\n};\n\nstatic struct fb_info fb_info;\nstatic struct acornfb_par current_par;\nstatic struct vidc_timing current_vidc;\n\nextern unsigned int vram_size;\t \n\n#ifdef HAS_VIDC20\n#include <mach/acornfb.h>\n\n#define MAX_SIZE\t(2*1024*1024)\n\n \nstatic void acornfb_set_timing(struct fb_info *info)\n{\n\tstruct fb_var_screeninfo *var = &info->var;\n\tstruct vidc_timing vidc;\n\tu_int vcr, fsize;\n\tu_int ext_ctl, dat_ctl;\n\tu_int words_per_line;\n\n\tmemset(&vidc, 0, sizeof(vidc));\n\n\tvidc.h_sync_width\t= var->hsync_len - 8;\n\tvidc.h_border_start\t= vidc.h_sync_width + var->left_margin + 8 - 12;\n\tvidc.h_display_start\t= vidc.h_border_start + 12 - 18;\n\tvidc.h_display_end\t= vidc.h_display_start + var->xres;\n\tvidc.h_border_end\t= vidc.h_display_end + 18 - 12;\n\tvidc.h_cycle\t\t= vidc.h_border_end + var->right_margin + 12 - 8;\n\tvidc.h_interlace\t= vidc.h_cycle / 2;\n\tvidc.v_sync_width\t= var->vsync_len - 1;\n\tvidc.v_border_start\t= vidc.v_sync_width + var->upper_margin;\n\tvidc.v_display_start\t= vidc.v_border_start;\n\tvidc.v_display_end\t= vidc.v_display_start + var->yres;\n\tvidc.v_border_end\t= vidc.v_display_end;\n\tvidc.control\t\t= acornfb_default_control();\n\n\tvcr = var->vsync_len + var->upper_margin + var->yres +\n\t      var->lower_margin;\n\n\tif ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\n\t\tvidc.v_cycle = (vcr - 3) / 2;\n\t\tvidc.control |= VIDC20_CTRL_INT;\n\t} else\n\t\tvidc.v_cycle = vcr - 2;\n\n\tswitch (var->bits_per_pixel) {\n\tcase  1: vidc.control |= VIDC20_CTRL_1BPP;\tbreak;\n\tcase  2: vidc.control |= VIDC20_CTRL_2BPP;\tbreak;\n\tcase  4: vidc.control |= VIDC20_CTRL_4BPP;\tbreak;\n\tdefault:\n\tcase  8: vidc.control |= VIDC20_CTRL_8BPP;\tbreak;\n\tcase 16: vidc.control |= VIDC20_CTRL_16BPP;\tbreak;\n\tcase 32: vidc.control |= VIDC20_CTRL_32BPP;\tbreak;\n\t}\n\n\tacornfb_vidc20_find_rates(&vidc, var);\n\tfsize = var->vsync_len + var->upper_margin + var->lower_margin - 1;\n\n\tif (memcmp(&current_vidc, &vidc, sizeof(vidc))) {\n\t\tcurrent_vidc = vidc;\n\n\t\tvidc_writel(VIDC20_CTRL | vidc.control);\n\t\tvidc_writel(0xd0000000 | vidc.pll_ctl);\n\t\tvidc_writel(0x80000000 | vidc.h_cycle);\n\t\tvidc_writel(0x81000000 | vidc.h_sync_width);\n\t\tvidc_writel(0x82000000 | vidc.h_border_start);\n\t\tvidc_writel(0x83000000 | vidc.h_display_start);\n\t\tvidc_writel(0x84000000 | vidc.h_display_end);\n\t\tvidc_writel(0x85000000 | vidc.h_border_end);\n\t\tvidc_writel(0x86000000);\n\t\tvidc_writel(0x87000000 | vidc.h_interlace);\n\t\tvidc_writel(0x90000000 | vidc.v_cycle);\n\t\tvidc_writel(0x91000000 | vidc.v_sync_width);\n\t\tvidc_writel(0x92000000 | vidc.v_border_start);\n\t\tvidc_writel(0x93000000 | vidc.v_display_start);\n\t\tvidc_writel(0x94000000 | vidc.v_display_end);\n\t\tvidc_writel(0x95000000 | vidc.v_border_end);\n\t\tvidc_writel(0x96000000);\n\t\tvidc_writel(0x97000000);\n\t}\n\n\tiomd_writel(fsize, IOMD_FSIZE);\n\n\text_ctl = acornfb_default_econtrol();\n\n\tif (var->sync & FB_SYNC_COMP_HIGH_ACT)  \n\t\text_ctl |= VIDC20_ECTL_HS_NCSYNC | VIDC20_ECTL_VS_NCSYNC;\n\telse {\n\t\tif (var->sync & FB_SYNC_HOR_HIGH_ACT)\n\t\t\text_ctl |= VIDC20_ECTL_HS_HSYNC;\n\t\telse\n\t\t\text_ctl |= VIDC20_ECTL_HS_NHSYNC;\n\n\t\tif (var->sync & FB_SYNC_VERT_HIGH_ACT)\n\t\t\text_ctl |= VIDC20_ECTL_VS_VSYNC;\n\t\telse\n\t\t\text_ctl |= VIDC20_ECTL_VS_NVSYNC;\n\t}\n\n\tvidc_writel(VIDC20_ECTL | ext_ctl);\n\n\twords_per_line = var->xres * var->bits_per_pixel / 32;\n\n\tif (current_par.using_vram && info->fix.smem_len == 2048*1024)\n\t\twords_per_line /= 2;\n\n\t \n\tdat_ctl = VIDC20_DCTL_VRAM_DIS | VIDC20_DCTL_SNA | words_per_line;\n\n\t \n\tif (current_par.using_vram && current_par.vram_half_sam == 2048)\n\t\tdat_ctl |= VIDC20_DCTL_BUS_D63_0;\n\telse\n\t\tdat_ctl |= VIDC20_DCTL_BUS_D31_0;\n\n\tvidc_writel(VIDC20_DCTL | dat_ctl);\n\n#ifdef DEBUG_MODE_SELECTION\n\tprintk(KERN_DEBUG \"VIDC registers for %dx%dx%d:\\n\", var->xres,\n\t       var->yres, var->bits_per_pixel);\n\tprintk(KERN_DEBUG \" H-cycle          : %d\\n\", vidc.h_cycle);\n\tprintk(KERN_DEBUG \" H-sync-width     : %d\\n\", vidc.h_sync_width);\n\tprintk(KERN_DEBUG \" H-border-start   : %d\\n\", vidc.h_border_start);\n\tprintk(KERN_DEBUG \" H-display-start  : %d\\n\", vidc.h_display_start);\n\tprintk(KERN_DEBUG \" H-display-end    : %d\\n\", vidc.h_display_end);\n\tprintk(KERN_DEBUG \" H-border-end     : %d\\n\", vidc.h_border_end);\n\tprintk(KERN_DEBUG \" H-interlace      : %d\\n\", vidc.h_interlace);\n\tprintk(KERN_DEBUG \" V-cycle          : %d\\n\", vidc.v_cycle);\n\tprintk(KERN_DEBUG \" V-sync-width     : %d\\n\", vidc.v_sync_width);\n\tprintk(KERN_DEBUG \" V-border-start   : %d\\n\", vidc.v_border_start);\n\tprintk(KERN_DEBUG \" V-display-start  : %d\\n\", vidc.v_display_start);\n\tprintk(KERN_DEBUG \" V-display-end    : %d\\n\", vidc.v_display_end);\n\tprintk(KERN_DEBUG \" V-border-end     : %d\\n\", vidc.v_border_end);\n\tprintk(KERN_DEBUG \" Ext Ctrl  (C)    : 0x%08X\\n\", ext_ctl);\n\tprintk(KERN_DEBUG \" PLL Ctrl  (D)    : 0x%08X\\n\", vidc.pll_ctl);\n\tprintk(KERN_DEBUG \" Ctrl      (E)    : 0x%08X\\n\", vidc.control);\n\tprintk(KERN_DEBUG \" Data Ctrl (F)    : 0x%08X\\n\", dat_ctl);\n\tprintk(KERN_DEBUG \" Fsize            : 0x%08X\\n\", fsize);\n#endif\n}\n\n \nstatic int\nacornfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t  u_int trans, struct fb_info *info)\n{\n\tunion palette pal;\n\n\tif (regno >= current_par.palette_size)\n\t\treturn 1;\n\n\tif (regno < 16 && info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\tu32 pseudo_val;\n\n\t\tpseudo_val  = regno << info->var.red.offset;\n\t\tpseudo_val |= regno << info->var.green.offset;\n\t\tpseudo_val |= regno << info->var.blue.offset;\n\n\t\t((u32 *)info->pseudo_palette)[regno] = pseudo_val;\n\t}\n\n\tpal.p = 0;\n\tpal.vidc20.red   = red >> 8;\n\tpal.vidc20.green = green >> 8;\n\tpal.vidc20.blue  = blue >> 8;\n\n\tcurrent_par.palette[regno] = pal;\n\n\tif (info->var.bits_per_pixel == 16) {\n\t\tint i;\n\n\t\tpal.p = 0;\n\t\tvidc_writel(0x10000000);\n\t\tfor (i = 0; i < 256; i += 1) {\n\t\t\tpal.vidc20.red   = current_par.palette[i       & 31].vidc20.red;\n\t\t\tpal.vidc20.green = current_par.palette[(i >> 1) & 31].vidc20.green;\n\t\t\tpal.vidc20.blue  = current_par.palette[(i >> 2) & 31].vidc20.blue;\n\t\t\tvidc_writel(pal.p);\n\t\t\t \n\t\t}\n\t} else {\n\t\tvidc_writel(0x10000000 | regno);\n\t\tvidc_writel(pal.p);\n\t}\n\n\treturn 0;\n}\n#endif\n\n \nstatic int\nacornfb_adjust_timing(struct fb_info *info, struct fb_var_screeninfo *var, u_int fontht)\n{\n\tu_int font_line_len, sam_size, min_size, size, nr_y;\n\n\t \n\tvar->xres = (var->xres + 1) & ~1;\n\n\t \n\tvar->xres_virtual = var->xres;\n\tvar->xoffset = 0;\n\n\tif (current_par.using_vram)\n\t\tsam_size = current_par.vram_half_sam * 2;\n\telse\n\t\tsam_size = 16;\n\n\t \n\tfont_line_len = var->xres * var->bits_per_pixel * fontht / 8;\n\tmin_size = var->xres * var->yres * var->bits_per_pixel / 8;\n\n\t \n\tif (min_size > info->fix.smem_len)\n\t\treturn -EINVAL;\n\n\t \n\tfor (size = info->fix.smem_len;\n\t     nr_y = size / font_line_len, min_size <= size;\n\t     size -= sam_size) {\n\t\tif (nr_y * font_line_len == size)\n\t\t\tbreak;\n\t}\n\tnr_y *= fontht;\n\n\tif (var->accel_flags & FB_ACCELF_TEXT) {\n\t\tif (min_size > size) {\n\t\t\t \n\t\t\tsize = info->fix.smem_len;\n\t\t\tvar->yres_virtual = size / (font_line_len / fontht);\n\t\t} else\n\t\t\tvar->yres_virtual = nr_y;\n\t} else if (var->yres_virtual > nr_y)\n\t\tvar->yres_virtual = nr_y;\n\n\tcurrent_par.screen_end = info->fix.smem_start + size;\n\n\t \n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres = var->yres_virtual;\n\n\tif (var->vmode & FB_VMODE_YWRAP) {\n\t\tif (var->yoffset > var->yres_virtual)\n\t\t\tvar->yoffset = var->yres_virtual;\n\t} else {\n\t\tif (var->yoffset + var->yres > var->yres_virtual)\n\t\t\tvar->yoffset = var->yres_virtual - var->yres;\n\t}\n\n\t \n\tvar->hsync_len = (var->hsync_len + 1) & ~1;\n\n#if defined(HAS_VIDC20)\n\t \n\tif (var->left_margin & 1) {\n\t\tvar->left_margin += 1;\n\t\tvar->right_margin -= 1;\n\t}\n\n\t \n\tif (var->right_margin & 1)\n\t\tvar->right_margin += 1;\n#endif\n\n\tif (var->vsync_len < 1)\n\t\tvar->vsync_len = 1;\n\n\treturn 0;\n}\n\nstatic int\nacornfb_validate_timing(struct fb_var_screeninfo *var,\n\t\t\tstruct fb_monspecs *monspecs)\n{\n\tunsigned long hs, vs;\n\n\t \n\ths = 1953125000 / var->pixclock;\n\ths = hs * 512 /\n\t     (var->xres + var->left_margin + var->right_margin + var->hsync_len);\n\tvs = hs /\n\t     (var->yres + var->upper_margin + var->lower_margin + var->vsync_len);\n\n\treturn (vs >= monspecs->vfmin && vs <= monspecs->vfmax &&\n\t\ths >= monspecs->hfmin && hs <= monspecs->hfmax) ? 0 : -EINVAL;\n}\n\nstatic inline void\nacornfb_update_dma(struct fb_info *info, struct fb_var_screeninfo *var)\n{\n\tu_int off = var->yoffset * info->fix.line_length;\n\n#if defined(HAS_MEMC)\n\tmemc_write(VDMA_INIT, off >> 2);\n#elif defined(HAS_IOMD)\n\tiomd_writel(info->fix.smem_start + off, IOMD_VIDINIT);\n#endif\n}\n\nstatic int\nacornfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tu_int fontht;\n\tint err;\n\n\t \n\tfontht = 8;\n\n\tvar->red.msb_right = 0;\n\tvar->green.msb_right = 0;\n\tvar->blue.msb_right = 0;\n\tvar->transp.msb_right = 0;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 1:\tcase 2:\tcase 4:\tcase 8:\n\t\tvar->red.offset    = 0;\n\t\tvar->red.length    = var->bits_per_pixel;\n\t\tvar->green         = var->red;\n\t\tvar->blue          = var->red;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\n#ifdef HAS_VIDC20\n\tcase 16:\n\t\tvar->red.offset    = 0;\n\t\tvar->red.length    = 5;\n\t\tvar->green.offset  = 5;\n\t\tvar->green.length  = 5;\n\t\tvar->blue.offset   = 10;\n\t\tvar->blue.length   = 5;\n\t\tvar->transp.offset = 15;\n\t\tvar->transp.length = 1;\n\t\tbreak;\n\n\tcase 32:\n\t\tvar->red.offset    = 0;\n\t\tvar->red.length    = 8;\n\t\tvar->green.offset  = 8;\n\t\tvar->green.length  = 8;\n\t\tvar->blue.offset   = 16;\n\t\tvar->blue.length   = 8;\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!acornfb_valid_pixrate(var))\n\t\treturn -EINVAL;\n\n\t \n\terr = acornfb_adjust_timing(info, var, fontht);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn acornfb_validate_timing(var, &info->monspecs);\n}\n\nstatic int acornfb_set_par(struct fb_info *info)\n{\n\tswitch (info->var.bits_per_pixel) {\n\tcase 1:\n\t\tcurrent_par.palette_size = 2;\n\t\tinfo->fix.visual = FB_VISUAL_MONO10;\n\t\tbreak;\n\tcase 2:\n\t\tcurrent_par.palette_size = 4;\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\tcase 4:\n\t\tcurrent_par.palette_size = 16;\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\tcase 8:\n\t\tcurrent_par.palette_size = VIDC_PALETTE_SIZE;\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n#ifdef HAS_VIDC20\n\tcase 16:\n\t\tcurrent_par.palette_size = 32;\n\t\tinfo->fix.visual = FB_VISUAL_DIRECTCOLOR;\n\t\tbreak;\n\tcase 32:\n\t\tcurrent_par.palette_size = VIDC_PALETTE_SIZE;\n\t\tinfo->fix.visual = FB_VISUAL_DIRECTCOLOR;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tBUG();\n\t}\n\n\tinfo->fix.line_length\t= (info->var.xres * info->var.bits_per_pixel) / 8;\n\n#if defined(HAS_MEMC)\n\t{\n\t\tunsigned long size = info->fix.smem_len - VDMA_XFERSIZE;\n\n\t\tmemc_write(VDMA_START, 0);\n\t\tmemc_write(VDMA_END, size >> 2);\n\t}\n#elif defined(HAS_IOMD)\n\t{\n\t\tunsigned long start, size;\n\t\tu_int control;\n\n\t\tstart = info->fix.smem_start;\n\t\tsize  = current_par.screen_end;\n\n\t\tif (current_par.using_vram) {\n\t\t\tsize -= current_par.vram_half_sam;\n\t\t\tcontrol = DMA_CR_E | (current_par.vram_half_sam / 256);\n\t\t} else {\n\t\t\tsize -= 16;\n\t\t\tcontrol = DMA_CR_E | DMA_CR_D | 16;\n\t\t}\n\n\t\tiomd_writel(start,   IOMD_VIDSTART);\n\t\tiomd_writel(size,    IOMD_VIDEND);\n\t\tiomd_writel(control, IOMD_VIDCR);\n\t}\n#endif\n\n\tacornfb_update_dma(info, &info->var);\n\tacornfb_set_timing(info);\n\n\treturn 0;\n}\n\nstatic int\nacornfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tu_int y_bottom = var->yoffset;\n\n\tif (!(var->vmode & FB_VMODE_YWRAP))\n\t\ty_bottom += info->var.yres;\n\n\tif (y_bottom > info->var.yres_virtual)\n\t\treturn -EINVAL;\n\n\tacornfb_update_dma(info, var);\n\n\treturn 0;\n}\n\nstatic const struct fb_ops acornfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= acornfb_check_var,\n\t.fb_set_par\t= acornfb_set_par,\n\t.fb_setcolreg\t= acornfb_setcolreg,\n\t.fb_pan_display\t= acornfb_pan_display,\n};\n\n \nstatic struct fb_videomode modedb[] = {\n\t{\t \n\t\tNULL, 50,  320,  256, 125000,  92,  62,  35, 19,  38, 2,\n\t\tFB_SYNC_COMP_HIGH_ACT,\n\t\tFB_VMODE_NONINTERLACED\n\t}, {\t \n\t\tNULL, 50,  640,  250,  62500, 185, 123,  38, 21,  76, 3,\n\t\t0,\n\t\tFB_VMODE_NONINTERLACED\n\t}, {\t \n\t\tNULL, 50,  640,  256,  62500, 185, 123,  35, 18,  76, 3,\n\t\t0,\n\t\tFB_VMODE_NONINTERLACED\n\t}, {\t \n\t\tNULL, 50,  640,  512,  41667, 113,  87,  18,  1,  56, 3,\n\t\t0,\n\t\tFB_VMODE_NONINTERLACED\n\t}, {\t \n\t\tNULL, 70,  640,  250,  39722,  48,  16, 109, 88,  96, 2,\n\t\t0,\n\t\tFB_VMODE_NONINTERLACED\n\t}, {\t \n\t\tNULL, 70,  640,  256,  39722,  48,  16, 106, 85,  96, 2,\n\t\t0,\n\t\tFB_VMODE_NONINTERLACED\n\t}, {\t \n\t\tNULL, 70,  640,  352,  39722,  48,  16,  58, 37,  96, 2,\n\t\t0,\n\t\tFB_VMODE_NONINTERLACED\n\t}, {\t \n\t\tNULL, 60,  640,  480,  39722,  48,  16,  32, 11,  96, 2,\n\t\t0,\n\t\tFB_VMODE_NONINTERLACED\n\t}, {\t \n\t\tNULL, 56,  800,  600,  27778, 101,  23,  22,  1, 100, 2,\n\t\t0,\n\t\tFB_VMODE_NONINTERLACED\n\t}, {\t \n\t\tNULL, 60,  896,  352,  41667,  59,  27,   9,  0, 118, 3,\n\t\t0,\n\t\tFB_VMODE_NONINTERLACED\n\t}, {\t \n\t\tNULL, 60, 1024,  768,  15385, 160,  24,  29,  3, 136, 6,\n\t\t0,\n\t\tFB_VMODE_NONINTERLACED\n\t}, {\t \n\t\tNULL, 60, 1280, 1024,   9090, 186,  96,  38,  1, 160, 3,\n\t\t0,\n\t\tFB_VMODE_NONINTERLACED\n\t}\n};\n\nstatic struct fb_videomode acornfb_default_mode = {\n\t.name =\t\tNULL,\n\t.refresh =\t60,\n\t.xres =\t\t640,\n\t.yres =\t\t480,\n\t.pixclock =\t39722,\n\t.left_margin =\t56,\n\t.right_margin =\t16,\n\t.upper_margin =\t34,\n\t.lower_margin =\t9,\n\t.hsync_len =\t88,\n\t.vsync_len =\t2,\n\t.sync =\t\t0,\n\t.vmode =\tFB_VMODE_NONINTERLACED\n};\n\nstatic void acornfb_init_fbinfo(void)\n{\n\tstatic int first = 1;\n\n\tif (!first)\n\t\treturn;\n\tfirst = 0;\n\n\tfb_info.fbops\t\t= &acornfb_ops;\n\tfb_info.flags\t\t= FBINFO_HWACCEL_YPAN;\n\tfb_info.pseudo_palette\t= current_par.pseudo_palette;\n\n\tstrcpy(fb_info.fix.id, \"Acorn\");\n\tfb_info.fix.type\t= FB_TYPE_PACKED_PIXELS;\n\tfb_info.fix.type_aux\t= 0;\n\tfb_info.fix.xpanstep\t= 0;\n\tfb_info.fix.ypanstep\t= 1;\n\tfb_info.fix.ywrapstep\t= 1;\n\tfb_info.fix.line_length\t= 0;\n\tfb_info.fix.accel\t= FB_ACCEL_NONE;\n\n\t \n\tmemset(&fb_info.var, 0, sizeof(fb_info.var));\n\n#if defined(HAS_VIDC20)\n\tfb_info.var.red.length\t   = 8;\n\tfb_info.var.transp.length  = 4;\n#endif\n\tfb_info.var.green\t   = fb_info.var.red;\n\tfb_info.var.blue\t   = fb_info.var.red;\n\tfb_info.var.nonstd\t   = 0;\n\tfb_info.var.activate\t   = FB_ACTIVATE_NOW;\n\tfb_info.var.height\t   = -1;\n\tfb_info.var.width\t   = -1;\n\tfb_info.var.vmode\t   = FB_VMODE_NONINTERLACED;\n\tfb_info.var.accel_flags\t   = FB_ACCELF_TEXT;\n\n\tcurrent_par.dram_size\t   = 0;\n\tcurrent_par.montype\t   = -1;\n\tcurrent_par.dpms\t   = 0;\n}\n\n \nstatic void acornfb_parse_mon(char *opt)\n{\n\tchar *p = opt;\n\n\tcurrent_par.montype = -2;\n\n\tfb_info.monspecs.hfmin = simple_strtoul(p, &p, 0);\n\tif (*p == '-')\n\t\tfb_info.monspecs.hfmax = simple_strtoul(p + 1, &p, 0);\n\telse\n\t\tfb_info.monspecs.hfmax = fb_info.monspecs.hfmin;\n\n\tif (*p != ':')\n\t\tgoto bad;\n\n\tfb_info.monspecs.vfmin = simple_strtoul(p + 1, &p, 0);\n\tif (*p == '-')\n\t\tfb_info.monspecs.vfmax = simple_strtoul(p + 1, &p, 0);\n\telse\n\t\tfb_info.monspecs.vfmax = fb_info.monspecs.vfmin;\n\n\tif (*p != ':')\n\t\tgoto check_values;\n\n\tfb_info.monspecs.dpms = simple_strtoul(p + 1, &p, 0);\n\n\tif (*p != ':')\n\t\tgoto check_values;\n\n\tfb_info.var.width = simple_strtoul(p + 1, &p, 0);\n\n\tif (*p != ':')\n\t\tgoto check_values;\n\n\tfb_info.var.height = simple_strtoul(p + 1, NULL, 0);\n\ncheck_values:\n\tif (fb_info.monspecs.hfmax < fb_info.monspecs.hfmin ||\n\t    fb_info.monspecs.vfmax < fb_info.monspecs.vfmin)\n\t\tgoto bad;\n\treturn;\n\nbad:\n\tprintk(KERN_ERR \"Acornfb: bad monitor settings: %s\\n\", opt);\n\tcurrent_par.montype = -1;\n}\n\nstatic void acornfb_parse_montype(char *opt)\n{\n\tcurrent_par.montype = -2;\n\n\tif (strncmp(opt, \"tv\", 2) == 0) {\n\t\topt += 2;\n\t\tcurrent_par.montype = 0;\n\t} else if (strncmp(opt, \"multi\", 5) == 0) {\n\t\topt += 5;\n\t\tcurrent_par.montype = 1;\n\t} else if (strncmp(opt, \"hires\", 5) == 0) {\n\t\topt += 5;\n\t\tcurrent_par.montype = 2;\n\t} else if (strncmp(opt, \"vga\", 3) == 0) {\n\t\topt += 3;\n\t\tcurrent_par.montype = 3;\n\t} else if (strncmp(opt, \"svga\", 4) == 0) {\n\t\topt += 4;\n\t\tcurrent_par.montype = 4;\n\t} else if (strncmp(opt, \"auto\", 4) == 0) {\n\t\topt += 4;\n\t\tcurrent_par.montype = -1;\n\t} else if (isdigit(*opt))\n\t\tcurrent_par.montype = simple_strtoul(opt, &opt, 0);\n\n\tif (current_par.montype == -2 ||\n\t    current_par.montype > NR_MONTYPES) {\n\t\tprintk(KERN_ERR \"acornfb: unknown monitor type: %s\\n\",\n\t\t\topt);\n\t\tcurrent_par.montype = -1;\n\t} else\n\tif (opt && *opt) {\n\t\tif (strcmp(opt, \",dpms\") == 0)\n\t\t\tcurrent_par.dpms = 1;\n\t\telse\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"acornfb: unknown monitor option: %s\\n\",\n\t\t\t       opt);\n\t}\n}\n\nstatic void acornfb_parse_dram(char *opt)\n{\n\tunsigned int size;\n\n\tsize = simple_strtoul(opt, &opt, 0);\n\n\tif (opt) {\n\t\tswitch (*opt) {\n\t\tcase 'M':\n\t\tcase 'm':\n\t\t\tsize *= 1024;\n\t\t\tfallthrough;\n\t\tcase 'K':\n\t\tcase 'k':\n\t\t\tsize *= 1024;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcurrent_par.dram_size = size;\n}\n\nstatic struct options {\n\tchar *name;\n\tvoid (*parse)(char *opt);\n} opt_table[] = {\n\t{ \"mon\",     acornfb_parse_mon     },\n\t{ \"montype\", acornfb_parse_montype },\n\t{ \"dram\",    acornfb_parse_dram    },\n\t{ NULL, NULL }\n};\n\nstatic int acornfb_setup(char *options)\n{\n\tstruct options *optp;\n\tchar *opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\tacornfb_init_fbinfo();\n\n\twhile ((opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*opt)\n\t\t\tcontinue;\n\n\t\tfor (optp = opt_table; optp->name; optp++) {\n\t\t\tint optlen;\n\n\t\t\toptlen = strlen(optp->name);\n\n\t\t\tif (strncmp(opt, optp->name, optlen) == 0 &&\n\t\t\t    opt[optlen] == ':') {\n\t\t\t\toptp->parse(opt + optlen + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!optp->name)\n\t\t\tprintk(KERN_ERR \"acornfb: unknown parameter: %s\\n\",\n\t\t\t       opt);\n\t}\n\treturn 0;\n}\n\n \nstatic int acornfb_detect_monitortype(void)\n{\n\treturn 4;\n}\n\nstatic int acornfb_probe(struct platform_device *dev)\n{\n\tunsigned long size;\n\tu_int h_sync, v_sync;\n\tint rc, i;\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"acornfb\", &option))\n\t\treturn -ENODEV;\n\tacornfb_setup(option);\n\n\tacornfb_init_fbinfo();\n\n\tcurrent_par.dev = &dev->dev;\n\n\tif (current_par.montype == -1)\n\t\tcurrent_par.montype = acornfb_detect_monitortype();\n\n\tif (current_par.montype == -1 || current_par.montype > NR_MONTYPES)\n\t\tcurrent_par.montype = 4;\n\n\tif (current_par.montype >= 0) {\n\t\tfb_info.monspecs = monspecs[current_par.montype];\n\t\tfb_info.monspecs.dpms = current_par.dpms;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(modedb); i++) {\n\t\tunsigned long hs;\n\n\t\ths = modedb[i].refresh *\n\t\t     (modedb[i].yres + modedb[i].upper_margin +\n\t\t      modedb[i].lower_margin + modedb[i].vsync_len);\n\t\tif (modedb[i].xres == DEFAULT_XRES &&\n\t\t    modedb[i].yres == DEFAULT_YRES &&\n\t\t    modedb[i].refresh >= fb_info.monspecs.vfmin &&\n\t\t    modedb[i].refresh <= fb_info.monspecs.vfmax &&\n\t\t    hs                >= fb_info.monspecs.hfmin &&\n\t\t    hs                <= fb_info.monspecs.hfmax) {\n\t\t\tacornfb_default_mode = modedb[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfb_info.screen_base    = (char *)SCREEN_BASE;\n\tfb_info.fix.smem_start = SCREEN_START;\n\tcurrent_par.using_vram = 0;\n\n\t \n\tif (vram_size && !current_par.dram_size) {\n\t\tsize = vram_size;\n\t\tcurrent_par.vram_half_sam = vram_size / 1024;\n\t\tcurrent_par.using_vram = 1;\n\t} else if (current_par.dram_size)\n\t\tsize = current_par.dram_size;\n\telse\n\t\tsize = MAX_SIZE;\n\n\t \n\tif (size > MAX_SIZE)\n\t\tsize = MAX_SIZE;\n\n\tsize = PAGE_ALIGN(size);\n\n#if defined(HAS_VIDC20)\n\tif (!current_par.using_vram) {\n\t\tdma_addr_t handle;\n\t\tvoid *base;\n\n\t\t \n\t\tbase = dma_alloc_wc(current_par.dev, size, &handle,\n\t\t\t\t    GFP_KERNEL);\n\t\tif (base == NULL) {\n\t\t\tprintk(KERN_ERR \"acornfb: unable to allocate screen memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfb_info.screen_base = base;\n\t\tfb_info.fix.smem_start = handle;\n\t}\n#endif\n\tfb_info.fix.smem_len = size;\n\tcurrent_par.palette_size   = VIDC_PALETTE_SIZE;\n\n\t \n\tdo {\n\t\trc = fb_find_mode(&fb_info.var, &fb_info, NULL, modedb,\n\t\t\t\t ARRAY_SIZE(modedb),\n\t\t\t\t &acornfb_default_mode, DEFAULT_BPP);\n\t\t \n\t\tif (rc == 1)\n\t\t\tbreak;\n\n\t\trc = fb_find_mode(&fb_info.var, &fb_info, NULL, NULL, 0,\n\t\t\t\t  &acornfb_default_mode, DEFAULT_BPP);\n\t\t \n\t\tif (rc == 1)\n\t\t\tbreak;\n\n\t\trc = fb_find_mode(&fb_info.var, &fb_info, NULL, modedb,\n\t\t\t\t ARRAY_SIZE(modedb),\n\t\t\t\t &acornfb_default_mode, DEFAULT_BPP);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\trc = fb_find_mode(&fb_info.var, &fb_info, NULL, NULL, 0,\n\t\t\t\t  &acornfb_default_mode, DEFAULT_BPP);\n\t} while (0);\n\n\t \n\tif (rc == 0) {\n\t\tprintk(\"Acornfb: no valid mode found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\th_sync = 1953125000 / fb_info.var.pixclock;\n\th_sync = h_sync * 512 / (fb_info.var.xres + fb_info.var.left_margin +\n\t\t fb_info.var.right_margin + fb_info.var.hsync_len);\n\tv_sync = h_sync / (fb_info.var.yres + fb_info.var.upper_margin +\n\t\t fb_info.var.lower_margin + fb_info.var.vsync_len);\n\n\tprintk(KERN_INFO \"Acornfb: %dkB %cRAM, %s, using %dx%d, %d.%03dkHz, %dHz\\n\",\n\t\tfb_info.fix.smem_len / 1024,\n\t\tcurrent_par.using_vram ? 'V' : 'D',\n\t\tVIDC_NAME, fb_info.var.xres, fb_info.var.yres,\n\t\th_sync / 1000, h_sync % 1000, v_sync);\n\n\tprintk(KERN_INFO \"Acornfb: Monitor: %d.%03d-%d.%03dkHz, %d-%dHz%s\\n\",\n\t\tfb_info.monspecs.hfmin / 1000, fb_info.monspecs.hfmin % 1000,\n\t\tfb_info.monspecs.hfmax / 1000, fb_info.monspecs.hfmax % 1000,\n\t\tfb_info.monspecs.vfmin, fb_info.monspecs.vfmax,\n\t\tfb_info.monspecs.dpms ? \", DPMS\" : \"\");\n\n\tif (fb_set_var(&fb_info, &fb_info.var))\n\t\tprintk(KERN_ERR \"Acornfb: unable to set display parameters\\n\");\n\n\tif (register_framebuffer(&fb_info) < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct platform_driver acornfb_driver = {\n\t.probe\t= acornfb_probe,\n\t.driver\t= {\n\t\t.name\t= \"acornfb\",\n\t},\n};\n\nstatic int __init acornfb_init(void)\n{\n\treturn platform_driver_register(&acornfb_driver);\n}\n\nmodule_init(acornfb_init);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"VIDC 1/1a/20 framebuffer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}