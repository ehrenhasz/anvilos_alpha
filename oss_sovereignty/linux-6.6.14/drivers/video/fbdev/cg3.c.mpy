{
  "module_name": "cg3.c",
  "hash_id": "2ea9270f1ff9d479fd351f8d5c55c3aadfe1bcc41e3188913f22c727cf342cd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/cg3.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/fb.h>\n#include <linux/mm.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <asm/io.h>\n#include <asm/fbio.h>\n\n#include \"sbuslib.h\"\n\n \n\nstatic int cg3_setcolreg(unsigned, unsigned, unsigned, unsigned,\n\t\t\t unsigned, struct fb_info *);\nstatic int cg3_blank(int, struct fb_info *);\n\nstatic int cg3_mmap(struct fb_info *, struct vm_area_struct *);\nstatic int cg3_ioctl(struct fb_info *, unsigned int, unsigned long);\n\n \n\nstatic const struct fb_ops cg3_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_setcolreg\t\t= cg3_setcolreg,\n\t.fb_blank\t\t= cg3_blank,\n\t.fb_fillrect\t\t= cfb_fillrect,\n\t.fb_copyarea\t\t= cfb_copyarea,\n\t.fb_imageblit\t\t= cfb_imageblit,\n\t.fb_mmap\t\t= cg3_mmap,\n\t.fb_ioctl\t\t= cg3_ioctl,\n#ifdef CONFIG_COMPAT\n\t.fb_compat_ioctl\t= sbusfb_compat_ioctl,\n#endif\n};\n\n\n \n#define CG3_CR_ENABLE_INTS      0x80\n#define CG3_CR_ENABLE_VIDEO     0x40\n#define CG3_CR_ENABLE_TIMING    0x20\n#define CG3_CR_ENABLE_CURCMP    0x10\n#define CG3_CR_XTAL_MASK        0x0c\n#define CG3_CR_DIVISOR_MASK     0x03\n\n \n#define CG3_SR_PENDING_INT      0x80\n#define CG3_SR_RES_MASK         0x70\n#define CG3_SR_1152_900_76_A    0x40\n#define CG3_SR_1152_900_76_B    0x60\n#define CG3_SR_ID_MASK          0x0f\n#define CG3_SR_ID_COLOR         0x01\n#define CG3_SR_ID_MONO          0x02\n#define CG3_SR_ID_MONO_ECL      0x03\n\nenum cg3_type {\n\tCG3_AT_66HZ = 0,\n\tCG3_AT_76HZ,\n\tCG3_RDI\n};\n\nstruct bt_regs {\n\tu32 addr;\n\tu32 color_map;\n\tu32 control;\n\tu32 cursor;\n};\n\nstruct cg3_regs {\n\tstruct bt_regs\tcmap;\n\tu8\tcontrol;\n\tu8\tstatus;\n\tu8\tcursor_start;\n\tu8\tcursor_end;\n\tu8\th_blank_start;\n\tu8\th_blank_end;\n\tu8\th_sync_start;\n\tu8\th_sync_end;\n\tu8\tcomp_sync_end;\n\tu8\tv_blank_start_high;\n\tu8\tv_blank_start_low;\n\tu8\tv_blank_end;\n\tu8\tv_sync_start;\n\tu8\tv_sync_end;\n\tu8\txfer_holdoff_start;\n\tu8\txfer_holdoff_end;\n};\n\n \n#define CG3_REGS_OFFSET\t     0x400000UL\n#define CG3_RAM_OFFSET\t     0x800000UL\n\nstruct cg3_par {\n\tspinlock_t\t\tlock;\n\tstruct cg3_regs\t\t__iomem *regs;\n\tu32\t\t\tsw_cmap[((256 * 3) + 3) / 4];\n\n\tu32\t\t\tflags;\n#define CG3_FLAG_BLANKED\t0x00000001\n#define CG3_FLAG_RDI\t\t0x00000002\n\n\tunsigned long\t\twhich_io;\n};\n\n \nstatic int cg3_setcolreg(unsigned regno,\n\t\t\t unsigned red, unsigned green, unsigned blue,\n\t\t\t unsigned transp, struct fb_info *info)\n{\n\tstruct cg3_par *par = (struct cg3_par *) info->par;\n\tstruct bt_regs __iomem *bt = &par->regs->cmap;\n\tunsigned long flags;\n\tu32 *p32;\n\tu8 *p8;\n\tint count;\n\n\tif (regno >= 256)\n\t\treturn 1;\n\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tp8 = (u8 *)par->sw_cmap + (regno * 3);\n\tp8[0] = red;\n\tp8[1] = green;\n\tp8[2] = blue;\n\n#define D4M3(x) ((((x)>>2)<<1) + ((x)>>2))       \n#define D4M4(x) ((x)&~0x3)                       \n\n\tcount = 3;\n\tp32 = &par->sw_cmap[D4M3(regno)];\n\tsbus_writel(D4M4(regno), &bt->addr);\n\twhile (count--)\n\t\tsbus_writel(*p32++, &bt->color_map);\n\n#undef D4M3\n#undef D4M4\n\n\tspin_unlock_irqrestore(&par->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int cg3_blank(int blank, struct fb_info *info)\n{\n\tstruct cg3_par *par = (struct cg3_par *) info->par;\n\tstruct cg3_regs __iomem *regs = par->regs;\n\tunsigned long flags;\n\tu8 val;\n\n\tspin_lock_irqsave(&par->lock, flags);\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:  \n\t\tval = sbus_readb(&regs->control);\n\t\tval |= CG3_CR_ENABLE_VIDEO;\n\t\tsbus_writeb(val, &regs->control);\n\t\tpar->flags &= ~CG3_FLAG_BLANKED;\n\t\tbreak;\n\n\tcase FB_BLANK_NORMAL:  \n\tcase FB_BLANK_VSYNC_SUSPEND:  \n\tcase FB_BLANK_HSYNC_SUSPEND:  \n\tcase FB_BLANK_POWERDOWN:  \n\t\tval = sbus_readb(&regs->control);\n\t\tval &= ~CG3_CR_ENABLE_VIDEO;\n\t\tsbus_writeb(val, &regs->control);\n\t\tpar->flags |= CG3_FLAG_BLANKED;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&par->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct sbus_mmap_map cg3_mmap_map[] = {\n\t{\n\t\t.voff\t= CG3_MMAP_OFFSET,\n\t\t.poff\t= CG3_RAM_OFFSET,\n\t\t.size\t= SBUS_MMAP_FBSIZE(1)\n\t},\n\t{ .size = 0 }\n};\n\nstatic int cg3_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct cg3_par *par = (struct cg3_par *)info->par;\n\n\treturn sbusfb_mmap_helper(cg3_mmap_map,\n\t\t\t\t  info->fix.smem_start, info->fix.smem_len,\n\t\t\t\t  par->which_io,\n\t\t\t\t  vma);\n}\n\nstatic int cg3_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\n{\n\treturn sbusfb_ioctl_helper(cmd, arg, info,\n\t\t\t\t   FBTYPE_SUN3COLOR, 8, info->fix.smem_len);\n}\n\n \n\nstatic void cg3_init_fix(struct fb_info *info, int linebytes,\n\t\t\t struct device_node *dp)\n{\n\tsnprintf(info->fix.id, sizeof(info->fix.id), \"%pOFn\", dp);\n\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\n\tinfo->fix.line_length = linebytes;\n\n\tinfo->fix.accel = FB_ACCEL_SUN_CGTHREE;\n}\n\nstatic void cg3_rdi_maybe_fixup_var(struct fb_var_screeninfo *var,\n\t\t\t\t    struct device_node *dp)\n{\n\tconst char *params;\n\tchar *p;\n\tint ww, hh;\n\n\tparams = of_get_property(dp, \"params\", NULL);\n\tif (params) {\n\t\tww = simple_strtoul(params, &p, 10);\n\t\tif (ww && *p == 'x') {\n\t\t\thh = simple_strtoul(p + 1, &p, 10);\n\t\t\tif (hh && *p == '-') {\n\t\t\t\tif (var->xres != ww ||\n\t\t\t\t    var->yres != hh) {\n\t\t\t\t\tvar->xres = var->xres_virtual = ww;\n\t\t\t\t\tvar->yres = var->yres_virtual = hh;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic u8 cg3regvals_66hz[] = {\t \n\t0x14, 0xbb,\t0x15, 0x2b,\t0x16, 0x04,\t0x17, 0x14,\n\t0x18, 0xae,\t0x19, 0x03,\t0x1a, 0xa8,\t0x1b, 0x24,\n\t0x1c, 0x01,\t0x1d, 0x05,\t0x1e, 0xff,\t0x1f, 0x01,\n\t0x10, 0x20,\t0\n};\n\nstatic u8 cg3regvals_76hz[] = {\t \n\t0x14, 0xb7,\t0x15, 0x27,\t0x16, 0x03,\t0x17, 0x0f,\n\t0x18, 0xae,\t0x19, 0x03,\t0x1a, 0xae,\t0x1b, 0x2a,\n\t0x1c, 0x01,\t0x1d, 0x09,\t0x1e, 0xff,\t0x1f, 0x01,\n\t0x10, 0x24,\t0\n};\n\nstatic u8 cg3regvals_rdi[] = {\t \n\t0x14, 0x70,\t0x15, 0x20,\t0x16, 0x08,\t0x17, 0x10,\n\t0x18, 0x06,\t0x19, 0x02,\t0x1a, 0x31,\t0x1b, 0x51,\n\t0x1c, 0x06,\t0x1d, 0x0c,\t0x1e, 0xff,\t0x1f, 0x01,\n\t0x10, 0x22,\t0\n};\n\nstatic u8 *cg3_regvals[] = {\n\tcg3regvals_66hz, cg3regvals_76hz, cg3regvals_rdi\n};\n\nstatic u_char cg3_dacvals[] = {\n\t4, 0xff,\t5, 0x00,\t6, 0x70,\t7, 0x00,\t0\n};\n\nstatic int cg3_do_default_mode(struct cg3_par *par)\n{\n\tenum cg3_type type;\n\tu8 *p;\n\n\tif (par->flags & CG3_FLAG_RDI)\n\t\ttype = CG3_RDI;\n\telse {\n\t\tu8 status = sbus_readb(&par->regs->status), mon;\n\t\tif ((status & CG3_SR_ID_MASK) == CG3_SR_ID_COLOR) {\n\t\t\tmon = status & CG3_SR_RES_MASK;\n\t\t\tif (mon == CG3_SR_1152_900_76_A ||\n\t\t\t    mon == CG3_SR_1152_900_76_B)\n\t\t\t\ttype = CG3_AT_76HZ;\n\t\t\telse\n\t\t\t\ttype = CG3_AT_66HZ;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"cgthree: can't handle SR %02x\\n\",\n\t\t\t       status);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor (p = cg3_regvals[type]; *p; p += 2) {\n\t\tu8 __iomem *regp = &((u8 __iomem *)par->regs)[p[0]];\n\t\tsbus_writeb(p[1], regp);\n\t}\n\tfor (p = cg3_dacvals; *p; p += 2) {\n\t\tu8 __iomem *regp;\n\n\t\tregp = (u8 __iomem *)&par->regs->cmap.addr;\n\t\tsbus_writeb(p[0], regp);\n\t\tregp = (u8 __iomem *)&par->regs->cmap.control;\n\t\tsbus_writeb(p[1], regp);\n\t}\n\treturn 0;\n}\n\nstatic int cg3_probe(struct platform_device *op)\n{\n\tstruct device_node *dp = op->dev.of_node;\n\tstruct fb_info *info;\n\tstruct cg3_par *par;\n\tint linebytes, err;\n\n\tinfo = framebuffer_alloc(sizeof(struct cg3_par), &op->dev);\n\n\terr = -ENOMEM;\n\tif (!info)\n\t\tgoto out_err;\n\tpar = info->par;\n\n\tspin_lock_init(&par->lock);\n\n\tinfo->fix.smem_start = op->resource[0].start;\n\tpar->which_io = op->resource[0].flags & IORESOURCE_BITS;\n\n\tsbusfb_fill_var(&info->var, dp, 8);\n\tinfo->var.red.length = 8;\n\tinfo->var.green.length = 8;\n\tinfo->var.blue.length = 8;\n\tif (of_node_name_eq(dp, \"cgRDI\"))\n\t\tpar->flags |= CG3_FLAG_RDI;\n\tif (par->flags & CG3_FLAG_RDI)\n\t\tcg3_rdi_maybe_fixup_var(&info->var, dp);\n\n\tlinebytes = of_getintprop_default(dp, \"linebytes\",\n\t\t\t\t\t  info->var.xres);\n\tinfo->fix.smem_len = PAGE_ALIGN(linebytes * info->var.yres);\n\n\tpar->regs = of_ioremap(&op->resource[0], CG3_REGS_OFFSET,\n\t\t\t       sizeof(struct cg3_regs), \"cg3 regs\");\n\tif (!par->regs)\n\t\tgoto out_release_fb;\n\n\tinfo->fbops = &cg3_ops;\n\tinfo->screen_base = of_ioremap(&op->resource[0], CG3_RAM_OFFSET,\n\t\t\t\t       info->fix.smem_len, \"cg3 ram\");\n\tif (!info->screen_base)\n\t\tgoto out_unmap_regs;\n\n\tcg3_blank(FB_BLANK_UNBLANK, info);\n\n\tif (!of_property_present(dp, \"width\")) {\n\t\terr = cg3_do_default_mode(par);\n\t\tif (err)\n\t\t\tgoto out_unmap_screen;\n\t}\n\n\terr = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (err)\n\t\tgoto out_unmap_screen;\n\n\tfb_set_cmap(&info->cmap, info);\n\n\tcg3_init_fix(info, linebytes, dp);\n\n\terr = register_framebuffer(info);\n\tif (err < 0)\n\t\tgoto out_dealloc_cmap;\n\n\tdev_set_drvdata(&op->dev, info);\n\n\tprintk(KERN_INFO \"%pOF: cg3 at %lx:%lx\\n\",\n\t       dp, par->which_io, info->fix.smem_start);\n\n\treturn 0;\n\nout_dealloc_cmap:\n\tfb_dealloc_cmap(&info->cmap);\n\nout_unmap_screen:\n\tof_iounmap(&op->resource[0], info->screen_base, info->fix.smem_len);\n\nout_unmap_regs:\n\tof_iounmap(&op->resource[0], par->regs, sizeof(struct cg3_regs));\n\nout_release_fb:\n\tframebuffer_release(info);\n\nout_err:\n\treturn err;\n}\n\nstatic void cg3_remove(struct platform_device *op)\n{\n\tstruct fb_info *info = dev_get_drvdata(&op->dev);\n\tstruct cg3_par *par = info->par;\n\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\n\tof_iounmap(&op->resource[0], par->regs, sizeof(struct cg3_regs));\n\tof_iounmap(&op->resource[0], info->screen_base, info->fix.smem_len);\n\n\tframebuffer_release(info);\n}\n\nstatic const struct of_device_id cg3_match[] = {\n\t{\n\t\t.name = \"cgthree\",\n\t},\n\t{\n\t\t.name = \"cgRDI\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cg3_match);\n\nstatic struct platform_driver cg3_driver = {\n\t.driver = {\n\t\t.name = \"cg3\",\n\t\t.of_match_table = cg3_match,\n\t},\n\t.probe\t\t= cg3_probe,\n\t.remove_new\t= cg3_remove,\n};\n\nstatic int __init cg3_init(void)\n{\n\tif (fb_get_options(\"cg3fb\", NULL))\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&cg3_driver);\n}\n\nstatic void __exit cg3_exit(void)\n{\n\tplatform_driver_unregister(&cg3_driver);\n}\n\nmodule_init(cg3_init);\nmodule_exit(cg3_exit);\n\nMODULE_DESCRIPTION(\"framebuffer driver for CGthree chipsets\");\nMODULE_AUTHOR(\"David S. Miller <davem@davemloft.net>\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}