{
  "module_name": "mb862xx-i2c.c",
  "hash_id": "5658e5aa94389218f6f7d57c8bb62203a55262da97890ee8b9b0b414249ce8f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/mb862xx/mb862xx-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/fb.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n\n#include \"mb862xxfb.h\"\n#include \"mb862xx_reg.h\"\n\nstatic int mb862xx_i2c_wait_event(struct i2c_adapter *adap)\n{\n\tstruct mb862xxfb_par *par = adap->algo_data;\n\tu32 reg;\n\n\tdo {\n\t\tudelay(10);\n\t\treg = inreg(i2c, GC_I2C_BCR);\n\t\tif (reg & (I2C_INT | I2C_BER))\n\t\t\tbreak;\n\t} while (1);\n\n\treturn (reg & I2C_BER) ? 0 : 1;\n}\n\nstatic int mb862xx_i2c_do_address(struct i2c_adapter *adap, int addr)\n{\n\tstruct mb862xxfb_par *par = adap->algo_data;\n\n\toutreg(i2c, GC_I2C_DAR, addr);\n\toutreg(i2c, GC_I2C_CCR, I2C_CLOCK_AND_ENABLE);\n\toutreg(i2c, GC_I2C_BCR, par->i2c_rs ? I2C_REPEATED_START : I2C_START);\n\tif (!mb862xx_i2c_wait_event(adap))\n\t\treturn -EIO;\n\tpar->i2c_rs = !(inreg(i2c, GC_I2C_BSR) & I2C_LRB);\n\treturn par->i2c_rs;\n}\n\nstatic int mb862xx_i2c_write_byte(struct i2c_adapter *adap, u8 byte)\n{\n\tstruct mb862xxfb_par *par = adap->algo_data;\n\n\toutreg(i2c, GC_I2C_DAR, byte);\n\toutreg(i2c, GC_I2C_BCR, I2C_START);\n\tif (!mb862xx_i2c_wait_event(adap))\n\t\treturn -EIO;\n\treturn !(inreg(i2c, GC_I2C_BSR) & I2C_LRB);\n}\n\nstatic int mb862xx_i2c_read_byte(struct i2c_adapter *adap, u8 *byte, int last)\n{\n\tstruct mb862xxfb_par *par = adap->algo_data;\n\n\toutreg(i2c, GC_I2C_BCR, I2C_START | (last ? 0 : I2C_ACK));\n\tif (!mb862xx_i2c_wait_event(adap))\n\t\treturn 0;\n\t*byte = inreg(i2c, GC_I2C_DAR);\n\treturn 1;\n}\n\nstatic void mb862xx_i2c_stop(struct i2c_adapter *adap)\n{\n\tstruct mb862xxfb_par *par = adap->algo_data;\n\n\toutreg(i2c, GC_I2C_BCR, I2C_STOP);\n\toutreg(i2c, GC_I2C_CCR, I2C_DISABLE);\n\tpar->i2c_rs = 0;\n}\n\nstatic int mb862xx_i2c_read(struct i2c_adapter *adap, struct i2c_msg *m)\n{\n\tint i, ret = 0;\n\tint last = m->len - 1;\n\n\tfor (i = 0; i < m->len; i++) {\n\t\tif (!mb862xx_i2c_read_byte(adap, &m->buf[i], i == last)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int mb862xx_i2c_write(struct i2c_adapter *adap, struct i2c_msg *m)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < m->len; i++) {\n\t\tif (!mb862xx_i2c_write_byte(adap, m->buf[i])) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int mb862xx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\tint num)\n{\n\tstruct mb862xxfb_par *par = adap->algo_data;\n\tstruct i2c_msg *m;\n\tint addr;\n\tint i = 0, err = 0;\n\n\tdev_dbg(par->dev, \"%s: %d msgs\\n\", __func__, num);\n\n\tfor (i = 0; i < num; i++) {\n\t\tm = &msgs[i];\n\t\tif (!m->len) {\n\t\t\tdev_dbg(par->dev, \"%s: null msgs\\n\", __func__);\n\t\t\tcontinue;\n\t\t}\n\t\taddr = m->addr;\n\t\tif (m->flags & I2C_M_RD)\n\t\t\taddr |= 1;\n\n\t\terr = mb862xx_i2c_do_address(adap, addr);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (m->flags & I2C_M_RD)\n\t\t\terr = mb862xx_i2c_read(adap, m);\n\t\telse\n\t\t\terr = mb862xx_i2c_write(adap, m);\n\t}\n\n\tif (i)\n\t\tmb862xx_i2c_stop(adap);\n\n\treturn (err < 0) ? err : i;\n}\n\nstatic u32 mb862xx_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_BYTE_DATA;\n}\n\nstatic const struct i2c_algorithm mb862xx_algo = {\n\t.master_xfer\t= mb862xx_xfer,\n\t.functionality\t= mb862xx_func,\n};\n\nstatic struct i2c_adapter mb862xx_i2c_adapter = {\n\t.name\t\t= \"MB862xx I2C adapter\",\n\t.algo\t\t= &mb862xx_algo,\n\t.owner\t\t= THIS_MODULE,\n};\n\nint mb862xx_i2c_init(struct mb862xxfb_par *par)\n{\n\tmb862xx_i2c_adapter.algo_data = par;\n\tpar->adap = &mb862xx_i2c_adapter;\n\n\treturn i2c_add_adapter(par->adap);\n}\n\nvoid mb862xx_i2c_exit(struct mb862xxfb_par *par)\n{\n\tif (par->adap) {\n\t\ti2c_del_adapter(par->adap);\n\t\tpar->adap = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}