{
  "module_name": "mb862xxfbdrv.c",
  "hash_id": "21ad7d704ba9f4c6415fa7e9a8860006ff4b2c0f2af3a6bb825ad3a42324ca93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/mb862xx/mb862xxfbdrv.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/aperture.h>\n#include <linux/fb.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\n#include \"mb862xxfb.h\"\n#include \"mb862xx_reg.h\"\n\n#define NR_PALETTE\t\t256\n#define MB862XX_MEM_SIZE\t0x1000000\n#define CORALP_MEM_SIZE\t\t0x2000000\n#define CARMINE_MEM_SIZE\t0x8000000\n#define DRV_NAME\t\t\"mb862xxfb\"\n\n#if defined(CONFIG_SOCRATES)\nstatic struct mb862xx_gc_mode socrates_gc_mode = {\n\t \n\t{ \"800x480\", 45, 800, 480, 40000, 86, 42, 33, 10, 128, 2, 0, 0, 0 },\n\t \n\t16, 0x1000000, GC_CCF_COT_133, 0x4157ba63\n};\n#endif\n\n \nstatic inline int h_total(struct fb_var_screeninfo *var)\n{\n\treturn var->xres + var->left_margin +\n\t\tvar->right_margin + var->hsync_len;\n}\n\nstatic inline int v_total(struct fb_var_screeninfo *var)\n{\n\treturn var->yres + var->upper_margin +\n\t\tvar->lower_margin + var->vsync_len;\n}\n\nstatic inline int hsp(struct fb_var_screeninfo *var)\n{\n\treturn var->xres + var->right_margin - 1;\n}\n\nstatic inline int vsp(struct fb_var_screeninfo *var)\n{\n\treturn var->yres + var->lower_margin - 1;\n}\n\nstatic inline int d_pitch(struct fb_var_screeninfo *var)\n{\n\treturn var->xres * var->bits_per_pixel / 8;\n}\n\nstatic inline unsigned int chan_to_field(unsigned int chan,\n\t\t\t\t\t struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\nstatic int mb862xxfb_setcolreg(unsigned regno,\n\t\t\t       unsigned red, unsigned green, unsigned blue,\n\t\t\t       unsigned transp, struct fb_info *info)\n{\n\tstruct mb862xxfb_par *par = info->par;\n\tunsigned int val;\n\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\tif (regno < 16) {\n\t\t\tval  = chan_to_field(red,   &info->var.red);\n\t\t\tval |= chan_to_field(green, &info->var.green);\n\t\t\tval |= chan_to_field(blue,  &info->var.blue);\n\t\t\tpar->pseudo_palette[regno] = val;\n\t\t}\n\t\tbreak;\n\tcase FB_VISUAL_PSEUDOCOLOR:\n\t\tif (regno < 256) {\n\t\t\tval = (red >> 8) << 16;\n\t\t\tval |= (green >> 8) << 8;\n\t\t\tval |= blue >> 8;\n\t\t\toutreg(disp, GC_L0PAL0 + (regno * 4), val);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 1;    \n\t}\n\treturn 0;\n}\n\nstatic int mb862xxfb_check_var(struct fb_var_screeninfo *var,\n\t\t\t       struct fb_info *fbi)\n{\n\tunsigned long tmp;\n\n\tfb_dbg(fbi, \"%s\\n\", __func__);\n\n\t \n\tif (var->hsync_len > 255 || var->vsync_len > 255)\n\t\treturn -EINVAL;\n\n\tif ((var->xres + var->right_margin) >= 4096)\n\t\treturn -EINVAL;\n\n\tif ((var->yres + var->lower_margin) > 4096)\n\t\treturn -EINVAL;\n\n\tif (h_total(var) > 4096 || v_total(var) > 4096)\n\t\treturn -EINVAL;\n\n\tif (var->xres_virtual > 4096 || var->yres_virtual > 4096)\n\t\treturn -EINVAL;\n\n\tif (var->bits_per_pixel <= 8)\n\t\tvar->bits_per_pixel = 8;\n\telse if (var->bits_per_pixel <= 16)\n\t\tvar->bits_per_pixel = 16;\n\telse if (var->bits_per_pixel <= 32)\n\t\tvar->bits_per_pixel = 32;\n\n\t \n\tif (d_pitch(&fbi->var) % GC_L0M_L0W_UNIT) {\n\t\tint r;\n\n\t\tvar->bits_per_pixel = 0;\n\t\tdo {\n\t\t\tvar->bits_per_pixel += 8;\n\t\t\tr = d_pitch(&fbi->var) % GC_L0M_L0W_UNIT;\n\t\t} while (r && var->bits_per_pixel <= 32);\n\n\t\tif (d_pitch(&fbi->var) % GC_L0M_L0W_UNIT)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmp = (var->xres * var->bits_per_pixel) / 8;\n\tif ((tmp & 15) != 0)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.length\t\t= var->bits_per_pixel;\n\t\tvar->green.length\t= var->bits_per_pixel;\n\t\tvar->blue.length\t= var->bits_per_pixel;\n\t\tvar->red.offset\t\t= 0;\n\t\tvar->green.offset\t= 0;\n\t\tvar->blue.offset\t= 0;\n\t\tvar->transp.length\t= 0;\n\t\tbreak;\n\tcase 16:\n\t\tvar->red.length\t\t= 5;\n\t\tvar->green.length\t= 5;\n\t\tvar->blue.length\t= 5;\n\t\tvar->red.offset\t\t= 10;\n\t\tvar->green.offset\t= 5;\n\t\tvar->blue.offset\t= 0;\n\t\tvar->transp.length\t= 0;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tvar->transp.length\t= 8;\n\t\tvar->red.length\t\t= 8;\n\t\tvar->green.length\t= 8;\n\t\tvar->blue.length\t= 8;\n\t\tvar->transp.offset\t= 24;\n\t\tvar->red.offset\t\t= 16;\n\t\tvar->green.offset\t= 8;\n\t\tvar->blue.offset\t= 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic struct fb_ops mb862xxfb_ops;\n\n \nstatic int mb862xxfb_set_par(struct fb_info *fbi)\n{\n\tstruct mb862xxfb_par *par = fbi->par;\n\tunsigned long reg, sc;\n\n\tdev_dbg(par->dev, \"%s\\n\", __func__);\n\tif (par->type == BT_CORALP)\n\t\tmb862xxfb_init_accel(fbi, &mb862xxfb_ops, fbi->var.xres);\n\n\tif (par->pre_init)\n\t\treturn 0;\n\n\t \n\treg = inreg(disp, GC_DCM1);\n\treg &= ~GC_DCM01_DEN;\n\toutreg(disp, GC_DCM1, reg);\n\n\t \n\tsc = par->refclk / (1000000 / fbi->var.pixclock) - 1;\n\treg = inreg(disp, GC_DCM1);\n\treg &= ~(GC_DCM01_CKS | GC_DCM01_RESV | GC_DCM01_SC);\n\treg |= sc << 8;\n\toutreg(disp, GC_DCM1, reg);\n\tdev_dbg(par->dev, \"SC 0x%lx\\n\", sc);\n\n\t \n\treg =  pack(d_pitch(&fbi->var) / GC_L0M_L0W_UNIT,\n\t\t    (fbi->var.yres - 1));\n\tif (fbi->var.bits_per_pixel == 16)\n\t\treg |= GC_L0M_L0C_16;\n\toutreg(disp, GC_L0M, reg);\n\n\tif (fbi->var.bits_per_pixel == 32) {\n\t\treg = inreg(disp, GC_L0EM);\n\t\toutreg(disp, GC_L0EM, reg | GC_L0EM_L0EC_24);\n\t}\n\toutreg(disp, GC_WY_WX, 0);\n\treg = pack(fbi->var.yres - 1, fbi->var.xres);\n\toutreg(disp, GC_WH_WW, reg);\n\toutreg(disp, GC_L0OA0, 0);\n\toutreg(disp, GC_L0DA0, 0);\n\toutreg(disp, GC_L0DY_L0DX, 0);\n\toutreg(disp, GC_L0WY_L0WX, 0);\n\toutreg(disp, GC_L0WH_L0WW, reg);\n\n\t \n\treg = inreg(disp, GC_CPM_CUTC);\n\treg &= ~(GC_CPM_CEN0 | GC_CPM_CEN1);\n\toutreg(disp, GC_CPM_CUTC, reg);\n\n\t \n\treg = pack(fbi->var.xres - 1, fbi->var.xres - 1);\n\toutreg(disp, GC_HDB_HDP, reg);\n\treg = pack((fbi->var.yres - 1), vsp(&fbi->var));\n\toutreg(disp, GC_VDP_VSP, reg);\n\treg = ((fbi->var.vsync_len - 1) << 24) |\n\t      pack((fbi->var.hsync_len - 1), hsp(&fbi->var));\n\toutreg(disp, GC_VSW_HSW_HSP, reg);\n\toutreg(disp, GC_HTP, pack(h_total(&fbi->var) - 1, 0));\n\toutreg(disp, GC_VTR, pack(v_total(&fbi->var) - 1, 0));\n\n\t \n\treg = inreg(disp, GC_DCM1);\n\treg |= GC_DCM01_DEN | GC_DCM01_L0E;\n\treg &= ~GC_DCM01_ESY;\n\toutreg(disp, GC_DCM1, reg);\n\treturn 0;\n}\n\nstatic int mb862xxfb_pan(struct fb_var_screeninfo *var,\n\t\t\t struct fb_info *info)\n{\n\tstruct mb862xxfb_par *par = info->par;\n\tunsigned long reg;\n\n\treg = pack(var->yoffset, var->xoffset);\n\toutreg(disp, GC_L0WY_L0WX, reg);\n\n\treg = pack(info->var.yres_virtual, info->var.xres_virtual);\n\toutreg(disp, GC_L0WH_L0WW, reg);\n\treturn 0;\n}\n\nstatic int mb862xxfb_blank(int mode, struct fb_info *fbi)\n{\n\tstruct mb862xxfb_par  *par = fbi->par;\n\tunsigned long reg;\n\n\tfb_dbg(fbi, \"blank mode=%d\\n\", mode);\n\n\tswitch (mode) {\n\tcase FB_BLANK_POWERDOWN:\n\t\treg = inreg(disp, GC_DCM1);\n\t\treg &= ~GC_DCM01_DEN;\n\t\toutreg(disp, GC_DCM1, reg);\n\t\tbreak;\n\tcase FB_BLANK_UNBLANK:\n\t\treg = inreg(disp, GC_DCM1);\n\t\treg |= GC_DCM01_DEN;\n\t\toutreg(disp, GC_DCM1, reg);\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tdefault:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int mb862xxfb_ioctl(struct fb_info *fbi, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tstruct mb862xxfb_par *par = fbi->par;\n\tstruct mb862xx_l1_cfg *l1_cfg = &par->l1_cfg;\n\tvoid __user *argp = (void __user *)arg;\n\tint *enable;\n\tu32 l1em = 0;\n\n\tswitch (cmd) {\n\tcase MB862XX_L1_GET_CFG:\n\t\tif (copy_to_user(argp, l1_cfg, sizeof(*l1_cfg)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase MB862XX_L1_SET_CFG:\n\t\tif (copy_from_user(l1_cfg, argp, sizeof(*l1_cfg)))\n\t\t\treturn -EFAULT;\n\t\tif (l1_cfg->dh == 0 || l1_cfg->dw == 0)\n\t\t\treturn -EINVAL;\n\t\tif ((l1_cfg->sw >= l1_cfg->dw) && (l1_cfg->sh >= l1_cfg->dh)) {\n\t\t\t \n\t\t\toutreg(cap, GC_CAP_CSC,\n\t\t\t\tpack((l1_cfg->sh << 11) / l1_cfg->dh,\n\t\t\t\t     (l1_cfg->sw << 11) / l1_cfg->dw));\n\t\t\tl1em = inreg(disp, GC_L1EM);\n\t\t\tl1em &= ~GC_L1EM_DM;\n\t\t} else if ((l1_cfg->sw <= l1_cfg->dw) &&\n\t\t\t   (l1_cfg->sh <= l1_cfg->dh)) {\n\t\t\t \n\t\t\toutreg(cap, GC_CAP_CSC,\n\t\t\t\tpack((l1_cfg->sh << 11) / l1_cfg->dh,\n\t\t\t\t     (l1_cfg->sw << 11) / l1_cfg->dw));\n\t\t\toutreg(cap, GC_CAP_CMSS,\n\t\t\t\tpack(l1_cfg->sw >> 1, l1_cfg->sh));\n\t\t\toutreg(cap, GC_CAP_CMDS,\n\t\t\t\tpack(l1_cfg->dw >> 1, l1_cfg->dh));\n\t\t\tl1em = inreg(disp, GC_L1EM);\n\t\t\tl1em |= GC_L1EM_DM;\n\t\t}\n\n\t\tif (l1_cfg->mirror) {\n\t\t\toutreg(cap, GC_CAP_CBM,\n\t\t\t\tinreg(cap, GC_CAP_CBM) | GC_CBM_HRV);\n\t\t\tl1em |= l1_cfg->dw * 2 - 8;\n\t\t} else {\n\t\t\toutreg(cap, GC_CAP_CBM,\n\t\t\t\tinreg(cap, GC_CAP_CBM) & ~GC_CBM_HRV);\n\t\t\tl1em &= 0xffff0000;\n\t\t}\n\t\toutreg(disp, GC_L1EM, l1em);\n\t\tbreak;\n\tcase MB862XX_L1_ENABLE:\n\t\tenable = (int *)arg;\n\t\tif (*enable) {\n\t\t\toutreg(disp, GC_L1DA, par->cap_buf);\n\t\t\toutreg(cap, GC_CAP_IMG_START,\n\t\t\t\tpack(l1_cfg->sy >> 1, l1_cfg->sx));\n\t\t\toutreg(cap, GC_CAP_IMG_END,\n\t\t\t\tpack(l1_cfg->sh, l1_cfg->sw));\n\t\t\toutreg(disp, GC_L1M, GC_L1M_16 | GC_L1M_YC | GC_L1M_CS |\n\t\t\t\t\t     (par->l1_stride << 16));\n\t\t\toutreg(disp, GC_L1WY_L1WX,\n\t\t\t\tpack(l1_cfg->dy, l1_cfg->dx));\n\t\t\toutreg(disp, GC_L1WH_L1WW,\n\t\t\t\tpack(l1_cfg->dh - 1, l1_cfg->dw));\n\t\t\toutreg(disp, GC_DLS, 1);\n\t\t\toutreg(cap, GC_CAP_VCM,\n\t\t\t\tGC_VCM_VIE | GC_VCM_CM | GC_VCM_VS_PAL);\n\t\t\toutreg(disp, GC_DCM1, inreg(disp, GC_DCM1) |\n\t\t\t\t\t      GC_DCM1_DEN | GC_DCM1_L1E);\n\t\t} else {\n\t\t\toutreg(cap, GC_CAP_VCM,\n\t\t\t\tinreg(cap, GC_CAP_VCM) & ~GC_VCM_VIE);\n\t\t\toutreg(disp, GC_DCM1,\n\t\t\t\tinreg(disp, GC_DCM1) & ~GC_DCM1_L1E);\n\t\t}\n\t\tbreak;\n\tcase MB862XX_L1_CAP_CTL:\n\t\tenable = (int *)arg;\n\t\tif (*enable) {\n\t\t\toutreg(cap, GC_CAP_VCM,\n\t\t\t\tinreg(cap, GC_CAP_VCM) | GC_VCM_VIE);\n\t\t} else {\n\t\t\toutreg(cap, GC_CAP_VCM,\n\t\t\t\tinreg(cap, GC_CAP_VCM) & ~GC_VCM_VIE);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic struct fb_ops mb862xxfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_check_var\t= mb862xxfb_check_var,\n\t.fb_set_par\t= mb862xxfb_set_par,\n\t.fb_setcolreg\t= mb862xxfb_setcolreg,\n\t.fb_blank\t= mb862xxfb_blank,\n\t.fb_pan_display\t= mb862xxfb_pan,\n\t.fb_ioctl\t= mb862xxfb_ioctl,\n};\n\n \nstatic int mb862xxfb_init_fbinfo(struct fb_info *fbi)\n{\n\tstruct mb862xxfb_par *par = fbi->par;\n\tstruct mb862xx_gc_mode *mode = par->gc_mode;\n\tunsigned long reg;\n\tint stride;\n\n\tfbi->fbops = &mb862xxfb_ops;\n\tfbi->pseudo_palette = par->pseudo_palette;\n\tfbi->screen_base = par->fb_base;\n\tfbi->screen_size = par->mapped_vram;\n\n\tstrcpy(fbi->fix.id, DRV_NAME);\n\tfbi->fix.smem_start = (unsigned long)par->fb_base_phys;\n\tfbi->fix.mmio_start = (unsigned long)par->mmio_base_phys;\n\tfbi->fix.mmio_len = par->mmio_len;\n\tfbi->fix.accel = FB_ACCEL_NONE;\n\tfbi->fix.type = FB_TYPE_PACKED_PIXELS;\n\tfbi->fix.type_aux = 0;\n\tfbi->fix.xpanstep = 1;\n\tfbi->fix.ypanstep = 1;\n\tfbi->fix.ywrapstep = 0;\n\n\treg = inreg(disp, GC_DCM1);\n\tif (reg & GC_DCM01_DEN && reg & GC_DCM01_L0E) {\n\t\t \n\t\tunsigned long sc = ((reg & GC_DCM01_SC) >> 8) + 1;\n\t\tunsigned long hsp, vsp, ht, vt;\n\n\t\tdev_dbg(par->dev, \"using bootloader's disp. mode\\n\");\n\t\tfbi->var.pixclock = (sc * 1000000) / par->refclk;\n\t\tfbi->var.xres = (inreg(disp, GC_HDB_HDP) & 0x0fff) + 1;\n\t\treg = inreg(disp, GC_VDP_VSP);\n\t\tfbi->var.yres = ((reg >> 16) & 0x0fff) + 1;\n\t\tvsp = (reg & 0x0fff) + 1;\n\t\tfbi->var.xres_virtual = fbi->var.xres;\n\t\tfbi->var.yres_virtual = fbi->var.yres;\n\t\treg = inreg(disp, GC_L0EM);\n\t\tif (reg & GC_L0EM_L0EC_24) {\n\t\t\tfbi->var.bits_per_pixel = 32;\n\t\t} else {\n\t\t\treg = inreg(disp, GC_L0M);\n\t\t\tif (reg & GC_L0M_L0C_16)\n\t\t\t\tfbi->var.bits_per_pixel = 16;\n\t\t\telse\n\t\t\t\tfbi->var.bits_per_pixel = 8;\n\t\t}\n\t\treg = inreg(disp, GC_VSW_HSW_HSP);\n\t\tfbi->var.hsync_len = ((reg & 0xff0000) >> 16) + 1;\n\t\tfbi->var.vsync_len = ((reg & 0x3f000000) >> 24) + 1;\n\t\thsp = (reg & 0xffff) + 1;\n\t\tht = ((inreg(disp, GC_HTP) & 0xfff0000) >> 16) + 1;\n\t\tfbi->var.right_margin = hsp - fbi->var.xres;\n\t\tfbi->var.left_margin = ht - hsp - fbi->var.hsync_len;\n\t\tvt = ((inreg(disp, GC_VTR) & 0xfff0000) >> 16) + 1;\n\t\tfbi->var.lower_margin = vsp - fbi->var.yres;\n\t\tfbi->var.upper_margin = vt - vsp - fbi->var.vsync_len;\n\t} else if (mode) {\n\t\tdev_dbg(par->dev, \"using supplied mode\\n\");\n\t\tfb_videomode_to_var(&fbi->var, (struct fb_videomode *)mode);\n\t\tfbi->var.bits_per_pixel = mode->def_bpp ? mode->def_bpp : 8;\n\t} else {\n\t\tint ret;\n\n\t\tret = fb_find_mode(&fbi->var, fbi, \"640x480-16@60\",\n\t\t\t\t   NULL, 0, NULL, 16);\n\t\tif (ret == 0 || ret == 4) {\n\t\t\tdev_err(par->dev,\n\t\t\t\t\"failed to get initial mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfbi->var.xoffset = 0;\n\tfbi->var.yoffset = 0;\n\tfbi->var.grayscale = 0;\n\tfbi->var.nonstd = 0;\n\tfbi->var.height = -1;\n\tfbi->var.width = -1;\n\tfbi->var.accel_flags = 0;\n\tfbi->var.vmode = FB_VMODE_NONINTERLACED;\n\tfbi->var.activate = FB_ACTIVATE_NOW;\n\tfbi->flags =\n#ifdef __BIG_ENDIAN\n\t\t     FBINFO_FOREIGN_ENDIAN |\n#endif\n\t\t     FBINFO_HWACCEL_XPAN |\n\t\t     FBINFO_HWACCEL_YPAN;\n\n\t \n\tif ((fbi->fbops->fb_check_var)(&fbi->var, fbi))\n\t\tdev_err(par->dev, \"check_var() failed on initial setup?\\n\");\n\n\tfbi->fix.visual = fbi->var.bits_per_pixel == 8 ?\n\t\t\t FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\tfbi->fix.line_length = (fbi->var.xres_virtual *\n\t\t\t\tfbi->var.bits_per_pixel) / 8;\n\tfbi->fix.smem_len = fbi->fix.line_length * fbi->var.yres_virtual;\n\n\t \n\tpar->cap_buf = par->mapped_vram - 0x1bd800 - 0x10000;\n\tpar->cap_len = 0x1bd800;\n\tpar->l1_cfg.sx = 0;\n\tpar->l1_cfg.sy = 0;\n\tpar->l1_cfg.sw = 720;\n\tpar->l1_cfg.sh = 576;\n\tpar->l1_cfg.dx = 0;\n\tpar->l1_cfg.dy = 0;\n\tpar->l1_cfg.dw = 720;\n\tpar->l1_cfg.dh = 576;\n\tstride = par->l1_cfg.sw * (fbi->var.bits_per_pixel / 8);\n\tpar->l1_stride = stride / 64 + ((stride % 64) ? 1 : 0);\n\toutreg(cap, GC_CAP_CBM, GC_CBM_OO | GC_CBM_CBST |\n\t\t\t\t(par->l1_stride << 16));\n\toutreg(cap, GC_CAP_CBOA, par->cap_buf);\n\toutreg(cap, GC_CAP_CBLA, par->cap_buf + par->cap_len);\n\treturn 0;\n}\n\n \nstatic ssize_t dispregs_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(dev);\n\tstruct mb862xxfb_par *par = fbi->par;\n\tchar *ptr = buf;\n\tunsigned int reg;\n\n\tfor (reg = GC_DCM0; reg <= GC_L0DY_L0DX; reg += 4)\n\t\tptr += sprintf(ptr, \"%08x = %08x\\n\",\n\t\t\t       reg, inreg(disp, reg));\n\n\tfor (reg = GC_CPM_CUTC; reg <= GC_CUY1_CUX1; reg += 4)\n\t\tptr += sprintf(ptr, \"%08x = %08x\\n\",\n\t\t\t       reg, inreg(disp, reg));\n\n\tfor (reg = GC_DCM1; reg <= GC_L0WH_L0WW; reg += 4)\n\t\tptr += sprintf(ptr, \"%08x = %08x\\n\",\n\t\t\t       reg, inreg(disp, reg));\n\n\tfor (reg = 0x400; reg <= 0x410; reg += 4)\n\t\tptr += sprintf(ptr, \"geo %08x = %08x\\n\",\n\t\t\t       reg, inreg(geo, reg));\n\n\tfor (reg = 0x400; reg <= 0x410; reg += 4)\n\t\tptr += sprintf(ptr, \"draw %08x = %08x\\n\",\n\t\t\t       reg, inreg(draw, reg));\n\n\tfor (reg = 0x440; reg <= 0x450; reg += 4)\n\t\tptr += sprintf(ptr, \"draw %08x = %08x\\n\",\n\t\t\t       reg, inreg(draw, reg));\n\n\treturn ptr - buf;\n}\n\nstatic DEVICE_ATTR_RO(dispregs);\n\nstatic irqreturn_t mb862xx_intr(int irq, void *dev_id)\n{\n\tstruct mb862xxfb_par *par = (struct mb862xxfb_par *) dev_id;\n\tunsigned long reg_ist, mask;\n\n\tif (!par)\n\t\treturn IRQ_NONE;\n\n\tif (par->type == BT_CARMINE) {\n\t\t \n\t\treg_ist = inreg(ctrl, GC_CTRL_STATUS);\n\t\tmask = inreg(ctrl, GC_CTRL_INT_MASK);\n\t\tif (reg_ist == 0)\n\t\t\treturn IRQ_HANDLED;\n\n\t\treg_ist &= mask;\n\t\tif (reg_ist == 0)\n\t\t\treturn IRQ_HANDLED;\n\n\t\t \n\t\toutreg(ctrl, 0x0, reg_ist);\n\t} else {\n\t\t \n\t\treg_ist = inreg(host, GC_IST);\n\t\tmask = inreg(host, GC_IMASK);\n\n\t\treg_ist &= mask;\n\t\tif (reg_ist == 0)\n\t\t\treturn IRQ_HANDLED;\n\n\t\t \n\t\toutreg(host, GC_IST, ~reg_ist);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n#if defined(CONFIG_FB_MB862XX_LIME)\n \nstatic int mb862xx_gdc_init(struct mb862xxfb_par *par)\n{\n\tunsigned long ccf, mmr;\n\tunsigned long ver, rev;\n\n\tif (!par)\n\t\treturn -ENODEV;\n\n#if defined(CONFIG_FB_PRE_INIT_FB)\n\tpar->pre_init = 1;\n#endif\n\tpar->host = par->mmio_base;\n\tpar->i2c = par->mmio_base + MB862XX_I2C_BASE;\n\tpar->disp = par->mmio_base + MB862XX_DISP_BASE;\n\tpar->cap = par->mmio_base + MB862XX_CAP_BASE;\n\tpar->draw = par->mmio_base + MB862XX_DRAW_BASE;\n\tpar->geo = par->mmio_base + MB862XX_GEO_BASE;\n\tpar->pio = par->mmio_base + MB862XX_PIO_BASE;\n\n\tpar->refclk = GC_DISP_REFCLK_400;\n\n\tver = inreg(host, GC_CID);\n\trev = inreg(pio, GC_REVISION);\n\tif ((ver == 0x303) && (rev & 0xffffff00) == 0x20050100) {\n\t\tdev_info(par->dev, \"Fujitsu Lime v1.%d found\\n\",\n\t\t\t (int)rev & 0xff);\n\t\tpar->type = BT_LIME;\n\t\tccf = par->gc_mode ? par->gc_mode->ccf : GC_CCF_COT_100;\n\t\tmmr = par->gc_mode ? par->gc_mode->mmr : 0x414fb7f2;\n\t} else {\n\t\tdev_info(par->dev, \"? GDC, CID/Rev.: 0x%lx/0x%lx \\n\", ver, rev);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!par->pre_init) {\n\t\toutreg(host, GC_CCF, ccf);\n\t\tudelay(200);\n\t\toutreg(host, GC_MMR, mmr);\n\t\tudelay(10);\n\t}\n\n\t \n\toutreg(host, GC_IST, 0);\n\toutreg(host, GC_IMASK, GC_INT_EN);\n\treturn 0;\n}\n\nstatic int of_platform_mb862xx_probe(struct platform_device *ofdev)\n{\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct device *dev = &ofdev->dev;\n\tstruct mb862xxfb_par *par;\n\tstruct fb_info *info;\n\tstruct resource res;\n\tresource_size_t res_size;\n\tunsigned long ret = -ENODEV;\n\n\tif (of_address_to_resource(np, 0, &res)) {\n\t\tdev_err(dev, \"Invalid address\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct mb862xxfb_par), dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tpar->info = info;\n\tpar->dev = dev;\n\n\tpar->irq = irq_of_parse_and_map(np, 0);\n\tif (!par->irq) {\n\t\tdev_err(dev, \"failed to map irq\\n\");\n\t\tret = -ENODEV;\n\t\tgoto fbrel;\n\t}\n\n\tres_size = resource_size(&res);\n\tpar->res = request_mem_region(res.start, res_size, DRV_NAME);\n\tif (par->res == NULL) {\n\t\tdev_err(dev, \"Cannot claim framebuffer/mmio\\n\");\n\t\tret = -ENXIO;\n\t\tgoto irqdisp;\n\t}\n\n#if defined(CONFIG_SOCRATES)\n\tpar->gc_mode = &socrates_gc_mode;\n#endif\n\n\tpar->fb_base_phys = res.start;\n\tpar->mmio_base_phys = res.start + MB862XX_MMIO_BASE;\n\tpar->mmio_len = MB862XX_MMIO_SIZE;\n\tif (par->gc_mode)\n\t\tpar->mapped_vram = par->gc_mode->max_vram;\n\telse\n\t\tpar->mapped_vram = MB862XX_MEM_SIZE;\n\n\tpar->fb_base = ioremap(par->fb_base_phys, par->mapped_vram);\n\tif (par->fb_base == NULL) {\n\t\tdev_err(dev, \"Cannot map framebuffer\\n\");\n\t\tgoto rel_reg;\n\t}\n\n\tpar->mmio_base = ioremap(par->mmio_base_phys, par->mmio_len);\n\tif (par->mmio_base == NULL) {\n\t\tdev_err(dev, \"Cannot map registers\\n\");\n\t\tgoto fb_unmap;\n\t}\n\n\tdev_dbg(dev, \"fb phys 0x%llx 0x%lx\\n\",\n\t\t(u64)par->fb_base_phys, (ulong)par->mapped_vram);\n\tdev_dbg(dev, \"mmio phys 0x%llx 0x%lx, (irq = %d)\\n\",\n\t\t(u64)par->mmio_base_phys, (ulong)par->mmio_len, par->irq);\n\n\tif (mb862xx_gdc_init(par))\n\t\tgoto io_unmap;\n\n\tif (request_irq(par->irq, mb862xx_intr, 0,\n\t\t\tDRV_NAME, (void *)par)) {\n\t\tdev_err(dev, \"Cannot request irq\\n\");\n\t\tgoto io_unmap;\n\t}\n\n\tmb862xxfb_init_fbinfo(info);\n\n\tif (fb_alloc_cmap(&info->cmap, NR_PALETTE, 0) < 0) {\n\t\tdev_err(dev, \"Could not allocate cmap for fb_info.\\n\");\n\t\tgoto free_irq;\n\t}\n\n\tif ((info->fbops->fb_set_par)(info))\n\t\tdev_err(dev, \"set_var() failed on initial setup?\\n\");\n\n\tif (register_framebuffer(info)) {\n\t\tdev_err(dev, \"failed to register framebuffer\\n\");\n\t\tgoto rel_cmap;\n\t}\n\n\tdev_set_drvdata(dev, info);\n\n\tif (device_create_file(dev, &dev_attr_dispregs))\n\t\tdev_err(dev, \"Can't create sysfs regdump file\\n\");\n\treturn 0;\n\nrel_cmap:\n\tfb_dealloc_cmap(&info->cmap);\nfree_irq:\n\toutreg(host, GC_IMASK, 0);\n\tfree_irq(par->irq, (void *)par);\nio_unmap:\n\tiounmap(par->mmio_base);\nfb_unmap:\n\tiounmap(par->fb_base);\nrel_reg:\n\trelease_mem_region(res.start, res_size);\nirqdisp:\n\tirq_dispose_mapping(par->irq);\nfbrel:\n\tframebuffer_release(info);\n\treturn ret;\n}\n\nstatic void of_platform_mb862xx_remove(struct platform_device *ofdev)\n{\n\tstruct fb_info *fbi = dev_get_drvdata(&ofdev->dev);\n\tstruct mb862xxfb_par *par = fbi->par;\n\tresource_size_t res_size = resource_size(par->res);\n\tunsigned long reg;\n\n\tfb_dbg(fbi, \"%s release\\n\", fbi->fix.id);\n\n\t \n\treg = inreg(disp, GC_DCM1);\n\treg &= ~(GC_DCM01_DEN | GC_DCM01_L0E);\n\toutreg(disp, GC_DCM1, reg);\n\n\t \n\toutreg(host, GC_IMASK, 0);\n\n\tfree_irq(par->irq, (void *)par);\n\tirq_dispose_mapping(par->irq);\n\n\tdevice_remove_file(&ofdev->dev, &dev_attr_dispregs);\n\n\tunregister_framebuffer(fbi);\n\tfb_dealloc_cmap(&fbi->cmap);\n\n\tiounmap(par->mmio_base);\n\tiounmap(par->fb_base);\n\n\trelease_mem_region(par->res->start, res_size);\n\tframebuffer_release(fbi);\n}\n\n \nstatic struct of_device_id of_platform_mb862xx_tbl[] = {\n\t{ .compatible = \"fujitsu,MB86276\", },\n\t{ .compatible = \"fujitsu,lime\", },\n\t{ .compatible = \"fujitsu,MB86277\", },\n\t{ .compatible = \"fujitsu,mint\", },\n\t{ .compatible = \"fujitsu,MB86293\", },\n\t{ .compatible = \"fujitsu,MB86294\", },\n\t{ .compatible = \"fujitsu,coral\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_platform_mb862xx_tbl);\n\nstatic struct platform_driver of_platform_mb862xxfb_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = of_platform_mb862xx_tbl,\n\t},\n\t.probe\t\t= of_platform_mb862xx_probe,\n\t.remove_new\t= of_platform_mb862xx_remove,\n};\n#endif\n\n#if defined(CONFIG_FB_MB862XX_PCI_GDC)\nstatic int coralp_init(struct mb862xxfb_par *par)\n{\n\tint cn, ver;\n\n\tpar->host = par->mmio_base;\n\tpar->i2c = par->mmio_base + MB862XX_I2C_BASE;\n\tpar->disp = par->mmio_base + MB862XX_DISP_BASE;\n\tpar->cap = par->mmio_base + MB862XX_CAP_BASE;\n\tpar->draw = par->mmio_base + MB862XX_DRAW_BASE;\n\tpar->geo = par->mmio_base + MB862XX_GEO_BASE;\n\tpar->pio = par->mmio_base + MB862XX_PIO_BASE;\n\n\tpar->refclk = GC_DISP_REFCLK_400;\n\n\tif (par->mapped_vram >= 0x2000000) {\n\t\t \n\t\twritel(1, par->fb_base + MB862XX_MMIO_BASE + GC_RSW);\n\t\tudelay(1);  \n\t}\n\n\tver = inreg(host, GC_CID);\n\tcn = (ver & GC_CID_CNAME_MSK) >> 8;\n\tver = ver & GC_CID_VERSION_MSK;\n\tif (cn == 3) {\n\t\tunsigned long reg;\n\n\t\tdev_info(par->dev, \"Fujitsu Coral-%s GDC Rev.%d found\\n\",\\\n\t\t\t (ver == 6) ? \"P\" : (ver == 8) ? \"PA\" : \"?\",\n\t\t\t par->pdev->revision);\n\t\treg = inreg(disp, GC_DCM1);\n\t\tif (reg & GC_DCM01_DEN && reg & GC_DCM01_L0E)\n\t\t\tpar->pre_init = 1;\n\n\t\tif (!par->pre_init) {\n\t\t\toutreg(host, GC_CCF, GC_CCF_CGE_166 | GC_CCF_COT_133);\n\t\t\tudelay(200);\n\t\t\toutreg(host, GC_MMR, GC_MMR_CORALP_EVB_VAL);\n\t\t\tudelay(10);\n\t\t}\n\t\t \n\t\toutreg(host, GC_IST, 0);\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\tmb862xx_i2c_init(par);\n\treturn 0;\n}\n\nstatic int init_dram_ctrl(struct mb862xxfb_par *par)\n{\n\tunsigned long i = 0;\n\n\t \n\toutreg(dram_ctrl, GC_DCTL_IOCONT1_IOCONT0, GC_EVB_DCTL_IOCONT1_IOCONT0);\n\n\t \n\toutreg(dram_ctrl, GC_DCTL_MODE_ADD, GC_EVB_DCTL_MODE_ADD);\n\toutreg(dram_ctrl, GC_DCTL_SETTIME1_EMODE, GC_EVB_DCTL_SETTIME1_EMODE);\n\toutreg(dram_ctrl, GC_DCTL_REFRESH_SETTIME2,\n\t       GC_EVB_DCTL_REFRESH_SETTIME2);\n\toutreg(dram_ctrl, GC_DCTL_RSV2_RSV1, GC_EVB_DCTL_RSV2_RSV1);\n\toutreg(dram_ctrl, GC_DCTL_DDRIF2_DDRIF1, GC_EVB_DCTL_DDRIF2_DDRIF1);\n\toutreg(dram_ctrl, GC_DCTL_RSV0_STATES, GC_EVB_DCTL_RSV0_STATES);\n\n\t \n\twhile ((inreg(dram_ctrl, GC_DCTL_RSV0_STATES) & GC_DCTL_STATES_MSK)) {\n\t\tudelay(GC_DCTL_INIT_WAIT_INTERVAL);\n\t\tif (i++ > GC_DCTL_INIT_WAIT_CNT) {\n\t\t\tdev_err(par->dev, \"VRAM init failed.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\toutreg(dram_ctrl, GC_DCTL_MODE_ADD, GC_EVB_DCTL_MODE_ADD_AFT_RST);\n\toutreg(dram_ctrl, GC_DCTL_RSV0_STATES, GC_EVB_DCTL_RSV0_STATES_AFT_RST);\n\treturn 0;\n}\n\nstatic int carmine_init(struct mb862xxfb_par *par)\n{\n\tunsigned long reg;\n\n\tpar->ctrl = par->mmio_base + MB86297_CTRL_BASE;\n\tpar->i2c = par->mmio_base + MB86297_I2C_BASE;\n\tpar->disp = par->mmio_base + MB86297_DISP0_BASE;\n\tpar->disp1 = par->mmio_base + MB86297_DISP1_BASE;\n\tpar->cap = par->mmio_base + MB86297_CAP0_BASE;\n\tpar->cap1 = par->mmio_base + MB86297_CAP1_BASE;\n\tpar->draw = par->mmio_base + MB86297_DRAW_BASE;\n\tpar->dram_ctrl = par->mmio_base + MB86297_DRAMCTRL_BASE;\n\tpar->wrback = par->mmio_base + MB86297_WRBACK_BASE;\n\n\tpar->refclk = GC_DISP_REFCLK_533;\n\n\t \n\treg = GC_CTRL_CLK_EN_DRAM | GC_CTRL_CLK_EN_2D3D | GC_CTRL_CLK_EN_DISP0;\n\toutreg(ctrl, GC_CTRL_CLK_ENABLE, reg);\n\n\t \n\tif (inreg(draw, GC_2D3D_REV) == GC_RE_REVISION)\n\t\tdev_info(par->dev, \"Fujitsu Carmine GDC Rev.%d found\\n\",\n\t\t\t par->pdev->revision);\n\telse\n\t\tgoto err_init;\n\n\treg &= ~GC_CTRL_CLK_EN_2D3D;\n\toutreg(ctrl, GC_CTRL_CLK_ENABLE, reg);\n\n\t \n\tif (init_dram_ctrl(par) < 0)\n\t\tgoto err_init;\n\n\toutreg(ctrl, GC_CTRL_INT_MASK, 0);\n\treturn 0;\n\nerr_init:\n\toutreg(ctrl, GC_CTRL_CLK_ENABLE, 0);\n\treturn -EINVAL;\n}\n\nstatic inline int mb862xx_pci_gdc_init(struct mb862xxfb_par *par)\n{\n\tswitch (par->type) {\n\tcase BT_CORALP:\n\t\treturn coralp_init(par);\n\tcase BT_CARMINE:\n\t\treturn carmine_init(par);\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\n\n#define CHIP_ID(id)\t\\\n\t{ PCI_DEVICE(PCI_VENDOR_ID_FUJITSU_LIMITED, id) }\n\nstatic const struct pci_device_id mb862xx_pci_tbl[] = {\n\t \n\tCHIP_ID(PCI_DEVICE_ID_FUJITSU_CORALP),\n\tCHIP_ID(PCI_DEVICE_ID_FUJITSU_CORALPA),\n\t \n\tCHIP_ID(PCI_DEVICE_ID_FUJITSU_CARMINE),\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, mb862xx_pci_tbl);\n\nstatic int mb862xx_pci_probe(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *ent)\n{\n\tstruct mb862xxfb_par *par;\n\tstruct fb_info *info;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tret = aperture_remove_conflicting_pci_devices(pdev, \"mb862xxfb\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot enable PCI device\\n\");\n\t\tgoto out;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct mb862xxfb_par), dev);\n\tif (!info) {\n\t\tret = -ENOMEM;\n\t\tgoto dis_dev;\n\t}\n\n\tpar = info->par;\n\tpar->info = info;\n\tpar->dev = dev;\n\tpar->pdev = pdev;\n\tpar->irq = pdev->irq;\n\n\tret = pci_request_regions(pdev, DRV_NAME);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot reserve region(s) for PCI device\\n\");\n\t\tgoto rel_fb;\n\t}\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_FUJITSU_CORALP:\n\tcase PCI_DEVICE_ID_FUJITSU_CORALPA:\n\t\tpar->fb_base_phys = pci_resource_start(par->pdev, 0);\n\t\tpar->mapped_vram = CORALP_MEM_SIZE;\n\t\tif (par->mapped_vram >= 0x2000000) {\n\t\t\tpar->mmio_base_phys = par->fb_base_phys +\n\t\t\t\t\t      MB862XX_MMIO_HIGH_BASE;\n\t\t} else {\n\t\t\tpar->mmio_base_phys = par->fb_base_phys +\n\t\t\t\t\t      MB862XX_MMIO_BASE;\n\t\t}\n\t\tpar->mmio_len = MB862XX_MMIO_SIZE;\n\t\tpar->type = BT_CORALP;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_FUJITSU_CARMINE:\n\t\tpar->fb_base_phys = pci_resource_start(par->pdev, 2);\n\t\tpar->mmio_base_phys = pci_resource_start(par->pdev, 3);\n\t\tpar->mmio_len = pci_resource_len(par->pdev, 3);\n\t\tpar->mapped_vram = CARMINE_MEM_SIZE;\n\t\tpar->type = BT_CARMINE;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret = -EIO;\n\t\tgoto rel_reg;\n\t}\n\n\tpar->fb_base = ioremap(par->fb_base_phys, par->mapped_vram);\n\tif (par->fb_base == NULL) {\n\t\tdev_err(dev, \"Cannot map framebuffer\\n\");\n\t\tret = -EIO;\n\t\tgoto rel_reg;\n\t}\n\n\tpar->mmio_base = ioremap(par->mmio_base_phys, par->mmio_len);\n\tif (par->mmio_base == NULL) {\n\t\tdev_err(dev, \"Cannot map registers\\n\");\n\t\tret = -EIO;\n\t\tgoto fb_unmap;\n\t}\n\n\tdev_dbg(dev, \"fb phys 0x%llx 0x%lx\\n\",\n\t\t(unsigned long long)par->fb_base_phys, (ulong)par->mapped_vram);\n\tdev_dbg(dev, \"mmio phys 0x%llx 0x%lx\\n\",\n\t\t(unsigned long long)par->mmio_base_phys, (ulong)par->mmio_len);\n\n\tret = mb862xx_pci_gdc_init(par);\n\tif (ret)\n\t\tgoto io_unmap;\n\n\tret = request_irq(par->irq, mb862xx_intr, IRQF_SHARED,\n\t\t\t  DRV_NAME, (void *)par);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot request irq\\n\");\n\t\tgoto io_unmap;\n\t}\n\n\tmb862xxfb_init_fbinfo(info);\n\n\tif (fb_alloc_cmap(&info->cmap, NR_PALETTE, 0) < 0) {\n\t\tdev_err(dev, \"Could not allocate cmap for fb_info.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_irq;\n\t}\n\n\tif ((info->fbops->fb_set_par)(info))\n\t\tdev_err(dev, \"set_var() failed on initial setup?\\n\");\n\n\tret = register_framebuffer(info);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register framebuffer\\n\");\n\t\tgoto rel_cmap;\n\t}\n\n\tpci_set_drvdata(pdev, info);\n\n\tif (device_create_file(dev, &dev_attr_dispregs))\n\t\tdev_err(dev, \"Can't create sysfs regdump file\\n\");\n\n\tif (par->type == BT_CARMINE)\n\t\toutreg(ctrl, GC_CTRL_INT_MASK, GC_CARMINE_INT_EN);\n\telse\n\t\toutreg(host, GC_IMASK, GC_INT_EN);\n\n\treturn 0;\n\nrel_cmap:\n\tfb_dealloc_cmap(&info->cmap);\nfree_irq:\n\tfree_irq(par->irq, (void *)par);\nio_unmap:\n\tiounmap(par->mmio_base);\nfb_unmap:\n\tiounmap(par->fb_base);\nrel_reg:\n\tpci_release_regions(pdev);\nrel_fb:\n\tframebuffer_release(info);\ndis_dev:\n\tpci_disable_device(pdev);\nout:\n\treturn ret;\n}\n\nstatic void mb862xx_pci_remove(struct pci_dev *pdev)\n{\n\tstruct fb_info *fbi = pci_get_drvdata(pdev);\n\tstruct mb862xxfb_par *par = fbi->par;\n\tunsigned long reg;\n\n\tfb_dbg(fbi, \"%s release\\n\", fbi->fix.id);\n\n\t \n\treg = inreg(disp, GC_DCM1);\n\treg &= ~(GC_DCM01_DEN | GC_DCM01_L0E);\n\toutreg(disp, GC_DCM1, reg);\n\n\tif (par->type == BT_CARMINE) {\n\t\toutreg(ctrl, GC_CTRL_INT_MASK, 0);\n\t\toutreg(ctrl, GC_CTRL_CLK_ENABLE, 0);\n\t} else {\n\t\toutreg(host, GC_IMASK, 0);\n\t}\n\n\tmb862xx_i2c_exit(par);\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_dispregs);\n\n\tunregister_framebuffer(fbi);\n\tfb_dealloc_cmap(&fbi->cmap);\n\n\tfree_irq(par->irq, (void *)par);\n\tiounmap(par->mmio_base);\n\tiounmap(par->fb_base);\n\n\tpci_release_regions(pdev);\n\tframebuffer_release(fbi);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_driver mb862xxfb_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= mb862xx_pci_tbl,\n\t.probe\t\t= mb862xx_pci_probe,\n\t.remove\t\t= mb862xx_pci_remove,\n};\n#endif\n\nstatic int mb862xxfb_init(void)\n{\n\tint ret = -ENODEV;\n\n\tif (fb_modesetting_disabled(DRV_NAME))\n\t\treturn -ENODEV;\n\n#if defined(CONFIG_FB_MB862XX_LIME)\n\tret = platform_driver_register(&of_platform_mb862xxfb_driver);\n#endif\n#if defined(CONFIG_FB_MB862XX_PCI_GDC)\n\tret = pci_register_driver(&mb862xxfb_pci_driver);\n#endif\n\treturn ret;\n}\n\nstatic void __exit mb862xxfb_exit(void)\n{\n#if defined(CONFIG_FB_MB862XX_LIME)\n\tplatform_driver_unregister(&of_platform_mb862xxfb_driver);\n#endif\n#if defined(CONFIG_FB_MB862XX_PCI_GDC)\n\tpci_unregister_driver(&mb862xxfb_pci_driver);\n#endif\n}\n\nmodule_init(mb862xxfb_init);\nmodule_exit(mb862xxfb_exit);\n\nMODULE_DESCRIPTION(\"Fujitsu MB862xx Framebuffer driver\");\nMODULE_AUTHOR(\"Anatolij Gustschin <agust@denx.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}