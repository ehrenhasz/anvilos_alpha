{
  "module_name": "mb862xxfb_accel.c",
  "hash_id": "624e8beacd089ceca35329ade1d5b271bf77b11ed09df8b3102b4687d5b6bb5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/mb862xx/mb862xxfb_accel.c",
  "human_readable_source": "\n \n#include <linux/fb.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include \"mb862xxfb.h\"\n#include \"mb862xx_reg.h\"\n#include \"mb862xxfb_accel.h\"\n\nstatic void mb862xxfb_write_fifo(u32 count, u32 *data, struct fb_info *info)\n{\n\tstruct mb862xxfb_par *par = info->par;\n\tstatic u32 free;\n\n\tu32 total = 0;\n\twhile (total < count) {\n\t\tif (free) {\n\t\t\toutreg(geo, GDC_GEO_REG_INPUT_FIFO, data[total]);\n\t\t\ttotal++;\n\t\t\tfree--;\n\t\t} else {\n\t\t\tfree = (u32) inreg(draw, GDC_REG_FIFO_COUNT);\n\t\t}\n\t}\n}\n\nstatic void mb86290fb_copyarea(struct fb_info *info,\n\t\t\t       const struct fb_copyarea *area)\n{\n\t__u32 cmd[6];\n\n\tcmd[0] = (GDC_TYPE_SETREGISTER << 24) | (1 << 16) | GDC_REG_MODE_BITMAP;\n\t \n\tcmd[1] = (2 << 7) | (GDC_ROP_COPY << 9);\n\tcmd[2] = GDC_TYPE_BLTCOPYP << 24;\n\n\tif (area->sx >= area->dx && area->sy >= area->dy)\n\t\tcmd[2] |= GDC_CMD_BLTCOPY_TOP_LEFT << 16;\n\telse if (area->sx >= area->dx && area->sy <= area->dy)\n\t\tcmd[2] |= GDC_CMD_BLTCOPY_BOTTOM_LEFT << 16;\n\telse if (area->sx <= area->dx && area->sy >= area->dy)\n\t\tcmd[2] |= GDC_CMD_BLTCOPY_TOP_RIGHT << 16;\n\telse\n\t\tcmd[2] |= GDC_CMD_BLTCOPY_BOTTOM_RIGHT << 16;\n\n\tcmd[3] = (area->sy << 16) | area->sx;\n\tcmd[4] = (area->dy << 16) | area->dx;\n\tcmd[5] = (area->height << 16) | area->width;\n\tmb862xxfb_write_fifo(6, cmd, info);\n}\n\n \nstatic void mb86290fb_imageblit1(u32 *cmd, u16 step, u16 dx, u16 dy,\n\t\t\t\t u16 width, u16 height, u32 fgcolor,\n\t\t\t\t u32 bgcolor, const struct fb_image *image,\n\t\t\t\t struct fb_info *info)\n{\n\tint i;\n\tunsigned const char *line;\n\tu16 bytes;\n\n\t \n\tcmd[0] = (GDC_TYPE_SETREGISTER << 24) | (1 << 16) | GDC_REG_MODE_BITMAP;\n\t \n\tcmd[1] = (2 << 7) | (GDC_ROP_COPY << 9);\n\tcmd[2] =\n\t    (GDC_TYPE_SETCOLORREGISTER << 24) | (GDC_CMD_BODY_FORE_COLOR << 16);\n\tcmd[3] = fgcolor;\n\tcmd[4] =\n\t    (GDC_TYPE_SETCOLORREGISTER << 24) | (GDC_CMD_BODY_BACK_COLOR << 16);\n\tcmd[5] = bgcolor;\n\n\ti = 0;\n\tline = image->data;\n\tbytes = (image->width + 7) >> 3;\n\n\t \n\tcmd[6] = (GDC_TYPE_DRAWBITMAPP << 24) |\n\t    (GDC_CMD_BITMAP << 16) | (2 + (step * height));\n\tcmd[7] = (dy << 16) | dx;\n\tcmd[8] = (height << 16) | width;\n\n\twhile (i < height) {\n\t\tmemcpy(&cmd[9 + i * step], line, step << 2);\n#ifdef __LITTLE_ENDIAN\n\t\t{\n\t\t\tint k = 0;\n\t\t\tfor (k = 0; k < step; k++)\n\t\t\t\tcmd[9 + i * step + k] =\n\t\t\t\t    cpu_to_be32(cmd[9 + i * step + k]);\n\t\t}\n#endif\n\t\tline += bytes;\n\t\ti++;\n\t}\n}\n\n \nstatic void mb86290fb_imageblit8(u32 *cmd, u16 step, u16 dx, u16 dy,\n\t\t\t\t u16 width, u16 height, u32 fgcolor,\n\t\t\t\t u32 bgcolor, const struct fb_image *image,\n\t\t\t\t struct fb_info *info)\n{\n\tint i, j;\n\tunsigned const char *line, *ptr;\n\tu16 bytes;\n\n\tcmd[0] = (GDC_TYPE_DRAWBITMAPP << 24) |\n\t    (GDC_CMD_BLT_DRAW << 16) | (2 + (height * step));\n\tcmd[1] = (dy << 16) | dx;\n\tcmd[2] = (height << 16) | width;\n\n\ti = 0;\n\tline = image->data;\n\tbytes = image->width;\n\n\twhile (i < height) {\n\t\tptr = line;\n\t\tfor (j = 0; j < step; j++) {\n\t\t\tcmd[3 + i * step + j] =\n\t\t\t    (((u32 *) (info->pseudo_palette))[*ptr]) & 0xffff;\n\t\t\tptr++;\n\t\t\tcmd[3 + i * step + j] |=\n\t\t\t    ((((u32 *) (info->\n\t\t\t\t\tpseudo_palette))[*ptr]) & 0xffff) << 16;\n\t\t\tptr++;\n\t\t}\n\n\t\tline += bytes;\n\t\ti++;\n\t}\n}\n\n \nstatic void mb86290fb_imageblit16(u32 *cmd, u16 step, u16 dx, u16 dy,\n\t\t\t\t  u16 width, u16 height, u32 fgcolor,\n\t\t\t\t  u32 bgcolor, const struct fb_image *image,\n\t\t\t\t  struct fb_info *info)\n{\n\tint i;\n\tunsigned const char *line;\n\tu16 bytes;\n\n\ti = 0;\n\tline = image->data;\n\tbytes = image->width << 1;\n\n\tcmd[0] = (GDC_TYPE_DRAWBITMAPP << 24) |\n\t    (GDC_CMD_BLT_DRAW << 16) | (2 + step * height);\n\tcmd[1] = (dy << 16) | dx;\n\tcmd[2] = (height << 16) | width;\n\n\twhile (i < height) {\n\t\tmemcpy(&cmd[3 + i * step], line, step);\n\t\tline += bytes;\n\t\ti++;\n\t}\n}\n\nstatic void mb86290fb_imageblit(struct fb_info *info,\n\t\t\t\tconst struct fb_image *image)\n{\n\tu32 *cmd = NULL;\n\tvoid (*cmdfn) (u32 *, u16, u16, u16, u16, u16, u32, u32,\n\t\t       const struct fb_image *, struct fb_info *) = NULL;\n\tu32 cmdlen;\n\tu32 fgcolor = 0, bgcolor = 0;\n\tu16 step;\n\n\tu16 width = image->width, height = image->height;\n\tu16 dx = image->dx, dy = image->dy;\n\tint x2, y2, vxres, vyres;\n\n\tx2 = image->dx + image->width;\n\ty2 = image->dy + image->height;\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\tx2 = min(x2, vxres);\n\ty2 = min(y2, vyres);\n\twidth = x2 - dx;\n\theight = y2 - dy;\n\n\tswitch (image->depth) {\n\tcase 1:\n\t\tstep = (width + 31) >> 5;\n\t\tcmdlen = 9 + height * step;\n\t\tcmdfn = mb86290fb_imageblit1;\n\t\tif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\n\t\t    info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\t\tfgcolor =\n\t\t\t    ((u32 *) (info->pseudo_palette))[image->fg_color];\n\t\t\tbgcolor =\n\t\t\t    ((u32 *) (info->pseudo_palette))[image->bg_color];\n\t\t} else {\n\t\t\tfgcolor = image->fg_color;\n\t\t\tbgcolor = image->bg_color;\n\t\t}\n\n\t\tbreak;\n\n\tcase 8:\n\t\tstep = (width + 1) >> 1;\n\t\tcmdlen = 3 + height * step;\n\t\tcmdfn = mb86290fb_imageblit8;\n\t\tbreak;\n\n\tcase 16:\n\t\tstep = (width + 1) >> 1;\n\t\tcmdlen = 3 + height * step;\n\t\tcmdfn = mb86290fb_imageblit16;\n\t\tbreak;\n\n\tdefault:\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\n\tcmd = kmalloc_array(cmdlen, 4, GFP_DMA);\n\tif (!cmd)\n\t\treturn cfb_imageblit(info, image);\n\tcmdfn(cmd, step, dx, dy, width, height, fgcolor, bgcolor, image, info);\n\tmb862xxfb_write_fifo(cmdlen, cmd, info);\n\tkfree(cmd);\n}\n\nstatic void mb86290fb_fillrect(struct fb_info *info,\n\t\t\t       const struct fb_fillrect *rect)\n{\n\n\tu32 x2, y2, vxres, vyres, height, width, fg;\n\tu32 cmd[7];\n\n\tvxres = info->var.xres_virtual;\n\tvyres = info->var.yres_virtual;\n\n\tif (!rect->width || !rect->height || rect->dx > vxres\n\t    || rect->dy > vyres)\n\t\treturn;\n\n\t \n\tx2 = rect->dx + rect->width;\n\ty2 = rect->dy + rect->height;\n\tx2 = min(x2, vxres);\n\ty2 = min(y2, vyres);\n\twidth = x2 - rect->dx;\n\theight = y2 - rect->dy;\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\n\t    info->fix.visual == FB_VISUAL_DIRECTCOLOR)\n\t\tfg = ((u32 *) (info->pseudo_palette))[rect->color];\n\telse\n\t\tfg = rect->color;\n\n\tswitch (rect->rop) {\n\n\tcase ROP_XOR:\n\t\t \n\t\tcmd[1] = (2 << 7) | (GDC_ROP_XOR << 9);\n\t\tbreak;\n\n\tcase ROP_COPY:\n\t\t \n\t\tcmd[1] = (2 << 7) | (GDC_ROP_COPY << 9);\n\t\tbreak;\n\n\t}\n\n\tcmd[0] = (GDC_TYPE_SETREGISTER << 24) | (1 << 16) | GDC_REG_MODE_BITMAP;\n\t \n\tcmd[2] =\n\t    (GDC_TYPE_SETCOLORREGISTER << 24) | (GDC_CMD_BODY_FORE_COLOR << 16);\n\tcmd[3] = fg;\n\tcmd[4] = (GDC_TYPE_DRAWRECTP << 24) | (GDC_CMD_BLT_FILL << 16);\n\tcmd[5] = (rect->dy << 16) | (rect->dx);\n\tcmd[6] = (height << 16) | width;\n\n\tmb862xxfb_write_fifo(7, cmd, info);\n}\n\nvoid mb862xxfb_init_accel(struct fb_info *info, struct fb_ops *fbops, int xres)\n{\n\tstruct mb862xxfb_par *par = info->par;\n\n\tif (info->var.bits_per_pixel == 32) {\n\t\tfbops->fb_fillrect = cfb_fillrect;\n\t\tfbops->fb_copyarea = cfb_copyarea;\n\t\tfbops->fb_imageblit = cfb_imageblit;\n\t} else {\n\t\toutreg(disp, GC_L0EM, 3);\n\t\tfbops->fb_fillrect = mb86290fb_fillrect;\n\t\tfbops->fb_copyarea = mb86290fb_copyarea;\n\t\tfbops->fb_imageblit = mb86290fb_imageblit;\n\t}\n\toutreg(draw, GDC_REG_DRAW_BASE, 0);\n\toutreg(draw, GDC_REG_MODE_MISC, 0x8000);\n\toutreg(draw, GDC_REG_X_RESOLUTION, xres);\n\n\tinfo->flags |=\n\t    FBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |\n\t    FBINFO_HWACCEL_IMAGEBLIT;\n\tinfo->fix.accel = 0xff;\t \n}\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}