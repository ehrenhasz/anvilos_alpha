{
  "module_name": "hitfb.c",
  "hash_id": "d66a9da81804efe40b43985dd37be799654a38db948b8563394e1fb4af16013d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/hitfb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/fb.h>\n\n#include <asm/machvec.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <asm/hd64461.h>\n#include <cpu/dac.h>\n\n#define\tWIDTH 640\n\nstatic struct fb_var_screeninfo hitfb_var = {\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\nstatic struct fb_fix_screeninfo hitfb_fix = {\n\t.id\t\t= \"Hitachi HD64461\",\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.accel\t\t= FB_ACCEL_NONE,\n};\n\nstatic volatile void __iomem *hitfb_offset_to_addr(unsigned int offset)\n{\n\treturn (__force volatile void __iomem *)(uintptr_t)offset;\n}\n\nstatic u16 hitfb_readw(unsigned int offset)\n{\n\treturn fb_readw(hitfb_offset_to_addr(offset));\n}\n\nstatic void hitfb_writew(u16 value, unsigned int offset)\n{\n\tfb_writew(value, hitfb_offset_to_addr(offset));\n}\n\nstatic inline void hitfb_accel_wait(void)\n{\n\twhile (hitfb_readw(HD64461_GRCFGR) & HD64461_GRCFGR_ACCSTATUS)\n\t\t;\n}\n\nstatic inline void hitfb_accel_start(int truecolor)\n{\n\tif (truecolor) {\n\t\thitfb_writew(6, HD64461_GRCFGR);\n\t} else {\n\t\thitfb_writew(7, HD64461_GRCFGR);\n\t}\n}\n\nstatic inline void hitfb_accel_set_dest(int truecolor, u16 dx, u16 dy,\n\t\t\t\t\tu16 width, u16 height)\n{\n\tu32 saddr = WIDTH * dy + dx;\n\tif (truecolor)\n\t\tsaddr <<= 1;\n\n\thitfb_writew(width-1, HD64461_BBTDWR);\n\thitfb_writew(height-1, HD64461_BBTDHR);\n\n\thitfb_writew(saddr & 0xffff, HD64461_BBTDSARL);\n\thitfb_writew(saddr >> 16, HD64461_BBTDSARH);\n\n}\n\nstatic inline void hitfb_accel_bitblt(int truecolor, u16 sx, u16 sy, u16 dx,\n\t\t\t\t      u16 dy, u16 width, u16 height, u16 rop,\n\t\t\t\t      u32 mask_addr)\n{\n\tu32 saddr, daddr;\n\tu32 maddr = 0;\n\n\theight--;\n\twidth--;\n\thitfb_writew(rop, HD64461_BBTROPR);\n\tif ((sy < dy) || ((sy == dy) && (sx <= dx))) {\n\t\tsaddr = WIDTH * (sy + height) + sx + width;\n\t\tdaddr = WIDTH * (dy + height) + dx + width;\n\t\tif (mask_addr) {\n\t\t\tif (truecolor)\n\t\t\t\tmaddr = ((width >> 3) + 1) * (height + 1) - 1;\n\t\t\telse\n\t\t\t\tmaddr =\n\t\t\t\t    (((width >> 4) + 1) * (height + 1) - 1) * 2;\n\n\t\t\thitfb_writew((1 << 5) | 1, HD64461_BBTMDR);\n\t\t} else\n\t\t\thitfb_writew(1, HD64461_BBTMDR);\n\t} else {\n\t\tsaddr = WIDTH * sy + sx;\n\t\tdaddr = WIDTH * dy + dx;\n\t\tif (mask_addr) {\n\t\t\thitfb_writew((1 << 5), HD64461_BBTMDR);\n\t\t} else {\n\t\t\thitfb_writew(0, HD64461_BBTMDR);\n\t\t}\n\t}\n\tif (truecolor) {\n\t\tsaddr <<= 1;\n\t\tdaddr <<= 1;\n\t}\n\thitfb_writew(width, HD64461_BBTDWR);\n\thitfb_writew(height, HD64461_BBTDHR);\n\thitfb_writew(saddr & 0xffff, HD64461_BBTSSARL);\n\thitfb_writew(saddr >> 16, HD64461_BBTSSARH);\n\thitfb_writew(daddr & 0xffff, HD64461_BBTDSARL);\n\thitfb_writew(daddr >> 16, HD64461_BBTDSARH);\n\tif (mask_addr) {\n\t\tmaddr += mask_addr;\n\t\thitfb_writew(maddr & 0xffff, HD64461_BBTMARL);\n\t\thitfb_writew(maddr >> 16, HD64461_BBTMARH);\n\t}\n\thitfb_accel_start(truecolor);\n}\n\nstatic void hitfb_fillrect(struct fb_info *p, const struct fb_fillrect *rect)\n{\n\tif (rect->rop != ROP_COPY)\n\t\tcfb_fillrect(p, rect);\n\telse {\n\t\thitfb_accel_wait();\n\t\thitfb_writew(0x00f0, HD64461_BBTROPR);\n\t\thitfb_writew(16, HD64461_BBTMDR);\n\n\t\tif (p->var.bits_per_pixel == 16) {\n\t\t\thitfb_writew(((u32 *) (p->pseudo_palette))[rect->color],\n\t\t\t\t  HD64461_GRSCR);\n\t\t\thitfb_accel_set_dest(1, rect->dx, rect->dy, rect->width,\n\t\t\t\t\t     rect->height);\n\t\t\thitfb_accel_start(1);\n\t\t} else {\n\t\t\thitfb_writew(rect->color, HD64461_GRSCR);\n\t\t\thitfb_accel_set_dest(0, rect->dx, rect->dy, rect->width,\n\t\t\t\t\t     rect->height);\n\t\t\thitfb_accel_start(0);\n\t\t}\n\t}\n}\n\nstatic void hitfb_copyarea(struct fb_info *p, const struct fb_copyarea *area)\n{\n\thitfb_accel_wait();\n\thitfb_accel_bitblt(p->var.bits_per_pixel == 16, area->sx, area->sy,\n\t\t\t   area->dx, area->dy, area->width, area->height,\n\t\t\t   0x00cc, 0);\n}\n\nstatic int hitfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)\n{\n\tint xoffset = var->xoffset;\n\tint yoffset = var->yoffset;\n\n\tif (xoffset != 0)\n\t\treturn -EINVAL;\n\n\thitfb_writew((yoffset*info->fix.line_length)>>10, HD64461_LCDCBAR);\n\n\treturn 0;\n}\n\nstatic int hitfb_blank(int blank_mode, struct fb_info *info)\n{\n\tunsigned short v;\n\n\tif (blank_mode) {\n\t\tv = hitfb_readw(HD64461_LDR1);\n\t\tv &= ~HD64461_LDR1_DON;\n\t\thitfb_writew(v, HD64461_LDR1);\n\n\t\tv = hitfb_readw(HD64461_LCDCCR);\n\t\tv |= HD64461_LCDCCR_MOFF;\n\t\thitfb_writew(v, HD64461_LCDCCR);\n\n\t\tv = hitfb_readw(HD64461_STBCR);\n\t\tv |= HD64461_STBCR_SLCDST;\n\t\thitfb_writew(v, HD64461_STBCR);\n\t} else {\n\t\tv = hitfb_readw(HD64461_STBCR);\n\t\tv &= ~HD64461_STBCR_SLCDST;\n\t\thitfb_writew(v, HD64461_STBCR);\n\n\t\tv = hitfb_readw(HD64461_LCDCCR);\n\t\tv &= ~(HD64461_LCDCCR_MOFF | HD64461_LCDCCR_STREQ);\n\t\thitfb_writew(v, HD64461_LCDCCR);\n\n\t\tdo {\n\t\t    v = hitfb_readw(HD64461_LCDCCR);\n\t\t} while(v&HD64461_LCDCCR_STBACK);\n\n\t\tv = hitfb_readw(HD64461_LDR1);\n\t\tv |= HD64461_LDR1_DON;\n\t\thitfb_writew(v, HD64461_LDR1);\n\t}\n\treturn 0;\n}\n\nstatic int hitfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t   unsigned blue, unsigned transp, struct fb_info *info)\n{\n\tif (regno >= 256)\n\t\treturn 1;\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\thitfb_writew(regno << 8, HD64461_CPTWAR);\n\t\thitfb_writew(red >> 10, HD64461_CPTWDR);\n\t\thitfb_writew(green >> 10, HD64461_CPTWDR);\n\t\thitfb_writew(blue >> 10, HD64461_CPTWDR);\n\t\tbreak;\n\tcase 16:\n\t\tif (regno >= 16)\n\t\t\treturn 1;\n\t\t((u32 *) (info->pseudo_palette))[regno] =\n\t\t    ((red & 0xf800)) |\n\t\t    ((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int hitfb_sync(struct fb_info *info)\n{\n\thitfb_accel_wait();\n\n\treturn 0;\n}\n\nstatic int hitfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tint maxy;\n\n\tvar->xres = info->var.xres;\n\tvar->xres_virtual = info->var.xres;\n\tvar->yres = info->var.yres;\n\n\tif ((var->bits_per_pixel != 8) && (var->bits_per_pixel != 16))\n\t\tvar->bits_per_pixel = info->var.bits_per_pixel;\n\n\tif (var->yres_virtual < var->yres)\n\t\tvar->yres_virtual = var->yres;\n\n\tmaxy = info->fix.smem_len / var->xres;\n\n\tif (var->bits_per_pixel == 16)\n\t\tmaxy /= 2;\n\n\tif (var->yres_virtual > maxy)\n\t\tvar->yres_virtual = maxy;\n\n\tvar->xoffset = 0;\n\tvar->yoffset = 0;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset = 0;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 0;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\tcase 16:\t\t \n\t\tvar->red.offset = 11;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int hitfb_set_par(struct fb_info *info)\n{\n\tunsigned short ldr3;\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tinfo->fix.line_length = info->var.xres;\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tinfo->fix.ypanstep = 16;\n\t\tbreak;\n\tcase 16:\n\t\tinfo->fix.line_length = info->var.xres*2;\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tinfo->fix.ypanstep = 8;\n\t\tbreak;\n\t}\n\n\thitfb_writew(info->fix.line_length, HD64461_LCDCLOR);\n\tldr3 = hitfb_readw(HD64461_LDR3);\n\tldr3 &= ~15;\n\tldr3 |= (info->var.bits_per_pixel == 8) ? 4 : 8;\n\thitfb_writew(ldr3, HD64461_LDR3);\n\treturn 0;\n}\n\nstatic const struct fb_ops hitfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= hitfb_check_var,\n\t.fb_set_par\t\t= hitfb_set_par,\n\t.fb_setcolreg\t= hitfb_setcolreg,\n\t.fb_blank\t= hitfb_blank,\n\t.fb_sync\t= hitfb_sync,\n\t.fb_pan_display = hitfb_pan_display,\n\t.fb_fillrect\t= hitfb_fillrect,\n\t.fb_copyarea\t= hitfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n};\n\nstatic int hitfb_probe(struct platform_device *dev)\n{\n\tunsigned short lcdclor, ldr3, ldvndr;\n\tstruct fb_info *info;\n\tint ret;\n\n\tif (fb_get_options(\"hitfb\", NULL))\n\t\treturn -ENODEV;\n\n\thitfb_fix.mmio_start = HD64461_IO_OFFSET(0x1000);\n\thitfb_fix.mmio_len = 0x1000;\n\thitfb_fix.smem_start = HD64461_IO_OFFSET(0x02000000);\n\thitfb_fix.smem_len = 512 * 1024;\n\n\tlcdclor = hitfb_readw(HD64461_LCDCLOR);\n\tldvndr = hitfb_readw(HD64461_LDVNDR);\n\tldr3 = hitfb_readw(HD64461_LDR3);\n\n\tswitch (ldr3 & 15) {\n\tdefault:\n\tcase 4:\n\t\thitfb_var.bits_per_pixel = 8;\n\t\thitfb_var.xres = lcdclor;\n\t\tbreak;\n\tcase 8:\n\t\thitfb_var.bits_per_pixel = 16;\n\t\thitfb_var.xres = lcdclor / 2;\n\t\tbreak;\n\t}\n\thitfb_fix.line_length = lcdclor;\n\thitfb_fix.visual = (hitfb_var.bits_per_pixel == 8) ?\n\t    FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\thitfb_var.yres = ldvndr + 1;\n\thitfb_var.xres_virtual = hitfb_var.xres;\n\thitfb_var.yres_virtual = hitfb_fix.smem_len / lcdclor;\n\tswitch (hitfb_var.bits_per_pixel) {\n\tcase 8:\n\t\thitfb_var.red.offset = 0;\n\t\thitfb_var.red.length = 8;\n\t\thitfb_var.green.offset = 0;\n\t\thitfb_var.green.length = 8;\n\t\thitfb_var.blue.offset = 0;\n\t\thitfb_var.blue.length = 8;\n\t\thitfb_var.transp.offset = 0;\n\t\thitfb_var.transp.length = 0;\n\t\tbreak;\n\tcase 16:\t\t \n\t\thitfb_var.red.offset = 11;\n\t\thitfb_var.red.length = 5;\n\t\thitfb_var.green.offset = 5;\n\t\thitfb_var.green.length = 6;\n\t\thitfb_var.blue.offset = 0;\n\t\thitfb_var.blue.length = 5;\n\t\thitfb_var.transp.offset = 0;\n\t\thitfb_var.transp.length = 0;\n\t\tbreak;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(u32) * 16, &dev->dev);\n\tif (unlikely(!info))\n\t\treturn -ENOMEM;\n\n\tinfo->fbops = &hitfb_ops;\n\tinfo->var = hitfb_var;\n\tinfo->fix = hitfb_fix;\n\tinfo->pseudo_palette = info->par;\n\tinfo->flags = FBINFO_HWACCEL_YPAN |\n\t\tFBINFO_HWACCEL_FILLRECT | FBINFO_HWACCEL_COPYAREA;\n\n\tinfo->screen_base = (char __iomem *)(uintptr_t)hitfb_fix.smem_start;\n\n\tret = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (unlikely(ret < 0))\n\t\tgoto err_fb;\n\n\tret = register_framebuffer(info);\n\tif (unlikely(ret < 0))\n\t\tgoto err;\n\n\tplatform_set_drvdata(dev, info);\n\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\n\treturn 0;\n\nerr:\n\tfb_dealloc_cmap(&info->cmap);\nerr_fb:\n\tframebuffer_release(info);\n\treturn ret;\n}\n\nstatic void hitfb_remove(struct platform_device *dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\tframebuffer_release(info);\n}\n\nstatic int hitfb_suspend(struct device *dev)\n{\n\tu16 v;\n\n\thitfb_blank(1, NULL);\n\tv = hitfb_readw(HD64461_STBCR);\n\tv |= HD64461_STBCR_SLCKE_IST;\n\thitfb_writew(v, HD64461_STBCR);\n\n\treturn 0;\n}\n\nstatic int hitfb_resume(struct device *dev)\n{\n\tu16 v;\n\n\tv = hitfb_readw(HD64461_STBCR);\n\tv &= ~HD64461_STBCR_SLCKE_OST;\n\tmsleep(100);\n\tv = hitfb_readw(HD64461_STBCR);\n\tv &= ~HD64461_STBCR_SLCKE_IST;\n\thitfb_writew(v, HD64461_STBCR);\n\thitfb_blank(0, NULL);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops hitfb_dev_pm_ops = {\n\t.suspend\t= hitfb_suspend,\n\t.resume\t\t= hitfb_resume,\n};\n\nstatic struct platform_driver hitfb_driver = {\n\t.probe\t\t= hitfb_probe,\n\t.remove_new\t= hitfb_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"hitfb\",\n\t\t.pm\t= &hitfb_dev_pm_ops,\n\t},\n};\n\nstatic struct platform_device hitfb_device = {\n\t.name\t= \"hitfb\",\n\t.id\t= -1,\n};\n\nstatic int __init hitfb_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&hitfb_driver);\n\tif (!ret) {\n\t\tret = platform_device_register(&hitfb_device);\n\t\tif (ret)\n\t\t\tplatform_driver_unregister(&hitfb_driver);\n\t}\n\treturn ret;\n}\n\n\nstatic void __exit hitfb_exit(void)\n{\n\tplatform_device_unregister(&hitfb_device);\n\tplatform_driver_unregister(&hitfb_driver);\n}\n\nmodule_init(hitfb_init);\nmodule_exit(hitfb_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}