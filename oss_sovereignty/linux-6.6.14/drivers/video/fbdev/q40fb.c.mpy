{
  "module_name": "q40fb.c",
  "hash_id": "f808ad67c472c980c0315d5ead4e2a5207bd006052347c3f0d32dba60708ebaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/q40fb.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n\n#include <linux/uaccess.h>\n#include <asm/setup.h>\n#include <asm/q40_master.h>\n#include <linux/fb.h>\n#include <linux/module.h>\n\n#define Q40_PHYS_SCREEN_ADDR 0xFE800000\n\nstatic struct fb_fix_screeninfo q40fb_fix = {\n\t.id\t\t= \"Q40\",\n\t.smem_len\t= 1024*1024,\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.visual\t\t= FB_VISUAL_TRUECOLOR,\n\t.line_length\t= 1024*2,\n\t.accel\t\t= FB_ACCEL_NONE,\n};\n\nstatic const struct fb_var_screeninfo q40fb_var = {\n\t.xres\t\t= 1024,\n\t.yres\t\t= 512,\n\t.xres_virtual\t= 1024,\n\t.yres_virtual\t= 512,\n\t.bits_per_pixel\t= 16,\n    \t.red\t\t= {6, 5, 0},\n\t.green\t\t= {11, 5, 0},\n\t.blue\t\t= {0, 6, 0},\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.height\t\t= 230,\n\t.width\t\t= 300,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\nstatic int q40fb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t   unsigned blue, unsigned transp,\n\t\t\t   struct fb_info *info)\n{\n     \n\n    if (regno > 255)\n\t    return 1;\n    red>>=11;\n    green>>=11;\n    blue>>=10;\n\n    if (regno < 16) {\n\t((u32 *)info->pseudo_palette)[regno] = ((red & 31) <<6) |\n\t\t\t\t\t       ((green & 31) << 11) |\n\t\t\t\t\t       (blue & 63);\n    }\n    return 0;\n}\n\nstatic const struct fb_ops q40fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_setcolreg\t= q40fb_setcolreg,\n};\n\nstatic int q40fb_probe(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\n\tif (!MACH_IS_Q40)\n\t\treturn -ENXIO;\n\n\t \n\tq40fb_fix.smem_start = Q40_PHYS_SCREEN_ADDR;\n\n\tinfo = framebuffer_alloc(sizeof(u32) * 16, &dev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->var = q40fb_var;\n\tinfo->fix = q40fb_fix;\n\tinfo->fbops = &q40fb_ops;\n\tinfo->pseudo_palette = info->par;\n\tinfo->par = NULL;\n\tinfo->screen_base = (char *) q40fb_fix.smem_start;\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\n\t\tframebuffer_release(info);\n\t\treturn -ENOMEM;\n\t}\n\n\tmaster_outb(3, DISPLAY_CONTROL_REG);\n\n\tif (register_framebuffer(info) < 0) {\n\t\tprintk(KERN_ERR \"Unable to register Q40 frame buffer\\n\");\n\t\tfb_dealloc_cmap(&info->cmap);\n\t\tframebuffer_release(info);\n\t\treturn -EINVAL;\n\t}\n\n\tfb_info(info, \"Q40 frame buffer alive and kicking !\\n\");\n\treturn 0;\n}\n\nstatic struct platform_driver q40fb_driver = {\n\t.probe\t= q40fb_probe,\n\t.driver\t= {\n\t\t.name\t= \"q40fb\",\n\t},\n};\n\nstatic struct platform_device q40fb_device = {\n\t.name\t= \"q40fb\",\n};\n\nstatic int __init q40fb_init(void)\n{\n\tint ret = 0;\n\n\tif (fb_get_options(\"q40fb\", NULL))\n\t\treturn -ENODEV;\n\n\tret = platform_driver_register(&q40fb_driver);\n\n\tif (!ret) {\n\t\tret = platform_device_register(&q40fb_device);\n\t\tif (ret)\n\t\t\tplatform_driver_unregister(&q40fb_driver);\n\t}\n\treturn ret;\n}\n\nmodule_init(q40fb_init);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}