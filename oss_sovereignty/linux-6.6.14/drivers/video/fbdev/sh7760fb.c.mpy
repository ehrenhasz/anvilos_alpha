{
  "module_name": "sh7760fb.c",
  "hash_id": "f86ba8276e27c8935406aa6a1fa6b5b400de8355cc3d8e165de775f115ee9e41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/sh7760fb.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/fb.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <asm/sh7760fb.h>\n\nstruct sh7760fb_par {\n\tvoid __iomem *base;\n\tint irq;\n\n\tstruct sh7760fb_platdata *pd;\t \n\n\tdma_addr_t fbdma;\t \n\n\tint rot;\t\t \n\n\tu32 pseudo_palette[16];\n\n\tstruct platform_device *dev;\n\tstruct resource *ioarea;\n\tstruct completion vsync;\t \n};\n\nstatic irqreturn_t sh7760fb_irq(int irq, void *data)\n{\n\tstruct completion *c = data;\n\n\tcomplete(c);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int wait_for_lps(struct sh7760fb_par *par, int val)\n{\n\tint i = 100;\n\twhile (--i && ((ioread16(par->base + LDPMMR) & 3) != val))\n\t\tmsleep(1);\n\n\tif (i <= 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n \nstatic int sh7760fb_blank(int blank, struct fb_info *info)\n{\n\tstruct sh7760fb_par *par = info->par;\n\tstruct sh7760fb_platdata *pd = par->pd;\n\tunsigned short cntr = ioread16(par->base + LDCNTR);\n\tunsigned short intr = ioread16(par->base + LDINTR);\n\tint lps;\n\n\tif (blank == FB_BLANK_UNBLANK) {\n\t\tintr |= VINT_START;\n\t\tcntr = LDCNTR_DON2 | LDCNTR_DON;\n\t\tlps = 3;\n\t} else {\n\t\tintr &= ~VINT_START;\n\t\tcntr = LDCNTR_DON2;\n\t\tlps = 0;\n\t}\n\n\tif (pd->blank)\n\t\tpd->blank(blank);\n\n\tiowrite16(intr, par->base + LDINTR);\n\tiowrite16(cntr, par->base + LDCNTR);\n\n\treturn wait_for_lps(par, lps);\n}\n\nstatic int sh7760_setcolreg (u_int regno,\n\tu_int red, u_int green, u_int blue,\n\tu_int transp, struct fb_info *info)\n{\n\tu32 *palette = info->pseudo_palette;\n\n\tif (regno >= 16)\n\t\treturn -EINVAL;\n\n\t \n\n\tred >>= 16 - info->var.red.length;\n\tgreen >>= 16 - info->var.green.length;\n\tblue >>= 16 - info->var.blue.length;\n\ttransp >>= 16 - info->var.transp.length;\n\n\tpalette[regno] = (red << info->var.red.offset) |\n\t\t(green << info->var.green.offset) |\n\t\t(blue << info->var.blue.offset) |\n\t\t(transp << info->var.transp.offset);\n\n\treturn 0;\n}\n\nstatic int sh7760fb_get_color_info(struct fb_info *info,\n\t\t\t\t   u16 lddfr, int *bpp, int *gray)\n{\n\tint lbpp, lgray;\n\n\tlgray = lbpp = 0;\n\n\tswitch (lddfr & LDDFR_COLOR_MASK) {\n\tcase LDDFR_1BPP_MONO:\n\t\tlgray = 1;\n\t\tlbpp = 1;\n\t\tbreak;\n\tcase LDDFR_2BPP_MONO:\n\t\tlgray = 1;\n\t\tlbpp = 2;\n\t\tbreak;\n\tcase LDDFR_4BPP_MONO:\n\t\tlgray = 1;\n\t\tfallthrough;\n\tcase LDDFR_4BPP:\n\t\tlbpp = 4;\n\t\tbreak;\n\tcase LDDFR_6BPP_MONO:\n\t\tlgray = 1;\n\t\tfallthrough;\n\tcase LDDFR_8BPP:\n\t\tlbpp = 8;\n\t\tbreak;\n\tcase LDDFR_16BPP_RGB555:\n\tcase LDDFR_16BPP_RGB565:\n\t\tlbpp = 16;\n\t\tlgray = 0;\n\t\tbreak;\n\tdefault:\n\t\tfb_dbg(info, \"unsupported LDDFR bit depth.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bpp)\n\t\t*bpp = lbpp;\n\tif (gray)\n\t\t*gray = lgray;\n\n\treturn 0;\n}\n\nstatic int sh7760fb_check_var(struct fb_var_screeninfo *var,\n\t\t\t      struct fb_info *info)\n{\n\tstruct fb_fix_screeninfo *fix = &info->fix;\n\tstruct sh7760fb_par *par = info->par;\n\tint ret, bpp;\n\n\t \n\tret = sh7760fb_get_color_info(info, par->pd->lddfr, &bpp, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tvar->bits_per_pixel = bpp;\n\n\tif ((var->grayscale) && (var->bits_per_pixel == 1))\n\t\tfix->visual = FB_VISUAL_MONO10;\n\telse if (var->bits_per_pixel >= 15)\n\t\tfix->visual = FB_VISUAL_TRUECOLOR;\n\telse\n\t\tfix->visual = FB_VISUAL_PSEUDOCOLOR;\n\n\t \n\treturn 0;\n}\n\n \nstatic int sh7760fb_set_par(struct fb_info *info)\n{\n\tstruct sh7760fb_par *par = info->par;\n\tstruct fb_videomode *vm = par->pd->def_mode;\n\tunsigned long sbase, dstn_off, ldsarl, stride;\n\tunsigned short hsynp, hsynw, htcn, hdcn;\n\tunsigned short vsynp, vsynw, vtln, vdln;\n\tunsigned short lddfr, ldmtr;\n\tint ret, bpp, gray;\n\n\tpar->rot = par->pd->rotate;\n\n\t \n\tif (par->rot && (vm->xres > 320)) {\n\t\tfb_dbg(info, \"rotation disabled due to display size\\n\");\n\t\tpar->rot = 0;\n\t}\n\n\t \n\thsynp = vm->right_margin + vm->xres;\n\thsynw = vm->hsync_len;\n\thtcn = vm->left_margin + hsynp + hsynw;\n\thdcn = vm->xres;\n\tvsynp = vm->lower_margin + vm->yres;\n\tvsynw = vm->vsync_len;\n\tvtln = vm->upper_margin + vsynp + vsynw;\n\tvdln = vm->yres;\n\n\t \n\tret = sh7760fb_get_color_info(info, par->pd->lddfr, &bpp, &gray);\n\tif (ret)\n\t\treturn ret;\n\n\tfb_dbg(info, \"%dx%d %dbpp %s (orientation %s)\\n\", hdcn,\n\t\tvdln, bpp, gray ? \"grayscale\" : \"color\",\n\t\tpar->rot ? \"rotated\" : \"normal\");\n\n#ifdef CONFIG_CPU_LITTLE_ENDIAN\n\tlddfr = par->pd->lddfr | (1 << 8);\n#else\n\tlddfr = par->pd->lddfr & ~(1 << 8);\n#endif\n\n\tldmtr = par->pd->ldmtr;\n\n\tif (!(vm->sync & FB_SYNC_HOR_HIGH_ACT))\n\t\tldmtr |= LDMTR_CL1POL;\n\tif (!(vm->sync & FB_SYNC_VERT_HIGH_ACT))\n\t\tldmtr |= LDMTR_FLMPOL;\n\n\t \n\tsh7760fb_blank(FB_BLANK_POWERDOWN, info);\n\n\tiowrite16(par->pd->ldickr, par->base + LDICKR);\t \n\tiowrite16(ldmtr, par->base + LDMTR);\t \n\tiowrite16(lddfr, par->base + LDDFR);\t \n\tiowrite16((par->rot ? 1 << 13 : 0), par->base + LDSMR);\t \n\tiowrite16(par->pd->ldpmmr, par->base + LDPMMR);\t \n\tiowrite16(par->pd->ldpspr, par->base + LDPSPR);\t \n\n\t \n\tiowrite16(((htcn >> 3) - 1) | (((hdcn >> 3) - 1) << 8),\n\t\t  par->base + LDHCNR);\n\tiowrite16(vdln - 1, par->base + LDVDLNR);\n\tiowrite16(vtln - 1, par->base + LDVTLNR);\n\t \n\tiowrite16((vsynp - 1) | ((vsynw - 1) << 12), par->base + LDVSYNR);\n\tiowrite16(((hsynp >> 3) - 1) | (((hsynw >> 3) - 1) << 12),\n\t\t  par->base + LDHSYNR);\n\t \n\tiowrite16(par->pd->ldaclnr, par->base + LDACLNR);\n\n\tstride = (par->rot) ? vtln : hdcn;\n\tif (!gray)\n\t\tstride *= (bpp + 7) >> 3;\n\telse {\n\t\tif (bpp == 1)\n\t\t\tstride >>= 3;\n\t\telse if (bpp == 2)\n\t\t\tstride >>= 2;\n\t\telse if (bpp == 4)\n\t\t\tstride >>= 1;\n\t\t \n\t}\n\n\t \n\tif (par->rot) {\n\t\tunsigned long bit = 1 << 31;\n\t\twhile (bit) {\n\t\t\tif (stride & bit)\n\t\t\t\tbreak;\n\t\t\tbit >>= 1;\n\t\t}\n\t\tif (stride & ~bit)\n\t\t\tstride = bit << 1;\t \n\t}\n\tiowrite16(stride, par->base + LDLAOR);\n\n\t \n\tsbase = (unsigned long)par->fbdma;\n\tif (par->rot)\n\t\tsbase += (hdcn - 1) * stride;\n\n\tiowrite32(sbase, par->base + LDSARU);\n\n\t \n\tif (((ldmtr & 0x003f) >= LDMTR_DSTN_MONO_8) &&\n\t    ((ldmtr & 0x003f) <= LDMTR_DSTN_COLOR_16)) {\n\n\t\tfb_dbg(info, \" ***** DSTN untested! *****\\n\");\n\n\t\tdstn_off = stride;\n\t\tif (par->rot)\n\t\t\tdstn_off *= hdcn >> 1;\n\t\telse\n\t\t\tdstn_off *= vdln >> 1;\n\n\t\tldsarl = sbase + dstn_off;\n\t} else\n\t\tldsarl = 0;\n\n\tiowrite32(ldsarl, par->base + LDSARL);\t \n\n\tinfo->fix.line_length = stride;\n\n\tsh7760fb_check_var(&info->var, info);\n\n\tsh7760fb_blank(FB_BLANK_UNBLANK, info);\t \n\n\tfb_dbg(info, \"hdcn  : %6d htcn  : %6d\\n\", hdcn, htcn);\n\tfb_dbg(info, \"hsynw : %6d hsynp : %6d\\n\", hsynw, hsynp);\n\tfb_dbg(info, \"vdln  : %6d vtln  : %6d\\n\", vdln, vtln);\n\tfb_dbg(info, \"vsynw : %6d vsynp : %6d\\n\", vsynw, vsynp);\n\tfb_dbg(info, \"clksrc: %6d clkdiv: %6d\\n\",\n\t\t(par->pd->ldickr >> 12) & 3, par->pd->ldickr & 0x1f);\n\tfb_dbg(info, \"ldpmmr: 0x%04x ldpspr: 0x%04x\\n\", par->pd->ldpmmr,\n\t\tpar->pd->ldpspr);\n\tfb_dbg(info, \"ldmtr : 0x%04x lddfr : 0x%04x\\n\", ldmtr, lddfr);\n\tfb_dbg(info, \"ldlaor: %ld\\n\", stride);\n\tfb_dbg(info, \"ldsaru: 0x%08lx ldsarl: 0x%08lx\\n\", sbase, ldsarl);\n\n\treturn 0;\n}\n\nstatic const struct fb_ops sh7760fb_ops = {\n\t.owner = THIS_MODULE,\n\tFB_DEFAULT_IOMEM_OPS,\n\t.fb_blank = sh7760fb_blank,\n\t.fb_check_var = sh7760fb_check_var,\n\t.fb_setcolreg = sh7760_setcolreg,\n\t.fb_set_par = sh7760fb_set_par,\n};\n\nstatic void sh7760fb_free_mem(struct fb_info *info)\n{\n\tstruct sh7760fb_par *par = info->par;\n\n\tif (!info->screen_base)\n\t\treturn;\n\n\tdma_free_coherent(info->device, info->screen_size,\n\t\t\t  info->screen_base, par->fbdma);\n\n\tpar->fbdma = 0;\n\tinfo->screen_base = NULL;\n\tinfo->screen_size = 0;\n}\n\n \nstatic int sh7760fb_alloc_mem(struct fb_info *info)\n{\n\tstruct sh7760fb_par *par = info->par;\n\tvoid *fbmem;\n\tunsigned long vram;\n\tint ret, bpp;\n\n\tif (info->screen_base)\n\t\treturn 0;\n\n\t \n\tret = sh7760fb_get_color_info(info, par->pd->lddfr, &bpp, NULL);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"colinfo\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\tvram = info->var.xres * info->var.yres;\n\tif (info->var.grayscale) {\n\t\tif (bpp == 1)\n\t\t\tvram >>= 3;\n\t\telse if (bpp == 2)\n\t\t\tvram >>= 2;\n\t\telse if (bpp == 4)\n\t\t\tvram >>= 1;\n\t} else if (bpp > 8)\n\t\tvram *= 2;\n\tif ((vram < 1) || (vram > 1024 * 2048)) {\n\t\tfb_dbg(info, \"too much VRAM required. Check settings\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (vram < PAGE_SIZE)\n\t\tvram = PAGE_SIZE;\n\n\tfbmem = dma_alloc_coherent(info->device, vram, &par->fbdma, GFP_KERNEL);\n\n\tif (!fbmem)\n\t\treturn -ENOMEM;\n\n\tif ((par->fbdma & SH7760FB_DMA_MASK) != SH7760FB_DMA_MASK) {\n\t\tsh7760fb_free_mem(info);\n\t\tdev_err(info->device, \"kernel gave me memory at 0x%08lx, which is\"\n\t\t\t\"unusable for the LCDC\\n\", (unsigned long)par->fbdma);\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo->screen_base = fbmem;\n\tinfo->screen_size = vram;\n\tinfo->fix.smem_start = (unsigned long)info->screen_base;\n\tinfo->fix.smem_len = info->screen_size;\n\n\treturn 0;\n}\n\nstatic int sh7760fb_probe(struct platform_device *pdev)\n{\n\tstruct fb_info *info;\n\tstruct resource *res;\n\tstruct sh7760fb_par *par;\n\tint ret;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (unlikely(res == NULL)) {\n\t\tdev_err(&pdev->dev, \"invalid resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct sh7760fb_par), &pdev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tpar->dev = pdev;\n\n\tpar->pd = pdev->dev.platform_data;\n\tif (!par->pd) {\n\t\tdev_dbg(&pdev->dev, \"no display setup data!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_fb;\n\t}\n\n\tpar->ioarea = request_mem_region(res->start,\n\t\t\t\t\t resource_size(res), pdev->name);\n\tif (!par->ioarea) {\n\t\tdev_err(&pdev->dev, \"mmio area busy\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_fb;\n\t}\n\n\tpar->base = ioremap(res->start, resource_size(res));\n\tif (!par->base) {\n\t\tdev_err(&pdev->dev, \"cannot remap\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_res;\n\t}\n\n\tiowrite16(0, par->base + LDINTR);\t \n\tpar->irq = platform_get_irq(pdev, 0);\n\tif (par->irq >= 0) {\n\t\tret = request_irq(par->irq, sh7760fb_irq, 0,\n\t\t\t\t  \"sh7760-lcdc\", &par->vsync);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"cannot grab IRQ\\n\");\n\t\t\tpar->irq = -ENXIO;\n\t\t} else\n\t\t\tdisable_irq_nosync(par->irq);\n\t}\n\n\tfb_videomode_to_var(&info->var, par->pd->def_mode);\n\n\tret = sh7760fb_alloc_mem(info);\n\tif (ret) {\n\t\tdev_dbg(info->device, \"framebuffer memory allocation failed!\\n\");\n\t\tgoto out_unmap;\n\t}\n\n\tinfo->pseudo_palette = par->pseudo_palette;\n\n\t \n\tinfo->var.red.offset = 11;\n\tinfo->var.red.length = 5;\n\tinfo->var.red.msb_right = 0;\n\n\tinfo->var.green.offset = 5;\n\tinfo->var.green.length = 6;\n\tinfo->var.green.msb_right = 0;\n\n\tinfo->var.blue.offset = 0;\n\tinfo->var.blue.length = 5;\n\tinfo->var.blue.msb_right = 0;\n\n\tinfo->var.transp.offset = 0;\n\tinfo->var.transp.length = 0;\n\tinfo->var.transp.msb_right = 0;\n\n\tstrcpy(info->fix.id, \"sh7760-lcdc\");\n\n\t \n\tiowrite16(LDCNTR_DON2, par->base + LDCNTR);\n\tinfo->fbops = &sh7760fb_ops;\n\n\tret = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (ret) {\n\t\tdev_dbg(&pdev->dev, \"Unable to allocate cmap memory\\n\");\n\t\tgoto out_mem;\n\t}\n\n\tret = register_framebuffer(info);\n\tif (ret < 0) {\n\t\tdev_dbg(&pdev->dev, \"cannot register fb!\\n\");\n\t\tgoto out_cmap;\n\t}\n\tplatform_set_drvdata(pdev, info);\n\n\tprintk(KERN_INFO \"%s: memory at phys 0x%08lx-0x%08lx, size %ld KiB\\n\",\n\t       pdev->name,\n\t       (unsigned long)par->fbdma,\n\t       (unsigned long)(par->fbdma + info->screen_size - 1),\n\t       info->screen_size >> 10);\n\n\treturn 0;\n\nout_cmap:\n\tsh7760fb_blank(FB_BLANK_POWERDOWN, info);\n\tfb_dealloc_cmap(&info->cmap);\nout_mem:\n\tsh7760fb_free_mem(info);\nout_unmap:\n\tif (par->irq >= 0)\n\t\tfree_irq(par->irq, &par->vsync);\n\tiounmap(par->base);\nout_res:\n\trelease_mem_region(res->start, resource_size(res));\nout_fb:\n\tframebuffer_release(info);\n\treturn ret;\n}\n\nstatic void sh7760fb_remove(struct platform_device *dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\tstruct sh7760fb_par *par = info->par;\n\n\tsh7760fb_blank(FB_BLANK_POWERDOWN, info);\n\tunregister_framebuffer(info);\n\tfb_dealloc_cmap(&info->cmap);\n\tsh7760fb_free_mem(info);\n\tif (par->irq >= 0)\n\t\tfree_irq(par->irq, &par->vsync);\n\tiounmap(par->base);\n\trelease_mem_region(par->ioarea->start, resource_size(par->ioarea));\n\tframebuffer_release(info);\n}\n\nstatic struct platform_driver sh7760_lcdc_driver = {\n\t.driver = {\n\t\t   .name = \"sh7760-lcdc\",\n\t\t   },\n\t.probe = sh7760fb_probe,\n\t.remove_new = sh7760fb_remove,\n};\n\nmodule_platform_driver(sh7760_lcdc_driver);\n\nMODULE_AUTHOR(\"Nobuhiro Iwamatsu, Manuel Lauss\");\nMODULE_DESCRIPTION(\"FBdev for SH7760/63 integrated LCD Controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}