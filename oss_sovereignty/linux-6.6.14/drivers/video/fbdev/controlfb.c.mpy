{
  "module_name": "controlfb.c",
  "hash_id": "634d304c52d810ee6f797cf2d9a8f57fbe0238a56ebbe76a5c1f539faadd7580",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/fbdev/controlfb.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/nvram.h>\n#include <linux/adb.h>\n#include <linux/cuda.h>\n#ifdef CONFIG_BOOTX_TEXT\n#include <asm/btext.h>\n#endif\n\n#include \"macmodes.h\"\n#include \"controlfb.h\"\n\n#if !defined(CONFIG_PPC_PMAC) || !defined(CONFIG_PPC32)\n#define invalid_vram_cache(addr)\n#undef in_8\n#undef out_8\n#undef in_le32\n#undef out_le32\n#define in_8(addr)\t\t0\n#define out_8(addr, val)\t(void)(val)\n#define in_le32(addr)\t\t0\n#define out_le32(addr, val)\t(void)(val)\n#ifndef pgprot_cached_wthru\n#define pgprot_cached_wthru(prot) (prot)\n#endif\n#else\nstatic void invalid_vram_cache(void __force *addr)\n{\n\teieio();\n\tdcbf(addr);\n\tmb();\n\teieio();\n\tdcbf(addr);\n\tmb();\n}\n#endif\n\nstruct fb_par_control {\n\tint\tvmode, cmode;\n\tint\txres, yres;\n\tint\tvxres, vyres;\n\tint\txoffset, yoffset;\n\tint\tpitch;\n\tstruct control_regvals\tregvals;\n\tunsigned long sync;\n\tunsigned char ctrl;\n};\n\n#define DIRTY(z) ((x)->z != (y)->z)\n#define DIRTY_CMAP(z) (memcmp(&((x)->z), &((y)->z), sizeof((y)->z)))\nstatic inline int PAR_EQUAL(struct fb_par_control *x, struct fb_par_control *y)\n{\n\tint i, results;\n\n\tresults = 1;\n\tfor (i = 0; i < 3; i++)\n\t\tresults &= !DIRTY(regvals.clock_params[i]);\n\tif (!results)\n\t\treturn 0;\n\tfor (i = 0; i < 16; i++)\n\t\tresults &= !DIRTY(regvals.regs[i]);\n\tif (!results)\n\t\treturn 0;\n\treturn (!DIRTY(cmode) && !DIRTY(xres) && !DIRTY(yres)\n\t\t&& !DIRTY(vxres) && !DIRTY(vyres));\n}\n\nstruct fb_info_control {\n\tstruct fb_info\t\tinfo;\n\tstruct fb_par_control\tpar;\n\tu32\t\t\tpseudo_palette[16];\n\n\tstruct cmap_regs\t__iomem *cmap_regs;\n\tunsigned long\t\tcmap_regs_phys;\n\n\tstruct control_regs\t__iomem *control_regs;\n\tunsigned long\t\tcontrol_regs_phys;\n\tunsigned long\t\tcontrol_regs_size;\n\n\t__u8\t\t\t__iomem *frame_buffer;\n\tunsigned long\t\tframe_buffer_phys;\n\tunsigned long\t\tfb_orig_base;\n\tunsigned long\t\tfb_orig_size;\n\n\tint\t\t\tcontrol_use_bank2;\n\tunsigned long\t\ttotal_vram;\n\tunsigned char\t\tvram_attr;\n};\n\n \n#define CNTRL_REG(INFO,REG) (&(((INFO)->control_regs->REG).r))\n\n\n \n\nstatic struct fb_info_control *control_fb;\n\nstatic int default_vmode __initdata = VMODE_NVRAM;\nstatic int default_cmode __initdata = CMODE_NVRAM;\n\n\nstatic int controlfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\n\t\t\t     u_int transp, struct fb_info *info)\n{\n\tstruct fb_info_control *p =\n\t\tcontainer_of(info, struct fb_info_control, info);\n\t__u8 r, g, b;\n\n\tif (regno > 255)\n\t\treturn 1;\n\n\tr = red >> 8;\n\tg = green >> 8;\n\tb = blue >> 8;\n\n\tout_8(&p->cmap_regs->addr, regno);\t \n\tout_8(&p->cmap_regs->lut, r);\t\t \n\tout_8(&p->cmap_regs->lut, g);\t\t \n\tout_8(&p->cmap_regs->lut, b);\n\n\tif (regno < 16) {\n\t\tint i;\n\t\tswitch (p->par.cmode) {\n\t\tcase CMODE_16:\n\t\t\tp->pseudo_palette[regno] =\n\t\t\t    (regno << 10) | (regno << 5) | regno;\n\t\t\tbreak;\n\t\tcase CMODE_32:\n\t\t\ti = (regno << 8) | regno;\n\t\t\tp->pseudo_palette[regno] = (i << 16) | i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n \n\n\n\nstatic void set_control_clock(unsigned char *params)\n{\n#ifdef CONFIG_ADB_CUDA\n\tstruct adb_request req;\n\tint i;\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tcuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC,\n\t\t\t     0x50, i + 1, params[i]);\n\t\twhile (!req.complete)\n\t\t\tcuda_poll();\n\t}\n#endif\n}\n\n \nstatic inline void set_screen_start(int xoffset, int yoffset,\n\tstruct fb_info_control *p)\n{\n\tstruct fb_par_control *par = &p->par;\n\n\tpar->xoffset = xoffset;\n\tpar->yoffset = yoffset;\n\tout_le32(CNTRL_REG(p,start_addr),\n\t\t par->yoffset * par->pitch + (par->xoffset << par->cmode));\n}\n\n#define RADACAL_WRITE(a,d) \\\n\tout_8(&p->cmap_regs->addr, (a)); \\\n\tout_8(&p->cmap_regs->dat,   (d))\n\n \n \nstatic void control_set_hardware(struct fb_info_control *p, struct fb_par_control *par)\n{\n\tstruct control_regvals\t*r;\n\tvolatile struct preg\t__iomem *rp;\n\tint\t\t\ti, cmode;\n\n\tif (PAR_EQUAL(&p->par, par)) {\n\t\t \n\t\tif (p->par.xoffset != par->xoffset ||\n\t\t    p->par.yoffset != par->yoffset)\n\t\t\tset_screen_start(par->xoffset, par->yoffset, p);\n\n\t\treturn;\n\t}\n\n\tp->par = *par;\n\tcmode = p->par.cmode;\n\tr = &par->regvals;\n\n\t \n\tout_le32(CNTRL_REG(p,ctrl), 0x400 | par->ctrl);\n\n\tset_control_clock(r->clock_params);\n\n\tRADACAL_WRITE(0x20, r->radacal_ctrl);\n\tRADACAL_WRITE(0x21, p->control_use_bank2 ? 0 : 1);\n\tRADACAL_WRITE(0x10, 0);\n\tRADACAL_WRITE(0x11, 0);\n\n\trp = &p->control_regs->vswin;\n\tfor (i = 0; i < 16; ++i, ++rp)\n\t\tout_le32(&rp->r, r->regs[i]);\n\n\tout_le32(CNTRL_REG(p,pitch), par->pitch);\n\tout_le32(CNTRL_REG(p,mode), r->mode);\n\tout_le32(CNTRL_REG(p,vram_attr), p->vram_attr);\n\tout_le32(CNTRL_REG(p,start_addr), par->yoffset * par->pitch\n\t\t + (par->xoffset << cmode));\n\tout_le32(CNTRL_REG(p,rfrcnt), 0x1e5);\n\tout_le32(CNTRL_REG(p,intr_ena), 0);\n\n\t \n\tout_le32(CNTRL_REG(p,ctrl), par->ctrl);\n\n#ifdef CONFIG_BOOTX_TEXT\n\tbtext_update_display(p->frame_buffer_phys + CTRLFB_OFF,\n\t\t\t     p->par.xres, p->par.yres,\n\t\t\t     (cmode == CMODE_32? 32: cmode == CMODE_16? 16: 8),\n\t\t\t     p->par.pitch);\n#endif  \n}\n\n \n \n\nstatic void __init find_vram_size(struct fb_info_control *p)\n{\n\tint bank1, bank2;\n\n\t \n\tout_le32(CNTRL_REG(p,vram_attr), 0x31);\n\n\tout_8(&p->frame_buffer[0x600000], 0xb3);\n\tout_8(&p->frame_buffer[0x600001], 0x71);\n\tinvalid_vram_cache(&p->frame_buffer[0x600000]);\n\n\tbank2 = (in_8(&p->frame_buffer[0x600000]) == 0xb3)\n\t\t&& (in_8(&p->frame_buffer[0x600001]) == 0x71);\n\n\t \n\tout_le32(CNTRL_REG(p,vram_attr), 0x39);\n\n\tout_8(&p->frame_buffer[0], 0x5a);\n\tout_8(&p->frame_buffer[1], 0xc7);\n\tinvalid_vram_cache(&p->frame_buffer[0]);\n\n\tbank1 = (in_8(&p->frame_buffer[0]) == 0x5a)\n\t\t&& (in_8(&p->frame_buffer[1]) == 0xc7);\n\n\tif (bank2) {\n\t\tif (!bank1) {\n\t\t\t \n\t\t\tp->control_use_bank2 = 1;\n\t\t\tp->vram_attr = 0x39;\n\t\t\tp->frame_buffer += 0x600000;\n\t\t\tp->frame_buffer_phys += 0x600000;\n\t\t} else {\n\t\t\t \n\t\t\tp->vram_attr = 0x51;\n\t\t}\n\t} else {\n\t\t \n\t\tp->vram_attr = 0x31;\n\t}\n\n        p->total_vram = (bank1 + bank2) * 0x200000;\n\n\tprintk(KERN_INFO \"controlfb: VRAM Total = %dMB \"\n\t\t\t\"(%dMB @ bank 1, %dMB @ bank 2)\\n\",\n\t\t\t(bank1 + bank2) << 1, bank1 << 1, bank2 << 1);\n}\n\n \nstatic int read_control_sense(struct fb_info_control *p)\n{\n\tint sense;\n\n\tout_le32(CNTRL_REG(p,mon_sense), 7);\t \n\t__delay(200);\n\tout_le32(CNTRL_REG(p,mon_sense), 077);\t \n\t__delay(2000);\n\tsense = (in_le32(CNTRL_REG(p,mon_sense)) & 0x1c0) << 2;\n\n\t \n\tout_le32(CNTRL_REG(p,mon_sense), 033);\t \n\t__delay(2000);\n\tsense |= (in_le32(CNTRL_REG(p,mon_sense)) & 0xc0) >> 2;\n\tout_le32(CNTRL_REG(p,mon_sense), 055);\t \n\t__delay(2000);\n\tsense |= ((in_le32(CNTRL_REG(p,mon_sense)) & 0x100) >> 5)\n\t\t| ((in_le32(CNTRL_REG(p,mon_sense)) & 0x40) >> 4);\n\tout_le32(CNTRL_REG(p,mon_sense), 066);\t \n\t__delay(2000);\n\tsense |= (in_le32(CNTRL_REG(p,mon_sense)) & 0x180) >> 7;\n\n\tout_le32(CNTRL_REG(p,mon_sense), 077);\t \n\n\treturn sense;\n}\n\n \n\n#define CONTROL_PIXCLOCK_BASE\t256016\n#define CONTROL_PIXCLOCK_MIN\t5000\t \n\n \nstatic int calc_clock_params(unsigned long clk, unsigned char *param)\n{\n\tunsigned long p0, p1, p2, k, l, m, n, min;\n\n\tif (clk > (CONTROL_PIXCLOCK_BASE << 3))\n\t\treturn 1;\n\n\tp2 = ((clk << 4) < CONTROL_PIXCLOCK_BASE)? 3: 2;\n\tl = clk << p2;\n\tp0 = 0;\n\tp1 = 0;\n\tfor (k = 1, min = l; k < 32; k++) {\n\t\tunsigned long rem;\n\n\t\tm = CONTROL_PIXCLOCK_BASE * k;\n\t\tn = m / l;\n\t\trem = m % l;\n\t\tif (n && (n < 128) && rem < min) {\n\t\t\tp0 = k;\n\t\t\tp1 = n;\n\t\t\tmin = rem;\n\t\t}\n\t}\n\tif (!p0 || !p1)\n\t\treturn 1;\n\n\tparam[0] = p0;\n\tparam[1] = p1;\n\tparam[2] = p2;\n\n\treturn 0;\n}\n\n\n \n\nstatic int control_var_to_par(struct fb_var_screeninfo *var,\n\tstruct fb_par_control *par, const struct fb_info *fb_info)\n{\n\tint cmode, piped_diff, hstep;\n\tunsigned hperiod, hssync, hsblank, hesync, heblank, piped, heq, hlfln,\n\t\t hserr, vperiod, vssync, vesync, veblank, vsblank, vswin, vewin;\n\tunsigned long pixclock;\n\tstruct fb_info_control *p =\n\t\tcontainer_of(fb_info, struct fb_info_control, info);\n\tstruct control_regvals *r = &par->regvals;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tpar->cmode = CMODE_8;\n\t\tif (p->total_vram > 0x200000) {\n\t\t\tr->mode = 3;\n\t\t\tr->radacal_ctrl = 0x20;\n\t\t\tpiped_diff = 13;\n\t\t} else {\n\t\t\tr->mode = 2;\n\t\t\tr->radacal_ctrl = 0x10;\n\t\t\tpiped_diff = 9;\n\t\t}\n\t\tbreak;\n\tcase 15:\n\tcase 16:\n\t\tpar->cmode = CMODE_16;\n\t\tif (p->total_vram > 0x200000) {\n\t\t\tr->mode = 2;\n\t\t\tr->radacal_ctrl = 0x24;\n\t\t\tpiped_diff = 5;\n\t\t} else {\n\t\t\tr->mode = 1;\n\t\t\tr->radacal_ctrl = 0x14;\n\t\t\tpiped_diff = 3;\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tpar->cmode = CMODE_32;\n\t\tif (p->total_vram > 0x200000) {\n\t\t\tr->mode = 1;\n\t\t\tr->radacal_ctrl = 0x28;\n\t\t} else {\n\t\t\tr->mode = 0;\n\t\t\tr->radacal_ctrl = 0x18;\n\t\t}\n\t\tpiped_diff = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thstep = 31 >> par->cmode;\n\tpar->xres = (var->xres + hstep) & ~hstep;\n\tpar->vxres = (var->xres_virtual + hstep) & ~hstep;\n\tpar->xoffset = (var->xoffset + hstep) & ~hstep;\n\tif (par->vxres < par->xres)\n\t\tpar->vxres = par->xres;\n\tpar->pitch = par->vxres << par->cmode;\n\n\tpar->yres = var->yres;\n\tpar->vyres = var->yres_virtual;\n\tpar->yoffset = var->yoffset;\n\tif (par->vyres < par->yres)\n\t\tpar->vyres = par->yres;\n\n\tpar->sync = var->sync;\n\n\tif (par->pitch * par->vyres + CTRLFB_OFF > p->total_vram)\n\t\treturn -EINVAL;\n\n\tif (par->xoffset + par->xres > par->vxres)\n\t\tpar->xoffset = par->vxres - par->xres;\n\tif (par->yoffset + par->yres > par->vyres)\n\t\tpar->yoffset = par->vyres - par->yres;\n\n\tpixclock = (var->pixclock < CONTROL_PIXCLOCK_MIN)? CONTROL_PIXCLOCK_MIN:\n\t\t   var->pixclock;\n\tif (calc_clock_params(pixclock, r->clock_params))\n\t\treturn -EINVAL;\n\n\thperiod = ((var->left_margin + par->xres + var->right_margin\n\t\t    + var->hsync_len) >> 1) - 2;\n\thssync = hperiod + 1;\n\thsblank = hssync - (var->right_margin >> 1);\n\thesync = (var->hsync_len >> 1) - 1;\n\theblank = (var->left_margin >> 1) + hesync;\n\tpiped = heblank - piped_diff;\n\theq = var->hsync_len >> 2;\n\thlfln = (hperiod+2) >> 1;\n\thserr = hssync-hesync;\n\tvperiod = (var->vsync_len + var->lower_margin + par->yres\n\t\t   + var->upper_margin) << 1;\n\tvssync = vperiod - 2;\n\tvesync = (var->vsync_len << 1) - vperiod + vssync;\n\tveblank = (var->upper_margin << 1) + vesync;\n\tvsblank = vssync - (var->lower_margin << 1);\n\tvswin = (vsblank+vssync) >> 1;\n\tvewin = (vesync+veblank) >> 1;\n\n\tr->regs[0] = vswin;\n\tr->regs[1] = vsblank;\n\tr->regs[2] = veblank;\n\tr->regs[3] = vewin;\n\tr->regs[4] = vesync;\n\tr->regs[5] = vssync;\n\tr->regs[6] = vperiod;\n\tr->regs[7] = piped;\n\tr->regs[8] = hperiod;\n\tr->regs[9] = hsblank;\n\tr->regs[10] = heblank;\n\tr->regs[11] = hesync;\n\tr->regs[12] = hssync;\n\tr->regs[13] = heq;\n\tr->regs[14] = hlfln;\n\tr->regs[15] = hserr;\n\n\tif (par->xres >= 1280 && par->cmode >= CMODE_16)\n\t\tpar->ctrl = 0x7f;\n\telse\n\t\tpar->ctrl = 0x3b;\n\n\tif (mac_var_to_vmode(var, &par->vmode, &cmode))\n\t\tpar->vmode = 0;\n\n\treturn 0;\n}\n\n\n \n\nstatic void control_par_to_var(struct fb_par_control *par, struct fb_var_screeninfo *var)\n{\n\tstruct control_regints *rv;\n\n\trv = (struct control_regints *) par->regvals.regs;\n\n\tmemset(var, 0, sizeof(*var));\n\tvar->xres = par->xres;\n\tvar->yres = par->yres;\n\tvar->xres_virtual = par->vxres;\n\tvar->yres_virtual = par->vyres;\n\tvar->xoffset = par->xoffset;\n\tvar->yoffset = par->yoffset;\n\n\tswitch(par->cmode) {\n\tdefault:\n\tcase CMODE_8:\n\t\tvar->bits_per_pixel = 8;\n\t\tvar->red.length = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tbreak;\n\tcase CMODE_16:\t \n\t\tvar->bits_per_pixel = 16;\n\t\tvar->red.offset = 10;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 5;\n\t\tvar->blue.length = 5;\n\t\tbreak;\n\tcase CMODE_32:\t \n\t\tvar->bits_per_pixel = 32;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.length = 8;\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tbreak;\n\t}\n\tvar->height = -1;\n\tvar->width = -1;\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\n\tvar->left_margin = (rv->heblank - rv->hesync) << 1;\n\tvar->right_margin = (rv->hssync - rv->hsblank) << 1;\n\tvar->hsync_len = (rv->hperiod + 2 - rv->hssync + rv->hesync) << 1;\n\n\tvar->upper_margin = (rv->veblank - rv->vesync) >> 1;\n\tvar->lower_margin = (rv->vssync - rv->vsblank) >> 1;\n\tvar->vsync_len = (rv->vperiod - rv->vssync + rv->vesync) >> 1;\n\n\tvar->sync = par->sync;\n\n\t \n\t \n\tvar->pixclock = CONTROL_PIXCLOCK_BASE * par->regvals.clock_params[0];\n\tvar->pixclock /= par->regvals.clock_params[1];\n\tvar->pixclock >>= par->regvals.clock_params[2];\n}\n\n \n\n \nstatic int controlfb_check_var (struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct fb_par_control par;\n\tint err;\n\n\terr = control_var_to_par(var, &par, info);\n\tif (err)\n\t\treturn err;\n\tcontrol_par_to_var(&par, var);\n\n\treturn 0;\n}\n\n \nstatic int controlfb_set_par (struct fb_info *info)\n{\n\tstruct fb_info_control *p =\n\t\tcontainer_of(info, struct fb_info_control, info);\n\tstruct fb_par_control par;\n\tint err;\n\n\tif((err = control_var_to_par(&info->var, &par, info))) {\n\t\tprintk (KERN_ERR \"controlfb_set_par: error calling\"\n\t\t\t\t \" control_var_to_par: %d.\\n\", err);\n\t\treturn err;\n\t}\n\n\tcontrol_set_hardware(p, &par);\n\n\tinfo->fix.visual = (p->par.cmode == CMODE_8) ?\n\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\n\tinfo->fix.line_length = p->par.pitch;\n\tinfo->fix.xpanstep = 32 >> p->par.cmode;\n\tinfo->fix.ypanstep = 1;\n\n\treturn 0;\n}\n\nstatic int controlfb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\t struct fb_info *info)\n{\n\tunsigned int xoffset, hstep;\n\tstruct fb_info_control *p =\n\t\tcontainer_of(info, struct fb_info_control, info);\n\tstruct fb_par_control *par = &p->par;\n\n\t \n\thstep = 0x1f >> par->cmode;\n\txoffset = (var->xoffset + hstep) & ~hstep;\n\n\tif (xoffset+par->xres > par->vxres ||\n\t    var->yoffset+par->yres > par->vyres)\n\t\treturn -EINVAL;\n\n\tset_screen_start(xoffset, var->yoffset, p);\n\n\treturn 0;\n}\n\nstatic int controlfb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct fb_info_control __maybe_unused *p =\n\t\tcontainer_of(info, struct fb_info_control, info);\n\tunsigned ctrl;\n\n\tctrl = in_le32(CNTRL_REG(p, ctrl));\n\tif (blank_mode > 0)\n\t\tswitch (blank_mode) {\n\t\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\t\tctrl &= ~3;\n\t\t\tbreak;\n\t\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\t\tctrl &= ~0x30;\n\t\t\tbreak;\n\t\tcase FB_BLANK_POWERDOWN:\n\t\t\tctrl &= ~0x33;\n\t\t\tfallthrough;\n\t\tcase FB_BLANK_NORMAL:\n\t\t\tctrl |= 0x400;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\telse {\n\t\tctrl &= ~0x400;\n\t\tctrl |= 0x33;\n\t}\n\tout_le32(CNTRL_REG(p,ctrl), ctrl);\n\n\treturn 0;\n}\n\n \nstatic int controlfb_mmap(struct fb_info *info,\n                       struct vm_area_struct *vma)\n{\n\tunsigned long mmio_pgoff;\n\tunsigned long start;\n\tu32 len;\n\n\tstart = info->fix.smem_start;\n\tlen = info->fix.smem_len;\n\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\n\tif (vma->vm_pgoff >= mmio_pgoff) {\n\t\tif (info->var.accel_flags)\n\t\t\treturn -EINVAL;\n\t\tvma->vm_pgoff -= mmio_pgoff;\n\t\tstart = info->fix.mmio_start;\n\t\tlen = info->fix.mmio_len;\n\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\t} else {\n\t\t \n\t\tvma->vm_page_prot = pgprot_cached_wthru(vma->vm_page_prot);\n\t}\n\n\treturn vm_iomap_memory(vma, start, len);\n}\n\nstatic const struct fb_ops controlfb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= controlfb_check_var,\n\t.fb_set_par\t= controlfb_set_par,\n\t.fb_setcolreg\t= controlfb_setcolreg,\n\t.fb_pan_display = controlfb_pan_display,\n\t.fb_blank\t= controlfb_blank,\n\t.fb_mmap\t= controlfb_mmap,\n\t.fb_fillrect\t= cfb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n};\n\n \nstatic void __init control_init_info(struct fb_info *info, struct fb_info_control *p)\n{\n\t \n\tinfo->par = &p->par;\n\tinfo->fbops = &controlfb_ops;\n\tinfo->pseudo_palette = p->pseudo_palette;\n\tinfo->flags = FBINFO_HWACCEL_YPAN;\n\tinfo->screen_base = p->frame_buffer + CTRLFB_OFF;\n\n\tfb_alloc_cmap(&info->cmap, 256, 0);\n\n\t \n\tstrcpy(info->fix.id, \"control\");\n\tinfo->fix.mmio_start = p->control_regs_phys;\n\tinfo->fix.mmio_len = sizeof(struct control_regs);\n\tinfo->fix.type = FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.smem_start = p->frame_buffer_phys + CTRLFB_OFF;\n\tinfo->fix.smem_len = p->total_vram - CTRLFB_OFF;\n        info->fix.ywrapstep = 0;\n        info->fix.type_aux = 0;\n        info->fix.accel = FB_ACCEL_NONE;\n}\n\n \nstatic void __init control_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!strncmp(this_opt, \"vmode:\", 6)) {\n\t\t\tint vmode = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\tif (vmode > 0 && vmode <= VMODE_MAX &&\n\t\t\t    control_mac_modes[vmode - 1].m[1] >= 0)\n\t\t\t\tdefault_vmode = vmode;\n\t\t} else if (!strncmp(this_opt, \"cmode:\", 6)) {\n\t\t\tint depth = simple_strtoul(this_opt+6, NULL, 0);\n\t\t\tswitch (depth) {\n\t\t\t case CMODE_8:\n\t\t\t case CMODE_16:\n\t\t\t case CMODE_32:\n\t\t\t \tdefault_cmode = depth;\n\t\t\t \tbreak;\n\t\t\t case 8:\n\t\t\t\tdefault_cmode = CMODE_8;\n\t\t\t\tbreak;\n\t\t\t case 15:\n\t\t\t case 16:\n\t\t\t\tdefault_cmode = CMODE_16;\n\t\t\t\tbreak;\n\t\t\t case 24:\n\t\t\t case 32:\n\t\t\t\tdefault_cmode = CMODE_32;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int __init init_control(struct fb_info_control *p)\n{\n\tint full, sense, vmode, cmode, vyres;\n\tstruct fb_var_screeninfo var;\n\tint rc;\n\n\tprintk(KERN_INFO \"controlfb: \");\n\n\tfull = p->total_vram == 0x400000;\n\n\t \n\tcmode = default_cmode;\n\tif (IS_REACHABLE(CONFIG_NVRAM) && cmode == CMODE_NVRAM)\n\t\tcmode = nvram_read_byte(NV_CMODE);\n\tif (cmode < CMODE_8 || cmode > CMODE_32)\n\t\tcmode = CMODE_8;\n\n\tvmode = default_vmode;\n\tif (IS_REACHABLE(CONFIG_NVRAM) && vmode == VMODE_NVRAM)\n\t\tvmode = nvram_read_byte(NV_VMODE);\n\tif (vmode < 1 || vmode > VMODE_MAX ||\n\t    control_mac_modes[vmode - 1].m[full] < cmode) {\n\t\tsense = read_control_sense(p);\n\t\tprintk(KERN_CONT \"Monitor sense value = 0x%x, \", sense);\n\t\tvmode = mac_map_monitor_sense(sense);\n\t\tif (control_mac_modes[vmode - 1].m[full] < 0)\n\t\t\tvmode = VMODE_640_480_60;\n\t\tcmode = min(cmode, control_mac_modes[vmode - 1].m[full]);\n\t}\n\n\t \n\tcontrol_init_info(&p->info, p);\n\n\t \n\tif (mac_vmode_to_var(vmode, cmode, &var) < 0) {\n\t\t \n\t\tprintk(\"mac_vmode_to_var(%d, %d,) failed\\n\", vmode, cmode);\ntry_again:\n\t\tvmode = VMODE_640_480_60;\n\t\tcmode = CMODE_8;\n\t\tif (mac_vmode_to_var(vmode, cmode, &var) < 0) {\n\t\t\tprintk(KERN_ERR \"controlfb: mac_vmode_to_var() failed\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tprintk(KERN_INFO \"controlfb: \");\n\t}\n\tprintk(\"using video mode %d and color mode %d.\\n\", vmode, cmode);\n\n\tvyres = (p->total_vram - CTRLFB_OFF) / (var.xres << cmode);\n\tif (vyres > var.yres)\n\t\tvar.yres_virtual = vyres;\n\n\t \n\tvar.activate = FB_ACTIVATE_NOW;\n\trc = fb_set_var(&p->info, &var);\n\tif (rc && (vmode != VMODE_640_480_60 || cmode != CMODE_8))\n\t\tgoto try_again;\n\n\t \n\tif (register_framebuffer(&p->info) < 0)\n\t\treturn -ENXIO;\n\n\tfb_info(&p->info, \"control display adapter\\n\");\n\n\treturn 0;\n}\n\nstatic void control_cleanup(void)\n{\n\tstruct fb_info_control\t*p = control_fb;\n\n\tif (!p)\n\t\treturn;\n\n\tif (p->cmap_regs)\n\t\tiounmap(p->cmap_regs);\n\tif (p->control_regs)\n\t\tiounmap(p->control_regs);\n\tif (p->frame_buffer) {\n\t\tif (p->control_use_bank2)\n\t\t\tp->frame_buffer -= 0x600000;\n\t\tiounmap(p->frame_buffer);\n\t}\n\tif (p->cmap_regs_phys)\n\t\trelease_mem_region(p->cmap_regs_phys, 0x1000);\n\tif (p->control_regs_phys)\n\t\trelease_mem_region(p->control_regs_phys, p->control_regs_size);\n\tif (p->fb_orig_base)\n\t\trelease_mem_region(p->fb_orig_base, p->fb_orig_size);\n\tkfree(p);\n}\n\n \nstatic int __init control_of_init(struct device_node *dp)\n{\n\tstruct fb_info_control\t*p;\n\tstruct resource\t\tfb_res, reg_res;\n\n\tif (control_fb) {\n\t\tprintk(KERN_ERR \"controlfb: only one control is supported\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_pci_address_to_resource(dp, 2, &fb_res) ||\n\t    of_pci_address_to_resource(dp, 1, &reg_res)) {\n\t\tprintk(KERN_ERR \"can't get 2 addresses for control\\n\");\n\t\treturn -ENXIO;\n\t}\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\tcontrol_fb = p;\t \n\n\t \n\tp->fb_orig_base = fb_res.start;\n\tp->fb_orig_size = resource_size(&fb_res);\n\t \n\tp->frame_buffer_phys = fb_res.start + 0x800000;\n\tp->control_regs_phys = reg_res.start;\n\tp->control_regs_size = resource_size(&reg_res);\n\n\tif (!p->fb_orig_base ||\n\t    !request_mem_region(p->fb_orig_base,p->fb_orig_size,\"controlfb\")) {\n\t\tp->fb_orig_base = 0;\n\t\tgoto error_out;\n\t}\n\t \n\tp->frame_buffer = ioremap_wt(p->frame_buffer_phys, 0x800000);\n\n\tif (!p->control_regs_phys ||\n\t    !request_mem_region(p->control_regs_phys, p->control_regs_size,\n\t    \"controlfb regs\")) {\n\t\tp->control_regs_phys = 0;\n\t\tgoto error_out;\n\t}\n\tp->control_regs = ioremap(p->control_regs_phys, p->control_regs_size);\n\n\tp->cmap_regs_phys = 0xf301b000;\t  \n\tif (!request_mem_region(p->cmap_regs_phys, 0x1000, \"controlfb cmap\")) {\n\t\tp->cmap_regs_phys = 0;\n\t\tgoto error_out;\n\t}\n\tp->cmap_regs = ioremap(p->cmap_regs_phys, 0x1000);\n\n\tif (!p->cmap_regs || !p->control_regs || !p->frame_buffer)\n\t\tgoto error_out;\n\n\tfind_vram_size(p);\n\tif (!p->total_vram)\n\t\tgoto error_out;\n\n\tif (init_control(p) < 0)\n\t\tgoto error_out;\n\n\treturn 0;\n\nerror_out:\n\tcontrol_cleanup();\n\treturn -ENXIO;\n}\n\nstatic int __init control_init(void)\n{\n\tstruct device_node *dp;\n\tchar *option = NULL;\n\tint ret = -ENXIO;\n\n\tif (fb_get_options(\"controlfb\", &option))\n\t\treturn -ENODEV;\n\tcontrol_setup(option);\n\n\tdp = of_find_node_by_name(NULL, \"control\");\n\tif (dp && !control_of_init(dp))\n\t\tret = 0;\n\tof_node_put(dp);\n\n\treturn ret;\n}\n\ndevice_initcall(control_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}