{
  "module_name": "qcom-wled.c",
  "hash_id": "6c066ddfdb40f6d093343bba2a95dea4f4eb423c9dd5d32ef6e7cc45622c1db4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/qcom-wled.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/ktime.h>\n#include <linux/kernel.h>\n#include <linux/backlight.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define WLED_MAX_STRINGS\t\t\t\t4\n#define MOD_A\t\t\t\t\t\t0\n#define MOD_B\t\t\t\t\t\t1\n\n#define WLED_DEFAULT_BRIGHTNESS\t\t\t\t2048\n#define WLED_SOFT_START_DLY_US\t\t\t\t10000\n#define WLED3_SINK_REG_BRIGHT_MAX\t\t\t0xFFF\n#define WLED5_SINK_REG_BRIGHT_MAX_12B\t\t\t0xFFF\n#define WLED5_SINK_REG_BRIGHT_MAX_15B\t\t\t0x7FFF\n\n \n#define WLED3_CTRL_REG_FAULT_STATUS\t\t\t0x08\n#define  WLED3_CTRL_REG_ILIM_FAULT_BIT\t\t\tBIT(0)\n#define  WLED3_CTRL_REG_OVP_FAULT_BIT\t\t\tBIT(1)\n#define  WLED4_CTRL_REG_SC_FAULT_BIT\t\t\tBIT(2)\n#define  WLED5_CTRL_REG_OVP_PRE_ALARM_BIT\t\tBIT(4)\n\n#define WLED3_CTRL_REG_INT_RT_STS\t\t\t0x10\n#define  WLED3_CTRL_REG_OVP_FAULT_STATUS\t\tBIT(1)\n\n#define WLED3_CTRL_REG_MOD_EN\t\t\t\t0x46\n#define  WLED3_CTRL_REG_MOD_EN_MASK\t\t\tBIT(7)\n#define  WLED3_CTRL_REG_MOD_EN_SHIFT\t\t\t7\n\n#define WLED3_CTRL_REG_FEEDBACK_CONTROL\t\t\t0x48\n\n#define WLED3_CTRL_REG_FREQ\t\t\t\t0x4c\n#define  WLED3_CTRL_REG_FREQ_MASK\t\t\tGENMASK(3, 0)\n\n#define WLED3_CTRL_REG_OVP\t\t\t\t0x4d\n#define  WLED3_CTRL_REG_OVP_MASK\t\t\tGENMASK(1, 0)\n#define  WLED5_CTRL_REG_OVP_MASK\t\t\tGENMASK(3, 0)\n\n#define WLED3_CTRL_REG_ILIMIT\t\t\t\t0x4e\n#define  WLED3_CTRL_REG_ILIMIT_MASK\t\t\tGENMASK(2, 0)\n\n \n#define WLED3_SINK_REG_SYNC\t\t\t\t0x47\n#define  WLED3_SINK_REG_SYNC_CLEAR\t\t\t0x00\n\n#define WLED3_SINK_REG_CURR_SINK\t\t\t0x4f\n#define  WLED3_SINK_REG_CURR_SINK_MASK\t\t\tGENMASK(7, 5)\n#define  WLED3_SINK_REG_CURR_SINK_SHFT\t\t\t5\n\n \n#define WLED3_SINK_REG_BRIGHT(n)\t\t\t(0x40 + n)\n\n#define WLED3_SINK_REG_STR_MOD_EN(n)\t\t\t(0x60 + (n * 0x10))\n#define  WLED3_SINK_REG_STR_MOD_MASK\t\t\tBIT(7)\n\n#define WLED3_SINK_REG_STR_FULL_SCALE_CURR(n)\t\t(0x62 + (n * 0x10))\n#define  WLED3_SINK_REG_STR_FULL_SCALE_CURR_MASK\tGENMASK(4, 0)\n\n#define WLED3_SINK_REG_STR_MOD_SRC(n)\t\t\t(0x63 + (n * 0x10))\n#define  WLED3_SINK_REG_STR_MOD_SRC_MASK\t\tBIT(0)\n#define  WLED3_SINK_REG_STR_MOD_SRC_INT\t\t\t0x00\n#define  WLED3_SINK_REG_STR_MOD_SRC_EXT\t\t\t0x01\n\n#define WLED3_SINK_REG_STR_CABC(n)\t\t\t(0x66 + (n * 0x10))\n#define  WLED3_SINK_REG_STR_CABC_MASK\t\t\tBIT(7)\n\n \n#define WLED4_CTRL_REG_SHORT_PROTECT\t\t\t0x5e\n#define  WLED4_CTRL_REG_SHORT_EN_MASK\t\t\tBIT(7)\n\n#define WLED4_CTRL_REG_SEC_ACCESS\t\t\t0xd0\n#define  WLED4_CTRL_REG_SEC_UNLOCK\t\t\t0xa5\n\n#define WLED4_CTRL_REG_TEST1\t\t\t\t0xe2\n#define  WLED4_CTRL_REG_TEST1_EXT_FET_DTEST2\t\t0x09\n\n \n#define WLED4_SINK_REG_CURR_SINK\t\t\t0x46\n#define  WLED4_SINK_REG_CURR_SINK_MASK\t\t\tGENMASK(7, 4)\n#define  WLED4_SINK_REG_CURR_SINK_SHFT\t\t\t4\n\n \n#define WLED4_SINK_REG_STR_MOD_EN(n)\t\t\t(0x50 + (n * 0x10))\n#define  WLED4_SINK_REG_STR_MOD_MASK\t\t\tBIT(7)\n\n#define WLED4_SINK_REG_STR_FULL_SCALE_CURR(n)\t\t(0x52 + (n * 0x10))\n#define  WLED4_SINK_REG_STR_FULL_SCALE_CURR_MASK\tGENMASK(3, 0)\n\n#define WLED4_SINK_REG_STR_MOD_SRC(n)\t\t\t(0x53 + (n * 0x10))\n#define  WLED4_SINK_REG_STR_MOD_SRC_MASK\t\tBIT(0)\n#define  WLED4_SINK_REG_STR_MOD_SRC_INT\t\t\t0x00\n#define  WLED4_SINK_REG_STR_MOD_SRC_EXT\t\t\t0x01\n\n#define WLED4_SINK_REG_STR_CABC(n)\t\t\t(0x56 + (n * 0x10))\n#define  WLED4_SINK_REG_STR_CABC_MASK\t\t\tBIT(7)\n\n#define WLED4_SINK_REG_BRIGHT(n)\t\t\t(0x57 + (n * 0x10))\n\n \n#define WLED5_CTRL_REG_OVP_INT_CTL\t\t\t0x5f\n#define  WLED5_CTRL_REG_OVP_INT_TIMER_MASK\t\tGENMASK(2, 0)\n\n \n#define WLED5_SINK_REG_MOD_A_EN\t\t\t\t0x50\n#define WLED5_SINK_REG_MOD_B_EN\t\t\t\t0x60\n#define  WLED5_SINK_REG_MOD_EN_MASK\t\t\tBIT(7)\n\n#define WLED5_SINK_REG_MOD_A_SRC_SEL\t\t\t0x51\n#define WLED5_SINK_REG_MOD_B_SRC_SEL\t\t\t0x61\n#define  WLED5_SINK_REG_MOD_SRC_SEL_HIGH\t\t0\n#define  WLED5_SINK_REG_MOD_SRC_SEL_EXT\t\t\t0x03\n#define  WLED5_SINK_REG_MOD_SRC_SEL_MASK\t\tGENMASK(1, 0)\n\n#define WLED5_SINK_REG_MOD_A_BRIGHTNESS_WIDTH_SEL\t0x52\n#define WLED5_SINK_REG_MOD_B_BRIGHTNESS_WIDTH_SEL\t0x62\n#define  WLED5_SINK_REG_BRIGHTNESS_WIDTH_12B\t\t0\n#define  WLED5_SINK_REG_BRIGHTNESS_WIDTH_15B\t\t1\n\n#define WLED5_SINK_REG_MOD_A_BRIGHTNESS_LSB\t\t0x53\n#define WLED5_SINK_REG_MOD_A_BRIGHTNESS_MSB\t\t0x54\n#define WLED5_SINK_REG_MOD_B_BRIGHTNESS_LSB\t\t0x63\n#define WLED5_SINK_REG_MOD_B_BRIGHTNESS_MSB\t\t0x64\n\n#define WLED5_SINK_REG_MOD_SYNC_BIT\t\t\t0x65\n#define  WLED5_SINK_REG_SYNC_MOD_A_BIT\t\t\tBIT(0)\n#define  WLED5_SINK_REG_SYNC_MOD_B_BIT\t\t\tBIT(1)\n#define  WLED5_SINK_REG_SYNC_MASK\t\t\tGENMASK(1, 0)\n\n \n#define WLED5_SINK_REG_STR_FULL_SCALE_CURR(n)\t\t(0x72 + (n * 0x10))\n\n#define WLED5_SINK_REG_STR_SRC_SEL(n)\t\t\t(0x73 + (n * 0x10))\n#define  WLED5_SINK_REG_SRC_SEL_MOD_A\t\t\t0\n#define  WLED5_SINK_REG_SRC_SEL_MOD_B\t\t\t1\n#define  WLED5_SINK_REG_SRC_SEL_MASK\t\t\tGENMASK(1, 0)\n\nstruct wled_var_cfg {\n\tconst u32 *values;\n\tu32 (*fn)(u32);\n\tint size;\n};\n\nstruct wled_u32_opts {\n\tconst char *name;\n\tu32 *val_ptr;\n\tconst struct wled_var_cfg *cfg;\n};\n\nstruct wled_bool_opts {\n\tconst char *name;\n\tbool *val_ptr;\n};\n\nstruct wled_config {\n\tu32 boost_i_limit;\n\tu32 ovp;\n\tu32 switch_freq;\n\tu32 num_strings;\n\tu32 string_i_limit;\n\tu32 enabled_strings[WLED_MAX_STRINGS];\n\tu32 mod_sel;\n\tu32 cabc_sel;\n\tbool cs_out_en;\n\tbool ext_gen;\n\tbool cabc;\n\tbool external_pfet;\n\tbool auto_detection_enabled;\n};\n\nstruct wled {\n\tconst char *name;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct mutex lock;\t \n\tktime_t last_short_event;\n\tktime_t start_ovp_fault_time;\n\tu16 ctrl_addr;\n\tu16 sink_addr;\n\tu16 max_string_count;\n\tu16 auto_detection_ovp_count;\n\tu32 brightness;\n\tu32 max_brightness;\n\tu32 short_count;\n\tu32 auto_detect_count;\n\tu32 version;\n\tbool disabled_by_short;\n\tbool has_short_detect;\n\tbool cabc_disabled;\n\tint short_irq;\n\tint ovp_irq;\n\n\tstruct wled_config cfg;\n\tstruct delayed_work ovp_work;\n\n\t \n\tint (*wled_set_brightness)(struct wled *wled, u16 brightness);\n\n\t \n\tint (*wled_cabc_config)(struct wled *wled, bool enable);\n\n\t \n\tint (*wled_sync_toggle)(struct wled *wled);\n\n\t \n\tint (*wled_ovp_delay)(struct wled *wled);\n\n\t \n\tbool (*wled_auto_detection_required)(struct wled *wled);\n};\n\nstatic int wled3_set_brightness(struct wled *wled, u16 brightness)\n{\n\tint rc, i;\n\t__le16 v;\n\n\tv = cpu_to_le16(brightness & WLED3_SINK_REG_BRIGHT_MAX);\n\n\tfor (i = 0; i < wled->cfg.num_strings; ++i) {\n\t\trc = regmap_bulk_write(wled->regmap, wled->ctrl_addr +\n\t\t\t\t       WLED3_SINK_REG_BRIGHT(wled->cfg.enabled_strings[i]),\n\t\t\t\t       &v, sizeof(v));\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int wled4_set_brightness(struct wled *wled, u16 brightness)\n{\n\tint rc, i;\n\tu16 low_limit = wled->max_brightness * 4 / 1000;\n\t__le16 v;\n\n\t \n\tif (brightness > 0 && brightness < low_limit)\n\t\tbrightness = low_limit;\n\n\tv = cpu_to_le16(brightness & WLED3_SINK_REG_BRIGHT_MAX);\n\n\tfor (i = 0; i < wled->cfg.num_strings; ++i) {\n\t\trc = regmap_bulk_write(wled->regmap, wled->sink_addr +\n\t\t\t\t       WLED4_SINK_REG_BRIGHT(wled->cfg.enabled_strings[i]),\n\t\t\t\t       &v, sizeof(v));\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int wled5_set_brightness(struct wled *wled, u16 brightness)\n{\n\tint rc, offset;\n\tu16 low_limit = wled->max_brightness * 1 / 1000;\n\t__le16 v;\n\n\t \n\tif (brightness < low_limit)\n\t\tbrightness = low_limit;\n\n\tv = cpu_to_le16(brightness & WLED5_SINK_REG_BRIGHT_MAX_15B);\n\n\toffset = (wled->cfg.mod_sel == MOD_A) ?\n\t\t  WLED5_SINK_REG_MOD_A_BRIGHTNESS_LSB :\n\t\t  WLED5_SINK_REG_MOD_B_BRIGHTNESS_LSB;\n\n\trc = regmap_bulk_write(wled->regmap, wled->sink_addr + offset,\n\t\t\t       &v, sizeof(v));\n\treturn rc;\n}\n\nstatic void wled_ovp_work(struct work_struct *work)\n{\n\tstruct wled *wled = container_of(work,\n\t\t\t\t\t struct wled, ovp_work.work);\n\tenable_irq(wled->ovp_irq);\n}\n\nstatic int wled_module_enable(struct wled *wled, int val)\n{\n\tint rc;\n\n\tif (wled->disabled_by_short)\n\t\treturn -ENXIO;\n\n\trc = regmap_update_bits(wled->regmap, wled->ctrl_addr +\n\t\t\t\tWLED3_CTRL_REG_MOD_EN,\n\t\t\t\tWLED3_CTRL_REG_MOD_EN_MASK,\n\t\t\t\tval << WLED3_CTRL_REG_MOD_EN_SHIFT);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (wled->ovp_irq > 0) {\n\t\tif (val) {\n\t\t\t \n\t\t\tschedule_delayed_work(&wled->ovp_work, HZ / 100);\n\t\t} else {\n\t\t\tif (!cancel_delayed_work_sync(&wled->ovp_work))\n\t\t\t\tdisable_irq(wled->ovp_irq);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wled3_sync_toggle(struct wled *wled)\n{\n\tint rc;\n\tunsigned int mask = GENMASK(wled->max_string_count - 1, 0);\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->sink_addr + WLED3_SINK_REG_SYNC,\n\t\t\t\tmask, WLED3_SINK_REG_SYNC_CLEAR);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->sink_addr + WLED3_SINK_REG_SYNC,\n\t\t\t\tmask, mask);\n\n\treturn rc;\n}\n\nstatic int wled5_mod_sync_toggle(struct wled *wled)\n{\n\tint rc;\n\tu8 val;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->sink_addr + WLED5_SINK_REG_MOD_SYNC_BIT,\n\t\t\t\tWLED5_SINK_REG_SYNC_MASK, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tval = (wled->cfg.mod_sel == MOD_A) ? WLED5_SINK_REG_SYNC_MOD_A_BIT :\n\t\t\t\t\t     WLED5_SINK_REG_SYNC_MOD_B_BIT;\n\treturn regmap_update_bits(wled->regmap,\n\t\t\t\t  wled->sink_addr + WLED5_SINK_REG_MOD_SYNC_BIT,\n\t\t\t\t  WLED5_SINK_REG_SYNC_MASK, val);\n}\n\nstatic int wled_ovp_fault_status(struct wled *wled, bool *fault_set)\n{\n\tint rc;\n\tu32 int_rt_sts, fault_sts;\n\n\t*fault_set = false;\n\trc = regmap_read(wled->regmap,\n\t\t\twled->ctrl_addr + WLED3_CTRL_REG_INT_RT_STS,\n\t\t\t&int_rt_sts);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Failed to read INT_RT_STS rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = regmap_read(wled->regmap,\n\t\t\twled->ctrl_addr + WLED3_CTRL_REG_FAULT_STATUS,\n\t\t\t&fault_sts);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Failed to read FAULT_STATUS rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (int_rt_sts & WLED3_CTRL_REG_OVP_FAULT_STATUS)\n\t\t*fault_set = true;\n\n\tif (wled->version == 4 && (fault_sts & WLED3_CTRL_REG_OVP_FAULT_BIT))\n\t\t*fault_set = true;\n\n\tif (wled->version == 5 && (fault_sts & (WLED3_CTRL_REG_OVP_FAULT_BIT |\n\t\t\t\t   WLED5_CTRL_REG_OVP_PRE_ALARM_BIT)))\n\t\t*fault_set = true;\n\n\tif (*fault_set)\n\t\tdev_dbg(wled->dev, \"WLED OVP fault detected, int_rt_sts=0x%x fault_sts=0x%x\\n\",\n\t\t\tint_rt_sts, fault_sts);\n\n\treturn rc;\n}\n\nstatic int wled4_ovp_delay(struct wled *wled)\n{\n\treturn WLED_SOFT_START_DLY_US;\n}\n\nstatic int wled5_ovp_delay(struct wled *wled)\n{\n\tint rc, delay_us;\n\tu32 val;\n\tu8 ovp_timer_ms[8] = {1, 2, 4, 8, 12, 16, 20, 24};\n\n\t \n\trc = regmap_read(wled->regmap, wled->ctrl_addr +\n\t\t\t WLED5_CTRL_REG_OVP_INT_CTL, &val);\n\tif (rc < 0)\n\t\tdelay_us =\n\t\tovp_timer_ms[val & WLED5_CTRL_REG_OVP_INT_TIMER_MASK] * 1000;\n\telse\n\t\tdelay_us = 2 * WLED_SOFT_START_DLY_US;\n\n\tdev_dbg(wled->dev, \"delay_time_us: %d\\n\", delay_us);\n\n\treturn delay_us;\n}\n\nstatic int wled_update_status(struct backlight_device *bl)\n{\n\tstruct wled *wled = bl_get_data(bl);\n\tu16 brightness = backlight_get_brightness(bl);\n\tint rc = 0;\n\n\tmutex_lock(&wled->lock);\n\tif (brightness) {\n\t\trc = wled->wled_set_brightness(wled, brightness);\n\t\tif (rc < 0) {\n\t\t\tdev_err(wled->dev, \"wled failed to set brightness rc:%d\\n\",\n\t\t\t\trc);\n\t\t\tgoto unlock_mutex;\n\t\t}\n\n\t\tif (wled->version < 5) {\n\t\t\trc = wled->wled_sync_toggle(wled);\n\t\t\tif (rc < 0) {\n\t\t\t\tdev_err(wled->dev, \"wled sync failed rc:%d\\n\", rc);\n\t\t\t\tgoto unlock_mutex;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\trc = wled5_mod_sync_toggle(wled);\n\t\t\tif (rc < 0) {\n\t\t\t\tdev_err(wled->dev, \"wled mod sync failed rc:%d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto unlock_mutex;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!!brightness != !!wled->brightness) {\n\t\trc = wled_module_enable(wled, !!brightness);\n\t\tif (rc < 0) {\n\t\t\tdev_err(wled->dev, \"wled enable failed rc:%d\\n\", rc);\n\t\t\tgoto unlock_mutex;\n\t\t}\n\t}\n\n\twled->brightness = brightness;\n\nunlock_mutex:\n\tmutex_unlock(&wled->lock);\n\n\treturn rc;\n}\n\nstatic int wled4_cabc_config(struct wled *wled, bool enable)\n{\n\tint i, j, rc;\n\tu8 val;\n\n\tfor (i = 0; i < wled->cfg.num_strings; i++) {\n\t\tj = wled->cfg.enabled_strings[i];\n\n\t\tval = enable ? WLED4_SINK_REG_STR_CABC_MASK : 0;\n\t\trc = regmap_update_bits(wled->regmap, wled->sink_addr +\n\t\t\t\t\tWLED4_SINK_REG_STR_CABC(j),\n\t\t\t\t\tWLED4_SINK_REG_STR_CABC_MASK, val);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int wled5_cabc_config(struct wled *wled, bool enable)\n{\n\tint rc, offset;\n\tu8 reg;\n\n\tif (wled->cabc_disabled)\n\t\treturn 0;\n\n\treg = enable ? wled->cfg.cabc_sel : 0;\n\toffset = (wled->cfg.mod_sel == MOD_A) ? WLED5_SINK_REG_MOD_A_SRC_SEL :\n\t\t\t\t\t\tWLED5_SINK_REG_MOD_B_SRC_SEL;\n\n\trc = regmap_update_bits(wled->regmap, wled->sink_addr + offset,\n\t\t\t\tWLED5_SINK_REG_MOD_SRC_SEL_MASK, reg);\n\tif (rc < 0) {\n\t\tpr_err(\"Error in configuring CABC rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (!wled->cfg.cabc_sel)\n\t\twled->cabc_disabled = true;\n\n\treturn 0;\n}\n\n#define WLED_SHORT_DLY_MS\t\t\t20\n#define WLED_SHORT_CNT_MAX\t\t\t5\n#define WLED_SHORT_RESET_CNT_DLY_US\t\tUSEC_PER_SEC\n\nstatic irqreturn_t wled_short_irq_handler(int irq, void *_wled)\n{\n\tstruct wled *wled = _wled;\n\tint rc;\n\ts64 elapsed_time;\n\n\twled->short_count++;\n\tmutex_lock(&wled->lock);\n\trc = wled_module_enable(wled, false);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"wled disable failed rc:%d\\n\", rc);\n\t\tgoto unlock_mutex;\n\t}\n\n\telapsed_time = ktime_us_delta(ktime_get(),\n\t\t\t\t      wled->last_short_event);\n\tif (elapsed_time > WLED_SHORT_RESET_CNT_DLY_US)\n\t\twled->short_count = 1;\n\n\tif (wled->short_count > WLED_SHORT_CNT_MAX) {\n\t\tdev_err(wled->dev, \"Short triggered %d times, disabling WLED forever!\\n\",\n\t\t\twled->short_count);\n\t\twled->disabled_by_short = true;\n\t\tgoto unlock_mutex;\n\t}\n\n\twled->last_short_event = ktime_get();\n\n\tmsleep(WLED_SHORT_DLY_MS);\n\trc = wled_module_enable(wled, true);\n\tif (rc < 0)\n\t\tdev_err(wled->dev, \"wled enable failed rc:%d\\n\", rc);\n\nunlock_mutex:\n\tmutex_unlock(&wled->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n#define AUTO_DETECT_BRIGHTNESS\t\t200\n\nstatic void wled_auto_string_detection(struct wled *wled)\n{\n\tint rc = 0, i, j, delay_time_us;\n\tu32 sink_config = 0;\n\tu8 sink_test = 0, sink_valid = 0, val;\n\tbool fault_set;\n\n\t \n\trc = regmap_read(wled->regmap, wled->sink_addr +\n\t\t\t WLED4_SINK_REG_CURR_SINK, &sink_config);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Failed to read SINK configuration rc=%d\\n\",\n\t\t\trc);\n\t\tgoto failed_detect;\n\t}\n\n\t \n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->ctrl_addr + WLED3_CTRL_REG_MOD_EN,\n\t\t\t\tWLED3_CTRL_REG_MOD_EN_MASK, 0);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Failed to disable WLED module rc=%d\\n\", rc);\n\t\tgoto failed_detect;\n\t}\n\n\t \n\trc = wled4_set_brightness(wled, AUTO_DETECT_BRIGHTNESS);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Failed to set brightness for auto detection rc=%d\\n\",\n\t\t\trc);\n\t\tgoto failed_detect;\n\t}\n\n\tif (wled->cfg.cabc) {\n\t\trc = wled->wled_cabc_config(wled, false);\n\t\tif (rc < 0)\n\t\t\tgoto failed_detect;\n\t}\n\n\t \n\trc = regmap_write(wled->regmap,\n\t\t\t  wled->sink_addr + WLED4_SINK_REG_CURR_SINK, 0);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Failed to disable all sinks rc=%d\\n\", rc);\n\t\tgoto failed_detect;\n\t}\n\n\t \n\tfor (i = 0; i < wled->cfg.num_strings; i++) {\n\t\tj = wled->cfg.enabled_strings[i];\n\t\tsink_test = BIT((WLED4_SINK_REG_CURR_SINK_SHFT + j));\n\n\t\t \n\t\trc = regmap_write(wled->regmap, wled->ctrl_addr +\n\t\t\t\t  WLED3_CTRL_REG_FEEDBACK_CONTROL, j + 1);\n\t\tif (rc < 0) {\n\t\t\tdev_err(wled->dev, \"Failed to enable feedback for SINK %d rc = %d\\n\",\n\t\t\t\tj + 1, rc);\n\t\t\tgoto failed_detect;\n\t\t}\n\n\t\t \n\t\trc = regmap_write(wled->regmap, wled->sink_addr +\n\t\t\t\t  WLED4_SINK_REG_CURR_SINK, sink_test);\n\t\tif (rc < 0) {\n\t\t\tdev_err(wled->dev, \"Failed to configure SINK %d rc=%d\\n\",\n\t\t\t\tj + 1, rc);\n\t\t\tgoto failed_detect;\n\t\t}\n\n\t\t \n\t\trc = regmap_update_bits(wled->regmap, wled->ctrl_addr +\n\t\t\t\t\tWLED3_CTRL_REG_MOD_EN,\n\t\t\t\t\tWLED3_CTRL_REG_MOD_EN_MASK,\n\t\t\t\t\tWLED3_CTRL_REG_MOD_EN_MASK);\n\t\tif (rc < 0) {\n\t\t\tdev_err(wled->dev, \"Failed to enable WLED module rc=%d\\n\",\n\t\t\t\trc);\n\t\t\tgoto failed_detect;\n\t\t}\n\n\t\tdelay_time_us = wled->wled_ovp_delay(wled);\n\t\tusleep_range(delay_time_us, delay_time_us + 1000);\n\n\t\trc = wled_ovp_fault_status(wled, &fault_set);\n\t\tif (rc < 0) {\n\t\t\tdev_err(wled->dev, \"Error in getting OVP fault_sts, rc=%d\\n\",\n\t\t\t\trc);\n\t\t\tgoto failed_detect;\n\t\t}\n\n\t\tif (fault_set)\n\t\t\tdev_dbg(wled->dev, \"WLED OVP fault detected with SINK %d\\n\",\n\t\t\t\tj + 1);\n\t\telse\n\t\t\tsink_valid |= sink_test;\n\n\t\t \n\t\trc = regmap_update_bits(wled->regmap,\n\t\t\t\t\twled->ctrl_addr + WLED3_CTRL_REG_MOD_EN,\n\t\t\t\t\tWLED3_CTRL_REG_MOD_EN_MASK, 0);\n\t\tif (rc < 0) {\n\t\t\tdev_err(wled->dev, \"Failed to disable WLED module rc=%d\\n\",\n\t\t\t\trc);\n\t\t\tgoto failed_detect;\n\t\t}\n\t}\n\n\tif (!sink_valid) {\n\t\tdev_err(wled->dev, \"No valid WLED sinks found\\n\");\n\t\twled->disabled_by_short = true;\n\t\tgoto failed_detect;\n\t}\n\n\tif (sink_valid != sink_config) {\n\t\tdev_warn(wled->dev, \"%x is not a valid sink configuration - using %x instead\\n\",\n\t\t\t sink_config, sink_valid);\n\t\tsink_config = sink_valid;\n\t}\n\n\t \n\trc = regmap_write(wled->regmap,\n\t\t\t  wled->sink_addr + WLED4_SINK_REG_CURR_SINK,\n\t\t\t  sink_config);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Failed to reconfigure the default sink rc=%d\\n\",\n\t\t\trc);\n\t\tgoto failed_detect;\n\t}\n\n\t \n\tif (wled->version == 4) {\n\t\tfor (i = 0; i < wled->cfg.num_strings; i++) {\n\t\t\tj = wled->cfg.enabled_strings[i];\n\t\t\tif (sink_config &\n\t\t\t    BIT(WLED4_SINK_REG_CURR_SINK_SHFT + j))\n\t\t\t\tval = WLED4_SINK_REG_STR_MOD_MASK;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tval = 0;\n\n\t\t\trc = regmap_write(wled->regmap, wled->sink_addr +\n\t\t\t\t\t  WLED4_SINK_REG_STR_MOD_EN(j), val);\n\t\t\tif (rc < 0) {\n\t\t\t\tdev_err(wled->dev, \"Failed to configure MODULATOR_EN rc=%d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto failed_detect;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\trc = wled->wled_cabc_config(wled, true);\n\tif (rc < 0)\n\t\tgoto failed_detect;\n\n\t \n\trc = regmap_write(wled->regmap,\n\t\t\t  wled->ctrl_addr + WLED3_CTRL_REG_FEEDBACK_CONTROL, 0);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Failed to restore feedback setting rc=%d\\n\",\n\t\t\trc);\n\t\tgoto failed_detect;\n\t}\n\n\t \n\trc = wled4_set_brightness(wled, wled->brightness);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Failed to set brightness after auto detection rc=%d\\n\",\n\t\t\trc);\n\t\tgoto failed_detect;\n\t}\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->ctrl_addr + WLED3_CTRL_REG_MOD_EN,\n\t\t\t\tWLED3_CTRL_REG_MOD_EN_MASK,\n\t\t\t\tWLED3_CTRL_REG_MOD_EN_MASK);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Failed to enable WLED module rc=%d\\n\", rc);\n\t\tgoto failed_detect;\n\t}\n\nfailed_detect:\n\treturn;\n}\n\n#define WLED_AUTO_DETECT_OVP_COUNT\t\t5\n#define WLED_AUTO_DETECT_CNT_DLY_US\t\tUSEC_PER_SEC\n\nstatic bool wled4_auto_detection_required(struct wled *wled)\n{\n\ts64 elapsed_time_us;\n\n\tif (!wled->cfg.auto_detection_enabled)\n\t\treturn false;\n\n\t \n\tif (!wled->auto_detection_ovp_count) {\n\t\twled->start_ovp_fault_time = ktime_get();\n\t\twled->auto_detection_ovp_count++;\n\t} else {\n\t\telapsed_time_us = ktime_us_delta(ktime_get(),\n\t\t\t\t\t\t wled->start_ovp_fault_time);\n\t\tif (elapsed_time_us > WLED_AUTO_DETECT_CNT_DLY_US)\n\t\t\twled->auto_detection_ovp_count = 0;\n\t\telse\n\t\t\twled->auto_detection_ovp_count++;\n\n\t\tif (wled->auto_detection_ovp_count >=\n\t\t\t\tWLED_AUTO_DETECT_OVP_COUNT) {\n\t\t\twled->auto_detection_ovp_count = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool wled5_auto_detection_required(struct wled *wled)\n{\n\tif (!wled->cfg.auto_detection_enabled)\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\nstatic int wled_auto_detection_at_init(struct wled *wled)\n{\n\tint rc;\n\tbool fault_set;\n\n\tif (!wled->cfg.auto_detection_enabled)\n\t\treturn 0;\n\n\trc = wled_ovp_fault_status(wled, &fault_set);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Error in getting OVP fault_sts, rc=%d\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\tif (fault_set) {\n\t\tmutex_lock(&wled->lock);\n\t\twled_auto_string_detection(wled);\n\t\tmutex_unlock(&wled->lock);\n\t}\n\n\treturn rc;\n}\n\nstatic irqreturn_t wled_ovp_irq_handler(int irq, void *_wled)\n{\n\tstruct wled *wled = _wled;\n\tint rc;\n\tu32 int_sts, fault_sts;\n\n\trc = regmap_read(wled->regmap,\n\t\t\t wled->ctrl_addr + WLED3_CTRL_REG_INT_RT_STS, &int_sts);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Error in reading WLED3_INT_RT_STS rc=%d\\n\",\n\t\t\trc);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\trc = regmap_read(wled->regmap, wled->ctrl_addr +\n\t\t\t WLED3_CTRL_REG_FAULT_STATUS, &fault_sts);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Error in reading WLED_FAULT_STATUS rc=%d\\n\",\n\t\t\trc);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (fault_sts & (WLED3_CTRL_REG_OVP_FAULT_BIT |\n\t\tWLED3_CTRL_REG_ILIM_FAULT_BIT))\n\t\tdev_dbg(wled->dev, \"WLED OVP fault detected, int_sts=%x fault_sts= %x\\n\",\n\t\t\tint_sts, fault_sts);\n\n\tif (fault_sts & WLED3_CTRL_REG_OVP_FAULT_BIT) {\n\t\tif (wled->wled_auto_detection_required(wled)) {\n\t\t\tmutex_lock(&wled->lock);\n\t\t\twled_auto_string_detection(wled);\n\t\t\tmutex_unlock(&wled->lock);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int wled3_setup(struct wled *wled)\n{\n\tu16 addr;\n\tu8 sink_en = 0;\n\tint rc, i, j;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->ctrl_addr + WLED3_CTRL_REG_OVP,\n\t\t\t\tWLED3_CTRL_REG_OVP_MASK, wled->cfg.ovp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->ctrl_addr + WLED3_CTRL_REG_ILIMIT,\n\t\t\t\tWLED3_CTRL_REG_ILIMIT_MASK,\n\t\t\t\twled->cfg.boost_i_limit);\n\tif (rc)\n\t\treturn rc;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->ctrl_addr + WLED3_CTRL_REG_FREQ,\n\t\t\t\tWLED3_CTRL_REG_FREQ_MASK,\n\t\t\t\twled->cfg.switch_freq);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < wled->cfg.num_strings; ++i) {\n\t\tj = wled->cfg.enabled_strings[i];\n\t\taddr = wled->ctrl_addr + WLED3_SINK_REG_STR_MOD_EN(j);\n\t\trc = regmap_update_bits(wled->regmap, addr,\n\t\t\t\t\tWLED3_SINK_REG_STR_MOD_MASK,\n\t\t\t\t\tWLED3_SINK_REG_STR_MOD_MASK);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tif (wled->cfg.ext_gen) {\n\t\t\taddr = wled->ctrl_addr + WLED3_SINK_REG_STR_MOD_SRC(j);\n\t\t\trc = regmap_update_bits(wled->regmap, addr,\n\t\t\t\t\t\tWLED3_SINK_REG_STR_MOD_SRC_MASK,\n\t\t\t\t\t\tWLED3_SINK_REG_STR_MOD_SRC_EXT);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\taddr = wled->ctrl_addr + WLED3_SINK_REG_STR_FULL_SCALE_CURR(j);\n\t\trc = regmap_update_bits(wled->regmap, addr,\n\t\t\t\t\tWLED3_SINK_REG_STR_FULL_SCALE_CURR_MASK,\n\t\t\t\t\twled->cfg.string_i_limit);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\taddr = wled->ctrl_addr + WLED3_SINK_REG_STR_CABC(j);\n\t\trc = regmap_update_bits(wled->regmap, addr,\n\t\t\t\t\tWLED3_SINK_REG_STR_CABC_MASK,\n\t\t\t\t\twled->cfg.cabc ?\n\t\t\t\t\tWLED3_SINK_REG_STR_CABC_MASK : 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tsink_en |= BIT(j + WLED3_SINK_REG_CURR_SINK_SHFT);\n\t}\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->ctrl_addr + WLED3_SINK_REG_CURR_SINK,\n\t\t\t\tWLED3_SINK_REG_CURR_SINK_MASK, sink_en);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic const struct wled_config wled3_config_defaults = {\n\t.boost_i_limit = 3,\n\t.string_i_limit = 20,\n\t.ovp = 2,\n\t.num_strings = 3,\n\t.switch_freq = 5,\n\t.cs_out_en = false,\n\t.ext_gen = false,\n\t.cabc = false,\n\t.enabled_strings = {0, 1, 2},\n};\n\nstatic int wled4_setup(struct wled *wled)\n{\n\tint rc, temp, i, j;\n\tu16 addr;\n\tu8 sink_en = 0;\n\tu32 sink_cfg;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->ctrl_addr + WLED3_CTRL_REG_OVP,\n\t\t\t\tWLED3_CTRL_REG_OVP_MASK, wled->cfg.ovp);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->ctrl_addr + WLED3_CTRL_REG_ILIMIT,\n\t\t\t\tWLED3_CTRL_REG_ILIMIT_MASK,\n\t\t\t\twled->cfg.boost_i_limit);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->ctrl_addr + WLED3_CTRL_REG_FREQ,\n\t\t\t\tWLED3_CTRL_REG_FREQ_MASK,\n\t\t\t\twled->cfg.switch_freq);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (wled->cfg.external_pfet) {\n\t\t \n\t\trc = regmap_write(wled->regmap, wled->ctrl_addr +\n\t\t\t\t  WLED4_CTRL_REG_SEC_ACCESS,\n\t\t\t\t  WLED4_CTRL_REG_SEC_UNLOCK);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = regmap_write(wled->regmap,\n\t\t\t\t  wled->ctrl_addr + WLED4_CTRL_REG_TEST1,\n\t\t\t\t  WLED4_CTRL_REG_TEST1_EXT_FET_DTEST2);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\trc = regmap_read(wled->regmap, wled->sink_addr +\n\t\t\t WLED4_SINK_REG_CURR_SINK, &sink_cfg);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tfor (i = 0; i < wled->cfg.num_strings; i++) {\n\t\tj = wled->cfg.enabled_strings[i];\n\t\ttemp = j + WLED4_SINK_REG_CURR_SINK_SHFT;\n\t\tsink_en |= 1 << temp;\n\t}\n\n\tif (sink_cfg == sink_en) {\n\t\trc = wled_auto_detection_at_init(wled);\n\t\treturn rc;\n\t}\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->sink_addr + WLED4_SINK_REG_CURR_SINK,\n\t\t\t\tWLED4_SINK_REG_CURR_SINK_MASK, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = regmap_update_bits(wled->regmap, wled->ctrl_addr +\n\t\t\t\tWLED3_CTRL_REG_MOD_EN,\n\t\t\t\tWLED3_CTRL_REG_MOD_EN_MASK, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tfor (i = 0; i < wled->cfg.num_strings; i++) {\n\t\tj = wled->cfg.enabled_strings[i];\n\n\t\taddr = wled->sink_addr +\n\t\t\t\tWLED4_SINK_REG_STR_MOD_EN(j);\n\t\trc = regmap_update_bits(wled->regmap, addr,\n\t\t\t\t\tWLED4_SINK_REG_STR_MOD_MASK,\n\t\t\t\t\tWLED4_SINK_REG_STR_MOD_MASK);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\taddr = wled->sink_addr +\n\t\t\t\tWLED4_SINK_REG_STR_FULL_SCALE_CURR(j);\n\t\trc = regmap_update_bits(wled->regmap, addr,\n\t\t\t\t\tWLED4_SINK_REG_STR_FULL_SCALE_CURR_MASK,\n\t\t\t\t\twled->cfg.string_i_limit);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\trc = wled4_cabc_config(wled, wled->cfg.cabc);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = regmap_update_bits(wled->regmap, wled->ctrl_addr +\n\t\t\t\tWLED3_CTRL_REG_MOD_EN,\n\t\t\t\tWLED3_CTRL_REG_MOD_EN_MASK,\n\t\t\t\tWLED3_CTRL_REG_MOD_EN_MASK);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->sink_addr + WLED4_SINK_REG_CURR_SINK,\n\t\t\t\tWLED4_SINK_REG_CURR_SINK_MASK, sink_en);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = wled->wled_sync_toggle(wled);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Failed to toggle sync reg rc:%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = wled_auto_detection_at_init(wled);\n\n\treturn rc;\n}\n\nstatic const struct wled_config wled4_config_defaults = {\n\t.boost_i_limit = 4,\n\t.string_i_limit = 10,\n\t.ovp = 1,\n\t.num_strings = 4,\n\t.switch_freq = 11,\n\t.cabc = false,\n\t.external_pfet = false,\n\t.auto_detection_enabled = false,\n\t.enabled_strings = {0, 1, 2, 3},\n};\n\nstatic int wled5_setup(struct wled *wled)\n{\n\tint rc, temp, i, j, offset;\n\tu8 sink_en = 0;\n\tu16 addr;\n\tu32 val;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->ctrl_addr + WLED3_CTRL_REG_OVP,\n\t\t\t\tWLED5_CTRL_REG_OVP_MASK, wled->cfg.ovp);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->ctrl_addr + WLED3_CTRL_REG_ILIMIT,\n\t\t\t\tWLED3_CTRL_REG_ILIMIT_MASK,\n\t\t\t\twled->cfg.boost_i_limit);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->ctrl_addr + WLED3_CTRL_REG_FREQ,\n\t\t\t\tWLED3_CTRL_REG_FREQ_MASK,\n\t\t\t\twled->cfg.switch_freq);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tfor (i = 0; i < wled->cfg.num_strings; ++i) {\n\t\tj = wled->cfg.enabled_strings[i];\n\t\taddr = wled->sink_addr +\n\t\t\t\tWLED4_SINK_REG_STR_FULL_SCALE_CURR(j);\n\t\trc = regmap_update_bits(wled->regmap, addr,\n\t\t\t\t\tWLED4_SINK_REG_STR_FULL_SCALE_CURR_MASK,\n\t\t\t\t\twled->cfg.string_i_limit);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\taddr = wled->sink_addr + WLED5_SINK_REG_STR_SRC_SEL(j);\n\t\trc = regmap_update_bits(wled->regmap, addr,\n\t\t\t\t\tWLED5_SINK_REG_SRC_SEL_MASK,\n\t\t\t\t\twled->cfg.mod_sel == MOD_A ?\n\t\t\t\t\tWLED5_SINK_REG_SRC_SEL_MOD_A :\n\t\t\t\t\tWLED5_SINK_REG_SRC_SEL_MOD_B);\n\n\t\ttemp = j + WLED4_SINK_REG_CURR_SINK_SHFT;\n\t\tsink_en |= 1 << temp;\n\t}\n\n\trc = wled5_cabc_config(wled, wled->cfg.cabc_sel ? true : false);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\taddr = wled->sink_addr + WLED5_SINK_REG_MOD_A_EN;\n\tval = (wled->cfg.mod_sel == MOD_A) ? WLED5_SINK_REG_MOD_EN_MASK : 0;\n\trc = regmap_update_bits(wled->regmap, addr,\n\t\t\t\tWLED5_SINK_REG_MOD_EN_MASK, val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\taddr = wled->sink_addr + WLED5_SINK_REG_MOD_B_EN;\n\tval = (wled->cfg.mod_sel == MOD_B) ? WLED5_SINK_REG_MOD_EN_MASK : 0;\n\trc = regmap_update_bits(wled->regmap, addr,\n\t\t\t\tWLED5_SINK_REG_MOD_EN_MASK, val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\toffset = (wled->cfg.mod_sel == MOD_A) ?\n\t\t  WLED5_SINK_REG_MOD_A_BRIGHTNESS_WIDTH_SEL :\n\t\t  WLED5_SINK_REG_MOD_B_BRIGHTNESS_WIDTH_SEL;\n\n\taddr = wled->sink_addr + offset;\n\tval = (wled->max_brightness == WLED5_SINK_REG_BRIGHT_MAX_15B) ?\n\t\t WLED5_SINK_REG_BRIGHTNESS_WIDTH_15B :\n\t\t WLED5_SINK_REG_BRIGHTNESS_WIDTH_12B;\n\trc = regmap_write(wled->regmap, addr, val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = regmap_update_bits(wled->regmap,\n\t\t\t\twled->sink_addr + WLED4_SINK_REG_CURR_SINK,\n\t\t\t\tWLED4_SINK_REG_CURR_SINK_MASK, sink_en);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = wled->wled_sync_toggle(wled);\n\tif (rc < 0) {\n\t\tpr_err(\"Failed to toggle sync reg rc:%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = wled_auto_detection_at_init(wled);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic const struct wled_config wled5_config_defaults = {\n\t.boost_i_limit = 5,\n\t.string_i_limit = 10,\n\t.ovp = 4,\n\t.num_strings = 4,\n\t.switch_freq = 11,\n\t.mod_sel = 0,\n\t.cabc_sel = 0,\n\t.cabc = false,\n\t.external_pfet = false,\n\t.auto_detection_enabled = false,\n\t.enabled_strings = {0, 1, 2, 3},\n};\n\nstatic const u32 wled3_boost_i_limit_values[] = {\n\t105, 385, 525, 805, 980, 1260, 1400, 1680,\n};\n\nstatic const struct wled_var_cfg wled3_boost_i_limit_cfg = {\n\t.values = wled3_boost_i_limit_values,\n\t.size = ARRAY_SIZE(wled3_boost_i_limit_values),\n};\n\nstatic const u32 wled4_boost_i_limit_values[] = {\n\t105, 280, 450, 620, 970, 1150, 1300, 1500,\n};\n\nstatic const struct wled_var_cfg wled4_boost_i_limit_cfg = {\n\t.values = wled4_boost_i_limit_values,\n\t.size = ARRAY_SIZE(wled4_boost_i_limit_values),\n};\n\nstatic inline u32 wled5_boost_i_limit_values_fn(u32 idx)\n{\n\treturn 525 + (idx * 175);\n}\n\nstatic const struct wled_var_cfg wled5_boost_i_limit_cfg = {\n\t.fn = wled5_boost_i_limit_values_fn,\n\t.size = 8,\n};\n\nstatic const u32 wled3_ovp_values[] = {\n\t35, 32, 29, 27,\n};\n\nstatic const struct wled_var_cfg wled3_ovp_cfg = {\n\t.values = wled3_ovp_values,\n\t.size = ARRAY_SIZE(wled3_ovp_values),\n};\n\nstatic const u32 wled4_ovp_values[] = {\n\t31100, 29600, 19600, 18100,\n};\n\nstatic const struct wled_var_cfg wled4_ovp_cfg = {\n\t.values = wled4_ovp_values,\n\t.size = ARRAY_SIZE(wled4_ovp_values),\n};\n\nstatic inline u32 wled5_ovp_values_fn(u32 idx)\n{\n\t \n\treturn 38500 - (idx * 1500);\n}\n\nstatic const struct wled_var_cfg wled5_ovp_cfg = {\n\t.fn = wled5_ovp_values_fn,\n\t.size = 16,\n};\n\nstatic u32 wled3_switch_freq_values_fn(u32 idx)\n{\n\treturn 19200 / (2 * (1 + idx));\n}\n\nstatic const struct wled_var_cfg wled3_switch_freq_cfg = {\n\t.fn = wled3_switch_freq_values_fn,\n\t.size = 16,\n};\n\nstatic const struct wled_var_cfg wled3_string_i_limit_cfg = {\n\t.size = 26,\n};\n\nstatic const u32 wled4_string_i_limit_values[] = {\n\t0, 2500, 5000, 7500, 10000, 12500, 15000, 17500, 20000,\n\t22500, 25000, 27500, 30000,\n};\n\nstatic const struct wled_var_cfg wled4_string_i_limit_cfg = {\n\t.values = wled4_string_i_limit_values,\n\t.size = ARRAY_SIZE(wled4_string_i_limit_values),\n};\n\nstatic const struct wled_var_cfg wled5_mod_sel_cfg = {\n\t.size = 2,\n};\n\nstatic const struct wled_var_cfg wled5_cabc_sel_cfg = {\n\t.size = 4,\n};\n\nstatic u32 wled_values(const struct wled_var_cfg *cfg, u32 idx)\n{\n\tif (idx >= cfg->size)\n\t\treturn UINT_MAX;\n\tif (cfg->fn)\n\t\treturn cfg->fn(idx);\n\tif (cfg->values)\n\t\treturn cfg->values[idx];\n\treturn idx;\n}\n\nstatic int wled_configure(struct wled *wled)\n{\n\tstruct wled_config *cfg = &wled->cfg;\n\tstruct device *dev = wled->dev;\n\tconst __be32 *prop_addr;\n\tu32 size, val, c;\n\tint rc, i, j, string_len;\n\n\tconst struct wled_u32_opts *u32_opts = NULL;\n\tconst struct wled_u32_opts wled3_opts[] = {\n\t\t{\n\t\t\t.name = \"qcom,current-boost-limit\",\n\t\t\t.val_ptr = &cfg->boost_i_limit,\n\t\t\t.cfg = &wled3_boost_i_limit_cfg,\n\t\t},\n\t\t{\n\t\t\t.name = \"qcom,current-limit\",\n\t\t\t.val_ptr = &cfg->string_i_limit,\n\t\t\t.cfg = &wled3_string_i_limit_cfg,\n\t\t},\n\t\t{\n\t\t\t.name = \"qcom,ovp\",\n\t\t\t.val_ptr = &cfg->ovp,\n\t\t\t.cfg = &wled3_ovp_cfg,\n\t\t},\n\t\t{\n\t\t\t.name = \"qcom,switching-freq\",\n\t\t\t.val_ptr = &cfg->switch_freq,\n\t\t\t.cfg = &wled3_switch_freq_cfg,\n\t\t},\n\t};\n\n\tconst struct wled_u32_opts wled4_opts[] = {\n\t\t{\n\t\t\t.name = \"qcom,current-boost-limit\",\n\t\t\t.val_ptr = &cfg->boost_i_limit,\n\t\t\t.cfg = &wled4_boost_i_limit_cfg,\n\t\t},\n\t\t{\n\t\t\t.name = \"qcom,current-limit-microamp\",\n\t\t\t.val_ptr = &cfg->string_i_limit,\n\t\t\t.cfg = &wled4_string_i_limit_cfg,\n\t\t},\n\t\t{\n\t\t\t.name = \"qcom,ovp-millivolt\",\n\t\t\t.val_ptr = &cfg->ovp,\n\t\t\t.cfg = &wled4_ovp_cfg,\n\t\t},\n\t\t{\n\t\t\t.name = \"qcom,switching-freq\",\n\t\t\t.val_ptr = &cfg->switch_freq,\n\t\t\t.cfg = &wled3_switch_freq_cfg,\n\t\t},\n\t};\n\n\tconst struct wled_u32_opts wled5_opts[] = {\n\t\t{\n\t\t\t.name = \"qcom,current-boost-limit\",\n\t\t\t.val_ptr = &cfg->boost_i_limit,\n\t\t\t.cfg = &wled5_boost_i_limit_cfg,\n\t\t},\n\t\t{\n\t\t\t.name = \"qcom,current-limit-microamp\",\n\t\t\t.val_ptr = &cfg->string_i_limit,\n\t\t\t.cfg = &wled4_string_i_limit_cfg,\n\t\t},\n\t\t{\n\t\t\t.name = \"qcom,ovp-millivolt\",\n\t\t\t.val_ptr = &cfg->ovp,\n\t\t\t.cfg = &wled5_ovp_cfg,\n\t\t},\n\t\t{\n\t\t\t.name = \"qcom,switching-freq\",\n\t\t\t.val_ptr = &cfg->switch_freq,\n\t\t\t.cfg = &wled3_switch_freq_cfg,\n\t\t},\n\t\t{\n\t\t\t.name = \"qcom,modulator-sel\",\n\t\t\t.val_ptr = &cfg->mod_sel,\n\t\t\t.cfg = &wled5_mod_sel_cfg,\n\t\t},\n\t\t{\n\t\t\t.name = \"qcom,cabc-sel\",\n\t\t\t.val_ptr = &cfg->cabc_sel,\n\t\t\t.cfg = &wled5_cabc_sel_cfg,\n\t\t},\n\t};\n\n\tconst struct wled_bool_opts bool_opts[] = {\n\t\t{ \"qcom,cs-out\", &cfg->cs_out_en, },\n\t\t{ \"qcom,ext-gen\", &cfg->ext_gen, },\n\t\t{ \"qcom,cabc\", &cfg->cabc, },\n\t\t{ \"qcom,external-pfet\", &cfg->external_pfet, },\n\t\t{ \"qcom,auto-string-detection\", &cfg->auto_detection_enabled, },\n\t};\n\n\tprop_addr = of_get_address(dev->of_node, 0, NULL, NULL);\n\tif (!prop_addr) {\n\t\tdev_err(wled->dev, \"invalid IO resources\\n\");\n\t\treturn -EINVAL;\n\t}\n\twled->ctrl_addr = be32_to_cpu(*prop_addr);\n\n\trc = of_property_read_string(dev->of_node, \"label\", &wled->name);\n\tif (rc)\n\t\twled->name = devm_kasprintf(dev, GFP_KERNEL, \"%pOFn\", dev->of_node);\n\n\tswitch (wled->version) {\n\tcase 3:\n\t\tu32_opts = wled3_opts;\n\t\tsize = ARRAY_SIZE(wled3_opts);\n\t\t*cfg = wled3_config_defaults;\n\t\twled->wled_set_brightness = wled3_set_brightness;\n\t\twled->wled_sync_toggle = wled3_sync_toggle;\n\t\twled->max_string_count = 3;\n\t\twled->sink_addr = wled->ctrl_addr;\n\t\tbreak;\n\n\tcase 4:\n\t\tu32_opts = wled4_opts;\n\t\tsize = ARRAY_SIZE(wled4_opts);\n\t\t*cfg = wled4_config_defaults;\n\t\twled->wled_set_brightness = wled4_set_brightness;\n\t\twled->wled_sync_toggle = wled3_sync_toggle;\n\t\twled->wled_cabc_config = wled4_cabc_config;\n\t\twled->wled_ovp_delay = wled4_ovp_delay;\n\t\twled->wled_auto_detection_required =\n\t\t\t\t\twled4_auto_detection_required;\n\t\twled->max_string_count = 4;\n\n\t\tprop_addr = of_get_address(dev->of_node, 1, NULL, NULL);\n\t\tif (!prop_addr) {\n\t\t\tdev_err(wled->dev, \"invalid IO resources\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\twled->sink_addr = be32_to_cpu(*prop_addr);\n\t\tbreak;\n\n\tcase 5:\n\t\tu32_opts = wled5_opts;\n\t\tsize = ARRAY_SIZE(wled5_opts);\n\t\t*cfg = wled5_config_defaults;\n\t\twled->wled_set_brightness = wled5_set_brightness;\n\t\twled->wled_sync_toggle = wled3_sync_toggle;\n\t\twled->wled_cabc_config = wled5_cabc_config;\n\t\twled->wled_ovp_delay = wled5_ovp_delay;\n\t\twled->wled_auto_detection_required =\n\t\t\t\t\twled5_auto_detection_required;\n\t\twled->max_string_count = 4;\n\n\t\tprop_addr = of_get_address(dev->of_node, 1, NULL, NULL);\n\t\tif (!prop_addr) {\n\t\t\tdev_err(wled->dev, \"invalid IO resources\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\twled->sink_addr = be32_to_cpu(*prop_addr);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(wled->dev, \"Invalid WLED version\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < size; ++i) {\n\t\trc = of_property_read_u32(dev->of_node, u32_opts[i].name, &val);\n\t\tif (rc == -EINVAL) {\n\t\t\tcontinue;\n\t\t} else if (rc) {\n\t\t\tdev_err(dev, \"error reading '%s'\\n\", u32_opts[i].name);\n\t\t\treturn rc;\n\t\t}\n\n\t\tc = UINT_MAX;\n\t\tfor (j = 0; c != val; j++) {\n\t\t\tc = wled_values(u32_opts[i].cfg, j);\n\t\t\tif (c == UINT_MAX) {\n\t\t\t\tdev_err(dev, \"invalid value for '%s'\\n\",\n\t\t\t\t\tu32_opts[i].name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (c == val)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(dev, \"'%s' = %u\\n\", u32_opts[i].name, c);\n\t\t*u32_opts[i].val_ptr = j;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(bool_opts); ++i) {\n\t\tif (of_property_read_bool(dev->of_node, bool_opts[i].name))\n\t\t\t*bool_opts[i].val_ptr = true;\n\t}\n\n\tstring_len = of_property_count_elems_of_size(dev->of_node,\n\t\t\t\t\t\t     \"qcom,enabled-strings\",\n\t\t\t\t\t\t     sizeof(u32));\n\tif (string_len > 0) {\n\t\tif (string_len > wled->max_string_count) {\n\t\t\tdev_err(dev, \"Cannot have more than %d strings\\n\",\n\t\t\t\twled->max_string_count);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trc = of_property_read_u32_array(dev->of_node,\n\t\t\t\t\t\t\"qcom,enabled-strings\",\n\t\t\t\t\t\twled->cfg.enabled_strings,\n\t\t\t\t\t\tstring_len);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Failed to read %d elements from qcom,enabled-strings: %d\\n\",\n\t\t\t\tstring_len, rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tfor (i = 0; i < string_len; ++i) {\n\t\t\tif (wled->cfg.enabled_strings[i] >= wled->max_string_count) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"qcom,enabled-strings index %d at %d is out of bounds\\n\",\n\t\t\t\t\twled->cfg.enabled_strings[i], i);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tcfg->num_strings = string_len;\n\t}\n\n\trc = of_property_read_u32(dev->of_node, \"qcom,num-strings\", &val);\n\tif (!rc) {\n\t\tif (val < 1 || val > wled->max_string_count) {\n\t\t\tdev_err(dev, \"qcom,num-strings must be between 1 and %d\\n\",\n\t\t\t\twled->max_string_count);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (string_len > 0) {\n\t\t\tdev_warn(dev, \"Only one of qcom,num-strings or qcom,enabled-strings\"\n\t\t\t\t      \" should be set\\n\");\n\t\t\tif (val > string_len) {\n\t\t\t\tdev_err(dev, \"qcom,num-strings exceeds qcom,enabled-strings\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tcfg->num_strings = val;\n\t}\n\n\treturn 0;\n}\n\nstatic int wled_configure_short_irq(struct wled *wled,\n\t\t\t\t    struct platform_device *pdev)\n{\n\tint rc;\n\n\tif (!wled->has_short_detect)\n\t\treturn 0;\n\n\trc = regmap_update_bits(wled->regmap, wled->ctrl_addr +\n\t\t\t\tWLED4_CTRL_REG_SHORT_PROTECT,\n\t\t\t\tWLED4_CTRL_REG_SHORT_EN_MASK,\n\t\t\t\tWLED4_CTRL_REG_SHORT_EN_MASK);\n\tif (rc < 0)\n\t\treturn rc;\n\n\twled->short_irq = platform_get_irq_byname(pdev, \"short\");\n\tif (wled->short_irq < 0) {\n\t\tdev_dbg(&pdev->dev, \"short irq is not used\\n\");\n\t\treturn 0;\n\t}\n\n\trc = devm_request_threaded_irq(wled->dev, wled->short_irq,\n\t\t\t\t       NULL, wled_short_irq_handler,\n\t\t\t\t       IRQF_ONESHOT,\n\t\t\t\t       \"wled_short_irq\", wled);\n\tif (rc < 0)\n\t\tdev_err(wled->dev, \"Unable to request short_irq (err:%d)\\n\",\n\t\t\trc);\n\n\treturn rc;\n}\n\nstatic int wled_configure_ovp_irq(struct wled *wled,\n\t\t\t\t  struct platform_device *pdev)\n{\n\tint rc;\n\tu32 val;\n\n\twled->ovp_irq = platform_get_irq_byname(pdev, \"ovp\");\n\tif (wled->ovp_irq < 0) {\n\t\tdev_dbg(&pdev->dev, \"OVP IRQ not found - disabling automatic string detection\\n\");\n\t\treturn 0;\n\t}\n\n\trc = devm_request_threaded_irq(wled->dev, wled->ovp_irq, NULL,\n\t\t\t\t       wled_ovp_irq_handler, IRQF_ONESHOT,\n\t\t\t\t       \"wled_ovp_irq\", wled);\n\tif (rc < 0) {\n\t\tdev_err(wled->dev, \"Unable to request ovp_irq (err:%d)\\n\",\n\t\t\trc);\n\t\twled->ovp_irq = 0;\n\t\treturn 0;\n\t}\n\n\trc = regmap_read(wled->regmap, wled->ctrl_addr +\n\t\t\t WLED3_CTRL_REG_MOD_EN, &val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (!(val & WLED3_CTRL_REG_MOD_EN_MASK))\n\t\tdisable_irq(wled->ovp_irq);\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops wled_ops = {\n\t.update_status = wled_update_status,\n};\n\nstatic int wled_probe(struct platform_device *pdev)\n{\n\tstruct backlight_properties props;\n\tstruct backlight_device *bl;\n\tstruct wled *wled;\n\tstruct regmap *regmap;\n\tu32 val;\n\tint rc;\n\n\tregmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!regmap) {\n\t\tdev_err(&pdev->dev, \"Unable to get regmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twled = devm_kzalloc(&pdev->dev, sizeof(*wled), GFP_KERNEL);\n\tif (!wled)\n\t\treturn -ENOMEM;\n\n\twled->regmap = regmap;\n\twled->dev = &pdev->dev;\n\n\twled->version = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\tif (!wled->version) {\n\t\tdev_err(&pdev->dev, \"Unknown device version\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_init(&wled->lock);\n\trc = wled_configure(wled);\n\tif (rc)\n\t\treturn rc;\n\n\tval = WLED3_SINK_REG_BRIGHT_MAX;\n\tof_property_read_u32(pdev->dev.of_node, \"max-brightness\", &val);\n\twled->max_brightness = val;\n\n\tswitch (wled->version) {\n\tcase 3:\n\t\twled->cfg.auto_detection_enabled = false;\n\t\trc = wled3_setup(wled);\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev, \"wled3_setup failed\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\twled->has_short_detect = true;\n\t\trc = wled4_setup(wled);\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev, \"wled4_setup failed\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tbreak;\n\n\tcase 5:\n\t\twled->has_short_detect = true;\n\t\tif (wled->cfg.cabc_sel)\n\t\t\twled->max_brightness = WLED5_SINK_REG_BRIGHT_MAX_12B;\n\n\t\trc = wled5_setup(wled);\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev, \"wled5_setup failed\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(wled->dev, \"Invalid WLED version\\n\");\n\t\tbreak;\n\t}\n\n\tINIT_DELAYED_WORK(&wled->ovp_work, wled_ovp_work);\n\n\trc = wled_configure_short_irq(wled, pdev);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = wled_configure_ovp_irq(wled, pdev);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tval = WLED_DEFAULT_BRIGHTNESS;\n\tof_property_read_u32(pdev->dev.of_node, \"default-brightness\", &val);\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.brightness = val;\n\tprops.max_brightness = wled->max_brightness;\n\tbl = devm_backlight_device_register(&pdev->dev, wled->name,\n\t\t\t\t\t    &pdev->dev, wled,\n\t\t\t\t\t    &wled_ops, &props);\n\treturn PTR_ERR_OR_ZERO(bl);\n};\n\nstatic void wled_remove(struct platform_device *pdev)\n{\n\tstruct wled *wled = platform_get_drvdata(pdev);\n\n\tmutex_destroy(&wled->lock);\n\tcancel_delayed_work_sync(&wled->ovp_work);\n\tdisable_irq(wled->short_irq);\n\tdisable_irq(wled->ovp_irq);\n}\n\nstatic const struct of_device_id wled_match_table[] = {\n\t{ .compatible = \"qcom,pm8941-wled\", .data = (void *)3 },\n\t{ .compatible = \"qcom,pmi8950-wled\", .data = (void *)4 },\n\t{ .compatible = \"qcom,pmi8994-wled\", .data = (void *)4 },\n\t{ .compatible = \"qcom,pmi8998-wled\", .data = (void *)4 },\n\t{ .compatible = \"qcom,pm660l-wled\", .data = (void *)4 },\n\t{ .compatible = \"qcom,pm6150l-wled\", .data = (void *)5 },\n\t{ .compatible = \"qcom,pm8150l-wled\", .data = (void *)5 },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, wled_match_table);\n\nstatic struct platform_driver wled_driver = {\n\t.probe = wled_probe,\n\t.remove_new = wled_remove,\n\t.driver\t= {\n\t\t.name = \"qcom,wled\",\n\t\t.of_match_table\t= wled_match_table,\n\t},\n};\n\nmodule_platform_driver(wled_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm WLED driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}