{
  "module_name": "otm3225a.c",
  "hash_id": "fa90f573104734b3e216acd7e56d2f5e044dfe652d26837c3f3b7a45da58b6b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/otm3225a.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/lcd.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n\n#define OTM3225A_INDEX_REG\t0x70\n#define OTM3225A_DATA_REG\t0x72\n\n \n#define DRIVER_OUTPUT_CTRL_1\t0x01\n#define DRIVER_WAVEFORM_CTRL\t0x02\n#define ENTRY_MODE\t\t0x03\n#define SCALING_CTRL\t\t0x04\n#define DISPLAY_CTRL_1\t\t0x07\n#define DISPLAY_CTRL_2\t\t0x08\n#define DISPLAY_CTRL_3\t\t0x09\n#define FRAME_CYCLE_CTRL\t0x0A\n#define EXT_DISP_IFACE_CTRL_1\t0x0C\n#define FRAME_MAKER_POS\t\t0x0D\n#define EXT_DISP_IFACE_CTRL_2\t0x0F\n#define POWER_CTRL_1\t\t0x10\n#define POWER_CTRL_2\t\t0x11\n#define POWER_CTRL_3\t\t0x12\n#define POWER_CTRL_4\t\t0x13\n#define GRAM_ADDR_HORIZ_SET\t0x20\n#define GRAM_ADDR_VERT_SET\t0x21\n#define GRAM_READ_WRITE\t\t0x22\n#define POWER_CTRL_7\t\t0x29\n#define FRAME_RATE_CTRL\t\t0x2B\n#define GAMMA_CTRL_1\t\t0x30\n#define GAMMA_CTRL_2\t\t0x31\n#define GAMMA_CTRL_3\t\t0x32\n#define GAMMA_CTRL_4\t\t0x35\n#define GAMMA_CTRL_5\t\t0x36\n#define GAMMA_CTRL_6\t\t0x37\n#define GAMMA_CTRL_7\t\t0x38\n#define GAMMA_CTRL_8\t\t0x39\n#define GAMMA_CTRL_9\t\t0x3C\n#define GAMMA_CTRL_10\t\t0x3D\n#define WINDOW_HORIZ_RAM_START\t0x50\n#define WINDOW_HORIZ_RAM_END\t0x51\n#define WINDOW_VERT_RAM_START\t0x52\n#define WINDOW_VERT_RAM_END\t0x53\n#define DRIVER_OUTPUT_CTRL_2\t0x60\n#define BASE_IMG_DISPLAY_CTRL\t0x61\n#define VERT_SCROLL_CTRL\t0x6A\n#define PD1_DISPLAY_POS\t\t0x80\n#define PD1_RAM_START\t\t0x81\n#define PD1_RAM_END\t\t0x82\n#define PD2_DISPLAY_POS\t\t0x83\n#define PD2_RAM_START\t\t0x84\n#define PD2_RAM_END\t\t0x85\n#define PANEL_IFACE_CTRL_1\t0x90\n#define PANEL_IFACE_CTRL_2\t0x92\n#define PANEL_IFACE_CTRL_4\t0x95\n#define PANEL_IFACE_CTRL_5\t0x97\n\nstruct otm3225a_data {\n\tstruct spi_device *spi;\n\tstruct lcd_device *ld;\n\tint power;\n};\n\nstruct otm3225a_spi_instruction {\n\tunsigned char reg;\t \n\tunsigned short value;\t \n\tunsigned short delay;\t \n};\n\nstatic struct otm3225a_spi_instruction display_init[] = {\n\t{ DRIVER_OUTPUT_CTRL_1,\t\t0x0000, 0 },\n\t{ DRIVER_WAVEFORM_CTRL,\t\t0x0700, 0 },\n\t{ ENTRY_MODE,\t\t\t0x50A0, 0 },\n\t{ SCALING_CTRL,\t\t\t0x0000, 0 },\n\t{ DISPLAY_CTRL_2,\t\t0x0606, 0 },\n\t{ DISPLAY_CTRL_3,\t\t0x0000, 0 },\n\t{ FRAME_CYCLE_CTRL,\t\t0x0000, 0 },\n\t{ EXT_DISP_IFACE_CTRL_1,\t0x0000, 0 },\n\t{ FRAME_MAKER_POS,\t\t0x0000, 0 },\n\t{ EXT_DISP_IFACE_CTRL_2,\t0x0002, 0 },\n\t{ POWER_CTRL_2,\t\t\t0x0007, 0 },\n\t{ POWER_CTRL_3,\t\t\t0x0000, 0 },\n\t{ POWER_CTRL_4,\t\t\t0x0000, 200 },\n\t{ DISPLAY_CTRL_1,\t\t0x0101, 0 },\n\t{ POWER_CTRL_1,\t\t\t0x12B0, 0 },\n\t{ POWER_CTRL_2,\t\t\t0x0007, 0 },\n\t{ POWER_CTRL_3,\t\t\t0x01BB, 50 },\n\t{ POWER_CTRL_4,\t\t\t0x0013, 0 },\n\t{ POWER_CTRL_7,\t\t\t0x0010, 50 },\n\t{ GAMMA_CTRL_1,\t\t\t0x000A, 0 },\n\t{ GAMMA_CTRL_2,\t\t\t0x1326, 0 },\n\t{ GAMMA_CTRL_3,\t\t\t0x0A29, 0 },\n\t{ GAMMA_CTRL_4,\t\t\t0x0A0A, 0 },\n\t{ GAMMA_CTRL_5,\t\t\t0x1E03, 0 },\n\t{ GAMMA_CTRL_6,\t\t\t0x031E, 0 },\n\t{ GAMMA_CTRL_7,\t\t\t0x0706, 0 },\n\t{ GAMMA_CTRL_8,\t\t\t0x0303, 0 },\n\t{ GAMMA_CTRL_9,\t\t\t0x010E, 0 },\n\t{ GAMMA_CTRL_10,\t\t0x040E, 0 },\n\t{ WINDOW_HORIZ_RAM_START,\t0x0000, 0 },\n\t{ WINDOW_HORIZ_RAM_END,\t\t0x00EF, 0 },\n\t{ WINDOW_VERT_RAM_START,\t0x0000, 0 },\n\t{ WINDOW_VERT_RAM_END,\t\t0x013F, 0 },\n\t{ DRIVER_OUTPUT_CTRL_2,\t\t0x2700, 0 },\n\t{ BASE_IMG_DISPLAY_CTRL,\t0x0001, 0 },\n\t{ VERT_SCROLL_CTRL,\t\t0x0000, 0 },\n\t{ PD1_DISPLAY_POS,\t\t0x0000, 0 },\n\t{ PD1_RAM_START,\t\t0x0000, 0 },\n\t{ PD1_RAM_END,\t\t\t0x0000, 0 },\n\t{ PD2_DISPLAY_POS,\t\t0x0000, 0 },\n\t{ PD2_RAM_START,\t\t0x0000, 0 },\n\t{ PD2_RAM_END,\t\t\t0x0000, 0 },\n\t{ PANEL_IFACE_CTRL_1,\t\t0x0010, 0 },\n\t{ PANEL_IFACE_CTRL_2,\t\t0x0000, 0 },\n\t{ PANEL_IFACE_CTRL_4,\t\t0x0210, 0 },\n\t{ PANEL_IFACE_CTRL_5,\t\t0x0000, 0 },\n\t{ DISPLAY_CTRL_1,\t\t0x0133, 0 },\n};\n\nstatic struct otm3225a_spi_instruction display_enable_rgb_interface[] = {\n\t{ ENTRY_MODE,\t\t\t0x1080, 0 },\n\t{ GRAM_ADDR_HORIZ_SET,\t\t0x0000, 0 },\n\t{ GRAM_ADDR_VERT_SET,\t\t0x0000, 0 },\n\t{ EXT_DISP_IFACE_CTRL_1,\t0x0111, 500 },\n};\n\nstatic struct otm3225a_spi_instruction display_off[] = {\n\t{ DISPLAY_CTRL_1,\t0x0131, 100 },\n\t{ DISPLAY_CTRL_1,\t0x0130, 100 },\n\t{ DISPLAY_CTRL_1,\t0x0100, 0 },\n\t{ POWER_CTRL_1,\t\t0x0280, 0 },\n\t{ POWER_CTRL_3,\t\t0x018B, 0 },\n};\n\nstatic struct otm3225a_spi_instruction display_on[] = {\n\t{ POWER_CTRL_1,\t\t0x1280, 0 },\n\t{ DISPLAY_CTRL_1,\t0x0101, 100 },\n\t{ DISPLAY_CTRL_1,\t0x0121, 0 },\n\t{ DISPLAY_CTRL_1,\t0x0123, 100 },\n\t{ DISPLAY_CTRL_1,\t0x0133, 10 },\n};\n\nstatic void otm3225a_write(struct spi_device *spi,\n\t\t\t   struct otm3225a_spi_instruction *instruction,\n\t\t\t   unsigned int count)\n{\n\tunsigned char buf[3];\n\n\twhile (count--) {\n\t\t \n\t\tbuf[0] = OTM3225A_INDEX_REG;\n\t\tbuf[1] = 0x00;\n\t\tbuf[2] = instruction->reg;\n\t\tspi_write(spi, buf, 3);\n\n\t\t \n\t\tbuf[0] = OTM3225A_DATA_REG;\n\t\tbuf[1] = (instruction->value >> 8) & 0xff;\n\t\tbuf[2] = instruction->value & 0xff;\n\t\tspi_write(spi, buf, 3);\n\n\t\t \n\t\tif (instruction->delay)\n\t\t\tmsleep(instruction->delay);\n\t\tinstruction++;\n\t}\n}\n\nstatic int otm3225a_set_power(struct lcd_device *ld, int power)\n{\n\tstruct otm3225a_data *dd = lcd_get_data(ld);\n\n\tif (power == dd->power)\n\t\treturn 0;\n\n\tif (power > FB_BLANK_UNBLANK)\n\t\totm3225a_write(dd->spi, display_off, ARRAY_SIZE(display_off));\n\telse\n\t\totm3225a_write(dd->spi, display_on, ARRAY_SIZE(display_on));\n\tdd->power = power;\n\n\treturn 0;\n}\n\nstatic int otm3225a_get_power(struct lcd_device *ld)\n{\n\tstruct otm3225a_data *dd = lcd_get_data(ld);\n\n\treturn dd->power;\n}\n\nstatic struct lcd_ops otm3225a_ops = {\n\t.set_power = otm3225a_set_power,\n\t.get_power = otm3225a_get_power,\n};\n\nstatic int otm3225a_probe(struct spi_device *spi)\n{\n\tstruct otm3225a_data *dd;\n\tstruct lcd_device *ld;\n\tstruct device *dev = &spi->dev;\n\n\tdd = devm_kzalloc(dev, sizeof(struct otm3225a_data), GFP_KERNEL);\n\tif (dd == NULL)\n\t\treturn -ENOMEM;\n\n\tld = devm_lcd_device_register(dev, dev_name(dev), dev, dd,\n\t\t\t\t      &otm3225a_ops);\n\tif (IS_ERR(ld))\n\t\treturn PTR_ERR(ld);\n\n\tdd->spi = spi;\n\tdd->ld = ld;\n\tdev_set_drvdata(dev, dd);\n\n\tdev_info(dev, \"Initializing and switching to RGB interface\");\n\totm3225a_write(spi, display_init, ARRAY_SIZE(display_init));\n\totm3225a_write(spi, display_enable_rgb_interface,\n\t\t       ARRAY_SIZE(display_enable_rgb_interface));\n\treturn 0;\n}\n\nstatic struct spi_driver otm3225a_driver = {\n\t.driver = {\n\t\t.name = \"otm3225a\",\n\t\t.owner = THIS_MODULE,\n\t},\n\t.probe = otm3225a_probe,\n};\n\nmodule_spi_driver(otm3225a_driver);\n\nMODULE_AUTHOR(\"Felix Brack <fb@ltec.ch>\");\nMODULE_DESCRIPTION(\"OTM3225A TFT LCD driver\");\nMODULE_VERSION(\"1.0.0\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}