{
  "module_name": "corgi_lcd.c",
  "hash_id": "5f633609d3ab48e8b12a1ab804b88697b0c9fe6391b1ddca6fe704ad235b2f83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/corgi_lcd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/fb.h>\n#include <linux/lcd.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/corgi_lcd.h>\n#include <linux/slab.h>\n#include <asm/mach/sharpsl_param.h>\n\n#define POWER_IS_ON(pwr)\t((pwr) <= FB_BLANK_NORMAL)\n\n \n#define RESCTL_ADRS     0x00\n#define PHACTRL_ADRS    0x01\n#define DUTYCTRL_ADRS   0x02\n#define POWERREG0_ADRS  0x03\n#define POWERREG1_ADRS  0x04\n#define GPOR3_ADRS      0x05\n#define PICTRL_ADRS     0x06\n#define POLCTRL_ADRS    0x07\n\n \n#define RESCTL_QVGA     0x01\n#define RESCTL_VGA      0x00\n\n#define POWER1_VW_ON    0x01   \n#define POWER1_GVSS_ON  0x02   \n#define POWER1_VDD_ON   0x04   \n\n#define POWER1_VW_OFF   0x00   \n#define POWER1_GVSS_OFF 0x00   \n#define POWER1_VDD_OFF  0x00   \n\n#define POWER0_COM_DCLK 0x01   \n#define POWER0_COM_DOUT 0x02   \n#define POWER0_DAC_ON   0x04   \n#define POWER0_COM_ON   0x08   \n#define POWER0_VCC5_ON  0x10   \n\n#define POWER0_DAC_OFF  0x00   \n#define POWER0_COM_OFF  0x00   \n#define POWER0_VCC5_OFF 0x00   \n\n#define PICTRL_INIT_STATE      0x01\n#define PICTRL_INIOFF          0x02\n#define PICTRL_POWER_DOWN      0x04\n#define PICTRL_COM_SIGNAL_OFF  0x08\n#define PICTRL_DAC_SIGNAL_OFF  0x10\n\n#define POLCTRL_SYNC_POL_FALL  0x01\n#define POLCTRL_EN_POL_FALL    0x02\n#define POLCTRL_DATA_POL_FALL  0x04\n#define POLCTRL_SYNC_ACT_H     0x08\n#define POLCTRL_EN_ACT_L       0x10\n\n#define POLCTRL_SYNC_POL_RISE  0x00\n#define POLCTRL_EN_POL_RISE    0x00\n#define POLCTRL_DATA_POL_RISE  0x00\n#define POLCTRL_SYNC_ACT_L     0x00\n#define POLCTRL_EN_ACT_H       0x00\n\n#define PHACTRL_PHASE_MANUAL   0x01\n#define DEFAULT_PHAD_QVGA     (9)\n#define DEFAULT_COMADJ        (125)\n\nstruct corgi_lcd {\n\tstruct spi_device\t*spi_dev;\n\tstruct lcd_device\t*lcd_dev;\n\tstruct backlight_device\t*bl_dev;\n\n\tint\tlimit_mask;\n\tint\tintensity;\n\tint\tpower;\n\tint\tmode;\n\tchar\tbuf[2];\n\n\tstruct gpio_desc *backlight_on;\n\tstruct gpio_desc *backlight_cont;\n\n\tvoid (*kick_battery)(void);\n};\n\nstatic int corgi_ssp_lcdtg_send(struct corgi_lcd *lcd, int reg, uint8_t val);\n\nstatic struct corgi_lcd *the_corgi_lcd;\nstatic unsigned long corgibl_flags;\n#define CORGIBL_SUSPENDED     0x01\n#define CORGIBL_BATTLOW       0x02\n\n \nstatic void lcdtg_ssp_i2c_send(struct corgi_lcd *lcd, uint8_t data)\n{\n\tcorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS, data);\n\tudelay(10);\n}\n\nstatic void lcdtg_i2c_send_bit(struct corgi_lcd *lcd, uint8_t data)\n{\n\tlcdtg_ssp_i2c_send(lcd, data);\n\tlcdtg_ssp_i2c_send(lcd, data | POWER0_COM_DCLK);\n\tlcdtg_ssp_i2c_send(lcd, data);\n}\n\nstatic void lcdtg_i2c_send_start(struct corgi_lcd *lcd, uint8_t base)\n{\n\tlcdtg_ssp_i2c_send(lcd, base | POWER0_COM_DCLK | POWER0_COM_DOUT);\n\tlcdtg_ssp_i2c_send(lcd, base | POWER0_COM_DCLK);\n\tlcdtg_ssp_i2c_send(lcd, base);\n}\n\nstatic void lcdtg_i2c_send_stop(struct corgi_lcd *lcd, uint8_t base)\n{\n\tlcdtg_ssp_i2c_send(lcd, base);\n\tlcdtg_ssp_i2c_send(lcd, base | POWER0_COM_DCLK);\n\tlcdtg_ssp_i2c_send(lcd, base | POWER0_COM_DCLK | POWER0_COM_DOUT);\n}\n\nstatic void lcdtg_i2c_send_byte(struct corgi_lcd *lcd,\n\t\t\t\tuint8_t base, uint8_t data)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (data & 0x80)\n\t\t\tlcdtg_i2c_send_bit(lcd, base | POWER0_COM_DOUT);\n\t\telse\n\t\t\tlcdtg_i2c_send_bit(lcd, base);\n\t\tdata <<= 1;\n\t}\n}\n\nstatic void lcdtg_i2c_wait_ack(struct corgi_lcd *lcd, uint8_t base)\n{\n\tlcdtg_i2c_send_bit(lcd, base);\n}\n\nstatic void lcdtg_set_common_voltage(struct corgi_lcd *lcd,\n\t\t\t\t     uint8_t base_data, uint8_t data)\n{\n\t \n\tlcdtg_i2c_send_start(lcd, base_data);\n\tlcdtg_i2c_send_byte(lcd, base_data, 0x9c);\n\tlcdtg_i2c_wait_ack(lcd, base_data);\n\tlcdtg_i2c_send_byte(lcd, base_data, 0x00);\n\tlcdtg_i2c_wait_ack(lcd, base_data);\n\tlcdtg_i2c_send_byte(lcd, base_data, data);\n\tlcdtg_i2c_wait_ack(lcd, base_data);\n\tlcdtg_i2c_send_stop(lcd, base_data);\n}\n\nstatic int corgi_ssp_lcdtg_send(struct corgi_lcd *lcd, int adrs, uint8_t data)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer = {\n\t\t.len\t\t= 1,\n\t\t.cs_change\t= 0,\n\t\t.tx_buf\t\t= lcd->buf,\n\t};\n\n\tlcd->buf[0] = ((adrs & 0x07) << 5) | (data & 0x1f);\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer, &msg);\n\n\treturn spi_sync(lcd->spi_dev, &msg);\n}\n\n \nstatic void lcdtg_set_phadadj(struct corgi_lcd *lcd, int mode)\n{\n\tint adj;\n\n\tswitch (mode) {\n\tcase CORGI_LCD_MODE_VGA:\n\t\t \n\t\tadj = sharpsl_param.phadadj;\n\t\tadj = (adj < 0) ? PHACTRL_PHASE_MANUAL :\n\t\t\t\t  PHACTRL_PHASE_MANUAL | ((adj & 0xf) << 1);\n\t\tbreak;\n\tcase CORGI_LCD_MODE_QVGA:\n\tdefault:\n\t\t \n\t\tadj = (DEFAULT_PHAD_QVGA << 1) | PHACTRL_PHASE_MANUAL;\n\t\tbreak;\n\t}\n\n\tcorgi_ssp_lcdtg_send(lcd, PHACTRL_ADRS, adj);\n}\n\nstatic void corgi_lcd_power_on(struct corgi_lcd *lcd)\n{\n\tint comadj;\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, PICTRL_ADRS,\n\t\t\tPICTRL_POWER_DOWN | PICTRL_INIOFF |\n\t\t\tPICTRL_INIT_STATE | PICTRL_COM_SIGNAL_OFF |\n\t\t\tPICTRL_DAC_SIGNAL_OFF);\n\n\tcorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\n\t\t\tPOWER0_COM_DCLK | POWER0_COM_DOUT | POWER0_DAC_OFF |\n\t\t\tPOWER0_COM_OFF | POWER0_VCC5_OFF);\n\n\tcorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\n\t\t\tPOWER1_VW_OFF | POWER1_GVSS_OFF | POWER1_VDD_OFF);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\n\t\t\tPOWER1_VW_OFF | POWER1_GVSS_OFF | POWER1_VDD_ON);\n\tmdelay(3);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\n\t\t\tPOWER0_COM_DCLK | POWER0_COM_DOUT | POWER0_DAC_ON |\n\t\t\tPOWER0_COM_OFF | POWER0_VCC5_OFF);\n\n\t \n\t \n\tcorgi_ssp_lcdtg_send(lcd, PICTRL_ADRS,\n\t\t\tPICTRL_INIT_STATE | PICTRL_COM_SIGNAL_OFF);\n\n\t \n\tcomadj = sharpsl_param.comadj;\n\tif (comadj < 0)\n\t\tcomadj = DEFAULT_COMADJ;\n\n\tlcdtg_set_common_voltage(lcd, POWER0_DAC_ON | POWER0_COM_OFF |\n\t\t\t\t POWER0_VCC5_OFF, comadj);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\n\t\t\tPOWER0_COM_DCLK | POWER0_COM_DOUT | POWER0_DAC_ON |\n\t\t\tPOWER0_COM_OFF | POWER0_VCC5_ON);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\n\t\t\tPOWER1_VW_OFF | POWER1_GVSS_ON | POWER1_VDD_ON);\n\tmdelay(2);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, PICTRL_ADRS, PICTRL_INIT_STATE);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\n\t\t\tPOWER0_COM_DCLK | POWER0_COM_DOUT | POWER0_DAC_ON |\n\t\t\tPOWER0_COM_ON | POWER0_VCC5_ON);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\n\t\t\tPOWER1_VW_ON | POWER1_GVSS_ON | POWER1_VDD_ON);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, PICTRL_ADRS, 0);\n\n\t \n\tlcdtg_set_phadadj(lcd, lcd->mode);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, POLCTRL_ADRS,\n\t\t\tPOLCTRL_SYNC_POL_RISE | POLCTRL_EN_POL_RISE |\n\t\t\tPOLCTRL_DATA_POL_RISE | POLCTRL_SYNC_ACT_L |\n\t\t\tPOLCTRL_EN_ACT_H);\n\tudelay(1000);\n\n\tswitch (lcd->mode) {\n\tcase CORGI_LCD_MODE_VGA:\n\t\tcorgi_ssp_lcdtg_send(lcd, RESCTL_ADRS, RESCTL_VGA);\n\t\tbreak;\n\tcase CORGI_LCD_MODE_QVGA:\n\tdefault:\n\t\tcorgi_ssp_lcdtg_send(lcd, RESCTL_ADRS, RESCTL_QVGA);\n\t\tbreak;\n\t}\n}\n\nstatic void corgi_lcd_power_off(struct corgi_lcd *lcd)\n{\n\t \n\tmsleep(34);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\n\t\t\tPOWER1_VW_OFF | POWER1_GVSS_ON | POWER1_VDD_ON);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, PICTRL_ADRS, PICTRL_COM_SIGNAL_OFF);\n\tcorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\n\t\t\tPOWER0_DAC_ON | POWER0_COM_OFF | POWER0_VCC5_ON);\n\n\t \n\tlcdtg_set_common_voltage(lcd, POWER0_DAC_ON | POWER0_COM_OFF |\n\t\t\tPOWER0_VCC5_ON, 0);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\n\t\t\tPOWER1_VW_OFF | POWER1_GVSS_OFF | POWER1_VDD_ON);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\n\t\t\tPOWER0_DAC_ON | POWER0_COM_OFF | POWER0_VCC5_OFF);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, PICTRL_ADRS,\n\t\t\tPICTRL_INIOFF | PICTRL_DAC_SIGNAL_OFF |\n\t\t\tPICTRL_POWER_DOWN | PICTRL_COM_SIGNAL_OFF);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\n\t\t\tPOWER0_DAC_OFF | POWER0_COM_OFF | POWER0_VCC5_OFF);\n\n\t \n\tcorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\n\t\t\tPOWER1_VW_OFF | POWER1_GVSS_OFF | POWER1_VDD_OFF);\n}\n\nstatic int corgi_lcd_set_mode(struct lcd_device *ld, struct fb_videomode *m)\n{\n\tstruct corgi_lcd *lcd = lcd_get_data(ld);\n\tint mode = CORGI_LCD_MODE_QVGA;\n\n\tif (m->xres == 640 || m->xres == 480)\n\t\tmode = CORGI_LCD_MODE_VGA;\n\n\tif (lcd->mode == mode)\n\t\treturn 0;\n\n\tlcdtg_set_phadadj(lcd, mode);\n\n\tswitch (mode) {\n\tcase CORGI_LCD_MODE_VGA:\n\t\tcorgi_ssp_lcdtg_send(lcd, RESCTL_ADRS, RESCTL_VGA);\n\t\tbreak;\n\tcase CORGI_LCD_MODE_QVGA:\n\tdefault:\n\t\tcorgi_ssp_lcdtg_send(lcd, RESCTL_ADRS, RESCTL_QVGA);\n\t\tbreak;\n\t}\n\n\tlcd->mode = mode;\n\treturn 0;\n}\n\nstatic int corgi_lcd_set_power(struct lcd_device *ld, int power)\n{\n\tstruct corgi_lcd *lcd = lcd_get_data(ld);\n\n\tif (POWER_IS_ON(power) && !POWER_IS_ON(lcd->power))\n\t\tcorgi_lcd_power_on(lcd);\n\n\tif (!POWER_IS_ON(power) && POWER_IS_ON(lcd->power))\n\t\tcorgi_lcd_power_off(lcd);\n\n\tlcd->power = power;\n\treturn 0;\n}\n\nstatic int corgi_lcd_get_power(struct lcd_device *ld)\n{\n\tstruct corgi_lcd *lcd = lcd_get_data(ld);\n\n\treturn lcd->power;\n}\n\nstatic struct lcd_ops corgi_lcd_ops = {\n\t.get_power\t= corgi_lcd_get_power,\n\t.set_power\t= corgi_lcd_set_power,\n\t.set_mode\t= corgi_lcd_set_mode,\n};\n\nstatic int corgi_bl_get_intensity(struct backlight_device *bd)\n{\n\tstruct corgi_lcd *lcd = bl_get_data(bd);\n\n\treturn lcd->intensity;\n}\n\nstatic int corgi_bl_set_intensity(struct corgi_lcd *lcd, int intensity)\n{\n\tint cont;\n\n\tif (intensity > 0x10)\n\t\tintensity += 0x10;\n\n\tcorgi_ssp_lcdtg_send(lcd, DUTYCTRL_ADRS, intensity);\n\n\t \n\tcont = !!(intensity & 0x20);\n\n\tif (lcd->backlight_cont)\n\t\tgpiod_set_value_cansleep(lcd->backlight_cont, cont);\n\n\tif (lcd->backlight_on)\n\t\tgpiod_set_value_cansleep(lcd->backlight_on, intensity);\n\n\tif (lcd->kick_battery)\n\t\tlcd->kick_battery();\n\n\tlcd->intensity = intensity;\n\treturn 0;\n}\n\nstatic int corgi_bl_update_status(struct backlight_device *bd)\n{\n\tstruct corgi_lcd *lcd = bl_get_data(bd);\n\tint intensity = backlight_get_brightness(bd);\n\n\tif (corgibl_flags & CORGIBL_SUSPENDED)\n\t\tintensity = 0;\n\n\tif ((corgibl_flags & CORGIBL_BATTLOW) && intensity > lcd->limit_mask)\n\t\tintensity = lcd->limit_mask;\n\n\treturn corgi_bl_set_intensity(lcd, intensity);\n}\n\nvoid corgi_lcd_limit_intensity(int limit)\n{\n\tif (limit)\n\t\tcorgibl_flags |= CORGIBL_BATTLOW;\n\telse\n\t\tcorgibl_flags &= ~CORGIBL_BATTLOW;\n\n\tbacklight_update_status(the_corgi_lcd->bl_dev);\n}\nEXPORT_SYMBOL(corgi_lcd_limit_intensity);\n\nstatic const struct backlight_ops corgi_bl_ops = {\n\t.get_brightness\t= corgi_bl_get_intensity,\n\t.update_status  = corgi_bl_update_status,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int corgi_lcd_suspend(struct device *dev)\n{\n\tstruct corgi_lcd *lcd = dev_get_drvdata(dev);\n\n\tcorgibl_flags |= CORGIBL_SUSPENDED;\n\tcorgi_bl_set_intensity(lcd, 0);\n\tcorgi_lcd_set_power(lcd->lcd_dev, FB_BLANK_POWERDOWN);\n\treturn 0;\n}\n\nstatic int corgi_lcd_resume(struct device *dev)\n{\n\tstruct corgi_lcd *lcd = dev_get_drvdata(dev);\n\n\tcorgibl_flags &= ~CORGIBL_SUSPENDED;\n\tcorgi_lcd_set_power(lcd->lcd_dev, FB_BLANK_UNBLANK);\n\tbacklight_update_status(lcd->bl_dev);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(corgi_lcd_pm_ops, corgi_lcd_suspend, corgi_lcd_resume);\n\nstatic int setup_gpio_backlight(struct corgi_lcd *lcd,\n\t\t\t\tstruct corgi_lcd_platform_data *pdata)\n{\n\tstruct spi_device *spi = lcd->spi_dev;\n\n\tlcd->backlight_on = devm_gpiod_get_optional(&spi->dev,\n\t\t\t\t\t\t    \"BL_ON\", GPIOD_OUT_LOW);\n\tif (IS_ERR(lcd->backlight_on))\n\t\treturn PTR_ERR(lcd->backlight_on);\n\n\tlcd->backlight_cont = devm_gpiod_get_optional(&spi->dev, \"BL_CONT\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(lcd->backlight_cont))\n\t\treturn PTR_ERR(lcd->backlight_cont);\n\n\treturn 0;\n}\n\nstatic int corgi_lcd_probe(struct spi_device *spi)\n{\n\tstruct backlight_properties props;\n\tstruct corgi_lcd_platform_data *pdata = dev_get_platdata(&spi->dev);\n\tstruct corgi_lcd *lcd;\n\tint ret = 0;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&spi->dev, \"platform data not available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlcd = devm_kzalloc(&spi->dev, sizeof(struct corgi_lcd), GFP_KERNEL);\n\tif (!lcd)\n\t\treturn -ENOMEM;\n\n\tlcd->spi_dev = spi;\n\n\tlcd->lcd_dev = devm_lcd_device_register(&spi->dev, \"corgi_lcd\",\n\t\t\t\t\t\t&spi->dev, lcd, &corgi_lcd_ops);\n\tif (IS_ERR(lcd->lcd_dev))\n\t\treturn PTR_ERR(lcd->lcd_dev);\n\n\tlcd->power = FB_BLANK_POWERDOWN;\n\tlcd->mode = (pdata) ? pdata->init_mode : CORGI_LCD_MODE_VGA;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = pdata->max_intensity;\n\tlcd->bl_dev = devm_backlight_device_register(&spi->dev, \"corgi_bl\",\n\t\t\t\t\t\t&spi->dev, lcd, &corgi_bl_ops,\n\t\t\t\t\t\t&props);\n\tif (IS_ERR(lcd->bl_dev))\n\t\treturn PTR_ERR(lcd->bl_dev);\n\n\tlcd->bl_dev->props.brightness = pdata->default_intensity;\n\tlcd->bl_dev->props.power = FB_BLANK_UNBLANK;\n\n\tret = setup_gpio_backlight(lcd, pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tlcd->kick_battery = pdata->kick_battery;\n\n\tspi_set_drvdata(spi, lcd);\n\tcorgi_lcd_set_power(lcd->lcd_dev, FB_BLANK_UNBLANK);\n\tbacklight_update_status(lcd->bl_dev);\n\n\tlcd->limit_mask = pdata->limit_mask;\n\tthe_corgi_lcd = lcd;\n\treturn 0;\n}\n\nstatic void corgi_lcd_remove(struct spi_device *spi)\n{\n\tstruct corgi_lcd *lcd = spi_get_drvdata(spi);\n\n\tlcd->bl_dev->props.power = FB_BLANK_UNBLANK;\n\tlcd->bl_dev->props.brightness = 0;\n\tbacklight_update_status(lcd->bl_dev);\n\tcorgi_lcd_set_power(lcd->lcd_dev, FB_BLANK_POWERDOWN);\n}\n\nstatic struct spi_driver corgi_lcd_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"corgi-lcd\",\n\t\t.pm\t= &corgi_lcd_pm_ops,\n\t},\n\t.probe\t\t= corgi_lcd_probe,\n\t.remove\t\t= corgi_lcd_remove,\n};\n\nmodule_spi_driver(corgi_lcd_driver);\n\nMODULE_DESCRIPTION(\"LCD and backlight driver for SHARP C7x0/Cxx00\");\nMODULE_AUTHOR(\"Eric Miao <eric.miao@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:corgi-lcd\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}