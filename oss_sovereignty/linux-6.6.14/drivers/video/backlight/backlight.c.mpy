{
  "module_name": "backlight.c",
  "hash_id": "336f8d0925ae24259d7ca4811450806140e16d98d30a675aa55c6dbefe582fdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/backlight.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/backlight.h>\n#include <linux/notifier.h>\n#include <linux/ctype.h>\n#include <linux/err.h>\n#include <linux/fb.h>\n#include <linux/slab.h>\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n#include <asm/backlight.h>\n#endif\n\n \n\nstatic struct list_head backlight_dev_list;\nstatic struct mutex backlight_dev_list_mutex;\nstatic struct blocking_notifier_head backlight_notifier;\n\nstatic const char *const backlight_types[] = {\n\t[BACKLIGHT_RAW] = \"raw\",\n\t[BACKLIGHT_PLATFORM] = \"platform\",\n\t[BACKLIGHT_FIRMWARE] = \"firmware\",\n};\n\nstatic const char *const backlight_scale_types[] = {\n\t[BACKLIGHT_SCALE_UNKNOWN]\t= \"unknown\",\n\t[BACKLIGHT_SCALE_LINEAR]\t= \"linear\",\n\t[BACKLIGHT_SCALE_NON_LINEAR]\t= \"non-linear\",\n};\n\n#if defined(CONFIG_FB_CORE) || (defined(CONFIG_FB_CORE_MODULE) && \\\n\t\t\t\tdefined(CONFIG_BACKLIGHT_CLASS_DEVICE_MODULE))\n \nstatic int fb_notifier_callback(struct notifier_block *self,\n\t\t\t\tunsigned long event, void *data)\n{\n\tstruct backlight_device *bd;\n\tstruct fb_event *evdata = data;\n\tint node = evdata->info->node;\n\tint fb_blank = 0;\n\n\t \n\tif (event != FB_EVENT_BLANK)\n\t\treturn 0;\n\n\tbd = container_of(self, struct backlight_device, fb_notif);\n\tmutex_lock(&bd->ops_lock);\n\n\tif (!bd->ops)\n\t\tgoto out;\n\tif (bd->ops->check_fb && !bd->ops->check_fb(bd, evdata->info))\n\t\tgoto out;\n\n\tfb_blank = *(int *)evdata->data;\n\tif (fb_blank == FB_BLANK_UNBLANK && !bd->fb_bl_on[node]) {\n\t\tbd->fb_bl_on[node] = true;\n\t\tif (!bd->use_count++) {\n\t\t\tbd->props.state &= ~BL_CORE_FBBLANK;\n\t\t\tbd->props.fb_blank = FB_BLANK_UNBLANK;\n\t\t\tbacklight_update_status(bd);\n\t\t}\n\t} else if (fb_blank != FB_BLANK_UNBLANK && bd->fb_bl_on[node]) {\n\t\tbd->fb_bl_on[node] = false;\n\t\tif (!(--bd->use_count)) {\n\t\t\tbd->props.state |= BL_CORE_FBBLANK;\n\t\t\tbd->props.fb_blank = fb_blank;\n\t\t\tbacklight_update_status(bd);\n\t\t}\n\t}\nout:\n\tmutex_unlock(&bd->ops_lock);\n\treturn 0;\n}\n\nstatic int backlight_register_fb(struct backlight_device *bd)\n{\n\tmemset(&bd->fb_notif, 0, sizeof(bd->fb_notif));\n\tbd->fb_notif.notifier_call = fb_notifier_callback;\n\n\treturn fb_register_client(&bd->fb_notif);\n}\n\nstatic void backlight_unregister_fb(struct backlight_device *bd)\n{\n\tfb_unregister_client(&bd->fb_notif);\n}\n#else\nstatic inline int backlight_register_fb(struct backlight_device *bd)\n{\n\treturn 0;\n}\n\nstatic inline void backlight_unregister_fb(struct backlight_device *bd)\n{\n}\n#endif  \n\nstatic void backlight_generate_event(struct backlight_device *bd,\n\t\t\t\t     enum backlight_update_reason reason)\n{\n\tchar *envp[2];\n\n\tswitch (reason) {\n\tcase BACKLIGHT_UPDATE_SYSFS:\n\t\tenvp[0] = \"SOURCE=sysfs\";\n\t\tbreak;\n\tcase BACKLIGHT_UPDATE_HOTKEY:\n\t\tenvp[0] = \"SOURCE=hotkey\";\n\t\tbreak;\n\tdefault:\n\t\tenvp[0] = \"SOURCE=unknown\";\n\t\tbreak;\n\t}\n\tenvp[1] = NULL;\n\tkobject_uevent_env(&bd->dev.kobj, KOBJ_CHANGE, envp);\n\tsysfs_notify(&bd->dev.kobj, NULL, \"actual_brightness\");\n}\n\nstatic ssize_t bl_power_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct backlight_device *bd = to_backlight_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", bd->props.power);\n}\n\nstatic ssize_t bl_power_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint rc;\n\tstruct backlight_device *bd = to_backlight_device(dev);\n\tunsigned long power, old_power;\n\n\trc = kstrtoul(buf, 0, &power);\n\tif (rc)\n\t\treturn rc;\n\n\trc = -ENXIO;\n\tmutex_lock(&bd->ops_lock);\n\tif (bd->ops) {\n\t\tpr_debug(\"set power to %lu\\n\", power);\n\t\tif (bd->props.power != power) {\n\t\t\told_power = bd->props.power;\n\t\t\tbd->props.power = power;\n\t\t\trc = backlight_update_status(bd);\n\t\t\tif (rc)\n\t\t\t\tbd->props.power = old_power;\n\t\t\telse\n\t\t\t\trc = count;\n\t\t} else {\n\t\t\trc = count;\n\t\t}\n\t}\n\tmutex_unlock(&bd->ops_lock);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RW(bl_power);\n\nstatic ssize_t brightness_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct backlight_device *bd = to_backlight_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", bd->props.brightness);\n}\n\nint backlight_device_set_brightness(struct backlight_device *bd,\n\t\t\t\t    unsigned long brightness)\n{\n\tint rc = -ENXIO;\n\n\tmutex_lock(&bd->ops_lock);\n\tif (bd->ops) {\n\t\tif (brightness > bd->props.max_brightness)\n\t\t\trc = -EINVAL;\n\t\telse {\n\t\t\tpr_debug(\"set brightness to %lu\\n\", brightness);\n\t\t\tbd->props.brightness = brightness;\n\t\t\trc = backlight_update_status(bd);\n\t\t}\n\t}\n\tmutex_unlock(&bd->ops_lock);\n\n\tbacklight_generate_event(bd, BACKLIGHT_UPDATE_SYSFS);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(backlight_device_set_brightness);\n\nstatic ssize_t brightness_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tint rc;\n\tstruct backlight_device *bd = to_backlight_device(dev);\n\tunsigned long brightness;\n\n\trc = kstrtoul(buf, 0, &brightness);\n\tif (rc)\n\t\treturn rc;\n\n\trc = backlight_device_set_brightness(bd, brightness);\n\n\treturn rc ? rc : count;\n}\nstatic DEVICE_ATTR_RW(brightness);\n\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct backlight_device *bd = to_backlight_device(dev);\n\n\treturn sprintf(buf, \"%s\\n\", backlight_types[bd->props.type]);\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic ssize_t max_brightness_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct backlight_device *bd = to_backlight_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", bd->props.max_brightness);\n}\nstatic DEVICE_ATTR_RO(max_brightness);\n\nstatic ssize_t actual_brightness_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tint rc = -ENXIO;\n\tstruct backlight_device *bd = to_backlight_device(dev);\n\n\tmutex_lock(&bd->ops_lock);\n\tif (bd->ops && bd->ops->get_brightness) {\n\t\trc = bd->ops->get_brightness(bd);\n\t\tif (rc >= 0)\n\t\t\trc = sprintf(buf, \"%d\\n\", rc);\n\t} else {\n\t\trc = sprintf(buf, \"%d\\n\", bd->props.brightness);\n\t}\n\tmutex_unlock(&bd->ops_lock);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(actual_brightness);\n\nstatic ssize_t scale_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct backlight_device *bd = to_backlight_device(dev);\n\n\tif (WARN_ON(bd->props.scale > BACKLIGHT_SCALE_NON_LINEAR))\n\t\treturn sprintf(buf, \"unknown\\n\");\n\n\treturn sprintf(buf, \"%s\\n\", backlight_scale_types[bd->props.scale]);\n}\nstatic DEVICE_ATTR_RO(scale);\n\nstatic struct class *backlight_class;\n\n#ifdef CONFIG_PM_SLEEP\nstatic int backlight_suspend(struct device *dev)\n{\n\tstruct backlight_device *bd = to_backlight_device(dev);\n\n\tmutex_lock(&bd->ops_lock);\n\tif (bd->ops && bd->ops->options & BL_CORE_SUSPENDRESUME) {\n\t\tbd->props.state |= BL_CORE_SUSPENDED;\n\t\tbacklight_update_status(bd);\n\t}\n\tmutex_unlock(&bd->ops_lock);\n\n\treturn 0;\n}\n\nstatic int backlight_resume(struct device *dev)\n{\n\tstruct backlight_device *bd = to_backlight_device(dev);\n\n\tmutex_lock(&bd->ops_lock);\n\tif (bd->ops && bd->ops->options & BL_CORE_SUSPENDRESUME) {\n\t\tbd->props.state &= ~BL_CORE_SUSPENDED;\n\t\tbacklight_update_status(bd);\n\t}\n\tmutex_unlock(&bd->ops_lock);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(backlight_class_dev_pm_ops, backlight_suspend,\n\t\t\t backlight_resume);\n\nstatic void bl_device_release(struct device *dev)\n{\n\tstruct backlight_device *bd = to_backlight_device(dev);\n\tkfree(bd);\n}\n\nstatic struct attribute *bl_device_attrs[] = {\n\t&dev_attr_bl_power.attr,\n\t&dev_attr_brightness.attr,\n\t&dev_attr_actual_brightness.attr,\n\t&dev_attr_max_brightness.attr,\n\t&dev_attr_scale.attr,\n\t&dev_attr_type.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(bl_device);\n\n \nvoid backlight_force_update(struct backlight_device *bd,\n\t\t\t    enum backlight_update_reason reason)\n{\n\tint brightness;\n\n\tmutex_lock(&bd->ops_lock);\n\tif (bd->ops && bd->ops->get_brightness) {\n\t\tbrightness = bd->ops->get_brightness(bd);\n\t\tif (brightness >= 0)\n\t\t\tbd->props.brightness = brightness;\n\t\telse\n\t\t\tdev_err(&bd->dev,\n\t\t\t\t\"Could not update brightness from device: %pe\\n\",\n\t\t\t\tERR_PTR(brightness));\n\t}\n\tmutex_unlock(&bd->ops_lock);\n\tbacklight_generate_event(bd, reason);\n}\nEXPORT_SYMBOL(backlight_force_update);\n\n \nstruct backlight_device *backlight_device_register(const char *name,\n\tstruct device *parent, void *devdata, const struct backlight_ops *ops,\n\tconst struct backlight_properties *props)\n{\n\tstruct backlight_device *new_bd;\n\tint rc;\n\n\tpr_debug(\"backlight_device_register: name=%s\\n\", name);\n\n\tnew_bd = kzalloc(sizeof(struct backlight_device), GFP_KERNEL);\n\tif (!new_bd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&new_bd->update_lock);\n\tmutex_init(&new_bd->ops_lock);\n\n\tnew_bd->dev.class = backlight_class;\n\tnew_bd->dev.parent = parent;\n\tnew_bd->dev.release = bl_device_release;\n\tdev_set_name(&new_bd->dev, \"%s\", name);\n\tdev_set_drvdata(&new_bd->dev, devdata);\n\n\t \n\tif (props) {\n\t\tmemcpy(&new_bd->props, props,\n\t\t       sizeof(struct backlight_properties));\n\t\tif (props->type <= 0 || props->type >= BACKLIGHT_TYPE_MAX) {\n\t\t\tWARN(1, \"%s: invalid backlight type\", name);\n\t\t\tnew_bd->props.type = BACKLIGHT_RAW;\n\t\t}\n\t} else {\n\t\tnew_bd->props.type = BACKLIGHT_RAW;\n\t}\n\n\trc = device_register(&new_bd->dev);\n\tif (rc) {\n\t\tput_device(&new_bd->dev);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\trc = backlight_register_fb(new_bd);\n\tif (rc) {\n\t\tdevice_unregister(&new_bd->dev);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\tnew_bd->ops = ops;\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n\tmutex_lock(&pmac_backlight_mutex);\n\tif (!pmac_backlight)\n\t\tpmac_backlight = new_bd;\n\tmutex_unlock(&pmac_backlight_mutex);\n#endif\n\n\tmutex_lock(&backlight_dev_list_mutex);\n\tlist_add(&new_bd->entry, &backlight_dev_list);\n\tmutex_unlock(&backlight_dev_list_mutex);\n\n\tblocking_notifier_call_chain(&backlight_notifier,\n\t\t\t\t     BACKLIGHT_REGISTERED, new_bd);\n\n\treturn new_bd;\n}\nEXPORT_SYMBOL(backlight_device_register);\n\n \nstruct backlight_device *backlight_device_get_by_type(enum backlight_type type)\n{\n\tbool found = false;\n\tstruct backlight_device *bd;\n\n\tmutex_lock(&backlight_dev_list_mutex);\n\tlist_for_each_entry(bd, &backlight_dev_list, entry) {\n\t\tif (bd->props.type == type) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&backlight_dev_list_mutex);\n\n\treturn found ? bd : NULL;\n}\nEXPORT_SYMBOL(backlight_device_get_by_type);\n\n \nstruct backlight_device *backlight_device_get_by_name(const char *name)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device_by_name(backlight_class, name);\n\n\treturn dev ? to_backlight_device(dev) : NULL;\n}\nEXPORT_SYMBOL(backlight_device_get_by_name);\n\n \nvoid backlight_device_unregister(struct backlight_device *bd)\n{\n\tif (!bd)\n\t\treturn;\n\n\tmutex_lock(&backlight_dev_list_mutex);\n\tlist_del(&bd->entry);\n\tmutex_unlock(&backlight_dev_list_mutex);\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n\tmutex_lock(&pmac_backlight_mutex);\n\tif (pmac_backlight == bd)\n\t\tpmac_backlight = NULL;\n\tmutex_unlock(&pmac_backlight_mutex);\n#endif\n\n\tblocking_notifier_call_chain(&backlight_notifier,\n\t\t\t\t     BACKLIGHT_UNREGISTERED, bd);\n\n\tmutex_lock(&bd->ops_lock);\n\tbd->ops = NULL;\n\tmutex_unlock(&bd->ops_lock);\n\n\tbacklight_unregister_fb(bd);\n\tdevice_unregister(&bd->dev);\n}\nEXPORT_SYMBOL(backlight_device_unregister);\n\nstatic void devm_backlight_device_release(struct device *dev, void *res)\n{\n\tstruct backlight_device *backlight = *(struct backlight_device **)res;\n\n\tbacklight_device_unregister(backlight);\n}\n\nstatic int devm_backlight_device_match(struct device *dev, void *res,\n\t\t\t\t\tvoid *data)\n{\n\tstruct backlight_device **r = res;\n\n\treturn *r == data;\n}\n\n \nint backlight_register_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&backlight_notifier, nb);\n}\nEXPORT_SYMBOL(backlight_register_notifier);\n\n \nint backlight_unregister_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&backlight_notifier, nb);\n}\nEXPORT_SYMBOL(backlight_unregister_notifier);\n\n \nstruct backlight_device *devm_backlight_device_register(struct device *dev,\n\tconst char *name, struct device *parent, void *devdata,\n\tconst struct backlight_ops *ops,\n\tconst struct backlight_properties *props)\n{\n\tstruct backlight_device **ptr, *backlight;\n\n\tptr = devres_alloc(devm_backlight_device_release, sizeof(*ptr),\n\t\t\tGFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbacklight = backlight_device_register(name, parent, devdata, ops,\n\t\t\t\t\t\tprops);\n\tif (!IS_ERR(backlight)) {\n\t\t*ptr = backlight;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn backlight;\n}\nEXPORT_SYMBOL(devm_backlight_device_register);\n\n \nvoid devm_backlight_device_unregister(struct device *dev,\n\t\t\t\tstruct backlight_device *bd)\n{\n\tint rc;\n\n\trc = devres_release(dev, devm_backlight_device_release,\n\t\t\t\tdevm_backlight_device_match, bd);\n\tWARN_ON(rc);\n}\nEXPORT_SYMBOL(devm_backlight_device_unregister);\n\n#ifdef CONFIG_OF\nstatic int of_parent_match(struct device *dev, const void *data)\n{\n\treturn dev->parent && dev->parent->of_node == data;\n}\n\n \nstruct backlight_device *of_find_backlight_by_node(struct device_node *node)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device(backlight_class, NULL, node, of_parent_match);\n\n\treturn dev ? to_backlight_device(dev) : NULL;\n}\nEXPORT_SYMBOL(of_find_backlight_by_node);\n#endif\n\nstatic struct backlight_device *of_find_backlight(struct device *dev)\n{\n\tstruct backlight_device *bd = NULL;\n\tstruct device_node *np;\n\n\tif (!dev)\n\t\treturn NULL;\n\n\tif (IS_ENABLED(CONFIG_OF) && dev->of_node) {\n\t\tnp = of_parse_phandle(dev->of_node, \"backlight\", 0);\n\t\tif (np) {\n\t\t\tbd = of_find_backlight_by_node(np);\n\t\t\tof_node_put(np);\n\t\t\tif (!bd)\n\t\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t\t}\n\t}\n\n\treturn bd;\n}\n\nstatic void devm_backlight_release(void *data)\n{\n\tstruct backlight_device *bd = data;\n\n\tput_device(&bd->dev);\n}\n\n \nstruct backlight_device *devm_of_find_backlight(struct device *dev)\n{\n\tstruct backlight_device *bd;\n\tint ret;\n\n\tbd = of_find_backlight(dev);\n\tif (IS_ERR_OR_NULL(bd))\n\t\treturn bd;\n\tret = devm_add_action_or_reset(dev, devm_backlight_release, bd);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn bd;\n}\nEXPORT_SYMBOL(devm_of_find_backlight);\n\nstatic void __exit backlight_class_exit(void)\n{\n\tclass_destroy(backlight_class);\n}\n\nstatic int __init backlight_class_init(void)\n{\n\tbacklight_class = class_create(\"backlight\");\n\tif (IS_ERR(backlight_class)) {\n\t\tpr_warn(\"Unable to create backlight class; errno = %ld\\n\",\n\t\t\tPTR_ERR(backlight_class));\n\t\treturn PTR_ERR(backlight_class);\n\t}\n\n\tbacklight_class->dev_groups = bl_device_groups;\n\tbacklight_class->pm = &backlight_class_dev_pm_ops;\n\tINIT_LIST_HEAD(&backlight_dev_list);\n\tmutex_init(&backlight_dev_list_mutex);\n\tBLOCKING_INIT_NOTIFIER_HEAD(&backlight_notifier);\n\n\treturn 0;\n}\n\n \npostcore_initcall(backlight_class_init);\nmodule_exit(backlight_class_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jamey Hicks <jamey.hicks@hp.com>, Andrew Zabolotny <zap@homelink.ru>\");\nMODULE_DESCRIPTION(\"Backlight Lowlevel Control Abstraction\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}