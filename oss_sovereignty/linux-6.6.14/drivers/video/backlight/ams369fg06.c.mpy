{
  "module_name": "ams369fg06.c",
  "hash_id": "bf23cd149829c64dc7bd06f2159ace9cadf74873d5cf90f97708a67aa23aac29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/ams369fg06.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/lcd.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/wait.h>\n\n#define SLEEPMSEC\t\t0x1000\n#define ENDDEF\t\t\t0x2000\n#define\tDEFMASK\t\t\t0xFF00\n#define COMMAND_ONLY\t\t0xFE\n#define DATA_ONLY\t\t0xFF\n\n#define MAX_GAMMA_LEVEL\t\t5\n#define GAMMA_TABLE_COUNT\t21\n\n#define MIN_BRIGHTNESS\t\t0\n#define MAX_BRIGHTNESS\t\t255\n#define DEFAULT_BRIGHTNESS\t150\n\nstruct ams369fg06 {\n\tstruct device\t\t\t*dev;\n\tstruct spi_device\t\t*spi;\n\tunsigned int\t\t\tpower;\n\tstruct lcd_device\t\t*ld;\n\tstruct backlight_device\t\t*bd;\n\tstruct lcd_platform_data\t*lcd_pd;\n};\n\nstatic const unsigned short seq_display_on[] = {\n\t0x14, 0x03,\n\tENDDEF, 0x0000\n};\n\nstatic const unsigned short seq_display_off[] = {\n\t0x14, 0x00,\n\tENDDEF, 0x0000\n};\n\nstatic const unsigned short seq_stand_by_on[] = {\n\t0x1D, 0xA1,\n\tSLEEPMSEC, 200,\n\tENDDEF, 0x0000\n};\n\nstatic const unsigned short seq_stand_by_off[] = {\n\t0x1D, 0xA0,\n\tSLEEPMSEC, 250,\n\tENDDEF, 0x0000\n};\n\nstatic const unsigned short seq_setting[] = {\n\t0x31, 0x08,\n\t0x32, 0x14,\n\t0x30, 0x02,\n\t0x27, 0x01,\n\t0x12, 0x08,\n\t0x13, 0x08,\n\t0x15, 0x00,\n\t0x16, 0x00,\n\n\t0xef, 0xd0,\n\tDATA_ONLY, 0xe8,\n\n\t0x39, 0x44,\n\t0x40, 0x00,\n\t0x41, 0x3f,\n\t0x42, 0x2a,\n\t0x43, 0x27,\n\t0x44, 0x27,\n\t0x45, 0x1f,\n\t0x46, 0x44,\n\t0x50, 0x00,\n\t0x51, 0x00,\n\t0x52, 0x17,\n\t0x53, 0x24,\n\t0x54, 0x26,\n\t0x55, 0x1f,\n\t0x56, 0x43,\n\t0x60, 0x00,\n\t0x61, 0x3f,\n\t0x62, 0x2a,\n\t0x63, 0x25,\n\t0x64, 0x24,\n\t0x65, 0x1b,\n\t0x66, 0x5c,\n\n\t0x17, 0x22,\n\t0x18, 0x33,\n\t0x19, 0x03,\n\t0x1a, 0x01,\n\t0x22, 0xa4,\n\t0x23, 0x00,\n\t0x26, 0xa0,\n\n\t0x1d, 0xa0,\n\tSLEEPMSEC, 300,\n\n\t0x14, 0x03,\n\n\tENDDEF, 0x0000\n};\n\n \nstatic const unsigned int ams369fg06_22_250[] = {\n\t0x00, 0x3f, 0x2a, 0x27, 0x27, 0x1f, 0x44,\n\t0x00, 0x00, 0x17, 0x24, 0x26, 0x1f, 0x43,\n\t0x00, 0x3f, 0x2a, 0x25, 0x24, 0x1b, 0x5c,\n};\n\nstatic const unsigned int ams369fg06_22_200[] = {\n\t0x00, 0x3f, 0x28, 0x29, 0x27, 0x21, 0x3e,\n\t0x00, 0x00, 0x10, 0x25, 0x27, 0x20, 0x3d,\n\t0x00, 0x3f, 0x28, 0x27, 0x25, 0x1d, 0x53,\n};\n\nstatic const unsigned int ams369fg06_22_150[] = {\n\t0x00, 0x3f, 0x2d, 0x29, 0x28, 0x23, 0x37,\n\t0x00, 0x00, 0x0b, 0x25, 0x28, 0x22, 0x36,\n\t0x00, 0x3f, 0x2b, 0x28, 0x26, 0x1f, 0x4a,\n};\n\nstatic const unsigned int ams369fg06_22_100[] = {\n\t0x00, 0x3f, 0x30, 0x2a, 0x2b, 0x24, 0x2f,\n\t0x00, 0x00, 0x00, 0x25, 0x29, 0x24, 0x2e,\n\t0x00, 0x3f, 0x2f, 0x29, 0x29, 0x21, 0x3f,\n};\n\nstatic const unsigned int ams369fg06_22_50[] = {\n\t0x00, 0x3f, 0x3c, 0x2c, 0x2d, 0x27, 0x24,\n\t0x00, 0x00, 0x00, 0x22, 0x2a, 0x27, 0x23,\n\t0x00, 0x3f, 0x3b, 0x2c, 0x2b, 0x24, 0x31,\n};\n\nstruct ams369fg06_gamma {\n\tunsigned int *gamma_22_table[MAX_GAMMA_LEVEL];\n};\n\nstatic struct ams369fg06_gamma gamma_table = {\n\t.gamma_22_table[0] = (unsigned int *)&ams369fg06_22_50,\n\t.gamma_22_table[1] = (unsigned int *)&ams369fg06_22_100,\n\t.gamma_22_table[2] = (unsigned int *)&ams369fg06_22_150,\n\t.gamma_22_table[3] = (unsigned int *)&ams369fg06_22_200,\n\t.gamma_22_table[4] = (unsigned int *)&ams369fg06_22_250,\n};\n\nstatic int ams369fg06_spi_write_byte(struct ams369fg06 *lcd, int addr, int data)\n{\n\tu16 buf[1];\n\tstruct spi_message msg;\n\n\tstruct spi_transfer xfer = {\n\t\t.len\t\t= 2,\n\t\t.tx_buf\t\t= buf,\n\t};\n\n\tbuf[0] = (addr << 8) | data;\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer, &msg);\n\n\treturn spi_sync(lcd->spi, &msg);\n}\n\nstatic int ams369fg06_spi_write(struct ams369fg06 *lcd, unsigned char address,\n\tunsigned char command)\n{\n\tint ret = 0;\n\n\tif (address != DATA_ONLY)\n\t\tret = ams369fg06_spi_write_byte(lcd, 0x70, address);\n\tif (command != COMMAND_ONLY)\n\t\tret = ams369fg06_spi_write_byte(lcd, 0x72, command);\n\n\treturn ret;\n}\n\nstatic int ams369fg06_panel_send_sequence(struct ams369fg06 *lcd,\n\tconst unsigned short *wbuf)\n{\n\tint ret = 0, i = 0;\n\n\twhile ((wbuf[i] & DEFMASK) != ENDDEF) {\n\t\tif ((wbuf[i] & DEFMASK) != SLEEPMSEC) {\n\t\t\tret = ams369fg06_spi_write(lcd, wbuf[i], wbuf[i+1]);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmsleep(wbuf[i+1]);\n\t\t}\n\t\ti += 2;\n\t}\n\n\treturn ret;\n}\n\nstatic int _ams369fg06_gamma_ctl(struct ams369fg06 *lcd,\n\tconst unsigned int *gamma)\n{\n\tunsigned int i = 0;\n\tint ret = 0;\n\n\tfor (i = 0 ; i < GAMMA_TABLE_COUNT / 3; i++) {\n\t\tret = ams369fg06_spi_write(lcd, 0x40 + i, gamma[i]);\n\t\tret = ams369fg06_spi_write(lcd, 0x50 + i, gamma[i+7*1]);\n\t\tret = ams369fg06_spi_write(lcd, 0x60 + i, gamma[i+7*2]);\n\t\tif (ret) {\n\t\t\tdev_err(lcd->dev, \"failed to set gamma table.\\n\");\n\t\t\tgoto gamma_err;\n\t\t}\n\t}\n\ngamma_err:\n\treturn ret;\n}\n\nstatic int ams369fg06_gamma_ctl(struct ams369fg06 *lcd, int brightness)\n{\n\tint ret = 0;\n\tint gamma = 0;\n\n\tif ((brightness >= 0) && (brightness <= 50))\n\t\tgamma = 0;\n\telse if ((brightness > 50) && (brightness <= 100))\n\t\tgamma = 1;\n\telse if ((brightness > 100) && (brightness <= 150))\n\t\tgamma = 2;\n\telse if ((brightness > 150) && (brightness <= 200))\n\t\tgamma = 3;\n\telse if ((brightness > 200) && (brightness <= 255))\n\t\tgamma = 4;\n\n\tret = _ams369fg06_gamma_ctl(lcd, gamma_table.gamma_22_table[gamma]);\n\n\treturn ret;\n}\n\nstatic int ams369fg06_ldi_init(struct ams369fg06 *lcd)\n{\n\tint ret, i;\n\tstatic const unsigned short *init_seq[] = {\n\t\tseq_setting,\n\t\tseq_stand_by_off,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(init_seq); i++) {\n\t\tret = ams369fg06_panel_send_sequence(lcd, init_seq[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int ams369fg06_ldi_enable(struct ams369fg06 *lcd)\n{\n\tint ret, i;\n\tstatic const unsigned short *init_seq[] = {\n\t\tseq_stand_by_off,\n\t\tseq_display_on,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(init_seq); i++) {\n\t\tret = ams369fg06_panel_send_sequence(lcd, init_seq[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int ams369fg06_ldi_disable(struct ams369fg06 *lcd)\n{\n\tint ret, i;\n\n\tstatic const unsigned short *init_seq[] = {\n\t\tseq_display_off,\n\t\tseq_stand_by_on,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(init_seq); i++) {\n\t\tret = ams369fg06_panel_send_sequence(lcd, init_seq[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int ams369fg06_power_is_on(int power)\n{\n\treturn power <= FB_BLANK_NORMAL;\n}\n\nstatic int ams369fg06_power_on(struct ams369fg06 *lcd)\n{\n\tint ret = 0;\n\tstruct lcd_platform_data *pd;\n\tstruct backlight_device *bd;\n\n\tpd = lcd->lcd_pd;\n\tbd = lcd->bd;\n\n\tif (pd->power_on) {\n\t\tpd->power_on(lcd->ld, 1);\n\t\tmsleep(pd->power_on_delay);\n\t}\n\n\tif (!pd->reset) {\n\t\tdev_err(lcd->dev, \"reset is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpd->reset(lcd->ld);\n\tmsleep(pd->reset_delay);\n\n\tret = ams369fg06_ldi_init(lcd);\n\tif (ret) {\n\t\tdev_err(lcd->dev, \"failed to initialize ldi.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ams369fg06_ldi_enable(lcd);\n\tif (ret) {\n\t\tdev_err(lcd->dev, \"failed to enable ldi.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ams369fg06_gamma_ctl(lcd, bd->props.brightness);\n\tif (ret) {\n\t\tdev_err(lcd->dev, \"lcd gamma setting failed.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ams369fg06_power_off(struct ams369fg06 *lcd)\n{\n\tint ret;\n\tstruct lcd_platform_data *pd;\n\n\tpd = lcd->lcd_pd;\n\n\tret = ams369fg06_ldi_disable(lcd);\n\tif (ret) {\n\t\tdev_err(lcd->dev, \"lcd setting failed.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmsleep(pd->power_off_delay);\n\n\tif (pd->power_on)\n\t\tpd->power_on(lcd->ld, 0);\n\n\treturn 0;\n}\n\nstatic int ams369fg06_power(struct ams369fg06 *lcd, int power)\n{\n\tint ret = 0;\n\n\tif (ams369fg06_power_is_on(power) &&\n\t\t!ams369fg06_power_is_on(lcd->power))\n\t\tret = ams369fg06_power_on(lcd);\n\telse if (!ams369fg06_power_is_on(power) &&\n\t\tams369fg06_power_is_on(lcd->power))\n\t\tret = ams369fg06_power_off(lcd);\n\n\tif (!ret)\n\t\tlcd->power = power;\n\n\treturn ret;\n}\n\nstatic int ams369fg06_get_power(struct lcd_device *ld)\n{\n\tstruct ams369fg06 *lcd = lcd_get_data(ld);\n\n\treturn lcd->power;\n}\n\nstatic int ams369fg06_set_power(struct lcd_device *ld, int power)\n{\n\tstruct ams369fg06 *lcd = lcd_get_data(ld);\n\n\tif (power != FB_BLANK_UNBLANK && power != FB_BLANK_POWERDOWN &&\n\t\tpower != FB_BLANK_NORMAL) {\n\t\tdev_err(lcd->dev, \"power value should be 0, 1 or 4.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ams369fg06_power(lcd, power);\n}\n\nstatic int ams369fg06_set_brightness(struct backlight_device *bd)\n{\n\tint ret = 0;\n\tint brightness = bd->props.brightness;\n\tstruct ams369fg06 *lcd = bl_get_data(bd);\n\n\tif (brightness < MIN_BRIGHTNESS ||\n\t\tbrightness > bd->props.max_brightness) {\n\t\tdev_err(&bd->dev, \"lcd brightness should be %d to %d.\\n\",\n\t\t\tMIN_BRIGHTNESS, MAX_BRIGHTNESS);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ams369fg06_gamma_ctl(lcd, bd->props.brightness);\n\tif (ret) {\n\t\tdev_err(&bd->dev, \"lcd brightness setting failed.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic struct lcd_ops ams369fg06_lcd_ops = {\n\t.get_power = ams369fg06_get_power,\n\t.set_power = ams369fg06_set_power,\n};\n\nstatic const struct backlight_ops ams369fg06_backlight_ops = {\n\t.update_status = ams369fg06_set_brightness,\n};\n\nstatic int ams369fg06_probe(struct spi_device *spi)\n{\n\tint ret = 0;\n\tstruct ams369fg06 *lcd = NULL;\n\tstruct lcd_device *ld = NULL;\n\tstruct backlight_device *bd = NULL;\n\tstruct backlight_properties props;\n\n\tlcd = devm_kzalloc(&spi->dev, sizeof(struct ams369fg06), GFP_KERNEL);\n\tif (!lcd)\n\t\treturn -ENOMEM;\n\n\t \n\tspi->bits_per_word = 16;\n\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"spi setup failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tlcd->spi = spi;\n\tlcd->dev = &spi->dev;\n\n\tlcd->lcd_pd = dev_get_platdata(&spi->dev);\n\tif (!lcd->lcd_pd) {\n\t\tdev_err(&spi->dev, \"platform data is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tld = devm_lcd_device_register(&spi->dev, \"ams369fg06\", &spi->dev, lcd,\n\t\t\t\t\t&ams369fg06_lcd_ops);\n\tif (IS_ERR(ld))\n\t\treturn PTR_ERR(ld);\n\n\tlcd->ld = ld;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = MAX_BRIGHTNESS;\n\n\tbd = devm_backlight_device_register(&spi->dev, \"ams369fg06-bl\",\n\t\t\t\t\t&spi->dev, lcd,\n\t\t\t\t\t&ams369fg06_backlight_ops, &props);\n\tif (IS_ERR(bd))\n\t\treturn PTR_ERR(bd);\n\n\tbd->props.brightness = DEFAULT_BRIGHTNESS;\n\tlcd->bd = bd;\n\n\tif (!lcd->lcd_pd->lcd_enabled) {\n\t\t \n\t\tlcd->power = FB_BLANK_POWERDOWN;\n\n\t\tams369fg06_power(lcd, FB_BLANK_UNBLANK);\n\t} else {\n\t\tlcd->power = FB_BLANK_UNBLANK;\n\t}\n\n\tspi_set_drvdata(spi, lcd);\n\n\tdev_info(&spi->dev, \"ams369fg06 panel driver has been probed.\\n\");\n\n\treturn 0;\n}\n\nstatic void ams369fg06_remove(struct spi_device *spi)\n{\n\tstruct ams369fg06 *lcd = spi_get_drvdata(spi);\n\n\tams369fg06_power(lcd, FB_BLANK_POWERDOWN);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ams369fg06_suspend(struct device *dev)\n{\n\tstruct ams369fg06 *lcd = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"lcd->power = %d\\n\", lcd->power);\n\n\t \n\treturn ams369fg06_power(lcd, FB_BLANK_POWERDOWN);\n}\n\nstatic int ams369fg06_resume(struct device *dev)\n{\n\tstruct ams369fg06 *lcd = dev_get_drvdata(dev);\n\n\tlcd->power = FB_BLANK_POWERDOWN;\n\n\treturn ams369fg06_power(lcd, FB_BLANK_UNBLANK);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(ams369fg06_pm_ops, ams369fg06_suspend,\n\t\t\tams369fg06_resume);\n\nstatic void ams369fg06_shutdown(struct spi_device *spi)\n{\n\tstruct ams369fg06 *lcd = spi_get_drvdata(spi);\n\n\tams369fg06_power(lcd, FB_BLANK_POWERDOWN);\n}\n\nstatic struct spi_driver ams369fg06_driver = {\n\t.driver = {\n\t\t.name\t= \"ams369fg06\",\n\t\t.pm\t= &ams369fg06_pm_ops,\n\t},\n\t.probe\t\t= ams369fg06_probe,\n\t.remove\t\t= ams369fg06_remove,\n\t.shutdown\t= ams369fg06_shutdown,\n};\n\nmodule_spi_driver(ams369fg06_driver);\n\nMODULE_AUTHOR(\"Jingoo Han <jg1.han@samsung.com>\");\nMODULE_DESCRIPTION(\"ams369fg06 LCD Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}