{
  "module_name": "aat2870_bl.c",
  "hash_id": "3287f5d9859d873342fe29ced3796d879e7a1e57de7253c2297e1b6699ab3a76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/aat2870_bl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/backlight.h>\n#include <linux/mfd/aat2870.h>\n\nstruct aat2870_bl_driver_data {\n\tstruct platform_device *pdev;\n\tstruct backlight_device *bd;\n\n\tint channels;\n\tint max_current;\n\tint brightness;  \n};\n\nstatic inline int aat2870_brightness(struct aat2870_bl_driver_data *aat2870_bl,\n\t\t\t\t     int brightness)\n{\n\tstruct backlight_device *bd = aat2870_bl->bd;\n\tint val;\n\n\tval = brightness * (aat2870_bl->max_current - 1);\n\tval /= bd->props.max_brightness;\n\n\treturn val;\n}\n\nstatic inline int aat2870_bl_enable(struct aat2870_bl_driver_data *aat2870_bl)\n{\n\tstruct aat2870_data *aat2870\n\t\t\t= dev_get_drvdata(aat2870_bl->pdev->dev.parent);\n\n\treturn aat2870->write(aat2870, AAT2870_BL_CH_EN,\n\t\t\t      (u8)aat2870_bl->channels);\n}\n\nstatic inline int aat2870_bl_disable(struct aat2870_bl_driver_data *aat2870_bl)\n{\n\tstruct aat2870_data *aat2870\n\t\t\t= dev_get_drvdata(aat2870_bl->pdev->dev.parent);\n\n\treturn aat2870->write(aat2870, AAT2870_BL_CH_EN, 0x0);\n}\n\nstatic int aat2870_bl_update_status(struct backlight_device *bd)\n{\n\tstruct aat2870_bl_driver_data *aat2870_bl = bl_get_data(bd);\n\tstruct aat2870_data *aat2870 =\n\t\t\tdev_get_drvdata(aat2870_bl->pdev->dev.parent);\n\tint brightness = backlight_get_brightness(bd);\n\tint ret;\n\n\tif ((brightness < 0) || (bd->props.max_brightness < brightness)) {\n\t\tdev_err(&bd->dev, \"invalid brightness, %d\\n\", brightness);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&bd->dev, \"brightness=%d, power=%d, state=%d\\n\",\n\t\t bd->props.brightness, bd->props.power, bd->props.state);\n\n\tret = aat2870->write(aat2870, AAT2870_BLM,\n\t\t\t     (u8)aat2870_brightness(aat2870_bl, brightness));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (brightness == 0) {\n\t\tret = aat2870_bl_disable(aat2870_bl);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (aat2870_bl->brightness == 0) {\n\t\tret = aat2870_bl_enable(aat2870_bl);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\taat2870_bl->brightness = brightness;\n\n\treturn 0;\n}\n\nstatic int aat2870_bl_check_fb(struct backlight_device *bd, struct fb_info *fi)\n{\n\treturn 1;\n}\n\nstatic const struct backlight_ops aat2870_bl_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.update_status = aat2870_bl_update_status,\n\t.check_fb = aat2870_bl_check_fb,\n};\n\nstatic int aat2870_bl_probe(struct platform_device *pdev)\n{\n\tstruct aat2870_bl_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct aat2870_bl_driver_data *aat2870_bl;\n\tstruct backlight_device *bd;\n\tstruct backlight_properties props;\n\tint ret = 0;\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"No platform data\\n\");\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tif (pdev->id != AAT2870_ID_BL) {\n\t\tdev_err(&pdev->dev, \"Invalid device ID, %d\\n\", pdev->id);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\taat2870_bl = devm_kzalloc(&pdev->dev,\n\t\t\t\t  sizeof(struct aat2870_bl_driver_data),\n\t\t\t\t  GFP_KERNEL);\n\tif (!aat2870_bl) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\n\tprops.type = BACKLIGHT_RAW;\n\tbd = devm_backlight_device_register(&pdev->dev, \"aat2870-backlight\",\n\t\t\t\t\t&pdev->dev, aat2870_bl, &aat2870_bl_ops,\n\t\t\t\t\t&props);\n\tif (IS_ERR(bd)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed allocate memory for backlight device\\n\");\n\t\tret = PTR_ERR(bd);\n\t\tgoto out;\n\t}\n\n\taat2870_bl->pdev = pdev;\n\tplatform_set_drvdata(pdev, aat2870_bl);\n\n\taat2870_bl->bd = bd;\n\n\tif (pdata->channels > 0)\n\t\taat2870_bl->channels = pdata->channels;\n\telse\n\t\taat2870_bl->channels = AAT2870_BL_CH_ALL;\n\n\tif (pdata->max_current > 0)\n\t\taat2870_bl->max_current = pdata->max_current;\n\telse\n\t\taat2870_bl->max_current = AAT2870_CURRENT_27_9;\n\n\tif (pdata->max_brightness > 0)\n\t\tbd->props.max_brightness = pdata->max_brightness;\n\telse\n\t\tbd->props.max_brightness = 255;\n\n\taat2870_bl->brightness = 0;\n\tbd->props.power = FB_BLANK_UNBLANK;\n\tbd->props.brightness = bd->props.max_brightness;\n\n\tret = aat2870_bl_update_status(bd);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic void aat2870_bl_remove(struct platform_device *pdev)\n{\n\tstruct aat2870_bl_driver_data *aat2870_bl = platform_get_drvdata(pdev);\n\tstruct backlight_device *bd = aat2870_bl->bd;\n\n\tbd->props.power = FB_BLANK_POWERDOWN;\n\tbd->props.brightness = 0;\n\tbacklight_update_status(bd);\n}\n\nstatic struct platform_driver aat2870_bl_driver = {\n\t.driver = {\n\t\t.name\t= \"aat2870-backlight\",\n\t},\n\t.probe\t\t= aat2870_bl_probe,\n\t.remove_new\t= aat2870_bl_remove,\n};\n\nstatic int __init aat2870_bl_init(void)\n{\n\treturn platform_driver_register(&aat2870_bl_driver);\n}\nsubsys_initcall(aat2870_bl_init);\n\nstatic void __exit aat2870_bl_exit(void)\n{\n\tplatform_driver_unregister(&aat2870_bl_driver);\n}\nmodule_exit(aat2870_bl_exit);\n\nMODULE_DESCRIPTION(\"AnalogicTech AAT2870 Backlight\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jin Park <jinyoungp@nvidia.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}