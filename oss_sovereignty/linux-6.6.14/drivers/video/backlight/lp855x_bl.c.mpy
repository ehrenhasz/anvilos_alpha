{
  "module_name": "lp855x_bl.c",
  "hash_id": "4fe9c478602614c9920f02c9330d4c3caa3c809ff560b78f0f1d5ade5a75bc51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/lp855x_bl.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/platform_data/lp855x.h>\n#include <linux/pwm.h>\n#include <linux/regulator/consumer.h>\n\n \n#define LP855X_BRIGHTNESS_CTRL\t\t0x00\n#define LP855X_DEVICE_CTRL\t\t0x01\n#define LP855X_EEPROM_START\t\t0xA0\n#define LP855X_EEPROM_END\t\t0xA7\n#define LP8556_EPROM_START\t\t0xA0\n#define LP8556_EPROM_END\t\t0xAF\n\n \n#define LP8557_BL_CMD\t\t\t0x00\n#define LP8557_BL_MASK\t\t\t0x01\n#define LP8557_BL_ON\t\t\t0x01\n#define LP8557_BL_OFF\t\t\t0x00\n#define LP8557_BRIGHTNESS_CTRL\t\t0x04\n#define LP8557_CONFIG\t\t\t0x10\n#define LP8555_EPROM_START\t\t0x10\n#define LP8555_EPROM_END\t\t0x7A\n#define LP8557_EPROM_START\t\t0x10\n#define LP8557_EPROM_END\t\t0x1E\n\n#define DEFAULT_BL_NAME\t\t\"lcd-backlight\"\n#define MAX_BRIGHTNESS\t\t255\n\nenum lp855x_brightness_ctrl_mode {\n\tPWM_BASED = 1,\n\tREGISTER_BASED,\n};\n\nstruct lp855x;\n\n \nstruct lp855x_device_config {\n\tint (*pre_init_device)(struct lp855x *);\n\tu8 reg_brightness;\n\tu8 reg_devicectrl;\n\tint (*post_init_device)(struct lp855x *);\n};\n\nstruct lp855x {\n\tconst char *chipname;\n\tenum lp855x_chip_id chip_id;\n\tenum lp855x_brightness_ctrl_mode mode;\n\tstruct lp855x_device_config *cfg;\n\tstruct i2c_client *client;\n\tstruct backlight_device *bl;\n\tstruct device *dev;\n\tstruct lp855x_platform_data *pdata;\n\tstruct pwm_device *pwm;\n\tbool needs_pwm_init;\n\tstruct regulator *supply;\t \n\tstruct regulator *enable;\t \n};\n\nstatic int lp855x_write_byte(struct lp855x *lp, u8 reg, u8 data)\n{\n\treturn i2c_smbus_write_byte_data(lp->client, reg, data);\n}\n\nstatic int lp855x_update_bit(struct lp855x *lp, u8 reg, u8 mask, u8 data)\n{\n\tint ret;\n\tu8 tmp;\n\n\tret = i2c_smbus_read_byte_data(lp->client, reg);\n\tif (ret < 0) {\n\t\tdev_err(lp->dev, \"failed to read 0x%.2x\\n\", reg);\n\t\treturn ret;\n\t}\n\n\ttmp = (u8)ret;\n\ttmp &= ~mask;\n\ttmp |= data & mask;\n\n\treturn lp855x_write_byte(lp, reg, tmp);\n}\n\nstatic bool lp855x_is_valid_rom_area(struct lp855x *lp, u8 addr)\n{\n\tu8 start, end;\n\n\tswitch (lp->chip_id) {\n\tcase LP8550:\n\tcase LP8551:\n\tcase LP8552:\n\tcase LP8553:\n\t\tstart = LP855X_EEPROM_START;\n\t\tend = LP855X_EEPROM_END;\n\t\tbreak;\n\tcase LP8556:\n\t\tstart = LP8556_EPROM_START;\n\t\tend = LP8556_EPROM_END;\n\t\tbreak;\n\tcase LP8555:\n\t\tstart = LP8555_EPROM_START;\n\t\tend = LP8555_EPROM_END;\n\t\tbreak;\n\tcase LP8557:\n\t\tstart = LP8557_EPROM_START;\n\t\tend = LP8557_EPROM_END;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn addr >= start && addr <= end;\n}\n\nstatic int lp8557_bl_off(struct lp855x *lp)\n{\n\t \n\treturn lp855x_update_bit(lp, LP8557_BL_CMD, LP8557_BL_MASK,\n\t\t\t\tLP8557_BL_OFF);\n}\n\nstatic int lp8557_bl_on(struct lp855x *lp)\n{\n\t \n\treturn lp855x_update_bit(lp, LP8557_BL_CMD, LP8557_BL_MASK,\n\t\t\t\tLP8557_BL_ON);\n}\n\nstatic struct lp855x_device_config lp855x_dev_cfg = {\n\t.reg_brightness = LP855X_BRIGHTNESS_CTRL,\n\t.reg_devicectrl = LP855X_DEVICE_CTRL,\n};\n\nstatic struct lp855x_device_config lp8557_dev_cfg = {\n\t.reg_brightness = LP8557_BRIGHTNESS_CTRL,\n\t.reg_devicectrl = LP8557_CONFIG,\n\t.pre_init_device = lp8557_bl_off,\n\t.post_init_device = lp8557_bl_on,\n};\n\n \nstatic int lp855x_configure(struct lp855x *lp)\n{\n\tu8 val, addr;\n\tint i, ret;\n\tstruct lp855x_platform_data *pd = lp->pdata;\n\n\tif (lp->cfg->pre_init_device) {\n\t\tret = lp->cfg->pre_init_device(lp);\n\t\tif (ret) {\n\t\t\tdev_err(lp->dev, \"pre init device err: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tval = pd->initial_brightness;\n\tret = lp855x_write_byte(lp, lp->cfg->reg_brightness, val);\n\tif (ret)\n\t\tgoto err;\n\n\tval = pd->device_control;\n\tret = lp855x_write_byte(lp, lp->cfg->reg_devicectrl, val);\n\tif (ret)\n\t\tgoto err;\n\n\tif (pd->size_program > 0) {\n\t\tfor (i = 0; i < pd->size_program; i++) {\n\t\t\taddr = pd->rom_data[i].addr;\n\t\t\tval = pd->rom_data[i].val;\n\t\t\tif (!lp855x_is_valid_rom_area(lp, addr))\n\t\t\t\tcontinue;\n\n\t\t\tret = lp855x_write_byte(lp, addr, val);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (lp->cfg->post_init_device) {\n\t\tret = lp->cfg->post_init_device(lp);\n\t\tif (ret) {\n\t\t\tdev_err(lp->dev, \"post init device err: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic int lp855x_pwm_ctrl(struct lp855x *lp, int br, int max_br)\n{\n\tstruct pwm_state state;\n\n\tif (lp->needs_pwm_init) {\n\t\tpwm_init_state(lp->pwm, &state);\n\t\t \n\t\tif (lp->pdata->period_ns > 0)\n\t\t\tstate.period = lp->pdata->period_ns;\n\t\tlp->needs_pwm_init = false;\n\t} else {\n\t\tpwm_get_state(lp->pwm, &state);\n\t}\n\n\tstate.duty_cycle = div_u64(br * state.period, max_br);\n\tstate.enabled = state.duty_cycle;\n\n\treturn pwm_apply_state(lp->pwm, &state);\n}\n\nstatic int lp855x_bl_update_status(struct backlight_device *bl)\n{\n\tstruct lp855x *lp = bl_get_data(bl);\n\tint brightness = bl->props.brightness;\n\n\tif (bl->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK))\n\t\tbrightness = 0;\n\n\tif (lp->mode == PWM_BASED)\n\t\treturn lp855x_pwm_ctrl(lp, brightness,\n\t\t\t\t      bl->props.max_brightness);\n\telse if (lp->mode == REGISTER_BASED)\n\t\treturn lp855x_write_byte(lp, lp->cfg->reg_brightness,\n\t\t\t\t\t(u8)brightness);\n\treturn -EINVAL;\n}\n\nstatic const struct backlight_ops lp855x_bl_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.update_status = lp855x_bl_update_status,\n};\n\nstatic int lp855x_backlight_register(struct lp855x *lp)\n{\n\tstruct backlight_device *bl;\n\tstruct backlight_properties props;\n\tstruct lp855x_platform_data *pdata = lp->pdata;\n\tconst char *name = pdata->name ? : DEFAULT_BL_NAME;\n\n\tmemset(&props, 0, sizeof(props));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = MAX_BRIGHTNESS;\n\n\tif (pdata->initial_brightness > props.max_brightness)\n\t\tpdata->initial_brightness = props.max_brightness;\n\n\tprops.brightness = pdata->initial_brightness;\n\n\tbl = devm_backlight_device_register(lp->dev, name, lp->dev, lp,\n\t\t\t\t       &lp855x_bl_ops, &props);\n\tif (IS_ERR(bl))\n\t\treturn PTR_ERR(bl);\n\n\tlp->bl = bl;\n\n\treturn 0;\n}\n\nstatic ssize_t lp855x_get_chip_id(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lp855x *lp = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", lp->chipname);\n}\n\nstatic ssize_t lp855x_get_bl_ctl_mode(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct lp855x *lp = dev_get_drvdata(dev);\n\tchar *strmode = NULL;\n\n\tif (lp->mode == PWM_BASED)\n\t\tstrmode = \"pwm based\";\n\telse if (lp->mode == REGISTER_BASED)\n\t\tstrmode = \"register based\";\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", strmode);\n}\n\nstatic DEVICE_ATTR(chip_id, S_IRUGO, lp855x_get_chip_id, NULL);\nstatic DEVICE_ATTR(bl_ctl_mode, S_IRUGO, lp855x_get_bl_ctl_mode, NULL);\n\nstatic struct attribute *lp855x_attributes[] = {\n\t&dev_attr_chip_id.attr,\n\t&dev_attr_bl_ctl_mode.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group lp855x_attr_group = {\n\t.attrs = lp855x_attributes,\n};\n\n#ifdef CONFIG_OF\nstatic int lp855x_parse_dt(struct lp855x *lp)\n{\n\tstruct device *dev = lp->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct lp855x_platform_data *pdata = lp->pdata;\n\tint rom_length;\n\n\tif (!node) {\n\t\tdev_err(dev, \"no platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tof_property_read_string(node, \"bl-name\", &pdata->name);\n\tof_property_read_u8(node, \"dev-ctrl\", &pdata->device_control);\n\tof_property_read_u8(node, \"init-brt\", &pdata->initial_brightness);\n\t \n\tof_property_read_u32(node, \"pwm-period\", &pdata->period_ns);\n\n\t \n\trom_length = of_get_child_count(node);\n\tif (rom_length > 0) {\n\t\tstruct lp855x_rom_data *rom;\n\t\tstruct device_node *child;\n\t\tint i = 0;\n\n\t\trom = devm_kcalloc(dev, rom_length, sizeof(*rom), GFP_KERNEL);\n\t\tif (!rom)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_child_of_node(node, child) {\n\t\t\tof_property_read_u8(child, \"rom-addr\", &rom[i].addr);\n\t\t\tof_property_read_u8(child, \"rom-val\", &rom[i].val);\n\t\t\ti++;\n\t\t}\n\n\t\tpdata->size_program = rom_length;\n\t\tpdata->rom_data = &rom[0];\n\t}\n\n\treturn 0;\n}\n#else\nstatic int lp855x_parse_dt(struct lp855x *lp)\n{\n\treturn -EINVAL;\n}\n#endif\n\nstatic int lp855x_parse_acpi(struct lp855x *lp)\n{\n\tint ret;\n\n\t \n\tret = i2c_smbus_read_byte_data(lp->client, lp->cfg->reg_brightness);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlp->pdata->initial_brightness = ret;\n\n\tret = i2c_smbus_read_byte_data(lp->client, lp->cfg->reg_devicectrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlp->pdata->device_control = ret;\n\treturn 0;\n}\n\nstatic int lp855x_probe(struct i2c_client *cl)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(cl);\n\tconst struct acpi_device_id *acpi_id = NULL;\n\tstruct device *dev = &cl->dev;\n\tstruct lp855x *lp;\n\tint ret;\n\n\tif (!i2c_check_functionality(cl->adapter, I2C_FUNC_SMBUS_I2C_BLOCK))\n\t\treturn -EIO;\n\n\tlp = devm_kzalloc(dev, sizeof(struct lp855x), GFP_KERNEL);\n\tif (!lp)\n\t\treturn -ENOMEM;\n\n\tlp->client = cl;\n\tlp->dev = dev;\n\tlp->pdata = dev_get_platdata(dev);\n\n\tif (id) {\n\t\tlp->chipname = id->name;\n\t\tlp->chip_id = id->driver_data;\n\t} else {\n\t\tacpi_id = acpi_match_device(dev->driver->acpi_match_table, dev);\n\t\tif (!acpi_id)\n\t\t\treturn -ENODEV;\n\n\t\tlp->chipname = acpi_id->id;\n\t\tlp->chip_id = acpi_id->driver_data;\n\t}\n\n\tswitch (lp->chip_id) {\n\tcase LP8550:\n\tcase LP8551:\n\tcase LP8552:\n\tcase LP8553:\n\tcase LP8556:\n\t\tlp->cfg = &lp855x_dev_cfg;\n\t\tbreak;\n\tcase LP8555:\n\tcase LP8557:\n\t\tlp->cfg = &lp8557_dev_cfg;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!lp->pdata) {\n\t\tlp->pdata = devm_kzalloc(dev, sizeof(*lp->pdata), GFP_KERNEL);\n\t\tif (!lp->pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tif (id) {\n\t\t\tret = lp855x_parse_dt(lp);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = lp855x_parse_acpi(lp);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tlp->supply = devm_regulator_get(dev, \"power\");\n\tif (IS_ERR(lp->supply)) {\n\t\tif (PTR_ERR(lp->supply) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tlp->supply = NULL;\n\t}\n\n\tlp->enable = devm_regulator_get_optional(dev, \"enable\");\n\tif (IS_ERR(lp->enable)) {\n\t\tret = PTR_ERR(lp->enable);\n\t\tif (ret == -ENODEV)\n\t\t\tlp->enable = NULL;\n\t\telse\n\t\t\treturn dev_err_probe(dev, ret, \"getting enable regulator\\n\");\n\t}\n\n\tlp->pwm = devm_pwm_get(lp->dev, lp->chipname);\n\tif (IS_ERR(lp->pwm)) {\n\t\tret = PTR_ERR(lp->pwm);\n\t\tif (ret == -ENODEV || ret == -EINVAL)\n\t\t\tlp->pwm = NULL;\n\t\telse\n\t\t\treturn dev_err_probe(dev, ret, \"getting PWM\\n\");\n\n\t\tlp->needs_pwm_init = false;\n\t\tlp->mode = REGISTER_BASED;\n\t\tdev_dbg(dev, \"mode: register based\\n\");\n\t} else {\n\t\tlp->needs_pwm_init = true;\n\t\tlp->mode = PWM_BASED;\n\t\tdev_dbg(dev, \"mode: PWM based\\n\");\n\t}\n\n\tif (lp->supply) {\n\t\tret = regulator_enable(lp->supply);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to enable supply: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (lp->enable) {\n\t\tret = regulator_enable(lp->enable);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to enable vddio: %d\\n\", ret);\n\t\t\tgoto disable_supply;\n\t\t}\n\n\t\t \n\t\tusleep_range(1000, 2000);\n\t}\n\n\ti2c_set_clientdata(cl, lp);\n\n\tret = lp855x_configure(lp);\n\tif (ret) {\n\t\tdev_err(dev, \"device config err: %d\", ret);\n\t\tgoto disable_vddio;\n\t}\n\n\tret = lp855x_backlight_register(lp);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register backlight. err: %d\\n\", ret);\n\t\tgoto disable_vddio;\n\t}\n\n\tret = sysfs_create_group(&dev->kobj, &lp855x_attr_group);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register sysfs. err: %d\\n\", ret);\n\t\tgoto disable_vddio;\n\t}\n\n\tbacklight_update_status(lp->bl);\n\n\treturn 0;\n\ndisable_vddio:\n\tif (lp->enable)\n\t\tregulator_disable(lp->enable);\ndisable_supply:\n\tif (lp->supply)\n\t\tregulator_disable(lp->supply);\n\n\treturn ret;\n}\n\nstatic void lp855x_remove(struct i2c_client *cl)\n{\n\tstruct lp855x *lp = i2c_get_clientdata(cl);\n\n\tlp->bl->props.brightness = 0;\n\tbacklight_update_status(lp->bl);\n\tif (lp->enable)\n\t\tregulator_disable(lp->enable);\n\tif (lp->supply)\n\t\tregulator_disable(lp->supply);\n\tsysfs_remove_group(&lp->dev->kobj, &lp855x_attr_group);\n}\n\nstatic const struct of_device_id lp855x_dt_ids[] __maybe_unused = {\n\t{ .compatible = \"ti,lp8550\", },\n\t{ .compatible = \"ti,lp8551\", },\n\t{ .compatible = \"ti,lp8552\", },\n\t{ .compatible = \"ti,lp8553\", },\n\t{ .compatible = \"ti,lp8555\", },\n\t{ .compatible = \"ti,lp8556\", },\n\t{ .compatible = \"ti,lp8557\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lp855x_dt_ids);\n\nstatic const struct i2c_device_id lp855x_ids[] = {\n\t{\"lp8550\", LP8550},\n\t{\"lp8551\", LP8551},\n\t{\"lp8552\", LP8552},\n\t{\"lp8553\", LP8553},\n\t{\"lp8555\", LP8555},\n\t{\"lp8556\", LP8556},\n\t{\"lp8557\", LP8557},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lp855x_ids);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id lp855x_acpi_match[] = {\n\t \n\t{ \"XMCC0001\", LP8556 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, lp855x_acpi_match);\n#endif\n\nstatic struct i2c_driver lp855x_driver = {\n\t.driver = {\n\t\t   .name = \"lp855x\",\n\t\t   .of_match_table = of_match_ptr(lp855x_dt_ids),\n\t\t   .acpi_match_table = ACPI_PTR(lp855x_acpi_match),\n\t\t   },\n\t.probe = lp855x_probe,\n\t.remove = lp855x_remove,\n\t.id_table = lp855x_ids,\n};\n\nmodule_i2c_driver(lp855x_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments LP855x Backlight driver\");\nMODULE_AUTHOR(\"Milo Kim <milo.kim@ti.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}