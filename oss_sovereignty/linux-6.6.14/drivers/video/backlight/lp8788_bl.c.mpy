{
  "module_name": "lp8788_bl.c",
  "hash_id": "82137b1ec06feeb5158c9dc7fef20449db0dba3088c007389a37edd8f2933fe9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/lp8788_bl.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/err.h>\n#include <linux/mfd/lp8788.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n\n \n#define LP8788_BL_CONFIG\t\t0x96\n#define LP8788_BL_EN\t\t\tBIT(0)\n#define LP8788_BL_PWM_INPUT_EN\t\tBIT(5)\n#define LP8788_BL_FULLSCALE_SHIFT\t2\n#define LP8788_BL_DIM_MODE_SHIFT\t1\n#define LP8788_BL_PWM_POLARITY_SHIFT\t6\n\n#define LP8788_BL_BRIGHTNESS\t\t0x97\n\n#define LP8788_BL_RAMP\t\t\t0x98\n#define LP8788_BL_RAMP_RISE_SHIFT\t4\n\n#define MAX_BRIGHTNESS\t\t\t127\n#define DEFAULT_BL_NAME\t\t\t\"lcd-backlight\"\n\nstruct lp8788_bl_config {\n\tenum lp8788_bl_ctrl_mode bl_mode;\n\tenum lp8788_bl_dim_mode dim_mode;\n\tenum lp8788_bl_full_scale_current full_scale;\n\tenum lp8788_bl_ramp_step rise_time;\n\tenum lp8788_bl_ramp_step fall_time;\n\tenum pwm_polarity pwm_pol;\n};\n\nstruct lp8788_bl {\n\tstruct lp8788 *lp;\n\tstruct backlight_device *bl_dev;\n\tstruct lp8788_backlight_platform_data *pdata;\n\tenum lp8788_bl_ctrl_mode mode;\n\tstruct pwm_device *pwm;\n};\n\nstatic struct lp8788_bl_config default_bl_config = {\n\t.bl_mode    = LP8788_BL_REGISTER_ONLY,\n\t.dim_mode   = LP8788_DIM_EXPONENTIAL,\n\t.full_scale = LP8788_FULLSCALE_1900uA,\n\t.rise_time  = LP8788_RAMP_8192us,\n\t.fall_time  = LP8788_RAMP_8192us,\n\t.pwm_pol    = PWM_POLARITY_NORMAL,\n};\n\nstatic inline bool is_brightness_ctrl_by_pwm(enum lp8788_bl_ctrl_mode mode)\n{\n\treturn mode == LP8788_BL_COMB_PWM_BASED;\n}\n\nstatic inline bool is_brightness_ctrl_by_register(enum lp8788_bl_ctrl_mode mode)\n{\n\treturn mode == LP8788_BL_REGISTER_ONLY ||\n\t\tmode == LP8788_BL_COMB_REGISTER_BASED;\n}\n\nstatic int lp8788_backlight_configure(struct lp8788_bl *bl)\n{\n\tstruct lp8788_backlight_platform_data *pdata = bl->pdata;\n\tstruct lp8788_bl_config *cfg = &default_bl_config;\n\tint ret;\n\tu8 val;\n\n\t \n\tif (pdata) {\n\t\tcfg->bl_mode    = pdata->bl_mode;\n\t\tcfg->dim_mode   = pdata->dim_mode;\n\t\tcfg->full_scale = pdata->full_scale;\n\t\tcfg->rise_time  = pdata->rise_time;\n\t\tcfg->fall_time  = pdata->fall_time;\n\t\tcfg->pwm_pol    = pdata->pwm_pol;\n\t}\n\n\t \n\tval = (cfg->rise_time << LP8788_BL_RAMP_RISE_SHIFT) | cfg->fall_time;\n\tret = lp8788_write_byte(bl->lp, LP8788_BL_RAMP, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = (cfg->full_scale << LP8788_BL_FULLSCALE_SHIFT) |\n\t\t(cfg->dim_mode << LP8788_BL_DIM_MODE_SHIFT);\n\n\t \n\tswitch (cfg->bl_mode) {\n\tcase LP8788_BL_REGISTER_ONLY:\n\t\tval |= LP8788_BL_EN;\n\t\tbreak;\n\tcase LP8788_BL_COMB_PWM_BASED:\n\tcase LP8788_BL_COMB_REGISTER_BASED:\n\t\tval |= LP8788_BL_EN | LP8788_BL_PWM_INPUT_EN |\n\t\t\t(cfg->pwm_pol << LP8788_BL_PWM_POLARITY_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(bl->lp->dev, \"invalid mode: %d\\n\", cfg->bl_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tbl->mode = cfg->bl_mode;\n\n\treturn lp8788_write_byte(bl->lp, LP8788_BL_CONFIG, val);\n}\n\nstatic void lp8788_pwm_ctrl(struct lp8788_bl *bl, int br, int max_br)\n{\n\tunsigned int period;\n\tunsigned int duty;\n\tstruct device *dev;\n\tstruct pwm_device *pwm;\n\n\tif (!bl->pdata)\n\t\treturn;\n\n\tperiod = bl->pdata->period_ns;\n\tduty = br * period / max_br;\n\tdev = bl->lp->dev;\n\n\t \n\tif (!bl->pwm) {\n\t\tpwm = devm_pwm_get(dev, LP8788_DEV_BACKLIGHT);\n\t\tif (IS_ERR(pwm)) {\n\t\t\tdev_err(dev, \"can not get PWM device\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tbl->pwm = pwm;\n\n\t\t \n\t\tpwm_apply_args(pwm);\n\t}\n\n\tpwm_config(bl->pwm, duty, period);\n\tif (duty)\n\t\tpwm_enable(bl->pwm);\n\telse\n\t\tpwm_disable(bl->pwm);\n}\n\nstatic int lp8788_bl_update_status(struct backlight_device *bl_dev)\n{\n\tstruct lp8788_bl *bl = bl_get_data(bl_dev);\n\tenum lp8788_bl_ctrl_mode mode = bl->mode;\n\n\tif (bl_dev->props.state & BL_CORE_SUSPENDED)\n\t\tbl_dev->props.brightness = 0;\n\n\tif (is_brightness_ctrl_by_pwm(mode)) {\n\t\tint brt = bl_dev->props.brightness;\n\t\tint max = bl_dev->props.max_brightness;\n\n\t\tlp8788_pwm_ctrl(bl, brt, max);\n\t} else if (is_brightness_ctrl_by_register(mode)) {\n\t\tu8 brt = bl_dev->props.brightness;\n\n\t\tlp8788_write_byte(bl->lp, LP8788_BL_BRIGHTNESS, brt);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops lp8788_bl_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.update_status = lp8788_bl_update_status,\n};\n\nstatic int lp8788_backlight_register(struct lp8788_bl *bl)\n{\n\tstruct backlight_device *bl_dev;\n\tstruct backlight_properties props;\n\tstruct lp8788_backlight_platform_data *pdata = bl->pdata;\n\tint init_brt;\n\tchar *name;\n\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = MAX_BRIGHTNESS;\n\n\t \n\tif (pdata)\n\t\tinit_brt = min_t(int, pdata->initial_brightness,\n\t\t\t\tprops.max_brightness);\n\telse\n\t\tinit_brt = 0;\n\n\tprops.brightness = init_brt;\n\n\t \n\tif (!pdata || !pdata->name)\n\t\tname = DEFAULT_BL_NAME;\n\telse\n\t\tname = pdata->name;\n\n\tbl_dev = backlight_device_register(name, bl->lp->dev, bl,\n\t\t\t\t       &lp8788_bl_ops, &props);\n\tif (IS_ERR(bl_dev))\n\t\treturn PTR_ERR(bl_dev);\n\n\tbl->bl_dev = bl_dev;\n\n\treturn 0;\n}\n\nstatic void lp8788_backlight_unregister(struct lp8788_bl *bl)\n{\n\tstruct backlight_device *bl_dev = bl->bl_dev;\n\n\tbacklight_device_unregister(bl_dev);\n}\n\nstatic ssize_t lp8788_get_bl_ctl_mode(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct lp8788_bl *bl = dev_get_drvdata(dev);\n\tenum lp8788_bl_ctrl_mode mode = bl->mode;\n\tchar *strmode;\n\n\tif (is_brightness_ctrl_by_pwm(mode))\n\t\tstrmode = \"PWM based\";\n\telse if (is_brightness_ctrl_by_register(mode))\n\t\tstrmode = \"Register based\";\n\telse\n\t\tstrmode = \"Invalid mode\";\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", strmode);\n}\n\nstatic DEVICE_ATTR(bl_ctl_mode, S_IRUGO, lp8788_get_bl_ctl_mode, NULL);\n\nstatic struct attribute *lp8788_attributes[] = {\n\t&dev_attr_bl_ctl_mode.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group lp8788_attr_group = {\n\t.attrs = lp8788_attributes,\n};\n\nstatic int lp8788_backlight_probe(struct platform_device *pdev)\n{\n\tstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\n\tstruct lp8788_bl *bl;\n\tint ret;\n\n\tbl = devm_kzalloc(lp->dev, sizeof(struct lp8788_bl), GFP_KERNEL);\n\tif (!bl)\n\t\treturn -ENOMEM;\n\n\tbl->lp = lp;\n\tif (lp->pdata)\n\t\tbl->pdata = lp->pdata->bl_pdata;\n\n\tplatform_set_drvdata(pdev, bl);\n\n\tret = lp8788_backlight_configure(bl);\n\tif (ret) {\n\t\tdev_err(lp->dev, \"backlight config err: %d\\n\", ret);\n\t\tgoto err_dev;\n\t}\n\n\tret = lp8788_backlight_register(bl);\n\tif (ret) {\n\t\tdev_err(lp->dev, \"register backlight err: %d\\n\", ret);\n\t\tgoto err_dev;\n\t}\n\n\tret = sysfs_create_group(&pdev->dev.kobj, &lp8788_attr_group);\n\tif (ret) {\n\t\tdev_err(lp->dev, \"register sysfs err: %d\\n\", ret);\n\t\tgoto err_sysfs;\n\t}\n\n\tbacklight_update_status(bl->bl_dev);\n\n\treturn 0;\n\nerr_sysfs:\n\tlp8788_backlight_unregister(bl);\nerr_dev:\n\treturn ret;\n}\n\nstatic void lp8788_backlight_remove(struct platform_device *pdev)\n{\n\tstruct lp8788_bl *bl = platform_get_drvdata(pdev);\n\tstruct backlight_device *bl_dev = bl->bl_dev;\n\n\tbl_dev->props.brightness = 0;\n\tbacklight_update_status(bl_dev);\n\tsysfs_remove_group(&pdev->dev.kobj, &lp8788_attr_group);\n\tlp8788_backlight_unregister(bl);\n}\n\nstatic struct platform_driver lp8788_bl_driver = {\n\t.probe = lp8788_backlight_probe,\n\t.remove_new = lp8788_backlight_remove,\n\t.driver = {\n\t\t.name = LP8788_DEV_BACKLIGHT,\n\t},\n};\nmodule_platform_driver(lp8788_bl_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments LP8788 Backlight Driver\");\nMODULE_AUTHOR(\"Milo Kim\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:lp8788-backlight\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}