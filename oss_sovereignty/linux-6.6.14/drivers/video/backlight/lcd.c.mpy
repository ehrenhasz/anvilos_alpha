{
  "module_name": "lcd.c",
  "hash_id": "a912fea2160cf37839f57444daca117f126fdf7d49f7854c1fd7e6ba67bbf21a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/lcd.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/lcd.h>\n#include <linux/notifier.h>\n#include <linux/ctype.h>\n#include <linux/err.h>\n#include <linux/fb.h>\n#include <linux/slab.h>\n\n#if defined(CONFIG_FB) || (defined(CONFIG_FB_MODULE) && \\\n\t\t\t   defined(CONFIG_LCD_CLASS_DEVICE_MODULE))\n \nstatic int fb_notifier_callback(struct notifier_block *self,\n\t\t\t\t unsigned long event, void *data)\n{\n\tstruct lcd_device *ld;\n\tstruct fb_event *evdata = data;\n\n\tld = container_of(self, struct lcd_device, fb_notif);\n\tif (!ld->ops)\n\t\treturn 0;\n\n\tmutex_lock(&ld->ops_lock);\n\tif (!ld->ops->check_fb || ld->ops->check_fb(ld, evdata->info)) {\n\t\tif (event == FB_EVENT_BLANK) {\n\t\t\tif (ld->ops->set_power)\n\t\t\t\tld->ops->set_power(ld, *(int *)evdata->data);\n\t\t} else {\n\t\t\tif (ld->ops->set_mode)\n\t\t\t\tld->ops->set_mode(ld, evdata->data);\n\t\t}\n\t}\n\tmutex_unlock(&ld->ops_lock);\n\treturn 0;\n}\n\nstatic int lcd_register_fb(struct lcd_device *ld)\n{\n\tmemset(&ld->fb_notif, 0, sizeof(ld->fb_notif));\n\tld->fb_notif.notifier_call = fb_notifier_callback;\n\treturn fb_register_client(&ld->fb_notif);\n}\n\nstatic void lcd_unregister_fb(struct lcd_device *ld)\n{\n\tfb_unregister_client(&ld->fb_notif);\n}\n#else\nstatic int lcd_register_fb(struct lcd_device *ld)\n{\n\treturn 0;\n}\n\nstatic inline void lcd_unregister_fb(struct lcd_device *ld)\n{\n}\n#endif  \n\nstatic ssize_t lcd_power_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint rc;\n\tstruct lcd_device *ld = to_lcd_device(dev);\n\n\tmutex_lock(&ld->ops_lock);\n\tif (ld->ops && ld->ops->get_power)\n\t\trc = sprintf(buf, \"%d\\n\", ld->ops->get_power(ld));\n\telse\n\t\trc = -ENXIO;\n\tmutex_unlock(&ld->ops_lock);\n\n\treturn rc;\n}\n\nstatic ssize_t lcd_power_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tint rc;\n\tstruct lcd_device *ld = to_lcd_device(dev);\n\tunsigned long power;\n\n\trc = kstrtoul(buf, 0, &power);\n\tif (rc)\n\t\treturn rc;\n\n\trc = -ENXIO;\n\n\tmutex_lock(&ld->ops_lock);\n\tif (ld->ops && ld->ops->set_power) {\n\t\tpr_debug(\"set power to %lu\\n\", power);\n\t\tld->ops->set_power(ld, power);\n\t\trc = count;\n\t}\n\tmutex_unlock(&ld->ops_lock);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RW(lcd_power);\n\nstatic ssize_t contrast_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tint rc = -ENXIO;\n\tstruct lcd_device *ld = to_lcd_device(dev);\n\n\tmutex_lock(&ld->ops_lock);\n\tif (ld->ops && ld->ops->get_contrast)\n\t\trc = sprintf(buf, \"%d\\n\", ld->ops->get_contrast(ld));\n\tmutex_unlock(&ld->ops_lock);\n\n\treturn rc;\n}\n\nstatic ssize_t contrast_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tint rc;\n\tstruct lcd_device *ld = to_lcd_device(dev);\n\tunsigned long contrast;\n\n\trc = kstrtoul(buf, 0, &contrast);\n\tif (rc)\n\t\treturn rc;\n\n\trc = -ENXIO;\n\n\tmutex_lock(&ld->ops_lock);\n\tif (ld->ops && ld->ops->set_contrast) {\n\t\tpr_debug(\"set contrast to %lu\\n\", contrast);\n\t\tld->ops->set_contrast(ld, contrast);\n\t\trc = count;\n\t}\n\tmutex_unlock(&ld->ops_lock);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RW(contrast);\n\nstatic ssize_t max_contrast_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lcd_device *ld = to_lcd_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", ld->props.max_contrast);\n}\nstatic DEVICE_ATTR_RO(max_contrast);\n\nstatic struct class *lcd_class;\n\nstatic void lcd_device_release(struct device *dev)\n{\n\tstruct lcd_device *ld = to_lcd_device(dev);\n\tkfree(ld);\n}\n\nstatic struct attribute *lcd_device_attrs[] = {\n\t&dev_attr_lcd_power.attr,\n\t&dev_attr_contrast.attr,\n\t&dev_attr_max_contrast.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(lcd_device);\n\n \nstruct lcd_device *lcd_device_register(const char *name, struct device *parent,\n\t\tvoid *devdata, struct lcd_ops *ops)\n{\n\tstruct lcd_device *new_ld;\n\tint rc;\n\n\tpr_debug(\"lcd_device_register: name=%s\\n\", name);\n\n\tnew_ld = kzalloc(sizeof(struct lcd_device), GFP_KERNEL);\n\tif (!new_ld)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&new_ld->ops_lock);\n\tmutex_init(&new_ld->update_lock);\n\n\tnew_ld->dev.class = lcd_class;\n\tnew_ld->dev.parent = parent;\n\tnew_ld->dev.release = lcd_device_release;\n\tdev_set_name(&new_ld->dev, \"%s\", name);\n\tdev_set_drvdata(&new_ld->dev, devdata);\n\n\tnew_ld->ops = ops;\n\n\trc = device_register(&new_ld->dev);\n\tif (rc) {\n\t\tput_device(&new_ld->dev);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\trc = lcd_register_fb(new_ld);\n\tif (rc) {\n\t\tdevice_unregister(&new_ld->dev);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn new_ld;\n}\nEXPORT_SYMBOL(lcd_device_register);\n\n \nvoid lcd_device_unregister(struct lcd_device *ld)\n{\n\tif (!ld)\n\t\treturn;\n\n\tmutex_lock(&ld->ops_lock);\n\tld->ops = NULL;\n\tmutex_unlock(&ld->ops_lock);\n\tlcd_unregister_fb(ld);\n\n\tdevice_unregister(&ld->dev);\n}\nEXPORT_SYMBOL(lcd_device_unregister);\n\nstatic void devm_lcd_device_release(struct device *dev, void *res)\n{\n\tstruct lcd_device *lcd = *(struct lcd_device **)res;\n\n\tlcd_device_unregister(lcd);\n}\n\nstatic int devm_lcd_device_match(struct device *dev, void *res, void *data)\n{\n\tstruct lcd_device **r = res;\n\n\treturn *r == data;\n}\n\n \nstruct lcd_device *devm_lcd_device_register(struct device *dev,\n\t\tconst char *name, struct device *parent,\n\t\tvoid *devdata, struct lcd_ops *ops)\n{\n\tstruct lcd_device **ptr, *lcd;\n\n\tptr = devres_alloc(devm_lcd_device_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlcd = lcd_device_register(name, parent, devdata, ops);\n\tif (!IS_ERR(lcd)) {\n\t\t*ptr = lcd;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn lcd;\n}\nEXPORT_SYMBOL(devm_lcd_device_register);\n\n \nvoid devm_lcd_device_unregister(struct device *dev, struct lcd_device *ld)\n{\n\tint rc;\n\n\trc = devres_release(dev, devm_lcd_device_release,\n\t\t\t\tdevm_lcd_device_match, ld);\n\tWARN_ON(rc);\n}\nEXPORT_SYMBOL(devm_lcd_device_unregister);\n\n\nstatic void __exit lcd_class_exit(void)\n{\n\tclass_destroy(lcd_class);\n}\n\nstatic int __init lcd_class_init(void)\n{\n\tlcd_class = class_create(\"lcd\");\n\tif (IS_ERR(lcd_class)) {\n\t\tpr_warn(\"Unable to create backlight class; errno = %ld\\n\",\n\t\t\tPTR_ERR(lcd_class));\n\t\treturn PTR_ERR(lcd_class);\n\t}\n\n\tlcd_class->dev_groups = lcd_device_groups;\n\treturn 0;\n}\n\n \npostcore_initcall(lcd_class_init);\nmodule_exit(lcd_class_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jamey Hicks <jamey.hicks@hp.com>, Andrew Zabolotny <zap@homelink.ru>\");\nMODULE_DESCRIPTION(\"LCD Lowlevel Control Abstraction\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}