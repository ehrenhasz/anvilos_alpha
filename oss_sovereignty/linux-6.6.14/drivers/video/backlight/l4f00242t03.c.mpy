{
  "module_name": "l4f00242t03.c",
  "hash_id": "f4750e0615a617b8b662a2631659d9b61d3a3e8011ebaef68a262d5bbae8888d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/l4f00242t03.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/lcd.h>\n#include <linux/slab.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\nstruct l4f00242t03_priv {\n\tstruct spi_device\t*spi;\n\tstruct lcd_device\t*ld;\n\tint lcd_state;\n\tstruct regulator *io_reg;\n\tstruct regulator *core_reg;\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *enable;\n};\n\nstatic void l4f00242t03_reset(struct gpio_desc *gpiod)\n{\n\tpr_debug(\"l4f00242t03_reset.\\n\");\n\tgpiod_set_value(gpiod, 1);\n\tmdelay(100);\n\tgpiod_set_value(gpiod, 0);\n\tmdelay(10);\t \n\tgpiod_set_value(gpiod, 1);\n\tmdelay(20);\n}\n\n#define param(x) ((x) | 0x100)\n\nstatic void l4f00242t03_lcd_init(struct spi_device *spi)\n{\n\tstruct l4f00242t03_priv *priv = spi_get_drvdata(spi);\n\tconst u16 cmd[] = { 0x36, param(0), 0x3A, param(0x60) };\n\tint ret;\n\n\tdev_dbg(&spi->dev, \"initializing LCD\\n\");\n\n\tret = regulator_set_voltage(priv->io_reg, 1800000, 1800000);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to set the IO regulator voltage.\\n\");\n\t\treturn;\n\t}\n\tret = regulator_enable(priv->io_reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to enable the IO regulator.\\n\");\n\t\treturn;\n\t}\n\n\tret = regulator_set_voltage(priv->core_reg, 2800000, 2800000);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to set the core regulator voltage.\\n\");\n\t\tregulator_disable(priv->io_reg);\n\t\treturn;\n\t}\n\tret = regulator_enable(priv->core_reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to enable the core regulator.\\n\");\n\t\tregulator_disable(priv->io_reg);\n\t\treturn;\n\t}\n\n\tl4f00242t03_reset(priv->reset);\n\n\tgpiod_set_value(priv->enable, 1);\n\tmsleep(60);\n\tspi_write(spi, (const u8 *)cmd, ARRAY_SIZE(cmd) * sizeof(u16));\n}\n\nstatic void l4f00242t03_lcd_powerdown(struct spi_device *spi)\n{\n\tstruct l4f00242t03_priv *priv = spi_get_drvdata(spi);\n\n\tdev_dbg(&spi->dev, \"Powering down LCD\\n\");\n\n\tgpiod_set_value(priv->enable, 0);\n\n\tregulator_disable(priv->io_reg);\n\tregulator_disable(priv->core_reg);\n}\n\nstatic int l4f00242t03_lcd_power_get(struct lcd_device *ld)\n{\n\tstruct l4f00242t03_priv *priv = lcd_get_data(ld);\n\n\treturn priv->lcd_state;\n}\n\nstatic int l4f00242t03_lcd_power_set(struct lcd_device *ld, int power)\n{\n\tstruct l4f00242t03_priv *priv = lcd_get_data(ld);\n\tstruct spi_device *spi = priv->spi;\n\n\tconst u16 slpout = 0x11;\n\tconst u16 dison = 0x29;\n\n\tconst u16 slpin = 0x10;\n\tconst u16 disoff = 0x28;\n\n\tif (power <= FB_BLANK_NORMAL) {\n\t\tif (priv->lcd_state <= FB_BLANK_NORMAL) {\n\t\t\t \n\t\t} else if (priv->lcd_state < FB_BLANK_POWERDOWN) {\n\t\t\tdev_dbg(&spi->dev, \"Resuming LCD\\n\");\n\n\t\t\tspi_write(spi, (const u8 *)&slpout, sizeof(u16));\n\t\t\tmsleep(60);\n\t\t\tspi_write(spi, (const u8 *)&dison, sizeof(u16));\n\t\t} else {\n\t\t\t \n\t\t\tl4f00242t03_lcd_init(spi);\n\t\t\tpriv->lcd_state = FB_BLANK_VSYNC_SUSPEND;\n\t\t\tl4f00242t03_lcd_power_set(priv->ld, power);\n\t\t}\n\t} else if (power < FB_BLANK_POWERDOWN) {\n\t\tif (priv->lcd_state <= FB_BLANK_NORMAL) {\n\t\t\t \n\t\t\tdev_dbg(&spi->dev, \"Standby the LCD\\n\");\n\n\t\t\tspi_write(spi, (const u8 *)&disoff, sizeof(u16));\n\t\t\tmsleep(60);\n\t\t\tspi_write(spi, (const u8 *)&slpin, sizeof(u16));\n\t\t} else if (priv->lcd_state < FB_BLANK_POWERDOWN) {\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tl4f00242t03_lcd_init(spi);\n\t\t\tpriv->lcd_state = FB_BLANK_UNBLANK;\n\t\t\tl4f00242t03_lcd_power_set(ld, power);\n\t\t}\n\t} else {\n\t\t \n\t\tif (priv->lcd_state != FB_BLANK_POWERDOWN) {\n\t\t\t \n\t\t\tspi_write(spi, (const u8 *)&disoff, sizeof(u16));\n\t\t\tmsleep(60);\n\t\t\tl4f00242t03_lcd_powerdown(spi);\n\t\t}\n\t}\n\n\tpriv->lcd_state = power;\n\n\treturn 0;\n}\n\nstatic struct lcd_ops l4f_ops = {\n\t.set_power\t= l4f00242t03_lcd_power_set,\n\t.get_power\t= l4f00242t03_lcd_power_get,\n};\n\nstatic int l4f00242t03_probe(struct spi_device *spi)\n{\n\tstruct l4f00242t03_priv *priv;\n\n\tpriv = devm_kzalloc(&spi->dev, sizeof(struct l4f00242t03_priv),\n\t\t\t\tGFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, priv);\n\tspi->bits_per_word = 9;\n\tspi_setup(spi);\n\n\tpriv->spi = spi;\n\n\tpriv->reset = devm_gpiod_get(&spi->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->reset)) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"Unable to get the lcd l4f00242t03 reset gpio.\\n\");\n\t\treturn PTR_ERR(priv->reset);\n\t}\n\tgpiod_set_consumer_name(priv->reset, \"lcd l4f00242t03 reset\");\n\n\tpriv->enable = devm_gpiod_get(&spi->dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->enable)) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"Unable to get the lcd l4f00242t03 data en gpio.\\n\");\n\t\treturn PTR_ERR(priv->enable);\n\t}\n\tgpiod_set_consumer_name(priv->enable, \"lcd l4f00242t03 data enable\");\n\n\tpriv->io_reg = devm_regulator_get(&spi->dev, \"vdd\");\n\tif (IS_ERR(priv->io_reg)) {\n\t\tdev_err(&spi->dev, \"%s: Unable to get the IO regulator\\n\",\n\t\t       __func__);\n\t\treturn PTR_ERR(priv->io_reg);\n\t}\n\n\tpriv->core_reg = devm_regulator_get(&spi->dev, \"vcore\");\n\tif (IS_ERR(priv->core_reg)) {\n\t\tdev_err(&spi->dev, \"%s: Unable to get the core regulator\\n\",\n\t\t       __func__);\n\t\treturn PTR_ERR(priv->core_reg);\n\t}\n\n\tpriv->ld = devm_lcd_device_register(&spi->dev, \"l4f00242t03\", &spi->dev,\n\t\t\t\t\tpriv, &l4f_ops);\n\tif (IS_ERR(priv->ld))\n\t\treturn PTR_ERR(priv->ld);\n\n\t \n\tl4f00242t03_lcd_init(spi);\n\tpriv->lcd_state = FB_BLANK_VSYNC_SUSPEND;\n\tl4f00242t03_lcd_power_set(priv->ld, FB_BLANK_UNBLANK);\n\n\tdev_info(&spi->dev, \"Epson l4f00242t03 lcd probed.\\n\");\n\n\treturn 0;\n}\n\nstatic void l4f00242t03_remove(struct spi_device *spi)\n{\n\tstruct l4f00242t03_priv *priv = spi_get_drvdata(spi);\n\n\tl4f00242t03_lcd_power_set(priv->ld, FB_BLANK_POWERDOWN);\n}\n\nstatic void l4f00242t03_shutdown(struct spi_device *spi)\n{\n\tstruct l4f00242t03_priv *priv = spi_get_drvdata(spi);\n\n\tif (priv)\n\t\tl4f00242t03_lcd_power_set(priv->ld, FB_BLANK_POWERDOWN);\n\n}\n\nstatic struct spi_driver l4f00242t03_driver = {\n\t.driver = {\n\t\t.name\t= \"l4f00242t03\",\n\t},\n\t.probe\t\t= l4f00242t03_probe,\n\t.remove\t\t= l4f00242t03_remove,\n\t.shutdown\t= l4f00242t03_shutdown,\n};\n\nmodule_spi_driver(l4f00242t03_driver);\n\nMODULE_AUTHOR(\"Alberto Panizzo <maramaopercheseimorto@gmail.com>\");\nMODULE_DESCRIPTION(\"EPSON L4F00242T03 LCD\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}