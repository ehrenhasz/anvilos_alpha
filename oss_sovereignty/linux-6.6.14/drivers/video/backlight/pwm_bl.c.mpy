{
  "module_name": "pwm_bl.c",
  "hash_id": "4be07ed489f30512b618c16867f9efadd20c217263970cb90a3beda0394da5ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/pwm_bl.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/fb.h>\n#include <linux/backlight.h>\n#include <linux/err.h>\n#include <linux/pwm.h>\n#include <linux/pwm_backlight.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\nstruct pwm_bl_data {\n\tstruct pwm_device\t*pwm;\n\tstruct device\t\t*dev;\n\tunsigned int\t\tlth_brightness;\n\tunsigned int\t\t*levels;\n\tbool\t\t\tenabled;\n\tstruct regulator\t*power_supply;\n\tstruct gpio_desc\t*enable_gpio;\n\tunsigned int\t\tscale;\n\tunsigned int\t\tpost_pwm_on_delay;\n\tunsigned int\t\tpwm_off_delay;\n\tint\t\t\t(*notify)(struct device *,\n\t\t\t\t\t  int brightness);\n\tvoid\t\t\t(*notify_after)(struct device *,\n\t\t\t\t\tint brightness);\n\tint\t\t\t(*check_fb)(struct device *, struct fb_info *);\n\tvoid\t\t\t(*exit)(struct device *);\n};\n\nstatic void pwm_backlight_power_on(struct pwm_bl_data *pb)\n{\n\tint err;\n\n\tif (pb->enabled)\n\t\treturn;\n\n\tif (pb->power_supply) {\n\t\terr = regulator_enable(pb->power_supply);\n\t\tif (err < 0)\n\t\t\tdev_err(pb->dev, \"failed to enable power supply\\n\");\n\t}\n\n\tif (pb->post_pwm_on_delay)\n\t\tmsleep(pb->post_pwm_on_delay);\n\n\tgpiod_set_value_cansleep(pb->enable_gpio, 1);\n\n\tpb->enabled = true;\n}\n\nstatic void pwm_backlight_power_off(struct pwm_bl_data *pb)\n{\n\tif (!pb->enabled)\n\t\treturn;\n\n\tgpiod_set_value_cansleep(pb->enable_gpio, 0);\n\n\tif (pb->pwm_off_delay)\n\t\tmsleep(pb->pwm_off_delay);\n\n\tif (pb->power_supply)\n\t\tregulator_disable(pb->power_supply);\n\tpb->enabled = false;\n}\n\nstatic int compute_duty_cycle(struct pwm_bl_data *pb, int brightness, struct pwm_state *state)\n{\n\tunsigned int lth = pb->lth_brightness;\n\tu64 duty_cycle;\n\n\tif (pb->levels)\n\t\tduty_cycle = pb->levels[brightness];\n\telse\n\t\tduty_cycle = brightness;\n\n\tduty_cycle *= state->period - lth;\n\tdo_div(duty_cycle, pb->scale);\n\n\treturn duty_cycle + lth;\n}\n\nstatic int pwm_backlight_update_status(struct backlight_device *bl)\n{\n\tstruct pwm_bl_data *pb = bl_get_data(bl);\n\tint brightness = backlight_get_brightness(bl);\n\tstruct pwm_state state;\n\n\tif (pb->notify)\n\t\tbrightness = pb->notify(pb->dev, brightness);\n\n\tif (brightness > 0) {\n\t\tpwm_get_state(pb->pwm, &state);\n\t\tstate.duty_cycle = compute_duty_cycle(pb, brightness, &state);\n\t\tstate.enabled = true;\n\t\tpwm_apply_state(pb->pwm, &state);\n\n\t\tpwm_backlight_power_on(pb);\n\t} else {\n\t\tpwm_backlight_power_off(pb);\n\n\t\tpwm_get_state(pb->pwm, &state);\n\t\tstate.duty_cycle = 0;\n\t\t \n\t\tstate.enabled = !pb->power_supply && !pb->enable_gpio;\n\t\tpwm_apply_state(pb->pwm, &state);\n\t}\n\n\tif (pb->notify_after)\n\t\tpb->notify_after(pb->dev, brightness);\n\n\treturn 0;\n}\n\nstatic int pwm_backlight_check_fb(struct backlight_device *bl,\n\t\t\t\t  struct fb_info *info)\n{\n\tstruct pwm_bl_data *pb = bl_get_data(bl);\n\n\treturn !pb->check_fb || pb->check_fb(pb->dev, info);\n}\n\nstatic const struct backlight_ops pwm_backlight_ops = {\n\t.update_status\t= pwm_backlight_update_status,\n\t.check_fb\t= pwm_backlight_check_fb,\n};\n\n#ifdef CONFIG_OF\n#define PWM_LUMINANCE_SHIFT\t16\n#define PWM_LUMINANCE_SCALE\t(1 << PWM_LUMINANCE_SHIFT)  \n\n \nstatic u64 cie1931(unsigned int lightness)\n{\n\tu64 retval;\n\n\t \n\tlightness *= 100;\n\tif (lightness <= (8 * PWM_LUMINANCE_SCALE)) {\n\t\tretval = DIV_ROUND_CLOSEST(lightness * 10, 9033);\n\t} else {\n\t\tretval = (lightness + (16 * PWM_LUMINANCE_SCALE)) / 116;\n\t\tretval *= retval * retval;\n\t\tretval += 1ULL << (2*PWM_LUMINANCE_SHIFT - 1);\n\t\tretval >>= 2*PWM_LUMINANCE_SHIFT;\n\t}\n\n\treturn retval;\n}\n\n \nstatic\nint pwm_backlight_brightness_default(struct device *dev,\n\t\t\t\t     struct platform_pwm_backlight_data *data,\n\t\t\t\t     unsigned int period)\n{\n\tunsigned int i;\n\tu64 retval;\n\n\t \n\tdata->max_brightness =\n\t\tmin((int)DIV_ROUND_UP(period, fls(period)), 4096);\n\n\tdata->levels = devm_kcalloc(dev, data->max_brightness,\n\t\t\t\t    sizeof(*data->levels), GFP_KERNEL);\n\tif (!data->levels)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < data->max_brightness; i++) {\n\t\tretval = cie1931((i * PWM_LUMINANCE_SCALE) /\n\t\t\t\t data->max_brightness) * period;\n\t\tretval = DIV_ROUND_CLOSEST_ULL(retval, PWM_LUMINANCE_SCALE);\n\t\tif (retval > UINT_MAX)\n\t\t\treturn -EINVAL;\n\t\tdata->levels[i] = (unsigned int)retval;\n\t}\n\n\tdata->dft_brightness = data->max_brightness / 2;\n\tdata->max_brightness--;\n\n\treturn 0;\n}\n\nstatic int pwm_backlight_parse_dt(struct device *dev,\n\t\t\t\t  struct platform_pwm_backlight_data *data)\n{\n\tstruct device_node *node = dev->of_node;\n\tunsigned int num_levels;\n\tunsigned int num_steps = 0;\n\tstruct property *prop;\n\tunsigned int *table;\n\tint length;\n\tu32 value;\n\tint ret;\n\n\tif (!node)\n\t\treturn -ENODEV;\n\n\tmemset(data, 0, sizeof(*data));\n\n\t \n\tof_property_read_u32(node, \"post-pwm-on-delay-ms\",\n\t\t\t     &data->post_pwm_on_delay);\n\tof_property_read_u32(node, \"pwm-off-delay-ms\", &data->pwm_off_delay);\n\n\t \n\tprop = of_find_property(node, \"brightness-levels\", &length);\n\tif (!prop)\n\t\treturn 0;\n\n\tnum_levels = length / sizeof(u32);\n\n\t \n\tif (num_levels > 0) {\n\t\tdata->levels = devm_kcalloc(dev, num_levels,\n\t\t\t\t\t    sizeof(*data->levels), GFP_KERNEL);\n\t\tif (!data->levels)\n\t\t\treturn -ENOMEM;\n\n\t\tret = of_property_read_u32_array(node, \"brightness-levels\",\n\t\t\t\t\t\t data->levels,\n\t\t\t\t\t\t num_levels);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = of_property_read_u32(node, \"default-brightness-level\",\n\t\t\t\t\t   &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata->dft_brightness = value;\n\n\t\t \n\t\tof_property_read_u32(node, \"num-interpolated-steps\",\n\t\t\t\t     &num_steps);\n\n\t\t \n\t\tif (num_steps) {\n\t\t\tunsigned int num_input_levels = num_levels;\n\t\t\tunsigned int i;\n\t\t\tu32 x1, x2, x, dx;\n\t\t\tu32 y1, y2;\n\t\t\ts64 dy;\n\n\t\t\tif (num_input_levels < 2) {\n\t\t\t\tdev_err(dev, \"can't interpolate\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tnum_levels = (num_input_levels - 1) * num_steps + 1;\n\t\t\tdev_dbg(dev, \"new number of brightness levels: %d\\n\",\n\t\t\t\tnum_levels);\n\n\t\t\t \n\t\t\ttable = devm_kcalloc(dev, num_levels, sizeof(*table),\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!table)\n\t\t\t\treturn -ENOMEM;\n\t\t\t \n\t\t\tdx = num_steps;\n\t\t\tfor (i = 0; i < num_input_levels - 1; i++) {\n\t\t\t\tx1 = i * dx;\n\t\t\t\tx2 = x1 + dx;\n\t\t\t\ty1 = data->levels[i];\n\t\t\t\ty2 = data->levels[i + 1];\n\t\t\t\tdy = (s64)y2 - y1;\n\n\t\t\t\tfor (x = x1; x < x2; x++) {\n\t\t\t\t\ttable[x] = y1 +\n\t\t\t\t\t\tdiv_s64(dy * (x - x1), dx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\ttable[x2] = y2;\n\n\t\t\t \n\t\t\tdevm_kfree(dev, data->levels);\n\t\t\tdata->levels = table;\n\t\t}\n\n\t\tdata->max_brightness = num_levels - 1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id pwm_backlight_of_match[] = {\n\t{ .compatible = \"pwm-backlight\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, pwm_backlight_of_match);\n#else\nstatic int pwm_backlight_parse_dt(struct device *dev,\n\t\t\t\t  struct platform_pwm_backlight_data *data)\n{\n\treturn -ENODEV;\n}\n\nstatic\nint pwm_backlight_brightness_default(struct device *dev,\n\t\t\t\t     struct platform_pwm_backlight_data *data,\n\t\t\t\t     unsigned int period)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic bool pwm_backlight_is_linear(struct platform_pwm_backlight_data *data)\n{\n\tunsigned int nlevels = data->max_brightness + 1;\n\tunsigned int min_val = data->levels[0];\n\tunsigned int max_val = data->levels[nlevels - 1];\n\t \n\tunsigned int slope = (128 * (max_val - min_val)) / nlevels;\n\tunsigned int margin = (max_val - min_val) / 20;  \n\tint i;\n\n\tfor (i = 1; i < nlevels; i++) {\n\t\tunsigned int linear_value = min_val + ((i * slope) / 128);\n\t\tunsigned int delta = abs(linear_value - data->levels[i]);\n\n\t\tif (delta > margin)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int pwm_backlight_initial_power_state(const struct pwm_bl_data *pb)\n{\n\tstruct device_node *node = pb->dev->of_node;\n\tbool active = true;\n\n\t \n\tif (pb->enable_gpio && gpiod_get_value_cansleep(pb->enable_gpio) == 0)\n\t\tactive = false;\n\n\tif (pb->power_supply && !regulator_is_enabled(pb->power_supply))\n\t\tactive = false;\n\n\tif (!pwm_is_enabled(pb->pwm))\n\t\tactive = false;\n\n\t \n\tgpiod_direction_output(pb->enable_gpio, active);\n\n\t \n\n\t \n\tif (!node || !node->phandle)\n\t\treturn FB_BLANK_UNBLANK;\n\n\t \n\treturn active ? FB_BLANK_UNBLANK: FB_BLANK_POWERDOWN;\n}\n\nstatic int pwm_backlight_probe(struct platform_device *pdev)\n{\n\tstruct platform_pwm_backlight_data *data = dev_get_platdata(&pdev->dev);\n\tstruct platform_pwm_backlight_data defdata;\n\tstruct backlight_properties props;\n\tstruct backlight_device *bl;\n\tstruct pwm_bl_data *pb;\n\tstruct pwm_state state;\n\tunsigned int i;\n\tint ret;\n\n\tif (!data) {\n\t\tret = pwm_backlight_parse_dt(&pdev->dev, &defdata);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to find platform data\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata = &defdata;\n\t}\n\n\tif (data->init) {\n\t\tret = data->init(&pdev->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tpb = devm_kzalloc(&pdev->dev, sizeof(*pb), GFP_KERNEL);\n\tif (!pb) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tpb->notify = data->notify;\n\tpb->notify_after = data->notify_after;\n\tpb->check_fb = data->check_fb;\n\tpb->exit = data->exit;\n\tpb->dev = &pdev->dev;\n\tpb->enabled = false;\n\tpb->post_pwm_on_delay = data->post_pwm_on_delay;\n\tpb->pwm_off_delay = data->pwm_off_delay;\n\n\tpb->enable_gpio = devm_gpiod_get_optional(&pdev->dev, \"enable\",\n\t\t\t\t\t\t  GPIOD_ASIS);\n\tif (IS_ERR(pb->enable_gpio)) {\n\t\tret = PTR_ERR(pb->enable_gpio);\n\t\tgoto err_alloc;\n\t}\n\n\tpb->power_supply = devm_regulator_get_optional(&pdev->dev, \"power\");\n\tif (IS_ERR(pb->power_supply)) {\n\t\tret = PTR_ERR(pb->power_supply);\n\t\tif (ret == -ENODEV)\n\t\t\tpb->power_supply = NULL;\n\t\telse\n\t\t\tgoto err_alloc;\n\t}\n\n\tpb->pwm = devm_pwm_get(&pdev->dev, NULL);\n\tif (IS_ERR(pb->pwm)) {\n\t\tret = PTR_ERR(pb->pwm);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"unable to request PWM\\n\");\n\t\tgoto err_alloc;\n\t}\n\n\tdev_dbg(&pdev->dev, \"got pwm for backlight\\n\");\n\n\t \n\tpwm_init_state(pb->pwm, &state);\n\n\t \n\tif (!state.period && (data->pwm_period_ns > 0))\n\t\tstate.period = data->pwm_period_ns;\n\n\tret = pwm_apply_state(pb->pwm, &state);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to apply initial PWM state: %d\\n\",\n\t\t\tret);\n\t\tgoto err_alloc;\n\t}\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\n\tif (data->levels) {\n\t\tpb->levels = data->levels;\n\n\t\t \n\t\tfor (i = 0; i <= data->max_brightness; i++)\n\t\t\tif (data->levels[i] > pb->scale)\n\t\t\t\tpb->scale = data->levels[i];\n\n\t\tif (pwm_backlight_is_linear(data))\n\t\t\tprops.scale = BACKLIGHT_SCALE_LINEAR;\n\t\telse\n\t\t\tprops.scale = BACKLIGHT_SCALE_NON_LINEAR;\n\t} else if (!data->max_brightness) {\n\t\t \n\n\t\t \n\t\tpwm_get_state(pb->pwm, &state);\n\n\t\tret = pwm_backlight_brightness_default(&pdev->dev, data,\n\t\t\t\t\t\t       state.period);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to setup default brightness table\\n\");\n\t\t\tgoto err_alloc;\n\t\t}\n\n\t\tfor (i = 0; i <= data->max_brightness; i++) {\n\t\t\tif (data->levels[i] > pb->scale)\n\t\t\t\tpb->scale = data->levels[i];\n\n\t\t\tpb->levels = data->levels;\n\t\t}\n\n\t\tprops.scale = BACKLIGHT_SCALE_NON_LINEAR;\n\t} else {\n\t\t \n\t\tpb->scale = data->max_brightness;\n\t}\n\n\tpb->lth_brightness = data->lth_brightness * (div_u64(state.period,\n\t\t\t\tpb->scale));\n\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = data->max_brightness;\n\tbl = backlight_device_register(dev_name(&pdev->dev), &pdev->dev, pb,\n\t\t\t\t       &pwm_backlight_ops, &props);\n\tif (IS_ERR(bl)) {\n\t\tdev_err(&pdev->dev, \"failed to register backlight\\n\");\n\t\tret = PTR_ERR(bl);\n\t\tgoto err_alloc;\n\t}\n\n\tif (data->dft_brightness > data->max_brightness) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"invalid default brightness level: %u, using %u\\n\",\n\t\t\t data->dft_brightness, data->max_brightness);\n\t\tdata->dft_brightness = data->max_brightness;\n\t}\n\n\tbl->props.brightness = data->dft_brightness;\n\tbl->props.power = pwm_backlight_initial_power_state(pb);\n\tbacklight_update_status(bl);\n\n\tplatform_set_drvdata(pdev, bl);\n\treturn 0;\n\nerr_alloc:\n\tif (data->exit)\n\t\tdata->exit(&pdev->dev);\n\treturn ret;\n}\n\nstatic void pwm_backlight_remove(struct platform_device *pdev)\n{\n\tstruct backlight_device *bl = platform_get_drvdata(pdev);\n\tstruct pwm_bl_data *pb = bl_get_data(bl);\n\tstruct pwm_state state;\n\n\tbacklight_device_unregister(bl);\n\tpwm_backlight_power_off(pb);\n\tpwm_get_state(pb->pwm, &state);\n\tstate.duty_cycle = 0;\n\tstate.enabled = false;\n\tpwm_apply_state(pb->pwm, &state);\n\n\tif (pb->exit)\n\t\tpb->exit(&pdev->dev);\n}\n\nstatic void pwm_backlight_shutdown(struct platform_device *pdev)\n{\n\tstruct backlight_device *bl = platform_get_drvdata(pdev);\n\tstruct pwm_bl_data *pb = bl_get_data(bl);\n\tstruct pwm_state state;\n\n\tpwm_backlight_power_off(pb);\n\tpwm_get_state(pb->pwm, &state);\n\tstate.duty_cycle = 0;\n\tstate.enabled = false;\n\tpwm_apply_state(pb->pwm, &state);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pwm_backlight_suspend(struct device *dev)\n{\n\tstruct backlight_device *bl = dev_get_drvdata(dev);\n\tstruct pwm_bl_data *pb = bl_get_data(bl);\n\tstruct pwm_state state;\n\n\tif (pb->notify)\n\t\tpb->notify(pb->dev, 0);\n\n\tpwm_backlight_power_off(pb);\n\n\t \n\tpwm_get_state(pb->pwm, &state);\n\tstate.duty_cycle = 0;\n\tstate.enabled = false;\n\tpwm_apply_state(pb->pwm, &state);\n\n\tif (pb->notify_after)\n\t\tpb->notify_after(pb->dev, 0);\n\n\treturn 0;\n}\n\nstatic int pwm_backlight_resume(struct device *dev)\n{\n\tstruct backlight_device *bl = dev_get_drvdata(dev);\n\n\tbacklight_update_status(bl);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops pwm_backlight_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend = pwm_backlight_suspend,\n\t.resume = pwm_backlight_resume,\n\t.poweroff = pwm_backlight_suspend,\n\t.restore = pwm_backlight_resume,\n#endif\n};\n\nstatic struct platform_driver pwm_backlight_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"pwm-backlight\",\n\t\t.pm\t\t= &pwm_backlight_pm_ops,\n\t\t.of_match_table\t= of_match_ptr(pwm_backlight_of_match),\n\t},\n\t.probe\t\t= pwm_backlight_probe,\n\t.remove_new\t= pwm_backlight_remove,\n\t.shutdown\t= pwm_backlight_shutdown,\n};\n\nmodule_platform_driver(pwm_backlight_driver);\n\nMODULE_DESCRIPTION(\"PWM based Backlight Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:pwm-backlight\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}