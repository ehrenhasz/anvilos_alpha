{
  "module_name": "ili922x.c",
  "hash_id": "f4a38042192c97b1d088eac2e3fcfd9770b309087454c9e1c2e6a1faa5131069",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/ili922x.c",
  "human_readable_source": "\n \n\n#include <linux/fb.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/lcd.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/string.h>\n\n \n#define REG_START_OSCILLATION\t\t\t0x00\n#define REG_DRIVER_CODE_READ\t\t\t0x00\n#define REG_DRIVER_OUTPUT_CONTROL\t\t0x01\n#define REG_LCD_AC_DRIVEING_CONTROL\t\t0x02\n#define REG_ENTRY_MODE\t\t\t\t0x03\n#define REG_COMPARE_1\t\t\t\t0x04\n#define REG_COMPARE_2\t\t\t\t0x05\n#define REG_DISPLAY_CONTROL_1\t\t\t0x07\n#define REG_DISPLAY_CONTROL_2\t\t\t0x08\n#define REG_DISPLAY_CONTROL_3\t\t\t0x09\n#define REG_FRAME_CYCLE_CONTROL\t\t\t0x0B\n#define REG_EXT_INTF_CONTROL\t\t\t0x0C\n#define REG_POWER_CONTROL_1\t\t\t0x10\n#define REG_POWER_CONTROL_2\t\t\t0x11\n#define REG_POWER_CONTROL_3\t\t\t0x12\n#define REG_POWER_CONTROL_4\t\t\t0x13\n#define REG_RAM_ADDRESS_SET\t\t\t0x21\n#define REG_WRITE_DATA_TO_GRAM\t\t\t0x22\n#define REG_RAM_WRITE_MASK1\t\t\t0x23\n#define REG_RAM_WRITE_MASK2\t\t\t0x24\n#define REG_GAMMA_CONTROL_1\t\t\t0x30\n#define REG_GAMMA_CONTROL_2\t\t\t0x31\n#define REG_GAMMA_CONTROL_3\t\t\t0x32\n#define REG_GAMMA_CONTROL_4\t\t\t0x33\n#define REG_GAMMA_CONTROL_5\t\t\t0x34\n#define REG_GAMMA_CONTROL_6\t\t\t0x35\n#define REG_GAMMA_CONTROL_7\t\t\t0x36\n#define REG_GAMMA_CONTROL_8\t\t\t0x37\n#define REG_GAMMA_CONTROL_9\t\t\t0x38\n#define REG_GAMMA_CONTROL_10\t\t\t0x39\n#define REG_GATE_SCAN_CONTROL\t\t\t0x40\n#define REG_VERT_SCROLL_CONTROL\t\t\t0x41\n#define REG_FIRST_SCREEN_DRIVE_POS\t\t0x42\n#define REG_SECOND_SCREEN_DRIVE_POS\t\t0x43\n#define REG_RAM_ADDR_POS_H\t\t\t0x44\n#define REG_RAM_ADDR_POS_V\t\t\t0x45\n#define REG_OSCILLATOR_CONTROL\t\t\t0x4F\n#define REG_GPIO\t\t\t\t0x60\n#define REG_OTP_VCM_PROGRAMMING\t\t\t0x61\n#define REG_OTP_VCM_STATUS_ENABLE\t\t0x62\n#define REG_OTP_PROGRAMMING_ID_KEY\t\t0x65\n\n \n#define ILITEK_MAX_FREQ_REG\t4000000\n\n \n#define ILITEK_DEVICE_ID\t0x9220\n#define ILITEK_DEVICE_ID_MASK\t0xFFF0\n\n \n#define START_RS_INDEX\t\t0\n#define START_RS_REG\t\t1\n#define START_RW_WRITE\t\t0\n#define START_RW_READ\t\t1\n\n \n#define START_BYTE(id, rs, rw)\t\\\n\t(0x70 | (((id) & 0x01) << 2) | (((rs) & 0x01) << 1) | ((rw) & 0x01))\n\n \n#define CHECK_FREQ_REG(s, x)\t\\\n\tdo {\t\t\t\\\n\t\tif (s->max_speed_hz > ILITEK_MAX_FREQ_REG)\t\\\n\t\t\t((struct spi_transfer *)x)->speed_hz =\t\\\n\t\t\t\t\tILITEK_MAX_FREQ_REG;\t\\\n\t} while (0)\n\n#define CMD_BUFSIZE\t\t16\n\n#define POWER_IS_ON(pwr)\t((pwr) <= FB_BLANK_NORMAL)\n\n#define set_tx_byte(b)\t\t(tx_invert ? ~(b) : b)\n\n \nstatic int ili922x_id = 1;\nmodule_param(ili922x_id, int, 0);\n\nstatic int tx_invert;\nmodule_param(tx_invert, int, 0);\n\n \nstruct ili922x {\n\tstruct spi_device *spi;\n\tstruct lcd_device *ld;\n\tint power;\n};\n\n \nstatic int ili922x_read_status(struct spi_device *spi, u16 *rs)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer;\n\tunsigned char tbuf[CMD_BUFSIZE];\n\tunsigned char rbuf[CMD_BUFSIZE];\n\tint ret, i;\n\n\tmemset(&xfer, 0, sizeof(struct spi_transfer));\n\tspi_message_init(&msg);\n\txfer.tx_buf = tbuf;\n\txfer.rx_buf = rbuf;\n\txfer.cs_change = 1;\n\tCHECK_FREQ_REG(spi, &xfer);\n\n\ttbuf[0] = set_tx_byte(START_BYTE(ili922x_id, START_RS_INDEX,\n\t\t\t\t\t START_RW_READ));\n\t \n\tfor (i = 1; i < 4; i++)\n\t\ttbuf[i] = set_tx_byte(0);\t \n\n\txfer.bits_per_word = 8;\n\txfer.len = 4;\n\tspi_message_add_tail(&xfer, &msg);\n\tret = spi_sync(spi, &msg);\n\tif (ret < 0) {\n\t\tdev_dbg(&spi->dev, \"Error sending SPI message 0x%x\", ret);\n\t\treturn ret;\n\t}\n\n\t*rs = (rbuf[2] << 8) + rbuf[3];\n\treturn 0;\n}\n\n \nstatic int ili922x_read(struct spi_device *spi, u8 reg, u16 *rx)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer_regindex, xfer_regvalue;\n\tunsigned char tbuf[CMD_BUFSIZE];\n\tunsigned char rbuf[CMD_BUFSIZE];\n\tint ret, len = 0, send_bytes;\n\n\tmemset(&xfer_regindex, 0, sizeof(struct spi_transfer));\n\tmemset(&xfer_regvalue, 0, sizeof(struct spi_transfer));\n\tspi_message_init(&msg);\n\txfer_regindex.tx_buf = tbuf;\n\txfer_regindex.rx_buf = rbuf;\n\txfer_regindex.cs_change = 1;\n\tCHECK_FREQ_REG(spi, &xfer_regindex);\n\n\ttbuf[0] = set_tx_byte(START_BYTE(ili922x_id, START_RS_INDEX,\n\t\t\t\t\t START_RW_WRITE));\n\ttbuf[1] = set_tx_byte(0);\n\ttbuf[2] = set_tx_byte(reg);\n\txfer_regindex.bits_per_word = 8;\n\tlen = xfer_regindex.len = 3;\n\tspi_message_add_tail(&xfer_regindex, &msg);\n\n\tsend_bytes = len;\n\n\ttbuf[len++] = set_tx_byte(START_BYTE(ili922x_id, START_RS_REG,\n\t\t\t\t\t     START_RW_READ));\n\ttbuf[len++] = set_tx_byte(0);\n\ttbuf[len] = set_tx_byte(0);\n\n\txfer_regvalue.cs_change = 1;\n\txfer_regvalue.len = 3;\n\txfer_regvalue.tx_buf = &tbuf[send_bytes];\n\txfer_regvalue.rx_buf = &rbuf[send_bytes];\n\tCHECK_FREQ_REG(spi, &xfer_regvalue);\n\n\tspi_message_add_tail(&xfer_regvalue, &msg);\n\tret = spi_sync(spi, &msg);\n\tif (ret < 0) {\n\t\tdev_dbg(&spi->dev, \"Error sending SPI message 0x%x\", ret);\n\t\treturn ret;\n\t}\n\n\t*rx = (rbuf[1 + send_bytes] << 8) + rbuf[2 + send_bytes];\n\treturn 0;\n}\n\n \nstatic int ili922x_write(struct spi_device *spi, u8 reg, u16 value)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer_regindex, xfer_regvalue;\n\tunsigned char tbuf[CMD_BUFSIZE];\n\tunsigned char rbuf[CMD_BUFSIZE];\n\tint ret;\n\n\tmemset(&xfer_regindex, 0, sizeof(struct spi_transfer));\n\tmemset(&xfer_regvalue, 0, sizeof(struct spi_transfer));\n\n\tspi_message_init(&msg);\n\txfer_regindex.tx_buf = tbuf;\n\txfer_regindex.rx_buf = rbuf;\n\txfer_regindex.cs_change = 1;\n\tCHECK_FREQ_REG(spi, &xfer_regindex);\n\n\ttbuf[0] = set_tx_byte(START_BYTE(ili922x_id, START_RS_INDEX,\n\t\t\t\t\t START_RW_WRITE));\n\ttbuf[1] = set_tx_byte(0);\n\ttbuf[2] = set_tx_byte(reg);\n\txfer_regindex.bits_per_word = 8;\n\txfer_regindex.len = 3;\n\tspi_message_add_tail(&xfer_regindex, &msg);\n\n\tret = spi_sync(spi, &msg);\n\n\tspi_message_init(&msg);\n\ttbuf[0] = set_tx_byte(START_BYTE(ili922x_id, START_RS_REG,\n\t\t\t\t\t START_RW_WRITE));\n\ttbuf[1] = set_tx_byte((value & 0xFF00) >> 8);\n\ttbuf[2] = set_tx_byte(value & 0x00FF);\n\n\txfer_regvalue.cs_change = 1;\n\txfer_regvalue.len = 3;\n\txfer_regvalue.tx_buf = tbuf;\n\txfer_regvalue.rx_buf = rbuf;\n\tCHECK_FREQ_REG(spi, &xfer_regvalue);\n\n\tspi_message_add_tail(&xfer_regvalue, &msg);\n\n\tret = spi_sync(spi, &msg);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"Error sending SPI message 0x%x\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n#ifdef DEBUG\n \nstatic void ili922x_reg_dump(struct spi_device *spi)\n{\n\tu8 reg;\n\tu16 rx;\n\n\tdev_dbg(&spi->dev, \"ILI922x configuration registers:\\n\");\n\tfor (reg = REG_START_OSCILLATION;\n\t     reg <= REG_OTP_PROGRAMMING_ID_KEY; reg++) {\n\t\tili922x_read(spi, reg, &rx);\n\t\tdev_dbg(&spi->dev, \"reg @ 0x%02X: 0x%04X\\n\", reg, rx);\n\t}\n}\n#else\nstatic inline void ili922x_reg_dump(struct spi_device *spi) {}\n#endif\n\n \nstatic void set_write_to_gram_reg(struct spi_device *spi)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer;\n\tunsigned char tbuf[CMD_BUFSIZE];\n\n\tmemset(&xfer, 0, sizeof(struct spi_transfer));\n\n\tspi_message_init(&msg);\n\txfer.tx_buf = tbuf;\n\txfer.rx_buf = NULL;\n\txfer.cs_change = 1;\n\n\ttbuf[0] = START_BYTE(ili922x_id, START_RS_INDEX, START_RW_WRITE);\n\ttbuf[1] = 0;\n\ttbuf[2] = REG_WRITE_DATA_TO_GRAM;\n\n\txfer.bits_per_word = 8;\n\txfer.len = 3;\n\tspi_message_add_tail(&xfer, &msg);\n\tspi_sync(spi, &msg);\n}\n\n \nstatic int ili922x_poweron(struct spi_device *spi)\n{\n\tint ret;\n\n\t \n\tret = ili922x_write(spi, REG_POWER_CONTROL_1, 0x0000);\n\tusleep_range(10000, 10500);\n\tret += ili922x_write(spi, REG_POWER_CONTROL_2, 0x0000);\n\tret += ili922x_write(spi, REG_POWER_CONTROL_3, 0x0000);\n\tmsleep(40);\n\tret += ili922x_write(spi, REG_POWER_CONTROL_4, 0x0000);\n\tmsleep(40);\n\t \n\tret += ili922x_write(spi, 0x56, 0x080F);\n\tret += ili922x_write(spi, REG_POWER_CONTROL_1, 0x4240);\n\tusleep_range(10000, 10500);\n\tret += ili922x_write(spi, REG_POWER_CONTROL_2, 0x0000);\n\tret += ili922x_write(spi, REG_POWER_CONTROL_3, 0x0014);\n\tmsleep(40);\n\tret += ili922x_write(spi, REG_POWER_CONTROL_4, 0x1319);\n\tmsleep(40);\n\n\treturn ret;\n}\n\n \nstatic int ili922x_poweroff(struct spi_device *spi)\n{\n\tint ret;\n\n\t \n\tret = ili922x_write(spi, REG_POWER_CONTROL_1, 0x0000);\n\tusleep_range(10000, 10500);\n\tret += ili922x_write(spi, REG_POWER_CONTROL_2, 0x0000);\n\tret += ili922x_write(spi, REG_POWER_CONTROL_3, 0x0000);\n\tmsleep(40);\n\tret += ili922x_write(spi, REG_POWER_CONTROL_4, 0x0000);\n\tmsleep(40);\n\n\treturn ret;\n}\n\n \nstatic void ili922x_display_init(struct spi_device *spi)\n{\n\tili922x_write(spi, REG_START_OSCILLATION, 1);\n\tusleep_range(10000, 10500);\n\tili922x_write(spi, REG_DRIVER_OUTPUT_CONTROL, 0x691B);\n\tili922x_write(spi, REG_LCD_AC_DRIVEING_CONTROL, 0x0700);\n\tili922x_write(spi, REG_ENTRY_MODE, 0x1030);\n\tili922x_write(spi, REG_COMPARE_1, 0x0000);\n\tili922x_write(spi, REG_COMPARE_2, 0x0000);\n\tili922x_write(spi, REG_DISPLAY_CONTROL_1, 0x0037);\n\tili922x_write(spi, REG_DISPLAY_CONTROL_2, 0x0202);\n\tili922x_write(spi, REG_DISPLAY_CONTROL_3, 0x0000);\n\tili922x_write(spi, REG_FRAME_CYCLE_CONTROL, 0x0000);\n\n\t \n\tili922x_write(spi, REG_EXT_INTF_CONTROL, 0x0110);\n\n\tili922x_poweron(spi);\n\n\tili922x_write(spi, REG_GAMMA_CONTROL_1, 0x0302);\n\tili922x_write(spi, REG_GAMMA_CONTROL_2, 0x0407);\n\tili922x_write(spi, REG_GAMMA_CONTROL_3, 0x0304);\n\tili922x_write(spi, REG_GAMMA_CONTROL_4, 0x0203);\n\tili922x_write(spi, REG_GAMMA_CONTROL_5, 0x0706);\n\tili922x_write(spi, REG_GAMMA_CONTROL_6, 0x0407);\n\tili922x_write(spi, REG_GAMMA_CONTROL_7, 0x0706);\n\tili922x_write(spi, REG_GAMMA_CONTROL_8, 0x0000);\n\tili922x_write(spi, REG_GAMMA_CONTROL_9, 0x0C06);\n\tili922x_write(spi, REG_GAMMA_CONTROL_10, 0x0F00);\n\tili922x_write(spi, REG_RAM_ADDRESS_SET, 0x0000);\n\tili922x_write(spi, REG_GATE_SCAN_CONTROL, 0x0000);\n\tili922x_write(spi, REG_VERT_SCROLL_CONTROL, 0x0000);\n\tili922x_write(spi, REG_FIRST_SCREEN_DRIVE_POS, 0xDB00);\n\tili922x_write(spi, REG_SECOND_SCREEN_DRIVE_POS, 0xDB00);\n\tili922x_write(spi, REG_RAM_ADDR_POS_H, 0xAF00);\n\tili922x_write(spi, REG_RAM_ADDR_POS_V, 0xDB00);\n\tili922x_reg_dump(spi);\n\tset_write_to_gram_reg(spi);\n}\n\nstatic int ili922x_lcd_power(struct ili922x *lcd, int power)\n{\n\tint ret = 0;\n\n\tif (POWER_IS_ON(power) && !POWER_IS_ON(lcd->power))\n\t\tret = ili922x_poweron(lcd->spi);\n\telse if (!POWER_IS_ON(power) && POWER_IS_ON(lcd->power))\n\t\tret = ili922x_poweroff(lcd->spi);\n\n\tif (!ret)\n\t\tlcd->power = power;\n\n\treturn ret;\n}\n\nstatic int ili922x_set_power(struct lcd_device *ld, int power)\n{\n\tstruct ili922x *ili = lcd_get_data(ld);\n\n\treturn ili922x_lcd_power(ili, power);\n}\n\nstatic int ili922x_get_power(struct lcd_device *ld)\n{\n\tstruct ili922x *ili = lcd_get_data(ld);\n\n\treturn ili->power;\n}\n\nstatic struct lcd_ops ili922x_ops = {\n\t.get_power = ili922x_get_power,\n\t.set_power = ili922x_set_power,\n};\n\nstatic int ili922x_probe(struct spi_device *spi)\n{\n\tstruct ili922x *ili;\n\tstruct lcd_device *lcd;\n\tint ret;\n\tu16 reg = 0;\n\n\tili = devm_kzalloc(&spi->dev, sizeof(*ili), GFP_KERNEL);\n\tif (!ili)\n\t\treturn -ENOMEM;\n\n\tili->spi = spi;\n\tspi_set_drvdata(spi, ili);\n\n\t \n\tret = ili922x_read(spi, REG_DRIVER_CODE_READ, &reg);\n\tif (ret || ((reg & ILITEK_DEVICE_ID_MASK) != ILITEK_DEVICE_ID)) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"no LCD found: Chip ID 0x%x, ret %d\\n\",\n\t\t\treg, ret);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&spi->dev, \"ILI%x found, SPI freq %d, mode %d\\n\",\n\t\t reg, spi->max_speed_hz, spi->mode);\n\n\tret = ili922x_read_status(spi, &reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"reading RS failed...\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&spi->dev, \"status: 0x%x\\n\", reg);\n\n\tili922x_display_init(spi);\n\n\tili->power = FB_BLANK_POWERDOWN;\n\n\tlcd = devm_lcd_device_register(&spi->dev, \"ili922xlcd\", &spi->dev, ili,\n\t\t\t\t\t&ili922x_ops);\n\tif (IS_ERR(lcd)) {\n\t\tdev_err(&spi->dev, \"cannot register LCD\\n\");\n\t\treturn PTR_ERR(lcd);\n\t}\n\n\tili->ld = lcd;\n\tspi_set_drvdata(spi, ili);\n\n\tili922x_lcd_power(ili, FB_BLANK_UNBLANK);\n\n\treturn 0;\n}\n\nstatic void ili922x_remove(struct spi_device *spi)\n{\n\tili922x_poweroff(spi);\n}\n\nstatic struct spi_driver ili922x_driver = {\n\t.driver = {\n\t\t.name = \"ili922x\",\n\t},\n\t.probe = ili922x_probe,\n\t.remove = ili922x_remove,\n};\n\nmodule_spi_driver(ili922x_driver);\n\nMODULE_AUTHOR(\"Stefano Babic <sbabic@denx.de>\");\nMODULE_DESCRIPTION(\"ILI9221/9222 LCD driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_PARM_DESC(ili922x_id, \"set controller identifier (default=1)\");\nMODULE_PARM_DESC(tx_invert, \"invert bytes before sending\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}