{
  "module_name": "led_bl.c",
  "hash_id": "7655041d2b18559c2dc793106e9e14c0a034622480e34da10a3d5031a7cea93a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/led_bl.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\nstruct led_bl_data {\n\tstruct device\t\t*dev;\n\tstruct backlight_device\t*bl_dev;\n\tstruct led_classdev\t**leds;\n\tbool\t\t\tenabled;\n\tint\t\t\tnb_leds;\n\tunsigned int\t\t*levels;\n\tunsigned int\t\tdefault_brightness;\n\tunsigned int\t\tmax_brightness;\n};\n\nstatic void led_bl_set_brightness(struct led_bl_data *priv, int level)\n{\n\tint i;\n\tint bkl_brightness;\n\n\tif (priv->levels)\n\t\tbkl_brightness = priv->levels[level];\n\telse\n\t\tbkl_brightness = level;\n\n\tfor (i = 0; i < priv->nb_leds; i++)\n\t\tled_set_brightness(priv->leds[i], bkl_brightness);\n\n\tpriv->enabled = true;\n}\n\nstatic void led_bl_power_off(struct led_bl_data *priv)\n{\n\tint i;\n\n\tif (!priv->enabled)\n\t\treturn;\n\n\tfor (i = 0; i < priv->nb_leds; i++)\n\t\tled_set_brightness(priv->leds[i], LED_OFF);\n\n\tpriv->enabled = false;\n}\n\nstatic int led_bl_update_status(struct backlight_device *bl)\n{\n\tstruct led_bl_data *priv = bl_get_data(bl);\n\tint brightness = backlight_get_brightness(bl);\n\n\tif (brightness > 0)\n\t\tled_bl_set_brightness(priv, brightness);\n\telse\n\t\tled_bl_power_off(priv);\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops led_bl_ops = {\n\t.update_status\t= led_bl_update_status,\n};\n\nstatic int led_bl_get_leds(struct device *dev,\n\t\t\t   struct led_bl_data *priv)\n{\n\tint i, nb_leds, ret;\n\tstruct device_node *node = dev->of_node;\n\tstruct led_classdev **leds;\n\tunsigned int max_brightness;\n\tunsigned int default_brightness;\n\n\tret = of_count_phandle_with_args(node, \"leds\", NULL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unable to get led count\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnb_leds = ret;\n\tif (nb_leds < 1) {\n\t\tdev_err(dev, \"At least one LED must be specified!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tleds = devm_kzalloc(dev, sizeof(struct led_classdev *) * nb_leds,\n\t\t\t    GFP_KERNEL);\n\tif (!leds)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nb_leds; i++) {\n\t\tleds[i] = devm_of_led_get(dev, i);\n\t\tif (IS_ERR(leds[i]))\n\t\t\treturn PTR_ERR(leds[i]);\n\t}\n\n\t \n\tmax_brightness = leds[0]->max_brightness;\n\tfor (i = 1; i < nb_leds; i++) {\n\t\tif (max_brightness != leds[i]->max_brightness) {\n\t\t\tdev_err(dev, \"LEDs must have identical ranges\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tdefault_brightness = leds[0]->brightness;\n\n\tpriv->nb_leds = nb_leds;\n\tpriv->leds = leds;\n\tpriv->max_brightness = max_brightness;\n\tpriv->default_brightness = default_brightness;\n\n\treturn 0;\n}\n\nstatic int led_bl_parse_levels(struct device *dev,\n\t\t\t   struct led_bl_data *priv)\n{\n\tstruct device_node *node = dev->of_node;\n\tint num_levels;\n\tu32 value;\n\tint ret;\n\n\tif (!node)\n\t\treturn -ENODEV;\n\n\tnum_levels = of_property_count_u32_elems(node, \"brightness-levels\");\n\tif (num_levels > 1) {\n\t\tint i;\n\t\tunsigned int db;\n\t\tu32 *levels = NULL;\n\n\t\tlevels = devm_kzalloc(dev, sizeof(u32) * num_levels,\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!levels)\n\t\t\treturn -ENOMEM;\n\n\t\tret = of_property_read_u32_array(node, \"brightness-levels\",\n\t\t\t\t\t\tlevels,\n\t\t\t\t\t\tnum_levels);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tdb = priv->default_brightness;\n\t\tfor (i = 0 ; i < num_levels; i++) {\n\t\t\tif ((i && db > levels[i-1]) && db <= levels[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tpriv->default_brightness = i;\n\t\tpriv->max_brightness = num_levels - 1;\n\t\tpriv->levels = levels;\n\t} else if (num_levels >= 0)\n\t\tdev_warn(dev, \"Not enough levels defined\\n\");\n\n\tret = of_property_read_u32(node, \"default-brightness-level\", &value);\n\tif (!ret && value <= priv->max_brightness)\n\t\tpriv->default_brightness = value;\n\telse if (!ret  && value > priv->max_brightness)\n\t\tdev_warn(dev, \"Invalid default brightness. Ignoring it\\n\");\n\n\treturn 0;\n}\n\nstatic int led_bl_probe(struct platform_device *pdev)\n{\n\tstruct backlight_properties props;\n\tstruct led_bl_data *priv;\n\tint ret, i;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->dev = &pdev->dev;\n\n\tret = led_bl_get_leds(&pdev->dev, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = led_bl_parse_levels(&pdev->dev, priv);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to parse DT data\\n\");\n\t\treturn ret;\n\t}\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = priv->max_brightness;\n\tprops.brightness = priv->default_brightness;\n\tprops.power = (priv->default_brightness > 0) ? FB_BLANK_POWERDOWN :\n\t\t      FB_BLANK_UNBLANK;\n\tpriv->bl_dev = backlight_device_register(dev_name(&pdev->dev),\n\t\t\t&pdev->dev, priv, &led_bl_ops, &props);\n\tif (IS_ERR(priv->bl_dev)) {\n\t\tdev_err(&pdev->dev, \"Failed to register backlight\\n\");\n\t\treturn PTR_ERR(priv->bl_dev);\n\t}\n\n\tfor (i = 0; i < priv->nb_leds; i++) {\n\t\tmutex_lock(&priv->leds[i]->led_access);\n\t\tled_sysfs_disable(priv->leds[i]);\n\t\tmutex_unlock(&priv->leds[i]->led_access);\n\t}\n\n\tbacklight_update_status(priv->bl_dev);\n\n\treturn 0;\n}\n\nstatic void led_bl_remove(struct platform_device *pdev)\n{\n\tstruct led_bl_data *priv = platform_get_drvdata(pdev);\n\tstruct backlight_device *bl = priv->bl_dev;\n\tint i;\n\n\tbacklight_device_unregister(bl);\n\n\tled_bl_power_off(priv);\n\tfor (i = 0; i < priv->nb_leds; i++)\n\t\tled_sysfs_enable(priv->leds[i]);\n}\n\nstatic const struct of_device_id led_bl_of_match[] = {\n\t{ .compatible = \"led-backlight\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, led_bl_of_match);\n\nstatic struct platform_driver led_bl_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"led-backlight\",\n\t\t.of_match_table\t= led_bl_of_match,\n\t},\n\t.probe\t\t= led_bl_probe,\n\t.remove_new\t= led_bl_remove,\n};\n\nmodule_platform_driver(led_bl_driver);\n\nMODULE_DESCRIPTION(\"LED based Backlight Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:led-backlight\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}