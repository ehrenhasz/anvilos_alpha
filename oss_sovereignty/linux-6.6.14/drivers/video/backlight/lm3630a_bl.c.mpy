{
  "module_name": "lm3630a_bl.c",
  "hash_id": "6ca7b9489831510b599f980ea4a791b476a18025305af7c25b852cb42d5e6c27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/lm3630a_bl.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/backlight.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/interrupt.h>\n#include <linux/regmap.h>\n#include <linux/gpio/consumer.h>\n#include <linux/pwm.h>\n#include <linux/platform_data/lm3630a_bl.h>\n\n#define REG_CTRL\t0x00\n#define REG_BOOST\t0x02\n#define REG_CONFIG\t0x01\n#define REG_BRT_A\t0x03\n#define REG_BRT_B\t0x04\n#define REG_I_A\t\t0x05\n#define REG_I_B\t\t0x06\n#define REG_INT_STATUS\t0x09\n#define REG_INT_EN\t0x0A\n#define REG_FAULT\t0x0B\n#define REG_PWM_OUTLOW\t0x12\n#define REG_PWM_OUTHIGH\t0x13\n#define REG_FILTER_STRENGTH\t0x50\n#define REG_MAX\t\t0x50\n\n#define INT_DEBOUNCE_MSEC\t10\n\n#define LM3630A_BANK_0\t\t0\n#define LM3630A_BANK_1\t\t1\n\n#define LM3630A_NUM_SINKS\t2\n#define LM3630A_SINK_0\t\t0\n#define LM3630A_SINK_1\t\t1\n\nstruct lm3630a_chip {\n\tstruct device *dev;\n\tstruct delayed_work work;\n\n\tint irq;\n\tstruct workqueue_struct *irqthread;\n\tstruct lm3630a_platform_data *pdata;\n\tstruct backlight_device *bleda;\n\tstruct backlight_device *bledb;\n\tstruct gpio_desc *enable_gpio;\n\tstruct regmap *regmap;\n\tstruct pwm_device *pwmd;\n\tstruct pwm_state pwmd_state;\n};\n\n \nstatic int lm3630a_read(struct lm3630a_chip *pchip, unsigned int reg)\n{\n\tint rval;\n\tunsigned int reg_val;\n\n\trval = regmap_read(pchip->regmap, reg, &reg_val);\n\tif (rval < 0)\n\t\treturn rval;\n\treturn reg_val & 0xFF;\n}\n\nstatic int lm3630a_write(struct lm3630a_chip *pchip,\n\t\t\t unsigned int reg, unsigned int data)\n{\n\treturn regmap_write(pchip->regmap, reg, data);\n}\n\nstatic int lm3630a_update(struct lm3630a_chip *pchip,\n\t\t\t  unsigned int reg, unsigned int mask,\n\t\t\t  unsigned int data)\n{\n\treturn regmap_update_bits(pchip->regmap, reg, mask, data);\n}\n\n \nstatic int lm3630a_chip_init(struct lm3630a_chip *pchip)\n{\n\tint rval;\n\tstruct lm3630a_platform_data *pdata = pchip->pdata;\n\n\tusleep_range(1000, 2000);\n\t \n\trval = lm3630a_write(pchip, REG_FILTER_STRENGTH, 0x03);\n\t \n\trval |= lm3630a_update(pchip, REG_CONFIG, 0x07, pdata->pwm_ctrl);\n\t \n\trval |= lm3630a_write(pchip, REG_BOOST, 0x38);\n\t \n\trval |= lm3630a_update(pchip, REG_I_A, 0x1F, 0x1F);\n\t \n\trval |= lm3630a_write(pchip, REG_I_B, 0x1F);\n\t \n\trval |= lm3630a_update(pchip, REG_CTRL, 0x14, pdata->leda_ctrl);\n\trval |= lm3630a_update(pchip, REG_CTRL, 0x0B, pdata->ledb_ctrl);\n\tusleep_range(1000, 2000);\n\t \n\trval |= lm3630a_write(pchip, REG_BRT_A, pdata->leda_init_brt);\n\trval |= lm3630a_write(pchip, REG_BRT_B, pdata->ledb_init_brt);\n\n\tif (rval < 0)\n\t\tdev_err(pchip->dev, \"i2c failed to access register\\n\");\n\treturn rval;\n}\n\n \nstatic void lm3630a_delayed_func(struct work_struct *work)\n{\n\tint rval;\n\tstruct lm3630a_chip *pchip;\n\n\tpchip = container_of(work, struct lm3630a_chip, work.work);\n\n\trval = lm3630a_read(pchip, REG_INT_STATUS);\n\tif (rval < 0) {\n\t\tdev_err(pchip->dev,\n\t\t\t\"i2c failed to access REG_INT_STATUS Register\\n\");\n\t\treturn;\n\t}\n\n\tdev_info(pchip->dev, \"REG_INT_STATUS Register is 0x%x\\n\", rval);\n}\n\nstatic irqreturn_t lm3630a_isr_func(int irq, void *chip)\n{\n\tint rval;\n\tstruct lm3630a_chip *pchip = chip;\n\tunsigned long delay = msecs_to_jiffies(INT_DEBOUNCE_MSEC);\n\n\tqueue_delayed_work(pchip->irqthread, &pchip->work, delay);\n\n\trval = lm3630a_update(pchip, REG_CTRL, 0x80, 0x00);\n\tif (rval < 0) {\n\t\tdev_err(pchip->dev, \"i2c failed to access register\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int lm3630a_intr_config(struct lm3630a_chip *pchip)\n{\n\tint rval;\n\n\trval = lm3630a_write(pchip, REG_INT_EN, 0x87);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tINIT_DELAYED_WORK(&pchip->work, lm3630a_delayed_func);\n\tpchip->irqthread = create_singlethread_workqueue(\"lm3630a-irqthd\");\n\tif (!pchip->irqthread) {\n\t\tdev_err(pchip->dev, \"create irq thread fail\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (request_threaded_irq\n\t    (pchip->irq, NULL, lm3630a_isr_func,\n\t     IRQF_TRIGGER_FALLING | IRQF_ONESHOT, \"lm3630a_irq\", pchip)) {\n\t\tdev_err(pchip->dev, \"request threaded irq fail\\n\");\n\t\tdestroy_workqueue(pchip->irqthread);\n\t\treturn -ENOMEM;\n\t}\n\treturn rval;\n}\n\nstatic int lm3630a_pwm_ctrl(struct lm3630a_chip *pchip, int br, int br_max)\n{\n\tint err;\n\n\tpchip->pwmd_state.period = pchip->pdata->pwm_period;\n\n\terr = pwm_set_relative_duty_cycle(&pchip->pwmd_state, br, br_max);\n\tif (err)\n\t\treturn err;\n\n\tpchip->pwmd_state.enabled = pchip->pwmd_state.duty_cycle ? true : false;\n\n\treturn pwm_apply_state(pchip->pwmd, &pchip->pwmd_state);\n}\n\n \nstatic int lm3630a_bank_a_update_status(struct backlight_device *bl)\n{\n\tint ret;\n\tstruct lm3630a_chip *pchip = bl_get_data(bl);\n\tenum lm3630a_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;\n\n\t \n\tif ((pwm_ctrl & LM3630A_PWM_BANK_A) != 0)\n\t\treturn lm3630a_pwm_ctrl(pchip, bl->props.brightness,\n\t\t\t\t\tbl->props.max_brightness);\n\n\t \n\tret = lm3630a_update(pchip, REG_CTRL, 0x80, 0x00);\n\tif (ret < 0)\n\t\tgoto out_i2c_err;\n\tusleep_range(1000, 2000);\n\t \n\tret = lm3630a_write(pchip, REG_BRT_A, bl->props.brightness);\n\n\tif (backlight_is_blank(bl) || (backlight_get_brightness(bl) < 0x4))\n\t\t \n\t\tret |= lm3630a_update(pchip, REG_CTRL, LM3630A_LEDA_ENABLE, 0);\n\telse\n\t\tret |= lm3630a_update(pchip, REG_CTRL,\n\t\t\t\t      LM3630A_LEDA_ENABLE, LM3630A_LEDA_ENABLE);\n\tif (ret < 0)\n\t\tgoto out_i2c_err;\n\treturn 0;\n\nout_i2c_err:\n\tdev_err(pchip->dev, \"i2c failed to access (%pe)\\n\", ERR_PTR(ret));\n\treturn ret;\n}\n\nstatic int lm3630a_bank_a_get_brightness(struct backlight_device *bl)\n{\n\tint brightness, rval;\n\tstruct lm3630a_chip *pchip = bl_get_data(bl);\n\tenum lm3630a_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;\n\n\tif ((pwm_ctrl & LM3630A_PWM_BANK_A) != 0) {\n\t\trval = lm3630a_read(pchip, REG_PWM_OUTHIGH);\n\t\tif (rval < 0)\n\t\t\tgoto out_i2c_err;\n\t\tbrightness = (rval & 0x01) << 8;\n\t\trval = lm3630a_read(pchip, REG_PWM_OUTLOW);\n\t\tif (rval < 0)\n\t\t\tgoto out_i2c_err;\n\t\tbrightness |= rval;\n\t\tgoto out;\n\t}\n\n\t \n\trval = lm3630a_update(pchip, REG_CTRL, 0x80, 0x00);\n\tif (rval < 0)\n\t\tgoto out_i2c_err;\n\tusleep_range(1000, 2000);\n\trval = lm3630a_read(pchip, REG_BRT_A);\n\tif (rval < 0)\n\t\tgoto out_i2c_err;\n\tbrightness = rval;\n\nout:\n\tbl->props.brightness = brightness;\n\treturn bl->props.brightness;\nout_i2c_err:\n\tdev_err(pchip->dev, \"i2c failed to access register\\n\");\n\treturn 0;\n}\n\nstatic const struct backlight_ops lm3630a_bank_a_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.update_status = lm3630a_bank_a_update_status,\n\t.get_brightness = lm3630a_bank_a_get_brightness,\n};\n\n \nstatic int lm3630a_bank_b_update_status(struct backlight_device *bl)\n{\n\tint ret;\n\tstruct lm3630a_chip *pchip = bl_get_data(bl);\n\tenum lm3630a_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;\n\n\t \n\tif ((pwm_ctrl & LM3630A_PWM_BANK_B) != 0)\n\t\treturn lm3630a_pwm_ctrl(pchip, bl->props.brightness,\n\t\t\t\t\tbl->props.max_brightness);\n\n\t \n\tret = lm3630a_update(pchip, REG_CTRL, 0x80, 0x00);\n\tif (ret < 0)\n\t\tgoto out_i2c_err;\n\tusleep_range(1000, 2000);\n\t \n\tret = lm3630a_write(pchip, REG_BRT_B, bl->props.brightness);\n\n\tif (backlight_is_blank(bl) || (backlight_get_brightness(bl) < 0x4))\n\t\t \n\t\tret |= lm3630a_update(pchip, REG_CTRL, LM3630A_LEDB_ENABLE, 0);\n\telse\n\t\tret |= lm3630a_update(pchip, REG_CTRL,\n\t\t\t\t      LM3630A_LEDB_ENABLE, LM3630A_LEDB_ENABLE);\n\tif (ret < 0)\n\t\tgoto out_i2c_err;\n\treturn 0;\n\nout_i2c_err:\n\tdev_err(pchip->dev, \"i2c failed to access (%pe)\\n\", ERR_PTR(ret));\n\treturn ret;\n}\n\nstatic int lm3630a_bank_b_get_brightness(struct backlight_device *bl)\n{\n\tint brightness, rval;\n\tstruct lm3630a_chip *pchip = bl_get_data(bl);\n\tenum lm3630a_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;\n\n\tif ((pwm_ctrl & LM3630A_PWM_BANK_B) != 0) {\n\t\trval = lm3630a_read(pchip, REG_PWM_OUTHIGH);\n\t\tif (rval < 0)\n\t\t\tgoto out_i2c_err;\n\t\tbrightness = (rval & 0x01) << 8;\n\t\trval = lm3630a_read(pchip, REG_PWM_OUTLOW);\n\t\tif (rval < 0)\n\t\t\tgoto out_i2c_err;\n\t\tbrightness |= rval;\n\t\tgoto out;\n\t}\n\n\t \n\trval = lm3630a_update(pchip, REG_CTRL, 0x80, 0x00);\n\tif (rval < 0)\n\t\tgoto out_i2c_err;\n\tusleep_range(1000, 2000);\n\trval = lm3630a_read(pchip, REG_BRT_B);\n\tif (rval < 0)\n\t\tgoto out_i2c_err;\n\tbrightness = rval;\n\nout:\n\tbl->props.brightness = brightness;\n\treturn bl->props.brightness;\nout_i2c_err:\n\tdev_err(pchip->dev, \"i2c failed to access register\\n\");\n\treturn 0;\n}\n\nstatic const struct backlight_ops lm3630a_bank_b_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.update_status = lm3630a_bank_b_update_status,\n\t.get_brightness = lm3630a_bank_b_get_brightness,\n};\n\nstatic int lm3630a_backlight_register(struct lm3630a_chip *pchip)\n{\n\tstruct lm3630a_platform_data *pdata = pchip->pdata;\n\tstruct backlight_properties props;\n\tconst char *label;\n\n\tprops.type = BACKLIGHT_RAW;\n\tif (pdata->leda_ctrl != LM3630A_LEDA_DISABLE) {\n\t\tprops.brightness = pdata->leda_init_brt;\n\t\tprops.max_brightness = pdata->leda_max_brt;\n\t\tlabel = pdata->leda_label ? pdata->leda_label : \"lm3630a_leda\";\n\t\tpchip->bleda =\n\t\t    devm_backlight_device_register(pchip->dev, label,\n\t\t\t\t\t\t   pchip->dev, pchip,\n\t\t\t\t\t\t   &lm3630a_bank_a_ops, &props);\n\t\tif (IS_ERR(pchip->bleda))\n\t\t\treturn PTR_ERR(pchip->bleda);\n\t}\n\n\tif ((pdata->ledb_ctrl != LM3630A_LEDB_DISABLE) &&\n\t    (pdata->ledb_ctrl != LM3630A_LEDB_ON_A)) {\n\t\tprops.brightness = pdata->ledb_init_brt;\n\t\tprops.max_brightness = pdata->ledb_max_brt;\n\t\tlabel = pdata->ledb_label ? pdata->ledb_label : \"lm3630a_ledb\";\n\t\tpchip->bledb =\n\t\t    devm_backlight_device_register(pchip->dev, label,\n\t\t\t\t\t\t   pchip->dev, pchip,\n\t\t\t\t\t\t   &lm3630a_bank_b_ops, &props);\n\t\tif (IS_ERR(pchip->bledb))\n\t\t\treturn PTR_ERR(pchip->bledb);\n\t}\n\treturn 0;\n}\n\nstatic const struct regmap_config lm3630a_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = REG_MAX,\n};\n\nstatic int lm3630a_parse_led_sources(struct fwnode_handle *node,\n\t\t\t\t     int default_led_sources)\n{\n\tu32 sources[LM3630A_NUM_SINKS];\n\tint ret, num_sources, i;\n\n\tnum_sources = fwnode_property_count_u32(node, \"led-sources\");\n\tif (num_sources < 0)\n\t\treturn default_led_sources;\n\telse if (num_sources > ARRAY_SIZE(sources))\n\t\treturn -EINVAL;\n\n\tret = fwnode_property_read_u32_array(node, \"led-sources\", sources,\n\t\t\t\t\t     num_sources);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < num_sources; i++) {\n\t\tif (sources[i] != LM3630A_SINK_0 && sources[i] != LM3630A_SINK_1)\n\t\t\treturn -EINVAL;\n\n\t\tret |= BIT(sources[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic int lm3630a_parse_bank(struct lm3630a_platform_data *pdata,\n\t\t\t      struct fwnode_handle *node, int *seen_led_sources)\n{\n\tint led_sources, ret;\n\tconst char *label;\n\tu32 bank, val;\n\tbool linear;\n\n\tret = fwnode_property_read_u32(node, \"reg\", &bank);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bank != LM3630A_BANK_0 && bank != LM3630A_BANK_1)\n\t\treturn -EINVAL;\n\n\tled_sources = lm3630a_parse_led_sources(node, BIT(bank));\n\tif (led_sources < 0)\n\t\treturn led_sources;\n\n\tif (*seen_led_sources & led_sources)\n\t\treturn -EINVAL;\n\n\t*seen_led_sources |= led_sources;\n\n\tlinear = fwnode_property_read_bool(node,\n\t\t\t\t\t   \"ti,linear-mapping-mode\");\n\tif (bank) {\n\t\tif (led_sources & BIT(LM3630A_SINK_0) ||\n\t\t    !(led_sources & BIT(LM3630A_SINK_1)))\n\t\t\treturn -EINVAL;\n\n\t\tpdata->ledb_ctrl = linear ?\n\t\t\tLM3630A_LEDB_ENABLE_LINEAR :\n\t\t\tLM3630A_LEDB_ENABLE;\n\t} else {\n\t\tif (!(led_sources & BIT(LM3630A_SINK_0)))\n\t\t\treturn -EINVAL;\n\n\t\tpdata->leda_ctrl = linear ?\n\t\t\tLM3630A_LEDA_ENABLE_LINEAR :\n\t\t\tLM3630A_LEDA_ENABLE;\n\n\t\tif (led_sources & BIT(LM3630A_SINK_1))\n\t\t\tpdata->ledb_ctrl = LM3630A_LEDB_ON_A;\n\t}\n\n\tret = fwnode_property_read_string(node, \"label\", &label);\n\tif (!ret) {\n\t\tif (bank)\n\t\t\tpdata->ledb_label = label;\n\t\telse\n\t\t\tpdata->leda_label = label;\n\t}\n\n\tret = fwnode_property_read_u32(node, \"default-brightness\",\n\t\t\t\t       &val);\n\tif (!ret) {\n\t\tif (bank)\n\t\t\tpdata->ledb_init_brt = val;\n\t\telse\n\t\t\tpdata->leda_init_brt = val;\n\t}\n\n\tret = fwnode_property_read_u32(node, \"max-brightness\", &val);\n\tif (!ret) {\n\t\tif (bank)\n\t\t\tpdata->ledb_max_brt = val;\n\t\telse\n\t\t\tpdata->leda_max_brt = val;\n\t}\n\n\treturn 0;\n}\n\nstatic int lm3630a_parse_node(struct lm3630a_chip *pchip,\n\t\t\t      struct lm3630a_platform_data *pdata)\n{\n\tint ret = -ENODEV, seen_led_sources = 0;\n\tstruct fwnode_handle *node;\n\n\tdevice_for_each_child_node(pchip->dev, node) {\n\t\tret = lm3630a_parse_bank(pdata, node, &seen_led_sources);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(node);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int lm3630a_probe(struct i2c_client *client)\n{\n\tstruct lm3630a_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct lm3630a_chip *pchip;\n\tint rval;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"fail : i2c functionality check\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpchip = devm_kzalloc(&client->dev, sizeof(struct lm3630a_chip),\n\t\t\t     GFP_KERNEL);\n\tif (!pchip)\n\t\treturn -ENOMEM;\n\tpchip->dev = &client->dev;\n\n\tpchip->regmap = devm_regmap_init_i2c(client, &lm3630a_regmap);\n\tif (IS_ERR(pchip->regmap)) {\n\t\trval = PTR_ERR(pchip->regmap);\n\t\tdev_err(&client->dev, \"fail : allocate reg. map: %d\\n\", rval);\n\t\treturn rval;\n\t}\n\n\ti2c_set_clientdata(client, pchip);\n\tif (pdata == NULL) {\n\t\tpdata = devm_kzalloc(pchip->dev,\n\t\t\t\t     sizeof(struct lm3630a_platform_data),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (pdata == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tpdata->leda_max_brt = LM3630A_MAX_BRIGHTNESS;\n\t\tpdata->ledb_max_brt = LM3630A_MAX_BRIGHTNESS;\n\t\tpdata->leda_init_brt = LM3630A_MAX_BRIGHTNESS;\n\t\tpdata->ledb_init_brt = LM3630A_MAX_BRIGHTNESS;\n\n\t\trval = lm3630a_parse_node(pchip, pdata);\n\t\tif (rval) {\n\t\t\tdev_err(&client->dev, \"fail : parse node\\n\");\n\t\t\treturn rval;\n\t\t}\n\t}\n\tpchip->pdata = pdata;\n\n\tpchip->enable_gpio = devm_gpiod_get_optional(&client->dev, \"enable\",\n\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(pchip->enable_gpio)) {\n\t\trval = PTR_ERR(pchip->enable_gpio);\n\t\treturn rval;\n\t}\n\n\t \n\trval = lm3630a_chip_init(pchip);\n\tif (rval < 0) {\n\t\tdev_err(&client->dev, \"fail : init chip\\n\");\n\t\treturn rval;\n\t}\n\t \n\trval = lm3630a_backlight_register(pchip);\n\tif (rval < 0) {\n\t\tdev_err(&client->dev, \"fail : backlight register.\\n\");\n\t\treturn rval;\n\t}\n\t \n\tif (pdata->pwm_ctrl != LM3630A_PWM_DISABLE) {\n\t\tpchip->pwmd = devm_pwm_get(pchip->dev, \"lm3630a-pwm\");\n\t\tif (IS_ERR(pchip->pwmd)) {\n\t\t\tdev_err(&client->dev, \"fail : get pwm device\\n\");\n\t\t\treturn PTR_ERR(pchip->pwmd);\n\t\t}\n\n\t\tpwm_init_state(pchip->pwmd, &pchip->pwmd_state);\n\t}\n\n\t \n\tpchip->irq = client->irq;\n\tif (pchip->irq) {\n\t\trval = lm3630a_intr_config(pchip);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\t}\n\tdev_info(&client->dev, \"LM3630A backlight register OK.\\n\");\n\treturn 0;\n}\n\nstatic void lm3630a_remove(struct i2c_client *client)\n{\n\tint rval;\n\tstruct lm3630a_chip *pchip = i2c_get_clientdata(client);\n\n\trval = lm3630a_write(pchip, REG_BRT_A, 0);\n\tif (rval < 0)\n\t\tdev_err(pchip->dev, \"i2c failed to access register\\n\");\n\n\trval = lm3630a_write(pchip, REG_BRT_B, 0);\n\tif (rval < 0)\n\t\tdev_err(pchip->dev, \"i2c failed to access register\\n\");\n\n\tif (pchip->irq) {\n\t\tfree_irq(pchip->irq, pchip);\n\t\tdestroy_workqueue(pchip->irqthread);\n\t}\n}\n\nstatic const struct i2c_device_id lm3630a_id[] = {\n\t{LM3630A_NAME, 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, lm3630a_id);\n\nstatic const struct of_device_id lm3630a_match_table[] = {\n\t{ .compatible = \"ti,lm3630a\", },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, lm3630a_match_table);\n\nstatic struct i2c_driver lm3630a_i2c_driver = {\n\t.driver = {\n\t\t   .name = LM3630A_NAME,\n\t\t   .of_match_table = lm3630a_match_table,\n\t\t   },\n\t.probe = lm3630a_probe,\n\t.remove = lm3630a_remove,\n\t.id_table = lm3630a_id,\n};\n\nmodule_i2c_driver(lm3630a_i2c_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments Backlight driver for LM3630A\");\nMODULE_AUTHOR(\"Daniel Jeong <gshark.jeong@gmail.com>\");\nMODULE_AUTHOR(\"LDD MLP <ldd-mlp@list.ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}