{
  "module_name": "arcxcnn_bl.c",
  "hash_id": "74870bd7eb05714ae6d96bf4ab80528aba29d4cf82445d602bcc18fa24b72948",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/arcxcnn_bl.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\nenum arcxcnn_chip_id {\n\tARC2C0608\n};\n\n \nstruct arcxcnn_platform_data {\n\tconst char *name;\n\tu16 initial_brightness;\n\tu8\tleden;\n\tu8\tled_config_0;\n\tu8\tled_config_1;\n\tu8\tdim_freq;\n\tu8\tcomp_config;\n\tu8\tfilter_config;\n\tu8\ttrim_config;\n};\n\n#define ARCXCNN_CMD\t\t0x00\t \n#define ARCXCNN_CMD_STDBY\t0x80\t \n#define ARCXCNN_CMD_RESET\t0x40\t \n#define ARCXCNN_CMD_BOOST\t0x10\t \n#define ARCXCNN_CMD_OVP_MASK\t0x0C\t \n#define ARCXCNN_CMD_OVP_XXV\t0x0C\t \n#define ARCXCNN_CMD_OVP_20V\t0x08\t \n#define ARCXCNN_CMD_OVP_24V\t0x04\t \n#define ARCXCNN_CMD_OVP_31V\t0x00\t \n#define ARCXCNN_CMD_EXT_COMP\t0x01\t \n\n#define ARCXCNN_CONFIG\t\t0x01\t \n#define ARCXCNN_STATUS1\t\t0x02\t \n#define ARCXCNN_STATUS2\t\t0x03\t \n#define ARCXCNN_FADECTRL\t0x04\t \n#define ARCXCNN_ILED_CONFIG\t0x05\t \n#define ARCXCNN_ILED_DIM_PWM\t0x00\t \n#define ARCXCNN_ILED_DIM_INT\t0x04\t \n#define ARCXCNN_LEDEN\t\t0x06\t \n#define ARCXCNN_LEDEN_ISETEXT\t0x80\t \n#define ARCXCNN_LEDEN_MASK\t0x3F\t \n#define ARCXCNN_LEDEN_BITS\t0x06\t \n#define ARCXCNN_LEDEN_LED1\t0x01\n#define ARCXCNN_LEDEN_LED2\t0x02\n#define ARCXCNN_LEDEN_LED3\t0x04\n#define ARCXCNN_LEDEN_LED4\t0x08\n#define ARCXCNN_LEDEN_LED5\t0x10\n#define ARCXCNN_LEDEN_LED6\t0x20\n\n#define ARCXCNN_WLED_ISET_LSB\t0x07\t \n#define ARCXCNN_WLED_ISET_LSB_SHIFT 0x04   \n#define ARCXCNN_WLED_ISET_MSB\t0x08\t \n\n#define ARCXCNN_DIMFREQ\t\t0x09\n#define ARCXCNN_COMP_CONFIG\t0x0A\n#define ARCXCNN_FILT_CONFIG\t0x0B\n#define ARCXCNN_IMAXTUNE\t0x0C\n#define ARCXCNN_ID_MSB\t\t0x1E\n#define ARCXCNN_ID_LSB\t\t0x1F\n\n#define MAX_BRIGHTNESS\t\t4095\n#define INIT_BRIGHT\t\t60\n\nstruct arcxcnn {\n\tstruct i2c_client *client;\n\tstruct backlight_device *bl;\n\tstruct device *dev;\n\tstruct arcxcnn_platform_data *pdata;\n};\n\nstatic int arcxcnn_update_field(struct arcxcnn *lp, u8 reg, u8 mask, u8 data)\n{\n\tint ret;\n\tu8 tmp;\n\n\tret = i2c_smbus_read_byte_data(lp->client, reg);\n\tif (ret < 0) {\n\t\tdev_err(lp->dev, \"failed to read 0x%.2x\\n\", reg);\n\t\treturn ret;\n\t}\n\n\ttmp = (u8)ret;\n\ttmp &= ~mask;\n\ttmp |= data & mask;\n\n\treturn i2c_smbus_write_byte_data(lp->client, reg, tmp);\n}\n\nstatic int arcxcnn_set_brightness(struct arcxcnn *lp, u32 brightness)\n{\n\tint ret;\n\tu8 val;\n\n\t \n\tval = (brightness & 0xF) << ARCXCNN_WLED_ISET_LSB_SHIFT;\n\tret = i2c_smbus_write_byte_data(lp->client,\n\t\tARCXCNN_WLED_ISET_LSB, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval = (brightness >> 4);\n\treturn i2c_smbus_write_byte_data(lp->client,\n\t\tARCXCNN_WLED_ISET_MSB, val);\n}\n\nstatic int arcxcnn_bl_update_status(struct backlight_device *bl)\n{\n\tstruct arcxcnn *lp = bl_get_data(bl);\n\tu32 brightness = backlight_get_brightness(bl);\n\tint ret;\n\n\tret = arcxcnn_set_brightness(lp, brightness);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn arcxcnn_update_field(lp, ARCXCNN_CMD, ARCXCNN_CMD_STDBY,\n\t\t(bl->props.power == 0) ? 0 : ARCXCNN_CMD_STDBY);\n}\n\nstatic const struct backlight_ops arcxcnn_bl_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.update_status = arcxcnn_bl_update_status,\n};\n\nstatic int arcxcnn_backlight_register(struct arcxcnn *lp)\n{\n\tstruct backlight_properties *props;\n\tconst char *name = lp->pdata->name ? : \"arctic_bl\";\n\n\tprops = devm_kzalloc(lp->dev, sizeof(*props), GFP_KERNEL);\n\tif (!props)\n\t\treturn -ENOMEM;\n\n\tprops->type = BACKLIGHT_PLATFORM;\n\tprops->max_brightness = MAX_BRIGHTNESS;\n\n\tif (lp->pdata->initial_brightness > props->max_brightness)\n\t\tlp->pdata->initial_brightness = props->max_brightness;\n\n\tprops->brightness = lp->pdata->initial_brightness;\n\n\tlp->bl = devm_backlight_device_register(lp->dev, name, lp->dev, lp,\n\t\t\t\t       &arcxcnn_bl_ops, props);\n\treturn PTR_ERR_OR_ZERO(lp->bl);\n}\n\nstatic void arcxcnn_parse_dt(struct arcxcnn *lp)\n{\n\tstruct device *dev = lp->dev;\n\tstruct device_node *node = dev->of_node;\n\tu32 prog_val, num_entry, entry, sources[ARCXCNN_LEDEN_BITS];\n\tint ret;\n\n\t \n\tif (!node)\n\t\treturn;\n\n\tret = of_property_read_string(node, \"label\", &lp->pdata->name);\n\tif (ret < 0)\n\t\tlp->pdata->name = NULL;\n\n\tret = of_property_read_u32(node, \"default-brightness\", &prog_val);\n\tif (ret == 0)\n\t\tlp->pdata->initial_brightness = prog_val;\n\n\tret = of_property_read_u32(node, \"arc,led-config-0\", &prog_val);\n\tif (ret == 0)\n\t\tlp->pdata->led_config_0 = (u8)prog_val;\n\n\tret = of_property_read_u32(node, \"arc,led-config-1\", &prog_val);\n\tif (ret == 0)\n\t\tlp->pdata->led_config_1 = (u8)prog_val;\n\n\tret = of_property_read_u32(node, \"arc,dim-freq\", &prog_val);\n\tif (ret == 0)\n\t\tlp->pdata->dim_freq = (u8)prog_val;\n\n\tret = of_property_read_u32(node, \"arc,comp-config\", &prog_val);\n\tif (ret == 0)\n\t\tlp->pdata->comp_config = (u8)prog_val;\n\n\tret = of_property_read_u32(node, \"arc,filter-config\", &prog_val);\n\tif (ret == 0)\n\t\tlp->pdata->filter_config = (u8)prog_val;\n\n\tret = of_property_read_u32(node, \"arc,trim-config\", &prog_val);\n\tif (ret == 0)\n\t\tlp->pdata->trim_config = (u8)prog_val;\n\n\tret = of_property_count_u32_elems(node, \"led-sources\");\n\tif (ret < 0) {\n\t\tlp->pdata->leden = ARCXCNN_LEDEN_MASK;  \n\t} else {\n\t\tnum_entry = ret;\n\t\tif (num_entry > ARCXCNN_LEDEN_BITS)\n\t\t\tnum_entry = ARCXCNN_LEDEN_BITS;\n\n\t\tret = of_property_read_u32_array(node, \"led-sources\", sources,\n\t\t\t\t\tnum_entry);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"led-sources node is invalid.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tlp->pdata->leden = 0;\n\n\t\t \n\t\tfor (entry = 0; entry < num_entry; entry++) {\n\t\t\tu8 onbit = 1 << sources[entry];\n\n\t\t\tlp->pdata->leden |= onbit;\n\t\t}\n\t}\n}\n\nstatic int arcxcnn_probe(struct i2c_client *cl)\n{\n\tstruct arcxcnn *lp;\n\tint ret;\n\n\tif (!i2c_check_functionality(cl->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tlp = devm_kzalloc(&cl->dev, sizeof(*lp), GFP_KERNEL);\n\tif (!lp)\n\t\treturn -ENOMEM;\n\n\tlp->client = cl;\n\tlp->dev = &cl->dev;\n\tlp->pdata = dev_get_platdata(&cl->dev);\n\n\t \n\tret = i2c_smbus_write_byte_data(lp->client,\n\t\tARCXCNN_CMD, ARCXCNN_CMD_RESET);\n\tif (ret)\n\t\tgoto probe_err;\n\n\tif (!lp->pdata) {\n\t\tlp->pdata = devm_kzalloc(lp->dev,\n\t\t\t\tsizeof(*lp->pdata), GFP_KERNEL);\n\t\tif (!lp->pdata)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tlp->pdata->name = NULL;\n\t\tlp->pdata->initial_brightness = INIT_BRIGHT;\n\t\tlp->pdata->leden = ARCXCNN_LEDEN_MASK;\n\n\t\tlp->pdata->led_config_0 = i2c_smbus_read_byte_data(\n\t\t\tlp->client, ARCXCNN_FADECTRL);\n\n\t\tlp->pdata->led_config_1 = i2c_smbus_read_byte_data(\n\t\t\tlp->client, ARCXCNN_ILED_CONFIG);\n\t\t \n\t\tlp->pdata->led_config_1 |= ARCXCNN_ILED_DIM_INT;\n\n\t\tlp->pdata->dim_freq = i2c_smbus_read_byte_data(\n\t\t\tlp->client, ARCXCNN_DIMFREQ);\n\n\t\tlp->pdata->comp_config = i2c_smbus_read_byte_data(\n\t\t\tlp->client, ARCXCNN_COMP_CONFIG);\n\n\t\tlp->pdata->filter_config = i2c_smbus_read_byte_data(\n\t\t\tlp->client, ARCXCNN_FILT_CONFIG);\n\n\t\tlp->pdata->trim_config = i2c_smbus_read_byte_data(\n\t\t\tlp->client, ARCXCNN_IMAXTUNE);\n\n\t\tif (IS_ENABLED(CONFIG_OF))\n\t\t\tarcxcnn_parse_dt(lp);\n\t}\n\n\ti2c_set_clientdata(cl, lp);\n\n\t \n\tif (lp->pdata->initial_brightness > MAX_BRIGHTNESS)\n\t\tlp->pdata->initial_brightness = MAX_BRIGHTNESS;\n\n\t \n\tret = arcxcnn_set_brightness(lp, lp->pdata->initial_brightness);\n\tif (ret)\n\t\tgoto probe_err;\n\n\t \n\tret = i2c_smbus_write_byte_data(lp->client, ARCXCNN_FADECTRL,\n\t\tlp->pdata->led_config_0);\n\tif (ret)\n\t\tgoto probe_err;\n\n\tret = i2c_smbus_write_byte_data(lp->client, ARCXCNN_ILED_CONFIG,\n\t\tlp->pdata->led_config_1);\n\tif (ret)\n\t\tgoto probe_err;\n\n\tret = i2c_smbus_write_byte_data(lp->client, ARCXCNN_DIMFREQ,\n\t\tlp->pdata->dim_freq);\n\tif (ret)\n\t\tgoto probe_err;\n\n\tret = i2c_smbus_write_byte_data(lp->client, ARCXCNN_COMP_CONFIG,\n\t\tlp->pdata->comp_config);\n\tif (ret)\n\t\tgoto probe_err;\n\n\tret = i2c_smbus_write_byte_data(lp->client, ARCXCNN_FILT_CONFIG,\n\t\tlp->pdata->filter_config);\n\tif (ret)\n\t\tgoto probe_err;\n\n\tret = i2c_smbus_write_byte_data(lp->client, ARCXCNN_IMAXTUNE,\n\t\tlp->pdata->trim_config);\n\tif (ret)\n\t\tgoto probe_err;\n\n\t \n\tarcxcnn_update_field(lp, ARCXCNN_LEDEN,\n\t\tARCXCNN_LEDEN_MASK, lp->pdata->leden);\n\n\tret = arcxcnn_backlight_register(lp);\n\tif (ret)\n\t\tgoto probe_register_err;\n\n\tbacklight_update_status(lp->bl);\n\n\treturn 0;\n\nprobe_register_err:\n\tdev_err(lp->dev,\n\t\t\"failed to register backlight.\\n\");\n\nprobe_err:\n\tdev_err(lp->dev,\n\t\t\"failure ret: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void arcxcnn_remove(struct i2c_client *cl)\n{\n\tstruct arcxcnn *lp = i2c_get_clientdata(cl);\n\n\t \n\ti2c_smbus_write_byte_data(lp->client,\n\t\tARCXCNN_LEDEN, 0x00);\n\t \n\ti2c_smbus_write_byte_data(lp->client,\n\t\tARCXCNN_CMD, ARCXCNN_CMD_RESET);\n\n\tlp->bl->props.brightness = 0;\n\n\tbacklight_update_status(lp->bl);\n}\n\nstatic const struct of_device_id arcxcnn_dt_ids[] = {\n\t{ .compatible = \"arc,arc2c0608\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, arcxcnn_dt_ids);\n\nstatic const struct i2c_device_id arcxcnn_ids[] = {\n\t{\"arc2c0608\", ARC2C0608},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, arcxcnn_ids);\n\nstatic struct i2c_driver arcxcnn_driver = {\n\t.driver = {\n\t\t.name = \"arcxcnn_bl\",\n\t\t.of_match_table = arcxcnn_dt_ids,\n\t},\n\t.probe = arcxcnn_probe,\n\t.remove = arcxcnn_remove,\n\t.id_table = arcxcnn_ids,\n};\nmodule_i2c_driver(arcxcnn_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Brian Dodge <bdodge@arcticsand.com>\");\nMODULE_DESCRIPTION(\"ARCXCNN Backlight driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}