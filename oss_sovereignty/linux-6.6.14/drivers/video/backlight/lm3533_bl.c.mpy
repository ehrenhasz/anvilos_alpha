{
  "module_name": "lm3533_bl.c",
  "hash_id": "f76a6cc44ea555241fba51e6ca90644ab108de4bf9577531d678006d40ca7f6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/lm3533_bl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/backlight.h>\n#include <linux/fb.h>\n#include <linux/slab.h>\n\n#include <linux/mfd/lm3533.h>\n\n\n#define LM3533_HVCTRLBANK_COUNT\t\t2\n#define LM3533_BL_MAX_BRIGHTNESS\t255\n\n#define LM3533_REG_CTRLBANK_AB_BCONF\t0x1a\n\n\nstruct lm3533_bl {\n\tstruct lm3533 *lm3533;\n\tstruct lm3533_ctrlbank cb;\n\tstruct backlight_device *bd;\n\tint id;\n};\n\n\nstatic inline int lm3533_bl_get_ctrlbank_id(struct lm3533_bl *bl)\n{\n\treturn bl->id;\n}\n\nstatic int lm3533_bl_update_status(struct backlight_device *bd)\n{\n\tstruct lm3533_bl *bl = bl_get_data(bd);\n\n\treturn lm3533_ctrlbank_set_brightness(&bl->cb, backlight_get_brightness(bd));\n}\n\nstatic int lm3533_bl_get_brightness(struct backlight_device *bd)\n{\n\tstruct lm3533_bl *bl = bl_get_data(bd);\n\tu8 val;\n\tint ret;\n\n\tret = lm3533_ctrlbank_get_brightness(&bl->cb, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic const struct backlight_ops lm3533_bl_ops = {\n\t.get_brightness\t= lm3533_bl_get_brightness,\n\t.update_status\t= lm3533_bl_update_status,\n};\n\nstatic ssize_t show_id(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lm3533_bl *bl = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", bl->id);\n}\n\nstatic ssize_t show_als_channel(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lm3533_bl *bl = dev_get_drvdata(dev);\n\tunsigned channel = lm3533_bl_get_ctrlbank_id(bl);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", channel);\n}\n\nstatic ssize_t show_als_en(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lm3533_bl *bl = dev_get_drvdata(dev);\n\tint ctrlbank = lm3533_bl_get_ctrlbank_id(bl);\n\tu8 val;\n\tu8 mask;\n\tbool enable;\n\tint ret;\n\n\tret = lm3533_read(bl->lm3533, LM3533_REG_CTRLBANK_AB_BCONF, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmask = 1 << (2 * ctrlbank);\n\tenable = val & mask;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", enable);\n}\n\nstatic ssize_t store_als_en(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct lm3533_bl *bl = dev_get_drvdata(dev);\n\tint ctrlbank = lm3533_bl_get_ctrlbank_id(bl);\n\tint enable;\n\tu8 val;\n\tu8 mask;\n\tint ret;\n\n\tif (kstrtoint(buf, 0, &enable))\n\t\treturn -EINVAL;\n\n\tmask = 1 << (2 * ctrlbank);\n\n\tif (enable)\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\tret = lm3533_update(bl->lm3533, LM3533_REG_CTRLBANK_AB_BCONF, val,\n\t\t\t\t\t\t\t\t\tmask);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t show_linear(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lm3533_bl *bl = dev_get_drvdata(dev);\n\tu8 val;\n\tu8 mask;\n\tint linear;\n\tint ret;\n\n\tret = lm3533_read(bl->lm3533, LM3533_REG_CTRLBANK_AB_BCONF, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmask = 1 << (2 * lm3533_bl_get_ctrlbank_id(bl) + 1);\n\n\tif (val & mask)\n\t\tlinear = 1;\n\telse\n\t\tlinear = 0;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%x\\n\", linear);\n}\n\nstatic ssize_t store_linear(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct lm3533_bl *bl = dev_get_drvdata(dev);\n\tunsigned long linear;\n\tu8 mask;\n\tu8 val;\n\tint ret;\n\n\tif (kstrtoul(buf, 0, &linear))\n\t\treturn -EINVAL;\n\n\tmask = 1 << (2 * lm3533_bl_get_ctrlbank_id(bl) + 1);\n\n\tif (linear)\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\tret = lm3533_update(bl->lm3533, LM3533_REG_CTRLBANK_AB_BCONF, val,\n\t\t\t\t\t\t\t\t\tmask);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t show_pwm(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct lm3533_bl *bl = dev_get_drvdata(dev);\n\tu8 val;\n\tint ret;\n\n\tret = lm3533_ctrlbank_get_pwm(&bl->cb, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", val);\n}\n\nstatic ssize_t store_pwm(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct lm3533_bl *bl = dev_get_drvdata(dev);\n\tu8 val;\n\tint ret;\n\n\tif (kstrtou8(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tret = lm3533_ctrlbank_set_pwm(&bl->cb, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic LM3533_ATTR_RO(als_channel);\nstatic LM3533_ATTR_RW(als_en);\nstatic LM3533_ATTR_RO(id);\nstatic LM3533_ATTR_RW(linear);\nstatic LM3533_ATTR_RW(pwm);\n\nstatic struct attribute *lm3533_bl_attributes[] = {\n\t&dev_attr_als_channel.attr,\n\t&dev_attr_als_en.attr,\n\t&dev_attr_id.attr,\n\t&dev_attr_linear.attr,\n\t&dev_attr_pwm.attr,\n\tNULL,\n};\n\nstatic umode_t lm3533_bl_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct lm3533_bl *bl = dev_get_drvdata(dev);\n\tumode_t mode = attr->mode;\n\n\tif (attr == &dev_attr_als_channel.attr ||\n\t\t\t\t\tattr == &dev_attr_als_en.attr) {\n\t\tif (!bl->lm3533->have_als)\n\t\t\tmode = 0;\n\t}\n\n\treturn mode;\n};\n\nstatic struct attribute_group lm3533_bl_attribute_group = {\n\t.is_visible\t= lm3533_bl_attr_is_visible,\n\t.attrs\t\t= lm3533_bl_attributes\n};\n\nstatic int lm3533_bl_setup(struct lm3533_bl *bl,\n\t\t\t\t\tstruct lm3533_bl_platform_data *pdata)\n{\n\tint ret;\n\n\tret = lm3533_ctrlbank_set_max_current(&bl->cb, pdata->max_current);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lm3533_ctrlbank_set_pwm(&bl->cb, pdata->pwm);\n}\n\nstatic int lm3533_bl_probe(struct platform_device *pdev)\n{\n\tstruct lm3533 *lm3533;\n\tstruct lm3533_bl_platform_data *pdata;\n\tstruct lm3533_bl *bl;\n\tstruct backlight_device *bd;\n\tstruct backlight_properties props;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\tlm3533 = dev_get_drvdata(pdev->dev.parent);\n\tif (!lm3533)\n\t\treturn -EINVAL;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdev->id < 0 || pdev->id >= LM3533_HVCTRLBANK_COUNT) {\n\t\tdev_err(&pdev->dev, \"illegal backlight id %d\\n\", pdev->id);\n\t\treturn -EINVAL;\n\t}\n\n\tbl = devm_kzalloc(&pdev->dev, sizeof(*bl), GFP_KERNEL);\n\tif (!bl)\n\t\treturn -ENOMEM;\n\n\tbl->lm3533 = lm3533;\n\tbl->id = pdev->id;\n\n\tbl->cb.lm3533 = lm3533;\n\tbl->cb.id = lm3533_bl_get_ctrlbank_id(bl);\n\tbl->cb.dev = NULL;\t\t\t \n\n\tmemset(&props, 0, sizeof(props));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = LM3533_BL_MAX_BRIGHTNESS;\n\tprops.brightness = pdata->default_brightness;\n\tbd = devm_backlight_device_register(&pdev->dev, pdata->name,\n\t\t\t\t\tpdev->dev.parent, bl, &lm3533_bl_ops,\n\t\t\t\t\t&props);\n\tif (IS_ERR(bd)) {\n\t\tdev_err(&pdev->dev, \"failed to register backlight device\\n\");\n\t\treturn PTR_ERR(bd);\n\t}\n\n\tbl->bd = bd;\n\tbl->cb.dev = &bl->bd->dev;\n\n\tplatform_set_drvdata(pdev, bl);\n\n\tret = sysfs_create_group(&bd->dev.kobj, &lm3533_bl_attribute_group);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to create sysfs attributes\\n\");\n\t\treturn ret;\n\t}\n\n\tbacklight_update_status(bd);\n\n\tret = lm3533_bl_setup(bl, pdata);\n\tif (ret)\n\t\tgoto err_sysfs_remove;\n\n\tret = lm3533_ctrlbank_enable(&bl->cb);\n\tif (ret)\n\t\tgoto err_sysfs_remove;\n\n\treturn 0;\n\nerr_sysfs_remove:\n\tsysfs_remove_group(&bd->dev.kobj, &lm3533_bl_attribute_group);\n\n\treturn ret;\n}\n\nstatic void lm3533_bl_remove(struct platform_device *pdev)\n{\n\tstruct lm3533_bl *bl = platform_get_drvdata(pdev);\n\tstruct backlight_device *bd = bl->bd;\n\n\tdev_dbg(&bd->dev, \"%s\\n\", __func__);\n\n\tbd->props.power = FB_BLANK_POWERDOWN;\n\tbd->props.brightness = 0;\n\n\tlm3533_ctrlbank_disable(&bl->cb);\n\tsysfs_remove_group(&bd->dev.kobj, &lm3533_bl_attribute_group);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int lm3533_bl_suspend(struct device *dev)\n{\n\tstruct lm3533_bl *bl = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\treturn lm3533_ctrlbank_disable(&bl->cb);\n}\n\nstatic int lm3533_bl_resume(struct device *dev)\n{\n\tstruct lm3533_bl *bl = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\treturn lm3533_ctrlbank_enable(&bl->cb);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(lm3533_bl_pm_ops, lm3533_bl_suspend, lm3533_bl_resume);\n\nstatic void lm3533_bl_shutdown(struct platform_device *pdev)\n{\n\tstruct lm3533_bl *bl = platform_get_drvdata(pdev);\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\tlm3533_ctrlbank_disable(&bl->cb);\n}\n\nstatic struct platform_driver lm3533_bl_driver = {\n\t.driver = {\n\t\t.name\t= \"lm3533-backlight\",\n\t\t.pm\t= &lm3533_bl_pm_ops,\n\t},\n\t.probe\t\t= lm3533_bl_probe,\n\t.remove_new\t= lm3533_bl_remove,\n\t.shutdown\t= lm3533_bl_shutdown,\n};\nmodule_platform_driver(lm3533_bl_driver);\n\nMODULE_AUTHOR(\"Johan Hovold <jhovold@gmail.com>\");\nMODULE_DESCRIPTION(\"LM3533 Backlight driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:lm3533-backlight\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}