{
  "module_name": "adp5520_bl.c",
  "hash_id": "0f37e7bef32330dfc948996e94bd43b4d2ba0e1798ec18b7803cddf6e12723a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/adp5520_bl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/fb.h>\n#include <linux/backlight.h>\n#include <linux/mfd/adp5520.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct adp5520_bl {\n\tstruct device *master;\n\tstruct adp5520_backlight_platform_data *pdata;\n\tstruct mutex lock;\n\tunsigned long cached_daylight_max;\n\tint id;\n\tint current_brightness;\n};\n\nstatic int adp5520_bl_set(struct backlight_device *bl, int brightness)\n{\n\tstruct adp5520_bl *data = bl_get_data(bl);\n\tstruct device *master = data->master;\n\tint ret = 0;\n\n\tif (data->pdata->en_ambl_sens) {\n\t\tif ((brightness > 0) && (brightness < ADP5020_MAX_BRIGHTNESS)) {\n\t\t\t \n\t\t\tret |= adp5520_clr_bits(master, ADP5520_BL_CONTROL,\n\t\t\t\t\tADP5520_BL_AUTO_ADJ);\n\t\t\tret |= adp5520_write(master, ADP5520_DAYLIGHT_MAX,\n\t\t\t\t\tbrightness);\n\t\t} else {\n\t\t\t \n\t\t\tret |= adp5520_write(master, ADP5520_DAYLIGHT_MAX,\n\t\t\t\t\t data->cached_daylight_max);\n\t\t\tret |= adp5520_set_bits(master, ADP5520_BL_CONTROL,\n\t\t\t\t\t ADP5520_BL_AUTO_ADJ);\n\t\t}\n\t} else {\n\t\tret |= adp5520_write(master, ADP5520_DAYLIGHT_MAX, brightness);\n\t}\n\n\tif (data->current_brightness && brightness == 0)\n\t\tret |= adp5520_set_bits(master,\n\t\t\t\tADP5520_MODE_STATUS, ADP5520_DIM_EN);\n\telse if (data->current_brightness == 0 && brightness)\n\t\tret |= adp5520_clr_bits(master,\n\t\t\t\tADP5520_MODE_STATUS, ADP5520_DIM_EN);\n\n\tif (!ret)\n\t\tdata->current_brightness = brightness;\n\n\treturn ret;\n}\n\nstatic int adp5520_bl_update_status(struct backlight_device *bl)\n{\n\treturn adp5520_bl_set(bl, backlight_get_brightness(bl));\n}\n\nstatic int adp5520_bl_get_brightness(struct backlight_device *bl)\n{\n\tstruct adp5520_bl *data = bl_get_data(bl);\n\tint error;\n\tuint8_t reg_val;\n\n\terror = adp5520_read(data->master, ADP5520_BL_VALUE, &reg_val);\n\n\treturn error ? data->current_brightness : reg_val;\n}\n\nstatic const struct backlight_ops adp5520_bl_ops = {\n\t.update_status\t= adp5520_bl_update_status,\n\t.get_brightness\t= adp5520_bl_get_brightness,\n};\n\nstatic int adp5520_bl_setup(struct backlight_device *bl)\n{\n\tstruct adp5520_bl *data = bl_get_data(bl);\n\tstruct device *master = data->master;\n\tstruct adp5520_backlight_platform_data *pdata = data->pdata;\n\tint ret = 0;\n\n\tret |= adp5520_write(master, ADP5520_DAYLIGHT_MAX,\n\t\t\t\tpdata->l1_daylight_max);\n\tret |= adp5520_write(master, ADP5520_DAYLIGHT_DIM,\n\t\t\t\tpdata->l1_daylight_dim);\n\n\tif (pdata->en_ambl_sens) {\n\t\tdata->cached_daylight_max = pdata->l1_daylight_max;\n\t\tret |= adp5520_write(master, ADP5520_OFFICE_MAX,\n\t\t\t\tpdata->l2_office_max);\n\t\tret |= adp5520_write(master, ADP5520_OFFICE_DIM,\n\t\t\t\tpdata->l2_office_dim);\n\t\tret |= adp5520_write(master, ADP5520_DARK_MAX,\n\t\t\t\tpdata->l3_dark_max);\n\t\tret |= adp5520_write(master, ADP5520_DARK_DIM,\n\t\t\t\tpdata->l3_dark_dim);\n\t\tret |= adp5520_write(master, ADP5520_L2_TRIP,\n\t\t\t\tpdata->l2_trip);\n\t\tret |= adp5520_write(master, ADP5520_L2_HYS,\n\t\t\t\tpdata->l2_hyst);\n\t\tret |= adp5520_write(master, ADP5520_L3_TRIP,\n\t\t\t\t pdata->l3_trip);\n\t\tret |= adp5520_write(master, ADP5520_L3_HYS,\n\t\t\t\tpdata->l3_hyst);\n\t\tret |= adp5520_write(master, ADP5520_ALS_CMPR_CFG,\n\t\t\t\tALS_CMPR_CFG_VAL(pdata->abml_filt,\n\t\t\t\tADP5520_L3_EN));\n\t}\n\n\tret |= adp5520_write(master, ADP5520_BL_CONTROL,\n\t\t\tBL_CTRL_VAL(pdata->fade_led_law,\n\t\t\t\t\tpdata->en_ambl_sens));\n\n\tret |= adp5520_write(master, ADP5520_BL_FADE, FADE_VAL(pdata->fade_in,\n\t\t\tpdata->fade_out));\n\n\tret |= adp5520_set_bits(master, ADP5520_MODE_STATUS,\n\t\t\tADP5520_BL_EN | ADP5520_DIM_EN);\n\n\treturn ret;\n}\n\nstatic ssize_t adp5520_show(struct device *dev, char *buf, int reg)\n{\n\tstruct adp5520_bl *data = dev_get_drvdata(dev);\n\tint ret;\n\tuint8_t reg_val;\n\n\tmutex_lock(&data->lock);\n\tret = adp5520_read(data->master, reg, &reg_val);\n\tmutex_unlock(&data->lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%u\\n\", reg_val);\n}\n\nstatic ssize_t adp5520_store(struct device *dev, const char *buf,\n\t\t\t size_t count, int reg)\n{\n\tstruct adp5520_bl *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&data->lock);\n\tadp5520_write(data->master, reg, val);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t adp5520_bl_dark_max_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp5520_show(dev, buf, ADP5520_DARK_MAX);\n}\n\nstatic ssize_t adp5520_bl_dark_max_store(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\treturn adp5520_store(dev, buf, count, ADP5520_DARK_MAX);\n}\nstatic DEVICE_ATTR(dark_max, 0664, adp5520_bl_dark_max_show,\n\t\t\tadp5520_bl_dark_max_store);\n\nstatic ssize_t adp5520_bl_office_max_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp5520_show(dev, buf, ADP5520_OFFICE_MAX);\n}\n\nstatic ssize_t adp5520_bl_office_max_store(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\treturn adp5520_store(dev, buf, count, ADP5520_OFFICE_MAX);\n}\nstatic DEVICE_ATTR(office_max, 0664, adp5520_bl_office_max_show,\n\t\t\tadp5520_bl_office_max_store);\n\nstatic ssize_t adp5520_bl_daylight_max_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp5520_show(dev, buf, ADP5520_DAYLIGHT_MAX);\n}\n\nstatic ssize_t adp5520_bl_daylight_max_store(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct adp5520_bl *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &data->cached_daylight_max);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn adp5520_store(dev, buf, count, ADP5520_DAYLIGHT_MAX);\n}\nstatic DEVICE_ATTR(daylight_max, 0664, adp5520_bl_daylight_max_show,\n\t\t\tadp5520_bl_daylight_max_store);\n\nstatic ssize_t adp5520_bl_dark_dim_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp5520_show(dev, buf, ADP5520_DARK_DIM);\n}\n\nstatic ssize_t adp5520_bl_dark_dim_store(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\treturn adp5520_store(dev, buf, count, ADP5520_DARK_DIM);\n}\nstatic DEVICE_ATTR(dark_dim, 0664, adp5520_bl_dark_dim_show,\n\t\t\tadp5520_bl_dark_dim_store);\n\nstatic ssize_t adp5520_bl_office_dim_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp5520_show(dev, buf, ADP5520_OFFICE_DIM);\n}\n\nstatic ssize_t adp5520_bl_office_dim_store(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\treturn adp5520_store(dev, buf, count, ADP5520_OFFICE_DIM);\n}\nstatic DEVICE_ATTR(office_dim, 0664, adp5520_bl_office_dim_show,\n\t\t\tadp5520_bl_office_dim_store);\n\nstatic ssize_t adp5520_bl_daylight_dim_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp5520_show(dev, buf, ADP5520_DAYLIGHT_DIM);\n}\n\nstatic ssize_t adp5520_bl_daylight_dim_store(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\treturn adp5520_store(dev, buf, count, ADP5520_DAYLIGHT_DIM);\n}\nstatic DEVICE_ATTR(daylight_dim, 0664, adp5520_bl_daylight_dim_show,\n\t\t\tadp5520_bl_daylight_dim_store);\n\nstatic struct attribute *adp5520_bl_attributes[] = {\n\t&dev_attr_dark_max.attr,\n\t&dev_attr_dark_dim.attr,\n\t&dev_attr_office_max.attr,\n\t&dev_attr_office_dim.attr,\n\t&dev_attr_daylight_max.attr,\n\t&dev_attr_daylight_dim.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adp5520_bl_attr_group = {\n\t.attrs = adp5520_bl_attributes,\n};\n\nstatic int adp5520_bl_probe(struct platform_device *pdev)\n{\n\tstruct backlight_properties props;\n\tstruct backlight_device *bl;\n\tstruct adp5520_bl *data;\n\tint ret = 0;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tdata->master = pdev->dev.parent;\n\tdata->pdata = dev_get_platdata(&pdev->dev);\n\n\tif (data->pdata  == NULL) {\n\t\tdev_err(&pdev->dev, \"missing platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata->id = pdev->id;\n\tdata->current_brightness = 0;\n\n\tmutex_init(&data->lock);\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = ADP5020_MAX_BRIGHTNESS;\n\tbl = devm_backlight_device_register(&pdev->dev, pdev->name,\n\t\t\t\t\tdata->master, data, &adp5520_bl_ops,\n\t\t\t\t\t&props);\n\tif (IS_ERR(bl)) {\n\t\tdev_err(&pdev->dev, \"failed to register backlight\\n\");\n\t\treturn PTR_ERR(bl);\n\t}\n\n\tbl->props.brightness = ADP5020_MAX_BRIGHTNESS;\n\tif (data->pdata->en_ambl_sens)\n\t\tret = sysfs_create_group(&bl->dev.kobj,\n\t\t\t&adp5520_bl_attr_group);\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register sysfs\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, bl);\n\tret = adp5520_bl_setup(bl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to setup\\n\");\n\t\tif (data->pdata->en_ambl_sens)\n\t\t\tsysfs_remove_group(&bl->dev.kobj,\n\t\t\t\t\t&adp5520_bl_attr_group);\n\t\treturn ret;\n\t}\n\n\tbacklight_update_status(bl);\n\n\treturn 0;\n}\n\nstatic void adp5520_bl_remove(struct platform_device *pdev)\n{\n\tstruct backlight_device *bl = platform_get_drvdata(pdev);\n\tstruct adp5520_bl *data = bl_get_data(bl);\n\n\tadp5520_clr_bits(data->master, ADP5520_MODE_STATUS, ADP5520_BL_EN);\n\n\tif (data->pdata->en_ambl_sens)\n\t\tsysfs_remove_group(&bl->dev.kobj,\n\t\t\t\t&adp5520_bl_attr_group);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int adp5520_bl_suspend(struct device *dev)\n{\n\tstruct backlight_device *bl = dev_get_drvdata(dev);\n\n\treturn adp5520_bl_set(bl, 0);\n}\n\nstatic int adp5520_bl_resume(struct device *dev)\n{\n\tstruct backlight_device *bl = dev_get_drvdata(dev);\n\n\tbacklight_update_status(bl);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(adp5520_bl_pm_ops, adp5520_bl_suspend,\n\t\t\tadp5520_bl_resume);\n\nstatic struct platform_driver adp5520_bl_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"adp5520-backlight\",\n\t\t.pm\t= &adp5520_bl_pm_ops,\n\t},\n\t.probe\t\t= adp5520_bl_probe,\n\t.remove_new\t= adp5520_bl_remove,\n};\n\nmodule_platform_driver(adp5520_bl_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"ADP5520(01) Backlight Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:adp5520-backlight\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}