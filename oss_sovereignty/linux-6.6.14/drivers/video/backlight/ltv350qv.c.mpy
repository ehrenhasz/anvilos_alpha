{
  "module_name": "ltv350qv.c",
  "hash_id": "4abedeb044a6ba3a85cb57c72c20a91d485d56e255250e788470de8c96dc7c02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/ltv350qv.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/lcd.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n\n#include \"ltv350qv.h\"\n\n#define POWER_IS_ON(pwr)\t((pwr) <= FB_BLANK_NORMAL)\n\nstruct ltv350qv {\n\tstruct spi_device\t*spi;\n\tu8\t\t\t*buffer;\n\tint\t\t\tpower;\n\tstruct lcd_device\t*ld;\n};\n\n \nstatic int ltv350qv_write_reg(struct ltv350qv *lcd, u8 reg, u16 val)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer index_xfer = {\n\t\t.len\t\t= 3,\n\t\t.cs_change\t= 1,\n\t};\n\tstruct spi_transfer value_xfer = {\n\t\t.len\t\t= 3,\n\t};\n\n\tspi_message_init(&msg);\n\n\t \n\tlcd->buffer[0] = LTV_OPC_INDEX;\n\tlcd->buffer[1] = 0x00;\n\tlcd->buffer[2] = reg & 0x7f;\n\tindex_xfer.tx_buf = lcd->buffer;\n\tspi_message_add_tail(&index_xfer, &msg);\n\n\t \n\tlcd->buffer[4] = LTV_OPC_DATA;\n\tlcd->buffer[5] = val >> 8;\n\tlcd->buffer[6] = val;\n\tvalue_xfer.tx_buf = lcd->buffer + 4;\n\tspi_message_add_tail(&value_xfer, &msg);\n\n\treturn spi_sync(lcd->spi, &msg);\n}\n\n \nstatic int ltv350qv_power_on(struct ltv350qv *lcd)\n{\n\tint ret;\n\n\t \n\tif (ltv350qv_write_reg(lcd, LTV_PWRCTL1, 0x0000))\n\t\tgoto err;\n\tusleep_range(15000, 16000);\n\n\t \n\tif (ltv350qv_write_reg(lcd, LTV_PWRCTL1, LTV_VCOM_DISABLE))\n\t\tgoto err;\n\tif (ltv350qv_write_reg(lcd, LTV_PWRCTL2, LTV_VCOML_ENABLE))\n\t\tgoto err_power1;\n\n\t \n\tif (ltv350qv_write_reg(lcd, LTV_PWRCTL1,\n\t\t\t       LTV_VCOM_DISABLE | LTV_DRIVE_CURRENT(5)\n\t\t\t       | LTV_SUPPLY_CURRENT(5)))\n\t\tgoto err_power2;\n\n\tmsleep(55);\n\n\t \n\tret = ltv350qv_write_reg(lcd, LTV_IFCTL,\n\t\t\t\t LTV_NMD | LTV_REV | LTV_NL(0x1d));\n\tret |= ltv350qv_write_reg(lcd, LTV_DATACTL,\n\t\t\t\t  LTV_DS_SAME | LTV_CHS_480\n\t\t\t\t  | LTV_DF_RGB | LTV_RGB_BGR);\n\tret |= ltv350qv_write_reg(lcd, LTV_ENTRY_MODE,\n\t\t\t\t  LTV_VSPL_ACTIVE_LOW\n\t\t\t\t  | LTV_HSPL_ACTIVE_LOW\n\t\t\t\t  | LTV_DPL_SAMPLE_RISING\n\t\t\t\t  | LTV_EPL_ACTIVE_LOW\n\t\t\t\t  | LTV_SS_RIGHT_TO_LEFT);\n\tret |= ltv350qv_write_reg(lcd, LTV_GATECTL1, LTV_CLW(3));\n\tret |= ltv350qv_write_reg(lcd, LTV_GATECTL2,\n\t\t\t\t  LTV_NW_INV_1LINE | LTV_FWI(3));\n\tret |= ltv350qv_write_reg(lcd, LTV_VBP, 0x000a);\n\tret |= ltv350qv_write_reg(lcd, LTV_HBP, 0x0021);\n\tret |= ltv350qv_write_reg(lcd, LTV_SOTCTL, LTV_SDT(3) | LTV_EQ(0));\n\tret |= ltv350qv_write_reg(lcd, LTV_GAMMA(0), 0x0103);\n\tret |= ltv350qv_write_reg(lcd, LTV_GAMMA(1), 0x0301);\n\tret |= ltv350qv_write_reg(lcd, LTV_GAMMA(2), 0x1f0f);\n\tret |= ltv350qv_write_reg(lcd, LTV_GAMMA(3), 0x1f0f);\n\tret |= ltv350qv_write_reg(lcd, LTV_GAMMA(4), 0x0707);\n\tret |= ltv350qv_write_reg(lcd, LTV_GAMMA(5), 0x0307);\n\tret |= ltv350qv_write_reg(lcd, LTV_GAMMA(6), 0x0707);\n\tret |= ltv350qv_write_reg(lcd, LTV_GAMMA(7), 0x0000);\n\tret |= ltv350qv_write_reg(lcd, LTV_GAMMA(8), 0x0004);\n\tret |= ltv350qv_write_reg(lcd, LTV_GAMMA(9), 0x0000);\n\tif (ret)\n\t\tgoto err_settings;\n\n\t \n\tmsleep(20);\n\n\t \n\tret = ltv350qv_write_reg(lcd, LTV_PWRCTL1,\n\t\t\t\t LTV_VCOM_DISABLE | LTV_VCOMOUT_ENABLE\n\t\t\t\t | LTV_POWER_ON | LTV_DRIVE_CURRENT(5)\n\t\t\t\t | LTV_SUPPLY_CURRENT(5));\n\tret |= ltv350qv_write_reg(lcd, LTV_GATECTL2,\n\t\t\t\t  LTV_NW_INV_1LINE | LTV_DSC | LTV_FWI(3));\n\tif (ret)\n\t\tgoto err_disp_on;\n\n\t \n\treturn 0;\n\nerr_disp_on:\n\t \n\tltv350qv_write_reg(lcd, LTV_PWRCTL1,\n\t\t\t   LTV_VCOM_DISABLE | LTV_DRIVE_CURRENT(5)\n\t\t\t   | LTV_SUPPLY_CURRENT(5));\n\tltv350qv_write_reg(lcd, LTV_GATECTL2,\n\t\t\t   LTV_NW_INV_1LINE | LTV_FWI(3));\nerr_settings:\nerr_power2:\nerr_power1:\n\tltv350qv_write_reg(lcd, LTV_PWRCTL2, 0x0000);\n\tusleep_range(1000, 1100);\nerr:\n\tltv350qv_write_reg(lcd, LTV_PWRCTL1, LTV_VCOM_DISABLE);\n\treturn -EIO;\n}\n\nstatic int ltv350qv_power_off(struct ltv350qv *lcd)\n{\n\tint ret;\n\n\t \n\tret = ltv350qv_write_reg(lcd, LTV_PWRCTL1,\n\t\t\t\t LTV_VCOM_DISABLE\n\t\t\t\t | LTV_DRIVE_CURRENT(5)\n\t\t\t\t | LTV_SUPPLY_CURRENT(5));\n\tret |= ltv350qv_write_reg(lcd, LTV_GATECTL2,\n\t\t\t\t  LTV_NW_INV_1LINE | LTV_FWI(3));\n\n\t \n\tret |= ltv350qv_write_reg(lcd, LTV_PWRCTL2, 0x0000);\n\n\t \n\tusleep_range(1000, 1100);\n\n\t \n\tret |= ltv350qv_write_reg(lcd, LTV_PWRCTL1, LTV_VCOM_DISABLE);\n\n\t \n\tif (ret)\n\t\treturn -EIO;\n\n\t \n\treturn 0;\n}\n\nstatic int ltv350qv_power(struct ltv350qv *lcd, int power)\n{\n\tint ret = 0;\n\n\tif (POWER_IS_ON(power) && !POWER_IS_ON(lcd->power))\n\t\tret = ltv350qv_power_on(lcd);\n\telse if (!POWER_IS_ON(power) && POWER_IS_ON(lcd->power))\n\t\tret = ltv350qv_power_off(lcd);\n\n\tif (!ret)\n\t\tlcd->power = power;\n\n\treturn ret;\n}\n\nstatic int ltv350qv_set_power(struct lcd_device *ld, int power)\n{\n\tstruct ltv350qv *lcd = lcd_get_data(ld);\n\n\treturn ltv350qv_power(lcd, power);\n}\n\nstatic int ltv350qv_get_power(struct lcd_device *ld)\n{\n\tstruct ltv350qv *lcd = lcd_get_data(ld);\n\n\treturn lcd->power;\n}\n\nstatic struct lcd_ops ltv_ops = {\n\t.get_power\t= ltv350qv_get_power,\n\t.set_power\t= ltv350qv_set_power,\n};\n\nstatic int ltv350qv_probe(struct spi_device *spi)\n{\n\tstruct ltv350qv *lcd;\n\tstruct lcd_device *ld;\n\tint ret;\n\n\tlcd = devm_kzalloc(&spi->dev, sizeof(struct ltv350qv), GFP_KERNEL);\n\tif (!lcd)\n\t\treturn -ENOMEM;\n\n\tlcd->spi = spi;\n\tlcd->power = FB_BLANK_POWERDOWN;\n\tlcd->buffer = devm_kzalloc(&spi->dev, 8, GFP_KERNEL);\n\tif (!lcd->buffer)\n\t\treturn -ENOMEM;\n\n\tld = devm_lcd_device_register(&spi->dev, \"ltv350qv\", &spi->dev, lcd,\n\t\t\t\t\t&ltv_ops);\n\tif (IS_ERR(ld))\n\t\treturn PTR_ERR(ld);\n\n\tlcd->ld = ld;\n\n\tret = ltv350qv_power(lcd, FB_BLANK_UNBLANK);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, lcd);\n\n\treturn 0;\n}\n\nstatic void ltv350qv_remove(struct spi_device *spi)\n{\n\tstruct ltv350qv *lcd = spi_get_drvdata(spi);\n\n\tltv350qv_power(lcd, FB_BLANK_POWERDOWN);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ltv350qv_suspend(struct device *dev)\n{\n\tstruct ltv350qv *lcd = dev_get_drvdata(dev);\n\n\treturn ltv350qv_power(lcd, FB_BLANK_POWERDOWN);\n}\n\nstatic int ltv350qv_resume(struct device *dev)\n{\n\tstruct ltv350qv *lcd = dev_get_drvdata(dev);\n\n\treturn ltv350qv_power(lcd, FB_BLANK_UNBLANK);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(ltv350qv_pm_ops, ltv350qv_suspend, ltv350qv_resume);\n\n \nstatic void ltv350qv_shutdown(struct spi_device *spi)\n{\n\tstruct ltv350qv *lcd = spi_get_drvdata(spi);\n\n\tltv350qv_power(lcd, FB_BLANK_POWERDOWN);\n}\n\nstatic struct spi_driver ltv350qv_driver = {\n\t.driver = {\n\t\t.name\t\t= \"ltv350qv\",\n\t\t.pm\t\t= &ltv350qv_pm_ops,\n\t},\n\n\t.probe\t\t= ltv350qv_probe,\n\t.remove\t\t= ltv350qv_remove,\n\t.shutdown\t= ltv350qv_shutdown,\n};\n\nmodule_spi_driver(ltv350qv_driver);\n\nMODULE_AUTHOR(\"Haavard Skinnemoen (Atmel)\");\nMODULE_DESCRIPTION(\"Samsung LTV350QV LCD Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:ltv350qv\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}