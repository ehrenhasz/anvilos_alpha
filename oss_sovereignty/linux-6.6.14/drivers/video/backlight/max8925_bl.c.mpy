{
  "module_name": "max8925_bl.c",
  "hash_id": "4df91f1a9342d076e4ba3eb3604da4ef0f4ab74ef245a4ddd2a201c1d839d748",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/max8925_bl.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/fb.h>\n#include <linux/i2c.h>\n#include <linux/backlight.h>\n#include <linux/mfd/max8925.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define MAX_BRIGHTNESS\t\t(0xff)\n#define MIN_BRIGHTNESS\t\t(0)\n\n#define LWX_FREQ(x)\t\t(((x - 601) / 100) & 0x7)\n\nstruct max8925_backlight_data {\n\tstruct max8925_chip\t*chip;\n\n\tint\tcurrent_brightness;\n\tint\treg_mode_cntl;\n\tint\treg_cntl;\n};\n\nstatic int max8925_backlight_set(struct backlight_device *bl, int brightness)\n{\n\tstruct max8925_backlight_data *data = bl_get_data(bl);\n\tstruct max8925_chip *chip = data->chip;\n\tunsigned char value;\n\tint ret;\n\n\tif (brightness > MAX_BRIGHTNESS)\n\t\tvalue = MAX_BRIGHTNESS;\n\telse\n\t\tvalue = brightness;\n\n\tret = max8925_reg_write(chip->i2c, data->reg_cntl, value);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!data->current_brightness && brightness)\n\t\t \n\t\tret = max8925_set_bits(chip->i2c, data->reg_mode_cntl, 1, 1);\n\telse if (!brightness)\n\t\t \n\t\tret = max8925_set_bits(chip->i2c, data->reg_mode_cntl, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tdev_dbg(chip->dev, \"set brightness %d\\n\", value);\n\tdata->current_brightness = value;\n\treturn 0;\nout:\n\tdev_dbg(chip->dev, \"set brightness %d failure with return value:%d\\n\",\n\t\tvalue, ret);\n\treturn ret;\n}\n\nstatic int max8925_backlight_update_status(struct backlight_device *bl)\n{\n\treturn max8925_backlight_set(bl, backlight_get_brightness(bl));\n}\n\nstatic int max8925_backlight_get_brightness(struct backlight_device *bl)\n{\n\tstruct max8925_backlight_data *data = bl_get_data(bl);\n\tstruct max8925_chip *chip = data->chip;\n\tint ret;\n\n\tret = max8925_reg_read(chip->i2c, data->reg_cntl);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tdata->current_brightness = ret;\n\tdev_dbg(chip->dev, \"get brightness %d\\n\", data->current_brightness);\n\treturn ret;\n}\n\nstatic const struct backlight_ops max8925_backlight_ops = {\n\t.options\t= BL_CORE_SUSPENDRESUME,\n\t.update_status\t= max8925_backlight_update_status,\n\t.get_brightness\t= max8925_backlight_get_brightness,\n};\n\nstatic void max8925_backlight_dt_init(struct platform_device *pdev)\n{\n\tstruct device_node *nproot = pdev->dev.parent->of_node, *np;\n\tstruct max8925_backlight_pdata *pdata;\n\tu32 val;\n\n\tif (!nproot || !IS_ENABLED(CONFIG_OF))\n\t\treturn;\n\n\tpdata = devm_kzalloc(&pdev->dev,\n\t\t\t     sizeof(struct max8925_backlight_pdata),\n\t\t\t     GFP_KERNEL);\n\tif (!pdata)\n\t\treturn;\n\n\tnp = of_get_child_by_name(nproot, \"backlight\");\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"failed to find backlight node\\n\");\n\t\treturn;\n\t}\n\n\tif (!of_property_read_u32(np, \"maxim,max8925-dual-string\", &val))\n\t\tpdata->dual_string = val;\n\n\tof_node_put(np);\n\n\tpdev->dev.platform_data = pdata;\n}\n\nstatic int max8925_backlight_probe(struct platform_device *pdev)\n{\n\tstruct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct max8925_backlight_pdata *pdata;\n\tstruct max8925_backlight_data *data;\n\tstruct backlight_device *bl;\n\tstruct backlight_properties props;\n\tstruct resource *res;\n\tunsigned char value;\n\tint ret = 0;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct max8925_backlight_data),\n\t\t\t    GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_REG, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"No REG resource for mode control!\\n\");\n\t\treturn -ENXIO;\n\t}\n\tdata->reg_mode_cntl = res->start;\n\tres = platform_get_resource(pdev, IORESOURCE_REG, 1);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"No REG resource for control!\\n\");\n\t\treturn -ENXIO;\n\t}\n\tdata->reg_cntl = res->start;\n\n\tdata->chip = chip;\n\tdata->current_brightness = 0;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = MAX_BRIGHTNESS;\n\tbl = devm_backlight_device_register(&pdev->dev, \"max8925-backlight\",\n\t\t\t\t\t&pdev->dev, data,\n\t\t\t\t\t&max8925_backlight_ops, &props);\n\tif (IS_ERR(bl)) {\n\t\tdev_err(&pdev->dev, \"failed to register backlight\\n\");\n\t\treturn PTR_ERR(bl);\n\t}\n\tbl->props.brightness = MAX_BRIGHTNESS;\n\n\tplatform_set_drvdata(pdev, bl);\n\n\tvalue = 0;\n\tif (!pdev->dev.platform_data)\n\t\tmax8925_backlight_dt_init(pdev);\n\n\tpdata = pdev->dev.platform_data;\n\tif (pdata) {\n\t\tif (pdata->lxw_scl)\n\t\t\tvalue |= (1 << 7);\n\t\tif (pdata->lxw_freq)\n\t\t\tvalue |= (LWX_FREQ(pdata->lxw_freq) << 4);\n\t\tif (pdata->dual_string)\n\t\t\tvalue |= (1 << 1);\n\t}\n\tret = max8925_set_bits(chip->i2c, data->reg_mode_cntl, 0xfe, value);\n\tif (ret < 0)\n\t\treturn ret;\n\tbacklight_update_status(bl);\n\treturn 0;\n}\n\nstatic struct platform_driver max8925_backlight_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"max8925-backlight\",\n\t},\n\t.probe\t\t= max8925_backlight_probe,\n};\n\nmodule_platform_driver(max8925_backlight_driver);\n\nMODULE_DESCRIPTION(\"Backlight Driver for Maxim MAX8925\");\nMODULE_AUTHOR(\"Haojian Zhuang <haojian.zhuang@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:max8925-backlight\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}