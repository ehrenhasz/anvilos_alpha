{
  "module_name": "tdo24m.c",
  "hash_id": "1feea6b27714de96ace9c4afcabfa8efdc513b20efad36a72bd2bc3b364ee4a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/tdo24m.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/tdo24m.h>\n#include <linux/fb.h>\n#include <linux/lcd.h>\n#include <linux/slab.h>\n\n#define POWER_IS_ON(pwr)\t((pwr) <= FB_BLANK_NORMAL)\n\n#define TDO24M_SPI_BUFF_SIZE\t(4)\n#define MODE_QVGA\t0\n#define MODE_VGA\t1\n\nstruct tdo24m {\n\tstruct spi_device\t*spi_dev;\n\tstruct lcd_device\t*lcd_dev;\n\n\tstruct spi_message\tmsg;\n\tstruct spi_transfer\txfer;\n\tuint8_t\t\t\t*buf;\n\n\tint (*adj_mode)(struct tdo24m *lcd, int mode);\n\tint color_invert;\n\n\tint\t\t\tpower;\n\tint\t\t\tmode;\n};\n\n \n#define CMD0(x)\t\t((0 << 30) | (x))\n#define CMD1(x, x1)\t((1 << 30) | ((x) << 9) | 0x100 | (x1))\n#define CMD2(x, x1, x2)\t((2 << 30) | ((x) << 18) | 0x20000 |\\\n\t\t\t((x1) << 9) | 0x100 | (x2))\n#define CMD_NULL\t(-1)\n\nstatic const uint32_t lcd_panel_reset[] = {\n\tCMD0(0x1),  \n\tCMD0(0x0),  \n\tCMD0(0x0),  \n\tCMD0(0x0),  \n\tCMD_NULL,\n};\n\nstatic const uint32_t lcd_panel_on[] = {\n\tCMD0(0x29),\t\t \n\tCMD2(0xB8, 0xFF, 0xF9),\t \n\tCMD0(0x11),\t\t \n\tCMD1(0xB0, 0x16),\t \n\tCMD_NULL,\n};\n\nstatic const uint32_t lcd_panel_off[] = {\n\tCMD0(0x28),\t\t \n\tCMD2(0xB8, 0x80, 0x02),\t \n\tCMD0(0x10),\t\t \n\tCMD1(0xB0, 0x00),\t \n\tCMD_NULL,\n};\n\nstatic const uint32_t lcd_vga_pass_through_tdo24m[] = {\n\tCMD1(0xB0, 0x16),\n\tCMD1(0xBC, 0x80),\n\tCMD1(0xE1, 0x00),\n\tCMD1(0x36, 0x50),\n\tCMD1(0x3B, 0x00),\n\tCMD_NULL,\n};\n\nstatic const uint32_t lcd_qvga_pass_through_tdo24m[] = {\n\tCMD1(0xB0, 0x16),\n\tCMD1(0xBC, 0x81),\n\tCMD1(0xE1, 0x00),\n\tCMD1(0x36, 0x50),\n\tCMD1(0x3B, 0x22),\n\tCMD_NULL,\n};\n\nstatic const uint32_t lcd_vga_transfer_tdo24m[] = {\n\tCMD1(0xcf, 0x02),\t \n\tCMD2(0xd0, 0x08, 0x04),\t \n\tCMD1(0xd1, 0x01),\t \n\tCMD2(0xd2, 0x14, 0x00),\t \n\tCMD2(0xd3, 0x1a, 0x0f),\t \n\tCMD2(0xd4, 0x1f, 0xaf),\t \n\tCMD1(0xd5, 0x14),\t \n\tCMD0(0x21),\t\t \n\tCMD0(0x29),\t\t \n\tCMD_NULL,\n};\n\nstatic const uint32_t lcd_qvga_transfer[] = {\n\tCMD1(0xd6, 0x02),\t \n\tCMD2(0xd7, 0x08, 0x04),\t \n\tCMD1(0xd8, 0x01),\t \n\tCMD2(0xd9, 0x00, 0x08),\t \n\tCMD2(0xde, 0x05, 0x0a),\t \n\tCMD2(0xdf, 0x0a, 0x19),\t \n\tCMD1(0xe0, 0x0a),\t \n\tCMD0(0x21),\t\t \n\tCMD0(0x29),\t\t \n\tCMD_NULL,\n};\n\nstatic const uint32_t lcd_vga_pass_through_tdo35s[] = {\n\tCMD1(0xB0, 0x16),\n\tCMD1(0xBC, 0x80),\n\tCMD1(0xE1, 0x00),\n\tCMD1(0x3B, 0x00),\n\tCMD_NULL,\n};\n\nstatic const uint32_t lcd_qvga_pass_through_tdo35s[] = {\n\tCMD1(0xB0, 0x16),\n\tCMD1(0xBC, 0x81),\n\tCMD1(0xE1, 0x00),\n\tCMD1(0x3B, 0x22),\n\tCMD_NULL,\n};\n\nstatic const uint32_t lcd_vga_transfer_tdo35s[] = {\n\tCMD1(0xcf, 0x02),\t \n\tCMD2(0xd0, 0x08, 0x04),\t \n\tCMD1(0xd1, 0x01),\t \n\tCMD2(0xd2, 0x00, 0x1e),\t \n\tCMD2(0xd3, 0x14, 0x28),\t \n\tCMD2(0xd4, 0x28, 0x64),\t \n\tCMD1(0xd5, 0x28),\t \n\tCMD0(0x21),\t\t \n\tCMD0(0x29),\t\t \n\tCMD_NULL,\n};\n\nstatic const uint32_t lcd_panel_config[] = {\n\tCMD2(0xb8, 0xff, 0xf9),\t \n\tCMD0(0x11),\t\t \n\tCMD1(0xba, 0x01),\t \n\tCMD1(0xbb, 0x00),\t \n\tCMD1(0x3a, 0x60),\t \n\tCMD1(0xbf, 0x10),\t \n\tCMD1(0xb1, 0x56),\t \n\tCMD1(0xb2, 0x33),\t \n\tCMD1(0xb3, 0x11),\t \n\tCMD1(0xb4, 0x02),\t \n\tCMD1(0xb5, 0x35),\t \n\tCMD1(0xb6, 0x40),\t \n\tCMD1(0xb7, 0x03),\t \n\tCMD1(0xbd, 0x00),\t \n\tCMD1(0xbe, 0x00),\t \n\tCMD1(0xc0, 0x11),\t \n\tCMD1(0xc1, 0x11),\t \n\tCMD1(0xc2, 0x11),\t \n\tCMD2(0xc3, 0x20, 0x40),\t \n\tCMD2(0xc4, 0x60, 0xc0),\t \n\tCMD2(0xc5, 0x10, 0x20),\t \n\tCMD1(0xc6, 0xc0),\t \n\tCMD2(0xc7, 0x33, 0x43),\t \n\tCMD1(0xc8, 0x44),\t \n\tCMD1(0xc9, 0x33),\t \n\tCMD1(0xca, 0x00),\t \n\tCMD2(0xec, 0x01, 0xf0),\t \n\tCMD_NULL,\n};\n\nstatic int tdo24m_writes(struct tdo24m *lcd, const uint32_t *array)\n{\n\tstruct spi_transfer *x = &lcd->xfer;\n\tconst uint32_t *p = array;\n\tuint32_t data;\n\tint nparams, err = 0;\n\n\tfor (; *p != CMD_NULL; p++) {\n\t\tif (!lcd->color_invert && *p == CMD0(0x21))\n\t\t\tcontinue;\n\n\t\tnparams = (*p >> 30) & 0x3;\n\n\t\tdata = *p << (7 - nparams);\n\t\tswitch (nparams) {\n\t\tcase 0:\n\t\t\tlcd->buf[0] = (data >> 8) & 0xff;\n\t\t\tlcd->buf[1] = data & 0xff;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tlcd->buf[0] = (data >> 16) & 0xff;\n\t\t\tlcd->buf[1] = (data >> 8) & 0xff;\n\t\t\tlcd->buf[2] = data & 0xff;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlcd->buf[0] = (data >> 24) & 0xff;\n\t\t\tlcd->buf[1] = (data >> 16) & 0xff;\n\t\t\tlcd->buf[2] = (data >> 8) & 0xff;\n\t\t\tlcd->buf[3] = data & 0xff;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tx->len = nparams + 2;\n\t\terr = spi_sync(lcd->spi_dev, &lcd->msg);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int tdo24m_adj_mode(struct tdo24m *lcd, int mode)\n{\n\tswitch (mode) {\n\tcase MODE_VGA:\n\t\ttdo24m_writes(lcd, lcd_vga_pass_through_tdo24m);\n\t\ttdo24m_writes(lcd, lcd_panel_config);\n\t\ttdo24m_writes(lcd, lcd_vga_transfer_tdo24m);\n\t\tbreak;\n\tcase MODE_QVGA:\n\t\ttdo24m_writes(lcd, lcd_qvga_pass_through_tdo24m);\n\t\ttdo24m_writes(lcd, lcd_panel_config);\n\t\ttdo24m_writes(lcd, lcd_qvga_transfer);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlcd->mode = mode;\n\treturn 0;\n}\n\nstatic int tdo35s_adj_mode(struct tdo24m *lcd, int mode)\n{\n\tswitch (mode) {\n\tcase MODE_VGA:\n\t\ttdo24m_writes(lcd, lcd_vga_pass_through_tdo35s);\n\t\ttdo24m_writes(lcd, lcd_panel_config);\n\t\ttdo24m_writes(lcd, lcd_vga_transfer_tdo35s);\n\t\tbreak;\n\tcase MODE_QVGA:\n\t\ttdo24m_writes(lcd, lcd_qvga_pass_through_tdo35s);\n\t\ttdo24m_writes(lcd, lcd_panel_config);\n\t\ttdo24m_writes(lcd, lcd_qvga_transfer);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlcd->mode = mode;\n\treturn 0;\n}\n\nstatic int tdo24m_power_on(struct tdo24m *lcd)\n{\n\tint err;\n\n\terr = tdo24m_writes(lcd, lcd_panel_on);\n\tif (err)\n\t\tgoto out;\n\n\terr = tdo24m_writes(lcd, lcd_panel_reset);\n\tif (err)\n\t\tgoto out;\n\n\terr = lcd->adj_mode(lcd, lcd->mode);\nout:\n\treturn err;\n}\n\nstatic int tdo24m_power_off(struct tdo24m *lcd)\n{\n\treturn tdo24m_writes(lcd, lcd_panel_off);\n}\n\nstatic int tdo24m_power(struct tdo24m *lcd, int power)\n{\n\tint ret = 0;\n\n\tif (POWER_IS_ON(power) && !POWER_IS_ON(lcd->power))\n\t\tret = tdo24m_power_on(lcd);\n\telse if (!POWER_IS_ON(power) && POWER_IS_ON(lcd->power))\n\t\tret = tdo24m_power_off(lcd);\n\n\tif (!ret)\n\t\tlcd->power = power;\n\n\treturn ret;\n}\n\n\nstatic int tdo24m_set_power(struct lcd_device *ld, int power)\n{\n\tstruct tdo24m *lcd = lcd_get_data(ld);\n\n\treturn tdo24m_power(lcd, power);\n}\n\nstatic int tdo24m_get_power(struct lcd_device *ld)\n{\n\tstruct tdo24m *lcd = lcd_get_data(ld);\n\n\treturn lcd->power;\n}\n\nstatic int tdo24m_set_mode(struct lcd_device *ld, struct fb_videomode *m)\n{\n\tstruct tdo24m *lcd = lcd_get_data(ld);\n\tint mode = MODE_QVGA;\n\n\tif (m->xres == 640 || m->xres == 480)\n\t\tmode = MODE_VGA;\n\n\tif (lcd->mode == mode)\n\t\treturn 0;\n\n\treturn lcd->adj_mode(lcd, mode);\n}\n\nstatic struct lcd_ops tdo24m_ops = {\n\t.get_power\t= tdo24m_get_power,\n\t.set_power\t= tdo24m_set_power,\n\t.set_mode\t= tdo24m_set_mode,\n};\n\nstatic int tdo24m_probe(struct spi_device *spi)\n{\n\tstruct tdo24m *lcd;\n\tstruct spi_message *m;\n\tstruct spi_transfer *x;\n\tstruct tdo24m_platform_data *pdata;\n\tenum tdo24m_model model;\n\tint err;\n\n\tpdata = dev_get_platdata(&spi->dev);\n\tif (pdata)\n\t\tmodel = pdata->model;\n\telse\n\t\tmodel = TDO24M;\n\n\tspi->bits_per_word = 8;\n\tspi->mode = SPI_MODE_3;\n\terr = spi_setup(spi);\n\tif (err)\n\t\treturn err;\n\n\tlcd = devm_kzalloc(&spi->dev, sizeof(struct tdo24m), GFP_KERNEL);\n\tif (!lcd)\n\t\treturn -ENOMEM;\n\n\tlcd->spi_dev = spi;\n\tlcd->power = FB_BLANK_POWERDOWN;\n\tlcd->mode = MODE_VGA;\t \n\n\tlcd->buf = devm_kzalloc(&spi->dev, TDO24M_SPI_BUFF_SIZE, GFP_KERNEL);\n\tif (lcd->buf == NULL)\n\t\treturn -ENOMEM;\n\n\tm = &lcd->msg;\n\tx = &lcd->xfer;\n\n\tspi_message_init(m);\n\n\tx->cs_change = 0;\n\tx->tx_buf = &lcd->buf[0];\n\tspi_message_add_tail(x, m);\n\n\tswitch (model) {\n\tcase TDO24M:\n\t\tlcd->color_invert = 1;\n\t\tlcd->adj_mode = tdo24m_adj_mode;\n\t\tbreak;\n\tcase TDO35S:\n\t\tlcd->adj_mode = tdo35s_adj_mode;\n\t\tlcd->color_invert = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&spi->dev, \"Unsupported model\");\n\t\treturn -EINVAL;\n\t}\n\n\tlcd->lcd_dev = devm_lcd_device_register(&spi->dev, \"tdo24m\", &spi->dev,\n\t\t\t\t\t\tlcd, &tdo24m_ops);\n\tif (IS_ERR(lcd->lcd_dev))\n\t\treturn PTR_ERR(lcd->lcd_dev);\n\n\tspi_set_drvdata(spi, lcd);\n\terr = tdo24m_power(lcd, FB_BLANK_UNBLANK);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void tdo24m_remove(struct spi_device *spi)\n{\n\tstruct tdo24m *lcd = spi_get_drvdata(spi);\n\n\ttdo24m_power(lcd, FB_BLANK_POWERDOWN);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tdo24m_suspend(struct device *dev)\n{\n\tstruct tdo24m *lcd = dev_get_drvdata(dev);\n\n\treturn tdo24m_power(lcd, FB_BLANK_POWERDOWN);\n}\n\nstatic int tdo24m_resume(struct device *dev)\n{\n\tstruct tdo24m *lcd = dev_get_drvdata(dev);\n\n\treturn tdo24m_power(lcd, FB_BLANK_UNBLANK);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(tdo24m_pm_ops, tdo24m_suspend, tdo24m_resume);\n\n \nstatic void tdo24m_shutdown(struct spi_device *spi)\n{\n\tstruct tdo24m *lcd = spi_get_drvdata(spi);\n\n\ttdo24m_power(lcd, FB_BLANK_POWERDOWN);\n}\n\nstatic struct spi_driver tdo24m_driver = {\n\t.driver = {\n\t\t.name\t\t= \"tdo24m\",\n\t\t.pm\t\t= &tdo24m_pm_ops,\n\t},\n\t.probe\t\t= tdo24m_probe,\n\t.remove\t\t= tdo24m_remove,\n\t.shutdown\t= tdo24m_shutdown,\n};\n\nmodule_spi_driver(tdo24m_driver);\n\nMODULE_AUTHOR(\"Eric Miao <eric.miao@marvell.com>\");\nMODULE_DESCRIPTION(\"Driver for Toppoly TDO24M LCD Panel\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:tdo24m\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}