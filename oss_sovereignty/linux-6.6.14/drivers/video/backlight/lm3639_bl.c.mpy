{
  "module_name": "lm3639_bl.c",
  "hash_id": "a8c302d5d49a16155d3511431cf5a3b03acae735e8d47b185158390e589518ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/lm3639_bl.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/leds.h>\n#include <linux/backlight.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/interrupt.h>\n#include <linux/regmap.h>\n#include <linux/platform_data/lm3639_bl.h>\n\n#define REG_DEV_ID\t0x00\n#define REG_CHECKSUM\t0x01\n#define REG_BL_CONF_1\t0x02\n#define REG_BL_CONF_2\t0x03\n#define REG_BL_CONF_3\t0x04\n#define REG_BL_CONF_4\t0x05\n#define REG_FL_CONF_1\t0x06\n#define REG_FL_CONF_2\t0x07\n#define REG_FL_CONF_3\t0x08\n#define REG_IO_CTRL\t0x09\n#define REG_ENABLE\t0x0A\n#define REG_FLAG\t0x0B\n#define REG_MAX\t\tREG_FLAG\n\nstruct lm3639_chip_data {\n\tstruct device *dev;\n\tstruct lm3639_platform_data *pdata;\n\n\tstruct backlight_device *bled;\n\tstruct led_classdev cdev_flash;\n\tstruct led_classdev cdev_torch;\n\tstruct regmap *regmap;\n\n\tunsigned int bled_mode;\n\tunsigned int bled_map;\n\tunsigned int last_flag;\n};\n\n \nstatic int lm3639_chip_init(struct lm3639_chip_data *pchip)\n{\n\tint ret;\n\tunsigned int reg_val;\n\tstruct lm3639_platform_data *pdata = pchip->pdata;\n\n\t \n\tret =\n\t    regmap_update_bits(pchip->regmap, REG_BL_CONF_1, 0x08,\n\t\t\t       pdata->pin_pwm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treg_val = (pdata->pin_pwm & 0x40) | pdata->pin_strobe | pdata->pin_tx;\n\tret = regmap_update_bits(pchip->regmap, REG_IO_CTRL, 0x7C, reg_val);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = regmap_write(pchip->regmap, REG_BL_CONF_4, pdata->init_brt_led);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = regmap_write(pchip->regmap, REG_BL_CONF_3, pdata->init_brt_led);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (!pdata->init_brt_led) {\n\t\treg_val = pdata->fled_pins;\n\t\treg_val |= pdata->bled_pins;\n\t} else {\n\t\treg_val = pdata->fled_pins;\n\t\treg_val |= pdata->bled_pins | 0x01;\n\t}\n\n\tret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x79, reg_val);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treturn ret;\nout:\n\tdev_err(pchip->dev, \"i2c failed to access register\\n\");\n\treturn ret;\n}\n\n \nstatic int lm3639_bled_update_status(struct backlight_device *bl)\n{\n\tint ret;\n\tunsigned int reg_val;\n\tstruct lm3639_chip_data *pchip = bl_get_data(bl);\n\tstruct lm3639_platform_data *pdata = pchip->pdata;\n\n\tret = regmap_read(pchip->regmap, REG_FLAG, &reg_val);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (reg_val != 0)\n\t\tdev_info(pchip->dev, \"last flag is 0x%x\\n\", reg_val);\n\n\t \n\tif (pdata->pin_pwm) {\n\t\tif (pdata->pwm_set_intensity)\n\t\t\tpdata->pwm_set_intensity(bl->props.brightness,\n\t\t\t\t\t\t pdata->max_brt_led);\n\t\telse\n\t\t\tdev_err(pchip->dev,\n\t\t\t\t\"No pwm control func. in plat-data\\n\");\n\t\treturn bl->props.brightness;\n\t}\n\n\t \n\tret = regmap_write(pchip->regmap, REG_BL_CONF_4, bl->props.brightness);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = regmap_write(pchip->regmap, REG_BL_CONF_3, bl->props.brightness);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!bl->props.brightness)\n\t\tret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x01, 0x00);\n\telse\n\t\tret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x01, 0x01);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treturn bl->props.brightness;\nout:\n\tdev_err(pchip->dev, \"i2c failed to access registers\\n\");\n\treturn bl->props.brightness;\n}\n\nstatic int lm3639_bled_get_brightness(struct backlight_device *bl)\n{\n\tint ret;\n\tunsigned int reg_val;\n\tstruct lm3639_chip_data *pchip = bl_get_data(bl);\n\tstruct lm3639_platform_data *pdata = pchip->pdata;\n\n\tif (pdata->pin_pwm) {\n\t\tif (pdata->pwm_get_intensity)\n\t\t\tbl->props.brightness = pdata->pwm_get_intensity();\n\t\telse\n\t\t\tdev_err(pchip->dev,\n\t\t\t\t\"No pwm control func. in plat-data\\n\");\n\t\treturn bl->props.brightness;\n\t}\n\n\tret = regmap_read(pchip->regmap, REG_BL_CONF_1, &reg_val);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (reg_val & 0x10)\n\t\tret = regmap_read(pchip->regmap, REG_BL_CONF_4, &reg_val);\n\telse\n\t\tret = regmap_read(pchip->regmap, REG_BL_CONF_3, &reg_val);\n\tif (ret < 0)\n\t\tgoto out;\n\tbl->props.brightness = reg_val;\n\n\treturn bl->props.brightness;\nout:\n\tdev_err(pchip->dev, \"i2c failed to access register\\n\");\n\treturn bl->props.brightness;\n}\n\nstatic const struct backlight_ops lm3639_bled_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.update_status = lm3639_bled_update_status,\n\t.get_brightness = lm3639_bled_get_brightness,\n};\n\n \nstatic ssize_t lm3639_bled_mode_store(struct device *dev,\n\t\t\t\t      struct device_attribute *devAttr,\n\t\t\t\t      const char *buf, size_t size)\n{\n\tssize_t ret;\n\tstruct lm3639_chip_data *pchip = dev_get_drvdata(dev);\n\tunsigned int state;\n\n\tret = kstrtouint(buf, 10, &state);\n\tif (ret)\n\t\tgoto out_input;\n\n\tif (!state)\n\t\tret =\n\t\t    regmap_update_bits(pchip->regmap, REG_BL_CONF_1, 0x10,\n\t\t\t\t       0x00);\n\telse\n\t\tret =\n\t\t    regmap_update_bits(pchip->regmap, REG_BL_CONF_1, 0x10,\n\t\t\t\t       0x10);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\treturn size;\n\nout:\n\tdev_err(pchip->dev, \"%s:i2c access fail to register\\n\", __func__);\n\treturn ret;\n\nout_input:\n\tdev_err(pchip->dev, \"%s:input conversion fail\\n\", __func__);\n\treturn ret;\n\n}\n\nstatic DEVICE_ATTR(bled_mode, S_IWUSR, NULL, lm3639_bled_mode_store);\n\n \nstatic void lm3639_torch_brightness_set(struct led_classdev *cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tint ret;\n\tunsigned int reg_val;\n\tstruct lm3639_chip_data *pchip;\n\n\tpchip = container_of(cdev, struct lm3639_chip_data, cdev_torch);\n\n\tret = regmap_read(pchip->regmap, REG_FLAG, &reg_val);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (reg_val != 0)\n\t\tdev_info(pchip->dev, \"last flag is 0x%x\\n\", reg_val);\n\n\t \n\tif (!brightness) {\n\t\tret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x06, 0x00);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\treturn;\n\t}\n\n\tret = regmap_update_bits(pchip->regmap,\n\t\t\t\t REG_FL_CONF_1, 0x70, (brightness - 1) << 4);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x06, 0x02);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treturn;\nout:\n\tdev_err(pchip->dev, \"i2c failed to access register\\n\");\n}\n\n \nstatic void lm3639_flash_brightness_set(struct led_classdev *cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tint ret;\n\tunsigned int reg_val;\n\tstruct lm3639_chip_data *pchip;\n\n\tpchip = container_of(cdev, struct lm3639_chip_data, cdev_flash);\n\n\tret = regmap_read(pchip->regmap, REG_FLAG, &reg_val);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (reg_val != 0)\n\t\tdev_info(pchip->dev, \"last flag is 0x%x\\n\", reg_val);\n\n\t \n\tret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x06, 0x00);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (!brightness)\n\t\treturn;\n\n\tret = regmap_update_bits(pchip->regmap,\n\t\t\t\t REG_FL_CONF_1, 0x0F, brightness - 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x06, 0x06);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treturn;\nout:\n\tdev_err(pchip->dev, \"i2c failed to access register\\n\");\n}\n\nstatic const struct regmap_config lm3639_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = REG_MAX,\n};\n\nstatic int lm3639_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct lm3639_chip_data *pchip;\n\tstruct lm3639_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct backlight_properties props;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"i2c functionality check fail.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (pdata == NULL) {\n\t\tdev_err(&client->dev, \"Needs Platform Data.\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\tpchip = devm_kzalloc(&client->dev,\n\t\t\t     sizeof(struct lm3639_chip_data), GFP_KERNEL);\n\tif (!pchip)\n\t\treturn -ENOMEM;\n\n\tpchip->pdata = pdata;\n\tpchip->dev = &client->dev;\n\n\tpchip->regmap = devm_regmap_init_i2c(client, &lm3639_regmap);\n\tif (IS_ERR(pchip->regmap)) {\n\t\tret = PTR_ERR(pchip->regmap);\n\t\tdev_err(&client->dev, \"fail : allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\ti2c_set_clientdata(client, pchip);\n\n\t \n\tret = lm3639_chip_init(pchip);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"fail : chip init\\n\");\n\t\tgoto err_out;\n\t}\n\n\t \n\tprops.type = BACKLIGHT_RAW;\n\tprops.brightness = pdata->init_brt_led;\n\tprops.max_brightness = pdata->max_brt_led;\n\tpchip->bled =\n\t    devm_backlight_device_register(pchip->dev, \"lm3639_bled\",\n\t\t\t\t\t   pchip->dev, pchip, &lm3639_bled_ops,\n\t\t\t\t\t   &props);\n\tif (IS_ERR(pchip->bled)) {\n\t\tdev_err(&client->dev, \"fail : backlight register\\n\");\n\t\tret = PTR_ERR(pchip->bled);\n\t\tgoto err_out;\n\t}\n\n\tret = device_create_file(&(pchip->bled->dev), &dev_attr_bled_mode);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed : add sysfs entries\\n\");\n\t\tgoto err_out;\n\t}\n\n\t \n\tpchip->cdev_flash.name = \"lm3639_flash\";\n\tpchip->cdev_flash.max_brightness = 16;\n\tpchip->cdev_flash.brightness_set = lm3639_flash_brightness_set;\n\tret = led_classdev_register((struct device *)\n\t\t\t\t    &client->dev, &pchip->cdev_flash);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"fail : flash register\\n\");\n\t\tgoto err_flash;\n\t}\n\n\t \n\tpchip->cdev_torch.name = \"lm3639_torch\";\n\tpchip->cdev_torch.max_brightness = 8;\n\tpchip->cdev_torch.brightness_set = lm3639_torch_brightness_set;\n\tret = led_classdev_register((struct device *)\n\t\t\t\t    &client->dev, &pchip->cdev_torch);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"fail : torch register\\n\");\n\t\tgoto err_torch;\n\t}\n\n\treturn 0;\n\nerr_torch:\n\tled_classdev_unregister(&pchip->cdev_flash);\nerr_flash:\n\tdevice_remove_file(&(pchip->bled->dev), &dev_attr_bled_mode);\nerr_out:\n\treturn ret;\n}\n\nstatic void lm3639_remove(struct i2c_client *client)\n{\n\tstruct lm3639_chip_data *pchip = i2c_get_clientdata(client);\n\n\tregmap_write(pchip->regmap, REG_ENABLE, 0x00);\n\n\tled_classdev_unregister(&pchip->cdev_torch);\n\tled_classdev_unregister(&pchip->cdev_flash);\n\tif (pchip->bled)\n\t\tdevice_remove_file(&(pchip->bled->dev), &dev_attr_bled_mode);\n}\n\nstatic const struct i2c_device_id lm3639_id[] = {\n\t{LM3639_NAME, 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, lm3639_id);\nstatic struct i2c_driver lm3639_i2c_driver = {\n\t.driver = {\n\t\t   .name = LM3639_NAME,\n\t\t   },\n\t.probe = lm3639_probe,\n\t.remove = lm3639_remove,\n\t.id_table = lm3639_id,\n};\n\nmodule_i2c_driver(lm3639_i2c_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments Backlight+Flash LED driver for LM3639\");\nMODULE_AUTHOR(\"Daniel Jeong <gshark.jeong@gmail.com>\");\nMODULE_AUTHOR(\"Ldd Mlp <ldd-mlp@list.ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}