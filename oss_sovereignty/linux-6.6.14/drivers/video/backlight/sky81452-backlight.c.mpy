{
  "module_name": "sky81452-backlight.c",
  "hash_id": "f6b9b03cf7494fc8e63aed11591cc1476e883c3c6846d5e4c6d72ea56a9ecef2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/sky81452-backlight.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \n#define SKY81452_REG0\t0x00\n#define SKY81452_REG1\t0x01\n#define SKY81452_REG2\t0x02\n#define SKY81452_REG4\t0x04\n#define SKY81452_REG5\t0x05\n\n \n#define SKY81452_CS\t0xFF\n#define SKY81452_EN\t0x3F\n#define SKY81452_IGPW\t0x20\n#define SKY81452_PWMMD\t0x10\n#define SKY81452_PHASE\t0x08\n#define SKY81452_ILIM\t0x04\n#define SKY81452_VSHRT\t0x03\n#define SKY81452_OCP\t0x80\n#define SKY81452_OTMP\t0x40\n#define SKY81452_SHRT\t0x3F\n#define SKY81452_OPN\t0x3F\n\n#define SKY81452_DEFAULT_NAME \"lcd-backlight\"\n#define SKY81452_MAX_BRIGHTNESS\t(SKY81452_CS + 1)\n\n \nstruct sky81452_bl_platform_data {\n\tconst char *name;\n\tstruct gpio_desc *gpiod_enable;\n\tunsigned int enable;\n\tbool ignore_pwm;\n\tbool dpwm_mode;\n\tbool phase_shift;\n\tunsigned int short_detection_threshold;\n\tunsigned int boost_current_limit;\n};\n\n#define CTZ(b) __builtin_ctz(b)\n\nstatic int sky81452_bl_update_status(struct backlight_device *bd)\n{\n\tconst struct sky81452_bl_platform_data *pdata =\n\t\t\tdev_get_platdata(bd->dev.parent);\n\tconst unsigned int brightness = (unsigned int)bd->props.brightness;\n\tstruct regmap *regmap = bl_get_data(bd);\n\tint ret;\n\n\tif (brightness > 0) {\n\t\tret = regmap_write(regmap, SKY81452_REG0, brightness - 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn regmap_update_bits(regmap, SKY81452_REG1, SKY81452_EN,\n\t\t\t\t\tpdata->enable << CTZ(SKY81452_EN));\n\t}\n\n\treturn regmap_update_bits(regmap, SKY81452_REG1, SKY81452_EN, 0);\n}\n\nstatic const struct backlight_ops sky81452_bl_ops = {\n\t.update_status = sky81452_bl_update_status,\n};\n\nstatic ssize_t sky81452_bl_store_enable(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct regmap *regmap = bl_get_data(to_backlight_device(dev));\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 16, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, SKY81452_REG1, SKY81452_EN,\n\t\t\t\t\tvalue << CTZ(SKY81452_EN));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t sky81452_bl_show_open_short(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regmap *regmap = bl_get_data(to_backlight_device(dev));\n\tunsigned int reg, value = 0;\n\tchar tmp[3];\n\tint i, ret;\n\n\treg = !strcmp(attr->attr.name, \"open\") ? SKY81452_REG5 : SKY81452_REG4;\n\tret = regmap_read(regmap, reg, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (value & SKY81452_SHRT) {\n\t\t*buf = 0;\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tif (value & 0x01) {\n\t\t\t\tsprintf(tmp, \"%d \", i + 1);\n\t\t\t\tstrcat(buf, tmp);\n\t\t\t}\n\t\t\tvalue >>= 1;\n\t\t}\n\t\tstrcat(buf, \"\\n\");\n\t} else {\n\t\tstrcpy(buf, \"none\\n\");\n\t}\n\n\treturn strlen(buf);\n}\n\nstatic ssize_t sky81452_bl_show_fault(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regmap *regmap = bl_get_data(to_backlight_device(dev));\n\tunsigned int value = 0;\n\tint ret;\n\n\tret = regmap_read(regmap, SKY81452_REG4, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*buf = 0;\n\n\tif (value & SKY81452_OCP)\n\t\tstrcat(buf, \"over-current \");\n\n\tif (value & SKY81452_OTMP)\n\t\tstrcat(buf, \"over-temperature\");\n\n\tstrcat(buf, \"\\n\");\n\treturn strlen(buf);\n}\n\nstatic DEVICE_ATTR(enable, S_IWGRP | S_IWUSR, NULL, sky81452_bl_store_enable);\nstatic DEVICE_ATTR(open, S_IRUGO, sky81452_bl_show_open_short, NULL);\nstatic DEVICE_ATTR(short, S_IRUGO, sky81452_bl_show_open_short, NULL);\nstatic DEVICE_ATTR(fault, S_IRUGO, sky81452_bl_show_fault, NULL);\n\nstatic struct attribute *sky81452_bl_attribute[] = {\n\t&dev_attr_enable.attr,\n\t&dev_attr_open.attr,\n\t&dev_attr_short.attr,\n\t&dev_attr_fault.attr,\n\tNULL\n};\n\nstatic const struct attribute_group sky81452_bl_attr_group = {\n\t.attrs = sky81452_bl_attribute,\n};\n\n#ifdef CONFIG_OF\nstatic struct sky81452_bl_platform_data *sky81452_bl_parse_dt(\n\t\t\t\t\t\t\tstruct device *dev)\n{\n\tstruct device_node *np = of_node_get(dev->of_node);\n\tstruct sky81452_bl_platform_data *pdata;\n\tint num_entry;\n\tunsigned int sources[6];\n\tint ret;\n\n\tif (!np) {\n\t\tdev_err(dev, \"backlight node not found.\\n\");\n\t\treturn ERR_PTR(-ENODATA);\n\t}\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tof_node_put(np);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tof_property_read_string(np, \"name\", &pdata->name);\n\tpdata->ignore_pwm = of_property_read_bool(np, \"skyworks,ignore-pwm\");\n\tpdata->dpwm_mode = of_property_read_bool(np, \"skyworks,dpwm-mode\");\n\tpdata->phase_shift = of_property_read_bool(np, \"skyworks,phase-shift\");\n\tpdata->gpiod_enable = devm_gpiod_get_optional(dev, NULL, GPIOD_OUT_HIGH);\n\n\tret = of_property_count_u32_elems(np, \"led-sources\");\n\tif (ret < 0) {\n\t\tpdata->enable = SKY81452_EN >> CTZ(SKY81452_EN);\n\t} else {\n\t\tnum_entry = ret;\n\t\tif (num_entry > 6)\n\t\t\tnum_entry = 6;\n\n\t\tret = of_property_read_u32_array(np, \"led-sources\", sources,\n\t\t\t\t\tnum_entry);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"led-sources node is invalid.\\n\");\n\t\t\tof_node_put(np);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tpdata->enable = 0;\n\t\twhile (--num_entry)\n\t\t\tpdata->enable |= (1 << sources[num_entry]);\n\t}\n\n\tret = of_property_read_u32(np,\n\t\t\t\"skyworks,short-detection-threshold-volt\",\n\t\t\t&pdata->short_detection_threshold);\n\tif (ret < 0)\n\t\tpdata->short_detection_threshold = 7;\n\n\tret = of_property_read_u32(np, \"skyworks,current-limit-mA\",\n\t\t\t&pdata->boost_current_limit);\n\tif (ret < 0)\n\t\tpdata->boost_current_limit = 2750;\n\n\tof_node_put(np);\n\treturn pdata;\n}\n#else\nstatic struct sky81452_bl_platform_data *sky81452_bl_parse_dt(\n\t\t\t\t\t\t\tstruct device *dev)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n#endif\n\nstatic int sky81452_bl_init_device(struct regmap *regmap,\n\t\tstruct sky81452_bl_platform_data *pdata)\n{\n\tunsigned int value;\n\n\tvalue = pdata->ignore_pwm ? SKY81452_IGPW : 0;\n\tvalue |= pdata->dpwm_mode ? SKY81452_PWMMD : 0;\n\tvalue |= pdata->phase_shift ? 0 : SKY81452_PHASE;\n\n\tif (pdata->boost_current_limit == 2300)\n\t\tvalue |= SKY81452_ILIM;\n\telse if (pdata->boost_current_limit != 2750)\n\t\treturn -EINVAL;\n\n\tif (pdata->short_detection_threshold < 4 ||\n\t\t\t\tpdata->short_detection_threshold > 7)\n\t\treturn -EINVAL;\n\tvalue |= (7 - pdata->short_detection_threshold) << CTZ(SKY81452_VSHRT);\n\n\treturn regmap_write(regmap, SKY81452_REG2, value);\n}\n\nstatic int sky81452_bl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap *regmap = dev_get_drvdata(dev->parent);\n\tstruct sky81452_bl_platform_data *pdata;\n\tstruct backlight_device *bd;\n\tstruct backlight_properties props;\n\tconst char *name;\n\tint ret;\n\n\tpdata = sky81452_bl_parse_dt(dev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\n\tret = sky81452_bl_init_device(regmap, pdata);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to initialize. err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmemset(&props, 0, sizeof(props));\n\tprops.max_brightness = SKY81452_MAX_BRIGHTNESS;\n\tname = pdata->name ? pdata->name : SKY81452_DEFAULT_NAME;\n\tbd = devm_backlight_device_register(dev, name, dev, regmap,\n\t\t\t\t\t\t&sky81452_bl_ops, &props);\n\tif (IS_ERR(bd)) {\n\t\tdev_err(dev, \"failed to register. err=%ld\\n\", PTR_ERR(bd));\n\t\treturn PTR_ERR(bd);\n\t}\n\n\tplatform_set_drvdata(pdev, bd);\n\n\tret = sysfs_create_group(&bd->dev.kobj, &sky81452_bl_attr_group);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to create attribute. err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void sky81452_bl_remove(struct platform_device *pdev)\n{\n\tconst struct sky81452_bl_platform_data *pdata =\n\t\t\t\t\t\tdev_get_platdata(&pdev->dev);\n\tstruct backlight_device *bd = platform_get_drvdata(pdev);\n\n\tsysfs_remove_group(&bd->dev.kobj, &sky81452_bl_attr_group);\n\n\tbd->props.power = FB_BLANK_UNBLANK;\n\tbd->props.brightness = 0;\n\tbacklight_update_status(bd);\n\n\tif (pdata->gpiod_enable)\n\t\tgpiod_set_value_cansleep(pdata->gpiod_enable, 0);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id sky81452_bl_of_match[] = {\n\t{ .compatible = \"skyworks,sky81452-backlight\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sky81452_bl_of_match);\n#endif\n\nstatic struct platform_driver sky81452_bl_driver = {\n\t.driver = {\n\t\t.name = \"sky81452-backlight\",\n\t\t.of_match_table = of_match_ptr(sky81452_bl_of_match),\n\t},\n\t.probe = sky81452_bl_probe,\n\t.remove_new = sky81452_bl_remove,\n};\n\nmodule_platform_driver(sky81452_bl_driver);\n\nMODULE_DESCRIPTION(\"Skyworks SKY81452 backlight driver\");\nMODULE_AUTHOR(\"Gyungoh Yoo <jack.yoo@skyworksinc.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}