{
  "module_name": "ktz8866.c",
  "hash_id": "b86d298fd46ad95d83b4b0fd08abce0c6f1922b570aec3e0e2450f2fd267eb45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/ktz8866.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#define DEFAULT_BRIGHTNESS 1500\n#define MAX_BRIGHTNESS 2047\n#define REG_MAX 0x15\n\n \n#define DEVICE_ID 0x01\n#define BL_CFG1 0x02\n#define BL_CFG2 0x03\n#define BL_BRT_LSB 0x04\n#define BL_BRT_MSB 0x05\n#define BL_EN 0x08\n#define LCD_BIAS_CFG1 0x09\n#define LCD_BIAS_CFG2 0x0A\n#define LCD_BIAS_CFG3 0x0B\n#define LCD_BOOST_CFG 0x0C\n#define OUTP_CFG 0x0D\n#define OUTN_CFG 0x0E\n#define FLAG 0x0F\n#define BL_OPTION1 0x10\n#define BL_OPTION2 0x11\n#define PWM2DIG_LSBs 0x12\n#define PWM2DIG_MSBs 0x13\n#define BL_DIMMING 0x14\n#define PWM_RAMP_TIME 0x15\n\n \n#define BL_EN_BIT BIT(6)\n#define LCD_BIAS_EN 0x9F\n#define PWM_HYST 0x5\n\nstruct ktz8866 {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tbool led_on;\n\tstruct gpio_desc *enable_gpio;\n};\n\nstatic const struct regmap_config ktz8866_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = REG_MAX,\n};\n\nstatic int ktz8866_write(struct ktz8866 *ktz, unsigned int reg,\n\t\t\t unsigned int val)\n{\n\treturn regmap_write(ktz->regmap, reg, val);\n}\n\nstatic int ktz8866_update_bits(struct ktz8866 *ktz, unsigned int reg,\n\t\t\t       unsigned int mask, unsigned int val)\n{\n\treturn regmap_update_bits(ktz->regmap, reg, mask, val);\n}\n\nstatic int ktz8866_backlight_update_status(struct backlight_device *backlight_dev)\n{\n\tstruct ktz8866 *ktz = bl_get_data(backlight_dev);\n\tunsigned int brightness = backlight_get_brightness(backlight_dev);\n\n\tif (!ktz->led_on && brightness > 0) {\n\t\tktz8866_update_bits(ktz, BL_EN, BL_EN_BIT, BL_EN_BIT);\n\t\tktz->led_on = true;\n\t} else if (brightness == 0) {\n\t\tktz8866_update_bits(ktz, BL_EN, BL_EN_BIT, 0);\n\t\tktz->led_on = false;\n\t}\n\n\t \n\tktz8866_write(ktz, BL_BRT_LSB, brightness & 0x7);\n\tktz8866_write(ktz, BL_BRT_MSB, (brightness >> 3) & 0xFF);\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops ktz8866_backlight_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.update_status = ktz8866_backlight_update_status,\n};\n\nstatic void ktz8866_init(struct ktz8866 *ktz)\n{\n\tunsigned int val = 0;\n\n\tif (of_property_read_u32(ktz->client->dev.of_node, \"current-num-sinks\", &val))\n\t\tktz8866_write(ktz, BL_EN, BIT(val) - 1);\n\telse\n\t\t \n\t\tktz8866_write(ktz, BL_EN, BIT(6) - 1);\n\n\tif (of_property_read_u32(ktz->client->dev.of_node, \"kinetic,current-ramp-delay-ms\", &val)) {\n\t\tif (val <= 128)\n\t\t\tktz8866_write(ktz, BL_CFG2, BIT(7) | (ilog2(val) << 3) | PWM_HYST);\n\t\telse\n\t\t\tktz8866_write(ktz, BL_CFG2, BIT(7) | ((5 + val / 64) << 3) | PWM_HYST);\n\t}\n\n\tif (of_property_read_u32(ktz->client->dev.of_node, \"kinetic,led-enable-ramp-delay-ms\", &val)) {\n\t\tif (val == 0)\n\t\t\tktz8866_write(ktz, BL_DIMMING, 0);\n\t\telse {\n\t\t\tunsigned int ramp_off_time = ilog2(val) + 1;\n\t\t\tunsigned int ramp_on_time = ramp_off_time << 4;\n\t\t\tktz8866_write(ktz, BL_DIMMING, ramp_on_time | ramp_off_time);\n\t\t}\n\t}\n\n\tif (of_property_read_bool(ktz->client->dev.of_node, \"kinetic,enable-lcd-bias\"))\n\t\tktz8866_write(ktz, LCD_BIAS_CFG1, LCD_BIAS_EN);\n}\n\nstatic int ktz8866_probe(struct i2c_client *client)\n{\n\tstruct backlight_device *backlight_dev;\n\tstruct backlight_properties props;\n\tstruct ktz8866 *ktz;\n\tint ret = 0;\n\n\tktz = devm_kzalloc(&client->dev, sizeof(*ktz), GFP_KERNEL);\n\tif (!ktz)\n\t\treturn -ENOMEM;\n\n\tktz->client = client;\n\tktz->regmap = devm_regmap_init_i2c(client, &ktz8866_regmap_config);\n\tif (IS_ERR(ktz->regmap))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(ktz->regmap), \"failed to init regmap\\n\");\n\n\tret = devm_regulator_get_enable(&client->dev, \"vddpos\");\n\tif (ret)\n\t\treturn dev_err_probe(&client->dev, ret, \"get regulator vddpos failed\\n\");\n\tret = devm_regulator_get_enable(&client->dev, \"vddneg\");\n\tif (ret)\n\t\treturn dev_err_probe(&client->dev, ret, \"get regulator vddneg failed\\n\");\n\n\tktz->enable_gpio = devm_gpiod_get_optional(&client->dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ktz->enable_gpio))\n\t\treturn PTR_ERR(ktz->enable_gpio);\n\n\tmemset(&props, 0, sizeof(props));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = MAX_BRIGHTNESS;\n\tprops.brightness = DEFAULT_BRIGHTNESS;\n\tprops.scale = BACKLIGHT_SCALE_LINEAR;\n\n\tbacklight_dev = devm_backlight_device_register(&client->dev, \"ktz8866-backlight\",\n\t\t\t\t\t&client->dev, ktz, &ktz8866_backlight_ops, &props);\n\tif (IS_ERR(backlight_dev))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(backlight_dev),\n\t\t\t\t\"failed to register backlight device\\n\");\n\n\tktz8866_init(ktz);\n\n\ti2c_set_clientdata(client, backlight_dev);\n\tbacklight_update_status(backlight_dev);\n\n\treturn 0;\n}\n\nstatic void ktz8866_remove(struct i2c_client *client)\n{\n\tstruct backlight_device *backlight_dev = i2c_get_clientdata(client);\n\tbacklight_dev->props.brightness = 0;\n\tbacklight_update_status(backlight_dev);\n}\n\nstatic const struct i2c_device_id ktz8866_ids[] = {\n\t{ \"ktz8866\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, ktz8866_ids);\n\nstatic const struct of_device_id ktz8866_match_table[] = {\n\t{\n\t\t.compatible = \"kinetic,ktz8866\",\n\t},\n\t{},\n};\n\nstatic struct i2c_driver ktz8866_driver = {\n\t.driver = {\n\t\t.name = \"ktz8866\",\n\t\t.of_match_table = ktz8866_match_table,\n\t},\n\t.probe = ktz8866_probe,\n\t.remove = ktz8866_remove,\n\t.id_table = ktz8866_ids,\n};\n\nmodule_i2c_driver(ktz8866_driver);\n\nMODULE_DESCRIPTION(\"Kinetic KTZ8866 Backlight Driver\");\nMODULE_AUTHOR(\"Jianhua Lu <lujianhua000@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}