{
  "module_name": "adp8870_bl.c",
  "hash_id": "576e03711da3874fc06879d894f4ffe00f06568fbe3ac966e034982e5cb12475",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/backlight/adp8870_bl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/pm.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/fb.h>\n#include <linux/backlight.h>\n#include <linux/leds.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n\n#include <linux/platform_data/adp8870.h>\n#define ADP8870_EXT_FEATURES\n#define ADP8870_USE_LEDS\n\n\n#define ADP8870_MFDVID\t0x00   \n#define ADP8870_MDCR\t0x01   \n#define ADP8870_INT_STAT 0x02   \n#define ADP8870_INT_EN\t0x03   \n#define ADP8870_CFGR\t0x04   \n#define ADP8870_BLSEL\t0x05   \n#define ADP8870_PWMLED\t0x06   \n#define ADP8870_BLOFF\t0x07   \n#define ADP8870_BLDIM\t0x08   \n#define ADP8870_BLFR\t0x09   \n#define ADP8870_BLMX1\t0x0A   \n#define ADP8870_BLDM1\t0x0B   \n#define ADP8870_BLMX2\t0x0C   \n#define ADP8870_BLDM2\t0x0D   \n#define ADP8870_BLMX3\t0x0E   \n#define ADP8870_BLDM3\t0x0F   \n#define ADP8870_BLMX4\t0x10   \n#define ADP8870_BLDM4\t0x11   \n#define ADP8870_BLMX5\t0x12   \n#define ADP8870_BLDM5\t0x13   \n#define ADP8870_ISCLAW\t0x1A   \n#define ADP8870_ISCC\t0x1B   \n#define ADP8870_ISCT1\t0x1C   \n#define ADP8870_ISCT2\t0x1D   \n#define ADP8870_ISCF\t0x1E   \n#define ADP8870_ISC1\t0x1F   \n#define ADP8870_ISC2\t0x20   \n#define ADP8870_ISC3\t0x21   \n#define ADP8870_ISC4\t0x22   \n#define ADP8870_ISC5\t0x23   \n#define ADP8870_ISC6\t0x24   \n#define ADP8870_ISC7\t0x25   \n#define ADP8870_ISC7_L2\t0x26   \n#define ADP8870_ISC7_L3\t0x27   \n#define ADP8870_ISC7_L4\t0x28   \n#define ADP8870_ISC7_L5\t0x29   \n#define ADP8870_CMP_CTL\t0x2D   \n#define ADP8870_ALS1_EN\t0x2E   \n#define ADP8870_ALS2_EN\t0x2F   \n#define ADP8870_ALS1_STAT 0x30   \n#define ADP8870_ALS2_STAT 0x31   \n#define ADP8870_L2TRP\t0x32   \n#define ADP8870_L2HYS\t0x33   \n#define ADP8870_L3TRP\t0x34   \n#define ADP8870_L3HYS\t0x35   \n#define ADP8870_L4TRP\t0x36   \n#define ADP8870_L4HYS\t0x37   \n#define ADP8870_L5TRP\t0x38   \n#define ADP8870_L5HYS\t0x39   \n#define ADP8870_PH1LEVL\t0x40   \n#define ADP8870_PH1LEVH\t0x41   \n#define ADP8870_PH2LEVL\t0x42   \n#define ADP8870_PH2LEVH\t0x43   \n\n#define ADP8870_MANUFID\t\t0x3   \n#define ADP8870_DEVID(x)\t((x) & 0xF)\n#define ADP8870_MANID(x)\t((x) >> 4)\n\n \n#define D7ALSEN\t\t\t(1 << 7)\n#define INT_CFG\t\t\t(1 << 6)\n#define NSTBY\t\t\t(1 << 5)\n#define DIM_EN\t\t\t(1 << 4)\n#define GDWN_DIS\t\t(1 << 3)\n#define SIS_EN\t\t\t(1 << 2)\n#define CMP_AUTOEN\t\t(1 << 1)\n#define BLEN\t\t\t(1 << 0)\n\n \n#define L5_EN\t\t\t(1 << 3)\n#define L4_EN\t\t\t(1 << 2)\n#define L3_EN\t\t\t(1 << 1)\n#define L2_EN\t\t\t(1 << 0)\n\n#define CFGR_BLV_SHIFT\t\t3\n#define CFGR_BLV_MASK\t\t0x7\n#define ADP8870_FLAG_LED_MASK\t0xFF\n\n#define FADE_VAL(in, out)\t((0xF & (in)) | ((0xF & (out)) << 4))\n#define BL_CFGR_VAL(law, blv)\t((((blv) & CFGR_BLV_MASK) << CFGR_BLV_SHIFT) | ((0x3 & (law)) << 1))\n#define ALS_CMPR_CFG_VAL(filt)\t((0x7 & (filt)) << 1)\n\nstruct adp8870_bl {\n\tstruct i2c_client *client;\n\tstruct backlight_device *bl;\n\tstruct adp8870_led *led;\n\tstruct adp8870_backlight_platform_data *pdata;\n\tstruct mutex lock;\n\tunsigned long cached_daylight_max;\n\tint id;\n\tint revid;\n\tint current_brightness;\n};\n\nstruct adp8870_led {\n\tstruct led_classdev\tcdev;\n\tstruct work_struct\twork;\n\tstruct i2c_client\t*client;\n\tenum led_brightness\tnew_brightness;\n\tint\t\t\tid;\n\tint\t\t\tflags;\n};\n\nstatic int adp8870_read(struct i2c_client *client, int reg, uint8_t *val)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, reg);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed reading at 0x%02x\\n\", reg);\n\t\treturn ret;\n\t}\n\n\t*val = ret;\n\treturn 0;\n}\n\n\nstatic int adp8870_write(struct i2c_client *client, u8 reg, u8 val)\n{\n\tint ret = i2c_smbus_write_byte_data(client, reg, val);\n\n\tif (ret)\n\t\tdev_err(&client->dev, \"failed to write\\n\");\n\n\treturn ret;\n}\n\nstatic int adp8870_set_bits(struct i2c_client *client, int reg, uint8_t bit_mask)\n{\n\tstruct adp8870_bl *data = i2c_get_clientdata(client);\n\tuint8_t reg_val;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\tret = adp8870_read(client, reg, &reg_val);\n\n\tif (!ret && ((reg_val & bit_mask) != bit_mask)) {\n\t\treg_val |= bit_mask;\n\t\tret = adp8870_write(client, reg, reg_val);\n\t}\n\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int adp8870_clr_bits(struct i2c_client *client, int reg, uint8_t bit_mask)\n{\n\tstruct adp8870_bl *data = i2c_get_clientdata(client);\n\tuint8_t reg_val;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\tret = adp8870_read(client, reg, &reg_val);\n\n\tif (!ret && (reg_val & bit_mask)) {\n\t\treg_val &= ~bit_mask;\n\t\tret = adp8870_write(client, reg, reg_val);\n\t}\n\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\n \n#if defined(ADP8870_USE_LEDS)\nstatic void adp8870_led_work(struct work_struct *work)\n{\n\tstruct adp8870_led *led = container_of(work, struct adp8870_led, work);\n\n\tadp8870_write(led->client, ADP8870_ISC1 + led->id - 1,\n\t\t\t led->new_brightness >> 1);\n}\n\nstatic void adp8870_led_set(struct led_classdev *led_cdev,\n\t\t\t   enum led_brightness value)\n{\n\tstruct adp8870_led *led;\n\n\tled = container_of(led_cdev, struct adp8870_led, cdev);\n\tled->new_brightness = value;\n\t \n\tschedule_work(&led->work);\n}\n\nstatic int adp8870_led_setup(struct adp8870_led *led)\n{\n\tstruct i2c_client *client = led->client;\n\tint ret = 0;\n\n\tret = adp8870_write(client, ADP8870_ISC1 + led->id - 1, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adp8870_set_bits(client, ADP8870_ISCC, 1 << (led->id - 1));\n\tif (ret)\n\t\treturn ret;\n\n\tif (led->id > 4)\n\t\tret = adp8870_set_bits(client, ADP8870_ISCT1,\n\t\t\t\t(led->flags & 0x3) << ((led->id - 5) * 2));\n\telse\n\t\tret = adp8870_set_bits(client, ADP8870_ISCT2,\n\t\t\t\t(led->flags & 0x3) << ((led->id - 1) * 2));\n\n\treturn ret;\n}\n\nstatic int adp8870_led_probe(struct i2c_client *client)\n{\n\tstruct adp8870_backlight_platform_data *pdata =\n\t\tdev_get_platdata(&client->dev);\n\tstruct adp8870_bl *data = i2c_get_clientdata(client);\n\tstruct adp8870_led *led, *led_dat;\n\tstruct led_info *cur_led;\n\tint ret, i;\n\n\tled = devm_kcalloc(&client->dev, pdata->num_leds, sizeof(*led),\n\t\t\t\tGFP_KERNEL);\n\tif (led == NULL)\n\t\treturn -ENOMEM;\n\n\tret = adp8870_write(client, ADP8870_ISCLAW, pdata->led_fade_law);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adp8870_write(client, ADP8870_ISCT1,\n\t\t\t(pdata->led_on_time & 0x3) << 6);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adp8870_write(client, ADP8870_ISCF,\n\t\t\tFADE_VAL(pdata->led_fade_in, pdata->led_fade_out));\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < pdata->num_leds; ++i) {\n\t\tcur_led = &pdata->leds[i];\n\t\tled_dat = &led[i];\n\n\t\tled_dat->id = cur_led->flags & ADP8870_FLAG_LED_MASK;\n\n\t\tif (led_dat->id > 7 || led_dat->id < 1) {\n\t\t\tdev_err(&client->dev, \"Invalid LED ID %d\\n\",\n\t\t\t\tled_dat->id);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (pdata->bl_led_assign & (1 << (led_dat->id - 1))) {\n\t\t\tdev_err(&client->dev, \"LED %d used by Backlight\\n\",\n\t\t\t\tled_dat->id);\n\t\t\tret = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\n\t\tled_dat->cdev.name = cur_led->name;\n\t\tled_dat->cdev.default_trigger = cur_led->default_trigger;\n\t\tled_dat->cdev.brightness_set = adp8870_led_set;\n\t\tled_dat->cdev.brightness = LED_OFF;\n\t\tled_dat->flags = cur_led->flags >> FLAG_OFFT_SHIFT;\n\t\tled_dat->client = client;\n\t\tled_dat->new_brightness = LED_OFF;\n\t\tINIT_WORK(&led_dat->work, adp8870_led_work);\n\n\t\tret = led_classdev_register(&client->dev, &led_dat->cdev);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"failed to register LED %d\\n\",\n\t\t\t\tled_dat->id);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = adp8870_led_setup(led_dat);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"failed to write\\n\");\n\t\t\ti++;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tdata->led = led;\n\n\treturn 0;\n\n err:\n\tfor (i = i - 1; i >= 0; --i) {\n\t\tled_classdev_unregister(&led[i].cdev);\n\t\tcancel_work_sync(&led[i].work);\n\t}\n\n\treturn ret;\n}\n\nstatic int adp8870_led_remove(struct i2c_client *client)\n{\n\tstruct adp8870_backlight_platform_data *pdata =\n\t\tdev_get_platdata(&client->dev);\n\tstruct adp8870_bl *data = i2c_get_clientdata(client);\n\tint i;\n\n\tfor (i = 0; i < pdata->num_leds; i++) {\n\t\tled_classdev_unregister(&data->led[i].cdev);\n\t\tcancel_work_sync(&data->led[i].work);\n\t}\n\n\treturn 0;\n}\n#else\nstatic int adp8870_led_probe(struct i2c_client *client)\n{\n\treturn 0;\n}\n\nstatic int adp8870_led_remove(struct i2c_client *client)\n{\n\treturn 0;\n}\n#endif\n\nstatic int adp8870_bl_set(struct backlight_device *bl, int brightness)\n{\n\tstruct adp8870_bl *data = bl_get_data(bl);\n\tstruct i2c_client *client = data->client;\n\tint ret = 0;\n\n\tif (data->pdata->en_ambl_sens) {\n\t\tif ((brightness > 0) && (brightness < ADP8870_MAX_BRIGHTNESS)) {\n\t\t\t \n\t\t\tret = adp8870_clr_bits(client, ADP8870_MDCR,\n\t\t\t\t\tCMP_AUTOEN);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = adp8870_write(client, ADP8870_BLMX1, brightness);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\t \n\t\t\tret = adp8870_write(client, ADP8870_BLMX1,\n\t\t\t\t\t data->cached_daylight_max);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = adp8870_set_bits(client, ADP8870_MDCR,\n\t\t\t\t\t CMP_AUTOEN);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = adp8870_write(client, ADP8870_BLMX1, brightness);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (data->current_brightness && brightness == 0)\n\t\tret = adp8870_set_bits(client,\n\t\t\t\tADP8870_MDCR, DIM_EN);\n\telse if (data->current_brightness == 0 && brightness)\n\t\tret = adp8870_clr_bits(client,\n\t\t\t\tADP8870_MDCR, DIM_EN);\n\n\tif (!ret)\n\t\tdata->current_brightness = brightness;\n\n\treturn ret;\n}\n\nstatic int adp8870_bl_update_status(struct backlight_device *bl)\n{\n\treturn adp8870_bl_set(bl, backlight_get_brightness(bl));\n}\n\nstatic int adp8870_bl_get_brightness(struct backlight_device *bl)\n{\n\tstruct adp8870_bl *data = bl_get_data(bl);\n\n\treturn data->current_brightness;\n}\n\nstatic const struct backlight_ops adp8870_bl_ops = {\n\t.update_status\t= adp8870_bl_update_status,\n\t.get_brightness\t= adp8870_bl_get_brightness,\n};\n\nstatic int adp8870_bl_setup(struct backlight_device *bl)\n{\n\tstruct adp8870_bl *data = bl_get_data(bl);\n\tstruct i2c_client *client = data->client;\n\tstruct adp8870_backlight_platform_data *pdata = data->pdata;\n\tint ret = 0;\n\n\tret = adp8870_write(client, ADP8870_BLSEL, ~pdata->bl_led_assign);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adp8870_write(client, ADP8870_PWMLED, pdata->pwm_assign);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adp8870_write(client, ADP8870_BLMX1, pdata->l1_daylight_max);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adp8870_write(client, ADP8870_BLDM1, pdata->l1_daylight_dim);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pdata->en_ambl_sens) {\n\t\tdata->cached_daylight_max = pdata->l1_daylight_max;\n\t\tret = adp8870_write(client, ADP8870_BLMX2,\n\t\t\t\t\t\tpdata->l2_bright_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = adp8870_write(client, ADP8870_BLDM2,\n\t\t\t\t\t\tpdata->l2_bright_dim);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_BLMX3,\n\t\t\t\t\t\tpdata->l3_office_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = adp8870_write(client, ADP8870_BLDM3,\n\t\t\t\t\t\tpdata->l3_office_dim);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_BLMX4,\n\t\t\t\t\t\tpdata->l4_indoor_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_BLDM4,\n\t\t\t\t\t\tpdata->l4_indor_dim);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_BLMX5,\n\t\t\t\t\t\tpdata->l5_dark_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_BLDM5,\n\t\t\t\t\t\tpdata->l5_dark_dim);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_L2TRP, pdata->l2_trip);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_L2HYS, pdata->l2_hyst);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_L3TRP, pdata->l3_trip);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_L3HYS, pdata->l3_hyst);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_L4TRP, pdata->l4_trip);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_L4HYS, pdata->l4_hyst);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_L5TRP, pdata->l5_trip);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_L5HYS, pdata->l5_hyst);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_ALS1_EN, L5_EN | L4_EN |\n\t\t\t\t\t\tL3_EN | L2_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adp8870_write(client, ADP8870_CMP_CTL,\n\t\t\tALS_CMPR_CFG_VAL(pdata->abml_filt));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = adp8870_write(client, ADP8870_CFGR,\n\t\t\tBL_CFGR_VAL(pdata->bl_fade_law, 0));\n\tif (ret)\n\t\treturn ret;\n\n\tret = adp8870_write(client, ADP8870_BLFR, FADE_VAL(pdata->bl_fade_in,\n\t\t\tpdata->bl_fade_out));\n\tif (ret)\n\t\treturn ret;\n\t \n\n\tret = adp8870_set_bits(client, ADP8870_MDCR, BLEN | DIM_EN | NSTBY |\n\t\t\t(data->revid == 0 ? GDWN_DIS : 0));\n\n\treturn ret;\n}\n\nstatic ssize_t adp8870_show(struct device *dev, char *buf, int reg)\n{\n\tstruct adp8870_bl *data = dev_get_drvdata(dev);\n\tint error;\n\tuint8_t reg_val;\n\n\tmutex_lock(&data->lock);\n\terror = adp8870_read(data->client, reg, &reg_val);\n\tmutex_unlock(&data->lock);\n\n\tif (error < 0)\n\t\treturn error;\n\n\treturn sprintf(buf, \"%u\\n\", reg_val);\n}\n\nstatic ssize_t adp8870_store(struct device *dev, const char *buf,\n\t\t\t size_t count, int reg)\n{\n\tstruct adp8870_bl *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&data->lock);\n\tadp8870_write(data->client, reg, val);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t adp8870_bl_l5_dark_max_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp8870_show(dev, buf, ADP8870_BLMX5);\n}\n\nstatic ssize_t adp8870_bl_l5_dark_max_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn adp8870_store(dev, buf, count, ADP8870_BLMX5);\n}\nstatic DEVICE_ATTR(l5_dark_max, 0664, adp8870_bl_l5_dark_max_show,\n\t\t\tadp8870_bl_l5_dark_max_store);\n\n\nstatic ssize_t adp8870_bl_l4_indoor_max_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp8870_show(dev, buf, ADP8870_BLMX4);\n}\n\nstatic ssize_t adp8870_bl_l4_indoor_max_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn adp8870_store(dev, buf, count, ADP8870_BLMX4);\n}\nstatic DEVICE_ATTR(l4_indoor_max, 0664, adp8870_bl_l4_indoor_max_show,\n\t\t\tadp8870_bl_l4_indoor_max_store);\n\n\nstatic ssize_t adp8870_bl_l3_office_max_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn adp8870_show(dev, buf, ADP8870_BLMX3);\n}\n\nstatic ssize_t adp8870_bl_l3_office_max_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn adp8870_store(dev, buf, count, ADP8870_BLMX3);\n}\n\nstatic DEVICE_ATTR(l3_office_max, 0664, adp8870_bl_l3_office_max_show,\n\t\t\tadp8870_bl_l3_office_max_store);\n\nstatic ssize_t adp8870_bl_l2_bright_max_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp8870_show(dev, buf, ADP8870_BLMX2);\n}\n\nstatic ssize_t adp8870_bl_l2_bright_max_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn adp8870_store(dev, buf, count, ADP8870_BLMX2);\n}\nstatic DEVICE_ATTR(l2_bright_max, 0664, adp8870_bl_l2_bright_max_show,\n\t\t\tadp8870_bl_l2_bright_max_store);\n\nstatic ssize_t adp8870_bl_l1_daylight_max_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp8870_show(dev, buf, ADP8870_BLMX1);\n}\n\nstatic ssize_t adp8870_bl_l1_daylight_max_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct adp8870_bl *data = dev_get_drvdata(dev);\n\tint ret = kstrtoul(buf, 10, &data->cached_daylight_max);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn adp8870_store(dev, buf, count, ADP8870_BLMX1);\n}\nstatic DEVICE_ATTR(l1_daylight_max, 0664, adp8870_bl_l1_daylight_max_show,\n\t\t\tadp8870_bl_l1_daylight_max_store);\n\nstatic ssize_t adp8870_bl_l5_dark_dim_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp8870_show(dev, buf, ADP8870_BLDM5);\n}\n\nstatic ssize_t adp8870_bl_l5_dark_dim_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\treturn adp8870_store(dev, buf, count, ADP8870_BLDM5);\n}\nstatic DEVICE_ATTR(l5_dark_dim, 0664, adp8870_bl_l5_dark_dim_show,\n\t\t\tadp8870_bl_l5_dark_dim_store);\n\nstatic ssize_t adp8870_bl_l4_indoor_dim_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp8870_show(dev, buf, ADP8870_BLDM4);\n}\n\nstatic ssize_t adp8870_bl_l4_indoor_dim_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\treturn adp8870_store(dev, buf, count, ADP8870_BLDM4);\n}\nstatic DEVICE_ATTR(l4_indoor_dim, 0664, adp8870_bl_l4_indoor_dim_show,\n\t\t\tadp8870_bl_l4_indoor_dim_store);\n\n\nstatic ssize_t adp8870_bl_l3_office_dim_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp8870_show(dev, buf, ADP8870_BLDM3);\n}\n\nstatic ssize_t adp8870_bl_l3_office_dim_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\treturn adp8870_store(dev, buf, count, ADP8870_BLDM3);\n}\nstatic DEVICE_ATTR(l3_office_dim, 0664, adp8870_bl_l3_office_dim_show,\n\t\t\tadp8870_bl_l3_office_dim_store);\n\nstatic ssize_t adp8870_bl_l2_bright_dim_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn adp8870_show(dev, buf, ADP8870_BLDM2);\n}\n\nstatic ssize_t adp8870_bl_l2_bright_dim_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\treturn adp8870_store(dev, buf, count, ADP8870_BLDM2);\n}\nstatic DEVICE_ATTR(l2_bright_dim, 0664, adp8870_bl_l2_bright_dim_show,\n\t\t\tadp8870_bl_l2_bright_dim_store);\n\nstatic ssize_t adp8870_bl_l1_daylight_dim_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn adp8870_show(dev, buf, ADP8870_BLDM1);\n}\n\nstatic ssize_t adp8870_bl_l1_daylight_dim_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\treturn adp8870_store(dev, buf, count, ADP8870_BLDM1);\n}\nstatic DEVICE_ATTR(l1_daylight_dim, 0664, adp8870_bl_l1_daylight_dim_show,\n\t\t\tadp8870_bl_l1_daylight_dim_store);\n\n#ifdef ADP8870_EXT_FEATURES\nstatic ssize_t adp8870_bl_ambient_light_level_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct adp8870_bl *data = dev_get_drvdata(dev);\n\tint error;\n\tuint8_t reg_val;\n\tuint16_t ret_val;\n\n\tmutex_lock(&data->lock);\n\terror = adp8870_read(data->client, ADP8870_PH1LEVL, &reg_val);\n\tif (error < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn error;\n\t}\n\tret_val = reg_val;\n\terror = adp8870_read(data->client, ADP8870_PH1LEVH, &reg_val);\n\tmutex_unlock(&data->lock);\n\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\tret_val += (reg_val & 0x1F) << 8;\n\n\treturn sprintf(buf, \"%u\\n\", ret_val);\n}\nstatic DEVICE_ATTR(ambient_light_level, 0444,\n\t\tadp8870_bl_ambient_light_level_show, NULL);\n\nstatic ssize_t adp8870_bl_ambient_light_zone_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct adp8870_bl *data = dev_get_drvdata(dev);\n\tint error;\n\tuint8_t reg_val;\n\n\tmutex_lock(&data->lock);\n\terror = adp8870_read(data->client, ADP8870_CFGR, &reg_val);\n\tmutex_unlock(&data->lock);\n\n\tif (error < 0)\n\t\treturn error;\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t((reg_val >> CFGR_BLV_SHIFT) & CFGR_BLV_MASK) + 1);\n}\n\nstatic ssize_t adp8870_bl_ambient_light_zone_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct adp8870_bl *data = dev_get_drvdata(dev);\n\tunsigned long val;\n\tuint8_t reg_val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val == 0) {\n\t\t \n\t\tadp8870_set_bits(data->client, ADP8870_MDCR, CMP_AUTOEN);\n\t} else if ((val > 0) && (val < 6)) {\n\t\t \n\t\tadp8870_clr_bits(data->client, ADP8870_MDCR, CMP_AUTOEN);\n\n\t\t \n\t\tmutex_lock(&data->lock);\n\t\tret = adp8870_read(data->client, ADP8870_CFGR, &reg_val);\n\t\tif (!ret) {\n\t\t\treg_val &= ~(CFGR_BLV_MASK << CFGR_BLV_SHIFT);\n\t\t\treg_val |= (val - 1) << CFGR_BLV_SHIFT;\n\t\t\tadp8870_write(data->client, ADP8870_CFGR, reg_val);\n\t\t}\n\t\tmutex_unlock(&data->lock);\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR(ambient_light_zone, 0664,\n\t\tadp8870_bl_ambient_light_zone_show,\n\t\tadp8870_bl_ambient_light_zone_store);\n#endif\n\nstatic struct attribute *adp8870_bl_attributes[] = {\n\t&dev_attr_l5_dark_max.attr,\n\t&dev_attr_l5_dark_dim.attr,\n\t&dev_attr_l4_indoor_max.attr,\n\t&dev_attr_l4_indoor_dim.attr,\n\t&dev_attr_l3_office_max.attr,\n\t&dev_attr_l3_office_dim.attr,\n\t&dev_attr_l2_bright_max.attr,\n\t&dev_attr_l2_bright_dim.attr,\n\t&dev_attr_l1_daylight_max.attr,\n\t&dev_attr_l1_daylight_dim.attr,\n#ifdef ADP8870_EXT_FEATURES\n\t&dev_attr_ambient_light_level.attr,\n\t&dev_attr_ambient_light_zone.attr,\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group adp8870_bl_attr_group = {\n\t.attrs = adp8870_bl_attributes,\n};\n\nstatic int adp8870_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct backlight_properties props;\n\tstruct backlight_device *bl;\n\tstruct adp8870_bl *data;\n\tstruct adp8870_backlight_platform_data *pdata =\n\t\tdev_get_platdata(&client->dev);\n\tuint8_t reg_val;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t\tI2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&client->dev, \"SMBUS Byte Data not Supported\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (!pdata) {\n\t\tdev_err(&client->dev, \"no platform data?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adp8870_read(client, ADP8870_MFDVID, &reg_val);\n\tif (ret < 0)\n\t\treturn -EIO;\n\n\tif (ADP8870_MANID(reg_val) != ADP8870_MANUFID) {\n\t\tdev_err(&client->dev, \"failed to probe\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tdata->revid = ADP8870_DEVID(reg_val);\n\tdata->client = client;\n\tdata->pdata = pdata;\n\tdata->id = id->driver_data;\n\tdata->current_brightness = 0;\n\ti2c_set_clientdata(client, data);\n\n\tmutex_init(&data->lock);\n\n\tmemset(&props, 0, sizeof(props));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = props.brightness = ADP8870_MAX_BRIGHTNESS;\n\tbl = devm_backlight_device_register(&client->dev,\n\t\t\t\tdev_driver_string(&client->dev),\n\t\t\t\t&client->dev, data, &adp8870_bl_ops, &props);\n\tif (IS_ERR(bl)) {\n\t\tdev_err(&client->dev, \"failed to register backlight\\n\");\n\t\treturn PTR_ERR(bl);\n\t}\n\n\tdata->bl = bl;\n\n\tif (pdata->en_ambl_sens) {\n\t\tret = sysfs_create_group(&bl->dev.kobj,\n\t\t\t&adp8870_bl_attr_group);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"failed to register sysfs\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = adp8870_bl_setup(bl);\n\tif (ret) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tbacklight_update_status(bl);\n\n\tdev_info(&client->dev, \"Rev.%d Backlight\\n\", data->revid);\n\n\tif (pdata->num_leds)\n\t\tadp8870_led_probe(client);\n\n\treturn 0;\n\nout:\n\tif (data->pdata->en_ambl_sens)\n\t\tsysfs_remove_group(&data->bl->dev.kobj,\n\t\t\t&adp8870_bl_attr_group);\n\n\treturn ret;\n}\n\nstatic void adp8870_remove(struct i2c_client *client)\n{\n\tstruct adp8870_bl *data = i2c_get_clientdata(client);\n\n\tadp8870_clr_bits(client, ADP8870_MDCR, NSTBY);\n\n\tif (data->led)\n\t\tadp8870_led_remove(client);\n\n\tif (data->pdata->en_ambl_sens)\n\t\tsysfs_remove_group(&data->bl->dev.kobj,\n\t\t\t&adp8870_bl_attr_group);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int adp8870_i2c_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tadp8870_clr_bits(client, ADP8870_MDCR, NSTBY);\n\n\treturn 0;\n}\n\nstatic int adp8870_i2c_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tadp8870_set_bits(client, ADP8870_MDCR, NSTBY | BLEN);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(adp8870_i2c_pm_ops, adp8870_i2c_suspend,\n\t\t\tadp8870_i2c_resume);\n\nstatic const struct i2c_device_id adp8870_id[] = {\n\t{ \"adp8870\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adp8870_id);\n\nstatic struct i2c_driver adp8870_driver = {\n\t.driver = {\n\t\t.name\t= KBUILD_MODNAME,\n\t\t.pm\t= &adp8870_i2c_pm_ops,\n\t},\n\t.probe = adp8870_probe,\n\t.remove = adp8870_remove,\n\t.id_table = adp8870_id,\n};\n\nmodule_i2c_driver(adp8870_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"ADP8870 Backlight driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}