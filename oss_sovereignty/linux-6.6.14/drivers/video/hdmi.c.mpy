{
  "module_name": "hdmi.c",
  "hash_id": "6a68abf0ac4c64335e98a63cb3afe2d472b9614dd3694840e1af3190d10a28f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/hdmi.c",
  "human_readable_source": " \n\n#include <drm/display/drm_dp.h>\n#include <linux/bitops.h>\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/hdmi.h>\n#include <linux/string.h>\n#include <linux/device.h>\n\n#define hdmi_log(fmt, ...) dev_printk(level, dev, fmt, ##__VA_ARGS__)\n\nstatic u8 hdmi_infoframe_checksum(const u8 *ptr, size_t size)\n{\n\tu8 csum = 0;\n\tsize_t i;\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tcsum += ptr[i];\n\n\treturn 256 - csum;\n}\n\nstatic void hdmi_infoframe_set_checksum(void *buffer, size_t size)\n{\n\tu8 *ptr = buffer;\n\n\tptr[3] = hdmi_infoframe_checksum(buffer, size);\n}\n\n \nvoid hdmi_avi_infoframe_init(struct hdmi_avi_infoframe *frame)\n{\n\tmemset(frame, 0, sizeof(*frame));\n\n\tframe->type = HDMI_INFOFRAME_TYPE_AVI;\n\tframe->version = 2;\n\tframe->length = HDMI_AVI_INFOFRAME_SIZE;\n}\nEXPORT_SYMBOL(hdmi_avi_infoframe_init);\n\nstatic int hdmi_avi_infoframe_check_only(const struct hdmi_avi_infoframe *frame)\n{\n\tif (frame->type != HDMI_INFOFRAME_TYPE_AVI ||\n\t    frame->version != 2 ||\n\t    frame->length != HDMI_AVI_INFOFRAME_SIZE)\n\t\treturn -EINVAL;\n\n\tif (frame->picture_aspect > HDMI_PICTURE_ASPECT_16_9)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint hdmi_avi_infoframe_check(struct hdmi_avi_infoframe *frame)\n{\n\treturn hdmi_avi_infoframe_check_only(frame);\n}\nEXPORT_SYMBOL(hdmi_avi_infoframe_check);\n\n \nssize_t hdmi_avi_infoframe_pack_only(const struct hdmi_avi_infoframe *frame,\n\t\t\t\t     void *buffer, size_t size)\n{\n\tu8 *ptr = buffer;\n\tsize_t length;\n\tint ret;\n\n\tret = hdmi_avi_infoframe_check_only(frame);\n\tif (ret)\n\t\treturn ret;\n\n\tlength = HDMI_INFOFRAME_HEADER_SIZE + frame->length;\n\n\tif (size < length)\n\t\treturn -ENOSPC;\n\n\tmemset(buffer, 0, size);\n\n\tptr[0] = frame->type;\n\tptr[1] = frame->version;\n\tptr[2] = frame->length;\n\tptr[3] = 0;  \n\n\t \n\tptr += HDMI_INFOFRAME_HEADER_SIZE;\n\n\tptr[0] = ((frame->colorspace & 0x3) << 5) | (frame->scan_mode & 0x3);\n\n\t \n\tif (frame->active_aspect & 0xf)\n\t\tptr[0] |= BIT(4);\n\n\t \n\tif (frame->top_bar || frame->bottom_bar)\n\t\tptr[0] |= BIT(3);\n\n\tif (frame->left_bar || frame->right_bar)\n\t\tptr[0] |= BIT(2);\n\n\tptr[1] = ((frame->colorimetry & 0x3) << 6) |\n\t\t ((frame->picture_aspect & 0x3) << 4) |\n\t\t (frame->active_aspect & 0xf);\n\n\tptr[2] = ((frame->extended_colorimetry & 0x7) << 4) |\n\t\t ((frame->quantization_range & 0x3) << 2) |\n\t\t (frame->nups & 0x3);\n\n\tif (frame->itc)\n\t\tptr[2] |= BIT(7);\n\n\tptr[3] = frame->video_code & 0x7f;\n\n\tptr[4] = ((frame->ycc_quantization_range & 0x3) << 6) |\n\t\t ((frame->content_type & 0x3) << 4) |\n\t\t (frame->pixel_repeat & 0xf);\n\n\tptr[5] = frame->top_bar & 0xff;\n\tptr[6] = (frame->top_bar >> 8) & 0xff;\n\tptr[7] = frame->bottom_bar & 0xff;\n\tptr[8] = (frame->bottom_bar >> 8) & 0xff;\n\tptr[9] = frame->left_bar & 0xff;\n\tptr[10] = (frame->left_bar >> 8) & 0xff;\n\tptr[11] = frame->right_bar & 0xff;\n\tptr[12] = (frame->right_bar >> 8) & 0xff;\n\n\thdmi_infoframe_set_checksum(buffer, length);\n\n\treturn length;\n}\nEXPORT_SYMBOL(hdmi_avi_infoframe_pack_only);\n\n \nssize_t hdmi_avi_infoframe_pack(struct hdmi_avi_infoframe *frame,\n\t\t\t\tvoid *buffer, size_t size)\n{\n\tint ret;\n\n\tret = hdmi_avi_infoframe_check(frame);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hdmi_avi_infoframe_pack_only(frame, buffer, size);\n}\nEXPORT_SYMBOL(hdmi_avi_infoframe_pack);\n\n \nint hdmi_spd_infoframe_init(struct hdmi_spd_infoframe *frame,\n\t\t\t    const char *vendor, const char *product)\n{\n\tsize_t len;\n\n\tmemset(frame, 0, sizeof(*frame));\n\n\tframe->type = HDMI_INFOFRAME_TYPE_SPD;\n\tframe->version = 1;\n\tframe->length = HDMI_SPD_INFOFRAME_SIZE;\n\n\tlen = strlen(vendor);\n\tmemcpy(frame->vendor, vendor, min(len, sizeof(frame->vendor)));\n\tlen = strlen(product);\n\tmemcpy(frame->product, product, min(len, sizeof(frame->product)));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hdmi_spd_infoframe_init);\n\nstatic int hdmi_spd_infoframe_check_only(const struct hdmi_spd_infoframe *frame)\n{\n\tif (frame->type != HDMI_INFOFRAME_TYPE_SPD ||\n\t    frame->version != 1 ||\n\t    frame->length != HDMI_SPD_INFOFRAME_SIZE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint hdmi_spd_infoframe_check(struct hdmi_spd_infoframe *frame)\n{\n\treturn hdmi_spd_infoframe_check_only(frame);\n}\nEXPORT_SYMBOL(hdmi_spd_infoframe_check);\n\n \nssize_t hdmi_spd_infoframe_pack_only(const struct hdmi_spd_infoframe *frame,\n\t\t\t\t     void *buffer, size_t size)\n{\n\tu8 *ptr = buffer;\n\tsize_t length;\n\tint ret;\n\n\tret = hdmi_spd_infoframe_check_only(frame);\n\tif (ret)\n\t\treturn ret;\n\n\tlength = HDMI_INFOFRAME_HEADER_SIZE + frame->length;\n\n\tif (size < length)\n\t\treturn -ENOSPC;\n\n\tmemset(buffer, 0, size);\n\n\tptr[0] = frame->type;\n\tptr[1] = frame->version;\n\tptr[2] = frame->length;\n\tptr[3] = 0;  \n\n\t \n\tptr += HDMI_INFOFRAME_HEADER_SIZE;\n\n\tmemcpy(ptr, frame->vendor, sizeof(frame->vendor));\n\tmemcpy(ptr + 8, frame->product, sizeof(frame->product));\n\n\tptr[24] = frame->sdi;\n\n\thdmi_infoframe_set_checksum(buffer, length);\n\n\treturn length;\n}\nEXPORT_SYMBOL(hdmi_spd_infoframe_pack_only);\n\n \nssize_t hdmi_spd_infoframe_pack(struct hdmi_spd_infoframe *frame,\n\t\t\t\tvoid *buffer, size_t size)\n{\n\tint ret;\n\n\tret = hdmi_spd_infoframe_check(frame);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hdmi_spd_infoframe_pack_only(frame, buffer, size);\n}\nEXPORT_SYMBOL(hdmi_spd_infoframe_pack);\n\n \nint hdmi_audio_infoframe_init(struct hdmi_audio_infoframe *frame)\n{\n\tmemset(frame, 0, sizeof(*frame));\n\n\tframe->type = HDMI_INFOFRAME_TYPE_AUDIO;\n\tframe->version = 1;\n\tframe->length = HDMI_AUDIO_INFOFRAME_SIZE;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hdmi_audio_infoframe_init);\n\nstatic int hdmi_audio_infoframe_check_only(const struct hdmi_audio_infoframe *frame)\n{\n\tif (frame->type != HDMI_INFOFRAME_TYPE_AUDIO ||\n\t    frame->version != 1 ||\n\t    frame->length != HDMI_AUDIO_INFOFRAME_SIZE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint hdmi_audio_infoframe_check(const struct hdmi_audio_infoframe *frame)\n{\n\treturn hdmi_audio_infoframe_check_only(frame);\n}\nEXPORT_SYMBOL(hdmi_audio_infoframe_check);\n\nstatic void\nhdmi_audio_infoframe_pack_payload(const struct hdmi_audio_infoframe *frame,\n\t\t\t\t  u8 *buffer)\n{\n\tu8 channels;\n\n\tif (frame->channels >= 2)\n\t\tchannels = frame->channels - 1;\n\telse\n\t\tchannels = 0;\n\n\tbuffer[0] = ((frame->coding_type & 0xf) << 4) | (channels & 0x7);\n\tbuffer[1] = ((frame->sample_frequency & 0x7) << 2) |\n\t\t (frame->sample_size & 0x3);\n\tbuffer[2] = frame->coding_type_ext & 0x1f;\n\tbuffer[3] = frame->channel_allocation;\n\tbuffer[4] = (frame->level_shift_value & 0xf) << 3;\n\n\tif (frame->downmix_inhibit)\n\t\tbuffer[4] |= BIT(7);\n}\n\n \nssize_t hdmi_audio_infoframe_pack_only(const struct hdmi_audio_infoframe *frame,\n\t\t\t\t       void *buffer, size_t size)\n{\n\tu8 *ptr = buffer;\n\tsize_t length;\n\tint ret;\n\n\tret = hdmi_audio_infoframe_check_only(frame);\n\tif (ret)\n\t\treturn ret;\n\n\tlength = HDMI_INFOFRAME_HEADER_SIZE + frame->length;\n\n\tif (size < length)\n\t\treturn -ENOSPC;\n\n\tmemset(buffer, 0, size);\n\n\tptr[0] = frame->type;\n\tptr[1] = frame->version;\n\tptr[2] = frame->length;\n\tptr[3] = 0;  \n\n\thdmi_audio_infoframe_pack_payload(frame,\n\t\t\t\t\t  ptr + HDMI_INFOFRAME_HEADER_SIZE);\n\n\thdmi_infoframe_set_checksum(buffer, length);\n\n\treturn length;\n}\nEXPORT_SYMBOL(hdmi_audio_infoframe_pack_only);\n\n \nssize_t hdmi_audio_infoframe_pack(struct hdmi_audio_infoframe *frame,\n\t\t\t\t  void *buffer, size_t size)\n{\n\tint ret;\n\n\tret = hdmi_audio_infoframe_check(frame);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hdmi_audio_infoframe_pack_only(frame, buffer, size);\n}\nEXPORT_SYMBOL(hdmi_audio_infoframe_pack);\n\n \nssize_t\nhdmi_audio_infoframe_pack_for_dp(const struct hdmi_audio_infoframe *frame,\n\t\t\t\t struct dp_sdp *sdp, u8 dp_version)\n{\n\tint ret;\n\n\tret = hdmi_audio_infoframe_check(frame);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(sdp->db, 0, sizeof(sdp->db));\n\n\t \n\tsdp->sdp_header.HB0 = 0;\n\tsdp->sdp_header.HB1 = frame->type;\n\tsdp->sdp_header.HB2 = DP_SDP_AUDIO_INFOFRAME_HB2;\n\tsdp->sdp_header.HB3 = (dp_version & 0x3f) << 2;\n\n\thdmi_audio_infoframe_pack_payload(frame, sdp->db);\n\n\t \n\treturn frame->length + 4;\n}\nEXPORT_SYMBOL(hdmi_audio_infoframe_pack_for_dp);\n\n \nint hdmi_vendor_infoframe_init(struct hdmi_vendor_infoframe *frame)\n{\n\tmemset(frame, 0, sizeof(*frame));\n\n\tframe->type = HDMI_INFOFRAME_TYPE_VENDOR;\n\tframe->version = 1;\n\n\tframe->oui = HDMI_IEEE_OUI;\n\n\t \n\tframe->s3d_struct = HDMI_3D_STRUCTURE_INVALID;\n\tframe->length = HDMI_VENDOR_INFOFRAME_SIZE;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hdmi_vendor_infoframe_init);\n\nstatic int hdmi_vendor_infoframe_length(const struct hdmi_vendor_infoframe *frame)\n{\n\t \n\tif (frame->s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF)\n\t\treturn 6;\n\telse if (frame->vic != 0 || frame->s3d_struct != HDMI_3D_STRUCTURE_INVALID)\n\t\treturn 5;\n\telse\n\t\treturn 4;\n}\n\nstatic int hdmi_vendor_infoframe_check_only(const struct hdmi_vendor_infoframe *frame)\n{\n\tif (frame->type != HDMI_INFOFRAME_TYPE_VENDOR ||\n\t    frame->version != 1 ||\n\t    frame->oui != HDMI_IEEE_OUI)\n\t\treturn -EINVAL;\n\n\t \n\tif (frame->vic != 0 && frame->s3d_struct != HDMI_3D_STRUCTURE_INVALID)\n\t\treturn -EINVAL;\n\n\tif (frame->length != hdmi_vendor_infoframe_length(frame))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint hdmi_vendor_infoframe_check(struct hdmi_vendor_infoframe *frame)\n{\n\tframe->length = hdmi_vendor_infoframe_length(frame);\n\n\treturn hdmi_vendor_infoframe_check_only(frame);\n}\nEXPORT_SYMBOL(hdmi_vendor_infoframe_check);\n\n \nssize_t hdmi_vendor_infoframe_pack_only(const struct hdmi_vendor_infoframe *frame,\n\t\t\t\t\tvoid *buffer, size_t size)\n{\n\tu8 *ptr = buffer;\n\tsize_t length;\n\tint ret;\n\n\tret = hdmi_vendor_infoframe_check_only(frame);\n\tif (ret)\n\t\treturn ret;\n\n\tlength = HDMI_INFOFRAME_HEADER_SIZE + frame->length;\n\n\tif (size < length)\n\t\treturn -ENOSPC;\n\n\tmemset(buffer, 0, size);\n\n\tptr[0] = frame->type;\n\tptr[1] = frame->version;\n\tptr[2] = frame->length;\n\tptr[3] = 0;  \n\n\t \n\tptr[4] = 0x03;\n\tptr[5] = 0x0c;\n\tptr[6] = 0x00;\n\n\tif (frame->s3d_struct != HDMI_3D_STRUCTURE_INVALID) {\n\t\tptr[7] = 0x2 << 5;\t \n\t\tptr[8] = (frame->s3d_struct & 0xf) << 4;\n\t\tif (frame->s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF)\n\t\t\tptr[9] = (frame->s3d_ext_data & 0xf) << 4;\n\t} else if (frame->vic) {\n\t\tptr[7] = 0x1 << 5;\t \n\t\tptr[8] = frame->vic;\n\t} else {\n\t\tptr[7] = 0x0 << 5;\t \n\t}\n\n\thdmi_infoframe_set_checksum(buffer, length);\n\n\treturn length;\n}\nEXPORT_SYMBOL(hdmi_vendor_infoframe_pack_only);\n\n \nssize_t hdmi_vendor_infoframe_pack(struct hdmi_vendor_infoframe *frame,\n\t\t\t\t   void *buffer, size_t size)\n{\n\tint ret;\n\n\tret = hdmi_vendor_infoframe_check(frame);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hdmi_vendor_infoframe_pack_only(frame, buffer, size);\n}\nEXPORT_SYMBOL(hdmi_vendor_infoframe_pack);\n\nstatic int\nhdmi_vendor_any_infoframe_check_only(const union hdmi_vendor_any_infoframe *frame)\n{\n\tif (frame->any.type != HDMI_INFOFRAME_TYPE_VENDOR ||\n\t    frame->any.version != 1)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint hdmi_drm_infoframe_init(struct hdmi_drm_infoframe *frame)\n{\n\tmemset(frame, 0, sizeof(*frame));\n\n\tframe->type = HDMI_INFOFRAME_TYPE_DRM;\n\tframe->version = 1;\n\tframe->length = HDMI_DRM_INFOFRAME_SIZE;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hdmi_drm_infoframe_init);\n\nstatic int hdmi_drm_infoframe_check_only(const struct hdmi_drm_infoframe *frame)\n{\n\tif (frame->type != HDMI_INFOFRAME_TYPE_DRM ||\n\t    frame->version != 1)\n\t\treturn -EINVAL;\n\n\tif (frame->length != HDMI_DRM_INFOFRAME_SIZE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint hdmi_drm_infoframe_check(struct hdmi_drm_infoframe *frame)\n{\n\treturn hdmi_drm_infoframe_check_only(frame);\n}\nEXPORT_SYMBOL(hdmi_drm_infoframe_check);\n\n \nssize_t hdmi_drm_infoframe_pack_only(const struct hdmi_drm_infoframe *frame,\n\t\t\t\t     void *buffer, size_t size)\n{\n\tu8 *ptr = buffer;\n\tsize_t length;\n\tint i;\n\n\tlength = HDMI_INFOFRAME_HEADER_SIZE + frame->length;\n\n\tif (size < length)\n\t\treturn -ENOSPC;\n\n\tmemset(buffer, 0, size);\n\n\tptr[0] = frame->type;\n\tptr[1] = frame->version;\n\tptr[2] = frame->length;\n\tptr[3] = 0;  \n\n\t \n\tptr += HDMI_INFOFRAME_HEADER_SIZE;\n\n\t*ptr++ = frame->eotf;\n\t*ptr++ = frame->metadata_type;\n\n\tfor (i = 0; i < 3; i++) {\n\t\t*ptr++ = frame->display_primaries[i].x;\n\t\t*ptr++ = frame->display_primaries[i].x >> 8;\n\t\t*ptr++ = frame->display_primaries[i].y;\n\t\t*ptr++ = frame->display_primaries[i].y >> 8;\n\t}\n\n\t*ptr++ = frame->white_point.x;\n\t*ptr++ = frame->white_point.x >> 8;\n\n\t*ptr++ = frame->white_point.y;\n\t*ptr++ = frame->white_point.y >> 8;\n\n\t*ptr++ = frame->max_display_mastering_luminance;\n\t*ptr++ = frame->max_display_mastering_luminance >> 8;\n\n\t*ptr++ = frame->min_display_mastering_luminance;\n\t*ptr++ = frame->min_display_mastering_luminance >> 8;\n\n\t*ptr++ = frame->max_cll;\n\t*ptr++ = frame->max_cll >> 8;\n\n\t*ptr++ = frame->max_fall;\n\t*ptr++ = frame->max_fall >> 8;\n\n\thdmi_infoframe_set_checksum(buffer, length);\n\n\treturn length;\n}\nEXPORT_SYMBOL(hdmi_drm_infoframe_pack_only);\n\n \nssize_t hdmi_drm_infoframe_pack(struct hdmi_drm_infoframe *frame,\n\t\t\t\tvoid *buffer, size_t size)\n{\n\tint ret;\n\n\tret = hdmi_drm_infoframe_check(frame);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hdmi_drm_infoframe_pack_only(frame, buffer, size);\n}\nEXPORT_SYMBOL(hdmi_drm_infoframe_pack);\n\n \nstatic int\nhdmi_vendor_any_infoframe_check(union hdmi_vendor_any_infoframe *frame)\n{\n\tint ret;\n\n\tret = hdmi_vendor_any_infoframe_check_only(frame);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (frame->any.oui != HDMI_IEEE_OUI)\n\t\treturn -EINVAL;\n\n\treturn hdmi_vendor_infoframe_check(&frame->hdmi);\n}\n\n \nstatic ssize_t\nhdmi_vendor_any_infoframe_pack_only(const union hdmi_vendor_any_infoframe *frame,\n\t\t\t\t    void *buffer, size_t size)\n{\n\tint ret;\n\n\tret = hdmi_vendor_any_infoframe_check_only(frame);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (frame->any.oui != HDMI_IEEE_OUI)\n\t\treturn -EINVAL;\n\n\treturn hdmi_vendor_infoframe_pack_only(&frame->hdmi, buffer, size);\n}\n\n \nstatic ssize_t\nhdmi_vendor_any_infoframe_pack(union hdmi_vendor_any_infoframe *frame,\n\t\t\t       void *buffer, size_t size)\n{\n\tint ret;\n\n\tret = hdmi_vendor_any_infoframe_check(frame);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hdmi_vendor_any_infoframe_pack_only(frame, buffer, size);\n}\n\n \nint\nhdmi_infoframe_check(union hdmi_infoframe *frame)\n{\n\tswitch (frame->any.type) {\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\treturn hdmi_avi_infoframe_check(&frame->avi);\n\tcase HDMI_INFOFRAME_TYPE_SPD:\n\t\treturn hdmi_spd_infoframe_check(&frame->spd);\n\tcase HDMI_INFOFRAME_TYPE_AUDIO:\n\t\treturn hdmi_audio_infoframe_check(&frame->audio);\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\treturn hdmi_vendor_any_infoframe_check(&frame->vendor);\n\tdefault:\n\t\tWARN(1, \"Bad infoframe type %d\\n\", frame->any.type);\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(hdmi_infoframe_check);\n\n \nssize_t\nhdmi_infoframe_pack_only(const union hdmi_infoframe *frame, void *buffer, size_t size)\n{\n\tssize_t length;\n\n\tswitch (frame->any.type) {\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\tlength = hdmi_avi_infoframe_pack_only(&frame->avi,\n\t\t\t\t\t\t      buffer, size);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_DRM:\n\t\tlength = hdmi_drm_infoframe_pack_only(&frame->drm,\n\t\t\t\t\t\t      buffer, size);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_SPD:\n\t\tlength = hdmi_spd_infoframe_pack_only(&frame->spd,\n\t\t\t\t\t\t      buffer, size);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_AUDIO:\n\t\tlength = hdmi_audio_infoframe_pack_only(&frame->audio,\n\t\t\t\t\t\t\tbuffer, size);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\tlength = hdmi_vendor_any_infoframe_pack_only(&frame->vendor,\n\t\t\t\t\t\t\t     buffer, size);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Bad infoframe type %d\\n\", frame->any.type);\n\t\tlength = -EINVAL;\n\t}\n\n\treturn length;\n}\nEXPORT_SYMBOL(hdmi_infoframe_pack_only);\n\n \nssize_t\nhdmi_infoframe_pack(union hdmi_infoframe *frame,\n\t\t    void *buffer, size_t size)\n{\n\tssize_t length;\n\n\tswitch (frame->any.type) {\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\tlength = hdmi_avi_infoframe_pack(&frame->avi, buffer, size);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_DRM:\n\t\tlength = hdmi_drm_infoframe_pack(&frame->drm, buffer, size);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_SPD:\n\t\tlength = hdmi_spd_infoframe_pack(&frame->spd, buffer, size);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_AUDIO:\n\t\tlength = hdmi_audio_infoframe_pack(&frame->audio, buffer, size);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\tlength = hdmi_vendor_any_infoframe_pack(&frame->vendor,\n\t\t\t\t\t\t\tbuffer, size);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Bad infoframe type %d\\n\", frame->any.type);\n\t\tlength = -EINVAL;\n\t}\n\n\treturn length;\n}\nEXPORT_SYMBOL(hdmi_infoframe_pack);\n\nstatic const char *hdmi_infoframe_type_get_name(enum hdmi_infoframe_type type)\n{\n\tif (type < 0x80 || type > 0x9f)\n\t\treturn \"Invalid\";\n\tswitch (type) {\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\treturn \"Vendor\";\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\treturn \"Auxiliary Video Information (AVI)\";\n\tcase HDMI_INFOFRAME_TYPE_SPD:\n\t\treturn \"Source Product Description (SPD)\";\n\tcase HDMI_INFOFRAME_TYPE_AUDIO:\n\t\treturn \"Audio\";\n\tcase HDMI_INFOFRAME_TYPE_DRM:\n\t\treturn \"Dynamic Range and Mastering\";\n\t}\n\treturn \"Reserved\";\n}\n\nstatic void hdmi_infoframe_log_header(const char *level,\n\t\t\t\t      struct device *dev,\n\t\t\t\t      const struct hdmi_any_infoframe *frame)\n{\n\thdmi_log(\"HDMI infoframe: %s, version %u, length %u\\n\",\n\t\thdmi_infoframe_type_get_name(frame->type),\n\t\tframe->version, frame->length);\n}\n\nstatic const char *hdmi_colorspace_get_name(enum hdmi_colorspace colorspace)\n{\n\tswitch (colorspace) {\n\tcase HDMI_COLORSPACE_RGB:\n\t\treturn \"RGB\";\n\tcase HDMI_COLORSPACE_YUV422:\n\t\treturn \"YCbCr 4:2:2\";\n\tcase HDMI_COLORSPACE_YUV444:\n\t\treturn \"YCbCr 4:4:4\";\n\tcase HDMI_COLORSPACE_YUV420:\n\t\treturn \"YCbCr 4:2:0\";\n\tcase HDMI_COLORSPACE_RESERVED4:\n\t\treturn \"Reserved (4)\";\n\tcase HDMI_COLORSPACE_RESERVED5:\n\t\treturn \"Reserved (5)\";\n\tcase HDMI_COLORSPACE_RESERVED6:\n\t\treturn \"Reserved (6)\";\n\tcase HDMI_COLORSPACE_IDO_DEFINED:\n\t\treturn \"IDO Defined\";\n\t}\n\treturn \"Invalid\";\n}\n\nstatic const char *hdmi_scan_mode_get_name(enum hdmi_scan_mode scan_mode)\n{\n\tswitch (scan_mode) {\n\tcase HDMI_SCAN_MODE_NONE:\n\t\treturn \"No Data\";\n\tcase HDMI_SCAN_MODE_OVERSCAN:\n\t\treturn \"Overscan\";\n\tcase HDMI_SCAN_MODE_UNDERSCAN:\n\t\treturn \"Underscan\";\n\tcase HDMI_SCAN_MODE_RESERVED:\n\t\treturn \"Reserved\";\n\t}\n\treturn \"Invalid\";\n}\n\nstatic const char *hdmi_colorimetry_get_name(enum hdmi_colorimetry colorimetry)\n{\n\tswitch (colorimetry) {\n\tcase HDMI_COLORIMETRY_NONE:\n\t\treturn \"No Data\";\n\tcase HDMI_COLORIMETRY_ITU_601:\n\t\treturn \"ITU601\";\n\tcase HDMI_COLORIMETRY_ITU_709:\n\t\treturn \"ITU709\";\n\tcase HDMI_COLORIMETRY_EXTENDED:\n\t\treturn \"Extended\";\n\t}\n\treturn \"Invalid\";\n}\n\nstatic const char *\nhdmi_picture_aspect_get_name(enum hdmi_picture_aspect picture_aspect)\n{\n\tswitch (picture_aspect) {\n\tcase HDMI_PICTURE_ASPECT_NONE:\n\t\treturn \"No Data\";\n\tcase HDMI_PICTURE_ASPECT_4_3:\n\t\treturn \"4:3\";\n\tcase HDMI_PICTURE_ASPECT_16_9:\n\t\treturn \"16:9\";\n\tcase HDMI_PICTURE_ASPECT_64_27:\n\t\treturn \"64:27\";\n\tcase HDMI_PICTURE_ASPECT_256_135:\n\t\treturn \"256:135\";\n\tcase HDMI_PICTURE_ASPECT_RESERVED:\n\t\treturn \"Reserved\";\n\t}\n\treturn \"Invalid\";\n}\n\nstatic const char *\nhdmi_active_aspect_get_name(enum hdmi_active_aspect active_aspect)\n{\n\tif (active_aspect < 0 || active_aspect > 0xf)\n\t\treturn \"Invalid\";\n\n\tswitch (active_aspect) {\n\tcase HDMI_ACTIVE_ASPECT_16_9_TOP:\n\t\treturn \"16:9 Top\";\n\tcase HDMI_ACTIVE_ASPECT_14_9_TOP:\n\t\treturn \"14:9 Top\";\n\tcase HDMI_ACTIVE_ASPECT_16_9_CENTER:\n\t\treturn \"16:9 Center\";\n\tcase HDMI_ACTIVE_ASPECT_PICTURE:\n\t\treturn \"Same as Picture\";\n\tcase HDMI_ACTIVE_ASPECT_4_3:\n\t\treturn \"4:3\";\n\tcase HDMI_ACTIVE_ASPECT_16_9:\n\t\treturn \"16:9\";\n\tcase HDMI_ACTIVE_ASPECT_14_9:\n\t\treturn \"14:9\";\n\tcase HDMI_ACTIVE_ASPECT_4_3_SP_14_9:\n\t\treturn \"4:3 SP 14:9\";\n\tcase HDMI_ACTIVE_ASPECT_16_9_SP_14_9:\n\t\treturn \"16:9 SP 14:9\";\n\tcase HDMI_ACTIVE_ASPECT_16_9_SP_4_3:\n\t\treturn \"16:9 SP 4:3\";\n\t}\n\treturn \"Reserved\";\n}\n\nstatic const char *\nhdmi_extended_colorimetry_get_name(enum hdmi_extended_colorimetry ext_col)\n{\n\tswitch (ext_col) {\n\tcase HDMI_EXTENDED_COLORIMETRY_XV_YCC_601:\n\t\treturn \"xvYCC 601\";\n\tcase HDMI_EXTENDED_COLORIMETRY_XV_YCC_709:\n\t\treturn \"xvYCC 709\";\n\tcase HDMI_EXTENDED_COLORIMETRY_S_YCC_601:\n\t\treturn \"sYCC 601\";\n\tcase HDMI_EXTENDED_COLORIMETRY_OPYCC_601:\n\t\treturn \"opYCC 601\";\n\tcase HDMI_EXTENDED_COLORIMETRY_OPRGB:\n\t\treturn \"opRGB\";\n\tcase HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM:\n\t\treturn \"BT.2020 Constant Luminance\";\n\tcase HDMI_EXTENDED_COLORIMETRY_BT2020:\n\t\treturn \"BT.2020\";\n\tcase HDMI_EXTENDED_COLORIMETRY_RESERVED:\n\t\treturn \"Reserved\";\n\t}\n\treturn \"Invalid\";\n}\n\nstatic const char *\nhdmi_quantization_range_get_name(enum hdmi_quantization_range qrange)\n{\n\tswitch (qrange) {\n\tcase HDMI_QUANTIZATION_RANGE_DEFAULT:\n\t\treturn \"Default\";\n\tcase HDMI_QUANTIZATION_RANGE_LIMITED:\n\t\treturn \"Limited\";\n\tcase HDMI_QUANTIZATION_RANGE_FULL:\n\t\treturn \"Full\";\n\tcase HDMI_QUANTIZATION_RANGE_RESERVED:\n\t\treturn \"Reserved\";\n\t}\n\treturn \"Invalid\";\n}\n\nstatic const char *hdmi_nups_get_name(enum hdmi_nups nups)\n{\n\tswitch (nups) {\n\tcase HDMI_NUPS_UNKNOWN:\n\t\treturn \"Unknown Non-uniform Scaling\";\n\tcase HDMI_NUPS_HORIZONTAL:\n\t\treturn \"Horizontally Scaled\";\n\tcase HDMI_NUPS_VERTICAL:\n\t\treturn \"Vertically Scaled\";\n\tcase HDMI_NUPS_BOTH:\n\t\treturn \"Horizontally and Vertically Scaled\";\n\t}\n\treturn \"Invalid\";\n}\n\nstatic const char *\nhdmi_ycc_quantization_range_get_name(enum hdmi_ycc_quantization_range qrange)\n{\n\tswitch (qrange) {\n\tcase HDMI_YCC_QUANTIZATION_RANGE_LIMITED:\n\t\treturn \"Limited\";\n\tcase HDMI_YCC_QUANTIZATION_RANGE_FULL:\n\t\treturn \"Full\";\n\t}\n\treturn \"Invalid\";\n}\n\nstatic const char *\nhdmi_content_type_get_name(enum hdmi_content_type content_type)\n{\n\tswitch (content_type) {\n\tcase HDMI_CONTENT_TYPE_GRAPHICS:\n\t\treturn \"Graphics\";\n\tcase HDMI_CONTENT_TYPE_PHOTO:\n\t\treturn \"Photo\";\n\tcase HDMI_CONTENT_TYPE_CINEMA:\n\t\treturn \"Cinema\";\n\tcase HDMI_CONTENT_TYPE_GAME:\n\t\treturn \"Game\";\n\t}\n\treturn \"Invalid\";\n}\n\nstatic void hdmi_avi_infoframe_log(const char *level,\n\t\t\t\t   struct device *dev,\n\t\t\t\t   const struct hdmi_avi_infoframe *frame)\n{\n\thdmi_infoframe_log_header(level, dev,\n\t\t\t\t  (const struct hdmi_any_infoframe *)frame);\n\n\thdmi_log(\"    colorspace: %s\\n\",\n\t\t\thdmi_colorspace_get_name(frame->colorspace));\n\thdmi_log(\"    scan mode: %s\\n\",\n\t\t\thdmi_scan_mode_get_name(frame->scan_mode));\n\thdmi_log(\"    colorimetry: %s\\n\",\n\t\t\thdmi_colorimetry_get_name(frame->colorimetry));\n\thdmi_log(\"    picture aspect: %s\\n\",\n\t\t\thdmi_picture_aspect_get_name(frame->picture_aspect));\n\thdmi_log(\"    active aspect: %s\\n\",\n\t\t\thdmi_active_aspect_get_name(frame->active_aspect));\n\thdmi_log(\"    itc: %s\\n\", frame->itc ? \"IT Content\" : \"No Data\");\n\thdmi_log(\"    extended colorimetry: %s\\n\",\n\t\t\thdmi_extended_colorimetry_get_name(frame->extended_colorimetry));\n\thdmi_log(\"    quantization range: %s\\n\",\n\t\t\thdmi_quantization_range_get_name(frame->quantization_range));\n\thdmi_log(\"    nups: %s\\n\", hdmi_nups_get_name(frame->nups));\n\thdmi_log(\"    video code: %u\\n\", frame->video_code);\n\thdmi_log(\"    ycc quantization range: %s\\n\",\n\t\t\thdmi_ycc_quantization_range_get_name(frame->ycc_quantization_range));\n\thdmi_log(\"    hdmi content type: %s\\n\",\n\t\t\thdmi_content_type_get_name(frame->content_type));\n\thdmi_log(\"    pixel repeat: %u\\n\", frame->pixel_repeat);\n\thdmi_log(\"    bar top %u, bottom %u, left %u, right %u\\n\",\n\t\t\tframe->top_bar, frame->bottom_bar,\n\t\t\tframe->left_bar, frame->right_bar);\n}\n\nstatic const char *hdmi_spd_sdi_get_name(enum hdmi_spd_sdi sdi)\n{\n\tif (sdi < 0 || sdi > 0xff)\n\t\treturn \"Invalid\";\n\tswitch (sdi) {\n\tcase HDMI_SPD_SDI_UNKNOWN:\n\t\treturn \"Unknown\";\n\tcase HDMI_SPD_SDI_DSTB:\n\t\treturn \"Digital STB\";\n\tcase HDMI_SPD_SDI_DVDP:\n\t\treturn \"DVD Player\";\n\tcase HDMI_SPD_SDI_DVHS:\n\t\treturn \"D-VHS\";\n\tcase HDMI_SPD_SDI_HDDVR:\n\t\treturn \"HDD Videorecorder\";\n\tcase HDMI_SPD_SDI_DVC:\n\t\treturn \"DVC\";\n\tcase HDMI_SPD_SDI_DSC:\n\t\treturn \"DSC\";\n\tcase HDMI_SPD_SDI_VCD:\n\t\treturn \"Video CD\";\n\tcase HDMI_SPD_SDI_GAME:\n\t\treturn \"Game\";\n\tcase HDMI_SPD_SDI_PC:\n\t\treturn \"PC General\";\n\tcase HDMI_SPD_SDI_BD:\n\t\treturn \"Blu-Ray Disc (BD)\";\n\tcase HDMI_SPD_SDI_SACD:\n\t\treturn \"Super Audio CD\";\n\tcase HDMI_SPD_SDI_HDDVD:\n\t\treturn \"HD DVD\";\n\tcase HDMI_SPD_SDI_PMP:\n\t\treturn \"PMP\";\n\t}\n\treturn \"Reserved\";\n}\n\nstatic void hdmi_spd_infoframe_log(const char *level,\n\t\t\t\t   struct device *dev,\n\t\t\t\t   const struct hdmi_spd_infoframe *frame)\n{\n\tu8 buf[17];\n\n\thdmi_infoframe_log_header(level, dev,\n\t\t\t\t  (const struct hdmi_any_infoframe *)frame);\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tstrncpy(buf, frame->vendor, 8);\n\thdmi_log(\"    vendor: %s\\n\", buf);\n\tstrncpy(buf, frame->product, 16);\n\thdmi_log(\"    product: %s\\n\", buf);\n\thdmi_log(\"    source device information: %s (0x%x)\\n\",\n\t\thdmi_spd_sdi_get_name(frame->sdi), frame->sdi);\n}\n\nstatic const char *\nhdmi_audio_coding_type_get_name(enum hdmi_audio_coding_type coding_type)\n{\n\tswitch (coding_type) {\n\tcase HDMI_AUDIO_CODING_TYPE_STREAM:\n\t\treturn \"Refer to Stream Header\";\n\tcase HDMI_AUDIO_CODING_TYPE_PCM:\n\t\treturn \"PCM\";\n\tcase HDMI_AUDIO_CODING_TYPE_AC3:\n\t\treturn \"AC-3\";\n\tcase HDMI_AUDIO_CODING_TYPE_MPEG1:\n\t\treturn \"MPEG1\";\n\tcase HDMI_AUDIO_CODING_TYPE_MP3:\n\t\treturn \"MP3\";\n\tcase HDMI_AUDIO_CODING_TYPE_MPEG2:\n\t\treturn \"MPEG2\";\n\tcase HDMI_AUDIO_CODING_TYPE_AAC_LC:\n\t\treturn \"AAC\";\n\tcase HDMI_AUDIO_CODING_TYPE_DTS:\n\t\treturn \"DTS\";\n\tcase HDMI_AUDIO_CODING_TYPE_ATRAC:\n\t\treturn \"ATRAC\";\n\tcase HDMI_AUDIO_CODING_TYPE_DSD:\n\t\treturn \"One Bit Audio\";\n\tcase HDMI_AUDIO_CODING_TYPE_EAC3:\n\t\treturn \"Dolby Digital +\";\n\tcase HDMI_AUDIO_CODING_TYPE_DTS_HD:\n\t\treturn \"DTS-HD\";\n\tcase HDMI_AUDIO_CODING_TYPE_MLP:\n\t\treturn \"MAT (MLP)\";\n\tcase HDMI_AUDIO_CODING_TYPE_DST:\n\t\treturn \"DST\";\n\tcase HDMI_AUDIO_CODING_TYPE_WMA_PRO:\n\t\treturn \"WMA PRO\";\n\tcase HDMI_AUDIO_CODING_TYPE_CXT:\n\t\treturn \"Refer to CXT\";\n\t}\n\treturn \"Invalid\";\n}\n\nstatic const char *\nhdmi_audio_sample_size_get_name(enum hdmi_audio_sample_size sample_size)\n{\n\tswitch (sample_size) {\n\tcase HDMI_AUDIO_SAMPLE_SIZE_STREAM:\n\t\treturn \"Refer to Stream Header\";\n\tcase HDMI_AUDIO_SAMPLE_SIZE_16:\n\t\treturn \"16 bit\";\n\tcase HDMI_AUDIO_SAMPLE_SIZE_20:\n\t\treturn \"20 bit\";\n\tcase HDMI_AUDIO_SAMPLE_SIZE_24:\n\t\treturn \"24 bit\";\n\t}\n\treturn \"Invalid\";\n}\n\nstatic const char *\nhdmi_audio_sample_frequency_get_name(enum hdmi_audio_sample_frequency freq)\n{\n\tswitch (freq) {\n\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM:\n\t\treturn \"Refer to Stream Header\";\n\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_32000:\n\t\treturn \"32 kHz\";\n\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_44100:\n\t\treturn \"44.1 kHz (CD)\";\n\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_48000:\n\t\treturn \"48 kHz\";\n\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_88200:\n\t\treturn \"88.2 kHz\";\n\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_96000:\n\t\treturn \"96 kHz\";\n\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_176400:\n\t\treturn \"176.4 kHz\";\n\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_192000:\n\t\treturn \"192 kHz\";\n\t}\n\treturn \"Invalid\";\n}\n\nstatic const char *\nhdmi_audio_coding_type_ext_get_name(enum hdmi_audio_coding_type_ext ctx)\n{\n\tif (ctx < 0 || ctx > 0x1f)\n\t\treturn \"Invalid\";\n\n\tswitch (ctx) {\n\tcase HDMI_AUDIO_CODING_TYPE_EXT_CT:\n\t\treturn \"Refer to CT\";\n\tcase HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC:\n\t\treturn \"HE AAC\";\n\tcase HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC_V2:\n\t\treturn \"HE AAC v2\";\n\tcase HDMI_AUDIO_CODING_TYPE_EXT_MPEG_SURROUND:\n\t\treturn \"MPEG SURROUND\";\n\tcase HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC:\n\t\treturn \"MPEG-4 HE AAC\";\n\tcase HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_V2:\n\t\treturn \"MPEG-4 HE AAC v2\";\n\tcase HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC:\n\t\treturn \"MPEG-4 AAC LC\";\n\tcase HDMI_AUDIO_CODING_TYPE_EXT_DRA:\n\t\treturn \"DRA\";\n\tcase HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_SURROUND:\n\t\treturn \"MPEG-4 HE AAC + MPEG Surround\";\n\tcase HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC_SURROUND:\n\t\treturn \"MPEG-4 AAC LC + MPEG Surround\";\n\t}\n\treturn \"Reserved\";\n}\n\nstatic void hdmi_audio_infoframe_log(const char *level,\n\t\t\t\t     struct device *dev,\n\t\t\t\t     const struct hdmi_audio_infoframe *frame)\n{\n\thdmi_infoframe_log_header(level, dev,\n\t\t\t\t  (const struct hdmi_any_infoframe *)frame);\n\n\tif (frame->channels)\n\t\thdmi_log(\"    channels: %u\\n\", frame->channels - 1);\n\telse\n\t\thdmi_log(\"    channels: Refer to stream header\\n\");\n\thdmi_log(\"    coding type: %s\\n\",\n\t\t\thdmi_audio_coding_type_get_name(frame->coding_type));\n\thdmi_log(\"    sample size: %s\\n\",\n\t\t\thdmi_audio_sample_size_get_name(frame->sample_size));\n\thdmi_log(\"    sample frequency: %s\\n\",\n\t\t\thdmi_audio_sample_frequency_get_name(frame->sample_frequency));\n\thdmi_log(\"    coding type ext: %s\\n\",\n\t\t\thdmi_audio_coding_type_ext_get_name(frame->coding_type_ext));\n\thdmi_log(\"    channel allocation: 0x%x\\n\",\n\t\t\tframe->channel_allocation);\n\thdmi_log(\"    level shift value: %u dB\\n\",\n\t\t\tframe->level_shift_value);\n\thdmi_log(\"    downmix inhibit: %s\\n\",\n\t\t\tframe->downmix_inhibit ? \"Yes\" : \"No\");\n}\n\nstatic void hdmi_drm_infoframe_log(const char *level,\n\t\t\t\t   struct device *dev,\n\t\t\t\t   const struct hdmi_drm_infoframe *frame)\n{\n\tint i;\n\n\thdmi_infoframe_log_header(level, dev,\n\t\t\t\t  (struct hdmi_any_infoframe *)frame);\n\thdmi_log(\"length: %d\\n\", frame->length);\n\thdmi_log(\"metadata type: %d\\n\", frame->metadata_type);\n\thdmi_log(\"eotf: %d\\n\", frame->eotf);\n\tfor (i = 0; i < 3; i++) {\n\t\thdmi_log(\"x[%d]: %d\\n\", i, frame->display_primaries[i].x);\n\t\thdmi_log(\"y[%d]: %d\\n\", i, frame->display_primaries[i].y);\n\t}\n\n\thdmi_log(\"white point x: %d\\n\", frame->white_point.x);\n\thdmi_log(\"white point y: %d\\n\", frame->white_point.y);\n\n\thdmi_log(\"max_display_mastering_luminance: %d\\n\",\n\t\t frame->max_display_mastering_luminance);\n\thdmi_log(\"min_display_mastering_luminance: %d\\n\",\n\t\t frame->min_display_mastering_luminance);\n\n\thdmi_log(\"max_cll: %d\\n\", frame->max_cll);\n\thdmi_log(\"max_fall: %d\\n\", frame->max_fall);\n}\n\nstatic const char *\nhdmi_3d_structure_get_name(enum hdmi_3d_structure s3d_struct)\n{\n\tif (s3d_struct < 0 || s3d_struct > 0xf)\n\t\treturn \"Invalid\";\n\n\tswitch (s3d_struct) {\n\tcase HDMI_3D_STRUCTURE_FRAME_PACKING:\n\t\treturn \"Frame Packing\";\n\tcase HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE:\n\t\treturn \"Field Alternative\";\n\tcase HDMI_3D_STRUCTURE_LINE_ALTERNATIVE:\n\t\treturn \"Line Alternative\";\n\tcase HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL:\n\t\treturn \"Side-by-side (Full)\";\n\tcase HDMI_3D_STRUCTURE_L_DEPTH:\n\t\treturn \"L + Depth\";\n\tcase HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH:\n\t\treturn \"L + Depth + Graphics + Graphics-depth\";\n\tcase HDMI_3D_STRUCTURE_TOP_AND_BOTTOM:\n\t\treturn \"Top-and-Bottom\";\n\tcase HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF:\n\t\treturn \"Side-by-side (Half)\";\n\tdefault:\n\t\tbreak;\n\t}\n\treturn \"Reserved\";\n}\n\nstatic void\nhdmi_vendor_any_infoframe_log(const char *level,\n\t\t\t      struct device *dev,\n\t\t\t      const union hdmi_vendor_any_infoframe *frame)\n{\n\tconst struct hdmi_vendor_infoframe *hvf = &frame->hdmi;\n\n\thdmi_infoframe_log_header(level, dev,\n\t\t\t\t  (const struct hdmi_any_infoframe *)frame);\n\n\tif (frame->any.oui != HDMI_IEEE_OUI) {\n\t\thdmi_log(\"    not a HDMI vendor infoframe\\n\");\n\t\treturn;\n\t}\n\tif (hvf->vic == 0 && hvf->s3d_struct == HDMI_3D_STRUCTURE_INVALID) {\n\t\thdmi_log(\"    empty frame\\n\");\n\t\treturn;\n\t}\n\n\tif (hvf->vic)\n\t\thdmi_log(\"    HDMI VIC: %u\\n\", hvf->vic);\n\tif (hvf->s3d_struct != HDMI_3D_STRUCTURE_INVALID) {\n\t\thdmi_log(\"    3D structure: %s\\n\",\n\t\t\t\thdmi_3d_structure_get_name(hvf->s3d_struct));\n\t\tif (hvf->s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF)\n\t\t\thdmi_log(\"    3D extension data: %d\\n\",\n\t\t\t\t\thvf->s3d_ext_data);\n\t}\n}\n\n \nvoid hdmi_infoframe_log(const char *level,\n\t\t\tstruct device *dev,\n\t\t\tconst union hdmi_infoframe *frame)\n{\n\tswitch (frame->any.type) {\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\thdmi_avi_infoframe_log(level, dev, &frame->avi);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_SPD:\n\t\thdmi_spd_infoframe_log(level, dev, &frame->spd);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_AUDIO:\n\t\thdmi_audio_infoframe_log(level, dev, &frame->audio);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\thdmi_vendor_any_infoframe_log(level, dev, &frame->vendor);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_DRM:\n\t\thdmi_drm_infoframe_log(level, dev, &frame->drm);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(hdmi_infoframe_log);\n\n \nstatic int hdmi_avi_infoframe_unpack(struct hdmi_avi_infoframe *frame,\n\t\t\t\t     const void *buffer, size_t size)\n{\n\tconst u8 *ptr = buffer;\n\n\tif (size < HDMI_INFOFRAME_SIZE(AVI))\n\t\treturn -EINVAL;\n\n\tif (ptr[0] != HDMI_INFOFRAME_TYPE_AVI ||\n\t    ptr[1] != 2 ||\n\t    ptr[2] != HDMI_AVI_INFOFRAME_SIZE)\n\t\treturn -EINVAL;\n\n\tif (hdmi_infoframe_checksum(buffer, HDMI_INFOFRAME_SIZE(AVI)) != 0)\n\t\treturn -EINVAL;\n\n\thdmi_avi_infoframe_init(frame);\n\n\tptr += HDMI_INFOFRAME_HEADER_SIZE;\n\n\tframe->colorspace = (ptr[0] >> 5) & 0x3;\n\tif (ptr[0] & 0x10)\n\t\tframe->active_aspect = ptr[1] & 0xf;\n\tif (ptr[0] & 0x8) {\n\t\tframe->top_bar = (ptr[6] << 8) | ptr[5];\n\t\tframe->bottom_bar = (ptr[8] << 8) | ptr[7];\n\t}\n\tif (ptr[0] & 0x4) {\n\t\tframe->left_bar = (ptr[10] << 8) | ptr[9];\n\t\tframe->right_bar = (ptr[12] << 8) | ptr[11];\n\t}\n\tframe->scan_mode = ptr[0] & 0x3;\n\n\tframe->colorimetry = (ptr[1] >> 6) & 0x3;\n\tframe->picture_aspect = (ptr[1] >> 4) & 0x3;\n\tframe->active_aspect = ptr[1] & 0xf;\n\n\tframe->itc = ptr[2] & 0x80 ? true : false;\n\tframe->extended_colorimetry = (ptr[2] >> 4) & 0x7;\n\tframe->quantization_range = (ptr[2] >> 2) & 0x3;\n\tframe->nups = ptr[2] & 0x3;\n\n\tframe->video_code = ptr[3] & 0x7f;\n\tframe->ycc_quantization_range = (ptr[4] >> 6) & 0x3;\n\tframe->content_type = (ptr[4] >> 4) & 0x3;\n\n\tframe->pixel_repeat = ptr[4] & 0xf;\n\n\treturn 0;\n}\n\n \nstatic int hdmi_spd_infoframe_unpack(struct hdmi_spd_infoframe *frame,\n\t\t\t\t     const void *buffer, size_t size)\n{\n\tconst u8 *ptr = buffer;\n\tint ret;\n\n\tif (size < HDMI_INFOFRAME_SIZE(SPD))\n\t\treturn -EINVAL;\n\n\tif (ptr[0] != HDMI_INFOFRAME_TYPE_SPD ||\n\t    ptr[1] != 1 ||\n\t    ptr[2] != HDMI_SPD_INFOFRAME_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdmi_infoframe_checksum(buffer, HDMI_INFOFRAME_SIZE(SPD)) != 0)\n\t\treturn -EINVAL;\n\n\tptr += HDMI_INFOFRAME_HEADER_SIZE;\n\n\tret = hdmi_spd_infoframe_init(frame, ptr, ptr + 8);\n\tif (ret)\n\t\treturn ret;\n\n\tframe->sdi = ptr[24];\n\n\treturn 0;\n}\n\n \nstatic int hdmi_audio_infoframe_unpack(struct hdmi_audio_infoframe *frame,\n\t\t\t\t       const void *buffer, size_t size)\n{\n\tconst u8 *ptr = buffer;\n\tint ret;\n\n\tif (size < HDMI_INFOFRAME_SIZE(AUDIO))\n\t\treturn -EINVAL;\n\n\tif (ptr[0] != HDMI_INFOFRAME_TYPE_AUDIO ||\n\t    ptr[1] != 1 ||\n\t    ptr[2] != HDMI_AUDIO_INFOFRAME_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdmi_infoframe_checksum(buffer, HDMI_INFOFRAME_SIZE(AUDIO)) != 0)\n\t\treturn -EINVAL;\n\n\tret = hdmi_audio_infoframe_init(frame);\n\tif (ret)\n\t\treturn ret;\n\n\tptr += HDMI_INFOFRAME_HEADER_SIZE;\n\n\tframe->channels = ptr[0] & 0x7;\n\tframe->coding_type = (ptr[0] >> 4) & 0xf;\n\tframe->sample_size = ptr[1] & 0x3;\n\tframe->sample_frequency = (ptr[1] >> 2) & 0x7;\n\tframe->coding_type_ext = ptr[2] & 0x1f;\n\tframe->channel_allocation = ptr[3];\n\tframe->level_shift_value = (ptr[4] >> 3) & 0xf;\n\tframe->downmix_inhibit = ptr[4] & 0x80 ? true : false;\n\n\treturn 0;\n}\n\n \nstatic int\nhdmi_vendor_any_infoframe_unpack(union hdmi_vendor_any_infoframe *frame,\n\t\t\t\t const void *buffer, size_t size)\n{\n\tconst u8 *ptr = buffer;\n\tsize_t length;\n\tint ret;\n\tu8 hdmi_video_format;\n\tstruct hdmi_vendor_infoframe *hvf = &frame->hdmi;\n\n\tif (size < HDMI_INFOFRAME_HEADER_SIZE)\n\t\treturn -EINVAL;\n\n\tif (ptr[0] != HDMI_INFOFRAME_TYPE_VENDOR ||\n\t    ptr[1] != 1 ||\n\t    (ptr[2] != 4 && ptr[2] != 5 && ptr[2] != 6))\n\t\treturn -EINVAL;\n\n\tlength = ptr[2];\n\n\tif (size < HDMI_INFOFRAME_HEADER_SIZE + length)\n\t\treturn -EINVAL;\n\n\tif (hdmi_infoframe_checksum(buffer,\n\t\t\t\t    HDMI_INFOFRAME_HEADER_SIZE + length) != 0)\n\t\treturn -EINVAL;\n\n\tptr += HDMI_INFOFRAME_HEADER_SIZE;\n\n\t \n\tif ((ptr[0] != 0x03) ||\n\t    (ptr[1] != 0x0c) ||\n\t    (ptr[2] != 0x00))\n\t\treturn -EINVAL;\n\n\thdmi_video_format = ptr[3] >> 5;\n\n\tif (hdmi_video_format > 0x2)\n\t\treturn -EINVAL;\n\n\tret = hdmi_vendor_infoframe_init(hvf);\n\tif (ret)\n\t\treturn ret;\n\n\thvf->length = length;\n\n\tif (hdmi_video_format == 0x2) {\n\t\tif (length != 5 && length != 6)\n\t\t\treturn -EINVAL;\n\t\thvf->s3d_struct = ptr[4] >> 4;\n\t\tif (hvf->s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF) {\n\t\t\tif (length != 6)\n\t\t\t\treturn -EINVAL;\n\t\t\thvf->s3d_ext_data = ptr[5] >> 4;\n\t\t}\n\t} else if (hdmi_video_format == 0x1) {\n\t\tif (length != 5)\n\t\t\treturn -EINVAL;\n\t\thvf->vic = ptr[4];\n\t} else {\n\t\tif (length != 4)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint hdmi_drm_infoframe_unpack_only(struct hdmi_drm_infoframe *frame,\n\t\t\t\t   const void *buffer, size_t size)\n{\n\tconst u8 *ptr = buffer;\n\tconst u8 *temp;\n\tu8 x_lsb, x_msb;\n\tu8 y_lsb, y_msb;\n\tint ret;\n\tint i;\n\n\tif (size < HDMI_DRM_INFOFRAME_SIZE)\n\t\treturn -EINVAL;\n\n\tret = hdmi_drm_infoframe_init(frame);\n\tif (ret)\n\t\treturn ret;\n\n\tframe->eotf = ptr[0] & 0x7;\n\tframe->metadata_type = ptr[1] & 0x7;\n\n\ttemp = ptr + 2;\n\tfor (i = 0; i < 3; i++) {\n\t\tx_lsb = *temp++;\n\t\tx_msb = *temp++;\n\t\tframe->display_primaries[i].x = (x_msb << 8) | x_lsb;\n\t\ty_lsb = *temp++;\n\t\ty_msb = *temp++;\n\t\tframe->display_primaries[i].y = (y_msb << 8) | y_lsb;\n\t}\n\n\tframe->white_point.x = (ptr[15] << 8) | ptr[14];\n\tframe->white_point.y = (ptr[17] << 8) | ptr[16];\n\n\tframe->max_display_mastering_luminance = (ptr[19] << 8) | ptr[18];\n\tframe->min_display_mastering_luminance = (ptr[21] << 8) | ptr[20];\n\tframe->max_cll = (ptr[23] << 8) | ptr[22];\n\tframe->max_fall = (ptr[25] << 8) | ptr[24];\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hdmi_drm_infoframe_unpack_only);\n\n \nstatic int hdmi_drm_infoframe_unpack(struct hdmi_drm_infoframe *frame,\n\t\t\t\t     const void *buffer, size_t size)\n{\n\tconst u8 *ptr = buffer;\n\tint ret;\n\n\tif (size < HDMI_INFOFRAME_SIZE(DRM))\n\t\treturn -EINVAL;\n\n\tif (ptr[0] != HDMI_INFOFRAME_TYPE_DRM ||\n\t    ptr[1] != 1 ||\n\t    ptr[2] != HDMI_DRM_INFOFRAME_SIZE)\n\t\treturn -EINVAL;\n\n\tif (hdmi_infoframe_checksum(buffer, HDMI_INFOFRAME_SIZE(DRM)) != 0)\n\t\treturn -EINVAL;\n\n\tret = hdmi_drm_infoframe_unpack_only(frame, ptr + HDMI_INFOFRAME_HEADER_SIZE,\n\t\t\t\t\t     size - HDMI_INFOFRAME_HEADER_SIZE);\n\treturn ret;\n}\n\n \nint hdmi_infoframe_unpack(union hdmi_infoframe *frame,\n\t\t\t  const void *buffer, size_t size)\n{\n\tint ret;\n\tconst u8 *ptr = buffer;\n\n\tif (size < HDMI_INFOFRAME_HEADER_SIZE)\n\t\treturn -EINVAL;\n\n\tswitch (ptr[0]) {\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\tret = hdmi_avi_infoframe_unpack(&frame->avi, buffer, size);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_DRM:\n\t\tret = hdmi_drm_infoframe_unpack(&frame->drm, buffer, size);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_SPD:\n\t\tret = hdmi_spd_infoframe_unpack(&frame->spd, buffer, size);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_AUDIO:\n\t\tret = hdmi_audio_infoframe_unpack(&frame->audio, buffer, size);\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\tret = hdmi_vendor_any_infoframe_unpack(&frame->vendor, buffer, size);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(hdmi_infoframe_unpack);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}