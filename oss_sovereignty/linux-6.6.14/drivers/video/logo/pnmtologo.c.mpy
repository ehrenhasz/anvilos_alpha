{
  "module_name": "pnmtologo.c",
  "hash_id": "d46131e18172f38641a0a980a8537aa4462d0483d670c6aae6c9ff36ec46547a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/logo/pnmtologo.c",
  "human_readable_source": "\n \n\n#include <ctype.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n\nstatic const char *programname;\nstatic const char *filename;\nstatic const char *logoname = \"linux_logo\";\nstatic const char *outputname;\nstatic FILE *out;\n\n\n#define LINUX_LOGO_MONO\t\t1\t \n#define LINUX_LOGO_VGA16\t2\t \n#define LINUX_LOGO_CLUT224\t3\t \n#define LINUX_LOGO_GRAY256\t4\t \n\nstatic const char *logo_types[LINUX_LOGO_GRAY256+1] = {\n\t[LINUX_LOGO_MONO] = \"LINUX_LOGO_MONO\",\n\t[LINUX_LOGO_VGA16] = \"LINUX_LOGO_VGA16\",\n\t[LINUX_LOGO_CLUT224] = \"LINUX_LOGO_CLUT224\",\n\t[LINUX_LOGO_GRAY256] = \"LINUX_LOGO_GRAY256\"\n};\n\n#define MAX_LINUX_LOGO_COLORS\t224\n\nstruct color {\n\tunsigned char red;\n\tunsigned char green;\n\tunsigned char blue;\n};\n\nstatic const struct color clut_vga16[16] = {\n\t{ 0x00, 0x00, 0x00 },\n\t{ 0x00, 0x00, 0xaa },\n\t{ 0x00, 0xaa, 0x00 },\n\t{ 0x00, 0xaa, 0xaa },\n\t{ 0xaa, 0x00, 0x00 },\n\t{ 0xaa, 0x00, 0xaa },\n\t{ 0xaa, 0x55, 0x00 },\n\t{ 0xaa, 0xaa, 0xaa },\n\t{ 0x55, 0x55, 0x55 },\n\t{ 0x55, 0x55, 0xff },\n\t{ 0x55, 0xff, 0x55 },\n\t{ 0x55, 0xff, 0xff },\n\t{ 0xff, 0x55, 0x55 },\n\t{ 0xff, 0x55, 0xff },\n\t{ 0xff, 0xff, 0x55 },\n\t{ 0xff, 0xff, 0xff },\n};\n\n\nstatic int logo_type = LINUX_LOGO_CLUT224;\nstatic unsigned int logo_width;\nstatic unsigned int logo_height;\nstatic struct color **logo_data;\nstatic struct color logo_clut[MAX_LINUX_LOGO_COLORS];\nstatic unsigned int logo_clutsize;\nstatic int is_plain_pbm = 0;\n\nstatic void die(const char *fmt, ...)\n__attribute__((noreturn)) __attribute((format (printf, 1, 2)));\nstatic void usage(void) __attribute((noreturn));\n\n\nstatic unsigned int get_number(FILE *fp)\n{\n\tint c, val;\n\n\t \n\tdo {\n\t\tc = fgetc(fp);\n\t\tif (c == EOF)\n\t\t\tdie(\"%s: end of file\\n\", filename);\n\t\tif (c == '#') {\n\t\t\t \n\t\t\tdo {\n\t\t\t\tc = fgetc(fp);\n\t\t\t\tif (c == EOF)\n\t\t\t\t\tdie(\"%s: end of file\\n\", filename);\n\t\t\t} while (c != '\\n');\n\t\t}\n\t} while (isspace(c));\n\n\t \n\tval = 0;\n\twhile (isdigit(c)) {\n\t\tval = 10*val+c-'0';\n\t\t \n\t\tif (is_plain_pbm)\n\t\t\tbreak;\n\t\tc = fgetc(fp);\n\t\tif (c == EOF)\n\t\t\tdie(\"%s: end of file\\n\", filename);\n\t}\n\treturn val;\n}\n\nstatic unsigned int get_number255(FILE *fp, unsigned int maxval)\n{\n\tunsigned int val = get_number(fp);\n\n\treturn (255*val+maxval/2)/maxval;\n}\n\nstatic void read_image(void)\n{\n\tFILE *fp;\n\tunsigned int i, j;\n\tint magic;\n\tunsigned int maxval;\n\n\t \n\tfp = fopen(filename, \"r\");\n\tif (!fp)\n\t\tdie(\"Cannot open file %s: %s\\n\", filename, strerror(errno));\n\n\t \n\tmagic = fgetc(fp);\n\tif (magic != 'P')\n\t\tdie(\"%s is not a PNM file\\n\", filename);\n\tmagic = fgetc(fp);\n\tswitch (magic) {\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\t\t \n\t\tbreak;\n\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\t\t \n\t\tdie(\"%s: Binary PNM is not supported\\n\"\n\t\t\"Use pnmnoraw(1) to convert it to ASCII PNM\\n\", filename);\n\n\tdefault:\n\t\tdie(\"%s is not a PNM file\\n\", filename);\n\t}\n\tlogo_width = get_number(fp);\n\tlogo_height = get_number(fp);\n\n\t \n\tlogo_data = (struct color **)malloc(logo_height*sizeof(struct color *));\n\tif (!logo_data)\n\t\tdie(\"%s\\n\", strerror(errno));\n\tfor (i = 0; i < logo_height; i++) {\n\t\tlogo_data[i] = malloc(logo_width*sizeof(struct color));\n\tif (!logo_data[i])\n\t\tdie(\"%s\\n\", strerror(errno));\n\t}\n\n\t \n\tswitch (magic) {\n\tcase '1':\n\t\t \n\t\tis_plain_pbm = 1;\n\t\tfor (i = 0; i < logo_height; i++)\n\t\t\tfor (j = 0; j < logo_width; j++)\n\t\t\t\tlogo_data[i][j].red = logo_data[i][j].green =\n\t\t\t\t\tlogo_data[i][j].blue = 255*(1-get_number(fp));\n\t\tbreak;\n\n\tcase '2':\n\t\t \n\t\tmaxval = get_number(fp);\n\t\tfor (i = 0; i < logo_height; i++)\n\t\t\tfor (j = 0; j < logo_width; j++)\n\t\t\t\tlogo_data[i][j].red = logo_data[i][j].green =\n\t\t\t\t\tlogo_data[i][j].blue = get_number255(fp, maxval);\n\t\tbreak;\n\n\tcase '3':\n\t\t \n\t\tmaxval = get_number(fp);\n\t\tfor (i = 0; i < logo_height; i++)\n\t\t\tfor (j = 0; j < logo_width; j++) {\n\t\t\t\tlogo_data[i][j].red = get_number255(fp, maxval);\n\t\t\t\tlogo_data[i][j].green = get_number255(fp, maxval);\n\t\t\t\tlogo_data[i][j].blue = get_number255(fp, maxval);\n\t\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tfclose(fp);\n}\n\nstatic inline int is_black(struct color c)\n{\n\treturn c.red == 0 && c.green == 0 && c.blue == 0;\n}\n\nstatic inline int is_white(struct color c)\n{\n\treturn c.red == 255 && c.green == 255 && c.blue == 255;\n}\n\nstatic inline int is_gray(struct color c)\n{\n\treturn c.red == c.green && c.red == c.blue;\n}\n\nstatic inline int is_equal(struct color c1, struct color c2)\n{\n\treturn c1.red == c2.red && c1.green == c2.green && c1.blue == c2.blue;\n}\n\nstatic void write_header(void)\n{\n\t \n\tif (outputname) {\n\t\tout = fopen(outputname, \"w\");\n\t\tif (!out)\n\t\t\tdie(\"Cannot create file %s: %s\\n\", outputname, strerror(errno));\n\t} else {\n\t\tout = stdout;\n\t}\n\n\tfputs(\"/*\\n\", out);\n\tfputs(\" *  DO NOT EDIT THIS FILE!\\n\", out);\n\tfputs(\" *\\n\", out);\n\tfprintf(out, \" *  It was automatically generated from %s\\n\", filename);\n\tfputs(\" *\\n\", out);\n\tfprintf(out, \" *  Linux logo %s\\n\", logoname);\n\tfputs(\" */\\n\\n\", out);\n\tfputs(\"#include <linux/linux_logo.h>\\n\\n\", out);\n\tfprintf(out, \"static unsigned char %s_data[] __initdata = {\\n\",\n\t\tlogoname);\n}\n\nstatic void write_footer(void)\n{\n\tfputs(\"\\n};\\n\\n\", out);\n\tfprintf(out, \"const struct linux_logo %s __initconst = {\\n\", logoname);\n\tfprintf(out, \"\\t.type\\t\\t= %s,\\n\", logo_types[logo_type]);\n\tfprintf(out, \"\\t.width\\t\\t= %d,\\n\", logo_width);\n\tfprintf(out, \"\\t.height\\t\\t= %d,\\n\", logo_height);\n\tif (logo_type == LINUX_LOGO_CLUT224) {\n\t\tfprintf(out, \"\\t.clutsize\\t= %d,\\n\", logo_clutsize);\n\t\tfprintf(out, \"\\t.clut\\t\\t= %s_clut,\\n\", logoname);\n\t}\n\tfprintf(out, \"\\t.data\\t\\t= %s_data\\n\", logoname);\n\tfputs(\"};\\n\\n\", out);\n\n\t \n\tif (outputname)\n\t\tfclose(out);\n}\n\nstatic int write_hex_cnt;\n\nstatic void write_hex(unsigned char byte)\n{\n\tif (write_hex_cnt % 12)\n\t\tfprintf(out, \", 0x%02x\", byte);\n\telse if (write_hex_cnt)\n\t\tfprintf(out, \",\\n\\t0x%02x\", byte);\n\telse\n\t\tfprintf(out, \"\\t0x%02x\", byte);\n\twrite_hex_cnt++;\n}\n\nstatic void write_logo_mono(void)\n{\n\tunsigned int i, j;\n\tunsigned char val, bit;\n\n\t \n\tfor (i = 0; i < logo_height; i++)\n\t\tfor (j = 0; j < logo_width; j++)\n\t\t\tif (!is_black(logo_data[i][j]) && !is_white(logo_data[i][j]))\n\t\t\t\tdie(\"Image must be monochrome\\n\");\n\n\t \n\twrite_header();\n\n\t \n\tfor (i = 0; i < logo_height; i++) {\n\t\tfor (j = 0; j < logo_width;) {\n\t\t\tfor (val = 0, bit = 0x80; bit && j < logo_width; j++, bit >>= 1)\n\t\t\t\tif (logo_data[i][j].red)\n\t\t\t\t\tval |= bit;\n\t\t\twrite_hex(val);\n\t\t}\n\t}\n\n\t \n\twrite_footer();\n}\n\nstatic void write_logo_vga16(void)\n{\n\tunsigned int i, j, k;\n\tunsigned char val;\n\n\t \n\tfor (i = 0; i < logo_height; i++)\n\t\tfor (j = 0; j < logo_width; j++) {\n\t\t\tfor (k = 0; k < 16; k++)\n\t\t\t\tif (is_equal(logo_data[i][j], clut_vga16[k]))\n\t\t\t\t\tbreak;\n\t\t\tif (k == 16)\n\t\t\t\tdie(\"Image must use the 16 console colors only\\n\"\n\t\t\t\t    \"Use ppmquant(1) -map clut_vga16.ppm to reduce the number \"\n\t\t\t\t    \"of colors\\n\");\n\t\t}\n\n\t \n\twrite_header();\n\n\t \n\tfor (i = 0; i < logo_height; i++)\n\t\tfor (j = 0; j < logo_width; j++) {\n\t\t\tfor (k = 0; k < 16; k++)\n\t\t\t\tif (is_equal(logo_data[i][j], clut_vga16[k]))\n\t\t\t\t\tbreak;\n\t\t\tval = k<<4;\n\t\t\tif (++j < logo_width) {\n\t\t\t\tfor (k = 0; k < 16; k++)\n\t\t\t\t\tif (is_equal(logo_data[i][j], clut_vga16[k]))\n\t\t\t\t\t\tbreak;\n\t\t\t\tval |= k;\n\t\t\t}\n\t\t\twrite_hex(val);\n\t\t}\n\n\t \n\twrite_footer();\n}\n\nstatic void write_logo_clut224(void)\n{\n\tunsigned int i, j, k;\n\n\t \n\tfor (i = 0; i < logo_height; i++)\n\t\tfor (j = 0; j < logo_width; j++) {\n\t\t\tfor (k = 0; k < logo_clutsize; k++)\n\t\t\t\tif (is_equal(logo_data[i][j], logo_clut[k]))\n\t\t\t\t\tbreak;\n\t\t\tif (k == logo_clutsize) {\n\t\t\t\tif (logo_clutsize == MAX_LINUX_LOGO_COLORS)\n\t\t\t\t\tdie(\"Image has more than %d colors\\n\"\n\t\t\t\t\t    \"Use ppmquant(1) to reduce the number of colors\\n\",\n\t\t\t\t\t    MAX_LINUX_LOGO_COLORS);\n\t\t\t\tlogo_clut[logo_clutsize++] = logo_data[i][j];\n\t\t\t}\n\t\t}\n\n\t \n\twrite_header();\n\n\t \n\tfor (i = 0; i < logo_height; i++)\n\t\tfor (j = 0; j < logo_width; j++) {\n\t\t\tfor (k = 0; k < logo_clutsize; k++)\n\t\t\t\tif (is_equal(logo_data[i][j], logo_clut[k]))\n\t\t\t\t\tbreak;\n\t\t\twrite_hex(k+32);\n\t\t}\n\tfputs(\"\\n};\\n\\n\", out);\n\n\t \n\tfprintf(out, \"static unsigned char %s_clut[] __initdata = {\\n\",\n\t\tlogoname);\n\twrite_hex_cnt = 0;\n\tfor (i = 0; i < logo_clutsize; i++) {\n\t\twrite_hex(logo_clut[i].red);\n\t\twrite_hex(logo_clut[i].green);\n\t\twrite_hex(logo_clut[i].blue);\n\t}\n\n\t \n\twrite_footer();\n}\n\nstatic void write_logo_gray256(void)\n{\n\tunsigned int i, j;\n\n\t \n\tfor (i = 0; i < logo_height; i++)\n\t\tfor (j = 0; j < logo_width; j++)\n\t\t\tif (!is_gray(logo_data[i][j]))\n\t\t\t\tdie(\"Image must be grayscale\\n\");\n\n\t \n\twrite_header();\n\n\t \n\tfor (i = 0; i < logo_height; i++)\n\t\tfor (j = 0; j < logo_width; j++)\n\t\t\twrite_hex(logo_data[i][j].red);\n\n\t \n\twrite_footer();\n}\n\nstatic void die(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\n\texit(1);\n}\n\nstatic void usage(void)\n{\n\tdie(\"\\n\"\n\t\"Usage: %s [options] <filename>\\n\"\n\t\"\\n\"\n\t\"Valid options:\\n\"\n\t\"\t-h\t\t  : display this usage information\\n\"\n\t\"\t-n <name>   : specify logo name (default: linux_logo)\\n\"\n\t\"\t-o <output> : output to file <output> instead of stdout\\n\"\n\t\"\t-t <type>   : specify logo type, one of\\n\"\n\t\"\t\t\t\t\t  mono\t: monochrome black/white\\n\"\n\t\"\t\t\t\t\t  vga16   : 16 colors VGA text palette\\n\"\n\t\"\t\t\t\t\t  clut224 : 224 colors (default)\\n\"\n\t\"\t\t\t\t\t  gray256 : 256 levels grayscale\\n\"\n\t\"\\n\", programname);\n}\n\nint main(int argc, char *argv[])\n{\n\tint opt;\n\n\tprogramname = argv[0];\n\n\topterr = 0;\n\twhile (1) {\n\t\topt = getopt(argc, argv, \"hn:o:t:\");\n\t\tif (opt == -1)\n\t\t\tbreak;\n\n\t\tswitch (opt) {\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tlogoname = optarg;\n\t\t\tbreak;\n\n\t\tcase 'o':\n\t\t\toutputname = optarg;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\tif (!strcmp(optarg, \"mono\"))\n\t\t\t\tlogo_type = LINUX_LOGO_MONO;\n\t\t\telse if (!strcmp(optarg, \"vga16\"))\n\t\t\t\tlogo_type = LINUX_LOGO_VGA16;\n\t\t\telse if (!strcmp(optarg, \"clut224\"))\n\t\t\t\tlogo_type = LINUX_LOGO_CLUT224;\n\t\t\telse if (!strcmp(optarg, \"gray256\"))\n\t\t\t\tlogo_type = LINUX_LOGO_GRAY256;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (optind != argc-1)\n\t\tusage();\n\n\tfilename = argv[optind];\n\n\tread_image();\n\tswitch (logo_type) {\n\tcase LINUX_LOGO_MONO:\n\t\twrite_logo_mono();\n\t\tbreak;\n\n\tcase LINUX_LOGO_VGA16:\n\t\twrite_logo_vga16();\n\t\tbreak;\n\n\tcase LINUX_LOGO_CLUT224:\n\t\twrite_logo_clut224();\n\t\tbreak;\n\n\tcase LINUX_LOGO_GRAY256:\n\t\twrite_logo_gray256();\n\t\tbreak;\n\t}\n\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}