{
  "module_name": "of_display_timing.c",
  "hash_id": "a2b417336c95e2f131ce0fcaed8ed4784f4f64a6c47f942124feb8a07e6bbb14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/of_display_timing.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <video/display_timing.h>\n#include <video/of_display_timing.h>\n\n \nstatic int parse_timing_property(const struct device_node *np, const char *name,\n\t\t\t  struct timing_entry *result)\n{\n\tstruct property *prop;\n\tint length, cells, ret;\n\n\tprop = of_find_property(np, name, &length);\n\tif (!prop) {\n\t\tpr_err(\"%pOF: could not find property %s\\n\", np, name);\n\t\treturn -EINVAL;\n\t}\n\n\tcells = length / sizeof(u32);\n\tif (cells == 1) {\n\t\tret = of_property_read_u32(np, name, &result->typ);\n\t\tresult->min = result->typ;\n\t\tresult->max = result->typ;\n\t} else if (cells == 3) {\n\t\tret = of_property_read_u32_array(np, name, &result->min, cells);\n\t} else {\n\t\tpr_err(\"%pOF: illegal timing specification in %s\\n\", np, name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int of_parse_display_timing(const struct device_node *np,\n\t\tstruct display_timing *dt)\n{\n\tu32 val = 0;\n\tint ret = 0;\n\n\tmemset(dt, 0, sizeof(*dt));\n\n\tret |= parse_timing_property(np, \"hback-porch\", &dt->hback_porch);\n\tret |= parse_timing_property(np, \"hfront-porch\", &dt->hfront_porch);\n\tret |= parse_timing_property(np, \"hactive\", &dt->hactive);\n\tret |= parse_timing_property(np, \"hsync-len\", &dt->hsync_len);\n\tret |= parse_timing_property(np, \"vback-porch\", &dt->vback_porch);\n\tret |= parse_timing_property(np, \"vfront-porch\", &dt->vfront_porch);\n\tret |= parse_timing_property(np, \"vactive\", &dt->vactive);\n\tret |= parse_timing_property(np, \"vsync-len\", &dt->vsync_len);\n\tret |= parse_timing_property(np, \"clock-frequency\", &dt->pixelclock);\n\n\tdt->flags = 0;\n\tif (!of_property_read_u32(np, \"vsync-active\", &val))\n\t\tdt->flags |= val ? DISPLAY_FLAGS_VSYNC_HIGH :\n\t\t\t\tDISPLAY_FLAGS_VSYNC_LOW;\n\tif (!of_property_read_u32(np, \"hsync-active\", &val))\n\t\tdt->flags |= val ? DISPLAY_FLAGS_HSYNC_HIGH :\n\t\t\t\tDISPLAY_FLAGS_HSYNC_LOW;\n\tif (!of_property_read_u32(np, \"de-active\", &val))\n\t\tdt->flags |= val ? DISPLAY_FLAGS_DE_HIGH :\n\t\t\t\tDISPLAY_FLAGS_DE_LOW;\n\tif (!of_property_read_u32(np, \"pixelclk-active\", &val))\n\t\tdt->flags |= val ? DISPLAY_FLAGS_PIXDATA_POSEDGE :\n\t\t\t\tDISPLAY_FLAGS_PIXDATA_NEGEDGE;\n\n\tif (!of_property_read_u32(np, \"syncclk-active\", &val))\n\t\tdt->flags |= val ? DISPLAY_FLAGS_SYNC_POSEDGE :\n\t\t\t\tDISPLAY_FLAGS_SYNC_NEGEDGE;\n\telse if (dt->flags & (DISPLAY_FLAGS_PIXDATA_POSEDGE |\n\t\t\t      DISPLAY_FLAGS_PIXDATA_NEGEDGE))\n\t\tdt->flags |= dt->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE ?\n\t\t\t\tDISPLAY_FLAGS_SYNC_POSEDGE :\n\t\t\t\tDISPLAY_FLAGS_SYNC_NEGEDGE;\n\n\tif (of_property_read_bool(np, \"interlaced\"))\n\t\tdt->flags |= DISPLAY_FLAGS_INTERLACED;\n\tif (of_property_read_bool(np, \"doublescan\"))\n\t\tdt->flags |= DISPLAY_FLAGS_DOUBLESCAN;\n\tif (of_property_read_bool(np, \"doubleclk\"))\n\t\tdt->flags |= DISPLAY_FLAGS_DOUBLECLK;\n\n\tif (ret) {\n\t\tpr_err(\"%pOF: error reading timing properties\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint of_get_display_timing(const struct device_node *np, const char *name,\n\t\tstruct display_timing *dt)\n{\n\tstruct device_node *timing_np;\n\tint ret;\n\n\tif (!np)\n\t\treturn -EINVAL;\n\n\ttiming_np = of_get_child_by_name(np, name);\n\tif (!timing_np)\n\t\treturn -ENOENT;\n\n\tret = of_parse_display_timing(timing_np, dt);\n\n\tof_node_put(timing_np);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_get_display_timing);\n\n \nstruct display_timings *of_get_display_timings(const struct device_node *np)\n{\n\tstruct device_node *timings_np;\n\tstruct device_node *entry;\n\tstruct device_node *native_mode;\n\tstruct display_timings *disp;\n\n\tif (!np)\n\t\treturn NULL;\n\n\ttimings_np = of_get_child_by_name(np, \"display-timings\");\n\tif (!timings_np) {\n\t\tpr_err(\"%pOF: could not find display-timings node\\n\", np);\n\t\treturn NULL;\n\t}\n\n\tdisp = kzalloc(sizeof(*disp), GFP_KERNEL);\n\tif (!disp) {\n\t\tpr_err(\"%pOF: could not allocate struct disp'\\n\", np);\n\t\tgoto dispfail;\n\t}\n\n\tentry = of_parse_phandle(timings_np, \"native-mode\", 0);\n\t \n\tif (!entry)\n\t\tentry = of_get_next_child(timings_np, NULL);\n\t \n\tif (!entry) {\n\t\tpr_err(\"%pOF: no timing specifications given\\n\", np);\n\t\tgoto entryfail;\n\t}\n\n\tpr_debug(\"%pOF: using %pOFn as default timing\\n\", np, entry);\n\n\tnative_mode = entry;\n\n\tdisp->num_timings = of_get_child_count(timings_np);\n\tif (disp->num_timings == 0) {\n\t\t \n\t\tpr_err(\"%pOF: no timings specified\\n\", np);\n\t\tgoto entryfail;\n\t}\n\n\tdisp->timings = kcalloc(disp->num_timings,\n\t\t\t\tsizeof(struct display_timing *),\n\t\t\t\tGFP_KERNEL);\n\tif (!disp->timings) {\n\t\tpr_err(\"%pOF: could not allocate timings array\\n\", np);\n\t\tgoto entryfail;\n\t}\n\n\tdisp->num_timings = 0;\n\tdisp->native_mode = 0;\n\n\tfor_each_child_of_node(timings_np, entry) {\n\t\tstruct display_timing *dt;\n\t\tint r;\n\n\t\tdt = kmalloc(sizeof(*dt), GFP_KERNEL);\n\t\tif (!dt) {\n\t\t\tpr_err(\"%pOF: could not allocate display_timing struct\\n\",\n\t\t\t\tnp);\n\t\t\tgoto timingfail;\n\t\t}\n\n\t\tr = of_parse_display_timing(entry, dt);\n\t\tif (r) {\n\t\t\t \n\t\t\tpr_err(\"%pOF: error in timing %d\\n\",\n\t\t\t\tnp, disp->num_timings + 1);\n\t\t\tkfree(dt);\n\t\t\tgoto timingfail;\n\t\t}\n\n\t\tif (native_mode == entry)\n\t\t\tdisp->native_mode = disp->num_timings;\n\n\t\tdisp->timings[disp->num_timings] = dt;\n\t\tdisp->num_timings++;\n\t}\n\tof_node_put(timings_np);\n\t \n\tof_node_put(native_mode);\n\n\tpr_debug(\"%pOF: got %d timings. Using timing #%d as default\\n\",\n\t\tnp, disp->num_timings,\n\t\tdisp->native_mode + 1);\n\n\treturn disp;\n\ntimingfail:\n\tof_node_put(native_mode);\n\tdisplay_timings_release(disp);\n\tdisp = NULL;\nentryfail:\n\tkfree(disp);\ndispfail:\n\tof_node_put(timings_np);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(of_get_display_timings);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}