{
  "module_name": "sticore.c",
  "hash_id": "a1259a8c86e33627aa3ee0897ada24c94542268b2eead73a3638625608863a5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/video/sticore.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, KBUILD_MODNAME\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/font.h>\n\n#include <asm/hardware.h>\n#include <asm/page.h>\n#include <asm/parisc-device.h>\n#include <asm/pdc.h>\n#include <asm/cacheflush.h>\n#include <asm/grfioctl.h>\n\n#include <video/sticore.h>\n\n#define STI_DRIVERVERSION \"Version 0.9c\"\n\nstatic struct sti_struct *default_sti __read_mostly;\n\n \nstatic int num_sti_roms __read_mostly;\nstatic struct sti_struct *sti_roms[MAX_STI_ROMS] __read_mostly;\n\nstatic void *store_sti_val(struct sti_struct *sti, void *ptr, unsigned long val)\n{\n\tu32 *ptr32 = ptr;\n\n\tif (IS_ENABLED(CONFIG_64BIT) && sti->do_call64) {\n\t\t \n\t\tunsigned long *ptr64 = ptr;\n\n\t\tptr64 = PTR_ALIGN(ptr64, sizeof(void *));\n\t\t*ptr64++ = val;\n\t\treturn ptr64;\n\t}\n\n\t \n\t*ptr32++ = val;\n\treturn ptr32;\n}\n\n#define store_sti_ptr(sti, dest, ptr)\t\\\n\t\tstore_sti_val(sti, dest, STI_PTR(ptr))\n\n \n\nstatic const u8 col_trans[8] = {\n        0, 6, 4, 5,\n        2, 7, 3, 1\n};\n\n#define c_fg(sti, c) col_trans[((c>> 8) & 7)]\n#define c_bg(sti, c) col_trans[((c>>11) & 7)]\n#define c_index(sti, c) ((c) & 0xff)\n\nstatic const struct sti_init_flags default_init_flags = {\n\t.wait\t= STI_WAIT,\n\t.reset\t= 1,\n\t.text\t= 1,\n\t.nontext = 1,\n\t.no_chg_bet = 1,\n\t.no_chg_bei = 1,\n\t.init_cmap_tx = 1,\n};\n\nstatic int sti_init_graph(struct sti_struct *sti)\n{\n\tstruct sti_init_inptr *inptr = &sti->sti_data->init_inptr;\n\tstruct sti_init_inptr_ext *inptr_ext = &sti->sti_data->init_inptr_ext;\n\tstruct sti_init_outptr *outptr = &sti->sti_data->init_outptr;\n\tunsigned long flags;\n\tint ret, err;\n\n\tspin_lock_irqsave(&sti->lock, flags);\n\n\tmemset(inptr, 0, sizeof(*inptr));\n\tinptr->text_planes = 3;  \n\tmemset(inptr_ext, 0, sizeof(*inptr_ext));\n\tstore_sti_ptr(sti, &inptr->ext_ptr, inptr_ext);\n\toutptr->errno = 0;\n\n\tret = sti_call(sti, sti->init_graph, &default_init_flags, inptr,\n\t\toutptr, sti->glob_cfg);\n\n\tif (ret >= 0)\n\t\tsti->text_planes = outptr->text_planes;\n\terr = outptr->errno;\n\n\tspin_unlock_irqrestore(&sti->lock, flags);\n\n\tif (ret < 0) {\n\t\tpr_err(\"STI init_graph failed (ret %d, errno %d)\\n\", ret, err);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct sti_conf_flags default_conf_flags = {\n\t.wait\t= STI_WAIT,\n};\n\nstatic void sti_inq_conf(struct sti_struct *sti)\n{\n\tstruct sti_conf_inptr *inptr = &sti->sti_data->inq_inptr;\n\tstruct sti_conf_outptr *outptr = &sti->sti_data->inq_outptr;\n\tunsigned long flags;\n\ts32 ret;\n\n\tstore_sti_ptr(sti, &outptr->ext_ptr, &sti->sti_data->inq_outptr_ext);\n\n\tdo {\n\t\tspin_lock_irqsave(&sti->lock, flags);\n\t\tmemset(inptr, 0, sizeof(*inptr));\n\t\tret = sti_call(sti, sti->inq_conf, &default_conf_flags,\n\t\t\tinptr, outptr, sti->glob_cfg);\n\t\tspin_unlock_irqrestore(&sti->lock, flags);\n\t} while (ret == 1);\n}\n\nstatic const struct sti_font_flags default_font_flags = {\n\t.wait\t\t= STI_WAIT,\n\t.non_text\t= 0,\n};\n\nvoid\nsti_putc(struct sti_struct *sti, int c, int y, int x,\n\t struct sti_cooked_font *font)\n{\n\tstruct sti_font_inptr *inptr;\n\tstruct sti_font_inptr inptr_default = {\n\t\t.font_start_addr = (void *)STI_PTR(font->raw),\n\t\t.index\t\t= c_index(sti, c),\n\t\t.fg_color\t= c_fg(sti, c),\n\t\t.bg_color\t= c_bg(sti, c),\n\t\t.dest_x\t\t= x * font->width,\n\t\t.dest_y\t\t= y * font->height,\n\t};\n\tstruct sti_font_outptr *outptr = &sti->sti_data->font_outptr;\n\ts32 ret;\n\tunsigned long flags;\n\n\tdo {\n\t\tspin_lock_irqsave(&sti->lock, flags);\n\t\tinptr = &inptr_default;\n\t\tif (IS_ENABLED(CONFIG_64BIT) && !sti->do_call64) {\n\t\t\t \n\t\t\tinptr = &sti->sti_data->font_inptr;\n\t\t\t*inptr = inptr_default;\n\t\t\t \n\t\t\tinptr = (void *)(((unsigned long)inptr) + sizeof(u32));\n\t\t}\n\t\tret = sti_call(sti, sti->font_unpmv, &default_font_flags,\n\t\t\tinptr, outptr, sti->glob_cfg);\n\t\tspin_unlock_irqrestore(&sti->lock, flags);\n\t} while (ret == 1);\n}\n\nstatic const struct sti_blkmv_flags clear_blkmv_flags = {\n\t.wait\t= STI_WAIT,\n\t.color\t= 1,\n\t.clear\t= 1,\n};\n\nvoid\nsti_set(struct sti_struct *sti, int src_y, int src_x,\n\tint height, int width, u8 color)\n{\n\tstruct sti_blkmv_inptr *inptr;\n\tstruct sti_blkmv_inptr inptr_default = {\n\t\t.fg_color\t= color,\n\t\t.bg_color\t= color,\n\t\t.src_x\t\t= src_x,\n\t\t.src_y\t\t= src_y,\n\t\t.dest_x\t\t= src_x,\n\t\t.dest_y\t\t= src_y,\n\t\t.width\t\t= width,\n\t\t.height\t\t= height,\n\t};\n\tstruct sti_blkmv_outptr *outptr = &sti->sti_data->blkmv_outptr;\n\ts32 ret;\n\tunsigned long flags;\n\n\tdo {\n\t\tspin_lock_irqsave(&sti->lock, flags);\n\t\tinptr = &inptr_default;\n\t\tif (IS_ENABLED(CONFIG_64BIT) && !sti->do_call64) {\n\t\t\t \n\t\t\tinptr = &sti->sti_data->blkmv_inptr;\n\t\t\t*inptr = inptr_default;\n\t\t}\n\t\tret = sti_call(sti, sti->block_move, &clear_blkmv_flags,\n\t\t\tinptr, outptr, sti->glob_cfg);\n\t\tspin_unlock_irqrestore(&sti->lock, flags);\n\t} while (ret == 1);\n}\n\nvoid\nsti_clear(struct sti_struct *sti, int src_y, int src_x,\n\t  int height, int width, int c, struct sti_cooked_font *font)\n{\n\tstruct sti_blkmv_inptr *inptr;\n\tstruct sti_blkmv_inptr inptr_default = {\n\t\t.fg_color\t= c_fg(sti, c),\n\t\t.bg_color\t= c_bg(sti, c),\n\t\t.src_x\t\t= src_x * font->width,\n\t\t.src_y\t\t= src_y * font->height,\n\t\t.dest_x\t\t= src_x * font->width,\n\t\t.dest_y\t\t= src_y * font->height,\n\t\t.width\t\t= width * font->width,\n\t\t.height\t\t= height * font->height,\n\t};\n\tstruct sti_blkmv_outptr *outptr = &sti->sti_data->blkmv_outptr;\n\ts32 ret;\n\tunsigned long flags;\n\n\tdo {\n\t\tspin_lock_irqsave(&sti->lock, flags);\n\t\tinptr = &inptr_default;\n\t\tif (IS_ENABLED(CONFIG_64BIT) && !sti->do_call64) {\n\t\t\t \n\t\t\tinptr = &sti->sti_data->blkmv_inptr;\n\t\t\t*inptr = inptr_default;\n\t\t}\n\t\tret = sti_call(sti, sti->block_move, &clear_blkmv_flags,\n\t\t\tinptr, outptr, sti->glob_cfg);\n\t\tspin_unlock_irqrestore(&sti->lock, flags);\n\t} while (ret == 1);\n}\n\nstatic const struct sti_blkmv_flags default_blkmv_flags = {\n\t.wait = STI_WAIT,\n};\n\nvoid\nsti_bmove(struct sti_struct *sti, int src_y, int src_x,\n\t  int dst_y, int dst_x, int height, int width,\n\t  struct sti_cooked_font *font)\n{\n\tstruct sti_blkmv_inptr *inptr;\n\tstruct sti_blkmv_inptr inptr_default = {\n\t\t.src_x\t\t= src_x * font->width,\n\t\t.src_y\t\t= src_y * font->height,\n\t\t.dest_x\t\t= dst_x * font->width,\n\t\t.dest_y\t\t= dst_y * font->height,\n\t\t.width\t\t= width * font->width,\n\t\t.height\t\t= height * font->height,\n\t};\n\tstruct sti_blkmv_outptr *outptr = &sti->sti_data->blkmv_outptr;\n\ts32 ret;\n\tunsigned long flags;\n\n\tdo {\n\t\tspin_lock_irqsave(&sti->lock, flags);\n\t\tinptr = &inptr_default;\n\t\tif (IS_ENABLED(CONFIG_64BIT) && !sti->do_call64) {\n\t\t\t \n\t\t\tinptr = &sti->sti_data->blkmv_inptr;\n\t\t\t*inptr = inptr_default;\n\t\t}\n\t\tret = sti_call(sti, sti->block_move, &default_blkmv_flags,\n\t\t\tinptr, outptr, sti->glob_cfg);\n\t\tspin_unlock_irqrestore(&sti->lock, flags);\n\t} while (ret == 1);\n}\n\n\nstatic void sti_flush(unsigned long start, unsigned long end)\n{\n\tflush_icache_range(start, end);\n}\n\nstatic void sti_rom_copy(unsigned long base, unsigned long count, void *dest)\n{\n\tunsigned long dest_start = (unsigned long) dest;\n\n\t \n\twhile (count >= 4) {\n\t\tcount -= 4;\n\t\t*(u32 *)dest = gsc_readl(base);\n\t\tbase += 4;\n\t\tdest += 4;\n\t}\n\twhile (count) {\n\t\tcount--;\n\t\t*(u8 *)dest = gsc_readb(base);\n\t\tbase++;\n\t\tdest++;\n\t}\n\n\tsti_flush(dest_start, (unsigned long)dest);\n}\n\n\n\n\nstatic char default_sti_path[21] __read_mostly;\n\n#ifndef MODULE\nstatic int __init sti_setup(char *str)\n{\n\tif (str)\n\t\tstrscpy(default_sti_path, str, sizeof(default_sti_path));\n\n\treturn 1;\n}\n\n \n__setup(\"sti=\", sti_setup);\n#endif\n\n\n\nstatic char *font_name;\nstatic int font_index,\n\t   font_height,\n\t   font_width;\n#ifndef MODULE\nstatic int sti_font_setup(char *str)\n{\n\t \n\n\tif (*str >= '0' && *str <= '9') {\n\t\tchar *x;\n\n\t\tif ((x = strchr(str, 'x')) || (x = strchr(str, '*'))) {\n\t\t\tfont_height = simple_strtoul(str, NULL, 0);\n\t\t\tfont_width = simple_strtoul(x+1, NULL, 0);\n\t\t} else {\n\t\t\tfont_index = simple_strtoul(str, NULL, 0);\n\t\t}\n\t} else {\n\t\tfont_name = str;\t \n\t}\n\n\treturn 1;\n}\n\n \n__setup(\"sti_font=\", sti_font_setup);\n#endif\n\n\n\nstatic void sti_dump_globcfg(struct sti_struct *sti)\n{\n\tstruct sti_glob_cfg *glob_cfg = sti->glob_cfg;\n\tstruct sti_glob_cfg_ext *cfg = &sti->sti_data->glob_cfg_ext;\n\n\tpr_debug(\"%d text planes\\n\"\n\t\t\"%4d x %4d screen resolution\\n\"\n\t\t\"%4d x %4d offscreen\\n\"\n\t\t\"%4d x %4d layout\\n\",\n\t\tglob_cfg->text_planes,\n\t\tglob_cfg->onscreen_x, glob_cfg->onscreen_y,\n\t\tglob_cfg->offscreen_x, glob_cfg->offscreen_y,\n\t\tglob_cfg->total_x, glob_cfg->total_y);\n\n\t \n\tpr_debug(\"monitor %d\\n\"\n\t\t\"in friendly mode: %d\\n\"\n\t\t\"power consumption %d watts\\n\"\n\t\t\"freq ref %d\\n\"\n\t\t\"sti_mem_addr %px (size=%d bytes)\\n\",\n\t\tcfg->curr_mon,\n\t\tcfg->friendly_boot,\n\t\tcfg->power,\n\t\tcfg->freq_ref,\n\t\tcfg->sti_mem_addr, sti->sti_mem_request);\n}\n\nstatic void sti_dump_outptr(struct sti_struct *sti)\n{\n\tpr_debug(\"%d bits per pixel\\n\"\n\t\t\"%d used bits\\n\"\n\t\t\"%d planes\\n\"\n\t\t\"attributes %08x\\n\",\n\t\t sti->sti_data->inq_outptr.bits_per_pixel,\n\t\t sti->sti_data->inq_outptr.bits_used,\n\t\t sti->sti_data->inq_outptr.planes,\n\t\t sti->sti_data->inq_outptr.attributes);\n}\n\nstatic int sti_init_glob_cfg(struct sti_struct *sti, unsigned long rom_address,\n\t\t\t     unsigned long hpa)\n{\n\tstruct sti_glob_cfg *glob_cfg;\n\tstruct sti_glob_cfg_ext *glob_cfg_ext;\n\tvoid *save_addr, *ptr;\n\tvoid *sti_mem_addr;\n\tint i, size;\n\n\tif (sti->sti_mem_request < 256)\n\t\tsti->sti_mem_request = 256;  \n\n\tsize = sizeof(struct sti_all_data) + sti->sti_mem_request - 256;\n\n\tsti->sti_data = kzalloc(size, STI_LOWMEM);\n\tif (!sti->sti_data)\n\t\treturn -ENOMEM;\n\n\tglob_cfg\t= &sti->sti_data->glob_cfg;\n\tglob_cfg_ext\t= &sti->sti_data->glob_cfg_ext;\n\tsave_addr\t= &sti->sti_data->save_addr;\n\tsti_mem_addr\t= &sti->sti_data->sti_mem_addr;\n\n\tfor (i = 0; i < STI_REGION_MAX; i++) {\n\t\tunsigned long newhpa, len;\n\n\t\tif (sti->pd) {\n\t\t\tunsigned char offs = sti->rm_entry[i];\n\n\t\t\tif (offs == 0)\n\t\t\t\tcontinue;\n\t\t\tif (offs != PCI_ROM_ADDRESS &&\n\t\t\t    (offs < PCI_BASE_ADDRESS_0 ||\n\t\t\t     offs > PCI_BASE_ADDRESS_5)) {\n\t\t\t\tpr_warn(\"STI pci region mapping for region %d (%02x) can't be mapped\\n\",\n\t\t\t\t\ti,sti->rm_entry[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnewhpa = pci_resource_start (sti->pd, (offs - PCI_BASE_ADDRESS_0) / 4);\n\t\t} else\n\t\t\tnewhpa = (i == 0) ? rom_address : hpa;\n\n\t\tsti->regions_phys[i] =\n\t\t\tREGION_OFFSET_TO_PHYS(sti->regions[i], newhpa);\n\n\t\tlen = sti->regions[i].region_desc.length * 4096;\n\n\t\tpr_debug(\"region #%d: phys %08lx, len=%lukB, \"\n\t\t\t \"btlb=%d, sysonly=%d, cache=%d, last=%d\\n\",\n\t\t\ti, sti->regions_phys[i], len / 1024,\n\t\t\tsti->regions[i].region_desc.btlb,\n\t\t\tsti->regions[i].region_desc.sys_only,\n\t\t\tsti->regions[i].region_desc.cache,\n\t\t\tsti->regions[i].region_desc.last);\n\n\t\t \n\t\tif (sti->regions[i].region_desc.last)\n\t\t\tbreak;\n\t}\n\n\tptr = &glob_cfg->region_ptrs;\n\tfor (i = 0; i < STI_REGION_MAX; i++)\n\t\tptr = store_sti_val(sti, ptr, sti->regions_phys[i]);\n\n\t*(s32 *)ptr = 0;\t \n\tptr += sizeof(s32);\n\tptr = store_sti_ptr(sti, ptr, save_addr);\n\tptr = store_sti_ptr(sti, ptr, glob_cfg_ext);\n\n\tstore_sti_ptr(sti, &glob_cfg_ext->sti_mem_addr, sti_mem_addr);\n\n\tsti->glob_cfg = glob_cfg;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_FONT_SUPPORT\nstatic struct sti_cooked_font *\nsti_select_fbfont(struct sti_cooked_rom *cooked_rom, const char *fbfont_name)\n{\n\tconst struct font_desc *fbfont = NULL;\n\tunsigned int size, bpc;\n\tvoid *dest;\n\tstruct sti_rom_font *nf;\n\tstruct sti_cooked_font *cooked_font;\n\n\tif (fbfont_name && strlen(fbfont_name))\n\t\tfbfont = find_font(fbfont_name);\n\tif (!fbfont)\n\t\tfbfont = get_default_font(1024,768, ~(u32)0, ~(u32)0);\n\tif (!fbfont)\n\t\treturn NULL;\n\n\tpr_info(\"    using %ux%u framebuffer font %s\\n\",\n\t\t\tfbfont->width, fbfont->height, fbfont->name);\n\n\tbpc = ((fbfont->width+7)/8) * fbfont->height;\n\tsize = bpc * fbfont->charcount;\n\tsize += sizeof(struct sti_rom_font);\n\n\tnf = kzalloc(size, STI_LOWMEM);\n\tif (!nf)\n\t\treturn NULL;\n\n\tnf->first_char = 0;\n\tnf->last_char = fbfont->charcount - 1;\n\tnf->width = fbfont->width;\n\tnf->height = fbfont->height;\n\tnf->font_type = STI_FONT_HPROMAN8;\n\tnf->bytes_per_char = bpc;\n\tnf->next_font = 0;\n\tnf->underline_height = 1;\n\tnf->underline_pos = fbfont->height - nf->underline_height;\n\n\tdest = nf;\n\tdest += sizeof(struct sti_rom_font);\n\tmemcpy(dest, fbfont->data, bpc * fbfont->charcount);\n\n\tcooked_font = kzalloc(sizeof(*cooked_font), GFP_KERNEL);\n\tif (!cooked_font) {\n\t\tkfree(nf);\n\t\treturn NULL;\n\t}\n\n\tcooked_font->raw = nf;\n\tcooked_font->raw_ptr = nf;\n\tcooked_font->next_font = NULL;\n\n\tcooked_rom->font_start = cooked_font;\n\n\treturn cooked_font;\n}\n#else\nstatic struct sti_cooked_font *\nsti_select_fbfont(struct sti_cooked_rom *cooked_rom, const char *fbfont_name)\n{\n\treturn NULL;\n}\n#endif\n\nstatic void sti_dump_font(struct sti_cooked_font *font)\n{\n#ifdef STI_DUMP_FONT\n\tunsigned char *p = (unsigned char *)font->raw;\n\tint n;\n\n\tp += sizeof(struct sti_rom_font);\n\tpr_debug(\"  w %d h %d bpc %d\\n\", font->width, font->height,\n\t\t\t\t\tfont->raw->bytes_per_char);\n\n\tfor (n = 0; n < 256 * font->raw->bytes_per_char; n += 16, p += 16) {\n\t\tpr_debug(\"        0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x,\"\n\t\t\t\" 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x,\"\n\t\t\t\" 0x%02x, 0x%02x, 0x%02x, 0x%02x,\\n\",\n\t\t\tp[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8],\n\t\t\tp[9], p[10], p[11], p[12], p[13], p[14], p[15]);\n\t}\n#endif\n}\n\nstatic int sti_search_font(struct sti_cooked_rom *rom, int height, int width)\n{\n\tstruct sti_cooked_font *font;\n\tint i = 0;\n\n\tfor (font = rom->font_start; font; font = font->next_font, i++) {\n\t\tif ((font->raw->width == width) &&\n\t\t    (font->raw->height == height))\n\t\t\treturn i;\n\t}\n\treturn 0;\n}\n\nstatic struct sti_cooked_font *sti_select_font(struct sti_cooked_rom *rom)\n{\n\tstruct sti_cooked_font *font;\n\tint i;\n\n\t \n\tif (!font_index) {\n\t\tfont = sti_select_fbfont(rom, font_name);\n\t\tif (font)\n\t\t\treturn font;\n\t}\n\n\tif (font_width && font_height)\n\t\tfont_index = sti_search_font(rom,\n\t\t\t\tfont_height, font_width);\n\n\tfor (font = rom->font_start, i = font_index - 1;\n\t\tfont && (i > 0);\n\t\tfont = font->next_font, i--);\n\n\tif (font)\n\t\treturn font;\n\telse\n\t\treturn rom->font_start;\n}\n\n\nstatic void sti_dump_rom(struct sti_struct *sti)\n{\n\tstruct sti_rom *rom = sti->rom->raw;\n\tstruct sti_cooked_font *font_start;\n\tint nr;\n\n\tpr_info(\"  id %04x-%04x, conforms to spec rev. %d.%02x\\n\",\n\t\trom->graphics_id[0],\n\t\trom->graphics_id[1],\n\t\trom->revno[0] >> 4,\n\t\trom->revno[0] & 0x0f);\n\tpr_debug(\"  supports %d monitors\\n\", rom->num_mons);\n\tpr_debug(\"  font start %08x\\n\", rom->font_start);\n\tpr_debug(\"  region list %08x\\n\", rom->region_list);\n\tpr_debug(\"  init_graph %08x\\n\", rom->init_graph);\n\tpr_debug(\"  bus support %02x\\n\", rom->bus_support);\n\tpr_debug(\"  ext bus support %02x\\n\", rom->ext_bus_support);\n\tpr_debug(\"  alternate code type %d\\n\", rom->alt_code_type);\n\n\tfont_start = sti->rom->font_start;\n\tnr = 0;\n\twhile (font_start) {\n\t\tstruct sti_rom_font *f = font_start->raw;\n\n\t\tpr_info(\"    built-in font #%d: size %dx%d, chars %d-%d, bpc %d\\n\", ++nr,\n\t\t\tf->width, f->height,\n\t\t\tf->first_char, f->last_char, f->bytes_per_char);\n\t\tfont_start = font_start->next_font;\n\t}\n}\n\n\nstatic int sti_cook_fonts(struct sti_cooked_rom *cooked_rom,\n\t\t\t  struct sti_rom *raw_rom)\n{\n\tstruct sti_rom_font *raw_font, *font_start;\n\tstruct sti_cooked_font *cooked_font;\n\n\tcooked_font = kzalloc(sizeof(*cooked_font), GFP_KERNEL);\n\tif (!cooked_font)\n\t\treturn 0;\n\n\tcooked_rom->font_start = cooked_font;\n\n\traw_font = ((void *)raw_rom) + (raw_rom->font_start);\n\n\tfont_start = raw_font;\n\tcooked_font->raw = raw_font;\n\n\twhile (raw_font->next_font) {\n\t\traw_font = ((void *)font_start) + (raw_font->next_font);\n\n\t\tcooked_font->next_font = kzalloc(sizeof(*cooked_font), GFP_KERNEL);\n\t\tif (!cooked_font->next_font)\n\t\t\treturn 1;\n\n\t\tcooked_font = cooked_font->next_font;\n\n\t\tcooked_font->raw = raw_font;\n\t}\n\n\tcooked_font->next_font = NULL;\n\treturn 1;\n}\n\n#define BMODE_RELOCATE(offset)\t\toffset = (offset) / 4;\n#define BMODE_LAST_ADDR_OFFS\t\t0x50\n\nvoid sti_font_convert_bytemode(struct sti_struct *sti, struct sti_cooked_font *f)\n{\n\tunsigned char *n, *p, *q;\n\tint size = f->raw->bytes_per_char * (f->raw->last_char + 1) + sizeof(struct sti_rom_font);\n\tstruct sti_rom_font *old_font;\n\n\tif (sti->wordmode)\n\t\treturn;\n\n\told_font = f->raw_ptr;\n\tn = kcalloc(4, size, STI_LOWMEM);\n\tf->raw_ptr = n;\n\tif (!n)\n\t\treturn;\n\tp = n + 3;\n\tq = (unsigned char *) f->raw;\n\twhile (size--) {\n\t\t*p = *q++;\n\t\tp += 4;\n\t}\n\t \n\tf->raw = (struct sti_rom_font *) (n + 3);\n\tkfree(old_font);\n}\nEXPORT_SYMBOL(sti_font_convert_bytemode);\n\nstatic void sti_bmode_rom_copy(unsigned long base, unsigned long count,\n\t\t\t       void *dest)\n{\n\tunsigned long dest_start = (unsigned long) dest;\n\n\twhile (count) {\n\t\tcount--;\n\t\t*(u8 *)dest = gsc_readl(base);\n\t\tbase += 4;\n\t\tdest++;\n\t}\n\n\tsti_flush(dest_start, (unsigned long)dest);\n}\n\nstatic struct sti_rom *sti_get_bmode_rom (unsigned long address)\n{\n\tstruct sti_rom *raw;\n\tu32 size;\n\tstruct sti_rom_font *raw_font, *font_start;\n\n\tsti_bmode_rom_copy(address + BMODE_LAST_ADDR_OFFS, sizeof(size), &size);\n\n\tsize = (size+3) / 4;\n\traw = kmalloc(size, STI_LOWMEM);\n\tif (raw) {\n\t\tsti_bmode_rom_copy(address, size, raw);\n\t\tmemmove (&raw->res004, &raw->type[0], 0x3c);\n\t\traw->type[3] = raw->res004;\n\n\t\tBMODE_RELOCATE (raw->region_list);\n\t\tBMODE_RELOCATE (raw->font_start);\n\n\t\tBMODE_RELOCATE (raw->init_graph);\n\t\tBMODE_RELOCATE (raw->state_mgmt);\n\t\tBMODE_RELOCATE (raw->font_unpmv);\n\t\tBMODE_RELOCATE (raw->block_move);\n\t\tBMODE_RELOCATE (raw->inq_conf);\n\n\t\traw_font = ((void *)raw) + raw->font_start;\n\t\tfont_start = raw_font;\n\n\t\twhile (raw_font->next_font) {\n\t\t\tBMODE_RELOCATE (raw_font->next_font);\n\t\t\traw_font = ((void *)font_start) + raw_font->next_font;\n\t\t}\n\t}\n\treturn raw;\n}\n\nstatic struct sti_rom *sti_get_wmode_rom(unsigned long address)\n{\n\tstruct sti_rom *raw;\n\tunsigned long size;\n\n\t \n\tsize = gsc_readl(address + offsetof(struct sti_rom,last_addr));\n\n\traw = kmalloc(size, STI_LOWMEM);\n\tif (raw)\n\t\tsti_rom_copy(address, size, raw);\n\n\treturn raw;\n}\n\nstatic int sti_read_rom(int wordmode, struct sti_struct *sti,\n\t\t\tunsigned long address)\n{\n\tstruct sti_cooked_rom *cooked;\n\tstruct sti_rom *raw = NULL;\n\tunsigned long revno;\n\n\tcooked = kmalloc(sizeof *cooked, GFP_KERNEL);\n\tif (!cooked)\n\t\tgoto out_err;\n\n\tif (wordmode)\n\t\traw = sti_get_wmode_rom (address);\n\telse\n\t\traw = sti_get_bmode_rom (address);\n\n\tif (!raw)\n\t\tgoto out_err;\n\n\tif (!sti_cook_fonts(cooked, raw)) {\n\t\tpr_warn(\"No font found for STI at %08lx\\n\", address);\n\t\tgoto out_err;\n\t}\n\n\tif (raw->region_list)\n\t\tmemcpy(sti->regions, ((void *)raw)+raw->region_list, sizeof(sti->regions));\n\n\taddress = (unsigned long) STI_PTR(raw);\n\n\tpr_info(\"STI %s ROM supports 32 %sbit firmware functions.\\n\",\n\t\twordmode ? \"word mode\" : \"byte mode\",\n\t\traw->alt_code_type == ALT_CODE_TYPE_PA_RISC_64\n\t\t? \"and 64 \" : \"\");\n\n\tif (IS_ENABLED(CONFIG_64BIT) &&\n\t    raw->alt_code_type == ALT_CODE_TYPE_PA_RISC_64) {\n\t\tsti->do_call64 = 1;\n\t\tsti->font_unpmv = address + (raw->font_unp_addr   & 0x03ffffff);\n\t\tsti->block_move = address + (raw->block_move_addr & 0x03ffffff);\n\t\tsti->init_graph = address + (raw->init_graph_addr & 0x03ffffff);\n\t\tsti->inq_conf   = address + (raw->inq_conf_addr   & 0x03ffffff);\n\t} else {\n\t\tsti->font_unpmv = address + (raw->font_unpmv & 0x03ffffff);\n\t\tsti->block_move = address + (raw->block_move & 0x03ffffff);\n\t\tsti->init_graph = address + (raw->init_graph & 0x03ffffff);\n\t\tsti->inq_conf   = address + (raw->inq_conf   & 0x03ffffff);\n\t}\n\n\tsti->rom = cooked;\n\tsti->rom->raw = raw;\n\tsti_dump_rom(sti);\n\n\tsti->wordmode = wordmode;\n\tsti->font = sti_select_font(sti->rom);\n\tsti->font->width = sti->font->raw->width;\n\tsti->font->height = sti->font->raw->height;\n\tsti_font_convert_bytemode(sti, sti->font);\n\tsti_dump_font(sti->font);\n\n\tpr_info(\"    using %d-bit STI ROM functions\\n\",\n\t\t(IS_ENABLED(CONFIG_64BIT) && sti->do_call64) ? 64 : 32);\n\n\tsti->sti_mem_request = raw->sti_mem_req;\n\tpr_debug(\"    mem_request = %d,  reentsize %d\\n\",\n\t\t sti->sti_mem_request, raw->reentsize);\n\n\tsti->graphics_id[0] = raw->graphics_id[0];\n\tsti->graphics_id[1] = raw->graphics_id[1];\n\n\t \n\tif (wordmode || sti->graphics_id[1] != 0x09A02587)\n\t\tgoto ok;\n\n\trevno = (raw->revno[0] << 8) | raw->revno[1];\n\n\tswitch (sti->graphics_id[0]) {\n\tcase S9000_ID_HCRX:\n\t\t \n\t\tif (revno == 0x8408 || revno == 0x840b)\n\t\t\tgoto msg_not_supported;\n\t\tbreak;\n\tcase CRT_ID_THUNDER:\n\t\tif (revno == 0x8509)\n\t\t\tgoto msg_not_supported;\n\t\tbreak;\n\tcase CRT_ID_THUNDER2:\n\t\tif (revno == 0x850c)\n\t\t\tgoto msg_not_supported;\n\t}\nok:\n\treturn 1;\n\nmsg_not_supported:\n\tpr_warn(\"Sorry, this GSC/STI card is not yet supported.\\n\");\n\tpr_warn(\"Please see https://parisc.wiki.kernel.org/\"\n\t\t\"index.php/Graphics_howto for more info.\\n\");\n\t \nout_err:\n\tkfree(raw);\n\tkfree(cooked);\n\treturn 0;\n}\n\nstatic struct sti_struct *sti_try_rom_generic(unsigned long address,\n\t\t\t\t\t      unsigned long hpa,\n\t\t\t\t\t      struct pci_dev *pd)\n{\n\tstruct sti_struct *sti;\n\tint ok;\n\tu32 sig;\n\n\tif (num_sti_roms >= MAX_STI_ROMS) {\n\t\tpr_warn(\"maximum number of STI ROMS reached !\\n\");\n\t\treturn NULL;\n\t}\n\n\tsti = kzalloc(sizeof(*sti), GFP_KERNEL);\n\tif (!sti)\n\t\treturn NULL;\n\n\tspin_lock_init(&sti->lock);\n\ntest_rom:\n\t \n\tif ((!IS_ENABLED(CONFIG_64BIT) ||\n\t     (boot_cpu_data.pdc.capabilities & PDC_MODEL_OS32)) &&\n\t    pdc_add_valid(address)) {\n\t\tgoto out_err;\n\t}\n\n\tsig = gsc_readl(address);\n\n\t \n\tif ((le32_to_cpu(sig)==0xaa55)) {\n\t\tunsigned int i, rm_offset;\n\t\tu32 *rm;\n\t\ti = gsc_readl(address+0x04);\n\t\tif (i != 1) {\n\t\t\t \n\t\t\tpr_warn(\"PCI ROM is not a STI ROM type image (0x%8x)\\n\", i);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tsti->pd = pd;\n\n\t\ti = gsc_readl(address+0x0c);\n\t\tpr_debug(\"PCI ROM size (from header) = %d kB\\n\",\n\t\t\tle16_to_cpu(i>>16)*512/1024);\n\t\trm_offset = le16_to_cpu(i & 0xffff);\n\t\tif (rm_offset) {\n\t\t\t \n\t\t\trm = (u32*) &sti->rm_entry;\n\t\t\t*rm++ = gsc_readl(address+rm_offset+0x00);\n\t\t\t*rm++ = gsc_readl(address+rm_offset+0x04);\n\t\t\t*rm++ = gsc_readl(address+rm_offset+0x08);\n\t\t\t*rm++ = gsc_readl(address+rm_offset+0x0c);\n\t\t}\n\n\t\taddress += le32_to_cpu(gsc_readl(address+8));\n\t\tpr_debug(\"sig %04x, PCI STI ROM at %08lx\\n\", sig, address);\n\t\tgoto test_rom;\n\t}\n\n\tok = 0;\n\n\tif ((sig & 0xff) == 0x01) {\n\t\tpr_debug(\"    byte mode ROM at %08lx, hpa at %08lx\\n\",\n\t\t       address, hpa);\n\t\tok = sti_read_rom(0, sti, address);\n\t}\n\n\tif ((sig & 0xffff) == 0x0303) {\n\t\tpr_debug(\"    word mode ROM at %08lx, hpa at %08lx\\n\",\n\t\t       address, hpa);\n\t\tok = sti_read_rom(1, sti, address);\n\t}\n\n\tif (!ok)\n\t\tgoto out_err;\n\n\tif (sti_init_glob_cfg(sti, address, hpa))\n\t\tgoto out_err;  \n\n\t \n\tif (sti->pd) {\n\t\tunsigned long rom_base;\n\t\trom_base = pci_resource_start(sti->pd, PCI_ROM_RESOURCE);\n\t\tpci_write_config_dword(sti->pd, PCI_ROM_ADDRESS, rom_base & ~PCI_ROM_ADDRESS_ENABLE);\n\t\tpr_debug(\"STI PCI ROM disabled\\n\");\n\t}\n\n\tif (sti_init_graph(sti))\n\t\tgoto out_err;\n\n\tsti_inq_conf(sti);\n\tsti_dump_globcfg(sti);\n\tsti_dump_outptr(sti);\n\n\tpr_info(\"    graphics card name: %s\\n\",\n\t\tsti->sti_data->inq_outptr.dev_name);\n\n\tsti_roms[num_sti_roms] = sti;\n\tnum_sti_roms++;\n\n\treturn sti;\n\nout_err:\n\tkfree(sti);\n\treturn NULL;\n}\n\nstatic void sticore_check_for_default_sti(struct sti_struct *sti, char *path)\n{\n\tpr_info(\"    located at [%s]\\n\", sti->pa_path);\n\tif (strcmp (path, default_sti_path) == 0)\n\t\tdefault_sti = sti;\n}\n\n \nstatic int __init sticore_pa_init(struct parisc_device *dev)\n{\n\tstruct sti_struct *sti = NULL;\n\tint hpa = dev->hpa.start;\n\n\tif (dev->num_addrs && dev->addr[0])\n\t\tsti = sti_try_rom_generic(dev->addr[0], hpa, NULL);\n\tif (!sti)\n\t\tsti = sti_try_rom_generic(hpa, hpa, NULL);\n\tif (!sti)\n\t\tsti = sti_try_rom_generic(PAGE0->proc_sti, hpa, NULL);\n\tif (!sti)\n\t\treturn 1;\n\n\tprint_pa_hwpath(dev, sti->pa_path);\n\tsticore_check_for_default_sti(sti, sti->pa_path);\n\treturn 0;\n}\n\n\nstatic int sticore_pci_init(struct pci_dev *pd, const struct pci_device_id *ent)\n{\n#ifdef CONFIG_PCI\n\tunsigned long fb_base, rom_base;\n\tunsigned int fb_len, rom_len;\n\tint err;\n\tstruct sti_struct *sti;\n\n\terr = pci_enable_device(pd);\n\tif (err < 0) {\n\t\tdev_err(&pd->dev, \"Cannot enable PCI device\\n\");\n\t\treturn err;\n\t}\n\n\tfb_base = pci_resource_start(pd, 0);\n\tfb_len = pci_resource_len(pd, 0);\n\trom_base = pci_resource_start(pd, PCI_ROM_RESOURCE);\n\trom_len = pci_resource_len(pd, PCI_ROM_RESOURCE);\n\tif (rom_base) {\n\t\tpci_write_config_dword(pd, PCI_ROM_ADDRESS, rom_base | PCI_ROM_ADDRESS_ENABLE);\n\t\tpr_debug(\"STI PCI ROM enabled at 0x%08lx\\n\", rom_base);\n\t}\n\n\tpr_info(\"STI PCI graphic ROM found at %08lx (%u kB), fb at %08lx (%u MB)\\n\",\n\t\trom_base, rom_len/1024, fb_base, fb_len/1024/1024);\n\n\tpr_debug(\"Trying PCI STI ROM at %08lx, PCI hpa at %08lx\\n\",\n\t\t    rom_base, fb_base);\n\n\tsti = sti_try_rom_generic(rom_base, fb_base, pd);\n\tif (sti) {\n\t\tprint_pci_hwpath(pd, sti->pa_path);\n\t\tsticore_check_for_default_sti(sti, sti->pa_path);\n\t}\n\n\tif (!sti) {\n\t\tpr_warn(\"Unable to handle STI device '%s'\\n\", pci_name(pd));\n\t\treturn -ENODEV;\n\t}\n#endif  \n\n\treturn 0;\n}\n\n\nstatic void __exit sticore_pci_remove(struct pci_dev *pd)\n{\n\tBUG();\n}\n\n\nstatic struct pci_device_id sti_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_VISUALIZE_EG) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_VISUALIZE_FX6) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_VISUALIZE_FX4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_VISUALIZE_FX2) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_VISUALIZE_FXE) },\n\t{ 0, }  \n};\nMODULE_DEVICE_TABLE(pci, sti_pci_tbl);\n\nstatic struct pci_driver pci_sti_driver = {\n\t.name\t\t= \"sti\",\n\t.id_table\t= sti_pci_tbl,\n\t.probe\t\t= sticore_pci_init,\n\t.remove\t\t= __exit_p(sticore_pci_remove),\n};\n\nstatic struct parisc_device_id sti_pa_tbl[] = {\n\t{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x00077 },\n\t{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x00085 },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(parisc, sti_pa_tbl);\n\nstatic struct parisc_driver pa_sti_driver __refdata = {\n\t.name\t\t= \"sti\",\n\t.id_table\t= sti_pa_tbl,\n\t.probe\t\t= sticore_pa_init,\n};\n\n\n \n\nstatic int sticore_initialized __read_mostly;\n\nstatic void sti_init_roms(void)\n{\n\tif (sticore_initialized)\n\t\treturn;\n\n\tsticore_initialized = 1;\n\n\tpr_info(\"STI GSC/PCI core graphics driver \"\n\t\t\tSTI_DRIVERVERSION \"\\n\");\n\n\t \n\tregister_parisc_driver(&pa_sti_driver);\n\tWARN_ON(pci_register_driver(&pci_sti_driver));\n\n\t \n\tif (!default_sti)\n\t\tdefault_sti = sti_roms[0];\n\n}\n\n \nstruct sti_struct * sti_get_rom(unsigned int index)\n{\n\tif (!sticore_initialized)\n\t\tsti_init_roms();\n\n\tif (index == 0)\n\t\treturn default_sti;\n\n\tif (index > num_sti_roms)\n\t\treturn NULL;\n\n\treturn sti_roms[index-1];\n}\nEXPORT_SYMBOL(sti_get_rom);\n\n\nint sti_call(const struct sti_struct *sti, unsigned long func,\n\t\tconst void *flags, void *inptr, void *outptr,\n\t\tstruct sti_glob_cfg *glob_cfg)\n{\n\tunsigned long _flags = STI_PTR(flags);\n\tunsigned long _inptr = STI_PTR(inptr);\n\tunsigned long _outptr = STI_PTR(outptr);\n\tunsigned long _glob_cfg = STI_PTR(glob_cfg);\n\tint ret;\n\n\t \n\tif (WARN_ONCE(IS_ENABLED(CONFIG_64BIT) && !sti->do_call64 &&\n\t\t      (upper_32_bits(_flags) || upper_32_bits(_inptr) ||\n\t\t      upper_32_bits(_outptr) || upper_32_bits(_glob_cfg)),\n\t\t\t\"Out of 32bit-range pointers!\"))\n\t\treturn -1;\n\n\tret = pdc_sti_call(func, _flags, _inptr, _outptr, _glob_cfg,\n\t\t\t   sti->do_call64);\n\n\treturn ret;\n}\n\nMODULE_AUTHOR(\"Philipp Rumpf, Helge Deller, Thomas Bogendoerfer\");\nMODULE_DESCRIPTION(\"Core STI driver for HP's NGLE series graphics cards in HP PARISC machines\");\nMODULE_LICENSE(\"GPL v2\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}