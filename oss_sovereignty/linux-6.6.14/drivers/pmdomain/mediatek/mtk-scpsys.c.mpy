{
  "module_name": "mtk-scpsys.c",
  "hash_id": "fa0e7b1cdee0619b9ec8ad1a6868030692bdbd55301360b05d61a93e9ff39a2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/mediatek/mtk-scpsys.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/regulator/consumer.h>\n#include <linux/soc/mediatek/infracfg.h>\n\n#include <dt-bindings/power/mt2701-power.h>\n#include <dt-bindings/power/mt2712-power.h>\n#include <dt-bindings/power/mt6797-power.h>\n#include <dt-bindings/power/mt7622-power.h>\n#include <dt-bindings/power/mt7623a-power.h>\n#include <dt-bindings/power/mt8173-power.h>\n\n#define MTK_POLL_DELAY_US   10\n#define MTK_POLL_TIMEOUT    USEC_PER_SEC\n\n#define MTK_SCPD_ACTIVE_WAKEUP\t\tBIT(0)\n#define MTK_SCPD_FWAIT_SRAM\t\tBIT(1)\n#define MTK_SCPD_CAPS(_scpd, _x)\t((_scpd)->data->caps & (_x))\n\n#define SPM_VDE_PWR_CON\t\t\t0x0210\n#define SPM_MFG_PWR_CON\t\t\t0x0214\n#define SPM_VEN_PWR_CON\t\t\t0x0230\n#define SPM_ISP_PWR_CON\t\t\t0x0238\n#define SPM_DIS_PWR_CON\t\t\t0x023c\n#define SPM_CONN_PWR_CON\t\t0x0280\n#define SPM_VEN2_PWR_CON\t\t0x0298\n#define SPM_AUDIO_PWR_CON\t\t0x029c\t \n#define SPM_BDP_PWR_CON\t\t\t0x029c\t \n#define SPM_ETH_PWR_CON\t\t\t0x02a0\n#define SPM_HIF_PWR_CON\t\t\t0x02a4\n#define SPM_IFR_MSC_PWR_CON\t\t0x02a8\n#define SPM_MFG_2D_PWR_CON\t\t0x02c0\n#define SPM_MFG_ASYNC_PWR_CON\t\t0x02c4\n#define SPM_USB_PWR_CON\t\t\t0x02cc\n#define SPM_USB2_PWR_CON\t\t0x02d4\t \n#define SPM_ETHSYS_PWR_CON\t\t0x02e0\t \n#define SPM_HIF0_PWR_CON\t\t0x02e4\t \n#define SPM_HIF1_PWR_CON\t\t0x02e8\t \n#define SPM_WB_PWR_CON\t\t\t0x02ec\t \n\n#define SPM_PWR_STATUS\t\t\t0x060c\n#define SPM_PWR_STATUS_2ND\t\t0x0610\n\n#define PWR_RST_B_BIT\t\t\tBIT(0)\n#define PWR_ISO_BIT\t\t\tBIT(1)\n#define PWR_ON_BIT\t\t\tBIT(2)\n#define PWR_ON_2ND_BIT\t\t\tBIT(3)\n#define PWR_CLK_DIS_BIT\t\t\tBIT(4)\n\n#define PWR_STATUS_CONN\t\t\tBIT(1)\n#define PWR_STATUS_DISP\t\t\tBIT(3)\n#define PWR_STATUS_MFG\t\t\tBIT(4)\n#define PWR_STATUS_ISP\t\t\tBIT(5)\n#define PWR_STATUS_VDEC\t\t\tBIT(7)\n#define PWR_STATUS_BDP\t\t\tBIT(14)\n#define PWR_STATUS_ETH\t\t\tBIT(15)\n#define PWR_STATUS_HIF\t\t\tBIT(16)\n#define PWR_STATUS_IFR_MSC\t\tBIT(17)\n#define PWR_STATUS_USB2\t\t\tBIT(19)\t \n#define PWR_STATUS_VENC_LT\t\tBIT(20)\n#define PWR_STATUS_VENC\t\t\tBIT(21)\n#define PWR_STATUS_MFG_2D\t\tBIT(22)\t \n#define PWR_STATUS_MFG_ASYNC\t\tBIT(23)\t \n#define PWR_STATUS_AUDIO\t\tBIT(24)\t \n#define PWR_STATUS_USB\t\t\tBIT(25)\t \n#define PWR_STATUS_ETHSYS\t\tBIT(24)\t \n#define PWR_STATUS_HIF0\t\t\tBIT(25)\t \n#define PWR_STATUS_HIF1\t\t\tBIT(26)\t \n#define PWR_STATUS_WB\t\t\tBIT(27)\t \n\nenum clk_id {\n\tCLK_NONE,\n\tCLK_MM,\n\tCLK_MFG,\n\tCLK_VENC,\n\tCLK_VENC_LT,\n\tCLK_ETHIF,\n\tCLK_VDEC,\n\tCLK_HIFSEL,\n\tCLK_JPGDEC,\n\tCLK_AUDIO,\n\tCLK_MAX,\n};\n\nstatic const char * const clk_names[] = {\n\tNULL,\n\t\"mm\",\n\t\"mfg\",\n\t\"venc\",\n\t\"venc_lt\",\n\t\"ethif\",\n\t\"vdec\",\n\t\"hif_sel\",\n\t\"jpgdec\",\n\t\"audio\",\n\tNULL,\n};\n\n#define MAX_CLKS\t3\n\n \nstruct scp_domain_data {\n\tconst char *name;\n\tu32 sta_mask;\n\tint ctl_offs;\n\tu32 sram_pdn_bits;\n\tu32 sram_pdn_ack_bits;\n\tu32 bus_prot_mask;\n\tenum clk_id clk_id[MAX_CLKS];\n\tu8 caps;\n};\n\nstruct scp;\n\nstruct scp_domain {\n\tstruct generic_pm_domain genpd;\n\tstruct scp *scp;\n\tstruct clk *clk[MAX_CLKS];\n\tconst struct scp_domain_data *data;\n\tstruct regulator *supply;\n};\n\nstruct scp_ctrl_reg {\n\tint pwr_sta_offs;\n\tint pwr_sta2nd_offs;\n};\n\nstruct scp {\n\tstruct scp_domain *domains;\n\tstruct genpd_onecell_data pd_data;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct regmap *infracfg;\n\tstruct scp_ctrl_reg ctrl_reg;\n\tbool bus_prot_reg_update;\n};\n\nstruct scp_subdomain {\n\tint origin;\n\tint subdomain;\n};\n\nstruct scp_soc_data {\n\tconst struct scp_domain_data *domains;\n\tint num_domains;\n\tconst struct scp_subdomain *subdomains;\n\tint num_subdomains;\n\tconst struct scp_ctrl_reg regs;\n\tbool bus_prot_reg_update;\n};\n\nstatic int scpsys_domain_is_on(struct scp_domain *scpd)\n{\n\tstruct scp *scp = scpd->scp;\n\n\tu32 status = readl(scp->base + scp->ctrl_reg.pwr_sta_offs) &\n\t\t\t\t\t\tscpd->data->sta_mask;\n\tu32 status2 = readl(scp->base + scp->ctrl_reg.pwr_sta2nd_offs) &\n\t\t\t\t\t\tscpd->data->sta_mask;\n\n\t \n\n\tif (status && status2)\n\t\treturn true;\n\tif (!status && !status2)\n\t\treturn false;\n\n\treturn -EINVAL;\n}\n\nstatic int scpsys_regulator_enable(struct scp_domain *scpd)\n{\n\tif (!scpd->supply)\n\t\treturn 0;\n\n\treturn regulator_enable(scpd->supply);\n}\n\nstatic int scpsys_regulator_disable(struct scp_domain *scpd)\n{\n\tif (!scpd->supply)\n\t\treturn 0;\n\n\treturn regulator_disable(scpd->supply);\n}\n\nstatic void scpsys_clk_disable(struct clk *clk[], int max_num)\n{\n\tint i;\n\n\tfor (i = max_num - 1; i >= 0; i--)\n\t\tclk_disable_unprepare(clk[i]);\n}\n\nstatic int scpsys_clk_enable(struct clk *clk[], int max_num)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < max_num && clk[i]; i++) {\n\t\tret = clk_prepare_enable(clk[i]);\n\t\tif (ret) {\n\t\t\tscpsys_clk_disable(clk, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int scpsys_sram_enable(struct scp_domain *scpd, void __iomem *ctl_addr)\n{\n\tu32 val;\n\tu32 pdn_ack = scpd->data->sram_pdn_ack_bits;\n\tint tmp;\n\n\tval = readl(ctl_addr);\n\tval &= ~scpd->data->sram_pdn_bits;\n\twritel(val, ctl_addr);\n\n\t \n\tif (MTK_SCPD_CAPS(scpd, MTK_SCPD_FWAIT_SRAM)) {\n\t\t \n\t\tusleep_range(12000, 12100);\n\t} else {\n\t\t \n\t\tint ret = readl_poll_timeout(ctl_addr, tmp,\n\t\t\t\t(tmp & pdn_ack) == 0,\n\t\t\t\tMTK_POLL_DELAY_US, MTK_POLL_TIMEOUT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int scpsys_sram_disable(struct scp_domain *scpd, void __iomem *ctl_addr)\n{\n\tu32 val;\n\tu32 pdn_ack = scpd->data->sram_pdn_ack_bits;\n\tint tmp;\n\n\tval = readl(ctl_addr);\n\tval |= scpd->data->sram_pdn_bits;\n\twritel(val, ctl_addr);\n\n\t \n\treturn readl_poll_timeout(ctl_addr, tmp,\n\t\t\t(tmp & pdn_ack) == pdn_ack,\n\t\t\tMTK_POLL_DELAY_US, MTK_POLL_TIMEOUT);\n}\n\nstatic int scpsys_bus_protect_enable(struct scp_domain *scpd)\n{\n\tstruct scp *scp = scpd->scp;\n\n\tif (!scpd->data->bus_prot_mask)\n\t\treturn 0;\n\n\treturn mtk_infracfg_set_bus_protection(scp->infracfg,\n\t\t\tscpd->data->bus_prot_mask,\n\t\t\tscp->bus_prot_reg_update);\n}\n\nstatic int scpsys_bus_protect_disable(struct scp_domain *scpd)\n{\n\tstruct scp *scp = scpd->scp;\n\n\tif (!scpd->data->bus_prot_mask)\n\t\treturn 0;\n\n\treturn mtk_infracfg_clear_bus_protection(scp->infracfg,\n\t\t\tscpd->data->bus_prot_mask,\n\t\t\tscp->bus_prot_reg_update);\n}\n\nstatic int scpsys_power_on(struct generic_pm_domain *genpd)\n{\n\tstruct scp_domain *scpd = container_of(genpd, struct scp_domain, genpd);\n\tstruct scp *scp = scpd->scp;\n\tvoid __iomem *ctl_addr = scp->base + scpd->data->ctl_offs;\n\tu32 val;\n\tint ret, tmp;\n\n\tret = scpsys_regulator_enable(scpd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = scpsys_clk_enable(scpd->clk, MAX_CLKS);\n\tif (ret)\n\t\tgoto err_clk;\n\n\t \n\tval = readl(ctl_addr);\n\tval |= PWR_ON_BIT;\n\twritel(val, ctl_addr);\n\tval |= PWR_ON_2ND_BIT;\n\twritel(val, ctl_addr);\n\n\t \n\tret = readx_poll_timeout(scpsys_domain_is_on, scpd, tmp, tmp > 0,\n\t\t\t\t MTK_POLL_DELAY_US, MTK_POLL_TIMEOUT);\n\tif (ret < 0)\n\t\tgoto err_pwr_ack;\n\n\tval &= ~PWR_CLK_DIS_BIT;\n\twritel(val, ctl_addr);\n\n\tval &= ~PWR_ISO_BIT;\n\twritel(val, ctl_addr);\n\n\tval |= PWR_RST_B_BIT;\n\twritel(val, ctl_addr);\n\n\tret = scpsys_sram_enable(scpd, ctl_addr);\n\tif (ret < 0)\n\t\tgoto err_pwr_ack;\n\n\tret = scpsys_bus_protect_disable(scpd);\n\tif (ret < 0)\n\t\tgoto err_pwr_ack;\n\n\treturn 0;\n\nerr_pwr_ack:\n\tscpsys_clk_disable(scpd->clk, MAX_CLKS);\nerr_clk:\n\tscpsys_regulator_disable(scpd);\n\n\tdev_err(scp->dev, \"Failed to power on domain %s\\n\", genpd->name);\n\n\treturn ret;\n}\n\nstatic int scpsys_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct scp_domain *scpd = container_of(genpd, struct scp_domain, genpd);\n\tstruct scp *scp = scpd->scp;\n\tvoid __iomem *ctl_addr = scp->base + scpd->data->ctl_offs;\n\tu32 val;\n\tint ret, tmp;\n\n\tret = scpsys_bus_protect_enable(scpd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = scpsys_sram_disable(scpd, ctl_addr);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tval = readl(ctl_addr);\n\tval |= PWR_ISO_BIT;\n\twritel(val, ctl_addr);\n\n\tval &= ~PWR_RST_B_BIT;\n\twritel(val, ctl_addr);\n\n\tval |= PWR_CLK_DIS_BIT;\n\twritel(val, ctl_addr);\n\n\tval &= ~PWR_ON_BIT;\n\twritel(val, ctl_addr);\n\n\tval &= ~PWR_ON_2ND_BIT;\n\twritel(val, ctl_addr);\n\n\t \n\tret = readx_poll_timeout(scpsys_domain_is_on, scpd, tmp, tmp == 0,\n\t\t\t\t MTK_POLL_DELAY_US, MTK_POLL_TIMEOUT);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tscpsys_clk_disable(scpd->clk, MAX_CLKS);\n\n\tret = scpsys_regulator_disable(scpd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tdev_err(scp->dev, \"Failed to power off domain %s\\n\", genpd->name);\n\n\treturn ret;\n}\n\nstatic void init_clks(struct platform_device *pdev, struct clk **clk)\n{\n\tint i;\n\n\tfor (i = CLK_NONE + 1; i < CLK_MAX; i++)\n\t\tclk[i] = devm_clk_get(&pdev->dev, clk_names[i]);\n}\n\nstatic struct scp *init_scp(struct platform_device *pdev,\n\t\t\tconst struct scp_domain_data *scp_domain_data, int num,\n\t\t\tconst struct scp_ctrl_reg *scp_ctrl_reg,\n\t\t\tbool bus_prot_reg_update)\n{\n\tstruct genpd_onecell_data *pd_data;\n\tstruct resource *res;\n\tint i, j;\n\tstruct scp *scp;\n\tstruct clk *clk[CLK_MAX];\n\n\tscp = devm_kzalloc(&pdev->dev, sizeof(*scp), GFP_KERNEL);\n\tif (!scp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tscp->ctrl_reg.pwr_sta_offs = scp_ctrl_reg->pwr_sta_offs;\n\tscp->ctrl_reg.pwr_sta2nd_offs = scp_ctrl_reg->pwr_sta2nd_offs;\n\n\tscp->bus_prot_reg_update = bus_prot_reg_update;\n\n\tscp->dev = &pdev->dev;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tscp->base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(scp->base))\n\t\treturn ERR_CAST(scp->base);\n\n\tscp->domains = devm_kcalloc(&pdev->dev,\n\t\t\t\tnum, sizeof(*scp->domains), GFP_KERNEL);\n\tif (!scp->domains)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpd_data = &scp->pd_data;\n\n\tpd_data->domains = devm_kcalloc(&pdev->dev,\n\t\t\tnum, sizeof(*pd_data->domains), GFP_KERNEL);\n\tif (!pd_data->domains)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tscp->infracfg = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\"infracfg\");\n\tif (IS_ERR(scp->infracfg)) {\n\t\tdev_err(&pdev->dev, \"Cannot find infracfg controller: %ld\\n\",\n\t\t\t\tPTR_ERR(scp->infracfg));\n\t\treturn ERR_CAST(scp->infracfg);\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct scp_domain *scpd = &scp->domains[i];\n\t\tconst struct scp_domain_data *data = &scp_domain_data[i];\n\n\t\tscpd->supply = devm_regulator_get_optional(&pdev->dev, data->name);\n\t\tif (IS_ERR(scpd->supply)) {\n\t\t\tif (PTR_ERR(scpd->supply) == -ENODEV)\n\t\t\t\tscpd->supply = NULL;\n\t\t\telse\n\t\t\t\treturn ERR_CAST(scpd->supply);\n\t\t}\n\t}\n\n\tpd_data->num_domains = num;\n\n\tinit_clks(pdev, clk);\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct scp_domain *scpd = &scp->domains[i];\n\t\tstruct generic_pm_domain *genpd = &scpd->genpd;\n\t\tconst struct scp_domain_data *data = &scp_domain_data[i];\n\n\t\tpd_data->domains[i] = genpd;\n\t\tscpd->scp = scp;\n\n\t\tscpd->data = data;\n\n\t\tfor (j = 0; j < MAX_CLKS && data->clk_id[j]; j++) {\n\t\t\tstruct clk *c = clk[data->clk_id[j]];\n\n\t\t\tif (IS_ERR(c)) {\n\t\t\t\tdev_err(&pdev->dev, \"%s: clk unavailable\\n\",\n\t\t\t\t\tdata->name);\n\t\t\t\treturn ERR_CAST(c);\n\t\t\t}\n\n\t\t\tscpd->clk[j] = c;\n\t\t}\n\n\t\tgenpd->name = data->name;\n\t\tgenpd->power_off = scpsys_power_off;\n\t\tgenpd->power_on = scpsys_power_on;\n\t\tif (MTK_SCPD_CAPS(scpd, MTK_SCPD_ACTIVE_WAKEUP))\n\t\t\tgenpd->flags |= GENPD_FLAG_ACTIVE_WAKEUP;\n\t}\n\n\treturn scp;\n}\n\nstatic void mtk_register_power_domains(struct platform_device *pdev,\n\t\t\t\tstruct scp *scp, int num)\n{\n\tstruct genpd_onecell_data *pd_data;\n\tint i, ret;\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct scp_domain *scpd = &scp->domains[i];\n\t\tstruct generic_pm_domain *genpd = &scpd->genpd;\n\t\tbool on;\n\n\t\t \n\t\ton = !WARN_ON(genpd->power_on(genpd) < 0);\n\n\t\tpm_genpd_init(genpd, NULL, !on);\n\t}\n\n\t \n\n\tpd_data = &scp->pd_data;\n\n\tret = of_genpd_add_provider_onecell(pdev->dev.of_node, pd_data);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Failed to add OF provider: %d\\n\", ret);\n}\n\n \n\nstatic const struct scp_domain_data scp_domain_data_mt2701[] = {\n\t[MT2701_POWER_DOMAIN_CONN] = {\n\t\t.name = \"conn\",\n\t\t.sta_mask = PWR_STATUS_CONN,\n\t\t.ctl_offs = SPM_CONN_PWR_CON,\n\t\t.bus_prot_mask = MT2701_TOP_AXI_PROT_EN_CONN_M |\n\t\t\t\t MT2701_TOP_AXI_PROT_EN_CONN_S,\n\t\t.clk_id = {CLK_NONE},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2701_POWER_DOMAIN_DISP] = {\n\t\t.name = \"disp\",\n\t\t.sta_mask = PWR_STATUS_DISP,\n\t\t.ctl_offs = SPM_DIS_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.clk_id = {CLK_MM},\n\t\t.bus_prot_mask = MT2701_TOP_AXI_PROT_EN_MM_M0,\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2701_POWER_DOMAIN_MFG] = {\n\t\t.name = \"mfg\",\n\t\t.sta_mask = PWR_STATUS_MFG,\n\t\t.ctl_offs = SPM_MFG_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(12, 12),\n\t\t.clk_id = {CLK_MFG},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2701_POWER_DOMAIN_VDEC] = {\n\t\t.name = \"vdec\",\n\t\t.sta_mask = PWR_STATUS_VDEC,\n\t\t.ctl_offs = SPM_VDE_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(12, 12),\n\t\t.clk_id = {CLK_MM},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2701_POWER_DOMAIN_ISP] = {\n\t\t.name = \"isp\",\n\t\t.sta_mask = PWR_STATUS_ISP,\n\t\t.ctl_offs = SPM_ISP_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(13, 12),\n\t\t.clk_id = {CLK_MM},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2701_POWER_DOMAIN_BDP] = {\n\t\t.name = \"bdp\",\n\t\t.sta_mask = PWR_STATUS_BDP,\n\t\t.ctl_offs = SPM_BDP_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.clk_id = {CLK_NONE},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2701_POWER_DOMAIN_ETH] = {\n\t\t.name = \"eth\",\n\t\t.sta_mask = PWR_STATUS_ETH,\n\t\t.ctl_offs = SPM_ETH_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_ETHIF},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2701_POWER_DOMAIN_HIF] = {\n\t\t.name = \"hif\",\n\t\t.sta_mask = PWR_STATUS_HIF,\n\t\t.ctl_offs = SPM_HIF_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_ETHIF},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2701_POWER_DOMAIN_IFR_MSC] = {\n\t\t.name = \"ifr_msc\",\n\t\t.sta_mask = PWR_STATUS_IFR_MSC,\n\t\t.ctl_offs = SPM_IFR_MSC_PWR_CON,\n\t\t.clk_id = {CLK_NONE},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n};\n\n \nstatic const struct scp_domain_data scp_domain_data_mt2712[] = {\n\t[MT2712_POWER_DOMAIN_MM] = {\n\t\t.name = \"mm\",\n\t\t.sta_mask = PWR_STATUS_DISP,\n\t\t.ctl_offs = SPM_DIS_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(8, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(12, 12),\n\t\t.clk_id = {CLK_MM},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2712_POWER_DOMAIN_VDEC] = {\n\t\t.name = \"vdec\",\n\t\t.sta_mask = PWR_STATUS_VDEC,\n\t\t.ctl_offs = SPM_VDE_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(8, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(12, 12),\n\t\t.clk_id = {CLK_MM, CLK_VDEC},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2712_POWER_DOMAIN_VENC] = {\n\t\t.name = \"venc\",\n\t\t.sta_mask = PWR_STATUS_VENC,\n\t\t.ctl_offs = SPM_VEN_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_MM, CLK_VENC, CLK_JPGDEC},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2712_POWER_DOMAIN_ISP] = {\n\t\t.name = \"isp\",\n\t\t.sta_mask = PWR_STATUS_ISP,\n\t\t.ctl_offs = SPM_ISP_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(13, 12),\n\t\t.clk_id = {CLK_MM},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2712_POWER_DOMAIN_AUDIO] = {\n\t\t.name = \"audio\",\n\t\t.sta_mask = PWR_STATUS_AUDIO,\n\t\t.ctl_offs = SPM_AUDIO_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_AUDIO},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2712_POWER_DOMAIN_USB] = {\n\t\t.name = \"usb\",\n\t\t.sta_mask = PWR_STATUS_USB,\n\t\t.ctl_offs = SPM_USB_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(10, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(14, 12),\n\t\t.clk_id = {CLK_NONE},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2712_POWER_DOMAIN_USB2] = {\n\t\t.name = \"usb2\",\n\t\t.sta_mask = PWR_STATUS_USB2,\n\t\t.ctl_offs = SPM_USB2_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(10, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(14, 12),\n\t\t.clk_id = {CLK_NONE},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2712_POWER_DOMAIN_MFG] = {\n\t\t.name = \"mfg\",\n\t\t.sta_mask = PWR_STATUS_MFG,\n\t\t.ctl_offs = SPM_MFG_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(8, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(16, 16),\n\t\t.clk_id = {CLK_MFG},\n\t\t.bus_prot_mask = BIT(14) | BIT(21) | BIT(23),\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2712_POWER_DOMAIN_MFG_SC1] = {\n\t\t.name = \"mfg_sc1\",\n\t\t.sta_mask = BIT(22),\n\t\t.ctl_offs = 0x02c0,\n\t\t.sram_pdn_bits = GENMASK(8, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(16, 16),\n\t\t.clk_id = {CLK_NONE},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2712_POWER_DOMAIN_MFG_SC2] = {\n\t\t.name = \"mfg_sc2\",\n\t\t.sta_mask = BIT(23),\n\t\t.ctl_offs = 0x02c4,\n\t\t.sram_pdn_bits = GENMASK(8, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(16, 16),\n\t\t.clk_id = {CLK_NONE},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT2712_POWER_DOMAIN_MFG_SC3] = {\n\t\t.name = \"mfg_sc3\",\n\t\t.sta_mask = BIT(30),\n\t\t.ctl_offs = 0x01f8,\n\t\t.sram_pdn_bits = GENMASK(8, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(16, 16),\n\t\t.clk_id = {CLK_NONE},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n};\n\nstatic const struct scp_subdomain scp_subdomain_mt2712[] = {\n\t{MT2712_POWER_DOMAIN_MM, MT2712_POWER_DOMAIN_VDEC},\n\t{MT2712_POWER_DOMAIN_MM, MT2712_POWER_DOMAIN_VENC},\n\t{MT2712_POWER_DOMAIN_MM, MT2712_POWER_DOMAIN_ISP},\n\t{MT2712_POWER_DOMAIN_MFG, MT2712_POWER_DOMAIN_MFG_SC1},\n\t{MT2712_POWER_DOMAIN_MFG_SC1, MT2712_POWER_DOMAIN_MFG_SC2},\n\t{MT2712_POWER_DOMAIN_MFG_SC2, MT2712_POWER_DOMAIN_MFG_SC3},\n};\n\n \n\nstatic const struct scp_domain_data scp_domain_data_mt6797[] = {\n\t[MT6797_POWER_DOMAIN_VDEC] = {\n\t\t.name = \"vdec\",\n\t\t.sta_mask = BIT(7),\n\t\t.ctl_offs = 0x300,\n\t\t.sram_pdn_bits = GENMASK(8, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(12, 12),\n\t\t.clk_id = {CLK_VDEC},\n\t},\n\t[MT6797_POWER_DOMAIN_VENC] = {\n\t\t.name = \"venc\",\n\t\t.sta_mask = BIT(21),\n\t\t.ctl_offs = 0x304,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_NONE},\n\t},\n\t[MT6797_POWER_DOMAIN_ISP] = {\n\t\t.name = \"isp\",\n\t\t.sta_mask = BIT(5),\n\t\t.ctl_offs = 0x308,\n\t\t.sram_pdn_bits = GENMASK(9, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(13, 12),\n\t\t.clk_id = {CLK_NONE},\n\t},\n\t[MT6797_POWER_DOMAIN_MM] = {\n\t\t.name = \"mm\",\n\t\t.sta_mask = BIT(3),\n\t\t.ctl_offs = 0x30C,\n\t\t.sram_pdn_bits = GENMASK(8, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(12, 12),\n\t\t.clk_id = {CLK_MM},\n\t\t.bus_prot_mask = (BIT(1) | BIT(2)),\n\t},\n\t[MT6797_POWER_DOMAIN_AUDIO] = {\n\t\t.name = \"audio\",\n\t\t.sta_mask = BIT(24),\n\t\t.ctl_offs = 0x314,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_NONE},\n\t},\n\t[MT6797_POWER_DOMAIN_MFG_ASYNC] = {\n\t\t.name = \"mfg_async\",\n\t\t.sta_mask = BIT(13),\n\t\t.ctl_offs = 0x334,\n\t\t.sram_pdn_bits = 0,\n\t\t.sram_pdn_ack_bits = 0,\n\t\t.clk_id = {CLK_MFG},\n\t},\n\t[MT6797_POWER_DOMAIN_MJC] = {\n\t\t.name = \"mjc\",\n\t\t.sta_mask = BIT(20),\n\t\t.ctl_offs = 0x310,\n\t\t.sram_pdn_bits = GENMASK(8, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(12, 12),\n\t\t.clk_id = {CLK_NONE},\n\t},\n};\n\n#define SPM_PWR_STATUS_MT6797\t\t0x0180\n#define SPM_PWR_STATUS_2ND_MT6797\t0x0184\n\nstatic const struct scp_subdomain scp_subdomain_mt6797[] = {\n\t{MT6797_POWER_DOMAIN_MM, MT6797_POWER_DOMAIN_VDEC},\n\t{MT6797_POWER_DOMAIN_MM, MT6797_POWER_DOMAIN_ISP},\n\t{MT6797_POWER_DOMAIN_MM, MT6797_POWER_DOMAIN_VENC},\n\t{MT6797_POWER_DOMAIN_MM, MT6797_POWER_DOMAIN_MJC},\n};\n\n \n\nstatic const struct scp_domain_data scp_domain_data_mt7622[] = {\n\t[MT7622_POWER_DOMAIN_ETHSYS] = {\n\t\t.name = \"ethsys\",\n\t\t.sta_mask = PWR_STATUS_ETHSYS,\n\t\t.ctl_offs = SPM_ETHSYS_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_NONE},\n\t\t.bus_prot_mask = MT7622_TOP_AXI_PROT_EN_ETHSYS,\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT7622_POWER_DOMAIN_HIF0] = {\n\t\t.name = \"hif0\",\n\t\t.sta_mask = PWR_STATUS_HIF0,\n\t\t.ctl_offs = SPM_HIF0_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_HIFSEL},\n\t\t.bus_prot_mask = MT7622_TOP_AXI_PROT_EN_HIF0,\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT7622_POWER_DOMAIN_HIF1] = {\n\t\t.name = \"hif1\",\n\t\t.sta_mask = PWR_STATUS_HIF1,\n\t\t.ctl_offs = SPM_HIF1_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_HIFSEL},\n\t\t.bus_prot_mask = MT7622_TOP_AXI_PROT_EN_HIF1,\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT7622_POWER_DOMAIN_WB] = {\n\t\t.name = \"wb\",\n\t\t.sta_mask = PWR_STATUS_WB,\n\t\t.ctl_offs = SPM_WB_PWR_CON,\n\t\t.sram_pdn_bits = 0,\n\t\t.sram_pdn_ack_bits = 0,\n\t\t.clk_id = {CLK_NONE},\n\t\t.bus_prot_mask = MT7622_TOP_AXI_PROT_EN_WB,\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP | MTK_SCPD_FWAIT_SRAM,\n\t},\n};\n\n \n\nstatic const struct scp_domain_data scp_domain_data_mt7623a[] = {\n\t[MT7623A_POWER_DOMAIN_CONN] = {\n\t\t.name = \"conn\",\n\t\t.sta_mask = PWR_STATUS_CONN,\n\t\t.ctl_offs = SPM_CONN_PWR_CON,\n\t\t.bus_prot_mask = MT2701_TOP_AXI_PROT_EN_CONN_M |\n\t\t\t\t MT2701_TOP_AXI_PROT_EN_CONN_S,\n\t\t.clk_id = {CLK_NONE},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT7623A_POWER_DOMAIN_ETH] = {\n\t\t.name = \"eth\",\n\t\t.sta_mask = PWR_STATUS_ETH,\n\t\t.ctl_offs = SPM_ETH_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_ETHIF},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT7623A_POWER_DOMAIN_HIF] = {\n\t\t.name = \"hif\",\n\t\t.sta_mask = PWR_STATUS_HIF,\n\t\t.ctl_offs = SPM_HIF_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_ETHIF},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT7623A_POWER_DOMAIN_IFR_MSC] = {\n\t\t.name = \"ifr_msc\",\n\t\t.sta_mask = PWR_STATUS_IFR_MSC,\n\t\t.ctl_offs = SPM_IFR_MSC_PWR_CON,\n\t\t.clk_id = {CLK_NONE},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n};\n\n \n\nstatic const struct scp_domain_data scp_domain_data_mt8173[] = {\n\t[MT8173_POWER_DOMAIN_VDEC] = {\n\t\t.name = \"vdec\",\n\t\t.sta_mask = PWR_STATUS_VDEC,\n\t\t.ctl_offs = SPM_VDE_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(12, 12),\n\t\t.clk_id = {CLK_MM},\n\t},\n\t[MT8173_POWER_DOMAIN_VENC] = {\n\t\t.name = \"venc\",\n\t\t.sta_mask = PWR_STATUS_VENC,\n\t\t.ctl_offs = SPM_VEN_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_MM, CLK_VENC},\n\t},\n\t[MT8173_POWER_DOMAIN_ISP] = {\n\t\t.name = \"isp\",\n\t\t.sta_mask = PWR_STATUS_ISP,\n\t\t.ctl_offs = SPM_ISP_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(13, 12),\n\t\t.clk_id = {CLK_MM},\n\t},\n\t[MT8173_POWER_DOMAIN_MM] = {\n\t\t.name = \"mm\",\n\t\t.sta_mask = PWR_STATUS_DISP,\n\t\t.ctl_offs = SPM_DIS_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(12, 12),\n\t\t.clk_id = {CLK_MM},\n\t\t.bus_prot_mask = MT8173_TOP_AXI_PROT_EN_MM_M0 |\n\t\t\tMT8173_TOP_AXI_PROT_EN_MM_M1,\n\t},\n\t[MT8173_POWER_DOMAIN_VENC_LT] = {\n\t\t.name = \"venc_lt\",\n\t\t.sta_mask = PWR_STATUS_VENC_LT,\n\t\t.ctl_offs = SPM_VEN2_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_MM, CLK_VENC_LT},\n\t},\n\t[MT8173_POWER_DOMAIN_AUDIO] = {\n\t\t.name = \"audio\",\n\t\t.sta_mask = PWR_STATUS_AUDIO,\n\t\t.ctl_offs = SPM_AUDIO_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_NONE},\n\t},\n\t[MT8173_POWER_DOMAIN_USB] = {\n\t\t.name = \"usb\",\n\t\t.sta_mask = PWR_STATUS_USB,\n\t\t.ctl_offs = SPM_USB_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(15, 12),\n\t\t.clk_id = {CLK_NONE},\n\t\t.caps = MTK_SCPD_ACTIVE_WAKEUP,\n\t},\n\t[MT8173_POWER_DOMAIN_MFG_ASYNC] = {\n\t\t.name = \"mfg_async\",\n\t\t.sta_mask = PWR_STATUS_MFG_ASYNC,\n\t\t.ctl_offs = SPM_MFG_ASYNC_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = 0,\n\t\t.clk_id = {CLK_MFG},\n\t},\n\t[MT8173_POWER_DOMAIN_MFG_2D] = {\n\t\t.name = \"mfg_2d\",\n\t\t.sta_mask = PWR_STATUS_MFG_2D,\n\t\t.ctl_offs = SPM_MFG_2D_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(11, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(13, 12),\n\t\t.clk_id = {CLK_NONE},\n\t},\n\t[MT8173_POWER_DOMAIN_MFG] = {\n\t\t.name = \"mfg\",\n\t\t.sta_mask = PWR_STATUS_MFG,\n\t\t.ctl_offs = SPM_MFG_PWR_CON,\n\t\t.sram_pdn_bits = GENMASK(13, 8),\n\t\t.sram_pdn_ack_bits = GENMASK(21, 16),\n\t\t.clk_id = {CLK_NONE},\n\t\t.bus_prot_mask = MT8173_TOP_AXI_PROT_EN_MFG_S |\n\t\t\tMT8173_TOP_AXI_PROT_EN_MFG_M0 |\n\t\t\tMT8173_TOP_AXI_PROT_EN_MFG_M1 |\n\t\t\tMT8173_TOP_AXI_PROT_EN_MFG_SNOOP_OUT,\n\t},\n};\n\nstatic const struct scp_subdomain scp_subdomain_mt8173[] = {\n\t{MT8173_POWER_DOMAIN_MFG_ASYNC, MT8173_POWER_DOMAIN_MFG_2D},\n\t{MT8173_POWER_DOMAIN_MFG_2D, MT8173_POWER_DOMAIN_MFG},\n};\n\nstatic const struct scp_soc_data mt2701_data = {\n\t.domains = scp_domain_data_mt2701,\n\t.num_domains = ARRAY_SIZE(scp_domain_data_mt2701),\n\t.regs = {\n\t\t.pwr_sta_offs = SPM_PWR_STATUS,\n\t\t.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND\n\t},\n\t.bus_prot_reg_update = true,\n};\n\nstatic const struct scp_soc_data mt2712_data = {\n\t.domains = scp_domain_data_mt2712,\n\t.num_domains = ARRAY_SIZE(scp_domain_data_mt2712),\n\t.subdomains = scp_subdomain_mt2712,\n\t.num_subdomains = ARRAY_SIZE(scp_subdomain_mt2712),\n\t.regs = {\n\t\t.pwr_sta_offs = SPM_PWR_STATUS,\n\t\t.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND\n\t},\n\t.bus_prot_reg_update = false,\n};\n\nstatic const struct scp_soc_data mt6797_data = {\n\t.domains = scp_domain_data_mt6797,\n\t.num_domains = ARRAY_SIZE(scp_domain_data_mt6797),\n\t.subdomains = scp_subdomain_mt6797,\n\t.num_subdomains = ARRAY_SIZE(scp_subdomain_mt6797),\n\t.regs = {\n\t\t.pwr_sta_offs = SPM_PWR_STATUS_MT6797,\n\t\t.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND_MT6797\n\t},\n\t.bus_prot_reg_update = true,\n};\n\nstatic const struct scp_soc_data mt7622_data = {\n\t.domains = scp_domain_data_mt7622,\n\t.num_domains = ARRAY_SIZE(scp_domain_data_mt7622),\n\t.regs = {\n\t\t.pwr_sta_offs = SPM_PWR_STATUS,\n\t\t.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND\n\t},\n\t.bus_prot_reg_update = true,\n};\n\nstatic const struct scp_soc_data mt7623a_data = {\n\t.domains = scp_domain_data_mt7623a,\n\t.num_domains = ARRAY_SIZE(scp_domain_data_mt7623a),\n\t.regs = {\n\t\t.pwr_sta_offs = SPM_PWR_STATUS,\n\t\t.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND\n\t},\n\t.bus_prot_reg_update = true,\n};\n\nstatic const struct scp_soc_data mt8173_data = {\n\t.domains = scp_domain_data_mt8173,\n\t.num_domains = ARRAY_SIZE(scp_domain_data_mt8173),\n\t.subdomains = scp_subdomain_mt8173,\n\t.num_subdomains = ARRAY_SIZE(scp_subdomain_mt8173),\n\t.regs = {\n\t\t.pwr_sta_offs = SPM_PWR_STATUS,\n\t\t.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND\n\t},\n\t.bus_prot_reg_update = true,\n};\n\n \n\nstatic const struct of_device_id of_scpsys_match_tbl[] = {\n\t{\n\t\t.compatible = \"mediatek,mt2701-scpsys\",\n\t\t.data = &mt2701_data,\n\t}, {\n\t\t.compatible = \"mediatek,mt2712-scpsys\",\n\t\t.data = &mt2712_data,\n\t}, {\n\t\t.compatible = \"mediatek,mt6797-scpsys\",\n\t\t.data = &mt6797_data,\n\t}, {\n\t\t.compatible = \"mediatek,mt7622-scpsys\",\n\t\t.data = &mt7622_data,\n\t}, {\n\t\t.compatible = \"mediatek,mt7623a-scpsys\",\n\t\t.data = &mt7623a_data,\n\t}, {\n\t\t.compatible = \"mediatek,mt8173-scpsys\",\n\t\t.data = &mt8173_data,\n\t}, {\n\t\t \n\t}\n};\n\nstatic int scpsys_probe(struct platform_device *pdev)\n{\n\tconst struct scp_subdomain *sd;\n\tconst struct scp_soc_data *soc;\n\tstruct scp *scp;\n\tstruct genpd_onecell_data *pd_data;\n\tint i, ret;\n\n\tsoc = of_device_get_match_data(&pdev->dev);\n\n\tscp = init_scp(pdev, soc->domains, soc->num_domains, &soc->regs,\n\t\t\tsoc->bus_prot_reg_update);\n\tif (IS_ERR(scp))\n\t\treturn PTR_ERR(scp);\n\n\tmtk_register_power_domains(pdev, scp, soc->num_domains);\n\n\tpd_data = &scp->pd_data;\n\n\tfor (i = 0, sd = soc->subdomains; i < soc->num_subdomains; i++, sd++) {\n\t\tret = pm_genpd_add_subdomain(pd_data->domains[sd->origin],\n\t\t\t\t\t     pd_data->domains[sd->subdomain]);\n\t\tif (ret && IS_ENABLED(CONFIG_PM))\n\t\t\tdev_err(&pdev->dev, \"Failed to add subdomain: %d\\n\",\n\t\t\t\tret);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver scpsys_drv = {\n\t.probe = scpsys_probe,\n\t.driver = {\n\t\t.name = \"mtk-scpsys\",\n\t\t.suppress_bind_attrs = true,\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = of_scpsys_match_tbl,\n\t},\n};\nbuiltin_platform_driver(scpsys_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}