{
  "module_name": "mtk-pm-domains.c",
  "hash_id": "4698b10cf9711e9a10187ee800ef0f68e97d8b03c17df41e789d9b3f025033a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/mediatek/mtk-pm-domains.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_clk.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/soc/mediatek/infracfg.h>\n\n#include \"mt6795-pm-domains.h\"\n#include \"mt8167-pm-domains.h\"\n#include \"mt8173-pm-domains.h\"\n#include \"mt8183-pm-domains.h\"\n#include \"mt8186-pm-domains.h\"\n#include \"mt8188-pm-domains.h\"\n#include \"mt8192-pm-domains.h\"\n#include \"mt8195-pm-domains.h\"\n\n#define MTK_POLL_DELAY_US\t\t10\n#define MTK_POLL_TIMEOUT\t\tUSEC_PER_SEC\n\n#define PWR_RST_B_BIT\t\t\tBIT(0)\n#define PWR_ISO_BIT\t\t\tBIT(1)\n#define PWR_ON_BIT\t\t\tBIT(2)\n#define PWR_ON_2ND_BIT\t\t\tBIT(3)\n#define PWR_CLK_DIS_BIT\t\t\tBIT(4)\n#define PWR_SRAM_CLKISO_BIT\t\tBIT(5)\n#define PWR_SRAM_ISOINT_B_BIT\t\tBIT(6)\n\nstruct scpsys_domain {\n\tstruct generic_pm_domain genpd;\n\tconst struct scpsys_domain_data *data;\n\tstruct scpsys *scpsys;\n\tint num_clks;\n\tstruct clk_bulk_data *clks;\n\tint num_subsys_clks;\n\tstruct clk_bulk_data *subsys_clks;\n\tstruct regmap *infracfg;\n\tstruct regmap *smi;\n\tstruct regulator *supply;\n};\n\nstruct scpsys {\n\tstruct device *dev;\n\tstruct regmap *base;\n\tconst struct scpsys_soc_data *soc_data;\n\tstruct genpd_onecell_data pd_data;\n\tstruct generic_pm_domain *domains[];\n};\n\n#define to_scpsys_domain(gpd) container_of(gpd, struct scpsys_domain, genpd)\n\nstatic bool scpsys_domain_is_on(struct scpsys_domain *pd)\n{\n\tstruct scpsys *scpsys = pd->scpsys;\n\tu32 status, status2;\n\n\tregmap_read(scpsys->base, pd->data->pwr_sta_offs, &status);\n\tstatus &= pd->data->sta_mask;\n\n\tregmap_read(scpsys->base, pd->data->pwr_sta2nd_offs, &status2);\n\tstatus2 &= pd->data->sta_mask;\n\n\t \n\treturn status && status2;\n}\n\nstatic int scpsys_sram_enable(struct scpsys_domain *pd)\n{\n\tu32 pdn_ack = pd->data->sram_pdn_ack_bits;\n\tstruct scpsys *scpsys = pd->scpsys;\n\tunsigned int tmp;\n\tint ret;\n\n\tregmap_clear_bits(scpsys->base, pd->data->ctl_offs, pd->data->sram_pdn_bits);\n\n\t \n\tret = regmap_read_poll_timeout(scpsys->base, pd->data->ctl_offs, tmp,\n\t\t\t\t       (tmp & pdn_ack) == 0, MTK_POLL_DELAY_US, MTK_POLL_TIMEOUT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (MTK_SCPD_CAPS(pd, MTK_SCPD_SRAM_ISO)) {\n\t\tregmap_set_bits(scpsys->base, pd->data->ctl_offs, PWR_SRAM_ISOINT_B_BIT);\n\t\tudelay(1);\n\t\tregmap_clear_bits(scpsys->base, pd->data->ctl_offs, PWR_SRAM_CLKISO_BIT);\n\t}\n\n\treturn 0;\n}\n\nstatic int scpsys_sram_disable(struct scpsys_domain *pd)\n{\n\tu32 pdn_ack = pd->data->sram_pdn_ack_bits;\n\tstruct scpsys *scpsys = pd->scpsys;\n\tunsigned int tmp;\n\n\tif (MTK_SCPD_CAPS(pd, MTK_SCPD_SRAM_ISO)) {\n\t\tregmap_set_bits(scpsys->base, pd->data->ctl_offs, PWR_SRAM_CLKISO_BIT);\n\t\tudelay(1);\n\t\tregmap_clear_bits(scpsys->base, pd->data->ctl_offs, PWR_SRAM_ISOINT_B_BIT);\n\t}\n\n\tregmap_set_bits(scpsys->base, pd->data->ctl_offs, pd->data->sram_pdn_bits);\n\n\t \n\treturn regmap_read_poll_timeout(scpsys->base, pd->data->ctl_offs, tmp,\n\t\t\t\t\t(tmp & pdn_ack) == pdn_ack, MTK_POLL_DELAY_US,\n\t\t\t\t\tMTK_POLL_TIMEOUT);\n}\n\nstatic int _scpsys_bus_protect_enable(const struct scpsys_bus_prot_data *bpd, struct regmap *regmap)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < SPM_MAX_BUS_PROT_DATA; i++) {\n\t\tu32 val, mask = bpd[i].bus_prot_mask;\n\n\t\tif (!mask)\n\t\t\tbreak;\n\n\t\tif (bpd[i].bus_prot_reg_update)\n\t\t\tregmap_set_bits(regmap, bpd[i].bus_prot_set, mask);\n\t\telse\n\t\t\tregmap_write(regmap, bpd[i].bus_prot_set, mask);\n\n\t\tret = regmap_read_poll_timeout(regmap, bpd[i].bus_prot_sta,\n\t\t\t\t\t       val, (val & mask) == mask,\n\t\t\t\t\t       MTK_POLL_DELAY_US, MTK_POLL_TIMEOUT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int scpsys_bus_protect_enable(struct scpsys_domain *pd)\n{\n\tint ret;\n\n\tret = _scpsys_bus_protect_enable(pd->data->bp_infracfg, pd->infracfg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn _scpsys_bus_protect_enable(pd->data->bp_smi, pd->smi);\n}\n\nstatic int _scpsys_bus_protect_disable(const struct scpsys_bus_prot_data *bpd,\n\t\t\t\t       struct regmap *regmap)\n{\n\tint i, ret;\n\n\tfor (i = SPM_MAX_BUS_PROT_DATA - 1; i >= 0; i--) {\n\t\tu32 val, mask = bpd[i].bus_prot_mask;\n\n\t\tif (!mask)\n\t\t\tcontinue;\n\n\t\tif (bpd[i].bus_prot_reg_update)\n\t\t\tregmap_clear_bits(regmap, bpd[i].bus_prot_clr, mask);\n\t\telse\n\t\t\tregmap_write(regmap, bpd[i].bus_prot_clr, mask);\n\n\t\tif (bpd[i].ignore_clr_ack)\n\t\t\tcontinue;\n\n\t\tret = regmap_read_poll_timeout(regmap, bpd[i].bus_prot_sta,\n\t\t\t\t\t       val, !(val & mask),\n\t\t\t\t\t       MTK_POLL_DELAY_US, MTK_POLL_TIMEOUT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int scpsys_bus_protect_disable(struct scpsys_domain *pd)\n{\n\tint ret;\n\n\tret = _scpsys_bus_protect_disable(pd->data->bp_smi, pd->smi);\n\tif (ret)\n\t\treturn ret;\n\n\treturn _scpsys_bus_protect_disable(pd->data->bp_infracfg, pd->infracfg);\n}\n\nstatic int scpsys_regulator_enable(struct regulator *supply)\n{\n\treturn supply ? regulator_enable(supply) : 0;\n}\n\nstatic int scpsys_regulator_disable(struct regulator *supply)\n{\n\treturn supply ? regulator_disable(supply) : 0;\n}\n\nstatic int scpsys_power_on(struct generic_pm_domain *genpd)\n{\n\tstruct scpsys_domain *pd = container_of(genpd, struct scpsys_domain, genpd);\n\tstruct scpsys *scpsys = pd->scpsys;\n\tbool tmp;\n\tint ret;\n\n\tret = scpsys_regulator_enable(pd->supply);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(pd->num_clks, pd->clks);\n\tif (ret)\n\t\tgoto err_reg;\n\n\tif (pd->data->ext_buck_iso_offs && MTK_SCPD_CAPS(pd, MTK_SCPD_EXT_BUCK_ISO))\n\t\tregmap_clear_bits(scpsys->base, pd->data->ext_buck_iso_offs,\n\t\t\t\t  pd->data->ext_buck_iso_mask);\n\n\t \n\tregmap_set_bits(scpsys->base, pd->data->ctl_offs, PWR_ON_BIT);\n\tregmap_set_bits(scpsys->base, pd->data->ctl_offs, PWR_ON_2ND_BIT);\n\n\t \n\tret = readx_poll_timeout(scpsys_domain_is_on, pd, tmp, tmp, MTK_POLL_DELAY_US,\n\t\t\t\t MTK_POLL_TIMEOUT);\n\tif (ret < 0)\n\t\tgoto err_pwr_ack;\n\n\tregmap_clear_bits(scpsys->base, pd->data->ctl_offs, PWR_CLK_DIS_BIT);\n\tregmap_clear_bits(scpsys->base, pd->data->ctl_offs, PWR_ISO_BIT);\n\tregmap_set_bits(scpsys->base, pd->data->ctl_offs, PWR_RST_B_BIT);\n\n\tret = clk_bulk_prepare_enable(pd->num_subsys_clks, pd->subsys_clks);\n\tif (ret)\n\t\tgoto err_pwr_ack;\n\n\tret = scpsys_sram_enable(pd);\n\tif (ret < 0)\n\t\tgoto err_disable_subsys_clks;\n\n\tret = scpsys_bus_protect_disable(pd);\n\tif (ret < 0)\n\t\tgoto err_disable_sram;\n\n\treturn 0;\n\nerr_disable_sram:\n\tscpsys_sram_disable(pd);\nerr_disable_subsys_clks:\n\tclk_bulk_disable_unprepare(pd->num_subsys_clks, pd->subsys_clks);\nerr_pwr_ack:\n\tclk_bulk_disable_unprepare(pd->num_clks, pd->clks);\nerr_reg:\n\tscpsys_regulator_disable(pd->supply);\n\treturn ret;\n}\n\nstatic int scpsys_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct scpsys_domain *pd = container_of(genpd, struct scpsys_domain, genpd);\n\tstruct scpsys *scpsys = pd->scpsys;\n\tbool tmp;\n\tint ret;\n\n\tret = scpsys_bus_protect_enable(pd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = scpsys_sram_disable(pd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pd->data->ext_buck_iso_offs && MTK_SCPD_CAPS(pd, MTK_SCPD_EXT_BUCK_ISO))\n\t\tregmap_set_bits(scpsys->base, pd->data->ext_buck_iso_offs,\n\t\t\t\tpd->data->ext_buck_iso_mask);\n\n\tclk_bulk_disable_unprepare(pd->num_subsys_clks, pd->subsys_clks);\n\n\t \n\tregmap_set_bits(scpsys->base, pd->data->ctl_offs, PWR_ISO_BIT);\n\tregmap_set_bits(scpsys->base, pd->data->ctl_offs, PWR_CLK_DIS_BIT);\n\tregmap_clear_bits(scpsys->base, pd->data->ctl_offs, PWR_RST_B_BIT);\n\tregmap_clear_bits(scpsys->base, pd->data->ctl_offs, PWR_ON_2ND_BIT);\n\tregmap_clear_bits(scpsys->base, pd->data->ctl_offs, PWR_ON_BIT);\n\n\t \n\tret = readx_poll_timeout(scpsys_domain_is_on, pd, tmp, !tmp, MTK_POLL_DELAY_US,\n\t\t\t\t MTK_POLL_TIMEOUT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tclk_bulk_disable_unprepare(pd->num_clks, pd->clks);\n\n\tscpsys_regulator_disable(pd->supply);\n\n\treturn 0;\n}\n\nstatic struct\ngeneric_pm_domain *scpsys_add_one_domain(struct scpsys *scpsys, struct device_node *node)\n{\n\tconst struct scpsys_domain_data *domain_data;\n\tstruct scpsys_domain *pd;\n\tstruct device_node *root_node = scpsys->dev->of_node;\n\tstruct device_node *smi_node;\n\tstruct property *prop;\n\tconst char *clk_name;\n\tint i, ret, num_clks;\n\tstruct clk *clk;\n\tint clk_ind = 0;\n\tu32 id;\n\n\tret = of_property_read_u32(node, \"reg\", &id);\n\tif (ret) {\n\t\tdev_err(scpsys->dev, \"%pOF: failed to retrieve domain id from reg: %d\\n\",\n\t\t\tnode, ret);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (id >= scpsys->soc_data->num_domains) {\n\t\tdev_err(scpsys->dev, \"%pOF: invalid domain id %d\\n\", node, id);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdomain_data = &scpsys->soc_data->domains_data[id];\n\tif (domain_data->sta_mask == 0) {\n\t\tdev_err(scpsys->dev, \"%pOF: undefined domain id %d\\n\", node, id);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpd = devm_kzalloc(scpsys->dev, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpd->data = domain_data;\n\tpd->scpsys = scpsys;\n\n\tif (MTK_SCPD_CAPS(pd, MTK_SCPD_DOMAIN_SUPPLY)) {\n\t\t \n\t\tscpsys->dev->of_node = node;\n\t\tpd->supply = devm_regulator_get(scpsys->dev, \"domain\");\n\t\tscpsys->dev->of_node = root_node;\n\t\tif (IS_ERR(pd->supply)) {\n\t\t\tdev_err_probe(scpsys->dev, PTR_ERR(pd->supply),\n\t\t\t\t      \"%pOF: failed to get power supply.\\n\",\n\t\t\t\t      node);\n\t\t\treturn ERR_CAST(pd->supply);\n\t\t}\n\t}\n\n\tpd->infracfg = syscon_regmap_lookup_by_phandle_optional(node, \"mediatek,infracfg\");\n\tif (IS_ERR(pd->infracfg))\n\t\treturn ERR_CAST(pd->infracfg);\n\n\tsmi_node = of_parse_phandle(node, \"mediatek,smi\", 0);\n\tif (smi_node) {\n\t\tpd->smi = device_node_to_regmap(smi_node);\n\t\tof_node_put(smi_node);\n\t\tif (IS_ERR(pd->smi))\n\t\t\treturn ERR_CAST(pd->smi);\n\t}\n\n\tnum_clks = of_clk_get_parent_count(node);\n\tif (num_clks > 0) {\n\t\t \n\t\tof_property_for_each_string(node, \"clock-names\", prop, clk_name) {\n\t\t\tchar *subsys;\n\n\t\t\tsubsys = strchr(clk_name, '-');\n\t\t\tif (subsys)\n\t\t\t\tpd->num_subsys_clks++;\n\t\t\telse\n\t\t\t\tpd->num_clks++;\n\t\t}\n\n\t\tpd->clks = devm_kcalloc(scpsys->dev, pd->num_clks, sizeof(*pd->clks), GFP_KERNEL);\n\t\tif (!pd->clks)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tpd->subsys_clks = devm_kcalloc(scpsys->dev, pd->num_subsys_clks,\n\t\t\t\t\t       sizeof(*pd->subsys_clks), GFP_KERNEL);\n\t\tif (!pd->subsys_clks)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t}\n\n\tfor (i = 0; i < pd->num_clks; i++) {\n\t\tclk = of_clk_get(node, i);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tdev_err_probe(scpsys->dev, ret,\n\t\t\t\t      \"%pOF: failed to get clk at index %d\\n\", node, i);\n\t\t\tgoto err_put_clocks;\n\t\t}\n\n\t\tpd->clks[clk_ind++].clk = clk;\n\t}\n\n\tfor (i = 0; i < pd->num_subsys_clks; i++) {\n\t\tclk = of_clk_get(node, i + clk_ind);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tdev_err_probe(scpsys->dev, ret,\n\t\t\t\t      \"%pOF: failed to get clk at index %d\\n\", node,\n\t\t\t\t      i + clk_ind);\n\t\t\tgoto err_put_subsys_clocks;\n\t\t}\n\n\t\tpd->subsys_clks[i].clk = clk;\n\t}\n\n\t \n\tif (MTK_SCPD_CAPS(pd, MTK_SCPD_KEEP_DEFAULT_OFF)) {\n\t\tif (scpsys_domain_is_on(pd))\n\t\t\tdev_warn(scpsys->dev,\n\t\t\t\t \"%pOF: A default off power domain has been ON\\n\", node);\n\t} else {\n\t\tret = scpsys_power_on(&pd->genpd);\n\t\tif (ret < 0) {\n\t\t\tdev_err(scpsys->dev, \"%pOF: failed to power on domain: %d\\n\", node, ret);\n\t\t\tgoto err_put_subsys_clocks;\n\t\t}\n\n\t\tif (MTK_SCPD_CAPS(pd, MTK_SCPD_ALWAYS_ON))\n\t\t\tpd->genpd.flags |= GENPD_FLAG_ALWAYS_ON;\n\t}\n\n\tif (scpsys->domains[id]) {\n\t\tret = -EINVAL;\n\t\tdev_err(scpsys->dev,\n\t\t\t\"power domain with id %d already exists, check your device-tree\\n\", id);\n\t\tgoto err_put_subsys_clocks;\n\t}\n\n\tif (!pd->data->name)\n\t\tpd->genpd.name = node->name;\n\telse\n\t\tpd->genpd.name = pd->data->name;\n\n\tpd->genpd.power_off = scpsys_power_off;\n\tpd->genpd.power_on = scpsys_power_on;\n\n\tif (MTK_SCPD_CAPS(pd, MTK_SCPD_ACTIVE_WAKEUP))\n\t\tpd->genpd.flags |= GENPD_FLAG_ACTIVE_WAKEUP;\n\n\tif (MTK_SCPD_CAPS(pd, MTK_SCPD_KEEP_DEFAULT_OFF))\n\t\tpm_genpd_init(&pd->genpd, NULL, true);\n\telse\n\t\tpm_genpd_init(&pd->genpd, NULL, false);\n\n\tscpsys->domains[id] = &pd->genpd;\n\n\treturn scpsys->pd_data.domains[id];\n\nerr_put_subsys_clocks:\n\tclk_bulk_put(pd->num_subsys_clks, pd->subsys_clks);\nerr_put_clocks:\n\tclk_bulk_put(pd->num_clks, pd->clks);\n\treturn ERR_PTR(ret);\n}\n\nstatic int scpsys_add_subdomain(struct scpsys *scpsys, struct device_node *parent)\n{\n\tstruct generic_pm_domain *child_pd, *parent_pd;\n\tstruct device_node *child;\n\tint ret;\n\n\tfor_each_child_of_node(parent, child) {\n\t\tu32 id;\n\n\t\tret = of_property_read_u32(parent, \"reg\", &id);\n\t\tif (ret) {\n\t\t\tdev_err(scpsys->dev, \"%pOF: failed to get parent domain id\\n\", child);\n\t\t\tgoto err_put_node;\n\t\t}\n\n\t\tif (!scpsys->pd_data.domains[id]) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(scpsys->dev, \"power domain with id %d does not exist\\n\", id);\n\t\t\tgoto err_put_node;\n\t\t}\n\n\t\tparent_pd = scpsys->pd_data.domains[id];\n\n\t\tchild_pd = scpsys_add_one_domain(scpsys, child);\n\t\tif (IS_ERR(child_pd)) {\n\t\t\tret = PTR_ERR(child_pd);\n\t\t\tdev_err_probe(scpsys->dev, ret, \"%pOF: failed to get child domain id\\n\",\n\t\t\t\t      child);\n\t\t\tgoto err_put_node;\n\t\t}\n\n\t\tret = pm_genpd_add_subdomain(parent_pd, child_pd);\n\t\tif (ret) {\n\t\t\tdev_err(scpsys->dev, \"failed to add %s subdomain to parent %s\\n\",\n\t\t\t\tchild_pd->name, parent_pd->name);\n\t\t\tgoto err_put_node;\n\t\t} else {\n\t\t\tdev_dbg(scpsys->dev, \"%s add subdomain: %s\\n\", parent_pd->name,\n\t\t\t\tchild_pd->name);\n\t\t}\n\n\t\t \n\t\tret = scpsys_add_subdomain(scpsys, child);\n\t\tif (ret)\n\t\t\tgoto err_put_node;\n\t}\n\n\treturn 0;\n\nerr_put_node:\n\tof_node_put(child);\n\treturn ret;\n}\n\nstatic void scpsys_remove_one_domain(struct scpsys_domain *pd)\n{\n\tint ret;\n\n\tif (scpsys_domain_is_on(pd))\n\t\tscpsys_power_off(&pd->genpd);\n\n\t \n\tret = pm_genpd_remove(&pd->genpd);\n\tif (ret < 0)\n\t\tdev_err(pd->scpsys->dev,\n\t\t\t\"failed to remove domain '%s' : %d - state may be inconsistent\\n\",\n\t\t\tpd->genpd.name, ret);\n\n\tclk_bulk_put(pd->num_clks, pd->clks);\n\tclk_bulk_put(pd->num_subsys_clks, pd->subsys_clks);\n}\n\nstatic void scpsys_domain_cleanup(struct scpsys *scpsys)\n{\n\tstruct generic_pm_domain *genpd;\n\tstruct scpsys_domain *pd;\n\tint i;\n\n\tfor (i = scpsys->pd_data.num_domains - 1; i >= 0; i--) {\n\t\tgenpd = scpsys->pd_data.domains[i];\n\t\tif (genpd) {\n\t\t\tpd = to_scpsys_domain(genpd);\n\t\t\tscpsys_remove_one_domain(pd);\n\t\t}\n\t}\n}\n\nstatic const struct of_device_id scpsys_of_match[] = {\n\t{\n\t\t.compatible = \"mediatek,mt6795-power-controller\",\n\t\t.data = &mt6795_scpsys_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8167-power-controller\",\n\t\t.data = &mt8167_scpsys_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8173-power-controller\",\n\t\t.data = &mt8173_scpsys_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8183-power-controller\",\n\t\t.data = &mt8183_scpsys_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8186-power-controller\",\n\t\t.data = &mt8186_scpsys_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8188-power-controller\",\n\t\t.data = &mt8188_scpsys_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8192-power-controller\",\n\t\t.data = &mt8192_scpsys_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8195-power-controller\",\n\t\t.data = &mt8195_scpsys_data,\n\t},\n\t{ }\n};\n\nstatic int scpsys_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct scpsys_soc_data *soc;\n\tstruct device_node *node;\n\tstruct device *parent;\n\tstruct scpsys *scpsys;\n\tint ret;\n\n\tsoc = of_device_get_match_data(&pdev->dev);\n\tif (!soc) {\n\t\tdev_err(&pdev->dev, \"no power controller data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tscpsys = devm_kzalloc(dev, struct_size(scpsys, domains, soc->num_domains), GFP_KERNEL);\n\tif (!scpsys)\n\t\treturn -ENOMEM;\n\n\tscpsys->dev = dev;\n\tscpsys->soc_data = soc;\n\n\tscpsys->pd_data.domains = scpsys->domains;\n\tscpsys->pd_data.num_domains = soc->num_domains;\n\n\tparent = dev->parent;\n\tif (!parent) {\n\t\tdev_err(dev, \"no parent for syscon devices\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tscpsys->base = syscon_node_to_regmap(parent->of_node);\n\tif (IS_ERR(scpsys->base)) {\n\t\tdev_err(dev, \"no regmap available\\n\");\n\t\treturn PTR_ERR(scpsys->base);\n\t}\n\n\tret = -ENODEV;\n\tfor_each_available_child_of_node(np, node) {\n\t\tstruct generic_pm_domain *domain;\n\n\t\tdomain = scpsys_add_one_domain(scpsys, node);\n\t\tif (IS_ERR(domain)) {\n\t\t\tret = PTR_ERR(domain);\n\t\t\tof_node_put(node);\n\t\t\tgoto err_cleanup_domains;\n\t\t}\n\n\t\tret = scpsys_add_subdomain(scpsys, node);\n\t\tif (ret) {\n\t\t\tof_node_put(node);\n\t\t\tgoto err_cleanup_domains;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tdev_dbg(dev, \"no power domains present\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_genpd_add_provider_onecell(np, &scpsys->pd_data);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add provider: %d\\n\", ret);\n\t\tgoto err_cleanup_domains;\n\t}\n\n\treturn 0;\n\nerr_cleanup_domains:\n\tscpsys_domain_cleanup(scpsys);\n\treturn ret;\n}\n\nstatic struct platform_driver scpsys_pm_domain_driver = {\n\t.probe = scpsys_probe,\n\t.driver = {\n\t\t.name = \"mtk-power-controller\",\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table = scpsys_of_match,\n\t},\n};\nbuiltin_platform_driver(scpsys_pm_domain_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}