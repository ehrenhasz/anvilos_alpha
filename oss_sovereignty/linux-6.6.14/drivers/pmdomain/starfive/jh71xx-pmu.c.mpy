{
  "module_name": "jh71xx-pmu.c",
  "hash_id": "0df4163c645ea416ff45e3dba701e05723cce7df1a21b04dc28740c7045750a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/starfive/jh71xx-pmu.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <dt-bindings/power/starfive,jh7110-pmu.h>\n\n \n#define JH71XX_PMU_SW_TURN_ON_POWER\t0x0C\n#define JH71XX_PMU_SW_TURN_OFF_POWER\t0x10\n#define JH71XX_PMU_SW_ENCOURAGE\t\t0x44\n#define JH71XX_PMU_TIMER_INT_MASK\t0x48\n#define JH71XX_PMU_CURR_POWER_MODE\t0x80\n#define JH71XX_PMU_EVENT_STATUS\t\t0x88\n#define JH71XX_PMU_INT_STATUS\t\t0x8C\n\n \n#define JH71XX_PMU_SW_ENCOURAGE_EN_LO\t0x05\n#define JH71XX_PMU_SW_ENCOURAGE_EN_HI\t0x50\n#define JH71XX_PMU_SW_ENCOURAGE_DIS_LO\t0x0A\n#define JH71XX_PMU_SW_ENCOURAGE_DIS_HI\t0xA0\n#define JH71XX_PMU_SW_ENCOURAGE_ON\t0xFF\n\n \n#define JH71XX_PMU_INT_SEQ_DONE\t\tBIT(0)\n#define JH71XX_PMU_INT_HW_REQ\t\tBIT(1)\n#define JH71XX_PMU_INT_SW_FAIL\t\tGENMASK(3, 2)\n#define JH71XX_PMU_INT_HW_FAIL\t\tGENMASK(5, 4)\n#define JH71XX_PMU_INT_PCH_FAIL\t\tGENMASK(8, 6)\n#define JH71XX_PMU_INT_ALL_MASK\t\tGENMASK(8, 0)\n\n \n#define JH71XX_PMU_TIMEOUT_US\t\t100\n\nstruct jh71xx_domain_info {\n\tconst char * const name;\n\tunsigned int flags;\n\tu8 bit;\n};\n\nstruct jh71xx_pmu_match_data {\n\tconst struct jh71xx_domain_info *domain_info;\n\tint num_domains;\n};\n\nstruct jh71xx_pmu {\n\tstruct device *dev;\n\tconst struct jh71xx_pmu_match_data *match_data;\n\tvoid __iomem *base;\n\tstruct generic_pm_domain **genpd;\n\tstruct genpd_onecell_data genpd_data;\n\tint irq;\n\tspinlock_t lock;\t \n};\n\nstruct jh71xx_pmu_dev {\n\tconst struct jh71xx_domain_info *domain_info;\n\tstruct jh71xx_pmu *pmu;\n\tstruct generic_pm_domain genpd;\n};\n\nstatic int jh71xx_pmu_get_state(struct jh71xx_pmu_dev *pmd, u32 mask, bool *is_on)\n{\n\tstruct jh71xx_pmu *pmu = pmd->pmu;\n\n\tif (!mask)\n\t\treturn -EINVAL;\n\n\t*is_on = readl(pmu->base + JH71XX_PMU_CURR_POWER_MODE) & mask;\n\n\treturn 0;\n}\n\nstatic int jh71xx_pmu_set_state(struct jh71xx_pmu_dev *pmd, u32 mask, bool on)\n{\n\tstruct jh71xx_pmu *pmu = pmd->pmu;\n\tunsigned long flags;\n\tu32 val;\n\tu32 mode;\n\tu32 encourage_lo;\n\tu32 encourage_hi;\n\tbool is_on;\n\tint ret;\n\n\tret = jh71xx_pmu_get_state(pmd, mask, &is_on);\n\tif (ret) {\n\t\tdev_dbg(pmu->dev, \"unable to get current state for %s\\n\",\n\t\t\tpmd->genpd.name);\n\t\treturn ret;\n\t}\n\n\tif (is_on == on) {\n\t\tdev_dbg(pmu->dev, \"pm domain [%s] is already %sable status.\\n\",\n\t\t\tpmd->genpd.name, on ? \"en\" : \"dis\");\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&pmu->lock, flags);\n\n\t \n\tif (on) {\n\t\tmode = JH71XX_PMU_SW_TURN_ON_POWER;\n\t\tencourage_lo = JH71XX_PMU_SW_ENCOURAGE_EN_LO;\n\t\tencourage_hi = JH71XX_PMU_SW_ENCOURAGE_EN_HI;\n\t} else {\n\t\tmode = JH71XX_PMU_SW_TURN_OFF_POWER;\n\t\tencourage_lo = JH71XX_PMU_SW_ENCOURAGE_DIS_LO;\n\t\tencourage_hi = JH71XX_PMU_SW_ENCOURAGE_DIS_HI;\n\t}\n\n\twritel(mask, pmu->base + mode);\n\n\t \n\twritel(JH71XX_PMU_SW_ENCOURAGE_ON, pmu->base + JH71XX_PMU_SW_ENCOURAGE);\n\twritel(encourage_lo, pmu->base + JH71XX_PMU_SW_ENCOURAGE);\n\twritel(encourage_hi, pmu->base + JH71XX_PMU_SW_ENCOURAGE);\n\n\tspin_unlock_irqrestore(&pmu->lock, flags);\n\n\t \n\tif (on) {\n\t\tret = readl_poll_timeout_atomic(pmu->base + JH71XX_PMU_CURR_POWER_MODE,\n\t\t\t\t\t\tval, val & mask,\n\t\t\t\t\t\t1, JH71XX_PMU_TIMEOUT_US);\n\t} else {\n\t\tret = readl_poll_timeout_atomic(pmu->base + JH71XX_PMU_CURR_POWER_MODE,\n\t\t\t\t\t\tval, !(val & mask),\n\t\t\t\t\t\t1, JH71XX_PMU_TIMEOUT_US);\n\t}\n\n\tif (ret) {\n\t\tdev_err(pmu->dev, \"%s: failed to power %s\\n\",\n\t\t\tpmd->genpd.name, on ? \"on\" : \"off\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int jh71xx_pmu_on(struct generic_pm_domain *genpd)\n{\n\tstruct jh71xx_pmu_dev *pmd = container_of(genpd,\n\t\t\t\t\t\t  struct jh71xx_pmu_dev, genpd);\n\tu32 pwr_mask = BIT(pmd->domain_info->bit);\n\n\treturn jh71xx_pmu_set_state(pmd, pwr_mask, true);\n}\n\nstatic int jh71xx_pmu_off(struct generic_pm_domain *genpd)\n{\n\tstruct jh71xx_pmu_dev *pmd = container_of(genpd,\n\t\t\t\t\t\t  struct jh71xx_pmu_dev, genpd);\n\tu32 pwr_mask = BIT(pmd->domain_info->bit);\n\n\treturn jh71xx_pmu_set_state(pmd, pwr_mask, false);\n}\n\nstatic void jh71xx_pmu_int_enable(struct jh71xx_pmu *pmu, u32 mask, bool enable)\n{\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pmu->lock, flags);\n\tval = readl(pmu->base + JH71XX_PMU_TIMER_INT_MASK);\n\n\tif (enable)\n\t\tval &= ~mask;\n\telse\n\t\tval |= mask;\n\n\twritel(val, pmu->base + JH71XX_PMU_TIMER_INT_MASK);\n\tspin_unlock_irqrestore(&pmu->lock, flags);\n}\n\nstatic irqreturn_t jh71xx_pmu_interrupt(int irq, void *data)\n{\n\tstruct jh71xx_pmu *pmu = data;\n\tu32 val;\n\n\tval = readl(pmu->base + JH71XX_PMU_INT_STATUS);\n\n\tif (val & JH71XX_PMU_INT_SEQ_DONE)\n\t\tdev_dbg(pmu->dev, \"sequence done.\\n\");\n\tif (val & JH71XX_PMU_INT_HW_REQ)\n\t\tdev_dbg(pmu->dev, \"hardware encourage requestion.\\n\");\n\tif (val & JH71XX_PMU_INT_SW_FAIL)\n\t\tdev_err(pmu->dev, \"software encourage fail.\\n\");\n\tif (val & JH71XX_PMU_INT_HW_FAIL)\n\t\tdev_err(pmu->dev, \"hardware encourage fail.\\n\");\n\tif (val & JH71XX_PMU_INT_PCH_FAIL)\n\t\tdev_err(pmu->dev, \"p-channel fail event.\\n\");\n\n\t \n\twritel(val, pmu->base + JH71XX_PMU_INT_STATUS);\n\twritel(val, pmu->base + JH71XX_PMU_EVENT_STATUS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int jh71xx_pmu_init_domain(struct jh71xx_pmu *pmu, int index)\n{\n\tstruct jh71xx_pmu_dev *pmd;\n\tu32 pwr_mask;\n\tint ret;\n\tbool is_on = false;\n\n\tpmd = devm_kzalloc(pmu->dev, sizeof(*pmd), GFP_KERNEL);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\n\tpmd->domain_info = &pmu->match_data->domain_info[index];\n\tpmd->pmu = pmu;\n\tpwr_mask = BIT(pmd->domain_info->bit);\n\n\tpmd->genpd.name = pmd->domain_info->name;\n\tpmd->genpd.flags = pmd->domain_info->flags;\n\n\tret = jh71xx_pmu_get_state(pmd, pwr_mask, &is_on);\n\tif (ret)\n\t\tdev_warn(pmu->dev, \"unable to get current state for %s\\n\",\n\t\t\t pmd->genpd.name);\n\n\tpmd->genpd.power_on = jh71xx_pmu_on;\n\tpmd->genpd.power_off = jh71xx_pmu_off;\n\tpm_genpd_init(&pmd->genpd, NULL, !is_on);\n\n\tpmu->genpd_data.domains[index] = &pmd->genpd;\n\n\treturn 0;\n}\n\nstatic int jh71xx_pmu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct jh71xx_pmu_match_data *match_data;\n\tstruct jh71xx_pmu *pmu;\n\tunsigned int i;\n\tint ret;\n\n\tpmu = devm_kzalloc(dev, sizeof(*pmu), GFP_KERNEL);\n\tif (!pmu)\n\t\treturn -ENOMEM;\n\n\tpmu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pmu->base))\n\t\treturn PTR_ERR(pmu->base);\n\n\tpmu->irq = platform_get_irq(pdev, 0);\n\tif (pmu->irq < 0)\n\t\treturn pmu->irq;\n\n\tret = devm_request_irq(dev, pmu->irq, jh71xx_pmu_interrupt,\n\t\t\t       0, pdev->name, pmu);\n\tif (ret)\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\n\tmatch_data = of_device_get_match_data(dev);\n\tif (!match_data)\n\t\treturn -EINVAL;\n\n\tpmu->genpd = devm_kcalloc(dev, match_data->num_domains,\n\t\t\t\t  sizeof(struct generic_pm_domain *),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pmu->genpd)\n\t\treturn -ENOMEM;\n\n\tpmu->dev = dev;\n\tpmu->match_data = match_data;\n\tpmu->genpd_data.domains = pmu->genpd;\n\tpmu->genpd_data.num_domains = match_data->num_domains;\n\n\tfor (i = 0; i < match_data->num_domains; i++) {\n\t\tret = jh71xx_pmu_init_domain(pmu, i);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to initialize power domain\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tspin_lock_init(&pmu->lock);\n\tjh71xx_pmu_int_enable(pmu, JH71XX_PMU_INT_ALL_MASK & ~JH71XX_PMU_INT_PCH_FAIL, true);\n\n\tret = of_genpd_add_provider_onecell(np, &pmu->genpd_data);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register genpd driver: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"registered %u power domains\\n\", i);\n\n\treturn 0;\n}\n\nstatic const struct jh71xx_domain_info jh7110_power_domains[] = {\n\t[JH7110_PD_SYSTOP] = {\n\t\t.name = \"SYSTOP\",\n\t\t.bit = 0,\n\t\t.flags = GENPD_FLAG_ALWAYS_ON,\n\t},\n\t[JH7110_PD_CPU] = {\n\t\t.name = \"CPU\",\n\t\t.bit = 1,\n\t\t.flags = GENPD_FLAG_ALWAYS_ON,\n\t},\n\t[JH7110_PD_GPUA] = {\n\t\t.name = \"GPUA\",\n\t\t.bit = 2,\n\t},\n\t[JH7110_PD_VDEC] = {\n\t\t.name = \"VDEC\",\n\t\t.bit = 3,\n\t},\n\t[JH7110_PD_VOUT] = {\n\t\t.name = \"VOUT\",\n\t\t.bit = 4,\n\t},\n\t[JH7110_PD_ISP] = {\n\t\t.name = \"ISP\",\n\t\t.bit = 5,\n\t},\n\t[JH7110_PD_VENC] = {\n\t\t.name = \"VENC\",\n\t\t.bit = 6,\n\t},\n};\n\nstatic const struct jh71xx_pmu_match_data jh7110_pmu = {\n\t.num_domains = ARRAY_SIZE(jh7110_power_domains),\n\t.domain_info = jh7110_power_domains,\n};\n\nstatic const struct of_device_id jh71xx_pmu_of_match[] = {\n\t{\n\t\t.compatible = \"starfive,jh7110-pmu\",\n\t\t.data = (void *)&jh7110_pmu,\n\t}, {\n\t\t \n\t}\n};\n\nstatic struct platform_driver jh71xx_pmu_driver = {\n\t.probe = jh71xx_pmu_probe,\n\t.driver = {\n\t\t.name = \"jh71xx-pmu\",\n\t\t.of_match_table = jh71xx_pmu_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(jh71xx_pmu_driver);\n\nMODULE_AUTHOR(\"Walker Chen <walker.chen@starfivetech.com>\");\nMODULE_DESCRIPTION(\"StarFive JH71XX PMU Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}