{
  "module_name": "ti_sci_pm_domains.c",
  "hash_id": "861200bccbe44f6369b358704223d0c6f6477e768c889c7d6dfea8a17c887ae9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/ti/ti_sci_pm_domains.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/slab.h>\n#include <linux/soc/ti/ti_sci_protocol.h>\n#include <dt-bindings/soc/ti,sci_pm_domain.h>\n\n \nstruct ti_sci_genpd_provider {\n\tconst struct ti_sci_handle *ti_sci;\n\tstruct device *dev;\n\tstruct list_head pd_list;\n\tstruct genpd_onecell_data data;\n};\n\n \nstruct ti_sci_pm_domain {\n\tint idx;\n\tu8 exclusive;\n\tstruct generic_pm_domain pd;\n\tstruct list_head node;\n\tstruct ti_sci_genpd_provider *parent;\n};\n\n#define genpd_to_ti_sci_pd(gpd) container_of(gpd, struct ti_sci_pm_domain, pd)\n\n \nstatic int ti_sci_pd_power_off(struct generic_pm_domain *domain)\n{\n\tstruct ti_sci_pm_domain *pd = genpd_to_ti_sci_pd(domain);\n\tconst struct ti_sci_handle *ti_sci = pd->parent->ti_sci;\n\n\treturn ti_sci->ops.dev_ops.put_device(ti_sci, pd->idx);\n}\n\n \nstatic int ti_sci_pd_power_on(struct generic_pm_domain *domain)\n{\n\tstruct ti_sci_pm_domain *pd = genpd_to_ti_sci_pd(domain);\n\tconst struct ti_sci_handle *ti_sci = pd->parent->ti_sci;\n\n\tif (pd->exclusive)\n\t\treturn ti_sci->ops.dev_ops.get_device_exclusive(ti_sci,\n\t\t\t\t\t\t\t\tpd->idx);\n\telse\n\t\treturn ti_sci->ops.dev_ops.get_device(ti_sci, pd->idx);\n}\n\n \nstatic struct generic_pm_domain *ti_sci_pd_xlate(\n\t\t\t\t\tstruct of_phandle_args *genpdspec,\n\t\t\t\t\tvoid *data)\n{\n\tstruct genpd_onecell_data *genpd_data = data;\n\tunsigned int idx = genpdspec->args[0];\n\n\tif (genpdspec->args_count != 1 && genpdspec->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (idx >= genpd_data->num_domains) {\n\t\tpr_err(\"%s: invalid domain index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!genpd_data->domains[idx])\n\t\treturn ERR_PTR(-ENOENT);\n\n\tgenpd_to_ti_sci_pd(genpd_data->domains[idx])->exclusive =\n\t\tgenpdspec->args[1];\n\n\treturn genpd_data->domains[idx];\n}\n\nstatic const struct of_device_id ti_sci_pm_domain_matches[] = {\n\t{ .compatible = \"ti,sci-pm-domain\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ti_sci_pm_domain_matches);\n\nstatic int ti_sci_pm_domain_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ti_sci_genpd_provider *pd_provider;\n\tstruct ti_sci_pm_domain *pd;\n\tstruct device_node *np;\n\tstruct of_phandle_args args;\n\tint ret;\n\tu32 max_id = 0;\n\tint index;\n\n\tpd_provider = devm_kzalloc(dev, sizeof(*pd_provider), GFP_KERNEL);\n\tif (!pd_provider)\n\t\treturn -ENOMEM;\n\n\tpd_provider->ti_sci = devm_ti_sci_get_handle(dev);\n\tif (IS_ERR(pd_provider->ti_sci))\n\t\treturn PTR_ERR(pd_provider->ti_sci);\n\n\tpd_provider->dev = dev;\n\n\tINIT_LIST_HEAD(&pd_provider->pd_list);\n\n\t \n\tfor_each_node_with_property(np, \"power-domains\") {\n\t\tindex = 0;\n\n\t\twhile (1) {\n\t\t\tret = of_parse_phandle_with_args(np, \"power-domains\",\n\t\t\t\t\t\t\t \"#power-domain-cells\",\n\t\t\t\t\t\t\t index, &args);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (args.args_count >= 1 && args.np == dev->of_node) {\n\t\t\t\tif (args.args[0] > max_id)\n\t\t\t\t\tmax_id = args.args[0];\n\n\t\t\t\tpd = devm_kzalloc(dev, sizeof(*pd), GFP_KERNEL);\n\t\t\t\tif (!pd)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tpd->pd.name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t\t     \"pd:%d\",\n\t\t\t\t\t\t\t     args.args[0]);\n\t\t\t\tif (!pd->pd.name)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tpd->pd.power_off = ti_sci_pd_power_off;\n\t\t\t\tpd->pd.power_on = ti_sci_pd_power_on;\n\t\t\t\tpd->idx = args.args[0];\n\t\t\t\tpd->parent = pd_provider;\n\n\t\t\t\tpm_genpd_init(&pd->pd, NULL, true);\n\n\t\t\t\tlist_add(&pd->node, &pd_provider->pd_list);\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t}\n\n\tpd_provider->data.domains =\n\t\tdevm_kcalloc(dev, max_id + 1,\n\t\t\t     sizeof(*pd_provider->data.domains),\n\t\t\t     GFP_KERNEL);\n\tif (!pd_provider->data.domains)\n\t\treturn -ENOMEM;\n\n\tpd_provider->data.num_domains = max_id + 1;\n\tpd_provider->data.xlate = ti_sci_pd_xlate;\n\n\tlist_for_each_entry(pd, &pd_provider->pd_list, node)\n\t\tpd_provider->data.domains[pd->idx] = &pd->pd;\n\n\treturn of_genpd_add_provider_onecell(dev->of_node, &pd_provider->data);\n}\n\nstatic struct platform_driver ti_sci_pm_domains_driver = {\n\t.probe = ti_sci_pm_domain_probe,\n\t.driver = {\n\t\t.name = \"ti_sci_pm_domains\",\n\t\t.of_match_table = ti_sci_pm_domain_matches,\n\t},\n};\nmodule_platform_driver(ti_sci_pm_domains_driver);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI System Control Interface (SCI) Power Domain driver\");\nMODULE_AUTHOR(\"Dave Gerlach\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}