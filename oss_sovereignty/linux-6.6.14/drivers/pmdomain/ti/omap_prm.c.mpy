{
  "module_name": "omap_prm.c",
  "hash_id": "bd6d17b0190560b84e0aab670d00a2371999304282b9eb779219fbdc97780d2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/ti/omap_prm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_domain.h>\n#include <linux/reset-controller.h>\n#include <linux/delay.h>\n\n#include <linux/platform_data/ti-prm.h>\n\nenum omap_prm_domain_mode {\n\tOMAP_PRMD_OFF,\n\tOMAP_PRMD_RETENTION,\n\tOMAP_PRMD_ON_INACTIVE,\n\tOMAP_PRMD_ON_ACTIVE,\n};\n\nstruct omap_prm_domain_map {\n\tunsigned int usable_modes;\t \n\tunsigned long statechange:1;\t \n\tunsigned long logicretstate:1;\t \n};\n\nstruct omap_prm_domain {\n\tstruct device *dev;\n\tstruct omap_prm *prm;\n\tstruct generic_pm_domain pd;\n\tu16 pwrstctrl;\n\tu16 pwrstst;\n\tconst struct omap_prm_domain_map *cap;\n\tu32 pwrstctrl_saved;\n\tunsigned int uses_pm_clk:1;\n};\n\nstruct omap_rst_map {\n\ts8 rst;\n\ts8 st;\n};\n\nstruct omap_prm_data {\n\tu32 base;\n\tconst char *name;\n\tconst char *clkdm_name;\n\tu16 pwrstctrl;\n\tu16 pwrstst;\n\tconst struct omap_prm_domain_map *dmap;\n\tu16 rstctrl;\n\tu16 rstst;\n\tconst struct omap_rst_map *rstmap;\n\tu8 flags;\n};\n\nstruct omap_prm {\n\tconst struct omap_prm_data *data;\n\tvoid __iomem *base;\n\tstruct omap_prm_domain *prmd;\n};\n\nstruct omap_reset_data {\n\tstruct reset_controller_dev rcdev;\n\tstruct omap_prm *prm;\n\tu32 mask;\n\tspinlock_t lock;\n\tstruct clockdomain *clkdm;\n\tstruct device *dev;\n};\n\n#define genpd_to_prm_domain(gpd) container_of(gpd, struct omap_prm_domain, pd)\n#define to_omap_reset_data(p) container_of((p), struct omap_reset_data, rcdev)\n\n#define OMAP_MAX_RESETS\t\t8\n#define OMAP_RESET_MAX_WAIT\t10000\n\n#define OMAP_PRM_HAS_RSTCTRL\tBIT(0)\n#define OMAP_PRM_HAS_RSTST\tBIT(1)\n#define OMAP_PRM_HAS_NO_CLKDM\tBIT(2)\n#define OMAP_PRM_RET_WHEN_IDLE\tBIT(3)\n\n#define OMAP_PRM_HAS_RESETS\t(OMAP_PRM_HAS_RSTCTRL | OMAP_PRM_HAS_RSTST)\n\n#define PRM_STATE_MAX_WAIT\t10000\n#define PRM_LOGICRETSTATE\tBIT(2)\n#define PRM_LOWPOWERSTATECHANGE\tBIT(4)\n#define PRM_POWERSTATE_MASK\tOMAP_PRMD_ON_ACTIVE\n\n#define PRM_ST_INTRANSITION\tBIT(20)\n\nstatic const struct omap_prm_domain_map omap_prm_all = {\n\t.usable_modes = BIT(OMAP_PRMD_ON_ACTIVE) | BIT(OMAP_PRMD_ON_INACTIVE) |\n\t\t\tBIT(OMAP_PRMD_RETENTION) | BIT(OMAP_PRMD_OFF),\n\t.statechange = 1,\n\t.logicretstate = 1,\n};\n\nstatic const struct omap_prm_domain_map omap_prm_noinact = {\n\t.usable_modes = BIT(OMAP_PRMD_ON_ACTIVE) | BIT(OMAP_PRMD_RETENTION) |\n\t\t\tBIT(OMAP_PRMD_OFF),\n\t.statechange = 1,\n\t.logicretstate = 1,\n};\n\nstatic const struct omap_prm_domain_map omap_prm_nooff = {\n\t.usable_modes = BIT(OMAP_PRMD_ON_ACTIVE) | BIT(OMAP_PRMD_ON_INACTIVE) |\n\t\t\tBIT(OMAP_PRMD_RETENTION),\n\t.statechange = 1,\n\t.logicretstate = 1,\n};\n\nstatic const struct omap_prm_domain_map omap_prm_onoff_noauto = {\n\t.usable_modes = BIT(OMAP_PRMD_ON_ACTIVE) | BIT(OMAP_PRMD_OFF),\n\t.statechange = 1,\n};\n\nstatic const struct omap_prm_domain_map omap_prm_alwon = {\n\t.usable_modes = BIT(OMAP_PRMD_ON_ACTIVE),\n};\n\nstatic const struct omap_prm_domain_map omap_prm_reton = {\n\t.usable_modes = BIT(OMAP_PRMD_ON_ACTIVE) | BIT(OMAP_PRMD_RETENTION),\n\t.statechange = 1,\n\t.logicretstate = 1,\n};\n\nstatic const struct omap_rst_map rst_map_0[] = {\n\t{ .rst = 0, .st = 0 },\n\t{ .rst = -1 },\n};\n\nstatic const struct omap_rst_map rst_map_01[] = {\n\t{ .rst = 0, .st = 0 },\n\t{ .rst = 1, .st = 1 },\n\t{ .rst = -1 },\n};\n\nstatic const struct omap_rst_map rst_map_012[] = {\n\t{ .rst = 0, .st = 0 },\n\t{ .rst = 1, .st = 1 },\n\t{ .rst = 2, .st = 2 },\n\t{ .rst = -1 },\n};\n\nstatic const struct omap_prm_data omap4_prm_data[] = {\n\t{\n\t\t.name = \"mpu\", .base = 0x4a306300,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_reton,\n\t},\n\t{\n\t\t.name = \"tesla\", .base = 0x4a306400,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_noinact,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_01\n\t},\n\t{\n\t\t.name = \"abe\", .base = 0x4a306500,\n\t\t.pwrstctrl = 0, .pwrstst = 0x4, .dmap = &omap_prm_all,\n\t},\n\t{\n\t\t.name = \"always_on_core\", .base = 0x4a306600,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon,\n\t},\n\t{\n\t\t.name = \"core\", .base = 0x4a306700,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_reton,\n\t\t.rstctrl = 0x210, .rstst = 0x214, .clkdm_name = \"ducati\",\n\t\t.rstmap = rst_map_012,\n\t\t.flags = OMAP_PRM_RET_WHEN_IDLE,\n\t},\n\t{\n\t\t.name = \"ivahd\", .base = 0x4a306f00,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_noinact,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_012\n\t},\n\t{\n\t\t.name = \"cam\", .base = 0x4a307000,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t},\n\t{\n\t\t.name = \"dss\", .base = 0x4a307100,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_noinact\n\t},\n\t{\n\t\t.name = \"gfx\", .base = 0x4a307200,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto\n\t},\n\t{\n\t\t.name = \"l3init\", .base = 0x4a307300,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_reton\n\t},\n\t{\n\t\t.name = \"l4per\", .base = 0x4a307400,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_reton,\n\t\t.flags = OMAP_PRM_RET_WHEN_IDLE,\n\t},\n\t{\n\t\t.name = \"cefuse\", .base = 0x4a307600,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto\n\t},\n\t{\n\t\t.name = \"wkup\", .base = 0x4a307700,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon\n\t},\n\t{\n\t\t.name = \"emu\", .base = 0x4a307900,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto\n\t},\n\t{\n\t\t.name = \"device\", .base = 0x4a307b00,\n\t\t.rstctrl = 0x0, .rstst = 0x4, .rstmap = rst_map_01,\n\t\t.flags = OMAP_PRM_HAS_RSTCTRL | OMAP_PRM_HAS_NO_CLKDM\n\t},\n\t{ },\n};\n\nstatic const struct omap_prm_data omap5_prm_data[] = {\n\t{\n\t\t.name = \"mpu\", .base = 0x4ae06300,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_reton,\n\t},\n\t{\n\t\t.name = \"dsp\", .base = 0x4ae06400,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_noinact,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_01\n\t},\n\t{\n\t\t.name = \"abe\", .base = 0x4ae06500,\n\t\t.pwrstctrl = 0, .pwrstst = 0x4, .dmap = &omap_prm_nooff,\n\t},\n\t{\n\t\t.name = \"coreaon\", .base = 0x4ae06600,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon\n\t},\n\t{\n\t\t.name = \"core\", .base = 0x4ae06700,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_reton,\n\t\t.rstctrl = 0x210, .rstst = 0x214, .clkdm_name = \"ipu\",\n\t\t.rstmap = rst_map_012\n\t},\n\t{\n\t\t.name = \"iva\", .base = 0x4ae07200,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_noinact,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_012\n\t},\n\t{\n\t\t.name = \"cam\", .base = 0x4ae07300,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto\n\t},\n\t{\n\t\t.name = \"dss\", .base = 0x4ae07400,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_noinact\n\t},\n\t{\n\t\t.name = \"gpu\", .base = 0x4ae07500,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto\n\t},\n\t{\n\t\t.name = \"l3init\", .base = 0x4ae07600,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_reton\n\t},\n\t{\n\t\t.name = \"custefuse\", .base = 0x4ae07700,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto\n\t},\n\t{\n\t\t.name = \"wkupaon\", .base = 0x4ae07800,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon\n\t},\n\t{\n\t\t.name = \"emu\", .base = 0x4ae07a00,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto\n\t},\n\t{\n\t\t.name = \"device\", .base = 0x4ae07c00,\n\t\t.rstctrl = 0x0, .rstst = 0x4, .rstmap = rst_map_01,\n\t\t.flags = OMAP_PRM_HAS_RSTCTRL | OMAP_PRM_HAS_NO_CLKDM\n\t},\n\t{ },\n};\n\nstatic const struct omap_prm_data dra7_prm_data[] = {\n\t{\n\t\t.name = \"mpu\", .base = 0x4ae06300,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_reton,\n\t},\n\t{\n\t\t.name = \"dsp1\", .base = 0x4ae06400,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_01,\n\t},\n\t{\n\t\t.name = \"ipu\", .base = 0x4ae06500,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_012,\n\t\t.clkdm_name = \"ipu1\"\n\t},\n\t{\n\t\t.name = \"coreaon\", .base = 0x4ae06628,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon,\n\t},\n\t{\n\t\t.name = \"core\", .base = 0x4ae06700,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon,\n\t\t.rstctrl = 0x210, .rstst = 0x214, .rstmap = rst_map_012,\n\t\t.clkdm_name = \"ipu2\"\n\t},\n\t{\n\t\t.name = \"iva\", .base = 0x4ae06f00,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_012,\n\t},\n\t{\n\t\t.name = \"cam\", .base = 0x4ae07000,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t},\n\t{\n\t\t.name = \"dss\", .base = 0x4ae07100,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t},\n\t{\n\t\t.name = \"gpu\", .base = 0x4ae07200,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t},\n\t{\n\t\t.name = \"l3init\", .base = 0x4ae07300,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_01,\n\t\t.clkdm_name = \"pcie\"\n\t},\n\t{\n\t\t.name = \"l4per\", .base = 0x4ae07400,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon,\n\t},\n\t{\n\t\t.name = \"custefuse\", .base = 0x4ae07600,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t},\n\t{\n\t\t.name = \"wkupaon\", .base = 0x4ae07724,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon,\n\t},\n\t{\n\t\t.name = \"emu\", .base = 0x4ae07900,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t},\n\t{\n\t\t.name = \"dsp2\", .base = 0x4ae07b00,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_01\n\t},\n\t{\n\t\t.name = \"eve1\", .base = 0x4ae07b40,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_01\n\t},\n\t{\n\t\t.name = \"eve2\", .base = 0x4ae07b80,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_01\n\t},\n\t{\n\t\t.name = \"eve3\", .base = 0x4ae07bc0,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_01\n\t},\n\t{\n\t\t.name = \"eve4\", .base = 0x4ae07c00,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_01\n\t},\n\t{\n\t\t.name = \"rtc\", .base = 0x4ae07c60,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon,\n\t},\n\t{\n\t\t.name = \"vpe\", .base = 0x4ae07c80,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t},\n\t{ },\n};\n\nstatic const struct omap_rst_map am3_per_rst_map[] = {\n\t{ .rst = 1 },\n\t{ .rst = -1 },\n};\n\nstatic const struct omap_rst_map am3_wkup_rst_map[] = {\n\t{ .rst = 3, .st = 5 },\n\t{ .rst = -1 },\n};\n\nstatic const struct omap_prm_data am3_prm_data[] = {\n\t{\n\t\t.name = \"per\", .base = 0x44e00c00,\n\t\t.pwrstctrl = 0xc, .pwrstst = 0x8, .dmap = &omap_prm_noinact,\n\t\t.rstctrl = 0x0, .rstmap = am3_per_rst_map,\n\t\t.flags = OMAP_PRM_HAS_RSTCTRL, .clkdm_name = \"pruss_ocp\"\n\t},\n\t{\n\t\t.name = \"wkup\", .base = 0x44e00d00,\n\t\t.pwrstctrl = 0x4, .pwrstst = 0x4, .dmap = &omap_prm_alwon,\n\t\t.rstctrl = 0x0, .rstst = 0xc, .rstmap = am3_wkup_rst_map,\n\t\t.flags = OMAP_PRM_HAS_RSTCTRL | OMAP_PRM_HAS_NO_CLKDM\n\t},\n\t{\n\t\t.name = \"mpu\", .base = 0x44e00e00,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_noinact,\n\t},\n\t{\n\t\t.name = \"device\", .base = 0x44e00f00,\n\t\t.rstctrl = 0x0, .rstst = 0x8, .rstmap = rst_map_01,\n\t\t.flags = OMAP_PRM_HAS_RSTCTRL | OMAP_PRM_HAS_NO_CLKDM\n\t},\n\t{\n\t\t.name = \"rtc\", .base = 0x44e01000,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon,\n\t},\n\t{\n\t\t.name = \"gfx\", .base = 0x44e01100,\n\t\t.pwrstctrl = 0, .pwrstst = 0x10, .dmap = &omap_prm_noinact,\n\t\t.rstctrl = 0x4, .rstst = 0x14, .rstmap = rst_map_0, .clkdm_name = \"gfx_l3\",\n\t},\n\t{\n\t\t.name = \"cefuse\", .base = 0x44e01200,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t},\n\t{ },\n};\n\nstatic const struct omap_rst_map am4_per_rst_map[] = {\n\t{ .rst = 1, .st = 0 },\n\t{ .rst = -1 },\n};\n\nstatic const struct omap_rst_map am4_device_rst_map[] = {\n\t{ .rst = 0, .st = 1 },\n\t{ .rst = 1, .st = 0 },\n\t{ .rst = -1 },\n};\n\nstatic const struct omap_prm_data am4_prm_data[] = {\n\t{\n\t\t.name = \"mpu\", .base = 0x44df0300,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_noinact,\n\t},\n\t{\n\t\t.name = \"gfx\", .base = 0x44df0400,\n\t\t.pwrstctrl = 0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = rst_map_0, .clkdm_name = \"gfx_l3\",\n\t},\n\t{\n\t\t.name = \"rtc\", .base = 0x44df0500,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon,\n\t},\n\t{\n\t\t.name = \"tamper\", .base = 0x44df0600,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon,\n\t},\n\t{\n\t\t.name = \"cefuse\", .base = 0x44df0700,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_onoff_noauto,\n\t},\n\t{\n\t\t.name = \"per\", .base = 0x44df0800,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_noinact,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = am4_per_rst_map,\n\t\t.clkdm_name = \"pruss_ocp\"\n\t},\n\t{\n\t\t.name = \"wkup\", .base = 0x44df2000,\n\t\t.pwrstctrl = 0x0, .pwrstst = 0x4, .dmap = &omap_prm_alwon,\n\t\t.rstctrl = 0x10, .rstst = 0x14, .rstmap = am3_wkup_rst_map,\n\t\t.flags = OMAP_PRM_HAS_NO_CLKDM\n\t},\n\t{\n\t\t.name = \"device\", .base = 0x44df4000,\n\t\t.rstctrl = 0x0, .rstst = 0x4, .rstmap = am4_device_rst_map,\n\t\t.flags = OMAP_PRM_HAS_RSTCTRL | OMAP_PRM_HAS_NO_CLKDM\n\t},\n\t{ },\n};\n\nstatic const struct of_device_id omap_prm_id_table[] = {\n\t{ .compatible = \"ti,omap4-prm-inst\", .data = omap4_prm_data },\n\t{ .compatible = \"ti,omap5-prm-inst\", .data = omap5_prm_data },\n\t{ .compatible = \"ti,dra7-prm-inst\", .data = dra7_prm_data },\n\t{ .compatible = \"ti,am3-prm-inst\", .data = am3_prm_data },\n\t{ .compatible = \"ti,am4-prm-inst\", .data = am4_prm_data },\n\t{ },\n};\n\n#ifdef DEBUG\nstatic void omap_prm_domain_show_state(struct omap_prm_domain *prmd,\n\t\t\t\t       const char *desc)\n{\n\tdev_dbg(prmd->dev, \"%s %s: %08x/%08x\\n\",\n\t\tprmd->pd.name, desc,\n\t\treadl_relaxed(prmd->prm->base + prmd->pwrstctrl),\n\t\treadl_relaxed(prmd->prm->base + prmd->pwrstst));\n}\n#else\nstatic inline void omap_prm_domain_show_state(struct omap_prm_domain *prmd,\n\t\t\t\t\t      const char *desc)\n{\n}\n#endif\n\nstatic int omap_prm_domain_power_on(struct generic_pm_domain *domain)\n{\n\tstruct omap_prm_domain *prmd;\n\tint ret;\n\tu32 v, mode;\n\n\tprmd = genpd_to_prm_domain(domain);\n\tif (!prmd->cap)\n\t\treturn 0;\n\n\tomap_prm_domain_show_state(prmd, \"on: previous state\");\n\n\tif (prmd->pwrstctrl_saved)\n\t\tv = prmd->pwrstctrl_saved;\n\telse\n\t\tv = readl_relaxed(prmd->prm->base + prmd->pwrstctrl);\n\n\tif (prmd->prm->data->flags & OMAP_PRM_RET_WHEN_IDLE)\n\t\tmode = OMAP_PRMD_RETENTION;\n\telse\n\t\tmode = OMAP_PRMD_ON_ACTIVE;\n\n\twritel_relaxed((v & ~PRM_POWERSTATE_MASK) | mode,\n\t\t       prmd->prm->base + prmd->pwrstctrl);\n\n\t \n\tret = readl_relaxed_poll_timeout(prmd->prm->base + prmd->pwrstst,\n\t\t\t\t\t v, !(v & PRM_ST_INTRANSITION), 1,\n\t\t\t\t\t PRM_STATE_MAX_WAIT);\n\tif (ret)\n\t\tdev_err(prmd->dev, \"%s: %s timed out\\n\",\n\t\t\tprmd->pd.name, __func__);\n\n\tomap_prm_domain_show_state(prmd, \"on: new state\");\n\n\treturn ret;\n}\n\n \nstatic int omap_prm_domain_find_lowest(struct omap_prm_domain *prmd)\n{\n\treturn __ffs(prmd->cap->usable_modes);\n}\n\nstatic int omap_prm_domain_power_off(struct generic_pm_domain *domain)\n{\n\tstruct omap_prm_domain *prmd;\n\tint ret;\n\tu32 v;\n\n\tprmd = genpd_to_prm_domain(domain);\n\tif (!prmd->cap)\n\t\treturn 0;\n\n\tomap_prm_domain_show_state(prmd, \"off: previous state\");\n\n\tv = readl_relaxed(prmd->prm->base + prmd->pwrstctrl);\n\tprmd->pwrstctrl_saved = v;\n\n\tv &= ~PRM_POWERSTATE_MASK;\n\tv |= omap_prm_domain_find_lowest(prmd);\n\n\tif (prmd->cap->statechange)\n\t\tv |= PRM_LOWPOWERSTATECHANGE;\n\tif (prmd->cap->logicretstate)\n\t\tv &= ~PRM_LOGICRETSTATE;\n\telse\n\t\tv |= PRM_LOGICRETSTATE;\n\n\twritel_relaxed(v, prmd->prm->base + prmd->pwrstctrl);\n\n\t \n\tret = readl_relaxed_poll_timeout(prmd->prm->base + prmd->pwrstst,\n\t\t\t\t\t v, !(v & PRM_ST_INTRANSITION), 1,\n\t\t\t\t\t PRM_STATE_MAX_WAIT);\n\tif (ret)\n\t\tdev_warn(prmd->dev, \"%s: %s timed out\\n\",\n\t\t\t __func__, prmd->pd.name);\n\n\tomap_prm_domain_show_state(prmd, \"off: new state\");\n\n\treturn 0;\n}\n\n \nstatic int omap_prm_domain_attach_clock(struct device *dev,\n\t\t\t\t\tstruct omap_prm_domain *prmd)\n{\n\tstruct device_node *np = dev->of_node;\n\tint error;\n\n\tif (!of_device_is_compatible(np, \"simple-pm-bus\"))\n\t\treturn 0;\n\n\tif (!of_property_read_bool(np, \"clocks\"))\n\t\treturn 0;\n\n\terror = pm_clk_create(dev);\n\tif (error)\n\t\treturn error;\n\n\terror = of_pm_clk_add_clks(dev);\n\tif (error < 0) {\n\t\tpm_clk_destroy(dev);\n\t\treturn error;\n\t}\n\n\tprmd->uses_pm_clk = 1;\n\n\treturn 0;\n}\n\nstatic int omap_prm_domain_attach_dev(struct generic_pm_domain *domain,\n\t\t\t\t      struct device *dev)\n{\n\tstruct generic_pm_domain_data *genpd_data;\n\tstruct of_phandle_args pd_args;\n\tstruct omap_prm_domain *prmd;\n\tstruct device_node *np;\n\tint ret;\n\n\tprmd = genpd_to_prm_domain(domain);\n\tnp = dev->of_node;\n\n\tret = of_parse_phandle_with_args(np, \"power-domains\",\n\t\t\t\t\t \"#power-domain-cells\", 0, &pd_args);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pd_args.args_count != 0)\n\t\tdev_warn(dev, \"%s: unusupported #power-domain-cells: %i\\n\",\n\t\t\t prmd->pd.name, pd_args.args_count);\n\n\tgenpd_data = dev_gpd_data(dev);\n\tgenpd_data->data = NULL;\n\n\tret = omap_prm_domain_attach_clock(dev, prmd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void omap_prm_domain_detach_dev(struct generic_pm_domain *domain,\n\t\t\t\t       struct device *dev)\n{\n\tstruct generic_pm_domain_data *genpd_data;\n\tstruct omap_prm_domain *prmd;\n\n\tprmd = genpd_to_prm_domain(domain);\n\tif (prmd->uses_pm_clk)\n\t\tpm_clk_destroy(dev);\n\tgenpd_data = dev_gpd_data(dev);\n\tgenpd_data->data = NULL;\n}\n\nstatic int omap_prm_domain_init(struct device *dev, struct omap_prm *prm)\n{\n\tstruct omap_prm_domain *prmd;\n\tstruct device_node *np = dev->of_node;\n\tconst struct omap_prm_data *data;\n\tconst char *name;\n\tint error;\n\n\tif (!of_property_present(dev->of_node, \"#power-domain-cells\"))\n\t\treturn 0;\n\n\tof_node_put(dev->of_node);\n\n\tprmd = devm_kzalloc(dev, sizeof(*prmd), GFP_KERNEL);\n\tif (!prmd)\n\t\treturn -ENOMEM;\n\n\tdata = prm->data;\n\tname = devm_kasprintf(dev, GFP_KERNEL, \"prm_%s\",\n\t\t\t      data->name);\n\n\tprmd->dev = dev;\n\tprmd->prm = prm;\n\tprmd->cap = prmd->prm->data->dmap;\n\tprmd->pwrstctrl = prmd->prm->data->pwrstctrl;\n\tprmd->pwrstst = prmd->prm->data->pwrstst;\n\n\tprmd->pd.name = name;\n\tprmd->pd.power_on = omap_prm_domain_power_on;\n\tprmd->pd.power_off = omap_prm_domain_power_off;\n\tprmd->pd.attach_dev = omap_prm_domain_attach_dev;\n\tprmd->pd.detach_dev = omap_prm_domain_detach_dev;\n\tprmd->pd.flags = GENPD_FLAG_PM_CLK;\n\n\tpm_genpd_init(&prmd->pd, NULL, true);\n\terror = of_genpd_add_provider_simple(np, &prmd->pd);\n\tif (error)\n\t\tpm_genpd_remove(&prmd->pd);\n\telse\n\t\tprm->prmd = prmd;\n\n\treturn error;\n}\n\nstatic bool _is_valid_reset(struct omap_reset_data *reset, unsigned long id)\n{\n\tif (reset->mask & BIT(id))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int omap_reset_get_st_bit(struct omap_reset_data *reset,\n\t\t\t\t unsigned long id)\n{\n\tconst struct omap_rst_map *map = reset->prm->data->rstmap;\n\n\twhile (map->rst >= 0) {\n\t\tif (map->rst == id)\n\t\t\treturn map->st;\n\n\t\tmap++;\n\t}\n\n\treturn id;\n}\n\nstatic int omap_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\tstruct omap_reset_data *reset = to_omap_reset_data(rcdev);\n\tu32 v;\n\tint st_bit = omap_reset_get_st_bit(reset, id);\n\tbool has_rstst = reset->prm->data->rstst ||\n\t\t(reset->prm->data->flags & OMAP_PRM_HAS_RSTST);\n\n\t \n\tif (!has_rstst)\n\t\treturn -ENOTSUPP;\n\n\t \n\tv = readl_relaxed(reset->prm->base + reset->prm->data->rstctrl);\n\tif (v & BIT(id))\n\t\treturn 1;\n\n\t \n\tv = readl_relaxed(reset->prm->base + reset->prm->data->rstst);\n\tv >>= st_bit;\n\tv &= 1;\n\n\treturn !v;\n}\n\nstatic int omap_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\tstruct omap_reset_data *reset = to_omap_reset_data(rcdev);\n\tu32 v;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&reset->lock, flags);\n\tv = readl_relaxed(reset->prm->base + reset->prm->data->rstctrl);\n\tv |= 1 << id;\n\twritel_relaxed(v, reset->prm->base + reset->prm->data->rstctrl);\n\tspin_unlock_irqrestore(&reset->lock, flags);\n\n\treturn 0;\n}\n\nstatic int omap_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct omap_reset_data *reset = to_omap_reset_data(rcdev);\n\tu32 v;\n\tint st_bit;\n\tbool has_rstst;\n\tunsigned long flags;\n\tstruct ti_prm_platform_data *pdata = dev_get_platdata(reset->dev);\n\tint ret = 0;\n\n\t \n\tif (!omap_reset_status(rcdev, id))\n\t\treturn 0;\n\n\thas_rstst = reset->prm->data->rstst ||\n\t\t(reset->prm->data->flags & OMAP_PRM_HAS_RSTST);\n\n\tif (has_rstst) {\n\t\tst_bit = omap_reset_get_st_bit(reset, id);\n\n\t\t \n\t\tv = 1 << st_bit;\n\t\twritel_relaxed(v, reset->prm->base + reset->prm->data->rstst);\n\t}\n\n\tif (reset->clkdm)\n\t\tpdata->clkdm_deny_idle(reset->clkdm);\n\n\t \n\tspin_lock_irqsave(&reset->lock, flags);\n\tv = readl_relaxed(reset->prm->base + reset->prm->data->rstctrl);\n\tv &= ~(1 << id);\n\twritel_relaxed(v, reset->prm->base + reset->prm->data->rstctrl);\n\tspin_unlock_irqrestore(&reset->lock, flags);\n\n\t \n\tret = readl_relaxed_poll_timeout_atomic(reset->prm->base +\n\t\t\t\t\t\treset->prm->data->rstctrl,\n\t\t\t\t\t\tv, !(v & BIT(id)), 1,\n\t\t\t\t\t\tOMAP_RESET_MAX_WAIT);\n\tif (ret)\n\t\tpr_err(\"%s: timedout waiting for %s:%lu\\n\", __func__,\n\t\t       reset->prm->data->name, id);\n\n\t \n\tif (has_rstst) {\n\t\tret = readl_relaxed_poll_timeout_atomic(reset->prm->base +\n\t\t\t\t\t\t reset->prm->data->rstst,\n\t\t\t\t\t\t v, v & BIT(st_bit), 1,\n\t\t\t\t\t\t OMAP_RESET_MAX_WAIT);\n\t\tif (ret)\n\t\t\tpr_err(\"%s: timedout waiting for %s:%lu\\n\", __func__,\n\t\t\t       reset->prm->data->name, id);\n\t}\n\n\tif (reset->clkdm)\n\t\tpdata->clkdm_allow_idle(reset->clkdm);\n\n\treturn ret;\n}\n\nstatic const struct reset_control_ops omap_reset_ops = {\n\t.assert\t\t= omap_reset_assert,\n\t.deassert\t= omap_reset_deassert,\n\t.status\t\t= omap_reset_status,\n};\n\nstatic int omap_prm_reset_xlate(struct reset_controller_dev *rcdev,\n\t\t\t\tconst struct of_phandle_args *reset_spec)\n{\n\tstruct omap_reset_data *reset = to_omap_reset_data(rcdev);\n\n\tif (!_is_valid_reset(reset, reset_spec->args[0]))\n\t\treturn -EINVAL;\n\n\treturn reset_spec->args[0];\n}\n\nstatic int omap_prm_reset_init(struct platform_device *pdev,\n\t\t\t       struct omap_prm *prm)\n{\n\tstruct omap_reset_data *reset;\n\tconst struct omap_rst_map *map;\n\tstruct ti_prm_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tchar buf[32];\n\tu32 v;\n\n\t \n\tif (!prm->data->rstctrl && !(prm->data->flags & OMAP_PRM_HAS_RSTCTRL))\n\t\treturn 0;\n\n\t \n\tif (!pdata || !pdata->clkdm_lookup || !pdata->clkdm_deny_idle ||\n\t    !pdata->clkdm_allow_idle)\n\t\treturn -EINVAL;\n\n\tmap = prm->data->rstmap;\n\tif (!map)\n\t\treturn -EINVAL;\n\n\treset = devm_kzalloc(&pdev->dev, sizeof(*reset), GFP_KERNEL);\n\tif (!reset)\n\t\treturn -ENOMEM;\n\n\treset->rcdev.owner = THIS_MODULE;\n\treset->rcdev.ops = &omap_reset_ops;\n\treset->rcdev.of_node = pdev->dev.of_node;\n\treset->rcdev.nr_resets = OMAP_MAX_RESETS;\n\treset->rcdev.of_xlate = omap_prm_reset_xlate;\n\treset->rcdev.of_reset_n_cells = 1;\n\treset->dev = &pdev->dev;\n\tspin_lock_init(&reset->lock);\n\n\treset->prm = prm;\n\n\tsprintf(buf, \"%s_clkdm\", prm->data->clkdm_name ? prm->data->clkdm_name :\n\t\tprm->data->name);\n\n\tif (!(prm->data->flags & OMAP_PRM_HAS_NO_CLKDM)) {\n\t\treset->clkdm = pdata->clkdm_lookup(buf);\n\t\tif (!reset->clkdm)\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (map->rst >= 0) {\n\t\treset->mask |= BIT(map->rst);\n\t\tmap++;\n\t}\n\n\t \n\tif (prm->data->rstmap == rst_map_012) {\n\t\tv = readl_relaxed(reset->prm->base + reset->prm->data->rstctrl);\n\t\tif ((v & reset->mask) != reset->mask) {\n\t\t\tdev_dbg(&pdev->dev, \"Asserting all resets: %08x\\n\", v);\n\t\t\twritel_relaxed(reset->mask, reset->prm->base +\n\t\t\t\t       reset->prm->data->rstctrl);\n\t\t}\n\t}\n\n\treturn devm_reset_controller_register(&pdev->dev, &reset->rcdev);\n}\n\nstatic int omap_prm_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tconst struct omap_prm_data *data;\n\tstruct omap_prm *prm;\n\tint ret;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data)\n\t\treturn -ENOTSUPP;\n\n\tprm = devm_kzalloc(&pdev->dev, sizeof(*prm), GFP_KERNEL);\n\tif (!prm)\n\t\treturn -ENOMEM;\n\n\tprm->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(prm->base))\n\t\treturn PTR_ERR(prm->base);\n\n\twhile (data->base != res->start) {\n\t\tif (!data->base)\n\t\t\treturn -EINVAL;\n\t\tdata++;\n\t}\n\n\tprm->data = data;\n\n\tret = omap_prm_domain_init(&pdev->dev, prm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = omap_prm_reset_init(pdev, prm);\n\tif (ret)\n\t\tgoto err_domain;\n\n\treturn 0;\n\nerr_domain:\n\tof_genpd_del_provider(pdev->dev.of_node);\n\tpm_genpd_remove(&prm->prmd->pd);\n\n\treturn ret;\n}\n\nstatic struct platform_driver omap_prm_driver = {\n\t.probe = omap_prm_probe,\n\t.driver = {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= omap_prm_id_table,\n\t},\n};\nbuiltin_platform_driver(omap_prm_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}