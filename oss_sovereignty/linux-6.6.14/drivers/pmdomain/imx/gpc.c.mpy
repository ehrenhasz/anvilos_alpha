{
  "module_name": "gpc.c",
  "hash_id": "50b2ab2b8c0a086f9e722b28130de1d08e40bd0a1d8cbc64ba91d466570bb0ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/imx/gpc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#define GPC_CNTR\t\t0x000\n\n#define GPC_PGC_CTRL_OFFS\t0x0\n#define GPC_PGC_PUPSCR_OFFS\t0x4\n#define GPC_PGC_PDNSCR_OFFS\t0x8\n#define GPC_PGC_SW2ISO_SHIFT\t0x8\n#define GPC_PGC_SW_SHIFT\t0x0\n\n#define GPC_PGC_PCI_PDN\t\t0x200\n#define GPC_PGC_PCI_SR\t\t0x20c\n\n#define GPC_PGC_GPU_PDN\t\t0x260\n#define GPC_PGC_GPU_PUPSCR\t0x264\n#define GPC_PGC_GPU_PDNSCR\t0x268\n#define GPC_PGC_GPU_SR\t\t0x26c\n\n#define GPC_PGC_DISP_PDN\t0x240\n#define GPC_PGC_DISP_SR\t\t0x24c\n\n#define GPU_VPU_PUP_REQ\t\tBIT(1)\n#define GPU_VPU_PDN_REQ\t\tBIT(0)\n\n#define GPC_CLK_MAX\t\t7\n\n#define PGC_DOMAIN_FLAG_NO_PD\t\tBIT(0)\n\nstruct imx_pm_domain {\n\tstruct generic_pm_domain base;\n\tstruct regmap *regmap;\n\tstruct regulator *supply;\n\tstruct clk *clk[GPC_CLK_MAX];\n\tint num_clks;\n\tunsigned int reg_offs;\n\tsigned char cntr_pdn_bit;\n\tunsigned int ipg_rate_mhz;\n};\n\nstatic inline struct imx_pm_domain *\nto_imx_pm_domain(struct generic_pm_domain *genpd)\n{\n\treturn container_of(genpd, struct imx_pm_domain, base);\n}\n\nstatic int imx6_pm_domain_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct imx_pm_domain *pd = to_imx_pm_domain(genpd);\n\tint iso, iso2sw;\n\tu32 val;\n\n\t \n\tregmap_read(pd->regmap, pd->reg_offs + GPC_PGC_PDNSCR_OFFS, &val);\n\tiso = val & 0x3f;\n\tiso2sw = (val >> 8) & 0x3f;\n\n\t \n\tregmap_update_bits(pd->regmap, pd->reg_offs + GPC_PGC_CTRL_OFFS,\n\t\t\t   0x1, 0x1);\n\n\t \n\tval = BIT(pd->cntr_pdn_bit);\n\tregmap_update_bits(pd->regmap, GPC_CNTR, val, val);\n\n\t \n\tudelay(DIV_ROUND_UP(iso + iso2sw, pd->ipg_rate_mhz));\n\n\tif (pd->supply)\n\t\tregulator_disable(pd->supply);\n\n\treturn 0;\n}\n\nstatic int imx6_pm_domain_power_on(struct generic_pm_domain *genpd)\n{\n\tstruct imx_pm_domain *pd = to_imx_pm_domain(genpd);\n\tint i, ret;\n\tu32 val, req;\n\n\tif (pd->supply) {\n\t\tret = regulator_enable(pd->supply);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: failed to enable regulator: %d\\n\",\n\t\t\t       __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < pd->num_clks; i++)\n\t\tclk_prepare_enable(pd->clk[i]);\n\n\t \n\tregmap_update_bits(pd->regmap, pd->reg_offs + GPC_PGC_CTRL_OFFS,\n\t\t\t   0x1, 0x1);\n\n\t \n\treq = BIT(pd->cntr_pdn_bit + 1);\n\tregmap_update_bits(pd->regmap, GPC_CNTR, req, req);\n\n\t \n\tret = regmap_read_poll_timeout(pd->regmap, GPC_CNTR, val, !(val & req),\n\t\t\t\t       1, 50);\n\tif (ret)\n\t\tpr_err(\"powerup request on domain %s timed out\\n\", genpd->name);\n\n\t \n\tusleep_range(5, 10);\n\n\t \n\tfor (i = 0; i < pd->num_clks; i++)\n\t\tclk_disable_unprepare(pd->clk[i]);\n\n\treturn 0;\n}\n\nstatic int imx_pgc_get_clocks(struct device *dev, struct imx_pm_domain *domain)\n{\n\tint i, ret;\n\n\tfor (i = 0; ; i++) {\n\t\tstruct clk *clk = of_clk_get(dev->of_node, i);\n\t\tif (IS_ERR(clk))\n\t\t\tbreak;\n\t\tif (i >= GPC_CLK_MAX) {\n\t\t\tdev_err(dev, \"more than %d clocks\\n\", GPC_CLK_MAX);\n\t\t\tret = -EINVAL;\n\t\t\tgoto clk_err;\n\t\t}\n\t\tdomain->clk[i] = clk;\n\t}\n\tdomain->num_clks = i;\n\n\treturn 0;\n\nclk_err:\n\twhile (i--)\n\t\tclk_put(domain->clk[i]);\n\n\treturn ret;\n}\n\nstatic void imx_pgc_put_clocks(struct imx_pm_domain *domain)\n{\n\tint i;\n\n\tfor (i = domain->num_clks - 1; i >= 0; i--)\n\t\tclk_put(domain->clk[i]);\n}\n\nstatic int imx_pgc_parse_dt(struct device *dev, struct imx_pm_domain *domain)\n{\n\t \n\tdomain->supply = devm_regulator_get_optional(dev, \"power\");\n\tif (IS_ERR(domain->supply)) {\n\t\tif (PTR_ERR(domain->supply) == -ENODEV)\n\t\t\tdomain->supply = NULL;\n\t\telse\n\t\t\treturn PTR_ERR(domain->supply);\n\t}\n\n\t \n\treturn imx_pgc_get_clocks(dev, domain);\n}\n\nstatic int imx_pgc_power_domain_probe(struct platform_device *pdev)\n{\n\tstruct imx_pm_domain *domain = pdev->dev.platform_data;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\t \n\tif (dev->of_node) {\n\t\tret = imx_pgc_parse_dt(dev, domain);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (domain->base.power_on)\n\t\tdomain->base.power_on(&domain->base);\n\n\tif (IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS)) {\n\t\tpm_genpd_init(&domain->base, NULL, false);\n\t\tret = of_genpd_add_provider_simple(dev->of_node, &domain->base);\n\t\tif (ret)\n\t\t\tgoto genpd_err;\n\t}\n\n\tdevice_link_add(dev, dev->parent, DL_FLAG_AUTOREMOVE_CONSUMER);\n\n\treturn 0;\n\ngenpd_err:\n\tpm_genpd_remove(&domain->base);\n\timx_pgc_put_clocks(domain);\n\n\treturn ret;\n}\n\nstatic int imx_pgc_power_domain_remove(struct platform_device *pdev)\n{\n\tstruct imx_pm_domain *domain = pdev->dev.platform_data;\n\n\tif (IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS)) {\n\t\tof_genpd_del_provider(pdev->dev.of_node);\n\t\tpm_genpd_remove(&domain->base);\n\t\timx_pgc_put_clocks(domain);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id imx_pgc_power_domain_id[] = {\n\t{ \"imx-pgc-power-domain\"},\n\t{ },\n};\n\nstatic struct platform_driver imx_pgc_power_domain_driver = {\n\t.driver = {\n\t\t.name = \"imx-pgc-pd\",\n\t},\n\t.probe = imx_pgc_power_domain_probe,\n\t.remove = imx_pgc_power_domain_remove,\n\t.id_table = imx_pgc_power_domain_id,\n};\nbuiltin_platform_driver(imx_pgc_power_domain_driver)\n\n#define GPC_PGC_DOMAIN_ARM\t0\n#define GPC_PGC_DOMAIN_PU\t1\n#define GPC_PGC_DOMAIN_DISPLAY\t2\n#define GPC_PGC_DOMAIN_PCI\t3\n\nstatic struct genpd_power_state imx6_pm_domain_pu_state = {\n\t.power_off_latency_ns = 25000,\n\t.power_on_latency_ns = 2000000,\n};\n\nstatic struct imx_pm_domain imx_gpc_domains[] = {\n\t[GPC_PGC_DOMAIN_ARM] = {\n\t\t.base = {\n\t\t\t.name = \"ARM\",\n\t\t\t.flags = GENPD_FLAG_ALWAYS_ON,\n\t\t},\n\t},\n\t[GPC_PGC_DOMAIN_PU] = {\n\t\t.base = {\n\t\t\t.name = \"PU\",\n\t\t\t.power_off = imx6_pm_domain_power_off,\n\t\t\t.power_on = imx6_pm_domain_power_on,\n\t\t\t.states = &imx6_pm_domain_pu_state,\n\t\t\t.state_count = 1,\n\t\t},\n\t\t.reg_offs = 0x260,\n\t\t.cntr_pdn_bit = 0,\n\t},\n\t[GPC_PGC_DOMAIN_DISPLAY] = {\n\t\t.base = {\n\t\t\t.name = \"DISPLAY\",\n\t\t\t.power_off = imx6_pm_domain_power_off,\n\t\t\t.power_on = imx6_pm_domain_power_on,\n\t\t},\n\t\t.reg_offs = 0x240,\n\t\t.cntr_pdn_bit = 4,\n\t},\n\t[GPC_PGC_DOMAIN_PCI] = {\n\t\t.base = {\n\t\t\t.name = \"PCI\",\n\t\t\t.power_off = imx6_pm_domain_power_off,\n\t\t\t.power_on = imx6_pm_domain_power_on,\n\t\t},\n\t\t.reg_offs = 0x200,\n\t\t.cntr_pdn_bit = 6,\n\t},\n};\n\nstruct imx_gpc_dt_data {\n\tint num_domains;\n\tbool err009619_present;\n\tbool err006287_present;\n};\n\nstatic const struct imx_gpc_dt_data imx6q_dt_data = {\n\t.num_domains = 2,\n\t.err009619_present = false,\n\t.err006287_present = false,\n};\n\nstatic const struct imx_gpc_dt_data imx6qp_dt_data = {\n\t.num_domains = 2,\n\t.err009619_present = true,\n\t.err006287_present = false,\n};\n\nstatic const struct imx_gpc_dt_data imx6sl_dt_data = {\n\t.num_domains = 3,\n\t.err009619_present = false,\n\t.err006287_present = true,\n};\n\nstatic const struct imx_gpc_dt_data imx6sx_dt_data = {\n\t.num_domains = 4,\n\t.err009619_present = false,\n\t.err006287_present = false,\n};\n\nstatic const struct of_device_id imx_gpc_dt_ids[] = {\n\t{ .compatible = \"fsl,imx6q-gpc\", .data = &imx6q_dt_data },\n\t{ .compatible = \"fsl,imx6qp-gpc\", .data = &imx6qp_dt_data },\n\t{ .compatible = \"fsl,imx6sl-gpc\", .data = &imx6sl_dt_data },\n\t{ .compatible = \"fsl,imx6sx-gpc\", .data = &imx6sx_dt_data },\n\t{ }\n};\n\nstatic const struct regmap_range yes_ranges[] = {\n\tregmap_reg_range(GPC_CNTR, GPC_CNTR),\n\tregmap_reg_range(GPC_PGC_PCI_PDN, GPC_PGC_PCI_SR),\n\tregmap_reg_range(GPC_PGC_GPU_PDN, GPC_PGC_GPU_SR),\n\tregmap_reg_range(GPC_PGC_DISP_PDN, GPC_PGC_DISP_SR),\n};\n\nstatic const struct regmap_access_table access_table = {\n\t.yes_ranges\t= yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(yes_ranges),\n};\n\nstatic const struct regmap_config imx_gpc_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.rd_table = &access_table,\n\t.wr_table = &access_table,\n\t.max_register = 0x2ac,\n\t.fast_io = true,\n};\n\nstatic struct generic_pm_domain *imx_gpc_onecell_domains[] = {\n\t&imx_gpc_domains[GPC_PGC_DOMAIN_ARM].base,\n\t&imx_gpc_domains[GPC_PGC_DOMAIN_PU].base,\n};\n\nstatic struct genpd_onecell_data imx_gpc_onecell_data = {\n\t.domains = imx_gpc_onecell_domains,\n\t.num_domains = 2,\n};\n\nstatic int imx_gpc_old_dt_init(struct device *dev, struct regmap *regmap,\n\t\t\t       unsigned int num_domains)\n{\n\tstruct imx_pm_domain *domain;\n\tint i, ret;\n\n\tfor (i = 0; i < num_domains; i++) {\n\t\tdomain = &imx_gpc_domains[i];\n\t\tdomain->regmap = regmap;\n\t\tdomain->ipg_rate_mhz = 66;\n\n\t\tif (i == 1) {\n\t\t\tdomain->supply = devm_regulator_get(dev, \"pu\");\n\t\t\tif (IS_ERR(domain->supply))\n\t\t\t\treturn PTR_ERR(domain->supply);\n\n\t\t\tret = imx_pgc_get_clocks(dev, domain);\n\t\t\tif (ret)\n\t\t\t\tgoto clk_err;\n\n\t\t\tdomain->base.power_on(&domain->base);\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_domains; i++)\n\t\tpm_genpd_init(&imx_gpc_domains[i].base, NULL, false);\n\n\tif (IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS)) {\n\t\tret = of_genpd_add_provider_onecell(dev->of_node,\n\t\t\t\t\t\t    &imx_gpc_onecell_data);\n\t\tif (ret)\n\t\t\tgoto genpd_err;\n\t}\n\n\treturn 0;\n\ngenpd_err:\n\tfor (i = 0; i < num_domains; i++)\n\t\tpm_genpd_remove(&imx_gpc_domains[i].base);\n\timx_pgc_put_clocks(&imx_gpc_domains[GPC_PGC_DOMAIN_PU]);\nclk_err:\n\treturn ret;\n}\n\nstatic int imx_gpc_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id =\n\t\t\tof_match_device(imx_gpc_dt_ids, &pdev->dev);\n\tconst struct imx_gpc_dt_data *of_id_data = of_id->data;\n\tstruct device_node *pgc_node;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tint ret;\n\n\tpgc_node = of_get_child_by_name(pdev->dev.of_node, \"pgc\");\n\n\t \n\tif (!of_property_read_bool(pdev->dev.of_node, \"#power-domain-cells\") &&\n\t    !pgc_node)\n\t\treturn 0;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio_clk(&pdev->dev, NULL, base,\n\t\t\t\t\t   &imx_gpc_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tdev_err(&pdev->dev, \"failed to init regmap: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (of_id_data->err009619_present)\n\t\timx_gpc_domains[GPC_PGC_DOMAIN_PU].base.flags |=\n\t\t\t\tGENPD_FLAG_RPM_ALWAYS_ON;\n\n\t \n\tif (of_id_data->err006287_present)\n\t\timx_gpc_domains[GPC_PGC_DOMAIN_DISPLAY].base.flags |=\n\t\t\t\tGENPD_FLAG_ALWAYS_ON;\n\n\tif (!pgc_node) {\n\t\tret = imx_gpc_old_dt_init(&pdev->dev, regmap,\n\t\t\t\t\t  of_id_data->num_domains);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tstruct imx_pm_domain *domain;\n\t\tstruct platform_device *pd_pdev;\n\t\tstruct device_node *np;\n\t\tstruct clk *ipg_clk;\n\t\tunsigned int ipg_rate_mhz;\n\t\tint domain_index;\n\n\t\tipg_clk = devm_clk_get(&pdev->dev, \"ipg\");\n\t\tif (IS_ERR(ipg_clk))\n\t\t\treturn PTR_ERR(ipg_clk);\n\t\tipg_rate_mhz = clk_get_rate(ipg_clk) / 1000000;\n\n\t\tfor_each_child_of_node(pgc_node, np) {\n\t\t\tret = of_property_read_u32(np, \"reg\", &domain_index);\n\t\t\tif (ret) {\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif (domain_index >= of_id_data->num_domains)\n\t\t\t\tcontinue;\n\n\t\t\tpd_pdev = platform_device_alloc(\"imx-pgc-power-domain\",\n\t\t\t\t\t\t\tdomain_index);\n\t\t\tif (!pd_pdev) {\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tret = platform_device_add_data(pd_pdev,\n\t\t\t\t\t\t       &imx_gpc_domains[domain_index],\n\t\t\t\t\t\t       sizeof(imx_gpc_domains[domain_index]));\n\t\t\tif (ret) {\n\t\t\t\tplatform_device_put(pd_pdev);\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdomain = pd_pdev->dev.platform_data;\n\t\t\tdomain->regmap = regmap;\n\t\t\tdomain->ipg_rate_mhz = ipg_rate_mhz;\n\n\t\t\tpd_pdev->dev.parent = &pdev->dev;\n\t\t\tpd_pdev->dev.of_node = np;\n\t\t\tpd_pdev->dev.fwnode = of_fwnode_handle(np);\n\n\t\t\tret = platform_device_add(pd_pdev);\n\t\t\tif (ret) {\n\t\t\t\tplatform_device_put(pd_pdev);\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_gpc_remove(struct platform_device *pdev)\n{\n\tstruct device_node *pgc_node;\n\tint ret;\n\n\tpgc_node = of_get_child_by_name(pdev->dev.of_node, \"pgc\");\n\n\t \n\tif (!of_property_read_bool(pdev->dev.of_node, \"#power-domain-cells\") &&\n\t    !pgc_node)\n\t\treturn 0;\n\n\t \n\tif (!pgc_node) {\n\t\tof_genpd_del_provider(pdev->dev.of_node);\n\n\t\tret = pm_genpd_remove(&imx_gpc_domains[GPC_PGC_DOMAIN_PU].base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\timx_pgc_put_clocks(&imx_gpc_domains[GPC_PGC_DOMAIN_PU]);\n\n\t\tret = pm_genpd_remove(&imx_gpc_domains[GPC_PGC_DOMAIN_ARM].base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver imx_gpc_driver = {\n\t.driver = {\n\t\t.name = \"imx-gpc\",\n\t\t.of_match_table = imx_gpc_dt_ids,\n\t},\n\t.probe = imx_gpc_probe,\n\t.remove = imx_gpc_remove,\n};\nbuiltin_platform_driver(imx_gpc_driver)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}