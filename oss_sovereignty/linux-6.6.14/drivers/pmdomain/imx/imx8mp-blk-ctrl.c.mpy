{
  "module_name": "imx8mp-blk-ctrl.c",
  "hash_id": "d2d312924017c53f6c285cb52614891429a91cb766dc4a7e3b3dea542e7bb0a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/imx/imx8mp-blk-ctrl.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/interconnect.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/power/imx8mp-power.h>\n\n#define GPR_REG0\t\t0x0\n#define  PCIE_CLOCK_MODULE_EN\tBIT(0)\n#define  USB_CLOCK_MODULE_EN\tBIT(1)\n#define  PCIE_PHY_APB_RST\tBIT(4)\n#define  PCIE_PHY_INIT_RST\tBIT(5)\n#define GPR_REG1\t\t0x4\n#define  PLL_LOCK\t\tBIT(13)\n#define GPR_REG2\t\t0x8\n#define  P_PLL_MASK\t\tGENMASK(5, 0)\n#define  M_PLL_MASK\t\tGENMASK(15, 6)\n#define  S_PLL_MASK\t\tGENMASK(18, 16)\n#define GPR_REG3\t\t0xc\n#define  PLL_CKE\t\tBIT(17)\n#define  PLL_RST\t\tBIT(31)\n\nstruct imx8mp_blk_ctrl_domain;\n\nstruct imx8mp_blk_ctrl {\n\tstruct device *dev;\n\tstruct notifier_block power_nb;\n\tstruct device *bus_power_dev;\n\tstruct regmap *regmap;\n\tstruct imx8mp_blk_ctrl_domain *domains;\n\tstruct genpd_onecell_data onecell_data;\n\tvoid (*power_off) (struct imx8mp_blk_ctrl *bc, struct imx8mp_blk_ctrl_domain *domain);\n\tvoid (*power_on) (struct imx8mp_blk_ctrl *bc, struct imx8mp_blk_ctrl_domain *domain);\n};\n\nstruct imx8mp_blk_ctrl_domain_data {\n\tconst char *name;\n\tconst char * const *clk_names;\n\tint num_clks;\n\tconst char * const *path_names;\n\tint num_paths;\n\tconst char *gpc_name;\n};\n\n#define DOMAIN_MAX_CLKS 2\n#define DOMAIN_MAX_PATHS 3\n\nstruct imx8mp_blk_ctrl_domain {\n\tstruct generic_pm_domain genpd;\n\tconst struct imx8mp_blk_ctrl_domain_data *data;\n\tstruct clk_bulk_data clks[DOMAIN_MAX_CLKS];\n\tstruct icc_bulk_data paths[DOMAIN_MAX_PATHS];\n\tstruct device *power_dev;\n\tstruct imx8mp_blk_ctrl *bc;\n\tint num_paths;\n\tint id;\n};\n\nstruct imx8mp_blk_ctrl_data {\n\tint max_reg;\n\tint (*probe) (struct imx8mp_blk_ctrl *bc);\n\tnotifier_fn_t power_notifier_fn;\n\tvoid (*power_off) (struct imx8mp_blk_ctrl *bc, struct imx8mp_blk_ctrl_domain *domain);\n\tvoid (*power_on) (struct imx8mp_blk_ctrl *bc, struct imx8mp_blk_ctrl_domain *domain);\n\tconst struct imx8mp_blk_ctrl_domain_data *domains;\n\tint num_domains;\n};\n\nstatic inline struct imx8mp_blk_ctrl_domain *\nto_imx8mp_blk_ctrl_domain(struct generic_pm_domain *genpd)\n{\n\treturn container_of(genpd, struct imx8mp_blk_ctrl_domain, genpd);\n}\n\nstruct clk_hsio_pll {\n\tstruct clk_hw\thw;\n\tstruct regmap *regmap;\n};\n\nstatic inline struct clk_hsio_pll *to_clk_hsio_pll(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct clk_hsio_pll, hw);\n}\n\nstatic int clk_hsio_pll_prepare(struct clk_hw *hw)\n{\n\tstruct clk_hsio_pll *clk = to_clk_hsio_pll(hw);\n\tu32 val;\n\n\t \n\tregmap_update_bits(clk->regmap, GPR_REG2,\n\t\t\t   P_PLL_MASK | M_PLL_MASK | S_PLL_MASK,\n\t\t\t   FIELD_PREP(P_PLL_MASK, 12) |\n\t\t\t   FIELD_PREP(M_PLL_MASK, 800) |\n\t\t\t   FIELD_PREP(S_PLL_MASK, 4));\n\n\t \n\tregmap_update_bits(clk->regmap, GPR_REG3, PLL_RST, PLL_RST);\n\n\t \n\tregmap_update_bits(clk->regmap, GPR_REG3, PLL_CKE, PLL_CKE);\n\n\treturn regmap_read_poll_timeout(clk->regmap, GPR_REG1, val,\n\t\t\t\t\tval & PLL_LOCK, 10, 100);\n}\n\nstatic void clk_hsio_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_hsio_pll *clk = to_clk_hsio_pll(hw);\n\n\tregmap_update_bits(clk->regmap, GPR_REG3, PLL_RST | PLL_CKE, 0);\n}\n\nstatic int clk_hsio_pll_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_hsio_pll *clk = to_clk_hsio_pll(hw);\n\n\treturn regmap_test_bits(clk->regmap, GPR_REG1, PLL_LOCK);\n}\n\nstatic unsigned long clk_hsio_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\treturn 100000000;\n}\n\nstatic const struct clk_ops clk_hsio_pll_ops = {\n\t.prepare = clk_hsio_pll_prepare,\n\t.unprepare = clk_hsio_pll_unprepare,\n\t.is_prepared = clk_hsio_pll_is_prepared,\n\t.recalc_rate = clk_hsio_pll_recalc_rate,\n};\n\nstatic int imx8mp_hsio_blk_ctrl_probe(struct imx8mp_blk_ctrl *bc)\n{\n\tstruct clk_hsio_pll *clk_hsio_pll;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tint ret;\n\n\tclk_hsio_pll = devm_kzalloc(bc->dev, sizeof(*clk_hsio_pll), GFP_KERNEL);\n\tif (!clk_hsio_pll)\n\t\treturn -ENOMEM;\n\n\tinit.name = \"hsio_pll\";\n\tinit.ops = &clk_hsio_pll_ops;\n\tinit.parent_names = (const char *[]){\"osc_24m\"};\n\tinit.num_parents = 1;\n\n\tclk_hsio_pll->regmap = bc->regmap;\n\tclk_hsio_pll->hw.init = &init;\n\n\thw = &clk_hsio_pll->hw;\n\tret = devm_clk_hw_register(bc->bus_power_dev, hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_of_clk_add_hw_provider(bc->dev, of_clk_hw_simple_get, hw);\n}\n\nstatic void imx8mp_hsio_blk_ctrl_power_on(struct imx8mp_blk_ctrl *bc,\n\t\t\t\t\t  struct imx8mp_blk_ctrl_domain *domain)\n{\n\tswitch (domain->id) {\n\tcase IMX8MP_HSIOBLK_PD_USB:\n\t\tregmap_set_bits(bc->regmap, GPR_REG0, USB_CLOCK_MODULE_EN);\n\t\tbreak;\n\tcase IMX8MP_HSIOBLK_PD_PCIE:\n\t\tregmap_set_bits(bc->regmap, GPR_REG0, PCIE_CLOCK_MODULE_EN);\n\t\tbreak;\n\tcase IMX8MP_HSIOBLK_PD_PCIE_PHY:\n\t\tregmap_set_bits(bc->regmap, GPR_REG0,\n\t\t\t\tPCIE_PHY_APB_RST | PCIE_PHY_INIT_RST);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void imx8mp_hsio_blk_ctrl_power_off(struct imx8mp_blk_ctrl *bc,\n\t\t\t\t\t   struct imx8mp_blk_ctrl_domain *domain)\n{\n\tswitch (domain->id) {\n\tcase IMX8MP_HSIOBLK_PD_USB:\n\t\tregmap_clear_bits(bc->regmap, GPR_REG0, USB_CLOCK_MODULE_EN);\n\t\tbreak;\n\tcase IMX8MP_HSIOBLK_PD_PCIE:\n\t\tregmap_clear_bits(bc->regmap, GPR_REG0, PCIE_CLOCK_MODULE_EN);\n\t\tbreak;\n\tcase IMX8MP_HSIOBLK_PD_PCIE_PHY:\n\t\tregmap_clear_bits(bc->regmap, GPR_REG0,\n\t\t\t\t  PCIE_PHY_APB_RST | PCIE_PHY_INIT_RST);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int imx8mp_hsio_power_notifier(struct notifier_block *nb,\n\t\t\t\t      unsigned long action, void *data)\n{\n\tstruct imx8mp_blk_ctrl *bc = container_of(nb, struct imx8mp_blk_ctrl,\n\t\t\t\t\t\t power_nb);\n\tstruct clk_bulk_data *usb_clk = bc->domains[IMX8MP_HSIOBLK_PD_USB].clks;\n\tint num_clks = bc->domains[IMX8MP_HSIOBLK_PD_USB].data->num_clks;\n\tint ret;\n\n\tswitch (action) {\n\tcase GENPD_NOTIFY_ON:\n\t\t \n\t\tret = clk_bulk_prepare_enable(num_clks, usb_clk);\n\t\tif (ret)\n\t\t\treturn NOTIFY_BAD;\n\t\tregmap_set_bits(bc->regmap, GPR_REG0, USB_CLOCK_MODULE_EN);\n\n\t\tudelay(5);\n\n\t\tregmap_clear_bits(bc->regmap, GPR_REG0, USB_CLOCK_MODULE_EN);\n\t\tclk_bulk_disable_unprepare(num_clks, usb_clk);\n\t\tbreak;\n\tcase GENPD_NOTIFY_PRE_OFF:\n\t\t \n\t\tret = clk_bulk_prepare_enable(num_clks, usb_clk);\n\t\tif (ret)\n\t\t\treturn NOTIFY_BAD;\n\n\t\tregmap_set_bits(bc->regmap, GPR_REG0, USB_CLOCK_MODULE_EN);\n\t\tbreak;\n\tcase GENPD_NOTIFY_OFF:\n\t\tclk_bulk_disable_unprepare(num_clks, usb_clk);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic const struct imx8mp_blk_ctrl_domain_data imx8mp_hsio_domain_data[] = {\n\t[IMX8MP_HSIOBLK_PD_USB] = {\n\t\t.name = \"hsioblk-usb\",\n\t\t.clk_names = (const char *[]){ \"usb\" },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"usb\",\n\t\t.path_names = (const char *[]){\"usb1\", \"usb2\"},\n\t\t.num_paths = 2,\n\t},\n\t[IMX8MP_HSIOBLK_PD_USB_PHY1] = {\n\t\t.name = \"hsioblk-usb-phy1\",\n\t\t.gpc_name = \"usb-phy1\",\n\t},\n\t[IMX8MP_HSIOBLK_PD_USB_PHY2] = {\n\t\t.name = \"hsioblk-usb-phy2\",\n\t\t.gpc_name = \"usb-phy2\",\n\t},\n\t[IMX8MP_HSIOBLK_PD_PCIE] = {\n\t\t.name = \"hsioblk-pcie\",\n\t\t.clk_names = (const char *[]){ \"pcie\" },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"pcie\",\n\t\t.path_names = (const char *[]){\"noc-pcie\", \"pcie\"},\n\t\t.num_paths = 2,\n\t},\n\t[IMX8MP_HSIOBLK_PD_PCIE_PHY] = {\n\t\t.name = \"hsioblk-pcie-phy\",\n\t\t.gpc_name = \"pcie-phy\",\n\t},\n};\n\nstatic const struct imx8mp_blk_ctrl_data imx8mp_hsio_blk_ctl_dev_data = {\n\t.max_reg = 0x24,\n\t.probe = imx8mp_hsio_blk_ctrl_probe,\n\t.power_on = imx8mp_hsio_blk_ctrl_power_on,\n\t.power_off = imx8mp_hsio_blk_ctrl_power_off,\n\t.power_notifier_fn = imx8mp_hsio_power_notifier,\n\t.domains = imx8mp_hsio_domain_data,\n\t.num_domains = ARRAY_SIZE(imx8mp_hsio_domain_data),\n};\n\n#define HDMI_RTX_RESET_CTL0\t0x20\n#define HDMI_RTX_CLK_CTL0\t0x40\n#define HDMI_RTX_CLK_CTL1\t0x50\n#define HDMI_RTX_CLK_CTL2\t0x60\n#define HDMI_RTX_CLK_CTL3\t0x70\n#define HDMI_RTX_CLK_CTL4\t0x80\n#define HDMI_TX_CONTROL0\t0x200\n#define  HDMI_LCDIF_NOC_HURRY_MASK\t\tGENMASK(14, 12)\n\nstatic void imx8mp_hdmi_blk_ctrl_power_on(struct imx8mp_blk_ctrl *bc,\n\t\t\t\t\t  struct imx8mp_blk_ctrl_domain *domain)\n{\n\tswitch (domain->id) {\n\tcase IMX8MP_HDMIBLK_PD_IRQSTEER:\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL0, BIT(9));\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(16));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_LCDIF:\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL0,\n\t\t\t\tBIT(16) | BIT(17) | BIT(18) |\n\t\t\t\tBIT(19) | BIT(20));\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL1, BIT(11));\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_RESET_CTL0,\n\t\t\t\tBIT(4) | BIT(5) | BIT(6));\n\t\tregmap_set_bits(bc->regmap, HDMI_TX_CONTROL0,\n\t\t\t\tFIELD_PREP(HDMI_LCDIF_NOC_HURRY_MASK, 7));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_PAI:\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL1, BIT(17));\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(18));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_PVI:\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL1, BIT(28));\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(22));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_TRNG:\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL1, BIT(27) | BIT(30));\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(20));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_HDMI_TX:\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL0,\n\t\t\t\tBIT(2) | BIT(4) | BIT(5));\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL1,\n\t\t\t\tBIT(12) | BIT(13) | BIT(14) | BIT(15) | BIT(16) |\n\t\t\t\tBIT(18) | BIT(19) | BIT(20) | BIT(21));\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_RESET_CTL0,\n\t\t\t\tBIT(7) | BIT(10) | BIT(11));\n\t\tregmap_set_bits(bc->regmap, HDMI_TX_CONTROL0, BIT(1));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_HDMI_TX_PHY:\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL0, BIT(7));\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL1, BIT(22) | BIT(24));\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(12));\n\t\tregmap_clear_bits(bc->regmap, HDMI_TX_CONTROL0, BIT(3));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_HDCP:\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL0, BIT(11));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_HRV:\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL1, BIT(3) | BIT(4) | BIT(5));\n\t\tregmap_set_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(15));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void imx8mp_hdmi_blk_ctrl_power_off(struct imx8mp_blk_ctrl *bc,\n\t\t\t\t\t   struct imx8mp_blk_ctrl_domain *domain)\n{\n\tswitch (domain->id) {\n\tcase IMX8MP_HDMIBLK_PD_IRQSTEER:\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_CLK_CTL0, BIT(9));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(16));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_LCDIF:\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_RESET_CTL0,\n\t\t\t\t  BIT(4) | BIT(5) | BIT(6));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_CLK_CTL1, BIT(11));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_CLK_CTL0,\n\t\t\t\t  BIT(16) | BIT(17) | BIT(18) |\n\t\t\t\t  BIT(19) | BIT(20));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_PAI:\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(18));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_CLK_CTL1, BIT(17));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_PVI:\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(22));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_CLK_CTL1, BIT(28));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_TRNG:\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(20));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_CLK_CTL1, BIT(27) | BIT(30));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_HDMI_TX:\n\t\tregmap_clear_bits(bc->regmap, HDMI_TX_CONTROL0, BIT(1));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_RESET_CTL0,\n\t\t\t\t  BIT(7) | BIT(10) | BIT(11));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_CLK_CTL1,\n\t\t\t\t  BIT(12) | BIT(13) | BIT(14) | BIT(15) | BIT(16) |\n\t\t\t\t  BIT(18) | BIT(19) | BIT(20) | BIT(21));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_CLK_CTL0,\n\t\t\t\t  BIT(2) | BIT(4) | BIT(5));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_HDMI_TX_PHY:\n\t\tregmap_set_bits(bc->regmap, HDMI_TX_CONTROL0, BIT(3));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(12));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_CLK_CTL0, BIT(7));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_CLK_CTL1, BIT(22) | BIT(24));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_HDCP:\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_CLK_CTL0, BIT(11));\n\t\tbreak;\n\tcase IMX8MP_HDMIBLK_PD_HRV:\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(15));\n\t\tregmap_clear_bits(bc->regmap, HDMI_RTX_CLK_CTL1, BIT(3) | BIT(4) | BIT(5));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int imx8mp_hdmi_power_notifier(struct notifier_block *nb,\n\t\t\t\t      unsigned long action, void *data)\n{\n\tstruct imx8mp_blk_ctrl *bc = container_of(nb, struct imx8mp_blk_ctrl,\n\t\t\t\t\t\t power_nb);\n\n\tif (action != GENPD_NOTIFY_ON)\n\t\treturn NOTIFY_OK;\n\n\t \n\tregmap_write(bc->regmap, HDMI_RTX_RESET_CTL0, 0x0);\n\tregmap_write(bc->regmap, HDMI_RTX_CLK_CTL0, 0x0);\n\tregmap_write(bc->regmap, HDMI_RTX_CLK_CTL1, 0x0);\n\tregmap_set_bits(bc->regmap, HDMI_RTX_CLK_CTL0,\n\t\t\tBIT(0) | BIT(1) | BIT(10));\n\tregmap_set_bits(bc->regmap, HDMI_RTX_RESET_CTL0, BIT(0));\n\n\t \n\tudelay(5);\n\n\treturn NOTIFY_OK;\n}\n\nstatic const struct imx8mp_blk_ctrl_domain_data imx8mp_hdmi_domain_data[] = {\n\t[IMX8MP_HDMIBLK_PD_IRQSTEER] = {\n\t\t.name = \"hdmiblk-irqsteer\",\n\t\t.clk_names = (const char *[]){ \"apb\" },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"irqsteer\",\n\t},\n\t[IMX8MP_HDMIBLK_PD_LCDIF] = {\n\t\t.name = \"hdmiblk-lcdif\",\n\t\t.clk_names = (const char *[]){ \"axi\", \"apb\" },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"lcdif\",\n\t\t.path_names = (const char *[]){\"lcdif-hdmi\"},\n\t\t.num_paths = 1,\n\t},\n\t[IMX8MP_HDMIBLK_PD_PAI] = {\n\t\t.name = \"hdmiblk-pai\",\n\t\t.clk_names = (const char *[]){ \"apb\" },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"pai\",\n\t},\n\t[IMX8MP_HDMIBLK_PD_PVI] = {\n\t\t.name = \"hdmiblk-pvi\",\n\t\t.clk_names = (const char *[]){ \"apb\" },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"pvi\",\n\t},\n\t[IMX8MP_HDMIBLK_PD_TRNG] = {\n\t\t.name = \"hdmiblk-trng\",\n\t\t.clk_names = (const char *[]){ \"apb\" },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"trng\",\n\t},\n\t[IMX8MP_HDMIBLK_PD_HDMI_TX] = {\n\t\t.name = \"hdmiblk-hdmi-tx\",\n\t\t.clk_names = (const char *[]){ \"apb\", \"ref_266m\" },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"hdmi-tx\",\n\t},\n\t[IMX8MP_HDMIBLK_PD_HDMI_TX_PHY] = {\n\t\t.name = \"hdmiblk-hdmi-tx-phy\",\n\t\t.clk_names = (const char *[]){ \"apb\", \"ref_24m\" },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"hdmi-tx-phy\",\n\t},\n\t[IMX8MP_HDMIBLK_PD_HRV] = {\n\t\t.name = \"hdmiblk-hrv\",\n\t\t.clk_names = (const char *[]){ \"axi\", \"apb\" },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"hrv\",\n\t\t.path_names = (const char *[]){\"hrv\"},\n\t\t.num_paths = 1,\n\t},\n\t[IMX8MP_HDMIBLK_PD_HDCP] = {\n\t\t.name = \"hdmiblk-hdcp\",\n\t\t.clk_names = (const char *[]){ \"axi\", \"apb\" },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"hdcp\",\n\t\t.path_names = (const char *[]){\"hdcp\"},\n\t\t.num_paths = 1,\n\t},\n};\n\nstatic const struct imx8mp_blk_ctrl_data imx8mp_hdmi_blk_ctl_dev_data = {\n\t.max_reg = 0x23c,\n\t.power_on = imx8mp_hdmi_blk_ctrl_power_on,\n\t.power_off = imx8mp_hdmi_blk_ctrl_power_off,\n\t.power_notifier_fn = imx8mp_hdmi_power_notifier,\n\t.domains = imx8mp_hdmi_domain_data,\n\t.num_domains = ARRAY_SIZE(imx8mp_hdmi_domain_data),\n};\n\nstatic int imx8mp_blk_ctrl_power_on(struct generic_pm_domain *genpd)\n{\n\tstruct imx8mp_blk_ctrl_domain *domain = to_imx8mp_blk_ctrl_domain(genpd);\n\tconst struct imx8mp_blk_ctrl_domain_data *data = domain->data;\n\tstruct imx8mp_blk_ctrl *bc = domain->bc;\n\tint ret;\n\n\t \n\tret = pm_runtime_resume_and_get(bc->bus_power_dev);\n\tif (ret < 0) {\n\t\tdev_err(bc->dev, \"failed to power up bus domain\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = clk_bulk_prepare_enable(data->num_clks, domain->clks);\n\tif (ret) {\n\t\tdev_err(bc->dev, \"failed to enable clocks\\n\");\n\t\tgoto bus_put;\n\t}\n\n\t \n\tbc->power_on(bc, domain);\n\n\t \n\tret = pm_runtime_resume_and_get(domain->power_dev);\n\tif (ret < 0) {\n\t\tdev_err(bc->dev, \"failed to power up peripheral domain\\n\");\n\t\tgoto clk_disable;\n\t}\n\n\tret = icc_bulk_set_bw(domain->num_paths, domain->paths);\n\tif (ret)\n\t\tdev_err(bc->dev, \"failed to set icc bw\\n\");\n\n\tclk_bulk_disable_unprepare(data->num_clks, domain->clks);\n\n\treturn 0;\n\nclk_disable:\n\tclk_bulk_disable_unprepare(data->num_clks, domain->clks);\nbus_put:\n\tpm_runtime_put(bc->bus_power_dev);\n\n\treturn ret;\n}\n\nstatic int imx8mp_blk_ctrl_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct imx8mp_blk_ctrl_domain *domain = to_imx8mp_blk_ctrl_domain(genpd);\n\tconst struct imx8mp_blk_ctrl_domain_data *data = domain->data;\n\tstruct imx8mp_blk_ctrl *bc = domain->bc;\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(data->num_clks, domain->clks);\n\tif (ret) {\n\t\tdev_err(bc->dev, \"failed to enable clocks\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tbc->power_off(bc, domain);\n\n\tclk_bulk_disable_unprepare(data->num_clks, domain->clks);\n\n\t \n\tpm_runtime_put(domain->power_dev);\n\n\t \n\tpm_runtime_put(bc->bus_power_dev);\n\n\treturn 0;\n}\n\nstatic struct lock_class_key blk_ctrl_genpd_lock_class;\n\nstatic int imx8mp_blk_ctrl_probe(struct platform_device *pdev)\n{\n\tconst struct imx8mp_blk_ctrl_data *bc_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct imx8mp_blk_ctrl *bc;\n\tvoid __iomem *base;\n\tint num_domains, i, ret;\n\n\tstruct regmap_config regmap_config = {\n\t\t.reg_bits\t= 32,\n\t\t.val_bits\t= 32,\n\t\t.reg_stride\t= 4,\n\t};\n\n\tbc = devm_kzalloc(dev, sizeof(*bc), GFP_KERNEL);\n\tif (!bc)\n\t\treturn -ENOMEM;\n\n\tbc->dev = dev;\n\n\tbc_data = of_device_get_match_data(dev);\n\tnum_domains = bc_data->num_domains;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap_config.max_register = bc_data->max_reg;\n\tbc->regmap = devm_regmap_init_mmio(dev, base, &regmap_config);\n\tif (IS_ERR(bc->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(bc->regmap),\n\t\t\t\t     \"failed to init regmap\\n\");\n\n\tbc->domains = devm_kcalloc(dev, num_domains,\n\t\t\t\t   sizeof(struct imx8mp_blk_ctrl_domain),\n\t\t\t\t   GFP_KERNEL);\n\tif (!bc->domains)\n\t\treturn -ENOMEM;\n\n\tbc->onecell_data.num_domains = num_domains;\n\tbc->onecell_data.domains =\n\t\tdevm_kcalloc(dev, num_domains,\n\t\t\t     sizeof(struct generic_pm_domain *), GFP_KERNEL);\n\tif (!bc->onecell_data.domains)\n\t\treturn -ENOMEM;\n\n\tbc->bus_power_dev = dev_pm_domain_attach_by_name(dev, \"bus\");\n\tif (IS_ERR(bc->bus_power_dev))\n\t\treturn dev_err_probe(dev, PTR_ERR(bc->bus_power_dev),\n\t\t\t\t     \"failed to attach bus power domain\\n\");\n\n\tbc->power_off = bc_data->power_off;\n\tbc->power_on = bc_data->power_on;\n\n\tfor (i = 0; i < num_domains; i++) {\n\t\tconst struct imx8mp_blk_ctrl_domain_data *data = &bc_data->domains[i];\n\t\tstruct imx8mp_blk_ctrl_domain *domain = &bc->domains[i];\n\t\tint j;\n\n\t\tdomain->data = data;\n\t\tdomain->num_paths = data->num_paths;\n\n\t\tfor (j = 0; j < data->num_clks; j++)\n\t\t\tdomain->clks[j].id = data->clk_names[j];\n\n\t\tfor (j = 0; j < data->num_paths; j++) {\n\t\t\tdomain->paths[j].name = data->path_names[j];\n\t\t\t \n\t\t\tdomain->paths[j].avg_bw = 1;\n\t\t\tdomain->paths[j].peak_bw = 1;\n\t\t}\n\n\t\tret = devm_of_icc_bulk_get(dev, data->num_paths, domain->paths);\n\t\tif (ret) {\n\t\t\tif (ret != -EPROBE_DEFER) {\n\t\t\t\tdev_warn_once(dev, \"Could not get interconnect paths, NoC will stay unconfigured!\\n\");\n\t\t\t\tdomain->num_paths = 0;\n\t\t\t} else {\n\t\t\t\tdev_err_probe(dev, ret, \"failed to get noc entries\\n\");\n\t\t\t\tgoto cleanup_pds;\n\t\t\t}\n\t\t}\n\n\t\tret = devm_clk_bulk_get(dev, data->num_clks, domain->clks);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"failed to get clock\\n\");\n\t\t\tgoto cleanup_pds;\n\t\t}\n\n\t\tdomain->power_dev =\n\t\t\tdev_pm_domain_attach_by_name(dev, data->gpc_name);\n\t\tif (IS_ERR(domain->power_dev)) {\n\t\t\tdev_err_probe(dev, PTR_ERR(domain->power_dev),\n\t\t\t\t      \"failed to attach power domain %s\\n\",\n\t\t\t\t      data->gpc_name);\n\t\t\tret = PTR_ERR(domain->power_dev);\n\t\t\tgoto cleanup_pds;\n\t\t}\n\n\t\tdomain->genpd.name = data->name;\n\t\tdomain->genpd.power_on = imx8mp_blk_ctrl_power_on;\n\t\tdomain->genpd.power_off = imx8mp_blk_ctrl_power_off;\n\t\tdomain->bc = bc;\n\t\tdomain->id = i;\n\n\t\tret = pm_genpd_init(&domain->genpd, NULL, true);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"failed to init power domain\\n\");\n\t\t\tdev_pm_domain_detach(domain->power_dev, true);\n\t\t\tgoto cleanup_pds;\n\t\t}\n\n\t\t \n\t\tlockdep_set_class(&domain->genpd.mlock,\n\t\t\t\t  &blk_ctrl_genpd_lock_class);\n\n\t\tbc->onecell_data.domains[i] = &domain->genpd;\n\t}\n\n\tret = of_genpd_add_provider_onecell(dev->of_node, &bc->onecell_data);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to add power domain provider\\n\");\n\t\tgoto cleanup_pds;\n\t}\n\n\tbc->power_nb.notifier_call = bc_data->power_notifier_fn;\n\tret = dev_pm_genpd_add_notifier(bc->bus_power_dev, &bc->power_nb);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to add power notifier\\n\");\n\t\tgoto cleanup_provider;\n\t}\n\n\tif (bc_data->probe) {\n\t\tret = bc_data->probe(bc);\n\t\tif (ret)\n\t\t\tgoto cleanup_provider;\n\t}\n\n\tdev_set_drvdata(dev, bc);\n\n\treturn 0;\n\ncleanup_provider:\n\tof_genpd_del_provider(dev->of_node);\ncleanup_pds:\n\tfor (i--; i >= 0; i--) {\n\t\tpm_genpd_remove(&bc->domains[i].genpd);\n\t\tdev_pm_domain_detach(bc->domains[i].power_dev, true);\n\t}\n\n\tdev_pm_domain_detach(bc->bus_power_dev, true);\n\n\treturn ret;\n}\n\nstatic int imx8mp_blk_ctrl_remove(struct platform_device *pdev)\n{\n\tstruct imx8mp_blk_ctrl *bc = dev_get_drvdata(&pdev->dev);\n\tint i;\n\n\tof_genpd_del_provider(pdev->dev.of_node);\n\n\tfor (i = 0; bc->onecell_data.num_domains; i++) {\n\t\tstruct imx8mp_blk_ctrl_domain *domain = &bc->domains[i];\n\n\t\tpm_genpd_remove(&domain->genpd);\n\t\tdev_pm_domain_detach(domain->power_dev, true);\n\t}\n\n\tdev_pm_genpd_remove_notifier(bc->bus_power_dev);\n\n\tdev_pm_domain_detach(bc->bus_power_dev, true);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int imx8mp_blk_ctrl_suspend(struct device *dev)\n{\n\tstruct imx8mp_blk_ctrl *bc = dev_get_drvdata(dev);\n\tint ret, i;\n\n\t \n\tret = pm_runtime_get_sync(bc->bus_power_dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(bc->bus_power_dev);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < bc->onecell_data.num_domains; i++) {\n\t\tstruct imx8mp_blk_ctrl_domain *domain = &bc->domains[i];\n\n\t\tret = pm_runtime_get_sync(domain->power_dev);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_noidle(domain->power_dev);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_fail:\n\tfor (i--; i >= 0; i--)\n\t\tpm_runtime_put(bc->domains[i].power_dev);\n\n\tpm_runtime_put(bc->bus_power_dev);\n\n\treturn ret;\n}\n\nstatic int imx8mp_blk_ctrl_resume(struct device *dev)\n{\n\tstruct imx8mp_blk_ctrl *bc = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < bc->onecell_data.num_domains; i++)\n\t\tpm_runtime_put(bc->domains[i].power_dev);\n\n\tpm_runtime_put(bc->bus_power_dev);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops imx8mp_blk_ctrl_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(imx8mp_blk_ctrl_suspend,\n\t\t\t\timx8mp_blk_ctrl_resume)\n};\n\nstatic const struct of_device_id imx8mp_blk_ctrl_of_match[] = {\n\t{\n\t\t.compatible = \"fsl,imx8mp-hsio-blk-ctrl\",\n\t\t.data = &imx8mp_hsio_blk_ctl_dev_data,\n\t}, {\n\t\t.compatible = \"fsl,imx8mp-hdmi-blk-ctrl\",\n\t\t.data = &imx8mp_hdmi_blk_ctl_dev_data,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, imx8mp_blk_ctrl_of_match);\n\nstatic struct platform_driver imx8mp_blk_ctrl_driver = {\n\t.probe = imx8mp_blk_ctrl_probe,\n\t.remove = imx8mp_blk_ctrl_remove,\n\t.driver = {\n\t\t.name = \"imx8mp-blk-ctrl\",\n\t\t.pm = &imx8mp_blk_ctrl_pm_ops,\n\t\t.of_match_table = imx8mp_blk_ctrl_of_match,\n\t},\n};\nmodule_platform_driver(imx8mp_blk_ctrl_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}