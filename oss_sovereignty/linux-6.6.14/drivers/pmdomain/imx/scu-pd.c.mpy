{
  "module_name": "scu-pd.c",
  "hash_id": "e647525950f906506744fa73225908a0c6ac43fc0503582f8e74430e366c2867",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/imx/scu-pd.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/firmware/imx/rsrc.h>\n#include <linux/console.h>\n#include <linux/firmware/imx/sci.h>\n#include <linux/firmware/imx/svc/rm.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_domain.h>\n#include <linux/slab.h>\n\n \nstruct imx_sc_msg_req_set_resource_power_mode {\n\tstruct imx_sc_rpc_msg hdr;\n\tu16 resource;\n\tu8 mode;\n} __packed __aligned(4);\n\nstruct req_get_resource_mode {\n\tu16 resource;\n};\n\nstruct resp_get_resource_mode {\n\tu8 mode;\n};\n\nstruct imx_sc_msg_req_get_resource_power_mode {\n\tstruct imx_sc_rpc_msg hdr;\n\tunion {\n\t\tstruct req_get_resource_mode req;\n\t\tstruct resp_get_resource_mode resp;\n\t} data;\n} __packed __aligned(4);\n\n#define IMX_SCU_PD_NAME_SIZE 20\nstruct imx_sc_pm_domain {\n\tstruct generic_pm_domain pd;\n\tchar name[IMX_SCU_PD_NAME_SIZE];\n\tu32 rsrc;\n};\n\nstruct imx_sc_pd_range {\n\tchar *name;\n\tu32 rsrc;\n\tu8 num;\n\n\t \n\tbool postfix;\n\tu8 start_from;\n};\n\nstruct imx_sc_pd_soc {\n\tconst struct imx_sc_pd_range *pd_ranges;\n\tu8 num_ranges;\n};\n\nstatic int imx_con_rsrc;\n\n \nstatic const char * const imx_sc_pm_mode[] = {\n\t\"IMX_SC_PM_PW_MODE_OFF\",\n\t\"IMX_SC_PM_PW_MODE_STBY\",\n\t\"IMX_SC_PM_PW_MODE_LP\",\n\t\"IMX_SC_PM_PW_MODE_ON\"\n};\n\nstatic const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {\n\t \n\t{ \"pwm\", IMX_SC_R_PWM_0, 8, true, 0 },\n\t{ \"gpio\", IMX_SC_R_GPIO_0, 8, true, 0 },\n\t{ \"gpt\", IMX_SC_R_GPT_0, 5, true, 0 },\n\t{ \"kpp\", IMX_SC_R_KPP, 1, false, 0 },\n\t{ \"fspi\", IMX_SC_R_FSPI_0, 2, true, 0 },\n\t{ \"mu_a\", IMX_SC_R_MU_0A, 14, true, 0 },\n\t{ \"mu_b\", IMX_SC_R_MU_5B, 9, true, 5 },\n\n\t \n\t{ \"usb\", IMX_SC_R_USB_0, 2, true, 0 },\n\t{ \"usb0phy\", IMX_SC_R_USB_0_PHY, 1, false, 0 },\n\t{ \"usb1phy\", IMX_SC_R_USB_1_PHY, 1, false, 0},\n\t{ \"usb2\", IMX_SC_R_USB_2, 1, false, 0 },\n\t{ \"usb2phy\", IMX_SC_R_USB_2_PHY, 1, false, 0 },\n\t{ \"sdhc\", IMX_SC_R_SDHC_0, 3, true, 0 },\n\t{ \"enet\", IMX_SC_R_ENET_0, 2, true, 0 },\n\t{ \"nand\", IMX_SC_R_NAND, 1, false, 0 },\n\t{ \"mlb\", IMX_SC_R_MLB_0, 1, true, 0 },\n\n\t \n\t{ \"audio-pll0\", IMX_SC_R_AUDIO_PLL_0, 1, false, 0 },\n\t{ \"audio-pll1\", IMX_SC_R_AUDIO_PLL_1, 1, false, 0 },\n\t{ \"audio-clk-0\", IMX_SC_R_AUDIO_CLK_0, 1, false, 0 },\n\t{ \"audio-clk-1\", IMX_SC_R_AUDIO_CLK_1, 1, false, 0 },\n\t{ \"mclk-out-0\", IMX_SC_R_MCLK_OUT_0, 1, false, 0 },\n\t{ \"mclk-out-1\", IMX_SC_R_MCLK_OUT_1, 1, false, 0 },\n\t{ \"dma0-ch\", IMX_SC_R_DMA_0_CH0, 32, true, 0 },\n\t{ \"dma1-ch\", IMX_SC_R_DMA_1_CH0, 16, true, 0 },\n\t{ \"dma2-ch-0\", IMX_SC_R_DMA_2_CH0, 5, true, 0 },\n\t{ \"dma2-ch-1\", IMX_SC_R_DMA_2_CH5, 27, true, 0 },\n\t{ \"dma3-ch\", IMX_SC_R_DMA_3_CH0, 32, true, 0 },\n\t{ \"asrc0\", IMX_SC_R_ASRC_0, 1, false, 0 },\n\t{ \"asrc1\", IMX_SC_R_ASRC_1, 1, false, 0 },\n\t{ \"esai0\", IMX_SC_R_ESAI_0, 1, false, 0 },\n\t{ \"esai1\", IMX_SC_R_ESAI_1, 1, false, 0 },\n\t{ \"spdif0\", IMX_SC_R_SPDIF_0, 1, false, 0 },\n\t{ \"spdif1\", IMX_SC_R_SPDIF_1, 1, false, 0 },\n\t{ \"sai\", IMX_SC_R_SAI_0, 3, true, 0 },\n\t{ \"sai3\", IMX_SC_R_SAI_3, 1, false, 0 },\n\t{ \"sai4\", IMX_SC_R_SAI_4, 1, false, 0 },\n\t{ \"sai5\", IMX_SC_R_SAI_5, 1, false, 0 },\n\t{ \"sai6\", IMX_SC_R_SAI_6, 1, false, 0 },\n\t{ \"sai7\", IMX_SC_R_SAI_7, 1, false, 0 },\n\t{ \"amix\", IMX_SC_R_AMIX, 1, false, 0 },\n\t{ \"mqs0\", IMX_SC_R_MQS_0, 1, false, 0 },\n\t{ \"dsp\", IMX_SC_R_DSP, 1, false, 0 },\n\t{ \"dsp-ram\", IMX_SC_R_DSP_RAM, 1, false, 0 },\n\n\t \n\t{ \"can\", IMX_SC_R_CAN_0, 3, true, 0 },\n\t{ \"ftm\", IMX_SC_R_FTM_0, 2, true, 0 },\n\t{ \"lpi2c\", IMX_SC_R_I2C_0, 5, true, 0 },\n\t{ \"adc\", IMX_SC_R_ADC_0, 2, true, 0 },\n\t{ \"lcd\", IMX_SC_R_LCD_0, 1, true, 0 },\n\t{ \"lcd-pll\", IMX_SC_R_ELCDIF_PLL, 1, true, 0 },\n\t{ \"lcd0-pwm\", IMX_SC_R_LCD_0_PWM_0, 1, true, 0 },\n\t{ \"lpuart\", IMX_SC_R_UART_0, 5, true, 0 },\n\t{ \"sim\", IMX_SC_R_EMVSIM_0, 2, true, 0 },\n\t{ \"lpspi\", IMX_SC_R_SPI_0, 4, true, 0 },\n\t{ \"irqstr_dsp\", IMX_SC_R_IRQSTR_DSP, 1, false, 0 },\n\n\t \n\t{ \"vpu\", IMX_SC_R_VPU, 1, false, 0 },\n\t{ \"vpu-pid\", IMX_SC_R_VPU_PID0, 8, true, 0 },\n\t{ \"vpu-dec0\", IMX_SC_R_VPU_DEC_0, 1, false, 0 },\n\t{ \"vpu-enc0\", IMX_SC_R_VPU_ENC_0, 1, false, 0 },\n\t{ \"vpu-enc1\", IMX_SC_R_VPU_ENC_1, 1, false, 0 },\n\t{ \"vpu-mu0\", IMX_SC_R_VPU_MU_0, 1, false, 0 },\n\t{ \"vpu-mu1\", IMX_SC_R_VPU_MU_1, 1, false, 0 },\n\t{ \"vpu-mu2\", IMX_SC_R_VPU_MU_2, 1, false, 0 },\n\n\t \n\t{ \"gpu0-pid\", IMX_SC_R_GPU_0_PID0, 4, true, 0 },\n\t{ \"gpu1-pid\", IMX_SC_R_GPU_1_PID0, 4, true, 0 },\n\n\n\t \n\t{ \"pcie-a\", IMX_SC_R_PCIE_A, 1, false, 0 },\n\t{ \"serdes-0\", IMX_SC_R_SERDES_0, 1, false, 0 },\n\t{ \"pcie-b\", IMX_SC_R_PCIE_B, 1, false, 0 },\n\t{ \"serdes-1\", IMX_SC_R_SERDES_1, 1, false, 0 },\n\t{ \"sata-0\", IMX_SC_R_SATA_0, 1, false, 0 },\n\t{ \"hsio-gpio\", IMX_SC_R_HSIO_GPIO, 1, false, 0 },\n\n\t \n\t{ \"mipi0\", IMX_SC_R_MIPI_0, 1, false, 0 },\n\t{ \"mipi0-pwm0\", IMX_SC_R_MIPI_0_PWM_0, 1, false, 0 },\n\t{ \"mipi0-i2c\", IMX_SC_R_MIPI_0_I2C_0, 2, true, 0 },\n\n\t{ \"mipi1\", IMX_SC_R_MIPI_1, 1, false, 0 },\n\t{ \"mipi1-pwm0\", IMX_SC_R_MIPI_1_PWM_0, 1, false, 0 },\n\t{ \"mipi1-i2c\", IMX_SC_R_MIPI_1_I2C_0, 2, true, 0 },\n\n\t \n\t{ \"lvds0\", IMX_SC_R_LVDS_0, 1, false, 0 },\n\t{ \"lvds0-pwm\", IMX_SC_R_LVDS_0_PWM_0, 1, false, 0 },\n\t{ \"lvds0-lpi2c\", IMX_SC_R_LVDS_0_I2C_0, 2, true, 0 },\n\t{ \"lvds1\", IMX_SC_R_LVDS_1, 1, false, 0 },\n\t{ \"lvds1-pwm\", IMX_SC_R_LVDS_1_PWM_0, 1, false, 0 },\n\t{ \"lvds1-lpi2c\", IMX_SC_R_LVDS_1_I2C_0, 2, true, 0 },\n\n\t{ \"mipi1\", IMX_SC_R_MIPI_1, 1, 0 },\n\t{ \"mipi1-pwm0\", IMX_SC_R_MIPI_1_PWM_0, 1, 0 },\n\t{ \"mipi1-i2c\", IMX_SC_R_MIPI_1_I2C_0, 2, 1 },\n\t{ \"lvds1\", IMX_SC_R_LVDS_1, 1, 0 },\n\n\t \n\t{ \"dc0\", IMX_SC_R_DC_0, 1, false, 0 },\n\t{ \"dc0-pll\", IMX_SC_R_DC_0_PLL_0, 2, true, 0 },\n\t{ \"dc0-video\", IMX_SC_R_DC_0_VIDEO0, 2, true, 0 },\n\n\t{ \"dc1\", IMX_SC_R_DC_1, 1, false, 0 },\n\t{ \"dc1-pll\", IMX_SC_R_DC_1_PLL_0, 2, true, 0 },\n\t{ \"dc1-video\", IMX_SC_R_DC_1_VIDEO0, 2, true, 0 },\n\n\t \n\t{ \"cm40-i2c\", IMX_SC_R_M4_0_I2C, 1, false, 0 },\n\t{ \"cm40-intmux\", IMX_SC_R_M4_0_INTMUX, 1, false, 0 },\n\t{ \"cm40-pid\", IMX_SC_R_M4_0_PID0, 5, true, 0},\n\t{ \"cm40-mu-a1\", IMX_SC_R_M4_0_MU_1A, 1, false, 0},\n\t{ \"cm40-lpuart\", IMX_SC_R_M4_0_UART, 1, false, 0},\n\n\t \n\t{ \"cm41-i2c\", IMX_SC_R_M4_1_I2C, 1, false, 0 },\n\t{ \"cm41-intmux\", IMX_SC_R_M4_1_INTMUX, 1, false, 0 },\n\t{ \"cm41-pid\", IMX_SC_R_M4_1_PID0, 5, true, 0},\n\t{ \"cm41-mu-a1\", IMX_SC_R_M4_1_MU_1A, 1, false, 0},\n\t{ \"cm41-lpuart\", IMX_SC_R_M4_1_UART, 1, false, 0},\n\n\t \n\t{ \"cm41_i2c\", IMX_SC_R_M4_1_I2C, 1, false, 0 },\n\t{ \"cm41_intmux\", IMX_SC_R_M4_1_INTMUX, 1, false, 0 },\n\n\t \n\t{ \"perf\", IMX_SC_R_PERF, 1, false, 0},\n\n\t \n\t{ \"img-jpegdec-mp\", IMX_SC_R_MJPEG_DEC_MP, 1, false, 0 },\n\t{ \"img-jpegdec-s0\", IMX_SC_R_MJPEG_DEC_S0, 4, true, 0 },\n\t{ \"img-jpegenc-mp\", IMX_SC_R_MJPEG_ENC_MP, 1, false, 0 },\n\t{ \"img-jpegenc-s0\", IMX_SC_R_MJPEG_ENC_S0, 4, true, 0 },\n\n\t \n\t{ \"seco_mu\", IMX_SC_R_SECO_MU_2, 3, true, 2},\n\n\t \n\t{ \"v2x_mu\", IMX_SC_R_V2X_MU_0, 2, true, 0},\n\t{ \"v2x_mu\", IMX_SC_R_V2X_MU_2, 1, true, 2},\n\t{ \"v2x_mu\", IMX_SC_R_V2X_MU_3, 2, true, 3},\n\t{ \"img-pdma\", IMX_SC_R_ISI_CH0, 8, true, 0 },\n\t{ \"img-csi0\", IMX_SC_R_CSI_0, 1, false, 0 },\n\t{ \"img-csi0-i2c0\", IMX_SC_R_CSI_0_I2C_0, 1, false, 0 },\n\t{ \"img-csi0-pwm0\", IMX_SC_R_CSI_0_PWM_0, 1, false, 0 },\n\t{ \"img-csi1\", IMX_SC_R_CSI_1, 1, false, 0 },\n\t{ \"img-csi1-i2c0\", IMX_SC_R_CSI_1_I2C_0, 1, false, 0 },\n\t{ \"img-csi1-pwm0\", IMX_SC_R_CSI_1_PWM_0, 1, false, 0 },\n\t{ \"img-parallel\", IMX_SC_R_PI_0, 1, false, 0 },\n\t{ \"img-parallel-i2c0\", IMX_SC_R_PI_0_I2C_0, 1, false, 0 },\n\t{ \"img-parallel-pwm0\", IMX_SC_R_PI_0_PWM_0, 2, true, 0 },\n\t{ \"img-parallel-pll\", IMX_SC_R_PI_0_PLL, 1, false, 0 },\n\n\t \n\t{ \"hdmi-tx\", IMX_SC_R_HDMI, 1, false, 0},\n\t{ \"hdmi-tx-i2s\", IMX_SC_R_HDMI_I2S, 1, false, 0},\n\t{ \"hdmi-tx-i2c0\", IMX_SC_R_HDMI_I2C_0, 1, false, 0},\n\t{ \"hdmi-tx-pll0\", IMX_SC_R_HDMI_PLL_0, 1, false, 0},\n\t{ \"hdmi-tx-pll1\", IMX_SC_R_HDMI_PLL_1, 1, false, 0},\n\n\t \n\t{ \"hdmi-rx\", IMX_SC_R_HDMI_RX, 1, false, 0},\n\t{ \"hdmi-rx-pwm\", IMX_SC_R_HDMI_RX_PWM_0, 1, false, 0},\n\t{ \"hdmi-rx-i2c0\", IMX_SC_R_HDMI_RX_I2C_0, 1, false, 0},\n\t{ \"hdmi-rx-bypass\", IMX_SC_R_HDMI_RX_BYPASS, 1, false, 0},\n\n\t \n\t{ \"sec-jr\", IMX_SC_R_CAAM_JR2, 2, true, 2},\n\n\t \n\t{ \"board\", IMX_SC_R_BOARD_R0, 8, true, 0},\n};\n\nstatic const struct imx_sc_pd_soc imx8qxp_scu_pd = {\n\t.pd_ranges = imx8qxp_scu_pd_ranges,\n\t.num_ranges = ARRAY_SIZE(imx8qxp_scu_pd_ranges),\n};\n\nstatic struct imx_sc_ipc *pm_ipc_handle;\n\nstatic inline struct imx_sc_pm_domain *\nto_imx_sc_pd(struct generic_pm_domain *genpd)\n{\n\treturn container_of(genpd, struct imx_sc_pm_domain, pd);\n}\n\nstatic void imx_sc_pd_get_console_rsrc(void)\n{\n\tstruct of_phandle_args specs;\n\tint ret;\n\n\tif (!of_stdout)\n\t\treturn;\n\n\tret = of_parse_phandle_with_args(of_stdout, \"power-domains\",\n\t\t\t\t\t \"#power-domain-cells\",\n\t\t\t\t\t 0, &specs);\n\tif (ret)\n\t\treturn;\n\n\timx_con_rsrc = specs.args[0];\n}\n\nstatic int imx_sc_get_pd_power(struct device *dev, u32 rsrc)\n{\n\tstruct imx_sc_msg_req_get_resource_power_mode msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tint ret;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_PM;\n\thdr->func = IMX_SC_PM_FUNC_GET_RESOURCE_POWER_MODE;\n\thdr->size = 2;\n\n\tmsg.data.req.resource = rsrc;\n\n\tret = imx_scu_call_rpc(pm_ipc_handle, &msg, true);\n\tif (ret)\n\t\tdev_err(dev, \"failed to get power resource %d mode, ret %d\\n\",\n\t\t\trsrc, ret);\n\n\treturn msg.data.resp.mode;\n}\n\nstatic int imx_sc_pd_power(struct generic_pm_domain *domain, bool power_on)\n{\n\tstruct imx_sc_msg_req_set_resource_power_mode msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tstruct imx_sc_pm_domain *pd;\n\tint ret;\n\n\tpd = to_imx_sc_pd(domain);\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_PM;\n\thdr->func = IMX_SC_PM_FUNC_SET_RESOURCE_POWER_MODE;\n\thdr->size = 2;\n\n\tmsg.resource = pd->rsrc;\n\tmsg.mode = power_on ? IMX_SC_PM_PW_MODE_ON : IMX_SC_PM_PW_MODE_LP;\n\n\t \n\tif (imx_con_rsrc == pd->rsrc && !console_suspend_enabled && !power_on)\n\t\treturn -EBUSY;\n\n\tret = imx_scu_call_rpc(pm_ipc_handle, &msg, true);\n\tif (ret)\n\t\tdev_err(&domain->dev, \"failed to power %s resource %d ret %d\\n\",\n\t\t\tpower_on ? \"up\" : \"off\", pd->rsrc, ret);\n\n\treturn ret;\n}\n\nstatic int imx_sc_pd_power_on(struct generic_pm_domain *domain)\n{\n\treturn imx_sc_pd_power(domain, true);\n}\n\nstatic int imx_sc_pd_power_off(struct generic_pm_domain *domain)\n{\n\treturn imx_sc_pd_power(domain, false);\n}\n\nstatic struct generic_pm_domain *imx_scu_pd_xlate(struct of_phandle_args *spec,\n\t\t\t\t\t\t  void *data)\n{\n\tstruct generic_pm_domain *domain = ERR_PTR(-ENOENT);\n\tstruct genpd_onecell_data *pd_data = data;\n\tunsigned int i;\n\n\tfor (i = 0; i < pd_data->num_domains; i++) {\n\t\tstruct imx_sc_pm_domain *sc_pd;\n\n\t\tsc_pd = to_imx_sc_pd(pd_data->domains[i]);\n\t\tif (sc_pd->rsrc == spec->args[0]) {\n\t\t\tdomain = &sc_pd->pd;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn domain;\n}\n\nstatic struct imx_sc_pm_domain *\nimx_scu_add_pm_domain(struct device *dev, int idx,\n\t\t      const struct imx_sc_pd_range *pd_ranges)\n{\n\tstruct imx_sc_pm_domain *sc_pd;\n\tbool is_off;\n\tint mode, ret;\n\n\tif (!imx_sc_rm_is_resource_owned(pm_ipc_handle, pd_ranges->rsrc + idx))\n\t\treturn NULL;\n\n\tsc_pd = devm_kzalloc(dev, sizeof(*sc_pd), GFP_KERNEL);\n\tif (!sc_pd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsc_pd->rsrc = pd_ranges->rsrc + idx;\n\tsc_pd->pd.power_off = imx_sc_pd_power_off;\n\tsc_pd->pd.power_on = imx_sc_pd_power_on;\n\n\tif (pd_ranges->postfix)\n\t\tsnprintf(sc_pd->name, sizeof(sc_pd->name),\n\t\t\t \"%s%i\", pd_ranges->name, pd_ranges->start_from + idx);\n\telse\n\t\tsnprintf(sc_pd->name, sizeof(sc_pd->name),\n\t\t\t \"%s\", pd_ranges->name);\n\n\tsc_pd->pd.name = sc_pd->name;\n\tif (imx_con_rsrc == sc_pd->rsrc)\n\t\tsc_pd->pd.flags = GENPD_FLAG_RPM_ALWAYS_ON;\n\n\tmode = imx_sc_get_pd_power(dev, pd_ranges->rsrc + idx);\n\tif (mode == IMX_SC_PM_PW_MODE_ON)\n\t\tis_off = false;\n\telse\n\t\tis_off = true;\n\n\tdev_dbg(dev, \"%s : %s\\n\", sc_pd->name, imx_sc_pm_mode[mode]);\n\n\tif (sc_pd->rsrc >= IMX_SC_R_LAST) {\n\t\tdev_warn(dev, \"invalid pd %s rsrc id %d found\",\n\t\t\t sc_pd->name, sc_pd->rsrc);\n\n\t\tdevm_kfree(dev, sc_pd);\n\t\treturn NULL;\n\t}\n\n\tret = pm_genpd_init(&sc_pd->pd, NULL, is_off);\n\tif (ret) {\n\t\tdev_warn(dev, \"failed to init pd %s rsrc id %d\",\n\t\t\t sc_pd->name, sc_pd->rsrc);\n\t\tdevm_kfree(dev, sc_pd);\n\t\treturn NULL;\n\t}\n\n\treturn sc_pd;\n}\n\nstatic int imx_scu_init_pm_domains(struct device *dev,\n\t\t\t\t    const struct imx_sc_pd_soc *pd_soc)\n{\n\tconst struct imx_sc_pd_range *pd_ranges = pd_soc->pd_ranges;\n\tstruct generic_pm_domain **domains;\n\tstruct genpd_onecell_data *pd_data;\n\tstruct imx_sc_pm_domain *sc_pd;\n\tu32 count = 0;\n\tint i, j;\n\n\tfor (i = 0; i < pd_soc->num_ranges; i++)\n\t\tcount += pd_ranges[i].num;\n\n\tdomains = devm_kcalloc(dev, count, sizeof(*domains), GFP_KERNEL);\n\tif (!domains)\n\t\treturn -ENOMEM;\n\n\tpd_data = devm_kzalloc(dev, sizeof(*pd_data), GFP_KERNEL);\n\tif (!pd_data)\n\t\treturn -ENOMEM;\n\n\tcount = 0;\n\tfor (i = 0; i < pd_soc->num_ranges; i++) {\n\t\tfor (j = 0; j < pd_ranges[i].num; j++) {\n\t\t\tsc_pd = imx_scu_add_pm_domain(dev, j, &pd_ranges[i]);\n\t\t\tif (IS_ERR_OR_NULL(sc_pd))\n\t\t\t\tcontinue;\n\n\t\t\tdomains[count++] = &sc_pd->pd;\n\t\t\tdev_dbg(dev, \"added power domain %s\\n\", sc_pd->pd.name);\n\t\t}\n\t}\n\n\tpd_data->domains = domains;\n\tpd_data->num_domains = count;\n\tpd_data->xlate = imx_scu_pd_xlate;\n\n\tof_genpd_add_provider_onecell(dev->of_node, pd_data);\n\n\treturn 0;\n}\n\nstatic int imx_sc_pd_probe(struct platform_device *pdev)\n{\n\tconst struct imx_sc_pd_soc *pd_soc;\n\tint ret;\n\n\tret = imx_scu_get_handle(&pm_ipc_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tpd_soc = of_device_get_match_data(&pdev->dev);\n\tif (!pd_soc)\n\t\treturn -ENODEV;\n\n\timx_sc_pd_get_console_rsrc();\n\n\treturn imx_scu_init_pm_domains(&pdev->dev, pd_soc);\n}\n\nstatic const struct of_device_id imx_sc_pd_match[] = {\n\t{ .compatible = \"fsl,imx8qxp-scu-pd\", &imx8qxp_scu_pd},\n\t{ .compatible = \"fsl,scu-pd\", &imx8qxp_scu_pd},\n\t{   }\n};\n\nstatic struct platform_driver imx_sc_pd_driver = {\n\t.driver = {\n\t\t.name = \"imx-scu-pd\",\n\t\t.of_match_table = imx_sc_pd_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = imx_sc_pd_probe,\n};\nbuiltin_platform_driver(imx_sc_pd_driver);\n\nMODULE_AUTHOR(\"Dong Aisheng <aisheng.dong@nxp.com>\");\nMODULE_DESCRIPTION(\"IMX SCU Power Domain driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}