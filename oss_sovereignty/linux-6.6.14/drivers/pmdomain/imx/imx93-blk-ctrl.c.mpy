{
  "module_name": "imx93-blk-ctrl.c",
  "hash_id": "5d8cd9a24e6bbe16a02c37b3fa5d0a2d1e30975d7e44b04d97101c43ee0c7361",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/imx/imx93-blk-ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/sizes.h>\n\n#include <dt-bindings/power/fsl,imx93-power.h>\n\n#define BLK_SFT_RSTN\t0x0\n#define BLK_CLK_EN\t0x4\n#define BLK_MAX_CLKS\t4\n\n#define DOMAIN_MAX_CLKS 4\n\n#define LCDIF_QOS_REG\t\t0xC\n#define LCDIF_DEFAULT_QOS_OFF\t12\n#define LCDIF_CFG_QOS_OFF\t8\n\n#define PXP_QOS_REG\t\t0x10\n#define PXP_R_DEFAULT_QOS_OFF\t28\n#define PXP_R_CFG_QOS_OFF\t24\n#define PXP_W_DEFAULT_QOS_OFF\t20\n#define PXP_W_CFG_QOS_OFF\t16\n\n#define ISI_CACHE_REG\t\t0x14\n\n#define ISI_QOS_REG\t\t0x1C\n#define ISI_V_DEFAULT_QOS_OFF\t28\n#define ISI_V_CFG_QOS_OFF\t24\n#define ISI_U_DEFAULT_QOS_OFF\t20\n#define ISI_U_CFG_QOS_OFF\t16\n#define ISI_Y_R_DEFAULT_QOS_OFF\t12\n#define ISI_Y_R_CFG_QOS_OFF\t8\n#define ISI_Y_W_DEFAULT_QOS_OFF\t4\n#define ISI_Y_W_CFG_QOS_OFF\t0\n\n#define PRIO_MASK\t\t0xF\n\n#define PRIO(X)\t\t\t(X)\n\nstruct imx93_blk_ctrl_domain;\n\nstruct imx93_blk_ctrl {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tint num_clks;\n\tstruct clk_bulk_data clks[BLK_MAX_CLKS];\n\tstruct imx93_blk_ctrl_domain *domains;\n\tstruct genpd_onecell_data onecell_data;\n};\n\n#define DOMAIN_MAX_QOS 4\n\nstruct imx93_blk_ctrl_qos {\n\tu32 reg;\n\tu32 cfg_off;\n\tu32 default_prio;\n\tu32 cfg_prio;\n};\n\nstruct imx93_blk_ctrl_domain_data {\n\tconst char *name;\n\tconst char * const *clk_names;\n\tint num_clks;\n\tu32 rst_mask;\n\tu32 clk_mask;\n\tint num_qos;\n\tstruct imx93_blk_ctrl_qos qos[DOMAIN_MAX_QOS];\n};\n\nstruct imx93_blk_ctrl_domain {\n\tstruct generic_pm_domain genpd;\n\tconst struct imx93_blk_ctrl_domain_data *data;\n\tstruct clk_bulk_data clks[DOMAIN_MAX_CLKS];\n\tstruct imx93_blk_ctrl *bc;\n};\n\nstruct imx93_blk_ctrl_data {\n\tconst struct imx93_blk_ctrl_domain_data *domains;\n\tint num_domains;\n\tconst char * const *clk_names;\n\tint num_clks;\n\tconst struct regmap_access_table *reg_access_table;\n};\n\nstatic inline struct imx93_blk_ctrl_domain *\nto_imx93_blk_ctrl_domain(struct generic_pm_domain *genpd)\n{\n\treturn container_of(genpd, struct imx93_blk_ctrl_domain, genpd);\n}\n\nstatic int imx93_blk_ctrl_set_qos(struct imx93_blk_ctrl_domain *domain)\n{\n\tconst struct imx93_blk_ctrl_domain_data *data = domain->data;\n\tstruct imx93_blk_ctrl *bc = domain->bc;\n\tconst struct imx93_blk_ctrl_qos *qos;\n\tu32 val, mask;\n\tint i;\n\n\tfor (i = 0; i < data->num_qos; i++) {\n\t\tqos = &data->qos[i];\n\n\t\tmask = PRIO_MASK << qos->cfg_off;\n\t\tmask |= PRIO_MASK << (qos->cfg_off + 4);\n\t\tval = qos->cfg_prio << qos->cfg_off;\n\t\tval |= qos->default_prio << (qos->cfg_off + 4);\n\n\t\tregmap_write_bits(bc->regmap, qos->reg, mask, val);\n\n\t\tdev_dbg(bc->dev, \"data->qos[i].reg 0x%x 0x%x\\n\", qos->reg, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int imx93_blk_ctrl_power_on(struct generic_pm_domain *genpd)\n{\n\tstruct imx93_blk_ctrl_domain *domain = to_imx93_blk_ctrl_domain(genpd);\n\tconst struct imx93_blk_ctrl_domain_data *data = domain->data;\n\tstruct imx93_blk_ctrl *bc = domain->bc;\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(bc->num_clks, bc->clks);\n\tif (ret) {\n\t\tdev_err(bc->dev, \"failed to enable bus clocks\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_bulk_prepare_enable(data->num_clks, domain->clks);\n\tif (ret) {\n\t\tclk_bulk_disable_unprepare(bc->num_clks, bc->clks);\n\t\tdev_err(bc->dev, \"failed to enable clocks\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pm_runtime_get_sync(bc->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(bc->dev);\n\t\tdev_err(bc->dev, \"failed to power up domain\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\t \n\tregmap_clear_bits(bc->regmap, BLK_CLK_EN, data->clk_mask);\n\n\t \n\tregmap_set_bits(bc->regmap, BLK_SFT_RSTN, data->rst_mask);\n\n\tdev_dbg(bc->dev, \"pd_on: name: %s\\n\", genpd->name);\n\n\treturn imx93_blk_ctrl_set_qos(domain);\n\ndisable_clk:\n\tclk_bulk_disable_unprepare(data->num_clks, domain->clks);\n\n\tclk_bulk_disable_unprepare(bc->num_clks, bc->clks);\n\n\treturn ret;\n}\n\nstatic int imx93_blk_ctrl_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct imx93_blk_ctrl_domain *domain = to_imx93_blk_ctrl_domain(genpd);\n\tconst struct imx93_blk_ctrl_domain_data *data = domain->data;\n\tstruct imx93_blk_ctrl *bc = domain->bc;\n\n\tdev_dbg(bc->dev, \"pd_off: name: %s\\n\", genpd->name);\n\n\tregmap_clear_bits(bc->regmap, BLK_SFT_RSTN, data->rst_mask);\n\tregmap_set_bits(bc->regmap, BLK_CLK_EN, data->clk_mask);\n\n\tpm_runtime_put(bc->dev);\n\n\tclk_bulk_disable_unprepare(data->num_clks, domain->clks);\n\n\tclk_bulk_disable_unprepare(bc->num_clks, bc->clks);\n\n\treturn 0;\n}\n\nstatic struct lock_class_key blk_ctrl_genpd_lock_class;\n\nstatic int imx93_blk_ctrl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct imx93_blk_ctrl_data *bc_data = of_device_get_match_data(dev);\n\tstruct imx93_blk_ctrl *bc;\n\tvoid __iomem *base;\n\tint i, ret;\n\n\tstruct regmap_config regmap_config = {\n\t\t.reg_bits\t= 32,\n\t\t.val_bits\t= 32,\n\t\t.reg_stride\t= 4,\n\t\t.rd_table\t= bc_data->reg_access_table,\n\t\t.wr_table\t= bc_data->reg_access_table,\n\t\t.max_register   = SZ_4K,\n\t};\n\n\tbc = devm_kzalloc(dev, sizeof(*bc), GFP_KERNEL);\n\tif (!bc)\n\t\treturn -ENOMEM;\n\n\tbc->dev = dev;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tbc->regmap = devm_regmap_init_mmio(dev, base, &regmap_config);\n\tif (IS_ERR(bc->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(bc->regmap),\n\t\t\t\t     \"failed to init regmap\\n\");\n\n\tbc->domains = devm_kcalloc(dev, bc_data->num_domains,\n\t\t\t\t   sizeof(struct imx93_blk_ctrl_domain),\n\t\t\t\t   GFP_KERNEL);\n\tif (!bc->domains)\n\t\treturn -ENOMEM;\n\n\tbc->onecell_data.num_domains = bc_data->num_domains;\n\tbc->onecell_data.domains =\n\t\tdevm_kcalloc(dev, bc_data->num_domains,\n\t\t\t     sizeof(struct generic_pm_domain *), GFP_KERNEL);\n\tif (!bc->onecell_data.domains)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < bc_data->num_clks; i++)\n\t\tbc->clks[i].id = bc_data->clk_names[i];\n\tbc->num_clks = bc_data->num_clks;\n\n\tret = devm_clk_bulk_get(dev, bc->num_clks, bc->clks);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to get bus clock\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < bc_data->num_domains; i++) {\n\t\tconst struct imx93_blk_ctrl_domain_data *data = &bc_data->domains[i];\n\t\tstruct imx93_blk_ctrl_domain *domain = &bc->domains[i];\n\t\tint j;\n\n\t\tdomain->data = data;\n\n\t\tfor (j = 0; j < data->num_clks; j++)\n\t\t\tdomain->clks[j].id = data->clk_names[j];\n\n\t\tret = devm_clk_bulk_get(dev, data->num_clks, domain->clks);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"failed to get clock\\n\");\n\t\t\tgoto cleanup_pds;\n\t\t}\n\n\t\tdomain->genpd.name = data->name;\n\t\tdomain->genpd.power_on = imx93_blk_ctrl_power_on;\n\t\tdomain->genpd.power_off = imx93_blk_ctrl_power_off;\n\t\tdomain->bc = bc;\n\n\t\tret = pm_genpd_init(&domain->genpd, NULL, true);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"failed to init power domain\\n\");\n\t\t\tgoto cleanup_pds;\n\t\t}\n\n\t\t \n\t\tlockdep_set_class(&domain->genpd.mlock,\n\t\t\t\t  &blk_ctrl_genpd_lock_class);\n\n\t\tbc->onecell_data.domains[i] = &domain->genpd;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\tret = of_genpd_add_provider_onecell(dev->of_node, &bc->onecell_data);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to add power domain provider\\n\");\n\t\tgoto cleanup_pds;\n\t}\n\n\tdev_set_drvdata(dev, bc);\n\n\treturn 0;\n\ncleanup_pds:\n\tfor (i--; i >= 0; i--)\n\t\tpm_genpd_remove(&bc->domains[i].genpd);\n\n\treturn ret;\n}\n\nstatic int imx93_blk_ctrl_remove(struct platform_device *pdev)\n{\n\tstruct imx93_blk_ctrl *bc = dev_get_drvdata(&pdev->dev);\n\tint i;\n\n\tof_genpd_del_provider(pdev->dev.of_node);\n\n\tfor (i = 0; bc->onecell_data.num_domains; i++) {\n\t\tstruct imx93_blk_ctrl_domain *domain = &bc->domains[i];\n\n\t\tpm_genpd_remove(&domain->genpd);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct imx93_blk_ctrl_domain_data imx93_media_blk_ctl_domain_data[] = {\n\t[IMX93_MEDIABLK_PD_MIPI_DSI] = {\n\t\t.name = \"mediablk-mipi-dsi\",\n\t\t.clk_names = (const char *[]){ \"dsi\" },\n\t\t.num_clks = 1,\n\t\t.rst_mask = BIT(11) | BIT(12),\n\t\t.clk_mask = BIT(11) | BIT(12),\n\t},\n\t[IMX93_MEDIABLK_PD_MIPI_CSI] = {\n\t\t.name = \"mediablk-mipi-csi\",\n\t\t.clk_names = (const char *[]){ \"cam\", \"csi\" },\n\t\t.num_clks = 2,\n\t\t.rst_mask = BIT(9) | BIT(10),\n\t\t.clk_mask = BIT(9) | BIT(10),\n\t},\n\t[IMX93_MEDIABLK_PD_PXP] = {\n\t\t.name = \"mediablk-pxp\",\n\t\t.clk_names = (const char *[]){ \"pxp\" },\n\t\t.num_clks = 1,\n\t\t.rst_mask = BIT(7) | BIT(8),\n\t\t.clk_mask = BIT(7) | BIT(8),\n\t\t.num_qos = 2,\n\t\t.qos = {\n\t\t\t{\n\t\t\t\t.reg = PXP_QOS_REG,\n\t\t\t\t.cfg_off = PXP_R_CFG_QOS_OFF,\n\t\t\t\t.default_prio = PRIO(3),\n\t\t\t\t.cfg_prio = PRIO(6),\n\t\t\t}, {\n\t\t\t\t.reg = PXP_QOS_REG,\n\t\t\t\t.cfg_off = PXP_W_CFG_QOS_OFF,\n\t\t\t\t.default_prio = PRIO(3),\n\t\t\t\t.cfg_prio = PRIO(6),\n\t\t\t}\n\t\t}\n\t},\n\t[IMX93_MEDIABLK_PD_LCDIF] = {\n\t\t.name = \"mediablk-lcdif\",\n\t\t.clk_names = (const char *[]){ \"disp\", \"lcdif\" },\n\t\t.num_clks = 2,\n\t\t.rst_mask = BIT(4) | BIT(5) | BIT(6),\n\t\t.clk_mask = BIT(4) | BIT(5) | BIT(6),\n\t\t.num_qos = 1,\n\t\t.qos = {\n\t\t\t{\n\t\t\t.reg = LCDIF_QOS_REG,\n\t\t\t.cfg_off = LCDIF_CFG_QOS_OFF,\n\t\t\t.default_prio = PRIO(3),\n\t\t\t.cfg_prio = PRIO(7),\n\t\t\t}\n\t\t}\n\t},\n\t[IMX93_MEDIABLK_PD_ISI] = {\n\t\t.name = \"mediablk-isi\",\n\t\t.clk_names = (const char *[]){ \"isi\" },\n\t\t.num_clks = 1,\n\t\t.rst_mask = BIT(2) | BIT(3),\n\t\t.clk_mask = BIT(2) | BIT(3),\n\t\t.num_qos = 4,\n\t\t.qos = {\n\t\t\t{\n\t\t\t\t.reg = ISI_QOS_REG,\n\t\t\t\t.cfg_off = ISI_Y_W_CFG_QOS_OFF,\n\t\t\t\t.default_prio = PRIO(3),\n\t\t\t\t.cfg_prio = PRIO(7),\n\t\t\t}, {\n\t\t\t\t.reg = ISI_QOS_REG,\n\t\t\t\t.cfg_off = ISI_Y_R_CFG_QOS_OFF,\n\t\t\t\t.default_prio = PRIO(3),\n\t\t\t\t.cfg_prio = PRIO(7),\n\t\t\t}, {\n\t\t\t\t.reg = ISI_QOS_REG,\n\t\t\t\t.cfg_off = ISI_U_CFG_QOS_OFF,\n\t\t\t\t.default_prio = PRIO(3),\n\t\t\t\t.cfg_prio = PRIO(7),\n\t\t\t}, {\n\t\t\t\t.reg = ISI_QOS_REG,\n\t\t\t\t.cfg_off = ISI_V_CFG_QOS_OFF,\n\t\t\t\t.default_prio = PRIO(3),\n\t\t\t\t.cfg_prio = PRIO(7),\n\t\t\t}\n\t\t}\n\t},\n};\n\nstatic const struct regmap_range imx93_media_blk_ctl_yes_ranges[] = {\n\tregmap_reg_range(BLK_SFT_RSTN, BLK_CLK_EN),\n\tregmap_reg_range(LCDIF_QOS_REG, ISI_CACHE_REG),\n\tregmap_reg_range(ISI_QOS_REG, ISI_QOS_REG),\n};\n\nstatic const struct regmap_access_table imx93_media_blk_ctl_access_table = {\n\t.yes_ranges = imx93_media_blk_ctl_yes_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(imx93_media_blk_ctl_yes_ranges),\n};\n\nstatic const struct imx93_blk_ctrl_data imx93_media_blk_ctl_dev_data = {\n\t.domains = imx93_media_blk_ctl_domain_data,\n\t.num_domains = ARRAY_SIZE(imx93_media_blk_ctl_domain_data),\n\t.clk_names = (const char *[]){ \"axi\", \"apb\", \"nic\", },\n\t.num_clks = 3,\n\t.reg_access_table = &imx93_media_blk_ctl_access_table,\n};\n\nstatic const struct of_device_id imx93_blk_ctrl_of_match[] = {\n\t{\n\t\t.compatible = \"fsl,imx93-media-blk-ctrl\",\n\t\t.data = &imx93_media_blk_ctl_dev_data\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, imx93_blk_ctrl_of_match);\n\nstatic struct platform_driver imx93_blk_ctrl_driver = {\n\t.probe = imx93_blk_ctrl_probe,\n\t.remove = imx93_blk_ctrl_remove,\n\t.driver = {\n\t\t.name = \"imx93-blk-ctrl\",\n\t\t.of_match_table = imx93_blk_ctrl_of_match,\n\t},\n};\nmodule_platform_driver(imx93_blk_ctrl_driver);\n\nMODULE_AUTHOR(\"Peng Fan <peng.fan@nxp.com>\");\nMODULE_DESCRIPTION(\"i.MX93 BLK CTRL driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}