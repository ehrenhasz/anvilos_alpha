{
  "module_name": "gpcv2.c",
  "hash_id": "19e5906a9b0893e5207c3b815830b6323eaa7661bb6d8c8fcea9a65a30dba359",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/imx/gpcv2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/sizes.h>\n#include <dt-bindings/power/imx7-power.h>\n#include <dt-bindings/power/imx8mq-power.h>\n#include <dt-bindings/power/imx8mm-power.h>\n#include <dt-bindings/power/imx8mn-power.h>\n#include <dt-bindings/power/imx8mp-power.h>\n\n#define GPC_LPCR_A_CORE_BSC\t\t\t0x000\n\n#define GPC_PGC_CPU_MAPPING\t\t0x0ec\n#define IMX8MP_GPC_PGC_CPU_MAPPING\t0x1cc\n\n#define IMX7_USB_HSIC_PHY_A_CORE_DOMAIN\t\tBIT(6)\n#define IMX7_USB_OTG2_PHY_A_CORE_DOMAIN\t\tBIT(5)\n#define IMX7_USB_OTG1_PHY_A_CORE_DOMAIN\t\tBIT(4)\n#define IMX7_PCIE_PHY_A_CORE_DOMAIN\t\tBIT(3)\n#define IMX7_MIPI_PHY_A_CORE_DOMAIN\t\tBIT(2)\n\n#define IMX8M_PCIE2_A53_DOMAIN\t\t\tBIT(15)\n#define IMX8M_MIPI_CSI2_A53_DOMAIN\t\tBIT(14)\n#define IMX8M_MIPI_CSI1_A53_DOMAIN\t\tBIT(13)\n#define IMX8M_DISP_A53_DOMAIN\t\t\tBIT(12)\n#define IMX8M_HDMI_A53_DOMAIN\t\t\tBIT(11)\n#define IMX8M_VPU_A53_DOMAIN\t\t\tBIT(10)\n#define IMX8M_GPU_A53_DOMAIN\t\t\tBIT(9)\n#define IMX8M_DDR2_A53_DOMAIN\t\t\tBIT(8)\n#define IMX8M_DDR1_A53_DOMAIN\t\t\tBIT(7)\n#define IMX8M_OTG2_A53_DOMAIN\t\t\tBIT(5)\n#define IMX8M_OTG1_A53_DOMAIN\t\t\tBIT(4)\n#define IMX8M_PCIE1_A53_DOMAIN\t\t\tBIT(3)\n#define IMX8M_MIPI_A53_DOMAIN\t\t\tBIT(2)\n\n#define IMX8MM_VPUH1_A53_DOMAIN\t\t\tBIT(15)\n#define IMX8MM_VPUG2_A53_DOMAIN\t\t\tBIT(14)\n#define IMX8MM_VPUG1_A53_DOMAIN\t\t\tBIT(13)\n#define IMX8MM_DISPMIX_A53_DOMAIN\t\tBIT(12)\n#define IMX8MM_VPUMIX_A53_DOMAIN\t\tBIT(10)\n#define IMX8MM_GPUMIX_A53_DOMAIN\t\tBIT(9)\n#define IMX8MM_GPU_A53_DOMAIN\t\t\t(BIT(8) | BIT(11))\n#define IMX8MM_DDR1_A53_DOMAIN\t\t\tBIT(7)\n#define IMX8MM_OTG2_A53_DOMAIN\t\t\tBIT(5)\n#define IMX8MM_OTG1_A53_DOMAIN\t\t\tBIT(4)\n#define IMX8MM_PCIE_A53_DOMAIN\t\t\tBIT(3)\n#define IMX8MM_MIPI_A53_DOMAIN\t\t\tBIT(2)\n\n#define IMX8MN_DISPMIX_A53_DOMAIN\t\tBIT(12)\n#define IMX8MN_GPUMIX_A53_DOMAIN\t\tBIT(9)\n#define IMX8MN_DDR1_A53_DOMAIN\t\tBIT(7)\n#define IMX8MN_OTG1_A53_DOMAIN\t\tBIT(4)\n#define IMX8MN_MIPI_A53_DOMAIN\t\tBIT(2)\n\n#define IMX8MP_MEDIA_ISPDWP_A53_DOMAIN\tBIT(20)\n#define IMX8MP_HSIOMIX_A53_DOMAIN\t\tBIT(19)\n#define IMX8MP_MIPI_PHY2_A53_DOMAIN\t\tBIT(18)\n#define IMX8MP_HDMI_PHY_A53_DOMAIN\t\tBIT(17)\n#define IMX8MP_HDMIMIX_A53_DOMAIN\t\tBIT(16)\n#define IMX8MP_VPU_VC8000E_A53_DOMAIN\t\tBIT(15)\n#define IMX8MP_VPU_G2_A53_DOMAIN\t\tBIT(14)\n#define IMX8MP_VPU_G1_A53_DOMAIN\t\tBIT(13)\n#define IMX8MP_MEDIAMIX_A53_DOMAIN\t\tBIT(12)\n#define IMX8MP_GPU3D_A53_DOMAIN\t\t\tBIT(11)\n#define IMX8MP_VPUMIX_A53_DOMAIN\t\tBIT(10)\n#define IMX8MP_GPUMIX_A53_DOMAIN\t\tBIT(9)\n#define IMX8MP_GPU2D_A53_DOMAIN\t\t\tBIT(8)\n#define IMX8MP_AUDIOMIX_A53_DOMAIN\t\tBIT(7)\n#define IMX8MP_MLMIX_A53_DOMAIN\t\t\tBIT(6)\n#define IMX8MP_USB2_PHY_A53_DOMAIN\t\tBIT(5)\n#define IMX8MP_USB1_PHY_A53_DOMAIN\t\tBIT(4)\n#define IMX8MP_PCIE_PHY_A53_DOMAIN\t\tBIT(3)\n#define IMX8MP_MIPI_PHY1_A53_DOMAIN\t\tBIT(2)\n\n#define IMX8MP_GPC_PU_PGC_SW_PUP_REQ\t0x0d8\n#define IMX8MP_GPC_PU_PGC_SW_PDN_REQ\t0x0e4\n\n#define GPC_PU_PGC_SW_PUP_REQ\t\t0x0f8\n#define GPC_PU_PGC_SW_PDN_REQ\t\t0x104\n\n#define IMX7_USB_HSIC_PHY_SW_Pxx_REQ\t\tBIT(4)\n#define IMX7_USB_OTG2_PHY_SW_Pxx_REQ\t\tBIT(3)\n#define IMX7_USB_OTG1_PHY_SW_Pxx_REQ\t\tBIT(2)\n#define IMX7_PCIE_PHY_SW_Pxx_REQ\t\tBIT(1)\n#define IMX7_MIPI_PHY_SW_Pxx_REQ\t\tBIT(0)\n\n#define IMX8M_PCIE2_SW_Pxx_REQ\t\t\tBIT(13)\n#define IMX8M_MIPI_CSI2_SW_Pxx_REQ\t\tBIT(12)\n#define IMX8M_MIPI_CSI1_SW_Pxx_REQ\t\tBIT(11)\n#define IMX8M_DISP_SW_Pxx_REQ\t\t\tBIT(10)\n#define IMX8M_HDMI_SW_Pxx_REQ\t\t\tBIT(9)\n#define IMX8M_VPU_SW_Pxx_REQ\t\t\tBIT(8)\n#define IMX8M_GPU_SW_Pxx_REQ\t\t\tBIT(7)\n#define IMX8M_DDR2_SW_Pxx_REQ\t\t\tBIT(6)\n#define IMX8M_DDR1_SW_Pxx_REQ\t\t\tBIT(5)\n#define IMX8M_OTG2_SW_Pxx_REQ\t\t\tBIT(3)\n#define IMX8M_OTG1_SW_Pxx_REQ\t\t\tBIT(2)\n#define IMX8M_PCIE1_SW_Pxx_REQ\t\t\tBIT(1)\n#define IMX8M_MIPI_SW_Pxx_REQ\t\t\tBIT(0)\n\n#define IMX8MM_VPUH1_SW_Pxx_REQ\t\t\tBIT(13)\n#define IMX8MM_VPUG2_SW_Pxx_REQ\t\t\tBIT(12)\n#define IMX8MM_VPUG1_SW_Pxx_REQ\t\t\tBIT(11)\n#define IMX8MM_DISPMIX_SW_Pxx_REQ\t\tBIT(10)\n#define IMX8MM_VPUMIX_SW_Pxx_REQ\t\tBIT(8)\n#define IMX8MM_GPUMIX_SW_Pxx_REQ\t\tBIT(7)\n#define IMX8MM_GPU_SW_Pxx_REQ\t\t\t(BIT(6) | BIT(9))\n#define IMX8MM_DDR1_SW_Pxx_REQ\t\t\tBIT(5)\n#define IMX8MM_OTG2_SW_Pxx_REQ\t\t\tBIT(3)\n#define IMX8MM_OTG1_SW_Pxx_REQ\t\t\tBIT(2)\n#define IMX8MM_PCIE_SW_Pxx_REQ\t\t\tBIT(1)\n#define IMX8MM_MIPI_SW_Pxx_REQ\t\t\tBIT(0)\n\n#define IMX8MN_DISPMIX_SW_Pxx_REQ\t\tBIT(10)\n#define IMX8MN_GPUMIX_SW_Pxx_REQ\t\tBIT(7)\n#define IMX8MN_DDR1_SW_Pxx_REQ\t\tBIT(5)\n#define IMX8MN_OTG1_SW_Pxx_REQ\t\tBIT(2)\n#define IMX8MN_MIPI_SW_Pxx_REQ\t\tBIT(0)\n\n#define IMX8MP_DDRMIX_Pxx_REQ\t\t\tBIT(19)\n#define IMX8MP_MEDIA_ISP_DWP_Pxx_REQ\t\tBIT(18)\n#define IMX8MP_HSIOMIX_Pxx_REQ\t\t\tBIT(17)\n#define IMX8MP_MIPI_PHY2_Pxx_REQ\t\tBIT(16)\n#define IMX8MP_HDMI_PHY_Pxx_REQ\t\t\tBIT(15)\n#define IMX8MP_HDMIMIX_Pxx_REQ\t\t\tBIT(14)\n#define IMX8MP_VPU_VC8K_Pxx_REQ\t\t\tBIT(13)\n#define IMX8MP_VPU_G2_Pxx_REQ\t\t\tBIT(12)\n#define IMX8MP_VPU_G1_Pxx_REQ\t\t\tBIT(11)\n#define IMX8MP_MEDIMIX_Pxx_REQ\t\t\tBIT(10)\n#define IMX8MP_GPU_3D_Pxx_REQ\t\t\tBIT(9)\n#define IMX8MP_VPU_MIX_SHARE_LOGIC_Pxx_REQ\tBIT(8)\n#define IMX8MP_GPU_SHARE_LOGIC_Pxx_REQ\t\tBIT(7)\n#define IMX8MP_GPU_2D_Pxx_REQ\t\t\tBIT(6)\n#define IMX8MP_AUDIOMIX_Pxx_REQ\t\t\tBIT(5)\n#define IMX8MP_MLMIX_Pxx_REQ\t\t\tBIT(4)\n#define IMX8MP_USB2_PHY_Pxx_REQ\t\t\tBIT(3)\n#define IMX8MP_USB1_PHY_Pxx_REQ\t\t\tBIT(2)\n#define IMX8MP_PCIE_PHY_SW_Pxx_REQ\t\tBIT(1)\n#define IMX8MP_MIPI_PHY1_SW_Pxx_REQ\t\tBIT(0)\n\n#define GPC_M4_PU_PDN_FLG\t\t0x1bc\n\n#define IMX8MP_GPC_PU_PWRHSK\t\t0x190\n#define GPC_PU_PWRHSK\t\t\t0x1fc\n\n#define IMX8M_GPU_HSK_PWRDNACKN\t\t\tBIT(26)\n#define IMX8M_VPU_HSK_PWRDNACKN\t\t\tBIT(25)\n#define IMX8M_DISP_HSK_PWRDNACKN\t\tBIT(24)\n#define IMX8M_GPU_HSK_PWRDNREQN\t\t\tBIT(6)\n#define IMX8M_VPU_HSK_PWRDNREQN\t\t\tBIT(5)\n#define IMX8M_DISP_HSK_PWRDNREQN\t\tBIT(4)\n\n#define IMX8MM_GPUMIX_HSK_PWRDNACKN\t\tBIT(29)\n#define IMX8MM_GPU_HSK_PWRDNACKN\t\t(BIT(27) | BIT(28))\n#define IMX8MM_VPUMIX_HSK_PWRDNACKN\t\tBIT(26)\n#define IMX8MM_DISPMIX_HSK_PWRDNACKN\t\tBIT(25)\n#define IMX8MM_HSIO_HSK_PWRDNACKN\t\t(BIT(23) | BIT(24))\n#define IMX8MM_GPUMIX_HSK_PWRDNREQN\t\tBIT(11)\n#define IMX8MM_GPU_HSK_PWRDNREQN\t\t(BIT(9) | BIT(10))\n#define IMX8MM_VPUMIX_HSK_PWRDNREQN\t\tBIT(8)\n#define IMX8MM_DISPMIX_HSK_PWRDNREQN\t\tBIT(7)\n#define IMX8MM_HSIO_HSK_PWRDNREQN\t\t(BIT(5) | BIT(6))\n\n#define IMX8MN_GPUMIX_HSK_PWRDNACKN\t\t(BIT(29) | BIT(27))\n#define IMX8MN_DISPMIX_HSK_PWRDNACKN\t\tBIT(25)\n#define IMX8MN_HSIO_HSK_PWRDNACKN\t\tBIT(23)\n#define IMX8MN_GPUMIX_HSK_PWRDNREQN\t\t(BIT(11) | BIT(9))\n#define IMX8MN_DISPMIX_HSK_PWRDNREQN\t\tBIT(7)\n#define IMX8MN_HSIO_HSK_PWRDNREQN\t\tBIT(5)\n\n#define IMX8MP_MEDIAMIX_PWRDNACKN\t\tBIT(30)\n#define IMX8MP_HDMIMIX_PWRDNACKN\t\tBIT(29)\n#define IMX8MP_HSIOMIX_PWRDNACKN\t\tBIT(28)\n#define IMX8MP_VPUMIX_PWRDNACKN\t\t\tBIT(26)\n#define IMX8MP_GPUMIX_PWRDNACKN\t\t\tBIT(25)\n#define IMX8MP_MLMIX_PWRDNACKN\t\t\t(BIT(23) | BIT(24))\n#define IMX8MP_AUDIOMIX_PWRDNACKN\t\t(BIT(20) | BIT(31))\n#define IMX8MP_MEDIAMIX_PWRDNREQN\t\tBIT(14)\n#define IMX8MP_HDMIMIX_PWRDNREQN\t\tBIT(13)\n#define IMX8MP_HSIOMIX_PWRDNREQN\t\tBIT(12)\n#define IMX8MP_VPUMIX_PWRDNREQN\t\t\tBIT(10)\n#define IMX8MP_GPUMIX_PWRDNREQN\t\t\tBIT(9)\n#define IMX8MP_MLMIX_PWRDNREQN\t\t\t(BIT(7) | BIT(8))\n#define IMX8MP_AUDIOMIX_PWRDNREQN\t\t(BIT(4) | BIT(15))\n\n \n#define IMX7_PGC_MIPI\t\t\t16\n#define IMX7_PGC_PCIE\t\t\t17\n#define IMX7_PGC_USB_HSIC\t\t20\n\n#define IMX8M_PGC_MIPI\t\t\t16\n#define IMX8M_PGC_PCIE1\t\t\t17\n#define IMX8M_PGC_OTG1\t\t\t18\n#define IMX8M_PGC_OTG2\t\t\t19\n#define IMX8M_PGC_DDR1\t\t\t21\n#define IMX8M_PGC_GPU\t\t\t23\n#define IMX8M_PGC_VPU\t\t\t24\n#define IMX8M_PGC_DISP\t\t\t26\n#define IMX8M_PGC_MIPI_CSI1\t\t27\n#define IMX8M_PGC_MIPI_CSI2\t\t28\n#define IMX8M_PGC_PCIE2\t\t\t29\n\n#define IMX8MM_PGC_MIPI\t\t\t16\n#define IMX8MM_PGC_PCIE\t\t\t17\n#define IMX8MM_PGC_OTG1\t\t\t18\n#define IMX8MM_PGC_OTG2\t\t\t19\n#define IMX8MM_PGC_DDR1\t\t\t21\n#define IMX8MM_PGC_GPU2D\t\t22\n#define IMX8MM_PGC_GPUMIX\t\t23\n#define IMX8MM_PGC_VPUMIX\t\t24\n#define IMX8MM_PGC_GPU3D\t\t25\n#define IMX8MM_PGC_DISPMIX\t\t26\n#define IMX8MM_PGC_VPUG1\t\t27\n#define IMX8MM_PGC_VPUG2\t\t28\n#define IMX8MM_PGC_VPUH1\t\t29\n\n#define IMX8MN_PGC_MIPI\t\t16\n#define IMX8MN_PGC_OTG1\t\t18\n#define IMX8MN_PGC_DDR1\t\t21\n#define IMX8MN_PGC_GPUMIX\t\t23\n#define IMX8MN_PGC_DISPMIX\t\t26\n\n#define IMX8MP_PGC_NOC\t\t\t9\n#define IMX8MP_PGC_MIPI1\t\t12\n#define IMX8MP_PGC_PCIE\t\t\t13\n#define IMX8MP_PGC_USB1\t\t\t14\n#define IMX8MP_PGC_USB2\t\t\t15\n#define IMX8MP_PGC_MLMIX\t\t16\n#define IMX8MP_PGC_AUDIOMIX\t\t17\n#define IMX8MP_PGC_GPU2D\t\t18\n#define IMX8MP_PGC_GPUMIX\t\t19\n#define IMX8MP_PGC_VPUMIX\t\t20\n#define IMX8MP_PGC_GPU3D\t\t21\n#define IMX8MP_PGC_MEDIAMIX\t\t22\n#define IMX8MP_PGC_VPU_G1\t\t23\n#define IMX8MP_PGC_VPU_G2\t\t24\n#define IMX8MP_PGC_VPU_VC8000E\t\t25\n#define IMX8MP_PGC_HDMIMIX\t\t26\n#define IMX8MP_PGC_HDMI\t\t\t27\n#define IMX8MP_PGC_MIPI2\t\t28\n#define IMX8MP_PGC_HSIOMIX\t\t29\n#define IMX8MP_PGC_MEDIA_ISP_DWP\t30\n#define IMX8MP_PGC_DDRMIX\t\t31\n\n#define GPC_PGC_CTRL(n)\t\t\t(0x800 + (n) * 0x40)\n#define GPC_PGC_SR(n)\t\t\t(GPC_PGC_CTRL(n) + 0xc)\n\n#define GPC_PGC_CTRL_PCR\t\tBIT(0)\n\nstruct imx_pgc_regs {\n\tu16 map;\n\tu16 pup;\n\tu16 pdn;\n\tu16 hsk;\n};\n\nstruct imx_pgc_domain {\n\tstruct generic_pm_domain genpd;\n\tstruct regmap *regmap;\n\tconst struct imx_pgc_regs *regs;\n\tstruct regulator *regulator;\n\tstruct reset_control *reset;\n\tstruct clk_bulk_data *clks;\n\tint num_clks;\n\n\tunsigned long pgc;\n\n\tconst struct {\n\t\tu32 pxx;\n\t\tu32 map;\n\t\tu32 hskreq;\n\t\tu32 hskack;\n\t} bits;\n\n\tconst int voltage;\n\tconst bool keep_clocks;\n\tstruct device *dev;\n\n\tunsigned int pgc_sw_pup_reg;\n\tunsigned int pgc_sw_pdn_reg;\n};\n\nstruct imx_pgc_domain_data {\n\tconst struct imx_pgc_domain *domains;\n\tsize_t domains_num;\n\tconst struct regmap_access_table *reg_access_table;\n\tconst struct imx_pgc_regs *pgc_regs;\n};\n\nstatic inline struct imx_pgc_domain *\nto_imx_pgc_domain(struct generic_pm_domain *genpd)\n{\n\treturn container_of(genpd, struct imx_pgc_domain, genpd);\n}\n\nstatic int imx_pgc_power_up(struct generic_pm_domain *genpd)\n{\n\tstruct imx_pgc_domain *domain = to_imx_pgc_domain(genpd);\n\tu32 reg_val, pgc;\n\tint ret;\n\n\tret = pm_runtime_get_sync(domain->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(domain->dev);\n\t\treturn ret;\n\t}\n\n\tif (!IS_ERR(domain->regulator)) {\n\t\tret = regulator_enable(domain->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(domain->dev,\n\t\t\t\t\"failed to enable regulator: %pe\\n\",\n\t\t\t\tERR_PTR(ret));\n\t\t\tgoto out_put_pm;\n\t\t}\n\t}\n\n\treset_control_assert(domain->reset);\n\n\t \n\tret = clk_bulk_prepare_enable(domain->num_clks, domain->clks);\n\tif (ret) {\n\t\tdev_err(domain->dev, \"failed to enable reset clocks\\n\");\n\t\tgoto out_regulator_disable;\n\t}\n\n\t \n\tudelay(5);\n\n\tif (domain->bits.pxx) {\n\t\t \n\t\tregmap_update_bits(domain->regmap, domain->regs->pup,\n\t\t\t\t   domain->bits.pxx, domain->bits.pxx);\n\t\t \n\t\tret = regmap_read_poll_timeout(domain->regmap,\n\t\t\t\t\t       domain->regs->pup, reg_val,\n\t\t\t\t\t       !(reg_val & domain->bits.pxx),\n\t\t\t\t\t       0, USEC_PER_MSEC);\n\t\tif (ret) {\n\t\t\tdev_err(domain->dev, \"failed to command PGC\\n\");\n\t\t\tgoto out_clk_disable;\n\t\t}\n\n\t\t \n\t\tfor_each_set_bit(pgc, &domain->pgc, 32) {\n\t\t\tregmap_clear_bits(domain->regmap, GPC_PGC_CTRL(pgc),\n\t\t\t\t\t  GPC_PGC_CTRL_PCR);\n\t\t}\n\t}\n\n\t \n\tudelay(5);\n\n\treset_control_deassert(domain->reset);\n\n\t \n\tif (domain->bits.hskreq) {\n\t\tregmap_update_bits(domain->regmap, domain->regs->hsk,\n\t\t\t\t   domain->bits.hskreq, domain->bits.hskreq);\n\n\t\t \n\t}\n\n\t \n\tif (!domain->keep_clocks)\n\t\tclk_bulk_disable_unprepare(domain->num_clks, domain->clks);\n\n\treturn 0;\n\nout_clk_disable:\n\tclk_bulk_disable_unprepare(domain->num_clks, domain->clks);\nout_regulator_disable:\n\tif (!IS_ERR(domain->regulator))\n\t\tregulator_disable(domain->regulator);\nout_put_pm:\n\tpm_runtime_put(domain->dev);\n\n\treturn ret;\n}\n\nstatic int imx_pgc_power_down(struct generic_pm_domain *genpd)\n{\n\tstruct imx_pgc_domain *domain = to_imx_pgc_domain(genpd);\n\tu32 reg_val, pgc;\n\tint ret;\n\n\t \n\tif (!domain->keep_clocks) {\n\t\tret = clk_bulk_prepare_enable(domain->num_clks, domain->clks);\n\t\tif (ret) {\n\t\t\tdev_err(domain->dev, \"failed to enable reset clocks\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (domain->bits.hskreq) {\n\t\tregmap_clear_bits(domain->regmap, domain->regs->hsk,\n\t\t\t\t  domain->bits.hskreq);\n\n\t\tret = regmap_read_poll_timeout(domain->regmap, domain->regs->hsk,\n\t\t\t\t\t       reg_val,\n\t\t\t\t\t       !(reg_val & domain->bits.hskack),\n\t\t\t\t\t       0, USEC_PER_MSEC);\n\t\tif (ret) {\n\t\t\tdev_err(domain->dev, \"failed to power down ADB400\\n\");\n\t\t\tgoto out_clk_disable;\n\t\t}\n\t}\n\n\tif (domain->bits.pxx) {\n\t\t \n\t\tfor_each_set_bit(pgc, &domain->pgc, 32) {\n\t\t\tregmap_update_bits(domain->regmap, GPC_PGC_CTRL(pgc),\n\t\t\t\t\t   GPC_PGC_CTRL_PCR, GPC_PGC_CTRL_PCR);\n\t\t}\n\n\t\t \n\t\tregmap_update_bits(domain->regmap, domain->regs->pdn,\n\t\t\t\t   domain->bits.pxx, domain->bits.pxx);\n\t\t \n\t\tret = regmap_read_poll_timeout(domain->regmap,\n\t\t\t\t\t       domain->regs->pdn, reg_val,\n\t\t\t\t\t       !(reg_val & domain->bits.pxx),\n\t\t\t\t\t       0, USEC_PER_MSEC);\n\t\tif (ret) {\n\t\t\tdev_err(domain->dev, \"failed to command PGC\\n\");\n\t\t\tgoto out_clk_disable;\n\t\t}\n\t}\n\n\t \n\tclk_bulk_disable_unprepare(domain->num_clks, domain->clks);\n\n\tif (!IS_ERR(domain->regulator)) {\n\t\tret = regulator_disable(domain->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(domain->dev,\n\t\t\t\t\"failed to disable regulator: %pe\\n\",\n\t\t\t\tERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpm_runtime_put_sync_suspend(domain->dev);\n\n\treturn 0;\n\nout_clk_disable:\n\tif (!domain->keep_clocks)\n\t\tclk_bulk_disable_unprepare(domain->num_clks, domain->clks);\n\n\treturn ret;\n}\n\nstatic const struct imx_pgc_domain imx7_pgc_domains[] = {\n\t[IMX7_POWER_DOMAIN_MIPI_PHY] = {\n\t\t.genpd = {\n\t\t\t.name      = \"mipi-phy\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX7_MIPI_PHY_SW_Pxx_REQ,\n\t\t\t.map = IMX7_MIPI_PHY_A_CORE_DOMAIN,\n\t\t},\n\t\t.voltage   = 1000000,\n\t\t.pgc\t   = BIT(IMX7_PGC_MIPI),\n\t},\n\n\t[IMX7_POWER_DOMAIN_PCIE_PHY] = {\n\t\t.genpd = {\n\t\t\t.name      = \"pcie-phy\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX7_PCIE_PHY_SW_Pxx_REQ,\n\t\t\t.map = IMX7_PCIE_PHY_A_CORE_DOMAIN,\n\t\t},\n\t\t.voltage   = 1000000,\n\t\t.pgc\t   = BIT(IMX7_PGC_PCIE),\n\t},\n\n\t[IMX7_POWER_DOMAIN_USB_HSIC_PHY] = {\n\t\t.genpd = {\n\t\t\t.name      = \"usb-hsic-phy\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX7_USB_HSIC_PHY_SW_Pxx_REQ,\n\t\t\t.map = IMX7_USB_HSIC_PHY_A_CORE_DOMAIN,\n\t\t},\n\t\t.voltage   = 1200000,\n\t\t.pgc\t   = BIT(IMX7_PGC_USB_HSIC),\n\t},\n};\n\nstatic const struct regmap_range imx7_yes_ranges[] = {\n\t\tregmap_reg_range(GPC_LPCR_A_CORE_BSC,\n\t\t\t\t GPC_M4_PU_PDN_FLG),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX7_PGC_MIPI),\n\t\t\t\t GPC_PGC_SR(IMX7_PGC_MIPI)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX7_PGC_PCIE),\n\t\t\t\t GPC_PGC_SR(IMX7_PGC_PCIE)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX7_PGC_USB_HSIC),\n\t\t\t\t GPC_PGC_SR(IMX7_PGC_USB_HSIC)),\n};\n\nstatic const struct regmap_access_table imx7_access_table = {\n\t.yes_ranges\t= imx7_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(imx7_yes_ranges),\n};\n\nstatic const struct imx_pgc_regs imx7_pgc_regs = {\n\t.map = GPC_PGC_CPU_MAPPING,\n\t.pup = GPC_PU_PGC_SW_PUP_REQ,\n\t.pdn = GPC_PU_PGC_SW_PDN_REQ,\n\t.hsk = GPC_PU_PWRHSK,\n};\n\nstatic const struct imx_pgc_domain_data imx7_pgc_domain_data = {\n\t.domains = imx7_pgc_domains,\n\t.domains_num = ARRAY_SIZE(imx7_pgc_domains),\n\t.reg_access_table = &imx7_access_table,\n\t.pgc_regs = &imx7_pgc_regs,\n};\n\nstatic const struct imx_pgc_domain imx8m_pgc_domains[] = {\n\t[IMX8M_POWER_DOMAIN_MIPI] = {\n\t\t.genpd = {\n\t\t\t.name      = \"mipi\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8M_MIPI_SW_Pxx_REQ,\n\t\t\t.map = IMX8M_MIPI_A53_DOMAIN,\n\t\t},\n\t\t.pgc\t   = BIT(IMX8M_PGC_MIPI),\n\t},\n\n\t[IMX8M_POWER_DOMAIN_PCIE1] = {\n\t\t.genpd = {\n\t\t\t.name = \"pcie1\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8M_PCIE1_SW_Pxx_REQ,\n\t\t\t.map = IMX8M_PCIE1_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8M_PGC_PCIE1),\n\t},\n\n\t[IMX8M_POWER_DOMAIN_USB_OTG1] = {\n\t\t.genpd = {\n\t\t\t.name = \"usb-otg1\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8M_OTG1_SW_Pxx_REQ,\n\t\t\t.map = IMX8M_OTG1_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8M_PGC_OTG1),\n\t},\n\n\t[IMX8M_POWER_DOMAIN_USB_OTG2] = {\n\t\t.genpd = {\n\t\t\t.name = \"usb-otg2\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8M_OTG2_SW_Pxx_REQ,\n\t\t\t.map = IMX8M_OTG2_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8M_PGC_OTG2),\n\t},\n\n\t[IMX8M_POWER_DOMAIN_DDR1] = {\n\t\t.genpd = {\n\t\t\t.name = \"ddr1\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8M_DDR1_SW_Pxx_REQ,\n\t\t\t.map = IMX8M_DDR2_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8M_PGC_DDR1),\n\t},\n\n\t[IMX8M_POWER_DOMAIN_GPU] = {\n\t\t.genpd = {\n\t\t\t.name = \"gpu\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8M_GPU_SW_Pxx_REQ,\n\t\t\t.map = IMX8M_GPU_A53_DOMAIN,\n\t\t\t.hskreq = IMX8M_GPU_HSK_PWRDNREQN,\n\t\t\t.hskack = IMX8M_GPU_HSK_PWRDNACKN,\n\t\t},\n\t\t.pgc   = BIT(IMX8M_PGC_GPU),\n\t},\n\n\t[IMX8M_POWER_DOMAIN_VPU] = {\n\t\t.genpd = {\n\t\t\t.name = \"vpu\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8M_VPU_SW_Pxx_REQ,\n\t\t\t.map = IMX8M_VPU_A53_DOMAIN,\n\t\t\t.hskreq = IMX8M_VPU_HSK_PWRDNREQN,\n\t\t\t.hskack = IMX8M_VPU_HSK_PWRDNACKN,\n\t\t},\n\t\t.pgc   = BIT(IMX8M_PGC_VPU),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8M_POWER_DOMAIN_DISP] = {\n\t\t.genpd = {\n\t\t\t.name = \"disp\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8M_DISP_SW_Pxx_REQ,\n\t\t\t.map = IMX8M_DISP_A53_DOMAIN,\n\t\t\t.hskreq = IMX8M_DISP_HSK_PWRDNREQN,\n\t\t\t.hskack = IMX8M_DISP_HSK_PWRDNACKN,\n\t\t},\n\t\t.pgc   = BIT(IMX8M_PGC_DISP),\n\t},\n\n\t[IMX8M_POWER_DOMAIN_MIPI_CSI1] = {\n\t\t.genpd = {\n\t\t\t.name = \"mipi-csi1\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8M_MIPI_CSI1_SW_Pxx_REQ,\n\t\t\t.map = IMX8M_MIPI_CSI1_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8M_PGC_MIPI_CSI1),\n\t},\n\n\t[IMX8M_POWER_DOMAIN_MIPI_CSI2] = {\n\t\t.genpd = {\n\t\t\t.name = \"mipi-csi2\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8M_MIPI_CSI2_SW_Pxx_REQ,\n\t\t\t.map = IMX8M_MIPI_CSI2_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8M_PGC_MIPI_CSI2),\n\t},\n\n\t[IMX8M_POWER_DOMAIN_PCIE2] = {\n\t\t.genpd = {\n\t\t\t.name = \"pcie2\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8M_PCIE2_SW_Pxx_REQ,\n\t\t\t.map = IMX8M_PCIE2_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8M_PGC_PCIE2),\n\t},\n};\n\nstatic const struct regmap_range imx8m_yes_ranges[] = {\n\t\tregmap_reg_range(GPC_LPCR_A_CORE_BSC,\n\t\t\t\t GPC_PU_PWRHSK),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8M_PGC_MIPI),\n\t\t\t\t GPC_PGC_SR(IMX8M_PGC_MIPI)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8M_PGC_PCIE1),\n\t\t\t\t GPC_PGC_SR(IMX8M_PGC_PCIE1)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8M_PGC_OTG1),\n\t\t\t\t GPC_PGC_SR(IMX8M_PGC_OTG1)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8M_PGC_OTG2),\n\t\t\t\t GPC_PGC_SR(IMX8M_PGC_OTG2)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8M_PGC_DDR1),\n\t\t\t\t GPC_PGC_SR(IMX8M_PGC_DDR1)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8M_PGC_GPU),\n\t\t\t\t GPC_PGC_SR(IMX8M_PGC_GPU)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8M_PGC_VPU),\n\t\t\t\t GPC_PGC_SR(IMX8M_PGC_VPU)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8M_PGC_DISP),\n\t\t\t\t GPC_PGC_SR(IMX8M_PGC_DISP)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8M_PGC_MIPI_CSI1),\n\t\t\t\t GPC_PGC_SR(IMX8M_PGC_MIPI_CSI1)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8M_PGC_MIPI_CSI2),\n\t\t\t\t GPC_PGC_SR(IMX8M_PGC_MIPI_CSI2)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8M_PGC_PCIE2),\n\t\t\t\t GPC_PGC_SR(IMX8M_PGC_PCIE2)),\n};\n\nstatic const struct regmap_access_table imx8m_access_table = {\n\t.yes_ranges\t= imx8m_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(imx8m_yes_ranges),\n};\n\nstatic const struct imx_pgc_domain_data imx8m_pgc_domain_data = {\n\t.domains = imx8m_pgc_domains,\n\t.domains_num = ARRAY_SIZE(imx8m_pgc_domains),\n\t.reg_access_table = &imx8m_access_table,\n\t.pgc_regs = &imx7_pgc_regs,\n};\n\nstatic const struct imx_pgc_domain imx8mm_pgc_domains[] = {\n\t[IMX8MM_POWER_DOMAIN_HSIOMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"hsiomix\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = 0,  \n\t\t\t.map = 0,  \n\t\t\t.hskreq = IMX8MM_HSIO_HSK_PWRDNREQN,\n\t\t\t.hskack = IMX8MM_HSIO_HSK_PWRDNACKN,\n\t\t},\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MM_POWER_DOMAIN_PCIE] = {\n\t\t.genpd = {\n\t\t\t.name = \"pcie\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MM_PCIE_SW_Pxx_REQ,\n\t\t\t.map = IMX8MM_PCIE_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MM_PGC_PCIE),\n\t},\n\n\t[IMX8MM_POWER_DOMAIN_OTG1] = {\n\t\t.genpd = {\n\t\t\t.name = \"usb-otg1\",\n\t\t\t.flags = GENPD_FLAG_ACTIVE_WAKEUP,\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MM_OTG1_SW_Pxx_REQ,\n\t\t\t.map = IMX8MM_OTG1_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MM_PGC_OTG1),\n\t},\n\n\t[IMX8MM_POWER_DOMAIN_OTG2] = {\n\t\t.genpd = {\n\t\t\t.name = \"usb-otg2\",\n\t\t\t.flags = GENPD_FLAG_ACTIVE_WAKEUP,\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MM_OTG2_SW_Pxx_REQ,\n\t\t\t.map = IMX8MM_OTG2_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MM_PGC_OTG2),\n\t},\n\n\t[IMX8MM_POWER_DOMAIN_GPUMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"gpumix\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MM_GPUMIX_SW_Pxx_REQ,\n\t\t\t.map = IMX8MM_GPUMIX_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MM_GPUMIX_HSK_PWRDNREQN,\n\t\t\t.hskack = IMX8MM_GPUMIX_HSK_PWRDNACKN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MM_PGC_GPUMIX),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MM_POWER_DOMAIN_GPU] = {\n\t\t.genpd = {\n\t\t\t.name = \"gpu\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MM_GPU_SW_Pxx_REQ,\n\t\t\t.map = IMX8MM_GPU_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MM_GPU_HSK_PWRDNREQN,\n\t\t\t.hskack = IMX8MM_GPU_HSK_PWRDNACKN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MM_PGC_GPU2D) | BIT(IMX8MM_PGC_GPU3D),\n\t},\n\n\t[IMX8MM_POWER_DOMAIN_VPUMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"vpumix\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MM_VPUMIX_SW_Pxx_REQ,\n\t\t\t.map = IMX8MM_VPUMIX_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MM_VPUMIX_HSK_PWRDNREQN,\n\t\t\t.hskack = IMX8MM_VPUMIX_HSK_PWRDNACKN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MM_PGC_VPUMIX),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MM_POWER_DOMAIN_VPUG1] = {\n\t\t.genpd = {\n\t\t\t.name = \"vpu-g1\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MM_VPUG1_SW_Pxx_REQ,\n\t\t\t.map = IMX8MM_VPUG1_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MM_PGC_VPUG1),\n\t},\n\n\t[IMX8MM_POWER_DOMAIN_VPUG2] = {\n\t\t.genpd = {\n\t\t\t.name = \"vpu-g2\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MM_VPUG2_SW_Pxx_REQ,\n\t\t\t.map = IMX8MM_VPUG2_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MM_PGC_VPUG2),\n\t},\n\n\t[IMX8MM_POWER_DOMAIN_VPUH1] = {\n\t\t.genpd = {\n\t\t\t.name = \"vpu-h1\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MM_VPUH1_SW_Pxx_REQ,\n\t\t\t.map = IMX8MM_VPUH1_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MM_PGC_VPUH1),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MM_POWER_DOMAIN_DISPMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"dispmix\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MM_DISPMIX_SW_Pxx_REQ,\n\t\t\t.map = IMX8MM_DISPMIX_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MM_DISPMIX_HSK_PWRDNREQN,\n\t\t\t.hskack = IMX8MM_DISPMIX_HSK_PWRDNACKN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MM_PGC_DISPMIX),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MM_POWER_DOMAIN_MIPI] = {\n\t\t.genpd = {\n\t\t\t.name = \"mipi\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MM_MIPI_SW_Pxx_REQ,\n\t\t\t.map = IMX8MM_MIPI_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MM_PGC_MIPI),\n\t},\n};\n\nstatic const struct regmap_range imx8mm_yes_ranges[] = {\n\t\tregmap_reg_range(GPC_LPCR_A_CORE_BSC,\n\t\t\t\t GPC_PU_PWRHSK),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_MIPI),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_MIPI)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_PCIE),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_PCIE)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_OTG1),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_OTG1)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_OTG2),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_OTG2)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_DDR1),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_DDR1)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_GPU2D),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_GPU2D)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_GPUMIX),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_GPUMIX)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_VPUMIX),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_VPUMIX)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_GPU3D),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_GPU3D)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_DISPMIX),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_DISPMIX)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_VPUG1),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_VPUG1)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_VPUG2),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_VPUG2)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MM_PGC_VPUH1),\n\t\t\t\t GPC_PGC_SR(IMX8MM_PGC_VPUH1)),\n};\n\nstatic const struct regmap_access_table imx8mm_access_table = {\n\t.yes_ranges\t= imx8mm_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(imx8mm_yes_ranges),\n};\n\nstatic const struct imx_pgc_domain_data imx8mm_pgc_domain_data = {\n\t.domains = imx8mm_pgc_domains,\n\t.domains_num = ARRAY_SIZE(imx8mm_pgc_domains),\n\t.reg_access_table = &imx8mm_access_table,\n\t.pgc_regs = &imx7_pgc_regs,\n};\n\nstatic const struct imx_pgc_domain imx8mp_pgc_domains[] = {\n\t[IMX8MP_POWER_DOMAIN_MIPI_PHY1] = {\n\t\t.genpd = {\n\t\t\t.name = \"mipi-phy1\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_MIPI_PHY1_SW_Pxx_REQ,\n\t\t\t.map = IMX8MP_MIPI_PHY1_A53_DOMAIN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_MIPI1),\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_PCIE_PHY] = {\n\t\t.genpd = {\n\t\t\t.name = \"pcie-phy1\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_PCIE_PHY_SW_Pxx_REQ,\n\t\t\t.map = IMX8MP_PCIE_PHY_A53_DOMAIN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_PCIE),\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_USB1_PHY] = {\n\t\t.genpd = {\n\t\t\t.name = \"usb-otg1\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_USB1_PHY_Pxx_REQ,\n\t\t\t.map = IMX8MP_USB1_PHY_A53_DOMAIN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_USB1),\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_USB2_PHY] = {\n\t\t.genpd = {\n\t\t\t.name = \"usb-otg2\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_USB2_PHY_Pxx_REQ,\n\t\t\t.map = IMX8MP_USB2_PHY_A53_DOMAIN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_USB2),\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_MLMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"mlmix\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_MLMIX_Pxx_REQ,\n\t\t\t.map = IMX8MP_MLMIX_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MP_MLMIX_PWRDNREQN,\n\t\t\t.hskack = IMX8MP_MLMIX_PWRDNACKN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_MLMIX),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_AUDIOMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"audiomix\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_AUDIOMIX_Pxx_REQ,\n\t\t\t.map = IMX8MP_AUDIOMIX_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MP_AUDIOMIX_PWRDNREQN,\n\t\t\t.hskack = IMX8MP_AUDIOMIX_PWRDNACKN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_AUDIOMIX),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_GPU2D] = {\n\t\t.genpd = {\n\t\t\t.name = \"gpu2d\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_GPU_2D_Pxx_REQ,\n\t\t\t.map = IMX8MP_GPU2D_A53_DOMAIN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_GPU2D),\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_GPUMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"gpumix\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_GPU_SHARE_LOGIC_Pxx_REQ,\n\t\t\t.map = IMX8MP_GPUMIX_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MP_GPUMIX_PWRDNREQN,\n\t\t\t.hskack = IMX8MP_GPUMIX_PWRDNACKN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_GPUMIX),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_VPUMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"vpumix\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_VPU_MIX_SHARE_LOGIC_Pxx_REQ,\n\t\t\t.map = IMX8MP_VPUMIX_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MP_VPUMIX_PWRDNREQN,\n\t\t\t.hskack = IMX8MP_VPUMIX_PWRDNACKN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_VPUMIX),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_GPU3D] = {\n\t\t.genpd = {\n\t\t\t.name = \"gpu3d\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_GPU_3D_Pxx_REQ,\n\t\t\t.map = IMX8MP_GPU3D_A53_DOMAIN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_GPU3D),\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_MEDIAMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"mediamix\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_MEDIMIX_Pxx_REQ,\n\t\t\t.map = IMX8MP_MEDIAMIX_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MP_MEDIAMIX_PWRDNREQN,\n\t\t\t.hskack = IMX8MP_MEDIAMIX_PWRDNACKN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_MEDIAMIX),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_VPU_G1] = {\n\t\t.genpd = {\n\t\t\t.name = \"vpu-g1\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_VPU_G1_Pxx_REQ,\n\t\t\t.map = IMX8MP_VPU_G1_A53_DOMAIN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_VPU_G1),\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_VPU_G2] = {\n\t\t.genpd = {\n\t\t\t.name = \"vpu-g2\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_VPU_G2_Pxx_REQ,\n\t\t\t.map = IMX8MP_VPU_G2_A53_DOMAIN\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_VPU_G2),\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_VPU_VC8000E] = {\n\t\t.genpd = {\n\t\t\t.name = \"vpu-h1\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_VPU_VC8K_Pxx_REQ,\n\t\t\t.map = IMX8MP_VPU_VC8000E_A53_DOMAIN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_VPU_VC8000E),\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_HDMIMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"hdmimix\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_HDMIMIX_Pxx_REQ,\n\t\t\t.map = IMX8MP_HDMIMIX_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MP_HDMIMIX_PWRDNREQN,\n\t\t\t.hskack = IMX8MP_HDMIMIX_PWRDNACKN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_HDMIMIX),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_HDMI_PHY] = {\n\t\t.genpd = {\n\t\t\t.name = \"hdmi-phy\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_HDMI_PHY_Pxx_REQ,\n\t\t\t.map = IMX8MP_HDMI_PHY_A53_DOMAIN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_HDMI),\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_MIPI_PHY2] = {\n\t\t.genpd = {\n\t\t\t.name = \"mipi-phy2\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_MIPI_PHY2_Pxx_REQ,\n\t\t\t.map = IMX8MP_MIPI_PHY2_A53_DOMAIN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_MIPI2),\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_HSIOMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"hsiomix\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_HSIOMIX_Pxx_REQ,\n\t\t\t.map = IMX8MP_HSIOMIX_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MP_HSIOMIX_PWRDNREQN,\n\t\t\t.hskack = IMX8MP_HSIOMIX_PWRDNACKN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_HSIOMIX),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MP_POWER_DOMAIN_MEDIAMIX_ISPDWP] = {\n\t\t.genpd = {\n\t\t\t.name = \"mediamix-isp-dwp\",\n\t\t},\n\t\t.bits = {\n\t\t\t.pxx = IMX8MP_MEDIA_ISP_DWP_Pxx_REQ,\n\t\t\t.map = IMX8MP_MEDIA_ISPDWP_A53_DOMAIN,\n\t\t},\n\t\t.pgc = BIT(IMX8MP_PGC_MEDIA_ISP_DWP),\n\t},\n};\n\nstatic const struct regmap_range imx8mp_yes_ranges[] = {\n\t\tregmap_reg_range(GPC_LPCR_A_CORE_BSC,\n\t\t\t\t IMX8MP_GPC_PGC_CPU_MAPPING),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_NOC),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_NOC)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_MIPI1),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_MIPI1)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_PCIE),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_PCIE)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_USB1),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_USB1)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_USB2),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_USB2)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_MLMIX),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_MLMIX)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_AUDIOMIX),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_AUDIOMIX)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_GPU2D),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_GPU2D)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_GPUMIX),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_GPUMIX)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_VPUMIX),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_VPUMIX)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_GPU3D),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_GPU3D)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_MEDIAMIX),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_MEDIAMIX)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_VPU_G1),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_VPU_G1)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_VPU_G2),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_VPU_G2)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_VPU_VC8000E),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_VPU_VC8000E)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_HDMIMIX),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_HDMIMIX)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_HDMI),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_HDMI)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_MIPI2),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_MIPI2)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_HSIOMIX),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_HSIOMIX)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_MEDIA_ISP_DWP),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_MEDIA_ISP_DWP)),\n\t\tregmap_reg_range(GPC_PGC_CTRL(IMX8MP_PGC_DDRMIX),\n\t\t\t\t GPC_PGC_SR(IMX8MP_PGC_DDRMIX)),\n};\n\nstatic const struct regmap_access_table imx8mp_access_table = {\n\t.yes_ranges\t= imx8mp_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(imx8mp_yes_ranges),\n};\n\nstatic const struct imx_pgc_regs imx8mp_pgc_regs = {\n\t.map = IMX8MP_GPC_PGC_CPU_MAPPING,\n\t.pup = IMX8MP_GPC_PU_PGC_SW_PUP_REQ,\n\t.pdn = IMX8MP_GPC_PU_PGC_SW_PDN_REQ,\n\t.hsk = IMX8MP_GPC_PU_PWRHSK,\n};\nstatic const struct imx_pgc_domain_data imx8mp_pgc_domain_data = {\n\t.domains = imx8mp_pgc_domains,\n\t.domains_num = ARRAY_SIZE(imx8mp_pgc_domains),\n\t.reg_access_table = &imx8mp_access_table,\n\t.pgc_regs = &imx8mp_pgc_regs,\n};\n\nstatic const struct imx_pgc_domain imx8mn_pgc_domains[] = {\n\t[IMX8MN_POWER_DOMAIN_HSIOMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"hsiomix\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = 0,  \n\t\t\t.map = 0,  \n\t\t\t.hskreq = IMX8MN_HSIO_HSK_PWRDNREQN,\n\t\t\t.hskack = IMX8MN_HSIO_HSK_PWRDNACKN,\n\t\t},\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MN_POWER_DOMAIN_OTG1] = {\n\t\t.genpd = {\n\t\t\t.name = \"usb-otg1\",\n\t\t\t.flags = GENPD_FLAG_ACTIVE_WAKEUP,\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MN_OTG1_SW_Pxx_REQ,\n\t\t\t.map = IMX8MN_OTG1_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MN_PGC_OTG1),\n\t},\n\n\t[IMX8MN_POWER_DOMAIN_GPUMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"gpumix\",\n\t\t},\n\t\t.bits  = {\n\t\t\t.pxx = IMX8MN_GPUMIX_SW_Pxx_REQ,\n\t\t\t.map = IMX8MN_GPUMIX_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MN_GPUMIX_HSK_PWRDNREQN,\n\t\t\t.hskack = IMX8MN_GPUMIX_HSK_PWRDNACKN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MN_PGC_GPUMIX),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MN_POWER_DOMAIN_DISPMIX] = {\n\t\t.genpd = {\n\t\t\t.name = \"dispmix\",\n\t\t},\n\t\t\t.bits  = {\n\t\t\t.pxx = IMX8MN_DISPMIX_SW_Pxx_REQ,\n\t\t\t.map = IMX8MN_DISPMIX_A53_DOMAIN,\n\t\t\t.hskreq = IMX8MN_DISPMIX_HSK_PWRDNREQN,\n\t\t\t.hskack = IMX8MN_DISPMIX_HSK_PWRDNACKN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MN_PGC_DISPMIX),\n\t\t.keep_clocks = true,\n\t},\n\n\t[IMX8MN_POWER_DOMAIN_MIPI] = {\n\t\t.genpd = {\n\t\t\t.name = \"mipi\",\n\t\t},\n\t\t\t.bits  = {\n\t\t\t.pxx = IMX8MN_MIPI_SW_Pxx_REQ,\n\t\t\t.map = IMX8MN_MIPI_A53_DOMAIN,\n\t\t},\n\t\t.pgc   = BIT(IMX8MN_PGC_MIPI),\n\t},\n};\n\nstatic const struct regmap_range imx8mn_yes_ranges[] = {\n\tregmap_reg_range(GPC_LPCR_A_CORE_BSC,\n\t\t\t GPC_PU_PWRHSK),\n\tregmap_reg_range(GPC_PGC_CTRL(IMX8MN_PGC_MIPI),\n\t\t\t GPC_PGC_SR(IMX8MN_PGC_MIPI)),\n\tregmap_reg_range(GPC_PGC_CTRL(IMX8MN_PGC_OTG1),\n\t\t\t GPC_PGC_SR(IMX8MN_PGC_OTG1)),\n\tregmap_reg_range(GPC_PGC_CTRL(IMX8MN_PGC_DDR1),\n\t\t\t GPC_PGC_SR(IMX8MN_PGC_DDR1)),\n\tregmap_reg_range(GPC_PGC_CTRL(IMX8MN_PGC_GPUMIX),\n\t\t\t GPC_PGC_SR(IMX8MN_PGC_GPUMIX)),\n\tregmap_reg_range(GPC_PGC_CTRL(IMX8MN_PGC_DISPMIX),\n\t\t\t GPC_PGC_SR(IMX8MN_PGC_DISPMIX)),\n};\n\nstatic const struct regmap_access_table imx8mn_access_table = {\n\t.yes_ranges\t= imx8mn_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(imx8mn_yes_ranges),\n};\n\nstatic const struct imx_pgc_domain_data imx8mn_pgc_domain_data = {\n\t.domains = imx8mn_pgc_domains,\n\t.domains_num = ARRAY_SIZE(imx8mn_pgc_domains),\n\t.reg_access_table = &imx8mn_access_table,\n\t.pgc_regs = &imx7_pgc_regs,\n};\n\nstatic int imx_pgc_domain_probe(struct platform_device *pdev)\n{\n\tstruct imx_pgc_domain *domain = pdev->dev.platform_data;\n\tint ret;\n\n\tdomain->dev = &pdev->dev;\n\n\tdomain->regulator = devm_regulator_get_optional(domain->dev, \"power\");\n\tif (IS_ERR(domain->regulator)) {\n\t\tif (PTR_ERR(domain->regulator) != -ENODEV)\n\t\t\treturn dev_err_probe(domain->dev, PTR_ERR(domain->regulator),\n\t\t\t\t\t     \"Failed to get domain's regulator\\n\");\n\t} else if (domain->voltage) {\n\t\tregulator_set_voltage(domain->regulator,\n\t\t\t\t      domain->voltage, domain->voltage);\n\t}\n\n\tdomain->num_clks = devm_clk_bulk_get_all(domain->dev, &domain->clks);\n\tif (domain->num_clks < 0)\n\t\treturn dev_err_probe(domain->dev, domain->num_clks,\n\t\t\t\t     \"Failed to get domain's clocks\\n\");\n\n\tdomain->reset = devm_reset_control_array_get_optional_exclusive(domain->dev);\n\tif (IS_ERR(domain->reset))\n\t\treturn dev_err_probe(domain->dev, PTR_ERR(domain->reset),\n\t\t\t\t     \"Failed to get domain's resets\\n\");\n\n\tpm_runtime_enable(domain->dev);\n\n\tif (domain->bits.map)\n\t\tregmap_update_bits(domain->regmap, domain->regs->map,\n\t\t\t\t   domain->bits.map, domain->bits.map);\n\n\tret = pm_genpd_init(&domain->genpd, NULL, true);\n\tif (ret) {\n\t\tdev_err(domain->dev, \"Failed to init power domain\\n\");\n\t\tgoto out_domain_unmap;\n\t}\n\n\tif (IS_ENABLED(CONFIG_LOCKDEP) &&\n\t    of_property_read_bool(domain->dev->of_node, \"power-domains\"))\n\t\tlockdep_set_subclass(&domain->genpd.mlock, 1);\n\n\tret = of_genpd_add_provider_simple(domain->dev->of_node,\n\t\t\t\t\t   &domain->genpd);\n\tif (ret) {\n\t\tdev_err(domain->dev, \"Failed to add genpd provider\\n\");\n\t\tgoto out_genpd_remove;\n\t}\n\n\treturn 0;\n\nout_genpd_remove:\n\tpm_genpd_remove(&domain->genpd);\nout_domain_unmap:\n\tif (domain->bits.map)\n\t\tregmap_update_bits(domain->regmap, domain->regs->map,\n\t\t\t\t   domain->bits.map, 0);\n\tpm_runtime_disable(domain->dev);\n\n\treturn ret;\n}\n\nstatic int imx_pgc_domain_remove(struct platform_device *pdev)\n{\n\tstruct imx_pgc_domain *domain = pdev->dev.platform_data;\n\n\tof_genpd_del_provider(domain->dev->of_node);\n\tpm_genpd_remove(&domain->genpd);\n\n\tif (domain->bits.map)\n\t\tregmap_update_bits(domain->regmap, domain->regs->map,\n\t\t\t\t   domain->bits.map, 0);\n\n\tpm_runtime_disable(domain->dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int imx_pgc_domain_suspend(struct device *dev)\n{\n\tint ret;\n\n\t \n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_pgc_domain_resume(struct device *dev)\n{\n\treturn pm_runtime_put(dev);\n}\n#endif\n\nstatic const struct dev_pm_ops imx_pgc_domain_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(imx_pgc_domain_suspend, imx_pgc_domain_resume)\n};\n\nstatic const struct platform_device_id imx_pgc_domain_id[] = {\n\t{ \"imx-pgc-domain\", },\n\t{ },\n};\n\nstatic struct platform_driver imx_pgc_domain_driver = {\n\t.driver = {\n\t\t.name = \"imx-pgc\",\n\t\t.pm = &imx_pgc_domain_pm_ops,\n\t},\n\t.probe    = imx_pgc_domain_probe,\n\t.remove   = imx_pgc_domain_remove,\n\t.id_table = imx_pgc_domain_id,\n};\nbuiltin_platform_driver(imx_pgc_domain_driver)\n\nstatic int imx_gpcv2_probe(struct platform_device *pdev)\n{\n\tconst struct imx_pgc_domain_data *domain_data =\n\t\t\tof_device_get_match_data(&pdev->dev);\n\n\tstruct regmap_config regmap_config = {\n\t\t.reg_bits\t= 32,\n\t\t.val_bits\t= 32,\n\t\t.reg_stride\t= 4,\n\t\t.rd_table\t= domain_data->reg_access_table,\n\t\t.wr_table\t= domain_data->reg_access_table,\n\t\t.max_register   = SZ_4K,\n\t};\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *pgc_np, *np;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tint ret;\n\n\tpgc_np = of_get_child_by_name(dev->of_node, \"pgc\");\n\tif (!pgc_np) {\n\t\tdev_err(dev, \"No power domains specified in DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(dev, base, &regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tdev_err(dev, \"failed to init regmap (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor_each_child_of_node(pgc_np, np) {\n\t\tstruct platform_device *pd_pdev;\n\t\tstruct imx_pgc_domain *domain;\n\t\tu32 domain_index;\n\n\t\tif (!of_device_is_available(np))\n\t\t\tcontinue;\n\n\t\tret = of_property_read_u32(np, \"reg\", &domain_index);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to read 'reg' property\\n\");\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (domain_index >= domain_data->domains_num) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Domain index %d is out of bounds\\n\",\n\t\t\t\t domain_index);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpd_pdev = platform_device_alloc(\"imx-pgc-domain\",\n\t\t\t\t\t\tdomain_index);\n\t\tif (!pd_pdev) {\n\t\t\tdev_err(dev, \"Failed to allocate platform device\\n\");\n\t\t\tof_node_put(np);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tret = platform_device_add_data(pd_pdev,\n\t\t\t\t\t       &domain_data->domains[domain_index],\n\t\t\t\t\t       sizeof(domain_data->domains[domain_index]));\n\t\tif (ret) {\n\t\t\tplatform_device_put(pd_pdev);\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdomain = pd_pdev->dev.platform_data;\n\t\tdomain->regmap = regmap;\n\t\tdomain->regs = domain_data->pgc_regs;\n\n\t\tdomain->genpd.power_on  = imx_pgc_power_up;\n\t\tdomain->genpd.power_off = imx_pgc_power_down;\n\n\t\tpd_pdev->dev.parent = dev;\n\t\tdevice_set_node(&pd_pdev->dev, of_fwnode_handle(np));\n\n\t\tret = platform_device_add(pd_pdev);\n\t\tif (ret) {\n\t\t\tplatform_device_put(pd_pdev);\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id imx_gpcv2_dt_ids[] = {\n\t{ .compatible = \"fsl,imx7d-gpc\", .data = &imx7_pgc_domain_data, },\n\t{ .compatible = \"fsl,imx8mm-gpc\", .data = &imx8mm_pgc_domain_data, },\n\t{ .compatible = \"fsl,imx8mn-gpc\", .data = &imx8mn_pgc_domain_data, },\n\t{ .compatible = \"fsl,imx8mp-gpc\", .data = &imx8mp_pgc_domain_data, },\n\t{ .compatible = \"fsl,imx8mq-gpc\", .data = &imx8m_pgc_domain_data, },\n\t{ }\n};\n\nstatic struct platform_driver imx_gpc_driver = {\n\t.driver = {\n\t\t.name = \"imx-gpcv2\",\n\t\t.of_match_table = imx_gpcv2_dt_ids,\n\t},\n\t.probe = imx_gpcv2_probe,\n};\nbuiltin_platform_driver(imx_gpc_driver)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}