{
  "module_name": "imx8m-blk-ctrl.c",
  "hash_id": "0e711fa8e493b0ae03c252287ea975b7c0424684f38fbfab9aba28dce019a6f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/imx/imx8m-blk-ctrl.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/interconnect.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/clk.h>\n\n#include <dt-bindings/power/imx8mm-power.h>\n#include <dt-bindings/power/imx8mn-power.h>\n#include <dt-bindings/power/imx8mp-power.h>\n#include <dt-bindings/power/imx8mq-power.h>\n\n#define BLK_SFT_RSTN\t0x0\n#define BLK_CLK_EN\t0x4\n#define BLK_MIPI_RESET_DIV\t0x8  \n\nstruct imx8m_blk_ctrl_domain;\n\nstruct imx8m_blk_ctrl {\n\tstruct device *dev;\n\tstruct notifier_block power_nb;\n\tstruct device *bus_power_dev;\n\tstruct regmap *regmap;\n\tstruct imx8m_blk_ctrl_domain *domains;\n\tstruct genpd_onecell_data onecell_data;\n};\n\nstruct imx8m_blk_ctrl_domain_data {\n\tconst char *name;\n\tconst char * const *clk_names;\n\tconst char * const *path_names;\n\tconst char *gpc_name;\n\tint num_clks;\n\tint num_paths;\n\tu32 rst_mask;\n\tu32 clk_mask;\n\n\t \n\tu32 mipi_phy_rst_mask;\n};\n\n#define DOMAIN_MAX_CLKS 4\n#define DOMAIN_MAX_PATHS 4\n\nstruct imx8m_blk_ctrl_domain {\n\tstruct generic_pm_domain genpd;\n\tconst struct imx8m_blk_ctrl_domain_data *data;\n\tstruct clk_bulk_data clks[DOMAIN_MAX_CLKS];\n\tstruct icc_bulk_data paths[DOMAIN_MAX_PATHS];\n\tstruct device *power_dev;\n\tstruct imx8m_blk_ctrl *bc;\n\tint num_paths;\n};\n\nstruct imx8m_blk_ctrl_data {\n\tint max_reg;\n\tnotifier_fn_t power_notifier_fn;\n\tconst struct imx8m_blk_ctrl_domain_data *domains;\n\tint num_domains;\n};\n\nstatic inline struct imx8m_blk_ctrl_domain *\nto_imx8m_blk_ctrl_domain(struct generic_pm_domain *genpd)\n{\n\treturn container_of(genpd, struct imx8m_blk_ctrl_domain, genpd);\n}\n\nstatic int imx8m_blk_ctrl_power_on(struct generic_pm_domain *genpd)\n{\n\tstruct imx8m_blk_ctrl_domain *domain = to_imx8m_blk_ctrl_domain(genpd);\n\tconst struct imx8m_blk_ctrl_domain_data *data = domain->data;\n\tstruct imx8m_blk_ctrl *bc = domain->bc;\n\tint ret;\n\n\t \n\tret = pm_runtime_get_sync(bc->bus_power_dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(bc->bus_power_dev);\n\t\tdev_err(bc->dev, \"failed to power up bus domain\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_clear_bits(bc->regmap, BLK_SFT_RSTN, data->rst_mask);\n\tif (data->mipi_phy_rst_mask)\n\t\tregmap_clear_bits(bc->regmap, BLK_MIPI_RESET_DIV, data->mipi_phy_rst_mask);\n\n\t \n\tret = clk_bulk_prepare_enable(data->num_clks, domain->clks);\n\tif (ret) {\n\t\tdev_err(bc->dev, \"failed to enable clocks\\n\");\n\t\tgoto bus_put;\n\t}\n\tregmap_set_bits(bc->regmap, BLK_CLK_EN, data->clk_mask);\n\n\t \n\tret = pm_runtime_get_sync(domain->power_dev);\n\tif (ret < 0) {\n\t\tdev_err(bc->dev, \"failed to power up peripheral domain\\n\");\n\t\tgoto clk_disable;\n\t}\n\n\t \n\tudelay(5);\n\n\t \n\tregmap_set_bits(bc->regmap, BLK_SFT_RSTN, data->rst_mask);\n\tif (data->mipi_phy_rst_mask)\n\t\tregmap_set_bits(bc->regmap, BLK_MIPI_RESET_DIV, data->mipi_phy_rst_mask);\n\n\tret = icc_bulk_set_bw(domain->num_paths, domain->paths);\n\tif (ret)\n\t\tdev_err(bc->dev, \"failed to set icc bw\\n\");\n\n\t \n\tclk_bulk_disable_unprepare(data->num_clks, domain->clks);\n\n\treturn 0;\n\nclk_disable:\n\tclk_bulk_disable_unprepare(data->num_clks, domain->clks);\nbus_put:\n\tpm_runtime_put(bc->bus_power_dev);\n\n\treturn ret;\n}\n\nstatic int imx8m_blk_ctrl_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct imx8m_blk_ctrl_domain *domain = to_imx8m_blk_ctrl_domain(genpd);\n\tconst struct imx8m_blk_ctrl_domain_data *data = domain->data;\n\tstruct imx8m_blk_ctrl *bc = domain->bc;\n\n\t \n\tif (data->mipi_phy_rst_mask)\n\t\tregmap_clear_bits(bc->regmap, BLK_MIPI_RESET_DIV, data->mipi_phy_rst_mask);\n\n\tregmap_clear_bits(bc->regmap, BLK_SFT_RSTN, data->rst_mask);\n\tregmap_clear_bits(bc->regmap, BLK_CLK_EN, data->clk_mask);\n\n\t \n\tpm_runtime_put(domain->power_dev);\n\n\t \n\tpm_runtime_put(bc->bus_power_dev);\n\n\treturn 0;\n}\n\nstatic struct lock_class_key blk_ctrl_genpd_lock_class;\n\nstatic int imx8m_blk_ctrl_probe(struct platform_device *pdev)\n{\n\tconst struct imx8m_blk_ctrl_data *bc_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct imx8m_blk_ctrl *bc;\n\tvoid __iomem *base;\n\tint i, ret;\n\n\tstruct regmap_config regmap_config = {\n\t\t.reg_bits\t= 32,\n\t\t.val_bits\t= 32,\n\t\t.reg_stride\t= 4,\n\t};\n\n\tbc = devm_kzalloc(dev, sizeof(*bc), GFP_KERNEL);\n\tif (!bc)\n\t\treturn -ENOMEM;\n\n\tbc->dev = dev;\n\n\tbc_data = of_device_get_match_data(dev);\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap_config.max_register = bc_data->max_reg;\n\tbc->regmap = devm_regmap_init_mmio(dev, base, &regmap_config);\n\tif (IS_ERR(bc->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(bc->regmap),\n\t\t\t\t     \"failed to init regmap\\n\");\n\n\tbc->domains = devm_kcalloc(dev, bc_data->num_domains,\n\t\t\t\t   sizeof(struct imx8m_blk_ctrl_domain),\n\t\t\t\t   GFP_KERNEL);\n\tif (!bc->domains)\n\t\treturn -ENOMEM;\n\n\tbc->onecell_data.num_domains = bc_data->num_domains;\n\tbc->onecell_data.domains =\n\t\tdevm_kcalloc(dev, bc_data->num_domains,\n\t\t\t     sizeof(struct generic_pm_domain *), GFP_KERNEL);\n\tif (!bc->onecell_data.domains)\n\t\treturn -ENOMEM;\n\n\tbc->bus_power_dev = dev_pm_domain_attach_by_name(dev, \"bus\");\n\tif (IS_ERR(bc->bus_power_dev)) {\n\t\tif (PTR_ERR(bc->bus_power_dev) == -ENODEV)\n\t\t\treturn dev_err_probe(dev, -EPROBE_DEFER,\n\t\t\t\t\t     \"failed to attach power domain \\\"bus\\\"\\n\");\n\t\telse\n\t\t\treturn dev_err_probe(dev, PTR_ERR(bc->bus_power_dev),\n\t\t\t\t\t     \"failed to attach power domain \\\"bus\\\"\\n\");\n\t}\n\n\tfor (i = 0; i < bc_data->num_domains; i++) {\n\t\tconst struct imx8m_blk_ctrl_domain_data *data = &bc_data->domains[i];\n\t\tstruct imx8m_blk_ctrl_domain *domain = &bc->domains[i];\n\t\tint j;\n\n\t\tdomain->data = data;\n\t\tdomain->num_paths = data->num_paths;\n\n\t\tfor (j = 0; j < data->num_clks; j++)\n\t\t\tdomain->clks[j].id = data->clk_names[j];\n\n\t\tfor (j = 0; j < data->num_paths; j++) {\n\t\t\tdomain->paths[j].name = data->path_names[j];\n\t\t\t \n\t\t\tdomain->paths[j].avg_bw = 1;\n\t\t\tdomain->paths[j].peak_bw = 1;\n\t\t}\n\n\t\tret = devm_of_icc_bulk_get(dev, data->num_paths, domain->paths);\n\t\tif (ret) {\n\t\t\tif (ret != -EPROBE_DEFER) {\n\t\t\t\tdev_warn_once(dev, \"Could not get interconnect paths, NoC will stay unconfigured!\\n\");\n\t\t\t\tdomain->num_paths = 0;\n\t\t\t} else {\n\t\t\t\tdev_err_probe(dev, ret, \"failed to get noc entries\\n\");\n\t\t\t\tgoto cleanup_pds;\n\t\t\t}\n\t\t}\n\n\t\tret = devm_clk_bulk_get(dev, data->num_clks, domain->clks);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"failed to get clock\\n\");\n\t\t\tgoto cleanup_pds;\n\t\t}\n\n\t\tdomain->power_dev =\n\t\t\tdev_pm_domain_attach_by_name(dev, data->gpc_name);\n\t\tif (IS_ERR(domain->power_dev)) {\n\t\t\tdev_err_probe(dev, PTR_ERR(domain->power_dev),\n\t\t\t\t      \"failed to attach power domain \\\"%s\\\"\\n\",\n\t\t\t\t      data->gpc_name);\n\t\t\tret = PTR_ERR(domain->power_dev);\n\t\t\tgoto cleanup_pds;\n\t\t}\n\n\t\tdomain->genpd.name = data->name;\n\t\tdomain->genpd.power_on = imx8m_blk_ctrl_power_on;\n\t\tdomain->genpd.power_off = imx8m_blk_ctrl_power_off;\n\t\tdomain->bc = bc;\n\n\t\tret = pm_genpd_init(&domain->genpd, NULL, true);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret,\n\t\t\t\t      \"failed to init power domain \\\"%s\\\"\\n\",\n\t\t\t\t      data->gpc_name);\n\t\t\tdev_pm_domain_detach(domain->power_dev, true);\n\t\t\tgoto cleanup_pds;\n\t\t}\n\n\t\t \n\t\tlockdep_set_class(&domain->genpd.mlock,\n\t\t\t\t  &blk_ctrl_genpd_lock_class);\n\n\t\tbc->onecell_data.domains[i] = &domain->genpd;\n\t}\n\n\tret = of_genpd_add_provider_onecell(dev->of_node, &bc->onecell_data);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to add power domain provider\\n\");\n\t\tgoto cleanup_pds;\n\t}\n\n\tbc->power_nb.notifier_call = bc_data->power_notifier_fn;\n\tret = dev_pm_genpd_add_notifier(bc->bus_power_dev, &bc->power_nb);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to add power notifier\\n\");\n\t\tgoto cleanup_provider;\n\t}\n\n\tdev_set_drvdata(dev, bc);\n\n\tret = devm_of_platform_populate(dev);\n\tif (ret)\n\t\tgoto cleanup_provider;\n\n\treturn 0;\n\ncleanup_provider:\n\tof_genpd_del_provider(dev->of_node);\ncleanup_pds:\n\tfor (i--; i >= 0; i--) {\n\t\tpm_genpd_remove(&bc->domains[i].genpd);\n\t\tdev_pm_domain_detach(bc->domains[i].power_dev, true);\n\t}\n\n\tdev_pm_domain_detach(bc->bus_power_dev, true);\n\n\treturn ret;\n}\n\nstatic int imx8m_blk_ctrl_remove(struct platform_device *pdev)\n{\n\tstruct imx8m_blk_ctrl *bc = dev_get_drvdata(&pdev->dev);\n\tint i;\n\n\tof_genpd_del_provider(pdev->dev.of_node);\n\n\tfor (i = 0; bc->onecell_data.num_domains; i++) {\n\t\tstruct imx8m_blk_ctrl_domain *domain = &bc->domains[i];\n\n\t\tpm_genpd_remove(&domain->genpd);\n\t\tdev_pm_domain_detach(domain->power_dev, true);\n\t}\n\n\tdev_pm_genpd_remove_notifier(bc->bus_power_dev);\n\n\tdev_pm_domain_detach(bc->bus_power_dev, true);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int imx8m_blk_ctrl_suspend(struct device *dev)\n{\n\tstruct imx8m_blk_ctrl *bc = dev_get_drvdata(dev);\n\tint ret, i;\n\n\t \n\tret = pm_runtime_get_sync(bc->bus_power_dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(bc->bus_power_dev);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < bc->onecell_data.num_domains; i++) {\n\t\tstruct imx8m_blk_ctrl_domain *domain = &bc->domains[i];\n\n\t\tret = pm_runtime_get_sync(domain->power_dev);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_noidle(domain->power_dev);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_fail:\n\tfor (i--; i >= 0; i--)\n\t\tpm_runtime_put(bc->domains[i].power_dev);\n\n\tpm_runtime_put(bc->bus_power_dev);\n\n\treturn ret;\n}\n\nstatic int imx8m_blk_ctrl_resume(struct device *dev)\n{\n\tstruct imx8m_blk_ctrl *bc = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < bc->onecell_data.num_domains; i++)\n\t\tpm_runtime_put(bc->domains[i].power_dev);\n\n\tpm_runtime_put(bc->bus_power_dev);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops imx8m_blk_ctrl_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(imx8m_blk_ctrl_suspend, imx8m_blk_ctrl_resume)\n};\n\nstatic int imx8mm_vpu_power_notifier(struct notifier_block *nb,\n\t\t\t\t     unsigned long action, void *data)\n{\n\tstruct imx8m_blk_ctrl *bc = container_of(nb, struct imx8m_blk_ctrl,\n\t\t\t\t\t\t power_nb);\n\n\tif (action != GENPD_NOTIFY_ON && action != GENPD_NOTIFY_PRE_OFF)\n\t\treturn NOTIFY_OK;\n\n\t \n\tregmap_clear_bits(bc->regmap, BLK_SFT_RSTN, BIT(0) | BIT(1) | BIT(2));\n\tregmap_set_bits(bc->regmap, BLK_CLK_EN, BIT(0) | BIT(1) | BIT(2));\n\n\tif (action == GENPD_NOTIFY_ON) {\n\t\t \n\t\tudelay(5);\n\n\t\t \n\t\tregmap_set_bits(bc->regmap, 0x8, 0xffffffff);\n\t\tregmap_set_bits(bc->regmap, 0xc, 0xffffffff);\n\t\tregmap_set_bits(bc->regmap, 0x10, 0xffffffff);\n\t\tregmap_set_bits(bc->regmap, 0x14, 0xffffffff);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic const struct imx8m_blk_ctrl_domain_data imx8mm_vpu_blk_ctl_domain_data[] = {\n\t[IMX8MM_VPUBLK_PD_G1] = {\n\t\t.name = \"vpublk-g1\",\n\t\t.clk_names = (const char *[]){ \"g1\", },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"g1\",\n\t\t.rst_mask = BIT(1),\n\t\t.clk_mask = BIT(1),\n\t},\n\t[IMX8MM_VPUBLK_PD_G2] = {\n\t\t.name = \"vpublk-g2\",\n\t\t.clk_names = (const char *[]){ \"g2\", },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"g2\",\n\t\t.rst_mask = BIT(0),\n\t\t.clk_mask = BIT(0),\n\t},\n\t[IMX8MM_VPUBLK_PD_H1] = {\n\t\t.name = \"vpublk-h1\",\n\t\t.clk_names = (const char *[]){ \"h1\", },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"h1\",\n\t\t.rst_mask = BIT(2),\n\t\t.clk_mask = BIT(2),\n\t},\n};\n\nstatic const struct imx8m_blk_ctrl_data imx8mm_vpu_blk_ctl_dev_data = {\n\t.max_reg = 0x18,\n\t.power_notifier_fn = imx8mm_vpu_power_notifier,\n\t.domains = imx8mm_vpu_blk_ctl_domain_data,\n\t.num_domains = ARRAY_SIZE(imx8mm_vpu_blk_ctl_domain_data),\n};\n\nstatic const struct imx8m_blk_ctrl_domain_data imx8mp_vpu_blk_ctl_domain_data[] = {\n\t[IMX8MP_VPUBLK_PD_G1] = {\n\t\t.name = \"vpublk-g1\",\n\t\t.clk_names = (const char *[]){ \"g1\", },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"g1\",\n\t\t.rst_mask = BIT(1),\n\t\t.clk_mask = BIT(1),\n\t\t.path_names = (const char *[]){\"g1\"},\n\t\t.num_paths = 1,\n\t},\n\t[IMX8MP_VPUBLK_PD_G2] = {\n\t\t.name = \"vpublk-g2\",\n\t\t.clk_names = (const char *[]){ \"g2\", },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"g2\",\n\t\t.rst_mask = BIT(0),\n\t\t.clk_mask = BIT(0),\n\t\t.path_names = (const char *[]){\"g2\"},\n\t\t.num_paths = 1,\n\t},\n\t[IMX8MP_VPUBLK_PD_VC8000E] = {\n\t\t.name = \"vpublk-vc8000e\",\n\t\t.clk_names = (const char *[]){ \"vc8000e\", },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"vc8000e\",\n\t\t.rst_mask = BIT(2),\n\t\t.clk_mask = BIT(2),\n\t\t.path_names = (const char *[]){\"vc8000e\"},\n\t\t.num_paths = 1,\n\t},\n};\n\nstatic const struct imx8m_blk_ctrl_data imx8mp_vpu_blk_ctl_dev_data = {\n\t.max_reg = 0x18,\n\t.power_notifier_fn = imx8mm_vpu_power_notifier,\n\t.domains = imx8mp_vpu_blk_ctl_domain_data,\n\t.num_domains = ARRAY_SIZE(imx8mp_vpu_blk_ctl_domain_data),\n};\n\nstatic int imx8mm_disp_power_notifier(struct notifier_block *nb,\n\t\t\t\t      unsigned long action, void *data)\n{\n\tstruct imx8m_blk_ctrl *bc = container_of(nb, struct imx8m_blk_ctrl,\n\t\t\t\t\t\t power_nb);\n\n\tif (action != GENPD_NOTIFY_ON && action != GENPD_NOTIFY_PRE_OFF)\n\t\treturn NOTIFY_OK;\n\n\t \n\tregmap_set_bits(bc->regmap, BLK_CLK_EN, BIT(12));\n\tregmap_set_bits(bc->regmap, BLK_SFT_RSTN, BIT(6));\n\n\t \n\tif (action == GENPD_NOTIFY_ON)\n\t\tudelay(5);\n\n\n\treturn NOTIFY_OK;\n}\n\nstatic const struct imx8m_blk_ctrl_domain_data imx8mm_disp_blk_ctl_domain_data[] = {\n\t[IMX8MM_DISPBLK_PD_CSI_BRIDGE] = {\n\t\t.name = \"dispblk-csi-bridge\",\n\t\t.clk_names = (const char *[]){ \"csi-bridge-axi\", \"csi-bridge-apb\",\n\t\t\t\t\t       \"csi-bridge-core\", },\n\t\t.num_clks = 3,\n\t\t.gpc_name = \"csi-bridge\",\n\t\t.rst_mask = BIT(0) | BIT(1) | BIT(2),\n\t\t.clk_mask = BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5),\n\t},\n\t[IMX8MM_DISPBLK_PD_LCDIF] = {\n\t\t.name = \"dispblk-lcdif\",\n\t\t.clk_names = (const char *[]){ \"lcdif-axi\", \"lcdif-apb\", \"lcdif-pix\", },\n\t\t.num_clks = 3,\n\t\t.gpc_name = \"lcdif\",\n\t\t.clk_mask = BIT(6) | BIT(7),\n\t},\n\t[IMX8MM_DISPBLK_PD_MIPI_DSI] = {\n\t\t.name = \"dispblk-mipi-dsi\",\n\t\t.clk_names = (const char *[]){ \"dsi-pclk\", \"dsi-ref\", },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"mipi-dsi\",\n\t\t.rst_mask = BIT(5),\n\t\t.clk_mask = BIT(8) | BIT(9),\n\t\t.mipi_phy_rst_mask = BIT(17),\n\t},\n\t[IMX8MM_DISPBLK_PD_MIPI_CSI] = {\n\t\t.name = \"dispblk-mipi-csi\",\n\t\t.clk_names = (const char *[]){ \"csi-aclk\", \"csi-pclk\" },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"mipi-csi\",\n\t\t.rst_mask = BIT(3) | BIT(4),\n\t\t.clk_mask = BIT(10) | BIT(11),\n\t\t.mipi_phy_rst_mask = BIT(16),\n\t},\n};\n\nstatic const struct imx8m_blk_ctrl_data imx8mm_disp_blk_ctl_dev_data = {\n\t.max_reg = 0x2c,\n\t.power_notifier_fn = imx8mm_disp_power_notifier,\n\t.domains = imx8mm_disp_blk_ctl_domain_data,\n\t.num_domains = ARRAY_SIZE(imx8mm_disp_blk_ctl_domain_data),\n};\n\n\nstatic int imx8mn_disp_power_notifier(struct notifier_block *nb,\n\t\t\t\t      unsigned long action, void *data)\n{\n\tstruct imx8m_blk_ctrl *bc = container_of(nb, struct imx8m_blk_ctrl,\n\t\t\t\t\t\t power_nb);\n\n\tif (action != GENPD_NOTIFY_ON && action != GENPD_NOTIFY_PRE_OFF)\n\t\treturn NOTIFY_OK;\n\n\t \n\tregmap_set_bits(bc->regmap, BLK_CLK_EN, BIT(8));\n\tregmap_set_bits(bc->regmap, BLK_SFT_RSTN, BIT(8));\n\n\t \n\tif (action == GENPD_NOTIFY_ON)\n\t\tudelay(5);\n\n\n\treturn NOTIFY_OK;\n}\n\nstatic const struct imx8m_blk_ctrl_domain_data imx8mn_disp_blk_ctl_domain_data[] = {\n\t[IMX8MN_DISPBLK_PD_MIPI_DSI] = {\n\t\t.name = \"dispblk-mipi-dsi\",\n\t\t.clk_names = (const char *[]){ \"dsi-pclk\", \"dsi-ref\", },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"mipi-dsi\",\n\t\t.rst_mask = BIT(0) | BIT(1),\n\t\t.clk_mask = BIT(0) | BIT(1),\n\t\t.mipi_phy_rst_mask = BIT(17),\n\t},\n\t[IMX8MN_DISPBLK_PD_MIPI_CSI] = {\n\t\t.name = \"dispblk-mipi-csi\",\n\t\t.clk_names = (const char *[]){ \"csi-aclk\", \"csi-pclk\" },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"mipi-csi\",\n\t\t.rst_mask = BIT(2) | BIT(3),\n\t\t.clk_mask = BIT(2) | BIT(3),\n\t\t.mipi_phy_rst_mask = BIT(16),\n\t},\n\t[IMX8MN_DISPBLK_PD_LCDIF] = {\n\t\t.name = \"dispblk-lcdif\",\n\t\t.clk_names = (const char *[]){ \"lcdif-axi\", \"lcdif-apb\", \"lcdif-pix\", },\n\t\t.num_clks = 3,\n\t\t.gpc_name = \"lcdif\",\n\t\t.rst_mask = BIT(4) | BIT(5),\n\t\t.clk_mask = BIT(4) | BIT(5),\n\t},\n\t[IMX8MN_DISPBLK_PD_ISI] = {\n\t\t.name = \"dispblk-isi\",\n\t\t.clk_names = (const char *[]){ \"disp_axi\", \"disp_apb\", \"disp_axi_root\",\n\t\t\t\t\t\t\"disp_apb_root\"},\n\t\t.num_clks = 4,\n\t\t.gpc_name = \"isi\",\n\t\t.rst_mask = BIT(6) | BIT(7),\n\t\t.clk_mask = BIT(6) | BIT(7),\n\t},\n};\n\nstatic const struct imx8m_blk_ctrl_data imx8mn_disp_blk_ctl_dev_data = {\n\t.max_reg = 0x84,\n\t.power_notifier_fn = imx8mn_disp_power_notifier,\n\t.domains = imx8mn_disp_blk_ctl_domain_data,\n\t.num_domains = ARRAY_SIZE(imx8mn_disp_blk_ctl_domain_data),\n};\n\n#define LCDIF_ARCACHE_CTRL\t0x4c\n#define  LCDIF_1_RD_HURRY\tGENMASK(15, 13)\n#define  LCDIF_0_RD_HURRY\tGENMASK(12, 10)\n\nstatic int imx8mp_media_power_notifier(struct notifier_block *nb,\n\t\t\t\tunsigned long action, void *data)\n{\n\tstruct imx8m_blk_ctrl *bc = container_of(nb, struct imx8m_blk_ctrl,\n\t\t\t\t\t\t power_nb);\n\n\tif (action != GENPD_NOTIFY_ON && action != GENPD_NOTIFY_PRE_OFF)\n\t\treturn NOTIFY_OK;\n\n\t \n\tregmap_set_bits(bc->regmap, BLK_CLK_EN, BIT(8));\n\tregmap_set_bits(bc->regmap, BLK_SFT_RSTN, BIT(8));\n\n\tif (action == GENPD_NOTIFY_ON) {\n\t\t \n\t\tudelay(5);\n\n\t\t \n\t\tregmap_set_bits(bc->regmap, LCDIF_ARCACHE_CTRL,\n\t\t\t\tFIELD_PREP(LCDIF_1_RD_HURRY, 7) |\n\t\t\t\tFIELD_PREP(LCDIF_0_RD_HURRY, 7));\n\t}\n\n\treturn NOTIFY_OK;\n}\n\n \nstatic const struct imx8m_blk_ctrl_domain_data imx8mp_media_blk_ctl_domain_data[] = {\n\t[IMX8MP_MEDIABLK_PD_MIPI_DSI_1] = {\n\t\t.name = \"mediablk-mipi-dsi-1\",\n\t\t.clk_names = (const char *[]){ \"apb\", \"phy\", },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"mipi-dsi1\",\n\t\t.rst_mask = BIT(0) | BIT(1),\n\t\t.clk_mask = BIT(0) | BIT(1),\n\t\t.mipi_phy_rst_mask = BIT(17),\n\t},\n\t[IMX8MP_MEDIABLK_PD_MIPI_CSI2_1] = {\n\t\t.name = \"mediablk-mipi-csi2-1\",\n\t\t.clk_names = (const char *[]){ \"apb\", \"cam1\" },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"mipi-csi1\",\n\t\t.rst_mask = BIT(2) | BIT(3),\n\t\t.clk_mask = BIT(2) | BIT(3),\n\t\t.mipi_phy_rst_mask = BIT(16),\n\t},\n\t[IMX8MP_MEDIABLK_PD_LCDIF_1] = {\n\t\t.name = \"mediablk-lcdif-1\",\n\t\t.clk_names = (const char *[]){ \"disp1\", \"apb\", \"axi\", },\n\t\t.num_clks = 3,\n\t\t.gpc_name = \"lcdif1\",\n\t\t.rst_mask = BIT(4) | BIT(5) | BIT(23),\n\t\t.clk_mask = BIT(4) | BIT(5) | BIT(23),\n\t\t.path_names = (const char *[]){\"lcdif-rd\", \"lcdif-wr\"},\n\t\t.num_paths = 2,\n\t},\n\t[IMX8MP_MEDIABLK_PD_ISI] = {\n\t\t.name = \"mediablk-isi\",\n\t\t.clk_names = (const char *[]){ \"axi\", \"apb\" },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"isi\",\n\t\t.rst_mask = BIT(6) | BIT(7),\n\t\t.clk_mask = BIT(6) | BIT(7),\n\t\t.path_names = (const char *[]){\"isi0\", \"isi1\", \"isi2\"},\n\t\t.num_paths = 3,\n\t},\n\t[IMX8MP_MEDIABLK_PD_MIPI_CSI2_2] = {\n\t\t.name = \"mediablk-mipi-csi2-2\",\n\t\t.clk_names = (const char *[]){ \"apb\", \"cam2\" },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"mipi-csi2\",\n\t\t.rst_mask = BIT(9) | BIT(10),\n\t\t.clk_mask = BIT(9) | BIT(10),\n\t\t.mipi_phy_rst_mask = BIT(30),\n\t},\n\t[IMX8MP_MEDIABLK_PD_LCDIF_2] = {\n\t\t.name = \"mediablk-lcdif-2\",\n\t\t.clk_names = (const char *[]){ \"disp2\", \"apb\", \"axi\", },\n\t\t.num_clks = 3,\n\t\t.gpc_name = \"lcdif2\",\n\t\t.rst_mask = BIT(11) | BIT(12) | BIT(24),\n\t\t.clk_mask = BIT(11) | BIT(12) | BIT(24),\n\t\t.path_names = (const char *[]){\"lcdif-rd\", \"lcdif-wr\"},\n\t\t.num_paths = 2,\n\t},\n\t[IMX8MP_MEDIABLK_PD_ISP] = {\n\t\t.name = \"mediablk-isp\",\n\t\t.clk_names = (const char *[]){ \"isp\", \"axi\", \"apb\" },\n\t\t.num_clks = 3,\n\t\t.gpc_name = \"isp\",\n\t\t.rst_mask = BIT(16) | BIT(17) | BIT(18),\n\t\t.clk_mask = BIT(16) | BIT(17) | BIT(18),\n\t\t.path_names = (const char *[]){\"isp0\", \"isp1\"},\n\t\t.num_paths = 2,\n\t},\n\t[IMX8MP_MEDIABLK_PD_DWE] = {\n\t\t.name = \"mediablk-dwe\",\n\t\t.clk_names = (const char *[]){ \"axi\", \"apb\" },\n\t\t.num_clks = 2,\n\t\t.gpc_name = \"dwe\",\n\t\t.rst_mask = BIT(19) | BIT(20) | BIT(21),\n\t\t.clk_mask = BIT(19) | BIT(20) | BIT(21),\n\t\t.path_names = (const char *[]){\"dwe\"},\n\t\t.num_paths = 1,\n\t},\n\t[IMX8MP_MEDIABLK_PD_MIPI_DSI_2] = {\n\t\t.name = \"mediablk-mipi-dsi-2\",\n\t\t.clk_names = (const char *[]){ \"phy\", },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"mipi-dsi2\",\n\t\t.rst_mask = BIT(22),\n\t\t.clk_mask = BIT(22),\n\t\t.mipi_phy_rst_mask = BIT(29),\n\t},\n};\n\nstatic const struct imx8m_blk_ctrl_data imx8mp_media_blk_ctl_dev_data = {\n\t.max_reg = 0x138,\n\t.power_notifier_fn = imx8mp_media_power_notifier,\n\t.domains = imx8mp_media_blk_ctl_domain_data,\n\t.num_domains = ARRAY_SIZE(imx8mp_media_blk_ctl_domain_data),\n};\n\nstatic int imx8mq_vpu_power_notifier(struct notifier_block *nb,\n\t\t\t\t     unsigned long action, void *data)\n{\n\tstruct imx8m_blk_ctrl *bc = container_of(nb, struct imx8m_blk_ctrl,\n\t\t\t\t\t\t power_nb);\n\n\tif (action != GENPD_NOTIFY_ON && action != GENPD_NOTIFY_PRE_OFF)\n\t\treturn NOTIFY_OK;\n\n\t \n\tregmap_set_bits(bc->regmap, BLK_SFT_RSTN, BIT(0) | BIT(1));\n\tregmap_set_bits(bc->regmap, BLK_CLK_EN, BIT(0) | BIT(1));\n\n\tif (action == GENPD_NOTIFY_ON) {\n\t\t \n\t\tudelay(5);\n\n\t\t \n\t\tregmap_set_bits(bc->regmap, 0x8, 0xffffffff);\n\t\tregmap_set_bits(bc->regmap, 0xc, 0xffffffff);\n\t\tregmap_set_bits(bc->regmap, 0x10, 0xffffffff);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic const struct imx8m_blk_ctrl_domain_data imx8mq_vpu_blk_ctl_domain_data[] = {\n\t[IMX8MQ_VPUBLK_PD_G1] = {\n\t\t.name = \"vpublk-g1\",\n\t\t.clk_names = (const char *[]){ \"g1\", },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"g1\",\n\t\t.rst_mask = BIT(1),\n\t\t.clk_mask = BIT(1),\n\t},\n\t[IMX8MQ_VPUBLK_PD_G2] = {\n\t\t.name = \"vpublk-g2\",\n\t\t.clk_names = (const char *[]){ \"g2\", },\n\t\t.num_clks = 1,\n\t\t.gpc_name = \"g2\",\n\t\t.rst_mask = BIT(0),\n\t\t.clk_mask = BIT(0),\n\t},\n};\n\nstatic const struct imx8m_blk_ctrl_data imx8mq_vpu_blk_ctl_dev_data = {\n\t.max_reg = 0x14,\n\t.power_notifier_fn = imx8mq_vpu_power_notifier,\n\t.domains = imx8mq_vpu_blk_ctl_domain_data,\n\t.num_domains = ARRAY_SIZE(imx8mq_vpu_blk_ctl_domain_data),\n};\n\nstatic const struct of_device_id imx8m_blk_ctrl_of_match[] = {\n\t{\n\t\t.compatible = \"fsl,imx8mm-vpu-blk-ctrl\",\n\t\t.data = &imx8mm_vpu_blk_ctl_dev_data\n\t}, {\n\t\t.compatible = \"fsl,imx8mm-disp-blk-ctrl\",\n\t\t.data = &imx8mm_disp_blk_ctl_dev_data\n\t}, {\n\t\t.compatible = \"fsl,imx8mn-disp-blk-ctrl\",\n\t\t.data = &imx8mn_disp_blk_ctl_dev_data\n\t}, {\n\t\t.compatible = \"fsl,imx8mp-media-blk-ctrl\",\n\t\t.data = &imx8mp_media_blk_ctl_dev_data\n\t}, {\n\t\t.compatible = \"fsl,imx8mq-vpu-blk-ctrl\",\n\t\t.data = &imx8mq_vpu_blk_ctl_dev_data\n\t}, {\n\t\t.compatible = \"fsl,imx8mp-vpu-blk-ctrl\",\n\t\t.data = &imx8mp_vpu_blk_ctl_dev_data\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, imx8m_blk_ctrl_of_match);\n\nstatic struct platform_driver imx8m_blk_ctrl_driver = {\n\t.probe = imx8m_blk_ctrl_probe,\n\t.remove = imx8m_blk_ctrl_remove,\n\t.driver = {\n\t\t.name = \"imx8m-blk-ctrl\",\n\t\t.pm = &imx8m_blk_ctrl_pm_ops,\n\t\t.of_match_table = imx8m_blk_ctrl_of_match,\n\t},\n};\nmodule_platform_driver(imx8m_blk_ctrl_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}