{
  "module_name": "imx93-pd.c",
  "hash_id": "f2849ffef5828956877d314909f5fa31cb12146e2eb746067ca06df621708ec2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/imx/imx93-pd.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n\n#define MIX_SLICE_SW_CTRL_OFF\t\t0x20\n#define SLICE_SW_CTRL_PSW_CTRL_OFF_MASK\tBIT(4)\n#define SLICE_SW_CTRL_PDN_SOFT_MASK\tBIT(31)\n\n#define MIX_FUNC_STAT_OFF\t\t0xB4\n\n#define FUNC_STAT_PSW_STAT_MASK\t\tBIT(0)\n#define FUNC_STAT_RST_STAT_MASK\t\tBIT(2)\n#define FUNC_STAT_ISO_STAT_MASK\t\tBIT(4)\n\nstruct imx93_power_domain {\n\tstruct generic_pm_domain genpd;\n\tstruct device *dev;\n\tvoid __iomem *addr;\n\tstruct clk_bulk_data *clks;\n\tint num_clks;\n\tbool init_off;\n};\n\n#define to_imx93_pd(_genpd) container_of(_genpd, struct imx93_power_domain, genpd)\n\nstatic int imx93_pd_on(struct generic_pm_domain *genpd)\n{\n\tstruct imx93_power_domain *domain = to_imx93_pd(genpd);\n\tvoid __iomem *addr = domain->addr;\n\tu32 val;\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(domain->num_clks, domain->clks);\n\tif (ret) {\n\t\tdev_err(domain->dev, \"failed to enable clocks for domain: %s\\n\", genpd->name);\n\t\treturn ret;\n\t}\n\n\tval = readl(addr + MIX_SLICE_SW_CTRL_OFF);\n\tval &= ~SLICE_SW_CTRL_PDN_SOFT_MASK;\n\twritel(val, addr + MIX_SLICE_SW_CTRL_OFF);\n\n\tret = readl_poll_timeout(addr + MIX_FUNC_STAT_OFF, val,\n\t\t\t\t !(val & FUNC_STAT_ISO_STAT_MASK), 1, 10000);\n\tif (ret) {\n\t\tdev_err(domain->dev, \"pd_on timeout: name: %s, stat: %x\\n\", genpd->name, val);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx93_pd_off(struct generic_pm_domain *genpd)\n{\n\tstruct imx93_power_domain *domain = to_imx93_pd(genpd);\n\tvoid __iomem *addr = domain->addr;\n\tint ret;\n\tu32 val;\n\n\t \n\tval = readl(addr + MIX_SLICE_SW_CTRL_OFF);\n\tval |= SLICE_SW_CTRL_PDN_SOFT_MASK;\n\twritel(val, addr + MIX_SLICE_SW_CTRL_OFF);\n\n\tret = readl_poll_timeout(addr + MIX_FUNC_STAT_OFF, val,\n\t\t\t\t val & FUNC_STAT_PSW_STAT_MASK, 1, 1000);\n\tif (ret) {\n\t\tdev_err(domain->dev, \"pd_off timeout: name: %s, stat: %x\\n\", genpd->name, val);\n\t\treturn ret;\n\t}\n\n\tclk_bulk_disable_unprepare(domain->num_clks, domain->clks);\n\n\treturn 0;\n};\n\nstatic int imx93_pd_remove(struct platform_device *pdev)\n{\n\tstruct imx93_power_domain *domain = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\n\tif (!domain->init_off)\n\t\tclk_bulk_disable_unprepare(domain->num_clks, domain->clks);\n\n\tof_genpd_del_provider(np);\n\tpm_genpd_remove(&domain->genpd);\n\n\treturn 0;\n}\n\nstatic int imx93_pd_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct imx93_power_domain *domain;\n\tint ret;\n\n\tdomain = devm_kzalloc(dev, sizeof(*domain), GFP_KERNEL);\n\tif (!domain)\n\t\treturn -ENOMEM;\n\n\tdomain->addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(domain->addr))\n\t\treturn PTR_ERR(domain->addr);\n\n\tdomain->num_clks = devm_clk_bulk_get_all(dev, &domain->clks);\n\tif (domain->num_clks < 0)\n\t\treturn dev_err_probe(dev, domain->num_clks, \"Failed to get domain's clocks\\n\");\n\n\tdomain->genpd.name = dev_name(dev);\n\tdomain->genpd.power_off = imx93_pd_off;\n\tdomain->genpd.power_on = imx93_pd_on;\n\tdomain->dev = dev;\n\n\tdomain->init_off = readl(domain->addr + MIX_FUNC_STAT_OFF) & FUNC_STAT_ISO_STAT_MASK;\n\t \n\tif (!domain->init_off) {\n\t\tret = clk_bulk_prepare_enable(domain->num_clks, domain->clks);\n\t\tif (ret) {\n\t\t\tdev_err(domain->dev, \"failed to enable clocks for domain: %s\\n\",\n\t\t\t\tdomain->genpd.name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = pm_genpd_init(&domain->genpd, NULL, domain->init_off);\n\tif (ret)\n\t\tgoto err_clk_unprepare;\n\n\tplatform_set_drvdata(pdev, domain);\n\n\tret = of_genpd_add_provider_simple(np, &domain->genpd);\n\tif (ret)\n\t\tgoto err_genpd_remove;\n\n\treturn 0;\n\nerr_genpd_remove:\n\tpm_genpd_remove(&domain->genpd);\n\nerr_clk_unprepare:\n\tif (!domain->init_off)\n\t\tclk_bulk_disable_unprepare(domain->num_clks, domain->clks);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id imx93_pd_ids[] = {\n\t{ .compatible = \"fsl,imx93-src-slice\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, imx93_pd_ids);\n\nstatic struct platform_driver imx93_power_domain_driver = {\n\t.driver = {\n\t\t.name\t= \"imx93_power_domain\",\n\t\t.of_match_table = imx93_pd_ids,\n\t},\n\t.probe = imx93_pd_probe,\n\t.remove = imx93_pd_remove,\n};\nmodule_platform_driver(imx93_power_domain_driver);\n\nMODULE_AUTHOR(\"Peng Fan <peng.fan@nxp.com>\");\nMODULE_DESCRIPTION(\"NXP i.MX93 power domain driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}