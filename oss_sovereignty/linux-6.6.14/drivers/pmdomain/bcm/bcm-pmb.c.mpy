{
  "module_name": "bcm-pmb.c",
  "hash_id": "4dc25c2d4b66a485c384f7b1702785dfd2b1b4d1e8272882dd3dc59fdd7b30d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/bcm/bcm-pmb.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/soc/bcm-pmb.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/reset/bcm63xx_pmb.h>\n\n#define BPCM_ID_REG\t\t\t\t\t0x00\n#define BPCM_CAPABILITIES\t\t\t\t0x04\n#define  BPCM_CAP_NUM_ZONES\t\t\t\t0x000000ff\n#define  BPCM_CAP_SR_REG_BITS\t\t\t\t0x0000ff00\n#define  BPCM_CAP_PLLTYPE\t\t\t\t0x00030000\n#define  BPCM_CAP_UBUS\t\t\t\t\t0x00080000\n#define BPCM_CONTROL\t\t\t\t\t0x08\n#define BPCM_STATUS\t\t\t\t\t0x0c\n#define BPCM_ROSC_CONTROL\t\t\t\t0x10\n#define BPCM_ROSC_THRESH_H\t\t\t\t0x14\n#define BPCM_ROSC_THRESHOLD_BCM6838\t\t\t0x14\n#define BPCM_ROSC_THRESH_S\t\t\t\t0x18\n#define BPCM_ROSC_COUNT_BCM6838\t\t\t\t0x18\n#define BPCM_ROSC_COUNT\t\t\t\t\t0x1c\n#define BPCM_PWD_CONTROL_BCM6838\t\t\t0x1c\n#define BPCM_PWD_CONTROL\t\t\t\t0x20\n#define BPCM_SR_CONTROL_BCM6838\t\t\t\t0x20\n#define BPCM_PWD_ACCUM_CONTROL\t\t\t\t0x24\n#define BPCM_SR_CONTROL\t\t\t\t\t0x28\n#define BPCM_GLOBAL_CONTROL\t\t\t\t0x2c\n#define BPCM_MISC_CONTROL\t\t\t\t0x30\n#define BPCM_MISC_CONTROL2\t\t\t\t0x34\n#define BPCM_SGPHY_CNTL\t\t\t\t\t0x38\n#define BPCM_SGPHY_STATUS\t\t\t\t0x3c\n#define BPCM_ZONE0\t\t\t\t\t0x40\n#define  BPCM_ZONE_CONTROL\t\t\t\t0x00\n#define   BPCM_ZONE_CONTROL_MANUAL_CLK_EN\t\t0x00000001\n#define   BPCM_ZONE_CONTROL_MANUAL_RESET_CTL\t\t0x00000002\n#define   BPCM_ZONE_CONTROL_FREQ_SCALE_USED\t\t0x00000004\t \n#define   BPCM_ZONE_CONTROL_DPG_CAPABLE\t\t\t0x00000008\t \n#define   BPCM_ZONE_CONTROL_MANUAL_MEM_PWR\t\t0x00000030\n#define   BPCM_ZONE_CONTROL_MANUAL_ISO_CTL\t\t0x00000040\n#define   BPCM_ZONE_CONTROL_MANUAL_CTL\t\t\t0x00000080\n#define   BPCM_ZONE_CONTROL_DPG_CTL_EN\t\t\t0x00000100\n#define   BPCM_ZONE_CONTROL_PWR_DN_REQ\t\t\t0x00000200\n#define   BPCM_ZONE_CONTROL_PWR_UP_REQ\t\t\t0x00000400\n#define   BPCM_ZONE_CONTROL_MEM_PWR_CTL_EN\t\t0x00000800\n#define   BPCM_ZONE_CONTROL_BLK_RESET_ASSERT\t\t0x00001000\n#define   BPCM_ZONE_CONTROL_MEM_STBY\t\t\t0x00002000\n#define   BPCM_ZONE_CONTROL_RESERVED\t\t\t0x0007c000\n#define   BPCM_ZONE_CONTROL_PWR_CNTL_STATE\t\t0x00f80000\n#define   BPCM_ZONE_CONTROL_FREQ_SCALAR_DYN_SEL\t\t0x01000000\t \n#define   BPCM_ZONE_CONTROL_PWR_OFF_STATE\t\t0x02000000\t \n#define   BPCM_ZONE_CONTROL_PWR_ON_STATE\t\t0x04000000\t \n#define   BPCM_ZONE_CONTROL_PWR_GOOD\t\t\t0x08000000\t \n#define   BPCM_ZONE_CONTROL_DPG_PWR_STATE\t\t0x10000000\t \n#define   BPCM_ZONE_CONTROL_MEM_PWR_STATE\t\t0x20000000\t \n#define   BPCM_ZONE_CONTROL_ISO_STATE\t\t\t0x40000000\t \n#define   BPCM_ZONE_CONTROL_RESET_STATE\t\t\t0x80000000\t \n#define  BPCM_ZONE_CONFIG1\t\t\t\t0x04\n#define  BPCM_ZONE_CONFIG2\t\t\t\t0x08\n#define  BPCM_ZONE_FREQ_SCALAR_CONTROL\t\t\t0x0c\n#define  BPCM_ZONE_SIZE\t\t\t\t\t0x10\n\nstruct bcm_pmb {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tspinlock_t lock;\n\tbool little_endian;\n\tstruct genpd_onecell_data genpd_onecell_data;\n};\n\nstruct bcm_pmb_pd_data {\n\tconst char * const name;\n\tint id;\n\tu8 bus;\n\tu8 device;\n};\n\nstruct bcm_pmb_pm_domain {\n\tstruct bcm_pmb *pmb;\n\tconst struct bcm_pmb_pd_data *data;\n\tstruct generic_pm_domain genpd;\n};\n\nstatic int bcm_pmb_bpcm_read(struct bcm_pmb *pmb, int bus, u8 device,\n\t\t\t     int offset, u32 *val)\n{\n\tvoid __iomem *base = pmb->base + bus * 0x20;\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&pmb->lock, flags);\n\terr = bpcm_rd(base, device, offset, val);\n\tspin_unlock_irqrestore(&pmb->lock, flags);\n\n\tif (!err)\n\t\t*val = pmb->little_endian ? le32_to_cpu(*val) : be32_to_cpu(*val);\n\n\treturn err;\n}\n\nstatic int bcm_pmb_bpcm_write(struct bcm_pmb *pmb, int bus, u8 device,\n\t\t\t      int offset, u32 val)\n{\n\tvoid __iomem *base = pmb->base + bus * 0x20;\n\tunsigned long flags;\n\tint err;\n\n\tval = pmb->little_endian ? cpu_to_le32(val) : cpu_to_be32(val);\n\n\tspin_lock_irqsave(&pmb->lock, flags);\n\terr = bpcm_wr(base, device, offset, val);\n\tspin_unlock_irqrestore(&pmb->lock, flags);\n\n\treturn err;\n}\n\nstatic int bcm_pmb_power_off_zone(struct bcm_pmb *pmb, int bus, u8 device,\n\t\t\t\t  int zone)\n{\n\tint offset;\n\tu32 val;\n\tint err;\n\n\toffset = BPCM_ZONE0 + zone * BPCM_ZONE_SIZE + BPCM_ZONE_CONTROL;\n\n\terr = bcm_pmb_bpcm_read(pmb, bus, device, offset, &val);\n\tif (err)\n\t\treturn err;\n\n\tval |= BPCM_ZONE_CONTROL_PWR_DN_REQ;\n\tval &= ~BPCM_ZONE_CONTROL_PWR_UP_REQ;\n\n\terr = bcm_pmb_bpcm_write(pmb, bus, device, offset, val);\n\n\treturn err;\n}\n\nstatic int bcm_pmb_power_on_zone(struct bcm_pmb *pmb, int bus, u8 device,\n\t\t\t\t int zone)\n{\n\tint offset;\n\tu32 val;\n\tint err;\n\n\toffset = BPCM_ZONE0 + zone * BPCM_ZONE_SIZE + BPCM_ZONE_CONTROL;\n\n\terr = bcm_pmb_bpcm_read(pmb, bus, device, offset, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (!(val & BPCM_ZONE_CONTROL_PWR_ON_STATE)) {\n\t\tval &= ~BPCM_ZONE_CONTROL_PWR_DN_REQ;\n\t\tval |= BPCM_ZONE_CONTROL_DPG_CTL_EN;\n\t\tval |= BPCM_ZONE_CONTROL_PWR_UP_REQ;\n\t\tval |= BPCM_ZONE_CONTROL_MEM_PWR_CTL_EN;\n\t\tval |= BPCM_ZONE_CONTROL_BLK_RESET_ASSERT;\n\n\t\terr = bcm_pmb_bpcm_write(pmb, bus, device, offset, val);\n\t}\n\n\treturn err;\n}\n\nstatic int bcm_pmb_power_off_device(struct bcm_pmb *pmb, int bus, u8 device)\n{\n\tint offset;\n\tu32 val;\n\tint err;\n\n\t \n\toffset = BPCM_ZONE0 + BPCM_ZONE_CONTROL;\n\n\terr = bcm_pmb_bpcm_read(pmb, bus, device, offset, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (!(val & BPCM_ZONE_CONTROL_PWR_OFF_STATE)) {\n\t\tval = BPCM_ZONE_CONTROL_PWR_DN_REQ;\n\n\t\terr = bcm_pmb_bpcm_write(pmb, bus, device, offset, val);\n\t}\n\n\treturn err;\n}\n\nstatic int bcm_pmb_power_on_device(struct bcm_pmb *pmb, int bus, u8 device)\n{\n\tu32 val;\n\tint err;\n\tint i;\n\n\terr = bcm_pmb_bpcm_read(pmb, bus, device, BPCM_CAPABILITIES, &val);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < (val & BPCM_CAP_NUM_ZONES); i++) {\n\t\terr = bcm_pmb_power_on_zone(pmb, bus, device, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int bcm_pmb_power_on_sata(struct bcm_pmb *pmb, int bus, u8 device)\n{\n\tint err;\n\n\terr = bcm_pmb_power_on_zone(pmb, bus, device, 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = bcm_pmb_bpcm_write(pmb, bus, device, BPCM_MISC_CONTROL, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = bcm_pmb_bpcm_write(pmb, bus, device, BPCM_SR_CONTROL, 0xffffffff);\n\tif (err)\n\t\treturn err;\n\n\terr = bcm_pmb_bpcm_write(pmb, bus, device, BPCM_SR_CONTROL, 0);\n\n\treturn err;\n}\n\nstatic int bcm_pmb_power_on(struct generic_pm_domain *genpd)\n{\n\tstruct bcm_pmb_pm_domain *pd = container_of(genpd, struct bcm_pmb_pm_domain, genpd);\n\tconst struct bcm_pmb_pd_data *data = pd->data;\n\tstruct bcm_pmb *pmb = pd->pmb;\n\n\tswitch (data->id) {\n\tcase BCM_PMB_PCIE0:\n\tcase BCM_PMB_PCIE1:\n\tcase BCM_PMB_PCIE2:\n\t\treturn bcm_pmb_power_on_zone(pmb, data->bus, data->device, 0);\n\tcase BCM_PMB_HOST_USB:\n\t\treturn bcm_pmb_power_on_device(pmb, data->bus, data->device);\n\tcase BCM_PMB_SATA:\n\t\treturn bcm_pmb_power_on_sata(pmb, data->bus, data->device);\n\tdefault:\n\t\tdev_err(pmb->dev, \"unsupported device id: %d\\n\", data->id);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bcm_pmb_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct bcm_pmb_pm_domain *pd = container_of(genpd, struct bcm_pmb_pm_domain, genpd);\n\tconst struct bcm_pmb_pd_data *data = pd->data;\n\tstruct bcm_pmb *pmb = pd->pmb;\n\n\tswitch (data->id) {\n\tcase BCM_PMB_PCIE0:\n\tcase BCM_PMB_PCIE1:\n\tcase BCM_PMB_PCIE2:\n\t\treturn bcm_pmb_power_off_zone(pmb, data->bus, data->device, 0);\n\tcase BCM_PMB_HOST_USB:\n\t\treturn bcm_pmb_power_off_device(pmb, data->bus, data->device);\n\tdefault:\n\t\tdev_err(pmb->dev, \"unsupported device id: %d\\n\", data->id);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bcm_pmb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct bcm_pmb_pd_data *table;\n\tconst struct bcm_pmb_pd_data *e;\n\tstruct bcm_pmb *pmb;\n\tint max_id;\n\tint err;\n\n\tpmb = devm_kzalloc(dev, sizeof(*pmb), GFP_KERNEL);\n\tif (!pmb)\n\t\treturn -ENOMEM;\n\n\tpmb->dev = dev;\n\n\tpmb->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pmb->base))\n\t\treturn PTR_ERR(pmb->base);\n\n\tspin_lock_init(&pmb->lock);\n\n\tpmb->little_endian = !of_device_is_big_endian(dev->of_node);\n\n\ttable = of_device_get_match_data(dev);\n\tif (!table)\n\t\treturn -EINVAL;\n\n\tmax_id = 0;\n\tfor (e = table; e->name; e++)\n\t\tmax_id = max(max_id, e->id);\n\n\tpmb->genpd_onecell_data.num_domains = max_id + 1;\n\tpmb->genpd_onecell_data.domains =\n\t\tdevm_kcalloc(dev, pmb->genpd_onecell_data.num_domains,\n\t\t\t     sizeof(struct generic_pm_domain *), GFP_KERNEL);\n\tif (!pmb->genpd_onecell_data.domains)\n\t\treturn -ENOMEM;\n\n\tfor (e = table; e->name; e++) {\n\t\tstruct bcm_pmb_pm_domain *pd = devm_kzalloc(dev, sizeof(*pd), GFP_KERNEL);\n\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tpd->pmb = pmb;\n\t\tpd->data = e;\n\t\tpd->genpd.name = e->name;\n\t\tpd->genpd.power_on = bcm_pmb_power_on;\n\t\tpd->genpd.power_off = bcm_pmb_power_off;\n\n\t\tpm_genpd_init(&pd->genpd, NULL, true);\n\t\tpmb->genpd_onecell_data.domains[e->id] = &pd->genpd;\n\t}\n\n\terr = of_genpd_add_provider_onecell(dev->of_node, &pmb->genpd_onecell_data);\n\tif (err) {\n\t\tdev_err(dev, \"failed to add genpd provider: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct bcm_pmb_pd_data bcm_pmb_bcm4908_data[] = {\n\t{ .name = \"pcie2\", .id = BCM_PMB_PCIE2, .bus = 0, .device = 2, },\n\t{ .name = \"pcie0\", .id = BCM_PMB_PCIE0, .bus = 1, .device = 14, },\n\t{ .name = \"pcie1\", .id = BCM_PMB_PCIE1, .bus = 1, .device = 15, },\n\t{ .name = \"usb\", .id = BCM_PMB_HOST_USB, .bus = 1, .device = 17, },\n\t{ },\n};\n\nstatic const struct bcm_pmb_pd_data bcm_pmb_bcm63138_data[] = {\n\t{ .name = \"sata\", .id = BCM_PMB_SATA, .bus = 0, .device = 3, },\n\t{ },\n};\n\nstatic const struct of_device_id bcm_pmb_of_match[] = {\n\t{ .compatible = \"brcm,bcm4908-pmb\", .data = &bcm_pmb_bcm4908_data, },\n\t{ .compatible = \"brcm,bcm63138-pmb\", .data = &bcm_pmb_bcm63138_data, },\n\t{ },\n};\n\nstatic struct platform_driver bcm_pmb_driver = {\n\t.driver = {\n\t\t.name = \"bcm-pmb\",\n\t\t.of_match_table = bcm_pmb_of_match,\n\t},\n\t.probe  = bcm_pmb_probe,\n};\n\nbuiltin_platform_driver(bcm_pmb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}