{
  "module_name": "bcm63xx-power.c",
  "hash_id": "63f461779646f8ffbefbbcb3c8111584302e8ad80844d05eec29eb8b4fdcea79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/bcm/bcm63xx-power.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/soc/bcm6318-pm.h>\n#include <dt-bindings/soc/bcm6328-pm.h>\n#include <dt-bindings/soc/bcm6362-pm.h>\n#include <dt-bindings/soc/bcm63268-pm.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/of.h>\n\nstruct bcm63xx_power_dev {\n\tstruct generic_pm_domain genpd;\n\tstruct bcm63xx_power *power;\n\tuint32_t mask;\n};\n\nstruct bcm63xx_power {\n\tvoid __iomem *base;\n\tspinlock_t lock;\n\tstruct bcm63xx_power_dev *dev;\n\tstruct genpd_onecell_data genpd_data;\n\tstruct generic_pm_domain **genpd;\n};\n\nstruct bcm63xx_power_data {\n\tconst char * const name;\n\tuint8_t bit;\n\tunsigned int flags;\n};\n\nstatic int bcm63xx_power_get_state(struct bcm63xx_power_dev *pmd, bool *is_on)\n{\n\tstruct bcm63xx_power *power = pmd->power;\n\n\tif (!pmd->mask) {\n\t\t*is_on = false;\n\t\treturn -EINVAL;\n\t}\n\n\t*is_on = !(__raw_readl(power->base) & pmd->mask);\n\n\treturn 0;\n}\n\nstatic int bcm63xx_power_set_state(struct bcm63xx_power_dev *pmd, bool on)\n{\n\tstruct bcm63xx_power *power = pmd->power;\n\tunsigned long flags;\n\tuint32_t val;\n\n\tif (!pmd->mask)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&power->lock, flags);\n\tval = __raw_readl(power->base);\n\tif (on)\n\t\tval &= ~pmd->mask;\n\telse\n\t\tval |= pmd->mask;\n\t__raw_writel(val, power->base);\n\tspin_unlock_irqrestore(&power->lock, flags);\n\n\treturn 0;\n}\n\nstatic int bcm63xx_power_on(struct generic_pm_domain *genpd)\n{\n\tstruct bcm63xx_power_dev *pmd = container_of(genpd,\n\t\tstruct bcm63xx_power_dev, genpd);\n\n\treturn bcm63xx_power_set_state(pmd, true);\n}\n\nstatic int bcm63xx_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct bcm63xx_power_dev *pmd = container_of(genpd,\n\t\tstruct bcm63xx_power_dev, genpd);\n\n\treturn bcm63xx_power_set_state(pmd, false);\n}\n\nstatic int bcm63xx_power_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct bcm63xx_power_data *entry, *table;\n\tstruct bcm63xx_power *power;\n\tunsigned int ndom;\n\tuint8_t max_bit = 0;\n\tint ret;\n\n\tpower = devm_kzalloc(dev, sizeof(*power), GFP_KERNEL);\n\tif (!power)\n\t\treturn -ENOMEM;\n\n\tpower->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(power->base))\n\t\treturn PTR_ERR(power->base);\n\n\ttable = of_device_get_match_data(dev);\n\tif (!table)\n\t\treturn -EINVAL;\n\n\tpower->genpd_data.num_domains = 0;\n\tndom = 0;\n\tfor (entry = table; entry->name; entry++) {\n\t\tmax_bit = max(max_bit, entry->bit);\n\t\tndom++;\n\t}\n\n\tif (!ndom)\n\t\treturn -ENODEV;\n\n\tpower->genpd_data.num_domains = max_bit + 1;\n\n\tpower->dev = devm_kcalloc(dev, power->genpd_data.num_domains,\n\t\t\t\t  sizeof(struct bcm63xx_power_dev),\n\t\t\t\t  GFP_KERNEL);\n\tif (!power->dev)\n\t\treturn -ENOMEM;\n\n\tpower->genpd = devm_kcalloc(dev, power->genpd_data.num_domains,\n\t\t\t\t    sizeof(struct generic_pm_domain *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!power->genpd)\n\t\treturn -ENOMEM;\n\n\tpower->genpd_data.domains = power->genpd;\n\n\tndom = 0;\n\tfor (entry = table; entry->name; entry++) {\n\t\tstruct bcm63xx_power_dev *pmd = &power->dev[ndom];\n\t\tbool is_on;\n\n\t\tpmd->power = power;\n\t\tpmd->mask = BIT(entry->bit);\n\t\tpmd->genpd.name = entry->name;\n\t\tpmd->genpd.flags = entry->flags;\n\n\t\tret = bcm63xx_power_get_state(pmd, &is_on);\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"unable to get current state for %s\\n\",\n\t\t\t\t pmd->genpd.name);\n\n\t\tpmd->genpd.power_on = bcm63xx_power_on;\n\t\tpmd->genpd.power_off = bcm63xx_power_off;\n\n\t\tpm_genpd_init(&pmd->genpd, NULL, !is_on);\n\t\tpower->genpd[entry->bit] = &pmd->genpd;\n\n\t\tndom++;\n\t}\n\n\tspin_lock_init(&power->lock);\n\n\tret = of_genpd_add_provider_onecell(np, &power->genpd_data);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register genpd driver: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_info(dev, \"registered %u power domains\\n\", ndom);\n\n\treturn 0;\n}\n\nstatic const struct bcm63xx_power_data bcm6318_power_domains[] = {\n\t{\n\t\t.name = \"pcie\",\n\t\t.bit = BCM6318_POWER_DOMAIN_PCIE,\n\t}, {\n\t\t.name = \"usb\",\n\t\t.bit = BCM6318_POWER_DOMAIN_USB,\n\t}, {\n\t\t.name = \"ephy0\",\n\t\t.bit = BCM6318_POWER_DOMAIN_EPHY0,\n\t}, {\n\t\t.name = \"ephy1\",\n\t\t.bit = BCM6318_POWER_DOMAIN_EPHY1,\n\t}, {\n\t\t.name = \"ephy2\",\n\t\t.bit = BCM6318_POWER_DOMAIN_EPHY2,\n\t}, {\n\t\t.name = \"ephy3\",\n\t\t.bit = BCM6318_POWER_DOMAIN_EPHY3,\n\t}, {\n\t\t.name = \"ldo2p5\",\n\t\t.bit = BCM6318_POWER_DOMAIN_LDO2P5,\n\t\t.flags = GENPD_FLAG_ALWAYS_ON,\n\t}, {\n\t\t.name = \"ldo2p9\",\n\t\t.bit = BCM6318_POWER_DOMAIN_LDO2P9,\n\t\t.flags = GENPD_FLAG_ALWAYS_ON,\n\t}, {\n\t\t.name = \"sw1p0\",\n\t\t.bit = BCM6318_POWER_DOMAIN_SW1P0,\n\t\t.flags = GENPD_FLAG_ALWAYS_ON,\n\t}, {\n\t\t.name = \"pad\",\n\t\t.bit = BCM6318_POWER_DOMAIN_PAD,\n\t\t.flags = GENPD_FLAG_ALWAYS_ON,\n\t}, {\n\t\t \n\t},\n};\n\nstatic const struct bcm63xx_power_data bcm6328_power_domains[] = {\n\t{\n\t\t.name = \"adsl2-mips\",\n\t\t.bit = BCM6328_POWER_DOMAIN_ADSL2_MIPS,\n\t}, {\n\t\t.name = \"adsl2-phy\",\n\t\t.bit = BCM6328_POWER_DOMAIN_ADSL2_PHY,\n\t}, {\n\t\t.name = \"adsl2-afe\",\n\t\t.bit = BCM6328_POWER_DOMAIN_ADSL2_AFE,\n\t}, {\n\t\t.name = \"sar\",\n\t\t.bit = BCM6328_POWER_DOMAIN_SAR,\n\t}, {\n\t\t.name = \"pcm\",\n\t\t.bit = BCM6328_POWER_DOMAIN_PCM,\n\t}, {\n\t\t.name = \"usbd\",\n\t\t.bit = BCM6328_POWER_DOMAIN_USBD,\n\t}, {\n\t\t.name = \"usbh\",\n\t\t.bit = BCM6328_POWER_DOMAIN_USBH,\n\t}, {\n\t\t.name = \"pcie\",\n\t\t.bit = BCM6328_POWER_DOMAIN_PCIE,\n\t}, {\n\t\t.name = \"robosw\",\n\t\t.bit = BCM6328_POWER_DOMAIN_ROBOSW,\n\t}, {\n\t\t.name = \"ephy\",\n\t\t.bit = BCM6328_POWER_DOMAIN_EPHY,\n\t}, {\n\t\t \n\t},\n};\n\nstatic const struct bcm63xx_power_data bcm6362_power_domains[] = {\n\t{\n\t\t.name = \"sar\",\n\t\t.bit = BCM6362_POWER_DOMAIN_SAR,\n\t}, {\n\t\t.name = \"ipsec\",\n\t\t.bit = BCM6362_POWER_DOMAIN_IPSEC,\n\t}, {\n\t\t.name = \"mips\",\n\t\t.bit = BCM6362_POWER_DOMAIN_MIPS,\n\t\t.flags = GENPD_FLAG_ALWAYS_ON,\n\t}, {\n\t\t.name = \"dect\",\n\t\t.bit = BCM6362_POWER_DOMAIN_DECT,\n\t}, {\n\t\t.name = \"usbh\",\n\t\t.bit = BCM6362_POWER_DOMAIN_USBH,\n\t}, {\n\t\t.name = \"usbd\",\n\t\t.bit = BCM6362_POWER_DOMAIN_USBD,\n\t}, {\n\t\t.name = \"robosw\",\n\t\t.bit = BCM6362_POWER_DOMAIN_ROBOSW,\n\t}, {\n\t\t.name = \"pcm\",\n\t\t.bit = BCM6362_POWER_DOMAIN_PCM,\n\t}, {\n\t\t.name = \"periph\",\n\t\t.bit = BCM6362_POWER_DOMAIN_PERIPH,\n\t\t.flags = GENPD_FLAG_ALWAYS_ON,\n\t}, {\n\t\t.name = \"adsl-phy\",\n\t\t.bit = BCM6362_POWER_DOMAIN_ADSL_PHY,\n\t}, {\n\t\t.name = \"gmii-pads\",\n\t\t.bit = BCM6362_POWER_DOMAIN_GMII_PADS,\n\t}, {\n\t\t.name = \"fap\",\n\t\t.bit = BCM6362_POWER_DOMAIN_FAP,\n\t}, {\n\t\t.name = \"pcie\",\n\t\t.bit = BCM6362_POWER_DOMAIN_PCIE,\n\t}, {\n\t\t.name = \"wlan-pads\",\n\t\t.bit = BCM6362_POWER_DOMAIN_WLAN_PADS,\n\t}, {\n\t\t \n\t},\n};\n\nstatic const struct bcm63xx_power_data bcm63268_power_domains[] = {\n\t{\n\t\t.name = \"sar\",\n\t\t.bit = BCM63268_POWER_DOMAIN_SAR,\n\t}, {\n\t\t.name = \"ipsec\",\n\t\t.bit = BCM63268_POWER_DOMAIN_IPSEC,\n\t}, {\n\t\t.name = \"mips\",\n\t\t.bit = BCM63268_POWER_DOMAIN_MIPS,\n\t\t.flags = GENPD_FLAG_ALWAYS_ON,\n\t}, {\n\t\t.name = \"dect\",\n\t\t.bit = BCM63268_POWER_DOMAIN_DECT,\n\t}, {\n\t\t.name = \"usbh\",\n\t\t.bit = BCM63268_POWER_DOMAIN_USBH,\n\t}, {\n\t\t.name = \"usbd\",\n\t\t.bit = BCM63268_POWER_DOMAIN_USBD,\n\t}, {\n\t\t.name = \"robosw\",\n\t\t.bit = BCM63268_POWER_DOMAIN_ROBOSW,\n\t}, {\n\t\t.name = \"pcm\",\n\t\t.bit = BCM63268_POWER_DOMAIN_PCM,\n\t}, {\n\t\t.name = \"periph\",\n\t\t.bit = BCM63268_POWER_DOMAIN_PERIPH,\n\t\t.flags = GENPD_FLAG_ALWAYS_ON,\n\t}, {\n\t\t.name = \"vdsl-phy\",\n\t\t.bit = BCM63268_POWER_DOMAIN_VDSL_PHY,\n\t}, {\n\t\t.name = \"vdsl-mips\",\n\t\t.bit = BCM63268_POWER_DOMAIN_VDSL_MIPS,\n\t}, {\n\t\t.name = \"fap\",\n\t\t.bit = BCM63268_POWER_DOMAIN_FAP,\n\t}, {\n\t\t.name = \"pcie\",\n\t\t.bit = BCM63268_POWER_DOMAIN_PCIE,\n\t}, {\n\t\t.name = \"wlan-pads\",\n\t\t.bit = BCM63268_POWER_DOMAIN_WLAN_PADS,\n\t}, {\n\t\t \n\t},\n};\n\nstatic const struct of_device_id bcm63xx_power_of_match[] = {\n\t{\n\t\t.compatible = \"brcm,bcm6318-power-controller\",\n\t\t.data = &bcm6318_power_domains,\n\t}, {\n\t\t.compatible = \"brcm,bcm6328-power-controller\",\n\t\t.data = &bcm6328_power_domains,\n\t}, {\n\t\t.compatible = \"brcm,bcm6362-power-controller\",\n\t\t.data = &bcm6362_power_domains,\n\t}, {\n\t\t.compatible = \"brcm,bcm63268-power-controller\",\n\t\t.data = &bcm63268_power_domains,\n\t}, {\n\t\t \n\t}\n};\n\nstatic struct platform_driver bcm63xx_power_driver = {\n\t.driver = {\n\t\t.name = \"bcm63xx-power-controller\",\n\t\t.of_match_table = bcm63xx_power_of_match,\n\t},\n\t.probe  = bcm63xx_power_probe,\n};\nbuiltin_platform_driver(bcm63xx_power_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}