{
  "module_name": "bcm2835-power.c",
  "hash_id": "46075c59f9e7a4352d27dad71bc33c52614b423c0c911fd7b8f7c090a320c9b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/bcm/bcm2835-power.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/soc/bcm2835-pm.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mfd/bcm2835-pm.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/reset-controller.h>\n#include <linux/types.h>\n\n#define PM_GNRIC                        0x00\n#define PM_AUDIO                        0x04\n#define PM_STATUS                       0x18\n#define PM_RSTC\t\t\t\t0x1c\n#define PM_RSTS\t\t\t\t0x20\n#define PM_WDOG\t\t\t\t0x24\n#define PM_PADS0\t\t\t0x28\n#define PM_PADS2\t\t\t0x2c\n#define PM_PADS3\t\t\t0x30\n#define PM_PADS4\t\t\t0x34\n#define PM_PADS5\t\t\t0x38\n#define PM_PADS6\t\t\t0x3c\n#define PM_CAM0\t\t\t\t0x44\n#define PM_CAM0_LDOHPEN\t\t\tBIT(2)\n#define PM_CAM0_LDOLPEN\t\t\tBIT(1)\n#define PM_CAM0_CTRLEN\t\t\tBIT(0)\n\n#define PM_CAM1\t\t\t\t0x48\n#define PM_CAM1_LDOHPEN\t\t\tBIT(2)\n#define PM_CAM1_LDOLPEN\t\t\tBIT(1)\n#define PM_CAM1_CTRLEN\t\t\tBIT(0)\n\n#define PM_CCP2TX\t\t\t0x4c\n#define PM_CCP2TX_LDOEN\t\t\tBIT(1)\n#define PM_CCP2TX_CTRLEN\t\tBIT(0)\n\n#define PM_DSI0\t\t\t\t0x50\n#define PM_DSI0_LDOHPEN\t\t\tBIT(2)\n#define PM_DSI0_LDOLPEN\t\t\tBIT(1)\n#define PM_DSI0_CTRLEN\t\t\tBIT(0)\n\n#define PM_DSI1\t\t\t\t0x54\n#define PM_DSI1_LDOHPEN\t\t\tBIT(2)\n#define PM_DSI1_LDOLPEN\t\t\tBIT(1)\n#define PM_DSI1_CTRLEN\t\t\tBIT(0)\n\n#define PM_HDMI\t\t\t\t0x58\n#define PM_HDMI_RSTDR\t\t\tBIT(19)\n#define PM_HDMI_LDOPD\t\t\tBIT(1)\n#define PM_HDMI_CTRLEN\t\t\tBIT(0)\n\n#define PM_USB\t\t\t\t0x5c\n \n#define PM_USB_CTRLEN\t\t\tBIT(0)\n\n#define PM_PXLDO\t\t\t0x60\n#define PM_PXBG\t\t\t\t0x64\n#define PM_DFT\t\t\t\t0x68\n#define PM_SMPS\t\t\t\t0x6c\n#define PM_XOSC\t\t\t\t0x70\n#define PM_SPAREW\t\t\t0x74\n#define PM_SPARER\t\t\t0x78\n#define PM_AVS_RSTDR\t\t\t0x7c\n#define PM_AVS_STAT\t\t\t0x80\n#define PM_AVS_EVENT\t\t\t0x84\n#define PM_AVS_INTEN\t\t\t0x88\n#define PM_DUMMY\t\t\t0xfc\n\n#define PM_IMAGE\t\t\t0x108\n#define PM_GRAFX\t\t\t0x10c\n#define PM_PROC\t\t\t\t0x110\n#define PM_ENAB\t\t\t\tBIT(12)\n#define PM_ISPRSTN\t\t\tBIT(8)\n#define PM_H264RSTN\t\t\tBIT(7)\n#define PM_PERIRSTN\t\t\tBIT(6)\n#define PM_V3DRSTN\t\t\tBIT(6)\n#define PM_ISFUNC\t\t\tBIT(5)\n#define PM_MRDONE\t\t\tBIT(4)\n#define PM_MEMREP\t\t\tBIT(3)\n#define PM_ISPOW\t\t\tBIT(2)\n#define PM_POWOK\t\t\tBIT(1)\n#define PM_POWUP\t\t\tBIT(0)\n#define PM_INRUSH_SHIFT\t\t\t13\n#define PM_INRUSH_3_5_MA\t\t0\n#define PM_INRUSH_5_MA\t\t\t1\n#define PM_INRUSH_10_MA\t\t\t2\n#define PM_INRUSH_20_MA\t\t\t3\n#define PM_INRUSH_MASK\t\t\t(3 << PM_INRUSH_SHIFT)\n\n#define PM_PASSWORD\t\t\t0x5a000000\n\n#define PM_WDOG_TIME_SET\t\t0x000fffff\n#define PM_RSTC_WRCFG_CLR\t\t0xffffffcf\n#define PM_RSTS_HADWRH_SET\t\t0x00000040\n#define PM_RSTC_WRCFG_SET\t\t0x00000030\n#define PM_RSTC_WRCFG_FULL_RESET\t0x00000020\n#define PM_RSTC_RESET\t\t\t0x00000102\n\n#define PM_READ(reg) readl(power->base + (reg))\n#define PM_WRITE(reg, val) writel(PM_PASSWORD | (val), power->base + (reg))\n\n#define ASB_BRDG_VERSION                0x00\n#define ASB_CPR_CTRL                    0x04\n\n#define ASB_V3D_S_CTRL\t\t\t0x08\n#define ASB_V3D_M_CTRL\t\t\t0x0c\n#define ASB_ISP_S_CTRL\t\t\t0x10\n#define ASB_ISP_M_CTRL\t\t\t0x14\n#define ASB_H264_S_CTRL\t\t\t0x18\n#define ASB_H264_M_CTRL\t\t\t0x1c\n\n#define ASB_REQ_STOP                    BIT(0)\n#define ASB_ACK                         BIT(1)\n#define ASB_EMPTY                       BIT(2)\n#define ASB_FULL                        BIT(3)\n\n#define ASB_AXI_BRDG_ID\t\t\t0x20\n\n#define BCM2835_BRDG_ID\t\t\t0x62726467\n\nstruct bcm2835_power_domain {\n\tstruct generic_pm_domain base;\n\tstruct bcm2835_power *power;\n\tu32 domain;\n\tstruct clk *clk;\n};\n\nstruct bcm2835_power {\n\tstruct device\t\t*dev;\n\t \n\tvoid __iomem\t\t*base;\n\t \n\tvoid __iomem\t\t*asb;\n\t \n\tvoid __iomem\t\t*rpivid_asb;\n\n\tstruct genpd_onecell_data pd_xlate;\n\tstruct bcm2835_power_domain domains[BCM2835_POWER_DOMAIN_COUNT];\n\tstruct reset_controller_dev reset;\n};\n\nstatic int bcm2835_asb_control(struct bcm2835_power *power, u32 reg, bool enable)\n{\n\tvoid __iomem *base = power->asb;\n\tu64 start;\n\tu32 val;\n\n\tswitch (reg) {\n\tcase 0:\n\t\treturn 0;\n\tcase ASB_V3D_S_CTRL:\n\tcase ASB_V3D_M_CTRL:\n\t\tif (power->rpivid_asb)\n\t\t\tbase = power->rpivid_asb;\n\t\tbreak;\n\t}\n\n\tstart = ktime_get_ns();\n\n\t \n\tif (enable) {\n\t\tval = readl(base + reg) & ~ASB_REQ_STOP;\n\t} else {\n\t\tval = readl(base + reg) | ASB_REQ_STOP;\n\t}\n\twritel(PM_PASSWORD | val, base + reg);\n\n\twhile (!!(readl(base + reg) & ASB_ACK) == enable) {\n\t\tcpu_relax();\n\t\tif (ktime_get_ns() - start >= 1000)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm2835_asb_enable(struct bcm2835_power *power, u32 reg)\n{\n\treturn bcm2835_asb_control(power, reg, true);\n}\n\nstatic int bcm2835_asb_disable(struct bcm2835_power *power, u32 reg)\n{\n\treturn bcm2835_asb_control(power, reg, false);\n}\n\nstatic int bcm2835_power_power_off(struct bcm2835_power_domain *pd, u32 pm_reg)\n{\n\tstruct bcm2835_power *power = pd->power;\n\n\t \n\tif (power->rpivid_asb)\n\t\treturn 0;\n\n\t \n\tPM_WRITE(pm_reg, PM_READ(pm_reg) & ~PM_ISFUNC);\n\n\t \n\tPM_WRITE(pm_reg, PM_READ(pm_reg) & ~PM_ISPOW);\n\n\t \n\tPM_WRITE(pm_reg, PM_READ(pm_reg) & ~PM_POWUP);\n\n\treturn 0;\n}\n\nstatic int bcm2835_power_power_on(struct bcm2835_power_domain *pd, u32 pm_reg)\n{\n\tstruct bcm2835_power *power = pd->power;\n\tstruct device *dev = power->dev;\n\tu64 start;\n\tint ret;\n\tint inrush;\n\tbool powok;\n\n\t \n\tif (power->rpivid_asb)\n\t\treturn 0;\n\n\t \n\tif (PM_READ(pm_reg) & PM_POWUP)\n\t\treturn 0;\n\n\t \n\tpowok = false;\n\tfor (inrush = PM_INRUSH_3_5_MA; inrush <= PM_INRUSH_20_MA; inrush++) {\n\t\tPM_WRITE(pm_reg,\n\t\t\t (PM_READ(pm_reg) & ~PM_INRUSH_MASK) |\n\t\t\t (inrush << PM_INRUSH_SHIFT) |\n\t\t\t PM_POWUP);\n\n\t\tstart = ktime_get_ns();\n\t\twhile (!(powok = !!(PM_READ(pm_reg) & PM_POWOK))) {\n\t\t\tcpu_relax();\n\t\t\tif (ktime_get_ns() - start >= 3000)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!powok) {\n\t\tdev_err(dev, \"Timeout waiting for %s power OK\\n\",\n\t\t\tpd->base.name);\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_disable_powup;\n\t}\n\n\t \n\tPM_WRITE(pm_reg, PM_READ(pm_reg) | PM_ISPOW);\n\n\t \n\tPM_WRITE(pm_reg, PM_READ(pm_reg) | PM_MEMREP);\n\tstart = ktime_get_ns();\n\twhile (!(PM_READ(pm_reg) & PM_MRDONE)) {\n\t\tcpu_relax();\n\t\tif (ktime_get_ns() - start >= 1000) {\n\t\t\tdev_err(dev, \"Timeout waiting for %s memory repair\\n\",\n\t\t\t\tpd->base.name);\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto err_disable_ispow;\n\t\t}\n\t}\n\n\t \n\tPM_WRITE(pm_reg, PM_READ(pm_reg) | PM_ISFUNC);\n\n\treturn 0;\n\nerr_disable_ispow:\n\tPM_WRITE(pm_reg, PM_READ(pm_reg) & ~PM_ISPOW);\nerr_disable_powup:\n\tPM_WRITE(pm_reg, PM_READ(pm_reg) & ~(PM_POWUP | PM_INRUSH_MASK));\n\treturn ret;\n}\n\nstatic int bcm2835_asb_power_on(struct bcm2835_power_domain *pd,\n\t\t\t\tu32 pm_reg,\n\t\t\t\tu32 asb_m_reg,\n\t\t\t\tu32 asb_s_reg,\n\t\t\t\tu32 reset_flags)\n{\n\tstruct bcm2835_power *power = pd->power;\n\tint ret;\n\n\tret = clk_prepare_enable(pd->clk);\n\tif (ret) {\n\t\tdev_err(power->dev, \"Failed to enable clock for %s\\n\",\n\t\t\tpd->base.name);\n\t\treturn ret;\n\t}\n\n\t \n\tudelay(1);\n\n\tclk_disable_unprepare(pd->clk);\n\n\t \n\tPM_WRITE(pm_reg, PM_READ(pm_reg) | reset_flags);\n\n\tret = clk_prepare_enable(pd->clk);\n\tif (ret) {\n\t\tdev_err(power->dev, \"Failed to enable clock for %s\\n\",\n\t\t\tpd->base.name);\n\t\tgoto err_enable_resets;\n\t}\n\n\tret = bcm2835_asb_enable(power, asb_m_reg);\n\tif (ret) {\n\t\tdev_err(power->dev, \"Failed to enable ASB master for %s\\n\",\n\t\t\tpd->base.name);\n\t\tgoto err_disable_clk;\n\t}\n\tret = bcm2835_asb_enable(power, asb_s_reg);\n\tif (ret) {\n\t\tdev_err(power->dev, \"Failed to enable ASB slave for %s\\n\",\n\t\t\tpd->base.name);\n\t\tgoto err_disable_asb_master;\n\t}\n\n\treturn 0;\n\nerr_disable_asb_master:\n\tbcm2835_asb_disable(power, asb_m_reg);\nerr_disable_clk:\n\tclk_disable_unprepare(pd->clk);\nerr_enable_resets:\n\tPM_WRITE(pm_reg, PM_READ(pm_reg) & ~reset_flags);\n\treturn ret;\n}\n\nstatic int bcm2835_asb_power_off(struct bcm2835_power_domain *pd,\n\t\t\t\t u32 pm_reg,\n\t\t\t\t u32 asb_m_reg,\n\t\t\t\t u32 asb_s_reg,\n\t\t\t\t u32 reset_flags)\n{\n\tstruct bcm2835_power *power = pd->power;\n\tint ret;\n\n\tret = bcm2835_asb_disable(power, asb_s_reg);\n\tif (ret) {\n\t\tdev_warn(power->dev, \"Failed to disable ASB slave for %s\\n\",\n\t\t\t pd->base.name);\n\t\treturn ret;\n\t}\n\tret = bcm2835_asb_disable(power, asb_m_reg);\n\tif (ret) {\n\t\tdev_warn(power->dev, \"Failed to disable ASB master for %s\\n\",\n\t\t\t pd->base.name);\n\t\tbcm2835_asb_enable(power, asb_s_reg);\n\t\treturn ret;\n\t}\n\n\tclk_disable_unprepare(pd->clk);\n\n\t \n\tPM_WRITE(pm_reg, PM_READ(pm_reg) & ~reset_flags);\n\n\treturn 0;\n}\n\nstatic int bcm2835_power_pd_power_on(struct generic_pm_domain *domain)\n{\n\tstruct bcm2835_power_domain *pd =\n\t\tcontainer_of(domain, struct bcm2835_power_domain, base);\n\tstruct bcm2835_power *power = pd->power;\n\n\tswitch (pd->domain) {\n\tcase BCM2835_POWER_DOMAIN_GRAFX:\n\t\treturn bcm2835_power_power_on(pd, PM_GRAFX);\n\n\tcase BCM2835_POWER_DOMAIN_GRAFX_V3D:\n\t\treturn bcm2835_asb_power_on(pd, PM_GRAFX,\n\t\t\t\t\t    ASB_V3D_M_CTRL, ASB_V3D_S_CTRL,\n\t\t\t\t\t    PM_V3DRSTN);\n\n\tcase BCM2835_POWER_DOMAIN_IMAGE:\n\t\treturn bcm2835_power_power_on(pd, PM_IMAGE);\n\n\tcase BCM2835_POWER_DOMAIN_IMAGE_PERI:\n\t\treturn bcm2835_asb_power_on(pd, PM_IMAGE,\n\t\t\t\t\t    0, 0,\n\t\t\t\t\t    PM_PERIRSTN);\n\n\tcase BCM2835_POWER_DOMAIN_IMAGE_ISP:\n\t\treturn bcm2835_asb_power_on(pd, PM_IMAGE,\n\t\t\t\t\t    ASB_ISP_M_CTRL, ASB_ISP_S_CTRL,\n\t\t\t\t\t    PM_ISPRSTN);\n\n\tcase BCM2835_POWER_DOMAIN_IMAGE_H264:\n\t\treturn bcm2835_asb_power_on(pd, PM_IMAGE,\n\t\t\t\t\t    ASB_H264_M_CTRL, ASB_H264_S_CTRL,\n\t\t\t\t\t    PM_H264RSTN);\n\n\tcase BCM2835_POWER_DOMAIN_USB:\n\t\tPM_WRITE(PM_USB, PM_USB_CTRLEN);\n\t\treturn 0;\n\n\tcase BCM2835_POWER_DOMAIN_DSI0:\n\t\tPM_WRITE(PM_DSI0, PM_DSI0_CTRLEN);\n\t\tPM_WRITE(PM_DSI0, PM_DSI0_CTRLEN | PM_DSI0_LDOHPEN);\n\t\treturn 0;\n\n\tcase BCM2835_POWER_DOMAIN_DSI1:\n\t\tPM_WRITE(PM_DSI1, PM_DSI1_CTRLEN);\n\t\tPM_WRITE(PM_DSI1, PM_DSI1_CTRLEN | PM_DSI1_LDOHPEN);\n\t\treturn 0;\n\n\tcase BCM2835_POWER_DOMAIN_CCP2TX:\n\t\tPM_WRITE(PM_CCP2TX, PM_CCP2TX_CTRLEN);\n\t\tPM_WRITE(PM_CCP2TX, PM_CCP2TX_CTRLEN | PM_CCP2TX_LDOEN);\n\t\treturn 0;\n\n\tcase BCM2835_POWER_DOMAIN_HDMI:\n\t\tPM_WRITE(PM_HDMI, PM_READ(PM_HDMI) | PM_HDMI_RSTDR);\n\t\tPM_WRITE(PM_HDMI, PM_READ(PM_HDMI) | PM_HDMI_CTRLEN);\n\t\tPM_WRITE(PM_HDMI, PM_READ(PM_HDMI) & ~PM_HDMI_LDOPD);\n\t\tusleep_range(100, 200);\n\t\tPM_WRITE(PM_HDMI, PM_READ(PM_HDMI) & ~PM_HDMI_RSTDR);\n\t\treturn 0;\n\n\tdefault:\n\t\tdev_err(power->dev, \"Invalid domain %d\\n\", pd->domain);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bcm2835_power_pd_power_off(struct generic_pm_domain *domain)\n{\n\tstruct bcm2835_power_domain *pd =\n\t\tcontainer_of(domain, struct bcm2835_power_domain, base);\n\tstruct bcm2835_power *power = pd->power;\n\n\tswitch (pd->domain) {\n\tcase BCM2835_POWER_DOMAIN_GRAFX:\n\t\treturn bcm2835_power_power_off(pd, PM_GRAFX);\n\n\tcase BCM2835_POWER_DOMAIN_GRAFX_V3D:\n\t\treturn bcm2835_asb_power_off(pd, PM_GRAFX,\n\t\t\t\t\t     ASB_V3D_M_CTRL, ASB_V3D_S_CTRL,\n\t\t\t\t\t     PM_V3DRSTN);\n\n\tcase BCM2835_POWER_DOMAIN_IMAGE:\n\t\treturn bcm2835_power_power_off(pd, PM_IMAGE);\n\n\tcase BCM2835_POWER_DOMAIN_IMAGE_PERI:\n\t\treturn bcm2835_asb_power_off(pd, PM_IMAGE,\n\t\t\t\t\t     0, 0,\n\t\t\t\t\t     PM_PERIRSTN);\n\n\tcase BCM2835_POWER_DOMAIN_IMAGE_ISP:\n\t\treturn bcm2835_asb_power_off(pd, PM_IMAGE,\n\t\t\t\t\t     ASB_ISP_M_CTRL, ASB_ISP_S_CTRL,\n\t\t\t\t\t     PM_ISPRSTN);\n\n\tcase BCM2835_POWER_DOMAIN_IMAGE_H264:\n\t\treturn bcm2835_asb_power_off(pd, PM_IMAGE,\n\t\t\t\t\t     ASB_H264_M_CTRL, ASB_H264_S_CTRL,\n\t\t\t\t\t     PM_H264RSTN);\n\n\tcase BCM2835_POWER_DOMAIN_USB:\n\t\tPM_WRITE(PM_USB, 0);\n\t\treturn 0;\n\n\tcase BCM2835_POWER_DOMAIN_DSI0:\n\t\tPM_WRITE(PM_DSI0, PM_DSI0_CTRLEN);\n\t\tPM_WRITE(PM_DSI0, 0);\n\t\treturn 0;\n\n\tcase BCM2835_POWER_DOMAIN_DSI1:\n\t\tPM_WRITE(PM_DSI1, PM_DSI1_CTRLEN);\n\t\tPM_WRITE(PM_DSI1, 0);\n\t\treturn 0;\n\n\tcase BCM2835_POWER_DOMAIN_CCP2TX:\n\t\tPM_WRITE(PM_CCP2TX, PM_CCP2TX_CTRLEN);\n\t\tPM_WRITE(PM_CCP2TX, 0);\n\t\treturn 0;\n\n\tcase BCM2835_POWER_DOMAIN_HDMI:\n\t\tPM_WRITE(PM_HDMI, PM_READ(PM_HDMI) | PM_HDMI_LDOPD);\n\t\tPM_WRITE(PM_HDMI, PM_READ(PM_HDMI) & ~PM_HDMI_CTRLEN);\n\t\treturn 0;\n\n\tdefault:\n\t\tdev_err(power->dev, \"Invalid domain %d\\n\", pd->domain);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nbcm2835_init_power_domain(struct bcm2835_power *power,\n\t\t\t  int pd_xlate_index, const char *name)\n{\n\tstruct device *dev = power->dev;\n\tstruct bcm2835_power_domain *dom = &power->domains[pd_xlate_index];\n\n\tdom->clk = devm_clk_get(dev->parent, name);\n\tif (IS_ERR(dom->clk)) {\n\t\tint ret = PTR_ERR(dom->clk);\n\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\n\t\t \n\t\tdom->clk = NULL;\n\t}\n\n\tdom->base.name = name;\n\tdom->base.power_on = bcm2835_power_pd_power_on;\n\tdom->base.power_off = bcm2835_power_pd_power_off;\n\n\tdom->domain = pd_xlate_index;\n\tdom->power = power;\n\n\t \n\tpm_genpd_init(&dom->base, NULL, true);\n\n\tpower->pd_xlate.domains[pd_xlate_index] = &dom->base;\n\n\treturn 0;\n}\n\n \nstatic int bcm2835_reset_reset(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct bcm2835_power *power = container_of(rcdev, struct bcm2835_power,\n\t\t\t\t\t\t   reset);\n\tstruct bcm2835_power_domain *pd;\n\tint ret;\n\n\tswitch (id) {\n\tcase BCM2835_RESET_V3D:\n\t\tpd = &power->domains[BCM2835_POWER_DOMAIN_GRAFX_V3D];\n\t\tbreak;\n\tcase BCM2835_RESET_H264:\n\t\tpd = &power->domains[BCM2835_POWER_DOMAIN_IMAGE_H264];\n\t\tbreak;\n\tcase BCM2835_RESET_ISP:\n\t\tpd = &power->domains[BCM2835_POWER_DOMAIN_IMAGE_ISP];\n\t\tbreak;\n\tdefault:\n\t\tdev_err(power->dev, \"Bad reset id %ld\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tret = bcm2835_power_pd_power_off(&pd->base);\n\tif (ret)\n\t\treturn ret;\n\n\treturn bcm2835_power_pd_power_on(&pd->base);\n}\n\nstatic int bcm2835_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct bcm2835_power *power = container_of(rcdev, struct bcm2835_power,\n\t\t\t\t\t\t   reset);\n\n\tswitch (id) {\n\tcase BCM2835_RESET_V3D:\n\t\treturn !PM_READ(PM_GRAFX & PM_V3DRSTN);\n\tcase BCM2835_RESET_H264:\n\t\treturn !PM_READ(PM_IMAGE & PM_H264RSTN);\n\tcase BCM2835_RESET_ISP:\n\t\treturn !PM_READ(PM_IMAGE & PM_ISPRSTN);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct reset_control_ops bcm2835_reset_ops = {\n\t.reset = bcm2835_reset_reset,\n\t.status = bcm2835_reset_status,\n};\n\nstatic const char *const power_domain_names[] = {\n\t[BCM2835_POWER_DOMAIN_GRAFX] = \"grafx\",\n\t[BCM2835_POWER_DOMAIN_GRAFX_V3D] = \"v3d\",\n\n\t[BCM2835_POWER_DOMAIN_IMAGE] = \"image\",\n\t[BCM2835_POWER_DOMAIN_IMAGE_PERI] = \"peri_image\",\n\t[BCM2835_POWER_DOMAIN_IMAGE_H264] = \"h264\",\n\t[BCM2835_POWER_DOMAIN_IMAGE_ISP] = \"isp\",\n\n\t[BCM2835_POWER_DOMAIN_USB] = \"usb\",\n\t[BCM2835_POWER_DOMAIN_DSI0] = \"dsi0\",\n\t[BCM2835_POWER_DOMAIN_DSI1] = \"dsi1\",\n\t[BCM2835_POWER_DOMAIN_CAM0] = \"cam0\",\n\t[BCM2835_POWER_DOMAIN_CAM1] = \"cam1\",\n\t[BCM2835_POWER_DOMAIN_CCP2TX] = \"ccp2tx\",\n\t[BCM2835_POWER_DOMAIN_HDMI] = \"hdmi\",\n};\n\nstatic int bcm2835_power_probe(struct platform_device *pdev)\n{\n\tstruct bcm2835_pm *pm = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm2835_power *power;\n\tstatic const struct {\n\t\tint parent, child;\n\t} domain_deps[] = {\n\t\t{ BCM2835_POWER_DOMAIN_GRAFX, BCM2835_POWER_DOMAIN_GRAFX_V3D },\n\t\t{ BCM2835_POWER_DOMAIN_IMAGE, BCM2835_POWER_DOMAIN_IMAGE_PERI },\n\t\t{ BCM2835_POWER_DOMAIN_IMAGE, BCM2835_POWER_DOMAIN_IMAGE_H264 },\n\t\t{ BCM2835_POWER_DOMAIN_IMAGE, BCM2835_POWER_DOMAIN_IMAGE_ISP },\n\t\t{ BCM2835_POWER_DOMAIN_IMAGE_PERI, BCM2835_POWER_DOMAIN_USB },\n\t\t{ BCM2835_POWER_DOMAIN_IMAGE_PERI, BCM2835_POWER_DOMAIN_CAM0 },\n\t\t{ BCM2835_POWER_DOMAIN_IMAGE_PERI, BCM2835_POWER_DOMAIN_CAM1 },\n\t};\n\tint ret = 0, i;\n\tu32 id;\n\n\tpower = devm_kzalloc(dev, sizeof(*power), GFP_KERNEL);\n\tif (!power)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, power);\n\n\tpower->dev = dev;\n\tpower->base = pm->base;\n\tpower->asb = pm->asb;\n\tpower->rpivid_asb = pm->rpivid_asb;\n\n\tid = readl(power->asb + ASB_AXI_BRDG_ID);\n\tif (id != BCM2835_BRDG_ID  ) {\n\t\tdev_err(dev, \"ASB register ID returned 0x%08x\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\tif (power->rpivid_asb) {\n\t\tid = readl(power->rpivid_asb + ASB_AXI_BRDG_ID);\n\t\tif (id != BCM2835_BRDG_ID  ) {\n\t\t\tdev_err(dev, \"RPiVid ASB register ID returned 0x%08x\\n\",\n\t\t\t\t     id);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tpower->pd_xlate.domains = devm_kcalloc(dev,\n\t\t\t\t\t       ARRAY_SIZE(power_domain_names),\n\t\t\t\t\t       sizeof(*power->pd_xlate.domains),\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!power->pd_xlate.domains)\n\t\treturn -ENOMEM;\n\n\tpower->pd_xlate.num_domains = ARRAY_SIZE(power_domain_names);\n\n\tfor (i = 0; i < ARRAY_SIZE(power_domain_names); i++) {\n\t\tret = bcm2835_init_power_domain(power, i, power_domain_names[i]);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(domain_deps); i++) {\n\t\tpm_genpd_add_subdomain(&power->domains[domain_deps[i].parent].base,\n\t\t\t\t       &power->domains[domain_deps[i].child].base);\n\t}\n\n\tpower->reset.owner = THIS_MODULE;\n\tpower->reset.nr_resets = BCM2835_RESET_COUNT;\n\tpower->reset.ops = &bcm2835_reset_ops;\n\tpower->reset.of_node = dev->parent->of_node;\n\n\tret = devm_reset_controller_register(dev, &power->reset);\n\tif (ret)\n\t\tgoto fail;\n\n\tof_genpd_add_provider_onecell(dev->parent->of_node, &power->pd_xlate);\n\n\tdev_info(dev, \"Broadcom BCM2835 power domains driver\");\n\treturn 0;\n\nfail:\n\tfor (i = 0; i < ARRAY_SIZE(power_domain_names); i++) {\n\t\tstruct generic_pm_domain *dom = &power->domains[i].base;\n\n\t\tif (dom->name)\n\t\t\tpm_genpd_remove(dom);\n\t}\n\treturn ret;\n}\n\nstatic struct platform_driver bcm2835_power_driver = {\n\t.probe\t\t= bcm2835_power_probe,\n\t.driver = {\n\t\t.name =\t\"bcm2835-power\",\n\t},\n};\nmodule_platform_driver(bcm2835_power_driver);\n\nMODULE_AUTHOR(\"Eric Anholt <eric@anholt.net>\");\nMODULE_DESCRIPTION(\"Driver for Broadcom BCM2835 PM power domains and reset\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}