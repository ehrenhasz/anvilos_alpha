{
  "module_name": "raspberrypi-power.c",
  "hash_id": "3a1bed4f1158191131062115e652759a51c991f2a3c92be5b7e17882a408d813",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/bcm/raspberrypi-power.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <dt-bindings/power/raspberrypi-power.h>\n#include <soc/bcm2835/raspberrypi-firmware.h>\n\n \n#define RPI_OLD_POWER_DOMAIN_USB\t\t3\n#define RPI_OLD_POWER_DOMAIN_V3D\t\t10\n\nstruct rpi_power_domain {\n\tu32 domain;\n\tbool enabled;\n\tbool old_interface;\n\tstruct generic_pm_domain base;\n\tstruct rpi_firmware *fw;\n};\n\nstruct rpi_power_domains {\n\tbool has_new_interface;\n\tstruct genpd_onecell_data xlate;\n\tstruct rpi_firmware *fw;\n\tstruct rpi_power_domain domains[RPI_POWER_DOMAIN_COUNT];\n};\n\n \nstruct rpi_power_domain_packet {\n\tu32 domain;\n\tu32 on;\n};\n\n \nstatic int rpi_firmware_set_power(struct rpi_power_domain *rpi_domain, bool on)\n{\n\tstruct rpi_power_domain_packet packet;\n\n\tpacket.domain = rpi_domain->domain;\n\tpacket.on = on;\n\treturn rpi_firmware_property(rpi_domain->fw,\n\t\t\t\t     rpi_domain->old_interface ?\n\t\t\t\t     RPI_FIRMWARE_SET_POWER_STATE :\n\t\t\t\t     RPI_FIRMWARE_SET_DOMAIN_STATE,\n\t\t\t\t     &packet, sizeof(packet));\n}\n\nstatic int rpi_domain_off(struct generic_pm_domain *domain)\n{\n\tstruct rpi_power_domain *rpi_domain =\n\t\tcontainer_of(domain, struct rpi_power_domain, base);\n\n\treturn rpi_firmware_set_power(rpi_domain, false);\n}\n\nstatic int rpi_domain_on(struct generic_pm_domain *domain)\n{\n\tstruct rpi_power_domain *rpi_domain =\n\t\tcontainer_of(domain, struct rpi_power_domain, base);\n\n\treturn rpi_firmware_set_power(rpi_domain, true);\n}\n\nstatic void rpi_common_init_power_domain(struct rpi_power_domains *rpi_domains,\n\t\t\t\t\t int xlate_index, const char *name)\n{\n\tstruct rpi_power_domain *dom = &rpi_domains->domains[xlate_index];\n\n\tdom->fw = rpi_domains->fw;\n\n\tdom->base.name = name;\n\tdom->base.power_on = rpi_domain_on;\n\tdom->base.power_off = rpi_domain_off;\n\n\t \n\tpm_genpd_init(&dom->base, NULL, true);\n\n\trpi_domains->xlate.domains[xlate_index] = &dom->base;\n}\n\nstatic void rpi_init_power_domain(struct rpi_power_domains *rpi_domains,\n\t\t\t\t  int xlate_index, const char *name)\n{\n\tstruct rpi_power_domain *dom = &rpi_domains->domains[xlate_index];\n\n\tif (!rpi_domains->has_new_interface)\n\t\treturn;\n\n\t \n\tdom->domain = xlate_index + 1;\n\n\trpi_common_init_power_domain(rpi_domains, xlate_index, name);\n}\n\nstatic void rpi_init_old_power_domain(struct rpi_power_domains *rpi_domains,\n\t\t\t\t      int xlate_index, int domain,\n\t\t\t\t      const char *name)\n{\n\tstruct rpi_power_domain *dom = &rpi_domains->domains[xlate_index];\n\n\tdom->old_interface = true;\n\tdom->domain = domain;\n\n\trpi_common_init_power_domain(rpi_domains, xlate_index, name);\n}\n\n \nstatic bool\nrpi_has_new_domain_support(struct rpi_power_domains *rpi_domains)\n{\n\tstruct rpi_power_domain_packet packet;\n\tint ret;\n\n\tpacket.domain = RPI_POWER_DOMAIN_ARM;\n\tpacket.on = ~0;\n\n\tret = rpi_firmware_property(rpi_domains->fw,\n\t\t\t\t    RPI_FIRMWARE_GET_DOMAIN_STATE,\n\t\t\t\t    &packet, sizeof(packet));\n\n\treturn ret == 0 && packet.on != ~0;\n}\n\nstatic int rpi_power_probe(struct platform_device *pdev)\n{\n\tstruct device_node *fw_np;\n\tstruct device *dev = &pdev->dev;\n\tstruct rpi_power_domains *rpi_domains;\n\n\trpi_domains = devm_kzalloc(dev, sizeof(*rpi_domains), GFP_KERNEL);\n\tif (!rpi_domains)\n\t\treturn -ENOMEM;\n\n\trpi_domains->xlate.domains =\n\t\tdevm_kcalloc(dev,\n\t\t\t     RPI_POWER_DOMAIN_COUNT,\n\t\t\t     sizeof(*rpi_domains->xlate.domains),\n\t\t\t     GFP_KERNEL);\n\tif (!rpi_domains->xlate.domains)\n\t\treturn -ENOMEM;\n\n\trpi_domains->xlate.num_domains = RPI_POWER_DOMAIN_COUNT;\n\n\tfw_np = of_parse_phandle(pdev->dev.of_node, \"firmware\", 0);\n\tif (!fw_np) {\n\t\tdev_err(&pdev->dev, \"no firmware node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trpi_domains->fw = devm_rpi_firmware_get(&pdev->dev, fw_np);\n\tof_node_put(fw_np);\n\tif (!rpi_domains->fw)\n\t\treturn -EPROBE_DEFER;\n\n\trpi_domains->has_new_interface =\n\t\trpi_has_new_domain_support(rpi_domains);\n\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_I2C0, \"I2C0\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_I2C1, \"I2C1\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_I2C2, \"I2C2\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_VIDEO_SCALER,\n\t\t\t      \"VIDEO_SCALER\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_VPU1, \"VPU1\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_HDMI, \"HDMI\");\n\n\t \n\trpi_init_old_power_domain(rpi_domains, RPI_POWER_DOMAIN_USB,\n\t\t\t\t  RPI_OLD_POWER_DOMAIN_USB, \"USB\");\n\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_VEC, \"VEC\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_JPEG, \"JPEG\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_H264, \"H264\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_V3D, \"V3D\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_ISP, \"ISP\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_UNICAM0, \"UNICAM0\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_UNICAM1, \"UNICAM1\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_CCP2RX, \"CCP2RX\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_CSI2, \"CSI2\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_CPI, \"CPI\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_DSI0, \"DSI0\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_DSI1, \"DSI1\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_TRANSPOSER,\n\t\t\t      \"TRANSPOSER\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_CCP2TX, \"CCP2TX\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_CDP, \"CDP\");\n\trpi_init_power_domain(rpi_domains, RPI_POWER_DOMAIN_ARM, \"ARM\");\n\n\tof_genpd_add_provider_onecell(dev->of_node, &rpi_domains->xlate);\n\n\tplatform_set_drvdata(pdev, rpi_domains);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rpi_power_of_match[] = {\n\t{ .compatible = \"raspberrypi,bcm2835-power\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rpi_power_of_match);\n\nstatic struct platform_driver rpi_power_driver = {\n\t.driver = {\n\t\t.name = \"raspberrypi-power\",\n\t\t.of_match_table = rpi_power_of_match,\n\t},\n\t.probe\t\t= rpi_power_probe,\n};\nbuiltin_platform_driver(rpi_power_driver);\n\nMODULE_AUTHOR(\"Alexander Aring <aar@pengutronix.de>\");\nMODULE_AUTHOR(\"Eric Anholt <eric@anholt.net>\");\nMODULE_DESCRIPTION(\"Raspberry Pi power domain driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}