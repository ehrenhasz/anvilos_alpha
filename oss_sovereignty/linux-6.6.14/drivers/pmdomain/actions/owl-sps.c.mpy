{
  "module_name": "owl-sps.c",
  "hash_id": "c2866b8efbb510566b497e0f6d62aaaf454b0533436d92c62456b37ee3ae1780",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/actions/owl-sps.c",
  "human_readable_source": "\n \n\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/pm_domain.h>\n#include <linux/soc/actions/owl-sps.h>\n#include <dt-bindings/power/owl-s500-powergate.h>\n#include <dt-bindings/power/owl-s700-powergate.h>\n#include <dt-bindings/power/owl-s900-powergate.h>\n\nstruct owl_sps_domain_info {\n\tconst char *name;\n\tint pwr_bit;\n\tint ack_bit;\n\tunsigned int genpd_flags;\n};\n\nstruct owl_sps_info {\n\tunsigned num_domains;\n\tconst struct owl_sps_domain_info *domains;\n};\n\nstruct owl_sps {\n\tstruct device *dev;\n\tconst struct owl_sps_info *info;\n\tvoid __iomem *base;\n\tstruct genpd_onecell_data genpd_data;\n\tstruct generic_pm_domain *domains[];\n};\n\n#define to_owl_pd(gpd) container_of(gpd, struct owl_sps_domain, genpd)\n\nstruct owl_sps_domain {\n\tstruct generic_pm_domain genpd;\n\tconst struct owl_sps_domain_info *info;\n\tstruct owl_sps *sps;\n};\n\nstatic int owl_sps_set_power(struct owl_sps_domain *pd, bool enable)\n{\n\tu32 pwr_mask, ack_mask;\n\n\tack_mask = BIT(pd->info->ack_bit);\n\tpwr_mask = BIT(pd->info->pwr_bit);\n\n\treturn owl_sps_set_pg(pd->sps->base, pwr_mask, ack_mask, enable);\n}\n\nstatic int owl_sps_power_on(struct generic_pm_domain *domain)\n{\n\tstruct owl_sps_domain *pd = to_owl_pd(domain);\n\n\tdev_dbg(pd->sps->dev, \"%s power on\", pd->info->name);\n\n\treturn owl_sps_set_power(pd, true);\n}\n\nstatic int owl_sps_power_off(struct generic_pm_domain *domain)\n{\n\tstruct owl_sps_domain *pd = to_owl_pd(domain);\n\n\tdev_dbg(pd->sps->dev, \"%s power off\", pd->info->name);\n\n\treturn owl_sps_set_power(pd, false);\n}\n\nstatic int owl_sps_init_domain(struct owl_sps *sps, int index)\n{\n\tstruct owl_sps_domain *pd;\n\n\tpd = devm_kzalloc(sps->dev, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tpd->info = &sps->info->domains[index];\n\tpd->sps = sps;\n\n\tpd->genpd.name = pd->info->name;\n\tpd->genpd.power_on = owl_sps_power_on;\n\tpd->genpd.power_off = owl_sps_power_off;\n\tpd->genpd.flags = pd->info->genpd_flags;\n\tpm_genpd_init(&pd->genpd, NULL, false);\n\n\tsps->genpd_data.domains[index] = &pd->genpd;\n\n\treturn 0;\n}\n\nstatic int owl_sps_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tconst struct owl_sps_info *sps_info;\n\tstruct owl_sps *sps;\n\tint i, ret;\n\n\tif (!pdev->dev.of_node) {\n\t\tdev_err(&pdev->dev, \"no device node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmatch = of_match_device(pdev->dev.driver->of_match_table, &pdev->dev);\n\tif (!match || !match->data) {\n\t\tdev_err(&pdev->dev, \"unknown compatible or missing data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsps_info = match->data;\n\n\tsps = devm_kzalloc(&pdev->dev,\n\t\t\t   struct_size(sps, domains, sps_info->num_domains),\n\t\t\t   GFP_KERNEL);\n\tif (!sps)\n\t\treturn -ENOMEM;\n\n\tsps->base = of_io_request_and_map(pdev->dev.of_node, 0, \"owl-sps\");\n\tif (IS_ERR(sps->base)) {\n\t\tdev_err(&pdev->dev, \"failed to map sps registers\\n\");\n\t\treturn PTR_ERR(sps->base);\n\t}\n\n\tsps->dev = &pdev->dev;\n\tsps->info = sps_info;\n\tsps->genpd_data.domains = sps->domains;\n\tsps->genpd_data.num_domains = sps_info->num_domains;\n\n\tfor (i = 0; i < sps_info->num_domains; i++) {\n\t\tret = owl_sps_init_domain(sps, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = of_genpd_add_provider_onecell(pdev->dev.of_node, &sps->genpd_data);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add provider (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct owl_sps_domain_info s500_sps_domains[] = {\n\t[S500_PD_VDE] = {\n\t\t.name = \"VDE\",\n\t\t.pwr_bit = 0,\n\t\t.ack_bit = 16,\n\t},\n\t[S500_PD_VCE_SI] = {\n\t\t.name = \"VCE_SI\",\n\t\t.pwr_bit = 1,\n\t\t.ack_bit = 17,\n\t},\n\t[S500_PD_USB2_1] = {\n\t\t.name = \"USB2_1\",\n\t\t.pwr_bit = 2,\n\t\t.ack_bit = 18,\n\t},\n\t[S500_PD_CPU2] = {\n\t\t.name = \"CPU2\",\n\t\t.pwr_bit = 5,\n\t\t.ack_bit = 21,\n\t\t.genpd_flags = GENPD_FLAG_ALWAYS_ON,\n\t},\n\t[S500_PD_CPU3] = {\n\t\t.name = \"CPU3\",\n\t\t.pwr_bit = 6,\n\t\t.ack_bit = 22,\n\t\t.genpd_flags = GENPD_FLAG_ALWAYS_ON,\n\t},\n\t[S500_PD_DMA] = {\n\t\t.name = \"DMA\",\n\t\t.pwr_bit = 8,\n\t\t.ack_bit = 12,\n\t},\n\t[S500_PD_DS] = {\n\t\t.name = \"DS\",\n\t\t.pwr_bit = 9,\n\t\t.ack_bit = 13,\n\t},\n\t[S500_PD_USB3] = {\n\t\t.name = \"USB3\",\n\t\t.pwr_bit = 10,\n\t\t.ack_bit = 14,\n\t},\n\t[S500_PD_USB2_0] = {\n\t\t.name = \"USB2_0\",\n\t\t.pwr_bit = 11,\n\t\t.ack_bit = 15,\n\t},\n};\n\nstatic const struct owl_sps_info s500_sps_info = {\n\t.num_domains = ARRAY_SIZE(s500_sps_domains),\n\t.domains = s500_sps_domains,\n};\n\nstatic const struct owl_sps_domain_info s700_sps_domains[] = {\n\t[S700_PD_VDE] = {\n\t\t.name = \"VDE\",\n\t\t.pwr_bit = 0,\n\t},\n\t[S700_PD_VCE_SI] = {\n\t\t.name = \"VCE_SI\",\n\t\t.pwr_bit = 1,\n\t},\n\t[S700_PD_USB2_1] = {\n\t\t.name = \"USB2_1\",\n\t\t.pwr_bit = 2,\n\t},\n\t[S700_PD_HDE] = {\n\t\t.name = \"HDE\",\n\t\t.pwr_bit = 7,\n\t},\n\t[S700_PD_DMA] = {\n\t\t.name = \"DMA\",\n\t\t.pwr_bit = 8,\n\t},\n\t[S700_PD_DS] = {\n\t\t.name = \"DS\",\n\t\t.pwr_bit = 9,\n\t},\n\t[S700_PD_USB3] = {\n\t\t.name = \"USB3\",\n\t\t.pwr_bit = 10,\n\t},\n\t[S700_PD_USB2_0] = {\n\t\t.name = \"USB2_0\",\n\t\t.pwr_bit = 11,\n\t},\n};\n\nstatic const struct owl_sps_info s700_sps_info = {\n\t.num_domains = ARRAY_SIZE(s700_sps_domains),\n\t.domains = s700_sps_domains,\n};\n\nstatic const struct owl_sps_domain_info s900_sps_domains[] = {\n\t[S900_PD_GPU_B] = {\n\t\t.name = \"GPU_B\",\n\t\t.pwr_bit = 3,\n\t},\n\t[S900_PD_VCE] = {\n\t\t.name = \"VCE\",\n\t\t.pwr_bit = 4,\n\t},\n\t[S900_PD_SENSOR] = {\n\t\t.name = \"SENSOR\",\n\t\t.pwr_bit = 5,\n\t},\n\t[S900_PD_VDE] = {\n\t\t.name = \"VDE\",\n\t\t.pwr_bit = 6,\n\t},\n\t[S900_PD_HDE] = {\n\t\t.name = \"HDE\",\n\t\t.pwr_bit = 7,\n\t},\n\t[S900_PD_USB3] = {\n\t\t.name = \"USB3\",\n\t\t.pwr_bit = 8,\n\t},\n\t[S900_PD_DDR0] = {\n\t\t.name = \"DDR0\",\n\t\t.pwr_bit = 9,\n\t},\n\t[S900_PD_DDR1] = {\n\t\t.name = \"DDR1\",\n\t\t.pwr_bit = 10,\n\t},\n\t[S900_PD_DE] = {\n\t\t.name = \"DE\",\n\t\t.pwr_bit = 13,\n\t},\n\t[S900_PD_NAND] = {\n\t\t.name = \"NAND\",\n\t\t.pwr_bit = 14,\n\t},\n\t[S900_PD_USB2_H0] = {\n\t\t.name = \"USB2_H0\",\n\t\t.pwr_bit = 15,\n\t},\n\t[S900_PD_USB2_H1] = {\n\t\t.name = \"USB2_H1\",\n\t\t.pwr_bit = 16,\n\t},\n};\n\nstatic const struct owl_sps_info s900_sps_info = {\n\t.num_domains = ARRAY_SIZE(s900_sps_domains),\n\t.domains = s900_sps_domains,\n};\n\nstatic const struct of_device_id owl_sps_of_matches[] = {\n\t{ .compatible = \"actions,s500-sps\", .data = &s500_sps_info },\n\t{ .compatible = \"actions,s700-sps\", .data = &s700_sps_info },\n\t{ .compatible = \"actions,s900-sps\", .data = &s900_sps_info },\n\t{ }\n};\n\nstatic struct platform_driver owl_sps_platform_driver = {\n\t.probe = owl_sps_probe,\n\t.driver = {\n\t\t.name = \"owl-sps\",\n\t\t.of_match_table = owl_sps_of_matches,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nstatic int __init owl_sps_init(void)\n{\n\treturn platform_driver_register(&owl_sps_platform_driver);\n}\npostcore_initcall(owl_sps_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}