{
  "module_name": "rcar-sysc.c",
  "hash_id": "b46fc57005ad96cc84294e9073ebb92a21906d9ad1dbe3acaddc2e6ab5979798",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/renesas/rcar-sysc.c",
  "human_readable_source": "\n \n\n#include <linux/clk/renesas.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/of_address.h>\n#include <linux/pm_domain.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/soc/renesas/rcar-sysc.h>\n\n#include \"rcar-sysc.h\"\n\n \n#define SYSCSR\t\t\t0x00\t \n#define SYSCISR\t\t\t0x04\t \n#define SYSCISCR\t\t0x08\t \n#define SYSCIER\t\t\t0x0c\t \n#define SYSCIMR\t\t\t0x10\t \n\n \n#define SYSCSR_PONENB\t\t1\t \n#define SYSCSR_POFFENB\t\t0\t \n\n \n#define PWRSR_OFFS\t\t0x00\t \n#define PWROFFCR_OFFS\t\t0x04\t \n#define PWROFFSR_OFFS\t\t0x08\t \n#define PWRONCR_OFFS\t\t0x0c\t \n#define PWRONSR_OFFS\t\t0x10\t \n#define PWRER_OFFS\t\t0x14\t \n\n\n#define SYSCSR_TIMEOUT\t\t100\n#define SYSCSR_DELAY_US\t\t1\n\n#define PWRER_RETRIES\t\t100\n#define PWRER_DELAY_US\t\t1\n\n#define SYSCISR_TIMEOUT\t\t1000\n#define SYSCISR_DELAY_US\t1\n\n#define RCAR_PD_ALWAYS_ON\t32\t \n\nstruct rcar_sysc_ch {\n\tu16 chan_offs;\n\tu8 chan_bit;\n\tu8 isr_bit;\n};\n\nstatic void __iomem *rcar_sysc_base;\nstatic DEFINE_SPINLOCK(rcar_sysc_lock);  \nstatic u32 rcar_sysc_extmask_offs, rcar_sysc_extmask_val;\n\nstatic int rcar_sysc_pwr_on_off(const struct rcar_sysc_ch *sysc_ch, bool on)\n{\n\tunsigned int sr_bit, reg_offs;\n\tu32 val;\n\tint ret;\n\n\tif (on) {\n\t\tsr_bit = SYSCSR_PONENB;\n\t\treg_offs = PWRONCR_OFFS;\n\t} else {\n\t\tsr_bit = SYSCSR_POFFENB;\n\t\treg_offs = PWROFFCR_OFFS;\n\t}\n\n\t \n\tret = readl_poll_timeout_atomic(rcar_sysc_base + SYSCSR, val,\n\t\t\t\t\tval & BIT(sr_bit), SYSCSR_DELAY_US,\n\t\t\t\t\tSYSCSR_TIMEOUT);\n\tif (ret)\n\t\treturn -EAGAIN;\n\n\t \n\tiowrite32(BIT(sysc_ch->chan_bit),\n\t\t  rcar_sysc_base + sysc_ch->chan_offs + reg_offs);\n\n\treturn 0;\n}\n\nstatic int rcar_sysc_power(const struct rcar_sysc_ch *sysc_ch, bool on)\n{\n\tunsigned int isr_mask = BIT(sysc_ch->isr_bit);\n\tunsigned int chan_mask = BIT(sysc_ch->chan_bit);\n\tunsigned int status, k;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rcar_sysc_lock, flags);\n\n\t \n\tif (rcar_sysc_extmask_val) {\n\t\tiowrite32(rcar_sysc_extmask_val,\n\t\t\t  rcar_sysc_base + rcar_sysc_extmask_offs);\n\t}\n\n\t \n\tiowrite32(ioread32(rcar_sysc_base + SYSCIMR) | isr_mask,\n\t\t  rcar_sysc_base + SYSCIMR);\n\tiowrite32(ioread32(rcar_sysc_base + SYSCIER) | isr_mask,\n\t\t  rcar_sysc_base + SYSCIER);\n\n\tiowrite32(isr_mask, rcar_sysc_base + SYSCISCR);\n\n\t \n\tfor (k = 0; k < PWRER_RETRIES; k++) {\n\t\tret = rcar_sysc_pwr_on_off(sysc_ch, on);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tstatus = ioread32(rcar_sysc_base +\n\t\t\t\t  sysc_ch->chan_offs + PWRER_OFFS);\n\t\tif (!(status & chan_mask))\n\t\t\tbreak;\n\n\t\tudelay(PWRER_DELAY_US);\n\t}\n\n\tif (k == PWRER_RETRIES) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tret = readl_poll_timeout_atomic(rcar_sysc_base + SYSCISR, status,\n\t\t\t\t\tstatus & isr_mask, SYSCISR_DELAY_US,\n\t\t\t\t\tSYSCISR_TIMEOUT);\n\tif (ret)\n\t\tret = -EIO;\n\n\tiowrite32(isr_mask, rcar_sysc_base + SYSCISCR);\n\n out:\n\tif (rcar_sysc_extmask_val)\n\t\tiowrite32(0, rcar_sysc_base + rcar_sysc_extmask_offs);\n\n\tspin_unlock_irqrestore(&rcar_sysc_lock, flags);\n\n\tpr_debug(\"sysc power %s domain %d: %08x -> %d\\n\", on ? \"on\" : \"off\",\n\t\t sysc_ch->isr_bit, ioread32(rcar_sysc_base + SYSCISR), ret);\n\treturn ret;\n}\n\nstatic bool rcar_sysc_power_is_off(const struct rcar_sysc_ch *sysc_ch)\n{\n\tunsigned int st;\n\n\tst = ioread32(rcar_sysc_base + sysc_ch->chan_offs + PWRSR_OFFS);\n\tif (st & BIT(sysc_ch->chan_bit))\n\t\treturn true;\n\n\treturn false;\n}\n\nstruct rcar_sysc_pd {\n\tstruct generic_pm_domain genpd;\n\tstruct rcar_sysc_ch ch;\n\tunsigned int flags;\n\tchar name[];\n};\n\nstatic inline struct rcar_sysc_pd *to_rcar_pd(struct generic_pm_domain *d)\n{\n\treturn container_of(d, struct rcar_sysc_pd, genpd);\n}\n\nstatic int rcar_sysc_pd_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct rcar_sysc_pd *pd = to_rcar_pd(genpd);\n\n\tpr_debug(\"%s: %s\\n\", __func__, genpd->name);\n\treturn rcar_sysc_power(&pd->ch, false);\n}\n\nstatic int rcar_sysc_pd_power_on(struct generic_pm_domain *genpd)\n{\n\tstruct rcar_sysc_pd *pd = to_rcar_pd(genpd);\n\n\tpr_debug(\"%s: %s\\n\", __func__, genpd->name);\n\treturn rcar_sysc_power(&pd->ch, true);\n}\n\nstatic bool has_cpg_mstp;\n\nstatic int __init rcar_sysc_pd_setup(struct rcar_sysc_pd *pd)\n{\n\tstruct generic_pm_domain *genpd = &pd->genpd;\n\tconst char *name = pd->genpd.name;\n\tint error;\n\n\tif (pd->flags & PD_CPU) {\n\t\t \n\t\tpr_debug(\"PM domain %s contains %s\\n\", name, \"CPU\");\n\t\tgenpd->flags |= GENPD_FLAG_ALWAYS_ON;\n\t} else if (pd->flags & PD_SCU) {\n\t\t \n\t\tpr_debug(\"PM domain %s contains %s\\n\", name, \"SCU\");\n\t\tgenpd->flags |= GENPD_FLAG_ALWAYS_ON;\n\t} else if (pd->flags & PD_NO_CR) {\n\t\t \n\t\tgenpd->flags |= GENPD_FLAG_ALWAYS_ON;\n\t}\n\n\tif (!(pd->flags & (PD_CPU | PD_SCU))) {\n\t\t \n\t\tgenpd->flags |= GENPD_FLAG_PM_CLK | GENPD_FLAG_ACTIVE_WAKEUP;\n\t\tif (has_cpg_mstp) {\n\t\t\tgenpd->attach_dev = cpg_mstp_attach_dev;\n\t\t\tgenpd->detach_dev = cpg_mstp_detach_dev;\n\t\t} else {\n\t\t\tgenpd->attach_dev = cpg_mssr_attach_dev;\n\t\t\tgenpd->detach_dev = cpg_mssr_detach_dev;\n\t\t}\n\t}\n\n\tgenpd->power_off = rcar_sysc_pd_power_off;\n\tgenpd->power_on = rcar_sysc_pd_power_on;\n\n\tif (pd->flags & (PD_CPU | PD_NO_CR)) {\n\t\t \n\t\tpr_debug(\"%s: Not touching %s\\n\", __func__, genpd->name);\n\t\tgoto finalize;\n\t}\n\n\tif (!rcar_sysc_power_is_off(&pd->ch)) {\n\t\tpr_debug(\"%s: %s is already powered\\n\", __func__, genpd->name);\n\t\tgoto finalize;\n\t}\n\n\trcar_sysc_power(&pd->ch, true);\n\nfinalize:\n\terror = pm_genpd_init(genpd, &simple_qos_governor, false);\n\tif (error)\n\t\tpr_err(\"Failed to init PM domain %s: %d\\n\", name, error);\n\n\treturn error;\n}\n\nstatic const struct of_device_id rcar_sysc_matches[] __initconst = {\n#ifdef CONFIG_SYSC_R8A7742\n\t{ .compatible = \"renesas,r8a7742-sysc\", .data = &r8a7742_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A7743\n\t{ .compatible = \"renesas,r8a7743-sysc\", .data = &r8a7743_sysc_info },\n\t \n\t{ .compatible = \"renesas,r8a7744-sysc\", .data = &r8a7743_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A7745\n\t{ .compatible = \"renesas,r8a7745-sysc\", .data = &r8a7745_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A77470\n\t{ .compatible = \"renesas,r8a77470-sysc\", .data = &r8a77470_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A774A1\n\t{ .compatible = \"renesas,r8a774a1-sysc\", .data = &r8a774a1_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A774B1\n\t{ .compatible = \"renesas,r8a774b1-sysc\", .data = &r8a774b1_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A774C0\n\t{ .compatible = \"renesas,r8a774c0-sysc\", .data = &r8a774c0_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A774E1\n\t{ .compatible = \"renesas,r8a774e1-sysc\", .data = &r8a774e1_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A7779\n\t{ .compatible = \"renesas,r8a7779-sysc\", .data = &r8a7779_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A7790\n\t{ .compatible = \"renesas,r8a7790-sysc\", .data = &r8a7790_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A7791\n\t{ .compatible = \"renesas,r8a7791-sysc\", .data = &r8a7791_sysc_info },\n\t \n\t{ .compatible = \"renesas,r8a7793-sysc\", .data = &r8a7791_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A7792\n\t{ .compatible = \"renesas,r8a7792-sysc\", .data = &r8a7792_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A7794\n\t{ .compatible = \"renesas,r8a7794-sysc\", .data = &r8a7794_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A7795\n\t{ .compatible = \"renesas,r8a7795-sysc\", .data = &r8a7795_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A77960\n\t{ .compatible = \"renesas,r8a7796-sysc\", .data = &r8a77960_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A77961\n\t{ .compatible = \"renesas,r8a77961-sysc\", .data = &r8a77961_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A77965\n\t{ .compatible = \"renesas,r8a77965-sysc\", .data = &r8a77965_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A77970\n\t{ .compatible = \"renesas,r8a77970-sysc\", .data = &r8a77970_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A77980\n\t{ .compatible = \"renesas,r8a77980-sysc\", .data = &r8a77980_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A77990\n\t{ .compatible = \"renesas,r8a77990-sysc\", .data = &r8a77990_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A77995\n\t{ .compatible = \"renesas,r8a77995-sysc\", .data = &r8a77995_sysc_info },\n#endif\n\t{   }\n};\n\nstruct rcar_pm_domains {\n\tstruct genpd_onecell_data onecell_data;\n\tstruct generic_pm_domain *domains[RCAR_PD_ALWAYS_ON + 1];\n};\n\nstatic struct genpd_onecell_data *rcar_sysc_onecell_data;\n\nstatic int __init rcar_sysc_pd_init(void)\n{\n\tconst struct rcar_sysc_info *info;\n\tconst struct of_device_id *match;\n\tstruct rcar_pm_domains *domains;\n\tstruct device_node *np;\n\tvoid __iomem *base;\n\tunsigned int i;\n\tint error;\n\n\tnp = of_find_matching_node_and_match(NULL, rcar_sysc_matches, &match);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tinfo = match->data;\n\n\tif (info->init) {\n\t\terror = info->init();\n\t\tif (error)\n\t\t\tgoto out_put;\n\t}\n\n\thas_cpg_mstp = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t       \"renesas,cpg-mstp-clocks\");\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_warn(\"%pOF: Cannot map regs\\n\", np);\n\t\terror = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\trcar_sysc_base = base;\n\n\t \n\trcar_sysc_extmask_offs = info->extmask_offs;\n\trcar_sysc_extmask_val = info->extmask_val;\n\n\tdomains = kzalloc(sizeof(*domains), GFP_KERNEL);\n\tif (!domains) {\n\t\terror = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\tdomains->onecell_data.domains = domains->domains;\n\tdomains->onecell_data.num_domains = ARRAY_SIZE(domains->domains);\n\trcar_sysc_onecell_data = &domains->onecell_data;\n\n\tfor (i = 0; i < info->num_areas; i++) {\n\t\tconst struct rcar_sysc_area *area = &info->areas[i];\n\t\tstruct rcar_sysc_pd *pd;\n\t\tsize_t n;\n\n\t\tif (!area->name) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tn = strlen(area->name) + 1;\n\t\tpd = kzalloc(sizeof(*pd) + n, GFP_KERNEL);\n\t\tif (!pd) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_put;\n\t\t}\n\n\t\tmemcpy(pd->name, area->name, n);\n\t\tpd->genpd.name = pd->name;\n\t\tpd->ch.chan_offs = area->chan_offs;\n\t\tpd->ch.chan_bit = area->chan_bit;\n\t\tpd->ch.isr_bit = area->isr_bit;\n\t\tpd->flags = area->flags;\n\n\t\terror = rcar_sysc_pd_setup(pd);\n\t\tif (error)\n\t\t\tgoto out_put;\n\n\t\tdomains->domains[area->isr_bit] = &pd->genpd;\n\n\t\tif (area->parent < 0)\n\t\t\tcontinue;\n\n\t\terror = pm_genpd_add_subdomain(domains->domains[area->parent],\n\t\t\t\t\t       &pd->genpd);\n\t\tif (error) {\n\t\t\tpr_warn(\"Failed to add PM subdomain %s to parent %u\\n\",\n\t\t\t\tarea->name, area->parent);\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\terror = of_genpd_add_provider_onecell(np, &domains->onecell_data);\n\tif (!error)\n\t\tfwnode_dev_initialized(of_fwnode_handle(np), true);\n\nout_put:\n\tof_node_put(np);\n\treturn error;\n}\nearly_initcall(rcar_sysc_pd_init);\n\nvoid __init rcar_sysc_nullify(struct rcar_sysc_area *areas,\n\t\t\t      unsigned int num_areas, u8 id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num_areas; i++)\n\t\tif (areas[i].isr_bit == id) {\n\t\t\tareas[i].name = NULL;\n\t\t\treturn;\n\t\t}\n}\n\n#ifdef CONFIG_ARCH_R8A7779\nstatic int rcar_sysc_power_cpu(unsigned int idx, bool on)\n{\n\tstruct generic_pm_domain *genpd;\n\tstruct rcar_sysc_pd *pd;\n\tunsigned int i;\n\n\tif (!rcar_sysc_onecell_data)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < rcar_sysc_onecell_data->num_domains; i++) {\n\t\tgenpd = rcar_sysc_onecell_data->domains[i];\n\t\tif (!genpd)\n\t\t\tcontinue;\n\n\t\tpd = to_rcar_pd(genpd);\n\t\tif (!(pd->flags & PD_CPU) || pd->ch.chan_bit != idx)\n\t\t\tcontinue;\n\n\t\treturn rcar_sysc_power(&pd->ch, on);\n\t}\n\n\treturn -ENOENT;\n}\n\nint rcar_sysc_power_down_cpu(unsigned int cpu)\n{\n\treturn rcar_sysc_power_cpu(cpu, false);\n}\n\nint rcar_sysc_power_up_cpu(unsigned int cpu)\n{\n\treturn rcar_sysc_power_cpu(cpu, true);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}