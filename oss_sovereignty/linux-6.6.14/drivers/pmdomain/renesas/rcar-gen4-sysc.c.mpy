{
  "module_name": "rcar-gen4-sysc.c",
  "hash_id": "10ec42cdf185ed662de6b841ed0a211bb45e2d7b57921a7fccc04754d0646199",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/renesas/rcar-gen4-sysc.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk/renesas.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/of_address.h>\n#include <linux/pm_domain.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#include \"rcar-gen4-sysc.h\"\n\n \n#define SYSCSR\t\t0x000\t \n#define SYSCPONSR(x)\t(0x800 + ((x) * 0x4))  \n#define SYSCPOFFSR(x)\t(0x808 + ((x) * 0x4))  \n#define SYSCISCR(x)\t(0x810 + ((x) * 0x4))  \n#define SYSCIER(x)\t(0x820 + ((x) * 0x4))  \n#define SYSCIMR(x)\t(0x830 + ((x) * 0x4))  \n\n \n#define PDRSR(n)\t(0x1000 + ((n) * 0x40))\n#define PDRONCR(n)\t(0x1004 + ((n) * 0x40))\n#define PDROFFCR(n)\t(0x1008 + ((n) * 0x40))\n#define PDRESR(n)\t(0x100C + ((n) * 0x40))\n\n \n#define PWRON_PWROFF\t\tBIT(0)\t \n\n \n#define PDRESR_ERR\t\tBIT(0)\n\n \n#define PDRSR_OFF\t\tBIT(0)\t \n#define PDRSR_ON\t\tBIT(4)\t \n#define PDRSR_OFF_STATE\t\tBIT(8)   \n#define PDRSR_ON_STATE\t\tBIT(12)  \n\n#define SYSCSR_BUSY\t\tGENMASK(1, 0)\t \n\n#define SYSCSR_TIMEOUT\t\t10000\n#define SYSCSR_DELAY_US\t\t10\n\n#define PDRESR_RETRIES\t\t1000\n#define PDRESR_DELAY_US\t\t10\n\n#define SYSCISR_TIMEOUT\t\t10000\n#define SYSCISR_DELAY_US\t10\n\n#define RCAR_GEN4_PD_ALWAYS_ON\t64\n#define NUM_DOMAINS_EACH_REG\tBITS_PER_TYPE(u32)\n\nstatic void __iomem *rcar_gen4_sysc_base;\nstatic DEFINE_SPINLOCK(rcar_gen4_sysc_lock);  \n\nstatic int rcar_gen4_sysc_pwr_on_off(u8 pdr, bool on)\n{\n\tunsigned int reg_offs;\n\tu32 val;\n\tint ret;\n\n\tif (on)\n\t\treg_offs = PDRONCR(pdr);\n\telse\n\t\treg_offs = PDROFFCR(pdr);\n\n\t \n\tret = readl_poll_timeout_atomic(rcar_gen4_sysc_base + SYSCSR, val,\n\t\t\t\t\t(val & SYSCSR_BUSY) == SYSCSR_BUSY,\n\t\t\t\t\tSYSCSR_DELAY_US, SYSCSR_TIMEOUT);\n\tif (ret < 0)\n\t\treturn -EAGAIN;\n\n\t \n\tiowrite32(PWRON_PWROFF, rcar_gen4_sysc_base + reg_offs);\n\n\treturn 0;\n}\n\nstatic int clear_irq_flags(unsigned int reg_idx, unsigned int isr_mask)\n{\n\tu32 val;\n\tint ret;\n\n\tiowrite32(isr_mask, rcar_gen4_sysc_base + SYSCISCR(reg_idx));\n\n\tret = readl_poll_timeout_atomic(rcar_gen4_sysc_base + SYSCISCR(reg_idx),\n\t\t\t\t\tval, !(val & isr_mask),\n\t\t\t\t\tSYSCISR_DELAY_US, SYSCISR_TIMEOUT);\n\tif (ret < 0) {\n\t\tpr_err(\"\\n %s : Can not clear IRQ flags in SYSCISCR\", __func__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int rcar_gen4_sysc_power(u8 pdr, bool on)\n{\n\tunsigned int isr_mask;\n\tunsigned int reg_idx, bit_idx;\n\tunsigned int status;\n\tunsigned long flags;\n\tint ret = 0;\n\tu32 val;\n\tint k;\n\n\tspin_lock_irqsave(&rcar_gen4_sysc_lock, flags);\n\n\treg_idx = pdr / NUM_DOMAINS_EACH_REG;\n\tbit_idx = pdr % NUM_DOMAINS_EACH_REG;\n\n\tisr_mask = BIT(bit_idx);\n\n\t \n\tiowrite32(ioread32(rcar_gen4_sysc_base + SYSCIER(reg_idx)) | isr_mask,\n\t\t  rcar_gen4_sysc_base + SYSCIER(reg_idx));\n\tiowrite32(ioread32(rcar_gen4_sysc_base + SYSCIMR(reg_idx)) | isr_mask,\n\t\t  rcar_gen4_sysc_base + SYSCIMR(reg_idx));\n\n\tret = clear_irq_flags(reg_idx, isr_mask);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tfor (k = 0; k < PDRESR_RETRIES; k++) {\n\t\tret = rcar_gen4_sysc_pwr_on_off(pdr, on);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tstatus = ioread32(rcar_gen4_sysc_base + PDRESR(pdr));\n\t\tif (!(status & PDRESR_ERR))\n\t\t\tbreak;\n\n\t\tudelay(PDRESR_DELAY_US);\n\t}\n\n\tif (k == PDRESR_RETRIES) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tret = readl_poll_timeout_atomic(rcar_gen4_sysc_base + SYSCISCR(reg_idx),\n\t\t\t\t\tval, (val & isr_mask),\n\t\t\t\t\tSYSCISR_DELAY_US, SYSCISR_TIMEOUT);\n\tif (ret < 0) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tret = clear_irq_flags(reg_idx, isr_mask);\n\tif (ret)\n\t\tgoto out;\n\n out:\n\tspin_unlock_irqrestore(&rcar_gen4_sysc_lock, flags);\n\n\tpr_debug(\"sysc power %s domain %d: %08x -> %d\\n\", on ? \"on\" : \"off\",\n\t\t pdr, ioread32(rcar_gen4_sysc_base + SYSCISCR(reg_idx)), ret);\n\treturn ret;\n}\n\nstatic bool rcar_gen4_sysc_power_is_off(u8 pdr)\n{\n\tunsigned int st;\n\n\tst = ioread32(rcar_gen4_sysc_base + PDRSR(pdr));\n\n\tif (st & PDRSR_OFF)\n\t\treturn true;\n\n\treturn false;\n}\n\nstruct rcar_gen4_sysc_pd {\n\tstruct generic_pm_domain genpd;\n\tu8 pdr;\n\tunsigned int flags;\n\tchar name[];\n};\n\nstatic inline struct rcar_gen4_sysc_pd *to_rcar_gen4_pd(struct generic_pm_domain *d)\n{\n\treturn container_of(d, struct rcar_gen4_sysc_pd, genpd);\n}\n\nstatic int rcar_gen4_sysc_pd_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct rcar_gen4_sysc_pd *pd = to_rcar_gen4_pd(genpd);\n\n\tpr_debug(\"%s: %s\\n\", __func__, genpd->name);\n\treturn rcar_gen4_sysc_power(pd->pdr, false);\n}\n\nstatic int rcar_gen4_sysc_pd_power_on(struct generic_pm_domain *genpd)\n{\n\tstruct rcar_gen4_sysc_pd *pd = to_rcar_gen4_pd(genpd);\n\n\tpr_debug(\"%s: %s\\n\", __func__, genpd->name);\n\treturn rcar_gen4_sysc_power(pd->pdr, true);\n}\n\nstatic int __init rcar_gen4_sysc_pd_setup(struct rcar_gen4_sysc_pd *pd)\n{\n\tstruct generic_pm_domain *genpd = &pd->genpd;\n\tconst char *name = pd->genpd.name;\n\tint error;\n\n\tif (pd->flags & PD_CPU) {\n\t\t \n\t\tpr_debug(\"PM domain %s contains %s\\n\", name, \"CPU\");\n\t\tgenpd->flags |= GENPD_FLAG_ALWAYS_ON;\n\t} else if (pd->flags & PD_SCU) {\n\t\t \n\t\tpr_debug(\"PM domain %s contains %s\\n\", name, \"SCU\");\n\t\tgenpd->flags |= GENPD_FLAG_ALWAYS_ON;\n\t} else if (pd->flags & PD_NO_CR) {\n\t\t \n\t\tgenpd->flags |= GENPD_FLAG_ALWAYS_ON;\n\t}\n\n\tif (!(pd->flags & (PD_CPU | PD_SCU))) {\n\t\t \n\t\tgenpd->flags |= GENPD_FLAG_PM_CLK | GENPD_FLAG_ACTIVE_WAKEUP;\n\t\tgenpd->attach_dev = cpg_mssr_attach_dev;\n\t\tgenpd->detach_dev = cpg_mssr_detach_dev;\n\t}\n\n\tgenpd->power_off = rcar_gen4_sysc_pd_power_off;\n\tgenpd->power_on = rcar_gen4_sysc_pd_power_on;\n\n\tif (pd->flags & (PD_CPU | PD_NO_CR)) {\n\t\t \n\t\tpr_debug(\"%s: Not touching %s\\n\", __func__, genpd->name);\n\t\tgoto finalize;\n\t}\n\n\tif (!rcar_gen4_sysc_power_is_off(pd->pdr)) {\n\t\tpr_debug(\"%s: %s is already powered\\n\", __func__, genpd->name);\n\t\tgoto finalize;\n\t}\n\n\trcar_gen4_sysc_power(pd->pdr, true);\n\nfinalize:\n\terror = pm_genpd_init(genpd, &simple_qos_governor, false);\n\tif (error)\n\t\tpr_err(\"Failed to init PM domain %s: %d\\n\", name, error);\n\n\treturn error;\n}\n\nstatic const struct of_device_id rcar_gen4_sysc_matches[] __initconst = {\n#ifdef CONFIG_SYSC_R8A779A0\n\t{ .compatible = \"renesas,r8a779a0-sysc\", .data = &r8a779a0_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A779F0\n\t{ .compatible = \"renesas,r8a779f0-sysc\", .data = &r8a779f0_sysc_info },\n#endif\n#ifdef CONFIG_SYSC_R8A779G0\n\t{ .compatible = \"renesas,r8a779g0-sysc\", .data = &r8a779g0_sysc_info },\n#endif\n\t{   }\n};\n\nstruct rcar_gen4_pm_domains {\n\tstruct genpd_onecell_data onecell_data;\n\tstruct generic_pm_domain *domains[RCAR_GEN4_PD_ALWAYS_ON + 1];\n};\n\nstatic struct genpd_onecell_data *rcar_gen4_sysc_onecell_data;\n\nstatic int __init rcar_gen4_sysc_pd_init(void)\n{\n\tconst struct rcar_gen4_sysc_info *info;\n\tconst struct of_device_id *match;\n\tstruct rcar_gen4_pm_domains *domains;\n\tstruct device_node *np;\n\tvoid __iomem *base;\n\tunsigned int i;\n\tint error;\n\n\tnp = of_find_matching_node_and_match(NULL, rcar_gen4_sysc_matches, &match);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tinfo = match->data;\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_warn(\"%pOF: Cannot map regs\\n\", np);\n\t\terror = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\trcar_gen4_sysc_base = base;\n\n\tdomains = kzalloc(sizeof(*domains), GFP_KERNEL);\n\tif (!domains) {\n\t\terror = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\tdomains->onecell_data.domains = domains->domains;\n\tdomains->onecell_data.num_domains = ARRAY_SIZE(domains->domains);\n\trcar_gen4_sysc_onecell_data = &domains->onecell_data;\n\n\tfor (i = 0; i < info->num_areas; i++) {\n\t\tconst struct rcar_gen4_sysc_area *area = &info->areas[i];\n\t\tstruct rcar_gen4_sysc_pd *pd;\n\t\tsize_t n;\n\n\t\tif (!area->name) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tn = strlen(area->name) + 1;\n\t\tpd = kzalloc(sizeof(*pd) + n, GFP_KERNEL);\n\t\tif (!pd) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_put;\n\t\t}\n\n\t\tmemcpy(pd->name, area->name, n);\n\t\tpd->genpd.name = pd->name;\n\t\tpd->pdr = area->pdr;\n\t\tpd->flags = area->flags;\n\n\t\terror = rcar_gen4_sysc_pd_setup(pd);\n\t\tif (error)\n\t\t\tgoto out_put;\n\n\t\tdomains->domains[area->pdr] = &pd->genpd;\n\n\t\tif (area->parent < 0)\n\t\t\tcontinue;\n\n\t\terror = pm_genpd_add_subdomain(domains->domains[area->parent],\n\t\t\t\t\t       &pd->genpd);\n\t\tif (error) {\n\t\t\tpr_warn(\"Failed to add PM subdomain %s to parent %u\\n\",\n\t\t\t\tarea->name, area->parent);\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\terror = of_genpd_add_provider_onecell(np, &domains->onecell_data);\n\nout_put:\n\tof_node_put(np);\n\treturn error;\n}\nearly_initcall(rcar_gen4_sysc_pd_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}