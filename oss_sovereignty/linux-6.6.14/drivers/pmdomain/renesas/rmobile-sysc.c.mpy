{
  "module_name": "rmobile-sysc.c",
  "hash_id": "543628cef8836b1fff3162d1e869fce480e611056af245234fa8159666bc31d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/renesas/rmobile-sysc.c",
  "human_readable_source": "\n \n#include <linux/clk/renesas.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/pm.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_domain.h>\n#include <linux/slab.h>\n\n \n#define SPDCR\t\t0x08\t \n#define SWUCR\t\t0x14\t \n#define PSTR\t\t0x80\t \n\n#define PSTR_RETRIES\t100\n#define PSTR_DELAY_US\t10\n\nstruct rmobile_pm_domain {\n\tstruct generic_pm_domain genpd;\n\tstruct dev_power_governor *gov;\n\tint (*suspend)(void);\n\tvoid __iomem *base;\n\tunsigned int bit_shift;\n};\n\nstatic inline\nstruct rmobile_pm_domain *to_rmobile_pd(struct generic_pm_domain *d)\n{\n\treturn container_of(d, struct rmobile_pm_domain, genpd);\n}\n\nstatic int rmobile_pd_power_down(struct generic_pm_domain *genpd)\n{\n\tstruct rmobile_pm_domain *rmobile_pd = to_rmobile_pd(genpd);\n\tunsigned int mask = BIT(rmobile_pd->bit_shift);\n\tu32 val;\n\n\tif (rmobile_pd->suspend) {\n\t\tint ret = rmobile_pd->suspend();\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (readl(rmobile_pd->base + PSTR) & mask) {\n\t\twritel(mask, rmobile_pd->base + SPDCR);\n\n\t\treadl_poll_timeout_atomic(rmobile_pd->base + SPDCR, val,\n\t\t\t\t\t  !(val & mask), 0, PSTR_RETRIES);\n\t}\n\n\tpr_debug(\"%s: Power off, 0x%08x -> PSTR = 0x%08x\\n\", genpd->name, mask,\n\t\t readl(rmobile_pd->base + PSTR));\n\n\treturn 0;\n}\n\nstatic int __rmobile_pd_power_up(struct rmobile_pm_domain *rmobile_pd)\n{\n\tunsigned int val, mask = BIT(rmobile_pd->bit_shift);\n\tint ret = 0;\n\n\tif (readl(rmobile_pd->base + PSTR) & mask)\n\t\treturn ret;\n\n\twritel(mask, rmobile_pd->base + SWUCR);\n\n\tret = readl_poll_timeout_atomic(rmobile_pd->base + SWUCR, val,\n\t\t\t\t\t(val & mask), PSTR_DELAY_US,\n\t\t\t\t\tPSTR_RETRIES * PSTR_DELAY_US);\n\n\tpr_debug(\"%s: Power on, 0x%08x -> PSTR = 0x%08x\\n\",\n\t\t rmobile_pd->genpd.name, mask,\n\t\t readl(rmobile_pd->base + PSTR));\n\n\treturn ret;\n}\n\nstatic int rmobile_pd_power_up(struct generic_pm_domain *genpd)\n{\n\treturn __rmobile_pd_power_up(to_rmobile_pd(genpd));\n}\n\nstatic void rmobile_init_pm_domain(struct rmobile_pm_domain *rmobile_pd)\n{\n\tstruct generic_pm_domain *genpd = &rmobile_pd->genpd;\n\tstruct dev_power_governor *gov = rmobile_pd->gov;\n\n\tgenpd->flags |= GENPD_FLAG_PM_CLK | GENPD_FLAG_ACTIVE_WAKEUP;\n\tgenpd->attach_dev = cpg_mstp_attach_dev;\n\tgenpd->detach_dev = cpg_mstp_detach_dev;\n\n\tif (!(genpd->flags & GENPD_FLAG_ALWAYS_ON)) {\n\t\tgenpd->power_off = rmobile_pd_power_down;\n\t\tgenpd->power_on = rmobile_pd_power_up;\n\t\t__rmobile_pd_power_up(rmobile_pd);\n\t}\n\n\tpm_genpd_init(genpd, gov ? : &simple_qos_governor, false);\n}\n\nstatic int rmobile_pd_suspend_console(void)\n{\n\t \n\treturn console_suspend_enabled ? 0 : -EBUSY;\n}\n\nenum pd_types {\n\tPD_NORMAL,\n\tPD_CPU,\n\tPD_CONSOLE,\n\tPD_DEBUG,\n\tPD_MEMCTL,\n};\n\n#define MAX_NUM_SPECIAL_PDS\t16\n\nstatic struct special_pd {\n\tstruct device_node *pd;\n\tenum pd_types type;\n} special_pds[MAX_NUM_SPECIAL_PDS] __initdata;\n\nstatic unsigned int num_special_pds __initdata;\n\nstatic const struct of_device_id special_ids[] __initconst = {\n\t{ .compatible = \"arm,coresight-etm3x\", .data = (void *)PD_DEBUG },\n\t{ .compatible = \"renesas,dbsc-r8a73a4\", .data = (void *)PD_MEMCTL, },\n\t{ .compatible = \"renesas,dbsc3-r8a7740\", .data = (void *)PD_MEMCTL, },\n\t{ .compatible = \"renesas,sbsc-sh73a0\", .data = (void *)PD_MEMCTL, },\n\t{   },\n};\n\nstatic void __init add_special_pd(struct device_node *np, enum pd_types type)\n{\n\tunsigned int i;\n\tstruct device_node *pd;\n\n\tpd = of_parse_phandle(np, \"power-domains\", 0);\n\tif (!pd)\n\t\treturn;\n\n\tfor (i = 0; i < num_special_pds; i++)\n\t\tif (pd == special_pds[i].pd && type == special_pds[i].type) {\n\t\t\tof_node_put(pd);\n\t\t\treturn;\n\t\t}\n\n\tif (num_special_pds == ARRAY_SIZE(special_pds)) {\n\t\tpr_warn(\"Too many special PM domains\\n\");\n\t\tof_node_put(pd);\n\t\treturn;\n\t}\n\n\tpr_debug(\"Special PM domain %pOFn type %d for %pOF\\n\", pd, type, np);\n\n\tspecial_pds[num_special_pds].pd = pd;\n\tspecial_pds[num_special_pds].type = type;\n\tnum_special_pds++;\n}\n\nstatic void __init get_special_pds(void)\n{\n\tstruct device_node *np;\n\tconst struct of_device_id *id;\n\n\t \n\tfor_each_of_cpu_node(np)\n\t\tadd_special_pd(np, PD_CPU);\n\n\t \n\tif (of_stdout)\n\t\tadd_special_pd(of_stdout, PD_CONSOLE);\n\n\t \n\tfor_each_matching_node_and_match(np, special_ids, &id)\n\t\tadd_special_pd(np, (enum pd_types)id->data);\n}\n\nstatic void __init put_special_pds(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num_special_pds; i++)\n\t\tof_node_put(special_pds[i].pd);\n}\n\nstatic enum pd_types __init pd_type(const struct device_node *pd)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num_special_pds; i++)\n\t\tif (pd == special_pds[i].pd)\n\t\t\treturn special_pds[i].type;\n\n\treturn PD_NORMAL;\n}\n\nstatic void __init rmobile_setup_pm_domain(struct device_node *np,\n\t\t\t\t\t   struct rmobile_pm_domain *pd)\n{\n\tconst char *name = pd->genpd.name;\n\n\tswitch (pd_type(np)) {\n\tcase PD_CPU:\n\t\t \n\t\tpr_debug(\"PM domain %s contains CPU\\n\", name);\n\t\tpd->genpd.flags |= GENPD_FLAG_ALWAYS_ON;\n\t\tbreak;\n\n\tcase PD_CONSOLE:\n\t\tpr_debug(\"PM domain %s contains serial console\\n\", name);\n\t\tpd->gov = &pm_domain_always_on_gov;\n\t\tpd->suspend = rmobile_pd_suspend_console;\n\t\tbreak;\n\n\tcase PD_DEBUG:\n\t\t \n\t\tpr_debug(\"PM domain %s contains Coresight-ETM\\n\", name);\n\t\tpd->genpd.flags |= GENPD_FLAG_ALWAYS_ON;\n\t\tbreak;\n\n\tcase PD_MEMCTL:\n\t\t \n\t\tpr_debug(\"PM domain %s contains MEMCTL\\n\", name);\n\t\tpd->genpd.flags |= GENPD_FLAG_ALWAYS_ON;\n\t\tbreak;\n\n\tcase PD_NORMAL:\n\t\tif (pd->bit_shift == ~0) {\n\t\t\t \n\t\t\tpr_debug(\"PM domain %s is always-on domain\\n\", name);\n\t\t\tpd->genpd.flags |= GENPD_FLAG_ALWAYS_ON;\n\t\t}\n\t\tbreak;\n\t}\n\n\trmobile_init_pm_domain(pd);\n}\n\nstatic int __init rmobile_add_pm_domains(void __iomem *base,\n\t\t\t\t\t struct device_node *parent,\n\t\t\t\t\t struct generic_pm_domain *genpd_parent)\n{\n\tstruct device_node *np;\n\n\tfor_each_child_of_node(parent, np) {\n\t\tstruct rmobile_pm_domain *pd;\n\t\tu32 idx = ~0;\n\n\t\tif (of_property_read_u32(np, \"reg\", &idx)) {\n\t\t\t \n\t\t}\n\n\t\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\t\tif (!pd) {\n\t\t\tof_node_put(np);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpd->genpd.name = np->name;\n\t\tpd->base = base;\n\t\tpd->bit_shift = idx;\n\n\t\trmobile_setup_pm_domain(np, pd);\n\t\tif (genpd_parent)\n\t\t\tpm_genpd_add_subdomain(genpd_parent, &pd->genpd);\n\t\tof_genpd_add_provider_simple(np, &pd->genpd);\n\n\t\trmobile_add_pm_domains(base, np, &pd->genpd);\n\t}\n\treturn 0;\n}\n\nstatic int __init rmobile_init_pm_domains(void)\n{\n\tstruct device_node *np, *pmd;\n\tbool scanned = false;\n\tvoid __iomem *base;\n\tint ret = 0;\n\n\tfor_each_compatible_node(np, NULL, \"renesas,sysc-rmobile\") {\n\t\tbase = of_iomap(np, 0);\n\t\tif (!base) {\n\t\t\tpr_warn(\"%pOF cannot map reg 0\\n\", np);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpmd = of_get_child_by_name(np, \"pm-domains\");\n\t\tif (!pmd) {\n\t\t\tiounmap(base);\n\t\t\tpr_warn(\"%pOF lacks pm-domains node\\n\", np);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!scanned) {\n\t\t\t \n\t\t\tget_special_pds();\n\t\t\tscanned = true;\n\t\t}\n\n\t\tret = rmobile_add_pm_domains(base, pmd, NULL);\n\t\tof_node_put(pmd);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\tbreak;\n\t\t}\n\n\t\tfwnode_dev_initialized(of_fwnode_handle(np), true);\n\t}\n\n\tput_special_pds();\n\n\treturn ret;\n}\n\ncore_initcall(rmobile_init_pm_domains);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}