{
  "module_name": "exynos-pm-domains.c",
  "hash_id": "eed03c7cae01e423f8167ae6317f9a6bcca6c6d6a40e570a9aa0c87339f64aaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/samsung/exynos-pm-domains.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/pm_domain.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/pm_runtime.h>\n\nstruct exynos_pm_domain_config {\n\t \n\tu32 local_pwr_cfg;\n};\n\n \nstruct exynos_pm_domain {\n\tvoid __iomem *base;\n\tstruct generic_pm_domain pd;\n\tu32 local_pwr_cfg;\n};\n\nstatic int exynos_pd_power(struct generic_pm_domain *domain, bool power_on)\n{\n\tstruct exynos_pm_domain *pd;\n\tvoid __iomem *base;\n\tu32 timeout, pwr;\n\tchar *op;\n\n\tpd = container_of(domain, struct exynos_pm_domain, pd);\n\tbase = pd->base;\n\n\tpwr = power_on ? pd->local_pwr_cfg : 0;\n\twritel_relaxed(pwr, base);\n\n\t \n\ttimeout = 10;\n\n\twhile ((readl_relaxed(base + 0x4) & pd->local_pwr_cfg) != pwr) {\n\t\tif (!timeout) {\n\t\t\top = (power_on) ? \"enable\" : \"disable\";\n\t\t\tpr_err(\"Power domain %s %s failed\\n\", domain->name, op);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\ttimeout--;\n\t\tcpu_relax();\n\t\tusleep_range(80, 100);\n\t}\n\n\treturn 0;\n}\n\nstatic int exynos_pd_power_on(struct generic_pm_domain *domain)\n{\n\treturn exynos_pd_power(domain, true);\n}\n\nstatic int exynos_pd_power_off(struct generic_pm_domain *domain)\n{\n\treturn exynos_pd_power(domain, false);\n}\n\nstatic const struct exynos_pm_domain_config exynos4210_cfg = {\n\t.local_pwr_cfg\t\t= 0x7,\n};\n\nstatic const struct exynos_pm_domain_config exynos5433_cfg = {\n\t.local_pwr_cfg\t\t= 0xf,\n};\n\nstatic const struct of_device_id exynos_pm_domain_of_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos4210-pd\",\n\t\t.data = &exynos4210_cfg,\n\t}, {\n\t\t.compatible = \"samsung,exynos5433-pd\",\n\t\t.data = &exynos5433_cfg,\n\t},\n\t{ },\n};\n\nstatic const char *exynos_get_domain_name(struct device_node *node)\n{\n\tconst char *name;\n\n\tif (of_property_read_string(node, \"label\", &name) < 0)\n\t\tname = kbasename(node->full_name);\n\treturn kstrdup_const(name, GFP_KERNEL);\n}\n\nstatic int exynos_pd_probe(struct platform_device *pdev)\n{\n\tconst struct exynos_pm_domain_config *pm_domain_cfg;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_args child, parent;\n\tstruct exynos_pm_domain *pd;\n\tint on, ret;\n\n\tpm_domain_cfg = of_device_get_match_data(dev);\n\tpd = devm_kzalloc(dev, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tpd->pd.name = exynos_get_domain_name(np);\n\tif (!pd->pd.name)\n\t\treturn -ENOMEM;\n\n\tpd->base = of_iomap(np, 0);\n\tif (!pd->base) {\n\t\tkfree_const(pd->pd.name);\n\t\treturn -ENODEV;\n\t}\n\n\tpd->pd.power_off = exynos_pd_power_off;\n\tpd->pd.power_on = exynos_pd_power_on;\n\tpd->local_pwr_cfg = pm_domain_cfg->local_pwr_cfg;\n\n\ton = readl_relaxed(pd->base + 0x4) & pd->local_pwr_cfg;\n\n\tpm_genpd_init(&pd->pd, NULL, !on);\n\tret = of_genpd_add_provider_simple(np, &pd->pd);\n\n\tif (ret == 0 && of_parse_phandle_with_args(np, \"power-domains\",\n\t\t\t\t      \"#power-domain-cells\", 0, &parent) == 0) {\n\t\tchild.np = np;\n\t\tchild.args_count = 0;\n\n\t\tif (of_genpd_add_subdomain(&parent, &child))\n\t\t\tpr_warn(\"%pOF failed to add subdomain: %pOF\\n\",\n\t\t\t\tparent.np, child.np);\n\t\telse\n\t\t\tpr_info(\"%pOF has as child subdomain: %pOF.\\n\",\n\t\t\t\tparent.np, child.np);\n\t}\n\n\tpm_runtime_enable(dev);\n\treturn ret;\n}\n\nstatic struct platform_driver exynos_pd_driver = {\n\t.probe\t= exynos_pd_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"exynos-pd\",\n\t\t.of_match_table\t= exynos_pm_domain_of_match,\n\t\t.suppress_bind_attrs = true,\n\t}\n};\n\nstatic __init int exynos4_pm_init_power_domain(void)\n{\n\treturn platform_driver_register(&exynos_pd_driver);\n}\ncore_initcall(exynos4_pm_init_power_domain);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}