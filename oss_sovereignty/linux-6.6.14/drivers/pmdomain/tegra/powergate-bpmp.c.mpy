{
  "module_name": "powergate-bpmp.c",
  "hash_id": "2e05f5d67153cb91510575badb73e218276a2dc07197d4b6d6a580767c6a74e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/tegra/powergate-bpmp.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/slab.h>\n\n#include <soc/tegra/bpmp.h>\n#include <soc/tegra/bpmp-abi.h>\n\nstruct tegra_powergate_info {\n\tunsigned int id;\n\tchar *name;\n};\n\nstruct tegra_powergate {\n\tstruct generic_pm_domain genpd;\n\tstruct tegra_bpmp *bpmp;\n\tunsigned int id;\n};\n\nstatic inline struct tegra_powergate *\nto_tegra_powergate(struct generic_pm_domain *genpd)\n{\n\treturn container_of(genpd, struct tegra_powergate, genpd);\n}\n\nstatic int tegra_bpmp_powergate_set_state(struct tegra_bpmp *bpmp,\n\t\t\t\t\t  unsigned int id, u32 state)\n{\n\tstruct mrq_pg_request request;\n\tstruct tegra_bpmp_message msg;\n\tint err;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.cmd = CMD_PG_SET_STATE;\n\trequest.id = id;\n\trequest.set_state.state = state;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_PG;\n\tmsg.tx.data = &request;\n\tmsg.tx.size = sizeof(request);\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err < 0)\n\t\treturn err;\n\telse if (msg.rx.ret < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int tegra_bpmp_powergate_get_state(struct tegra_bpmp *bpmp,\n\t\t\t\t\t  unsigned int id)\n{\n\tstruct mrq_pg_response response;\n\tstruct mrq_pg_request request;\n\tstruct tegra_bpmp_message msg;\n\tint err;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.cmd = CMD_PG_GET_STATE;\n\trequest.id = id;\n\n\tmemset(&response, 0, sizeof(response));\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_PG;\n\tmsg.tx.data = &request;\n\tmsg.tx.size = sizeof(request);\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err < 0)\n\t\treturn PG_STATE_OFF;\n\telse if (msg.rx.ret < 0)\n\t\treturn -EINVAL;\n\n\treturn response.get_state.state;\n}\n\nstatic int tegra_bpmp_powergate_get_max_id(struct tegra_bpmp *bpmp)\n{\n\tstruct mrq_pg_response response;\n\tstruct mrq_pg_request request;\n\tstruct tegra_bpmp_message msg;\n\tint err;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.cmd = CMD_PG_GET_MAX_ID;\n\n\tmemset(&response, 0, sizeof(response));\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_PG;\n\tmsg.tx.data = &request;\n\tmsg.tx.size = sizeof(request);\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err < 0)\n\t\treturn err;\n\telse if (msg.rx.ret < 0)\n\t\treturn -EINVAL;\n\n\treturn response.get_max_id.max_id;\n}\n\nstatic char *tegra_bpmp_powergate_get_name(struct tegra_bpmp *bpmp,\n\t\t\t\t\t   unsigned int id)\n{\n\tstruct mrq_pg_response response;\n\tstruct mrq_pg_request request;\n\tstruct tegra_bpmp_message msg;\n\tint err;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.cmd = CMD_PG_GET_NAME;\n\trequest.id = id;\n\n\tmemset(&response, 0, sizeof(response));\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_PG;\n\tmsg.tx.data = &request;\n\tmsg.tx.size = sizeof(request);\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err < 0 || msg.rx.ret < 0)\n\t\treturn NULL;\n\n\treturn kstrdup(response.get_name.name, GFP_KERNEL);\n}\n\nstatic inline bool tegra_bpmp_powergate_is_powered(struct tegra_bpmp *bpmp,\n\t\t\t\t\t\t   unsigned int id)\n{\n\treturn tegra_bpmp_powergate_get_state(bpmp, id) != PG_STATE_OFF;\n}\n\nstatic int tegra_powergate_power_on(struct generic_pm_domain *domain)\n{\n\tstruct tegra_powergate *powergate = to_tegra_powergate(domain);\n\tstruct tegra_bpmp *bpmp = powergate->bpmp;\n\n\treturn tegra_bpmp_powergate_set_state(bpmp, powergate->id,\n\t\t\t\t\t      PG_STATE_ON);\n}\n\nstatic int tegra_powergate_power_off(struct generic_pm_domain *domain)\n{\n\tstruct tegra_powergate *powergate = to_tegra_powergate(domain);\n\tstruct tegra_bpmp *bpmp = powergate->bpmp;\n\n\treturn tegra_bpmp_powergate_set_state(bpmp, powergate->id,\n\t\t\t\t\t      PG_STATE_OFF);\n}\n\nstatic struct tegra_powergate *\ntegra_powergate_add(struct tegra_bpmp *bpmp,\n\t\t    const struct tegra_powergate_info *info)\n{\n\tstruct tegra_powergate *powergate;\n\tbool off;\n\tint err;\n\n\toff = !tegra_bpmp_powergate_is_powered(bpmp, info->id);\n\n\tpowergate = devm_kzalloc(bpmp->dev, sizeof(*powergate), GFP_KERNEL);\n\tif (!powergate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpowergate->id = info->id;\n\tpowergate->bpmp = bpmp;\n\n\tpowergate->genpd.name = kstrdup(info->name, GFP_KERNEL);\n\tpowergate->genpd.power_on = tegra_powergate_power_on;\n\tpowergate->genpd.power_off = tegra_powergate_power_off;\n\n\terr = pm_genpd_init(&powergate->genpd, NULL, off);\n\tif (err < 0) {\n\t\tkfree(powergate->genpd.name);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn powergate;\n}\n\nstatic void tegra_powergate_remove(struct tegra_powergate *powergate)\n{\n\tstruct generic_pm_domain *genpd = &powergate->genpd;\n\tstruct tegra_bpmp *bpmp = powergate->bpmp;\n\tint err;\n\n\terr = pm_genpd_remove(genpd);\n\tif (err < 0)\n\t\tdev_err(bpmp->dev, \"failed to remove power domain %s: %d\\n\",\n\t\t\tgenpd->name, err);\n\n\tkfree(genpd->name);\n}\n\nstatic int\ntegra_bpmp_probe_powergates(struct tegra_bpmp *bpmp,\n\t\t\t    struct tegra_powergate_info **powergatesp)\n{\n\tstruct tegra_powergate_info *powergates;\n\tunsigned int max_id, id, count = 0;\n\tunsigned int num_holes = 0;\n\tint err;\n\n\terr = tegra_bpmp_powergate_get_max_id(bpmp);\n\tif (err < 0)\n\t\treturn err;\n\n\tmax_id = err;\n\n\tdev_dbg(bpmp->dev, \"maximum powergate ID: %u\\n\", max_id);\n\n\tpowergates = kcalloc(max_id + 1, sizeof(*powergates), GFP_KERNEL);\n\tif (!powergates)\n\t\treturn -ENOMEM;\n\n\tfor (id = 0; id <= max_id; id++) {\n\t\tstruct tegra_powergate_info *info = &powergates[count];\n\n\t\tinfo->name = tegra_bpmp_powergate_get_name(bpmp, id);\n\t\tif (!info->name || info->name[0] == '\\0') {\n\t\t\tnum_holes++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinfo->id = id;\n\t\tcount++;\n\t}\n\n\tdev_dbg(bpmp->dev, \"holes: %u\\n\", num_holes);\n\n\t*powergatesp = powergates;\n\n\treturn count;\n}\n\nstatic int tegra_bpmp_add_powergates(struct tegra_bpmp *bpmp,\n\t\t\t\t     struct tegra_powergate_info *powergates,\n\t\t\t\t     unsigned int count)\n{\n\tstruct genpd_onecell_data *genpd = &bpmp->genpd;\n\tstruct generic_pm_domain **domains;\n\tstruct tegra_powergate *powergate;\n\tunsigned int i;\n\tint err;\n\n\tdomains = kcalloc(count, sizeof(*domains), GFP_KERNEL);\n\tif (!domains)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; i++) {\n\t\tpowergate = tegra_powergate_add(bpmp, &powergates[i]);\n\t\tif (IS_ERR(powergate)) {\n\t\t\terr = PTR_ERR(powergate);\n\t\t\tgoto remove;\n\t\t}\n\n\t\tdev_dbg(bpmp->dev, \"added power domain %s\\n\",\n\t\t\tpowergate->genpd.name);\n\t\tdomains[i] = &powergate->genpd;\n\t}\n\n\tgenpd->num_domains = count;\n\tgenpd->domains = domains;\n\n\treturn 0;\n\nremove:\n\twhile (i--) {\n\t\tpowergate = to_tegra_powergate(domains[i]);\n\t\ttegra_powergate_remove(powergate);\n\t}\n\n\tkfree(domains);\n\treturn err;\n}\n\nstatic void tegra_bpmp_remove_powergates(struct tegra_bpmp *bpmp)\n{\n\tstruct genpd_onecell_data *genpd = &bpmp->genpd;\n\tunsigned int i = genpd->num_domains;\n\tstruct tegra_powergate *powergate;\n\n\twhile (i--) {\n\t\tdev_dbg(bpmp->dev, \"removing power domain %s\\n\",\n\t\t\tgenpd->domains[i]->name);\n\t\tpowergate = to_tegra_powergate(genpd->domains[i]);\n\t\ttegra_powergate_remove(powergate);\n\t}\n}\n\nstatic struct generic_pm_domain *\ntegra_powergate_xlate(struct of_phandle_args *spec, void *data)\n{\n\tstruct generic_pm_domain *domain = ERR_PTR(-ENOENT);\n\tstruct genpd_onecell_data *genpd = data;\n\tunsigned int i;\n\n\tfor (i = 0; i < genpd->num_domains; i++) {\n\t\tstruct tegra_powergate *powergate;\n\n\t\tpowergate = to_tegra_powergate(genpd->domains[i]);\n\t\tif (powergate->id == spec->args[0]) {\n\t\t\tdomain = &powergate->genpd;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn domain;\n}\n\nint tegra_bpmp_init_powergates(struct tegra_bpmp *bpmp)\n{\n\tstruct device_node *np = bpmp->dev->of_node;\n\tstruct tegra_powergate_info *powergates;\n\tstruct device *dev = bpmp->dev;\n\tunsigned int count, i;\n\tint err;\n\n\terr = tegra_bpmp_probe_powergates(bpmp, &powergates);\n\tif (err < 0)\n\t\treturn err;\n\n\tcount = err;\n\n\tdev_dbg(dev, \"%u power domains probed\\n\", count);\n\n\terr = tegra_bpmp_add_powergates(bpmp, powergates, count);\n\tif (err < 0)\n\t\tgoto free;\n\n\tbpmp->genpd.xlate = tegra_powergate_xlate;\n\n\terr = of_genpd_add_provider_onecell(np, &bpmp->genpd);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to add power domain provider: %d\\n\", err);\n\t\ttegra_bpmp_remove_powergates(bpmp);\n\t}\n\nfree:\n\tfor (i = 0; i < count; i++)\n\t\tkfree(powergates[i].name);\n\n\tkfree(powergates);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}