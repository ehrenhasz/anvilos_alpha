{
  "module_name": "meson-ee-pwrc.c",
  "hash_id": "49235141ba8c4893afb8b675c96b3d2f267e0e18c663348d18a6b56f58cc4a63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/amlogic/meson-ee-pwrc.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/bitfield.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/reset-controller.h>\n#include <linux/reset.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <dt-bindings/power/meson8-power.h>\n#include <dt-bindings/power/meson-axg-power.h>\n#include <dt-bindings/power/meson-g12a-power.h>\n#include <dt-bindings/power/meson-gxbb-power.h>\n#include <dt-bindings/power/meson-sm1-power.h>\n\n \n\n#define GX_AO_RTI_GEN_PWR_SLEEP0\t(0x3a << 2)\n#define GX_AO_RTI_GEN_PWR_ISO0\t\t(0x3b << 2)\n\n \n#define MESON8_AO_RTI_GEN_PWR_SLEEP0\t(0x02 << 2)\n#define MESON8_AO_RTI_GEN_PWR_ISO0\t(0x03 << 2)\n\n \n\n#define HHI_MEM_PD_REG0\t\t\t(0x40 << 2)\n#define HHI_VPU_MEM_PD_REG0\t\t(0x41 << 2)\n#define HHI_VPU_MEM_PD_REG1\t\t(0x42 << 2)\n#define HHI_VPU_MEM_PD_REG3\t\t(0x43 << 2)\n#define HHI_VPU_MEM_PD_REG4\t\t(0x44 << 2)\n#define HHI_AUDIO_MEM_PD_REG0\t\t(0x45 << 2)\n#define HHI_NANOQ_MEM_PD_REG0\t\t(0x46 << 2)\n#define HHI_NANOQ_MEM_PD_REG1\t\t(0x47 << 2)\n#define HHI_VPU_MEM_PD_REG2\t\t(0x4d << 2)\n\n#define G12A_HHI_NANOQ_MEM_PD_REG0\t(0x43 << 2)\n#define G12A_HHI_NANOQ_MEM_PD_REG1\t(0x44 << 2)\n\nstruct meson_ee_pwrc;\nstruct meson_ee_pwrc_domain;\n\nstruct meson_ee_pwrc_mem_domain {\n\tunsigned int reg;\n\tunsigned int mask;\n};\n\nstruct meson_ee_pwrc_top_domain {\n\tunsigned int sleep_reg;\n\tunsigned int sleep_mask;\n\tunsigned int iso_reg;\n\tunsigned int iso_mask;\n};\n\nstruct meson_ee_pwrc_domain_desc {\n\tchar *name;\n\tunsigned int reset_names_count;\n\tunsigned int clk_names_count;\n\tstruct meson_ee_pwrc_top_domain *top_pd;\n\tunsigned int mem_pd_count;\n\tstruct meson_ee_pwrc_mem_domain *mem_pd;\n\tbool (*is_powered_off)(struct meson_ee_pwrc_domain *pwrc_domain);\n};\n\nstruct meson_ee_pwrc_domain_data {\n\tunsigned int count;\n\tstruct meson_ee_pwrc_domain_desc *domains;\n};\n\n \n\nstatic struct meson_ee_pwrc_top_domain gx_pwrc_vpu = {\n\t.sleep_reg = GX_AO_RTI_GEN_PWR_SLEEP0,\n\t.sleep_mask = BIT(8),\n\t.iso_reg = GX_AO_RTI_GEN_PWR_SLEEP0,\n\t.iso_mask = BIT(9),\n};\n\nstatic struct meson_ee_pwrc_top_domain meson8_pwrc_vpu = {\n\t.sleep_reg = MESON8_AO_RTI_GEN_PWR_SLEEP0,\n\t.sleep_mask = BIT(8),\n\t.iso_reg = MESON8_AO_RTI_GEN_PWR_SLEEP0,\n\t.iso_mask = BIT(9),\n};\n\n#define SM1_EE_PD(__bit)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.sleep_reg = GX_AO_RTI_GEN_PWR_SLEEP0, \t\t\\\n\t\t.sleep_mask = BIT(__bit), \t\t\t\\\n\t\t.iso_reg = GX_AO_RTI_GEN_PWR_ISO0, \t\t\\\n\t\t.iso_mask = BIT(__bit), \t\t\t\\\n\t}\n\nstatic struct meson_ee_pwrc_top_domain sm1_pwrc_vpu = SM1_EE_PD(8);\nstatic struct meson_ee_pwrc_top_domain sm1_pwrc_nna = SM1_EE_PD(16);\nstatic struct meson_ee_pwrc_top_domain sm1_pwrc_usb = SM1_EE_PD(17);\nstatic struct meson_ee_pwrc_top_domain sm1_pwrc_pci = SM1_EE_PD(18);\nstatic struct meson_ee_pwrc_top_domain sm1_pwrc_ge2d = SM1_EE_PD(19);\n\nstatic struct meson_ee_pwrc_top_domain g12a_pwrc_nna = {\n\t.sleep_reg = GX_AO_RTI_GEN_PWR_SLEEP0,\n\t.sleep_mask = BIT(16) | BIT(17),\n\t.iso_reg = GX_AO_RTI_GEN_PWR_ISO0,\n\t.iso_mask = BIT(16) | BIT(17),\n};\n\n \n\n#define VPU_MEMPD(__reg)\t\t\t\t\t\\\n\t{ __reg, GENMASK(1, 0) },\t\t\t\t\\\n\t{ __reg, GENMASK(3, 2) },\t\t\t\t\\\n\t{ __reg, GENMASK(5, 4) },\t\t\t\t\\\n\t{ __reg, GENMASK(7, 6) },\t\t\t\t\\\n\t{ __reg, GENMASK(9, 8) },\t\t\t\t\\\n\t{ __reg, GENMASK(11, 10) },\t\t\t\t\\\n\t{ __reg, GENMASK(13, 12) },\t\t\t\t\\\n\t{ __reg, GENMASK(15, 14) },\t\t\t\t\\\n\t{ __reg, GENMASK(17, 16) },\t\t\t\t\\\n\t{ __reg, GENMASK(19, 18) },\t\t\t\t\\\n\t{ __reg, GENMASK(21, 20) },\t\t\t\t\\\n\t{ __reg, GENMASK(23, 22) },\t\t\t\t\\\n\t{ __reg, GENMASK(25, 24) },\t\t\t\t\\\n\t{ __reg, GENMASK(27, 26) },\t\t\t\t\\\n\t{ __reg, GENMASK(29, 28) },\t\t\t\t\\\n\t{ __reg, GENMASK(31, 30) }\n\n#define VPU_HHI_MEMPD(__reg)\t\t\t\t\t\\\n\t{ __reg, BIT(8) },\t\t\t\t\t\\\n\t{ __reg, BIT(9) },\t\t\t\t\t\\\n\t{ __reg, BIT(10) },\t\t\t\t\t\\\n\t{ __reg, BIT(11) },\t\t\t\t\t\\\n\t{ __reg, BIT(12) },\t\t\t\t\t\\\n\t{ __reg, BIT(13) },\t\t\t\t\t\\\n\t{ __reg, BIT(14) },\t\t\t\t\t\\\n\t{ __reg, BIT(15) }\n\nstatic struct meson_ee_pwrc_mem_domain axg_pwrc_mem_vpu[] = {\n\tVPU_MEMPD(HHI_VPU_MEM_PD_REG0),\n\tVPU_HHI_MEMPD(HHI_MEM_PD_REG0),\n};\n\nstatic struct meson_ee_pwrc_mem_domain g12a_pwrc_mem_vpu[] = {\n\tVPU_MEMPD(HHI_VPU_MEM_PD_REG0),\n\tVPU_MEMPD(HHI_VPU_MEM_PD_REG1),\n\tVPU_MEMPD(HHI_VPU_MEM_PD_REG2),\n\tVPU_HHI_MEMPD(HHI_MEM_PD_REG0),\n};\n\nstatic struct meson_ee_pwrc_mem_domain gxbb_pwrc_mem_vpu[] = {\n\tVPU_MEMPD(HHI_VPU_MEM_PD_REG0),\n\tVPU_MEMPD(HHI_VPU_MEM_PD_REG1),\n\tVPU_HHI_MEMPD(HHI_MEM_PD_REG0),\n};\n\nstatic struct meson_ee_pwrc_mem_domain meson_pwrc_mem_eth[] = {\n\t{ HHI_MEM_PD_REG0, GENMASK(3, 2) },\n};\n\nstatic struct meson_ee_pwrc_mem_domain meson8_pwrc_audio_dsp_mem[] = {\n\t{ HHI_MEM_PD_REG0, GENMASK(1, 0) },\n};\n\nstatic struct meson_ee_pwrc_mem_domain meson8_pwrc_mem_vpu[] = {\n\tVPU_MEMPD(HHI_VPU_MEM_PD_REG0),\n\tVPU_MEMPD(HHI_VPU_MEM_PD_REG1),\n\tVPU_HHI_MEMPD(HHI_MEM_PD_REG0),\n};\n\nstatic struct meson_ee_pwrc_mem_domain sm1_pwrc_mem_vpu[] = {\n\tVPU_MEMPD(HHI_VPU_MEM_PD_REG0),\n\tVPU_MEMPD(HHI_VPU_MEM_PD_REG1),\n\tVPU_MEMPD(HHI_VPU_MEM_PD_REG2),\n\tVPU_MEMPD(HHI_VPU_MEM_PD_REG3),\n\t{ HHI_VPU_MEM_PD_REG4, GENMASK(1, 0) },\n\t{ HHI_VPU_MEM_PD_REG4, GENMASK(3, 2) },\n\t{ HHI_VPU_MEM_PD_REG4, GENMASK(5, 4) },\n\t{ HHI_VPU_MEM_PD_REG4, GENMASK(7, 6) },\n\tVPU_HHI_MEMPD(HHI_MEM_PD_REG0),\n};\n\nstatic struct meson_ee_pwrc_mem_domain sm1_pwrc_mem_nna[] = {\n\t{ HHI_NANOQ_MEM_PD_REG0, 0xff },\n\t{ HHI_NANOQ_MEM_PD_REG1, 0xff },\n};\n\nstatic struct meson_ee_pwrc_mem_domain sm1_pwrc_mem_usb[] = {\n\t{ HHI_MEM_PD_REG0, GENMASK(31, 30) },\n};\n\nstatic struct meson_ee_pwrc_mem_domain sm1_pwrc_mem_pcie[] = {\n\t{ HHI_MEM_PD_REG0, GENMASK(29, 26) },\n};\n\nstatic struct meson_ee_pwrc_mem_domain sm1_pwrc_mem_ge2d[] = {\n\t{ HHI_MEM_PD_REG0, GENMASK(25, 18) },\n};\n\nstatic struct meson_ee_pwrc_mem_domain axg_pwrc_mem_audio[] = {\n\t{ HHI_MEM_PD_REG0, GENMASK(5, 4) },\n};\n\nstatic struct meson_ee_pwrc_mem_domain sm1_pwrc_mem_audio[] = {\n\t{ HHI_MEM_PD_REG0, GENMASK(5, 4) },\n\t{ HHI_AUDIO_MEM_PD_REG0, GENMASK(1, 0) },\n\t{ HHI_AUDIO_MEM_PD_REG0, GENMASK(3, 2) },\n\t{ HHI_AUDIO_MEM_PD_REG0, GENMASK(5, 4) },\n\t{ HHI_AUDIO_MEM_PD_REG0, GENMASK(7, 6) },\n\t{ HHI_AUDIO_MEM_PD_REG0, GENMASK(13, 12) },\n\t{ HHI_AUDIO_MEM_PD_REG0, GENMASK(15, 14) },\n\t{ HHI_AUDIO_MEM_PD_REG0, GENMASK(17, 16) },\n\t{ HHI_AUDIO_MEM_PD_REG0, GENMASK(19, 18) },\n\t{ HHI_AUDIO_MEM_PD_REG0, GENMASK(21, 20) },\n\t{ HHI_AUDIO_MEM_PD_REG0, GENMASK(23, 22) },\n\t{ HHI_AUDIO_MEM_PD_REG0, GENMASK(25, 24) },\n\t{ HHI_AUDIO_MEM_PD_REG0, GENMASK(27, 26) },\n};\n\nstatic struct meson_ee_pwrc_mem_domain g12a_pwrc_mem_nna[] = {\n\t{ G12A_HHI_NANOQ_MEM_PD_REG0, GENMASK(31, 0) },\n\t{ G12A_HHI_NANOQ_MEM_PD_REG1, GENMASK(31, 0) },\n};\n\n#define VPU_PD(__name, __top_pd, __mem, __is_pwr_off, __resets, __clks)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = __name,\t\t\t\t\t\t\\\n\t\t.reset_names_count = __resets,\t\t\t\t\\\n\t\t.clk_names_count = __clks,\t\t\t\t\\\n\t\t.top_pd = __top_pd,\t\t\t\t\t\\\n\t\t.mem_pd_count = ARRAY_SIZE(__mem),\t\t\t\\\n\t\t.mem_pd = __mem,\t\t\t\t\t\\\n\t\t.is_powered_off = __is_pwr_off,\t\t\t\t\\\n\t}\n\n#define TOP_PD(__name, __top_pd, __mem, __is_pwr_off)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = __name,\t\t\t\t\t\t\\\n\t\t.top_pd = __top_pd,\t\t\t\t\t\\\n\t\t.mem_pd_count = ARRAY_SIZE(__mem),\t\t\t\\\n\t\t.mem_pd = __mem,\t\t\t\t\t\\\n\t\t.is_powered_off = __is_pwr_off,\t\t\t\t\\\n\t}\n\n#define MEM_PD(__name, __mem)\t\t\t\t\t\t\\\n\tTOP_PD(__name, NULL, __mem, NULL)\n\nstatic bool pwrc_ee_is_powered_off(struct meson_ee_pwrc_domain *pwrc_domain);\n\nstatic struct meson_ee_pwrc_domain_desc axg_pwrc_domains[] = {\n\t[PWRC_AXG_VPU_ID]  = VPU_PD(\"VPU\", &gx_pwrc_vpu, axg_pwrc_mem_vpu,\n\t\t\t\t     pwrc_ee_is_powered_off, 5, 2),\n\t[PWRC_AXG_ETHERNET_MEM_ID] = MEM_PD(\"ETH\", meson_pwrc_mem_eth),\n\t[PWRC_AXG_AUDIO_ID] = MEM_PD(\"AUDIO\", axg_pwrc_mem_audio),\n};\n\nstatic struct meson_ee_pwrc_domain_desc g12a_pwrc_domains[] = {\n\t[PWRC_G12A_VPU_ID]  = VPU_PD(\"VPU\", &gx_pwrc_vpu, g12a_pwrc_mem_vpu,\n\t\t\t\t     pwrc_ee_is_powered_off, 11, 2),\n\t[PWRC_G12A_ETH_ID] = MEM_PD(\"ETH\", meson_pwrc_mem_eth),\n\t[PWRC_G12A_NNA_ID] = TOP_PD(\"NNA\", &g12a_pwrc_nna, g12a_pwrc_mem_nna,\n\t\t\t\t    pwrc_ee_is_powered_off),\n};\n\nstatic struct meson_ee_pwrc_domain_desc gxbb_pwrc_domains[] = {\n\t[PWRC_GXBB_VPU_ID]  = VPU_PD(\"VPU\", &gx_pwrc_vpu, gxbb_pwrc_mem_vpu,\n\t\t\t\t     pwrc_ee_is_powered_off, 12, 2),\n\t[PWRC_GXBB_ETHERNET_MEM_ID] = MEM_PD(\"ETH\", meson_pwrc_mem_eth),\n};\n\nstatic struct meson_ee_pwrc_domain_desc meson8_pwrc_domains[] = {\n\t[PWRC_MESON8_VPU_ID]  = VPU_PD(\"VPU\", &meson8_pwrc_vpu,\n\t\t\t\t       meson8_pwrc_mem_vpu,\n\t\t\t\t       pwrc_ee_is_powered_off, 0, 1),\n\t[PWRC_MESON8_ETHERNET_MEM_ID] = MEM_PD(\"ETHERNET_MEM\",\n\t\t\t\t\t       meson_pwrc_mem_eth),\n\t[PWRC_MESON8_AUDIO_DSP_MEM_ID] = MEM_PD(\"AUDIO_DSP_MEM\",\n\t\t\t\t\t\tmeson8_pwrc_audio_dsp_mem),\n};\n\nstatic struct meson_ee_pwrc_domain_desc meson8b_pwrc_domains[] = {\n\t[PWRC_MESON8_VPU_ID]  = VPU_PD(\"VPU\", &meson8_pwrc_vpu,\n\t\t\t\t       meson8_pwrc_mem_vpu,\n\t\t\t\t       pwrc_ee_is_powered_off, 11, 1),\n\t[PWRC_MESON8_ETHERNET_MEM_ID] = MEM_PD(\"ETHERNET_MEM\",\n\t\t\t\t\t       meson_pwrc_mem_eth),\n\t[PWRC_MESON8_AUDIO_DSP_MEM_ID] = MEM_PD(\"AUDIO_DSP_MEM\",\n\t\t\t\t\t\tmeson8_pwrc_audio_dsp_mem),\n};\n\nstatic struct meson_ee_pwrc_domain_desc sm1_pwrc_domains[] = {\n\t[PWRC_SM1_VPU_ID]  = VPU_PD(\"VPU\", &sm1_pwrc_vpu, sm1_pwrc_mem_vpu,\n\t\t\t\t    pwrc_ee_is_powered_off, 11, 2),\n\t[PWRC_SM1_NNA_ID]  = TOP_PD(\"NNA\", &sm1_pwrc_nna, sm1_pwrc_mem_nna,\n\t\t\t\t    pwrc_ee_is_powered_off),\n\t[PWRC_SM1_USB_ID]  = TOP_PD(\"USB\", &sm1_pwrc_usb, sm1_pwrc_mem_usb,\n\t\t\t\t    pwrc_ee_is_powered_off),\n\t[PWRC_SM1_PCIE_ID] = TOP_PD(\"PCI\", &sm1_pwrc_pci, sm1_pwrc_mem_pcie,\n\t\t\t\t    pwrc_ee_is_powered_off),\n\t[PWRC_SM1_GE2D_ID] = TOP_PD(\"GE2D\", &sm1_pwrc_ge2d, sm1_pwrc_mem_ge2d,\n\t\t\t\t    pwrc_ee_is_powered_off),\n\t[PWRC_SM1_AUDIO_ID] = MEM_PD(\"AUDIO\", sm1_pwrc_mem_audio),\n\t[PWRC_SM1_ETH_ID] = MEM_PD(\"ETH\", meson_pwrc_mem_eth),\n};\n\nstruct meson_ee_pwrc_domain {\n\tstruct generic_pm_domain base;\n\tbool enabled;\n\tstruct meson_ee_pwrc *pwrc;\n\tstruct meson_ee_pwrc_domain_desc desc;\n\tstruct clk_bulk_data *clks;\n\tint num_clks;\n\tstruct reset_control *rstc;\n\tint num_rstc;\n};\n\nstruct meson_ee_pwrc {\n\tstruct regmap *regmap_ao;\n\tstruct regmap *regmap_hhi;\n\tstruct meson_ee_pwrc_domain *domains;\n\tstruct genpd_onecell_data xlate;\n};\n\nstatic bool pwrc_ee_is_powered_off(struct meson_ee_pwrc_domain *pwrc_domain)\n{\n\tu32 reg;\n\n\tregmap_read(pwrc_domain->pwrc->regmap_ao,\n\t\t    pwrc_domain->desc.top_pd->sleep_reg, &reg);\n\n\treturn (reg & pwrc_domain->desc.top_pd->sleep_mask);\n}\n\nstatic int meson_ee_pwrc_off(struct generic_pm_domain *domain)\n{\n\tstruct meson_ee_pwrc_domain *pwrc_domain =\n\t\tcontainer_of(domain, struct meson_ee_pwrc_domain, base);\n\tint i;\n\n\tif (pwrc_domain->desc.top_pd)\n\t\tregmap_update_bits(pwrc_domain->pwrc->regmap_ao,\n\t\t\t\t   pwrc_domain->desc.top_pd->sleep_reg,\n\t\t\t\t   pwrc_domain->desc.top_pd->sleep_mask,\n\t\t\t\t   pwrc_domain->desc.top_pd->sleep_mask);\n\tudelay(20);\n\n\tfor (i = 0 ; i < pwrc_domain->desc.mem_pd_count ; ++i)\n\t\tregmap_update_bits(pwrc_domain->pwrc->regmap_hhi,\n\t\t\t\t   pwrc_domain->desc.mem_pd[i].reg,\n\t\t\t\t   pwrc_domain->desc.mem_pd[i].mask,\n\t\t\t\t   pwrc_domain->desc.mem_pd[i].mask);\n\n\tudelay(20);\n\n\tif (pwrc_domain->desc.top_pd)\n\t\tregmap_update_bits(pwrc_domain->pwrc->regmap_ao,\n\t\t\t\t   pwrc_domain->desc.top_pd->iso_reg,\n\t\t\t\t   pwrc_domain->desc.top_pd->iso_mask,\n\t\t\t\t   pwrc_domain->desc.top_pd->iso_mask);\n\n\tif (pwrc_domain->num_clks) {\n\t\tmsleep(20);\n\t\tclk_bulk_disable_unprepare(pwrc_domain->num_clks,\n\t\t\t\t\t   pwrc_domain->clks);\n\t}\n\n\treturn 0;\n}\n\nstatic int meson_ee_pwrc_on(struct generic_pm_domain *domain)\n{\n\tstruct meson_ee_pwrc_domain *pwrc_domain =\n\t\tcontainer_of(domain, struct meson_ee_pwrc_domain, base);\n\tint i, ret;\n\n\tif (pwrc_domain->desc.top_pd)\n\t\tregmap_update_bits(pwrc_domain->pwrc->regmap_ao,\n\t\t\t\t   pwrc_domain->desc.top_pd->sleep_reg,\n\t\t\t\t   pwrc_domain->desc.top_pd->sleep_mask, 0);\n\tudelay(20);\n\n\tfor (i = 0 ; i < pwrc_domain->desc.mem_pd_count ; ++i)\n\t\tregmap_update_bits(pwrc_domain->pwrc->regmap_hhi,\n\t\t\t\t   pwrc_domain->desc.mem_pd[i].reg,\n\t\t\t\t   pwrc_domain->desc.mem_pd[i].mask, 0);\n\n\tudelay(20);\n\n\tret = reset_control_assert(pwrc_domain->rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pwrc_domain->desc.top_pd)\n\t\tregmap_update_bits(pwrc_domain->pwrc->regmap_ao,\n\t\t\t\t   pwrc_domain->desc.top_pd->iso_reg,\n\t\t\t\t   pwrc_domain->desc.top_pd->iso_mask, 0);\n\n\tret = reset_control_deassert(pwrc_domain->rstc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn clk_bulk_prepare_enable(pwrc_domain->num_clks,\n\t\t\t\t       pwrc_domain->clks);\n}\n\nstatic int meson_ee_pwrc_init_domain(struct platform_device *pdev,\n\t\t\t\t     struct meson_ee_pwrc *pwrc,\n\t\t\t\t     struct meson_ee_pwrc_domain *dom)\n{\n\tint ret;\n\n\tdom->pwrc = pwrc;\n\tdom->num_rstc = dom->desc.reset_names_count;\n\tdom->num_clks = dom->desc.clk_names_count;\n\n\tif (dom->num_rstc) {\n\t\tint count = reset_control_get_count(&pdev->dev);\n\n\t\tif (count != dom->num_rstc)\n\t\t\tdev_warn(&pdev->dev, \"Invalid resets count %d for domain %s\\n\",\n\t\t\t\t count, dom->desc.name);\n\n\t\tdom->rstc = devm_reset_control_array_get_exclusive(&pdev->dev);\n\t\tif (IS_ERR(dom->rstc))\n\t\t\treturn PTR_ERR(dom->rstc);\n\t}\n\n\tif (dom->num_clks) {\n\t\tint ret = devm_clk_bulk_get_all(&pdev->dev, &dom->clks);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (dom->num_clks != ret) {\n\t\t\tdev_warn(&pdev->dev, \"Invalid clocks count %d for domain %s\\n\",\n\t\t\t\t ret, dom->desc.name);\n\t\t\tdom->num_clks = ret;\n\t\t}\n\t}\n\n\tdom->base.name = dom->desc.name;\n\tdom->base.power_on = meson_ee_pwrc_on;\n\tdom->base.power_off = meson_ee_pwrc_off;\n\n\t \n\tif (dom->num_clks && dom->desc.is_powered_off && !dom->desc.is_powered_off(dom)) {\n\t\tret = clk_bulk_prepare_enable(dom->num_clks, dom->clks);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdom->base.flags = GENPD_FLAG_ALWAYS_ON;\n\t\tret = pm_genpd_init(&dom->base, NULL, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = pm_genpd_init(&dom->base, NULL,\n\t\t\t\t    (dom->desc.is_powered_off ?\n\t\t\t\t     dom->desc.is_powered_off(dom) : true));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int meson_ee_pwrc_probe(struct platform_device *pdev)\n{\n\tconst struct meson_ee_pwrc_domain_data *match;\n\tstruct regmap *regmap_ao, *regmap_hhi;\n\tstruct device_node *parent_np;\n\tstruct meson_ee_pwrc *pwrc;\n\tint i, ret;\n\n\tmatch = of_device_get_match_data(&pdev->dev);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"failed to get match data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpwrc = devm_kzalloc(&pdev->dev, sizeof(*pwrc), GFP_KERNEL);\n\tif (!pwrc)\n\t\treturn -ENOMEM;\n\n\tpwrc->xlate.domains = devm_kcalloc(&pdev->dev, match->count,\n\t\t\t\t\t   sizeof(*pwrc->xlate.domains),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!pwrc->xlate.domains)\n\t\treturn -ENOMEM;\n\n\tpwrc->domains = devm_kcalloc(&pdev->dev, match->count,\n\t\t\t\t     sizeof(*pwrc->domains), GFP_KERNEL);\n\tif (!pwrc->domains)\n\t\treturn -ENOMEM;\n\n\tpwrc->xlate.num_domains = match->count;\n\n\tparent_np = of_get_parent(pdev->dev.of_node);\n\tregmap_hhi = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap_hhi)) {\n\t\tdev_err(&pdev->dev, \"failed to get HHI regmap\\n\");\n\t\treturn PTR_ERR(regmap_hhi);\n\t}\n\n\tregmap_ao = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t    \"amlogic,ao-sysctrl\");\n\tif (IS_ERR(regmap_ao)) {\n\t\tdev_err(&pdev->dev, \"failed to get AO regmap\\n\");\n\t\treturn PTR_ERR(regmap_ao);\n\t}\n\n\tpwrc->regmap_ao = regmap_ao;\n\tpwrc->regmap_hhi = regmap_hhi;\n\n\tplatform_set_drvdata(pdev, pwrc);\n\n\tfor (i = 0 ; i < match->count ; ++i) {\n\t\tstruct meson_ee_pwrc_domain *dom = &pwrc->domains[i];\n\n\t\tmemcpy(&dom->desc, &match->domains[i], sizeof(dom->desc));\n\n\t\tret = meson_ee_pwrc_init_domain(pdev, pwrc, dom);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpwrc->xlate.domains[i] = &dom->base;\n\t}\n\n\treturn of_genpd_add_provider_onecell(pdev->dev.of_node, &pwrc->xlate);\n}\n\nstatic void meson_ee_pwrc_shutdown(struct platform_device *pdev)\n{\n\tstruct meson_ee_pwrc *pwrc = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0 ; i < pwrc->xlate.num_domains ; ++i) {\n\t\tstruct meson_ee_pwrc_domain *dom = &pwrc->domains[i];\n\n\t\tif (dom->desc.is_powered_off && !dom->desc.is_powered_off(dom))\n\t\t\tmeson_ee_pwrc_off(&dom->base);\n\t}\n}\n\nstatic struct meson_ee_pwrc_domain_data meson_ee_g12a_pwrc_data = {\n\t.count = ARRAY_SIZE(g12a_pwrc_domains),\n\t.domains = g12a_pwrc_domains,\n};\n\nstatic struct meson_ee_pwrc_domain_data meson_ee_axg_pwrc_data = {\n\t.count = ARRAY_SIZE(axg_pwrc_domains),\n\t.domains = axg_pwrc_domains,\n};\n\nstatic struct meson_ee_pwrc_domain_data meson_ee_gxbb_pwrc_data = {\n\t.count = ARRAY_SIZE(gxbb_pwrc_domains),\n\t.domains = gxbb_pwrc_domains,\n};\n\nstatic struct meson_ee_pwrc_domain_data meson_ee_m8_pwrc_data = {\n\t.count = ARRAY_SIZE(meson8_pwrc_domains),\n\t.domains = meson8_pwrc_domains,\n};\n\nstatic struct meson_ee_pwrc_domain_data meson_ee_m8b_pwrc_data = {\n\t.count = ARRAY_SIZE(meson8b_pwrc_domains),\n\t.domains = meson8b_pwrc_domains,\n};\n\nstatic struct meson_ee_pwrc_domain_data meson_ee_sm1_pwrc_data = {\n\t.count = ARRAY_SIZE(sm1_pwrc_domains),\n\t.domains = sm1_pwrc_domains,\n};\n\nstatic const struct of_device_id meson_ee_pwrc_match_table[] = {\n\t{\n\t\t.compatible = \"amlogic,meson8-pwrc\",\n\t\t.data = &meson_ee_m8_pwrc_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson8b-pwrc\",\n\t\t.data = &meson_ee_m8b_pwrc_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson8m2-pwrc\",\n\t\t.data = &meson_ee_m8b_pwrc_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-axg-pwrc\",\n\t\t.data = &meson_ee_axg_pwrc_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-gxbb-pwrc\",\n\t\t.data = &meson_ee_gxbb_pwrc_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-g12a-pwrc\",\n\t\t.data = &meson_ee_g12a_pwrc_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-sm1-pwrc\",\n\t\t.data = &meson_ee_sm1_pwrc_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, meson_ee_pwrc_match_table);\n\nstatic struct platform_driver meson_ee_pwrc_driver = {\n\t.probe = meson_ee_pwrc_probe,\n\t.shutdown = meson_ee_pwrc_shutdown,\n\t.driver = {\n\t\t.name\t\t= \"meson_ee_pwrc\",\n\t\t.of_match_table\t= meson_ee_pwrc_match_table,\n\t},\n};\nmodule_platform_driver(meson_ee_pwrc_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}