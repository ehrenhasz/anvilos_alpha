{
  "module_name": "meson-gx-pwrc-vpu.c",
  "hash_id": "7832486998975955d9b9377be9df009dcc783d87390093bc751197d16bde8a62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/amlogic/meson-gx-pwrc-vpu.c",
  "human_readable_source": " \n\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/bitfield.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/reset.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n\n \n\n#define AO_RTI_GEN_PWR_SLEEP0\t\t(0x3a << 2)\n\n#define GEN_PWR_VPU_HDMI\t\tBIT(8)\n#define GEN_PWR_VPU_HDMI_ISO\t\tBIT(9)\n\n \n\n#define HHI_MEM_PD_REG0\t\t\t(0x40 << 2)\n#define HHI_VPU_MEM_PD_REG0\t\t(0x41 << 2)\n#define HHI_VPU_MEM_PD_REG1\t\t(0x42 << 2)\n#define HHI_VPU_MEM_PD_REG2\t\t(0x4d << 2)\n\nstruct meson_gx_pwrc_vpu {\n\tstruct generic_pm_domain genpd;\n\tstruct regmap *regmap_ao;\n\tstruct regmap *regmap_hhi;\n\tstruct reset_control *rstc;\n\tstruct clk *vpu_clk;\n\tstruct clk *vapb_clk;\n};\n\nstatic inline\nstruct meson_gx_pwrc_vpu *genpd_to_pd(struct generic_pm_domain *d)\n{\n\treturn container_of(d, struct meson_gx_pwrc_vpu, genpd);\n}\n\nstatic int meson_gx_pwrc_vpu_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct meson_gx_pwrc_vpu *pd = genpd_to_pd(genpd);\n\tint i;\n\n\tregmap_update_bits(pd->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t   GEN_PWR_VPU_HDMI_ISO, GEN_PWR_VPU_HDMI_ISO);\n\tudelay(20);\n\n\t \n\tfor (i = 0; i < 32; i += 2) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_VPU_MEM_PD_REG0,\n\t\t\t\t   0x3 << i, 0x3 << i);\n\t\tudelay(5);\n\t}\n\tfor (i = 0; i < 32; i += 2) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_VPU_MEM_PD_REG1,\n\t\t\t\t   0x3 << i, 0x3 << i);\n\t\tudelay(5);\n\t}\n\tfor (i = 8; i < 16; i++) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_MEM_PD_REG0,\n\t\t\t\t   BIT(i), BIT(i));\n\t\tudelay(5);\n\t}\n\tudelay(20);\n\n\tregmap_update_bits(pd->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t   GEN_PWR_VPU_HDMI, GEN_PWR_VPU_HDMI);\n\n\tmsleep(20);\n\n\tclk_disable_unprepare(pd->vpu_clk);\n\tclk_disable_unprepare(pd->vapb_clk);\n\n\treturn 0;\n}\n\nstatic int meson_g12a_pwrc_vpu_power_off(struct generic_pm_domain *genpd)\n{\n\tstruct meson_gx_pwrc_vpu *pd = genpd_to_pd(genpd);\n\tint i;\n\n\tregmap_update_bits(pd->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t   GEN_PWR_VPU_HDMI_ISO, GEN_PWR_VPU_HDMI_ISO);\n\tudelay(20);\n\n\t \n\tfor (i = 0; i < 32; i += 2) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_VPU_MEM_PD_REG0,\n\t\t\t\t   0x3 << i, 0x3 << i);\n\t\tudelay(5);\n\t}\n\tfor (i = 0; i < 32; i += 2) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_VPU_MEM_PD_REG1,\n\t\t\t\t   0x3 << i, 0x3 << i);\n\t\tudelay(5);\n\t}\n\tfor (i = 0; i < 32; i += 2) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_VPU_MEM_PD_REG2,\n\t\t\t\t   0x3 << i, 0x3 << i);\n\t\tudelay(5);\n\t}\n\tfor (i = 8; i < 16; i++) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_MEM_PD_REG0,\n\t\t\t\t   BIT(i), BIT(i));\n\t\tudelay(5);\n\t}\n\tudelay(20);\n\n\tregmap_update_bits(pd->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t   GEN_PWR_VPU_HDMI, GEN_PWR_VPU_HDMI);\n\n\tmsleep(20);\n\n\tclk_disable_unprepare(pd->vpu_clk);\n\tclk_disable_unprepare(pd->vapb_clk);\n\n\treturn 0;\n}\n\nstatic int meson_gx_pwrc_vpu_setup_clk(struct meson_gx_pwrc_vpu *pd)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(pd->vpu_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(pd->vapb_clk);\n\tif (ret)\n\t\tclk_disable_unprepare(pd->vpu_clk);\n\n\treturn ret;\n}\n\nstatic int meson_gx_pwrc_vpu_power_on(struct generic_pm_domain *genpd)\n{\n\tstruct meson_gx_pwrc_vpu *pd = genpd_to_pd(genpd);\n\tint ret;\n\tint i;\n\n\tregmap_update_bits(pd->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t   GEN_PWR_VPU_HDMI, 0);\n\tudelay(20);\n\n\t \n\tfor (i = 0; i < 32; i += 2) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_VPU_MEM_PD_REG0,\n\t\t\t\t   0x3 << i, 0);\n\t\tudelay(5);\n\t}\n\n\tfor (i = 0; i < 32; i += 2) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_VPU_MEM_PD_REG1,\n\t\t\t\t   0x3 << i, 0);\n\t\tudelay(5);\n\t}\n\n\tfor (i = 8; i < 16; i++) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_MEM_PD_REG0,\n\t\t\t\t   BIT(i), 0);\n\t\tudelay(5);\n\t}\n\tudelay(20);\n\n\tret = reset_control_assert(pd->rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(pd->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t   GEN_PWR_VPU_HDMI_ISO, 0);\n\n\tret = reset_control_deassert(pd->rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = meson_gx_pwrc_vpu_setup_clk(pd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int meson_g12a_pwrc_vpu_power_on(struct generic_pm_domain *genpd)\n{\n\tstruct meson_gx_pwrc_vpu *pd = genpd_to_pd(genpd);\n\tint ret;\n\tint i;\n\n\tregmap_update_bits(pd->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t   GEN_PWR_VPU_HDMI, 0);\n\tudelay(20);\n\n\t \n\tfor (i = 0; i < 32; i += 2) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_VPU_MEM_PD_REG0,\n\t\t\t\t   0x3 << i, 0);\n\t\tudelay(5);\n\t}\n\n\tfor (i = 0; i < 32; i += 2) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_VPU_MEM_PD_REG1,\n\t\t\t\t   0x3 << i, 0);\n\t\tudelay(5);\n\t}\n\n\tfor (i = 0; i < 32; i += 2) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_VPU_MEM_PD_REG2,\n\t\t\t\t   0x3 << i, 0);\n\t\tudelay(5);\n\t}\n\n\tfor (i = 8; i < 16; i++) {\n\t\tregmap_update_bits(pd->regmap_hhi, HHI_MEM_PD_REG0,\n\t\t\t\t   BIT(i), 0);\n\t\tudelay(5);\n\t}\n\tudelay(20);\n\n\tret = reset_control_assert(pd->rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(pd->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t   GEN_PWR_VPU_HDMI_ISO, 0);\n\n\tret = reset_control_deassert(pd->rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = meson_gx_pwrc_vpu_setup_clk(pd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic bool meson_gx_pwrc_vpu_get_power(struct meson_gx_pwrc_vpu *pd)\n{\n\tu32 reg;\n\n\tregmap_read(pd->regmap_ao, AO_RTI_GEN_PWR_SLEEP0, &reg);\n\n\treturn (reg & GEN_PWR_VPU_HDMI);\n}\n\nstatic struct meson_gx_pwrc_vpu vpu_hdmi_pd = {\n\t.genpd = {\n\t\t.name = \"vpu_hdmi\",\n\t\t.power_off = meson_gx_pwrc_vpu_power_off,\n\t\t.power_on = meson_gx_pwrc_vpu_power_on,\n\t},\n};\n\nstatic struct meson_gx_pwrc_vpu vpu_hdmi_pd_g12a = {\n\t.genpd = {\n\t\t.name = \"vpu_hdmi\",\n\t\t.power_off = meson_g12a_pwrc_vpu_power_off,\n\t\t.power_on = meson_g12a_pwrc_vpu_power_on,\n\t},\n};\n\nstatic int meson_gx_pwrc_vpu_probe(struct platform_device *pdev)\n{\n\tconst struct meson_gx_pwrc_vpu *vpu_pd_match;\n\tstruct regmap *regmap_ao, *regmap_hhi;\n\tstruct meson_gx_pwrc_vpu *vpu_pd;\n\tstruct device_node *parent_np;\n\tstruct reset_control *rstc;\n\tstruct clk *vpu_clk;\n\tstruct clk *vapb_clk;\n\tbool powered_off;\n\tint ret;\n\n\tvpu_pd_match = of_device_get_match_data(&pdev->dev);\n\tif (!vpu_pd_match) {\n\t\tdev_err(&pdev->dev, \"failed to get match data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tvpu_pd = devm_kzalloc(&pdev->dev, sizeof(*vpu_pd), GFP_KERNEL);\n\tif (!vpu_pd)\n\t\treturn -ENOMEM;\n\n\tmemcpy(vpu_pd, vpu_pd_match, sizeof(*vpu_pd));\n\n\tparent_np = of_get_parent(pdev->dev.of_node);\n\tregmap_ao = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap_ao)) {\n\t\tdev_err(&pdev->dev, \"failed to get regmap\\n\");\n\t\treturn PTR_ERR(regmap_ao);\n\t}\n\n\tregmap_hhi = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t     \"amlogic,hhi-sysctrl\");\n\tif (IS_ERR(regmap_hhi)) {\n\t\tdev_err(&pdev->dev, \"failed to get HHI regmap\\n\");\n\t\treturn PTR_ERR(regmap_hhi);\n\t}\n\n\trstc = devm_reset_control_array_get_exclusive(&pdev->dev);\n\tif (IS_ERR(rstc))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(rstc),\n\t\t\t\t     \"failed to get reset lines\\n\");\n\n\tvpu_clk = devm_clk_get(&pdev->dev, \"vpu\");\n\tif (IS_ERR(vpu_clk)) {\n\t\tdev_err(&pdev->dev, \"vpu clock request failed\\n\");\n\t\treturn PTR_ERR(vpu_clk);\n\t}\n\n\tvapb_clk = devm_clk_get(&pdev->dev, \"vapb\");\n\tif (IS_ERR(vapb_clk)) {\n\t\tdev_err(&pdev->dev, \"vapb clock request failed\\n\");\n\t\treturn PTR_ERR(vapb_clk);\n\t}\n\n\tvpu_pd->regmap_ao = regmap_ao;\n\tvpu_pd->regmap_hhi = regmap_hhi;\n\tvpu_pd->rstc = rstc;\n\tvpu_pd->vpu_clk = vpu_clk;\n\tvpu_pd->vapb_clk = vapb_clk;\n\n\tplatform_set_drvdata(pdev, vpu_pd);\n\n\tpowered_off = meson_gx_pwrc_vpu_get_power(vpu_pd);\n\n\t \n\tif (!powered_off) {\n\t\tret = meson_gx_pwrc_vpu_setup_clk(vpu_pd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tvpu_pd->genpd.flags = GENPD_FLAG_ALWAYS_ON;\n\tpm_genpd_init(&vpu_pd->genpd, NULL, powered_off);\n\n\treturn of_genpd_add_provider_simple(pdev->dev.of_node,\n\t\t\t\t\t    &vpu_pd->genpd);\n}\n\nstatic void meson_gx_pwrc_vpu_shutdown(struct platform_device *pdev)\n{\n\tstruct meson_gx_pwrc_vpu *vpu_pd = platform_get_drvdata(pdev);\n\tbool powered_off;\n\n\tpowered_off = meson_gx_pwrc_vpu_get_power(vpu_pd);\n\tif (!powered_off)\n\t\tvpu_pd->genpd.power_off(&vpu_pd->genpd);\n}\n\nstatic const struct of_device_id meson_gx_pwrc_vpu_match_table[] = {\n\t{ .compatible = \"amlogic,meson-gx-pwrc-vpu\", .data = &vpu_hdmi_pd },\n\t{\n\t  .compatible = \"amlogic,meson-g12a-pwrc-vpu\",\n\t  .data = &vpu_hdmi_pd_g12a\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, meson_gx_pwrc_vpu_match_table);\n\nstatic struct platform_driver meson_gx_pwrc_vpu_driver = {\n\t.probe\t= meson_gx_pwrc_vpu_probe,\n\t.shutdown = meson_gx_pwrc_vpu_shutdown,\n\t.driver = {\n\t\t.name\t\t= \"meson_gx_pwrc_vpu\",\n\t\t.of_match_table\t= meson_gx_pwrc_vpu_match_table,\n\t},\n};\nmodule_platform_driver(meson_gx_pwrc_vpu_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}