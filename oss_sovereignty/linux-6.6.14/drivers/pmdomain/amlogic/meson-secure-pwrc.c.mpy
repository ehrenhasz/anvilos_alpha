{
  "module_name": "meson-secure-pwrc.c",
  "hash_id": "4c70bc2895412adb35eb8ca2c7528785eb96907d4069a76a54e8df225a6694ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/amlogic/meson-secure-pwrc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <dt-bindings/power/meson-a1-power.h>\n#include <dt-bindings/power/amlogic,c3-pwrc.h>\n#include <dt-bindings/power/meson-s4-power.h>\n#include <linux/arm-smccc.h>\n#include <linux/firmware/meson/meson_sm.h>\n#include <linux/module.h>\n\n#define PWRC_ON\t\t1\n#define PWRC_OFF\t0\n\nstruct meson_secure_pwrc_domain {\n\tstruct generic_pm_domain base;\n\tunsigned int index;\n\tstruct meson_secure_pwrc *pwrc;\n};\n\nstruct meson_secure_pwrc {\n\tstruct meson_secure_pwrc_domain *domains;\n\tstruct genpd_onecell_data xlate;\n\tstruct meson_sm_firmware *fw;\n};\n\nstruct meson_secure_pwrc_domain_desc {\n\tunsigned int index;\n\tunsigned int flags;\n\tchar *name;\n\tbool (*is_off)(struct meson_secure_pwrc_domain *pwrc_domain);\n};\n\nstruct meson_secure_pwrc_domain_data {\n\tunsigned int count;\n\tstruct meson_secure_pwrc_domain_desc *domains;\n};\n\nstatic bool pwrc_secure_is_off(struct meson_secure_pwrc_domain *pwrc_domain)\n{\n\tint is_off = 1;\n\n\tif (meson_sm_call(pwrc_domain->pwrc->fw, SM_A1_PWRC_GET, &is_off,\n\t\t\t  pwrc_domain->index, 0, 0, 0, 0) < 0)\n\t\tpr_err(\"failed to get power domain status\\n\");\n\n\treturn is_off;\n}\n\nstatic int meson_secure_pwrc_off(struct generic_pm_domain *domain)\n{\n\tint ret = 0;\n\tstruct meson_secure_pwrc_domain *pwrc_domain =\n\t\tcontainer_of(domain, struct meson_secure_pwrc_domain, base);\n\n\tif (meson_sm_call(pwrc_domain->pwrc->fw, SM_A1_PWRC_SET, NULL,\n\t\t\t  pwrc_domain->index, PWRC_OFF, 0, 0, 0) < 0) {\n\t\tpr_err(\"failed to set power domain off\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int meson_secure_pwrc_on(struct generic_pm_domain *domain)\n{\n\tint ret = 0;\n\tstruct meson_secure_pwrc_domain *pwrc_domain =\n\t\tcontainer_of(domain, struct meson_secure_pwrc_domain, base);\n\n\tif (meson_sm_call(pwrc_domain->pwrc->fw, SM_A1_PWRC_SET, NULL,\n\t\t\t  pwrc_domain->index, PWRC_ON, 0, 0, 0) < 0) {\n\t\tpr_err(\"failed to set power domain on\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n#define SEC_PD(__name, __flag)\t\t\t\\\n[PWRC_##__name##_ID] =\t\t\t\t\\\n{\t\t\t\t\t\t\\\n\t.name = #__name,\t\t\t\\\n\t.index = PWRC_##__name##_ID,\t\t\\\n\t.is_off = pwrc_secure_is_off,\t\\\n\t.flags = __flag,\t\t\t\\\n}\n\nstatic struct meson_secure_pwrc_domain_desc a1_pwrc_domains[] = {\n\tSEC_PD(DSPA,\t0),\n\tSEC_PD(DSPB,\t0),\n\t \n\tSEC_PD(UART,\tGENPD_FLAG_ALWAYS_ON),\n\t \n\tSEC_PD(DMC,\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(I2C,\t0),\n\tSEC_PD(PSRAM,\t0),\n\tSEC_PD(ACODEC,\t0),\n\tSEC_PD(AUDIO,\t0),\n\tSEC_PD(OTP,\t0),\n\tSEC_PD(DMA,\tGENPD_FLAG_ALWAYS_ON | GENPD_FLAG_IRQ_SAFE),\n\tSEC_PD(SD_EMMC,\t0),\n\tSEC_PD(RAMA,\t0),\n\t \n\tSEC_PD(RAMB,\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(IR,\t0),\n\tSEC_PD(SPICC,\t0),\n\tSEC_PD(SPIFC,\t0),\n\tSEC_PD(USB,\t0),\n\t \n\tSEC_PD(NIC,\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(PDMIN,\t0),\n\tSEC_PD(RSA,\t0),\n};\n\nstatic struct meson_secure_pwrc_domain_desc c3_pwrc_domains[] = {\n\tSEC_PD(C3_NNA,\t0),\n\tSEC_PD(C3_AUDIO,\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(C3_SDIOA,\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(C3_EMMC,\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(C3_USB_COMB, GENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(C3_SDCARD,\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(C3_ETH,\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(C3_GE2D,\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(C3_CVE,\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(C3_GDC_WRAP,\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(C3_ISP_TOP,\t\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(C3_MIPI_ISP_WRAP, GENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(C3_VCODEC,\t0),\n};\n\nstatic struct meson_secure_pwrc_domain_desc s4_pwrc_domains[] = {\n\tSEC_PD(S4_DOS_HEVC,\t0),\n\tSEC_PD(S4_DOS_VDEC,\t0),\n\tSEC_PD(S4_VPU_HDMI,\t0),\n\tSEC_PD(S4_USB_COMB,\t0),\n\tSEC_PD(S4_GE2D,\t\t0),\n\t \n\tSEC_PD(S4_ETH,\t\tGENPD_FLAG_ALWAYS_ON),\n\tSEC_PD(S4_DEMOD,\t0),\n\tSEC_PD(S4_AUDIO,\t0),\n};\n\nstatic int meson_secure_pwrc_probe(struct platform_device *pdev)\n{\n\tint i;\n\tstruct device_node *sm_np;\n\tstruct meson_secure_pwrc *pwrc;\n\tconst struct meson_secure_pwrc_domain_data *match;\n\n\tmatch = of_device_get_match_data(&pdev->dev);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"failed to get match data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsm_np = of_find_compatible_node(NULL, NULL, \"amlogic,meson-gxbb-sm\");\n\tif (!sm_np) {\n\t\tdev_err(&pdev->dev, \"no secure-monitor node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpwrc = devm_kzalloc(&pdev->dev, sizeof(*pwrc), GFP_KERNEL);\n\tif (!pwrc) {\n\t\tof_node_put(sm_np);\n\t\treturn -ENOMEM;\n\t}\n\n\tpwrc->fw = meson_sm_get(sm_np);\n\tof_node_put(sm_np);\n\tif (!pwrc->fw)\n\t\treturn -EPROBE_DEFER;\n\n\tpwrc->xlate.domains = devm_kcalloc(&pdev->dev, match->count,\n\t\t\t\t\t   sizeof(*pwrc->xlate.domains),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!pwrc->xlate.domains)\n\t\treturn -ENOMEM;\n\n\tpwrc->domains = devm_kcalloc(&pdev->dev, match->count,\n\t\t\t\t     sizeof(*pwrc->domains), GFP_KERNEL);\n\tif (!pwrc->domains)\n\t\treturn -ENOMEM;\n\n\tpwrc->xlate.num_domains = match->count;\n\tplatform_set_drvdata(pdev, pwrc);\n\n\tfor (i = 0 ; i < match->count ; ++i) {\n\t\tstruct meson_secure_pwrc_domain *dom = &pwrc->domains[i];\n\n\t\tif (!match->domains[i].name)\n\t\t\tcontinue;\n\n\t\tdom->pwrc = pwrc;\n\t\tdom->index = match->domains[i].index;\n\t\tdom->base.name = match->domains[i].name;\n\t\tdom->base.flags = match->domains[i].flags;\n\t\tdom->base.power_on = meson_secure_pwrc_on;\n\t\tdom->base.power_off = meson_secure_pwrc_off;\n\n\t\tpm_genpd_init(&dom->base, NULL, match->domains[i].is_off(dom));\n\n\t\tpwrc->xlate.domains[i] = &dom->base;\n\t}\n\n\treturn of_genpd_add_provider_onecell(pdev->dev.of_node, &pwrc->xlate);\n}\n\nstatic struct meson_secure_pwrc_domain_data meson_secure_a1_pwrc_data = {\n\t.domains = a1_pwrc_domains,\n\t.count = ARRAY_SIZE(a1_pwrc_domains),\n};\n\nstatic struct meson_secure_pwrc_domain_data amlogic_secure_c3_pwrc_data = {\n\t.domains = c3_pwrc_domains,\n\t.count = ARRAY_SIZE(c3_pwrc_domains),\n};\n\nstatic struct meson_secure_pwrc_domain_data meson_secure_s4_pwrc_data = {\n\t.domains = s4_pwrc_domains,\n\t.count = ARRAY_SIZE(s4_pwrc_domains),\n};\n\nstatic const struct of_device_id meson_secure_pwrc_match_table[] = {\n\t{\n\t\t.compatible = \"amlogic,meson-a1-pwrc\",\n\t\t.data = &meson_secure_a1_pwrc_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,c3-pwrc\",\n\t\t.data = &amlogic_secure_c3_pwrc_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-s4-pwrc\",\n\t\t.data = &meson_secure_s4_pwrc_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, meson_secure_pwrc_match_table);\n\nstatic struct platform_driver meson_secure_pwrc_driver = {\n\t.probe = meson_secure_pwrc_probe,\n\t.driver = {\n\t\t.name\t\t= \"meson_secure_pwrc\",\n\t\t.of_match_table\t= meson_secure_pwrc_match_table,\n\t},\n};\nmodule_platform_driver(meson_secure_pwrc_driver);\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}