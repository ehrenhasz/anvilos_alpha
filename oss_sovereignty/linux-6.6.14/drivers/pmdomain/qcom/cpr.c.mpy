{
  "module_name": "cpr.c",
  "hash_id": "80b4878a96fc0b747ed474da5d1b68974b39212b5d1b993417f9f9dbbe40b079",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/qcom/cpr.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/debugfs.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_opp.h>\n#include <linux/interrupt.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regulator/consumer.h>\n#include <linux/clk.h>\n#include <linux/nvmem-consumer.h>\n\n \n\n \n#define REG_RBCPR_VERSION\t\t0\n#define RBCPR_VER_2\t\t\t0x02\n#define FLAGS_IGNORE_1ST_IRQ_STATUS\tBIT(0)\n\n \n#define REG_RBCPR_GCNT_TARGET(n)\t(0x60 + 4 * (n))\n\n#define RBCPR_GCNT_TARGET_TARGET_SHIFT\t0\n#define RBCPR_GCNT_TARGET_TARGET_MASK\tGENMASK(11, 0)\n#define RBCPR_GCNT_TARGET_GCNT_SHIFT\t12\n#define RBCPR_GCNT_TARGET_GCNT_MASK\tGENMASK(9, 0)\n\n \n#define REG_RBCPR_TIMER_INTERVAL\t0x44\n#define REG_RBIF_TIMER_ADJUST\t\t0x4c\n\n#define RBIF_TIMER_ADJ_CONS_UP_MASK\tGENMASK(3, 0)\n#define RBIF_TIMER_ADJ_CONS_UP_SHIFT\t0\n#define RBIF_TIMER_ADJ_CONS_DOWN_MASK\tGENMASK(3, 0)\n#define RBIF_TIMER_ADJ_CONS_DOWN_SHIFT\t4\n#define RBIF_TIMER_ADJ_CLAMP_INT_MASK\tGENMASK(7, 0)\n#define RBIF_TIMER_ADJ_CLAMP_INT_SHIFT\t8\n\n \n#define REG_RBIF_LIMIT\t\t\t0x48\n#define RBIF_LIMIT_CEILING_MASK\t\tGENMASK(5, 0)\n#define RBIF_LIMIT_CEILING_SHIFT\t6\n#define RBIF_LIMIT_FLOOR_BITS\t\t6\n#define RBIF_LIMIT_FLOOR_MASK\t\tGENMASK(5, 0)\n\n#define RBIF_LIMIT_CEILING_DEFAULT\tRBIF_LIMIT_CEILING_MASK\n#define RBIF_LIMIT_FLOOR_DEFAULT\t0\n\n#define REG_RBIF_SW_VLEVEL\t\t0x94\n#define RBIF_SW_VLEVEL_DEFAULT\t\t0x20\n\n#define REG_RBCPR_STEP_QUOT\t\t0x80\n#define RBCPR_STEP_QUOT_STEPQUOT_MASK\tGENMASK(7, 0)\n#define RBCPR_STEP_QUOT_IDLE_CLK_MASK\tGENMASK(3, 0)\n#define RBCPR_STEP_QUOT_IDLE_CLK_SHIFT\t8\n\n \n#define REG_RBCPR_CTL\t\t\t0x90\n\n#define RBCPR_CTL_LOOP_EN\t\t\tBIT(0)\n#define RBCPR_CTL_TIMER_EN\t\t\tBIT(3)\n#define RBCPR_CTL_SW_AUTO_CONT_ACK_EN\t\tBIT(5)\n#define RBCPR_CTL_SW_AUTO_CONT_NACK_DN_EN\tBIT(6)\n#define RBCPR_CTL_COUNT_MODE\t\t\tBIT(10)\n#define RBCPR_CTL_UP_THRESHOLD_MASK\tGENMASK(3, 0)\n#define RBCPR_CTL_UP_THRESHOLD_SHIFT\t24\n#define RBCPR_CTL_DN_THRESHOLD_MASK\tGENMASK(3, 0)\n#define RBCPR_CTL_DN_THRESHOLD_SHIFT\t28\n\n \n#define REG_RBIF_CONT_ACK_CMD\t\t0x98\n#define REG_RBIF_CONT_NACK_CMD\t\t0x9c\n\n \n#define REG_RBCPR_RESULT_0\t\t0xa0\n\n#define RBCPR_RESULT0_BUSY_SHIFT\t19\n#define RBCPR_RESULT0_BUSY_MASK\t\tBIT(RBCPR_RESULT0_BUSY_SHIFT)\n#define RBCPR_RESULT0_ERROR_LT0_SHIFT\t18\n#define RBCPR_RESULT0_ERROR_SHIFT\t6\n#define RBCPR_RESULT0_ERROR_MASK\tGENMASK(11, 0)\n#define RBCPR_RESULT0_ERROR_STEPS_SHIFT\t2\n#define RBCPR_RESULT0_ERROR_STEPS_MASK\tGENMASK(3, 0)\n#define RBCPR_RESULT0_STEP_UP_SHIFT\t1\n\n \n#define REG_RBIF_IRQ_EN(n)\t\t(0x100 + 4 * (n))\n#define REG_RBIF_IRQ_CLEAR\t\t0x110\n#define REG_RBIF_IRQ_STATUS\t\t0x114\n\n#define CPR_INT_DONE\t\tBIT(0)\n#define CPR_INT_MIN\t\tBIT(1)\n#define CPR_INT_DOWN\t\tBIT(2)\n#define CPR_INT_MID\t\tBIT(3)\n#define CPR_INT_UP\t\tBIT(4)\n#define CPR_INT_MAX\t\tBIT(5)\n#define CPR_INT_CLAMP\t\tBIT(6)\n#define CPR_INT_ALL\t(CPR_INT_DONE | CPR_INT_MIN | CPR_INT_DOWN | \\\n\t\t\tCPR_INT_MID | CPR_INT_UP | CPR_INT_MAX | CPR_INT_CLAMP)\n#define CPR_INT_DEFAULT\t(CPR_INT_UP | CPR_INT_DOWN)\n\n#define CPR_NUM_RING_OSC\t8\n\n \n#define CPR_FUSE_TARGET_QUOT_BITS_MASK\tGENMASK(11, 0)\n\n#define CPR_FUSE_MIN_QUOT_DIFF\t\t50\n\n#define FUSE_REVISION_UNKNOWN\t\t(-1)\n\nenum voltage_change_dir {\n\tNO_CHANGE,\n\tDOWN,\n\tUP,\n};\n\nstruct cpr_fuse {\n\tchar *ring_osc;\n\tchar *init_voltage;\n\tchar *quotient;\n\tchar *quotient_offset;\n};\n\nstruct fuse_corner_data {\n\tint ref_uV;\n\tint max_uV;\n\tint min_uV;\n\tint max_volt_scale;\n\tint max_quot_scale;\n\t \n\tint quot_offset;\n\tint quot_scale;\n\tint quot_adjust;\n\t \n\tint quot_offset_scale;\n\tint quot_offset_adjust;\n};\n\nstruct cpr_fuses {\n\tint init_voltage_step;\n\tint init_voltage_width;\n\tstruct fuse_corner_data *fuse_corner_data;\n};\n\nstruct corner_data {\n\tunsigned int fuse_corner;\n\tunsigned long freq;\n};\n\nstruct cpr_desc {\n\tunsigned int num_fuse_corners;\n\tint min_diff_quot;\n\tint *step_quot;\n\n\tunsigned int\t\ttimer_delay_us;\n\tunsigned int\t\ttimer_cons_up;\n\tunsigned int\t\ttimer_cons_down;\n\tunsigned int\t\tup_threshold;\n\tunsigned int\t\tdown_threshold;\n\tunsigned int\t\tidle_clocks;\n\tunsigned int\t\tgcnt_us;\n\tunsigned int\t\tvdd_apc_step_up_limit;\n\tunsigned int\t\tvdd_apc_step_down_limit;\n\tunsigned int\t\tclamp_timer_interval;\n\n\tstruct cpr_fuses cpr_fuses;\n\tbool reduce_to_fuse_uV;\n\tbool reduce_to_corner_uV;\n};\n\nstruct acc_desc {\n\tunsigned int\tenable_reg;\n\tu32\t\tenable_mask;\n\n\tstruct reg_sequence\t*config;\n\tstruct reg_sequence\t*settings;\n\tint\t\t\tnum_regs_per_fuse;\n};\n\nstruct cpr_acc_desc {\n\tconst struct cpr_desc *cpr_desc;\n\tconst struct acc_desc *acc_desc;\n};\n\nstruct fuse_corner {\n\tint min_uV;\n\tint max_uV;\n\tint uV;\n\tint quot;\n\tint step_quot;\n\tconst struct reg_sequence *accs;\n\tint num_accs;\n\tunsigned long max_freq;\n\tu8 ring_osc_idx;\n};\n\nstruct corner {\n\tint min_uV;\n\tint max_uV;\n\tint uV;\n\tint last_uV;\n\tint quot_adjust;\n\tu32 save_ctl;\n\tu32 save_irq;\n\tunsigned long freq;\n\tstruct fuse_corner *fuse_corner;\n};\n\nstruct cpr_drv {\n\tunsigned int\t\tnum_corners;\n\tunsigned int\t\tref_clk_khz;\n\n\tstruct generic_pm_domain pd;\n\tstruct device\t\t*dev;\n\tstruct device\t\t*attached_cpu_dev;\n\tstruct mutex\t\tlock;\n\tvoid __iomem\t\t*base;\n\tstruct corner\t\t*corner;\n\tstruct regulator\t*vdd_apc;\n\tstruct clk\t\t*cpu_clk;\n\tstruct regmap\t\t*tcsr;\n\tbool\t\t\tloop_disabled;\n\tu32\t\t\tgcnt;\n\tunsigned long\t\tflags;\n\n\tstruct fuse_corner\t*fuse_corners;\n\tstruct corner\t\t*corners;\n\n\tconst struct cpr_desc *desc;\n\tconst struct acc_desc *acc_desc;\n\tconst struct cpr_fuse *cpr_fuses;\n\n\tstruct dentry *debugfs;\n};\n\nstatic bool cpr_is_allowed(struct cpr_drv *drv)\n{\n\treturn !drv->loop_disabled;\n}\n\nstatic void cpr_write(struct cpr_drv *drv, u32 offset, u32 value)\n{\n\twritel_relaxed(value, drv->base + offset);\n}\n\nstatic u32 cpr_read(struct cpr_drv *drv, u32 offset)\n{\n\treturn readl_relaxed(drv->base + offset);\n}\n\nstatic void\ncpr_masked_write(struct cpr_drv *drv, u32 offset, u32 mask, u32 value)\n{\n\tu32 val;\n\n\tval = readl_relaxed(drv->base + offset);\n\tval &= ~mask;\n\tval |= value & mask;\n\twritel_relaxed(val, drv->base + offset);\n}\n\nstatic void cpr_irq_clr(struct cpr_drv *drv)\n{\n\tcpr_write(drv, REG_RBIF_IRQ_CLEAR, CPR_INT_ALL);\n}\n\nstatic void cpr_irq_clr_nack(struct cpr_drv *drv)\n{\n\tcpr_irq_clr(drv);\n\tcpr_write(drv, REG_RBIF_CONT_NACK_CMD, 1);\n}\n\nstatic void cpr_irq_clr_ack(struct cpr_drv *drv)\n{\n\tcpr_irq_clr(drv);\n\tcpr_write(drv, REG_RBIF_CONT_ACK_CMD, 1);\n}\n\nstatic void cpr_irq_set(struct cpr_drv *drv, u32 int_bits)\n{\n\tcpr_write(drv, REG_RBIF_IRQ_EN(0), int_bits);\n}\n\nstatic void cpr_ctl_modify(struct cpr_drv *drv, u32 mask, u32 value)\n{\n\tcpr_masked_write(drv, REG_RBCPR_CTL, mask, value);\n}\n\nstatic void cpr_ctl_enable(struct cpr_drv *drv, struct corner *corner)\n{\n\tu32 val, mask;\n\tconst struct cpr_desc *desc = drv->desc;\n\n\t \n\tval = desc->timer_cons_down << RBIF_TIMER_ADJ_CONS_DOWN_SHIFT;\n\tval |= desc->timer_cons_up << RBIF_TIMER_ADJ_CONS_UP_SHIFT;\n\tmask = RBIF_TIMER_ADJ_CONS_UP_MASK | RBIF_TIMER_ADJ_CONS_DOWN_MASK;\n\tcpr_masked_write(drv, REG_RBIF_TIMER_ADJUST, mask, val);\n\tcpr_masked_write(drv, REG_RBCPR_CTL,\n\t\t\t RBCPR_CTL_SW_AUTO_CONT_NACK_DN_EN |\n\t\t\t RBCPR_CTL_SW_AUTO_CONT_ACK_EN,\n\t\t\t corner->save_ctl);\n\tcpr_irq_set(drv, corner->save_irq);\n\n\tif (cpr_is_allowed(drv) && corner->max_uV > corner->min_uV)\n\t\tval = RBCPR_CTL_LOOP_EN;\n\telse\n\t\tval = 0;\n\tcpr_ctl_modify(drv, RBCPR_CTL_LOOP_EN, val);\n}\n\nstatic void cpr_ctl_disable(struct cpr_drv *drv)\n{\n\tcpr_irq_set(drv, 0);\n\tcpr_ctl_modify(drv, RBCPR_CTL_SW_AUTO_CONT_NACK_DN_EN |\n\t\t       RBCPR_CTL_SW_AUTO_CONT_ACK_EN, 0);\n\tcpr_masked_write(drv, REG_RBIF_TIMER_ADJUST,\n\t\t\t RBIF_TIMER_ADJ_CONS_UP_MASK |\n\t\t\t RBIF_TIMER_ADJ_CONS_DOWN_MASK, 0);\n\tcpr_irq_clr(drv);\n\tcpr_write(drv, REG_RBIF_CONT_ACK_CMD, 1);\n\tcpr_write(drv, REG_RBIF_CONT_NACK_CMD, 1);\n\tcpr_ctl_modify(drv, RBCPR_CTL_LOOP_EN, 0);\n}\n\nstatic bool cpr_ctl_is_enabled(struct cpr_drv *drv)\n{\n\tu32 reg_val;\n\n\treg_val = cpr_read(drv, REG_RBCPR_CTL);\n\treturn reg_val & RBCPR_CTL_LOOP_EN;\n}\n\nstatic bool cpr_ctl_is_busy(struct cpr_drv *drv)\n{\n\tu32 reg_val;\n\n\treg_val = cpr_read(drv, REG_RBCPR_RESULT_0);\n\treturn reg_val & RBCPR_RESULT0_BUSY_MASK;\n}\n\nstatic void cpr_corner_save(struct cpr_drv *drv, struct corner *corner)\n{\n\tcorner->save_ctl = cpr_read(drv, REG_RBCPR_CTL);\n\tcorner->save_irq = cpr_read(drv, REG_RBIF_IRQ_EN(0));\n}\n\nstatic void cpr_corner_restore(struct cpr_drv *drv, struct corner *corner)\n{\n\tu32 gcnt, ctl, irq, ro_sel, step_quot;\n\tstruct fuse_corner *fuse = corner->fuse_corner;\n\tconst struct cpr_desc *desc = drv->desc;\n\tint i;\n\n\tro_sel = fuse->ring_osc_idx;\n\tgcnt = drv->gcnt;\n\tgcnt |= fuse->quot - corner->quot_adjust;\n\n\t \n\tstep_quot = desc->idle_clocks << RBCPR_STEP_QUOT_IDLE_CLK_SHIFT;\n\tstep_quot |= fuse->step_quot & RBCPR_STEP_QUOT_STEPQUOT_MASK;\n\tcpr_write(drv, REG_RBCPR_STEP_QUOT, step_quot);\n\n\t \n\tfor (i = 0; i < CPR_NUM_RING_OSC; i++)\n\t\tcpr_write(drv, REG_RBCPR_GCNT_TARGET(i), 0);\n\n\tcpr_write(drv, REG_RBCPR_GCNT_TARGET(ro_sel), gcnt);\n\tctl = corner->save_ctl;\n\tcpr_write(drv, REG_RBCPR_CTL, ctl);\n\tirq = corner->save_irq;\n\tcpr_irq_set(drv, irq);\n\tdev_dbg(drv->dev, \"gcnt = %#08x, ctl = %#08x, irq = %#08x\\n\", gcnt,\n\t\tctl, irq);\n}\n\nstatic void cpr_set_acc(struct regmap *tcsr, struct fuse_corner *f,\n\t\t\tstruct fuse_corner *end)\n{\n\tif (f == end)\n\t\treturn;\n\n\tif (f < end) {\n\t\tfor (f += 1; f <= end; f++)\n\t\t\tregmap_multi_reg_write(tcsr, f->accs, f->num_accs);\n\t} else {\n\t\tfor (f -= 1; f >= end; f--)\n\t\t\tregmap_multi_reg_write(tcsr, f->accs, f->num_accs);\n\t}\n}\n\nstatic int cpr_pre_voltage(struct cpr_drv *drv,\n\t\t\t   struct fuse_corner *fuse_corner,\n\t\t\t   enum voltage_change_dir dir)\n{\n\tstruct fuse_corner *prev_fuse_corner = drv->corner->fuse_corner;\n\n\tif (drv->tcsr && dir == DOWN)\n\t\tcpr_set_acc(drv->tcsr, prev_fuse_corner, fuse_corner);\n\n\treturn 0;\n}\n\nstatic int cpr_post_voltage(struct cpr_drv *drv,\n\t\t\t    struct fuse_corner *fuse_corner,\n\t\t\t    enum voltage_change_dir dir)\n{\n\tstruct fuse_corner *prev_fuse_corner = drv->corner->fuse_corner;\n\n\tif (drv->tcsr && dir == UP)\n\t\tcpr_set_acc(drv->tcsr, prev_fuse_corner, fuse_corner);\n\n\treturn 0;\n}\n\nstatic int cpr_scale_voltage(struct cpr_drv *drv, struct corner *corner,\n\t\t\t     int new_uV, enum voltage_change_dir dir)\n{\n\tint ret;\n\tstruct fuse_corner *fuse_corner = corner->fuse_corner;\n\n\tret = cpr_pre_voltage(drv, fuse_corner, dir);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_set_voltage(drv->vdd_apc, new_uV, new_uV);\n\tif (ret) {\n\t\tdev_err_ratelimited(drv->dev, \"failed to set apc voltage %d\\n\",\n\t\t\t\t    new_uV);\n\t\treturn ret;\n\t}\n\n\tret = cpr_post_voltage(drv, fuse_corner, dir);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic unsigned int cpr_get_cur_perf_state(struct cpr_drv *drv)\n{\n\treturn drv->corner ? drv->corner - drv->corners + 1 : 0;\n}\n\nstatic int cpr_scale(struct cpr_drv *drv, enum voltage_change_dir dir)\n{\n\tu32 val, error_steps, reg_mask;\n\tint last_uV, new_uV, step_uV, ret;\n\tstruct corner *corner;\n\tconst struct cpr_desc *desc = drv->desc;\n\n\tif (dir != UP && dir != DOWN)\n\t\treturn 0;\n\n\tstep_uV = regulator_get_linear_step(drv->vdd_apc);\n\tif (!step_uV)\n\t\treturn -EINVAL;\n\n\tcorner = drv->corner;\n\n\tval = cpr_read(drv, REG_RBCPR_RESULT_0);\n\n\terror_steps = val >> RBCPR_RESULT0_ERROR_STEPS_SHIFT;\n\terror_steps &= RBCPR_RESULT0_ERROR_STEPS_MASK;\n\tlast_uV = corner->last_uV;\n\n\tif (dir == UP) {\n\t\tif (desc->clamp_timer_interval &&\n\t\t    error_steps < desc->up_threshold) {\n\t\t\t \n\t\t\terror_steps = max(desc->up_threshold,\n\t\t\t\t\t  desc->vdd_apc_step_up_limit);\n\t\t}\n\n\t\tif (last_uV >= corner->max_uV) {\n\t\t\tcpr_irq_clr_nack(drv);\n\n\t\t\t \n\t\t\treg_mask = RBCPR_CTL_UP_THRESHOLD_MASK;\n\t\t\treg_mask <<= RBCPR_CTL_UP_THRESHOLD_SHIFT;\n\t\t\tval = reg_mask;\n\t\t\tcpr_ctl_modify(drv, reg_mask, val);\n\n\t\t\t \n\t\t\tcpr_irq_set(drv, CPR_INT_DEFAULT & ~CPR_INT_UP);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (error_steps > desc->vdd_apc_step_up_limit)\n\t\t\terror_steps = desc->vdd_apc_step_up_limit;\n\n\t\t \n\t\tnew_uV = last_uV + error_steps * step_uV;\n\t\tnew_uV = min(new_uV, corner->max_uV);\n\n\t\tdev_dbg(drv->dev,\n\t\t\t\"UP: -> new_uV: %d last_uV: %d perf state: %u\\n\",\n\t\t\tnew_uV, last_uV, cpr_get_cur_perf_state(drv));\n\t} else {\n\t\tif (desc->clamp_timer_interval &&\n\t\t    error_steps < desc->down_threshold) {\n\t\t\t \n\t\t\terror_steps = max(desc->down_threshold,\n\t\t\t\t\t  desc->vdd_apc_step_down_limit);\n\t\t}\n\n\t\tif (last_uV <= corner->min_uV) {\n\t\t\tcpr_irq_clr_nack(drv);\n\n\t\t\t \n\t\t\treg_mask = RBCPR_CTL_SW_AUTO_CONT_NACK_DN_EN;\n\t\t\tval = RBCPR_CTL_SW_AUTO_CONT_NACK_DN_EN;\n\n\t\t\tcpr_ctl_modify(drv, reg_mask, val);\n\n\t\t\t \n\t\t\tcpr_irq_set(drv, CPR_INT_DEFAULT & ~CPR_INT_DOWN);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (error_steps > desc->vdd_apc_step_down_limit)\n\t\t\terror_steps = desc->vdd_apc_step_down_limit;\n\n\t\t \n\t\tnew_uV = last_uV - error_steps * step_uV;\n\t\tnew_uV = max(new_uV, corner->min_uV);\n\n\t\tdev_dbg(drv->dev,\n\t\t\t\"DOWN: -> new_uV: %d last_uV: %d perf state: %u\\n\",\n\t\t\tnew_uV, last_uV, cpr_get_cur_perf_state(drv));\n\t}\n\n\tret = cpr_scale_voltage(drv, corner, new_uV, dir);\n\tif (ret) {\n\t\tcpr_irq_clr_nack(drv);\n\t\treturn ret;\n\t}\n\tdrv->corner->last_uV = new_uV;\n\n\tif (dir == UP) {\n\t\t \n\t\treg_mask = RBCPR_CTL_SW_AUTO_CONT_NACK_DN_EN;\n\t\tval = 0;\n\t} else {\n\t\t \n\t\treg_mask = RBCPR_CTL_UP_THRESHOLD_MASK;\n\t\treg_mask <<= RBCPR_CTL_UP_THRESHOLD_SHIFT;\n\t\tval = desc->up_threshold;\n\t\tval <<= RBCPR_CTL_UP_THRESHOLD_SHIFT;\n\t}\n\n\tcpr_ctl_modify(drv, reg_mask, val);\n\n\t \n\tcpr_irq_set(drv, CPR_INT_DEFAULT);\n\n\t \n\tcpr_irq_clr_ack(drv);\n\n\treturn 0;\n}\n\nstatic irqreturn_t cpr_irq_handler(int irq, void *dev)\n{\n\tstruct cpr_drv *drv = dev;\n\tconst struct cpr_desc *desc = drv->desc;\n\tirqreturn_t ret = IRQ_HANDLED;\n\tu32 val;\n\n\tmutex_lock(&drv->lock);\n\n\tval = cpr_read(drv, REG_RBIF_IRQ_STATUS);\n\tif (drv->flags & FLAGS_IGNORE_1ST_IRQ_STATUS)\n\t\tval = cpr_read(drv, REG_RBIF_IRQ_STATUS);\n\n\tdev_dbg(drv->dev, \"IRQ_STATUS = %#02x\\n\", val);\n\n\tif (!cpr_ctl_is_enabled(drv)) {\n\t\tdev_dbg(drv->dev, \"CPR is disabled\\n\");\n\t\tret = IRQ_NONE;\n\t} else if (cpr_ctl_is_busy(drv) && !desc->clamp_timer_interval) {\n\t\tdev_dbg(drv->dev, \"CPR measurement is not ready\\n\");\n\t} else if (!cpr_is_allowed(drv)) {\n\t\tval = cpr_read(drv, REG_RBCPR_CTL);\n\t\tdev_err_ratelimited(drv->dev,\n\t\t\t\t    \"Interrupt broken? RBCPR_CTL = %#02x\\n\",\n\t\t\t\t    val);\n\t\tret = IRQ_NONE;\n\t} else {\n\t\t \n\t\tif (val & CPR_INT_UP) {\n\t\t\tcpr_scale(drv, UP);\n\t\t} else if (val & CPR_INT_DOWN) {\n\t\t\tcpr_scale(drv, DOWN);\n\t\t} else if (val & CPR_INT_MIN) {\n\t\t\tcpr_irq_clr_nack(drv);\n\t\t} else if (val & CPR_INT_MAX) {\n\t\t\tcpr_irq_clr_nack(drv);\n\t\t} else if (val & CPR_INT_MID) {\n\t\t\t \n\t\t\tdev_dbg(drv->dev, \"IRQ occurred for Mid Flag\\n\");\n\t\t} else {\n\t\t\tdev_dbg(drv->dev,\n\t\t\t\t\"IRQ occurred for unknown flag (%#08x)\\n\", val);\n\t\t}\n\n\t\t \n\t\tcpr_corner_save(drv, drv->corner);\n\t}\n\n\tmutex_unlock(&drv->lock);\n\n\treturn ret;\n}\n\nstatic int cpr_enable(struct cpr_drv *drv)\n{\n\tint ret;\n\n\tret = regulator_enable(drv->vdd_apc);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&drv->lock);\n\n\tif (cpr_is_allowed(drv) && drv->corner) {\n\t\tcpr_irq_clr(drv);\n\t\tcpr_corner_restore(drv, drv->corner);\n\t\tcpr_ctl_enable(drv, drv->corner);\n\t}\n\n\tmutex_unlock(&drv->lock);\n\n\treturn 0;\n}\n\nstatic int cpr_disable(struct cpr_drv *drv)\n{\n\tmutex_lock(&drv->lock);\n\n\tif (cpr_is_allowed(drv)) {\n\t\tcpr_ctl_disable(drv);\n\t\tcpr_irq_clr(drv);\n\t}\n\n\tmutex_unlock(&drv->lock);\n\n\treturn regulator_disable(drv->vdd_apc);\n}\n\nstatic int cpr_config(struct cpr_drv *drv)\n{\n\tint i;\n\tu32 val, gcnt;\n\tstruct corner *corner;\n\tconst struct cpr_desc *desc = drv->desc;\n\n\t \n\tcpr_write(drv, REG_RBIF_IRQ_EN(0), 0);\n\tcpr_write(drv, REG_RBCPR_CTL, 0);\n\n\t \n\tval = (RBIF_LIMIT_CEILING_DEFAULT & RBIF_LIMIT_CEILING_MASK)\n\t\t<< RBIF_LIMIT_CEILING_SHIFT;\n\tval |= RBIF_LIMIT_FLOOR_DEFAULT & RBIF_LIMIT_FLOOR_MASK;\n\tcpr_write(drv, REG_RBIF_LIMIT, val);\n\tcpr_write(drv, REG_RBIF_SW_VLEVEL, RBIF_SW_VLEVEL_DEFAULT);\n\n\t \n\tfor (i = 0; i < CPR_NUM_RING_OSC; i++)\n\t\tcpr_write(drv, REG_RBCPR_GCNT_TARGET(i), 0);\n\n\t \n\tgcnt = (drv->ref_clk_khz * desc->gcnt_us) / 1000;\n\tgcnt = gcnt & RBCPR_GCNT_TARGET_GCNT_MASK;\n\tgcnt <<= RBCPR_GCNT_TARGET_GCNT_SHIFT;\n\tdrv->gcnt = gcnt;\n\n\t \n\tval = (drv->ref_clk_khz * desc->timer_delay_us) / 1000;\n\tcpr_write(drv, REG_RBCPR_TIMER_INTERVAL, val);\n\tdev_dbg(drv->dev, \"Timer count: %#0x (for %d us)\\n\", val,\n\t\tdesc->timer_delay_us);\n\n\t \n\tval = desc->timer_cons_down << RBIF_TIMER_ADJ_CONS_DOWN_SHIFT;\n\tval |= desc->timer_cons_up << RBIF_TIMER_ADJ_CONS_UP_SHIFT;\n\tval |= desc->clamp_timer_interval << RBIF_TIMER_ADJ_CLAMP_INT_SHIFT;\n\tcpr_write(drv, REG_RBIF_TIMER_ADJUST, val);\n\n\t \n\tval = desc->up_threshold << RBCPR_CTL_UP_THRESHOLD_SHIFT;\n\tval |= desc->down_threshold << RBCPR_CTL_DN_THRESHOLD_SHIFT;\n\tval |= RBCPR_CTL_TIMER_EN | RBCPR_CTL_COUNT_MODE;\n\tval |= RBCPR_CTL_SW_AUTO_CONT_ACK_EN;\n\tcpr_write(drv, REG_RBCPR_CTL, val);\n\n\tfor (i = 0; i < drv->num_corners; i++) {\n\t\tcorner = &drv->corners[i];\n\t\tcorner->save_ctl = val;\n\t\tcorner->save_irq = CPR_INT_DEFAULT;\n\t}\n\n\tcpr_irq_set(drv, CPR_INT_DEFAULT);\n\n\tval = cpr_read(drv, REG_RBCPR_VERSION);\n\tif (val <= RBCPR_VER_2)\n\t\tdrv->flags |= FLAGS_IGNORE_1ST_IRQ_STATUS;\n\n\treturn 0;\n}\n\nstatic int cpr_set_performance_state(struct generic_pm_domain *domain,\n\t\t\t\t     unsigned int state)\n{\n\tstruct cpr_drv *drv = container_of(domain, struct cpr_drv, pd);\n\tstruct corner *corner, *end;\n\tenum voltage_change_dir dir;\n\tint ret = 0, new_uV;\n\n\tmutex_lock(&drv->lock);\n\n\tdev_dbg(drv->dev, \"%s: setting perf state: %u (prev state: %u)\\n\",\n\t\t__func__, state, cpr_get_cur_perf_state(drv));\n\n\t \n\tcorner = drv->corners + state - 1;\n\tend = &drv->corners[drv->num_corners - 1];\n\tif (corner > end || corner < drv->corners) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (drv->corner > corner)\n\t\tdir = DOWN;\n\telse if (drv->corner < corner)\n\t\tdir = UP;\n\telse\n\t\tdir = NO_CHANGE;\n\n\tif (cpr_is_allowed(drv))\n\t\tnew_uV = corner->last_uV;\n\telse\n\t\tnew_uV = corner->uV;\n\n\tif (cpr_is_allowed(drv))\n\t\tcpr_ctl_disable(drv);\n\n\tret = cpr_scale_voltage(drv, corner, new_uV, dir);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (cpr_is_allowed(drv)) {\n\t\tcpr_irq_clr(drv);\n\t\tif (drv->corner != corner)\n\t\t\tcpr_corner_restore(drv, corner);\n\t\tcpr_ctl_enable(drv, corner);\n\t}\n\n\tdrv->corner = corner;\n\nunlock:\n\tmutex_unlock(&drv->lock);\n\n\treturn ret;\n}\n\nstatic int\ncpr_populate_ring_osc_idx(struct cpr_drv *drv)\n{\n\tstruct fuse_corner *fuse = drv->fuse_corners;\n\tstruct fuse_corner *end = fuse + drv->desc->num_fuse_corners;\n\tconst struct cpr_fuse *fuses = drv->cpr_fuses;\n\tu32 data;\n\tint ret;\n\n\tfor (; fuse < end; fuse++, fuses++) {\n\t\tret = nvmem_cell_read_variable_le_u32(drv->dev, fuses->ring_osc, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tfuse->ring_osc_idx = data;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpr_read_fuse_uV(const struct cpr_desc *desc,\n\t\t\t    const struct fuse_corner_data *fdata,\n\t\t\t    const char *init_v_efuse,\n\t\t\t    int step_volt,\n\t\t\t    struct cpr_drv *drv)\n{\n\tint step_size_uV, steps, uV;\n\tu32 bits = 0;\n\tint ret;\n\n\tret = nvmem_cell_read_variable_le_u32(drv->dev, init_v_efuse, &bits);\n\tif (ret)\n\t\treturn ret;\n\n\tsteps = bits & ~BIT(desc->cpr_fuses.init_voltage_width - 1);\n\t \n\tif (bits & BIT(desc->cpr_fuses.init_voltage_width - 1))\n\t\tsteps = -steps;\n\n\tstep_size_uV = desc->cpr_fuses.init_voltage_step;\n\n\tuV = fdata->ref_uV + steps * step_size_uV;\n\treturn DIV_ROUND_UP(uV, step_volt) * step_volt;\n}\n\nstatic int cpr_fuse_corner_init(struct cpr_drv *drv)\n{\n\tconst struct cpr_desc *desc = drv->desc;\n\tconst struct cpr_fuse *fuses = drv->cpr_fuses;\n\tconst struct acc_desc *acc_desc = drv->acc_desc;\n\tint i;\n\tunsigned int step_volt;\n\tstruct fuse_corner_data *fdata;\n\tstruct fuse_corner *fuse, *end;\n\tint uV;\n\tconst struct reg_sequence *accs;\n\tint ret;\n\n\taccs = acc_desc->settings;\n\n\tstep_volt = regulator_get_linear_step(drv->vdd_apc);\n\tif (!step_volt)\n\t\treturn -EINVAL;\n\n\t \n\tfuse = drv->fuse_corners;\n\tend = &fuse[desc->num_fuse_corners - 1];\n\tfdata = desc->cpr_fuses.fuse_corner_data;\n\n\tfor (i = 0; fuse <= end; fuse++, fuses++, i++, fdata++) {\n\t\t \n\t\tfdata->min_uV = roundup(fdata->min_uV, step_volt);\n\t\tfdata->max_uV = roundup(fdata->max_uV, step_volt);\n\n\t\t \n\t\tuV = cpr_read_fuse_uV(desc, fdata, fuses->init_voltage,\n\t\t\t\t      step_volt, drv);\n\t\tif (uV < 0)\n\t\t\treturn uV;\n\n\t\tfuse->min_uV = fdata->min_uV;\n\t\tfuse->max_uV = fdata->max_uV;\n\t\tfuse->uV = clamp(uV, fuse->min_uV, fuse->max_uV);\n\n\t\tif (fuse == end) {\n\t\t\t \n\t\t\tend->max_uV = max(end->max_uV, end->uV);\n\t\t}\n\n\t\t \n\t\tret = nvmem_cell_read_variable_le_u32(drv->dev, fuses->quotient, &fuse->quot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfuse->quot *= fdata->quot_scale;\n\t\tfuse->quot += fdata->quot_offset;\n\t\tfuse->quot += fdata->quot_adjust;\n\t\tfuse->step_quot = desc->step_quot[fuse->ring_osc_idx];\n\n\t\t \n\t\tfuse->accs = accs;\n\t\tfuse->num_accs = acc_desc->num_regs_per_fuse;\n\t\taccs += acc_desc->num_regs_per_fuse;\n\t}\n\n\t \n\tfor (fuse = drv->fuse_corners, i = 0; fuse <= end; fuse++, i++) {\n\t\tif (fuse->uV > fuse->max_uV)\n\t\t\tfuse->uV = fuse->max_uV;\n\t\telse if (fuse->uV < fuse->min_uV)\n\t\t\tfuse->uV = fuse->min_uV;\n\n\t\tret = regulator_is_supported_voltage(drv->vdd_apc,\n\t\t\t\t\t\t     fuse->min_uV,\n\t\t\t\t\t\t     fuse->min_uV);\n\t\tif (!ret) {\n\t\t\tdev_err(drv->dev,\n\t\t\t\t\"min uV: %d (fuse corner: %d) not supported by regulator\\n\",\n\t\t\t\tfuse->min_uV, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = regulator_is_supported_voltage(drv->vdd_apc,\n\t\t\t\t\t\t     fuse->max_uV,\n\t\t\t\t\t\t     fuse->max_uV);\n\t\tif (!ret) {\n\t\t\tdev_err(drv->dev,\n\t\t\t\t\"max uV: %d (fuse corner: %d) not supported by regulator\\n\",\n\t\t\t\tfuse->max_uV, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(drv->dev,\n\t\t\t\"fuse corner %d: [%d %d %d] RO%hhu quot %d squot %d\\n\",\n\t\t\ti, fuse->min_uV, fuse->uV, fuse->max_uV,\n\t\t\tfuse->ring_osc_idx, fuse->quot, fuse->step_quot);\n\t}\n\n\treturn 0;\n}\n\nstatic int cpr_calculate_scaling(const char *quot_offset,\n\t\t\t\t struct cpr_drv *drv,\n\t\t\t\t const struct fuse_corner_data *fdata,\n\t\t\t\t const struct corner *corner)\n{\n\tu32 quot_diff = 0;\n\tunsigned long freq_diff;\n\tint scaling;\n\tconst struct fuse_corner *fuse, *prev_fuse;\n\tint ret;\n\n\tfuse = corner->fuse_corner;\n\tprev_fuse = fuse - 1;\n\n\tif (quot_offset) {\n\t\tret = nvmem_cell_read_variable_le_u32(drv->dev, quot_offset, &quot_diff);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tquot_diff *= fdata->quot_offset_scale;\n\t\tquot_diff += fdata->quot_offset_adjust;\n\t} else {\n\t\tquot_diff = fuse->quot - prev_fuse->quot;\n\t}\n\n\tfreq_diff = fuse->max_freq - prev_fuse->max_freq;\n\tfreq_diff /= 1000000;  \n\tscaling = 1000 * quot_diff / freq_diff;\n\treturn min(scaling, fdata->max_quot_scale);\n}\n\nstatic int cpr_interpolate(const struct corner *corner, int step_volt,\n\t\t\t   const struct fuse_corner_data *fdata)\n{\n\tunsigned long f_high, f_low, f_diff;\n\tint uV_high, uV_low, uV;\n\tu64 temp, temp_limit;\n\tconst struct fuse_corner *fuse, *prev_fuse;\n\n\tfuse = corner->fuse_corner;\n\tprev_fuse = fuse - 1;\n\n\tf_high = fuse->max_freq;\n\tf_low = prev_fuse->max_freq;\n\tuV_high = fuse->uV;\n\tuV_low = prev_fuse->uV;\n\tf_diff = fuse->max_freq - corner->freq;\n\n\t \n\tif (f_high <= f_low || uV_high <= uV_low || f_high <= corner->freq)\n\t\treturn corner->uV;\n\n\ttemp = f_diff * (uV_high - uV_low);\n\ttemp = div64_ul(temp, f_high - f_low);\n\n\t \n\ttemp_limit = f_diff * fdata->max_volt_scale;\n\tdo_div(temp_limit, 1000000);\n\n\tuV = uV_high - min(temp, temp_limit);\n\treturn roundup(uV, step_volt);\n}\n\nstatic unsigned int cpr_get_fuse_corner(struct dev_pm_opp *opp)\n{\n\tstruct device_node *np;\n\tunsigned int fuse_corner = 0;\n\n\tnp = dev_pm_opp_get_of_node(opp);\n\tif (of_property_read_u32(np, \"qcom,opp-fuse-level\", &fuse_corner))\n\t\tpr_err(\"%s: missing 'qcom,opp-fuse-level' property\\n\",\n\t\t       __func__);\n\n\tof_node_put(np);\n\n\treturn fuse_corner;\n}\n\nstatic unsigned long cpr_get_opp_hz_for_req(struct dev_pm_opp *ref,\n\t\t\t\t\t    struct device *cpu_dev)\n{\n\tu64 rate = 0;\n\tstruct device_node *ref_np;\n\tstruct device_node *desc_np;\n\tstruct device_node *child_np = NULL;\n\tstruct device_node *child_req_np = NULL;\n\n\tdesc_np = dev_pm_opp_of_get_opp_desc_node(cpu_dev);\n\tif (!desc_np)\n\t\treturn 0;\n\n\tref_np = dev_pm_opp_get_of_node(ref);\n\tif (!ref_np)\n\t\tgoto out_ref;\n\n\tdo {\n\t\tof_node_put(child_req_np);\n\t\tchild_np = of_get_next_available_child(desc_np, child_np);\n\t\tchild_req_np = of_parse_phandle(child_np, \"required-opps\", 0);\n\t} while (child_np && child_req_np != ref_np);\n\n\tif (child_np && child_req_np == ref_np)\n\t\tof_property_read_u64(child_np, \"opp-hz\", &rate);\n\n\tof_node_put(child_req_np);\n\tof_node_put(child_np);\n\tof_node_put(ref_np);\nout_ref:\n\tof_node_put(desc_np);\n\n\treturn (unsigned long) rate;\n}\n\nstatic int cpr_corner_init(struct cpr_drv *drv)\n{\n\tconst struct cpr_desc *desc = drv->desc;\n\tconst struct cpr_fuse *fuses = drv->cpr_fuses;\n\tint i, level, scaling = 0;\n\tunsigned int fnum, fc;\n\tconst char *quot_offset;\n\tstruct fuse_corner *fuse, *prev_fuse;\n\tstruct corner *corner, *end;\n\tstruct corner_data *cdata;\n\tconst struct fuse_corner_data *fdata;\n\tbool apply_scaling;\n\tunsigned long freq_diff, freq_diff_mhz;\n\tunsigned long freq;\n\tint step_volt = regulator_get_linear_step(drv->vdd_apc);\n\tstruct dev_pm_opp *opp;\n\n\tif (!step_volt)\n\t\treturn -EINVAL;\n\n\tcorner = drv->corners;\n\tend = &corner[drv->num_corners - 1];\n\n\tcdata = devm_kcalloc(drv->dev, drv->num_corners,\n\t\t\t     sizeof(struct corner_data),\n\t\t\t     GFP_KERNEL);\n\tif (!cdata)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (level = 1; level <= drv->num_corners; level++) {\n\t\topp = dev_pm_opp_find_level_exact(&drv->pd.dev, level);\n\t\tif (IS_ERR(opp))\n\t\t\treturn -EINVAL;\n\t\tfc = cpr_get_fuse_corner(opp);\n\t\tif (!fc) {\n\t\t\tdev_pm_opp_put(opp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfnum = fc - 1;\n\t\tfreq = cpr_get_opp_hz_for_req(opp, drv->attached_cpu_dev);\n\t\tif (!freq) {\n\t\t\tdev_pm_opp_put(opp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcdata[level - 1].fuse_corner = fnum;\n\t\tcdata[level - 1].freq = freq;\n\n\t\tfuse = &drv->fuse_corners[fnum];\n\t\tdev_dbg(drv->dev, \"freq: %lu level: %u fuse level: %u\\n\",\n\t\t\tfreq, dev_pm_opp_get_level(opp) - 1, fnum);\n\t\tif (freq > fuse->max_freq)\n\t\t\tfuse->max_freq = freq;\n\t\tdev_pm_opp_put(opp);\n\t}\n\n\t \n\tfor (apply_scaling = false, i = 0; corner <= end; corner++, i++) {\n\t\tfnum = cdata[i].fuse_corner;\n\t\tfdata = &desc->cpr_fuses.fuse_corner_data[fnum];\n\t\tquot_offset = fuses[fnum].quotient_offset;\n\t\tfuse = &drv->fuse_corners[fnum];\n\t\tif (fnum)\n\t\t\tprev_fuse = &drv->fuse_corners[fnum - 1];\n\t\telse\n\t\t\tprev_fuse = NULL;\n\n\t\tcorner->fuse_corner = fuse;\n\t\tcorner->freq = cdata[i].freq;\n\t\tcorner->uV = fuse->uV;\n\n\t\tif (prev_fuse && cdata[i - 1].freq == prev_fuse->max_freq) {\n\t\t\tscaling = cpr_calculate_scaling(quot_offset, drv,\n\t\t\t\t\t\t\tfdata, corner);\n\t\t\tif (scaling < 0)\n\t\t\t\treturn scaling;\n\n\t\t\tapply_scaling = true;\n\t\t} else if (corner->freq == fuse->max_freq) {\n\t\t\t \n\t\t\tapply_scaling = false;\n\t\t}\n\n\t\tif (apply_scaling) {\n\t\t\tfreq_diff = fuse->max_freq - corner->freq;\n\t\t\tfreq_diff_mhz = freq_diff / 1000000;\n\t\t\tcorner->quot_adjust = scaling * freq_diff_mhz / 1000;\n\n\t\t\tcorner->uV = cpr_interpolate(corner, step_volt, fdata);\n\t\t}\n\n\t\tcorner->max_uV = fuse->max_uV;\n\t\tcorner->min_uV = fuse->min_uV;\n\t\tcorner->uV = clamp(corner->uV, corner->min_uV, corner->max_uV);\n\t\tcorner->last_uV = corner->uV;\n\n\t\t \n\t\tif (desc->reduce_to_corner_uV && corner->uV < corner->max_uV)\n\t\t\tcorner->max_uV = corner->uV;\n\t\telse if (desc->reduce_to_fuse_uV && fuse->uV < corner->max_uV)\n\t\t\tcorner->max_uV = max(corner->min_uV, fuse->uV);\n\n\t\tdev_dbg(drv->dev, \"corner %d: [%d %d %d] quot %d\\n\", i,\n\t\t\tcorner->min_uV, corner->uV, corner->max_uV,\n\t\t\tfuse->quot - corner->quot_adjust);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct cpr_fuse *cpr_get_fuses(struct cpr_drv *drv)\n{\n\tconst struct cpr_desc *desc = drv->desc;\n\tstruct cpr_fuse *fuses;\n\tint i;\n\n\tfuses = devm_kcalloc(drv->dev, desc->num_fuse_corners,\n\t\t\t     sizeof(struct cpr_fuse),\n\t\t\t     GFP_KERNEL);\n\tif (!fuses)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < desc->num_fuse_corners; i++) {\n\t\tchar tbuf[32];\n\n\t\tsnprintf(tbuf, 32, \"cpr_ring_osc%d\", i + 1);\n\t\tfuses[i].ring_osc = devm_kstrdup(drv->dev, tbuf, GFP_KERNEL);\n\t\tif (!fuses[i].ring_osc)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tsnprintf(tbuf, 32, \"cpr_init_voltage%d\", i + 1);\n\t\tfuses[i].init_voltage = devm_kstrdup(drv->dev, tbuf,\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!fuses[i].init_voltage)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tsnprintf(tbuf, 32, \"cpr_quotient%d\", i + 1);\n\t\tfuses[i].quotient = devm_kstrdup(drv->dev, tbuf, GFP_KERNEL);\n\t\tif (!fuses[i].quotient)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tsnprintf(tbuf, 32, \"cpr_quotient_offset%d\", i + 1);\n\t\tfuses[i].quotient_offset = devm_kstrdup(drv->dev, tbuf,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!fuses[i].quotient_offset)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn fuses;\n}\n\nstatic void cpr_set_loop_allowed(struct cpr_drv *drv)\n{\n\tdrv->loop_disabled = false;\n}\n\nstatic int cpr_init_parameters(struct cpr_drv *drv)\n{\n\tconst struct cpr_desc *desc = drv->desc;\n\tstruct clk *clk;\n\n\tclk = clk_get(drv->dev, \"ref\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tdrv->ref_clk_khz = clk_get_rate(clk) / 1000;\n\tclk_put(clk);\n\n\tif (desc->timer_cons_up > RBIF_TIMER_ADJ_CONS_UP_MASK ||\n\t    desc->timer_cons_down > RBIF_TIMER_ADJ_CONS_DOWN_MASK ||\n\t    desc->up_threshold > RBCPR_CTL_UP_THRESHOLD_MASK ||\n\t    desc->down_threshold > RBCPR_CTL_DN_THRESHOLD_MASK ||\n\t    desc->idle_clocks > RBCPR_STEP_QUOT_IDLE_CLK_MASK ||\n\t    desc->clamp_timer_interval > RBIF_TIMER_ADJ_CLAMP_INT_MASK)\n\t\treturn -EINVAL;\n\n\tdev_dbg(drv->dev, \"up threshold = %u, down threshold = %u\\n\",\n\t\tdesc->up_threshold, desc->down_threshold);\n\n\treturn 0;\n}\n\nstatic int cpr_find_initial_corner(struct cpr_drv *drv)\n{\n\tunsigned long rate;\n\tconst struct corner *end;\n\tstruct corner *iter;\n\tunsigned int i = 0;\n\n\tif (!drv->cpu_clk) {\n\t\tdev_err(drv->dev, \"cannot get rate from NULL clk\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tend = &drv->corners[drv->num_corners - 1];\n\trate = clk_get_rate(drv->cpu_clk);\n\n\t \n\tfor (iter = drv->corners; iter <= end; iter++) {\n\t\tif (iter->freq > rate)\n\t\t\tbreak;\n\t\ti++;\n\t\tif (iter->freq == rate) {\n\t\t\tdrv->corner = iter;\n\t\t\tbreak;\n\t\t}\n\t\tif (iter->freq < rate)\n\t\t\tdrv->corner = iter;\n\t}\n\n\tif (!drv->corner) {\n\t\tdev_err(drv->dev, \"boot up corner not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(drv->dev, \"boot up perf state: %u\\n\", i);\n\n\treturn 0;\n}\n\nstatic const struct cpr_desc qcs404_cpr_desc = {\n\t.num_fuse_corners = 3,\n\t.min_diff_quot = CPR_FUSE_MIN_QUOT_DIFF,\n\t.step_quot = (int []){ 25, 25, 25, },\n\t.timer_delay_us = 5000,\n\t.timer_cons_up = 0,\n\t.timer_cons_down = 2,\n\t.up_threshold = 1,\n\t.down_threshold = 3,\n\t.idle_clocks = 15,\n\t.gcnt_us = 1,\n\t.vdd_apc_step_up_limit = 1,\n\t.vdd_apc_step_down_limit = 1,\n\t.cpr_fuses = {\n\t\t.init_voltage_step = 8000,\n\t\t.init_voltage_width = 6,\n\t\t.fuse_corner_data = (struct fuse_corner_data[]){\n\t\t\t \n\t\t\t{\n\t\t\t\t.ref_uV = 1224000,\n\t\t\t\t.max_uV = 1224000,\n\t\t\t\t.min_uV = 1048000,\n\t\t\t\t.max_volt_scale = 0,\n\t\t\t\t.max_quot_scale = 0,\n\t\t\t\t.quot_offset = 0,\n\t\t\t\t.quot_scale = 1,\n\t\t\t\t.quot_adjust = 0,\n\t\t\t\t.quot_offset_scale = 5,\n\t\t\t\t.quot_offset_adjust = 0,\n\t\t\t},\n\t\t\t \n\t\t\t{\n\t\t\t\t.ref_uV = 1288000,\n\t\t\t\t.max_uV = 1288000,\n\t\t\t\t.min_uV = 1048000,\n\t\t\t\t.max_volt_scale = 2000,\n\t\t\t\t.max_quot_scale = 1400,\n\t\t\t\t.quot_offset = 0,\n\t\t\t\t.quot_scale = 1,\n\t\t\t\t.quot_adjust = -20,\n\t\t\t\t.quot_offset_scale = 5,\n\t\t\t\t.quot_offset_adjust = 0,\n\t\t\t},\n\t\t\t \n\t\t\t{\n\t\t\t\t.ref_uV = 1352000,\n\t\t\t\t.max_uV = 1384000,\n\t\t\t\t.min_uV = 1088000,\n\t\t\t\t.max_volt_scale = 2000,\n\t\t\t\t.max_quot_scale = 1400,\n\t\t\t\t.quot_offset = 0,\n\t\t\t\t.quot_scale = 1,\n\t\t\t\t.quot_adjust = 0,\n\t\t\t\t.quot_offset_scale = 5,\n\t\t\t\t.quot_offset_adjust = 0,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic const struct acc_desc qcs404_acc_desc = {\n\t.settings = (struct reg_sequence[]){\n\t\t{ 0xb120, 0x1041040 },\n\t\t{ 0xb124, 0x41 },\n\t\t{ 0xb120, 0x0 },\n\t\t{ 0xb124, 0x0 },\n\t\t{ 0xb120, 0x0 },\n\t\t{ 0xb124, 0x0 },\n\t},\n\t.config = (struct reg_sequence[]){\n\t\t{ 0xb138, 0xff },\n\t\t{ 0xb130, 0x5555 },\n\t},\n\t.num_regs_per_fuse = 2,\n};\n\nstatic const struct cpr_acc_desc qcs404_cpr_acc_desc = {\n\t.cpr_desc = &qcs404_cpr_desc,\n\t.acc_desc = &qcs404_acc_desc,\n};\n\nstatic unsigned int cpr_get_performance_state(struct generic_pm_domain *genpd,\n\t\t\t\t\t      struct dev_pm_opp *opp)\n{\n\treturn dev_pm_opp_get_level(opp);\n}\n\nstatic int cpr_power_off(struct generic_pm_domain *domain)\n{\n\tstruct cpr_drv *drv = container_of(domain, struct cpr_drv, pd);\n\n\treturn cpr_disable(drv);\n}\n\nstatic int cpr_power_on(struct generic_pm_domain *domain)\n{\n\tstruct cpr_drv *drv = container_of(domain, struct cpr_drv, pd);\n\n\treturn cpr_enable(drv);\n}\n\nstatic int cpr_pd_attach_dev(struct generic_pm_domain *domain,\n\t\t\t     struct device *dev)\n{\n\tstruct cpr_drv *drv = container_of(domain, struct cpr_drv, pd);\n\tconst struct acc_desc *acc_desc = drv->acc_desc;\n\tint ret = 0;\n\n\tmutex_lock(&drv->lock);\n\n\tdev_dbg(drv->dev, \"attach callback for: %s\\n\", dev_name(dev));\n\n\t \n\tif (drv->attached_cpu_dev)\n\t\tgoto unlock;\n\n\t \n\tdrv->cpu_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(drv->cpu_clk)) {\n\t\tret = PTR_ERR(drv->cpu_clk);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(drv->dev, \"could not get cpu clk: %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n\tdrv->attached_cpu_dev = dev;\n\n\tdev_dbg(drv->dev, \"using cpu clk from: %s\\n\",\n\t\tdev_name(drv->attached_cpu_dev));\n\n\t \n\tret = dev_pm_opp_get_opp_count(&drv->pd.dev);\n\tif (ret < 0) {\n\t\tdev_err(drv->dev, \"could not get OPP count\\n\");\n\t\tgoto unlock;\n\t}\n\tdrv->num_corners = ret;\n\n\tif (drv->num_corners < 2) {\n\t\tdev_err(drv->dev, \"need at least 2 OPPs to use CPR\\n\");\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tdrv->corners = devm_kcalloc(drv->dev, drv->num_corners,\n\t\t\t\t    sizeof(*drv->corners),\n\t\t\t\t    GFP_KERNEL);\n\tif (!drv->corners) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tret = cpr_corner_init(drv);\n\tif (ret)\n\t\tgoto unlock;\n\n\tcpr_set_loop_allowed(drv);\n\n\tret = cpr_init_parameters(drv);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tret = cpr_config(drv);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = cpr_find_initial_corner(drv);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (acc_desc->config)\n\t\tregmap_multi_reg_write(drv->tcsr, acc_desc->config,\n\t\t\t\t       acc_desc->num_regs_per_fuse);\n\n\t \n\tif (acc_desc->enable_mask)\n\t\tregmap_update_bits(drv->tcsr, acc_desc->enable_reg,\n\t\t\t\t   acc_desc->enable_mask,\n\t\t\t\t   acc_desc->enable_mask);\n\n\tdev_info(drv->dev, \"driver initialized with %u OPPs\\n\",\n\t\t drv->num_corners);\n\nunlock:\n\tmutex_unlock(&drv->lock);\n\n\treturn ret;\n}\n\nstatic int cpr_debug_info_show(struct seq_file *s, void *unused)\n{\n\tu32 gcnt, ro_sel, ctl, irq_status, reg, error_steps;\n\tu32 step_dn, step_up, error, error_lt0, busy;\n\tstruct cpr_drv *drv = s->private;\n\tstruct fuse_corner *fuse_corner;\n\tstruct corner *corner;\n\n\tcorner = drv->corner;\n\tfuse_corner = corner->fuse_corner;\n\n\tseq_printf(s, \"corner, current_volt = %d uV\\n\",\n\t\t       corner->last_uV);\n\n\tro_sel = fuse_corner->ring_osc_idx;\n\tgcnt = cpr_read(drv, REG_RBCPR_GCNT_TARGET(ro_sel));\n\tseq_printf(s, \"rbcpr_gcnt_target (%u) = %#02X\\n\", ro_sel, gcnt);\n\n\tctl = cpr_read(drv, REG_RBCPR_CTL);\n\tseq_printf(s, \"rbcpr_ctl = %#02X\\n\", ctl);\n\n\tirq_status = cpr_read(drv, REG_RBIF_IRQ_STATUS);\n\tseq_printf(s, \"rbcpr_irq_status = %#02X\\n\", irq_status);\n\n\treg = cpr_read(drv, REG_RBCPR_RESULT_0);\n\tseq_printf(s, \"rbcpr_result_0 = %#02X\\n\", reg);\n\n\tstep_dn = reg & 0x01;\n\tstep_up = (reg >> RBCPR_RESULT0_STEP_UP_SHIFT) & 0x01;\n\tseq_printf(s, \"  [step_dn = %u\", step_dn);\n\n\tseq_printf(s, \", step_up = %u\", step_up);\n\n\terror_steps = (reg >> RBCPR_RESULT0_ERROR_STEPS_SHIFT)\n\t\t\t\t& RBCPR_RESULT0_ERROR_STEPS_MASK;\n\tseq_printf(s, \", error_steps = %u\", error_steps);\n\n\terror = (reg >> RBCPR_RESULT0_ERROR_SHIFT) & RBCPR_RESULT0_ERROR_MASK;\n\tseq_printf(s, \", error = %u\", error);\n\n\terror_lt0 = (reg >> RBCPR_RESULT0_ERROR_LT0_SHIFT) & 0x01;\n\tseq_printf(s, \", error_lt_0 = %u\", error_lt0);\n\n\tbusy = (reg >> RBCPR_RESULT0_BUSY_SHIFT) & 0x01;\n\tseq_printf(s, \", busy = %u]\\n\", busy);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(cpr_debug_info);\n\nstatic void cpr_debugfs_init(struct cpr_drv *drv)\n{\n\tdrv->debugfs = debugfs_create_dir(\"qcom_cpr\", NULL);\n\n\tdebugfs_create_file(\"debug_info\", 0444, drv->debugfs,\n\t\t\t    drv, &cpr_debug_info_fops);\n}\n\nstatic int cpr_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cpr_drv *drv;\n\tint irq, ret;\n\tconst struct cpr_acc_desc *data;\n\tstruct device_node *np;\n\tu32 cpr_rev = FUSE_REVISION_UNKNOWN;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data || !data->cpr_desc || !data->acc_desc)\n\t\treturn -EINVAL;\n\n\tdrv = devm_kzalloc(dev, sizeof(*drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\tdrv->dev = dev;\n\tdrv->desc = data->cpr_desc;\n\tdrv->acc_desc = data->acc_desc;\n\n\tdrv->fuse_corners = devm_kcalloc(dev, drv->desc->num_fuse_corners,\n\t\t\t\t\t sizeof(*drv->fuse_corners),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!drv->fuse_corners)\n\t\treturn -ENOMEM;\n\n\tnp = of_parse_phandle(dev->of_node, \"acc-syscon\", 0);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tdrv->tcsr = syscon_node_to_regmap(np);\n\tof_node_put(np);\n\tif (IS_ERR(drv->tcsr))\n\t\treturn PTR_ERR(drv->tcsr);\n\n\tdrv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(drv->base))\n\t\treturn PTR_ERR(drv->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tdrv->vdd_apc = devm_regulator_get(dev, \"vdd-apc\");\n\tif (IS_ERR(drv->vdd_apc))\n\t\treturn PTR_ERR(drv->vdd_apc);\n\n\t \n\tret = nvmem_cell_read_variable_le_u32(dev, \"cpr_fuse_revision\", &cpr_rev);\n\tif (ret)\n\t\treturn ret;\n\n\tdrv->cpr_fuses = cpr_get_fuses(drv);\n\tif (IS_ERR(drv->cpr_fuses))\n\t\treturn PTR_ERR(drv->cpr_fuses);\n\n\tret = cpr_populate_ring_osc_idx(drv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cpr_fuse_corner_init(drv);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&drv->lock);\n\n\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t\tcpr_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_RISING,\n\t\t\t\t\t\"cpr\", drv);\n\tif (ret)\n\t\treturn ret;\n\n\tdrv->pd.name = devm_kstrdup_const(dev, dev->of_node->full_name,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!drv->pd.name)\n\t\treturn -EINVAL;\n\n\tdrv->pd.power_off = cpr_power_off;\n\tdrv->pd.power_on = cpr_power_on;\n\tdrv->pd.set_performance_state = cpr_set_performance_state;\n\tdrv->pd.opp_to_performance_state = cpr_get_performance_state;\n\tdrv->pd.attach_dev = cpr_pd_attach_dev;\n\n\tret = pm_genpd_init(&drv->pd, NULL, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_genpd_add_provider_simple(dev->of_node, &drv->pd);\n\tif (ret)\n\t\tgoto err_remove_genpd;\n\n\tplatform_set_drvdata(pdev, drv);\n\tcpr_debugfs_init(drv);\n\n\treturn 0;\n\nerr_remove_genpd:\n\tpm_genpd_remove(&drv->pd);\n\treturn ret;\n}\n\nstatic int cpr_remove(struct platform_device *pdev)\n{\n\tstruct cpr_drv *drv = platform_get_drvdata(pdev);\n\n\tif (cpr_is_allowed(drv)) {\n\t\tcpr_ctl_disable(drv);\n\t\tcpr_irq_set(drv, 0);\n\t}\n\n\tof_genpd_del_provider(pdev->dev.of_node);\n\tpm_genpd_remove(&drv->pd);\n\n\tdebugfs_remove_recursive(drv->debugfs);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id cpr_match_table[] = {\n\t{ .compatible = \"qcom,qcs404-cpr\", .data = &qcs404_cpr_acc_desc },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cpr_match_table);\n\nstatic struct platform_driver cpr_driver = {\n\t.probe\t\t= cpr_probe,\n\t.remove\t\t= cpr_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"qcom-cpr\",\n\t\t.of_match_table = cpr_match_table,\n\t},\n};\nmodule_platform_driver(cpr_driver);\n\nMODULE_DESCRIPTION(\"Core Power Reduction (CPR) driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}