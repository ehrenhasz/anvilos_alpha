{
  "module_name": "rpmhpd.c",
  "hash_id": "91fa63c75f9404be67e14b0a755766f8ccb7813095a2fc8c4adc59feb6cc3713",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/qcom/rpmhpd.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pm_domain.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <soc/qcom/cmd-db.h>\n#include <soc/qcom/rpmh.h>\n#include <dt-bindings/power/qcom-rpmpd.h>\n#include <dt-bindings/power/qcom,rpmhpd.h>\n\n#define domain_to_rpmhpd(domain) container_of(domain, struct rpmhpd, pd)\n\n#define RPMH_ARC_MAX_LEVELS\t16\n\n \nstruct rpmhpd {\n\tstruct device\t*dev;\n\tstruct generic_pm_domain pd;\n\tstruct generic_pm_domain *parent;\n\tstruct rpmhpd\t*peer;\n\tconst bool\tactive_only;\n\tunsigned int\tcorner;\n\tunsigned int\tactive_corner;\n\tunsigned int\tenable_corner;\n\tu32\t\tlevel[RPMH_ARC_MAX_LEVELS];\n\tsize_t\t\tlevel_count;\n\tbool\t\tenabled;\n\tconst char\t*res_name;\n\tu32\t\taddr;\n\tbool\t\tstate_synced;\n};\n\nstruct rpmhpd_desc {\n\tstruct rpmhpd **rpmhpds;\n\tsize_t num_pds;\n};\n\nstatic DEFINE_MUTEX(rpmhpd_lock);\n\n \n\nstatic struct rpmhpd cx_ao;\nstatic struct rpmhpd mx;\nstatic struct rpmhpd mx_ao;\nstatic struct rpmhpd cx = {\n\t.pd = { .name = \"cx\", },\n\t.peer = &cx_ao,\n\t.res_name = \"cx.lvl\",\n};\n\nstatic struct rpmhpd cx_ao = {\n\t.pd = { .name = \"cx_ao\", },\n\t.active_only = true,\n\t.peer = &cx,\n\t.res_name = \"cx.lvl\",\n};\n\nstatic struct rpmhpd cx_ao_w_mx_parent;\nstatic struct rpmhpd cx_w_mx_parent = {\n\t.pd = { .name = \"cx\", },\n\t.peer = &cx_ao_w_mx_parent,\n\t.parent = &mx.pd,\n\t.res_name = \"cx.lvl\",\n};\n\nstatic struct rpmhpd cx_ao_w_mx_parent = {\n\t.pd = { .name = \"cx_ao\", },\n\t.active_only = true,\n\t.peer = &cx_w_mx_parent,\n\t.parent = &mx_ao.pd,\n\t.res_name = \"cx.lvl\",\n};\n\nstatic struct rpmhpd ebi = {\n\t.pd = { .name = \"ebi\", },\n\t.res_name = \"ebi.lvl\",\n};\n\nstatic struct rpmhpd gfx = {\n\t.pd = { .name = \"gfx\", },\n\t.res_name = \"gfx.lvl\",\n};\n\nstatic struct rpmhpd lcx = {\n\t.pd = { .name = \"lcx\", },\n\t.res_name = \"lcx.lvl\",\n};\n\nstatic struct rpmhpd lmx = {\n\t.pd = { .name = \"lmx\", },\n\t.res_name = \"lmx.lvl\",\n};\n\nstatic struct rpmhpd mmcx_ao;\nstatic struct rpmhpd mmcx = {\n\t.pd = { .name = \"mmcx\", },\n\t.peer = &mmcx_ao,\n\t.res_name = \"mmcx.lvl\",\n};\n\nstatic struct rpmhpd mmcx_ao = {\n\t.pd = { .name = \"mmcx_ao\", },\n\t.active_only = true,\n\t.peer = &mmcx,\n\t.res_name = \"mmcx.lvl\",\n};\n\nstatic struct rpmhpd mmcx_ao_w_cx_parent;\nstatic struct rpmhpd mmcx_w_cx_parent = {\n\t.pd = { .name = \"mmcx\", },\n\t.peer = &mmcx_ao_w_cx_parent,\n\t.parent = &cx.pd,\n\t.res_name = \"mmcx.lvl\",\n};\n\nstatic struct rpmhpd mmcx_ao_w_cx_parent = {\n\t.pd = { .name = \"mmcx_ao\", },\n\t.active_only = true,\n\t.peer = &mmcx_w_cx_parent,\n\t.parent = &cx_ao.pd,\n\t.res_name = \"mmcx.lvl\",\n};\n\nstatic struct rpmhpd mss = {\n\t.pd = { .name = \"mss\", },\n\t.res_name = \"mss.lvl\",\n};\n\nstatic struct rpmhpd mx_ao;\nstatic struct rpmhpd mx = {\n\t.pd = { .name = \"mx\", },\n\t.peer = &mx_ao,\n\t.res_name = \"mx.lvl\",\n};\n\nstatic struct rpmhpd mx_ao = {\n\t.pd = { .name = \"mx_ao\", },\n\t.active_only = true,\n\t.peer = &mx,\n\t.res_name = \"mx.lvl\",\n};\n\nstatic struct rpmhpd mxc_ao;\nstatic struct rpmhpd mxc = {\n\t.pd = { .name = \"mxc\", },\n\t.peer = &mxc_ao,\n\t.res_name = \"mxc.lvl\",\n};\n\nstatic struct rpmhpd mxc_ao = {\n\t.pd = { .name = \"mxc_ao\", },\n\t.active_only = true,\n\t.peer = &mxc,\n\t.res_name = \"mxc.lvl\",\n};\n\nstatic struct rpmhpd nsp = {\n\t.pd = { .name = \"nsp\", },\n\t.res_name = \"nsp.lvl\",\n};\n\nstatic struct rpmhpd nsp0 = {\n\t.pd = { .name = \"nsp0\", },\n\t.res_name = \"nsp0.lvl\",\n};\n\nstatic struct rpmhpd nsp1 = {\n\t.pd = { .name = \"nsp1\", },\n\t.res_name = \"nsp1.lvl\",\n};\n\nstatic struct rpmhpd qphy = {\n\t.pd = { .name = \"qphy\", },\n\t.res_name = \"qphy.lvl\",\n};\n\n \nstatic struct rpmhpd *sa8540p_rpmhpds[] = {\n\t[SC8280XP_CX] = &cx,\n\t[SC8280XP_CX_AO] = &cx_ao,\n\t[SC8280XP_EBI] = &ebi,\n\t[SC8280XP_GFX] = &gfx,\n\t[SC8280XP_LCX] = &lcx,\n\t[SC8280XP_LMX] = &lmx,\n\t[SC8280XP_MMCX] = &mmcx,\n\t[SC8280XP_MMCX_AO] = &mmcx_ao,\n\t[SC8280XP_MX] = &mx,\n\t[SC8280XP_MX_AO] = &mx_ao,\n\t[SC8280XP_NSP] = &nsp,\n};\n\nstatic const struct rpmhpd_desc sa8540p_desc = {\n\t.rpmhpds = sa8540p_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sa8540p_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sa8775p_rpmhpds[] = {\n\t[SA8775P_CX] = &cx,\n\t[SA8775P_CX_AO] = &cx_ao,\n\t[SA8775P_EBI] = &ebi,\n\t[SA8775P_GFX] = &gfx,\n\t[SA8775P_LCX] = &lcx,\n\t[SA8775P_LMX] = &lmx,\n\t[SA8775P_MMCX] = &mmcx,\n\t[SA8775P_MMCX_AO] = &mmcx_ao,\n\t[SA8775P_MXC] = &mxc,\n\t[SA8775P_MXC_AO] = &mxc_ao,\n\t[SA8775P_MX] = &mx,\n\t[SA8775P_MX_AO] = &mx_ao,\n\t[SA8775P_NSP0] = &nsp0,\n\t[SA8775P_NSP1] = &nsp1,\n};\n\nstatic const struct rpmhpd_desc sa8775p_desc = {\n\t.rpmhpds = sa8775p_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sa8775p_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sdm670_rpmhpds[] = {\n\t[SDM670_CX] = &cx_w_mx_parent,\n\t[SDM670_CX_AO] = &cx_ao_w_mx_parent,\n\t[SDM670_GFX] = &gfx,\n\t[SDM670_LCX] = &lcx,\n\t[SDM670_LMX] = &lmx,\n\t[SDM670_MSS] = &mss,\n\t[SDM670_MX] = &mx,\n\t[SDM670_MX_AO] = &mx_ao,\n};\n\nstatic const struct rpmhpd_desc sdm670_desc = {\n\t.rpmhpds = sdm670_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sdm670_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sdm845_rpmhpds[] = {\n\t[SDM845_CX] = &cx_w_mx_parent,\n\t[SDM845_CX_AO] = &cx_ao_w_mx_parent,\n\t[SDM845_EBI] = &ebi,\n\t[SDM845_GFX] = &gfx,\n\t[SDM845_LCX] = &lcx,\n\t[SDM845_LMX] = &lmx,\n\t[SDM845_MSS] = &mss,\n\t[SDM845_MX] = &mx,\n\t[SDM845_MX_AO] = &mx_ao,\n};\n\nstatic const struct rpmhpd_desc sdm845_desc = {\n\t.rpmhpds = sdm845_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sdm845_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sdx55_rpmhpds[] = {\n\t[SDX55_CX] = &cx_w_mx_parent,\n\t[SDX55_MSS] = &mss,\n\t[SDX55_MX] = &mx,\n};\n\nstatic const struct rpmhpd_desc sdx55_desc = {\n\t.rpmhpds = sdx55_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sdx55_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sdx65_rpmhpds[] = {\n\t[SDX65_CX] = &cx_w_mx_parent,\n\t[SDX65_CX_AO] = &cx_ao_w_mx_parent,\n\t[SDX65_MSS] = &mss,\n\t[SDX65_MX] = &mx,\n\t[SDX65_MX_AO] = &mx_ao,\n\t[SDX65_MXC] = &mxc,\n};\n\nstatic const struct rpmhpd_desc sdx65_desc = {\n\t.rpmhpds = sdx65_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sdx65_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sdx75_rpmhpds[] = {\n\t[RPMHPD_CX] = &cx,\n\t[RPMHPD_CX_AO] = &cx_ao,\n\t[RPMHPD_MSS] = &mss,\n\t[RPMHPD_MX] = &mx,\n\t[RPMHPD_MX_AO] = &mx_ao,\n\t[RPMHPD_MXC] = &mxc,\n};\n\nstatic const struct rpmhpd_desc sdx75_desc = {\n\t.rpmhpds = sdx75_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sdx75_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sm6350_rpmhpds[] = {\n\t[SM6350_CX] = &cx_w_mx_parent,\n\t[SM6350_GFX] = &gfx,\n\t[SM6350_LCX] = &lcx,\n\t[SM6350_LMX] = &lmx,\n\t[SM6350_MSS] = &mss,\n\t[SM6350_MX] = &mx,\n};\n\nstatic const struct rpmhpd_desc sm6350_desc = {\n\t.rpmhpds = sm6350_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sm6350_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sm8150_rpmhpds[] = {\n\t[SM8150_CX] = &cx_w_mx_parent,\n\t[SM8150_CX_AO] = &cx_ao_w_mx_parent,\n\t[SM8150_EBI] = &ebi,\n\t[SM8150_GFX] = &gfx,\n\t[SM8150_LCX] = &lcx,\n\t[SM8150_LMX] = &lmx,\n\t[SM8150_MMCX] = &mmcx,\n\t[SM8150_MMCX_AO] = &mmcx_ao,\n\t[SM8150_MSS] = &mss,\n\t[SM8150_MX] = &mx,\n\t[SM8150_MX_AO] = &mx_ao,\n};\n\nstatic const struct rpmhpd_desc sm8150_desc = {\n\t.rpmhpds = sm8150_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sm8150_rpmhpds),\n};\n\nstatic struct rpmhpd *sa8155p_rpmhpds[] = {\n\t[SA8155P_CX] = &cx_w_mx_parent,\n\t[SA8155P_CX_AO] = &cx_ao_w_mx_parent,\n\t[SA8155P_EBI] = &ebi,\n\t[SA8155P_GFX] = &gfx,\n\t[SA8155P_MSS] = &mss,\n\t[SA8155P_MX] = &mx,\n\t[SA8155P_MX_AO] = &mx_ao,\n};\n\nstatic const struct rpmhpd_desc sa8155p_desc = {\n\t.rpmhpds = sa8155p_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sa8155p_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sm8250_rpmhpds[] = {\n\t[RPMHPD_CX] = &cx_w_mx_parent,\n\t[RPMHPD_CX_AO] = &cx_ao_w_mx_parent,\n\t[RPMHPD_EBI] = &ebi,\n\t[RPMHPD_GFX] = &gfx,\n\t[RPMHPD_LCX] = &lcx,\n\t[RPMHPD_LMX] = &lmx,\n\t[RPMHPD_MMCX] = &mmcx,\n\t[RPMHPD_MMCX_AO] = &mmcx_ao,\n\t[RPMHPD_MX] = &mx,\n\t[RPMHPD_MX_AO] = &mx_ao,\n};\n\nstatic const struct rpmhpd_desc sm8250_desc = {\n\t.rpmhpds = sm8250_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sm8250_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sm8350_rpmhpds[] = {\n\t[RPMHPD_CX] = &cx_w_mx_parent,\n\t[RPMHPD_CX_AO] = &cx_ao_w_mx_parent,\n\t[RPMHPD_EBI] = &ebi,\n\t[RPMHPD_GFX] = &gfx,\n\t[RPMHPD_LCX] = &lcx,\n\t[RPMHPD_LMX] = &lmx,\n\t[RPMHPD_MMCX] = &mmcx,\n\t[RPMHPD_MMCX_AO] = &mmcx_ao,\n\t[RPMHPD_MSS] = &mss,\n\t[RPMHPD_MX] = &mx,\n\t[RPMHPD_MX_AO] = &mx_ao,\n\t[RPMHPD_MXC] = &mxc,\n\t[RPMHPD_MXC_AO] = &mxc_ao,\n};\n\nstatic const struct rpmhpd_desc sm8350_desc = {\n\t.rpmhpds = sm8350_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sm8350_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sm8450_rpmhpds[] = {\n\t[RPMHPD_CX] = &cx,\n\t[RPMHPD_CX_AO] = &cx_ao,\n\t[RPMHPD_EBI] = &ebi,\n\t[RPMHPD_GFX] = &gfx,\n\t[RPMHPD_LCX] = &lcx,\n\t[RPMHPD_LMX] = &lmx,\n\t[RPMHPD_MMCX] = &mmcx_w_cx_parent,\n\t[RPMHPD_MMCX_AO] = &mmcx_ao_w_cx_parent,\n\t[RPMHPD_MSS] = &mss,\n\t[RPMHPD_MX] = &mx,\n\t[RPMHPD_MX_AO] = &mx_ao,\n\t[RPMHPD_MXC] = &mxc,\n\t[RPMHPD_MXC_AO] = &mxc_ao,\n};\n\nstatic const struct rpmhpd_desc sm8450_desc = {\n\t.rpmhpds = sm8450_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sm8450_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sm8550_rpmhpds[] = {\n\t[RPMHPD_CX] = &cx,\n\t[RPMHPD_CX_AO] = &cx_ao,\n\t[RPMHPD_EBI] = &ebi,\n\t[RPMHPD_GFX] = &gfx,\n\t[RPMHPD_LCX] = &lcx,\n\t[RPMHPD_LMX] = &lmx,\n\t[RPMHPD_MMCX] = &mmcx_w_cx_parent,\n\t[RPMHPD_MMCX_AO] = &mmcx_ao_w_cx_parent,\n\t[RPMHPD_MSS] = &mss,\n\t[RPMHPD_MX] = &mx,\n\t[RPMHPD_MX_AO] = &mx_ao,\n\t[RPMHPD_MXC] = &mxc,\n\t[RPMHPD_MXC_AO] = &mxc_ao,\n\t[RPMHPD_NSP] = &nsp,\n};\n\nstatic const struct rpmhpd_desc sm8550_desc = {\n\t.rpmhpds = sm8550_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sm8550_rpmhpds),\n};\n\n \nstatic struct rpmhpd *qdu1000_rpmhpds[] = {\n\t[QDU1000_CX] = &cx,\n\t[QDU1000_EBI] = &ebi,\n\t[QDU1000_MSS] = &mss,\n\t[QDU1000_MX] = &mx,\n};\n\nstatic const struct rpmhpd_desc qdu1000_desc = {\n\t.rpmhpds = qdu1000_rpmhpds,\n\t.num_pds = ARRAY_SIZE(qdu1000_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sc7180_rpmhpds[] = {\n\t[SC7180_CX] = &cx_w_mx_parent,\n\t[SC7180_CX_AO] = &cx_ao_w_mx_parent,\n\t[SC7180_GFX] = &gfx,\n\t[SC7180_LCX] = &lcx,\n\t[SC7180_LMX] = &lmx,\n\t[SC7180_MSS] = &mss,\n\t[SC7180_MX] = &mx,\n\t[SC7180_MX_AO] = &mx_ao,\n};\n\nstatic const struct rpmhpd_desc sc7180_desc = {\n\t.rpmhpds = sc7180_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sc7180_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sc7280_rpmhpds[] = {\n\t[SC7280_CX] = &cx,\n\t[SC7280_CX_AO] = &cx_ao,\n\t[SC7280_EBI] = &ebi,\n\t[SC7280_GFX] = &gfx,\n\t[SC7280_LCX] = &lcx,\n\t[SC7280_LMX] = &lmx,\n\t[SC7280_MSS] = &mss,\n\t[SC7280_MX] = &mx,\n\t[SC7280_MX_AO] = &mx_ao,\n};\n\nstatic const struct rpmhpd_desc sc7280_desc = {\n\t.rpmhpds = sc7280_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sc7280_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sc8180x_rpmhpds[] = {\n\t[SC8180X_CX] = &cx_w_mx_parent,\n\t[SC8180X_CX_AO] = &cx_ao_w_mx_parent,\n\t[SC8180X_EBI] = &ebi,\n\t[SC8180X_GFX] = &gfx,\n\t[SC8180X_LCX] = &lcx,\n\t[SC8180X_LMX] = &lmx,\n\t[SC8180X_MMCX] = &mmcx,\n\t[SC8180X_MMCX_AO] = &mmcx_ao,\n\t[SC8180X_MSS] = &mss,\n\t[SC8180X_MX] = &mx,\n\t[SC8180X_MX_AO] = &mx_ao,\n};\n\nstatic const struct rpmhpd_desc sc8180x_desc = {\n\t.rpmhpds = sc8180x_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sc8180x_rpmhpds),\n};\n\n \nstatic struct rpmhpd *sc8280xp_rpmhpds[] = {\n\t[SC8280XP_CX] = &cx,\n\t[SC8280XP_CX_AO] = &cx_ao,\n\t[SC8280XP_EBI] = &ebi,\n\t[SC8280XP_GFX] = &gfx,\n\t[SC8280XP_LCX] = &lcx,\n\t[SC8280XP_LMX] = &lmx,\n\t[SC8280XP_MMCX] = &mmcx,\n\t[SC8280XP_MMCX_AO] = &mmcx_ao,\n\t[SC8280XP_MX] = &mx,\n\t[SC8280XP_MX_AO] = &mx_ao,\n\t[SC8280XP_NSP] = &nsp,\n\t[SC8280XP_QPHY] = &qphy,\n};\n\nstatic const struct rpmhpd_desc sc8280xp_desc = {\n\t.rpmhpds = sc8280xp_rpmhpds,\n\t.num_pds = ARRAY_SIZE(sc8280xp_rpmhpds),\n};\n\nstatic const struct of_device_id rpmhpd_match_table[] = {\n\t{ .compatible = \"qcom,qdu1000-rpmhpd\", .data = &qdu1000_desc },\n\t{ .compatible = \"qcom,sa8155p-rpmhpd\", .data = &sa8155p_desc },\n\t{ .compatible = \"qcom,sa8540p-rpmhpd\", .data = &sa8540p_desc },\n\t{ .compatible = \"qcom,sa8775p-rpmhpd\", .data = &sa8775p_desc },\n\t{ .compatible = \"qcom,sc7180-rpmhpd\", .data = &sc7180_desc },\n\t{ .compatible = \"qcom,sc7280-rpmhpd\", .data = &sc7280_desc },\n\t{ .compatible = \"qcom,sc8180x-rpmhpd\", .data = &sc8180x_desc },\n\t{ .compatible = \"qcom,sc8280xp-rpmhpd\", .data = &sc8280xp_desc },\n\t{ .compatible = \"qcom,sdm670-rpmhpd\", .data = &sdm670_desc },\n\t{ .compatible = \"qcom,sdm845-rpmhpd\", .data = &sdm845_desc },\n\t{ .compatible = \"qcom,sdx55-rpmhpd\", .data = &sdx55_desc},\n\t{ .compatible = \"qcom,sdx65-rpmhpd\", .data = &sdx65_desc},\n\t{ .compatible = \"qcom,sdx75-rpmhpd\", .data = &sdx75_desc},\n\t{ .compatible = \"qcom,sm6350-rpmhpd\", .data = &sm6350_desc },\n\t{ .compatible = \"qcom,sm8150-rpmhpd\", .data = &sm8150_desc },\n\t{ .compatible = \"qcom,sm8250-rpmhpd\", .data = &sm8250_desc },\n\t{ .compatible = \"qcom,sm8350-rpmhpd\", .data = &sm8350_desc },\n\t{ .compatible = \"qcom,sm8450-rpmhpd\", .data = &sm8450_desc },\n\t{ .compatible = \"qcom,sm8550-rpmhpd\", .data = &sm8550_desc },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rpmhpd_match_table);\n\nstatic int rpmhpd_send_corner(struct rpmhpd *pd, int state,\n\t\t\t      unsigned int corner, bool sync)\n{\n\tstruct tcs_cmd cmd = {\n\t\t.addr = pd->addr,\n\t\t.data = corner,\n\t};\n\n\t \n\tif (sync)\n\t\treturn rpmh_write(pd->dev, state, &cmd, 1);\n\telse\n\t\treturn rpmh_write_async(pd->dev, state, &cmd, 1);\n}\n\nstatic void to_active_sleep(struct rpmhpd *pd, unsigned int corner,\n\t\t\t    unsigned int *active, unsigned int *sleep)\n{\n\t*active = corner;\n\n\tif (pd->active_only)\n\t\t*sleep = 0;\n\telse\n\t\t*sleep = *active;\n}\n\n \nstatic int rpmhpd_aggregate_corner(struct rpmhpd *pd, unsigned int corner)\n{\n\tint ret;\n\tstruct rpmhpd *peer = pd->peer;\n\tunsigned int active_corner, sleep_corner;\n\tunsigned int this_active_corner = 0, this_sleep_corner = 0;\n\tunsigned int peer_active_corner = 0, peer_sleep_corner = 0;\n\n\tif (pd->state_synced) {\n\t\tto_active_sleep(pd, corner, &this_active_corner, &this_sleep_corner);\n\t} else {\n\t\t \n\t\tthis_active_corner = pd->level_count - 1;\n\t\tthis_sleep_corner = pd->level_count - 1;\n\t}\n\n\tif (peer && peer->enabled)\n\t\tto_active_sleep(peer, peer->corner, &peer_active_corner,\n\t\t\t\t&peer_sleep_corner);\n\n\tactive_corner = max(this_active_corner, peer_active_corner);\n\n\tret = rpmhpd_send_corner(pd, RPMH_ACTIVE_ONLY_STATE, active_corner,\n\t\t\t\t active_corner > pd->active_corner);\n\tif (ret)\n\t\treturn ret;\n\n\tpd->active_corner = active_corner;\n\n\tif (peer) {\n\t\tpeer->active_corner = active_corner;\n\n\t\tret = rpmhpd_send_corner(pd, RPMH_WAKE_ONLY_STATE,\n\t\t\t\t\t active_corner, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsleep_corner = max(this_sleep_corner, peer_sleep_corner);\n\n\t\treturn rpmhpd_send_corner(pd, RPMH_SLEEP_STATE, sleep_corner,\n\t\t\t\t\t  false);\n\t}\n\n\treturn ret;\n}\n\nstatic int rpmhpd_power_on(struct generic_pm_domain *domain)\n{\n\tstruct rpmhpd *pd = domain_to_rpmhpd(domain);\n\tunsigned int corner;\n\tint ret;\n\n\tmutex_lock(&rpmhpd_lock);\n\n\tcorner = max(pd->corner, pd->enable_corner);\n\tret = rpmhpd_aggregate_corner(pd, corner);\n\tif (!ret)\n\t\tpd->enabled = true;\n\n\tmutex_unlock(&rpmhpd_lock);\n\n\treturn ret;\n}\n\nstatic int rpmhpd_power_off(struct generic_pm_domain *domain)\n{\n\tstruct rpmhpd *pd = domain_to_rpmhpd(domain);\n\tint ret;\n\n\tmutex_lock(&rpmhpd_lock);\n\n\tret = rpmhpd_aggregate_corner(pd, 0);\n\tif (!ret)\n\t\tpd->enabled = false;\n\n\tmutex_unlock(&rpmhpd_lock);\n\n\treturn ret;\n}\n\nstatic int rpmhpd_set_performance_state(struct generic_pm_domain *domain,\n\t\t\t\t\tunsigned int level)\n{\n\tstruct rpmhpd *pd = domain_to_rpmhpd(domain);\n\tint ret = 0, i;\n\n\tmutex_lock(&rpmhpd_lock);\n\n\tfor (i = 0; i < pd->level_count; i++)\n\t\tif (level <= pd->level[i])\n\t\t\tbreak;\n\n\t \n\tif (i == pd->level_count)\n\t\ti--;\n\n\tif (pd->enabled) {\n\t\t \n\t\tif (i < pd->enable_corner)\n\t\t\ti = pd->enable_corner;\n\n\t\tret = rpmhpd_aggregate_corner(pd, i);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tpd->corner = i;\nout:\n\tmutex_unlock(&rpmhpd_lock);\n\n\treturn ret;\n}\n\nstatic unsigned int rpmhpd_get_performance_state(struct generic_pm_domain *genpd,\n\t\t\t\t\t\t struct dev_pm_opp *opp)\n{\n\treturn dev_pm_opp_get_level(opp);\n}\n\nstatic int rpmhpd_update_level_mapping(struct rpmhpd *rpmhpd)\n{\n\tint i;\n\tconst u16 *buf;\n\n\tbuf = cmd_db_read_aux_data(rpmhpd->res_name, &rpmhpd->level_count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\t \n\trpmhpd->level_count >>= 1;\n\n\tif (rpmhpd->level_count > RPMH_ARC_MAX_LEVELS)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < rpmhpd->level_count; i++) {\n\t\trpmhpd->level[i] = buf[i];\n\n\t\t \n\t\tif (!rpmhpd->level[rpmhpd->enable_corner] && rpmhpd->level[i])\n\t\t\trpmhpd->enable_corner = i;\n\n\t\t \n\t\tif (i > 0 && rpmhpd->level[i] == 0) {\n\t\t\trpmhpd->level_count = i;\n\t\t\tbreak;\n\t\t}\n\t\tpr_debug(\"%s: ARC hlvl=%2d --> vlvl=%4u\\n\", rpmhpd->res_name, i,\n\t\t\t rpmhpd->level[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int rpmhpd_probe(struct platform_device *pdev)\n{\n\tint i, ret;\n\tsize_t num_pds;\n\tstruct device *dev = &pdev->dev;\n\tstruct genpd_onecell_data *data;\n\tstruct rpmhpd **rpmhpds;\n\tconst struct rpmhpd_desc *desc;\n\n\tdesc = of_device_get_match_data(dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\trpmhpds = desc->rpmhpds;\n\tnum_pds = desc->num_pds;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->domains = devm_kcalloc(dev, num_pds, sizeof(*data->domains),\n\t\t\t\t     GFP_KERNEL);\n\tif (!data->domains)\n\t\treturn -ENOMEM;\n\n\tdata->num_domains = num_pds;\n\n\tfor (i = 0; i < num_pds; i++) {\n\t\tif (!rpmhpds[i])\n\t\t\tcontinue;\n\n\t\trpmhpds[i]->dev = dev;\n\t\trpmhpds[i]->addr = cmd_db_read_addr(rpmhpds[i]->res_name);\n\t\tif (!rpmhpds[i]->addr) {\n\t\t\tdev_err(dev, \"Could not find RPMh address for resource %s\\n\",\n\t\t\t\trpmhpds[i]->res_name);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tret = cmd_db_read_slave_id(rpmhpds[i]->res_name);\n\t\tif (ret != CMD_DB_HW_ARC) {\n\t\t\tdev_err(dev, \"RPMh slave ID mismatch\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = rpmhpd_update_level_mapping(rpmhpds[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trpmhpds[i]->pd.power_off = rpmhpd_power_off;\n\t\trpmhpds[i]->pd.power_on = rpmhpd_power_on;\n\t\trpmhpds[i]->pd.set_performance_state = rpmhpd_set_performance_state;\n\t\trpmhpds[i]->pd.opp_to_performance_state = rpmhpd_get_performance_state;\n\t\tpm_genpd_init(&rpmhpds[i]->pd, NULL, true);\n\n\t\tdata->domains[i] = &rpmhpds[i]->pd;\n\t}\n\n\t \n\tfor (i = 0; i < num_pds; i++) {\n\t\tif (!rpmhpds[i])\n\t\t\tcontinue;\n\t\tif (rpmhpds[i]->parent)\n\t\t\tpm_genpd_add_subdomain(rpmhpds[i]->parent,\n\t\t\t\t\t       &rpmhpds[i]->pd);\n\t}\n\n\treturn of_genpd_add_provider_onecell(pdev->dev.of_node, data);\n}\n\nstatic void rpmhpd_sync_state(struct device *dev)\n{\n\tconst struct rpmhpd_desc *desc = of_device_get_match_data(dev);\n\tstruct rpmhpd **rpmhpds = desc->rpmhpds;\n\tunsigned int corner;\n\tstruct rpmhpd *pd;\n\tunsigned int i;\n\tint ret;\n\n\tmutex_lock(&rpmhpd_lock);\n\tfor (i = 0; i < desc->num_pds; i++) {\n\t\tpd = rpmhpds[i];\n\t\tif (!pd)\n\t\t\tcontinue;\n\n\t\tpd->state_synced = true;\n\t\tif (pd->enabled)\n\t\t\tcorner = max(pd->corner, pd->enable_corner);\n\t\telse\n\t\t\tcorner = 0;\n\n\t\tret = rpmhpd_aggregate_corner(pd, corner);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"failed to sync %s\\n\", pd->res_name);\n\t}\n\tmutex_unlock(&rpmhpd_lock);\n}\n\nstatic struct platform_driver rpmhpd_driver = {\n\t.driver = {\n\t\t.name = \"qcom-rpmhpd\",\n\t\t.of_match_table = rpmhpd_match_table,\n\t\t.suppress_bind_attrs = true,\n\t\t.sync_state = rpmhpd_sync_state,\n\t},\n\t.probe = rpmhpd_probe,\n};\n\nstatic int __init rpmhpd_init(void)\n{\n\treturn platform_driver_register(&rpmhpd_driver);\n}\ncore_initcall(rpmhpd_init);\n\nMODULE_DESCRIPTION(\"Qualcomm Technologies, Inc. RPMh Power Domain Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}