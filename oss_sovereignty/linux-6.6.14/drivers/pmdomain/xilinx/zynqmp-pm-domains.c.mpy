{
  "module_name": "zynqmp-pm-domains.c",
  "hash_id": "7eceb149d4a766515de90e5b1221b57a4c42cd8407354a70ec383800d362e767",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/xilinx/zynqmp-pm-domains.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/slab.h>\n\n#include <linux/firmware/xlnx-zynqmp.h>\n\n#define ZYNQMP_NUM_DOMAINS\t\t(100)\n\nstatic int min_capability;\n\n \nstruct zynqmp_pm_domain {\n\tstruct generic_pm_domain gpd;\n\tu32 node_id;\n\tbool requested;\n};\n\n#define to_zynqmp_pm_domain(pm_domain) \\\n\tcontainer_of(pm_domain, struct zynqmp_pm_domain, gpd)\n\n \nstatic int zynqmp_gpd_is_active_wakeup_path(struct device *dev, void *not_used)\n{\n\tint may_wakeup;\n\n\tmay_wakeup = device_may_wakeup(dev);\n\tif (may_wakeup)\n\t\treturn may_wakeup;\n\n\treturn device_for_each_child(dev, NULL,\n\t\t\tzynqmp_gpd_is_active_wakeup_path);\n}\n\n \nstatic int zynqmp_gpd_power_on(struct generic_pm_domain *domain)\n{\n\tstruct zynqmp_pm_domain *pd = to_zynqmp_pm_domain(domain);\n\tint ret;\n\n\tret = zynqmp_pm_set_requirement(pd->node_id,\n\t\t\t\t\tZYNQMP_PM_CAPABILITY_ACCESS,\n\t\t\t\t\tZYNQMP_PM_MAX_QOS,\n\t\t\t\t\tZYNQMP_PM_REQUEST_ACK_BLOCKING);\n\tif (ret) {\n\t\tdev_err(&domain->dev,\n\t\t\t\"failed to set requirement to 0x%x for PM node id %d: %d\\n\",\n\t\t\tZYNQMP_PM_CAPABILITY_ACCESS, pd->node_id, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&domain->dev, \"set requirement to 0x%x for PM node id %d\\n\",\n\t\tZYNQMP_PM_CAPABILITY_ACCESS, pd->node_id);\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_gpd_power_off(struct generic_pm_domain *domain)\n{\n\tstruct zynqmp_pm_domain *pd = to_zynqmp_pm_domain(domain);\n\tint ret;\n\tstruct pm_domain_data *pdd, *tmp;\n\tu32 capabilities = min_capability;\n\tbool may_wakeup;\n\n\t \n\tif (!pd->requested) {\n\t\tdev_dbg(&domain->dev, \"PM node id %d is already released\\n\",\n\t\t\tpd->node_id);\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry_safe(pdd, tmp, &domain->dev_list, list_node) {\n\t\t \n\t\tmay_wakeup = zynqmp_gpd_is_active_wakeup_path(pdd->dev, NULL);\n\t\tif (may_wakeup) {\n\t\t\tdev_dbg(pdd->dev, \"device is in wakeup path in %s\\n\",\n\t\t\t\tdomain->name);\n\t\t\tcapabilities = ZYNQMP_PM_CAPABILITY_WAKEUP;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = zynqmp_pm_set_requirement(pd->node_id, capabilities, 0,\n\t\t\t\t\tZYNQMP_PM_REQUEST_ACK_NO);\n\tif (ret) {\n\t\tdev_err(&domain->dev,\n\t\t\t\"failed to set requirement to 0x%x for PM node id %d: %d\\n\",\n\t\t\tcapabilities, pd->node_id, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&domain->dev, \"set requirement to 0x%x for PM node id %d\\n\",\n\t\tcapabilities, pd->node_id);\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_gpd_attach_dev(struct generic_pm_domain *domain,\n\t\t\t\t struct device *dev)\n{\n\tstruct zynqmp_pm_domain *pd = to_zynqmp_pm_domain(domain);\n\tstruct device_link *link;\n\tint ret;\n\n\tlink = device_link_add(dev, &domain->dev, DL_FLAG_SYNC_STATE_ONLY);\n\tif (!link)\n\t\tdev_dbg(&domain->dev, \"failed to create device link for %s\\n\",\n\t\t\tdev_name(dev));\n\n\t \n\tif (domain->device_count)\n\t\treturn 0;\n\n\tret = zynqmp_pm_request_node(pd->node_id, 0, 0,\n\t\t\t\t     ZYNQMP_PM_REQUEST_ACK_BLOCKING);\n\tif (ret) {\n\t\tdev_err(&domain->dev, \"%s request failed for node %d: %d\\n\",\n\t\t\tdomain->name, pd->node_id, ret);\n\t\treturn ret;\n\t}\n\n\tpd->requested = true;\n\n\tdev_dbg(&domain->dev, \"%s requested PM node id %d\\n\",\n\t\tdev_name(dev), pd->node_id);\n\n\treturn 0;\n}\n\n \nstatic void zynqmp_gpd_detach_dev(struct generic_pm_domain *domain,\n\t\t\t\t  struct device *dev)\n{\n\tstruct zynqmp_pm_domain *pd = to_zynqmp_pm_domain(domain);\n\tint ret;\n\n\t \n\tif (domain->device_count)\n\t\treturn;\n\n\tret = zynqmp_pm_release_node(pd->node_id);\n\tif (ret) {\n\t\tdev_err(&domain->dev, \"failed to release PM node id %d: %d\\n\",\n\t\t\tpd->node_id, ret);\n\t\treturn;\n\t}\n\n\tpd->requested = false;\n\n\tdev_dbg(&domain->dev, \"%s released PM node id %d\\n\",\n\t\tdev_name(dev), pd->node_id);\n}\n\nstatic struct generic_pm_domain *zynqmp_gpd_xlate\n\t\t\t\t(struct of_phandle_args *genpdspec, void *data)\n{\n\tstruct genpd_onecell_data *genpd_data = data;\n\tunsigned int i, idx = genpdspec->args[0];\n\tstruct zynqmp_pm_domain *pd;\n\n\tpd = to_zynqmp_pm_domain(genpd_data->domains[0]);\n\n\tif (genpdspec->args_count != 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tfor (i = 0; i < ZYNQMP_NUM_DOMAINS; i++) {\n\t\tif (pd[i].node_id == idx)\n\t\t\tgoto done;\n\t}\n\n\t \n\tfor (i = 0; i < ZYNQMP_NUM_DOMAINS; i++) {\n\t\tif (pd[i].node_id == 0) {\n\t\t\tpd[i].node_id = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tif (!genpd_data->domains[i] || i == ZYNQMP_NUM_DOMAINS)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn genpd_data->domains[i];\n}\n\nstatic int zynqmp_gpd_probe(struct platform_device *pdev)\n{\n\tint i;\n\tstruct genpd_onecell_data *zynqmp_pd_data;\n\tstruct generic_pm_domain **domains;\n\tstruct zynqmp_pm_domain *pd;\n\tstruct device *dev = &pdev->dev;\n\n\tpd = devm_kcalloc(dev, ZYNQMP_NUM_DOMAINS, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tzynqmp_pd_data = devm_kzalloc(dev, sizeof(*zynqmp_pd_data), GFP_KERNEL);\n\tif (!zynqmp_pd_data)\n\t\treturn -ENOMEM;\n\n\tzynqmp_pd_data->xlate = zynqmp_gpd_xlate;\n\n\tdomains = devm_kcalloc(dev, ZYNQMP_NUM_DOMAINS, sizeof(*domains),\n\t\t\t       GFP_KERNEL);\n\tif (!domains)\n\t\treturn -ENOMEM;\n\n\tif (!of_device_is_compatible(dev->parent->of_node,\n\t\t\t\t     \"xlnx,zynqmp-firmware\"))\n\t\tmin_capability = ZYNQMP_PM_CAPABILITY_UNUSABLE;\n\n\tfor (i = 0; i < ZYNQMP_NUM_DOMAINS; i++, pd++) {\n\t\tpd->node_id = 0;\n\t\tpd->gpd.name = kasprintf(GFP_KERNEL, \"domain%d\", i);\n\t\tpd->gpd.power_off = zynqmp_gpd_power_off;\n\t\tpd->gpd.power_on = zynqmp_gpd_power_on;\n\t\tpd->gpd.attach_dev = zynqmp_gpd_attach_dev;\n\t\tpd->gpd.detach_dev = zynqmp_gpd_detach_dev;\n\n\t\tdomains[i] = &pd->gpd;\n\n\t\t \n\t\tpm_genpd_init(&pd->gpd, NULL, true);\n\t}\n\n\tzynqmp_pd_data->domains = domains;\n\tzynqmp_pd_data->num_domains = ZYNQMP_NUM_DOMAINS;\n\tof_genpd_add_provider_onecell(dev->parent->of_node, zynqmp_pd_data);\n\n\treturn 0;\n}\n\nstatic int zynqmp_gpd_remove(struct platform_device *pdev)\n{\n\tof_genpd_del_provider(pdev->dev.parent->of_node);\n\n\treturn 0;\n}\n\nstatic void zynqmp_gpd_sync_state(struct device *dev)\n{\n\tint ret;\n\n\tret = zynqmp_pm_init_finalize();\n\tif (ret)\n\t\tdev_warn(dev, \"failed to release power management to firmware\\n\");\n}\n\nstatic struct platform_driver zynqmp_power_domain_driver = {\n\t.driver\t= {\n\t\t.name = \"zynqmp_power_controller\",\n\t\t.sync_state = zynqmp_gpd_sync_state,\n\t},\n\t.probe = zynqmp_gpd_probe,\n\t.remove = zynqmp_gpd_remove,\n};\nmodule_platform_driver(zynqmp_power_domain_driver);\n\nMODULE_ALIAS(\"platform:zynqmp_power_controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}