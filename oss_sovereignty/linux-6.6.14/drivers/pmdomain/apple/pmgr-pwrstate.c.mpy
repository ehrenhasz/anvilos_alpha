{
  "module_name": "pmgr-pwrstate.c",
  "hash_id": "7c750ec657908bf1e4354dfc9aa0bf1659c38aeaa81568a60eca37bddd02ad7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/apple/pmgr-pwrstate.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/reset-controller.h>\n#include <linux/module.h>\n\n#define APPLE_PMGR_RESET        BIT(31)\n#define APPLE_PMGR_AUTO_ENABLE  BIT(28)\n#define APPLE_PMGR_PS_AUTO      GENMASK(27, 24)\n#define APPLE_PMGR_PS_MIN       GENMASK(19, 16)\n#define APPLE_PMGR_PARENT_OFF   BIT(11)\n#define APPLE_PMGR_DEV_DISABLE  BIT(10)\n#define APPLE_PMGR_WAS_CLKGATED BIT(9)\n#define APPLE_PMGR_WAS_PWRGATED BIT(8)\n#define APPLE_PMGR_PS_ACTUAL    GENMASK(7, 4)\n#define APPLE_PMGR_PS_TARGET    GENMASK(3, 0)\n\n#define APPLE_PMGR_FLAGS        (APPLE_PMGR_WAS_CLKGATED | APPLE_PMGR_WAS_PWRGATED)\n\n#define APPLE_PMGR_PS_ACTIVE    0xf\n#define APPLE_PMGR_PS_CLKGATE   0x4\n#define APPLE_PMGR_PS_PWRGATE   0x0\n\n#define APPLE_PMGR_PS_SET_TIMEOUT 100\n#define APPLE_PMGR_RESET_TIME 1\n\nstruct apple_pmgr_ps {\n\tstruct device *dev;\n\tstruct generic_pm_domain genpd;\n\tstruct reset_controller_dev rcdev;\n\tstruct regmap *regmap;\n\tu32 offset;\n\tu32 min_state;\n};\n\n#define genpd_to_apple_pmgr_ps(_genpd) container_of(_genpd, struct apple_pmgr_ps, genpd)\n#define rcdev_to_apple_pmgr_ps(_rcdev) container_of(_rcdev, struct apple_pmgr_ps, rcdev)\n\nstatic int apple_pmgr_ps_set(struct generic_pm_domain *genpd, u32 pstate, bool auto_enable)\n{\n\tint ret;\n\tstruct apple_pmgr_ps *ps = genpd_to_apple_pmgr_ps(genpd);\n\tu32 reg;\n\n\tret = regmap_read(ps->regmap, ps->offset, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (reg & APPLE_PMGR_RESET && pstate != APPLE_PMGR_PS_ACTIVE)\n\t\tdev_err(ps->dev, \"PS %s: powering off with RESET active\\n\",\n\t\t\tgenpd->name);\n\n\treg &= ~(APPLE_PMGR_AUTO_ENABLE | APPLE_PMGR_FLAGS | APPLE_PMGR_PS_TARGET);\n\treg |= FIELD_PREP(APPLE_PMGR_PS_TARGET, pstate);\n\n\tdev_dbg(ps->dev, \"PS %s: pwrstate = 0x%x: 0x%x\\n\", genpd->name, pstate, reg);\n\n\tregmap_write(ps->regmap, ps->offset, reg);\n\n\tret = regmap_read_poll_timeout_atomic(\n\t\tps->regmap, ps->offset, reg,\n\t\t(FIELD_GET(APPLE_PMGR_PS_ACTUAL, reg) == pstate), 1,\n\t\tAPPLE_PMGR_PS_SET_TIMEOUT);\n\tif (ret < 0)\n\t\tdev_err(ps->dev, \"PS %s: Failed to reach power state 0x%x (now: 0x%x)\\n\",\n\t\t\tgenpd->name, pstate, reg);\n\n\tif (auto_enable) {\n\t\t \n\t\treg &= ~APPLE_PMGR_FLAGS;\n\t\treg |= APPLE_PMGR_AUTO_ENABLE;\n\t\tregmap_write(ps->regmap, ps->offset, reg);\n\t}\n\n\treturn ret;\n}\n\nstatic bool apple_pmgr_ps_is_active(struct apple_pmgr_ps *ps)\n{\n\tu32 reg = 0;\n\n\tregmap_read(ps->regmap, ps->offset, &reg);\n\t \n\treturn (FIELD_GET(APPLE_PMGR_PS_ACTUAL, reg) == APPLE_PMGR_PS_ACTIVE ||\n\t\t(FIELD_GET(APPLE_PMGR_PS_TARGET, reg) == APPLE_PMGR_PS_ACTIVE &&\n\t\t reg & APPLE_PMGR_AUTO_ENABLE));\n}\n\nstatic int apple_pmgr_ps_power_on(struct generic_pm_domain *genpd)\n{\n\treturn apple_pmgr_ps_set(genpd, APPLE_PMGR_PS_ACTIVE, true);\n}\n\nstatic int apple_pmgr_ps_power_off(struct generic_pm_domain *genpd)\n{\n\treturn apple_pmgr_ps_set(genpd, APPLE_PMGR_PS_PWRGATE, false);\n}\n\nstatic int apple_pmgr_reset_assert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tstruct apple_pmgr_ps *ps = rcdev_to_apple_pmgr_ps(rcdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ps->genpd.slock, flags);\n\n\tif (ps->genpd.status == GENPD_STATE_OFF)\n\t\tdev_err(ps->dev, \"PS 0x%x: asserting RESET while powered down\\n\", ps->offset);\n\n\tdev_dbg(ps->dev, \"PS 0x%x: assert reset\\n\", ps->offset);\n\t \n\tregmap_update_bits(ps->regmap, ps->offset, APPLE_PMGR_FLAGS | APPLE_PMGR_DEV_DISABLE,\n\t\t\t   APPLE_PMGR_DEV_DISABLE);\n\tregmap_update_bits(ps->regmap, ps->offset, APPLE_PMGR_FLAGS | APPLE_PMGR_RESET,\n\t\t\t   APPLE_PMGR_RESET);\n\n\tspin_unlock_irqrestore(&ps->genpd.slock, flags);\n\n\treturn 0;\n}\n\nstatic int apple_pmgr_reset_deassert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tstruct apple_pmgr_ps *ps = rcdev_to_apple_pmgr_ps(rcdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ps->genpd.slock, flags);\n\n\tdev_dbg(ps->dev, \"PS 0x%x: deassert reset\\n\", ps->offset);\n\tregmap_update_bits(ps->regmap, ps->offset, APPLE_PMGR_FLAGS | APPLE_PMGR_RESET, 0);\n\tregmap_update_bits(ps->regmap, ps->offset, APPLE_PMGR_FLAGS | APPLE_PMGR_DEV_DISABLE, 0);\n\n\tif (ps->genpd.status == GENPD_STATE_OFF)\n\t\tdev_err(ps->dev, \"PS 0x%x: RESET was deasserted while powered down\\n\", ps->offset);\n\n\tspin_unlock_irqrestore(&ps->genpd.slock, flags);\n\n\treturn 0;\n}\n\nstatic int apple_pmgr_reset_reset(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tint ret;\n\n\tret = apple_pmgr_reset_assert(rcdev, id);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(APPLE_PMGR_RESET_TIME, 2 * APPLE_PMGR_RESET_TIME);\n\n\treturn apple_pmgr_reset_deassert(rcdev, id);\n}\n\nstatic int apple_pmgr_reset_status(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tstruct apple_pmgr_ps *ps = rcdev_to_apple_pmgr_ps(rcdev);\n\tu32 reg = 0;\n\n\tregmap_read(ps->regmap, ps->offset, &reg);\n\n\treturn !!(reg & APPLE_PMGR_RESET);\n}\n\nconst struct reset_control_ops apple_pmgr_reset_ops = {\n\t.assert\t\t= apple_pmgr_reset_assert,\n\t.deassert\t= apple_pmgr_reset_deassert,\n\t.reset\t\t= apple_pmgr_reset_reset,\n\t.status\t\t= apple_pmgr_reset_status,\n};\n\nstatic int apple_pmgr_reset_xlate(struct reset_controller_dev *rcdev,\n\t\t\t\t  const struct of_phandle_args *reset_spec)\n{\n\treturn 0;\n}\n\nstatic int apple_pmgr_ps_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct apple_pmgr_ps *ps;\n\tstruct regmap *regmap;\n\tstruct of_phandle_iterator it;\n\tint ret;\n\tconst char *name;\n\tbool active;\n\n\tregmap = syscon_node_to_regmap(node->parent);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tps = devm_kzalloc(dev, sizeof(*ps), GFP_KERNEL);\n\tif (!ps)\n\t\treturn -ENOMEM;\n\n\tps->dev = dev;\n\tps->regmap = regmap;\n\n\tret = of_property_read_string(node, \"label\", &name);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing label property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(node, \"reg\", &ps->offset);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing reg property\\n\");\n\t\treturn ret;\n\t}\n\n\tps->genpd.flags |= GENPD_FLAG_IRQ_SAFE;\n\tps->genpd.name = name;\n\tps->genpd.power_on = apple_pmgr_ps_power_on;\n\tps->genpd.power_off = apple_pmgr_ps_power_off;\n\n\tret = of_property_read_u32(node, \"apple,min-state\", &ps->min_state);\n\tif (ret == 0 && ps->min_state <= APPLE_PMGR_PS_ACTIVE)\n\t\tregmap_update_bits(regmap, ps->offset, APPLE_PMGR_FLAGS | APPLE_PMGR_PS_MIN,\n\t\t\t\t   FIELD_PREP(APPLE_PMGR_PS_MIN, ps->min_state));\n\n\tactive = apple_pmgr_ps_is_active(ps);\n\tif (of_property_read_bool(node, \"apple,always-on\")) {\n\t\tps->genpd.flags |= GENPD_FLAG_ALWAYS_ON;\n\t\tif (!active) {\n\t\t\tdev_warn(dev, \"always-on domain %s is not on at boot\\n\", name);\n\t\t\t \n\t\t\tactive = apple_pmgr_ps_power_on(&ps->genpd) == 0;\n\t\t}\n\t}\n\n\t \n\tif (active)\n\t\tregmap_update_bits(regmap, ps->offset, APPLE_PMGR_FLAGS | APPLE_PMGR_AUTO_ENABLE,\n\t\t\t\t   APPLE_PMGR_AUTO_ENABLE);\n\n\tret = pm_genpd_init(&ps->genpd, NULL, !active);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pm_genpd_init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_genpd_add_provider_simple(node, &ps->genpd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"of_genpd_add_provider_simple failed\\n\");\n\t\treturn ret;\n\t}\n\n\tof_for_each_phandle(&it, ret, node, \"power-domains\", \"#power-domain-cells\", -1) {\n\t\tstruct of_phandle_args parent, child;\n\n\t\tparent.np = it.node;\n\t\tparent.args_count = of_phandle_iterator_args(&it, parent.args, MAX_PHANDLE_ARGS);\n\t\tchild.np = node;\n\t\tchild.args_count = 0;\n\t\tret = of_genpd_add_subdomain(&parent, &child);\n\n\t\tif (ret == -EPROBE_DEFER) {\n\t\t\tof_node_put(parent.np);\n\t\t\tgoto err_remove;\n\t\t} else if (ret < 0) {\n\t\t\tdev_err(dev, \"failed to add to parent domain: %d (%s -> %s)\\n\",\n\t\t\t\tret, it.node->name, node->name);\n\t\t\tof_node_put(parent.np);\n\t\t\tgoto err_remove;\n\t\t}\n\t}\n\n\t \n\tpm_genpd_remove_device(dev);\n\n\tps->rcdev.owner = THIS_MODULE;\n\tps->rcdev.nr_resets = 1;\n\tps->rcdev.ops = &apple_pmgr_reset_ops;\n\tps->rcdev.of_node = dev->of_node;\n\tps->rcdev.of_reset_n_cells = 0;\n\tps->rcdev.of_xlate = apple_pmgr_reset_xlate;\n\n\tret = devm_reset_controller_register(dev, &ps->rcdev);\n\tif (ret < 0)\n\t\tgoto err_remove;\n\n\treturn 0;\nerr_remove:\n\tof_genpd_del_provider(node);\n\tpm_genpd_remove(&ps->genpd);\n\treturn ret;\n}\n\nstatic const struct of_device_id apple_pmgr_ps_of_match[] = {\n\t{ .compatible = \"apple,pmgr-pwrstate\" },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, apple_pmgr_ps_of_match);\n\nstatic struct platform_driver apple_pmgr_ps_driver = {\n\t.probe = apple_pmgr_ps_probe,\n\t.driver = {\n\t\t.name = \"apple-pmgr-pwrstate\",\n\t\t.of_match_table = apple_pmgr_ps_of_match,\n\t},\n};\n\nMODULE_AUTHOR(\"Hector Martin <marcan@marcan.st>\");\nMODULE_DESCRIPTION(\"PMGR power state driver for Apple SoCs\");\n\nmodule_platform_driver(apple_pmgr_ps_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}