{
  "module_name": "pm-domains.c",
  "hash_id": "9a005679020a7b520d4c892b1d434ba582c15488953af6fc59113335e8002e3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/rockchip/pm-domains.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_domain.h>\n#include <linux/of_address.h>\n#include <linux/of_clk.h>\n#include <linux/of_platform.h>\n#include <linux/clk.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <soc/rockchip/pm_domains.h>\n#include <dt-bindings/power/px30-power.h>\n#include <dt-bindings/power/rockchip,rv1126-power.h>\n#include <dt-bindings/power/rk3036-power.h>\n#include <dt-bindings/power/rk3066-power.h>\n#include <dt-bindings/power/rk3128-power.h>\n#include <dt-bindings/power/rk3188-power.h>\n#include <dt-bindings/power/rk3228-power.h>\n#include <dt-bindings/power/rk3288-power.h>\n#include <dt-bindings/power/rk3328-power.h>\n#include <dt-bindings/power/rk3366-power.h>\n#include <dt-bindings/power/rk3368-power.h>\n#include <dt-bindings/power/rk3399-power.h>\n#include <dt-bindings/power/rk3568-power.h>\n#include <dt-bindings/power/rk3588-power.h>\n\nstruct rockchip_domain_info {\n\tconst char *name;\n\tint pwr_mask;\n\tint status_mask;\n\tint req_mask;\n\tint idle_mask;\n\tint ack_mask;\n\tbool active_wakeup;\n\tint pwr_w_mask;\n\tint req_w_mask;\n\tint mem_status_mask;\n\tint repair_status_mask;\n\tu32 pwr_offset;\n\tu32 mem_offset;\n\tu32 req_offset;\n};\n\nstruct rockchip_pmu_info {\n\tu32 pwr_offset;\n\tu32 status_offset;\n\tu32 req_offset;\n\tu32 idle_offset;\n\tu32 ack_offset;\n\tu32 mem_pwr_offset;\n\tu32 chain_status_offset;\n\tu32 mem_status_offset;\n\tu32 repair_status_offset;\n\n\tu32 core_pwrcnt_offset;\n\tu32 gpu_pwrcnt_offset;\n\n\tunsigned int core_power_transition_time;\n\tunsigned int gpu_power_transition_time;\n\n\tint num_domains;\n\tconst struct rockchip_domain_info *domain_info;\n};\n\n#define MAX_QOS_REGS_NUM\t5\n#define QOS_PRIORITY\t\t0x08\n#define QOS_MODE\t\t0x0c\n#define QOS_BANDWIDTH\t\t0x10\n#define QOS_SATURATION\t\t0x14\n#define QOS_EXTCONTROL\t\t0x18\n\nstruct rockchip_pm_domain {\n\tstruct generic_pm_domain genpd;\n\tconst struct rockchip_domain_info *info;\n\tstruct rockchip_pmu *pmu;\n\tint num_qos;\n\tstruct regmap **qos_regmap;\n\tu32 *qos_save_regs[MAX_QOS_REGS_NUM];\n\tint num_clks;\n\tstruct clk_bulk_data *clks;\n};\n\nstruct rockchip_pmu {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tconst struct rockchip_pmu_info *info;\n\tstruct mutex mutex;  \n\tstruct genpd_onecell_data genpd_data;\n\tstruct generic_pm_domain *domains[];\n};\n\n#define to_rockchip_pd(gpd) container_of(gpd, struct rockchip_pm_domain, genpd)\n\n#define DOMAIN(_name, pwr, status, req, idle, ack, wakeup)\t\\\n{\t\t\t\t\t\t\t\\\n\t.name = _name,\t\t\t\t\\\n\t.pwr_mask = (pwr),\t\t\t\t\\\n\t.status_mask = (status),\t\t\t\\\n\t.req_mask = (req),\t\t\t\t\\\n\t.idle_mask = (idle),\t\t\t\t\\\n\t.ack_mask = (ack),\t\t\t\t\\\n\t.active_wakeup = (wakeup),\t\t\t\\\n}\n\n#define DOMAIN_M(_name, pwr, status, req, idle, ack, wakeup)\t\\\n{\t\t\t\t\t\t\t\\\n\t.name = _name,\t\t\t\t\\\n\t.pwr_w_mask = (pwr) << 16,\t\t\t\\\n\t.pwr_mask = (pwr),\t\t\t\t\\\n\t.status_mask = (status),\t\t\t\\\n\t.req_w_mask = (req) << 16,\t\t\t\\\n\t.req_mask = (req),\t\t\t\t\\\n\t.idle_mask = (idle),\t\t\t\t\\\n\t.ack_mask = (ack),\t\t\t\t\\\n\t.active_wakeup = wakeup,\t\t\t\\\n}\n\n#define DOMAIN_M_O_R(_name, p_offset, pwr, status, m_offset, m_status, r_status, r_offset, req, idle, ack, wakeup)\t\\\n{\t\t\t\t\t\t\t\\\n\t.name = _name,\t\t\t\t\t\\\n\t.pwr_offset = p_offset,\t\t\t\t\\\n\t.pwr_w_mask = (pwr) << 16,\t\t\t\\\n\t.pwr_mask = (pwr),\t\t\t\t\\\n\t.status_mask = (status),\t\t\t\\\n\t.mem_offset = m_offset,\t\t\t\t\\\n\t.mem_status_mask = (m_status),\t\t\t\\\n\t.repair_status_mask = (r_status),\t\t\\\n\t.req_offset = r_offset,\t\t\t\t\\\n\t.req_w_mask = (req) << 16,\t\t\t\\\n\t.req_mask = (req),\t\t\t\t\\\n\t.idle_mask = (idle),\t\t\t\t\\\n\t.ack_mask = (ack),\t\t\t\t\\\n\t.active_wakeup = wakeup,\t\t\t\\\n}\n\n#define DOMAIN_RK3036(_name, req, ack, idle, wakeup)\t\t\\\n{\t\t\t\t\t\t\t\\\n\t.name = _name,\t\t\t\t\\\n\t.req_mask = (req),\t\t\t\t\\\n\t.req_w_mask = (req) << 16,\t\t\t\\\n\t.ack_mask = (ack),\t\t\t\t\\\n\t.idle_mask = (idle),\t\t\t\t\\\n\t.active_wakeup = wakeup,\t\t\t\\\n}\n\n#define DOMAIN_PX30(name, pwr, status, req, wakeup)\t\t\\\n\tDOMAIN_M(name, pwr, status, req, (req) << 16, req, wakeup)\n\n#define DOMAIN_RV1126(name, pwr, req, idle, wakeup)\t\t\\\n\tDOMAIN_M(name, pwr, pwr, req, idle, idle, wakeup)\n\n#define DOMAIN_RK3288(name, pwr, status, req, wakeup)\t\t\\\n\tDOMAIN(name, pwr, status, req, req, (req) << 16, wakeup)\n\n#define DOMAIN_RK3328(name, pwr, status, req, wakeup)\t\t\\\n\tDOMAIN_M(name, pwr, pwr, req, (req) << 10, req, wakeup)\n\n#define DOMAIN_RK3368(name, pwr, status, req, wakeup)\t\t\\\n\tDOMAIN(name, pwr, status, req, (req) << 16, req, wakeup)\n\n#define DOMAIN_RK3399(name, pwr, status, req, wakeup)\t\t\\\n\tDOMAIN(name, pwr, status, req, req, req, wakeup)\n\n#define DOMAIN_RK3568(name, pwr, req, wakeup)\t\t\\\n\tDOMAIN_M(name, pwr, pwr, req, req, req, wakeup)\n\n \nstatic DEFINE_MUTEX(dmc_pmu_mutex);\nstatic struct rockchip_pmu *dmc_pmu;\n\n \nint rockchip_pmu_block(void)\n{\n\tstruct rockchip_pmu *pmu;\n\tstruct generic_pm_domain *genpd;\n\tstruct rockchip_pm_domain *pd;\n\tint i, ret;\n\n\tmutex_lock(&dmc_pmu_mutex);\n\n\t \n\tif (!dmc_pmu)\n\t\treturn 0;\n\tpmu = dmc_pmu;\n\n\t \n\tmutex_lock(&pmu->mutex);\n\n\t \n\tfor (i = 0; i < pmu->genpd_data.num_domains; i++) {\n\t\tgenpd = pmu->genpd_data.domains[i];\n\t\tif (genpd) {\n\t\t\tpd = to_rockchip_pd(genpd);\n\t\t\tret = clk_bulk_enable(pd->num_clks, pd->clks);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(pmu->dev,\n\t\t\t\t\t\"failed to enable clks for domain '%s': %d\\n\",\n\t\t\t\t\tgenpd->name, ret);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = i - 1; i >= 0; i--) {\n\t\tgenpd = pmu->genpd_data.domains[i];\n\t\tif (genpd) {\n\t\t\tpd = to_rockchip_pd(genpd);\n\t\t\tclk_bulk_disable(pd->num_clks, pd->clks);\n\t\t}\n\t}\n\tmutex_unlock(&pmu->mutex);\n\tmutex_unlock(&dmc_pmu_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rockchip_pmu_block);\n\n \nvoid rockchip_pmu_unblock(void)\n{\n\tstruct rockchip_pmu *pmu;\n\tstruct generic_pm_domain *genpd;\n\tstruct rockchip_pm_domain *pd;\n\tint i;\n\n\tif (dmc_pmu) {\n\t\tpmu = dmc_pmu;\n\t\tfor (i = 0; i < pmu->genpd_data.num_domains; i++) {\n\t\t\tgenpd = pmu->genpd_data.domains[i];\n\t\t\tif (genpd) {\n\t\t\t\tpd = to_rockchip_pd(genpd);\n\t\t\t\tclk_bulk_disable(pd->num_clks, pd->clks);\n\t\t\t}\n\t\t}\n\n\t\tmutex_unlock(&pmu->mutex);\n\t}\n\n\tmutex_unlock(&dmc_pmu_mutex);\n}\nEXPORT_SYMBOL_GPL(rockchip_pmu_unblock);\n\n#define DOMAIN_RK3588(name, p_offset, pwr, status, m_offset, m_status, r_status, r_offset, req, idle, wakeup)\t\\\n\tDOMAIN_M_O_R(name, p_offset, pwr, status, m_offset, m_status, r_status, r_offset, req, idle, idle, wakeup)\n\nstatic bool rockchip_pmu_domain_is_idle(struct rockchip_pm_domain *pd)\n{\n\tstruct rockchip_pmu *pmu = pd->pmu;\n\tconst struct rockchip_domain_info *pd_info = pd->info;\n\tunsigned int val;\n\n\tregmap_read(pmu->regmap, pmu->info->idle_offset, &val);\n\treturn (val & pd_info->idle_mask) == pd_info->idle_mask;\n}\n\nstatic unsigned int rockchip_pmu_read_ack(struct rockchip_pmu *pmu)\n{\n\tunsigned int val;\n\n\tregmap_read(pmu->regmap, pmu->info->ack_offset, &val);\n\treturn val;\n}\n\nstatic int rockchip_pmu_set_idle_request(struct rockchip_pm_domain *pd,\n\t\t\t\t\t bool idle)\n{\n\tconst struct rockchip_domain_info *pd_info = pd->info;\n\tstruct generic_pm_domain *genpd = &pd->genpd;\n\tstruct rockchip_pmu *pmu = pd->pmu;\n\tu32 pd_req_offset = pd_info->req_offset;\n\tunsigned int target_ack;\n\tunsigned int val;\n\tbool is_idle;\n\tint ret;\n\n\tif (pd_info->req_mask == 0)\n\t\treturn 0;\n\telse if (pd_info->req_w_mask)\n\t\tregmap_write(pmu->regmap, pmu->info->req_offset + pd_req_offset,\n\t\t\t     idle ? (pd_info->req_mask | pd_info->req_w_mask) :\n\t\t\t     pd_info->req_w_mask);\n\telse\n\t\tregmap_update_bits(pmu->regmap, pmu->info->req_offset + pd_req_offset,\n\t\t\t\t   pd_info->req_mask, idle ? -1U : 0);\n\n\twmb();\n\n\t \n\ttarget_ack = idle ? pd_info->ack_mask : 0;\n\tret = readx_poll_timeout_atomic(rockchip_pmu_read_ack, pmu, val,\n\t\t\t\t\t(val & pd_info->ack_mask) == target_ack,\n\t\t\t\t\t0, 10000);\n\tif (ret) {\n\t\tdev_err(pmu->dev,\n\t\t\t\"failed to get ack on domain '%s', val=0x%x\\n\",\n\t\t\tgenpd->name, val);\n\t\treturn ret;\n\t}\n\n\tret = readx_poll_timeout_atomic(rockchip_pmu_domain_is_idle, pd,\n\t\t\t\t\tis_idle, is_idle == idle, 0, 10000);\n\tif (ret) {\n\t\tdev_err(pmu->dev,\n\t\t\t\"failed to set idle on domain '%s', val=%d\\n\",\n\t\t\tgenpd->name, is_idle);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_pmu_save_qos(struct rockchip_pm_domain *pd)\n{\n\tint i;\n\n\tfor (i = 0; i < pd->num_qos; i++) {\n\t\tregmap_read(pd->qos_regmap[i],\n\t\t\t    QOS_PRIORITY,\n\t\t\t    &pd->qos_save_regs[0][i]);\n\t\tregmap_read(pd->qos_regmap[i],\n\t\t\t    QOS_MODE,\n\t\t\t    &pd->qos_save_regs[1][i]);\n\t\tregmap_read(pd->qos_regmap[i],\n\t\t\t    QOS_BANDWIDTH,\n\t\t\t    &pd->qos_save_regs[2][i]);\n\t\tregmap_read(pd->qos_regmap[i],\n\t\t\t    QOS_SATURATION,\n\t\t\t    &pd->qos_save_regs[3][i]);\n\t\tregmap_read(pd->qos_regmap[i],\n\t\t\t    QOS_EXTCONTROL,\n\t\t\t    &pd->qos_save_regs[4][i]);\n\t}\n\treturn 0;\n}\n\nstatic int rockchip_pmu_restore_qos(struct rockchip_pm_domain *pd)\n{\n\tint i;\n\n\tfor (i = 0; i < pd->num_qos; i++) {\n\t\tregmap_write(pd->qos_regmap[i],\n\t\t\t     QOS_PRIORITY,\n\t\t\t     pd->qos_save_regs[0][i]);\n\t\tregmap_write(pd->qos_regmap[i],\n\t\t\t     QOS_MODE,\n\t\t\t     pd->qos_save_regs[1][i]);\n\t\tregmap_write(pd->qos_regmap[i],\n\t\t\t     QOS_BANDWIDTH,\n\t\t\t     pd->qos_save_regs[2][i]);\n\t\tregmap_write(pd->qos_regmap[i],\n\t\t\t     QOS_SATURATION,\n\t\t\t     pd->qos_save_regs[3][i]);\n\t\tregmap_write(pd->qos_regmap[i],\n\t\t\t     QOS_EXTCONTROL,\n\t\t\t     pd->qos_save_regs[4][i]);\n\t}\n\n\treturn 0;\n}\n\nstatic bool rockchip_pmu_domain_is_on(struct rockchip_pm_domain *pd)\n{\n\tstruct rockchip_pmu *pmu = pd->pmu;\n\tunsigned int val;\n\n\tif (pd->info->repair_status_mask) {\n\t\tregmap_read(pmu->regmap, pmu->info->repair_status_offset, &val);\n\t\t \n\t\treturn val & pd->info->repair_status_mask;\n\t}\n\n\t \n\tif (pd->info->status_mask == 0)\n\t\treturn !rockchip_pmu_domain_is_idle(pd);\n\n\tregmap_read(pmu->regmap, pmu->info->status_offset, &val);\n\n\t \n\treturn !(val & pd->info->status_mask);\n}\n\nstatic bool rockchip_pmu_domain_is_mem_on(struct rockchip_pm_domain *pd)\n{\n\tstruct rockchip_pmu *pmu = pd->pmu;\n\tunsigned int val;\n\n\tregmap_read(pmu->regmap,\n\t\t    pmu->info->mem_status_offset + pd->info->mem_offset, &val);\n\n\t \n\treturn !(val & pd->info->mem_status_mask);\n}\n\nstatic bool rockchip_pmu_domain_is_chain_on(struct rockchip_pm_domain *pd)\n{\n\tstruct rockchip_pmu *pmu = pd->pmu;\n\tunsigned int val;\n\n\tregmap_read(pmu->regmap,\n\t\t    pmu->info->chain_status_offset + pd->info->mem_offset, &val);\n\n\t \n\treturn val & pd->info->mem_status_mask;\n}\n\nstatic int rockchip_pmu_domain_mem_reset(struct rockchip_pm_domain *pd)\n{\n\tstruct rockchip_pmu *pmu = pd->pmu;\n\tstruct generic_pm_domain *genpd = &pd->genpd;\n\tbool is_on;\n\tint ret = 0;\n\n\tret = readx_poll_timeout_atomic(rockchip_pmu_domain_is_chain_on, pd, is_on,\n\t\t\t\t\tis_on == true, 0, 10000);\n\tif (ret) {\n\t\tdev_err(pmu->dev,\n\t\t\t\"failed to get chain status '%s', target_on=1, val=%d\\n\",\n\t\t\tgenpd->name, is_on);\n\t\tgoto error;\n\t}\n\n\tudelay(20);\n\n\tregmap_write(pmu->regmap, pmu->info->mem_pwr_offset + pd->info->pwr_offset,\n\t\t     (pd->info->pwr_mask | pd->info->pwr_w_mask));\n\twmb();\n\n\tret = readx_poll_timeout_atomic(rockchip_pmu_domain_is_mem_on, pd, is_on,\n\t\t\t\t\tis_on == false, 0, 10000);\n\tif (ret) {\n\t\tdev_err(pmu->dev,\n\t\t\t\"failed to get mem status '%s', target_on=0, val=%d\\n\",\n\t\t\tgenpd->name, is_on);\n\t\tgoto error;\n\t}\n\n\tregmap_write(pmu->regmap, pmu->info->mem_pwr_offset + pd->info->pwr_offset,\n\t\t     pd->info->pwr_w_mask);\n\twmb();\n\n\tret = readx_poll_timeout_atomic(rockchip_pmu_domain_is_mem_on, pd, is_on,\n\t\t\t\t\tis_on == true, 0, 10000);\n\tif (ret) {\n\t\tdev_err(pmu->dev,\n\t\t\t\"failed to get mem status '%s', target_on=1, val=%d\\n\",\n\t\t\tgenpd->name, is_on);\n\t}\n\nerror:\n\treturn ret;\n}\n\nstatic void rockchip_do_pmu_set_power_domain(struct rockchip_pm_domain *pd,\n\t\t\t\t\t     bool on)\n{\n\tstruct rockchip_pmu *pmu = pd->pmu;\n\tstruct generic_pm_domain *genpd = &pd->genpd;\n\tu32 pd_pwr_offset = pd->info->pwr_offset;\n\tbool is_on, is_mem_on = false;\n\n\tif (pd->info->pwr_mask == 0)\n\t\treturn;\n\n\tif (on && pd->info->mem_status_mask)\n\t\tis_mem_on = rockchip_pmu_domain_is_mem_on(pd);\n\n\tif (pd->info->pwr_w_mask)\n\t\tregmap_write(pmu->regmap, pmu->info->pwr_offset + pd_pwr_offset,\n\t\t\t     on ? pd->info->pwr_w_mask :\n\t\t\t     (pd->info->pwr_mask | pd->info->pwr_w_mask));\n\telse\n\t\tregmap_update_bits(pmu->regmap, pmu->info->pwr_offset + pd_pwr_offset,\n\t\t\t\t   pd->info->pwr_mask, on ? 0 : -1U);\n\n\twmb();\n\n\tif (is_mem_on && rockchip_pmu_domain_mem_reset(pd))\n\t\treturn;\n\n\tif (readx_poll_timeout_atomic(rockchip_pmu_domain_is_on, pd, is_on,\n\t\t\t\t      is_on == on, 0, 10000)) {\n\t\tdev_err(pmu->dev,\n\t\t\t\"failed to set domain '%s', val=%d\\n\",\n\t\t\tgenpd->name, is_on);\n\t\treturn;\n\t}\n}\n\nstatic int rockchip_pd_power(struct rockchip_pm_domain *pd, bool power_on)\n{\n\tstruct rockchip_pmu *pmu = pd->pmu;\n\tint ret;\n\n\tmutex_lock(&pmu->mutex);\n\n\tif (rockchip_pmu_domain_is_on(pd) != power_on) {\n\t\tret = clk_bulk_enable(pd->num_clks, pd->clks);\n\t\tif (ret < 0) {\n\t\t\tdev_err(pmu->dev, \"failed to enable clocks\\n\");\n\t\t\tmutex_unlock(&pmu->mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!power_on) {\n\t\t\trockchip_pmu_save_qos(pd);\n\n\t\t\t \n\t\t\trockchip_pmu_set_idle_request(pd, true);\n\t\t}\n\n\t\trockchip_do_pmu_set_power_domain(pd, power_on);\n\n\t\tif (power_on) {\n\t\t\t \n\t\t\trockchip_pmu_set_idle_request(pd, false);\n\n\t\t\trockchip_pmu_restore_qos(pd);\n\t\t}\n\n\t\tclk_bulk_disable(pd->num_clks, pd->clks);\n\t}\n\n\tmutex_unlock(&pmu->mutex);\n\treturn 0;\n}\n\nstatic int rockchip_pd_power_on(struct generic_pm_domain *domain)\n{\n\tstruct rockchip_pm_domain *pd = to_rockchip_pd(domain);\n\n\treturn rockchip_pd_power(pd, true);\n}\n\nstatic int rockchip_pd_power_off(struct generic_pm_domain *domain)\n{\n\tstruct rockchip_pm_domain *pd = to_rockchip_pd(domain);\n\n\treturn rockchip_pd_power(pd, false);\n}\n\nstatic int rockchip_pd_attach_dev(struct generic_pm_domain *genpd,\n\t\t\t\t  struct device *dev)\n{\n\tstruct clk *clk;\n\tint i;\n\tint error;\n\n\tdev_dbg(dev, \"attaching to power domain '%s'\\n\", genpd->name);\n\n\terror = pm_clk_create(dev);\n\tif (error) {\n\t\tdev_err(dev, \"pm_clk_create failed %d\\n\", error);\n\t\treturn error;\n\t}\n\n\ti = 0;\n\twhile ((clk = of_clk_get(dev->of_node, i++)) && !IS_ERR(clk)) {\n\t\tdev_dbg(dev, \"adding clock '%pC' to list of PM clocks\\n\", clk);\n\t\terror = pm_clk_add_clk(dev, clk);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"pm_clk_add_clk failed %d\\n\", error);\n\t\t\tclk_put(clk);\n\t\t\tpm_clk_destroy(dev);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void rockchip_pd_detach_dev(struct generic_pm_domain *genpd,\n\t\t\t\t   struct device *dev)\n{\n\tdev_dbg(dev, \"detaching from power domain '%s'\\n\", genpd->name);\n\n\tpm_clk_destroy(dev);\n}\n\nstatic int rockchip_pm_add_one_domain(struct rockchip_pmu *pmu,\n\t\t\t\t      struct device_node *node)\n{\n\tconst struct rockchip_domain_info *pd_info;\n\tstruct rockchip_pm_domain *pd;\n\tstruct device_node *qos_node;\n\tint i, j;\n\tu32 id;\n\tint error;\n\n\terror = of_property_read_u32(node, \"reg\", &id);\n\tif (error) {\n\t\tdev_err(pmu->dev,\n\t\t\t\"%pOFn: failed to retrieve domain id (reg): %d\\n\",\n\t\t\tnode, error);\n\t\treturn -EINVAL;\n\t}\n\n\tif (id >= pmu->info->num_domains) {\n\t\tdev_err(pmu->dev, \"%pOFn: invalid domain id %d\\n\",\n\t\t\tnode, id);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (pmu->genpd_data.domains[id])\n\t\treturn 0;\n\n\tpd_info = &pmu->info->domain_info[id];\n\tif (!pd_info) {\n\t\tdev_err(pmu->dev, \"%pOFn: undefined domain id %d\\n\",\n\t\t\tnode, id);\n\t\treturn -EINVAL;\n\t}\n\n\tpd = devm_kzalloc(pmu->dev, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tpd->info = pd_info;\n\tpd->pmu = pmu;\n\n\tpd->num_clks = of_clk_get_parent_count(node);\n\tif (pd->num_clks > 0) {\n\t\tpd->clks = devm_kcalloc(pmu->dev, pd->num_clks,\n\t\t\t\t\tsizeof(*pd->clks), GFP_KERNEL);\n\t\tif (!pd->clks)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tdev_dbg(pmu->dev, \"%pOFn: doesn't have clocks: %d\\n\",\n\t\t\tnode, pd->num_clks);\n\t\tpd->num_clks = 0;\n\t}\n\n\tfor (i = 0; i < pd->num_clks; i++) {\n\t\tpd->clks[i].clk = of_clk_get(node, i);\n\t\tif (IS_ERR(pd->clks[i].clk)) {\n\t\t\terror = PTR_ERR(pd->clks[i].clk);\n\t\t\tdev_err(pmu->dev,\n\t\t\t\t\"%pOFn: failed to get clk at index %d: %d\\n\",\n\t\t\t\tnode, i, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = clk_bulk_prepare(pd->num_clks, pd->clks);\n\tif (error)\n\t\tgoto err_put_clocks;\n\n\tpd->num_qos = of_count_phandle_with_args(node, \"pm_qos\",\n\t\t\t\t\t\t NULL);\n\n\tif (pd->num_qos > 0) {\n\t\tpd->qos_regmap = devm_kcalloc(pmu->dev, pd->num_qos,\n\t\t\t\t\t      sizeof(*pd->qos_regmap),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!pd->qos_regmap) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto err_unprepare_clocks;\n\t\t}\n\n\t\tfor (j = 0; j < MAX_QOS_REGS_NUM; j++) {\n\t\t\tpd->qos_save_regs[j] = devm_kcalloc(pmu->dev,\n\t\t\t\t\t\t\t    pd->num_qos,\n\t\t\t\t\t\t\t    sizeof(u32),\n\t\t\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (!pd->qos_save_regs[j]) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto err_unprepare_clocks;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < pd->num_qos; j++) {\n\t\t\tqos_node = of_parse_phandle(node, \"pm_qos\", j);\n\t\t\tif (!qos_node) {\n\t\t\t\terror = -ENODEV;\n\t\t\t\tgoto err_unprepare_clocks;\n\t\t\t}\n\t\t\tpd->qos_regmap[j] = syscon_node_to_regmap(qos_node);\n\t\t\tif (IS_ERR(pd->qos_regmap[j])) {\n\t\t\t\terror = -ENODEV;\n\t\t\t\tof_node_put(qos_node);\n\t\t\t\tgoto err_unprepare_clocks;\n\t\t\t}\n\t\t\tof_node_put(qos_node);\n\t\t}\n\t}\n\n\tif (pd->info->name)\n\t\tpd->genpd.name = pd->info->name;\n\telse\n\t\tpd->genpd.name = kbasename(node->full_name);\n\tpd->genpd.power_off = rockchip_pd_power_off;\n\tpd->genpd.power_on = rockchip_pd_power_on;\n\tpd->genpd.attach_dev = rockchip_pd_attach_dev;\n\tpd->genpd.detach_dev = rockchip_pd_detach_dev;\n\tpd->genpd.flags = GENPD_FLAG_PM_CLK;\n\tif (pd_info->active_wakeup)\n\t\tpd->genpd.flags |= GENPD_FLAG_ACTIVE_WAKEUP;\n\tpm_genpd_init(&pd->genpd, NULL,\n\t\t      !rockchip_pmu_domain_is_on(pd) ||\n\t\t      (pd->info->mem_status_mask && !rockchip_pmu_domain_is_mem_on(pd)));\n\n\tpmu->genpd_data.domains[id] = &pd->genpd;\n\treturn 0;\n\nerr_unprepare_clocks:\n\tclk_bulk_unprepare(pd->num_clks, pd->clks);\nerr_put_clocks:\n\tclk_bulk_put(pd->num_clks, pd->clks);\n\treturn error;\n}\n\nstatic void rockchip_pm_remove_one_domain(struct rockchip_pm_domain *pd)\n{\n\tint ret;\n\n\t \n\tret = pm_genpd_remove(&pd->genpd);\n\tif (ret < 0)\n\t\tdev_err(pd->pmu->dev, \"failed to remove domain '%s' : %d - state may be inconsistent\\n\",\n\t\t\tpd->genpd.name, ret);\n\n\tclk_bulk_unprepare(pd->num_clks, pd->clks);\n\tclk_bulk_put(pd->num_clks, pd->clks);\n\n\t \n\tmutex_lock(&pd->pmu->mutex);\n\tpd->num_clks = 0;\n\tmutex_unlock(&pd->pmu->mutex);\n\n\t \n}\n\nstatic void rockchip_pm_domain_cleanup(struct rockchip_pmu *pmu)\n{\n\tstruct generic_pm_domain *genpd;\n\tstruct rockchip_pm_domain *pd;\n\tint i;\n\n\tfor (i = 0; i < pmu->genpd_data.num_domains; i++) {\n\t\tgenpd = pmu->genpd_data.domains[i];\n\t\tif (genpd) {\n\t\t\tpd = to_rockchip_pd(genpd);\n\t\t\trockchip_pm_remove_one_domain(pd);\n\t\t}\n\t}\n\n\t \n}\n\nstatic void rockchip_configure_pd_cnt(struct rockchip_pmu *pmu,\n\t\t\t\t      u32 domain_reg_offset,\n\t\t\t\t      unsigned int count)\n{\n\t \n\tregmap_write(pmu->regmap, domain_reg_offset, count);\n\t \n\tregmap_write(pmu->regmap, domain_reg_offset + 4, count);\n}\n\nstatic int rockchip_pm_add_subdomain(struct rockchip_pmu *pmu,\n\t\t\t\t     struct device_node *parent)\n{\n\tstruct device_node *np;\n\tstruct generic_pm_domain *child_domain, *parent_domain;\n\tint error;\n\n\tfor_each_child_of_node(parent, np) {\n\t\tu32 idx;\n\n\t\terror = of_property_read_u32(parent, \"reg\", &idx);\n\t\tif (error) {\n\t\t\tdev_err(pmu->dev,\n\t\t\t\t\"%pOFn: failed to retrieve domain id (reg): %d\\n\",\n\t\t\t\tparent, error);\n\t\t\tgoto err_out;\n\t\t}\n\t\tparent_domain = pmu->genpd_data.domains[idx];\n\n\t\terror = rockchip_pm_add_one_domain(pmu, np);\n\t\tif (error) {\n\t\t\tdev_err(pmu->dev, \"failed to handle node %pOFn: %d\\n\",\n\t\t\t\tnp, error);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\terror = of_property_read_u32(np, \"reg\", &idx);\n\t\tif (error) {\n\t\t\tdev_err(pmu->dev,\n\t\t\t\t\"%pOFn: failed to retrieve domain id (reg): %d\\n\",\n\t\t\t\tnp, error);\n\t\t\tgoto err_out;\n\t\t}\n\t\tchild_domain = pmu->genpd_data.domains[idx];\n\n\t\terror = pm_genpd_add_subdomain(parent_domain, child_domain);\n\t\tif (error) {\n\t\t\tdev_err(pmu->dev, \"%s failed to add subdomain %s: %d\\n\",\n\t\t\t\tparent_domain->name, child_domain->name, error);\n\t\t\tgoto err_out;\n\t\t} else {\n\t\t\tdev_dbg(pmu->dev, \"%s add subdomain: %s\\n\",\n\t\t\t\tparent_domain->name, child_domain->name);\n\t\t}\n\n\t\trockchip_pm_add_subdomain(pmu, np);\n\t}\n\n\treturn 0;\n\nerr_out:\n\tof_node_put(np);\n\treturn error;\n}\n\nstatic int rockchip_pm_domain_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *node;\n\tstruct device *parent;\n\tstruct rockchip_pmu *pmu;\n\tconst struct of_device_id *match;\n\tconst struct rockchip_pmu_info *pmu_info;\n\tint error;\n\n\tif (!np) {\n\t\tdev_err(dev, \"device tree node not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmatch = of_match_device(dev->driver->of_match_table, dev);\n\tif (!match || !match->data) {\n\t\tdev_err(dev, \"missing pmu data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpmu_info = match->data;\n\n\tpmu = devm_kzalloc(dev,\n\t\t\t   struct_size(pmu, domains, pmu_info->num_domains),\n\t\t\t   GFP_KERNEL);\n\tif (!pmu)\n\t\treturn -ENOMEM;\n\n\tpmu->dev = &pdev->dev;\n\tmutex_init(&pmu->mutex);\n\n\tpmu->info = pmu_info;\n\n\tpmu->genpd_data.domains = pmu->domains;\n\tpmu->genpd_data.num_domains = pmu_info->num_domains;\n\n\tparent = dev->parent;\n\tif (!parent) {\n\t\tdev_err(dev, \"no parent for syscon devices\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpmu->regmap = syscon_node_to_regmap(parent->of_node);\n\tif (IS_ERR(pmu->regmap)) {\n\t\tdev_err(dev, \"no regmap available\\n\");\n\t\treturn PTR_ERR(pmu->regmap);\n\t}\n\n\t \n\tif (pmu_info->core_power_transition_time)\n\t\trockchip_configure_pd_cnt(pmu, pmu_info->core_pwrcnt_offset,\n\t\t\t\t\tpmu_info->core_power_transition_time);\n\tif (pmu_info->gpu_pwrcnt_offset)\n\t\trockchip_configure_pd_cnt(pmu, pmu_info->gpu_pwrcnt_offset,\n\t\t\t\t\tpmu_info->gpu_power_transition_time);\n\n\terror = -ENODEV;\n\n\t \n\tmutex_lock(&dmc_pmu_mutex);\n\n\tfor_each_available_child_of_node(np, node) {\n\t\terror = rockchip_pm_add_one_domain(pmu, node);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"failed to handle node %pOFn: %d\\n\",\n\t\t\t\tnode, error);\n\t\t\tof_node_put(node);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\terror = rockchip_pm_add_subdomain(pmu, node);\n\t\tif (error < 0) {\n\t\t\tdev_err(dev, \"failed to handle subdomain node %pOFn: %d\\n\",\n\t\t\t\tnode, error);\n\t\t\tof_node_put(node);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (error) {\n\t\tdev_dbg(dev, \"no power domains defined\\n\");\n\t\tgoto err_out;\n\t}\n\n\terror = of_genpd_add_provider_onecell(np, &pmu->genpd_data);\n\tif (error) {\n\t\tdev_err(dev, \"failed to add provider: %d\\n\", error);\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (!WARN_ON_ONCE(dmc_pmu))\n\t\tdmc_pmu = pmu;\n\n\tmutex_unlock(&dmc_pmu_mutex);\n\n\treturn 0;\n\nerr_out:\n\trockchip_pm_domain_cleanup(pmu);\n\tmutex_unlock(&dmc_pmu_mutex);\n\treturn error;\n}\n\nstatic const struct rockchip_domain_info px30_pm_domains[] = {\n\t[PX30_PD_USB]\t\t= DOMAIN_PX30(\"usb\",      BIT(5),  BIT(5),  BIT(10), false),\n\t[PX30_PD_SDCARD]\t= DOMAIN_PX30(\"sdcard\",   BIT(8),  BIT(8),  BIT(9),  false),\n\t[PX30_PD_GMAC]\t\t= DOMAIN_PX30(\"gmac\",     BIT(10), BIT(10), BIT(6),  false),\n\t[PX30_PD_MMC_NAND]\t= DOMAIN_PX30(\"mmc_nand\", BIT(11), BIT(11), BIT(5),  false),\n\t[PX30_PD_VPU]\t\t= DOMAIN_PX30(\"vpu\",      BIT(12), BIT(12), BIT(14), false),\n\t[PX30_PD_VO]\t\t= DOMAIN_PX30(\"vo\",       BIT(13), BIT(13), BIT(7),  false),\n\t[PX30_PD_VI]\t\t= DOMAIN_PX30(\"vi\",       BIT(14), BIT(14), BIT(8),  false),\n\t[PX30_PD_GPU]\t\t= DOMAIN_PX30(\"gpu\",      BIT(15), BIT(15), BIT(2),  false),\n};\n\nstatic const struct rockchip_domain_info rv1126_pm_domains[] = {\n\t[RV1126_PD_VEPU]\t= DOMAIN_RV1126(\"vepu\", BIT(2),  BIT(9),  BIT(9), false),\n\t[RV1126_PD_VI]\t\t= DOMAIN_RV1126(\"vi\", BIT(4),  BIT(6),  BIT(6),  false),\n\t[RV1126_PD_VO]\t\t= DOMAIN_RV1126(\"vo\", BIT(5),  BIT(7),  BIT(7),  false),\n\t[RV1126_PD_ISPP]\t= DOMAIN_RV1126(\"ispp\", BIT(1), BIT(8), BIT(8),  false),\n\t[RV1126_PD_VDPU]\t= DOMAIN_RV1126(\"vdpu\", BIT(3), BIT(10), BIT(10), false),\n\t[RV1126_PD_NVM]\t\t= DOMAIN_RV1126(\"nvm\", BIT(7), BIT(11), BIT(11),  false),\n\t[RV1126_PD_SDIO]\t= DOMAIN_RV1126(\"sdio\", BIT(8), BIT(13), BIT(13),  false),\n\t[RV1126_PD_USB]\t\t= DOMAIN_RV1126(\"usb\", BIT(9), BIT(15), BIT(15),  false),\n};\n\nstatic const struct rockchip_domain_info rk3036_pm_domains[] = {\n\t[RK3036_PD_MSCH]\t= DOMAIN_RK3036(\"msch\", BIT(14), BIT(23), BIT(30), true),\n\t[RK3036_PD_CORE]\t= DOMAIN_RK3036(\"core\", BIT(13), BIT(17), BIT(24), false),\n\t[RK3036_PD_PERI]\t= DOMAIN_RK3036(\"peri\", BIT(12), BIT(18), BIT(25), false),\n\t[RK3036_PD_VIO]\t\t= DOMAIN_RK3036(\"vio\",  BIT(11), BIT(19), BIT(26), false),\n\t[RK3036_PD_VPU]\t\t= DOMAIN_RK3036(\"vpu\",  BIT(10), BIT(20), BIT(27), false),\n\t[RK3036_PD_GPU]\t\t= DOMAIN_RK3036(\"gpu\",  BIT(9),  BIT(21), BIT(28), false),\n\t[RK3036_PD_SYS]\t\t= DOMAIN_RK3036(\"sys\",  BIT(8),  BIT(22), BIT(29), false),\n};\n\nstatic const struct rockchip_domain_info rk3066_pm_domains[] = {\n\t[RK3066_PD_GPU]\t\t= DOMAIN(\"gpu\",   BIT(9), BIT(9), BIT(3), BIT(24), BIT(29), false),\n\t[RK3066_PD_VIDEO]\t= DOMAIN(\"video\", BIT(8), BIT(8), BIT(4), BIT(23), BIT(28), false),\n\t[RK3066_PD_VIO]\t\t= DOMAIN(\"vio\",   BIT(7), BIT(7), BIT(5), BIT(22), BIT(27), false),\n\t[RK3066_PD_PERI]\t= DOMAIN(\"peri\",  BIT(6), BIT(6), BIT(2), BIT(25), BIT(30), false),\n\t[RK3066_PD_CPU]\t\t= DOMAIN(\"cpu\",   0,      BIT(5), BIT(1), BIT(26), BIT(31), false),\n};\n\nstatic const struct rockchip_domain_info rk3128_pm_domains[] = {\n\t[RK3128_PD_CORE]\t= DOMAIN_RK3288(\"core\",  BIT(0), BIT(0), BIT(4), false),\n\t[RK3128_PD_MSCH]\t= DOMAIN_RK3288(\"msch\",  0,      0,      BIT(6), true),\n\t[RK3128_PD_VIO]\t\t= DOMAIN_RK3288(\"vio\",   BIT(3), BIT(3), BIT(2), false),\n\t[RK3128_PD_VIDEO]\t= DOMAIN_RK3288(\"video\", BIT(2), BIT(2), BIT(1), false),\n\t[RK3128_PD_GPU]\t\t= DOMAIN_RK3288(\"gpu\",   BIT(1), BIT(1), BIT(3), false),\n};\n\nstatic const struct rockchip_domain_info rk3188_pm_domains[] = {\n\t[RK3188_PD_GPU]\t\t= DOMAIN(\"gpu\",   BIT(9), BIT(9), BIT(3), BIT(24), BIT(29), false),\n\t[RK3188_PD_VIDEO]\t= DOMAIN(\"video\", BIT(8), BIT(8), BIT(4), BIT(23), BIT(28), false),\n\t[RK3188_PD_VIO]\t\t= DOMAIN(\"vio\",   BIT(7), BIT(7), BIT(5), BIT(22), BIT(27), false),\n\t[RK3188_PD_PERI]\t= DOMAIN(\"peri\",  BIT(6), BIT(6), BIT(2), BIT(25), BIT(30), false),\n\t[RK3188_PD_CPU]\t\t= DOMAIN(\"cpu\",   BIT(5), BIT(5), BIT(1), BIT(26), BIT(31), false),\n};\n\nstatic const struct rockchip_domain_info rk3228_pm_domains[] = {\n\t[RK3228_PD_CORE]\t= DOMAIN_RK3036(\"core\", BIT(0),  BIT(0),  BIT(16), true),\n\t[RK3228_PD_MSCH]\t= DOMAIN_RK3036(\"msch\", BIT(1),  BIT(1),  BIT(17), true),\n\t[RK3228_PD_BUS]\t\t= DOMAIN_RK3036(\"bus\",  BIT(2),  BIT(2),  BIT(18), true),\n\t[RK3228_PD_SYS]\t\t= DOMAIN_RK3036(\"sys\",  BIT(3),  BIT(3),  BIT(19), true),\n\t[RK3228_PD_VIO]\t\t= DOMAIN_RK3036(\"vio\",  BIT(4),  BIT(4),  BIT(20), false),\n\t[RK3228_PD_VOP]\t\t= DOMAIN_RK3036(\"vop\",  BIT(5),  BIT(5),  BIT(21), false),\n\t[RK3228_PD_VPU]\t\t= DOMAIN_RK3036(\"vpu\",  BIT(6),  BIT(6),  BIT(22), false),\n\t[RK3228_PD_RKVDEC]\t= DOMAIN_RK3036(\"vdec\", BIT(7),  BIT(7),  BIT(23), false),\n\t[RK3228_PD_GPU]\t\t= DOMAIN_RK3036(\"gpu\",  BIT(8),  BIT(8),  BIT(24), false),\n\t[RK3228_PD_PERI]\t= DOMAIN_RK3036(\"peri\", BIT(9),  BIT(9),  BIT(25), true),\n\t[RK3228_PD_GMAC]\t= DOMAIN_RK3036(\"gmac\", BIT(10), BIT(10), BIT(26), false),\n};\n\nstatic const struct rockchip_domain_info rk3288_pm_domains[] = {\n\t[RK3288_PD_VIO]\t\t= DOMAIN_RK3288(\"vio\",   BIT(7),  BIT(7),  BIT(4), false),\n\t[RK3288_PD_HEVC]\t= DOMAIN_RK3288(\"hevc\",  BIT(14), BIT(10), BIT(9), false),\n\t[RK3288_PD_VIDEO]\t= DOMAIN_RK3288(\"video\", BIT(8),  BIT(8),  BIT(3), false),\n\t[RK3288_PD_GPU]\t\t= DOMAIN_RK3288(\"gpu\",   BIT(9),  BIT(9),  BIT(2), false),\n};\n\nstatic const struct rockchip_domain_info rk3328_pm_domains[] = {\n\t[RK3328_PD_CORE]\t= DOMAIN_RK3328(\"core\",  0, BIT(0), BIT(0), false),\n\t[RK3328_PD_GPU]\t\t= DOMAIN_RK3328(\"gpu\",   0, BIT(1), BIT(1), false),\n\t[RK3328_PD_BUS]\t\t= DOMAIN_RK3328(\"bus\",   0, BIT(2), BIT(2), true),\n\t[RK3328_PD_MSCH]\t= DOMAIN_RK3328(\"msch\",  0, BIT(3), BIT(3), true),\n\t[RK3328_PD_PERI]\t= DOMAIN_RK3328(\"peri\",  0, BIT(4), BIT(4), true),\n\t[RK3328_PD_VIDEO]\t= DOMAIN_RK3328(\"video\", 0, BIT(5), BIT(5), false),\n\t[RK3328_PD_HEVC]\t= DOMAIN_RK3328(\"hevc\",  0, BIT(6), BIT(6), false),\n\t[RK3328_PD_VIO]\t\t= DOMAIN_RK3328(\"vio\",   0, BIT(8), BIT(8), false),\n\t[RK3328_PD_VPU]\t\t= DOMAIN_RK3328(\"vpu\",   0, BIT(9), BIT(9), false),\n};\n\nstatic const struct rockchip_domain_info rk3366_pm_domains[] = {\n\t[RK3366_PD_PERI]\t= DOMAIN_RK3368(\"peri\",   BIT(10), BIT(10), BIT(6), true),\n\t[RK3366_PD_VIO]\t\t= DOMAIN_RK3368(\"vio\",    BIT(14), BIT(14), BIT(8), false),\n\t[RK3366_PD_VIDEO]\t= DOMAIN_RK3368(\"video\",  BIT(13), BIT(13), BIT(7), false),\n\t[RK3366_PD_RKVDEC]\t= DOMAIN_RK3368(\"vdec\",   BIT(11), BIT(11), BIT(7), false),\n\t[RK3366_PD_WIFIBT]\t= DOMAIN_RK3368(\"wifibt\", BIT(8),  BIT(8),  BIT(9), false),\n\t[RK3366_PD_VPU]\t\t= DOMAIN_RK3368(\"vpu\",    BIT(12), BIT(12), BIT(7), false),\n\t[RK3366_PD_GPU]\t\t= DOMAIN_RK3368(\"gpu\",    BIT(15), BIT(15), BIT(2), false),\n};\n\nstatic const struct rockchip_domain_info rk3368_pm_domains[] = {\n\t[RK3368_PD_PERI]\t= DOMAIN_RK3368(\"peri\",  BIT(13), BIT(12), BIT(6), true),\n\t[RK3368_PD_VIO]\t\t= DOMAIN_RK3368(\"vio\",   BIT(15), BIT(14), BIT(8), false),\n\t[RK3368_PD_VIDEO]\t= DOMAIN_RK3368(\"video\", BIT(14), BIT(13), BIT(7), false),\n\t[RK3368_PD_GPU_0]\t= DOMAIN_RK3368(\"gpu_0\", BIT(16), BIT(15), BIT(2), false),\n\t[RK3368_PD_GPU_1]\t= DOMAIN_RK3368(\"gpu_1\", BIT(17), BIT(16), BIT(2), false),\n};\n\nstatic const struct rockchip_domain_info rk3399_pm_domains[] = {\n\t[RK3399_PD_TCPD0]\t= DOMAIN_RK3399(\"tcpd0\",     BIT(8),  BIT(8),  0,       false),\n\t[RK3399_PD_TCPD1]\t= DOMAIN_RK3399(\"tcpd1\",     BIT(9),  BIT(9),  0,       false),\n\t[RK3399_PD_CCI]\t\t= DOMAIN_RK3399(\"cci\",       BIT(10), BIT(10), 0,       true),\n\t[RK3399_PD_CCI0]\t= DOMAIN_RK3399(\"cci0\",      0,       0,       BIT(15), true),\n\t[RK3399_PD_CCI1]\t= DOMAIN_RK3399(\"cci1\",      0,       0,       BIT(16), true),\n\t[RK3399_PD_PERILP]\t= DOMAIN_RK3399(\"perilp\",    BIT(11), BIT(11), BIT(1),  true),\n\t[RK3399_PD_PERIHP]\t= DOMAIN_RK3399(\"perihp\",    BIT(12), BIT(12), BIT(2),  true),\n\t[RK3399_PD_CENTER]\t= DOMAIN_RK3399(\"center\",    BIT(13), BIT(13), BIT(14), true),\n\t[RK3399_PD_VIO]\t\t= DOMAIN_RK3399(\"vio\",       BIT(14), BIT(14), BIT(17), false),\n\t[RK3399_PD_GPU]\t\t= DOMAIN_RK3399(\"gpu\",       BIT(15), BIT(15), BIT(0),  false),\n\t[RK3399_PD_VCODEC]\t= DOMAIN_RK3399(\"vcodec\",    BIT(16), BIT(16), BIT(3),  false),\n\t[RK3399_PD_VDU]\t\t= DOMAIN_RK3399(\"vdu\",       BIT(17), BIT(17), BIT(4),  false),\n\t[RK3399_PD_RGA]\t\t= DOMAIN_RK3399(\"rga\",       BIT(18), BIT(18), BIT(5),  false),\n\t[RK3399_PD_IEP]\t\t= DOMAIN_RK3399(\"iep\",       BIT(19), BIT(19), BIT(6),  false),\n\t[RK3399_PD_VO]\t\t= DOMAIN_RK3399(\"vo\",        BIT(20), BIT(20), 0,       false),\n\t[RK3399_PD_VOPB]\t= DOMAIN_RK3399(\"vopb\",      0,       0,       BIT(7),  false),\n\t[RK3399_PD_VOPL]\t= DOMAIN_RK3399(\"vopl\",      0,       0,       BIT(8),  false),\n\t[RK3399_PD_ISP0]\t= DOMAIN_RK3399(\"isp0\",      BIT(22), BIT(22), BIT(9),  false),\n\t[RK3399_PD_ISP1]\t= DOMAIN_RK3399(\"isp1\",      BIT(23), BIT(23), BIT(10), false),\n\t[RK3399_PD_HDCP]\t= DOMAIN_RK3399(\"hdcp\",      BIT(24), BIT(24), BIT(11), false),\n\t[RK3399_PD_GMAC]\t= DOMAIN_RK3399(\"gmac\",      BIT(25), BIT(25), BIT(23), true),\n\t[RK3399_PD_EMMC]\t= DOMAIN_RK3399(\"emmc\",      BIT(26), BIT(26), BIT(24), true),\n\t[RK3399_PD_USB3]\t= DOMAIN_RK3399(\"usb3\",      BIT(27), BIT(27), BIT(12), true),\n\t[RK3399_PD_EDP]\t\t= DOMAIN_RK3399(\"edp\",       BIT(28), BIT(28), BIT(22), false),\n\t[RK3399_PD_GIC]\t\t= DOMAIN_RK3399(\"gic\",       BIT(29), BIT(29), BIT(27), true),\n\t[RK3399_PD_SD]\t\t= DOMAIN_RK3399(\"sd\",        BIT(30), BIT(30), BIT(28), true),\n\t[RK3399_PD_SDIOAUDIO]\t= DOMAIN_RK3399(\"sdioaudio\", BIT(31), BIT(31), BIT(29), true),\n};\n\nstatic const struct rockchip_domain_info rk3568_pm_domains[] = {\n\t[RK3568_PD_NPU]\t\t= DOMAIN_RK3568(\"npu\",  BIT(1), BIT(2),  false),\n\t[RK3568_PD_GPU]\t\t= DOMAIN_RK3568(\"gpu\",  BIT(0), BIT(1),  false),\n\t[RK3568_PD_VI]\t\t= DOMAIN_RK3568(\"vi\",   BIT(6), BIT(3),  false),\n\t[RK3568_PD_VO]\t\t= DOMAIN_RK3568(\"vo\",   BIT(7), BIT(4),  false),\n\t[RK3568_PD_RGA]\t\t= DOMAIN_RK3568(\"rga\",  BIT(5), BIT(5),  false),\n\t[RK3568_PD_VPU]\t\t= DOMAIN_RK3568(\"vpu\",  BIT(2), BIT(6),  false),\n\t[RK3568_PD_RKVDEC]\t= DOMAIN_RK3568(\"vdec\", BIT(4), BIT(8),  false),\n\t[RK3568_PD_RKVENC]\t= DOMAIN_RK3568(\"venc\", BIT(3), BIT(7),  false),\n\t[RK3568_PD_PIPE]\t= DOMAIN_RK3568(\"pipe\", BIT(8), BIT(11), false),\n};\n\nstatic const struct rockchip_domain_info rk3588_pm_domains[] = {\n\t[RK3588_PD_GPU]\t\t= DOMAIN_RK3588(\"gpu\",     0x0, BIT(0),  0,       0x0, 0,       BIT(1),  0x0, BIT(0),  BIT(0),  false),\n\t[RK3588_PD_NPU]\t\t= DOMAIN_RK3588(\"npu\",     0x0, BIT(1),  BIT(1),  0x0, 0,       0,       0x0, 0,       0,       false),\n\t[RK3588_PD_VCODEC]\t= DOMAIN_RK3588(\"vcodec\",  0x0, BIT(2),  BIT(2),  0x0, 0,       0,       0x0, 0,       0,       false),\n\t[RK3588_PD_NPUTOP]\t= DOMAIN_RK3588(\"nputop\",  0x0, BIT(3),  0,       0x0, BIT(11), BIT(2),  0x0, BIT(1),  BIT(1),  false),\n\t[RK3588_PD_NPU1]\t= DOMAIN_RK3588(\"npu1\",    0x0, BIT(4),  0,       0x0, BIT(12), BIT(3),  0x0, BIT(2),  BIT(2),  false),\n\t[RK3588_PD_NPU2]\t= DOMAIN_RK3588(\"npu2\",    0x0, BIT(5),  0,       0x0, BIT(13), BIT(4),  0x0, BIT(3),  BIT(3),  false),\n\t[RK3588_PD_VENC0]\t= DOMAIN_RK3588(\"venc0\",   0x0, BIT(6),  0,       0x0, BIT(14), BIT(5),  0x0, BIT(4),  BIT(4),  false),\n\t[RK3588_PD_VENC1]\t= DOMAIN_RK3588(\"venc1\",   0x0, BIT(7),  0,       0x0, BIT(15), BIT(6),  0x0, BIT(5),  BIT(5),  false),\n\t[RK3588_PD_RKVDEC0]\t= DOMAIN_RK3588(\"rkvdec0\", 0x0, BIT(8),  0,       0x0, BIT(16), BIT(7),  0x0, BIT(6),  BIT(6),  false),\n\t[RK3588_PD_RKVDEC1]\t= DOMAIN_RK3588(\"rkvdec1\", 0x0, BIT(9),  0,       0x0, BIT(17), BIT(8),  0x0, BIT(7),  BIT(7),  false),\n\t[RK3588_PD_VDPU]\t= DOMAIN_RK3588(\"vdpu\",    0x0, BIT(10), 0,       0x0, BIT(18), BIT(9),  0x0, BIT(8),  BIT(8),  false),\n\t[RK3588_PD_RGA30]\t= DOMAIN_RK3588(\"rga30\",   0x0, BIT(11), 0,       0x0, BIT(19), BIT(10), 0x0, 0,       0,       false),\n\t[RK3588_PD_AV1]\t\t= DOMAIN_RK3588(\"av1\",     0x0, BIT(12), 0,       0x0, BIT(20), BIT(11), 0x0, BIT(9),  BIT(9),  false),\n\t[RK3588_PD_VI]\t\t= DOMAIN_RK3588(\"vi\",      0x0, BIT(13), 0,       0x0, BIT(21), BIT(12), 0x0, BIT(10), BIT(10), false),\n\t[RK3588_PD_FEC]\t\t= DOMAIN_RK3588(\"fec\",     0x0, BIT(14), 0,       0x0, BIT(22), BIT(13), 0x0, 0,       0,       false),\n\t[RK3588_PD_ISP1]\t= DOMAIN_RK3588(\"isp1\",    0x0, BIT(15), 0,       0x0, BIT(23), BIT(14), 0x0, BIT(11), BIT(11), false),\n\t[RK3588_PD_RGA31]\t= DOMAIN_RK3588(\"rga31\",   0x4, BIT(0),  0,       0x0, BIT(24), BIT(15), 0x0, BIT(12), BIT(12), false),\n\t[RK3588_PD_VOP]\t\t= DOMAIN_RK3588(\"vop\",     0x4, BIT(1),  0,       0x0, BIT(25), BIT(16), 0x0, BIT(13) | BIT(14), BIT(13) | BIT(14), false),\n\t[RK3588_PD_VO0]\t\t= DOMAIN_RK3588(\"vo0\",     0x4, BIT(2),  0,       0x0, BIT(26), BIT(17), 0x0, BIT(15), BIT(15), false),\n\t[RK3588_PD_VO1]\t\t= DOMAIN_RK3588(\"vo1\",     0x4, BIT(3),  0,       0x0, BIT(27), BIT(18), 0x4, BIT(0),  BIT(16), false),\n\t[RK3588_PD_AUDIO]\t= DOMAIN_RK3588(\"audio\",   0x4, BIT(4),  0,       0x0, BIT(28), BIT(19), 0x4, BIT(1),  BIT(17), false),\n\t[RK3588_PD_PHP]\t\t= DOMAIN_RK3588(\"php\",     0x4, BIT(5),  0,       0x0, BIT(29), BIT(20), 0x4, BIT(5),  BIT(21), false),\n\t[RK3588_PD_GMAC]\t= DOMAIN_RK3588(\"gmac\",    0x4, BIT(6),  0,       0x0, BIT(30), BIT(21), 0x0, 0,       0,       false),\n\t[RK3588_PD_PCIE]\t= DOMAIN_RK3588(\"pcie\",    0x4, BIT(7),  0,       0x0, BIT(31), BIT(22), 0x0, 0,       0,       true),\n\t[RK3588_PD_NVM]\t\t= DOMAIN_RK3588(\"nvm\",     0x4, BIT(8),  BIT(24), 0x4, 0,       0,       0x4, BIT(2),  BIT(18), false),\n\t[RK3588_PD_NVM0]\t= DOMAIN_RK3588(\"nvm0\",    0x4, BIT(9),  0,       0x4, BIT(1),  BIT(23), 0x0, 0,       0,       false),\n\t[RK3588_PD_SDIO]\t= DOMAIN_RK3588(\"sdio\",    0x4, BIT(10), 0,       0x4, BIT(2),  BIT(24), 0x4, BIT(3),  BIT(19), false),\n\t[RK3588_PD_USB]\t\t= DOMAIN_RK3588(\"usb\",     0x4, BIT(11), 0,       0x4, BIT(3),  BIT(25), 0x4, BIT(4),  BIT(20), true),\n\t[RK3588_PD_SDMMC]\t= DOMAIN_RK3588(\"sdmmc\",   0x4, BIT(13), 0,       0x4, BIT(5),  BIT(26), 0x0, 0,       0,       false),\n};\n\nstatic const struct rockchip_pmu_info px30_pmu = {\n\t.pwr_offset = 0x18,\n\t.status_offset = 0x20,\n\t.req_offset = 0x64,\n\t.idle_offset = 0x6c,\n\t.ack_offset = 0x6c,\n\n\t.num_domains = ARRAY_SIZE(px30_pm_domains),\n\t.domain_info = px30_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rk3036_pmu = {\n\t.req_offset = 0x148,\n\t.idle_offset = 0x14c,\n\t.ack_offset = 0x14c,\n\n\t.num_domains = ARRAY_SIZE(rk3036_pm_domains),\n\t.domain_info = rk3036_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rk3066_pmu = {\n\t.pwr_offset = 0x08,\n\t.status_offset = 0x0c,\n\t.req_offset = 0x38,  \n\t.idle_offset = 0x0c,\n\t.ack_offset = 0x0c,\n\n\t.num_domains = ARRAY_SIZE(rk3066_pm_domains),\n\t.domain_info = rk3066_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rk3128_pmu = {\n\t.pwr_offset = 0x04,\n\t.status_offset = 0x08,\n\t.req_offset = 0x0c,\n\t.idle_offset = 0x10,\n\t.ack_offset = 0x10,\n\n\t.num_domains = ARRAY_SIZE(rk3128_pm_domains),\n\t.domain_info = rk3128_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rk3188_pmu = {\n\t.pwr_offset = 0x08,\n\t.status_offset = 0x0c,\n\t.req_offset = 0x38,  \n\t.idle_offset = 0x0c,\n\t.ack_offset = 0x0c,\n\n\t.num_domains = ARRAY_SIZE(rk3188_pm_domains),\n\t.domain_info = rk3188_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rk3228_pmu = {\n\t.req_offset = 0x40c,\n\t.idle_offset = 0x488,\n\t.ack_offset = 0x488,\n\n\t.num_domains = ARRAY_SIZE(rk3228_pm_domains),\n\t.domain_info = rk3228_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rk3288_pmu = {\n\t.pwr_offset = 0x08,\n\t.status_offset = 0x0c,\n\t.req_offset = 0x10,\n\t.idle_offset = 0x14,\n\t.ack_offset = 0x14,\n\n\t.core_pwrcnt_offset = 0x34,\n\t.gpu_pwrcnt_offset = 0x3c,\n\n\t.core_power_transition_time = 24,  \n\t.gpu_power_transition_time = 24,  \n\n\t.num_domains = ARRAY_SIZE(rk3288_pm_domains),\n\t.domain_info = rk3288_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rk3328_pmu = {\n\t.req_offset = 0x414,\n\t.idle_offset = 0x484,\n\t.ack_offset = 0x484,\n\n\t.num_domains = ARRAY_SIZE(rk3328_pm_domains),\n\t.domain_info = rk3328_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rk3366_pmu = {\n\t.pwr_offset = 0x0c,\n\t.status_offset = 0x10,\n\t.req_offset = 0x3c,\n\t.idle_offset = 0x40,\n\t.ack_offset = 0x40,\n\n\t.core_pwrcnt_offset = 0x48,\n\t.gpu_pwrcnt_offset = 0x50,\n\n\t.core_power_transition_time = 24,\n\t.gpu_power_transition_time = 24,\n\n\t.num_domains = ARRAY_SIZE(rk3366_pm_domains),\n\t.domain_info = rk3366_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rk3368_pmu = {\n\t.pwr_offset = 0x0c,\n\t.status_offset = 0x10,\n\t.req_offset = 0x3c,\n\t.idle_offset = 0x40,\n\t.ack_offset = 0x40,\n\n\t.core_pwrcnt_offset = 0x48,\n\t.gpu_pwrcnt_offset = 0x50,\n\n\t.core_power_transition_time = 24,\n\t.gpu_power_transition_time = 24,\n\n\t.num_domains = ARRAY_SIZE(rk3368_pm_domains),\n\t.domain_info = rk3368_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rk3399_pmu = {\n\t.pwr_offset = 0x14,\n\t.status_offset = 0x18,\n\t.req_offset = 0x60,\n\t.idle_offset = 0x64,\n\t.ack_offset = 0x68,\n\n\t \n\n\t.num_domains = ARRAY_SIZE(rk3399_pm_domains),\n\t.domain_info = rk3399_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rk3568_pmu = {\n\t.pwr_offset = 0xa0,\n\t.status_offset = 0x98,\n\t.req_offset = 0x50,\n\t.idle_offset = 0x68,\n\t.ack_offset = 0x60,\n\n\t.num_domains = ARRAY_SIZE(rk3568_pm_domains),\n\t.domain_info = rk3568_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rk3588_pmu = {\n\t.pwr_offset = 0x14c,\n\t.status_offset = 0x180,\n\t.req_offset = 0x10c,\n\t.idle_offset = 0x120,\n\t.ack_offset = 0x118,\n\t.mem_pwr_offset = 0x1a0,\n\t.chain_status_offset = 0x1f0,\n\t.mem_status_offset = 0x1f8,\n\t.repair_status_offset = 0x290,\n\n\t.num_domains = ARRAY_SIZE(rk3588_pm_domains),\n\t.domain_info = rk3588_pm_domains,\n};\n\nstatic const struct rockchip_pmu_info rv1126_pmu = {\n\t.pwr_offset = 0x110,\n\t.status_offset = 0x108,\n\t.req_offset = 0xc0,\n\t.idle_offset = 0xd8,\n\t.ack_offset = 0xd0,\n\n\t.num_domains = ARRAY_SIZE(rv1126_pm_domains),\n\t.domain_info = rv1126_pm_domains,\n};\n\nstatic const struct of_device_id rockchip_pm_domain_dt_match[] = {\n\t{\n\t\t.compatible = \"rockchip,px30-power-controller\",\n\t\t.data = (void *)&px30_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3036-power-controller\",\n\t\t.data = (void *)&rk3036_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3066-power-controller\",\n\t\t.data = (void *)&rk3066_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3128-power-controller\",\n\t\t.data = (void *)&rk3128_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3188-power-controller\",\n\t\t.data = (void *)&rk3188_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3228-power-controller\",\n\t\t.data = (void *)&rk3228_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3288-power-controller\",\n\t\t.data = (void *)&rk3288_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3328-power-controller\",\n\t\t.data = (void *)&rk3328_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3366-power-controller\",\n\t\t.data = (void *)&rk3366_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3368-power-controller\",\n\t\t.data = (void *)&rk3368_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3399-power-controller\",\n\t\t.data = (void *)&rk3399_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3568-power-controller\",\n\t\t.data = (void *)&rk3568_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3588-power-controller\",\n\t\t.data = (void *)&rk3588_pmu,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rv1126-power-controller\",\n\t\t.data = (void *)&rv1126_pmu,\n\t},\n\t{   },\n};\n\nstatic struct platform_driver rockchip_pm_domain_driver = {\n\t.probe = rockchip_pm_domain_probe,\n\t.driver = {\n\t\t.name   = \"rockchip-pm-domain\",\n\t\t.of_match_table = rockchip_pm_domain_dt_match,\n\t\t \n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nstatic int __init rockchip_pm_domain_drv_register(void)\n{\n\treturn platform_driver_register(&rockchip_pm_domain_driver);\n}\npostcore_initcall(rockchip_pm_domain_drv_register);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}