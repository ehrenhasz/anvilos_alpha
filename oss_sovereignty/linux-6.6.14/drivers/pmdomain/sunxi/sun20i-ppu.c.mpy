{
  "module_name": "sun20i-ppu.c",
  "hash_id": "a10aa2a36e601036382d3767f3f893642ceb05c75067a3255e17fdedf12eedd5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pmdomain/sunxi/sun20i-ppu.c",
  "human_readable_source": "\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/reset.h>\n\n#define PD_STATE_ON\t\t\t1\n#define PD_STATE_OFF\t\t\t2\n\n#define PD_RSTN_REG\t\t\t0x00\n#define PD_CLK_GATE_REG\t\t\t0x04\n#define PD_PWROFF_GATE_REG\t\t0x08\n#define PD_PSW_ON_REG\t\t\t0x0c\n#define PD_PSW_OFF_REG\t\t\t0x10\n#define PD_PSW_DELAY_REG\t\t0x14\n#define PD_OFF_DELAY_REG\t\t0x18\n#define PD_ON_DELAY_REG\t\t\t0x1c\n#define PD_COMMAND_REG\t\t\t0x20\n#define PD_STATUS_REG\t\t\t0x24\n#define PD_STATUS_COMPLETE\t\t\tBIT(1)\n#define PD_STATUS_BUSY\t\t\t\tBIT(3)\n#define PD_STATUS_STATE\t\t\t\tGENMASK(17, 16)\n#define PD_ACTIVE_CTRL_REG\t\t0x2c\n#define PD_GATE_STATUS_REG\t\t0x30\n#define PD_RSTN_STATUS\t\t\t\tBIT(0)\n#define PD_CLK_GATE_STATUS\t\t\tBIT(1)\n#define PD_PWROFF_GATE_STATUS\t\t\tBIT(2)\n#define PD_PSW_STATUS_REG\t\t0x34\n\n#define PD_REGS_SIZE\t\t\t0x80\n\nstruct sun20i_ppu_desc {\n\tconst char *const\t\t*names;\n\tunsigned int\t\t\tnum_domains;\n};\n\nstruct sun20i_ppu_pd {\n\tstruct generic_pm_domain\tgenpd;\n\tvoid __iomem\t\t\t*base;\n};\n\n#define to_sun20i_ppu_pd(_genpd) \\\n\tcontainer_of(_genpd, struct sun20i_ppu_pd, genpd)\n\nstatic bool sun20i_ppu_pd_is_on(const struct sun20i_ppu_pd *pd)\n{\n\tu32 status = readl(pd->base + PD_STATUS_REG);\n\n\treturn FIELD_GET(PD_STATUS_STATE, status) == PD_STATE_ON;\n}\n\nstatic int sun20i_ppu_pd_set_power(const struct sun20i_ppu_pd *pd, bool power_on)\n{\n\tu32 state, status;\n\tint ret;\n\n\tif (sun20i_ppu_pd_is_on(pd) == power_on)\n\t\treturn 0;\n\n\t \n\tret = readl_poll_timeout(pd->base + PD_STATUS_REG, status,\n\t\t\t\t !(status & PD_STATUS_BUSY), 100, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\tstate = power_on ? PD_STATE_ON : PD_STATE_OFF;\n\twritel(state, pd->base + PD_COMMAND_REG);\n\n\t \n\tret = readl_poll_timeout(pd->base + PD_STATUS_REG, status,\n\t\t\t\t FIELD_GET(PD_STATUS_STATE, status) == state &&\n\t\t\t\t (status & PD_STATUS_COMPLETE), 100, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(status, pd->base + PD_STATUS_REG);\n\n\treturn 0;\n}\n\nstatic int sun20i_ppu_pd_power_on(struct generic_pm_domain *genpd)\n{\n\tconst struct sun20i_ppu_pd *pd = to_sun20i_ppu_pd(genpd);\n\n\treturn sun20i_ppu_pd_set_power(pd, true);\n}\n\nstatic int sun20i_ppu_pd_power_off(struct generic_pm_domain *genpd)\n{\n\tconst struct sun20i_ppu_pd *pd = to_sun20i_ppu_pd(genpd);\n\n\treturn sun20i_ppu_pd_set_power(pd, false);\n}\n\nstatic int sun20i_ppu_probe(struct platform_device *pdev)\n{\n\tconst struct sun20i_ppu_desc *desc;\n\tstruct device *dev = &pdev->dev;\n\tstruct genpd_onecell_data *ppu;\n\tstruct sun20i_ppu_pd *pds;\n\tstruct reset_control *rst;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tint ret;\n\n\tdesc = of_device_get_match_data(dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tpds = devm_kcalloc(dev, desc->num_domains, sizeof(*pds), GFP_KERNEL);\n\tif (!pds)\n\t\treturn -ENOMEM;\n\n\tppu = devm_kzalloc(dev, sizeof(*ppu), GFP_KERNEL);\n\tif (!ppu)\n\t\treturn -ENOMEM;\n\n\tppu->domains = devm_kcalloc(dev, desc->num_domains,\n\t\t\t\t    sizeof(*ppu->domains), GFP_KERNEL);\n\tif (!ppu->domains)\n\t\treturn -ENOMEM;\n\n\tppu->num_domains = desc->num_domains;\n\tplatform_set_drvdata(pdev, ppu);\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tclk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\trst = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(rst))\n\t\treturn PTR_ERR(rst);\n\n\tret = reset_control_deassert(rst);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (unsigned int i = 0; i < ppu->num_domains; ++i) {\n\t\tstruct sun20i_ppu_pd *pd = &pds[i];\n\n\t\tpd->genpd.name\t\t= desc->names[i];\n\t\tpd->genpd.power_off\t= sun20i_ppu_pd_power_off;\n\t\tpd->genpd.power_on\t= sun20i_ppu_pd_power_on;\n\t\tpd->base\t\t= base + PD_REGS_SIZE * i;\n\n\t\tret = pm_genpd_init(&pd->genpd, NULL, sun20i_ppu_pd_is_on(pd));\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"Failed to add '%s' domain: %d\\n\",\n\t\t\t\t pd->genpd.name, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tppu->domains[i] = &pd->genpd;\n\t}\n\n\tret = of_genpd_add_provider_onecell(dev->of_node, ppu);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to add provider: %d\\n\", ret);\n\n\treturn 0;\n}\n\nstatic const char *const sun20i_d1_ppu_pd_names[] = {\n\t\"CPU\",\n\t\"VE\",\n\t\"DSP\",\n};\n\nstatic const struct sun20i_ppu_desc sun20i_d1_ppu_desc = {\n\t.names\t\t= sun20i_d1_ppu_pd_names,\n\t.num_domains\t= ARRAY_SIZE(sun20i_d1_ppu_pd_names),\n};\n\nstatic const struct of_device_id sun20i_ppu_of_match[] = {\n\t{\n\t\t.compatible\t= \"allwinner,sun20i-d1-ppu\",\n\t\t.data\t\t= &sun20i_d1_ppu_desc,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sun20i_ppu_of_match);\n\nstatic struct platform_driver sun20i_ppu_driver = {\n\t.probe\t= sun20i_ppu_probe,\n\t.driver\t= {\n\t\t.name\t\t\t= \"sun20i-ppu\",\n\t\t.of_match_table\t\t= sun20i_ppu_of_match,\n\t\t \n\t\t.suppress_bind_attrs\t= true,\n\t},\n};\nmodule_platform_driver(sun20i_ppu_driver);\n\nMODULE_AUTHOR(\"Samuel Holland <samuel@sholland.org>\");\nMODULE_DESCRIPTION(\"Allwinner D1 PPU power domain driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}