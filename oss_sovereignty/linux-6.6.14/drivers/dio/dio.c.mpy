{
  "module_name": "dio.c",
  "hash_id": "9ee45d3085f6d0f0abff6ee7704672734f6dbf388019a39d17d5ec09efddf5d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dio/dio.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/dio.h>\n#include <linux/slab.h>                          \n#include <linux/uaccess.h>\n#include <linux/io.h>                            \n\nstruct dio_bus dio_bus = {\n\t.resources = {\n\t\t \n\t\t{ .name = \"DIO mem\", .start = 0x00600000, .end = 0x007fffff },\n\t\t \n\t\t{ .name = \"DIO-II mem\", .start = 0x01000000, .end = 0x1fffffff }\n\t},\n\t.name = \"DIO bus\"\n};\n\n \n#define CONFIG_DIO_CONSTANTS\n\n#ifdef CONFIG_DIO_CONSTANTS\n \nstruct dioname {\n\tint id;\n\tconst char *name;\n};\n\n \n#define DIONAME(x) { DIO_ID_##x, DIO_DESC_##x }\n#define DIOFBNAME(x) { DIO_ENCODE_ID(DIO_ID_FBUFFER, DIO_ID2_##x), DIO_DESC2_##x }\n\nstatic struct dioname names[] = {\n\tDIONAME(DCA0), DIONAME(DCA0REM), DIONAME(DCA1), DIONAME(DCA1REM),\n\tDIONAME(DCM), DIONAME(DCMREM),\n\tDIONAME(LAN),\n\tDIONAME(FHPIB), DIONAME(NHPIB),\n\tDIONAME(SCSI0), DIONAME(SCSI1), DIONAME(SCSI2), DIONAME(SCSI3),\n\tDIONAME(FBUFFER),\n\tDIONAME(PARALLEL), DIONAME(VME), DIONAME(DCL), DIONAME(DCLREM),\n\tDIONAME(MISC0), DIONAME(MISC1), DIONAME(MISC2), DIONAME(MISC3),\n\tDIONAME(MISC4), DIONAME(MISC5), DIONAME(MISC6), DIONAME(MISC7),\n\tDIONAME(MISC8), DIONAME(MISC9), DIONAME(MISC10), DIONAME(MISC11),\n\tDIONAME(MISC12), DIONAME(MISC13),\n\tDIOFBNAME(GATORBOX), DIOFBNAME(TOPCAT), DIOFBNAME(RENAISSANCE),\n\tDIOFBNAME(LRCATSEYE), DIOFBNAME(HRCCATSEYE), DIOFBNAME(HRMCATSEYE),\n\tDIOFBNAME(DAVINCI), DIOFBNAME(XXXCATSEYE), DIOFBNAME(HYPERION),\n\tDIOFBNAME(XGENESIS), DIOFBNAME(TIGER), DIOFBNAME(YGENESIS)\n};\n\n#undef DIONAME\n#undef DIOFBNAME\n\nstatic const char unknowndioname[]\n\t= \"unknown DIO board, please email linux-m68k@lists.linux-m68k.org\";\n\nstatic const char *dio_getname(int id)\n{\n\t \n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(names); i++)\n\t\tif (names[i].id == id)\n\t\t\treturn names[i].name;\n\n\treturn unknowndioname;\n}\n\n#else\n\nstatic char dio_no_name[] = { 0 };\n#define dio_getname(_id)\t(dio_no_name)\n\n#endif  \n\nstatic void dio_dev_release(struct device *dev)\n{\n\tstruct dio_dev *ddev = container_of(dev, typeof(struct dio_dev), dev);\n\tkfree(ddev);\n}\n\nint __init dio_find(int deviceid)\n{\n\t \n\tint scode, id;\n\tu_char prid, secid, i;\n\n\tfor (scode = 0; scode < DIO_SCMAX; scode++) {\n\t\tvoid *va;\n\t\tunsigned long pa;\n\n\t\tif (DIO_SCINHOLE(scode))\n\t\t\tcontinue;\n\n\t\tpa = dio_scodetophysaddr(scode);\n\n\t\tif (!pa)\n\t\t\tcontinue;\n\n\t\tif (scode < DIOII_SCBASE)\n\t\t\tva = (void *)(pa + DIO_VIRADDRBASE);\n\t\telse\n\t\t\tva = ioremap(pa, PAGE_SIZE);\n\n\t\tif (copy_from_kernel_nofault(&i,\n\t\t\t\t(unsigned char *)va + DIO_IDOFF, 1)) {\n\t\t\tif (scode >= DIOII_SCBASE)\n\t\t\t\tiounmap(va);\n\t\t\tcontinue;\t      \n\t\t}\n\n\t\tprid = DIO_ID(va);\n\n\t\tif (DIO_NEEDSSECID(prid)) {\n\t\t\tsecid = DIO_SECID(va);\n\t\t\tid = DIO_ENCODE_ID(prid, secid);\n\t\t} else\n\t\t\tid = prid;\n\n\t\tif (id == deviceid) {\n\t\t\tif (scode >= DIOII_SCBASE)\n\t\t\t\tiounmap(va);\n\t\t\treturn scode;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n \nstatic int __init dio_init(void)\n{\n\tint scode;\n\tint i;\n\tstruct dio_dev *dev;\n\tint error;\n\n\tif (!MACH_IS_HP300)\n\t\treturn 0;\n\n        printk(KERN_INFO \"Scanning for DIO devices...\\n\");\n\n\t \n\tINIT_LIST_HEAD(&dio_bus.devices);\n\tdev_set_name(&dio_bus.dev, \"dio\");\n\terror = device_register(&dio_bus.dev);\n\tif (error) {\n\t\tpr_err(\"DIO: Error registering dio_bus\\n\");\n\t\treturn error;\n\t}\n\n\t \n\tdio_bus.num_resources = (hp300_model == HP_320 ? 1 : 2);\n\tfor (i = 0; i < dio_bus.num_resources; i++)\n\t\trequest_resource(&iomem_resource, &dio_bus.resources[i]);\n\n\t \n\tfor (scode = 0; scode < DIO_SCMAX; ++scode) {\n\t\tu_char prid, secid = 0;\t \n\t\tu_char *va;\n\t\tunsigned long pa;\n\n\t\tif (DIO_SCINHOLE(scode))\n\t\t\tcontinue;\n\n\t\tpa = dio_scodetophysaddr(scode);\n\n\t\tif (!pa)\n\t\t\tcontinue;\n\n\t\tif (scode < DIOII_SCBASE)\n\t\t\tva = (void *)(pa + DIO_VIRADDRBASE);\n\t\telse\n\t\t\tva = ioremap(pa, PAGE_SIZE);\n\n\t\tif (copy_from_kernel_nofault(&i,\n\t\t\t\t(unsigned char *)va + DIO_IDOFF, 1)) {\n\t\t\tif (scode >= DIOII_SCBASE)\n\t\t\t\tiounmap(va);\n\t\t\tcontinue;\t       \n\t\t}\n\n\t\t \n\t\tdev = kzalloc(sizeof(struct dio_dev), GFP_KERNEL);\n\t\tif (!dev) {\n\t\t\tif (scode >= DIOII_SCBASE)\n\t\t\t\tiounmap(va);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdev->bus = &dio_bus;\n\t\tdev->dev.parent = &dio_bus.dev;\n\t\tdev->dev.bus = &dio_bus_type;\n\t\tdev->dev.release = dio_dev_release;\n\t\tdev->scode = scode;\n\t\tdev->resource.start = pa;\n\t\tdev->resource.end = pa + DIO_SIZE(scode, va);\n\t\tdev_set_name(&dev->dev, \"%02x\", scode);\n\n\t\t \n\t\tprid = DIO_ID(va);\n\n\t\tif (DIO_NEEDSSECID(prid)) {\n\t\t\tsecid = DIO_SECID(va);\n\t\t\tdev->id = DIO_ENCODE_ID(prid, secid);\n\t\t} else\n\t\t\tdev->id = prid;\n\n\t\tdev->ipl = DIO_IPL(va);\n\t\tstrcpy(dev->name, dio_getname(dev->id));\n                printk(KERN_INFO \"select code %3d: ipl %d: ID %02X\", dev->scode, dev->ipl, prid);\n\t\tif (DIO_NEEDSSECID(prid))\n                        printk(\":%02X\", secid);\n                printk(\": %s\\n\", dev->name);\n\n\t\tif (scode >= DIOII_SCBASE)\n\t\t\tiounmap(va);\n\t\terror = device_register(&dev->dev);\n\t\tif (error) {\n\t\t\tpr_err(\"DIO: Error registering device %s\\n\",\n\t\t\t       dev->name);\n\t\t\tput_device(&dev->dev);\n\t\t\tcontinue;\n\t\t}\n\t\terror = dio_create_sysfs_dev_files(dev);\n\t\tif (error)\n\t\t\tdev_err(&dev->dev, \"Error creating sysfs files\\n\");\n\t}\n\treturn 0;\n}\n\nsubsys_initcall(dio_init);\n\n \nunsigned long dio_scodetophysaddr(int scode)\n{\n\tif (scode >= DIOII_SCBASE)\n\t\treturn (DIOII_BASE + (scode - 132) * DIOII_DEVSIZE);\n\telse if (scode > DIO_SCMAX || scode < 0)\n\t\treturn 0;\n\telse if (DIO_SCINHOLE(scode))\n\t\treturn 0;\n\n\treturn (DIO_BASE + scode * DIO_DEVSIZE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}