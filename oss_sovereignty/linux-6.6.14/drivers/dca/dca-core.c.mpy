{
  "module_name": "dca-core.c",
  "hash_id": "f425925de892d6a95317932d7a2bce9aa981f25a8e07ffe3f174d51518bc40de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dca/dca-core.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/notifier.h>\n#include <linux/device.h>\n#include <linux/dca.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define DCA_VERSION \"1.12.1\"\n\nMODULE_VERSION(DCA_VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Intel Corporation\");\n\nstatic DEFINE_RAW_SPINLOCK(dca_lock);\n\nstatic LIST_HEAD(dca_domains);\n\nstatic BLOCKING_NOTIFIER_HEAD(dca_provider_chain);\n\nstatic int dca_providers_blocked;\n\nstatic struct pci_bus *dca_pci_rc_from_dev(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pci_bus *bus = pdev->bus;\n\n\twhile (bus->parent)\n\t\tbus = bus->parent;\n\n\treturn bus;\n}\n\nstatic struct dca_domain *dca_allocate_domain(struct pci_bus *rc)\n{\n\tstruct dca_domain *domain;\n\n\tdomain = kzalloc(sizeof(*domain), GFP_NOWAIT);\n\tif (!domain)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&domain->dca_providers);\n\tdomain->pci_rc = rc;\n\n\treturn domain;\n}\n\nstatic void dca_free_domain(struct dca_domain *domain)\n{\n\tlist_del(&domain->node);\n\tkfree(domain);\n}\n\nstatic int dca_provider_ioat_ver_3_0(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn ((pdev->vendor == PCI_VENDOR_ID_INTEL) &&\n\t\t((pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG0) ||\n\t\t(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG1) ||\n\t\t(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG2) ||\n\t\t(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG3) ||\n\t\t(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG4) ||\n\t\t(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG5) ||\n\t\t(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG6) ||\n\t\t(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG7)));\n}\n\nstatic void unregister_dca_providers(void)\n{\n\tstruct dca_provider *dca, *_dca;\n\tstruct list_head unregistered_providers;\n\tstruct dca_domain *domain;\n\tunsigned long flags;\n\n\tblocking_notifier_call_chain(&dca_provider_chain,\n\t\t\t\t     DCA_PROVIDER_REMOVE, NULL);\n\n\tINIT_LIST_HEAD(&unregistered_providers);\n\n\traw_spin_lock_irqsave(&dca_lock, flags);\n\n\tif (list_empty(&dca_domains)) {\n\t\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tdomain = list_first_entry(&dca_domains, struct dca_domain, node);\n\n\tlist_for_each_entry_safe(dca, _dca, &domain->dca_providers, node)\n\t\tlist_move(&dca->node, &unregistered_providers);\n\n\tdca_free_domain(domain);\n\n\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\n\tlist_for_each_entry_safe(dca, _dca, &unregistered_providers, node) {\n\t\tdca_sysfs_remove_provider(dca);\n\t\tlist_del(&dca->node);\n\t}\n}\n\nstatic struct dca_domain *dca_find_domain(struct pci_bus *rc)\n{\n\tstruct dca_domain *domain;\n\n\tlist_for_each_entry(domain, &dca_domains, node)\n\t\tif (domain->pci_rc == rc)\n\t\t\treturn domain;\n\n\treturn NULL;\n}\n\nstatic struct dca_domain *dca_get_domain(struct device *dev)\n{\n\tstruct pci_bus *rc;\n\tstruct dca_domain *domain;\n\n\trc = dca_pci_rc_from_dev(dev);\n\tdomain = dca_find_domain(rc);\n\n\tif (!domain) {\n\t\tif (dca_provider_ioat_ver_3_0(dev) && !list_empty(&dca_domains))\n\t\t\tdca_providers_blocked = 1;\n\t}\n\n\treturn domain;\n}\n\nstatic struct dca_provider *dca_find_provider_by_dev(struct device *dev)\n{\n\tstruct dca_provider *dca;\n\tstruct pci_bus *rc;\n\tstruct dca_domain *domain;\n\n\tif (dev) {\n\t\trc = dca_pci_rc_from_dev(dev);\n\t\tdomain = dca_find_domain(rc);\n\t\tif (!domain)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (!list_empty(&dca_domains))\n\t\t\tdomain = list_first_entry(&dca_domains,\n\t\t\t\t\t\t  struct dca_domain,\n\t\t\t\t\t\t  node);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(dca, &domain->dca_providers, node)\n\t\tif ((!dev) || (dca->ops->dev_managed(dca, dev)))\n\t\t\treturn dca;\n\n\treturn NULL;\n}\n\n \nint dca_add_requester(struct device *dev)\n{\n\tstruct dca_provider *dca;\n\tint err, slot = -ENODEV;\n\tunsigned long flags;\n\tstruct pci_bus *pci_rc;\n\tstruct dca_domain *domain;\n\n\tif (!dev)\n\t\treturn -EFAULT;\n\n\traw_spin_lock_irqsave(&dca_lock, flags);\n\n\t \n\tdca = dca_find_provider_by_dev(dev);\n\tif (dca) {\n\t\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\t\treturn -EEXIST;\n\t}\n\n\tpci_rc = dca_pci_rc_from_dev(dev);\n\tdomain = dca_find_domain(pci_rc);\n\tif (!domain) {\n\t\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tlist_for_each_entry(dca, &domain->dca_providers, node) {\n\t\tslot = dca->ops->add_requester(dca, dev);\n\t\tif (slot >= 0)\n\t\t\tbreak;\n\t}\n\n\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\n\tif (slot < 0)\n\t\treturn slot;\n\n\terr = dca_sysfs_add_req(dca, dev, slot);\n\tif (err) {\n\t\traw_spin_lock_irqsave(&dca_lock, flags);\n\t\tif (dca == dca_find_provider_by_dev(dev))\n\t\t\tdca->ops->remove_requester(dca, dev);\n\t\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dca_add_requester);\n\n \nint dca_remove_requester(struct device *dev)\n{\n\tstruct dca_provider *dca;\n\tint slot;\n\tunsigned long flags;\n\n\tif (!dev)\n\t\treturn -EFAULT;\n\n\traw_spin_lock_irqsave(&dca_lock, flags);\n\tdca = dca_find_provider_by_dev(dev);\n\tif (!dca) {\n\t\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\tslot = dca->ops->remove_requester(dca, dev);\n\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\n\tif (slot < 0)\n\t\treturn slot;\n\n\tdca_sysfs_remove_req(dca, slot);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dca_remove_requester);\n\n \nstatic u8 dca_common_get_tag(struct device *dev, int cpu)\n{\n\tstruct dca_provider *dca;\n\tu8 tag;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&dca_lock, flags);\n\n\tdca = dca_find_provider_by_dev(dev);\n\tif (!dca) {\n\t\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\ttag = dca->ops->get_tag(dca, dev, cpu);\n\n\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\treturn tag;\n}\n\n \nu8 dca3_get_tag(struct device *dev, int cpu)\n{\n\tif (!dev)\n\t\treturn -EFAULT;\n\n\treturn dca_common_get_tag(dev, cpu);\n}\nEXPORT_SYMBOL_GPL(dca3_get_tag);\n\n \nu8 dca_get_tag(int cpu)\n{\n\treturn dca_common_get_tag(NULL, cpu);\n}\nEXPORT_SYMBOL_GPL(dca_get_tag);\n\n \nstruct dca_provider *alloc_dca_provider(const struct dca_ops *ops,\n\t\t\t\t\tint priv_size)\n{\n\tstruct dca_provider *dca;\n\tint alloc_size;\n\n\talloc_size = (sizeof(*dca) + priv_size);\n\tdca = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!dca)\n\t\treturn NULL;\n\tdca->ops = ops;\n\n\treturn dca;\n}\nEXPORT_SYMBOL_GPL(alloc_dca_provider);\n\n \nvoid free_dca_provider(struct dca_provider *dca)\n{\n\tkfree(dca);\n}\nEXPORT_SYMBOL_GPL(free_dca_provider);\n\n \nint register_dca_provider(struct dca_provider *dca, struct device *dev)\n{\n\tint err;\n\tunsigned long flags;\n\tstruct dca_domain *domain, *newdomain = NULL;\n\n\traw_spin_lock_irqsave(&dca_lock, flags);\n\tif (dca_providers_blocked) {\n\t\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\n\terr = dca_sysfs_add_provider(dca, dev);\n\tif (err)\n\t\treturn err;\n\n\traw_spin_lock_irqsave(&dca_lock, flags);\n\tdomain = dca_get_domain(dev);\n\tif (!domain) {\n\t\tstruct pci_bus *rc;\n\n\t\tif (dca_providers_blocked) {\n\t\t\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\t\t\tdca_sysfs_remove_provider(dca);\n\t\t\tunregister_dca_providers();\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\t\trc = dca_pci_rc_from_dev(dev);\n\t\tnewdomain = dca_allocate_domain(rc);\n\t\tif (!newdomain)\n\t\t\treturn -ENODEV;\n\t\traw_spin_lock_irqsave(&dca_lock, flags);\n\t\t \n\t\tdomain = dca_get_domain(dev);\n\t\tif (!domain) {\n\t\t\tdomain = newdomain;\n\t\t\tnewdomain = NULL;\n\t\t\tlist_add(&domain->node, &dca_domains);\n\t\t}\n\t}\n\tlist_add(&dca->node, &domain->dca_providers);\n\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\n\tblocking_notifier_call_chain(&dca_provider_chain,\n\t\t\t\t     DCA_PROVIDER_ADD, NULL);\n\tkfree(newdomain);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(register_dca_provider);\n\n \nvoid unregister_dca_provider(struct dca_provider *dca, struct device *dev)\n{\n\tunsigned long flags;\n\tstruct pci_bus *pci_rc;\n\tstruct dca_domain *domain;\n\n\tblocking_notifier_call_chain(&dca_provider_chain,\n\t\t\t\t     DCA_PROVIDER_REMOVE, NULL);\n\n\traw_spin_lock_irqsave(&dca_lock, flags);\n\n\tif (list_empty(&dca_domains)) {\n\t\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\t\treturn;\n\t}\n\n\tlist_del(&dca->node);\n\n\tpci_rc = dca_pci_rc_from_dev(dev);\n\tdomain = dca_find_domain(pci_rc);\n\tif (list_empty(&domain->dca_providers))\n\t\tdca_free_domain(domain);\n\n\traw_spin_unlock_irqrestore(&dca_lock, flags);\n\n\tdca_sysfs_remove_provider(dca);\n}\nEXPORT_SYMBOL_GPL(unregister_dca_provider);\n\n \nvoid dca_register_notify(struct notifier_block *nb)\n{\n\tblocking_notifier_chain_register(&dca_provider_chain, nb);\n}\nEXPORT_SYMBOL_GPL(dca_register_notify);\n\n \nvoid dca_unregister_notify(struct notifier_block *nb)\n{\n\tblocking_notifier_chain_unregister(&dca_provider_chain, nb);\n}\nEXPORT_SYMBOL_GPL(dca_unregister_notify);\n\nstatic int __init dca_init(void)\n{\n\tpr_info(\"dca service started, version %s\\n\", DCA_VERSION);\n\treturn dca_sysfs_init();\n}\n\nstatic void __exit dca_exit(void)\n{\n\tdca_sysfs_exit();\n}\n\narch_initcall(dca_init);\nmodule_exit(dca_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}