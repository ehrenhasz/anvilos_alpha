{
  "module_name": "fsi-scom.c",
  "hash_id": "9cd5d0a9cd39d292539a926a51dec7557963d9aa87c5f05173b9f3cbfcc7407e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fsi/fsi-scom.c",
  "human_readable_source": "\n \n\n#include <linux/fsi.h>\n#include <linux/module.h>\n#include <linux/cdev.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/mod_devicetable.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n\n#include <uapi/linux/fsi.h>\n\n#define FSI_ENGID_SCOM\t\t0x5\n\n \n#define SCOM_DATA0_REG\t\t0x00\n#define SCOM_DATA1_REG\t\t0x04\n#define SCOM_CMD_REG\t\t0x08\n#define SCOM_FSI2PIB_RESET_REG\t0x18\n#define SCOM_STATUS_REG\t\t0x1C  \n#define SCOM_PIB_RESET_REG\t0x1C  \n\n \n#define SCOM_WRITE_CMD\t\t0x80000000\n#define SCOM_READ_CMD\t\t0x00000000\n\n \n#define SCOM_STATUS_ERR_SUMMARY\t\t0x80000000\n#define SCOM_STATUS_PROTECTION\t\t0x01000000\n#define SCOM_STATUS_PARITY\t\t0x04000000\n#define SCOM_STATUS_PIB_ABORT\t\t0x00100000\n#define SCOM_STATUS_PIB_RESP_MASK\t0x00007000\n#define SCOM_STATUS_PIB_RESP_SHIFT\t12\n\n#define SCOM_STATUS_FSI2PIB_ERROR\t(SCOM_STATUS_PROTECTION |\t\\\n\t\t\t\t\t SCOM_STATUS_PARITY |\t\t\\\n\t\t\t\t\t SCOM_STATUS_PIB_ABORT)\n#define SCOM_STATUS_ANY_ERR\t\t(SCOM_STATUS_FSI2PIB_ERROR |\t\\\n\t\t\t\t\t SCOM_STATUS_PIB_RESP_MASK)\n \n#define XSCOM_ADDR_IND_FLAG\t\tBIT_ULL(63)\n#define XSCOM_ADDR_INF_FORM1\t\tBIT_ULL(60)\n\n \n#define XSCOM_ADDR_DIRECT_PART\t\t0x7fffffffull\n#define XSCOM_ADDR_INDIRECT_PART\t0x000fffff00000000ull\n#define XSCOM_DATA_IND_READ\t\tBIT_ULL(63)\n#define XSCOM_DATA_IND_COMPLETE\t\tBIT_ULL(31)\n#define XSCOM_DATA_IND_ERR_MASK\t\t0x70000000ull\n#define XSCOM_DATA_IND_ERR_SHIFT\t28\n#define XSCOM_DATA_IND_DATA\t\t0x0000ffffull\n#define XSCOM_DATA_IND_FORM1_DATA\t0x000fffffffffffffull\n#define XSCOM_ADDR_FORM1_LOW\t\t0x000ffffffffull\n#define XSCOM_ADDR_FORM1_HI\t\t0xfff00000000ull\n#define XSCOM_ADDR_FORM1_HI_SHIFT\t20\n\n \n#define SCOM_MAX_IND_RETRIES\t\t10\t \n\nstruct scom_device {\n\tstruct list_head link;\n\tstruct fsi_device *fsi_dev;\n\tstruct device dev;\n\tstruct cdev cdev;\n\tstruct mutex lock;\n\tbool dead;\n};\n\nstatic int __put_scom(struct scom_device *scom_dev, uint64_t value,\n\t\t      uint32_t addr, uint32_t *status)\n{\n\t__be32 data, raw_status;\n\tint rc;\n\n\tdata = cpu_to_be32((value >> 32) & 0xffffffff);\n\trc = fsi_device_write(scom_dev->fsi_dev, SCOM_DATA0_REG, &data,\n\t\t\t\tsizeof(uint32_t));\n\tif (rc)\n\t\treturn rc;\n\n\tdata = cpu_to_be32(value & 0xffffffff);\n\trc = fsi_device_write(scom_dev->fsi_dev, SCOM_DATA1_REG, &data,\n\t\t\t\tsizeof(uint32_t));\n\tif (rc)\n\t\treturn rc;\n\n\tdata = cpu_to_be32(SCOM_WRITE_CMD | addr);\n\trc = fsi_device_write(scom_dev->fsi_dev, SCOM_CMD_REG, &data,\n\t\t\t\tsizeof(uint32_t));\n\tif (rc)\n\t\treturn rc;\n\trc = fsi_device_read(scom_dev->fsi_dev, SCOM_STATUS_REG, &raw_status,\n\t\t\t     sizeof(uint32_t));\n\tif (rc)\n\t\treturn rc;\n\t*status = be32_to_cpu(raw_status);\n\n\treturn 0;\n}\n\nstatic int __get_scom(struct scom_device *scom_dev, uint64_t *value,\n\t\t      uint32_t addr, uint32_t *status)\n{\n\t__be32 data, raw_status;\n\tint rc;\n\n\n\t*value = 0ULL;\n\tdata = cpu_to_be32(SCOM_READ_CMD | addr);\n\trc = fsi_device_write(scom_dev->fsi_dev, SCOM_CMD_REG, &data,\n\t\t\t\tsizeof(uint32_t));\n\tif (rc)\n\t\treturn rc;\n\trc = fsi_device_read(scom_dev->fsi_dev, SCOM_STATUS_REG, &raw_status,\n\t\t\t     sizeof(uint32_t));\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = fsi_device_read(scom_dev->fsi_dev, SCOM_DATA0_REG, &data,\n\t\t\t\tsizeof(uint32_t));\n\tif (rc)\n\t\treturn rc;\n\t*value |= (uint64_t)be32_to_cpu(data) << 32;\n\trc = fsi_device_read(scom_dev->fsi_dev, SCOM_DATA1_REG, &data,\n\t\t\t\tsizeof(uint32_t));\n\tif (rc)\n\t\treturn rc;\n\t*value |= be32_to_cpu(data);\n\t*status = be32_to_cpu(raw_status);\n\n\treturn rc;\n}\n\nstatic int put_indirect_scom_form0(struct scom_device *scom, uint64_t value,\n\t\t\t\t   uint64_t addr, uint32_t *status)\n{\n\tuint64_t ind_data, ind_addr;\n\tint rc, err;\n\n\tif (value & ~XSCOM_DATA_IND_DATA)\n\t\treturn -EINVAL;\n\n\tind_addr = addr & XSCOM_ADDR_DIRECT_PART;\n\tind_data = (addr & XSCOM_ADDR_INDIRECT_PART) | value;\n\trc = __put_scom(scom, ind_data, ind_addr, status);\n\tif (rc || (*status & SCOM_STATUS_ANY_ERR))\n\t\treturn rc;\n\n\trc = __get_scom(scom, &ind_data, addr, status);\n\tif (rc || (*status & SCOM_STATUS_ANY_ERR))\n\t\treturn rc;\n\n\terr = (ind_data & XSCOM_DATA_IND_ERR_MASK) >> XSCOM_DATA_IND_ERR_SHIFT;\n\t*status = err << SCOM_STATUS_PIB_RESP_SHIFT;\n\n\treturn 0;\n}\n\nstatic int put_indirect_scom_form1(struct scom_device *scom, uint64_t value,\n\t\t\t\t   uint64_t addr, uint32_t *status)\n{\n\tuint64_t ind_data, ind_addr;\n\n\tif (value & ~XSCOM_DATA_IND_FORM1_DATA)\n\t\treturn -EINVAL;\n\n\tind_addr = addr & XSCOM_ADDR_FORM1_LOW;\n\tind_data = value | (addr & XSCOM_ADDR_FORM1_HI) << XSCOM_ADDR_FORM1_HI_SHIFT;\n\treturn __put_scom(scom, ind_data, ind_addr, status);\n}\n\nstatic int get_indirect_scom_form0(struct scom_device *scom, uint64_t *value,\n\t\t\t\t   uint64_t addr, uint32_t *status)\n{\n\tuint64_t ind_data, ind_addr;\n\tint rc, err;\n\n\tind_addr = addr & XSCOM_ADDR_DIRECT_PART;\n\tind_data = (addr & XSCOM_ADDR_INDIRECT_PART) | XSCOM_DATA_IND_READ;\n\trc = __put_scom(scom, ind_data, ind_addr, status);\n\tif (rc || (*status & SCOM_STATUS_ANY_ERR))\n\t\treturn rc;\n\n\trc = __get_scom(scom, &ind_data, addr, status);\n\tif (rc || (*status & SCOM_STATUS_ANY_ERR))\n\t\treturn rc;\n\n\terr = (ind_data & XSCOM_DATA_IND_ERR_MASK) >> XSCOM_DATA_IND_ERR_SHIFT;\n\t*status = err << SCOM_STATUS_PIB_RESP_SHIFT;\n\t*value = ind_data & XSCOM_DATA_IND_DATA;\n\n\treturn 0;\n}\n\nstatic int raw_put_scom(struct scom_device *scom, uint64_t value,\n\t\t\tuint64_t addr, uint32_t *status)\n{\n\tif (addr & XSCOM_ADDR_IND_FLAG) {\n\t\tif (addr & XSCOM_ADDR_INF_FORM1)\n\t\t\treturn put_indirect_scom_form1(scom, value, addr, status);\n\t\telse\n\t\t\treturn put_indirect_scom_form0(scom, value, addr, status);\n\t} else\n\t\treturn __put_scom(scom, value, addr, status);\n}\n\nstatic int raw_get_scom(struct scom_device *scom, uint64_t *value,\n\t\t\tuint64_t addr, uint32_t *status)\n{\n\tif (addr & XSCOM_ADDR_IND_FLAG) {\n\t\tif (addr & XSCOM_ADDR_INF_FORM1)\n\t\t\treturn -ENXIO;\n\t\treturn get_indirect_scom_form0(scom, value, addr, status);\n\t} else\n\t\treturn __get_scom(scom, value, addr, status);\n}\n\nstatic int handle_fsi2pib_status(struct scom_device *scom, uint32_t status)\n{\n\tuint32_t dummy = -1;\n\n\tif (status & SCOM_STATUS_FSI2PIB_ERROR)\n\t\tfsi_device_write(scom->fsi_dev, SCOM_FSI2PIB_RESET_REG, &dummy,\n\t\t\t\t sizeof(uint32_t));\n\n\tif (status & SCOM_STATUS_PROTECTION)\n\t\treturn -EPERM;\n\tif (status & SCOM_STATUS_PARITY)\n\t\treturn -EIO;\n\n\tif (status & SCOM_STATUS_PIB_ABORT)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic int handle_pib_status(struct scom_device *scom, uint8_t status)\n{\n\tuint32_t dummy = -1;\n\n\tif (status == SCOM_PIB_SUCCESS)\n\t\treturn 0;\n\tif (status == SCOM_PIB_BLOCKED)\n\t\treturn -EBUSY;\n\n\t \n\tfsi_device_write(scom->fsi_dev, SCOM_FSI2PIB_RESET_REG, &dummy,\n\t\t\t sizeof(uint32_t));\n\n\tswitch(status) {\n\tcase SCOM_PIB_OFFLINE:\n\t\treturn -ENODEV;\n\tcase SCOM_PIB_BAD_ADDR:\n\t\treturn -ENXIO;\n\tcase SCOM_PIB_TIMEOUT:\n\t\treturn -ETIMEDOUT;\n\tcase SCOM_PIB_PARTIAL:\n\tcase SCOM_PIB_CLK_ERR:\n\tcase SCOM_PIB_PARITY_ERR:\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int put_scom(struct scom_device *scom, uint64_t value,\n\t\t    uint64_t addr)\n{\n\tuint32_t status;\n\tint rc;\n\n\trc = raw_put_scom(scom, value, addr, &status);\n\tif (rc)\n\t\treturn rc;\n\n\trc = handle_fsi2pib_status(scom, status);\n\tif (rc)\n\t\treturn rc;\n\n\treturn handle_pib_status(scom,\n\t\t\t\t (status & SCOM_STATUS_PIB_RESP_MASK)\n\t\t\t\t >> SCOM_STATUS_PIB_RESP_SHIFT);\n}\n\nstatic int get_scom(struct scom_device *scom, uint64_t *value,\n\t\t    uint64_t addr)\n{\n\tuint32_t status;\n\tint rc;\n\n\trc = raw_get_scom(scom, value, addr, &status);\n\tif (rc)\n\t\treturn rc;\n\n\trc = handle_fsi2pib_status(scom, status);\n\tif (rc)\n\t\treturn rc;\n\n\treturn handle_pib_status(scom,\n\t\t\t\t (status & SCOM_STATUS_PIB_RESP_MASK)\n\t\t\t\t >> SCOM_STATUS_PIB_RESP_SHIFT);\n}\n\nstatic ssize_t scom_read(struct file *filep, char __user *buf, size_t len,\n\t\t\t loff_t *offset)\n{\n\tstruct scom_device *scom = filep->private_data;\n\tstruct device *dev = &scom->fsi_dev->dev;\n\tuint64_t val;\n\tint rc;\n\n\tif (len != sizeof(uint64_t))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&scom->lock);\n\tif (scom->dead)\n\t\trc = -ENODEV;\n\telse\n\t\trc = get_scom(scom, &val, *offset);\n\tmutex_unlock(&scom->lock);\n\tif (rc) {\n\t\tdev_dbg(dev, \"get_scom fail:%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = copy_to_user(buf, &val, len);\n\tif (rc)\n\t\tdev_dbg(dev, \"copy to user failed:%d\\n\", rc);\n\n\treturn rc ? rc : len;\n}\n\nstatic ssize_t scom_write(struct file *filep, const char __user *buf,\n\t\t\t  size_t len, loff_t *offset)\n{\n\tint rc;\n\tstruct scom_device *scom = filep->private_data;\n\tstruct device *dev = &scom->fsi_dev->dev;\n\tuint64_t val;\n\n\tif (len != sizeof(uint64_t))\n\t\treturn -EINVAL;\n\n\trc = copy_from_user(&val, buf, len);\n\tif (rc) {\n\t\tdev_dbg(dev, \"copy from user failed:%d\\n\", rc);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&scom->lock);\n\tif (scom->dead)\n\t\trc = -ENODEV;\n\telse\n\t\trc = put_scom(scom, val, *offset);\n\tmutex_unlock(&scom->lock);\n\tif (rc) {\n\t\tdev_dbg(dev, \"put_scom failed with:%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn len;\n}\n\nstatic loff_t scom_llseek(struct file *file, loff_t offset, int whence)\n{\n\tswitch (whence) {\n\tcase SEEK_CUR:\n\t\tbreak;\n\tcase SEEK_SET:\n\t\tfile->f_pos = offset;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn offset;\n}\n\nstatic void raw_convert_status(struct scom_access *acc, uint32_t status)\n{\n\tacc->pib_status = (status & SCOM_STATUS_PIB_RESP_MASK) >>\n\t\tSCOM_STATUS_PIB_RESP_SHIFT;\n\tacc->intf_errors = 0;\n\n\tif (status & SCOM_STATUS_PROTECTION)\n\t\tacc->intf_errors |= SCOM_INTF_ERR_PROTECTION;\n\telse if (status & SCOM_STATUS_PARITY)\n\t\tacc->intf_errors |= SCOM_INTF_ERR_PARITY;\n\telse if (status & SCOM_STATUS_PIB_ABORT)\n\t\tacc->intf_errors |= SCOM_INTF_ERR_ABORT;\n\telse if (status & SCOM_STATUS_ERR_SUMMARY)\n\t\tacc->intf_errors |= SCOM_INTF_ERR_UNKNOWN;\n}\n\nstatic int scom_raw_read(struct scom_device *scom, void __user *argp)\n{\n\tstruct scom_access acc;\n\tuint32_t status;\n\tint rc;\n\n\tif (copy_from_user(&acc, argp, sizeof(struct scom_access)))\n\t\treturn -EFAULT;\n\n\trc = raw_get_scom(scom, &acc.data, acc.addr, &status);\n\tif (rc)\n\t\treturn rc;\n\traw_convert_status(&acc, status);\n\tif (copy_to_user(argp, &acc, sizeof(struct scom_access)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int scom_raw_write(struct scom_device *scom, void __user *argp)\n{\n\tu64 prev_data, mask, data;\n\tstruct scom_access acc;\n\tuint32_t status;\n\tint rc;\n\n\tif (copy_from_user(&acc, argp, sizeof(struct scom_access)))\n\t\treturn -EFAULT;\n\n\tif (acc.mask) {\n\t\trc = raw_get_scom(scom, &prev_data, acc.addr, &status);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (status & SCOM_STATUS_ANY_ERR)\n\t\t\tgoto fail;\n\t\tmask = acc.mask;\n\t} else {\n\t\tprev_data = mask = -1ull;\n\t}\n\tdata = (prev_data & ~mask) | (acc.data & mask);\n\trc = raw_put_scom(scom, data, acc.addr, &status);\n\tif (rc)\n\t\treturn rc;\n fail:\n\traw_convert_status(&acc, status);\n\tif (copy_to_user(argp, &acc, sizeof(struct scom_access)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int scom_reset(struct scom_device *scom, void __user *argp)\n{\n\tuint32_t flags, dummy = -1;\n\tint rc = 0;\n\n\tif (get_user(flags, (__u32 __user *)argp))\n\t\treturn -EFAULT;\n\tif (flags & SCOM_RESET_PIB)\n\t\trc = fsi_device_write(scom->fsi_dev, SCOM_PIB_RESET_REG, &dummy,\n\t\t\t\t      sizeof(uint32_t));\n\tif (!rc && (flags & (SCOM_RESET_PIB | SCOM_RESET_INTF)))\n\t\trc = fsi_device_write(scom->fsi_dev, SCOM_FSI2PIB_RESET_REG, &dummy,\n\t\t\t\t      sizeof(uint32_t));\n\treturn rc;\n}\n\nstatic int scom_check(struct scom_device *scom, void __user *argp)\n{\n\t \n\treturn put_user(SCOM_CHECK_SUPPORTED, (__u32 __user *)argp);\n}\n\nstatic long scom_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct scom_device *scom = file->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint rc = -ENOTTY;\n\n\tmutex_lock(&scom->lock);\n\tif (scom->dead) {\n\t\tmutex_unlock(&scom->lock);\n\t\treturn -ENODEV;\n\t}\n\tswitch(cmd) {\n\tcase FSI_SCOM_CHECK:\n\t\trc = scom_check(scom, argp);\n\t\tbreak;\n\tcase FSI_SCOM_READ:\n\t\trc = scom_raw_read(scom, argp);\n\t\tbreak;\n\tcase FSI_SCOM_WRITE:\n\t\trc = scom_raw_write(scom, argp);\n\t\tbreak;\n\tcase FSI_SCOM_RESET:\n\t\trc = scom_reset(scom, argp);\n\t\tbreak;\n\t}\n\tmutex_unlock(&scom->lock);\n\treturn rc;\n}\n\nstatic int scom_open(struct inode *inode, struct file *file)\n{\n\tstruct scom_device *scom = container_of(inode->i_cdev, struct scom_device, cdev);\n\n\tfile->private_data = scom;\n\n\treturn 0;\n}\n\nstatic const struct file_operations scom_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= scom_open,\n\t.llseek\t\t= scom_llseek,\n\t.read\t\t= scom_read,\n\t.write\t\t= scom_write,\n\t.unlocked_ioctl\t= scom_ioctl,\n};\n\nstatic void scom_free(struct device *dev)\n{\n\tstruct scom_device *scom = container_of(dev, struct scom_device, dev);\n\n\tput_device(&scom->fsi_dev->dev);\n\tkfree(scom);\n}\n\nstatic int scom_probe(struct device *dev)\n{\n\tstruct fsi_device *fsi_dev = to_fsi_dev(dev);\n\tstruct scom_device *scom;\n\tint rc, didx;\n\n\tscom = kzalloc(sizeof(*scom), GFP_KERNEL);\n\tif (!scom)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, scom);\n\tmutex_init(&scom->lock);\n\n\t \n\tif (!get_device(dev)) {\n\t\tkfree(scom);\n\t\treturn -ENODEV;\n\t}\n\tscom->fsi_dev = fsi_dev;\n\n\t \n\tscom->dev.type = &fsi_cdev_type;\n\tscom->dev.parent = dev;\n\tscom->dev.release = scom_free;\n\tdevice_initialize(&scom->dev);\n\n\t \n\trc = fsi_get_new_minor(fsi_dev, fsi_dev_scom, &scom->dev.devt, &didx);\n\tif (rc)\n\t\tgoto err;\n\n\tdev_set_name(&scom->dev, \"scom%d\", didx);\n\tcdev_init(&scom->cdev, &scom_fops);\n\trc = cdev_device_add(&scom->cdev, &scom->dev);\n\tif (rc) {\n\t\tdev_err(dev, \"Error %d creating char device %s\\n\",\n\t\t\trc, dev_name(&scom->dev));\n\t\tgoto err_free_minor;\n\t}\n\n\treturn 0;\n err_free_minor:\n\tfsi_free_minor(scom->dev.devt);\n err:\n\tput_device(&scom->dev);\n\treturn rc;\n}\n\nstatic int scom_remove(struct device *dev)\n{\n\tstruct scom_device *scom = dev_get_drvdata(dev);\n\n\tmutex_lock(&scom->lock);\n\tscom->dead = true;\n\tmutex_unlock(&scom->lock);\n\tcdev_device_del(&scom->cdev, &scom->dev);\n\tfsi_free_minor(scom->dev.devt);\n\tput_device(&scom->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id scom_of_ids[] = {\n\t{ .compatible = \"ibm,fsi2pib\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, scom_of_ids);\n\nstatic const struct fsi_device_id scom_ids[] = {\n\t{\n\t\t.engine_type = FSI_ENGID_SCOM,\n\t\t.version = FSI_VERSION_ANY,\n\t},\n\t{ 0 }\n};\n\nstatic struct fsi_driver scom_drv = {\n\t.id_table = scom_ids,\n\t.drv = {\n\t\t.name = \"scom\",\n\t\t.bus = &fsi_bus_type,\n\t\t.of_match_table = scom_of_ids,\n\t\t.probe = scom_probe,\n\t\t.remove = scom_remove,\n\t}\n};\n\nstatic int scom_init(void)\n{\n\treturn fsi_driver_register(&scom_drv);\n}\n\nstatic void scom_exit(void)\n{\n\tfsi_driver_unregister(&scom_drv);\n}\n\nmodule_init(scom_init);\nmodule_exit(scom_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}