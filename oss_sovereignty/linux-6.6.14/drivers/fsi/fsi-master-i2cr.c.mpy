{
  "module_name": "fsi-master-i2cr.c",
  "hash_id": "cd120c6c9cfe99fca0bc3add84640f939d2a99a10d24af2c01ebe373877e143e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fsi/fsi-master-i2cr.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/fsi.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n\n#include \"fsi-master-i2cr.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/fsi_master_i2cr.h>\n\n#define I2CR_ADDRESS_CFAM(a)\t((a) >> 2)\n#define I2CR_INITIAL_PARITY\ttrue\n\n#define I2CR_STATUS_CMD\t\t0x60002\n#define  I2CR_STATUS_ERR\t BIT_ULL(61)\n#define I2CR_ERROR_CMD\t\t0x60004\n#define I2CR_LOG_CMD\t\t0x60008\n\nstatic const u8 i2cr_cfam[] = {\n\t0xc0, 0x02, 0x0d, 0xa6,\n\t0x80, 0x01, 0x10, 0x02,\n\t0x80, 0x01, 0x10, 0x02,\n\t0x80, 0x01, 0x10, 0x02,\n\t0x80, 0x01, 0x80, 0x52,\n\t0x80, 0x01, 0x10, 0x02,\n\t0x80, 0x01, 0x10, 0x02,\n\t0x80, 0x01, 0x10, 0x02,\n\t0x80, 0x01, 0x10, 0x02,\n\t0x80, 0x01, 0x22, 0x2d,\n\t0x00, 0x00, 0x00, 0x00,\n\t0xde, 0xad, 0xc0, 0xde\n};\n\nstatic bool i2cr_check_parity32(u32 v, bool parity)\n{\n\tu32 i;\n\n\tfor (i = 0; i < 32; ++i) {\n\t\tif (v & (1u << i))\n\t\t\tparity = !parity;\n\t}\n\n\treturn parity;\n}\n\nstatic bool i2cr_check_parity64(u64 v)\n{\n\tu32 i;\n\tbool parity = I2CR_INITIAL_PARITY;\n\n\tfor (i = 0; i < 64; ++i) {\n\t\tif (v & (1llu << i))\n\t\t\tparity = !parity;\n\t}\n\n\treturn parity;\n}\n\nstatic u32 i2cr_get_command(u32 address, bool parity)\n{\n\taddress <<= 1;\n\n\tif (i2cr_check_parity32(address, parity))\n\t\taddress |= 1;\n\n\treturn address;\n}\n\nstatic int i2cr_transfer(struct i2c_client *client, u32 command, u64 *data)\n{\n\tstruct i2c_msg msgs[2];\n\tint ret;\n\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = sizeof(command);\n\tmsgs[0].buf = (__u8 *)&command;\n\tmsgs[1].addr = client->addr;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].len = sizeof(*data);\n\tmsgs[1].buf = (__u8 *)data;\n\n\tret = i2c_transfer(client->adapter, msgs, 2);\n\tif (ret == 2)\n\t\treturn 0;\n\n\ttrace_i2cr_i2c_error(client, command, ret);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn -EIO;\n}\n\nstatic int i2cr_check_status(struct i2c_client *client)\n{\n\tu64 status;\n\tint ret;\n\n\tret = i2cr_transfer(client, I2CR_STATUS_CMD, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status & I2CR_STATUS_ERR) {\n\t\tu32 buf[3] = { 0, 0, 0 };\n\t\tu64 error;\n\t\tu64 log;\n\n\t\ti2cr_transfer(client, I2CR_ERROR_CMD, &error);\n\t\ti2cr_transfer(client, I2CR_LOG_CMD, &log);\n\n\t\ttrace_i2cr_status_error(client, status, error, log);\n\n\t\tbuf[0] = I2CR_STATUS_CMD;\n\t\ti2c_master_send(client, (const char *)buf, sizeof(buf));\n\n\t\tbuf[0] = I2CR_ERROR_CMD;\n\t\ti2c_master_send(client, (const char *)buf, sizeof(buf));\n\n\t\tbuf[0] = I2CR_LOG_CMD;\n\t\ti2c_master_send(client, (const char *)buf, sizeof(buf));\n\n\t\tdev_err(&client->dev, \"status:%016llx error:%016llx log:%016llx\\n\", status, error,\n\t\t\tlog);\n\t\treturn -EREMOTEIO;\n\t}\n\n\ttrace_i2cr_status(client, status);\n\treturn 0;\n}\n\nint fsi_master_i2cr_read(struct fsi_master_i2cr *i2cr, u32 addr, u64 *data)\n{\n\tu32 command = i2cr_get_command(addr, I2CR_INITIAL_PARITY);\n\tint ret;\n\n\tmutex_lock(&i2cr->lock);\n\n\tret = i2cr_transfer(i2cr->client, command, data);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = i2cr_check_status(i2cr->client);\n\tif (ret)\n\t\tgoto unlock;\n\n\ttrace_i2cr_read(i2cr->client, command, data);\n\nunlock:\n\tmutex_unlock(&i2cr->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(fsi_master_i2cr_read);\n\nint fsi_master_i2cr_write(struct fsi_master_i2cr *i2cr, u32 addr, u64 data)\n{\n\tu32 buf[3] = { 0 };\n\tint ret;\n\n\tbuf[0] = i2cr_get_command(addr, i2cr_check_parity64(data));\n\tmemcpy(&buf[1], &data, sizeof(data));\n\n\tmutex_lock(&i2cr->lock);\n\n\tret = i2c_master_send(i2cr->client, (const char *)buf, sizeof(buf));\n\tif (ret == sizeof(buf)) {\n\t\tret = i2cr_check_status(i2cr->client);\n\t\tif (!ret)\n\t\t\ttrace_i2cr_write(i2cr->client, buf[0], data);\n\t} else {\n\t\ttrace_i2cr_i2c_error(i2cr->client, buf[0], ret);\n\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\n\tmutex_unlock(&i2cr->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(fsi_master_i2cr_write);\n\nstatic int i2cr_read(struct fsi_master *master, int link, uint8_t id, uint32_t addr, void *val,\n\t\t     size_t size)\n{\n\tstruct fsi_master_i2cr *i2cr = container_of(master, struct fsi_master_i2cr, master);\n\tu64 data;\n\tsize_t i;\n\tint ret;\n\n\tif (link || id || (addr & 0xffff0000) || !(size == 1 || size == 2 || size == 4))\n\t\treturn -EINVAL;\n\n\t \n\tif (addr < 0xc00) {\n\t\tif (addr > sizeof(i2cr_cfam) - 4)\n\t\t\taddr = (addr & 0x3) + (sizeof(i2cr_cfam) - 4);\n\n\t\tmemcpy(val, &i2cr_cfam[addr], size);\n\t\treturn 0;\n\t}\n\n\tret = fsi_master_i2cr_read(i2cr, I2CR_ADDRESS_CFAM(addr), &data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < size; ++i)\n\t\t((u8 *)val)[i] = ((u8 *)&data)[7 - i];\n\n\treturn 0;\n}\n\nstatic int i2cr_write(struct fsi_master *master, int link, uint8_t id, uint32_t addr,\n\t\t      const void *val, size_t size)\n{\n\tstruct fsi_master_i2cr *i2cr = container_of(master, struct fsi_master_i2cr, master);\n\tu64 data = 0;\n\tsize_t i;\n\n\tif (link || id || (addr & 0xffff0000) || !(size == 1 || size == 2 || size == 4))\n\t\treturn -EINVAL;\n\n\t \n\tif (addr < 0xc00)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < size; ++i)\n\t\t((u8 *)&data)[7 - i] = ((u8 *)val)[i];\n\n\treturn fsi_master_i2cr_write(i2cr, I2CR_ADDRESS_CFAM(addr), data);\n}\n\nstatic void i2cr_release(struct device *dev)\n{\n\tstruct fsi_master_i2cr *i2cr = to_fsi_master_i2cr(to_fsi_master(dev));\n\n\tof_node_put(dev->of_node);\n\n\tkfree(i2cr);\n}\n\nstatic int i2cr_probe(struct i2c_client *client)\n{\n\tstruct fsi_master_i2cr *i2cr;\n\tint ret;\n\n\ti2cr = kzalloc(sizeof(*i2cr), GFP_KERNEL);\n\tif (!i2cr)\n\t\treturn -ENOMEM;\n\n\t \n\ti2cr->master.idx = client->adapter->nr;\n\tdev_set_name(&i2cr->master.dev, \"i2cr%d\", i2cr->master.idx);\n\ti2cr->master.dev.parent = &client->dev;\n\ti2cr->master.dev.of_node = of_node_get(dev_of_node(&client->dev));\n\ti2cr->master.dev.release = i2cr_release;\n\n\ti2cr->master.n_links = 1;\n\ti2cr->master.read = i2cr_read;\n\ti2cr->master.write = i2cr_write;\n\n\tmutex_init(&i2cr->lock);\n\ti2cr->client = client;\n\n\tret = fsi_master_register(&i2cr->master);\n\tif (ret)\n\t\treturn ret;\n\n\ti2c_set_clientdata(client, i2cr);\n\treturn 0;\n}\n\nstatic void i2cr_remove(struct i2c_client *client)\n{\n\tstruct fsi_master_i2cr *i2cr = i2c_get_clientdata(client);\n\n\tfsi_master_unregister(&i2cr->master);\n}\n\nstatic const struct of_device_id i2cr_ids[] = {\n\t{ .compatible = \"ibm,i2cr-fsi-master\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, i2cr_ids);\n\nstatic struct i2c_driver i2cr_driver = {\n\t.probe = i2cr_probe,\n\t.remove = i2cr_remove,\n\t.driver = {\n\t\t.name = \"fsi-master-i2cr\",\n\t\t.of_match_table = i2cr_ids,\n\t},\n};\n\nmodule_i2c_driver(i2cr_driver)\n\nMODULE_AUTHOR(\"Eddie James <eajames@linux.ibm.com>\");\nMODULE_DESCRIPTION(\"IBM I2C Responder virtual FSI master driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}