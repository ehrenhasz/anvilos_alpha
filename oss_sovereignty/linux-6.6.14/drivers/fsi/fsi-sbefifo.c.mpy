{
  "module_name": "fsi-sbefifo.c",
  "hash_id": "ee3fcc8b0284e02648e47a1babe503b3ba75e44e87726cb46592a6f8fc0efd70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fsi/fsi-sbefifo.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/fsi.h>\n#include <linux/fsi-sbefifo.h>\n#include <linux/kernel.h>\n#include <linux/cdev.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/uio.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n\n#include <uapi/linux/fsi.h>\n\n \n\n#define DEVICE_NAME\t\t\"sbefifo\"\n#define FSI_ENGID_SBE\t\t0x22\n\n \n\n \n#define SBEFIFO_UP\t\t0x00\t\t \n#define SBEFIFO_DOWN\t\t0x40\t\t \n\n \n#define SBEFIFO_FIFO\t\t0x00\t\t \n#define SBEFIFO_STS\t\t0x04\t\t \n#define   SBEFIFO_STS_PARITY_ERR\t0x20000000\n#define   SBEFIFO_STS_RESET_REQ\t\t0x02000000\n#define   SBEFIFO_STS_GOT_EOT\t\t0x00800000\n#define   SBEFIFO_STS_MAX_XFER_LIMIT\t0x00400000\n#define   SBEFIFO_STS_FULL\t\t0x00200000\n#define   SBEFIFO_STS_EMPTY\t\t0x00100000\n#define   SBEFIFO_STS_ECNT_MASK\t\t0x000f0000\n#define   SBEFIFO_STS_ECNT_SHIFT\t16\n#define   SBEFIFO_STS_VALID_MASK\t0x0000ff00\n#define   SBEFIFO_STS_VALID_SHIFT\t8\n#define   SBEFIFO_STS_EOT_MASK\t\t0x000000ff\n#define   SBEFIFO_STS_EOT_SHIFT\t\t0\n#define SBEFIFO_EOT_RAISE\t0x08\t\t \n#define SBEFIFO_REQ_RESET\t0x0C\t\t \n#define SBEFIFO_PERFORM_RESET\t0x10\t\t \n#define SBEFIFO_EOT_ACK\t\t0x14\t\t \n#define SBEFIFO_DOWN_MAX\t0x18\t\t \n\n \n#define CFAM_GP_MBOX_SBM_ADDR\t0x2824\t \n\n#define CFAM_SBM_SBE_BOOTED\t\t0x80000000\n#define CFAM_SBM_SBE_ASYNC_FFDC\t\t0x40000000\n#define CFAM_SBM_SBE_STATE_MASK\t\t0x00f00000\n#define CFAM_SBM_SBE_STATE_SHIFT\t20\n\nenum sbe_state\n{\n\tSBE_STATE_UNKNOWN = 0x0, \n\tSBE_STATE_IPLING  = 0x1, \n\tSBE_STATE_ISTEP   = 0x2, \n\tSBE_STATE_MPIPL   = 0x3, \n\tSBE_STATE_RUNTIME = 0x4, \n\tSBE_STATE_DMT     = 0x5, \n\tSBE_STATE_DUMP    = 0x6, \n\tSBE_STATE_FAILURE = 0x7, \n\tSBE_STATE_QUIESCE = 0x8, \n};\n\n \n#define SBEFIFO_FIFO_DEPTH\t\t8\n\n \n#define sbefifo_empty(sts)\t((sts) & SBEFIFO_STS_EMPTY)\n#define sbefifo_full(sts)\t((sts) & SBEFIFO_STS_FULL)\n#define sbefifo_parity_err(sts)\t((sts) & SBEFIFO_STS_PARITY_ERR)\n#define sbefifo_populated(sts)\t(((sts) & SBEFIFO_STS_ECNT_MASK) >> SBEFIFO_STS_ECNT_SHIFT)\n#define sbefifo_vacant(sts)\t(SBEFIFO_FIFO_DEPTH - sbefifo_populated(sts))\n#define sbefifo_eot_set(sts)\t(((sts) & SBEFIFO_STS_EOT_MASK) >> SBEFIFO_STS_EOT_SHIFT)\n\n \n#define SBEFIFO_RESET_TIMEOUT\t\t10000\n\n \n#define SBEFIFO_TIMEOUT_START_CMD\t10000\n#define SBEFIFO_TIMEOUT_IN_CMD\t\t1000\n#define SBEFIFO_TIMEOUT_START_RSP\t10000\n#define SBEFIFO_TIMEOUT_IN_RSP\t\t1000\n\n \n#define SBEFIFO_MAX_USER_CMD_LEN\t(0x100000 + PAGE_SIZE)\n#define SBEFIFO_RESET_MAGIC\t\t0x52534554  \n\nstruct sbefifo {\n\tuint32_t\t\tmagic;\n#define SBEFIFO_MAGIC\t\t0x53424546  \n\tstruct fsi_device\t*fsi_dev;\n\tstruct device\t\tdev;\n\tstruct cdev\t\tcdev;\n\tstruct mutex\t\tlock;\n\tbool\t\t\tbroken;\n\tbool\t\t\tdead;\n\tbool\t\t\tasync_ffdc;\n\tbool\t\t\ttimed_out;\n\tu32\t\t\ttimeout_in_cmd_ms;\n\tu32\t\t\ttimeout_start_rsp_ms;\n};\n\nstruct sbefifo_user {\n\tstruct sbefifo\t\t*sbefifo;\n\tstruct mutex\t\tfile_lock;\n\tvoid\t\t\t*cmd_page;\n\tvoid\t\t\t*pending_cmd;\n\tsize_t\t\t\tpending_len;\n\tu32\t\t\tcmd_timeout_ms;\n\tu32\t\t\tread_timeout_ms;\n};\n\nstatic DEFINE_MUTEX(sbefifo_ffdc_mutex);\n\nstatic ssize_t timeout_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct sbefifo *sbefifo = container_of(dev, struct sbefifo, dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", sbefifo->timed_out ? 1 : 0);\n}\nstatic DEVICE_ATTR_RO(timeout);\n\nstatic void __sbefifo_dump_ffdc(struct device *dev, const __be32 *ffdc,\n\t\t\t\tsize_t ffdc_sz, bool internal)\n{\n\tint pack = 0;\n#define FFDC_LSIZE\t60\n\tstatic char ffdc_line[FFDC_LSIZE];\n\tchar *p = ffdc_line;\n\n\twhile (ffdc_sz) {\n\t\tu32 w0, w1, w2, i;\n\t\tif (ffdc_sz < 3) {\n\t\t\tdev_err(dev, \"SBE invalid FFDC package size %zd\\n\", ffdc_sz);\n\t\t\treturn;\n\t\t}\n\t\tw0 = be32_to_cpu(*(ffdc++));\n\t\tw1 = be32_to_cpu(*(ffdc++));\n\t\tw2 = be32_to_cpu(*(ffdc++));\n\t\tffdc_sz -= 3;\n\t\tif ((w0 >> 16) != 0xFFDC) {\n\t\t\tdev_err(dev, \"SBE invalid FFDC package signature %08x %08x %08x\\n\",\n\t\t\t\tw0, w1, w2);\n\t\t\tbreak;\n\t\t}\n\t\tw0 &= 0xffff;\n\t\tif (w0 > ffdc_sz) {\n\t\t\tdev_err(dev, \"SBE FFDC package len %d words but only %zd remaining\\n\",\n\t\t\t\tw0, ffdc_sz);\n\t\t\tw0 = ffdc_sz;\n\t\t\tbreak;\n\t\t}\n\t\tif (internal) {\n\t\t\tdev_warn(dev, \"+---- SBE FFDC package %d for async err -----+\\n\",\n\t\t\t\t pack++);\n\t\t} else {\n\t\t\tdev_warn(dev, \"+---- SBE FFDC package %d for cmd %02x:%02x -----+\\n\",\n\t\t\t\t pack++, (w1 >> 8) & 0xff, w1 & 0xff);\n\t\t}\n\t\tdev_warn(dev, \"| Response code: %08x                   |\\n\", w2);\n\t\tdev_warn(dev, \"|-------------------------------------------|\\n\");\n\t\tfor (i = 0; i < w0; i++) {\n\t\t\tif ((i & 3) == 0) {\n\t\t\t\tp = ffdc_line;\n\t\t\t\tp += sprintf(p, \"| %04x:\", i << 4);\n\t\t\t}\n\t\t\tp += sprintf(p, \" %08x\", be32_to_cpu(*(ffdc++)));\n\t\t\tffdc_sz--;\n\t\t\tif ((i & 3) == 3 || i == (w0 - 1)) {\n\t\t\t\twhile ((i & 3) < 3) {\n\t\t\t\t\tp += sprintf(p, \"         \");\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tdev_warn(dev, \"%s |\\n\", ffdc_line);\n\t\t\t}\n\t\t}\n\t\tdev_warn(dev, \"+-------------------------------------------+\\n\");\n\t}\n}\n\nstatic void sbefifo_dump_ffdc(struct device *dev, const __be32 *ffdc,\n\t\t\t      size_t ffdc_sz, bool internal)\n{\n\tmutex_lock(&sbefifo_ffdc_mutex);\n\t__sbefifo_dump_ffdc(dev, ffdc, ffdc_sz, internal);\n\tmutex_unlock(&sbefifo_ffdc_mutex);\n}\n\nint sbefifo_parse_status(struct device *dev, u16 cmd, __be32 *response,\n\t\t\t size_t resp_len, size_t *data_len)\n{\n\tu32 dh, s0, s1;\n\tsize_t ffdc_sz;\n\n\tif (resp_len < 3) {\n\t\tpr_debug(\"sbefifo: cmd %04x, response too small: %zd\\n\",\n\t\t\t cmd, resp_len);\n\t\treturn -ENXIO;\n\t}\n\tdh = be32_to_cpu(response[resp_len - 1]);\n\tif (dh > resp_len || dh < 3) {\n\t\tdev_err(dev, \"SBE cmd %02x:%02x status offset out of range: %d/%zd\\n\",\n\t\t\tcmd >> 8, cmd & 0xff, dh, resp_len);\n\t\treturn -ENXIO;\n\t}\n\ts0 = be32_to_cpu(response[resp_len - dh]);\n\ts1 = be32_to_cpu(response[resp_len - dh + 1]);\n\tif (((s0 >> 16) != 0xC0DE) || ((s0 & 0xffff) != cmd)) {\n\t\tdev_err(dev, \"SBE cmd %02x:%02x, status signature invalid: 0x%08x 0x%08x\\n\",\n\t\t\tcmd >> 8, cmd & 0xff, s0, s1);\n\t\treturn -ENXIO;\n\t}\n\tif (s1 != 0) {\n\t\tffdc_sz = dh - 3;\n\t\tdev_warn(dev, \"SBE error cmd %02x:%02x status=%04x:%04x\\n\",\n\t\t\t cmd >> 8, cmd & 0xff, s1 >> 16, s1 & 0xffff);\n\t\tif (ffdc_sz)\n\t\t\tsbefifo_dump_ffdc(dev, &response[resp_len - dh + 2],\n\t\t\t\t\t  ffdc_sz, false);\n\t}\n\tif (data_len)\n\t\t*data_len = resp_len - dh;\n\n\t \n\treturn s1;\n}\nEXPORT_SYMBOL_GPL(sbefifo_parse_status);\n\nstatic int sbefifo_regr(struct sbefifo *sbefifo, int reg, u32 *word)\n{\n\t__be32 raw_word;\n\tint rc;\n\n\trc = fsi_device_read(sbefifo->fsi_dev, reg, &raw_word,\n\t\t\t     sizeof(raw_word));\n\tif (rc)\n\t\treturn rc;\n\n\t*word = be32_to_cpu(raw_word);\n\n\treturn 0;\n}\n\nstatic int sbefifo_regw(struct sbefifo *sbefifo, int reg, u32 word)\n{\n\t__be32 raw_word = cpu_to_be32(word);\n\n\treturn fsi_device_write(sbefifo->fsi_dev, reg, &raw_word,\n\t\t\t\tsizeof(raw_word));\n}\n\nstatic int sbefifo_check_sbe_state(struct sbefifo *sbefifo)\n{\n\t__be32 raw_word;\n\tu32 sbm;\n\tint rc;\n\n\trc = fsi_slave_read(sbefifo->fsi_dev->slave, CFAM_GP_MBOX_SBM_ADDR,\n\t\t\t    &raw_word, sizeof(raw_word));\n\tif (rc)\n\t\treturn rc;\n\tsbm = be32_to_cpu(raw_word);\n\n\t \n\tif (!(sbm & CFAM_SBM_SBE_BOOTED))\n\t\treturn -ESHUTDOWN;\n\n\t \n\tswitch ((sbm & CFAM_SBM_SBE_STATE_MASK) >> CFAM_SBM_SBE_STATE_SHIFT) {\n\tcase SBE_STATE_UNKNOWN:\n\t\treturn -ESHUTDOWN;\n\tcase SBE_STATE_DMT:\n\t\treturn -EBUSY;\n\tcase SBE_STATE_IPLING:\n\tcase SBE_STATE_ISTEP:\n\tcase SBE_STATE_MPIPL:\n\tcase SBE_STATE_RUNTIME:\n\tcase SBE_STATE_DUMP:  \n\t\tbreak;\n\tcase SBE_STATE_FAILURE:\n\tcase SBE_STATE_QUIESCE:\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\tif (sbm & CFAM_SBM_SBE_ASYNC_FFDC)\n\t\tsbefifo->async_ffdc = true;\n\n\treturn 0;\n}\n\n \nstatic int sbefifo_down_read(struct sbefifo *sbefifo, __be32 *word)\n{\n\treturn fsi_device_read(sbefifo->fsi_dev, SBEFIFO_DOWN, word,\n\t\t\t       sizeof(*word));\n}\n\nstatic int sbefifo_up_write(struct sbefifo *sbefifo, __be32 word)\n{\n\treturn fsi_device_write(sbefifo->fsi_dev, SBEFIFO_UP, &word,\n\t\t\t\tsizeof(word));\n}\n\nstatic int sbefifo_request_reset(struct sbefifo *sbefifo)\n{\n\tstruct device *dev = &sbefifo->fsi_dev->dev;\n\tunsigned long end_time;\n\tu32 status;\n\tint rc;\n\n\tdev_dbg(dev, \"Requesting FIFO reset\\n\");\n\n\t \n\tsbefifo->broken = true;\n\n\t \n\trc = sbefifo_regw(sbefifo, SBEFIFO_UP | SBEFIFO_REQ_RESET, 1);\n\tif (rc) {\n\t\tdev_err(dev, \"Sending reset request failed, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tend_time = jiffies + msecs_to_jiffies(SBEFIFO_RESET_TIMEOUT);\n\twhile (!time_after(jiffies, end_time)) {\n\t\trc = sbefifo_regr(sbefifo, SBEFIFO_UP | SBEFIFO_STS, &status);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Failed to read UP fifo status during reset\"\n\t\t\t\t\" , rc=%d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (!(status & SBEFIFO_STS_RESET_REQ)) {\n\t\t\tdev_dbg(dev, \"FIFO reset done\\n\");\n\t\t\tsbefifo->broken = false;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\tdev_err(dev, \"FIFO reset timed out\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int sbefifo_cleanup_hw(struct sbefifo *sbefifo)\n{\n\tstruct device *dev = &sbefifo->fsi_dev->dev;\n\tu32 up_status, down_status;\n\tbool need_reset = false;\n\tint rc;\n\n\trc = sbefifo_check_sbe_state(sbefifo);\n\tif (rc) {\n\t\tdev_dbg(dev, \"SBE state=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tif (sbefifo->broken)\n\t\tgoto do_reset;\n\n\trc = sbefifo_regr(sbefifo, SBEFIFO_UP | SBEFIFO_STS, &up_status);\n\tif (rc) {\n\t\tdev_err(dev, \"Cleanup: Reading UP status failed, rc=%d\\n\", rc);\n\n\t\t \n\t\tsbefifo->broken = true;\n\t\treturn rc;\n\t}\n\n\trc = sbefifo_regr(sbefifo, SBEFIFO_DOWN | SBEFIFO_STS, &down_status);\n\tif (rc) {\n\t\tdev_err(dev, \"Cleanup: Reading DOWN status failed, rc=%d\\n\", rc);\n\n\t\t \n\t\tsbefifo->broken = true;\n\t\treturn rc;\n\t}\n\n\t \n\tif (down_status & SBEFIFO_STS_RESET_REQ) {\n\t\tdev_info(dev, \"Cleanup: FIFO reset request set, resetting\\n\");\n\t\trc = sbefifo_regw(sbefifo, SBEFIFO_DOWN, SBEFIFO_PERFORM_RESET);\n\t\tif (rc) {\n\t\t\tsbefifo->broken = true;\n\t\t\tdev_err(dev, \"Cleanup: Reset reg write failed, rc=%d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\tsbefifo->broken = false;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((up_status | down_status) & SBEFIFO_STS_PARITY_ERR)\n\t\tneed_reset = true;\n\n\t \n\tif (!((up_status & down_status) & SBEFIFO_STS_EMPTY))\n\t\tneed_reset = true;\n\n\tif (!need_reset)\n\t\treturn 0;\n\n\tdev_info(dev, \"Cleanup: FIFO not clean (up=0x%08x down=0x%08x)\\n\",\n\t\t up_status, down_status);\n\n do_reset:\n\n\t \n\treturn sbefifo_request_reset(sbefifo);\n}\n\nstatic int sbefifo_wait(struct sbefifo *sbefifo, bool up,\n\t\t\tu32 *status, unsigned long timeout)\n{\n\tstruct device *dev = &sbefifo->fsi_dev->dev;\n\tunsigned long end_time;\n\tbool ready = false;\n\tu32 addr, sts = 0;\n\tint rc;\n\n\tdev_vdbg(dev, \"Wait on %s fifo...\\n\", up ? \"up\" : \"down\");\n\n\taddr = (up ? SBEFIFO_UP : SBEFIFO_DOWN) | SBEFIFO_STS;\n\n\tend_time = jiffies + timeout;\n\twhile (!time_after(jiffies, end_time)) {\n\t\tcond_resched();\n\t\trc = sbefifo_regr(sbefifo, addr, &sts);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"FSI error %d reading status register\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\tif (!up && sbefifo_parity_err(sts)) {\n\t\t\tdev_err(dev, \"Parity error in DOWN FIFO\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tready = !(up ? sbefifo_full(sts) : sbefifo_empty(sts));\n\t\tif (ready)\n\t\t\tbreak;\n\t}\n\tif (!ready) {\n\t\tsysfs_notify(&sbefifo->dev.kobj, NULL, dev_attr_timeout.attr.name);\n\t\tsbefifo->timed_out = true;\n\t\tdev_err(dev, \"%s FIFO Timeout (%u ms)! status=%08x\\n\",\n\t\t\tup ? \"UP\" : \"DOWN\", jiffies_to_msecs(timeout), sts);\n\t\treturn -ETIMEDOUT;\n\t}\n\tdev_vdbg(dev, \"End of wait status: %08x\\n\", sts);\n\n\tsbefifo->timed_out = false;\n\t*status = sts;\n\n\treturn 0;\n}\n\nstatic int sbefifo_send_command(struct sbefifo *sbefifo,\n\t\t\t\tconst __be32 *command, size_t cmd_len)\n{\n\tstruct device *dev = &sbefifo->fsi_dev->dev;\n\tsize_t len, chunk, vacant = 0, remaining = cmd_len;\n\tunsigned long timeout;\n\tu32 status;\n\tint rc;\n\n\tdev_dbg(dev, \"sending command (%zd words, cmd=%04x)\\n\",\n\t\tcmd_len, be32_to_cpu(command[1]));\n\n\t \n\ttimeout = msecs_to_jiffies(SBEFIFO_TIMEOUT_START_CMD);\n\twhile (remaining) {\n\t\t \n\t\trc = sbefifo_wait(sbefifo, true, &status, timeout);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\ttimeout = msecs_to_jiffies(sbefifo->timeout_in_cmd_ms);\n\n\t\tvacant = sbefifo_vacant(status);\n\t\tlen = chunk = min(vacant, remaining);\n\n\t\tdev_vdbg(dev, \"  status=%08x vacant=%zd chunk=%zd\\n\",\n\t\t\t status, vacant, chunk);\n\n\t\t \n\t\twhile (len--) {\n\t\t\trc = sbefifo_up_write(sbefifo, *(command++));\n\t\t\tif (rc) {\n\t\t\t\tdev_err(dev, \"FSI error %d writing UP FIFO\\n\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tremaining -= chunk;\n\t\tvacant -= chunk;\n\t}\n\n\t \n\tif (!vacant) {\n\t\trc = sbefifo_wait(sbefifo, true, &status, timeout);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\trc = sbefifo_regw(sbefifo, SBEFIFO_UP | SBEFIFO_EOT_RAISE, 0);\n\tif (rc)\n\t\tdev_err(dev, \"FSI error %d writing EOT\\n\", rc);\n\treturn rc;\n}\n\nstatic int sbefifo_read_response(struct sbefifo *sbefifo, struct iov_iter *response)\n{\n\tstruct device *dev = &sbefifo->fsi_dev->dev;\n\tu32 status, eot_set;\n\tunsigned long timeout;\n\tbool overflow = false;\n\t__be32 data;\n\tsize_t len;\n\tint rc;\n\n\tdev_dbg(dev, \"reading response, buflen = %zd\\n\", iov_iter_count(response));\n\n\ttimeout = msecs_to_jiffies(sbefifo->timeout_start_rsp_ms);\n\tfor (;;) {\n\t\t \n\t\trc = sbefifo_wait(sbefifo, false, &status, timeout);\n\t\tif (rc < 0) {\n\t\t\tdev_dbg(dev, \"timeout waiting (%u ms)\\n\", jiffies_to_msecs(timeout));\n\t\t\treturn rc;\n\t\t}\n\t\ttimeout = msecs_to_jiffies(SBEFIFO_TIMEOUT_IN_RSP);\n\n\t\t \n\t\tlen = sbefifo_populated(status);\n\t\teot_set = sbefifo_eot_set(status);\n\n\t\tdev_dbg(dev, \"  chunk size %zd eot_set=0x%x\\n\", len, eot_set);\n\n\t\t \n\t\twhile(len--) {\n\t\t\t \n\t\t\trc = sbefifo_down_read(sbefifo, &data);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\t \n\t\t\tif (eot_set & 0x80) {\n\t\t\t\t \n\t\t\t\tif (len) {\n\t\t\t\t\tdev_warn(dev, \"FIFO read hit\"\n\t\t\t\t\t\t \" EOT with still %zd data\\n\",\n\t\t\t\t\t\t len);\n\t\t\t\t\tsbefifo->broken = true;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\trc = sbefifo_regw(sbefifo,\n\t\t\t\t\t\t  SBEFIFO_DOWN | SBEFIFO_EOT_ACK, 0);\n\n\t\t\t\t \n\t\t\t\tif (rc) {\n\t\t\t\t\tdev_err(dev, \"FSI error %d ack'ing EOT\\n\", rc);\n\t\t\t\t\tsbefifo->broken = true;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\treturn overflow ? -EOVERFLOW : 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (iov_iter_count(response) >= sizeof(__be32)) {\n\t\t\t\tif (copy_to_iter(&data, sizeof(__be32), response) < sizeof(__be32))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else {\n\t\t\t\tdev_vdbg(dev, \"Response overflowed !\\n\");\n\n\t\t\t\toverflow = true;\n\t\t\t}\n\n\t\t\t \n\t\t\teot_set <<= 1;\n\t\t}\n\t}\n\t \n\treturn -EIO;\n}\n\nstatic int sbefifo_do_command(struct sbefifo *sbefifo,\n\t\t\t      const __be32 *command, size_t cmd_len,\n\t\t\t      struct iov_iter *response)\n{\n\t \n\tint rc = sbefifo_send_command(sbefifo, command, cmd_len);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treturn sbefifo_read_response(sbefifo, response);\n}\n\nstatic void sbefifo_collect_async_ffdc(struct sbefifo *sbefifo)\n{\n\tstruct device *dev = &sbefifo->fsi_dev->dev;\n        struct iov_iter ffdc_iter;\n        struct kvec ffdc_iov;\n\t__be32 *ffdc;\n\tsize_t ffdc_sz;\n\t__be32 cmd[2];\n\tint rc;\n\n\tsbefifo->async_ffdc = false;\n\tffdc = vmalloc(SBEFIFO_MAX_FFDC_SIZE);\n\tif (!ffdc) {\n\t\tdev_err(dev, \"Failed to allocate SBE FFDC buffer\\n\");\n\t\treturn;\n\t}\n        ffdc_iov.iov_base = ffdc;\n\tffdc_iov.iov_len = SBEFIFO_MAX_FFDC_SIZE;\n        iov_iter_kvec(&ffdc_iter, ITER_DEST, &ffdc_iov, 1, SBEFIFO_MAX_FFDC_SIZE);\n\tcmd[0] = cpu_to_be32(2);\n\tcmd[1] = cpu_to_be32(SBEFIFO_CMD_GET_SBE_FFDC);\n\trc = sbefifo_do_command(sbefifo, cmd, 2, &ffdc_iter);\n\tif (rc != 0) {\n\t\tdev_err(dev, \"Error %d retrieving SBE FFDC\\n\", rc);\n\t\tgoto bail;\n\t}\n\tffdc_sz = SBEFIFO_MAX_FFDC_SIZE - iov_iter_count(&ffdc_iter);\n\tffdc_sz /= sizeof(__be32);\n\trc = sbefifo_parse_status(dev, SBEFIFO_CMD_GET_SBE_FFDC, ffdc,\n\t\t\t\t  ffdc_sz, &ffdc_sz);\n\tif (rc != 0) {\n\t\tdev_err(dev, \"Error %d decoding SBE FFDC\\n\", rc);\n\t\tgoto bail;\n\t}\n\tif (ffdc_sz > 0)\n\t\tsbefifo_dump_ffdc(dev, ffdc, ffdc_sz, true);\n bail:\n\tvfree(ffdc);\n\n}\n\nstatic int __sbefifo_submit(struct sbefifo *sbefifo,\n\t\t\t    const __be32 *command, size_t cmd_len,\n\t\t\t    struct iov_iter *response)\n{\n\tstruct device *dev = &sbefifo->fsi_dev->dev;\n\tint rc;\n\n\tif (sbefifo->dead)\n\t\treturn -ENODEV;\n\n\tif (cmd_len < 2 || be32_to_cpu(command[0]) != cmd_len) {\n\t\tdev_vdbg(dev, \"Invalid command len %zd (header: %d)\\n\",\n\t\t\t cmd_len, be32_to_cpu(command[0]));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trc = sbefifo_cleanup_hw(sbefifo);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (sbefifo->async_ffdc)\n\t\tsbefifo_collect_async_ffdc(sbefifo);\n\n\trc = sbefifo_do_command(sbefifo, command, cmd_len, response);\n\tif (rc != 0 && rc != -EOVERFLOW)\n\t\tgoto fail;\n\treturn rc;\n fail:\n\t \n        sbefifo_request_reset(sbefifo);\n\n\t \n\treturn rc;\n}\n\n \nint sbefifo_submit(struct device *dev, const __be32 *command, size_t cmd_len,\n\t\t   __be32 *response, size_t *resp_len)\n{\n\tstruct sbefifo *sbefifo;\n        struct iov_iter resp_iter;\n        struct kvec resp_iov;\n\tsize_t rbytes;\n\tint rc;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\tsbefifo = dev_get_drvdata(dev);\n\tif (!sbefifo)\n\t\treturn -ENODEV;\n\tif (WARN_ON_ONCE(sbefifo->magic != SBEFIFO_MAGIC))\n\t\treturn -ENODEV;\n\tif (!resp_len || !command || !response)\n\t\treturn -EINVAL;\n\n\t \n\trbytes = (*resp_len) * sizeof(__be32);\n\tresp_iov.iov_base = response;\n\tresp_iov.iov_len = rbytes;\n        iov_iter_kvec(&resp_iter, ITER_DEST, &resp_iov, 1, rbytes);\n\n\t \n\trc = mutex_lock_interruptible(&sbefifo->lock);\n\tif (rc)\n\t\treturn rc;\n\trc = __sbefifo_submit(sbefifo, command, cmd_len, &resp_iter);\n\tmutex_unlock(&sbefifo->lock);\n\n\t \n\trbytes -= iov_iter_count(&resp_iter);\n\t*resp_len = rbytes / sizeof(__be32);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(sbefifo_submit);\n\n \n\nstatic void sbefifo_release_command(struct sbefifo_user *user)\n{\n\tif (is_vmalloc_addr(user->pending_cmd))\n\t\tvfree(user->pending_cmd);\n\tuser->pending_cmd = NULL;\n\tuser->pending_len = 0;\n}\n\nstatic int sbefifo_user_open(struct inode *inode, struct file *file)\n{\n\tstruct sbefifo *sbefifo = container_of(inode->i_cdev, struct sbefifo, cdev);\n\tstruct sbefifo_user *user;\n\n\tuser = kzalloc(sizeof(struct sbefifo_user), GFP_KERNEL);\n\tif (!user)\n\t\treturn -ENOMEM;\n\n\tfile->private_data = user;\n\tuser->sbefifo = sbefifo;\n\tuser->cmd_page = (void *)__get_free_page(GFP_KERNEL);\n\tif (!user->cmd_page) {\n\t\tkfree(user);\n\t\treturn -ENOMEM;\n\t}\n\tmutex_init(&user->file_lock);\n\tuser->cmd_timeout_ms = SBEFIFO_TIMEOUT_IN_CMD;\n\tuser->read_timeout_ms = SBEFIFO_TIMEOUT_START_RSP;\n\n\treturn 0;\n}\n\nstatic ssize_t sbefifo_user_read(struct file *file, char __user *buf,\n\t\t\t\t size_t len, loff_t *offset)\n{\n\tstruct sbefifo_user *user = file->private_data;\n\tstruct sbefifo *sbefifo;\n\tstruct iov_iter resp_iter;\n        struct iovec resp_iov;\n\tsize_t cmd_len;\n\tint rc;\n\n\tif (!user)\n\t\treturn -EINVAL;\n\tsbefifo = user->sbefifo;\n\tif (len & 3)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&user->file_lock);\n\n\t \n\tif (user->pending_len == 0) {\n\t\trc = -EAGAIN;\n\t\tgoto bail;\n\t}\n\tif (user->pending_len < 8) {\n\t\trc = -EINVAL;\n\t\tgoto bail;\n\t}\n\tcmd_len = user->pending_len >> 2;\n\n\t \n\tresp_iov.iov_base = buf;\n\tresp_iov.iov_len = len;\n\tiov_iter_init(&resp_iter, ITER_DEST, &resp_iov, 1, len);\n\n\t \n\trc = mutex_lock_interruptible(&sbefifo->lock);\n\tif (rc)\n\t\tgoto bail;\n\tsbefifo->timeout_in_cmd_ms = user->cmd_timeout_ms;\n\tsbefifo->timeout_start_rsp_ms = user->read_timeout_ms;\n\trc = __sbefifo_submit(sbefifo, user->pending_cmd, cmd_len, &resp_iter);\n\tsbefifo->timeout_start_rsp_ms = SBEFIFO_TIMEOUT_START_RSP;\n\tsbefifo->timeout_in_cmd_ms = SBEFIFO_TIMEOUT_IN_CMD;\n\tmutex_unlock(&sbefifo->lock);\n\tif (rc < 0)\n\t\tgoto bail;\n\n\t \n\trc = len - iov_iter_count(&resp_iter);\n bail:\n\tsbefifo_release_command(user);\n\tmutex_unlock(&user->file_lock);\n\treturn rc;\n}\n\nstatic ssize_t sbefifo_user_write(struct file *file, const char __user *buf,\n\t\t\t\t  size_t len, loff_t *offset)\n{\n\tstruct sbefifo_user *user = file->private_data;\n\tstruct sbefifo *sbefifo;\n\tint rc = len;\n\n\tif (!user)\n\t\treturn -EINVAL;\n\tsbefifo = user->sbefifo;\n\tif (len > SBEFIFO_MAX_USER_CMD_LEN)\n\t\treturn -EINVAL;\n\tif (len & 3)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&user->file_lock);\n\n\t \n\tif (len <= PAGE_SIZE)\n\t\tuser->pending_cmd = user->cmd_page;\n\telse\n\t\tuser->pending_cmd = vmalloc(len);\n\tif (!user->pending_cmd) {\n\t\trc = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\t \n\tif (copy_from_user(user->pending_cmd, buf, len)) {\n\t\trc = -EFAULT;\n\t\tgoto bail;\n\t}\n\n\t \n\tif (len == 4 && be32_to_cpu(*(__be32 *)user->pending_cmd) ==\n\t    SBEFIFO_RESET_MAGIC)  {\n\n\t\t \n\t\tuser->pending_len = 0;\n\n\t\t \n\t\trc = mutex_lock_interruptible(&sbefifo->lock);\n\t\tif (rc)\n\t\t\tgoto bail;\n\t\trc = sbefifo_request_reset(user->sbefifo);\n\t\tmutex_unlock(&sbefifo->lock);\n\t\tif (rc == 0)\n\t\t\trc = 4;\n\t\tgoto bail;\n\t}\n\n\t \n\tuser->pending_len = len;\n bail:\n\tif (!user->pending_len)\n\t\tsbefifo_release_command(user);\n\n\tmutex_unlock(&user->file_lock);\n\n\t \n\treturn rc;\n}\n\nstatic int sbefifo_user_release(struct inode *inode, struct file *file)\n{\n\tstruct sbefifo_user *user = file->private_data;\n\n\tif (!user)\n\t\treturn -EINVAL;\n\n\tsbefifo_release_command(user);\n\tfree_page((unsigned long)user->cmd_page);\n\tkfree(user);\n\n\treturn 0;\n}\n\nstatic int sbefifo_cmd_timeout(struct sbefifo_user *user, void __user *argp)\n{\n\tstruct device *dev = &user->sbefifo->dev;\n\tu32 timeout;\n\n\tif (get_user(timeout, (__u32 __user *)argp))\n\t\treturn -EFAULT;\n\n\tif (timeout == 0) {\n\t\tuser->cmd_timeout_ms = SBEFIFO_TIMEOUT_IN_CMD;\n\t\tdev_dbg(dev, \"Command timeout reset to %us\\n\", user->cmd_timeout_ms / 1000);\n\t\treturn 0;\n\t}\n\n\tuser->cmd_timeout_ms = timeout * 1000;  \n\tdev_dbg(dev, \"Command timeout set to %us\\n\", timeout);\n\treturn 0;\n}\n\nstatic int sbefifo_read_timeout(struct sbefifo_user *user, void __user *argp)\n{\n\tstruct device *dev = &user->sbefifo->dev;\n\tu32 timeout;\n\n\tif (get_user(timeout, (__u32 __user *)argp))\n\t\treturn -EFAULT;\n\n\tif (timeout == 0) {\n\t\tuser->read_timeout_ms = SBEFIFO_TIMEOUT_START_RSP;\n\t\tdev_dbg(dev, \"Timeout reset to %us\\n\", user->read_timeout_ms / 1000);\n\t\treturn 0;\n\t}\n\n\tuser->read_timeout_ms = timeout * 1000;  \n\tdev_dbg(dev, \"Timeout set to %us\\n\", timeout);\n\treturn 0;\n}\n\nstatic long sbefifo_user_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct sbefifo_user *user = file->private_data;\n\tint rc = -ENOTTY;\n\n\tif (!user)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&user->file_lock);\n\tswitch (cmd) {\n\tcase FSI_SBEFIFO_CMD_TIMEOUT_SECONDS:\n\t\trc = sbefifo_cmd_timeout(user, (void __user *)arg);\n\t\tbreak;\n\tcase FSI_SBEFIFO_READ_TIMEOUT_SECONDS:\n\t\trc = sbefifo_read_timeout(user, (void __user *)arg);\n\t\tbreak;\n\t}\n\tmutex_unlock(&user->file_lock);\n\treturn rc;\n}\n\nstatic const struct file_operations sbefifo_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= sbefifo_user_open,\n\t.read\t\t= sbefifo_user_read,\n\t.write\t\t= sbefifo_user_write,\n\t.release\t= sbefifo_user_release,\n\t.unlocked_ioctl = sbefifo_user_ioctl,\n};\n\nstatic void sbefifo_free(struct device *dev)\n{\n\tstruct sbefifo *sbefifo = container_of(dev, struct sbefifo, dev);\n\n\tput_device(&sbefifo->fsi_dev->dev);\n\tkfree(sbefifo);\n}\n\n \n\nstatic int sbefifo_probe(struct device *dev)\n{\n\tstruct fsi_device *fsi_dev = to_fsi_dev(dev);\n\tstruct sbefifo *sbefifo;\n\tstruct device_node *np;\n\tstruct platform_device *child;\n\tchar child_name[32];\n\tint rc, didx, child_idx = 0;\n\n\tdev_dbg(dev, \"Found sbefifo device\\n\");\n\n\tsbefifo = kzalloc(sizeof(*sbefifo), GFP_KERNEL);\n\tif (!sbefifo)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!get_device(dev)) {\n\t\tkfree(sbefifo);\n\t\treturn -ENODEV;\n\t}\n\n\tsbefifo->magic = SBEFIFO_MAGIC;\n\tsbefifo->fsi_dev = fsi_dev;\n\tdev_set_drvdata(dev, sbefifo);\n\tmutex_init(&sbefifo->lock);\n\tsbefifo->timeout_in_cmd_ms = SBEFIFO_TIMEOUT_IN_CMD;\n\tsbefifo->timeout_start_rsp_ms = SBEFIFO_TIMEOUT_START_RSP;\n\n\t \n\tsbefifo->dev.type = &fsi_cdev_type;\n\tsbefifo->dev.parent = dev;\n\tsbefifo->dev.release = sbefifo_free;\n\tdevice_initialize(&sbefifo->dev);\n\n\t \n\trc = fsi_get_new_minor(fsi_dev, fsi_dev_sbefifo, &sbefifo->dev.devt, &didx);\n\tif (rc)\n\t\tgoto err;\n\n\tdev_set_name(&sbefifo->dev, \"sbefifo%d\", didx);\n\tcdev_init(&sbefifo->cdev, &sbefifo_fops);\n\trc = cdev_device_add(&sbefifo->cdev, &sbefifo->dev);\n\tif (rc) {\n\t\tdev_err(dev, \"Error %d creating char device %s\\n\",\n\t\t\trc, dev_name(&sbefifo->dev));\n\t\tgoto err_free_minor;\n\t}\n\n\t \n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tsnprintf(child_name, sizeof(child_name), \"%s-dev%d\",\n\t\t\t dev_name(&sbefifo->dev), child_idx++);\n\t\tchild = of_platform_device_create(np, child_name, dev);\n\t\tif (!child)\n\t\t\tdev_warn(dev, \"failed to create child %s dev\\n\",\n\t\t\t\t child_name);\n\t}\n\n\tdevice_create_file(&sbefifo->dev, &dev_attr_timeout);\n\n\treturn 0;\n err_free_minor:\n\tfsi_free_minor(sbefifo->dev.devt);\n err:\n\tput_device(&sbefifo->dev);\n\treturn rc;\n}\n\nstatic int sbefifo_unregister_child(struct device *dev, void *data)\n{\n\tstruct platform_device *child = to_platform_device(dev);\n\n\tof_device_unregister(child);\n\tif (dev->of_node)\n\t\tof_node_clear_flag(dev->of_node, OF_POPULATED);\n\n\treturn 0;\n}\n\nstatic int sbefifo_remove(struct device *dev)\n{\n\tstruct sbefifo *sbefifo = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"Removing sbefifo device...\\n\");\n\n\tdevice_remove_file(&sbefifo->dev, &dev_attr_timeout);\n\n\tmutex_lock(&sbefifo->lock);\n\tsbefifo->dead = true;\n\tmutex_unlock(&sbefifo->lock);\n\n\tcdev_device_del(&sbefifo->cdev, &sbefifo->dev);\n\tfsi_free_minor(sbefifo->dev.devt);\n\tdevice_for_each_child(dev, NULL, sbefifo_unregister_child);\n\tput_device(&sbefifo->dev);\n\n\treturn 0;\n}\n\nstatic const struct fsi_device_id sbefifo_ids[] = {\n\t{\n\t\t.engine_type = FSI_ENGID_SBE,\n\t\t.version = FSI_VERSION_ANY,\n\t},\n\t{ 0 }\n};\n\nstatic struct fsi_driver sbefifo_drv = {\n\t.id_table = sbefifo_ids,\n\t.drv = {\n\t\t.name = DEVICE_NAME,\n\t\t.bus = &fsi_bus_type,\n\t\t.probe = sbefifo_probe,\n\t\t.remove = sbefifo_remove,\n\t}\n};\n\nstatic int sbefifo_init(void)\n{\n\treturn fsi_driver_register(&sbefifo_drv);\n}\n\nstatic void sbefifo_exit(void)\n{\n\tfsi_driver_unregister(&sbefifo_drv);\n}\n\nmodule_init(sbefifo_init);\nmodule_exit(sbefifo_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Brad Bishop <bradleyb@fuzziesquirrel.com>\");\nMODULE_AUTHOR(\"Eddie James <eajames@linux.vnet.ibm.com>\");\nMODULE_AUTHOR(\"Andrew Jeffery <andrew@aj.id.au>\");\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"Linux device interface to the POWER Self Boot Engine\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}