{
  "module_name": "fsi-master-gpio.c",
  "hash_id": "4306223c265bae533d6a149a4619d316871c2707c8ec4d7cda8f97077055ee9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fsi/fsi-master-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/crc4.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/fsi.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/irqflags.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"fsi-master.h\"\n\n#define\tFSI_GPIO_STD_DLY\t1\t \n#define LAST_ADDR_INVALID\t\t0x1\n\nstruct fsi_master_gpio {\n\tstruct fsi_master\tmaster;\n\tstruct device\t\t*dev;\n\tstruct mutex\t\tcmd_lock;\t \n\tstruct gpio_desc\t*gpio_clk;\n\tstruct gpio_desc\t*gpio_data;\n\tstruct gpio_desc\t*gpio_trans;\t \n\tstruct gpio_desc\t*gpio_enable;\t \n\tstruct gpio_desc\t*gpio_mux;\t \n\tbool\t\t\texternal_mode;\n\tbool\t\t\tno_delays;\n\tuint32_t\t\tlast_addr;\n\tuint8_t\t\t\tt_send_delay;\n\tuint8_t\t\t\tt_echo_delay;\n};\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/fsi_master_gpio.h>\n\n#define to_fsi_master_gpio(m) container_of(m, struct fsi_master_gpio, master)\n\nstruct fsi_gpio_msg {\n\tuint64_t\tmsg;\n\tuint8_t\t\tbits;\n};\n\nstatic void clock_toggle(struct fsi_master_gpio *master, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (!master->no_delays)\n\t\t\tndelay(FSI_GPIO_STD_DLY);\n\t\tgpiod_set_value(master->gpio_clk, 0);\n\t\tif (!master->no_delays)\n\t\t\tndelay(FSI_GPIO_STD_DLY);\n\t\tgpiod_set_value(master->gpio_clk, 1);\n\t}\n}\n\nstatic int sda_clock_in(struct fsi_master_gpio *master)\n{\n\tint in;\n\n\tif (!master->no_delays)\n\t\tndelay(FSI_GPIO_STD_DLY);\n\tgpiod_set_value(master->gpio_clk, 0);\n\n\t \n\tgpiod_get_value(master->gpio_data);\n\n\t \n\tin = gpiod_get_value(master->gpio_data);\n\tif (!master->no_delays)\n\t\tndelay(FSI_GPIO_STD_DLY);\n\tgpiod_set_value(master->gpio_clk, 1);\n\treturn in ? 1 : 0;\n}\n\nstatic void sda_out(struct fsi_master_gpio *master, int value)\n{\n\tgpiod_set_value(master->gpio_data, value);\n}\n\nstatic void set_sda_input(struct fsi_master_gpio *master)\n{\n\tgpiod_direction_input(master->gpio_data);\n\tgpiod_set_value(master->gpio_trans, 0);\n}\n\nstatic void set_sda_output(struct fsi_master_gpio *master, int value)\n{\n\tgpiod_set_value(master->gpio_trans, 1);\n\tgpiod_direction_output(master->gpio_data, value);\n}\n\nstatic void clock_zeros(struct fsi_master_gpio *master, int count)\n{\n\ttrace_fsi_master_gpio_clock_zeros(master, count);\n\tset_sda_output(master, 1);\n\tclock_toggle(master, count);\n}\n\nstatic void echo_delay(struct fsi_master_gpio *master)\n{\n\tclock_zeros(master, master->t_echo_delay);\n}\n\n\nstatic void serial_in(struct fsi_master_gpio *master, struct fsi_gpio_msg *msg,\n\t\t\tuint8_t num_bits)\n{\n\tuint8_t bit, in_bit;\n\n\tset_sda_input(master);\n\n\tfor (bit = 0; bit < num_bits; bit++) {\n\t\tin_bit = sda_clock_in(master);\n\t\tmsg->msg <<= 1;\n\t\tmsg->msg |= ~in_bit & 0x1;\t \n\t}\n\tmsg->bits += num_bits;\n\n\ttrace_fsi_master_gpio_in(master, num_bits, msg->msg);\n}\n\nstatic void serial_out(struct fsi_master_gpio *master,\n\t\t\tconst struct fsi_gpio_msg *cmd)\n{\n\tuint8_t bit;\n\tuint64_t msg = ~cmd->msg;\t \n\tuint64_t sda_mask = 0x1ULL << (cmd->bits - 1);\n\tuint64_t last_bit = ~0;\n\tint next_bit;\n\n\ttrace_fsi_master_gpio_out(master, cmd->bits, cmd->msg);\n\n\tif (!cmd->bits) {\n\t\tdev_warn(master->dev, \"trying to output 0 bits\\n\");\n\t\treturn;\n\t}\n\tset_sda_output(master, 0);\n\n\t \n\tsda_out(master, 0);\n\tclock_toggle(master, 1);\n\n\t \n\tfor (bit = 0; bit < cmd->bits; bit++) {\n\t\tnext_bit = (msg & sda_mask) >> (cmd->bits - 1);\n\t\tif (last_bit ^ next_bit) {\n\t\t\tsda_out(master, next_bit);\n\t\t\tlast_bit = next_bit;\n\t\t}\n\t\tclock_toggle(master, 1);\n\t\tmsg <<= 1;\n\t}\n}\n\nstatic void msg_push_bits(struct fsi_gpio_msg *msg, uint64_t data, int bits)\n{\n\tmsg->msg <<= bits;\n\tmsg->msg |= data & ((1ull << bits) - 1);\n\tmsg->bits += bits;\n}\n\nstatic void msg_push_crc(struct fsi_gpio_msg *msg)\n{\n\tuint8_t crc;\n\tint top;\n\n\ttop = msg->bits & 0x3;\n\n\t \n\tcrc = crc4(0, 1 << top | msg->msg >> (msg->bits - top), top + 1);\n\n\t \n\tcrc = crc4(crc, msg->msg, msg->bits - top);\n\n\tmsg_push_bits(msg, crc, 4);\n}\n\nstatic bool check_same_address(struct fsi_master_gpio *master, int id,\n\t\tuint32_t addr)\n{\n\t \n\treturn master->last_addr == (((id & 0x3) << 21) | (addr & ~0x3));\n}\n\nstatic bool check_relative_address(struct fsi_master_gpio *master, int id,\n\t\tuint32_t addr, uint32_t *rel_addrp)\n{\n\tuint32_t last_addr = master->last_addr;\n\tint32_t rel_addr;\n\n\tif (last_addr == LAST_ADDR_INVALID)\n\t\treturn false;\n\n\t \n\tif (((last_addr >> 21) & 0x3) != id)\n\t\treturn false;\n\n\t \n\tlast_addr &= (1 << 21) - 1;\n\n\t \n\trel_addr = addr - last_addr;\n\tif (rel_addr > 255 || rel_addr < -256)\n\t\treturn false;\n\n\t*rel_addrp = (uint32_t)rel_addr;\n\n\treturn true;\n}\n\nstatic void last_address_update(struct fsi_master_gpio *master,\n\t\tint id, bool valid, uint32_t addr)\n{\n\tif (!valid)\n\t\tmaster->last_addr = LAST_ADDR_INVALID;\n\telse\n\t\tmaster->last_addr = ((id & 0x3) << 21) | (addr & ~0x3);\n}\n\n \nstatic void build_ar_command(struct fsi_master_gpio *master,\n\t\tstruct fsi_gpio_msg *cmd, uint8_t id,\n\t\tuint32_t addr, size_t size, const void *data)\n{\n\tint i, addr_bits, opcode_bits;\n\tbool write = !!data;\n\tuint8_t ds, opcode;\n\tuint32_t rel_addr;\n\n\tcmd->bits = 0;\n\tcmd->msg = 0;\n\n\t \n\taddr &= ((1 << 21) - 1);\n\n\t \n\topcode_bits = 3;\n\n\tif (check_same_address(master, id, addr)) {\n\t\t \n\t\taddr_bits = 2;\n\t\topcode_bits = 2;\n\t\topcode = FSI_CMD_SAME_AR;\n\t\ttrace_fsi_master_gpio_cmd_same_addr(master);\n\n\t} else if (check_relative_address(master, id, addr, &rel_addr)) {\n\t\t \n\t\taddr_bits = 9;\n\t\taddr = rel_addr;\n\t\topcode = FSI_CMD_REL_AR;\n\t\ttrace_fsi_master_gpio_cmd_rel_addr(master, rel_addr);\n\n\t} else {\n\t\taddr_bits = 21;\n\t\topcode = FSI_CMD_ABS_AR;\n\t\ttrace_fsi_master_gpio_cmd_abs_addr(master, addr);\n\t}\n\n\t \n\tds = size > 1 ? 1 : 0;\n\taddr &= ~(size - 1);\n\tif (size == 4)\n\t\taddr |= 1;\n\n\tmsg_push_bits(cmd, id, 2);\n\tmsg_push_bits(cmd, opcode, opcode_bits);\n\tmsg_push_bits(cmd, write ? 0 : 1, 1);\n\tmsg_push_bits(cmd, addr, addr_bits);\n\tmsg_push_bits(cmd, ds, 1);\n\tfor (i = 0; write && i < size; i++)\n\t\tmsg_push_bits(cmd, ((uint8_t *)data)[i], 8);\n\n\tmsg_push_crc(cmd);\n}\n\nstatic void build_dpoll_command(struct fsi_gpio_msg *cmd, uint8_t slave_id)\n{\n\tcmd->bits = 0;\n\tcmd->msg = 0;\n\n\tmsg_push_bits(cmd, slave_id, 2);\n\tmsg_push_bits(cmd, FSI_CMD_DPOLL, 3);\n\tmsg_push_crc(cmd);\n}\n\nstatic void build_epoll_command(struct fsi_gpio_msg *cmd, uint8_t slave_id)\n{\n\tcmd->bits = 0;\n\tcmd->msg = 0;\n\n\tmsg_push_bits(cmd, slave_id, 2);\n\tmsg_push_bits(cmd, FSI_CMD_EPOLL, 3);\n\tmsg_push_crc(cmd);\n}\n\nstatic void build_term_command(struct fsi_gpio_msg *cmd, uint8_t slave_id)\n{\n\tcmd->bits = 0;\n\tcmd->msg = 0;\n\n\tmsg_push_bits(cmd, slave_id, 2);\n\tmsg_push_bits(cmd, FSI_CMD_TERM, 6);\n\tmsg_push_crc(cmd);\n}\n\n \nstatic int read_one_response(struct fsi_master_gpio *master,\n\t\tuint8_t data_size, struct fsi_gpio_msg *msgp, uint8_t *tagp)\n{\n\tstruct fsi_gpio_msg msg;\n\tunsigned long flags;\n\tuint32_t crc;\n\tuint8_t tag;\n\tint i;\n\n\tlocal_irq_save(flags);\n\n\t \n\tfor (i = 0; i < FSI_MASTER_MTOE_COUNT; i++) {\n\t\tmsg.bits = 0;\n\t\tmsg.msg = 0;\n\t\tserial_in(master, &msg, 1);\n\t\tif (msg.msg)\n\t\t\tbreak;\n\t}\n\tif (i == FSI_MASTER_MTOE_COUNT) {\n\t\tdev_dbg(master->dev,\n\t\t\t\"Master time out waiting for response\\n\");\n\t\tlocal_irq_restore(flags);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tmsg.bits = 0;\n\tmsg.msg = 0;\n\n\t \n\tserial_in(master, &msg, 4);\n\n\ttag = msg.msg & 0x3;\n\n\t \n\tif (tag == FSI_RESP_ACK && data_size)\n\t\tserial_in(master, &msg, data_size * 8);\n\n\t \n\tserial_in(master, &msg, FSI_CRC_SIZE);\n\n\tlocal_irq_restore(flags);\n\n\t \n\tcrc = crc4(0, 1, 1);\n\tcrc = crc4(crc, msg.msg, msg.bits);\n\tif (crc) {\n\t\t \n\t\tif (((~msg.msg) & ((1ull << msg.bits) - 1)) == 0)\n\t\t\treturn -ENODEV;\n\t\tdev_dbg(master->dev, \"ERR response CRC msg: 0x%016llx (%d bits)\\n\",\n\t\t\tmsg.msg, msg.bits);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (msgp)\n\t\t*msgp = msg;\n\tif (tagp)\n\t\t*tagp = tag;\n\n\treturn 0;\n}\n\nstatic int issue_term(struct fsi_master_gpio *master, uint8_t slave)\n{\n\tstruct fsi_gpio_msg cmd;\n\tunsigned long flags;\n\tuint8_t tag;\n\tint rc;\n\n\tbuild_term_command(&cmd, slave);\n\n\tlocal_irq_save(flags);\n\tserial_out(master, &cmd);\n\techo_delay(master);\n\tlocal_irq_restore(flags);\n\n\trc = read_one_response(master, 0, NULL, &tag);\n\tif (rc < 0) {\n\t\tdev_err(master->dev,\n\t\t\t\t\"TERM failed; lost communication with slave\\n\");\n\t\treturn -EIO;\n\t} else if (tag != FSI_RESP_ACK) {\n\t\tdev_err(master->dev, \"TERM failed; response %d\\n\", tag);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int poll_for_response(struct fsi_master_gpio *master,\n\t\tuint8_t slave, uint8_t size, void *data)\n{\n\tstruct fsi_gpio_msg response, cmd;\n\tint busy_count = 0, rc, i;\n\tunsigned long flags;\n\tuint8_t tag;\n\tuint8_t *data_byte = data;\n\tint crc_err_retries = 0;\nretry:\n\trc = read_one_response(master, size, &response, &tag);\n\n\t \n\tif (rc == -EAGAIN) {\n\t\t \n\t\tif (crc_err_retries++ > FSI_CRC_ERR_RETRIES) {\n\t\t\t \n\t\t\trc = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tdev_dbg(master->dev,\n\t\t\t \"CRC error retry %d\\n\", crc_err_retries);\n\t\ttrace_fsi_master_gpio_crc_rsp_error(master);\n\t\tbuild_epoll_command(&cmd, slave);\n\t\tlocal_irq_save(flags);\n\t\tclock_zeros(master, FSI_MASTER_EPOLL_CLOCKS);\n\t\tserial_out(master, &cmd);\n\t\techo_delay(master);\n\t\tlocal_irq_restore(flags);\n\t\tgoto retry;\n\t} else if (rc)\n\t\tgoto fail;\n\n\tswitch (tag) {\n\tcase FSI_RESP_ACK:\n\t\tif (size && data) {\n\t\t\tuint64_t val = response.msg;\n\t\t\t \n\t\t\tval >>= 4;\n\t\t\tval &= (1ull << (size * 8)) - 1;\n\n\t\t\tfor (i = 0; i < size; i++) {\n\t\t\t\tdata_byte[size-i-1] = val;\n\t\t\t\tval >>= 8;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase FSI_RESP_BUSY:\n\t\t \n\t\tif (busy_count++ < FSI_MASTER_MAX_BUSY) {\n\t\t\tbuild_dpoll_command(&cmd, slave);\n\t\t\tlocal_irq_save(flags);\n\t\t\tclock_zeros(master, FSI_MASTER_DPOLL_CLOCKS);\n\t\t\tserial_out(master, &cmd);\n\t\t\techo_delay(master);\n\t\t\tlocal_irq_restore(flags);\n\t\t\tgoto retry;\n\t\t}\n\t\tdev_warn(master->dev,\n\t\t\t\"ERR slave is stuck in busy state, issuing TERM\\n\");\n\t\tlocal_irq_save(flags);\n\t\tclock_zeros(master, FSI_MASTER_DPOLL_CLOCKS);\n\t\tlocal_irq_restore(flags);\n\t\tissue_term(master, slave);\n\t\trc = -EIO;\n\t\tbreak;\n\n\tcase FSI_RESP_ERRA:\n\t\tdev_dbg(master->dev, \"ERRA received: 0x%x\\n\", (int)response.msg);\n\t\trc = -EIO;\n\t\tbreak;\n\tcase FSI_RESP_ERRC:\n\t\tdev_dbg(master->dev, \"ERRC received: 0x%x\\n\", (int)response.msg);\n\t\ttrace_fsi_master_gpio_crc_cmd_error(master);\n\t\trc = -EAGAIN;\n\t\tbreak;\n\t}\n\n\tif (busy_count > 0)\n\t\ttrace_fsi_master_gpio_poll_response_busy(master, busy_count);\n fail:\n\t \n\tlocal_irq_save(flags);\n\tclock_zeros(master, master->t_send_delay);\n\tlocal_irq_restore(flags);\n\n\treturn rc;\n}\n\nstatic int send_request(struct fsi_master_gpio *master,\n\t\tstruct fsi_gpio_msg *cmd)\n{\n\tunsigned long flags;\n\n\tif (master->external_mode)\n\t\treturn -EBUSY;\n\n\tlocal_irq_save(flags);\n\tserial_out(master, cmd);\n\techo_delay(master);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\nstatic int fsi_master_gpio_xfer(struct fsi_master_gpio *master, uint8_t slave,\n\t\tstruct fsi_gpio_msg *cmd, size_t resp_len, void *resp)\n{\n\tint rc = -EAGAIN, retries = 0;\n\n\twhile ((retries++) < FSI_CRC_ERR_RETRIES) {\n\t\trc = send_request(master, cmd);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = poll_for_response(master, slave, resp_len, resp);\n\t\tif (rc != -EAGAIN)\n\t\t\tbreak;\n\t\trc = -EIO;\n\t\tdev_warn(master->dev, \"ECRC retry %d\\n\", retries);\n\n\t\t \n\t\tmsleep(1);\n\t}\n\n\treturn rc;\n}\n\nstatic int fsi_master_gpio_read(struct fsi_master *_master, int link,\n\t\tuint8_t id, uint32_t addr, void *val, size_t size)\n{\n\tstruct fsi_master_gpio *master = to_fsi_master_gpio(_master);\n\tstruct fsi_gpio_msg cmd;\n\tint rc;\n\n\tif (link != 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&master->cmd_lock);\n\tbuild_ar_command(master, &cmd, id, addr, size, NULL);\n\trc = fsi_master_gpio_xfer(master, id, &cmd, size, val);\n\tlast_address_update(master, id, rc == 0, addr);\n\tmutex_unlock(&master->cmd_lock);\n\n\treturn rc;\n}\n\nstatic int fsi_master_gpio_write(struct fsi_master *_master, int link,\n\t\tuint8_t id, uint32_t addr, const void *val, size_t size)\n{\n\tstruct fsi_master_gpio *master = to_fsi_master_gpio(_master);\n\tstruct fsi_gpio_msg cmd;\n\tint rc;\n\n\tif (link != 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&master->cmd_lock);\n\tbuild_ar_command(master, &cmd, id, addr, size, val);\n\trc = fsi_master_gpio_xfer(master, id, &cmd, 0, NULL);\n\tlast_address_update(master, id, rc == 0, addr);\n\tmutex_unlock(&master->cmd_lock);\n\n\treturn rc;\n}\n\nstatic int fsi_master_gpio_term(struct fsi_master *_master,\n\t\tint link, uint8_t id)\n{\n\tstruct fsi_master_gpio *master = to_fsi_master_gpio(_master);\n\tstruct fsi_gpio_msg cmd;\n\tint rc;\n\n\tif (link != 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&master->cmd_lock);\n\tbuild_term_command(&cmd, id);\n\trc = fsi_master_gpio_xfer(master, id, &cmd, 0, NULL);\n\tlast_address_update(master, id, false, 0);\n\tmutex_unlock(&master->cmd_lock);\n\n\treturn rc;\n}\n\nstatic int fsi_master_gpio_break(struct fsi_master *_master, int link)\n{\n\tstruct fsi_master_gpio *master = to_fsi_master_gpio(_master);\n\tunsigned long flags;\n\n\tif (link != 0)\n\t\treturn -ENODEV;\n\n\ttrace_fsi_master_gpio_break(master);\n\n\tmutex_lock(&master->cmd_lock);\n\tif (master->external_mode) {\n\t\tmutex_unlock(&master->cmd_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tlocal_irq_save(flags);\n\n\tset_sda_output(master, 1);\n\tsda_out(master, 1);\n\tclock_toggle(master, FSI_PRE_BREAK_CLOCKS);\n\tsda_out(master, 0);\n\tclock_toggle(master, FSI_BREAK_CLOCKS);\n\techo_delay(master);\n\tsda_out(master, 1);\n\tclock_toggle(master, FSI_POST_BREAK_CLOCKS);\n\n\tlocal_irq_restore(flags);\n\n\tlast_address_update(master, 0, false, 0);\n\tmutex_unlock(&master->cmd_lock);\n\n\t \n\tudelay(200);\n\n\treturn 0;\n}\n\nstatic void fsi_master_gpio_init(struct fsi_master_gpio *master)\n{\n\tunsigned long flags;\n\n\tgpiod_direction_output(master->gpio_mux, 1);\n\tgpiod_direction_output(master->gpio_trans, 1);\n\tgpiod_direction_output(master->gpio_enable, 1);\n\tgpiod_direction_output(master->gpio_clk, 1);\n\tgpiod_direction_output(master->gpio_data, 1);\n\n\t \n\tlocal_irq_save(flags);\n\tclock_zeros(master, FSI_INIT_CLOCKS);\n\tlocal_irq_restore(flags);\n}\n\nstatic void fsi_master_gpio_init_external(struct fsi_master_gpio *master)\n{\n\tgpiod_direction_output(master->gpio_mux, 0);\n\tgpiod_direction_output(master->gpio_trans, 0);\n\tgpiod_direction_output(master->gpio_enable, 1);\n\tgpiod_direction_input(master->gpio_clk);\n\tgpiod_direction_input(master->gpio_data);\n}\n\nstatic int fsi_master_gpio_link_enable(struct fsi_master *_master, int link,\n\t\t\t\t       bool enable)\n{\n\tstruct fsi_master_gpio *master = to_fsi_master_gpio(_master);\n\tint rc = -EBUSY;\n\n\tif (link != 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&master->cmd_lock);\n\tif (!master->external_mode) {\n\t\tgpiod_set_value(master->gpio_enable, enable ? 1 : 0);\n\t\trc = 0;\n\t}\n\tmutex_unlock(&master->cmd_lock);\n\n\treturn rc;\n}\n\nstatic int fsi_master_gpio_link_config(struct fsi_master *_master, int link,\n\t\t\t\t       u8 t_send_delay, u8 t_echo_delay)\n{\n\tstruct fsi_master_gpio *master = to_fsi_master_gpio(_master);\n\n\tif (link != 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&master->cmd_lock);\n\tmaster->t_send_delay = t_send_delay;\n\tmaster->t_echo_delay = t_echo_delay;\n\tmutex_unlock(&master->cmd_lock);\n\n\treturn 0;\n}\n\nstatic ssize_t external_mode_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fsi_master_gpio *master = dev_get_drvdata(dev);\n\n\treturn snprintf(buf, PAGE_SIZE - 1, \"%u\\n\",\n\t\t\tmaster->external_mode ? 1 : 0);\n}\n\nstatic ssize_t external_mode_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct fsi_master_gpio *master = dev_get_drvdata(dev);\n\tunsigned long val;\n\tbool external_mode;\n\tint err;\n\n\terr = kstrtoul(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\n\texternal_mode = !!val;\n\n\tmutex_lock(&master->cmd_lock);\n\n\tif (external_mode == master->external_mode) {\n\t\tmutex_unlock(&master->cmd_lock);\n\t\treturn count;\n\t}\n\n\tmaster->external_mode = external_mode;\n\tif (master->external_mode)\n\t\tfsi_master_gpio_init_external(master);\n\telse\n\t\tfsi_master_gpio_init(master);\n\n\tmutex_unlock(&master->cmd_lock);\n\n\tfsi_master_rescan(&master->master);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(external_mode, 0664,\n\t\texternal_mode_show, external_mode_store);\n\nstatic void fsi_master_gpio_release(struct device *dev)\n{\n\tstruct fsi_master_gpio *master = to_fsi_master_gpio(to_fsi_master(dev));\n\n\tof_node_put(dev_of_node(master->dev));\n\n\tkfree(master);\n}\n\nstatic int fsi_master_gpio_probe(struct platform_device *pdev)\n{\n\tstruct fsi_master_gpio *master;\n\tstruct gpio_desc *gpio;\n\tint rc;\n\n\tmaster = kzalloc(sizeof(*master), GFP_KERNEL);\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tmaster->dev = &pdev->dev;\n\tmaster->master.dev.parent = master->dev;\n\tmaster->master.dev.of_node = of_node_get(dev_of_node(master->dev));\n\tmaster->master.dev.release = fsi_master_gpio_release;\n\tmaster->last_addr = LAST_ADDR_INVALID;\n\n\tgpio = devm_gpiod_get(&pdev->dev, \"clock\", 0);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock gpio\\n\");\n\t\trc = PTR_ERR(gpio);\n\t\tgoto err_free;\n\t}\n\tmaster->gpio_clk = gpio;\n\n\tgpio = devm_gpiod_get(&pdev->dev, \"data\", 0);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get data gpio\\n\");\n\t\trc = PTR_ERR(gpio);\n\t\tgoto err_free;\n\t}\n\tmaster->gpio_data = gpio;\n\n\t \n\tgpio = devm_gpiod_get_optional(&pdev->dev, \"trans\", 0);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get trans gpio\\n\");\n\t\trc = PTR_ERR(gpio);\n\t\tgoto err_free;\n\t}\n\tmaster->gpio_trans = gpio;\n\n\tgpio = devm_gpiod_get_optional(&pdev->dev, \"enable\", 0);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get enable gpio\\n\");\n\t\trc = PTR_ERR(gpio);\n\t\tgoto err_free;\n\t}\n\tmaster->gpio_enable = gpio;\n\n\tgpio = devm_gpiod_get_optional(&pdev->dev, \"mux\", 0);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get mux gpio\\n\");\n\t\trc = PTR_ERR(gpio);\n\t\tgoto err_free;\n\t}\n\tmaster->gpio_mux = gpio;\n\n\t \n\tmaster->no_delays = device_property_present(&pdev->dev, \"no-gpio-delays\");\n\n\t \n\tmaster->t_send_delay = FSI_SEND_DELAY_CLOCKS;\n\tmaster->t_echo_delay = FSI_ECHO_DELAY_CLOCKS;\n\n\tmaster->master.n_links = 1;\n\tmaster->master.flags = FSI_MASTER_FLAG_SWCLOCK;\n\tmaster->master.read = fsi_master_gpio_read;\n\tmaster->master.write = fsi_master_gpio_write;\n\tmaster->master.term = fsi_master_gpio_term;\n\tmaster->master.send_break = fsi_master_gpio_break;\n\tmaster->master.link_enable = fsi_master_gpio_link_enable;\n\tmaster->master.link_config = fsi_master_gpio_link_config;\n\tplatform_set_drvdata(pdev, master);\n\tmutex_init(&master->cmd_lock);\n\n\tfsi_master_gpio_init(master);\n\n\trc = device_create_file(&pdev->dev, &dev_attr_external_mode);\n\tif (rc)\n\t\tgoto err_free;\n\n\trc = fsi_master_register(&master->master);\n\tif (rc) {\n\t\tdevice_remove_file(&pdev->dev, &dev_attr_external_mode);\n\t\tput_device(&master->master.dev);\n\t\treturn rc;\n\t}\n\treturn 0;\n err_free:\n\tkfree(master);\n\treturn rc;\n}\n\n\n\nstatic int fsi_master_gpio_remove(struct platform_device *pdev)\n{\n\tstruct fsi_master_gpio *master = platform_get_drvdata(pdev);\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_external_mode);\n\n\tfsi_master_unregister(&master->master);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id fsi_master_gpio_match[] = {\n\t{ .compatible = \"fsi-master-gpio\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, fsi_master_gpio_match);\n\nstatic struct platform_driver fsi_master_gpio_driver = {\n\t.driver = {\n\t\t.name\t\t= \"fsi-master-gpio\",\n\t\t.of_match_table\t= fsi_master_gpio_match,\n\t},\n\t.probe\t= fsi_master_gpio_probe,\n\t.remove = fsi_master_gpio_remove,\n};\n\nmodule_platform_driver(fsi_master_gpio_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}