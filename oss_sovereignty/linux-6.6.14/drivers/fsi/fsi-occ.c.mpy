{
  "module_name": "fsi-occ.c",
  "hash_id": "01fcd98022547a47d35ad836cde6dad1d9be5fa5259f962022c1f974d3c8ed77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fsi/fsi-occ.c",
  "human_readable_source": "\n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/fsi-sbefifo.h>\n#include <linux/gfp.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/miscdevice.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/fsi-occ.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n\n#define OCC_SRAM_BYTES\t\t4096\n#define OCC_CMD_DATA_BYTES\t4090\n#define OCC_RESP_DATA_BYTES\t4089\n\n#define OCC_P9_SRAM_CMD_ADDR\t0xFFFBE000\n#define OCC_P9_SRAM_RSP_ADDR\t0xFFFBF000\n\n#define OCC_P10_SRAM_CMD_ADDR\t0xFFFFD000\n#define OCC_P10_SRAM_RSP_ADDR\t0xFFFFE000\n\n#define OCC_P10_SRAM_MODE\t0x58\t \n\n#define OCC_TIMEOUT_MS\t\t1000\n#define OCC_CMD_IN_PRG_WAIT_MS\t50\n\nenum versions { occ_p9, occ_p10 };\n\nstruct occ {\n\tstruct device *dev;\n\tstruct device *sbefifo;\n\tchar name[32];\n\tint idx;\n\tbool platform_hwmon;\n\tu8 sequence_number;\n\tvoid *buffer;\n\tvoid *client_buffer;\n\tsize_t client_buffer_size;\n\tsize_t client_response_size;\n\tenum versions version;\n\tstruct miscdevice mdev;\n\tstruct mutex occ_lock;\n};\n\n#define to_occ(x)\tcontainer_of((x), struct occ, mdev)\n\nstruct occ_response {\n\tu8 seq_no;\n\tu8 cmd_type;\n\tu8 return_status;\n\t__be16 data_length;\n\tu8 data[OCC_RESP_DATA_BYTES + 2];\t \n} __packed;\n\nstruct occ_client {\n\tstruct occ *occ;\n\tstruct mutex lock;\n\tsize_t data_size;\n\tsize_t read_offset;\n\tu8 *buffer;\n};\n\n#define to_client(x)\tcontainer_of((x), struct occ_client, xfr)\n\nstatic DEFINE_IDA(occ_ida);\n\nstatic int occ_open(struct inode *inode, struct file *file)\n{\n\tstruct occ_client *client = kzalloc(sizeof(*client), GFP_KERNEL);\n\tstruct miscdevice *mdev = file->private_data;\n\tstruct occ *occ = to_occ(mdev);\n\n\tif (!client)\n\t\treturn -ENOMEM;\n\n\tclient->buffer = (u8 *)__get_free_page(GFP_KERNEL);\n\tif (!client->buffer) {\n\t\tkfree(client);\n\t\treturn -ENOMEM;\n\t}\n\n\tclient->occ = occ;\n\tmutex_init(&client->lock);\n\tfile->private_data = client;\n\tget_device(occ->dev);\n\n\t \n\tBUILD_BUG_ON((OCC_CMD_DATA_BYTES + 3) > PAGE_SIZE);\n\tBUILD_BUG_ON((OCC_RESP_DATA_BYTES + 7) > PAGE_SIZE);\n\n\treturn 0;\n}\n\nstatic ssize_t occ_read(struct file *file, char __user *buf, size_t len,\n\t\t\tloff_t *offset)\n{\n\tstruct occ_client *client = file->private_data;\n\tssize_t rc = 0;\n\n\tif (!client)\n\t\treturn -ENODEV;\n\n\tif (len > OCC_SRAM_BYTES)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&client->lock);\n\n\t \n\tif (WARN_ON_ONCE(client->read_offset > client->data_size)) {\n\t\trc = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\trc = min(len, client->data_size - client->read_offset);\n\tif (copy_to_user(buf, client->buffer + client->read_offset, rc))\n\t\trc = -EFAULT;\n\telse\n\t\tclient->read_offset += rc;\n\n done:\n\tmutex_unlock(&client->lock);\n\n\treturn rc;\n}\n\nstatic ssize_t occ_write(struct file *file, const char __user *buf,\n\t\t\t size_t len, loff_t *offset)\n{\n\tstruct occ_client *client = file->private_data;\n\tsize_t rlen, data_length;\n\tssize_t rc;\n\tu8 *cmd;\n\n\tif (!client)\n\t\treturn -ENODEV;\n\n\tif (len > (OCC_CMD_DATA_BYTES + 3) || len < 3)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&client->lock);\n\n\t \n\tcmd = client->buffer;\n\n\t \n\tif (copy_from_user(&cmd[1], buf, len)) {\n\t\trc = -EFAULT;\n\t\tgoto done;\n\t}\n\n\t \n\tdata_length = (cmd[2] << 8) + cmd[3];\n\tif (data_length > OCC_CMD_DATA_BYTES) {\n\t\trc = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\trlen = PAGE_SIZE;\n\trc = fsi_occ_submit(client->occ->dev, cmd, data_length + 6, cmd,\n\t\t\t    &rlen);\n\tif (rc)\n\t\tgoto done;\n\n\t \n\tclient->data_size = rlen;\n\tclient->read_offset = 0;\n\n\t \n\trc = len;\n\n done:\n\tmutex_unlock(&client->lock);\n\n\treturn rc;\n}\n\nstatic int occ_release(struct inode *inode, struct file *file)\n{\n\tstruct occ_client *client = file->private_data;\n\n\tput_device(client->occ->dev);\n\tfree_page((unsigned long)client->buffer);\n\tkfree(client);\n\n\treturn 0;\n}\n\nstatic const struct file_operations occ_fops = {\n\t.owner = THIS_MODULE,\n\t.open = occ_open,\n\t.read = occ_read,\n\t.write = occ_write,\n\t.release = occ_release,\n};\n\nstatic void occ_save_ffdc(struct occ *occ, __be32 *resp, size_t parsed_len,\n\t\t\t  size_t resp_len)\n{\n\tif (resp_len > parsed_len) {\n\t\tsize_t dh = resp_len - parsed_len;\n\t\tsize_t ffdc_len = (dh - 1) * 4;  \n\t\t__be32 *ffdc = &resp[parsed_len];\n\n\t\tif (ffdc_len > occ->client_buffer_size)\n\t\t\tffdc_len = occ->client_buffer_size;\n\n\t\tmemcpy(occ->client_buffer, ffdc, ffdc_len);\n\t\tocc->client_response_size = ffdc_len;\n\t}\n}\n\nstatic int occ_verify_checksum(struct occ *occ, struct occ_response *resp,\n\t\t\t       u16 data_length)\n{\n\t \n\tu16 checksum_resp = get_unaligned_be16(&resp->data[data_length]);\n\tu16 checksum;\n\tu16 i;\n\n\tchecksum = resp->seq_no;\n\tchecksum += resp->cmd_type;\n\tchecksum += resp->return_status;\n\tchecksum += (data_length >> 8) + (data_length & 0xFF);\n\n\tfor (i = 0; i < data_length; ++i)\n\t\tchecksum += resp->data[i];\n\n\tif (checksum != checksum_resp) {\n\t\tdev_err(occ->dev, \"Bad checksum: %04x!=%04x\\n\", checksum,\n\t\t\tchecksum_resp);\n\t\treturn -EBADE;\n\t}\n\n\treturn 0;\n}\n\nstatic int occ_getsram(struct occ *occ, u32 offset, void *data, ssize_t len)\n{\n\tu32 data_len = ((len + 7) / 8) * 8;\t \n\tsize_t cmd_len, parsed_len, resp_data_len;\n\tsize_t resp_len = OCC_MAX_RESP_WORDS;\n\t__be32 *resp = occ->buffer;\n\t__be32 cmd[6];\n\tint idx = 0, rc;\n\n\t \n\tswitch (occ->version) {\n\tdefault:\n\tcase occ_p9:\n\t\tcmd_len = 5;\n\t\tcmd[2] = cpu_to_be32(1);\t \n\t\tcmd[3] = cpu_to_be32(OCC_P9_SRAM_RSP_ADDR + offset);\n\t\tbreak;\n\tcase occ_p10:\n\t\tidx = 1;\n\t\tcmd_len = 6;\n\t\tcmd[2] = cpu_to_be32(OCC_P10_SRAM_MODE);\n\t\tcmd[3] = 0;\n\t\tcmd[4] = cpu_to_be32(OCC_P10_SRAM_RSP_ADDR + offset);\n\t\tbreak;\n\t}\n\n\tcmd[0] = cpu_to_be32(cmd_len);\n\tcmd[1] = cpu_to_be32(SBEFIFO_CMD_GET_OCC_SRAM);\n\tcmd[4 + idx] = cpu_to_be32(data_len);\n\n\trc = sbefifo_submit(occ->sbefifo, cmd, cmd_len, resp, &resp_len);\n\tif (rc)\n\t\treturn rc;\n\n\trc = sbefifo_parse_status(occ->sbefifo, SBEFIFO_CMD_GET_OCC_SRAM,\n\t\t\t\t  resp, resp_len, &parsed_len);\n\tif (rc > 0) {\n\t\tdev_err(occ->dev, \"SRAM read returned failure status: %08x\\n\",\n\t\t\trc);\n\t\tocc_save_ffdc(occ, resp, parsed_len, resp_len);\n\t\treturn -ECOMM;\n\t} else if (rc) {\n\t\treturn rc;\n\t}\n\n\tresp_data_len = be32_to_cpu(resp[parsed_len - 1]);\n\tif (resp_data_len != data_len) {\n\t\tdev_err(occ->dev, \"SRAM read expected %d bytes got %zd\\n\",\n\t\t\tdata_len, resp_data_len);\n\t\trc = -EBADMSG;\n\t} else {\n\t\tmemcpy(data, resp, len);\n\t}\n\n\treturn rc;\n}\n\nstatic int occ_putsram(struct occ *occ, const void *data, ssize_t len,\n\t\t       u8 seq_no, u16 checksum)\n{\n\tu32 data_len = ((len + 7) / 8) * 8;\t \n\tsize_t cmd_len, parsed_len, resp_data_len;\n\tsize_t resp_len = OCC_MAX_RESP_WORDS;\n\t__be32 *buf = occ->buffer;\n\tu8 *byte_buf;\n\tint idx = 0, rc;\n\n\tcmd_len = (occ->version == occ_p10) ? 6 : 5;\n\tcmd_len += data_len >> 2;\n\n\t \n\tbuf[0] = cpu_to_be32(cmd_len);\n\tbuf[1] = cpu_to_be32(SBEFIFO_CMD_PUT_OCC_SRAM);\n\n\tswitch (occ->version) {\n\tdefault:\n\tcase occ_p9:\n\t\tbuf[2] = cpu_to_be32(1);\t \n\t\tbuf[3] = cpu_to_be32(OCC_P9_SRAM_CMD_ADDR);\n\t\tbreak;\n\tcase occ_p10:\n\t\tidx = 1;\n\t\tbuf[2] = cpu_to_be32(OCC_P10_SRAM_MODE);\n\t\tbuf[3] = 0;\n\t\tbuf[4] = cpu_to_be32(OCC_P10_SRAM_CMD_ADDR);\n\t\tbreak;\n\t}\n\n\tbuf[4 + idx] = cpu_to_be32(data_len);\n\tmemcpy(&buf[5 + idx], data, len);\n\n\tbyte_buf = (u8 *)&buf[5 + idx];\n\t \n\tbyte_buf[0] = seq_no;\n\tbyte_buf[len - 2] = checksum >> 8;\n\tbyte_buf[len - 1] = checksum & 0xff;\n\n\trc = sbefifo_submit(occ->sbefifo, buf, cmd_len, buf, &resp_len);\n\tif (rc)\n\t\treturn rc;\n\n\trc = sbefifo_parse_status(occ->sbefifo, SBEFIFO_CMD_PUT_OCC_SRAM,\n\t\t\t\t  buf, resp_len, &parsed_len);\n\tif (rc > 0) {\n\t\tdev_err(occ->dev, \"SRAM write returned failure status: %08x\\n\",\n\t\t\trc);\n\t\tocc_save_ffdc(occ, buf, parsed_len, resp_len);\n\t\treturn -ECOMM;\n\t} else if (rc) {\n\t\treturn rc;\n\t}\n\n\tif (parsed_len != 1) {\n\t\tdev_err(occ->dev, \"SRAM write response length invalid: %zd\\n\",\n\t\t\tparsed_len);\n\t\trc = -EBADMSG;\n\t} else {\n\t\tresp_data_len = be32_to_cpu(buf[0]);\n\t\tif (resp_data_len != data_len) {\n\t\t\tdev_err(occ->dev,\n\t\t\t\t\"SRAM write expected %d bytes got %zd\\n\",\n\t\t\t\tdata_len, resp_data_len);\n\t\t\trc = -EBADMSG;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int occ_trigger_attn(struct occ *occ)\n{\n\t__be32 *buf = occ->buffer;\n\tsize_t cmd_len, parsed_len, resp_data_len;\n\tsize_t resp_len = OCC_MAX_RESP_WORDS;\n\tint idx = 0, rc;\n\n\tswitch (occ->version) {\n\tdefault:\n\tcase occ_p9:\n\t\tcmd_len = 7;\n\t\tbuf[2] = cpu_to_be32(3);  \n\t\tbuf[3] = 0;\n\t\tbreak;\n\tcase occ_p10:\n\t\tidx = 1;\n\t\tcmd_len = 8;\n\t\tbuf[2] = cpu_to_be32(0xd0);  \n\t\tbuf[3] = 0;\n\t\tbuf[4] = 0;\n\t\tbreak;\n\t}\n\n\tbuf[0] = cpu_to_be32(cmd_len);\t\t \n\tbuf[1] = cpu_to_be32(SBEFIFO_CMD_PUT_OCC_SRAM);\n\tbuf[4 + idx] = cpu_to_be32(8);\t\t \n\tbuf[5 + idx] = cpu_to_be32(0x20010000);\t \n\tbuf[6 + idx] = 0;\n\n\trc = sbefifo_submit(occ->sbefifo, buf, cmd_len, buf, &resp_len);\n\tif (rc)\n\t\treturn rc;\n\n\trc = sbefifo_parse_status(occ->sbefifo, SBEFIFO_CMD_PUT_OCC_SRAM,\n\t\t\t\t  buf, resp_len, &parsed_len);\n\tif (rc > 0) {\n\t\tdev_err(occ->dev, \"SRAM attn returned failure status: %08x\\n\",\n\t\t\trc);\n\t\tocc_save_ffdc(occ, buf, parsed_len, resp_len);\n\t\treturn -ECOMM;\n\t} else if (rc) {\n\t\treturn rc;\n\t}\n\n\tif (parsed_len != 1) {\n\t\tdev_err(occ->dev, \"SRAM attn response length invalid: %zd\\n\",\n\t\t\tparsed_len);\n\t\trc = -EBADMSG;\n\t} else {\n\t\tresp_data_len = be32_to_cpu(buf[0]);\n\t\tif (resp_data_len != 8) {\n\t\t\tdev_err(occ->dev,\n\t\t\t\t\"SRAM attn expected 8 bytes got %zd\\n\",\n\t\t\t\tresp_data_len);\n\t\t\trc = -EBADMSG;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic bool fsi_occ_response_not_ready(struct occ_response *resp, u8 seq_no,\n\t\t\t\t       u8 cmd_type)\n{\n\treturn resp->return_status == OCC_RESP_CMD_IN_PRG ||\n\t\tresp->return_status == OCC_RESP_CRIT_INIT ||\n\t\tresp->seq_no != seq_no || resp->cmd_type != cmd_type;\n}\n\nint fsi_occ_submit(struct device *dev, const void *request, size_t req_len,\n\t\t   void *response, size_t *resp_len)\n{\n\tconst unsigned long timeout = msecs_to_jiffies(OCC_TIMEOUT_MS);\n\tconst unsigned long wait_time =\n\t\tmsecs_to_jiffies(OCC_CMD_IN_PRG_WAIT_MS);\n\tstruct occ *occ = dev_get_drvdata(dev);\n\tstruct occ_response *resp = response;\n\tsize_t user_resp_len = *resp_len;\n\tu8 seq_no;\n\tu8 cmd_type;\n\tu16 checksum = 0;\n\tu16 resp_data_length;\n\tconst u8 *byte_request = (const u8 *)request;\n\tunsigned long end;\n\tint rc;\n\tsize_t i;\n\n\t*resp_len = 0;\n\n\tif (!occ)\n\t\treturn -ENODEV;\n\n\tif (user_resp_len < 7) {\n\t\tdev_dbg(dev, \"Bad resplen %zd\\n\", user_resp_len);\n\t\treturn -EINVAL;\n\t}\n\n\tcmd_type = byte_request[1];\n\n\t \n\tfor (i = 1; i < req_len - 2; ++i)\n\t\tchecksum += byte_request[i];\n\n\trc = mutex_lock_interruptible(&occ->occ_lock);\n\tif (rc)\n\t\treturn rc;\n\n\tocc->client_buffer = response;\n\tocc->client_buffer_size = user_resp_len;\n\tocc->client_response_size = 0;\n\n\tif (!occ->buffer) {\n\t\trc = -ENOENT;\n\t\tgoto done;\n\t}\n\n\t \n\tseq_no = occ->sequence_number++;\n\tif (!occ->sequence_number)\n\t\tocc->sequence_number = 1;\n\tchecksum += seq_no;\n\n\trc = occ_putsram(occ, request, req_len, seq_no, checksum);\n\tif (rc)\n\t\tgoto done;\n\n\trc = occ_trigger_attn(occ);\n\tif (rc)\n\t\tgoto done;\n\n\tend = jiffies + timeout;\n\twhile (true) {\n\t\t \n\t\trc = occ_getsram(occ, 0, resp, 8);\n\t\tif (rc)\n\t\t\tgoto done;\n\n\t\tif (fsi_occ_response_not_ready(resp, seq_no, cmd_type)) {\n\t\t\tif (time_after(jiffies, end)) {\n\t\t\t\tdev_err(occ->dev,\n\t\t\t\t\t\"resp timeout status=%02x seq=%d cmd=%d, our seq=%d cmd=%d\\n\",\n\t\t\t\t\tresp->return_status, resp->seq_no,\n\t\t\t\t\tresp->cmd_type, seq_no, cmd_type);\n\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_timeout(wait_time);\n\t\t} else {\n\t\t\t \n\t\t\tresp_data_length =\n\t\t\t\tget_unaligned_be16(&resp->data_length);\n\n\t\t\t \n\t\t\tif ((resp_data_length + 7) > user_resp_len) {\n\t\t\t\trc = -EMSGSIZE;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (resp_data_length > 1) {\n\t\t\t\trc = occ_getsram(occ, 0, resp,\n\t\t\t\t\t\t resp_data_length + 7);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tif (!fsi_occ_response_not_ready(resp, seq_no,\n\t\t\t\t\t\t\t\tcmd_type))\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"resp_status=%02x resp_data_len=%d\\n\",\n\t\tresp->return_status, resp_data_length);\n\n\trc = occ_verify_checksum(occ, resp, resp_data_length);\n\tif (rc)\n\t\tgoto done;\n\n\tocc->client_response_size = resp_data_length + 7;\n\n done:\n\t*resp_len = occ->client_response_size;\n\tmutex_unlock(&occ->occ_lock);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(fsi_occ_submit);\n\nstatic int occ_unregister_platform_child(struct device *dev, void *data)\n{\n\tstruct platform_device *hwmon_dev = to_platform_device(dev);\n\n\tplatform_device_unregister(hwmon_dev);\n\n\treturn 0;\n}\n\nstatic int occ_unregister_of_child(struct device *dev, void *data)\n{\n\tstruct platform_device *hwmon_dev = to_platform_device(dev);\n\n\tof_device_unregister(hwmon_dev);\n\tif (dev->of_node)\n\t\tof_node_clear_flag(dev->of_node, OF_POPULATED);\n\n\treturn 0;\n}\n\nstatic int occ_probe(struct platform_device *pdev)\n{\n\tint rc;\n\tu32 reg;\n\tchar child_name[32];\n\tstruct occ *occ;\n\tstruct platform_device *hwmon_dev = NULL;\n\tstruct device_node *hwmon_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct platform_device_info hwmon_dev_info = {\n\t\t.parent = dev,\n\t\t.name = \"occ-hwmon\",\n\t};\n\n\tocc = devm_kzalloc(dev, sizeof(*occ), GFP_KERNEL);\n\tif (!occ)\n\t\treturn -ENOMEM;\n\n\t \n\tocc->buffer = kvmalloc(OCC_MAX_RESP_WORDS * 4, GFP_KERNEL);\n\tif (!occ->buffer)\n\t\treturn -ENOMEM;\n\n\tocc->version = (uintptr_t)of_device_get_match_data(dev);\n\tocc->dev = dev;\n\tocc->sbefifo = dev->parent;\n\t \n\tocc->sequence_number = (u8)((jiffies % 0xff) + 1);\n\tmutex_init(&occ->occ_lock);\n\n\tif (dev->of_node) {\n\t\trc = of_property_read_u32(dev->of_node, \"reg\", &reg);\n\t\tif (!rc) {\n\t\t\t \n\t\t\tocc->idx = ida_simple_get(&occ_ida, reg, reg + 1,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (occ->idx < 0)\n\t\t\t\tocc->idx = ida_simple_get(&occ_ida, 1, INT_MAX,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t} else {\n\t\t\tocc->idx = ida_simple_get(&occ_ida, 1, INT_MAX,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t}\n\t} else {\n\t\tocc->idx = ida_simple_get(&occ_ida, 1, INT_MAX, GFP_KERNEL);\n\t}\n\n\tplatform_set_drvdata(pdev, occ);\n\n\tsnprintf(occ->name, sizeof(occ->name), \"occ%d\", occ->idx);\n\tocc->mdev.fops = &occ_fops;\n\tocc->mdev.minor = MISC_DYNAMIC_MINOR;\n\tocc->mdev.name = occ->name;\n\tocc->mdev.parent = dev;\n\n\trc = misc_register(&occ->mdev);\n\tif (rc) {\n\t\tdev_err(dev, \"failed to register miscdevice: %d\\n\", rc);\n\t\tida_simple_remove(&occ_ida, occ->idx);\n\t\tkvfree(occ->buffer);\n\t\treturn rc;\n\t}\n\n\thwmon_node = of_get_child_by_name(dev->of_node, hwmon_dev_info.name);\n\tif (hwmon_node) {\n\t\tsnprintf(child_name, sizeof(child_name), \"%s.%d\", hwmon_dev_info.name, occ->idx);\n\t\thwmon_dev = of_platform_device_create(hwmon_node, child_name, dev);\n\t\tof_node_put(hwmon_node);\n\t}\n\n\tif (!hwmon_dev) {\n\t\tocc->platform_hwmon = true;\n\t\thwmon_dev_info.id = occ->idx;\n\t\thwmon_dev = platform_device_register_full(&hwmon_dev_info);\n\t\tif (IS_ERR(hwmon_dev))\n\t\t\tdev_warn(dev, \"failed to create hwmon device\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int occ_remove(struct platform_device *pdev)\n{\n\tstruct occ *occ = platform_get_drvdata(pdev);\n\n\tmisc_deregister(&occ->mdev);\n\n\tmutex_lock(&occ->occ_lock);\n\tkvfree(occ->buffer);\n\tocc->buffer = NULL;\n\tmutex_unlock(&occ->occ_lock);\n\n\tif (occ->platform_hwmon)\n\t\tdevice_for_each_child(&pdev->dev, NULL, occ_unregister_platform_child);\n\telse\n\t\tdevice_for_each_child(&pdev->dev, NULL, occ_unregister_of_child);\n\n\tida_simple_remove(&occ_ida, occ->idx);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id occ_match[] = {\n\t{\n\t\t.compatible = \"ibm,p9-occ\",\n\t\t.data = (void *)occ_p9\n\t},\n\t{\n\t\t.compatible = \"ibm,p10-occ\",\n\t\t.data = (void *)occ_p10\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, occ_match);\n\nstatic struct platform_driver occ_driver = {\n\t.driver = {\n\t\t.name = \"occ\",\n\t\t.of_match_table\t= occ_match,\n\t},\n\t.probe\t= occ_probe,\n\t.remove = occ_remove,\n};\n\nstatic int occ_init(void)\n{\n\treturn platform_driver_register(&occ_driver);\n}\n\nstatic void occ_exit(void)\n{\n\tplatform_driver_unregister(&occ_driver);\n\n\tida_destroy(&occ_ida);\n}\n\nmodule_init(occ_init);\nmodule_exit(occ_exit);\n\nMODULE_AUTHOR(\"Eddie James <eajames@linux.ibm.com>\");\nMODULE_DESCRIPTION(\"BMC P9 OCC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}