{
  "module_name": "i2cr-scom.c",
  "hash_id": "57f882b178f77eee07b24b64eb4628b980fa3e62ae332a05693cf00090fc0927",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fsi/i2cr-scom.c",
  "human_readable_source": "\n \n\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/fsi.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n\n#include \"fsi-master-i2cr.h\"\n#include \"fsi-slave.h\"\n\nstruct i2cr_scom {\n\tstruct device dev;\n\tstruct cdev cdev;\n\tstruct fsi_master_i2cr *i2cr;\n};\n\nstatic loff_t i2cr_scom_llseek(struct file *file, loff_t offset, int whence)\n{\n\tswitch (whence) {\n\tcase SEEK_CUR:\n\t\tbreak;\n\tcase SEEK_SET:\n\t\tfile->f_pos = offset;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn offset;\n}\n\nstatic ssize_t i2cr_scom_read(struct file *filep, char __user *buf, size_t len, loff_t *offset)\n{\n\tstruct i2cr_scom *scom = filep->private_data;\n\tu64 data;\n\tint ret;\n\n\tif (len != sizeof(data))\n\t\treturn -EINVAL;\n\n\tret = fsi_master_i2cr_read(scom->i2cr, (u32)*offset, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = copy_to_user(buf, &data, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t i2cr_scom_write(struct file *filep, const char __user *buf, size_t len,\n\t\t\t       loff_t *offset)\n{\n\tstruct i2cr_scom *scom = filep->private_data;\n\tu64 data;\n\tint ret;\n\n\tif (len != sizeof(data))\n\t\treturn -EINVAL;\n\n\tret = copy_from_user(&data, buf, len);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fsi_master_i2cr_write(scom->i2cr, (u32)*offset, data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic const struct file_operations i2cr_scom_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= simple_open,\n\t.llseek\t\t= i2cr_scom_llseek,\n\t.read\t\t= i2cr_scom_read,\n\t.write\t\t= i2cr_scom_write,\n};\n\nstatic int i2cr_scom_probe(struct device *dev)\n{\n\tstruct fsi_device *fsi_dev = to_fsi_dev(dev);\n\tstruct i2cr_scom *scom;\n\tint didx;\n\tint ret;\n\n\tif (!is_fsi_master_i2cr(fsi_dev->slave->master))\n\t\treturn -ENODEV;\n\n\tscom = devm_kzalloc(dev, sizeof(*scom), GFP_KERNEL);\n\tif (!scom)\n\t\treturn -ENOMEM;\n\n\tscom->i2cr = to_fsi_master_i2cr(fsi_dev->slave->master);\n\tdev_set_drvdata(dev, scom);\n\n\tscom->dev.type = &fsi_cdev_type;\n\tscom->dev.parent = dev;\n\tdevice_initialize(&scom->dev);\n\n\tret = fsi_get_new_minor(fsi_dev, fsi_dev_scom, &scom->dev.devt, &didx);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_name(&scom->dev, \"scom%d\", didx);\n\tcdev_init(&scom->cdev, &i2cr_scom_fops);\n\tret = cdev_device_add(&scom->cdev, &scom->dev);\n\tif (ret)\n\t\tfsi_free_minor(scom->dev.devt);\n\n\treturn ret;\n}\n\nstatic int i2cr_scom_remove(struct device *dev)\n{\n\tstruct i2cr_scom *scom = dev_get_drvdata(dev);\n\n\tcdev_device_del(&scom->cdev, &scom->dev);\n\tfsi_free_minor(scom->dev.devt);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id i2cr_scom_of_ids[] = {\n\t{ .compatible = \"ibm,i2cr-scom\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, i2cr_scom_of_ids);\n\nstatic const struct fsi_device_id i2cr_scom_ids[] = {\n\t{ 0x5, FSI_VERSION_ANY },\n\t{ }\n};\n\nstatic struct fsi_driver i2cr_scom_driver = {\n\t.id_table = i2cr_scom_ids,\n\t.drv = {\n\t\t.name = \"i2cr_scom\",\n\t\t.bus = &fsi_bus_type,\n\t\t.of_match_table = i2cr_scom_of_ids,\n\t\t.probe = i2cr_scom_probe,\n\t\t.remove = i2cr_scom_remove,\n\t}\n};\n\nmodule_fsi_driver(i2cr_scom_driver);\n\nMODULE_AUTHOR(\"Eddie James <eajames@linux.ibm.com>\");\nMODULE_DESCRIPTION(\"IBM I2C Responder SCOM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}