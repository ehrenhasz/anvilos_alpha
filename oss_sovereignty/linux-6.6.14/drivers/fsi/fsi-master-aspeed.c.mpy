{
  "module_name": "fsi-master-aspeed.c",
  "hash_id": "1dcc28d3d4b27000e9c4de6c79263ce13ba4987f4e29c18258feb9318e14a6a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fsi/fsi-master-aspeed.c",
  "human_readable_source": "\n\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/fsi.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/iopoll.h>\n#include <linux/gpio/consumer.h>\n\n#include \"fsi-master.h\"\n\nstruct fsi_master_aspeed {\n\tstruct fsi_master\tmaster;\n\tstruct mutex\t\tlock;\t \n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n\tstruct gpio_desc\t*cfam_reset_gpio;\n};\n\n#define to_fsi_master_aspeed(m) \\\n\tcontainer_of(m, struct fsi_master_aspeed, master)\n\n \nstatic const u32 ctrl_base = 0x80000000;\n\nstatic const u32 fsi_base = 0xa0000000;\n\n#define OPB_FSI_VER\t0x00\n#define OPB_TRIGGER\t0x04\n#define OPB_CTRL_BASE\t0x08\n#define OPB_FSI_BASE\t0x0c\n#define OPB_CLK_SYNC\t0x3c\n#define OPB_IRQ_CLEAR\t0x40\n#define OPB_IRQ_MASK\t0x44\n#define OPB_IRQ_STATUS\t0x48\n\n#define OPB0_SELECT\t0x10\n#define OPB0_RW\t\t0x14\n#define OPB0_XFER_SIZE\t0x18\n#define OPB0_FSI_ADDR\t0x1c\n#define OPB0_FSI_DATA_W\t0x20\n#define OPB0_STATUS\t0x80\n#define OPB0_FSI_DATA_R\t0x84\n\n#define OPB0_WRITE_ORDER1\t0x4c\n#define OPB0_WRITE_ORDER2\t0x50\n#define OPB1_WRITE_ORDER1\t0x54\n#define OPB1_WRITE_ORDER2\t0x58\n#define OPB0_READ_ORDER1\t0x5c\n#define OPB1_READ_ORDER2\t0x60\n\n#define OPB_RETRY_COUNTER\t0x64\n\n \n#define STATUS_HALFWORD_ACK\tBIT(0)\n#define STATUS_FULLWORD_ACK\tBIT(1)\n#define STATUS_ERR_ACK\t\tBIT(2)\n#define STATUS_RETRY\t\tBIT(3)\n#define STATUS_TIMEOUT\t\tBIT(4)\n\n \n#define OPB1_XFER_ACK_EN BIT(17)\n#define OPB0_XFER_ACK_EN BIT(16)\n\n \n#define CMD_READ\tBIT(0)\n#define CMD_WRITE\t0\n\n \n#define XFER_FULLWORD\t(BIT(1) | BIT(0))\n#define XFER_HALFWORD\t(BIT(0))\n#define XFER_BYTE\t(0)\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/fsi_master_aspeed.h>\n\n#define FSI_LINK_ENABLE_SETUP_TIME\t10\t \n\n \n#define FSI_DIVISOR_DEFAULT            1\n#define FSI_DIVISOR_CABLED             2\nstatic u16 aspeed_fsi_divisor = FSI_DIVISOR_DEFAULT;\nmodule_param_named(bus_div,aspeed_fsi_divisor, ushort, 0);\n\n#define OPB_POLL_TIMEOUT\t\t500\n\nstatic int __opb_write(struct fsi_master_aspeed *aspeed, u32 addr,\n\t\t       u32 val, u32 transfer_size)\n{\n\tvoid __iomem *base = aspeed->base;\n\tu32 reg, status;\n\tint ret;\n\n\t \n\twritel_relaxed(CMD_WRITE, base + OPB0_RW);\n\twritel_relaxed(transfer_size, base + OPB0_XFER_SIZE);\n\twritel_relaxed(addr, base + OPB0_FSI_ADDR);\n\twritel_relaxed(val, base + OPB0_FSI_DATA_W);\n\twritel_relaxed(0x1, base + OPB_IRQ_CLEAR);\n\twritel(0x1, base + OPB_TRIGGER);\n\n\tret = readl_poll_timeout(base + OPB_IRQ_STATUS, reg,\n\t\t\t\t(reg & OPB0_XFER_ACK_EN) != 0,\n\t\t\t\t0, OPB_POLL_TIMEOUT);\n\n\tstatus = readl(base + OPB0_STATUS);\n\n\ttrace_fsi_master_aspeed_opb_write(addr, val, transfer_size, status, reg);\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (status & STATUS_ERR_ACK)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int opb_writeb(struct fsi_master_aspeed *aspeed, u32 addr, u8 val)\n{\n\treturn __opb_write(aspeed, addr, val, XFER_BYTE);\n}\n\nstatic int opb_writew(struct fsi_master_aspeed *aspeed, u32 addr, __be16 val)\n{\n\treturn __opb_write(aspeed, addr, (__force u16)val, XFER_HALFWORD);\n}\n\nstatic int opb_writel(struct fsi_master_aspeed *aspeed, u32 addr, __be32 val)\n{\n\treturn __opb_write(aspeed, addr, (__force u32)val, XFER_FULLWORD);\n}\n\nstatic int __opb_read(struct fsi_master_aspeed *aspeed, uint32_t addr,\n\t\t      u32 transfer_size, void *out)\n{\n\tvoid __iomem *base = aspeed->base;\n\tu32 result, reg;\n\tint status, ret;\n\n\t \n\twritel_relaxed(CMD_READ, base + OPB0_RW);\n\twritel_relaxed(transfer_size, base + OPB0_XFER_SIZE);\n\twritel_relaxed(addr, base + OPB0_FSI_ADDR);\n\twritel_relaxed(0x1, base + OPB_IRQ_CLEAR);\n\twritel(0x1, base + OPB_TRIGGER);\n\n\tret = readl_poll_timeout(base + OPB_IRQ_STATUS, reg,\n\t\t\t   (reg & OPB0_XFER_ACK_EN) != 0,\n\t\t\t   0, OPB_POLL_TIMEOUT);\n\n\tstatus = readl(base + OPB0_STATUS);\n\n\tresult = readl(base + OPB0_FSI_DATA_R);\n\n\ttrace_fsi_master_aspeed_opb_read(addr, transfer_size, result,\n\t\t\treadl(base + OPB0_STATUS),\n\t\t\treg);\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (status & STATUS_ERR_ACK)\n\t\treturn -EIO;\n\n\tif (out) {\n\t\tswitch (transfer_size) {\n\t\tcase XFER_BYTE:\n\t\t\t*(u8 *)out = result;\n\t\t\tbreak;\n\t\tcase XFER_HALFWORD:\n\t\t\t*(u16 *)out = result;\n\t\t\tbreak;\n\t\tcase XFER_FULLWORD:\n\t\t\t*(u32 *)out = result;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int opb_readl(struct fsi_master_aspeed *aspeed, uint32_t addr, __be32 *out)\n{\n\treturn __opb_read(aspeed, addr, XFER_FULLWORD, out);\n}\n\nstatic int opb_readw(struct fsi_master_aspeed *aspeed, uint32_t addr, __be16 *out)\n{\n\treturn __opb_read(aspeed, addr, XFER_HALFWORD, (void *)out);\n}\n\nstatic int opb_readb(struct fsi_master_aspeed *aspeed, uint32_t addr, u8 *out)\n{\n\treturn __opb_read(aspeed, addr, XFER_BYTE, (void *)out);\n}\n\nstatic int check_errors(struct fsi_master_aspeed *aspeed, int err)\n{\n\tint ret;\n\n\tif (trace_fsi_master_aspeed_opb_error_enabled()) {\n\t\t__be32 mresp0, mstap0, mesrb0;\n\n\t\topb_readl(aspeed, ctrl_base + FSI_MRESP0, &mresp0);\n\t\topb_readl(aspeed, ctrl_base + FSI_MSTAP0, &mstap0);\n\t\topb_readl(aspeed, ctrl_base + FSI_MESRB0, &mesrb0);\n\n\t\ttrace_fsi_master_aspeed_opb_error(\n\t\t\t\tbe32_to_cpu(mresp0),\n\t\t\t\tbe32_to_cpu(mstap0),\n\t\t\t\tbe32_to_cpu(mesrb0));\n\t}\n\n\tif (err == -EIO) {\n\t\t \n\n\t\t \n\t\tret = opb_writel(aspeed, ctrl_base + FSI_MRESP0,\n\t\t\t\tcpu_to_be32(FSI_MRESP_RST_ALL_MASTER));\n\t\tif (ret) {\n\t\t\t \n\t\t\treturn ret;\n\t\t}\n\t\t \n\t}\n\n\t \n\treturn err;\n}\n\nstatic int aspeed_master_read(struct fsi_master *master, int link,\n\t\t\tuint8_t id, uint32_t addr, void *val, size_t size)\n{\n\tstruct fsi_master_aspeed *aspeed = to_fsi_master_aspeed(master);\n\tint ret;\n\n\tif (id > 0x3)\n\t\treturn -EINVAL;\n\n\taddr |= id << 21;\n\taddr += link * FSI_HUB_LINK_SIZE;\n\n\tmutex_lock(&aspeed->lock);\n\n\tswitch (size) {\n\tcase 1:\n\t\tret = opb_readb(aspeed, fsi_base + addr, val);\n\t\tbreak;\n\tcase 2:\n\t\tret = opb_readw(aspeed, fsi_base + addr, val);\n\t\tbreak;\n\tcase 4:\n\t\tret = opb_readl(aspeed, fsi_base + addr, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tret = check_errors(aspeed, ret);\ndone:\n\tmutex_unlock(&aspeed->lock);\n\treturn ret;\n}\n\nstatic int aspeed_master_write(struct fsi_master *master, int link,\n\t\t\tuint8_t id, uint32_t addr, const void *val, size_t size)\n{\n\tstruct fsi_master_aspeed *aspeed = to_fsi_master_aspeed(master);\n\tint ret;\n\n\tif (id > 0x3)\n\t\treturn -EINVAL;\n\n\taddr |= id << 21;\n\taddr += link * FSI_HUB_LINK_SIZE;\n\n\tmutex_lock(&aspeed->lock);\n\n\tswitch (size) {\n\tcase 1:\n\t\tret = opb_writeb(aspeed, fsi_base + addr, *(u8 *)val);\n\t\tbreak;\n\tcase 2:\n\t\tret = opb_writew(aspeed, fsi_base + addr, *(__be16 *)val);\n\t\tbreak;\n\tcase 4:\n\t\tret = opb_writel(aspeed, fsi_base + addr, *(__be32 *)val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tret = check_errors(aspeed, ret);\ndone:\n\tmutex_unlock(&aspeed->lock);\n\treturn ret;\n}\n\nstatic int aspeed_master_link_enable(struct fsi_master *master, int link,\n\t\t\t\t     bool enable)\n{\n\tstruct fsi_master_aspeed *aspeed = to_fsi_master_aspeed(master);\n\tint idx, bit, ret;\n\t__be32 reg;\n\n\tidx = link / 32;\n\tbit = link % 32;\n\n\treg = cpu_to_be32(0x80000000 >> bit);\n\n\tmutex_lock(&aspeed->lock);\n\n\tif (!enable) {\n\t\tret = opb_writel(aspeed, ctrl_base + FSI_MCENP0 + (4 * idx), reg);\n\t\tgoto done;\n\t}\n\n\tret = opb_writel(aspeed, ctrl_base + FSI_MSENP0 + (4 * idx), reg);\n\tif (ret)\n\t\tgoto done;\n\n\tmdelay(FSI_LINK_ENABLE_SETUP_TIME);\ndone:\n\tmutex_unlock(&aspeed->lock);\n\treturn ret;\n}\n\nstatic int aspeed_master_term(struct fsi_master *master, int link, uint8_t id)\n{\n\tuint32_t addr;\n\t__be32 cmd;\n\n\taddr = 0x4;\n\tcmd = cpu_to_be32(0xecc00000);\n\n\treturn aspeed_master_write(master, link, id, addr, &cmd, 4);\n}\n\nstatic int aspeed_master_break(struct fsi_master *master, int link)\n{\n\tuint32_t addr;\n\t__be32 cmd;\n\n\taddr = 0x0;\n\tcmd = cpu_to_be32(0xc0de0000);\n\n\treturn aspeed_master_write(master, link, 0, addr, &cmd, 4);\n}\n\nstatic void aspeed_master_release(struct device *dev)\n{\n\tstruct fsi_master_aspeed *aspeed =\n\t\tto_fsi_master_aspeed(to_fsi_master(dev));\n\n\tkfree(aspeed);\n}\n\n \nstatic inline u32 fsi_mmode_crs0(u32 x)\n{\n\treturn (x & FSI_MMODE_CRS0MASK) << FSI_MMODE_CRS0SHFT;\n}\n\nstatic inline u32 fsi_mmode_crs1(u32 x)\n{\n\treturn (x & FSI_MMODE_CRS1MASK) << FSI_MMODE_CRS1SHFT;\n}\n\nstatic int aspeed_master_init(struct fsi_master_aspeed *aspeed)\n{\n\t__be32 reg;\n\n\treg = cpu_to_be32(FSI_MRESP_RST_ALL_MASTER | FSI_MRESP_RST_ALL_LINK\n\t\t\t| FSI_MRESP_RST_MCR | FSI_MRESP_RST_PYE);\n\topb_writel(aspeed, ctrl_base + FSI_MRESP0, reg);\n\n\t \n\treg = cpu_to_be32(FSI_MRESP_RST_ALL_MASTER | FSI_MRESP_RST_ALL_LINK\n\t\t\t| FSI_MRESP_RST_MCR | FSI_MRESP_RST_PYE);\n\topb_writel(aspeed, ctrl_base + FSI_MRESP0, reg);\n\n\treg = cpu_to_be32(FSI_MECTRL_EOAE | FSI_MECTRL_P8_AUTO_TERM);\n\topb_writel(aspeed, ctrl_base + FSI_MECTRL, reg);\n\n\treg = cpu_to_be32(FSI_MMODE_ECRC | FSI_MMODE_EPC | FSI_MMODE_RELA\n\t\t\t| fsi_mmode_crs0(aspeed_fsi_divisor)\n\t\t\t| fsi_mmode_crs1(aspeed_fsi_divisor)\n\t\t\t| FSI_MMODE_P8_TO_LSB);\n\tdev_info(aspeed->dev, \"mmode set to %08x (divisor %d)\\n\",\n\t\t\tbe32_to_cpu(reg), aspeed_fsi_divisor);\n\topb_writel(aspeed, ctrl_base + FSI_MMODE, reg);\n\n\treg = cpu_to_be32(0xffff0000);\n\topb_writel(aspeed, ctrl_base + FSI_MDLYR, reg);\n\n\treg = cpu_to_be32(~0);\n\topb_writel(aspeed, ctrl_base + FSI_MSENP0, reg);\n\n\t \n\tmdelay(FSI_LINK_ENABLE_SETUP_TIME);\n\n\topb_writel(aspeed, ctrl_base + FSI_MCENP0, reg);\n\n\topb_readl(aspeed, ctrl_base + FSI_MAEB, NULL);\n\n\treg = cpu_to_be32(FSI_MRESP_RST_ALL_MASTER | FSI_MRESP_RST_ALL_LINK);\n\topb_writel(aspeed, ctrl_base + FSI_MRESP0, reg);\n\n\topb_readl(aspeed, ctrl_base + FSI_MLEVP0, NULL);\n\n\t \n\treg = cpu_to_be32(FSI_MRESB_RST_GEN);\n\topb_writel(aspeed, ctrl_base + FSI_MRESB0, reg);\n\n\treg = cpu_to_be32(FSI_MRESB_RST_ERR);\n\topb_writel(aspeed, ctrl_base + FSI_MRESB0, reg);\n\n\treturn 0;\n}\n\nstatic ssize_t cfam_reset_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct fsi_master_aspeed *aspeed = dev_get_drvdata(dev);\n\n\ttrace_fsi_master_aspeed_cfam_reset(true);\n\tmutex_lock(&aspeed->lock);\n\tgpiod_set_value(aspeed->cfam_reset_gpio, 1);\n\tusleep_range(900, 1000);\n\tgpiod_set_value(aspeed->cfam_reset_gpio, 0);\n\tusleep_range(900, 1000);\n\topb_writel(aspeed, ctrl_base + FSI_MRESP0, cpu_to_be32(FSI_MRESP_RST_ALL_MASTER));\n\tmutex_unlock(&aspeed->lock);\n\ttrace_fsi_master_aspeed_cfam_reset(false);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(cfam_reset, 0200, NULL, cfam_reset_store);\n\nstatic int setup_cfam_reset(struct fsi_master_aspeed *aspeed)\n{\n\tstruct device *dev = aspeed->dev;\n\tstruct gpio_desc *gpio;\n\tint rc;\n\n\tgpio = devm_gpiod_get_optional(dev, \"cfam-reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\tif (!gpio)\n\t\treturn 0;\n\n\taspeed->cfam_reset_gpio = gpio;\n\n\trc = device_create_file(dev, &dev_attr_cfam_reset);\n\tif (rc) {\n\t\tdevm_gpiod_put(dev, gpio);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int tacoma_cabled_fsi_fixup(struct device *dev)\n{\n\tstruct gpio_desc *routing_gpio, *mux_gpio;\n\tint gpio;\n\n\t \n\trouting_gpio = devm_gpiod_get_optional(dev, \"fsi-routing\",\n\t\t\tGPIOD_IN | GPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\tif (IS_ERR(routing_gpio))\n\t\treturn PTR_ERR(routing_gpio);\n\tif (!routing_gpio)\n\t\treturn 0;\n\n\tmux_gpio = devm_gpiod_get_optional(dev, \"fsi-mux\", GPIOD_ASIS);\n\tif (IS_ERR(mux_gpio))\n\t\treturn PTR_ERR(mux_gpio);\n\tif (!mux_gpio)\n\t\treturn 0;\n\n\tgpio = gpiod_get_value(routing_gpio);\n\tif (gpio < 0)\n\t\treturn gpio;\n\n\t \n\tif (gpio) {\n\t\t \n\t\tif (aspeed_fsi_divisor == FSI_DIVISOR_DEFAULT)\n\t\t\taspeed_fsi_divisor = FSI_DIVISOR_CABLED;\n\n\t\tgpiod_direction_output(mux_gpio, 0);\n\t\tdev_info(dev, \"FSI configured for external cable\\n\");\n\t} else {\n\t\tgpiod_direction_output(mux_gpio, 1);\n\t}\n\n\tdevm_gpiod_put(dev, routing_gpio);\n\n\treturn 0;\n}\n\nstatic int fsi_master_aspeed_probe(struct platform_device *pdev)\n{\n\tstruct fsi_master_aspeed *aspeed;\n\tint rc, links, reg;\n\t__be32 raw;\n\n\trc = tacoma_cabled_fsi_fixup(&pdev->dev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Tacoma FSI cable fixup failed\\n\");\n\t\treturn rc;\n\t}\n\n\taspeed = kzalloc(sizeof(*aspeed), GFP_KERNEL);\n\tif (!aspeed)\n\t\treturn -ENOMEM;\n\n\taspeed->dev = &pdev->dev;\n\n\taspeed->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(aspeed->base)) {\n\t\trc = PTR_ERR(aspeed->base);\n\t\tgoto err_free_aspeed;\n\t}\n\n\taspeed->clk = devm_clk_get(aspeed->dev, NULL);\n\tif (IS_ERR(aspeed->clk)) {\n\t\tdev_err(aspeed->dev, \"couldn't get clock\\n\");\n\t\trc = PTR_ERR(aspeed->clk);\n\t\tgoto err_free_aspeed;\n\t}\n\trc = clk_prepare_enable(aspeed->clk);\n\tif (rc) {\n\t\tdev_err(aspeed->dev, \"couldn't enable clock\\n\");\n\t\tgoto err_free_aspeed;\n\t}\n\n\trc = setup_cfam_reset(aspeed);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"CFAM reset GPIO setup failed\\n\");\n\t}\n\n\twritel(0x1, aspeed->base + OPB_CLK_SYNC);\n\twritel(OPB1_XFER_ACK_EN | OPB0_XFER_ACK_EN,\n\t\t\taspeed->base + OPB_IRQ_MASK);\n\n\t \n\twritel(0x10, aspeed->base + OPB_RETRY_COUNTER);\n\n\twritel(ctrl_base, aspeed->base + OPB_CTRL_BASE);\n\twritel(fsi_base, aspeed->base + OPB_FSI_BASE);\n\n\t \n\twritel(0x00030b1b, aspeed->base + OPB0_READ_ORDER1);\n\n\t \n\twritel(0x0011101b, aspeed->base + OPB0_WRITE_ORDER1);\n\twritel(0x0c330f3f, aspeed->base + OPB0_WRITE_ORDER2);\n\n\t \n\twritel(0x1, aspeed->base + OPB0_SELECT);\n\n\trc = opb_readl(aspeed, ctrl_base + FSI_MVER, &raw);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"failed to read hub version\\n\");\n\t\tgoto err_release;\n\t}\n\n\treg = be32_to_cpu(raw);\n\tlinks = (reg >> 8) & 0xff;\n\tdev_info(&pdev->dev, \"hub version %08x (%d links)\\n\", reg, links);\n\n\taspeed->master.dev.parent = &pdev->dev;\n\taspeed->master.dev.release = aspeed_master_release;\n\taspeed->master.dev.of_node = of_node_get(dev_of_node(&pdev->dev));\n\n\taspeed->master.n_links = links;\n\taspeed->master.read = aspeed_master_read;\n\taspeed->master.write = aspeed_master_write;\n\taspeed->master.send_break = aspeed_master_break;\n\taspeed->master.term = aspeed_master_term;\n\taspeed->master.link_enable = aspeed_master_link_enable;\n\n\tdev_set_drvdata(&pdev->dev, aspeed);\n\n\tmutex_init(&aspeed->lock);\n\taspeed_master_init(aspeed);\n\n\trc = fsi_master_register(&aspeed->master);\n\tif (rc)\n\t\tgoto err_release;\n\n\t \n\tget_device(&aspeed->master.dev);\n\treturn 0;\n\nerr_release:\n\tclk_disable_unprepare(aspeed->clk);\nerr_free_aspeed:\n\tkfree(aspeed);\n\treturn rc;\n}\n\nstatic int fsi_master_aspeed_remove(struct platform_device *pdev)\n{\n\tstruct fsi_master_aspeed *aspeed = platform_get_drvdata(pdev);\n\n\tfsi_master_unregister(&aspeed->master);\n\tclk_disable_unprepare(aspeed->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id fsi_master_aspeed_match[] = {\n\t{ .compatible = \"aspeed,ast2600-fsi-master\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, fsi_master_aspeed_match);\n\nstatic struct platform_driver fsi_master_aspeed_driver = {\n\t.driver = {\n\t\t.name\t\t= \"fsi-master-aspeed\",\n\t\t.of_match_table\t= fsi_master_aspeed_match,\n\t},\n\t.probe\t= fsi_master_aspeed_probe,\n\t.remove = fsi_master_aspeed_remove,\n};\n\nmodule_platform_driver(fsi_master_aspeed_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}