{
  "module_name": "fsi-core.c",
  "hash_id": "c06dfd939cc658da4015ff7a76d81a12ced11e51a35d8442a2276526aaa5f641",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fsi/fsi-core.c",
  "human_readable_source": "\n \n\n#include <linux/crc4.h>\n#include <linux/device.h>\n#include <linux/fsi.h>\n#include <linux/idr.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/cdev.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n\n#include \"fsi-master.h\"\n#include \"fsi-slave.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/fsi.h>\n\n#define FSI_SLAVE_CONF_NEXT_MASK\tGENMASK(31, 31)\n#define FSI_SLAVE_CONF_SLOTS_MASK\tGENMASK(23, 16)\n#define FSI_SLAVE_CONF_SLOTS_SHIFT\t16\n#define FSI_SLAVE_CONF_VERSION_MASK\tGENMASK(15, 12)\n#define FSI_SLAVE_CONF_VERSION_SHIFT\t12\n#define FSI_SLAVE_CONF_TYPE_MASK\tGENMASK(11, 4)\n#define FSI_SLAVE_CONF_TYPE_SHIFT\t4\n#define FSI_SLAVE_CONF_CRC_SHIFT\t4\n#define FSI_SLAVE_CONF_CRC_MASK\t\tGENMASK(3, 0)\n#define FSI_SLAVE_CONF_DATA_BITS\t28\n\n#define FSI_PEEK_BASE\t\t\t0x410\n\nstatic const int engine_page_size = 0x400;\n\n#define FSI_SLAVE_BASE\t\t\t0x800\n\n \n#define FSI_SMODE\t\t0x0\t \n#define FSI_SISC\t\t0x8\t \n#define FSI_SSTAT\t\t0x14\t \n#define FSI_SLBUS\t\t0x30\t \n#define FSI_LLMODE\t\t0x100\t \n\n \n#define FSI_SMODE_WSC\t\t0x80000000\t \n#define FSI_SMODE_ECRC\t\t0x20000000\t \n#define FSI_SMODE_SID_SHIFT\t24\t\t \n#define FSI_SMODE_SID_MASK\t3\t\t \n#define FSI_SMODE_ED_SHIFT\t20\t\t \n#define FSI_SMODE_ED_MASK\t0xf\t\t \n#define FSI_SMODE_SD_SHIFT\t16\t\t \n#define FSI_SMODE_SD_MASK\t0xf\t\t \n#define FSI_SMODE_LBCRR_SHIFT\t8\t\t \n#define FSI_SMODE_LBCRR_MASK\t0xf\t\t \n\n \n#define FSI_SLBUS_FORCE\t\t0x80000000\t \n\n \n#define FSI_LLMODE_ASYNC\t0x1\n\n#define FSI_SLAVE_SIZE_23b\t\t0x800000\n\nstatic DEFINE_IDA(master_ida);\n\nstatic const int slave_retries = 2;\nstatic int discard_errors;\n\nstatic dev_t fsi_base_dev;\nstatic DEFINE_IDA(fsi_minor_ida);\n#define FSI_CHAR_MAX_DEVICES\t0x1000\n\n \n#define FSI_CHAR_LEGACY_TOP\t64\n\nstatic int fsi_master_read(struct fsi_master *master, int link,\n\t\tuint8_t slave_id, uint32_t addr, void *val, size_t size);\nstatic int fsi_master_write(struct fsi_master *master, int link,\n\t\tuint8_t slave_id, uint32_t addr, const void *val, size_t size);\nstatic int fsi_master_break(struct fsi_master *master, int link);\n\n \nint fsi_device_read(struct fsi_device *dev, uint32_t addr, void *val,\n\t\tsize_t size)\n{\n\tif (addr > dev->size || size > dev->size || addr > dev->size - size)\n\t\treturn -EINVAL;\n\n\treturn fsi_slave_read(dev->slave, dev->addr + addr, val, size);\n}\nEXPORT_SYMBOL_GPL(fsi_device_read);\n\nint fsi_device_write(struct fsi_device *dev, uint32_t addr, const void *val,\n\t\tsize_t size)\n{\n\tif (addr > dev->size || size > dev->size || addr > dev->size - size)\n\t\treturn -EINVAL;\n\n\treturn fsi_slave_write(dev->slave, dev->addr + addr, val, size);\n}\nEXPORT_SYMBOL_GPL(fsi_device_write);\n\nint fsi_device_peek(struct fsi_device *dev, void *val)\n{\n\tuint32_t addr = FSI_PEEK_BASE + ((dev->unit - 2) * sizeof(uint32_t));\n\n\treturn fsi_slave_read(dev->slave, addr, val, sizeof(uint32_t));\n}\n\nstatic void fsi_device_release(struct device *_device)\n{\n\tstruct fsi_device *device = to_fsi_dev(_device);\n\n\tof_node_put(device->dev.of_node);\n\tkfree(device);\n}\n\nstatic struct fsi_device *fsi_create_device(struct fsi_slave *slave)\n{\n\tstruct fsi_device *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev->dev.parent = &slave->dev;\n\tdev->dev.bus = &fsi_bus_type;\n\tdev->dev.release = fsi_device_release;\n\n\treturn dev;\n}\n\n \nstatic int fsi_slave_calc_addr(struct fsi_slave *slave, uint32_t *addrp,\n\t\tuint8_t *idp)\n{\n\tuint32_t addr = *addrp;\n\tuint8_t id = *idp;\n\n\tif (addr > slave->size)\n\t\treturn -EINVAL;\n\n\t \n\tif (addr > 0x1fffff) {\n\t\tif (slave->id != 0)\n\t\t\treturn -EINVAL;\n\t\tid = (addr >> 21) & 0x3;\n\t\taddr &= 0x1fffff;\n\t}\n\n\t*addrp = addr;\n\t*idp = id;\n\treturn 0;\n}\n\nstatic int fsi_slave_report_and_clear_errors(struct fsi_slave *slave)\n{\n\tstruct fsi_master *master = slave->master;\n\t__be32 irq, stat;\n\tint rc, link;\n\tuint8_t id;\n\n\tlink = slave->link;\n\tid = slave->id;\n\n\trc = fsi_master_read(master, link, id, FSI_SLAVE_BASE + FSI_SISC,\n\t\t\t&irq, sizeof(irq));\n\tif (rc)\n\t\treturn rc;\n\n\trc =  fsi_master_read(master, link, id, FSI_SLAVE_BASE + FSI_SSTAT,\n\t\t\t&stat, sizeof(stat));\n\tif (rc)\n\t\treturn rc;\n\n\tdev_dbg(&slave->dev, \"status: 0x%08x, sisc: 0x%08x\\n\",\n\t\t\tbe32_to_cpu(stat), be32_to_cpu(irq));\n\n\t \n\treturn fsi_master_write(master, link, id, FSI_SLAVE_BASE + FSI_SISC,\n\t\t\t&irq, sizeof(irq));\n}\n\n \nstatic inline uint32_t fsi_smode_echodly(int x)\n{\n\treturn (x & FSI_SMODE_ED_MASK) << FSI_SMODE_ED_SHIFT;\n}\n\n \nstatic inline uint32_t fsi_smode_senddly(int x)\n{\n\treturn (x & FSI_SMODE_SD_MASK) << FSI_SMODE_SD_SHIFT;\n}\n\n \nstatic inline uint32_t fsi_smode_lbcrr(int x)\n{\n\treturn (x & FSI_SMODE_LBCRR_MASK) << FSI_SMODE_LBCRR_SHIFT;\n}\n\n \nstatic inline uint32_t fsi_smode_sid(int x)\n{\n\treturn (x & FSI_SMODE_SID_MASK) << FSI_SMODE_SID_SHIFT;\n}\n\nstatic uint32_t fsi_slave_smode(int id, u8 t_senddly, u8 t_echodly)\n{\n\treturn FSI_SMODE_WSC | FSI_SMODE_ECRC\n\t\t| fsi_smode_sid(id)\n\t\t| fsi_smode_echodly(t_echodly - 1) | fsi_smode_senddly(t_senddly - 1)\n\t\t| fsi_smode_lbcrr(0x8);\n}\n\nstatic int fsi_slave_set_smode(struct fsi_slave *slave)\n{\n\tuint32_t smode;\n\t__be32 data;\n\n\t \n\tsmode = fsi_slave_smode(slave->id, slave->t_send_delay, slave->t_echo_delay);\n\tdata = cpu_to_be32(smode);\n\n\treturn fsi_master_write(slave->master, slave->link, slave->id,\n\t\t\t\tFSI_SLAVE_BASE + FSI_SMODE,\n\t\t\t\t&data, sizeof(data));\n}\n\nstatic int fsi_slave_handle_error(struct fsi_slave *slave, bool write,\n\t\t\t\t  uint32_t addr, size_t size)\n{\n\tstruct fsi_master *master = slave->master;\n\tint rc, link;\n\tuint32_t reg;\n\tuint8_t id, send_delay, echo_delay;\n\n\tif (discard_errors)\n\t\treturn -1;\n\n\tlink = slave->link;\n\tid = slave->id;\n\n\tdev_dbg(&slave->dev, \"handling error on %s to 0x%08x[%zd]\",\n\t\t\twrite ? \"write\" : \"read\", addr, size);\n\n\t \n\trc = fsi_slave_report_and_clear_errors(slave);\n\tif (!rc)\n\t\treturn 0;\n\n\t \n\tif (master->term) {\n\t\trc = master->term(master, link, id);\n\t\tif (!rc) {\n\t\t\trc = fsi_master_read(master, link, id, 0,\n\t\t\t\t\t&reg, sizeof(reg));\n\t\t\tif (!rc)\n\t\t\t\trc = fsi_slave_report_and_clear_errors(slave);\n\t\t\tif (!rc)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsend_delay = slave->t_send_delay;\n\techo_delay = slave->t_echo_delay;\n\n\t \n\trc = fsi_master_break(master, link);\n\tif (rc)\n\t\treturn rc;\n\n\tslave->t_send_delay = send_delay;\n\tslave->t_echo_delay = echo_delay;\n\n\trc = fsi_slave_set_smode(slave);\n\tif (rc)\n\t\treturn rc;\n\n\tif (master->link_config)\n\t\tmaster->link_config(master, link,\n\t\t\t\t    slave->t_send_delay,\n\t\t\t\t    slave->t_echo_delay);\n\n\treturn fsi_slave_report_and_clear_errors(slave);\n}\n\nint fsi_slave_read(struct fsi_slave *slave, uint32_t addr,\n\t\t\tvoid *val, size_t size)\n{\n\tuint8_t id = slave->id;\n\tint rc, err_rc, i;\n\n\trc = fsi_slave_calc_addr(slave, &addr, &id);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < slave_retries; i++) {\n\t\trc = fsi_master_read(slave->master, slave->link,\n\t\t\t\tid, addr, val, size);\n\t\tif (!rc)\n\t\t\tbreak;\n\n\t\terr_rc = fsi_slave_handle_error(slave, false, addr, size);\n\t\tif (err_rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(fsi_slave_read);\n\nint fsi_slave_write(struct fsi_slave *slave, uint32_t addr,\n\t\t\tconst void *val, size_t size)\n{\n\tuint8_t id = slave->id;\n\tint rc, err_rc, i;\n\n\trc = fsi_slave_calc_addr(slave, &addr, &id);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < slave_retries; i++) {\n\t\trc = fsi_master_write(slave->master, slave->link,\n\t\t\t\tid, addr, val, size);\n\t\tif (!rc)\n\t\t\tbreak;\n\n\t\terr_rc = fsi_slave_handle_error(slave, true, addr, size);\n\t\tif (err_rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(fsi_slave_write);\n\nint fsi_slave_claim_range(struct fsi_slave *slave,\n\t\t\t  uint32_t addr, uint32_t size)\n{\n\tif (addr + size < addr)\n\t\treturn -EINVAL;\n\n\tif (addr + size > slave->size)\n\t\treturn -EINVAL;\n\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fsi_slave_claim_range);\n\nvoid fsi_slave_release_range(struct fsi_slave *slave,\n\t\t\t     uint32_t addr, uint32_t size)\n{\n}\nEXPORT_SYMBOL_GPL(fsi_slave_release_range);\n\nstatic bool fsi_device_node_matches(struct device *dev, struct device_node *np,\n\t\tuint32_t addr, uint32_t size)\n{\n\tu64 paddr, psize;\n\n\tif (of_property_read_reg(np, 0, &paddr, &psize))\n\t\treturn false;\n\n\tif (paddr != addr)\n\t\treturn false;\n\n\tif (psize != size) {\n\t\tdev_warn(dev,\n\t\t\t\"node %pOF matches probed address, but not size (got 0x%llx, expected 0x%x)\",\n\t\t\tnp, psize, size);\n\t}\n\n\treturn true;\n}\n\n \nstatic struct device_node *fsi_device_find_of_node(struct fsi_device *dev)\n{\n\tstruct device_node *parent, *np;\n\n\tparent = dev_of_node(&dev->slave->dev);\n\tif (!parent)\n\t\treturn NULL;\n\n\tfor_each_child_of_node(parent, np) {\n\t\tif (fsi_device_node_matches(&dev->dev, np,\n\t\t\t\t\tdev->addr, dev->size))\n\t\t\treturn np;\n\t}\n\n\treturn NULL;\n}\n\nstatic int fsi_slave_scan(struct fsi_slave *slave)\n{\n\tuint32_t engine_addr;\n\tint rc, i;\n\n\t \n\tengine_addr = engine_page_size * 3;\n\tfor (i = 2; i < engine_page_size / sizeof(uint32_t); i++) {\n\t\tuint8_t slots, version, type, crc;\n\t\tstruct fsi_device *dev;\n\t\tuint32_t conf;\n\t\t__be32 data;\n\n\t\trc = fsi_slave_read(slave, (i + 1) * sizeof(data),\n\t\t\t\t&data, sizeof(data));\n\t\tif (rc) {\n\t\t\tdev_warn(&slave->dev,\n\t\t\t\t\"error reading slave registers\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tconf = be32_to_cpu(data);\n\n\t\tcrc = crc4(0, conf, 32);\n\t\tif (crc) {\n\t\t\tdev_warn(&slave->dev,\n\t\t\t\t\"crc error in slave register at 0x%04x\\n\",\n\t\t\t\ti);\n\t\t\treturn -1;\n\t\t}\n\n\t\tslots = (conf & FSI_SLAVE_CONF_SLOTS_MASK)\n\t\t\t>> FSI_SLAVE_CONF_SLOTS_SHIFT;\n\t\tversion = (conf & FSI_SLAVE_CONF_VERSION_MASK)\n\t\t\t>> FSI_SLAVE_CONF_VERSION_SHIFT;\n\t\ttype = (conf & FSI_SLAVE_CONF_TYPE_MASK)\n\t\t\t>> FSI_SLAVE_CONF_TYPE_SHIFT;\n\n\t\t \n\t\tif (type != 0 && slots != 0) {\n\n\t\t\t \n\t\t\tdev = fsi_create_device(slave);\n\t\t\tif (!dev)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdev->slave = slave;\n\t\t\tdev->engine_type = type;\n\t\t\tdev->version = version;\n\t\t\tdev->unit = i;\n\t\t\tdev->addr = engine_addr;\n\t\t\tdev->size = slots * engine_page_size;\n\n\t\t\ttrace_fsi_dev_init(dev);\n\n\t\t\tdev_dbg(&slave->dev,\n\t\t\t\"engine[%i]: type %x, version %x, addr %x size %x\\n\",\n\t\t\t\t\tdev->unit, dev->engine_type, version,\n\t\t\t\t\tdev->addr, dev->size);\n\n\t\t\tdev_set_name(&dev->dev, \"%02x:%02x:%02x:%02x\",\n\t\t\t\t\tslave->master->idx, slave->link,\n\t\t\t\t\tslave->id, i - 2);\n\t\t\tdev->dev.of_node = fsi_device_find_of_node(dev);\n\n\t\t\trc = device_register(&dev->dev);\n\t\t\tif (rc) {\n\t\t\t\tdev_warn(&slave->dev, \"add failed: %d\\n\", rc);\n\t\t\t\tput_device(&dev->dev);\n\t\t\t}\n\t\t}\n\n\t\tengine_addr += slots * engine_page_size;\n\n\t\tif (!(conf & FSI_SLAVE_CONF_NEXT_MASK))\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long aligned_access_size(size_t offset, size_t count)\n{\n\tunsigned long offset_unit, count_unit;\n\n\t \n\n\t \n\toffset_unit = BIT(__builtin_ctzl(offset | 4));\n\n\t \n\tcount_unit = BIT(8 * sizeof(unsigned long) - 1 - __builtin_clzl(count));\n\n\t \n\treturn BIT(__builtin_ctzl(offset_unit | count_unit));\n}\n\nstatic ssize_t fsi_slave_sysfs_raw_read(struct file *file,\n\t\tstruct kobject *kobj, struct bin_attribute *attr, char *buf,\n\t\tloff_t off, size_t count)\n{\n\tstruct fsi_slave *slave = to_fsi_slave(kobj_to_dev(kobj));\n\tsize_t total_len, read_len;\n\tint rc;\n\n\tif (off < 0)\n\t\treturn -EINVAL;\n\n\tif (off > 0xffffffff || count > 0xffffffff || off + count > 0xffffffff)\n\t\treturn -EINVAL;\n\n\tfor (total_len = 0; total_len < count; total_len += read_len) {\n\t\tread_len = aligned_access_size(off, count - total_len);\n\n\t\trc = fsi_slave_read(slave, off, buf + total_len, read_len);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\toff += read_len;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t fsi_slave_sysfs_raw_write(struct file *file,\n\t\tstruct kobject *kobj, struct bin_attribute *attr,\n\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct fsi_slave *slave = to_fsi_slave(kobj_to_dev(kobj));\n\tsize_t total_len, write_len;\n\tint rc;\n\n\tif (off < 0)\n\t\treturn -EINVAL;\n\n\tif (off > 0xffffffff || count > 0xffffffff || off + count > 0xffffffff)\n\t\treturn -EINVAL;\n\n\tfor (total_len = 0; total_len < count; total_len += write_len) {\n\t\twrite_len = aligned_access_size(off, count - total_len);\n\n\t\trc = fsi_slave_write(slave, off, buf + total_len, write_len);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\toff += write_len;\n\t}\n\n\treturn count;\n}\n\nstatic const struct bin_attribute fsi_slave_raw_attr = {\n\t.attr = {\n\t\t.name = \"raw\",\n\t\t.mode = 0600,\n\t},\n\t.size = 0,\n\t.read = fsi_slave_sysfs_raw_read,\n\t.write = fsi_slave_sysfs_raw_write,\n};\n\nstatic void fsi_slave_release(struct device *dev)\n{\n\tstruct fsi_slave *slave = to_fsi_slave(dev);\n\n\tfsi_free_minor(slave->dev.devt);\n\tof_node_put(dev->of_node);\n\tkfree(slave);\n}\n\nstatic bool fsi_slave_node_matches(struct device_node *np,\n\t\tint link, uint8_t id)\n{\n\tu64 addr;\n\n\tif (of_property_read_reg(np, 0, &addr, NULL))\n\t\treturn false;\n\n\treturn addr == (((u64)link << 32) | id);\n}\n\n \nstatic struct device_node *fsi_slave_find_of_node(struct fsi_master *master,\n\t\tint link, uint8_t id)\n{\n\tstruct device_node *parent, *np;\n\n\tparent = dev_of_node(&master->dev);\n\tif (!parent)\n\t\treturn NULL;\n\n\tfor_each_child_of_node(parent, np) {\n\t\tif (fsi_slave_node_matches(np, link, id))\n\t\t\treturn np;\n\t}\n\n\treturn NULL;\n}\n\nstatic ssize_t cfam_read(struct file *filep, char __user *buf, size_t count,\n\t\t\t loff_t *offset)\n{\n\tstruct fsi_slave *slave = filep->private_data;\n\tsize_t total_len, read_len;\n\tloff_t off = *offset;\n\tssize_t rc;\n\n\tif (off < 0)\n\t\treturn -EINVAL;\n\n\tif (off > 0xffffffff || count > 0xffffffff || off + count > 0xffffffff)\n\t\treturn -EINVAL;\n\n\tfor (total_len = 0; total_len < count; total_len += read_len) {\n\t\t__be32 data;\n\n\t\tread_len = min_t(size_t, count, 4);\n\t\tread_len -= off & 0x3;\n\n\t\trc = fsi_slave_read(slave, off, &data, read_len);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t\trc = copy_to_user(buf + total_len, &data, read_len);\n\t\tif (rc) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto fail;\n\t\t}\n\t\toff += read_len;\n\t}\n\trc = count;\n fail:\n\t*offset = off;\n\treturn rc;\n}\n\nstatic ssize_t cfam_write(struct file *filep, const char __user *buf,\n\t\t\t  size_t count, loff_t *offset)\n{\n\tstruct fsi_slave *slave = filep->private_data;\n\tsize_t total_len, write_len;\n\tloff_t off = *offset;\n\tssize_t rc;\n\n\n\tif (off < 0)\n\t\treturn -EINVAL;\n\n\tif (off > 0xffffffff || count > 0xffffffff || off + count > 0xffffffff)\n\t\treturn -EINVAL;\n\n\tfor (total_len = 0; total_len < count; total_len += write_len) {\n\t\t__be32 data;\n\n\t\twrite_len = min_t(size_t, count, 4);\n\t\twrite_len -= off & 0x3;\n\n\t\trc = copy_from_user(&data, buf + total_len, write_len);\n\t\tif (rc) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto fail;\n\t\t}\n\t\trc = fsi_slave_write(slave, off, &data, write_len);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t\toff += write_len;\n\t}\n\trc = count;\n fail:\n\t*offset = off;\n\treturn rc;\n}\n\nstatic loff_t cfam_llseek(struct file *file, loff_t offset, int whence)\n{\n\tswitch (whence) {\n\tcase SEEK_CUR:\n\t\tbreak;\n\tcase SEEK_SET:\n\t\tfile->f_pos = offset;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn offset;\n}\n\nstatic int cfam_open(struct inode *inode, struct file *file)\n{\n\tstruct fsi_slave *slave = container_of(inode->i_cdev, struct fsi_slave, cdev);\n\n\tfile->private_data = slave;\n\n\treturn 0;\n}\n\nstatic const struct file_operations cfam_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= cfam_open,\n\t.llseek\t\t= cfam_llseek,\n\t.read\t\t= cfam_read,\n\t.write\t\t= cfam_write,\n};\n\nstatic ssize_t send_term_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct fsi_slave *slave = to_fsi_slave(dev);\n\tstruct fsi_master *master = slave->master;\n\n\tif (!master->term)\n\t\treturn -ENODEV;\n\n\tmaster->term(master, slave->link, slave->id);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_WO(send_term);\n\nstatic ssize_t slave_send_echo_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct fsi_slave *slave = to_fsi_slave(dev);\n\n\treturn sprintf(buf, \"%u\\n\", slave->t_send_delay);\n}\n\nstatic ssize_t slave_send_echo_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct fsi_slave *slave = to_fsi_slave(dev);\n\tstruct fsi_master *master = slave->master;\n\tunsigned long val;\n\tint rc;\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (val < 1 || val > 16)\n\t\treturn -EINVAL;\n\n\tif (!master->link_config)\n\t\treturn -ENXIO;\n\n\t \n\tslave->t_send_delay = val;\n\tslave->t_echo_delay = val;\n\n\trc = fsi_slave_set_smode(slave);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (master->link_config)\n\t\tmaster->link_config(master, slave->link,\n\t\t\t\t    slave->t_send_delay,\n\t\t\t\t    slave->t_echo_delay);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(send_echo_delays, 0600,\n\t\t   slave_send_echo_show, slave_send_echo_store);\n\nstatic ssize_t chip_id_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct fsi_slave *slave = to_fsi_slave(dev);\n\n\treturn sprintf(buf, \"%d\\n\", slave->chip_id);\n}\n\nstatic DEVICE_ATTR_RO(chip_id);\n\nstatic ssize_t cfam_id_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct fsi_slave *slave = to_fsi_slave(dev);\n\n\treturn sprintf(buf, \"0x%x\\n\", slave->cfam_id);\n}\n\nstatic DEVICE_ATTR_RO(cfam_id);\n\nstatic struct attribute *cfam_attr[] = {\n\t&dev_attr_send_echo_delays.attr,\n\t&dev_attr_chip_id.attr,\n\t&dev_attr_cfam_id.attr,\n\t&dev_attr_send_term.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cfam_attr_group = {\n\t.attrs = cfam_attr,\n};\n\nstatic const struct attribute_group *cfam_attr_groups[] = {\n\t&cfam_attr_group,\n\tNULL,\n};\n\nstatic char *cfam_devnode(const struct device *dev, umode_t *mode,\n\t\t\t  kuid_t *uid, kgid_t *gid)\n{\n\tconst struct fsi_slave *slave = to_fsi_slave(dev);\n\n#ifdef CONFIG_FSI_NEW_DEV_NODE\n\treturn kasprintf(GFP_KERNEL, \"fsi/cfam%d\", slave->cdev_idx);\n#else\n\treturn kasprintf(GFP_KERNEL, \"cfam%d\", slave->cdev_idx);\n#endif\n}\n\nstatic const struct device_type cfam_type = {\n\t.name = \"cfam\",\n\t.devnode = cfam_devnode,\n\t.groups = cfam_attr_groups\n};\n\nstatic char *fsi_cdev_devnode(const struct device *dev, umode_t *mode,\n\t\t\t      kuid_t *uid, kgid_t *gid)\n{\n#ifdef CONFIG_FSI_NEW_DEV_NODE\n\treturn kasprintf(GFP_KERNEL, \"fsi/%s\", dev_name(dev));\n#else\n\treturn kasprintf(GFP_KERNEL, \"%s\", dev_name(dev));\n#endif\n}\n\nconst struct device_type fsi_cdev_type = {\n\t.name = \"fsi-cdev\",\n\t.devnode = fsi_cdev_devnode,\n};\nEXPORT_SYMBOL_GPL(fsi_cdev_type);\n\n \nstatic int fsi_adjust_index(int index)\n{\n#ifdef CONFIG_FSI_NEW_DEV_NODE\n\treturn index;\n#else\n\treturn index + 1;\n#endif\n}\n\nstatic int __fsi_get_new_minor(struct fsi_slave *slave, enum fsi_dev_type type,\n\t\t\t       dev_t *out_dev, int *out_index)\n{\n\tint cid = slave->chip_id;\n\tint id;\n\n\t \n\tif (cid >= 0 && cid < 16 && type < 4) {\n\t\t \n\t\tid = (cid << 2) | type;\n\t\tid = ida_alloc_range(&fsi_minor_ida, id, id, GFP_KERNEL);\n\t\tif (id >= 0) {\n\t\t\t*out_index = fsi_adjust_index(cid);\n\t\t\t*out_dev = fsi_base_dev + id;\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif (id != -ENOSPC)\n\t\t\treturn id;\n\t\t \n\t}\n\tid = ida_alloc_range(&fsi_minor_ida, FSI_CHAR_LEGACY_TOP,\n\t\t\t     FSI_CHAR_MAX_DEVICES - 1, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\t*out_index = fsi_adjust_index(id);\n\t*out_dev = fsi_base_dev + id;\n\treturn 0;\n}\n\nstatic const char *const fsi_dev_type_names[] = {\n\t\"cfam\",\n\t\"sbefifo\",\n\t\"scom\",\n\t\"occ\",\n};\n\nint fsi_get_new_minor(struct fsi_device *fdev, enum fsi_dev_type type,\n\t\t      dev_t *out_dev, int *out_index)\n{\n\tif (fdev->dev.of_node) {\n\t\tint aid = of_alias_get_id(fdev->dev.of_node, fsi_dev_type_names[type]);\n\n\t\tif (aid >= 0) {\n\t\t\t \n\t\t\tint id = (aid << 2) | type;\n\n\t\t\tid = ida_alloc_range(&fsi_minor_ida, id, id, GFP_KERNEL);\n\t\t\tif (id >= 0) {\n\t\t\t\t*out_index = aid;\n\t\t\t\t*out_dev = fsi_base_dev + id;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (id != -ENOSPC)\n\t\t\t\treturn id;\n\t\t}\n\t}\n\n\treturn __fsi_get_new_minor(fdev->slave, type, out_dev, out_index);\n}\nEXPORT_SYMBOL_GPL(fsi_get_new_minor);\n\nvoid fsi_free_minor(dev_t dev)\n{\n\tida_free(&fsi_minor_ida, MINOR(dev));\n}\nEXPORT_SYMBOL_GPL(fsi_free_minor);\n\nstatic int fsi_slave_init(struct fsi_master *master, int link, uint8_t id)\n{\n\tuint32_t cfam_id;\n\tstruct fsi_slave *slave;\n\tuint8_t crc;\n\t__be32 data, llmode, slbus;\n\tint rc;\n\n\t \n\tif (id != 0)\n\t\treturn -EINVAL;\n\n\trc = fsi_master_read(master, link, id, 0, &data, sizeof(data));\n\tif (rc) {\n\t\tdev_dbg(&master->dev, \"can't read slave %02x:%02x %d\\n\",\n\t\t\t\tlink, id, rc);\n\t\treturn -ENODEV;\n\t}\n\tcfam_id = be32_to_cpu(data);\n\n\tcrc = crc4(0, cfam_id, 32);\n\tif (crc) {\n\t\ttrace_fsi_slave_invalid_cfam(master, link, cfam_id);\n\t\tdev_warn(&master->dev, \"slave %02x:%02x invalid cfam id CRC!\\n\",\n\t\t\t\tlink, id);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&master->dev, \"fsi: found chip %08x at %02x:%02x:%02x\\n\",\n\t\t\tcfam_id, master->idx, link, id);\n\n\t \n\tif (master->flags & FSI_MASTER_FLAG_SWCLOCK) {\n\t\tllmode = cpu_to_be32(FSI_LLMODE_ASYNC);\n\t\trc = fsi_master_write(master, link, id,\n\t\t\t\tFSI_SLAVE_BASE + FSI_LLMODE,\n\t\t\t\t&llmode, sizeof(llmode));\n\t\tif (rc)\n\t\t\tdev_warn(&master->dev,\n\t\t\t\t\"can't set llmode on slave:%02x:%02x %d\\n\",\n\t\t\t\tlink, id, rc);\n\t}\n\n\t \n\tslave = kzalloc(sizeof(*slave), GFP_KERNEL);\n\tif (!slave)\n\t\treturn -ENOMEM;\n\n\tdev_set_name(&slave->dev, \"slave@%02x:%02x\", link, id);\n\tslave->dev.type = &cfam_type;\n\tslave->dev.parent = &master->dev;\n\tslave->dev.of_node = fsi_slave_find_of_node(master, link, id);\n\tslave->dev.release = fsi_slave_release;\n\tdevice_initialize(&slave->dev);\n\tslave->cfam_id = cfam_id;\n\tslave->master = master;\n\tslave->link = link;\n\tslave->id = id;\n\tslave->size = FSI_SLAVE_SIZE_23b;\n\tslave->t_send_delay = 16;\n\tslave->t_echo_delay = 16;\n\n\t \n\tslave->chip_id = -1;\n\tif (slave->dev.of_node) {\n\t\tuint32_t prop;\n\t\tif (!of_property_read_u32(slave->dev.of_node, \"chip-id\", &prop))\n\t\t\tslave->chip_id = prop;\n\n\t}\n\n\tslbus = cpu_to_be32(FSI_SLBUS_FORCE);\n\trc = fsi_master_write(master, link, id, FSI_SLAVE_BASE + FSI_SLBUS,\n\t\t\t      &slbus, sizeof(slbus));\n\tif (rc)\n\t\tdev_warn(&master->dev,\n\t\t\t \"can't set slbus on slave:%02x:%02x %d\\n\", link, id,\n\t\t\t rc);\n\n\trc = fsi_slave_set_smode(slave);\n\tif (rc) {\n\t\tdev_warn(&master->dev,\n\t\t\t\t\"can't set smode on slave:%02x:%02x %d\\n\",\n\t\t\t\tlink, id, rc);\n\t\tgoto err_free;\n\t}\n\n\t \n\trc = __fsi_get_new_minor(slave, fsi_dev_cfam, &slave->dev.devt,\n\t\t\t\t &slave->cdev_idx);\n\tif (rc)\n\t\tgoto err_free;\n\n\ttrace_fsi_slave_init(slave);\n\n\t \n\tcdev_init(&slave->cdev, &cfam_fops);\n\trc = cdev_device_add(&slave->cdev, &slave->dev);\n\tif (rc) {\n\t\tdev_err(&slave->dev, \"Error %d creating slave device\\n\", rc);\n\t\tgoto err_free_ida;\n\t}\n\n\t \n\n\tif (master->link_config)\n\t\tmaster->link_config(master, link,\n\t\t\t\t    slave->t_send_delay,\n\t\t\t\t    slave->t_echo_delay);\n\n\t \n\trc = device_create_bin_file(&slave->dev, &fsi_slave_raw_attr);\n\tif (rc)\n\t\tdev_warn(&slave->dev, \"failed to create raw attr: %d\\n\", rc);\n\n\n\trc = fsi_slave_scan(slave);\n\tif (rc)\n\t\tdev_dbg(&master->dev, \"failed during slave scan with: %d\\n\",\n\t\t\t\trc);\n\n\treturn 0;\n\nerr_free_ida:\n\tfsi_free_minor(slave->dev.devt);\nerr_free:\n\tof_node_put(slave->dev.of_node);\n\tkfree(slave);\n\treturn rc;\n}\n\n \nstatic int fsi_check_access(uint32_t addr, size_t size)\n{\n\tif (size == 4) {\n\t\tif (addr & 0x3)\n\t\t\treturn -EINVAL;\n\t} else if (size == 2) {\n\t\tif (addr & 0x1)\n\t\t\treturn -EINVAL;\n\t} else if (size != 1)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int fsi_master_read(struct fsi_master *master, int link,\n\t\tuint8_t slave_id, uint32_t addr, void *val, size_t size)\n{\n\tint rc;\n\n\ttrace_fsi_master_read(master, link, slave_id, addr, size);\n\n\trc = fsi_check_access(addr, size);\n\tif (!rc)\n\t\trc = master->read(master, link, slave_id, addr, val, size);\n\n\ttrace_fsi_master_rw_result(master, link, slave_id, addr, size,\n\t\t\tfalse, val, rc);\n\n\treturn rc;\n}\n\nstatic int fsi_master_write(struct fsi_master *master, int link,\n\t\tuint8_t slave_id, uint32_t addr, const void *val, size_t size)\n{\n\tint rc;\n\n\ttrace_fsi_master_write(master, link, slave_id, addr, size, val);\n\n\trc = fsi_check_access(addr, size);\n\tif (!rc)\n\t\trc = master->write(master, link, slave_id, addr, val, size);\n\n\ttrace_fsi_master_rw_result(master, link, slave_id, addr, size,\n\t\t\ttrue, val, rc);\n\n\treturn rc;\n}\n\nstatic int fsi_master_link_disable(struct fsi_master *master, int link)\n{\n\tif (master->link_enable)\n\t\treturn master->link_enable(master, link, false);\n\n\treturn 0;\n}\n\nstatic int fsi_master_link_enable(struct fsi_master *master, int link)\n{\n\tif (master->link_enable)\n\t\treturn master->link_enable(master, link, true);\n\n\treturn 0;\n}\n\n \nstatic int fsi_master_break(struct fsi_master *master, int link)\n{\n\tint rc = 0;\n\n\ttrace_fsi_master_break(master, link);\n\n\tif (master->send_break)\n\t\trc = master->send_break(master, link);\n\tif (master->link_config)\n\t\tmaster->link_config(master, link, 16, 16);\n\n\treturn rc;\n}\n\nstatic int fsi_master_scan(struct fsi_master *master)\n{\n\tint link, rc;\n\n\ttrace_fsi_master_scan(master, true);\n\tfor (link = 0; link < master->n_links; link++) {\n\t\trc = fsi_master_link_enable(master, link);\n\t\tif (rc) {\n\t\t\tdev_dbg(&master->dev,\n\t\t\t\t\"enable link %d failed: %d\\n\", link, rc);\n\t\t\tcontinue;\n\t\t}\n\t\trc = fsi_master_break(master, link);\n\t\tif (rc) {\n\t\t\tfsi_master_link_disable(master, link);\n\t\t\tdev_dbg(&master->dev,\n\t\t\t\t\"break to link %d failed: %d\\n\", link, rc);\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = fsi_slave_init(master, link, 0);\n\t\tif (rc)\n\t\t\tfsi_master_link_disable(master, link);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsi_slave_remove_device(struct device *dev, void *arg)\n{\n\tdevice_unregister(dev);\n\treturn 0;\n}\n\nstatic int fsi_master_remove_slave(struct device *dev, void *arg)\n{\n\tstruct fsi_slave *slave = to_fsi_slave(dev);\n\n\tdevice_for_each_child(dev, NULL, fsi_slave_remove_device);\n\tcdev_device_del(&slave->cdev, &slave->dev);\n\tput_device(dev);\n\treturn 0;\n}\n\nstatic void fsi_master_unscan(struct fsi_master *master)\n{\n\ttrace_fsi_master_scan(master, false);\n\tdevice_for_each_child(&master->dev, NULL, fsi_master_remove_slave);\n}\n\nint fsi_master_rescan(struct fsi_master *master)\n{\n\tint rc;\n\n\tmutex_lock(&master->scan_lock);\n\tfsi_master_unscan(master);\n\trc = fsi_master_scan(master);\n\tmutex_unlock(&master->scan_lock);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(fsi_master_rescan);\n\nstatic ssize_t master_rescan_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct fsi_master *master = to_fsi_master(dev);\n\tint rc;\n\n\trc = fsi_master_rescan(master);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(rescan, 0200, NULL, master_rescan_store);\n\nstatic ssize_t master_break_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct fsi_master *master = to_fsi_master(dev);\n\n\tfsi_master_break(master, 0);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(break, 0200, NULL, master_break_store);\n\nstatic struct attribute *master_attrs[] = {\n\t&dev_attr_break.attr,\n\t&dev_attr_rescan.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(master);\n\nstatic struct class fsi_master_class = {\n\t.name = \"fsi-master\",\n\t.dev_groups = master_groups,\n};\n\nint fsi_master_register(struct fsi_master *master)\n{\n\tint rc;\n\tstruct device_node *np;\n\n\tmutex_init(&master->scan_lock);\n\n\t \n\tif (master->idx) {\n\t\tmaster->idx = ida_alloc_range(&master_ida, master->idx,\n\t\t\t\t\t      master->idx, GFP_KERNEL);\n\t} else {\n\t\tmaster->idx = ida_alloc(&master_ida, GFP_KERNEL);\n\t}\n\n\tif (master->idx < 0)\n\t\treturn master->idx;\n\n\tif (!dev_name(&master->dev))\n\t\tdev_set_name(&master->dev, \"fsi%d\", master->idx);\n\n\tmaster->dev.class = &fsi_master_class;\n\n\tmutex_lock(&master->scan_lock);\n\trc = device_register(&master->dev);\n\tif (rc) {\n\t\tida_free(&master_ida, master->idx);\n\t\tgoto out;\n\t}\n\n\tnp = dev_of_node(&master->dev);\n\tif (!of_property_read_bool(np, \"no-scan-on-init\")) {\n\t\tfsi_master_scan(master);\n\t}\nout:\n\tmutex_unlock(&master->scan_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(fsi_master_register);\n\nvoid fsi_master_unregister(struct fsi_master *master)\n{\n\tint idx = master->idx;\n\n\ttrace_fsi_master_unregister(master);\n\n\tmutex_lock(&master->scan_lock);\n\tfsi_master_unscan(master);\n\tmaster->n_links = 0;\n\tmutex_unlock(&master->scan_lock);\n\n\tdevice_unregister(&master->dev);\n\tida_free(&master_ida, idx);\n}\nEXPORT_SYMBOL_GPL(fsi_master_unregister);\n\n \n\nstatic int fsi_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct fsi_device *fsi_dev = to_fsi_dev(dev);\n\tstruct fsi_driver *fsi_drv = to_fsi_drv(drv);\n\tconst struct fsi_device_id *id;\n\n\tif (!fsi_drv->id_table)\n\t\treturn 0;\n\n\tfor (id = fsi_drv->id_table; id->engine_type; id++) {\n\t\tif (id->engine_type != fsi_dev->engine_type)\n\t\t\tcontinue;\n\t\tif (id->version == FSI_VERSION_ANY ||\n\t\t    id->version == fsi_dev->version) {\n\t\t\tif (drv->of_match_table) {\n\t\t\t\tif (of_driver_match_device(dev, drv))\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint fsi_driver_register(struct fsi_driver *fsi_drv)\n{\n\tif (!fsi_drv)\n\t\treturn -EINVAL;\n\tif (!fsi_drv->id_table)\n\t\treturn -EINVAL;\n\n\treturn driver_register(&fsi_drv->drv);\n}\nEXPORT_SYMBOL_GPL(fsi_driver_register);\n\nvoid fsi_driver_unregister(struct fsi_driver *fsi_drv)\n{\n\tdriver_unregister(&fsi_drv->drv);\n}\nEXPORT_SYMBOL_GPL(fsi_driver_unregister);\n\nstruct bus_type fsi_bus_type = {\n\t.name\t\t= \"fsi\",\n\t.match\t\t= fsi_bus_match,\n};\nEXPORT_SYMBOL_GPL(fsi_bus_type);\n\nstatic int __init fsi_init(void)\n{\n\tint rc;\n\n\trc = alloc_chrdev_region(&fsi_base_dev, 0, FSI_CHAR_MAX_DEVICES, \"fsi\");\n\tif (rc)\n\t\treturn rc;\n\trc = bus_register(&fsi_bus_type);\n\tif (rc)\n\t\tgoto fail_bus;\n\n\trc = class_register(&fsi_master_class);\n\tif (rc)\n\t\tgoto fail_class;\n\n\treturn 0;\n\n fail_class:\n\tbus_unregister(&fsi_bus_type);\n fail_bus:\n\tunregister_chrdev_region(fsi_base_dev, FSI_CHAR_MAX_DEVICES);\n\treturn rc;\n}\npostcore_initcall(fsi_init);\n\nstatic void fsi_exit(void)\n{\n\tclass_unregister(&fsi_master_class);\n\tbus_unregister(&fsi_bus_type);\n\tunregister_chrdev_region(fsi_base_dev, FSI_CHAR_MAX_DEVICES);\n\tida_destroy(&fsi_minor_ida);\n}\nmodule_exit(fsi_exit);\nmodule_param(discard_errors, int, 0664);\nMODULE_LICENSE(\"GPL\");\nMODULE_PARM_DESC(discard_errors, \"Don't invoke error handling on bus accesses\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}