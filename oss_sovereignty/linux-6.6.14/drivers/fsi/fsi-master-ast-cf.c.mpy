{
  "module_name": "fsi-master-ast-cf.c",
  "hash_id": "a2f5c58f5f6990ec5182adb87f1f469b38001bdb618043ff48d1bdcbc4f1558f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fsi/fsi-master-ast-cf.c",
  "human_readable_source": "\n\n \n\n#include <linux/crc4.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/fsi.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/irqflags.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/firmware.h>\n#include <linux/gpio/aspeed.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of_address.h>\n#include <linux/genalloc.h>\n\n#include \"fsi-master.h\"\n#include \"cf-fsi-fw.h\"\n\n#define FW_FILE_NAME\t\"cf-fsi-fw.bin\"\n\n \n#define SCU_COPRO_CTRL\t\t\t0x100\n#define   SCU_COPRO_RESET\t\t\t0x00000002\n#define   SCU_COPRO_CLK_EN\t\t\t0x00000001\n\n \n#define SCU_2500_COPRO_SEG0\t\t0x104\n#define SCU_2500_COPRO_SEG1\t\t0x108\n#define SCU_2500_COPRO_SEG2\t\t0x10c\n#define SCU_2500_COPRO_SEG3\t\t0x110\n#define SCU_2500_COPRO_SEG4\t\t0x114\n#define SCU_2500_COPRO_SEG5\t\t0x118\n#define SCU_2500_COPRO_SEG6\t\t0x11c\n#define SCU_2500_COPRO_SEG7\t\t0x120\n#define SCU_2500_COPRO_SEG8\t\t0x124\n#define   SCU_2500_COPRO_SEG_SWAP\t\t0x00000001\n#define SCU_2500_COPRO_CACHE_CTL\t0x128\n#define   SCU_2500_COPRO_CACHE_EN\t\t0x00000001\n#define   SCU_2500_COPRO_SEG0_CACHE_EN\t\t0x00000002\n#define   SCU_2500_COPRO_SEG1_CACHE_EN\t\t0x00000004\n#define   SCU_2500_COPRO_SEG2_CACHE_EN\t\t0x00000008\n#define   SCU_2500_COPRO_SEG3_CACHE_EN\t\t0x00000010\n#define   SCU_2500_COPRO_SEG4_CACHE_EN\t\t0x00000020\n#define   SCU_2500_COPRO_SEG5_CACHE_EN\t\t0x00000040\n#define   SCU_2500_COPRO_SEG6_CACHE_EN\t\t0x00000080\n#define   SCU_2500_COPRO_SEG7_CACHE_EN\t\t0x00000100\n#define   SCU_2500_COPRO_SEG8_CACHE_EN\t\t0x00000200\n\n#define SCU_2400_COPRO_SEG0\t\t0x104\n#define SCU_2400_COPRO_SEG2\t\t0x108\n#define SCU_2400_COPRO_SEG4\t\t0x10c\n#define SCU_2400_COPRO_SEG6\t\t0x110\n#define SCU_2400_COPRO_SEG8\t\t0x114\n#define   SCU_2400_COPRO_SEG_SWAP\t\t0x80000000\n#define SCU_2400_COPRO_CACHE_CTL\t0x118\n#define   SCU_2400_COPRO_CACHE_EN\t\t0x00000001\n#define   SCU_2400_COPRO_SEG0_CACHE_EN\t\t0x00000002\n#define   SCU_2400_COPRO_SEG2_CACHE_EN\t\t0x00000004\n#define   SCU_2400_COPRO_SEG4_CACHE_EN\t\t0x00000008\n#define   SCU_2400_COPRO_SEG6_CACHE_EN\t\t0x00000010\n#define   SCU_2400_COPRO_SEG8_CACHE_EN\t\t0x00000020\n\n \n#define CVIC_EN_REG\t\t\t0x10\n#define CVIC_TRIG_REG\t\t\t0x18\n\n \n#define SYSREG_BASE\t\t\t0x1e600000\n\n \n#define SRAM_SIZE\t\t\t0x1000\n\n#define LAST_ADDR_INVALID\t\t0x1\n\nstruct fsi_master_acf {\n\tstruct fsi_master\tmaster;\n\tstruct device\t\t*dev;\n\tstruct regmap\t\t*scu;\n\tstruct mutex\t\tlock;\t \n\tstruct gpio_desc\t*gpio_clk;\n\tstruct gpio_desc\t*gpio_data;\n\tstruct gpio_desc\t*gpio_trans;\t \n\tstruct gpio_desc\t*gpio_enable;\t \n\tstruct gpio_desc\t*gpio_mux;\t \n\tuint16_t\t\tgpio_clk_vreg;\n\tuint16_t\t\tgpio_clk_dreg;\n\tuint16_t       \t\tgpio_dat_vreg;\n\tuint16_t       \t\tgpio_dat_dreg;\n\tuint16_t       \t\tgpio_tra_vreg;\n\tuint16_t       \t\tgpio_tra_dreg;\n\tuint8_t\t\t\tgpio_clk_bit;\n\tuint8_t\t\t\tgpio_dat_bit;\n\tuint8_t\t\t\tgpio_tra_bit;\n\tuint32_t\t\tcf_mem_addr;\n\tsize_t\t\t\tcf_mem_size;\n\tvoid __iomem\t\t*cf_mem;\n\tvoid __iomem\t\t*cvic;\n\tstruct gen_pool\t\t*sram_pool;\n\tvoid __iomem\t\t*sram;\n\tbool\t\t\tis_ast2500;\n\tbool\t\t\texternal_mode;\n\tbool\t\t\ttrace_enabled;\n\tuint32_t\t\tlast_addr;\n\tuint8_t\t\t\tt_send_delay;\n\tuint8_t\t\t\tt_echo_delay;\n\tuint32_t\t\tcvic_sw_irq;\n};\n#define to_fsi_master_acf(m) container_of(m, struct fsi_master_acf, master)\n\nstruct fsi_msg {\n\tuint64_t\tmsg;\n\tuint8_t\t\tbits;\n};\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/fsi_master_ast_cf.h>\n\nstatic void msg_push_bits(struct fsi_msg *msg, uint64_t data, int bits)\n{\n\tmsg->msg <<= bits;\n\tmsg->msg |= data & ((1ull << bits) - 1);\n\tmsg->bits += bits;\n}\n\nstatic void msg_push_crc(struct fsi_msg *msg)\n{\n\tuint8_t crc;\n\tint top;\n\n\ttop = msg->bits & 0x3;\n\n\t \n\tcrc = crc4(0, 1 << top | msg->msg >> (msg->bits - top), top + 1);\n\n\t \n\tcrc = crc4(crc, msg->msg, msg->bits - top);\n\n\tmsg_push_bits(msg, crc, 4);\n}\n\nstatic void msg_finish_cmd(struct fsi_msg *cmd)\n{\n\t \n\tcmd->msg <<= (64 - cmd->bits);\n}\n\nstatic bool check_same_address(struct fsi_master_acf *master, int id,\n\t\t\t       uint32_t addr)\n{\n\t \n\treturn master->last_addr == (((id & 0x3) << 21) | (addr & ~0x3));\n}\n\nstatic bool check_relative_address(struct fsi_master_acf *master, int id,\n\t\t\t\t   uint32_t addr, uint32_t *rel_addrp)\n{\n\tuint32_t last_addr = master->last_addr;\n\tint32_t rel_addr;\n\n\tif (last_addr == LAST_ADDR_INVALID)\n\t\treturn false;\n\n\t \n\tif (((last_addr >> 21) & 0x3) != id)\n\t\treturn false;\n\n\t \n\tlast_addr &= (1 << 21) - 1;\n\n\t \n\trel_addr = addr - last_addr;\n\tif (rel_addr > 255 || rel_addr < -256)\n\t\treturn false;\n\n\t*rel_addrp = (uint32_t)rel_addr;\n\n\treturn true;\n}\n\nstatic void last_address_update(struct fsi_master_acf *master,\n\t\t\t\tint id, bool valid, uint32_t addr)\n{\n\tif (!valid)\n\t\tmaster->last_addr = LAST_ADDR_INVALID;\n\telse\n\t\tmaster->last_addr = ((id & 0x3) << 21) | (addr & ~0x3);\n}\n\n \nstatic void build_ar_command(struct fsi_master_acf *master,\n\t\t\t     struct fsi_msg *cmd, uint8_t id,\n\t\t\t     uint32_t addr, size_t size,\n\t\t\t     const void *data)\n{\n\tint i, addr_bits, opcode_bits;\n\tbool write = !!data;\n\tuint8_t ds, opcode;\n\tuint32_t rel_addr;\n\n\tcmd->bits = 0;\n\tcmd->msg = 0;\n\n\t \n\taddr &= ((1 << 21) - 1);\n\n\t \n\topcode_bits = 3;\n\n\tif (check_same_address(master, id, addr)) {\n\t\t \n\t\taddr_bits = 2;\n\t\topcode_bits = 2;\n\t\topcode = FSI_CMD_SAME_AR;\n\t\ttrace_fsi_master_acf_cmd_same_addr(master);\n\n\t} else if (check_relative_address(master, id, addr, &rel_addr)) {\n\t\t \n\t\taddr_bits = 9;\n\t\taddr = rel_addr;\n\t\topcode = FSI_CMD_REL_AR;\n\t\ttrace_fsi_master_acf_cmd_rel_addr(master, rel_addr);\n\n\t} else {\n\t\taddr_bits = 21;\n\t\topcode = FSI_CMD_ABS_AR;\n\t\ttrace_fsi_master_acf_cmd_abs_addr(master, addr);\n\t}\n\n\t \n\tds = size > 1 ? 1 : 0;\n\taddr &= ~(size - 1);\n\tif (size == 4)\n\t\taddr |= 1;\n\n\tmsg_push_bits(cmd, id, 2);\n\tmsg_push_bits(cmd, opcode, opcode_bits);\n\tmsg_push_bits(cmd, write ? 0 : 1, 1);\n\tmsg_push_bits(cmd, addr, addr_bits);\n\tmsg_push_bits(cmd, ds, 1);\n\tfor (i = 0; write && i < size; i++)\n\t\tmsg_push_bits(cmd, ((uint8_t *)data)[i], 8);\n\n\tmsg_push_crc(cmd);\n\tmsg_finish_cmd(cmd);\n}\n\nstatic void build_dpoll_command(struct fsi_msg *cmd, uint8_t slave_id)\n{\n\tcmd->bits = 0;\n\tcmd->msg = 0;\n\n\tmsg_push_bits(cmd, slave_id, 2);\n\tmsg_push_bits(cmd, FSI_CMD_DPOLL, 3);\n\tmsg_push_crc(cmd);\n\tmsg_finish_cmd(cmd);\n}\n\nstatic void build_epoll_command(struct fsi_msg *cmd, uint8_t slave_id)\n{\n\tcmd->bits = 0;\n\tcmd->msg = 0;\n\n\tmsg_push_bits(cmd, slave_id, 2);\n\tmsg_push_bits(cmd, FSI_CMD_EPOLL, 3);\n\tmsg_push_crc(cmd);\n\tmsg_finish_cmd(cmd);\n}\n\nstatic void build_term_command(struct fsi_msg *cmd, uint8_t slave_id)\n{\n\tcmd->bits = 0;\n\tcmd->msg = 0;\n\n\tmsg_push_bits(cmd, slave_id, 2);\n\tmsg_push_bits(cmd, FSI_CMD_TERM, 6);\n\tmsg_push_crc(cmd);\n\tmsg_finish_cmd(cmd);\n}\n\nstatic int do_copro_command(struct fsi_master_acf *master, uint32_t op)\n{\n\tuint32_t timeout = 10000000;\n\tuint8_t stat;\n\n\ttrace_fsi_master_acf_copro_command(master, op);\n\n\t \n\tiowrite32be(op, master->sram + CMD_STAT_REG);\n\n\t \n\tif (master->cvic)\n\t\tiowrite32(0x2, master->cvic + CVIC_TRIG_REG);\n\n\t \n\tdo {\n\t\tif (timeout-- == 0) {\n\t\t\tdev_warn(master->dev,\n\t\t\t\t \"Timeout waiting for coprocessor completion\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tstat = ioread8(master->sram + CMD_STAT_REG);\n\t} while(stat < STAT_COMPLETE || stat == 0xff);\n\n\tif (stat == STAT_COMPLETE)\n\t\treturn 0;\n\tswitch(stat) {\n\tcase STAT_ERR_INVAL_CMD:\n\t\treturn -EINVAL;\n\tcase STAT_ERR_INVAL_IRQ:\n\t\treturn -EIO;\n\tcase STAT_ERR_MTOE:\n\t\treturn -ESHUTDOWN;\n\t}\n\treturn -ENXIO;\n}\n\nstatic int clock_zeros(struct fsi_master_acf *master, int count)\n{\n\twhile (count) {\n\t\tint rc, lcnt = min(count, 255);\n\n\t\trc = do_copro_command(master,\n\t\t\t\t      CMD_IDLE_CLOCKS | (lcnt << CMD_REG_CLEN_SHIFT));\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcount -= lcnt;\n\t}\n\treturn 0;\n}\n\nstatic int send_request(struct fsi_master_acf *master, struct fsi_msg *cmd,\n\t\t\tunsigned int resp_bits)\n{\n\tuint32_t op;\n\n\ttrace_fsi_master_acf_send_request(master, cmd, resp_bits);\n\n\t \n\tiowrite32be((cmd->msg >> 32), master->sram + CMD_DATA);\n\tiowrite32be((cmd->msg & 0xffffffff), master->sram + CMD_DATA + 4);\n\n\top = CMD_COMMAND;\n\top |= cmd->bits << CMD_REG_CLEN_SHIFT;\n\tif (resp_bits)\n\t\top |= resp_bits << CMD_REG_RLEN_SHIFT;\n\n\treturn do_copro_command(master, op);\n}\n\nstatic int read_copro_response(struct fsi_master_acf *master, uint8_t size,\n\t\t\t       uint32_t *response, u8 *tag)\n{\n\tuint8_t rtag = ioread8(master->sram + STAT_RTAG) & 0xf;\n\tuint8_t rcrc = ioread8(master->sram + STAT_RCRC) & 0xf;\n\tuint32_t rdata = 0;\n\tuint32_t crc;\n\tuint8_t ack;\n\n\t*tag = ack = rtag & 3;\n\n\t \n\tcrc = crc4(0, 1, 1);\n\tcrc = crc4(crc, rtag, 4);\n\tif (ack == FSI_RESP_ACK && size) {\n\t\trdata = ioread32be(master->sram + RSP_DATA);\n\t\tcrc = crc4(crc, rdata, size);\n\t\tif (response)\n\t\t\t*response = rdata;\n\t}\n\tcrc = crc4(crc, rcrc, 4);\n\n\ttrace_fsi_master_acf_copro_response(master, rtag, rcrc, rdata, crc == 0);\n\n\tif (crc) {\n\t\t \n\t\tif ((rtag == 0xf && rcrc == 0xf) || (rtag == 0 && rcrc == 0))\n\t\t\treturn -ENODEV;\n\t\tdev_dbg(master->dev, \"Bad response CRC !\\n\");\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic int send_term(struct fsi_master_acf *master, uint8_t slave)\n{\n\tstruct fsi_msg cmd;\n\tuint8_t tag;\n\tint rc;\n\n\tbuild_term_command(&cmd, slave);\n\n\trc = send_request(master, &cmd, 0);\n\tif (rc) {\n\t\tdev_warn(master->dev, \"Error %d sending term\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = read_copro_response(master, 0, NULL, &tag);\n\tif (rc < 0) {\n\t\tdev_err(master->dev,\n\t\t\t\t\"TERM failed; lost communication with slave\\n\");\n\t\treturn -EIO;\n\t} else if (tag != FSI_RESP_ACK) {\n\t\tdev_err(master->dev, \"TERM failed; response %d\\n\", tag);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void dump_ucode_trace(struct fsi_master_acf *master)\n{\n\tchar trbuf[52];\n\tchar *p;\n\tint i;\n\n\tdev_dbg(master->dev,\n\t\t\"CMDSTAT:%08x RTAG=%02x RCRC=%02x RDATA=%02x #INT=%08x\\n\",\n\t\tioread32be(master->sram + CMD_STAT_REG),\n\t\tioread8(master->sram + STAT_RTAG),\n\t\tioread8(master->sram + STAT_RCRC),\n\t\tioread32be(master->sram + RSP_DATA),\n\t\tioread32be(master->sram + INT_CNT));\n\n\tfor (i = 0; i < 512; i++) {\n\t\tuint8_t v;\n\t\tif ((i % 16) == 0)\n\t\t\tp = trbuf;\n\t\tv = ioread8(master->sram + TRACEBUF + i);\n\t\tp += sprintf(p, \"%02x \", v);\n\t\tif (((i % 16) == 15) || v == TR_END)\n\t\t\tdev_dbg(master->dev, \"%s\\n\", trbuf);\n\t\tif (v == TR_END)\n\t\t\tbreak;\n\t}\n}\n\nstatic int handle_response(struct fsi_master_acf *master,\n\t\t\t   uint8_t slave, uint8_t size, void *data)\n{\n\tint busy_count = 0, rc;\n\tint crc_err_retries = 0;\n\tstruct fsi_msg cmd;\n\tuint32_t response;\n\tuint8_t tag;\nretry:\n\trc = read_copro_response(master, size, &response, &tag);\n\n\t \n\tif (rc == -EAGAIN) {\n\t\t \n\t\tif (crc_err_retries++ > FSI_CRC_ERR_RETRIES) {\n\t\t\t \n\t\t\trc = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t\ttrace_fsi_master_acf_crc_rsp_error(master, crc_err_retries);\n\t\tif (master->trace_enabled)\n\t\t\tdump_ucode_trace(master);\n\t\trc = clock_zeros(master, FSI_MASTER_EPOLL_CLOCKS);\n\t\tif (rc) {\n\t\t\tdev_warn(master->dev,\n\t\t\t\t \"Error %d clocking zeros for E_POLL\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\tbuild_epoll_command(&cmd, slave);\n\t\trc = send_request(master, &cmd, size);\n\t\tif (rc) {\n\t\t\tdev_warn(master->dev, \"Error %d sending E_POLL\\n\", rc);\n\t\t\treturn -EIO;\n\t\t}\n\t\tgoto retry;\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (tag) {\n\tcase FSI_RESP_ACK:\n\t\tif (size && data) {\n\t\t\tif (size == 32)\n\t\t\t\t*(__be32 *)data = cpu_to_be32(response);\n\t\t\telse if (size == 16)\n\t\t\t\t*(__be16 *)data = cpu_to_be16(response);\n\t\t\telse\n\t\t\t\t*(u8 *)data = response;\n\t\t}\n\t\tbreak;\n\tcase FSI_RESP_BUSY:\n\t\t \n\t\tdev_dbg(master->dev, \"Busy, retrying...\\n\");\n\t\tif (master->trace_enabled)\n\t\t\tdump_ucode_trace(master);\n\t\trc = clock_zeros(master, FSI_MASTER_DPOLL_CLOCKS);\n\t\tif (rc) {\n\t\t\tdev_warn(master->dev,\n\t\t\t\t \"Error %d clocking zeros for D_POLL\\n\", rc);\n\t\t\tbreak;\n\t\t}\n\t\tif (busy_count++ < FSI_MASTER_MAX_BUSY) {\n\t\t\tbuild_dpoll_command(&cmd, slave);\n\t\t\trc = send_request(master, &cmd, size);\n\t\t\tif (rc) {\n\t\t\t\tdev_warn(master->dev, \"Error %d sending D_POLL\\n\", rc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto retry;\n\t\t}\n\t\tdev_dbg(master->dev,\n\t\t\t\"ERR slave is stuck in busy state, issuing TERM\\n\");\n\t\tsend_term(master, slave);\n\t\trc = -EIO;\n\t\tbreak;\n\n\tcase FSI_RESP_ERRA:\n\t\tdev_dbg(master->dev, \"ERRA received\\n\");\n\t\tif (master->trace_enabled)\n\t\t\tdump_ucode_trace(master);\n\t\trc = -EIO;\n\t\tbreak;\n\tcase FSI_RESP_ERRC:\n\t\tdev_dbg(master->dev, \"ERRC received\\n\");\n\t\tif (master->trace_enabled)\n\t\t\tdump_ucode_trace(master);\n\t\trc = -EAGAIN;\n\t\tbreak;\n\t}\n bail:\n\tif (busy_count > 0) {\n\t\ttrace_fsi_master_acf_poll_response_busy(master, busy_count);\n\t}\n\n\treturn rc;\n}\n\nstatic int fsi_master_acf_xfer(struct fsi_master_acf *master, uint8_t slave,\n\t\t\t       struct fsi_msg *cmd, size_t resp_len, void *resp)\n{\n\tint rc = -EAGAIN, retries = 0;\n\n\tresp_len <<= 3;\n\twhile ((retries++) < FSI_CRC_ERR_RETRIES) {\n\t\trc = send_request(master, cmd, resp_len);\n\t\tif (rc) {\n\t\t\tif (rc != -ESHUTDOWN)\n\t\t\t\tdev_warn(master->dev, \"Error %d sending command\\n\", rc);\n\t\t\tbreak;\n\t\t}\n\t\trc = handle_response(master, slave, resp_len, resp);\n\t\tif (rc != -EAGAIN)\n\t\t\tbreak;\n\t\trc = -EIO;\n\t\tdev_dbg(master->dev, \"ECRC retry %d\\n\", retries);\n\n\t\t \n\t\tmsleep(1);\n\t}\n\n\treturn rc;\n}\n\nstatic int fsi_master_acf_read(struct fsi_master *_master, int link,\n\t\t\t       uint8_t id, uint32_t addr, void *val,\n\t\t\t       size_t size)\n{\n\tstruct fsi_master_acf *master = to_fsi_master_acf(_master);\n\tstruct fsi_msg cmd;\n\tint rc;\n\n\tif (link != 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&master->lock);\n\tdev_dbg(master->dev, \"read id %d addr %x size %zd\\n\", id, addr, size);\n\tbuild_ar_command(master, &cmd, id, addr, size, NULL);\n\trc = fsi_master_acf_xfer(master, id, &cmd, size, val);\n\tlast_address_update(master, id, rc == 0, addr);\n\tif (rc)\n\t\tdev_dbg(master->dev, \"read id %d addr 0x%08x err: %d\\n\",\n\t\t\tid, addr, rc);\n\tmutex_unlock(&master->lock);\n\n\treturn rc;\n}\n\nstatic int fsi_master_acf_write(struct fsi_master *_master, int link,\n\t\t\t\tuint8_t id, uint32_t addr, const void *val,\n\t\t\t\tsize_t size)\n{\n\tstruct fsi_master_acf *master = to_fsi_master_acf(_master);\n\tstruct fsi_msg cmd;\n\tint rc;\n\n\tif (link != 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&master->lock);\n\tbuild_ar_command(master, &cmd, id, addr, size, val);\n\tdev_dbg(master->dev, \"write id %d addr %x size %zd raw_data: %08x\\n\",\n\t\tid, addr, size, *(uint32_t *)val);\n\trc = fsi_master_acf_xfer(master, id, &cmd, 0, NULL);\n\tlast_address_update(master, id, rc == 0, addr);\n\tif (rc)\n\t\tdev_dbg(master->dev, \"write id %d addr 0x%08x err: %d\\n\",\n\t\t\tid, addr, rc);\n\tmutex_unlock(&master->lock);\n\n\treturn rc;\n}\n\nstatic int fsi_master_acf_term(struct fsi_master *_master,\n\t\t\t       int link, uint8_t id)\n{\n\tstruct fsi_master_acf *master = to_fsi_master_acf(_master);\n\tstruct fsi_msg cmd;\n\tint rc;\n\n\tif (link != 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&master->lock);\n\tbuild_term_command(&cmd, id);\n\tdev_dbg(master->dev, \"term id %d\\n\", id);\n\trc = fsi_master_acf_xfer(master, id, &cmd, 0, NULL);\n\tlast_address_update(master, id, false, 0);\n\tmutex_unlock(&master->lock);\n\n\treturn rc;\n}\n\nstatic int fsi_master_acf_break(struct fsi_master *_master, int link)\n{\n\tstruct fsi_master_acf *master = to_fsi_master_acf(_master);\n\tint rc;\n\n\tif (link != 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&master->lock);\n\tif (master->external_mode) {\n\t\tmutex_unlock(&master->lock);\n\t\treturn -EBUSY;\n\t}\n\tdev_dbg(master->dev, \"sending BREAK\\n\");\n\trc = do_copro_command(master, CMD_BREAK);\n\tlast_address_update(master, 0, false, 0);\n\tmutex_unlock(&master->lock);\n\n\t \n\tudelay(200);\n\n\treturn rc;\n}\n\nstatic void reset_cf(struct fsi_master_acf *master)\n{\n\tregmap_write(master->scu, SCU_COPRO_CTRL, SCU_COPRO_RESET);\n\tusleep_range(20,20);\n\tregmap_write(master->scu, SCU_COPRO_CTRL, 0);\n\tusleep_range(20,20);\n}\n\nstatic void start_cf(struct fsi_master_acf *master)\n{\n\tregmap_write(master->scu, SCU_COPRO_CTRL, SCU_COPRO_CLK_EN);\n}\n\nstatic void setup_ast2500_cf_maps(struct fsi_master_acf *master)\n{\n\t \n\n\t \n\tregmap_write(master->scu, SCU_2500_COPRO_SEG0, master->cf_mem_addr |\n\t\t     SCU_2500_COPRO_SEG_SWAP);\n\n\t \n\tregmap_write(master->scu, SCU_2500_COPRO_SEG2, SYSREG_BASE |\n\t\t     SCU_2500_COPRO_SEG_SWAP);\n\tregmap_write(master->scu, SCU_2500_COPRO_SEG3, SYSREG_BASE | 0x100000 |\n\t\t     SCU_2500_COPRO_SEG_SWAP);\n\n\t \n\tregmap_write(master->scu, SCU_2500_COPRO_SEG6, SYSREG_BASE);\n\tregmap_write(master->scu, SCU_2500_COPRO_SEG7, SYSREG_BASE | 0x100000);\n\n\t \n\tregmap_write(master->scu, SCU_2500_COPRO_CACHE_CTL,\n\t\t     SCU_2500_COPRO_SEG0_CACHE_EN | SCU_2500_COPRO_CACHE_EN);\n}\n\nstatic void setup_ast2400_cf_maps(struct fsi_master_acf *master)\n{\n\t \n\tregmap_write(master->scu, SCU_2400_COPRO_SEG0, master->cf_mem_addr |\n\t\t     SCU_2400_COPRO_SEG_SWAP);\n\n\t \n\tregmap_write(master->scu, SCU_2400_COPRO_SEG2, SYSREG_BASE |\n\t\t     SCU_2400_COPRO_SEG_SWAP);\n\n\t \n\tregmap_write(master->scu, SCU_2400_COPRO_SEG6, SYSREG_BASE);\n\n\t \n\tregmap_write(master->scu, SCU_2400_COPRO_CACHE_CTL,\n\t\t     SCU_2400_COPRO_SEG0_CACHE_EN | SCU_2400_COPRO_CACHE_EN);\n}\n\nstatic void setup_common_fw_config(struct fsi_master_acf *master,\n\t\t\t\t   void __iomem *base)\n{\n\tiowrite16be(master->gpio_clk_vreg, base + HDR_CLOCK_GPIO_VADDR);\n\tiowrite16be(master->gpio_clk_dreg, base + HDR_CLOCK_GPIO_DADDR);\n\tiowrite16be(master->gpio_dat_vreg, base + HDR_DATA_GPIO_VADDR);\n\tiowrite16be(master->gpio_dat_dreg, base + HDR_DATA_GPIO_DADDR);\n\tiowrite16be(master->gpio_tra_vreg, base + HDR_TRANS_GPIO_VADDR);\n\tiowrite16be(master->gpio_tra_dreg, base + HDR_TRANS_GPIO_DADDR);\n\tiowrite8(master->gpio_clk_bit, base + HDR_CLOCK_GPIO_BIT);\n\tiowrite8(master->gpio_dat_bit, base + HDR_DATA_GPIO_BIT);\n\tiowrite8(master->gpio_tra_bit, base + HDR_TRANS_GPIO_BIT);\n}\n\nstatic void setup_ast2500_fw_config(struct fsi_master_acf *master)\n{\n\tvoid __iomem *base = master->cf_mem + HDR_OFFSET;\n\n\tsetup_common_fw_config(master, base);\n\tiowrite32be(FW_CONTROL_USE_STOP, base + HDR_FW_CONTROL);\n}\n\nstatic void setup_ast2400_fw_config(struct fsi_master_acf *master)\n{\n\tvoid __iomem *base = master->cf_mem + HDR_OFFSET;\n\n\tsetup_common_fw_config(master, base);\n\tiowrite32be(FW_CONTROL_CONT_CLOCK|FW_CONTROL_DUMMY_RD, base + HDR_FW_CONTROL);\n}\n\nstatic int setup_gpios_for_copro(struct fsi_master_acf *master)\n{\n\n\tint rc;\n\n\t \n\tgpiod_direction_output(master->gpio_mux, 1);\n\tgpiod_direction_output(master->gpio_enable, 1);\n\n\t \n\trc = aspeed_gpio_copro_grab_gpio(master->gpio_clk, &master->gpio_clk_vreg,\n\t\t\t\t\t &master->gpio_clk_dreg, &master->gpio_clk_bit);\n\tif (rc) {\n\t\tdev_err(master->dev, \"failed to assign clock gpio to coprocessor\\n\");\n\t\treturn rc;\n\t}\n\trc = aspeed_gpio_copro_grab_gpio(master->gpio_data, &master->gpio_dat_vreg,\n\t\t\t\t\t &master->gpio_dat_dreg, &master->gpio_dat_bit);\n\tif (rc) {\n\t\tdev_err(master->dev, \"failed to assign data gpio to coprocessor\\n\");\n\t\taspeed_gpio_copro_release_gpio(master->gpio_clk);\n\t\treturn rc;\n\t}\n\trc = aspeed_gpio_copro_grab_gpio(master->gpio_trans, &master->gpio_tra_vreg,\n\t\t\t\t\t &master->gpio_tra_dreg, &master->gpio_tra_bit);\n\tif (rc) {\n\t\tdev_err(master->dev, \"failed to assign trans gpio to coprocessor\\n\");\n\t\taspeed_gpio_copro_release_gpio(master->gpio_clk);\n\t\taspeed_gpio_copro_release_gpio(master->gpio_data);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic void release_copro_gpios(struct fsi_master_acf *master)\n{\n\taspeed_gpio_copro_release_gpio(master->gpio_clk);\n\taspeed_gpio_copro_release_gpio(master->gpio_data);\n\taspeed_gpio_copro_release_gpio(master->gpio_trans);\n}\n\nstatic int load_copro_firmware(struct fsi_master_acf *master)\n{\n\tconst struct firmware *fw;\n\tuint16_t sig = 0, wanted_sig;\n\tconst u8 *data;\n\tsize_t size = 0;\n\tint rc;\n\n\t \n\trc = request_firmware(&fw, FW_FILE_NAME, master->dev);\n\tif (rc) {\n\t\tdev_err(\n\t\t\tmaster->dev, \"Error %d to load firmware '%s' !\\n\",\n\t\t\trc, FW_FILE_NAME);\n\t\treturn rc;\n\t}\n\n\t \n\tif (master->gpio_clk_vreg == master->gpio_dat_vreg)\n\t\twanted_sig = SYS_SIG_SHARED;\n\telse\n\t\twanted_sig = SYS_SIG_SPLIT;\n\tdev_dbg(master->dev, \"Looking for image sig %04x\\n\", wanted_sig);\n\n\t \n\tfor (data = fw->data; data < (fw->data + fw->size);) {\n\t\tsig = be16_to_cpup((__be16 *)(data + HDR_OFFSET + HDR_SYS_SIG));\n\t\tsize = be32_to_cpup((__be32 *)(data + HDR_OFFSET + HDR_FW_SIZE));\n\t\tif (sig == wanted_sig)\n\t\t\tbreak;\n\t\tdata += size;\n\t}\n\tif (sig != wanted_sig) {\n\t\tdev_err(master->dev, \"Failed to locate image sig %04x in FW blob\\n\",\n\t\t\twanted_sig);\n\t\trc = -ENODEV;\n\t\tgoto release_fw;\n\t}\n\tif (size > master->cf_mem_size) {\n\t\tdev_err(master->dev, \"FW size (%zd) bigger than memory reserve (%zd)\\n\",\n\t\t\tfw->size, master->cf_mem_size);\n\t\trc = -ENOMEM;\n\t} else {\n\t\tmemcpy_toio(master->cf_mem, data, size);\n\t}\n\nrelease_fw:\n\trelease_firmware(fw);\n\treturn rc;\n}\n\nstatic int check_firmware_image(struct fsi_master_acf *master)\n{\n\tuint32_t fw_vers, fw_api, fw_options;\n\n\tfw_vers = ioread16be(master->cf_mem + HDR_OFFSET + HDR_FW_VERS);\n\tfw_api = ioread16be(master->cf_mem + HDR_OFFSET + HDR_API_VERS);\n\tfw_options = ioread32be(master->cf_mem + HDR_OFFSET + HDR_FW_OPTIONS);\n\tmaster->trace_enabled = !!(fw_options & FW_OPTION_TRACE_EN);\n\n\t \n\tdev_info(master->dev, \"ColdFire initialized, firmware v%d API v%d.%d (trace %s)\\n\",\n\t\t fw_vers, fw_api >> 8, fw_api & 0xff,\n\t\t master->trace_enabled ? \"enabled\" : \"disabled\");\n\n\tif ((fw_api >> 8) != API_VERSION_MAJ) {\n\t\tdev_err(master->dev, \"Unsupported coprocessor API version !\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int copro_enable_sw_irq(struct fsi_master_acf *master)\n{\n\tint timeout;\n\tuint32_t val;\n\n\t \n\tfor (timeout = 0; timeout < 10; timeout++) {\n\t\tiowrite32(0x2, master->cvic + CVIC_EN_REG);\n\t\tval = ioread32(master->cvic + CVIC_EN_REG);\n\t\tif (val & 2)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\tif (!(val & 2)) {\n\t\tdev_err(master->dev, \"Failed to enable coprocessor interrupt !\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int fsi_master_acf_setup(struct fsi_master_acf *master)\n{\n\tint timeout, rc;\n\tuint32_t val;\n\n\t \n\treset_cf(master);\n\n\t \n\tmemset_io(master->sram, 0, SRAM_SIZE);\n\n\t \n\trc = setup_gpios_for_copro(master);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = load_copro_firmware(master);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = check_firmware_image(master);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (master->is_ast2500) {\n\t\tsetup_ast2500_cf_maps(master);\n\t\tsetup_ast2500_fw_config(master);\n\t} else {\n\t\tsetup_ast2400_cf_maps(master);\n\t\tsetup_ast2400_fw_config(master);\n\t}\n\n\t \n\tstart_cf(master);\n\n\t \n\tfor (timeout = 0; timeout < 10; timeout++) {\n\t\tval = ioread8(master->sram + CF_STARTED);\n\t\tif (val)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\tif (!val) {\n\t\tdev_err(master->dev, \"Coprocessor startup timeout !\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tiowrite8(master->t_send_delay, master->sram + SEND_DLY_REG);\n\tiowrite8(master->t_echo_delay, master->sram + ECHO_DLY_REG);\n\n\t \n\tif (master->cvic) {\n\t\trc = copro_enable_sw_irq(master);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\treturn 0;\n err:\n\t \n\treset_cf(master);\n\n\t \n\trelease_copro_gpios(master);\n\n\treturn rc;\n}\n\n\nstatic void fsi_master_acf_terminate(struct fsi_master_acf *master)\n{\n\tunsigned long flags;\n\n\t \n\n\tlocal_irq_save(flags);\n\n\t \n\treset_cf(master);\n\n\t \n\tiowrite32(0, master->sram + CF_STARTED);\n\n\t \n\tiowrite8(ARB_ARM_ACK, master->sram + ARB_REG);\n\n\tlocal_irq_restore(flags);\n\n\t \n\trelease_copro_gpios(master);\n}\n\nstatic void fsi_master_acf_setup_external(struct fsi_master_acf *master)\n{\n\t \n\tgpiod_direction_output(master->gpio_mux, 0);\n\tgpiod_direction_output(master->gpio_trans, 0);\n\tgpiod_direction_output(master->gpio_enable, 1);\n\tgpiod_direction_input(master->gpio_clk);\n\tgpiod_direction_input(master->gpio_data);\n}\n\nstatic int fsi_master_acf_link_enable(struct fsi_master *_master, int link,\n\t\t\t\t      bool enable)\n{\n\tstruct fsi_master_acf *master = to_fsi_master_acf(_master);\n\tint rc = -EBUSY;\n\n\tif (link != 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&master->lock);\n\tif (!master->external_mode) {\n\t\tgpiod_set_value(master->gpio_enable, enable ? 1 : 0);\n\t\trc = 0;\n\t}\n\tmutex_unlock(&master->lock);\n\n\treturn rc;\n}\n\nstatic int fsi_master_acf_link_config(struct fsi_master *_master, int link,\n\t\t\t\t      u8 t_send_delay, u8 t_echo_delay)\n{\n\tstruct fsi_master_acf *master = to_fsi_master_acf(_master);\n\n\tif (link != 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&master->lock);\n\tmaster->t_send_delay = t_send_delay;\n\tmaster->t_echo_delay = t_echo_delay;\n\tdev_dbg(master->dev, \"Changing delays: send=%d echo=%d\\n\",\n\t\tt_send_delay, t_echo_delay);\n\tiowrite8(master->t_send_delay, master->sram + SEND_DLY_REG);\n\tiowrite8(master->t_echo_delay, master->sram + ECHO_DLY_REG);\n\tmutex_unlock(&master->lock);\n\n\treturn 0;\n}\n\nstatic ssize_t external_mode_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct fsi_master_acf *master = dev_get_drvdata(dev);\n\n\treturn snprintf(buf, PAGE_SIZE - 1, \"%u\\n\",\n\t\t\tmaster->external_mode ? 1 : 0);\n}\n\nstatic ssize_t external_mode_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct fsi_master_acf *master = dev_get_drvdata(dev);\n\tunsigned long val;\n\tbool external_mode;\n\tint err;\n\n\terr = kstrtoul(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\n\texternal_mode = !!val;\n\n\tmutex_lock(&master->lock);\n\n\tif (external_mode == master->external_mode) {\n\t\tmutex_unlock(&master->lock);\n\t\treturn count;\n\t}\n\n\tmaster->external_mode = external_mode;\n\tif (master->external_mode) {\n\t\tfsi_master_acf_terminate(master);\n\t\tfsi_master_acf_setup_external(master);\n\t} else\n\t\tfsi_master_acf_setup(master);\n\n\tmutex_unlock(&master->lock);\n\n\tfsi_master_rescan(&master->master);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(external_mode, 0664,\n\t\texternal_mode_show, external_mode_store);\n\nstatic int fsi_master_acf_gpio_request(void *data)\n{\n\tstruct fsi_master_acf *master = data;\n\tint timeout;\n\tu8 val;\n\n\t \n\n\t \n\tiowrite8(ARB_ARM_REQ, master->sram + ARB_REG);\n\n\t \n\tif (ioread32(master->sram + CF_STARTED) == 0) {\n\t\tunsigned int reg = 0;\n\n\t\tregmap_read(master->scu, SCU_COPRO_CTRL, &reg);\n\t\tif (!(reg & SCU_COPRO_CLK_EN))\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (master->cvic)\n\t\tiowrite32(0x2, master->cvic + CVIC_TRIG_REG);\n\n\tfor (timeout = 0; timeout < 10000; timeout++) {\n\t\tval = ioread8(master->sram + ARB_REG);\n\t\tif (val != ARB_ARM_REQ)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\t \n\tif (val != ARB_ARM_ACK)\n\t\tdev_warn(master->dev, \"GPIO request arbitration timeout\\n\");\n\n\treturn 0;\n}\n\nstatic int fsi_master_acf_gpio_release(void *data)\n{\n\tstruct fsi_master_acf *master = data;\n\n\t \n\tiowrite8(0, master->sram + ARB_REG);\n\n\t \n\tif (master->cvic)\n\t\tiowrite32(0x2, master->cvic + CVIC_TRIG_REG);\n\n\treturn 0;\n}\n\nstatic void fsi_master_acf_release(struct device *dev)\n{\n\tstruct fsi_master_acf *master = to_fsi_master_acf(to_fsi_master(dev));\n\n\t \n\tmutex_lock(&master->lock);\n\tfsi_master_acf_terminate(master);\n\taspeed_gpio_copro_set_ops(NULL, NULL);\n\tmutex_unlock(&master->lock);\n\n\t \n\tgen_pool_free(master->sram_pool, (unsigned long)master->sram, SRAM_SIZE);\n\tof_node_put(dev_of_node(master->dev));\n\n\tkfree(master);\n}\n\nstatic const struct aspeed_gpio_copro_ops fsi_master_acf_gpio_ops = {\n\t.request_access = fsi_master_acf_gpio_request,\n\t.release_access = fsi_master_acf_gpio_release,\n};\n\nstatic int fsi_master_acf_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np, *mnode = dev_of_node(&pdev->dev);\n\tstruct genpool_data_fixed gpdf;\n\tstruct fsi_master_acf *master;\n\tstruct gpio_desc *gpio;\n\tstruct resource res;\n\tuint32_t cf_mem_align;\n\tint rc;\n\n\tmaster = kzalloc(sizeof(*master), GFP_KERNEL);\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tmaster->dev = &pdev->dev;\n\tmaster->master.dev.parent = master->dev;\n\tmaster->last_addr = LAST_ADDR_INVALID;\n\n\t \n\tmaster->is_ast2500 = of_device_is_compatible(mnode, \"aspeed,ast2500-cf-fsi-master\");\n\n\t \n\tif (master->is_ast2500)\n\t\tmaster->scu = syscon_regmap_lookup_by_compatible(\"aspeed,ast2500-scu\");\n\telse\n\t\tmaster->scu = syscon_regmap_lookup_by_compatible(\"aspeed,ast2400-scu\");\n\tif (IS_ERR(master->scu)) {\n\t\tdev_err(&pdev->dev, \"failed to find SCU regmap\\n\");\n\t\trc = PTR_ERR(master->scu);\n\t\tgoto err_free;\n\t}\n\n\t \n\tgpio = devm_gpiod_get(&pdev->dev, \"clock\", 0);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock gpio\\n\");\n\t\trc = PTR_ERR(gpio);\n\t\tgoto err_free;\n\t}\n\tmaster->gpio_clk = gpio;\n\n\tgpio = devm_gpiod_get(&pdev->dev, \"data\", 0);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get data gpio\\n\");\n\t\trc = PTR_ERR(gpio);\n\t\tgoto err_free;\n\t}\n\tmaster->gpio_data = gpio;\n\n\t \n\tgpio = devm_gpiod_get_optional(&pdev->dev, \"trans\", 0);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get trans gpio\\n\");\n\t\trc = PTR_ERR(gpio);\n\t\tgoto err_free;\n\t}\n\tmaster->gpio_trans = gpio;\n\n\tgpio = devm_gpiod_get_optional(&pdev->dev, \"enable\", 0);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get enable gpio\\n\");\n\t\trc = PTR_ERR(gpio);\n\t\tgoto err_free;\n\t}\n\tmaster->gpio_enable = gpio;\n\n\tgpio = devm_gpiod_get_optional(&pdev->dev, \"mux\", 0);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(&pdev->dev, \"failed to get mux gpio\\n\");\n\t\trc = PTR_ERR(gpio);\n\t\tgoto err_free;\n\t}\n\tmaster->gpio_mux = gpio;\n\n\t \n\tnp = of_parse_phandle(mnode, \"memory-region\", 0);\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"Didn't find reserved memory\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_free;\n\t}\n\trc = of_address_to_resource(np, 0, &res);\n\tof_node_put(np);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Couldn't address to resource for reserved memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\tmaster->cf_mem_size = resource_size(&res);\n\tmaster->cf_mem_addr = (uint32_t)res.start;\n\tcf_mem_align = master->is_ast2500 ? 0x00100000 : 0x00200000;\n\tif (master->cf_mem_addr & (cf_mem_align - 1)) {\n\t\tdev_err(&pdev->dev, \"Reserved memory has insufficient alignment\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\tmaster->cf_mem = devm_ioremap_resource(&pdev->dev, &res);\n \tif (IS_ERR(master->cf_mem)) {\n\t\trc = PTR_ERR(master->cf_mem);\n \t\tgoto err_free;\n\t}\n\tdev_dbg(&pdev->dev, \"DRAM allocation @%x\\n\", master->cf_mem_addr);\n\n\t \n\tif (master->is_ast2500) {\n\t\t \n\t\tnp = of_parse_phandle(mnode, \"aspeed,cvic\", 0);\n\t\tif (!np) {\n\t\t\tdev_err(&pdev->dev, \"Didn't find CVIC\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\t\tmaster->cvic = devm_of_iomap(&pdev->dev, np, 0, NULL);\n\t\tif (IS_ERR(master->cvic)) {\n\t\t\tof_node_put(np);\n\t\t\trc = PTR_ERR(master->cvic);\n\t\t\tdev_err(&pdev->dev, \"Error %d mapping CVIC\\n\", rc);\n\t\t\tgoto err_free;\n\t\t}\n\t\trc = of_property_read_u32(np, \"copro-sw-interrupts\",\n\t\t\t\t\t  &master->cvic_sw_irq);\n\t\tof_node_put(np);\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev, \"Can't find coprocessor SW interrupt\\n\");\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\n\t \n\tmaster->sram_pool = of_gen_pool_get(dev_of_node(&pdev->dev), \"aspeed,sram\", 0);\n\tif (!master->sram_pool) {\n\t\trc = -ENODEV;\n\t\tdev_err(&pdev->dev, \"Can't find sram pool\\n\");\n\t\tgoto err_free;\n\t}\n\n\t \n\tgpdf.offset = 0;\n\tmaster->sram = (void __iomem *)gen_pool_alloc_algo(master->sram_pool, SRAM_SIZE,\n\t\t\t\t\t\t\t   gen_pool_fixed_alloc, &gpdf);\n\tif (!master->sram) {\n\t\trc = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"Failed to allocate sram from pool\\n\");\n\t\tgoto err_free;\n\t}\n\tdev_dbg(&pdev->dev, \"SRAM allocation @%lx\\n\",\n\t\t(unsigned long)gen_pool_virt_to_phys(master->sram_pool,\n\t\t\t\t\t\t     (unsigned long)master->sram));\n\n\t \n\taspeed_gpio_copro_set_ops(&fsi_master_acf_gpio_ops, master);\n\n\t \n\tmaster->t_send_delay = FSI_SEND_DELAY_CLOCKS;\n\tmaster->t_echo_delay = FSI_ECHO_DELAY_CLOCKS;\n\tmaster->master.n_links = 1;\n\tif (master->is_ast2500)\n\t\tmaster->master.flags = FSI_MASTER_FLAG_SWCLOCK;\n\tmaster->master.read = fsi_master_acf_read;\n\tmaster->master.write = fsi_master_acf_write;\n\tmaster->master.term = fsi_master_acf_term;\n\tmaster->master.send_break = fsi_master_acf_break;\n\tmaster->master.link_enable = fsi_master_acf_link_enable;\n\tmaster->master.link_config = fsi_master_acf_link_config;\n\tmaster->master.dev.of_node = of_node_get(dev_of_node(master->dev));\n\tmaster->master.dev.release = fsi_master_acf_release;\n\tplatform_set_drvdata(pdev, master);\n\tmutex_init(&master->lock);\n\n\tmutex_lock(&master->lock);\n\trc = fsi_master_acf_setup(master);\n\tmutex_unlock(&master->lock);\n\tif (rc)\n\t\tgoto release_of_dev;\n\n\trc = device_create_file(&pdev->dev, &dev_attr_external_mode);\n\tif (rc)\n\t\tgoto stop_copro;\n\n\trc = fsi_master_register(&master->master);\n\tif (!rc)\n\t\treturn 0;\n\n\tdevice_remove_file(master->dev, &dev_attr_external_mode);\n\tput_device(&master->master.dev);\n\treturn rc;\n\n stop_copro:\n\tfsi_master_acf_terminate(master);\n release_of_dev:\n\taspeed_gpio_copro_set_ops(NULL, NULL);\n\tgen_pool_free(master->sram_pool, (unsigned long)master->sram, SRAM_SIZE);\n\tof_node_put(dev_of_node(master->dev));\n err_free:\n\tkfree(master);\n\treturn rc;\n}\n\n\nstatic int fsi_master_acf_remove(struct platform_device *pdev)\n{\n\tstruct fsi_master_acf *master = platform_get_drvdata(pdev);\n\n\tdevice_remove_file(master->dev, &dev_attr_external_mode);\n\n\tfsi_master_unregister(&master->master);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id fsi_master_acf_match[] = {\n\t{ .compatible = \"aspeed,ast2400-cf-fsi-master\" },\n\t{ .compatible = \"aspeed,ast2500-cf-fsi-master\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, fsi_master_acf_match);\n\nstatic struct platform_driver fsi_master_acf = {\n\t.driver = {\n\t\t.name\t\t= \"fsi-master-acf\",\n\t\t.of_match_table\t= fsi_master_acf_match,\n\t},\n\t.probe\t= fsi_master_acf_probe,\n\t.remove = fsi_master_acf_remove,\n};\n\nmodule_platform_driver(fsi_master_acf);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FW_FILE_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}