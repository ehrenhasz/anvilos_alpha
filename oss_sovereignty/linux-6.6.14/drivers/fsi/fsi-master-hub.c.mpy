{
  "module_name": "fsi-master-hub.c",
  "hash_id": "51dcee907c833d9e55a64a84270c9a3ccf30968f55e0e58c8974cdc1d6da5cc1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fsi/fsi-master-hub.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/fsi.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n#include \"fsi-master.h\"\n\n#define FSI_ENGID_HUB_MASTER\t\t0x1c\n\n#define FSI_LINK_ENABLE_SETUP_TIME\t10\t \n\n \nstruct fsi_master_hub {\n\tstruct fsi_master\tmaster;\n\tstruct fsi_device\t*upstream;\n\tuint32_t\t\taddr, size;\t \n\t\t\t\t\t\t \n};\n\n#define to_fsi_master_hub(m) container_of(m, struct fsi_master_hub, master)\n\nstatic int hub_master_read(struct fsi_master *master, int link,\n\t\t\tuint8_t id, uint32_t addr, void *val, size_t size)\n{\n\tstruct fsi_master_hub *hub = to_fsi_master_hub(master);\n\n\tif (id != 0)\n\t\treturn -EINVAL;\n\n\taddr += hub->addr + (link * FSI_HUB_LINK_SIZE);\n\treturn fsi_slave_read(hub->upstream->slave, addr, val, size);\n}\n\nstatic int hub_master_write(struct fsi_master *master, int link,\n\t\t\tuint8_t id, uint32_t addr, const void *val, size_t size)\n{\n\tstruct fsi_master_hub *hub = to_fsi_master_hub(master);\n\n\tif (id != 0)\n\t\treturn -EINVAL;\n\n\taddr += hub->addr + (link * FSI_HUB_LINK_SIZE);\n\treturn fsi_slave_write(hub->upstream->slave, addr, val, size);\n}\n\nstatic int hub_master_break(struct fsi_master *master, int link)\n{\n\tuint32_t addr;\n\t__be32 cmd;\n\n\taddr = 0x4;\n\tcmd = cpu_to_be32(0xc0de0000);\n\n\treturn hub_master_write(master, link, 0, addr, &cmd, sizeof(cmd));\n}\n\nstatic int hub_master_link_enable(struct fsi_master *master, int link,\n\t\t\t\t  bool enable)\n{\n\tstruct fsi_master_hub *hub = to_fsi_master_hub(master);\n\tint idx, bit;\n\t__be32 reg;\n\tint rc;\n\n\tidx = link / 32;\n\tbit = link % 32;\n\n\treg = cpu_to_be32(0x80000000 >> bit);\n\n\tif (!enable)\n\t\treturn fsi_device_write(hub->upstream, FSI_MCENP0 + (4 * idx),\n\t\t\t\t\t&reg, 4);\n\n\trc = fsi_device_write(hub->upstream, FSI_MSENP0 + (4 * idx), &reg, 4);\n\tif (rc)\n\t\treturn rc;\n\n\tmdelay(FSI_LINK_ENABLE_SETUP_TIME);\n\n\treturn 0;\n}\n\nstatic void hub_master_release(struct device *dev)\n{\n\tstruct fsi_master_hub *hub = to_fsi_master_hub(to_fsi_master(dev));\n\n\tkfree(hub);\n}\n\n \nstatic inline u32 fsi_mmode_crs0(u32 x)\n{\n\treturn (x & FSI_MMODE_CRS0MASK) << FSI_MMODE_CRS0SHFT;\n}\n\nstatic inline u32 fsi_mmode_crs1(u32 x)\n{\n\treturn (x & FSI_MMODE_CRS1MASK) << FSI_MMODE_CRS1SHFT;\n}\n\nstatic int hub_master_init(struct fsi_master_hub *hub)\n{\n\tstruct fsi_device *dev = hub->upstream;\n\t__be32 reg;\n\tint rc;\n\n\treg = cpu_to_be32(FSI_MRESP_RST_ALL_MASTER | FSI_MRESP_RST_ALL_LINK\n\t\t\t| FSI_MRESP_RST_MCR | FSI_MRESP_RST_PYE);\n\trc = fsi_device_write(dev, FSI_MRESP0, &reg, sizeof(reg));\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treg = cpu_to_be32(FSI_MRESP_RST_ALL_MASTER | FSI_MRESP_RST_ALL_LINK\n\t\t\t| FSI_MRESP_RST_MCR | FSI_MRESP_RST_PYE);\n\trc = fsi_device_write(dev, FSI_MRESP0, &reg, sizeof(reg));\n\tif (rc)\n\t\treturn rc;\n\n\treg = cpu_to_be32(FSI_MECTRL_EOAE | FSI_MECTRL_P8_AUTO_TERM);\n\trc = fsi_device_write(dev, FSI_MECTRL, &reg, sizeof(reg));\n\tif (rc)\n\t\treturn rc;\n\n\treg = cpu_to_be32(FSI_MMODE_EIP | FSI_MMODE_ECRC | FSI_MMODE_EPC\n\t\t\t| fsi_mmode_crs0(1) | fsi_mmode_crs1(1)\n\t\t\t| FSI_MMODE_P8_TO_LSB);\n\trc = fsi_device_write(dev, FSI_MMODE, &reg, sizeof(reg));\n\tif (rc)\n\t\treturn rc;\n\n\treg = cpu_to_be32(0xffff0000);\n\trc = fsi_device_write(dev, FSI_MDLYR, &reg, sizeof(reg));\n\tif (rc)\n\t\treturn rc;\n\n\treg = cpu_to_be32(~0);\n\trc = fsi_device_write(dev, FSI_MSENP0, &reg, sizeof(reg));\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tmdelay(FSI_LINK_ENABLE_SETUP_TIME);\n\n\trc = fsi_device_write(dev, FSI_MCENP0, &reg, sizeof(reg));\n\tif (rc)\n\t\treturn rc;\n\n\trc = fsi_device_read(dev, FSI_MAEB, &reg, sizeof(reg));\n\tif (rc)\n\t\treturn rc;\n\n\treg = cpu_to_be32(FSI_MRESP_RST_ALL_MASTER | FSI_MRESP_RST_ALL_LINK);\n\trc = fsi_device_write(dev, FSI_MRESP0, &reg, sizeof(reg));\n\tif (rc)\n\t\treturn rc;\n\n\trc = fsi_device_read(dev, FSI_MLEVP0, &reg, sizeof(reg));\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treg = cpu_to_be32(FSI_MRESB_RST_GEN);\n\trc = fsi_device_write(dev, FSI_MRESB0, &reg, sizeof(reg));\n\tif (rc)\n\t\treturn rc;\n\n\treg = cpu_to_be32(FSI_MRESB_RST_ERR);\n\treturn fsi_device_write(dev, FSI_MRESB0, &reg, sizeof(reg));\n}\n\nstatic int hub_master_probe(struct device *dev)\n{\n\tstruct fsi_device *fsi_dev = to_fsi_dev(dev);\n\tstruct fsi_master_hub *hub;\n\tuint32_t reg, links;\n\t__be32 __reg;\n\tint rc;\n\n\trc = fsi_device_read(fsi_dev, FSI_MVER, &__reg, sizeof(__reg));\n\tif (rc)\n\t\treturn rc;\n\n\treg = be32_to_cpu(__reg);\n\tlinks = (reg >> 8) & 0xff;\n\tdev_dbg(dev, \"hub version %08x (%d links)\\n\", reg, links);\n\n\trc = fsi_slave_claim_range(fsi_dev->slave, FSI_HUB_LINK_OFFSET,\n\t\t\tFSI_HUB_LINK_SIZE * links);\n\tif (rc) {\n\t\tdev_err(dev, \"can't claim slave address range for links\");\n\t\treturn rc;\n\t}\n\n\thub = kzalloc(sizeof(*hub), GFP_KERNEL);\n\tif (!hub) {\n\t\trc = -ENOMEM;\n\t\tgoto err_release;\n\t}\n\n\thub->addr = FSI_HUB_LINK_OFFSET;\n\thub->size = FSI_HUB_LINK_SIZE * links;\n\thub->upstream = fsi_dev;\n\n\thub->master.dev.parent = dev;\n\thub->master.dev.release = hub_master_release;\n\thub->master.dev.of_node = of_node_get(dev_of_node(dev));\n\n\thub->master.n_links = links;\n\thub->master.read = hub_master_read;\n\thub->master.write = hub_master_write;\n\thub->master.send_break = hub_master_break;\n\thub->master.link_enable = hub_master_link_enable;\n\n\tdev_set_drvdata(dev, hub);\n\n\thub_master_init(hub);\n\n\trc = fsi_master_register(&hub->master);\n\tif (rc)\n\t\tgoto err_release;\n\n\t \n\tget_device(&hub->master.dev);\n\treturn 0;\n\nerr_release:\n\tfsi_slave_release_range(fsi_dev->slave, FSI_HUB_LINK_OFFSET,\n\t\t\tFSI_HUB_LINK_SIZE * links);\n\treturn rc;\n}\n\nstatic int hub_master_remove(struct device *dev)\n{\n\tstruct fsi_master_hub *hub = dev_get_drvdata(dev);\n\n\tfsi_master_unregister(&hub->master);\n\tfsi_slave_release_range(hub->upstream->slave, hub->addr, hub->size);\n\tof_node_put(hub->master.dev.of_node);\n\n\t \n\tput_device(&hub->master.dev);\n\n\treturn 0;\n}\n\nstatic const struct fsi_device_id hub_master_ids[] = {\n\t{\n\t\t.engine_type = FSI_ENGID_HUB_MASTER,\n\t\t.version = FSI_VERSION_ANY,\n\t},\n\t{ 0 }\n};\n\nstatic struct fsi_driver hub_master_driver = {\n\t.id_table = hub_master_ids,\n\t.drv = {\n\t\t.name = \"fsi-master-hub\",\n\t\t.bus = &fsi_bus_type,\n\t\t.probe = hub_master_probe,\n\t\t.remove = hub_master_remove,\n\t}\n};\n\nmodule_fsi_driver(hub_master_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}