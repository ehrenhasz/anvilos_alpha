{
  "module_name": "hisi_uncore_l3c_pmu.c",
  "hash_id": "87be73e639ea72b39d7e3c720cd514be0b13faad2f78e47b93288fd4f7f9cfe5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/hisilicon/hisi_uncore_l3c_pmu.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/bug.h>\n#include <linux/cpuhotplug.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/list.h>\n#include <linux/smp.h>\n\n#include \"hisi_uncore_pmu.h\"\n\n \n#define L3C_PERF_CTRL\t\t0x0408\n#define L3C_INT_MASK\t\t0x0800\n#define L3C_INT_STATUS\t\t0x0808\n#define L3C_INT_CLEAR\t\t0x080c\n#define L3C_CORE_CTRL           0x1b04\n#define L3C_TRACETAG_CTRL       0x1b20\n#define L3C_DATSRC_TYPE         0x1b48\n#define L3C_DATSRC_CTRL         0x1bf0\n#define L3C_EVENT_CTRL\t        0x1c00\n#define L3C_VERSION\t\t0x1cf0\n#define L3C_EVENT_TYPE0\t\t0x1d00\n \n#define L3C_CNTR0_LOWER\t\t0x1e00\n\n \n#define L3C_NR_COUNTERS\t\t0x8\n\n#define L3C_PERF_CTRL_EN\t0x10000\n#define L3C_TRACETAG_EN\t\tBIT(31)\n#define L3C_TRACETAG_REQ_SHIFT\t7\n#define L3C_TRACETAG_MARK_EN\tBIT(0)\n#define L3C_TRACETAG_REQ_EN\t(L3C_TRACETAG_MARK_EN | BIT(2))\n#define L3C_TRACETAG_CORE_EN\t(L3C_TRACETAG_MARK_EN | BIT(3))\n#define L3C_CORE_EN\t\tBIT(20)\n#define L3C_COER_NONE\t\t0x0\n#define L3C_DATSRC_MASK\t\t0xFF\n#define L3C_DATSRC_SKT_EN\tBIT(23)\n#define L3C_DATSRC_NONE\t\t0x0\n#define L3C_EVTYPE_NONE\t\t0xff\n#define L3C_V1_NR_EVENTS\t0x59\n#define L3C_V2_NR_EVENTS\t0xFF\n\nHISI_PMU_EVENT_ATTR_EXTRACTOR(tt_core, config1, 7, 0);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(tt_req, config1, 10, 8);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(datasrc_cfg, config1, 15, 11);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(datasrc_skt, config1, 16, 16);\n\nstatic void hisi_l3c_pmu_config_req_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *l3c_pmu = to_hisi_pmu(event->pmu);\n\tu32 tt_req = hisi_get_tt_req(event);\n\n\tif (tt_req) {\n\t\tu32 val;\n\n\t\t \n\t\tval = readl(l3c_pmu->base + L3C_TRACETAG_CTRL);\n\t\tval |= tt_req << L3C_TRACETAG_REQ_SHIFT;\n\t\tval |= L3C_TRACETAG_REQ_EN;\n\t\twritel(val, l3c_pmu->base + L3C_TRACETAG_CTRL);\n\n\t\t \n\t\tval = readl(l3c_pmu->base + L3C_PERF_CTRL);\n\t\tval |= L3C_TRACETAG_EN;\n\t\twritel(val, l3c_pmu->base + L3C_PERF_CTRL);\n\t}\n}\n\nstatic void hisi_l3c_pmu_clear_req_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *l3c_pmu = to_hisi_pmu(event->pmu);\n\tu32 tt_req = hisi_get_tt_req(event);\n\n\tif (tt_req) {\n\t\tu32 val;\n\n\t\t \n\t\tval = readl(l3c_pmu->base + L3C_TRACETAG_CTRL);\n\t\tval &= ~(tt_req << L3C_TRACETAG_REQ_SHIFT);\n\t\tval &= ~L3C_TRACETAG_REQ_EN;\n\t\twritel(val, l3c_pmu->base + L3C_TRACETAG_CTRL);\n\n\t\t \n\t\tval = readl(l3c_pmu->base + L3C_PERF_CTRL);\n\t\tval &= ~L3C_TRACETAG_EN;\n\t\twritel(val, l3c_pmu->base + L3C_PERF_CTRL);\n\t}\n}\n\nstatic void hisi_l3c_pmu_write_ds(struct perf_event *event, u32 ds_cfg)\n{\n\tstruct hisi_pmu *l3c_pmu = to_hisi_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu32 reg, reg_idx, shift, val;\n\tint idx = hwc->idx;\n\n\t \n\treg = L3C_DATSRC_TYPE + (idx / 4) * 4;\n\treg_idx = idx % 4;\n\tshift = 8 * reg_idx;\n\n\tval = readl(l3c_pmu->base + reg);\n\tval &= ~(L3C_DATSRC_MASK << shift);\n\tval |= ds_cfg << shift;\n\twritel(val, l3c_pmu->base + reg);\n}\n\nstatic void hisi_l3c_pmu_config_ds(struct perf_event *event)\n{\n\tstruct hisi_pmu *l3c_pmu = to_hisi_pmu(event->pmu);\n\tu32 ds_cfg = hisi_get_datasrc_cfg(event);\n\tu32 ds_skt = hisi_get_datasrc_skt(event);\n\n\tif (ds_cfg)\n\t\thisi_l3c_pmu_write_ds(event, ds_cfg);\n\n\tif (ds_skt) {\n\t\tu32 val;\n\n\t\tval = readl(l3c_pmu->base + L3C_DATSRC_CTRL);\n\t\tval |= L3C_DATSRC_SKT_EN;\n\t\twritel(val, l3c_pmu->base + L3C_DATSRC_CTRL);\n\t}\n}\n\nstatic void hisi_l3c_pmu_clear_ds(struct perf_event *event)\n{\n\tstruct hisi_pmu *l3c_pmu = to_hisi_pmu(event->pmu);\n\tu32 ds_cfg = hisi_get_datasrc_cfg(event);\n\tu32 ds_skt = hisi_get_datasrc_skt(event);\n\n\tif (ds_cfg)\n\t\thisi_l3c_pmu_write_ds(event, L3C_DATSRC_NONE);\n\n\tif (ds_skt) {\n\t\tu32 val;\n\n\t\tval = readl(l3c_pmu->base + L3C_DATSRC_CTRL);\n\t\tval &= ~L3C_DATSRC_SKT_EN;\n\t\twritel(val, l3c_pmu->base + L3C_DATSRC_CTRL);\n\t}\n}\n\nstatic void hisi_l3c_pmu_config_core_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *l3c_pmu = to_hisi_pmu(event->pmu);\n\tu32 core = hisi_get_tt_core(event);\n\n\tif (core) {\n\t\tu32 val;\n\n\t\t \n\t\twritel(core, l3c_pmu->base + L3C_CORE_CTRL);\n\t\tval = readl(l3c_pmu->base + L3C_PERF_CTRL);\n\t\tval |= L3C_CORE_EN;\n\t\twritel(val, l3c_pmu->base + L3C_PERF_CTRL);\n\n\t\t \n\t\tval = readl(l3c_pmu->base + L3C_TRACETAG_CTRL);\n\t\tval |= L3C_TRACETAG_CORE_EN;\n\t\twritel(val, l3c_pmu->base + L3C_TRACETAG_CTRL);\n\t}\n}\n\nstatic void hisi_l3c_pmu_clear_core_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *l3c_pmu = to_hisi_pmu(event->pmu);\n\tu32 core = hisi_get_tt_core(event);\n\n\tif (core) {\n\t\tu32 val;\n\n\t\t \n\t\twritel(L3C_COER_NONE, l3c_pmu->base + L3C_CORE_CTRL);\n\t\tval = readl(l3c_pmu->base + L3C_PERF_CTRL);\n\t\tval &= ~L3C_CORE_EN;\n\t\twritel(val, l3c_pmu->base + L3C_PERF_CTRL);\n\n\t\t \n\t\tval = readl(l3c_pmu->base + L3C_TRACETAG_CTRL);\n\t\tval &= ~L3C_TRACETAG_CORE_EN;\n\t\twritel(val, l3c_pmu->base + L3C_TRACETAG_CTRL);\n\t}\n}\n\nstatic void hisi_l3c_pmu_enable_filter(struct perf_event *event)\n{\n\tif (event->attr.config1 != 0x0) {\n\t\thisi_l3c_pmu_config_req_tracetag(event);\n\t\thisi_l3c_pmu_config_core_tracetag(event);\n\t\thisi_l3c_pmu_config_ds(event);\n\t}\n}\n\nstatic void hisi_l3c_pmu_disable_filter(struct perf_event *event)\n{\n\tif (event->attr.config1 != 0x0) {\n\t\thisi_l3c_pmu_clear_ds(event);\n\t\thisi_l3c_pmu_clear_core_tracetag(event);\n\t\thisi_l3c_pmu_clear_req_tracetag(event);\n\t}\n}\n\n \nstatic u32 hisi_l3c_pmu_get_counter_offset(int cntr_idx)\n{\n\treturn (L3C_CNTR0_LOWER + (cntr_idx * 8));\n}\n\nstatic u64 hisi_l3c_pmu_read_counter(struct hisi_pmu *l3c_pmu,\n\t\t\t\t     struct hw_perf_event *hwc)\n{\n\treturn readq(l3c_pmu->base + hisi_l3c_pmu_get_counter_offset(hwc->idx));\n}\n\nstatic void hisi_l3c_pmu_write_counter(struct hisi_pmu *l3c_pmu,\n\t\t\t\t       struct hw_perf_event *hwc, u64 val)\n{\n\twriteq(val, l3c_pmu->base + hisi_l3c_pmu_get_counter_offset(hwc->idx));\n}\n\nstatic void hisi_l3c_pmu_write_evtype(struct hisi_pmu *l3c_pmu, int idx,\n\t\t\t\t      u32 type)\n{\n\tu32 reg, reg_idx, shift, val;\n\n\t \n\treg = L3C_EVENT_TYPE0 + (idx / 4) * 4;\n\treg_idx = idx % 4;\n\tshift = 8 * reg_idx;\n\n\t \n\tval = readl(l3c_pmu->base + reg);\n\tval &= ~(L3C_EVTYPE_NONE << shift);\n\tval |= (type << shift);\n\twritel(val, l3c_pmu->base + reg);\n}\n\nstatic void hisi_l3c_pmu_start_counters(struct hisi_pmu *l3c_pmu)\n{\n\tu32 val;\n\n\t \n\tval = readl(l3c_pmu->base + L3C_PERF_CTRL);\n\tval |= L3C_PERF_CTRL_EN;\n\twritel(val, l3c_pmu->base + L3C_PERF_CTRL);\n}\n\nstatic void hisi_l3c_pmu_stop_counters(struct hisi_pmu *l3c_pmu)\n{\n\tu32 val;\n\n\t \n\tval = readl(l3c_pmu->base + L3C_PERF_CTRL);\n\tval &= ~(L3C_PERF_CTRL_EN);\n\twritel(val, l3c_pmu->base + L3C_PERF_CTRL);\n}\n\nstatic void hisi_l3c_pmu_enable_counter(struct hisi_pmu *l3c_pmu,\n\t\t\t\t\tstruct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(l3c_pmu->base + L3C_EVENT_CTRL);\n\tval |= (1 << hwc->idx);\n\twritel(val, l3c_pmu->base + L3C_EVENT_CTRL);\n}\n\nstatic void hisi_l3c_pmu_disable_counter(struct hisi_pmu *l3c_pmu,\n\t\t\t\t\t struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(l3c_pmu->base + L3C_EVENT_CTRL);\n\tval &= ~(1 << hwc->idx);\n\twritel(val, l3c_pmu->base + L3C_EVENT_CTRL);\n}\n\nstatic void hisi_l3c_pmu_enable_counter_int(struct hisi_pmu *l3c_pmu,\n\t\t\t\t\t    struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\tval = readl(l3c_pmu->base + L3C_INT_MASK);\n\t \n\tval &= ~(1 << hwc->idx);\n\twritel(val, l3c_pmu->base + L3C_INT_MASK);\n}\n\nstatic void hisi_l3c_pmu_disable_counter_int(struct hisi_pmu *l3c_pmu,\n\t\t\t\t\t     struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\tval = readl(l3c_pmu->base + L3C_INT_MASK);\n\t \n\tval |= (1 << hwc->idx);\n\twritel(val, l3c_pmu->base + L3C_INT_MASK);\n}\n\nstatic u32 hisi_l3c_pmu_get_int_status(struct hisi_pmu *l3c_pmu)\n{\n\treturn readl(l3c_pmu->base + L3C_INT_STATUS);\n}\n\nstatic void hisi_l3c_pmu_clear_int_status(struct hisi_pmu *l3c_pmu, int idx)\n{\n\twritel(1 << idx, l3c_pmu->base + L3C_INT_CLEAR);\n}\n\nstatic const struct acpi_device_id hisi_l3c_pmu_acpi_match[] = {\n\t{ \"HISI0213\", },\n\t{ \"HISI0214\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, hisi_l3c_pmu_acpi_match);\n\nstatic int hisi_l3c_pmu_init_data(struct platform_device *pdev,\n\t\t\t\t  struct hisi_pmu *l3c_pmu)\n{\n\t \n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,scl-id\",\n\t\t\t\t     &l3c_pmu->sccl_id)) {\n\t\tdev_err(&pdev->dev, \"Can not read l3c sccl-id!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,ccl-id\",\n\t\t\t\t     &l3c_pmu->ccl_id)) {\n\t\tdev_err(&pdev->dev, \"Can not read l3c ccl-id!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tl3c_pmu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(l3c_pmu->base)) {\n\t\tdev_err(&pdev->dev, \"ioremap failed for l3c_pmu resource\\n\");\n\t\treturn PTR_ERR(l3c_pmu->base);\n\t}\n\n\tl3c_pmu->identifier = readl(l3c_pmu->base + L3C_VERSION);\n\n\treturn 0;\n}\n\nstatic struct attribute *hisi_l3c_pmu_v1_format_attr[] = {\n\tHISI_PMU_FORMAT_ATTR(event, \"config:0-7\"),\n\tNULL,\n};\n\nstatic const struct attribute_group hisi_l3c_pmu_v1_format_group = {\n\t.name = \"format\",\n\t.attrs = hisi_l3c_pmu_v1_format_attr,\n};\n\nstatic struct attribute *hisi_l3c_pmu_v2_format_attr[] = {\n\tHISI_PMU_FORMAT_ATTR(event, \"config:0-7\"),\n\tHISI_PMU_FORMAT_ATTR(tt_core, \"config1:0-7\"),\n\tHISI_PMU_FORMAT_ATTR(tt_req, \"config1:8-10\"),\n\tHISI_PMU_FORMAT_ATTR(datasrc_cfg, \"config1:11-15\"),\n\tHISI_PMU_FORMAT_ATTR(datasrc_skt, \"config1:16\"),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_l3c_pmu_v2_format_group = {\n\t.name = \"format\",\n\t.attrs = hisi_l3c_pmu_v2_format_attr,\n};\n\nstatic struct attribute *hisi_l3c_pmu_v1_events_attr[] = {\n\tHISI_PMU_EVENT_ATTR(rd_cpipe,\t\t0x00),\n\tHISI_PMU_EVENT_ATTR(wr_cpipe,\t\t0x01),\n\tHISI_PMU_EVENT_ATTR(rd_hit_cpipe,\t0x02),\n\tHISI_PMU_EVENT_ATTR(wr_hit_cpipe,\t0x03),\n\tHISI_PMU_EVENT_ATTR(victim_num,\t\t0x04),\n\tHISI_PMU_EVENT_ATTR(rd_spipe,\t\t0x20),\n\tHISI_PMU_EVENT_ATTR(wr_spipe,\t\t0x21),\n\tHISI_PMU_EVENT_ATTR(rd_hit_spipe,\t0x22),\n\tHISI_PMU_EVENT_ATTR(wr_hit_spipe,\t0x23),\n\tHISI_PMU_EVENT_ATTR(back_invalid,\t0x29),\n\tHISI_PMU_EVENT_ATTR(retry_cpu,\t\t0x40),\n\tHISI_PMU_EVENT_ATTR(retry_ring,\t\t0x41),\n\tHISI_PMU_EVENT_ATTR(prefetch_drop,\t0x42),\n\tNULL,\n};\n\nstatic const struct attribute_group hisi_l3c_pmu_v1_events_group = {\n\t.name = \"events\",\n\t.attrs = hisi_l3c_pmu_v1_events_attr,\n};\n\nstatic struct attribute *hisi_l3c_pmu_v2_events_attr[] = {\n\tHISI_PMU_EVENT_ATTR(l3c_hit,\t\t0x48),\n\tHISI_PMU_EVENT_ATTR(cycles,\t\t0x7f),\n\tHISI_PMU_EVENT_ATTR(l3c_ref,\t\t0xb8),\n\tHISI_PMU_EVENT_ATTR(dat_access,\t\t0xb9),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_l3c_pmu_v2_events_group = {\n\t.name = \"events\",\n\t.attrs = hisi_l3c_pmu_v2_events_attr,\n};\n\nstatic DEVICE_ATTR(cpumask, 0444, hisi_cpumask_sysfs_show, NULL);\n\nstatic struct attribute *hisi_l3c_pmu_cpumask_attrs[] = {\n\t&dev_attr_cpumask.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group hisi_l3c_pmu_cpumask_attr_group = {\n\t.attrs = hisi_l3c_pmu_cpumask_attrs,\n};\n\nstatic struct device_attribute hisi_l3c_pmu_identifier_attr =\n\t__ATTR(identifier, 0444, hisi_uncore_pmu_identifier_attr_show, NULL);\n\nstatic struct attribute *hisi_l3c_pmu_identifier_attrs[] = {\n\t&hisi_l3c_pmu_identifier_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hisi_l3c_pmu_identifier_group = {\n\t.attrs = hisi_l3c_pmu_identifier_attrs,\n};\n\nstatic const struct attribute_group *hisi_l3c_pmu_v1_attr_groups[] = {\n\t&hisi_l3c_pmu_v1_format_group,\n\t&hisi_l3c_pmu_v1_events_group,\n\t&hisi_l3c_pmu_cpumask_attr_group,\n\t&hisi_l3c_pmu_identifier_group,\n\tNULL,\n};\n\nstatic const struct attribute_group *hisi_l3c_pmu_v2_attr_groups[] = {\n\t&hisi_l3c_pmu_v2_format_group,\n\t&hisi_l3c_pmu_v2_events_group,\n\t&hisi_l3c_pmu_cpumask_attr_group,\n\t&hisi_l3c_pmu_identifier_group,\n\tNULL\n};\n\nstatic const struct hisi_uncore_ops hisi_uncore_l3c_ops = {\n\t.write_evtype\t\t= hisi_l3c_pmu_write_evtype,\n\t.get_event_idx\t\t= hisi_uncore_pmu_get_event_idx,\n\t.start_counters\t\t= hisi_l3c_pmu_start_counters,\n\t.stop_counters\t\t= hisi_l3c_pmu_stop_counters,\n\t.enable_counter\t\t= hisi_l3c_pmu_enable_counter,\n\t.disable_counter\t= hisi_l3c_pmu_disable_counter,\n\t.enable_counter_int\t= hisi_l3c_pmu_enable_counter_int,\n\t.disable_counter_int\t= hisi_l3c_pmu_disable_counter_int,\n\t.write_counter\t\t= hisi_l3c_pmu_write_counter,\n\t.read_counter\t\t= hisi_l3c_pmu_read_counter,\n\t.get_int_status\t\t= hisi_l3c_pmu_get_int_status,\n\t.clear_int_status\t= hisi_l3c_pmu_clear_int_status,\n\t.enable_filter\t\t= hisi_l3c_pmu_enable_filter,\n\t.disable_filter\t\t= hisi_l3c_pmu_disable_filter,\n};\n\nstatic int hisi_l3c_pmu_dev_probe(struct platform_device *pdev,\n\t\t\t\t  struct hisi_pmu *l3c_pmu)\n{\n\tint ret;\n\n\tret = hisi_l3c_pmu_init_data(pdev, l3c_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_uncore_pmu_init_irq(l3c_pmu, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (l3c_pmu->identifier >= HISI_PMU_V2) {\n\t\tl3c_pmu->counter_bits = 64;\n\t\tl3c_pmu->check_event = L3C_V2_NR_EVENTS;\n\t\tl3c_pmu->pmu_events.attr_groups = hisi_l3c_pmu_v2_attr_groups;\n\t} else {\n\t\tl3c_pmu->counter_bits = 48;\n\t\tl3c_pmu->check_event = L3C_V1_NR_EVENTS;\n\t\tl3c_pmu->pmu_events.attr_groups = hisi_l3c_pmu_v1_attr_groups;\n\t}\n\n\tl3c_pmu->num_counters = L3C_NR_COUNTERS;\n\tl3c_pmu->ops = &hisi_uncore_l3c_ops;\n\tl3c_pmu->dev = &pdev->dev;\n\tl3c_pmu->on_cpu = -1;\n\n\treturn 0;\n}\n\nstatic int hisi_l3c_pmu_probe(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *l3c_pmu;\n\tchar *name;\n\tint ret;\n\n\tl3c_pmu = devm_kzalloc(&pdev->dev, sizeof(*l3c_pmu), GFP_KERNEL);\n\tif (!l3c_pmu)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, l3c_pmu);\n\n\tret = hisi_l3c_pmu_dev_probe(pdev, l3c_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"hisi_sccl%u_l3c%u\",\n\t\t\t      l3c_pmu->sccl_id, l3c_pmu->ccl_id);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = cpuhp_state_add_instance(CPUHP_AP_PERF_ARM_HISI_L3_ONLINE,\n\t\t\t\t       &l3c_pmu->node);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error %d registering hotplug\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thisi_pmu_init(l3c_pmu, THIS_MODULE);\n\n\tret = perf_pmu_register(&l3c_pmu->pmu, name, -1);\n\tif (ret) {\n\t\tdev_err(l3c_pmu->dev, \"L3C PMU register failed!\\n\");\n\t\tcpuhp_state_remove_instance_nocalls(\n\t\t\tCPUHP_AP_PERF_ARM_HISI_L3_ONLINE, &l3c_pmu->node);\n\t}\n\n\treturn ret;\n}\n\nstatic int hisi_l3c_pmu_remove(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *l3c_pmu = platform_get_drvdata(pdev);\n\n\tperf_pmu_unregister(&l3c_pmu->pmu);\n\tcpuhp_state_remove_instance_nocalls(CPUHP_AP_PERF_ARM_HISI_L3_ONLINE,\n\t\t\t\t\t    &l3c_pmu->node);\n\treturn 0;\n}\n\nstatic struct platform_driver hisi_l3c_pmu_driver = {\n\t.driver = {\n\t\t.name = \"hisi_l3c_pmu\",\n\t\t.acpi_match_table = ACPI_PTR(hisi_l3c_pmu_acpi_match),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = hisi_l3c_pmu_probe,\n\t.remove = hisi_l3c_pmu_remove,\n};\n\nstatic int __init hisi_l3c_pmu_module_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_PERF_ARM_HISI_L3_ONLINE,\n\t\t\t\t      \"AP_PERF_ARM_HISI_L3_ONLINE\",\n\t\t\t\t      hisi_uncore_pmu_online_cpu,\n\t\t\t\t      hisi_uncore_pmu_offline_cpu);\n\tif (ret) {\n\t\tpr_err(\"L3C PMU: Error setup hotplug, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&hisi_l3c_pmu_driver);\n\tif (ret)\n\t\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HISI_L3_ONLINE);\n\n\treturn ret;\n}\nmodule_init(hisi_l3c_pmu_module_init);\n\nstatic void __exit hisi_l3c_pmu_module_exit(void)\n{\n\tplatform_driver_unregister(&hisi_l3c_pmu_driver);\n\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HISI_L3_ONLINE);\n}\nmodule_exit(hisi_l3c_pmu_module_exit);\n\nMODULE_DESCRIPTION(\"HiSilicon SoC L3C uncore PMU driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Anurup M <anurup.m@huawei.com>\");\nMODULE_AUTHOR(\"Shaokun Zhang <zhangshaokun@hisilicon.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}