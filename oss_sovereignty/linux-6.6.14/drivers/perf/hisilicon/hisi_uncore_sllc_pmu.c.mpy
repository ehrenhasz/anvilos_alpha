{
  "module_name": "hisi_uncore_sllc_pmu.c",
  "hash_id": "097501c0822f71d128399293d6305aadf1ff08c43214a507969425a5fb564a0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/hisilicon/hisi_uncore_sllc_pmu.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/cpuhotplug.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/list.h>\n#include <linux/smp.h>\n\n#include \"hisi_uncore_pmu.h\"\n\n \n#define SLLC_INT_MASK\t\t\t0x0814\n#define SLLC_INT_STATUS\t\t\t0x0818\n#define SLLC_INT_CLEAR\t\t\t0x081c\n#define SLLC_PERF_CTRL\t\t\t0x1c00\n#define SLLC_SRCID_CTRL\t\t\t0x1c04\n#define SLLC_TGTID_CTRL\t\t\t0x1c08\n#define SLLC_EVENT_CTRL\t\t\t0x1c14\n#define SLLC_EVENT_TYPE0\t\t0x1c18\n#define SLLC_VERSION\t\t\t0x1cf0\n#define SLLC_EVENT_CNT0_L\t\t0x1d00\n\n#define SLLC_EVTYPE_MASK\t\t0xff\n#define SLLC_PERF_CTRL_EN\t\tBIT(0)\n#define SLLC_FILT_EN\t\t\tBIT(1)\n#define SLLC_TRACETAG_EN\t\tBIT(2)\n#define SLLC_SRCID_EN\t\t\tBIT(4)\n#define SLLC_SRCID_NONE\t\t\t0x0\n#define SLLC_TGTID_EN\t\t\tBIT(5)\n#define SLLC_TGTID_NONE\t\t\t0x0\n#define SLLC_TGTID_MIN_SHIFT\t\t1\n#define SLLC_TGTID_MAX_SHIFT\t\t12\n#define SLLC_SRCID_CMD_SHIFT\t\t1\n#define SLLC_SRCID_MSK_SHIFT\t\t12\n#define SLLC_NR_EVENTS\t\t\t0x80\n\nHISI_PMU_EVENT_ATTR_EXTRACTOR(tgtid_min, config1, 10, 0);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(tgtid_max, config1, 21, 11);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(srcid_cmd, config1, 32, 22);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(srcid_msk, config1, 43, 33);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(tracetag_en, config1, 44, 44);\n\nstatic bool tgtid_is_valid(u32 max, u32 min)\n{\n\treturn max > 0 && max >= min;\n}\n\nstatic void hisi_sllc_pmu_enable_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *sllc_pmu = to_hisi_pmu(event->pmu);\n\tu32 tt_en = hisi_get_tracetag_en(event);\n\n\tif (tt_en) {\n\t\tu32 val;\n\n\t\tval = readl(sllc_pmu->base + SLLC_PERF_CTRL);\n\t\tval |= SLLC_TRACETAG_EN | SLLC_FILT_EN;\n\t\twritel(val, sllc_pmu->base + SLLC_PERF_CTRL);\n\t}\n}\n\nstatic void hisi_sllc_pmu_disable_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *sllc_pmu = to_hisi_pmu(event->pmu);\n\tu32 tt_en = hisi_get_tracetag_en(event);\n\n\tif (tt_en) {\n\t\tu32 val;\n\n\t\tval = readl(sllc_pmu->base + SLLC_PERF_CTRL);\n\t\tval &= ~(SLLC_TRACETAG_EN | SLLC_FILT_EN);\n\t\twritel(val, sllc_pmu->base + SLLC_PERF_CTRL);\n\t}\n}\n\nstatic void hisi_sllc_pmu_config_tgtid(struct perf_event *event)\n{\n\tstruct hisi_pmu *sllc_pmu = to_hisi_pmu(event->pmu);\n\tu32 min = hisi_get_tgtid_min(event);\n\tu32 max = hisi_get_tgtid_max(event);\n\n\tif (tgtid_is_valid(max, min)) {\n\t\tu32 val = (max << SLLC_TGTID_MAX_SHIFT) | (min << SLLC_TGTID_MIN_SHIFT);\n\n\t\twritel(val, sllc_pmu->base + SLLC_TGTID_CTRL);\n\t\t \n\t\tval = readl(sllc_pmu->base + SLLC_PERF_CTRL);\n\t\tval |= SLLC_TGTID_EN | SLLC_FILT_EN;\n\t\twritel(val, sllc_pmu->base + SLLC_PERF_CTRL);\n\t}\n}\n\nstatic void hisi_sllc_pmu_clear_tgtid(struct perf_event *event)\n{\n\tstruct hisi_pmu *sllc_pmu = to_hisi_pmu(event->pmu);\n\tu32 min = hisi_get_tgtid_min(event);\n\tu32 max = hisi_get_tgtid_max(event);\n\n\tif (tgtid_is_valid(max, min)) {\n\t\tu32 val;\n\n\t\twritel(SLLC_TGTID_NONE, sllc_pmu->base + SLLC_TGTID_CTRL);\n\t\t \n\t\tval = readl(sllc_pmu->base + SLLC_PERF_CTRL);\n\t\tval &= ~(SLLC_TGTID_EN | SLLC_FILT_EN);\n\t\twritel(val, sllc_pmu->base + SLLC_PERF_CTRL);\n\t}\n}\n\nstatic void hisi_sllc_pmu_config_srcid(struct perf_event *event)\n{\n\tstruct hisi_pmu *sllc_pmu = to_hisi_pmu(event->pmu);\n\tu32 cmd = hisi_get_srcid_cmd(event);\n\n\tif (cmd) {\n\t\tu32 val, msk;\n\n\t\tmsk = hisi_get_srcid_msk(event);\n\t\tval = (cmd << SLLC_SRCID_CMD_SHIFT) | (msk << SLLC_SRCID_MSK_SHIFT);\n\t\twritel(val, sllc_pmu->base + SLLC_SRCID_CTRL);\n\t\t \n\t\tval = readl(sllc_pmu->base + SLLC_PERF_CTRL);\n\t\tval |= SLLC_SRCID_EN | SLLC_FILT_EN;\n\t\twritel(val, sllc_pmu->base + SLLC_PERF_CTRL);\n\t}\n}\n\nstatic void hisi_sllc_pmu_clear_srcid(struct perf_event *event)\n{\n\tstruct hisi_pmu *sllc_pmu = to_hisi_pmu(event->pmu);\n\tu32 cmd = hisi_get_srcid_cmd(event);\n\n\tif (cmd) {\n\t\tu32 val;\n\n\t\twritel(SLLC_SRCID_NONE, sllc_pmu->base + SLLC_SRCID_CTRL);\n\t\t \n\t\tval = readl(sllc_pmu->base + SLLC_PERF_CTRL);\n\t\tval &= ~(SLLC_SRCID_EN | SLLC_FILT_EN);\n\t\twritel(val, sllc_pmu->base + SLLC_PERF_CTRL);\n\t}\n}\n\nstatic void hisi_sllc_pmu_enable_filter(struct perf_event *event)\n{\n\tif (event->attr.config1 != 0x0) {\n\t\thisi_sllc_pmu_enable_tracetag(event);\n\t\thisi_sllc_pmu_config_srcid(event);\n\t\thisi_sllc_pmu_config_tgtid(event);\n\t}\n}\n\nstatic void hisi_sllc_pmu_clear_filter(struct perf_event *event)\n{\n\tif (event->attr.config1 != 0x0) {\n\t\thisi_sllc_pmu_disable_tracetag(event);\n\t\thisi_sllc_pmu_clear_srcid(event);\n\t\thisi_sllc_pmu_clear_tgtid(event);\n\t}\n}\n\nstatic u32 hisi_sllc_pmu_get_counter_offset(int idx)\n{\n\treturn (SLLC_EVENT_CNT0_L + idx * 8);\n}\n\nstatic u64 hisi_sllc_pmu_read_counter(struct hisi_pmu *sllc_pmu,\n\t\t\t\t      struct hw_perf_event *hwc)\n{\n\treturn readq(sllc_pmu->base +\n\t\t     hisi_sllc_pmu_get_counter_offset(hwc->idx));\n}\n\nstatic void hisi_sllc_pmu_write_counter(struct hisi_pmu *sllc_pmu,\n\t\t\t\t\tstruct hw_perf_event *hwc, u64 val)\n{\n\twriteq(val, sllc_pmu->base +\n\t       hisi_sllc_pmu_get_counter_offset(hwc->idx));\n}\n\nstatic void hisi_sllc_pmu_write_evtype(struct hisi_pmu *sllc_pmu, int idx,\n\t\t\t\t       u32 type)\n{\n\tu32 reg, reg_idx, shift, val;\n\n\t \n\treg = SLLC_EVENT_TYPE0 + (idx / 4) * 4;\n\treg_idx = idx % 4;\n\tshift = 8 * reg_idx;\n\n\t \n\tval = readl(sllc_pmu->base + reg);\n\tval &= ~(SLLC_EVTYPE_MASK << shift);\n\tval |= (type << shift);\n\twritel(val, sllc_pmu->base + reg);\n}\n\nstatic void hisi_sllc_pmu_start_counters(struct hisi_pmu *sllc_pmu)\n{\n\tu32 val;\n\n\tval = readl(sllc_pmu->base + SLLC_PERF_CTRL);\n\tval |= SLLC_PERF_CTRL_EN;\n\twritel(val, sllc_pmu->base + SLLC_PERF_CTRL);\n}\n\nstatic void hisi_sllc_pmu_stop_counters(struct hisi_pmu *sllc_pmu)\n{\n\tu32 val;\n\n\tval = readl(sllc_pmu->base + SLLC_PERF_CTRL);\n\tval &= ~(SLLC_PERF_CTRL_EN);\n\twritel(val, sllc_pmu->base + SLLC_PERF_CTRL);\n}\n\nstatic void hisi_sllc_pmu_enable_counter(struct hisi_pmu *sllc_pmu,\n\t\t\t\t\t struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\tval = readl(sllc_pmu->base + SLLC_EVENT_CTRL);\n\tval |= 1 << hwc->idx;\n\twritel(val, sllc_pmu->base + SLLC_EVENT_CTRL);\n}\n\nstatic void hisi_sllc_pmu_disable_counter(struct hisi_pmu *sllc_pmu,\n\t\t\t\t\t  struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\tval = readl(sllc_pmu->base + SLLC_EVENT_CTRL);\n\tval &= ~(1 << hwc->idx);\n\twritel(val, sllc_pmu->base + SLLC_EVENT_CTRL);\n}\n\nstatic void hisi_sllc_pmu_enable_counter_int(struct hisi_pmu *sllc_pmu,\n\t\t\t\t\t     struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\tval = readl(sllc_pmu->base + SLLC_INT_MASK);\n\t \n\tval &= ~(1 << hwc->idx);\n\twritel(val, sllc_pmu->base + SLLC_INT_MASK);\n}\n\nstatic void hisi_sllc_pmu_disable_counter_int(struct hisi_pmu *sllc_pmu,\n\t\t\t\t\t      struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\tval = readl(sllc_pmu->base + SLLC_INT_MASK);\n\t \n\tval |= 1 << hwc->idx;\n\twritel(val, sllc_pmu->base + SLLC_INT_MASK);\n}\n\nstatic u32 hisi_sllc_pmu_get_int_status(struct hisi_pmu *sllc_pmu)\n{\n\treturn readl(sllc_pmu->base + SLLC_INT_STATUS);\n}\n\nstatic void hisi_sllc_pmu_clear_int_status(struct hisi_pmu *sllc_pmu, int idx)\n{\n\twritel(1 << idx, sllc_pmu->base + SLLC_INT_CLEAR);\n}\n\nstatic const struct acpi_device_id hisi_sllc_pmu_acpi_match[] = {\n\t{ \"HISI0263\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, hisi_sllc_pmu_acpi_match);\n\nstatic int hisi_sllc_pmu_init_data(struct platform_device *pdev,\n\t\t\t\t   struct hisi_pmu *sllc_pmu)\n{\n\t \n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,scl-id\",\n\t\t\t\t     &sllc_pmu->sccl_id)) {\n\t\tdev_err(&pdev->dev, \"Cannot read sccl-id!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,idx-id\",\n\t\t\t\t     &sllc_pmu->index_id)) {\n\t\tdev_err(&pdev->dev, \"Cannot read idx-id!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsllc_pmu->ccl_id = -1;\n\n\tsllc_pmu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sllc_pmu->base)) {\n\t\tdev_err(&pdev->dev, \"ioremap failed for sllc_pmu resource.\\n\");\n\t\treturn PTR_ERR(sllc_pmu->base);\n\t}\n\n\tsllc_pmu->identifier = readl(sllc_pmu->base + SLLC_VERSION);\n\n\treturn 0;\n}\n\nstatic struct attribute *hisi_sllc_pmu_v2_format_attr[] = {\n\tHISI_PMU_FORMAT_ATTR(event, \"config:0-7\"),\n\tHISI_PMU_FORMAT_ATTR(tgtid_min, \"config1:0-10\"),\n\tHISI_PMU_FORMAT_ATTR(tgtid_max, \"config1:11-21\"),\n\tHISI_PMU_FORMAT_ATTR(srcid_cmd, \"config1:22-32\"),\n\tHISI_PMU_FORMAT_ATTR(srcid_msk, \"config1:33-43\"),\n\tHISI_PMU_FORMAT_ATTR(tracetag_en, \"config1:44\"),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_sllc_pmu_v2_format_group = {\n\t.name = \"format\",\n\t.attrs = hisi_sllc_pmu_v2_format_attr,\n};\n\nstatic struct attribute *hisi_sllc_pmu_v2_events_attr[] = {\n\tHISI_PMU_EVENT_ATTR(rx_req,             0x30),\n\tHISI_PMU_EVENT_ATTR(rx_data,            0x31),\n\tHISI_PMU_EVENT_ATTR(tx_req,             0x34),\n\tHISI_PMU_EVENT_ATTR(tx_data,            0x35),\n\tHISI_PMU_EVENT_ATTR(cycles,             0x09),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_sllc_pmu_v2_events_group = {\n\t.name = \"events\",\n\t.attrs = hisi_sllc_pmu_v2_events_attr,\n};\n\nstatic DEVICE_ATTR(cpumask, 0444, hisi_cpumask_sysfs_show, NULL);\n\nstatic struct attribute *hisi_sllc_pmu_cpumask_attrs[] = {\n\t&dev_attr_cpumask.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hisi_sllc_pmu_cpumask_attr_group = {\n\t.attrs = hisi_sllc_pmu_cpumask_attrs,\n};\n\nstatic struct device_attribute hisi_sllc_pmu_identifier_attr =\n\t__ATTR(identifier, 0444, hisi_uncore_pmu_identifier_attr_show, NULL);\n\nstatic struct attribute *hisi_sllc_pmu_identifier_attrs[] = {\n\t&hisi_sllc_pmu_identifier_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hisi_sllc_pmu_identifier_group = {\n\t.attrs = hisi_sllc_pmu_identifier_attrs,\n};\n\nstatic const struct attribute_group *hisi_sllc_pmu_v2_attr_groups[] = {\n\t&hisi_sllc_pmu_v2_format_group,\n\t&hisi_sllc_pmu_v2_events_group,\n\t&hisi_sllc_pmu_cpumask_attr_group,\n\t&hisi_sllc_pmu_identifier_group,\n\tNULL\n};\n\nstatic const struct hisi_uncore_ops hisi_uncore_sllc_ops = {\n\t.write_evtype\t\t= hisi_sllc_pmu_write_evtype,\n\t.get_event_idx\t\t= hisi_uncore_pmu_get_event_idx,\n\t.start_counters\t\t= hisi_sllc_pmu_start_counters,\n\t.stop_counters\t\t= hisi_sllc_pmu_stop_counters,\n\t.enable_counter\t\t= hisi_sllc_pmu_enable_counter,\n\t.disable_counter\t= hisi_sllc_pmu_disable_counter,\n\t.enable_counter_int\t= hisi_sllc_pmu_enable_counter_int,\n\t.disable_counter_int\t= hisi_sllc_pmu_disable_counter_int,\n\t.write_counter\t\t= hisi_sllc_pmu_write_counter,\n\t.read_counter\t\t= hisi_sllc_pmu_read_counter,\n\t.get_int_status\t\t= hisi_sllc_pmu_get_int_status,\n\t.clear_int_status\t= hisi_sllc_pmu_clear_int_status,\n\t.enable_filter\t\t= hisi_sllc_pmu_enable_filter,\n\t.disable_filter\t\t= hisi_sllc_pmu_clear_filter,\n};\n\nstatic int hisi_sllc_pmu_dev_probe(struct platform_device *pdev,\n\t\t\t\t   struct hisi_pmu *sllc_pmu)\n{\n\tint ret;\n\n\tret = hisi_sllc_pmu_init_data(pdev, sllc_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_uncore_pmu_init_irq(sllc_pmu, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tsllc_pmu->pmu_events.attr_groups = hisi_sllc_pmu_v2_attr_groups;\n\tsllc_pmu->ops = &hisi_uncore_sllc_ops;\n\tsllc_pmu->check_event = SLLC_NR_EVENTS;\n\tsllc_pmu->counter_bits = 64;\n\tsllc_pmu->num_counters = 8;\n\tsllc_pmu->dev = &pdev->dev;\n\tsllc_pmu->on_cpu = -1;\n\n\treturn 0;\n}\n\nstatic int hisi_sllc_pmu_probe(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *sllc_pmu;\n\tchar *name;\n\tint ret;\n\n\tsllc_pmu = devm_kzalloc(&pdev->dev, sizeof(*sllc_pmu), GFP_KERNEL);\n\tif (!sllc_pmu)\n\t\treturn -ENOMEM;\n\n\tret = hisi_sllc_pmu_dev_probe(pdev, sllc_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"hisi_sccl%u_sllc%u\",\n\t\t\t      sllc_pmu->sccl_id, sllc_pmu->index_id);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = cpuhp_state_add_instance(CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE,\n\t\t\t\t       &sllc_pmu->node);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error %d registering hotplug\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thisi_pmu_init(sllc_pmu, THIS_MODULE);\n\n\tret = perf_pmu_register(&sllc_pmu->pmu, name, -1);\n\tif (ret) {\n\t\tdev_err(sllc_pmu->dev, \"PMU register failed, ret = %d\\n\", ret);\n\t\tcpuhp_state_remove_instance_nocalls(CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE,\n\t\t\t\t\t\t    &sllc_pmu->node);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, sllc_pmu);\n\n\treturn ret;\n}\n\nstatic int hisi_sllc_pmu_remove(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *sllc_pmu = platform_get_drvdata(pdev);\n\n\tperf_pmu_unregister(&sllc_pmu->pmu);\n\tcpuhp_state_remove_instance_nocalls(CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE,\n\t\t\t\t\t    &sllc_pmu->node);\n\treturn 0;\n}\n\nstatic struct platform_driver hisi_sllc_pmu_driver = {\n\t.driver = {\n\t\t.name = \"hisi_sllc_pmu\",\n\t\t.acpi_match_table = hisi_sllc_pmu_acpi_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = hisi_sllc_pmu_probe,\n\t.remove = hisi_sllc_pmu_remove,\n};\n\nstatic int __init hisi_sllc_pmu_module_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE,\n\t\t\t\t      \"AP_PERF_ARM_HISI_SLLC_ONLINE\",\n\t\t\t\t      hisi_uncore_pmu_online_cpu,\n\t\t\t\t      hisi_uncore_pmu_offline_cpu);\n\tif (ret) {\n\t\tpr_err(\"SLLC PMU: cpuhp state setup failed, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&hisi_sllc_pmu_driver);\n\tif (ret)\n\t\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE);\n\n\treturn ret;\n}\nmodule_init(hisi_sllc_pmu_module_init);\n\nstatic void __exit hisi_sllc_pmu_module_exit(void)\n{\n\tplatform_driver_unregister(&hisi_sllc_pmu_driver);\n\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE);\n}\nmodule_exit(hisi_sllc_pmu_module_exit);\n\nMODULE_DESCRIPTION(\"HiSilicon SLLC uncore PMU driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Shaokun Zhang <zhangshaokun@hisilicon.com>\");\nMODULE_AUTHOR(\"Qi Liu <liuqi115@huawei.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}