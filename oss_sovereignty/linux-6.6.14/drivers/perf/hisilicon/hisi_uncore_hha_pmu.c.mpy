{
  "module_name": "hisi_uncore_hha_pmu.c",
  "hash_id": "d7a0a73c34dbc2f4ee33c3930f185c269ab5818ffac6e8cf50bc6e57bb885e46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/hisilicon/hisi_uncore_hha_pmu.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/bug.h>\n#include <linux/cpuhotplug.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/list.h>\n#include <linux/smp.h>\n\n#include \"hisi_uncore_pmu.h\"\n\n \n#define HHA_INT_MASK\t\t0x0804\n#define HHA_INT_STATUS\t\t0x0808\n#define HHA_INT_CLEAR\t\t0x080C\n#define HHA_VERSION\t\t0x1cf0\n#define HHA_PERF_CTRL\t\t0x1E00\n#define HHA_EVENT_CTRL\t\t0x1E04\n#define HHA_SRCID_CTRL\t\t0x1E08\n#define HHA_DATSRC_CTRL\t\t0x1BF0\n#define HHA_EVENT_TYPE0\t\t0x1E80\n \n#define HHA_CNT0_LOWER\t\t0x1F00\n\n \n#define HHA_V1_NR_COUNTERS\t0x10\n#define HHA_V2_NR_COUNTERS\t0x8\n\n#define HHA_PERF_CTRL_EN\t0x1\n#define HHA_TRACETAG_EN\t\tBIT(31)\n#define HHA_SRCID_EN\t\tBIT(2)\n#define HHA_SRCID_CMD_SHIFT\t6\n#define HHA_SRCID_MSK_SHIFT\t20\n#define HHA_SRCID_CMD\t\tGENMASK(16, 6)\n#define HHA_SRCID_MSK\t\tGENMASK(30, 20)\n#define HHA_DATSRC_SKT_EN\tBIT(23)\n#define HHA_EVTYPE_NONE\t\t0xff\n#define HHA_V1_NR_EVENT\t\t0x65\n#define HHA_V2_NR_EVENT\t\t0xCE\n\nHISI_PMU_EVENT_ATTR_EXTRACTOR(srcid_cmd, config1, 10, 0);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(srcid_msk, config1, 21, 11);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(tracetag_en, config1, 22, 22);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(datasrc_skt, config1, 23, 23);\n\nstatic void hisi_hha_pmu_enable_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *hha_pmu = to_hisi_pmu(event->pmu);\n\tu32 tt_en = hisi_get_tracetag_en(event);\n\n\tif (tt_en) {\n\t\tu32 val;\n\n\t\tval = readl(hha_pmu->base + HHA_SRCID_CTRL);\n\t\tval |= HHA_TRACETAG_EN;\n\t\twritel(val, hha_pmu->base + HHA_SRCID_CTRL);\n\t}\n}\n\nstatic void hisi_hha_pmu_clear_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *hha_pmu = to_hisi_pmu(event->pmu);\n\tu32 val;\n\n\tval = readl(hha_pmu->base + HHA_SRCID_CTRL);\n\tval &= ~HHA_TRACETAG_EN;\n\twritel(val, hha_pmu->base + HHA_SRCID_CTRL);\n}\n\nstatic void hisi_hha_pmu_config_ds(struct perf_event *event)\n{\n\tstruct hisi_pmu *hha_pmu = to_hisi_pmu(event->pmu);\n\tu32 ds_skt = hisi_get_datasrc_skt(event);\n\n\tif (ds_skt) {\n\t\tu32 val;\n\n\t\tval = readl(hha_pmu->base + HHA_DATSRC_CTRL);\n\t\tval |= HHA_DATSRC_SKT_EN;\n\t\twritel(val, hha_pmu->base + HHA_DATSRC_CTRL);\n\t}\n}\n\nstatic void hisi_hha_pmu_clear_ds(struct perf_event *event)\n{\n\tstruct hisi_pmu *hha_pmu = to_hisi_pmu(event->pmu);\n\tu32 ds_skt = hisi_get_datasrc_skt(event);\n\n\tif (ds_skt) {\n\t\tu32 val;\n\n\t\tval = readl(hha_pmu->base + HHA_DATSRC_CTRL);\n\t\tval &= ~HHA_DATSRC_SKT_EN;\n\t\twritel(val, hha_pmu->base + HHA_DATSRC_CTRL);\n\t}\n}\n\nstatic void hisi_hha_pmu_config_srcid(struct perf_event *event)\n{\n\tstruct hisi_pmu *hha_pmu = to_hisi_pmu(event->pmu);\n\tu32 cmd = hisi_get_srcid_cmd(event);\n\n\tif (cmd) {\n\t\tu32 val, msk;\n\n\t\tmsk = hisi_get_srcid_msk(event);\n\t\tval = readl(hha_pmu->base + HHA_SRCID_CTRL);\n\t\tval |= HHA_SRCID_EN | (cmd << HHA_SRCID_CMD_SHIFT) |\n\t\t\t(msk << HHA_SRCID_MSK_SHIFT);\n\t\twritel(val, hha_pmu->base + HHA_SRCID_CTRL);\n\t}\n}\n\nstatic void hisi_hha_pmu_disable_srcid(struct perf_event *event)\n{\n\tstruct hisi_pmu *hha_pmu = to_hisi_pmu(event->pmu);\n\tu32 cmd = hisi_get_srcid_cmd(event);\n\n\tif (cmd) {\n\t\tu32 val;\n\n\t\tval = readl(hha_pmu->base + HHA_SRCID_CTRL);\n\t\tval &= ~(HHA_SRCID_EN | HHA_SRCID_MSK | HHA_SRCID_CMD);\n\t\twritel(val, hha_pmu->base + HHA_SRCID_CTRL);\n\t}\n}\n\nstatic void hisi_hha_pmu_enable_filter(struct perf_event *event)\n{\n\tif (event->attr.config1 != 0x0) {\n\t\thisi_hha_pmu_enable_tracetag(event);\n\t\thisi_hha_pmu_config_ds(event);\n\t\thisi_hha_pmu_config_srcid(event);\n\t}\n}\n\nstatic void hisi_hha_pmu_disable_filter(struct perf_event *event)\n{\n\tif (event->attr.config1 != 0x0) {\n\t\thisi_hha_pmu_disable_srcid(event);\n\t\thisi_hha_pmu_clear_ds(event);\n\t\thisi_hha_pmu_clear_tracetag(event);\n\t}\n}\n\n \nstatic u32 hisi_hha_pmu_get_counter_offset(int cntr_idx)\n{\n\treturn (HHA_CNT0_LOWER + (cntr_idx * 8));\n}\n\nstatic u64 hisi_hha_pmu_read_counter(struct hisi_pmu *hha_pmu,\n\t\t\t\t     struct hw_perf_event *hwc)\n{\n\t \n\treturn readq(hha_pmu->base + hisi_hha_pmu_get_counter_offset(hwc->idx));\n}\n\nstatic void hisi_hha_pmu_write_counter(struct hisi_pmu *hha_pmu,\n\t\t\t\t       struct hw_perf_event *hwc, u64 val)\n{\n\t \n\twriteq(val, hha_pmu->base + hisi_hha_pmu_get_counter_offset(hwc->idx));\n}\n\nstatic void hisi_hha_pmu_write_evtype(struct hisi_pmu *hha_pmu, int idx,\n\t\t\t\t      u32 type)\n{\n\tu32 reg, reg_idx, shift, val;\n\n\t \n\treg = HHA_EVENT_TYPE0 + 4 * (idx / 4);\n\treg_idx = idx % 4;\n\tshift = 8 * reg_idx;\n\n\t \n\tval = readl(hha_pmu->base + reg);\n\tval &= ~(HHA_EVTYPE_NONE << shift);\n\tval |= (type << shift);\n\twritel(val, hha_pmu->base + reg);\n}\n\nstatic void hisi_hha_pmu_start_counters(struct hisi_pmu *hha_pmu)\n{\n\tu32 val;\n\n\t \n\tval = readl(hha_pmu->base + HHA_PERF_CTRL);\n\tval |= HHA_PERF_CTRL_EN;\n\twritel(val, hha_pmu->base + HHA_PERF_CTRL);\n}\n\nstatic void hisi_hha_pmu_stop_counters(struct hisi_pmu *hha_pmu)\n{\n\tu32 val;\n\n\t \n\tval = readl(hha_pmu->base + HHA_PERF_CTRL);\n\tval &= ~(HHA_PERF_CTRL_EN);\n\twritel(val, hha_pmu->base + HHA_PERF_CTRL);\n}\n\nstatic void hisi_hha_pmu_enable_counter(struct hisi_pmu *hha_pmu,\n\t\t\t\t\tstruct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(hha_pmu->base + HHA_EVENT_CTRL);\n\tval |= (1 << hwc->idx);\n\twritel(val, hha_pmu->base + HHA_EVENT_CTRL);\n}\n\nstatic void hisi_hha_pmu_disable_counter(struct hisi_pmu *hha_pmu,\n\t\t\t\t\t struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(hha_pmu->base + HHA_EVENT_CTRL);\n\tval &= ~(1 << hwc->idx);\n\twritel(val, hha_pmu->base + HHA_EVENT_CTRL);\n}\n\nstatic void hisi_hha_pmu_enable_counter_int(struct hisi_pmu *hha_pmu,\n\t\t\t\t\t    struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(hha_pmu->base + HHA_INT_MASK);\n\tval &= ~(1 << hwc->idx);\n\twritel(val, hha_pmu->base + HHA_INT_MASK);\n}\n\nstatic void hisi_hha_pmu_disable_counter_int(struct hisi_pmu *hha_pmu,\n\t\t\t\t\t     struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(hha_pmu->base + HHA_INT_MASK);\n\tval |= (1 << hwc->idx);\n\twritel(val, hha_pmu->base + HHA_INT_MASK);\n}\n\nstatic u32 hisi_hha_pmu_get_int_status(struct hisi_pmu *hha_pmu)\n{\n\treturn readl(hha_pmu->base + HHA_INT_STATUS);\n}\n\nstatic void hisi_hha_pmu_clear_int_status(struct hisi_pmu *hha_pmu, int idx)\n{\n\twritel(1 << idx, hha_pmu->base + HHA_INT_CLEAR);\n}\n\nstatic const struct acpi_device_id hisi_hha_pmu_acpi_match[] = {\n\t{ \"HISI0243\", },\n\t{ \"HISI0244\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, hisi_hha_pmu_acpi_match);\n\nstatic int hisi_hha_pmu_init_data(struct platform_device *pdev,\n\t\t\t\t  struct hisi_pmu *hha_pmu)\n{\n\tunsigned long long id;\n\tacpi_status status;\n\n\t \n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,scl-id\",\n\t\t\t\t     &hha_pmu->sccl_id)) {\n\t\tdev_err(&pdev->dev, \"Can not read hha sccl-id!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,idx-id\",\n\t\t\t\t     &hha_pmu->index_id)) {\n\t\tstatus = acpi_evaluate_integer(ACPI_HANDLE(&pdev->dev),\n\t\t\t\t\t       \"_UID\", NULL, &id);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tdev_err(&pdev->dev, \"Cannot read idx-id!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thha_pmu->index_id = id;\n\t}\n\t \n\thha_pmu->ccl_id = -1;\n\n\thha_pmu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hha_pmu->base)) {\n\t\tdev_err(&pdev->dev, \"ioremap failed for hha_pmu resource\\n\");\n\t\treturn PTR_ERR(hha_pmu->base);\n\t}\n\n\thha_pmu->identifier = readl(hha_pmu->base + HHA_VERSION);\n\n\treturn 0;\n}\n\nstatic struct attribute *hisi_hha_pmu_v1_format_attr[] = {\n\tHISI_PMU_FORMAT_ATTR(event, \"config:0-7\"),\n\tNULL,\n};\n\nstatic const struct attribute_group hisi_hha_pmu_v1_format_group = {\n\t.name = \"format\",\n\t.attrs = hisi_hha_pmu_v1_format_attr,\n};\n\nstatic struct attribute *hisi_hha_pmu_v2_format_attr[] = {\n\tHISI_PMU_FORMAT_ATTR(event, \"config:0-7\"),\n\tHISI_PMU_FORMAT_ATTR(srcid_cmd, \"config1:0-10\"),\n\tHISI_PMU_FORMAT_ATTR(srcid_msk, \"config1:11-21\"),\n\tHISI_PMU_FORMAT_ATTR(tracetag_en, \"config1:22\"),\n\tHISI_PMU_FORMAT_ATTR(datasrc_skt, \"config1:23\"),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_hha_pmu_v2_format_group = {\n\t.name = \"format\",\n\t.attrs = hisi_hha_pmu_v2_format_attr,\n};\n\nstatic struct attribute *hisi_hha_pmu_v1_events_attr[] = {\n\tHISI_PMU_EVENT_ATTR(rx_ops_num,\t\t0x00),\n\tHISI_PMU_EVENT_ATTR(rx_outer,\t\t0x01),\n\tHISI_PMU_EVENT_ATTR(rx_sccl,\t\t0x02),\n\tHISI_PMU_EVENT_ATTR(rx_ccix,\t\t0x03),\n\tHISI_PMU_EVENT_ATTR(rx_wbi,\t\t0x04),\n\tHISI_PMU_EVENT_ATTR(rx_wbip,\t\t0x05),\n\tHISI_PMU_EVENT_ATTR(rx_wtistash,\t0x11),\n\tHISI_PMU_EVENT_ATTR(rd_ddr_64b,\t\t0x1c),\n\tHISI_PMU_EVENT_ATTR(wr_ddr_64b,\t\t0x1d),\n\tHISI_PMU_EVENT_ATTR(rd_ddr_128b,\t0x1e),\n\tHISI_PMU_EVENT_ATTR(wr_ddr_128b,\t0x1f),\n\tHISI_PMU_EVENT_ATTR(spill_num,\t\t0x20),\n\tHISI_PMU_EVENT_ATTR(spill_success,\t0x21),\n\tHISI_PMU_EVENT_ATTR(bi_num,\t\t0x23),\n\tHISI_PMU_EVENT_ATTR(mediated_num,\t0x32),\n\tHISI_PMU_EVENT_ATTR(tx_snp_num,\t\t0x33),\n\tHISI_PMU_EVENT_ATTR(tx_snp_outer,\t0x34),\n\tHISI_PMU_EVENT_ATTR(tx_snp_ccix,\t0x35),\n\tHISI_PMU_EVENT_ATTR(rx_snprspdata,\t0x38),\n\tHISI_PMU_EVENT_ATTR(rx_snprsp_outer,\t0x3c),\n\tHISI_PMU_EVENT_ATTR(sdir-lookup,\t0x40),\n\tHISI_PMU_EVENT_ATTR(edir-lookup,\t0x41),\n\tHISI_PMU_EVENT_ATTR(sdir-hit,\t\t0x42),\n\tHISI_PMU_EVENT_ATTR(edir-hit,\t\t0x43),\n\tHISI_PMU_EVENT_ATTR(sdir-home-migrate,\t0x4c),\n\tHISI_PMU_EVENT_ATTR(edir-home-migrate,  0x4d),\n\tNULL,\n};\n\nstatic const struct attribute_group hisi_hha_pmu_v1_events_group = {\n\t.name = \"events\",\n\t.attrs = hisi_hha_pmu_v1_events_attr,\n};\n\nstatic struct attribute *hisi_hha_pmu_v2_events_attr[] = {\n\tHISI_PMU_EVENT_ATTR(rx_ops_num,\t\t0x00),\n\tHISI_PMU_EVENT_ATTR(rx_outer,\t\t0x01),\n\tHISI_PMU_EVENT_ATTR(rx_sccl,\t\t0x02),\n\tHISI_PMU_EVENT_ATTR(hha_retry,\t\t0x2e),\n\tHISI_PMU_EVENT_ATTR(cycles,\t\t0x55),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_hha_pmu_v2_events_group = {\n\t.name = \"events\",\n\t.attrs = hisi_hha_pmu_v2_events_attr,\n};\n\nstatic DEVICE_ATTR(cpumask, 0444, hisi_cpumask_sysfs_show, NULL);\n\nstatic struct attribute *hisi_hha_pmu_cpumask_attrs[] = {\n\t&dev_attr_cpumask.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group hisi_hha_pmu_cpumask_attr_group = {\n\t.attrs = hisi_hha_pmu_cpumask_attrs,\n};\n\nstatic struct device_attribute hisi_hha_pmu_identifier_attr =\n\t__ATTR(identifier, 0444, hisi_uncore_pmu_identifier_attr_show, NULL);\n\nstatic struct attribute *hisi_hha_pmu_identifier_attrs[] = {\n\t&hisi_hha_pmu_identifier_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hisi_hha_pmu_identifier_group = {\n\t.attrs = hisi_hha_pmu_identifier_attrs,\n};\n\nstatic const struct attribute_group *hisi_hha_pmu_v1_attr_groups[] = {\n\t&hisi_hha_pmu_v1_format_group,\n\t&hisi_hha_pmu_v1_events_group,\n\t&hisi_hha_pmu_cpumask_attr_group,\n\t&hisi_hha_pmu_identifier_group,\n\tNULL,\n};\n\nstatic const struct attribute_group *hisi_hha_pmu_v2_attr_groups[] = {\n\t&hisi_hha_pmu_v2_format_group,\n\t&hisi_hha_pmu_v2_events_group,\n\t&hisi_hha_pmu_cpumask_attr_group,\n\t&hisi_hha_pmu_identifier_group,\n\tNULL\n};\n\nstatic const struct hisi_uncore_ops hisi_uncore_hha_ops = {\n\t.write_evtype\t\t= hisi_hha_pmu_write_evtype,\n\t.get_event_idx\t\t= hisi_uncore_pmu_get_event_idx,\n\t.start_counters\t\t= hisi_hha_pmu_start_counters,\n\t.stop_counters\t\t= hisi_hha_pmu_stop_counters,\n\t.enable_counter\t\t= hisi_hha_pmu_enable_counter,\n\t.disable_counter\t= hisi_hha_pmu_disable_counter,\n\t.enable_counter_int\t= hisi_hha_pmu_enable_counter_int,\n\t.disable_counter_int\t= hisi_hha_pmu_disable_counter_int,\n\t.write_counter\t\t= hisi_hha_pmu_write_counter,\n\t.read_counter\t\t= hisi_hha_pmu_read_counter,\n\t.get_int_status\t\t= hisi_hha_pmu_get_int_status,\n\t.clear_int_status\t= hisi_hha_pmu_clear_int_status,\n\t.enable_filter\t\t= hisi_hha_pmu_enable_filter,\n\t.disable_filter\t\t= hisi_hha_pmu_disable_filter,\n};\n\nstatic int hisi_hha_pmu_dev_probe(struct platform_device *pdev,\n\t\t\t\t  struct hisi_pmu *hha_pmu)\n{\n\tint ret;\n\n\tret = hisi_hha_pmu_init_data(pdev, hha_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_uncore_pmu_init_irq(hha_pmu, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hha_pmu->identifier >= HISI_PMU_V2) {\n\t\thha_pmu->counter_bits = 64;\n\t\thha_pmu->check_event = HHA_V2_NR_EVENT;\n\t\thha_pmu->pmu_events.attr_groups = hisi_hha_pmu_v2_attr_groups;\n\t\thha_pmu->num_counters = HHA_V2_NR_COUNTERS;\n\t} else {\n\t\thha_pmu->counter_bits = 48;\n\t\thha_pmu->check_event = HHA_V1_NR_EVENT;\n\t\thha_pmu->pmu_events.attr_groups = hisi_hha_pmu_v1_attr_groups;\n\t\thha_pmu->num_counters = HHA_V1_NR_COUNTERS;\n\t}\n\thha_pmu->ops = &hisi_uncore_hha_ops;\n\thha_pmu->dev = &pdev->dev;\n\thha_pmu->on_cpu = -1;\n\n\treturn 0;\n}\n\nstatic int hisi_hha_pmu_probe(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *hha_pmu;\n\tchar *name;\n\tint ret;\n\n\thha_pmu = devm_kzalloc(&pdev->dev, sizeof(*hha_pmu), GFP_KERNEL);\n\tif (!hha_pmu)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, hha_pmu);\n\n\tret = hisi_hha_pmu_dev_probe(pdev, hha_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"hisi_sccl%u_hha%u\",\n\t\t\t      hha_pmu->sccl_id, hha_pmu->index_id);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = cpuhp_state_add_instance(CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE,\n\t\t\t\t       &hha_pmu->node);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error %d registering hotplug\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thisi_pmu_init(hha_pmu, THIS_MODULE);\n\n\tret = perf_pmu_register(&hha_pmu->pmu, name, -1);\n\tif (ret) {\n\t\tdev_err(hha_pmu->dev, \"HHA PMU register failed!\\n\");\n\t\tcpuhp_state_remove_instance_nocalls(\n\t\t\tCPUHP_AP_PERF_ARM_HISI_HHA_ONLINE, &hha_pmu->node);\n\t}\n\n\treturn ret;\n}\n\nstatic int hisi_hha_pmu_remove(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *hha_pmu = platform_get_drvdata(pdev);\n\n\tperf_pmu_unregister(&hha_pmu->pmu);\n\tcpuhp_state_remove_instance_nocalls(CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE,\n\t\t\t\t\t    &hha_pmu->node);\n\treturn 0;\n}\n\nstatic struct platform_driver hisi_hha_pmu_driver = {\n\t.driver = {\n\t\t.name = \"hisi_hha_pmu\",\n\t\t.acpi_match_table = ACPI_PTR(hisi_hha_pmu_acpi_match),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = hisi_hha_pmu_probe,\n\t.remove = hisi_hha_pmu_remove,\n};\n\nstatic int __init hisi_hha_pmu_module_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE,\n\t\t\t\t      \"AP_PERF_ARM_HISI_HHA_ONLINE\",\n\t\t\t\t      hisi_uncore_pmu_online_cpu,\n\t\t\t\t      hisi_uncore_pmu_offline_cpu);\n\tif (ret) {\n\t\tpr_err(\"HHA PMU: Error setup hotplug, ret = %d;\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&hisi_hha_pmu_driver);\n\tif (ret)\n\t\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE);\n\n\treturn ret;\n}\nmodule_init(hisi_hha_pmu_module_init);\n\nstatic void __exit hisi_hha_pmu_module_exit(void)\n{\n\tplatform_driver_unregister(&hisi_hha_pmu_driver);\n\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE);\n}\nmodule_exit(hisi_hha_pmu_module_exit);\n\nMODULE_DESCRIPTION(\"HiSilicon SoC HHA uncore PMU driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Shaokun Zhang <zhangshaokun@hisilicon.com>\");\nMODULE_AUTHOR(\"Anurup M <anurup.m@huawei.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}