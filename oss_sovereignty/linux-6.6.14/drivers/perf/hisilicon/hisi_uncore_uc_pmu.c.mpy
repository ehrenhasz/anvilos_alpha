{
  "module_name": "hisi_uncore_uc_pmu.c",
  "hash_id": "0a2bbe3565e2647fd46392e1b128c97a79352b21f84da209b27292b03d43033c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/hisilicon/hisi_uncore_uc_pmu.c",
  "human_readable_source": "\n \n#include <linux/cpuhotplug.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/list.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n\n#include \"hisi_uncore_pmu.h\"\n\n \nstatic enum cpuhp_state hisi_uc_pmu_online;\n\n \n#define HISI_UC_INT_MASK_REG\t\t0x0800\n#define HISI_UC_INT_STS_REG\t\t0x0808\n#define HISI_UC_INT_CLEAR_REG\t\t0x080c\n#define HISI_UC_TRACETAG_CTRL_REG\t0x1b2c\n#define HISI_UC_TRACETAG_REQ_MSK\tGENMASK(9, 7)\n#define HISI_UC_TRACETAG_MARK_EN\tBIT(0)\n#define HISI_UC_TRACETAG_REQ_EN\t\t(HISI_UC_TRACETAG_MARK_EN | BIT(2))\n#define HISI_UC_TRACETAG_SRCID_EN\tBIT(3)\n#define HISI_UC_SRCID_CTRL_REG\t\t0x1b40\n#define HISI_UC_SRCID_MSK\t\tGENMASK(14, 1)\n#define HISI_UC_EVENT_CTRL_REG\t\t0x1c00\n#define HISI_UC_EVENT_TRACETAG_EN\tBIT(29)\n#define HISI_UC_EVENT_URING_MSK\t\tGENMASK(28, 27)\n#define HISI_UC_EVENT_GLB_EN\t\tBIT(26)\n#define HISI_UC_VERSION_REG\t\t0x1cf0\n#define HISI_UC_EVTYPE_REGn(n)\t\t(0x1d00 + (n) * 4)\n#define HISI_UC_EVTYPE_MASK\t\tGENMASK(7, 0)\n#define HISI_UC_CNTR_REGn(n)\t\t(0x1e00 + (n) * 8)\n\n#define HISI_UC_NR_COUNTERS\t\t0x8\n#define HISI_UC_V2_NR_EVENTS\t\t0xFF\n#define HISI_UC_CNTR_REG_BITS\t\t64\n\n#define HISI_UC_RD_REQ_TRACETAG\t\t0x4\n#define HISI_UC_URING_EVENT_MIN\t\t0x47\n#define HISI_UC_URING_EVENT_MAX\t\t0x59\n\nHISI_PMU_EVENT_ATTR_EXTRACTOR(rd_req_en, config1, 0, 0);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(uring_channel, config1, 5, 4);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(srcid, config1, 19, 6);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(srcid_en, config1, 20, 20);\n\nstatic int hisi_uc_pmu_check_filter(struct perf_event *event)\n{\n\tstruct hisi_pmu *uc_pmu = to_hisi_pmu(event->pmu);\n\n\tif (hisi_get_srcid_en(event) && !hisi_get_rd_req_en(event)) {\n\t\tdev_err(uc_pmu->dev,\n\t\t\t\"rcid_en depends on rd_req_en being enabled!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hisi_get_uring_channel(event))\n\t\treturn 0;\n\n\tif ((HISI_GET_EVENTID(event) < HISI_UC_URING_EVENT_MIN) ||\n\t    (HISI_GET_EVENTID(event) > HISI_UC_URING_EVENT_MAX))\n\t\tdev_warn(uc_pmu->dev,\n\t\t\t \"Only events: [%#x ~ %#x] support channel filtering!\",\n\t\t\t HISI_UC_URING_EVENT_MIN, HISI_UC_URING_EVENT_MAX);\n\n\treturn 0;\n}\n\nstatic void hisi_uc_pmu_config_req_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *uc_pmu = to_hisi_pmu(event->pmu);\n\tu32 val;\n\n\tif (!hisi_get_rd_req_en(event))\n\t\treturn;\n\n\tval = readl(uc_pmu->base + HISI_UC_TRACETAG_CTRL_REG);\n\n\t \n\tif (FIELD_GET(HISI_UC_TRACETAG_REQ_MSK, val) == HISI_UC_RD_REQ_TRACETAG)\n\t\treturn;\n\n\t \n\tval &= ~HISI_UC_TRACETAG_REQ_MSK;\n\tval |= FIELD_PREP(HISI_UC_TRACETAG_REQ_MSK, HISI_UC_RD_REQ_TRACETAG);\n\tval |= HISI_UC_TRACETAG_REQ_EN;\n\twritel(val, uc_pmu->base + HISI_UC_TRACETAG_CTRL_REG);\n}\n\nstatic void hisi_uc_pmu_clear_req_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *uc_pmu = to_hisi_pmu(event->pmu);\n\tu32 val;\n\n\tif (!hisi_get_rd_req_en(event))\n\t\treturn;\n\n\tval = readl(uc_pmu->base + HISI_UC_TRACETAG_CTRL_REG);\n\n\t \n\tif (FIELD_GET(HISI_UC_TRACETAG_REQ_MSK, val) == 0)\n\t\treturn;\n\n\t \n\tval &= ~HISI_UC_TRACETAG_REQ_MSK;\n\tval &= ~HISI_UC_TRACETAG_REQ_EN;\n\twritel(val, uc_pmu->base + HISI_UC_TRACETAG_CTRL_REG);\n}\n\nstatic void hisi_uc_pmu_config_srcid_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *uc_pmu = to_hisi_pmu(event->pmu);\n\tu32 val;\n\n\tif (!hisi_get_srcid_en(event))\n\t\treturn;\n\n\tval = readl(uc_pmu->base + HISI_UC_TRACETAG_CTRL_REG);\n\n\t \n\tif (FIELD_GET(HISI_UC_TRACETAG_SRCID_EN, val))\n\t\treturn;\n\n\t \n\tval |= HISI_UC_TRACETAG_SRCID_EN;\n\twritel(val, uc_pmu->base + HISI_UC_TRACETAG_CTRL_REG);\n\n\tval = readl(uc_pmu->base + HISI_UC_SRCID_CTRL_REG);\n\tval &= ~HISI_UC_SRCID_MSK;\n\tval |= FIELD_PREP(HISI_UC_SRCID_MSK, hisi_get_srcid(event));\n\twritel(val, uc_pmu->base + HISI_UC_SRCID_CTRL_REG);\n\n\t \n\thisi_uc_pmu_config_req_tracetag(event);\n}\n\nstatic void hisi_uc_pmu_clear_srcid_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *uc_pmu = to_hisi_pmu(event->pmu);\n\tu32 val;\n\n\tif (!hisi_get_srcid_en(event))\n\t\treturn;\n\n\tval = readl(uc_pmu->base + HISI_UC_TRACETAG_CTRL_REG);\n\n\t \n\tif (FIELD_GET(HISI_UC_TRACETAG_SRCID_EN, val) == 0)\n\t\treturn;\n\n\thisi_uc_pmu_clear_req_tracetag(event);\n\n\t \n\tval &= ~HISI_UC_TRACETAG_SRCID_EN;\n\twritel(val, uc_pmu->base + HISI_UC_TRACETAG_CTRL_REG);\n\n\tval = readl(uc_pmu->base + HISI_UC_SRCID_CTRL_REG);\n\tval &= ~HISI_UC_SRCID_MSK;\n\twritel(val, uc_pmu->base + HISI_UC_SRCID_CTRL_REG);\n}\n\nstatic void hisi_uc_pmu_config_uring_channel(struct perf_event *event)\n{\n\tstruct hisi_pmu *uc_pmu = to_hisi_pmu(event->pmu);\n\tu32 uring_channel = hisi_get_uring_channel(event);\n\tu32 val;\n\n\t \n\tif (uring_channel == 0)\n\t\treturn;\n\n\tval = readl(uc_pmu->base + HISI_UC_EVENT_CTRL_REG);\n\n\t \n\tif (uring_channel == FIELD_GET(HISI_UC_EVENT_URING_MSK, val))\n\t\treturn;\n\n\tval &= ~HISI_UC_EVENT_URING_MSK;\n\tval |= FIELD_PREP(HISI_UC_EVENT_URING_MSK, uring_channel);\n\twritel(val, uc_pmu->base + HISI_UC_EVENT_CTRL_REG);\n}\n\nstatic void hisi_uc_pmu_clear_uring_channel(struct perf_event *event)\n{\n\tstruct hisi_pmu *uc_pmu = to_hisi_pmu(event->pmu);\n\tu32 val;\n\n\t \n\tif (hisi_get_uring_channel(event) == 0)\n\t\treturn;\n\n\tval = readl(uc_pmu->base + HISI_UC_EVENT_CTRL_REG);\n\n\t \n\tif (FIELD_GET(HISI_UC_EVENT_URING_MSK, val) == 0)\n\t\treturn;\n\n\tval &= ~HISI_UC_EVENT_URING_MSK;\n\twritel(val, uc_pmu->base + HISI_UC_EVENT_CTRL_REG);\n}\n\nstatic void hisi_uc_pmu_enable_filter(struct perf_event *event)\n{\n\tif (event->attr.config1 == 0)\n\t\treturn;\n\n\thisi_uc_pmu_config_uring_channel(event);\n\thisi_uc_pmu_config_req_tracetag(event);\n\thisi_uc_pmu_config_srcid_tracetag(event);\n}\n\nstatic void hisi_uc_pmu_disable_filter(struct perf_event *event)\n{\n\tif (event->attr.config1 == 0)\n\t\treturn;\n\n\thisi_uc_pmu_clear_srcid_tracetag(event);\n\thisi_uc_pmu_clear_req_tracetag(event);\n\thisi_uc_pmu_clear_uring_channel(event);\n}\n\nstatic void hisi_uc_pmu_write_evtype(struct hisi_pmu *uc_pmu, int idx, u32 type)\n{\n\tu32 val;\n\n\t \n\tval = readl(uc_pmu->base + HISI_UC_EVTYPE_REGn(idx / 4));\n\tval &= ~(HISI_UC_EVTYPE_MASK << HISI_PMU_EVTYPE_SHIFT(idx));\n\tval |= (type << HISI_PMU_EVTYPE_SHIFT(idx));\n\twritel(val, uc_pmu->base + HISI_UC_EVTYPE_REGn(idx / 4));\n}\n\nstatic void hisi_uc_pmu_start_counters(struct hisi_pmu *uc_pmu)\n{\n\tu32 val;\n\n\tval = readl(uc_pmu->base + HISI_UC_EVENT_CTRL_REG);\n\tval |= HISI_UC_EVENT_GLB_EN;\n\twritel(val, uc_pmu->base + HISI_UC_EVENT_CTRL_REG);\n}\n\nstatic void hisi_uc_pmu_stop_counters(struct hisi_pmu *uc_pmu)\n{\n\tu32 val;\n\n\tval = readl(uc_pmu->base + HISI_UC_EVENT_CTRL_REG);\n\tval &= ~HISI_UC_EVENT_GLB_EN;\n\twritel(val, uc_pmu->base + HISI_UC_EVENT_CTRL_REG);\n}\n\nstatic void hisi_uc_pmu_enable_counter(struct hisi_pmu *uc_pmu,\n\t\t\t\t\tstruct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(uc_pmu->base + HISI_UC_EVENT_CTRL_REG);\n\tval |= (1 << hwc->idx);\n\twritel(val, uc_pmu->base + HISI_UC_EVENT_CTRL_REG);\n}\n\nstatic void hisi_uc_pmu_disable_counter(struct hisi_pmu *uc_pmu,\n\t\t\t\t\tstruct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(uc_pmu->base + HISI_UC_EVENT_CTRL_REG);\n\tval &= ~(1 << hwc->idx);\n\twritel(val, uc_pmu->base + HISI_UC_EVENT_CTRL_REG);\n}\n\nstatic u64 hisi_uc_pmu_read_counter(struct hisi_pmu *uc_pmu,\n\t\t\t\t    struct hw_perf_event *hwc)\n{\n\treturn readq(uc_pmu->base + HISI_UC_CNTR_REGn(hwc->idx));\n}\n\nstatic void hisi_uc_pmu_write_counter(struct hisi_pmu *uc_pmu,\n\t\t\t\t      struct hw_perf_event *hwc, u64 val)\n{\n\twriteq(val, uc_pmu->base + HISI_UC_CNTR_REGn(hwc->idx));\n}\n\nstatic void hisi_uc_pmu_enable_counter_int(struct hisi_pmu *uc_pmu,\n\t\t\t\t\t   struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\tval = readl(uc_pmu->base + HISI_UC_INT_MASK_REG);\n\tval &= ~(1 << hwc->idx);\n\twritel(val, uc_pmu->base + HISI_UC_INT_MASK_REG);\n}\n\nstatic void hisi_uc_pmu_disable_counter_int(struct hisi_pmu *uc_pmu,\n\t\t\t\t\t    struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\tval = readl(uc_pmu->base + HISI_UC_INT_MASK_REG);\n\tval |= (1 << hwc->idx);\n\twritel(val, uc_pmu->base + HISI_UC_INT_MASK_REG);\n}\n\nstatic u32 hisi_uc_pmu_get_int_status(struct hisi_pmu *uc_pmu)\n{\n\treturn readl(uc_pmu->base + HISI_UC_INT_STS_REG);\n}\n\nstatic void hisi_uc_pmu_clear_int_status(struct hisi_pmu *uc_pmu, int idx)\n{\n\twritel(1 << idx, uc_pmu->base + HISI_UC_INT_CLEAR_REG);\n}\n\nstatic int hisi_uc_pmu_init_data(struct platform_device *pdev,\n\t\t\t\t struct hisi_pmu *uc_pmu)\n{\n\t \n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,scl-id\",\n\t\t\t\t     &uc_pmu->sccl_id)) {\n\t\tdev_err(&pdev->dev, \"Can not read uc sccl-id!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,ccl-id\",\n\t\t\t\t     &uc_pmu->ccl_id)) {\n\t\tdev_err(&pdev->dev, \"Can not read uc ccl-id!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,sub-id\",\n\t\t\t\t     &uc_pmu->sub_id)) {\n\t\tdev_err(&pdev->dev, \"Can not read sub-id!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tuc_pmu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(uc_pmu->base)) {\n\t\tdev_err(&pdev->dev, \"ioremap failed for uc_pmu resource\\n\");\n\t\treturn PTR_ERR(uc_pmu->base);\n\t}\n\n\tuc_pmu->identifier = readl(uc_pmu->base + HISI_UC_VERSION_REG);\n\n\treturn 0;\n}\n\nstatic struct attribute *hisi_uc_pmu_format_attr[] = {\n\tHISI_PMU_FORMAT_ATTR(event, \"config:0-7\"),\n\tHISI_PMU_FORMAT_ATTR(rd_req_en, \"config1:0-0\"),\n\tHISI_PMU_FORMAT_ATTR(uring_channel, \"config1:4-5\"),\n\tHISI_PMU_FORMAT_ATTR(srcid, \"config1:6-19\"),\n\tHISI_PMU_FORMAT_ATTR(srcid_en, \"config1:20-20\"),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_uc_pmu_format_group = {\n\t.name = \"format\",\n\t.attrs = hisi_uc_pmu_format_attr,\n};\n\nstatic struct attribute *hisi_uc_pmu_events_attr[] = {\n\tHISI_PMU_EVENT_ATTR(sq_time,\t\t0x00),\n\tHISI_PMU_EVENT_ATTR(pq_time,\t\t0x01),\n\tHISI_PMU_EVENT_ATTR(hbm_time,\t\t0x02),\n\tHISI_PMU_EVENT_ATTR(iq_comp_time_cring,\t0x03),\n\tHISI_PMU_EVENT_ATTR(iq_comp_time_uring,\t0x05),\n\tHISI_PMU_EVENT_ATTR(cpu_rd,\t\t0x10),\n\tHISI_PMU_EVENT_ATTR(cpu_rd64,\t\t0x17),\n\tHISI_PMU_EVENT_ATTR(cpu_rs64,\t\t0x19),\n\tHISI_PMU_EVENT_ATTR(cpu_mru,\t\t0x1c),\n\tHISI_PMU_EVENT_ATTR(cycles,\t\t0x95),\n\tHISI_PMU_EVENT_ATTR(spipe_hit,\t\t0xb3),\n\tHISI_PMU_EVENT_ATTR(hpipe_hit,\t\t0xdb),\n\tHISI_PMU_EVENT_ATTR(cring_rxdat_cnt,\t0xfa),\n\tHISI_PMU_EVENT_ATTR(cring_txdat_cnt,\t0xfb),\n\tHISI_PMU_EVENT_ATTR(uring_rxdat_cnt,\t0xfc),\n\tHISI_PMU_EVENT_ATTR(uring_txdat_cnt,\t0xfd),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_uc_pmu_events_group = {\n\t.name = \"events\",\n\t.attrs = hisi_uc_pmu_events_attr,\n};\n\nstatic DEVICE_ATTR(cpumask, 0444, hisi_cpumask_sysfs_show, NULL);\n\nstatic struct attribute *hisi_uc_pmu_cpumask_attrs[] = {\n\t&dev_attr_cpumask.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group hisi_uc_pmu_cpumask_attr_group = {\n\t.attrs = hisi_uc_pmu_cpumask_attrs,\n};\n\nstatic struct device_attribute hisi_uc_pmu_identifier_attr =\n\t__ATTR(identifier, 0444, hisi_uncore_pmu_identifier_attr_show, NULL);\n\nstatic struct attribute *hisi_uc_pmu_identifier_attrs[] = {\n\t&hisi_uc_pmu_identifier_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hisi_uc_pmu_identifier_group = {\n\t.attrs = hisi_uc_pmu_identifier_attrs,\n};\n\nstatic const struct attribute_group *hisi_uc_pmu_attr_groups[] = {\n\t&hisi_uc_pmu_format_group,\n\t&hisi_uc_pmu_events_group,\n\t&hisi_uc_pmu_cpumask_attr_group,\n\t&hisi_uc_pmu_identifier_group,\n\tNULL\n};\n\nstatic const struct hisi_uncore_ops hisi_uncore_uc_pmu_ops = {\n\t.check_filter\t\t= hisi_uc_pmu_check_filter,\n\t.write_evtype\t\t= hisi_uc_pmu_write_evtype,\n\t.get_event_idx\t\t= hisi_uncore_pmu_get_event_idx,\n\t.start_counters\t\t= hisi_uc_pmu_start_counters,\n\t.stop_counters\t\t= hisi_uc_pmu_stop_counters,\n\t.enable_counter\t\t= hisi_uc_pmu_enable_counter,\n\t.disable_counter\t= hisi_uc_pmu_disable_counter,\n\t.enable_counter_int\t= hisi_uc_pmu_enable_counter_int,\n\t.disable_counter_int\t= hisi_uc_pmu_disable_counter_int,\n\t.write_counter\t\t= hisi_uc_pmu_write_counter,\n\t.read_counter\t\t= hisi_uc_pmu_read_counter,\n\t.get_int_status\t\t= hisi_uc_pmu_get_int_status,\n\t.clear_int_status\t= hisi_uc_pmu_clear_int_status,\n\t.enable_filter\t\t= hisi_uc_pmu_enable_filter,\n\t.disable_filter\t\t= hisi_uc_pmu_disable_filter,\n};\n\nstatic int hisi_uc_pmu_dev_probe(struct platform_device *pdev,\n\t\t\t\t struct hisi_pmu *uc_pmu)\n{\n\tint ret;\n\n\tret = hisi_uc_pmu_init_data(pdev, uc_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_uncore_pmu_init_irq(uc_pmu, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tuc_pmu->pmu_events.attr_groups = hisi_uc_pmu_attr_groups;\n\tuc_pmu->check_event = HISI_UC_EVTYPE_MASK;\n\tuc_pmu->ops = &hisi_uncore_uc_pmu_ops;\n\tuc_pmu->counter_bits = HISI_UC_CNTR_REG_BITS;\n\tuc_pmu->num_counters = HISI_UC_NR_COUNTERS;\n\tuc_pmu->dev = &pdev->dev;\n\tuc_pmu->on_cpu = -1;\n\n\treturn 0;\n}\n\nstatic void hisi_uc_pmu_remove_cpuhp_instance(void *hotplug_node)\n{\n\tcpuhp_state_remove_instance_nocalls(hisi_uc_pmu_online, hotplug_node);\n}\n\nstatic void hisi_uc_pmu_unregister_pmu(void *pmu)\n{\n\tperf_pmu_unregister(pmu);\n}\n\nstatic int hisi_uc_pmu_probe(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *uc_pmu;\n\tchar *name;\n\tint ret;\n\n\tuc_pmu = devm_kzalloc(&pdev->dev, sizeof(*uc_pmu), GFP_KERNEL);\n\tif (!uc_pmu)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, uc_pmu);\n\n\tret = hisi_uc_pmu_dev_probe(pdev, uc_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"hisi_sccl%d_uc%d_%u\",\n\t\t\t      uc_pmu->sccl_id, uc_pmu->ccl_id, uc_pmu->sub_id);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = cpuhp_state_add_instance(hisi_uc_pmu_online, &uc_pmu->node);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Error registering hotplug\\n\");\n\n\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       hisi_uc_pmu_remove_cpuhp_instance,\n\t\t\t\t       &uc_pmu->node);\n\tif (ret)\n\t\treturn ret;\n\n\thisi_pmu_init(uc_pmu, THIS_MODULE);\n\n\tret = perf_pmu_register(&uc_pmu->pmu, name, -1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t\thisi_uc_pmu_unregister_pmu,\n\t\t\t\t\t&uc_pmu->pmu);\n}\n\nstatic const struct acpi_device_id hisi_uc_pmu_acpi_match[] = {\n\t{ \"HISI0291\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, hisi_uc_pmu_acpi_match);\n\nstatic struct platform_driver hisi_uc_pmu_driver = {\n\t.driver = {\n\t\t.name = \"hisi_uc_pmu\",\n\t\t.acpi_match_table = hisi_uc_pmu_acpi_match,\n\t\t \n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = hisi_uc_pmu_probe,\n};\n\nstatic int __init hisi_uc_pmu_module_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t      \"perf/hisi/uc:online\",\n\t\t\t\t      hisi_uncore_pmu_online_cpu,\n\t\t\t\t      hisi_uncore_pmu_offline_cpu);\n\tif (ret < 0) {\n\t\tpr_err(\"UC PMU: Error setup hotplug, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\thisi_uc_pmu_online = ret;\n\n\tret = platform_driver_register(&hisi_uc_pmu_driver);\n\tif (ret)\n\t\tcpuhp_remove_multi_state(hisi_uc_pmu_online);\n\n\treturn ret;\n}\nmodule_init(hisi_uc_pmu_module_init);\n\nstatic void __exit hisi_uc_pmu_module_exit(void)\n{\n\tplatform_driver_unregister(&hisi_uc_pmu_driver);\n\tcpuhp_remove_multi_state(hisi_uc_pmu_online);\n}\nmodule_exit(hisi_uc_pmu_module_exit);\n\nMODULE_DESCRIPTION(\"HiSilicon SoC UC uncore PMU driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Junhao He <hejunhao3@huawei.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}