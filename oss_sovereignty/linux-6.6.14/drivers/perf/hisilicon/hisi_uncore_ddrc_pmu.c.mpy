{
  "module_name": "hisi_uncore_ddrc_pmu.c",
  "hash_id": "92330ff37abf6fd571d16fb5c3276774b664df06d8c941d500f26bc415579fc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/hisilicon/hisi_uncore_ddrc_pmu.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/bug.h>\n#include <linux/cpuhotplug.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/list.h>\n#include <linux/smp.h>\n\n#include \"hisi_uncore_pmu.h\"\n\n \n#define DDRC_PERF_CTRL\t\t0x010\n#define DDRC_FLUX_WR\t\t0x380\n#define DDRC_FLUX_RD\t\t0x384\n#define DDRC_FLUX_WCMD          0x388\n#define DDRC_FLUX_RCMD          0x38c\n#define DDRC_PRE_CMD            0x3c0\n#define DDRC_ACT_CMD            0x3c4\n#define DDRC_RNK_CHG            0x3cc\n#define DDRC_RW_CHG             0x3d0\n#define DDRC_EVENT_CTRL         0x6C0\n#define DDRC_INT_MASK\t\t0x6c8\n#define DDRC_INT_STATUS\t\t0x6cc\n#define DDRC_INT_CLEAR\t\t0x6d0\n#define DDRC_VERSION\t\t0x710\n\n \n#define DDRC_V2_INT_MASK\t0x528\n#define DDRC_V2_INT_STATUS\t0x52c\n#define DDRC_V2_INT_CLEAR\t0x530\n#define DDRC_V2_EVENT_CNT\t0xe00\n#define DDRC_V2_EVENT_CTRL\t0xe70\n#define DDRC_V2_EVENT_TYPE\t0xe74\n#define DDRC_V2_PERF_CTRL\t0xeA0\n\n \n#define DDRC_NR_COUNTERS\t0x8\n#define DDRC_V1_PERF_CTRL_EN\t0x2\n#define DDRC_V2_PERF_CTRL_EN\t0x1\n#define DDRC_V1_NR_EVENTS\t0x7\n#define DDRC_V2_NR_EVENTS\t0x90\n\n \n#define GET_DDRC_EVENTID(hwc)\t(hwc->config_base & 0x7)\n\nstatic const u32 ddrc_reg_off[] = {\n\tDDRC_FLUX_WR, DDRC_FLUX_RD, DDRC_FLUX_WCMD, DDRC_FLUX_RCMD,\n\tDDRC_PRE_CMD, DDRC_ACT_CMD, DDRC_RNK_CHG, DDRC_RW_CHG\n};\n\n \nstatic u32 hisi_ddrc_pmu_v1_get_counter_offset(int cntr_idx)\n{\n\treturn ddrc_reg_off[cntr_idx];\n}\n\nstatic u32 hisi_ddrc_pmu_v2_get_counter_offset(int cntr_idx)\n{\n\treturn DDRC_V2_EVENT_CNT + cntr_idx * 8;\n}\n\nstatic u64 hisi_ddrc_pmu_v1_read_counter(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t      struct hw_perf_event *hwc)\n{\n\treturn readl(ddrc_pmu->base +\n\t\t     hisi_ddrc_pmu_v1_get_counter_offset(hwc->idx));\n}\n\nstatic void hisi_ddrc_pmu_v1_write_counter(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\tstruct hw_perf_event *hwc, u64 val)\n{\n\twritel((u32)val,\n\t       ddrc_pmu->base + hisi_ddrc_pmu_v1_get_counter_offset(hwc->idx));\n}\n\nstatic u64 hisi_ddrc_pmu_v2_read_counter(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\t struct hw_perf_event *hwc)\n{\n\treturn readq(ddrc_pmu->base +\n\t\t     hisi_ddrc_pmu_v2_get_counter_offset(hwc->idx));\n}\n\nstatic void hisi_ddrc_pmu_v2_write_counter(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\t   struct hw_perf_event *hwc, u64 val)\n{\n\twriteq(val,\n\t       ddrc_pmu->base + hisi_ddrc_pmu_v2_get_counter_offset(hwc->idx));\n}\n\n \nstatic void hisi_ddrc_pmu_write_evtype(struct hisi_pmu *hha_pmu, int idx,\n\t\t\t\t       u32 type)\n{\n\tu32 offset;\n\n\tif (hha_pmu->identifier >= HISI_PMU_V2) {\n\t\toffset = DDRC_V2_EVENT_TYPE + 4 * idx;\n\t\twritel(type, hha_pmu->base + offset);\n\t}\n}\n\nstatic void hisi_ddrc_pmu_v1_start_counters(struct hisi_pmu *ddrc_pmu)\n{\n\tu32 val;\n\n\t \n\tval = readl(ddrc_pmu->base + DDRC_PERF_CTRL);\n\tval |= DDRC_V1_PERF_CTRL_EN;\n\twritel(val, ddrc_pmu->base + DDRC_PERF_CTRL);\n}\n\nstatic void hisi_ddrc_pmu_v1_stop_counters(struct hisi_pmu *ddrc_pmu)\n{\n\tu32 val;\n\n\t \n\tval = readl(ddrc_pmu->base + DDRC_PERF_CTRL);\n\tval &= ~DDRC_V1_PERF_CTRL_EN;\n\twritel(val, ddrc_pmu->base + DDRC_PERF_CTRL);\n}\n\nstatic void hisi_ddrc_pmu_v1_enable_counter(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\t    struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(ddrc_pmu->base + DDRC_EVENT_CTRL);\n\tval |= (1 << GET_DDRC_EVENTID(hwc));\n\twritel(val, ddrc_pmu->base + DDRC_EVENT_CTRL);\n}\n\nstatic void hisi_ddrc_pmu_v1_disable_counter(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\t     struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(ddrc_pmu->base + DDRC_EVENT_CTRL);\n\tval &= ~(1 << GET_DDRC_EVENTID(hwc));\n\twritel(val, ddrc_pmu->base + DDRC_EVENT_CTRL);\n}\n\nstatic int hisi_ddrc_pmu_v1_get_event_idx(struct perf_event *event)\n{\n\tstruct hisi_pmu *ddrc_pmu = to_hisi_pmu(event->pmu);\n\tunsigned long *used_mask = ddrc_pmu->pmu_events.used_mask;\n\tstruct hw_perf_event *hwc = &event->hw;\n\t \n\tint idx = GET_DDRC_EVENTID(hwc);\n\n\tif (test_bit(idx, used_mask))\n\t\treturn -EAGAIN;\n\n\tset_bit(idx, used_mask);\n\n\treturn idx;\n}\n\nstatic int hisi_ddrc_pmu_v2_get_event_idx(struct perf_event *event)\n{\n\treturn hisi_uncore_pmu_get_event_idx(event);\n}\n\nstatic void hisi_ddrc_pmu_v2_start_counters(struct hisi_pmu *ddrc_pmu)\n{\n\tu32 val;\n\n\tval = readl(ddrc_pmu->base + DDRC_V2_PERF_CTRL);\n\tval |= DDRC_V2_PERF_CTRL_EN;\n\twritel(val, ddrc_pmu->base + DDRC_V2_PERF_CTRL);\n}\n\nstatic void hisi_ddrc_pmu_v2_stop_counters(struct hisi_pmu *ddrc_pmu)\n{\n\tu32 val;\n\n\tval = readl(ddrc_pmu->base + DDRC_V2_PERF_CTRL);\n\tval &= ~DDRC_V2_PERF_CTRL_EN;\n\twritel(val, ddrc_pmu->base + DDRC_V2_PERF_CTRL);\n}\n\nstatic void hisi_ddrc_pmu_v2_enable_counter(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\t    struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\tval = readl(ddrc_pmu->base + DDRC_V2_EVENT_CTRL);\n\tval |= 1 << hwc->idx;\n\twritel(val, ddrc_pmu->base + DDRC_V2_EVENT_CTRL);\n}\n\nstatic void hisi_ddrc_pmu_v2_disable_counter(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\t     struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\tval = readl(ddrc_pmu->base + DDRC_V2_EVENT_CTRL);\n\tval &= ~(1 << hwc->idx);\n\twritel(val, ddrc_pmu->base + DDRC_V2_EVENT_CTRL);\n}\n\nstatic void hisi_ddrc_pmu_v1_enable_counter_int(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\t\tstruct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(ddrc_pmu->base + DDRC_INT_MASK);\n\tval &= ~(1 << hwc->idx);\n\twritel(val, ddrc_pmu->base + DDRC_INT_MASK);\n}\n\nstatic void hisi_ddrc_pmu_v1_disable_counter_int(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\t\t struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(ddrc_pmu->base + DDRC_INT_MASK);\n\tval |= 1 << hwc->idx;\n\twritel(val, ddrc_pmu->base + DDRC_INT_MASK);\n}\n\nstatic void hisi_ddrc_pmu_v2_enable_counter_int(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\t\tstruct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\tval = readl(ddrc_pmu->base + DDRC_V2_INT_MASK);\n\tval &= ~(1 << hwc->idx);\n\twritel(val, ddrc_pmu->base + DDRC_V2_INT_MASK);\n}\n\nstatic void hisi_ddrc_pmu_v2_disable_counter_int(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\t\tstruct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\tval = readl(ddrc_pmu->base + DDRC_V2_INT_MASK);\n\tval |= 1 << hwc->idx;\n\twritel(val, ddrc_pmu->base + DDRC_V2_INT_MASK);\n}\n\nstatic u32 hisi_ddrc_pmu_v1_get_int_status(struct hisi_pmu *ddrc_pmu)\n{\n\treturn readl(ddrc_pmu->base + DDRC_INT_STATUS);\n}\n\nstatic void hisi_ddrc_pmu_v1_clear_int_status(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\t      int idx)\n{\n\twritel(1 << idx, ddrc_pmu->base + DDRC_INT_CLEAR);\n}\n\nstatic u32 hisi_ddrc_pmu_v2_get_int_status(struct hisi_pmu *ddrc_pmu)\n{\n\treturn readl(ddrc_pmu->base + DDRC_V2_INT_STATUS);\n}\n\nstatic void hisi_ddrc_pmu_v2_clear_int_status(struct hisi_pmu *ddrc_pmu,\n\t\t\t\t\t      int idx)\n{\n\twritel(1 << idx, ddrc_pmu->base + DDRC_V2_INT_CLEAR);\n}\n\nstatic const struct acpi_device_id hisi_ddrc_pmu_acpi_match[] = {\n\t{ \"HISI0233\", },\n\t{ \"HISI0234\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, hisi_ddrc_pmu_acpi_match);\n\nstatic int hisi_ddrc_pmu_init_data(struct platform_device *pdev,\n\t\t\t\t   struct hisi_pmu *ddrc_pmu)\n{\n\t \n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,ch-id\",\n\t\t\t\t     &ddrc_pmu->index_id)) {\n\t\tdev_err(&pdev->dev, \"Can not read ddrc channel-id!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,scl-id\",\n\t\t\t\t     &ddrc_pmu->sccl_id)) {\n\t\tdev_err(&pdev->dev, \"Can not read ddrc sccl-id!\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tddrc_pmu->ccl_id = -1;\n\n\tddrc_pmu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ddrc_pmu->base)) {\n\t\tdev_err(&pdev->dev, \"ioremap failed for ddrc_pmu resource\\n\");\n\t\treturn PTR_ERR(ddrc_pmu->base);\n\t}\n\n\tddrc_pmu->identifier = readl(ddrc_pmu->base + DDRC_VERSION);\n\tif (ddrc_pmu->identifier >= HISI_PMU_V2) {\n\t\tif (device_property_read_u32(&pdev->dev, \"hisilicon,sub-id\",\n\t\t\t\t\t     &ddrc_pmu->sub_id)) {\n\t\t\tdev_err(&pdev->dev, \"Can not read sub-id!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct attribute *hisi_ddrc_pmu_v1_format_attr[] = {\n\tHISI_PMU_FORMAT_ATTR(event, \"config:0-4\"),\n\tNULL,\n};\n\nstatic const struct attribute_group hisi_ddrc_pmu_v1_format_group = {\n\t.name = \"format\",\n\t.attrs = hisi_ddrc_pmu_v1_format_attr,\n};\n\nstatic struct attribute *hisi_ddrc_pmu_v2_format_attr[] = {\n\tHISI_PMU_FORMAT_ATTR(event, \"config:0-7\"),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_ddrc_pmu_v2_format_group = {\n\t.name = \"format\",\n\t.attrs = hisi_ddrc_pmu_v2_format_attr,\n};\n\nstatic struct attribute *hisi_ddrc_pmu_v1_events_attr[] = {\n\tHISI_PMU_EVENT_ATTR(flux_wr,\t\t0x00),\n\tHISI_PMU_EVENT_ATTR(flux_rd,\t\t0x01),\n\tHISI_PMU_EVENT_ATTR(flux_wcmd,\t\t0x02),\n\tHISI_PMU_EVENT_ATTR(flux_rcmd,\t\t0x03),\n\tHISI_PMU_EVENT_ATTR(pre_cmd,\t\t0x04),\n\tHISI_PMU_EVENT_ATTR(act_cmd,\t\t0x05),\n\tHISI_PMU_EVENT_ATTR(rnk_chg,\t\t0x06),\n\tHISI_PMU_EVENT_ATTR(rw_chg,\t\t0x07),\n\tNULL,\n};\n\nstatic const struct attribute_group hisi_ddrc_pmu_v1_events_group = {\n\t.name = \"events\",\n\t.attrs = hisi_ddrc_pmu_v1_events_attr,\n};\n\nstatic struct attribute *hisi_ddrc_pmu_v2_events_attr[] = {\n\tHISI_PMU_EVENT_ATTR(cycles,\t\t0x00),\n\tHISI_PMU_EVENT_ATTR(flux_wr,\t\t0x83),\n\tHISI_PMU_EVENT_ATTR(flux_rd,\t\t0x84),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_ddrc_pmu_v2_events_group = {\n\t.name = \"events\",\n\t.attrs = hisi_ddrc_pmu_v2_events_attr,\n};\n\nstatic DEVICE_ATTR(cpumask, 0444, hisi_cpumask_sysfs_show, NULL);\n\nstatic struct attribute *hisi_ddrc_pmu_cpumask_attrs[] = {\n\t&dev_attr_cpumask.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group hisi_ddrc_pmu_cpumask_attr_group = {\n\t.attrs = hisi_ddrc_pmu_cpumask_attrs,\n};\n\nstatic struct device_attribute hisi_ddrc_pmu_identifier_attr =\n\t__ATTR(identifier, 0444, hisi_uncore_pmu_identifier_attr_show, NULL);\n\nstatic struct attribute *hisi_ddrc_pmu_identifier_attrs[] = {\n\t&hisi_ddrc_pmu_identifier_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hisi_ddrc_pmu_identifier_group = {\n\t.attrs = hisi_ddrc_pmu_identifier_attrs,\n};\n\nstatic const struct attribute_group *hisi_ddrc_pmu_v1_attr_groups[] = {\n\t&hisi_ddrc_pmu_v1_format_group,\n\t&hisi_ddrc_pmu_v1_events_group,\n\t&hisi_ddrc_pmu_cpumask_attr_group,\n\t&hisi_ddrc_pmu_identifier_group,\n\tNULL,\n};\n\nstatic const struct attribute_group *hisi_ddrc_pmu_v2_attr_groups[] = {\n\t&hisi_ddrc_pmu_v2_format_group,\n\t&hisi_ddrc_pmu_v2_events_group,\n\t&hisi_ddrc_pmu_cpumask_attr_group,\n\t&hisi_ddrc_pmu_identifier_group,\n\tNULL\n};\n\nstatic const struct hisi_uncore_ops hisi_uncore_ddrc_v1_ops = {\n\t.write_evtype           = hisi_ddrc_pmu_write_evtype,\n\t.get_event_idx\t\t= hisi_ddrc_pmu_v1_get_event_idx,\n\t.start_counters\t\t= hisi_ddrc_pmu_v1_start_counters,\n\t.stop_counters\t\t= hisi_ddrc_pmu_v1_stop_counters,\n\t.enable_counter\t\t= hisi_ddrc_pmu_v1_enable_counter,\n\t.disable_counter\t= hisi_ddrc_pmu_v1_disable_counter,\n\t.enable_counter_int\t= hisi_ddrc_pmu_v1_enable_counter_int,\n\t.disable_counter_int\t= hisi_ddrc_pmu_v1_disable_counter_int,\n\t.write_counter\t\t= hisi_ddrc_pmu_v1_write_counter,\n\t.read_counter\t\t= hisi_ddrc_pmu_v1_read_counter,\n\t.get_int_status\t\t= hisi_ddrc_pmu_v1_get_int_status,\n\t.clear_int_status\t= hisi_ddrc_pmu_v1_clear_int_status,\n};\n\nstatic const struct hisi_uncore_ops hisi_uncore_ddrc_v2_ops = {\n\t.write_evtype           = hisi_ddrc_pmu_write_evtype,\n\t.get_event_idx\t\t= hisi_ddrc_pmu_v2_get_event_idx,\n\t.start_counters\t\t= hisi_ddrc_pmu_v2_start_counters,\n\t.stop_counters\t\t= hisi_ddrc_pmu_v2_stop_counters,\n\t.enable_counter\t\t= hisi_ddrc_pmu_v2_enable_counter,\n\t.disable_counter\t= hisi_ddrc_pmu_v2_disable_counter,\n\t.enable_counter_int\t= hisi_ddrc_pmu_v2_enable_counter_int,\n\t.disable_counter_int\t= hisi_ddrc_pmu_v2_disable_counter_int,\n\t.write_counter\t\t= hisi_ddrc_pmu_v2_write_counter,\n\t.read_counter\t\t= hisi_ddrc_pmu_v2_read_counter,\n\t.get_int_status\t\t= hisi_ddrc_pmu_v2_get_int_status,\n\t.clear_int_status\t= hisi_ddrc_pmu_v2_clear_int_status,\n};\n\nstatic int hisi_ddrc_pmu_dev_probe(struct platform_device *pdev,\n\t\t\t\t   struct hisi_pmu *ddrc_pmu)\n{\n\tint ret;\n\n\tret = hisi_ddrc_pmu_init_data(pdev, ddrc_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_uncore_pmu_init_irq(ddrc_pmu, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ddrc_pmu->identifier >= HISI_PMU_V2) {\n\t\tddrc_pmu->counter_bits = 48;\n\t\tddrc_pmu->check_event = DDRC_V2_NR_EVENTS;\n\t\tddrc_pmu->pmu_events.attr_groups = hisi_ddrc_pmu_v2_attr_groups;\n\t\tddrc_pmu->ops = &hisi_uncore_ddrc_v2_ops;\n\t} else {\n\t\tddrc_pmu->counter_bits = 32;\n\t\tddrc_pmu->check_event = DDRC_V1_NR_EVENTS;\n\t\tddrc_pmu->pmu_events.attr_groups = hisi_ddrc_pmu_v1_attr_groups;\n\t\tddrc_pmu->ops = &hisi_uncore_ddrc_v1_ops;\n\t}\n\n\tddrc_pmu->num_counters = DDRC_NR_COUNTERS;\n\tddrc_pmu->dev = &pdev->dev;\n\tddrc_pmu->on_cpu = -1;\n\n\treturn 0;\n}\n\nstatic int hisi_ddrc_pmu_probe(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *ddrc_pmu;\n\tchar *name;\n\tint ret;\n\n\tddrc_pmu = devm_kzalloc(&pdev->dev, sizeof(*ddrc_pmu), GFP_KERNEL);\n\tif (!ddrc_pmu)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ddrc_pmu);\n\n\tret = hisi_ddrc_pmu_dev_probe(pdev, ddrc_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ddrc_pmu->identifier >= HISI_PMU_V2)\n\t\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t      \"hisi_sccl%u_ddrc%u_%u\",\n\t\t\t\t      ddrc_pmu->sccl_id, ddrc_pmu->index_id,\n\t\t\t\t      ddrc_pmu->sub_id);\n\telse\n\t\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t      \"hisi_sccl%u_ddrc%u\", ddrc_pmu->sccl_id,\n\t\t\t\t      ddrc_pmu->index_id);\n\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = cpuhp_state_add_instance(CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE,\n\t\t\t\t       &ddrc_pmu->node);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error %d registering hotplug;\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thisi_pmu_init(ddrc_pmu, THIS_MODULE);\n\n\tret = perf_pmu_register(&ddrc_pmu->pmu, name, -1);\n\tif (ret) {\n\t\tdev_err(ddrc_pmu->dev, \"DDRC PMU register failed!\\n\");\n\t\tcpuhp_state_remove_instance_nocalls(\n\t\t\tCPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE, &ddrc_pmu->node);\n\t}\n\n\treturn ret;\n}\n\nstatic int hisi_ddrc_pmu_remove(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *ddrc_pmu = platform_get_drvdata(pdev);\n\n\tperf_pmu_unregister(&ddrc_pmu->pmu);\n\tcpuhp_state_remove_instance_nocalls(CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE,\n\t\t\t\t\t    &ddrc_pmu->node);\n\treturn 0;\n}\n\nstatic struct platform_driver hisi_ddrc_pmu_driver = {\n\t.driver = {\n\t\t.name = \"hisi_ddrc_pmu\",\n\t\t.acpi_match_table = ACPI_PTR(hisi_ddrc_pmu_acpi_match),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = hisi_ddrc_pmu_probe,\n\t.remove = hisi_ddrc_pmu_remove,\n};\n\nstatic int __init hisi_ddrc_pmu_module_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE,\n\t\t\t\t      \"AP_PERF_ARM_HISI_DDRC_ONLINE\",\n\t\t\t\t      hisi_uncore_pmu_online_cpu,\n\t\t\t\t      hisi_uncore_pmu_offline_cpu);\n\tif (ret) {\n\t\tpr_err(\"DDRC PMU: setup hotplug, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&hisi_ddrc_pmu_driver);\n\tif (ret)\n\t\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE);\n\n\treturn ret;\n}\nmodule_init(hisi_ddrc_pmu_module_init);\n\nstatic void __exit hisi_ddrc_pmu_module_exit(void)\n{\n\tplatform_driver_unregister(&hisi_ddrc_pmu_driver);\n\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE);\n\n}\nmodule_exit(hisi_ddrc_pmu_module_exit);\n\nMODULE_DESCRIPTION(\"HiSilicon SoC DDRC uncore PMU driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Shaokun Zhang <zhangshaokun@hisilicon.com>\");\nMODULE_AUTHOR(\"Anurup M <anurup.m@huawei.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}