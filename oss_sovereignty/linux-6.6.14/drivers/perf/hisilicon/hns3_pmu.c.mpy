{
  "module_name": "hns3_pmu.c",
  "hash_id": "c708c41ce4761b30de072b605240df3616016740ef0b2e21cdc823fd483856f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/hisilicon/hns3_pmu.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bitmap.h>\n#include <linux/bug.h>\n#include <linux/cpuhotplug.h>\n#include <linux/cpumask.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/io-64-nonatomic-hi-lo.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pci-epf.h>\n#include <linux/perf_event.h>\n#include <linux/smp.h>\n\n \n#define HNS3_PMU_REG_GLOBAL_CTRL\t\t0x0000\n#define HNS3_PMU_REG_CLOCK_FREQ\t\t\t0x0020\n#define HNS3_PMU_REG_BDF\t\t\t0x0fe0\n#define HNS3_PMU_REG_VERSION\t\t\t0x0fe4\n#define HNS3_PMU_REG_DEVICE_ID\t\t\t0x0fe8\n\n#define HNS3_PMU_REG_EVENT_OFFSET\t\t0x1000\n#define HNS3_PMU_REG_EVENT_SIZE\t\t\t0x1000\n#define HNS3_PMU_REG_EVENT_CTRL_LOW\t\t0x00\n#define HNS3_PMU_REG_EVENT_CTRL_HIGH\t\t0x04\n#define HNS3_PMU_REG_EVENT_INTR_STATUS\t\t0x08\n#define HNS3_PMU_REG_EVENT_INTR_MASK\t\t0x0c\n#define HNS3_PMU_REG_EVENT_COUNTER\t\t0x10\n#define HNS3_PMU_REG_EVENT_EXT_COUNTER\t\t0x18\n#define HNS3_PMU_REG_EVENT_QID_CTRL\t\t0x28\n#define HNS3_PMU_REG_EVENT_QID_PARA\t\t0x2c\n\n#define HNS3_PMU_FILTER_SUPPORT_GLOBAL\t\tBIT(0)\n#define HNS3_PMU_FILTER_SUPPORT_PORT\t\tBIT(1)\n#define HNS3_PMU_FILTER_SUPPORT_PORT_TC\t\tBIT(2)\n#define HNS3_PMU_FILTER_SUPPORT_FUNC\t\tBIT(3)\n#define HNS3_PMU_FILTER_SUPPORT_FUNC_QUEUE\tBIT(4)\n#define HNS3_PMU_FILTER_SUPPORT_FUNC_INTR\tBIT(5)\n\n#define HNS3_PMU_FILTER_ALL_TC\t\t\t0xf\n#define HNS3_PMU_FILTER_ALL_QUEUE\t\t0xffff\n\n#define HNS3_PMU_CTRL_SUBEVENT_S\t\t4\n#define HNS3_PMU_CTRL_FILTER_MODE_S\t\t24\n\n#define HNS3_PMU_GLOBAL_START\t\t\tBIT(0)\n\n#define HNS3_PMU_EVENT_STATUS_RESET\t\tBIT(11)\n#define HNS3_PMU_EVENT_EN\t\t\tBIT(12)\n#define HNS3_PMU_EVENT_OVERFLOW_RESTART\t\tBIT(15)\n\n#define HNS3_PMU_QID_PARA_FUNC_S\t\t0\n#define HNS3_PMU_QID_PARA_QUEUE_S\t\t16\n\n#define HNS3_PMU_QID_CTRL_REQ_ENABLE\t\tBIT(0)\n#define HNS3_PMU_QID_CTRL_DONE\t\t\tBIT(1)\n#define HNS3_PMU_QID_CTRL_MISS\t\t\tBIT(2)\n\n#define HNS3_PMU_INTR_MASK_OVERFLOW\t\tBIT(1)\n\n#define HNS3_PMU_MAX_HW_EVENTS\t\t\t8\n\n \n \n#define HNS3_PMU_EVT_BW_SSU_EGU_BYTE_NUM\t\t0x00001\n#define HNS3_PMU_EVT_BW_SSU_EGU_TIME\t\t\t0x10001\n#define HNS3_PMU_EVT_BW_SSU_RPU_BYTE_NUM\t\t0x00002\n#define HNS3_PMU_EVT_BW_SSU_RPU_TIME\t\t\t0x10002\n#define HNS3_PMU_EVT_BW_SSU_ROCE_BYTE_NUM\t\t0x00003\n#define HNS3_PMU_EVT_BW_SSU_ROCE_TIME\t\t\t0x10003\n#define HNS3_PMU_EVT_BW_ROCE_SSU_BYTE_NUM\t\t0x00004\n#define HNS3_PMU_EVT_BW_ROCE_SSU_TIME\t\t\t0x10004\n#define HNS3_PMU_EVT_BW_TPU_SSU_BYTE_NUM\t\t0x00005\n#define HNS3_PMU_EVT_BW_TPU_SSU_TIME\t\t\t0x10005\n#define HNS3_PMU_EVT_BW_RPU_RCBRX_BYTE_NUM\t\t0x00006\n#define HNS3_PMU_EVT_BW_RPU_RCBRX_TIME\t\t\t0x10006\n#define HNS3_PMU_EVT_BW_RCBTX_TXSCH_BYTE_NUM\t\t0x00008\n#define HNS3_PMU_EVT_BW_RCBTX_TXSCH_TIME\t\t0x10008\n#define HNS3_PMU_EVT_BW_WR_FBD_BYTE_NUM\t\t\t0x00009\n#define HNS3_PMU_EVT_BW_WR_FBD_TIME\t\t\t0x10009\n#define HNS3_PMU_EVT_BW_WR_EBD_BYTE_NUM\t\t\t0x0000a\n#define HNS3_PMU_EVT_BW_WR_EBD_TIME\t\t\t0x1000a\n#define HNS3_PMU_EVT_BW_RD_FBD_BYTE_NUM\t\t\t0x0000b\n#define HNS3_PMU_EVT_BW_RD_FBD_TIME\t\t\t0x1000b\n#define HNS3_PMU_EVT_BW_RD_EBD_BYTE_NUM\t\t\t0x0000c\n#define HNS3_PMU_EVT_BW_RD_EBD_TIME\t\t\t0x1000c\n#define HNS3_PMU_EVT_BW_RD_PAY_M0_BYTE_NUM\t\t0x0000d\n#define HNS3_PMU_EVT_BW_RD_PAY_M0_TIME\t\t\t0x1000d\n#define HNS3_PMU_EVT_BW_RD_PAY_M1_BYTE_NUM\t\t0x0000e\n#define HNS3_PMU_EVT_BW_RD_PAY_M1_TIME\t\t\t0x1000e\n#define HNS3_PMU_EVT_BW_WR_PAY_M0_BYTE_NUM\t\t0x0000f\n#define HNS3_PMU_EVT_BW_WR_PAY_M0_TIME\t\t\t0x1000f\n#define HNS3_PMU_EVT_BW_WR_PAY_M1_BYTE_NUM\t\t0x00010\n#define HNS3_PMU_EVT_BW_WR_PAY_M1_TIME\t\t\t0x10010\n\n \n#define HNS3_PMU_EVT_PPS_IGU_SSU_PACKET_NUM\t\t0x00100\n#define HNS3_PMU_EVT_PPS_IGU_SSU_TIME\t\t\t0x10100\n#define HNS3_PMU_EVT_PPS_SSU_EGU_PACKET_NUM\t\t0x00101\n#define HNS3_PMU_EVT_PPS_SSU_EGU_TIME\t\t\t0x10101\n#define HNS3_PMU_EVT_PPS_SSU_RPU_PACKET_NUM\t\t0x00102\n#define HNS3_PMU_EVT_PPS_SSU_RPU_TIME\t\t\t0x10102\n#define HNS3_PMU_EVT_PPS_SSU_ROCE_PACKET_NUM\t\t0x00103\n#define HNS3_PMU_EVT_PPS_SSU_ROCE_TIME\t\t\t0x10103\n#define HNS3_PMU_EVT_PPS_ROCE_SSU_PACKET_NUM\t\t0x00104\n#define HNS3_PMU_EVT_PPS_ROCE_SSU_TIME\t\t\t0x10104\n#define HNS3_PMU_EVT_PPS_TPU_SSU_PACKET_NUM\t\t0x00105\n#define HNS3_PMU_EVT_PPS_TPU_SSU_TIME\t\t\t0x10105\n#define HNS3_PMU_EVT_PPS_RPU_RCBRX_PACKET_NUM\t\t0x00106\n#define HNS3_PMU_EVT_PPS_RPU_RCBRX_TIME\t\t\t0x10106\n#define HNS3_PMU_EVT_PPS_RCBTX_TPU_PACKET_NUM\t\t0x00107\n#define HNS3_PMU_EVT_PPS_RCBTX_TPU_TIME\t\t\t0x10107\n#define HNS3_PMU_EVT_PPS_RCBTX_TXSCH_PACKET_NUM\t\t0x00108\n#define HNS3_PMU_EVT_PPS_RCBTX_TXSCH_TIME\t\t0x10108\n#define HNS3_PMU_EVT_PPS_WR_FBD_PACKET_NUM\t\t0x00109\n#define HNS3_PMU_EVT_PPS_WR_FBD_TIME\t\t\t0x10109\n#define HNS3_PMU_EVT_PPS_WR_EBD_PACKET_NUM\t\t0x0010a\n#define HNS3_PMU_EVT_PPS_WR_EBD_TIME\t\t\t0x1010a\n#define HNS3_PMU_EVT_PPS_RD_FBD_PACKET_NUM\t\t0x0010b\n#define HNS3_PMU_EVT_PPS_RD_FBD_TIME\t\t\t0x1010b\n#define HNS3_PMU_EVT_PPS_RD_EBD_PACKET_NUM\t\t0x0010c\n#define HNS3_PMU_EVT_PPS_RD_EBD_TIME\t\t\t0x1010c\n#define HNS3_PMU_EVT_PPS_RD_PAY_M0_PACKET_NUM\t\t0x0010d\n#define HNS3_PMU_EVT_PPS_RD_PAY_M0_TIME\t\t\t0x1010d\n#define HNS3_PMU_EVT_PPS_RD_PAY_M1_PACKET_NUM\t\t0x0010e\n#define HNS3_PMU_EVT_PPS_RD_PAY_M1_TIME\t\t\t0x1010e\n#define HNS3_PMU_EVT_PPS_WR_PAY_M0_PACKET_NUM\t\t0x0010f\n#define HNS3_PMU_EVT_PPS_WR_PAY_M0_TIME\t\t\t0x1010f\n#define HNS3_PMU_EVT_PPS_WR_PAY_M1_PACKET_NUM\t\t0x00110\n#define HNS3_PMU_EVT_PPS_WR_PAY_M1_TIME\t\t\t0x10110\n#define HNS3_PMU_EVT_PPS_NICROH_TX_PRE_PACKET_NUM\t0x00111\n#define HNS3_PMU_EVT_PPS_NICROH_TX_PRE_TIME\t\t0x10111\n#define HNS3_PMU_EVT_PPS_NICROH_RX_PRE_PACKET_NUM\t0x00112\n#define HNS3_PMU_EVT_PPS_NICROH_RX_PRE_TIME\t\t0x10112\n\n \n#define HNS3_PMU_EVT_DLY_TX_PUSH_TIME\t\t\t0x00202\n#define HNS3_PMU_EVT_DLY_TX_PUSH_PACKET_NUM\t\t0x10202\n#define HNS3_PMU_EVT_DLY_TX_TIME\t\t\t0x00204\n#define HNS3_PMU_EVT_DLY_TX_PACKET_NUM\t\t\t0x10204\n#define HNS3_PMU_EVT_DLY_SSU_TX_NIC_TIME\t\t0x00206\n#define HNS3_PMU_EVT_DLY_SSU_TX_NIC_PACKET_NUM\t\t0x10206\n#define HNS3_PMU_EVT_DLY_SSU_TX_ROCE_TIME\t\t0x00207\n#define HNS3_PMU_EVT_DLY_SSU_TX_ROCE_PACKET_NUM\t\t0x10207\n#define HNS3_PMU_EVT_DLY_SSU_RX_NIC_TIME\t\t0x00208\n#define HNS3_PMU_EVT_DLY_SSU_RX_NIC_PACKET_NUM\t\t0x10208\n#define HNS3_PMU_EVT_DLY_SSU_RX_ROCE_TIME\t\t0x00209\n#define HNS3_PMU_EVT_DLY_SSU_RX_ROCE_PACKET_NUM\t\t0x10209\n#define HNS3_PMU_EVT_DLY_RPU_TIME\t\t\t0x0020e\n#define HNS3_PMU_EVT_DLY_RPU_PACKET_NUM\t\t\t0x1020e\n#define HNS3_PMU_EVT_DLY_TPU_TIME\t\t\t0x0020f\n#define HNS3_PMU_EVT_DLY_TPU_PACKET_NUM\t\t\t0x1020f\n#define HNS3_PMU_EVT_DLY_RPE_TIME\t\t\t0x00210\n#define HNS3_PMU_EVT_DLY_RPE_PACKET_NUM\t\t\t0x10210\n#define HNS3_PMU_EVT_DLY_TPE_TIME\t\t\t0x00211\n#define HNS3_PMU_EVT_DLY_TPE_PACKET_NUM\t\t\t0x10211\n#define HNS3_PMU_EVT_DLY_TPE_PUSH_TIME\t\t\t0x00212\n#define HNS3_PMU_EVT_DLY_TPE_PUSH_PACKET_NUM\t\t0x10212\n#define HNS3_PMU_EVT_DLY_WR_FBD_TIME\t\t\t0x00213\n#define HNS3_PMU_EVT_DLY_WR_FBD_PACKET_NUM\t\t0x10213\n#define HNS3_PMU_EVT_DLY_WR_EBD_TIME\t\t\t0x00214\n#define HNS3_PMU_EVT_DLY_WR_EBD_PACKET_NUM\t\t0x10214\n#define HNS3_PMU_EVT_DLY_RD_FBD_TIME\t\t\t0x00215\n#define HNS3_PMU_EVT_DLY_RD_FBD_PACKET_NUM\t\t0x10215\n#define HNS3_PMU_EVT_DLY_RD_EBD_TIME\t\t\t0x00216\n#define HNS3_PMU_EVT_DLY_RD_EBD_PACKET_NUM\t\t0x10216\n#define HNS3_PMU_EVT_DLY_RD_PAY_M0_TIME\t\t\t0x00217\n#define HNS3_PMU_EVT_DLY_RD_PAY_M0_PACKET_NUM\t\t0x10217\n#define HNS3_PMU_EVT_DLY_RD_PAY_M1_TIME\t\t\t0x00218\n#define HNS3_PMU_EVT_DLY_RD_PAY_M1_PACKET_NUM\t\t0x10218\n#define HNS3_PMU_EVT_DLY_WR_PAY_M0_TIME\t\t\t0x00219\n#define HNS3_PMU_EVT_DLY_WR_PAY_M0_PACKET_NUM\t\t0x10219\n#define HNS3_PMU_EVT_DLY_WR_PAY_M1_TIME\t\t\t0x0021a\n#define HNS3_PMU_EVT_DLY_WR_PAY_M1_PACKET_NUM\t\t0x1021a\n#define HNS3_PMU_EVT_DLY_MSIX_WRITE_TIME\t\t0x0021c\n#define HNS3_PMU_EVT_DLY_MSIX_WRITE_PACKET_NUM\t\t0x1021c\n\n \n#define HNS3_PMU_EVT_PPS_MSIX_NIC_INTR_NUM\t\t0x00300\n#define HNS3_PMU_EVT_PPS_MSIX_NIC_TIME\t\t\t0x10300\n\n \n#define HNS3_PMU_FILTER_BW_SSU_EGU\t\t0x07\n#define HNS3_PMU_FILTER_BW_SSU_RPU\t\t0x1f\n#define HNS3_PMU_FILTER_BW_SSU_ROCE\t\t0x0f\n#define HNS3_PMU_FILTER_BW_ROCE_SSU\t\t0x0f\n#define HNS3_PMU_FILTER_BW_TPU_SSU\t\t0x1f\n#define HNS3_PMU_FILTER_BW_RPU_RCBRX\t\t0x11\n#define HNS3_PMU_FILTER_BW_RCBTX_TXSCH\t\t0x11\n#define HNS3_PMU_FILTER_BW_WR_FBD\t\t0x1b\n#define HNS3_PMU_FILTER_BW_WR_EBD\t\t0x11\n#define HNS3_PMU_FILTER_BW_RD_FBD\t\t0x01\n#define HNS3_PMU_FILTER_BW_RD_EBD\t\t0x1b\n#define HNS3_PMU_FILTER_BW_RD_PAY_M0\t\t0x01\n#define HNS3_PMU_FILTER_BW_RD_PAY_M1\t\t0x01\n#define HNS3_PMU_FILTER_BW_WR_PAY_M0\t\t0x01\n#define HNS3_PMU_FILTER_BW_WR_PAY_M1\t\t0x01\n\n \n#define HNS3_PMU_FILTER_PPS_IGU_SSU\t\t0x07\n#define HNS3_PMU_FILTER_PPS_SSU_EGU\t\t0x07\n#define HNS3_PMU_FILTER_PPS_SSU_RPU\t\t0x1f\n#define HNS3_PMU_FILTER_PPS_SSU_ROCE\t\t0x0f\n#define HNS3_PMU_FILTER_PPS_ROCE_SSU\t\t0x0f\n#define HNS3_PMU_FILTER_PPS_TPU_SSU\t\t0x1f\n#define HNS3_PMU_FILTER_PPS_RPU_RCBRX\t\t0x11\n#define HNS3_PMU_FILTER_PPS_RCBTX_TPU\t\t0x1f\n#define HNS3_PMU_FILTER_PPS_RCBTX_TXSCH\t\t0x11\n#define HNS3_PMU_FILTER_PPS_WR_FBD\t\t0x1b\n#define HNS3_PMU_FILTER_PPS_WR_EBD\t\t0x11\n#define HNS3_PMU_FILTER_PPS_RD_FBD\t\t0x01\n#define HNS3_PMU_FILTER_PPS_RD_EBD\t\t0x1b\n#define HNS3_PMU_FILTER_PPS_RD_PAY_M0\t\t0x01\n#define HNS3_PMU_FILTER_PPS_RD_PAY_M1\t\t0x01\n#define HNS3_PMU_FILTER_PPS_WR_PAY_M0\t\t0x01\n#define HNS3_PMU_FILTER_PPS_WR_PAY_M1\t\t0x01\n#define HNS3_PMU_FILTER_PPS_NICROH_TX_PRE\t0x01\n#define HNS3_PMU_FILTER_PPS_NICROH_RX_PRE\t0x01\n\n \n#define HNS3_PMU_FILTER_DLY_TX_PUSH\t\t0x01\n#define HNS3_PMU_FILTER_DLY_TX\t\t\t0x01\n#define HNS3_PMU_FILTER_DLY_SSU_TX_NIC\t\t0x07\n#define HNS3_PMU_FILTER_DLY_SSU_TX_ROCE\t\t0x07\n#define HNS3_PMU_FILTER_DLY_SSU_RX_NIC\t\t0x07\n#define HNS3_PMU_FILTER_DLY_SSU_RX_ROCE\t\t0x07\n#define HNS3_PMU_FILTER_DLY_RPU\t\t\t0x11\n#define HNS3_PMU_FILTER_DLY_TPU\t\t\t0x1f\n#define HNS3_PMU_FILTER_DLY_RPE\t\t\t0x01\n#define HNS3_PMU_FILTER_DLY_TPE\t\t\t0x0b\n#define HNS3_PMU_FILTER_DLY_TPE_PUSH\t\t0x1b\n#define HNS3_PMU_FILTER_DLY_WR_FBD\t\t0x1b\n#define HNS3_PMU_FILTER_DLY_WR_EBD\t\t0x11\n#define HNS3_PMU_FILTER_DLY_RD_FBD\t\t0x01\n#define HNS3_PMU_FILTER_DLY_RD_EBD\t\t0x1b\n#define HNS3_PMU_FILTER_DLY_RD_PAY_M0\t\t0x01\n#define HNS3_PMU_FILTER_DLY_RD_PAY_M1\t\t0x01\n#define HNS3_PMU_FILTER_DLY_WR_PAY_M0\t\t0x01\n#define HNS3_PMU_FILTER_DLY_WR_PAY_M1\t\t0x01\n#define HNS3_PMU_FILTER_DLY_MSIX_WRITE\t\t0x01\n\n \n#define HNS3_PMU_FILTER_INTR_MSIX_NIC\t\t0x01\n\nenum hns3_pmu_hw_filter_mode {\n\tHNS3_PMU_HW_FILTER_GLOBAL,\n\tHNS3_PMU_HW_FILTER_PORT,\n\tHNS3_PMU_HW_FILTER_PORT_TC,\n\tHNS3_PMU_HW_FILTER_FUNC,\n\tHNS3_PMU_HW_FILTER_FUNC_QUEUE,\n\tHNS3_PMU_HW_FILTER_FUNC_INTR,\n};\n\nstruct hns3_pmu_event_attr {\n\tu32 event;\n\tu16 filter_support;\n};\n\nstruct hns3_pmu {\n\tstruct perf_event *hw_events[HNS3_PMU_MAX_HW_EVENTS];\n\tstruct hlist_node node;\n\tstruct pci_dev *pdev;\n\tstruct pmu pmu;\n\tvoid __iomem *base;\n\tint irq;\n\tint on_cpu;\n\tu32 identifier;\n\tu32 hw_clk_freq;  \n\t \n\tu16 bdf_min;\n\tu16 bdf_max;\n};\n\n#define to_hns3_pmu(p)  (container_of((p), struct hns3_pmu, pmu))\n\n#define GET_PCI_DEVFN(bdf)  ((bdf) & 0xff)\n\n#define FILTER_CONDITION_PORT(port) ((1 << (port)) & 0xff)\n#define FILTER_CONDITION_PORT_TC(port, tc) (((port) << 3) | ((tc) & 0x07))\n#define FILTER_CONDITION_FUNC_INTR(func, intr) (((intr) << 8) | (func))\n\n#define HNS3_PMU_FILTER_ATTR(_name, _config, _start, _end)               \\\n\tstatic inline u64 hns3_pmu_get_##_name(struct perf_event *event) \\\n\t{                                                                \\\n\t\treturn FIELD_GET(GENMASK_ULL(_end, _start),              \\\n\t\t\t\t event->attr._config);                   \\\n\t}\n\nHNS3_PMU_FILTER_ATTR(subevent, config, 0, 7);\nHNS3_PMU_FILTER_ATTR(event_type, config, 8, 15);\nHNS3_PMU_FILTER_ATTR(ext_counter_used, config, 16, 16);\nHNS3_PMU_FILTER_ATTR(port, config1, 0, 3);\nHNS3_PMU_FILTER_ATTR(tc, config1, 4, 7);\nHNS3_PMU_FILTER_ATTR(bdf, config1, 8, 23);\nHNS3_PMU_FILTER_ATTR(queue, config1, 24, 39);\nHNS3_PMU_FILTER_ATTR(intr, config1, 40, 51);\nHNS3_PMU_FILTER_ATTR(global, config1, 52, 52);\n\n#define HNS3_BW_EVT_BYTE_NUM(_name)\t(&(struct hns3_pmu_event_attr) {\\\n\tHNS3_PMU_EVT_BW_##_name##_BYTE_NUM,\t\t\t\t\\\n\tHNS3_PMU_FILTER_BW_##_name})\n#define HNS3_BW_EVT_TIME(_name)\t\t(&(struct hns3_pmu_event_attr) {\\\n\tHNS3_PMU_EVT_BW_##_name##_TIME,\t\t\t\t\t\\\n\tHNS3_PMU_FILTER_BW_##_name})\n#define HNS3_PPS_EVT_PACKET_NUM(_name)\t(&(struct hns3_pmu_event_attr) {\\\n\tHNS3_PMU_EVT_PPS_##_name##_PACKET_NUM,\t\t\t\t\\\n\tHNS3_PMU_FILTER_PPS_##_name})\n#define HNS3_PPS_EVT_TIME(_name)\t(&(struct hns3_pmu_event_attr) {\\\n\tHNS3_PMU_EVT_PPS_##_name##_TIME,\t\t\t\t\\\n\tHNS3_PMU_FILTER_PPS_##_name})\n#define HNS3_DLY_EVT_TIME(_name)\t(&(struct hns3_pmu_event_attr) {\\\n\tHNS3_PMU_EVT_DLY_##_name##_TIME,\t\t\t\t\\\n\tHNS3_PMU_FILTER_DLY_##_name})\n#define HNS3_DLY_EVT_PACKET_NUM(_name)\t(&(struct hns3_pmu_event_attr) {\\\n\tHNS3_PMU_EVT_DLY_##_name##_PACKET_NUM,\t\t\t\t\\\n\tHNS3_PMU_FILTER_DLY_##_name})\n#define HNS3_INTR_EVT_INTR_NUM(_name)\t(&(struct hns3_pmu_event_attr) {\\\n\tHNS3_PMU_EVT_PPS_##_name##_INTR_NUM,\t\t\t\t\\\n\tHNS3_PMU_FILTER_INTR_##_name})\n#define HNS3_INTR_EVT_TIME(_name)\t(&(struct hns3_pmu_event_attr) {\\\n\tHNS3_PMU_EVT_PPS_##_name##_TIME,\t\t\t\t\\\n\tHNS3_PMU_FILTER_INTR_##_name})\n\nstatic ssize_t hns3_pmu_format_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct dev_ext_attribute *eattr;\n\n\teattr = container_of(attr, struct dev_ext_attribute, attr);\n\n\treturn sysfs_emit(buf, \"%s\\n\", (char *)eattr->var);\n}\n\nstatic ssize_t hns3_pmu_event_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct hns3_pmu_event_attr *event;\n\tstruct dev_ext_attribute *eattr;\n\n\teattr = container_of(attr, struct dev_ext_attribute, attr);\n\tevent = eattr->var;\n\n\treturn sysfs_emit(buf, \"config=0x%x\\n\", event->event);\n}\n\nstatic ssize_t hns3_pmu_filter_mode_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct hns3_pmu_event_attr *event;\n\tstruct dev_ext_attribute *eattr;\n\tint len;\n\n\teattr = container_of(attr, struct dev_ext_attribute, attr);\n\tevent = eattr->var;\n\n\tlen = sysfs_emit_at(buf, 0, \"filter mode supported: \");\n\tif (event->filter_support & HNS3_PMU_FILTER_SUPPORT_GLOBAL)\n\t\tlen += sysfs_emit_at(buf, len, \"global \");\n\tif (event->filter_support & HNS3_PMU_FILTER_SUPPORT_PORT)\n\t\tlen += sysfs_emit_at(buf, len, \"port \");\n\tif (event->filter_support & HNS3_PMU_FILTER_SUPPORT_PORT_TC)\n\t\tlen += sysfs_emit_at(buf, len, \"port-tc \");\n\tif (event->filter_support & HNS3_PMU_FILTER_SUPPORT_FUNC)\n\t\tlen += sysfs_emit_at(buf, len, \"func \");\n\tif (event->filter_support & HNS3_PMU_FILTER_SUPPORT_FUNC_QUEUE)\n\t\tlen += sysfs_emit_at(buf, len, \"func-queue \");\n\tif (event->filter_support & HNS3_PMU_FILTER_SUPPORT_FUNC_INTR)\n\t\tlen += sysfs_emit_at(buf, len, \"func-intr \");\n\n\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\n\treturn len;\n}\n\n#define HNS3_PMU_ATTR(_name, _func, _config)\t\t\t\t\\\n\t(&((struct dev_ext_attribute[]) {\t\t\t\t\\\n\t\t{ __ATTR(_name, 0444, _func, NULL), (void *)_config }\t\\\n\t})[0].attr.attr)\n\n#define HNS3_PMU_FORMAT_ATTR(_name, _format) \\\n\tHNS3_PMU_ATTR(_name, hns3_pmu_format_show, (void *)_format)\n#define HNS3_PMU_EVENT_ATTR(_name, _event) \\\n\tHNS3_PMU_ATTR(_name, hns3_pmu_event_show, (void *)_event)\n#define HNS3_PMU_FLT_MODE_ATTR(_name, _event) \\\n\tHNS3_PMU_ATTR(_name, hns3_pmu_filter_mode_show, (void *)_event)\n\n#define HNS3_PMU_BW_EVT_PAIR(_name, _macro) \\\n\tHNS3_PMU_EVENT_ATTR(_name##_byte_num, HNS3_BW_EVT_BYTE_NUM(_macro)), \\\n\tHNS3_PMU_EVENT_ATTR(_name##_time, HNS3_BW_EVT_TIME(_macro))\n#define HNS3_PMU_PPS_EVT_PAIR(_name, _macro) \\\n\tHNS3_PMU_EVENT_ATTR(_name##_packet_num, HNS3_PPS_EVT_PACKET_NUM(_macro)), \\\n\tHNS3_PMU_EVENT_ATTR(_name##_time, HNS3_PPS_EVT_TIME(_macro))\n#define HNS3_PMU_DLY_EVT_PAIR(_name, _macro) \\\n\tHNS3_PMU_EVENT_ATTR(_name##_time, HNS3_DLY_EVT_TIME(_macro)), \\\n\tHNS3_PMU_EVENT_ATTR(_name##_packet_num, HNS3_DLY_EVT_PACKET_NUM(_macro))\n#define HNS3_PMU_INTR_EVT_PAIR(_name, _macro) \\\n\tHNS3_PMU_EVENT_ATTR(_name##_intr_num, HNS3_INTR_EVT_INTR_NUM(_macro)), \\\n\tHNS3_PMU_EVENT_ATTR(_name##_time, HNS3_INTR_EVT_TIME(_macro))\n\n#define HNS3_PMU_BW_FLT_MODE_PAIR(_name, _macro) \\\n\tHNS3_PMU_FLT_MODE_ATTR(_name##_byte_num, HNS3_BW_EVT_BYTE_NUM(_macro)), \\\n\tHNS3_PMU_FLT_MODE_ATTR(_name##_time, HNS3_BW_EVT_TIME(_macro))\n#define HNS3_PMU_PPS_FLT_MODE_PAIR(_name, _macro) \\\n\tHNS3_PMU_FLT_MODE_ATTR(_name##_packet_num, HNS3_PPS_EVT_PACKET_NUM(_macro)), \\\n\tHNS3_PMU_FLT_MODE_ATTR(_name##_time, HNS3_PPS_EVT_TIME(_macro))\n#define HNS3_PMU_DLY_FLT_MODE_PAIR(_name, _macro) \\\n\tHNS3_PMU_FLT_MODE_ATTR(_name##_time, HNS3_DLY_EVT_TIME(_macro)), \\\n\tHNS3_PMU_FLT_MODE_ATTR(_name##_packet_num, HNS3_DLY_EVT_PACKET_NUM(_macro))\n#define HNS3_PMU_INTR_FLT_MODE_PAIR(_name, _macro) \\\n\tHNS3_PMU_FLT_MODE_ATTR(_name##_intr_num, HNS3_INTR_EVT_INTR_NUM(_macro)), \\\n\tHNS3_PMU_FLT_MODE_ATTR(_name##_time, HNS3_INTR_EVT_TIME(_macro))\n\nstatic u8 hns3_pmu_hw_filter_modes[] = {\n\tHNS3_PMU_HW_FILTER_GLOBAL,\n\tHNS3_PMU_HW_FILTER_PORT,\n\tHNS3_PMU_HW_FILTER_PORT_TC,\n\tHNS3_PMU_HW_FILTER_FUNC,\n\tHNS3_PMU_HW_FILTER_FUNC_QUEUE,\n\tHNS3_PMU_HW_FILTER_FUNC_INTR,\n};\n\n#define HNS3_PMU_SET_HW_FILTER(_hwc, _mode) \\\n\t((_hwc)->addr_filters = (void *)&hns3_pmu_hw_filter_modes[(_mode)])\n\nstatic ssize_t identifier_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(dev_get_drvdata(dev));\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", hns3_pmu->identifier);\n}\nstatic DEVICE_ATTR_RO(identifier);\n\nstatic ssize_t cpumask_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(dev_get_drvdata(dev));\n\n\treturn sysfs_emit(buf, \"%d\\n\", hns3_pmu->on_cpu);\n}\nstatic DEVICE_ATTR_RO(cpumask);\n\nstatic ssize_t bdf_min_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(dev_get_drvdata(dev));\n\tu16 bdf = hns3_pmu->bdf_min;\n\n\treturn sysfs_emit(buf, \"%02x:%02x.%x\\n\", PCI_BUS_NUM(bdf),\n\t\t\t  PCI_SLOT(bdf), PCI_FUNC(bdf));\n}\nstatic DEVICE_ATTR_RO(bdf_min);\n\nstatic ssize_t bdf_max_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(dev_get_drvdata(dev));\n\tu16 bdf = hns3_pmu->bdf_max;\n\n\treturn sysfs_emit(buf, \"%02x:%02x.%x\\n\", PCI_BUS_NUM(bdf),\n\t\t\t  PCI_SLOT(bdf), PCI_FUNC(bdf));\n}\nstatic DEVICE_ATTR_RO(bdf_max);\n\nstatic ssize_t hw_clk_freq_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(dev_get_drvdata(dev));\n\n\treturn sysfs_emit(buf, \"%u\\n\", hns3_pmu->hw_clk_freq);\n}\nstatic DEVICE_ATTR_RO(hw_clk_freq);\n\nstatic struct attribute *hns3_pmu_events_attr[] = {\n\t \n\tHNS3_PMU_BW_EVT_PAIR(bw_ssu_egu, SSU_EGU),\n\tHNS3_PMU_BW_EVT_PAIR(bw_ssu_rpu, SSU_RPU),\n\tHNS3_PMU_BW_EVT_PAIR(bw_ssu_roce, SSU_ROCE),\n\tHNS3_PMU_BW_EVT_PAIR(bw_roce_ssu, ROCE_SSU),\n\tHNS3_PMU_BW_EVT_PAIR(bw_tpu_ssu, TPU_SSU),\n\tHNS3_PMU_BW_EVT_PAIR(bw_rpu_rcbrx, RPU_RCBRX),\n\tHNS3_PMU_BW_EVT_PAIR(bw_rcbtx_txsch, RCBTX_TXSCH),\n\tHNS3_PMU_BW_EVT_PAIR(bw_wr_fbd, WR_FBD),\n\tHNS3_PMU_BW_EVT_PAIR(bw_wr_ebd, WR_EBD),\n\tHNS3_PMU_BW_EVT_PAIR(bw_rd_fbd, RD_FBD),\n\tHNS3_PMU_BW_EVT_PAIR(bw_rd_ebd, RD_EBD),\n\tHNS3_PMU_BW_EVT_PAIR(bw_rd_pay_m0, RD_PAY_M0),\n\tHNS3_PMU_BW_EVT_PAIR(bw_rd_pay_m1, RD_PAY_M1),\n\tHNS3_PMU_BW_EVT_PAIR(bw_wr_pay_m0, WR_PAY_M0),\n\tHNS3_PMU_BW_EVT_PAIR(bw_wr_pay_m1, WR_PAY_M1),\n\n\t \n\tHNS3_PMU_PPS_EVT_PAIR(pps_igu_ssu, IGU_SSU),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_ssu_egu, SSU_EGU),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_ssu_rpu, SSU_RPU),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_ssu_roce, SSU_ROCE),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_roce_ssu, ROCE_SSU),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_tpu_ssu, TPU_SSU),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_rpu_rcbrx, RPU_RCBRX),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_rcbtx_tpu, RCBTX_TPU),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_rcbtx_txsch, RCBTX_TXSCH),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_wr_fbd, WR_FBD),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_wr_ebd, WR_EBD),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_rd_fbd, RD_FBD),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_rd_ebd, RD_EBD),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_rd_pay_m0, RD_PAY_M0),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_rd_pay_m1, RD_PAY_M1),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_wr_pay_m0, WR_PAY_M0),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_wr_pay_m1, WR_PAY_M1),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_intr_nicroh_tx_pre, NICROH_TX_PRE),\n\tHNS3_PMU_PPS_EVT_PAIR(pps_intr_nicroh_rx_pre, NICROH_RX_PRE),\n\n\t \n\tHNS3_PMU_DLY_EVT_PAIR(dly_tx_push_to_mac, TX_PUSH),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_tx_normal_to_mac, TX),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_ssu_tx_th_nic, SSU_TX_NIC),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_ssu_tx_th_roce, SSU_TX_ROCE),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_ssu_rx_th_nic, SSU_RX_NIC),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_ssu_rx_th_roce, SSU_RX_ROCE),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_rpu, RPU),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_tpu, TPU),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_rpe, RPE),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_tpe_normal, TPE),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_tpe_push, TPE_PUSH),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_wr_fbd, WR_FBD),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_wr_ebd, WR_EBD),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_rd_fbd, RD_FBD),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_rd_ebd, RD_EBD),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_rd_pay_m0, RD_PAY_M0),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_rd_pay_m1, RD_PAY_M1),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_wr_pay_m0, WR_PAY_M0),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_wr_pay_m1, WR_PAY_M1),\n\tHNS3_PMU_DLY_EVT_PAIR(dly_msix_write, MSIX_WRITE),\n\n\t \n\tHNS3_PMU_INTR_EVT_PAIR(pps_intr_msix_nic, MSIX_NIC),\n\n\tNULL\n};\n\nstatic struct attribute *hns3_pmu_filter_mode_attr[] = {\n\t \n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_ssu_egu, SSU_EGU),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_ssu_rpu, SSU_RPU),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_ssu_roce, SSU_ROCE),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_roce_ssu, ROCE_SSU),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_tpu_ssu, TPU_SSU),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_rpu_rcbrx, RPU_RCBRX),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_rcbtx_txsch, RCBTX_TXSCH),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_wr_fbd, WR_FBD),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_wr_ebd, WR_EBD),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_rd_fbd, RD_FBD),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_rd_ebd, RD_EBD),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_rd_pay_m0, RD_PAY_M0),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_rd_pay_m1, RD_PAY_M1),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_wr_pay_m0, WR_PAY_M0),\n\tHNS3_PMU_BW_FLT_MODE_PAIR(bw_wr_pay_m1, WR_PAY_M1),\n\n\t \n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_igu_ssu, IGU_SSU),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_ssu_egu, SSU_EGU),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_ssu_rpu, SSU_RPU),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_ssu_roce, SSU_ROCE),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_roce_ssu, ROCE_SSU),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_tpu_ssu, TPU_SSU),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_rpu_rcbrx, RPU_RCBRX),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_rcbtx_tpu, RCBTX_TPU),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_rcbtx_txsch, RCBTX_TXSCH),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_wr_fbd, WR_FBD),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_wr_ebd, WR_EBD),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_rd_fbd, RD_FBD),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_rd_ebd, RD_EBD),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_rd_pay_m0, RD_PAY_M0),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_rd_pay_m1, RD_PAY_M1),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_wr_pay_m0, WR_PAY_M0),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_wr_pay_m1, WR_PAY_M1),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_intr_nicroh_tx_pre, NICROH_TX_PRE),\n\tHNS3_PMU_PPS_FLT_MODE_PAIR(pps_intr_nicroh_rx_pre, NICROH_RX_PRE),\n\n\t \n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_tx_push_to_mac, TX_PUSH),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_tx_normal_to_mac, TX),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_ssu_tx_th_nic, SSU_TX_NIC),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_ssu_tx_th_roce, SSU_TX_ROCE),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_ssu_rx_th_nic, SSU_RX_NIC),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_ssu_rx_th_roce, SSU_RX_ROCE),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_rpu, RPU),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_tpu, TPU),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_rpe, RPE),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_tpe_normal, TPE),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_tpe_push, TPE_PUSH),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_wr_fbd, WR_FBD),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_wr_ebd, WR_EBD),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_rd_fbd, RD_FBD),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_rd_ebd, RD_EBD),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_rd_pay_m0, RD_PAY_M0),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_rd_pay_m1, RD_PAY_M1),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_wr_pay_m0, WR_PAY_M0),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_wr_pay_m1, WR_PAY_M1),\n\tHNS3_PMU_DLY_FLT_MODE_PAIR(dly_msix_write, MSIX_WRITE),\n\n\t \n\tHNS3_PMU_INTR_FLT_MODE_PAIR(pps_intr_msix_nic, MSIX_NIC),\n\n\tNULL\n};\n\nstatic struct attribute_group hns3_pmu_events_group = {\n\t.name = \"events\",\n\t.attrs = hns3_pmu_events_attr,\n};\n\nstatic struct attribute_group hns3_pmu_filter_mode_group = {\n\t.name = \"filtermode\",\n\t.attrs = hns3_pmu_filter_mode_attr,\n};\n\nstatic struct attribute *hns3_pmu_format_attr[] = {\n\tHNS3_PMU_FORMAT_ATTR(subevent, \"config:0-7\"),\n\tHNS3_PMU_FORMAT_ATTR(event_type, \"config:8-15\"),\n\tHNS3_PMU_FORMAT_ATTR(ext_counter_used, \"config:16\"),\n\tHNS3_PMU_FORMAT_ATTR(port, \"config1:0-3\"),\n\tHNS3_PMU_FORMAT_ATTR(tc, \"config1:4-7\"),\n\tHNS3_PMU_FORMAT_ATTR(bdf, \"config1:8-23\"),\n\tHNS3_PMU_FORMAT_ATTR(queue, \"config1:24-39\"),\n\tHNS3_PMU_FORMAT_ATTR(intr, \"config1:40-51\"),\n\tHNS3_PMU_FORMAT_ATTR(global, \"config1:52\"),\n\tNULL\n};\n\nstatic struct attribute_group hns3_pmu_format_group = {\n\t.name = \"format\",\n\t.attrs = hns3_pmu_format_attr,\n};\n\nstatic struct attribute *hns3_pmu_cpumask_attrs[] = {\n\t&dev_attr_cpumask.attr,\n\tNULL\n};\n\nstatic struct attribute_group hns3_pmu_cpumask_attr_group = {\n\t.attrs = hns3_pmu_cpumask_attrs,\n};\n\nstatic struct attribute *hns3_pmu_identifier_attrs[] = {\n\t&dev_attr_identifier.attr,\n\tNULL\n};\n\nstatic struct attribute_group hns3_pmu_identifier_attr_group = {\n\t.attrs = hns3_pmu_identifier_attrs,\n};\n\nstatic struct attribute *hns3_pmu_bdf_range_attrs[] = {\n\t&dev_attr_bdf_min.attr,\n\t&dev_attr_bdf_max.attr,\n\tNULL\n};\n\nstatic struct attribute_group hns3_pmu_bdf_range_attr_group = {\n\t.attrs = hns3_pmu_bdf_range_attrs,\n};\n\nstatic struct attribute *hns3_pmu_hw_clk_freq_attrs[] = {\n\t&dev_attr_hw_clk_freq.attr,\n\tNULL\n};\n\nstatic struct attribute_group hns3_pmu_hw_clk_freq_attr_group = {\n\t.attrs = hns3_pmu_hw_clk_freq_attrs,\n};\n\nstatic const struct attribute_group *hns3_pmu_attr_groups[] = {\n\t&hns3_pmu_events_group,\n\t&hns3_pmu_filter_mode_group,\n\t&hns3_pmu_format_group,\n\t&hns3_pmu_cpumask_attr_group,\n\t&hns3_pmu_identifier_attr_group,\n\t&hns3_pmu_bdf_range_attr_group,\n\t&hns3_pmu_hw_clk_freq_attr_group,\n\tNULL\n};\n\nstatic u32 hns3_pmu_get_event(struct perf_event *event)\n{\n\treturn hns3_pmu_get_ext_counter_used(event) << 16 |\n\t       hns3_pmu_get_event_type(event) << 8 |\n\t       hns3_pmu_get_subevent(event);\n}\n\nstatic u32 hns3_pmu_get_real_event(struct perf_event *event)\n{\n\treturn hns3_pmu_get_event_type(event) << 8 |\n\t       hns3_pmu_get_subevent(event);\n}\n\nstatic u32 hns3_pmu_get_offset(u32 offset, u32 idx)\n{\n\treturn offset + HNS3_PMU_REG_EVENT_OFFSET +\n\t       HNS3_PMU_REG_EVENT_SIZE * idx;\n}\n\nstatic u32 hns3_pmu_readl(struct hns3_pmu *hns3_pmu, u32 reg_offset, u32 idx)\n{\n\tu32 offset = hns3_pmu_get_offset(reg_offset, idx);\n\n\treturn readl(hns3_pmu->base + offset);\n}\n\nstatic void hns3_pmu_writel(struct hns3_pmu *hns3_pmu, u32 reg_offset, u32 idx,\n\t\t\t    u32 val)\n{\n\tu32 offset = hns3_pmu_get_offset(reg_offset, idx);\n\n\twritel(val, hns3_pmu->base + offset);\n}\n\nstatic u64 hns3_pmu_readq(struct hns3_pmu *hns3_pmu, u32 reg_offset, u32 idx)\n{\n\tu32 offset = hns3_pmu_get_offset(reg_offset, idx);\n\n\treturn readq(hns3_pmu->base + offset);\n}\n\nstatic void hns3_pmu_writeq(struct hns3_pmu *hns3_pmu, u32 reg_offset, u32 idx,\n\t\t\t    u64 val)\n{\n\tu32 offset = hns3_pmu_get_offset(reg_offset, idx);\n\n\twriteq(val, hns3_pmu->base + offset);\n}\n\nstatic bool hns3_pmu_cmp_event(struct perf_event *target,\n\t\t\t       struct perf_event *event)\n{\n\treturn hns3_pmu_get_real_event(target) == hns3_pmu_get_real_event(event);\n}\n\nstatic int hns3_pmu_find_related_event_idx(struct hns3_pmu *hns3_pmu,\n\t\t\t\t\t   struct perf_event *event)\n{\n\tstruct perf_event *sibling;\n\tint hw_event_used = 0;\n\tint idx;\n\n\tfor (idx = 0; idx < HNS3_PMU_MAX_HW_EVENTS; idx++) {\n\t\tsibling = hns3_pmu->hw_events[idx];\n\t\tif (!sibling)\n\t\t\tcontinue;\n\n\t\thw_event_used++;\n\n\t\tif (!hns3_pmu_cmp_event(sibling, event))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sibling->group_leader == event->group_leader)\n\t\t\treturn idx;\n\t}\n\n\t \n\tif (hw_event_used >= HNS3_PMU_MAX_HW_EVENTS)\n\t\treturn -EBUSY;\n\n\t \n\treturn -ENOENT;\n}\n\nstatic int hns3_pmu_get_event_idx(struct hns3_pmu *hns3_pmu)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HNS3_PMU_MAX_HW_EVENTS; idx++) {\n\t\tif (!hns3_pmu->hw_events[idx])\n\t\t\treturn idx;\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic bool hns3_pmu_valid_bdf(struct hns3_pmu *hns3_pmu, u16 bdf)\n{\n\tstruct pci_dev *pdev;\n\n\tif (bdf < hns3_pmu->bdf_min || bdf > hns3_pmu->bdf_max) {\n\t\tpci_err(hns3_pmu->pdev, \"Invalid EP device: %#x!\\n\", bdf);\n\t\treturn false;\n\t}\n\n\tpdev = pci_get_domain_bus_and_slot(pci_domain_nr(hns3_pmu->pdev->bus),\n\t\t\t\t\t   PCI_BUS_NUM(bdf),\n\t\t\t\t\t   GET_PCI_DEVFN(bdf));\n\tif (!pdev) {\n\t\tpci_err(hns3_pmu->pdev, \"Nonexistent EP device: %#x!\\n\", bdf);\n\t\treturn false;\n\t}\n\n\tpci_dev_put(pdev);\n\treturn true;\n}\n\nstatic void hns3_pmu_set_qid_para(struct hns3_pmu *hns3_pmu, u32 idx, u16 bdf,\n\t\t\t\t  u16 queue)\n{\n\tu32 val;\n\n\tval = GET_PCI_DEVFN(bdf);\n\tval |= (u32)queue << HNS3_PMU_QID_PARA_QUEUE_S;\n\thns3_pmu_writel(hns3_pmu, HNS3_PMU_REG_EVENT_QID_PARA, idx, val);\n}\n\nstatic bool hns3_pmu_qid_req_start(struct hns3_pmu *hns3_pmu, u32 idx)\n{\n\tbool queue_id_valid = false;\n\tu32 reg_qid_ctrl, val;\n\tint err;\n\n\t \n\thns3_pmu_writel(hns3_pmu, HNS3_PMU_REG_EVENT_QID_CTRL, idx,\n\t\t\tHNS3_PMU_QID_CTRL_REQ_ENABLE);\n\n\treg_qid_ctrl = hns3_pmu_get_offset(HNS3_PMU_REG_EVENT_QID_CTRL, idx);\n\terr = readl_poll_timeout(hns3_pmu->base + reg_qid_ctrl, val,\n\t\t\t\t val & HNS3_PMU_QID_CTRL_DONE, 1, 1000);\n\tif (err == -ETIMEDOUT) {\n\t\tpci_err(hns3_pmu->pdev, \"QID request timeout!\\n\");\n\t\tgoto out;\n\t}\n\n\tqueue_id_valid = !(val & HNS3_PMU_QID_CTRL_MISS);\n\nout:\n\t \n\thns3_pmu_writel(hns3_pmu, HNS3_PMU_REG_EVENT_QID_CTRL, idx, 0);\n\n\treturn queue_id_valid;\n}\n\nstatic bool hns3_pmu_valid_queue(struct hns3_pmu *hns3_pmu, u32 idx, u16 bdf,\n\t\t\t\t u16 queue)\n{\n\thns3_pmu_set_qid_para(hns3_pmu, idx, bdf, queue);\n\n\treturn hns3_pmu_qid_req_start(hns3_pmu, idx);\n}\n\nstatic struct hns3_pmu_event_attr *hns3_pmu_get_pmu_event(u32 event)\n{\n\tstruct hns3_pmu_event_attr *pmu_event;\n\tstruct dev_ext_attribute *eattr;\n\tstruct device_attribute *dattr;\n\tstruct attribute *attr;\n\tu32 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hns3_pmu_events_attr) - 1; i++) {\n\t\tattr = hns3_pmu_events_attr[i];\n\t\tdattr = container_of(attr, struct device_attribute, attr);\n\t\teattr = container_of(dattr, struct dev_ext_attribute, attr);\n\t\tpmu_event = eattr->var;\n\n\t\tif (event == pmu_event->event)\n\t\t\treturn pmu_event;\n\t}\n\n\treturn NULL;\n}\n\nstatic int hns3_pmu_set_func_mode(struct perf_event *event,\n\t\t\t\t  struct hns3_pmu *hns3_pmu)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu16 bdf = hns3_pmu_get_bdf(event);\n\n\tif (!hns3_pmu_valid_bdf(hns3_pmu, bdf))\n\t\treturn -ENOENT;\n\n\tHNS3_PMU_SET_HW_FILTER(hwc, HNS3_PMU_HW_FILTER_FUNC);\n\n\treturn 0;\n}\n\nstatic int hns3_pmu_set_func_queue_mode(struct perf_event *event,\n\t\t\t\t\tstruct hns3_pmu *hns3_pmu)\n{\n\tu16 queue_id = hns3_pmu_get_queue(event);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu16 bdf = hns3_pmu_get_bdf(event);\n\n\tif (!hns3_pmu_valid_bdf(hns3_pmu, bdf))\n\t\treturn -ENOENT;\n\n\tif (!hns3_pmu_valid_queue(hns3_pmu, hwc->idx, bdf, queue_id)) {\n\t\tpci_err(hns3_pmu->pdev, \"Invalid queue: %u\\n\", queue_id);\n\t\treturn -ENOENT;\n\t}\n\n\tHNS3_PMU_SET_HW_FILTER(hwc, HNS3_PMU_HW_FILTER_FUNC_QUEUE);\n\n\treturn 0;\n}\n\nstatic bool\nhns3_pmu_is_enabled_global_mode(struct perf_event *event,\n\t\t\t\tstruct hns3_pmu_event_attr *pmu_event)\n{\n\tu8 global = hns3_pmu_get_global(event);\n\n\tif (!(pmu_event->filter_support & HNS3_PMU_FILTER_SUPPORT_GLOBAL))\n\t\treturn false;\n\n\treturn global;\n}\n\nstatic bool hns3_pmu_is_enabled_func_mode(struct perf_event *event,\n\t\t\t\t\t  struct hns3_pmu_event_attr *pmu_event)\n{\n\tu16 queue_id = hns3_pmu_get_queue(event);\n\tu16 bdf = hns3_pmu_get_bdf(event);\n\n\tif (!(pmu_event->filter_support & HNS3_PMU_FILTER_SUPPORT_FUNC))\n\t\treturn false;\n\telse if (queue_id != HNS3_PMU_FILTER_ALL_QUEUE)\n\t\treturn false;\n\n\treturn bdf;\n}\n\nstatic bool\nhns3_pmu_is_enabled_func_queue_mode(struct perf_event *event,\n\t\t\t\t    struct hns3_pmu_event_attr *pmu_event)\n{\n\tu16 queue_id = hns3_pmu_get_queue(event);\n\tu16 bdf = hns3_pmu_get_bdf(event);\n\n\tif (!(pmu_event->filter_support & HNS3_PMU_FILTER_SUPPORT_FUNC_QUEUE))\n\t\treturn false;\n\telse if (queue_id == HNS3_PMU_FILTER_ALL_QUEUE)\n\t\treturn false;\n\n\treturn bdf;\n}\n\nstatic bool hns3_pmu_is_enabled_port_mode(struct perf_event *event,\n\t\t\t\t\t  struct hns3_pmu_event_attr *pmu_event)\n{\n\tu8 tc_id = hns3_pmu_get_tc(event);\n\n\tif (!(pmu_event->filter_support & HNS3_PMU_FILTER_SUPPORT_PORT))\n\t\treturn false;\n\n\treturn tc_id == HNS3_PMU_FILTER_ALL_TC;\n}\n\nstatic bool\nhns3_pmu_is_enabled_port_tc_mode(struct perf_event *event,\n\t\t\t\t struct hns3_pmu_event_attr *pmu_event)\n{\n\tu8 tc_id = hns3_pmu_get_tc(event);\n\n\tif (!(pmu_event->filter_support & HNS3_PMU_FILTER_SUPPORT_PORT_TC))\n\t\treturn false;\n\n\treturn tc_id != HNS3_PMU_FILTER_ALL_TC;\n}\n\nstatic bool\nhns3_pmu_is_enabled_func_intr_mode(struct perf_event *event,\n\t\t\t\t   struct hns3_pmu *hns3_pmu,\n\t\t\t\t   struct hns3_pmu_event_attr *pmu_event)\n{\n\tu16 bdf = hns3_pmu_get_bdf(event);\n\n\tif (!(pmu_event->filter_support & HNS3_PMU_FILTER_SUPPORT_FUNC_INTR))\n\t\treturn false;\n\n\treturn hns3_pmu_valid_bdf(hns3_pmu, bdf);\n}\n\nstatic int hns3_pmu_select_filter_mode(struct perf_event *event,\n\t\t\t\t       struct hns3_pmu *hns3_pmu)\n{\n\tu32 event_id = hns3_pmu_get_event(event);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hns3_pmu_event_attr *pmu_event;\n\n\tpmu_event = hns3_pmu_get_pmu_event(event_id);\n\tif (!pmu_event) {\n\t\tpci_err(hns3_pmu->pdev, \"Invalid pmu event\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (hns3_pmu_is_enabled_global_mode(event, pmu_event)) {\n\t\tHNS3_PMU_SET_HW_FILTER(hwc, HNS3_PMU_HW_FILTER_GLOBAL);\n\t\treturn 0;\n\t}\n\n\tif (hns3_pmu_is_enabled_func_mode(event, pmu_event))\n\t\treturn hns3_pmu_set_func_mode(event, hns3_pmu);\n\n\tif (hns3_pmu_is_enabled_func_queue_mode(event, pmu_event))\n\t\treturn hns3_pmu_set_func_queue_mode(event, hns3_pmu);\n\n\tif (hns3_pmu_is_enabled_port_mode(event, pmu_event)) {\n\t\tHNS3_PMU_SET_HW_FILTER(hwc, HNS3_PMU_HW_FILTER_PORT);\n\t\treturn 0;\n\t}\n\n\tif (hns3_pmu_is_enabled_port_tc_mode(event, pmu_event)) {\n\t\tHNS3_PMU_SET_HW_FILTER(hwc, HNS3_PMU_HW_FILTER_PORT_TC);\n\t\treturn 0;\n\t}\n\n\tif (hns3_pmu_is_enabled_func_intr_mode(event, hns3_pmu, pmu_event)) {\n\t\tHNS3_PMU_SET_HW_FILTER(hwc, HNS3_PMU_HW_FILTER_FUNC_INTR);\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic bool hns3_pmu_validate_event_group(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tstruct perf_event *event_group[HNS3_PMU_MAX_HW_EVENTS];\n\tint counters = 1;\n\tint num;\n\n\tevent_group[0] = leader;\n\tif (!is_software_event(leader)) {\n\t\tif (leader->pmu != event->pmu)\n\t\t\treturn false;\n\n\t\tif (leader != event && !hns3_pmu_cmp_event(leader, event))\n\t\t\tevent_group[counters++] = event;\n\t}\n\n\tfor_each_sibling_event(sibling, event->group_leader) {\n\t\tif (is_software_event(sibling))\n\t\t\tcontinue;\n\n\t\tif (sibling->pmu != event->pmu)\n\t\t\treturn false;\n\n\t\tfor (num = 0; num < counters; num++) {\n\t\t\tif (hns3_pmu_cmp_event(event_group[num], sibling))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (num == counters)\n\t\t\tevent_group[counters++] = sibling;\n\t}\n\n\treturn counters <= HNS3_PMU_MAX_HW_EVENTS;\n}\n\nstatic u32 hns3_pmu_get_filter_condition(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu16 intr_id = hns3_pmu_get_intr(event);\n\tu8 port_id = hns3_pmu_get_port(event);\n\tu16 bdf = hns3_pmu_get_bdf(event);\n\tu8 tc_id = hns3_pmu_get_tc(event);\n\tu8 filter_mode;\n\n\tfilter_mode = *(u8 *)hwc->addr_filters;\n\tswitch (filter_mode) {\n\tcase HNS3_PMU_HW_FILTER_PORT:\n\t\treturn FILTER_CONDITION_PORT(port_id);\n\tcase HNS3_PMU_HW_FILTER_PORT_TC:\n\t\treturn FILTER_CONDITION_PORT_TC(port_id, tc_id);\n\tcase HNS3_PMU_HW_FILTER_FUNC:\n\tcase HNS3_PMU_HW_FILTER_FUNC_QUEUE:\n\t\treturn GET_PCI_DEVFN(bdf);\n\tcase HNS3_PMU_HW_FILTER_FUNC_INTR:\n\t\treturn FILTER_CONDITION_FUNC_INTR(GET_PCI_DEVFN(bdf), intr_id);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void hns3_pmu_config_filter(struct perf_event *event)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(event->pmu);\n\tu8 event_type = hns3_pmu_get_event_type(event);\n\tu8 subevent_id = hns3_pmu_get_subevent(event);\n\tu16 queue_id = hns3_pmu_get_queue(event);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu8 filter_mode = *(u8 *)hwc->addr_filters;\n\tu16 bdf = hns3_pmu_get_bdf(event);\n\tu32 idx = hwc->idx;\n\tu32 val;\n\n\tval = event_type;\n\tval |= subevent_id << HNS3_PMU_CTRL_SUBEVENT_S;\n\tval |= filter_mode << HNS3_PMU_CTRL_FILTER_MODE_S;\n\tval |= HNS3_PMU_EVENT_OVERFLOW_RESTART;\n\thns3_pmu_writel(hns3_pmu, HNS3_PMU_REG_EVENT_CTRL_LOW, idx, val);\n\n\tval = hns3_pmu_get_filter_condition(event);\n\thns3_pmu_writel(hns3_pmu, HNS3_PMU_REG_EVENT_CTRL_HIGH, idx, val);\n\n\tif (filter_mode == HNS3_PMU_HW_FILTER_FUNC_QUEUE)\n\t\thns3_pmu_set_qid_para(hns3_pmu, idx, bdf, queue_id);\n}\n\nstatic void hns3_pmu_enable_counter(struct hns3_pmu *hns3_pmu,\n\t\t\t\t    struct hw_perf_event *hwc)\n{\n\tu32 idx = hwc->idx;\n\tu32 val;\n\n\tval = hns3_pmu_readl(hns3_pmu, HNS3_PMU_REG_EVENT_CTRL_LOW, idx);\n\tval |= HNS3_PMU_EVENT_EN;\n\thns3_pmu_writel(hns3_pmu, HNS3_PMU_REG_EVENT_CTRL_LOW, idx, val);\n}\n\nstatic void hns3_pmu_disable_counter(struct hns3_pmu *hns3_pmu,\n\t\t\t\t     struct hw_perf_event *hwc)\n{\n\tu32 idx = hwc->idx;\n\tu32 val;\n\n\tval = hns3_pmu_readl(hns3_pmu, HNS3_PMU_REG_EVENT_CTRL_LOW, idx);\n\tval &= ~HNS3_PMU_EVENT_EN;\n\thns3_pmu_writel(hns3_pmu, HNS3_PMU_REG_EVENT_CTRL_LOW, idx, val);\n}\n\nstatic void hns3_pmu_enable_intr(struct hns3_pmu *hns3_pmu,\n\t\t\t\t struct hw_perf_event *hwc)\n{\n\tu32 idx = hwc->idx;\n\tu32 val;\n\n\tval = hns3_pmu_readl(hns3_pmu, HNS3_PMU_REG_EVENT_INTR_MASK, idx);\n\tval &= ~HNS3_PMU_INTR_MASK_OVERFLOW;\n\thns3_pmu_writel(hns3_pmu, HNS3_PMU_REG_EVENT_INTR_MASK, idx, val);\n}\n\nstatic void hns3_pmu_disable_intr(struct hns3_pmu *hns3_pmu,\n\t\t\t\t  struct hw_perf_event *hwc)\n{\n\tu32 idx = hwc->idx;\n\tu32 val;\n\n\tval = hns3_pmu_readl(hns3_pmu, HNS3_PMU_REG_EVENT_INTR_MASK, idx);\n\tval |= HNS3_PMU_INTR_MASK_OVERFLOW;\n\thns3_pmu_writel(hns3_pmu, HNS3_PMU_REG_EVENT_INTR_MASK, idx, val);\n}\n\nstatic void hns3_pmu_clear_intr_status(struct hns3_pmu *hns3_pmu, u32 idx)\n{\n\tu32 val;\n\n\tval = hns3_pmu_readl(hns3_pmu, HNS3_PMU_REG_EVENT_CTRL_LOW, idx);\n\tval |= HNS3_PMU_EVENT_STATUS_RESET;\n\thns3_pmu_writel(hns3_pmu, HNS3_PMU_REG_EVENT_CTRL_LOW, idx, val);\n\n\tval = hns3_pmu_readl(hns3_pmu, HNS3_PMU_REG_EVENT_CTRL_LOW, idx);\n\tval &= ~HNS3_PMU_EVENT_STATUS_RESET;\n\thns3_pmu_writel(hns3_pmu, HNS3_PMU_REG_EVENT_CTRL_LOW, idx, val);\n}\n\nstatic u64 hns3_pmu_read_counter(struct perf_event *event)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(event->pmu);\n\n\treturn hns3_pmu_readq(hns3_pmu, event->hw.event_base, event->hw.idx);\n}\n\nstatic void hns3_pmu_write_counter(struct perf_event *event, u64 value)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(event->pmu);\n\tu32 idx = event->hw.idx;\n\n\thns3_pmu_writeq(hns3_pmu, HNS3_PMU_REG_EVENT_COUNTER, idx, value);\n\thns3_pmu_writeq(hns3_pmu, HNS3_PMU_REG_EVENT_EXT_COUNTER, idx, value);\n}\n\nstatic void hns3_pmu_init_counter(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tlocal64_set(&hwc->prev_count, 0);\n\thns3_pmu_write_counter(event, 0);\n}\n\nstatic int hns3_pmu_event_init(struct perf_event *event)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx;\n\tint ret;\n\n\tif (event->attr.type != event->pmu->type)\n\t\treturn -ENOENT;\n\n\t \n\tif (is_sampling_event(event) || event->attach_state & PERF_ATTACH_TASK)\n\t\treturn -EOPNOTSUPP;\n\n\tevent->cpu = hns3_pmu->on_cpu;\n\n\tidx = hns3_pmu_get_event_idx(hns3_pmu);\n\tif (idx < 0) {\n\t\tpci_err(hns3_pmu->pdev, \"Up to %u events are supported!\\n\",\n\t\t\tHNS3_PMU_MAX_HW_EVENTS);\n\t\treturn -EBUSY;\n\t}\n\n\thwc->idx = idx;\n\n\tret = hns3_pmu_select_filter_mode(event, hns3_pmu);\n\tif (ret) {\n\t\tpci_err(hns3_pmu->pdev, \"Invalid filter, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!hns3_pmu_validate_event_group(event)) {\n\t\tpci_err(hns3_pmu->pdev, \"Invalid event group.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hns3_pmu_get_ext_counter_used(event))\n\t\thwc->event_base = HNS3_PMU_REG_EVENT_EXT_COUNTER;\n\telse\n\t\thwc->event_base = HNS3_PMU_REG_EVENT_COUNTER;\n\n\treturn 0;\n}\n\nstatic void hns3_pmu_read(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 new_cnt, prev_cnt, delta;\n\n\tdo {\n\t\tprev_cnt = local64_read(&hwc->prev_count);\n\t\tnew_cnt = hns3_pmu_read_counter(event);\n\t} while (local64_cmpxchg(&hwc->prev_count, prev_cnt, new_cnt) !=\n\t\t prev_cnt);\n\n\tdelta = new_cnt - prev_cnt;\n\tlocal64_add(delta, &event->count);\n}\n\nstatic void hns3_pmu_start(struct perf_event *event, int flags)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (WARN_ON_ONCE(!(hwc->state & PERF_HES_STOPPED)))\n\t\treturn;\n\n\tWARN_ON_ONCE(!(hwc->state & PERF_HES_UPTODATE));\n\thwc->state = 0;\n\n\thns3_pmu_config_filter(event);\n\thns3_pmu_init_counter(event);\n\thns3_pmu_enable_intr(hns3_pmu, hwc);\n\thns3_pmu_enable_counter(hns3_pmu, hwc);\n\n\tperf_event_update_userpage(event);\n}\n\nstatic void hns3_pmu_stop(struct perf_event *event, int flags)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\thns3_pmu_disable_counter(hns3_pmu, hwc);\n\thns3_pmu_disable_intr(hns3_pmu, hwc);\n\n\tWARN_ON_ONCE(hwc->state & PERF_HES_STOPPED);\n\thwc->state |= PERF_HES_STOPPED;\n\n\tif (hwc->state & PERF_HES_UPTODATE)\n\t\treturn;\n\n\t \n\thns3_pmu_read(event);\n\thwc->state |= PERF_HES_UPTODATE;\n}\n\nstatic int hns3_pmu_add(struct perf_event *event, int flags)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx;\n\n\thwc->state = PERF_HES_STOPPED | PERF_HES_UPTODATE;\n\n\t \n\tidx = hns3_pmu_find_related_event_idx(hns3_pmu, event);\n\tif (idx < 0 && idx != -ENOENT)\n\t\treturn idx;\n\n\t \n\tif (idx >= 0 && idx < HNS3_PMU_MAX_HW_EVENTS) {\n\t\thwc->idx = idx;\n\t\tgoto start_count;\n\t}\n\n\tidx = hns3_pmu_get_event_idx(hns3_pmu);\n\tif (idx < 0)\n\t\treturn idx;\n\n\thwc->idx = idx;\n\thns3_pmu->hw_events[idx] = event;\n\nstart_count:\n\tif (flags & PERF_EF_START)\n\t\thns3_pmu_start(event, PERF_EF_RELOAD);\n\n\treturn 0;\n}\n\nstatic void hns3_pmu_del(struct perf_event *event, int flags)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\thns3_pmu_stop(event, PERF_EF_UPDATE);\n\thns3_pmu->hw_events[hwc->idx] = NULL;\n\tperf_event_update_userpage(event);\n}\n\nstatic void hns3_pmu_enable(struct pmu *pmu)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(pmu);\n\tu32 val;\n\n\tval = readl(hns3_pmu->base + HNS3_PMU_REG_GLOBAL_CTRL);\n\tval |= HNS3_PMU_GLOBAL_START;\n\twritel(val, hns3_pmu->base + HNS3_PMU_REG_GLOBAL_CTRL);\n}\n\nstatic void hns3_pmu_disable(struct pmu *pmu)\n{\n\tstruct hns3_pmu *hns3_pmu = to_hns3_pmu(pmu);\n\tu32 val;\n\n\tval = readl(hns3_pmu->base + HNS3_PMU_REG_GLOBAL_CTRL);\n\tval &= ~HNS3_PMU_GLOBAL_START;\n\twritel(val, hns3_pmu->base + HNS3_PMU_REG_GLOBAL_CTRL);\n}\n\nstatic int hns3_pmu_alloc_pmu(struct pci_dev *pdev, struct hns3_pmu *hns3_pmu)\n{\n\tu16 device_id;\n\tchar *name;\n\tu32 val;\n\n\thns3_pmu->base = pcim_iomap_table(pdev)[BAR_2];\n\tif (!hns3_pmu->base) {\n\t\tpci_err(pdev, \"ioremap failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thns3_pmu->hw_clk_freq = readl(hns3_pmu->base + HNS3_PMU_REG_CLOCK_FREQ);\n\n\tval = readl(hns3_pmu->base + HNS3_PMU_REG_BDF);\n\thns3_pmu->bdf_min = val & 0xffff;\n\thns3_pmu->bdf_max = val >> 16;\n\n\tval = readl(hns3_pmu->base + HNS3_PMU_REG_DEVICE_ID);\n\tdevice_id = val & 0xffff;\n\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"hns3_pmu_sicl_%u\", device_id);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\thns3_pmu->pdev = pdev;\n\thns3_pmu->on_cpu = -1;\n\thns3_pmu->identifier = readl(hns3_pmu->base + HNS3_PMU_REG_VERSION);\n\thns3_pmu->pmu = (struct pmu) {\n\t\t.name\t\t= name,\n\t\t.module\t\t= THIS_MODULE,\n\t\t.event_init\t= hns3_pmu_event_init,\n\t\t.pmu_enable\t= hns3_pmu_enable,\n\t\t.pmu_disable\t= hns3_pmu_disable,\n\t\t.add\t\t= hns3_pmu_add,\n\t\t.del\t\t= hns3_pmu_del,\n\t\t.start\t\t= hns3_pmu_start,\n\t\t.stop\t\t= hns3_pmu_stop,\n\t\t.read\t\t= hns3_pmu_read,\n\t\t.task_ctx_nr\t= perf_invalid_context,\n\t\t.attr_groups\t= hns3_pmu_attr_groups,\n\t\t.capabilities\t= PERF_PMU_CAP_NO_EXCLUDE,\n\t};\n\n\treturn 0;\n}\n\nstatic irqreturn_t hns3_pmu_irq(int irq, void *data)\n{\n\tstruct hns3_pmu *hns3_pmu = data;\n\tu32 intr_status, idx;\n\n\tfor (idx = 0; idx < HNS3_PMU_MAX_HW_EVENTS; idx++) {\n\t\tintr_status = hns3_pmu_readl(hns3_pmu,\n\t\t\t\t\t     HNS3_PMU_REG_EVENT_INTR_STATUS,\n\t\t\t\t\t     idx);\n\n\t\t \n\t\tif (intr_status)\n\t\t\thns3_pmu_clear_intr_status(hns3_pmu, idx);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int hns3_pmu_online_cpu(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct hns3_pmu *hns3_pmu;\n\n\thns3_pmu = hlist_entry_safe(node, struct hns3_pmu, node);\n\tif (!hns3_pmu)\n\t\treturn -ENODEV;\n\n\tif (hns3_pmu->on_cpu == -1) {\n\t\thns3_pmu->on_cpu = cpu;\n\t\tirq_set_affinity(hns3_pmu->irq, cpumask_of(cpu));\n\t}\n\n\treturn 0;\n}\n\nstatic int hns3_pmu_offline_cpu(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct hns3_pmu *hns3_pmu;\n\tunsigned int target;\n\n\thns3_pmu = hlist_entry_safe(node, struct hns3_pmu, node);\n\tif (!hns3_pmu)\n\t\treturn -ENODEV;\n\n\t \n\tif (hns3_pmu->on_cpu != cpu)\n\t\treturn 0;\n\n\t \n\ttarget = cpumask_any_but(cpu_online_mask, cpu);\n\tif (target >= nr_cpu_ids)\n\t\treturn 0;\n\n\tperf_pmu_migrate_context(&hns3_pmu->pmu, cpu, target);\n\thns3_pmu->on_cpu = target;\n\tirq_set_affinity(hns3_pmu->irq, cpumask_of(target));\n\n\treturn 0;\n}\n\nstatic void hns3_pmu_free_irq(void *data)\n{\n\tstruct pci_dev *pdev = data;\n\n\tpci_free_irq_vectors(pdev);\n}\n\nstatic int hns3_pmu_irq_register(struct pci_dev *pdev,\n\t\t\t\t struct hns3_pmu *hns3_pmu)\n{\n\tint irq, ret;\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tif (ret < 0) {\n\t\tpci_err(pdev, \"failed to enable MSI vectors, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action(&pdev->dev, hns3_pmu_free_irq, pdev);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to add free irq action, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tirq = pci_irq_vector(pdev, 0);\n\tret = devm_request_irq(&pdev->dev, irq, hns3_pmu_irq, 0,\n\t\t\t       hns3_pmu->pmu.name, hns3_pmu);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to register irq, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thns3_pmu->irq = irq;\n\n\treturn 0;\n}\n\nstatic int hns3_pmu_init_pmu(struct pci_dev *pdev, struct hns3_pmu *hns3_pmu)\n{\n\tint ret;\n\n\tret = hns3_pmu_alloc_pmu(pdev, hns3_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hns3_pmu_irq_register(pdev, hns3_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cpuhp_state_add_instance(CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE,\n\t\t\t\t       &hns3_pmu->node);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to register hotplug, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = perf_pmu_register(&hns3_pmu->pmu, hns3_pmu->pmu.name, -1);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to register perf PMU, ret = %d.\\n\", ret);\n\t\tcpuhp_state_remove_instance_nocalls(CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE,\n\t\t\t\t\t\t    &hns3_pmu->node);\n\t}\n\n\treturn ret;\n}\n\nstatic void hns3_pmu_uninit_pmu(struct pci_dev *pdev)\n{\n\tstruct hns3_pmu *hns3_pmu = pci_get_drvdata(pdev);\n\n\tperf_pmu_unregister(&hns3_pmu->pmu);\n\tcpuhp_state_remove_instance_nocalls(CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE,\n\t\t\t\t\t    &hns3_pmu->node);\n}\n\nstatic int hns3_pmu_init_dev(struct pci_dev *pdev)\n{\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to enable pci device, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pcim_iomap_regions(pdev, BIT(BAR_2), \"hns3_pmu\");\n\tif (ret < 0) {\n\t\tpci_err(pdev, \"failed to request pci region, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpci_set_master(pdev);\n\n\treturn 0;\n}\n\nstatic int hns3_pmu_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct hns3_pmu *hns3_pmu;\n\tint ret;\n\n\thns3_pmu = devm_kzalloc(&pdev->dev, sizeof(*hns3_pmu), GFP_KERNEL);\n\tif (!hns3_pmu)\n\t\treturn -ENOMEM;\n\n\tret = hns3_pmu_init_dev(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hns3_pmu_init_pmu(pdev, hns3_pmu);\n\tif (ret) {\n\t\tpci_clear_master(pdev);\n\t\treturn ret;\n\t}\n\n\tpci_set_drvdata(pdev, hns3_pmu);\n\n\treturn ret;\n}\n\nstatic void hns3_pmu_remove(struct pci_dev *pdev)\n{\n\thns3_pmu_uninit_pmu(pdev);\n\tpci_clear_master(pdev);\n\tpci_set_drvdata(pdev, NULL);\n}\n\nstatic const struct pci_device_id hns3_pmu_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HUAWEI, 0xa22b) },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, hns3_pmu_ids);\n\nstatic struct pci_driver hns3_pmu_driver = {\n\t.name = \"hns3_pmu\",\n\t.id_table = hns3_pmu_ids,\n\t.probe = hns3_pmu_probe,\n\t.remove = hns3_pmu_remove,\n};\n\nstatic int __init hns3_pmu_module_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE,\n\t\t\t\t      \"AP_PERF_ARM_HNS3_PMU_ONLINE\",\n\t\t\t\t      hns3_pmu_online_cpu,\n\t\t\t\t      hns3_pmu_offline_cpu);\n\tif (ret) {\n\t\tpr_err(\"failed to setup HNS3 PMU hotplug, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pci_register_driver(&hns3_pmu_driver);\n\tif (ret) {\n\t\tpr_err(\"failed to register pci driver, ret = %d.\\n\", ret);\n\t\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE);\n\t}\n\n\treturn ret;\n}\nmodule_init(hns3_pmu_module_init);\n\nstatic void __exit hns3_pmu_module_exit(void)\n{\n\tpci_unregister_driver(&hns3_pmu_driver);\n\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE);\n}\nmodule_exit(hns3_pmu_module_exit);\n\nMODULE_DESCRIPTION(\"HNS3 PMU driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}