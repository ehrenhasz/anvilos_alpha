{
  "module_name": "hisi_uncore_pa_pmu.c",
  "hash_id": "f6f5e24e5a46eeeabfae753d49a21d34fabaaa750a06c7c3eb67a5ed0bec5a30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/hisilicon/hisi_uncore_pa_pmu.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/cpuhotplug.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/list.h>\n#include <linux/smp.h>\n\n#include \"hisi_uncore_pmu.h\"\n\n \n#define PA_PERF_CTRL\t\t\t0x1c00\n#define PA_EVENT_CTRL\t\t\t0x1c04\n#define PA_TT_CTRL\t\t\t0x1c08\n#define PA_TGTID_CTRL\t\t\t0x1c14\n#define PA_SRCID_CTRL\t\t\t0x1c18\n\n \n#define PA_INT_MASK\t\t\t0x1c70\n#define PA_INT_STATUS\t\t\t0x1c78\n#define PA_INT_CLEAR\t\t\t0x1c7c\n\n#define H60PA_INT_STATUS\t\t0x1c70\n#define H60PA_INT_MASK\t\t\t0x1c74\n\n#define PA_EVENT_TYPE0\t\t\t0x1c80\n#define PA_PMU_VERSION\t\t\t0x1cf0\n#define PA_EVENT_CNT0_L\t\t\t0x1d00\n\n#define PA_EVTYPE_MASK\t\t\t0xff\n#define PA_NR_COUNTERS\t\t\t0x8\n#define PA_PERF_CTRL_EN\t\t\tBIT(0)\n#define PA_TRACETAG_EN\t\t\tBIT(4)\n#define PA_TGTID_EN\t\t\tBIT(11)\n#define PA_SRCID_EN\t\t\tBIT(11)\n#define PA_TGTID_NONE\t\t\t0\n#define PA_SRCID_NONE\t\t\t0\n#define PA_TGTID_MSK_SHIFT\t\t12\n#define PA_SRCID_MSK_SHIFT\t\t12\n\nHISI_PMU_EVENT_ATTR_EXTRACTOR(tgtid_cmd, config1, 10, 0);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(tgtid_msk, config1, 21, 11);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(srcid_cmd, config1, 32, 22);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(srcid_msk, config1, 43, 33);\nHISI_PMU_EVENT_ATTR_EXTRACTOR(tracetag_en, config1, 44, 44);\n\nstruct hisi_pa_pmu_int_regs {\n\tu32 mask_offset;\n\tu32 clear_offset;\n\tu32 status_offset;\n};\n\nstatic void hisi_pa_pmu_enable_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *pa_pmu = to_hisi_pmu(event->pmu);\n\tu32 tt_en = hisi_get_tracetag_en(event);\n\n\tif (tt_en) {\n\t\tu32 val;\n\n\t\tval = readl(pa_pmu->base + PA_TT_CTRL);\n\t\tval |= PA_TRACETAG_EN;\n\t\twritel(val, pa_pmu->base + PA_TT_CTRL);\n\t}\n}\n\nstatic void hisi_pa_pmu_clear_tracetag(struct perf_event *event)\n{\n\tstruct hisi_pmu *pa_pmu = to_hisi_pmu(event->pmu);\n\tu32 tt_en = hisi_get_tracetag_en(event);\n\n\tif (tt_en) {\n\t\tu32 val;\n\n\t\tval = readl(pa_pmu->base + PA_TT_CTRL);\n\t\tval &= ~PA_TRACETAG_EN;\n\t\twritel(val, pa_pmu->base + PA_TT_CTRL);\n\t}\n}\n\nstatic void hisi_pa_pmu_config_tgtid(struct perf_event *event)\n{\n\tstruct hisi_pmu *pa_pmu = to_hisi_pmu(event->pmu);\n\tu32 cmd = hisi_get_tgtid_cmd(event);\n\n\tif (cmd) {\n\t\tu32 msk = hisi_get_tgtid_msk(event);\n\t\tu32 val = cmd | PA_TGTID_EN | (msk << PA_TGTID_MSK_SHIFT);\n\n\t\twritel(val, pa_pmu->base + PA_TGTID_CTRL);\n\t}\n}\n\nstatic void hisi_pa_pmu_clear_tgtid(struct perf_event *event)\n{\n\tstruct hisi_pmu *pa_pmu = to_hisi_pmu(event->pmu);\n\tu32 cmd = hisi_get_tgtid_cmd(event);\n\n\tif (cmd)\n\t\twritel(PA_TGTID_NONE, pa_pmu->base + PA_TGTID_CTRL);\n}\n\nstatic void hisi_pa_pmu_config_srcid(struct perf_event *event)\n{\n\tstruct hisi_pmu *pa_pmu = to_hisi_pmu(event->pmu);\n\tu32 cmd = hisi_get_srcid_cmd(event);\n\n\tif (cmd) {\n\t\tu32 msk = hisi_get_srcid_msk(event);\n\t\tu32 val = cmd | PA_SRCID_EN | (msk << PA_SRCID_MSK_SHIFT);\n\n\t\twritel(val, pa_pmu->base + PA_SRCID_CTRL);\n\t}\n}\n\nstatic void hisi_pa_pmu_clear_srcid(struct perf_event *event)\n{\n\tstruct hisi_pmu *pa_pmu = to_hisi_pmu(event->pmu);\n\tu32 cmd = hisi_get_srcid_cmd(event);\n\n\tif (cmd)\n\t\twritel(PA_SRCID_NONE, pa_pmu->base + PA_SRCID_CTRL);\n}\n\nstatic void hisi_pa_pmu_enable_filter(struct perf_event *event)\n{\n\tif (event->attr.config1 != 0x0) {\n\t\thisi_pa_pmu_enable_tracetag(event);\n\t\thisi_pa_pmu_config_srcid(event);\n\t\thisi_pa_pmu_config_tgtid(event);\n\t}\n}\n\nstatic void hisi_pa_pmu_disable_filter(struct perf_event *event)\n{\n\tif (event->attr.config1 != 0x0) {\n\t\thisi_pa_pmu_clear_tgtid(event);\n\t\thisi_pa_pmu_clear_srcid(event);\n\t\thisi_pa_pmu_clear_tracetag(event);\n\t}\n}\n\nstatic u32 hisi_pa_pmu_get_counter_offset(int idx)\n{\n\treturn (PA_EVENT_CNT0_L + idx * 8);\n}\n\nstatic u64 hisi_pa_pmu_read_counter(struct hisi_pmu *pa_pmu,\n\t\t\t\t    struct hw_perf_event *hwc)\n{\n\treturn readq(pa_pmu->base + hisi_pa_pmu_get_counter_offset(hwc->idx));\n}\n\nstatic void hisi_pa_pmu_write_counter(struct hisi_pmu *pa_pmu,\n\t\t\t\t      struct hw_perf_event *hwc, u64 val)\n{\n\twriteq(val, pa_pmu->base + hisi_pa_pmu_get_counter_offset(hwc->idx));\n}\n\nstatic void hisi_pa_pmu_write_evtype(struct hisi_pmu *pa_pmu, int idx,\n\t\t\t\t     u32 type)\n{\n\tu32 reg, reg_idx, shift, val;\n\n\t \n\treg = PA_EVENT_TYPE0 + (idx / 4) * 4;\n\treg_idx = idx % 4;\n\tshift = 8 * reg_idx;\n\n\t \n\tval = readl(pa_pmu->base + reg);\n\tval &= ~(PA_EVTYPE_MASK << shift);\n\tval |= (type << shift);\n\twritel(val, pa_pmu->base + reg);\n}\n\nstatic void hisi_pa_pmu_start_counters(struct hisi_pmu *pa_pmu)\n{\n\tu32 val;\n\n\tval = readl(pa_pmu->base + PA_PERF_CTRL);\n\tval |= PA_PERF_CTRL_EN;\n\twritel(val, pa_pmu->base + PA_PERF_CTRL);\n}\n\nstatic void hisi_pa_pmu_stop_counters(struct hisi_pmu *pa_pmu)\n{\n\tu32 val;\n\n\tval = readl(pa_pmu->base + PA_PERF_CTRL);\n\tval &= ~(PA_PERF_CTRL_EN);\n\twritel(val, pa_pmu->base + PA_PERF_CTRL);\n}\n\nstatic void hisi_pa_pmu_enable_counter(struct hisi_pmu *pa_pmu,\n\t\t\t\t       struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(pa_pmu->base + PA_EVENT_CTRL);\n\tval |= 1 << hwc->idx;\n\twritel(val, pa_pmu->base + PA_EVENT_CTRL);\n}\n\nstatic void hisi_pa_pmu_disable_counter(struct hisi_pmu *pa_pmu,\n\t\t\t\t\tstruct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(pa_pmu->base + PA_EVENT_CTRL);\n\tval &= ~(1 << hwc->idx);\n\twritel(val, pa_pmu->base + PA_EVENT_CTRL);\n}\n\nstatic void hisi_pa_pmu_enable_counter_int(struct hisi_pmu *pa_pmu,\n\t\t\t\t\t   struct hw_perf_event *hwc)\n{\n\tstruct hisi_pa_pmu_int_regs *regs = pa_pmu->dev_info->private;\n\tu32 val;\n\n\t \n\tval = readl(pa_pmu->base + regs->mask_offset);\n\tval &= ~(1 << hwc->idx);\n\twritel(val, pa_pmu->base + regs->mask_offset);\n}\n\nstatic void hisi_pa_pmu_disable_counter_int(struct hisi_pmu *pa_pmu,\n\t\t\t\t\t    struct hw_perf_event *hwc)\n{\n\tstruct hisi_pa_pmu_int_regs *regs = pa_pmu->dev_info->private;\n\tu32 val;\n\n\t \n\tval = readl(pa_pmu->base + regs->mask_offset);\n\tval |= 1 << hwc->idx;\n\twritel(val, pa_pmu->base + regs->mask_offset);\n}\n\nstatic u32 hisi_pa_pmu_get_int_status(struct hisi_pmu *pa_pmu)\n{\n\tstruct hisi_pa_pmu_int_regs *regs = pa_pmu->dev_info->private;\n\n\treturn readl(pa_pmu->base + regs->status_offset);\n}\n\nstatic void hisi_pa_pmu_clear_int_status(struct hisi_pmu *pa_pmu, int idx)\n{\n\tstruct hisi_pa_pmu_int_regs *regs = pa_pmu->dev_info->private;\n\n\twritel(1 << idx, pa_pmu->base + regs->clear_offset);\n}\n\nstatic int hisi_pa_pmu_init_data(struct platform_device *pdev,\n\t\t\t\t   struct hisi_pmu *pa_pmu)\n{\n\t \n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,scl-id\",\n\t\t\t\t     &pa_pmu->sicl_id)) {\n\t\tdev_err(&pdev->dev, \"Cannot read sicl-id!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,idx-id\",\n\t\t\t\t     &pa_pmu->index_id)) {\n\t\tdev_err(&pdev->dev, \"Cannot read idx-id!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpa_pmu->ccl_id = -1;\n\tpa_pmu->sccl_id = -1;\n\n\tpa_pmu->dev_info = device_get_match_data(&pdev->dev);\n\tif (!pa_pmu->dev_info)\n\t\treturn -ENODEV;\n\n\tpa_pmu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pa_pmu->base)) {\n\t\tdev_err(&pdev->dev, \"ioremap failed for pa_pmu resource.\\n\");\n\t\treturn PTR_ERR(pa_pmu->base);\n\t}\n\n\tpa_pmu->identifier = readl(pa_pmu->base + PA_PMU_VERSION);\n\n\treturn 0;\n}\n\nstatic struct attribute *hisi_pa_pmu_v2_format_attr[] = {\n\tHISI_PMU_FORMAT_ATTR(event, \"config:0-7\"),\n\tHISI_PMU_FORMAT_ATTR(tgtid_cmd, \"config1:0-10\"),\n\tHISI_PMU_FORMAT_ATTR(tgtid_msk, \"config1:11-21\"),\n\tHISI_PMU_FORMAT_ATTR(srcid_cmd, \"config1:22-32\"),\n\tHISI_PMU_FORMAT_ATTR(srcid_msk, \"config1:33-43\"),\n\tHISI_PMU_FORMAT_ATTR(tracetag_en, \"config1:44\"),\n\tNULL,\n};\n\nstatic const struct attribute_group hisi_pa_pmu_v2_format_group = {\n\t.name = \"format\",\n\t.attrs = hisi_pa_pmu_v2_format_attr,\n};\n\nstatic struct attribute *hisi_pa_pmu_v2_events_attr[] = {\n\tHISI_PMU_EVENT_ATTR(rx_req,\t\t0x40),\n\tHISI_PMU_EVENT_ATTR(tx_req,             0x5c),\n\tHISI_PMU_EVENT_ATTR(cycle,\t\t0x78),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_pa_pmu_v2_events_group = {\n\t.name = \"events\",\n\t.attrs = hisi_pa_pmu_v2_events_attr,\n};\n\nstatic struct attribute *hisi_pa_pmu_v3_events_attr[] = {\n\tHISI_PMU_EVENT_ATTR(tx_req,\t0x0),\n\tHISI_PMU_EVENT_ATTR(tx_dat,\t0x1),\n\tHISI_PMU_EVENT_ATTR(tx_snp,\t0x2),\n\tHISI_PMU_EVENT_ATTR(rx_req,\t0x7),\n\tHISI_PMU_EVENT_ATTR(rx_dat,\t0x8),\n\tHISI_PMU_EVENT_ATTR(rx_snp,\t0x9),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_pa_pmu_v3_events_group = {\n\t.name = \"events\",\n\t.attrs = hisi_pa_pmu_v3_events_attr,\n};\n\nstatic struct attribute *hisi_h60pa_pmu_events_attr[] = {\n\tHISI_PMU_EVENT_ATTR(rx_flit,\t0x50),\n\tHISI_PMU_EVENT_ATTR(tx_flit,\t0x65),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_h60pa_pmu_events_group = {\n\t.name = \"events\",\n\t.attrs = hisi_h60pa_pmu_events_attr,\n};\n\nstatic DEVICE_ATTR(cpumask, 0444, hisi_cpumask_sysfs_show, NULL);\n\nstatic struct attribute *hisi_pa_pmu_cpumask_attrs[] = {\n\t&dev_attr_cpumask.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hisi_pa_pmu_cpumask_attr_group = {\n\t.attrs = hisi_pa_pmu_cpumask_attrs,\n};\n\nstatic struct device_attribute hisi_pa_pmu_identifier_attr =\n\t__ATTR(identifier, 0444, hisi_uncore_pmu_identifier_attr_show, NULL);\n\nstatic struct attribute *hisi_pa_pmu_identifier_attrs[] = {\n\t&hisi_pa_pmu_identifier_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hisi_pa_pmu_identifier_group = {\n\t.attrs = hisi_pa_pmu_identifier_attrs,\n};\n\nstatic struct hisi_pa_pmu_int_regs hisi_pa_pmu_regs = {\n\t.mask_offset = PA_INT_MASK,\n\t.clear_offset = PA_INT_CLEAR,\n\t.status_offset = PA_INT_STATUS,\n};\n\nstatic const struct attribute_group *hisi_pa_pmu_v2_attr_groups[] = {\n\t&hisi_pa_pmu_v2_format_group,\n\t&hisi_pa_pmu_v2_events_group,\n\t&hisi_pa_pmu_cpumask_attr_group,\n\t&hisi_pa_pmu_identifier_group,\n\tNULL\n};\n\nstatic const struct hisi_pmu_dev_info hisi_h32pa_v2 = {\n\t.name = \"pa\",\n\t.attr_groups = hisi_pa_pmu_v2_attr_groups,\n\t.private = &hisi_pa_pmu_regs,\n};\n\nstatic const struct attribute_group *hisi_pa_pmu_v3_attr_groups[] = {\n\t&hisi_pa_pmu_v2_format_group,\n\t&hisi_pa_pmu_v3_events_group,\n\t&hisi_pa_pmu_cpumask_attr_group,\n\t&hisi_pa_pmu_identifier_group,\n\tNULL\n};\n\nstatic const struct hisi_pmu_dev_info hisi_h32pa_v3 = {\n\t.name = \"pa\",\n\t.attr_groups = hisi_pa_pmu_v3_attr_groups,\n\t.private = &hisi_pa_pmu_regs,\n};\n\nstatic struct hisi_pa_pmu_int_regs hisi_h60pa_pmu_regs = {\n\t.mask_offset = H60PA_INT_MASK,\n\t.clear_offset = H60PA_INT_STATUS,  \n\t.status_offset = H60PA_INT_STATUS,\n};\n\nstatic const struct attribute_group *hisi_h60pa_pmu_attr_groups[] = {\n\t&hisi_pa_pmu_v2_format_group,\n\t&hisi_h60pa_pmu_events_group,\n\t&hisi_pa_pmu_cpumask_attr_group,\n\t&hisi_pa_pmu_identifier_group,\n\tNULL\n};\n\nstatic const struct hisi_pmu_dev_info hisi_h60pa = {\n\t.name = \"h60pa\",\n\t.attr_groups = hisi_h60pa_pmu_attr_groups,\n\t.private = &hisi_h60pa_pmu_regs,\n};\n\nstatic const struct hisi_uncore_ops hisi_uncore_pa_ops = {\n\t.write_evtype\t\t= hisi_pa_pmu_write_evtype,\n\t.get_event_idx\t\t= hisi_uncore_pmu_get_event_idx,\n\t.start_counters\t\t= hisi_pa_pmu_start_counters,\n\t.stop_counters\t\t= hisi_pa_pmu_stop_counters,\n\t.enable_counter\t\t= hisi_pa_pmu_enable_counter,\n\t.disable_counter\t= hisi_pa_pmu_disable_counter,\n\t.enable_counter_int\t= hisi_pa_pmu_enable_counter_int,\n\t.disable_counter_int\t= hisi_pa_pmu_disable_counter_int,\n\t.write_counter\t\t= hisi_pa_pmu_write_counter,\n\t.read_counter\t\t= hisi_pa_pmu_read_counter,\n\t.get_int_status\t\t= hisi_pa_pmu_get_int_status,\n\t.clear_int_status\t= hisi_pa_pmu_clear_int_status,\n\t.enable_filter\t\t= hisi_pa_pmu_enable_filter,\n\t.disable_filter\t\t= hisi_pa_pmu_disable_filter,\n};\n\nstatic int hisi_pa_pmu_dev_probe(struct platform_device *pdev,\n\t\t\t\t struct hisi_pmu *pa_pmu)\n{\n\tint ret;\n\n\tret = hisi_pa_pmu_init_data(pdev, pa_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_uncore_pmu_init_irq(pa_pmu, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpa_pmu->pmu_events.attr_groups = pa_pmu->dev_info->attr_groups;\n\tpa_pmu->num_counters = PA_NR_COUNTERS;\n\tpa_pmu->ops = &hisi_uncore_pa_ops;\n\tpa_pmu->check_event = 0xB0;\n\tpa_pmu->counter_bits = 64;\n\tpa_pmu->dev = &pdev->dev;\n\tpa_pmu->on_cpu = -1;\n\n\treturn 0;\n}\n\nstatic int hisi_pa_pmu_probe(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *pa_pmu;\n\tchar *name;\n\tint ret;\n\n\tpa_pmu = devm_kzalloc(&pdev->dev, sizeof(*pa_pmu), GFP_KERNEL);\n\tif (!pa_pmu)\n\t\treturn -ENOMEM;\n\n\tret = hisi_pa_pmu_dev_probe(pdev, pa_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"hisi_sicl%d_%s%u\",\n\t\t\t      pa_pmu->sicl_id, pa_pmu->dev_info->name,\n\t\t\t      pa_pmu->index_id);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = cpuhp_state_add_instance(CPUHP_AP_PERF_ARM_HISI_PA_ONLINE,\n\t\t\t\t       &pa_pmu->node);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error %d registering hotplug\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thisi_pmu_init(pa_pmu, THIS_MODULE);\n\tret = perf_pmu_register(&pa_pmu->pmu, name, -1);\n\tif (ret) {\n\t\tdev_err(pa_pmu->dev, \"PMU register failed, ret = %d\\n\", ret);\n\t\tcpuhp_state_remove_instance_nocalls(CPUHP_AP_PERF_ARM_HISI_PA_ONLINE,\n\t\t\t\t\t\t    &pa_pmu->node);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, pa_pmu);\n\treturn ret;\n}\n\nstatic int hisi_pa_pmu_remove(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *pa_pmu = platform_get_drvdata(pdev);\n\n\tperf_pmu_unregister(&pa_pmu->pmu);\n\tcpuhp_state_remove_instance_nocalls(CPUHP_AP_PERF_ARM_HISI_PA_ONLINE,\n\t\t\t\t\t    &pa_pmu->node);\n\treturn 0;\n}\n\nstatic const struct acpi_device_id hisi_pa_pmu_acpi_match[] = {\n\t{ \"HISI0273\", (kernel_ulong_t)&hisi_h32pa_v2 },\n\t{ \"HISI0275\", (kernel_ulong_t)&hisi_h32pa_v3 },\n\t{ \"HISI0274\", (kernel_ulong_t)&hisi_h60pa },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, hisi_pa_pmu_acpi_match);\n\nstatic struct platform_driver hisi_pa_pmu_driver = {\n\t.driver = {\n\t\t.name = \"hisi_pa_pmu\",\n\t\t.acpi_match_table = hisi_pa_pmu_acpi_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = hisi_pa_pmu_probe,\n\t.remove = hisi_pa_pmu_remove,\n};\n\nstatic int __init hisi_pa_pmu_module_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_PERF_ARM_HISI_PA_ONLINE,\n\t\t\t\t      \"AP_PERF_ARM_HISI_PA_ONLINE\",\n\t\t\t\t      hisi_uncore_pmu_online_cpu,\n\t\t\t\t      hisi_uncore_pmu_offline_cpu);\n\tif (ret) {\n\t\tpr_err(\"PA PMU: cpuhp state setup failed, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&hisi_pa_pmu_driver);\n\tif (ret)\n\t\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HISI_PA_ONLINE);\n\n\treturn ret;\n}\nmodule_init(hisi_pa_pmu_module_init);\n\nstatic void __exit hisi_pa_pmu_module_exit(void)\n{\n\tplatform_driver_unregister(&hisi_pa_pmu_driver);\n\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HISI_PA_ONLINE);\n}\nmodule_exit(hisi_pa_pmu_module_exit);\n\nMODULE_DESCRIPTION(\"HiSilicon Protocol Adapter uncore PMU driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Shaokun Zhang <zhangshaokun@hisilicon.com>\");\nMODULE_AUTHOR(\"Qi Liu <liuqi115@huawei.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}