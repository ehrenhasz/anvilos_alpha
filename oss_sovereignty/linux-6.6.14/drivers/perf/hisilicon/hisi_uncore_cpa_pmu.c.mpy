{
  "module_name": "hisi_uncore_cpa_pmu.c",
  "hash_id": "e50ed77d155019c2ecbee393edfe6aa3884bdc5aab445235912639ad6a960153",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/hisilicon/hisi_uncore_cpa_pmu.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"cpa pmu: \" fmt\n#include <linux/acpi.h>\n#include <linux/bug.h>\n#include <linux/cpuhotplug.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/list.h>\n#include <linux/smp.h>\n\n#include \"hisi_uncore_pmu.h\"\n\n \n#define CPA_PERF_CTRL\t\t0x1c00\n#define CPA_EVENT_CTRL\t\t0x1c04\n#define CPA_INT_MASK\t\t0x1c70\n#define CPA_INT_STATUS\t\t0x1c78\n#define CPA_INT_CLEAR\t\t0x1c7c\n#define CPA_EVENT_TYPE0\t\t0x1c80\n#define CPA_VERSION\t\t0x1cf0\n#define CPA_CNT0_LOWER\t\t0x1d00\n#define CPA_CFG_REG\t\t0x0534\n\n \n#define CPA_PERF_CTRL_EN\tBIT_ULL(0)\n#define CPA_EVTYPE_MASK\t\t0xffUL\n#define CPA_PM_CTRL\t\tBIT_ULL(9)\n\n \n#define CPA_NR_COUNTERS\t\t0x8\n#define CPA_COUNTER_BITS\t64\n#define CPA_NR_EVENTS\t\t0xff\n#define CPA_REG_OFFSET\t\t0x8\n\nstatic u32 hisi_cpa_pmu_get_counter_offset(int idx)\n{\n\treturn (CPA_CNT0_LOWER + idx * CPA_REG_OFFSET);\n}\n\nstatic u64 hisi_cpa_pmu_read_counter(struct hisi_pmu *cpa_pmu,\n\t\t\t\t     struct hw_perf_event *hwc)\n{\n\treturn readq(cpa_pmu->base + hisi_cpa_pmu_get_counter_offset(hwc->idx));\n}\n\nstatic void hisi_cpa_pmu_write_counter(struct hisi_pmu *cpa_pmu,\n\t\t\t\t       struct hw_perf_event *hwc, u64 val)\n{\n\twriteq(val, cpa_pmu->base + hisi_cpa_pmu_get_counter_offset(hwc->idx));\n}\n\nstatic void hisi_cpa_pmu_write_evtype(struct hisi_pmu *cpa_pmu, int idx,\n\t\t\t\t      u32 type)\n{\n\tu32 reg, reg_idx, shift, val;\n\n\t \n\treg = CPA_EVENT_TYPE0 + (idx / 4) * 4;\n\treg_idx = idx % 4;\n\tshift = CPA_REG_OFFSET * reg_idx;\n\n\t \n\tval = readl(cpa_pmu->base + reg);\n\tval &= ~(CPA_EVTYPE_MASK << shift);\n\tval |= type << shift;\n\twritel(val, cpa_pmu->base + reg);\n}\n\nstatic void hisi_cpa_pmu_start_counters(struct hisi_pmu *cpa_pmu)\n{\n\tu32 val;\n\n\tval = readl(cpa_pmu->base + CPA_PERF_CTRL);\n\tval |= CPA_PERF_CTRL_EN;\n\twritel(val, cpa_pmu->base + CPA_PERF_CTRL);\n}\n\nstatic void hisi_cpa_pmu_stop_counters(struct hisi_pmu *cpa_pmu)\n{\n\tu32 val;\n\n\tval = readl(cpa_pmu->base + CPA_PERF_CTRL);\n\tval &= ~(CPA_PERF_CTRL_EN);\n\twritel(val, cpa_pmu->base + CPA_PERF_CTRL);\n}\n\nstatic void hisi_cpa_pmu_disable_pm(struct hisi_pmu *cpa_pmu)\n{\n\tu32 val;\n\n\tval = readl(cpa_pmu->base + CPA_CFG_REG);\n\tval |= CPA_PM_CTRL;\n\twritel(val, cpa_pmu->base + CPA_CFG_REG);\n}\n\nstatic void hisi_cpa_pmu_enable_pm(struct hisi_pmu *cpa_pmu)\n{\n\tu32 val;\n\n\tval = readl(cpa_pmu->base + CPA_CFG_REG);\n\tval &= ~(CPA_PM_CTRL);\n\twritel(val, cpa_pmu->base + CPA_CFG_REG);\n}\n\nstatic void hisi_cpa_pmu_enable_counter(struct hisi_pmu *cpa_pmu,\n\t\t\t\t\tstruct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(cpa_pmu->base + CPA_EVENT_CTRL);\n\tval |= 1 << hwc->idx;\n\twritel(val, cpa_pmu->base + CPA_EVENT_CTRL);\n}\n\nstatic void hisi_cpa_pmu_disable_counter(struct hisi_pmu *cpa_pmu,\n\t\t\t\t\t struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(cpa_pmu->base + CPA_EVENT_CTRL);\n\tval &= ~(1UL << hwc->idx);\n\twritel(val, cpa_pmu->base + CPA_EVENT_CTRL);\n}\n\nstatic void hisi_cpa_pmu_enable_counter_int(struct hisi_pmu *cpa_pmu,\n\t\t\t\t\t    struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(cpa_pmu->base + CPA_INT_MASK);\n\tval &= ~(1UL << hwc->idx);\n\twritel(val, cpa_pmu->base + CPA_INT_MASK);\n}\n\nstatic void hisi_cpa_pmu_disable_counter_int(struct hisi_pmu *cpa_pmu,\n\t\t\t\t\t     struct hw_perf_event *hwc)\n{\n\tu32 val;\n\n\t \n\tval = readl(cpa_pmu->base + CPA_INT_MASK);\n\tval |= 1 << hwc->idx;\n\twritel(val, cpa_pmu->base + CPA_INT_MASK);\n}\n\nstatic u32 hisi_cpa_pmu_get_int_status(struct hisi_pmu *cpa_pmu)\n{\n\treturn readl(cpa_pmu->base + CPA_INT_STATUS);\n}\n\nstatic void hisi_cpa_pmu_clear_int_status(struct hisi_pmu *cpa_pmu, int idx)\n{\n\twritel(1 << idx, cpa_pmu->base + CPA_INT_CLEAR);\n}\n\nstatic const struct acpi_device_id hisi_cpa_pmu_acpi_match[] = {\n\t{ \"HISI0281\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, hisi_cpa_pmu_acpi_match);\n\nstatic int hisi_cpa_pmu_init_data(struct platform_device *pdev,\n\t\t\t\t  struct hisi_pmu *cpa_pmu)\n{\n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,scl-id\",\n\t\t\t\t     &cpa_pmu->sicl_id)) {\n\t\tdev_err(&pdev->dev, \"Can not read sicl-id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_u32(&pdev->dev, \"hisilicon,idx-id\",\n\t\t\t\t     &cpa_pmu->index_id)) {\n\t\tdev_err(&pdev->dev, \"Cannot read idx-id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcpa_pmu->ccl_id = -1;\n\tcpa_pmu->sccl_id = -1;\n\tcpa_pmu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cpa_pmu->base))\n\t\treturn PTR_ERR(cpa_pmu->base);\n\n\tcpa_pmu->identifier = readl(cpa_pmu->base + CPA_VERSION);\n\n\treturn 0;\n}\n\nstatic struct attribute *hisi_cpa_pmu_format_attr[] = {\n\tHISI_PMU_FORMAT_ATTR(event, \"config:0-15\"),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_cpa_pmu_format_group = {\n\t.name = \"format\",\n\t.attrs = hisi_cpa_pmu_format_attr,\n};\n\nstatic struct attribute *hisi_cpa_pmu_events_attr[] = {\n\tHISI_PMU_EVENT_ATTR(cpa_cycles,\t\t0x00),\n\tHISI_PMU_EVENT_ATTR(cpa_p1_wr_dat,\t0x61),\n\tHISI_PMU_EVENT_ATTR(cpa_p1_rd_dat,\t0x62),\n\tHISI_PMU_EVENT_ATTR(cpa_p0_wr_dat,\t0xE1),\n\tHISI_PMU_EVENT_ATTR(cpa_p0_rd_dat,\t0xE2),\n\tNULL\n};\n\nstatic const struct attribute_group hisi_cpa_pmu_events_group = {\n\t.name = \"events\",\n\t.attrs = hisi_cpa_pmu_events_attr,\n};\n\nstatic DEVICE_ATTR(cpumask, 0444, hisi_cpumask_sysfs_show, NULL);\n\nstatic struct attribute *hisi_cpa_pmu_cpumask_attrs[] = {\n\t&dev_attr_cpumask.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hisi_cpa_pmu_cpumask_attr_group = {\n\t.attrs = hisi_cpa_pmu_cpumask_attrs,\n};\n\nstatic struct device_attribute hisi_cpa_pmu_identifier_attr =\n\t__ATTR(identifier, 0444, hisi_uncore_pmu_identifier_attr_show, NULL);\n\nstatic struct attribute *hisi_cpa_pmu_identifier_attrs[] = {\n\t&hisi_cpa_pmu_identifier_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hisi_cpa_pmu_identifier_group = {\n\t.attrs = hisi_cpa_pmu_identifier_attrs,\n};\n\nstatic const struct attribute_group *hisi_cpa_pmu_attr_groups[] = {\n\t&hisi_cpa_pmu_format_group,\n\t&hisi_cpa_pmu_events_group,\n\t&hisi_cpa_pmu_cpumask_attr_group,\n\t&hisi_cpa_pmu_identifier_group,\n\tNULL\n};\n\nstatic const struct hisi_uncore_ops hisi_uncore_cpa_pmu_ops = {\n\t.write_evtype           = hisi_cpa_pmu_write_evtype,\n\t.get_event_idx\t\t= hisi_uncore_pmu_get_event_idx,\n\t.start_counters\t\t= hisi_cpa_pmu_start_counters,\n\t.stop_counters\t\t= hisi_cpa_pmu_stop_counters,\n\t.enable_counter\t\t= hisi_cpa_pmu_enable_counter,\n\t.disable_counter\t= hisi_cpa_pmu_disable_counter,\n\t.enable_counter_int\t= hisi_cpa_pmu_enable_counter_int,\n\t.disable_counter_int\t= hisi_cpa_pmu_disable_counter_int,\n\t.write_counter\t\t= hisi_cpa_pmu_write_counter,\n\t.read_counter\t\t= hisi_cpa_pmu_read_counter,\n\t.get_int_status\t\t= hisi_cpa_pmu_get_int_status,\n\t.clear_int_status\t= hisi_cpa_pmu_clear_int_status,\n};\n\nstatic int hisi_cpa_pmu_dev_probe(struct platform_device *pdev,\n\t\t\t\t  struct hisi_pmu *cpa_pmu)\n{\n\tint ret;\n\n\tret = hisi_cpa_pmu_init_data(pdev, cpa_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_uncore_pmu_init_irq(cpa_pmu, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tcpa_pmu->counter_bits = CPA_COUNTER_BITS;\n\tcpa_pmu->check_event = CPA_NR_EVENTS;\n\tcpa_pmu->pmu_events.attr_groups = hisi_cpa_pmu_attr_groups;\n\tcpa_pmu->ops = &hisi_uncore_cpa_pmu_ops;\n\tcpa_pmu->num_counters = CPA_NR_COUNTERS;\n\tcpa_pmu->dev = &pdev->dev;\n\tcpa_pmu->on_cpu = -1;\n\n\treturn 0;\n}\n\nstatic int hisi_cpa_pmu_probe(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *cpa_pmu;\n\tchar *name;\n\tint ret;\n\n\tcpa_pmu = devm_kzalloc(&pdev->dev, sizeof(*cpa_pmu), GFP_KERNEL);\n\tif (!cpa_pmu)\n\t\treturn -ENOMEM;\n\n\tret = hisi_cpa_pmu_dev_probe(pdev, cpa_pmu);\n\tif (ret)\n\t\treturn ret;\n\n\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"hisi_sicl%d_cpa%u\",\n\t\t\t      cpa_pmu->sicl_id, cpa_pmu->index_id);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\thisi_pmu_init(cpa_pmu, THIS_MODULE);\n\n\t \n\thisi_cpa_pmu_disable_pm(cpa_pmu);\n\tret = cpuhp_state_add_instance(CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE,\n\t\t\t\t       &cpa_pmu->node);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error %d registering hotplug\\n\", ret);\n\t\thisi_cpa_pmu_enable_pm(cpa_pmu);\n\t\treturn ret;\n\t}\n\n\tret = perf_pmu_register(&cpa_pmu->pmu, name, -1);\n\tif (ret) {\n\t\tdev_err(cpa_pmu->dev, \"PMU register failed\\n\");\n\t\tcpuhp_state_remove_instance_nocalls(\n\t\t\tCPUHP_AP_PERF_ARM_HISI_CPA_ONLINE, &cpa_pmu->node);\n\t\thisi_cpa_pmu_enable_pm(cpa_pmu);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, cpa_pmu);\n\treturn ret;\n}\n\nstatic int hisi_cpa_pmu_remove(struct platform_device *pdev)\n{\n\tstruct hisi_pmu *cpa_pmu = platform_get_drvdata(pdev);\n\n\tperf_pmu_unregister(&cpa_pmu->pmu);\n\tcpuhp_state_remove_instance_nocalls(CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE,\n\t\t\t\t\t    &cpa_pmu->node);\n\thisi_cpa_pmu_enable_pm(cpa_pmu);\n\treturn 0;\n}\n\nstatic struct platform_driver hisi_cpa_pmu_driver = {\n\t.driver = {\n\t\t.name = \"hisi_cpa_pmu\",\n\t\t.acpi_match_table = ACPI_PTR(hisi_cpa_pmu_acpi_match),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = hisi_cpa_pmu_probe,\n\t.remove = hisi_cpa_pmu_remove,\n};\n\nstatic int __init hisi_cpa_pmu_module_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE,\n\t\t\t\t      \"AP_PERF_ARM_HISI_CPA_ONLINE\",\n\t\t\t\t      hisi_uncore_pmu_online_cpu,\n\t\t\t\t      hisi_uncore_pmu_offline_cpu);\n\tif (ret) {\n\t\tpr_err(\"setup hotplug failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&hisi_cpa_pmu_driver);\n\tif (ret)\n\t\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE);\n\n\treturn ret;\n}\nmodule_init(hisi_cpa_pmu_module_init);\n\nstatic void __exit hisi_cpa_pmu_module_exit(void)\n{\n\tplatform_driver_unregister(&hisi_cpa_pmu_driver);\n\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE);\n}\nmodule_exit(hisi_cpa_pmu_module_exit);\n\nMODULE_DESCRIPTION(\"HiSilicon SoC CPA PMU driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Qi Liu <liuqi115@huawei.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}