{
  "module_name": "arm_cspmu.c",
  "hash_id": "fb75ab09de39c33e1db8bf37b585129bcf7c24ac8a25ff3d39b3a092e203201b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/arm_cspmu/arm_cspmu.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/cacheinfo.h>\n#include <linux/ctype.h>\n#include <linux/interrupt.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/module.h>\n#include <linux/perf_event.h>\n#include <linux/platform_device.h>\n\n#include \"arm_cspmu.h\"\n#include \"nvidia_cspmu.h\"\n\n#define PMUNAME \"arm_cspmu\"\n#define DRVNAME \"arm-cs-arch-pmu\"\n\n#define ARM_CSPMU_CPUMASK_ATTR(_name, _config)\t\t\t\\\n\tARM_CSPMU_EXT_ATTR(_name, arm_cspmu_cpumask_show,\t\\\n\t\t\t\t(unsigned long)_config)\n\n \n#define PMEVCNTR_LO\t\t\t\t\t0x0\n#define PMEVCNTR_HI\t\t\t\t\t0x4\n#define PMEVTYPER\t\t\t\t\t0x400\n#define PMCCFILTR\t\t\t\t\t0x47C\n#define PMEVFILTR\t\t\t\t\t0xA00\n#define PMCNTENSET\t\t\t\t\t0xC00\n#define PMCNTENCLR\t\t\t\t\t0xC20\n#define PMINTENSET\t\t\t\t\t0xC40\n#define PMINTENCLR\t\t\t\t\t0xC60\n#define PMOVSCLR\t\t\t\t\t0xC80\n#define PMOVSSET\t\t\t\t\t0xCC0\n#define PMCFGR\t\t\t\t\t\t0xE00\n#define PMCR\t\t\t\t\t\t0xE04\n#define PMIIDR\t\t\t\t\t\t0xE08\n\n \n#define PMCFGR_NCG\t\t\t\t\tGENMASK(31, 28)\n#define PMCFGR_HDBG\t\t\t\t\tBIT(24)\n#define PMCFGR_TRO\t\t\t\t\tBIT(23)\n#define PMCFGR_SS\t\t\t\t\tBIT(22)\n#define PMCFGR_FZO\t\t\t\t\tBIT(21)\n#define PMCFGR_MSI\t\t\t\t\tBIT(20)\n#define PMCFGR_UEN\t\t\t\t\tBIT(19)\n#define PMCFGR_NA\t\t\t\t\tBIT(17)\n#define PMCFGR_EX\t\t\t\t\tBIT(16)\n#define PMCFGR_CCD\t\t\t\t\tBIT(15)\n#define PMCFGR_CC\t\t\t\t\tBIT(14)\n#define PMCFGR_SIZE\t\t\t\t\tGENMASK(13, 8)\n#define PMCFGR_N\t\t\t\t\tGENMASK(7, 0)\n\n \n#define PMCR_TRO\t\t\t\t\tBIT(11)\n#define PMCR_HDBG\t\t\t\t\tBIT(10)\n#define PMCR_FZO\t\t\t\t\tBIT(9)\n#define PMCR_NA\t\t\t\t\t\tBIT(8)\n#define PMCR_DP\t\t\t\t\t\tBIT(5)\n#define PMCR_X\t\t\t\t\t\tBIT(4)\n#define PMCR_D\t\t\t\t\t\tBIT(3)\n#define PMCR_C\t\t\t\t\t\tBIT(2)\n#define PMCR_P\t\t\t\t\t\tBIT(1)\n#define PMCR_E\t\t\t\t\t\tBIT(0)\n\n \n#define ARM_CSPMU_SET_CLR_COUNTER_SHIFT\t\t5\n#define ARM_CSPMU_SET_CLR_COUNTER_NUM\t\t\\\n\t(1 << ARM_CSPMU_SET_CLR_COUNTER_SHIFT)\n\n \n#define COUNTER_TO_SET_CLR_ID(idx)\t\t\t\\\n\t(idx >> ARM_CSPMU_SET_CLR_COUNTER_SHIFT)\n\n \n#define COUNTER_TO_SET_CLR_BIT(idx)\t\t\t\\\n\t(idx & (ARM_CSPMU_SET_CLR_COUNTER_NUM - 1))\n\n#define ARM_CSPMU_ACTIVE_CPU_MASK\t\t0x0\n#define ARM_CSPMU_ASSOCIATED_CPU_MASK\t\t0x1\n\n \n#define CHECK_DEFAULT_IMPL_OPS(ops, callback)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (!ops->callback)\t\t\t\t\\\n\t\t\tops->callback = arm_cspmu_ ## callback;\t\\\n\t} while (0)\n\n \n#define HILOHI_MAX_POLL\t1000\n\n \n#define ARM_CSPMU_IMPL_ID_NVIDIA\t\t0x36B\n\nstatic unsigned long arm_cspmu_cpuhp_state;\n\nstatic struct acpi_apmt_node *arm_cspmu_apmt_node(struct device *dev)\n{\n\treturn *(struct acpi_apmt_node **)dev_get_platdata(dev);\n}\n\n \n\n \nstatic u64 read_reg64_hilohi(const void __iomem *addr, u32 max_poll_count)\n{\n\tu32 val_lo, val_hi;\n\tu64 val;\n\n\t \n\tdo {\n\t\tif (max_poll_count-- == 0) {\n\t\t\tpr_err(\"ARM CSPMU: timeout hi-low-high sequence\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tval_hi = readl(addr + 4);\n\t\tval_lo = readl(addr);\n\t} while (val_hi != readl(addr + 4));\n\n\tval = (((u64)val_hi << 32) | val_lo);\n\n\treturn val;\n}\n\n \nstatic inline bool supports_cycle_counter(const struct arm_cspmu *cspmu)\n{\n\treturn (cspmu->pmcfgr & PMCFGR_CC);\n}\n\n \nstatic inline u32 counter_size(const struct arm_cspmu *cspmu)\n{\n\treturn FIELD_GET(PMCFGR_SIZE, cspmu->pmcfgr) + 1;\n}\n\n \nstatic inline u64 counter_mask(const struct arm_cspmu *cspmu)\n{\n\treturn GENMASK_ULL(counter_size(cspmu) - 1, 0);\n}\n\n \nstatic inline bool use_64b_counter_reg(const struct arm_cspmu *cspmu)\n{\n\treturn (counter_size(cspmu) > 32);\n}\n\nssize_t arm_cspmu_sysfs_event_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct perf_pmu_events_attr *pmu_attr;\n\n\tpmu_attr = container_of(attr, typeof(*pmu_attr), attr);\n\treturn sysfs_emit(buf, \"event=0x%llx\\n\", pmu_attr->id);\n}\nEXPORT_SYMBOL_GPL(arm_cspmu_sysfs_event_show);\n\n \nstatic struct attribute *arm_cspmu_event_attrs[] = {\n\tARM_CSPMU_EVENT_ATTR(cycles, ARM_CSPMU_EVT_CYCLES_DEFAULT),\n\tNULL,\n};\n\nstatic struct attribute **\narm_cspmu_get_event_attrs(const struct arm_cspmu *cspmu)\n{\n\tstruct attribute **attrs;\n\n\tattrs = devm_kmemdup(cspmu->dev, arm_cspmu_event_attrs,\n\t\tsizeof(arm_cspmu_event_attrs), GFP_KERNEL);\n\n\treturn attrs;\n}\n\nstatic umode_t\narm_cspmu_event_attr_is_visible(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, int unused)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(dev_get_drvdata(dev));\n\tstruct perf_pmu_events_attr *eattr;\n\n\teattr = container_of(attr, typeof(*eattr), attr.attr);\n\n\t \n\tif (!supports_cycle_counter(cspmu) &&\n\t    eattr->id == ARM_CSPMU_EVT_CYCLES_DEFAULT)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nssize_t arm_cspmu_sysfs_format_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct dev_ext_attribute *eattr =\n\t\tcontainer_of(attr, struct dev_ext_attribute, attr);\n\treturn sysfs_emit(buf, \"%s\\n\", (char *)eattr->var);\n}\nEXPORT_SYMBOL_GPL(arm_cspmu_sysfs_format_show);\n\nstatic struct attribute *arm_cspmu_format_attrs[] = {\n\tARM_CSPMU_FORMAT_EVENT_ATTR,\n\tARM_CSPMU_FORMAT_FILTER_ATTR,\n\tNULL,\n};\n\nstatic struct attribute **\narm_cspmu_get_format_attrs(const struct arm_cspmu *cspmu)\n{\n\tstruct attribute **attrs;\n\n\tattrs = devm_kmemdup(cspmu->dev, arm_cspmu_format_attrs,\n\t\tsizeof(arm_cspmu_format_attrs), GFP_KERNEL);\n\n\treturn attrs;\n}\n\nstatic u32 arm_cspmu_event_type(const struct perf_event *event)\n{\n\treturn event->attr.config & ARM_CSPMU_EVENT_MASK;\n}\n\nstatic bool arm_cspmu_is_cycle_counter_event(const struct perf_event *event)\n{\n\treturn (event->attr.config == ARM_CSPMU_EVT_CYCLES_DEFAULT);\n}\n\nstatic u32 arm_cspmu_event_filter(const struct perf_event *event)\n{\n\treturn event->attr.config1 & ARM_CSPMU_FILTER_MASK;\n}\n\nstatic ssize_t arm_cspmu_identifier_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *page)\n{\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(dev_get_drvdata(dev));\n\n\treturn sysfs_emit(page, \"%s\\n\", cspmu->identifier);\n}\n\nstatic struct device_attribute arm_cspmu_identifier_attr =\n\t__ATTR(identifier, 0444, arm_cspmu_identifier_show, NULL);\n\nstatic struct attribute *arm_cspmu_identifier_attrs[] = {\n\t&arm_cspmu_identifier_attr.attr,\n\tNULL,\n};\n\nstatic struct attribute_group arm_cspmu_identifier_attr_group = {\n\t.attrs = arm_cspmu_identifier_attrs,\n};\n\nstatic const char *arm_cspmu_get_identifier(const struct arm_cspmu *cspmu)\n{\n\tconst char *identifier =\n\t\tdevm_kasprintf(cspmu->dev, GFP_KERNEL, \"%x\",\n\t\t\t       cspmu->impl.pmiidr);\n\treturn identifier;\n}\n\nstatic const char *arm_cspmu_type_str[ACPI_APMT_NODE_TYPE_COUNT] = {\n\t\"mc\",\n\t\"smmu\",\n\t\"pcie\",\n\t\"acpi\",\n\t\"cache\",\n};\n\nstatic const char *arm_cspmu_get_name(const struct arm_cspmu *cspmu)\n{\n\tstruct device *dev;\n\tstruct acpi_apmt_node *apmt_node;\n\tu8 pmu_type;\n\tchar *name;\n\tchar acpi_hid_string[ACPI_ID_LEN] = { 0 };\n\tstatic atomic_t pmu_idx[ACPI_APMT_NODE_TYPE_COUNT] = { 0 };\n\n\tdev = cspmu->dev;\n\tapmt_node = arm_cspmu_apmt_node(dev);\n\tpmu_type = apmt_node->type;\n\n\tif (pmu_type >= ACPI_APMT_NODE_TYPE_COUNT) {\n\t\tdev_err(dev, \"unsupported PMU type-%u\\n\", pmu_type);\n\t\treturn NULL;\n\t}\n\n\tif (pmu_type == ACPI_APMT_NODE_TYPE_ACPI) {\n\t\tmemcpy(acpi_hid_string,\n\t\t\t&apmt_node->inst_primary,\n\t\t\tsizeof(apmt_node->inst_primary));\n\t\tname = devm_kasprintf(dev, GFP_KERNEL, \"%s_%s_%s_%u\", PMUNAME,\n\t\t\t\t      arm_cspmu_type_str[pmu_type],\n\t\t\t\t      acpi_hid_string,\n\t\t\t\t      apmt_node->inst_secondary);\n\t} else {\n\t\tname = devm_kasprintf(dev, GFP_KERNEL, \"%s_%s_%d\", PMUNAME,\n\t\t\t\t      arm_cspmu_type_str[pmu_type],\n\t\t\t\t      atomic_fetch_inc(&pmu_idx[pmu_type]));\n\t}\n\n\treturn name;\n}\n\nstatic ssize_t arm_cspmu_cpumask_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(pmu);\n\tstruct dev_ext_attribute *eattr =\n\t\tcontainer_of(attr, struct dev_ext_attribute, attr);\n\tunsigned long mask_id = (unsigned long)eattr->var;\n\tconst cpumask_t *cpumask;\n\n\tswitch (mask_id) {\n\tcase ARM_CSPMU_ACTIVE_CPU_MASK:\n\t\tcpumask = &cspmu->active_cpu;\n\t\tbreak;\n\tcase ARM_CSPMU_ASSOCIATED_CPU_MASK:\n\t\tcpumask = &cspmu->associated_cpus;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn cpumap_print_to_pagebuf(true, buf, cpumask);\n}\n\nstatic struct attribute *arm_cspmu_cpumask_attrs[] = {\n\tARM_CSPMU_CPUMASK_ATTR(cpumask, ARM_CSPMU_ACTIVE_CPU_MASK),\n\tARM_CSPMU_CPUMASK_ATTR(associated_cpus, ARM_CSPMU_ASSOCIATED_CPU_MASK),\n\tNULL,\n};\n\nstatic struct attribute_group arm_cspmu_cpumask_attr_group = {\n\t.attrs = arm_cspmu_cpumask_attrs,\n};\n\nstruct impl_match {\n\tu32 pmiidr;\n\tu32 mask;\n\tint (*impl_init_ops)(struct arm_cspmu *cspmu);\n};\n\nstatic const struct impl_match impl_match[] = {\n\t{\n\t  .pmiidr = ARM_CSPMU_IMPL_ID_NVIDIA,\n\t  .mask = ARM_CSPMU_PMIIDR_IMPLEMENTER,\n\t  .impl_init_ops = nv_cspmu_init_ops\n\t},\n\t{}\n};\n\nstatic int arm_cspmu_init_impl_ops(struct arm_cspmu *cspmu)\n{\n\tint ret;\n\tstruct arm_cspmu_impl_ops *impl_ops = &cspmu->impl.ops;\n\tstruct acpi_apmt_node *apmt_node = arm_cspmu_apmt_node(cspmu->dev);\n\tconst struct impl_match *match = impl_match;\n\n\t \n\tcspmu->impl.pmiidr =\n\t\t(apmt_node->impl_id) ? apmt_node->impl_id :\n\t\t\t\t       readl(cspmu->base0 + PMIIDR);\n\n\t \n\tfor (; match->pmiidr; match++) {\n\t\tconst u32 mask = match->mask;\n\n\t\tif ((match->pmiidr & mask) == (cspmu->impl.pmiidr & mask)) {\n\t\t\tret = match->impl_init_ops(cspmu);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tCHECK_DEFAULT_IMPL_OPS(impl_ops, get_event_attrs);\n\tCHECK_DEFAULT_IMPL_OPS(impl_ops, get_format_attrs);\n\tCHECK_DEFAULT_IMPL_OPS(impl_ops, get_identifier);\n\tCHECK_DEFAULT_IMPL_OPS(impl_ops, get_name);\n\tCHECK_DEFAULT_IMPL_OPS(impl_ops, is_cycle_counter_event);\n\tCHECK_DEFAULT_IMPL_OPS(impl_ops, event_type);\n\tCHECK_DEFAULT_IMPL_OPS(impl_ops, event_filter);\n\tCHECK_DEFAULT_IMPL_OPS(impl_ops, event_attr_is_visible);\n\n\treturn 0;\n}\n\nstatic struct attribute_group *\narm_cspmu_alloc_event_attr_group(struct arm_cspmu *cspmu)\n{\n\tstruct attribute_group *event_group;\n\tstruct device *dev = cspmu->dev;\n\tconst struct arm_cspmu_impl_ops *impl_ops = &cspmu->impl.ops;\n\n\tevent_group =\n\t\tdevm_kzalloc(dev, sizeof(struct attribute_group), GFP_KERNEL);\n\tif (!event_group)\n\t\treturn NULL;\n\n\tevent_group->name = \"events\";\n\tevent_group->is_visible = impl_ops->event_attr_is_visible;\n\tevent_group->attrs = impl_ops->get_event_attrs(cspmu);\n\n\tif (!event_group->attrs)\n\t\treturn NULL;\n\n\treturn event_group;\n}\n\nstatic struct attribute_group *\narm_cspmu_alloc_format_attr_group(struct arm_cspmu *cspmu)\n{\n\tstruct attribute_group *format_group;\n\tstruct device *dev = cspmu->dev;\n\n\tformat_group =\n\t\tdevm_kzalloc(dev, sizeof(struct attribute_group), GFP_KERNEL);\n\tif (!format_group)\n\t\treturn NULL;\n\n\tformat_group->name = \"format\";\n\tformat_group->attrs = cspmu->impl.ops.get_format_attrs(cspmu);\n\n\tif (!format_group->attrs)\n\t\treturn NULL;\n\n\treturn format_group;\n}\n\nstatic struct attribute_group **\narm_cspmu_alloc_attr_group(struct arm_cspmu *cspmu)\n{\n\tstruct attribute_group **attr_groups = NULL;\n\tstruct device *dev = cspmu->dev;\n\tconst struct arm_cspmu_impl_ops *impl_ops = &cspmu->impl.ops;\n\tint ret;\n\n\tret = arm_cspmu_init_impl_ops(cspmu);\n\tif (ret)\n\t\treturn NULL;\n\n\tcspmu->identifier = impl_ops->get_identifier(cspmu);\n\tcspmu->name = impl_ops->get_name(cspmu);\n\n\tif (!cspmu->identifier || !cspmu->name)\n\t\treturn NULL;\n\n\tattr_groups = devm_kcalloc(dev, 5, sizeof(struct attribute_group *),\n\t\t\t\t   GFP_KERNEL);\n\tif (!attr_groups)\n\t\treturn NULL;\n\n\tattr_groups[0] = arm_cspmu_alloc_event_attr_group(cspmu);\n\tattr_groups[1] = arm_cspmu_alloc_format_attr_group(cspmu);\n\tattr_groups[2] = &arm_cspmu_identifier_attr_group;\n\tattr_groups[3] = &arm_cspmu_cpumask_attr_group;\n\n\tif (!attr_groups[0] || !attr_groups[1])\n\t\treturn NULL;\n\n\treturn attr_groups;\n}\n\nstatic inline void arm_cspmu_reset_counters(struct arm_cspmu *cspmu)\n{\n\tu32 pmcr = 0;\n\n\tpmcr |= PMCR_P;\n\tpmcr |= PMCR_C;\n\twritel(pmcr, cspmu->base0 + PMCR);\n}\n\nstatic inline void arm_cspmu_start_counters(struct arm_cspmu *cspmu)\n{\n\twritel(PMCR_E, cspmu->base0 + PMCR);\n}\n\nstatic inline void arm_cspmu_stop_counters(struct arm_cspmu *cspmu)\n{\n\twritel(0, cspmu->base0 + PMCR);\n}\n\nstatic void arm_cspmu_enable(struct pmu *pmu)\n{\n\tbool disabled;\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(pmu);\n\n\tdisabled = bitmap_empty(cspmu->hw_events.used_ctrs,\n\t\t\t\tcspmu->num_logical_ctrs);\n\n\tif (disabled)\n\t\treturn;\n\n\tarm_cspmu_start_counters(cspmu);\n}\n\nstatic void arm_cspmu_disable(struct pmu *pmu)\n{\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(pmu);\n\n\tarm_cspmu_stop_counters(cspmu);\n}\n\nstatic int arm_cspmu_get_event_idx(struct arm_cspmu_hw_events *hw_events,\n\t\t\t\tstruct perf_event *event)\n{\n\tint idx;\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(event->pmu);\n\n\tif (supports_cycle_counter(cspmu)) {\n\t\tif (cspmu->impl.ops.is_cycle_counter_event(event)) {\n\t\t\t \n\t\t\tif (test_and_set_bit(cspmu->cycle_counter_logical_idx,\n\t\t\t\t\t     hw_events->used_ctrs))\n\t\t\t\treturn -EAGAIN;\n\n\t\t\treturn cspmu->cycle_counter_logical_idx;\n\t\t}\n\n\t\t \n\t\tidx = find_first_zero_bit(hw_events->used_ctrs,\n\t\t\t\t\t  cspmu->cycle_counter_logical_idx);\n\t\tif (idx >= cspmu->cycle_counter_logical_idx) {\n\t\t\tidx = find_next_zero_bit(\n\t\t\t\thw_events->used_ctrs,\n\t\t\t\tcspmu->num_logical_ctrs,\n\t\t\t\tcspmu->cycle_counter_logical_idx + 1);\n\t\t}\n\t} else {\n\t\tidx = find_first_zero_bit(hw_events->used_ctrs,\n\t\t\t\t\t  cspmu->num_logical_ctrs);\n\t}\n\n\tif (idx >= cspmu->num_logical_ctrs)\n\t\treturn -EAGAIN;\n\n\tset_bit(idx, hw_events->used_ctrs);\n\n\treturn idx;\n}\n\nstatic bool arm_cspmu_validate_event(struct pmu *pmu,\n\t\t\t\t struct arm_cspmu_hw_events *hw_events,\n\t\t\t\t struct perf_event *event)\n{\n\tif (is_software_event(event))\n\t\treturn true;\n\n\t \n\tif (event->pmu != pmu)\n\t\treturn false;\n\n\treturn (arm_cspmu_get_event_idx(hw_events, event) >= 0);\n}\n\n \nstatic bool arm_cspmu_validate_group(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tstruct arm_cspmu_hw_events fake_hw_events;\n\n\tif (event->group_leader == event)\n\t\treturn true;\n\n\tmemset(&fake_hw_events, 0, sizeof(fake_hw_events));\n\n\tif (!arm_cspmu_validate_event(event->pmu, &fake_hw_events, leader))\n\t\treturn false;\n\n\tfor_each_sibling_event(sibling, leader) {\n\t\tif (!arm_cspmu_validate_event(event->pmu, &fake_hw_events,\n\t\t\t\t\t\t  sibling))\n\t\t\treturn false;\n\t}\n\n\treturn arm_cspmu_validate_event(event->pmu, &fake_hw_events, event);\n}\n\nstatic int arm_cspmu_event_init(struct perf_event *event)\n{\n\tstruct arm_cspmu *cspmu;\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tcspmu = to_arm_cspmu(event->pmu);\n\n\tif (event->attr.type != event->pmu->type)\n\t\treturn -ENOENT;\n\n\t \n\tif (is_sampling_event(event)) {\n\t\tdev_dbg(cspmu->pmu.dev,\n\t\t\t\"Can't support sampling events\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (event->cpu < 0 || event->attach_state & PERF_ATTACH_TASK) {\n\t\tdev_dbg(cspmu->pmu.dev,\n\t\t\t\"Can't support per-task counters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!cpumask_test_cpu(event->cpu, &cspmu->associated_cpus)) {\n\t\tdev_dbg(cspmu->pmu.dev,\n\t\t\t\"Requested cpu is not associated with the PMU\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tevent->cpu = cpumask_first(&cspmu->active_cpu);\n\tif (event->cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (!arm_cspmu_validate_group(event))\n\t\treturn -EINVAL;\n\n\t \n\thwc->idx = -1;\n\thwc->extra_reg.idx = -1;\n\thwc->config = cspmu->impl.ops.event_type(event);\n\n\treturn 0;\n}\n\nstatic inline u32 counter_offset(u32 reg_sz, u32 ctr_idx)\n{\n\treturn (PMEVCNTR_LO + (reg_sz * ctr_idx));\n}\n\nstatic void arm_cspmu_write_counter(struct perf_event *event, u64 val)\n{\n\tu32 offset;\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(event->pmu);\n\n\tif (use_64b_counter_reg(cspmu)) {\n\t\toffset = counter_offset(sizeof(u64), event->hw.idx);\n\n\t\twriteq(val, cspmu->base1 + offset);\n\t} else {\n\t\toffset = counter_offset(sizeof(u32), event->hw.idx);\n\n\t\twritel(lower_32_bits(val), cspmu->base1 + offset);\n\t}\n}\n\nstatic u64 arm_cspmu_read_counter(struct perf_event *event)\n{\n\tu32 offset;\n\tconst void __iomem *counter_addr;\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(event->pmu);\n\n\tif (use_64b_counter_reg(cspmu)) {\n\t\toffset = counter_offset(sizeof(u64), event->hw.idx);\n\t\tcounter_addr = cspmu->base1 + offset;\n\n\t\treturn cspmu->has_atomic_dword ?\n\t\t\t       readq(counter_addr) :\n\t\t\t       read_reg64_hilohi(counter_addr, HILOHI_MAX_POLL);\n\t}\n\n\toffset = counter_offset(sizeof(u32), event->hw.idx);\n\treturn readl(cspmu->base1 + offset);\n}\n\n \nstatic void arm_cspmu_set_event_period(struct perf_event *event)\n{\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(event->pmu);\n\tu64 val = counter_mask(cspmu) >> 1ULL;\n\n\tlocal64_set(&event->hw.prev_count, val);\n\tarm_cspmu_write_counter(event, val);\n}\n\nstatic void arm_cspmu_enable_counter(struct arm_cspmu *cspmu, int idx)\n{\n\tu32 reg_id, reg_bit, inten_off, cnten_off;\n\n\treg_id = COUNTER_TO_SET_CLR_ID(idx);\n\treg_bit = COUNTER_TO_SET_CLR_BIT(idx);\n\n\tinten_off = PMINTENSET + (4 * reg_id);\n\tcnten_off = PMCNTENSET + (4 * reg_id);\n\n\twritel(BIT(reg_bit), cspmu->base0 + inten_off);\n\twritel(BIT(reg_bit), cspmu->base0 + cnten_off);\n}\n\nstatic void arm_cspmu_disable_counter(struct arm_cspmu *cspmu, int idx)\n{\n\tu32 reg_id, reg_bit, inten_off, cnten_off;\n\n\treg_id = COUNTER_TO_SET_CLR_ID(idx);\n\treg_bit = COUNTER_TO_SET_CLR_BIT(idx);\n\n\tinten_off = PMINTENCLR + (4 * reg_id);\n\tcnten_off = PMCNTENCLR + (4 * reg_id);\n\n\twritel(BIT(reg_bit), cspmu->base0 + cnten_off);\n\twritel(BIT(reg_bit), cspmu->base0 + inten_off);\n}\n\nstatic void arm_cspmu_event_update(struct perf_event *event)\n{\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 delta, prev, now;\n\n\tdo {\n\t\tprev = local64_read(&hwc->prev_count);\n\t\tnow = arm_cspmu_read_counter(event);\n\t} while (local64_cmpxchg(&hwc->prev_count, prev, now) != prev);\n\n\tdelta = (now - prev) & counter_mask(cspmu);\n\tlocal64_add(delta, &event->count);\n}\n\nstatic inline void arm_cspmu_set_event(struct arm_cspmu *cspmu,\n\t\t\t\t\tstruct hw_perf_event *hwc)\n{\n\tu32 offset = PMEVTYPER + (4 * hwc->idx);\n\n\twritel(hwc->config, cspmu->base0 + offset);\n}\n\nstatic inline void arm_cspmu_set_ev_filter(struct arm_cspmu *cspmu,\n\t\t\t\t\t   struct hw_perf_event *hwc,\n\t\t\t\t\t   u32 filter)\n{\n\tu32 offset = PMEVFILTR + (4 * hwc->idx);\n\n\twritel(filter, cspmu->base0 + offset);\n}\n\nstatic inline void arm_cspmu_set_cc_filter(struct arm_cspmu *cspmu, u32 filter)\n{\n\tu32 offset = PMCCFILTR;\n\n\twritel(filter, cspmu->base0 + offset);\n}\n\nstatic void arm_cspmu_start(struct perf_event *event, int pmu_flags)\n{\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu32 filter;\n\n\t \n\tif (pmu_flags & PERF_EF_RELOAD)\n\t\tWARN_ON(!(hwc->state & PERF_HES_UPTODATE));\n\n\tarm_cspmu_set_event_period(event);\n\n\tfilter = cspmu->impl.ops.event_filter(event);\n\n\tif (event->hw.extra_reg.idx == cspmu->cycle_counter_logical_idx) {\n\t\tarm_cspmu_set_cc_filter(cspmu, filter);\n\t} else {\n\t\tarm_cspmu_set_event(cspmu, hwc);\n\t\tarm_cspmu_set_ev_filter(cspmu, hwc, filter);\n\t}\n\n\thwc->state = 0;\n\n\tarm_cspmu_enable_counter(cspmu, hwc->idx);\n}\n\nstatic void arm_cspmu_stop(struct perf_event *event, int pmu_flags)\n{\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (hwc->state & PERF_HES_STOPPED)\n\t\treturn;\n\n\tarm_cspmu_disable_counter(cspmu, hwc->idx);\n\tarm_cspmu_event_update(event);\n\n\thwc->state |= PERF_HES_STOPPED | PERF_HES_UPTODATE;\n}\n\nstatic inline u32 to_phys_idx(struct arm_cspmu *cspmu, u32 idx)\n{\n\treturn (idx == cspmu->cycle_counter_logical_idx) ?\n\t\tARM_CSPMU_CYCLE_CNTR_IDX : idx;\n}\n\nstatic int arm_cspmu_add(struct perf_event *event, int flags)\n{\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(event->pmu);\n\tstruct arm_cspmu_hw_events *hw_events = &cspmu->hw_events;\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx;\n\n\tif (WARN_ON_ONCE(!cpumask_test_cpu(smp_processor_id(),\n\t\t\t\t\t   &cspmu->associated_cpus)))\n\t\treturn -ENOENT;\n\n\tidx = arm_cspmu_get_event_idx(hw_events, event);\n\tif (idx < 0)\n\t\treturn idx;\n\n\thw_events->events[idx] = event;\n\thwc->idx = to_phys_idx(cspmu, idx);\n\thwc->extra_reg.idx = idx;\n\thwc->state = PERF_HES_STOPPED | PERF_HES_UPTODATE;\n\n\tif (flags & PERF_EF_START)\n\t\tarm_cspmu_start(event, PERF_EF_RELOAD);\n\n\t \n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void arm_cspmu_del(struct perf_event *event, int flags)\n{\n\tstruct arm_cspmu *cspmu = to_arm_cspmu(event->pmu);\n\tstruct arm_cspmu_hw_events *hw_events = &cspmu->hw_events;\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx = hwc->extra_reg.idx;\n\n\tarm_cspmu_stop(event, PERF_EF_UPDATE);\n\n\thw_events->events[idx] = NULL;\n\n\tclear_bit(idx, hw_events->used_ctrs);\n\n\tperf_event_update_userpage(event);\n}\n\nstatic void arm_cspmu_read(struct perf_event *event)\n{\n\tarm_cspmu_event_update(event);\n}\n\nstatic struct arm_cspmu *arm_cspmu_alloc(struct platform_device *pdev)\n{\n\tstruct acpi_apmt_node *apmt_node;\n\tstruct arm_cspmu *cspmu;\n\tstruct device *dev = &pdev->dev;\n\n\tcspmu = devm_kzalloc(dev, sizeof(*cspmu), GFP_KERNEL);\n\tif (!cspmu)\n\t\treturn NULL;\n\n\tcspmu->dev = dev;\n\tplatform_set_drvdata(pdev, cspmu);\n\n\tapmt_node = arm_cspmu_apmt_node(dev);\n\tcspmu->has_atomic_dword = apmt_node->flags & ACPI_APMT_FLAGS_ATOMIC;\n\n\treturn cspmu;\n}\n\nstatic int arm_cspmu_init_mmio(struct arm_cspmu *cspmu)\n{\n\tstruct device *dev;\n\tstruct platform_device *pdev;\n\n\tdev = cspmu->dev;\n\tpdev = to_platform_device(dev);\n\n\t \n\tcspmu->base0 = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cspmu->base0)) {\n\t\tdev_err(dev, \"ioremap failed for page-0 resource\\n\");\n\t\treturn PTR_ERR(cspmu->base0);\n\t}\n\n\t \n\tcspmu->base1 = cspmu->base0;\n\tif (platform_get_resource(pdev, IORESOURCE_MEM, 1)) {\n\t\tcspmu->base1 = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(cspmu->base1)) {\n\t\t\tdev_err(dev, \"ioremap failed for page-1 resource\\n\");\n\t\t\treturn PTR_ERR(cspmu->base1);\n\t\t}\n\t}\n\n\tcspmu->pmcfgr = readl(cspmu->base0 + PMCFGR);\n\n\tcspmu->num_logical_ctrs = FIELD_GET(PMCFGR_N, cspmu->pmcfgr) + 1;\n\n\tcspmu->cycle_counter_logical_idx = ARM_CSPMU_MAX_HW_CNTRS;\n\n\tif (supports_cycle_counter(cspmu)) {\n\t\t \n\t\tcspmu->cycle_counter_logical_idx =\n\t\t\t(cspmu->num_logical_ctrs <= ARM_CSPMU_CYCLE_CNTR_IDX) ?\n\t\t\t\tcspmu->num_logical_ctrs - 1 :\n\t\t\t\tARM_CSPMU_CYCLE_CNTR_IDX;\n\t}\n\n\tcspmu->num_set_clr_reg =\n\t\tDIV_ROUND_UP(cspmu->num_logical_ctrs,\n\t\t\t\tARM_CSPMU_SET_CLR_COUNTER_NUM);\n\n\tcspmu->hw_events.events =\n\t\tdevm_kcalloc(dev, cspmu->num_logical_ctrs,\n\t\t\t     sizeof(*cspmu->hw_events.events), GFP_KERNEL);\n\n\tif (!cspmu->hw_events.events)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic inline int arm_cspmu_get_reset_overflow(struct arm_cspmu *cspmu,\n\t\t\t\t\t       u32 *pmovs)\n{\n\tint i;\n\tu32 pmovclr_offset = PMOVSCLR;\n\tu32 has_overflowed = 0;\n\n\tfor (i = 0; i < cspmu->num_set_clr_reg; ++i) {\n\t\tpmovs[i] = readl(cspmu->base1 + pmovclr_offset);\n\t\thas_overflowed |= pmovs[i];\n\t\twritel(pmovs[i], cspmu->base1 + pmovclr_offset);\n\t\tpmovclr_offset += sizeof(u32);\n\t}\n\n\treturn has_overflowed != 0;\n}\n\nstatic irqreturn_t arm_cspmu_handle_irq(int irq_num, void *dev)\n{\n\tint idx, has_overflowed;\n\tstruct perf_event *event;\n\tstruct arm_cspmu *cspmu = dev;\n\tDECLARE_BITMAP(pmovs, ARM_CSPMU_MAX_HW_CNTRS);\n\tbool handled = false;\n\n\tarm_cspmu_stop_counters(cspmu);\n\n\thas_overflowed = arm_cspmu_get_reset_overflow(cspmu, (u32 *)pmovs);\n\tif (!has_overflowed)\n\t\tgoto done;\n\n\tfor_each_set_bit(idx, cspmu->hw_events.used_ctrs,\n\t\t\tcspmu->num_logical_ctrs) {\n\t\tevent = cspmu->hw_events.events[idx];\n\n\t\tif (!event)\n\t\t\tcontinue;\n\n\t\tif (!test_bit(event->hw.idx, pmovs))\n\t\t\tcontinue;\n\n\t\tarm_cspmu_event_update(event);\n\t\tarm_cspmu_set_event_period(event);\n\n\t\thandled = true;\n\t}\n\ndone:\n\tarm_cspmu_start_counters(cspmu);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic int arm_cspmu_request_irq(struct arm_cspmu *cspmu)\n{\n\tint irq, ret;\n\tstruct device *dev;\n\tstruct platform_device *pdev;\n\n\tdev = cspmu->dev;\n\tpdev = to_platform_device(dev);\n\n\t \n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq == -ENXIO ? 0 : irq;\n\n\tret = devm_request_irq(dev, irq, arm_cspmu_handle_irq,\n\t\t\t       IRQF_NOBALANCING | IRQF_NO_THREAD, dev_name(dev),\n\t\t\t       cspmu);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not request IRQ %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\tcspmu->irq = irq;\n\n\treturn 0;\n}\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_ARM64)\n#include <acpi/processor.h>\n\nstatic inline int arm_cspmu_find_cpu_container(int cpu, u32 container_uid)\n{\n\tu32 acpi_uid;\n\tstruct device *cpu_dev;\n\tstruct acpi_device *acpi_dev;\n\n\tcpu_dev = get_cpu_device(cpu);\n\tif (!cpu_dev)\n\t\treturn -ENODEV;\n\n\tacpi_dev = ACPI_COMPANION(cpu_dev);\n\twhile (acpi_dev) {\n\t\tif (!strcmp(acpi_device_hid(acpi_dev),\n\t\t\t    ACPI_PROCESSOR_CONTAINER_HID) &&\n\t\t    !kstrtouint(acpi_device_uid(acpi_dev), 0, &acpi_uid) &&\n\t\t    acpi_uid == container_uid)\n\t\t\treturn 0;\n\n\t\tacpi_dev = acpi_dev_parent(acpi_dev);\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int arm_cspmu_acpi_get_cpus(struct arm_cspmu *cspmu)\n{\n\tstruct acpi_apmt_node *apmt_node;\n\tint affinity_flag;\n\tint cpu;\n\n\tapmt_node = arm_cspmu_apmt_node(cspmu->dev);\n\taffinity_flag = apmt_node->flags & ACPI_APMT_FLAGS_AFFINITY;\n\n\tif (affinity_flag == ACPI_APMT_FLAGS_AFFINITY_PROC) {\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tif (apmt_node->proc_affinity ==\n\t\t\t    get_acpi_id_for_cpu(cpu)) {\n\t\t\t\tcpumask_set_cpu(cpu, &cspmu->associated_cpus);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tif (arm_cspmu_find_cpu_container(\n\t\t\t\t    cpu, apmt_node->proc_affinity))\n\t\t\t\tcontinue;\n\n\t\t\tcpumask_set_cpu(cpu, &cspmu->associated_cpus);\n\t\t}\n\t}\n\n\tif (cpumask_empty(&cspmu->associated_cpus)) {\n\t\tdev_dbg(cspmu->dev, \"No cpu associated with the PMU\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n#else\nstatic int arm_cspmu_acpi_get_cpus(struct arm_cspmu *cspmu)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic int arm_cspmu_get_cpus(struct arm_cspmu *cspmu)\n{\n\treturn arm_cspmu_acpi_get_cpus(cspmu);\n}\n\nstatic int arm_cspmu_register_pmu(struct arm_cspmu *cspmu)\n{\n\tint ret, capabilities;\n\tstruct attribute_group **attr_groups;\n\n\tattr_groups = arm_cspmu_alloc_attr_group(cspmu);\n\tif (!attr_groups)\n\t\treturn -ENOMEM;\n\n\tret = cpuhp_state_add_instance(arm_cspmu_cpuhp_state,\n\t\t\t\t       &cspmu->cpuhp_node);\n\tif (ret)\n\t\treturn ret;\n\n\tcapabilities = PERF_PMU_CAP_NO_EXCLUDE;\n\tif (cspmu->irq == 0)\n\t\tcapabilities |= PERF_PMU_CAP_NO_INTERRUPT;\n\n\tcspmu->pmu = (struct pmu){\n\t\t.task_ctx_nr\t= perf_invalid_context,\n\t\t.module\t\t= THIS_MODULE,\n\t\t.pmu_enable\t= arm_cspmu_enable,\n\t\t.pmu_disable\t= arm_cspmu_disable,\n\t\t.event_init\t= arm_cspmu_event_init,\n\t\t.add\t\t= arm_cspmu_add,\n\t\t.del\t\t= arm_cspmu_del,\n\t\t.start\t\t= arm_cspmu_start,\n\t\t.stop\t\t= arm_cspmu_stop,\n\t\t.read\t\t= arm_cspmu_read,\n\t\t.attr_groups\t= (const struct attribute_group **)attr_groups,\n\t\t.capabilities\t= capabilities,\n\t};\n\n\t \n\tarm_cspmu_stop_counters(cspmu);\n\tarm_cspmu_reset_counters(cspmu);\n\n\tret = perf_pmu_register(&cspmu->pmu, cspmu->name, -1);\n\tif (ret) {\n\t\tcpuhp_state_remove_instance(arm_cspmu_cpuhp_state,\n\t\t\t\t\t    &cspmu->cpuhp_node);\n\t}\n\n\treturn ret;\n}\n\nstatic int arm_cspmu_device_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct arm_cspmu *cspmu;\n\n\tcspmu = arm_cspmu_alloc(pdev);\n\tif (!cspmu)\n\t\treturn -ENOMEM;\n\n\tret = arm_cspmu_init_mmio(cspmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = arm_cspmu_request_irq(cspmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = arm_cspmu_get_cpus(cspmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = arm_cspmu_register_pmu(cspmu);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int arm_cspmu_device_remove(struct platform_device *pdev)\n{\n\tstruct arm_cspmu *cspmu = platform_get_drvdata(pdev);\n\n\tperf_pmu_unregister(&cspmu->pmu);\n\tcpuhp_state_remove_instance(arm_cspmu_cpuhp_state, &cspmu->cpuhp_node);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id arm_cspmu_id[] = {\n\t{DRVNAME, 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, arm_cspmu_id);\n\nstatic struct platform_driver arm_cspmu_driver = {\n\t.driver = {\n\t\t\t.name = DRVNAME,\n\t\t\t.suppress_bind_attrs = true,\n\t\t},\n\t.probe = arm_cspmu_device_probe,\n\t.remove = arm_cspmu_device_remove,\n\t.id_table = arm_cspmu_id,\n};\n\nstatic void arm_cspmu_set_active_cpu(int cpu, struct arm_cspmu *cspmu)\n{\n\tcpumask_set_cpu(cpu, &cspmu->active_cpu);\n\tif (cspmu->irq)\n\t\tWARN_ON(irq_set_affinity(cspmu->irq, &cspmu->active_cpu));\n}\n\nstatic int arm_cspmu_cpu_online(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct arm_cspmu *cspmu =\n\t\thlist_entry_safe(node, struct arm_cspmu, cpuhp_node);\n\n\tif (!cpumask_test_cpu(cpu, &cspmu->associated_cpus))\n\t\treturn 0;\n\n\t \n\tif (!cpumask_empty(&cspmu->active_cpu))\n\t\treturn 0;\n\n\t \n\tarm_cspmu_set_active_cpu(cpu, cspmu);\n\n\treturn 0;\n}\n\nstatic int arm_cspmu_cpu_teardown(unsigned int cpu, struct hlist_node *node)\n{\n\tint dst;\n\tstruct cpumask online_supported;\n\n\tstruct arm_cspmu *cspmu =\n\t\thlist_entry_safe(node, struct arm_cspmu, cpuhp_node);\n\n\t \n\tif (!cpumask_test_and_clear_cpu(cpu, &cspmu->active_cpu))\n\t\treturn 0;\n\n\t \n\tcpumask_and(&online_supported, &cspmu->associated_cpus,\n\t\t    cpu_online_mask);\n\tdst = cpumask_any_but(&online_supported, cpu);\n\tif (dst >= nr_cpu_ids)\n\t\treturn 0;\n\n\t \n\tperf_pmu_migrate_context(&cspmu->pmu, cpu, dst);\n\tarm_cspmu_set_active_cpu(dst, cspmu);\n\n\treturn 0;\n}\n\nstatic int __init arm_cspmu_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"perf/arm/cspmu:online\",\n\t\t\t\t\tarm_cspmu_cpu_online,\n\t\t\t\t\tarm_cspmu_cpu_teardown);\n\tif (ret < 0)\n\t\treturn ret;\n\tarm_cspmu_cpuhp_state = ret;\n\treturn platform_driver_register(&arm_cspmu_driver);\n}\n\nstatic void __exit arm_cspmu_exit(void)\n{\n\tplatform_driver_unregister(&arm_cspmu_driver);\n\tcpuhp_remove_multi_state(arm_cspmu_cpuhp_state);\n}\n\nmodule_init(arm_cspmu_init);\nmodule_exit(arm_cspmu_exit);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}