{
  "module_name": "arm-ccn.c",
  "hash_id": "105249ae37364a9ce1c9088c825f065f951a2ab6b207bdca089395927b0cf8ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/arm-ccn.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/hrtimer.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/perf_event.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define CCN_NUM_XP_PORTS 2\n#define CCN_NUM_VCS 4\n#define CCN_NUM_REGIONS\t256\n#define CCN_REGION_SIZE\t0x10000\n\n#define CCN_ALL_OLY_ID\t\t\t0xff00\n#define CCN_ALL_OLY_ID__OLY_ID__SHIFT\t\t\t0\n#define CCN_ALL_OLY_ID__OLY_ID__MASK\t\t\t0x1f\n#define CCN_ALL_OLY_ID__NODE_ID__SHIFT\t\t\t8\n#define CCN_ALL_OLY_ID__NODE_ID__MASK\t\t\t0x3f\n\n#define CCN_MN_ERRINT_STATUS\t\t0x0008\n#define CCN_MN_ERRINT_STATUS__INTREQ__DESSERT\t\t0x11\n#define CCN_MN_ERRINT_STATUS__ALL_ERRORS__ENABLE\t0x02\n#define CCN_MN_ERRINT_STATUS__ALL_ERRORS__DISABLED\t0x20\n#define CCN_MN_ERRINT_STATUS__ALL_ERRORS__DISABLE\t0x22\n#define CCN_MN_ERRINT_STATUS__CORRECTED_ERRORS_ENABLE\t0x04\n#define CCN_MN_ERRINT_STATUS__CORRECTED_ERRORS_DISABLED\t0x40\n#define CCN_MN_ERRINT_STATUS__CORRECTED_ERRORS_DISABLE\t0x44\n#define CCN_MN_ERRINT_STATUS__PMU_EVENTS__ENABLE\t0x08\n#define CCN_MN_ERRINT_STATUS__PMU_EVENTS__DISABLED\t0x80\n#define CCN_MN_ERRINT_STATUS__PMU_EVENTS__DISABLE\t0x88\n#define CCN_MN_OLY_COMP_LIST_63_0\t0x01e0\n#define CCN_MN_ERR_SIG_VAL_63_0\t\t0x0300\n#define CCN_MN_ERR_SIG_VAL_63_0__DT\t\t\t(1 << 1)\n\n#define CCN_DT_ACTIVE_DSM\t\t0x0000\n#define CCN_DT_ACTIVE_DSM__DSM_ID__SHIFT(n)\t\t((n) * 8)\n#define CCN_DT_ACTIVE_DSM__DSM_ID__MASK\t\t\t0xff\n#define CCN_DT_CTL\t\t\t0x0028\n#define CCN_DT_CTL__DT_EN\t\t\t\t(1 << 0)\n#define CCN_DT_PMEVCNT(n)\t\t(0x0100 + (n) * 0x8)\n#define CCN_DT_PMCCNTR\t\t\t0x0140\n#define CCN_DT_PMCCNTRSR\t\t0x0190\n#define CCN_DT_PMOVSR\t\t\t0x0198\n#define CCN_DT_PMOVSR_CLR\t\t0x01a0\n#define CCN_DT_PMOVSR_CLR__MASK\t\t\t\t0x1f\n#define CCN_DT_PMCR\t\t\t0x01a8\n#define CCN_DT_PMCR__OVFL_INTR_EN\t\t\t(1 << 6)\n#define CCN_DT_PMCR__PMU_EN\t\t\t\t(1 << 0)\n#define CCN_DT_PMSR\t\t\t0x01b0\n#define CCN_DT_PMSR_REQ\t\t\t0x01b8\n#define CCN_DT_PMSR_CLR\t\t\t0x01c0\n\n#define CCN_HNF_PMU_EVENT_SEL\t\t0x0600\n#define CCN_HNF_PMU_EVENT_SEL__ID__SHIFT(n)\t\t((n) * 4)\n#define CCN_HNF_PMU_EVENT_SEL__ID__MASK\t\t\t0xf\n\n#define CCN_XP_DT_CONFIG\t\t0x0300\n#define CCN_XP_DT_CONFIG__DT_CFG__SHIFT(n)\t\t((n) * 4)\n#define CCN_XP_DT_CONFIG__DT_CFG__MASK\t\t\t0xf\n#define CCN_XP_DT_CONFIG__DT_CFG__PASS_THROUGH\t\t0x0\n#define CCN_XP_DT_CONFIG__DT_CFG__WATCHPOINT_0_OR_1\t0x1\n#define CCN_XP_DT_CONFIG__DT_CFG__WATCHPOINT(n)\t\t(0x2 + (n))\n#define CCN_XP_DT_CONFIG__DT_CFG__XP_PMU_EVENT(n)\t(0x4 + (n))\n#define CCN_XP_DT_CONFIG__DT_CFG__DEVICE_PMU_EVENT(d, n) (0x8 + (d) * 4 + (n))\n#define CCN_XP_DT_INTERFACE_SEL\t\t0x0308\n#define CCN_XP_DT_INTERFACE_SEL__DT_IO_SEL__SHIFT(n)\t(0 + (n) * 8)\n#define CCN_XP_DT_INTERFACE_SEL__DT_IO_SEL__MASK\t0x1\n#define CCN_XP_DT_INTERFACE_SEL__DT_DEV_SEL__SHIFT(n)\t(1 + (n) * 8)\n#define CCN_XP_DT_INTERFACE_SEL__DT_DEV_SEL__MASK\t0x1\n#define CCN_XP_DT_INTERFACE_SEL__DT_VC_SEL__SHIFT(n)\t(2 + (n) * 8)\n#define CCN_XP_DT_INTERFACE_SEL__DT_VC_SEL__MASK\t0x3\n#define CCN_XP_DT_CMP_VAL_L(n)\t\t(0x0310 + (n) * 0x40)\n#define CCN_XP_DT_CMP_VAL_H(n)\t\t(0x0318 + (n) * 0x40)\n#define CCN_XP_DT_CMP_MASK_L(n)\t\t(0x0320 + (n) * 0x40)\n#define CCN_XP_DT_CMP_MASK_H(n)\t\t(0x0328 + (n) * 0x40)\n#define CCN_XP_DT_CONTROL\t\t0x0370\n#define CCN_XP_DT_CONTROL__DT_ENABLE\t\t\t(1 << 0)\n#define CCN_XP_DT_CONTROL__WP_ARM_SEL__SHIFT(n)\t\t(12 + (n) * 4)\n#define CCN_XP_DT_CONTROL__WP_ARM_SEL__MASK\t\t0xf\n#define CCN_XP_DT_CONTROL__WP_ARM_SEL__ALWAYS\t\t0xf\n#define CCN_XP_PMU_EVENT_SEL\t\t0x0600\n#define CCN_XP_PMU_EVENT_SEL__ID__SHIFT(n)\t\t((n) * 7)\n#define CCN_XP_PMU_EVENT_SEL__ID__MASK\t\t\t0x3f\n\n#define CCN_SBAS_PMU_EVENT_SEL\t\t0x0600\n#define CCN_SBAS_PMU_EVENT_SEL__ID__SHIFT(n)\t\t((n) * 4)\n#define CCN_SBAS_PMU_EVENT_SEL__ID__MASK\t\t0xf\n\n#define CCN_RNI_PMU_EVENT_SEL\t\t0x0600\n#define CCN_RNI_PMU_EVENT_SEL__ID__SHIFT(n)\t\t((n) * 4)\n#define CCN_RNI_PMU_EVENT_SEL__ID__MASK\t\t\t0xf\n\n#define CCN_TYPE_MN\t0x01\n#define CCN_TYPE_DT\t0x02\n#define CCN_TYPE_HNF\t0x04\n#define CCN_TYPE_HNI\t0x05\n#define CCN_TYPE_XP\t0x08\n#define CCN_TYPE_SBSX\t0x0c\n#define CCN_TYPE_SBAS\t0x10\n#define CCN_TYPE_RNI_1P\t0x14\n#define CCN_TYPE_RNI_2P\t0x15\n#define CCN_TYPE_RNI_3P\t0x16\n#define CCN_TYPE_RND_1P\t0x18  \n#define CCN_TYPE_RND_2P\t0x19\n#define CCN_TYPE_RND_3P\t0x1a\n#define CCN_TYPE_CYCLES\t0xff  \n\n#define CCN_EVENT_WATCHPOINT 0xfe  \n\n#define CCN_NUM_PMU_EVENTS\t\t4\n#define CCN_NUM_XP_WATCHPOINTS\t\t2  \n#define CCN_NUM_PMU_EVENT_COUNTERS\t8  \n#define CCN_IDX_PMU_CYCLE_COUNTER\tCCN_NUM_PMU_EVENT_COUNTERS\n\n#define CCN_NUM_PREDEFINED_MASKS\t4\n#define CCN_IDX_MASK_ANY\t\t(CCN_NUM_PMU_EVENT_COUNTERS + 0)\n#define CCN_IDX_MASK_EXACT\t\t(CCN_NUM_PMU_EVENT_COUNTERS + 1)\n#define CCN_IDX_MASK_ORDER\t\t(CCN_NUM_PMU_EVENT_COUNTERS + 2)\n#define CCN_IDX_MASK_OPCODE\t\t(CCN_NUM_PMU_EVENT_COUNTERS + 3)\n\nstruct arm_ccn_component {\n\tvoid __iomem *base;\n\tu32 type;\n\n\tDECLARE_BITMAP(pmu_events_mask, CCN_NUM_PMU_EVENTS);\n\tunion {\n\t\tstruct {\n\t\t\tDECLARE_BITMAP(dt_cmp_mask, CCN_NUM_XP_WATCHPOINTS);\n\t\t} xp;\n\t};\n};\n\n#define pmu_to_arm_ccn(_pmu) container_of(container_of(_pmu, \\\n\tstruct arm_ccn_dt, pmu), struct arm_ccn, dt)\n\nstruct arm_ccn_dt {\n\tint id;\n\tvoid __iomem *base;\n\n\tspinlock_t config_lock;\n\n\tDECLARE_BITMAP(pmu_counters_mask, CCN_NUM_PMU_EVENT_COUNTERS + 1);\n\tstruct {\n\t\tstruct arm_ccn_component *source;\n\t\tstruct perf_event *event;\n\t} pmu_counters[CCN_NUM_PMU_EVENT_COUNTERS + 1];\n\n\tstruct {\n\t       u64 l, h;\n\t} cmp_mask[CCN_NUM_PMU_EVENT_COUNTERS + CCN_NUM_PREDEFINED_MASKS];\n\n\tstruct hrtimer hrtimer;\n\n\tunsigned int cpu;\n\tstruct hlist_node node;\n\n\tstruct pmu pmu;\n};\n\nstruct arm_ccn {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tunsigned int irq;\n\n\tunsigned sbas_present:1;\n\tunsigned sbsx_present:1;\n\n\tint num_nodes;\n\tstruct arm_ccn_component *node;\n\n\tint num_xps;\n\tstruct arm_ccn_component *xp;\n\n\tstruct arm_ccn_dt dt;\n\tint mn_id;\n};\n\nstatic int arm_ccn_node_to_xp(int node)\n{\n\treturn node / CCN_NUM_XP_PORTS;\n}\n\nstatic int arm_ccn_node_to_xp_port(int node)\n{\n\treturn node % CCN_NUM_XP_PORTS;\n}\n\n\n \n#define CCN_CONFIG_NODE(_config)\t(((_config) >> 0) & 0xff)\n#define CCN_CONFIG_XP(_config)\t\t(((_config) >> 0) & 0xff)\n#define CCN_CONFIG_TYPE(_config)\t(((_config) >> 8) & 0xff)\n#define CCN_CONFIG_EVENT(_config)\t(((_config) >> 16) & 0xff)\n#define CCN_CONFIG_PORT(_config)\t(((_config) >> 24) & 0x3)\n#define CCN_CONFIG_BUS(_config)\t\t(((_config) >> 24) & 0x3)\n#define CCN_CONFIG_VC(_config)\t\t(((_config) >> 26) & 0x7)\n#define CCN_CONFIG_DIR(_config)\t\t(((_config) >> 29) & 0x1)\n#define CCN_CONFIG_MASK(_config)\t(((_config) >> 30) & 0xf)\n\nstatic void arm_ccn_pmu_config_set(u64 *config, u32 node_xp, u32 type, u32 port)\n{\n\t*config &= ~((0xff << 0) | (0xff << 8) | (0x3 << 24));\n\t*config |= (node_xp << 0) | (type << 8) | (port << 24);\n}\n\nstatic ssize_t arm_ccn_pmu_format_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dev_ext_attribute *ea = container_of(attr,\n\t\t\tstruct dev_ext_attribute, attr);\n\n\treturn sysfs_emit(buf, \"%s\\n\", (char *)ea->var);\n}\n\n#define CCN_FORMAT_ATTR(_name, _config) \\\n\tstruct dev_ext_attribute arm_ccn_pmu_format_attr_##_name = \\\n\t\t\t{ __ATTR(_name, S_IRUGO, arm_ccn_pmu_format_show, \\\n\t\t\tNULL), _config }\n\nstatic CCN_FORMAT_ATTR(node, \"config:0-7\");\nstatic CCN_FORMAT_ATTR(xp, \"config:0-7\");\nstatic CCN_FORMAT_ATTR(type, \"config:8-15\");\nstatic CCN_FORMAT_ATTR(event, \"config:16-23\");\nstatic CCN_FORMAT_ATTR(port, \"config:24-25\");\nstatic CCN_FORMAT_ATTR(bus, \"config:24-25\");\nstatic CCN_FORMAT_ATTR(vc, \"config:26-28\");\nstatic CCN_FORMAT_ATTR(dir, \"config:29-29\");\nstatic CCN_FORMAT_ATTR(mask, \"config:30-33\");\nstatic CCN_FORMAT_ATTR(cmp_l, \"config1:0-62\");\nstatic CCN_FORMAT_ATTR(cmp_h, \"config2:0-59\");\n\nstatic struct attribute *arm_ccn_pmu_format_attrs[] = {\n\t&arm_ccn_pmu_format_attr_node.attr.attr,\n\t&arm_ccn_pmu_format_attr_xp.attr.attr,\n\t&arm_ccn_pmu_format_attr_type.attr.attr,\n\t&arm_ccn_pmu_format_attr_event.attr.attr,\n\t&arm_ccn_pmu_format_attr_port.attr.attr,\n\t&arm_ccn_pmu_format_attr_bus.attr.attr,\n\t&arm_ccn_pmu_format_attr_vc.attr.attr,\n\t&arm_ccn_pmu_format_attr_dir.attr.attr,\n\t&arm_ccn_pmu_format_attr_mask.attr.attr,\n\t&arm_ccn_pmu_format_attr_cmp_l.attr.attr,\n\t&arm_ccn_pmu_format_attr_cmp_h.attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group arm_ccn_pmu_format_attr_group = {\n\t.name = \"format\",\n\t.attrs = arm_ccn_pmu_format_attrs,\n};\n\n\nstruct arm_ccn_pmu_event {\n\tstruct device_attribute attr;\n\tu32 type;\n\tu32 event;\n\tint num_ports;\n\tint num_vcs;\n\tconst char *def;\n\tint mask;\n};\n\n#define CCN_EVENT_ATTR(_name) \\\n\t__ATTR(_name, S_IRUGO, arm_ccn_pmu_event_show, NULL)\n\n \n\n#define CCN_EVENT_MN(_name, _def, _mask) { .attr = CCN_EVENT_ATTR(mn_##_name), \\\n\t\t.type = CCN_TYPE_MN, .event = CCN_EVENT_WATCHPOINT, \\\n\t\t.num_ports = CCN_NUM_XP_PORTS, .num_vcs = CCN_NUM_VCS, \\\n\t\t.def = _def, .mask = _mask, }\n\n#define CCN_EVENT_HNI(_name, _def, _mask) { \\\n\t\t.attr = CCN_EVENT_ATTR(hni_##_name), .type = CCN_TYPE_HNI, \\\n\t\t.event = CCN_EVENT_WATCHPOINT, .num_ports = CCN_NUM_XP_PORTS, \\\n\t\t.num_vcs = CCN_NUM_VCS, .def = _def, .mask = _mask, }\n\n#define CCN_EVENT_SBSX(_name, _def, _mask) { \\\n\t\t.attr = CCN_EVENT_ATTR(sbsx_##_name), .type = CCN_TYPE_SBSX, \\\n\t\t.event = CCN_EVENT_WATCHPOINT, .num_ports = CCN_NUM_XP_PORTS, \\\n\t\t.num_vcs = CCN_NUM_VCS, .def = _def, .mask = _mask, }\n\n#define CCN_EVENT_HNF(_name, _event) { .attr = CCN_EVENT_ATTR(hnf_##_name), \\\n\t\t.type = CCN_TYPE_HNF, .event = _event, }\n\n#define CCN_EVENT_XP(_name, _event) { .attr = CCN_EVENT_ATTR(xp_##_name), \\\n\t\t.type = CCN_TYPE_XP, .event = _event, \\\n\t\t.num_ports = CCN_NUM_XP_PORTS, .num_vcs = CCN_NUM_VCS, }\n\n \n#define CCN_EVENT_RNI(_name, _event) { .attr = CCN_EVENT_ATTR(rni_##_name), \\\n\t\t.type = CCN_TYPE_RNI_3P, .event = _event, }\n\n#define CCN_EVENT_SBAS(_name, _event) { .attr = CCN_EVENT_ATTR(sbas_##_name), \\\n\t\t.type = CCN_TYPE_SBAS, .event = _event, }\n\n#define CCN_EVENT_CYCLES(_name) { .attr = CCN_EVENT_ATTR(_name), \\\n\t\t.type = CCN_TYPE_CYCLES }\n\n\nstatic ssize_t arm_ccn_pmu_event_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(dev_get_drvdata(dev));\n\tstruct arm_ccn_pmu_event *event = container_of(attr,\n\t\t\tstruct arm_ccn_pmu_event, attr);\n\tint res;\n\n\tres = sysfs_emit(buf, \"type=0x%x\", event->type);\n\tif (event->event)\n\t\tres += sysfs_emit_at(buf, res, \",event=0x%x\", event->event);\n\tif (event->def)\n\t\tres += sysfs_emit_at(buf, res, \",%s\", event->def);\n\tif (event->mask)\n\t\tres += sysfs_emit_at(buf, res, \",mask=0x%x\", event->mask);\n\n\t \n\tswitch (event->type) {\n\tcase CCN_TYPE_CYCLES:\n\t\tbreak;\n\tcase CCN_TYPE_XP:\n\t\tres += sysfs_emit_at(buf, res, \",xp=?,vc=?\");\n\t\tif (event->event == CCN_EVENT_WATCHPOINT)\n\t\t\tres += sysfs_emit_at(buf, res,\n\t\t\t\t\t\",port=?,dir=?,cmp_l=?,cmp_h=?,mask=?\");\n\t\telse\n\t\t\tres += sysfs_emit_at(buf, res, \",bus=?\");\n\n\t\tbreak;\n\tcase CCN_TYPE_MN:\n\t\tres += sysfs_emit_at(buf, res, \",node=%d\", ccn->mn_id);\n\t\tbreak;\n\tdefault:\n\t\tres += sysfs_emit_at(buf, res, \",node=?\");\n\t\tbreak;\n\t}\n\n\tres += sysfs_emit_at(buf, res, \"\\n\");\n\n\treturn res;\n}\n\nstatic umode_t arm_ccn_pmu_events_is_visible(struct kobject *kobj,\n\t\t\t\t     struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(dev_get_drvdata(dev));\n\tstruct device_attribute *dev_attr = container_of(attr,\n\t\t\tstruct device_attribute, attr);\n\tstruct arm_ccn_pmu_event *event = container_of(dev_attr,\n\t\t\tstruct arm_ccn_pmu_event, attr);\n\n\tif (event->type == CCN_TYPE_SBAS && !ccn->sbas_present)\n\t\treturn 0;\n\tif (event->type == CCN_TYPE_SBSX && !ccn->sbsx_present)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic struct arm_ccn_pmu_event arm_ccn_pmu_events[] = {\n\tCCN_EVENT_MN(eobarrier, \"dir=1,vc=0,cmp_h=0x1c00\", CCN_IDX_MASK_OPCODE),\n\tCCN_EVENT_MN(ecbarrier, \"dir=1,vc=0,cmp_h=0x1e00\", CCN_IDX_MASK_OPCODE),\n\tCCN_EVENT_MN(dvmop, \"dir=1,vc=0,cmp_h=0x2800\", CCN_IDX_MASK_OPCODE),\n\tCCN_EVENT_HNI(txdatflits, \"dir=1,vc=3\", CCN_IDX_MASK_ANY),\n\tCCN_EVENT_HNI(rxdatflits, \"dir=0,vc=3\", CCN_IDX_MASK_ANY),\n\tCCN_EVENT_HNI(txreqflits, \"dir=1,vc=0\", CCN_IDX_MASK_ANY),\n\tCCN_EVENT_HNI(rxreqflits, \"dir=0,vc=0\", CCN_IDX_MASK_ANY),\n\tCCN_EVENT_HNI(rxreqflits_order, \"dir=0,vc=0,cmp_h=0x8000\",\n\t\t\tCCN_IDX_MASK_ORDER),\n\tCCN_EVENT_SBSX(txdatflits, \"dir=1,vc=3\", CCN_IDX_MASK_ANY),\n\tCCN_EVENT_SBSX(rxdatflits, \"dir=0,vc=3\", CCN_IDX_MASK_ANY),\n\tCCN_EVENT_SBSX(txreqflits, \"dir=1,vc=0\", CCN_IDX_MASK_ANY),\n\tCCN_EVENT_SBSX(rxreqflits, \"dir=0,vc=0\", CCN_IDX_MASK_ANY),\n\tCCN_EVENT_SBSX(rxreqflits_order, \"dir=0,vc=0,cmp_h=0x8000\",\n\t\t\tCCN_IDX_MASK_ORDER),\n\tCCN_EVENT_HNF(cache_miss, 0x1),\n\tCCN_EVENT_HNF(l3_sf_cache_access, 0x02),\n\tCCN_EVENT_HNF(cache_fill, 0x3),\n\tCCN_EVENT_HNF(pocq_retry, 0x4),\n\tCCN_EVENT_HNF(pocq_reqs_recvd, 0x5),\n\tCCN_EVENT_HNF(sf_hit, 0x6),\n\tCCN_EVENT_HNF(sf_evictions, 0x7),\n\tCCN_EVENT_HNF(snoops_sent, 0x8),\n\tCCN_EVENT_HNF(snoops_broadcast, 0x9),\n\tCCN_EVENT_HNF(l3_eviction, 0xa),\n\tCCN_EVENT_HNF(l3_fill_invalid_way, 0xb),\n\tCCN_EVENT_HNF(mc_retries, 0xc),\n\tCCN_EVENT_HNF(mc_reqs, 0xd),\n\tCCN_EVENT_HNF(qos_hh_retry, 0xe),\n\tCCN_EVENT_RNI(rdata_beats_p0, 0x1),\n\tCCN_EVENT_RNI(rdata_beats_p1, 0x2),\n\tCCN_EVENT_RNI(rdata_beats_p2, 0x3),\n\tCCN_EVENT_RNI(rxdat_flits, 0x4),\n\tCCN_EVENT_RNI(txdat_flits, 0x5),\n\tCCN_EVENT_RNI(txreq_flits, 0x6),\n\tCCN_EVENT_RNI(txreq_flits_retried, 0x7),\n\tCCN_EVENT_RNI(rrt_full, 0x8),\n\tCCN_EVENT_RNI(wrt_full, 0x9),\n\tCCN_EVENT_RNI(txreq_flits_replayed, 0xa),\n\tCCN_EVENT_XP(upload_starvation, 0x1),\n\tCCN_EVENT_XP(download_starvation, 0x2),\n\tCCN_EVENT_XP(respin, 0x3),\n\tCCN_EVENT_XP(valid_flit, 0x4),\n\tCCN_EVENT_XP(watchpoint, CCN_EVENT_WATCHPOINT),\n\tCCN_EVENT_SBAS(rdata_beats_p0, 0x1),\n\tCCN_EVENT_SBAS(rxdat_flits, 0x4),\n\tCCN_EVENT_SBAS(txdat_flits, 0x5),\n\tCCN_EVENT_SBAS(txreq_flits, 0x6),\n\tCCN_EVENT_SBAS(txreq_flits_retried, 0x7),\n\tCCN_EVENT_SBAS(rrt_full, 0x8),\n\tCCN_EVENT_SBAS(wrt_full, 0x9),\n\tCCN_EVENT_SBAS(txreq_flits_replayed, 0xa),\n\tCCN_EVENT_CYCLES(cycles),\n};\n\n \nstatic struct attribute\n\t\t*arm_ccn_pmu_events_attrs[ARRAY_SIZE(arm_ccn_pmu_events) + 1];\n\nstatic const struct attribute_group arm_ccn_pmu_events_attr_group = {\n\t.name = \"events\",\n\t.is_visible = arm_ccn_pmu_events_is_visible,\n\t.attrs = arm_ccn_pmu_events_attrs,\n};\n\n\nstatic u64 *arm_ccn_pmu_get_cmp_mask(struct arm_ccn *ccn, const char *name)\n{\n\tunsigned long i;\n\n\tif (WARN_ON(!name || !name[0] || !isxdigit(name[0]) || !name[1]))\n\t\treturn NULL;\n\ti = isdigit(name[0]) ? name[0] - '0' : 0xa + tolower(name[0]) - 'a';\n\n\tswitch (name[1]) {\n\tcase 'l':\n\t\treturn &ccn->dt.cmp_mask[i].l;\n\tcase 'h':\n\t\treturn &ccn->dt.cmp_mask[i].h;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic ssize_t arm_ccn_pmu_cmp_mask_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(dev_get_drvdata(dev));\n\tu64 *mask = arm_ccn_pmu_get_cmp_mask(ccn, attr->attr.name);\n\n\treturn mask ? sysfs_emit(buf, \"0x%016llx\\n\", *mask) : -EINVAL;\n}\n\nstatic ssize_t arm_ccn_pmu_cmp_mask_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(dev_get_drvdata(dev));\n\tu64 *mask = arm_ccn_pmu_get_cmp_mask(ccn, attr->attr.name);\n\tint err = -EINVAL;\n\n\tif (mask)\n\t\terr = kstrtoull(buf, 0, mask);\n\n\treturn err ? err : count;\n}\n\n#define CCN_CMP_MASK_ATTR(_name) \\\n\tstruct device_attribute arm_ccn_pmu_cmp_mask_attr_##_name = \\\n\t\t\t__ATTR(_name, S_IRUGO | S_IWUSR, \\\n\t\t\tarm_ccn_pmu_cmp_mask_show, arm_ccn_pmu_cmp_mask_store)\n\n#define CCN_CMP_MASK_ATTR_RO(_name) \\\n\tstruct device_attribute arm_ccn_pmu_cmp_mask_attr_##_name = \\\n\t\t\t__ATTR(_name, S_IRUGO, arm_ccn_pmu_cmp_mask_show, NULL)\n\nstatic CCN_CMP_MASK_ATTR(0l);\nstatic CCN_CMP_MASK_ATTR(0h);\nstatic CCN_CMP_MASK_ATTR(1l);\nstatic CCN_CMP_MASK_ATTR(1h);\nstatic CCN_CMP_MASK_ATTR(2l);\nstatic CCN_CMP_MASK_ATTR(2h);\nstatic CCN_CMP_MASK_ATTR(3l);\nstatic CCN_CMP_MASK_ATTR(3h);\nstatic CCN_CMP_MASK_ATTR(4l);\nstatic CCN_CMP_MASK_ATTR(4h);\nstatic CCN_CMP_MASK_ATTR(5l);\nstatic CCN_CMP_MASK_ATTR(5h);\nstatic CCN_CMP_MASK_ATTR(6l);\nstatic CCN_CMP_MASK_ATTR(6h);\nstatic CCN_CMP_MASK_ATTR(7l);\nstatic CCN_CMP_MASK_ATTR(7h);\nstatic CCN_CMP_MASK_ATTR_RO(8l);\nstatic CCN_CMP_MASK_ATTR_RO(8h);\nstatic CCN_CMP_MASK_ATTR_RO(9l);\nstatic CCN_CMP_MASK_ATTR_RO(9h);\nstatic CCN_CMP_MASK_ATTR_RO(al);\nstatic CCN_CMP_MASK_ATTR_RO(ah);\nstatic CCN_CMP_MASK_ATTR_RO(bl);\nstatic CCN_CMP_MASK_ATTR_RO(bh);\n\nstatic struct attribute *arm_ccn_pmu_cmp_mask_attrs[] = {\n\t&arm_ccn_pmu_cmp_mask_attr_0l.attr, &arm_ccn_pmu_cmp_mask_attr_0h.attr,\n\t&arm_ccn_pmu_cmp_mask_attr_1l.attr, &arm_ccn_pmu_cmp_mask_attr_1h.attr,\n\t&arm_ccn_pmu_cmp_mask_attr_2l.attr, &arm_ccn_pmu_cmp_mask_attr_2h.attr,\n\t&arm_ccn_pmu_cmp_mask_attr_3l.attr, &arm_ccn_pmu_cmp_mask_attr_3h.attr,\n\t&arm_ccn_pmu_cmp_mask_attr_4l.attr, &arm_ccn_pmu_cmp_mask_attr_4h.attr,\n\t&arm_ccn_pmu_cmp_mask_attr_5l.attr, &arm_ccn_pmu_cmp_mask_attr_5h.attr,\n\t&arm_ccn_pmu_cmp_mask_attr_6l.attr, &arm_ccn_pmu_cmp_mask_attr_6h.attr,\n\t&arm_ccn_pmu_cmp_mask_attr_7l.attr, &arm_ccn_pmu_cmp_mask_attr_7h.attr,\n\t&arm_ccn_pmu_cmp_mask_attr_8l.attr, &arm_ccn_pmu_cmp_mask_attr_8h.attr,\n\t&arm_ccn_pmu_cmp_mask_attr_9l.attr, &arm_ccn_pmu_cmp_mask_attr_9h.attr,\n\t&arm_ccn_pmu_cmp_mask_attr_al.attr, &arm_ccn_pmu_cmp_mask_attr_ah.attr,\n\t&arm_ccn_pmu_cmp_mask_attr_bl.attr, &arm_ccn_pmu_cmp_mask_attr_bh.attr,\n\tNULL\n};\n\nstatic const struct attribute_group arm_ccn_pmu_cmp_mask_attr_group = {\n\t.name = \"cmp_mask\",\n\t.attrs = arm_ccn_pmu_cmp_mask_attrs,\n};\n\nstatic ssize_t arm_ccn_pmu_cpumask_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(dev_get_drvdata(dev));\n\n\treturn cpumap_print_to_pagebuf(true, buf, cpumask_of(ccn->dt.cpu));\n}\n\nstatic struct device_attribute arm_ccn_pmu_cpumask_attr =\n\t\t__ATTR(cpumask, S_IRUGO, arm_ccn_pmu_cpumask_show, NULL);\n\nstatic struct attribute *arm_ccn_pmu_cpumask_attrs[] = {\n\t&arm_ccn_pmu_cpumask_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group arm_ccn_pmu_cpumask_attr_group = {\n\t.attrs = arm_ccn_pmu_cpumask_attrs,\n};\n\n \nstatic unsigned int arm_ccn_pmu_poll_period_us = 10000;\nmodule_param_named(pmu_poll_period_us, arm_ccn_pmu_poll_period_us, uint,\n\t\tS_IRUGO | S_IWUSR);\n\nstatic ktime_t arm_ccn_pmu_timer_period(void)\n{\n\treturn ns_to_ktime((u64)arm_ccn_pmu_poll_period_us * 1000);\n}\n\n\nstatic const struct attribute_group *arm_ccn_pmu_attr_groups[] = {\n\t&arm_ccn_pmu_events_attr_group,\n\t&arm_ccn_pmu_format_attr_group,\n\t&arm_ccn_pmu_cmp_mask_attr_group,\n\t&arm_ccn_pmu_cpumask_attr_group,\n\tNULL\n};\n\n\nstatic int arm_ccn_pmu_alloc_bit(unsigned long *bitmap, unsigned long size)\n{\n\tint bit;\n\n\tdo {\n\t\tbit = find_first_zero_bit(bitmap, size);\n\t\tif (bit >= size)\n\t\t\treturn -EAGAIN;\n\t} while (test_and_set_bit(bit, bitmap));\n\n\treturn bit;\n}\n\n \nstatic int arm_ccn_pmu_type_eq(u32 a, u32 b)\n{\n\tif (a == b)\n\t\treturn 1;\n\n\tswitch (a) {\n\tcase CCN_TYPE_RNI_1P:\n\tcase CCN_TYPE_RNI_2P:\n\tcase CCN_TYPE_RNI_3P:\n\tcase CCN_TYPE_RND_1P:\n\tcase CCN_TYPE_RND_2P:\n\tcase CCN_TYPE_RND_3P:\n\t\tswitch (b) {\n\t\tcase CCN_TYPE_RNI_1P:\n\t\tcase CCN_TYPE_RNI_2P:\n\t\tcase CCN_TYPE_RNI_3P:\n\t\tcase CCN_TYPE_RND_1P:\n\t\tcase CCN_TYPE_RND_2P:\n\t\tcase CCN_TYPE_RND_3P:\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int arm_ccn_pmu_event_alloc(struct perf_event *event)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(event->pmu);\n\tstruct hw_perf_event *hw = &event->hw;\n\tu32 node_xp, type, event_id;\n\tstruct arm_ccn_component *source;\n\tint bit;\n\n\tnode_xp = CCN_CONFIG_NODE(event->attr.config);\n\ttype = CCN_CONFIG_TYPE(event->attr.config);\n\tevent_id = CCN_CONFIG_EVENT(event->attr.config);\n\n\t \n\tif (type == CCN_TYPE_CYCLES) {\n\t\tif (test_and_set_bit(CCN_IDX_PMU_CYCLE_COUNTER,\n\t\t\t\tccn->dt.pmu_counters_mask))\n\t\t\treturn -EAGAIN;\n\n\t\thw->idx = CCN_IDX_PMU_CYCLE_COUNTER;\n\t\tccn->dt.pmu_counters[CCN_IDX_PMU_CYCLE_COUNTER].event = event;\n\n\t\treturn 0;\n\t}\n\n\t \n\thw->idx = arm_ccn_pmu_alloc_bit(ccn->dt.pmu_counters_mask,\n\t\t\tCCN_NUM_PMU_EVENT_COUNTERS);\n\tif (hw->idx < 0) {\n\t\tdev_dbg(ccn->dev, \"No more counters available!\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (type == CCN_TYPE_XP)\n\t\tsource = &ccn->xp[node_xp];\n\telse\n\t\tsource = &ccn->node[node_xp];\n\tccn->dt.pmu_counters[hw->idx].source = source;\n\n\t \n\tif (type == CCN_TYPE_XP && event_id == CCN_EVENT_WATCHPOINT)\n\t\tbit = arm_ccn_pmu_alloc_bit(source->xp.dt_cmp_mask,\n\t\t\t\tCCN_NUM_XP_WATCHPOINTS);\n\telse\n\t\tbit = arm_ccn_pmu_alloc_bit(source->pmu_events_mask,\n\t\t\t\tCCN_NUM_PMU_EVENTS);\n\tif (bit < 0) {\n\t\tdev_dbg(ccn->dev, \"No more event sources/watchpoints on node/XP %d!\\n\",\n\t\t\t\tnode_xp);\n\t\tclear_bit(hw->idx, ccn->dt.pmu_counters_mask);\n\t\treturn -EAGAIN;\n\t}\n\thw->config_base = bit;\n\n\tccn->dt.pmu_counters[hw->idx].event = event;\n\n\treturn 0;\n}\n\nstatic void arm_ccn_pmu_event_release(struct perf_event *event)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(event->pmu);\n\tstruct hw_perf_event *hw = &event->hw;\n\n\tif (hw->idx == CCN_IDX_PMU_CYCLE_COUNTER) {\n\t\tclear_bit(CCN_IDX_PMU_CYCLE_COUNTER, ccn->dt.pmu_counters_mask);\n\t} else {\n\t\tstruct arm_ccn_component *source =\n\t\t\t\tccn->dt.pmu_counters[hw->idx].source;\n\n\t\tif (CCN_CONFIG_TYPE(event->attr.config) == CCN_TYPE_XP &&\n\t\t\t\tCCN_CONFIG_EVENT(event->attr.config) ==\n\t\t\t\tCCN_EVENT_WATCHPOINT)\n\t\t\tclear_bit(hw->config_base, source->xp.dt_cmp_mask);\n\t\telse\n\t\t\tclear_bit(hw->config_base, source->pmu_events_mask);\n\t\tclear_bit(hw->idx, ccn->dt.pmu_counters_mask);\n\t}\n\n\tccn->dt.pmu_counters[hw->idx].source = NULL;\n\tccn->dt.pmu_counters[hw->idx].event = NULL;\n}\n\nstatic int arm_ccn_pmu_event_init(struct perf_event *event)\n{\n\tstruct arm_ccn *ccn;\n\tstruct hw_perf_event *hw = &event->hw;\n\tu32 node_xp, type, event_id;\n\tint valid;\n\tint i;\n\tstruct perf_event *sibling;\n\n\tif (event->attr.type != event->pmu->type)\n\t\treturn -ENOENT;\n\n\tccn = pmu_to_arm_ccn(event->pmu);\n\n\tif (hw->sample_period) {\n\t\tdev_dbg(ccn->dev, \"Sampling not supported!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (has_branch_stack(event)) {\n\t\tdev_dbg(ccn->dev, \"Can't exclude execution levels!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (event->cpu < 0) {\n\t\tdev_dbg(ccn->dev, \"Can't provide per-task data!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\t \n\tevent->cpu = ccn->dt.cpu;\n\n\tnode_xp = CCN_CONFIG_NODE(event->attr.config);\n\ttype = CCN_CONFIG_TYPE(event->attr.config);\n\tevent_id = CCN_CONFIG_EVENT(event->attr.config);\n\n\t \n\tswitch (type) {\n\tcase CCN_TYPE_MN:\n\t\tif (node_xp != ccn->mn_id) {\n\t\t\tdev_dbg(ccn->dev, \"Invalid MN ID %d!\\n\", node_xp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase CCN_TYPE_XP:\n\t\tif (node_xp >= ccn->num_xps) {\n\t\t\tdev_dbg(ccn->dev, \"Invalid XP ID %d!\\n\", node_xp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase CCN_TYPE_CYCLES:\n\t\tbreak;\n\tdefault:\n\t\tif (node_xp >= ccn->num_nodes) {\n\t\t\tdev_dbg(ccn->dev, \"Invalid node ID %d!\\n\", node_xp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!arm_ccn_pmu_type_eq(type, ccn->node[node_xp].type)) {\n\t\t\tdev_dbg(ccn->dev, \"Invalid type 0x%x for node %d!\\n\",\n\t\t\t\t\ttype, node_xp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0, valid = 0; i < ARRAY_SIZE(arm_ccn_pmu_events) && !valid;\n\t\t\ti++) {\n\t\tstruct arm_ccn_pmu_event *e = &arm_ccn_pmu_events[i];\n\t\tu32 port = CCN_CONFIG_PORT(event->attr.config);\n\t\tu32 vc = CCN_CONFIG_VC(event->attr.config);\n\n\t\tif (!arm_ccn_pmu_type_eq(type, e->type))\n\t\t\tcontinue;\n\t\tif (event_id != e->event)\n\t\t\tcontinue;\n\t\tif (e->num_ports && port >= e->num_ports) {\n\t\t\tdev_dbg(ccn->dev, \"Invalid port %d for node/XP %d!\\n\",\n\t\t\t\t\tport, node_xp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (e->num_vcs && vc >= e->num_vcs) {\n\t\t\tdev_dbg(ccn->dev, \"Invalid vc %d for node/XP %d!\\n\",\n\t\t\t\t\tvc, node_xp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvalid = 1;\n\t}\n\tif (!valid) {\n\t\tdev_dbg(ccn->dev, \"Invalid event 0x%x for node/XP %d!\\n\",\n\t\t\t\tevent_id, node_xp);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (event_id == CCN_EVENT_WATCHPOINT && type != CCN_TYPE_XP) {\n\t\tu32 port;\n\n\t\ttype = CCN_TYPE_XP;\n\t\tport = arm_ccn_node_to_xp_port(node_xp);\n\t\tnode_xp = arm_ccn_node_to_xp(node_xp);\n\n\t\tarm_ccn_pmu_config_set(&event->attr.config,\n\t\t\t\tnode_xp, type, port);\n\t}\n\n\t \n\tif (event->group_leader->pmu != event->pmu &&\n\t\t\t!is_software_event(event->group_leader))\n\t\treturn -EINVAL;\n\n\tfor_each_sibling_event(sibling, event->group_leader) {\n\t\tif (sibling->pmu != event->pmu &&\n\t\t\t\t!is_software_event(sibling))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic u64 arm_ccn_pmu_read_counter(struct arm_ccn *ccn, int idx)\n{\n\tu64 res;\n\n\tif (idx == CCN_IDX_PMU_CYCLE_COUNTER) {\n#ifdef readq\n\t\tres = readq(ccn->dt.base + CCN_DT_PMCCNTR);\n#else\n\t\t \n\t\twritel(0x1, ccn->dt.base + CCN_DT_PMSR_REQ);\n\t\twhile (!(readl(ccn->dt.base + CCN_DT_PMSR) & 0x1))\n\t\t\t;\n\t\twritel(0x1, ccn->dt.base + CCN_DT_PMSR_CLR);\n\t\tres = readl(ccn->dt.base + CCN_DT_PMCCNTRSR + 4) & 0xff;\n\t\tres <<= 32;\n\t\tres |= readl(ccn->dt.base + CCN_DT_PMCCNTRSR);\n#endif\n\t} else {\n\t\tres = readl(ccn->dt.base + CCN_DT_PMEVCNT(idx));\n\t}\n\n\treturn res;\n}\n\nstatic void arm_ccn_pmu_event_update(struct perf_event *event)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(event->pmu);\n\tstruct hw_perf_event *hw = &event->hw;\n\tu64 prev_count, new_count, mask;\n\n\tdo {\n\t\tprev_count = local64_read(&hw->prev_count);\n\t\tnew_count = arm_ccn_pmu_read_counter(ccn, hw->idx);\n\t} while (local64_xchg(&hw->prev_count, new_count) != prev_count);\n\n\tmask = (1LLU << (hw->idx == CCN_IDX_PMU_CYCLE_COUNTER ? 40 : 32)) - 1;\n\n\tlocal64_add((new_count - prev_count) & mask, &event->count);\n}\n\nstatic void arm_ccn_pmu_xp_dt_config(struct perf_event *event, int enable)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(event->pmu);\n\tstruct hw_perf_event *hw = &event->hw;\n\tstruct arm_ccn_component *xp;\n\tu32 val, dt_cfg;\n\n\t \n\tif (hw->idx == CCN_IDX_PMU_CYCLE_COUNTER)\n\t\treturn;\n\n\tif (CCN_CONFIG_TYPE(event->attr.config) == CCN_TYPE_XP)\n\t\txp = &ccn->xp[CCN_CONFIG_XP(event->attr.config)];\n\telse\n\t\txp = &ccn->xp[arm_ccn_node_to_xp(\n\t\t\t\tCCN_CONFIG_NODE(event->attr.config))];\n\n\tif (enable)\n\t\tdt_cfg = hw->event_base;\n\telse\n\t\tdt_cfg = CCN_XP_DT_CONFIG__DT_CFG__PASS_THROUGH;\n\n\tspin_lock(&ccn->dt.config_lock);\n\n\tval = readl(xp->base + CCN_XP_DT_CONFIG);\n\tval &= ~(CCN_XP_DT_CONFIG__DT_CFG__MASK <<\n\t\t\tCCN_XP_DT_CONFIG__DT_CFG__SHIFT(hw->idx));\n\tval |= dt_cfg << CCN_XP_DT_CONFIG__DT_CFG__SHIFT(hw->idx);\n\twritel(val, xp->base + CCN_XP_DT_CONFIG);\n\n\tspin_unlock(&ccn->dt.config_lock);\n}\n\nstatic void arm_ccn_pmu_event_start(struct perf_event *event, int flags)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(event->pmu);\n\tstruct hw_perf_event *hw = &event->hw;\n\n\tlocal64_set(&event->hw.prev_count,\n\t\t\tarm_ccn_pmu_read_counter(ccn, hw->idx));\n\thw->state = 0;\n\n\t \n\tarm_ccn_pmu_xp_dt_config(event, 1);\n}\n\nstatic void arm_ccn_pmu_event_stop(struct perf_event *event, int flags)\n{\n\tstruct hw_perf_event *hw = &event->hw;\n\n\t \n\tarm_ccn_pmu_xp_dt_config(event, 0);\n\n\tif (flags & PERF_EF_UPDATE)\n\t\tarm_ccn_pmu_event_update(event);\n\n\thw->state |= PERF_HES_STOPPED;\n}\n\nstatic void arm_ccn_pmu_xp_watchpoint_config(struct perf_event *event)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(event->pmu);\n\tstruct hw_perf_event *hw = &event->hw;\n\tstruct arm_ccn_component *source =\n\t\t\tccn->dt.pmu_counters[hw->idx].source;\n\tunsigned long wp = hw->config_base;\n\tu32 val;\n\tu64 cmp_l = event->attr.config1;\n\tu64 cmp_h = event->attr.config2;\n\tu64 mask_l = ccn->dt.cmp_mask[CCN_CONFIG_MASK(event->attr.config)].l;\n\tu64 mask_h = ccn->dt.cmp_mask[CCN_CONFIG_MASK(event->attr.config)].h;\n\n\thw->event_base = CCN_XP_DT_CONFIG__DT_CFG__WATCHPOINT(wp);\n\n\t \n\tval = readl(source->base + CCN_XP_DT_INTERFACE_SEL);\n\tval &= ~(CCN_XP_DT_INTERFACE_SEL__DT_IO_SEL__MASK <<\n\t\t\tCCN_XP_DT_INTERFACE_SEL__DT_IO_SEL__SHIFT(wp));\n\tval |= CCN_CONFIG_DIR(event->attr.config) <<\n\t\t\tCCN_XP_DT_INTERFACE_SEL__DT_IO_SEL__SHIFT(wp);\n\tval &= ~(CCN_XP_DT_INTERFACE_SEL__DT_DEV_SEL__MASK <<\n\t\t\tCCN_XP_DT_INTERFACE_SEL__DT_DEV_SEL__SHIFT(wp));\n\tval |= CCN_CONFIG_PORT(event->attr.config) <<\n\t\t\tCCN_XP_DT_INTERFACE_SEL__DT_DEV_SEL__SHIFT(wp);\n\tval &= ~(CCN_XP_DT_INTERFACE_SEL__DT_VC_SEL__MASK <<\n\t\t\tCCN_XP_DT_INTERFACE_SEL__DT_VC_SEL__SHIFT(wp));\n\tval |= CCN_CONFIG_VC(event->attr.config) <<\n\t\t\tCCN_XP_DT_INTERFACE_SEL__DT_VC_SEL__SHIFT(wp);\n\twritel(val, source->base + CCN_XP_DT_INTERFACE_SEL);\n\n\t \n\twritel(cmp_l & 0xffffffff, source->base + CCN_XP_DT_CMP_VAL_L(wp));\n\twritel((cmp_l >> 32) & 0x7fffffff,\n\t\t\tsource->base + CCN_XP_DT_CMP_VAL_L(wp) + 4);\n\twritel(cmp_h & 0xffffffff, source->base + CCN_XP_DT_CMP_VAL_H(wp));\n\twritel((cmp_h >> 32) & 0x0fffffff,\n\t\t\tsource->base + CCN_XP_DT_CMP_VAL_H(wp) + 4);\n\n\t \n\twritel(mask_l & 0xffffffff, source->base + CCN_XP_DT_CMP_MASK_L(wp));\n\twritel((mask_l >> 32) & 0x7fffffff,\n\t\t\tsource->base + CCN_XP_DT_CMP_MASK_L(wp) + 4);\n\twritel(mask_h & 0xffffffff, source->base + CCN_XP_DT_CMP_MASK_H(wp));\n\twritel((mask_h >> 32) & 0x0fffffff,\n\t\t\tsource->base + CCN_XP_DT_CMP_MASK_H(wp) + 4);\n}\n\nstatic void arm_ccn_pmu_xp_event_config(struct perf_event *event)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(event->pmu);\n\tstruct hw_perf_event *hw = &event->hw;\n\tstruct arm_ccn_component *source =\n\t\t\tccn->dt.pmu_counters[hw->idx].source;\n\tu32 val, id;\n\n\thw->event_base = CCN_XP_DT_CONFIG__DT_CFG__XP_PMU_EVENT(hw->config_base);\n\n\tid = (CCN_CONFIG_VC(event->attr.config) << 4) |\n\t\t\t(CCN_CONFIG_BUS(event->attr.config) << 3) |\n\t\t\t(CCN_CONFIG_EVENT(event->attr.config) << 0);\n\n\tval = readl(source->base + CCN_XP_PMU_EVENT_SEL);\n\tval &= ~(CCN_XP_PMU_EVENT_SEL__ID__MASK <<\n\t\t\tCCN_XP_PMU_EVENT_SEL__ID__SHIFT(hw->config_base));\n\tval |= id << CCN_XP_PMU_EVENT_SEL__ID__SHIFT(hw->config_base);\n\twritel(val, source->base + CCN_XP_PMU_EVENT_SEL);\n}\n\nstatic void arm_ccn_pmu_node_event_config(struct perf_event *event)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(event->pmu);\n\tstruct hw_perf_event *hw = &event->hw;\n\tstruct arm_ccn_component *source =\n\t\t\tccn->dt.pmu_counters[hw->idx].source;\n\tu32 type = CCN_CONFIG_TYPE(event->attr.config);\n\tu32 val, port;\n\n\tport = arm_ccn_node_to_xp_port(CCN_CONFIG_NODE(event->attr.config));\n\thw->event_base = CCN_XP_DT_CONFIG__DT_CFG__DEVICE_PMU_EVENT(port,\n\t\t\thw->config_base);\n\n\t \n\tBUILD_BUG_ON(CCN_HNF_PMU_EVENT_SEL != CCN_SBAS_PMU_EVENT_SEL);\n\tBUILD_BUG_ON(CCN_SBAS_PMU_EVENT_SEL != CCN_RNI_PMU_EVENT_SEL);\n\tBUILD_BUG_ON(CCN_HNF_PMU_EVENT_SEL__ID__SHIFT(1) !=\n\t\t\tCCN_SBAS_PMU_EVENT_SEL__ID__SHIFT(1));\n\tBUILD_BUG_ON(CCN_SBAS_PMU_EVENT_SEL__ID__SHIFT(1) !=\n\t\t\tCCN_RNI_PMU_EVENT_SEL__ID__SHIFT(1));\n\tBUILD_BUG_ON(CCN_HNF_PMU_EVENT_SEL__ID__MASK !=\n\t\t\tCCN_SBAS_PMU_EVENT_SEL__ID__MASK);\n\tBUILD_BUG_ON(CCN_SBAS_PMU_EVENT_SEL__ID__MASK !=\n\t\t\tCCN_RNI_PMU_EVENT_SEL__ID__MASK);\n\tif (WARN_ON(type != CCN_TYPE_HNF && type != CCN_TYPE_SBAS &&\n\t\t\t!arm_ccn_pmu_type_eq(type, CCN_TYPE_RNI_3P)))\n\t\treturn;\n\n\t \n\tval = readl(source->base + CCN_HNF_PMU_EVENT_SEL);\n\tval &= ~(CCN_HNF_PMU_EVENT_SEL__ID__MASK <<\n\t\tCCN_HNF_PMU_EVENT_SEL__ID__SHIFT(hw->config_base));\n\tval |= CCN_CONFIG_EVENT(event->attr.config) <<\n\t\tCCN_HNF_PMU_EVENT_SEL__ID__SHIFT(hw->config_base);\n\twritel(val, source->base + CCN_HNF_PMU_EVENT_SEL);\n}\n\nstatic void arm_ccn_pmu_event_config(struct perf_event *event)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(event->pmu);\n\tstruct hw_perf_event *hw = &event->hw;\n\tu32 xp, offset, val;\n\n\t \n\tif (hw->idx == CCN_IDX_PMU_CYCLE_COUNTER)\n\t\treturn;\n\n\tif (CCN_CONFIG_TYPE(event->attr.config) == CCN_TYPE_XP)\n\t\txp = CCN_CONFIG_XP(event->attr.config);\n\telse\n\t\txp = arm_ccn_node_to_xp(CCN_CONFIG_NODE(event->attr.config));\n\n\tspin_lock(&ccn->dt.config_lock);\n\n\t \n\toffset = (hw->idx / 4) * 4;\n\tval = readl(ccn->dt.base + CCN_DT_ACTIVE_DSM + offset);\n\tval &= ~(CCN_DT_ACTIVE_DSM__DSM_ID__MASK <<\n\t\t\tCCN_DT_ACTIVE_DSM__DSM_ID__SHIFT(hw->idx % 4));\n\tval |= xp << CCN_DT_ACTIVE_DSM__DSM_ID__SHIFT(hw->idx % 4);\n\twritel(val, ccn->dt.base + CCN_DT_ACTIVE_DSM + offset);\n\n\tif (CCN_CONFIG_TYPE(event->attr.config) == CCN_TYPE_XP) {\n\t\tif (CCN_CONFIG_EVENT(event->attr.config) ==\n\t\t\t\tCCN_EVENT_WATCHPOINT)\n\t\t\tarm_ccn_pmu_xp_watchpoint_config(event);\n\t\telse\n\t\t\tarm_ccn_pmu_xp_event_config(event);\n\t} else {\n\t\tarm_ccn_pmu_node_event_config(event);\n\t}\n\n\tspin_unlock(&ccn->dt.config_lock);\n}\n\nstatic int arm_ccn_pmu_active_counters(struct arm_ccn *ccn)\n{\n\treturn bitmap_weight(ccn->dt.pmu_counters_mask,\n\t\t\t     CCN_NUM_PMU_EVENT_COUNTERS + 1);\n}\n\nstatic int arm_ccn_pmu_event_add(struct perf_event *event, int flags)\n{\n\tint err;\n\tstruct hw_perf_event *hw = &event->hw;\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(event->pmu);\n\n\terr = arm_ccn_pmu_event_alloc(event);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!ccn->irq && arm_ccn_pmu_active_counters(ccn) == 1)\n\t\thrtimer_start(&ccn->dt.hrtimer, arm_ccn_pmu_timer_period(),\n\t\t\t      HRTIMER_MODE_REL_PINNED);\n\n\tarm_ccn_pmu_event_config(event);\n\n\thw->state = PERF_HES_STOPPED;\n\n\tif (flags & PERF_EF_START)\n\t\tarm_ccn_pmu_event_start(event, PERF_EF_UPDATE);\n\n\treturn 0;\n}\n\nstatic void arm_ccn_pmu_event_del(struct perf_event *event, int flags)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(event->pmu);\n\n\tarm_ccn_pmu_event_stop(event, PERF_EF_UPDATE);\n\n\tarm_ccn_pmu_event_release(event);\n\n\tif (!ccn->irq && arm_ccn_pmu_active_counters(ccn) == 0)\n\t\thrtimer_cancel(&ccn->dt.hrtimer);\n}\n\nstatic void arm_ccn_pmu_event_read(struct perf_event *event)\n{\n\tarm_ccn_pmu_event_update(event);\n}\n\nstatic void arm_ccn_pmu_enable(struct pmu *pmu)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(pmu);\n\n\tu32 val = readl(ccn->dt.base + CCN_DT_PMCR);\n\tval |= CCN_DT_PMCR__PMU_EN;\n\twritel(val, ccn->dt.base + CCN_DT_PMCR);\n}\n\nstatic void arm_ccn_pmu_disable(struct pmu *pmu)\n{\n\tstruct arm_ccn *ccn = pmu_to_arm_ccn(pmu);\n\n\tu32 val = readl(ccn->dt.base + CCN_DT_PMCR);\n\tval &= ~CCN_DT_PMCR__PMU_EN;\n\twritel(val, ccn->dt.base + CCN_DT_PMCR);\n}\n\nstatic irqreturn_t arm_ccn_pmu_overflow_handler(struct arm_ccn_dt *dt)\n{\n\tu32 pmovsr = readl(dt->base + CCN_DT_PMOVSR);\n\tint idx;\n\n\tif (!pmovsr)\n\t\treturn IRQ_NONE;\n\n\twritel(pmovsr, dt->base + CCN_DT_PMOVSR_CLR);\n\n\tBUILD_BUG_ON(CCN_IDX_PMU_CYCLE_COUNTER != CCN_NUM_PMU_EVENT_COUNTERS);\n\n\tfor (idx = 0; idx < CCN_NUM_PMU_EVENT_COUNTERS + 1; idx++) {\n\t\tstruct perf_event *event = dt->pmu_counters[idx].event;\n\t\tint overflowed = pmovsr & BIT(idx);\n\n\t\tWARN_ON_ONCE(overflowed && !event &&\n\t\t\t\tidx != CCN_IDX_PMU_CYCLE_COUNTER);\n\n\t\tif (!event || !overflowed)\n\t\t\tcontinue;\n\n\t\tarm_ccn_pmu_event_update(event);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic enum hrtimer_restart arm_ccn_pmu_timer_handler(struct hrtimer *hrtimer)\n{\n\tstruct arm_ccn_dt *dt = container_of(hrtimer, struct arm_ccn_dt,\n\t\t\thrtimer);\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tarm_ccn_pmu_overflow_handler(dt);\n\tlocal_irq_restore(flags);\n\n\thrtimer_forward_now(hrtimer, arm_ccn_pmu_timer_period());\n\treturn HRTIMER_RESTART;\n}\n\n\nstatic int arm_ccn_pmu_offline_cpu(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct arm_ccn_dt *dt = hlist_entry_safe(node, struct arm_ccn_dt, node);\n\tstruct arm_ccn *ccn = container_of(dt, struct arm_ccn, dt);\n\tunsigned int target;\n\n\tif (cpu != dt->cpu)\n\t\treturn 0;\n\ttarget = cpumask_any_but(cpu_online_mask, cpu);\n\tif (target >= nr_cpu_ids)\n\t\treturn 0;\n\tperf_pmu_migrate_context(&dt->pmu, cpu, target);\n\tdt->cpu = target;\n\tif (ccn->irq)\n\t\tWARN_ON(irq_set_affinity(ccn->irq, cpumask_of(dt->cpu)));\n\treturn 0;\n}\n\nstatic DEFINE_IDA(arm_ccn_pmu_ida);\n\nstatic int arm_ccn_pmu_init(struct arm_ccn *ccn)\n{\n\tint i;\n\tchar *name;\n\tint err;\n\n\t \n\tccn->dt.base = ccn->base + CCN_REGION_SIZE;\n\tspin_lock_init(&ccn->dt.config_lock);\n\twritel(CCN_DT_PMOVSR_CLR__MASK, ccn->dt.base + CCN_DT_PMOVSR_CLR);\n\twritel(CCN_DT_CTL__DT_EN, ccn->dt.base + CCN_DT_CTL);\n\twritel(CCN_DT_PMCR__OVFL_INTR_EN | CCN_DT_PMCR__PMU_EN,\n\t\t\tccn->dt.base + CCN_DT_PMCR);\n\twritel(0x1, ccn->dt.base + CCN_DT_PMSR_CLR);\n\tfor (i = 0; i < ccn->num_xps; i++) {\n\t\twritel(0, ccn->xp[i].base + CCN_XP_DT_CONFIG);\n\t\twritel((CCN_XP_DT_CONTROL__WP_ARM_SEL__ALWAYS <<\n\t\t\t\tCCN_XP_DT_CONTROL__WP_ARM_SEL__SHIFT(0)) |\n\t\t\t\t(CCN_XP_DT_CONTROL__WP_ARM_SEL__ALWAYS <<\n\t\t\t\tCCN_XP_DT_CONTROL__WP_ARM_SEL__SHIFT(1)) |\n\t\t\t\tCCN_XP_DT_CONTROL__DT_ENABLE,\n\t\t\t\tccn->xp[i].base + CCN_XP_DT_CONTROL);\n\t}\n\tccn->dt.cmp_mask[CCN_IDX_MASK_ANY].l = ~0;\n\tccn->dt.cmp_mask[CCN_IDX_MASK_ANY].h = ~0;\n\tccn->dt.cmp_mask[CCN_IDX_MASK_EXACT].l = 0;\n\tccn->dt.cmp_mask[CCN_IDX_MASK_EXACT].h = 0;\n\tccn->dt.cmp_mask[CCN_IDX_MASK_ORDER].l = ~0;\n\tccn->dt.cmp_mask[CCN_IDX_MASK_ORDER].h = ~(0x1 << 15);\n\tccn->dt.cmp_mask[CCN_IDX_MASK_OPCODE].l = ~0;\n\tccn->dt.cmp_mask[CCN_IDX_MASK_OPCODE].h = ~(0x1f << 9);\n\n\t \n\tccn->dt.id = ida_alloc(&arm_ccn_pmu_ida, GFP_KERNEL);\n\tif (ccn->dt.id == 0) {\n\t\tname = \"ccn\";\n\t} else {\n\t\tname = devm_kasprintf(ccn->dev, GFP_KERNEL, \"ccn_%d\",\n\t\t\t\t      ccn->dt.id);\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_choose_name;\n\t\t}\n\t}\n\n\t \n\tccn->dt.pmu = (struct pmu) {\n\t\t.module = THIS_MODULE,\n\t\t.attr_groups = arm_ccn_pmu_attr_groups,\n\t\t.task_ctx_nr = perf_invalid_context,\n\t\t.event_init = arm_ccn_pmu_event_init,\n\t\t.add = arm_ccn_pmu_event_add,\n\t\t.del = arm_ccn_pmu_event_del,\n\t\t.start = arm_ccn_pmu_event_start,\n\t\t.stop = arm_ccn_pmu_event_stop,\n\t\t.read = arm_ccn_pmu_event_read,\n\t\t.pmu_enable = arm_ccn_pmu_enable,\n\t\t.pmu_disable = arm_ccn_pmu_disable,\n\t\t.capabilities = PERF_PMU_CAP_NO_EXCLUDE,\n\t};\n\n\t \n\tif (!ccn->irq) {\n\t\tdev_info(ccn->dev, \"No access to interrupts, using timer.\\n\");\n\t\thrtimer_init(&ccn->dt.hrtimer, CLOCK_MONOTONIC,\n\t\t\t\tHRTIMER_MODE_REL);\n\t\tccn->dt.hrtimer.function = arm_ccn_pmu_timer_handler;\n\t}\n\n\t \n\tccn->dt.cpu = raw_smp_processor_id();\n\n\t \n\tif (ccn->irq) {\n\t\terr = irq_set_affinity(ccn->irq, cpumask_of(ccn->dt.cpu));\n\t\tif (err) {\n\t\t\tdev_err(ccn->dev, \"Failed to set interrupt affinity!\\n\");\n\t\t\tgoto error_set_affinity;\n\t\t}\n\t}\n\n\tcpuhp_state_add_instance_nocalls(CPUHP_AP_PERF_ARM_CCN_ONLINE,\n\t\t\t\t\t &ccn->dt.node);\n\n\terr = perf_pmu_register(&ccn->dt.pmu, name, -1);\n\tif (err)\n\t\tgoto error_pmu_register;\n\n\treturn 0;\n\nerror_pmu_register:\n\tcpuhp_state_remove_instance_nocalls(CPUHP_AP_PERF_ARM_CCN_ONLINE,\n\t\t\t\t\t    &ccn->dt.node);\nerror_set_affinity:\nerror_choose_name:\n\tida_free(&arm_ccn_pmu_ida, ccn->dt.id);\n\tfor (i = 0; i < ccn->num_xps; i++)\n\t\twritel(0, ccn->xp[i].base + CCN_XP_DT_CONTROL);\n\twritel(0, ccn->dt.base + CCN_DT_PMCR);\n\treturn err;\n}\n\nstatic void arm_ccn_pmu_cleanup(struct arm_ccn *ccn)\n{\n\tint i;\n\n\tcpuhp_state_remove_instance_nocalls(CPUHP_AP_PERF_ARM_CCN_ONLINE,\n\t\t\t\t\t    &ccn->dt.node);\n\tfor (i = 0; i < ccn->num_xps; i++)\n\t\twritel(0, ccn->xp[i].base + CCN_XP_DT_CONTROL);\n\twritel(0, ccn->dt.base + CCN_DT_PMCR);\n\tperf_pmu_unregister(&ccn->dt.pmu);\n\tida_free(&arm_ccn_pmu_ida, ccn->dt.id);\n}\n\nstatic int arm_ccn_for_each_valid_region(struct arm_ccn *ccn,\n\t\tint (*callback)(struct arm_ccn *ccn, int region,\n\t\tvoid __iomem *base, u32 type, u32 id))\n{\n\tint region;\n\n\tfor (region = 0; region < CCN_NUM_REGIONS; region++) {\n\t\tu32 val, type, id;\n\t\tvoid __iomem *base;\n\t\tint err;\n\n\t\tval = readl(ccn->base + CCN_MN_OLY_COMP_LIST_63_0 +\n\t\t\t\t4 * (region / 32));\n\t\tif (!(val & (1 << (region % 32))))\n\t\t\tcontinue;\n\n\t\tbase = ccn->base + region * CCN_REGION_SIZE;\n\t\tval = readl(base + CCN_ALL_OLY_ID);\n\t\ttype = (val >> CCN_ALL_OLY_ID__OLY_ID__SHIFT) &\n\t\t\t\tCCN_ALL_OLY_ID__OLY_ID__MASK;\n\t\tid = (val >> CCN_ALL_OLY_ID__NODE_ID__SHIFT) &\n\t\t\t\tCCN_ALL_OLY_ID__NODE_ID__MASK;\n\n\t\terr = callback(ccn, region, base, type, id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int arm_ccn_get_nodes_num(struct arm_ccn *ccn, int region,\n\t\tvoid __iomem *base, u32 type, u32 id)\n{\n\n\tif (type == CCN_TYPE_XP && id >= ccn->num_xps)\n\t\tccn->num_xps = id + 1;\n\telse if (id >= ccn->num_nodes)\n\t\tccn->num_nodes = id + 1;\n\n\treturn 0;\n}\n\nstatic int arm_ccn_init_nodes(struct arm_ccn *ccn, int region,\n\t\tvoid __iomem *base, u32 type, u32 id)\n{\n\tstruct arm_ccn_component *component;\n\n\tdev_dbg(ccn->dev, \"Region %d: id=%u, type=0x%02x\\n\", region, id, type);\n\n\tswitch (type) {\n\tcase CCN_TYPE_MN:\n\t\tccn->mn_id = id;\n\t\treturn 0;\n\tcase CCN_TYPE_DT:\n\t\treturn 0;\n\tcase CCN_TYPE_XP:\n\t\tcomponent = &ccn->xp[id];\n\t\tbreak;\n\tcase CCN_TYPE_SBSX:\n\t\tccn->sbsx_present = 1;\n\t\tcomponent = &ccn->node[id];\n\t\tbreak;\n\tcase CCN_TYPE_SBAS:\n\t\tccn->sbas_present = 1;\n\t\tfallthrough;\n\tdefault:\n\t\tcomponent = &ccn->node[id];\n\t\tbreak;\n\t}\n\n\tcomponent->base = base;\n\tcomponent->type = type;\n\n\treturn 0;\n}\n\n\nstatic irqreturn_t arm_ccn_error_handler(struct arm_ccn *ccn,\n\t\tconst u32 *err_sig_val)\n{\n\t \n\tdev_err(ccn->dev, \"Error reported in %08x%08x%08x%08x%08x%08x.\\n\",\n\t\t\terr_sig_val[5], err_sig_val[4], err_sig_val[3],\n\t\t\terr_sig_val[2], err_sig_val[1], err_sig_val[0]);\n\tdev_err(ccn->dev, \"Disabling interrupt generation for all errors.\\n\");\n\twritel(CCN_MN_ERRINT_STATUS__ALL_ERRORS__DISABLE,\n\t\t\tccn->base + CCN_MN_ERRINT_STATUS);\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic irqreturn_t arm_ccn_irq_handler(int irq, void *dev_id)\n{\n\tirqreturn_t res = IRQ_NONE;\n\tstruct arm_ccn *ccn = dev_id;\n\tu32 err_sig_val[6];\n\tu32 err_or;\n\tint i;\n\n\t \n\terr_or = err_sig_val[0] = readl(ccn->base + CCN_MN_ERR_SIG_VAL_63_0);\n\tif (err_or & CCN_MN_ERR_SIG_VAL_63_0__DT) {\n\t\terr_or &= ~CCN_MN_ERR_SIG_VAL_63_0__DT;\n\t\tres = arm_ccn_pmu_overflow_handler(&ccn->dt);\n\t}\n\n\t \n\tfor (i = 1; i < ARRAY_SIZE(err_sig_val); i++) {\n\t\terr_sig_val[i] = readl(ccn->base +\n\t\t\t\tCCN_MN_ERR_SIG_VAL_63_0 + i * 4);\n\t\terr_or |= err_sig_val[i];\n\t}\n\tif (err_or)\n\t\tres |= arm_ccn_error_handler(ccn, err_sig_val);\n\n\tif (res != IRQ_NONE)\n\t\twritel(CCN_MN_ERRINT_STATUS__INTREQ__DESSERT,\n\t\t\t\tccn->base + CCN_MN_ERRINT_STATUS);\n\n\treturn res;\n}\n\n\nstatic int arm_ccn_probe(struct platform_device *pdev)\n{\n\tstruct arm_ccn *ccn;\n\tint irq;\n\tint err;\n\n\tccn = devm_kzalloc(&pdev->dev, sizeof(*ccn), GFP_KERNEL);\n\tif (!ccn)\n\t\treturn -ENOMEM;\n\tccn->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ccn);\n\n\tccn->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ccn->base))\n\t\treturn PTR_ERR(ccn->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\twritel(CCN_MN_ERRINT_STATUS__PMU_EVENTS__DISABLE,\n\t\t\tccn->base + CCN_MN_ERRINT_STATUS);\n\tif (readl(ccn->base + CCN_MN_ERRINT_STATUS) &\n\t\t\tCCN_MN_ERRINT_STATUS__PMU_EVENTS__DISABLED) {\n\t\t \n\t\twritel(CCN_MN_ERRINT_STATUS__PMU_EVENTS__ENABLE,\n\t\t\t\tccn->base + CCN_MN_ERRINT_STATUS);\n\t\terr = devm_request_irq(ccn->dev, irq, arm_ccn_irq_handler,\n\t\t\t\t       IRQF_NOBALANCING | IRQF_NO_THREAD,\n\t\t\t\t       dev_name(ccn->dev), ccn);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tccn->irq = irq;\n\t}\n\n\n\t \n\n\terr = arm_ccn_for_each_valid_region(ccn, arm_ccn_get_nodes_num);\n\tif (err)\n\t\treturn err;\n\n\tccn->node = devm_kcalloc(ccn->dev, ccn->num_nodes, sizeof(*ccn->node),\n\t\t\t\t GFP_KERNEL);\n\tccn->xp = devm_kcalloc(ccn->dev, ccn->num_xps, sizeof(*ccn->node),\n\t\t\t       GFP_KERNEL);\n\tif (!ccn->node || !ccn->xp)\n\t\treturn -ENOMEM;\n\n\terr = arm_ccn_for_each_valid_region(ccn, arm_ccn_init_nodes);\n\tif (err)\n\t\treturn err;\n\n\treturn arm_ccn_pmu_init(ccn);\n}\n\nstatic int arm_ccn_remove(struct platform_device *pdev)\n{\n\tstruct arm_ccn *ccn = platform_get_drvdata(pdev);\n\n\tarm_ccn_pmu_cleanup(ccn);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id arm_ccn_match[] = {\n\t{ .compatible = \"arm,ccn-502\", },\n\t{ .compatible = \"arm,ccn-504\", },\n\t{ .compatible = \"arm,ccn-512\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, arm_ccn_match);\n\nstatic struct platform_driver arm_ccn_driver = {\n\t.driver = {\n\t\t.name = \"arm-ccn\",\n\t\t.of_match_table = arm_ccn_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = arm_ccn_probe,\n\t.remove = arm_ccn_remove,\n};\n\nstatic int __init arm_ccn_init(void)\n{\n\tint i, ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_PERF_ARM_CCN_ONLINE,\n\t\t\t\t      \"perf/arm/ccn:online\", NULL,\n\t\t\t\t      arm_ccn_pmu_offline_cpu);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(arm_ccn_pmu_events); i++)\n\t\tarm_ccn_pmu_events_attrs[i] = &arm_ccn_pmu_events[i].attr.attr;\n\n\tret = platform_driver_register(&arm_ccn_driver);\n\tif (ret)\n\t\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_CCN_ONLINE);\n\treturn ret;\n}\n\nstatic void __exit arm_ccn_exit(void)\n{\n\tplatform_driver_unregister(&arm_ccn_driver);\n\tcpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_CCN_ONLINE);\n}\n\nmodule_init(arm_ccn_init);\nmodule_exit(arm_ccn_exit);\n\nMODULE_AUTHOR(\"Pawel Moll <pawel.moll@arm.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}