{
  "module_name": "fsl_imx9_ddr_perf.c",
  "hash_id": "a68f87eeecd719a69c4e71ac9924dc485304814be7aa41514cdfbd84b0a81d28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/fsl_imx9_ddr_perf.c",
  "human_readable_source": "\n\n\n#include <linux/bitfield.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/perf_event.h>\n\n \n#define PMCFG1  \t\t\t0x00\n#define PMCFG1_RD_TRANS_FILT_EN \tBIT(31)\n#define PMCFG1_WR_TRANS_FILT_EN \tBIT(30)\n#define PMCFG1_RD_BT_FILT_EN \t\tBIT(29)\n#define PMCFG1_ID_MASK  \t\tGENMASK(17, 0)\n\n#define PMCFG2  \t\t\t0x04\n#define PMCFG2_ID\t\t\tGENMASK(17, 0)\n\n \n#define PMGC0\t\t0x40\n \n#define PMGC0_FAC\tBIT(31)\n#define PMGC0_PMIE\tBIT(30)\n#define PMGC0_FCECE\tBIT(29)\n\n \n#define PMLCA(n)\t(0x40 + 0x10 + (0x10 * n))\n#define PMLCB(n)\t(0x40 + 0x14 + (0x10 * n))\n#define PMC(n)\t\t(0x40 + 0x18 + (0x10 * n))\n \n#define PMLCA_FC\tBIT(31)\n#define PMLCA_CE\tBIT(26)\n#define PMLCA_EVENT\tGENMASK(22, 16)\n\n#define NUM_COUNTERS\t\t11\n#define CYCLES_COUNTER\t\t0\n\n#define to_ddr_pmu(p)\t\tcontainer_of(p, struct ddr_pmu, pmu)\n\n#define DDR_PERF_DEV_NAME\t\"imx9_ddr\"\n#define DDR_CPUHP_CB_NAME\tDDR_PERF_DEV_NAME \"_perf_pmu\"\n\nstatic DEFINE_IDA(ddr_ida);\n\nstruct imx_ddr_devtype_data {\n\tconst char *identifier;\t\t \n};\n\nstruct ddr_pmu {\n\tstruct pmu pmu;\n\tvoid __iomem *base;\n\tunsigned int cpu;\n\tstruct hlist_node node;\n\tstruct device *dev;\n\tstruct perf_event *events[NUM_COUNTERS];\n\tint active_events;\n\tenum cpuhp_state cpuhp_state;\n\tconst struct imx_ddr_devtype_data *devtype_data;\n\tint irq;\n\tint id;\n};\n\nstatic const struct imx_ddr_devtype_data imx93_devtype_data = {\n\t.identifier = \"imx93\",\n};\n\nstatic const struct of_device_id imx_ddr_pmu_dt_ids[] = {\n\t{.compatible = \"fsl,imx93-ddr-pmu\", .data = &imx93_devtype_data},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_ddr_pmu_dt_ids);\n\nstatic ssize_t ddr_perf_identifier_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *page)\n{\n\tstruct ddr_pmu *pmu = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(page, \"%s\\n\", pmu->devtype_data->identifier);\n}\n\nstatic struct device_attribute ddr_perf_identifier_attr =\n\t__ATTR(identifier, 0444, ddr_perf_identifier_show, NULL);\n\nstatic struct attribute *ddr_perf_identifier_attrs[] = {\n\t&ddr_perf_identifier_attr.attr,\n\tNULL,\n};\n\nstatic struct attribute_group ddr_perf_identifier_attr_group = {\n\t.attrs = ddr_perf_identifier_attrs,\n};\n\nstatic ssize_t ddr_perf_cpumask_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ddr_pmu *pmu = dev_get_drvdata(dev);\n\n\treturn cpumap_print_to_pagebuf(true, buf, cpumask_of(pmu->cpu));\n}\n\nstatic struct device_attribute ddr_perf_cpumask_attr =\n\t__ATTR(cpumask, 0444, ddr_perf_cpumask_show, NULL);\n\nstatic struct attribute *ddr_perf_cpumask_attrs[] = {\n\t&ddr_perf_cpumask_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ddr_perf_cpumask_attr_group = {\n\t.attrs = ddr_perf_cpumask_attrs,\n};\n\nstatic ssize_t ddr_pmu_event_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *page)\n{\n\tstruct perf_pmu_events_attr *pmu_attr;\n\n\tpmu_attr = container_of(attr, struct perf_pmu_events_attr, attr);\n\treturn sysfs_emit(page, \"event=0x%02llx\\n\", pmu_attr->id);\n}\n\n#define IMX9_DDR_PMU_EVENT_ATTR(_name, _id)\t\t\t\t\\\n\t(&((struct perf_pmu_events_attr[]) {\t\t\t\t\\\n\t\t{ .attr = __ATTR(_name, 0444, ddr_pmu_event_show, NULL),\\\n\t\t  .id = _id, }\t\t\t\t\t\t\\\n\t})[0].attr.attr)\n\nstatic struct attribute *ddr_perf_events_attrs[] = {\n\t \n\tIMX9_DDR_PMU_EVENT_ATTR(cycles, 0),\n\n\t \n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ddrc1_rmw_for_ecc, 12),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_rreorder, 13),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_wreorder, 14),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_0, 15),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_1, 16),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_2, 17),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_3, 18),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_4, 19),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_5, 22),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_6, 23),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_7, 24),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_8, 25),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_9, 26),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_10, 27),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_11, 28),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_12, 31),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_13, 59),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_15, 61),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_pm_29, 63),\n\n\t \n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_riq_0, 64),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_riq_1, 65),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_riq_2, 66),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_riq_3, 67),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_riq_4, 68),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_riq_5, 69),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_riq_6, 70),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_riq_7, 71),\n\n\t \n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_wiq_0, 64),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_wiq_1, 65),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_wiq_2, 66),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_wiq_3, 67),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_wiq_4, 68),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_wiq_5, 69),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_wiq_6, 70),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_ld_wiq_7, 71),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_empty, 72),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pm_rd_trans_filt, 73),\n\n\t \n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_collision_0, 64),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_collision_1, 65),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_collision_2, 66),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_collision_3, 67),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_collision_4, 68),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_collision_5, 69),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_collision_6, 70),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_collision_7, 71),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_full, 72),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pm_wr_trans_filt, 73),\n\n\t \n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_open_0, 64),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_open_1, 65),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_open_2, 66),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_open_3, 67),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_open_4, 68),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_open_5, 69),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_open_6, 70),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_row_open_7, 71),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_ld_rdq2_rmw, 72),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pm_rd_beat_filt, 73),\n\n\t \n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_valid_start_0, 64),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_valid_start_1, 65),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_valid_start_2, 66),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_valid_start_3, 67),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_valid_start_4, 68),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_valid_start_5, 69),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_valid_start_6, 70),\n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_valid_start_7, 71),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_ld_rdq1, 72),\n\n\t \n\tIMX9_DDR_PMU_EVENT_ATTR(ddrc_qx_valid_end_0, 64),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_ld_rdq2, 72),\n\n\t \n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_1_2_full, 64),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_ld_wrq0, 65),\n\n\t \n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_bias_switched, 64),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_1_4_full, 65),\n\n\t \n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_ld_wrq1, 65),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_3_4_full, 66),\n\n\t \n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_misc_mrk, 65),\n\tIMX9_DDR_PMU_EVENT_ATTR(eddrtq_pmon_ld_rdq0, 66),\n\tNULL,\n};\n\nstatic const struct attribute_group ddr_perf_events_attr_group = {\n\t.name = \"events\",\n\t.attrs = ddr_perf_events_attrs,\n};\n\nPMU_FORMAT_ATTR(event, \"config:0-7\");\nPMU_FORMAT_ATTR(counter, \"config:8-15\");\nPMU_FORMAT_ATTR(axi_id, \"config1:0-17\");\nPMU_FORMAT_ATTR(axi_mask, \"config2:0-17\");\n\nstatic struct attribute *ddr_perf_format_attrs[] = {\n\t&format_attr_event.attr,\n\t&format_attr_counter.attr,\n\t&format_attr_axi_id.attr,\n\t&format_attr_axi_mask.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ddr_perf_format_attr_group = {\n\t.name = \"format\",\n\t.attrs = ddr_perf_format_attrs,\n};\n\nstatic const struct attribute_group *attr_groups[] = {\n\t&ddr_perf_identifier_attr_group,\n\t&ddr_perf_cpumask_attr_group,\n\t&ddr_perf_events_attr_group,\n\t&ddr_perf_format_attr_group,\n\tNULL,\n};\n\nstatic void ddr_perf_clear_counter(struct ddr_pmu *pmu, int counter)\n{\n\tif (counter == CYCLES_COUNTER) {\n\t\twritel(0, pmu->base + PMC(counter) + 0x4);\n\t\twritel(0, pmu->base + PMC(counter));\n\t} else {\n\t\twritel(0, pmu->base + PMC(counter));\n\t}\n}\n\nstatic u64 ddr_perf_read_counter(struct ddr_pmu *pmu, int counter)\n{\n\tu32 val_lower, val_upper;\n\tu64 val;\n\n\tif (counter != CYCLES_COUNTER) {\n\t\tval = readl_relaxed(pmu->base + PMC(counter));\n\t\tgoto out;\n\t}\n\n\t \n\tdo {\n\t\tval_upper = readl_relaxed(pmu->base + PMC(counter) + 0x4);\n\t\tval_lower = readl_relaxed(pmu->base + PMC(counter));\n\t} while (val_upper != readl_relaxed(pmu->base + PMC(counter) + 0x4));\n\n\tval = val_upper;\n\tval = (val << 32);\n\tval |= val_lower;\nout:\n\treturn val;\n}\n\nstatic void ddr_perf_counter_global_config(struct ddr_pmu *pmu, bool enable)\n{\n\tu32 ctrl;\n\n\tctrl = readl_relaxed(pmu->base + PMGC0);\n\n\tif (enable) {\n\t\t \n\t\tctrl |= PMGC0_FAC;\n\t\twritel(ctrl, pmu->base + PMGC0);\n\n\t\t \n\t\tctrl &= ~PMGC0_FAC;\n\t\tctrl |= PMGC0_PMIE | PMGC0_FCECE;\n\t\twritel(ctrl, pmu->base + PMGC0);\n\t} else {\n\t\tctrl |= PMGC0_FAC;\n\t\tctrl &= ~(PMGC0_PMIE | PMGC0_FCECE);\n\t\twritel(ctrl, pmu->base + PMGC0);\n\t}\n}\n\nstatic void ddr_perf_counter_local_config(struct ddr_pmu *pmu, int config,\n\t\t\t\t    int counter, bool enable)\n{\n\tu32 ctrl_a;\n\n\tctrl_a = readl_relaxed(pmu->base + PMLCA(counter));\n\n\tif (enable) {\n\t\tctrl_a |= PMLCA_FC;\n\t\twritel(ctrl_a, pmu->base + PMLCA(counter));\n\n\t\tddr_perf_clear_counter(pmu, counter);\n\n\t\t \n\t\tctrl_a &= ~PMLCA_FC;\n\t\tctrl_a |= PMLCA_CE;\n\t\tctrl_a &= ~FIELD_PREP(PMLCA_EVENT, 0x7F);\n\t\tctrl_a |= FIELD_PREP(PMLCA_EVENT, (config & 0x000000FF));\n\t\twritel(ctrl_a, pmu->base + PMLCA(counter));\n\t} else {\n\t\t \n\t\tctrl_a |= PMLCA_FC;\n\t\twritel(ctrl_a, pmu->base + PMLCA(counter));\n\t}\n}\n\nstatic void ddr_perf_monitor_config(struct ddr_pmu *pmu, int cfg, int cfg1, int cfg2)\n{\n\tu32 pmcfg1, pmcfg2;\n\tint event, counter;\n\n\tevent = cfg & 0x000000FF;\n\tcounter = (cfg & 0x0000FF00) >> 8;\n\n\tpmcfg1 = readl_relaxed(pmu->base + PMCFG1);\n\n\tif (counter == 2 && event == 73)\n\t\tpmcfg1 |= PMCFG1_RD_TRANS_FILT_EN;\n\telse if (counter == 2 && event != 73)\n\t\tpmcfg1 &= ~PMCFG1_RD_TRANS_FILT_EN;\n\n\tif (counter == 3 && event == 73)\n\t\tpmcfg1 |= PMCFG1_WR_TRANS_FILT_EN;\n\telse if (counter == 3 && event != 73)\n\t\tpmcfg1 &= ~PMCFG1_WR_TRANS_FILT_EN;\n\n\tif (counter == 4 && event == 73)\n\t\tpmcfg1 |= PMCFG1_RD_BT_FILT_EN;\n\telse if (counter == 4 && event != 73)\n\t\tpmcfg1 &= ~PMCFG1_RD_BT_FILT_EN;\n\n\tpmcfg1 &= ~FIELD_PREP(PMCFG1_ID_MASK, 0x3FFFF);\n\tpmcfg1 |= FIELD_PREP(PMCFG1_ID_MASK, cfg2);\n\twritel(pmcfg1, pmu->base + PMCFG1);\n\n\tpmcfg2 = readl_relaxed(pmu->base + PMCFG2);\n\tpmcfg2 &= ~FIELD_PREP(PMCFG2_ID, 0x3FFFF);\n\tpmcfg2 |= FIELD_PREP(PMCFG2_ID, cfg1);\n\twritel(pmcfg2, pmu->base + PMCFG2);\n}\n\nstatic void ddr_perf_event_update(struct perf_event *event)\n{\n\tstruct ddr_pmu *pmu = to_ddr_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint counter = hwc->idx;\n\tu64 new_raw_count;\n\n\tnew_raw_count = ddr_perf_read_counter(pmu, counter);\n\tlocal64_add(new_raw_count, &event->count);\n\n\t \n\tddr_perf_clear_counter(pmu, counter);\n}\n\nstatic int ddr_perf_event_init(struct perf_event *event)\n{\n\tstruct ddr_pmu *pmu = to_ddr_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct perf_event *sibling;\n\n\tif (event->attr.type != event->pmu->type)\n\t\treturn -ENOENT;\n\n\tif (is_sampling_event(event) || event->attach_state & PERF_ATTACH_TASK)\n\t\treturn -EOPNOTSUPP;\n\n\tif (event->cpu < 0) {\n\t\tdev_warn(pmu->dev, \"Can't provide per-task data!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (event->group_leader->pmu != event->pmu &&\n\t\t\t!is_software_event(event->group_leader))\n\t\treturn -EINVAL;\n\n\tfor_each_sibling_event(sibling, event->group_leader) {\n\t\tif (sibling->pmu != event->pmu &&\n\t\t\t\t!is_software_event(sibling))\n\t\t\treturn -EINVAL;\n\t}\n\n\tevent->cpu = pmu->cpu;\n\thwc->idx = -1;\n\n\treturn 0;\n}\n\nstatic void ddr_perf_event_start(struct perf_event *event, int flags)\n{\n\tstruct ddr_pmu *pmu = to_ddr_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint counter = hwc->idx;\n\n\tlocal64_set(&hwc->prev_count, 0);\n\n\tddr_perf_counter_local_config(pmu, event->attr.config, counter, true);\n\thwc->state = 0;\n}\n\nstatic int ddr_perf_event_add(struct perf_event *event, int flags)\n{\n\tstruct ddr_pmu *pmu = to_ddr_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint cfg = event->attr.config;\n\tint cfg1 = event->attr.config1;\n\tint cfg2 = event->attr.config2;\n\tint counter;\n\n\tcounter = (cfg & 0x0000FF00) >> 8;\n\n\tpmu->events[counter] = event;\n\tpmu->active_events++;\n\thwc->idx = counter;\n\thwc->state |= PERF_HES_STOPPED;\n\n\tif (flags & PERF_EF_START)\n\t\tddr_perf_event_start(event, flags);\n\n\t \n\tddr_perf_monitor_config(pmu, cfg, cfg1, cfg2);\n\n\treturn 0;\n}\n\nstatic void ddr_perf_event_stop(struct perf_event *event, int flags)\n{\n\tstruct ddr_pmu *pmu = to_ddr_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint counter = hwc->idx;\n\n\tddr_perf_counter_local_config(pmu, event->attr.config, counter, false);\n\tddr_perf_event_update(event);\n\n\thwc->state |= PERF_HES_STOPPED;\n}\n\nstatic void ddr_perf_event_del(struct perf_event *event, int flags)\n{\n\tstruct ddr_pmu *pmu = to_ddr_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tddr_perf_event_stop(event, PERF_EF_UPDATE);\n\n\tpmu->active_events--;\n\thwc->idx = -1;\n}\n\nstatic void ddr_perf_pmu_enable(struct pmu *pmu)\n{\n\tstruct ddr_pmu *ddr_pmu = to_ddr_pmu(pmu);\n\n\tddr_perf_counter_global_config(ddr_pmu, true);\n}\n\nstatic void ddr_perf_pmu_disable(struct pmu *pmu)\n{\n\tstruct ddr_pmu *ddr_pmu = to_ddr_pmu(pmu);\n\n\tddr_perf_counter_global_config(ddr_pmu, false);\n}\n\nstatic void ddr_perf_init(struct ddr_pmu *pmu, void __iomem *base,\n\t\t\t struct device *dev)\n{\n\t*pmu = (struct ddr_pmu) {\n\t\t.pmu = (struct pmu) {\n\t\t\t.module       = THIS_MODULE,\n\t\t\t.capabilities = PERF_PMU_CAP_NO_EXCLUDE,\n\t\t\t.task_ctx_nr  = perf_invalid_context,\n\t\t\t.attr_groups  = attr_groups,\n\t\t\t.event_init   = ddr_perf_event_init,\n\t\t\t.add          = ddr_perf_event_add,\n\t\t\t.del          = ddr_perf_event_del,\n\t\t\t.start        = ddr_perf_event_start,\n\t\t\t.stop         = ddr_perf_event_stop,\n\t\t\t.read         = ddr_perf_event_update,\n\t\t\t.pmu_enable   = ddr_perf_pmu_enable,\n\t\t\t.pmu_disable  = ddr_perf_pmu_disable,\n\t\t},\n\t\t.base = base,\n\t\t.dev = dev,\n\t};\n}\n\nstatic irqreturn_t ddr_perf_irq_handler(int irq, void *p)\n{\n\tstruct ddr_pmu *pmu = (struct ddr_pmu *)p;\n\tstruct perf_event *event;\n\tint i;\n\n\t \n\tfor (i = 0; i < NUM_COUNTERS; i++) {\n\t\tif (!pmu->events[i])\n\t\t\tcontinue;\n\n\t\tevent = pmu->events[i];\n\n\t\tddr_perf_event_update(event);\n\t}\n\n\tddr_perf_counter_global_config(pmu, true);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ddr_perf_offline_cpu(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct ddr_pmu *pmu = hlist_entry_safe(node, struct ddr_pmu, node);\n\tint target;\n\n\tif (cpu != pmu->cpu)\n\t\treturn 0;\n\n\ttarget = cpumask_any_but(cpu_online_mask, cpu);\n\tif (target >= nr_cpu_ids)\n\t\treturn 0;\n\n\tperf_pmu_migrate_context(&pmu->pmu, cpu, target);\n\tpmu->cpu = target;\n\n\tWARN_ON(irq_set_affinity(pmu->irq, cpumask_of(pmu->cpu)));\n\n\treturn 0;\n}\n\nstatic int ddr_perf_probe(struct platform_device *pdev)\n{\n\tstruct ddr_pmu *pmu;\n\tvoid __iomem *base;\n\tint ret, irq;\n\tchar *name;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpmu = devm_kzalloc(&pdev->dev, sizeof(*pmu), GFP_KERNEL);\n\tif (!pmu)\n\t\treturn -ENOMEM;\n\n\tddr_perf_init(pmu, base, &pdev->dev);\n\n\tpmu->devtype_data = of_device_get_match_data(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, pmu);\n\n\tpmu->id = ida_simple_get(&ddr_ida, 0, 0, GFP_KERNEL);\n\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL, DDR_PERF_DEV_NAME \"%d\", pmu->id);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto format_string_err;\n\t}\n\n\tpmu->cpu = raw_smp_processor_id();\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, DDR_CPUHP_CB_NAME,\n\t\t\t\t      NULL, ddr_perf_offline_cpu);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to add callbacks for multi state\\n\");\n\t\tgoto cpuhp_state_err;\n\t}\n\tpmu->cpuhp_state = ret;\n\n\t \n\tret = cpuhp_state_add_instance_nocalls(pmu->cpuhp_state, &pmu->node);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error %d registering hotplug\\n\", ret);\n\t\tgoto cpuhp_instance_err;\n\t}\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto ddr_perf_err;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, ddr_perf_irq_handler,\n\t\t\t       IRQF_NOBALANCING | IRQF_NO_THREAD,\n\t\t\t       DDR_CPUHP_CB_NAME, pmu);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Request irq failed: %d\", ret);\n\t\tgoto ddr_perf_err;\n\t}\n\n\tpmu->irq = irq;\n\tret = irq_set_affinity(pmu->irq, cpumask_of(pmu->cpu));\n\tif (ret) {\n\t\tdev_err(pmu->dev, \"Failed to set interrupt affinity\\n\");\n\t\tgoto ddr_perf_err;\n\t}\n\n\tret = perf_pmu_register(&pmu->pmu, name, -1);\n\tif (ret)\n\t\tgoto ddr_perf_err;\n\n\treturn 0;\n\nddr_perf_err:\n\tcpuhp_state_remove_instance_nocalls(pmu->cpuhp_state, &pmu->node);\ncpuhp_instance_err:\n\tcpuhp_remove_multi_state(pmu->cpuhp_state);\ncpuhp_state_err:\nformat_string_err:\n\tida_simple_remove(&ddr_ida, pmu->id);\n\tdev_warn(&pdev->dev, \"i.MX9 DDR Perf PMU failed (%d), disabled\\n\", ret);\n\treturn ret;\n}\n\nstatic int ddr_perf_remove(struct platform_device *pdev)\n{\n\tstruct ddr_pmu *pmu = platform_get_drvdata(pdev);\n\n\tcpuhp_state_remove_instance_nocalls(pmu->cpuhp_state, &pmu->node);\n\tcpuhp_remove_multi_state(pmu->cpuhp_state);\n\n\tperf_pmu_unregister(&pmu->pmu);\n\n\tida_simple_remove(&ddr_ida, pmu->id);\n\n\treturn 0;\n}\n\nstatic struct platform_driver imx_ddr_pmu_driver = {\n\t.driver         = {\n\t\t.name                = \"imx9-ddr-pmu\",\n\t\t.of_match_table      = imx_ddr_pmu_dt_ids,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe          = ddr_perf_probe,\n\t.remove         = ddr_perf_remove,\n};\nmodule_platform_driver(imx_ddr_pmu_driver);\n\nMODULE_AUTHOR(\"Xu Yang <xu.yang_2@nxp.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DDRC PerfMon for i.MX9 SoCs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}