{
  "module_name": "riscv_pmu_sbi.c",
  "hash_id": "44a182cf1e1ee287bf37385e032ee1ea46a79d5c49fa08e6411164665b91c6ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/riscv_pmu_sbi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"riscv-pmu-sbi: \" fmt\n\n#include <linux/mod_devicetable.h>\n#include <linux/perf/riscv_pmu.h>\n#include <linux/platform_device.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/cpu_pm.h>\n#include <linux/sched/clock.h>\n\n#include <asm/errata_list.h>\n#include <asm/sbi.h>\n#include <asm/hwcap.h>\n\n#define SYSCTL_NO_USER_ACCESS\t0\n#define SYSCTL_USER_ACCESS\t1\n#define SYSCTL_LEGACY\t\t2\n\n#define PERF_EVENT_FLAG_NO_USER_ACCESS\tBIT(SYSCTL_NO_USER_ACCESS)\n#define PERF_EVENT_FLAG_USER_ACCESS\tBIT(SYSCTL_USER_ACCESS)\n#define PERF_EVENT_FLAG_LEGACY\t\tBIT(SYSCTL_LEGACY)\n\nPMU_FORMAT_ATTR(event, \"config:0-47\");\nPMU_FORMAT_ATTR(firmware, \"config:63\");\n\nstatic struct attribute *riscv_arch_formats_attr[] = {\n\t&format_attr_event.attr,\n\t&format_attr_firmware.attr,\n\tNULL,\n};\n\nstatic struct attribute_group riscv_pmu_format_group = {\n\t.name = \"format\",\n\t.attrs = riscv_arch_formats_attr,\n};\n\nstatic const struct attribute_group *riscv_pmu_attr_groups[] = {\n\t&riscv_pmu_format_group,\n\tNULL,\n};\n\n \nstatic int sysctl_perf_user_access __read_mostly = SYSCTL_USER_ACCESS;\n\n \nstatic union sbi_pmu_ctr_info *pmu_ctr_list;\nstatic bool riscv_pmu_use_irq;\nstatic unsigned int riscv_pmu_irq_num;\nstatic unsigned int riscv_pmu_irq;\n\n \nstatic unsigned long cmask;\n\nstruct sbi_pmu_event_data {\n\tunion {\n\t\tunion {\n\t\t\tstruct hw_gen_event {\n\t\t\t\tuint32_t event_code:16;\n\t\t\t\tuint32_t event_type:4;\n\t\t\t\tuint32_t reserved:12;\n\t\t\t} hw_gen_event;\n\t\t\tstruct hw_cache_event {\n\t\t\t\tuint32_t result_id:1;\n\t\t\t\tuint32_t op_id:2;\n\t\t\t\tuint32_t cache_id:13;\n\t\t\t\tuint32_t event_type:4;\n\t\t\t\tuint32_t reserved:12;\n\t\t\t} hw_cache_event;\n\t\t};\n\t\tuint32_t event_idx;\n\t};\n};\n\nstatic const struct sbi_pmu_event_data pmu_hw_event_map[] = {\n\t[PERF_COUNT_HW_CPU_CYCLES]\t\t= {.hw_gen_event = {\n\t\t\t\t\t\t\tSBI_PMU_HW_CPU_CYCLES,\n\t\t\t\t\t\t\tSBI_PMU_EVENT_TYPE_HW, 0}},\n\t[PERF_COUNT_HW_INSTRUCTIONS]\t\t= {.hw_gen_event = {\n\t\t\t\t\t\t\tSBI_PMU_HW_INSTRUCTIONS,\n\t\t\t\t\t\t\tSBI_PMU_EVENT_TYPE_HW, 0}},\n\t[PERF_COUNT_HW_CACHE_REFERENCES]\t= {.hw_gen_event = {\n\t\t\t\t\t\t\tSBI_PMU_HW_CACHE_REFERENCES,\n\t\t\t\t\t\t\tSBI_PMU_EVENT_TYPE_HW, 0}},\n\t[PERF_COUNT_HW_CACHE_MISSES]\t\t= {.hw_gen_event = {\n\t\t\t\t\t\t\tSBI_PMU_HW_CACHE_MISSES,\n\t\t\t\t\t\t\tSBI_PMU_EVENT_TYPE_HW, 0}},\n\t[PERF_COUNT_HW_BRANCH_INSTRUCTIONS]\t= {.hw_gen_event = {\n\t\t\t\t\t\t\tSBI_PMU_HW_BRANCH_INSTRUCTIONS,\n\t\t\t\t\t\t\tSBI_PMU_EVENT_TYPE_HW, 0}},\n\t[PERF_COUNT_HW_BRANCH_MISSES]\t\t= {.hw_gen_event = {\n\t\t\t\t\t\t\tSBI_PMU_HW_BRANCH_MISSES,\n\t\t\t\t\t\t\tSBI_PMU_EVENT_TYPE_HW, 0}},\n\t[PERF_COUNT_HW_BUS_CYCLES]\t\t= {.hw_gen_event = {\n\t\t\t\t\t\t\tSBI_PMU_HW_BUS_CYCLES,\n\t\t\t\t\t\t\tSBI_PMU_EVENT_TYPE_HW, 0}},\n\t[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND]\t= {.hw_gen_event = {\n\t\t\t\t\t\t\tSBI_PMU_HW_STALLED_CYCLES_FRONTEND,\n\t\t\t\t\t\t\tSBI_PMU_EVENT_TYPE_HW, 0}},\n\t[PERF_COUNT_HW_STALLED_CYCLES_BACKEND]\t= {.hw_gen_event = {\n\t\t\t\t\t\t\tSBI_PMU_HW_STALLED_CYCLES_BACKEND,\n\t\t\t\t\t\t\tSBI_PMU_EVENT_TYPE_HW, 0}},\n\t[PERF_COUNT_HW_REF_CPU_CYCLES]\t\t= {.hw_gen_event = {\n\t\t\t\t\t\t\tSBI_PMU_HW_REF_CPU_CYCLES,\n\t\t\t\t\t\t\tSBI_PMU_EVENT_TYPE_HW, 0}},\n};\n\n#define C(x) PERF_COUNT_HW_CACHE_##x\nstatic const struct sbi_pmu_event_data pmu_cache_event_map[PERF_COUNT_HW_CACHE_MAX]\n[PERF_COUNT_HW_CACHE_OP_MAX]\n[PERF_COUNT_HW_CACHE_RESULT_MAX] = {\n\t[C(L1D)] = {\n\t\t[C(OP_READ)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_READ), C(L1D), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_READ), C(L1D), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_WRITE)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_WRITE), C(L1D), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_WRITE), C(L1D), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_PREFETCH)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_PREFETCH), C(L1D), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_PREFETCH), C(L1D), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t},\n\t[C(L1I)] = {\n\t\t[C(OP_READ)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event =\t{C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_READ), C(L1I), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS), C(OP_READ),\n\t\t\t\t\tC(L1I), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_WRITE)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_WRITE), C(L1I), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_WRITE), C(L1I), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_PREFETCH)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_PREFETCH), C(L1I), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_PREFETCH), C(L1I), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t},\n\t[C(LL)] = {\n\t\t[C(OP_READ)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_READ), C(LL), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_READ), C(LL), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_WRITE)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_WRITE), C(LL), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_WRITE), C(LL), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_PREFETCH)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_PREFETCH), C(LL), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_PREFETCH), C(LL), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t},\n\t[C(DTLB)] = {\n\t\t[C(OP_READ)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_READ), C(DTLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_READ), C(DTLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_WRITE)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_WRITE), C(DTLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_WRITE), C(DTLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_PREFETCH)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_PREFETCH), C(DTLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_PREFETCH), C(DTLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t},\n\t[C(ITLB)] = {\n\t\t[C(OP_READ)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_READ), C(ITLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_READ), C(ITLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_WRITE)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_WRITE), C(ITLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_WRITE), C(ITLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_PREFETCH)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_PREFETCH), C(ITLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_PREFETCH), C(ITLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t},\n\t[C(BPU)] = {\n\t\t[C(OP_READ)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_READ), C(BPU), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_READ), C(BPU), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_WRITE)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_WRITE), C(BPU), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_WRITE), C(BPU), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_PREFETCH)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_PREFETCH), C(BPU), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_PREFETCH), C(BPU), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t},\n\t[C(NODE)] = {\n\t\t[C(OP_READ)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_READ), C(NODE), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_READ), C(NODE), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_WRITE)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_WRITE), C(NODE), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_WRITE), C(NODE), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t\t[C(OP_PREFETCH)] = {\n\t\t\t[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),\n\t\t\t\t\tC(OP_PREFETCH), C(NODE), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t\t[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),\n\t\t\t\t\tC(OP_PREFETCH), C(NODE), SBI_PMU_EVENT_TYPE_CACHE, 0}},\n\t\t},\n\t},\n};\n\nstatic int pmu_sbi_ctr_get_width(int idx)\n{\n\treturn pmu_ctr_list[idx].width;\n}\n\nstatic bool pmu_sbi_ctr_is_fw(int cidx)\n{\n\tunion sbi_pmu_ctr_info *info;\n\n\tinfo = &pmu_ctr_list[cidx];\n\tif (!info)\n\t\treturn false;\n\n\treturn (info->type == SBI_PMU_CTR_TYPE_FW) ? true : false;\n}\n\n \nint riscv_pmu_get_hpm_info(u32 *hw_ctr_width, u32 *num_hw_ctr)\n{\n\tint i;\n\tunion sbi_pmu_ctr_info *info;\n\tu32 hpm_width = 0, hpm_count = 0;\n\n\tif (!cmask)\n\t\treturn -EINVAL;\n\n\tfor_each_set_bit(i, &cmask, RISCV_MAX_COUNTERS) {\n\t\tinfo = &pmu_ctr_list[i];\n\t\tif (!info)\n\t\t\tcontinue;\n\t\tif (!hpm_width && info->csr != CSR_CYCLE && info->csr != CSR_INSTRET)\n\t\t\thpm_width = info->width;\n\t\tif (info->type == SBI_PMU_CTR_TYPE_HW)\n\t\t\thpm_count++;\n\t}\n\n\t*hw_ctr_width = hpm_width;\n\t*num_hw_ctr = hpm_count;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(riscv_pmu_get_hpm_info);\n\nstatic uint8_t pmu_sbi_csr_index(struct perf_event *event)\n{\n\treturn pmu_ctr_list[event->hw.idx].csr - CSR_CYCLE;\n}\n\nstatic unsigned long pmu_sbi_get_filter_flags(struct perf_event *event)\n{\n\tunsigned long cflags = 0;\n\tbool guest_events = false;\n\n\tif (event->attr.config1 & RISCV_PMU_CONFIG1_GUEST_EVENTS)\n\t\tguest_events = true;\n\tif (event->attr.exclude_kernel)\n\t\tcflags |= guest_events ? SBI_PMU_CFG_FLAG_SET_VSINH : SBI_PMU_CFG_FLAG_SET_SINH;\n\tif (event->attr.exclude_user)\n\t\tcflags |= guest_events ? SBI_PMU_CFG_FLAG_SET_VUINH : SBI_PMU_CFG_FLAG_SET_UINH;\n\tif (guest_events && event->attr.exclude_hv)\n\t\tcflags |= SBI_PMU_CFG_FLAG_SET_SINH;\n\tif (event->attr.exclude_host)\n\t\tcflags |= SBI_PMU_CFG_FLAG_SET_UINH | SBI_PMU_CFG_FLAG_SET_SINH;\n\tif (event->attr.exclude_guest)\n\t\tcflags |= SBI_PMU_CFG_FLAG_SET_VSINH | SBI_PMU_CFG_FLAG_SET_VUINH;\n\n\treturn cflags;\n}\n\nstatic int pmu_sbi_ctr_get_idx(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct riscv_pmu *rvpmu = to_riscv_pmu(event->pmu);\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(rvpmu->hw_events);\n\tstruct sbiret ret;\n\tint idx;\n\tuint64_t cbase = 0, cmask = rvpmu->cmask;\n\tunsigned long cflags = 0;\n\n\tcflags = pmu_sbi_get_filter_flags(event);\n\n\t \n\tif (hwc->flags & PERF_EVENT_FLAG_LEGACY) {\n\t\tif (event->attr.config == PERF_COUNT_HW_CPU_CYCLES) {\n\t\t\tcflags |= SBI_PMU_CFG_FLAG_SKIP_MATCH;\n\t\t\tcmask = 1;\n\t\t} else if (event->attr.config == PERF_COUNT_HW_INSTRUCTIONS) {\n\t\t\tcflags |= SBI_PMU_CFG_FLAG_SKIP_MATCH;\n\t\t\tcmask = 1UL << (CSR_INSTRET - CSR_CYCLE);\n\t\t}\n\t}\n\n\t \n#if defined(CONFIG_32BIT)\n\tret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_CFG_MATCH, cbase,\n\t\t\tcmask, cflags, hwc->event_base, hwc->config,\n\t\t\thwc->config >> 32);\n#else\n\tret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_CFG_MATCH, cbase,\n\t\t\tcmask, cflags, hwc->event_base, hwc->config, 0);\n#endif\n\tif (ret.error) {\n\t\tpr_debug(\"Not able to find a counter for event %lx config %llx\\n\",\n\t\t\thwc->event_base, hwc->config);\n\t\treturn sbi_err_map_linux_errno(ret.error);\n\t}\n\n\tidx = ret.value;\n\tif (!test_bit(idx, &rvpmu->cmask) || !pmu_ctr_list[idx].value)\n\t\treturn -ENOENT;\n\n\t \n\tif (pmu_sbi_ctr_is_fw(idx)) {\n\t\tif (!test_and_set_bit(idx, cpuc->used_fw_ctrs))\n\t\t\treturn idx;\n\t} else {\n\t\tif (!test_and_set_bit(idx, cpuc->used_hw_ctrs))\n\t\t\treturn idx;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic void pmu_sbi_ctr_clear_idx(struct perf_event *event)\n{\n\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct riscv_pmu *rvpmu = to_riscv_pmu(event->pmu);\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(rvpmu->hw_events);\n\tint idx = hwc->idx;\n\n\tif (pmu_sbi_ctr_is_fw(idx))\n\t\tclear_bit(idx, cpuc->used_fw_ctrs);\n\telse\n\t\tclear_bit(idx, cpuc->used_hw_ctrs);\n}\n\nstatic int pmu_event_find_cache(u64 config)\n{\n\tunsigned int cache_type, cache_op, cache_result, ret;\n\n\tcache_type = (config >>  0) & 0xff;\n\tif (cache_type >= PERF_COUNT_HW_CACHE_MAX)\n\t\treturn -EINVAL;\n\n\tcache_op = (config >>  8) & 0xff;\n\tif (cache_op >= PERF_COUNT_HW_CACHE_OP_MAX)\n\t\treturn -EINVAL;\n\n\tcache_result = (config >> 16) & 0xff;\n\tif (cache_result >= PERF_COUNT_HW_CACHE_RESULT_MAX)\n\t\treturn -EINVAL;\n\n\tret = pmu_cache_event_map[cache_type][cache_op][cache_result].event_idx;\n\n\treturn ret;\n}\n\nstatic bool pmu_sbi_is_fw_event(struct perf_event *event)\n{\n\tu32 type = event->attr.type;\n\tu64 config = event->attr.config;\n\n\tif ((type == PERF_TYPE_RAW) && ((config >> 63) == 1))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int pmu_sbi_event_map(struct perf_event *event, u64 *econfig)\n{\n\tu32 type = event->attr.type;\n\tu64 config = event->attr.config;\n\tint bSoftware;\n\tu64 raw_config_val;\n\tint ret;\n\n\tswitch (type) {\n\tcase PERF_TYPE_HARDWARE:\n\t\tif (config >= PERF_COUNT_HW_MAX)\n\t\t\treturn -EINVAL;\n\t\tret = pmu_hw_event_map[event->attr.config].event_idx;\n\t\tbreak;\n\tcase PERF_TYPE_HW_CACHE:\n\t\tret = pmu_event_find_cache(config);\n\t\tbreak;\n\tcase PERF_TYPE_RAW:\n\t\t \n\t\tbSoftware = config >> 63;\n\t\traw_config_val = config & RISCV_PMU_RAW_EVENT_MASK;\n\t\tif (bSoftware) {\n\t\t\tret = (raw_config_val & 0xFFFF) |\n\t\t\t\t(SBI_PMU_EVENT_TYPE_FW << 16);\n\t\t} else {\n\t\t\tret = RISCV_PMU_RAW_EVENT_IDX;\n\t\t\t*econfig = raw_config_val;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic u64 pmu_sbi_ctr_read(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx = hwc->idx;\n\tstruct sbiret ret;\n\tunion sbi_pmu_ctr_info info;\n\tu64 val = 0;\n\n\tif (pmu_sbi_is_fw_event(event)) {\n\t\tret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_FW_READ,\n\t\t\t\thwc->idx, 0, 0, 0, 0, 0);\n\t\tif (!ret.error)\n\t\t\tval = ret.value;\n\t} else {\n\t\tinfo = pmu_ctr_list[idx];\n\t\tval = riscv_pmu_ctr_read_csr(info.csr);\n\t\tif (IS_ENABLED(CONFIG_32BIT))\n\t\t\tval = ((u64)riscv_pmu_ctr_read_csr(info.csr + 0x80)) << 31 | val;\n\t}\n\n\treturn val;\n}\n\nstatic void pmu_sbi_set_scounteren(void *arg)\n{\n\tstruct perf_event *event = (struct perf_event *)arg;\n\n\tif (event->hw.idx != -1)\n\t\tcsr_write(CSR_SCOUNTEREN,\n\t\t\t  csr_read(CSR_SCOUNTEREN) | (1 << pmu_sbi_csr_index(event)));\n}\n\nstatic void pmu_sbi_reset_scounteren(void *arg)\n{\n\tstruct perf_event *event = (struct perf_event *)arg;\n\n\tif (event->hw.idx != -1)\n\t\tcsr_write(CSR_SCOUNTEREN,\n\t\t\t  csr_read(CSR_SCOUNTEREN) & ~(1 << pmu_sbi_csr_index(event)));\n}\n\nstatic void pmu_sbi_ctr_start(struct perf_event *event, u64 ival)\n{\n\tstruct sbiret ret;\n\tstruct hw_perf_event *hwc = &event->hw;\n\tunsigned long flag = SBI_PMU_START_FLAG_SET_INIT_VALUE;\n\n#if defined(CONFIG_32BIT)\n\tret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_START, hwc->idx,\n\t\t\t1, flag, ival, ival >> 32, 0);\n#else\n\tret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_START, hwc->idx,\n\t\t\t1, flag, ival, 0, 0);\n#endif\n\tif (ret.error && (ret.error != SBI_ERR_ALREADY_STARTED))\n\t\tpr_err(\"Starting counter idx %d failed with error %d\\n\",\n\t\t\thwc->idx, sbi_err_map_linux_errno(ret.error));\n\n\tif ((hwc->flags & PERF_EVENT_FLAG_USER_ACCESS) &&\n\t    (hwc->flags & PERF_EVENT_FLAG_USER_READ_CNT))\n\t\tpmu_sbi_set_scounteren((void *)event);\n}\n\nstatic void pmu_sbi_ctr_stop(struct perf_event *event, unsigned long flag)\n{\n\tstruct sbiret ret;\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif ((hwc->flags & PERF_EVENT_FLAG_USER_ACCESS) &&\n\t    (hwc->flags & PERF_EVENT_FLAG_USER_READ_CNT))\n\t\tpmu_sbi_reset_scounteren((void *)event);\n\n\tret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_STOP, hwc->idx, 1, flag, 0, 0, 0);\n\tif (ret.error && (ret.error != SBI_ERR_ALREADY_STOPPED) &&\n\t\tflag != SBI_PMU_STOP_FLAG_RESET)\n\t\tpr_err(\"Stopping counter idx %d failed with error %d\\n\",\n\t\t\thwc->idx, sbi_err_map_linux_errno(ret.error));\n}\n\nstatic int pmu_sbi_find_num_ctrs(void)\n{\n\tstruct sbiret ret;\n\n\tret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_NUM_COUNTERS, 0, 0, 0, 0, 0, 0);\n\tif (!ret.error)\n\t\treturn ret.value;\n\telse\n\t\treturn sbi_err_map_linux_errno(ret.error);\n}\n\nstatic int pmu_sbi_get_ctrinfo(int nctr, unsigned long *mask)\n{\n\tstruct sbiret ret;\n\tint i, num_hw_ctr = 0, num_fw_ctr = 0;\n\tunion sbi_pmu_ctr_info cinfo;\n\n\tpmu_ctr_list = kcalloc(nctr, sizeof(*pmu_ctr_list), GFP_KERNEL);\n\tif (!pmu_ctr_list)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nctr; i++) {\n\t\tret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_GET_INFO, i, 0, 0, 0, 0, 0);\n\t\tif (ret.error)\n\t\t\t \n\t\t\tcontinue;\n\n\t\t*mask |= BIT(i);\n\n\t\tcinfo.value = ret.value;\n\t\tif (cinfo.type == SBI_PMU_CTR_TYPE_FW)\n\t\t\tnum_fw_ctr++;\n\t\telse\n\t\t\tnum_hw_ctr++;\n\t\tpmu_ctr_list[i].value = cinfo.value;\n\t}\n\n\tpr_info(\"%d firmware and %d hardware counters\\n\", num_fw_ctr, num_hw_ctr);\n\n\treturn 0;\n}\n\nstatic inline void pmu_sbi_stop_all(struct riscv_pmu *pmu)\n{\n\t \n\tsbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_STOP,\n\t\t  0, pmu->cmask, 0, 0, 0, 0);\n}\n\nstatic inline void pmu_sbi_stop_hw_ctrs(struct riscv_pmu *pmu)\n{\n\tstruct cpu_hw_events *cpu_hw_evt = this_cpu_ptr(pmu->hw_events);\n\n\t \n\tsbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_STOP, 0,\n\t\t  cpu_hw_evt->used_hw_ctrs[0], 0, 0, 0, 0);\n}\n\n \nstatic inline void pmu_sbi_start_overflow_mask(struct riscv_pmu *pmu,\n\t\t\t\t\t       unsigned long ctr_ovf_mask)\n{\n\tint idx = 0;\n\tstruct cpu_hw_events *cpu_hw_evt = this_cpu_ptr(pmu->hw_events);\n\tstruct perf_event *event;\n\tunsigned long flag = SBI_PMU_START_FLAG_SET_INIT_VALUE;\n\tunsigned long ctr_start_mask = 0;\n\tuint64_t max_period;\n\tstruct hw_perf_event *hwc;\n\tu64 init_val = 0;\n\n\tctr_start_mask = cpu_hw_evt->used_hw_ctrs[0] & ~ctr_ovf_mask;\n\n\t \n\tsbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_START, 0, ctr_start_mask,\n\t\t  0, 0, 0, 0);\n\n\t \n\twhile (ctr_ovf_mask) {\n\t\tif (ctr_ovf_mask & 0x01) {\n\t\t\tevent = cpu_hw_evt->events[idx];\n\t\t\thwc = &event->hw;\n\t\t\tmax_period = riscv_pmu_ctr_get_width_mask(event);\n\t\t\tinit_val = local64_read(&hwc->prev_count) & max_period;\n#if defined(CONFIG_32BIT)\n\t\t\tsbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_START, idx, 1,\n\t\t\t\t  flag, init_val, init_val >> 32, 0);\n#else\n\t\t\tsbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_START, idx, 1,\n\t\t\t\t  flag, init_val, 0, 0);\n#endif\n\t\t\tperf_event_update_userpage(event);\n\t\t}\n\t\tctr_ovf_mask = ctr_ovf_mask >> 1;\n\t\tidx++;\n\t}\n}\n\nstatic irqreturn_t pmu_sbi_ovf_handler(int irq, void *dev)\n{\n\tstruct perf_sample_data data;\n\tstruct pt_regs *regs;\n\tstruct hw_perf_event *hw_evt;\n\tunion sbi_pmu_ctr_info *info;\n\tint lidx, hidx, fidx;\n\tstruct riscv_pmu *pmu;\n\tstruct perf_event *event;\n\tunsigned long overflow;\n\tunsigned long overflowed_ctrs = 0;\n\tstruct cpu_hw_events *cpu_hw_evt = dev;\n\tu64 start_clock = sched_clock();\n\n\tif (WARN_ON_ONCE(!cpu_hw_evt))\n\t\treturn IRQ_NONE;\n\n\t \n\tfidx = find_first_bit(cpu_hw_evt->used_hw_ctrs, RISCV_MAX_COUNTERS);\n\tif (fidx == RISCV_MAX_COUNTERS) {\n\t\tcsr_clear(CSR_SIP, BIT(riscv_pmu_irq_num));\n\t\treturn IRQ_NONE;\n\t}\n\n\tevent = cpu_hw_evt->events[fidx];\n\tif (!event) {\n\t\tcsr_clear(CSR_SIP, BIT(riscv_pmu_irq_num));\n\t\treturn IRQ_NONE;\n\t}\n\n\tpmu = to_riscv_pmu(event->pmu);\n\tpmu_sbi_stop_hw_ctrs(pmu);\n\n\t \n\tALT_SBI_PMU_OVERFLOW(overflow);\n\n\t \n\tcsr_clear(CSR_SIP, BIT(riscv_pmu_irq_num));\n\n\t \n\tif (!overflow)\n\t\treturn IRQ_NONE;\n\n\tregs = get_irq_regs();\n\n\tfor_each_set_bit(lidx, cpu_hw_evt->used_hw_ctrs, RISCV_MAX_COUNTERS) {\n\t\tstruct perf_event *event = cpu_hw_evt->events[lidx];\n\n\t\t \n\t\tif (!event || !is_sampling_event(event))\n\t\t\tcontinue;\n\n\t\tinfo = &pmu_ctr_list[lidx];\n\t\t \n\t\tif (!info || info->type != SBI_PMU_CTR_TYPE_HW)\n\t\t\tcontinue;\n\n\t\t \n\t\thidx = info->csr - CSR_CYCLE;\n\t\t \n\t\tif (!(overflow & (1 << hidx)))\n\t\t\tcontinue;\n\n\t\t \n\t\toverflowed_ctrs |= 1 << lidx;\n\t\thw_evt = &event->hw;\n\t\triscv_pmu_event_update(event);\n\t\tperf_sample_data_init(&data, 0, hw_evt->last_period);\n\t\tif (riscv_pmu_event_set_period(event)) {\n\t\t\t \n\t\t\tperf_event_overflow(event, &data, regs);\n\t\t}\n\t}\n\n\tpmu_sbi_start_overflow_mask(pmu, overflowed_ctrs);\n\tperf_sample_event_took(sched_clock() - start_clock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pmu_sbi_starting_cpu(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct riscv_pmu *pmu = hlist_entry_safe(node, struct riscv_pmu, node);\n\tstruct cpu_hw_events *cpu_hw_evt = this_cpu_ptr(pmu->hw_events);\n\n\t \n\tif (sysctl_perf_user_access == SYSCTL_LEGACY)\n\t\tcsr_write(CSR_SCOUNTEREN, 0x7);\n\telse\n\t\tcsr_write(CSR_SCOUNTEREN, 0x2);\n\n\t \n\tpmu_sbi_stop_all(pmu);\n\n\tif (riscv_pmu_use_irq) {\n\t\tcpu_hw_evt->irq = riscv_pmu_irq;\n\t\tcsr_clear(CSR_IP, BIT(riscv_pmu_irq_num));\n\t\tcsr_set(CSR_IE, BIT(riscv_pmu_irq_num));\n\t\tenable_percpu_irq(riscv_pmu_irq, IRQ_TYPE_NONE);\n\t}\n\n\treturn 0;\n}\n\nstatic int pmu_sbi_dying_cpu(unsigned int cpu, struct hlist_node *node)\n{\n\tif (riscv_pmu_use_irq) {\n\t\tdisable_percpu_irq(riscv_pmu_irq);\n\t\tcsr_clear(CSR_IE, BIT(riscv_pmu_irq_num));\n\t}\n\n\t \n\tcsr_write(CSR_SCOUNTEREN, 0x0);\n\n\treturn 0;\n}\n\nstatic int pmu_sbi_setup_irqs(struct riscv_pmu *pmu, struct platform_device *pdev)\n{\n\tint ret;\n\tstruct cpu_hw_events __percpu *hw_events = pmu->hw_events;\n\tstruct irq_domain *domain = NULL;\n\n\tif (riscv_isa_extension_available(NULL, SSCOFPMF)) {\n\t\triscv_pmu_irq_num = RV_IRQ_PMU;\n\t\triscv_pmu_use_irq = true;\n\t} else if (IS_ENABLED(CONFIG_ERRATA_THEAD_PMU) &&\n\t\t   riscv_cached_mvendorid(0) == THEAD_VENDOR_ID &&\n\t\t   riscv_cached_marchid(0) == 0 &&\n\t\t   riscv_cached_mimpid(0) == 0) {\n\t\triscv_pmu_irq_num = THEAD_C9XX_RV_IRQ_PMU;\n\t\triscv_pmu_use_irq = true;\n\t}\n\n\tif (!riscv_pmu_use_irq)\n\t\treturn -EOPNOTSUPP;\n\n\tdomain = irq_find_matching_fwnode(riscv_get_intc_hwnode(),\n\t\t\t\t\t  DOMAIN_BUS_ANY);\n\tif (!domain) {\n\t\tpr_err(\"Failed to find INTC IRQ root domain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\triscv_pmu_irq = irq_create_mapping(domain, riscv_pmu_irq_num);\n\tif (!riscv_pmu_irq) {\n\t\tpr_err(\"Failed to map PMU interrupt for node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = request_percpu_irq(riscv_pmu_irq, pmu_sbi_ovf_handler, \"riscv-pmu\", hw_events);\n\tif (ret) {\n\t\tpr_err(\"registering percpu irq failed [%d]\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_CPU_PM\nstatic int riscv_pm_pmu_notify(struct notifier_block *b, unsigned long cmd,\n\t\t\t\tvoid *v)\n{\n\tstruct riscv_pmu *rvpmu = container_of(b, struct riscv_pmu, riscv_pm_nb);\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(rvpmu->hw_events);\n\tint enabled = bitmap_weight(cpuc->used_hw_ctrs, RISCV_MAX_COUNTERS);\n\tstruct perf_event *event;\n\tint idx;\n\n\tif (!enabled)\n\t\treturn NOTIFY_OK;\n\n\tfor (idx = 0; idx < RISCV_MAX_COUNTERS; idx++) {\n\t\tevent = cpuc->events[idx];\n\t\tif (!event)\n\t\t\tcontinue;\n\n\t\tswitch (cmd) {\n\t\tcase CPU_PM_ENTER:\n\t\t\t \n\t\t\triscv_pmu_stop(event, PERF_EF_UPDATE);\n\t\t\tbreak;\n\t\tcase CPU_PM_EXIT:\n\t\tcase CPU_PM_ENTER_FAILED:\n\t\t\t \n\t\t\triscv_pmu_start(event, PERF_EF_RELOAD);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int riscv_pm_pmu_register(struct riscv_pmu *pmu)\n{\n\tpmu->riscv_pm_nb.notifier_call = riscv_pm_pmu_notify;\n\treturn cpu_pm_register_notifier(&pmu->riscv_pm_nb);\n}\n\nstatic void riscv_pm_pmu_unregister(struct riscv_pmu *pmu)\n{\n\tcpu_pm_unregister_notifier(&pmu->riscv_pm_nb);\n}\n#else\nstatic inline int riscv_pm_pmu_register(struct riscv_pmu *pmu) { return 0; }\nstatic inline void riscv_pm_pmu_unregister(struct riscv_pmu *pmu) { }\n#endif\n\nstatic void riscv_pmu_destroy(struct riscv_pmu *pmu)\n{\n\triscv_pm_pmu_unregister(pmu);\n\tcpuhp_state_remove_instance(CPUHP_AP_PERF_RISCV_STARTING, &pmu->node);\n}\n\nstatic void pmu_sbi_event_init(struct perf_event *event)\n{\n\t \n\tif (sysctl_perf_user_access == SYSCTL_NO_USER_ACCESS)\n\t\tevent->hw.flags |= PERF_EVENT_FLAG_NO_USER_ACCESS;\n\telse if (sysctl_perf_user_access == SYSCTL_USER_ACCESS)\n\t\tevent->hw.flags |= PERF_EVENT_FLAG_USER_ACCESS;\n\telse\n\t\tevent->hw.flags |= PERF_EVENT_FLAG_LEGACY;\n}\n\nstatic void pmu_sbi_event_mapped(struct perf_event *event, struct mm_struct *mm)\n{\n\tif (event->hw.flags & PERF_EVENT_FLAG_NO_USER_ACCESS)\n\t\treturn;\n\n\tif (event->hw.flags & PERF_EVENT_FLAG_LEGACY) {\n\t\tif (event->attr.config != PERF_COUNT_HW_CPU_CYCLES &&\n\t\t    event->attr.config != PERF_COUNT_HW_INSTRUCTIONS) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\n\tevent->hw.flags |= PERF_EVENT_FLAG_USER_READ_CNT;\n\n\t \n\tif (event->hw.flags & PERF_EVENT_FLAG_USER_ACCESS)\n\t\ton_each_cpu_mask(mm_cpumask(mm),\n\t\t\t\t pmu_sbi_set_scounteren, (void *)event, 1);\n}\n\nstatic void pmu_sbi_event_unmapped(struct perf_event *event, struct mm_struct *mm)\n{\n\tif (event->hw.flags & PERF_EVENT_FLAG_NO_USER_ACCESS)\n\t\treturn;\n\n\tif (event->hw.flags & PERF_EVENT_FLAG_LEGACY) {\n\t\tif (event->attr.config != PERF_COUNT_HW_CPU_CYCLES &&\n\t\t    event->attr.config != PERF_COUNT_HW_INSTRUCTIONS) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tevent->hw.flags &= ~PERF_EVENT_FLAG_USER_READ_CNT;\n\n\tif (event->hw.flags & PERF_EVENT_FLAG_USER_ACCESS)\n\t\ton_each_cpu_mask(mm_cpumask(mm),\n\t\t\t\t pmu_sbi_reset_scounteren, (void *)event, 1);\n}\n\nstatic void riscv_pmu_update_counter_access(void *info)\n{\n\tif (sysctl_perf_user_access == SYSCTL_LEGACY)\n\t\tcsr_write(CSR_SCOUNTEREN, 0x7);\n\telse\n\t\tcsr_write(CSR_SCOUNTEREN, 0x2);\n}\n\nstatic int riscv_pmu_proc_user_access_handler(struct ctl_table *table,\n\t\t\t\t\t      int write, void *buffer,\n\t\t\t\t\t      size_t *lenp, loff_t *ppos)\n{\n\tint prev = sysctl_perf_user_access;\n\tint ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\t \n\tif (ret || !write || prev == sysctl_perf_user_access)\n\t\treturn ret;\n\n\ton_each_cpu(riscv_pmu_update_counter_access, NULL, 1);\n\n\treturn 0;\n}\n\nstatic struct ctl_table sbi_pmu_sysctl_table[] = {\n\t{\n\t\t.procname       = \"perf_user_access\",\n\t\t.data\t\t= &sysctl_perf_user_access,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler\t= riscv_pmu_proc_user_access_handler,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{ }\n};\n\nstatic int pmu_sbi_device_probe(struct platform_device *pdev)\n{\n\tstruct riscv_pmu *pmu = NULL;\n\tint ret = -ENODEV;\n\tint num_counters;\n\n\tpr_info(\"SBI PMU extension is available\\n\");\n\tpmu = riscv_pmu_alloc();\n\tif (!pmu)\n\t\treturn -ENOMEM;\n\n\tnum_counters = pmu_sbi_find_num_ctrs();\n\tif (num_counters < 0) {\n\t\tpr_err(\"SBI PMU extension doesn't provide any counters\\n\");\n\t\tgoto out_free;\n\t}\n\n\t \n\tif (num_counters > RISCV_MAX_COUNTERS) {\n\t\tnum_counters = RISCV_MAX_COUNTERS;\n\t\tpr_info(\"SBI returned more than maximum number of counters. Limiting the number of counters to %d\\n\", num_counters);\n\t}\n\n\t \n\tif (pmu_sbi_get_ctrinfo(num_counters, &cmask))\n\t\tgoto out_free;\n\n\tret = pmu_sbi_setup_irqs(pmu, pdev);\n\tif (ret < 0) {\n\t\tpr_info(\"Perf sampling/filtering is not supported as sscof extension is not available\\n\");\n\t\tpmu->pmu.capabilities |= PERF_PMU_CAP_NO_INTERRUPT;\n\t\tpmu->pmu.capabilities |= PERF_PMU_CAP_NO_EXCLUDE;\n\t}\n\n\tpmu->pmu.attr_groups = riscv_pmu_attr_groups;\n\tpmu->cmask = cmask;\n\tpmu->ctr_start = pmu_sbi_ctr_start;\n\tpmu->ctr_stop = pmu_sbi_ctr_stop;\n\tpmu->event_map = pmu_sbi_event_map;\n\tpmu->ctr_get_idx = pmu_sbi_ctr_get_idx;\n\tpmu->ctr_get_width = pmu_sbi_ctr_get_width;\n\tpmu->ctr_clear_idx = pmu_sbi_ctr_clear_idx;\n\tpmu->ctr_read = pmu_sbi_ctr_read;\n\tpmu->event_init = pmu_sbi_event_init;\n\tpmu->event_mapped = pmu_sbi_event_mapped;\n\tpmu->event_unmapped = pmu_sbi_event_unmapped;\n\tpmu->csr_index = pmu_sbi_csr_index;\n\n\tret = cpuhp_state_add_instance(CPUHP_AP_PERF_RISCV_STARTING, &pmu->node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = riscv_pm_pmu_register(pmu);\n\tif (ret)\n\t\tgoto out_unregister;\n\n\tret = perf_pmu_register(&pmu->pmu, \"cpu\", PERF_TYPE_RAW);\n\tif (ret)\n\t\tgoto out_unregister;\n\n\tregister_sysctl(\"kernel\", sbi_pmu_sysctl_table);\n\n\treturn 0;\n\nout_unregister:\n\triscv_pmu_destroy(pmu);\n\nout_free:\n\tkfree(pmu);\n\treturn ret;\n}\n\nstatic struct platform_driver pmu_sbi_driver = {\n\t.probe\t\t= pmu_sbi_device_probe,\n\t.driver\t\t= {\n\t\t.name\t= RISCV_PMU_SBI_PDEV_NAME,\n\t},\n};\n\nstatic int __init pmu_sbi_devinit(void)\n{\n\tint ret;\n\tstruct platform_device *pdev;\n\n\tif (sbi_spec_version < sbi_mk_version(0, 3) ||\n\t    !sbi_probe_extension(SBI_EXT_PMU)) {\n\t\treturn 0;\n\t}\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_PERF_RISCV_STARTING,\n\t\t\t\t      \"perf/riscv/pmu:starting\",\n\t\t\t\t      pmu_sbi_starting_cpu, pmu_sbi_dying_cpu);\n\tif (ret) {\n\t\tpr_err(\"CPU hotplug notifier could not be registered: %d\\n\",\n\t\t       ret);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&pmu_sbi_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tpdev = platform_device_register_simple(RISCV_PMU_SBI_PDEV_NAME, -1, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\tplatform_driver_unregister(&pmu_sbi_driver);\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\t \n\triscv_pmu_legacy_skip_init();\n\n\treturn ret;\n}\ndevice_initcall(pmu_sbi_devinit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}