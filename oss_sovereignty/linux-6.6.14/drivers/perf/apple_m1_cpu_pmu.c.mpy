{
  "module_name": "apple_m1_cpu_pmu.c",
  "hash_id": "2ce39b6006f1393251f851a39a987fec42982ca6fa855a60874c348636f8521b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/apple_m1_cpu_pmu.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/perf/arm_pmu.h>\n#include <linux/platform_device.h>\n\n#include <asm/apple_m1_pmu.h>\n#include <asm/irq_regs.h>\n#include <asm/perf_event.h>\n\n#define M1_PMU_NR_COUNTERS\t\t10\n\n#define M1_PMU_CFG_EVENT\t\tGENMASK(7, 0)\n\n#define ANY_BUT_0_1\t\t\tGENMASK(9, 2)\n#define ONLY_2_TO_7\t\t\tGENMASK(7, 2)\n#define ONLY_2_4_6\t\t\t(BIT(2) | BIT(4) | BIT(6))\n#define ONLY_5_6_7\t\t\t(BIT(5) | BIT(6) | BIT(7))\n\n \nenum m1_pmu_events {\n\tM1_PMU_PERFCTR_UNKNOWN_01\t= 0x01,\n\tM1_PMU_PERFCTR_CPU_CYCLES\t= 0x02,\n\tM1_PMU_PERFCTR_INSTRUCTIONS\t= 0x8c,\n\tM1_PMU_PERFCTR_UNKNOWN_8d\t= 0x8d,\n\tM1_PMU_PERFCTR_UNKNOWN_8e\t= 0x8e,\n\tM1_PMU_PERFCTR_UNKNOWN_8f\t= 0x8f,\n\tM1_PMU_PERFCTR_UNKNOWN_90\t= 0x90,\n\tM1_PMU_PERFCTR_UNKNOWN_93\t= 0x93,\n\tM1_PMU_PERFCTR_UNKNOWN_94\t= 0x94,\n\tM1_PMU_PERFCTR_UNKNOWN_95\t= 0x95,\n\tM1_PMU_PERFCTR_UNKNOWN_96\t= 0x96,\n\tM1_PMU_PERFCTR_UNKNOWN_97\t= 0x97,\n\tM1_PMU_PERFCTR_UNKNOWN_98\t= 0x98,\n\tM1_PMU_PERFCTR_UNKNOWN_99\t= 0x99,\n\tM1_PMU_PERFCTR_UNKNOWN_9a\t= 0x9a,\n\tM1_PMU_PERFCTR_UNKNOWN_9b\t= 0x9b,\n\tM1_PMU_PERFCTR_UNKNOWN_9c\t= 0x9c,\n\tM1_PMU_PERFCTR_UNKNOWN_9f\t= 0x9f,\n\tM1_PMU_PERFCTR_UNKNOWN_bf\t= 0xbf,\n\tM1_PMU_PERFCTR_UNKNOWN_c0\t= 0xc0,\n\tM1_PMU_PERFCTR_UNKNOWN_c1\t= 0xc1,\n\tM1_PMU_PERFCTR_UNKNOWN_c4\t= 0xc4,\n\tM1_PMU_PERFCTR_UNKNOWN_c5\t= 0xc5,\n\tM1_PMU_PERFCTR_UNKNOWN_c6\t= 0xc6,\n\tM1_PMU_PERFCTR_UNKNOWN_c8\t= 0xc8,\n\tM1_PMU_PERFCTR_UNKNOWN_ca\t= 0xca,\n\tM1_PMU_PERFCTR_UNKNOWN_cb\t= 0xcb,\n\tM1_PMU_PERFCTR_UNKNOWN_f5\t= 0xf5,\n\tM1_PMU_PERFCTR_UNKNOWN_f6\t= 0xf6,\n\tM1_PMU_PERFCTR_UNKNOWN_f7\t= 0xf7,\n\tM1_PMU_PERFCTR_UNKNOWN_f8\t= 0xf8,\n\tM1_PMU_PERFCTR_UNKNOWN_fd\t= 0xfd,\n\tM1_PMU_PERFCTR_LAST\t\t= M1_PMU_CFG_EVENT,\n\n\t \n\tM1_PMU_CFG_COUNT_USER\t\t= BIT(8),\n\tM1_PMU_CFG_COUNT_KERNEL\t\t= BIT(9),\n};\n\n \nstatic const u16 m1_pmu_event_affinity[M1_PMU_PERFCTR_LAST + 1] = {\n\t[0 ... M1_PMU_PERFCTR_LAST]\t= ANY_BUT_0_1,\n\t[M1_PMU_PERFCTR_UNKNOWN_01]\t= BIT(7),\n\t[M1_PMU_PERFCTR_CPU_CYCLES]\t= ANY_BUT_0_1 | BIT(0),\n\t[M1_PMU_PERFCTR_INSTRUCTIONS]\t= BIT(7) | BIT(1),\n\t[M1_PMU_PERFCTR_UNKNOWN_8d]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_8e]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_8f]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_90]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_93]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_94]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_95]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_96]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_97]\t= BIT(7),\n\t[M1_PMU_PERFCTR_UNKNOWN_98]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_99]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_9a]\t= BIT(7),\n\t[M1_PMU_PERFCTR_UNKNOWN_9b]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_9c]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_9f]\t= BIT(7),\n\t[M1_PMU_PERFCTR_UNKNOWN_bf]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_c0]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_c1]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_c4]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_c5]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_c6]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_c8]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_ca]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_cb]\t= ONLY_5_6_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_f5]\t= ONLY_2_4_6,\n\t[M1_PMU_PERFCTR_UNKNOWN_f6]\t= ONLY_2_4_6,\n\t[M1_PMU_PERFCTR_UNKNOWN_f7]\t= ONLY_2_4_6,\n\t[M1_PMU_PERFCTR_UNKNOWN_f8]\t= ONLY_2_TO_7,\n\t[M1_PMU_PERFCTR_UNKNOWN_fd]\t= ONLY_2_4_6,\n};\n\nstatic const unsigned m1_pmu_perf_map[PERF_COUNT_HW_MAX] = {\n\tPERF_MAP_ALL_UNSUPPORTED,\n\t[PERF_COUNT_HW_CPU_CYCLES]\t= M1_PMU_PERFCTR_CPU_CYCLES,\n\t[PERF_COUNT_HW_INSTRUCTIONS]\t= M1_PMU_PERFCTR_INSTRUCTIONS,\n\t \n};\n\n \nstatic ssize_t m1_pmu_events_sysfs_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *page)\n{\n\tstruct perf_pmu_events_attr *pmu_attr;\n\n\tpmu_attr = container_of(attr, struct perf_pmu_events_attr, attr);\n\n\treturn sprintf(page, \"event=0x%04llx\\n\", pmu_attr->id);\n}\n\n#define M1_PMU_EVENT_ATTR(name, config)\t\t\t\t\t\\\n\tPMU_EVENT_ATTR_ID(name, m1_pmu_events_sysfs_show, config)\n\nstatic struct attribute *m1_pmu_event_attrs[] = {\n\tM1_PMU_EVENT_ATTR(cycles, M1_PMU_PERFCTR_CPU_CYCLES),\n\tM1_PMU_EVENT_ATTR(instructions, M1_PMU_PERFCTR_INSTRUCTIONS),\n\tNULL,\n};\n\nstatic const struct attribute_group m1_pmu_events_attr_group = {\n\t.name = \"events\",\n\t.attrs = m1_pmu_event_attrs,\n};\n\nPMU_FORMAT_ATTR(event, \"config:0-7\");\n\nstatic struct attribute *m1_pmu_format_attrs[] = {\n\t&format_attr_event.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group m1_pmu_format_attr_group = {\n\t.name = \"format\",\n\t.attrs = m1_pmu_format_attrs,\n};\n\n \n#define PMU_READ_COUNTER(_idx)\t\t\t\t\t\t\\\n\tcase _idx:\treturn read_sysreg_s(SYS_IMP_APL_PMC## _idx ##_EL1)\n\n#define PMU_WRITE_COUNTER(_val, _idx)\t\t\t\t\t\\\n\tcase _idx:\t\t\t\t\t\t\t\\\n\t\twrite_sysreg_s(_val, SYS_IMP_APL_PMC## _idx ##_EL1);\t\\\n\t\treturn\n\nstatic u64 m1_pmu_read_hw_counter(unsigned int index)\n{\n\tswitch (index) {\n\t\tPMU_READ_COUNTER(0);\n\t\tPMU_READ_COUNTER(1);\n\t\tPMU_READ_COUNTER(2);\n\t\tPMU_READ_COUNTER(3);\n\t\tPMU_READ_COUNTER(4);\n\t\tPMU_READ_COUNTER(5);\n\t\tPMU_READ_COUNTER(6);\n\t\tPMU_READ_COUNTER(7);\n\t\tPMU_READ_COUNTER(8);\n\t\tPMU_READ_COUNTER(9);\n\t}\n\n\tBUG();\n}\n\nstatic void m1_pmu_write_hw_counter(u64 val, unsigned int index)\n{\n\tswitch (index) {\n\t\tPMU_WRITE_COUNTER(val, 0);\n\t\tPMU_WRITE_COUNTER(val, 1);\n\t\tPMU_WRITE_COUNTER(val, 2);\n\t\tPMU_WRITE_COUNTER(val, 3);\n\t\tPMU_WRITE_COUNTER(val, 4);\n\t\tPMU_WRITE_COUNTER(val, 5);\n\t\tPMU_WRITE_COUNTER(val, 6);\n\t\tPMU_WRITE_COUNTER(val, 7);\n\t\tPMU_WRITE_COUNTER(val, 8);\n\t\tPMU_WRITE_COUNTER(val, 9);\n\t}\n\n\tBUG();\n}\n\n#define get_bit_offset(index, mask)\t(__ffs(mask) + (index))\n\nstatic void __m1_pmu_enable_counter(unsigned int index, bool en)\n{\n\tu64 val, bit;\n\n\tswitch (index) {\n\tcase 0 ... 7:\n\t\tbit = BIT(get_bit_offset(index, PMCR0_CNT_ENABLE_0_7));\n\t\tbreak;\n\tcase 8 ... 9:\n\t\tbit = BIT(get_bit_offset(index - 8, PMCR0_CNT_ENABLE_8_9));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tval = read_sysreg_s(SYS_IMP_APL_PMCR0_EL1);\n\n\tif (en)\n\t\tval |= bit;\n\telse\n\t\tval &= ~bit;\n\n\twrite_sysreg_s(val, SYS_IMP_APL_PMCR0_EL1);\n}\n\nstatic void m1_pmu_enable_counter(unsigned int index)\n{\n\t__m1_pmu_enable_counter(index, true);\n}\n\nstatic void m1_pmu_disable_counter(unsigned int index)\n{\n\t__m1_pmu_enable_counter(index, false);\n}\n\nstatic void __m1_pmu_enable_counter_interrupt(unsigned int index, bool en)\n{\n\tu64 val, bit;\n\n\tswitch (index) {\n\tcase 0 ... 7:\n\t\tbit = BIT(get_bit_offset(index, PMCR0_PMI_ENABLE_0_7));\n\t\tbreak;\n\tcase 8 ... 9:\n\t\tbit = BIT(get_bit_offset(index - 8, PMCR0_PMI_ENABLE_8_9));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tval = read_sysreg_s(SYS_IMP_APL_PMCR0_EL1);\n\n\tif (en)\n\t\tval |= bit;\n\telse\n\t\tval &= ~bit;\n\n\twrite_sysreg_s(val, SYS_IMP_APL_PMCR0_EL1);\n}\n\nstatic void m1_pmu_enable_counter_interrupt(unsigned int index)\n{\n\t__m1_pmu_enable_counter_interrupt(index, true);\n}\n\nstatic void m1_pmu_disable_counter_interrupt(unsigned int index)\n{\n\t__m1_pmu_enable_counter_interrupt(index, false);\n}\n\nstatic void m1_pmu_configure_counter(unsigned int index, u8 event,\n\t\t\t\t     bool user, bool kernel)\n{\n\tu64 val, user_bit, kernel_bit;\n\tint shift;\n\n\tswitch (index) {\n\tcase 0 ... 7:\n\t\tuser_bit = BIT(get_bit_offset(index, PMCR1_COUNT_A64_EL0_0_7));\n\t\tkernel_bit = BIT(get_bit_offset(index, PMCR1_COUNT_A64_EL1_0_7));\n\t\tbreak;\n\tcase 8 ... 9:\n\t\tuser_bit = BIT(get_bit_offset(index - 8, PMCR1_COUNT_A64_EL0_8_9));\n\t\tkernel_bit = BIT(get_bit_offset(index - 8, PMCR1_COUNT_A64_EL1_8_9));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tval = read_sysreg_s(SYS_IMP_APL_PMCR1_EL1);\n\n\tif (user)\n\t\tval |= user_bit;\n\telse\n\t\tval &= ~user_bit;\n\n\tif (kernel)\n\t\tval |= kernel_bit;\n\telse\n\t\tval &= ~kernel_bit;\n\n\twrite_sysreg_s(val, SYS_IMP_APL_PMCR1_EL1);\n\n\t \n\tswitch (index) {\n\tcase 0 ... 1:\n\t\tbreak;\n\tcase 2 ... 5:\n\t\tshift = (index - 2) * 8;\n\t\tval = read_sysreg_s(SYS_IMP_APL_PMESR0_EL1);\n\t\tval &= ~((u64)0xff << shift);\n\t\tval |= (u64)event << shift;\n\t\twrite_sysreg_s(val, SYS_IMP_APL_PMESR0_EL1);\n\t\tbreak;\n\tcase 6 ... 9:\n\t\tshift = (index - 6) * 8;\n\t\tval = read_sysreg_s(SYS_IMP_APL_PMESR1_EL1);\n\t\tval &= ~((u64)0xff << shift);\n\t\tval |= (u64)event << shift;\n\t\twrite_sysreg_s(val, SYS_IMP_APL_PMESR1_EL1);\n\t\tbreak;\n\t}\n}\n\n \nstatic void m1_pmu_enable_event(struct perf_event *event)\n{\n\tbool user, kernel;\n\tu8 evt;\n\n\tevt = event->hw.config_base & M1_PMU_CFG_EVENT;\n\tuser = event->hw.config_base & M1_PMU_CFG_COUNT_USER;\n\tkernel = event->hw.config_base & M1_PMU_CFG_COUNT_KERNEL;\n\n\tm1_pmu_disable_counter_interrupt(event->hw.idx);\n\tm1_pmu_disable_counter(event->hw.idx);\n\tisb();\n\n\tm1_pmu_configure_counter(event->hw.idx, evt, user, kernel);\n\tm1_pmu_enable_counter(event->hw.idx);\n\tm1_pmu_enable_counter_interrupt(event->hw.idx);\n\tisb();\n}\n\nstatic void m1_pmu_disable_event(struct perf_event *event)\n{\n\tm1_pmu_disable_counter_interrupt(event->hw.idx);\n\tm1_pmu_disable_counter(event->hw.idx);\n\tisb();\n}\n\nstatic irqreturn_t m1_pmu_handle_irq(struct arm_pmu *cpu_pmu)\n{\n\tstruct pmu_hw_events *cpuc = this_cpu_ptr(cpu_pmu->hw_events);\n\tstruct pt_regs *regs;\n\tu64 overflow, state;\n\tint idx;\n\n\toverflow = read_sysreg_s(SYS_IMP_APL_PMSR_EL1);\n\tif (!overflow) {\n\t\t \n\t\tstate = read_sysreg_s(SYS_IMP_APL_PMCR0_EL1);\n\t\tstate &= ~PMCR0_IACT;\n\t\twrite_sysreg_s(state, SYS_IMP_APL_PMCR0_EL1);\n\t\tisb();\n\t\treturn IRQ_NONE;\n\t}\n\n\tcpu_pmu->stop(cpu_pmu);\n\n\tregs = get_irq_regs();\n\n\tfor (idx = 0; idx < cpu_pmu->num_events; idx++) {\n\t\tstruct perf_event *event = cpuc->events[idx];\n\t\tstruct perf_sample_data data;\n\n\t\tif (!event)\n\t\t\tcontinue;\n\n\t\tarmpmu_event_update(event);\n\t\tperf_sample_data_init(&data, 0, event->hw.last_period);\n\t\tif (!armpmu_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tm1_pmu_disable_event(event);\n\t}\n\n\tcpu_pmu->start(cpu_pmu);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u64 m1_pmu_read_counter(struct perf_event *event)\n{\n\treturn m1_pmu_read_hw_counter(event->hw.idx);\n}\n\nstatic void m1_pmu_write_counter(struct perf_event *event, u64 value)\n{\n\tm1_pmu_write_hw_counter(value, event->hw.idx);\n\tisb();\n}\n\nstatic int m1_pmu_get_event_idx(struct pmu_hw_events *cpuc,\n\t\t\t\tstruct perf_event *event)\n{\n\tunsigned long evtype = event->hw.config_base & M1_PMU_CFG_EVENT;\n\tunsigned long affinity = m1_pmu_event_affinity[evtype];\n\tint idx;\n\n\t \n\tfor_each_set_bit(idx, &affinity, M1_PMU_NR_COUNTERS) {\n\t\tif (!test_and_set_bit(idx, cpuc->used_mask))\n\t\t\treturn idx;\n\t}\n\n\treturn -EAGAIN;\n}\n\nstatic void m1_pmu_clear_event_idx(struct pmu_hw_events *cpuc,\n\t\t\t\t   struct perf_event *event)\n{\n\tclear_bit(event->hw.idx, cpuc->used_mask);\n}\n\nstatic void __m1_pmu_set_mode(u8 mode)\n{\n\tu64 val;\n\n\tval = read_sysreg_s(SYS_IMP_APL_PMCR0_EL1);\n\tval &= ~(PMCR0_IMODE | PMCR0_IACT);\n\tval |= FIELD_PREP(PMCR0_IMODE, mode);\n\twrite_sysreg_s(val, SYS_IMP_APL_PMCR0_EL1);\n\tisb();\n}\n\nstatic void m1_pmu_start(struct arm_pmu *cpu_pmu)\n{\n\t__m1_pmu_set_mode(PMCR0_IMODE_FIQ);\n}\n\nstatic void m1_pmu_stop(struct arm_pmu *cpu_pmu)\n{\n\t__m1_pmu_set_mode(PMCR0_IMODE_OFF);\n}\n\nstatic int m1_pmu_map_event(struct perf_event *event)\n{\n\t \n\tevent->hw.flags |= ARMPMU_EVT_47BIT;\n\treturn armpmu_map_event(event, &m1_pmu_perf_map, NULL, M1_PMU_CFG_EVENT);\n}\n\nstatic int m2_pmu_map_event(struct perf_event *event)\n{\n\t \n\tevent->hw.flags |= ARMPMU_EVT_63BIT;\n\treturn armpmu_map_event(event, &m1_pmu_perf_map, NULL, M1_PMU_CFG_EVENT);\n}\n\nstatic void m1_pmu_reset(void *info)\n{\n\tint i;\n\n\t__m1_pmu_set_mode(PMCR0_IMODE_OFF);\n\n\tfor (i = 0; i < M1_PMU_NR_COUNTERS; i++) {\n\t\tm1_pmu_disable_counter(i);\n\t\tm1_pmu_disable_counter_interrupt(i);\n\t\tm1_pmu_write_hw_counter(0, i);\n\t}\n\n\tisb();\n}\n\nstatic int m1_pmu_set_event_filter(struct hw_perf_event *event,\n\t\t\t\t   struct perf_event_attr *attr)\n{\n\tunsigned long config_base = 0;\n\n\tif (!attr->exclude_guest)\n\t\treturn -EINVAL;\n\tif (!attr->exclude_kernel)\n\t\tconfig_base |= M1_PMU_CFG_COUNT_KERNEL;\n\tif (!attr->exclude_user)\n\t\tconfig_base |= M1_PMU_CFG_COUNT_USER;\n\n\tevent->config_base = config_base;\n\n\treturn 0;\n}\n\nstatic int m1_pmu_init(struct arm_pmu *cpu_pmu, u32 flags)\n{\n\tcpu_pmu->handle_irq\t  = m1_pmu_handle_irq;\n\tcpu_pmu->enable\t\t  = m1_pmu_enable_event;\n\tcpu_pmu->disable\t  = m1_pmu_disable_event;\n\tcpu_pmu->read_counter\t  = m1_pmu_read_counter;\n\tcpu_pmu->write_counter\t  = m1_pmu_write_counter;\n\tcpu_pmu->get_event_idx\t  = m1_pmu_get_event_idx;\n\tcpu_pmu->clear_event_idx  = m1_pmu_clear_event_idx;\n\tcpu_pmu->start\t\t  = m1_pmu_start;\n\tcpu_pmu->stop\t\t  = m1_pmu_stop;\n\n\tif (flags & ARMPMU_EVT_47BIT)\n\t\tcpu_pmu->map_event = m1_pmu_map_event;\n\telse if (flags & ARMPMU_EVT_63BIT)\n\t\tcpu_pmu->map_event = m2_pmu_map_event;\n\telse\n\t\treturn WARN_ON(-EINVAL);\n\n\tcpu_pmu->reset\t\t  = m1_pmu_reset;\n\tcpu_pmu->set_event_filter = m1_pmu_set_event_filter;\n\n\tcpu_pmu->num_events\t  = M1_PMU_NR_COUNTERS;\n\tcpu_pmu->attr_groups[ARMPMU_ATTR_GROUP_EVENTS] = &m1_pmu_events_attr_group;\n\tcpu_pmu->attr_groups[ARMPMU_ATTR_GROUP_FORMATS] = &m1_pmu_format_attr_group;\n\treturn 0;\n}\n\n \nstatic int m1_pmu_ice_init(struct arm_pmu *cpu_pmu)\n{\n\tcpu_pmu->name = \"apple_icestorm_pmu\";\n\treturn m1_pmu_init(cpu_pmu, ARMPMU_EVT_47BIT);\n}\n\nstatic int m1_pmu_fire_init(struct arm_pmu *cpu_pmu)\n{\n\tcpu_pmu->name = \"apple_firestorm_pmu\";\n\treturn m1_pmu_init(cpu_pmu, ARMPMU_EVT_47BIT);\n}\n\nstatic int m2_pmu_avalanche_init(struct arm_pmu *cpu_pmu)\n{\n\tcpu_pmu->name = \"apple_avalanche_pmu\";\n\treturn m1_pmu_init(cpu_pmu, ARMPMU_EVT_63BIT);\n}\n\nstatic int m2_pmu_blizzard_init(struct arm_pmu *cpu_pmu)\n{\n\tcpu_pmu->name = \"apple_blizzard_pmu\";\n\treturn m1_pmu_init(cpu_pmu, ARMPMU_EVT_63BIT);\n}\n\nstatic const struct of_device_id m1_pmu_of_device_ids[] = {\n\t{ .compatible = \"apple,avalanche-pmu\",\t.data = m2_pmu_avalanche_init, },\n\t{ .compatible = \"apple,blizzard-pmu\",\t.data = m2_pmu_blizzard_init, },\n\t{ .compatible = \"apple,icestorm-pmu\",\t.data = m1_pmu_ice_init, },\n\t{ .compatible = \"apple,firestorm-pmu\",\t.data = m1_pmu_fire_init, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, m1_pmu_of_device_ids);\n\nstatic int m1_pmu_device_probe(struct platform_device *pdev)\n{\n\treturn arm_pmu_device_probe(pdev, m1_pmu_of_device_ids, NULL);\n}\n\nstatic struct platform_driver m1_pmu_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t\t= \"apple-m1-cpu-pmu\",\n\t\t.of_match_table\t\t= m1_pmu_of_device_ids,\n\t\t.suppress_bind_attrs\t= true,\n\t},\n\t.probe\t\t= m1_pmu_device_probe,\n};\n\nmodule_platform_driver(m1_pmu_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}