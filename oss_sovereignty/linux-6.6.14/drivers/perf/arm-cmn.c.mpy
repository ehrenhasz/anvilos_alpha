{
  "module_name": "arm-cmn.c",
  "hash_id": "b7b0d26a5bb053c70a4f8c1e56132e9f8035df79c31efc62d382e15b2cd1f1c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/arm-cmn.c",
  "human_readable_source": "\n\n\n\n#include <linux/acpi.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/debugfs.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/perf_event.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n\n \n#define CMN_NODE_INFO\t\t\t0x0000\n#define CMN_NI_NODE_TYPE\t\tGENMASK_ULL(15, 0)\n#define CMN_NI_NODE_ID\t\t\tGENMASK_ULL(31, 16)\n#define CMN_NI_LOGICAL_ID\t\tGENMASK_ULL(47, 32)\n\n#define CMN_NODEID_DEVID(reg)\t\t((reg) & 3)\n#define CMN_NODEID_EXT_DEVID(reg)\t((reg) & 1)\n#define CMN_NODEID_PID(reg)\t\t(((reg) >> 2) & 1)\n#define CMN_NODEID_EXT_PID(reg)\t\t(((reg) >> 1) & 3)\n#define CMN_NODEID_1x1_PID(reg)\t\t(((reg) >> 2) & 7)\n#define CMN_NODEID_X(reg, bits)\t\t((reg) >> (3 + (bits)))\n#define CMN_NODEID_Y(reg, bits)\t\t(((reg) >> 3) & ((1U << (bits)) - 1))\n\n#define CMN_CHILD_INFO\t\t\t0x0080\n#define CMN_CI_CHILD_COUNT\t\tGENMASK_ULL(15, 0)\n#define CMN_CI_CHILD_PTR_OFFSET\t\tGENMASK_ULL(31, 16)\n\n#define CMN_CHILD_NODE_ADDR\t\tGENMASK(29, 0)\n#define CMN_CHILD_NODE_EXTERNAL\t\tBIT(31)\n\n#define CMN_MAX_DIMENSION\t\t12\n#define CMN_MAX_XPS\t\t\t(CMN_MAX_DIMENSION * CMN_MAX_DIMENSION)\n#define CMN_MAX_DTMS\t\t\t(CMN_MAX_XPS + (CMN_MAX_DIMENSION - 1) * 4)\n\n \n#define CMN_CFGM_PERIPH_ID_01\t\t0x0008\n#define CMN_CFGM_PID0_PART_0\t\tGENMASK_ULL(7, 0)\n#define CMN_CFGM_PID1_PART_1\t\tGENMASK_ULL(35, 32)\n#define CMN_CFGM_PERIPH_ID_23\t\t0x0010\n#define CMN_CFGM_PID2_REVISION\t\tGENMASK_ULL(7, 4)\n\n#define CMN_CFGM_INFO_GLOBAL\t\t0x900\n#define CMN_INFO_MULTIPLE_DTM_EN\tBIT_ULL(63)\n#define CMN_INFO_RSP_VC_NUM\t\tGENMASK_ULL(53, 52)\n#define CMN_INFO_DAT_VC_NUM\t\tGENMASK_ULL(51, 50)\n\n#define CMN_CFGM_INFO_GLOBAL_1\t\t0x908\n#define CMN_INFO_SNP_VC_NUM\t\tGENMASK_ULL(3, 2)\n#define CMN_INFO_REQ_VC_NUM\t\tGENMASK_ULL(1, 0)\n\n \n#define CMN_MXP__CONNECT_INFO(p)\t(0x0008 + 8 * (p))\n#define CMN__CONNECT_INFO_DEVICE_TYPE\tGENMASK_ULL(4, 0)\n\n#define CMN_MAX_PORTS\t\t\t6\n#define CI700_CONNECT_INFO_P2_5_OFFSET\t0x10\n\n \n#define CMN_PMU_OFFSET\t\t\t0x2000\n\n \n#define CMN_PMU_EVENT_SEL\t\t0x000\n#define CMN__PMU_CBUSY_SNTHROTTLE_SEL\tGENMASK_ULL(44, 42)\n#define CMN__PMU_SN_HOME_SEL\t\tGENMASK_ULL(40, 39)\n#define CMN__PMU_HBT_LBT_SEL\t\tGENMASK_ULL(38, 37)\n#define CMN__PMU_CLASS_OCCUP_ID\t\tGENMASK_ULL(36, 35)\n \n#define CMN__PMU_OCCUP1_ID\t\tGENMASK_ULL(34, 32)\n\n \n#define CMN_HNP_PMU_EVENT_SEL\t\t0x008\n\n \n#define CMN_DTM_WPn(n)\t\t\t(0x1A0 + (n) * 0x18)\n#define CMN_DTM_WPn_CONFIG(n)\t\t(CMN_DTM_WPn(n) + 0x00)\n#define CMN_DTM_WPn_CONFIG_WP_CHN_NUM\tGENMASK_ULL(20, 19)\n#define CMN_DTM_WPn_CONFIG_WP_DEV_SEL2\tGENMASK_ULL(18, 17)\n#define CMN_DTM_WPn_CONFIG_WP_COMBINE\tBIT(9)\n#define CMN_DTM_WPn_CONFIG_WP_EXCLUSIVE\tBIT(8)\n#define CMN600_WPn_CONFIG_WP_COMBINE\tBIT(6)\n#define CMN600_WPn_CONFIG_WP_EXCLUSIVE\tBIT(5)\n#define CMN_DTM_WPn_CONFIG_WP_GRP\tGENMASK_ULL(5, 4)\n#define CMN_DTM_WPn_CONFIG_WP_CHN_SEL\tGENMASK_ULL(3, 1)\n#define CMN_DTM_WPn_CONFIG_WP_DEV_SEL\tBIT(0)\n#define CMN_DTM_WPn_VAL(n)\t\t(CMN_DTM_WPn(n) + 0x08)\n#define CMN_DTM_WPn_MASK(n)\t\t(CMN_DTM_WPn(n) + 0x10)\n\n#define CMN_DTM_PMU_CONFIG\t\t0x210\n#define CMN__PMEVCNT0_INPUT_SEL\t\tGENMASK_ULL(37, 32)\n#define CMN__PMEVCNT0_INPUT_SEL_WP\t0x00\n#define CMN__PMEVCNT0_INPUT_SEL_XP\t0x04\n#define CMN__PMEVCNT0_INPUT_SEL_DEV\t0x10\n#define CMN__PMEVCNT0_GLOBAL_NUM\tGENMASK_ULL(18, 16)\n#define CMN__PMEVCNTn_GLOBAL_NUM_SHIFT(n)\t((n) * 4)\n#define CMN__PMEVCNT_PAIRED(n)\t\tBIT(4 + (n))\n#define CMN__PMEVCNT23_COMBINED\t\tBIT(2)\n#define CMN__PMEVCNT01_COMBINED\t\tBIT(1)\n#define CMN_DTM_PMU_CONFIG_PMU_EN\tBIT(0)\n\n#define CMN_DTM_PMEVCNT\t\t\t0x220\n\n#define CMN_DTM_PMEVCNTSR\t\t0x240\n\n#define CMN650_DTM_UNIT_INFO\t\t0x0910\n#define CMN_DTM_UNIT_INFO\t\t0x0960\n#define CMN_DTM_UNIT_INFO_DTC_DOMAIN\tGENMASK_ULL(1, 0)\n\n#define CMN_DTM_NUM_COUNTERS\t\t4\n \n#define CMN_DTM_OFFSET(n)\t\t((n) * 0x200)\n\n \n#define CMN_DT_DTC_CTL\t\t\t0x0a00\n#define CMN_DT_DTC_CTL_DT_EN\t\tBIT(0)\n\n \n#define _CMN_DT_CNT_REG(n)\t\t((((n) / 2) * 4 + (n) % 2) * 4)\n#define CMN_DT_PMEVCNT(n)\t\t(CMN_PMU_OFFSET + _CMN_DT_CNT_REG(n))\n#define CMN_DT_PMCCNTR\t\t\t(CMN_PMU_OFFSET + 0x40)\n\n#define CMN_DT_PMEVCNTSR(n)\t\t(CMN_PMU_OFFSET + 0x50 + _CMN_DT_CNT_REG(n))\n#define CMN_DT_PMCCNTRSR\t\t(CMN_PMU_OFFSET + 0x90)\n\n#define CMN_DT_PMCR\t\t\t(CMN_PMU_OFFSET + 0x100)\n#define CMN_DT_PMCR_PMU_EN\t\tBIT(0)\n#define CMN_DT_PMCR_CNTR_RST\t\tBIT(5)\n#define CMN_DT_PMCR_OVFL_INTR_EN\tBIT(6)\n\n#define CMN_DT_PMOVSR\t\t\t(CMN_PMU_OFFSET + 0x118)\n#define CMN_DT_PMOVSR_CLR\t\t(CMN_PMU_OFFSET + 0x120)\n\n#define CMN_DT_PMSSR\t\t\t(CMN_PMU_OFFSET + 0x128)\n#define CMN_DT_PMSSR_SS_STATUS(n)\tBIT(n)\n\n#define CMN_DT_PMSRR\t\t\t(CMN_PMU_OFFSET + 0x130)\n#define CMN_DT_PMSRR_SS_REQ\t\tBIT(0)\n\n#define CMN_DT_NUM_COUNTERS\t\t8\n#define CMN_MAX_DTCS\t\t\t4\n\n \n#define CMN_COUNTER_INIT\t\t0x80000000\n \n#define CMN_CC_INIT\t\t\t0x8000000000ULL\n\n\n \n#define CMN_CONFIG_TYPE\t\t\tGENMASK_ULL(15, 0)\n#define CMN_CONFIG_EVENTID\t\tGENMASK_ULL(26, 16)\n#define CMN_CONFIG_OCCUPID\t\tGENMASK_ULL(30, 27)\n#define CMN_CONFIG_BYNODEID\t\tBIT_ULL(31)\n#define CMN_CONFIG_NODEID\t\tGENMASK_ULL(47, 32)\n\n#define CMN_EVENT_TYPE(event)\t\tFIELD_GET(CMN_CONFIG_TYPE, (event)->attr.config)\n#define CMN_EVENT_EVENTID(event)\tFIELD_GET(CMN_CONFIG_EVENTID, (event)->attr.config)\n#define CMN_EVENT_OCCUPID(event)\tFIELD_GET(CMN_CONFIG_OCCUPID, (event)->attr.config)\n#define CMN_EVENT_BYNODEID(event)\tFIELD_GET(CMN_CONFIG_BYNODEID, (event)->attr.config)\n#define CMN_EVENT_NODEID(event)\t\tFIELD_GET(CMN_CONFIG_NODEID, (event)->attr.config)\n\n#define CMN_CONFIG_WP_COMBINE\t\tGENMASK_ULL(30, 27)\n#define CMN_CONFIG_WP_DEV_SEL\t\tGENMASK_ULL(50, 48)\n#define CMN_CONFIG_WP_CHN_SEL\t\tGENMASK_ULL(55, 51)\n \n#define CMN_CONFIG_WP_GRP\t\tBIT_ULL(56)\n#define CMN_CONFIG_WP_EXCLUSIVE\t\tBIT_ULL(57)\n#define CMN_CONFIG1_WP_VAL\t\tGENMASK_ULL(63, 0)\n#define CMN_CONFIG2_WP_MASK\t\tGENMASK_ULL(63, 0)\n\n#define CMN_EVENT_WP_COMBINE(event)\tFIELD_GET(CMN_CONFIG_WP_COMBINE, (event)->attr.config)\n#define CMN_EVENT_WP_DEV_SEL(event)\tFIELD_GET(CMN_CONFIG_WP_DEV_SEL, (event)->attr.config)\n#define CMN_EVENT_WP_CHN_SEL(event)\tFIELD_GET(CMN_CONFIG_WP_CHN_SEL, (event)->attr.config)\n#define CMN_EVENT_WP_GRP(event)\t\tFIELD_GET(CMN_CONFIG_WP_GRP, (event)->attr.config)\n#define CMN_EVENT_WP_EXCLUSIVE(event)\tFIELD_GET(CMN_CONFIG_WP_EXCLUSIVE, (event)->attr.config)\n#define CMN_EVENT_WP_VAL(event)\t\tFIELD_GET(CMN_CONFIG1_WP_VAL, (event)->attr.config1)\n#define CMN_EVENT_WP_MASK(event)\tFIELD_GET(CMN_CONFIG2_WP_MASK, (event)->attr.config2)\n\n \n#define CMN_WP_UP\t\t\t0\n#define CMN_WP_DOWN\t\t\t2\n\n\n \nenum cmn_model {\n\tCMN600 = 1,\n\tCMN650 = 2,\n\tCMN700 = 4,\n\tCI700 = 8,\n\t \n\tCMN_ANY = -1,\n\tNOT_CMN600 = -2,\n\tCMN_650ON = CMN650 | CMN700,\n};\n\n \nenum cmn_part {\n\tPART_CMN600 = 0x434,\n\tPART_CMN650 = 0x436,\n\tPART_CMN700 = 0x43c,\n\tPART_CI700 = 0x43a,\n};\n\n \nenum cmn_revision {\n\tREV_CMN600_R1P0,\n\tREV_CMN600_R1P1,\n\tREV_CMN600_R1P2,\n\tREV_CMN600_R1P3,\n\tREV_CMN600_R2P0,\n\tREV_CMN600_R3P0,\n\tREV_CMN600_R3P1,\n\tREV_CMN650_R0P0 = 0,\n\tREV_CMN650_R1P0,\n\tREV_CMN650_R1P1,\n\tREV_CMN650_R2P0,\n\tREV_CMN650_R1P2,\n\tREV_CMN700_R0P0 = 0,\n\tREV_CMN700_R1P0,\n\tREV_CMN700_R2P0,\n\tREV_CMN700_R3P0,\n\tREV_CI700_R0P0 = 0,\n\tREV_CI700_R1P0,\n\tREV_CI700_R2P0,\n};\n\nenum cmn_node_type {\n\tCMN_TYPE_INVALID,\n\tCMN_TYPE_DVM,\n\tCMN_TYPE_CFG,\n\tCMN_TYPE_DTC,\n\tCMN_TYPE_HNI,\n\tCMN_TYPE_HNF,\n\tCMN_TYPE_XP,\n\tCMN_TYPE_SBSX,\n\tCMN_TYPE_MPAM_S,\n\tCMN_TYPE_MPAM_NS,\n\tCMN_TYPE_RNI,\n\tCMN_TYPE_RND = 0xd,\n\tCMN_TYPE_RNSAM = 0xf,\n\tCMN_TYPE_MTSX,\n\tCMN_TYPE_HNP,\n\tCMN_TYPE_CXRA = 0x100,\n\tCMN_TYPE_CXHA,\n\tCMN_TYPE_CXLA,\n\tCMN_TYPE_CCRA,\n\tCMN_TYPE_CCHA,\n\tCMN_TYPE_CCLA,\n\tCMN_TYPE_CCLA_RNI,\n\tCMN_TYPE_HNS = 0x200,\n\tCMN_TYPE_HNS_MPAM_S,\n\tCMN_TYPE_HNS_MPAM_NS,\n\t \n\tCMN_TYPE_WP = 0x7770\n};\n\nenum cmn_filter_select {\n\tSEL_NONE = -1,\n\tSEL_OCCUP1ID,\n\tSEL_CLASS_OCCUP_ID,\n\tSEL_CBUSY_SNTHROTTLE_SEL,\n\tSEL_HBT_LBT_SEL,\n\tSEL_SN_HOME_SEL,\n\tSEL_MAX\n};\n\nstruct arm_cmn_node {\n\tvoid __iomem *pmu_base;\n\tu16 id, logid;\n\tenum cmn_node_type type;\n\n\tint dtm;\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\tu8 val : 4;\n\t\t\tu8 count : 4;\n\t\t} occupid[SEL_MAX];\n\t\t \n\t\tu8 dtc;\n\t};\n\tunion {\n\t\tu8 event[4];\n\t\t__le32 event_sel;\n\t\tu16 event_w[4];\n\t\t__le64 event_sel_w;\n\t};\n};\n\nstruct arm_cmn_dtm {\n\tvoid __iomem *base;\n\tu32 pmu_config_low;\n\tunion {\n\t\tu8 input_sel[4];\n\t\t__le32 pmu_config_high;\n\t};\n\ts8 wp_event[4];\n};\n\nstruct arm_cmn_dtc {\n\tvoid __iomem *base;\n\tint irq;\n\tint irq_friend;\n\tbool cc_active;\n\n\tstruct perf_event *counters[CMN_DT_NUM_COUNTERS];\n\tstruct perf_event *cycles;\n};\n\n#define CMN_STATE_DISABLED\tBIT(0)\n#define CMN_STATE_TXN\t\tBIT(1)\n\nstruct arm_cmn {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tunsigned int state;\n\n\tenum cmn_revision rev;\n\tenum cmn_part part;\n\tu8 mesh_x;\n\tu8 mesh_y;\n\tu16 num_xps;\n\tu16 num_dns;\n\tbool multi_dtm;\n\tu8 ports_used;\n\tstruct {\n\t\tunsigned int rsp_vc_num : 2;\n\t\tunsigned int dat_vc_num : 2;\n\t\tunsigned int snp_vc_num : 2;\n\t\tunsigned int req_vc_num : 2;\n\t};\n\n\tstruct arm_cmn_node *xps;\n\tstruct arm_cmn_node *dns;\n\n\tstruct arm_cmn_dtm *dtms;\n\tstruct arm_cmn_dtc *dtc;\n\tunsigned int num_dtcs;\n\n\tint cpu;\n\tstruct hlist_node cpuhp_node;\n\n\tstruct pmu pmu;\n\tstruct dentry *debug;\n};\n\n#define to_cmn(p)\tcontainer_of(p, struct arm_cmn, pmu)\n\nstatic int arm_cmn_hp_state;\n\nstruct arm_cmn_nodeid {\n\tu8 x;\n\tu8 y;\n\tu8 port;\n\tu8 dev;\n};\n\nstatic int arm_cmn_xyidbits(const struct arm_cmn *cmn)\n{\n\treturn fls((cmn->mesh_x - 1) | (cmn->mesh_y - 1) | 2);\n}\n\nstatic struct arm_cmn_nodeid arm_cmn_nid(const struct arm_cmn *cmn, u16 id)\n{\n\tstruct arm_cmn_nodeid nid;\n\n\tif (cmn->num_xps == 1) {\n\t\tnid.x = 0;\n\t\tnid.y = 0;\n\t\tnid.port = CMN_NODEID_1x1_PID(id);\n\t\tnid.dev = CMN_NODEID_DEVID(id);\n\t} else {\n\t\tint bits = arm_cmn_xyidbits(cmn);\n\n\t\tnid.x = CMN_NODEID_X(id, bits);\n\t\tnid.y = CMN_NODEID_Y(id, bits);\n\t\tif (cmn->ports_used & 0xc) {\n\t\t\tnid.port = CMN_NODEID_EXT_PID(id);\n\t\t\tnid.dev = CMN_NODEID_EXT_DEVID(id);\n\t\t} else {\n\t\t\tnid.port = CMN_NODEID_PID(id);\n\t\t\tnid.dev = CMN_NODEID_DEVID(id);\n\t\t}\n\t}\n\treturn nid;\n}\n\nstatic struct arm_cmn_node *arm_cmn_node_to_xp(const struct arm_cmn *cmn,\n\t\t\t\t\t       const struct arm_cmn_node *dn)\n{\n\tstruct arm_cmn_nodeid nid = arm_cmn_nid(cmn, dn->id);\n\tint xp_idx = cmn->mesh_x * nid.y + nid.x;\n\n\treturn cmn->xps + xp_idx;\n}\nstatic struct arm_cmn_node *arm_cmn_node(const struct arm_cmn *cmn,\n\t\t\t\t\t enum cmn_node_type type)\n{\n\tstruct arm_cmn_node *dn;\n\n\tfor (dn = cmn->dns; dn->type; dn++)\n\t\tif (dn->type == type)\n\t\t\treturn dn;\n\treturn NULL;\n}\n\nstatic enum cmn_model arm_cmn_model(const struct arm_cmn *cmn)\n{\n\tswitch (cmn->part) {\n\tcase PART_CMN600:\n\t\treturn CMN600;\n\tcase PART_CMN650:\n\t\treturn CMN650;\n\tcase PART_CMN700:\n\t\treturn CMN700;\n\tcase PART_CI700:\n\t\treturn CI700;\n\tdefault:\n\t\treturn 0;\n\t};\n}\n\nstatic u32 arm_cmn_device_connect_info(const struct arm_cmn *cmn,\n\t\t\t\t       const struct arm_cmn_node *xp, int port)\n{\n\tint offset = CMN_MXP__CONNECT_INFO(port);\n\n\tif (port >= 2) {\n\t\tif (cmn->part == PART_CMN600 || cmn->part == PART_CMN650)\n\t\t\treturn 0;\n\t\t \n\t\tif (cmn->part == PART_CI700)\n\t\t\toffset += CI700_CONNECT_INFO_P2_5_OFFSET;\n\t}\n\n\treturn readl_relaxed(xp->pmu_base - CMN_PMU_OFFSET + offset);\n}\n\nstatic struct dentry *arm_cmn_debugfs;\n\n#ifdef CONFIG_DEBUG_FS\nstatic const char *arm_cmn_device_type(u8 type)\n{\n\tswitch(FIELD_GET(CMN__CONNECT_INFO_DEVICE_TYPE, type)) {\n\t\tcase 0x00: return \"        |\";\n\t\tcase 0x01: return \"  RN-I  |\";\n\t\tcase 0x02: return \"  RN-D  |\";\n\t\tcase 0x04: return \" RN-F_B |\";\n\t\tcase 0x05: return \"RN-F_B_E|\";\n\t\tcase 0x06: return \" RN-F_A |\";\n\t\tcase 0x07: return \"RN-F_A_E|\";\n\t\tcase 0x08: return \"  HN-T  |\";\n\t\tcase 0x09: return \"  HN-I  |\";\n\t\tcase 0x0a: return \"  HN-D  |\";\n\t\tcase 0x0b: return \"  HN-P  |\";\n\t\tcase 0x0c: return \"  SN-F  |\";\n\t\tcase 0x0d: return \"  SBSX  |\";\n\t\tcase 0x0e: return \"  HN-F  |\";\n\t\tcase 0x0f: return \" SN-F_E |\";\n\t\tcase 0x10: return \" SN-F_D |\";\n\t\tcase 0x11: return \"  CXHA  |\";\n\t\tcase 0x12: return \"  CXRA  |\";\n\t\tcase 0x13: return \"  CXRH  |\";\n\t\tcase 0x14: return \" RN-F_D |\";\n\t\tcase 0x15: return \"RN-F_D_E|\";\n\t\tcase 0x16: return \" RN-F_C |\";\n\t\tcase 0x17: return \"RN-F_C_E|\";\n\t\tcase 0x18: return \" RN-F_E |\";\n\t\tcase 0x19: return \"RN-F_E_E|\";\n\t\tcase 0x1c: return \"  MTSX  |\";\n\t\tcase 0x1d: return \"  HN-V  |\";\n\t\tcase 0x1e: return \"  CCG   |\";\n\t\tdefault:   return \"  ????  |\";\n\t}\n}\n\nstatic void arm_cmn_show_logid(struct seq_file *s, int x, int y, int p, int d)\n{\n\tstruct arm_cmn *cmn = s->private;\n\tstruct arm_cmn_node *dn;\n\n\tfor (dn = cmn->dns; dn->type; dn++) {\n\t\tstruct arm_cmn_nodeid nid = arm_cmn_nid(cmn, dn->id);\n\n\t\tif (dn->type == CMN_TYPE_XP)\n\t\t\tcontinue;\n\t\t \n\t\tif (dn->type < CMN_TYPE_HNI)\n\t\t\tcontinue;\n\n\t\tif (nid.x != x || nid.y != y || nid.port != p || nid.dev != d)\n\t\t\tcontinue;\n\n\t\tseq_printf(s, \"   #%-2d  |\", dn->logid);\n\t\treturn;\n\t}\n\tseq_puts(s, \"        |\");\n}\n\nstatic int arm_cmn_map_show(struct seq_file *s, void *data)\n{\n\tstruct arm_cmn *cmn = s->private;\n\tint x, y, p, pmax = fls(cmn->ports_used);\n\n\tseq_puts(s, \"     X\");\n\tfor (x = 0; x < cmn->mesh_x; x++)\n\t\tseq_printf(s, \"    %d    \", x);\n\tseq_puts(s, \"\\nY P D+\");\n\ty = cmn->mesh_y;\n\twhile (y--) {\n\t\tint xp_base = cmn->mesh_x * y;\n\t\tu8 port[CMN_MAX_PORTS][CMN_MAX_DIMENSION];\n\n\t\tfor (x = 0; x < cmn->mesh_x; x++)\n\t\t\tseq_puts(s, \"--------+\");\n\n\t\tseq_printf(s, \"\\n%d    |\", y);\n\t\tfor (x = 0; x < cmn->mesh_x; x++) {\n\t\t\tstruct arm_cmn_node *xp = cmn->xps + xp_base + x;\n\n\t\t\tfor (p = 0; p < CMN_MAX_PORTS; p++)\n\t\t\t\tport[p][x] = arm_cmn_device_connect_info(cmn, xp, p);\n\t\t\tseq_printf(s, \" XP #%-2d |\", xp_base + x);\n\t\t}\n\n\t\tseq_puts(s, \"\\n     |\");\n\t\tfor (x = 0; x < cmn->mesh_x; x++) {\n\t\t\tu8 dtc = cmn->xps[xp_base + x].dtc;\n\n\t\t\tif (dtc & (dtc - 1))\n\t\t\t\tseq_puts(s, \" DTC ?? |\");\n\t\t\telse\n\t\t\t\tseq_printf(s, \" DTC %ld  |\", __ffs(dtc));\n\t\t}\n\t\tseq_puts(s, \"\\n     |\");\n\t\tfor (x = 0; x < cmn->mesh_x; x++)\n\t\t\tseq_puts(s, \"........|\");\n\n\t\tfor (p = 0; p < pmax; p++) {\n\t\t\tseq_printf(s, \"\\n  %d  |\", p);\n\t\t\tfor (x = 0; x < cmn->mesh_x; x++)\n\t\t\t\tseq_puts(s, arm_cmn_device_type(port[p][x]));\n\t\t\tseq_puts(s, \"\\n    0|\");\n\t\t\tfor (x = 0; x < cmn->mesh_x; x++)\n\t\t\t\tarm_cmn_show_logid(s, x, y, p, 0);\n\t\t\tseq_puts(s, \"\\n    1|\");\n\t\t\tfor (x = 0; x < cmn->mesh_x; x++)\n\t\t\t\tarm_cmn_show_logid(s, x, y, p, 1);\n\t\t}\n\t\tseq_puts(s, \"\\n-----+\");\n\t}\n\tfor (x = 0; x < cmn->mesh_x; x++)\n\t\tseq_puts(s, \"--------+\");\n\tseq_puts(s, \"\\n\");\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(arm_cmn_map);\n\nstatic void arm_cmn_debugfs_init(struct arm_cmn *cmn, int id)\n{\n\tconst char *name  = \"map\";\n\n\tif (id > 0)\n\t\tname = devm_kasprintf(cmn->dev, GFP_KERNEL, \"map_%d\", id);\n\tif (!name)\n\t\treturn;\n\n\tcmn->debug = debugfs_create_file(name, 0444, arm_cmn_debugfs, cmn, &arm_cmn_map_fops);\n}\n#else\nstatic void arm_cmn_debugfs_init(struct arm_cmn *cmn, int id) {}\n#endif\n\nstruct arm_cmn_hw_event {\n\tstruct arm_cmn_node *dn;\n\tu64 dtm_idx[4];\n\tunsigned int dtc_idx;\n\tu8 dtcs_used;\n\tu8 num_dns;\n\tu8 dtm_offset;\n\tbool wide_sel;\n\tenum cmn_filter_select filter_sel;\n};\n\n#define for_each_hw_dn(hw, dn, i) \\\n\tfor (i = 0, dn = hw->dn; i < hw->num_dns; i++, dn++)\n\nstatic struct arm_cmn_hw_event *to_cmn_hw(struct perf_event *event)\n{\n\tBUILD_BUG_ON(sizeof(struct arm_cmn_hw_event) > offsetof(struct hw_perf_event, target));\n\treturn (struct arm_cmn_hw_event *)&event->hw;\n}\n\nstatic void arm_cmn_set_index(u64 x[], unsigned int pos, unsigned int val)\n{\n\tx[pos / 32] |= (u64)val << ((pos % 32) * 2);\n}\n\nstatic unsigned int arm_cmn_get_index(u64 x[], unsigned int pos)\n{\n\treturn (x[pos / 32] >> ((pos % 32) * 2)) & 3;\n}\n\nstruct arm_cmn_event_attr {\n\tstruct device_attribute attr;\n\tenum cmn_model model;\n\tenum cmn_node_type type;\n\tenum cmn_filter_select fsel;\n\tu16 eventid;\n\tu8 occupid;\n};\n\nstruct arm_cmn_format_attr {\n\tstruct device_attribute attr;\n\tu64 field;\n\tint config;\n};\n\n#define _CMN_EVENT_ATTR(_model, _name, _type, _eventid, _occupid, _fsel)\\\n\t(&((struct arm_cmn_event_attr[]) {{\t\t\t\t\\\n\t\t.attr = __ATTR(_name, 0444, arm_cmn_event_show, NULL),\t\\\n\t\t.model = _model,\t\t\t\t\t\\\n\t\t.type = _type,\t\t\t\t\t\t\\\n\t\t.eventid = _eventid,\t\t\t\t\t\\\n\t\t.occupid = _occupid,\t\t\t\t\t\\\n\t\t.fsel = _fsel,\t\t\t\t\t\t\\\n\t}})[0].attr.attr)\n#define CMN_EVENT_ATTR(_model, _name, _type, _eventid)\t\t\t\\\n\t_CMN_EVENT_ATTR(_model, _name, _type, _eventid, 0, SEL_NONE)\n\nstatic ssize_t arm_cmn_event_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct arm_cmn_event_attr *eattr;\n\n\teattr = container_of(attr, typeof(*eattr), attr);\n\n\tif (eattr->type == CMN_TYPE_DTC)\n\t\treturn sysfs_emit(buf, \"type=0x%x\\n\", eattr->type);\n\n\tif (eattr->type == CMN_TYPE_WP)\n\t\treturn sysfs_emit(buf,\n\t\t\t\t  \"type=0x%x,eventid=0x%x,wp_dev_sel=?,wp_chn_sel=?,wp_grp=?,wp_val=?,wp_mask=?\\n\",\n\t\t\t\t  eattr->type, eattr->eventid);\n\n\tif (eattr->fsel > SEL_NONE)\n\t\treturn sysfs_emit(buf, \"type=0x%x,eventid=0x%x,occupid=0x%x\\n\",\n\t\t\t\t  eattr->type, eattr->eventid, eattr->occupid);\n\n\treturn sysfs_emit(buf, \"type=0x%x,eventid=0x%x\\n\", eattr->type,\n\t\t\t  eattr->eventid);\n}\n\nstatic umode_t arm_cmn_event_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *attr,\n\t\t\t\t\t     int unused)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct arm_cmn *cmn = to_cmn(dev_get_drvdata(dev));\n\tstruct arm_cmn_event_attr *eattr;\n\tenum cmn_node_type type;\n\tu16 eventid;\n\n\teattr = container_of(attr, typeof(*eattr), attr.attr);\n\n\tif (!(eattr->model & arm_cmn_model(cmn)))\n\t\treturn 0;\n\n\ttype = eattr->type;\n\teventid = eattr->eventid;\n\n\t \n\tif (type == CMN_TYPE_WP)\n\t\treturn attr->mode;\n\n\t \n\tif (type == CMN_TYPE_XP) {\n\t\tunsigned int intf = (eventid >> 2) & 7;\n\t\tunsigned int chan = eventid >> 5;\n\n\t\tif ((intf & 4) && !(cmn->ports_used & BIT(intf & 3)))\n\t\t\treturn 0;\n\n\t\tif (chan == 4 && cmn->part == PART_CMN600)\n\t\t\treturn 0;\n\n\t\tif ((chan == 5 && cmn->rsp_vc_num < 2) ||\n\t\t    (chan == 6 && cmn->dat_vc_num < 2) ||\n\t\t    (chan == 7 && cmn->snp_vc_num < 2) ||\n\t\t    (chan == 8 && cmn->req_vc_num < 2))\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (cmn->part == PART_CMN600) {\n\t\tif (cmn->rev < REV_CMN600_R1P3) {\n\t\t\tif (type == CMN_TYPE_CXRA && eventid > 0x10)\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (cmn->rev < REV_CMN600_R1P2) {\n\t\t\tif (type == CMN_TYPE_HNF && eventid == 0x1b)\n\t\t\t\treturn 0;\n\t\t\tif (type == CMN_TYPE_CXRA || type == CMN_TYPE_CXHA)\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (cmn->part == PART_CMN650) {\n\t\tif (cmn->rev < REV_CMN650_R2P0 || cmn->rev == REV_CMN650_R1P2) {\n\t\t\tif (type == CMN_TYPE_HNF && eventid > 0x22)\n\t\t\t\treturn 0;\n\t\t\tif (type == CMN_TYPE_SBSX && eventid == 0x17)\n\t\t\t\treturn 0;\n\t\t\tif (type == CMN_TYPE_RNI && eventid > 0x10)\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (cmn->part == PART_CMN700) {\n\t\tif (cmn->rev < REV_CMN700_R2P0) {\n\t\t\tif (type == CMN_TYPE_HNF && eventid > 0x2c)\n\t\t\t\treturn 0;\n\t\t\tif (type == CMN_TYPE_CCHA && eventid > 0x74)\n\t\t\t\treturn 0;\n\t\t\tif (type == CMN_TYPE_CCLA && eventid > 0x27)\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (cmn->rev < REV_CMN700_R1P0) {\n\t\t\tif (type == CMN_TYPE_HNF && eventid > 0x2b)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!arm_cmn_node(cmn, type))\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\n#define _CMN_EVENT_DVM(_model, _name, _event, _occup, _fsel)\t\\\n\t_CMN_EVENT_ATTR(_model, dn_##_name, CMN_TYPE_DVM, _event, _occup, _fsel)\n#define CMN_EVENT_DTC(_name)\t\t\t\t\t\\\n\tCMN_EVENT_ATTR(CMN_ANY, dtc_##_name, CMN_TYPE_DTC, 0)\n#define CMN_EVENT_HNF(_model, _name, _event)\t\t\t\\\n\tCMN_EVENT_ATTR(_model, hnf_##_name, CMN_TYPE_HNF, _event)\n#define CMN_EVENT_HNI(_name, _event)\t\t\t\t\\\n\tCMN_EVENT_ATTR(CMN_ANY, hni_##_name, CMN_TYPE_HNI, _event)\n#define CMN_EVENT_HNP(_name, _event)\t\t\t\t\\\n\tCMN_EVENT_ATTR(CMN_ANY, hnp_##_name, CMN_TYPE_HNP, _event)\n#define __CMN_EVENT_XP(_name, _event)\t\t\t\t\\\n\tCMN_EVENT_ATTR(CMN_ANY, mxp_##_name, CMN_TYPE_XP, _event)\n#define CMN_EVENT_SBSX(_model, _name, _event)\t\t\t\\\n\tCMN_EVENT_ATTR(_model, sbsx_##_name, CMN_TYPE_SBSX, _event)\n#define CMN_EVENT_RNID(_model, _name, _event)\t\t\t\\\n\tCMN_EVENT_ATTR(_model, rnid_##_name, CMN_TYPE_RNI, _event)\n#define CMN_EVENT_MTSX(_name, _event)\t\t\t\t\\\n\tCMN_EVENT_ATTR(CMN_ANY, mtsx_##_name, CMN_TYPE_MTSX, _event)\n#define CMN_EVENT_CXRA(_model, _name, _event)\t\t\t\t\\\n\tCMN_EVENT_ATTR(_model, cxra_##_name, CMN_TYPE_CXRA, _event)\n#define CMN_EVENT_CXHA(_name, _event)\t\t\t\t\\\n\tCMN_EVENT_ATTR(CMN_ANY, cxha_##_name, CMN_TYPE_CXHA, _event)\n#define CMN_EVENT_CCRA(_name, _event)\t\t\t\t\\\n\tCMN_EVENT_ATTR(CMN_ANY, ccra_##_name, CMN_TYPE_CCRA, _event)\n#define CMN_EVENT_CCHA(_name, _event)\t\t\t\t\\\n\tCMN_EVENT_ATTR(CMN_ANY, ccha_##_name, CMN_TYPE_CCHA, _event)\n#define CMN_EVENT_CCLA(_name, _event)\t\t\t\t\\\n\tCMN_EVENT_ATTR(CMN_ANY, ccla_##_name, CMN_TYPE_CCLA, _event)\n#define CMN_EVENT_CCLA_RNI(_name, _event)\t\t\t\t\\\n\tCMN_EVENT_ATTR(CMN_ANY, ccla_rni_##_name, CMN_TYPE_CCLA_RNI, _event)\n#define CMN_EVENT_HNS(_name, _event)\t\t\t\t\\\n\tCMN_EVENT_ATTR(CMN_ANY, hns_##_name, CMN_TYPE_HNS, _event)\n\n#define CMN_EVENT_DVM(_model, _name, _event)\t\t\t\\\n\t_CMN_EVENT_DVM(_model, _name, _event, 0, SEL_NONE)\n#define CMN_EVENT_DVM_OCC(_model, _name, _event)\t\t\t\\\n\t_CMN_EVENT_DVM(_model, _name##_all, _event, 0, SEL_OCCUP1ID),\t\\\n\t_CMN_EVENT_DVM(_model, _name##_dvmop, _event, 1, SEL_OCCUP1ID),\t\\\n\t_CMN_EVENT_DVM(_model, _name##_dvmsync, _event, 2, SEL_OCCUP1ID)\n\n#define CMN_EVENT_HN_OCC(_model, _name, _type, _event)\t\t\\\n\t_CMN_EVENT_ATTR(_model, _name##_all, _type, _event, 0, SEL_OCCUP1ID), \\\n\t_CMN_EVENT_ATTR(_model, _name##_read, _type, _event, 1, SEL_OCCUP1ID), \\\n\t_CMN_EVENT_ATTR(_model, _name##_write, _type, _event, 2, SEL_OCCUP1ID), \\\n\t_CMN_EVENT_ATTR(_model, _name##_atomic, _type, _event, 3, SEL_OCCUP1ID), \\\n\t_CMN_EVENT_ATTR(_model, _name##_stash, _type, _event, 4, SEL_OCCUP1ID)\n#define CMN_EVENT_HN_CLS(_model, _name, _type, _event)\t\t\t\\\n\t_CMN_EVENT_ATTR(_model, _name##_class0, _type, _event, 0, SEL_CLASS_OCCUP_ID), \\\n\t_CMN_EVENT_ATTR(_model, _name##_class1, _type, _event, 1, SEL_CLASS_OCCUP_ID), \\\n\t_CMN_EVENT_ATTR(_model, _name##_class2, _type, _event, 2, SEL_CLASS_OCCUP_ID), \\\n\t_CMN_EVENT_ATTR(_model, _name##_class3, _type, _event, 3, SEL_CLASS_OCCUP_ID)\n#define CMN_EVENT_HN_SNT(_model, _name, _type, _event)\t\t\t\\\n\t_CMN_EVENT_ATTR(_model, _name##_all, _type, _event, 0, SEL_CBUSY_SNTHROTTLE_SEL), \\\n\t_CMN_EVENT_ATTR(_model, _name##_group0_read, _type, _event, 1, SEL_CBUSY_SNTHROTTLE_SEL), \\\n\t_CMN_EVENT_ATTR(_model, _name##_group0_write, _type, _event, 2, SEL_CBUSY_SNTHROTTLE_SEL), \\\n\t_CMN_EVENT_ATTR(_model, _name##_group1_read, _type, _event, 3, SEL_CBUSY_SNTHROTTLE_SEL), \\\n\t_CMN_EVENT_ATTR(_model, _name##_group1_write, _type, _event, 4, SEL_CBUSY_SNTHROTTLE_SEL), \\\n\t_CMN_EVENT_ATTR(_model, _name##_read, _type, _event, 5, SEL_CBUSY_SNTHROTTLE_SEL), \\\n\t_CMN_EVENT_ATTR(_model, _name##_write, _type, _event, 6, SEL_CBUSY_SNTHROTTLE_SEL)\n\n#define CMN_EVENT_HNF_OCC(_model, _name, _event)\t\t\t\\\n\tCMN_EVENT_HN_OCC(_model, hnf_##_name, CMN_TYPE_HNF, _event)\n#define CMN_EVENT_HNF_CLS(_model, _name, _event)\t\t\t\\\n\tCMN_EVENT_HN_CLS(_model, hnf_##_name, CMN_TYPE_HNF, _event)\n#define CMN_EVENT_HNF_SNT(_model, _name, _event)\t\t\t\\\n\tCMN_EVENT_HN_SNT(_model, hnf_##_name, CMN_TYPE_HNF, _event)\n\n#define CMN_EVENT_HNS_OCC(_name, _event)\t\t\t\t\\\n\tCMN_EVENT_HN_OCC(CMN_ANY, hns_##_name, CMN_TYPE_HNS, _event),\t\\\n\t_CMN_EVENT_ATTR(CMN_ANY, hns_##_name##_rxsnp, CMN_TYPE_HNS, _event, 5, SEL_OCCUP1ID), \\\n\t_CMN_EVENT_ATTR(CMN_ANY, hns_##_name##_lbt, CMN_TYPE_HNS, _event, 6, SEL_OCCUP1ID), \\\n\t_CMN_EVENT_ATTR(CMN_ANY, hns_##_name##_hbt, CMN_TYPE_HNS, _event, 7, SEL_OCCUP1ID)\n#define CMN_EVENT_HNS_CLS( _name, _event)\t\t\t\t\\\n\tCMN_EVENT_HN_CLS(CMN_ANY, hns_##_name, CMN_TYPE_HNS, _event)\n#define CMN_EVENT_HNS_SNT(_name, _event)\t\t\t\t\\\n\tCMN_EVENT_HN_SNT(CMN_ANY, hns_##_name, CMN_TYPE_HNS, _event)\n#define CMN_EVENT_HNS_HBT(_name, _event)\t\t\t\t\\\n\t_CMN_EVENT_ATTR(CMN_ANY, hns_##_name##_all, CMN_TYPE_HNS, _event, 0, SEL_HBT_LBT_SEL), \\\n\t_CMN_EVENT_ATTR(CMN_ANY, hns_##_name##_hbt, CMN_TYPE_HNS, _event, 1, SEL_HBT_LBT_SEL), \\\n\t_CMN_EVENT_ATTR(CMN_ANY, hns_##_name##_lbt, CMN_TYPE_HNS, _event, 2, SEL_HBT_LBT_SEL)\n#define CMN_EVENT_HNS_SNH(_name, _event)\t\t\t\t\\\n\t_CMN_EVENT_ATTR(CMN_ANY, hns_##_name##_all, CMN_TYPE_HNS, _event, 0, SEL_SN_HOME_SEL), \\\n\t_CMN_EVENT_ATTR(CMN_ANY, hns_##_name##_sn, CMN_TYPE_HNS, _event, 1, SEL_SN_HOME_SEL), \\\n\t_CMN_EVENT_ATTR(CMN_ANY, hns_##_name##_home, CMN_TYPE_HNS, _event, 2, SEL_SN_HOME_SEL)\n\n#define _CMN_EVENT_XP_MESH(_name, _event)\t\t\t\\\n\t__CMN_EVENT_XP(e_##_name, (_event) | (0 << 2)),\t\t\\\n\t__CMN_EVENT_XP(w_##_name, (_event) | (1 << 2)),\t\t\\\n\t__CMN_EVENT_XP(n_##_name, (_event) | (2 << 2)),\t\t\\\n\t__CMN_EVENT_XP(s_##_name, (_event) | (3 << 2))\n\n#define _CMN_EVENT_XP_PORT(_name, _event)\t\t\t\\\n\t__CMN_EVENT_XP(p0_##_name, (_event) | (4 << 2)),\t\\\n\t__CMN_EVENT_XP(p1_##_name, (_event) | (5 << 2)),\t\\\n\t__CMN_EVENT_XP(p2_##_name, (_event) | (6 << 2)),\t\\\n\t__CMN_EVENT_XP(p3_##_name, (_event) | (7 << 2))\n\n#define _CMN_EVENT_XP(_name, _event)\t\t\t\t\\\n\t_CMN_EVENT_XP_MESH(_name, _event),\t\t\t\\\n\t_CMN_EVENT_XP_PORT(_name, _event)\n\n \n#define CMN_EVENT_XP(_name, _event)\t\t\t\t\\\n\t_CMN_EVENT_XP(req_##_name, (_event) | (0 << 5)),\t\\\n\t_CMN_EVENT_XP(rsp_##_name, (_event) | (1 << 5)),\t\\\n\t_CMN_EVENT_XP(snp_##_name, (_event) | (2 << 5)),\t\\\n\t_CMN_EVENT_XP(dat_##_name, (_event) | (3 << 5)),\t\\\n\t_CMN_EVENT_XP(pub_##_name, (_event) | (4 << 5)),\t\\\n\t_CMN_EVENT_XP(rsp2_##_name, (_event) | (5 << 5)),\t\\\n\t_CMN_EVENT_XP(dat2_##_name, (_event) | (6 << 5)),\t\\\n\t_CMN_EVENT_XP(snp2_##_name, (_event) | (7 << 5)),\t\\\n\t_CMN_EVENT_XP(req2_##_name, (_event) | (8 << 5))\n\n#define CMN_EVENT_XP_DAT(_name, _event)\t\t\t\t\\\n\t_CMN_EVENT_XP_PORT(dat_##_name, (_event) | (3 << 5)),\t\\\n\t_CMN_EVENT_XP_PORT(dat2_##_name, (_event) | (6 << 5))\n\n\nstatic struct attribute *arm_cmn_event_attrs[] = {\n\tCMN_EVENT_DTC(cycles),\n\n\t \n\tCMN_EVENT_DVM(CMN600, rxreq_dvmop,\t\t0x01),\n\tCMN_EVENT_DVM(CMN600, rxreq_dvmsync,\t\t0x02),\n\tCMN_EVENT_DVM(CMN600, rxreq_dvmop_vmid_filtered, 0x03),\n\tCMN_EVENT_DVM(CMN600, rxreq_retried,\t\t0x04),\n\tCMN_EVENT_DVM_OCC(CMN600, rxreq_trk_occupancy,\t0x05),\n\tCMN_EVENT_DVM(NOT_CMN600, dvmop_tlbi,\t\t0x01),\n\tCMN_EVENT_DVM(NOT_CMN600, dvmop_bpi,\t\t0x02),\n\tCMN_EVENT_DVM(NOT_CMN600, dvmop_pici,\t\t0x03),\n\tCMN_EVENT_DVM(NOT_CMN600, dvmop_vici,\t\t0x04),\n\tCMN_EVENT_DVM(NOT_CMN600, dvmsync,\t\t0x05),\n\tCMN_EVENT_DVM(NOT_CMN600, vmid_filtered,\t0x06),\n\tCMN_EVENT_DVM(NOT_CMN600, rndop_filtered,\t0x07),\n\tCMN_EVENT_DVM(NOT_CMN600, retry,\t\t0x08),\n\tCMN_EVENT_DVM(NOT_CMN600, txsnp_flitv,\t\t0x09),\n\tCMN_EVENT_DVM(NOT_CMN600, txsnp_stall,\t\t0x0a),\n\tCMN_EVENT_DVM(NOT_CMN600, trkfull,\t\t0x0b),\n\tCMN_EVENT_DVM_OCC(NOT_CMN600, trk_occupancy,\t0x0c),\n\tCMN_EVENT_DVM_OCC(CMN700, trk_occupancy_cxha,\t0x0d),\n\tCMN_EVENT_DVM_OCC(CMN700, trk_occupancy_pdn,\t0x0e),\n\tCMN_EVENT_DVM(CMN700, trk_alloc,\t\t0x0f),\n\tCMN_EVENT_DVM(CMN700, trk_cxha_alloc,\t\t0x10),\n\tCMN_EVENT_DVM(CMN700, trk_pdn_alloc,\t\t0x11),\n\tCMN_EVENT_DVM(CMN700, txsnp_stall_limit,\t0x12),\n\tCMN_EVENT_DVM(CMN700, rxsnp_stall_starv,\t0x13),\n\tCMN_EVENT_DVM(CMN700, txsnp_sync_stall_op,\t0x14),\n\n\tCMN_EVENT_HNF(CMN_ANY, cache_miss,\t\t0x01),\n\tCMN_EVENT_HNF(CMN_ANY, slc_sf_cache_access,\t0x02),\n\tCMN_EVENT_HNF(CMN_ANY, cache_fill,\t\t0x03),\n\tCMN_EVENT_HNF(CMN_ANY, pocq_retry,\t\t0x04),\n\tCMN_EVENT_HNF(CMN_ANY, pocq_reqs_recvd,\t\t0x05),\n\tCMN_EVENT_HNF(CMN_ANY, sf_hit,\t\t\t0x06),\n\tCMN_EVENT_HNF(CMN_ANY, sf_evictions,\t\t0x07),\n\tCMN_EVENT_HNF(CMN_ANY, dir_snoops_sent,\t\t0x08),\n\tCMN_EVENT_HNF(CMN_ANY, brd_snoops_sent,\t\t0x09),\n\tCMN_EVENT_HNF(CMN_ANY, slc_eviction,\t\t0x0a),\n\tCMN_EVENT_HNF(CMN_ANY, slc_fill_invalid_way,\t0x0b),\n\tCMN_EVENT_HNF(CMN_ANY, mc_retries,\t\t0x0c),\n\tCMN_EVENT_HNF(CMN_ANY, mc_reqs,\t\t\t0x0d),\n\tCMN_EVENT_HNF(CMN_ANY, qos_hh_retry,\t\t0x0e),\n\tCMN_EVENT_HNF_OCC(CMN_ANY, qos_pocq_occupancy,\t0x0f),\n\tCMN_EVENT_HNF(CMN_ANY, pocq_addrhaz,\t\t0x10),\n\tCMN_EVENT_HNF(CMN_ANY, pocq_atomic_addrhaz,\t0x11),\n\tCMN_EVENT_HNF(CMN_ANY, ld_st_swp_adq_full,\t0x12),\n\tCMN_EVENT_HNF(CMN_ANY, cmp_adq_full,\t\t0x13),\n\tCMN_EVENT_HNF(CMN_ANY, txdat_stall,\t\t0x14),\n\tCMN_EVENT_HNF(CMN_ANY, txrsp_stall,\t\t0x15),\n\tCMN_EVENT_HNF(CMN_ANY, seq_full,\t\t0x16),\n\tCMN_EVENT_HNF(CMN_ANY, seq_hit,\t\t\t0x17),\n\tCMN_EVENT_HNF(CMN_ANY, snp_sent,\t\t0x18),\n\tCMN_EVENT_HNF(CMN_ANY, sfbi_dir_snp_sent,\t0x19),\n\tCMN_EVENT_HNF(CMN_ANY, sfbi_brd_snp_sent,\t0x1a),\n\tCMN_EVENT_HNF(CMN_ANY, snp_sent_untrk,\t\t0x1b),\n\tCMN_EVENT_HNF(CMN_ANY, intv_dirty,\t\t0x1c),\n\tCMN_EVENT_HNF(CMN_ANY, stash_snp_sent,\t\t0x1d),\n\tCMN_EVENT_HNF(CMN_ANY, stash_data_pull,\t\t0x1e),\n\tCMN_EVENT_HNF(CMN_ANY, snp_fwded,\t\t0x1f),\n\tCMN_EVENT_HNF(NOT_CMN600, atomic_fwd,\t\t0x20),\n\tCMN_EVENT_HNF(NOT_CMN600, mpam_hardlim,\t\t0x21),\n\tCMN_EVENT_HNF(NOT_CMN600, mpam_softlim,\t\t0x22),\n\tCMN_EVENT_HNF(CMN_650ON, snp_sent_cluster,\t0x23),\n\tCMN_EVENT_HNF(CMN_650ON, sf_imprecise_evict,\t0x24),\n\tCMN_EVENT_HNF(CMN_650ON, sf_evict_shared_line,\t0x25),\n\tCMN_EVENT_HNF_CLS(CMN700, pocq_class_occup,\t0x26),\n\tCMN_EVENT_HNF_CLS(CMN700, pocq_class_retry,\t0x27),\n\tCMN_EVENT_HNF_CLS(CMN700, class_mc_reqs,\t0x28),\n\tCMN_EVENT_HNF_CLS(CMN700, class_cgnt_cmin,\t0x29),\n\tCMN_EVENT_HNF_SNT(CMN700, sn_throttle,\t\t0x2a),\n\tCMN_EVENT_HNF_SNT(CMN700, sn_throttle_min,\t0x2b),\n\tCMN_EVENT_HNF(CMN700, sf_precise_to_imprecise,\t0x2c),\n\tCMN_EVENT_HNF(CMN700, snp_intv_cln,\t\t0x2d),\n\tCMN_EVENT_HNF(CMN700, nc_excl,\t\t\t0x2e),\n\tCMN_EVENT_HNF(CMN700, excl_mon_ovfl,\t\t0x2f),\n\n\tCMN_EVENT_HNI(rrt_rd_occ_cnt_ovfl,\t\t0x20),\n\tCMN_EVENT_HNI(rrt_wr_occ_cnt_ovfl,\t\t0x21),\n\tCMN_EVENT_HNI(rdt_rd_occ_cnt_ovfl,\t\t0x22),\n\tCMN_EVENT_HNI(rdt_wr_occ_cnt_ovfl,\t\t0x23),\n\tCMN_EVENT_HNI(wdb_occ_cnt_ovfl,\t\t\t0x24),\n\tCMN_EVENT_HNI(rrt_rd_alloc,\t\t\t0x25),\n\tCMN_EVENT_HNI(rrt_wr_alloc,\t\t\t0x26),\n\tCMN_EVENT_HNI(rdt_rd_alloc,\t\t\t0x27),\n\tCMN_EVENT_HNI(rdt_wr_alloc,\t\t\t0x28),\n\tCMN_EVENT_HNI(wdb_alloc,\t\t\t0x29),\n\tCMN_EVENT_HNI(txrsp_retryack,\t\t\t0x2a),\n\tCMN_EVENT_HNI(arvalid_no_arready,\t\t0x2b),\n\tCMN_EVENT_HNI(arready_no_arvalid,\t\t0x2c),\n\tCMN_EVENT_HNI(awvalid_no_awready,\t\t0x2d),\n\tCMN_EVENT_HNI(awready_no_awvalid,\t\t0x2e),\n\tCMN_EVENT_HNI(wvalid_no_wready,\t\t\t0x2f),\n\tCMN_EVENT_HNI(txdat_stall,\t\t\t0x30),\n\tCMN_EVENT_HNI(nonpcie_serialization,\t\t0x31),\n\tCMN_EVENT_HNI(pcie_serialization,\t\t0x32),\n\n\t \n\tCMN_EVENT_HNP(rrt_wr_occ_cnt_ovfl,\t\t0x01),\n\tCMN_EVENT_HNP(rdt_wr_occ_cnt_ovfl,\t\t0x02),\n\tCMN_EVENT_HNP(wdb_occ_cnt_ovfl,\t\t\t0x03),\n\tCMN_EVENT_HNP(rrt_wr_alloc,\t\t\t0x04),\n\tCMN_EVENT_HNP(rdt_wr_alloc,\t\t\t0x05),\n\tCMN_EVENT_HNP(wdb_alloc,\t\t\t0x06),\n\tCMN_EVENT_HNP(awvalid_no_awready,\t\t0x07),\n\tCMN_EVENT_HNP(awready_no_awvalid,\t\t0x08),\n\tCMN_EVENT_HNP(wvalid_no_wready,\t\t\t0x09),\n\tCMN_EVENT_HNP(rrt_rd_occ_cnt_ovfl,\t\t0x11),\n\tCMN_EVENT_HNP(rdt_rd_occ_cnt_ovfl,\t\t0x12),\n\tCMN_EVENT_HNP(rrt_rd_alloc,\t\t\t0x13),\n\tCMN_EVENT_HNP(rdt_rd_alloc,\t\t\t0x14),\n\tCMN_EVENT_HNP(arvalid_no_arready,\t\t0x15),\n\tCMN_EVENT_HNP(arready_no_arvalid,\t\t0x16),\n\n\tCMN_EVENT_XP(txflit_valid,\t\t\t0x01),\n\tCMN_EVENT_XP(txflit_stall,\t\t\t0x02),\n\tCMN_EVENT_XP_DAT(partial_dat_flit,\t\t0x03),\n\t \n\tCMN_EVENT_ATTR(CMN_ANY, watchpoint_up, CMN_TYPE_WP, CMN_WP_UP),\n\tCMN_EVENT_ATTR(CMN_ANY, watchpoint_down, CMN_TYPE_WP, CMN_WP_DOWN),\n\n\tCMN_EVENT_SBSX(CMN_ANY, rd_req,\t\t\t0x01),\n\tCMN_EVENT_SBSX(CMN_ANY, wr_req,\t\t\t0x02),\n\tCMN_EVENT_SBSX(CMN_ANY, cmo_req,\t\t0x03),\n\tCMN_EVENT_SBSX(CMN_ANY, txrsp_retryack,\t\t0x04),\n\tCMN_EVENT_SBSX(CMN_ANY, txdat_flitv,\t\t0x05),\n\tCMN_EVENT_SBSX(CMN_ANY, txrsp_flitv,\t\t0x06),\n\tCMN_EVENT_SBSX(CMN_ANY, rd_req_trkr_occ_cnt_ovfl, 0x11),\n\tCMN_EVENT_SBSX(CMN_ANY, wr_req_trkr_occ_cnt_ovfl, 0x12),\n\tCMN_EVENT_SBSX(CMN_ANY, cmo_req_trkr_occ_cnt_ovfl, 0x13),\n\tCMN_EVENT_SBSX(CMN_ANY, wdb_occ_cnt_ovfl,\t0x14),\n\tCMN_EVENT_SBSX(CMN_ANY, rd_axi_trkr_occ_cnt_ovfl, 0x15),\n\tCMN_EVENT_SBSX(CMN_ANY, cmo_axi_trkr_occ_cnt_ovfl, 0x16),\n\tCMN_EVENT_SBSX(NOT_CMN600, rdb_occ_cnt_ovfl,\t0x17),\n\tCMN_EVENT_SBSX(CMN_ANY, arvalid_no_arready,\t0x21),\n\tCMN_EVENT_SBSX(CMN_ANY, awvalid_no_awready,\t0x22),\n\tCMN_EVENT_SBSX(CMN_ANY, wvalid_no_wready,\t0x23),\n\tCMN_EVENT_SBSX(CMN_ANY, txdat_stall,\t\t0x24),\n\tCMN_EVENT_SBSX(CMN_ANY, txrsp_stall,\t\t0x25),\n\n\tCMN_EVENT_RNID(CMN_ANY, s0_rdata_beats,\t\t0x01),\n\tCMN_EVENT_RNID(CMN_ANY, s1_rdata_beats,\t\t0x02),\n\tCMN_EVENT_RNID(CMN_ANY, s2_rdata_beats,\t\t0x03),\n\tCMN_EVENT_RNID(CMN_ANY, rxdat_flits,\t\t0x04),\n\tCMN_EVENT_RNID(CMN_ANY, txdat_flits,\t\t0x05),\n\tCMN_EVENT_RNID(CMN_ANY, txreq_flits_total,\t0x06),\n\tCMN_EVENT_RNID(CMN_ANY, txreq_flits_retried,\t0x07),\n\tCMN_EVENT_RNID(CMN_ANY, rrt_occ_ovfl,\t\t0x08),\n\tCMN_EVENT_RNID(CMN_ANY, wrt_occ_ovfl,\t\t0x09),\n\tCMN_EVENT_RNID(CMN_ANY, txreq_flits_replayed,\t0x0a),\n\tCMN_EVENT_RNID(CMN_ANY, wrcancel_sent,\t\t0x0b),\n\tCMN_EVENT_RNID(CMN_ANY, s0_wdata_beats,\t\t0x0c),\n\tCMN_EVENT_RNID(CMN_ANY, s1_wdata_beats,\t\t0x0d),\n\tCMN_EVENT_RNID(CMN_ANY, s2_wdata_beats,\t\t0x0e),\n\tCMN_EVENT_RNID(CMN_ANY, rrt_alloc,\t\t0x0f),\n\tCMN_EVENT_RNID(CMN_ANY, wrt_alloc,\t\t0x10),\n\tCMN_EVENT_RNID(CMN600, rdb_unord,\t\t0x11),\n\tCMN_EVENT_RNID(CMN600, rdb_replay,\t\t0x12),\n\tCMN_EVENT_RNID(CMN600, rdb_hybrid,\t\t0x13),\n\tCMN_EVENT_RNID(CMN600, rdb_ord,\t\t\t0x14),\n\tCMN_EVENT_RNID(NOT_CMN600, padb_occ_ovfl,\t0x11),\n\tCMN_EVENT_RNID(NOT_CMN600, rpdb_occ_ovfl,\t0x12),\n\tCMN_EVENT_RNID(NOT_CMN600, rrt_occup_ovfl_slice1, 0x13),\n\tCMN_EVENT_RNID(NOT_CMN600, rrt_occup_ovfl_slice2, 0x14),\n\tCMN_EVENT_RNID(NOT_CMN600, rrt_occup_ovfl_slice3, 0x15),\n\tCMN_EVENT_RNID(NOT_CMN600, wrt_throttled,\t0x16),\n\tCMN_EVENT_RNID(CMN700, ldb_full,\t\t0x17),\n\tCMN_EVENT_RNID(CMN700, rrt_rd_req_occup_ovfl_slice0, 0x18),\n\tCMN_EVENT_RNID(CMN700, rrt_rd_req_occup_ovfl_slice1, 0x19),\n\tCMN_EVENT_RNID(CMN700, rrt_rd_req_occup_ovfl_slice2, 0x1a),\n\tCMN_EVENT_RNID(CMN700, rrt_rd_req_occup_ovfl_slice3, 0x1b),\n\tCMN_EVENT_RNID(CMN700, rrt_burst_occup_ovfl_slice0, 0x1c),\n\tCMN_EVENT_RNID(CMN700, rrt_burst_occup_ovfl_slice1, 0x1d),\n\tCMN_EVENT_RNID(CMN700, rrt_burst_occup_ovfl_slice2, 0x1e),\n\tCMN_EVENT_RNID(CMN700, rrt_burst_occup_ovfl_slice3, 0x1f),\n\tCMN_EVENT_RNID(CMN700, rrt_burst_alloc,\t\t0x20),\n\tCMN_EVENT_RNID(CMN700, awid_hash,\t\t0x21),\n\tCMN_EVENT_RNID(CMN700, atomic_alloc,\t\t0x22),\n\tCMN_EVENT_RNID(CMN700, atomic_occ_ovfl,\t\t0x23),\n\n\tCMN_EVENT_MTSX(tc_lookup,\t\t\t0x01),\n\tCMN_EVENT_MTSX(tc_fill,\t\t\t\t0x02),\n\tCMN_EVENT_MTSX(tc_miss,\t\t\t\t0x03),\n\tCMN_EVENT_MTSX(tdb_forward,\t\t\t0x04),\n\tCMN_EVENT_MTSX(tcq_hazard,\t\t\t0x05),\n\tCMN_EVENT_MTSX(tcq_rd_alloc,\t\t\t0x06),\n\tCMN_EVENT_MTSX(tcq_wr_alloc,\t\t\t0x07),\n\tCMN_EVENT_MTSX(tcq_cmo_alloc,\t\t\t0x08),\n\tCMN_EVENT_MTSX(axi_rd_req,\t\t\t0x09),\n\tCMN_EVENT_MTSX(axi_wr_req,\t\t\t0x0a),\n\tCMN_EVENT_MTSX(tcq_occ_cnt_ovfl,\t\t0x0b),\n\tCMN_EVENT_MTSX(tdb_occ_cnt_ovfl,\t\t0x0c),\n\n\tCMN_EVENT_CXRA(CMN_ANY, rht_occ,\t\t0x01),\n\tCMN_EVENT_CXRA(CMN_ANY, sht_occ,\t\t0x02),\n\tCMN_EVENT_CXRA(CMN_ANY, rdb_occ,\t\t0x03),\n\tCMN_EVENT_CXRA(CMN_ANY, wdb_occ,\t\t0x04),\n\tCMN_EVENT_CXRA(CMN_ANY, ssb_occ,\t\t0x05),\n\tCMN_EVENT_CXRA(CMN_ANY, snp_bcasts,\t\t0x06),\n\tCMN_EVENT_CXRA(CMN_ANY, req_chains,\t\t0x07),\n\tCMN_EVENT_CXRA(CMN_ANY, req_chain_avglen,\t0x08),\n\tCMN_EVENT_CXRA(CMN_ANY, chirsp_stalls,\t\t0x09),\n\tCMN_EVENT_CXRA(CMN_ANY, chidat_stalls,\t\t0x0a),\n\tCMN_EVENT_CXRA(CMN_ANY, cxreq_pcrd_stalls_link0, 0x0b),\n\tCMN_EVENT_CXRA(CMN_ANY, cxreq_pcrd_stalls_link1, 0x0c),\n\tCMN_EVENT_CXRA(CMN_ANY, cxreq_pcrd_stalls_link2, 0x0d),\n\tCMN_EVENT_CXRA(CMN_ANY, cxdat_pcrd_stalls_link0, 0x0e),\n\tCMN_EVENT_CXRA(CMN_ANY, cxdat_pcrd_stalls_link1, 0x0f),\n\tCMN_EVENT_CXRA(CMN_ANY, cxdat_pcrd_stalls_link2, 0x10),\n\tCMN_EVENT_CXRA(CMN_ANY, external_chirsp_stalls,\t0x11),\n\tCMN_EVENT_CXRA(CMN_ANY, external_chidat_stalls,\t0x12),\n\tCMN_EVENT_CXRA(NOT_CMN600, cxmisc_pcrd_stalls_link0, 0x13),\n\tCMN_EVENT_CXRA(NOT_CMN600, cxmisc_pcrd_stalls_link1, 0x14),\n\tCMN_EVENT_CXRA(NOT_CMN600, cxmisc_pcrd_stalls_link2, 0x15),\n\n\tCMN_EVENT_CXHA(rddatbyp,\t\t\t0x21),\n\tCMN_EVENT_CXHA(chirsp_up_stall,\t\t\t0x22),\n\tCMN_EVENT_CXHA(chidat_up_stall,\t\t\t0x23),\n\tCMN_EVENT_CXHA(snppcrd_link0_stall,\t\t0x24),\n\tCMN_EVENT_CXHA(snppcrd_link1_stall,\t\t0x25),\n\tCMN_EVENT_CXHA(snppcrd_link2_stall,\t\t0x26),\n\tCMN_EVENT_CXHA(reqtrk_occ,\t\t\t0x27),\n\tCMN_EVENT_CXHA(rdb_occ,\t\t\t\t0x28),\n\tCMN_EVENT_CXHA(rdbyp_occ,\t\t\t0x29),\n\tCMN_EVENT_CXHA(wdb_occ,\t\t\t\t0x2a),\n\tCMN_EVENT_CXHA(snptrk_occ,\t\t\t0x2b),\n\tCMN_EVENT_CXHA(sdb_occ,\t\t\t\t0x2c),\n\tCMN_EVENT_CXHA(snphaz_occ,\t\t\t0x2d),\n\n\tCMN_EVENT_CCRA(rht_occ,\t\t\t\t0x41),\n\tCMN_EVENT_CCRA(sht_occ,\t\t\t\t0x42),\n\tCMN_EVENT_CCRA(rdb_occ,\t\t\t\t0x43),\n\tCMN_EVENT_CCRA(wdb_occ,\t\t\t\t0x44),\n\tCMN_EVENT_CCRA(ssb_occ,\t\t\t\t0x45),\n\tCMN_EVENT_CCRA(snp_bcasts,\t\t\t0x46),\n\tCMN_EVENT_CCRA(req_chains,\t\t\t0x47),\n\tCMN_EVENT_CCRA(req_chain_avglen,\t\t0x48),\n\tCMN_EVENT_CCRA(chirsp_stalls,\t\t\t0x49),\n\tCMN_EVENT_CCRA(chidat_stalls,\t\t\t0x4a),\n\tCMN_EVENT_CCRA(cxreq_pcrd_stalls_link0,\t\t0x4b),\n\tCMN_EVENT_CCRA(cxreq_pcrd_stalls_link1,\t\t0x4c),\n\tCMN_EVENT_CCRA(cxreq_pcrd_stalls_link2,\t\t0x4d),\n\tCMN_EVENT_CCRA(cxdat_pcrd_stalls_link0,\t\t0x4e),\n\tCMN_EVENT_CCRA(cxdat_pcrd_stalls_link1,\t\t0x4f),\n\tCMN_EVENT_CCRA(cxdat_pcrd_stalls_link2,\t\t0x50),\n\tCMN_EVENT_CCRA(external_chirsp_stalls,\t\t0x51),\n\tCMN_EVENT_CCRA(external_chidat_stalls,\t\t0x52),\n\tCMN_EVENT_CCRA(cxmisc_pcrd_stalls_link0,\t0x53),\n\tCMN_EVENT_CCRA(cxmisc_pcrd_stalls_link1,\t0x54),\n\tCMN_EVENT_CCRA(cxmisc_pcrd_stalls_link2,\t0x55),\n\tCMN_EVENT_CCRA(rht_alloc,\t\t\t0x56),\n\tCMN_EVENT_CCRA(sht_alloc,\t\t\t0x57),\n\tCMN_EVENT_CCRA(rdb_alloc,\t\t\t0x58),\n\tCMN_EVENT_CCRA(wdb_alloc,\t\t\t0x59),\n\tCMN_EVENT_CCRA(ssb_alloc,\t\t\t0x5a),\n\n\tCMN_EVENT_CCHA(rddatbyp,\t\t\t0x61),\n\tCMN_EVENT_CCHA(chirsp_up_stall,\t\t\t0x62),\n\tCMN_EVENT_CCHA(chidat_up_stall,\t\t\t0x63),\n\tCMN_EVENT_CCHA(snppcrd_link0_stall,\t\t0x64),\n\tCMN_EVENT_CCHA(snppcrd_link1_stall,\t\t0x65),\n\tCMN_EVENT_CCHA(snppcrd_link2_stall,\t\t0x66),\n\tCMN_EVENT_CCHA(reqtrk_occ,\t\t\t0x67),\n\tCMN_EVENT_CCHA(rdb_occ,\t\t\t\t0x68),\n\tCMN_EVENT_CCHA(rdbyp_occ,\t\t\t0x69),\n\tCMN_EVENT_CCHA(wdb_occ,\t\t\t\t0x6a),\n\tCMN_EVENT_CCHA(snptrk_occ,\t\t\t0x6b),\n\tCMN_EVENT_CCHA(sdb_occ,\t\t\t\t0x6c),\n\tCMN_EVENT_CCHA(snphaz_occ,\t\t\t0x6d),\n\tCMN_EVENT_CCHA(reqtrk_alloc,\t\t\t0x6e),\n\tCMN_EVENT_CCHA(rdb_alloc,\t\t\t0x6f),\n\tCMN_EVENT_CCHA(rdbyp_alloc,\t\t\t0x70),\n\tCMN_EVENT_CCHA(wdb_alloc,\t\t\t0x71),\n\tCMN_EVENT_CCHA(snptrk_alloc,\t\t\t0x72),\n\tCMN_EVENT_CCHA(sdb_alloc,\t\t\t0x73),\n\tCMN_EVENT_CCHA(snphaz_alloc,\t\t\t0x74),\n\tCMN_EVENT_CCHA(pb_rhu_req_occ,\t\t\t0x75),\n\tCMN_EVENT_CCHA(pb_rhu_req_alloc,\t\t0x76),\n\tCMN_EVENT_CCHA(pb_rhu_pcie_req_occ,\t\t0x77),\n\tCMN_EVENT_CCHA(pb_rhu_pcie_req_alloc,\t\t0x78),\n\tCMN_EVENT_CCHA(pb_pcie_wr_req_occ,\t\t0x79),\n\tCMN_EVENT_CCHA(pb_pcie_wr_req_alloc,\t\t0x7a),\n\tCMN_EVENT_CCHA(pb_pcie_reg_req_occ,\t\t0x7b),\n\tCMN_EVENT_CCHA(pb_pcie_reg_req_alloc,\t\t0x7c),\n\tCMN_EVENT_CCHA(pb_pcie_rsvd_req_occ,\t\t0x7d),\n\tCMN_EVENT_CCHA(pb_pcie_rsvd_req_alloc,\t\t0x7e),\n\tCMN_EVENT_CCHA(pb_rhu_dat_occ,\t\t\t0x7f),\n\tCMN_EVENT_CCHA(pb_rhu_dat_alloc,\t\t0x80),\n\tCMN_EVENT_CCHA(pb_rhu_pcie_dat_occ,\t\t0x81),\n\tCMN_EVENT_CCHA(pb_rhu_pcie_dat_alloc,\t\t0x82),\n\tCMN_EVENT_CCHA(pb_pcie_wr_dat_occ,\t\t0x83),\n\tCMN_EVENT_CCHA(pb_pcie_wr_dat_alloc,\t\t0x84),\n\n\tCMN_EVENT_CCLA(rx_cxs,\t\t\t\t0x21),\n\tCMN_EVENT_CCLA(tx_cxs,\t\t\t\t0x22),\n\tCMN_EVENT_CCLA(rx_cxs_avg_size,\t\t\t0x23),\n\tCMN_EVENT_CCLA(tx_cxs_avg_size,\t\t\t0x24),\n\tCMN_EVENT_CCLA(tx_cxs_lcrd_backpressure,\t0x25),\n\tCMN_EVENT_CCLA(link_crdbuf_occ,\t\t\t0x26),\n\tCMN_EVENT_CCLA(link_crdbuf_alloc,\t\t0x27),\n\tCMN_EVENT_CCLA(pfwd_rcvr_cxs,\t\t\t0x28),\n\tCMN_EVENT_CCLA(pfwd_sndr_num_flits,\t\t0x29),\n\tCMN_EVENT_CCLA(pfwd_sndr_stalls_static_crd,\t0x2a),\n\tCMN_EVENT_CCLA(pfwd_sndr_stalls_dynmaic_crd,\t0x2b),\n\n\tCMN_EVENT_HNS_HBT(cache_miss,\t\t\t0x01),\n\tCMN_EVENT_HNS_HBT(slc_sf_cache_access,\t\t0x02),\n\tCMN_EVENT_HNS_HBT(cache_fill,\t\t\t0x03),\n\tCMN_EVENT_HNS_HBT(pocq_retry,\t\t\t0x04),\n\tCMN_EVENT_HNS_HBT(pocq_reqs_recvd,\t\t0x05),\n\tCMN_EVENT_HNS_HBT(sf_hit,\t\t\t0x06),\n\tCMN_EVENT_HNS_HBT(sf_evictions,\t\t\t0x07),\n\tCMN_EVENT_HNS(dir_snoops_sent,\t\t\t0x08),\n\tCMN_EVENT_HNS(brd_snoops_sent,\t\t\t0x09),\n\tCMN_EVENT_HNS_HBT(slc_eviction,\t\t\t0x0a),\n\tCMN_EVENT_HNS_HBT(slc_fill_invalid_way,\t\t0x0b),\n\tCMN_EVENT_HNS(mc_retries_local,\t\t\t0x0c),\n\tCMN_EVENT_HNS_SNH(mc_reqs_local,\t\t0x0d),\n\tCMN_EVENT_HNS(qos_hh_retry,\t\t\t0x0e),\n\tCMN_EVENT_HNS_OCC(qos_pocq_occupancy,\t\t0x0f),\n\tCMN_EVENT_HNS(pocq_addrhaz,\t\t\t0x10),\n\tCMN_EVENT_HNS(pocq_atomic_addrhaz,\t\t0x11),\n\tCMN_EVENT_HNS(ld_st_swp_adq_full,\t\t0x12),\n\tCMN_EVENT_HNS(cmp_adq_full,\t\t\t0x13),\n\tCMN_EVENT_HNS(txdat_stall,\t\t\t0x14),\n\tCMN_EVENT_HNS(txrsp_stall,\t\t\t0x15),\n\tCMN_EVENT_HNS(seq_full,\t\t\t\t0x16),\n\tCMN_EVENT_HNS(seq_hit,\t\t\t\t0x17),\n\tCMN_EVENT_HNS(snp_sent,\t\t\t\t0x18),\n\tCMN_EVENT_HNS(sfbi_dir_snp_sent,\t\t0x19),\n\tCMN_EVENT_HNS(sfbi_brd_snp_sent,\t\t0x1a),\n\tCMN_EVENT_HNS(intv_dirty,\t\t\t0x1c),\n\tCMN_EVENT_HNS(stash_snp_sent,\t\t\t0x1d),\n\tCMN_EVENT_HNS(stash_data_pull,\t\t\t0x1e),\n\tCMN_EVENT_HNS(snp_fwded,\t\t\t0x1f),\n\tCMN_EVENT_HNS(atomic_fwd,\t\t\t0x20),\n\tCMN_EVENT_HNS(mpam_hardlim,\t\t\t0x21),\n\tCMN_EVENT_HNS(mpam_softlim,\t\t\t0x22),\n\tCMN_EVENT_HNS(snp_sent_cluster,\t\t\t0x23),\n\tCMN_EVENT_HNS(sf_imprecise_evict,\t\t0x24),\n\tCMN_EVENT_HNS(sf_evict_shared_line,\t\t0x25),\n\tCMN_EVENT_HNS_CLS(pocq_class_occup,\t\t0x26),\n\tCMN_EVENT_HNS_CLS(pocq_class_retry,\t\t0x27),\n\tCMN_EVENT_HNS_CLS(class_mc_reqs_local,\t\t0x28),\n\tCMN_EVENT_HNS_CLS(class_cgnt_cmin,\t\t0x29),\n\tCMN_EVENT_HNS_SNT(sn_throttle,\t\t\t0x2a),\n\tCMN_EVENT_HNS_SNT(sn_throttle_min,\t\t0x2b),\n\tCMN_EVENT_HNS(sf_precise_to_imprecise,\t\t0x2c),\n\tCMN_EVENT_HNS(snp_intv_cln,\t\t\t0x2d),\n\tCMN_EVENT_HNS(nc_excl,\t\t\t\t0x2e),\n\tCMN_EVENT_HNS(excl_mon_ovfl,\t\t\t0x2f),\n\tCMN_EVENT_HNS(snp_req_recvd,\t\t\t0x30),\n\tCMN_EVENT_HNS(snp_req_byp_pocq,\t\t\t0x31),\n\tCMN_EVENT_HNS(dir_ccgha_snp_sent,\t\t0x32),\n\tCMN_EVENT_HNS(brd_ccgha_snp_sent,\t\t0x33),\n\tCMN_EVENT_HNS(ccgha_snp_stall,\t\t\t0x34),\n\tCMN_EVENT_HNS(lbt_req_hardlim,\t\t\t0x35),\n\tCMN_EVENT_HNS(hbt_req_hardlim,\t\t\t0x36),\n\tCMN_EVENT_HNS(sf_reupdate,\t\t\t0x37),\n\tCMN_EVENT_HNS(excl_sf_imprecise,\t\t0x38),\n\tCMN_EVENT_HNS(snp_pocq_addrhaz,\t\t\t0x39),\n\tCMN_EVENT_HNS(mc_retries_remote,\t\t0x3a),\n\tCMN_EVENT_HNS_SNH(mc_reqs_remote,\t\t0x3b),\n\tCMN_EVENT_HNS_CLS(class_mc_reqs_remote,\t\t0x3c),\n\n\tNULL\n};\n\nstatic const struct attribute_group arm_cmn_event_attrs_group = {\n\t.name = \"events\",\n\t.attrs = arm_cmn_event_attrs,\n\t.is_visible = arm_cmn_event_attr_is_visible,\n};\n\nstatic ssize_t arm_cmn_format_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct arm_cmn_format_attr *fmt = container_of(attr, typeof(*fmt), attr);\n\tint lo = __ffs(fmt->field), hi = __fls(fmt->field);\n\n\tif (lo == hi)\n\t\treturn sysfs_emit(buf, \"config:%d\\n\", lo);\n\n\tif (!fmt->config)\n\t\treturn sysfs_emit(buf, \"config:%d-%d\\n\", lo, hi);\n\n\treturn sysfs_emit(buf, \"config%d:%d-%d\\n\", fmt->config, lo, hi);\n}\n\n#define _CMN_FORMAT_ATTR(_name, _cfg, _fld)\t\t\t\t\\\n\t(&((struct arm_cmn_format_attr[]) {{\t\t\t\t\\\n\t\t.attr = __ATTR(_name, 0444, arm_cmn_format_show, NULL),\t\\\n\t\t.config = _cfg,\t\t\t\t\t\t\\\n\t\t.field = _fld,\t\t\t\t\t\t\\\n\t}})[0].attr.attr)\n#define CMN_FORMAT_ATTR(_name, _fld)\t_CMN_FORMAT_ATTR(_name, 0, _fld)\n\nstatic struct attribute *arm_cmn_format_attrs[] = {\n\tCMN_FORMAT_ATTR(type, CMN_CONFIG_TYPE),\n\tCMN_FORMAT_ATTR(eventid, CMN_CONFIG_EVENTID),\n\tCMN_FORMAT_ATTR(occupid, CMN_CONFIG_OCCUPID),\n\tCMN_FORMAT_ATTR(bynodeid, CMN_CONFIG_BYNODEID),\n\tCMN_FORMAT_ATTR(nodeid, CMN_CONFIG_NODEID),\n\n\tCMN_FORMAT_ATTR(wp_dev_sel, CMN_CONFIG_WP_DEV_SEL),\n\tCMN_FORMAT_ATTR(wp_chn_sel, CMN_CONFIG_WP_CHN_SEL),\n\tCMN_FORMAT_ATTR(wp_grp, CMN_CONFIG_WP_GRP),\n\tCMN_FORMAT_ATTR(wp_exclusive, CMN_CONFIG_WP_EXCLUSIVE),\n\tCMN_FORMAT_ATTR(wp_combine, CMN_CONFIG_WP_COMBINE),\n\n\t_CMN_FORMAT_ATTR(wp_val, 1, CMN_CONFIG1_WP_VAL),\n\t_CMN_FORMAT_ATTR(wp_mask, 2, CMN_CONFIG2_WP_MASK),\n\n\tNULL\n};\n\nstatic const struct attribute_group arm_cmn_format_attrs_group = {\n\t.name = \"format\",\n\t.attrs = arm_cmn_format_attrs,\n};\n\nstatic ssize_t arm_cmn_cpumask_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct arm_cmn *cmn = to_cmn(dev_get_drvdata(dev));\n\n\treturn cpumap_print_to_pagebuf(true, buf, cpumask_of(cmn->cpu));\n}\n\nstatic struct device_attribute arm_cmn_cpumask_attr =\n\t\t__ATTR(cpumask, 0444, arm_cmn_cpumask_show, NULL);\n\nstatic ssize_t arm_cmn_identifier_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct arm_cmn *cmn = to_cmn(dev_get_drvdata(dev));\n\n\treturn sysfs_emit(buf, \"%03x%02x\\n\", cmn->part, cmn->rev);\n}\n\nstatic struct device_attribute arm_cmn_identifier_attr =\n\t\t__ATTR(identifier, 0444, arm_cmn_identifier_show, NULL);\n\nstatic struct attribute *arm_cmn_other_attrs[] = {\n\t&arm_cmn_cpumask_attr.attr,\n\t&arm_cmn_identifier_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group arm_cmn_other_attrs_group = {\n\t.attrs = arm_cmn_other_attrs,\n};\n\nstatic const struct attribute_group *arm_cmn_attr_groups[] = {\n\t&arm_cmn_event_attrs_group,\n\t&arm_cmn_format_attrs_group,\n\t&arm_cmn_other_attrs_group,\n\tNULL\n};\n\nstatic int arm_cmn_wp_idx(struct perf_event *event)\n{\n\treturn CMN_EVENT_EVENTID(event) + CMN_EVENT_WP_GRP(event);\n}\n\nstatic u32 arm_cmn_wp_config(struct perf_event *event)\n{\n\tu32 config;\n\tu32 dev = CMN_EVENT_WP_DEV_SEL(event);\n\tu32 chn = CMN_EVENT_WP_CHN_SEL(event);\n\tu32 grp = CMN_EVENT_WP_GRP(event);\n\tu32 exc = CMN_EVENT_WP_EXCLUSIVE(event);\n\tu32 combine = CMN_EVENT_WP_COMBINE(event);\n\tbool is_cmn600 = to_cmn(event->pmu)->part == PART_CMN600;\n\n\tconfig = FIELD_PREP(CMN_DTM_WPn_CONFIG_WP_DEV_SEL, dev) |\n\t\t FIELD_PREP(CMN_DTM_WPn_CONFIG_WP_CHN_SEL, chn) |\n\t\t FIELD_PREP(CMN_DTM_WPn_CONFIG_WP_GRP, grp) |\n\t\t FIELD_PREP(CMN_DTM_WPn_CONFIG_WP_DEV_SEL2, dev >> 1);\n\tif (exc)\n\t\tconfig |= is_cmn600 ? CMN600_WPn_CONFIG_WP_EXCLUSIVE :\n\t\t\t\t      CMN_DTM_WPn_CONFIG_WP_EXCLUSIVE;\n\tif (combine && !grp)\n\t\tconfig |= is_cmn600 ? CMN600_WPn_CONFIG_WP_COMBINE :\n\t\t\t\t      CMN_DTM_WPn_CONFIG_WP_COMBINE;\n\treturn config;\n}\n\nstatic void arm_cmn_set_state(struct arm_cmn *cmn, u32 state)\n{\n\tif (!cmn->state)\n\t\twritel_relaxed(0, cmn->dtc[0].base + CMN_DT_PMCR);\n\tcmn->state |= state;\n}\n\nstatic void arm_cmn_clear_state(struct arm_cmn *cmn, u32 state)\n{\n\tcmn->state &= ~state;\n\tif (!cmn->state)\n\t\twritel_relaxed(CMN_DT_PMCR_PMU_EN | CMN_DT_PMCR_OVFL_INTR_EN,\n\t\t\t       cmn->dtc[0].base + CMN_DT_PMCR);\n}\n\nstatic void arm_cmn_pmu_enable(struct pmu *pmu)\n{\n\tarm_cmn_clear_state(to_cmn(pmu), CMN_STATE_DISABLED);\n}\n\nstatic void arm_cmn_pmu_disable(struct pmu *pmu)\n{\n\tarm_cmn_set_state(to_cmn(pmu), CMN_STATE_DISABLED);\n}\n\nstatic u64 arm_cmn_read_dtm(struct arm_cmn *cmn, struct arm_cmn_hw_event *hw,\n\t\t\t    bool snapshot)\n{\n\tstruct arm_cmn_dtm *dtm = NULL;\n\tstruct arm_cmn_node *dn;\n\tunsigned int i, offset, dtm_idx;\n\tu64 reg, count = 0;\n\n\toffset = snapshot ? CMN_DTM_PMEVCNTSR : CMN_DTM_PMEVCNT;\n\tfor_each_hw_dn(hw, dn, i) {\n\t\tif (dtm != &cmn->dtms[dn->dtm]) {\n\t\t\tdtm = &cmn->dtms[dn->dtm] + hw->dtm_offset;\n\t\t\treg = readq_relaxed(dtm->base + offset);\n\t\t}\n\t\tdtm_idx = arm_cmn_get_index(hw->dtm_idx, i);\n\t\tcount += (u16)(reg >> (dtm_idx * 16));\n\t}\n\treturn count;\n}\n\nstatic u64 arm_cmn_read_cc(struct arm_cmn_dtc *dtc)\n{\n\tu64 val = readq_relaxed(dtc->base + CMN_DT_PMCCNTR);\n\n\twriteq_relaxed(CMN_CC_INIT, dtc->base + CMN_DT_PMCCNTR);\n\treturn (val - CMN_CC_INIT) & ((CMN_CC_INIT << 1) - 1);\n}\n\nstatic u32 arm_cmn_read_counter(struct arm_cmn_dtc *dtc, int idx)\n{\n\tu32 val, pmevcnt = CMN_DT_PMEVCNT(idx);\n\n\tval = readl_relaxed(dtc->base + pmevcnt);\n\twritel_relaxed(CMN_COUNTER_INIT, dtc->base + pmevcnt);\n\treturn val - CMN_COUNTER_INIT;\n}\n\nstatic void arm_cmn_init_counter(struct perf_event *event)\n{\n\tstruct arm_cmn *cmn = to_cmn(event->pmu);\n\tstruct arm_cmn_hw_event *hw = to_cmn_hw(event);\n\tunsigned int i, pmevcnt = CMN_DT_PMEVCNT(hw->dtc_idx);\n\tu64 count;\n\n\tfor (i = 0; hw->dtcs_used & (1U << i); i++) {\n\t\twritel_relaxed(CMN_COUNTER_INIT, cmn->dtc[i].base + pmevcnt);\n\t\tcmn->dtc[i].counters[hw->dtc_idx] = event;\n\t}\n\n\tcount = arm_cmn_read_dtm(cmn, hw, false);\n\tlocal64_set(&event->hw.prev_count, count);\n}\n\nstatic void arm_cmn_event_read(struct perf_event *event)\n{\n\tstruct arm_cmn *cmn = to_cmn(event->pmu);\n\tstruct arm_cmn_hw_event *hw = to_cmn_hw(event);\n\tu64 delta, new, prev;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tif (hw->dtc_idx == CMN_DT_NUM_COUNTERS) {\n\t\ti = __ffs(hw->dtcs_used);\n\t\tdelta = arm_cmn_read_cc(cmn->dtc + i);\n\t\tlocal64_add(delta, &event->count);\n\t\treturn;\n\t}\n\tnew = arm_cmn_read_dtm(cmn, hw, false);\n\tprev = local64_xchg(&event->hw.prev_count, new);\n\n\tdelta = new - prev;\n\n\tlocal_irq_save(flags);\n\tfor (i = 0; hw->dtcs_used & (1U << i); i++) {\n\t\tnew = arm_cmn_read_counter(cmn->dtc + i, hw->dtc_idx);\n\t\tdelta += new << 16;\n\t}\n\tlocal_irq_restore(flags);\n\tlocal64_add(delta, &event->count);\n}\n\nstatic int arm_cmn_set_event_sel_hi(struct arm_cmn_node *dn,\n\t\t\t\t    enum cmn_filter_select fsel, u8 occupid)\n{\n\tu64 reg;\n\n\tif (fsel == SEL_NONE)\n\t\treturn 0;\n\n\tif (!dn->occupid[fsel].count) {\n\t\tdn->occupid[fsel].val = occupid;\n\t\treg = FIELD_PREP(CMN__PMU_CBUSY_SNTHROTTLE_SEL,\n\t\t\t\t dn->occupid[SEL_CBUSY_SNTHROTTLE_SEL].val) |\n\t\t      FIELD_PREP(CMN__PMU_SN_HOME_SEL,\n\t\t\t\t dn->occupid[SEL_SN_HOME_SEL].val) |\n\t\t      FIELD_PREP(CMN__PMU_HBT_LBT_SEL,\n\t\t\t\t dn->occupid[SEL_HBT_LBT_SEL].val) |\n\t\t      FIELD_PREP(CMN__PMU_CLASS_OCCUP_ID,\n\t\t\t\t dn->occupid[SEL_CLASS_OCCUP_ID].val) |\n\t\t      FIELD_PREP(CMN__PMU_OCCUP1_ID,\n\t\t\t\t dn->occupid[SEL_OCCUP1ID].val);\n\t\twritel_relaxed(reg >> 32, dn->pmu_base + CMN_PMU_EVENT_SEL + 4);\n\t} else if (dn->occupid[fsel].val != occupid) {\n\t\treturn -EBUSY;\n\t}\n\tdn->occupid[fsel].count++;\n\treturn 0;\n}\n\nstatic void arm_cmn_set_event_sel_lo(struct arm_cmn_node *dn, int dtm_idx,\n\t\t\t\t     int eventid, bool wide_sel)\n{\n\tif (wide_sel) {\n\t\tdn->event_w[dtm_idx] = eventid;\n\t\twriteq_relaxed(le64_to_cpu(dn->event_sel_w), dn->pmu_base + CMN_PMU_EVENT_SEL);\n\t} else {\n\t\tdn->event[dtm_idx] = eventid;\n\t\twritel_relaxed(le32_to_cpu(dn->event_sel), dn->pmu_base + CMN_PMU_EVENT_SEL);\n\t}\n}\n\nstatic void arm_cmn_event_start(struct perf_event *event, int flags)\n{\n\tstruct arm_cmn *cmn = to_cmn(event->pmu);\n\tstruct arm_cmn_hw_event *hw = to_cmn_hw(event);\n\tstruct arm_cmn_node *dn;\n\tenum cmn_node_type type = CMN_EVENT_TYPE(event);\n\tint i;\n\n\tif (type == CMN_TYPE_DTC) {\n\t\ti = __ffs(hw->dtcs_used);\n\t\twriteq_relaxed(CMN_CC_INIT, cmn->dtc[i].base + CMN_DT_PMCCNTR);\n\t\tcmn->dtc[i].cc_active = true;\n\t} else if (type == CMN_TYPE_WP) {\n\t\tint wp_idx = arm_cmn_wp_idx(event);\n\t\tu64 val = CMN_EVENT_WP_VAL(event);\n\t\tu64 mask = CMN_EVENT_WP_MASK(event);\n\n\t\tfor_each_hw_dn(hw, dn, i) {\n\t\t\tvoid __iomem *base = dn->pmu_base + CMN_DTM_OFFSET(hw->dtm_offset);\n\n\t\t\twriteq_relaxed(val, base + CMN_DTM_WPn_VAL(wp_idx));\n\t\t\twriteq_relaxed(mask, base + CMN_DTM_WPn_MASK(wp_idx));\n\t\t}\n\t} else for_each_hw_dn(hw, dn, i) {\n\t\tint dtm_idx = arm_cmn_get_index(hw->dtm_idx, i);\n\n\t\tarm_cmn_set_event_sel_lo(dn, dtm_idx, CMN_EVENT_EVENTID(event),\n\t\t\t\t\t hw->wide_sel);\n\t}\n}\n\nstatic void arm_cmn_event_stop(struct perf_event *event, int flags)\n{\n\tstruct arm_cmn *cmn = to_cmn(event->pmu);\n\tstruct arm_cmn_hw_event *hw = to_cmn_hw(event);\n\tstruct arm_cmn_node *dn;\n\tenum cmn_node_type type = CMN_EVENT_TYPE(event);\n\tint i;\n\n\tif (type == CMN_TYPE_DTC) {\n\t\ti = __ffs(hw->dtcs_used);\n\t\tcmn->dtc[i].cc_active = false;\n\t} else if (type == CMN_TYPE_WP) {\n\t\tint wp_idx = arm_cmn_wp_idx(event);\n\n\t\tfor_each_hw_dn(hw, dn, i) {\n\t\t\tvoid __iomem *base = dn->pmu_base + CMN_DTM_OFFSET(hw->dtm_offset);\n\n\t\t\twriteq_relaxed(0, base + CMN_DTM_WPn_MASK(wp_idx));\n\t\t\twriteq_relaxed(~0ULL, base + CMN_DTM_WPn_VAL(wp_idx));\n\t\t}\n\t} else for_each_hw_dn(hw, dn, i) {\n\t\tint dtm_idx = arm_cmn_get_index(hw->dtm_idx, i);\n\n\t\tarm_cmn_set_event_sel_lo(dn, dtm_idx, 0, hw->wide_sel);\n\t}\n\n\tarm_cmn_event_read(event);\n}\n\nstruct arm_cmn_val {\n\tu8 dtm_count[CMN_MAX_DTMS];\n\tu8 occupid[CMN_MAX_DTMS][SEL_MAX];\n\tu8 wp[CMN_MAX_DTMS][4];\n\tint dtc_count;\n\tbool cycles;\n};\n\nstatic void arm_cmn_val_add_event(struct arm_cmn *cmn, struct arm_cmn_val *val,\n\t\t\t\t  struct perf_event *event)\n{\n\tstruct arm_cmn_hw_event *hw = to_cmn_hw(event);\n\tstruct arm_cmn_node *dn;\n\tenum cmn_node_type type;\n\tint i;\n\n\tif (is_software_event(event))\n\t\treturn;\n\n\ttype = CMN_EVENT_TYPE(event);\n\tif (type == CMN_TYPE_DTC) {\n\t\tval->cycles = true;\n\t\treturn;\n\t}\n\n\tval->dtc_count++;\n\n\tfor_each_hw_dn(hw, dn, i) {\n\t\tint wp_idx, dtm = dn->dtm, sel = hw->filter_sel;\n\n\t\tval->dtm_count[dtm]++;\n\n\t\tif (sel > SEL_NONE)\n\t\t\tval->occupid[dtm][sel] = CMN_EVENT_OCCUPID(event) + 1;\n\n\t\tif (type != CMN_TYPE_WP)\n\t\t\tcontinue;\n\n\t\twp_idx = arm_cmn_wp_idx(event);\n\t\tval->wp[dtm][wp_idx] = CMN_EVENT_WP_COMBINE(event) + 1;\n\t}\n}\n\nstatic int arm_cmn_validate_group(struct arm_cmn *cmn, struct perf_event *event)\n{\n\tstruct arm_cmn_hw_event *hw = to_cmn_hw(event);\n\tstruct arm_cmn_node *dn;\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tenum cmn_node_type type;\n\tstruct arm_cmn_val *val;\n\tint i, ret = -EINVAL;\n\n\tif (leader == event)\n\t\treturn 0;\n\n\tif (event->pmu != leader->pmu && !is_software_event(leader))\n\t\treturn -EINVAL;\n\n\tval = kzalloc(sizeof(*val), GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\n\tarm_cmn_val_add_event(cmn, val, leader);\n\tfor_each_sibling_event(sibling, leader)\n\t\tarm_cmn_val_add_event(cmn, val, sibling);\n\n\ttype = CMN_EVENT_TYPE(event);\n\tif (type == CMN_TYPE_DTC) {\n\t\tret = val->cycles ? -EINVAL : 0;\n\t\tgoto done;\n\t}\n\n\tif (val->dtc_count == CMN_DT_NUM_COUNTERS)\n\t\tgoto done;\n\n\tfor_each_hw_dn(hw, dn, i) {\n\t\tint wp_idx, wp_cmb, dtm = dn->dtm, sel = hw->filter_sel;\n\n\t\tif (val->dtm_count[dtm] == CMN_DTM_NUM_COUNTERS)\n\t\t\tgoto done;\n\n\t\tif (sel > SEL_NONE && val->occupid[dtm][sel] &&\n\t\t    val->occupid[dtm][sel] != CMN_EVENT_OCCUPID(event) + 1)\n\t\t\tgoto done;\n\n\t\tif (type != CMN_TYPE_WP)\n\t\t\tcontinue;\n\n\t\twp_idx = arm_cmn_wp_idx(event);\n\t\tif (val->wp[dtm][wp_idx])\n\t\t\tgoto done;\n\n\t\twp_cmb = val->wp[dtm][wp_idx ^ 1];\n\t\tif (wp_cmb && wp_cmb != CMN_EVENT_WP_COMBINE(event) + 1)\n\t\t\tgoto done;\n\t}\n\n\tret = 0;\ndone:\n\tkfree(val);\n\treturn ret;\n}\n\nstatic enum cmn_filter_select arm_cmn_filter_sel(const struct arm_cmn *cmn,\n\t\t\t\t\t\t enum cmn_node_type type,\n\t\t\t\t\t\t unsigned int eventid)\n{\n\tstruct arm_cmn_event_attr *e;\n\tenum cmn_model model = arm_cmn_model(cmn);\n\n\tfor (int i = 0; i < ARRAY_SIZE(arm_cmn_event_attrs) - 1; i++) {\n\t\te = container_of(arm_cmn_event_attrs[i], typeof(*e), attr.attr);\n\t\tif (e->model & model && e->type == type && e->eventid == eventid)\n\t\t\treturn e->fsel;\n\t}\n\treturn SEL_NONE;\n}\n\n\nstatic int arm_cmn_event_init(struct perf_event *event)\n{\n\tstruct arm_cmn *cmn = to_cmn(event->pmu);\n\tstruct arm_cmn_hw_event *hw = to_cmn_hw(event);\n\tstruct arm_cmn_node *dn;\n\tenum cmn_node_type type;\n\tbool bynodeid;\n\tu16 nodeid, eventid;\n\n\tif (event->attr.type != event->pmu->type)\n\t\treturn -ENOENT;\n\n\tif (is_sampling_event(event) || event->attach_state & PERF_ATTACH_TASK)\n\t\treturn -EINVAL;\n\n\tevent->cpu = cmn->cpu;\n\tif (event->cpu < 0)\n\t\treturn -EINVAL;\n\n\ttype = CMN_EVENT_TYPE(event);\n\t \n\tif (type == CMN_TYPE_DTC)\n\t\treturn arm_cmn_validate_group(cmn, event);\n\n\teventid = CMN_EVENT_EVENTID(event);\n\t \n\tif (type == CMN_TYPE_WP) {\n\t\ttype = CMN_TYPE_XP;\n\t\t \n\t\tif (eventid != CMN_WP_UP && eventid != CMN_WP_DOWN)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (cmn->multi_dtm)\n\t\t\thw->dtm_offset = CMN_EVENT_WP_DEV_SEL(event) / 2;\n\t} else if (type == CMN_TYPE_XP && cmn->part == PART_CMN700) {\n\t\thw->wide_sel = true;\n\t}\n\n\t \n\thw->filter_sel = arm_cmn_filter_sel(cmn, type, eventid);\n\n\tbynodeid = CMN_EVENT_BYNODEID(event);\n\tnodeid = CMN_EVENT_NODEID(event);\n\n\thw->dn = arm_cmn_node(cmn, type);\n\tif (!hw->dn)\n\t\treturn -EINVAL;\n\tfor (dn = hw->dn; dn->type == type; dn++) {\n\t\tif (bynodeid && dn->id != nodeid) {\n\t\t\thw->dn++;\n\t\t\tcontinue;\n\t\t}\n\t\thw->num_dns++;\n\t\tif (bynodeid)\n\t\t\tbreak;\n\t}\n\n\tif (!hw->num_dns) {\n\t\tstruct arm_cmn_nodeid nid = arm_cmn_nid(cmn, nodeid);\n\n\t\tdev_dbg(cmn->dev, \"invalid node 0x%x (%d,%d,%d,%d) type 0x%x\\n\",\n\t\t\tnodeid, nid.x, nid.y, nid.port, nid.dev, type);\n\t\treturn -EINVAL;\n\t}\n\t \n\thw->dtcs_used = (1U << cmn->num_dtcs) - 1;\n\n\treturn arm_cmn_validate_group(cmn, event);\n}\n\nstatic void arm_cmn_event_clear(struct arm_cmn *cmn, struct perf_event *event,\n\t\t\t\tint i)\n{\n\tstruct arm_cmn_hw_event *hw = to_cmn_hw(event);\n\tenum cmn_node_type type = CMN_EVENT_TYPE(event);\n\n\twhile (i--) {\n\t\tstruct arm_cmn_dtm *dtm = &cmn->dtms[hw->dn[i].dtm] + hw->dtm_offset;\n\t\tunsigned int dtm_idx = arm_cmn_get_index(hw->dtm_idx, i);\n\n\t\tif (type == CMN_TYPE_WP)\n\t\t\tdtm->wp_event[arm_cmn_wp_idx(event)] = -1;\n\n\t\tif (hw->filter_sel > SEL_NONE)\n\t\t\thw->dn[i].occupid[hw->filter_sel].count--;\n\n\t\tdtm->pmu_config_low &= ~CMN__PMEVCNT_PAIRED(dtm_idx);\n\t\twritel_relaxed(dtm->pmu_config_low, dtm->base + CMN_DTM_PMU_CONFIG);\n\t}\n\tmemset(hw->dtm_idx, 0, sizeof(hw->dtm_idx));\n\n\tfor (i = 0; hw->dtcs_used & (1U << i); i++)\n\t\tcmn->dtc[i].counters[hw->dtc_idx] = NULL;\n}\n\nstatic int arm_cmn_event_add(struct perf_event *event, int flags)\n{\n\tstruct arm_cmn *cmn = to_cmn(event->pmu);\n\tstruct arm_cmn_hw_event *hw = to_cmn_hw(event);\n\tstruct arm_cmn_dtc *dtc = &cmn->dtc[0];\n\tstruct arm_cmn_node *dn;\n\tenum cmn_node_type type = CMN_EVENT_TYPE(event);\n\tunsigned int i, dtc_idx, input_sel;\n\n\tif (type == CMN_TYPE_DTC) {\n\t\ti = 0;\n\t\twhile (cmn->dtc[i].cycles)\n\t\t\tif (++i == cmn->num_dtcs)\n\t\t\t\treturn -ENOSPC;\n\n\t\tcmn->dtc[i].cycles = event;\n\t\thw->dtc_idx = CMN_DT_NUM_COUNTERS;\n\t\thw->dtcs_used = 1U << i;\n\n\t\tif (flags & PERF_EF_START)\n\t\t\tarm_cmn_event_start(event, 0);\n\t\treturn 0;\n\t}\n\n\t \n\tdtc_idx = 0;\n\twhile (dtc->counters[dtc_idx])\n\t\tif (++dtc_idx == CMN_DT_NUM_COUNTERS)\n\t\t\treturn -ENOSPC;\n\n\thw->dtc_idx = dtc_idx;\n\n\t \n\tfor_each_hw_dn(hw, dn, i) {\n\t\tstruct arm_cmn_dtm *dtm = &cmn->dtms[dn->dtm] + hw->dtm_offset;\n\t\tunsigned int dtm_idx, shift;\n\t\tu64 reg;\n\n\t\tdtm_idx = 0;\n\t\twhile (dtm->pmu_config_low & CMN__PMEVCNT_PAIRED(dtm_idx))\n\t\t\tif (++dtm_idx == CMN_DTM_NUM_COUNTERS)\n\t\t\t\tgoto free_dtms;\n\n\t\tif (type == CMN_TYPE_XP) {\n\t\t\tinput_sel = CMN__PMEVCNT0_INPUT_SEL_XP + dtm_idx;\n\t\t} else if (type == CMN_TYPE_WP) {\n\t\t\tint tmp, wp_idx = arm_cmn_wp_idx(event);\n\t\t\tu32 cfg = arm_cmn_wp_config(event);\n\n\t\t\tif (dtm->wp_event[wp_idx] >= 0)\n\t\t\t\tgoto free_dtms;\n\n\t\t\ttmp = dtm->wp_event[wp_idx ^ 1];\n\t\t\tif (tmp >= 0 && CMN_EVENT_WP_COMBINE(event) !=\n\t\t\t\t\tCMN_EVENT_WP_COMBINE(dtc->counters[tmp]))\n\t\t\t\tgoto free_dtms;\n\n\t\t\tinput_sel = CMN__PMEVCNT0_INPUT_SEL_WP + wp_idx;\n\t\t\tdtm->wp_event[wp_idx] = dtc_idx;\n\t\t\twritel_relaxed(cfg, dtm->base + CMN_DTM_WPn_CONFIG(wp_idx));\n\t\t} else {\n\t\t\tstruct arm_cmn_nodeid nid = arm_cmn_nid(cmn, dn->id);\n\n\t\t\tif (cmn->multi_dtm)\n\t\t\t\tnid.port %= 2;\n\n\t\t\tinput_sel = CMN__PMEVCNT0_INPUT_SEL_DEV + dtm_idx +\n\t\t\t\t    (nid.port << 4) + (nid.dev << 2);\n\n\t\t\tif (arm_cmn_set_event_sel_hi(dn, hw->filter_sel, CMN_EVENT_OCCUPID(event)))\n\t\t\t\tgoto free_dtms;\n\t\t}\n\n\t\tarm_cmn_set_index(hw->dtm_idx, i, dtm_idx);\n\n\t\tdtm->input_sel[dtm_idx] = input_sel;\n\t\tshift = CMN__PMEVCNTn_GLOBAL_NUM_SHIFT(dtm_idx);\n\t\tdtm->pmu_config_low &= ~(CMN__PMEVCNT0_GLOBAL_NUM << shift);\n\t\tdtm->pmu_config_low |= FIELD_PREP(CMN__PMEVCNT0_GLOBAL_NUM, dtc_idx) << shift;\n\t\tdtm->pmu_config_low |= CMN__PMEVCNT_PAIRED(dtm_idx);\n\t\treg = (u64)le32_to_cpu(dtm->pmu_config_high) << 32 | dtm->pmu_config_low;\n\t\twriteq_relaxed(reg, dtm->base + CMN_DTM_PMU_CONFIG);\n\t}\n\n\t \n\tarm_cmn_init_counter(event);\n\n\tif (flags & PERF_EF_START)\n\t\tarm_cmn_event_start(event, 0);\n\n\treturn 0;\n\nfree_dtms:\n\tarm_cmn_event_clear(cmn, event, i);\n\treturn -ENOSPC;\n}\n\nstatic void arm_cmn_event_del(struct perf_event *event, int flags)\n{\n\tstruct arm_cmn *cmn = to_cmn(event->pmu);\n\tstruct arm_cmn_hw_event *hw = to_cmn_hw(event);\n\tenum cmn_node_type type = CMN_EVENT_TYPE(event);\n\n\tarm_cmn_event_stop(event, PERF_EF_UPDATE);\n\n\tif (type == CMN_TYPE_DTC)\n\t\tcmn->dtc[__ffs(hw->dtcs_used)].cycles = NULL;\n\telse\n\t\tarm_cmn_event_clear(cmn, event, hw->num_dns);\n}\n\n \nstatic void arm_cmn_start_txn(struct pmu *pmu, unsigned int flags)\n{\n\tarm_cmn_set_state(to_cmn(pmu), CMN_STATE_TXN);\n}\n\nstatic void arm_cmn_end_txn(struct pmu *pmu)\n{\n\tarm_cmn_clear_state(to_cmn(pmu), CMN_STATE_TXN);\n}\n\nstatic int arm_cmn_commit_txn(struct pmu *pmu)\n{\n\tarm_cmn_end_txn(pmu);\n\treturn 0;\n}\n\nstatic void arm_cmn_migrate(struct arm_cmn *cmn, unsigned int cpu)\n{\n\tunsigned int i;\n\n\tperf_pmu_migrate_context(&cmn->pmu, cmn->cpu, cpu);\n\tfor (i = 0; i < cmn->num_dtcs; i++)\n\t\tirq_set_affinity(cmn->dtc[i].irq, cpumask_of(cpu));\n\tcmn->cpu = cpu;\n}\n\nstatic int arm_cmn_pmu_online_cpu(unsigned int cpu, struct hlist_node *cpuhp_node)\n{\n\tstruct arm_cmn *cmn;\n\tint node;\n\n\tcmn = hlist_entry_safe(cpuhp_node, struct arm_cmn, cpuhp_node);\n\tnode = dev_to_node(cmn->dev);\n\tif (node != NUMA_NO_NODE && cpu_to_node(cmn->cpu) != node && cpu_to_node(cpu) == node)\n\t\tarm_cmn_migrate(cmn, cpu);\n\treturn 0;\n}\n\nstatic int arm_cmn_pmu_offline_cpu(unsigned int cpu, struct hlist_node *cpuhp_node)\n{\n\tstruct arm_cmn *cmn;\n\tunsigned int target;\n\tint node;\n\tcpumask_t mask;\n\n\tcmn = hlist_entry_safe(cpuhp_node, struct arm_cmn, cpuhp_node);\n\tif (cpu != cmn->cpu)\n\t\treturn 0;\n\n\tnode = dev_to_node(cmn->dev);\n\tif (cpumask_and(&mask, cpumask_of_node(node), cpu_online_mask) &&\n\t    cpumask_andnot(&mask, &mask, cpumask_of(cpu)))\n\t\ttarget = cpumask_any(&mask);\n\telse\n\t\ttarget = cpumask_any_but(cpu_online_mask, cpu);\n\tif (target < nr_cpu_ids)\n\t\tarm_cmn_migrate(cmn, target);\n\treturn 0;\n}\n\nstatic irqreturn_t arm_cmn_handle_irq(int irq, void *dev_id)\n{\n\tstruct arm_cmn_dtc *dtc = dev_id;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tfor (;;) {\n\t\tu32 status = readl_relaxed(dtc->base + CMN_DT_PMOVSR);\n\t\tu64 delta;\n\t\tint i;\n\n\t\tfor (i = 0; i < CMN_DT_NUM_COUNTERS; i++) {\n\t\t\tif (status & (1U << i)) {\n\t\t\t\tret = IRQ_HANDLED;\n\t\t\t\tif (WARN_ON(!dtc->counters[i]))\n\t\t\t\t\tcontinue;\n\t\t\t\tdelta = (u64)arm_cmn_read_counter(dtc, i) << 16;\n\t\t\t\tlocal64_add(delta, &dtc->counters[i]->count);\n\t\t\t}\n\t\t}\n\n\t\tif (status & (1U << CMN_DT_NUM_COUNTERS)) {\n\t\t\tret = IRQ_HANDLED;\n\t\t\tif (dtc->cc_active && !WARN_ON(!dtc->cycles)) {\n\t\t\t\tdelta = arm_cmn_read_cc(dtc);\n\t\t\t\tlocal64_add(delta, &dtc->cycles->count);\n\t\t\t}\n\t\t}\n\n\t\twritel_relaxed(status, dtc->base + CMN_DT_PMOVSR_CLR);\n\n\t\tif (!dtc->irq_friend)\n\t\t\treturn ret;\n\t\tdtc += dtc->irq_friend;\n\t}\n}\n\n \nstatic int arm_cmn_init_irqs(struct arm_cmn *cmn)\n{\n\tint i, j, irq, err;\n\n\tfor (i = 0; i < cmn->num_dtcs; i++) {\n\t\tirq = cmn->dtc[i].irq;\n\t\tfor (j = i; j--; ) {\n\t\t\tif (cmn->dtc[j].irq == irq) {\n\t\t\t\tcmn->dtc[j].irq_friend = i - j;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\terr = devm_request_irq(cmn->dev, irq, arm_cmn_handle_irq,\n\t\t\t\t       IRQF_NOBALANCING | IRQF_NO_THREAD,\n\t\t\t\t       dev_name(cmn->dev), &cmn->dtc[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = irq_set_affinity(irq, cpumask_of(cmn->cpu));\n\t\tif (err)\n\t\t\treturn err;\n\tnext:\n\t\t;  \n\t}\n\treturn 0;\n}\n\nstatic void arm_cmn_init_dtm(struct arm_cmn_dtm *dtm, struct arm_cmn_node *xp, int idx)\n{\n\tint i;\n\n\tdtm->base = xp->pmu_base + CMN_DTM_OFFSET(idx);\n\tdtm->pmu_config_low = CMN_DTM_PMU_CONFIG_PMU_EN;\n\twriteq_relaxed(dtm->pmu_config_low, dtm->base + CMN_DTM_PMU_CONFIG);\n\tfor (i = 0; i < 4; i++) {\n\t\tdtm->wp_event[i] = -1;\n\t\twriteq_relaxed(0, dtm->base + CMN_DTM_WPn_MASK(i));\n\t\twriteq_relaxed(~0ULL, dtm->base + CMN_DTM_WPn_VAL(i));\n\t}\n}\n\nstatic int arm_cmn_init_dtc(struct arm_cmn *cmn, struct arm_cmn_node *dn, int idx)\n{\n\tstruct arm_cmn_dtc *dtc = cmn->dtc + idx;\n\n\tdtc->base = dn->pmu_base - CMN_PMU_OFFSET;\n\tdtc->irq = platform_get_irq(to_platform_device(cmn->dev), idx);\n\tif (dtc->irq < 0)\n\t\treturn dtc->irq;\n\n\twritel_relaxed(CMN_DT_DTC_CTL_DT_EN, dtc->base + CMN_DT_DTC_CTL);\n\twritel_relaxed(CMN_DT_PMCR_PMU_EN | CMN_DT_PMCR_OVFL_INTR_EN, dtc->base + CMN_DT_PMCR);\n\twriteq_relaxed(0, dtc->base + CMN_DT_PMCCNTR);\n\twritel_relaxed(0x1ff, dtc->base + CMN_DT_PMOVSR_CLR);\n\n\treturn 0;\n}\n\nstatic int arm_cmn_node_cmp(const void *a, const void *b)\n{\n\tconst struct arm_cmn_node *dna = a, *dnb = b;\n\tint cmp;\n\n\tcmp = dna->type - dnb->type;\n\tif (!cmp)\n\t\tcmp = dna->logid - dnb->logid;\n\treturn cmp;\n}\n\nstatic int arm_cmn_init_dtcs(struct arm_cmn *cmn)\n{\n\tstruct arm_cmn_node *dn, *xp;\n\tint dtc_idx = 0;\n\tu8 dtcs_present = (1 << cmn->num_dtcs) - 1;\n\n\tcmn->dtc = devm_kcalloc(cmn->dev, cmn->num_dtcs, sizeof(cmn->dtc[0]), GFP_KERNEL);\n\tif (!cmn->dtc)\n\t\treturn -ENOMEM;\n\n\tsort(cmn->dns, cmn->num_dns, sizeof(cmn->dns[0]), arm_cmn_node_cmp, NULL);\n\n\tcmn->xps = arm_cmn_node(cmn, CMN_TYPE_XP);\n\n\tfor (dn = cmn->dns; dn->type; dn++) {\n\t\tif (dn->type == CMN_TYPE_XP) {\n\t\t\tdn->dtc &= dtcs_present;\n\t\t\tcontinue;\n\t\t}\n\n\t\txp = arm_cmn_node_to_xp(cmn, dn);\n\t\tdn->dtm = xp->dtm;\n\t\tif (cmn->multi_dtm)\n\t\t\tdn->dtm += arm_cmn_nid(cmn, dn->id).port / 2;\n\n\t\tif (dn->type == CMN_TYPE_DTC) {\n\t\t\tint err;\n\t\t\t \n\t\t\tif (xp->dtc == 0xf)\n\t\t\t\txp->dtc = 1 << dtc_idx;\n\t\t\terr = arm_cmn_init_dtc(cmn, dn, dtc_idx++);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tif (dn->type == CMN_TYPE_RND)\n\t\t\tdn->type = CMN_TYPE_RNI;\n\n\t\t \n\t\tif (dn->type == CMN_TYPE_CCLA_RNI)\n\t\t\tdn->type = CMN_TYPE_CCLA;\n\t}\n\n\tarm_cmn_set_state(cmn, CMN_STATE_DISABLED);\n\n\treturn 0;\n}\n\nstatic unsigned int arm_cmn_dtc_domain(struct arm_cmn *cmn, void __iomem *xp_region)\n{\n\tint offset = CMN_DTM_UNIT_INFO;\n\n\tif (cmn->part == PART_CMN650 || cmn->part == PART_CI700)\n\t\toffset = CMN650_DTM_UNIT_INFO;\n\n\treturn FIELD_GET(CMN_DTM_UNIT_INFO_DTC_DOMAIN, readl_relaxed(xp_region + offset));\n}\n\nstatic void arm_cmn_init_node_info(struct arm_cmn *cmn, u32 offset, struct arm_cmn_node *node)\n{\n\tint level;\n\tu64 reg = readq_relaxed(cmn->base + offset + CMN_NODE_INFO);\n\n\tnode->type = FIELD_GET(CMN_NI_NODE_TYPE, reg);\n\tnode->id = FIELD_GET(CMN_NI_NODE_ID, reg);\n\tnode->logid = FIELD_GET(CMN_NI_LOGICAL_ID, reg);\n\n\tnode->pmu_base = cmn->base + offset + CMN_PMU_OFFSET;\n\n\tif (node->type == CMN_TYPE_CFG)\n\t\tlevel = 0;\n\telse if (node->type == CMN_TYPE_XP)\n\t\tlevel = 1;\n\telse\n\t\tlevel = 2;\n\n\tdev_dbg(cmn->dev, \"node%*c%#06hx%*ctype:%-#6x id:%-4hd off:%#x\\n\",\n\t\t\t(level * 2) + 1, ' ', node->id, 5 - (level * 2), ' ',\n\t\t\tnode->type, node->logid, offset);\n}\n\nstatic enum cmn_node_type arm_cmn_subtype(enum cmn_node_type type)\n{\n\tswitch (type) {\n\tcase CMN_TYPE_HNP:\n\t\treturn CMN_TYPE_HNI;\n\tcase CMN_TYPE_CCLA_RNI:\n\t\treturn CMN_TYPE_RNI;\n\tdefault:\n\t\treturn CMN_TYPE_INVALID;\n\t}\n}\n\nstatic int arm_cmn_discover(struct arm_cmn *cmn, unsigned int rgn_offset)\n{\n\tvoid __iomem *cfg_region;\n\tstruct arm_cmn_node cfg, *dn;\n\tstruct arm_cmn_dtm *dtm;\n\tenum cmn_part part;\n\tu16 child_count, child_poff;\n\tu32 xp_offset[CMN_MAX_XPS];\n\tu64 reg;\n\tint i, j;\n\tsize_t sz;\n\n\tarm_cmn_init_node_info(cmn, rgn_offset, &cfg);\n\tif (cfg.type != CMN_TYPE_CFG)\n\t\treturn -ENODEV;\n\n\tcfg_region = cmn->base + rgn_offset;\n\n\treg = readq_relaxed(cfg_region + CMN_CFGM_PERIPH_ID_01);\n\tpart = FIELD_GET(CMN_CFGM_PID0_PART_0, reg);\n\tpart |= FIELD_GET(CMN_CFGM_PID1_PART_1, reg) << 8;\n\tif (cmn->part && cmn->part != part)\n\t\tdev_warn(cmn->dev,\n\t\t\t \"Firmware binding mismatch: expected part number 0x%x, found 0x%x\\n\",\n\t\t\t cmn->part, part);\n\tcmn->part = part;\n\tif (!arm_cmn_model(cmn))\n\t\tdev_warn(cmn->dev, \"Unknown part number: 0x%x\\n\", part);\n\n\treg = readl_relaxed(cfg_region + CMN_CFGM_PERIPH_ID_23);\n\tcmn->rev = FIELD_GET(CMN_CFGM_PID2_REVISION, reg);\n\n\treg = readq_relaxed(cfg_region + CMN_CFGM_INFO_GLOBAL);\n\tcmn->multi_dtm = reg & CMN_INFO_MULTIPLE_DTM_EN;\n\tcmn->rsp_vc_num = FIELD_GET(CMN_INFO_RSP_VC_NUM, reg);\n\tcmn->dat_vc_num = FIELD_GET(CMN_INFO_DAT_VC_NUM, reg);\n\n\treg = readq_relaxed(cfg_region + CMN_CFGM_INFO_GLOBAL_1);\n\tcmn->snp_vc_num = FIELD_GET(CMN_INFO_SNP_VC_NUM, reg);\n\tcmn->req_vc_num = FIELD_GET(CMN_INFO_REQ_VC_NUM, reg);\n\n\treg = readq_relaxed(cfg_region + CMN_CHILD_INFO);\n\tchild_count = FIELD_GET(CMN_CI_CHILD_COUNT, reg);\n\tchild_poff = FIELD_GET(CMN_CI_CHILD_PTR_OFFSET, reg);\n\n\tcmn->num_xps = child_count;\n\tcmn->num_dns = cmn->num_xps;\n\n\t \n\tfor (i = 0; i < cmn->num_xps; i++) {\n\t\treg = readq_relaxed(cfg_region + child_poff + i * 8);\n\t\txp_offset[i] = reg & CMN_CHILD_NODE_ADDR;\n\n\t\treg = readq_relaxed(cmn->base + xp_offset[i] + CMN_CHILD_INFO);\n\t\tcmn->num_dns += FIELD_GET(CMN_CI_CHILD_COUNT, reg);\n\t}\n\n\t \n\tdn = devm_kcalloc(cmn->dev, cmn->num_dns * 2 - cmn->num_xps,\n\t\t\t  sizeof(*dn), GFP_KERNEL);\n\tif (!dn)\n\t\treturn -ENOMEM;\n\n\t \n\ti = cmn->num_xps;\n\tif (cmn->multi_dtm)\n\t\ti += cmn->num_xps + 1;\n\tdtm = devm_kcalloc(cmn->dev, i, sizeof(*dtm), GFP_KERNEL);\n\tif (!dtm)\n\t\treturn -ENOMEM;\n\n\t \n\tcmn->dns = dn;\n\tcmn->dtms = dtm;\n\tfor (i = 0; i < cmn->num_xps; i++) {\n\t\tvoid __iomem *xp_region = cmn->base + xp_offset[i];\n\t\tstruct arm_cmn_node *xp = dn++;\n\t\tunsigned int xp_ports = 0;\n\n\t\tarm_cmn_init_node_info(cmn, xp_offset[i], xp);\n\t\t \n\t\tif (xp->id == (1 << 3))\n\t\t\tcmn->mesh_x = xp->logid;\n\n\t\tif (cmn->part == PART_CMN600)\n\t\t\txp->dtc = 0xf;\n\t\telse\n\t\t\txp->dtc = 1 << arm_cmn_dtc_domain(cmn, xp_region);\n\n\t\txp->dtm = dtm - cmn->dtms;\n\t\tarm_cmn_init_dtm(dtm++, xp, 0);\n\t\t \n\t\tfor (int p = 0; p < CMN_MAX_PORTS; p++)\n\t\t\tif (arm_cmn_device_connect_info(cmn, xp, p))\n\t\t\t\txp_ports |= BIT(p);\n\n\t\tif (cmn->multi_dtm && (xp_ports & 0xc))\n\t\t\tarm_cmn_init_dtm(dtm++, xp, 1);\n\t\tif (cmn->multi_dtm && (xp_ports & 0x30))\n\t\t\tarm_cmn_init_dtm(dtm++, xp, 2);\n\n\t\tcmn->ports_used |= xp_ports;\n\n\t\treg = readq_relaxed(xp_region + CMN_CHILD_INFO);\n\t\tchild_count = FIELD_GET(CMN_CI_CHILD_COUNT, reg);\n\t\tchild_poff = FIELD_GET(CMN_CI_CHILD_PTR_OFFSET, reg);\n\n\t\tfor (j = 0; j < child_count; j++) {\n\t\t\treg = readq_relaxed(xp_region + child_poff + j * 8);\n\t\t\t \n\t\t\tif (reg & CMN_CHILD_NODE_EXTERNAL) {\n\t\t\t\tdev_dbg(cmn->dev, \"ignoring external node %llx\\n\", reg);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tarm_cmn_init_node_info(cmn, reg & CMN_CHILD_NODE_ADDR, dn);\n\n\t\t\tswitch (dn->type) {\n\t\t\tcase CMN_TYPE_DTC:\n\t\t\t\tcmn->num_dtcs++;\n\t\t\t\tdn++;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase CMN_TYPE_DVM:\n\t\t\tcase CMN_TYPE_HNI:\n\t\t\tcase CMN_TYPE_HNF:\n\t\t\tcase CMN_TYPE_SBSX:\n\t\t\tcase CMN_TYPE_RNI:\n\t\t\tcase CMN_TYPE_RND:\n\t\t\tcase CMN_TYPE_MTSX:\n\t\t\tcase CMN_TYPE_CXRA:\n\t\t\tcase CMN_TYPE_CXHA:\n\t\t\tcase CMN_TYPE_CCRA:\n\t\t\tcase CMN_TYPE_CCHA:\n\t\t\tcase CMN_TYPE_CCLA:\n\t\t\tcase CMN_TYPE_HNS:\n\t\t\t\tdn++;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase CMN_TYPE_MPAM_S:\n\t\t\tcase CMN_TYPE_MPAM_NS:\n\t\t\tcase CMN_TYPE_RNSAM:\n\t\t\tcase CMN_TYPE_CXLA:\n\t\t\tcase CMN_TYPE_HNS_MPAM_S:\n\t\t\tcase CMN_TYPE_HNS_MPAM_NS:\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase CMN_TYPE_HNP:\n\t\t\tcase CMN_TYPE_CCLA_RNI:\n\t\t\t\tdn[1] = dn[0];\n\t\t\t\tdn[0].pmu_base += CMN_HNP_PMU_EVENT_SEL;\n\t\t\t\tdn[1].type = arm_cmn_subtype(dn->type);\n\t\t\t\tdn += 2;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tdefault:\n\t\t\t\tdev_err(cmn->dev, \"invalid device node type: 0x%x\\n\", dn->type);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tcmn->num_dns = dn - cmn->dns;\n\n\t \n\tsz = (void *)(dn + 1) - (void *)cmn->dns;\n\tdn = devm_krealloc(cmn->dev, cmn->dns, sz, GFP_KERNEL);\n\tif (dn)\n\t\tcmn->dns = dn;\n\n\tsz = (void *)dtm - (void *)cmn->dtms;\n\tdtm = devm_krealloc(cmn->dev, cmn->dtms, sz, GFP_KERNEL);\n\tif (dtm)\n\t\tcmn->dtms = dtm;\n\n\t \n\tif (!cmn->mesh_x)\n\t\tcmn->mesh_x = cmn->num_xps;\n\tcmn->mesh_y = cmn->num_xps / cmn->mesh_x;\n\n\t \n\tif (cmn->num_xps == 1)\n\t\tdev_warn(cmn->dev, \"1x1 config not fully supported, translate XP events manually\\n\");\n\n\tdev_dbg(cmn->dev, \"periph_id part 0x%03x revision %d\\n\", cmn->part, cmn->rev);\n\treg = cmn->ports_used;\n\tdev_dbg(cmn->dev, \"mesh %dx%d, ID width %d, ports %6pbl%s\\n\",\n\t\tcmn->mesh_x, cmn->mesh_y, arm_cmn_xyidbits(cmn), &reg,\n\t\tcmn->multi_dtm ? \", multi-DTM\" : \"\");\n\n\treturn 0;\n}\n\nstatic int arm_cmn600_acpi_probe(struct platform_device *pdev, struct arm_cmn *cmn)\n{\n\tstruct resource *cfg, *root;\n\n\tcfg = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!cfg)\n\t\treturn -EINVAL;\n\n\troot = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\tif (!resource_contains(cfg, root))\n\t\tswap(cfg, root);\n\t \n\tcmn->base = devm_ioremap(cmn->dev, cfg->start, resource_size(cfg));\n\tif (!cmn->base)\n\t\treturn -ENOMEM;\n\n\treturn root->start - cfg->start;\n}\n\nstatic int arm_cmn600_of_probe(struct device_node *np)\n{\n\tu32 rootnode;\n\n\treturn of_property_read_u32(np, \"arm,root-node\", &rootnode) ?: rootnode;\n}\n\nstatic int arm_cmn_probe(struct platform_device *pdev)\n{\n\tstruct arm_cmn *cmn;\n\tconst char *name;\n\tstatic atomic_t id;\n\tint err, rootnode, this_id;\n\n\tcmn = devm_kzalloc(&pdev->dev, sizeof(*cmn), GFP_KERNEL);\n\tif (!cmn)\n\t\treturn -ENOMEM;\n\n\tcmn->dev = &pdev->dev;\n\tcmn->part = (unsigned long)device_get_match_data(cmn->dev);\n\tplatform_set_drvdata(pdev, cmn);\n\n\tif (cmn->part == PART_CMN600 && has_acpi_companion(cmn->dev)) {\n\t\trootnode = arm_cmn600_acpi_probe(pdev, cmn);\n\t} else {\n\t\trootnode = 0;\n\t\tcmn->base = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(cmn->base))\n\t\t\treturn PTR_ERR(cmn->base);\n\t\tif (cmn->part == PART_CMN600)\n\t\t\trootnode = arm_cmn600_of_probe(pdev->dev.of_node);\n\t}\n\tif (rootnode < 0)\n\t\treturn rootnode;\n\n\terr = arm_cmn_discover(cmn, rootnode);\n\tif (err)\n\t\treturn err;\n\n\terr = arm_cmn_init_dtcs(cmn);\n\tif (err)\n\t\treturn err;\n\n\terr = arm_cmn_init_irqs(cmn);\n\tif (err)\n\t\treturn err;\n\n\tcmn->cpu = cpumask_local_spread(0, dev_to_node(cmn->dev));\n\tcmn->pmu = (struct pmu) {\n\t\t.module = THIS_MODULE,\n\t\t.attr_groups = arm_cmn_attr_groups,\n\t\t.capabilities = PERF_PMU_CAP_NO_EXCLUDE,\n\t\t.task_ctx_nr = perf_invalid_context,\n\t\t.pmu_enable = arm_cmn_pmu_enable,\n\t\t.pmu_disable = arm_cmn_pmu_disable,\n\t\t.event_init = arm_cmn_event_init,\n\t\t.add = arm_cmn_event_add,\n\t\t.del = arm_cmn_event_del,\n\t\t.start = arm_cmn_event_start,\n\t\t.stop = arm_cmn_event_stop,\n\t\t.read = arm_cmn_event_read,\n\t\t.start_txn = arm_cmn_start_txn,\n\t\t.commit_txn = arm_cmn_commit_txn,\n\t\t.cancel_txn = arm_cmn_end_txn,\n\t};\n\n\tthis_id = atomic_fetch_inc(&id);\n\tname = devm_kasprintf(cmn->dev, GFP_KERNEL, \"arm_cmn_%d\", this_id);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\terr = cpuhp_state_add_instance(arm_cmn_hp_state, &cmn->cpuhp_node);\n\tif (err)\n\t\treturn err;\n\n\terr = perf_pmu_register(&cmn->pmu, name, -1);\n\tif (err)\n\t\tcpuhp_state_remove_instance_nocalls(arm_cmn_hp_state, &cmn->cpuhp_node);\n\telse\n\t\tarm_cmn_debugfs_init(cmn, this_id);\n\n\treturn err;\n}\n\nstatic int arm_cmn_remove(struct platform_device *pdev)\n{\n\tstruct arm_cmn *cmn = platform_get_drvdata(pdev);\n\n\twritel_relaxed(0, cmn->dtc[0].base + CMN_DT_DTC_CTL);\n\n\tperf_pmu_unregister(&cmn->pmu);\n\tcpuhp_state_remove_instance_nocalls(arm_cmn_hp_state, &cmn->cpuhp_node);\n\tdebugfs_remove(cmn->debug);\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id arm_cmn_of_match[] = {\n\t{ .compatible = \"arm,cmn-600\", .data = (void *)PART_CMN600 },\n\t{ .compatible = \"arm,cmn-650\" },\n\t{ .compatible = \"arm,cmn-700\" },\n\t{ .compatible = \"arm,ci-700\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, arm_cmn_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id arm_cmn_acpi_match[] = {\n\t{ \"ARMHC600\", PART_CMN600 },\n\t{ \"ARMHC650\" },\n\t{ \"ARMHC700\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, arm_cmn_acpi_match);\n#endif\n\nstatic struct platform_driver arm_cmn_driver = {\n\t.driver = {\n\t\t.name = \"arm-cmn\",\n\t\t.of_match_table = of_match_ptr(arm_cmn_of_match),\n\t\t.acpi_match_table = ACPI_PTR(arm_cmn_acpi_match),\n\t},\n\t.probe = arm_cmn_probe,\n\t.remove = arm_cmn_remove,\n};\n\nstatic int __init arm_cmn_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t      \"perf/arm/cmn:online\",\n\t\t\t\t      arm_cmn_pmu_online_cpu,\n\t\t\t\t      arm_cmn_pmu_offline_cpu);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tarm_cmn_hp_state = ret;\n\tarm_cmn_debugfs = debugfs_create_dir(\"arm-cmn\", NULL);\n\n\tret = platform_driver_register(&arm_cmn_driver);\n\tif (ret) {\n\t\tcpuhp_remove_multi_state(arm_cmn_hp_state);\n\t\tdebugfs_remove(arm_cmn_debugfs);\n\t}\n\treturn ret;\n}\n\nstatic void __exit arm_cmn_exit(void)\n{\n\tplatform_driver_unregister(&arm_cmn_driver);\n\tcpuhp_remove_multi_state(arm_cmn_hp_state);\n\tdebugfs_remove(arm_cmn_debugfs);\n}\n\nmodule_init(arm_cmn_init);\nmodule_exit(arm_cmn_exit);\n\nMODULE_AUTHOR(\"Robin Murphy <robin.murphy@arm.com>\");\nMODULE_DESCRIPTION(\"Arm CMN-600 PMU driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}