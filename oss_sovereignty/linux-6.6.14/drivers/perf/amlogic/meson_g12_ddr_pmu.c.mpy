{
  "module_name": "meson_g12_ddr_pmu.c",
  "hash_id": "9577689e99b3bb6a1d8ceedd440dacfb6ad806cc7d187ae4cee9719e992461eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/amlogic/meson_g12_ddr_pmu.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/perf_event.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/types.h>\n\n#include <soc/amlogic/meson_ddr_pmu.h>\n\n#define PORT_MAJOR\t\t32\n#define DEFAULT_XTAL_FREQ\t24000000UL\n\n#define DMC_QOS_IRQ\t\tBIT(30)\n\n \n#define DMC_MON_G12_CTRL0\t\t(0x0  << 2)\n#define DMC_MON_G12_CTRL1\t\t(0x1  << 2)\n#define DMC_MON_G12_CTRL2\t\t(0x2  << 2)\n#define DMC_MON_G12_CTRL3\t\t(0x3  << 2)\n#define DMC_MON_G12_CTRL4\t\t(0x4  << 2)\n#define DMC_MON_G12_CTRL5\t\t(0x5  << 2)\n#define DMC_MON_G12_CTRL6\t\t(0x6  << 2)\n#define DMC_MON_G12_CTRL7\t\t(0x7  << 2)\n#define DMC_MON_G12_CTRL8\t\t(0x8  << 2)\n\n#define DMC_MON_G12_ALL_REQ_CNT\t\t(0x9  << 2)\n#define DMC_MON_G12_ALL_GRANT_CNT\t(0xa  << 2)\n#define DMC_MON_G12_ONE_GRANT_CNT\t(0xb  << 2)\n#define DMC_MON_G12_SEC_GRANT_CNT\t(0xc  << 2)\n#define DMC_MON_G12_THD_GRANT_CNT\t(0xd  << 2)\n#define DMC_MON_G12_FOR_GRANT_CNT\t(0xe  << 2)\n#define DMC_MON_G12_TIMER\t\t(0xf  << 2)\n\n \nPMU_FORMAT_ATTR(event, \"config:0-7\");\nPMU_FORMAT_ATTR(arm, \"config1:0\");\nPMU_FORMAT_ATTR(gpu, \"config1:1\");\nPMU_FORMAT_ATTR(pcie, \"config1:2\");\nPMU_FORMAT_ATTR(hdcp, \"config1:3\");\nPMU_FORMAT_ATTR(hevc_front, \"config1:4\");\nPMU_FORMAT_ATTR(usb3_0, \"config1:6\");\nPMU_FORMAT_ATTR(device, \"config1:7\");\nPMU_FORMAT_ATTR(hevc_back, \"config1:8\");\nPMU_FORMAT_ATTR(h265enc, \"config1:9\");\nPMU_FORMAT_ATTR(vpu_read1, \"config1:16\");\nPMU_FORMAT_ATTR(vpu_read2, \"config1:17\");\nPMU_FORMAT_ATTR(vpu_read3, \"config1:18\");\nPMU_FORMAT_ATTR(vpu_write1, \"config1:19\");\nPMU_FORMAT_ATTR(vpu_write2, \"config1:20\");\nPMU_FORMAT_ATTR(vdec, \"config1:21\");\nPMU_FORMAT_ATTR(hcodec, \"config1:22\");\nPMU_FORMAT_ATTR(ge2d, \"config1:23\");\n\nPMU_FORMAT_ATTR(spicc1, \"config1:32\");\nPMU_FORMAT_ATTR(usb0, \"config1:33\");\nPMU_FORMAT_ATTR(dma, \"config1:34\");\nPMU_FORMAT_ATTR(arb0, \"config1:35\");\nPMU_FORMAT_ATTR(sd_emmc_b, \"config1:36\");\nPMU_FORMAT_ATTR(usb1, \"config1:37\");\nPMU_FORMAT_ATTR(audio, \"config1:38\");\nPMU_FORMAT_ATTR(aififo, \"config1:39\");\nPMU_FORMAT_ATTR(parser, \"config1:41\");\nPMU_FORMAT_ATTR(ao_cpu, \"config1:42\");\nPMU_FORMAT_ATTR(sd_emmc_c, \"config1:43\");\nPMU_FORMAT_ATTR(spicc2, \"config1:44\");\nPMU_FORMAT_ATTR(ethernet, \"config1:45\");\nPMU_FORMAT_ATTR(sana, \"config1:46\");\n\n \nPMU_FORMAT_ATTR(nna, \"config1:10\");\n\n \nPMU_FORMAT_ATTR(gdc, \"config1:11\");\nPMU_FORMAT_ATTR(mipi_isp, \"config1:12\");\nPMU_FORMAT_ATTR(arm1, \"config1:13\");\nPMU_FORMAT_ATTR(sd_emmc_a, \"config1:40\");\n\nstatic struct attribute *g12_pmu_format_attrs[] = {\n\t&format_attr_event.attr,\n\t&format_attr_arm.attr,\n\t&format_attr_gpu.attr,\n\t&format_attr_nna.attr,\n\t&format_attr_gdc.attr,\n\t&format_attr_arm1.attr,\n\t&format_attr_mipi_isp.attr,\n\t&format_attr_sd_emmc_a.attr,\n\t&format_attr_pcie.attr,\n\t&format_attr_hdcp.attr,\n\t&format_attr_hevc_front.attr,\n\t&format_attr_usb3_0.attr,\n\t&format_attr_device.attr,\n\t&format_attr_hevc_back.attr,\n\t&format_attr_h265enc.attr,\n\t&format_attr_vpu_read1.attr,\n\t&format_attr_vpu_read2.attr,\n\t&format_attr_vpu_read3.attr,\n\t&format_attr_vpu_write1.attr,\n\t&format_attr_vpu_write2.attr,\n\t&format_attr_vdec.attr,\n\t&format_attr_hcodec.attr,\n\t&format_attr_ge2d.attr,\n\t&format_attr_spicc1.attr,\n\t&format_attr_usb0.attr,\n\t&format_attr_dma.attr,\n\t&format_attr_arb0.attr,\n\t&format_attr_sd_emmc_b.attr,\n\t&format_attr_usb1.attr,\n\t&format_attr_audio.attr,\n\t&format_attr_aififo.attr,\n\t&format_attr_parser.attr,\n\t&format_attr_ao_cpu.attr,\n\t&format_attr_sd_emmc_c.attr,\n\t&format_attr_spicc2.attr,\n\t&format_attr_ethernet.attr,\n\t&format_attr_sana.attr,\n\tNULL,\n};\n\n \nstatic unsigned long dmc_g12_get_freq_quick(struct dmc_info *info)\n{\n\tunsigned int val;\n\tunsigned int n, m, od1;\n\tunsigned int od_div = 0xfff;\n\tunsigned long freq = 0;\n\n\tval = readl(info->pll_reg);\n\tval = val & 0xfffff;\n\tswitch ((val >> 16) & 7) {\n\tcase 0:\n\t\tod_div = 2;\n\t\tbreak;\n\n\tcase 1:\n\t\tod_div = 3;\n\t\tbreak;\n\n\tcase 2:\n\t\tod_div = 4;\n\t\tbreak;\n\n\tcase 3:\n\t\tod_div = 6;\n\t\tbreak;\n\n\tcase 4:\n\t\tod_div = 8;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tm = val & 0x1ff;\n\tn = ((val >> 10) & 0x1f);\n\tod1 = (((val >> 19) & 0x1)) == 1 ? 2 : 1;\n\tfreq = DEFAULT_XTAL_FREQ / 1000;         \n\tif (n)\n\t\tfreq = ((((freq * m) / n) >> od1) / od_div) * 1000;\n\n\treturn freq;\n}\n\n#ifdef DEBUG\nstatic void g12_dump_reg(struct dmc_info *db)\n{\n\tint s = 0, i;\n\tunsigned int r;\n\n\tfor (i = 0; i < 9; i++) {\n\t\tr  = readl(db->ddr_reg[0] + (DMC_MON_G12_CTRL0 + (i << 2)));\n\t\tpr_notice(\"DMC_MON_CTRL%d:        %08x\\n\", i, r);\n\t}\n\tr  = readl(db->ddr_reg[0] + DMC_MON_G12_ALL_REQ_CNT);\n\tpr_notice(\"DMC_MON_ALL_REQ_CNT:  %08x\\n\", r);\n\tr  = readl(db->ddr_reg[0] + DMC_MON_G12_ALL_GRANT_CNT);\n\tpr_notice(\"DMC_MON_ALL_GRANT_CNT:%08x\\n\", r);\n\tr  = readl(db->ddr_reg[0] + DMC_MON_G12_ONE_GRANT_CNT);\n\tpr_notice(\"DMC_MON_ONE_GRANT_CNT:%08x\\n\", r);\n\tr  = readl(db->ddr_reg[0] + DMC_MON_G12_SEC_GRANT_CNT);\n\tpr_notice(\"DMC_MON_SEC_GRANT_CNT:%08x\\n\", r);\n\tr  = readl(db->ddr_reg[0] + DMC_MON_G12_THD_GRANT_CNT);\n\tpr_notice(\"DMC_MON_THD_GRANT_CNT:%08x\\n\", r);\n\tr  = readl(db->ddr_reg[0] + DMC_MON_G12_FOR_GRANT_CNT);\n\tpr_notice(\"DMC_MON_FOR_GRANT_CNT:%08x\\n\", r);\n\tr  = readl(db->ddr_reg[0] + DMC_MON_G12_TIMER);\n\tpr_notice(\"DMC_MON_TIMER:        %08x\\n\", r);\n}\n#endif\n\nstatic void dmc_g12_counter_enable(struct dmc_info *info)\n{\n\tunsigned int val;\n\tunsigned long clock_count = dmc_g12_get_freq_quick(info) / 10;  \n\n\twritel(clock_count, info->ddr_reg[0] + DMC_MON_G12_TIMER);\n\n\tval = readl(info->ddr_reg[0] + DMC_MON_G12_CTRL0);\n\n\t \n\tval =  BIT(31) |\t \n\t       BIT(20) |\t \n\t       0x0f;\t\t \n\n\twritel(val, info->ddr_reg[0] + DMC_MON_G12_CTRL0);\n\n#ifdef DEBUG\n\tg12_dump_reg(info);\n#endif\n}\n\nstatic void dmc_g12_config_fiter(struct dmc_info *info,\n\t\t\t\t int port, int channel)\n{\n\tu32 val;\n\tu32 rp[MAX_CHANNEL_NUM] = {DMC_MON_G12_CTRL1, DMC_MON_G12_CTRL3,\n\t\t\t\t\tDMC_MON_G12_CTRL5, DMC_MON_G12_CTRL7};\n\tu32 rs[MAX_CHANNEL_NUM] = {DMC_MON_G12_CTRL2, DMC_MON_G12_CTRL4,\n\t\t\t\t\tDMC_MON_G12_CTRL6, DMC_MON_G12_CTRL8};\n\tint subport = -1;\n\n\t \n\tif (port < 0) {\n\t\twritel(0, info->ddr_reg[0] + rp[channel]);\n\t\twritel(0, info->ddr_reg[0] + rs[channel]);\n\t\treturn;\n\t}\n\n\tif (port >= PORT_MAJOR)\n\t\tsubport = port - PORT_MAJOR;\n\n\tif (subport < 0) {\n\t\tval = readl(info->ddr_reg[0] + rp[channel]);\n\t\tval |=  (1 << port);\n\t\twritel(val, info->ddr_reg[0] + rp[channel]);\n\t\tval = 0xffff;\n\t\twritel(val, info->ddr_reg[0] + rs[channel]);\n\t} else {\n\t\tval = BIT(23);\t\t \n\t\twritel(val, info->ddr_reg[0] + rp[channel]);\n\t\tval = readl(info->ddr_reg[0] + rs[channel]);\n\t\tval |= (1 << subport);\n\t\twritel(val, info->ddr_reg[0] + rs[channel]);\n\t}\n}\n\nstatic void dmc_g12_set_axi_filter(struct dmc_info *info, int axi_id, int channel)\n{\n\tif (channel > info->hw_info->chann_nr)\n\t\treturn;\n\n\tdmc_g12_config_fiter(info, axi_id, channel);\n}\n\nstatic void dmc_g12_counter_disable(struct dmc_info *info)\n{\n\tint i;\n\n\t \n\twritel(0, info->ddr_reg[0] + DMC_MON_G12_CTRL0);\n\twritel(0, info->ddr_reg[0] + DMC_MON_G12_TIMER);\n\n\twritel(0, info->ddr_reg[0] + DMC_MON_G12_ALL_REQ_CNT);\n\twritel(0, info->ddr_reg[0] + DMC_MON_G12_ALL_GRANT_CNT);\n\twritel(0, info->ddr_reg[0] + DMC_MON_G12_ONE_GRANT_CNT);\n\twritel(0, info->ddr_reg[0] + DMC_MON_G12_SEC_GRANT_CNT);\n\twritel(0, info->ddr_reg[0] + DMC_MON_G12_THD_GRANT_CNT);\n\twritel(0, info->ddr_reg[0] + DMC_MON_G12_FOR_GRANT_CNT);\n\n\t \n\tfor (i = 0; i < info->hw_info->chann_nr; i++)\n\t\tdmc_g12_config_fiter(info, -1, i);\n}\n\nstatic void dmc_g12_get_counters(struct dmc_info *info,\n\t\t\t\t struct dmc_counter *counter)\n{\n\tint i;\n\tunsigned int reg;\n\n\tcounter->all_cnt = readl(info->ddr_reg[0] + DMC_MON_G12_ALL_GRANT_CNT);\n\tcounter->all_req   = readl(info->ddr_reg[0] + DMC_MON_G12_ALL_REQ_CNT);\n\n\tfor (i = 0; i < info->hw_info->chann_nr; i++) {\n\t\treg = DMC_MON_G12_ONE_GRANT_CNT + (i << 2);\n\t\tcounter->channel_cnt[i] = readl(info->ddr_reg[0] + reg);\n\t}\n}\n\nstatic int dmc_g12_irq_handler(struct dmc_info *info,\n\t\t\t       struct dmc_counter *counter)\n{\n\tunsigned int val;\n\tint ret = -EINVAL;\n\n\tval = readl(info->ddr_reg[0] + DMC_MON_G12_CTRL0);\n\tif (val & DMC_QOS_IRQ) {\n\t\tdmc_g12_get_counters(info, counter);\n\t\t \n\t\twritel(val, info->ddr_reg[0] + DMC_MON_G12_CTRL0);\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic const struct dmc_hw_info g12a_dmc_info = {\n\t.enable\t\t= dmc_g12_counter_enable,\n\t.disable\t= dmc_g12_counter_disable,\n\t.irq_handler\t= dmc_g12_irq_handler,\n\t.get_counters\t= dmc_g12_get_counters,\n\t.set_axi_filter\t= dmc_g12_set_axi_filter,\n\n\t.dmc_nr = 1,\n\t.chann_nr = 4,\n\t.capability = {0X7EFF00FF03DF, 0},\n\t.fmt_attr = g12_pmu_format_attrs,\n};\n\nstatic const struct dmc_hw_info g12b_dmc_info = {\n\t.enable\t\t= dmc_g12_counter_enable,\n\t.disable\t= dmc_g12_counter_disable,\n\t.irq_handler\t= dmc_g12_irq_handler,\n\t.get_counters\t= dmc_g12_get_counters,\n\t.set_axi_filter\t= dmc_g12_set_axi_filter,\n\n\t.dmc_nr = 1,\n\t.chann_nr = 4,\n\t.capability = {0X7FFF00FF3FDF, 0},\n\t.fmt_attr = g12_pmu_format_attrs,\n};\n\nstatic const struct dmc_hw_info sm1_dmc_info = {\n\t.enable\t\t= dmc_g12_counter_enable,\n\t.disable\t= dmc_g12_counter_disable,\n\t.irq_handler\t= dmc_g12_irq_handler,\n\t.get_counters\t= dmc_g12_get_counters,\n\t.set_axi_filter\t= dmc_g12_set_axi_filter,\n\n\t.dmc_nr = 1,\n\t.chann_nr = 4,\n\t.capability = {0X7EFF00FF07DF, 0},\n\t.fmt_attr = g12_pmu_format_attrs,\n};\n\nstatic int g12_ddr_pmu_probe(struct platform_device *pdev)\n{\n\treturn meson_ddr_pmu_create(pdev);\n}\n\nstatic int g12_ddr_pmu_remove(struct platform_device *pdev)\n{\n\tmeson_ddr_pmu_remove(pdev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id meson_ddr_pmu_dt_match[] = {\n\t{\n\t\t.compatible = \"amlogic,g12a-ddr-pmu\",\n\t\t.data = &g12a_dmc_info,\n\t},\n\t{\n\t\t.compatible = \"amlogic,g12b-ddr-pmu\",\n\t\t.data = &g12b_dmc_info,\n\t},\n\t{\n\t\t.compatible = \"amlogic,sm1-ddr-pmu\",\n\t\t.data = &sm1_dmc_info,\n\t},\n\t{}\n};\n\nstatic struct platform_driver g12_ddr_pmu_driver = {\n\t.probe = g12_ddr_pmu_probe,\n\t.remove = g12_ddr_pmu_remove,\n\n\t.driver = {\n\t\t.name = \"meson-g12-ddr-pmu\",\n\t\t.of_match_table = meson_ddr_pmu_dt_match,\n\t},\n};\n\nmodule_platform_driver(g12_ddr_pmu_driver);\nMODULE_AUTHOR(\"Jiucheng Xu\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Amlogic G12 series SoC DDR PMU\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}