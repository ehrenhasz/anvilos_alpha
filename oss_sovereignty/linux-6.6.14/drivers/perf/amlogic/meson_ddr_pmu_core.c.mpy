{
  "module_name": "meson_ddr_pmu_core.c",
  "hash_id": "b1dc48881051e263f9f161ae4fd31f331d341179a41b88775ada7d7c667cab43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/amlogic/meson_ddr_pmu_core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/init.h>\n#include <linux/irqreturn.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/perf_event.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n\n#include <soc/amlogic/meson_ddr_pmu.h>\n\nstruct ddr_pmu {\n\tstruct pmu pmu;\n\tstruct dmc_info info;\n\tstruct dmc_counter counters;\t \n\tbool pmu_enabled;\n\tstruct device *dev;\n\tchar *name;\n\tstruct hlist_node node;\n\tenum cpuhp_state cpuhp_state;\n\tint cpu;\t\t\t \n};\n\n#define DDR_PERF_DEV_NAME \"meson_ddr_bw\"\n#define MAX_AXI_PORTS_OF_CHANNEL\t4\t \n\n#define to_ddr_pmu(p)\t\tcontainer_of(p, struct ddr_pmu, pmu)\n#define dmc_info_to_pmu(p)\tcontainer_of(p, struct ddr_pmu, info)\n\nstatic void dmc_pmu_enable(struct ddr_pmu *pmu)\n{\n\tif (!pmu->pmu_enabled)\n\t\tpmu->info.hw_info->enable(&pmu->info);\n\n\tpmu->pmu_enabled = true;\n}\n\nstatic void dmc_pmu_disable(struct ddr_pmu *pmu)\n{\n\tif (pmu->pmu_enabled)\n\t\tpmu->info.hw_info->disable(&pmu->info);\n\n\tpmu->pmu_enabled = false;\n}\n\nstatic void meson_ddr_set_axi_filter(struct perf_event *event, u8 axi_id)\n{\n\tstruct ddr_pmu *pmu = to_ddr_pmu(event->pmu);\n\tint chann;\n\n\tif (event->attr.config > ALL_CHAN_COUNTER_ID &&\n\t    event->attr.config < COUNTER_MAX_ID) {\n\t\tchann = event->attr.config - CHAN1_COUNTER_ID;\n\n\t\tpmu->info.hw_info->set_axi_filter(&pmu->info, axi_id, chann);\n\t}\n}\n\nstatic void ddr_cnt_addition(struct dmc_counter *sum,\n\t\t\t     struct dmc_counter *add1,\n\t\t\t     struct dmc_counter *add2,\n\t\t\t     int chann_nr)\n{\n\tint i;\n\tu64 cnt1, cnt2;\n\n\tsum->all_cnt = add1->all_cnt + add2->all_cnt;\n\tsum->all_req = add1->all_req + add2->all_req;\n\tfor (i = 0; i < chann_nr; i++) {\n\t\tcnt1 = add1->channel_cnt[i];\n\t\tcnt2 = add2->channel_cnt[i];\n\n\t\tsum->channel_cnt[i] = cnt1 + cnt2;\n\t}\n}\n\nstatic void meson_ddr_perf_event_update(struct perf_event *event)\n{\n\tstruct ddr_pmu *pmu = to_ddr_pmu(event->pmu);\n\tu64 new_raw_count = 0;\n\tstruct dmc_counter dc = {0}, sum_dc = {0};\n\tint idx;\n\tint chann_nr = pmu->info.hw_info->chann_nr;\n\n\t \n\tpmu->info.hw_info->get_counters(&pmu->info, &dc);\n\n\tddr_cnt_addition(&sum_dc, &pmu->counters, &dc, chann_nr);\n\n\tswitch (event->attr.config) {\n\tcase ALL_CHAN_COUNTER_ID:\n\t\tnew_raw_count = sum_dc.all_cnt;\n\t\tbreak;\n\tcase CHAN1_COUNTER_ID:\n\tcase CHAN2_COUNTER_ID:\n\tcase CHAN3_COUNTER_ID:\n\tcase CHAN4_COUNTER_ID:\n\tcase CHAN5_COUNTER_ID:\n\tcase CHAN6_COUNTER_ID:\n\tcase CHAN7_COUNTER_ID:\n\tcase CHAN8_COUNTER_ID:\n\t\tidx = event->attr.config - CHAN1_COUNTER_ID;\n\t\tnew_raw_count = sum_dc.channel_cnt[idx];\n\t\tbreak;\n\t}\n\n\tlocal64_set(&event->count, new_raw_count);\n}\n\nstatic int meson_ddr_perf_event_init(struct perf_event *event)\n{\n\tstruct ddr_pmu *pmu = to_ddr_pmu(event->pmu);\n\tu64 config1 = event->attr.config1;\n\tu64 config2 = event->attr.config2;\n\n\tif (event->attr.type != event->pmu->type)\n\t\treturn -ENOENT;\n\n\tif (is_sampling_event(event) || event->attach_state & PERF_ATTACH_TASK)\n\t\treturn -EOPNOTSUPP;\n\n\tif (event->cpu < 0)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (event->attr.config != ALL_CHAN_COUNTER_ID &&\n\t    hweight64(config1) + hweight64(config2) > MAX_AXI_PORTS_OF_CHANNEL)\n\t\treturn -EOPNOTSUPP;\n\n\tevent->cpu = pmu->cpu;\n\n\treturn 0;\n}\n\nstatic void meson_ddr_perf_event_start(struct perf_event *event, int flags)\n{\n\tstruct ddr_pmu *pmu = to_ddr_pmu(event->pmu);\n\n\tmemset(&pmu->counters, 0, sizeof(pmu->counters));\n\tdmc_pmu_enable(pmu);\n}\n\nstatic int meson_ddr_perf_event_add(struct perf_event *event, int flags)\n{\n\tu64 config1 = event->attr.config1;\n\tu64 config2 = event->attr.config2;\n\tint i;\n\n\tfor_each_set_bit(i,\n\t\t\t (const unsigned long *)&config1,\n\t\t\t BITS_PER_TYPE(config1))\n\t\tmeson_ddr_set_axi_filter(event, i);\n\n\tfor_each_set_bit(i,\n\t\t\t (const unsigned long *)&config2,\n\t\t\t BITS_PER_TYPE(config2))\n\t\tmeson_ddr_set_axi_filter(event, i + 64);\n\n\tif (flags & PERF_EF_START)\n\t\tmeson_ddr_perf_event_start(event, flags);\n\n\treturn 0;\n}\n\nstatic void meson_ddr_perf_event_stop(struct perf_event *event, int flags)\n{\n\tstruct ddr_pmu *pmu = to_ddr_pmu(event->pmu);\n\n\tif (flags & PERF_EF_UPDATE)\n\t\tmeson_ddr_perf_event_update(event);\n\n\tdmc_pmu_disable(pmu);\n}\n\nstatic void meson_ddr_perf_event_del(struct perf_event *event, int flags)\n{\n\tmeson_ddr_perf_event_stop(event, PERF_EF_UPDATE);\n}\n\nstatic ssize_t meson_ddr_perf_cpumask_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct ddr_pmu *pmu = dev_get_drvdata(dev);\n\n\treturn cpumap_print_to_pagebuf(true, buf, cpumask_of(pmu->cpu));\n}\n\nstatic struct device_attribute meson_ddr_perf_cpumask_attr =\n__ATTR(cpumask, 0444, meson_ddr_perf_cpumask_show, NULL);\n\nstatic struct attribute *meson_ddr_perf_cpumask_attrs[] = {\n\t&meson_ddr_perf_cpumask_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ddr_perf_cpumask_attr_group = {\n\t.attrs = meson_ddr_perf_cpumask_attrs,\n};\n\nstatic ssize_t\npmu_event_show(struct device *dev, struct device_attribute *attr,\n\t       char *page)\n{\n\tstruct perf_pmu_events_attr *pmu_attr;\n\n\tpmu_attr = container_of(attr, struct perf_pmu_events_attr, attr);\n\treturn sysfs_emit(page, \"event=0x%02llx\\n\", pmu_attr->id);\n}\n\nstatic ssize_t\nevent_show_unit(struct device *dev, struct device_attribute *attr,\n\t\tchar *page)\n{\n\treturn sysfs_emit(page, \"MB\\n\");\n}\n\nstatic ssize_t\nevent_show_scale(struct device *dev, struct device_attribute *attr,\n\t\t char *page)\n{\n\t \n\treturn sysfs_emit(page, \"1.52587890625e-05\\n\");\n}\n\n#define AML_DDR_PMU_EVENT_ATTR(_name, _id)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.attr = __ATTR(_name, 0444, pmu_event_show, NULL),\t\t\\\n\t.id = _id,\t\t\t\t\t\t\t\\\n}\n\n#define AML_DDR_PMU_EVENT_UNIT_ATTR(_name)\t\t\t\t\\\n\t__ATTR(_name.unit, 0444, event_show_unit, NULL)\n\n#define AML_DDR_PMU_EVENT_SCALE_ATTR(_name)\t\t\t\t\\\n\t__ATTR(_name.scale, 0444, event_show_scale, NULL)\n\nstatic struct device_attribute event_unit_attrs[] = {\n\tAML_DDR_PMU_EVENT_UNIT_ATTR(total_rw_bytes),\n\tAML_DDR_PMU_EVENT_UNIT_ATTR(chan_1_rw_bytes),\n\tAML_DDR_PMU_EVENT_UNIT_ATTR(chan_2_rw_bytes),\n\tAML_DDR_PMU_EVENT_UNIT_ATTR(chan_3_rw_bytes),\n\tAML_DDR_PMU_EVENT_UNIT_ATTR(chan_4_rw_bytes),\n\tAML_DDR_PMU_EVENT_UNIT_ATTR(chan_5_rw_bytes),\n\tAML_DDR_PMU_EVENT_UNIT_ATTR(chan_6_rw_bytes),\n\tAML_DDR_PMU_EVENT_UNIT_ATTR(chan_7_rw_bytes),\n\tAML_DDR_PMU_EVENT_UNIT_ATTR(chan_8_rw_bytes),\n};\n\nstatic struct device_attribute event_scale_attrs[] = {\n\tAML_DDR_PMU_EVENT_SCALE_ATTR(total_rw_bytes),\n\tAML_DDR_PMU_EVENT_SCALE_ATTR(chan_1_rw_bytes),\n\tAML_DDR_PMU_EVENT_SCALE_ATTR(chan_2_rw_bytes),\n\tAML_DDR_PMU_EVENT_SCALE_ATTR(chan_3_rw_bytes),\n\tAML_DDR_PMU_EVENT_SCALE_ATTR(chan_4_rw_bytes),\n\tAML_DDR_PMU_EVENT_SCALE_ATTR(chan_5_rw_bytes),\n\tAML_DDR_PMU_EVENT_SCALE_ATTR(chan_6_rw_bytes),\n\tAML_DDR_PMU_EVENT_SCALE_ATTR(chan_7_rw_bytes),\n\tAML_DDR_PMU_EVENT_SCALE_ATTR(chan_8_rw_bytes),\n};\n\nstatic struct perf_pmu_events_attr event_attrs[] = {\n\tAML_DDR_PMU_EVENT_ATTR(total_rw_bytes, ALL_CHAN_COUNTER_ID),\n\tAML_DDR_PMU_EVENT_ATTR(chan_1_rw_bytes, CHAN1_COUNTER_ID),\n\tAML_DDR_PMU_EVENT_ATTR(chan_2_rw_bytes, CHAN2_COUNTER_ID),\n\tAML_DDR_PMU_EVENT_ATTR(chan_3_rw_bytes, CHAN3_COUNTER_ID),\n\tAML_DDR_PMU_EVENT_ATTR(chan_4_rw_bytes, CHAN4_COUNTER_ID),\n\tAML_DDR_PMU_EVENT_ATTR(chan_5_rw_bytes, CHAN5_COUNTER_ID),\n\tAML_DDR_PMU_EVENT_ATTR(chan_6_rw_bytes, CHAN6_COUNTER_ID),\n\tAML_DDR_PMU_EVENT_ATTR(chan_7_rw_bytes, CHAN7_COUNTER_ID),\n\tAML_DDR_PMU_EVENT_ATTR(chan_8_rw_bytes, CHAN8_COUNTER_ID),\n};\n\n \nstatic struct attribute *ddr_perf_events_attrs[COUNTER_MAX_ID * 3];\n\nstatic struct attribute_group ddr_perf_events_attr_group = {\n\t.name = \"events\",\n\t.attrs = ddr_perf_events_attrs,\n};\n\nstatic umode_t meson_ddr_perf_format_attr_visible(struct kobject *kobj,\n\t\t\t\t\t\t  struct attribute *attr,\n\t\t\t\t\t\t  int n)\n{\n\tstruct pmu *pmu = dev_get_drvdata(kobj_to_dev(kobj));\n\tstruct ddr_pmu *ddr_pmu = to_ddr_pmu(pmu);\n\tconst u64 *capability = ddr_pmu->info.hw_info->capability;\n\tstruct device_attribute *dev_attr;\n\tint id;\n\tchar value[20]; \n\n\tdev_attr = container_of(attr, struct device_attribute, attr);\n\tdev_attr->show(NULL, NULL, value);\n\n\tif (sscanf(value, \"config1:%d\", &id) == 1)\n\t\treturn capability[0] & (1ULL << id) ? attr->mode : 0;\n\n\tif (sscanf(value, \"config2:%d\", &id) == 1)\n\t\treturn capability[1] & (1ULL << id) ? attr->mode : 0;\n\n\treturn attr->mode;\n}\n\nstatic struct attribute_group ddr_perf_format_attr_group = {\n\t.name = \"format\",\n\t.is_visible = meson_ddr_perf_format_attr_visible,\n};\n\nstatic ssize_t meson_ddr_perf_identifier_show(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *page)\n{\n\tstruct ddr_pmu *pmu = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(page, \"%s\\n\", pmu->name);\n}\n\nstatic struct device_attribute meson_ddr_perf_identifier_attr =\n__ATTR(identifier, 0444, meson_ddr_perf_identifier_show, NULL);\n\nstatic struct attribute *meson_ddr_perf_identifier_attrs[] = {\n\t&meson_ddr_perf_identifier_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ddr_perf_identifier_attr_group = {\n\t.attrs = meson_ddr_perf_identifier_attrs,\n};\n\nstatic const struct attribute_group *attr_groups[] = {\n\t&ddr_perf_events_attr_group,\n\t&ddr_perf_format_attr_group,\n\t&ddr_perf_cpumask_attr_group,\n\t&ddr_perf_identifier_attr_group,\n\tNULL,\n};\n\nstatic irqreturn_t dmc_irq_handler(int irq, void *dev_id)\n{\n\tstruct dmc_info *info = dev_id;\n\tstruct ddr_pmu *pmu;\n\tstruct dmc_counter counters, *sum_cnter;\n\tint i;\n\n\tpmu = dmc_info_to_pmu(info);\n\n\tif (info->hw_info->irq_handler(info, &counters) != 0)\n\t\tgoto out;\n\n\tsum_cnter = &pmu->counters;\n\tsum_cnter->all_cnt += counters.all_cnt;\n\tsum_cnter->all_req += counters.all_req;\n\n\tfor (i = 0; i < pmu->info.hw_info->chann_nr; i++)\n\t\tsum_cnter->channel_cnt[i] += counters.channel_cnt[i];\n\n\tif (pmu->pmu_enabled)\n\t\t \n\t\tinfo->hw_info->enable(info);\n\n\tdev_dbg(pmu->dev, \"counts: %llu %llu %llu, %llu, %llu, %llu\\t\\t\"\n\t\t\t\"sum: %llu %llu %llu, %llu, %llu, %llu\\n\",\n\t\t\tcounters.all_req,\n\t\t\tcounters.all_cnt,\n\t\t\tcounters.channel_cnt[0],\n\t\t\tcounters.channel_cnt[1],\n\t\t\tcounters.channel_cnt[2],\n\t\t\tcounters.channel_cnt[3],\n\n\t\t\tpmu->counters.all_req,\n\t\t\tpmu->counters.all_cnt,\n\t\t\tpmu->counters.channel_cnt[0],\n\t\t\tpmu->counters.channel_cnt[1],\n\t\t\tpmu->counters.channel_cnt[2],\n\t\t\tpmu->counters.channel_cnt[3]);\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int ddr_perf_offline_cpu(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct ddr_pmu *pmu = hlist_entry_safe(node, struct ddr_pmu, node);\n\tint target;\n\n\tif (cpu != pmu->cpu)\n\t\treturn 0;\n\n\ttarget = cpumask_any_but(cpu_online_mask, cpu);\n\tif (target >= nr_cpu_ids)\n\t\treturn 0;\n\n\tperf_pmu_migrate_context(&pmu->pmu, cpu, target);\n\tpmu->cpu = target;\n\n\tWARN_ON(irq_set_affinity(pmu->info.irq_num, cpumask_of(pmu->cpu)));\n\n\treturn 0;\n}\n\nstatic void fill_event_attr(struct ddr_pmu *pmu)\n{\n\tint i, j, k;\n\tstruct attribute **dst = ddr_perf_events_attrs;\n\n\tj = 0;\n\tk = 0;\n\n\t \n\tdst[j++] = &event_attrs[k].attr.attr;\n\tdst[j++] = &event_unit_attrs[k].attr;\n\tdst[j++] = &event_scale_attrs[k].attr;\n\n\tk++;\n\n\t \n\tfor (i = 0; i < pmu->info.hw_info->chann_nr; i++, k++) {\n\t\tdst[j++] = &event_attrs[k].attr.attr;\n\t\tdst[j++] = &event_unit_attrs[k].attr;\n\t\tdst[j++] = &event_scale_attrs[k].attr;\n\t}\n\n\tdst[j] = NULL;  \n}\n\nstatic void fmt_attr_fill(struct attribute **fmt_attr)\n{\n\tddr_perf_format_attr_group.attrs = fmt_attr;\n}\n\nstatic int ddr_pmu_parse_dt(struct platform_device *pdev,\n\t\t\t    struct dmc_info *info)\n{\n\tvoid __iomem *base;\n\tint i, ret;\n\n\tinfo->hw_info = of_device_get_match_data(&pdev->dev);\n\n\tfor (i = 0; i < info->hw_info->dmc_nr; i++) {\n\t\t \n\t\tbase = devm_platform_ioremap_resource(pdev, i);\n\t\tif (IS_ERR(base))\n\t\t\treturn PTR_ERR(base);\n\n\t\tinfo->ddr_reg[i] = base;\n\t}\n\n\t \n\tbase = devm_platform_ioremap_resource(pdev, i);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tinfo->pll_reg = base;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinfo->irq_num = ret;\n\n\tret = devm_request_irq(&pdev->dev, info->irq_num, dmc_irq_handler,\n\t\t\t       IRQF_NOBALANCING, dev_name(&pdev->dev),\n\t\t\t       (void *)info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint meson_ddr_pmu_create(struct platform_device *pdev)\n{\n\tint ret;\n\tchar *name;\n\tstruct ddr_pmu *pmu;\n\n\tpmu = devm_kzalloc(&pdev->dev, sizeof(struct ddr_pmu), GFP_KERNEL);\n\tif (!pmu)\n\t\treturn -ENOMEM;\n\n\t*pmu = (struct ddr_pmu) {\n\t\t.pmu = {\n\t\t\t.module\t\t= THIS_MODULE,\n\t\t\t.capabilities\t= PERF_PMU_CAP_NO_EXCLUDE,\n\t\t\t.task_ctx_nr\t= perf_invalid_context,\n\t\t\t.attr_groups\t= attr_groups,\n\t\t\t.event_init\t= meson_ddr_perf_event_init,\n\t\t\t.add\t\t= meson_ddr_perf_event_add,\n\t\t\t.del\t\t= meson_ddr_perf_event_del,\n\t\t\t.start\t\t= meson_ddr_perf_event_start,\n\t\t\t.stop\t\t= meson_ddr_perf_event_stop,\n\t\t\t.read\t\t= meson_ddr_perf_event_update,\n\t\t},\n\t};\n\n\tret = ddr_pmu_parse_dt(pdev, &pmu->info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmt_attr_fill(pmu->info.hw_info->fmt_attr);\n\n\tpmu->cpu = smp_processor_id();\n\n\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL, DDR_PERF_DEV_NAME);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, name, NULL,\n\t\t\t\t      ddr_perf_offline_cpu);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmu->cpuhp_state = ret;\n\n\t \n\tret = cpuhp_state_add_instance_nocalls(pmu->cpuhp_state, &pmu->node);\n\tif (ret)\n\t\tgoto cpuhp_instance_err;\n\n\tfill_event_attr(pmu);\n\n\tret = perf_pmu_register(&pmu->pmu, name, -1);\n\tif (ret)\n\t\tgoto pmu_register_err;\n\n\tpmu->name = name;\n\tpmu->dev = &pdev->dev;\n\tpmu->pmu_enabled = false;\n\n\tplatform_set_drvdata(pdev, pmu);\n\n\treturn 0;\n\npmu_register_err:\n\tcpuhp_state_remove_instance_nocalls(pmu->cpuhp_state, &pmu->node);\n\ncpuhp_instance_err:\n\tcpuhp_remove_state(pmu->cpuhp_state);\n\n\treturn ret;\n}\n\nint meson_ddr_pmu_remove(struct platform_device *pdev)\n{\n\tstruct ddr_pmu *pmu = platform_get_drvdata(pdev);\n\n\tperf_pmu_unregister(&pmu->pmu);\n\tcpuhp_state_remove_instance_nocalls(pmu->cpuhp_state, &pmu->node);\n\tcpuhp_remove_state(pmu->cpuhp_state);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}