{
  "module_name": "alibaba_uncore_drw_pmu.c",
  "hash_id": "fd134d16beb9336c3175af5944844f9428ecd9a646c8c967c6c197bd8d1a25d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/alibaba_uncore_drw_pmu.c",
  "human_readable_source": "\n \n\n#define ALI_DRW_PMUNAME\t\t\"ali_drw\"\n#define ALI_DRW_DRVNAME\t\tALI_DRW_PMUNAME \"_pmu\"\n#define pr_fmt(fmt)\t\tALI_DRW_DRVNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/bitfield.h>\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n#include <linux/cpuhotplug.h>\n#include <linux/cpumask.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/perf_event.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/rculist.h>\n#include <linux/refcount.h>\n\n\n#define ALI_DRW_PMU_COMMON_MAX_COUNTERS\t\t\t16\n#define ALI_DRW_PMU_TEST_SEL_COMMON_COUNTER_BASE\t19\n\n#define ALI_DRW_PMU_PA_SHIFT\t\t\t12\n#define ALI_DRW_PMU_CNT_INIT\t\t\t0x00000000\n#define ALI_DRW_CNT_MAX_PERIOD\t\t\t0xffffffff\n#define ALI_DRW_PMU_CYCLE_EVT_ID\t\t0x80\n\n#define ALI_DRW_PMU_CNT_CTRL\t\t\t0xC00\n#define ALI_DRW_PMU_CNT_RST\t\t\tBIT(2)\n#define ALI_DRW_PMU_CNT_STOP\t\t\tBIT(1)\n#define ALI_DRW_PMU_CNT_START\t\t\tBIT(0)\n\n#define ALI_DRW_PMU_CNT_STATE\t\t\t0xC04\n#define ALI_DRW_PMU_TEST_CTRL\t\t\t0xC08\n#define ALI_DRW_PMU_CNT_PRELOAD\t\t\t0xC0C\n\n#define ALI_DRW_PMU_CYCLE_CNT_HIGH_MASK\t\tGENMASK(23, 0)\n#define ALI_DRW_PMU_CYCLE_CNT_LOW_MASK\t\tGENMASK(31, 0)\n#define ALI_DRW_PMU_CYCLE_CNT_HIGH\t\t0xC10\n#define ALI_DRW_PMU_CYCLE_CNT_LOW\t\t0xC14\n\n \n#define ALI_DRW_PMU_EVENT_SEL0\t\t\t0xC68\n \n#define ALI_DRW_PMU_EVENT_SELn(n) \\\n\t(ALI_DRW_PMU_EVENT_SEL0 + (n / 4) * 0x4)\n#define ALI_DRW_PMCOM_CNT_EN\t\t\tBIT(7)\n#define ALI_DRW_PMCOM_CNT_EVENT_MASK\t\tGENMASK(5, 0)\n#define ALI_DRW_PMCOM_CNT_EVENT_OFFSET(n) \\\n\t(8 * (n % 4))\n\n \n#define ALI_DRW_PMU_COMMON_COUNTER0\t\t0xC78\n#define ALI_DRW_PMU_COMMON_COUNTERn(n) \\\n\t(ALI_DRW_PMU_COMMON_COUNTER0 + 0x4 * (n))\n\n#define ALI_DRW_PMU_OV_INTR_ENABLE_CTL\t\t0xCB8\n#define ALI_DRW_PMU_OV_INTR_DISABLE_CTL\t\t0xCBC\n#define ALI_DRW_PMU_OV_INTR_ENABLE_STATUS\t0xCC0\n#define ALI_DRW_PMU_OV_INTR_CLR\t\t\t0xCC4\n#define ALI_DRW_PMU_OV_INTR_STATUS\t\t0xCC8\n#define ALI_DRW_PMCOM_CNT_OV_INTR_MASK\t\tGENMASK(23, 8)\n#define ALI_DRW_PMBW_CNT_OV_INTR_MASK\t\tGENMASK(7, 0)\n#define ALI_DRW_PMU_OV_INTR_MASK\t\tGENMASK_ULL(63, 0)\n\nstatic int ali_drw_cpuhp_state_num;\n\nstatic LIST_HEAD(ali_drw_pmu_irqs);\nstatic DEFINE_MUTEX(ali_drw_pmu_irqs_lock);\n\nstruct ali_drw_pmu_irq {\n\tstruct hlist_node node;\n\tstruct list_head irqs_node;\n\tstruct list_head pmus_node;\n\tint irq_num;\n\tint cpu;\n\trefcount_t refcount;\n};\n\nstruct ali_drw_pmu {\n\tvoid __iomem *cfg_base;\n\tstruct device *dev;\n\n\tstruct list_head pmus_node;\n\tstruct ali_drw_pmu_irq *irq;\n\tint irq_num;\n\tint cpu;\n\tDECLARE_BITMAP(used_mask, ALI_DRW_PMU_COMMON_MAX_COUNTERS);\n\tstruct perf_event *events[ALI_DRW_PMU_COMMON_MAX_COUNTERS];\n\tint evtids[ALI_DRW_PMU_COMMON_MAX_COUNTERS];\n\n\tstruct pmu pmu;\n};\n\n#define to_ali_drw_pmu(p) (container_of(p, struct ali_drw_pmu, pmu))\n\n#define DRW_CONFIG_EVENTID\t\tGENMASK(7, 0)\n#define GET_DRW_EVENTID(event)\tFIELD_GET(DRW_CONFIG_EVENTID, (event)->attr.config)\n\nstatic ssize_t ali_drw_pmu_format_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dev_ext_attribute *eattr;\n\n\teattr = container_of(attr, struct dev_ext_attribute, attr);\n\n\treturn sprintf(buf, \"%s\\n\", (char *)eattr->var);\n}\n\n \nstatic ssize_t ali_drw_pmu_event_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *page)\n{\n\tstruct dev_ext_attribute *eattr;\n\n\teattr = container_of(attr, struct dev_ext_attribute, attr);\n\n\treturn sprintf(page, \"config=0x%lx\\n\", (unsigned long)eattr->var);\n}\n\n#define ALI_DRW_PMU_ATTR(_name, _func, _config)                            \\\n\t\t(&((struct dev_ext_attribute[]) {                               \\\n\t\t\t\t{ __ATTR(_name, 0444, _func, NULL), (void *)_config }   \\\n\t\t})[0].attr.attr)\n\n#define ALI_DRW_PMU_FORMAT_ATTR(_name, _config)            \\\n\tALI_DRW_PMU_ATTR(_name, ali_drw_pmu_format_show, (void *)_config)\n#define ALI_DRW_PMU_EVENT_ATTR(_name, _config)             \\\n\tALI_DRW_PMU_ATTR(_name, ali_drw_pmu_event_show, (unsigned long)_config)\n\nstatic struct attribute *ali_drw_pmu_events_attrs[] = {\n\tALI_DRW_PMU_EVENT_ATTR(hif_rd_or_wr,\t\t\t0x0),\n\tALI_DRW_PMU_EVENT_ATTR(hif_wr,\t\t\t\t0x1),\n\tALI_DRW_PMU_EVENT_ATTR(hif_rd,\t\t\t\t0x2),\n\tALI_DRW_PMU_EVENT_ATTR(hif_rmw,\t\t\t\t0x3),\n\tALI_DRW_PMU_EVENT_ATTR(hif_hi_pri_rd,\t\t\t0x4),\n\tALI_DRW_PMU_EVENT_ATTR(dfi_wr_data_cycles,\t\t0x7),\n\tALI_DRW_PMU_EVENT_ATTR(dfi_rd_data_cycles,\t\t0x8),\n\tALI_DRW_PMU_EVENT_ATTR(hpr_xact_when_critical,\t\t0x9),\n\tALI_DRW_PMU_EVENT_ATTR(lpr_xact_when_critical,\t\t0xA),\n\tALI_DRW_PMU_EVENT_ATTR(wr_xact_when_critical,\t\t0xB),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_activate,\t\t\t0xC),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_rd_or_wr,\t\t\t0xD),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_rd_activate,\t\t0xE),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_rd,\t\t\t0xF),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_wr,\t\t\t0x10),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_mwr,\t\t\t0x11),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_precharge,\t\t\t0x12),\n\tALI_DRW_PMU_EVENT_ATTR(precharge_for_rdwr,\t\t0x13),\n\tALI_DRW_PMU_EVENT_ATTR(precharge_for_other,\t\t0x14),\n\tALI_DRW_PMU_EVENT_ATTR(rdwr_transitions,\t\t0x15),\n\tALI_DRW_PMU_EVENT_ATTR(write_combine,\t\t\t0x16),\n\tALI_DRW_PMU_EVENT_ATTR(war_hazard,\t\t\t0x17),\n\tALI_DRW_PMU_EVENT_ATTR(raw_hazard,\t\t\t0x18),\n\tALI_DRW_PMU_EVENT_ATTR(waw_hazard,\t\t\t0x19),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_enter_selfref_rk0,\t\t0x1A),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_enter_selfref_rk1,\t\t0x1B),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_enter_selfref_rk2,\t\t0x1C),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_enter_selfref_rk3,\t\t0x1D),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_enter_powerdown_rk0,\t0x1E),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_enter_powerdown_rk1,\t0x1F),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_enter_powerdown_rk2,\t0x20),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_enter_powerdown_rk3,\t0x21),\n\tALI_DRW_PMU_EVENT_ATTR(selfref_mode_rk0,\t\t0x26),\n\tALI_DRW_PMU_EVENT_ATTR(selfref_mode_rk1,\t\t0x27),\n\tALI_DRW_PMU_EVENT_ATTR(selfref_mode_rk2,\t\t0x28),\n\tALI_DRW_PMU_EVENT_ATTR(selfref_mode_rk3,\t\t0x29),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_refresh,\t\t\t0x2A),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_crit_ref,\t\t\t0x2B),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_load_mode,\t\t\t0x2D),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_zqcl,\t\t\t0x2E),\n\tALI_DRW_PMU_EVENT_ATTR(visible_window_limit_reached_rd, 0x30),\n\tALI_DRW_PMU_EVENT_ATTR(visible_window_limit_reached_wr, 0x31),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_dqsosc_mpc,\t\t0x34),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_dqsosc_mrr,\t\t0x35),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_tcr_mrr,\t\t\t0x36),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_zqstart,\t\t\t0x37),\n\tALI_DRW_PMU_EVENT_ATTR(op_is_zqlatch,\t\t\t0x38),\n\tALI_DRW_PMU_EVENT_ATTR(chi_txreq,\t\t\t0x39),\n\tALI_DRW_PMU_EVENT_ATTR(chi_txdat,\t\t\t0x3A),\n\tALI_DRW_PMU_EVENT_ATTR(chi_rxdat,\t\t\t0x3B),\n\tALI_DRW_PMU_EVENT_ATTR(chi_rxrsp,\t\t\t0x3C),\n\tALI_DRW_PMU_EVENT_ATTR(tsz_vio,\t\t\t\t0x3D),\n\tALI_DRW_PMU_EVENT_ATTR(cycle,\t\t\t\t0x80),\n\tNULL,\n};\n\nstatic struct attribute_group ali_drw_pmu_events_attr_group = {\n\t.name = \"events\",\n\t.attrs = ali_drw_pmu_events_attrs,\n};\n\nstatic struct attribute *ali_drw_pmu_format_attr[] = {\n\tALI_DRW_PMU_FORMAT_ATTR(event, \"config:0-7\"),\n\tNULL,\n};\n\nstatic const struct attribute_group ali_drw_pmu_format_group = {\n\t.name = \"format\",\n\t.attrs = ali_drw_pmu_format_attr,\n};\n\nstatic ssize_t ali_drw_pmu_cpumask_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct ali_drw_pmu *drw_pmu = to_ali_drw_pmu(dev_get_drvdata(dev));\n\n\treturn cpumap_print_to_pagebuf(true, buf, cpumask_of(drw_pmu->cpu));\n}\n\nstatic struct device_attribute ali_drw_pmu_cpumask_attr =\n\t\t__ATTR(cpumask, 0444, ali_drw_pmu_cpumask_show, NULL);\n\nstatic struct attribute *ali_drw_pmu_cpumask_attrs[] = {\n\t&ali_drw_pmu_cpumask_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ali_drw_pmu_cpumask_attr_group = {\n\t.attrs = ali_drw_pmu_cpumask_attrs,\n};\n\nstatic ssize_t ali_drw_pmu_identifier_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *page)\n{\n\treturn sysfs_emit(page, \"%s\\n\", \"ali_drw_pmu\");\n}\n\nstatic umode_t ali_drw_pmu_identifier_attr_visible(struct kobject *kobj,\n\t\t\t\t\t\tstruct attribute *attr, int n)\n{\n\treturn attr->mode;\n}\n\nstatic struct device_attribute ali_drw_pmu_identifier_attr =\n\t__ATTR(identifier, 0444, ali_drw_pmu_identifier_show, NULL);\n\nstatic struct attribute *ali_drw_pmu_identifier_attrs[] = {\n\t&ali_drw_pmu_identifier_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ali_drw_pmu_identifier_attr_group = {\n\t.attrs = ali_drw_pmu_identifier_attrs,\n\t.is_visible = ali_drw_pmu_identifier_attr_visible\n};\n\nstatic const struct attribute_group *ali_drw_pmu_attr_groups[] = {\n\t&ali_drw_pmu_events_attr_group,\n\t&ali_drw_pmu_cpumask_attr_group,\n\t&ali_drw_pmu_format_group,\n\t&ali_drw_pmu_identifier_attr_group,\n\tNULL,\n};\n\n \nstatic int ali_drw_get_counter_idx(struct perf_event *event)\n{\n\tstruct ali_drw_pmu *drw_pmu = to_ali_drw_pmu(event->pmu);\n\tint idx;\n\n\tfor (idx = 0; idx < ALI_DRW_PMU_COMMON_MAX_COUNTERS; ++idx) {\n\t\tif (!test_and_set_bit(idx, drw_pmu->used_mask))\n\t\t\treturn idx;\n\t}\n\n\t \n\treturn -EBUSY;\n}\n\nstatic u64 ali_drw_pmu_read_counter(struct perf_event *event)\n{\n\tstruct ali_drw_pmu *drw_pmu = to_ali_drw_pmu(event->pmu);\n\tu64 cycle_high, cycle_low;\n\n\tif (GET_DRW_EVENTID(event) == ALI_DRW_PMU_CYCLE_EVT_ID) {\n\t\tcycle_high = readl(drw_pmu->cfg_base + ALI_DRW_PMU_CYCLE_CNT_HIGH);\n\t\tcycle_high &= ALI_DRW_PMU_CYCLE_CNT_HIGH_MASK;\n\t\tcycle_low = readl(drw_pmu->cfg_base + ALI_DRW_PMU_CYCLE_CNT_LOW);\n\t\tcycle_low &= ALI_DRW_PMU_CYCLE_CNT_LOW_MASK;\n\t\treturn (cycle_high << 32 | cycle_low);\n\t}\n\n\treturn readl(drw_pmu->cfg_base +\n\t\t     ALI_DRW_PMU_COMMON_COUNTERn(event->hw.idx));\n}\n\nstatic void ali_drw_pmu_event_update(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 delta, prev, now;\n\n\tdo {\n\t\tprev = local64_read(&hwc->prev_count);\n\t\tnow = ali_drw_pmu_read_counter(event);\n\t} while (local64_cmpxchg(&hwc->prev_count, prev, now) != prev);\n\n\t \n\tdelta = now - prev;\n\tif (GET_DRW_EVENTID(event) == ALI_DRW_PMU_CYCLE_EVT_ID)\n\t\tdelta &= ALI_DRW_PMU_OV_INTR_MASK;\n\telse\n\t\tdelta &= ALI_DRW_CNT_MAX_PERIOD;\n\tlocal64_add(delta, &event->count);\n}\n\nstatic void ali_drw_pmu_event_set_period(struct perf_event *event)\n{\n\tu64 pre_val;\n\tstruct ali_drw_pmu *drw_pmu = to_ali_drw_pmu(event->pmu);\n\n\t \n\twritel(ALI_DRW_PMU_TEST_SEL_COMMON_COUNTER_BASE + event->hw.idx,\n\t       drw_pmu->cfg_base + ALI_DRW_PMU_TEST_CTRL);\n\n\t \n\tpre_val = ALI_DRW_PMU_CNT_INIT;\n\twritel(pre_val, drw_pmu->cfg_base + ALI_DRW_PMU_CNT_PRELOAD);\n\tlocal64_set(&event->hw.prev_count, pre_val);\n\n\t \n\twritel(0x0, drw_pmu->cfg_base + ALI_DRW_PMU_TEST_CTRL);\n}\n\nstatic void ali_drw_pmu_enable_counter(struct perf_event *event)\n{\n\tu32 val, subval, reg, shift;\n\tint counter = event->hw.idx;\n\tstruct ali_drw_pmu *drw_pmu = to_ali_drw_pmu(event->pmu);\n\n\treg = ALI_DRW_PMU_EVENT_SELn(counter);\n\tval = readl(drw_pmu->cfg_base + reg);\n\tsubval = FIELD_PREP(ALI_DRW_PMCOM_CNT_EN, 1) |\n\t\t FIELD_PREP(ALI_DRW_PMCOM_CNT_EVENT_MASK, drw_pmu->evtids[counter]);\n\n\tshift = ALI_DRW_PMCOM_CNT_EVENT_OFFSET(counter);\n\tval &= ~(GENMASK(7, 0) << shift);\n\tval |= subval << shift;\n\n\twritel(val, drw_pmu->cfg_base + reg);\n}\n\nstatic void ali_drw_pmu_disable_counter(struct perf_event *event)\n{\n\tu32 val, reg, subval, shift;\n\tstruct ali_drw_pmu *drw_pmu = to_ali_drw_pmu(event->pmu);\n\tint counter = event->hw.idx;\n\n\treg = ALI_DRW_PMU_EVENT_SELn(counter);\n\tval = readl(drw_pmu->cfg_base + reg);\n\tsubval = FIELD_PREP(ALI_DRW_PMCOM_CNT_EN, 0) |\n\t\t FIELD_PREP(ALI_DRW_PMCOM_CNT_EVENT_MASK, 0);\n\n\tshift = ALI_DRW_PMCOM_CNT_EVENT_OFFSET(counter);\n\tval &= ~(GENMASK(7, 0) << shift);\n\tval |= subval << shift;\n\n\twritel(val, drw_pmu->cfg_base + reg);\n}\n\nstatic irqreturn_t ali_drw_pmu_isr(int irq_num, void *data)\n{\n\tstruct ali_drw_pmu_irq *irq = data;\n\tstruct ali_drw_pmu *drw_pmu;\n\tirqreturn_t ret = IRQ_NONE;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(drw_pmu, &irq->pmus_node, pmus_node) {\n\t\tunsigned long status, clr_status;\n\t\tstruct perf_event *event;\n\t\tunsigned int idx;\n\n\t\tfor (idx = 0; idx < ALI_DRW_PMU_COMMON_MAX_COUNTERS; idx++) {\n\t\t\tevent = drw_pmu->events[idx];\n\t\t\tif (!event)\n\t\t\t\tcontinue;\n\t\t\tali_drw_pmu_disable_counter(event);\n\t\t}\n\n\t\t \n\t\tstatus = readl(drw_pmu->cfg_base + ALI_DRW_PMU_OV_INTR_STATUS);\n\t\tstatus = FIELD_GET(ALI_DRW_PMCOM_CNT_OV_INTR_MASK, status);\n\t\tif (status) {\n\t\t\tfor_each_set_bit(idx, &status,\n\t\t\t\t\t ALI_DRW_PMU_COMMON_MAX_COUNTERS) {\n\t\t\t\tevent = drw_pmu->events[idx];\n\t\t\t\tif (WARN_ON_ONCE(!event))\n\t\t\t\t\tcontinue;\n\t\t\t\tali_drw_pmu_event_update(event);\n\t\t\t\tali_drw_pmu_event_set_period(event);\n\t\t\t}\n\n\t\t\t \n\t\t\tclr_status = FIELD_PREP(ALI_DRW_PMCOM_CNT_OV_INTR_MASK, 1);\n\t\t\twritel(clr_status,\n\t\t\t       drw_pmu->cfg_base + ALI_DRW_PMU_OV_INTR_CLR);\n\t\t}\n\n\t\tfor (idx = 0; idx < ALI_DRW_PMU_COMMON_MAX_COUNTERS; idx++) {\n\t\t\tevent = drw_pmu->events[idx];\n\t\t\tif (!event)\n\t\t\t\tcontinue;\n\t\t\tif (!(event->hw.state & PERF_HES_STOPPED))\n\t\t\t\tali_drw_pmu_enable_counter(event);\n\t\t}\n\t\tif (status)\n\t\t\tret = IRQ_HANDLED;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic struct ali_drw_pmu_irq *__ali_drw_pmu_init_irq(struct platform_device\n\t\t\t\t\t\t      *pdev, int irq_num)\n{\n\tint ret;\n\tstruct ali_drw_pmu_irq *irq;\n\n\tlist_for_each_entry(irq, &ali_drw_pmu_irqs, irqs_node) {\n\t\tif (irq->irq_num == irq_num\n\t\t    && refcount_inc_not_zero(&irq->refcount))\n\t\t\treturn irq;\n\t}\n\n\tirq = kzalloc(sizeof(*irq), GFP_KERNEL);\n\tif (!irq)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&irq->pmus_node);\n\n\t \n\tirq->cpu = smp_processor_id();\n\trefcount_set(&irq->refcount, 1);\n\n\t \n\tret = devm_request_irq(&pdev->dev, irq_num, ali_drw_pmu_isr,\n\t\t\t       IRQF_SHARED, dev_name(&pdev->dev), irq);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Fail to request IRQ:%d ret:%d\\n\", irq_num, ret);\n\t\tgoto out_free;\n\t}\n\n\tret = irq_set_affinity_hint(irq_num, cpumask_of(irq->cpu));\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = cpuhp_state_add_instance_nocalls(ali_drw_cpuhp_state_num,\n\t\t\t\t\t     &irq->node);\n\tif (ret)\n\t\tgoto out_free;\n\n\tirq->irq_num = irq_num;\n\tlist_add(&irq->irqs_node, &ali_drw_pmu_irqs);\n\n\treturn irq;\n\nout_free:\n\tkfree(irq);\n\treturn ERR_PTR(ret);\n}\n\nstatic int ali_drw_pmu_init_irq(struct ali_drw_pmu *drw_pmu,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tint irq_num;\n\tstruct ali_drw_pmu_irq *irq;\n\n\t \n\tirq_num = platform_get_irq(pdev, 0);\n\tif (irq_num < 0)\n\t\treturn irq_num;\n\n\tmutex_lock(&ali_drw_pmu_irqs_lock);\n\tirq = __ali_drw_pmu_init_irq(pdev, irq_num);\n\tmutex_unlock(&ali_drw_pmu_irqs_lock);\n\n\tif (IS_ERR(irq))\n\t\treturn PTR_ERR(irq);\n\n\tdrw_pmu->irq = irq;\n\n\tmutex_lock(&ali_drw_pmu_irqs_lock);\n\tlist_add_rcu(&drw_pmu->pmus_node, &irq->pmus_node);\n\tmutex_unlock(&ali_drw_pmu_irqs_lock);\n\n\treturn 0;\n}\n\nstatic void ali_drw_pmu_uninit_irq(struct ali_drw_pmu *drw_pmu)\n{\n\tstruct ali_drw_pmu_irq *irq = drw_pmu->irq;\n\n\tmutex_lock(&ali_drw_pmu_irqs_lock);\n\tlist_del_rcu(&drw_pmu->pmus_node);\n\n\tif (!refcount_dec_and_test(&irq->refcount)) {\n\t\tmutex_unlock(&ali_drw_pmu_irqs_lock);\n\t\treturn;\n\t}\n\n\tlist_del(&irq->irqs_node);\n\tmutex_unlock(&ali_drw_pmu_irqs_lock);\n\n\tWARN_ON(irq_set_affinity_hint(irq->irq_num, NULL));\n\tcpuhp_state_remove_instance_nocalls(ali_drw_cpuhp_state_num,\n\t\t\t\t\t    &irq->node);\n\tkfree(irq);\n}\n\nstatic int ali_drw_pmu_event_init(struct perf_event *event)\n{\n\tstruct ali_drw_pmu *drw_pmu = to_ali_drw_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct perf_event *sibling;\n\tstruct device *dev = drw_pmu->pmu.dev;\n\n\tif (event->attr.type != event->pmu->type)\n\t\treturn -ENOENT;\n\n\tif (is_sampling_event(event)) {\n\t\tdev_err(dev, \"Sampling not supported!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (event->attach_state & PERF_ATTACH_TASK) {\n\t\tdev_err(dev, \"Per-task counter cannot allocate!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tevent->cpu = drw_pmu->cpu;\n\tif (event->cpu < 0) {\n\t\tdev_err(dev, \"Per-task mode not supported!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (event->group_leader != event &&\n\t    !is_software_event(event->group_leader)) {\n\t\tdev_err(dev, \"driveway only allow one event!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_sibling_event(sibling, event->group_leader) {\n\t\tif (sibling != event && !is_software_event(sibling)) {\n\t\t\tdev_err(dev, \"driveway event not allowed!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\twritel(ALI_DRW_PMU_CNT_RST, drw_pmu->cfg_base + ALI_DRW_PMU_CNT_CTRL);\n\n\thwc->idx = -1;\n\n\treturn 0;\n}\n\nstatic void ali_drw_pmu_start(struct perf_event *event, int flags)\n{\n\tstruct ali_drw_pmu *drw_pmu = to_ali_drw_pmu(event->pmu);\n\n\tevent->hw.state = 0;\n\n\tif (GET_DRW_EVENTID(event) == ALI_DRW_PMU_CYCLE_EVT_ID) {\n\t\twritel(ALI_DRW_PMU_CNT_START,\n\t\t       drw_pmu->cfg_base + ALI_DRW_PMU_CNT_CTRL);\n\t\treturn;\n\t}\n\n\tali_drw_pmu_event_set_period(event);\n\tif (flags & PERF_EF_RELOAD) {\n\t\tunsigned long prev_raw_count =\n\t\t    local64_read(&event->hw.prev_count);\n\t\twritel(prev_raw_count,\n\t\t       drw_pmu->cfg_base + ALI_DRW_PMU_CNT_PRELOAD);\n\t}\n\n\tali_drw_pmu_enable_counter(event);\n\n\twritel(ALI_DRW_PMU_CNT_START, drw_pmu->cfg_base + ALI_DRW_PMU_CNT_CTRL);\n}\n\nstatic void ali_drw_pmu_stop(struct perf_event *event, int flags)\n{\n\tstruct ali_drw_pmu *drw_pmu = to_ali_drw_pmu(event->pmu);\n\n\tif (event->hw.state & PERF_HES_STOPPED)\n\t\treturn;\n\n\tif (GET_DRW_EVENTID(event) != ALI_DRW_PMU_CYCLE_EVT_ID)\n\t\tali_drw_pmu_disable_counter(event);\n\n\twritel(ALI_DRW_PMU_CNT_STOP, drw_pmu->cfg_base + ALI_DRW_PMU_CNT_CTRL);\n\n\tali_drw_pmu_event_update(event);\n\tevent->hw.state |= PERF_HES_STOPPED | PERF_HES_UPTODATE;\n}\n\nstatic int ali_drw_pmu_add(struct perf_event *event, int flags)\n{\n\tstruct ali_drw_pmu *drw_pmu = to_ali_drw_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx = -1;\n\tint evtid;\n\n\tevtid = GET_DRW_EVENTID(event);\n\n\tif (evtid != ALI_DRW_PMU_CYCLE_EVT_ID) {\n\t\tidx = ali_drw_get_counter_idx(event);\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\t\tdrw_pmu->events[idx] = event;\n\t\tdrw_pmu->evtids[idx] = evtid;\n\t}\n\thwc->idx = idx;\n\n\thwc->state = PERF_HES_STOPPED | PERF_HES_UPTODATE;\n\n\tif (flags & PERF_EF_START)\n\t\tali_drw_pmu_start(event, PERF_EF_RELOAD);\n\n\t \n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void ali_drw_pmu_del(struct perf_event *event, int flags)\n{\n\tstruct ali_drw_pmu *drw_pmu = to_ali_drw_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx = hwc->idx;\n\n\tali_drw_pmu_stop(event, PERF_EF_UPDATE);\n\n\tif (idx >= 0 && idx < ALI_DRW_PMU_COMMON_MAX_COUNTERS) {\n\t\tdrw_pmu->events[idx] = NULL;\n\t\tdrw_pmu->evtids[idx] = 0;\n\t\tclear_bit(idx, drw_pmu->used_mask);\n\t}\n\n\tperf_event_update_userpage(event);\n}\n\nstatic void ali_drw_pmu_read(struct perf_event *event)\n{\n\tali_drw_pmu_event_update(event);\n}\n\nstatic int ali_drw_pmu_probe(struct platform_device *pdev)\n{\n\tstruct ali_drw_pmu *drw_pmu;\n\tstruct resource *res;\n\tchar *name;\n\tint ret;\n\n\tdrw_pmu = devm_kzalloc(&pdev->dev, sizeof(*drw_pmu), GFP_KERNEL);\n\tif (!drw_pmu)\n\t\treturn -ENOMEM;\n\n\tdrw_pmu->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, drw_pmu);\n\n\tdrw_pmu->cfg_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(drw_pmu->cfg_base))\n\t\treturn PTR_ERR(drw_pmu->cfg_base);\n\n\tname = devm_kasprintf(drw_pmu->dev, GFP_KERNEL, \"ali_drw_%llx\",\n\t\t\t      (u64) (res->start >> ALI_DRW_PMU_PA_SHIFT));\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\twritel(ALI_DRW_PMU_CNT_RST, drw_pmu->cfg_base + ALI_DRW_PMU_CNT_CTRL);\n\n\t \n\twritel(ALI_DRW_PMCOM_CNT_OV_INTR_MASK,\n\t       drw_pmu->cfg_base + ALI_DRW_PMU_OV_INTR_ENABLE_CTL);\n\n\t \n\twritel(0xffffff, drw_pmu->cfg_base + ALI_DRW_PMU_OV_INTR_CLR);\n\n\tdrw_pmu->cpu = smp_processor_id();\n\n\tret = ali_drw_pmu_init_irq(drw_pmu, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdrw_pmu->pmu = (struct pmu) {\n\t\t.module\t\t= THIS_MODULE,\n\t\t.task_ctx_nr\t= perf_invalid_context,\n\t\t.event_init\t= ali_drw_pmu_event_init,\n\t\t.add\t\t= ali_drw_pmu_add,\n\t\t.del\t\t= ali_drw_pmu_del,\n\t\t.start\t\t= ali_drw_pmu_start,\n\t\t.stop\t\t= ali_drw_pmu_stop,\n\t\t.read\t\t= ali_drw_pmu_read,\n\t\t.attr_groups\t= ali_drw_pmu_attr_groups,\n\t\t.capabilities\t= PERF_PMU_CAP_NO_EXCLUDE,\n\t};\n\n\tret = perf_pmu_register(&drw_pmu->pmu, name, -1);\n\tif (ret) {\n\t\tdev_err(drw_pmu->dev, \"DRW Driveway PMU PMU register failed!\\n\");\n\t\tali_drw_pmu_uninit_irq(drw_pmu);\n\t}\n\n\treturn ret;\n}\n\nstatic int ali_drw_pmu_remove(struct platform_device *pdev)\n{\n\tstruct ali_drw_pmu *drw_pmu = platform_get_drvdata(pdev);\n\n\t \n\twritel(ALI_DRW_PMCOM_CNT_OV_INTR_MASK,\n\t       drw_pmu->cfg_base + ALI_DRW_PMU_OV_INTR_DISABLE_CTL);\n\n\tali_drw_pmu_uninit_irq(drw_pmu);\n\tperf_pmu_unregister(&drw_pmu->pmu);\n\n\treturn 0;\n}\n\nstatic int ali_drw_pmu_offline_cpu(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct ali_drw_pmu_irq *irq;\n\tstruct ali_drw_pmu *drw_pmu;\n\tunsigned int target;\n\tint ret;\n\tcpumask_t node_online_cpus;\n\n\tirq = hlist_entry_safe(node, struct ali_drw_pmu_irq, node);\n\tif (cpu != irq->cpu)\n\t\treturn 0;\n\n\tret = cpumask_and(&node_online_cpus,\n\t\t\t  cpumask_of_node(cpu_to_node(cpu)), cpu_online_mask);\n\tif (ret)\n\t\ttarget = cpumask_any_but(&node_online_cpus, cpu);\n\telse\n\t\ttarget = cpumask_any_but(cpu_online_mask, cpu);\n\n\tif (target >= nr_cpu_ids)\n\t\treturn 0;\n\n\t \n\tmutex_lock(&ali_drw_pmu_irqs_lock);\n\tlist_for_each_entry(drw_pmu, &irq->pmus_node, pmus_node)\n\t\tperf_pmu_migrate_context(&drw_pmu->pmu, irq->cpu, target);\n\tmutex_unlock(&ali_drw_pmu_irqs_lock);\n\n\tWARN_ON(irq_set_affinity_hint(irq->irq_num, cpumask_of(target)));\n\tirq->cpu = target;\n\n\treturn 0;\n}\n\n \nstatic const struct acpi_device_id ali_drw_acpi_match[] = {\n\t{\"BABA5000\", 0},\n\t{\"ARMHD700\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, ali_drw_acpi_match);\n\nstatic struct platform_driver ali_drw_pmu_driver = {\n\t.driver = {\n\t\t   .name = \"ali_drw_pmu\",\n\t\t   .acpi_match_table = ali_drw_acpi_match,\n\t\t   },\n\t.probe = ali_drw_pmu_probe,\n\t.remove = ali_drw_pmu_remove,\n};\n\nstatic int __init ali_drw_pmu_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t      \"ali_drw_pmu:online\",\n\t\t\t\t      NULL, ali_drw_pmu_offline_cpu);\n\n\tif (ret < 0) {\n\t\tpr_err(\"DRW Driveway PMU: setup hotplug failed, ret = %d\\n\",\n\t\t       ret);\n\t\treturn ret;\n\t}\n\tali_drw_cpuhp_state_num = ret;\n\n\tret = platform_driver_register(&ali_drw_pmu_driver);\n\tif (ret)\n\t\tcpuhp_remove_multi_state(ali_drw_cpuhp_state_num);\n\n\treturn ret;\n}\n\nstatic void __exit ali_drw_pmu_exit(void)\n{\n\tplatform_driver_unregister(&ali_drw_pmu_driver);\n\tcpuhp_remove_multi_state(ali_drw_cpuhp_state_num);\n}\n\nmodule_init(ali_drw_pmu_init);\nmodule_exit(ali_drw_pmu_exit);\n\nMODULE_AUTHOR(\"Hongbo Yao <yaohongbo@linux.alibaba.com>\");\nMODULE_AUTHOR(\"Neng Chen <nengchen@linux.alibaba.com>\");\nMODULE_AUTHOR(\"Shuai Xue <xueshuai@linux.alibaba.com>\");\nMODULE_DESCRIPTION(\"Alibaba DDR Sub-System Driveway PMU driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}