{
  "module_name": "qcom_l2_pmu.c",
  "hash_id": "f3a3552a23fc7eb61010eec3006ab9487d3b665a41399e878931d0716b9336b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/qcom_l2_pmu.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/bug.h>\n#include <linux/cpuhotplug.h>\n#include <linux/cpumask.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/perf_event.h>\n#include <linux/platform_device.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n\n#include <asm/barrier.h>\n#include <asm/local64.h>\n#include <asm/sysreg.h>\n#include <soc/qcom/kryo-l2-accessors.h>\n\n#define MAX_L2_CTRS             9\n\n#define L2PMCR_NUM_EV_SHIFT     11\n#define L2PMCR_NUM_EV_MASK      0x1F\n\n#define L2PMCR                  0x400\n#define L2PMCNTENCLR            0x403\n#define L2PMCNTENSET            0x404\n#define L2PMINTENCLR            0x405\n#define L2PMINTENSET            0x406\n#define L2PMOVSCLR              0x407\n#define L2PMOVSSET              0x408\n#define L2PMCCNTCR              0x409\n#define L2PMCCNTR               0x40A\n#define L2PMCCNTSR              0x40C\n#define L2PMRESR                0x410\n#define IA_L2PMXEVCNTCR_BASE    0x420\n#define IA_L2PMXEVCNTR_BASE     0x421\n#define IA_L2PMXEVFILTER_BASE   0x423\n#define IA_L2PMXEVTYPER_BASE    0x424\n\n#define IA_L2_REG_OFFSET        0x10\n\n#define L2PMXEVFILTER_SUFILTER_ALL      0x000E0000\n#define L2PMXEVFILTER_ORGFILTER_IDINDEP 0x00000004\n#define L2PMXEVFILTER_ORGFILTER_ALL     0x00000003\n\n#define L2EVTYPER_REG_SHIFT     3\n\n#define L2PMRESR_GROUP_BITS     8\n#define L2PMRESR_GROUP_MASK     GENMASK(7, 0)\n\n#define L2CYCLE_CTR_BIT         31\n#define L2CYCLE_CTR_RAW_CODE    0xFE\n\n#define L2PMCR_RESET_ALL        0x6\n#define L2PMCR_COUNTERS_ENABLE  0x1\n#define L2PMCR_COUNTERS_DISABLE 0x0\n\n#define L2PMRESR_EN             BIT_ULL(63)\n\n#define L2_EVT_MASK             0x00000FFF\n#define L2_EVT_CODE_MASK        0x00000FF0\n#define L2_EVT_GRP_MASK         0x0000000F\n#define L2_EVT_CODE_SHIFT       4\n#define L2_EVT_GRP_SHIFT        0\n\n#define L2_EVT_CODE(event)   (((event) & L2_EVT_CODE_MASK) >> L2_EVT_CODE_SHIFT)\n#define L2_EVT_GROUP(event)  (((event) & L2_EVT_GRP_MASK) >> L2_EVT_GRP_SHIFT)\n\n#define L2_EVT_GROUP_MAX        7\n\n#define L2_COUNTER_RELOAD       BIT_ULL(31)\n#define L2_CYCLE_COUNTER_RELOAD BIT_ULL(63)\n\n\n#define reg_idx(reg, i)         (((i) * IA_L2_REG_OFFSET) + reg##_BASE)\n\n \n#define L2_EVENT_CYCLES                    0xfe\n#define L2_EVENT_DCACHE_OPS                0x400\n#define L2_EVENT_ICACHE_OPS                0x401\n#define L2_EVENT_TLBI                      0x402\n#define L2_EVENT_BARRIERS                  0x403\n#define L2_EVENT_TOTAL_READS               0x405\n#define L2_EVENT_TOTAL_WRITES              0x406\n#define L2_EVENT_TOTAL_REQUESTS            0x407\n#define L2_EVENT_LDREX                     0x420\n#define L2_EVENT_STREX                     0x421\n#define L2_EVENT_CLREX                     0x422\n\n\n\nstruct cluster_pmu;\n\n \nstruct l2cache_pmu {\n\tstruct hlist_node node;\n\tu32 num_pmus;\n\tstruct pmu pmu;\n\tint num_counters;\n\tcpumask_t cpumask;\n\tstruct platform_device *pdev;\n\tstruct cluster_pmu * __percpu *pmu_cluster;\n\tstruct list_head clusters;\n};\n\n \nstruct cluster_pmu {\n\tstruct list_head next;\n\tstruct perf_event *events[MAX_L2_CTRS];\n\tstruct l2cache_pmu *l2cache_pmu;\n\tDECLARE_BITMAP(used_counters, MAX_L2_CTRS);\n\tDECLARE_BITMAP(used_groups, L2_EVT_GROUP_MAX + 1);\n\tint irq;\n\tint cluster_id;\n\t \n\tint on_cpu;\n\t \n\tcpumask_t cluster_cpus;\n\tspinlock_t pmu_lock;\n};\n\n#define to_l2cache_pmu(p) (container_of(p, struct l2cache_pmu, pmu))\n\nstatic u32 l2_cycle_ctr_idx;\nstatic u32 l2_counter_present_mask;\n\nstatic inline u32 idx_to_reg_bit(u32 idx)\n{\n\tif (idx == l2_cycle_ctr_idx)\n\t\treturn BIT(L2CYCLE_CTR_BIT);\n\n\treturn BIT(idx);\n}\n\nstatic inline struct cluster_pmu *get_cluster_pmu(\n\tstruct l2cache_pmu *l2cache_pmu, int cpu)\n{\n\treturn *per_cpu_ptr(l2cache_pmu->pmu_cluster, cpu);\n}\n\nstatic void cluster_pmu_reset(void)\n{\n\t \n\tkryo_l2_set_indirect_reg(L2PMCR, L2PMCR_RESET_ALL);\n\tkryo_l2_set_indirect_reg(L2PMCNTENCLR, l2_counter_present_mask);\n\tkryo_l2_set_indirect_reg(L2PMINTENCLR, l2_counter_present_mask);\n\tkryo_l2_set_indirect_reg(L2PMOVSCLR, l2_counter_present_mask);\n}\n\nstatic inline void cluster_pmu_enable(void)\n{\n\tkryo_l2_set_indirect_reg(L2PMCR, L2PMCR_COUNTERS_ENABLE);\n}\n\nstatic inline void cluster_pmu_disable(void)\n{\n\tkryo_l2_set_indirect_reg(L2PMCR, L2PMCR_COUNTERS_DISABLE);\n}\n\nstatic inline void cluster_pmu_counter_set_value(u32 idx, u64 value)\n{\n\tif (idx == l2_cycle_ctr_idx)\n\t\tkryo_l2_set_indirect_reg(L2PMCCNTR, value);\n\telse\n\t\tkryo_l2_set_indirect_reg(reg_idx(IA_L2PMXEVCNTR, idx), value);\n}\n\nstatic inline u64 cluster_pmu_counter_get_value(u32 idx)\n{\n\tu64 value;\n\n\tif (idx == l2_cycle_ctr_idx)\n\t\tvalue = kryo_l2_get_indirect_reg(L2PMCCNTR);\n\telse\n\t\tvalue = kryo_l2_get_indirect_reg(reg_idx(IA_L2PMXEVCNTR, idx));\n\n\treturn value;\n}\n\nstatic inline void cluster_pmu_counter_enable(u32 idx)\n{\n\tkryo_l2_set_indirect_reg(L2PMCNTENSET, idx_to_reg_bit(idx));\n}\n\nstatic inline void cluster_pmu_counter_disable(u32 idx)\n{\n\tkryo_l2_set_indirect_reg(L2PMCNTENCLR, idx_to_reg_bit(idx));\n}\n\nstatic inline void cluster_pmu_counter_enable_interrupt(u32 idx)\n{\n\tkryo_l2_set_indirect_reg(L2PMINTENSET, idx_to_reg_bit(idx));\n}\n\nstatic inline void cluster_pmu_counter_disable_interrupt(u32 idx)\n{\n\tkryo_l2_set_indirect_reg(L2PMINTENCLR, idx_to_reg_bit(idx));\n}\n\nstatic inline void cluster_pmu_set_evccntcr(u32 val)\n{\n\tkryo_l2_set_indirect_reg(L2PMCCNTCR, val);\n}\n\nstatic inline void cluster_pmu_set_evcntcr(u32 ctr, u32 val)\n{\n\tkryo_l2_set_indirect_reg(reg_idx(IA_L2PMXEVCNTCR, ctr), val);\n}\n\nstatic inline void cluster_pmu_set_evtyper(u32 ctr, u32 val)\n{\n\tkryo_l2_set_indirect_reg(reg_idx(IA_L2PMXEVTYPER, ctr), val);\n}\n\nstatic void cluster_pmu_set_resr(struct cluster_pmu *cluster,\n\t\t\t       u32 event_group, u32 event_cc)\n{\n\tu64 field;\n\tu64 resr_val;\n\tu32 shift;\n\tunsigned long flags;\n\n\tshift = L2PMRESR_GROUP_BITS * event_group;\n\tfield = ((u64)(event_cc & L2PMRESR_GROUP_MASK) << shift);\n\n\tspin_lock_irqsave(&cluster->pmu_lock, flags);\n\n\tresr_val = kryo_l2_get_indirect_reg(L2PMRESR);\n\tresr_val &= ~(L2PMRESR_GROUP_MASK << shift);\n\tresr_val |= field;\n\tresr_val |= L2PMRESR_EN;\n\tkryo_l2_set_indirect_reg(L2PMRESR, resr_val);\n\n\tspin_unlock_irqrestore(&cluster->pmu_lock, flags);\n}\n\n \nstatic inline void cluster_pmu_set_evfilter_sys_mode(u32 ctr)\n{\n\tu32 val =  L2PMXEVFILTER_SUFILTER_ALL |\n\t\t   L2PMXEVFILTER_ORGFILTER_IDINDEP |\n\t\t   L2PMXEVFILTER_ORGFILTER_ALL;\n\n\tkryo_l2_set_indirect_reg(reg_idx(IA_L2PMXEVFILTER, ctr), val);\n}\n\nstatic inline u32 cluster_pmu_getreset_ovsr(void)\n{\n\tu32 result = kryo_l2_get_indirect_reg(L2PMOVSSET);\n\n\tkryo_l2_set_indirect_reg(L2PMOVSCLR, result);\n\treturn result;\n}\n\nstatic inline bool cluster_pmu_has_overflowed(u32 ovsr)\n{\n\treturn !!(ovsr & l2_counter_present_mask);\n}\n\nstatic inline bool cluster_pmu_counter_has_overflowed(u32 ovsr, u32 idx)\n{\n\treturn !!(ovsr & idx_to_reg_bit(idx));\n}\n\nstatic void l2_cache_event_update(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 delta, prev, now;\n\tu32 idx = hwc->idx;\n\n\tdo {\n\t\tprev = local64_read(&hwc->prev_count);\n\t\tnow = cluster_pmu_counter_get_value(idx);\n\t} while (local64_cmpxchg(&hwc->prev_count, prev, now) != prev);\n\n\t \n\tdelta = now - prev;\n\tif (idx != l2_cycle_ctr_idx)\n\t\tdelta &= 0xffffffff;\n\n\tlocal64_add(delta, &event->count);\n}\n\nstatic void l2_cache_cluster_set_period(struct cluster_pmu *cluster,\n\t\t\t\t       struct hw_perf_event *hwc)\n{\n\tu32 idx = hwc->idx;\n\tu64 new;\n\n\t \n\tif (idx == l2_cycle_ctr_idx)\n\t\tnew = L2_CYCLE_COUNTER_RELOAD;\n\telse\n\t\tnew = L2_COUNTER_RELOAD;\n\n\tlocal64_set(&hwc->prev_count, new);\n\tcluster_pmu_counter_set_value(idx, new);\n}\n\nstatic int l2_cache_get_event_idx(struct cluster_pmu *cluster,\n\t\t\t\t   struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx;\n\tint num_ctrs = cluster->l2cache_pmu->num_counters - 1;\n\tunsigned int group;\n\n\tif (hwc->config_base == L2CYCLE_CTR_RAW_CODE) {\n\t\tif (test_and_set_bit(l2_cycle_ctr_idx, cluster->used_counters))\n\t\t\treturn -EAGAIN;\n\n\t\treturn l2_cycle_ctr_idx;\n\t}\n\n\tidx = find_first_zero_bit(cluster->used_counters, num_ctrs);\n\tif (idx == num_ctrs)\n\t\t \n\t\treturn -EAGAIN;\n\n\t \n\tgroup = L2_EVT_GROUP(hwc->config_base);\n\tif (test_bit(group, cluster->used_groups))\n\t\treturn -EAGAIN;\n\n\tset_bit(idx, cluster->used_counters);\n\tset_bit(group, cluster->used_groups);\n\n\treturn idx;\n}\n\nstatic void l2_cache_clear_event_idx(struct cluster_pmu *cluster,\n\t\t\t\t      struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx = hwc->idx;\n\n\tclear_bit(idx, cluster->used_counters);\n\tif (hwc->config_base != L2CYCLE_CTR_RAW_CODE)\n\t\tclear_bit(L2_EVT_GROUP(hwc->config_base), cluster->used_groups);\n}\n\nstatic irqreturn_t l2_cache_handle_irq(int irq_num, void *data)\n{\n\tstruct cluster_pmu *cluster = data;\n\tint num_counters = cluster->l2cache_pmu->num_counters;\n\tu32 ovsr;\n\tint idx;\n\n\tovsr = cluster_pmu_getreset_ovsr();\n\tif (!cluster_pmu_has_overflowed(ovsr))\n\t\treturn IRQ_NONE;\n\n\tfor_each_set_bit(idx, cluster->used_counters, num_counters) {\n\t\tstruct perf_event *event = cluster->events[idx];\n\t\tstruct hw_perf_event *hwc;\n\n\t\tif (WARN_ON_ONCE(!event))\n\t\t\tcontinue;\n\n\t\tif (!cluster_pmu_counter_has_overflowed(ovsr, idx))\n\t\t\tcontinue;\n\n\t\tl2_cache_event_update(event);\n\t\thwc = &event->hw;\n\n\t\tl2_cache_cluster_set_period(cluster, hwc);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void l2_cache_pmu_enable(struct pmu *pmu)\n{\n\t \n\n\tcluster_pmu_enable();\n}\n\nstatic void l2_cache_pmu_disable(struct pmu *pmu)\n{\n\tcluster_pmu_disable();\n}\n\nstatic int l2_cache_event_init(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct cluster_pmu *cluster;\n\tstruct perf_event *sibling;\n\tstruct l2cache_pmu *l2cache_pmu;\n\n\tif (event->attr.type != event->pmu->type)\n\t\treturn -ENOENT;\n\n\tl2cache_pmu = to_l2cache_pmu(event->pmu);\n\n\tif (hwc->sample_period) {\n\t\tdev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\n\t\t\t\t    \"Sampling not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (event->cpu < 0) {\n\t\tdev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\n\t\t\t\t    \"Per-task mode not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (((L2_EVT_GROUP(event->attr.config) > L2_EVT_GROUP_MAX) ||\n\t     ((event->attr.config & ~L2_EVT_MASK) != 0)) &&\n\t    (event->attr.config != L2CYCLE_CTR_RAW_CODE)) {\n\t\tdev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\n\t\t\t\t    \"Invalid config %llx\\n\",\n\t\t\t\t    event->attr.config);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (event->group_leader->pmu != event->pmu &&\n\t    !is_software_event(event->group_leader)) {\n\t\tdev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\n\t\t\t \"Can't create mixed PMU group\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_sibling_event(sibling, event->group_leader) {\n\t\tif (sibling->pmu != event->pmu &&\n\t\t    !is_software_event(sibling)) {\n\t\t\tdev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\n\t\t\t\t \"Can't create mixed PMU group\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tcluster = get_cluster_pmu(l2cache_pmu, event->cpu);\n\tif (!cluster) {\n\t\t \n\t\tdev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\n\t\t\t\"CPU%d not associated with L2 cluster\\n\", event->cpu);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((event->group_leader != event) &&\n\t    (cluster->on_cpu != event->group_leader->cpu)) {\n\t\tdev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\n\t\t\t \"Can't create group on CPUs %d and %d\",\n\t\t\t event->cpu, event->group_leader->cpu);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((event != event->group_leader) &&\n\t    !is_software_event(event->group_leader) &&\n\t    (L2_EVT_GROUP(event->group_leader->attr.config) ==\n\t     L2_EVT_GROUP(event->attr.config))) {\n\t\tdev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\n\t\t\t \"Column exclusion: conflicting events %llx %llx\\n\",\n\t\t       event->group_leader->attr.config,\n\t\t       event->attr.config);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_sibling_event(sibling, event->group_leader) {\n\t\tif ((sibling != event) &&\n\t\t    !is_software_event(sibling) &&\n\t\t    (L2_EVT_GROUP(sibling->attr.config) ==\n\t\t     L2_EVT_GROUP(event->attr.config))) {\n\t\t\tdev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\n\t\t\t     \"Column exclusion: conflicting events %llx %llx\\n\",\n\t\t\t\t\t    sibling->attr.config,\n\t\t\t\t\t    event->attr.config);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\thwc->idx = -1;\n\thwc->config_base = event->attr.config;\n\n\t \n\tevent->cpu = cluster->on_cpu;\n\n\treturn 0;\n}\n\nstatic void l2_cache_event_start(struct perf_event *event, int flags)\n{\n\tstruct cluster_pmu *cluster;\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx = hwc->idx;\n\tu32 config;\n\tu32 event_cc, event_group;\n\n\thwc->state = 0;\n\n\tcluster = get_cluster_pmu(to_l2cache_pmu(event->pmu), event->cpu);\n\n\tl2_cache_cluster_set_period(cluster, hwc);\n\n\tif (hwc->config_base == L2CYCLE_CTR_RAW_CODE) {\n\t\tcluster_pmu_set_evccntcr(0);\n\t} else {\n\t\tconfig = hwc->config_base;\n\t\tevent_cc    = L2_EVT_CODE(config);\n\t\tevent_group = L2_EVT_GROUP(config);\n\n\t\tcluster_pmu_set_evcntcr(idx, 0);\n\t\tcluster_pmu_set_evtyper(idx, event_group);\n\t\tcluster_pmu_set_resr(cluster, event_group, event_cc);\n\t\tcluster_pmu_set_evfilter_sys_mode(idx);\n\t}\n\n\tcluster_pmu_counter_enable_interrupt(idx);\n\tcluster_pmu_counter_enable(idx);\n}\n\nstatic void l2_cache_event_stop(struct perf_event *event, int flags)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx = hwc->idx;\n\n\tif (hwc->state & PERF_HES_STOPPED)\n\t\treturn;\n\n\tcluster_pmu_counter_disable_interrupt(idx);\n\tcluster_pmu_counter_disable(idx);\n\n\tif (flags & PERF_EF_UPDATE)\n\t\tl2_cache_event_update(event);\n\thwc->state |= PERF_HES_STOPPED | PERF_HES_UPTODATE;\n}\n\nstatic int l2_cache_event_add(struct perf_event *event, int flags)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx;\n\tint err = 0;\n\tstruct cluster_pmu *cluster;\n\n\tcluster = get_cluster_pmu(to_l2cache_pmu(event->pmu), event->cpu);\n\n\tidx = l2_cache_get_event_idx(cluster, event);\n\tif (idx < 0)\n\t\treturn idx;\n\n\thwc->idx = idx;\n\thwc->state = PERF_HES_STOPPED | PERF_HES_UPTODATE;\n\tcluster->events[idx] = event;\n\tlocal64_set(&hwc->prev_count, 0);\n\n\tif (flags & PERF_EF_START)\n\t\tl2_cache_event_start(event, flags);\n\n\t \n\tperf_event_update_userpage(event);\n\n\treturn err;\n}\n\nstatic void l2_cache_event_del(struct perf_event *event, int flags)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct cluster_pmu *cluster;\n\tint idx = hwc->idx;\n\n\tcluster = get_cluster_pmu(to_l2cache_pmu(event->pmu), event->cpu);\n\n\tl2_cache_event_stop(event, flags | PERF_EF_UPDATE);\n\tcluster->events[idx] = NULL;\n\tl2_cache_clear_event_idx(cluster, event);\n\n\tperf_event_update_userpage(event);\n}\n\nstatic void l2_cache_event_read(struct perf_event *event)\n{\n\tl2_cache_event_update(event);\n}\n\nstatic ssize_t l2_cache_pmu_cpumask_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct l2cache_pmu *l2cache_pmu = to_l2cache_pmu(dev_get_drvdata(dev));\n\n\treturn cpumap_print_to_pagebuf(true, buf, &l2cache_pmu->cpumask);\n}\n\nstatic struct device_attribute l2_cache_pmu_cpumask_attr =\n\t\t__ATTR(cpumask, S_IRUGO, l2_cache_pmu_cpumask_show, NULL);\n\nstatic struct attribute *l2_cache_pmu_cpumask_attrs[] = {\n\t&l2_cache_pmu_cpumask_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group l2_cache_pmu_cpumask_group = {\n\t.attrs = l2_cache_pmu_cpumask_attrs,\n};\n\n \nPMU_FORMAT_ATTR(l2_code,   \"config:4-11\");\nPMU_FORMAT_ATTR(l2_group,  \"config:0-3\");\nPMU_FORMAT_ATTR(event,     \"config:0-11\");\n\nstatic struct attribute *l2_cache_pmu_formats[] = {\n\t&format_attr_l2_code.attr,\n\t&format_attr_l2_group.attr,\n\t&format_attr_event.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group l2_cache_pmu_format_group = {\n\t.name = \"format\",\n\t.attrs = l2_cache_pmu_formats,\n};\n\nstatic ssize_t l2cache_pmu_event_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *page)\n{\n\tstruct perf_pmu_events_attr *pmu_attr;\n\n\tpmu_attr = container_of(attr, struct perf_pmu_events_attr, attr);\n\treturn sysfs_emit(page, \"event=0x%02llx\\n\", pmu_attr->id);\n}\n\n#define L2CACHE_EVENT_ATTR(_name, _id)\t\t\t    \\\n\tPMU_EVENT_ATTR_ID(_name, l2cache_pmu_event_show, _id)\n\nstatic struct attribute *l2_cache_pmu_events[] = {\n\tL2CACHE_EVENT_ATTR(cycles, L2_EVENT_CYCLES),\n\tL2CACHE_EVENT_ATTR(dcache-ops, L2_EVENT_DCACHE_OPS),\n\tL2CACHE_EVENT_ATTR(icache-ops, L2_EVENT_ICACHE_OPS),\n\tL2CACHE_EVENT_ATTR(tlbi, L2_EVENT_TLBI),\n\tL2CACHE_EVENT_ATTR(barriers, L2_EVENT_BARRIERS),\n\tL2CACHE_EVENT_ATTR(total-reads, L2_EVENT_TOTAL_READS),\n\tL2CACHE_EVENT_ATTR(total-writes, L2_EVENT_TOTAL_WRITES),\n\tL2CACHE_EVENT_ATTR(total-requests, L2_EVENT_TOTAL_REQUESTS),\n\tL2CACHE_EVENT_ATTR(ldrex, L2_EVENT_LDREX),\n\tL2CACHE_EVENT_ATTR(strex, L2_EVENT_STREX),\n\tL2CACHE_EVENT_ATTR(clrex, L2_EVENT_CLREX),\n\tNULL\n};\n\nstatic const struct attribute_group l2_cache_pmu_events_group = {\n\t.name = \"events\",\n\t.attrs = l2_cache_pmu_events,\n};\n\nstatic const struct attribute_group *l2_cache_pmu_attr_grps[] = {\n\t&l2_cache_pmu_format_group,\n\t&l2_cache_pmu_cpumask_group,\n\t&l2_cache_pmu_events_group,\n\tNULL,\n};\n\n \n\nstatic const struct acpi_device_id l2_cache_pmu_acpi_match[] = {\n\t{ \"QCOM8130\", },\n\t{ }\n};\n\nstatic int get_num_counters(void)\n{\n\tint val;\n\n\tval = kryo_l2_get_indirect_reg(L2PMCR);\n\n\t \n\treturn ((val >> L2PMCR_NUM_EV_SHIFT) & L2PMCR_NUM_EV_MASK) + 1;\n}\n\nstatic struct cluster_pmu *l2_cache_associate_cpu_with_cluster(\n\tstruct l2cache_pmu *l2cache_pmu, int cpu)\n{\n\tu64 mpidr;\n\tint cpu_cluster_id;\n\tstruct cluster_pmu *cluster;\n\n\t \n\tmpidr = read_cpuid_mpidr();\n\tif (mpidr & MPIDR_MT_BITMASK)\n\t\tcpu_cluster_id = MPIDR_AFFINITY_LEVEL(mpidr, 2);\n\telse\n\t\tcpu_cluster_id = MPIDR_AFFINITY_LEVEL(mpidr, 1);\n\n\tlist_for_each_entry(cluster, &l2cache_pmu->clusters, next) {\n\t\tif (cluster->cluster_id != cpu_cluster_id)\n\t\t\tcontinue;\n\n\t\tdev_info(&l2cache_pmu->pdev->dev,\n\t\t\t \"CPU%d associated with cluster %d\\n\", cpu,\n\t\t\t cluster->cluster_id);\n\t\tcpumask_set_cpu(cpu, &cluster->cluster_cpus);\n\t\t*per_cpu_ptr(l2cache_pmu->pmu_cluster, cpu) = cluster;\n\t\treturn cluster;\n\t}\n\n\treturn NULL;\n}\n\nstatic int l2cache_pmu_online_cpu(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct cluster_pmu *cluster;\n\tstruct l2cache_pmu *l2cache_pmu;\n\n\tl2cache_pmu = hlist_entry_safe(node, struct l2cache_pmu, node);\n\tcluster = get_cluster_pmu(l2cache_pmu, cpu);\n\tif (!cluster) {\n\t\t \n\t\tcluster = l2_cache_associate_cpu_with_cluster(l2cache_pmu, cpu);\n\t\tif (!cluster) {\n\t\t\t \n\t\t\tWARN_ONCE(1, \"No L2 cache cluster for CPU%d\\n\", cpu);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (cluster->on_cpu != -1)\n\t\treturn 0;\n\n\t \n\tcluster->on_cpu = cpu;\n\tcpumask_set_cpu(cpu, &l2cache_pmu->cpumask);\n\tcluster_pmu_reset();\n\n\tWARN_ON(irq_set_affinity(cluster->irq, cpumask_of(cpu)));\n\tenable_irq(cluster->irq);\n\n\treturn 0;\n}\n\nstatic int l2cache_pmu_offline_cpu(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct cluster_pmu *cluster;\n\tstruct l2cache_pmu *l2cache_pmu;\n\tcpumask_t cluster_online_cpus;\n\tunsigned int target;\n\n\tl2cache_pmu = hlist_entry_safe(node, struct l2cache_pmu, node);\n\tcluster = get_cluster_pmu(l2cache_pmu, cpu);\n\tif (!cluster)\n\t\treturn 0;\n\n\t \n\tif (cluster->on_cpu != cpu)\n\t\treturn 0;\n\n\t \n\tcpumask_clear_cpu(cpu, &l2cache_pmu->cpumask);\n\tcluster->on_cpu = -1;\n\n\t \n\tcpumask_and(&cluster_online_cpus, &cluster->cluster_cpus,\n\t\t    cpu_online_mask);\n\ttarget = cpumask_any_but(&cluster_online_cpus, cpu);\n\tif (target >= nr_cpu_ids) {\n\t\tdisable_irq(cluster->irq);\n\t\treturn 0;\n\t}\n\n\tperf_pmu_migrate_context(&l2cache_pmu->pmu, cpu, target);\n\tcluster->on_cpu = target;\n\tcpumask_set_cpu(target, &l2cache_pmu->cpumask);\n\tWARN_ON(irq_set_affinity(cluster->irq, cpumask_of(target)));\n\n\treturn 0;\n}\n\nstatic int l2_cache_pmu_probe_cluster(struct device *dev, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev->parent);\n\tstruct platform_device *sdev = to_platform_device(dev);\n\tstruct l2cache_pmu *l2cache_pmu = data;\n\tstruct cluster_pmu *cluster;\n\tu64 fw_cluster_id;\n\tint err;\n\tint irq;\n\n\terr = acpi_dev_uid_to_integer(ACPI_COMPANION(dev), &fw_cluster_id);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"unable to read ACPI uid\\n\");\n\t\treturn err;\n\t}\n\n\tcluster = devm_kzalloc(&pdev->dev, sizeof(*cluster), GFP_KERNEL);\n\tif (!cluster)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&cluster->next);\n\tcluster->cluster_id = fw_cluster_id;\n\n\tirq = platform_get_irq(sdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tcluster->irq = irq;\n\n\tcluster->l2cache_pmu = l2cache_pmu;\n\tcluster->on_cpu = -1;\n\n\terr = devm_request_irq(&pdev->dev, irq, l2_cache_handle_irq,\n\t\t\t       IRQF_NOBALANCING | IRQF_NO_THREAD |\n\t\t\t       IRQF_NO_AUTOEN,\n\t\t\t       \"l2-cache-pmu\", cluster);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to request IRQ%d for L2 PMU counters\\n\", irq);\n\t\treturn err;\n\t}\n\n\tdev_info(&pdev->dev,\n\t\t \"Registered L2 cache PMU cluster %lld\\n\", fw_cluster_id);\n\n\tspin_lock_init(&cluster->pmu_lock);\n\n\tlist_add(&cluster->next, &l2cache_pmu->clusters);\n\tl2cache_pmu->num_pmus++;\n\n\treturn 0;\n}\n\nstatic int l2_cache_pmu_probe(struct platform_device *pdev)\n{\n\tint err;\n\tstruct l2cache_pmu *l2cache_pmu;\n\n\tl2cache_pmu =\n\t\tdevm_kzalloc(&pdev->dev, sizeof(*l2cache_pmu), GFP_KERNEL);\n\tif (!l2cache_pmu)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&l2cache_pmu->clusters);\n\n\tplatform_set_drvdata(pdev, l2cache_pmu);\n\tl2cache_pmu->pmu = (struct pmu) {\n\t\t \n\t\t.name\t\t= \"l2cache_0\",\n\t\t.task_ctx_nr    = perf_invalid_context,\n\t\t.pmu_enable\t= l2_cache_pmu_enable,\n\t\t.pmu_disable\t= l2_cache_pmu_disable,\n\t\t.event_init\t= l2_cache_event_init,\n\t\t.add\t\t= l2_cache_event_add,\n\t\t.del\t\t= l2_cache_event_del,\n\t\t.start\t\t= l2_cache_event_start,\n\t\t.stop\t\t= l2_cache_event_stop,\n\t\t.read\t\t= l2_cache_event_read,\n\t\t.attr_groups\t= l2_cache_pmu_attr_grps,\n\t\t.capabilities\t= PERF_PMU_CAP_NO_EXCLUDE,\n\t};\n\n\tl2cache_pmu->num_counters = get_num_counters();\n\tl2cache_pmu->pdev = pdev;\n\tl2cache_pmu->pmu_cluster = devm_alloc_percpu(&pdev->dev,\n\t\t\t\t\t\t     struct cluster_pmu *);\n\tif (!l2cache_pmu->pmu_cluster)\n\t\treturn -ENOMEM;\n\n\tl2_cycle_ctr_idx = l2cache_pmu->num_counters - 1;\n\tl2_counter_present_mask = GENMASK(l2cache_pmu->num_counters - 2, 0) |\n\t\tBIT(L2CYCLE_CTR_BIT);\n\n\tcpumask_clear(&l2cache_pmu->cpumask);\n\n\t \n\terr = device_for_each_child(&pdev->dev, l2cache_pmu,\n\t\t\t\t    l2_cache_pmu_probe_cluster);\n\tif (err)\n\t\treturn err;\n\n\tif (l2cache_pmu->num_pmus == 0) {\n\t\tdev_err(&pdev->dev, \"No hardware L2 cache PMUs found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = cpuhp_state_add_instance(CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE,\n\t\t\t\t       &l2cache_pmu->node);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Error %d registering hotplug\", err);\n\t\treturn err;\n\t}\n\n\terr = perf_pmu_register(&l2cache_pmu->pmu, l2cache_pmu->pmu.name, -1);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Error %d registering L2 cache PMU\\n\", err);\n\t\tgoto out_unregister;\n\t}\n\n\tdev_info(&pdev->dev, \"Registered L2 cache PMU using %d HW PMUs\\n\",\n\t\t l2cache_pmu->num_pmus);\n\n\treturn err;\n\nout_unregister:\n\tcpuhp_state_remove_instance(CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE,\n\t\t\t\t    &l2cache_pmu->node);\n\treturn err;\n}\n\nstatic int l2_cache_pmu_remove(struct platform_device *pdev)\n{\n\tstruct l2cache_pmu *l2cache_pmu =\n\t\tto_l2cache_pmu(platform_get_drvdata(pdev));\n\n\tperf_pmu_unregister(&l2cache_pmu->pmu);\n\tcpuhp_state_remove_instance(CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE,\n\t\t\t\t    &l2cache_pmu->node);\n\treturn 0;\n}\n\nstatic struct platform_driver l2_cache_pmu_driver = {\n\t.driver = {\n\t\t.name = \"qcom-l2cache-pmu\",\n\t\t.acpi_match_table = ACPI_PTR(l2_cache_pmu_acpi_match),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = l2_cache_pmu_probe,\n\t.remove = l2_cache_pmu_remove,\n};\n\nstatic int __init register_l2_cache_pmu_driver(void)\n{\n\tint err;\n\n\terr = cpuhp_setup_state_multi(CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE,\n\t\t\t\t      \"AP_PERF_ARM_QCOM_L2_ONLINE\",\n\t\t\t\t      l2cache_pmu_online_cpu,\n\t\t\t\t      l2cache_pmu_offline_cpu);\n\tif (err)\n\t\treturn err;\n\n\treturn platform_driver_register(&l2_cache_pmu_driver);\n}\ndevice_initcall(register_l2_cache_pmu_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}