{
  "module_name": "arm_smmuv3_pmu.c",
  "hash_id": "b34a3ef6436c1983fad418b20008d87c6ab835501212ccd73fcbfa3e768ff6b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/arm_smmuv3_pmu.c",
  "human_readable_source": "\n\n \n\n#include <linux/acpi.h>\n#include <linux/acpi_iort.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/cpuhotplug.h>\n#include <linux/cpumask.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/perf_event.h>\n#include <linux/platform_device.h>\n#include <linux/smp.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n\n#define SMMU_PMCG_EVCNTR0               0x0\n#define SMMU_PMCG_EVCNTR(n, stride)     (SMMU_PMCG_EVCNTR0 + (n) * (stride))\n#define SMMU_PMCG_EVTYPER0              0x400\n#define SMMU_PMCG_EVTYPER(n)            (SMMU_PMCG_EVTYPER0 + (n) * 4)\n#define SMMU_PMCG_SID_SPAN_SHIFT        29\n#define SMMU_PMCG_SMR0                  0xA00\n#define SMMU_PMCG_SMR(n)                (SMMU_PMCG_SMR0 + (n) * 4)\n#define SMMU_PMCG_CNTENSET0             0xC00\n#define SMMU_PMCG_CNTENCLR0             0xC20\n#define SMMU_PMCG_INTENSET0             0xC40\n#define SMMU_PMCG_INTENCLR0             0xC60\n#define SMMU_PMCG_OVSCLR0               0xC80\n#define SMMU_PMCG_OVSSET0               0xCC0\n#define SMMU_PMCG_CFGR                  0xE00\n#define SMMU_PMCG_CFGR_SID_FILTER_TYPE  BIT(23)\n#define SMMU_PMCG_CFGR_MSI              BIT(21)\n#define SMMU_PMCG_CFGR_RELOC_CTRS       BIT(20)\n#define SMMU_PMCG_CFGR_SIZE             GENMASK(13, 8)\n#define SMMU_PMCG_CFGR_NCTR             GENMASK(5, 0)\n#define SMMU_PMCG_CR                    0xE04\n#define SMMU_PMCG_CR_ENABLE             BIT(0)\n#define SMMU_PMCG_IIDR                  0xE08\n#define SMMU_PMCG_IIDR_PRODUCTID        GENMASK(31, 20)\n#define SMMU_PMCG_IIDR_VARIANT          GENMASK(19, 16)\n#define SMMU_PMCG_IIDR_REVISION         GENMASK(15, 12)\n#define SMMU_PMCG_IIDR_IMPLEMENTER      GENMASK(11, 0)\n#define SMMU_PMCG_CEID0                 0xE20\n#define SMMU_PMCG_CEID1                 0xE28\n#define SMMU_PMCG_IRQ_CTRL              0xE50\n#define SMMU_PMCG_IRQ_CTRL_IRQEN        BIT(0)\n#define SMMU_PMCG_IRQ_CFG0              0xE58\n#define SMMU_PMCG_IRQ_CFG1              0xE60\n#define SMMU_PMCG_IRQ_CFG2              0xE64\n\n \n#define SMMU_PMCG_PIDR0                 0xFE0\n#define SMMU_PMCG_PIDR0_PART_0          GENMASK(7, 0)\n#define SMMU_PMCG_PIDR1                 0xFE4\n#define SMMU_PMCG_PIDR1_DES_0           GENMASK(7, 4)\n#define SMMU_PMCG_PIDR1_PART_1          GENMASK(3, 0)\n#define SMMU_PMCG_PIDR2                 0xFE8\n#define SMMU_PMCG_PIDR2_REVISION        GENMASK(7, 4)\n#define SMMU_PMCG_PIDR2_DES_1           GENMASK(2, 0)\n#define SMMU_PMCG_PIDR3                 0xFEC\n#define SMMU_PMCG_PIDR3_REVAND          GENMASK(7, 4)\n#define SMMU_PMCG_PIDR4                 0xFD0\n#define SMMU_PMCG_PIDR4_DES_2           GENMASK(3, 0)\n\n \n#define MSI_CFG0_ADDR_MASK              GENMASK_ULL(51, 2)\n#define MSI_CFG2_MEMATTR_DEVICE_nGnRE   0x1\n\n#define SMMU_PMCG_DEFAULT_FILTER_SPAN   1\n#define SMMU_PMCG_DEFAULT_FILTER_SID    GENMASK(31, 0)\n\n#define SMMU_PMCG_MAX_COUNTERS          64\n#define SMMU_PMCG_ARCH_MAX_EVENTS       128\n\n#define SMMU_PMCG_PA_SHIFT              12\n\n#define SMMU_PMCG_EVCNTR_RDONLY         BIT(0)\n#define SMMU_PMCG_HARDEN_DISABLE        BIT(1)\n\nstatic int cpuhp_state_num;\n\nstruct smmu_pmu {\n\tstruct hlist_node node;\n\tstruct perf_event *events[SMMU_PMCG_MAX_COUNTERS];\n\tDECLARE_BITMAP(used_counters, SMMU_PMCG_MAX_COUNTERS);\n\tDECLARE_BITMAP(supported_events, SMMU_PMCG_ARCH_MAX_EVENTS);\n\tunsigned int irq;\n\tunsigned int on_cpu;\n\tstruct pmu pmu;\n\tunsigned int num_counters;\n\tstruct device *dev;\n\tvoid __iomem *reg_base;\n\tvoid __iomem *reloc_base;\n\tu64 counter_mask;\n\tu32 options;\n\tu32 iidr;\n\tbool global_filter;\n};\n\n#define to_smmu_pmu(p) (container_of(p, struct smmu_pmu, pmu))\n\n#define SMMU_PMU_EVENT_ATTR_EXTRACTOR(_name, _config, _start, _end)        \\\n\tstatic inline u32 get_##_name(struct perf_event *event)            \\\n\t{                                                                  \\\n\t\treturn FIELD_GET(GENMASK_ULL(_end, _start),                \\\n\t\t\t\t event->attr._config);                     \\\n\t}                                                                  \\\n\nSMMU_PMU_EVENT_ATTR_EXTRACTOR(event, config, 0, 15);\nSMMU_PMU_EVENT_ATTR_EXTRACTOR(filter_stream_id, config1, 0, 31);\nSMMU_PMU_EVENT_ATTR_EXTRACTOR(filter_span, config1, 32, 32);\nSMMU_PMU_EVENT_ATTR_EXTRACTOR(filter_enable, config1, 33, 33);\n\nstatic inline void smmu_pmu_enable(struct pmu *pmu)\n{\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(pmu);\n\n\twritel(SMMU_PMCG_IRQ_CTRL_IRQEN,\n\t       smmu_pmu->reg_base + SMMU_PMCG_IRQ_CTRL);\n\twritel(SMMU_PMCG_CR_ENABLE, smmu_pmu->reg_base + SMMU_PMCG_CR);\n}\n\nstatic int smmu_pmu_apply_event_filter(struct smmu_pmu *smmu_pmu,\n\t\t\t\t       struct perf_event *event, int idx);\n\nstatic inline void smmu_pmu_enable_quirk_hip08_09(struct pmu *pmu)\n{\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(pmu);\n\tunsigned int idx;\n\n\tfor_each_set_bit(idx, smmu_pmu->used_counters, smmu_pmu->num_counters)\n\t\tsmmu_pmu_apply_event_filter(smmu_pmu, smmu_pmu->events[idx], idx);\n\n\tsmmu_pmu_enable(pmu);\n}\n\nstatic inline void smmu_pmu_disable(struct pmu *pmu)\n{\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(pmu);\n\n\twritel(0, smmu_pmu->reg_base + SMMU_PMCG_CR);\n\twritel(0, smmu_pmu->reg_base + SMMU_PMCG_IRQ_CTRL);\n}\n\nstatic inline void smmu_pmu_disable_quirk_hip08_09(struct pmu *pmu)\n{\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(pmu);\n\tunsigned int idx;\n\n\t \n\tfor_each_set_bit(idx, smmu_pmu->used_counters, smmu_pmu->num_counters)\n\t\twritel(0xffff, smmu_pmu->reg_base + SMMU_PMCG_EVTYPER(idx));\n\n\tsmmu_pmu_disable(pmu);\n}\n\nstatic inline void smmu_pmu_counter_set_value(struct smmu_pmu *smmu_pmu,\n\t\t\t\t\t      u32 idx, u64 value)\n{\n\tif (smmu_pmu->counter_mask & BIT(32))\n\t\twriteq(value, smmu_pmu->reloc_base + SMMU_PMCG_EVCNTR(idx, 8));\n\telse\n\t\twritel(value, smmu_pmu->reloc_base + SMMU_PMCG_EVCNTR(idx, 4));\n}\n\nstatic inline u64 smmu_pmu_counter_get_value(struct smmu_pmu *smmu_pmu, u32 idx)\n{\n\tu64 value;\n\n\tif (smmu_pmu->counter_mask & BIT(32))\n\t\tvalue = readq(smmu_pmu->reloc_base + SMMU_PMCG_EVCNTR(idx, 8));\n\telse\n\t\tvalue = readl(smmu_pmu->reloc_base + SMMU_PMCG_EVCNTR(idx, 4));\n\n\treturn value;\n}\n\nstatic inline void smmu_pmu_counter_enable(struct smmu_pmu *smmu_pmu, u32 idx)\n{\n\twriteq(BIT(idx), smmu_pmu->reg_base + SMMU_PMCG_CNTENSET0);\n}\n\nstatic inline void smmu_pmu_counter_disable(struct smmu_pmu *smmu_pmu, u32 idx)\n{\n\twriteq(BIT(idx), smmu_pmu->reg_base + SMMU_PMCG_CNTENCLR0);\n}\n\nstatic inline void smmu_pmu_interrupt_enable(struct smmu_pmu *smmu_pmu, u32 idx)\n{\n\twriteq(BIT(idx), smmu_pmu->reg_base + SMMU_PMCG_INTENSET0);\n}\n\nstatic inline void smmu_pmu_interrupt_disable(struct smmu_pmu *smmu_pmu,\n\t\t\t\t\t      u32 idx)\n{\n\twriteq(BIT(idx), smmu_pmu->reg_base + SMMU_PMCG_INTENCLR0);\n}\n\nstatic inline void smmu_pmu_set_evtyper(struct smmu_pmu *smmu_pmu, u32 idx,\n\t\t\t\t\tu32 val)\n{\n\twritel(val, smmu_pmu->reg_base + SMMU_PMCG_EVTYPER(idx));\n}\n\nstatic inline void smmu_pmu_set_smr(struct smmu_pmu *smmu_pmu, u32 idx, u32 val)\n{\n\twritel(val, smmu_pmu->reg_base + SMMU_PMCG_SMR(idx));\n}\n\nstatic void smmu_pmu_event_update(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(event->pmu);\n\tu64 delta, prev, now;\n\tu32 idx = hwc->idx;\n\n\tdo {\n\t\tprev = local64_read(&hwc->prev_count);\n\t\tnow = smmu_pmu_counter_get_value(smmu_pmu, idx);\n\t} while (local64_cmpxchg(&hwc->prev_count, prev, now) != prev);\n\n\t \n\tdelta = now - prev;\n\tdelta &= smmu_pmu->counter_mask;\n\n\tlocal64_add(delta, &event->count);\n}\n\nstatic void smmu_pmu_set_period(struct smmu_pmu *smmu_pmu,\n\t\t\t\tstruct hw_perf_event *hwc)\n{\n\tu32 idx = hwc->idx;\n\tu64 new;\n\n\tif (smmu_pmu->options & SMMU_PMCG_EVCNTR_RDONLY) {\n\t\t \n\t\tnew = smmu_pmu_counter_get_value(smmu_pmu, idx);\n\t} else {\n\t\t \n\t\tnew = smmu_pmu->counter_mask >> 1;\n\t\tsmmu_pmu_counter_set_value(smmu_pmu, idx, new);\n\t}\n\n\tlocal64_set(&hwc->prev_count, new);\n}\n\nstatic void smmu_pmu_set_event_filter(struct perf_event *event,\n\t\t\t\t      int idx, u32 span, u32 sid)\n{\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(event->pmu);\n\tu32 evtyper;\n\n\tevtyper = get_event(event) | span << SMMU_PMCG_SID_SPAN_SHIFT;\n\tsmmu_pmu_set_evtyper(smmu_pmu, idx, evtyper);\n\tsmmu_pmu_set_smr(smmu_pmu, idx, sid);\n}\n\nstatic bool smmu_pmu_check_global_filter(struct perf_event *curr,\n\t\t\t\t\t struct perf_event *new)\n{\n\tif (get_filter_enable(new) != get_filter_enable(curr))\n\t\treturn false;\n\n\tif (!get_filter_enable(new))\n\t\treturn true;\n\n\treturn get_filter_span(new) == get_filter_span(curr) &&\n\t       get_filter_stream_id(new) == get_filter_stream_id(curr);\n}\n\nstatic int smmu_pmu_apply_event_filter(struct smmu_pmu *smmu_pmu,\n\t\t\t\t       struct perf_event *event, int idx)\n{\n\tu32 span, sid;\n\tunsigned int cur_idx, num_ctrs = smmu_pmu->num_counters;\n\tbool filter_en = !!get_filter_enable(event);\n\n\tspan = filter_en ? get_filter_span(event) :\n\t\t\t   SMMU_PMCG_DEFAULT_FILTER_SPAN;\n\tsid = filter_en ? get_filter_stream_id(event) :\n\t\t\t   SMMU_PMCG_DEFAULT_FILTER_SID;\n\n\tcur_idx = find_first_bit(smmu_pmu->used_counters, num_ctrs);\n\t \n\tif (!smmu_pmu->global_filter || cur_idx == num_ctrs) {\n\t\tsmmu_pmu_set_event_filter(event, idx, span, sid);\n\t\treturn 0;\n\t}\n\n\t \n\tif (smmu_pmu_check_global_filter(smmu_pmu->events[cur_idx], event)) {\n\t\tsmmu_pmu_set_evtyper(smmu_pmu, idx, get_event(event));\n\t\treturn 0;\n\t}\n\n\treturn -EAGAIN;\n}\n\nstatic int smmu_pmu_get_event_idx(struct smmu_pmu *smmu_pmu,\n\t\t\t\t  struct perf_event *event)\n{\n\tint idx, err;\n\tunsigned int num_ctrs = smmu_pmu->num_counters;\n\n\tidx = find_first_zero_bit(smmu_pmu->used_counters, num_ctrs);\n\tif (idx == num_ctrs)\n\t\t \n\t\treturn -EAGAIN;\n\n\terr = smmu_pmu_apply_event_filter(smmu_pmu, event, idx);\n\tif (err)\n\t\treturn err;\n\n\tset_bit(idx, smmu_pmu->used_counters);\n\n\treturn idx;\n}\n\nstatic bool smmu_pmu_events_compatible(struct perf_event *curr,\n\t\t\t\t       struct perf_event *new)\n{\n\tif (new->pmu != curr->pmu)\n\t\treturn false;\n\n\tif (to_smmu_pmu(new->pmu)->global_filter &&\n\t    !smmu_pmu_check_global_filter(curr, new))\n\t\treturn false;\n\n\treturn true;\n}\n\n \n\nstatic int smmu_pmu_event_init(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(event->pmu);\n\tstruct device *dev = smmu_pmu->dev;\n\tstruct perf_event *sibling;\n\tint group_num_events = 1;\n\tu16 event_id;\n\n\tif (event->attr.type != event->pmu->type)\n\t\treturn -ENOENT;\n\n\tif (hwc->sample_period) {\n\t\tdev_dbg(dev, \"Sampling not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (event->cpu < 0) {\n\t\tdev_dbg(dev, \"Per-task mode not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tevent_id = get_event(event);\n\tif (event_id < SMMU_PMCG_ARCH_MAX_EVENTS &&\n\t    (!test_bit(event_id, smmu_pmu->supported_events))) {\n\t\tdev_dbg(dev, \"Invalid event %d for this PMU\\n\", event_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!is_software_event(event->group_leader)) {\n\t\tif (!smmu_pmu_events_compatible(event->group_leader, event))\n\t\t\treturn -EINVAL;\n\n\t\tif (++group_num_events > smmu_pmu->num_counters)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor_each_sibling_event(sibling, event->group_leader) {\n\t\tif (is_software_event(sibling))\n\t\t\tcontinue;\n\n\t\tif (!smmu_pmu_events_compatible(sibling, event))\n\t\t\treturn -EINVAL;\n\n\t\tif (++group_num_events > smmu_pmu->num_counters)\n\t\t\treturn -EINVAL;\n\t}\n\n\thwc->idx = -1;\n\n\t \n\tevent->cpu = smmu_pmu->on_cpu;\n\n\treturn 0;\n}\n\nstatic void smmu_pmu_event_start(struct perf_event *event, int flags)\n{\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx = hwc->idx;\n\n\thwc->state = 0;\n\n\tsmmu_pmu_set_period(smmu_pmu, hwc);\n\n\tsmmu_pmu_counter_enable(smmu_pmu, idx);\n}\n\nstatic void smmu_pmu_event_stop(struct perf_event *event, int flags)\n{\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx = hwc->idx;\n\n\tif (hwc->state & PERF_HES_STOPPED)\n\t\treturn;\n\n\tsmmu_pmu_counter_disable(smmu_pmu, idx);\n\t \n\tsmmu_pmu_event_update(event);\n\thwc->state |= PERF_HES_STOPPED | PERF_HES_UPTODATE;\n}\n\nstatic int smmu_pmu_event_add(struct perf_event *event, int flags)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx;\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(event->pmu);\n\n\tidx = smmu_pmu_get_event_idx(smmu_pmu, event);\n\tif (idx < 0)\n\t\treturn idx;\n\n\thwc->idx = idx;\n\thwc->state = PERF_HES_STOPPED | PERF_HES_UPTODATE;\n\tsmmu_pmu->events[idx] = event;\n\tlocal64_set(&hwc->prev_count, 0);\n\n\tsmmu_pmu_interrupt_enable(smmu_pmu, idx);\n\n\tif (flags & PERF_EF_START)\n\t\tsmmu_pmu_event_start(event, flags);\n\n\t \n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void smmu_pmu_event_del(struct perf_event *event, int flags)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(event->pmu);\n\tint idx = hwc->idx;\n\n\tsmmu_pmu_event_stop(event, flags | PERF_EF_UPDATE);\n\tsmmu_pmu_interrupt_disable(smmu_pmu, idx);\n\tsmmu_pmu->events[idx] = NULL;\n\tclear_bit(idx, smmu_pmu->used_counters);\n\n\tperf_event_update_userpage(event);\n}\n\nstatic void smmu_pmu_event_read(struct perf_event *event)\n{\n\tsmmu_pmu_event_update(event);\n}\n\n \n\nstatic ssize_t smmu_pmu_cpumask_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(dev_get_drvdata(dev));\n\n\treturn cpumap_print_to_pagebuf(true, buf, cpumask_of(smmu_pmu->on_cpu));\n}\n\nstatic struct device_attribute smmu_pmu_cpumask_attr =\n\t\t__ATTR(cpumask, 0444, smmu_pmu_cpumask_show, NULL);\n\nstatic struct attribute *smmu_pmu_cpumask_attrs[] = {\n\t&smmu_pmu_cpumask_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group smmu_pmu_cpumask_group = {\n\t.attrs = smmu_pmu_cpumask_attrs,\n};\n\n \n\nstatic ssize_t smmu_pmu_event_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *page)\n{\n\tstruct perf_pmu_events_attr *pmu_attr;\n\n\tpmu_attr = container_of(attr, struct perf_pmu_events_attr, attr);\n\n\treturn sysfs_emit(page, \"event=0x%02llx\\n\", pmu_attr->id);\n}\n\n#define SMMU_EVENT_ATTR(name, config)\t\t\t\\\n\tPMU_EVENT_ATTR_ID(name, smmu_pmu_event_show, config)\n\nstatic struct attribute *smmu_pmu_events[] = {\n\tSMMU_EVENT_ATTR(cycles, 0),\n\tSMMU_EVENT_ATTR(transaction, 1),\n\tSMMU_EVENT_ATTR(tlb_miss, 2),\n\tSMMU_EVENT_ATTR(config_cache_miss, 3),\n\tSMMU_EVENT_ATTR(trans_table_walk_access, 4),\n\tSMMU_EVENT_ATTR(config_struct_access, 5),\n\tSMMU_EVENT_ATTR(pcie_ats_trans_rq, 6),\n\tSMMU_EVENT_ATTR(pcie_ats_trans_passed, 7),\n\tNULL\n};\n\nstatic umode_t smmu_pmu_event_is_visible(struct kobject *kobj,\n\t\t\t\t\t struct attribute *attr, int unused)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(dev_get_drvdata(dev));\n\tstruct perf_pmu_events_attr *pmu_attr;\n\n\tpmu_attr = container_of(attr, struct perf_pmu_events_attr, attr.attr);\n\n\tif (test_bit(pmu_attr->id, smmu_pmu->supported_events))\n\t\treturn attr->mode;\n\n\treturn 0;\n}\n\nstatic const struct attribute_group smmu_pmu_events_group = {\n\t.name = \"events\",\n\t.attrs = smmu_pmu_events,\n\t.is_visible = smmu_pmu_event_is_visible,\n};\n\nstatic ssize_t smmu_pmu_identifier_attr_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *page)\n{\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(dev_get_drvdata(dev));\n\n\treturn sysfs_emit(page, \"0x%08x\\n\", smmu_pmu->iidr);\n}\n\nstatic umode_t smmu_pmu_identifier_attr_visible(struct kobject *kobj,\n\t\t\t\t\t\tstruct attribute *attr,\n\t\t\t\t\t\tint n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct smmu_pmu *smmu_pmu = to_smmu_pmu(dev_get_drvdata(dev));\n\n\tif (!smmu_pmu->iidr)\n\t\treturn 0;\n\treturn attr->mode;\n}\n\nstatic struct device_attribute smmu_pmu_identifier_attr =\n\t__ATTR(identifier, 0444, smmu_pmu_identifier_attr_show, NULL);\n\nstatic struct attribute *smmu_pmu_identifier_attrs[] = {\n\t&smmu_pmu_identifier_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group smmu_pmu_identifier_group = {\n\t.attrs = smmu_pmu_identifier_attrs,\n\t.is_visible = smmu_pmu_identifier_attr_visible,\n};\n\n \nPMU_FORMAT_ATTR(event,\t\t   \"config:0-15\");\nPMU_FORMAT_ATTR(filter_stream_id,  \"config1:0-31\");\nPMU_FORMAT_ATTR(filter_span,\t   \"config1:32\");\nPMU_FORMAT_ATTR(filter_enable,\t   \"config1:33\");\n\nstatic struct attribute *smmu_pmu_formats[] = {\n\t&format_attr_event.attr,\n\t&format_attr_filter_stream_id.attr,\n\t&format_attr_filter_span.attr,\n\t&format_attr_filter_enable.attr,\n\tNULL\n};\n\nstatic const struct attribute_group smmu_pmu_format_group = {\n\t.name = \"format\",\n\t.attrs = smmu_pmu_formats,\n};\n\nstatic const struct attribute_group *smmu_pmu_attr_grps[] = {\n\t&smmu_pmu_cpumask_group,\n\t&smmu_pmu_events_group,\n\t&smmu_pmu_format_group,\n\t&smmu_pmu_identifier_group,\n\tNULL\n};\n\n \n\nstatic int smmu_pmu_offline_cpu(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct smmu_pmu *smmu_pmu;\n\tunsigned int target;\n\n\tsmmu_pmu = hlist_entry_safe(node, struct smmu_pmu, node);\n\tif (cpu != smmu_pmu->on_cpu)\n\t\treturn 0;\n\n\ttarget = cpumask_any_but(cpu_online_mask, cpu);\n\tif (target >= nr_cpu_ids)\n\t\treturn 0;\n\n\tperf_pmu_migrate_context(&smmu_pmu->pmu, cpu, target);\n\tsmmu_pmu->on_cpu = target;\n\tWARN_ON(irq_set_affinity(smmu_pmu->irq, cpumask_of(target)));\n\n\treturn 0;\n}\n\nstatic irqreturn_t smmu_pmu_handle_irq(int irq_num, void *data)\n{\n\tstruct smmu_pmu *smmu_pmu = data;\n\tDECLARE_BITMAP(ovs, BITS_PER_TYPE(u64));\n\tu64 ovsr;\n\tunsigned int idx;\n\n\tovsr = readq(smmu_pmu->reloc_base + SMMU_PMCG_OVSSET0);\n\tif (!ovsr)\n\t\treturn IRQ_NONE;\n\n\twriteq(ovsr, smmu_pmu->reloc_base + SMMU_PMCG_OVSCLR0);\n\n\tbitmap_from_u64(ovs, ovsr);\n\tfor_each_set_bit(idx, ovs, smmu_pmu->num_counters) {\n\t\tstruct perf_event *event = smmu_pmu->events[idx];\n\t\tstruct hw_perf_event *hwc;\n\n\t\tif (WARN_ON_ONCE(!event))\n\t\t\tcontinue;\n\n\t\tsmmu_pmu_event_update(event);\n\t\thwc = &event->hw;\n\n\t\tsmmu_pmu_set_period(smmu_pmu, hwc);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void smmu_pmu_free_msis(void *data)\n{\n\tstruct device *dev = data;\n\n\tplatform_msi_domain_free_irqs(dev);\n}\n\nstatic void smmu_pmu_write_msi_msg(struct msi_desc *desc, struct msi_msg *msg)\n{\n\tphys_addr_t doorbell;\n\tstruct device *dev = msi_desc_to_dev(desc);\n\tstruct smmu_pmu *pmu = dev_get_drvdata(dev);\n\n\tdoorbell = (((u64)msg->address_hi) << 32) | msg->address_lo;\n\tdoorbell &= MSI_CFG0_ADDR_MASK;\n\n\twriteq_relaxed(doorbell, pmu->reg_base + SMMU_PMCG_IRQ_CFG0);\n\twritel_relaxed(msg->data, pmu->reg_base + SMMU_PMCG_IRQ_CFG1);\n\twritel_relaxed(MSI_CFG2_MEMATTR_DEVICE_nGnRE,\n\t\t       pmu->reg_base + SMMU_PMCG_IRQ_CFG2);\n}\n\nstatic void smmu_pmu_setup_msi(struct smmu_pmu *pmu)\n{\n\tstruct device *dev = pmu->dev;\n\tint ret;\n\n\t \n\twriteq_relaxed(0, pmu->reg_base + SMMU_PMCG_IRQ_CFG0);\n\n\t \n\tif (!(readl(pmu->reg_base + SMMU_PMCG_CFGR) & SMMU_PMCG_CFGR_MSI))\n\t\treturn;\n\n\tret = platform_msi_domain_alloc_irqs(dev, 1, smmu_pmu_write_msi_msg);\n\tif (ret) {\n\t\tdev_warn(dev, \"failed to allocate MSIs\\n\");\n\t\treturn;\n\t}\n\n\tpmu->irq = msi_get_virq(dev, 0);\n\n\t \n\tdevm_add_action(dev, smmu_pmu_free_msis, dev);\n}\n\nstatic int smmu_pmu_setup_irq(struct smmu_pmu *pmu)\n{\n\tunsigned long flags = IRQF_NOBALANCING | IRQF_SHARED | IRQF_NO_THREAD;\n\tint irq, ret = -ENXIO;\n\n\tsmmu_pmu_setup_msi(pmu);\n\n\tirq = pmu->irq;\n\tif (irq)\n\t\tret = devm_request_irq(pmu->dev, irq, smmu_pmu_handle_irq,\n\t\t\t\t       flags, \"smmuv3-pmu\", pmu);\n\treturn ret;\n}\n\nstatic void smmu_pmu_reset(struct smmu_pmu *smmu_pmu)\n{\n\tu64 counter_present_mask = GENMASK_ULL(smmu_pmu->num_counters - 1, 0);\n\n\tsmmu_pmu_disable(&smmu_pmu->pmu);\n\n\t \n\twriteq_relaxed(counter_present_mask,\n\t\t       smmu_pmu->reg_base + SMMU_PMCG_CNTENCLR0);\n\twriteq_relaxed(counter_present_mask,\n\t\t       smmu_pmu->reg_base + SMMU_PMCG_INTENCLR0);\n\twriteq_relaxed(counter_present_mask,\n\t\t       smmu_pmu->reloc_base + SMMU_PMCG_OVSCLR0);\n}\n\nstatic void smmu_pmu_get_acpi_options(struct smmu_pmu *smmu_pmu)\n{\n\tu32 model;\n\n\tmodel = *(u32 *)dev_get_platdata(smmu_pmu->dev);\n\n\tswitch (model) {\n\tcase IORT_SMMU_V3_PMCG_HISI_HIP08:\n\t\t \n\t\tsmmu_pmu->options |= SMMU_PMCG_EVCNTR_RDONLY | SMMU_PMCG_HARDEN_DISABLE;\n\t\tbreak;\n\tcase IORT_SMMU_V3_PMCG_HISI_HIP09:\n\t\tsmmu_pmu->options |= SMMU_PMCG_HARDEN_DISABLE;\n\t\tbreak;\n\t}\n\n\tdev_notice(smmu_pmu->dev, \"option mask 0x%x\\n\", smmu_pmu->options);\n}\n\nstatic bool smmu_pmu_coresight_id_regs(struct smmu_pmu *smmu_pmu)\n{\n\treturn of_device_is_compatible(smmu_pmu->dev->of_node,\n\t\t\t\t       \"arm,mmu-600-pmcg\");\n}\n\nstatic void smmu_pmu_get_iidr(struct smmu_pmu *smmu_pmu)\n{\n\tu32 iidr = readl_relaxed(smmu_pmu->reg_base + SMMU_PMCG_IIDR);\n\n\tif (!iidr && smmu_pmu_coresight_id_regs(smmu_pmu)) {\n\t\tu32 pidr0 = readl(smmu_pmu->reg_base + SMMU_PMCG_PIDR0);\n\t\tu32 pidr1 = readl(smmu_pmu->reg_base + SMMU_PMCG_PIDR1);\n\t\tu32 pidr2 = readl(smmu_pmu->reg_base + SMMU_PMCG_PIDR2);\n\t\tu32 pidr3 = readl(smmu_pmu->reg_base + SMMU_PMCG_PIDR3);\n\t\tu32 pidr4 = readl(smmu_pmu->reg_base + SMMU_PMCG_PIDR4);\n\n\t\tu32 productid = FIELD_GET(SMMU_PMCG_PIDR0_PART_0, pidr0) |\n\t\t\t\t(FIELD_GET(SMMU_PMCG_PIDR1_PART_1, pidr1) << 8);\n\t\tu32 variant = FIELD_GET(SMMU_PMCG_PIDR2_REVISION, pidr2);\n\t\tu32 revision = FIELD_GET(SMMU_PMCG_PIDR3_REVAND, pidr3);\n\t\tu32 implementer =\n\t\t\tFIELD_GET(SMMU_PMCG_PIDR1_DES_0, pidr1) |\n\t\t\t(FIELD_GET(SMMU_PMCG_PIDR2_DES_1, pidr2) << 4) |\n\t\t\t(FIELD_GET(SMMU_PMCG_PIDR4_DES_2, pidr4) << 8);\n\n\t\tiidr = FIELD_PREP(SMMU_PMCG_IIDR_PRODUCTID, productid) |\n\t\t       FIELD_PREP(SMMU_PMCG_IIDR_VARIANT, variant) |\n\t\t       FIELD_PREP(SMMU_PMCG_IIDR_REVISION, revision) |\n\t\t       FIELD_PREP(SMMU_PMCG_IIDR_IMPLEMENTER, implementer);\n\t}\n\n\tsmmu_pmu->iidr = iidr;\n}\n\nstatic int smmu_pmu_probe(struct platform_device *pdev)\n{\n\tstruct smmu_pmu *smmu_pmu;\n\tstruct resource *res_0;\n\tu32 cfgr, reg_size;\n\tu64 ceid_64[2];\n\tint irq, err;\n\tchar *name;\n\tstruct device *dev = &pdev->dev;\n\n\tsmmu_pmu = devm_kzalloc(dev, sizeof(*smmu_pmu), GFP_KERNEL);\n\tif (!smmu_pmu)\n\t\treturn -ENOMEM;\n\n\tsmmu_pmu->dev = dev;\n\tplatform_set_drvdata(pdev, smmu_pmu);\n\n\tsmmu_pmu->pmu = (struct pmu) {\n\t\t.module\t\t= THIS_MODULE,\n\t\t.task_ctx_nr    = perf_invalid_context,\n\t\t.pmu_enable\t= smmu_pmu_enable,\n\t\t.pmu_disable\t= smmu_pmu_disable,\n\t\t.event_init\t= smmu_pmu_event_init,\n\t\t.add\t\t= smmu_pmu_event_add,\n\t\t.del\t\t= smmu_pmu_event_del,\n\t\t.start\t\t= smmu_pmu_event_start,\n\t\t.stop\t\t= smmu_pmu_event_stop,\n\t\t.read\t\t= smmu_pmu_event_read,\n\t\t.attr_groups\t= smmu_pmu_attr_grps,\n\t\t.capabilities\t= PERF_PMU_CAP_NO_EXCLUDE,\n\t};\n\n\tsmmu_pmu->reg_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res_0);\n\tif (IS_ERR(smmu_pmu->reg_base))\n\t\treturn PTR_ERR(smmu_pmu->reg_base);\n\n\tcfgr = readl_relaxed(smmu_pmu->reg_base + SMMU_PMCG_CFGR);\n\n\t \n\tif (cfgr & SMMU_PMCG_CFGR_RELOC_CTRS) {\n\t\tsmmu_pmu->reloc_base = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(smmu_pmu->reloc_base))\n\t\t\treturn PTR_ERR(smmu_pmu->reloc_base);\n\t} else {\n\t\tsmmu_pmu->reloc_base = smmu_pmu->reg_base;\n\t}\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq > 0)\n\t\tsmmu_pmu->irq = irq;\n\n\tceid_64[0] = readq_relaxed(smmu_pmu->reg_base + SMMU_PMCG_CEID0);\n\tceid_64[1] = readq_relaxed(smmu_pmu->reg_base + SMMU_PMCG_CEID1);\n\tbitmap_from_arr32(smmu_pmu->supported_events, (u32 *)ceid_64,\n\t\t\t  SMMU_PMCG_ARCH_MAX_EVENTS);\n\n\tsmmu_pmu->num_counters = FIELD_GET(SMMU_PMCG_CFGR_NCTR, cfgr) + 1;\n\n\tsmmu_pmu->global_filter = !!(cfgr & SMMU_PMCG_CFGR_SID_FILTER_TYPE);\n\n\treg_size = FIELD_GET(SMMU_PMCG_CFGR_SIZE, cfgr);\n\tsmmu_pmu->counter_mask = GENMASK_ULL(reg_size, 0);\n\n\tsmmu_pmu_reset(smmu_pmu);\n\n\terr = smmu_pmu_setup_irq(smmu_pmu);\n\tif (err) {\n\t\tdev_err(dev, \"Setup irq failed, PMU @%pa\\n\", &res_0->start);\n\t\treturn err;\n\t}\n\n\tsmmu_pmu_get_iidr(smmu_pmu);\n\n\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"smmuv3_pmcg_%llx\",\n\t\t\t      (res_0->start) >> SMMU_PMCG_PA_SHIFT);\n\tif (!name) {\n\t\tdev_err(dev, \"Create name failed, PMU @%pa\\n\", &res_0->start);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!dev->of_node)\n\t\tsmmu_pmu_get_acpi_options(smmu_pmu);\n\n\t \n\tif (smmu_pmu->options & SMMU_PMCG_HARDEN_DISABLE) {\n\t\tsmmu_pmu->pmu.pmu_enable = smmu_pmu_enable_quirk_hip08_09;\n\t\tsmmu_pmu->pmu.pmu_disable = smmu_pmu_disable_quirk_hip08_09;\n\t}\n\n\t \n\tsmmu_pmu->on_cpu = raw_smp_processor_id();\n\tWARN_ON(irq_set_affinity(smmu_pmu->irq, cpumask_of(smmu_pmu->on_cpu)));\n\n\terr = cpuhp_state_add_instance_nocalls(cpuhp_state_num,\n\t\t\t\t\t       &smmu_pmu->node);\n\tif (err) {\n\t\tdev_err(dev, \"Error %d registering hotplug, PMU @%pa\\n\",\n\t\t\terr, &res_0->start);\n\t\treturn err;\n\t}\n\n\terr = perf_pmu_register(&smmu_pmu->pmu, name, -1);\n\tif (err) {\n\t\tdev_err(dev, \"Error %d registering PMU @%pa\\n\",\n\t\t\terr, &res_0->start);\n\t\tgoto out_unregister;\n\t}\n\n\tdev_info(dev, \"Registered PMU @ %pa using %d counters with %s filter settings\\n\",\n\t\t &res_0->start, smmu_pmu->num_counters,\n\t\t smmu_pmu->global_filter ? \"Global(Counter0)\" :\n\t\t \"Individual\");\n\n\treturn 0;\n\nout_unregister:\n\tcpuhp_state_remove_instance_nocalls(cpuhp_state_num, &smmu_pmu->node);\n\treturn err;\n}\n\nstatic int smmu_pmu_remove(struct platform_device *pdev)\n{\n\tstruct smmu_pmu *smmu_pmu = platform_get_drvdata(pdev);\n\n\tperf_pmu_unregister(&smmu_pmu->pmu);\n\tcpuhp_state_remove_instance_nocalls(cpuhp_state_num, &smmu_pmu->node);\n\n\treturn 0;\n}\n\nstatic void smmu_pmu_shutdown(struct platform_device *pdev)\n{\n\tstruct smmu_pmu *smmu_pmu = platform_get_drvdata(pdev);\n\n\tsmmu_pmu_disable(&smmu_pmu->pmu);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id smmu_pmu_of_match[] = {\n\t{ .compatible = \"arm,smmu-v3-pmcg\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, smmu_pmu_of_match);\n#endif\n\nstatic struct platform_driver smmu_pmu_driver = {\n\t.driver = {\n\t\t.name = \"arm-smmu-v3-pmcg\",\n\t\t.of_match_table = of_match_ptr(smmu_pmu_of_match),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = smmu_pmu_probe,\n\t.remove = smmu_pmu_remove,\n\t.shutdown = smmu_pmu_shutdown,\n};\n\nstatic int __init arm_smmu_pmu_init(void)\n{\n\tint ret;\n\n\tcpuhp_state_num = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\t  \"perf/arm/pmcg:online\",\n\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t  smmu_pmu_offline_cpu);\n\tif (cpuhp_state_num < 0)\n\t\treturn cpuhp_state_num;\n\n\tret = platform_driver_register(&smmu_pmu_driver);\n\tif (ret)\n\t\tcpuhp_remove_multi_state(cpuhp_state_num);\n\n\treturn ret;\n}\nmodule_init(arm_smmu_pmu_init);\n\nstatic void __exit arm_smmu_pmu_exit(void)\n{\n\tplatform_driver_unregister(&smmu_pmu_driver);\n\tcpuhp_remove_multi_state(cpuhp_state_num);\n}\n\nmodule_exit(arm_smmu_pmu_exit);\n\nMODULE_ALIAS(\"platform:arm-smmu-v3-pmcg\");\nMODULE_DESCRIPTION(\"PMU driver for ARM SMMUv3 Performance Monitors Extension\");\nMODULE_AUTHOR(\"Neil Leeder <nleeder@codeaurora.org>\");\nMODULE_AUTHOR(\"Shameer Kolothum <shameerali.kolothum.thodi@huawei.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}