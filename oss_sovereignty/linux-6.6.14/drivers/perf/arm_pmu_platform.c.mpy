{
  "module_name": "arm_pmu_platform.c",
  "hash_id": "c37d471cc81b1a96662cd7f3081d4d9c0fd720ce7df544be505cc4ad0cac3e1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/arm_pmu_platform.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"hw perfevents: \" fmt\n#define dev_fmt pr_fmt\n\n#include <linux/bug.h>\n#include <linux/cpumask.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/irq.h>\n#include <linux/irqdesc.h>\n#include <linux/kconfig.h>\n#include <linux/of.h>\n#include <linux/percpu.h>\n#include <linux/perf/arm_pmu.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/smp.h>\n\nstatic int probe_current_pmu(struct arm_pmu *pmu,\n\t\t\t     const struct pmu_probe_info *info)\n{\n\tint cpu = get_cpu();\n\tunsigned int cpuid = read_cpuid_id();\n\tint ret = -ENODEV;\n\n\tpr_info(\"probing PMU on CPU %d\\n\", cpu);\n\n\tfor (; info->init != NULL; info++) {\n\t\tif ((cpuid & info->mask) != info->cpuid)\n\t\t\tcontinue;\n\t\tret = info->init(pmu);\n\t\tbreak;\n\t}\n\n\tput_cpu();\n\treturn ret;\n}\n\nstatic int pmu_parse_percpu_irq(struct arm_pmu *pmu, int irq)\n{\n\tint cpu, ret;\n\tstruct pmu_hw_events __percpu *hw_events = pmu->hw_events;\n\n\tret = irq_get_percpu_devid_partition(irq, &pmu->supported_cpus);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_cpu(cpu, &pmu->supported_cpus)\n\t\tper_cpu(hw_events->irq, cpu) = irq;\n\n\treturn 0;\n}\n\nstatic bool pmu_has_irq_affinity(struct device_node *node)\n{\n\treturn !!of_find_property(node, \"interrupt-affinity\", NULL);\n}\n\nstatic int pmu_parse_irq_affinity(struct device *dev, int i)\n{\n\tstruct device_node *dn;\n\tint cpu;\n\n\t \n\tif (!pmu_has_irq_affinity(dev->of_node))\n\t\treturn i;\n\n\tdn = of_parse_phandle(dev->of_node, \"interrupt-affinity\", i);\n\tif (!dn) {\n\t\tdev_warn(dev, \"failed to parse interrupt-affinity[%d]\\n\", i);\n\t\treturn -EINVAL;\n\t}\n\n\tcpu = of_cpu_node_to_id(dn);\n\tif (cpu < 0) {\n\t\tdev_warn(dev, \"failed to find logical CPU for %pOFn\\n\", dn);\n\t\tcpu = nr_cpu_ids;\n\t}\n\n\tof_node_put(dn);\n\n\treturn cpu;\n}\n\nstatic int pmu_parse_irqs(struct arm_pmu *pmu)\n{\n\tint i = 0, num_irqs;\n\tstruct platform_device *pdev = pmu->plat_device;\n\tstruct pmu_hw_events __percpu *hw_events = pmu->hw_events;\n\tstruct device *dev = &pdev->dev;\n\n\tnum_irqs = platform_irq_count(pdev);\n\tif (num_irqs < 0)\n\t\treturn dev_err_probe(dev, num_irqs, \"unable to count PMU IRQs\\n\");\n\n\t \n\tif (num_irqs == 0) {\n\t\tdev_warn(dev, \"no irqs for PMU, sampling events not supported\\n\");\n\t\tpmu->pmu.capabilities |= PERF_PMU_CAP_NO_INTERRUPT;\n\t\tcpumask_setall(&pmu->supported_cpus);\n\t\treturn 0;\n\t}\n\n\tif (num_irqs == 1) {\n\t\tint irq = platform_get_irq(pdev, 0);\n\t\tif ((irq > 0) && irq_is_percpu_devid(irq))\n\t\t\treturn pmu_parse_percpu_irq(pmu, irq);\n\t}\n\n\tif (nr_cpu_ids != 1 && !pmu_has_irq_affinity(dev->of_node))\n\t\tdev_warn(dev, \"no interrupt-affinity property, guessing.\\n\");\n\n\tfor (i = 0; i < num_irqs; i++) {\n\t\tint cpu, irq;\n\n\t\tirq = platform_get_irq(pdev, i);\n\t\tif (WARN_ON(irq <= 0))\n\t\t\tcontinue;\n\n\t\tif (irq_is_percpu_devid(irq)) {\n\t\t\tdev_warn(dev, \"multiple PPIs or mismatched SPI/PPI detected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcpu = pmu_parse_irq_affinity(dev, i);\n\t\tif (cpu < 0)\n\t\t\treturn cpu;\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcontinue;\n\n\t\tif (per_cpu(hw_events->irq, cpu)) {\n\t\t\tdev_warn(dev, \"multiple PMU IRQs for the same CPU detected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tper_cpu(hw_events->irq, cpu) = irq;\n\t\tcpumask_set_cpu(cpu, &pmu->supported_cpus);\n\t}\n\n\treturn 0;\n}\n\nstatic int armpmu_request_irqs(struct arm_pmu *armpmu)\n{\n\tstruct pmu_hw_events __percpu *hw_events = armpmu->hw_events;\n\tint cpu, err = 0;\n\n\tfor_each_cpu(cpu, &armpmu->supported_cpus) {\n\t\tint irq = per_cpu(hw_events->irq, cpu);\n\t\tif (!irq)\n\t\t\tcontinue;\n\n\t\terr = armpmu_request_irq(irq, cpu);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void armpmu_free_irqs(struct arm_pmu *armpmu)\n{\n\tint cpu;\n\tstruct pmu_hw_events __percpu *hw_events = armpmu->hw_events;\n\n\tfor_each_cpu(cpu, &armpmu->supported_cpus) {\n\t\tint irq = per_cpu(hw_events->irq, cpu);\n\n\t\tarmpmu_free_irq(irq, cpu);\n\t}\n}\n\nint arm_pmu_device_probe(struct platform_device *pdev,\n\t\t\t const struct of_device_id *of_table,\n\t\t\t const struct pmu_probe_info *probe_table)\n{\n\tarmpmu_init_fn init_fn;\n\tstruct device *dev = &pdev->dev;\n\tstruct arm_pmu *pmu;\n\tint ret = -ENODEV;\n\n\tpmu = armpmu_alloc();\n\tif (!pmu)\n\t\treturn -ENOMEM;\n\n\tpmu->plat_device = pdev;\n\n\tret = pmu_parse_irqs(pmu);\n\tif (ret)\n\t\tgoto out_free;\n\n\tinit_fn = of_device_get_match_data(dev);\n\tif (init_fn) {\n\t\tpmu->secure_access = of_property_read_bool(dev->of_node,\n\t\t\t\t\t\t\t   \"secure-reg-access\");\n\n\t\t \n\t\tif (IS_ENABLED(CONFIG_ARM64) && pmu->secure_access) {\n\t\t\tdev_warn(dev, \"ignoring \\\"secure-reg-access\\\" property for arm64\\n\");\n\t\t\tpmu->secure_access = false;\n\t\t}\n\n\t\tret = init_fn(pmu);\n\t} else if (probe_table) {\n\t\tcpumask_setall(&pmu->supported_cpus);\n\t\tret = probe_current_pmu(pmu, probe_table);\n\t}\n\n\tif (ret) {\n\t\tdev_err(dev, \"failed to probe PMU!\\n\");\n\t\tgoto out_free;\n\t}\n\n\tret = armpmu_request_irqs(pmu);\n\tif (ret)\n\t\tgoto out_free_irqs;\n\n\tret = armpmu_register(pmu);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register PMU devices!\\n\");\n\t\tgoto out_free_irqs;\n\t}\n\n\treturn 0;\n\nout_free_irqs:\n\tarmpmu_free_irqs(pmu);\nout_free:\n\tarmpmu_free(pmu);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}