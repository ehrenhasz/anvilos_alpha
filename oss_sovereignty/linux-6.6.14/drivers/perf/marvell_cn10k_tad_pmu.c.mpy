{
  "module_name": "marvell_cn10k_tad_pmu.c",
  "hash_id": "f42d1d897d3fc04a2f0d604c75c5e8a9c984a58b3a0375c515f9d5f30ccaebe6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/marvell_cn10k_tad_pmu.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"tad_pmu: \" fmt\n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/cpuhotplug.h>\n#include <linux/perf_event.h>\n#include <linux/platform_device.h>\n#include <linux/acpi.h>\n\n#define TAD_PFC_OFFSET\t\t0x800\n#define TAD_PFC(counter)\t(TAD_PFC_OFFSET | (counter << 3))\n#define TAD_PRF_OFFSET\t\t0x900\n#define TAD_PRF(counter)\t(TAD_PRF_OFFSET | (counter << 3))\n#define TAD_PRF_CNTSEL_MASK\t0xFF\n#define TAD_MAX_COUNTERS\t8\n\n#define to_tad_pmu(p) (container_of(p, struct tad_pmu, pmu))\n\nstruct tad_region {\n\tvoid __iomem\t*base;\n};\n\nstruct tad_pmu {\n\tstruct pmu pmu;\n\tstruct tad_region *regions;\n\tu32 region_cnt;\n\tunsigned int cpu;\n\tstruct hlist_node node;\n\tstruct perf_event *events[TAD_MAX_COUNTERS];\n\tDECLARE_BITMAP(counters_map, TAD_MAX_COUNTERS);\n};\n\nstatic int tad_pmu_cpuhp_state;\n\nstatic void tad_pmu_event_counter_read(struct perf_event *event)\n{\n\tstruct tad_pmu *tad_pmu = to_tad_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu32 counter_idx = hwc->idx;\n\tu64 prev, new;\n\tint i;\n\n\tdo {\n\t\tprev = local64_read(&hwc->prev_count);\n\t\tfor (i = 0, new = 0; i < tad_pmu->region_cnt; i++)\n\t\t\tnew += readq(tad_pmu->regions[i].base +\n\t\t\t\t     TAD_PFC(counter_idx));\n\t} while (local64_cmpxchg(&hwc->prev_count, prev, new) != prev);\n\n\tlocal64_add(new - prev, &event->count);\n}\n\nstatic void tad_pmu_event_counter_stop(struct perf_event *event, int flags)\n{\n\tstruct tad_pmu *tad_pmu = to_tad_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu32 counter_idx = hwc->idx;\n\tint i;\n\n\t \n\tfor (i = 0; i < tad_pmu->region_cnt; i++) {\n\t\twriteq_relaxed(0, tad_pmu->regions[i].base +\n\t\t\t       TAD_PRF(counter_idx));\n\t}\n\n\ttad_pmu_event_counter_read(event);\n\thwc->state |= PERF_HES_STOPPED | PERF_HES_UPTODATE;\n}\n\nstatic void tad_pmu_event_counter_start(struct perf_event *event, int flags)\n{\n\tstruct tad_pmu *tad_pmu = to_tad_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu32 event_idx = event->attr.config;\n\tu32 counter_idx = hwc->idx;\n\tu64 reg_val;\n\tint i;\n\n\thwc->state = 0;\n\n\t \n\tfor (i = 0; i < tad_pmu->region_cnt; i++)\n\t\twriteq_relaxed(0, tad_pmu->regions[i].base +\n\t\t\t       TAD_PFC(counter_idx));\n\n\t \n\tfor (i = 0; i < tad_pmu->region_cnt; i++) {\n\t\treg_val = event_idx & 0xFF;\n\t\twriteq_relaxed(reg_val,\ttad_pmu->regions[i].base +\n\t\t\t       TAD_PRF(counter_idx));\n\t}\n}\n\nstatic void tad_pmu_event_counter_del(struct perf_event *event, int flags)\n{\n\tstruct tad_pmu *tad_pmu = to_tad_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx = hwc->idx;\n\n\ttad_pmu_event_counter_stop(event, flags | PERF_EF_UPDATE);\n\ttad_pmu->events[idx] = NULL;\n\tclear_bit(idx, tad_pmu->counters_map);\n}\n\nstatic int tad_pmu_event_counter_add(struct perf_event *event, int flags)\n{\n\tstruct tad_pmu *tad_pmu = to_tad_pmu(event->pmu);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx;\n\n\t \n\tidx = find_first_zero_bit(tad_pmu->counters_map, TAD_MAX_COUNTERS);\n\tif (idx == TAD_MAX_COUNTERS)\n\t\treturn -EAGAIN;\n\n\tset_bit(idx, tad_pmu->counters_map);\n\n\thwc->idx = idx;\n\thwc->state = PERF_HES_STOPPED;\n\ttad_pmu->events[idx] = event;\n\n\tif (flags & PERF_EF_START)\n\t\ttad_pmu_event_counter_start(event, flags);\n\n\treturn 0;\n}\n\nstatic int tad_pmu_event_init(struct perf_event *event)\n{\n\tstruct tad_pmu *tad_pmu = to_tad_pmu(event->pmu);\n\n\tif (event->attr.type != event->pmu->type)\n\t\treturn -ENOENT;\n\n\tif (!event->attr.disabled)\n\t\treturn -EINVAL;\n\n\tif (event->state != PERF_EVENT_STATE_OFF)\n\t\treturn -EINVAL;\n\n\tevent->cpu = tad_pmu->cpu;\n\tevent->hw.idx = -1;\n\tevent->hw.config_base = event->attr.config;\n\n\treturn 0;\n}\n\nstatic ssize_t tad_pmu_event_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *page)\n{\n\tstruct perf_pmu_events_attr *pmu_attr;\n\n\tpmu_attr = container_of(attr, struct perf_pmu_events_attr, attr);\n\treturn sysfs_emit(page, \"event=0x%02llx\\n\", pmu_attr->id);\n}\n\n#define TAD_PMU_EVENT_ATTR(name, config)\t\t\t\\\n\tPMU_EVENT_ATTR_ID(name, tad_pmu_event_show, config)\n\nstatic struct attribute *tad_pmu_event_attrs[] = {\n\tTAD_PMU_EVENT_ATTR(tad_none, 0x0),\n\tTAD_PMU_EVENT_ATTR(tad_req_msh_in_any, 0x1),\n\tTAD_PMU_EVENT_ATTR(tad_req_msh_in_mn, 0x2),\n\tTAD_PMU_EVENT_ATTR(tad_req_msh_in_exlmn, 0x3),\n\tTAD_PMU_EVENT_ATTR(tad_rsp_msh_in_any, 0x4),\n\tTAD_PMU_EVENT_ATTR(tad_rsp_msh_in_mn, 0x5),\n\tTAD_PMU_EVENT_ATTR(tad_rsp_msh_in_exlmn, 0x6),\n\tTAD_PMU_EVENT_ATTR(tad_rsp_msh_in_dss, 0x7),\n\tTAD_PMU_EVENT_ATTR(tad_rsp_msh_in_retry_dss, 0x8),\n\tTAD_PMU_EVENT_ATTR(tad_dat_msh_in_any, 0x9),\n\tTAD_PMU_EVENT_ATTR(tad_dat_msh_in_dss, 0xa),\n\tTAD_PMU_EVENT_ATTR(tad_req_msh_out_any, 0xb),\n\tTAD_PMU_EVENT_ATTR(tad_req_msh_out_dss_rd, 0xc),\n\tTAD_PMU_EVENT_ATTR(tad_req_msh_out_dss_wr, 0xd),\n\tTAD_PMU_EVENT_ATTR(tad_req_msh_out_evict, 0xe),\n\tTAD_PMU_EVENT_ATTR(tad_rsp_msh_out_any, 0xf),\n\tTAD_PMU_EVENT_ATTR(tad_rsp_msh_out_retry_exlmn, 0x10),\n\tTAD_PMU_EVENT_ATTR(tad_rsp_msh_out_retry_mn, 0x11),\n\tTAD_PMU_EVENT_ATTR(tad_rsp_msh_out_exlmn, 0x12),\n\tTAD_PMU_EVENT_ATTR(tad_rsp_msh_out_mn, 0x13),\n\tTAD_PMU_EVENT_ATTR(tad_snp_msh_out_any, 0x14),\n\tTAD_PMU_EVENT_ATTR(tad_snp_msh_out_mn, 0x15),\n\tTAD_PMU_EVENT_ATTR(tad_snp_msh_out_exlmn, 0x16),\n\tTAD_PMU_EVENT_ATTR(tad_dat_msh_out_any, 0x17),\n\tTAD_PMU_EVENT_ATTR(tad_dat_msh_out_fill, 0x18),\n\tTAD_PMU_EVENT_ATTR(tad_dat_msh_out_dss, 0x19),\n\tTAD_PMU_EVENT_ATTR(tad_alloc_dtg, 0x1a),\n\tTAD_PMU_EVENT_ATTR(tad_alloc_ltg, 0x1b),\n\tTAD_PMU_EVENT_ATTR(tad_alloc_any, 0x1c),\n\tTAD_PMU_EVENT_ATTR(tad_hit_dtg, 0x1d),\n\tTAD_PMU_EVENT_ATTR(tad_hit_ltg, 0x1e),\n\tTAD_PMU_EVENT_ATTR(tad_hit_any, 0x1f),\n\tTAD_PMU_EVENT_ATTR(tad_tag_rd, 0x20),\n\tTAD_PMU_EVENT_ATTR(tad_dat_rd, 0x21),\n\tTAD_PMU_EVENT_ATTR(tad_dat_rd_byp, 0x22),\n\tTAD_PMU_EVENT_ATTR(tad_ifb_occ, 0x23),\n\tTAD_PMU_EVENT_ATTR(tad_req_occ, 0x24),\n\tNULL\n};\n\nstatic const struct attribute_group tad_pmu_events_attr_group = {\n\t.name = \"events\",\n\t.attrs = tad_pmu_event_attrs,\n};\n\nPMU_FORMAT_ATTR(event, \"config:0-7\");\n\nstatic struct attribute *tad_pmu_format_attrs[] = {\n\t&format_attr_event.attr,\n\tNULL\n};\n\nstatic struct attribute_group tad_pmu_format_attr_group = {\n\t.name = \"format\",\n\t.attrs = tad_pmu_format_attrs,\n};\n\nstatic ssize_t tad_pmu_cpumask_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct tad_pmu *tad_pmu = to_tad_pmu(dev_get_drvdata(dev));\n\n\treturn cpumap_print_to_pagebuf(true, buf, cpumask_of(tad_pmu->cpu));\n}\n\nstatic DEVICE_ATTR(cpumask, 0444, tad_pmu_cpumask_show, NULL);\n\nstatic struct attribute *tad_pmu_cpumask_attrs[] = {\n\t&dev_attr_cpumask.attr,\n\tNULL\n};\n\nstatic struct attribute_group tad_pmu_cpumask_attr_group = {\n\t.attrs = tad_pmu_cpumask_attrs,\n};\n\nstatic const struct attribute_group *tad_pmu_attr_groups[] = {\n\t&tad_pmu_events_attr_group,\n\t&tad_pmu_format_attr_group,\n\t&tad_pmu_cpumask_attr_group,\n\tNULL\n};\n\nstatic int tad_pmu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tad_region *regions;\n\tstruct tad_pmu *tad_pmu;\n\tstruct resource *res;\n\tu32 tad_pmu_page_size;\n\tu32 tad_page_size;\n\tu32 tad_cnt;\n\tint i, ret;\n\tchar *name;\n\n\ttad_pmu = devm_kzalloc(&pdev->dev, sizeof(*tad_pmu), GFP_KERNEL);\n\tif (!tad_pmu)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, tad_pmu);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Mem resource not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = device_property_read_u32(dev, \"marvell,tad-page-size\",\n\t\t\t\t       &tad_page_size);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't find tad-page-size property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(dev, \"marvell,tad-pmu-page-size\",\n\t\t\t\t       &tad_pmu_page_size);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't find tad-pmu-page-size property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(dev, \"marvell,tad-cnt\", &tad_cnt);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't find tad-cnt property\\n\");\n\t\treturn ret;\n\t}\n\n\tregions = devm_kcalloc(&pdev->dev, tad_cnt,\n\t\t\t       sizeof(*regions), GFP_KERNEL);\n\tif (!regions)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < tad_cnt && res->start < res->end; i++) {\n\t\tregions[i].base = devm_ioremap(&pdev->dev,\n\t\t\t\t\t       res->start,\n\t\t\t\t\t       tad_pmu_page_size);\n\t\tif (!regions[i].base) {\n\t\t\tdev_err(&pdev->dev, \"TAD%d ioremap fail\\n\", i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tres->start += tad_page_size;\n\t}\n\n\ttad_pmu->regions = regions;\n\ttad_pmu->region_cnt = tad_cnt;\n\n\ttad_pmu->pmu = (struct pmu) {\n\n\t\t.module\t\t= THIS_MODULE,\n\t\t.attr_groups\t= tad_pmu_attr_groups,\n\t\t.capabilities\t= PERF_PMU_CAP_NO_EXCLUDE |\n\t\t\t\t  PERF_PMU_CAP_NO_INTERRUPT,\n\t\t.task_ctx_nr\t= perf_invalid_context,\n\n\t\t.event_init\t= tad_pmu_event_init,\n\t\t.add\t\t= tad_pmu_event_counter_add,\n\t\t.del\t\t= tad_pmu_event_counter_del,\n\t\t.start\t\t= tad_pmu_event_counter_start,\n\t\t.stop\t\t= tad_pmu_event_counter_stop,\n\t\t.read\t\t= tad_pmu_event_counter_read,\n\t};\n\n\ttad_pmu->cpu = raw_smp_processor_id();\n\n\t \n\tret = cpuhp_state_add_instance_nocalls(tad_pmu_cpuhp_state,\n\t\t\t\t\t       &tad_pmu->node);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error %d registering hotplug\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tname = \"tad\";\n\tret = perf_pmu_register(&tad_pmu->pmu, name, -1);\n\tif (ret)\n\t\tcpuhp_state_remove_instance_nocalls(tad_pmu_cpuhp_state,\n\t\t\t\t\t\t    &tad_pmu->node);\n\n\treturn ret;\n}\n\nstatic int tad_pmu_remove(struct platform_device *pdev)\n{\n\tstruct tad_pmu *pmu = platform_get_drvdata(pdev);\n\n\tcpuhp_state_remove_instance_nocalls(tad_pmu_cpuhp_state,\n\t\t\t\t\t\t&pmu->node);\n\tperf_pmu_unregister(&pmu->pmu);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tad_pmu_of_match[] = {\n\t{ .compatible = \"marvell,cn10k-tad-pmu\", },\n\t{},\n};\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id tad_pmu_acpi_match[] = {\n\t{\"MRVL000B\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, tad_pmu_acpi_match);\n#endif\n\nstatic struct platform_driver tad_pmu_driver = {\n\t.driver         = {\n\t\t.name   = \"cn10k_tad_pmu\",\n\t\t.of_match_table = of_match_ptr(tad_pmu_of_match),\n\t\t.acpi_match_table = ACPI_PTR(tad_pmu_acpi_match),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe          = tad_pmu_probe,\n\t.remove         = tad_pmu_remove,\n};\n\nstatic int tad_pmu_offline_cpu(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct tad_pmu *pmu = hlist_entry_safe(node, struct tad_pmu, node);\n\tunsigned int target;\n\n\tif (cpu != pmu->cpu)\n\t\treturn 0;\n\n\ttarget = cpumask_any_but(cpu_online_mask, cpu);\n\tif (target >= nr_cpu_ids)\n\t\treturn 0;\n\n\tperf_pmu_migrate_context(&pmu->pmu, cpu, target);\n\tpmu->cpu = target;\n\n\treturn 0;\n}\n\nstatic int __init tad_pmu_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t      \"perf/cn10k/tadpmu:online\",\n\t\t\t\t      NULL,\n\t\t\t\t      tad_pmu_offline_cpu);\n\tif (ret < 0)\n\t\treturn ret;\n\ttad_pmu_cpuhp_state = ret;\n\tret = platform_driver_register(&tad_pmu_driver);\n\tif (ret)\n\t\tcpuhp_remove_multi_state(tad_pmu_cpuhp_state);\n\n\treturn ret;\n}\n\nstatic void __exit tad_pmu_exit(void)\n{\n\tplatform_driver_unregister(&tad_pmu_driver);\n\tcpuhp_remove_multi_state(tad_pmu_cpuhp_state);\n}\n\nmodule_init(tad_pmu_init);\nmodule_exit(tad_pmu_exit);\n\nMODULE_DESCRIPTION(\"Marvell CN10K LLC-TAD Perf driver\");\nMODULE_AUTHOR(\"Bhaskara Budiredla <bbudiredla@marvell.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}