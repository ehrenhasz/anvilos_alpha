{
  "module_name": "arm_pmu_acpi.c",
  "hash_id": "6e299d71848fc6e7b1f20e39cbad2da40f4e357b868ec86d52a8c6328bb8779a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/arm_pmu_acpi.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/cpumask.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/irqdesc.h>\n#include <linux/percpu.h>\n#include <linux/perf/arm_pmu.h>\n\n#include <asm/cpu.h>\n#include <asm/cputype.h>\n\nstatic DEFINE_PER_CPU(struct arm_pmu *, probed_pmus);\nstatic DEFINE_PER_CPU(int, pmu_irqs);\n\nstatic int arm_pmu_acpi_register_irq(int cpu)\n{\n\tstruct acpi_madt_generic_interrupt *gicc;\n\tint gsi, trigger;\n\n\tgicc = acpi_cpu_get_madt_gicc(cpu);\n\n\tgsi = gicc->performance_interrupt;\n\n\t \n\tif (!gsi)\n\t\treturn 0;\n\n\tif (gicc->flags & ACPI_MADT_PERFORMANCE_IRQ_MODE)\n\t\ttrigger = ACPI_EDGE_SENSITIVE;\n\telse\n\t\ttrigger = ACPI_LEVEL_SENSITIVE;\n\n\t \n\treturn acpi_register_gsi(NULL, gsi, trigger, ACPI_ACTIVE_HIGH);\n}\n\nstatic void arm_pmu_acpi_unregister_irq(int cpu)\n{\n\tstruct acpi_madt_generic_interrupt *gicc;\n\tint gsi;\n\n\tgicc = acpi_cpu_get_madt_gicc(cpu);\n\n\tgsi = gicc->performance_interrupt;\n\tif (gsi)\n\t\tacpi_unregister_gsi(gsi);\n}\n\nstatic int __maybe_unused\narm_acpi_register_pmu_device(struct platform_device *pdev, u8 len,\n\t\t\t     u16 (*parse_gsi)(struct acpi_madt_generic_interrupt *))\n{\n\tint cpu, this_hetid, hetid, irq, ret;\n\tu16 this_gsi = 0, gsi = 0;\n\n\t \n\tif (pdev->num_resources != 1)\n\t\treturn -ENXIO;\n\n\tif (pdev->resource[0].flags != IORESOURCE_IRQ)\n\t\treturn -ENXIO;\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tstruct acpi_madt_generic_interrupt *gicc;\n\n\t\tgicc = acpi_cpu_get_madt_gicc(cpu);\n\t\tif (gicc->header.length < len)\n\t\t\treturn gsi ? -ENXIO : 0;\n\n\t\tthis_gsi = parse_gsi(gicc);\n\t\tthis_hetid = find_acpi_cpu_topology_hetero_id(cpu);\n\t\tif (!gsi) {\n\t\t\thetid = this_hetid;\n\t\t\tgsi = this_gsi;\n\t\t} else if (hetid != this_hetid || gsi != this_gsi) {\n\t\t\tpr_warn(\"ACPI: %s: must be homogeneous\\n\", pdev->name);\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tif (!this_gsi)\n\t\treturn 0;\n\n\tirq = acpi_register_gsi(NULL, gsi, ACPI_LEVEL_SENSITIVE, ACPI_ACTIVE_HIGH);\n\tif (irq < 0) {\n\t\tpr_warn(\"ACPI: %s Unable to register interrupt: %d\\n\", pdev->name, gsi);\n\t\treturn -ENXIO;\n\t}\n\n\tpdev->resource[0].start = irq;\n\tret = platform_device_register(pdev);\n\tif (ret)\n\t\tacpi_unregister_gsi(gsi);\n\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_ARM_SPE_PMU)\nstatic struct resource spe_resources[] = {\n\t{\n\t\t \n\t\t.flags          = IORESOURCE_IRQ,\n\t}\n};\n\nstatic struct platform_device spe_dev = {\n\t.name = ARMV8_SPE_PDEV_NAME,\n\t.id = -1,\n\t.resource = spe_resources,\n\t.num_resources = ARRAY_SIZE(spe_resources)\n};\n\nstatic u16 arm_spe_parse_gsi(struct acpi_madt_generic_interrupt *gicc)\n{\n\treturn gicc->spe_interrupt;\n}\n\n \nstatic void arm_spe_acpi_register_device(void)\n{\n\tint ret = arm_acpi_register_pmu_device(&spe_dev, ACPI_MADT_GICC_SPE,\n\t\t\t\t\t       arm_spe_parse_gsi);\n\tif (ret)\n\t\tpr_warn(\"ACPI: SPE: Unable to register device\\n\");\n}\n#else\nstatic inline void arm_spe_acpi_register_device(void)\n{\n}\n#endif  \n\n#if IS_ENABLED(CONFIG_CORESIGHT_TRBE)\nstatic struct resource trbe_resources[] = {\n\t{\n\t\t \n\t\t.flags          = IORESOURCE_IRQ,\n\t}\n};\n\nstatic struct platform_device trbe_dev = {\n\t.name = ARMV8_TRBE_PDEV_NAME,\n\t.id = -1,\n\t.resource = trbe_resources,\n\t.num_resources = ARRAY_SIZE(trbe_resources)\n};\n\nstatic u16 arm_trbe_parse_gsi(struct acpi_madt_generic_interrupt *gicc)\n{\n\treturn gicc->trbe_interrupt;\n}\n\nstatic void arm_trbe_acpi_register_device(void)\n{\n\tint ret = arm_acpi_register_pmu_device(&trbe_dev, ACPI_MADT_GICC_TRBE,\n\t\t\t\t\t       arm_trbe_parse_gsi);\n\tif (ret)\n\t\tpr_warn(\"ACPI: TRBE: Unable to register device\\n\");\n}\n#else\nstatic inline void arm_trbe_acpi_register_device(void)\n{\n\n}\n#endif  \n\nstatic int arm_pmu_acpi_parse_irqs(void)\n{\n\tint irq, cpu, irq_cpu, err;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tirq = arm_pmu_acpi_register_irq(cpu);\n\t\tif (irq < 0) {\n\t\t\terr = irq;\n\t\t\tpr_warn(\"Unable to parse ACPI PMU IRQ for CPU%d: %d\\n\",\n\t\t\t\tcpu, err);\n\t\t\tgoto out_err;\n\t\t} else if (irq == 0) {\n\t\t\tpr_warn(\"No ACPI PMU IRQ for CPU%d\\n\", cpu);\n\t\t}\n\n\t\t \n\t\tper_cpu(pmu_irqs, cpu) = irq;\n\t\terr = armpmu_request_irq(irq, cpu);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\tfor_each_possible_cpu(cpu) {\n\t\tirq = per_cpu(pmu_irqs, cpu);\n\t\tif (!irq)\n\t\t\tcontinue;\n\n\t\tarm_pmu_acpi_unregister_irq(cpu);\n\n\t\t \n\t\tfor_each_possible_cpu(irq_cpu) {\n\t\t\tif (per_cpu(pmu_irqs, irq_cpu) == irq)\n\t\t\t\tper_cpu(pmu_irqs, irq_cpu) = 0;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic struct arm_pmu *arm_pmu_acpi_find_pmu(void)\n{\n\tunsigned long cpuid = read_cpuid_id();\n\tstruct arm_pmu *pmu;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpmu = per_cpu(probed_pmus, cpu);\n\t\tif (!pmu || pmu->acpi_cpuid != cpuid)\n\t\t\tcontinue;\n\n\t\treturn pmu;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic bool pmu_irq_matches(struct arm_pmu *pmu, int irq)\n{\n\tstruct pmu_hw_events __percpu *hw_events = pmu->hw_events;\n\tint cpu;\n\n\tif (!irq)\n\t\treturn true;\n\n\tfor_each_cpu(cpu, &pmu->supported_cpus) {\n\t\tint other_irq = per_cpu(hw_events->irq, cpu);\n\t\tif (!other_irq)\n\t\t\tcontinue;\n\n\t\tif (irq == other_irq)\n\t\t\tcontinue;\n\t\tif (!irq_is_percpu_devid(irq) && !irq_is_percpu_devid(other_irq))\n\t\t\tcontinue;\n\n\t\tpr_warn(\"mismatched PPIs detected\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void arm_pmu_acpi_associate_pmu_cpu(struct arm_pmu *pmu,\n\t\t\t\t\t   unsigned int cpu)\n{\n\tint irq = per_cpu(pmu_irqs, cpu);\n\n\tper_cpu(probed_pmus, cpu) = pmu;\n\n\tif (pmu_irq_matches(pmu, irq)) {\n\t\tstruct pmu_hw_events __percpu *hw_events;\n\t\thw_events = pmu->hw_events;\n\t\tper_cpu(hw_events->irq, cpu) = irq;\n\t}\n\n\tcpumask_set_cpu(cpu, &pmu->supported_cpus);\n}\n\n \nstatic int arm_pmu_acpi_cpu_starting(unsigned int cpu)\n{\n\tstruct arm_pmu *pmu;\n\n\t \n\tif (per_cpu(probed_pmus, cpu))\n\t\treturn 0;\n\n\tpmu = arm_pmu_acpi_find_pmu();\n\tif (!pmu) {\n\t\tpr_warn_ratelimited(\"Unable to associate CPU%d with a PMU\\n\",\n\t\t\t\t    cpu);\n\t\treturn 0;\n\t}\n\n\tarm_pmu_acpi_associate_pmu_cpu(pmu, cpu);\n\treturn 0;\n}\n\nstatic void arm_pmu_acpi_probe_matching_cpus(struct arm_pmu *pmu,\n\t\t\t\t\t     unsigned long cpuid)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\tunsigned long cpu_cpuid = per_cpu(cpu_data, cpu).reg_midr;\n\n\t\tif (cpu_cpuid == cpuid)\n\t\t\tarm_pmu_acpi_associate_pmu_cpu(pmu, cpu);\n\t}\n}\n\nint arm_pmu_acpi_probe(armpmu_init_fn init_fn)\n{\n\tint pmu_idx = 0;\n\tunsigned int cpu;\n\tint ret;\n\n\tret = arm_pmu_acpi_parse_irqs();\n\tif (ret)\n\t\treturn ret;\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_PERF_ARM_ACPI_STARTING,\n\t\t\t\t\t\"perf/arm/pmu_acpi:starting\",\n\t\t\t\t\tarm_pmu_acpi_cpu_starting, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor_each_online_cpu(cpu) {\n\t\tstruct arm_pmu *pmu = per_cpu(probed_pmus, cpu);\n\t\tunsigned long cpuid;\n\t\tchar *base_name;\n\n\t\t \n\t\tif (pmu)\n\t\t\tcontinue;\n\n\t\tpmu = armpmu_alloc();\n\t\tif (!pmu) {\n\t\t\tpr_warn(\"Unable to allocate PMU for CPU%d\\n\",\n\t\t\t\tcpu);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcpuid = per_cpu(cpu_data, cpu).reg_midr;\n\t\tpmu->acpi_cpuid = cpuid;\n\n\t\tarm_pmu_acpi_probe_matching_cpus(pmu, cpuid);\n\n\t\tret = init_fn(pmu);\n\t\tif (ret == -ENODEV) {\n\t\t\t \n\t\t\tcontinue;\n\t\t} else if (ret) {\n\t\t\tpr_warn(\"Unable to initialise PMU for CPU%d\\n\", cpu);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbase_name = pmu->name;\n\t\tpmu->name = kasprintf(GFP_KERNEL, \"%s_%d\", base_name, pmu_idx++);\n\t\tif (!pmu->name) {\n\t\t\tpr_warn(\"Unable to allocate PMU name for CPU%d\\n\", cpu);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tret = armpmu_register(pmu);\n\t\tif (ret) {\n\t\t\tpr_warn(\"Failed to register PMU for CPU%d\\n\", cpu);\n\t\t\tkfree(pmu->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int arm_pmu_acpi_init(void)\n{\n\tif (acpi_disabled)\n\t\treturn 0;\n\n\tarm_spe_acpi_register_device();\n\tarm_trbe_acpi_register_device();\n\n\treturn 0;\n}\nsubsys_initcall(arm_pmu_acpi_init)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}