{
  "module_name": "riscv_pmu_legacy.c",
  "hash_id": "e9483f13c2be4a495b99df91001d735cd7eadb4e3037d86d64610abb0a6a51dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/perf/riscv_pmu_legacy.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/perf/riscv_pmu.h>\n#include <linux/platform_device.h>\n\n#define RISCV_PMU_LEGACY_CYCLE\t\t0\n#define RISCV_PMU_LEGACY_INSTRET\t2\n\nstatic bool pmu_init_done;\n\nstatic int pmu_legacy_ctr_get_idx(struct perf_event *event)\n{\n\tstruct perf_event_attr *attr = &event->attr;\n\n\tif (event->attr.type != PERF_TYPE_HARDWARE)\n\t\treturn -EOPNOTSUPP;\n\tif (attr->config == PERF_COUNT_HW_CPU_CYCLES)\n\t\treturn RISCV_PMU_LEGACY_CYCLE;\n\telse if (attr->config == PERF_COUNT_HW_INSTRUCTIONS)\n\t\treturn RISCV_PMU_LEGACY_INSTRET;\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\n \nstatic int pmu_legacy_event_map(struct perf_event *event, u64 *config)\n{\n\treturn pmu_legacy_ctr_get_idx(event);\n}\n\nstatic u64 pmu_legacy_read_ctr(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint idx = hwc->idx;\n\tu64 val;\n\n\tif (idx == RISCV_PMU_LEGACY_CYCLE) {\n\t\tval = riscv_pmu_ctr_read_csr(CSR_CYCLE);\n\t\tif (IS_ENABLED(CONFIG_32BIT))\n\t\t\tval = (u64)riscv_pmu_ctr_read_csr(CSR_CYCLEH) << 32 | val;\n\t} else if (idx == RISCV_PMU_LEGACY_INSTRET) {\n\t\tval = riscv_pmu_ctr_read_csr(CSR_INSTRET);\n\t\tif (IS_ENABLED(CONFIG_32BIT))\n\t\t\tval = ((u64)riscv_pmu_ctr_read_csr(CSR_INSTRETH)) << 32 | val;\n\t} else\n\t\treturn 0;\n\n\treturn val;\n}\n\nstatic void pmu_legacy_ctr_start(struct perf_event *event, u64 ival)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 initial_val = pmu_legacy_read_ctr(event);\n\n\t \n\tlocal64_set(&hwc->prev_count, initial_val);\n}\n\nstatic uint8_t pmu_legacy_csr_index(struct perf_event *event)\n{\n\treturn event->hw.idx;\n}\n\nstatic void pmu_legacy_event_mapped(struct perf_event *event, struct mm_struct *mm)\n{\n\tif (event->attr.config != PERF_COUNT_HW_CPU_CYCLES &&\n\t    event->attr.config != PERF_COUNT_HW_INSTRUCTIONS)\n\t\treturn;\n\n\tevent->hw.flags |= PERF_EVENT_FLAG_USER_READ_CNT;\n}\n\nstatic void pmu_legacy_event_unmapped(struct perf_event *event, struct mm_struct *mm)\n{\n\tif (event->attr.config != PERF_COUNT_HW_CPU_CYCLES &&\n\t    event->attr.config != PERF_COUNT_HW_INSTRUCTIONS)\n\t\treturn;\n\n\tevent->hw.flags &= ~PERF_EVENT_FLAG_USER_READ_CNT;\n}\n\n \nstatic void pmu_legacy_init(struct riscv_pmu *pmu)\n{\n\tpr_info(\"Legacy PMU implementation is available\\n\");\n\n\tpmu->cmask = BIT(RISCV_PMU_LEGACY_CYCLE) |\n\t\tBIT(RISCV_PMU_LEGACY_INSTRET);\n\tpmu->ctr_start = pmu_legacy_ctr_start;\n\tpmu->ctr_stop = NULL;\n\tpmu->event_map = pmu_legacy_event_map;\n\tpmu->ctr_get_idx = pmu_legacy_ctr_get_idx;\n\tpmu->ctr_get_width = NULL;\n\tpmu->ctr_clear_idx = NULL;\n\tpmu->ctr_read = pmu_legacy_read_ctr;\n\tpmu->event_mapped = pmu_legacy_event_mapped;\n\tpmu->event_unmapped = pmu_legacy_event_unmapped;\n\tpmu->csr_index = pmu_legacy_csr_index;\n\n\tperf_pmu_register(&pmu->pmu, \"cpu\", PERF_TYPE_RAW);\n}\n\nstatic int pmu_legacy_device_probe(struct platform_device *pdev)\n{\n\tstruct riscv_pmu *pmu = NULL;\n\n\tpmu = riscv_pmu_alloc();\n\tif (!pmu)\n\t\treturn -ENOMEM;\n\tpmu_legacy_init(pmu);\n\n\treturn 0;\n}\n\nstatic struct platform_driver pmu_legacy_driver = {\n\t.probe\t\t= pmu_legacy_device_probe,\n\t.driver\t\t= {\n\t\t.name\t= RISCV_PMU_LEGACY_PDEV_NAME,\n\t},\n};\n\nstatic int __init riscv_pmu_legacy_devinit(void)\n{\n\tint ret;\n\tstruct platform_device *pdev;\n\n\tif (likely(pmu_init_done))\n\t\treturn 0;\n\n\tret = platform_driver_register(&pmu_legacy_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tpdev = platform_device_register_simple(RISCV_PMU_LEGACY_PDEV_NAME, -1, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\tplatform_driver_unregister(&pmu_legacy_driver);\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\treturn ret;\n}\nlate_initcall(riscv_pmu_legacy_devinit);\n\nvoid riscv_pmu_legacy_skip_init(void)\n{\n\tpmu_init_done = true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}