{
  "module_name": "kc.c",
  "hash_id": "a0c2540d2a8a3de4dc0c315091a2b5ee3b8db9608d3523d693cc986e3beb09c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pps/kc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/pps_kernel.h>\n\n#include \"kc.h\"\n\n \n\n \nstatic DEFINE_SPINLOCK(pps_kc_hardpps_lock);\n \nstatic struct pps_device *pps_kc_hardpps_dev;\t \nstatic int pps_kc_hardpps_mode;\t\t \n\n \nint pps_kc_bind(struct pps_device *pps, struct pps_bind_args *bind_args)\n{\n\t \n\tspin_lock_irq(&pps_kc_hardpps_lock);\n\n\tif (bind_args->edge == 0)\n\t\tif (pps_kc_hardpps_dev == pps) {\n\t\t\tpps_kc_hardpps_mode = 0;\n\t\t\tpps_kc_hardpps_dev = NULL;\n\t\t\tspin_unlock_irq(&pps_kc_hardpps_lock);\n\t\t\tdev_info(pps->dev, \"unbound kernel\"\n\t\t\t\t\t\" consumer\\n\");\n\t\t} else {\n\t\t\tspin_unlock_irq(&pps_kc_hardpps_lock);\n\t\t\tdev_err(pps->dev, \"selected kernel consumer\"\n\t\t\t\t\t\" is not bound\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\telse\n\t\tif (pps_kc_hardpps_dev == NULL ||\n\t\t\t\tpps_kc_hardpps_dev == pps) {\n\t\t\tpps_kc_hardpps_mode = bind_args->edge;\n\t\t\tpps_kc_hardpps_dev = pps;\n\t\t\tspin_unlock_irq(&pps_kc_hardpps_lock);\n\t\t\tdev_info(pps->dev, \"bound kernel consumer: \"\n\t\t\t\t\"edge=0x%x\\n\", bind_args->edge);\n\t\t} else {\n\t\t\tspin_unlock_irq(&pps_kc_hardpps_lock);\n\t\t\tdev_err(pps->dev, \"another kernel consumer\"\n\t\t\t\t\t\" is already bound\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\treturn 0;\n}\n\n \nvoid pps_kc_remove(struct pps_device *pps)\n{\n\tspin_lock_irq(&pps_kc_hardpps_lock);\n\tif (pps == pps_kc_hardpps_dev) {\n\t\tpps_kc_hardpps_mode = 0;\n\t\tpps_kc_hardpps_dev = NULL;\n\t\tspin_unlock_irq(&pps_kc_hardpps_lock);\n\t\tdev_info(pps->dev, \"unbound kernel consumer\"\n\t\t\t\t\" on device removal\\n\");\n\t} else\n\t\tspin_unlock_irq(&pps_kc_hardpps_lock);\n}\n\n \nvoid pps_kc_event(struct pps_device *pps, struct pps_event_time *ts,\n\t\tint event)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&pps_kc_hardpps_lock, flags);\n\tif (pps == pps_kc_hardpps_dev && event & pps_kc_hardpps_mode)\n\t\thardpps(&ts->ts_real, &ts->ts_raw);\n\tspin_unlock_irqrestore(&pps_kc_hardpps_lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}