{
  "module_name": "pps.c",
  "hash_id": "bd6e4971e71769fcc25149ae83d5def3795604961b28bc9a7415b88f74aed555",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pps/pps.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/poll.h>\n#include <linux/pps_kernel.h>\n#include <linux/slab.h>\n\n#include \"kc.h\"\n\n \n\nstatic dev_t pps_devt;\nstatic struct class *pps_class;\n\nstatic DEFINE_MUTEX(pps_idr_lock);\nstatic DEFINE_IDR(pps_idr);\n\n \n\nstatic __poll_t pps_cdev_poll(struct file *file, poll_table *wait)\n{\n\tstruct pps_device *pps = file->private_data;\n\n\tpoll_wait(file, &pps->queue, wait);\n\n\treturn EPOLLIN | EPOLLRDNORM;\n}\n\nstatic int pps_cdev_fasync(int fd, struct file *file, int on)\n{\n\tstruct pps_device *pps = file->private_data;\n\treturn fasync_helper(fd, file, on, &pps->async_queue);\n}\n\nstatic int pps_cdev_pps_fetch(struct pps_device *pps, struct pps_fdata *fdata)\n{\n\tunsigned int ev = pps->last_ev;\n\tint err = 0;\n\n\t \n\tif (fdata->timeout.flags & PPS_TIME_INVALID)\n\t\terr = wait_event_interruptible(pps->queue,\n\t\t\t\tev != pps->last_ev);\n\telse {\n\t\tunsigned long ticks;\n\n\t\tdev_dbg(pps->dev, \"timeout %lld.%09d\\n\",\n\t\t\t\t(long long) fdata->timeout.sec,\n\t\t\t\tfdata->timeout.nsec);\n\t\tticks = fdata->timeout.sec * HZ;\n\t\tticks += fdata->timeout.nsec / (NSEC_PER_SEC / HZ);\n\n\t\tif (ticks != 0) {\n\t\t\terr = wait_event_interruptible_timeout(\n\t\t\t\t\tpps->queue,\n\t\t\t\t\tev != pps->last_ev,\n\t\t\t\t\tticks);\n\t\t\tif (err == 0)\n\t\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\t \n\tif (err == -ERESTARTSYS) {\n\t\tdev_dbg(pps->dev, \"pending signal caught\\n\");\n\t\treturn -EINTR;\n\t}\n\n\treturn 0;\n}\n\nstatic long pps_cdev_ioctl(struct file *file,\n\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct pps_device *pps = file->private_data;\n\tstruct pps_kparams params;\n\tvoid __user *uarg = (void __user *) arg;\n\tint __user *iuarg = (int __user *) arg;\n\tint err;\n\n\tswitch (cmd) {\n\tcase PPS_GETPARAMS:\n\t\tdev_dbg(pps->dev, \"PPS_GETPARAMS\\n\");\n\n\t\tspin_lock_irq(&pps->lock);\n\n\t\t \n\t\tparams = pps->params;\n\n\t\tspin_unlock_irq(&pps->lock);\n\n\t\terr = copy_to_user(uarg, &params, sizeof(struct pps_kparams));\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\tcase PPS_SETPARAMS:\n\t\tdev_dbg(pps->dev, \"PPS_SETPARAMS\\n\");\n\n\t\t \n\t\tif (!capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\n\t\terr = copy_from_user(&params, uarg, sizeof(struct pps_kparams));\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t\tif (!(params.mode & (PPS_CAPTUREASSERT | PPS_CAPTURECLEAR))) {\n\t\t\tdev_dbg(pps->dev, \"capture mode unspecified (%x)\\n\",\n\t\t\t\t\t\t\t\tparams.mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif ((params.mode & ~pps->info.mode) != 0) {\n\t\t\tdev_dbg(pps->dev, \"unsupported capabilities (%x)\\n\",\n\t\t\t\t\t\t\t\tparams.mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tspin_lock_irq(&pps->lock);\n\n\t\t \n\t\tpps->params = params;\n\n\t\t \n\t\tif ((params.mode & (PPS_TSFMT_TSPEC | PPS_TSFMT_NTPFP)) == 0) {\n\t\t\t \n\t\t\tdev_dbg(pps->dev, \"time format unspecified (%x)\\n\",\n\t\t\t\t\t\t\t\tparams.mode);\n\t\t\tpps->params.mode |= PPS_TSFMT_TSPEC;\n\t\t}\n\t\tif (pps->info.mode & PPS_CANWAIT)\n\t\t\tpps->params.mode |= PPS_CANWAIT;\n\t\tpps->params.api_version = PPS_API_VERS;\n\n\t\t \n\t\tpps->params.assert_off_tu.flags = 0;\n\t\tpps->params.clear_off_tu.flags = 0;\n\n\t\tspin_unlock_irq(&pps->lock);\n\n\t\tbreak;\n\n\tcase PPS_GETCAP:\n\t\tdev_dbg(pps->dev, \"PPS_GETCAP\\n\");\n\n\t\terr = put_user(pps->info.mode, iuarg);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\tcase PPS_FETCH: {\n\t\tstruct pps_fdata fdata;\n\n\t\tdev_dbg(pps->dev, \"PPS_FETCH\\n\");\n\n\t\terr = copy_from_user(&fdata, uarg, sizeof(struct pps_fdata));\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\n\t\terr = pps_cdev_pps_fetch(pps, &fdata);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tspin_lock_irq(&pps->lock);\n\n\t\tfdata.info.assert_sequence = pps->assert_sequence;\n\t\tfdata.info.clear_sequence = pps->clear_sequence;\n\t\tfdata.info.assert_tu = pps->assert_tu;\n\t\tfdata.info.clear_tu = pps->clear_tu;\n\t\tfdata.info.current_mode = pps->current_mode;\n\n\t\tspin_unlock_irq(&pps->lock);\n\n\t\terr = copy_to_user(uarg, &fdata, sizeof(struct pps_fdata));\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\tcase PPS_KC_BIND: {\n\t\tstruct pps_bind_args bind_args;\n\n\t\tdev_dbg(pps->dev, \"PPS_KC_BIND\\n\");\n\n\t\t \n\t\tif (!capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&bind_args, uarg,\n\t\t\t\t\tsizeof(struct pps_bind_args)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif ((bind_args.edge & ~pps->info.mode) != 0) {\n\t\t\tdev_err(pps->dev, \"unsupported capabilities (%x)\\n\",\n\t\t\t\t\tbind_args.edge);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (bind_args.tsformat != PPS_TSFMT_TSPEC ||\n\t\t\t\t(bind_args.edge & ~PPS_CAPTUREBOTH) != 0 ||\n\t\t\t\tbind_args.consumer != PPS_KC_HARDPPS) {\n\t\t\tdev_err(pps->dev, \"invalid kernel consumer bind\"\n\t\t\t\t\t\" parameters (%x)\\n\", bind_args.edge);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = pps_kc_bind(pps, &bind_args);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long pps_cdev_compat_ioctl(struct file *file,\n\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct pps_device *pps = file->private_data;\n\tvoid __user *uarg = (void __user *) arg;\n\n\tcmd = _IOC(_IOC_DIR(cmd), _IOC_TYPE(cmd), _IOC_NR(cmd), sizeof(void *));\n\n\tif (cmd == PPS_FETCH) {\n\t\tstruct pps_fdata_compat compat;\n\t\tstruct pps_fdata fdata;\n\t\tint err;\n\n\t\tdev_dbg(pps->dev, \"PPS_FETCH\\n\");\n\n\t\terr = copy_from_user(&compat, uarg, sizeof(struct pps_fdata_compat));\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\n\t\tmemcpy(&fdata.timeout, &compat.timeout,\n\t\t\t\t\tsizeof(struct pps_ktime_compat));\n\n\t\terr = pps_cdev_pps_fetch(pps, &fdata);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tspin_lock_irq(&pps->lock);\n\n\t\tcompat.info.assert_sequence = pps->assert_sequence;\n\t\tcompat.info.clear_sequence = pps->clear_sequence;\n\t\tcompat.info.current_mode = pps->current_mode;\n\n\t\tmemcpy(&compat.info.assert_tu, &pps->assert_tu,\n\t\t\t\tsizeof(struct pps_ktime_compat));\n\t\tmemcpy(&compat.info.clear_tu, &pps->clear_tu,\n\t\t\t\tsizeof(struct pps_ktime_compat));\n\n\t\tspin_unlock_irq(&pps->lock);\n\n\t\treturn copy_to_user(uarg, &compat,\n\t\t\t\tsizeof(struct pps_fdata_compat)) ? -EFAULT : 0;\n\t}\n\n\treturn pps_cdev_ioctl(file, cmd, arg);\n}\n#else\n#define pps_cdev_compat_ioctl\tNULL\n#endif\n\nstatic int pps_cdev_open(struct inode *inode, struct file *file)\n{\n\tstruct pps_device *pps = container_of(inode->i_cdev,\n\t\t\t\t\t\tstruct pps_device, cdev);\n\tfile->private_data = pps;\n\tkobject_get(&pps->dev->kobj);\n\treturn 0;\n}\n\nstatic int pps_cdev_release(struct inode *inode, struct file *file)\n{\n\tstruct pps_device *pps = container_of(inode->i_cdev,\n\t\t\t\t\t\tstruct pps_device, cdev);\n\tkobject_put(&pps->dev->kobj);\n\treturn 0;\n}\n\n \n\nstatic const struct file_operations pps_cdev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.poll\t\t= pps_cdev_poll,\n\t.fasync\t\t= pps_cdev_fasync,\n\t.compat_ioctl\t= pps_cdev_compat_ioctl,\n\t.unlocked_ioctl\t= pps_cdev_ioctl,\n\t.open\t\t= pps_cdev_open,\n\t.release\t= pps_cdev_release,\n};\n\nstatic void pps_device_destruct(struct device *dev)\n{\n\tstruct pps_device *pps = dev_get_drvdata(dev);\n\n\tcdev_del(&pps->cdev);\n\n\t \n\tpr_debug(\"deallocating pps%d\\n\", pps->id);\n\tmutex_lock(&pps_idr_lock);\n\tidr_remove(&pps_idr, pps->id);\n\tmutex_unlock(&pps_idr_lock);\n\n\tkfree(dev);\n\tkfree(pps);\n}\n\nint pps_register_cdev(struct pps_device *pps)\n{\n\tint err;\n\tdev_t devt;\n\n\tmutex_lock(&pps_idr_lock);\n\t \n\terr = idr_alloc(&pps_idr, pps, 0, PPS_MAX_SOURCES, GFP_KERNEL);\n\tif (err < 0) {\n\t\tif (err == -ENOSPC) {\n\t\t\tpr_err(\"%s: too many PPS sources in the system\\n\",\n\t\t\t       pps->info.name);\n\t\t\terr = -EBUSY;\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\tpps->id = err;\n\tmutex_unlock(&pps_idr_lock);\n\n\tdevt = MKDEV(MAJOR(pps_devt), pps->id);\n\n\tcdev_init(&pps->cdev, &pps_cdev_fops);\n\tpps->cdev.owner = pps->info.owner;\n\n\terr = cdev_add(&pps->cdev, devt, 1);\n\tif (err) {\n\t\tpr_err(\"%s: failed to add char device %d:%d\\n\",\n\t\t\t\tpps->info.name, MAJOR(pps_devt), pps->id);\n\t\tgoto free_idr;\n\t}\n\tpps->dev = device_create(pps_class, pps->info.dev, devt, pps,\n\t\t\t\t\t\t\t\"pps%d\", pps->id);\n\tif (IS_ERR(pps->dev)) {\n\t\terr = PTR_ERR(pps->dev);\n\t\tgoto del_cdev;\n\t}\n\n\t \n\tpps->dev->release = pps_device_destruct;\n\n\tpr_debug(\"source %s got cdev (%d:%d)\\n\", pps->info.name,\n\t\t\tMAJOR(pps_devt), pps->id);\n\n\treturn 0;\n\ndel_cdev:\n\tcdev_del(&pps->cdev);\n\nfree_idr:\n\tmutex_lock(&pps_idr_lock);\n\tidr_remove(&pps_idr, pps->id);\nout_unlock:\n\tmutex_unlock(&pps_idr_lock);\n\treturn err;\n}\n\nvoid pps_unregister_cdev(struct pps_device *pps)\n{\n\tpr_debug(\"unregistering pps%d\\n\", pps->id);\n\tpps->lookup_cookie = NULL;\n\tdevice_destroy(pps_class, pps->dev->devt);\n}\n\n \nstruct pps_device *pps_lookup_dev(void const *cookie)\n{\n\tstruct pps_device *pps;\n\tunsigned id;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&pps_idr, pps, id)\n\t\tif (cookie == pps->lookup_cookie)\n\t\t\tbreak;\n\trcu_read_unlock();\n\treturn pps;\n}\nEXPORT_SYMBOL(pps_lookup_dev);\n\n \n\nstatic void __exit pps_exit(void)\n{\n\tclass_destroy(pps_class);\n\tunregister_chrdev_region(pps_devt, PPS_MAX_SOURCES);\n}\n\nstatic int __init pps_init(void)\n{\n\tint err;\n\n\tpps_class = class_create(\"pps\");\n\tif (IS_ERR(pps_class)) {\n\t\tpr_err(\"failed to allocate class\\n\");\n\t\treturn PTR_ERR(pps_class);\n\t}\n\tpps_class->dev_groups = pps_groups;\n\n\terr = alloc_chrdev_region(&pps_devt, 0, PPS_MAX_SOURCES, \"pps\");\n\tif (err < 0) {\n\t\tpr_err(\"failed to allocate char device region\\n\");\n\t\tgoto remove_class;\n\t}\n\n\tpr_info(\"LinuxPPS API ver. %d registered\\n\", PPS_API_VERS);\n\tpr_info(\"Software ver. %s - Copyright 2005-2007 Rodolfo Giometti \"\n\t\t\"<giometti@linux.it>\\n\", PPS_VERSION);\n\n\treturn 0;\n\nremove_class:\n\tclass_destroy(pps_class);\n\n\treturn err;\n}\n\nsubsys_initcall(pps_init);\nmodule_exit(pps_exit);\n\nMODULE_AUTHOR(\"Rodolfo Giometti <giometti@linux.it>\");\nMODULE_DESCRIPTION(\"LinuxPPS support (RFC 2783) - ver. \" PPS_VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}