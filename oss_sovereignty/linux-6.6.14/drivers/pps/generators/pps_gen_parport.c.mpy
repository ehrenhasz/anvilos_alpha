{
  "module_name": "pps_gen_parport.c",
  "hash_id": "5292090b01b65aefbb7b88dc21b0385af5638906910c5aa14bf79da740621f7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pps/generators/pps_gen_parport.c",
  "human_readable_source": "\n \n\n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/hrtimer.h>\n#include <linux/parport.h>\n\n#define SIGNAL\t\t0\n#define NO_SIGNAL\tPARPORT_CONTROL_STROBE\n\n \n\n#define SEND_DELAY_MAX\t\t100000\n\nstatic unsigned int send_delay = 30000;\nMODULE_PARM_DESC(delay,\n\t\"Delay between setting and dropping the signal (ns)\");\nmodule_param_named(delay, send_delay, uint, 0);\n\n\n#define SAFETY_INTERVAL\t3000\t \n\n \nstruct pps_generator_pp {\n\tstruct pardevice *pardev;\t \n\tstruct hrtimer timer;\n\tlong port_write_time;\t\t \n};\n\nstatic struct pps_generator_pp device = {\n\t.pardev = NULL,\n};\n\nstatic int attached;\n\n \nstatic long hrtimer_error = SAFETY_INTERVAL;\n\n \nstatic enum hrtimer_restart hrtimer_event(struct hrtimer *timer)\n{\n\tstruct timespec64 expire_time, ts1, ts2, ts3, dts;\n\tstruct pps_generator_pp *dev;\n\tstruct parport *port;\n\tlong lim, delta;\n\tunsigned long flags;\n\n\t \n\tlocal_irq_save(flags);\n\n\t \n\tktime_get_real_ts64(&ts1);\n\texpire_time = ktime_to_timespec64(hrtimer_get_softexpires(timer));\n\tdev = container_of(timer, struct pps_generator_pp, timer);\n\tlim = NSEC_PER_SEC - send_delay - dev->port_write_time;\n\n\t \n\tif (expire_time.tv_sec != ts1.tv_sec || ts1.tv_nsec > lim) {\n\t\tlocal_irq_restore(flags);\n\t\tpr_err(\"we are late this time %lld.%09ld\\n\",\n\t\t\t\t(s64)ts1.tv_sec, ts1.tv_nsec);\n\t\tgoto done;\n\t}\n\n\t \n\tdo {\n\t\tktime_get_real_ts64(&ts2);\n\t} while (expire_time.tv_sec == ts2.tv_sec && ts2.tv_nsec < lim);\n\n\t \n\tport = dev->pardev->port;\n\tport->ops->write_control(port, SIGNAL);\n\n\t \n\tlim = NSEC_PER_SEC - dev->port_write_time;\n\tdo {\n\t\tktime_get_real_ts64(&ts2);\n\t} while (expire_time.tv_sec == ts2.tv_sec && ts2.tv_nsec < lim);\n\n\t \n\tport->ops->write_control(port, NO_SIGNAL);\n\n\tktime_get_real_ts64(&ts3);\n\n\tlocal_irq_restore(flags);\n\n\t \n\tdts = timespec64_sub(ts3, ts2);\n\tdev->port_write_time =\n\t\t(dev->port_write_time + timespec64_to_ns(&dts)) >> 1;\n\ndone:\n\t \n\tdts = timespec64_sub(ts1, expire_time);\n\tdelta = timespec64_to_ns(&dts);\n\t \n\tif (delta >= hrtimer_error)\n\t\thrtimer_error = delta;\n\telse\n\t\thrtimer_error = (3 * hrtimer_error + delta) >> 2;\n\n\t \n\thrtimer_set_expires(timer,\n\t\t\tktime_set(expire_time.tv_sec + 1,\n\t\t\t\tNSEC_PER_SEC - (send_delay +\n\t\t\t\tdev->port_write_time + SAFETY_INTERVAL +\n\t\t\t\t2 * hrtimer_error)));\n\n\treturn HRTIMER_RESTART;\n}\n\n \n#define PORT_NTESTS_SHIFT\t5\nstatic void calibrate_port(struct pps_generator_pp *dev)\n{\n\tstruct parport *port = dev->pardev->port;\n\tint i;\n\tlong acc = 0;\n\n\tfor (i = 0; i < (1 << PORT_NTESTS_SHIFT); i++) {\n\t\tstruct timespec64 a, b;\n\t\tunsigned long irq_flags;\n\n\t\tlocal_irq_save(irq_flags);\n\t\tktime_get_real_ts64(&a);\n\t\tport->ops->write_control(port, NO_SIGNAL);\n\t\tktime_get_real_ts64(&b);\n\t\tlocal_irq_restore(irq_flags);\n\n\t\tb = timespec64_sub(b, a);\n\t\tacc += timespec64_to_ns(&b);\n\t}\n\n\tdev->port_write_time = acc >> PORT_NTESTS_SHIFT;\n\tpr_info(\"port write takes %ldns\\n\", dev->port_write_time);\n}\n\nstatic inline ktime_t next_intr_time(struct pps_generator_pp *dev)\n{\n\tstruct timespec64 ts;\n\n\tktime_get_real_ts64(&ts);\n\n\treturn ktime_set(ts.tv_sec +\n\t\t\t((ts.tv_nsec > 990 * NSEC_PER_MSEC) ? 1 : 0),\n\t\t\tNSEC_PER_SEC - (send_delay +\n\t\t\tdev->port_write_time + 3 * SAFETY_INTERVAL));\n}\n\nstatic void parport_attach(struct parport *port)\n{\n\tstruct pardev_cb pps_cb;\n\n\tif (send_delay > SEND_DELAY_MAX) {\n\t\tpr_err(\"delay value should be not greater then %d\\n\", SEND_DELAY_MAX);\n\t\treturn;\n\t}\n\n\tif (attached) {\n\t\t \n\t\treturn;\n\t}\n\n\tmemset(&pps_cb, 0, sizeof(pps_cb));\n\tpps_cb.private = &device;\n\tpps_cb.flags = PARPORT_FLAG_EXCL;\n\tdevice.pardev = parport_register_dev_model(port, KBUILD_MODNAME,\n\t\t\t\t\t\t   &pps_cb, 0);\n\tif (!device.pardev) {\n\t\tpr_err(\"couldn't register with %s\\n\", port->name);\n\t\treturn;\n\t}\n\n\tif (parport_claim_or_block(device.pardev) < 0) {\n\t\tpr_err(\"couldn't claim %s\\n\", port->name);\n\t\tgoto err_unregister_dev;\n\t}\n\n\tpr_info(\"attached to %s\\n\", port->name);\n\tattached = 1;\n\n\tcalibrate_port(&device);\n\n\thrtimer_init(&device.timer, CLOCK_REALTIME, HRTIMER_MODE_ABS);\n\tdevice.timer.function = hrtimer_event;\n\thrtimer_start(&device.timer, next_intr_time(&device), HRTIMER_MODE_ABS);\n\n\treturn;\n\nerr_unregister_dev:\n\tparport_unregister_device(device.pardev);\n}\n\nstatic void parport_detach(struct parport *port)\n{\n\tif (port->cad != device.pardev)\n\t\treturn;\t \n\n\thrtimer_cancel(&device.timer);\n\tparport_release(device.pardev);\n\tparport_unregister_device(device.pardev);\n}\n\nstatic struct parport_driver pps_gen_parport_driver = {\n\t.name = KBUILD_MODNAME,\n\t.match_port = parport_attach,\n\t.detach = parport_detach,\n\t.devmodel = true,\n};\nmodule_parport_driver(pps_gen_parport_driver);\n\nMODULE_AUTHOR(\"Alexander Gordeev <lasaine@lvk.cs.msu.su>\");\nMODULE_DESCRIPTION(\"parallel port PPS signal generator\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}