{
  "module_name": "Kconfig",
  "hash_id": "8837822991c190fb8dc2d27e289e52d353e3e929d3b11c9a6df490b3baba1a72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pps/clients/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# PPS clients configuration\n#\n\ncomment \"PPS clients support\"\n\nconfig PPS_CLIENT_KTIMER\n\ttristate \"Kernel timer client (Testing client, use for debug)\"\n\thelp\n\t  If you say yes here you get support for a PPS debugging client\n\t  which uses a kernel timer to generate the PPS signal.\n\n\t  This driver can also be built as a module.  If so, the module\n\t  will be called pps-ktimer.\n\nconfig PPS_CLIENT_LDISC\n\ttristate \"PPS line discipline\"\n\tdepends on TTY\n\thelp\n\t  If you say yes here you get support for a PPS source connected\n\t  with the CD (Carrier Detect) pin of your serial port.\n\nconfig PPS_CLIENT_PARPORT\n\ttristate \"Parallel port PPS client\"\n\tdepends on PARPORT\n\thelp\n\t  If you say yes here you get support for a PPS source connected\n\t  with the interrupt pin of your parallel port.\n\nconfig PPS_CLIENT_GPIO\n\ttristate \"PPS client using GPIO\"\n\thelp\n\t  If you say yes here you get support for a PPS source using\n\t  GPIO. To be useful you must also register a platform device\n\t  specifying the GPIO pin and other options, usually in your board\n\t  setup.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}