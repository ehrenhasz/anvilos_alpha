{
  "module_name": "pps-gpio.c",
  "hash_id": "80d76b0c7826d32870ab08322f7e81be2e15db12e586bcbd88762b6f71f5e8e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pps/clients/pps-gpio.c",
  "human_readable_source": "\n \n\n#define PPS_GPIO_NAME \"pps-gpio\"\n#define pr_fmt(fmt) PPS_GPIO_NAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/pps_kernel.h>\n#include <linux/gpio/consumer.h>\n#include <linux/list.h>\n#include <linux/property.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n\n \nstruct pps_gpio_device_data {\n\tint irq;\t\t\t \n\tstruct pps_device *pps;\t\t \n\tstruct pps_source_info info;\t \n\tstruct gpio_desc *gpio_pin;\t \n\tstruct gpio_desc *echo_pin;\n\tstruct timer_list echo_timer;\t \n\tbool assert_falling_edge;\n\tbool capture_clear;\n\tunsigned int echo_active_ms;\t \n\tunsigned long echo_timeout;\t \n};\n\n \n\nstatic irqreturn_t pps_gpio_irq_handler(int irq, void *data)\n{\n\tconst struct pps_gpio_device_data *info;\n\tstruct pps_event_time ts;\n\tint rising_edge;\n\n\t \n\tpps_get_ts(&ts);\n\n\tinfo = data;\n\n\trising_edge = gpiod_get_value(info->gpio_pin);\n\tif ((rising_edge && !info->assert_falling_edge) ||\n\t\t\t(!rising_edge && info->assert_falling_edge))\n\t\tpps_event(info->pps, &ts, PPS_CAPTUREASSERT, data);\n\telse if (info->capture_clear &&\n\t\t\t((rising_edge && info->assert_falling_edge) ||\n\t\t\t(!rising_edge && !info->assert_falling_edge)))\n\t\tpps_event(info->pps, &ts, PPS_CAPTURECLEAR, data);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void pps_gpio_echo(struct pps_device *pps, int event, void *data)\n{\n\t \n\tstruct pps_gpio_device_data *info = data;\n\n\tswitch (event) {\n\tcase PPS_CAPTUREASSERT:\n\t\tif (pps->params.mode & PPS_ECHOASSERT)\n\t\t\tgpiod_set_value(info->echo_pin, 1);\n\t\tbreak;\n\n\tcase PPS_CAPTURECLEAR:\n\t\tif (pps->params.mode & PPS_ECHOCLEAR)\n\t\t\tgpiod_set_value(info->echo_pin, 1);\n\t\tbreak;\n\t}\n\n\t \n\tif (info->pps->params.mode & (PPS_ECHOASSERT | PPS_ECHOCLEAR)) {\n\t\tinfo->echo_timer.expires = jiffies + info->echo_timeout;\n\t\tadd_timer(&info->echo_timer);\n\t}\n}\n\n \nstatic void pps_gpio_echo_timer_callback(struct timer_list *t)\n{\n\tconst struct pps_gpio_device_data *info;\n\n\tinfo = from_timer(info, t, echo_timer);\n\n\tgpiod_set_value(info->echo_pin, 0);\n}\n\nstatic int pps_gpio_setup(struct device *dev)\n{\n\tstruct pps_gpio_device_data *data = dev_get_drvdata(dev);\n\tint ret;\n\tu32 value;\n\n\tdata->gpio_pin = devm_gpiod_get(dev, NULL, GPIOD_IN);\n\tif (IS_ERR(data->gpio_pin))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->gpio_pin),\n\t\t\t\t     \"failed to request PPS GPIO\\n\");\n\n\tdata->assert_falling_edge =\n\t\tdevice_property_read_bool(dev, \"assert-falling-edge\");\n\n\tdata->echo_pin = devm_gpiod_get_optional(dev, \"echo\", GPIOD_OUT_LOW);\n\tif (IS_ERR(data->echo_pin))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->echo_pin),\n\t\t\t\t     \"failed to request ECHO GPIO\\n\");\n\n\tif (!data->echo_pin)\n\t\treturn 0;\n\n\tret = device_property_read_u32(dev, \"echo-active-ms\", &value);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get echo-active-ms from FW\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!value || value > 999) {\n\t\tdev_err(dev, \"echo-active-ms: %u - bad value from FW\\n\", value);\n\t\treturn -EINVAL;\n\t}\n\n\tdata->echo_active_ms = value;\n\n\treturn 0;\n}\n\nstatic unsigned long\nget_irqf_trigger_flags(const struct pps_gpio_device_data *data)\n{\n\tunsigned long flags = data->assert_falling_edge ?\n\t\tIRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;\n\n\tif (data->capture_clear) {\n\t\tflags |= ((flags & IRQF_TRIGGER_RISING) ?\n\t\t\t\tIRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING);\n\t}\n\n\treturn flags;\n}\n\nstatic int pps_gpio_probe(struct platform_device *pdev)\n{\n\tstruct pps_gpio_device_data *data;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\tint pps_default_params;\n\n\t \n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, data);\n\n\t \n\tret = pps_gpio_setup(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = gpiod_to_irq(data->gpio_pin);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to map GPIO to IRQ: %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\tdata->irq = ret;\n\n\t \n\tdata->info.mode = PPS_CAPTUREASSERT | PPS_OFFSETASSERT |\n\t\tPPS_ECHOASSERT | PPS_CANWAIT | PPS_TSFMT_TSPEC;\n\tif (data->capture_clear)\n\t\tdata->info.mode |= PPS_CAPTURECLEAR | PPS_OFFSETCLEAR |\n\t\t\tPPS_ECHOCLEAR;\n\tdata->info.owner = THIS_MODULE;\n\tsnprintf(data->info.name, PPS_MAX_NAME_LEN - 1, \"%s.%d\",\n\t\t pdev->name, pdev->id);\n\tif (data->echo_pin) {\n\t\tdata->info.echo = pps_gpio_echo;\n\t\tdata->echo_timeout = msecs_to_jiffies(data->echo_active_ms);\n\t\ttimer_setup(&data->echo_timer, pps_gpio_echo_timer_callback, 0);\n\t}\n\n\t \n\tpps_default_params = PPS_CAPTUREASSERT | PPS_OFFSETASSERT;\n\tif (data->capture_clear)\n\t\tpps_default_params |= PPS_CAPTURECLEAR | PPS_OFFSETCLEAR;\n\tdata->pps = pps_register_source(&data->info, pps_default_params);\n\tif (IS_ERR(data->pps)) {\n\t\tdev_err(dev, \"failed to register IRQ %d as PPS source\\n\",\n\t\t\tdata->irq);\n\t\treturn PTR_ERR(data->pps);\n\t}\n\n\t \n\tret = devm_request_irq(dev, data->irq, pps_gpio_irq_handler,\n\t\t\tget_irqf_trigger_flags(data), data->info.name, data);\n\tif (ret) {\n\t\tpps_unregister_source(data->pps);\n\t\tdev_err(dev, \"failed to acquire IRQ %d\\n\", data->irq);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(data->pps->dev, \"Registered IRQ %d as PPS source\\n\",\n\t\t data->irq);\n\n\treturn 0;\n}\n\nstatic int pps_gpio_remove(struct platform_device *pdev)\n{\n\tstruct pps_gpio_device_data *data = platform_get_drvdata(pdev);\n\n\tpps_unregister_source(data->pps);\n\tdel_timer_sync(&data->echo_timer);\n\t \n\tgpiod_set_value(data->echo_pin, 0);\n\tdev_info(&pdev->dev, \"removed IRQ %d as PPS source\\n\", data->irq);\n\treturn 0;\n}\n\nstatic const struct of_device_id pps_gpio_dt_ids[] = {\n\t{ .compatible = \"pps-gpio\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pps_gpio_dt_ids);\n\nstatic struct platform_driver pps_gpio_driver = {\n\t.probe\t\t= pps_gpio_probe,\n\t.remove\t\t= pps_gpio_remove,\n\t.driver\t\t= {\n\t\t.name\t= PPS_GPIO_NAME,\n\t\t.of_match_table\t= pps_gpio_dt_ids,\n\t},\n};\n\nmodule_platform_driver(pps_gpio_driver);\nMODULE_AUTHOR(\"Ricardo Martins <rasm@fe.up.pt>\");\nMODULE_AUTHOR(\"James Nuss <jamesnuss@nanometrics.ca>\");\nMODULE_DESCRIPTION(\"Use GPIO pin as PPS source\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.2.0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}