{
  "module_name": "pps-ldisc.c",
  "hash_id": "ef5d163e052f16f525b282a9d763c01b62005a2df77e98d7918eb65afb96fa1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pps/clients/pps-ldisc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/serial_core.h>\n#include <linux/tty.h>\n#include <linux/pps_kernel.h>\n#include <linux/bug.h>\n\nstatic void pps_tty_dcd_change(struct tty_struct *tty, bool active)\n{\n\tstruct pps_device *pps;\n\tstruct pps_event_time ts;\n\n\tpps_get_ts(&ts);\n\n\tpps = pps_lookup_dev(tty);\n\t \n\tif (WARN_ON_ONCE(pps == NULL))\n\t\treturn;\n\n\t \n\tpps_event(pps, &ts, active ? PPS_CAPTUREASSERT :\n\t\t\tPPS_CAPTURECLEAR, NULL);\n\n\tdev_dbg(pps->dev, \"PPS %s at %lu\\n\",\n\t\t\tactive ? \"assert\" : \"clear\", jiffies);\n}\n\nstatic int (*alias_n_tty_open)(struct tty_struct *tty);\n\nstatic int pps_tty_open(struct tty_struct *tty)\n{\n\tstruct pps_source_info info;\n\tstruct tty_driver *drv = tty->driver;\n\tint index = tty->index + drv->name_base;\n\tstruct pps_device *pps;\n\tint ret;\n\n\tinfo.owner = THIS_MODULE;\n\tinfo.dev = NULL;\n\tsnprintf(info.name, PPS_MAX_NAME_LEN, \"%s%d\", drv->driver_name, index);\n\tsnprintf(info.path, PPS_MAX_NAME_LEN, \"/dev/%s%d\", drv->name, index);\n\tinfo.mode = PPS_CAPTUREBOTH | \\\n\t\t\tPPS_OFFSETASSERT | PPS_OFFSETCLEAR | \\\n\t\t\tPPS_CANWAIT | PPS_TSFMT_TSPEC;\n\n\tpps = pps_register_source(&info, PPS_CAPTUREBOTH | \\\n\t\t\t\tPPS_OFFSETASSERT | PPS_OFFSETCLEAR);\n\tif (IS_ERR(pps)) {\n\t\tpr_err(\"cannot register PPS source \\\"%s\\\"\\n\", info.path);\n\t\treturn PTR_ERR(pps);\n\t}\n\tpps->lookup_cookie = tty;\n\n\t \n\tret = alias_n_tty_open(tty);\n\tif (ret < 0) {\n\t\tpr_err(\"cannot open tty ldisc \\\"%s\\\"\\n\", info.path);\n\t\tgoto err_unregister;\n\t}\n\n\tdev_info(pps->dev, \"source \\\"%s\\\" added\\n\", info.path);\n\n\treturn 0;\n\nerr_unregister:\n\tpps_unregister_source(pps);\n\treturn ret;\n}\n\nstatic void (*alias_n_tty_close)(struct tty_struct *tty);\n\nstatic void pps_tty_close(struct tty_struct *tty)\n{\n\tstruct pps_device *pps = pps_lookup_dev(tty);\n\n\talias_n_tty_close(tty);\n\n\tif (WARN_ON(!pps))\n\t\treturn;\n\n\tdev_info(pps->dev, \"removed\\n\");\n\tpps_unregister_source(pps);\n}\n\nstatic struct tty_ldisc_ops pps_ldisc_ops;\n\n \n\nstatic int __init pps_tty_init(void)\n{\n\tint err;\n\n\t \n\tn_tty_inherit_ops(&pps_ldisc_ops);\n\n\t \n\talias_n_tty_open = pps_ldisc_ops.open;\n\talias_n_tty_close = pps_ldisc_ops.close;\n\n\t \n\tpps_ldisc_ops.owner = THIS_MODULE;\n\tpps_ldisc_ops.num = N_PPS;\n\tpps_ldisc_ops.name = \"pps_tty\";\n\tpps_ldisc_ops.dcd_change = pps_tty_dcd_change;\n\tpps_ldisc_ops.open = pps_tty_open;\n\tpps_ldisc_ops.close = pps_tty_close;\n\n\terr = tty_register_ldisc(&pps_ldisc_ops);\n\tif (err)\n\t\tpr_err(\"can't register PPS line discipline\\n\");\n\telse\n\t\tpr_info(\"PPS line discipline registered\\n\");\n\n\treturn err;\n}\n\nstatic void __exit pps_tty_cleanup(void)\n{\n\ttty_unregister_ldisc(&pps_ldisc_ops);\n}\n\nmodule_init(pps_tty_init);\nmodule_exit(pps_tty_cleanup);\n\nMODULE_ALIAS_LDISC(N_PPS);\nMODULE_AUTHOR(\"Rodolfo Giometti <giometti@linux.it>\");\nMODULE_DESCRIPTION(\"PPS TTY device driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}