{
  "module_name": "pps_parport.c",
  "hash_id": "d52481c6e2fd0db99a152795906c7801e68c0024fbf4dc70b451e1eeea2a56cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pps/clients/pps_parport.c",
  "human_readable_source": "\n \n\n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/irqnr.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/parport.h>\n#include <linux/pps_kernel.h>\n\n \n\n#define CLEAR_WAIT_MAX\t\t100\n#define CLEAR_WAIT_MAX_ERRORS\t5\n\nstatic unsigned int clear_wait = 100;\nMODULE_PARM_DESC(clear_wait,\n\t\"Maximum number of port reads when polling for signal clear,\"\n\t\" zero turns clear edge capture off entirely\");\nmodule_param(clear_wait, uint, 0);\n\nstatic DEFINE_IDA(pps_client_index);\n\n \nstruct pps_client_pp {\n\tstruct pardevice *pardev;\t \n\tstruct pps_device *pps;\t\t \n\tunsigned int cw;\t\t \n\tunsigned int cw_err;\t\t \n\tint index;\t\t\t \n};\n\nstatic inline int signal_is_set(struct parport *port)\n{\n\treturn (port->ops->read_status(port) & PARPORT_STATUS_ACK) != 0;\n}\n\n \nstatic void parport_irq(void *handle)\n{\n\tstruct pps_event_time ts_assert, ts_clear;\n\tstruct pps_client_pp *dev = handle;\n\tstruct parport *port = dev->pardev->port;\n\tunsigned int i;\n\tunsigned long flags;\n\n\t \n\tpps_get_ts(&ts_assert);\n\n\tif (dev->cw == 0)\n\t\t \n\t\tgoto out_assert;\n\n\t \n\n\t \n\tlocal_irq_save(flags);\n\t \n\tif (!signal_is_set(port)) {\n\t\tlocal_irq_restore(flags);\n\t\tdev_err(dev->pps->dev, \"lost the signal\\n\");\n\t\tgoto out_assert;\n\t}\n\n\t \n\tfor (i = dev->cw; i; i--)\n\t\tif (!signal_is_set(port)) {\n\t\t\tpps_get_ts(&ts_clear);\n\t\t\tlocal_irq_restore(flags);\n\t\t\tdev->cw_err = 0;\n\t\t\tgoto out_both;\n\t\t}\n\tlocal_irq_restore(flags);\n\n\t \n\tdev->cw_err++;\n\tif (dev->cw_err >= CLEAR_WAIT_MAX_ERRORS) {\n\t\tdev_err(dev->pps->dev, \"disabled clear edge capture after %d\"\n\t\t\t\t\" timeouts\\n\", dev->cw_err);\n\t\tdev->cw = 0;\n\t\tdev->cw_err = 0;\n\t}\n\nout_assert:\n\t \n\tpps_event(dev->pps, &ts_assert,\n\t\t\tPPS_CAPTUREASSERT, NULL);\n\treturn;\n\nout_both:\n\t \n\tpps_event(dev->pps, &ts_assert,\n\t\t\tPPS_CAPTUREASSERT, NULL);\n\t \n\tpps_event(dev->pps, &ts_clear,\n\t\t\tPPS_CAPTURECLEAR, NULL);\n\treturn;\n}\n\nstatic void parport_attach(struct parport *port)\n{\n\tstruct pardev_cb pps_client_cb;\n\tint index;\n\tstruct pps_client_pp *device;\n\tstruct pps_source_info info = {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.path\t\t= \"\",\n\t\t.mode\t\t= PPS_CAPTUREBOTH | \\\n\t\t\t\t  PPS_OFFSETASSERT | PPS_OFFSETCLEAR | \\\n\t\t\t\t  PPS_ECHOASSERT | PPS_ECHOCLEAR | \\\n\t\t\t\t  PPS_CANWAIT | PPS_TSFMT_TSPEC,\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.dev\t\t= NULL\n\t};\n\n\tif (clear_wait > CLEAR_WAIT_MAX) {\n\t\tpr_err(\"clear_wait value should be not greater then %d\\n\",\n\t\t       CLEAR_WAIT_MAX);\n\t\treturn;\n\t}\n\n\tdevice = kzalloc(sizeof(struct pps_client_pp), GFP_KERNEL);\n\tif (!device) {\n\t\tpr_err(\"memory allocation failed, not attaching\\n\");\n\t\treturn;\n\t}\n\n\tindex = ida_simple_get(&pps_client_index, 0, 0, GFP_KERNEL);\n\tmemset(&pps_client_cb, 0, sizeof(pps_client_cb));\n\tpps_client_cb.private = device;\n\tpps_client_cb.irq_func = parport_irq;\n\tpps_client_cb.flags = PARPORT_FLAG_EXCL;\n\tdevice->pardev = parport_register_dev_model(port,\n\t\t\t\t\t\t    KBUILD_MODNAME,\n\t\t\t\t\t\t    &pps_client_cb,\n\t\t\t\t\t\t    index);\n\tif (!device->pardev) {\n\t\tpr_err(\"couldn't register with %s\\n\", port->name);\n\t\tgoto err_free;\n\t}\n\n\tif (parport_claim_or_block(device->pardev) < 0) {\n\t\tpr_err(\"couldn't claim %s\\n\", port->name);\n\t\tgoto err_unregister_dev;\n\t}\n\n\tdevice->pps = pps_register_source(&info,\n\t\t\tPPS_CAPTUREBOTH | PPS_OFFSETASSERT | PPS_OFFSETCLEAR);\n\tif (IS_ERR(device->pps)) {\n\t\tpr_err(\"couldn't register PPS source\\n\");\n\t\tgoto err_release_dev;\n\t}\n\n\tdevice->cw = clear_wait;\n\n\tport->ops->enable_irq(port);\n\tdevice->index = index;\n\n\tpr_info(\"attached to %s\\n\", port->name);\n\n\treturn;\n\nerr_release_dev:\n\tparport_release(device->pardev);\nerr_unregister_dev:\n\tparport_unregister_device(device->pardev);\nerr_free:\n\tida_simple_remove(&pps_client_index, index);\n\tkfree(device);\n}\n\nstatic void parport_detach(struct parport *port)\n{\n\tstruct pardevice *pardev = port->cad;\n\tstruct pps_client_pp *device;\n\n\t \n\tif (!pardev || strcmp(pardev->name, KBUILD_MODNAME))\n\t\t \n\t\treturn;\n\n\tdevice = pardev->private;\n\n\tport->ops->disable_irq(port);\n\tpps_unregister_source(device->pps);\n\tparport_release(pardev);\n\tparport_unregister_device(pardev);\n\tida_simple_remove(&pps_client_index, device->index);\n\tkfree(device);\n}\n\nstatic struct parport_driver pps_parport_driver = {\n\t.name = KBUILD_MODNAME,\n\t.match_port = parport_attach,\n\t.detach = parport_detach,\n\t.devmodel = true,\n};\nmodule_parport_driver(pps_parport_driver);\n\nMODULE_AUTHOR(\"Alexander Gordeev <lasaine@lvk.cs.msu.su>\");\nMODULE_DESCRIPTION(\"parallel port PPS client\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}