{
  "module_name": "kapi.c",
  "hash_id": "c0b9f5190709d4196919ddcf60d3693654b4c58375e196c90f4fb57a79fac22b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pps/kapi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/spinlock.h>\n#include <linux/fs.h>\n#include <linux/pps_kernel.h>\n#include <linux/slab.h>\n\n#include \"kc.h\"\n\n \n\nstatic void pps_add_offset(struct pps_ktime *ts, struct pps_ktime *offset)\n{\n\tts->nsec += offset->nsec;\n\twhile (ts->nsec >= NSEC_PER_SEC) {\n\t\tts->nsec -= NSEC_PER_SEC;\n\t\tts->sec++;\n\t}\n\twhile (ts->nsec < 0) {\n\t\tts->nsec += NSEC_PER_SEC;\n\t\tts->sec--;\n\t}\n\tts->sec += offset->sec;\n}\n\nstatic void pps_echo_client_default(struct pps_device *pps, int event,\n\t\tvoid *data)\n{\n\tdev_info(pps->dev, \"echo %s %s\\n\",\n\t\tevent & PPS_CAPTUREASSERT ? \"assert\" : \"\",\n\t\tevent & PPS_CAPTURECLEAR ? \"clear\" : \"\");\n}\n\n \n\n \n\nstruct pps_device *pps_register_source(struct pps_source_info *info,\n\t\tint default_params)\n{\n\tstruct pps_device *pps;\n\tint err;\n\n\t \n\tif ((info->mode & default_params) != default_params) {\n\t\tpr_err(\"%s: unsupported default parameters\\n\",\n\t\t\t\t\tinfo->name);\n\t\terr = -EINVAL;\n\t\tgoto pps_register_source_exit;\n\t}\n\tif ((info->mode & (PPS_TSFMT_TSPEC | PPS_TSFMT_NTPFP)) == 0) {\n\t\tpr_err(\"%s: unspecified time format\\n\",\n\t\t\t\t\tinfo->name);\n\t\terr = -EINVAL;\n\t\tgoto pps_register_source_exit;\n\t}\n\n\t \n\tpps = kzalloc(sizeof(struct pps_device), GFP_KERNEL);\n\tif (pps == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto pps_register_source_exit;\n\t}\n\n\t \n\tpps->params.api_version = PPS_API_VERS;\n\tpps->params.mode = default_params;\n\tpps->info = *info;\n\n\t \n\tif ((pps->info.mode & (PPS_ECHOASSERT | PPS_ECHOCLEAR)) &&\n\t\t\tpps->info.echo == NULL)\n\t\tpps->info.echo = pps_echo_client_default;\n\n\tinit_waitqueue_head(&pps->queue);\n\tspin_lock_init(&pps->lock);\n\n\t \n\terr = pps_register_cdev(pps);\n\tif (err < 0) {\n\t\tpr_err(\"%s: unable to create char device\\n\",\n\t\t\t\t\tinfo->name);\n\t\tgoto kfree_pps;\n\t}\n\n\tdev_info(pps->dev, \"new PPS source %s\\n\", info->name);\n\n\treturn pps;\n\nkfree_pps:\n\tkfree(pps);\n\npps_register_source_exit:\n\tpr_err(\"%s: unable to register source\\n\", info->name);\n\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(pps_register_source);\n\n \n\nvoid pps_unregister_source(struct pps_device *pps)\n{\n\tpps_kc_remove(pps);\n\tpps_unregister_cdev(pps);\n\n\t \n}\nEXPORT_SYMBOL(pps_unregister_source);\n\n \nvoid pps_event(struct pps_device *pps, struct pps_event_time *ts, int event,\n\t\tvoid *data)\n{\n\tunsigned long flags;\n\tint captured = 0;\n\tstruct pps_ktime ts_real = { .sec = 0, .nsec = 0, .flags = 0 };\n\n\t \n\tBUG_ON((event & (PPS_CAPTUREASSERT | PPS_CAPTURECLEAR)) == 0);\n\n\tdev_dbg(pps->dev, \"PPS event at %lld.%09ld\\n\",\n\t\t\t(s64)ts->ts_real.tv_sec, ts->ts_real.tv_nsec);\n\n\ttimespec_to_pps_ktime(&ts_real, ts->ts_real);\n\n\tspin_lock_irqsave(&pps->lock, flags);\n\n\t \n\tif ((pps->params.mode & (PPS_ECHOASSERT | PPS_ECHOCLEAR)))\n\t\tpps->info.echo(pps, event, data);\n\n\t \n\tpps->current_mode = pps->params.mode;\n\tif (event & pps->params.mode & PPS_CAPTUREASSERT) {\n\t\t \n\t\tif (pps->params.mode & PPS_OFFSETASSERT)\n\t\t\tpps_add_offset(&ts_real,\n\t\t\t\t\t&pps->params.assert_off_tu);\n\n\t\t \n\t\tpps->assert_tu = ts_real;\n\t\tpps->assert_sequence++;\n\t\tdev_dbg(pps->dev, \"capture assert seq #%u\\n\",\n\t\t\tpps->assert_sequence);\n\n\t\tcaptured = ~0;\n\t}\n\tif (event & pps->params.mode & PPS_CAPTURECLEAR) {\n\t\t \n\t\tif (pps->params.mode & PPS_OFFSETCLEAR)\n\t\t\tpps_add_offset(&ts_real,\n\t\t\t\t\t&pps->params.clear_off_tu);\n\n\t\t \n\t\tpps->clear_tu = ts_real;\n\t\tpps->clear_sequence++;\n\t\tdev_dbg(pps->dev, \"capture clear seq #%u\\n\",\n\t\t\tpps->clear_sequence);\n\n\t\tcaptured = ~0;\n\t}\n\n\tpps_kc_event(pps, ts, event);\n\n\t \n\tif (captured) {\n\t\tpps->last_ev++;\n\t\twake_up_interruptible_all(&pps->queue);\n\n\t\tkill_fasync(&pps->async_queue, SIGIO, POLL_IN);\n\t}\n\n\tspin_unlock_irqrestore(&pps->lock, flags);\n}\nEXPORT_SYMBOL(pps_event);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}