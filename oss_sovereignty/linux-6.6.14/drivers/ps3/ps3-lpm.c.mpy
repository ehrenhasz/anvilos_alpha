{
  "module_name": "ps3-lpm.c",
  "hash_id": "62ac1b83fa0880e9da7159f1ec96432dff5dea355884f2226a95d282a1ad008b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ps3/ps3-lpm.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/uaccess.h>\n#include <asm/smp.h>\n#include <asm/time.h>\n#include <asm/ps3.h>\n#include <asm/lv1call.h>\n#include <asm/cell-pmu.h>\n\n\n \n#define PS3_PM_BOOKMARK_START                    0x8000000000000000ULL\n#define PS3_PM_BOOKMARK_STOP                     0x4000000000000000ULL\n#define PS3_PM_BOOKMARK_TAG_KERNEL               0x1000000000000000ULL\n#define PS3_PM_BOOKMARK_TAG_USER                 0x3000000000000000ULL\n#define PS3_PM_BOOKMARK_TAG_MASK_HI              0xF000000000000000ULL\n#define PS3_PM_BOOKMARK_TAG_MASK_LO              0x0F00000000000000ULL\n\n \n#define PS3_PM_CONTROL_PPU_TH0_BOOKMARK          0x00001000\n#define PS3_PM_CONTROL_PPU_TH1_BOOKMARK          0x00000800\n#define PS3_PM_CONTROL_PPU_COUNT_MODE_MASK       0x000C0000\n#define PS3_PM_CONTROL_PPU_COUNT_MODE_PROBLEM    0x00080000\n#define PS3_WRITE_PM_MASK                        0xFFFFFFFFFFFFFFFFULL\n\n \n#define PS3_PM_START_STOP_PPU_TH0_BOOKMARK_START 0x02000000\n#define PS3_PM_START_STOP_PPU_TH1_BOOKMARK_START 0x01000000\n#define PS3_PM_START_STOP_PPU_TH0_BOOKMARK_STOP  0x00020000\n#define PS3_PM_START_STOP_PPU_TH1_BOOKMARK_STOP  0x00010000\n#define PS3_PM_START_STOP_START_MASK             0xFF000000\n#define PS3_PM_START_STOP_STOP_MASK              0x00FF0000\n\n \n#define PS3_PM_COUNTER_MASK_HI                   0xFFFFFFFF00000000ULL\n#define PS3_PM_COUNTER_MASK_LO                   0x00000000FFFFFFFFULL\n\n \n#define PM_ISLAND2_BASE_SIGNAL_GROUP_NUMBER  0\n#define PM_ISLAND2_SIGNAL_GROUP_NUMBER1      6\n#define PM_ISLAND2_SIGNAL_GROUP_NUMBER2      7\n#define PM_ISLAND3_BASE_SIGNAL_GROUP_NUMBER  7\n#define PM_ISLAND4_BASE_SIGNAL_GROUP_NUMBER  15\n#define PM_SPU_TRIGGER_SIGNAL_GROUP_NUMBER   17\n#define PM_SPU_EVENT_SIGNAL_GROUP_NUMBER     18\n#define PM_ISLAND5_BASE_SIGNAL_GROUP_NUMBER  18\n#define PM_ISLAND6_BASE_SIGNAL_GROUP_NUMBER  24\n#define PM_ISLAND7_BASE_SIGNAL_GROUP_NUMBER  49\n#define PM_ISLAND8_BASE_SIGNAL_GROUP_NUMBER  52\n#define PM_SIG_GROUP_SPU                     41\n#define PM_SIG_GROUP_SPU_TRIGGER             42\n#define PM_SIG_GROUP_SPU_EVENT               43\n#define PM_SIG_GROUP_MFC_MAX                 60\n\n \n\nstruct ps3_lpm_shadow_regs {\n\tu64 pm_control;\n\tu64 pm_start_stop;\n\tu64 group_control;\n\tu64 debug_bus_control;\n};\n\n#define PS3_LPM_SHADOW_REG_INIT 0xFFFFFFFF00000000ULL\n\n \n\nstruct ps3_lpm_priv {\n\tatomic_t open;\n\tu64 rights;\n\tu64 node_id;\n\tu64 pu_id;\n\tu64 lpm_id;\n\tu64 outlet_id;\n\tu64 tb_count;\n\tvoid *tb_cache;\n\tu64 tb_cache_size;\n\tvoid *tb_cache_internal;\n\tstruct ps3_lpm_shadow_regs shadow;\n\tstruct ps3_system_bus_device *sbd;\n};\n\nenum {\n\tPS3_LPM_DEFAULT_TB_CACHE_SIZE = 0x4000,\n};\n\n \n\nstatic struct ps3_lpm_priv *lpm_priv;\n\nstatic struct device *sbd_core(void)\n{\n\tBUG_ON(!lpm_priv || !lpm_priv->sbd);\n\treturn &lpm_priv->sbd->core;\n}\n\n \n\nenum {use_start_stop_bookmark = 1,};\n\nvoid ps3_set_bookmark(u64 bookmark)\n{\n\t \n\n\tasm volatile(\"nop;nop;nop;nop;nop;nop;nop;nop;nop;\");\n\tmtspr(SPRN_BKMK, bookmark);\n\tasm volatile(\"nop;nop;nop;nop;nop;nop;nop;nop;nop;\");\n}\nEXPORT_SYMBOL_GPL(ps3_set_bookmark);\n\nvoid ps3_set_pm_bookmark(u64 tag, u64 incident, u64 th_id)\n{\n\tu64 bookmark;\n\n\tbookmark = (get_tb() & 0x00000000FFFFFFFFULL) |\n\t\tPS3_PM_BOOKMARK_TAG_KERNEL;\n\tbookmark = ((tag << 56) & PS3_PM_BOOKMARK_TAG_MASK_LO) |\n\t\t(incident << 48) | (th_id << 32) | bookmark;\n\tps3_set_bookmark(bookmark);\n}\nEXPORT_SYMBOL_GPL(ps3_set_pm_bookmark);\n\n \n\nu32 ps3_read_phys_ctr(u32 cpu, u32 phys_ctr)\n{\n\tint result;\n\tu64 counter0415;\n\tu64 counter2637;\n\n\tif (phys_ctr >= NR_PHYS_CTRS) {\n\t\tdev_dbg(sbd_core(), \"%s:%u: phys_ctr too big: %u\\n\", __func__,\n\t\t\t__LINE__, phys_ctr);\n\t\treturn 0;\n\t}\n\n\tresult = lv1_set_lpm_counter(lpm_priv->lpm_id, 0, 0, 0, 0, &counter0415,\n\t\t\t\t     &counter2637);\n\tif (result) {\n\t\tdev_err(sbd_core(), \"%s:%u: lv1_set_lpm_counter failed: \"\n\t\t\t\"phys_ctr %u, %s\\n\", __func__, __LINE__, phys_ctr,\n\t\t\tps3_result(result));\n\t\treturn 0;\n\t}\n\n\tswitch (phys_ctr) {\n\tcase 0:\n\t\treturn counter0415 >> 32;\n\tcase 1:\n\t\treturn counter0415 & PS3_PM_COUNTER_MASK_LO;\n\tcase 2:\n\t\treturn counter2637 >> 32;\n\tcase 3:\n\t\treturn counter2637 & PS3_PM_COUNTER_MASK_LO;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3_read_phys_ctr);\n\n \n\nvoid ps3_write_phys_ctr(u32 cpu, u32 phys_ctr, u32 val)\n{\n\tu64 counter0415;\n\tu64 counter0415_mask;\n\tu64 counter2637;\n\tu64 counter2637_mask;\n\tint result;\n\n\tif (phys_ctr >= NR_PHYS_CTRS) {\n\t\tdev_dbg(sbd_core(), \"%s:%u: phys_ctr too big: %u\\n\", __func__,\n\t\t\t__LINE__, phys_ctr);\n\t\treturn;\n\t}\n\n\tswitch (phys_ctr) {\n\tcase 0:\n\t\tcounter0415 = (u64)val << 32;\n\t\tcounter0415_mask = PS3_PM_COUNTER_MASK_HI;\n\t\tcounter2637 = 0x0;\n\t\tcounter2637_mask = 0x0;\n\t\tbreak;\n\tcase 1:\n\t\tcounter0415 = (u64)val;\n\t\tcounter0415_mask = PS3_PM_COUNTER_MASK_LO;\n\t\tcounter2637 = 0x0;\n\t\tcounter2637_mask = 0x0;\n\t\tbreak;\n\tcase 2:\n\t\tcounter0415 = 0x0;\n\t\tcounter0415_mask = 0x0;\n\t\tcounter2637 = (u64)val << 32;\n\t\tcounter2637_mask = PS3_PM_COUNTER_MASK_HI;\n\t\tbreak;\n\tcase 3:\n\t\tcounter0415 = 0x0;\n\t\tcounter0415_mask = 0x0;\n\t\tcounter2637 = (u64)val;\n\t\tcounter2637_mask = PS3_PM_COUNTER_MASK_LO;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tresult = lv1_set_lpm_counter(lpm_priv->lpm_id,\n\t\t\t\t     counter0415, counter0415_mask,\n\t\t\t\t     counter2637, counter2637_mask,\n\t\t\t\t     &counter0415, &counter2637);\n\tif (result)\n\t\tdev_err(sbd_core(), \"%s:%u: lv1_set_lpm_counter failed: \"\n\t\t\t\"phys_ctr %u, val %u, %s\\n\", __func__, __LINE__,\n\t\t\tphys_ctr, val, ps3_result(result));\n}\nEXPORT_SYMBOL_GPL(ps3_write_phys_ctr);\n\n \n\nu32 ps3_read_ctr(u32 cpu, u32 ctr)\n{\n\tu32 val;\n\tu32 phys_ctr = ctr & (NR_PHYS_CTRS - 1);\n\n\tval = ps3_read_phys_ctr(cpu, phys_ctr);\n\n\tif (ps3_get_ctr_size(cpu, phys_ctr) == 16)\n\t\tval = (ctr < NR_PHYS_CTRS) ? (val >> 16) : (val & 0xffff);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(ps3_read_ctr);\n\n \n\nvoid ps3_write_ctr(u32 cpu, u32 ctr, u32 val)\n{\n\tu32 phys_ctr;\n\tu32 phys_val;\n\n\tphys_ctr = ctr & (NR_PHYS_CTRS - 1);\n\n\tif (ps3_get_ctr_size(cpu, phys_ctr) == 16) {\n\t\tphys_val = ps3_read_phys_ctr(cpu, phys_ctr);\n\n\t\tif (ctr < NR_PHYS_CTRS)\n\t\t\tval = (val << 16) | (phys_val & 0xffff);\n\t\telse\n\t\t\tval = (val & 0xffff) | (phys_val & 0xffff0000);\n\t}\n\n\tps3_write_phys_ctr(cpu, phys_ctr, val);\n}\nEXPORT_SYMBOL_GPL(ps3_write_ctr);\n\n \n\nu32 ps3_read_pm07_control(u32 cpu, u32 ctr)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3_read_pm07_control);\n\n \n\nvoid ps3_write_pm07_control(u32 cpu, u32 ctr, u32 val)\n{\n\tint result;\n\tstatic const u64 mask = 0xFFFFFFFFFFFFFFFFULL;\n\tu64 old_value;\n\n\tif (ctr >= NR_CTRS) {\n\t\tdev_dbg(sbd_core(), \"%s:%u: ctr too big: %u\\n\", __func__,\n\t\t\t__LINE__, ctr);\n\t\treturn;\n\t}\n\n\tresult = lv1_set_lpm_counter_control(lpm_priv->lpm_id, ctr, val, mask,\n\t\t\t\t\t     &old_value);\n\tif (result)\n\t\tdev_err(sbd_core(), \"%s:%u: lv1_set_lpm_counter_control \"\n\t\t\t\"failed: ctr %u, %s\\n\", __func__, __LINE__, ctr,\n\t\t\tps3_result(result));\n}\nEXPORT_SYMBOL_GPL(ps3_write_pm07_control);\n\n \n\nu32 ps3_read_pm(u32 cpu, enum pm_reg_name reg)\n{\n\tint result = 0;\n\tu64 val = 0;\n\n\tswitch (reg) {\n\tcase pm_control:\n\t\treturn lpm_priv->shadow.pm_control;\n\tcase trace_address:\n\t\treturn CBE_PM_TRACE_BUF_EMPTY;\n\tcase pm_start_stop:\n\t\treturn lpm_priv->shadow.pm_start_stop;\n\tcase pm_interval:\n\t\tresult = lv1_set_lpm_interval(lpm_priv->lpm_id, 0, 0, &val);\n\t\tif (result) {\n\t\t\tval = 0;\n\t\t\tdev_dbg(sbd_core(), \"%s:%u: lv1 set_interval failed: \"\n\t\t\t\t\"reg %u, %s\\n\", __func__, __LINE__, reg,\n\t\t\t\tps3_result(result));\n\t\t}\n\t\treturn (u32)val;\n\tcase group_control:\n\t\treturn lpm_priv->shadow.group_control;\n\tcase debug_bus_control:\n\t\treturn lpm_priv->shadow.debug_bus_control;\n\tcase pm_status:\n\t\tresult = lv1_get_lpm_interrupt_status(lpm_priv->lpm_id,\n\t\t\t\t\t\t      &val);\n\t\tif (result) {\n\t\t\tval = 0;\n\t\t\tdev_dbg(sbd_core(), \"%s:%u: lv1 get_lpm_status failed: \"\n\t\t\t\t\"reg %u, %s\\n\", __func__, __LINE__, reg,\n\t\t\t\tps3_result(result));\n\t\t}\n\t\treturn (u32)val;\n\tcase ext_tr_timer:\n\t\treturn 0;\n\tdefault:\n\t\tdev_dbg(sbd_core(), \"%s:%u: unknown reg: %d\\n\", __func__,\n\t\t\t__LINE__, reg);\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3_read_pm);\n\n \n\nvoid ps3_write_pm(u32 cpu, enum pm_reg_name reg, u32 val)\n{\n\tint result = 0;\n\tu64 dummy;\n\n\tswitch (reg) {\n\tcase group_control:\n\t\tif (val != lpm_priv->shadow.group_control)\n\t\t\tresult = lv1_set_lpm_group_control(lpm_priv->lpm_id,\n\t\t\t\t\t\t\t   val,\n\t\t\t\t\t\t\t   PS3_WRITE_PM_MASK,\n\t\t\t\t\t\t\t   &dummy);\n\t\tlpm_priv->shadow.group_control = val;\n\t\tbreak;\n\tcase debug_bus_control:\n\t\tif (val != lpm_priv->shadow.debug_bus_control)\n\t\t\tresult = lv1_set_lpm_debug_bus_control(lpm_priv->lpm_id,\n\t\t\t\t\t\t\t      val,\n\t\t\t\t\t\t\t      PS3_WRITE_PM_MASK,\n\t\t\t\t\t\t\t      &dummy);\n\t\tlpm_priv->shadow.debug_bus_control = val;\n\t\tbreak;\n\tcase pm_control:\n\t\tif (use_start_stop_bookmark)\n\t\t\tval |= (PS3_PM_CONTROL_PPU_TH0_BOOKMARK |\n\t\t\t\tPS3_PM_CONTROL_PPU_TH1_BOOKMARK);\n\t\tif (val != lpm_priv->shadow.pm_control)\n\t\t\tresult = lv1_set_lpm_general_control(lpm_priv->lpm_id,\n\t\t\t\t\t\t\t     val,\n\t\t\t\t\t\t\t     PS3_WRITE_PM_MASK,\n\t\t\t\t\t\t\t     0, 0, &dummy,\n\t\t\t\t\t\t\t     &dummy);\n\t\tlpm_priv->shadow.pm_control = val;\n\t\tbreak;\n\tcase pm_interval:\n\t\tresult = lv1_set_lpm_interval(lpm_priv->lpm_id, val,\n\t\t\t\t\t      PS3_WRITE_PM_MASK, &dummy);\n\t\tbreak;\n\tcase pm_start_stop:\n\t\tif (val != lpm_priv->shadow.pm_start_stop)\n\t\t\tresult = lv1_set_lpm_trigger_control(lpm_priv->lpm_id,\n\t\t\t\t\t\t\t     val,\n\t\t\t\t\t\t\t     PS3_WRITE_PM_MASK,\n\t\t\t\t\t\t\t     &dummy);\n\t\tlpm_priv->shadow.pm_start_stop = val;\n\t\tbreak;\n\tcase trace_address:\n\tcase ext_tr_timer:\n\tcase pm_status:\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(sbd_core(), \"%s:%u: unknown reg: %d\\n\", __func__,\n\t\t\t__LINE__, reg);\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tif (result)\n\t\tdev_err(sbd_core(), \"%s:%u: lv1 set_control failed: \"\n\t\t\t\"reg %u, %s\\n\", __func__, __LINE__, reg,\n\t\t\tps3_result(result));\n}\nEXPORT_SYMBOL_GPL(ps3_write_pm);\n\n \n\nu32 ps3_get_ctr_size(u32 cpu, u32 phys_ctr)\n{\n\tu32 pm_ctrl;\n\n\tif (phys_ctr >= NR_PHYS_CTRS) {\n\t\tdev_dbg(sbd_core(), \"%s:%u: phys_ctr too big: %u\\n\", __func__,\n\t\t\t__LINE__, phys_ctr);\n\t\treturn 0;\n\t}\n\n\tpm_ctrl = ps3_read_pm(cpu, pm_control);\n\treturn (pm_ctrl & CBE_PM_16BIT_CTR(phys_ctr)) ? 16 : 32;\n}\nEXPORT_SYMBOL_GPL(ps3_get_ctr_size);\n\n \n\nvoid ps3_set_ctr_size(u32 cpu, u32 phys_ctr, u32 ctr_size)\n{\n\tu32 pm_ctrl;\n\n\tif (phys_ctr >= NR_PHYS_CTRS) {\n\t\tdev_dbg(sbd_core(), \"%s:%u: phys_ctr too big: %u\\n\", __func__,\n\t\t\t__LINE__, phys_ctr);\n\t\treturn;\n\t}\n\n\tpm_ctrl = ps3_read_pm(cpu, pm_control);\n\n\tswitch (ctr_size) {\n\tcase 16:\n\t\tpm_ctrl |= CBE_PM_16BIT_CTR(phys_ctr);\n\t\tps3_write_pm(cpu, pm_control, pm_ctrl);\n\t\tbreak;\n\n\tcase 32:\n\t\tpm_ctrl &= ~CBE_PM_16BIT_CTR(phys_ctr);\n\t\tps3_write_pm(cpu, pm_control, pm_ctrl);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\nEXPORT_SYMBOL_GPL(ps3_set_ctr_size);\n\nstatic u64 pm_translate_signal_group_number_on_island2(u64 subgroup)\n{\n\n\tif (subgroup == 2)\n\t\tsubgroup = 3;\n\n\tif (subgroup <= 6)\n\t\treturn PM_ISLAND2_BASE_SIGNAL_GROUP_NUMBER + subgroup;\n\telse if (subgroup == 7)\n\t\treturn PM_ISLAND2_SIGNAL_GROUP_NUMBER1;\n\telse\n\t\treturn PM_ISLAND2_SIGNAL_GROUP_NUMBER2;\n}\n\nstatic u64 pm_translate_signal_group_number_on_island3(u64 subgroup)\n{\n\n\tswitch (subgroup) {\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\tsubgroup += 2;\n\t\tbreak;\n\tcase 5:\n\t\tsubgroup = 8;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn PM_ISLAND3_BASE_SIGNAL_GROUP_NUMBER + subgroup;\n}\n\nstatic u64 pm_translate_signal_group_number_on_island4(u64 subgroup)\n{\n\treturn PM_ISLAND4_BASE_SIGNAL_GROUP_NUMBER + subgroup;\n}\n\nstatic u64 pm_translate_signal_group_number_on_island5(u64 subgroup)\n{\n\n\tswitch (subgroup) {\n\tcase 3:\n\t\tsubgroup = 4;\n\t\tbreak;\n\tcase 4:\n\t\tsubgroup = 6;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn PM_ISLAND5_BASE_SIGNAL_GROUP_NUMBER + subgroup;\n}\n\nstatic u64 pm_translate_signal_group_number_on_island6(u64 subgroup,\n\t\t\t\t\t\t       u64 subsubgroup)\n{\n\tswitch (subgroup) {\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\t\tsubgroup += 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (subsubgroup) {\n\tcase 4:\n\tcase 5:\n\tcase 6:\n\t\tsubsubgroup += 2;\n\t\tbreak;\n\tcase 7:\n\tcase 8:\n\tcase 9:\n\tcase 10:\n\t\tsubsubgroup += 4;\n\t\tbreak;\n\tcase 11:\n\tcase 12:\n\tcase 13:\n\t\tsubsubgroup += 5;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (subgroup <= 5)\n\t\treturn (PM_ISLAND6_BASE_SIGNAL_GROUP_NUMBER + subgroup);\n\telse\n\t\treturn (PM_ISLAND6_BASE_SIGNAL_GROUP_NUMBER + subgroup\n\t\t\t+ subsubgroup - 1);\n}\n\nstatic u64 pm_translate_signal_group_number_on_island7(u64 subgroup)\n{\n\treturn PM_ISLAND7_BASE_SIGNAL_GROUP_NUMBER + subgroup;\n}\n\nstatic u64 pm_translate_signal_group_number_on_island8(u64 subgroup)\n{\n\treturn PM_ISLAND8_BASE_SIGNAL_GROUP_NUMBER + subgroup;\n}\n\nstatic u64 pm_signal_group_to_ps3_lv1_signal_group(u64 group)\n{\n\tu64 island;\n\tu64 subgroup;\n\tu64 subsubgroup;\n\n\tsubgroup = 0;\n\tsubsubgroup = 0;\n\tisland = 0;\n\tif (group < 1000) {\n\t\tif (group < 100) {\n\t\t\tif (20 <= group && group < 30) {\n\t\t\t\tisland = 2;\n\t\t\t\tsubgroup = group - 20;\n\t\t\t} else if (30 <= group && group < 40) {\n\t\t\t\tisland = 3;\n\t\t\t\tsubgroup = group - 30;\n\t\t\t} else if (40 <= group && group < 50) {\n\t\t\t\tisland = 4;\n\t\t\t\tsubgroup = group - 40;\n\t\t\t} else if (50 <= group && group < 60) {\n\t\t\t\tisland = 5;\n\t\t\t\tsubgroup = group - 50;\n\t\t\t} else if (60 <= group && group < 70) {\n\t\t\t\tisland = 6;\n\t\t\t\tsubgroup = group - 60;\n\t\t\t} else if (70 <= group && group < 80) {\n\t\t\t\tisland = 7;\n\t\t\t\tsubgroup = group - 70;\n\t\t\t} else if (80 <= group && group < 90) {\n\t\t\t\tisland = 8;\n\t\t\t\tsubgroup = group - 80;\n\t\t\t}\n\t\t} else if (200 <= group && group < 300) {\n\t\t\tisland = 2;\n\t\t\tsubgroup = group - 200;\n\t\t} else if (600 <= group && group < 700) {\n\t\t\tisland = 6;\n\t\t\tsubgroup = 5;\n\t\t\tsubsubgroup = group - 650;\n\t\t}\n\t} else if (6000 <= group && group < 7000) {\n\t\tisland = 6;\n\t\tsubgroup = 5;\n\t\tsubsubgroup = group - 6500;\n\t}\n\n\tswitch (island) {\n\tcase 2:\n\t\treturn pm_translate_signal_group_number_on_island2(subgroup);\n\tcase 3:\n\t\treturn pm_translate_signal_group_number_on_island3(subgroup);\n\tcase 4:\n\t\treturn pm_translate_signal_group_number_on_island4(subgroup);\n\tcase 5:\n\t\treturn pm_translate_signal_group_number_on_island5(subgroup);\n\tcase 6:\n\t\treturn pm_translate_signal_group_number_on_island6(subgroup,\n\t\t\t\t\t\t\t\t   subsubgroup);\n\tcase 7:\n\t\treturn pm_translate_signal_group_number_on_island7(subgroup);\n\tcase 8:\n\t\treturn pm_translate_signal_group_number_on_island8(subgroup);\n\tdefault:\n\t\tdev_dbg(sbd_core(), \"%s:%u: island not found: %llu\\n\", __func__,\n\t\t\t__LINE__, group);\n\t\tBUG();\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic u64 pm_bus_word_to_ps3_lv1_bus_word(u8 word)\n{\n\n\tswitch (word) {\n\tcase 1:\n\t\treturn 0xF000;\n\tcase 2:\n\t\treturn 0x0F00;\n\tcase 4:\n\t\treturn 0x00F0;\n\tcase 8:\n\tdefault:\n\t\treturn 0x000F;\n\t}\n}\n\nstatic int __ps3_set_signal(u64 lv1_signal_group, u64 bus_select,\n\t\t\t    u64 signal_select, u64 attr1, u64 attr2, u64 attr3)\n{\n\tint ret;\n\n\tret = lv1_set_lpm_signal(lpm_priv->lpm_id, lv1_signal_group, bus_select,\n\t\t\t\t signal_select, attr1, attr2, attr3);\n\tif (ret)\n\t\tdev_err(sbd_core(),\n\t\t\t\"%s:%u: error:%d 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx\\n\",\n\t\t\t__func__, __LINE__, ret, lv1_signal_group, bus_select,\n\t\t\tsignal_select, attr1, attr2, attr3);\n\n\treturn ret;\n}\n\nint ps3_set_signal(u64 signal_group, u8 signal_bit, u16 sub_unit,\n\t\t   u8 bus_word)\n{\n\tint ret;\n\tu64 lv1_signal_group;\n\tu64 bus_select;\n\tu64 signal_select;\n\tu64 attr1, attr2, attr3;\n\n\tif (signal_group == 0)\n\t\treturn __ps3_set_signal(0, 0, 0, 0, 0, 0);\n\n\tlv1_signal_group =\n\t\tpm_signal_group_to_ps3_lv1_signal_group(signal_group);\n\tbus_select = pm_bus_word_to_ps3_lv1_bus_word(bus_word);\n\n\tswitch (signal_group) {\n\tcase PM_SIG_GROUP_SPU_TRIGGER:\n\t\tsignal_select = 1;\n\t\tsignal_select = signal_select << (63 - signal_bit);\n\t\tbreak;\n\tcase PM_SIG_GROUP_SPU_EVENT:\n\t\tsignal_select = 1;\n\t\tsignal_select = (signal_select << (63 - signal_bit)) | 0x3;\n\t\tbreak;\n\tdefault:\n\t\tsignal_select = 0;\n\t\tbreak;\n\t}\n\n\t \n\tattr1 = 1;\n\n\t \n\tif (PM_SIG_GROUP_SPU <= signal_group &&\n\t\tsignal_group < PM_SIG_GROUP_MFC_MAX)\n\t\tattr2 = sub_unit;\n\telse\n\t\tattr2 = lpm_priv->pu_id;\n\n\t \n\tattr3 = 0;\n\n\tret = __ps3_set_signal(lv1_signal_group, bus_select, signal_select,\n\t\t\t       attr1, attr2, attr3);\n\tif (ret)\n\t\tdev_err(sbd_core(), \"%s:%u: __ps3_set_signal failed: %d\\n\",\n\t\t\t__func__, __LINE__, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ps3_set_signal);\n\nu32 ps3_get_hw_thread_id(int cpu)\n{\n\treturn get_hard_smp_processor_id(cpu);\n}\nEXPORT_SYMBOL_GPL(ps3_get_hw_thread_id);\n\n \n\nvoid ps3_enable_pm(u32 cpu)\n{\n\tint result;\n\tu64 tmp;\n\tint insert_bookmark = 0;\n\n\tlpm_priv->tb_count = 0;\n\n\tif (use_start_stop_bookmark) {\n\t\tif (!(lpm_priv->shadow.pm_start_stop &\n\t\t\t(PS3_PM_START_STOP_START_MASK\n\t\t\t| PS3_PM_START_STOP_STOP_MASK))) {\n\t\t\tresult = lv1_set_lpm_trigger_control(lpm_priv->lpm_id,\n\t\t\t\t(PS3_PM_START_STOP_PPU_TH0_BOOKMARK_START |\n\t\t\t\tPS3_PM_START_STOP_PPU_TH1_BOOKMARK_START |\n\t\t\t\tPS3_PM_START_STOP_PPU_TH0_BOOKMARK_STOP |\n\t\t\t\tPS3_PM_START_STOP_PPU_TH1_BOOKMARK_STOP),\n\t\t\t\t0xFFFFFFFFFFFFFFFFULL, &tmp);\n\n\t\t\tif (result)\n\t\t\t\tdev_err(sbd_core(), \"%s:%u: \"\n\t\t\t\t\t\"lv1_set_lpm_trigger_control failed: \"\n\t\t\t\t\t\"%s\\n\", __func__, __LINE__,\n\t\t\t\t\tps3_result(result));\n\n\t\t\tinsert_bookmark = !result;\n\t\t}\n\t}\n\n\tresult = lv1_start_lpm(lpm_priv->lpm_id);\n\n\tif (result)\n\t\tdev_err(sbd_core(), \"%s:%u: lv1_start_lpm failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\n\tif (use_start_stop_bookmark && !result && insert_bookmark)\n\t\tps3_set_bookmark(get_tb() | PS3_PM_BOOKMARK_START);\n}\nEXPORT_SYMBOL_GPL(ps3_enable_pm);\n\n \n\nvoid ps3_disable_pm(u32 cpu)\n{\n\tint result;\n\tu64 tmp;\n\n\tps3_set_bookmark(get_tb() | PS3_PM_BOOKMARK_STOP);\n\n\tresult = lv1_stop_lpm(lpm_priv->lpm_id, &tmp);\n\n\tif (result) {\n\t\tif (result != LV1_WRONG_STATE)\n\t\t\tdev_err(sbd_core(), \"%s:%u: lv1_stop_lpm failed: %s\\n\",\n\t\t\t\t__func__, __LINE__, ps3_result(result));\n\t\treturn;\n\t}\n\n\tlpm_priv->tb_count = tmp;\n\n\tdev_dbg(sbd_core(), \"%s:%u: tb_count %llu (%llxh)\\n\", __func__, __LINE__,\n\t\tlpm_priv->tb_count, lpm_priv->tb_count);\n}\nEXPORT_SYMBOL_GPL(ps3_disable_pm);\n\n \n\nint ps3_lpm_copy_tb(unsigned long offset, void *buf, unsigned long count,\n\t\t    unsigned long *bytes_copied)\n{\n\tint result;\n\n\t*bytes_copied = 0;\n\n\tif (!lpm_priv->tb_cache)\n\t\treturn -EPERM;\n\n\tif (offset >= lpm_priv->tb_count)\n\t\treturn 0;\n\n\tcount = min_t(u64, count, lpm_priv->tb_count - offset);\n\n\twhile (*bytes_copied < count) {\n\t\tconst unsigned long request = count - *bytes_copied;\n\t\tu64 tmp;\n\n\t\tresult = lv1_copy_lpm_trace_buffer(lpm_priv->lpm_id, offset,\n\t\t\t\t\t\t   request, &tmp);\n\t\tif (result) {\n\t\t\tdev_dbg(sbd_core(), \"%s:%u: 0x%lx bytes at 0x%lx\\n\",\n\t\t\t\t__func__, __LINE__, request, offset);\n\n\t\t\tdev_err(sbd_core(), \"%s:%u: lv1_copy_lpm_trace_buffer \"\n\t\t\t\t\"failed: %s\\n\", __func__, __LINE__,\n\t\t\t\tps3_result(result));\n\t\t\treturn result == LV1_WRONG_STATE ? -EBUSY : -EINVAL;\n\t\t}\n\n\t\tmemcpy(buf, lpm_priv->tb_cache, tmp);\n\t\tbuf += tmp;\n\t\t*bytes_copied += tmp;\n\t\toffset += tmp;\n\t}\n\tdev_dbg(sbd_core(), \"%s:%u: copied %lxh bytes\\n\", __func__, __LINE__,\n\t\t*bytes_copied);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3_lpm_copy_tb);\n\n \n\nint ps3_lpm_copy_tb_to_user(unsigned long offset, void __user *buf,\n\t\t\t    unsigned long count, unsigned long *bytes_copied)\n{\n\tint result;\n\n\t*bytes_copied = 0;\n\n\tif (!lpm_priv->tb_cache)\n\t\treturn -EPERM;\n\n\tif (offset >= lpm_priv->tb_count)\n\t\treturn 0;\n\n\tcount = min_t(u64, count, lpm_priv->tb_count - offset);\n\n\twhile (*bytes_copied < count) {\n\t\tconst unsigned long request = count - *bytes_copied;\n\t\tu64 tmp;\n\n\t\tresult = lv1_copy_lpm_trace_buffer(lpm_priv->lpm_id, offset,\n\t\t\t\t\t\t   request, &tmp);\n\t\tif (result) {\n\t\t\tdev_dbg(sbd_core(), \"%s:%u: 0x%lx bytes at 0x%lx\\n\",\n\t\t\t\t__func__, __LINE__, request, offset);\n\t\t\tdev_err(sbd_core(), \"%s:%u: lv1_copy_lpm_trace_buffer \"\n\t\t\t\t\"failed: %s\\n\", __func__, __LINE__,\n\t\t\t\tps3_result(result));\n\t\t\treturn result == LV1_WRONG_STATE ? -EBUSY : -EINVAL;\n\t\t}\n\n\t\tresult = copy_to_user(buf, lpm_priv->tb_cache, tmp);\n\n\t\tif (result) {\n\t\t\tdev_dbg(sbd_core(), \"%s:%u: 0x%llx bytes at 0x%p\\n\",\n\t\t\t\t__func__, __LINE__, tmp, buf);\n\t\t\tdev_err(sbd_core(), \"%s:%u: copy_to_user failed: %d\\n\",\n\t\t\t\t__func__, __LINE__, result);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tbuf += tmp;\n\t\t*bytes_copied += tmp;\n\t\toffset += tmp;\n\t}\n\tdev_dbg(sbd_core(), \"%s:%u: copied %lxh bytes\\n\", __func__, __LINE__,\n\t\t*bytes_copied);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3_lpm_copy_tb_to_user);\n\n \n\nu32 ps3_get_and_clear_pm_interrupts(u32 cpu)\n{\n\treturn ps3_read_pm(cpu, pm_status);\n}\nEXPORT_SYMBOL_GPL(ps3_get_and_clear_pm_interrupts);\n\n \n\nvoid ps3_enable_pm_interrupts(u32 cpu, u32 thread, u32 mask)\n{\n\tif (mask)\n\t\tps3_write_pm(cpu, pm_status, mask);\n}\nEXPORT_SYMBOL_GPL(ps3_enable_pm_interrupts);\n\n \n\nvoid ps3_disable_pm_interrupts(u32 cpu)\n{\n\tps3_get_and_clear_pm_interrupts(cpu);\n\tps3_write_pm(cpu, pm_status, 0);\n}\nEXPORT_SYMBOL_GPL(ps3_disable_pm_interrupts);\n\n \n\nint ps3_lpm_open(enum ps3_lpm_tb_type tb_type, void *tb_cache,\n\tu64 tb_cache_size)\n{\n\tint result;\n\tu64 tb_size;\n\n\tBUG_ON(!lpm_priv);\n\tBUG_ON(tb_type != PS3_LPM_TB_TYPE_NONE\n\t\t&& tb_type != PS3_LPM_TB_TYPE_INTERNAL);\n\n\tif (tb_type == PS3_LPM_TB_TYPE_NONE && tb_cache)\n\t\tdev_dbg(sbd_core(), \"%s:%u: bad in vals\\n\", __func__, __LINE__);\n\n\tif (!atomic_add_unless(&lpm_priv->open, 1, 1)) {\n\t\tdev_dbg(sbd_core(), \"%s:%u: busy\\n\", __func__, __LINE__);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\n\tif (tb_type == PS3_LPM_TB_TYPE_NONE) {\n\t\tlpm_priv->tb_cache_size = 0;\n\t\tlpm_priv->tb_cache_internal = NULL;\n\t\tlpm_priv->tb_cache = NULL;\n\t} else if (tb_cache) {\n\t\tif (tb_cache != (void *)ALIGN((unsigned long)tb_cache, 128)\n\t\t\t|| tb_cache_size != ALIGN(tb_cache_size, 128)) {\n\t\t\tdev_err(sbd_core(), \"%s:%u: unaligned tb_cache\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tresult = -EINVAL;\n\t\t\tgoto fail_align;\n\t\t}\n\t\tlpm_priv->tb_cache_size = tb_cache_size;\n\t\tlpm_priv->tb_cache_internal = NULL;\n\t\tlpm_priv->tb_cache = tb_cache;\n\t} else {\n\t\tlpm_priv->tb_cache_size = PS3_LPM_DEFAULT_TB_CACHE_SIZE;\n\t\tlpm_priv->tb_cache_internal = kzalloc(\n\t\t\tlpm_priv->tb_cache_size + 127, GFP_KERNEL);\n\t\tif (!lpm_priv->tb_cache_internal) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto fail_malloc;\n\t\t}\n\t\tlpm_priv->tb_cache = (void *)ALIGN(\n\t\t\t(unsigned long)lpm_priv->tb_cache_internal, 128);\n\t}\n\n\tresult = lv1_construct_lpm(lpm_priv->node_id, tb_type, 0, 0,\n\t\t\t\tps3_mm_phys_to_lpar(__pa(lpm_priv->tb_cache)),\n\t\t\t\tlpm_priv->tb_cache_size, &lpm_priv->lpm_id,\n\t\t\t\t&lpm_priv->outlet_id, &tb_size);\n\n\tif (result) {\n\t\tdev_err(sbd_core(), \"%s:%u: lv1_construct_lpm failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\t\tresult = -EINVAL;\n\t\tgoto fail_construct;\n\t}\n\n\tlpm_priv->shadow.pm_control = PS3_LPM_SHADOW_REG_INIT;\n\tlpm_priv->shadow.pm_start_stop = PS3_LPM_SHADOW_REG_INIT;\n\tlpm_priv->shadow.group_control = PS3_LPM_SHADOW_REG_INIT;\n\tlpm_priv->shadow.debug_bus_control = PS3_LPM_SHADOW_REG_INIT;\n\n\tdev_dbg(sbd_core(), \"%s:%u: lpm_id 0x%llx, outlet_id 0x%llx, \"\n\t\t\"tb_size 0x%llx\\n\", __func__, __LINE__, lpm_priv->lpm_id,\n\t\tlpm_priv->outlet_id, tb_size);\n\n\treturn 0;\n\nfail_construct:\n\tkfree(lpm_priv->tb_cache_internal);\n\tlpm_priv->tb_cache_internal = NULL;\nfail_malloc:\nfail_align:\n\tatomic_dec(&lpm_priv->open);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(ps3_lpm_open);\n\n \n\nint ps3_lpm_close(void)\n{\n\tdev_dbg(sbd_core(), \"%s:%u\\n\", __func__, __LINE__);\n\n\tlv1_destruct_lpm(lpm_priv->lpm_id);\n\tlpm_priv->lpm_id = 0;\n\n\tkfree(lpm_priv->tb_cache_internal);\n\tlpm_priv->tb_cache_internal = NULL;\n\n\tatomic_dec(&lpm_priv->open);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3_lpm_close);\n\nstatic int ps3_lpm_probe(struct ps3_system_bus_device *dev)\n{\n\tdev_dbg(&dev->core, \" -> %s:%u\\n\", __func__, __LINE__);\n\n\tif (lpm_priv) {\n\t\tdev_info(&dev->core, \"%s:%u: called twice\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -EBUSY;\n\t}\n\n\tlpm_priv = kzalloc(sizeof(*lpm_priv), GFP_KERNEL);\n\n\tif (!lpm_priv)\n\t\treturn -ENOMEM;\n\n\tlpm_priv->sbd = dev;\n\tlpm_priv->node_id = dev->lpm.node_id;\n\tlpm_priv->pu_id = dev->lpm.pu_id;\n\tlpm_priv->rights = dev->lpm.rights;\n\n\tdev_info(&dev->core, \" <- %s:%u:\\n\", __func__, __LINE__);\n\n\treturn 0;\n}\n\nstatic void ps3_lpm_remove(struct ps3_system_bus_device *dev)\n{\n\tdev_dbg(&dev->core, \" -> %s:%u:\\n\", __func__, __LINE__);\n\n\tps3_lpm_close();\n\n\tkfree(lpm_priv);\n\tlpm_priv = NULL;\n\n\tdev_info(&dev->core, \" <- %s:%u:\\n\", __func__, __LINE__);\n}\n\nstatic struct ps3_system_bus_driver ps3_lpm_driver = {\n\t.match_id = PS3_MATCH_ID_LPM,\n\t.core.name\t= \"ps3-lpm\",\n\t.core.owner\t= THIS_MODULE,\n\t.probe\t\t= ps3_lpm_probe,\n\t.remove\t\t= ps3_lpm_remove,\n\t.shutdown\t= ps3_lpm_remove,\n};\n\nstatic int __init ps3_lpm_init(void)\n{\n\tpr_debug(\"%s:%d:\\n\", __func__, __LINE__);\n\treturn ps3_system_bus_driver_register(&ps3_lpm_driver);\n}\n\nstatic void __exit ps3_lpm_exit(void)\n{\n\tpr_debug(\"%s:%d:\\n\", __func__, __LINE__);\n\tps3_system_bus_driver_unregister(&ps3_lpm_driver);\n}\n\nmodule_init(ps3_lpm_init);\nmodule_exit(ps3_lpm_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"PS3 Logical Performance Monitor Driver\");\nMODULE_AUTHOR(\"Sony Corporation\");\nMODULE_ALIAS(PS3_MODULE_ALIAS_LPM);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}