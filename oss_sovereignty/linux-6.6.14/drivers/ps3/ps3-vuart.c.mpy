{
  "module_name": "ps3-vuart.c",
  "hash_id": "39f70f3774508f06851cbec4ce97d89117db72323d7bee12ae34881f2bb0c45c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ps3/ps3-vuart.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/bitops.h>\n#include <asm/ps3.h>\n\n#include <asm/firmware.h>\n#include <asm/lv1call.h>\n\n#include \"vuart.h\"\n\nMODULE_AUTHOR(\"Sony Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"PS3 vuart\");\n\n \n\nenum {PORT_COUNT = 3,};\n\nenum vuart_param {\n\tPARAM_TX_TRIGGER = 0,\n\tPARAM_RX_TRIGGER = 1,\n\tPARAM_INTERRUPT_MASK = 2,\n\tPARAM_RX_BUF_SIZE = 3,  \n\tPARAM_RX_BYTES = 4,  \n\tPARAM_TX_BUF_SIZE = 5,  \n\tPARAM_TX_BYTES = 6,  \n\tPARAM_INTERRUPT_STATUS = 7,  \n};\n\nenum vuart_interrupt_bit {\n\tINTERRUPT_BIT_TX = 0,\n\tINTERRUPT_BIT_RX = 1,\n\tINTERRUPT_BIT_DISCONNECT = 2,\n};\n\nenum vuart_interrupt_mask {\n\tINTERRUPT_MASK_TX = 1,\n\tINTERRUPT_MASK_RX = 2,\n\tINTERRUPT_MASK_DISCONNECT = 4,\n};\n\n \n\nstruct ps3_vuart_port_priv {\n\tu64 interrupt_mask;\n\n\tstruct {\n\t\tspinlock_t lock;\n\t\tstruct list_head head;\n\t} tx_list;\n\tstruct {\n\t\tstruct ps3_vuart_work work;\n\t\tunsigned long bytes_held;\n\t\tspinlock_t lock;\n\t\tstruct list_head head;\n\t} rx_list;\n\tstruct ps3_vuart_stats stats;\n};\n\nstatic struct ps3_vuart_port_priv *to_port_priv(\n\tstruct ps3_system_bus_device *dev)\n{\n\tBUG_ON(!dev);\n\tBUG_ON(!dev->driver_priv);\n\treturn (struct ps3_vuart_port_priv *)dev->driver_priv;\n}\n\n \n\nstruct ports_bmp {\n\tu64 status;\n\tu64 unused[3];\n} __attribute__((aligned(32)));\n\n#define dump_ports_bmp(_b) _dump_ports_bmp(_b, __func__, __LINE__)\nstatic void __maybe_unused _dump_ports_bmp(\n\tconst struct ports_bmp *bmp, const char *func, int line)\n{\n\tpr_debug(\"%s:%d: ports_bmp: %016llxh\\n\", func, line, bmp->status);\n}\n\n#define dump_port_params(_b) _dump_port_params(_b, __func__, __LINE__)\nstatic void __maybe_unused _dump_port_params(unsigned int port_number,\n\tconst char *func, int line)\n{\n#if defined(DEBUG)\n\tstatic const char *strings[] = {\n\t\t\"tx_trigger      \",\n\t\t\"rx_trigger      \",\n\t\t\"interrupt_mask  \",\n\t\t\"rx_buf_size     \",\n\t\t\"rx_bytes        \",\n\t\t\"tx_buf_size     \",\n\t\t\"tx_bytes        \",\n\t\t\"interrupt_status\",\n\t};\n\tint result;\n\tunsigned int i;\n\tu64 value;\n\n\tfor (i = 0; i < ARRAY_SIZE(strings); i++) {\n\t\tresult = lv1_get_virtual_uart_param(port_number, i, &value);\n\n\t\tif (result) {\n\t\t\tpr_debug(\"%s:%d: port_%u: %s failed: %s\\n\", func, line,\n\t\t\t\tport_number, strings[i], ps3_result(result));\n\t\t\tcontinue;\n\t\t}\n\t\tpr_debug(\"%s:%d: port_%u: %s = %lxh\\n\",\n\t\t\tfunc, line, port_number, strings[i], value);\n\t}\n#endif\n}\n\nint ps3_vuart_get_triggers(struct ps3_system_bus_device *dev,\n\tstruct vuart_triggers *trig)\n{\n\tint result;\n\tu64 size;\n\tu64 val;\n\tu64 tx;\n\n\tresult = lv1_get_virtual_uart_param(dev->port_number,\n\t\tPARAM_TX_TRIGGER, &tx);\n\ttrig->tx = tx;\n\n\tif (result) {\n\t\tdev_dbg(&dev->core, \"%s:%d: tx_trigger failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\t\treturn result;\n\t}\n\n\tresult = lv1_get_virtual_uart_param(dev->port_number,\n\t\tPARAM_RX_BUF_SIZE, &size);\n\n\tif (result) {\n\t\tdev_dbg(&dev->core, \"%s:%d: tx_buf_size failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\t\treturn result;\n\t}\n\n\tresult = lv1_get_virtual_uart_param(dev->port_number,\n\t\tPARAM_RX_TRIGGER, &val);\n\n\tif (result) {\n\t\tdev_dbg(&dev->core, \"%s:%d: rx_trigger failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\t\treturn result;\n\t}\n\n\ttrig->rx = size - val;\n\n\tdev_dbg(&dev->core, \"%s:%d: tx %lxh, rx %lxh\\n\", __func__, __LINE__,\n\t\ttrig->tx, trig->rx);\n\n\treturn result;\n}\n\nint ps3_vuart_set_triggers(struct ps3_system_bus_device *dev, unsigned int tx,\n\tunsigned int rx)\n{\n\tint result;\n\tu64 size;\n\n\tresult = lv1_set_virtual_uart_param(dev->port_number,\n\t\tPARAM_TX_TRIGGER, tx);\n\n\tif (result) {\n\t\tdev_dbg(&dev->core, \"%s:%d: tx_trigger failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\t\treturn result;\n\t}\n\n\tresult = lv1_get_virtual_uart_param(dev->port_number,\n\t\tPARAM_RX_BUF_SIZE, &size);\n\n\tif (result) {\n\t\tdev_dbg(&dev->core, \"%s:%d: tx_buf_size failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\t\treturn result;\n\t}\n\n\tresult = lv1_set_virtual_uart_param(dev->port_number,\n\t\tPARAM_RX_TRIGGER, size - rx);\n\n\tif (result) {\n\t\tdev_dbg(&dev->core, \"%s:%d: rx_trigger failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\t\treturn result;\n\t}\n\n\tdev_dbg(&dev->core, \"%s:%d: tx %xh, rx %xh\\n\", __func__, __LINE__,\n\t\ttx, rx);\n\n\treturn result;\n}\n\nstatic int ps3_vuart_get_rx_bytes_waiting(struct ps3_system_bus_device *dev,\n\tu64 *bytes_waiting)\n{\n\tint result;\n\n\tresult = lv1_get_virtual_uart_param(dev->port_number,\n\t\tPARAM_RX_BYTES, bytes_waiting);\n\n\tif (result)\n\t\tdev_dbg(&dev->core, \"%s:%d: rx_bytes failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\n\tdev_dbg(&dev->core, \"%s:%d: %llxh\\n\", __func__, __LINE__,\n\t\t*bytes_waiting);\n\treturn result;\n}\n\n \n\nstatic int ps3_vuart_set_interrupt_mask(struct ps3_system_bus_device *dev,\n\tunsigned long mask)\n{\n\tint result;\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\n\tdev_dbg(&dev->core, \"%s:%d: %lxh\\n\", __func__, __LINE__, mask);\n\n\tpriv->interrupt_mask = mask;\n\n\tresult = lv1_set_virtual_uart_param(dev->port_number,\n\t\tPARAM_INTERRUPT_MASK, priv->interrupt_mask);\n\n\tif (result)\n\t\tdev_dbg(&dev->core, \"%s:%d: interrupt_mask failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\n\treturn result;\n}\n\nstatic int ps3_vuart_get_interrupt_status(struct ps3_system_bus_device *dev,\n\tunsigned long *status)\n{\n\tint result;\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\tu64 tmp;\n\n\tresult = lv1_get_virtual_uart_param(dev->port_number,\n\t\tPARAM_INTERRUPT_STATUS, &tmp);\n\n\tif (result)\n\t\tdev_dbg(&dev->core, \"%s:%d: interrupt_status failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\n\t*status = tmp & priv->interrupt_mask;\n\n\tdev_dbg(&dev->core, \"%s:%d: m %llxh, s %llxh, m&s %lxh\\n\",\n\t\t__func__, __LINE__, priv->interrupt_mask, tmp, *status);\n\n\treturn result;\n}\n\nint ps3_vuart_enable_interrupt_tx(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\n\treturn (priv->interrupt_mask & INTERRUPT_MASK_TX) ? 0\n\t\t: ps3_vuart_set_interrupt_mask(dev, priv->interrupt_mask\n\t\t| INTERRUPT_MASK_TX);\n}\n\nint ps3_vuart_enable_interrupt_rx(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\n\treturn (priv->interrupt_mask & INTERRUPT_MASK_RX) ? 0\n\t\t: ps3_vuart_set_interrupt_mask(dev, priv->interrupt_mask\n\t\t| INTERRUPT_MASK_RX);\n}\n\nint ps3_vuart_enable_interrupt_disconnect(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\n\treturn (priv->interrupt_mask & INTERRUPT_MASK_DISCONNECT) ? 0\n\t\t: ps3_vuart_set_interrupt_mask(dev, priv->interrupt_mask\n\t\t| INTERRUPT_MASK_DISCONNECT);\n}\n\nint ps3_vuart_disable_interrupt_tx(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\n\treturn (priv->interrupt_mask & INTERRUPT_MASK_TX)\n\t\t? ps3_vuart_set_interrupt_mask(dev, priv->interrupt_mask\n\t\t& ~INTERRUPT_MASK_TX) : 0;\n}\n\nint ps3_vuart_disable_interrupt_rx(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\n\treturn (priv->interrupt_mask & INTERRUPT_MASK_RX)\n\t\t? ps3_vuart_set_interrupt_mask(dev, priv->interrupt_mask\n\t\t& ~INTERRUPT_MASK_RX) : 0;\n}\n\nint ps3_vuart_disable_interrupt_disconnect(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\n\treturn (priv->interrupt_mask & INTERRUPT_MASK_DISCONNECT)\n\t\t? ps3_vuart_set_interrupt_mask(dev, priv->interrupt_mask\n\t\t& ~INTERRUPT_MASK_DISCONNECT) : 0;\n}\n\n \n\nstatic int ps3_vuart_raw_write(struct ps3_system_bus_device *dev,\n\tconst void *buf, unsigned int bytes, u64 *bytes_written)\n{\n\tint result;\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\n\tresult = lv1_write_virtual_uart(dev->port_number,\n\t\tps3_mm_phys_to_lpar(__pa(buf)), bytes, bytes_written);\n\n\tif (result) {\n\t\tdev_warn(&dev->core, \"%s:%d: lv1_write_virtual_uart failed: \"\n\t\t\t\"%s\\n\", __func__, __LINE__, ps3_result(result));\n\t\treturn result;\n\t}\n\n\tpriv->stats.bytes_written += *bytes_written;\n\n\tdev_dbg(&dev->core, \"%s:%d: wrote %llxh/%xh=>%lxh\\n\", __func__, __LINE__,\n\t\t*bytes_written, bytes, priv->stats.bytes_written);\n\n\treturn result;\n}\n\n \n\nstatic int ps3_vuart_raw_read(struct ps3_system_bus_device *dev, void *buf,\n\tunsigned int bytes, u64 *bytes_read)\n{\n\tint result;\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\n\tdev_dbg(&dev->core, \"%s:%d: %xh\\n\", __func__, __LINE__, bytes);\n\n\tresult = lv1_read_virtual_uart(dev->port_number,\n\t\tps3_mm_phys_to_lpar(__pa(buf)), bytes, bytes_read);\n\n\tif (result) {\n\t\tdev_dbg(&dev->core, \"%s:%d: lv1_read_virtual_uart failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\t\treturn result;\n\t}\n\n\tpriv->stats.bytes_read += *bytes_read;\n\n\tdev_dbg(&dev->core, \"%s:%d: read %llxh/%xh=>%lxh\\n\", __func__, __LINE__,\n\t\t*bytes_read, bytes, priv->stats.bytes_read);\n\n\treturn result;\n}\n\n \n\nvoid ps3_vuart_clear_rx_bytes(struct ps3_system_bus_device *dev,\n\tunsigned int bytes)\n{\n\tint result;\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\tu64 bytes_waiting;\n\tvoid *tmp;\n\n\tresult = ps3_vuart_get_rx_bytes_waiting(dev, &bytes_waiting);\n\n\tBUG_ON(result);\n\n\tbytes = bytes ? min(bytes, (unsigned int)bytes_waiting) : bytes_waiting;\n\n\tdev_dbg(&dev->core, \"%s:%d: %u\\n\", __func__, __LINE__, bytes);\n\n\tif (!bytes)\n\t\treturn;\n\n\t \n\n\tbytes += 128;\n\n\ttmp = kmalloc(bytes, GFP_KERNEL);\n\n\tif (!tmp)\n\t\treturn;\n\n\tps3_vuart_raw_read(dev, tmp, bytes, &bytes_waiting);\n\n\tkfree(tmp);\n\n\t \n\n\tpriv->stats.bytes_read -= bytes_waiting;\n}\nEXPORT_SYMBOL_GPL(ps3_vuart_clear_rx_bytes);\n\n \n\nstruct list_buffer {\n\tstruct list_head link;\n\tconst unsigned char *head;\n\tconst unsigned char *tail;\n\tunsigned long dbg_number;\n\tunsigned char data[];\n};\n\n \n\nint ps3_vuart_write(struct ps3_system_bus_device *dev, const void *buf,\n\tunsigned int bytes)\n{\n\tstatic unsigned long dbg_number;\n\tint result;\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\tunsigned long flags;\n\tstruct list_buffer *lb;\n\n\tdev_dbg(&dev->core, \"%s:%d: %u(%xh) bytes\\n\", __func__, __LINE__,\n\t\tbytes, bytes);\n\n\tspin_lock_irqsave(&priv->tx_list.lock, flags);\n\n\tif (list_empty(&priv->tx_list.head)) {\n\t\tu64 bytes_written;\n\n\t\tresult = ps3_vuart_raw_write(dev, buf, bytes, &bytes_written);\n\n\t\tspin_unlock_irqrestore(&priv->tx_list.lock, flags);\n\n\t\tif (result) {\n\t\t\tdev_dbg(&dev->core,\n\t\t\t\t\"%s:%d: ps3_vuart_raw_write failed\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\treturn result;\n\t\t}\n\n\t\tif (bytes_written == bytes) {\n\t\t\tdev_dbg(&dev->core, \"%s:%d: wrote %xh bytes\\n\",\n\t\t\t\t__func__, __LINE__, bytes);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbytes -= bytes_written;\n\t\tbuf += bytes_written;\n\t} else\n\t\tspin_unlock_irqrestore(&priv->tx_list.lock, flags);\n\n\tlb = kmalloc(sizeof(struct list_buffer) + bytes, GFP_KERNEL);\n\n\tif (!lb)\n\t\treturn -ENOMEM;\n\n\tmemcpy(lb->data, buf, bytes);\n\tlb->head = lb->data;\n\tlb->tail = lb->data + bytes;\n\tlb->dbg_number = ++dbg_number;\n\n\tspin_lock_irqsave(&priv->tx_list.lock, flags);\n\tlist_add_tail(&lb->link, &priv->tx_list.head);\n\tps3_vuart_enable_interrupt_tx(dev);\n\tspin_unlock_irqrestore(&priv->tx_list.lock, flags);\n\n\tdev_dbg(&dev->core, \"%s:%d: queued buf_%lu, %xh bytes\\n\",\n\t\t__func__, __LINE__, lb->dbg_number, bytes);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3_vuart_write);\n\n \n\nstatic int ps3_vuart_queue_rx_bytes(struct ps3_system_bus_device *dev,\n\tu64 *bytes_queued)\n{\n\tstatic unsigned long dbg_number;\n\tint result;\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\tstruct list_buffer *lb;\n\tu64 bytes;\n\n\t*bytes_queued = 0;\n\n\tresult = ps3_vuart_get_rx_bytes_waiting(dev, &bytes);\n\tBUG_ON(result);\n\n\tif (result)\n\t\treturn -EIO;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\t \n\n\tbytes += 128;\n\n\tlb = kmalloc(sizeof(struct list_buffer) + bytes, GFP_ATOMIC);\n\n\tif (!lb)\n\t\treturn -ENOMEM;\n\n\tps3_vuart_raw_read(dev, lb->data, bytes, &bytes);\n\n\tlb->head = lb->data;\n\tlb->tail = lb->data + bytes;\n\tlb->dbg_number = ++dbg_number;\n\n\tlist_add_tail(&lb->link, &priv->rx_list.head);\n\tpriv->rx_list.bytes_held += bytes;\n\n\tdev_dbg(&dev->core, \"%s:%d: buf_%lu: queued %llxh bytes\\n\",\n\t\t__func__, __LINE__, lb->dbg_number, bytes);\n\n\t*bytes_queued = bytes;\n\n\treturn 0;\n}\n\n \n\nint ps3_vuart_read(struct ps3_system_bus_device *dev, void *buf,\n\tunsigned int bytes)\n{\n\tint result;\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\tunsigned long flags;\n\tstruct list_buffer *lb, *n;\n\tunsigned long bytes_read;\n\n\tdev_dbg(&dev->core, \"%s:%d: %u(%xh) bytes\\n\", __func__, __LINE__,\n\t\tbytes, bytes);\n\n\tspin_lock_irqsave(&priv->rx_list.lock, flags);\n\n\t \n\n\twhile (priv->rx_list.bytes_held < bytes) {\n\t\tu64 tmp;\n\n\t\tresult = ps3_vuart_queue_rx_bytes(dev, &tmp);\n\t\tif (result || !tmp) {\n\t\t\tdev_dbg(&dev->core, \"%s:%d: starved for %lxh bytes\\n\",\n\t\t\t\t__func__, __LINE__,\n\t\t\t\tbytes - priv->rx_list.bytes_held);\n\t\t\tspin_unlock_irqrestore(&priv->rx_list.lock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(lb, n, &priv->rx_list.head, link) {\n\t\tbytes_read = min((unsigned int)(lb->tail - lb->head), bytes);\n\n\t\tmemcpy(buf, lb->head, bytes_read);\n\t\tbuf += bytes_read;\n\t\tbytes -= bytes_read;\n\t\tpriv->rx_list.bytes_held -= bytes_read;\n\n\t\tif (bytes_read < lb->tail - lb->head) {\n\t\t\tlb->head += bytes_read;\n\t\t\tdev_dbg(&dev->core, \"%s:%d: buf_%lu: dequeued %lxh \"\n\t\t\t\t\"bytes\\n\", __func__, __LINE__, lb->dbg_number,\n\t\t\t\tbytes_read);\n\t\t\tspin_unlock_irqrestore(&priv->rx_list.lock, flags);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdev_dbg(&dev->core, \"%s:%d: buf_%lu: free, dequeued %lxh \"\n\t\t\t\"bytes\\n\", __func__, __LINE__, lb->dbg_number,\n\t\t\tbytes_read);\n\n\t\tlist_del(&lb->link);\n\t\tkfree(lb);\n\t}\n\n\tspin_unlock_irqrestore(&priv->rx_list.lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3_vuart_read);\n\n \n\nstatic void ps3_vuart_work(struct work_struct *work)\n{\n\tstruct ps3_system_bus_device *dev =\n\t\tps3_vuart_work_to_system_bus_dev(work);\n\tstruct ps3_vuart_port_driver *drv =\n\t\tps3_system_bus_dev_to_vuart_drv(dev);\n\n\tBUG_ON(!drv);\n\tdrv->work(dev);\n}\n\nint ps3_vuart_read_async(struct ps3_system_bus_device *dev, unsigned int bytes)\n{\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\tunsigned long flags;\n\n\tif (priv->rx_list.work.trigger) {\n\t\tdev_dbg(&dev->core, \"%s:%d: warning, multiple calls\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -EAGAIN;\n\t}\n\n\tBUG_ON(!bytes);\n\n\tspin_lock_irqsave(&priv->rx_list.lock, flags);\n\tif (priv->rx_list.bytes_held >= bytes) {\n\t\tdev_dbg(&dev->core, \"%s:%d: schedule_work %xh bytes\\n\",\n\t\t\t__func__, __LINE__, bytes);\n\t\tschedule_work(&priv->rx_list.work.work);\n\t\tspin_unlock_irqrestore(&priv->rx_list.lock, flags);\n\t\treturn 0;\n\t}\n\n\tpriv->rx_list.work.trigger = bytes;\n\tspin_unlock_irqrestore(&priv->rx_list.lock, flags);\n\n\tdev_dbg(&dev->core, \"%s:%d: waiting for %u(%xh) bytes\\n\", __func__,\n\t\t__LINE__, bytes, bytes);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3_vuart_read_async);\n\nvoid ps3_vuart_cancel_async(struct ps3_system_bus_device *dev)\n{\n\tto_port_priv(dev)->rx_list.work.trigger = 0;\n}\nEXPORT_SYMBOL_GPL(ps3_vuart_cancel_async);\n\n \n\nstatic int ps3_vuart_handle_interrupt_tx(struct ps3_system_bus_device *dev)\n{\n\tint result = 0;\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\tunsigned long flags;\n\tstruct list_buffer *lb, *n;\n\tunsigned long bytes_total = 0;\n\n\tdev_dbg(&dev->core, \"%s:%d\\n\", __func__, __LINE__);\n\n\tspin_lock_irqsave(&priv->tx_list.lock, flags);\n\n\tlist_for_each_entry_safe(lb, n, &priv->tx_list.head, link) {\n\n\t\tu64 bytes_written;\n\n\t\tresult = ps3_vuart_raw_write(dev, lb->head, lb->tail - lb->head,\n\t\t\t&bytes_written);\n\n\t\tif (result) {\n\t\t\tdev_dbg(&dev->core,\n\t\t\t\t\"%s:%d: ps3_vuart_raw_write failed\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes_total += bytes_written;\n\n\t\tif (bytes_written < lb->tail - lb->head) {\n\t\t\tlb->head += bytes_written;\n\t\t\tdev_dbg(&dev->core,\n\t\t\t\t\"%s:%d cleared buf_%lu, %llxh bytes\\n\",\n\t\t\t\t__func__, __LINE__, lb->dbg_number,\n\t\t\t\tbytes_written);\n\t\t\tgoto port_full;\n\t\t}\n\n\t\tdev_dbg(&dev->core, \"%s:%d free buf_%lu\\n\", __func__, __LINE__,\n\t\t\tlb->dbg_number);\n\n\t\tlist_del(&lb->link);\n\t\tkfree(lb);\n\t}\n\n\tps3_vuart_disable_interrupt_tx(dev);\nport_full:\n\tspin_unlock_irqrestore(&priv->tx_list.lock, flags);\n\tdev_dbg(&dev->core, \"%s:%d wrote %lxh bytes total\\n\",\n\t\t__func__, __LINE__, bytes_total);\n\treturn result;\n}\n\n \n\nstatic int ps3_vuart_handle_interrupt_rx(struct ps3_system_bus_device *dev)\n{\n\tint result;\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\tunsigned long flags;\n\tu64 bytes;\n\n\tdev_dbg(&dev->core, \"%s:%d\\n\", __func__, __LINE__);\n\n\tspin_lock_irqsave(&priv->rx_list.lock, flags);\n\tresult = ps3_vuart_queue_rx_bytes(dev, &bytes);\n\n\tif (result) {\n\t\tspin_unlock_irqrestore(&priv->rx_list.lock, flags);\n\t\treturn result;\n\t}\n\n\tif (priv->rx_list.work.trigger && priv->rx_list.bytes_held\n\t\t>= priv->rx_list.work.trigger) {\n\t\tdev_dbg(&dev->core, \"%s:%d: schedule_work %lxh bytes\\n\",\n\t\t\t__func__, __LINE__, priv->rx_list.work.trigger);\n\t\tpriv->rx_list.work.trigger = 0;\n\t\tschedule_work(&priv->rx_list.work.work);\n\t}\n\n\tspin_unlock_irqrestore(&priv->rx_list.lock, flags);\n\treturn result;\n}\n\nstatic int ps3_vuart_handle_interrupt_disconnect(\n\tstruct ps3_system_bus_device *dev)\n{\n\tdev_dbg(&dev->core, \"%s:%d\\n\", __func__, __LINE__);\n\tBUG_ON(\"no support\");\n\treturn -1;\n}\n\n \n\nstatic int ps3_vuart_handle_port_interrupt(struct ps3_system_bus_device *dev)\n{\n\tint result;\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\tunsigned long status;\n\n\tresult = ps3_vuart_get_interrupt_status(dev, &status);\n\n\tif (result)\n\t\treturn result;\n\n\tdev_dbg(&dev->core, \"%s:%d: status: %lxh\\n\", __func__, __LINE__,\n\t\tstatus);\n\n\tif (status & INTERRUPT_MASK_DISCONNECT) {\n\t\tpriv->stats.disconnect_interrupts++;\n\t\tresult = ps3_vuart_handle_interrupt_disconnect(dev);\n\t\tif (result)\n\t\t\tps3_vuart_disable_interrupt_disconnect(dev);\n\t}\n\n\tif (status & INTERRUPT_MASK_TX) {\n\t\tpriv->stats.tx_interrupts++;\n\t\tresult = ps3_vuart_handle_interrupt_tx(dev);\n\t\tif (result)\n\t\t\tps3_vuart_disable_interrupt_tx(dev);\n\t}\n\n\tif (status & INTERRUPT_MASK_RX) {\n\t\tpriv->stats.rx_interrupts++;\n\t\tresult = ps3_vuart_handle_interrupt_rx(dev);\n\t\tif (result)\n\t\t\tps3_vuart_disable_interrupt_rx(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic struct vuart_bus_priv {\n\tstruct ports_bmp *bmp;\n\tunsigned int virq;\n\tstruct mutex probe_mutex;\n\tint use_count;\n\tstruct ps3_system_bus_device *devices[PORT_COUNT];\n} vuart_bus_priv;\n\n \n\nstatic irqreturn_t ps3_vuart_irq_handler(int irq, void *_private)\n{\n\tstruct vuart_bus_priv *bus_priv = _private;\n\n\tBUG_ON(!bus_priv);\n\n\twhile (1) {\n\t\tunsigned int port;\n\n\t\tdump_ports_bmp(bus_priv->bmp);\n\n\t\tport = (BITS_PER_LONG - 1) - __ilog2(bus_priv->bmp->status);\n\n\t\tif (port == BITS_PER_LONG)\n\t\t\tbreak;\n\n\t\tBUG_ON(port >= PORT_COUNT);\n\t\tBUG_ON(!bus_priv->devices[port]);\n\n\t\tps3_vuart_handle_port_interrupt(bus_priv->devices[port]);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ps3_vuart_bus_interrupt_get(void)\n{\n\tint result;\n\n\tpr_debug(\" -> %s:%d\\n\", __func__, __LINE__);\n\n\tvuart_bus_priv.use_count++;\n\n\tBUG_ON(vuart_bus_priv.use_count > 2);\n\n\tif (vuart_bus_priv.use_count != 1)\n\t\treturn 0;\n\n\tBUG_ON(vuart_bus_priv.bmp);\n\n\tvuart_bus_priv.bmp = kzalloc(sizeof(struct ports_bmp), GFP_KERNEL);\n\n\tif (!vuart_bus_priv.bmp) {\n\t\tresult = -ENOMEM;\n\t\tgoto fail_bmp_malloc;\n\t}\n\n\tresult = ps3_vuart_irq_setup(PS3_BINDING_CPU_ANY, vuart_bus_priv.bmp,\n\t\t&vuart_bus_priv.virq);\n\n\tif (result) {\n\t\tpr_debug(\"%s:%d: ps3_vuart_irq_setup failed (%d)\\n\",\n\t\t\t__func__, __LINE__, result);\n\t\tresult = -EPERM;\n\t\tgoto fail_alloc_irq;\n\t}\n\n\tresult = request_irq(vuart_bus_priv.virq, ps3_vuart_irq_handler,\n\t\t0, \"vuart\", &vuart_bus_priv);\n\n\tif (result) {\n\t\tpr_debug(\"%s:%d: request_irq failed (%d)\\n\",\n\t\t\t__func__, __LINE__, result);\n\t\tgoto fail_request_irq;\n\t}\n\n\tpr_debug(\" <- %s:%d: ok\\n\", __func__, __LINE__);\n\treturn result;\n\nfail_request_irq:\n\tps3_vuart_irq_destroy(vuart_bus_priv.virq);\n\tvuart_bus_priv.virq = 0;\nfail_alloc_irq:\n\tkfree(vuart_bus_priv.bmp);\n\tvuart_bus_priv.bmp = NULL;\nfail_bmp_malloc:\n\tvuart_bus_priv.use_count--;\n\tpr_debug(\" <- %s:%d: failed\\n\", __func__, __LINE__);\n\treturn result;\n}\n\nstatic int ps3_vuart_bus_interrupt_put(void)\n{\n\tpr_debug(\" -> %s:%d\\n\", __func__, __LINE__);\n\n\tvuart_bus_priv.use_count--;\n\n\tBUG_ON(vuart_bus_priv.use_count < 0);\n\n\tif (vuart_bus_priv.use_count != 0)\n\t\treturn 0;\n\n\tfree_irq(vuart_bus_priv.virq, &vuart_bus_priv);\n\n\tps3_vuart_irq_destroy(vuart_bus_priv.virq);\n\tvuart_bus_priv.virq = 0;\n\n\tkfree(vuart_bus_priv.bmp);\n\tvuart_bus_priv.bmp = NULL;\n\n\tpr_debug(\" <- %s:%d\\n\", __func__, __LINE__);\n\treturn 0;\n}\n\nstatic int ps3_vuart_probe(struct ps3_system_bus_device *dev)\n{\n\tint result;\n\tstruct ps3_vuart_port_driver *drv;\n\tstruct ps3_vuart_port_priv *priv = NULL;\n\n\tdev_dbg(&dev->core, \"%s:%d\\n\", __func__, __LINE__);\n\n\tdrv = ps3_system_bus_dev_to_vuart_drv(dev);\n\tBUG_ON(!drv);\n\n\tdev_dbg(&dev->core, \"%s:%d: (%s)\\n\", __func__, __LINE__,\n\t\tdrv->core.core.name);\n\n\tif (dev->port_number >= PORT_COUNT) {\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&vuart_bus_priv.probe_mutex);\n\n\tresult = ps3_vuart_bus_interrupt_get();\n\n\tif (result)\n\t\tgoto fail_setup_interrupt;\n\n\tif (vuart_bus_priv.devices[dev->port_number]) {\n\t\tdev_dbg(&dev->core, \"%s:%d: port busy (%d)\\n\", __func__,\n\t\t\t__LINE__, dev->port_number);\n\t\tresult = -EBUSY;\n\t\tgoto fail_busy;\n\t}\n\n\tvuart_bus_priv.devices[dev->port_number] = dev;\n\n\t \n\n\tdev->driver_priv = kzalloc(sizeof(struct ps3_vuart_port_priv),\n\t\tGFP_KERNEL);\n\n\tif (!dev->driver_priv) {\n\t\tresult = -ENOMEM;\n\t\tgoto fail_dev_malloc;\n\t}\n\n\tpriv = to_port_priv(dev);\n\n\tINIT_LIST_HEAD(&priv->tx_list.head);\n\tspin_lock_init(&priv->tx_list.lock);\n\n\tINIT_LIST_HEAD(&priv->rx_list.head);\n\tspin_lock_init(&priv->rx_list.lock);\n\n\tINIT_WORK(&priv->rx_list.work.work, ps3_vuart_work);\n\tpriv->rx_list.work.trigger = 0;\n\tpriv->rx_list.work.dev = dev;\n\n\t \n\n\tps3_vuart_clear_rx_bytes(dev, 0);\n\n\tps3_vuart_set_interrupt_mask(dev, INTERRUPT_MASK_RX);\n\n\tps3_vuart_set_triggers(dev, 1, 1);\n\n\tif (drv->probe)\n\t\tresult = drv->probe(dev);\n\telse {\n\t\tresult = 0;\n\t\tdev_info(&dev->core, \"%s:%d: no probe method\\n\", __func__,\n\t\t\t__LINE__);\n\t}\n\n\tif (result) {\n\t\tdev_dbg(&dev->core, \"%s:%d: drv->probe failed\\n\",\n\t\t\t__func__, __LINE__);\n\t\tgoto fail_probe;\n\t}\n\n\tmutex_unlock(&vuart_bus_priv.probe_mutex);\n\n\treturn result;\n\nfail_probe:\n\tps3_vuart_set_interrupt_mask(dev, 0);\n\tkfree(dev->driver_priv);\n\tdev->driver_priv = NULL;\nfail_dev_malloc:\n\tvuart_bus_priv.devices[dev->port_number] = NULL;\nfail_busy:\n\tps3_vuart_bus_interrupt_put();\nfail_setup_interrupt:\n\tmutex_unlock(&vuart_bus_priv.probe_mutex);\n\tdev_dbg(&dev->core, \"%s:%d: failed\\n\", __func__, __LINE__);\n\treturn result;\n}\n\n \n\nstatic int ps3_vuart_cleanup(struct ps3_system_bus_device *dev)\n{\n\tdev_dbg(&dev->core, \"%s:%d\\n\", __func__, __LINE__);\n\n\tps3_vuart_cancel_async(dev);\n\tps3_vuart_set_interrupt_mask(dev, 0);\n\tps3_vuart_bus_interrupt_put();\n\treturn 0;\n}\n\n \n\nstatic void ps3_vuart_remove(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\n\tstruct ps3_vuart_port_driver *drv;\n\n\tBUG_ON(!dev);\n\n\tmutex_lock(&vuart_bus_priv.probe_mutex);\n\n\tdev_dbg(&dev->core, \" -> %s:%d: match_id %d\\n\", __func__, __LINE__,\n\t\tdev->match_id);\n\n\tif (!dev->core.driver) {\n\t\tdev_dbg(&dev->core, \"%s:%d: no driver bound\\n\", __func__,\n\t\t\t__LINE__);\n\t\tmutex_unlock(&vuart_bus_priv.probe_mutex);\n\t\treturn;\n\t}\n\n\tdrv = ps3_system_bus_dev_to_vuart_drv(dev);\n\n\tBUG_ON(!drv);\n\n\tif (drv->remove) {\n\t\tdrv->remove(dev);\n\t} else {\n\t\tdev_dbg(&dev->core, \"%s:%d: no remove method\\n\", __func__,\n\t\t__LINE__);\n\t\tBUG();\n\t}\n\n\tps3_vuart_cleanup(dev);\n\n\tvuart_bus_priv.devices[dev->port_number] = NULL;\n\tkfree(priv);\n\tpriv = NULL;\n\n\tdev_dbg(&dev->core, \" <- %s:%d\\n\", __func__, __LINE__);\n\tmutex_unlock(&vuart_bus_priv.probe_mutex);\n}\n\n \n\nstatic void ps3_vuart_shutdown(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3_vuart_port_driver *drv;\n\n\tBUG_ON(!dev);\n\n\tmutex_lock(&vuart_bus_priv.probe_mutex);\n\n\tdev_dbg(&dev->core, \" -> %s:%d: match_id %d\\n\", __func__, __LINE__,\n\t\tdev->match_id);\n\n\tif (!dev->core.driver) {\n\t\tdev_dbg(&dev->core, \"%s:%d: no driver bound\\n\", __func__,\n\t\t\t__LINE__);\n\t\tmutex_unlock(&vuart_bus_priv.probe_mutex);\n\t\treturn;\n\t}\n\n\tdrv = ps3_system_bus_dev_to_vuart_drv(dev);\n\n\tBUG_ON(!drv);\n\n\tif (drv->shutdown)\n\t\tdrv->shutdown(dev);\n\telse if (drv->remove) {\n\t\tdev_dbg(&dev->core, \"%s:%d: no shutdown, calling remove\\n\",\n\t\t\t__func__, __LINE__);\n\t\tdrv->remove(dev);\n\t} else {\n\t\tdev_dbg(&dev->core, \"%s:%d: no shutdown method\\n\", __func__,\n\t\t\t__LINE__);\n\t\tBUG();\n\t}\n\n\tps3_vuart_cleanup(dev);\n\n\tdev_dbg(&dev->core, \" <- %s:%d\\n\", __func__, __LINE__);\n\n\tmutex_unlock(&vuart_bus_priv.probe_mutex);\n}\n\nstatic int __init ps3_vuart_bus_init(void)\n{\n\tpr_debug(\"%s:%d:\\n\", __func__, __LINE__);\n\n\tif (!firmware_has_feature(FW_FEATURE_PS3_LV1))\n\t\treturn -ENODEV;\n\n\tmutex_init(&vuart_bus_priv.probe_mutex);\n\n\treturn 0;\n}\n\nstatic void __exit ps3_vuart_bus_exit(void)\n{\n\tpr_debug(\"%s:%d:\\n\", __func__, __LINE__);\n}\n\ncore_initcall(ps3_vuart_bus_init);\nmodule_exit(ps3_vuart_bus_exit);\n\n \n\nint ps3_vuart_port_driver_register(struct ps3_vuart_port_driver *drv)\n{\n\tint result;\n\n\tpr_debug(\"%s:%d: (%s)\\n\", __func__, __LINE__, drv->core.core.name);\n\n\tBUG_ON(!drv->core.match_id);\n\tBUG_ON(!drv->core.core.name);\n\n\tdrv->core.probe = ps3_vuart_probe;\n\tdrv->core.remove = ps3_vuart_remove;\n\tdrv->core.shutdown = ps3_vuart_shutdown;\n\n\tresult = ps3_system_bus_driver_register(&drv->core);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(ps3_vuart_port_driver_register);\n\n \n\nvoid ps3_vuart_port_driver_unregister(struct ps3_vuart_port_driver *drv)\n{\n\tpr_debug(\"%s:%d: (%s)\\n\", __func__, __LINE__, drv->core.core.name);\n\tps3_system_bus_driver_unregister(&drv->core);\n}\nEXPORT_SYMBOL_GPL(ps3_vuart_port_driver_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}