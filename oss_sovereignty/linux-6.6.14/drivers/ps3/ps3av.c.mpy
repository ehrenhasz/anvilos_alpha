{
  "module_name": "ps3av.c",
  "hash_id": "7116a05bc0225e65bd100f61c15adaa90e842d240231cab77fedfbec4e99c4e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ps3/ps3av.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/ioctl.h>\n#include <linux/slab.h>\n\n#include <asm/firmware.h>\n#include <asm/ps3av.h>\n#include <asm/ps3.h>\n\n#include <video/cmdline.h>\n\n#include \"vuart.h\"\n\n#define BUFSIZE          4096\t \n#define PS3AV_BUF_SIZE   512\t \n\nstatic int safe_mode;\n\nstatic int timeout = 5000;\t \nmodule_param(timeout, int, 0644);\n\nstatic struct ps3av {\n\tstruct mutex mutex;\n\tstruct work_struct work;\n\tstruct completion done;\n\tint open_count;\n\tstruct ps3_system_bus_device *dev;\n\n\tint region;\n\tstruct ps3av_pkt_av_get_hw_conf av_hw_conf;\n\tu32 av_port[PS3AV_AV_PORT_MAX + PS3AV_OPT_PORT_MAX];\n\tu32 opt_port[PS3AV_OPT_PORT_MAX];\n\tu32 head[PS3AV_HEAD_MAX];\n\tu32 audio_port;\n\tint ps3av_mode;\n\tint ps3av_mode_old;\n\tunion {\n\t\tstruct ps3av_reply_hdr reply_hdr;\n\t\tu8 raw[PS3AV_BUF_SIZE];\n\t} recv_buf;\n} *ps3av;\n\n \n#define YUV444 PS3AV_CMD_VIDEO_CS_YUV444_8\n#define RGB8   PS3AV_CMD_VIDEO_CS_RGB_8\n \n#define XRGB   PS3AV_CMD_VIDEO_FMT_X8R8G8B8\n \n#define A_N    PS3AV_CMD_AV_ASPECT_4_3\n#define A_W    PS3AV_CMD_AV_ASPECT_16_9\nstatic const struct avset_video_mode {\n\tu32 cs;\n\tu32 fmt;\n\tu32 vid;\n\tu32 aspect;\n\tu32 x;\n\tu32 y;\n} video_mode_table[] = {\n\t{     0, },  \n\t{YUV444, XRGB, PS3AV_CMD_VIDEO_VID_480I,       A_N,  720,  480},\n\t{YUV444, XRGB, PS3AV_CMD_VIDEO_VID_480P,       A_N,  720,  480},\n\t{YUV444, XRGB, PS3AV_CMD_VIDEO_VID_720P_60HZ,  A_W, 1280,  720},\n\t{YUV444, XRGB, PS3AV_CMD_VIDEO_VID_1080I_60HZ, A_W, 1920, 1080},\n\t{YUV444, XRGB, PS3AV_CMD_VIDEO_VID_1080P_60HZ, A_W, 1920, 1080},\n\t{YUV444, XRGB, PS3AV_CMD_VIDEO_VID_576I,       A_N,  720,  576},\n\t{YUV444, XRGB, PS3AV_CMD_VIDEO_VID_576P,       A_N,  720,  576},\n\t{YUV444, XRGB, PS3AV_CMD_VIDEO_VID_720P_50HZ,  A_W, 1280,  720},\n\t{YUV444, XRGB, PS3AV_CMD_VIDEO_VID_1080I_50HZ, A_W, 1920, 1080},\n\t{YUV444, XRGB, PS3AV_CMD_VIDEO_VID_1080P_50HZ, A_W, 1920, 1080},\n\t{  RGB8, XRGB, PS3AV_CMD_VIDEO_VID_WXGA,       A_W, 1280,  768},\n\t{  RGB8, XRGB, PS3AV_CMD_VIDEO_VID_SXGA,       A_N, 1280, 1024},\n\t{  RGB8, XRGB, PS3AV_CMD_VIDEO_VID_WUXGA,      A_W, 1920, 1200},\n};\n\n \nstatic u32 cmd_table[] = {\n\t \n\tPS3AV_CID_AV_INIT,\n\tPS3AV_CID_AV_FIN,\n\tPS3AV_CID_VIDEO_INIT,\n\tPS3AV_CID_AUDIO_INIT,\n\n\t \n\tPS3AV_CID_AV_ENABLE_EVENT,\n\tPS3AV_CID_AV_DISABLE_EVENT,\n\n\tPS3AV_CID_AV_VIDEO_CS,\n\tPS3AV_CID_AV_VIDEO_MUTE,\n\tPS3AV_CID_AV_VIDEO_DISABLE_SIG,\n\tPS3AV_CID_AV_AUDIO_PARAM,\n\tPS3AV_CID_AV_AUDIO_MUTE,\n\tPS3AV_CID_AV_HDMI_MODE,\n\tPS3AV_CID_AV_TV_MUTE,\n\n\tPS3AV_CID_VIDEO_MODE,\n\tPS3AV_CID_VIDEO_FORMAT,\n\tPS3AV_CID_VIDEO_PITCH,\n\n\tPS3AV_CID_AUDIO_MODE,\n\tPS3AV_CID_AUDIO_MUTE,\n\tPS3AV_CID_AUDIO_ACTIVE,\n\tPS3AV_CID_AUDIO_INACTIVE,\n\tPS3AV_CID_AVB_PARAM,\n\n\t \n\tPS3AV_CID_AV_GET_HW_CONF,\n\tPS3AV_CID_AV_GET_MONITOR_INFO,\n\n\t \n\tPS3AV_CID_EVENT_UNPLUGGED,\n\tPS3AV_CID_EVENT_PLUGGED,\n\tPS3AV_CID_EVENT_HDCP_DONE,\n\tPS3AV_CID_EVENT_HDCP_FAIL,\n\tPS3AV_CID_EVENT_HDCP_AUTH,\n\tPS3AV_CID_EVENT_HDCP_ERROR,\n\n\t0\n};\n\n#define PS3AV_EVENT_CMD_MASK           0x10000000\n#define PS3AV_EVENT_ID_MASK            0x0000ffff\n#define PS3AV_CID_MASK                 0xffffffff\n#define PS3AV_REPLY_BIT                0x80000000\n\n#define ps3av_event_get_port_id(cid)   ((cid >> 16) & 0xff)\n\nstatic u32 *ps3av_search_cmd_table(u32 cid, u32 mask)\n{\n\tu32 *table;\n\tint i;\n\n\ttable = cmd_table;\n\tfor (i = 0;; table++, i++) {\n\t\tif ((*table & mask) == (cid & mask))\n\t\t\tbreak;\n\t\tif (*table == 0)\n\t\t\treturn NULL;\n\t}\n\treturn table;\n}\n\nstatic int ps3av_parse_event_packet(const struct ps3av_reply_hdr *hdr)\n{\n\tu32 *table;\n\n\tif (hdr->cid & PS3AV_EVENT_CMD_MASK) {\n\t\ttable = ps3av_search_cmd_table(hdr->cid, PS3AV_EVENT_CMD_MASK);\n\t\tif (table)\n\t\t\tdev_dbg(&ps3av->dev->core,\n\t\t\t\t\"recv event packet cid:%08x port:0x%x size:%d\\n\",\n\t\t\t\thdr->cid, ps3av_event_get_port_id(hdr->cid),\n\t\t\t\thdr->size);\n\t\telse\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"%s: failed event packet, cid:%08x size:%d\\n\",\n\t\t\t       __func__, hdr->cid, hdr->size);\n\t\treturn 1;\t \n\t}\n\treturn 0;\n}\n\n\n#define POLLING_INTERVAL  25\t \n\nstatic int ps3av_vuart_write(struct ps3_system_bus_device *dev,\n\t\t\t     const void *buf, unsigned long size)\n{\n\tint error;\n\tdev_dbg(&dev->core, \" -> %s:%d\\n\", __func__, __LINE__);\n\terror = ps3_vuart_write(dev, buf, size);\n\tdev_dbg(&dev->core, \" <- %s:%d\\n\", __func__, __LINE__);\n\treturn error ? error : size;\n}\n\nstatic int ps3av_vuart_read(struct ps3_system_bus_device *dev, void *buf,\n\t\t\t    unsigned long size, int timeout)\n{\n\tint error;\n\tint loopcnt = 0;\n\n\tdev_dbg(&dev->core, \" -> %s:%d\\n\", __func__, __LINE__);\n\ttimeout = (timeout + POLLING_INTERVAL - 1) / POLLING_INTERVAL;\n\twhile (loopcnt++ <= timeout) {\n\t\terror = ps3_vuart_read(dev, buf, size);\n\t\tif (!error)\n\t\t\treturn size;\n\t\tif (error != -EAGAIN) {\n\t\t\tprintk(KERN_ERR \"%s: ps3_vuart_read failed %d\\n\",\n\t\t\t       __func__, error);\n\t\t\treturn error;\n\t\t}\n\t\tmsleep(POLLING_INTERVAL);\n\t}\n\treturn -EWOULDBLOCK;\n}\n\nstatic int ps3av_send_cmd_pkt(const struct ps3av_send_hdr *send_buf,\n\t\t\t      struct ps3av_reply_hdr *recv_buf, int write_len,\n\t\t\t      int read_len)\n{\n\tint res;\n\tu32 cmd;\n\tint event;\n\n\tif (!ps3av)\n\t\treturn -ENODEV;\n\n\t \n\tres = ps3av_vuart_write(ps3av->dev, send_buf, write_len);\n\tif (res < 0) {\n\t\tdev_warn(&ps3av->dev->core,\n\t\t\t\"%s:%d: ps3av_vuart_write() failed: %s\\n\", __func__,\n\t\t\t__LINE__, ps3_result(res));\n\t\treturn res;\n\t}\n\n\t \n\tcmd = send_buf->cid;\n\tdo {\n\t\t \n\t\tres = ps3av_vuart_read(ps3av->dev, recv_buf, PS3AV_HDR_SIZE,\n\t\t\t\t       timeout);\n\t\tif (res != PS3AV_HDR_SIZE) {\n\t\t\tdev_warn(&ps3av->dev->core,\n\t\t\t\t\"%s:%d: ps3av_vuart_read() failed: %s\\n\", __func__,\n\t\t\t\t__LINE__, ps3_result(res));\n\t\t\treturn res;\n\t\t}\n\n\t\t \n\t\tres = ps3av_vuart_read(ps3av->dev, &recv_buf->cid,\n\t\t\t\t       recv_buf->size, timeout);\n\t\tif (res < 0) {\n\t\t\tdev_warn(&ps3av->dev->core,\n\t\t\t\t\"%s:%d: ps3av_vuart_read() failed: %s\\n\", __func__,\n\t\t\t\t__LINE__, ps3_result(res));\n\t\t\treturn res;\n\t\t}\n\t\tres += PS3AV_HDR_SIZE;\t \n\t\tevent = ps3av_parse_event_packet(recv_buf);\n\t\t \n\t} while (event);\n\n\tif ((cmd | PS3AV_REPLY_BIT) != recv_buf->cid) {\n\t\tdev_warn(&ps3av->dev->core, \"%s:%d: reply err: %x\\n\", __func__,\n\t\t\t__LINE__, recv_buf->cid);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ps3av_process_reply_packet(struct ps3av_send_hdr *cmd_buf,\n\t\t\t\t      const struct ps3av_reply_hdr *recv_buf,\n\t\t\t\t      int user_buf_size)\n{\n\tint return_len;\n\n\tif (recv_buf->version != PS3AV_VERSION) {\n\t\tdev_dbg(&ps3av->dev->core, \"reply_packet invalid version:%x\\n\",\n\t\t\trecv_buf->version);\n\t\treturn -EFAULT;\n\t}\n\treturn_len = recv_buf->size + PS3AV_HDR_SIZE;\n\tif (return_len > user_buf_size)\n\t\treturn_len = user_buf_size;\n\tmemcpy(cmd_buf, recv_buf, return_len);\n\treturn 0;\t\t \n}\n\nvoid ps3av_set_hdr(u32 cid, u16 size, struct ps3av_send_hdr *hdr)\n{\n\thdr->version = PS3AV_VERSION;\n\thdr->size = size - PS3AV_HDR_SIZE;\n\thdr->cid = cid;\n}\n\nint ps3av_do_pkt(u32 cid, u16 send_len, size_t usr_buf_size,\n\t\t struct ps3av_send_hdr *buf)\n{\n\tint res = 0;\n\tu32 *table;\n\n\tBUG_ON(!ps3av);\n\n\tmutex_lock(&ps3av->mutex);\n\n\ttable = ps3av_search_cmd_table(cid, PS3AV_CID_MASK);\n\tBUG_ON(!table);\n\tBUG_ON(send_len < PS3AV_HDR_SIZE);\n\tBUG_ON(usr_buf_size < send_len);\n\tBUG_ON(usr_buf_size > PS3AV_BUF_SIZE);\n\n\t \n\tps3av_set_hdr(cid, send_len, buf);\n\n\t \n\tres = ps3av_send_cmd_pkt(buf, &ps3av->recv_buf.reply_hdr, send_len,\n\t\t\t\t usr_buf_size);\n\tif (res < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: ps3av_send_cmd_pkt() failed (result=%d)\\n\",\n\t\t       __func__, res);\n\t\tgoto err;\n\t}\n\n\t \n\tres = ps3av_process_reply_packet(buf, &ps3av->recv_buf.reply_hdr,\n\t\t\t\t\t usr_buf_size);\n\tif (res < 0) {\n\t\tprintk(KERN_ERR \"%s: put_return_status() failed (result=%d)\\n\",\n\t\t       __func__, res);\n\t\tgoto err;\n\t}\n\n\tmutex_unlock(&ps3av->mutex);\n\treturn 0;\n\nerr:\n\tmutex_unlock(&ps3av->mutex);\n\tprintk(KERN_ERR \"%s: failed cid:%x res:%d\\n\", __func__, cid, res);\n\treturn res;\n}\n\nstatic int ps3av_set_av_video_mute(u32 mute)\n{\n\tint i, num_of_av_port, res;\n\n\tnum_of_av_port = ps3av->av_hw_conf.num_of_hdmi +\n\t\t\t ps3av->av_hw_conf.num_of_avmulti;\n\t \n\tfor (i = 0; i < num_of_av_port; i++) {\n\t\tres = ps3av_cmd_av_video_mute(1, &ps3av->av_port[i], mute);\n\t\tif (res < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ps3av_set_video_disable_sig(void)\n{\n\tint i, num_of_hdmi_port, num_of_av_port, res;\n\n\tnum_of_hdmi_port = ps3av->av_hw_conf.num_of_hdmi;\n\tnum_of_av_port = ps3av->av_hw_conf.num_of_hdmi +\n\t\t\t ps3av->av_hw_conf.num_of_avmulti;\n\n\t \n\tfor (i = 0; i < num_of_hdmi_port; i++) {\n\t\tres = ps3av_cmd_av_tv_mute(ps3av->av_port[i],\n\t\t\t\t\t   PS3AV_CMD_MUTE_ON);\n\t\tif (res < 0)\n\t\t\treturn -1;\n\t}\n\tmsleep(100);\n\n\t \n\tfor (i = 0; i < num_of_av_port; i++) {\n\t\tres = ps3av_cmd_av_video_disable_sig(ps3av->av_port[i]);\n\t\tif (res < 0)\n\t\t\treturn -1;\n\t\tif (i < num_of_hdmi_port) {\n\t\t\tres = ps3av_cmd_av_tv_mute(ps3av->av_port[i],\n\t\t\t\t\t\t   PS3AV_CMD_MUTE_OFF);\n\t\t\tif (res < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tmsleep(300);\n\n\treturn 0;\n}\n\nstatic int ps3av_set_audio_mute(u32 mute)\n{\n\tint i, num_of_av_port, num_of_opt_port, res;\n\n\tnum_of_av_port = ps3av->av_hw_conf.num_of_hdmi +\n\t\t\t ps3av->av_hw_conf.num_of_avmulti;\n\tnum_of_opt_port = ps3av->av_hw_conf.num_of_spdif;\n\n\tfor (i = 0; i < num_of_av_port; i++) {\n\t\tres = ps3av_cmd_av_audio_mute(1, &ps3av->av_port[i], mute);\n\t\tif (res < 0)\n\t\t\treturn -1;\n\t}\n\tfor (i = 0; i < num_of_opt_port; i++) {\n\t\tres = ps3av_cmd_audio_mute(1, &ps3av->opt_port[i], mute);\n\t\tif (res < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint ps3av_set_audio_mode(u32 ch, u32 fs, u32 word_bits, u32 format, u32 source)\n{\n\tstruct ps3av_pkt_avb_param avb_param;\n\tint i, num_of_audio, vid, res;\n\tstruct ps3av_pkt_audio_mode audio_mode;\n\tu32 len = 0;\n\n\tnum_of_audio = ps3av->av_hw_conf.num_of_hdmi +\n\t\t       ps3av->av_hw_conf.num_of_avmulti +\n\t\t       ps3av->av_hw_conf.num_of_spdif;\n\n\tavb_param.num_of_video_pkt = 0;\n\tavb_param.num_of_audio_pkt = PS3AV_AVB_NUM_AUDIO;\t \n\tavb_param.num_of_av_video_pkt = 0;\n\tavb_param.num_of_av_audio_pkt = ps3av->av_hw_conf.num_of_hdmi;\n\n\tvid = video_mode_table[ps3av->ps3av_mode].vid;\n\n\t \n\tps3av_set_audio_mute(PS3AV_CMD_MUTE_ON);\n\n\t \n\tres = ps3av_cmd_audio_active(0, ps3av->audio_port);\n\tif (res < 0)\n\t\tdev_dbg(&ps3av->dev->core,\n\t\t\t\"ps3av_cmd_audio_active OFF failed\\n\");\n\n\t \n\tfor (i = 0; i < num_of_audio; i++) {\n\t\tps3av_cmd_set_audio_mode(&audio_mode, ps3av->av_port[i], ch,\n\t\t\t\t\t fs, word_bits, format, source);\n\t\tif (i < ps3av->av_hw_conf.num_of_hdmi) {\n\t\t\t \n\t\t\tlen += ps3av_cmd_set_av_audio_param(&avb_param.buf[len],\n\t\t\t\t\t\t\t    ps3av->av_port[i],\n\t\t\t\t\t\t\t    &audio_mode, vid);\n\t\t}\n\t\t \n\t\tres = ps3av_cmd_audio_mode(&audio_mode);\n\t\tif (res < 0)\n\t\t\tdev_dbg(&ps3av->dev->core,\n\t\t\t\t\"ps3av_cmd_audio_mode failed, port:%x\\n\", i);\n\t}\n\n\t \n\tlen += offsetof(struct ps3av_pkt_avb_param, buf);\n\tres = ps3av_cmd_avb_param(&avb_param, len);\n\tif (res < 0)\n\t\tdev_dbg(&ps3av->dev->core, \"ps3av_cmd_avb_param failed\\n\");\n\n\t \n\tps3av_set_audio_mute(PS3AV_CMD_MUTE_OFF);\n\n\t \n\tres = ps3av_cmd_audio_active(1, ps3av->audio_port);\n\tif (res < 0)\n\t\tdev_dbg(&ps3av->dev->core,\n\t\t\t\"ps3av_cmd_audio_active ON failed\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3av_set_audio_mode);\n\nstatic int ps3av_set_videomode(void)\n{\n\t \n\tps3av_set_av_video_mute(PS3AV_CMD_MUTE_ON);\n\n\t \n\tschedule_work(&ps3av->work);\n\n\treturn 0;\n}\n\nstatic void ps3av_set_videomode_packet(u32 id)\n{\n\tstruct ps3av_pkt_avb_param avb_param;\n\tunsigned int i;\n\tu32 len = 0, av_video_cs;\n\tconst struct avset_video_mode *video_mode;\n\tint res;\n\n\tvideo_mode = &video_mode_table[id & PS3AV_MODE_MASK];\n\n\tavb_param.num_of_video_pkt = PS3AV_AVB_NUM_VIDEO;  \n\tavb_param.num_of_audio_pkt = 0;\n\tavb_param.num_of_av_video_pkt = ps3av->av_hw_conf.num_of_hdmi +\n\t\t\t\t\tps3av->av_hw_conf.num_of_avmulti;\n\tavb_param.num_of_av_audio_pkt = 0;\n\n\t \n\tfor (i = 0; i < avb_param.num_of_video_pkt; i++)\n\t\tlen += ps3av_cmd_set_video_mode(&avb_param.buf[len],\n\t\t\t\t\t\tps3av->head[i], video_mode->vid,\n\t\t\t\t\t\tvideo_mode->fmt, id);\n\t \n\tfor (i = 0; i < avb_param.num_of_av_video_pkt; i++) {\n\t\tif (id & PS3AV_MODE_DVI || id & PS3AV_MODE_RGB)\n\t\t\tav_video_cs = RGB8;\n\t\telse\n\t\t\tav_video_cs = video_mode->cs;\n#ifndef PS3AV_HDMI_YUV\n\t\tif (ps3av->av_port[i] == PS3AV_CMD_AVPORT_HDMI_0 ||\n\t\t    ps3av->av_port[i] == PS3AV_CMD_AVPORT_HDMI_1)\n\t\t\tav_video_cs = RGB8;  \n#endif\n\t\tlen += ps3av_cmd_set_av_video_cs(&avb_param.buf[len],\n\t\t\t\t\t\t ps3av->av_port[i],\n\t\t\t\t\t\t video_mode->vid, av_video_cs,\n\t\t\t\t\t\t video_mode->aspect, id);\n\t}\n\t \n\tlen += offsetof(struct ps3av_pkt_avb_param, buf);\n\tres = ps3av_cmd_avb_param(&avb_param, len);\n\tif (res == PS3AV_STATUS_NO_SYNC_HEAD)\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: Command failed. Please try your request again.\\n\",\n\t\t       __func__);\n\telse if (res)\n\t\tdev_dbg(&ps3av->dev->core, \"ps3av_cmd_avb_param failed\\n\");\n}\n\nstatic void ps3av_set_videomode_cont(u32 id, u32 old_id)\n{\n\tstatic int vesa;\n\tint res;\n\n\t \n\tps3av_set_video_disable_sig();\n\n\t \n\tif (vesa == 0 && (id & PS3AV_MODE_MASK) >= PS3AV_MODE_WXGA) {\n\t\t \n\t\tps3av_set_videomode_packet(PS3AV_MODE_480P);\n\t}\n\tvesa = 1;\n\n\t \n\tif (id & PS3AV_MODE_HDCP_OFF) {\n\t\tres = ps3av_cmd_av_hdmi_mode(PS3AV_CMD_AV_HDMI_HDCP_OFF);\n\t\tif (res == PS3AV_STATUS_UNSUPPORTED_HDMI_MODE)\n\t\t\tdev_dbg(&ps3av->dev->core, \"Not supported\\n\");\n\t\telse if (res)\n\t\t\tdev_dbg(&ps3av->dev->core,\n\t\t\t\t\"ps3av_cmd_av_hdmi_mode failed\\n\");\n\t} else if (old_id & PS3AV_MODE_HDCP_OFF) {\n\t\tres = ps3av_cmd_av_hdmi_mode(PS3AV_CMD_AV_HDMI_MODE_NORMAL);\n\t\tif (res < 0 && res != PS3AV_STATUS_UNSUPPORTED_HDMI_MODE)\n\t\t\tdev_dbg(&ps3av->dev->core,\n\t\t\t\t\"ps3av_cmd_av_hdmi_mode failed\\n\");\n\t}\n\n\tps3av_set_videomode_packet(id);\n\n\tmsleep(1500);\n\t \n\tps3av_set_av_video_mute(PS3AV_CMD_MUTE_OFF);\n}\n\nstatic void ps3avd(struct work_struct *work)\n{\n\tps3av_set_videomode_cont(ps3av->ps3av_mode, ps3av->ps3av_mode_old);\n\tcomplete(&ps3av->done);\n}\n\n#define SHIFT_50\t0\n#define SHIFT_60\t4\n#define SHIFT_VESA\t8\n\nstatic const struct {\n\tunsigned mask:19;\n\tunsigned id:4;\n} ps3av_preferred_modes[] = {\n\t{ PS3AV_RESBIT_WUXGA      << SHIFT_VESA, PS3AV_MODE_WUXGA   },\n\t{ PS3AV_RESBIT_1920x1080P << SHIFT_60,   PS3AV_MODE_1080P60 },\n\t{ PS3AV_RESBIT_1920x1080P << SHIFT_50,   PS3AV_MODE_1080P50 },\n\t{ PS3AV_RESBIT_1920x1080I << SHIFT_60,   PS3AV_MODE_1080I60 },\n\t{ PS3AV_RESBIT_1920x1080I << SHIFT_50,   PS3AV_MODE_1080I50 },\n\t{ PS3AV_RESBIT_SXGA       << SHIFT_VESA, PS3AV_MODE_SXGA    },\n\t{ PS3AV_RESBIT_WXGA       << SHIFT_VESA, PS3AV_MODE_WXGA    },\n\t{ PS3AV_RESBIT_1280x720P  << SHIFT_60,   PS3AV_MODE_720P60  },\n\t{ PS3AV_RESBIT_1280x720P  << SHIFT_50,   PS3AV_MODE_720P50  },\n\t{ PS3AV_RESBIT_720x480P   << SHIFT_60,   PS3AV_MODE_480P    },\n\t{ PS3AV_RESBIT_720x576P   << SHIFT_50,   PS3AV_MODE_576P    },\n};\n\nstatic enum ps3av_mode_num ps3av_resbit2id(u32 res_50, u32 res_60,\n\t\t\t\t\t   u32 res_vesa)\n{\n\tunsigned int i;\n\tu32 res_all;\n\n\t \n\tBUILD_BUG_ON(PS3AV_RES_MASK_50 << SHIFT_50 &\n\t\t     PS3AV_RES_MASK_60 << SHIFT_60);\n\tBUILD_BUG_ON(PS3AV_RES_MASK_50 << SHIFT_50 &\n\t\t     PS3AV_RES_MASK_VESA << SHIFT_VESA);\n\tBUILD_BUG_ON(PS3AV_RES_MASK_60 << SHIFT_60 &\n\t\t     PS3AV_RES_MASK_VESA << SHIFT_VESA);\n\tres_all = (res_50 & PS3AV_RES_MASK_50) << SHIFT_50 |\n\t\t  (res_60 & PS3AV_RES_MASK_60) << SHIFT_60 |\n\t\t  (res_vesa & PS3AV_RES_MASK_VESA) << SHIFT_VESA;\n\n\tif (!res_all)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(ps3av_preferred_modes); i++)\n\t\tif (res_all & ps3av_preferred_modes[i].mask)\n\t\t\treturn ps3av_preferred_modes[i].id;\n\n\treturn 0;\n}\n\nstatic enum ps3av_mode_num ps3av_hdmi_get_id(struct ps3av_info_monitor *info)\n{\n\tenum ps3av_mode_num id;\n\n\tif (safe_mode)\n\t\treturn PS3AV_DEFAULT_HDMI_MODE_ID_REG_60;\n\n\t \n\tid = ps3av_resbit2id(info->res_50.native, info->res_60.native,\n\t\t\t     info->res_vesa.native);\n\tif (id) {\n\t\tpr_debug(\"%s: Using native mode %d\\n\", __func__, id);\n\t\treturn id;\n\t}\n\n\t \n\tid = ps3av_resbit2id(info->res_50.res_bits, info->res_60.res_bits,\n\t\t\t     info->res_vesa.res_bits);\n\tif (id) {\n\t\tpr_debug(\"%s: Using supported mode %d\\n\", __func__, id);\n\t\treturn id;\n\t}\n\n\tif (ps3av->region & PS3AV_REGION_60)\n\t\tid = PS3AV_DEFAULT_HDMI_MODE_ID_REG_60;\n\telse\n\t\tid = PS3AV_DEFAULT_HDMI_MODE_ID_REG_50;\n\tpr_debug(\"%s: Using default mode %d\\n\", __func__, id);\n\treturn id;\n}\n\nstatic void ps3av_monitor_info_dump(\n\tconst struct ps3av_pkt_av_get_monitor_info *monitor_info)\n{\n\tconst struct ps3av_info_monitor *info = &monitor_info->info;\n\tconst struct ps3av_info_audio *audio = info->audio;\n\tchar id[sizeof(info->monitor_id)*3+1];\n\tint i;\n\n\tpr_debug(\"Monitor Info: size %u\\n\", monitor_info->send_hdr.size);\n\n\tpr_debug(\"avport: %02x\\n\", info->avport);\n\tfor (i = 0; i < sizeof(info->monitor_id); i++)\n\t\tsprintf(&id[i*3], \" %02x\", info->monitor_id[i]);\n\tpr_debug(\"monitor_id: %s\\n\", id);\n\tpr_debug(\"monitor_type: %02x\\n\", info->monitor_type);\n\tpr_debug(\"monitor_name: %.*s\\n\", (int)sizeof(info->monitor_name),\n\t\t info->monitor_name);\n\n\t \n\tpr_debug(\"resolution_60: bits: %08x native: %08x\\n\",\n\t\t info->res_60.res_bits, info->res_60.native);\n\tpr_debug(\"resolution_50: bits: %08x native: %08x\\n\",\n\t\t info->res_50.res_bits, info->res_50.native);\n\tpr_debug(\"resolution_other: bits: %08x native: %08x\\n\",\n\t\t info->res_other.res_bits, info->res_other.native);\n\tpr_debug(\"resolution_vesa: bits: %08x native: %08x\\n\",\n\t\t info->res_vesa.res_bits, info->res_vesa.native);\n\n\t \n\tpr_debug(\"color space    rgb: %02x\\n\", info->cs.rgb);\n\tpr_debug(\"color space yuv444: %02x\\n\", info->cs.yuv444);\n\tpr_debug(\"color space yuv422: %02x\\n\", info->cs.yuv422);\n\n\t \n\tpr_debug(\"color info   red: X %04x Y %04x\\n\", info->color.red_x,\n\t\t info->color.red_y);\n\tpr_debug(\"color info green: X %04x Y %04x\\n\", info->color.green_x,\n\t\t info->color.green_y);\n\tpr_debug(\"color info  blue: X %04x Y %04x\\n\", info->color.blue_x,\n\t\t info->color.blue_y);\n\tpr_debug(\"color info white: X %04x Y %04x\\n\", info->color.white_x,\n\t\t info->color.white_y);\n\tpr_debug(\"color info gamma:  %08x\\n\", info->color.gamma);\n\n\t \n\tpr_debug(\"supported_AI: %02x\\n\", info->supported_ai);\n\tpr_debug(\"speaker_info: %02x\\n\", info->speaker_info);\n\tpr_debug(\"num of audio: %02x\\n\", info->num_of_audio_block);\n\n\t \n\tfor (i = 0; i < info->num_of_audio_block; i++) {\n\t\tpr_debug(\n\t\t\t\"audio[%d] type: %02x max_ch: %02x fs: %02x sbit: %02x\\n\",\n\t\t\t i, audio->type, audio->max_num_of_ch, audio->fs,\n\t\t\t audio->sbit);\n\t\taudio++;\n\t}\n}\n\nstatic const struct ps3av_monitor_quirk {\n\tconst char *monitor_name;\n\tu32 clear_60;\n} ps3av_monitor_quirks[] = {\n\t{\n\t\t.monitor_name\t= \"DELL 2007WFP\",\n\t\t.clear_60\t= PS3AV_RESBIT_1920x1080I\n\t}, {\n\t\t.monitor_name\t= \"L226WTQ\",\n\t\t.clear_60\t= PS3AV_RESBIT_1920x1080I |\n\t\t\t\t  PS3AV_RESBIT_1920x1080P\n\t}, {\n\t\t.monitor_name\t= \"SyncMaster\",\n\t\t.clear_60\t= PS3AV_RESBIT_1920x1080I\n\t}\n};\n\nstatic void ps3av_fixup_monitor_info(struct ps3av_info_monitor *info)\n{\n\tunsigned int i;\n\tconst struct ps3av_monitor_quirk *quirk;\n\n\tfor (i = 0; i < ARRAY_SIZE(ps3av_monitor_quirks); i++) {\n\t\tquirk = &ps3av_monitor_quirks[i];\n\t\tif (!strncmp(info->monitor_name, quirk->monitor_name,\n\t\t\t     sizeof(info->monitor_name))) {\n\t\t\tpr_info(\"%s: Applying quirk for %s\\n\", __func__,\n\t\t\t\tquirk->monitor_name);\n\t\t\tinfo->res_60.res_bits &= ~quirk->clear_60;\n\t\t\tinfo->res_60.native &= ~quirk->clear_60;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int ps3av_auto_videomode(struct ps3av_pkt_av_get_hw_conf *av_hw_conf)\n{\n\tint i, res, id = 0, dvi = 0, rgb = 0;\n\tstruct ps3av_pkt_av_get_monitor_info monitor_info;\n\tstruct ps3av_info_monitor *info;\n\n\t \n\tfor (i = 0; i < av_hw_conf->num_of_hdmi && !id; i++) {\n\t\tres = ps3av_cmd_video_get_monitor_info(&monitor_info,\n\t\t\t\t\t\t       PS3AV_CMD_AVPORT_HDMI_0 +\n\t\t\t\t\t\t       i);\n\t\tif (res < 0)\n\t\t\treturn -1;\n\n\t\tps3av_monitor_info_dump(&monitor_info);\n\n\t\tinfo = &monitor_info.info;\n\t\tps3av_fixup_monitor_info(info);\n\n\t\tswitch (info->monitor_type) {\n\t\tcase PS3AV_MONITOR_TYPE_DVI:\n\t\t\tdvi = PS3AV_MODE_DVI;\n\t\t\tfallthrough;\n\t\tcase PS3AV_MONITOR_TYPE_HDMI:\n\t\t\tid = ps3av_hdmi_get_id(info);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!id) {\n\t\t \n\t\tif (ps3av->region & PS3AV_REGION_60)\n\t\t\tid = PS3AV_DEFAULT_AVMULTI_MODE_ID_REG_60;\n\t\telse\n\t\t\tid = PS3AV_DEFAULT_AVMULTI_MODE_ID_REG_50;\n\t\tif (ps3av->region & PS3AV_REGION_RGB)\n\t\t\trgb = PS3AV_MODE_RGB;\n\t\tpr_debug(\"%s: Using avmulti mode %d\\n\", __func__, id);\n\t}\n\n\treturn id | dvi | rgb;\n}\n\nstatic int ps3av_get_hw_conf(struct ps3av *ps3av)\n{\n\tint i, j, k, res;\n\tconst struct ps3av_pkt_av_get_hw_conf *hw_conf;\n\n\t \n\tres = ps3av_cmd_av_get_hw_conf(&ps3av->av_hw_conf);\n\tif (res < 0)\n\t\treturn -1;\n\n\thw_conf = &ps3av->av_hw_conf;\n\tpr_debug(\"av_h_conf: num of hdmi: %u\\n\", hw_conf->num_of_hdmi);\n\tpr_debug(\"av_h_conf: num of avmulti: %u\\n\", hw_conf->num_of_avmulti);\n\tpr_debug(\"av_h_conf: num of spdif: %u\\n\", hw_conf->num_of_spdif);\n\n\tfor (i = 0; i < PS3AV_HEAD_MAX; i++)\n\t\tps3av->head[i] = PS3AV_CMD_VIDEO_HEAD_A + i;\n\tfor (i = 0; i < PS3AV_OPT_PORT_MAX; i++)\n\t\tps3av->opt_port[i] = PS3AV_CMD_AVPORT_SPDIF_0 + i;\n\tfor (i = 0; i < hw_conf->num_of_hdmi; i++)\n\t\tps3av->av_port[i] = PS3AV_CMD_AVPORT_HDMI_0 + i;\n\tfor (j = 0; j < hw_conf->num_of_avmulti; j++)\n\t\tps3av->av_port[i + j] = PS3AV_CMD_AVPORT_AVMULTI_0 + j;\n\tfor (k = 0; k < hw_conf->num_of_spdif; k++)\n\t\tps3av->av_port[i + j + k] = PS3AV_CMD_AVPORT_SPDIF_0 + k;\n\n\t \n\tps3av->audio_port = PS3AV_CMD_AUDIO_PORT_HDMI_0\n\t    | PS3AV_CMD_AUDIO_PORT_HDMI_1\n\t    | PS3AV_CMD_AUDIO_PORT_AVMULTI_0\n\t    | PS3AV_CMD_AUDIO_PORT_SPDIF_0 | PS3AV_CMD_AUDIO_PORT_SPDIF_1;\n\n\treturn 0;\n}\n\n \nint ps3av_set_video_mode(int id)\n{\n\tint size;\n\tu32 option;\n\n\tsize = ARRAY_SIZE(video_mode_table);\n\tif ((id & PS3AV_MODE_MASK) > size - 1 || id < 0) {\n\t\tdev_dbg(&ps3av->dev->core, \"%s: error id :%d\\n\", __func__, id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\toption = id & ~PS3AV_MODE_MASK;\n\tif ((id & PS3AV_MODE_MASK) == PS3AV_MODE_AUTO) {\n\t\tid = ps3av_auto_videomode(&ps3av->av_hw_conf);\n\t\tif (id < 1) {\n\t\t\tprintk(KERN_ERR \"%s: invalid id :%d\\n\", __func__, id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tid |= option;\n\t}\n\n\t \n\twait_for_completion(&ps3av->done);\n\tps3av->ps3av_mode_old = ps3av->ps3av_mode;\n\tps3av->ps3av_mode = id;\n\tif (ps3av_set_videomode())\n\t\tps3av->ps3av_mode = ps3av->ps3av_mode_old;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3av_set_video_mode);\n\nint ps3av_get_auto_mode(void)\n{\n\treturn ps3av_auto_videomode(&ps3av->av_hw_conf);\n}\nEXPORT_SYMBOL_GPL(ps3av_get_auto_mode);\n\nint ps3av_get_mode(void)\n{\n\treturn ps3av ? ps3av->ps3av_mode : 0;\n}\nEXPORT_SYMBOL_GPL(ps3av_get_mode);\n\n \nint ps3av_video_mode2res(u32 id, u32 *xres, u32 *yres)\n{\n\tint size;\n\n\tid = id & PS3AV_MODE_MASK;\n\tsize = ARRAY_SIZE(video_mode_table);\n\tif (id > size - 1 || id < 0) {\n\t\tprintk(KERN_ERR \"%s: invalid mode %d\\n\", __func__, id);\n\t\treturn -EINVAL;\n\t}\n\t*xres = video_mode_table[id].x;\n\t*yres = video_mode_table[id].y;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3av_video_mode2res);\n\n \nint ps3av_video_mute(int mute)\n{\n\treturn ps3av_set_av_video_mute(mute ? PS3AV_CMD_MUTE_ON\n\t\t\t\t\t    : PS3AV_CMD_MUTE_OFF);\n}\nEXPORT_SYMBOL_GPL(ps3av_video_mute);\n\n \nint ps3av_audio_mute_analog(int mute)\n{\n\tint i, res;\n\n\tfor (i = 0; i < ps3av->av_hw_conf.num_of_avmulti; i++) {\n\t\tres = ps3av_cmd_av_audio_mute(1,\n\t\t\t&ps3av->av_port[i + ps3av->av_hw_conf.num_of_hdmi],\n\t\t\tmute);\n\t\tif (res < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ps3av_audio_mute_analog);\n\nint ps3av_audio_mute(int mute)\n{\n\treturn ps3av_set_audio_mute(mute ? PS3AV_CMD_MUTE_ON\n\t\t\t\t\t : PS3AV_CMD_MUTE_OFF);\n}\nEXPORT_SYMBOL_GPL(ps3av_audio_mute);\n\nstatic int ps3av_probe(struct ps3_system_bus_device *dev)\n{\n\tconst char *mode_option;\n\tint res;\n\tint id;\n\n\tdev_dbg(&dev->core, \" -> %s:%d\\n\", __func__, __LINE__);\n\tdev_dbg(&dev->core, \"  timeout=%d\\n\", timeout);\n\n\tif (ps3av) {\n\t\tdev_err(&dev->core, \"Only one ps3av device is supported\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tps3av = kzalloc(sizeof(*ps3av), GFP_KERNEL);\n\tif (!ps3av)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ps3av->mutex);\n\tps3av->ps3av_mode = PS3AV_MODE_AUTO;\n\tps3av->dev = dev;\n\n\tINIT_WORK(&ps3av->work, ps3avd);\n\tinit_completion(&ps3av->done);\n\tcomplete(&ps3av->done);\n\n\tswitch (ps3_os_area_get_av_multi_out()) {\n\tcase PS3_PARAM_AV_MULTI_OUT_NTSC:\n\t\tps3av->region = PS3AV_REGION_60;\n\t\tbreak;\n\tcase PS3_PARAM_AV_MULTI_OUT_PAL_YCBCR:\n\tcase PS3_PARAM_AV_MULTI_OUT_SECAM:\n\t\tps3av->region = PS3AV_REGION_50;\n\t\tbreak;\n\tcase PS3_PARAM_AV_MULTI_OUT_PAL_RGB:\n\t\tps3av->region = PS3AV_REGION_50 | PS3AV_REGION_RGB;\n\t\tbreak;\n\tdefault:\n\t\tps3av->region = PS3AV_REGION_60;\n\t\tbreak;\n\t}\n\n\t \n\tres = ps3av_cmd_init();\n\tif (res < 0)\n\t\tprintk(KERN_ERR \"%s: ps3av_cmd_init failed %d\\n\", __func__,\n\t\t       res);\n\n\tps3av_get_hw_conf(ps3av);\n\n\tmode_option = video_get_options(NULL);\n\tif (mode_option && !strcmp(mode_option, \"safe\"))\n\t\tsafe_mode = 1;\n\tid = ps3av_auto_videomode(&ps3av->av_hw_conf);\n\tif (id < 0) {\n\t\tprintk(KERN_ERR \"%s: invalid id :%d\\n\", __func__, id);\n\t\tres = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tsafe_mode = 0;\n\n\tmutex_lock(&ps3av->mutex);\n\tps3av->ps3av_mode = id;\n\tmutex_unlock(&ps3av->mutex);\n\n\tdev_dbg(&dev->core, \" <- %s:%d\\n\", __func__, __LINE__);\n\n\treturn 0;\n\nfail:\n\tkfree(ps3av);\n\tps3av = NULL;\n\treturn res;\n}\n\nstatic int ps3av_remove(struct ps3_system_bus_device *dev)\n{\n\tdev_dbg(&dev->core, \" -> %s:%d\\n\", __func__, __LINE__);\n\tif (ps3av) {\n\t\tps3av_cmd_fin();\n\t\tflush_work(&ps3av->work);\n\t\tkfree(ps3av);\n\t\tps3av = NULL;\n\t}\n\n\tdev_dbg(&dev->core, \" <- %s:%d\\n\", __func__, __LINE__);\n\treturn 0;\n}\n\nstatic void ps3av_shutdown(struct ps3_system_bus_device *dev)\n{\n\tdev_dbg(&dev->core, \" -> %s:%d\\n\", __func__, __LINE__);\n\tps3av_remove(dev);\n\tdev_dbg(&dev->core, \" <- %s:%d\\n\", __func__, __LINE__);\n}\n\nstatic struct ps3_vuart_port_driver ps3av_driver = {\n\t.core.match_id = PS3_MATCH_ID_AV_SETTINGS,\n\t.core.core.name = \"ps3_av\",\n\t.probe = ps3av_probe,\n\t.remove = ps3av_remove,\n\t.shutdown = ps3av_shutdown,\n};\n\nstatic int __init ps3av_module_init(void)\n{\n\tint error;\n\n\tif (!firmware_has_feature(FW_FEATURE_PS3_LV1))\n\t\treturn -ENODEV;\n\n\tpr_debug(\" -> %s:%d\\n\", __func__, __LINE__);\n\n\terror = ps3_vuart_port_driver_register(&ps3av_driver);\n\tif (error) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: ps3_vuart_port_driver_register failed %d\\n\",\n\t\t       __func__, error);\n\t\treturn error;\n\t}\n\n\tpr_debug(\" <- %s:%d\\n\", __func__, __LINE__);\n\treturn error;\n}\n\nstatic void __exit ps3av_module_exit(void)\n{\n\tpr_debug(\" -> %s:%d\\n\", __func__, __LINE__);\n\tps3_vuart_port_driver_unregister(&ps3av_driver);\n\tpr_debug(\" <- %s:%d\\n\", __func__, __LINE__);\n}\n\nsubsys_initcall(ps3av_module_init);\nmodule_exit(ps3av_module_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"PS3 AV Settings Driver\");\nMODULE_AUTHOR(\"Sony Computer Entertainment Inc.\");\nMODULE_ALIAS(PS3_MODULE_ALIAS_AV_SETTINGS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}