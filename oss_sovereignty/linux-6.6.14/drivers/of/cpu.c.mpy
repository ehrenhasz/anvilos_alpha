{
  "module_name": "cpu.c",
  "hash_id": "d80a4b78326903295f8f39b73dda34b9acccfb1d6867d6521089820ecbc43461",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/cpu.c",
  "human_readable_source": "\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n\n \nu64 of_get_cpu_hwid(struct device_node *cpun, unsigned int thread)\n{\n\tconst __be32 *cell;\n\tint ac, len;\n\n\tac = of_n_addr_cells(cpun);\n\tcell = of_get_property(cpun, \"reg\", &len);\n\tif (!cell || !ac || ((sizeof(*cell) * ac * (thread + 1)) > len))\n\t\treturn ~0ULL;\n\n\tcell += ac * thread;\n\treturn of_read_number(cell, ac);\n}\n\n \nbool __weak arch_match_cpu_phys_id(int cpu, u64 phys_id)\n{\n\treturn (u32)phys_id == cpu;\n}\n\n \nstatic bool __of_find_n_match_cpu_property(struct device_node *cpun,\n\t\t\tconst char *prop_name, int cpu, unsigned int *thread)\n{\n\tconst __be32 *cell;\n\tint ac, prop_len, tid;\n\tu64 hwid;\n\n\tac = of_n_addr_cells(cpun);\n\tcell = of_get_property(cpun, prop_name, &prop_len);\n\tif (!cell && !ac && arch_match_cpu_phys_id(cpu, 0))\n\t\treturn true;\n\tif (!cell || !ac)\n\t\treturn false;\n\tprop_len /= sizeof(*cell) * ac;\n\tfor (tid = 0; tid < prop_len; tid++) {\n\t\thwid = of_read_number(cell, ac);\n\t\tif (arch_match_cpu_phys_id(cpu, hwid)) {\n\t\t\tif (thread)\n\t\t\t\t*thread = tid;\n\t\t\treturn true;\n\t\t}\n\t\tcell += ac;\n\t}\n\treturn false;\n}\n\n \nbool __weak arch_find_n_match_cpu_physical_id(struct device_node *cpun,\n\t\t\t\t\t      int cpu, unsigned int *thread)\n{\n\t \n\tif (IS_ENABLED(CONFIG_PPC) &&\n\t    __of_find_n_match_cpu_property(cpun,\n\t\t\t\t\t   \"ibm,ppc-interrupt-server#s\",\n\t\t\t\t\t   cpu, thread))\n\t\treturn true;\n\n\treturn __of_find_n_match_cpu_property(cpun, \"reg\", cpu, thread);\n}\n\n \nstruct device_node *of_get_cpu_node(int cpu, unsigned int *thread)\n{\n\tstruct device_node *cpun;\n\n\tfor_each_of_cpu_node(cpun) {\n\t\tif (arch_find_n_match_cpu_physical_id(cpun, cpu, thread))\n\t\t\treturn cpun;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(of_get_cpu_node);\n\n \nstruct device_node *of_cpu_device_node_get(int cpu)\n{\n\tstruct device *cpu_dev;\n\tcpu_dev = get_cpu_device(cpu);\n\tif (!cpu_dev)\n\t\treturn of_get_cpu_node(cpu, NULL);\n\treturn of_node_get(cpu_dev->of_node);\n}\nEXPORT_SYMBOL(of_cpu_device_node_get);\n\n \nint of_cpu_node_to_id(struct device_node *cpu_node)\n{\n\tint cpu;\n\tbool found = false;\n\tstruct device_node *np;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tnp = of_cpu_device_node_get(cpu);\n\t\tfound = (cpu_node == np);\n\t\tof_node_put(np);\n\t\tif (found)\n\t\t\treturn cpu;\n\t}\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL(of_cpu_node_to_id);\n\n \nstruct device_node *of_get_cpu_state_node(struct device_node *cpu_node,\n\t\t\t\t\t  int index)\n{\n\tstruct of_phandle_args args;\n\tint err;\n\n\terr = of_parse_phandle_with_args(cpu_node, \"power-domains\",\n\t\t\t\t\t\"#power-domain-cells\", 0, &args);\n\tif (!err) {\n\t\tstruct device_node *state_node =\n\t\t\tof_parse_phandle(args.np, \"domain-idle-states\", index);\n\n\t\tof_node_put(args.np);\n\t\tif (state_node)\n\t\t\treturn state_node;\n\t}\n\n\treturn of_parse_phandle(cpu_node, \"cpu-idle-states\", index);\n}\nEXPORT_SYMBOL(of_get_cpu_state_node);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}