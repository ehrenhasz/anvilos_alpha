{
  "module_name": "dynamic.c",
  "hash_id": "77a5cdc6cdb66f35b501f5d37e464e56d84627d9937cc16e6475572f9636e2e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/dynamic.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"OF: \" fmt\n\n#include <linux/of.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/proc_fs.h>\n\n#include \"of_private.h\"\n\nstatic struct device_node *kobj_to_device_node(struct kobject *kobj)\n{\n\treturn container_of(kobj, struct device_node, kobj);\n}\n\n \nstruct device_node *of_node_get(struct device_node *node)\n{\n\tif (node)\n\t\tkobject_get(&node->kobj);\n\treturn node;\n}\nEXPORT_SYMBOL(of_node_get);\n\n \nvoid of_node_put(struct device_node *node)\n{\n\tif (node)\n\t\tkobject_put(&node->kobj);\n}\nEXPORT_SYMBOL(of_node_put);\n\nstatic BLOCKING_NOTIFIER_HEAD(of_reconfig_chain);\n\nint of_reconfig_notifier_register(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&of_reconfig_chain, nb);\n}\nEXPORT_SYMBOL_GPL(of_reconfig_notifier_register);\n\nint of_reconfig_notifier_unregister(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&of_reconfig_chain, nb);\n}\nEXPORT_SYMBOL_GPL(of_reconfig_notifier_unregister);\n\nstatic const char *action_names[] = {\n\t[0] = \"INVALID\",\n\t[OF_RECONFIG_ATTACH_NODE] = \"ATTACH_NODE\",\n\t[OF_RECONFIG_DETACH_NODE] = \"DETACH_NODE\",\n\t[OF_RECONFIG_ADD_PROPERTY] = \"ADD_PROPERTY\",\n\t[OF_RECONFIG_REMOVE_PROPERTY] = \"REMOVE_PROPERTY\",\n\t[OF_RECONFIG_UPDATE_PROPERTY] = \"UPDATE_PROPERTY\",\n};\n\n#define _do_print(func, prefix, action, node, prop, ...) ({\t\\\n\tfunc(\"changeset: \" prefix \"%-15s %pOF%s%s\\n\",\t\t\\\n\t     ##__VA_ARGS__, action_names[action], node,\t\t\\\n\t     prop ? \":\" : \"\", prop ? prop->name : \"\");\t\t\\\n})\n#define of_changeset_action_err(...) _do_print(pr_err, __VA_ARGS__)\n#define of_changeset_action_debug(...) _do_print(pr_debug, __VA_ARGS__)\n\nint of_reconfig_notify(unsigned long action, struct of_reconfig_data *p)\n{\n\tint rc;\n\tstruct of_reconfig_data *pr = p;\n\n\tof_changeset_action_debug(\"notify: \", action, pr->dn, pr->prop);\n\n\trc = blocking_notifier_call_chain(&of_reconfig_chain, action, p);\n\treturn notifier_to_errno(rc);\n}\n\n \nint of_reconfig_get_state_change(unsigned long action, struct of_reconfig_data *pr)\n{\n\tstruct property *prop, *old_prop = NULL;\n\tint is_status, status_state, old_status_state, prev_state, new_state;\n\n\t \n\tswitch (action) {\n\tcase OF_RECONFIG_ATTACH_NODE:\n\tcase OF_RECONFIG_DETACH_NODE:\n\t\tprop = of_find_property(pr->dn, \"status\", NULL);\n\t\tbreak;\n\tcase OF_RECONFIG_ADD_PROPERTY:\n\tcase OF_RECONFIG_REMOVE_PROPERTY:\n\t\tprop = pr->prop;\n\t\tbreak;\n\tcase OF_RECONFIG_UPDATE_PROPERTY:\n\t\tprop = pr->prop;\n\t\told_prop = pr->old_prop;\n\t\tbreak;\n\tdefault:\n\t\treturn OF_RECONFIG_NO_CHANGE;\n\t}\n\n\tis_status = 0;\n\tstatus_state = -1;\n\told_status_state = -1;\n\tprev_state = -1;\n\tnew_state = -1;\n\n\tif (prop && !strcmp(prop->name, \"status\")) {\n\t\tis_status = 1;\n\t\tstatus_state = !strcmp(prop->value, \"okay\") ||\n\t\t\t       !strcmp(prop->value, \"ok\");\n\t\tif (old_prop)\n\t\t\told_status_state = !strcmp(old_prop->value, \"okay\") ||\n\t\t\t\t\t   !strcmp(old_prop->value, \"ok\");\n\t}\n\n\tswitch (action) {\n\tcase OF_RECONFIG_ATTACH_NODE:\n\t\tprev_state = 0;\n\t\t \n\t\tnew_state = status_state != 0;\n\t\tbreak;\n\tcase OF_RECONFIG_DETACH_NODE:\n\t\t \n\t\tprev_state = status_state != 0;\n\t\tnew_state = 0;\n\t\tbreak;\n\tcase OF_RECONFIG_ADD_PROPERTY:\n\t\tif (is_status) {\n\t\t\t \n\t\t\tprev_state = 1;\n\t\t\tnew_state = status_state;\n\t\t}\n\t\tbreak;\n\tcase OF_RECONFIG_REMOVE_PROPERTY:\n\t\tif (is_status) {\n\t\t\tprev_state = status_state;\n\t\t\t \n\t\t\tnew_state = 1;\n\t\t}\n\t\tbreak;\n\tcase OF_RECONFIG_UPDATE_PROPERTY:\n\t\tif (is_status) {\n\t\t\tprev_state = old_status_state != 0;\n\t\t\tnew_state = status_state != 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (prev_state == new_state)\n\t\treturn OF_RECONFIG_NO_CHANGE;\n\n\treturn new_state ? OF_RECONFIG_CHANGE_ADD : OF_RECONFIG_CHANGE_REMOVE;\n}\nEXPORT_SYMBOL_GPL(of_reconfig_get_state_change);\n\nint of_property_notify(int action, struct device_node *np,\n\t\t       struct property *prop, struct property *oldprop)\n{\n\tstruct of_reconfig_data pr;\n\n\t \n\tif (!of_node_is_attached(np))\n\t\treturn 0;\n\n\tpr.dn = np;\n\tpr.prop = prop;\n\tpr.old_prop = oldprop;\n\treturn of_reconfig_notify(action, &pr);\n}\n\nstatic void __of_attach_node(struct device_node *np)\n{\n\tconst __be32 *phandle;\n\tint sz;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\n\tif (!of_node_check_flag(np, OF_OVERLAY)) {\n\t\tnp->name = __of_get_property(np, \"name\", NULL);\n\t\tif (!np->name)\n\t\t\tnp->name = \"<NULL>\";\n\n\t\tphandle = __of_get_property(np, \"phandle\", &sz);\n\t\tif (!phandle)\n\t\t\tphandle = __of_get_property(np, \"linux,phandle\", &sz);\n\t\tif (IS_ENABLED(CONFIG_PPC_PSERIES) && !phandle)\n\t\t\tphandle = __of_get_property(np, \"ibm,phandle\", &sz);\n\t\tif (phandle && (sz >= 4))\n\t\t\tnp->phandle = be32_to_cpup(phandle);\n\t\telse\n\t\t\tnp->phandle = 0;\n\t}\n\n\tnp->child = NULL;\n\tnp->sibling = np->parent->child;\n\tnp->parent->child = np;\n\tof_node_clear_flag(np, OF_DETACHED);\n\tnp->fwnode.flags |= FWNODE_FLAG_NOT_DEVICE;\n\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\n\t__of_attach_node_sysfs(np);\n}\n\n \nint of_attach_node(struct device_node *np)\n{\n\tstruct of_reconfig_data rd;\n\n\tmemset(&rd, 0, sizeof(rd));\n\trd.dn = np;\n\n\tmutex_lock(&of_mutex);\n\t__of_attach_node(np);\n\tmutex_unlock(&of_mutex);\n\n\tof_reconfig_notify(OF_RECONFIG_ATTACH_NODE, &rd);\n\n\treturn 0;\n}\n\nvoid __of_detach_node(struct device_node *np)\n{\n\tstruct device_node *parent;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\n\tparent = np->parent;\n\tif (WARN_ON(of_node_check_flag(np, OF_DETACHED) || !parent)) {\n\t\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\t\treturn;\n\t}\n\n\tif (parent->child == np)\n\t\tparent->child = np->sibling;\n\telse {\n\t\tstruct device_node *prevsib;\n\t\tfor (prevsib = np->parent->child;\n\t\t     prevsib->sibling != np;\n\t\t     prevsib = prevsib->sibling)\n\t\t\t;\n\t\tprevsib->sibling = np->sibling;\n\t}\n\n\tof_node_set_flag(np, OF_DETACHED);\n\n\t \n\t__of_phandle_cache_inv_entry(np->phandle);\n\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\n\t__of_detach_node_sysfs(np);\n}\n\n \nint of_detach_node(struct device_node *np)\n{\n\tstruct of_reconfig_data rd;\n\n\tmemset(&rd, 0, sizeof(rd));\n\trd.dn = np;\n\n\tmutex_lock(&of_mutex);\n\t__of_detach_node(np);\n\tmutex_unlock(&of_mutex);\n\n\tof_reconfig_notify(OF_RECONFIG_DETACH_NODE, &rd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_detach_node);\n\nstatic void property_list_free(struct property *prop_list)\n{\n\tstruct property *prop, *next;\n\n\tfor (prop = prop_list; prop != NULL; prop = next) {\n\t\tnext = prop->next;\n\t\tkfree(prop->name);\n\t\tkfree(prop->value);\n\t\tkfree(prop);\n\t}\n}\n\n \nvoid of_node_release(struct kobject *kobj)\n{\n\tstruct device_node *node = kobj_to_device_node(kobj);\n\n\t \n\n\t \n\tif (!of_node_check_flag(node, OF_DETACHED)) {\n\n\t\tpr_err(\"ERROR: %s() detected bad of_node_put() on %pOF/%s\\n\",\n\t\t\t__func__, node->parent, node->full_name);\n\n\t\t \n\t\tif (!IS_ENABLED(CONFIG_OF_UNITTEST) ||\n\t\t    strcmp(node->parent->full_name, \"testcase-data\")) {\n\t\t\tdump_stack();\n\t\t\tpr_err(\"ERROR: next of_node_put() on this node will result in a kobject warning 'refcount_t: underflow; use-after-free.'\\n\");\n\t\t}\n\n\t\treturn;\n\t}\n\tif (!of_node_check_flag(node, OF_DYNAMIC))\n\t\treturn;\n\n\tif (of_node_check_flag(node, OF_OVERLAY)) {\n\n\t\tif (!of_node_check_flag(node, OF_OVERLAY_FREE_CSET)) {\n\t\t\t \n\t\t\tpr_err(\"ERROR: memory leak before free overlay changeset,  %pOF\\n\",\n\t\t\t       node);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (node->properties)\n\t\t\tpr_err(\"ERROR: %s(), unexpected properties in %pOF\\n\",\n\t\t\t       __func__, node);\n\t}\n\n\tif (node->child)\n\t\tpr_err(\"ERROR: %s() unexpected children for %pOF/%s\\n\",\n\t\t\t__func__, node->parent, node->full_name);\n\n\tproperty_list_free(node->properties);\n\tproperty_list_free(node->deadprops);\n\tfwnode_links_purge(of_fwnode_handle(node));\n\n\tkfree(node->full_name);\n\tkfree(node->data);\n\tkfree(node);\n}\n\n \nstruct property *__of_prop_dup(const struct property *prop, gfp_t allocflags)\n{\n\tstruct property *new;\n\n\tnew = kzalloc(sizeof(*new), allocflags);\n\tif (!new)\n\t\treturn NULL;\n\n\t \n\tnew->name = kstrdup(prop->name, allocflags);\n\tnew->value = kmemdup(prop->value, prop->length, allocflags);\n\tnew->length = prop->length;\n\tif (!new->name || !new->value)\n\t\tgoto err_free;\n\n\t \n\tof_property_set_flag(new, OF_DYNAMIC);\n\n\treturn new;\n\n err_free:\n\tkfree(new->name);\n\tkfree(new->value);\n\tkfree(new);\n\treturn NULL;\n}\n\n \nstruct device_node *__of_node_dup(const struct device_node *np,\n\t\t\t\t  const char *full_name)\n{\n\tstruct device_node *node;\n\n\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node)\n\t\treturn NULL;\n\tnode->full_name = kstrdup(full_name, GFP_KERNEL);\n\tif (!node->full_name) {\n\t\tkfree(node);\n\t\treturn NULL;\n\t}\n\n\tof_node_set_flag(node, OF_DYNAMIC);\n\tof_node_set_flag(node, OF_DETACHED);\n\tof_node_init(node);\n\n\t \n\tif (np) {\n\t\tstruct property *pp, *new_pp;\n\t\tfor_each_property_of_node(np, pp) {\n\t\t\tnew_pp = __of_prop_dup(pp, GFP_KERNEL);\n\t\t\tif (!new_pp)\n\t\t\t\tgoto err_prop;\n\t\t\tif (__of_add_property(node, new_pp)) {\n\t\t\t\tkfree(new_pp->name);\n\t\t\t\tkfree(new_pp->value);\n\t\t\t\tkfree(new_pp);\n\t\t\t\tgoto err_prop;\n\t\t\t}\n\t\t}\n\t}\n\treturn node;\n\n err_prop:\n\tof_node_put(node);  \n\treturn NULL;\n}\n\n \nstruct device_node *of_changeset_create_node(struct of_changeset *ocs,\n\t\t\t\t\t     struct device_node *parent,\n\t\t\t\t\t     const char *full_name)\n{\n\tstruct device_node *np;\n\tint ret;\n\n\tnp = __of_node_dup(NULL, full_name);\n\tif (!np)\n\t\treturn NULL;\n\tnp->parent = parent;\n\n\tret = of_changeset_attach_node(ocs, np);\n\tif (ret) {\n\t\tof_node_put(np);\n\t\treturn NULL;\n\t}\n\n\treturn np;\n}\nEXPORT_SYMBOL(of_changeset_create_node);\n\nstatic void __of_changeset_entry_destroy(struct of_changeset_entry *ce)\n{\n\tif (ce->action == OF_RECONFIG_ATTACH_NODE &&\n\t    of_node_check_flag(ce->np, OF_OVERLAY)) {\n\t\tif (kref_read(&ce->np->kobj.kref) > 1) {\n\t\t\tpr_err(\"ERROR: memory leak, expected refcount 1 instead of %d, of_node_get()/of_node_put() unbalanced - destroy cset entry: attach overlay node %pOF\\n\",\n\t\t\t       kref_read(&ce->np->kobj.kref), ce->np);\n\t\t} else {\n\t\t\tof_node_set_flag(ce->np, OF_OVERLAY_FREE_CSET);\n\t\t}\n\t}\n\n\tof_node_put(ce->np);\n\tlist_del(&ce->node);\n\tkfree(ce);\n}\n\nstatic void __of_changeset_entry_invert(struct of_changeset_entry *ce,\n\t\t\t\t\t  struct of_changeset_entry *rce)\n{\n\tmemcpy(rce, ce, sizeof(*rce));\n\n\tswitch (ce->action) {\n\tcase OF_RECONFIG_ATTACH_NODE:\n\t\trce->action = OF_RECONFIG_DETACH_NODE;\n\t\tbreak;\n\tcase OF_RECONFIG_DETACH_NODE:\n\t\trce->action = OF_RECONFIG_ATTACH_NODE;\n\t\tbreak;\n\tcase OF_RECONFIG_ADD_PROPERTY:\n\t\trce->action = OF_RECONFIG_REMOVE_PROPERTY;\n\t\tbreak;\n\tcase OF_RECONFIG_REMOVE_PROPERTY:\n\t\trce->action = OF_RECONFIG_ADD_PROPERTY;\n\t\tbreak;\n\tcase OF_RECONFIG_UPDATE_PROPERTY:\n\t\trce->old_prop = ce->prop;\n\t\trce->prop = ce->old_prop;\n\t\t \n\t\tif (!rce->prop) {\n\t\t\trce->action = OF_RECONFIG_REMOVE_PROPERTY;\n\t\t\trce->prop = ce->prop;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int __of_changeset_entry_notify(struct of_changeset_entry *ce,\n\t\tbool revert)\n{\n\tstruct of_reconfig_data rd;\n\tstruct of_changeset_entry ce_inverted;\n\tint ret = 0;\n\n\tif (revert) {\n\t\t__of_changeset_entry_invert(ce, &ce_inverted);\n\t\tce = &ce_inverted;\n\t}\n\n\tswitch (ce->action) {\n\tcase OF_RECONFIG_ATTACH_NODE:\n\tcase OF_RECONFIG_DETACH_NODE:\n\t\tmemset(&rd, 0, sizeof(rd));\n\t\trd.dn = ce->np;\n\t\tret = of_reconfig_notify(ce->action, &rd);\n\t\tbreak;\n\tcase OF_RECONFIG_ADD_PROPERTY:\n\tcase OF_RECONFIG_REMOVE_PROPERTY:\n\tcase OF_RECONFIG_UPDATE_PROPERTY:\n\t\tret = of_property_notify(ce->action, ce->np, ce->prop, ce->old_prop);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"invalid devicetree changeset action: %i\\n\",\n\t\t\t(int)ce->action);\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tpr_err(\"changeset notifier error @%pOF\\n\", ce->np);\n\treturn ret;\n}\n\nstatic int __of_changeset_entry_apply(struct of_changeset_entry *ce)\n{\n\tint ret = 0;\n\n\tof_changeset_action_debug(\"apply: \", ce->action, ce->np, ce->prop);\n\n\tswitch (ce->action) {\n\tcase OF_RECONFIG_ATTACH_NODE:\n\t\t__of_attach_node(ce->np);\n\t\tbreak;\n\tcase OF_RECONFIG_DETACH_NODE:\n\t\t__of_detach_node(ce->np);\n\t\tbreak;\n\tcase OF_RECONFIG_ADD_PROPERTY:\n\t\tret = __of_add_property(ce->np, ce->prop);\n\t\tbreak;\n\tcase OF_RECONFIG_REMOVE_PROPERTY:\n\t\tret = __of_remove_property(ce->np, ce->prop);\n\t\tbreak;\n\n\tcase OF_RECONFIG_UPDATE_PROPERTY:\n\t\tret = __of_update_property(ce->np, ce->prop, &ce->old_prop);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret) {\n\t\tof_changeset_action_err(\"apply failed: \", ce->action, ce->np, ce->prop);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int __of_changeset_entry_revert(struct of_changeset_entry *ce)\n{\n\tstruct of_changeset_entry ce_inverted;\n\n\t__of_changeset_entry_invert(ce, &ce_inverted);\n\treturn __of_changeset_entry_apply(&ce_inverted);\n}\n\n \nvoid of_changeset_init(struct of_changeset *ocs)\n{\n\tmemset(ocs, 0, sizeof(*ocs));\n\tINIT_LIST_HEAD(&ocs->entries);\n}\nEXPORT_SYMBOL_GPL(of_changeset_init);\n\n \nvoid of_changeset_destroy(struct of_changeset *ocs)\n{\n\tstruct of_changeset_entry *ce, *cen;\n\n\tlist_for_each_entry_safe_reverse(ce, cen, &ocs->entries, node)\n\t\t__of_changeset_entry_destroy(ce);\n}\nEXPORT_SYMBOL_GPL(of_changeset_destroy);\n\n \nint __of_changeset_apply_entries(struct of_changeset *ocs, int *ret_revert)\n{\n\tstruct of_changeset_entry *ce;\n\tint ret, ret_tmp;\n\n\tpr_debug(\"changeset: applying...\\n\");\n\tlist_for_each_entry(ce, &ocs->entries, node) {\n\t\tret = __of_changeset_entry_apply(ce);\n\t\tif (ret) {\n\t\t\tpr_err(\"Error applying changeset (%d)\\n\", ret);\n\t\t\tlist_for_each_entry_continue_reverse(ce, &ocs->entries,\n\t\t\t\t\t\t\t     node) {\n\t\t\t\tret_tmp = __of_changeset_entry_revert(ce);\n\t\t\t\tif (ret_tmp)\n\t\t\t\t\t*ret_revert = ret_tmp;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint __of_changeset_apply_notify(struct of_changeset *ocs)\n{\n\tstruct of_changeset_entry *ce;\n\tint ret = 0, ret_tmp;\n\n\tpr_debug(\"changeset: emitting notifiers.\\n\");\n\n\t \n\tmutex_unlock(&of_mutex);\n\tlist_for_each_entry(ce, &ocs->entries, node) {\n\t\tret_tmp = __of_changeset_entry_notify(ce, 0);\n\t\tif (ret_tmp)\n\t\t\tret = ret_tmp;\n\t}\n\tmutex_lock(&of_mutex);\n\tpr_debug(\"changeset: notifiers sent.\\n\");\n\n\treturn ret;\n}\n\n \nstatic int __of_changeset_apply(struct of_changeset *ocs)\n{\n\tint ret, ret_revert = 0;\n\n\tret = __of_changeset_apply_entries(ocs, &ret_revert);\n\tif (!ret)\n\t\tret = __of_changeset_apply_notify(ocs);\n\n\treturn ret;\n}\n\n \nint of_changeset_apply(struct of_changeset *ocs)\n{\n\tint ret;\n\n\tmutex_lock(&of_mutex);\n\tret = __of_changeset_apply(ocs);\n\tmutex_unlock(&of_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_changeset_apply);\n\n \nint __of_changeset_revert_entries(struct of_changeset *ocs, int *ret_apply)\n{\n\tstruct of_changeset_entry *ce;\n\tint ret, ret_tmp;\n\n\tpr_debug(\"changeset: reverting...\\n\");\n\tlist_for_each_entry_reverse(ce, &ocs->entries, node) {\n\t\tret = __of_changeset_entry_revert(ce);\n\t\tif (ret) {\n\t\t\tpr_err(\"Error reverting changeset (%d)\\n\", ret);\n\t\t\tlist_for_each_entry_continue(ce, &ocs->entries, node) {\n\t\t\t\tret_tmp = __of_changeset_entry_apply(ce);\n\t\t\t\tif (ret_tmp)\n\t\t\t\t\t*ret_apply = ret_tmp;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint __of_changeset_revert_notify(struct of_changeset *ocs)\n{\n\tstruct of_changeset_entry *ce;\n\tint ret = 0, ret_tmp;\n\n\tpr_debug(\"changeset: emitting notifiers.\\n\");\n\n\t \n\tmutex_unlock(&of_mutex);\n\tlist_for_each_entry_reverse(ce, &ocs->entries, node) {\n\t\tret_tmp = __of_changeset_entry_notify(ce, 1);\n\t\tif (ret_tmp)\n\t\t\tret = ret_tmp;\n\t}\n\tmutex_lock(&of_mutex);\n\tpr_debug(\"changeset: notifiers sent.\\n\");\n\n\treturn ret;\n}\n\nstatic int __of_changeset_revert(struct of_changeset *ocs)\n{\n\tint ret, ret_reply;\n\n\tret_reply = 0;\n\tret = __of_changeset_revert_entries(ocs, &ret_reply);\n\n\tif (!ret)\n\t\tret = __of_changeset_revert_notify(ocs);\n\n\treturn ret;\n}\n\n \nint of_changeset_revert(struct of_changeset *ocs)\n{\n\tint ret;\n\n\tmutex_lock(&of_mutex);\n\tret = __of_changeset_revert(ocs);\n\tmutex_unlock(&of_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_changeset_revert);\n\n \nint of_changeset_action(struct of_changeset *ocs, unsigned long action,\n\t\tstruct device_node *np, struct property *prop)\n{\n\tstruct of_changeset_entry *ce;\n\n\tif (WARN_ON(action >= ARRAY_SIZE(action_names)))\n\t\treturn -EINVAL;\n\n\tce = kzalloc(sizeof(*ce), GFP_KERNEL);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\n\t \n\tce->action = action;\n\tce->np = of_node_get(np);\n\tce->prop = prop;\n\n\t \n\tlist_add_tail(&ce->node, &ocs->entries);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_changeset_action);\n\nstatic int of_changeset_add_prop_helper(struct of_changeset *ocs,\n\t\t\t\t\tstruct device_node *np,\n\t\t\t\t\tconst struct property *pp)\n{\n\tstruct property *new_pp;\n\tint ret;\n\n\tnew_pp = __of_prop_dup(pp, GFP_KERNEL);\n\tif (!new_pp)\n\t\treturn -ENOMEM;\n\n\tret = of_changeset_add_property(ocs, np, new_pp);\n\tif (ret) {\n\t\tkfree(new_pp->name);\n\t\tkfree(new_pp->value);\n\t\tkfree(new_pp);\n\t}\n\n\treturn ret;\n}\n\n \nint of_changeset_add_prop_string(struct of_changeset *ocs,\n\t\t\t\t struct device_node *np,\n\t\t\t\t const char *prop_name, const char *str)\n{\n\tstruct property prop;\n\n\tprop.name = (char *)prop_name;\n\tprop.length = strlen(str) + 1;\n\tprop.value = (void *)str;\n\n\treturn of_changeset_add_prop_helper(ocs, np, &prop);\n}\nEXPORT_SYMBOL_GPL(of_changeset_add_prop_string);\n\n \nint of_changeset_add_prop_string_array(struct of_changeset *ocs,\n\t\t\t\t       struct device_node *np,\n\t\t\t\t       const char *prop_name,\n\t\t\t\t       const char **str_array, size_t sz)\n{\n\tstruct property prop;\n\tint i, ret;\n\tchar *vp;\n\n\tprop.name = (char *)prop_name;\n\n\tprop.length = 0;\n\tfor (i = 0; i < sz; i++)\n\t\tprop.length += strlen(str_array[i]) + 1;\n\n\tprop.value = kmalloc(prop.length, GFP_KERNEL);\n\tif (!prop.value)\n\t\treturn -ENOMEM;\n\n\tvp = prop.value;\n\tfor (i = 0; i < sz; i++) {\n\t\tvp += snprintf(vp, (char *)prop.value + prop.length - vp, \"%s\",\n\t\t\t       str_array[i]) + 1;\n\t}\n\tret = of_changeset_add_prop_helper(ocs, np, &prop);\n\tkfree(prop.value);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_changeset_add_prop_string_array);\n\n \nint of_changeset_add_prop_u32_array(struct of_changeset *ocs,\n\t\t\t\t    struct device_node *np,\n\t\t\t\t    const char *prop_name,\n\t\t\t\t    const u32 *array, size_t sz)\n{\n\tstruct property prop;\n\t__be32 *val;\n\tint i, ret;\n\n\tval = kcalloc(sz, sizeof(__be32), GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < sz; i++)\n\t\tval[i] = cpu_to_be32(array[i]);\n\tprop.name = (char *)prop_name;\n\tprop.length = sizeof(u32) * sz;\n\tprop.value = (void *)val;\n\n\tret = of_changeset_add_prop_helper(ocs, np, &prop);\n\tkfree(val);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_changeset_add_prop_u32_array);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}