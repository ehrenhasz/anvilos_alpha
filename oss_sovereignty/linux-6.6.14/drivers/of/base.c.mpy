{
  "module_name": "base.c",
  "hash_id": "5c0114fe50085a2cedde6fe52e6a69f90a9a58b1c3b4fc963caa36be844a6daa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/base.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"OF: \" fmt\n\n#include <linux/console.h>\n#include <linux/ctype.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_graph.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/proc_fs.h>\n\n#include \"of_private.h\"\n\nLIST_HEAD(aliases_lookup);\n\nstruct device_node *of_root;\nEXPORT_SYMBOL(of_root);\nstruct device_node *of_chosen;\nEXPORT_SYMBOL(of_chosen);\nstruct device_node *of_aliases;\nstruct device_node *of_stdout;\nstatic const char *of_stdout_options;\n\nstruct kset *of_kset;\n\n \nDEFINE_MUTEX(of_mutex);\n\n \nDEFINE_RAW_SPINLOCK(devtree_lock);\n\nbool of_node_name_eq(const struct device_node *np, const char *name)\n{\n\tconst char *node_name;\n\tsize_t len;\n\n\tif (!np)\n\t\treturn false;\n\n\tnode_name = kbasename(np->full_name);\n\tlen = strchrnul(node_name, '@') - node_name;\n\n\treturn (strlen(name) == len) && (strncmp(node_name, name, len) == 0);\n}\nEXPORT_SYMBOL(of_node_name_eq);\n\nbool of_node_name_prefix(const struct device_node *np, const char *prefix)\n{\n\tif (!np)\n\t\treturn false;\n\n\treturn strncmp(kbasename(np->full_name), prefix, strlen(prefix)) == 0;\n}\nEXPORT_SYMBOL(of_node_name_prefix);\n\nstatic bool __of_node_is_type(const struct device_node *np, const char *type)\n{\n\tconst char *match = __of_get_property(np, \"device_type\", NULL);\n\n\treturn np && match && type && !strcmp(match, type);\n}\n\nint of_bus_n_addr_cells(struct device_node *np)\n{\n\tu32 cells;\n\n\tfor (; np; np = np->parent)\n\t\tif (!of_property_read_u32(np, \"#address-cells\", &cells))\n\t\t\treturn cells;\n\n\t \n\treturn OF_ROOT_NODE_ADDR_CELLS_DEFAULT;\n}\n\nint of_n_addr_cells(struct device_node *np)\n{\n\tif (np->parent)\n\t\tnp = np->parent;\n\n\treturn of_bus_n_addr_cells(np);\n}\nEXPORT_SYMBOL(of_n_addr_cells);\n\nint of_bus_n_size_cells(struct device_node *np)\n{\n\tu32 cells;\n\n\tfor (; np; np = np->parent)\n\t\tif (!of_property_read_u32(np, \"#size-cells\", &cells))\n\t\t\treturn cells;\n\n\t \n\treturn OF_ROOT_NODE_SIZE_CELLS_DEFAULT;\n}\n\nint of_n_size_cells(struct device_node *np)\n{\n\tif (np->parent)\n\t\tnp = np->parent;\n\n\treturn of_bus_n_size_cells(np);\n}\nEXPORT_SYMBOL(of_n_size_cells);\n\n#ifdef CONFIG_NUMA\nint __weak of_node_to_nid(struct device_node *np)\n{\n\treturn NUMA_NO_NODE;\n}\n#endif\n\n#define OF_PHANDLE_CACHE_BITS\t7\n#define OF_PHANDLE_CACHE_SZ\tBIT(OF_PHANDLE_CACHE_BITS)\n\nstatic struct device_node *phandle_cache[OF_PHANDLE_CACHE_SZ];\n\nstatic u32 of_phandle_cache_hash(phandle handle)\n{\n\treturn hash_32(handle, OF_PHANDLE_CACHE_BITS);\n}\n\n \nvoid __of_phandle_cache_inv_entry(phandle handle)\n{\n\tu32 handle_hash;\n\tstruct device_node *np;\n\n\tif (!handle)\n\t\treturn;\n\n\thandle_hash = of_phandle_cache_hash(handle);\n\n\tnp = phandle_cache[handle_hash];\n\tif (np && handle == np->phandle)\n\t\tphandle_cache[handle_hash] = NULL;\n}\n\nvoid __init of_core_init(void)\n{\n\tstruct device_node *np;\n\n\tof_platform_register_reconfig_notifier();\n\n\t \n\tmutex_lock(&of_mutex);\n\tof_kset = kset_create_and_add(\"devicetree\", NULL, firmware_kobj);\n\tif (!of_kset) {\n\t\tmutex_unlock(&of_mutex);\n\t\tpr_err(\"failed to register existing nodes\\n\");\n\t\treturn;\n\t}\n\tfor_each_of_allnodes(np) {\n\t\t__of_attach_node_sysfs(np);\n\t\tif (np->phandle && !phandle_cache[of_phandle_cache_hash(np->phandle)])\n\t\t\tphandle_cache[of_phandle_cache_hash(np->phandle)] = np;\n\t}\n\tmutex_unlock(&of_mutex);\n\n\t \n\tif (of_root)\n\t\tproc_symlink(\"device-tree\", NULL, \"/sys/firmware/devicetree/base\");\n}\n\nstatic struct property *__of_find_property(const struct device_node *np,\n\t\t\t\t\t   const char *name, int *lenp)\n{\n\tstruct property *pp;\n\n\tif (!np)\n\t\treturn NULL;\n\n\tfor (pp = np->properties; pp; pp = pp->next) {\n\t\tif (of_prop_cmp(pp->name, name) == 0) {\n\t\t\tif (lenp)\n\t\t\t\t*lenp = pp->length;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pp;\n}\n\nstruct property *of_find_property(const struct device_node *np,\n\t\t\t\t  const char *name,\n\t\t\t\t  int *lenp)\n{\n\tstruct property *pp;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tpp = __of_find_property(np, name, lenp);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\n\treturn pp;\n}\nEXPORT_SYMBOL(of_find_property);\n\nstruct device_node *__of_find_all_nodes(struct device_node *prev)\n{\n\tstruct device_node *np;\n\tif (!prev) {\n\t\tnp = of_root;\n\t} else if (prev->child) {\n\t\tnp = prev->child;\n\t} else {\n\t\t \n\t\tnp = prev;\n\t\twhile (np->parent && !np->sibling)\n\t\t\tnp = np->parent;\n\t\tnp = np->sibling;  \n\t}\n\treturn np;\n}\n\n \nstruct device_node *of_find_all_nodes(struct device_node *prev)\n{\n\tstruct device_node *np;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tnp = __of_find_all_nodes(prev);\n\tof_node_get(np);\n\tof_node_put(prev);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn np;\n}\nEXPORT_SYMBOL(of_find_all_nodes);\n\n \nconst void *__of_get_property(const struct device_node *np,\n\t\t\t      const char *name, int *lenp)\n{\n\tstruct property *pp = __of_find_property(np, name, lenp);\n\n\treturn pp ? pp->value : NULL;\n}\n\n \nconst void *of_get_property(const struct device_node *np, const char *name,\n\t\t\t    int *lenp)\n{\n\tstruct property *pp = of_find_property(np, name, lenp);\n\n\treturn pp ? pp->value : NULL;\n}\nEXPORT_SYMBOL(of_get_property);\n\n \nstatic int __of_device_is_compatible(const struct device_node *device,\n\t\t\t\t     const char *compat, const char *type, const char *name)\n{\n\tstruct property *prop;\n\tconst char *cp;\n\tint index = 0, score = 0;\n\n\t \n\tif (compat && compat[0]) {\n\t\tprop = __of_find_property(device, \"compatible\", NULL);\n\t\tfor (cp = of_prop_next_string(prop, NULL); cp;\n\t\t     cp = of_prop_next_string(prop, cp), index++) {\n\t\t\tif (of_compat_cmp(cp, compat, strlen(compat)) == 0) {\n\t\t\t\tscore = INT_MAX/2 - (index << 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!score)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (type && type[0]) {\n\t\tif (!__of_node_is_type(device, type))\n\t\t\treturn 0;\n\t\tscore += 2;\n\t}\n\n\t \n\tif (name && name[0]) {\n\t\tif (!of_node_name_eq(device, name))\n\t\t\treturn 0;\n\t\tscore++;\n\t}\n\n\treturn score;\n}\n\n \nint of_device_is_compatible(const struct device_node *device,\n\t\tconst char *compat)\n{\n\tunsigned long flags;\n\tint res;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tres = __of_device_is_compatible(device, compat, NULL, NULL);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn res;\n}\nEXPORT_SYMBOL(of_device_is_compatible);\n\n \nint of_device_compatible_match(const struct device_node *device,\n\t\t\t       const char *const *compat)\n{\n\tunsigned int tmp, score = 0;\n\n\tif (!compat)\n\t\treturn 0;\n\n\twhile (*compat) {\n\t\ttmp = of_device_is_compatible(device, *compat);\n\t\tif (tmp > score)\n\t\t\tscore = tmp;\n\t\tcompat++;\n\t}\n\n\treturn score;\n}\nEXPORT_SYMBOL_GPL(of_device_compatible_match);\n\n \nint of_machine_is_compatible(const char *compat)\n{\n\tstruct device_node *root;\n\tint rc = 0;\n\n\troot = of_find_node_by_path(\"/\");\n\tif (root) {\n\t\trc = of_device_is_compatible(root, compat);\n\t\tof_node_put(root);\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL(of_machine_is_compatible);\n\n \nstatic bool __of_device_is_available(const struct device_node *device)\n{\n\tconst char *status;\n\tint statlen;\n\n\tif (!device)\n\t\treturn false;\n\n\tstatus = __of_get_property(device, \"status\", &statlen);\n\tif (status == NULL)\n\t\treturn true;\n\n\tif (statlen > 0) {\n\t\tif (!strcmp(status, \"okay\") || !strcmp(status, \"ok\"))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nbool of_device_is_available(const struct device_node *device)\n{\n\tunsigned long flags;\n\tbool res;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tres = __of_device_is_available(device);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn res;\n\n}\nEXPORT_SYMBOL(of_device_is_available);\n\n \nstatic bool __of_device_is_fail(const struct device_node *device)\n{\n\tconst char *status;\n\n\tif (!device)\n\t\treturn false;\n\n\tstatus = __of_get_property(device, \"status\", NULL);\n\tif (status == NULL)\n\t\treturn false;\n\n\treturn !strcmp(status, \"fail\") || !strncmp(status, \"fail-\", 5);\n}\n\n \nbool of_device_is_big_endian(const struct device_node *device)\n{\n\tif (of_property_read_bool(device, \"big-endian\"))\n\t\treturn true;\n\tif (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&\n\t    of_property_read_bool(device, \"native-endian\"))\n\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL(of_device_is_big_endian);\n\n \nstruct device_node *of_get_parent(const struct device_node *node)\n{\n\tstruct device_node *np;\n\tunsigned long flags;\n\n\tif (!node)\n\t\treturn NULL;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tnp = of_node_get(node->parent);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn np;\n}\nEXPORT_SYMBOL(of_get_parent);\n\n \nstruct device_node *of_get_next_parent(struct device_node *node)\n{\n\tstruct device_node *parent;\n\tunsigned long flags;\n\n\tif (!node)\n\t\treturn NULL;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tparent = of_node_get(node->parent);\n\tof_node_put(node);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn parent;\n}\nEXPORT_SYMBOL(of_get_next_parent);\n\nstatic struct device_node *__of_get_next_child(const struct device_node *node,\n\t\t\t\t\t\tstruct device_node *prev)\n{\n\tstruct device_node *next;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tnext = prev ? prev->sibling : node->child;\n\tof_node_get(next);\n\tof_node_put(prev);\n\treturn next;\n}\n#define __for_each_child_of_node(parent, child) \\\n\tfor (child = __of_get_next_child(parent, NULL); child != NULL; \\\n\t     child = __of_get_next_child(parent, child))\n\n \nstruct device_node *of_get_next_child(const struct device_node *node,\n\tstruct device_node *prev)\n{\n\tstruct device_node *next;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tnext = __of_get_next_child(node, prev);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn next;\n}\nEXPORT_SYMBOL(of_get_next_child);\n\n \nstruct device_node *of_get_next_available_child(const struct device_node *node,\n\tstruct device_node *prev)\n{\n\tstruct device_node *next;\n\tunsigned long flags;\n\n\tif (!node)\n\t\treturn NULL;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tnext = prev ? prev->sibling : node->child;\n\tfor (; next; next = next->sibling) {\n\t\tif (!__of_device_is_available(next))\n\t\t\tcontinue;\n\t\tif (of_node_get(next))\n\t\t\tbreak;\n\t}\n\tof_node_put(prev);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn next;\n}\nEXPORT_SYMBOL(of_get_next_available_child);\n\n \nstruct device_node *of_get_next_cpu_node(struct device_node *prev)\n{\n\tstruct device_node *next = NULL;\n\tunsigned long flags;\n\tstruct device_node *node;\n\n\tif (!prev)\n\t\tnode = of_find_node_by_path(\"/cpus\");\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tif (prev)\n\t\tnext = prev->sibling;\n\telse if (node) {\n\t\tnext = node->child;\n\t\tof_node_put(node);\n\t}\n\tfor (; next; next = next->sibling) {\n\t\tif (__of_device_is_fail(next))\n\t\t\tcontinue;\n\t\tif (!(of_node_name_eq(next, \"cpu\") ||\n\t\t      __of_node_is_type(next, \"cpu\")))\n\t\t\tcontinue;\n\t\tif (of_node_get(next))\n\t\t\tbreak;\n\t}\n\tof_node_put(prev);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn next;\n}\nEXPORT_SYMBOL(of_get_next_cpu_node);\n\n \nstruct device_node *of_get_compatible_child(const struct device_node *parent,\n\t\t\t\tconst char *compatible)\n{\n\tstruct device_node *child;\n\n\tfor_each_child_of_node(parent, child) {\n\t\tif (of_device_is_compatible(child, compatible))\n\t\t\tbreak;\n\t}\n\n\treturn child;\n}\nEXPORT_SYMBOL(of_get_compatible_child);\n\n \nstruct device_node *of_get_child_by_name(const struct device_node *node,\n\t\t\t\tconst char *name)\n{\n\tstruct device_node *child;\n\n\tfor_each_child_of_node(node, child)\n\t\tif (of_node_name_eq(child, name))\n\t\t\tbreak;\n\treturn child;\n}\nEXPORT_SYMBOL(of_get_child_by_name);\n\nstruct device_node *__of_find_node_by_path(struct device_node *parent,\n\t\t\t\t\t\tconst char *path)\n{\n\tstruct device_node *child;\n\tint len;\n\n\tlen = strcspn(path, \"/:\");\n\tif (!len)\n\t\treturn NULL;\n\n\t__for_each_child_of_node(parent, child) {\n\t\tconst char *name = kbasename(child->full_name);\n\t\tif (strncmp(path, name, len) == 0 && (strlen(name) == len))\n\t\t\treturn child;\n\t}\n\treturn NULL;\n}\n\nstruct device_node *__of_find_node_by_full_path(struct device_node *node,\n\t\t\t\t\t\tconst char *path)\n{\n\tconst char *separator = strchr(path, ':');\n\n\twhile (node && *path == '/') {\n\t\tstruct device_node *tmp = node;\n\n\t\tpath++;  \n\t\tnode = __of_find_node_by_path(node, path);\n\t\tof_node_put(tmp);\n\t\tpath = strchrnul(path, '/');\n\t\tif (separator && separator < path)\n\t\t\tbreak;\n\t}\n\treturn node;\n}\n\n \nstruct device_node *of_find_node_opts_by_path(const char *path, const char **opts)\n{\n\tstruct device_node *np = NULL;\n\tstruct property *pp;\n\tunsigned long flags;\n\tconst char *separator = strchr(path, ':');\n\n\tif (opts)\n\t\t*opts = separator ? separator + 1 : NULL;\n\n\tif (strcmp(path, \"/\") == 0)\n\t\treturn of_node_get(of_root);\n\n\t \n\tif (*path != '/') {\n\t\tint len;\n\t\tconst char *p = separator;\n\n\t\tif (!p)\n\t\t\tp = strchrnul(path, '/');\n\t\tlen = p - path;\n\n\t\t \n\t\tif (!of_aliases)\n\t\t\treturn NULL;\n\n\t\tfor_each_property_of_node(of_aliases, pp) {\n\t\t\tif (strlen(pp->name) == len && !strncmp(pp->name, path, len)) {\n\t\t\t\tnp = of_find_node_by_path(pp->value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!np)\n\t\t\treturn NULL;\n\t\tpath = p;\n\t}\n\n\t \n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tif (!np)\n\t\tnp = of_node_get(of_root);\n\tnp = __of_find_node_by_full_path(np, path);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn np;\n}\nEXPORT_SYMBOL(of_find_node_opts_by_path);\n\n \nstruct device_node *of_find_node_by_name(struct device_node *from,\n\tconst char *name)\n{\n\tstruct device_node *np;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tfor_each_of_allnodes_from(from, np)\n\t\tif (of_node_name_eq(np, name) && of_node_get(np))\n\t\t\tbreak;\n\tof_node_put(from);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn np;\n}\nEXPORT_SYMBOL(of_find_node_by_name);\n\n \nstruct device_node *of_find_node_by_type(struct device_node *from,\n\tconst char *type)\n{\n\tstruct device_node *np;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tfor_each_of_allnodes_from(from, np)\n\t\tif (__of_node_is_type(np, type) && of_node_get(np))\n\t\t\tbreak;\n\tof_node_put(from);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn np;\n}\nEXPORT_SYMBOL(of_find_node_by_type);\n\n \nstruct device_node *of_find_compatible_node(struct device_node *from,\n\tconst char *type, const char *compatible)\n{\n\tstruct device_node *np;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tfor_each_of_allnodes_from(from, np)\n\t\tif (__of_device_is_compatible(np, compatible, type, NULL) &&\n\t\t    of_node_get(np))\n\t\t\tbreak;\n\tof_node_put(from);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn np;\n}\nEXPORT_SYMBOL(of_find_compatible_node);\n\n \nstruct device_node *of_find_node_with_property(struct device_node *from,\n\tconst char *prop_name)\n{\n\tstruct device_node *np;\n\tstruct property *pp;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tfor_each_of_allnodes_from(from, np) {\n\t\tfor (pp = np->properties; pp; pp = pp->next) {\n\t\t\tif (of_prop_cmp(pp->name, prop_name) == 0) {\n\t\t\t\tof_node_get(np);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tof_node_put(from);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn np;\n}\nEXPORT_SYMBOL(of_find_node_with_property);\n\nstatic\nconst struct of_device_id *__of_match_node(const struct of_device_id *matches,\n\t\t\t\t\t   const struct device_node *node)\n{\n\tconst struct of_device_id *best_match = NULL;\n\tint score, best_score = 0;\n\n\tif (!matches)\n\t\treturn NULL;\n\n\tfor (; matches->name[0] || matches->type[0] || matches->compatible[0]; matches++) {\n\t\tscore = __of_device_is_compatible(node, matches->compatible,\n\t\t\t\t\t\t  matches->type, matches->name);\n\t\tif (score > best_score) {\n\t\t\tbest_match = matches;\n\t\t\tbest_score = score;\n\t\t}\n\t}\n\n\treturn best_match;\n}\n\n \nconst struct of_device_id *of_match_node(const struct of_device_id *matches,\n\t\t\t\t\t const struct device_node *node)\n{\n\tconst struct of_device_id *match;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tmatch = __of_match_node(matches, node);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn match;\n}\nEXPORT_SYMBOL(of_match_node);\n\n \nstruct device_node *of_find_matching_node_and_match(struct device_node *from,\n\t\t\t\t\tconst struct of_device_id *matches,\n\t\t\t\t\tconst struct of_device_id **match)\n{\n\tstruct device_node *np;\n\tconst struct of_device_id *m;\n\tunsigned long flags;\n\n\tif (match)\n\t\t*match = NULL;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tfor_each_of_allnodes_from(from, np) {\n\t\tm = __of_match_node(matches, np);\n\t\tif (m && of_node_get(np)) {\n\t\t\tif (match)\n\t\t\t\t*match = m;\n\t\t\tbreak;\n\t\t}\n\t}\n\tof_node_put(from);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn np;\n}\nEXPORT_SYMBOL(of_find_matching_node_and_match);\n\n \nint of_alias_from_compatible(const struct device_node *node, char *alias, int len)\n{\n\tconst char *compatible, *p;\n\tint cplen;\n\n\tcompatible = of_get_property(node, \"compatible\", &cplen);\n\tif (!compatible || strlen(compatible) > cplen)\n\t\treturn -ENODEV;\n\tp = strchr(compatible, ',');\n\tstrscpy(alias, p ? p + 1 : compatible, len);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_alias_from_compatible);\n\n \nstruct device_node *of_find_node_by_phandle(phandle handle)\n{\n\tstruct device_node *np = NULL;\n\tunsigned long flags;\n\tu32 handle_hash;\n\n\tif (!handle)\n\t\treturn NULL;\n\n\thandle_hash = of_phandle_cache_hash(handle);\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\n\tif (phandle_cache[handle_hash] &&\n\t    handle == phandle_cache[handle_hash]->phandle)\n\t\tnp = phandle_cache[handle_hash];\n\n\tif (!np) {\n\t\tfor_each_of_allnodes(np)\n\t\t\tif (np->phandle == handle &&\n\t\t\t    !of_node_check_flag(np, OF_DETACHED)) {\n\t\t\t\tphandle_cache[handle_hash] = np;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\tof_node_get(np);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\treturn np;\n}\nEXPORT_SYMBOL(of_find_node_by_phandle);\n\nvoid of_print_phandle_args(const char *msg, const struct of_phandle_args *args)\n{\n\tint i;\n\tprintk(\"%s %pOF\", msg, args->np);\n\tfor (i = 0; i < args->args_count; i++) {\n\t\tconst char delim = i ? ',' : ':';\n\n\t\tpr_cont(\"%c%08x\", delim, args->args[i]);\n\t}\n\tpr_cont(\"\\n\");\n}\n\nint of_phandle_iterator_init(struct of_phandle_iterator *it,\n\t\tconst struct device_node *np,\n\t\tconst char *list_name,\n\t\tconst char *cells_name,\n\t\tint cell_count)\n{\n\tconst __be32 *list;\n\tint size;\n\n\tmemset(it, 0, sizeof(*it));\n\n\t \n\tif (cell_count < 0 && !cells_name)\n\t\treturn -EINVAL;\n\n\tlist = of_get_property(np, list_name, &size);\n\tif (!list)\n\t\treturn -ENOENT;\n\n\tit->cells_name = cells_name;\n\tit->cell_count = cell_count;\n\tit->parent = np;\n\tit->list_end = list + size / sizeof(*list);\n\tit->phandle_end = list;\n\tit->cur = list;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_phandle_iterator_init);\n\nint of_phandle_iterator_next(struct of_phandle_iterator *it)\n{\n\tuint32_t count = 0;\n\n\tif (it->node) {\n\t\tof_node_put(it->node);\n\t\tit->node = NULL;\n\t}\n\n\tif (!it->cur || it->phandle_end >= it->list_end)\n\t\treturn -ENOENT;\n\n\tit->cur = it->phandle_end;\n\n\t \n\tit->phandle = be32_to_cpup(it->cur++);\n\n\tif (it->phandle) {\n\n\t\t \n\t\tit->node = of_find_node_by_phandle(it->phandle);\n\n\t\tif (it->cells_name) {\n\t\t\tif (!it->node) {\n\t\t\t\tpr_err(\"%pOF: could not find phandle %d\\n\",\n\t\t\t\t       it->parent, it->phandle);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (of_property_read_u32(it->node, it->cells_name,\n\t\t\t\t\t\t &count)) {\n\t\t\t\t \n\t\t\t\tif (it->cell_count >= 0) {\n\t\t\t\t\tcount = it->cell_count;\n\t\t\t\t} else {\n\t\t\t\t\tpr_err(\"%pOF: could not get %s for %pOF\\n\",\n\t\t\t\t\t       it->parent,\n\t\t\t\t\t       it->cells_name,\n\t\t\t\t\t       it->node);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcount = it->cell_count;\n\t\t}\n\n\t\t \n\t\tif (it->cur + count > it->list_end) {\n\t\t\tif (it->cells_name)\n\t\t\t\tpr_err(\"%pOF: %s = %d found %td\\n\",\n\t\t\t\t\tit->parent, it->cells_name,\n\t\t\t\t\tcount, it->list_end - it->cur);\n\t\t\telse\n\t\t\t\tpr_err(\"%pOF: phandle %s needs %d, found %td\\n\",\n\t\t\t\t\tit->parent, of_node_full_name(it->node),\n\t\t\t\t\tcount, it->list_end - it->cur);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tit->phandle_end = it->cur + count;\n\tit->cur_count = count;\n\n\treturn 0;\n\nerr:\n\tif (it->node) {\n\t\tof_node_put(it->node);\n\t\tit->node = NULL;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(of_phandle_iterator_next);\n\nint of_phandle_iterator_args(struct of_phandle_iterator *it,\n\t\t\t     uint32_t *args,\n\t\t\t     int size)\n{\n\tint i, count;\n\n\tcount = it->cur_count;\n\n\tif (WARN_ON(size < count))\n\t\tcount = size;\n\n\tfor (i = 0; i < count; i++)\n\t\targs[i] = be32_to_cpup(it->cur++);\n\n\treturn count;\n}\n\nint __of_parse_phandle_with_args(const struct device_node *np,\n\t\t\t\t const char *list_name,\n\t\t\t\t const char *cells_name,\n\t\t\t\t int cell_count, int index,\n\t\t\t\t struct of_phandle_args *out_args)\n{\n\tstruct of_phandle_iterator it;\n\tint rc, cur_index = 0;\n\n\tif (index < 0)\n\t\treturn -EINVAL;\n\n\t \n\tof_for_each_phandle(&it, rc, np, list_name, cells_name, cell_count) {\n\t\t \n\t\trc = -ENOENT;\n\t\tif (cur_index == index) {\n\t\t\tif (!it.phandle)\n\t\t\t\tgoto err;\n\n\t\t\tif (out_args) {\n\t\t\t\tint c;\n\n\t\t\t\tc = of_phandle_iterator_args(&it,\n\t\t\t\t\t\t\t     out_args->args,\n\t\t\t\t\t\t\t     MAX_PHANDLE_ARGS);\n\t\t\t\tout_args->np = it.node;\n\t\t\t\tout_args->args_count = c;\n\t\t\t} else {\n\t\t\t\tof_node_put(it.node);\n\t\t\t}\n\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\n\t\tcur_index++;\n\t}\n\n\t \n\n err:\n\tof_node_put(it.node);\n\treturn rc;\n}\nEXPORT_SYMBOL(__of_parse_phandle_with_args);\n\n \nint of_parse_phandle_with_args_map(const struct device_node *np,\n\t\t\t\t   const char *list_name,\n\t\t\t\t   const char *stem_name,\n\t\t\t\t   int index, struct of_phandle_args *out_args)\n{\n\tchar *cells_name, *map_name = NULL, *mask_name = NULL;\n\tchar *pass_name = NULL;\n\tstruct device_node *cur, *new = NULL;\n\tconst __be32 *map, *mask, *pass;\n\tstatic const __be32 dummy_mask[] = { [0 ... MAX_PHANDLE_ARGS] = ~0 };\n\tstatic const __be32 dummy_pass[] = { [0 ... MAX_PHANDLE_ARGS] = 0 };\n\t__be32 initial_match_array[MAX_PHANDLE_ARGS];\n\tconst __be32 *match_array = initial_match_array;\n\tint i, ret, map_len, match;\n\tu32 list_size, new_size;\n\n\tif (index < 0)\n\t\treturn -EINVAL;\n\n\tcells_name = kasprintf(GFP_KERNEL, \"#%s-cells\", stem_name);\n\tif (!cells_name)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tmap_name = kasprintf(GFP_KERNEL, \"%s-map\", stem_name);\n\tif (!map_name)\n\t\tgoto free;\n\n\tmask_name = kasprintf(GFP_KERNEL, \"%s-map-mask\", stem_name);\n\tif (!mask_name)\n\t\tgoto free;\n\n\tpass_name = kasprintf(GFP_KERNEL, \"%s-map-pass-thru\", stem_name);\n\tif (!pass_name)\n\t\tgoto free;\n\n\tret = __of_parse_phandle_with_args(np, list_name, cells_name, -1, index,\n\t\t\t\t\t   out_args);\n\tif (ret)\n\t\tgoto free;\n\n\t \n\tcur = out_args->np;\n\tret = of_property_read_u32(cur, cells_name, &list_size);\n\tif (ret < 0)\n\t\tgoto put;\n\n\t \n\tfor (i = 0; i < list_size; i++)\n\t\tinitial_match_array[i] = cpu_to_be32(out_args->args[i]);\n\n\tret = -EINVAL;\n\twhile (cur) {\n\t\t \n\t\tmap = of_get_property(cur, map_name, &map_len);\n\t\tif (!map) {\n\t\t\tret = 0;\n\t\t\tgoto free;\n\t\t}\n\t\tmap_len /= sizeof(u32);\n\n\t\t \n\t\tmask = of_get_property(cur, mask_name, NULL);\n\t\tif (!mask)\n\t\t\tmask = dummy_mask;\n\t\t \n\t\tmatch = 0;\n\t\twhile (map_len > (list_size + 1) && !match) {\n\t\t\t \n\t\t\tmatch = 1;\n\t\t\tfor (i = 0; i < list_size; i++, map_len--)\n\t\t\t\tmatch &= !((match_array[i] ^ *map++) & mask[i]);\n\n\t\t\tof_node_put(new);\n\t\t\tnew = of_find_node_by_phandle(be32_to_cpup(map));\n\t\t\tmap++;\n\t\t\tmap_len--;\n\n\t\t\t \n\t\t\tif (!new)\n\t\t\t\tgoto put;\n\n\t\t\tif (!of_device_is_available(new))\n\t\t\t\tmatch = 0;\n\n\t\t\tret = of_property_read_u32(new, cells_name, &new_size);\n\t\t\tif (ret)\n\t\t\t\tgoto put;\n\n\t\t\t \n\t\t\tif (WARN_ON(new_size > MAX_PHANDLE_ARGS))\n\t\t\t\tgoto put;\n\t\t\tif (map_len < new_size)\n\t\t\t\tgoto put;\n\n\t\t\t \n\t\t\tmap += new_size;\n\t\t\tmap_len -= new_size;\n\t\t}\n\t\tif (!match)\n\t\t\tgoto put;\n\n\t\t \n\t\tpass = of_get_property(cur, pass_name, NULL);\n\t\tif (!pass)\n\t\t\tpass = dummy_pass;\n\n\t\t \n\t\tmatch_array = map - new_size;\n\t\tfor (i = 0; i < new_size; i++) {\n\t\t\t__be32 val = *(map - new_size + i);\n\n\t\t\tif (i < list_size) {\n\t\t\t\tval &= ~pass[i];\n\t\t\t\tval |= cpu_to_be32(out_args->args[i]) & pass[i];\n\t\t\t}\n\n\t\t\tout_args->args[i] = be32_to_cpu(val);\n\t\t}\n\t\tout_args->args_count = list_size = new_size;\n\t\t \n\t\tout_args->np = new;\n\t\tof_node_put(cur);\n\t\tcur = new;\n\t\tnew = NULL;\n\t}\nput:\n\tof_node_put(cur);\n\tof_node_put(new);\nfree:\n\tkfree(mask_name);\n\tkfree(map_name);\n\tkfree(cells_name);\n\tkfree(pass_name);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(of_parse_phandle_with_args_map);\n\n \nint of_count_phandle_with_args(const struct device_node *np, const char *list_name,\n\t\t\t\tconst char *cells_name)\n{\n\tstruct of_phandle_iterator it;\n\tint rc, cur_index = 0;\n\n\t \n\tif (!cells_name) {\n\t\tconst __be32 *list;\n\t\tint size;\n\n\t\tlist = of_get_property(np, list_name, &size);\n\t\tif (!list)\n\t\t\treturn -ENOENT;\n\n\t\treturn size / sizeof(*list);\n\t}\n\n\trc = of_phandle_iterator_init(&it, np, list_name, cells_name, -1);\n\tif (rc)\n\t\treturn rc;\n\n\twhile ((rc = of_phandle_iterator_next(&it)) == 0)\n\t\tcur_index += 1;\n\n\tif (rc != -ENOENT)\n\t\treturn rc;\n\n\treturn cur_index;\n}\nEXPORT_SYMBOL(of_count_phandle_with_args);\n\nstatic struct property *__of_remove_property_from_list(struct property **list, struct property *prop)\n{\n\tstruct property **next;\n\n\tfor (next = list; *next; next = &(*next)->next) {\n\t\tif (*next == prop) {\n\t\t\t*next = prop->next;\n\t\t\tprop->next = NULL;\n\t\t\treturn prop;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nint __of_add_property(struct device_node *np, struct property *prop)\n{\n\tint rc = 0;\n\tunsigned long flags;\n\tstruct property **next;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\n\t__of_remove_property_from_list(&np->deadprops, prop);\n\n\tprop->next = NULL;\n\tnext = &np->properties;\n\twhile (*next) {\n\t\tif (strcmp(prop->name, (*next)->name) == 0) {\n\t\t\t \n\t\t\trc = -EEXIST;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tnext = &(*next)->next;\n\t}\n\t*next = prop;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\tif (rc)\n\t\treturn rc;\n\n\t__of_add_property_sysfs(np, prop);\n\treturn 0;\n}\n\n \nint of_add_property(struct device_node *np, struct property *prop)\n{\n\tint rc;\n\n\tmutex_lock(&of_mutex);\n\trc = __of_add_property(np, prop);\n\tmutex_unlock(&of_mutex);\n\n\tif (!rc)\n\t\tof_property_notify(OF_RECONFIG_ADD_PROPERTY, np, prop, NULL);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(of_add_property);\n\nint __of_remove_property(struct device_node *np, struct property *prop)\n{\n\tunsigned long flags;\n\tint rc = -ENODEV;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\n\tif (__of_remove_property_from_list(&np->properties, prop)) {\n\t\t \n\t\tprop->next = np->deadprops;\n\t\tnp->deadprops = prop;\n\t\trc = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\tif (rc)\n\t\treturn rc;\n\n\t__of_remove_property_sysfs(np, prop);\n\treturn 0;\n}\n\n \nint of_remove_property(struct device_node *np, struct property *prop)\n{\n\tint rc;\n\n\tif (!prop)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&of_mutex);\n\trc = __of_remove_property(np, prop);\n\tmutex_unlock(&of_mutex);\n\n\tif (!rc)\n\t\tof_property_notify(OF_RECONFIG_REMOVE_PROPERTY, np, prop, NULL);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(of_remove_property);\n\nint __of_update_property(struct device_node *np, struct property *newprop,\n\t\tstruct property **oldpropp)\n{\n\tstruct property **next, *oldprop;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\n\t__of_remove_property_from_list(&np->deadprops, newprop);\n\n\tfor (next = &np->properties; *next; next = &(*next)->next) {\n\t\tif (of_prop_cmp((*next)->name, newprop->name) == 0)\n\t\t\tbreak;\n\t}\n\t*oldpropp = oldprop = *next;\n\n\tif (oldprop) {\n\t\t \n\t\tnewprop->next = oldprop->next;\n\t\t*next = newprop;\n\t\toldprop->next = np->deadprops;\n\t\tnp->deadprops = oldprop;\n\t} else {\n\t\t \n\t\tnewprop->next = NULL;\n\t\t*next = newprop;\n\t}\n\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\n\t__of_update_property_sysfs(np, newprop, oldprop);\n\n\treturn 0;\n}\n\n \nint of_update_property(struct device_node *np, struct property *newprop)\n{\n\tstruct property *oldprop;\n\tint rc;\n\n\tif (!newprop->name)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&of_mutex);\n\trc = __of_update_property(np, newprop, &oldprop);\n\tmutex_unlock(&of_mutex);\n\n\tif (!rc)\n\t\tof_property_notify(OF_RECONFIG_UPDATE_PROPERTY, np, newprop, oldprop);\n\n\treturn rc;\n}\n\nstatic void of_alias_add(struct alias_prop *ap, struct device_node *np,\n\t\t\t int id, const char *stem, int stem_len)\n{\n\tap->np = np;\n\tap->id = id;\n\tstrscpy(ap->stem, stem, stem_len + 1);\n\tlist_add_tail(&ap->link, &aliases_lookup);\n\tpr_debug(\"adding DT alias:%s: stem=%s id=%i node=%pOF\\n\",\n\t\t ap->alias, ap->stem, ap->id, np);\n}\n\n \nvoid of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))\n{\n\tstruct property *pp;\n\n\tof_aliases = of_find_node_by_path(\"/aliases\");\n\tof_chosen = of_find_node_by_path(\"/chosen\");\n\tif (of_chosen == NULL)\n\t\tof_chosen = of_find_node_by_path(\"/chosen@0\");\n\n\tif (of_chosen) {\n\t\t \n\t\tconst char *name = NULL;\n\n\t\tif (of_property_read_string(of_chosen, \"stdout-path\", &name))\n\t\t\tof_property_read_string(of_chosen, \"linux,stdout-path\",\n\t\t\t\t\t\t&name);\n\t\tif (IS_ENABLED(CONFIG_PPC) && !name)\n\t\t\tof_property_read_string(of_aliases, \"stdout\", &name);\n\t\tif (name)\n\t\t\tof_stdout = of_find_node_opts_by_path(name, &of_stdout_options);\n\t\tif (of_stdout)\n\t\t\tof_stdout->fwnode.flags |= FWNODE_FLAG_BEST_EFFORT;\n\t}\n\n\tif (!of_aliases)\n\t\treturn;\n\n\tfor_each_property_of_node(of_aliases, pp) {\n\t\tconst char *start = pp->name;\n\t\tconst char *end = start + strlen(start);\n\t\tstruct device_node *np;\n\t\tstruct alias_prop *ap;\n\t\tint id, len;\n\n\t\t \n\t\tif (!strcmp(pp->name, \"name\") ||\n\t\t    !strcmp(pp->name, \"phandle\") ||\n\t\t    !strcmp(pp->name, \"linux,phandle\"))\n\t\t\tcontinue;\n\n\t\tnp = of_find_node_by_path(pp->value);\n\t\tif (!np)\n\t\t\tcontinue;\n\n\t\t \n\t\twhile (isdigit(*(end-1)) && end > start)\n\t\t\tend--;\n\t\tlen = end - start;\n\n\t\tif (kstrtoint(end, 10, &id) < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tap = dt_alloc(sizeof(*ap) + len + 1, __alignof__(*ap));\n\t\tif (!ap)\n\t\t\tcontinue;\n\t\tmemset(ap, 0, sizeof(*ap) + len + 1);\n\t\tap->alias = start;\n\t\tof_alias_add(ap, np, id, start, len);\n\t}\n}\n\n \nint of_alias_get_id(struct device_node *np, const char *stem)\n{\n\tstruct alias_prop *app;\n\tint id = -ENODEV;\n\n\tmutex_lock(&of_mutex);\n\tlist_for_each_entry(app, &aliases_lookup, link) {\n\t\tif (strcmp(app->stem, stem) != 0)\n\t\t\tcontinue;\n\n\t\tif (np == app->np) {\n\t\t\tid = app->id;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&of_mutex);\n\n\treturn id;\n}\nEXPORT_SYMBOL_GPL(of_alias_get_id);\n\n \nint of_alias_get_highest_id(const char *stem)\n{\n\tstruct alias_prop *app;\n\tint id = -ENODEV;\n\n\tmutex_lock(&of_mutex);\n\tlist_for_each_entry(app, &aliases_lookup, link) {\n\t\tif (strcmp(app->stem, stem) != 0)\n\t\t\tcontinue;\n\n\t\tif (app->id > id)\n\t\t\tid = app->id;\n\t}\n\tmutex_unlock(&of_mutex);\n\n\treturn id;\n}\nEXPORT_SYMBOL_GPL(of_alias_get_highest_id);\n\n \nbool of_console_check(struct device_node *dn, char *name, int index)\n{\n\tif (!dn || dn != of_stdout || console_set_on_cmdline)\n\t\treturn false;\n\n\t \n\treturn !add_preferred_console(name, index, (char *)of_stdout_options);\n}\nEXPORT_SYMBOL_GPL(of_console_check);\n\n \nstruct device_node *of_find_next_cache_node(const struct device_node *np)\n{\n\tstruct device_node *child, *cache_node;\n\n\tcache_node = of_parse_phandle(np, \"l2-cache\", 0);\n\tif (!cache_node)\n\t\tcache_node = of_parse_phandle(np, \"next-level-cache\", 0);\n\n\tif (cache_node)\n\t\treturn cache_node;\n\n\t \n\tif (IS_ENABLED(CONFIG_PPC_PMAC) && of_node_is_type(np, \"cpu\"))\n\t\tfor_each_child_of_node(np, child)\n\t\t\tif (of_node_is_type(child, \"cache\"))\n\t\t\t\treturn child;\n\n\treturn NULL;\n}\n\n \nint of_find_last_cache_level(unsigned int cpu)\n{\n\tu32 cache_level = 0;\n\tstruct device_node *prev = NULL, *np = of_cpu_device_node_get(cpu);\n\n\twhile (np) {\n\t\tof_node_put(prev);\n\t\tprev = np;\n\t\tnp = of_find_next_cache_node(np);\n\t}\n\n\tof_property_read_u32(prev, \"cache-level\", &cache_level);\n\tof_node_put(prev);\n\n\treturn cache_level;\n}\n\n \nint of_map_id(struct device_node *np, u32 id,\n\t       const char *map_name, const char *map_mask_name,\n\t       struct device_node **target, u32 *id_out)\n{\n\tu32 map_mask, masked_id;\n\tint map_len;\n\tconst __be32 *map = NULL;\n\n\tif (!np || !map_name || (!target && !id_out))\n\t\treturn -EINVAL;\n\n\tmap = of_get_property(np, map_name, &map_len);\n\tif (!map) {\n\t\tif (target)\n\t\t\treturn -ENODEV;\n\t\t \n\t\t*id_out = id;\n\t\treturn 0;\n\t}\n\n\tif (!map_len || map_len % (4 * sizeof(*map))) {\n\t\tpr_err(\"%pOF: Error: Bad %s length: %d\\n\", np,\n\t\t\tmap_name, map_len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmap_mask = 0xffffffff;\n\n\t \n\tif (map_mask_name)\n\t\tof_property_read_u32(np, map_mask_name, &map_mask);\n\n\tmasked_id = map_mask & id;\n\tfor ( ; map_len > 0; map_len -= 4 * sizeof(*map), map += 4) {\n\t\tstruct device_node *phandle_node;\n\t\tu32 id_base = be32_to_cpup(map + 0);\n\t\tu32 phandle = be32_to_cpup(map + 1);\n\t\tu32 out_base = be32_to_cpup(map + 2);\n\t\tu32 id_len = be32_to_cpup(map + 3);\n\n\t\tif (id_base & ~map_mask) {\n\t\t\tpr_err(\"%pOF: Invalid %s translation - %s-mask (0x%x) ignores id-base (0x%x)\\n\",\n\t\t\t\tnp, map_name, map_name,\n\t\t\t\tmap_mask, id_base);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (masked_id < id_base || masked_id >= id_base + id_len)\n\t\t\tcontinue;\n\n\t\tphandle_node = of_find_node_by_phandle(phandle);\n\t\tif (!phandle_node)\n\t\t\treturn -ENODEV;\n\n\t\tif (target) {\n\t\t\tif (*target)\n\t\t\t\tof_node_put(phandle_node);\n\t\t\telse\n\t\t\t\t*target = phandle_node;\n\n\t\t\tif (*target != phandle_node)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (id_out)\n\t\t\t*id_out = masked_id - id_base + out_base;\n\n\t\tpr_debug(\"%pOF: %s, using mask %08x, id-base: %08x, out-base: %08x, length: %08x, id: %08x -> %08x\\n\",\n\t\t\tnp, map_name, map_mask, id_base, out_base,\n\t\t\tid_len, id, masked_id - id_base + out_base);\n\t\treturn 0;\n\t}\n\n\tpr_info(\"%pOF: no %s translation for id 0x%x on %pOF\\n\", np, map_name,\n\t\tid, target && *target ? *target : NULL);\n\n\t \n\tif (id_out)\n\t\t*id_out = id;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_map_id);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}