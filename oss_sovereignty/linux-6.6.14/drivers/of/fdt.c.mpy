{
  "module_name": "fdt.c",
  "hash_id": "0300457732e17d131afd0199bc04532df7d1b6d0e93471511d2882ce24d2027b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/fdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"OF: fdt: \" fmt\n\n#include <linux/crash_dump.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n#include <linux/initrd.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_fdt.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/sizes.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/libfdt.h>\n#include <linux/debugfs.h>\n#include <linux/serial_core.h>\n#include <linux/sysfs.h>\n#include <linux/random.h>\n\n#include <asm/setup.h>   \n#include <asm/page.h>\n\n#include \"of_private.h\"\n\n \nvoid __init of_fdt_limit_memory(int limit)\n{\n\tint memory;\n\tint len;\n\tconst void *val;\n\tint nr_address_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;\n\tint nr_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;\n\tconst __be32 *addr_prop;\n\tconst __be32 *size_prop;\n\tint root_offset;\n\tint cell_size;\n\n\troot_offset = fdt_path_offset(initial_boot_params, \"/\");\n\tif (root_offset < 0)\n\t\treturn;\n\n\taddr_prop = fdt_getprop(initial_boot_params, root_offset,\n\t\t\t\t\"#address-cells\", NULL);\n\tif (addr_prop)\n\t\tnr_address_cells = fdt32_to_cpu(*addr_prop);\n\n\tsize_prop = fdt_getprop(initial_boot_params, root_offset,\n\t\t\t\t\"#size-cells\", NULL);\n\tif (size_prop)\n\t\tnr_size_cells = fdt32_to_cpu(*size_prop);\n\n\tcell_size = sizeof(uint32_t)*(nr_address_cells + nr_size_cells);\n\n\tmemory = fdt_path_offset(initial_boot_params, \"/memory\");\n\tif (memory > 0) {\n\t\tval = fdt_getprop(initial_boot_params, memory, \"reg\", &len);\n\t\tif (len > limit*cell_size) {\n\t\t\tlen = limit*cell_size;\n\t\t\tpr_debug(\"Limiting number of entries to %d\\n\", limit);\n\t\t\tfdt_setprop(initial_boot_params, memory, \"reg\", val,\n\t\t\t\t\tlen);\n\t\t}\n\t}\n}\n\nstatic bool of_fdt_device_is_available(const void *blob, unsigned long node)\n{\n\tconst char *status = fdt_getprop(blob, node, \"status\", NULL);\n\n\tif (!status)\n\t\treturn true;\n\n\tif (!strcmp(status, \"ok\") || !strcmp(status, \"okay\"))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void *unflatten_dt_alloc(void **mem, unsigned long size,\n\t\t\t\t       unsigned long align)\n{\n\tvoid *res;\n\n\t*mem = PTR_ALIGN(*mem, align);\n\tres = *mem;\n\t*mem += size;\n\n\treturn res;\n}\n\nstatic void populate_properties(const void *blob,\n\t\t\t\tint offset,\n\t\t\t\tvoid **mem,\n\t\t\t\tstruct device_node *np,\n\t\t\t\tconst char *nodename,\n\t\t\t\tbool dryrun)\n{\n\tstruct property *pp, **pprev = NULL;\n\tint cur;\n\tbool has_name = false;\n\n\tpprev = &np->properties;\n\tfor (cur = fdt_first_property_offset(blob, offset);\n\t     cur >= 0;\n\t     cur = fdt_next_property_offset(blob, cur)) {\n\t\tconst __be32 *val;\n\t\tconst char *pname;\n\t\tu32 sz;\n\n\t\tval = fdt_getprop_by_offset(blob, cur, &pname, &sz);\n\t\tif (!val) {\n\t\t\tpr_warn(\"Cannot locate property at 0x%x\\n\", cur);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!pname) {\n\t\t\tpr_warn(\"Cannot find property name at 0x%x\\n\", cur);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(pname, \"name\"))\n\t\t\thas_name = true;\n\n\t\tpp = unflatten_dt_alloc(mem, sizeof(struct property),\n\t\t\t\t\t__alignof__(struct property));\n\t\tif (dryrun)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!strcmp(pname, \"phandle\") ||\n\t\t    !strcmp(pname, \"linux,phandle\")) {\n\t\t\tif (!np->phandle)\n\t\t\t\tnp->phandle = be32_to_cpup(val);\n\t\t}\n\n\t\t \n\t\tif (!strcmp(pname, \"ibm,phandle\"))\n\t\t\tnp->phandle = be32_to_cpup(val);\n\n\t\tpp->name   = (char *)pname;\n\t\tpp->length = sz;\n\t\tpp->value  = (__be32 *)val;\n\t\t*pprev     = pp;\n\t\tpprev      = &pp->next;\n\t}\n\n\t \n\tif (!has_name) {\n\t\tconst char *p = nodename, *ps = p, *pa = NULL;\n\t\tint len;\n\n\t\twhile (*p) {\n\t\t\tif ((*p) == '@')\n\t\t\t\tpa = p;\n\t\t\telse if ((*p) == '/')\n\t\t\t\tps = p + 1;\n\t\t\tp++;\n\t\t}\n\n\t\tif (pa < ps)\n\t\t\tpa = p;\n\t\tlen = (pa - ps) + 1;\n\t\tpp = unflatten_dt_alloc(mem, sizeof(struct property) + len,\n\t\t\t\t\t__alignof__(struct property));\n\t\tif (!dryrun) {\n\t\t\tpp->name   = \"name\";\n\t\t\tpp->length = len;\n\t\t\tpp->value  = pp + 1;\n\t\t\t*pprev     = pp;\n\t\t\tmemcpy(pp->value, ps, len - 1);\n\t\t\t((char *)pp->value)[len - 1] = 0;\n\t\t\tpr_debug(\"fixed up name for %s -> %s\\n\",\n\t\t\t\t nodename, (char *)pp->value);\n\t\t}\n\t}\n}\n\nstatic int populate_node(const void *blob,\n\t\t\t  int offset,\n\t\t\t  void **mem,\n\t\t\t  struct device_node *dad,\n\t\t\t  struct device_node **pnp,\n\t\t\t  bool dryrun)\n{\n\tstruct device_node *np;\n\tconst char *pathp;\n\tint len;\n\n\tpathp = fdt_get_name(blob, offset, &len);\n\tif (!pathp) {\n\t\t*pnp = NULL;\n\t\treturn len;\n\t}\n\n\tlen++;\n\n\tnp = unflatten_dt_alloc(mem, sizeof(struct device_node) + len,\n\t\t\t\t__alignof__(struct device_node));\n\tif (!dryrun) {\n\t\tchar *fn;\n\t\tof_node_init(np);\n\t\tnp->full_name = fn = ((char *)np) + sizeof(*np);\n\n\t\tmemcpy(fn, pathp, len);\n\n\t\tif (dad != NULL) {\n\t\t\tnp->parent = dad;\n\t\t\tnp->sibling = dad->child;\n\t\t\tdad->child = np;\n\t\t}\n\t}\n\n\tpopulate_properties(blob, offset, mem, np, pathp, dryrun);\n\tif (!dryrun) {\n\t\tnp->name = of_get_property(np, \"name\", NULL);\n\t\tif (!np->name)\n\t\t\tnp->name = \"<NULL>\";\n\t}\n\n\t*pnp = np;\n\treturn 0;\n}\n\nstatic void reverse_nodes(struct device_node *parent)\n{\n\tstruct device_node *child, *next;\n\n\t \n\tchild = parent->child;\n\twhile (child) {\n\t\treverse_nodes(child);\n\n\t\tchild = child->sibling;\n\t}\n\n\t \n\tchild = parent->child;\n\tparent->child = NULL;\n\twhile (child) {\n\t\tnext = child->sibling;\n\n\t\tchild->sibling = parent->child;\n\t\tparent->child = child;\n\t\tchild = next;\n\t}\n}\n\n \nstatic int unflatten_dt_nodes(const void *blob,\n\t\t\t      void *mem,\n\t\t\t      struct device_node *dad,\n\t\t\t      struct device_node **nodepp)\n{\n\tstruct device_node *root;\n\tint offset = 0, depth = 0, initial_depth = 0;\n#define FDT_MAX_DEPTH\t64\n\tstruct device_node *nps[FDT_MAX_DEPTH];\n\tvoid *base = mem;\n\tbool dryrun = !base;\n\tint ret;\n\n\tif (nodepp)\n\t\t*nodepp = NULL;\n\n\t \n\tif (dad)\n\t\tdepth = initial_depth = 1;\n\n\troot = dad;\n\tnps[depth] = dad;\n\n\tfor (offset = 0;\n\t     offset >= 0 && depth >= initial_depth;\n\t     offset = fdt_next_node(blob, offset, &depth)) {\n\t\tif (WARN_ON_ONCE(depth >= FDT_MAX_DEPTH - 1))\n\t\t\tcontinue;\n\n\t\tif (!IS_ENABLED(CONFIG_OF_KOBJ) &&\n\t\t    !of_fdt_device_is_available(blob, offset))\n\t\t\tcontinue;\n\n\t\tret = populate_node(blob, offset, &mem, nps[depth],\n\t\t\t\t   &nps[depth+1], dryrun);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!dryrun && nodepp && !*nodepp)\n\t\t\t*nodepp = nps[depth+1];\n\t\tif (!dryrun && !root)\n\t\t\troot = nps[depth+1];\n\t}\n\n\tif (offset < 0 && offset != -FDT_ERR_NOTFOUND) {\n\t\tpr_err(\"Error %d processing FDT\\n\", offset);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!dryrun)\n\t\treverse_nodes(root);\n\n\treturn mem - base;\n}\n\n \nvoid *__unflatten_device_tree(const void *blob,\n\t\t\t      struct device_node *dad,\n\t\t\t      struct device_node **mynodes,\n\t\t\t      void *(*dt_alloc)(u64 size, u64 align),\n\t\t\t      bool detached)\n{\n\tint size;\n\tvoid *mem;\n\tint ret;\n\n\tif (mynodes)\n\t\t*mynodes = NULL;\n\n\tpr_debug(\" -> unflatten_device_tree()\\n\");\n\n\tif (!blob) {\n\t\tpr_debug(\"No device tree pointer\\n\");\n\t\treturn NULL;\n\t}\n\n\tpr_debug(\"Unflattening device tree:\\n\");\n\tpr_debug(\"magic: %08x\\n\", fdt_magic(blob));\n\tpr_debug(\"size: %08x\\n\", fdt_totalsize(blob));\n\tpr_debug(\"version: %08x\\n\", fdt_version(blob));\n\n\tif (fdt_check_header(blob)) {\n\t\tpr_err(\"Invalid device tree blob header\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tsize = unflatten_dt_nodes(blob, NULL, dad, NULL);\n\tif (size <= 0)\n\t\treturn NULL;\n\n\tsize = ALIGN(size, 4);\n\tpr_debug(\"  size is %d, allocating...\\n\", size);\n\n\t \n\tmem = dt_alloc(size + 4, __alignof__(struct device_node));\n\tif (!mem)\n\t\treturn NULL;\n\n\tmemset(mem, 0, size);\n\n\t*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);\n\n\tpr_debug(\"  unflattening %p...\\n\", mem);\n\n\t \n\tret = unflatten_dt_nodes(blob, mem, dad, mynodes);\n\n\tif (be32_to_cpup(mem + size) != 0xdeadbeef)\n\t\tpr_warn(\"End of tree marker overwritten: %08x\\n\",\n\t\t\tbe32_to_cpup(mem + size));\n\n\tif (ret <= 0)\n\t\treturn NULL;\n\n\tif (detached && mynodes && *mynodes) {\n\t\tof_node_set_flag(*mynodes, OF_DETACHED);\n\t\tpr_debug(\"unflattened tree is detached\\n\");\n\t}\n\n\tpr_debug(\" <- unflatten_device_tree()\\n\");\n\treturn mem;\n}\n\nstatic void *kernel_tree_alloc(u64 size, u64 align)\n{\n\treturn kzalloc(size, GFP_KERNEL);\n}\n\nstatic DEFINE_MUTEX(of_fdt_unflatten_mutex);\n\n \nvoid *of_fdt_unflatten_tree(const unsigned long *blob,\n\t\t\t    struct device_node *dad,\n\t\t\t    struct device_node **mynodes)\n{\n\tvoid *mem;\n\n\tmutex_lock(&of_fdt_unflatten_mutex);\n\tmem = __unflatten_device_tree(blob, dad, mynodes, &kernel_tree_alloc,\n\t\t\t\t      true);\n\tmutex_unlock(&of_fdt_unflatten_mutex);\n\n\treturn mem;\n}\nEXPORT_SYMBOL_GPL(of_fdt_unflatten_tree);\n\n \nint __initdata dt_root_addr_cells;\nint __initdata dt_root_size_cells;\n\nvoid *initial_boot_params __ro_after_init;\n\n#ifdef CONFIG_OF_EARLY_FLATTREE\n\nstatic u32 of_fdt_crc32;\n\nstatic int __init early_init_dt_reserve_memory(phys_addr_t base,\n\t\t\t\t\t       phys_addr_t size, bool nomap)\n{\n\tif (nomap) {\n\t\t \n\t\tif (memblock_overlaps_region(&memblock.memory, base, size) &&\n\t\t    memblock_is_region_reserved(base, size))\n\t\t\treturn -EBUSY;\n\n\t\treturn memblock_mark_nomap(base, size);\n\t}\n\treturn memblock_reserve(base, size);\n}\n\n \nstatic int __init __reserved_mem_reserve_reg(unsigned long node,\n\t\t\t\t\t     const char *uname)\n{\n\tint t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);\n\tphys_addr_t base, size;\n\tint len;\n\tconst __be32 *prop;\n\tint first = 1;\n\tbool nomap;\n\n\tprop = of_get_flat_dt_prop(node, \"reg\", &len);\n\tif (!prop)\n\t\treturn -ENOENT;\n\n\tif (len && len % t_len != 0) {\n\t\tpr_err(\"Reserved memory: invalid reg property in '%s', skipping node.\\n\",\n\t\t       uname);\n\t\treturn -EINVAL;\n\t}\n\n\tnomap = of_get_flat_dt_prop(node, \"no-map\", NULL) != NULL;\n\n\twhile (len >= t_len) {\n\t\tbase = dt_mem_next_cell(dt_root_addr_cells, &prop);\n\t\tsize = dt_mem_next_cell(dt_root_size_cells, &prop);\n\n\t\tif (size &&\n\t\t    early_init_dt_reserve_memory(base, size, nomap) == 0)\n\t\t\tpr_debug(\"Reserved memory: reserved region for node '%s': base %pa, size %lu MiB\\n\",\n\t\t\t\tuname, &base, (unsigned long)(size / SZ_1M));\n\t\telse\n\t\t\tpr_err(\"Reserved memory: failed to reserve memory for node '%s': base %pa, size %lu MiB\\n\",\n\t\t\t       uname, &base, (unsigned long)(size / SZ_1M));\n\n\t\tlen -= t_len;\n\t\tif (first) {\n\t\t\tfdt_reserved_mem_save_node(node, uname, base, size);\n\t\t\tfirst = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int __init __reserved_mem_check_root(unsigned long node)\n{\n\tconst __be32 *prop;\n\n\tprop = of_get_flat_dt_prop(node, \"#size-cells\", NULL);\n\tif (!prop || be32_to_cpup(prop) != dt_root_size_cells)\n\t\treturn -EINVAL;\n\n\tprop = of_get_flat_dt_prop(node, \"#address-cells\", NULL);\n\tif (!prop || be32_to_cpup(prop) != dt_root_addr_cells)\n\t\treturn -EINVAL;\n\n\tprop = of_get_flat_dt_prop(node, \"ranges\", NULL);\n\tif (!prop)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int __init fdt_scan_reserved_mem(void)\n{\n\tint node, child;\n\tconst void *fdt = initial_boot_params;\n\n\tnode = fdt_path_offset(fdt, \"/reserved-memory\");\n\tif (node < 0)\n\t\treturn -ENODEV;\n\n\tif (__reserved_mem_check_root(node) != 0) {\n\t\tpr_err(\"Reserved memory: unsupported node format, ignoring\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfdt_for_each_subnode(child, fdt, node) {\n\t\tconst char *uname;\n\t\tint err;\n\n\t\tif (!of_fdt_device_is_available(fdt, child))\n\t\t\tcontinue;\n\n\t\tuname = fdt_get_name(fdt, child, NULL);\n\n\t\terr = __reserved_mem_reserve_reg(child, uname);\n\t\tif (err == -ENOENT && of_get_flat_dt_prop(child, \"size\", NULL))\n\t\t\tfdt_reserved_mem_save_node(child, uname, 0, 0);\n\t}\n\treturn 0;\n}\n\n \nstatic void __init fdt_reserve_elfcorehdr(void)\n{\n\tif (!IS_ENABLED(CONFIG_CRASH_DUMP) || !elfcorehdr_size)\n\t\treturn;\n\n\tif (memblock_is_region_reserved(elfcorehdr_addr, elfcorehdr_size)) {\n\t\tpr_warn(\"elfcorehdr is overlapped\\n\");\n\t\treturn;\n\t}\n\n\tmemblock_reserve(elfcorehdr_addr, elfcorehdr_size);\n\n\tpr_info(\"Reserving %llu KiB of memory at 0x%llx for elfcorehdr\\n\",\n\t\telfcorehdr_size >> 10, elfcorehdr_addr);\n}\n\n \nvoid __init early_init_fdt_scan_reserved_mem(void)\n{\n\tint n;\n\tu64 base, size;\n\n\tif (!initial_boot_params)\n\t\treturn;\n\n\tfdt_scan_reserved_mem();\n\tfdt_reserve_elfcorehdr();\n\n\t \n\tfor (n = 0; ; n++) {\n\t\tfdt_get_mem_rsv(initial_boot_params, n, &base, &size);\n\t\tif (!size)\n\t\t\tbreak;\n\t\tmemblock_reserve(base, size);\n\t}\n\n\tfdt_init_reserved_mem();\n}\n\n \nvoid __init early_init_fdt_reserve_self(void)\n{\n\tif (!initial_boot_params)\n\t\treturn;\n\n\t \n\tmemblock_reserve(__pa(initial_boot_params),\n\t\t\t fdt_totalsize(initial_boot_params));\n}\n\n \nint __init of_scan_flat_dt(int (*it)(unsigned long node,\n\t\t\t\t     const char *uname, int depth,\n\t\t\t\t     void *data),\n\t\t\t   void *data)\n{\n\tconst void *blob = initial_boot_params;\n\tconst char *pathp;\n\tint offset, rc = 0, depth = -1;\n\n\tif (!blob)\n\t\treturn 0;\n\n\tfor (offset = fdt_next_node(blob, -1, &depth);\n\t     offset >= 0 && depth >= 0 && !rc;\n\t     offset = fdt_next_node(blob, offset, &depth)) {\n\n\t\tpathp = fdt_get_name(blob, offset, NULL);\n\t\trc = it(offset, pathp, depth, data);\n\t}\n\treturn rc;\n}\n\n \nint __init of_scan_flat_dt_subnodes(unsigned long parent,\n\t\t\t\t    int (*it)(unsigned long node,\n\t\t\t\t\t      const char *uname,\n\t\t\t\t\t      void *data),\n\t\t\t\t    void *data)\n{\n\tconst void *blob = initial_boot_params;\n\tint node;\n\n\tfdt_for_each_subnode(node, blob, parent) {\n\t\tconst char *pathp;\n\t\tint rc;\n\n\t\tpathp = fdt_get_name(blob, node, NULL);\n\t\trc = it(node, pathp, data);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\n \n\nint __init of_get_flat_dt_subnode_by_name(unsigned long node, const char *uname)\n{\n\treturn fdt_subnode_offset(initial_boot_params, node, uname);\n}\n\n \nunsigned long __init of_get_flat_dt_root(void)\n{\n\treturn 0;\n}\n\n \nconst void *__init of_get_flat_dt_prop(unsigned long node, const char *name,\n\t\t\t\t       int *size)\n{\n\treturn fdt_getprop(initial_boot_params, node, name, size);\n}\n\n \nstatic int of_fdt_is_compatible(const void *blob,\n\t\t      unsigned long node, const char *compat)\n{\n\tconst char *cp;\n\tint cplen;\n\tunsigned long l, score = 0;\n\n\tcp = fdt_getprop(blob, node, \"compatible\", &cplen);\n\tif (cp == NULL)\n\t\treturn 0;\n\twhile (cplen > 0) {\n\t\tscore++;\n\t\tif (of_compat_cmp(cp, compat, strlen(compat)) == 0)\n\t\t\treturn score;\n\t\tl = strlen(cp) + 1;\n\t\tcp += l;\n\t\tcplen -= l;\n\t}\n\n\treturn 0;\n}\n\n \nint __init of_flat_dt_is_compatible(unsigned long node, const char *compat)\n{\n\treturn of_fdt_is_compatible(initial_boot_params, node, compat);\n}\n\n \nstatic int __init of_flat_dt_match(unsigned long node, const char *const *compat)\n{\n\tunsigned int tmp, score = 0;\n\n\tif (!compat)\n\t\treturn 0;\n\n\twhile (*compat) {\n\t\ttmp = of_fdt_is_compatible(initial_boot_params, node, *compat);\n\t\tif (tmp && (score == 0 || (tmp < score)))\n\t\t\tscore = tmp;\n\t\tcompat++;\n\t}\n\n\treturn score;\n}\n\n \nuint32_t __init of_get_flat_dt_phandle(unsigned long node)\n{\n\treturn fdt_get_phandle(initial_boot_params, node);\n}\n\nconst char * __init of_flat_dt_get_machine_name(void)\n{\n\tconst char *name;\n\tunsigned long dt_root = of_get_flat_dt_root();\n\n\tname = of_get_flat_dt_prop(dt_root, \"model\", NULL);\n\tif (!name)\n\t\tname = of_get_flat_dt_prop(dt_root, \"compatible\", NULL);\n\treturn name;\n}\n\n \nconst void * __init of_flat_dt_match_machine(const void *default_match,\n\t\tconst void * (*get_next_compat)(const char * const**))\n{\n\tconst void *data = NULL;\n\tconst void *best_data = default_match;\n\tconst char *const *compat;\n\tunsigned long dt_root;\n\tunsigned int best_score = ~1, score = 0;\n\n\tdt_root = of_get_flat_dt_root();\n\twhile ((data = get_next_compat(&compat))) {\n\t\tscore = of_flat_dt_match(dt_root, compat);\n\t\tif (score > 0 && score < best_score) {\n\t\t\tbest_data = data;\n\t\t\tbest_score = score;\n\t\t}\n\t}\n\tif (!best_data) {\n\t\tconst char *prop;\n\t\tint size;\n\n\t\tpr_err(\"\\n unrecognized device tree list:\\n[ \");\n\n\t\tprop = of_get_flat_dt_prop(dt_root, \"compatible\", &size);\n\t\tif (prop) {\n\t\t\twhile (size > 0) {\n\t\t\t\tprintk(\"'%s' \", prop);\n\t\t\t\tsize -= strlen(prop) + 1;\n\t\t\t\tprop += strlen(prop) + 1;\n\t\t\t}\n\t\t}\n\t\tprintk(\"]\\n\\n\");\n\t\treturn NULL;\n\t}\n\n\tpr_info(\"Machine model: %s\\n\", of_flat_dt_get_machine_name());\n\n\treturn best_data;\n}\n\nstatic void __early_init_dt_declare_initrd(unsigned long start,\n\t\t\t\t\t   unsigned long end)\n{\n\t \n\tif (!IS_ENABLED(CONFIG_ARM64) &&\n\t    !(IS_ENABLED(CONFIG_RISCV) && IS_ENABLED(CONFIG_64BIT))) {\n\t\tinitrd_start = (unsigned long)__va(start);\n\t\tinitrd_end = (unsigned long)__va(end);\n\t\tinitrd_below_start_ok = 1;\n\t}\n}\n\n \nstatic void __init early_init_dt_check_for_initrd(unsigned long node)\n{\n\tu64 start, end;\n\tint len;\n\tconst __be32 *prop;\n\n\tif (!IS_ENABLED(CONFIG_BLK_DEV_INITRD))\n\t\treturn;\n\n\tpr_debug(\"Looking for initrd properties... \");\n\n\tprop = of_get_flat_dt_prop(node, \"linux,initrd-start\", &len);\n\tif (!prop)\n\t\treturn;\n\tstart = of_read_number(prop, len/4);\n\n\tprop = of_get_flat_dt_prop(node, \"linux,initrd-end\", &len);\n\tif (!prop)\n\t\treturn;\n\tend = of_read_number(prop, len/4);\n\tif (start > end)\n\t\treturn;\n\n\t__early_init_dt_declare_initrd(start, end);\n\tphys_initrd_start = start;\n\tphys_initrd_size = end - start;\n\n\tpr_debug(\"initrd_start=0x%llx  initrd_end=0x%llx\\n\", start, end);\n}\n\n \nstatic void __init early_init_dt_check_for_elfcorehdr(unsigned long node)\n{\n\tconst __be32 *prop;\n\tint len;\n\n\tif (!IS_ENABLED(CONFIG_CRASH_DUMP))\n\t\treturn;\n\n\tpr_debug(\"Looking for elfcorehdr property... \");\n\n\tprop = of_get_flat_dt_prop(node, \"linux,elfcorehdr\", &len);\n\tif (!prop || (len < (dt_root_addr_cells + dt_root_size_cells)))\n\t\treturn;\n\n\telfcorehdr_addr = dt_mem_next_cell(dt_root_addr_cells, &prop);\n\telfcorehdr_size = dt_mem_next_cell(dt_root_size_cells, &prop);\n\n\tpr_debug(\"elfcorehdr_start=0x%llx elfcorehdr_size=0x%llx\\n\",\n\t\t elfcorehdr_addr, elfcorehdr_size);\n}\n\nstatic unsigned long chosen_node_offset = -FDT_ERR_NOTFOUND;\n\n \n#define MAX_USABLE_RANGES\t\t2\n\n \nvoid __init early_init_dt_check_for_usable_mem_range(void)\n{\n\tstruct memblock_region rgn[MAX_USABLE_RANGES] = {0};\n\tconst __be32 *prop, *endp;\n\tint len, i;\n\tunsigned long node = chosen_node_offset;\n\n\tif ((long)node < 0)\n\t\treturn;\n\n\tpr_debug(\"Looking for usable-memory-range property... \");\n\n\tprop = of_get_flat_dt_prop(node, \"linux,usable-memory-range\", &len);\n\tif (!prop || (len % (dt_root_addr_cells + dt_root_size_cells)))\n\t\treturn;\n\n\tendp = prop + (len / sizeof(__be32));\n\tfor (i = 0; i < MAX_USABLE_RANGES && prop < endp; i++) {\n\t\trgn[i].base = dt_mem_next_cell(dt_root_addr_cells, &prop);\n\t\trgn[i].size = dt_mem_next_cell(dt_root_size_cells, &prop);\n\n\t\tpr_debug(\"cap_mem_regions[%d]: base=%pa, size=%pa\\n\",\n\t\t\t i, &rgn[i].base, &rgn[i].size);\n\t}\n\n\tmemblock_cap_memory_range(rgn[0].base, rgn[0].size);\n\tfor (i = 1; i < MAX_USABLE_RANGES && rgn[i].size; i++)\n\t\tmemblock_add(rgn[i].base, rgn[i].size);\n}\n\n#ifdef CONFIG_SERIAL_EARLYCON\n\nint __init early_init_dt_scan_chosen_stdout(void)\n{\n\tint offset;\n\tconst char *p, *q, *options = NULL;\n\tint l;\n\tconst struct earlycon_id *match;\n\tconst void *fdt = initial_boot_params;\n\tint ret;\n\n\toffset = fdt_path_offset(fdt, \"/chosen\");\n\tif (offset < 0)\n\t\toffset = fdt_path_offset(fdt, \"/chosen@0\");\n\tif (offset < 0)\n\t\treturn -ENOENT;\n\n\tp = fdt_getprop(fdt, offset, \"stdout-path\", &l);\n\tif (!p)\n\t\tp = fdt_getprop(fdt, offset, \"linux,stdout-path\", &l);\n\tif (!p || !l)\n\t\treturn -ENOENT;\n\n\tq = strchrnul(p, ':');\n\tif (*q != '\\0')\n\t\toptions = q + 1;\n\tl = q - p;\n\n\t \n\toffset = fdt_path_offset_namelen(fdt, p, l);\n\tif (offset < 0) {\n\t\tpr_warn(\"earlycon: stdout-path %.*s not found\\n\", l, p);\n\t\treturn 0;\n\t}\n\n\tfor (match = __earlycon_table; match < __earlycon_table_end; match++) {\n\t\tif (!match->compatible[0])\n\t\t\tcontinue;\n\n\t\tif (fdt_node_check_compatible(fdt, offset, match->compatible))\n\t\t\tcontinue;\n\n\t\tret = of_setup_earlycon(match, offset, options);\n\t\tif (!ret || ret == -EALREADY)\n\t\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n#endif\n\n \nint __init early_init_dt_scan_root(void)\n{\n\tconst __be32 *prop;\n\tconst void *fdt = initial_boot_params;\n\tint node = fdt_path_offset(fdt, \"/\");\n\n\tif (node < 0)\n\t\treturn -ENODEV;\n\n\tdt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;\n\tdt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;\n\n\tprop = of_get_flat_dt_prop(node, \"#size-cells\", NULL);\n\tif (prop)\n\t\tdt_root_size_cells = be32_to_cpup(prop);\n\tpr_debug(\"dt_root_size_cells = %x\\n\", dt_root_size_cells);\n\n\tprop = of_get_flat_dt_prop(node, \"#address-cells\", NULL);\n\tif (prop)\n\t\tdt_root_addr_cells = be32_to_cpup(prop);\n\tpr_debug(\"dt_root_addr_cells = %x\\n\", dt_root_addr_cells);\n\n\treturn 0;\n}\n\nu64 __init dt_mem_next_cell(int s, const __be32 **cellp)\n{\n\tconst __be32 *p = *cellp;\n\n\t*cellp = p + s;\n\treturn of_read_number(p, s);\n}\n\n \nint __init early_init_dt_scan_memory(void)\n{\n\tint node, found_memory = 0;\n\tconst void *fdt = initial_boot_params;\n\n\tfdt_for_each_subnode(node, fdt, 0) {\n\t\tconst char *type = of_get_flat_dt_prop(node, \"device_type\", NULL);\n\t\tconst __be32 *reg, *endp;\n\t\tint l;\n\t\tbool hotpluggable;\n\n\t\t \n\t\tif (type == NULL || strcmp(type, \"memory\") != 0)\n\t\t\tcontinue;\n\n\t\tif (!of_fdt_device_is_available(fdt, node))\n\t\t\tcontinue;\n\n\t\treg = of_get_flat_dt_prop(node, \"linux,usable-memory\", &l);\n\t\tif (reg == NULL)\n\t\t\treg = of_get_flat_dt_prop(node, \"reg\", &l);\n\t\tif (reg == NULL)\n\t\t\tcontinue;\n\n\t\tendp = reg + (l / sizeof(__be32));\n\t\thotpluggable = of_get_flat_dt_prop(node, \"hotpluggable\", NULL);\n\n\t\tpr_debug(\"memory scan node %s, reg size %d,\\n\",\n\t\t\t fdt_get_name(fdt, node, NULL), l);\n\n\t\twhile ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {\n\t\t\tu64 base, size;\n\n\t\t\tbase = dt_mem_next_cell(dt_root_addr_cells, &reg);\n\t\t\tsize = dt_mem_next_cell(dt_root_size_cells, &reg);\n\n\t\t\tif (size == 0)\n\t\t\t\tcontinue;\n\t\t\tpr_debug(\" - %llx, %llx\\n\", base, size);\n\n\t\t\tearly_init_dt_add_memory_arch(base, size);\n\n\t\t\tfound_memory = 1;\n\n\t\t\tif (!hotpluggable)\n\t\t\t\tcontinue;\n\n\t\t\tif (memblock_mark_hotplug(base, size))\n\t\t\t\tpr_warn(\"failed to mark hotplug range 0x%llx - 0x%llx\\n\",\n\t\t\t\t\tbase, base + size);\n\t\t}\n\t}\n\treturn found_memory;\n}\n\nint __init early_init_dt_scan_chosen(char *cmdline)\n{\n\tint l, node;\n\tconst char *p;\n\tconst void *rng_seed;\n\tconst void *fdt = initial_boot_params;\n\n\tnode = fdt_path_offset(fdt, \"/chosen\");\n\tif (node < 0)\n\t\tnode = fdt_path_offset(fdt, \"/chosen@0\");\n\tif (node < 0)\n\t\t \n\t\tgoto handle_cmdline;\n\n\tchosen_node_offset = node;\n\n\tearly_init_dt_check_for_initrd(node);\n\tearly_init_dt_check_for_elfcorehdr(node);\n\n\trng_seed = of_get_flat_dt_prop(node, \"rng-seed\", &l);\n\tif (rng_seed && l > 0) {\n\t\tadd_bootloader_randomness(rng_seed, l);\n\n\t\t \n\t\tfdt_nop_property(initial_boot_params, node, \"rng-seed\");\n\n\t\t \n\t\tof_fdt_crc32 = crc32_be(~0, initial_boot_params,\n\t\t\t\tfdt_totalsize(initial_boot_params));\n\t}\n\n\t \n\tp = of_get_flat_dt_prop(node, \"bootargs\", &l);\n\tif (p != NULL && l > 0)\n\t\tstrscpy(cmdline, p, min(l, COMMAND_LINE_SIZE));\n\nhandle_cmdline:\n\t \n#ifdef CONFIG_CMDLINE\n#if defined(CONFIG_CMDLINE_EXTEND)\n\tstrlcat(cmdline, \" \", COMMAND_LINE_SIZE);\n\tstrlcat(cmdline, CONFIG_CMDLINE, COMMAND_LINE_SIZE);\n#elif defined(CONFIG_CMDLINE_FORCE)\n\tstrscpy(cmdline, CONFIG_CMDLINE, COMMAND_LINE_SIZE);\n#else\n\t \n\tif (!((char *)cmdline)[0])\n\t\tstrscpy(cmdline, CONFIG_CMDLINE, COMMAND_LINE_SIZE);\n#endif\n#endif  \n\n\tpr_debug(\"Command line is: %s\\n\", (char *)cmdline);\n\n\treturn 0;\n}\n\n#ifndef MIN_MEMBLOCK_ADDR\n#define MIN_MEMBLOCK_ADDR\t__pa(PAGE_OFFSET)\n#endif\n#ifndef MAX_MEMBLOCK_ADDR\n#define MAX_MEMBLOCK_ADDR\t((phys_addr_t)~0)\n#endif\n\nvoid __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)\n{\n\tconst u64 phys_offset = MIN_MEMBLOCK_ADDR;\n\n\tif (size < PAGE_SIZE - (base & ~PAGE_MASK)) {\n\t\tpr_warn(\"Ignoring memory block 0x%llx - 0x%llx\\n\",\n\t\t\tbase, base + size);\n\t\treturn;\n\t}\n\n\tif (!PAGE_ALIGNED(base)) {\n\t\tsize -= PAGE_SIZE - (base & ~PAGE_MASK);\n\t\tbase = PAGE_ALIGN(base);\n\t}\n\tsize &= PAGE_MASK;\n\n\tif (base > MAX_MEMBLOCK_ADDR) {\n\t\tpr_warn(\"Ignoring memory block 0x%llx - 0x%llx\\n\",\n\t\t\tbase, base + size);\n\t\treturn;\n\t}\n\n\tif (base + size - 1 > MAX_MEMBLOCK_ADDR) {\n\t\tpr_warn(\"Ignoring memory range 0x%llx - 0x%llx\\n\",\n\t\t\t((u64)MAX_MEMBLOCK_ADDR) + 1, base + size);\n\t\tsize = MAX_MEMBLOCK_ADDR - base + 1;\n\t}\n\n\tif (base + size < phys_offset) {\n\t\tpr_warn(\"Ignoring memory block 0x%llx - 0x%llx\\n\",\n\t\t\tbase, base + size);\n\t\treturn;\n\t}\n\tif (base < phys_offset) {\n\t\tpr_warn(\"Ignoring memory range 0x%llx - 0x%llx\\n\",\n\t\t\tbase, phys_offset);\n\t\tsize -= phys_offset - base;\n\t\tbase = phys_offset;\n\t}\n\tmemblock_add(base, size);\n}\n\nstatic void * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)\n{\n\tvoid *ptr = memblock_alloc(size, align);\n\n\tif (!ptr)\n\t\tpanic(\"%s: Failed to allocate %llu bytes align=0x%llx\\n\",\n\t\t      __func__, size, align);\n\n\treturn ptr;\n}\n\nbool __init early_init_dt_verify(void *params)\n{\n\tif (!params)\n\t\treturn false;\n\n\t \n\tif (fdt_check_header(params))\n\t\treturn false;\n\n\t \n\tinitial_boot_params = params;\n\tof_fdt_crc32 = crc32_be(~0, initial_boot_params,\n\t\t\t\tfdt_totalsize(initial_boot_params));\n\treturn true;\n}\n\n\nvoid __init early_init_dt_scan_nodes(void)\n{\n\tint rc;\n\n\t \n\tearly_init_dt_scan_root();\n\n\t \n\trc = early_init_dt_scan_chosen(boot_command_line);\n\tif (rc)\n\t\tpr_warn(\"No chosen node found, continuing without\\n\");\n\n\t \n\tearly_init_dt_scan_memory();\n\n\t \n\tearly_init_dt_check_for_usable_mem_range();\n}\n\nbool __init early_init_dt_scan(void *params)\n{\n\tbool status;\n\n\tstatus = early_init_dt_verify(params);\n\tif (!status)\n\t\treturn false;\n\n\tearly_init_dt_scan_nodes();\n\treturn true;\n}\n\n \nvoid __init unflatten_device_tree(void)\n{\n\t__unflatten_device_tree(initial_boot_params, NULL, &of_root,\n\t\t\t\tearly_init_dt_alloc_memory_arch, false);\n\n\t \n\tof_alias_scan(early_init_dt_alloc_memory_arch);\n\n\tunittest_unflatten_overlay_base();\n}\n\n \nvoid __init unflatten_and_copy_device_tree(void)\n{\n\tint size;\n\tvoid *dt;\n\n\tif (!initial_boot_params) {\n\t\tpr_warn(\"No valid device tree found, continuing without\\n\");\n\t\treturn;\n\t}\n\n\tsize = fdt_totalsize(initial_boot_params);\n\tdt = early_init_dt_alloc_memory_arch(size,\n\t\t\t\t\t     roundup_pow_of_two(FDT_V17_SIZE));\n\n\tif (dt) {\n\t\tmemcpy(dt, initial_boot_params, size);\n\t\tinitial_boot_params = dt;\n\t}\n\tunflatten_device_tree();\n}\n\n#ifdef CONFIG_SYSFS\nstatic ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *bin_attr,\n\t\t\t       char *buf, loff_t off, size_t count)\n{\n\tmemcpy(buf, initial_boot_params + off, count);\n\treturn count;\n}\n\nstatic int __init of_fdt_raw_init(void)\n{\n\tstatic struct bin_attribute of_fdt_raw_attr =\n\t\t__BIN_ATTR(fdt, S_IRUSR, of_fdt_raw_read, NULL, 0);\n\n\tif (!initial_boot_params)\n\t\treturn 0;\n\n\tif (of_fdt_crc32 != crc32_be(~0, initial_boot_params,\n\t\t\t\t     fdt_totalsize(initial_boot_params))) {\n\t\tpr_warn(\"not creating '/sys/firmware/fdt': CRC check failed\\n\");\n\t\treturn 0;\n\t}\n\tof_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);\n\treturn sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);\n}\nlate_initcall(of_fdt_raw_init);\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}