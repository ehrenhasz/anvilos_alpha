{
  "module_name": "irq.c",
  "hash_id": "d6bcf4ac484d0cadeb7cd76faef7db61fca07b2d075e1e0a5cc2750a95ce5fda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/irq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"OF: \" fmt\n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n \nunsigned int irq_of_parse_and_map(struct device_node *dev, int index)\n{\n\tstruct of_phandle_args oirq;\n\n\tif (of_irq_parse_one(dev, index, &oirq))\n\t\treturn 0;\n\n\treturn irq_create_of_mapping(&oirq);\n}\nEXPORT_SYMBOL_GPL(irq_of_parse_and_map);\n\n \nstruct device_node *of_irq_find_parent(struct device_node *child)\n{\n\tstruct device_node *p;\n\tphandle parent;\n\n\tif (!of_node_get(child))\n\t\treturn NULL;\n\n\tdo {\n\t\tif (of_property_read_u32(child, \"interrupt-parent\", &parent)) {\n\t\t\tp = of_get_parent(child);\n\t\t} else\t{\n\t\t\tif (of_irq_workarounds & OF_IMAP_NO_PHANDLE)\n\t\t\t\tp = of_node_get(of_irq_dflt_pic);\n\t\t\telse\n\t\t\t\tp = of_find_node_by_phandle(parent);\n\t\t}\n\t\tof_node_put(child);\n\t\tchild = p;\n\t} while (p && of_get_property(p, \"#interrupt-cells\", NULL) == NULL);\n\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(of_irq_find_parent);\n\n \nstatic const char * const of_irq_imap_abusers[] = {\n\t\"CBEA,platform-spider-pic\",\n\t\"sti,platform-spider-pic\",\n\t\"realtek,rtl-intc\",\n\t\"fsl,ls1021a-extirq\",\n\t\"fsl,ls1043a-extirq\",\n\t\"fsl,ls1088a-extirq\",\n\t\"renesas,rza1-irqc\",\n\tNULL,\n};\n\n \nint of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)\n{\n\tstruct device_node *ipar, *tnode, *old = NULL, *newpar = NULL;\n\t__be32 initial_match_array[MAX_PHANDLE_ARGS];\n\tconst __be32 *match_array = initial_match_array;\n\tconst __be32 *tmp, *imap, *imask, dummy_imask[] = { [0 ... MAX_PHANDLE_ARGS] = cpu_to_be32(~0) };\n\tu32 intsize = 1, addrsize, newintsize = 0, newaddrsize = 0;\n\tint imaplen, match, i, rc = -EINVAL;\n\n#ifdef DEBUG\n\tof_print_phandle_args(\"of_irq_parse_raw: \", out_irq);\n#endif\n\n\tipar = of_node_get(out_irq->np);\n\n\t \n\tdo {\n\t\tif (!of_property_read_u32(ipar, \"#interrupt-cells\", &intsize))\n\t\t\tbreak;\n\t\ttnode = ipar;\n\t\tipar = of_irq_find_parent(ipar);\n\t\tof_node_put(tnode);\n\t} while (ipar);\n\tif (ipar == NULL) {\n\t\tpr_debug(\" -> no parent found !\\n\");\n\t\tgoto fail;\n\t}\n\n\tpr_debug(\"of_irq_parse_raw: ipar=%pOF, size=%d\\n\", ipar, intsize);\n\n\tif (out_irq->args_count != intsize)\n\t\tgoto fail;\n\n\t \n\told = of_node_get(ipar);\n\tdo {\n\t\ttmp = of_get_property(old, \"#address-cells\", NULL);\n\t\ttnode = of_get_parent(old);\n\t\tof_node_put(old);\n\t\told = tnode;\n\t} while (old && tmp == NULL);\n\tof_node_put(old);\n\told = NULL;\n\taddrsize = (tmp == NULL) ? 2 : be32_to_cpu(*tmp);\n\n\tpr_debug(\" -> addrsize=%d\\n\", addrsize);\n\n\t \n\tif (WARN_ON(addrsize + intsize > MAX_PHANDLE_ARGS)) {\n\t\trc = -EFAULT;\n\t\tgoto fail;\n\t}\n\n\t \n\tfor (i = 0; i < addrsize; i++)\n\t\tinitial_match_array[i] = addr ? addr[i] : 0;\n\tfor (i = 0; i < intsize; i++)\n\t\tinitial_match_array[addrsize + i] = cpu_to_be32(out_irq->args[i]);\n\n\t \n\twhile (ipar != NULL) {\n\t\t \n\t\tbool intc = of_property_read_bool(ipar, \"interrupt-controller\");\n\n\t\timap = of_get_property(ipar, \"interrupt-map\", &imaplen);\n\t\tif (intc &&\n\t\t    (!imap || of_device_compatible_match(ipar, of_irq_imap_abusers))) {\n\t\t\tpr_debug(\" -> got it !\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (addrsize && !addr) {\n\t\t\tpr_debug(\" -> no reg passed in when needed !\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\tif (imap == NULL) {\n\t\t\tpr_debug(\" -> no map, getting parent\\n\");\n\t\t\tnewpar = of_irq_find_parent(ipar);\n\t\t\tgoto skiplevel;\n\t\t}\n\t\timaplen /= sizeof(u32);\n\n\t\t \n\t\timask = of_get_property(ipar, \"interrupt-map-mask\", NULL);\n\t\tif (!imask)\n\t\t\timask = dummy_imask;\n\n\t\t \n\t\tmatch = 0;\n\t\twhile (imaplen > (addrsize + intsize + 1) && !match) {\n\t\t\t \n\t\t\tmatch = 1;\n\t\t\tfor (i = 0; i < (addrsize + intsize); i++, imaplen--)\n\t\t\t\tmatch &= !((match_array[i] ^ *imap++) & imask[i]);\n\n\t\t\tpr_debug(\" -> match=%d (imaplen=%d)\\n\", match, imaplen);\n\n\t\t\t \n\t\t\tif (of_irq_workarounds & OF_IMAP_NO_PHANDLE)\n\t\t\t\tnewpar = of_node_get(of_irq_dflt_pic);\n\t\t\telse\n\t\t\t\tnewpar = of_find_node_by_phandle(be32_to_cpup(imap));\n\t\t\timap++;\n\t\t\t--imaplen;\n\n\t\t\t \n\t\t\tif (newpar == NULL) {\n\t\t\t\tpr_debug(\" -> imap parent not found !\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (!of_device_is_available(newpar))\n\t\t\t\tmatch = 0;\n\n\t\t\t \n\t\t\tif (of_property_read_u32(newpar, \"#interrupt-cells\",\n\t\t\t\t\t\t &newintsize)) {\n\t\t\t\tpr_debug(\" -> parent lacks #interrupt-cells!\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (of_property_read_u32(newpar, \"#address-cells\",\n\t\t\t\t\t\t &newaddrsize))\n\t\t\t\tnewaddrsize = 0;\n\n\t\t\tpr_debug(\" -> newintsize=%d, newaddrsize=%d\\n\",\n\t\t\t    newintsize, newaddrsize);\n\n\t\t\t \n\t\t\tif (WARN_ON(newaddrsize + newintsize > MAX_PHANDLE_ARGS)\n\t\t\t    || (imaplen < (newaddrsize + newintsize))) {\n\t\t\t\trc = -EFAULT;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\timap += newaddrsize + newintsize;\n\t\t\timaplen -= newaddrsize + newintsize;\n\n\t\t\tpr_debug(\" -> imaplen=%d\\n\", imaplen);\n\t\t}\n\t\tif (!match) {\n\t\t\tif (intc) {\n\t\t\t\t \n\t\t\t\tWARN(!IS_ENABLED(CONFIG_PPC_PASEMI),\n\t\t\t\t     \"%pOF interrupt-map failed, using interrupt-controller\\n\",\n\t\t\t\t     ipar);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\tmatch_array = imap - newaddrsize - newintsize;\n\t\tfor (i = 0; i < newintsize; i++)\n\t\t\tout_irq->args[i] = be32_to_cpup(imap - newintsize + i);\n\t\tout_irq->args_count = intsize = newintsize;\n\t\taddrsize = newaddrsize;\n\n\t\tif (ipar == newpar) {\n\t\t\tpr_debug(\"%pOF interrupt-map entry to self\\n\", ipar);\n\t\t\treturn 0;\n\t\t}\n\n\tskiplevel:\n\t\t \n\t\tout_irq->np = newpar;\n\t\tpr_debug(\" -> new parent: %pOF\\n\", newpar);\n\t\tof_node_put(ipar);\n\t\tipar = newpar;\n\t\tnewpar = NULL;\n\t}\n\trc = -ENOENT;  \n\n fail:\n\tof_node_put(ipar);\n\tof_node_put(newpar);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(of_irq_parse_raw);\n\n \nint of_irq_parse_one(struct device_node *device, int index, struct of_phandle_args *out_irq)\n{\n\tstruct device_node *p;\n\tconst __be32 *addr;\n\tu32 intsize;\n\tint i, res;\n\n\tpr_debug(\"of_irq_parse_one: dev=%pOF, index=%d\\n\", device, index);\n\n\t \n\tif (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)\n\t\treturn of_irq_parse_oldworld(device, index, out_irq);\n\n\t \n\taddr = of_get_property(device, \"reg\", NULL);\n\n\t \n\tres = of_parse_phandle_with_args(device, \"interrupts-extended\",\n\t\t\t\t\t\"#interrupt-cells\", index, out_irq);\n\tif (!res)\n\t\treturn of_irq_parse_raw(addr, out_irq);\n\n\t \n\tp = of_irq_find_parent(device);\n\tif (p == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tif (of_property_read_u32(p, \"#interrupt-cells\", &intsize)) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\" parent=%pOF, intsize=%d\\n\", p, intsize);\n\n\t \n\tout_irq->np = p;\n\tout_irq->args_count = intsize;\n\tfor (i = 0; i < intsize; i++) {\n\t\tres = of_property_read_u32_index(device, \"interrupts\",\n\t\t\t\t\t\t (index * intsize) + i,\n\t\t\t\t\t\t out_irq->args + i);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\tpr_debug(\" intspec=%d\\n\", *out_irq->args);\n\n\n\t \n\tres = of_irq_parse_raw(addr, out_irq);\n out:\n\tof_node_put(p);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(of_irq_parse_one);\n\n \nint of_irq_to_resource(struct device_node *dev, int index, struct resource *r)\n{\n\tint irq = of_irq_get(dev, index);\n\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tif (r && irq) {\n\t\tconst char *name = NULL;\n\n\t\tmemset(r, 0, sizeof(*r));\n\t\t \n\t\tof_property_read_string_index(dev, \"interrupt-names\", index,\n\t\t\t\t\t      &name);\n\n\t\tr->start = r->end = irq;\n\t\tr->flags = IORESOURCE_IRQ | irqd_get_trigger_type(irq_get_irq_data(irq));\n\t\tr->name = name ? name : of_node_full_name(dev);\n\t}\n\n\treturn irq;\n}\nEXPORT_SYMBOL_GPL(of_irq_to_resource);\n\n \nint of_irq_get(struct device_node *dev, int index)\n{\n\tint rc;\n\tstruct of_phandle_args oirq;\n\tstruct irq_domain *domain;\n\n\trc = of_irq_parse_one(dev, index, &oirq);\n\tif (rc)\n\t\treturn rc;\n\n\tdomain = irq_find_host(oirq.np);\n\tif (!domain) {\n\t\trc = -EPROBE_DEFER;\n\t\tgoto out;\n\t}\n\n\trc = irq_create_of_mapping(&oirq);\nout:\n\tof_node_put(oirq.np);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(of_irq_get);\n\n \nint of_irq_get_byname(struct device_node *dev, const char *name)\n{\n\tint index;\n\n\tif (unlikely(!name))\n\t\treturn -EINVAL;\n\n\tindex = of_property_match_string(dev, \"interrupt-names\", name);\n\tif (index < 0)\n\t\treturn index;\n\n\treturn of_irq_get(dev, index);\n}\nEXPORT_SYMBOL_GPL(of_irq_get_byname);\n\n \nint of_irq_count(struct device_node *dev)\n{\n\tstruct of_phandle_args irq;\n\tint nr = 0;\n\n\twhile (of_irq_parse_one(dev, nr, &irq) == 0)\n\t\tnr++;\n\n\treturn nr;\n}\n\n \nint of_irq_to_resource_table(struct device_node *dev, struct resource *res,\n\t\tint nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++, res++)\n\t\tif (of_irq_to_resource(dev, i, res) <= 0)\n\t\t\tbreak;\n\n\treturn i;\n}\nEXPORT_SYMBOL_GPL(of_irq_to_resource_table);\n\nstruct of_intc_desc {\n\tstruct list_head\tlist;\n\tof_irq_init_cb_t\tirq_init_cb;\n\tstruct device_node\t*dev;\n\tstruct device_node\t*interrupt_parent;\n};\n\n \nvoid __init of_irq_init(const struct of_device_id *matches)\n{\n\tconst struct of_device_id *match;\n\tstruct device_node *np, *parent = NULL;\n\tstruct of_intc_desc *desc, *temp_desc;\n\tstruct list_head intc_desc_list, intc_parent_list;\n\n\tINIT_LIST_HEAD(&intc_desc_list);\n\tINIT_LIST_HEAD(&intc_parent_list);\n\n\tfor_each_matching_node_and_match(np, matches, &match) {\n\t\tif (!of_property_read_bool(np, \"interrupt-controller\") ||\n\t\t\t\t!of_device_is_available(np))\n\t\t\tcontinue;\n\n\t\tif (WARN(!match->data, \"of_irq_init: no init function for %s\\n\",\n\t\t\t match->compatible))\n\t\t\tcontinue;\n\n\t\t \n\t\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\t\tif (!desc) {\n\t\t\tof_node_put(np);\n\t\t\tgoto err;\n\t\t}\n\n\t\tdesc->irq_init_cb = match->data;\n\t\tdesc->dev = of_node_get(np);\n\t\t \n\t\tdesc->interrupt_parent = of_parse_phandle(np, \"interrupts-extended\", 0);\n\t\tif (!desc->interrupt_parent)\n\t\t\tdesc->interrupt_parent = of_irq_find_parent(np);\n\t\tif (desc->interrupt_parent == np) {\n\t\t\tof_node_put(desc->interrupt_parent);\n\t\t\tdesc->interrupt_parent = NULL;\n\t\t}\n\t\tlist_add_tail(&desc->list, &intc_desc_list);\n\t}\n\n\t \n\twhile (!list_empty(&intc_desc_list)) {\n\t\t \n\t\tlist_for_each_entry_safe(desc, temp_desc, &intc_desc_list, list) {\n\t\t\tint ret;\n\n\t\t\tif (desc->interrupt_parent != parent)\n\t\t\t\tcontinue;\n\n\t\t\tlist_del(&desc->list);\n\n\t\t\tof_node_set_flag(desc->dev, OF_POPULATED);\n\n\t\t\tpr_debug(\"of_irq_init: init %pOF (%p), parent %p\\n\",\n\t\t\t\t desc->dev,\n\t\t\t\t desc->dev, desc->interrupt_parent);\n\t\t\tret = desc->irq_init_cb(desc->dev,\n\t\t\t\t\t\tdesc->interrupt_parent);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"%s: Failed to init %pOF (%p), parent %p\\n\",\n\t\t\t\t       __func__, desc->dev, desc->dev,\n\t\t\t\t       desc->interrupt_parent);\n\t\t\t\tof_node_clear_flag(desc->dev, OF_POPULATED);\n\t\t\t\tkfree(desc);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tlist_add_tail(&desc->list, &intc_parent_list);\n\t\t}\n\n\t\t \n\t\tdesc = list_first_entry_or_null(&intc_parent_list,\n\t\t\t\t\t\ttypeof(*desc), list);\n\t\tif (!desc) {\n\t\t\tpr_err(\"of_irq_init: children remain, but no parents\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlist_del(&desc->list);\n\t\tparent = desc->dev;\n\t\tkfree(desc);\n\t}\n\n\tlist_for_each_entry_safe(desc, temp_desc, &intc_parent_list, list) {\n\t\tlist_del(&desc->list);\n\t\tkfree(desc);\n\t}\nerr:\n\tlist_for_each_entry_safe(desc, temp_desc, &intc_desc_list, list) {\n\t\tlist_del(&desc->list);\n\t\tof_node_put(desc->dev);\n\t\tkfree(desc);\n\t}\n}\n\nstatic u32 __of_msi_map_id(struct device *dev, struct device_node **np,\n\t\t\t    u32 id_in)\n{\n\tstruct device *parent_dev;\n\tu32 id_out = id_in;\n\n\t \n\tfor (parent_dev = dev; parent_dev; parent_dev = parent_dev->parent)\n\t\tif (!of_map_id(parent_dev->of_node, id_in, \"msi-map\",\n\t\t\t\t\"msi-map-mask\", np, &id_out))\n\t\t\tbreak;\n\treturn id_out;\n}\n\n \nu32 of_msi_map_id(struct device *dev, struct device_node *msi_np, u32 id_in)\n{\n\treturn __of_msi_map_id(dev, &msi_np, id_in);\n}\n\n \nstruct irq_domain *of_msi_map_get_device_domain(struct device *dev, u32 id,\n\t\t\t\t\t\tu32 bus_token)\n{\n\tstruct device_node *np = NULL;\n\n\t__of_msi_map_id(dev, &np, id);\n\treturn irq_find_matching_host(np, bus_token);\n}\n\n \nstruct irq_domain *of_msi_get_domain(struct device *dev,\n\t\t\t\t     struct device_node *np,\n\t\t\t\t     enum irq_domain_bus_token token)\n{\n\tstruct device_node *msi_np;\n\tstruct irq_domain *d;\n\n\t \n\tmsi_np = of_parse_phandle(np, \"msi-parent\", 0);\n\tif (msi_np && !of_property_read_bool(msi_np, \"#msi-cells\")) {\n\t\td = irq_find_matching_host(msi_np, token);\n\t\tif (!d)\n\t\t\tof_node_put(msi_np);\n\t\treturn d;\n\t}\n\n\tif (token == DOMAIN_BUS_PLATFORM_MSI) {\n\t\t \n\t\tstruct of_phandle_args args;\n\t\tint index = 0;\n\n\t\twhile (!of_parse_phandle_with_args(np, \"msi-parent\",\n\t\t\t\t\t\t   \"#msi-cells\",\n\t\t\t\t\t\t   index, &args)) {\n\t\t\td = irq_find_matching_host(args.np, token);\n\t\t\tif (d)\n\t\t\t\treturn d;\n\n\t\t\tof_node_put(args.np);\n\t\t\tindex++;\n\t\t}\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(of_msi_get_domain);\n\n \nvoid of_msi_configure(struct device *dev, struct device_node *np)\n{\n\tdev_set_msi_domain(dev,\n\t\t\t   of_msi_get_domain(dev, np, DOMAIN_BUS_PLATFORM_MSI));\n}\nEXPORT_SYMBOL_GPL(of_msi_configure);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}