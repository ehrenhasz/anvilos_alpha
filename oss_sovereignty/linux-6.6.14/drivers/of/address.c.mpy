{
  "module_name": "address.c",
  "hash_id": "e3ba95695a9987e32bf65c47b9d769df182d3ed9e859e374fe66028793e3614f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/address.c",
  "human_readable_source": "\n#define pr_fmt(fmt)\t\"OF: \" fmt\n\n#include <linux/device.h>\n#include <linux/fwnode.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/logic_pio.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/pci_regs.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/dma-direct.h>  \n\n#include \"of_private.h\"\n\n \n#define OF_MAX_ADDR_CELLS\t4\n#define OF_CHECK_ADDR_COUNT(na)\t((na) > 0 && (na) <= OF_MAX_ADDR_CELLS)\n#define OF_CHECK_COUNTS(na, ns)\t(OF_CHECK_ADDR_COUNT(na) && (ns) > 0)\n\n \n#ifdef DEBUG\nstatic void of_dump_addr(const char *s, const __be32 *addr, int na)\n{\n\tpr_debug(\"%s\", s);\n\twhile (na--)\n\t\tpr_cont(\" %08x\", be32_to_cpu(*(addr++)));\n\tpr_cont(\"\\n\");\n}\n#else\nstatic void of_dump_addr(const char *s, const __be32 *addr, int na) { }\n#endif\n\n \nstruct of_bus {\n\tconst char\t*name;\n\tconst char\t*addresses;\n\tint\t\t(*match)(struct device_node *parent);\n\tvoid\t\t(*count_cells)(struct device_node *child,\n\t\t\t\t       int *addrc, int *sizec);\n\tu64\t\t(*map)(__be32 *addr, const __be32 *range,\n\t\t\t\tint na, int ns, int pna);\n\tint\t\t(*translate)(__be32 *addr, u64 offset, int na);\n\tbool\thas_flags;\n\tunsigned int\t(*get_flags)(const __be32 *addr);\n};\n\n \n\nstatic void of_bus_default_count_cells(struct device_node *dev,\n\t\t\t\t       int *addrc, int *sizec)\n{\n\tif (addrc)\n\t\t*addrc = of_n_addr_cells(dev);\n\tif (sizec)\n\t\t*sizec = of_n_size_cells(dev);\n}\n\nstatic u64 of_bus_default_map(__be32 *addr, const __be32 *range,\n\t\tint na, int ns, int pna)\n{\n\tu64 cp, s, da;\n\n\tcp = of_read_number(range, na);\n\ts  = of_read_number(range + na + pna, ns);\n\tda = of_read_number(addr, na);\n\n\tpr_debug(\"default map, cp=%llx, s=%llx, da=%llx\\n\", cp, s, da);\n\n\tif (da < cp || da >= (cp + s))\n\t\treturn OF_BAD_ADDR;\n\treturn da - cp;\n}\n\nstatic int of_bus_default_translate(__be32 *addr, u64 offset, int na)\n{\n\tu64 a = of_read_number(addr, na);\n\tmemset(addr, 0, na * 4);\n\ta += offset;\n\tif (na > 1)\n\t\taddr[na - 2] = cpu_to_be32(a >> 32);\n\taddr[na - 1] = cpu_to_be32(a & 0xffffffffu);\n\n\treturn 0;\n}\n\nstatic unsigned int of_bus_default_flags_get_flags(const __be32 *addr)\n{\n\treturn of_read_number(addr, 1);\n}\n\nstatic unsigned int of_bus_default_get_flags(const __be32 *addr)\n{\n\treturn IORESOURCE_MEM;\n}\n\nstatic u64 of_bus_default_flags_map(__be32 *addr, const __be32 *range, int na,\n\t\t\t\t    int ns, int pna)\n{\n\tu64 cp, s, da;\n\n\t \n\tif (*addr != *range)\n\t\treturn OF_BAD_ADDR;\n\n\t \n\tcp = of_read_number(range + 1, na - 1);\n\ts  = of_read_number(range + na + pna, ns);\n\tda = of_read_number(addr + 1, na - 1);\n\n\tpr_debug(\"default flags map, cp=%llx, s=%llx, da=%llx\\n\", cp, s, da);\n\n\tif (da < cp || da >= (cp + s))\n\t\treturn OF_BAD_ADDR;\n\treturn da - cp;\n}\n\nstatic int of_bus_default_flags_translate(__be32 *addr, u64 offset, int na)\n{\n\t \n\treturn of_bus_default_translate(addr + 1, offset, na - 1);\n}\n\n#ifdef CONFIG_PCI\nstatic unsigned int of_bus_pci_get_flags(const __be32 *addr)\n{\n\tunsigned int flags = 0;\n\tu32 w = be32_to_cpup(addr);\n\n\tif (!IS_ENABLED(CONFIG_PCI))\n\t\treturn 0;\n\n\tswitch((w >> 24) & 0x03) {\n\tcase 0x01:\n\t\tflags |= IORESOURCE_IO;\n\t\tbreak;\n\tcase 0x02:  \n\t\tflags |= IORESOURCE_MEM;\n\t\tbreak;\n\n\tcase 0x03:  \n\t\tflags |= IORESOURCE_MEM | IORESOURCE_MEM_64;\n\t\tbreak;\n\t}\n\tif (w & 0x40000000)\n\t\tflags |= IORESOURCE_PREFETCH;\n\treturn flags;\n}\n\n \n\nstatic bool of_node_is_pcie(struct device_node *np)\n{\n\tbool is_pcie = of_node_name_eq(np, \"pcie\");\n\n\tif (is_pcie)\n\t\tpr_warn_once(\"%pOF: Missing device_type\\n\", np);\n\n\treturn is_pcie;\n}\n\nstatic int of_bus_pci_match(struct device_node *np)\n{\n\t \n\treturn of_node_is_type(np, \"pci\") || of_node_is_type(np, \"pciex\") ||\n\t\tof_node_is_type(np, \"vci\") || of_node_is_type(np, \"ht\") ||\n\t\tof_node_is_pcie(np);\n}\n\nstatic void of_bus_pci_count_cells(struct device_node *np,\n\t\t\t\t   int *addrc, int *sizec)\n{\n\tif (addrc)\n\t\t*addrc = 3;\n\tif (sizec)\n\t\t*sizec = 2;\n}\n\nstatic u64 of_bus_pci_map(__be32 *addr, const __be32 *range, int na, int ns,\n\t\tint pna)\n{\n\tu64 cp, s, da;\n\tunsigned int af, rf;\n\n\taf = of_bus_pci_get_flags(addr);\n\trf = of_bus_pci_get_flags(range);\n\n\t \n\tif ((af ^ rf) & (IORESOURCE_MEM | IORESOURCE_IO))\n\t\treturn OF_BAD_ADDR;\n\n\t \n\tcp = of_read_number(range + 1, na - 1);\n\ts  = of_read_number(range + na + pna, ns);\n\tda = of_read_number(addr + 1, na - 1);\n\n\tpr_debug(\"PCI map, cp=%llx, s=%llx, da=%llx\\n\", cp, s, da);\n\n\tif (da < cp || da >= (cp + s))\n\t\treturn OF_BAD_ADDR;\n\treturn da - cp;\n}\n\nstatic int of_bus_pci_translate(__be32 *addr, u64 offset, int na)\n{\n\treturn of_bus_default_translate(addr + 1, offset, na - 1);\n}\n#endif  \n\n \nint of_pci_range_to_resource(struct of_pci_range *range,\n\t\t\t     struct device_node *np, struct resource *res)\n{\n\tint err;\n\tres->flags = range->flags;\n\tres->parent = res->child = res->sibling = NULL;\n\tres->name = np->full_name;\n\n\tif (res->flags & IORESOURCE_IO) {\n\t\tunsigned long port;\n\t\terr = pci_register_io_range(&np->fwnode, range->cpu_addr,\n\t\t\t\trange->size);\n\t\tif (err)\n\t\t\tgoto invalid_range;\n\t\tport = pci_address_to_pio(range->cpu_addr);\n\t\tif (port == (unsigned long)-1) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto invalid_range;\n\t\t}\n\t\tres->start = port;\n\t} else {\n\t\tif ((sizeof(resource_size_t) < 8) &&\n\t\t    upper_32_bits(range->cpu_addr)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto invalid_range;\n\t\t}\n\n\t\tres->start = range->cpu_addr;\n\t}\n\tres->end = res->start + range->size - 1;\n\treturn 0;\n\ninvalid_range:\n\tres->start = (resource_size_t)OF_BAD_ADDR;\n\tres->end = (resource_size_t)OF_BAD_ADDR;\n\treturn err;\n}\nEXPORT_SYMBOL(of_pci_range_to_resource);\n\n \nint of_range_to_resource(struct device_node *np, int index, struct resource *res)\n{\n\tint ret, i = 0;\n\tstruct of_range_parser parser;\n\tstruct of_range range;\n\n\tret = of_range_parser_init(&parser, np);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_of_range(&parser, &range)\n\t\tif (i++ == index)\n\t\t\treturn of_pci_range_to_resource(&range, np, res);\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL(of_range_to_resource);\n\n \n\nstatic int of_bus_isa_match(struct device_node *np)\n{\n\treturn of_node_name_eq(np, \"isa\");\n}\n\nstatic void of_bus_isa_count_cells(struct device_node *child,\n\t\t\t\t   int *addrc, int *sizec)\n{\n\tif (addrc)\n\t\t*addrc = 2;\n\tif (sizec)\n\t\t*sizec = 1;\n}\n\nstatic u64 of_bus_isa_map(__be32 *addr, const __be32 *range, int na, int ns,\n\t\tint pna)\n{\n\tu64 cp, s, da;\n\n\t \n\tif ((addr[0] ^ range[0]) & cpu_to_be32(1))\n\t\treturn OF_BAD_ADDR;\n\n\t \n\tcp = of_read_number(range + 1, na - 1);\n\ts  = of_read_number(range + na + pna, ns);\n\tda = of_read_number(addr + 1, na - 1);\n\n\tpr_debug(\"ISA map, cp=%llx, s=%llx, da=%llx\\n\", cp, s, da);\n\n\tif (da < cp || da >= (cp + s))\n\t\treturn OF_BAD_ADDR;\n\treturn da - cp;\n}\n\nstatic int of_bus_isa_translate(__be32 *addr, u64 offset, int na)\n{\n\treturn of_bus_default_translate(addr + 1, offset, na - 1);\n}\n\nstatic unsigned int of_bus_isa_get_flags(const __be32 *addr)\n{\n\tunsigned int flags = 0;\n\tu32 w = be32_to_cpup(addr);\n\n\tif (w & 1)\n\t\tflags |= IORESOURCE_IO;\n\telse\n\t\tflags |= IORESOURCE_MEM;\n\treturn flags;\n}\n\nstatic int of_bus_default_flags_match(struct device_node *np)\n{\n\treturn of_bus_n_addr_cells(np) == 3;\n}\n\n \n\nstatic struct of_bus of_busses[] = {\n#ifdef CONFIG_PCI\n\t \n\t{\n\t\t.name = \"pci\",\n\t\t.addresses = \"assigned-addresses\",\n\t\t.match = of_bus_pci_match,\n\t\t.count_cells = of_bus_pci_count_cells,\n\t\t.map = of_bus_pci_map,\n\t\t.translate = of_bus_pci_translate,\n\t\t.has_flags = true,\n\t\t.get_flags = of_bus_pci_get_flags,\n\t},\n#endif  \n\t \n\t{\n\t\t.name = \"isa\",\n\t\t.addresses = \"reg\",\n\t\t.match = of_bus_isa_match,\n\t\t.count_cells = of_bus_isa_count_cells,\n\t\t.map = of_bus_isa_map,\n\t\t.translate = of_bus_isa_translate,\n\t\t.has_flags = true,\n\t\t.get_flags = of_bus_isa_get_flags,\n\t},\n\t \n\t{\n\t\t.name = \"default-flags\",\n\t\t.addresses = \"reg\",\n\t\t.match = of_bus_default_flags_match,\n\t\t.count_cells = of_bus_default_count_cells,\n\t\t.map = of_bus_default_flags_map,\n\t\t.translate = of_bus_default_flags_translate,\n\t\t.has_flags = true,\n\t\t.get_flags = of_bus_default_flags_get_flags,\n\t},\n\t \n\t{\n\t\t.name = \"default\",\n\t\t.addresses = \"reg\",\n\t\t.match = NULL,\n\t\t.count_cells = of_bus_default_count_cells,\n\t\t.map = of_bus_default_map,\n\t\t.translate = of_bus_default_translate,\n\t\t.get_flags = of_bus_default_get_flags,\n\t},\n};\n\nstatic struct of_bus *of_match_bus(struct device_node *np)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(of_busses); i++)\n\t\tif (!of_busses[i].match || of_busses[i].match(np))\n\t\t\treturn &of_busses[i];\n\tBUG();\n\treturn NULL;\n}\n\nstatic int of_empty_ranges_quirk(struct device_node *np)\n{\n\tif (IS_ENABLED(CONFIG_PPC)) {\n\t\t \n\t\tstatic int quirk_state = -1;\n\n\t\t \n\t\tif (of_device_is_compatible(np, \"1682m-sdc\"))\n\t\t\treturn true;\n\n\t\t \n\t\tif (quirk_state < 0)\n\t\t\tquirk_state =\n\t\t\t\tof_machine_is_compatible(\"Power Macintosh\") ||\n\t\t\t\tof_machine_is_compatible(\"MacRISC\");\n\t\treturn quirk_state;\n\t}\n\treturn false;\n}\n\nstatic int of_translate_one(struct device_node *parent, struct of_bus *bus,\n\t\t\t    struct of_bus *pbus, __be32 *addr,\n\t\t\t    int na, int ns, int pna, const char *rprop)\n{\n\tconst __be32 *ranges;\n\tunsigned int rlen;\n\tint rone;\n\tu64 offset = OF_BAD_ADDR;\n\n\t \n\tranges = of_get_property(parent, rprop, &rlen);\n\tif (ranges == NULL && !of_empty_ranges_quirk(parent) &&\n\t    strcmp(rprop, \"dma-ranges\")) {\n\t\tpr_debug(\"no ranges; cannot translate\\n\");\n\t\treturn 1;\n\t}\n\tif (ranges == NULL || rlen == 0) {\n\t\toffset = of_read_number(addr, na);\n\t\tmemset(addr, 0, pna * 4);\n\t\tpr_debug(\"empty ranges; 1:1 translation\\n\");\n\t\tgoto finish;\n\t}\n\n\tpr_debug(\"walking ranges...\\n\");\n\n\t \n\trlen /= 4;\n\trone = na + pna + ns;\n\tfor (; rlen >= rone; rlen -= rone, ranges += rone) {\n\t\toffset = bus->map(addr, ranges, na, ns, pna);\n\t\tif (offset != OF_BAD_ADDR)\n\t\t\tbreak;\n\t}\n\tif (offset == OF_BAD_ADDR) {\n\t\tpr_debug(\"not found !\\n\");\n\t\treturn 1;\n\t}\n\tmemcpy(addr, ranges + na, 4 * pna);\n\n finish:\n\tof_dump_addr(\"parent translation for:\", addr, pna);\n\tpr_debug(\"with offset: %llx\\n\", offset);\n\n\t \n\treturn pbus->translate(addr, offset, pna);\n}\n\n \nstatic u64 __of_translate_address(struct device_node *dev,\n\t\t\t\t  struct device_node *(*get_parent)(const struct device_node *),\n\t\t\t\t  const __be32 *in_addr, const char *rprop,\n\t\t\t\t  struct device_node **host)\n{\n\tstruct device_node *parent = NULL;\n\tstruct of_bus *bus, *pbus;\n\t__be32 addr[OF_MAX_ADDR_CELLS];\n\tint na, ns, pna, pns;\n\tu64 result = OF_BAD_ADDR;\n\n\tpr_debug(\"** translation for device %pOF **\\n\", dev);\n\n\t \n\tof_node_get(dev);\n\n\t*host = NULL;\n\t \n\tparent = get_parent(dev);\n\tif (parent == NULL)\n\t\tgoto bail;\n\tbus = of_match_bus(parent);\n\n\t \n\tbus->count_cells(dev, &na, &ns);\n\tif (!OF_CHECK_COUNTS(na, ns)) {\n\t\tpr_debug(\"Bad cell count for %pOF\\n\", dev);\n\t\tgoto bail;\n\t}\n\tmemcpy(addr, in_addr, na * 4);\n\n\tpr_debug(\"bus is %s (na=%d, ns=%d) on %pOF\\n\",\n\t    bus->name, na, ns, parent);\n\tof_dump_addr(\"translating address:\", addr, na);\n\n\t \n\tfor (;;) {\n\t\tstruct logic_pio_hwaddr *iorange;\n\n\t\t \n\t\tof_node_put(dev);\n\t\tdev = parent;\n\t\tparent = get_parent(dev);\n\n\t\t \n\t\tif (parent == NULL) {\n\t\t\tpr_debug(\"reached root node\\n\");\n\t\t\tresult = of_read_number(addr, na);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tiorange = find_io_range_by_fwnode(&dev->fwnode);\n\t\tif (iorange && (iorange->flags != LOGIC_PIO_CPU_MMIO)) {\n\t\t\tresult = of_read_number(addr + 1, na - 1);\n\t\t\tpr_debug(\"indirectIO matched(%pOF) 0x%llx\\n\",\n\t\t\t\t dev, result);\n\t\t\t*host = of_node_get(dev);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpbus = of_match_bus(parent);\n\t\tpbus->count_cells(dev, &pna, &pns);\n\t\tif (!OF_CHECK_COUNTS(pna, pns)) {\n\t\t\tpr_err(\"Bad cell count for %pOF\\n\", dev);\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_debug(\"parent bus is %s (na=%d, ns=%d) on %pOF\\n\",\n\t\t    pbus->name, pna, pns, parent);\n\n\t\t \n\t\tif (of_translate_one(dev, bus, pbus, addr, na, ns, pna, rprop))\n\t\t\tbreak;\n\n\t\t \n\t\tna = pna;\n\t\tns = pns;\n\t\tbus = pbus;\n\n\t\tof_dump_addr(\"one level translation:\", addr, na);\n\t}\n bail:\n\tof_node_put(parent);\n\tof_node_put(dev);\n\n\treturn result;\n}\n\nu64 of_translate_address(struct device_node *dev, const __be32 *in_addr)\n{\n\tstruct device_node *host;\n\tu64 ret;\n\n\tret = __of_translate_address(dev, of_get_parent,\n\t\t\t\t     in_addr, \"ranges\", &host);\n\tif (host) {\n\t\tof_node_put(host);\n\t\treturn OF_BAD_ADDR;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(of_translate_address);\n\n#ifdef CONFIG_HAS_DMA\nstruct device_node *__of_get_dma_parent(const struct device_node *np)\n{\n\tstruct of_phandle_args args;\n\tint ret, index;\n\n\tindex = of_property_match_string(np, \"interconnect-names\", \"dma-mem\");\n\tif (index < 0)\n\t\treturn of_get_parent(np);\n\n\tret = of_parse_phandle_with_args(np, \"interconnects\",\n\t\t\t\t\t \"#interconnect-cells\",\n\t\t\t\t\t index, &args);\n\tif (ret < 0)\n\t\treturn of_get_parent(np);\n\n\treturn of_node_get(args.np);\n}\n#endif\n\nstatic struct device_node *of_get_next_dma_parent(struct device_node *np)\n{\n\tstruct device_node *parent;\n\n\tparent = __of_get_dma_parent(np);\n\tof_node_put(np);\n\n\treturn parent;\n}\n\nu64 of_translate_dma_address(struct device_node *dev, const __be32 *in_addr)\n{\n\tstruct device_node *host;\n\tu64 ret;\n\n\tret = __of_translate_address(dev, __of_get_dma_parent,\n\t\t\t\t     in_addr, \"dma-ranges\", &host);\n\n\tif (host) {\n\t\tof_node_put(host);\n\t\treturn OF_BAD_ADDR;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(of_translate_dma_address);\n\n \nconst __be32 *of_translate_dma_region(struct device_node *dev, const __be32 *prop,\n\t\t\t\t      phys_addr_t *start, size_t *length)\n{\n\tstruct device_node *parent;\n\tu64 address, size;\n\tint na, ns;\n\n\tparent = __of_get_dma_parent(dev);\n\tif (!parent)\n\t\treturn NULL;\n\n\tna = of_bus_n_addr_cells(parent);\n\tns = of_bus_n_size_cells(parent);\n\n\tof_node_put(parent);\n\n\taddress = of_translate_dma_address(dev, prop);\n\tif (address == OF_BAD_ADDR)\n\t\treturn NULL;\n\n\tsize = of_read_number(prop + na, ns);\n\n\tif (start)\n\t\t*start = address;\n\n\tif (length)\n\t\t*length = size;\n\n\treturn prop + na + ns;\n}\nEXPORT_SYMBOL(of_translate_dma_region);\n\nconst __be32 *__of_get_address(struct device_node *dev, int index, int bar_no,\n\t\t\t       u64 *size, unsigned int *flags)\n{\n\tconst __be32 *prop;\n\tunsigned int psize;\n\tstruct device_node *parent;\n\tstruct of_bus *bus;\n\tint onesize, i, na, ns;\n\n\t \n\tparent = of_get_parent(dev);\n\tif (parent == NULL)\n\t\treturn NULL;\n\tbus = of_match_bus(parent);\n\tif (strcmp(bus->name, \"pci\") && (bar_no >= 0)) {\n\t\tof_node_put(parent);\n\t\treturn NULL;\n\t}\n\tbus->count_cells(dev, &na, &ns);\n\tof_node_put(parent);\n\tif (!OF_CHECK_ADDR_COUNT(na))\n\t\treturn NULL;\n\n\t \n\tprop = of_get_property(dev, bus->addresses, &psize);\n\tif (prop == NULL)\n\t\treturn NULL;\n\tpsize /= 4;\n\n\tonesize = na + ns;\n\tfor (i = 0; psize >= onesize; psize -= onesize, prop += onesize, i++) {\n\t\tu32 val = be32_to_cpu(prop[0]);\n\t\t \n\t\tif (((bar_no >= 0) && ((val & 0xff) == ((bar_no * 4) + PCI_BASE_ADDRESS_0))) ||\n\t\t    ((index >= 0) && (i == index))) {\n\t\t\tif (size)\n\t\t\t\t*size = of_read_number(prop + na, ns);\n\t\t\tif (flags)\n\t\t\t\t*flags = bus->get_flags(prop);\n\t\t\treturn prop;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(__of_get_address);\n\n \nint of_property_read_reg(struct device_node *np, int idx, u64 *addr, u64 *size)\n{\n\tconst __be32 *prop = of_get_address(np, idx, size, NULL);\n\n\tif (!prop)\n\t\treturn -EINVAL;\n\n\t*addr = of_read_number(prop, of_n_addr_cells(np));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(of_property_read_reg);\n\nstatic int parser_init(struct of_pci_range_parser *parser,\n\t\t\tstruct device_node *node, const char *name)\n{\n\tint rlen;\n\n\tparser->node = node;\n\tparser->pna = of_n_addr_cells(node);\n\tparser->na = of_bus_n_addr_cells(node);\n\tparser->ns = of_bus_n_size_cells(node);\n\tparser->dma = !strcmp(name, \"dma-ranges\");\n\tparser->bus = of_match_bus(node);\n\n\tparser->range = of_get_property(node, name, &rlen);\n\tif (parser->range == NULL)\n\t\treturn -ENOENT;\n\n\tparser->end = parser->range + rlen / sizeof(__be32);\n\n\treturn 0;\n}\n\nint of_pci_range_parser_init(struct of_pci_range_parser *parser,\n\t\t\t\tstruct device_node *node)\n{\n\treturn parser_init(parser, node, \"ranges\");\n}\nEXPORT_SYMBOL_GPL(of_pci_range_parser_init);\n\nint of_pci_dma_range_parser_init(struct of_pci_range_parser *parser,\n\t\t\t\tstruct device_node *node)\n{\n\treturn parser_init(parser, node, \"dma-ranges\");\n}\nEXPORT_SYMBOL_GPL(of_pci_dma_range_parser_init);\n#define of_dma_range_parser_init of_pci_dma_range_parser_init\n\nstruct of_pci_range *of_pci_range_parser_one(struct of_pci_range_parser *parser,\n\t\t\t\t\t\tstruct of_pci_range *range)\n{\n\tint na = parser->na;\n\tint ns = parser->ns;\n\tint np = parser->pna + na + ns;\n\tint busflag_na = 0;\n\n\tif (!range)\n\t\treturn NULL;\n\n\tif (!parser->range || parser->range + np > parser->end)\n\t\treturn NULL;\n\n\trange->flags = parser->bus->get_flags(parser->range);\n\n\t \n\tif (parser->bus->has_flags)\n\t\tbusflag_na = 1;\n\n\trange->bus_addr = of_read_number(parser->range + busflag_na, na - busflag_na);\n\n\tif (parser->dma)\n\t\trange->cpu_addr = of_translate_dma_address(parser->node,\n\t\t\t\tparser->range + na);\n\telse\n\t\trange->cpu_addr = of_translate_address(parser->node,\n\t\t\t\tparser->range + na);\n\trange->size = of_read_number(parser->range + parser->pna + na, ns);\n\n\tparser->range += np;\n\n\t \n\twhile (parser->range + np <= parser->end) {\n\t\tu32 flags = 0;\n\t\tu64 bus_addr, cpu_addr, size;\n\n\t\tflags = parser->bus->get_flags(parser->range);\n\t\tbus_addr = of_read_number(parser->range + busflag_na, na - busflag_na);\n\t\tif (parser->dma)\n\t\t\tcpu_addr = of_translate_dma_address(parser->node,\n\t\t\t\t\tparser->range + na);\n\t\telse\n\t\t\tcpu_addr = of_translate_address(parser->node,\n\t\t\t\t\tparser->range + na);\n\t\tsize = of_read_number(parser->range + parser->pna + na, ns);\n\n\t\tif (flags != range->flags)\n\t\t\tbreak;\n\t\tif (bus_addr != range->bus_addr + range->size ||\n\t\t    cpu_addr != range->cpu_addr + range->size)\n\t\t\tbreak;\n\n\t\trange->size += size;\n\t\tparser->range += np;\n\t}\n\n\treturn range;\n}\nEXPORT_SYMBOL_GPL(of_pci_range_parser_one);\n\nstatic u64 of_translate_ioport(struct device_node *dev, const __be32 *in_addr,\n\t\t\tu64 size)\n{\n\tu64 taddr;\n\tunsigned long port;\n\tstruct device_node *host;\n\n\ttaddr = __of_translate_address(dev, of_get_parent,\n\t\t\t\t       in_addr, \"ranges\", &host);\n\tif (host) {\n\t\t \n\t\tport = logic_pio_trans_hwaddr(&host->fwnode, taddr, size);\n\t\tof_node_put(host);\n\t} else {\n\t\t \n\t\tport = pci_address_to_pio(taddr);\n\t}\n\n\tif (port == (unsigned long)-1)\n\t\treturn OF_BAD_ADDR;\n\n\treturn port;\n}\n\n#ifdef CONFIG_HAS_DMA\n \nint of_dma_get_range(struct device_node *np, const struct bus_dma_region **map)\n{\n\tstruct device_node *node = of_node_get(np);\n\tconst __be32 *ranges = NULL;\n\tbool found_dma_ranges = false;\n\tstruct of_range_parser parser;\n\tstruct of_range range;\n\tstruct bus_dma_region *r;\n\tint len, num_ranges = 0;\n\tint ret = 0;\n\n\twhile (node) {\n\t\tranges = of_get_property(node, \"dma-ranges\", &len);\n\n\t\t \n\t\tif (ranges && len > 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (found_dma_ranges && !ranges) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tfound_dma_ranges = true;\n\n\t\tnode = of_get_next_dma_parent(node);\n\t}\n\n\tif (!node || !ranges) {\n\t\tpr_debug(\"no dma-ranges found for node(%pOF)\\n\", np);\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tof_dma_range_parser_init(&parser, node);\n\tfor_each_of_range(&parser, &range) {\n\t\tif (range.cpu_addr == OF_BAD_ADDR) {\n\t\t\tpr_err(\"translation of DMA address(%llx) to CPU address failed node(%pOF)\\n\",\n\t\t\t       range.bus_addr, node);\n\t\t\tcontinue;\n\t\t}\n\t\tnum_ranges++;\n\t}\n\n\tif (!num_ranges) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tr = kcalloc(num_ranges + 1, sizeof(*r), GFP_KERNEL);\n\tif (!r) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\t*map = r;\n\tof_dma_range_parser_init(&parser, node);\n\tfor_each_of_range(&parser, &range) {\n\t\tpr_debug(\"dma_addr(%llx) cpu_addr(%llx) size(%llx)\\n\",\n\t\t\t range.bus_addr, range.cpu_addr, range.size);\n\t\tif (range.cpu_addr == OF_BAD_ADDR)\n\t\t\tcontinue;\n\t\tr->cpu_start = range.cpu_addr;\n\t\tr->dma_start = range.bus_addr;\n\t\tr->size = range.size;\n\t\tr->offset = range.cpu_addr - range.bus_addr;\n\t\tr++;\n\t}\nout:\n\tof_node_put(node);\n\treturn ret;\n}\n#endif  \n\n \nphys_addr_t __init of_dma_get_max_cpu_address(struct device_node *np)\n{\n\tphys_addr_t max_cpu_addr = PHYS_ADDR_MAX;\n\tstruct of_range_parser parser;\n\tphys_addr_t subtree_max_addr;\n\tstruct device_node *child;\n\tstruct of_range range;\n\tconst __be32 *ranges;\n\tu64 cpu_end = 0;\n\tint len;\n\n\tif (!np)\n\t\tnp = of_root;\n\n\tranges = of_get_property(np, \"dma-ranges\", &len);\n\tif (ranges && len) {\n\t\tof_dma_range_parser_init(&parser, np);\n\t\tfor_each_of_range(&parser, &range)\n\t\t\tif (range.cpu_addr + range.size > cpu_end)\n\t\t\t\tcpu_end = range.cpu_addr + range.size - 1;\n\n\t\tif (max_cpu_addr > cpu_end)\n\t\t\tmax_cpu_addr = cpu_end;\n\t}\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tsubtree_max_addr = of_dma_get_max_cpu_address(child);\n\t\tif (max_cpu_addr > subtree_max_addr)\n\t\t\tmax_cpu_addr = subtree_max_addr;\n\t}\n\n\treturn max_cpu_addr;\n}\n\n \nbool of_dma_is_coherent(struct device_node *np)\n{\n\tstruct device_node *node;\n\tbool is_coherent = dma_default_coherent;\n\n\tnode = of_node_get(np);\n\n\twhile (node) {\n\t\tif (of_property_read_bool(node, \"dma-coherent\")) {\n\t\t\tis_coherent = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (of_property_read_bool(node, \"dma-noncoherent\")) {\n\t\t\tis_coherent = false;\n\t\t\tbreak;\n\t\t}\n\t\tnode = of_get_next_dma_parent(node);\n\t}\n\tof_node_put(node);\n\treturn is_coherent;\n}\nEXPORT_SYMBOL_GPL(of_dma_is_coherent);\n\n \nstatic bool of_mmio_is_nonposted(struct device_node *np)\n{\n\tstruct device_node *parent;\n\tbool nonposted;\n\n\tif (!IS_ENABLED(CONFIG_ARCH_APPLE))\n\t\treturn false;\n\n\tparent = of_get_parent(np);\n\tif (!parent)\n\t\treturn false;\n\n\tnonposted = of_property_read_bool(parent, \"nonposted-mmio\");\n\n\tof_node_put(parent);\n\treturn nonposted;\n}\n\nstatic int __of_address_to_resource(struct device_node *dev, int index, int bar_no,\n\t\tstruct resource *r)\n{\n\tu64 taddr;\n\tconst __be32\t*addrp;\n\tu64\t\tsize;\n\tunsigned int\tflags;\n\tconst char\t*name = NULL;\n\n\taddrp = __of_get_address(dev, index, bar_no, &size, &flags);\n\tif (addrp == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tif (index >= 0)\n\t\tof_property_read_string_index(dev, \"reg-names\",\tindex, &name);\n\n\tif (flags & IORESOURCE_MEM)\n\t\ttaddr = of_translate_address(dev, addrp);\n\telse if (flags & IORESOURCE_IO)\n\t\ttaddr = of_translate_ioport(dev, addrp, size);\n\telse\n\t\treturn -EINVAL;\n\n\tif (taddr == OF_BAD_ADDR)\n\t\treturn -EINVAL;\n\tmemset(r, 0, sizeof(struct resource));\n\n\tif (of_mmio_is_nonposted(dev))\n\t\tflags |= IORESOURCE_MEM_NONPOSTED;\n\n\tr->start = taddr;\n\tr->end = taddr + size - 1;\n\tr->flags = flags;\n\tr->name = name ? name : dev->full_name;\n\n\treturn 0;\n}\n\n \nint of_address_to_resource(struct device_node *dev, int index,\n\t\t\t   struct resource *r)\n{\n\treturn __of_address_to_resource(dev, index, -1, r);\n}\nEXPORT_SYMBOL_GPL(of_address_to_resource);\n\nint of_pci_address_to_resource(struct device_node *dev, int bar,\n\t\t\t       struct resource *r)\n{\n\n\tif (!IS_ENABLED(CONFIG_PCI))\n\t\treturn -ENOSYS;\n\n\treturn __of_address_to_resource(dev, -1, bar, r);\n}\nEXPORT_SYMBOL_GPL(of_pci_address_to_resource);\n\n \nvoid __iomem *of_iomap(struct device_node *np, int index)\n{\n\tstruct resource res;\n\n\tif (of_address_to_resource(np, index, &res))\n\t\treturn NULL;\n\n\tif (res.flags & IORESOURCE_MEM_NONPOSTED)\n\t\treturn ioremap_np(res.start, resource_size(&res));\n\telse\n\t\treturn ioremap(res.start, resource_size(&res));\n}\nEXPORT_SYMBOL(of_iomap);\n\n \nvoid __iomem *of_io_request_and_map(struct device_node *np, int index,\n\t\t\t\t    const char *name)\n{\n\tstruct resource res;\n\tvoid __iomem *mem;\n\n\tif (of_address_to_resource(np, index, &res))\n\t\treturn IOMEM_ERR_PTR(-EINVAL);\n\n\tif (!name)\n\t\tname = res.name;\n\tif (!request_mem_region(res.start, resource_size(&res), name))\n\t\treturn IOMEM_ERR_PTR(-EBUSY);\n\n\tif (res.flags & IORESOURCE_MEM_NONPOSTED)\n\t\tmem = ioremap_np(res.start, resource_size(&res));\n\telse\n\t\tmem = ioremap(res.start, resource_size(&res));\n\n\tif (!mem) {\n\t\trelease_mem_region(res.start, resource_size(&res));\n\t\treturn IOMEM_ERR_PTR(-ENOMEM);\n\t}\n\n\treturn mem;\n}\nEXPORT_SYMBOL(of_io_request_and_map);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}