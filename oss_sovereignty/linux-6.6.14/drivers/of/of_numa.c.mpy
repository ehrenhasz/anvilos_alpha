{
  "module_name": "of_numa.c",
  "hash_id": "e3ed1dd5b9de7314a99d3ec194891fc006da9a6e4a2fee00916902da399b7c60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/of_numa.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"OF: NUMA: \" fmt\n\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/nodemask.h>\n\n#include <asm/numa.h>\n\n \n#define DEFAULT_NODE 0\n\n \nstatic void __init of_numa_parse_cpu_nodes(void)\n{\n\tu32 nid;\n\tint r;\n\tstruct device_node *np;\n\n\tfor_each_of_cpu_node(np) {\n\t\tr = of_property_read_u32(np, \"numa-node-id\", &nid);\n\t\tif (r)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"CPU on %u\\n\", nid);\n\t\tif (nid >= MAX_NUMNODES)\n\t\t\tpr_warn(\"Node id %u exceeds maximum value\\n\", nid);\n\t\telse\n\t\t\tnode_set(nid, numa_nodes_parsed);\n\t}\n}\n\nstatic int __init of_numa_parse_memory_nodes(void)\n{\n\tstruct device_node *np = NULL;\n\tstruct resource rsrc;\n\tu32 nid;\n\tint i, r;\n\n\tfor_each_node_by_type(np, \"memory\") {\n\t\tr = of_property_read_u32(np, \"numa-node-id\", &nid);\n\t\tif (r == -EINVAL)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tif (nid >= MAX_NUMNODES) {\n\t\t\tpr_warn(\"Node id %u exceeds maximum value\\n\", nid);\n\t\t\tr = -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; !r && !of_address_to_resource(np, i, &rsrc); i++)\n\t\t\tr = numa_add_memblk(nid, rsrc.start, rsrc.end + 1);\n\n\t\tif (!i || r) {\n\t\t\tof_node_put(np);\n\t\t\tpr_err(\"bad property in memory node\\n\");\n\t\t\treturn r ? : -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __init of_numa_parse_distance_map_v1(struct device_node *map)\n{\n\tconst __be32 *matrix;\n\tint entry_count;\n\tint i;\n\n\tpr_info(\"parsing numa-distance-map-v1\\n\");\n\n\tmatrix = of_get_property(map, \"distance-matrix\", NULL);\n\tif (!matrix) {\n\t\tpr_err(\"No distance-matrix property in distance-map\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry_count = of_property_count_u32_elems(map, \"distance-matrix\");\n\tif (entry_count <= 0) {\n\t\tpr_err(\"Invalid distance-matrix\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i + 2 < entry_count; i += 3) {\n\t\tu32 nodea, nodeb, distance;\n\n\t\tnodea = of_read_number(matrix, 1);\n\t\tmatrix++;\n\t\tnodeb = of_read_number(matrix, 1);\n\t\tmatrix++;\n\t\tdistance = of_read_number(matrix, 1);\n\t\tmatrix++;\n\n\t\tif ((nodea == nodeb && distance != LOCAL_DISTANCE) ||\n\t\t    (nodea != nodeb && distance <= LOCAL_DISTANCE)) {\n\t\t\tpr_err(\"Invalid distance[node%d -> node%d] = %d\\n\",\n\t\t\t       nodea, nodeb, distance);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnode_set(nodea, numa_nodes_parsed);\n\n\t\tnuma_set_distance(nodea, nodeb, distance);\n\n\t\t \n\t\tif (nodeb > nodea)\n\t\t\tnuma_set_distance(nodeb, nodea, distance);\n\t}\n\n\treturn 0;\n}\n\nstatic int __init of_numa_parse_distance_map(void)\n{\n\tint ret = 0;\n\tstruct device_node *np;\n\n\tnp = of_find_compatible_node(NULL, NULL,\n\t\t\t\t     \"numa-distance-map-v1\");\n\tif (np)\n\t\tret = of_numa_parse_distance_map_v1(np);\n\n\tof_node_put(np);\n\treturn ret;\n}\n\nint of_node_to_nid(struct device_node *device)\n{\n\tstruct device_node *np;\n\tu32 nid;\n\tint r = -ENODATA;\n\n\tnp = of_node_get(device);\n\n\twhile (np) {\n\t\tr = of_property_read_u32(np, \"numa-node-id\", &nid);\n\t\t \n\t\tif (r != -EINVAL)\n\t\t\tbreak;\n\n\t\tnp = of_get_next_parent(np);\n\t}\n\tif (np && r)\n\t\tpr_warn(\"Invalid \\\"numa-node-id\\\" property in node %pOFn\\n\",\n\t\t\tnp);\n\tof_node_put(np);\n\n\t \n\tif (!r && nid < MAX_NUMNODES && node_possible(nid))\n\t\treturn nid;\n\n\treturn NUMA_NO_NODE;\n}\n\nint __init of_numa_init(void)\n{\n\tint r;\n\n\tof_numa_parse_cpu_nodes();\n\tr = of_numa_parse_memory_nodes();\n\tif (r)\n\t\treturn r;\n\treturn of_numa_parse_distance_map();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}