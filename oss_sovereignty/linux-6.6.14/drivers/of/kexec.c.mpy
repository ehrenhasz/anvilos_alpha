{
  "module_name": "kexec.c",
  "hash_id": "efe7fb46181c4a42fd11527f633c9945800e4b694c2c4840a3551cbd19800f4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/kexec.c",
  "human_readable_source": "\n \n\n#include <linux/ima.h>\n#include <linux/kernel.h>\n#include <linux/kexec.h>\n#include <linux/memblock.h>\n#include <linux/libfdt.h>\n#include <linux/of.h>\n#include <linux/of_fdt.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define RNG_SEED_SIZE\t\t128\n\n \n#define FDT_EXTRA_SPACE 0x1000\n\n \nstatic int fdt_find_and_del_mem_rsv(void *fdt, unsigned long start, unsigned long size)\n{\n\tint i, ret, num_rsvs = fdt_num_mem_rsv(fdt);\n\n\tfor (i = 0; i < num_rsvs; i++) {\n\t\tu64 rsv_start, rsv_size;\n\n\t\tret = fdt_get_mem_rsv(fdt, i, &rsv_start, &rsv_size);\n\t\tif (ret) {\n\t\t\tpr_err(\"Malformed device tree.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rsv_start == start && rsv_size == size) {\n\t\t\tret = fdt_del_mem_rsv(fdt, i);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"Error deleting device tree reservation.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic int get_addr_size_cells(int *addr_cells, int *size_cells)\n{\n\tstruct device_node *root;\n\n\troot = of_find_node_by_path(\"/\");\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t*addr_cells = of_n_addr_cells(root);\n\t*size_cells = of_n_size_cells(root);\n\n\tof_node_put(root);\n\n\treturn 0;\n}\n\n \nstatic int do_get_kexec_buffer(const void *prop, int len, unsigned long *addr,\n\t\t\t       size_t *size)\n{\n\tint ret, addr_cells, size_cells;\n\n\tret = get_addr_size_cells(&addr_cells, &size_cells);\n\tif (ret)\n\t\treturn ret;\n\n\tif (len < 4 * (addr_cells + size_cells))\n\t\treturn -ENOENT;\n\n\t*addr = of_read_number(prop, addr_cells);\n\t*size = of_read_number(prop + 4 * addr_cells, size_cells);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_HAVE_IMA_KEXEC\n \nint __init ima_get_kexec_buffer(void **addr, size_t *size)\n{\n\tint ret, len;\n\tunsigned long tmp_addr;\n\tunsigned long start_pfn, end_pfn;\n\tsize_t tmp_size;\n\tconst void *prop;\n\n\tprop = of_get_property(of_chosen, \"linux,ima-kexec-buffer\", &len);\n\tif (!prop)\n\t\treturn -ENOENT;\n\n\tret = do_get_kexec_buffer(prop, len, &tmp_addr, &tmp_size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!tmp_size)\n\t\treturn -ENOENT;\n\n\t \n\tstart_pfn = PHYS_PFN(tmp_addr);\n\tend_pfn = PHYS_PFN(tmp_addr + tmp_size - 1);\n\tif (!page_is_ram(start_pfn) || !page_is_ram(end_pfn)) {\n\t\tpr_warn(\"IMA buffer at 0x%lx, size = 0x%zx beyond memory\\n\",\n\t\t\ttmp_addr, tmp_size);\n\t\treturn -EINVAL;\n\t}\n\n\t*addr = __va(tmp_addr);\n\t*size = tmp_size;\n\n\treturn 0;\n}\n\n \nint __init ima_free_kexec_buffer(void)\n{\n\tint ret;\n\tunsigned long addr;\n\tsize_t size;\n\tstruct property *prop;\n\n\tprop = of_find_property(of_chosen, \"linux,ima-kexec-buffer\", NULL);\n\tif (!prop)\n\t\treturn -ENOENT;\n\n\tret = do_get_kexec_buffer(prop->value, prop->length, &addr, &size);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_remove_property(of_chosen, prop);\n\tif (ret)\n\t\treturn ret;\n\n\tmemblock_free_late(addr, size);\n\treturn 0;\n}\n#endif\n\n \nstatic void remove_ima_buffer(void *fdt, int chosen_node)\n{\n\tint ret, len;\n\tunsigned long addr;\n\tsize_t size;\n\tconst void *prop;\n\n\tif (!IS_ENABLED(CONFIG_HAVE_IMA_KEXEC))\n\t\treturn;\n\n\tprop = fdt_getprop(fdt, chosen_node, \"linux,ima-kexec-buffer\", &len);\n\tif (!prop)\n\t\treturn;\n\n\tret = do_get_kexec_buffer(prop, len, &addr, &size);\n\tfdt_delprop(fdt, chosen_node, \"linux,ima-kexec-buffer\");\n\tif (ret)\n\t\treturn;\n\n\tret = fdt_find_and_del_mem_rsv(fdt, addr, size);\n\tif (!ret)\n\t\tpr_debug(\"Removed old IMA buffer reservation.\\n\");\n}\n\n#ifdef CONFIG_IMA_KEXEC\n \nstatic int setup_ima_buffer(const struct kimage *image, void *fdt,\n\t\t\t    int chosen_node)\n{\n\tint ret;\n\n\tif (!image->ima_buffer_size)\n\t\treturn 0;\n\n\tret = fdt_appendprop_addrrange(fdt, 0, chosen_node,\n\t\t\t\t       \"linux,ima-kexec-buffer\",\n\t\t\t\t       image->ima_buffer_addr,\n\t\t\t\t       image->ima_buffer_size);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tret = fdt_add_mem_rsv(fdt, image->ima_buffer_addr,\n\t\t\t      image->ima_buffer_size);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"IMA buffer at 0x%llx, size = 0x%zx\\n\",\n\t\t image->ima_buffer_addr, image->ima_buffer_size);\n\n\treturn 0;\n}\n#else  \nstatic inline int setup_ima_buffer(const struct kimage *image, void *fdt,\n\t\t\t\t   int chosen_node)\n{\n\treturn 0;\n}\n#endif  \n\n \nvoid *of_kexec_alloc_and_setup_fdt(const struct kimage *image,\n\t\t\t\t   unsigned long initrd_load_addr,\n\t\t\t\t   unsigned long initrd_len,\n\t\t\t\t   const char *cmdline, size_t extra_fdt_size)\n{\n\tvoid *fdt;\n\tint ret, chosen_node, len;\n\tconst void *prop;\n\tsize_t fdt_size;\n\n\tfdt_size = fdt_totalsize(initial_boot_params) +\n\t\t   (cmdline ? strlen(cmdline) : 0) +\n\t\t   FDT_EXTRA_SPACE +\n\t\t   extra_fdt_size;\n\tfdt = kvmalloc(fdt_size, GFP_KERNEL);\n\tif (!fdt)\n\t\treturn NULL;\n\n\tret = fdt_open_into(initial_boot_params, fdt, fdt_size);\n\tif (ret < 0) {\n\t\tpr_err(\"Error %d setting up the new device tree.\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = fdt_find_and_del_mem_rsv(fdt, __pa(initial_boot_params),\n\t\t\t\t       fdt_totalsize(initial_boot_params));\n\tif (ret == -EINVAL) {\n\t\tpr_err(\"Error removing memory reservation.\\n\");\n\t\tgoto out;\n\t}\n\n\tchosen_node = fdt_path_offset(fdt, \"/chosen\");\n\tif (chosen_node == -FDT_ERR_NOTFOUND)\n\t\tchosen_node = fdt_add_subnode(fdt, fdt_path_offset(fdt, \"/\"),\n\t\t\t\t\t      \"chosen\");\n\tif (chosen_node < 0) {\n\t\tret = chosen_node;\n\t\tgoto out;\n\t}\n\n\tret = fdt_delprop(fdt, chosen_node, \"linux,elfcorehdr\");\n\tif (ret && ret != -FDT_ERR_NOTFOUND)\n\t\tgoto out;\n\tret = fdt_delprop(fdt, chosen_node, \"linux,usable-memory-range\");\n\tif (ret && ret != -FDT_ERR_NOTFOUND)\n\t\tgoto out;\n\n\t \n\tprop = fdt_getprop(fdt, chosen_node, \"linux,initrd-start\", &len);\n\tif (prop) {\n\t\tu64 tmp_start, tmp_end, tmp_size;\n\n\t\ttmp_start = of_read_number(prop, len / 4);\n\n\t\tprop = fdt_getprop(fdt, chosen_node, \"linux,initrd-end\", &len);\n\t\tif (!prop) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttmp_end = of_read_number(prop, len / 4);\n\n\t\t \n\t\ttmp_size = tmp_end - tmp_start;\n\t\tret = fdt_find_and_del_mem_rsv(fdt, tmp_start, tmp_size);\n\t\tif (ret == -ENOENT)\n\t\t\tret = fdt_find_and_del_mem_rsv(fdt, tmp_start,\n\t\t\t\t\t\t       round_up(tmp_size, PAGE_SIZE));\n\t\tif (ret == -EINVAL)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (initrd_load_addr) {\n\t\tret = fdt_setprop_u64(fdt, chosen_node, \"linux,initrd-start\",\n\t\t\t\t      initrd_load_addr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = fdt_setprop_u64(fdt, chosen_node, \"linux,initrd-end\",\n\t\t\t\t      initrd_load_addr + initrd_len);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = fdt_add_mem_rsv(fdt, initrd_load_addr, initrd_len);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t} else {\n\t\tret = fdt_delprop(fdt, chosen_node, \"linux,initrd-start\");\n\t\tif (ret && (ret != -FDT_ERR_NOTFOUND))\n\t\t\tgoto out;\n\n\t\tret = fdt_delprop(fdt, chosen_node, \"linux,initrd-end\");\n\t\tif (ret && (ret != -FDT_ERR_NOTFOUND))\n\t\t\tgoto out;\n\t}\n\n\tif (image->type == KEXEC_TYPE_CRASH) {\n\t\t \n\t\tret = fdt_appendprop_addrrange(fdt, 0, chosen_node,\n\t\t\t\t\"linux,elfcorehdr\", image->elf_load_addr,\n\t\t\t\timage->elf_headers_sz);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tret = fdt_add_mem_rsv(fdt, image->elf_load_addr,\n\t\t\t\t      image->elf_headers_sz);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tret = fdt_appendprop_addrrange(fdt, 0, chosen_node,\n\t\t\t\t\"linux,usable-memory-range\", crashk_res.start,\n\t\t\t\tcrashk_res.end - crashk_res.start + 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (crashk_low_res.end) {\n\t\t\tret = fdt_appendprop_addrrange(fdt, 0, chosen_node,\n\t\t\t\t\t\"linux,usable-memory-range\",\n\t\t\t\t\tcrashk_low_res.start,\n\t\t\t\t\tcrashk_low_res.end - crashk_low_res.start + 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (cmdline) {\n\t\tret = fdt_setprop_string(fdt, chosen_node, \"bootargs\", cmdline);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tret = fdt_delprop(fdt, chosen_node, \"bootargs\");\n\t\tif (ret && (ret != -FDT_ERR_NOTFOUND))\n\t\t\tgoto out;\n\t}\n\n\t \n\tret = fdt_delprop(fdt, chosen_node, \"kaslr-seed\");\n\tif (ret == -FDT_ERR_NOTFOUND)\n\t\tret = 0;\n\telse if (ret)\n\t\tgoto out;\n\n\tif (rng_is_initialized()) {\n\t\tu64 seed = get_random_u64();\n\n\t\tret = fdt_setprop_u64(fdt, chosen_node, \"kaslr-seed\", seed);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tpr_notice(\"RNG is not initialised: omitting \\\"%s\\\" property\\n\",\n\t\t\t  \"kaslr-seed\");\n\t}\n\n\t \n\tif (rng_is_initialized()) {\n\t\tvoid *rng_seed;\n\n\t\tret = fdt_setprop_placeholder(fdt, chosen_node, \"rng-seed\",\n\t\t\t\tRNG_SEED_SIZE, &rng_seed);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tget_random_bytes(rng_seed, RNG_SEED_SIZE);\n\t} else {\n\t\tpr_notice(\"RNG is not initialised: omitting \\\"%s\\\" property\\n\",\n\t\t\t  \"rng-seed\");\n\t}\n\n\tret = fdt_setprop(fdt, chosen_node, \"linux,booted-from-kexec\", NULL, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tremove_ima_buffer(fdt, chosen_node);\n\tret = setup_ima_buffer(image, fdt, fdt_path_offset(fdt, \"/chosen\"));\n\nout:\n\tif (ret) {\n\t\tkvfree(fdt);\n\t\tfdt = NULL;\n\t}\n\n\treturn fdt;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}