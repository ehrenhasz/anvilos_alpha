{
  "module_name": "property.c",
  "hash_id": "db5de3fde514f0b52876b06522ac0dc59ae6946529d9fce87e4f70c4a1720886",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/property.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"OF: \" fmt\n\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_graph.h>\n#include <linux/of_irq.h>\n#include <linux/string.h>\n#include <linux/moduleparam.h>\n\n#include \"of_private.h\"\n\n \nbool of_graph_is_present(const struct device_node *node)\n{\n\tstruct device_node *ports, *port;\n\n\tports = of_get_child_by_name(node, \"ports\");\n\tif (ports)\n\t\tnode = ports;\n\n\tport = of_get_child_by_name(node, \"port\");\n\tof_node_put(ports);\n\tof_node_put(port);\n\n\treturn !!port;\n}\nEXPORT_SYMBOL(of_graph_is_present);\n\n \nint of_property_count_elems_of_size(const struct device_node *np,\n\t\t\t\tconst char *propname, int elem_size)\n{\n\tstruct property *prop = of_find_property(np, propname, NULL);\n\n\tif (!prop)\n\t\treturn -EINVAL;\n\tif (!prop->value)\n\t\treturn -ENODATA;\n\n\tif (prop->length % elem_size != 0) {\n\t\tpr_err(\"size of %s in node %pOF is not a multiple of %d\\n\",\n\t\t       propname, np, elem_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn prop->length / elem_size;\n}\nEXPORT_SYMBOL_GPL(of_property_count_elems_of_size);\n\n \nstatic void *of_find_property_value_of_size(const struct device_node *np,\n\t\t\tconst char *propname, u32 min, u32 max, size_t *len)\n{\n\tstruct property *prop = of_find_property(np, propname, NULL);\n\n\tif (!prop)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!prop->value)\n\t\treturn ERR_PTR(-ENODATA);\n\tif (prop->length < min)\n\t\treturn ERR_PTR(-EOVERFLOW);\n\tif (max && prop->length > max)\n\t\treturn ERR_PTR(-EOVERFLOW);\n\n\tif (len)\n\t\t*len = prop->length;\n\n\treturn prop->value;\n}\n\n \nint of_property_read_u32_index(const struct device_node *np,\n\t\t\t\t       const char *propname,\n\t\t\t\t       u32 index, u32 *out_value)\n{\n\tconst u32 *val = of_find_property_value_of_size(np, propname,\n\t\t\t\t\t((index + 1) * sizeof(*out_value)),\n\t\t\t\t\t0,\n\t\t\t\t\tNULL);\n\n\tif (IS_ERR(val))\n\t\treturn PTR_ERR(val);\n\n\t*out_value = be32_to_cpup(((__be32 *)val) + index);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_property_read_u32_index);\n\n \nint of_property_read_u64_index(const struct device_node *np,\n\t\t\t\t       const char *propname,\n\t\t\t\t       u32 index, u64 *out_value)\n{\n\tconst u64 *val = of_find_property_value_of_size(np, propname,\n\t\t\t\t\t((index + 1) * sizeof(*out_value)),\n\t\t\t\t\t0, NULL);\n\n\tif (IS_ERR(val))\n\t\treturn PTR_ERR(val);\n\n\t*out_value = be64_to_cpup(((__be64 *)val) + index);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_property_read_u64_index);\n\n \nint of_property_read_variable_u8_array(const struct device_node *np,\n\t\t\t\t\tconst char *propname, u8 *out_values,\n\t\t\t\t\tsize_t sz_min, size_t sz_max)\n{\n\tsize_t sz, count;\n\tconst u8 *val = of_find_property_value_of_size(np, propname,\n\t\t\t\t\t\t(sz_min * sizeof(*out_values)),\n\t\t\t\t\t\t(sz_max * sizeof(*out_values)),\n\t\t\t\t\t\t&sz);\n\n\tif (IS_ERR(val))\n\t\treturn PTR_ERR(val);\n\n\tif (!sz_max)\n\t\tsz = sz_min;\n\telse\n\t\tsz /= sizeof(*out_values);\n\n\tcount = sz;\n\twhile (count--)\n\t\t*out_values++ = *val++;\n\n\treturn sz;\n}\nEXPORT_SYMBOL_GPL(of_property_read_variable_u8_array);\n\n \nint of_property_read_variable_u16_array(const struct device_node *np,\n\t\t\t\t\tconst char *propname, u16 *out_values,\n\t\t\t\t\tsize_t sz_min, size_t sz_max)\n{\n\tsize_t sz, count;\n\tconst __be16 *val = of_find_property_value_of_size(np, propname,\n\t\t\t\t\t\t(sz_min * sizeof(*out_values)),\n\t\t\t\t\t\t(sz_max * sizeof(*out_values)),\n\t\t\t\t\t\t&sz);\n\n\tif (IS_ERR(val))\n\t\treturn PTR_ERR(val);\n\n\tif (!sz_max)\n\t\tsz = sz_min;\n\telse\n\t\tsz /= sizeof(*out_values);\n\n\tcount = sz;\n\twhile (count--)\n\t\t*out_values++ = be16_to_cpup(val++);\n\n\treturn sz;\n}\nEXPORT_SYMBOL_GPL(of_property_read_variable_u16_array);\n\n \nint of_property_read_variable_u32_array(const struct device_node *np,\n\t\t\t       const char *propname, u32 *out_values,\n\t\t\t       size_t sz_min, size_t sz_max)\n{\n\tsize_t sz, count;\n\tconst __be32 *val = of_find_property_value_of_size(np, propname,\n\t\t\t\t\t\t(sz_min * sizeof(*out_values)),\n\t\t\t\t\t\t(sz_max * sizeof(*out_values)),\n\t\t\t\t\t\t&sz);\n\n\tif (IS_ERR(val))\n\t\treturn PTR_ERR(val);\n\n\tif (!sz_max)\n\t\tsz = sz_min;\n\telse\n\t\tsz /= sizeof(*out_values);\n\n\tcount = sz;\n\twhile (count--)\n\t\t*out_values++ = be32_to_cpup(val++);\n\n\treturn sz;\n}\nEXPORT_SYMBOL_GPL(of_property_read_variable_u32_array);\n\n \nint of_property_read_u64(const struct device_node *np, const char *propname,\n\t\t\t u64 *out_value)\n{\n\tconst __be32 *val = of_find_property_value_of_size(np, propname,\n\t\t\t\t\t\tsizeof(*out_value),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tNULL);\n\n\tif (IS_ERR(val))\n\t\treturn PTR_ERR(val);\n\n\t*out_value = of_read_number(val, 2);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_property_read_u64);\n\n \nint of_property_read_variable_u64_array(const struct device_node *np,\n\t\t\t       const char *propname, u64 *out_values,\n\t\t\t       size_t sz_min, size_t sz_max)\n{\n\tsize_t sz, count;\n\tconst __be32 *val = of_find_property_value_of_size(np, propname,\n\t\t\t\t\t\t(sz_min * sizeof(*out_values)),\n\t\t\t\t\t\t(sz_max * sizeof(*out_values)),\n\t\t\t\t\t\t&sz);\n\n\tif (IS_ERR(val))\n\t\treturn PTR_ERR(val);\n\n\tif (!sz_max)\n\t\tsz = sz_min;\n\telse\n\t\tsz /= sizeof(*out_values);\n\n\tcount = sz;\n\twhile (count--) {\n\t\t*out_values++ = of_read_number(val, 2);\n\t\tval += 2;\n\t}\n\n\treturn sz;\n}\nEXPORT_SYMBOL_GPL(of_property_read_variable_u64_array);\n\n \nint of_property_read_string(const struct device_node *np, const char *propname,\n\t\t\t\tconst char **out_string)\n{\n\tconst struct property *prop = of_find_property(np, propname, NULL);\n\tif (!prop)\n\t\treturn -EINVAL;\n\tif (!prop->length)\n\t\treturn -ENODATA;\n\tif (strnlen(prop->value, prop->length) >= prop->length)\n\t\treturn -EILSEQ;\n\t*out_string = prop->value;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_property_read_string);\n\n \nint of_property_match_string(const struct device_node *np, const char *propname,\n\t\t\t     const char *string)\n{\n\tconst struct property *prop = of_find_property(np, propname, NULL);\n\tsize_t l;\n\tint i;\n\tconst char *p, *end;\n\n\tif (!prop)\n\t\treturn -EINVAL;\n\tif (!prop->value)\n\t\treturn -ENODATA;\n\n\tp = prop->value;\n\tend = p + prop->length;\n\n\tfor (i = 0; p < end; i++, p += l) {\n\t\tl = strnlen(p, end - p) + 1;\n\t\tif (p + l > end)\n\t\t\treturn -EILSEQ;\n\t\tpr_debug(\"comparing %s with %s\\n\", string, p);\n\t\tif (strcmp(string, p) == 0)\n\t\t\treturn i;  \n\t}\n\treturn -ENODATA;\n}\nEXPORT_SYMBOL_GPL(of_property_match_string);\n\n \nint of_property_read_string_helper(const struct device_node *np,\n\t\t\t\t   const char *propname, const char **out_strs,\n\t\t\t\t   size_t sz, int skip)\n{\n\tconst struct property *prop = of_find_property(np, propname, NULL);\n\tint l = 0, i = 0;\n\tconst char *p, *end;\n\n\tif (!prop)\n\t\treturn -EINVAL;\n\tif (!prop->value)\n\t\treturn -ENODATA;\n\tp = prop->value;\n\tend = p + prop->length;\n\n\tfor (i = 0; p < end && (!out_strs || i < skip + sz); i++, p += l) {\n\t\tl = strnlen(p, end - p) + 1;\n\t\tif (p + l > end)\n\t\t\treturn -EILSEQ;\n\t\tif (out_strs && i >= skip)\n\t\t\t*out_strs++ = p;\n\t}\n\ti -= skip;\n\treturn i <= 0 ? -ENODATA : i;\n}\nEXPORT_SYMBOL_GPL(of_property_read_string_helper);\n\nconst __be32 *of_prop_next_u32(struct property *prop, const __be32 *cur,\n\t\t\t       u32 *pu)\n{\n\tconst void *curv = cur;\n\n\tif (!prop)\n\t\treturn NULL;\n\n\tif (!cur) {\n\t\tcurv = prop->value;\n\t\tgoto out_val;\n\t}\n\n\tcurv += sizeof(*cur);\n\tif (curv >= prop->value + prop->length)\n\t\treturn NULL;\n\nout_val:\n\t*pu = be32_to_cpup(curv);\n\treturn curv;\n}\nEXPORT_SYMBOL_GPL(of_prop_next_u32);\n\nconst char *of_prop_next_string(struct property *prop, const char *cur)\n{\n\tconst void *curv = cur;\n\n\tif (!prop)\n\t\treturn NULL;\n\n\tif (!cur)\n\t\treturn prop->value;\n\n\tcurv += strlen(cur) + 1;\n\tif (curv >= prop->value + prop->length)\n\t\treturn NULL;\n\n\treturn curv;\n}\nEXPORT_SYMBOL_GPL(of_prop_next_string);\n\n \nint of_graph_parse_endpoint(const struct device_node *node,\n\t\t\t    struct of_endpoint *endpoint)\n{\n\tstruct device_node *port_node = of_get_parent(node);\n\n\tWARN_ONCE(!port_node, \"%s(): endpoint %pOF has no parent node\\n\",\n\t\t  __func__, node);\n\n\tmemset(endpoint, 0, sizeof(*endpoint));\n\n\tendpoint->local_node = node;\n\t \n\tof_property_read_u32(port_node, \"reg\", &endpoint->port);\n\tof_property_read_u32(node, \"reg\", &endpoint->id);\n\n\tof_node_put(port_node);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(of_graph_parse_endpoint);\n\n \nstruct device_node *of_graph_get_port_by_id(struct device_node *parent, u32 id)\n{\n\tstruct device_node *node, *port;\n\n\tnode = of_get_child_by_name(parent, \"ports\");\n\tif (node)\n\t\tparent = node;\n\n\tfor_each_child_of_node(parent, port) {\n\t\tu32 port_id = 0;\n\n\t\tif (!of_node_name_eq(port, \"port\"))\n\t\t\tcontinue;\n\t\tof_property_read_u32(port, \"reg\", &port_id);\n\t\tif (id == port_id)\n\t\t\tbreak;\n\t}\n\n\tof_node_put(node);\n\n\treturn port;\n}\nEXPORT_SYMBOL(of_graph_get_port_by_id);\n\n \nstruct device_node *of_graph_get_next_endpoint(const struct device_node *parent,\n\t\t\t\t\tstruct device_node *prev)\n{\n\tstruct device_node *endpoint;\n\tstruct device_node *port;\n\n\tif (!parent)\n\t\treturn NULL;\n\n\t \n\tif (!prev) {\n\t\tstruct device_node *node;\n\n\t\tnode = of_get_child_by_name(parent, \"ports\");\n\t\tif (node)\n\t\t\tparent = node;\n\n\t\tport = of_get_child_by_name(parent, \"port\");\n\t\tof_node_put(node);\n\n\t\tif (!port) {\n\t\t\tpr_err(\"graph: no port node found in %pOF\\n\", parent);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tport = of_get_parent(prev);\n\t\tif (WARN_ONCE(!port, \"%s(): endpoint %pOF has no parent node\\n\",\n\t\t\t      __func__, prev))\n\t\t\treturn NULL;\n\t}\n\n\twhile (1) {\n\t\t \n\t\tendpoint = of_get_next_child(port, prev);\n\t\tif (endpoint) {\n\t\t\tof_node_put(port);\n\t\t\treturn endpoint;\n\t\t}\n\n\t\t \n\t\tprev = NULL;\n\n\t\tdo {\n\t\t\tport = of_get_next_child(parent, port);\n\t\t\tif (!port)\n\t\t\t\treturn NULL;\n\t\t} while (!of_node_name_eq(port, \"port\"));\n\t}\n}\nEXPORT_SYMBOL(of_graph_get_next_endpoint);\n\n \nstruct device_node *of_graph_get_endpoint_by_regs(\n\tconst struct device_node *parent, int port_reg, int reg)\n{\n\tstruct of_endpoint endpoint;\n\tstruct device_node *node = NULL;\n\n\tfor_each_endpoint_of_node(parent, node) {\n\t\tof_graph_parse_endpoint(node, &endpoint);\n\t\tif (((port_reg == -1) || (endpoint.port == port_reg)) &&\n\t\t\t((reg == -1) || (endpoint.id == reg)))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(of_graph_get_endpoint_by_regs);\n\n \nstruct device_node *of_graph_get_remote_endpoint(const struct device_node *node)\n{\n\t \n\treturn of_parse_phandle(node, \"remote-endpoint\", 0);\n}\nEXPORT_SYMBOL(of_graph_get_remote_endpoint);\n\n \nstruct device_node *of_graph_get_port_parent(struct device_node *node)\n{\n\tunsigned int depth;\n\n\tif (!node)\n\t\treturn NULL;\n\n\t \n\tof_node_get(node);\n\n\t \n\tfor (depth = 3; depth && node; depth--) {\n\t\tnode = of_get_next_parent(node);\n\t\tif (depth == 2 && !of_node_name_eq(node, \"ports\"))\n\t\t\tbreak;\n\t}\n\treturn node;\n}\nEXPORT_SYMBOL(of_graph_get_port_parent);\n\n \nstruct device_node *of_graph_get_remote_port_parent(\n\t\t\t       const struct device_node *node)\n{\n\tstruct device_node *np, *pp;\n\n\t \n\tnp = of_graph_get_remote_endpoint(node);\n\n\tpp = of_graph_get_port_parent(np);\n\n\tof_node_put(np);\n\n\treturn pp;\n}\nEXPORT_SYMBOL(of_graph_get_remote_port_parent);\n\n \nstruct device_node *of_graph_get_remote_port(const struct device_node *node)\n{\n\tstruct device_node *np;\n\n\t \n\tnp = of_graph_get_remote_endpoint(node);\n\tif (!np)\n\t\treturn NULL;\n\treturn of_get_next_parent(np);\n}\nEXPORT_SYMBOL(of_graph_get_remote_port);\n\nint of_graph_get_endpoint_count(const struct device_node *np)\n{\n\tstruct device_node *endpoint;\n\tint num = 0;\n\n\tfor_each_endpoint_of_node(np, endpoint)\n\t\tnum++;\n\n\treturn num;\n}\nEXPORT_SYMBOL(of_graph_get_endpoint_count);\n\n \nstruct device_node *of_graph_get_remote_node(const struct device_node *node,\n\t\t\t\t\t     u32 port, u32 endpoint)\n{\n\tstruct device_node *endpoint_node, *remote;\n\n\tendpoint_node = of_graph_get_endpoint_by_regs(node, port, endpoint);\n\tif (!endpoint_node) {\n\t\tpr_debug(\"no valid endpoint (%d, %d) for node %pOF\\n\",\n\t\t\t port, endpoint, node);\n\t\treturn NULL;\n\t}\n\n\tremote = of_graph_get_remote_port_parent(endpoint_node);\n\tof_node_put(endpoint_node);\n\tif (!remote) {\n\t\tpr_debug(\"no valid remote node\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!of_device_is_available(remote)) {\n\t\tpr_debug(\"not available for remote node\\n\");\n\t\tof_node_put(remote);\n\t\treturn NULL;\n\t}\n\n\treturn remote;\n}\nEXPORT_SYMBOL(of_graph_get_remote_node);\n\nstatic struct fwnode_handle *of_fwnode_get(struct fwnode_handle *fwnode)\n{\n\treturn of_fwnode_handle(of_node_get(to_of_node(fwnode)));\n}\n\nstatic void of_fwnode_put(struct fwnode_handle *fwnode)\n{\n\tof_node_put(to_of_node(fwnode));\n}\n\nstatic bool of_fwnode_device_is_available(const struct fwnode_handle *fwnode)\n{\n\treturn of_device_is_available(to_of_node(fwnode));\n}\n\nstatic bool of_fwnode_device_dma_supported(const struct fwnode_handle *fwnode)\n{\n\treturn true;\n}\n\nstatic enum dev_dma_attr\nof_fwnode_device_get_dma_attr(const struct fwnode_handle *fwnode)\n{\n\tif (of_dma_is_coherent(to_of_node(fwnode)))\n\t\treturn DEV_DMA_COHERENT;\n\telse\n\t\treturn DEV_DMA_NON_COHERENT;\n}\n\nstatic bool of_fwnode_property_present(const struct fwnode_handle *fwnode,\n\t\t\t\t       const char *propname)\n{\n\treturn of_property_read_bool(to_of_node(fwnode), propname);\n}\n\nstatic int of_fwnode_property_read_int_array(const struct fwnode_handle *fwnode,\n\t\t\t\t\t     const char *propname,\n\t\t\t\t\t     unsigned int elem_size, void *val,\n\t\t\t\t\t     size_t nval)\n{\n\tconst struct device_node *node = to_of_node(fwnode);\n\n\tif (!val)\n\t\treturn of_property_count_elems_of_size(node, propname,\n\t\t\t\t\t\t       elem_size);\n\n\tswitch (elem_size) {\n\tcase sizeof(u8):\n\t\treturn of_property_read_u8_array(node, propname, val, nval);\n\tcase sizeof(u16):\n\t\treturn of_property_read_u16_array(node, propname, val, nval);\n\tcase sizeof(u32):\n\t\treturn of_property_read_u32_array(node, propname, val, nval);\n\tcase sizeof(u64):\n\t\treturn of_property_read_u64_array(node, propname, val, nval);\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic int\nof_fwnode_property_read_string_array(const struct fwnode_handle *fwnode,\n\t\t\t\t     const char *propname, const char **val,\n\t\t\t\t     size_t nval)\n{\n\tconst struct device_node *node = to_of_node(fwnode);\n\n\treturn val ?\n\t\tof_property_read_string_array(node, propname, val, nval) :\n\t\tof_property_count_strings(node, propname);\n}\n\nstatic const char *of_fwnode_get_name(const struct fwnode_handle *fwnode)\n{\n\treturn kbasename(to_of_node(fwnode)->full_name);\n}\n\nstatic const char *of_fwnode_get_name_prefix(const struct fwnode_handle *fwnode)\n{\n\t \n\tif (!to_of_node(fwnode)->parent)\n\t\treturn \"\";\n\n\treturn \"/\";\n}\n\nstatic struct fwnode_handle *\nof_fwnode_get_parent(const struct fwnode_handle *fwnode)\n{\n\treturn of_fwnode_handle(of_get_parent(to_of_node(fwnode)));\n}\n\nstatic struct fwnode_handle *\nof_fwnode_get_next_child_node(const struct fwnode_handle *fwnode,\n\t\t\t      struct fwnode_handle *child)\n{\n\treturn of_fwnode_handle(of_get_next_available_child(to_of_node(fwnode),\n\t\t\t\t\t\t\t    to_of_node(child)));\n}\n\nstatic struct fwnode_handle *\nof_fwnode_get_named_child_node(const struct fwnode_handle *fwnode,\n\t\t\t       const char *childname)\n{\n\tconst struct device_node *node = to_of_node(fwnode);\n\tstruct device_node *child;\n\n\tfor_each_available_child_of_node(node, child)\n\t\tif (of_node_name_eq(child, childname))\n\t\t\treturn of_fwnode_handle(child);\n\n\treturn NULL;\n}\n\nstatic int\nof_fwnode_get_reference_args(const struct fwnode_handle *fwnode,\n\t\t\t     const char *prop, const char *nargs_prop,\n\t\t\t     unsigned int nargs, unsigned int index,\n\t\t\t     struct fwnode_reference_args *args)\n{\n\tstruct of_phandle_args of_args;\n\tunsigned int i;\n\tint ret;\n\n\tif (nargs_prop)\n\t\tret = of_parse_phandle_with_args(to_of_node(fwnode), prop,\n\t\t\t\t\t\t nargs_prop, index, &of_args);\n\telse\n\t\tret = of_parse_phandle_with_fixed_args(to_of_node(fwnode), prop,\n\t\t\t\t\t\t       nargs, index, &of_args);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!args) {\n\t\tof_node_put(of_args.np);\n\t\treturn 0;\n\t}\n\n\targs->nargs = of_args.args_count;\n\targs->fwnode = of_fwnode_handle(of_args.np);\n\n\tfor (i = 0; i < NR_FWNODE_REFERENCE_ARGS; i++)\n\t\targs->args[i] = i < of_args.args_count ? of_args.args[i] : 0;\n\n\treturn 0;\n}\n\nstatic struct fwnode_handle *\nof_fwnode_graph_get_next_endpoint(const struct fwnode_handle *fwnode,\n\t\t\t\t  struct fwnode_handle *prev)\n{\n\treturn of_fwnode_handle(of_graph_get_next_endpoint(to_of_node(fwnode),\n\t\t\t\t\t\t\t   to_of_node(prev)));\n}\n\nstatic struct fwnode_handle *\nof_fwnode_graph_get_remote_endpoint(const struct fwnode_handle *fwnode)\n{\n\treturn of_fwnode_handle(\n\t\tof_graph_get_remote_endpoint(to_of_node(fwnode)));\n}\n\nstatic struct fwnode_handle *\nof_fwnode_graph_get_port_parent(struct fwnode_handle *fwnode)\n{\n\tstruct device_node *np;\n\n\t \n\tnp = of_get_parent(to_of_node(fwnode));\n\tif (!np)\n\t\treturn NULL;\n\n\t \n\tif (!of_node_name_eq(np, \"ports\"))\n\t\treturn of_fwnode_handle(np);\n\n\treturn of_fwnode_handle(of_get_next_parent(np));\n}\n\nstatic int of_fwnode_graph_parse_endpoint(const struct fwnode_handle *fwnode,\n\t\t\t\t\t  struct fwnode_endpoint *endpoint)\n{\n\tconst struct device_node *node = to_of_node(fwnode);\n\tstruct device_node *port_node = of_get_parent(node);\n\n\tendpoint->local_fwnode = fwnode;\n\n\tof_property_read_u32(port_node, \"reg\", &endpoint->port);\n\tof_property_read_u32(node, \"reg\", &endpoint->id);\n\n\tof_node_put(port_node);\n\n\treturn 0;\n}\n\nstatic const void *\nof_fwnode_device_get_match_data(const struct fwnode_handle *fwnode,\n\t\t\t\tconst struct device *dev)\n{\n\treturn of_device_get_match_data(dev);\n}\n\nstatic struct device_node *of_get_compat_node(struct device_node *np)\n{\n\tof_node_get(np);\n\n\twhile (np) {\n\t\tif (!of_device_is_available(np)) {\n\t\t\tof_node_put(np);\n\t\t\tnp = NULL;\n\t\t}\n\n\t\tif (of_property_present(np, \"compatible\"))\n\t\t\tbreak;\n\n\t\tnp = of_get_next_parent(np);\n\t}\n\n\treturn np;\n}\n\nstatic struct device_node *of_get_compat_node_parent(struct device_node *np)\n{\n\tstruct device_node *parent, *node;\n\n\tparent = of_get_parent(np);\n\tnode = of_get_compat_node(parent);\n\tof_node_put(parent);\n\n\treturn node;\n}\n\nstatic void of_link_to_phandle(struct device_node *con_np,\n\t\t\t      struct device_node *sup_np)\n{\n\tstruct device_node *tmp_np = of_node_get(sup_np);\n\n\t \n\twhile (tmp_np) {\n\t\tif (of_fwnode_handle(tmp_np)->dev) {\n\t\t\tof_node_put(tmp_np);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!of_device_is_available(tmp_np)) {\n\t\t\tof_node_put(tmp_np);\n\t\t\treturn;\n\t\t}\n\n\t\ttmp_np = of_get_next_parent(tmp_np);\n\t}\n\n\tfwnode_link_add(of_fwnode_handle(con_np), of_fwnode_handle(sup_np));\n}\n\n \nstatic struct device_node *parse_prop_cells(struct device_node *np,\n\t\t\t\t\t    const char *prop_name, int index,\n\t\t\t\t\t    const char *list_name,\n\t\t\t\t\t    const char *cells_name)\n{\n\tstruct of_phandle_args sup_args;\n\n\tif (strcmp(prop_name, list_name))\n\t\treturn NULL;\n\n\tif (__of_parse_phandle_with_args(np, list_name, cells_name, 0, index,\n\t\t\t\t\t &sup_args))\n\t\treturn NULL;\n\n\treturn sup_args.np;\n}\n\n#define DEFINE_SIMPLE_PROP(fname, name, cells)\t\t\t\t  \\\nstatic struct device_node *parse_##fname(struct device_node *np,\t  \\\n\t\t\t\t\tconst char *prop_name, int index) \\\n{\t\t\t\t\t\t\t\t\t  \\\n\treturn parse_prop_cells(np, prop_name, index, name, cells);\t  \\\n}\n\nstatic int strcmp_suffix(const char *str, const char *suffix)\n{\n\tunsigned int len, suffix_len;\n\n\tlen = strlen(str);\n\tsuffix_len = strlen(suffix);\n\tif (len <= suffix_len)\n\t\treturn -1;\n\treturn strcmp(str + len - suffix_len, suffix);\n}\n\n \nstatic struct device_node *parse_suffix_prop_cells(struct device_node *np,\n\t\t\t\t\t    const char *prop_name, int index,\n\t\t\t\t\t    const char *suffix,\n\t\t\t\t\t    const char *cells_name)\n{\n\tstruct of_phandle_args sup_args;\n\n\tif (strcmp_suffix(prop_name, suffix))\n\t\treturn NULL;\n\n\tif (of_parse_phandle_with_args(np, prop_name, cells_name, index,\n\t\t\t\t       &sup_args))\n\t\treturn NULL;\n\n\treturn sup_args.np;\n}\n\n#define DEFINE_SUFFIX_PROP(fname, suffix, cells)\t\t\t     \\\nstatic struct device_node *parse_##fname(struct device_node *np,\t     \\\n\t\t\t\t\tconst char *prop_name, int index)    \\\n{\t\t\t\t\t\t\t\t\t     \\\n\treturn parse_suffix_prop_cells(np, prop_name, index, suffix, cells); \\\n}\n\n \nstruct supplier_bindings {\n\tstruct device_node *(*parse_prop)(struct device_node *np,\n\t\t\t\t\t  const char *prop_name, int index);\n\tbool optional;\n\tbool node_not_dev;\n};\n\nDEFINE_SIMPLE_PROP(clocks, \"clocks\", \"#clock-cells\")\nDEFINE_SIMPLE_PROP(interconnects, \"interconnects\", \"#interconnect-cells\")\nDEFINE_SIMPLE_PROP(iommus, \"iommus\", \"#iommu-cells\")\nDEFINE_SIMPLE_PROP(mboxes, \"mboxes\", \"#mbox-cells\")\nDEFINE_SIMPLE_PROP(io_channels, \"io-channel\", \"#io-channel-cells\")\nDEFINE_SIMPLE_PROP(interrupt_parent, \"interrupt-parent\", NULL)\nDEFINE_SIMPLE_PROP(dmas, \"dmas\", \"#dma-cells\")\nDEFINE_SIMPLE_PROP(power_domains, \"power-domains\", \"#power-domain-cells\")\nDEFINE_SIMPLE_PROP(hwlocks, \"hwlocks\", \"#hwlock-cells\")\nDEFINE_SIMPLE_PROP(extcon, \"extcon\", NULL)\nDEFINE_SIMPLE_PROP(nvmem_cells, \"nvmem-cells\", \"#nvmem-cell-cells\")\nDEFINE_SIMPLE_PROP(phys, \"phys\", \"#phy-cells\")\nDEFINE_SIMPLE_PROP(wakeup_parent, \"wakeup-parent\", NULL)\nDEFINE_SIMPLE_PROP(pinctrl0, \"pinctrl-0\", NULL)\nDEFINE_SIMPLE_PROP(pinctrl1, \"pinctrl-1\", NULL)\nDEFINE_SIMPLE_PROP(pinctrl2, \"pinctrl-2\", NULL)\nDEFINE_SIMPLE_PROP(pinctrl3, \"pinctrl-3\", NULL)\nDEFINE_SIMPLE_PROP(pinctrl4, \"pinctrl-4\", NULL)\nDEFINE_SIMPLE_PROP(pinctrl5, \"pinctrl-5\", NULL)\nDEFINE_SIMPLE_PROP(pinctrl6, \"pinctrl-6\", NULL)\nDEFINE_SIMPLE_PROP(pinctrl7, \"pinctrl-7\", NULL)\nDEFINE_SIMPLE_PROP(pinctrl8, \"pinctrl-8\", NULL)\nDEFINE_SIMPLE_PROP(remote_endpoint, \"remote-endpoint\", NULL)\nDEFINE_SIMPLE_PROP(pwms, \"pwms\", \"#pwm-cells\")\nDEFINE_SIMPLE_PROP(resets, \"resets\", \"#reset-cells\")\nDEFINE_SIMPLE_PROP(leds, \"leds\", NULL)\nDEFINE_SIMPLE_PROP(backlight, \"backlight\", NULL)\nDEFINE_SIMPLE_PROP(panel, \"panel\", NULL)\nDEFINE_SUFFIX_PROP(regulators, \"-supply\", NULL)\nDEFINE_SUFFIX_PROP(gpio, \"-gpio\", \"#gpio-cells\")\n\nstatic struct device_node *parse_gpios(struct device_node *np,\n\t\t\t\t       const char *prop_name, int index)\n{\n\tif (!strcmp_suffix(prop_name, \",nr-gpios\"))\n\t\treturn NULL;\n\n\treturn parse_suffix_prop_cells(np, prop_name, index, \"-gpios\",\n\t\t\t\t       \"#gpio-cells\");\n}\n\nstatic struct device_node *parse_iommu_maps(struct device_node *np,\n\t\t\t\t\t    const char *prop_name, int index)\n{\n\tif (strcmp(prop_name, \"iommu-map\"))\n\t\treturn NULL;\n\n\treturn of_parse_phandle(np, prop_name, (index * 4) + 1);\n}\n\nstatic struct device_node *parse_gpio_compat(struct device_node *np,\n\t\t\t\t\t     const char *prop_name, int index)\n{\n\tstruct of_phandle_args sup_args;\n\n\tif (strcmp(prop_name, \"gpio\") && strcmp(prop_name, \"gpios\"))\n\t\treturn NULL;\n\n\t \n\tif (of_property_read_bool(np, \"gpio-hog\"))\n\t\treturn NULL;\n\n\tif (of_parse_phandle_with_args(np, prop_name, \"#gpio-cells\", index,\n\t\t\t\t       &sup_args))\n\t\treturn NULL;\n\n\treturn sup_args.np;\n}\n\nstatic struct device_node *parse_interrupts(struct device_node *np,\n\t\t\t\t\t    const char *prop_name, int index)\n{\n\tstruct of_phandle_args sup_args;\n\n\tif (!IS_ENABLED(CONFIG_OF_IRQ) || IS_ENABLED(CONFIG_PPC))\n\t\treturn NULL;\n\n\tif (strcmp(prop_name, \"interrupts\") &&\n\t    strcmp(prop_name, \"interrupts-extended\"))\n\t\treturn NULL;\n\n\treturn of_irq_parse_one(np, index, &sup_args) ? NULL : sup_args.np;\n}\n\nstatic const struct supplier_bindings of_supplier_bindings[] = {\n\t{ .parse_prop = parse_clocks, },\n\t{ .parse_prop = parse_interconnects, },\n\t{ .parse_prop = parse_iommus, .optional = true, },\n\t{ .parse_prop = parse_iommu_maps, .optional = true, },\n\t{ .parse_prop = parse_mboxes, },\n\t{ .parse_prop = parse_io_channels, },\n\t{ .parse_prop = parse_interrupt_parent, },\n\t{ .parse_prop = parse_dmas, .optional = true, },\n\t{ .parse_prop = parse_power_domains, },\n\t{ .parse_prop = parse_hwlocks, },\n\t{ .parse_prop = parse_extcon, },\n\t{ .parse_prop = parse_nvmem_cells, },\n\t{ .parse_prop = parse_phys, },\n\t{ .parse_prop = parse_wakeup_parent, },\n\t{ .parse_prop = parse_pinctrl0, },\n\t{ .parse_prop = parse_pinctrl1, },\n\t{ .parse_prop = parse_pinctrl2, },\n\t{ .parse_prop = parse_pinctrl3, },\n\t{ .parse_prop = parse_pinctrl4, },\n\t{ .parse_prop = parse_pinctrl5, },\n\t{ .parse_prop = parse_pinctrl6, },\n\t{ .parse_prop = parse_pinctrl7, },\n\t{ .parse_prop = parse_pinctrl8, },\n\t{ .parse_prop = parse_remote_endpoint, .node_not_dev = true, },\n\t{ .parse_prop = parse_pwms, },\n\t{ .parse_prop = parse_resets, },\n\t{ .parse_prop = parse_leds, },\n\t{ .parse_prop = parse_backlight, },\n\t{ .parse_prop = parse_panel, },\n\t{ .parse_prop = parse_gpio_compat, },\n\t{ .parse_prop = parse_interrupts, },\n\t{ .parse_prop = parse_regulators, },\n\t{ .parse_prop = parse_gpio, },\n\t{ .parse_prop = parse_gpios, },\n\t{}\n};\n\n \nstatic int of_link_property(struct device_node *con_np, const char *prop_name)\n{\n\tstruct device_node *phandle;\n\tconst struct supplier_bindings *s = of_supplier_bindings;\n\tunsigned int i = 0;\n\tbool matched = false;\n\n\t \n\twhile (!matched && s->parse_prop) {\n\t\tif (s->optional && !fw_devlink_is_strict()) {\n\t\t\ts++;\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile ((phandle = s->parse_prop(con_np, prop_name, i))) {\n\t\t\tstruct device_node *con_dev_np;\n\n\t\t\tcon_dev_np = s->node_not_dev\n\t\t\t\t\t? of_get_compat_node_parent(con_np)\n\t\t\t\t\t: of_node_get(con_np);\n\t\t\tmatched = true;\n\t\t\ti++;\n\t\t\tof_link_to_phandle(con_dev_np, phandle);\n\t\t\tof_node_put(phandle);\n\t\t\tof_node_put(con_dev_np);\n\t\t}\n\t\ts++;\n\t}\n\treturn 0;\n}\n\nstatic void __iomem *of_fwnode_iomap(struct fwnode_handle *fwnode, int index)\n{\n#ifdef CONFIG_OF_ADDRESS\n\treturn of_iomap(to_of_node(fwnode), index);\n#else\n\treturn NULL;\n#endif\n}\n\nstatic int of_fwnode_irq_get(const struct fwnode_handle *fwnode,\n\t\t\t     unsigned int index)\n{\n\treturn of_irq_get(to_of_node(fwnode), index);\n}\n\nstatic int of_fwnode_add_links(struct fwnode_handle *fwnode)\n{\n\tstruct property *p;\n\tstruct device_node *con_np = to_of_node(fwnode);\n\n\tif (IS_ENABLED(CONFIG_X86))\n\t\treturn 0;\n\n\tif (!con_np)\n\t\treturn -EINVAL;\n\n\tfor_each_property_of_node(con_np, p)\n\t\tof_link_property(con_np, p->name);\n\n\treturn 0;\n}\n\nconst struct fwnode_operations of_fwnode_ops = {\n\t.get = of_fwnode_get,\n\t.put = of_fwnode_put,\n\t.device_is_available = of_fwnode_device_is_available,\n\t.device_get_match_data = of_fwnode_device_get_match_data,\n\t.device_dma_supported = of_fwnode_device_dma_supported,\n\t.device_get_dma_attr = of_fwnode_device_get_dma_attr,\n\t.property_present = of_fwnode_property_present,\n\t.property_read_int_array = of_fwnode_property_read_int_array,\n\t.property_read_string_array = of_fwnode_property_read_string_array,\n\t.get_name = of_fwnode_get_name,\n\t.get_name_prefix = of_fwnode_get_name_prefix,\n\t.get_parent = of_fwnode_get_parent,\n\t.get_next_child_node = of_fwnode_get_next_child_node,\n\t.get_named_child_node = of_fwnode_get_named_child_node,\n\t.get_reference_args = of_fwnode_get_reference_args,\n\t.graph_get_next_endpoint = of_fwnode_graph_get_next_endpoint,\n\t.graph_get_remote_endpoint = of_fwnode_graph_get_remote_endpoint,\n\t.graph_get_port_parent = of_fwnode_graph_get_port_parent,\n\t.graph_parse_endpoint = of_fwnode_graph_parse_endpoint,\n\t.iomap = of_fwnode_iomap,\n\t.irq_get = of_fwnode_irq_get,\n\t.add_links = of_fwnode_add_links,\n};\nEXPORT_SYMBOL_GPL(of_fwnode_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}