{
  "module_name": "overlay.c",
  "hash_id": "ccea6eb4e6db179d946e928869c1e220f90ea424d9e39d92165ae367517ea1cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/overlay.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"OF: overlay: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_fdt.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/libfdt.h>\n#include <linux/err.h>\n#include <linux/idr.h>\n\n#include \"of_private.h\"\n\n \nstruct target {\n\tstruct device_node *np;\n\tbool in_livetree;\n};\n\n \nstruct fragment {\n\tstruct device_node *overlay;\n\tstruct device_node *target;\n};\n\n \nstruct overlay_changeset {\n\tint id;\n\tstruct list_head ovcs_list;\n\tconst void *new_fdt;\n\tconst void *overlay_mem;\n\tstruct device_node *overlay_root;\n\tenum of_overlay_notify_action notify_state;\n\tint count;\n\tstruct fragment *fragments;\n\tbool symbols_fragment;\n\tstruct of_changeset cset;\n};\n\n \nstatic int devicetree_state_flags;\n#define DTSF_APPLY_FAIL\t\t0x01\n#define DTSF_REVERT_FAIL\t0x02\n\n \nstatic int devicetree_corrupt(void)\n{\n\treturn devicetree_state_flags &\n\t\t(DTSF_APPLY_FAIL | DTSF_REVERT_FAIL);\n}\n\nstatic int build_changeset_next_level(struct overlay_changeset *ovcs,\n\t\tstruct target *target, const struct device_node *overlay_node);\n\n \nstatic DEFINE_MUTEX(of_overlay_phandle_mutex);\n\nvoid of_overlay_mutex_lock(void)\n{\n\tmutex_lock(&of_overlay_phandle_mutex);\n}\n\nvoid of_overlay_mutex_unlock(void)\n{\n\tmutex_unlock(&of_overlay_phandle_mutex);\n}\n\nstatic LIST_HEAD(ovcs_list);\nstatic DEFINE_IDR(ovcs_idr);\n\nstatic BLOCKING_NOTIFIER_HEAD(overlay_notify_chain);\n\n \nint of_overlay_notifier_register(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&overlay_notify_chain, nb);\n}\nEXPORT_SYMBOL_GPL(of_overlay_notifier_register);\n\n \nint of_overlay_notifier_unregister(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&overlay_notify_chain, nb);\n}\nEXPORT_SYMBOL_GPL(of_overlay_notifier_unregister);\n\nstatic int overlay_notify(struct overlay_changeset *ovcs,\n\t\tenum of_overlay_notify_action action)\n{\n\tstruct of_overlay_notify_data nd;\n\tint i, ret;\n\n\tovcs->notify_state = action;\n\n\tfor (i = 0; i < ovcs->count; i++) {\n\t\tstruct fragment *fragment = &ovcs->fragments[i];\n\n\t\tnd.target = fragment->target;\n\t\tnd.overlay = fragment->overlay;\n\n\t\tret = blocking_notifier_call_chain(&overlay_notify_chain,\n\t\t\t\t\t\t   action, &nd);\n\t\tif (notifier_to_errno(ret)) {\n\t\t\tret = notifier_to_errno(ret);\n\t\t\tpr_err(\"overlay changeset %s notifier error %d, target: %pOF\\n\",\n\t\t\t       of_overlay_action_name(action), ret, nd.target);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct property *dup_and_fixup_symbol_prop(\n\t\tstruct overlay_changeset *ovcs, const struct property *prop)\n{\n\tstruct fragment *fragment;\n\tstruct property *new_prop;\n\tstruct device_node *fragment_node;\n\tstruct device_node *overlay_node;\n\tconst char *path;\n\tconst char *path_tail;\n\tconst char *target_path;\n\tint k;\n\tint overlay_name_len;\n\tint path_len;\n\tint path_tail_len;\n\tint target_path_len;\n\n\tif (!prop->value)\n\t\treturn NULL;\n\tif (strnlen(prop->value, prop->length) >= prop->length)\n\t\treturn NULL;\n\tpath = prop->value;\n\tpath_len = strlen(path);\n\n\tif (path_len < 1)\n\t\treturn NULL;\n\tfragment_node = __of_find_node_by_path(ovcs->overlay_root, path + 1);\n\toverlay_node = __of_find_node_by_path(fragment_node, \"__overlay__/\");\n\tof_node_put(fragment_node);\n\tof_node_put(overlay_node);\n\n\tfor (k = 0; k < ovcs->count; k++) {\n\t\tfragment = &ovcs->fragments[k];\n\t\tif (fragment->overlay == overlay_node)\n\t\t\tbreak;\n\t}\n\tif (k >= ovcs->count)\n\t\treturn NULL;\n\n\toverlay_name_len = snprintf(NULL, 0, \"%pOF\", fragment->overlay);\n\n\tif (overlay_name_len > path_len)\n\t\treturn NULL;\n\tpath_tail = path + overlay_name_len;\n\tpath_tail_len = strlen(path_tail);\n\n\ttarget_path = kasprintf(GFP_KERNEL, \"%pOF\", fragment->target);\n\tif (!target_path)\n\t\treturn NULL;\n\ttarget_path_len = strlen(target_path);\n\n\tnew_prop = kzalloc(sizeof(*new_prop), GFP_KERNEL);\n\tif (!new_prop)\n\t\tgoto err_free_target_path;\n\n\tnew_prop->name = kstrdup(prop->name, GFP_KERNEL);\n\tnew_prop->length = target_path_len + path_tail_len + 1;\n\tnew_prop->value = kzalloc(new_prop->length, GFP_KERNEL);\n\tif (!new_prop->name || !new_prop->value)\n\t\tgoto err_free_new_prop;\n\n\tstrcpy(new_prop->value, target_path);\n\tstrcpy(new_prop->value + target_path_len, path_tail);\n\n\tof_property_set_flag(new_prop, OF_DYNAMIC);\n\n\tkfree(target_path);\n\n\treturn new_prop;\n\nerr_free_new_prop:\n\tkfree(new_prop->name);\n\tkfree(new_prop->value);\n\tkfree(new_prop);\nerr_free_target_path:\n\tkfree(target_path);\n\n\treturn NULL;\n}\n\n \nstatic int add_changeset_property(struct overlay_changeset *ovcs,\n\t\tstruct target *target, struct property *overlay_prop,\n\t\tbool is_symbols_prop)\n{\n\tstruct property *new_prop = NULL, *prop;\n\tint ret = 0;\n\n\tif (target->in_livetree)\n\t\tif (!of_prop_cmp(overlay_prop->name, \"name\") ||\n\t\t    !of_prop_cmp(overlay_prop->name, \"phandle\") ||\n\t\t    !of_prop_cmp(overlay_prop->name, \"linux,phandle\"))\n\t\t\treturn 0;\n\n\tif (target->in_livetree)\n\t\tprop = of_find_property(target->np, overlay_prop->name, NULL);\n\telse\n\t\tprop = NULL;\n\n\tif (prop) {\n\t\tif (!of_prop_cmp(prop->name, \"#address-cells\")) {\n\t\t\tif (!of_prop_val_eq(prop, overlay_prop)) {\n\t\t\t\tpr_err(\"ERROR: changing value of #address-cells is not allowed in %pOF\\n\",\n\t\t\t\t       target->np);\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\treturn ret;\n\n\t\t} else if (!of_prop_cmp(prop->name, \"#size-cells\")) {\n\t\t\tif (!of_prop_val_eq(prop, overlay_prop)) {\n\t\t\t\tpr_err(\"ERROR: changing value of #size-cells is not allowed in %pOF\\n\",\n\t\t\t\t       target->np);\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (is_symbols_prop) {\n\t\tif (prop)\n\t\t\treturn -EINVAL;\n\t\tnew_prop = dup_and_fixup_symbol_prop(ovcs, overlay_prop);\n\t} else {\n\t\tnew_prop = __of_prop_dup(overlay_prop, GFP_KERNEL);\n\t}\n\n\tif (!new_prop)\n\t\treturn -ENOMEM;\n\n\tif (!prop) {\n\t\tif (!target->in_livetree) {\n\t\t\tnew_prop->next = target->np->deadprops;\n\t\t\ttarget->np->deadprops = new_prop;\n\t\t}\n\t\tret = of_changeset_add_property(&ovcs->cset, target->np,\n\t\t\t\t\t\tnew_prop);\n\t} else {\n\t\tret = of_changeset_update_property(&ovcs->cset, target->np,\n\t\t\t\t\t\t   new_prop);\n\t}\n\n\tif (!of_node_check_flag(target->np, OF_OVERLAY))\n\t\tpr_err(\"WARNING: memory leak will occur if overlay removed, property: %pOF/%s\\n\",\n\t\t       target->np, new_prop->name);\n\n\tif (ret) {\n\t\tkfree(new_prop->name);\n\t\tkfree(new_prop->value);\n\t\tkfree(new_prop);\n\t}\n\treturn ret;\n}\n\n \nstatic int add_changeset_node(struct overlay_changeset *ovcs,\n\t\tstruct target *target, struct device_node *node)\n{\n\tconst char *node_kbasename;\n\tconst __be32 *phandle;\n\tstruct device_node *tchild;\n\tstruct target target_child;\n\tint ret = 0, size;\n\n\tnode_kbasename = kbasename(node->full_name);\n\n\tfor_each_child_of_node(target->np, tchild)\n\t\tif (!of_node_cmp(node_kbasename, kbasename(tchild->full_name)))\n\t\t\tbreak;\n\n\tif (!tchild) {\n\t\ttchild = __of_node_dup(NULL, node_kbasename);\n\t\tif (!tchild)\n\t\t\treturn -ENOMEM;\n\n\t\ttchild->parent = target->np;\n\t\ttchild->name = __of_get_property(node, \"name\", NULL);\n\n\t\tif (!tchild->name)\n\t\t\ttchild->name = \"<NULL>\";\n\n\t\t \n\t\tphandle = __of_get_property(node, \"phandle\", &size);\n\t\tif (phandle && (size == 4))\n\t\t\ttchild->phandle = be32_to_cpup(phandle);\n\n\t\tof_node_set_flag(tchild, OF_OVERLAY);\n\n\t\tret = of_changeset_attach_node(&ovcs->cset, tchild);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttarget_child.np = tchild;\n\t\ttarget_child.in_livetree = false;\n\n\t\tret = build_changeset_next_level(ovcs, &target_child, node);\n\t\tof_node_put(tchild);\n\t\treturn ret;\n\t}\n\n\tif (node->phandle && tchild->phandle) {\n\t\tret = -EINVAL;\n\t} else {\n\t\ttarget_child.np = tchild;\n\t\ttarget_child.in_livetree = target->in_livetree;\n\t\tret = build_changeset_next_level(ovcs, &target_child, node);\n\t}\n\tof_node_put(tchild);\n\n\treturn ret;\n}\n\n \nstatic int build_changeset_next_level(struct overlay_changeset *ovcs,\n\t\tstruct target *target, const struct device_node *overlay_node)\n{\n\tstruct device_node *child;\n\tstruct property *prop;\n\tint ret;\n\n\tfor_each_property_of_node(overlay_node, prop) {\n\t\tret = add_changeset_property(ovcs, target, prop, 0);\n\t\tif (ret) {\n\t\t\tpr_debug(\"Failed to apply prop @%pOF/%s, err=%d\\n\",\n\t\t\t\t target->np, prop->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_child_of_node(overlay_node, child) {\n\t\tret = add_changeset_node(ovcs, target, child);\n\t\tif (ret) {\n\t\t\tpr_debug(\"Failed to apply node @%pOF/%pOFn, err=%d\\n\",\n\t\t\t\t target->np, child, ret);\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int build_changeset_symbols_node(struct overlay_changeset *ovcs,\n\t\tstruct target *target,\n\t\tconst struct device_node *overlay_symbols_node)\n{\n\tstruct property *prop;\n\tint ret;\n\n\tfor_each_property_of_node(overlay_symbols_node, prop) {\n\t\tret = add_changeset_property(ovcs, target, prop, 1);\n\t\tif (ret) {\n\t\t\tpr_debug(\"Failed to apply symbols prop @%pOF/%s, err=%d\\n\",\n\t\t\t\t target->np, prop->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int find_dup_cset_node_entry(struct overlay_changeset *ovcs,\n\t\tstruct of_changeset_entry *ce_1)\n{\n\tstruct of_changeset_entry *ce_2;\n\tchar *fn_1, *fn_2;\n\tint node_path_match;\n\n\tif (ce_1->action != OF_RECONFIG_ATTACH_NODE &&\n\t    ce_1->action != OF_RECONFIG_DETACH_NODE)\n\t\treturn 0;\n\n\tce_2 = ce_1;\n\tlist_for_each_entry_continue(ce_2, &ovcs->cset.entries, node) {\n\t\tif ((ce_2->action != OF_RECONFIG_ATTACH_NODE &&\n\t\t     ce_2->action != OF_RECONFIG_DETACH_NODE) ||\n\t\t    of_node_cmp(ce_1->np->full_name, ce_2->np->full_name))\n\t\t\tcontinue;\n\n\t\tfn_1 = kasprintf(GFP_KERNEL, \"%pOF\", ce_1->np);\n\t\tfn_2 = kasprintf(GFP_KERNEL, \"%pOF\", ce_2->np);\n\t\tnode_path_match = !fn_1 || !fn_2 || !strcmp(fn_1, fn_2);\n\t\tkfree(fn_1);\n\t\tkfree(fn_2);\n\t\tif (node_path_match) {\n\t\t\tpr_err(\"ERROR: multiple fragments add and/or delete node %pOF\\n\",\n\t\t\t       ce_1->np);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int find_dup_cset_prop(struct overlay_changeset *ovcs,\n\t\tstruct of_changeset_entry *ce_1)\n{\n\tstruct of_changeset_entry *ce_2;\n\tchar *fn_1, *fn_2;\n\tint node_path_match;\n\n\tif (ce_1->action != OF_RECONFIG_ADD_PROPERTY &&\n\t    ce_1->action != OF_RECONFIG_REMOVE_PROPERTY &&\n\t    ce_1->action != OF_RECONFIG_UPDATE_PROPERTY)\n\t\treturn 0;\n\n\tce_2 = ce_1;\n\tlist_for_each_entry_continue(ce_2, &ovcs->cset.entries, node) {\n\t\tif ((ce_2->action != OF_RECONFIG_ADD_PROPERTY &&\n\t\t     ce_2->action != OF_RECONFIG_REMOVE_PROPERTY &&\n\t\t     ce_2->action != OF_RECONFIG_UPDATE_PROPERTY) ||\n\t\t    of_node_cmp(ce_1->np->full_name, ce_2->np->full_name))\n\t\t\tcontinue;\n\n\t\tfn_1 = kasprintf(GFP_KERNEL, \"%pOF\", ce_1->np);\n\t\tfn_2 = kasprintf(GFP_KERNEL, \"%pOF\", ce_2->np);\n\t\tnode_path_match = !fn_1 || !fn_2 || !strcmp(fn_1, fn_2);\n\t\tkfree(fn_1);\n\t\tkfree(fn_2);\n\t\tif (node_path_match &&\n\t\t    !of_prop_cmp(ce_1->prop->name, ce_2->prop->name)) {\n\t\t\tpr_err(\"ERROR: multiple fragments add, update, and/or delete property %pOF/%s\\n\",\n\t\t\t       ce_1->np, ce_1->prop->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int changeset_dup_entry_check(struct overlay_changeset *ovcs)\n{\n\tstruct of_changeset_entry *ce_1;\n\tint dup_entry = 0;\n\n\tlist_for_each_entry(ce_1, &ovcs->cset.entries, node) {\n\t\tdup_entry |= find_dup_cset_node_entry(ovcs, ce_1);\n\t\tdup_entry |= find_dup_cset_prop(ovcs, ce_1);\n\t}\n\n\treturn dup_entry ? -EINVAL : 0;\n}\n\n \nstatic int build_changeset(struct overlay_changeset *ovcs)\n{\n\tstruct fragment *fragment;\n\tstruct target target;\n\tint fragments_count, i, ret;\n\n\t \n\tif (ovcs->symbols_fragment)\n\t\tfragments_count = ovcs->count - 1;\n\telse\n\t\tfragments_count = ovcs->count;\n\n\tfor (i = 0; i < fragments_count; i++) {\n\t\tfragment = &ovcs->fragments[i];\n\n\t\ttarget.np = fragment->target;\n\t\ttarget.in_livetree = true;\n\t\tret = build_changeset_next_level(ovcs, &target,\n\t\t\t\t\t\t fragment->overlay);\n\t\tif (ret) {\n\t\t\tpr_debug(\"fragment apply failed '%pOF'\\n\",\n\t\t\t\t fragment->target);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (ovcs->symbols_fragment) {\n\t\tfragment = &ovcs->fragments[ovcs->count - 1];\n\n\t\ttarget.np = fragment->target;\n\t\ttarget.in_livetree = true;\n\t\tret = build_changeset_symbols_node(ovcs, &target,\n\t\t\t\t\t\t   fragment->overlay);\n\t\tif (ret) {\n\t\t\tpr_debug(\"symbols fragment apply failed '%pOF'\\n\",\n\t\t\t\t fragment->target);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn changeset_dup_entry_check(ovcs);\n}\n\n \nstatic struct device_node *find_target(struct device_node *info_node,\n\t\t\t\t       struct device_node *target_base)\n{\n\tstruct device_node *node;\n\tchar *target_path;\n\tconst char *path;\n\tu32 val;\n\tint ret;\n\n\tret = of_property_read_u32(info_node, \"target\", &val);\n\tif (!ret) {\n\t\tnode = of_find_node_by_phandle(val);\n\t\tif (!node)\n\t\t\tpr_err(\"find target, node: %pOF, phandle 0x%x not found\\n\",\n\t\t\t       info_node, val);\n\t\treturn node;\n\t}\n\n\tret = of_property_read_string(info_node, \"target-path\", &path);\n\tif (!ret) {\n\t\tif (target_base) {\n\t\t\ttarget_path = kasprintf(GFP_KERNEL, \"%pOF%s\", target_base, path);\n\t\t\tif (!target_path)\n\t\t\t\treturn NULL;\n\t\t\tnode = of_find_node_by_path(target_path);\n\t\t\tif (!node) {\n\t\t\t\tpr_err(\"find target, node: %pOF, path '%s' not found\\n\",\n\t\t\t\t       info_node, target_path);\n\t\t\t}\n\t\t\tkfree(target_path);\n\t\t} else {\n\t\t\tnode =  of_find_node_by_path(path);\n\t\t\tif (!node) {\n\t\t\t\tpr_err(\"find target, node: %pOF, path '%s' not found\\n\",\n\t\t\t\t       info_node, path);\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tpr_err(\"find target, node: %pOF, no target property\\n\", info_node);\n\n\treturn NULL;\n}\n\n \nstatic int init_overlay_changeset(struct overlay_changeset *ovcs,\n\t\t\t\t  struct device_node *target_base)\n{\n\tstruct device_node *node, *overlay_node;\n\tstruct fragment *fragment;\n\tstruct fragment *fragments;\n\tint cnt, ret;\n\n\t \n\n\t \n\tif (!of_node_check_flag(ovcs->overlay_root, OF_DYNAMIC))\n\t\tpr_debug(\"%s() ovcs->overlay_root is not dynamic\\n\", __func__);\n\n\tif (!of_node_check_flag(ovcs->overlay_root, OF_DETACHED))\n\t\tpr_debug(\"%s() ovcs->overlay_root is not detached\\n\", __func__);\n\n\tif (!of_node_is_root(ovcs->overlay_root))\n\t\tpr_debug(\"%s() ovcs->overlay_root is not root\\n\", __func__);\n\n\tcnt = 0;\n\n\t \n\tfor_each_child_of_node(ovcs->overlay_root, node) {\n\t\toverlay_node = of_get_child_by_name(node, \"__overlay__\");\n\t\tif (overlay_node) {\n\t\t\tcnt++;\n\t\t\tof_node_put(overlay_node);\n\t\t}\n\t}\n\n\tnode = of_get_child_by_name(ovcs->overlay_root, \"__symbols__\");\n\tif (node) {\n\t\tcnt++;\n\t\tof_node_put(node);\n\t}\n\n\tfragments = kcalloc(cnt, sizeof(*fragments), GFP_KERNEL);\n\tif (!fragments) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tovcs->fragments = fragments;\n\n\tcnt = 0;\n\tfor_each_child_of_node(ovcs->overlay_root, node) {\n\t\toverlay_node = of_get_child_by_name(node, \"__overlay__\");\n\t\tif (!overlay_node)\n\t\t\tcontinue;\n\n\t\tfragment = &fragments[cnt];\n\t\tfragment->overlay = overlay_node;\n\t\tfragment->target = find_target(node, target_base);\n\t\tif (!fragment->target) {\n\t\t\tof_node_put(fragment->overlay);\n\t\t\tret = -EINVAL;\n\t\t\tof_node_put(node);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tcnt++;\n\t}\n\n\t \n\tnode = of_get_child_by_name(ovcs->overlay_root, \"__symbols__\");\n\tif (node) {\n\t\tovcs->symbols_fragment = 1;\n\t\tfragment = &fragments[cnt];\n\t\tfragment->overlay = node;\n\t\tfragment->target = of_find_node_by_path(\"/__symbols__\");\n\n\t\tif (!fragment->target) {\n\t\t\tpr_err(\"symbols in overlay, but not in live tree\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tof_node_put(node);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tcnt++;\n\t}\n\n\tif (!cnt) {\n\t\tpr_err(\"no fragments or symbols in overlay\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tovcs->count = cnt;\n\n\treturn 0;\n\nerr_out:\n\tpr_err(\"%s() failed, ret = %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic void free_overlay_changeset(struct overlay_changeset *ovcs)\n{\n\tint i;\n\n\tif (ovcs->cset.entries.next)\n\t\tof_changeset_destroy(&ovcs->cset);\n\n\tif (ovcs->id) {\n\t\tidr_remove(&ovcs_idr, ovcs->id);\n\t\tlist_del(&ovcs->ovcs_list);\n\t\tovcs->id = 0;\n\t}\n\n\n\tfor (i = 0; i < ovcs->count; i++) {\n\t\tof_node_put(ovcs->fragments[i].target);\n\t\tof_node_put(ovcs->fragments[i].overlay);\n\t}\n\tkfree(ovcs->fragments);\n\n\t \n\n\tif (ovcs->notify_state == OF_OVERLAY_INIT ||\n\t    ovcs->notify_state == OF_OVERLAY_POST_REMOVE) {\n\t\tkfree(ovcs->overlay_mem);\n\t\tkfree(ovcs->new_fdt);\n\t}\n\tkfree(ovcs);\n}\n\n \n\nstatic int of_overlay_apply(struct overlay_changeset *ovcs,\n\t\t\t    struct device_node *base)\n{\n\tint ret = 0, ret_revert, ret_tmp;\n\n\tret = of_resolve_phandles(ovcs->overlay_root);\n\tif (ret)\n\t\tgoto out;\n\n\tret = init_overlay_changeset(ovcs, base);\n\tif (ret)\n\t\tgoto out;\n\n\tret = overlay_notify(ovcs, OF_OVERLAY_PRE_APPLY);\n\tif (ret)\n\t\tgoto out;\n\n\tret = build_changeset(ovcs);\n\tif (ret)\n\t\tgoto out;\n\n\tret_revert = 0;\n\tret = __of_changeset_apply_entries(&ovcs->cset, &ret_revert);\n\tif (ret) {\n\t\tif (ret_revert) {\n\t\t\tpr_debug(\"overlay changeset revert error %d\\n\",\n\t\t\t\t ret_revert);\n\t\t\tdevicetree_state_flags |= DTSF_APPLY_FAIL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tret = __of_changeset_apply_notify(&ovcs->cset);\n\tif (ret)\n\t\tpr_err(\"overlay apply changeset entry notify error %d\\n\", ret);\n\t \n\n\tret_tmp = overlay_notify(ovcs, OF_OVERLAY_POST_APPLY);\n\tif (ret_tmp)\n\t\tif (!ret)\n\t\t\tret = ret_tmp;\n\nout:\n\tpr_debug(\"%s() err=%d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\n \n\nint of_overlay_fdt_apply(const void *overlay_fdt, u32 overlay_fdt_size,\n\t\t\t int *ret_ovcs_id, struct device_node *base)\n{\n\tvoid *new_fdt;\n\tvoid *new_fdt_align;\n\tvoid *overlay_mem;\n\tint ret;\n\tu32 size;\n\tstruct overlay_changeset *ovcs;\n\n\t*ret_ovcs_id = 0;\n\n\tif (devicetree_corrupt()) {\n\t\tpr_err(\"devicetree state suspect, refuse to apply overlay\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (overlay_fdt_size < sizeof(struct fdt_header) ||\n\t    fdt_check_header(overlay_fdt)) {\n\t\tpr_err(\"Invalid overlay_fdt header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsize = fdt_totalsize(overlay_fdt);\n\tif (overlay_fdt_size < size)\n\t\treturn -EINVAL;\n\n\tovcs = kzalloc(sizeof(*ovcs), GFP_KERNEL);\n\tif (!ovcs)\n\t\treturn -ENOMEM;\n\n\tof_overlay_mutex_lock();\n\tmutex_lock(&of_mutex);\n\n\t \n\n\tovcs->id = idr_alloc(&ovcs_idr, ovcs, 1, 0, GFP_KERNEL);\n\tif (ovcs->id <= 0) {\n\t\tret = ovcs->id;\n\t\tgoto err_free_ovcs;\n\t}\n\n\tINIT_LIST_HEAD(&ovcs->ovcs_list);\n\tlist_add_tail(&ovcs->ovcs_list, &ovcs_list);\n\tof_changeset_init(&ovcs->cset);\n\n\t \n\tnew_fdt = kmalloc(size + FDT_ALIGN_SIZE, GFP_KERNEL);\n\tif (!new_fdt) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_ovcs;\n\t}\n\tovcs->new_fdt = new_fdt;\n\n\tnew_fdt_align = PTR_ALIGN(new_fdt, FDT_ALIGN_SIZE);\n\tmemcpy(new_fdt_align, overlay_fdt, size);\n\n\toverlay_mem = of_fdt_unflatten_tree(new_fdt_align, NULL,\n\t\t\t\t\t    &ovcs->overlay_root);\n\tif (!overlay_mem) {\n\t\tpr_err(\"unable to unflatten overlay_fdt\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_free_ovcs;\n\t}\n\tovcs->overlay_mem = overlay_mem;\n\n\tret = of_overlay_apply(ovcs, base);\n\t \n\t*ret_ovcs_id = ovcs->id;\n\tgoto out_unlock;\n\nerr_free_ovcs:\n\tfree_overlay_changeset(ovcs);\n\nout_unlock:\n\tmutex_unlock(&of_mutex);\n\tof_overlay_mutex_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_overlay_fdt_apply);\n\n \nstatic int find_node(struct device_node *tree, struct device_node *np)\n{\n\tstruct device_node *child;\n\n\tif (tree == np)\n\t\treturn 1;\n\n\tfor_each_child_of_node(tree, child) {\n\t\tif (find_node(child, np)) {\n\t\t\tof_node_put(child);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int node_overlaps_later_cs(struct overlay_changeset *remove_ovcs,\n\t\tstruct device_node *remove_ce_node)\n{\n\tstruct overlay_changeset *ovcs;\n\tstruct of_changeset_entry *ce;\n\n\tlist_for_each_entry_reverse(ovcs, &ovcs_list, ovcs_list) {\n\t\tif (ovcs == remove_ovcs)\n\t\t\tbreak;\n\n\t\tlist_for_each_entry(ce, &ovcs->cset.entries, node) {\n\t\t\tif (find_node(ce->np, remove_ce_node)) {\n\t\t\t\tpr_err(\"%s: #%d overlaps with #%d @%pOF\\n\",\n\t\t\t\t\t__func__, remove_ovcs->id, ovcs->id,\n\t\t\t\t\tremove_ce_node);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (find_node(remove_ce_node, ce->np)) {\n\t\t\t\tpr_err(\"%s: #%d overlaps with #%d @%pOF\\n\",\n\t\t\t\t\t__func__, remove_ovcs->id, ovcs->id,\n\t\t\t\t\tremove_ce_node);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int overlay_removal_is_ok(struct overlay_changeset *remove_ovcs)\n{\n\tstruct of_changeset_entry *remove_ce;\n\n\tlist_for_each_entry(remove_ce, &remove_ovcs->cset.entries, node) {\n\t\tif (node_overlaps_later_cs(remove_ovcs, remove_ce->np)) {\n\t\t\tpr_err(\"overlay #%d is not topmost\\n\", remove_ovcs->id);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n \nint of_overlay_remove(int *ovcs_id)\n{\n\tstruct overlay_changeset *ovcs;\n\tint ret, ret_apply, ret_tmp;\n\n\tif (devicetree_corrupt()) {\n\t\tpr_err(\"suspect devicetree state, refuse to remove overlay\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&of_mutex);\n\n\tovcs = idr_find(&ovcs_idr, *ovcs_id);\n\tif (!ovcs) {\n\t\tret = -ENODEV;\n\t\tpr_err(\"remove: Could not find overlay #%d\\n\", *ovcs_id);\n\t\tgoto err_unlock;\n\t}\n\n\tif (!overlay_removal_is_ok(ovcs)) {\n\t\tret = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tret = overlay_notify(ovcs, OF_OVERLAY_PRE_REMOVE);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tret_apply = 0;\n\tret = __of_changeset_revert_entries(&ovcs->cset, &ret_apply);\n\tif (ret) {\n\t\tif (ret_apply)\n\t\t\tdevicetree_state_flags |= DTSF_REVERT_FAIL;\n\t\tgoto err_unlock;\n\t}\n\n\tret = __of_changeset_revert_notify(&ovcs->cset);\n\tif (ret)\n\t\tpr_err(\"overlay remove changeset entry notify error %d\\n\", ret);\n\t \n\n\t*ovcs_id = 0;\n\n\t \n\tret_tmp = overlay_notify(ovcs, OF_OVERLAY_POST_REMOVE);\n\tif (ret_tmp)\n\t\tif (!ret)\n\t\t\tret = ret_tmp;\n\n\tfree_overlay_changeset(ovcs);\n\nerr_unlock:\n\t \n\tmutex_unlock(&of_mutex);\n\nout:\n\tpr_debug(\"%s() err=%d\\n\", __func__, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_overlay_remove);\n\n \nint of_overlay_remove_all(void)\n{\n\tstruct overlay_changeset *ovcs, *ovcs_n;\n\tint ret;\n\n\t \n\tlist_for_each_entry_safe_reverse(ovcs, ovcs_n, &ovcs_list, ovcs_list) {\n\t\tret = of_overlay_remove(&ovcs->id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_overlay_remove_all);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}