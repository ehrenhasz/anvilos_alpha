{
  "module_name": "device.c",
  "hash_id": "0c985ef416f16d6d5fab530965d8b6e34935bfb56a692580e3cbd7f429c38834",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/device.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/of_iommu.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/dma-direct.h>  \n#include <linux/dma-map-ops.h>\n#include <linux/init.h>\n#include <linux/mod_devicetable.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n\n#include <asm/errno.h>\n#include \"of_private.h\"\n\n \nconst struct of_device_id *of_match_device(const struct of_device_id *matches,\n\t\t\t\t\t   const struct device *dev)\n{\n\tif (!matches || !dev->of_node || dev->of_node_reused)\n\t\treturn NULL;\n\treturn of_match_node(matches, dev->of_node);\n}\nEXPORT_SYMBOL(of_match_device);\n\nstatic void\nof_dma_set_restricted_buffer(struct device *dev, struct device_node *np)\n{\n\tstruct device_node *node, *of_node = dev->of_node;\n\tint count, i;\n\n\tif (!IS_ENABLED(CONFIG_DMA_RESTRICTED_POOL))\n\t\treturn;\n\n\tcount = of_property_count_elems_of_size(of_node, \"memory-region\",\n\t\t\t\t\t\tsizeof(u32));\n\t \n\tif (count <= 0) {\n\t\tof_node = np;\n\t\tcount = of_property_count_elems_of_size(\n\t\t\tof_node, \"memory-region\", sizeof(u32));\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tnode = of_parse_phandle(of_node, \"memory-region\", i);\n\t\t \n\t\tif (of_device_is_compatible(node, \"restricted-dma-pool\") &&\n\t\t    of_device_is_available(node)) {\n\t\t\tof_node_put(node);\n\t\t\tbreak;\n\t\t}\n\t\tof_node_put(node);\n\t}\n\n\t \n\tif (i < count && of_reserved_mem_device_init_by_idx(dev, of_node, i))\n\t\tdev_warn(dev, \"failed to initialise \\\"restricted-dma-pool\\\" memory node\\n\");\n}\n\n \nint of_dma_configure_id(struct device *dev, struct device_node *np,\n\t\t\tbool force_dma, const u32 *id)\n{\n\tconst struct iommu_ops *iommu;\n\tconst struct bus_dma_region *map = NULL;\n\tstruct device_node *bus_np;\n\tu64 dma_start = 0;\n\tu64 mask, end, size = 0;\n\tbool coherent;\n\tint ret;\n\n\tif (np == dev->of_node)\n\t\tbus_np = __of_get_dma_parent(np);\n\telse\n\t\tbus_np = of_node_get(np);\n\n\tret = of_dma_get_range(bus_np, &map);\n\tof_node_put(bus_np);\n\tif (ret < 0) {\n\t\t \n\t\tif (!force_dma)\n\t\t\treturn ret == -ENODEV ? 0 : ret;\n\t} else {\n\t\tconst struct bus_dma_region *r = map;\n\t\tu64 dma_end = 0;\n\n\t\t \n\t\tfor (dma_start = ~0; r->size; r++) {\n\t\t\t \n\t\t\tif (r->dma_start < dma_start)\n\t\t\t\tdma_start = r->dma_start;\n\t\t\tif (r->dma_start + r->size > dma_end)\n\t\t\t\tdma_end = r->dma_start + r->size;\n\t\t}\n\t\tsize = dma_end - dma_start;\n\n\t\t \n\t\tif (size & 1) {\n\t\t\tdev_warn(dev, \"Invalid size 0x%llx for dma-range(s)\\n\",\n\t\t\t\t size);\n\t\t\tsize = size + 1;\n\t\t}\n\n\t\tif (!size) {\n\t\t\tdev_err(dev, \"Adjusted size 0x%llx invalid\\n\", size);\n\t\t\tkfree(map);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (!dev->dma_mask) {\n\t\tdev_warn(dev, \"DMA mask not set\\n\");\n\t\tdev->dma_mask = &dev->coherent_dma_mask;\n\t}\n\n\tif (!size && dev->coherent_dma_mask)\n\t\tsize = max(dev->coherent_dma_mask, dev->coherent_dma_mask + 1);\n\telse if (!size)\n\t\tsize = 1ULL << 32;\n\n\t \n\tend = dma_start + size - 1;\n\tmask = DMA_BIT_MASK(ilog2(end) + 1);\n\tdev->coherent_dma_mask &= mask;\n\t*dev->dma_mask &= mask;\n\t \n\tif (!ret) {\n\t\tdev->bus_dma_limit = end;\n\t\tdev->dma_range_map = map;\n\t}\n\n\tcoherent = of_dma_is_coherent(np);\n\tdev_dbg(dev, \"device is%sdma coherent\\n\",\n\t\tcoherent ? \" \" : \" not \");\n\n\tiommu = of_iommu_configure(dev, np, id);\n\tif (PTR_ERR(iommu) == -EPROBE_DEFER) {\n\t\t \n\t\tif (!ret)\n\t\t\tdev->dma_range_map = NULL;\n\t\tkfree(map);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tdev_dbg(dev, \"device is%sbehind an iommu\\n\",\n\t\tiommu ? \" \" : \" not \");\n\n\tarch_setup_dma_ops(dev, dma_start, size, iommu, coherent);\n\n\tif (!iommu)\n\t\tof_dma_set_restricted_buffer(dev, np);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_dma_configure_id);\n\nconst void *of_device_get_match_data(const struct device *dev)\n{\n\tconst struct of_device_id *match;\n\n\tmatch = of_match_device(dev->driver->of_match_table, dev);\n\tif (!match)\n\t\treturn NULL;\n\n\treturn match->data;\n}\nEXPORT_SYMBOL(of_device_get_match_data);\n\n \nssize_t of_device_modalias(struct device *dev, char *str, ssize_t len)\n{\n\tssize_t sl;\n\n\tif (!dev || !dev->of_node || dev->of_node_reused)\n\t\treturn -ENODEV;\n\n\tsl = of_modalias(dev->of_node, str, len - 2);\n\tif (sl < 0)\n\t\treturn sl;\n\tif (sl > len - 2)\n\t\treturn -ENOMEM;\n\n\tstr[sl++] = '\\n';\n\tstr[sl] = 0;\n\treturn sl;\n}\nEXPORT_SYMBOL_GPL(of_device_modalias);\n\n \nvoid of_device_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst char *compat, *type;\n\tstruct alias_prop *app;\n\tstruct property *p;\n\tint seen = 0;\n\n\tif ((!dev) || (!dev->of_node))\n\t\treturn;\n\n\tadd_uevent_var(env, \"OF_NAME=%pOFn\", dev->of_node);\n\tadd_uevent_var(env, \"OF_FULLNAME=%pOF\", dev->of_node);\n\ttype = of_node_get_device_type(dev->of_node);\n\tif (type)\n\t\tadd_uevent_var(env, \"OF_TYPE=%s\", type);\n\n\t \n\tof_property_for_each_string(dev->of_node, \"compatible\", p, compat) {\n\t\tadd_uevent_var(env, \"OF_COMPATIBLE_%d=%s\", seen, compat);\n\t\tseen++;\n\t}\n\tadd_uevent_var(env, \"OF_COMPATIBLE_N=%d\", seen);\n\n\tseen = 0;\n\tmutex_lock(&of_mutex);\n\tlist_for_each_entry(app, &aliases_lookup, link) {\n\t\tif (dev->of_node == app->np) {\n\t\t\tadd_uevent_var(env, \"OF_ALIAS_%d=%s\", seen,\n\t\t\t\t       app->alias);\n\t\t\tseen++;\n\t\t}\n\t}\n\tmutex_unlock(&of_mutex);\n}\nEXPORT_SYMBOL_GPL(of_device_uevent);\n\nint of_device_uevent_modalias(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tint sl;\n\n\tif ((!dev) || (!dev->of_node) || dev->of_node_reused)\n\t\treturn -ENODEV;\n\n\t \n\tif (add_uevent_var(env, \"MODALIAS=\"))\n\t\treturn -ENOMEM;\n\n\tsl = of_modalias(dev->of_node, &env->buf[env->buflen-1],\n\t\t\t sizeof(env->buf) - env->buflen);\n\tif (sl < 0)\n\t\treturn sl;\n\tif (sl >= (sizeof(env->buf) - env->buflen))\n\t\treturn -ENOMEM;\n\tenv->buflen += sl;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_device_uevent_modalias);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}