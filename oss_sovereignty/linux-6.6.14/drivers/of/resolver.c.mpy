{
  "module_name": "resolver.c",
  "hash_id": "29e8344420135ed81c0c509aa5f5730c5128cbc96d9d00df16497868f1a5fcd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/resolver.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"OF: resolver: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n\n#include \"of_private.h\"\n\nstatic phandle live_tree_max_phandle(void)\n{\n\tstruct device_node *node;\n\tphandle phandle;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tphandle = 0;\n\tfor_each_of_allnodes(node) {\n\t\tif (node->phandle != OF_PHANDLE_ILLEGAL &&\n\t\t\t\tnode->phandle > phandle)\n\t\t\tphandle = node->phandle;\n\t}\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\n\treturn phandle;\n}\n\nstatic void adjust_overlay_phandles(struct device_node *overlay,\n\t\tint phandle_delta)\n{\n\tstruct device_node *child;\n\tstruct property *prop;\n\tphandle phandle;\n\n\t \n\tif (overlay->phandle != 0 && overlay->phandle != OF_PHANDLE_ILLEGAL)\n\t\toverlay->phandle += phandle_delta;\n\n\t \n\tfor_each_property_of_node(overlay, prop) {\n\n\t\tif (of_prop_cmp(prop->name, \"phandle\") &&\n\t\t    of_prop_cmp(prop->name, \"linux,phandle\"))\n\t\t\tcontinue;\n\n\t\tif (prop->length < 4)\n\t\t\tcontinue;\n\n\t\tphandle = be32_to_cpup(prop->value);\n\t\tif (phandle == OF_PHANDLE_ILLEGAL)\n\t\t\tcontinue;\n\n\t\t*(__be32 *)prop->value = cpu_to_be32(overlay->phandle);\n\t}\n\n\tfor_each_child_of_node(overlay, child)\n\t\tadjust_overlay_phandles(child, phandle_delta);\n}\n\nstatic int update_usages_of_a_phandle_reference(struct device_node *overlay,\n\t\tstruct property *prop_fixup, phandle phandle)\n{\n\tstruct device_node *refnode;\n\tstruct property *prop;\n\tchar *value, *cur, *end, *node_path, *prop_name, *s;\n\tint offset, len;\n\tint err = 0;\n\n\tvalue = kmemdup(prop_fixup->value, prop_fixup->length, GFP_KERNEL);\n\tif (!value)\n\t\treturn -ENOMEM;\n\n\t \n\tend = value + prop_fixup->length;\n\tfor (cur = value; cur < end; cur += len + 1) {\n\t\tlen = strlen(cur);\n\n\t\tnode_path = cur;\n\t\ts = strchr(cur, ':');\n\t\tif (!s) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_fail;\n\t\t}\n\t\t*s++ = '\\0';\n\n\t\tprop_name = s;\n\t\ts = strchr(s, ':');\n\t\tif (!s) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_fail;\n\t\t}\n\t\t*s++ = '\\0';\n\n\t\terr = kstrtoint(s, 10, &offset);\n\t\tif (err)\n\t\t\tgoto err_fail;\n\n\t\trefnode = __of_find_node_by_full_path(of_node_get(overlay), node_path);\n\t\tif (!refnode)\n\t\t\tcontinue;\n\n\t\tfor_each_property_of_node(refnode, prop) {\n\t\t\tif (!of_prop_cmp(prop->name, prop_name))\n\t\t\t\tbreak;\n\t\t}\n\t\tof_node_put(refnode);\n\n\t\tif (!prop) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err_fail;\n\t\t}\n\n\t\tif (offset < 0 || offset + sizeof(__be32) > prop->length) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_fail;\n\t\t}\n\n\t\t*(__be32 *)(prop->value + offset) = cpu_to_be32(phandle);\n\t}\n\nerr_fail:\n\tkfree(value);\n\treturn err;\n}\n\n \nstatic int node_name_cmp(const struct device_node *dn1,\n\t\tconst struct device_node *dn2)\n{\n\tconst char *n1 = kbasename(dn1->full_name);\n\tconst char *n2 = kbasename(dn2->full_name);\n\n\treturn of_node_cmp(n1, n2);\n}\n\n \nstatic int adjust_local_phandle_references(struct device_node *local_fixups,\n\t\tstruct device_node *overlay, int phandle_delta)\n{\n\tstruct device_node *child, *overlay_child;\n\tstruct property *prop_fix, *prop;\n\tint err, i, count;\n\tunsigned int off;\n\n\tif (!local_fixups)\n\t\treturn 0;\n\n\tfor_each_property_of_node(local_fixups, prop_fix) {\n\n\t\t \n\t\tif (!of_prop_cmp(prop_fix->name, \"name\") ||\n\t\t    !of_prop_cmp(prop_fix->name, \"phandle\") ||\n\t\t    !of_prop_cmp(prop_fix->name, \"linux,phandle\"))\n\t\t\tcontinue;\n\n\t\tif ((prop_fix->length % 4) != 0 || prop_fix->length == 0)\n\t\t\treturn -EINVAL;\n\t\tcount = prop_fix->length / sizeof(__be32);\n\n\t\tfor_each_property_of_node(overlay, prop) {\n\t\t\tif (!of_prop_cmp(prop->name, prop_fix->name))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!prop)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toff = be32_to_cpu(((__be32 *)prop_fix->value)[i]);\n\t\t\tif ((off + 4) > prop->length)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tbe32_add_cpu(prop->value + off, phandle_delta);\n\t\t}\n\t}\n\n\t \n\tfor_each_child_of_node(local_fixups, child) {\n\n\t\tfor_each_child_of_node(overlay, overlay_child)\n\t\t\tif (!node_name_cmp(child, overlay_child)) {\n\t\t\t\tof_node_put(overlay_child);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!overlay_child) {\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = adjust_local_phandle_references(child, overlay_child,\n\t\t\t\tphandle_delta);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint of_resolve_phandles(struct device_node *overlay)\n{\n\tstruct device_node *child, *local_fixups, *refnode;\n\tstruct device_node *tree_symbols, *overlay_fixups;\n\tstruct property *prop;\n\tconst char *refpath;\n\tphandle phandle, phandle_delta;\n\tint err;\n\n\ttree_symbols = NULL;\n\n\tif (!overlay) {\n\t\tpr_err(\"null overlay\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!of_node_check_flag(overlay, OF_DETACHED)) {\n\t\tpr_err(\"overlay not detached\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tphandle_delta = live_tree_max_phandle() + 1;\n\tadjust_overlay_phandles(overlay, phandle_delta);\n\n\tfor_each_child_of_node(overlay, local_fixups)\n\t\tif (of_node_name_eq(local_fixups, \"__local_fixups__\"))\n\t\t\tbreak;\n\n\terr = adjust_local_phandle_references(local_fixups, overlay, phandle_delta);\n\tif (err)\n\t\tgoto out;\n\n\toverlay_fixups = NULL;\n\n\tfor_each_child_of_node(overlay, child) {\n\t\tif (of_node_name_eq(child, \"__fixups__\"))\n\t\t\toverlay_fixups = child;\n\t}\n\n\tif (!overlay_fixups) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\ttree_symbols = of_find_node_by_path(\"/__symbols__\");\n\tif (!tree_symbols) {\n\t\tpr_err(\"no symbols in root of device tree.\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor_each_property_of_node(overlay_fixups, prop) {\n\n\t\t \n\t\tif (!of_prop_cmp(prop->name, \"name\"))\n\t\t\tcontinue;\n\n\t\terr = of_property_read_string(tree_symbols,\n\t\t\t\tprop->name, &refpath);\n\t\tif (err) {\n\t\t\tpr_err(\"node label '%s' not found in live devicetree symbols table\\n\",\n\t\t\t       prop->name);\n\t\t\tgoto out;\n\t\t}\n\n\t\trefnode = of_find_node_by_path(refpath);\n\t\tif (!refnode) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tphandle = refnode->phandle;\n\t\tof_node_put(refnode);\n\n\t\terr = update_usages_of_a_phandle_reference(overlay, prop, phandle);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\nout:\n\tif (err)\n\t\tpr_err(\"overlay phandle fixup failed: %d\\n\", err);\n\tof_node_put(tree_symbols);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(of_resolve_phandles);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}