{
  "module_name": "platform.c",
  "hash_id": "d64ba937a2ef7a9ef1600a9ea514697cc75079a50693a996d58bd3f122fbab8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/platform.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"OF: \" fmt\n\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/amba/bus.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include \"of_private.h\"\n\nconst struct of_device_id of_default_bus_match_table[] = {\n\t{ .compatible = \"simple-bus\", },\n\t{ .compatible = \"simple-mfd\", },\n\t{ .compatible = \"isa\", },\n#ifdef CONFIG_ARM_AMBA\n\t{ .compatible = \"arm,amba-bus\", },\n#endif  \n\t{}  \n};\n\n \nstruct platform_device *of_find_device_by_node(struct device_node *np)\n{\n\tstruct device *dev;\n\n\tdev = bus_find_device_by_of_node(&platform_bus_type, np);\n\treturn dev ? to_platform_device(dev) : NULL;\n}\nEXPORT_SYMBOL(of_find_device_by_node);\n\nint of_device_add(struct platform_device *ofdev)\n{\n\tBUG_ON(ofdev->dev.of_node == NULL);\n\n\t \n\tofdev->name = dev_name(&ofdev->dev);\n\tofdev->id = PLATFORM_DEVID_NONE;\n\n\t \n\tset_dev_node(&ofdev->dev, of_node_to_nid(ofdev->dev.of_node));\n\n\treturn device_add(&ofdev->dev);\n}\n\nint of_device_register(struct platform_device *pdev)\n{\n\tdevice_initialize(&pdev->dev);\n\treturn of_device_add(pdev);\n}\nEXPORT_SYMBOL(of_device_register);\n\nvoid of_device_unregister(struct platform_device *ofdev)\n{\n\tdevice_unregister(&ofdev->dev);\n}\nEXPORT_SYMBOL(of_device_unregister);\n\n#ifdef CONFIG_OF_ADDRESS\nstatic const struct of_device_id of_skipped_node_table[] = {\n\t{ .compatible = \"operating-points-v2\", },\n\t{}  \n};\n\n \n\n \nstatic void of_device_make_bus_id(struct device *dev)\n{\n\tstruct device_node *node = dev->of_node;\n\tconst __be32 *reg;\n\tu64 addr;\n\tu32 mask;\n\n\t \n\twhile (node->parent) {\n\t\t \n\t\treg = of_get_property(node, \"reg\", NULL);\n\t\tif (reg && (addr = of_translate_address(node, reg)) != OF_BAD_ADDR) {\n\t\t\tif (!of_property_read_u32(node, \"mask\", &mask))\n\t\t\t\tdev_set_name(dev, dev_name(dev) ? \"%llx.%x.%pOFn:%s\" : \"%llx.%x.%pOFn\",\n\t\t\t\t\t     addr, ffs(mask) - 1, node, dev_name(dev));\n\n\t\t\telse\n\t\t\t\tdev_set_name(dev, dev_name(dev) ? \"%llx.%pOFn:%s\" : \"%llx.%pOFn\",\n\t\t\t\t\t     addr, node, dev_name(dev));\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tdev_set_name(dev, dev_name(dev) ? \"%s:%s\" : \"%s\",\n\t\t\t     kbasename(node->full_name), dev_name(dev));\n\t\tnode = node->parent;\n\t}\n}\n\n \nstruct platform_device *of_device_alloc(struct device_node *np,\n\t\t\t\t  const char *bus_id,\n\t\t\t\t  struct device *parent)\n{\n\tstruct platform_device *dev;\n\tint rc, i, num_reg = 0;\n\tstruct resource *res;\n\n\tdev = platform_device_alloc(\"\", PLATFORM_DEVID_NONE);\n\tif (!dev)\n\t\treturn NULL;\n\n\t \n\tnum_reg = of_address_count(np);\n\n\t \n\tif (num_reg) {\n\t\tres = kcalloc(num_reg, sizeof(*res), GFP_KERNEL);\n\t\tif (!res) {\n\t\t\tplatform_device_put(dev);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdev->num_resources = num_reg;\n\t\tdev->resource = res;\n\t\tfor (i = 0; i < num_reg; i++, res++) {\n\t\t\trc = of_address_to_resource(np, i, res);\n\t\t\tWARN_ON(rc);\n\t\t}\n\t}\n\n\t \n\tdevice_set_node(&dev->dev, of_fwnode_handle(of_node_get(np)));\n\tdev->dev.parent = parent ? : &platform_bus;\n\n\tif (bus_id)\n\t\tdev_set_name(&dev->dev, \"%s\", bus_id);\n\telse\n\t\tof_device_make_bus_id(&dev->dev);\n\n\treturn dev;\n}\nEXPORT_SYMBOL(of_device_alloc);\n\n \nstatic struct platform_device *of_platform_device_create_pdata(\n\t\t\t\t\tstruct device_node *np,\n\t\t\t\t\tconst char *bus_id,\n\t\t\t\t\tvoid *platform_data,\n\t\t\t\t\tstruct device *parent)\n{\n\tstruct platform_device *dev;\n\n\tif (!of_device_is_available(np) ||\n\t    of_node_test_and_set_flag(np, OF_POPULATED))\n\t\treturn NULL;\n\n\tdev = of_device_alloc(np, bus_id, parent);\n\tif (!dev)\n\t\tgoto err_clear_flag;\n\n\tdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\n\tif (!dev->dev.dma_mask)\n\t\tdev->dev.dma_mask = &dev->dev.coherent_dma_mask;\n\tdev->dev.bus = &platform_bus_type;\n\tdev->dev.platform_data = platform_data;\n\tof_msi_configure(&dev->dev, dev->dev.of_node);\n\n\tif (of_device_add(dev) != 0) {\n\t\tplatform_device_put(dev);\n\t\tgoto err_clear_flag;\n\t}\n\n\treturn dev;\n\nerr_clear_flag:\n\tof_node_clear_flag(np, OF_POPULATED);\n\treturn NULL;\n}\n\n \nstruct platform_device *of_platform_device_create(struct device_node *np,\n\t\t\t\t\t    const char *bus_id,\n\t\t\t\t\t    struct device *parent)\n{\n\treturn of_platform_device_create_pdata(np, bus_id, NULL, parent);\n}\nEXPORT_SYMBOL(of_platform_device_create);\n\n#ifdef CONFIG_ARM_AMBA\nstatic struct amba_device *of_amba_device_create(struct device_node *node,\n\t\t\t\t\t\t const char *bus_id,\n\t\t\t\t\t\t void *platform_data,\n\t\t\t\t\t\t struct device *parent)\n{\n\tstruct amba_device *dev;\n\tint ret;\n\n\tpr_debug(\"Creating amba device %pOF\\n\", node);\n\n\tif (!of_device_is_available(node) ||\n\t    of_node_test_and_set_flag(node, OF_POPULATED))\n\t\treturn NULL;\n\n\tdev = amba_device_alloc(NULL, 0, 0);\n\tif (!dev)\n\t\tgoto err_clear_flag;\n\n\t \n\tdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\n\tdev->dev.dma_mask = &dev->dev.coherent_dma_mask;\n\n\t \n\tdevice_set_node(&dev->dev, of_fwnode_handle(of_node_get(node)));\n\tdev->dev.parent = parent ? : &platform_bus;\n\tdev->dev.platform_data = platform_data;\n\tif (bus_id)\n\t\tdev_set_name(&dev->dev, \"%s\", bus_id);\n\telse\n\t\tof_device_make_bus_id(&dev->dev);\n\n\t \n\tof_property_read_u32(node, \"arm,primecell-periphid\", &dev->periphid);\n\n\tret = of_address_to_resource(node, 0, &dev->res);\n\tif (ret) {\n\t\tpr_err(\"amba: of_address_to_resource() failed (%d) for %pOF\\n\",\n\t\t       ret, node);\n\t\tgoto err_free;\n\t}\n\n\tret = amba_device_add(dev, &iomem_resource);\n\tif (ret) {\n\t\tpr_err(\"amba_device_add() failed (%d) for %pOF\\n\",\n\t\t       ret, node);\n\t\tgoto err_free;\n\t}\n\n\treturn dev;\n\nerr_free:\n\tamba_device_put(dev);\nerr_clear_flag:\n\tof_node_clear_flag(node, OF_POPULATED);\n\treturn NULL;\n}\n#else  \nstatic struct amba_device *of_amba_device_create(struct device_node *node,\n\t\t\t\t\t\t const char *bus_id,\n\t\t\t\t\t\t void *platform_data,\n\t\t\t\t\t\t struct device *parent)\n{\n\treturn NULL;\n}\n#endif  \n\n \nstatic const struct of_dev_auxdata *of_dev_lookup(const struct of_dev_auxdata *lookup,\n\t\t\t\t struct device_node *np)\n{\n\tconst struct of_dev_auxdata *auxdata;\n\tstruct resource res;\n\tint compatible = 0;\n\n\tif (!lookup)\n\t\treturn NULL;\n\n\tauxdata = lookup;\n\tfor (; auxdata->compatible; auxdata++) {\n\t\tif (!of_device_is_compatible(np, auxdata->compatible))\n\t\t\tcontinue;\n\t\tcompatible++;\n\t\tif (!of_address_to_resource(np, 0, &res))\n\t\t\tif (res.start != auxdata->phys_addr)\n\t\t\t\tcontinue;\n\t\tpr_debug(\"%pOF: devname=%s\\n\", np, auxdata->name);\n\t\treturn auxdata;\n\t}\n\n\tif (!compatible)\n\t\treturn NULL;\n\n\t \n\tauxdata = lookup;\n\tfor (; auxdata->compatible; auxdata++) {\n\t\tif (!of_device_is_compatible(np, auxdata->compatible))\n\t\t\tcontinue;\n\t\tif (!auxdata->phys_addr && !auxdata->name) {\n\t\t\tpr_debug(\"%pOF: compatible match\\n\", np);\n\t\t\treturn auxdata;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int of_platform_bus_create(struct device_node *bus,\n\t\t\t\t  const struct of_device_id *matches,\n\t\t\t\t  const struct of_dev_auxdata *lookup,\n\t\t\t\t  struct device *parent, bool strict)\n{\n\tconst struct of_dev_auxdata *auxdata;\n\tstruct device_node *child;\n\tstruct platform_device *dev;\n\tconst char *bus_id = NULL;\n\tvoid *platform_data = NULL;\n\tint rc = 0;\n\n\t \n\tif (strict && (!of_get_property(bus, \"compatible\", NULL))) {\n\t\tpr_debug(\"%s() - skipping %pOF, no compatible prop\\n\",\n\t\t\t __func__, bus);\n\t\treturn 0;\n\t}\n\n\t \n\tif (unlikely(of_match_node(of_skipped_node_table, bus))) {\n\t\tpr_debug(\"%s() - skipping %pOF node\\n\", __func__, bus);\n\t\treturn 0;\n\t}\n\n\tif (of_node_check_flag(bus, OF_POPULATED_BUS)) {\n\t\tpr_debug(\"%s() - skipping %pOF, already populated\\n\",\n\t\t\t__func__, bus);\n\t\treturn 0;\n\t}\n\n\tauxdata = of_dev_lookup(lookup, bus);\n\tif (auxdata) {\n\t\tbus_id = auxdata->name;\n\t\tplatform_data = auxdata->platform_data;\n\t}\n\n\tif (of_device_is_compatible(bus, \"arm,primecell\")) {\n\t\t \n\t\tof_amba_device_create(bus, bus_id, platform_data, parent);\n\t\treturn 0;\n\t}\n\n\tdev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);\n\tif (!dev || !of_match_node(matches, bus))\n\t\treturn 0;\n\n\tfor_each_child_of_node(bus, child) {\n\t\tpr_debug(\"   create child: %pOF\\n\", child);\n\t\trc = of_platform_bus_create(child, matches, lookup, &dev->dev, strict);\n\t\tif (rc) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\tof_node_set_flag(bus, OF_POPULATED_BUS);\n\treturn rc;\n}\n\n \nint of_platform_bus_probe(struct device_node *root,\n\t\t\t  const struct of_device_id *matches,\n\t\t\t  struct device *parent)\n{\n\tstruct device_node *child;\n\tint rc = 0;\n\n\troot = root ? of_node_get(root) : of_find_node_by_path(\"/\");\n\tif (!root)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\tpr_debug(\" starting at: %pOF\\n\", root);\n\n\t \n\tif (of_match_node(matches, root)) {\n\t\trc = of_platform_bus_create(root, matches, NULL, parent, false);\n\t} else for_each_child_of_node(root, child) {\n\t\tif (!of_match_node(matches, child))\n\t\t\tcontinue;\n\t\trc = of_platform_bus_create(child, matches, NULL, parent, false);\n\t\tif (rc) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tof_node_put(root);\n\treturn rc;\n}\nEXPORT_SYMBOL(of_platform_bus_probe);\n\n \nint of_platform_populate(struct device_node *root,\n\t\t\tconst struct of_device_id *matches,\n\t\t\tconst struct of_dev_auxdata *lookup,\n\t\t\tstruct device *parent)\n{\n\tstruct device_node *child;\n\tint rc = 0;\n\n\troot = root ? of_node_get(root) : of_find_node_by_path(\"/\");\n\tif (!root)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\tpr_debug(\" starting at: %pOF\\n\", root);\n\n\tdevice_links_supplier_sync_state_pause();\n\tfor_each_child_of_node(root, child) {\n\t\trc = of_platform_bus_create(child, matches, lookup, parent, true);\n\t\tif (rc) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdevice_links_supplier_sync_state_resume();\n\n\tof_node_set_flag(root, OF_POPULATED_BUS);\n\n\tof_node_put(root);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(of_platform_populate);\n\nint of_platform_default_populate(struct device_node *root,\n\t\t\t\t const struct of_dev_auxdata *lookup,\n\t\t\t\t struct device *parent)\n{\n\treturn of_platform_populate(root, of_default_bus_match_table, lookup,\n\t\t\t\t    parent);\n}\nEXPORT_SYMBOL_GPL(of_platform_default_populate);\n\nstatic const struct of_device_id reserved_mem_matches[] = {\n\t{ .compatible = \"phram\" },\n\t{ .compatible = \"qcom,rmtfs-mem\" },\n\t{ .compatible = \"qcom,cmd-db\" },\n\t{ .compatible = \"qcom,smem\" },\n\t{ .compatible = \"ramoops\" },\n\t{ .compatible = \"nvmem-rmem\" },\n\t{ .compatible = \"google,open-dice\" },\n\t{}\n};\n\nstatic int __init of_platform_default_populate_init(void)\n{\n\tstruct device_node *node;\n\n\tdevice_links_supplier_sync_state_pause();\n\n\tif (!of_have_populated_dt())\n\t\treturn -ENODEV;\n\n\tif (IS_ENABLED(CONFIG_PPC)) {\n\t\tstruct device_node *boot_display = NULL;\n\t\tstruct platform_device *dev;\n\t\tint display_number = 0;\n\t\tint ret;\n\n\t\t \n\t\tif (of_property_present(of_chosen, \"linux,bootx-noscreen\")) {\n\t\t\t \n\t\t\tdev = platform_device_alloc(\"bootx-noscreen\", 0);\n\t\t\tif (WARN_ON(!dev))\n\t\t\t\treturn -ENOMEM;\n\t\t\tret = platform_device_add(dev);\n\t\t\tif (WARN_ON(ret)) {\n\t\t\t\tplatform_device_put(dev);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor_each_node_by_type(node, \"display\") {\n\t\t\tif (!of_get_property(node, \"linux,opened\", NULL) ||\n\t\t\t    !of_get_property(node, \"linux,boot-display\", NULL))\n\t\t\t\tcontinue;\n\t\t\tdev = of_platform_device_create(node, \"of-display\", NULL);\n\t\t\tof_node_put(node);\n\t\t\tif (WARN_ON(!dev))\n\t\t\t\treturn -ENOMEM;\n\t\t\tboot_display = node;\n\t\t\tdisplay_number++;\n\t\t\tbreak;\n\t\t}\n\t\tfor_each_node_by_type(node, \"display\") {\n\t\t\tchar buf[14];\n\t\t\tconst char *of_display_format = \"of-display.%d\";\n\n\t\t\tif (!of_get_property(node, \"linux,opened\", NULL) || node == boot_display)\n\t\t\t\tcontinue;\n\t\t\tret = snprintf(buf, sizeof(buf), of_display_format, display_number++);\n\t\t\tif (ret < sizeof(buf))\n\t\t\t\tof_platform_device_create(node, buf, NULL);\n\t\t}\n\n\t} else {\n\t\t \n\t\tfor_each_matching_node(node, reserved_mem_matches)\n\t\t\tof_platform_device_create(node, NULL, NULL);\n\n\t\tnode = of_find_node_by_path(\"/firmware\");\n\t\tif (node) {\n\t\t\tof_platform_populate(node, NULL, NULL, NULL);\n\t\t\tof_node_put(node);\n\t\t}\n\n\t\tnode = of_get_compatible_child(of_chosen, \"simple-framebuffer\");\n\t\tof_platform_device_create(node, NULL, NULL);\n\t\tof_node_put(node);\n\n\t\t \n\t\tof_platform_default_populate(NULL, NULL, NULL);\n\t}\n\n\treturn 0;\n}\narch_initcall_sync(of_platform_default_populate_init);\n\nstatic int __init of_platform_sync_state_init(void)\n{\n\tdevice_links_supplier_sync_state_resume();\n\treturn 0;\n}\nlate_initcall_sync(of_platform_sync_state_init);\n\nint of_platform_device_destroy(struct device *dev, void *data)\n{\n\t \n\tif (!dev->of_node || !of_node_check_flag(dev->of_node, OF_POPULATED))\n\t\treturn 0;\n\n\t \n\tif (of_node_check_flag(dev->of_node, OF_POPULATED_BUS))\n\t\tdevice_for_each_child(dev, NULL, of_platform_device_destroy);\n\n\tof_node_clear_flag(dev->of_node, OF_POPULATED);\n\tof_node_clear_flag(dev->of_node, OF_POPULATED_BUS);\n\n\tif (dev->bus == &platform_bus_type)\n\t\tplatform_device_unregister(to_platform_device(dev));\n#ifdef CONFIG_ARM_AMBA\n\telse if (dev->bus == &amba_bustype)\n\t\tamba_device_unregister(to_amba_device(dev));\n#endif\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_platform_device_destroy);\n\n \nvoid of_platform_depopulate(struct device *parent)\n{\n\tif (parent->of_node && of_node_check_flag(parent->of_node, OF_POPULATED_BUS)) {\n\t\tdevice_for_each_child_reverse(parent, NULL, of_platform_device_destroy);\n\t\tof_node_clear_flag(parent->of_node, OF_POPULATED_BUS);\n\t}\n}\nEXPORT_SYMBOL_GPL(of_platform_depopulate);\n\nstatic void devm_of_platform_populate_release(struct device *dev, void *res)\n{\n\tof_platform_depopulate(*(struct device **)res);\n}\n\n \nint devm_of_platform_populate(struct device *dev)\n{\n\tstruct device **ptr;\n\tint ret;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tptr = devres_alloc(devm_of_platform_populate_release,\n\t\t\t   sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tret = of_platform_populate(dev->of_node, NULL, NULL, dev);\n\tif (ret) {\n\t\tdevres_free(ptr);\n\t} else {\n\t\t*ptr = dev;\n\t\tdevres_add(dev, ptr);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_of_platform_populate);\n\nstatic int devm_of_platform_match(struct device *dev, void *res, void *data)\n{\n\tstruct device **ptr = res;\n\n\tif (!ptr) {\n\t\tWARN_ON(!ptr);\n\t\treturn 0;\n\t}\n\n\treturn *ptr == data;\n}\n\n \nvoid devm_of_platform_depopulate(struct device *dev)\n{\n\tint ret;\n\n\tret = devres_release(dev, devm_of_platform_populate_release,\n\t\t\t     devm_of_platform_match, dev);\n\n\tWARN_ON(ret);\n}\nEXPORT_SYMBOL_GPL(devm_of_platform_depopulate);\n\n#ifdef CONFIG_OF_DYNAMIC\nstatic int of_platform_notify(struct notifier_block *nb,\n\t\t\t\tunsigned long action, void *arg)\n{\n\tstruct of_reconfig_data *rd = arg;\n\tstruct platform_device *pdev_parent, *pdev;\n\tbool children_left;\n\n\tswitch (of_reconfig_get_state_change(action, rd)) {\n\tcase OF_RECONFIG_CHANGE_ADD:\n\t\t \n\t\tif (!of_node_check_flag(rd->dn->parent, OF_POPULATED_BUS))\n\t\t\treturn NOTIFY_OK;\t \n\n\t\t \n\t\tif (of_node_check_flag(rd->dn, OF_POPULATED))\n\t\t\treturn NOTIFY_OK;\n\n\t\t \n\t\trd->dn->fwnode.flags &= ~FWNODE_FLAG_NOT_DEVICE;\n\t\t \n\t\tpdev_parent = of_find_device_by_node(rd->dn->parent);\n\t\tpdev = of_platform_device_create(rd->dn, NULL,\n\t\t\t\tpdev_parent ? &pdev_parent->dev : NULL);\n\t\tplatform_device_put(pdev_parent);\n\n\t\tif (pdev == NULL) {\n\t\t\tpr_err(\"%s: failed to create for '%pOF'\\n\",\n\t\t\t\t\t__func__, rd->dn);\n\t\t\t \n\t\t\treturn notifier_from_errno(-EINVAL);\n\t\t}\n\t\tbreak;\n\n\tcase OF_RECONFIG_CHANGE_REMOVE:\n\n\t\t \n\t\tif (!of_node_check_flag(rd->dn, OF_POPULATED))\n\t\t\treturn NOTIFY_OK;\n\n\t\t \n\t\tpdev = of_find_device_by_node(rd->dn);\n\t\tif (pdev == NULL)\n\t\t\treturn NOTIFY_OK;\t \n\n\t\t \n\t\tof_platform_device_destroy(&pdev->dev, &children_left);\n\n\t\t \n\t\tplatform_device_put(pdev);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block platform_of_notifier = {\n\t.notifier_call = of_platform_notify,\n};\n\nvoid of_platform_register_reconfig_notifier(void)\n{\n\tWARN_ON(of_reconfig_notifier_register(&platform_of_notifier));\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}