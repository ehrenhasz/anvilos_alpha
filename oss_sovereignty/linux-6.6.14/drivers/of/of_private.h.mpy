{
  "module_name": "of_private.h",
  "hash_id": "0f10e7534377df36e439cc464296eba580ca77548788c11af1b9b2a564286128",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/of_private.h",
  "human_readable_source": " \n#ifndef _LINUX_OF_PRIVATE_H\n#define _LINUX_OF_PRIVATE_H\n \n\n#define FDT_ALIGN_SIZE 8\n\n \nstruct alias_prop {\n\tstruct list_head link;\n\tconst char *alias;\n\tstruct device_node *np;\n\tint id;\n\tchar stem[];\n};\n\n#if defined(CONFIG_SPARC)\n#define OF_ROOT_NODE_ADDR_CELLS_DEFAULT 2\n#else\n#define OF_ROOT_NODE_ADDR_CELLS_DEFAULT 1\n#endif\n\n#define OF_ROOT_NODE_SIZE_CELLS_DEFAULT 1\n\nextern struct mutex of_mutex;\nextern raw_spinlock_t devtree_lock;\nextern struct list_head aliases_lookup;\nextern struct kset *of_kset;\n\n#if defined(CONFIG_OF_DYNAMIC)\nextern int of_property_notify(int action, struct device_node *np,\n\t\t\t      struct property *prop, struct property *old_prop);\nextern void of_node_release(struct kobject *kobj);\nextern int __of_changeset_apply_entries(struct of_changeset *ocs,\n\t\t\t\t\tint *ret_revert);\nextern int __of_changeset_apply_notify(struct of_changeset *ocs);\nextern int __of_changeset_revert_entries(struct of_changeset *ocs,\n\t\t\t\t\t int *ret_apply);\nextern int __of_changeset_revert_notify(struct of_changeset *ocs);\n#else  \nstatic inline int of_property_notify(int action, struct device_node *np,\n\t\t\t\t     struct property *prop, struct property *old_prop)\n{\n\treturn 0;\n}\n#endif  \n\n#if defined(CONFIG_OF_DYNAMIC) && defined(CONFIG_OF_ADDRESS)\nvoid of_platform_register_reconfig_notifier(void);\n#else\nstatic inline void of_platform_register_reconfig_notifier(void) { }\n#endif\n\n#if defined(CONFIG_OF_KOBJ)\nint of_node_is_attached(const struct device_node *node);\nint __of_add_property_sysfs(struct device_node *np, struct property *pp);\nvoid __of_remove_property_sysfs(struct device_node *np, struct property *prop);\nvoid __of_update_property_sysfs(struct device_node *np, struct property *newprop,\n\t\tstruct property *oldprop);\nint __of_attach_node_sysfs(struct device_node *np);\nvoid __of_detach_node_sysfs(struct device_node *np);\n#else\nstatic inline int __of_add_property_sysfs(struct device_node *np, struct property *pp)\n{\n\treturn 0;\n}\nstatic inline void __of_remove_property_sysfs(struct device_node *np, struct property *prop) {}\nstatic inline void __of_update_property_sysfs(struct device_node *np,\n\t\tstruct property *newprop, struct property *oldprop) {}\nstatic inline int __of_attach_node_sysfs(struct device_node *np)\n{\n\treturn 0;\n}\nstatic inline void __of_detach_node_sysfs(struct device_node *np) {}\n#endif\n\n#if defined(CONFIG_OF_RESOLVE)\nint of_resolve_phandles(struct device_node *tree);\n#endif\n\nvoid __of_phandle_cache_inv_entry(phandle handle);\n\n#if defined(CONFIG_OF_OVERLAY)\nvoid of_overlay_mutex_lock(void);\nvoid of_overlay_mutex_unlock(void);\n#else\nstatic inline void of_overlay_mutex_lock(void) {};\nstatic inline void of_overlay_mutex_unlock(void) {};\n#endif\n\n#if defined(CONFIG_OF_UNITTEST) && defined(CONFIG_OF_OVERLAY)\nextern void __init unittest_unflatten_overlay_base(void);\n#else\nstatic inline void unittest_unflatten_overlay_base(void) {};\n#endif\n\nextern void *__unflatten_device_tree(const void *blob,\n\t\t\t      struct device_node *dad,\n\t\t\t      struct device_node **mynodes,\n\t\t\t      void *(*dt_alloc)(u64 size, u64 align),\n\t\t\t      bool detached);\n\n \nstruct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);\nstruct device_node *__of_node_dup(const struct device_node *np,\n\t\t\t\t  const char *full_name);\n\nstruct device_node *__of_find_node_by_path(struct device_node *parent,\n\t\t\t\t\t\tconst char *path);\nstruct device_node *__of_find_node_by_full_path(struct device_node *node,\n\t\t\t\t\t\tconst char *path);\n\nextern const void *__of_get_property(const struct device_node *np,\n\t\t\t\t     const char *name, int *lenp);\nextern int __of_add_property(struct device_node *np, struct property *prop);\nextern int __of_remove_property(struct device_node *np, struct property *prop);\nextern int __of_update_property(struct device_node *np,\n\t\tstruct property *newprop, struct property **oldprop);\n\nextern void __of_detach_node(struct device_node *np);\n\nextern void __of_sysfs_remove_bin_file(struct device_node *np,\n\t\t\t\t       struct property *prop);\n\n \n#define OF_PHANDLE_ILLEGAL\t0xdeadbeef\n\n \n \n#define for_each_transaction_entry(_oft, _te) \\\n\tlist_for_each_entry(_te, &(_oft)->te_list, node)\n\n \n#define for_each_transaction_entry_reverse(_oft, _te) \\\n\tlist_for_each_entry_reverse(_te, &(_oft)->te_list, node)\n\nextern int of_bus_n_addr_cells(struct device_node *np);\nextern int of_bus_n_size_cells(struct device_node *np);\n\nstruct bus_dma_region;\n#if defined(CONFIG_OF_ADDRESS) && defined(CONFIG_HAS_DMA)\nint of_dma_get_range(struct device_node *np,\n\t\tconst struct bus_dma_region **map);\nstruct device_node *__of_get_dma_parent(const struct device_node *np);\n#else\nstatic inline int of_dma_get_range(struct device_node *np,\n\t\tconst struct bus_dma_region **map)\n{\n\treturn -ENODEV;\n}\nstatic inline struct device_node *__of_get_dma_parent(const struct device_node *np)\n{\n\treturn of_get_parent(np);\n}\n#endif\n\nvoid fdt_init_reserved_mem(void);\nvoid fdt_reserved_mem_save_node(unsigned long node, const char *uname,\n\t\t\t       phys_addr_t base, phys_addr_t size);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}