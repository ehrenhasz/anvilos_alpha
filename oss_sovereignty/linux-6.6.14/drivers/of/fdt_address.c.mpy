{
  "module_name": "fdt_address.c",
  "hash_id": "fdd3085018948f7c7d96641a2902cd5f22bb0d2df0c2cfd302af8df3daab6a5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/fdt_address.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"OF: fdt: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/libfdt.h>\n#include <linux/of.h>\n#include <linux/of_fdt.h>\n#include <linux/sizes.h>\n\n \n#define OF_MAX_ADDR_CELLS\t4\n#define OF_CHECK_COUNTS(na, ns)\t((na) > 0 && (na) <= OF_MAX_ADDR_CELLS && \\\n\t\t\t(ns) > 0)\n\n \n#ifdef DEBUG\nstatic void __init of_dump_addr(const char *s, const __be32 *addr, int na)\n{\n\tpr_debug(\"%s\", s);\n\twhile(na--)\n\t\tpr_cont(\" %08x\", *(addr++));\n\tpr_cont(\"\\n\");\n}\n#else\nstatic void __init of_dump_addr(const char *s, const __be32 *addr, int na) { }\n#endif\n\n \nstruct of_bus {\n\tvoid\t\t(*count_cells)(const void *blob, int parentoffset,\n\t\t\t\tint *addrc, int *sizec);\n\tu64\t\t(*map)(__be32 *addr, const __be32 *range,\n\t\t\t\tint na, int ns, int pna);\n\tint\t\t(*translate)(__be32 *addr, u64 offset, int na);\n};\n\n \nstatic void __init fdt_bus_default_count_cells(const void *blob, int parentoffset,\n\t\t\t\t\t       int *addrc, int *sizec)\n{\n\tconst __be32 *prop;\n\n\tif (addrc) {\n\t\tprop = fdt_getprop(blob, parentoffset, \"#address-cells\", NULL);\n\t\tif (prop)\n\t\t\t*addrc = be32_to_cpup(prop);\n\t\telse\n\t\t\t*addrc = dt_root_addr_cells;\n\t}\n\n\tif (sizec) {\n\t\tprop = fdt_getprop(blob, parentoffset, \"#size-cells\", NULL);\n\t\tif (prop)\n\t\t\t*sizec = be32_to_cpup(prop);\n\t\telse\n\t\t\t*sizec = dt_root_size_cells;\n\t}\n}\n\nstatic u64 __init fdt_bus_default_map(__be32 *addr, const __be32 *range,\n\t\t\t\t      int na, int ns, int pna)\n{\n\tu64 cp, s, da;\n\n\tcp = of_read_number(range, na);\n\ts  = of_read_number(range + na + pna, ns);\n\tda = of_read_number(addr, na);\n\n\tpr_debug(\"default map, cp=%llx, s=%llx, da=%llx\\n\",\n\t    cp, s, da);\n\n\tif (da < cp || da >= (cp + s))\n\t\treturn OF_BAD_ADDR;\n\treturn da - cp;\n}\n\nstatic int __init fdt_bus_default_translate(__be32 *addr, u64 offset, int na)\n{\n\tu64 a = of_read_number(addr, na);\n\tmemset(addr, 0, na * 4);\n\ta += offset;\n\tif (na > 1)\n\t\taddr[na - 2] = cpu_to_fdt32(a >> 32);\n\taddr[na - 1] = cpu_to_fdt32(a & 0xffffffffu);\n\n\treturn 0;\n}\n\n \nstatic const struct of_bus of_busses[] __initconst = {\n\t \n\t{\n\t\t.count_cells = fdt_bus_default_count_cells,\n\t\t.map = fdt_bus_default_map,\n\t\t.translate = fdt_bus_default_translate,\n\t},\n};\n\nstatic int __init fdt_translate_one(const void *blob, int parent,\n\t\t\t\t    const struct of_bus *bus,\n\t\t\t\t    const struct of_bus *pbus, __be32 *addr,\n\t\t\t\t    int na, int ns, int pna, const char *rprop)\n{\n\tconst __be32 *ranges;\n\tint rlen;\n\tint rone;\n\tu64 offset = OF_BAD_ADDR;\n\n\tranges = fdt_getprop(blob, parent, rprop, &rlen);\n\tif (!ranges)\n\t\treturn 1;\n\tif (rlen == 0) {\n\t\toffset = of_read_number(addr, na);\n\t\tmemset(addr, 0, pna * 4);\n\t\tpr_debug(\"empty ranges, 1:1 translation\\n\");\n\t\tgoto finish;\n\t}\n\n\tpr_debug(\"walking ranges...\\n\");\n\n\t \n\trlen /= 4;\n\trone = na + pna + ns;\n\tfor (; rlen >= rone; rlen -= rone, ranges += rone) {\n\t\toffset = bus->map(addr, ranges, na, ns, pna);\n\t\tif (offset != OF_BAD_ADDR)\n\t\t\tbreak;\n\t}\n\tif (offset == OF_BAD_ADDR) {\n\t\tpr_debug(\"not found !\\n\");\n\t\treturn 1;\n\t}\n\tmemcpy(addr, ranges + na, 4 * pna);\n\n finish:\n\tof_dump_addr(\"parent translation for:\", addr, pna);\n\tpr_debug(\"with offset: %llx\\n\", offset);\n\n\t \n\treturn pbus->translate(addr, offset, pna);\n}\n\n \nstatic u64 __init fdt_translate_address(const void *blob, int node_offset)\n{\n\tint parent, len;\n\tconst struct of_bus *bus, *pbus;\n\tconst __be32 *reg;\n\t__be32 addr[OF_MAX_ADDR_CELLS];\n\tint na, ns, pna, pns;\n\tu64 result = OF_BAD_ADDR;\n\n\tpr_debug(\"** translation for device %s **\\n\",\n\t\t fdt_get_name(blob, node_offset, NULL));\n\n\treg = fdt_getprop(blob, node_offset, \"reg\", &len);\n\tif (!reg) {\n\t\tpr_err(\"warning: device tree node '%s' has no address.\\n\",\n\t\t\tfdt_get_name(blob, node_offset, NULL));\n\t\tgoto bail;\n\t}\n\n\t \n\tparent = fdt_parent_offset(blob, node_offset);\n\tif (parent < 0)\n\t\tgoto bail;\n\tbus = &of_busses[0];\n\n\t \n\tbus->count_cells(blob, parent, &na, &ns);\n\tif (!OF_CHECK_COUNTS(na, ns)) {\n\t\tpr_err(\"Bad cell count for %s\\n\",\n\t\t       fdt_get_name(blob, node_offset, NULL));\n\t\tgoto bail;\n\t}\n\tmemcpy(addr, reg, na * 4);\n\n\tpr_debug(\"bus (na=%d, ns=%d) on %s\\n\",\n\t\t na, ns, fdt_get_name(blob, parent, NULL));\n\tof_dump_addr(\"translating address:\", addr, na);\n\n\t \n\tfor (;;) {\n\t\t \n\t\tnode_offset = parent;\n\t\tparent = fdt_parent_offset(blob, node_offset);\n\n\t\t \n\t\tif (parent < 0) {\n\t\t\tpr_debug(\"reached root node\\n\");\n\t\t\tresult = of_read_number(addr, na);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpbus = &of_busses[0];\n\t\tpbus->count_cells(blob, parent, &pna, &pns);\n\t\tif (!OF_CHECK_COUNTS(pna, pns)) {\n\t\t\tpr_err(\"Bad cell count for %s\\n\",\n\t\t\t\tfdt_get_name(blob, node_offset, NULL));\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_debug(\"parent bus (na=%d, ns=%d) on %s\\n\",\n\t\t\t pna, pns, fdt_get_name(blob, parent, NULL));\n\n\t\t \n\t\tif (fdt_translate_one(blob, node_offset, bus, pbus,\n\t\t\t\t\taddr, na, ns, pna, \"ranges\"))\n\t\t\tbreak;\n\n\t\t \n\t\tna = pna;\n\t\tns = pns;\n\t\tbus = pbus;\n\n\t\tof_dump_addr(\"one level translation:\", addr, na);\n\t}\n bail:\n\treturn result;\n}\n\n \nu64 __init of_flat_dt_translate_address(unsigned long node)\n{\n\treturn fdt_translate_address(initial_boot_params, node);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}