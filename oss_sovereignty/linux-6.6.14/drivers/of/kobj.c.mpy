{
  "module_name": "kobj.c",
  "hash_id": "071aa015e344acb07a7ddc26fa113a3e8c666daaa29fe78c9e83a457ee663210",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/kobj.c",
  "human_readable_source": "\n#include <linux/of.h>\n#include <linux/slab.h>\n\n#include \"of_private.h\"\n\n \nstatic int of_node_is_initialized(const struct device_node *node)\n{\n\treturn node && node->kobj.state_initialized;\n}\n\n \nint of_node_is_attached(const struct device_node *node)\n{\n\treturn node && node->kobj.state_in_sysfs;\n}\n\n\n#ifndef CONFIG_OF_DYNAMIC\nstatic void of_node_release(struct kobject *kobj)\n{\n\t \n}\n#endif  \n\nconst struct kobj_type of_node_ktype = {\n\t.release = of_node_release,\n};\n\nstatic ssize_t of_node_property_read(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr, char *buf,\n\t\t\t\tloff_t offset, size_t count)\n{\n\tstruct property *pp = container_of(bin_attr, struct property, attr);\n\treturn memory_read_from_buffer(buf, count, &offset, pp->value, pp->length);\n}\n\n \nstatic const char *safe_name(struct kobject *kobj, const char *orig_name)\n{\n\tconst char *name = orig_name;\n\tstruct kernfs_node *kn;\n\tint i = 0;\n\n\t \n\twhile (i < 16 && (kn = sysfs_get_dirent(kobj->sd, name))) {\n\t\tsysfs_put(kn);\n\t\tif (name != orig_name)\n\t\t\tkfree(name);\n\t\tname = kasprintf(GFP_KERNEL, \"%s#%i\", orig_name, ++i);\n\t}\n\n\tif (name == orig_name) {\n\t\tname = kstrdup(orig_name, GFP_KERNEL);\n\t} else {\n\t\tpr_warn(\"Duplicate name in %s, renamed to \\\"%s\\\"\\n\",\n\t\t\tkobject_name(kobj), name);\n\t}\n\treturn name;\n}\n\nint __of_add_property_sysfs(struct device_node *np, struct property *pp)\n{\n\tint rc;\n\n\t \n\tbool secure = strncmp(pp->name, \"security-\", 9) == 0;\n\n\tif (!IS_ENABLED(CONFIG_SYSFS))\n\t\treturn 0;\n\n\tif (!of_kset || !of_node_is_attached(np))\n\t\treturn 0;\n\n\tsysfs_bin_attr_init(&pp->attr);\n\tpp->attr.attr.name = safe_name(&np->kobj, pp->name);\n\tpp->attr.attr.mode = secure ? 0400 : 0444;\n\tpp->attr.size = secure ? 0 : pp->length;\n\tpp->attr.read = of_node_property_read;\n\n\trc = sysfs_create_bin_file(&np->kobj, &pp->attr);\n\tWARN(rc, \"error adding attribute %s to node %pOF\\n\", pp->name, np);\n\treturn rc;\n}\n\nvoid __of_sysfs_remove_bin_file(struct device_node *np, struct property *prop)\n{\n\tif (!IS_ENABLED(CONFIG_SYSFS))\n\t\treturn;\n\n\tsysfs_remove_bin_file(&np->kobj, &prop->attr);\n\tkfree(prop->attr.attr.name);\n}\n\nvoid __of_remove_property_sysfs(struct device_node *np, struct property *prop)\n{\n\t \n\tif (of_kset && of_node_is_attached(np))\n\t\t__of_sysfs_remove_bin_file(np, prop);\n}\n\nvoid __of_update_property_sysfs(struct device_node *np, struct property *newprop,\n\t\tstruct property *oldprop)\n{\n\t \n\tif (!of_kset)\n\t\treturn;\n\n\tif (oldprop)\n\t\t__of_sysfs_remove_bin_file(np, oldprop);\n\t__of_add_property_sysfs(np, newprop);\n}\n\nint __of_attach_node_sysfs(struct device_node *np)\n{\n\tconst char *name;\n\tstruct kobject *parent;\n\tstruct property *pp;\n\tint rc;\n\n\tif (!IS_ENABLED(CONFIG_SYSFS) || !of_kset)\n\t\treturn 0;\n\n\tnp->kobj.kset = of_kset;\n\tif (!np->parent) {\n\t\t \n\t\tname = safe_name(&of_kset->kobj, \"base\");\n\t\tparent = NULL;\n\t} else {\n\t\tname = safe_name(&np->parent->kobj, kbasename(np->full_name));\n\t\tparent = &np->parent->kobj;\n\t}\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\trc = kobject_add(&np->kobj, parent, \"%s\", name);\n\tkfree(name);\n\tif (rc)\n\t\treturn rc;\n\n\tfor_each_property_of_node(np, pp)\n\t\t__of_add_property_sysfs(np, pp);\n\n\tof_node_get(np);\n\treturn 0;\n}\n\nvoid __of_detach_node_sysfs(struct device_node *np)\n{\n\tstruct property *pp;\n\n\tBUG_ON(!of_node_is_initialized(np));\n\tif (!of_kset)\n\t\treturn;\n\n\t \n\tif (of_node_is_attached(np)) {\n\t\tfor_each_property_of_node(np, pp)\n\t\t\t__of_sysfs_remove_bin_file(np, pp);\n\t\tkobject_del(&np->kobj);\n\t}\n\n\tof_node_put(np);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}