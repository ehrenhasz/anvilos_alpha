{
  "module_name": "unittest.c",
  "hash_id": "fe866cdbe6539ab8c676c23b854f9c695ead4d588b39ab2cecb0e5df2635ea4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/unittest.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"### dt-test ### \" fmt\n\n#include <linux/memblock.h>\n#include <linux/clk.h>\n#include <linux/dma-direct.h>  \n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/hashtable.h>\n#include <linux/libfdt.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_fdt.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/gpio/driver.h>\n\n#include <linux/bitops.h>\n\n#include \"of_private.h\"\n\nstatic struct unittest_results {\n\tint passed;\n\tint failed;\n} unittest_results;\n\n#define unittest(result, fmt, ...) ({ \\\n\tbool failed = !(result); \\\n\tif (failed) { \\\n\t\tunittest_results.failed++; \\\n\t\tpr_err(\"FAIL %s():%i \" fmt, __func__, __LINE__, ##__VA_ARGS__); \\\n\t} else { \\\n\t\tunittest_results.passed++; \\\n\t\tpr_info(\"pass %s():%i\\n\", __func__, __LINE__); \\\n\t} \\\n\tfailed; \\\n})\n\n \n#define EXPECT_BEGIN(level, fmt, ...) \\\n\tprintk(level pr_fmt(\"EXPECT \\\\ : \") fmt, ##__VA_ARGS__)\n\n#define EXPECT_END(level, fmt, ...) \\\n\tprintk(level pr_fmt(\"EXPECT / : \") fmt, ##__VA_ARGS__)\n\n#define EXPECT_NOT_BEGIN(level, fmt, ...) \\\n\tprintk(level pr_fmt(\"EXPECT_NOT \\\\ : \") fmt, ##__VA_ARGS__)\n\n#define EXPECT_NOT_END(level, fmt, ...) \\\n\tprintk(level pr_fmt(\"EXPECT_NOT / : \") fmt, ##__VA_ARGS__)\n\nstatic void __init of_unittest_find_node_by_name(void)\n{\n\tstruct device_node *np;\n\tconst char *options, *name;\n\n\tnp = of_find_node_by_path(\"/testcase-data\");\n\tname = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tunittest(np && name && !strcmp(\"/testcase-data\", name),\n\t\t\"find /testcase-data failed\\n\");\n\tof_node_put(np);\n\tkfree(name);\n\n\t \n\tnp = of_find_node_by_path(\"/testcase-data/\");\n\tunittest(!np, \"trailing '/' on /testcase-data/ should fail\\n\");\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-a\");\n\tname = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tunittest(np && name && !strcmp(\"/testcase-data/phandle-tests/consumer-a\", name),\n\t\t\"find /testcase-data/phandle-tests/consumer-a failed\\n\");\n\tof_node_put(np);\n\tkfree(name);\n\n\tnp = of_find_node_by_path(\"testcase-alias\");\n\tname = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tunittest(np && name && !strcmp(\"/testcase-data\", name),\n\t\t\"find testcase-alias failed\\n\");\n\tof_node_put(np);\n\tkfree(name);\n\n\t \n\tnp = of_find_node_by_path(\"testcase-alias/\");\n\tunittest(!np, \"trailing '/' on testcase-alias/ should fail\\n\");\n\n\tnp = of_find_node_by_path(\"testcase-alias/phandle-tests/consumer-a\");\n\tname = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tunittest(np && name && !strcmp(\"/testcase-data/phandle-tests/consumer-a\", name),\n\t\t\"find testcase-alias/phandle-tests/consumer-a failed\\n\");\n\tof_node_put(np);\n\tkfree(name);\n\n\tnp = of_find_node_by_path(\"/testcase-data/missing-path\");\n\tunittest(!np, \"non-existent path returned node %pOF\\n\", np);\n\tof_node_put(np);\n\n\tnp = of_find_node_by_path(\"missing-alias\");\n\tunittest(!np, \"non-existent alias returned node %pOF\\n\", np);\n\tof_node_put(np);\n\n\tnp = of_find_node_by_path(\"testcase-alias/missing-path\");\n\tunittest(!np, \"non-existent alias with relative path returned node %pOF\\n\", np);\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"/testcase-data:testoption\", &options);\n\tunittest(np && !strcmp(\"testoption\", options),\n\t\t \"option path test failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"/testcase-data:test/option\", &options);\n\tunittest(np && !strcmp(\"test/option\", options),\n\t\t \"option path test, subcase #1 failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"/testcase-data/testcase-device1:test/option\", &options);\n\tunittest(np && !strcmp(\"test/option\", options),\n\t\t \"option path test, subcase #2 failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"/testcase-data:testoption\", NULL);\n\tunittest(np, \"NULL option path test failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"testcase-alias:testaliasoption\",\n\t\t\t\t       &options);\n\tunittest(np && !strcmp(\"testaliasoption\", options),\n\t\t \"option alias path test failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"testcase-alias:test/alias/option\",\n\t\t\t\t       &options);\n\tunittest(np && !strcmp(\"test/alias/option\", options),\n\t\t \"option alias path test, subcase #1 failed\\n\");\n\tof_node_put(np);\n\n\tnp = of_find_node_opts_by_path(\"testcase-alias:testaliasoption\", NULL);\n\tunittest(np, \"NULL option alias path test failed\\n\");\n\tof_node_put(np);\n\n\toptions = \"testoption\";\n\tnp = of_find_node_opts_by_path(\"testcase-alias\", &options);\n\tunittest(np && !options, \"option clearing test failed\\n\");\n\tof_node_put(np);\n\n\toptions = \"testoption\";\n\tnp = of_find_node_opts_by_path(\"/\", &options);\n\tunittest(np && !options, \"option clearing root node test failed\\n\");\n\tof_node_put(np);\n}\n\nstatic void __init of_unittest_dynamic(void)\n{\n\tstruct device_node *np;\n\tstruct property *prop;\n\n\tnp = of_find_node_by_path(\"/testcase-data\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\t \n\tprop = kcalloc(4, sizeof(*prop), GFP_KERNEL);\n\tif (!prop) {\n\t\tunittest(0, \"kzalloc() failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tprop->name = \"new-property\";\n\tprop->value = \"new-property-data\";\n\tprop->length = strlen(prop->value) + 1;\n\tunittest(of_add_property(np, prop) == 0, \"Adding a new property failed\\n\");\n\n\t \n\tprop++;\n\tprop->name = \"new-property\";\n\tprop->value = \"new-property-data-should-fail\";\n\tprop->length = strlen(prop->value) + 1;\n\tunittest(of_add_property(np, prop) != 0,\n\t\t \"Adding an existing property should have failed\\n\");\n\n\t \n\tprop->value = \"modify-property-data-should-pass\";\n\tprop->length = strlen(prop->value) + 1;\n\tunittest(of_update_property(np, prop) == 0,\n\t\t \"Updating an existing property should have passed\\n\");\n\n\t \n\tprop++;\n\tprop->name = \"modify-property\";\n\tprop->value = \"modify-missing-property-data-should-pass\";\n\tprop->length = strlen(prop->value) + 1;\n\tunittest(of_update_property(np, prop) == 0,\n\t\t \"Updating a missing property should have passed\\n\");\n\n\t \n\tunittest(of_remove_property(np, prop) == 0,\n\t\t \"Removing a property should have passed\\n\");\n\n\t \n\tprop++;\n\tprop->name = \"large-property-PAGE_SIZEx8\";\n\tprop->length = PAGE_SIZE * 8;\n\tprop->value = kzalloc(prop->length, GFP_KERNEL);\n\tunittest(prop->value != NULL, \"Unable to allocate large buffer\\n\");\n\tif (prop->value)\n\t\tunittest(of_add_property(np, prop) == 0,\n\t\t\t \"Adding a large property should have passed\\n\");\n}\n\nstatic int __init of_unittest_check_node_linkage(struct device_node *np)\n{\n\tstruct device_node *child;\n\tint count = 0, rc;\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (child->parent != np) {\n\t\t\tpr_err(\"Child node %pOFn links to wrong parent %pOFn\\n\",\n\t\t\t\t child, np);\n\t\t\trc = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\trc = of_unittest_check_node_linkage(child);\n\t\tif (rc < 0)\n\t\t\tgoto put_child;\n\t\tcount += rc;\n\t}\n\n\treturn count + 1;\nput_child:\n\tof_node_put(child);\n\treturn rc;\n}\n\nstatic void __init of_unittest_check_tree_linkage(void)\n{\n\tstruct device_node *np;\n\tint allnode_count = 0, child_count;\n\n\tif (!of_root)\n\t\treturn;\n\n\tfor_each_of_allnodes(np)\n\t\tallnode_count++;\n\tchild_count = of_unittest_check_node_linkage(of_root);\n\n\tunittest(child_count > 0, \"Device node data structure is corrupted\\n\");\n\tunittest(child_count == allnode_count,\n\t\t \"allnodes list size (%i) doesn't match sibling lists size (%i)\\n\",\n\t\t allnode_count, child_count);\n\tpr_debug(\"allnodes list size (%i); sibling lists size (%i)\\n\", allnode_count, child_count);\n}\n\nstatic void __init of_unittest_printf_one(struct device_node *np, const char *fmt,\n\t\t\t\t\t  const char *expected)\n{\n\tunsigned char *buf;\n\tint buf_size;\n\tint size, i;\n\n\tbuf_size = strlen(expected) + 10;\n\tbuf = kmalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\t \n\tmemset(buf, 0xff, buf_size);\n\tsize = snprintf(buf, buf_size - 2, fmt, np);\n\n\t \n\tunittest((strcmp(buf, expected) == 0) && (buf[size+1] == 0xff),\n\t\t\"sprintf failed; fmt='%s' expected='%s' rslt='%s'\\n\",\n\t\tfmt, expected, buf);\n\n\t \n\tsize++;\n\tfor (i = 0; i < 2; i++, size--) {\n\t\t \n\t\tmemset(buf, 0xff, buf_size);\n\t\tsnprintf(buf, size+1, fmt, np);\n\t\tunittest(strncmp(buf, expected, size) == 0 && (buf[size+1] == 0xff),\n\t\t\t\"snprintf failed; size=%i fmt='%s' expected='%s' rslt='%s'\\n\",\n\t\t\tsize, fmt, expected, buf);\n\t}\n\tkfree(buf);\n}\n\nstatic void __init of_unittest_printf(void)\n{\n\tstruct device_node *np;\n\tconst char *full_name = \"/testcase-data/platform-tests/test-device@1/dev@100\";\n\tchar phandle_str[16] = \"\";\n\n\tnp = of_find_node_by_path(full_name);\n\tif (!np) {\n\t\tunittest(np, \"testcase data missing\\n\");\n\t\treturn;\n\t}\n\n\tnum_to_str(phandle_str, sizeof(phandle_str), np->phandle, 0);\n\n\tof_unittest_printf_one(np, \"%pOF\",  full_name);\n\tof_unittest_printf_one(np, \"%pOFf\", full_name);\n\tof_unittest_printf_one(np, \"%pOFn\", \"dev\");\n\tof_unittest_printf_one(np, \"%2pOFn\", \"dev\");\n\tof_unittest_printf_one(np, \"%5pOFn\", \"  dev\");\n\tof_unittest_printf_one(np, \"%pOFnc\", \"dev:test-sub-device\");\n\tof_unittest_printf_one(np, \"%pOFp\", phandle_str);\n\tof_unittest_printf_one(np, \"%pOFP\", \"dev@100\");\n\tof_unittest_printf_one(np, \"ABC %pOFP ABC\", \"ABC dev@100 ABC\");\n\tof_unittest_printf_one(np, \"%10pOFP\", \"   dev@100\");\n\tof_unittest_printf_one(np, \"%-10pOFP\", \"dev@100   \");\n\tof_unittest_printf_one(of_root, \"%pOFP\", \"/\");\n\tof_unittest_printf_one(np, \"%pOFF\", \"----\");\n\tof_unittest_printf_one(np, \"%pOFPF\", \"dev@100:----\");\n\tof_unittest_printf_one(np, \"%pOFPFPc\", \"dev@100:----:dev@100:test-sub-device\");\n\tof_unittest_printf_one(np, \"%pOFc\", \"test-sub-device\");\n\tof_unittest_printf_one(np, \"%pOFC\",\n\t\t\t\"\\\"test-sub-device\\\",\\\"test-compat2\\\",\\\"test-compat3\\\"\");\n}\n\nstruct node_hash {\n\tstruct hlist_node node;\n\tstruct device_node *np;\n};\n\nstatic DEFINE_HASHTABLE(phandle_ht, 8);\nstatic void __init of_unittest_check_phandles(void)\n{\n\tstruct device_node *np;\n\tstruct node_hash *nh;\n\tstruct hlist_node *tmp;\n\tint i, dup_count = 0, phandle_count = 0;\n\n\tfor_each_of_allnodes(np) {\n\t\tif (!np->phandle)\n\t\t\tcontinue;\n\n\t\thash_for_each_possible(phandle_ht, nh, node, np->phandle) {\n\t\t\tif (nh->np->phandle == np->phandle) {\n\t\t\t\tpr_info(\"Duplicate phandle! %i used by %pOF and %pOF\\n\",\n\t\t\t\t\tnp->phandle, nh->np, np);\n\t\t\t\tdup_count++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tnh = kzalloc(sizeof(*nh), GFP_KERNEL);\n\t\tif (!nh)\n\t\t\treturn;\n\n\t\tnh->np = np;\n\t\thash_add(phandle_ht, &nh->node, np->phandle);\n\t\tphandle_count++;\n\t}\n\tunittest(dup_count == 0, \"Found %i duplicates in %i phandles\\n\",\n\t\t dup_count, phandle_count);\n\n\t \n\thash_for_each_safe(phandle_ht, i, tmp, nh, node) {\n\t\thash_del(&nh->node);\n\t\tkfree(nh);\n\t}\n}\n\nstatic void __init of_unittest_parse_phandle_with_args(void)\n{\n\tstruct device_node *np;\n\tstruct of_phandle_args args;\n\tint i, rc;\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-a\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\trc = of_count_phandle_with_args(np, \"phandle-list\", \"#phandle-cells\");\n\tunittest(rc == 7, \"of_count_phandle_with_args() returned %i, expected 7\\n\", rc);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_parse_phandle_with_args(np, \"phandle-list\",\n\t\t\t\t\t\t\"#phandle-cells\", i, &args);\n\n\t\t \n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tpassed &= (args.args[1] == 0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpassed &= (rc == -ENOENT);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tpassed &= (args.args[1] == 4);\n\t\t\tpassed &= (args.args[2] == 3);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tpassed &= (args.args[1] == 100);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 0);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == (i + 1));\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tpassed &= (rc == -ENOENT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpassed = false;\n\t\t}\n\n\t\tunittest(passed, \"index %i - data error on node %pOF rc=%i\\n\",\n\t\t\t i, args.np, rc);\n\n\t\tif (rc == 0)\n\t\t\tof_node_put(args.np);\n\t}\n\n\t \n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args(np, \"phandle-list-missing\",\n\t\t\t\t\t\"#phandle-cells\", 0, &args);\n\tunittest(rc == -ENOENT, \"expected:%i got:%i\\n\", -ENOENT, rc);\n\trc = of_count_phandle_with_args(np, \"phandle-list-missing\",\n\t\t\t\t\t\"#phandle-cells\");\n\tunittest(rc == -ENOENT, \"expected:%i got:%i\\n\", -ENOENT, rc);\n\n\t \n\tmemset(&args, 0, sizeof(args));\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: /testcase-data/phandle-tests/consumer-a: could not get #phandle-cells-missing for /testcase-data/phandle-tests/provider1\");\n\n\trc = of_parse_phandle_with_args(np, \"phandle-list\",\n\t\t\t\t\t\"#phandle-cells-missing\", 0, &args);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: /testcase-data/phandle-tests/consumer-a: could not get #phandle-cells-missing for /testcase-data/phandle-tests/provider1\");\n\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: /testcase-data/phandle-tests/consumer-a: could not get #phandle-cells-missing for /testcase-data/phandle-tests/provider1\");\n\n\trc = of_count_phandle_with_args(np, \"phandle-list\",\n\t\t\t\t\t\"#phandle-cells-missing\");\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: /testcase-data/phandle-tests/consumer-a: could not get #phandle-cells-missing for /testcase-data/phandle-tests/provider1\");\n\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\t \n\tmemset(&args, 0, sizeof(args));\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: /testcase-data/phandle-tests/consumer-a: could not find phandle\");\n\n\trc = of_parse_phandle_with_args(np, \"phandle-list-bad-phandle\",\n\t\t\t\t\t\"#phandle-cells\", 0, &args);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: /testcase-data/phandle-tests/consumer-a: could not find phandle\");\n\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: /testcase-data/phandle-tests/consumer-a: could not find phandle\");\n\n\trc = of_count_phandle_with_args(np, \"phandle-list-bad-phandle\",\n\t\t\t\t\t\"#phandle-cells\");\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: /testcase-data/phandle-tests/consumer-a: could not find phandle\");\n\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\t \n\tmemset(&args, 0, sizeof(args));\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: /testcase-data/phandle-tests/consumer-a: #phandle-cells = 3 found 1\");\n\n\trc = of_parse_phandle_with_args(np, \"phandle-list-bad-args\",\n\t\t\t\t\t\"#phandle-cells\", 1, &args);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: /testcase-data/phandle-tests/consumer-a: #phandle-cells = 3 found 1\");\n\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: /testcase-data/phandle-tests/consumer-a: #phandle-cells = 3 found 1\");\n\n\trc = of_count_phandle_with_args(np, \"phandle-list-bad-args\",\n\t\t\t\t\t\"#phandle-cells\");\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: /testcase-data/phandle-tests/consumer-a: #phandle-cells = 3 found 1\");\n\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n}\n\nstatic void __init of_unittest_parse_phandle_with_args_map(void)\n{\n\tstruct device_node *np, *p[6] = {};\n\tstruct of_phandle_args args;\n\tunsigned int prefs[6];\n\tint i, rc;\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-b\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tp[0] = of_find_node_by_path(\"/testcase-data/phandle-tests/provider0\");\n\tp[1] = of_find_node_by_path(\"/testcase-data/phandle-tests/provider1\");\n\tp[2] = of_find_node_by_path(\"/testcase-data/phandle-tests/provider2\");\n\tp[3] = of_find_node_by_path(\"/testcase-data/phandle-tests/provider3\");\n\tp[4] = of_find_node_by_path(\"/testcase-data/phandle-tests/provider4\");\n\tp[5] = of_find_node_by_path(\"/testcase-data/phandle-tests/provider5\");\n\tfor (i = 0; i < ARRAY_SIZE(p); ++i) {\n\t\tif (!p[i]) {\n\t\t\tpr_err(\"missing testcase data\\n\");\n\t\t\treturn;\n\t\t}\n\t\tprefs[i] = kref_read(&p[i]->kobj.kref);\n\t}\n\n\trc = of_count_phandle_with_args(np, \"phandle-list\", \"#phandle-cells\");\n\tunittest(rc == 8, \"of_count_phandle_with_args() returned %i, expected 8\\n\", rc);\n\n\tfor (i = 0; i < 9; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_parse_phandle_with_args_map(np, \"phandle-list\",\n\t\t\t\t\t\t    \"phandle\", i, &args);\n\n\t\t \n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p[1]);\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 1);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p[3]);\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 2);\n\t\t\tpassed &= (args.args[1] == 5);\n\t\t\tpassed &= (args.args[2] == 3);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpassed &= (rc == -ENOENT);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p[0]);\n\t\t\tpassed &= (args.args_count == 0);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p[1]);\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 3);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p[0]);\n\t\t\tpassed &= (args.args_count == 0);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p[2]);\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 15);\n\t\t\tpassed &= (args.args[1] == 0x20);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.np == p[3]);\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 2);\n\t\t\tpassed &= (args.args[1] == 5);\n\t\t\tpassed &= (args.args[2] == 3);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tpassed &= (rc == -ENOENT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpassed = false;\n\t\t}\n\n\t\tunittest(passed, \"index %i - data error on node %s rc=%i\\n\",\n\t\t\t i, args.np->full_name, rc);\n\n\t\tif (rc == 0)\n\t\t\tof_node_put(args.np);\n\t}\n\n\t \n\tmemset(&args, 0, sizeof(args));\n\trc = of_parse_phandle_with_args_map(np, \"phandle-list-missing\",\n\t\t\t\t\t    \"phandle\", 0, &args);\n\tunittest(rc == -ENOENT, \"expected:%i got:%i\\n\", -ENOENT, rc);\n\n\t \n\tmemset(&args, 0, sizeof(args));\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: /testcase-data/phandle-tests/consumer-b: could not get #phandle-missing-cells for /testcase-data/phandle-tests/provider1\");\n\n\trc = of_parse_phandle_with_args_map(np, \"phandle-list\",\n\t\t\t\t\t    \"phandle-missing\", 0, &args);\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: /testcase-data/phandle-tests/consumer-b: could not get #phandle-missing-cells for /testcase-data/phandle-tests/provider1\");\n\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\t \n\tmemset(&args, 0, sizeof(args));\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: /testcase-data/phandle-tests/consumer-b: could not find phandle 12345678\");\n\n\trc = of_parse_phandle_with_args_map(np, \"phandle-list-bad-phandle\",\n\t\t\t\t\t    \"phandle\", 0, &args);\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: /testcase-data/phandle-tests/consumer-b: could not find phandle 12345678\");\n\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\t \n\tmemset(&args, 0, sizeof(args));\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: /testcase-data/phandle-tests/consumer-b: #phandle-cells = 2 found 1\");\n\n\trc = of_parse_phandle_with_args_map(np, \"phandle-list-bad-args\",\n\t\t\t\t\t    \"phandle\", 1, &args);\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: /testcase-data/phandle-tests/consumer-b: #phandle-cells = 2 found 1\");\n\n\tunittest(rc == -EINVAL, \"expected:%i got:%i\\n\", -EINVAL, rc);\n\n\tfor (i = 0; i < ARRAY_SIZE(p); ++i) {\n\t\tunittest(prefs[i] == kref_read(&p[i]->kobj.kref),\n\t\t\t \"provider%d: expected:%d got:%d\\n\",\n\t\t\t i, prefs[i], kref_read(&p[i]->kobj.kref));\n\t\tof_node_put(p[i]);\n\t}\n}\n\nstatic void __init of_unittest_property_string(void)\n{\n\tconst char *strings[4];\n\tstruct device_node *np;\n\tint rc;\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-a\");\n\tif (!np) {\n\t\tpr_err(\"No testcase data in device tree\\n\");\n\t\treturn;\n\t}\n\n\trc = of_property_match_string(np, \"phandle-list-names\", \"first\");\n\tunittest(rc == 0, \"first expected:0 got:%i\\n\", rc);\n\trc = of_property_match_string(np, \"phandle-list-names\", \"second\");\n\tunittest(rc == 1, \"second expected:1 got:%i\\n\", rc);\n\trc = of_property_match_string(np, \"phandle-list-names\", \"third\");\n\tunittest(rc == 2, \"third expected:2 got:%i\\n\", rc);\n\trc = of_property_match_string(np, \"phandle-list-names\", \"fourth\");\n\tunittest(rc == -ENODATA, \"unmatched string; rc=%i\\n\", rc);\n\trc = of_property_match_string(np, \"missing-property\", \"blah\");\n\tunittest(rc == -EINVAL, \"missing property; rc=%i\\n\", rc);\n\trc = of_property_match_string(np, \"empty-property\", \"blah\");\n\tunittest(rc == -ENODATA, \"empty property; rc=%i\\n\", rc);\n\trc = of_property_match_string(np, \"unterminated-string\", \"blah\");\n\tunittest(rc == -EILSEQ, \"unterminated string; rc=%i\\n\", rc);\n\n\t \n\trc = of_property_count_strings(np, \"string-property\");\n\tunittest(rc == 1, \"Incorrect string count; rc=%i\\n\", rc);\n\trc = of_property_count_strings(np, \"phandle-list-names\");\n\tunittest(rc == 3, \"Incorrect string count; rc=%i\\n\", rc);\n\trc = of_property_count_strings(np, \"unterminated-string\");\n\tunittest(rc == -EILSEQ, \"unterminated string; rc=%i\\n\", rc);\n\trc = of_property_count_strings(np, \"unterminated-string-list\");\n\tunittest(rc == -EILSEQ, \"unterminated string array; rc=%i\\n\", rc);\n\n\t \n\trc = of_property_read_string_index(np, \"string-property\", 0, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"foobar\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[0] = NULL;\n\trc = of_property_read_string_index(np, \"string-property\", 1, strings);\n\tunittest(rc == -ENODATA && strings[0] == NULL, \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\trc = of_property_read_string_index(np, \"phandle-list-names\", 0, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"first\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\trc = of_property_read_string_index(np, \"phandle-list-names\", 1, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"second\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\trc = of_property_read_string_index(np, \"phandle-list-names\", 2, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"third\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[0] = NULL;\n\trc = of_property_read_string_index(np, \"phandle-list-names\", 3, strings);\n\tunittest(rc == -ENODATA && strings[0] == NULL, \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[0] = NULL;\n\trc = of_property_read_string_index(np, \"unterminated-string\", 0, strings);\n\tunittest(rc == -EILSEQ && strings[0] == NULL, \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\trc = of_property_read_string_index(np, \"unterminated-string-list\", 0, strings);\n\tunittest(rc == 0 && !strcmp(strings[0], \"first\"), \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[0] = NULL;\n\trc = of_property_read_string_index(np, \"unterminated-string-list\", 2, strings);  \n\tunittest(rc == -EILSEQ && strings[0] == NULL, \"of_property_read_string_index() failure; rc=%i\\n\", rc);\n\tstrings[1] = NULL;\n\n\t \n\trc = of_property_read_string_array(np, \"string-property\", strings, 4);\n\tunittest(rc == 1, \"Incorrect string count; rc=%i\\n\", rc);\n\trc = of_property_read_string_array(np, \"phandle-list-names\", strings, 4);\n\tunittest(rc == 3, \"Incorrect string count; rc=%i\\n\", rc);\n\trc = of_property_read_string_array(np, \"unterminated-string\", strings, 4);\n\tunittest(rc == -EILSEQ, \"unterminated string; rc=%i\\n\", rc);\n\t \n\trc = of_property_read_string_array(np, \"unterminated-string-list\", strings, 4);\n\tunittest(rc == -EILSEQ, \"unterminated string array; rc=%i\\n\", rc);\n\t \n\tstrings[2] = NULL;\n\trc = of_property_read_string_array(np, \"unterminated-string-list\", strings, 2);\n\tunittest(rc == 2 && strings[2] == NULL, \"of_property_read_string_array() failure; rc=%i\\n\", rc);\n\tstrings[1] = NULL;\n\trc = of_property_read_string_array(np, \"phandle-list-names\", strings, 1);\n\tunittest(rc == 1 && strings[1] == NULL, \"Overwrote end of string array; rc=%i, str='%s'\\n\", rc, strings[1]);\n}\n\n#define propcmp(p1, p2) (((p1)->length == (p2)->length) && \\\n\t\t\t(p1)->value && (p2)->value && \\\n\t\t\t!memcmp((p1)->value, (p2)->value, (p1)->length) && \\\n\t\t\t!strcmp((p1)->name, (p2)->name))\nstatic void __init of_unittest_property_copy(void)\n{\n#ifdef CONFIG_OF_DYNAMIC\n\tstruct property p1 = { .name = \"p1\", .length = 0, .value = \"\" };\n\tstruct property p2 = { .name = \"p2\", .length = 5, .value = \"abcd\" };\n\tstruct property *new;\n\n\tnew = __of_prop_dup(&p1, GFP_KERNEL);\n\tunittest(new && propcmp(&p1, new), \"empty property didn't copy correctly\\n\");\n\tkfree(new->value);\n\tkfree(new->name);\n\tkfree(new);\n\n\tnew = __of_prop_dup(&p2, GFP_KERNEL);\n\tunittest(new && propcmp(&p2, new), \"non-empty property didn't copy correctly\\n\");\n\tkfree(new->value);\n\tkfree(new->name);\n\tkfree(new);\n#endif\n}\n\nstatic void __init of_unittest_changeset(void)\n{\n#ifdef CONFIG_OF_DYNAMIC\n\tint ret;\n\tstruct property *ppadd, padd = { .name = \"prop-add\", .length = 1, .value = \"\" };\n\tstruct property *ppname_n1,  pname_n1  = { .name = \"name\", .length = 3, .value = \"n1\"  };\n\tstruct property *ppname_n2,  pname_n2  = { .name = \"name\", .length = 3, .value = \"n2\"  };\n\tstruct property *ppname_n21, pname_n21 = { .name = \"name\", .length = 3, .value = \"n21\" };\n\tstruct property *ppupdate, pupdate = { .name = \"prop-update\", .length = 5, .value = \"abcd\" };\n\tstruct property *ppremove;\n\tstruct device_node *n1, *n2, *n21, *n22, *nchangeset, *nremove, *parent, *np;\n\tstatic const char * const str_array[] = { \"str1\", \"str2\", \"str3\" };\n\tconst u32 u32_array[] = { 1, 2, 3 };\n\tstruct of_changeset chgset;\n\tconst char *propstr = NULL;\n\n\tn1 = __of_node_dup(NULL, \"n1\");\n\tunittest(n1, \"testcase setup failure\\n\");\n\n\tn2 = __of_node_dup(NULL, \"n2\");\n\tunittest(n2, \"testcase setup failure\\n\");\n\n\tn21 = __of_node_dup(NULL, \"n21\");\n\tunittest(n21, \"testcase setup failure %p\\n\", n21);\n\n\tnchangeset = of_find_node_by_path(\"/testcase-data/changeset\");\n\tnremove = of_get_child_by_name(nchangeset, \"node-remove\");\n\tunittest(nremove, \"testcase setup failure\\n\");\n\n\tppadd = __of_prop_dup(&padd, GFP_KERNEL);\n\tunittest(ppadd, \"testcase setup failure\\n\");\n\n\tppname_n1  = __of_prop_dup(&pname_n1, GFP_KERNEL);\n\tunittest(ppname_n1, \"testcase setup failure\\n\");\n\n\tppname_n2  = __of_prop_dup(&pname_n2, GFP_KERNEL);\n\tunittest(ppname_n2, \"testcase setup failure\\n\");\n\n\tppname_n21 = __of_prop_dup(&pname_n21, GFP_KERNEL);\n\tunittest(ppname_n21, \"testcase setup failure\\n\");\n\n\tppupdate = __of_prop_dup(&pupdate, GFP_KERNEL);\n\tunittest(ppupdate, \"testcase setup failure\\n\");\n\n\tparent = nchangeset;\n\tn1->parent = parent;\n\tn2->parent = parent;\n\tn21->parent = n2;\n\n\tppremove = of_find_property(parent, \"prop-remove\", NULL);\n\tunittest(ppremove, \"failed to find removal prop\");\n\n\tof_changeset_init(&chgset);\n\n\tunittest(!of_changeset_attach_node(&chgset, n1), \"fail attach n1\\n\");\n\tunittest(!of_changeset_add_property(&chgset, n1, ppname_n1), \"fail add prop name\\n\");\n\n\tunittest(!of_changeset_attach_node(&chgset, n2), \"fail attach n2\\n\");\n\tunittest(!of_changeset_add_property(&chgset, n2, ppname_n2), \"fail add prop name\\n\");\n\n\tunittest(!of_changeset_detach_node(&chgset, nremove), \"fail remove node\\n\");\n\tunittest(!of_changeset_add_property(&chgset, n21, ppname_n21), \"fail add prop name\\n\");\n\n\tunittest(!of_changeset_attach_node(&chgset, n21), \"fail attach n21\\n\");\n\n\tunittest(!of_changeset_add_property(&chgset, parent, ppadd), \"fail add prop prop-add\\n\");\n\tunittest(!of_changeset_update_property(&chgset, parent, ppupdate), \"fail update prop\\n\");\n\tunittest(!of_changeset_remove_property(&chgset, parent, ppremove), \"fail remove prop\\n\");\n\tn22 = of_changeset_create_node(&chgset, n2, \"n22\");\n\tunittest(n22, \"fail create n22\\n\");\n\tunittest(!of_changeset_add_prop_string(&chgset, n22, \"prop-str\", \"abcd\"),\n\t\t \"fail add prop prop-str\");\n\tunittest(!of_changeset_add_prop_string_array(&chgset, n22, \"prop-str-array\",\n\t\t\t\t\t\t     (const char **)str_array,\n\t\t\t\t\t\t     ARRAY_SIZE(str_array)),\n\t\t \"fail add prop prop-str-array\");\n\tunittest(!of_changeset_add_prop_u32_array(&chgset, n22, \"prop-u32-array\",\n\t\t\t\t\t\t  u32_array, ARRAY_SIZE(u32_array)),\n\t\t \"fail add prop prop-u32-array\");\n\n\tunittest(!of_changeset_apply(&chgset), \"apply failed\\n\");\n\n\tof_node_put(nchangeset);\n\n\t \n\tunittest((np = of_find_node_by_path(\"/testcase-data/changeset/n2/n21\")),\n\t\t \"'%pOF' not added\\n\", n21);\n\tof_node_put(np);\n\tunittest((np = of_find_node_by_path(\"/testcase-data/changeset/n2/n22\")),\n\t\t \"'%pOF' not added\\n\", n22);\n\tof_node_put(np);\n\n\tunittest(!of_changeset_revert(&chgset), \"revert failed\\n\");\n\n\tunittest(!of_find_node_by_path(\"/testcase-data/changeset/n2/n21\"),\n\t\t \"'%pOF' still present after revert\\n\", n21);\n\n\tppremove = of_find_property(parent, \"prop-remove\", NULL);\n\tunittest(ppremove, \"failed to find removed prop after revert\\n\");\n\n\tret = of_property_read_string(parent, \"prop-update\", &propstr);\n\tunittest(!ret, \"failed to find updated prop after revert\\n\");\n\tif (!ret)\n\t\tunittest(strcmp(propstr, \"hello\") == 0, \"original value not in updated property after revert\");\n\n\tof_changeset_destroy(&chgset);\n\n\tof_node_put(n1);\n\tof_node_put(n2);\n\tof_node_put(n21);\n\tof_node_put(n22);\n#endif\n}\n\nstatic void __init of_unittest_dma_get_max_cpu_address(void)\n{\n\tstruct device_node *np;\n\tphys_addr_t cpu_addr;\n\n\tif (!IS_ENABLED(CONFIG_OF_ADDRESS))\n\t\treturn;\n\n\tnp = of_find_node_by_path(\"/testcase-data/address-tests\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tcpu_addr = of_dma_get_max_cpu_address(np);\n\tunittest(cpu_addr == 0x4fffffff,\n\t\t \"of_dma_get_max_cpu_address: wrong CPU addr %pad (expecting %x)\\n\",\n\t\t &cpu_addr, 0x4fffffff);\n}\n\nstatic void __init of_unittest_dma_ranges_one(const char *path,\n\t\tu64 expect_dma_addr, u64 expect_paddr)\n{\n#ifdef CONFIG_HAS_DMA\n\tstruct device_node *np;\n\tconst struct bus_dma_region *map = NULL;\n\tint rc;\n\n\tnp = of_find_node_by_path(path);\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\trc = of_dma_get_range(np, &map);\n\n\tunittest(!rc, \"of_dma_get_range failed on node %pOF rc=%i\\n\", np, rc);\n\n\tif (!rc) {\n\t\tphys_addr_t\tpaddr;\n\t\tdma_addr_t\tdma_addr;\n\t\tstruct device\t*dev_bogus;\n\n\t\tdev_bogus = kzalloc(sizeof(struct device), GFP_KERNEL);\n\t\tif (!dev_bogus) {\n\t\t\tunittest(0, \"kzalloc() failed\\n\");\n\t\t\tkfree(map);\n\t\t\treturn;\n\t\t}\n\n\t\tdev_bogus->dma_range_map = map;\n\t\tpaddr = dma_to_phys(dev_bogus, expect_dma_addr);\n\t\tdma_addr = phys_to_dma(dev_bogus, expect_paddr);\n\n\t\tunittest(paddr == expect_paddr,\n\t\t\t \"of_dma_get_range: wrong phys addr %pap (expecting %llx) on node %pOF\\n\",\n\t\t\t &paddr, expect_paddr, np);\n\t\tunittest(dma_addr == expect_dma_addr,\n\t\t\t \"of_dma_get_range: wrong DMA addr %pad (expecting %llx) on node %pOF\\n\",\n\t\t\t &dma_addr, expect_dma_addr, np);\n\n\t\tkfree(map);\n\t\tkfree(dev_bogus);\n\t}\n\tof_node_put(np);\n#endif\n}\n\nstatic void __init of_unittest_parse_dma_ranges(void)\n{\n\tof_unittest_dma_ranges_one(\"/testcase-data/address-tests/device@70000000\",\n\t\t0x0, 0x20000000);\n\tif (IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT))\n\t\tof_unittest_dma_ranges_one(\"/testcase-data/address-tests/bus@80000000/device@1000\",\n\t\t\t0x100000000, 0x20000000);\n\tof_unittest_dma_ranges_one(\"/testcase-data/address-tests/pci@90000000\",\n\t\t0x80000000, 0x20000000);\n}\n\nstatic void __init of_unittest_pci_dma_ranges(void)\n{\n\tstruct device_node *np;\n\tstruct of_pci_range range;\n\tstruct of_pci_range_parser parser;\n\tint i = 0;\n\n\tif (!IS_ENABLED(CONFIG_PCI))\n\t\treturn;\n\n\tnp = of_find_node_by_path(\"/testcase-data/address-tests/pci@90000000\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tif (of_pci_dma_range_parser_init(&parser, np)) {\n\t\tpr_err(\"missing dma-ranges property\\n\");\n\t\treturn;\n\t}\n\n\t \n\tfor_each_of_pci_range(&parser, &range) {\n\t\tif (!i) {\n\t\t\tunittest(range.size == 0x10000000,\n\t\t\t\t \"for_each_of_pci_range wrong size on node %pOF size=%llx\\n\",\n\t\t\t\t np, range.size);\n\t\t\tunittest(range.cpu_addr == 0x20000000,\n\t\t\t\t \"for_each_of_pci_range wrong CPU addr (%llx) on node %pOF\",\n\t\t\t\t range.cpu_addr, np);\n\t\t\tunittest(range.pci_addr == 0x80000000,\n\t\t\t\t \"for_each_of_pci_range wrong DMA addr (%llx) on node %pOF\",\n\t\t\t\t range.pci_addr, np);\n\t\t} else {\n\t\t\tunittest(range.size == 0x10000000,\n\t\t\t\t \"for_each_of_pci_range wrong size on node %pOF size=%llx\\n\",\n\t\t\t\t np, range.size);\n\t\t\tunittest(range.cpu_addr == 0x40000000,\n\t\t\t\t \"for_each_of_pci_range wrong CPU addr (%llx) on node %pOF\",\n\t\t\t\t range.cpu_addr, np);\n\t\t\tunittest(range.pci_addr == 0xc0000000,\n\t\t\t\t \"for_each_of_pci_range wrong DMA addr (%llx) on node %pOF\",\n\t\t\t\t range.pci_addr, np);\n\t\t}\n\t\ti++;\n\t}\n\n\tof_node_put(np);\n}\n\nstatic void __init of_unittest_bus_ranges(void)\n{\n\tstruct device_node *np;\n\tstruct of_range range;\n\tstruct of_range_parser parser;\n\tstruct resource res;\n\tint ret, count, i = 0;\n\n\tnp = of_find_node_by_path(\"/testcase-data/address-tests\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tif (of_range_parser_init(&parser, np)) {\n\t\tpr_err(\"missing ranges property\\n\");\n\t\treturn;\n\t}\n\n\tret = of_range_to_resource(np, 1, &res);\n\tunittest(!ret, \"of_range_to_resource returned error (%d) node %pOF\\n\",\n\t\tret, np);\n\tunittest(resource_type(&res) == IORESOURCE_MEM,\n\t\t\"of_range_to_resource wrong resource type on node %pOF res=%pR\\n\",\n\t\tnp, &res);\n\tunittest(res.start == 0xd0000000,\n\t\t\"of_range_to_resource wrong resource start address on node %pOF res=%pR\\n\",\n\t\tnp, &res);\n\tunittest(resource_size(&res) == 0x20000000,\n\t\t\"of_range_to_resource wrong resource start address on node %pOF res=%pR\\n\",\n\t\tnp, &res);\n\n\tcount = of_range_count(&parser);\n\tunittest(count == 2,\n\t\t\"of_range_count wrong size on node %pOF count=%d\\n\",\n\t\tnp, count);\n\n\t \n\tfor_each_of_range(&parser, &range) {\n\t\tunittest(range.flags == IORESOURCE_MEM,\n\t\t\t\"for_each_of_range wrong flags on node %pOF flags=%x (expected %x)\\n\",\n\t\t\tnp, range.flags, IORESOURCE_MEM);\n\t\tif (!i) {\n\t\t\tunittest(range.size == 0x50000000,\n\t\t\t\t \"for_each_of_range wrong size on node %pOF size=%llx\\n\",\n\t\t\t\t np, range.size);\n\t\t\tunittest(range.cpu_addr == 0x70000000,\n\t\t\t\t \"for_each_of_range wrong CPU addr (%llx) on node %pOF\",\n\t\t\t\t range.cpu_addr, np);\n\t\t\tunittest(range.bus_addr == 0x70000000,\n\t\t\t\t \"for_each_of_range wrong bus addr (%llx) on node %pOF\",\n\t\t\t\t range.pci_addr, np);\n\t\t} else {\n\t\t\tunittest(range.size == 0x20000000,\n\t\t\t\t \"for_each_of_range wrong size on node %pOF size=%llx\\n\",\n\t\t\t\t np, range.size);\n\t\t\tunittest(range.cpu_addr == 0xd0000000,\n\t\t\t\t \"for_each_of_range wrong CPU addr (%llx) on node %pOF\",\n\t\t\t\t range.cpu_addr, np);\n\t\t\tunittest(range.bus_addr == 0x00000000,\n\t\t\t\t \"for_each_of_range wrong bus addr (%llx) on node %pOF\",\n\t\t\t\t range.pci_addr, np);\n\t\t}\n\t\ti++;\n\t}\n\n\tof_node_put(np);\n}\n\nstatic void __init of_unittest_bus_3cell_ranges(void)\n{\n\tstruct device_node *np;\n\tstruct of_range range;\n\tstruct of_range_parser parser;\n\tint i = 0;\n\n\tnp = of_find_node_by_path(\"/testcase-data/address-tests/bus@a0000000\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tif (of_range_parser_init(&parser, np)) {\n\t\tpr_err(\"missing ranges property\\n\");\n\t\treturn;\n\t}\n\n\t \n\tfor_each_of_range(&parser, &range) {\n\t\tif (!i) {\n\t\t\tunittest(range.flags == 0xf00baa,\n\t\t\t\t \"for_each_of_range wrong flags on node %pOF flags=%x\\n\",\n\t\t\t\t np, range.flags);\n\t\t\tunittest(range.size == 0x100000,\n\t\t\t\t \"for_each_of_range wrong size on node %pOF size=%llx\\n\",\n\t\t\t\t np, range.size);\n\t\t\tunittest(range.cpu_addr == 0xa0000000,\n\t\t\t\t \"for_each_of_range wrong CPU addr (%llx) on node %pOF\",\n\t\t\t\t range.cpu_addr, np);\n\t\t\tunittest(range.bus_addr == 0x0,\n\t\t\t\t \"for_each_of_range wrong bus addr (%llx) on node %pOF\",\n\t\t\t\t range.pci_addr, np);\n\t\t} else {\n\t\t\tunittest(range.flags == 0xf00bee,\n\t\t\t\t \"for_each_of_range wrong flags on node %pOF flags=%x\\n\",\n\t\t\t\t np, range.flags);\n\t\t\tunittest(range.size == 0x200000,\n\t\t\t\t \"for_each_of_range wrong size on node %pOF size=%llx\\n\",\n\t\t\t\t np, range.size);\n\t\t\tunittest(range.cpu_addr == 0xb0000000,\n\t\t\t\t \"for_each_of_range wrong CPU addr (%llx) on node %pOF\",\n\t\t\t\t range.cpu_addr, np);\n\t\t\tunittest(range.bus_addr == 0x100000000,\n\t\t\t\t \"for_each_of_range wrong bus addr (%llx) on node %pOF\",\n\t\t\t\t range.pci_addr, np);\n\t\t}\n\t\ti++;\n\t}\n\n\tof_node_put(np);\n}\n\nstatic void __init of_unittest_reg(void)\n{\n\tstruct device_node *np;\n\tint ret;\n\tu64 addr, size;\n\n\tnp = of_find_node_by_path(\"/testcase-data/address-tests/bus@80000000/device@1000\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tret = of_property_read_reg(np, 0, &addr, &size);\n\tunittest(!ret, \"of_property_read_reg(%pOF) returned error %d\\n\",\n\t\tnp, ret);\n\tunittest(addr == 0x1000, \"of_property_read_reg(%pOF) untranslated address (%llx) incorrect\\n\",\n\t\tnp, addr);\n\n\tof_node_put(np);\n}\n\nstatic void __init of_unittest_parse_interrupts(void)\n{\n\tstruct device_node *np;\n\tstruct of_phandle_args args;\n\tint i, rc;\n\n\tif (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)\n\t\treturn;\n\n\tnp = of_find_node_by_path(\"/testcase-data/interrupts/interrupts0\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_irq_parse_one(np, i, &args);\n\n\t\tpassed &= !rc;\n\t\tpassed &= (args.args_count == 1);\n\t\tpassed &= (args.args[0] == (i + 1));\n\n\t\tunittest(passed, \"index %i - data error on node %pOF rc=%i\\n\",\n\t\t\t i, args.np, rc);\n\t}\n\tof_node_put(np);\n\n\tnp = of_find_node_by_path(\"/testcase-data/interrupts/interrupts1\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_irq_parse_one(np, i, &args);\n\n\t\t \n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 9);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 10);\n\t\t\tpassed &= (args.args[1] == 11);\n\t\t\tpassed &= (args.args[2] == 12);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 13);\n\t\t\tpassed &= (args.args[1] == 14);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 15);\n\t\t\tpassed &= (args.args[1] == 16);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpassed = false;\n\t\t}\n\t\tunittest(passed, \"index %i - data error on node %pOF rc=%i\\n\",\n\t\t\t i, args.np, rc);\n\t}\n\tof_node_put(np);\n}\n\nstatic void __init of_unittest_parse_interrupts_extended(void)\n{\n\tstruct device_node *np;\n\tstruct of_phandle_args args;\n\tint i, rc;\n\n\tif (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)\n\t\treturn;\n\n\tnp = of_find_node_by_path(\"/testcase-data/interrupts/interrupts-extended0\");\n\tif (!np) {\n\t\tpr_err(\"missing testcase data\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 7; i++) {\n\t\tbool passed = true;\n\n\t\tmemset(&args, 0, sizeof(args));\n\t\trc = of_irq_parse_one(np, i, &args);\n\n\t\t \n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 1);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 2);\n\t\t\tpassed &= (args.args[1] == 3);\n\t\t\tpassed &= (args.args[2] == 4);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 5);\n\t\t\tpassed &= (args.args[1] == 6);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 9);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 3);\n\t\t\tpassed &= (args.args[0] == 10);\n\t\t\tpassed &= (args.args[1] == 11);\n\t\t\tpassed &= (args.args[2] == 12);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 2);\n\t\t\tpassed &= (args.args[0] == 13);\n\t\t\tpassed &= (args.args[1] == 14);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t \n\t\t\tpassed &= !rc;\n\t\t\tpassed &= (args.args_count == 1);\n\t\t\tpassed &= (args.args[0] == 15);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpassed = false;\n\t\t}\n\n\t\tunittest(passed, \"index %i - data error on node %pOF rc=%i\\n\",\n\t\t\t i, args.np, rc);\n\t}\n\tof_node_put(np);\n}\n\nstatic const struct of_device_id match_node_table[] = {\n\t{ .data = \"A\", .name = \"name0\", },  \n\t{ .data = \"B\", .type = \"type1\", },  \n\n\t{ .data = \"Ca\", .name = \"name2\", .type = \"type1\", },  \n\t{ .data = \"Cb\", .name = \"name2\", },  \n\t{ .data = \"Cc\", .name = \"name2\", .type = \"type2\", },\n\n\t{ .data = \"E\", .compatible = \"compat3\" },\n\t{ .data = \"G\", .compatible = \"compat2\", },\n\t{ .data = \"H\", .compatible = \"compat2\", .name = \"name5\", },\n\t{ .data = \"I\", .compatible = \"compat2\", .type = \"type1\", },\n\t{ .data = \"J\", .compatible = \"compat2\", .type = \"type1\", .name = \"name8\", },\n\t{ .data = \"K\", .compatible = \"compat2\", .name = \"name9\", },\n\t{}\n};\n\nstatic struct {\n\tconst char *path;\n\tconst char *data;\n} match_node_tests[] = {\n\t{ .path = \"/testcase-data/match-node/name0\", .data = \"A\", },\n\t{ .path = \"/testcase-data/match-node/name1\", .data = \"B\", },\n\t{ .path = \"/testcase-data/match-node/a/name2\", .data = \"Ca\", },\n\t{ .path = \"/testcase-data/match-node/b/name2\", .data = \"Cb\", },\n\t{ .path = \"/testcase-data/match-node/c/name2\", .data = \"Cc\", },\n\t{ .path = \"/testcase-data/match-node/name3\", .data = \"E\", },\n\t{ .path = \"/testcase-data/match-node/name4\", .data = \"G\", },\n\t{ .path = \"/testcase-data/match-node/name5\", .data = \"H\", },\n\t{ .path = \"/testcase-data/match-node/name6\", .data = \"G\", },\n\t{ .path = \"/testcase-data/match-node/name7\", .data = \"I\", },\n\t{ .path = \"/testcase-data/match-node/name8\", .data = \"J\", },\n\t{ .path = \"/testcase-data/match-node/name9\", .data = \"K\", },\n};\n\nstatic void __init of_unittest_match_node(void)\n{\n\tstruct device_node *np;\n\tconst struct of_device_id *match;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(match_node_tests); i++) {\n\t\tnp = of_find_node_by_path(match_node_tests[i].path);\n\t\tif (!np) {\n\t\t\tunittest(0, \"missing testcase node %s\\n\",\n\t\t\t\tmatch_node_tests[i].path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = of_match_node(match_node_table, np);\n\t\tif (!match) {\n\t\t\tunittest(0, \"%s didn't match anything\\n\",\n\t\t\t\tmatch_node_tests[i].path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(match->data, match_node_tests[i].data) != 0) {\n\t\t\tunittest(0, \"%s got wrong match. expected %s, got %s\\n\",\n\t\t\t\tmatch_node_tests[i].path, match_node_tests[i].data,\n\t\t\t\t(const char *)match->data);\n\t\t\tcontinue;\n\t\t}\n\t\tunittest(1, \"passed\");\n\t}\n}\n\nstatic struct resource test_bus_res = DEFINE_RES_MEM(0xfffffff8, 2);\nstatic const struct platform_device_info test_bus_info = {\n\t.name = \"unittest-bus\",\n};\nstatic void __init of_unittest_platform_populate(void)\n{\n\tint irq, rc;\n\tstruct device_node *np, *child, *grandchild;\n\tstruct platform_device *pdev, *test_bus;\n\tconst struct of_device_id match[] = {\n\t\t{ .compatible = \"test-device\", },\n\t\t{}\n\t};\n\n\tnp = of_find_node_by_path(\"/testcase-data\");\n\tof_platform_default_populate(np, NULL, NULL);\n\n\t \n\tnp = of_find_node_by_path(\"/testcase-data/testcase-device1\");\n\tpdev = of_find_device_by_node(np);\n\tunittest(pdev, \"device 1 creation failed\\n\");\n\n\tif (!(of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)) {\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tunittest(irq == -EPROBE_DEFER,\n\t\t\t \"device deferred probe failed - %d\\n\", irq);\n\n\t\t \n\t\tnp = of_find_node_by_path(\"/testcase-data/testcase-device2\");\n\t\tpdev = of_find_device_by_node(np);\n\t\tunittest(pdev, \"device 2 creation failed\\n\");\n\n\t\tEXPECT_BEGIN(KERN_INFO,\n\t\t\t     \"platform testcase-data:testcase-device2: error -ENXIO: IRQ index 0 not found\");\n\n\t\tirq = platform_get_irq(pdev, 0);\n\n\t\tEXPECT_END(KERN_INFO,\n\t\t\t   \"platform testcase-data:testcase-device2: error -ENXIO: IRQ index 0 not found\");\n\n\t\tunittest(irq < 0 && irq != -EPROBE_DEFER,\n\t\t\t \"device parsing error failed - %d\\n\", irq);\n\t}\n\n\tnp = of_find_node_by_path(\"/testcase-data/platform-tests\");\n\tunittest(np, \"No testcase data in device tree\\n\");\n\tif (!np)\n\t\treturn;\n\n\ttest_bus = platform_device_register_full(&test_bus_info);\n\trc = PTR_ERR_OR_ZERO(test_bus);\n\tunittest(!rc, \"testbus registration failed; rc=%i\\n\", rc);\n\tif (rc) {\n\t\tof_node_put(np);\n\t\treturn;\n\t}\n\ttest_bus->dev.of_node = np;\n\n\t \n\tplatform_device_add_resources(test_bus, &test_bus_res, 1);\n\n\tof_platform_populate(np, match, NULL, &test_bus->dev);\n\tfor_each_child_of_node(np, child) {\n\t\tfor_each_child_of_node(child, grandchild) {\n\t\t\tpdev = of_find_device_by_node(grandchild);\n\t\t\tunittest(pdev,\n\t\t\t\t \"Could not create device for node '%pOFn'\\n\",\n\t\t\t\t grandchild);\n\t\t\tplatform_device_put(pdev);\n\t\t}\n\t}\n\n\tof_platform_depopulate(&test_bus->dev);\n\tfor_each_child_of_node(np, child) {\n\t\tfor_each_child_of_node(child, grandchild)\n\t\t\tunittest(!of_find_device_by_node(grandchild),\n\t\t\t\t \"device didn't get destroyed '%pOFn'\\n\",\n\t\t\t\t grandchild);\n\t}\n\n\tplatform_device_unregister(test_bus);\n\tof_node_put(np);\n}\n\n \nstatic void update_node_properties(struct device_node *np,\n\t\t\t\t\tstruct device_node *dup)\n{\n\tstruct property *prop;\n\tstruct property *save_next;\n\tstruct device_node *child;\n\tint ret;\n\n\tfor_each_child_of_node(np, child)\n\t\tchild->parent = dup;\n\n\t \n\n\t \n\tfor (prop = np->properties; prop != NULL; prop = save_next) {\n\t\tsave_next = prop->next;\n\t\tret = of_add_property(dup, prop);\n\t\tif (ret) {\n\t\t\tif (ret == -EEXIST && !strcmp(prop->name, \"name\"))\n\t\t\t\tcontinue;\n\t\t\tpr_err(\"unittest internal error: unable to add testdata property %pOF/%s\",\n\t\t\t       np, prop->name);\n\t\t}\n\t}\n}\n\n \nstatic void attach_node_and_children(struct device_node *np)\n{\n\tstruct device_node *next, *dup, *child;\n\tunsigned long flags;\n\tconst char *full_name;\n\n\tfull_name = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tif (!full_name)\n\t\treturn;\n\n\tif (!strcmp(full_name, \"/__local_fixups__\") ||\n\t    !strcmp(full_name, \"/__fixups__\")) {\n\t\tkfree(full_name);\n\t\treturn;\n\t}\n\n\tdup = of_find_node_by_path(full_name);\n\tkfree(full_name);\n\tif (dup) {\n\t\tupdate_node_properties(np, dup);\n\t\treturn;\n\t}\n\n\tchild = np->child;\n\tnp->child = NULL;\n\n\tmutex_lock(&of_mutex);\n\traw_spin_lock_irqsave(&devtree_lock, flags);\n\tnp->sibling = np->parent->child;\n\tnp->parent->child = np;\n\tof_node_clear_flag(np, OF_DETACHED);\n\traw_spin_unlock_irqrestore(&devtree_lock, flags);\n\n\t__of_attach_node_sysfs(np);\n\tmutex_unlock(&of_mutex);\n\n\twhile (child) {\n\t\tnext = child->sibling;\n\t\tattach_node_and_children(child);\n\t\tchild = next;\n\t}\n}\n\n \nstatic int __init unittest_data_add(void)\n{\n\tvoid *unittest_data;\n\tvoid *unittest_data_align;\n\tstruct device_node *unittest_data_node = NULL, *np;\n\t \n\textern uint8_t __dtbo_testcases_begin[];\n\textern uint8_t __dtbo_testcases_end[];\n\tconst int size = __dtbo_testcases_end - __dtbo_testcases_begin;\n\tint rc;\n\tvoid *ret;\n\n\tif (!size) {\n\t\tpr_warn(\"%s: testcases is empty\\n\", __func__);\n\t\treturn -ENODATA;\n\t}\n\n\t \n\tunittest_data = kmalloc(size + FDT_ALIGN_SIZE, GFP_KERNEL);\n\tif (!unittest_data)\n\t\treturn -ENOMEM;\n\n\tunittest_data_align = PTR_ALIGN(unittest_data, FDT_ALIGN_SIZE);\n\tmemcpy(unittest_data_align, __dtbo_testcases_begin, size);\n\n\tret = of_fdt_unflatten_tree(unittest_data_align, NULL, &unittest_data_node);\n\tif (!ret) {\n\t\tpr_warn(\"%s: unflatten testcases tree failed\\n\", __func__);\n\t\tkfree(unittest_data);\n\t\treturn -ENODATA;\n\t}\n\tif (!unittest_data_node) {\n\t\tpr_warn(\"%s: testcases tree is empty\\n\", __func__);\n\t\tkfree(unittest_data);\n\t\treturn -ENODATA;\n\t}\n\n\t \n\tof_overlay_mutex_lock();\n\n\trc = of_resolve_phandles(unittest_data_node);\n\tif (rc) {\n\t\tpr_err(\"%s: Failed to resolve phandles (rc=%i)\\n\", __func__, rc);\n\t\tof_overlay_mutex_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tif (!of_root) {\n\t\tof_root = unittest_data_node;\n\t\tfor_each_of_allnodes(np)\n\t\t\t__of_attach_node_sysfs(np);\n\t\tof_aliases = of_find_node_by_path(\"/aliases\");\n\t\tof_chosen = of_find_node_by_path(\"/chosen\");\n\t\tof_overlay_mutex_unlock();\n\t\treturn 0;\n\t}\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"Duplicate name in testcase-data, renamed to \\\"duplicate-name#1\\\"\");\n\n\t \n\tnp = unittest_data_node->child;\n\twhile (np) {\n\t\tstruct device_node *next = np->sibling;\n\n\t\tnp->parent = of_root;\n\t\t \n\t\tattach_node_and_children(np);\n\t\tnp = next;\n\t}\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"Duplicate name in testcase-data, renamed to \\\"duplicate-name#1\\\"\");\n\n\tof_overlay_mutex_unlock();\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF_OVERLAY\nstatic int __init overlay_data_apply(const char *overlay_name, int *ovcs_id);\n\nstatic int unittest_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\n\tif (np == NULL) {\n\t\tdev_err(dev, \"No OF data for device\\n\");\n\t\treturn -EINVAL;\n\n\t}\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\n\tof_platform_populate(np, NULL, NULL, &pdev->dev);\n\n\treturn 0;\n}\n\nstatic void unittest_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n}\n\nstatic const struct of_device_id unittest_match[] = {\n\t{ .compatible = \"unittest\", },\n\t{},\n};\n\nstatic struct platform_driver unittest_driver = {\n\t.probe\t\t\t= unittest_probe,\n\t.remove_new\t\t= unittest_remove,\n\t.driver = {\n\t\t.name\t\t= \"unittest\",\n\t\t.of_match_table\t= unittest_match,\n\t},\n};\n\n \nstatic struct platform_device *of_path_to_platform_device(const char *path)\n{\n\tstruct device_node *np;\n\tstruct platform_device *pdev;\n\n\tnp = of_find_node_by_path(path);\n\tif (np == NULL)\n\t\treturn NULL;\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\n\treturn pdev;\n}\n\n \nstatic int of_path_platform_device_exists(const char *path)\n{\n\tstruct platform_device *pdev;\n\n\tpdev = of_path_to_platform_device(path);\n\tplatform_device_put(pdev);\n\treturn pdev != NULL;\n}\n\n#ifdef CONFIG_OF_GPIO\n\nstruct unittest_gpio_dev {\n\tstruct gpio_chip chip;\n};\n\nstatic int unittest_gpio_chip_request_count;\nstatic int unittest_gpio_probe_count;\nstatic int unittest_gpio_probe_pass_count;\n\nstatic int unittest_gpio_chip_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tunittest_gpio_chip_request_count++;\n\n\tpr_debug(\"%s(): %s %d %d\\n\", __func__, chip->label, offset,\n\t\t unittest_gpio_chip_request_count);\n\treturn 0;\n}\n\nstatic int unittest_gpio_probe(struct platform_device *pdev)\n{\n\tstruct unittest_gpio_dev *devptr;\n\tint ret;\n\n\tunittest_gpio_probe_count++;\n\n\tdevptr = kzalloc(sizeof(*devptr), GFP_KERNEL);\n\tif (!devptr)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, devptr);\n\n\tdevptr->chip.fwnode = dev_fwnode(&pdev->dev);\n\tdevptr->chip.label = \"of-unittest-gpio\";\n\tdevptr->chip.base = -1;  \n\tdevptr->chip.ngpio = 5;\n\tdevptr->chip.request = unittest_gpio_chip_request;\n\n\tret = gpiochip_add_data(&devptr->chip, NULL);\n\n\tunittest(!ret,\n\t\t \"gpiochip_add_data() for node @%pfw failed, ret = %d\\n\", devptr->chip.fwnode, ret);\n\n\tif (!ret)\n\t\tunittest_gpio_probe_pass_count++;\n\treturn ret;\n}\n\nstatic void unittest_gpio_remove(struct platform_device *pdev)\n{\n\tstruct unittest_gpio_dev *devptr = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\tdev_dbg(dev, \"%s for node @%pfw\\n\", __func__, devptr->chip.fwnode);\n\n\tif (devptr->chip.base != -1)\n\t\tgpiochip_remove(&devptr->chip);\n\n\tkfree(devptr);\n}\n\nstatic const struct of_device_id unittest_gpio_id[] = {\n\t{ .compatible = \"unittest-gpio\", },\n\t{}\n};\n\nstatic struct platform_driver unittest_gpio_driver = {\n\t.probe\t= unittest_gpio_probe,\n\t.remove_new = unittest_gpio_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"unittest-gpio\",\n\t\t.of_match_table\t= unittest_gpio_id,\n\t},\n};\n\nstatic void __init of_unittest_overlay_gpio(void)\n{\n\tint chip_request_count;\n\tint probe_pass_count;\n\tint ret;\n\n\t \n\n\tprobe_pass_count = unittest_gpio_probe_pass_count;\n\tchip_request_count = unittest_gpio_chip_request_count;\n\n\t \n\n\tunittest(overlay_data_apply(\"overlay_gpio_01\", NULL),\n\t\t \"Adding overlay 'overlay_gpio_01' failed\\n\");\n\n\tunittest(overlay_data_apply(\"overlay_gpio_02a\", NULL),\n\t\t \"Adding overlay 'overlay_gpio_02a' failed\\n\");\n\n\tunittest(overlay_data_apply(\"overlay_gpio_02b\", NULL),\n\t\t \"Adding overlay 'overlay_gpio_02b' failed\\n\");\n\n\tret = platform_driver_register(&unittest_gpio_driver);\n\tif (unittest(ret == 0, \"could not register unittest gpio driver\\n\"))\n\t\treturn;\n\n\tunittest(probe_pass_count + 2 == unittest_gpio_probe_pass_count,\n\t\t \"unittest_gpio_probe() failed or not called\\n\");\n\n\tunittest(chip_request_count + 2 == unittest_gpio_chip_request_count,\n\t\t \"unittest_gpio_chip_request() called %d times (expected 1 time)\\n\",\n\t\t unittest_gpio_chip_request_count - chip_request_count);\n\n\t \n\n\tprobe_pass_count = unittest_gpio_probe_pass_count;\n\tchip_request_count = unittest_gpio_chip_request_count;\n\n\t \n\n\tunittest(overlay_data_apply(\"overlay_gpio_03\", NULL),\n\t\t \"Adding overlay 'overlay_gpio_03' failed\\n\");\n\n\tunittest(probe_pass_count + 1 == unittest_gpio_probe_pass_count,\n\t\t \"unittest_gpio_probe() failed or not called\\n\");\n\n\tunittest(chip_request_count + 1 == unittest_gpio_chip_request_count,\n\t\t \"unittest_gpio_chip_request() called %d times (expected 1 time)\\n\",\n\t\t unittest_gpio_chip_request_count - chip_request_count);\n\n\t \n\n\tprobe_pass_count = unittest_gpio_probe_pass_count;\n\tchip_request_count = unittest_gpio_chip_request_count;\n\n\t \n\n\tunittest(overlay_data_apply(\"overlay_gpio_04a\", NULL),\n\t\t \"Adding overlay 'overlay_gpio_04a' failed\\n\");\n\n\tunittest(probe_pass_count + 1 == unittest_gpio_probe_pass_count,\n\t\t \"unittest_gpio_probe() failed or not called\\n\");\n\n\t \n\n\t \n\n\tunittest(overlay_data_apply(\"overlay_gpio_04b\", NULL),\n\t\t \"Adding overlay 'overlay_gpio_04b' failed\\n\");\n\n\tunittest(chip_request_count + 1 == unittest_gpio_chip_request_count,\n\t\t \"unittest_gpio_chip_request() called %d times (expected 1 time)\\n\",\n\t\t unittest_gpio_chip_request_count - chip_request_count);\n}\n\n#else\n\nstatic void __init of_unittest_overlay_gpio(void)\n{\n\t \n}\n\n#endif\n\n#if IS_BUILTIN(CONFIG_I2C)\n\n \nstatic struct i2c_client *of_path_to_i2c_client(const char *path)\n{\n\tstruct device_node *np;\n\tstruct i2c_client *client;\n\n\tnp = of_find_node_by_path(path);\n\tif (np == NULL)\n\t\treturn NULL;\n\n\tclient = of_find_i2c_device_by_node(np);\n\tof_node_put(np);\n\n\treturn client;\n}\n\n \nstatic int of_path_i2c_client_exists(const char *path)\n{\n\tstruct i2c_client *client;\n\n\tclient = of_path_to_i2c_client(path);\n\tif (client)\n\t\tput_device(&client->dev);\n\treturn client != NULL;\n}\n#else\nstatic int of_path_i2c_client_exists(const char *path)\n{\n\treturn 0;\n}\n#endif\n\nenum overlay_type {\n\tPDEV_OVERLAY,\n\tI2C_OVERLAY\n};\n\nstatic int of_path_device_type_exists(const char *path,\n\t\tenum overlay_type ovtype)\n{\n\tswitch (ovtype) {\n\tcase PDEV_OVERLAY:\n\t\treturn of_path_platform_device_exists(path);\n\tcase I2C_OVERLAY:\n\t\treturn of_path_i2c_client_exists(path);\n\t}\n\treturn 0;\n}\n\nstatic const char *unittest_path(int nr, enum overlay_type ovtype)\n{\n\tconst char *base;\n\tstatic char buf[256];\n\n\tswitch (ovtype) {\n\tcase PDEV_OVERLAY:\n\t\tbase = \"/testcase-data/overlay-node/test-bus\";\n\t\tbreak;\n\tcase I2C_OVERLAY:\n\t\tbase = \"/testcase-data/overlay-node/test-bus/i2c-test-bus\";\n\t\tbreak;\n\tdefault:\n\t\tbuf[0] = '\\0';\n\t\treturn buf;\n\t}\n\tsnprintf(buf, sizeof(buf) - 1, \"%s/test-unittest%d\", base, nr);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\treturn buf;\n}\n\nstatic int of_unittest_device_exists(int unittest_nr, enum overlay_type ovtype)\n{\n\tconst char *path;\n\n\tpath = unittest_path(unittest_nr, ovtype);\n\n\tswitch (ovtype) {\n\tcase PDEV_OVERLAY:\n\t\treturn of_path_platform_device_exists(path);\n\tcase I2C_OVERLAY:\n\t\treturn of_path_i2c_client_exists(path);\n\t}\n\treturn 0;\n}\n\nstatic const char *overlay_name_from_nr(int nr)\n{\n\tstatic char buf[256];\n\n\tsnprintf(buf, sizeof(buf) - 1,\n\t\t\"overlay_%d\", nr);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\n\treturn buf;\n}\n\nstatic const char *bus_path = \"/testcase-data/overlay-node/test-bus\";\n\n#define MAX_TRACK_OVCS_IDS 256\n\nstatic int track_ovcs_id[MAX_TRACK_OVCS_IDS];\nstatic int track_ovcs_id_overlay_nr[MAX_TRACK_OVCS_IDS];\nstatic int track_ovcs_id_cnt;\n\nstatic void of_unittest_track_overlay(int ovcs_id, int overlay_nr)\n{\n\tif (WARN_ON(track_ovcs_id_cnt >= MAX_TRACK_OVCS_IDS))\n\t\treturn;\n\n\ttrack_ovcs_id[track_ovcs_id_cnt] = ovcs_id;\n\ttrack_ovcs_id_overlay_nr[track_ovcs_id_cnt] = overlay_nr;\n\ttrack_ovcs_id_cnt++;\n}\n\nstatic void of_unittest_untrack_overlay(int ovcs_id)\n{\n\tif (WARN_ON(track_ovcs_id_cnt < 1))\n\t\treturn;\n\n\ttrack_ovcs_id_cnt--;\n\n\t \n\tWARN_ON(track_ovcs_id[track_ovcs_id_cnt] != ovcs_id);\n}\n\nstatic void of_unittest_remove_tracked_overlays(void)\n{\n\tint ret, ovcs_id, overlay_nr, save_ovcs_id;\n\tconst char *overlay_name;\n\n\twhile (track_ovcs_id_cnt > 0) {\n\n\t\tovcs_id = track_ovcs_id[track_ovcs_id_cnt - 1];\n\t\toverlay_nr = track_ovcs_id_overlay_nr[track_ovcs_id_cnt - 1];\n\t\tsave_ovcs_id = ovcs_id;\n\t\tret = of_overlay_remove(&ovcs_id);\n\t\tif (ret == -ENODEV) {\n\t\t\toverlay_name = overlay_name_from_nr(overlay_nr);\n\t\t\tpr_warn(\"%s: of_overlay_remove() for overlay \\\"%s\\\" failed, ret = %d\\n\",\n\t\t\t\t__func__, overlay_name, ret);\n\t\t}\n\t\tof_unittest_untrack_overlay(save_ovcs_id);\n\t}\n\n}\n\nstatic int __init of_unittest_apply_overlay(int overlay_nr, int *ovcs_id)\n{\n\t \n\n\tconst char *overlay_name;\n\n\toverlay_name = overlay_name_from_nr(overlay_nr);\n\n\tif (!overlay_data_apply(overlay_name, ovcs_id)) {\n\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\", overlay_name);\n\t\treturn -EFAULT;\n\t}\n\tof_unittest_track_overlay(*ovcs_id, overlay_nr);\n\n\treturn 0;\n}\n\nstatic int __init __of_unittest_apply_overlay_check(int overlay_nr,\n\t\tint unittest_nr, int before, int after,\n\t\tenum overlay_type ovtype)\n{\n\tint ret, ovcs_id;\n\n\t \n\tif (of_unittest_device_exists(unittest_nr, ovtype) != before) {\n\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tovcs_id = 0;\n\tret = of_unittest_apply_overlay(overlay_nr, &ovcs_id);\n\tif (ret != 0) {\n\t\t \n\t\treturn ret;\n\t}\n\n\t \n\tif (of_unittest_device_exists(unittest_nr, ovtype) != after) {\n\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!after ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ovcs_id;\n}\n\n \nstatic int __init of_unittest_apply_overlay_check(int overlay_nr,\n\t\tint unittest_nr, int before, int after,\n\t\tenum overlay_type ovtype)\n{\n\tint ovcs_id = __of_unittest_apply_overlay_check(overlay_nr,\n\t\t\t\tunittest_nr, before, after, ovtype);\n\tif (ovcs_id < 0)\n\t\treturn ovcs_id;\n\n\treturn 0;\n}\n\n \nstatic int __init of_unittest_apply_revert_overlay_check(int overlay_nr,\n\t\tint unittest_nr, int before, int after,\n\t\tenum overlay_type ovtype)\n{\n\tint ret, ovcs_id, save_ovcs_id;\n\n\tovcs_id = __of_unittest_apply_overlay_check(overlay_nr, unittest_nr,\n\t\t\t\t\t\t    before, after, ovtype);\n\tif (ovcs_id < 0)\n\t\treturn ovcs_id;\n\n\t \n\tsave_ovcs_id = ovcs_id;\n\tret = of_overlay_remove(&ovcs_id);\n\tif (ret != 0) {\n\t\tunittest(0, \"%s failed to be destroyed @\\\"%s\\\"\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype));\n\t\treturn ret;\n\t}\n\tof_unittest_untrack_overlay(save_ovcs_id);\n\n\t \n\tif (of_unittest_device_exists(unittest_nr, ovtype) != before) {\n\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr),\n\t\t\t\tunittest_path(unittest_nr, ovtype),\n\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __init of_unittest_overlay_0(void)\n{\n\tint ret;\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest0/status\");\n\n\t \n\tret = of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest0/status\");\n\n\tif (ret)\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 0);\n}\n\n \nstatic void __init of_unittest_overlay_1(void)\n{\n\tint ret;\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest1/status\");\n\n\t \n\tret = of_unittest_apply_overlay_check(1, 1, 1, 0, PDEV_OVERLAY);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest1/status\");\n\n\tif (ret)\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 1);\n\n}\n\n \nstatic void __init of_unittest_overlay_2(void)\n{\n\tint ret;\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest2/status\");\n\n\t \n\tret = of_unittest_apply_overlay_check(2, 2, 0, 1, PDEV_OVERLAY);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest2/status\");\n\n\tif (ret)\n\t\treturn;\n\tunittest(1, \"overlay test %d passed\\n\", 2);\n}\n\n \nstatic void __init of_unittest_overlay_3(void)\n{\n\tint ret;\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest3/status\");\n\n\t \n\tret = of_unittest_apply_overlay_check(3, 3, 1, 0, PDEV_OVERLAY);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest3/status\");\n\n\tif (ret)\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 3);\n}\n\n \nstatic void __init of_unittest_overlay_4(void)\n{\n\t \n\tif (of_unittest_apply_overlay_check(4, 4, 0, 1, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 4);\n}\n\n \nstatic void __init of_unittest_overlay_5(void)\n{\n\tint ret;\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest5/status\");\n\n\t \n\tret = of_unittest_apply_revert_overlay_check(5, 5, 0, 1, PDEV_OVERLAY);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest5/status\");\n\n\tif (ret)\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 5);\n}\n\n \nstatic void __init of_unittest_overlay_6(void)\n{\n\tint i, save_ovcs_id[2], ovcs_id;\n\tint overlay_nr = 6, unittest_nr = 6;\n\tint before = 0, after = 1;\n\tconst char *overlay_name;\n\n\tint ret;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tif (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)\n\t\t\t\t!= before) {\n\t\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr + i,\n\t\t\t\t\t\tPDEV_OVERLAY),\n\t\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest6/status\");\n\n\toverlay_name = overlay_name_from_nr(overlay_nr + 0);\n\n\tret = overlay_data_apply(overlay_name, &ovcs_id);\n\n\tif (!ret) {\n\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\", overlay_name);\n\t\t\treturn;\n\t}\n\tsave_ovcs_id[0] = ovcs_id;\n\tof_unittest_track_overlay(ovcs_id, overlay_nr + 0);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest6/status\");\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest7/status\");\n\n\toverlay_name = overlay_name_from_nr(overlay_nr + 1);\n\n\tret = overlay_data_apply(overlay_name, &ovcs_id);\n\n\tif (!ret) {\n\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\", overlay_name);\n\t\t\treturn;\n\t}\n\tsave_ovcs_id[1] = ovcs_id;\n\tof_unittest_track_overlay(ovcs_id, overlay_nr + 1);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest7/status\");\n\n\n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\tif (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)\n\t\t\t\t!= after) {\n\t\t\tunittest(0, \"overlay @\\\"%s\\\" failed @\\\"%s\\\" %s\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr + i,\n\t\t\t\t\t\tPDEV_OVERLAY),\n\t\t\t\t\t!after ? \"enabled\" : \"disabled\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (i = 1; i >= 0; i--) {\n\t\tovcs_id = save_ovcs_id[i];\n\t\tif (of_overlay_remove(&ovcs_id)) {\n\t\t\tunittest(0, \"%s failed destroy @\\\"%s\\\"\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr + i,\n\t\t\t\t\t\tPDEV_OVERLAY));\n\t\t\treturn;\n\t\t}\n\t\tof_unittest_untrack_overlay(save_ovcs_id[i]);\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\tif (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)\n\t\t\t\t!= before) {\n\t\t\tunittest(0, \"%s with device @\\\"%s\\\" %s\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr + i,\n\t\t\t\t\t\tPDEV_OVERLAY),\n\t\t\t\t\t!before ? \"enabled\" : \"disabled\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tunittest(1, \"overlay test %d passed\\n\", 6);\n\n}\n\n \nstatic void __init of_unittest_overlay_8(void)\n{\n\tint i, save_ovcs_id[2], ovcs_id;\n\tint overlay_nr = 8, unittest_nr = 8;\n\tconst char *overlay_name;\n\tint ret;\n\n\t \n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest8/status\");\n\n\toverlay_name = overlay_name_from_nr(overlay_nr + 0);\n\n\tret = overlay_data_apply(overlay_name, &ovcs_id);\n\tif (!ret)\n\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\", overlay_name);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest8/status\");\n\n\tif (!ret)\n\t\treturn;\n\n\tsave_ovcs_id[0] = ovcs_id;\n\tof_unittest_track_overlay(ovcs_id, overlay_nr + 0);\n\n\toverlay_name = overlay_name_from_nr(overlay_nr + 1);\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest8/property-foo\");\n\n\t \n\tret = overlay_data_apply(overlay_name, &ovcs_id);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest8/property-foo\");\n\n\tif (!ret) {\n\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\", overlay_name);\n\t\treturn;\n\t}\n\n\tsave_ovcs_id[1] = ovcs_id;\n\tof_unittest_track_overlay(ovcs_id, overlay_nr + 1);\n\n\t \n\tovcs_id = save_ovcs_id[0];\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: node_overlaps_later_cs: #6 overlaps with #7 @/testcase-data/overlay-node/test-bus/test-unittest8\");\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: overlay #6 is not topmost\");\n\n\tret = of_overlay_remove(&ovcs_id);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: overlay #6 is not topmost\");\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: node_overlaps_later_cs: #6 overlaps with #7 @/testcase-data/overlay-node/test-bus/test-unittest8\");\n\n\tif (!ret) {\n\t\t \n\t\tunittest(0, \"%s was destroyed @\\\"%s\\\"\\n\",\n\t\t\t\toverlay_name_from_nr(overlay_nr + 0),\n\t\t\t\tunittest_path(unittest_nr,\n\t\t\t\t\tPDEV_OVERLAY));\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 1; i >= 0; i--) {\n\t\tovcs_id = save_ovcs_id[i];\n\t\tif (of_overlay_remove(&ovcs_id)) {\n\t\t\tunittest(0, \"%s not destroyed @\\\"%s\\\"\\n\",\n\t\t\t\t\toverlay_name_from_nr(overlay_nr + i),\n\t\t\t\t\tunittest_path(unittest_nr,\n\t\t\t\t\t\tPDEV_OVERLAY));\n\t\t\treturn;\n\t\t}\n\t\tof_unittest_untrack_overlay(save_ovcs_id[i]);\n\t}\n\n\tunittest(1, \"overlay test %d passed\\n\", 8);\n}\n\n \nstatic void __init of_unittest_overlay_10(void)\n{\n\tint ret;\n\tchar *child_path;\n\n\t \n\tret = of_unittest_apply_overlay_check(10, 10, 0, 1, PDEV_OVERLAY);\n\n\tif (unittest(ret == 0,\n\t\t\t\"overlay test %d failed; overlay application\\n\", 10))\n\t\treturn;\n\n\tchild_path = kasprintf(GFP_KERNEL, \"%s/test-unittest101\",\n\t\t\tunittest_path(10, PDEV_OVERLAY));\n\tif (unittest(child_path, \"overlay test %d failed; kasprintf\\n\", 10))\n\t\treturn;\n\n\tret = of_path_device_type_exists(child_path, PDEV_OVERLAY);\n\tkfree(child_path);\n\n\tunittest(ret, \"overlay test %d failed; no child device\\n\", 10);\n}\n\n \nstatic void __init of_unittest_overlay_11(void)\n{\n\tint ret;\n\n\t \n\tret = of_unittest_apply_revert_overlay_check(11, 11, 0, 1,\n\t\t\tPDEV_OVERLAY);\n\n\tunittest(ret == 0, \"overlay test %d failed; overlay apply\\n\", 11);\n}\n\n#if IS_BUILTIN(CONFIG_I2C) && IS_ENABLED(CONFIG_OF_OVERLAY)\n\nstruct unittest_i2c_bus_data {\n\tstruct platform_device\t*pdev;\n\tstruct i2c_adapter\tadap;\n};\n\nstatic int unittest_i2c_master_xfer(struct i2c_adapter *adap,\n\t\tstruct i2c_msg *msgs, int num)\n{\n\tstruct unittest_i2c_bus_data *std = i2c_get_adapdata(adap);\n\n\t(void)std;\n\n\treturn num;\n}\n\nstatic u32 unittest_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm unittest_i2c_algo = {\n\t.master_xfer\t= unittest_i2c_master_xfer,\n\t.functionality\t= unittest_i2c_functionality,\n};\n\nstatic int unittest_i2c_bus_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct unittest_i2c_bus_data *std;\n\tstruct i2c_adapter *adap;\n\tint ret;\n\n\tif (np == NULL) {\n\t\tdev_err(dev, \"No OF data for device\\n\");\n\t\treturn -EINVAL;\n\n\t}\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\n\tstd = devm_kzalloc(dev, sizeof(*std), GFP_KERNEL);\n\tif (!std)\n\t\treturn -ENOMEM;\n\n\t \n\tstd->pdev = pdev;\n\tplatform_set_drvdata(pdev, std);\n\n\tadap = &std->adap;\n\ti2c_set_adapdata(adap, std);\n\tadap->nr = -1;\n\tstrscpy(adap->name, pdev->name, sizeof(adap->name));\n\tadap->class = I2C_CLASS_DEPRECATED;\n\tadap->algo = &unittest_i2c_algo;\n\tadap->dev.parent = dev;\n\tadap->dev.of_node = dev->of_node;\n\tadap->timeout = 5 * HZ;\n\tadap->retries = 3;\n\n\tret = i2c_add_numbered_adapter(adap);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to add I2C adapter\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void unittest_i2c_bus_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct unittest_i2c_bus_data *std = platform_get_drvdata(pdev);\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\ti2c_del_adapter(&std->adap);\n}\n\nstatic const struct of_device_id unittest_i2c_bus_match[] = {\n\t{ .compatible = \"unittest-i2c-bus\", },\n\t{},\n};\n\nstatic struct platform_driver unittest_i2c_bus_driver = {\n\t.probe\t\t\t= unittest_i2c_bus_probe,\n\t.remove_new\t\t= unittest_i2c_bus_remove,\n\t.driver = {\n\t\t.name\t\t= \"unittest-i2c-bus\",\n\t\t.of_match_table\t= unittest_i2c_bus_match,\n\t},\n};\n\nstatic int unittest_i2c_dev_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = client->dev.of_node;\n\n\tif (!np) {\n\t\tdev_err(dev, \"No OF node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\n\treturn 0;\n};\n\nstatic void unittest_i2c_dev_remove(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = client->dev.of_node;\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n}\n\nstatic const struct i2c_device_id unittest_i2c_dev_id[] = {\n\t{ .name = \"unittest-i2c-dev\" },\n\t{ }\n};\n\nstatic struct i2c_driver unittest_i2c_dev_driver = {\n\t.driver = {\n\t\t.name = \"unittest-i2c-dev\",\n\t},\n\t.probe = unittest_i2c_dev_probe,\n\t.remove = unittest_i2c_dev_remove,\n\t.id_table = unittest_i2c_dev_id,\n};\n\n#if IS_BUILTIN(CONFIG_I2C_MUX)\n\nstatic int unittest_i2c_mux_select_chan(struct i2c_mux_core *muxc, u32 chan)\n{\n\treturn 0;\n}\n\nstatic int unittest_i2c_mux_probe(struct i2c_client *client)\n{\n\tint i, nchans;\n\tstruct device *dev = &client->dev;\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct device_node *np = client->dev.of_node, *child;\n\tstruct i2c_mux_core *muxc;\n\tu32 reg, max_reg;\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\n\tif (!np) {\n\t\tdev_err(dev, \"No OF node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmax_reg = (u32)-1;\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_property_read_u32(child, \"reg\", &reg))\n\t\t\tcontinue;\n\t\tif (max_reg == (u32)-1 || reg > max_reg)\n\t\t\tmax_reg = reg;\n\t}\n\tnchans = max_reg == (u32)-1 ? 0 : max_reg + 1;\n\tif (nchans == 0) {\n\t\tdev_err(dev, \"No channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmuxc = i2c_mux_alloc(adap, dev, nchans, 0, 0,\n\t\t\t     unittest_i2c_mux_select_chan, NULL);\n\tif (!muxc)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < nchans; i++) {\n\t\tif (i2c_mux_add_adapter(muxc, 0, i, 0)) {\n\t\t\tdev_err(dev, \"Failed to register mux #%d\\n\", i);\n\t\t\ti2c_mux_del_adapters(muxc);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\ti2c_set_clientdata(client, muxc);\n\n\treturn 0;\n};\n\nstatic void unittest_i2c_mux_remove(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = client->dev.of_node;\n\tstruct i2c_mux_core *muxc = i2c_get_clientdata(client);\n\n\tdev_dbg(dev, \"%s for node @%pOF\\n\", __func__, np);\n\ti2c_mux_del_adapters(muxc);\n}\n\nstatic const struct i2c_device_id unittest_i2c_mux_id[] = {\n\t{ .name = \"unittest-i2c-mux\" },\n\t{ }\n};\n\nstatic struct i2c_driver unittest_i2c_mux_driver = {\n\t.driver = {\n\t\t.name = \"unittest-i2c-mux\",\n\t},\n\t.probe = unittest_i2c_mux_probe,\n\t.remove = unittest_i2c_mux_remove,\n\t.id_table = unittest_i2c_mux_id,\n};\n\n#endif\n\nstatic int of_unittest_overlay_i2c_init(void)\n{\n\tint ret;\n\n\tret = i2c_add_driver(&unittest_i2c_dev_driver);\n\tif (unittest(ret == 0,\n\t\t\t\"could not register unittest i2c device driver\\n\"))\n\t\treturn ret;\n\n\tret = platform_driver_register(&unittest_i2c_bus_driver);\n\n\tif (unittest(ret == 0,\n\t\t\t\"could not register unittest i2c bus driver\\n\"))\n\t\treturn ret;\n\n#if IS_BUILTIN(CONFIG_I2C_MUX)\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"i2c i2c-1: Added multiplexed i2c bus 2\");\n\n\tret = i2c_add_driver(&unittest_i2c_mux_driver);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"i2c i2c-1: Added multiplexed i2c bus 2\");\n\n\tif (unittest(ret == 0,\n\t\t\t\"could not register unittest i2c mux driver\\n\"))\n\t\treturn ret;\n#endif\n\n\treturn 0;\n}\n\nstatic void of_unittest_overlay_i2c_cleanup(void)\n{\n#if IS_BUILTIN(CONFIG_I2C_MUX)\n\ti2c_del_driver(&unittest_i2c_mux_driver);\n#endif\n\tplatform_driver_unregister(&unittest_i2c_bus_driver);\n\ti2c_del_driver(&unittest_i2c_dev_driver);\n}\n\nstatic void __init of_unittest_overlay_i2c_12(void)\n{\n\tint ret;\n\n\t \n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/i2c-test-bus/test-unittest12/status\");\n\n\tret = of_unittest_apply_overlay_check(12, 12, 0, 1, I2C_OVERLAY);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/i2c-test-bus/test-unittest12/status\");\n\n\tif (ret)\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 12);\n}\n\n \nstatic void __init of_unittest_overlay_i2c_13(void)\n{\n\tint ret;\n\n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/i2c-test-bus/test-unittest13/status\");\n\n\t \n\tret = of_unittest_apply_overlay_check(13, 13, 1, 0, I2C_OVERLAY);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/i2c-test-bus/test-unittest13/status\");\n\n\tif (ret)\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 13);\n}\n\n \nstatic void of_unittest_overlay_i2c_14(void)\n{\n}\n\nstatic void __init of_unittest_overlay_i2c_15(void)\n{\n\tint ret;\n\n\t \n\tEXPECT_BEGIN(KERN_INFO,\n\t\t     \"i2c i2c-1: Added multiplexed i2c bus 3\");\n\n\tret = of_unittest_apply_overlay_check(15, 15, 0, 1, I2C_OVERLAY);\n\n\tEXPECT_END(KERN_INFO,\n\t\t   \"i2c i2c-1: Added multiplexed i2c bus 3\");\n\n\tif (ret)\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 15);\n}\n\n#else\n\nstatic inline void of_unittest_overlay_i2c_14(void) { }\nstatic inline void of_unittest_overlay_i2c_15(void) { }\n\n#endif\n\nstatic int of_notify(struct notifier_block *nb, unsigned long action,\n\t\t     void *arg)\n{\n\tstruct of_overlay_notify_data *nd = arg;\n\tstruct device_node *found;\n\tint ret;\n\n\t \n\n\tret = 0;\n\tof_node_get(nd->overlay);\n\n\tswitch (action) {\n\n\tcase OF_OVERLAY_PRE_APPLY:\n\t\tfound = of_find_node_by_name(nd->overlay, \"test-unittest16\");\n\t\tif (found) {\n\t\t\tof_node_put(found);\n\t\t\tret = -EBUSY;\n\t\t}\n\t\tbreak;\n\n\tcase OF_OVERLAY_POST_APPLY:\n\t\tfound = of_find_node_by_name(nd->overlay, \"test-unittest17\");\n\t\tif (found) {\n\t\t\tof_node_put(found);\n\t\t\tret = -EEXIST;\n\t\t}\n\t\tbreak;\n\n\tcase OF_OVERLAY_PRE_REMOVE:\n\t\tfound = of_find_node_by_name(nd->overlay, \"test-unittest18\");\n\t\tif (found) {\n\t\t\tof_node_put(found);\n\t\t\tret = -EXDEV;\n\t\t}\n\t\tbreak;\n\n\tcase OF_OVERLAY_POST_REMOVE:\n\t\tfound = of_find_node_by_name(nd->overlay, \"test-unittest19\");\n\t\tif (found) {\n\t\t\tof_node_put(found);\n\t\t\tret = -ENODEV;\n\t\t}\n\t\tbreak;\n\n\tdefault:\t\t\t \n\t\tof_node_put(nd->overlay);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn notifier_from_errno(ret);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block of_nb = {\n\t.notifier_call = of_notify,\n};\n\nstatic void __init of_unittest_overlay_notify(void)\n{\n\tint ovcs_id;\n\tint ret;\n\n\tret = of_overlay_notifier_register(&of_nb);\n\tunittest(!ret,\n\t\t \"of_overlay_notifier_register() failed, ret = %d\\n\", ret);\n\tif (ret)\n\t\treturn;\n\n\t \n\n\t \n\n\tEXPECT_BEGIN(KERN_INFO, \"OF: overlay: overlay changeset pre-apply notifier error -16, target: /testcase-data/overlay-node/test-bus\");\n\n\tunittest(overlay_data_apply(\"overlay_16\", &ovcs_id),\n\t\t \"test OF_OVERLAY_PRE_APPLY notify injected error\\n\");\n\n\tEXPECT_END(KERN_INFO, \"OF: overlay: overlay changeset pre-apply notifier error -16, target: /testcase-data/overlay-node/test-bus\");\n\n\tunittest(ovcs_id, \"ovcs_id not created for overlay_16\\n\");\n\n\t \n\n\tEXPECT_BEGIN(KERN_INFO, \"OF: overlay: overlay changeset post-apply notifier error -17, target: /testcase-data/overlay-node/test-bus\");\n\n\tunittest(overlay_data_apply(\"overlay_17\", &ovcs_id),\n\t\t \"test OF_OVERLAY_POST_APPLY notify injected error\\n\");\n\n\tEXPECT_END(KERN_INFO, \"OF: overlay: overlay changeset post-apply notifier error -17, target: /testcase-data/overlay-node/test-bus\");\n\n\tunittest(ovcs_id, \"ovcs_id not created for overlay_17\\n\");\n\n\t \n\n\tunittest(overlay_data_apply(\"overlay_18\", &ovcs_id),\n\t\t \"OF_OVERLAY_PRE_REMOVE notify injected error\\n\");\n\n\tunittest(ovcs_id, \"ovcs_id not created for overlay_18\\n\");\n\n\tif (ovcs_id) {\n\t\tEXPECT_BEGIN(KERN_INFO, \"OF: overlay: overlay changeset pre-remove notifier error -18, target: /testcase-data/overlay-node/test-bus\");\n\n\t\tret = of_overlay_remove(&ovcs_id);\n\t\tEXPECT_END(KERN_INFO, \"OF: overlay: overlay changeset pre-remove notifier error -18, target: /testcase-data/overlay-node/test-bus\");\n\t\tif (ret == -EXDEV) {\n\t\t\t \n\t\t\tunittest(1, \"overlay_18 of_overlay_remove() injected error for OF_OVERLAY_PRE_REMOVE\\n\");\n\t\t} else {\n\t\t\tunittest(0, \"overlay_18 of_overlay_remove() injected error for OF_OVERLAY_PRE_REMOVE not returned\\n\");\n\t\t}\n\t} else {\n\t\tunittest(1, \"ovcs_id not created for overlay_18\\n\");\n\t}\n\n\tunittest(ovcs_id, \"ovcs_id removed for overlay_18\\n\");\n\n\t \n\n\tunittest(overlay_data_apply(\"overlay_19\", &ovcs_id),\n\t\t \"OF_OVERLAY_POST_REMOVE notify injected error\\n\");\n\n\tunittest(ovcs_id, \"ovcs_id not created for overlay_19\\n\");\n\n\tif (ovcs_id) {\n\t\tEXPECT_BEGIN(KERN_INFO, \"OF: overlay: overlay changeset post-remove notifier error -19, target: /testcase-data/overlay-node/test-bus\");\n\t\tret = of_overlay_remove(&ovcs_id);\n\t\tEXPECT_END(KERN_INFO, \"OF: overlay: overlay changeset post-remove notifier error -19, target: /testcase-data/overlay-node/test-bus\");\n\t\tif (ret == -ENODEV)\n\t\t\tunittest(1, \"overlay_19 of_overlay_remove() injected error for OF_OVERLAY_POST_REMOVE\\n\");\n\t\telse\n\t\t\tunittest(0, \"overlay_19 of_overlay_remove() injected error for OF_OVERLAY_POST_REMOVE not returned\\n\");\n\t} else {\n\t\tunittest(1, \"ovcs_id removed for overlay_19\\n\");\n\t}\n\n\tunittest(!ovcs_id, \"changeset ovcs_id = %d not removed for overlay_19\\n\",\n\t\t ovcs_id);\n\n\t \n\n\tunittest(overlay_data_apply(\"overlay_20\", &ovcs_id),\n\t\t \"overlay notify no injected error\\n\");\n\n\tif (ovcs_id) {\n\t\tret = of_overlay_remove(&ovcs_id);\n\t\tif (ret)\n\t\t\tunittest(1, \"overlay_20 failed to be destroyed, ret = %d\\n\",\n\t\t\t\t ret);\n\t} else {\n\t\tunittest(1, \"ovcs_id not created for overlay_20\\n\");\n\t}\n\n\tunittest(!of_overlay_notifier_unregister(&of_nb),\n\t\t \"of_overlay_notifier_unregister() failed, ret = %d\\n\", ret);\n}\n\nstatic void __init of_unittest_overlay(void)\n{\n\tstruct device_node *bus_np = NULL;\n\tunsigned int i;\n\n\tif (platform_driver_register(&unittest_driver)) {\n\t\tunittest(0, \"could not register unittest driver\\n\");\n\t\tgoto out;\n\t}\n\n\tbus_np = of_find_node_by_path(bus_path);\n\tif (bus_np == NULL) {\n\t\tunittest(0, \"could not find bus_path \\\"%s\\\"\\n\", bus_path);\n\t\tgoto out;\n\t}\n\n\tif (of_platform_default_populate(bus_np, NULL, NULL)) {\n\t\tunittest(0, \"could not populate bus @ \\\"%s\\\"\\n\", bus_path);\n\t\tgoto out;\n\t}\n\n\tif (!of_unittest_device_exists(100, PDEV_OVERLAY)) {\n\t\tunittest(0, \"could not find unittest0 @ \\\"%s\\\"\\n\",\n\t\t\t\tunittest_path(100, PDEV_OVERLAY));\n\t\tgoto out;\n\t}\n\n\tif (of_unittest_device_exists(101, PDEV_OVERLAY)) {\n\t\tunittest(0, \"unittest1 @ \\\"%s\\\" should not exist\\n\",\n\t\t\t\tunittest_path(101, PDEV_OVERLAY));\n\t\tgoto out;\n\t}\n\n\tunittest(1, \"basic infrastructure of overlays passed\");\n\n\t \n\tof_unittest_overlay_0();\n\tof_unittest_overlay_1();\n\tof_unittest_overlay_2();\n\tof_unittest_overlay_3();\n\tof_unittest_overlay_4();\n\tfor (i = 0; i < 3; i++)\n\t\tof_unittest_overlay_5();\n\tof_unittest_overlay_6();\n\tof_unittest_overlay_8();\n\n\tof_unittest_overlay_10();\n\tof_unittest_overlay_11();\n\n#if IS_BUILTIN(CONFIG_I2C)\n\tif (unittest(of_unittest_overlay_i2c_init() == 0, \"i2c init failed\\n\"))\n\t\tgoto out;\n\n\tof_unittest_overlay_i2c_12();\n\tof_unittest_overlay_i2c_13();\n\tof_unittest_overlay_i2c_14();\n\tof_unittest_overlay_i2c_15();\n\n\tof_unittest_overlay_i2c_cleanup();\n#endif\n\n\tof_unittest_overlay_gpio();\n\n\tof_unittest_remove_tracked_overlays();\n\n\tof_unittest_overlay_notify();\n\nout:\n\tof_node_put(bus_np);\n}\n\n#else\nstatic inline void __init of_unittest_overlay(void) { }\n#endif\n\nstatic void __init of_unittest_lifecycle(void)\n{\n#ifdef CONFIG_OF_DYNAMIC\n\tunsigned int refcount;\n\tint found_refcount_one = 0;\n\tint put_count = 0;\n\tstruct device_node *np;\n\tstruct device_node *prev_sibling, *next_sibling;\n\tconst char *refcount_path = \"/testcase-data/refcount-node\";\n\tconst char *refcount_parent_path = \"/testcase-data\";\n\n\t \n\n\tnp = of_find_node_by_path(refcount_path);\n\tunittest(np, \"find refcount_path \\\"%s\\\"\\n\", refcount_path);\n\tif (np == NULL)\n\t\tgoto out_skip_tests;\n\n\twhile (!found_refcount_one) {\n\n\t\tif (put_count++ > 10) {\n\t\t\tunittest(0, \"guardrail to avoid infinite loop\\n\");\n\t\t\tgoto out_skip_tests;\n\t\t}\n\n\t\trefcount = kref_read(&np->kobj.kref);\n\t\tif (refcount == 1)\n\t\t\tfound_refcount_one = 1;\n\t\telse\n\t\t\tof_node_put(np);\n\t}\n\n\tEXPECT_BEGIN(KERN_INFO, \"OF: ERROR: of_node_release() detected bad of_node_put() on /testcase-data/refcount-node\");\n\n\t \n\tunittest(1, \"/testcase-data/refcount-node is one\");\n\tof_node_put(np);\n\n\tEXPECT_END(KERN_INFO, \"OF: ERROR: of_node_release() detected bad of_node_put() on /testcase-data/refcount-node\");\n\n\n\t \n\tEXPECT_BEGIN(KERN_INFO, \"------------[ cut here ]------------\");\n\tEXPECT_BEGIN(KERN_INFO, \"WARNING: <<all>>\");\n\tEXPECT_BEGIN(KERN_INFO, \"refcount_t: underflow; use-after-free.\");\n\tEXPECT_BEGIN(KERN_INFO, \"---[ end trace <<int>> ]---\");\n\n\t \n\tunittest(1, \"/testcase-data/refcount-node is zero\");\n\tof_node_put(np);\n\n\tEXPECT_END(KERN_INFO, \"---[ end trace <<int>> ]---\");\n\tEXPECT_END(KERN_INFO, \"refcount_t: underflow; use-after-free.\");\n\tEXPECT_END(KERN_INFO, \"WARNING: <<all>>\");\n\tEXPECT_END(KERN_INFO, \"------------[ cut here ]------------\");\n\n\t \n\tEXPECT_NOT_BEGIN(KERN_INFO, \"------------[ cut here ]------------\");\n\tEXPECT_NOT_BEGIN(KERN_INFO, \"WARNING: <<all>>\");\n\tEXPECT_NOT_BEGIN(KERN_INFO, \"refcount_t: underflow; use-after-free.\");\n\tEXPECT_NOT_BEGIN(KERN_INFO, \"---[ end trace <<int>> ]---\");\n\n\tunittest(1, \"/testcase-data/refcount-node is zero, second time\");\n\tof_node_put(np);\n\n\tEXPECT_NOT_END(KERN_INFO, \"---[ end trace <<int>> ]---\");\n\tEXPECT_NOT_END(KERN_INFO, \"refcount_t: underflow; use-after-free.\");\n\tEXPECT_NOT_END(KERN_INFO, \"WARNING: <<all>>\");\n\tEXPECT_NOT_END(KERN_INFO, \"------------[ cut here ]------------\");\n\n\t \n\n\tnp = of_find_node_by_path(refcount_parent_path);\n\tunittest(np, \"find refcount_parent_path \\\"%s\\\"\\n\", refcount_parent_path);\n\tunittest(np, \"ERROR: devicetree live tree left in a 'bad state' if test fail\\n\");\n\tif (np == NULL)\n\t\treturn;\n\n\tprev_sibling = np->child;\n\tnext_sibling = prev_sibling->sibling;\n\tif (!strcmp(prev_sibling->full_name, \"refcount-node\")) {\n\t\tnp->child = next_sibling;\n\t\tnext_sibling = next_sibling->sibling;\n\t}\n\twhile (next_sibling) {\n\t\tif (!strcmp(next_sibling->full_name, \"refcount-node\"))\n\t\t\tprev_sibling->sibling = next_sibling->sibling;\n\t\tprev_sibling = next_sibling;\n\t\tnext_sibling = next_sibling->sibling;\n\t}\n\tof_node_put(np);\n\n\treturn;\n\nout_skip_tests:\n#endif\n\tunittest(0, \"One or more lifecycle tests skipped\\n\");\n}\n\n#ifdef CONFIG_OF_OVERLAY\n\n \n\n#define OVERLAY_INFO_EXTERN(overlay_name) \\\n\textern uint8_t __dtbo_##overlay_name##_begin[]; \\\n\textern uint8_t __dtbo_##overlay_name##_end[]\n\n#define OVERLAY_INFO(overlay_name, expected, expected_remove) \\\n{\t.dtbo_begin\t\t= __dtbo_##overlay_name##_begin, \\\n\t.dtbo_end\t\t= __dtbo_##overlay_name##_end, \\\n\t.expected_result\t= expected, \\\n\t.expected_result_remove\t= expected_remove, \\\n\t.name\t\t\t= #overlay_name, \\\n}\n\nstruct overlay_info {\n\tuint8_t\t\t*dtbo_begin;\n\tuint8_t\t\t*dtbo_end;\n\tint\t\texpected_result;\n\tint\t\texpected_result_remove;\t \n\tint\t\tovcs_id;\n\tchar\t\t*name;\n};\n\nOVERLAY_INFO_EXTERN(overlay_base);\nOVERLAY_INFO_EXTERN(overlay);\nOVERLAY_INFO_EXTERN(overlay_0);\nOVERLAY_INFO_EXTERN(overlay_1);\nOVERLAY_INFO_EXTERN(overlay_2);\nOVERLAY_INFO_EXTERN(overlay_3);\nOVERLAY_INFO_EXTERN(overlay_4);\nOVERLAY_INFO_EXTERN(overlay_5);\nOVERLAY_INFO_EXTERN(overlay_6);\nOVERLAY_INFO_EXTERN(overlay_7);\nOVERLAY_INFO_EXTERN(overlay_8);\nOVERLAY_INFO_EXTERN(overlay_9);\nOVERLAY_INFO_EXTERN(overlay_10);\nOVERLAY_INFO_EXTERN(overlay_11);\nOVERLAY_INFO_EXTERN(overlay_12);\nOVERLAY_INFO_EXTERN(overlay_13);\nOVERLAY_INFO_EXTERN(overlay_15);\nOVERLAY_INFO_EXTERN(overlay_16);\nOVERLAY_INFO_EXTERN(overlay_17);\nOVERLAY_INFO_EXTERN(overlay_18);\nOVERLAY_INFO_EXTERN(overlay_19);\nOVERLAY_INFO_EXTERN(overlay_20);\nOVERLAY_INFO_EXTERN(overlay_gpio_01);\nOVERLAY_INFO_EXTERN(overlay_gpio_02a);\nOVERLAY_INFO_EXTERN(overlay_gpio_02b);\nOVERLAY_INFO_EXTERN(overlay_gpio_03);\nOVERLAY_INFO_EXTERN(overlay_gpio_04a);\nOVERLAY_INFO_EXTERN(overlay_gpio_04b);\nOVERLAY_INFO_EXTERN(overlay_pci_node);\nOVERLAY_INFO_EXTERN(overlay_bad_add_dup_node);\nOVERLAY_INFO_EXTERN(overlay_bad_add_dup_prop);\nOVERLAY_INFO_EXTERN(overlay_bad_phandle);\nOVERLAY_INFO_EXTERN(overlay_bad_symbol);\nOVERLAY_INFO_EXTERN(overlay_bad_unresolved);\n\n \nstatic struct overlay_info overlays[] = {\n\tOVERLAY_INFO(overlay_base, -9999, 0),\n\tOVERLAY_INFO(overlay, 0, 0),\n\tOVERLAY_INFO(overlay_0, 0, 0),\n\tOVERLAY_INFO(overlay_1, 0, 0),\n\tOVERLAY_INFO(overlay_2, 0, 0),\n\tOVERLAY_INFO(overlay_3, 0, 0),\n\tOVERLAY_INFO(overlay_4, 0, 0),\n\tOVERLAY_INFO(overlay_5, 0, 0),\n\tOVERLAY_INFO(overlay_6, 0, 0),\n\tOVERLAY_INFO(overlay_7, 0, 0),\n\tOVERLAY_INFO(overlay_8, 0, 0),\n\tOVERLAY_INFO(overlay_9, 0, 0),\n\tOVERLAY_INFO(overlay_10, 0, 0),\n\tOVERLAY_INFO(overlay_11, 0, 0),\n\tOVERLAY_INFO(overlay_12, 0, 0),\n\tOVERLAY_INFO(overlay_13, 0, 0),\n\tOVERLAY_INFO(overlay_15, 0, 0),\n\tOVERLAY_INFO(overlay_16, -EBUSY, 0),\n\tOVERLAY_INFO(overlay_17, -EEXIST, 0),\n\tOVERLAY_INFO(overlay_18, 0, 0),\n\tOVERLAY_INFO(overlay_19, 0, 0),\n\tOVERLAY_INFO(overlay_20, 0, 0),\n\tOVERLAY_INFO(overlay_gpio_01, 0, 0),\n\tOVERLAY_INFO(overlay_gpio_02a, 0, 0),\n\tOVERLAY_INFO(overlay_gpio_02b, 0, 0),\n\tOVERLAY_INFO(overlay_gpio_03, 0, 0),\n\tOVERLAY_INFO(overlay_gpio_04a, 0, 0),\n\tOVERLAY_INFO(overlay_gpio_04b, 0, 0),\n\tOVERLAY_INFO(overlay_pci_node, 0, 0),\n\tOVERLAY_INFO(overlay_bad_add_dup_node, -EINVAL, -ENODEV),\n\tOVERLAY_INFO(overlay_bad_add_dup_prop, -EINVAL, -ENODEV),\n\tOVERLAY_INFO(overlay_bad_phandle, -EINVAL, 0),\n\tOVERLAY_INFO(overlay_bad_symbol, -EINVAL, -ENODEV),\n\tOVERLAY_INFO(overlay_bad_unresolved, -EINVAL, 0),\n\t \n\t{ }\n};\n\nstatic struct device_node *overlay_base_root;\n\nstatic void * __init dt_alloc_memory(u64 size, u64 align)\n{\n\tvoid *ptr = memblock_alloc(size, align);\n\n\tif (!ptr)\n\t\tpanic(\"%s: Failed to allocate %llu bytes align=0x%llx\\n\",\n\t\t      __func__, size, align);\n\n\treturn ptr;\n}\n\n \nvoid __init unittest_unflatten_overlay_base(void)\n{\n\tstruct overlay_info *info;\n\tu32 data_size;\n\tvoid *new_fdt;\n\tu32 size;\n\tint found = 0;\n\tconst char *overlay_name = \"overlay_base\";\n\n\tfor (info = overlays; info && info->name; info++) {\n\t\tif (!strcmp(overlay_name, info->name)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tpr_err(\"no overlay data for %s\\n\", overlay_name);\n\t\treturn;\n\t}\n\n\tinfo = &overlays[0];\n\n\tif (info->expected_result != -9999) {\n\t\tpr_err(\"No dtb 'overlay_base' to attach\\n\");\n\t\treturn;\n\t}\n\n\tdata_size = info->dtbo_end - info->dtbo_begin;\n\tif (!data_size) {\n\t\tpr_err(\"No dtb 'overlay_base' to attach\\n\");\n\t\treturn;\n\t}\n\n\tsize = fdt_totalsize(info->dtbo_begin);\n\tif (size != data_size) {\n\t\tpr_err(\"dtb 'overlay_base' header totalsize != actual size\");\n\t\treturn;\n\t}\n\n\tnew_fdt = dt_alloc_memory(size, roundup_pow_of_two(FDT_V17_SIZE));\n\tif (!new_fdt) {\n\t\tpr_err(\"alloc for dtb 'overlay_base' failed\");\n\t\treturn;\n\t}\n\n\tmemcpy(new_fdt, info->dtbo_begin, size);\n\n\t__unflatten_device_tree(new_fdt, NULL, &overlay_base_root,\n\t\t\t\tdt_alloc_memory, true);\n}\n\n \nstatic int __init overlay_data_apply(const char *overlay_name, int *ovcs_id)\n{\n\tstruct overlay_info *info;\n\tint passed = 1;\n\tint found = 0;\n\tint ret, ret2;\n\tu32 size;\n\n\tfor (info = overlays; info && info->name; info++) {\n\t\tif (!strcmp(overlay_name, info->name)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tpr_err(\"no overlay data for %s\\n\", overlay_name);\n\t\treturn 0;\n\t}\n\n\tsize = info->dtbo_end - info->dtbo_begin;\n\tif (!size)\n\t\tpr_err(\"no overlay data for %s\\n\", overlay_name);\n\n\tret = of_overlay_fdt_apply(info->dtbo_begin, size, &info->ovcs_id,\n\t\t\t\t   NULL);\n\tif (ovcs_id)\n\t\t*ovcs_id = info->ovcs_id;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpr_debug(\"%s applied\\n\", overlay_name);\n\nout:\n\tif (ret != info->expected_result) {\n\t\tpr_err(\"of_overlay_fdt_apply() expected %d, ret=%d, %s\\n\",\n\t\t       info->expected_result, ret, overlay_name);\n\t\tpassed = 0;\n\t}\n\n\tif (ret < 0) {\n\t\t \n\t\tret2 = of_overlay_remove(&info->ovcs_id);\n\t\tif (ret2 != info->expected_result_remove) {\n\t\t\tpr_err(\"of_overlay_remove() expected %d, ret=%d, %s\\n\",\n\t\t\t       info->expected_result_remove, ret2,\n\t\t\t       overlay_name);\n\t\t\tpassed = 0;\n\t\t}\n\t}\n\n\treturn passed;\n}\n\n \nstatic __init void of_unittest_overlay_high_level(void)\n{\n\tstruct device_node *last_sibling;\n\tstruct device_node *np;\n\tstruct device_node *of_symbols;\n\tstruct device_node *overlay_base_symbols;\n\tstruct device_node **pprev;\n\tstruct property *prop;\n\tint ret;\n\n\tif (!overlay_base_root) {\n\t\tunittest(0, \"overlay_base_root not initialized\\n\");\n\t\treturn;\n\t}\n\n\t \n\tof_overlay_mutex_lock();\n\tof_resolve_phandles(overlay_base_root);\n\tof_overlay_mutex_unlock();\n\n\n\t \n\n\t \n\tpprev = &overlay_base_root->child;\n\tfor (np = overlay_base_root->child; np; np = np->sibling) {\n\t\tif (of_node_name_eq(np, \"__local_fixups__\")) {\n\t\t\t*pprev = np->sibling;\n\t\t\tbreak;\n\t\t}\n\t\tpprev = &np->sibling;\n\t}\n\n\t \n\tof_symbols = of_get_child_by_name(of_root, \"__symbols__\");\n\tif (of_symbols) {\n\t\t \n\t\tpprev = &overlay_base_root->child;\n\t\tfor (np = overlay_base_root->child; np; np = np->sibling) {\n\t\t\tif (of_node_name_eq(np, \"__symbols__\")) {\n\t\t\t\toverlay_base_symbols = np;\n\t\t\t\t*pprev = np->sibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpprev = &np->sibling;\n\t\t}\n\t}\n\n\tfor_each_child_of_node(overlay_base_root, np) {\n\t\tstruct device_node *base_child;\n\t\tfor_each_child_of_node(of_root, base_child) {\n\t\t\tif (!strcmp(np->full_name, base_child->full_name)) {\n\t\t\t\tunittest(0, \"illegal node name in overlay_base %pOFn\",\n\t\t\t\t\t np);\n\t\t\t\tof_node_put(np);\n\t\t\t\tof_node_put(base_child);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tfor (np = overlay_base_root->child; np; np = np->sibling)\n\t\tnp->parent = of_root;\n\n\tmutex_lock(&of_mutex);\n\n\tfor (last_sibling = np = of_root->child; np; np = np->sibling)\n\t\tlast_sibling = np;\n\n\tif (last_sibling)\n\t\tlast_sibling->sibling = overlay_base_root->child;\n\telse\n\t\tof_root->child = overlay_base_root->child;\n\n\tfor_each_of_allnodes_from(overlay_base_root, np)\n\t\t__of_attach_node_sysfs(np);\n\n\tif (of_symbols) {\n\t\tstruct property *new_prop;\n\t\tfor_each_property_of_node(overlay_base_symbols, prop) {\n\n\t\t\tnew_prop = __of_prop_dup(prop, GFP_KERNEL);\n\t\t\tif (!new_prop) {\n\t\t\t\tunittest(0, \"__of_prop_dup() of '%s' from overlay_base node __symbols__\",\n\t\t\t\t\t prop->name);\n\t\t\t\tgoto err_unlock;\n\t\t\t}\n\t\t\tif (__of_add_property(of_symbols, new_prop)) {\n\t\t\t\tkfree(new_prop->name);\n\t\t\t\tkfree(new_prop->value);\n\t\t\t\tkfree(new_prop);\n\t\t\t\t \n\t\t\t\tif (!strcmp(prop->name, \"name\"))\n\t\t\t\t\tcontinue;\n\t\t\t\tunittest(0, \"duplicate property '%s' in overlay_base node __symbols__\",\n\t\t\t\t\t prop->name);\n\t\t\t\tgoto err_unlock;\n\t\t\t}\n\t\t\tif (__of_add_property_sysfs(of_symbols, new_prop)) {\n\t\t\t\tunittest(0, \"unable to add property '%s' in overlay_base node __symbols__ to sysfs\",\n\t\t\t\t\t prop->name);\n\t\t\t\tgoto err_unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&of_mutex);\n\n\n\t \n\n\t \n\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/substation@100/status\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/status\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@30/incline-up\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@40/incline-up\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/status\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/color\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/rate\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/hvac_2\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_left\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_right\");\n\n\tret = overlay_data_apply(\"overlay\", NULL);\n\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_right\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_left\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/hvac_2\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/rate\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/color\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/status\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@40/incline-up\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@30/incline-up\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/status\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/substation@100/status\");\n\n\tunittest(ret, \"Adding overlay 'overlay' failed\\n\");\n\n\t \n\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: ERROR: multiple fragments add and/or delete node /testcase-data-2/substation@100/motor-1/controller\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: ERROR: multiple fragments add, update, and/or delete property /testcase-data-2/substation@100/motor-1/controller/name\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: changeset: apply failed: REMOVE_PROPERTY /testcase-data-2/substation@100/motor-1/controller:name\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: Error reverting changeset (-19)\");\n\n\tunittest(overlay_data_apply(\"overlay_bad_add_dup_node\", NULL),\n\t\t \"Adding overlay 'overlay_bad_add_dup_node' failed\\n\");\n\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: Error reverting changeset (-19)\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: changeset: apply failed: REMOVE_PROPERTY /testcase-data-2/substation@100/motor-1/controller:name\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: ERROR: multiple fragments add, update, and/or delete property /testcase-data-2/substation@100/motor-1/controller/name\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: ERROR: multiple fragments add and/or delete node /testcase-data-2/substation@100/motor-1/controller\");\n\n\t \n\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: ERROR: multiple fragments add and/or delete node /testcase-data-2/substation@100/motor-1/electric\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: ERROR: multiple fragments add, update, and/or delete property /testcase-data-2/substation@100/motor-1/electric/rpm_avail\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: overlay: ERROR: multiple fragments add, update, and/or delete property /testcase-data-2/substation@100/motor-1/electric/name\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: changeset: apply failed: REMOVE_PROPERTY /testcase-data-2/substation@100/motor-1/electric:name\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: Error reverting changeset (-19)\");\n\n\tunittest(overlay_data_apply(\"overlay_bad_add_dup_prop\", NULL),\n\t\t \"Adding overlay 'overlay_bad_add_dup_prop' failed\\n\");\n\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: Error reverting changeset (-19)\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: changeset: apply failed: REMOVE_PROPERTY /testcase-data-2/substation@100/motor-1/electric:name\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: ERROR: multiple fragments add, update, and/or delete property /testcase-data-2/substation@100/motor-1/electric/name\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: ERROR: multiple fragments add, update, and/or delete property /testcase-data-2/substation@100/motor-1/electric/rpm_avail\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: overlay: ERROR: multiple fragments add and/or delete node /testcase-data-2/substation@100/motor-1/electric\");\n\n\t \n\n\tunittest(overlay_data_apply(\"overlay_bad_phandle\", NULL),\n\t\t \"Adding overlay 'overlay_bad_phandle' failed\\n\");\n\n\t \n\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: changeset: apply failed: REMOVE_PROPERTY /testcase-data-2/substation@100/hvac-medium-2:name\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: Error reverting changeset (-19)\");\n\n\tunittest(overlay_data_apply(\"overlay_bad_symbol\", NULL),\n\t\t \"Adding overlay 'overlay_bad_symbol' failed\\n\");\n\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: Error reverting changeset (-19)\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: changeset: apply failed: REMOVE_PROPERTY /testcase-data-2/substation@100/hvac-medium-2:name\");\n\n\t \n\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: resolver: node label 'this_label_does_not_exist' not found in live devicetree symbols table\");\n\tEXPECT_BEGIN(KERN_ERR,\n\t\t     \"OF: resolver: overlay phandle fixup failed: -22\");\n\n\tunittest(overlay_data_apply(\"overlay_bad_unresolved\", NULL),\n\t\t \"Adding overlay 'overlay_bad_unresolved' failed\\n\");\n\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: resolver: overlay phandle fixup failed: -22\");\n\tEXPECT_END(KERN_ERR,\n\t\t   \"OF: resolver: node label 'this_label_does_not_exist' not found in live devicetree symbols table\");\n\n\treturn;\n\nerr_unlock:\n\tmutex_unlock(&of_mutex);\n}\n\nstatic int of_unittest_pci_dev_num;\nstatic int of_unittest_pci_child_num;\n\n \nstatic const struct pci_device_id testdrv_pci_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_REDHAT, 0x5), },  \n\t{ 0, }\n};\n\nstatic int testdrv_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct overlay_info *info;\n\tstruct device_node *dn;\n\tint ret, ovcs_id;\n\tu32 size;\n\n\tdn = pdev->dev.of_node;\n\tif (!dn) {\n\t\tdev_err(&pdev->dev, \"does not find bus endpoint\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (info = overlays; info && info->name; info++) {\n\t\tif (!strcmp(info->name, \"overlay_pci_node\"))\n\t\t\tbreak;\n\t}\n\tif (!info || !info->name) {\n\t\tdev_err(&pdev->dev, \"no overlay data for overlay_pci_node\");\n\t\treturn -ENODEV;\n\t}\n\n\tsize = info->dtbo_end - info->dtbo_begin;\n\tret = of_overlay_fdt_apply(info->dtbo_begin, size, &ovcs_id, dn);\n\tof_node_put(dn);\n\tif (ret)\n\t\treturn ret;\n\n\tof_platform_default_populate(dn, NULL, &pdev->dev);\n\tpci_set_drvdata(pdev, (void *)(uintptr_t)ovcs_id);\n\n\treturn 0;\n}\n\nstatic void testdrv_remove(struct pci_dev *pdev)\n{\n\tint ovcs_id = (int)(uintptr_t)pci_get_drvdata(pdev);\n\n\tof_platform_depopulate(&pdev->dev);\n\tof_overlay_remove(&ovcs_id);\n}\n\nstatic struct pci_driver testdrv_driver = {\n\t.name = \"pci_dt_testdrv\",\n\t.id_table = testdrv_pci_ids,\n\t.probe = testdrv_probe,\n\t.remove = testdrv_remove,\n};\n\nstatic int unittest_pci_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct device *dev;\n\tu64 exp_addr;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tdev = &pdev->dev;\n\twhile (dev && !dev_is_pci(dev))\n\t\tdev = dev->parent;\n\tif (!dev) {\n\t\tpr_err(\"unable to find parent device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\texp_addr = pci_resource_start(to_pci_dev(dev), 0) + 0x100;\n\tunittest(res->start == exp_addr, \"Incorrect translated address %llx, expected %llx\\n\",\n\t\t (u64)res->start, exp_addr);\n\n\tof_unittest_pci_child_num++;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id unittest_pci_of_match[] = {\n\t{ .compatible = \"unittest-pci\" },\n\t{ }\n};\n\nstatic struct platform_driver unittest_pci_driver = {\n\t.probe = unittest_pci_probe,\n\t.driver = {\n\t\t.name = \"unittest-pci\",\n\t\t.of_match_table = unittest_pci_of_match,\n\t},\n};\n\nstatic int of_unittest_pci_node_verify(struct pci_dev *pdev, bool add)\n{\n\tstruct device_node *pnp, *np = NULL;\n\tstruct device *child_dev;\n\tchar *path = NULL;\n\tconst __be32 *reg;\n\tint rc = 0;\n\n\tpnp = pdev->dev.of_node;\n\tunittest(pnp, \"Failed creating PCI dt node\\n\");\n\tif (!pnp)\n\t\treturn -ENODEV;\n\n\tif (add) {\n\t\tpath = kasprintf(GFP_KERNEL, \"%pOF/pci-ep-bus@0/unittest-pci@100\", pnp);\n\t\tnp = of_find_node_by_path(path);\n\t\tunittest(np, \"Failed to get unittest-pci node under PCI node\\n\");\n\t\tif (!np) {\n\t\t\trc = -ENODEV;\n\t\t\tgoto failed;\n\t\t}\n\n\t\treg = of_get_property(np, \"reg\", NULL);\n\t\tunittest(reg, \"Failed to get reg property\\n\");\n\t\tif (!reg)\n\t\t\trc = -ENODEV;\n\t} else {\n\t\tpath = kasprintf(GFP_KERNEL, \"%pOF/pci-ep-bus@0\", pnp);\n\t\tnp = of_find_node_by_path(path);\n\t\tunittest(!np, \"Child device tree node is not removed\\n\");\n\t\tchild_dev = device_find_any_child(&pdev->dev);\n\t\tunittest(!child_dev, \"Child device is not removed\\n\");\n\t}\n\nfailed:\n\tkfree(path);\n\tif (np)\n\t\tof_node_put(np);\n\n\treturn rc;\n}\n\nstatic void __init of_unittest_pci_node(void)\n{\n\tstruct pci_dev *pdev = NULL;\n\tint rc;\n\n\tif (!IS_ENABLED(CONFIG_PCI_DYNAMIC_OF_NODES))\n\t\treturn;\n\n\trc = pci_register_driver(&testdrv_driver);\n\tunittest(!rc, \"Failed to register pci test driver; rc = %d\\n\", rc);\n\tif (rc)\n\t\treturn;\n\n\trc = platform_driver_register(&unittest_pci_driver);\n\tif (unittest(!rc, \"Failed to register unittest pci driver\\n\")) {\n\t\tpci_unregister_driver(&testdrv_driver);\n\t\treturn;\n\t}\n\n\twhile ((pdev = pci_get_device(PCI_VENDOR_ID_REDHAT, 0x5, pdev)) != NULL) {\n\t\tof_unittest_pci_node_verify(pdev, true);\n\t\tof_unittest_pci_dev_num++;\n\t}\n\tif (pdev)\n\t\tpci_dev_put(pdev);\n\n\tunittest(of_unittest_pci_dev_num,\n\t\t \"No test PCI device been found. Please run QEMU with '-device pci-testdev'\\n\");\n\tunittest(of_unittest_pci_dev_num == of_unittest_pci_child_num,\n\t\t \"Child device number %d is not expected %d\", of_unittest_pci_child_num,\n\t\t of_unittest_pci_dev_num);\n\n\tplatform_driver_unregister(&unittest_pci_driver);\n\tpci_unregister_driver(&testdrv_driver);\n\n\twhile ((pdev = pci_get_device(PCI_VENDOR_ID_REDHAT, 0x5, pdev)) != NULL)\n\t\tof_unittest_pci_node_verify(pdev, false);\n\tif (pdev)\n\t\tpci_dev_put(pdev);\n}\n#else\n\nstatic inline __init void of_unittest_overlay_high_level(void) {}\nstatic inline __init void of_unittest_pci_node(void) { }\n\n#endif\n\nstatic int __init of_unittest(void)\n{\n\tstruct device_node *np;\n\tint res;\n\n\tpr_info(\"start of unittest - you will see error messages\\n\");\n\n\t \n\tadd_taint(TAINT_TEST, LOCKDEP_STILL_OK);\n\n\t \n\n\tif (IS_ENABLED(CONFIG_UML))\n\t\tunittest_unflatten_overlay_base();\n\n\tres = unittest_data_add();\n\tif (res)\n\t\treturn res;\n\tif (!of_aliases)\n\t\tof_aliases = of_find_node_by_path(\"/aliases\");\n\n\tnp = of_find_node_by_path(\"/testcase-data/phandle-tests/consumer-a\");\n\tif (!np) {\n\t\tpr_info(\"No testcase data in device tree; not running tests\\n\");\n\t\treturn 0;\n\t}\n\tof_node_put(np);\n\n\tof_unittest_check_tree_linkage();\n\tof_unittest_check_phandles();\n\tof_unittest_find_node_by_name();\n\tof_unittest_dynamic();\n\tof_unittest_parse_phandle_with_args();\n\tof_unittest_parse_phandle_with_args_map();\n\tof_unittest_printf();\n\tof_unittest_property_string();\n\tof_unittest_property_copy();\n\tof_unittest_changeset();\n\tof_unittest_parse_interrupts();\n\tof_unittest_parse_interrupts_extended();\n\tof_unittest_dma_get_max_cpu_address();\n\tof_unittest_parse_dma_ranges();\n\tof_unittest_pci_dma_ranges();\n\tof_unittest_bus_ranges();\n\tof_unittest_bus_3cell_ranges();\n\tof_unittest_reg();\n\tof_unittest_match_node();\n\tof_unittest_platform_populate();\n\tof_unittest_overlay();\n\tof_unittest_lifecycle();\n\tof_unittest_pci_node();\n\n\t \n\tof_unittest_check_tree_linkage();\n\n\tof_unittest_overlay_high_level();\n\n\tpr_info(\"end of unittest - %i passed, %i failed\\n\",\n\t\tunittest_results.passed, unittest_results.failed);\n\n\treturn 0;\n}\nlate_initcall(of_unittest);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}