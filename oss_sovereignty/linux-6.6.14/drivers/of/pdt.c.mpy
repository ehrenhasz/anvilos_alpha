{
  "module_name": "pdt.c",
  "hash_id": "d73a581e6e29c11381b85bf74a3bec53ac75b40f896d8b064e33cee049aad8fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/of/pdt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_pdt.h>\n\nstatic struct of_pdt_ops *of_pdt_prom_ops __initdata;\n\n#if defined(CONFIG_SPARC)\nunsigned int of_pdt_unique_id __initdata;\n\n#define of_pdt_incr_unique_id(p) do { \\\n\t(p)->unique_id = of_pdt_unique_id++; \\\n} while (0)\n\nstatic char * __init of_pdt_build_full_name(struct device_node *dp)\n{\n\treturn build_path_component(dp);\n}\n\n#else  \n\nstatic inline void of_pdt_incr_unique_id(void *p) { }\nstatic inline void irq_trans_init(struct device_node *dp) { }\n\nstatic char * __init of_pdt_build_full_name(struct device_node *dp)\n{\n\tstatic int failsafe_id = 0;  \n\tconst char *name;\n\tchar path[256];\n\tchar *buf;\n\tint len;\n\n\tif (!of_pdt_prom_ops->pkg2path(dp->phandle, path, sizeof(path), &len)) {\n\t\tname = kbasename(path);\n\t\tbuf = prom_early_alloc(strlen(name) + 1);\n\t\tstrcpy(buf, name);\n\t\treturn buf;\n\t}\n\n\tname = of_get_property(dp, \"name\", &len);\n\tbuf = prom_early_alloc(len + 16);\n\tsprintf(buf, \"%s@unknown%i\", name, failsafe_id++);\n\tpr_err(\"%s: pkg2path failed; assigning %s\\n\", __func__, buf);\n\treturn buf;\n}\n\n#endif  \n\nstatic struct property * __init of_pdt_build_one_prop(phandle node, char *prev,\n\t\t\t\t\t       char *special_name,\n\t\t\t\t\t       void *special_val,\n\t\t\t\t\t       int special_len)\n{\n\tstatic struct property *tmp = NULL;\n\tstruct property *p;\n\tint err;\n\n\tif (tmp) {\n\t\tp = tmp;\n\t\tmemset(p, 0, sizeof(*p) + 32);\n\t\ttmp = NULL;\n\t} else {\n\t\tp = prom_early_alloc(sizeof(struct property) + 32);\n\t\tof_pdt_incr_unique_id(p);\n\t}\n\n\tp->name = (char *) (p + 1);\n\tif (special_name) {\n\t\tstrcpy(p->name, special_name);\n\t\tp->length = special_len;\n\t\tp->value = prom_early_alloc(special_len);\n\t\tmemcpy(p->value, special_val, special_len);\n\t} else {\n\t\terr = of_pdt_prom_ops->nextprop(node, prev, p->name);\n\t\tif (err) {\n\t\t\ttmp = p;\n\t\t\treturn NULL;\n\t\t}\n\t\tp->length = of_pdt_prom_ops->getproplen(node, p->name);\n\t\tif (p->length <= 0) {\n\t\t\tp->length = 0;\n\t\t} else {\n\t\t\tint len;\n\n\t\t\tp->value = prom_early_alloc(p->length + 1);\n\t\t\tlen = of_pdt_prom_ops->getproperty(node, p->name,\n\t\t\t\t\tp->value, p->length);\n\t\t\tif (len <= 0)\n\t\t\t\tp->length = 0;\n\t\t\t((unsigned char *)p->value)[p->length] = '\\0';\n\t\t}\n\t}\n\treturn p;\n}\n\nstatic struct property * __init of_pdt_build_prop_list(phandle node)\n{\n\tstruct property *head, *tail;\n\n\thead = tail = of_pdt_build_one_prop(node, NULL,\n\t\t\t\t     \".node\", &node, sizeof(node));\n\n\ttail->next = of_pdt_build_one_prop(node, NULL, NULL, NULL, 0);\n\ttail = tail->next;\n\twhile(tail) {\n\t\ttail->next = of_pdt_build_one_prop(node, tail->name,\n\t\t\t\t\t    NULL, NULL, 0);\n\t\ttail = tail->next;\n\t}\n\n\treturn head;\n}\n\nstatic char * __init of_pdt_get_one_property(phandle node, const char *name)\n{\n\tchar *buf = \"<NULL>\";\n\tint len;\n\n\tlen = of_pdt_prom_ops->getproplen(node, name);\n\tif (len > 0) {\n\t\tbuf = prom_early_alloc(len);\n\t\tlen = of_pdt_prom_ops->getproperty(node, name, buf, len);\n\t}\n\n\treturn buf;\n}\n\nstatic struct device_node * __init of_pdt_create_node(phandle node,\n\t\t\t\t\t\t    struct device_node *parent)\n{\n\tstruct device_node *dp;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tdp = prom_early_alloc(sizeof(*dp));\n\tof_node_init(dp);\n\tof_pdt_incr_unique_id(dp);\n\tdp->parent = parent;\n\n\tdp->name = of_pdt_get_one_property(node, \"name\");\n\tdp->phandle = node;\n\n\tdp->properties = of_pdt_build_prop_list(node);\n\n\tdp->full_name = of_pdt_build_full_name(dp);\n\n\tirq_trans_init(dp);\n\n\treturn dp;\n}\n\nstatic struct device_node * __init of_pdt_build_tree(struct device_node *parent,\n\t\t\t\t\t\t   phandle node)\n{\n\tstruct device_node *ret = NULL, *prev_sibling = NULL;\n\tstruct device_node *dp;\n\n\twhile (1) {\n\t\tdp = of_pdt_create_node(node, parent);\n\t\tif (!dp)\n\t\t\tbreak;\n\n\t\tif (prev_sibling)\n\t\t\tprev_sibling->sibling = dp;\n\n\t\tif (!ret)\n\t\t\tret = dp;\n\t\tprev_sibling = dp;\n\n\t\tdp->child = of_pdt_build_tree(dp, of_pdt_prom_ops->getchild(node));\n\n\t\tnode = of_pdt_prom_ops->getsibling(node);\n\t}\n\n\treturn ret;\n}\n\nstatic void * __init kernel_tree_alloc(u64 size, u64 align)\n{\n\treturn prom_early_alloc(size);\n}\n\nvoid __init of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops)\n{\n\tBUG_ON(!ops);\n\tof_pdt_prom_ops = ops;\n\n\tof_root = of_pdt_create_node(root_node, NULL);\n\tof_root->full_name = \"/\";\n\n\tof_root->child = of_pdt_build_tree(of_root,\n\t\t\t\tof_pdt_prom_ops->getchild(of_root->phandle));\n\n\t \n\tof_alias_scan(kernel_tree_alloc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}