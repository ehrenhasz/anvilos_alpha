{
  "module_name": "reset-berlin.c",
  "hash_id": "686d9e7a10c07f3bf88e6035f8ac3976274ac6338574652f0494bc2e6d36741a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-berlin.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define BERLIN_MAX_RESETS\t32\n\n#define to_berlin_reset_priv(p)\t\t\\\n\tcontainer_of((p), struct berlin_reset_priv, rcdev)\n\nstruct berlin_reset_priv {\n\tstruct regmap\t\t\t*regmap;\n\tstruct reset_controller_dev\trcdev;\n};\n\nstatic int berlin_reset_reset(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct berlin_reset_priv *priv = to_berlin_reset_priv(rcdev);\n\tint offset = id >> 8;\n\tint mask = BIT(id & 0x1f);\n\n\tregmap_write(priv->regmap, offset, mask);\n\n\t \n\tudelay(10);\n\n\treturn 0;\n}\n\nstatic const struct reset_control_ops berlin_reset_ops = {\n\t.reset\t= berlin_reset_reset,\n};\n\nstatic int berlin_reset_xlate(struct reset_controller_dev *rcdev,\n\t\t\t      const struct of_phandle_args *reset_spec)\n{\n\tunsigned int offset, bit;\n\n\toffset = reset_spec->args[0];\n\tbit = reset_spec->args[1];\n\n\tif (bit >= BERLIN_MAX_RESETS)\n\t\treturn -EINVAL;\n\n\treturn (offset << 8) | bit;\n}\n\nstatic int berlin2_reset_probe(struct platform_device *pdev)\n{\n\tstruct device_node *parent_np = of_get_parent(pdev->dev.of_node);\n\tstruct berlin_reset_priv *priv;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tpriv->rcdev.owner = THIS_MODULE;\n\tpriv->rcdev.ops = &berlin_reset_ops;\n\tpriv->rcdev.of_node = pdev->dev.of_node;\n\tpriv->rcdev.of_reset_n_cells = 2;\n\tpriv->rcdev.of_xlate = berlin_reset_xlate;\n\n\treturn reset_controller_register(&priv->rcdev);\n}\n\nstatic const struct of_device_id berlin_reset_dt_match[] = {\n\t{ .compatible = \"marvell,berlin2-reset\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, berlin_reset_dt_match);\n\nstatic struct platform_driver berlin_reset_driver = {\n\t.probe\t= berlin2_reset_probe,\n\t.driver\t= {\n\t\t.name = \"berlin2-reset\",\n\t\t.of_match_table = berlin_reset_dt_match,\n\t},\n};\nmodule_platform_driver(berlin_reset_driver);\n\nMODULE_AUTHOR(\"Antoine Tenart <antoine.tenart@free-electrons.com>\");\nMODULE_AUTHOR(\"Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>\");\nMODULE_DESCRIPTION(\"Synaptics Berlin reset controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}