{
  "module_name": "reset-simple.c",
  "hash_id": "def7a2ff80e22fa9b9d61c0dfc2ff8bbfc808076870eccf90488c96bc1378404",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-simple.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/reset/reset-simple.h>\n#include <linux/spinlock.h>\n\nstatic inline struct reset_simple_data *\nto_reset_simple_data(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct reset_simple_data, rcdev);\n}\n\nstatic int reset_simple_update(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id, bool assert)\n{\n\tstruct reset_simple_data *data = to_reset_simple_data(rcdev);\n\tint reg_width = sizeof(u32);\n\tint bank = id / (reg_width * BITS_PER_BYTE);\n\tint offset = id % (reg_width * BITS_PER_BYTE);\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\n\treg = readl(data->membase + (bank * reg_width));\n\tif (assert ^ data->active_low)\n\t\treg |= BIT(offset);\n\telse\n\t\treg &= ~BIT(offset);\n\twritel(reg, data->membase + (bank * reg_width));\n\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\treturn 0;\n}\n\nstatic int reset_simple_assert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\treturn reset_simple_update(rcdev, id, true);\n}\n\nstatic int reset_simple_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\treturn reset_simple_update(rcdev, id, false);\n}\n\nstatic int reset_simple_reset(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct reset_simple_data *data = to_reset_simple_data(rcdev);\n\tint ret;\n\n\tif (!data->reset_us)\n\t\treturn -ENOTSUPP;\n\n\tret = reset_simple_assert(rcdev, id);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(data->reset_us, data->reset_us * 2);\n\n\treturn reset_simple_deassert(rcdev, id);\n}\n\nstatic int reset_simple_status(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct reset_simple_data *data = to_reset_simple_data(rcdev);\n\tint reg_width = sizeof(u32);\n\tint bank = id / (reg_width * BITS_PER_BYTE);\n\tint offset = id % (reg_width * BITS_PER_BYTE);\n\tu32 reg;\n\n\treg = readl(data->membase + (bank * reg_width));\n\n\treturn !(reg & BIT(offset)) ^ !data->status_active_low;\n}\n\nconst struct reset_control_ops reset_simple_ops = {\n\t.assert\t\t= reset_simple_assert,\n\t.deassert\t= reset_simple_deassert,\n\t.reset\t\t= reset_simple_reset,\n\t.status\t\t= reset_simple_status,\n};\nEXPORT_SYMBOL_GPL(reset_simple_ops);\n\n \nstruct reset_simple_devdata {\n\tu32 reg_offset;\n\tu32 nr_resets;\n\tbool active_low;\n\tbool status_active_low;\n};\n\n#define SOCFPGA_NR_BANKS\t8\n\nstatic const struct reset_simple_devdata reset_simple_socfpga = {\n\t.reg_offset = 0x20,\n\t.nr_resets = SOCFPGA_NR_BANKS * 32,\n\t.status_active_low = true,\n};\n\nstatic const struct reset_simple_devdata reset_simple_active_low = {\n\t.active_low = true,\n\t.status_active_low = true,\n};\n\nstatic const struct of_device_id reset_simple_dt_ids[] = {\n\t{ .compatible = \"altr,stratix10-rst-mgr\",\n\t\t.data = &reset_simple_socfpga },\n\t{ .compatible = \"st,stm32-rcc\", },\n\t{ .compatible = \"allwinner,sun6i-a31-clock-reset\",\n\t\t.data = &reset_simple_active_low },\n\t{ .compatible = \"zte,zx296718-reset\",\n\t\t.data = &reset_simple_active_low },\n\t{ .compatible = \"aspeed,ast2400-lpc-reset\" },\n\t{ .compatible = \"aspeed,ast2500-lpc-reset\" },\n\t{ .compatible = \"aspeed,ast2600-lpc-reset\" },\n\t{ .compatible = \"bitmain,bm1880-reset\",\n\t\t.data = &reset_simple_active_low },\n\t{ .compatible = \"brcm,bcm4908-misc-pcie-reset\",\n\t\t.data = &reset_simple_active_low },\n\t{ .compatible = \"snps,dw-high-reset\" },\n\t{ .compatible = \"snps,dw-low-reset\",\n\t\t.data = &reset_simple_active_low },\n\t{   },\n};\n\nstatic int reset_simple_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct reset_simple_devdata *devdata;\n\tstruct reset_simple_data *data;\n\tvoid __iomem *membase;\n\tstruct resource *res;\n\tu32 reg_offset = 0;\n\n\tdevdata = of_device_get_match_data(dev);\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tmembase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(membase))\n\t\treturn PTR_ERR(membase);\n\n\tspin_lock_init(&data->lock);\n\tdata->membase = membase;\n\tdata->rcdev.owner = THIS_MODULE;\n\tdata->rcdev.nr_resets = resource_size(res) * BITS_PER_BYTE;\n\tdata->rcdev.ops = &reset_simple_ops;\n\tdata->rcdev.of_node = dev->of_node;\n\n\tif (devdata) {\n\t\treg_offset = devdata->reg_offset;\n\t\tif (devdata->nr_resets)\n\t\t\tdata->rcdev.nr_resets = devdata->nr_resets;\n\t\tdata->active_low = devdata->active_low;\n\t\tdata->status_active_low = devdata->status_active_low;\n\t}\n\n\tdata->membase += reg_offset;\n\n\treturn devm_reset_controller_register(dev, &data->rcdev);\n}\n\nstatic struct platform_driver reset_simple_driver = {\n\t.probe\t= reset_simple_probe,\n\t.driver = {\n\t\t.name\t\t= \"simple-reset\",\n\t\t.of_match_table\t= reset_simple_dt_ids,\n\t},\n};\nbuiltin_platform_driver(reset_simple_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}