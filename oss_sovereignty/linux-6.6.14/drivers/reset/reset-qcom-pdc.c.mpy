{
  "module_name": "reset-qcom-pdc.c",
  "hash_id": "ad37c91ce928e6132ebc3878536840ad20af922b948e42c5ee4816d56be7d050",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-qcom-pdc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n\n#include <dt-bindings/reset/qcom,sdm845-pdc.h>\n\n#define RPMH_SDM845_PDC_SYNC_RESET\t0x100\n#define RPMH_SC7280_PDC_SYNC_RESET\t0x1000\n\nstruct qcom_pdc_reset_map {\n\tu8 bit;\n};\n\nstruct qcom_pdc_reset_desc {\n\tconst struct qcom_pdc_reset_map *resets;\n\tsize_t num_resets;\n\tunsigned int offset;\n};\n\nstruct qcom_pdc_reset_data {\n\tstruct reset_controller_dev rcdev;\n\tstruct regmap *regmap;\n\tconst struct qcom_pdc_reset_desc *desc;\n};\n\nstatic const struct regmap_config pdc_regmap_config = {\n\t.name\t\t= \"pdc-reset\",\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.max_register\t= 0x20000,\n\t.fast_io\t= true,\n};\n\nstatic const struct qcom_pdc_reset_map sdm845_pdc_resets[] = {\n\t[PDC_APPS_SYNC_RESET] = {0},\n\t[PDC_SP_SYNC_RESET] = {1},\n\t[PDC_AUDIO_SYNC_RESET] = {2},\n\t[PDC_SENSORS_SYNC_RESET] = {3},\n\t[PDC_AOP_SYNC_RESET] = {4},\n\t[PDC_DEBUG_SYNC_RESET] = {5},\n\t[PDC_GPU_SYNC_RESET] = {6},\n\t[PDC_DISPLAY_SYNC_RESET] = {7},\n\t[PDC_COMPUTE_SYNC_RESET] = {8},\n\t[PDC_MODEM_SYNC_RESET] = {9},\n};\n\nstatic const struct qcom_pdc_reset_desc sdm845_pdc_reset_desc = {\n\t.resets = sdm845_pdc_resets,\n\t.num_resets = ARRAY_SIZE(sdm845_pdc_resets),\n\t.offset = RPMH_SDM845_PDC_SYNC_RESET,\n};\n\nstatic const struct qcom_pdc_reset_map sc7280_pdc_resets[] = {\n\t[PDC_APPS_SYNC_RESET] = {0},\n\t[PDC_SP_SYNC_RESET] = {1},\n\t[PDC_AUDIO_SYNC_RESET] = {2},\n\t[PDC_SENSORS_SYNC_RESET] = {3},\n\t[PDC_AOP_SYNC_RESET] = {4},\n\t[PDC_DEBUG_SYNC_RESET] = {5},\n\t[PDC_GPU_SYNC_RESET] = {6},\n\t[PDC_DISPLAY_SYNC_RESET] = {7},\n\t[PDC_COMPUTE_SYNC_RESET] = {8},\n\t[PDC_MODEM_SYNC_RESET] = {9},\n\t[PDC_WLAN_RF_SYNC_RESET] = {10},\n\t[PDC_WPSS_SYNC_RESET] = {11},\n};\n\nstatic const struct qcom_pdc_reset_desc sc7280_pdc_reset_desc = {\n\t.resets = sc7280_pdc_resets,\n\t.num_resets = ARRAY_SIZE(sc7280_pdc_resets),\n\t.offset = RPMH_SC7280_PDC_SYNC_RESET,\n};\n\nstatic inline struct qcom_pdc_reset_data *to_qcom_pdc_reset_data(\n\t\t\t\tstruct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct qcom_pdc_reset_data, rcdev);\n}\n\nstatic int qcom_pdc_control_assert(struct reset_controller_dev *rcdev,\n\t\t\t\t\tunsigned long idx)\n{\n\tstruct qcom_pdc_reset_data *data = to_qcom_pdc_reset_data(rcdev);\n\tu32 mask = BIT(data->desc->resets[idx].bit);\n\n\treturn regmap_update_bits(data->regmap, data->desc->offset, mask, mask);\n}\n\nstatic int qcom_pdc_control_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t\tunsigned long idx)\n{\n\tstruct qcom_pdc_reset_data *data = to_qcom_pdc_reset_data(rcdev);\n\tu32 mask = BIT(data->desc->resets[idx].bit);\n\n\treturn regmap_update_bits(data->regmap, data->desc->offset, mask, 0);\n}\n\nstatic const struct reset_control_ops qcom_pdc_reset_ops = {\n\t.assert = qcom_pdc_control_assert,\n\t.deassert = qcom_pdc_control_deassert,\n};\n\nstatic int qcom_pdc_reset_probe(struct platform_device *pdev)\n{\n\tconst struct qcom_pdc_reset_desc *desc;\n\tstruct qcom_pdc_reset_data *data;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *base;\n\tstruct resource *res;\n\n\tdesc = device_get_match_data(&pdev->dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->desc = desc;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdata->regmap = devm_regmap_init_mmio(dev, base, &pdc_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(dev, \"Unable to initialize regmap\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\tdata->rcdev.owner = THIS_MODULE;\n\tdata->rcdev.ops = &qcom_pdc_reset_ops;\n\tdata->rcdev.nr_resets = desc->num_resets;\n\tdata->rcdev.of_node = dev->of_node;\n\n\treturn devm_reset_controller_register(dev, &data->rcdev);\n}\n\nstatic const struct of_device_id qcom_pdc_reset_of_match[] = {\n\t{ .compatible = \"qcom,sc7280-pdc-global\", .data = &sc7280_pdc_reset_desc },\n\t{ .compatible = \"qcom,sdm845-pdc-global\", .data = &sdm845_pdc_reset_desc },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qcom_pdc_reset_of_match);\n\nstatic struct platform_driver qcom_pdc_reset_driver = {\n\t.probe = qcom_pdc_reset_probe,\n\t.driver = {\n\t\t.name = \"qcom_pdc_reset\",\n\t\t.of_match_table = qcom_pdc_reset_of_match,\n\t},\n};\nmodule_platform_driver(qcom_pdc_reset_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm PDC Reset Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}