{
  "module_name": "reset-lantiq.c",
  "hash_id": "e9e6e1af2b1cebfb75dd535c5c95f878b3d45b0808282eddb56ac1a6d293a79b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-lantiq.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#define LANTIQ_RCU_RESET_TIMEOUT\t10000\n\nstruct lantiq_rcu_reset_priv {\n\tstruct reset_controller_dev rcdev;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tu32 reset_offset;\n\tu32 status_offset;\n};\n\nstatic struct lantiq_rcu_reset_priv *to_lantiq_rcu_reset_priv(\n\tstruct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct lantiq_rcu_reset_priv, rcdev);\n}\n\nstatic int lantiq_rcu_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t\t   unsigned long id)\n{\n\tstruct lantiq_rcu_reset_priv *priv = to_lantiq_rcu_reset_priv(rcdev);\n\tunsigned int status = (id >> 8) & 0x1f;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, priv->status_offset, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & BIT(status));\n}\n\nstatic int lantiq_rcu_reset_status_timeout(struct reset_controller_dev *rcdev,\n\t\t\t\t\t   unsigned long id, bool assert)\n{\n\tint ret;\n\tint retry = LANTIQ_RCU_RESET_TIMEOUT;\n\n\tdo {\n\t\tret = lantiq_rcu_reset_status(rcdev, id);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == assert)\n\t\t\treturn 0;\n\t\tusleep_range(20, 40);\n\t} while (--retry);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int lantiq_rcu_reset_update(struct reset_controller_dev *rcdev,\n\t\t\t\t   unsigned long id, bool assert)\n{\n\tstruct lantiq_rcu_reset_priv *priv = to_lantiq_rcu_reset_priv(rcdev);\n\tunsigned int set = id & 0x1f;\n\tu32 val = assert ? BIT(set) : 0;\n\tint ret;\n\n\tret = regmap_update_bits(priv->regmap, priv->reset_offset, BIT(set),\n\t\t\t\t val);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to set reset bit %u\\n\", set);\n\t\treturn ret;\n\t}\n\n\n\tret = lantiq_rcu_reset_status_timeout(rcdev, id, assert);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to %s bit %u\\n\",\n\t\t\tassert ? \"assert\" : \"deassert\", set);\n\n\treturn ret;\n}\n\nstatic int lantiq_rcu_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\treturn lantiq_rcu_reset_update(rcdev, id, true);\n}\n\nstatic int lantiq_rcu_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\treturn lantiq_rcu_reset_update(rcdev, id, false);\n}\n\nstatic int lantiq_rcu_reset_reset(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id)\n{\n\tint ret;\n\n\tret = lantiq_rcu_reset_assert(rcdev, id);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lantiq_rcu_reset_deassert(rcdev, id);\n}\n\nstatic const struct reset_control_ops lantiq_rcu_reset_ops = {\n\t.assert = lantiq_rcu_reset_assert,\n\t.deassert = lantiq_rcu_reset_deassert,\n\t.status = lantiq_rcu_reset_status,\n\t.reset\t= lantiq_rcu_reset_reset,\n};\n\nstatic int lantiq_rcu_reset_of_parse(struct platform_device *pdev,\n\t\t\t       struct lantiq_rcu_reset_priv *priv)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst __be32 *offset;\n\n\tpriv->regmap = syscon_node_to_regmap(dev->of_node->parent);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(&pdev->dev, \"Failed to lookup RCU regmap\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\toffset = of_get_address(dev->of_node, 0, NULL, NULL);\n\tif (!offset) {\n\t\tdev_err(&pdev->dev, \"Failed to get RCU reset offset\\n\");\n\t\treturn -ENOENT;\n\t}\n\tpriv->reset_offset = __be32_to_cpu(*offset);\n\n\toffset = of_get_address(dev->of_node, 1, NULL, NULL);\n\tif (!offset) {\n\t\tdev_err(&pdev->dev, \"Failed to get RCU status offset\\n\");\n\t\treturn -ENOENT;\n\t}\n\tpriv->status_offset = __be32_to_cpu(*offset);\n\n\treturn 0;\n}\n\nstatic int lantiq_rcu_reset_xlate(struct reset_controller_dev *rcdev,\n\t\t\t\t  const struct of_phandle_args *reset_spec)\n{\n\tunsigned int status, set;\n\n\tset = reset_spec->args[0];\n\tstatus = reset_spec->args[1];\n\n\tif (set >= rcdev->nr_resets || status >= rcdev->nr_resets)\n\t\treturn -EINVAL;\n\n\treturn (status << 8) | set;\n}\n\nstatic int lantiq_rcu_reset_probe(struct platform_device *pdev)\n{\n\tstruct lantiq_rcu_reset_priv *priv;\n\tint err;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\n\terr = lantiq_rcu_reset_of_parse(pdev, priv);\n\tif (err)\n\t\treturn err;\n\n\tpriv->rcdev.ops = &lantiq_rcu_reset_ops;\n\tpriv->rcdev.owner = THIS_MODULE;\n\tpriv->rcdev.of_node = pdev->dev.of_node;\n\tpriv->rcdev.nr_resets = 32;\n\tpriv->rcdev.of_xlate = lantiq_rcu_reset_xlate;\n\tpriv->rcdev.of_reset_n_cells = 2;\n\n\treturn devm_reset_controller_register(&pdev->dev, &priv->rcdev);\n}\n\nstatic const struct of_device_id lantiq_rcu_reset_dt_ids[] = {\n\t{ .compatible = \"lantiq,danube-reset\", },\n\t{ .compatible = \"lantiq,xrx200-reset\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, lantiq_rcu_reset_dt_ids);\n\nstatic struct platform_driver lantiq_rcu_reset_driver = {\n\t.probe\t= lantiq_rcu_reset_probe,\n\t.driver = {\n\t\t.name\t\t= \"lantiq-reset\",\n\t\t.of_match_table\t= lantiq_rcu_reset_dt_ids,\n\t},\n};\nmodule_platform_driver(lantiq_rcu_reset_driver);\n\nMODULE_AUTHOR(\"Martin Blumenstingl <martin.blumenstingl@googlemail.com>\");\nMODULE_DESCRIPTION(\"Lantiq XWAY RCU Reset Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}