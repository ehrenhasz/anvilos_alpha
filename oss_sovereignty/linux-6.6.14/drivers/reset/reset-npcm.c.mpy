{
  "module_name": "reset-npcm.c",
  "hash_id": "bf6e719d4d0fe0b3c25d1193c24e0176c69b9bba4e93566de66240fb512dd0a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-npcm.c",
  "human_readable_source": "\n\n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/reset-controller.h>\n#include <linux/spinlock.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/of_address.h>\n\n \n#define NPCM_MDLR_OFFSET\t0x7C\n#define NPCM7XX_MDLR_USBD0\tBIT(9)\n#define NPCM7XX_MDLR_USBD1\tBIT(8)\n#define NPCM7XX_MDLR_USBD2_4\tBIT(21)\n#define NPCM7XX_MDLR_USBD5_9\tBIT(22)\n\n \n#define NPCM8XX_MDLR_USBD0_3\tBIT(9)\n#define NPCM8XX_MDLR_USBD4_7\tBIT(22)\n#define NPCM8XX_MDLR_USBD8\tBIT(24)\n#define NPCM8XX_MDLR_USBD9\tBIT(21)\n\n#define NPCM_USB1PHYCTL_OFFSET\t0x140\n#define NPCM_USB2PHYCTL_OFFSET\t0x144\n#define NPCM_USB3PHYCTL_OFFSET\t0x148\n#define NPCM_USBXPHYCTL_RS\tBIT(28)\n\n \n#define NPCM_SWRSTR\t\t0x14\n#define NPCM_SWRST\t\tBIT(2)\n\n#define NPCM_IPSRST1\t\t0x20\n#define NPCM_IPSRST1_USBD1\tBIT(5)\n#define NPCM_IPSRST1_USBD2\tBIT(8)\n#define NPCM_IPSRST1_USBD3\tBIT(25)\n#define NPCM_IPSRST1_USBD4\tBIT(22)\n#define NPCM_IPSRST1_USBD5\tBIT(23)\n#define NPCM_IPSRST1_USBD6\tBIT(24)\n\n#define NPCM_IPSRST2\t\t0x24\n#define NPCM_IPSRST2_USB_HOST\tBIT(26)\n\n#define NPCM_IPSRST3\t\t0x34\n#define NPCM_IPSRST3_USBD0\tBIT(4)\n#define NPCM_IPSRST3_USBD7\tBIT(5)\n#define NPCM_IPSRST3_USBD8\tBIT(6)\n#define NPCM_IPSRST3_USBD9\tBIT(7)\n#define NPCM_IPSRST3_USBPHY1\tBIT(24)\n#define NPCM_IPSRST3_USBPHY2\tBIT(25)\n\n#define NPCM_IPSRST4\t\t0x74\n#define NPCM_IPSRST4_USBPHY3\tBIT(25)\n#define NPCM_IPSRST4_USB_HOST2\tBIT(31)\n\n#define NPCM_RC_RESETS_PER_REG\t32\n#define NPCM_MASK_RESETS\tGENMASK(4, 0)\n\nenum {\n\tBMC_NPCM7XX = 0,\n\tBMC_NPCM8XX,\n};\n\nstatic const u32 npxm7xx_ipsrst[] = {NPCM_IPSRST1, NPCM_IPSRST2, NPCM_IPSRST3};\nstatic const u32 npxm8xx_ipsrst[] = {NPCM_IPSRST1, NPCM_IPSRST2, NPCM_IPSRST3,\n\tNPCM_IPSRST4};\n\nstruct npcm_reset_info {\n\tu32 bmc_id;\n\tu32 num_ipsrst;\n\tconst u32 *ipsrst;\n};\n\nstatic const struct npcm_reset_info npxm7xx_reset_info[] = {\n\t{.bmc_id = BMC_NPCM7XX, .num_ipsrst = 3, .ipsrst = npxm7xx_ipsrst}};\nstatic const struct npcm_reset_info npxm8xx_reset_info[] = {\n\t{.bmc_id = BMC_NPCM8XX, .num_ipsrst = 4, .ipsrst = npxm8xx_ipsrst}};\n\nstruct npcm_rc_data {\n\tstruct reset_controller_dev rcdev;\n\tstruct notifier_block restart_nb;\n\tconst struct npcm_reset_info *info;\n\tstruct regmap *gcr_regmap;\n\tu32 sw_reset_number;\n\tvoid __iomem *base;\n\tspinlock_t lock;\n};\n\n#define to_rc_data(p) container_of(p, struct npcm_rc_data, rcdev)\n\nstatic int npcm_rc_restart(struct notifier_block *nb, unsigned long mode,\n\t\t\t   void *cmd)\n{\n\tstruct npcm_rc_data *rc = container_of(nb, struct npcm_rc_data,\n\t\t\t\t\t       restart_nb);\n\n\twritel(NPCM_SWRST << rc->sw_reset_number, rc->base + NPCM_SWRSTR);\n\tmdelay(1000);\n\n\tpr_emerg(\"%s: unable to restart system\\n\", __func__);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int npcm_rc_setclear_reset(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id, bool set)\n{\n\tstruct npcm_rc_data *rc = to_rc_data(rcdev);\n\tunsigned int rst_bit = BIT(id & NPCM_MASK_RESETS);\n\tunsigned int ctrl_offset = id >> 8;\n\tunsigned long flags;\n\tu32 stat;\n\n\tspin_lock_irqsave(&rc->lock, flags);\n\tstat = readl(rc->base + ctrl_offset);\n\tif (set)\n\t\twritel(stat | rst_bit, rc->base + ctrl_offset);\n\telse\n\t\twritel(stat & ~rst_bit, rc->base + ctrl_offset);\n\tspin_unlock_irqrestore(&rc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int npcm_rc_assert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\treturn npcm_rc_setclear_reset(rcdev, id, true);\n}\n\nstatic int npcm_rc_deassert(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id)\n{\n\treturn npcm_rc_setclear_reset(rcdev, id, false);\n}\n\nstatic int npcm_rc_status(struct reset_controller_dev *rcdev,\n\t\t\t  unsigned long id)\n{\n\tstruct npcm_rc_data *rc = to_rc_data(rcdev);\n\tunsigned int rst_bit = BIT(id & NPCM_MASK_RESETS);\n\tunsigned int ctrl_offset = id >> 8;\n\n\treturn (readl(rc->base + ctrl_offset) & rst_bit);\n}\n\nstatic int npcm_reset_xlate(struct reset_controller_dev *rcdev,\n\t\t\t    const struct of_phandle_args *reset_spec)\n{\n\tstruct npcm_rc_data *rc = to_rc_data(rcdev);\n\tunsigned int offset, bit;\n\tbool offset_found = false;\n\tint off_num;\n\n\toffset = reset_spec->args[0];\n\tfor (off_num = 0 ; off_num < rc->info->num_ipsrst ; off_num++) {\n\t\tif (offset == rc->info->ipsrst[off_num]) {\n\t\t\toffset_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!offset_found) {\n\t\tdev_err(rcdev->dev, \"Error reset register (0x%x)\\n\", offset);\n\t\treturn -EINVAL;\n\t}\n\n\tbit = reset_spec->args[1];\n\tif (bit >= NPCM_RC_RESETS_PER_REG) {\n\t\tdev_err(rcdev->dev, \"Error reset number (%d)\\n\", bit);\n\t\treturn -EINVAL;\n\t}\n\n\treturn (offset << 8) | bit;\n}\n\nstatic const struct of_device_id npcm_rc_match[] = {\n\t{ .compatible = \"nuvoton,npcm750-reset\", .data = &npxm7xx_reset_info},\n\t{ .compatible = \"nuvoton,npcm845-reset\", .data = &npxm8xx_reset_info},\n\t{ }\n};\n\nstatic void npcm_usb_reset_npcm7xx(struct npcm_rc_data *rc)\n{\n\tu32 mdlr, iprst1, iprst2, iprst3;\n\tu32 ipsrst1_bits = 0;\n\tu32 ipsrst2_bits = NPCM_IPSRST2_USB_HOST;\n\tu32 ipsrst3_bits = 0;\n\n\t \n\tregmap_read(rc->gcr_regmap, NPCM_MDLR_OFFSET, &mdlr);\n\tif (!(mdlr & NPCM7XX_MDLR_USBD0))\n\t\tipsrst3_bits |= NPCM_IPSRST3_USBD0;\n\tif (!(mdlr & NPCM7XX_MDLR_USBD1))\n\t\tipsrst1_bits |= NPCM_IPSRST1_USBD1;\n\tif (!(mdlr & NPCM7XX_MDLR_USBD2_4))\n\t\tipsrst1_bits |= (NPCM_IPSRST1_USBD2 |\n\t\t\t\t NPCM_IPSRST1_USBD3 |\n\t\t\t\t NPCM_IPSRST1_USBD4);\n\tif (!(mdlr & NPCM7XX_MDLR_USBD0)) {\n\t\tipsrst1_bits |= (NPCM_IPSRST1_USBD5 |\n\t\t\t\t NPCM_IPSRST1_USBD6);\n\t\tipsrst3_bits |= (NPCM_IPSRST3_USBD7 |\n\t\t\t\t NPCM_IPSRST3_USBD8 |\n\t\t\t\t NPCM_IPSRST3_USBD9);\n\t}\n\n\t \n\tiprst1 = readl(rc->base + NPCM_IPSRST1);\n\tiprst2 = readl(rc->base + NPCM_IPSRST2);\n\tiprst3 = readl(rc->base + NPCM_IPSRST3);\n\n\tiprst1 |= ipsrst1_bits;\n\tiprst2 |= ipsrst2_bits;\n\tiprst3 |= (ipsrst3_bits | NPCM_IPSRST3_USBPHY1 |\n\t\t   NPCM_IPSRST3_USBPHY2);\n\n\twritel(iprst1, rc->base + NPCM_IPSRST1);\n\twritel(iprst2, rc->base + NPCM_IPSRST2);\n\twritel(iprst3, rc->base + NPCM_IPSRST3);\n\n\t \n\tregmap_update_bits(rc->gcr_regmap, NPCM_USB1PHYCTL_OFFSET,\n\t\t\t   NPCM_USBXPHYCTL_RS, 0);\n\tregmap_update_bits(rc->gcr_regmap, NPCM_USB2PHYCTL_OFFSET,\n\t\t\t   NPCM_USBXPHYCTL_RS, 0);\n\n\t \n\tiprst3 &= ~(NPCM_IPSRST3_USBPHY1 | NPCM_IPSRST3_USBPHY2);\n\twritel(iprst3, rc->base + NPCM_IPSRST3);\n\n\tudelay(50);\n\n\t \n\tregmap_update_bits(rc->gcr_regmap, NPCM_USB1PHYCTL_OFFSET,\n\t\t\t   NPCM_USBXPHYCTL_RS, NPCM_USBXPHYCTL_RS);\n\tregmap_update_bits(rc->gcr_regmap, NPCM_USB2PHYCTL_OFFSET,\n\t\t\t   NPCM_USBXPHYCTL_RS, NPCM_USBXPHYCTL_RS);\n\n\t \n\tiprst1 &= ~ipsrst1_bits;\n\tiprst2 &= ~ipsrst2_bits;\n\tiprst3 &= ~ipsrst3_bits;\n\n\twritel(iprst1, rc->base + NPCM_IPSRST1);\n\twritel(iprst2, rc->base + NPCM_IPSRST2);\n\twritel(iprst3, rc->base + NPCM_IPSRST3);\n}\n\nstatic void npcm_usb_reset_npcm8xx(struct npcm_rc_data *rc)\n{\n\tu32 mdlr, iprst1, iprst2, iprst3, iprst4;\n\tu32 ipsrst1_bits = 0;\n\tu32 ipsrst2_bits = NPCM_IPSRST2_USB_HOST;\n\tu32 ipsrst3_bits = 0;\n\tu32 ipsrst4_bits = NPCM_IPSRST4_USB_HOST2 | NPCM_IPSRST4_USBPHY3;\n\n\t \n\tregmap_read(rc->gcr_regmap, NPCM_MDLR_OFFSET, &mdlr);\n\tif (!(mdlr & NPCM8XX_MDLR_USBD0_3)) {\n\t\tipsrst3_bits |= NPCM_IPSRST3_USBD0;\n\t\tipsrst1_bits |= (NPCM_IPSRST1_USBD1 |\n\t\t\t\t NPCM_IPSRST1_USBD2 |\n\t\t\t\t NPCM_IPSRST1_USBD3);\n\t}\n\tif (!(mdlr & NPCM8XX_MDLR_USBD4_7)) {\n\t\tipsrst1_bits |= (NPCM_IPSRST1_USBD4 |\n\t\t\t\t NPCM_IPSRST1_USBD5 |\n\t\t\t\t NPCM_IPSRST1_USBD6);\n\t\tipsrst3_bits |= NPCM_IPSRST3_USBD7;\n\t}\n\n\tif (!(mdlr & NPCM8XX_MDLR_USBD8))\n\t\tipsrst3_bits |= NPCM_IPSRST3_USBD8;\n\tif (!(mdlr & NPCM8XX_MDLR_USBD9))\n\t\tipsrst3_bits |= NPCM_IPSRST3_USBD9;\n\n\t \n\tiprst1 = readl(rc->base + NPCM_IPSRST1);\n\tiprst2 = readl(rc->base + NPCM_IPSRST2);\n\tiprst3 = readl(rc->base + NPCM_IPSRST3);\n\tiprst4 = readl(rc->base + NPCM_IPSRST4);\n\n\tiprst1 |= ipsrst1_bits;\n\tiprst2 |= ipsrst2_bits;\n\tiprst3 |= (ipsrst3_bits | NPCM_IPSRST3_USBPHY1 |\n\t\t   NPCM_IPSRST3_USBPHY2);\n\tiprst4 |= ipsrst4_bits;\n\n\twritel(iprst1, rc->base + NPCM_IPSRST1);\n\twritel(iprst2, rc->base + NPCM_IPSRST2);\n\twritel(iprst3, rc->base + NPCM_IPSRST3);\n\twritel(iprst4, rc->base + NPCM_IPSRST4);\n\n\t \n\tregmap_update_bits(rc->gcr_regmap, NPCM_USB1PHYCTL_OFFSET,\n\t\t\t   NPCM_USBXPHYCTL_RS, 0);\n\tregmap_update_bits(rc->gcr_regmap, NPCM_USB2PHYCTL_OFFSET,\n\t\t\t   NPCM_USBXPHYCTL_RS, 0);\n\tregmap_update_bits(rc->gcr_regmap, NPCM_USB3PHYCTL_OFFSET,\n\t\t\t   NPCM_USBXPHYCTL_RS, 0);\n\n\t \n\tiprst3 &= ~(NPCM_IPSRST3_USBPHY1 | NPCM_IPSRST3_USBPHY2);\n\twritel(iprst3, rc->base + NPCM_IPSRST3);\n\tiprst4 &= ~NPCM_IPSRST4_USBPHY3;\n\twritel(iprst4, rc->base + NPCM_IPSRST4);\n\n\t \n\tregmap_update_bits(rc->gcr_regmap, NPCM_USB1PHYCTL_OFFSET,\n\t\t\t   NPCM_USBXPHYCTL_RS, NPCM_USBXPHYCTL_RS);\n\tregmap_update_bits(rc->gcr_regmap, NPCM_USB2PHYCTL_OFFSET,\n\t\t\t   NPCM_USBXPHYCTL_RS, NPCM_USBXPHYCTL_RS);\n\tregmap_update_bits(rc->gcr_regmap, NPCM_USB3PHYCTL_OFFSET,\n\t\t\t   NPCM_USBXPHYCTL_RS, NPCM_USBXPHYCTL_RS);\n\n\t \n\tiprst1 &= ~ipsrst1_bits;\n\tiprst2 &= ~ipsrst2_bits;\n\tiprst3 &= ~ipsrst3_bits;\n\tiprst4 &= ~ipsrst4_bits;\n\n\twritel(iprst1, rc->base + NPCM_IPSRST1);\n\twritel(iprst2, rc->base + NPCM_IPSRST2);\n\twritel(iprst3, rc->base + NPCM_IPSRST3);\n\twritel(iprst4, rc->base + NPCM_IPSRST4);\n}\n\n \nstatic int npcm_usb_reset(struct platform_device *pdev, struct npcm_rc_data *rc)\n{\n\tstruct device *dev = &pdev->dev;\n\n\trc->gcr_regmap = syscon_regmap_lookup_by_phandle(dev->of_node, \"nuvoton,sysgcr\");\n\tif (IS_ERR(rc->gcr_regmap)) {\n\t\tdev_warn(&pdev->dev, \"Failed to find nuvoton,sysgcr property, please update the device tree\\n\");\n\t\tdev_info(&pdev->dev, \"Using nuvoton,npcm750-gcr for Poleg backward compatibility\\n\");\n\t\trc->gcr_regmap = syscon_regmap_lookup_by_compatible(\"nuvoton,npcm750-gcr\");\n\t\tif (IS_ERR(rc->gcr_regmap)) {\n\t\t\tdev_err(&pdev->dev, \"Failed to find nuvoton,npcm750-gcr\");\n\t\t\treturn PTR_ERR(rc->gcr_regmap);\n\t\t}\n\t}\n\n\trc->info = (const struct npcm_reset_info *)\n\t\t\tof_match_device(dev->driver->of_match_table, dev)->data;\n\tswitch (rc->info->bmc_id) {\n\tcase BMC_NPCM7XX:\n\t\tnpcm_usb_reset_npcm7xx(rc);\n\t\tbreak;\n\tcase BMC_NPCM8XX:\n\t\tnpcm_usb_reset_npcm8xx(rc);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct reset_control_ops npcm_rc_ops = {\n\t.assert\t\t= npcm_rc_assert,\n\t.deassert\t= npcm_rc_deassert,\n\t.status\t\t= npcm_rc_status,\n};\n\nstatic int npcm_rc_probe(struct platform_device *pdev)\n{\n\tstruct npcm_rc_data *rc;\n\tint ret;\n\n\trc = devm_kzalloc(&pdev->dev, sizeof(*rc), GFP_KERNEL);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\n\trc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rc->base))\n\t\treturn PTR_ERR(rc->base);\n\n\tspin_lock_init(&rc->lock);\n\n\trc->rcdev.owner = THIS_MODULE;\n\trc->rcdev.ops = &npcm_rc_ops;\n\trc->rcdev.of_node = pdev->dev.of_node;\n\trc->rcdev.of_reset_n_cells = 2;\n\trc->rcdev.of_xlate = npcm_reset_xlate;\n\n\tret = devm_reset_controller_register(&pdev->dev, &rc->rcdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to register device\\n\");\n\t\treturn ret;\n\t}\n\n\tif (npcm_usb_reset(pdev, rc))\n\t\tdev_warn(&pdev->dev, \"NPCM USB reset failed, can cause issues with UDC and USB host\\n\");\n\n\tif (!of_property_read_u32(pdev->dev.of_node, \"nuvoton,sw-reset-number\",\n\t\t\t\t  &rc->sw_reset_number)) {\n\t\tif (rc->sw_reset_number && rc->sw_reset_number < 5) {\n\t\t\trc->restart_nb.priority = 192,\n\t\t\trc->restart_nb.notifier_call = npcm_rc_restart,\n\t\t\tret = register_restart_handler(&rc->restart_nb);\n\t\t\tif (ret)\n\t\t\t\tdev_warn(&pdev->dev, \"failed to register restart handler\\n\");\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic struct platform_driver npcm_rc_driver = {\n\t.probe\t= npcm_rc_probe,\n\t.driver\t= {\n\t\t.name\t\t\t= \"npcm-reset\",\n\t\t.of_match_table\t\t= npcm_rc_match,\n\t\t.suppress_bind_attrs\t= true,\n\t},\n};\nbuiltin_platform_driver(npcm_rc_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}