{
  "module_name": "reset-ath79.c",
  "hash_id": "8a8e5b657231fbb078d490f79d15fee8cb461aa2e7566cf5db30e5ef068fcc55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-ath79.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/reboot.h>\n\nstruct ath79_reset {\n\tstruct reset_controller_dev rcdev;\n\tstruct notifier_block restart_nb;\n\tvoid __iomem *base;\n\tspinlock_t lock;\n};\n\n#define FULL_CHIP_RESET 24\n\nstatic int ath79_reset_update(struct reset_controller_dev *rcdev,\n\t\t\tunsigned long id, bool assert)\n{\n\tstruct ath79_reset *ath79_reset =\n\t\tcontainer_of(rcdev, struct ath79_reset, rcdev);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&ath79_reset->lock, flags);\n\tval = readl(ath79_reset->base);\n\tif (assert)\n\t\tval |= BIT(id);\n\telse\n\t\tval &= ~BIT(id);\n\twritel(val, ath79_reset->base);\n\tspin_unlock_irqrestore(&ath79_reset->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ath79_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\tunsigned long id)\n{\n\treturn ath79_reset_update(rcdev, id, true);\n}\n\nstatic int ath79_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\treturn ath79_reset_update(rcdev, id, false);\n}\n\nstatic int ath79_reset_status(struct reset_controller_dev *rcdev,\n\t\t\tunsigned long id)\n{\n\tstruct ath79_reset *ath79_reset =\n\t\tcontainer_of(rcdev, struct ath79_reset, rcdev);\n\tu32 val;\n\n\tval = readl(ath79_reset->base);\n\n\treturn !!(val & BIT(id));\n}\n\nstatic const struct reset_control_ops ath79_reset_ops = {\n\t.assert = ath79_reset_assert,\n\t.deassert = ath79_reset_deassert,\n\t.status = ath79_reset_status,\n};\n\nstatic int ath79_reset_restart_handler(struct notifier_block *nb,\n\t\t\t\tunsigned long action, void *data)\n{\n\tstruct ath79_reset *ath79_reset =\n\t\tcontainer_of(nb, struct ath79_reset, restart_nb);\n\n\tath79_reset_assert(&ath79_reset->rcdev, FULL_CHIP_RESET);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int ath79_reset_probe(struct platform_device *pdev)\n{\n\tstruct ath79_reset *ath79_reset;\n\tint err;\n\n\tath79_reset = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(*ath79_reset), GFP_KERNEL);\n\tif (!ath79_reset)\n\t\treturn -ENOMEM;\n\n\tath79_reset->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ath79_reset->base))\n\t\treturn PTR_ERR(ath79_reset->base);\n\n\tspin_lock_init(&ath79_reset->lock);\n\tath79_reset->rcdev.ops = &ath79_reset_ops;\n\tath79_reset->rcdev.owner = THIS_MODULE;\n\tath79_reset->rcdev.of_node = pdev->dev.of_node;\n\tath79_reset->rcdev.of_reset_n_cells = 1;\n\tath79_reset->rcdev.nr_resets = 32;\n\n\terr = devm_reset_controller_register(&pdev->dev, &ath79_reset->rcdev);\n\tif (err)\n\t\treturn err;\n\n\tath79_reset->restart_nb.notifier_call = ath79_reset_restart_handler;\n\tath79_reset->restart_nb.priority = 128;\n\n\terr = register_restart_handler(&ath79_reset->restart_nb);\n\tif (err)\n\t\tdev_warn(&pdev->dev, \"Failed to register restart handler\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ath79_reset_dt_ids[] = {\n\t{ .compatible = \"qca,ar7100-reset\", },\n\t{ },\n};\n\nstatic struct platform_driver ath79_reset_driver = {\n\t.probe\t= ath79_reset_probe,\n\t.driver = {\n\t\t.name\t\t\t= \"ath79-reset\",\n\t\t.of_match_table\t\t= ath79_reset_dt_ids,\n\t\t.suppress_bind_attrs\t= true,\n\t},\n};\nbuiltin_platform_driver(ath79_reset_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}