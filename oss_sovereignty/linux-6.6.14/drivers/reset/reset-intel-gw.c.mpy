{
  "module_name": "reset-intel-gw.c",
  "hash_id": "58cf23306a2492dbee8d9a5d776ce6670fcad4d1dca3ff971ec679c516dcfba4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-intel-gw.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n\n#define RCU_RST_STAT\t0x0024\n#define RCU_RST_REQ\t0x0048\n\n#define REG_OFFSET_MASK\tGENMASK(31, 16)\n#define BIT_OFFSET_MASK\tGENMASK(15, 8)\n#define STAT_BIT_OFFSET_MASK\tGENMASK(7, 0)\n\n#define to_reset_data(x)\tcontainer_of(x, struct intel_reset_data, rcdev)\n\nstruct intel_reset_soc {\n\tbool legacy;\n\tu32 reset_cell_count;\n};\n\nstruct intel_reset_data {\n\tstruct reset_controller_dev rcdev;\n\tstruct notifier_block restart_nb;\n\tconst struct intel_reset_soc *soc_data;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tu32 reboot_id;\n};\n\nstatic const struct regmap_config intel_rcu_regmap_config = {\n\t.name =\t\t\"intel-reset\",\n\t.reg_bits =\t32,\n\t.reg_stride =\t4,\n\t.val_bits =\t32,\n\t.fast_io =\ttrue,\n};\n\n \nstatic u32 id_to_reg_and_bit_offsets(struct intel_reset_data *data,\n\t\t\t\t     unsigned long id, u32 *rst_req,\n\t\t\t\t     u32 *req_bit, u32 *stat_bit)\n{\n\t*rst_req = FIELD_GET(REG_OFFSET_MASK, id);\n\t*req_bit = FIELD_GET(BIT_OFFSET_MASK, id);\n\n\tif (data->soc_data->legacy)\n\t\t*stat_bit = FIELD_GET(STAT_BIT_OFFSET_MASK, id);\n\telse\n\t\t*stat_bit = *req_bit;\n\n\tif (data->soc_data->legacy && *rst_req == RCU_RST_REQ)\n\t\treturn RCU_RST_STAT;\n\telse\n\t\treturn *rst_req + 0x4;\n}\n\nstatic int intel_set_clr_bits(struct intel_reset_data *data, unsigned long id,\n\t\t\t      bool set)\n{\n\tu32 rst_req, req_bit, rst_stat, stat_bit, val;\n\tint ret;\n\n\trst_stat = id_to_reg_and_bit_offsets(data, id, &rst_req,\n\t\t\t\t\t     &req_bit, &stat_bit);\n\n\tval = set ? BIT(req_bit) : 0;\n\tret = regmap_update_bits(data->regmap, rst_req,  BIT(req_bit), val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_read_poll_timeout(data->regmap, rst_stat, val,\n\t\t\t\t\tset == !!(val & BIT(stat_bit)), 20,\n\t\t\t\t\t200);\n}\n\nstatic int intel_assert_device(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct intel_reset_data *data = to_reset_data(rcdev);\n\tint ret;\n\n\tret = intel_set_clr_bits(data, id, true);\n\tif (ret)\n\t\tdev_err(data->dev, \"Reset assert failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int intel_deassert_device(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\tstruct intel_reset_data *data = to_reset_data(rcdev);\n\tint ret;\n\n\tret = intel_set_clr_bits(data, id, false);\n\tif (ret)\n\t\tdev_err(data->dev, \"Reset deassert failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int intel_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct intel_reset_data *data = to_reset_data(rcdev);\n\tu32 rst_req, req_bit, rst_stat, stat_bit, val;\n\tint ret;\n\n\trst_stat = id_to_reg_and_bit_offsets(data, id, &rst_req,\n\t\t\t\t\t     &req_bit, &stat_bit);\n\tret = regmap_read(data->regmap, rst_stat, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & BIT(stat_bit));\n}\n\nstatic const struct reset_control_ops intel_reset_ops = {\n\t.assert =\tintel_assert_device,\n\t.deassert =\tintel_deassert_device,\n\t.status\t=\tintel_reset_status,\n};\n\nstatic int intel_reset_xlate(struct reset_controller_dev *rcdev,\n\t\t\t     const struct of_phandle_args *spec)\n{\n\tstruct intel_reset_data *data = to_reset_data(rcdev);\n\tu32 id;\n\n\tif (spec->args[1] > 31)\n\t\treturn -EINVAL;\n\n\tid = FIELD_PREP(REG_OFFSET_MASK, spec->args[0]);\n\tid |= FIELD_PREP(BIT_OFFSET_MASK, spec->args[1]);\n\n\tif (data->soc_data->legacy) {\n\t\tif (spec->args[2] > 31)\n\t\t\treturn -EINVAL;\n\n\t\tid |= FIELD_PREP(STAT_BIT_OFFSET_MASK, spec->args[2]);\n\t}\n\n\treturn id;\n}\n\nstatic int intel_reset_restart_handler(struct notifier_block *nb,\n\t\t\t\t       unsigned long action, void *data)\n{\n\tstruct intel_reset_data *reset_data;\n\n\treset_data = container_of(nb, struct intel_reset_data, restart_nb);\n\tintel_assert_device(&reset_data->rcdev, reset_data->reboot_id);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int intel_reset_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct intel_reset_data *data;\n\tvoid __iomem *base;\n\tu32 rb_id[3];\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->soc_data = of_device_get_match_data(dev);\n\tif (!data->soc_data)\n\t\treturn -ENODEV;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdata->regmap = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t     &intel_rcu_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(dev, \"regmap initialization failed\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\tret = device_property_read_u32_array(dev, \"intel,global-reset\", rb_id,\n\t\t\t\t\t     data->soc_data->reset_cell_count);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get global reset offset!\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->dev =\t\t\tdev;\n\tdata->rcdev.of_node =\t\tnp;\n\tdata->rcdev.owner =\t\tdev->driver->owner;\n\tdata->rcdev.ops\t=\t\t&intel_reset_ops;\n\tdata->rcdev.of_xlate =\t\tintel_reset_xlate;\n\tdata->rcdev.of_reset_n_cells =\tdata->soc_data->reset_cell_count;\n\tret = devm_reset_controller_register(&pdev->dev, &data->rcdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->reboot_id = FIELD_PREP(REG_OFFSET_MASK, rb_id[0]);\n\tdata->reboot_id |= FIELD_PREP(BIT_OFFSET_MASK, rb_id[1]);\n\n\tif (data->soc_data->legacy)\n\t\tdata->reboot_id |= FIELD_PREP(STAT_BIT_OFFSET_MASK, rb_id[2]);\n\n\tdata->restart_nb.notifier_call =\tintel_reset_restart_handler;\n\tdata->restart_nb.priority =\t\t128;\n\tregister_restart_handler(&data->restart_nb);\n\n\treturn 0;\n}\n\nstatic const struct intel_reset_soc xrx200_data = {\n\t.legacy =\t\ttrue,\n\t.reset_cell_count =\t3,\n};\n\nstatic const struct intel_reset_soc lgm_data = {\n\t.legacy =\t\tfalse,\n\t.reset_cell_count =\t2,\n};\n\nstatic const struct of_device_id intel_reset_match[] = {\n\t{ .compatible = \"intel,rcu-lgm\", .data = &lgm_data },\n\t{ .compatible = \"intel,rcu-xrx200\", .data = &xrx200_data },\n\t{}\n};\n\nstatic struct platform_driver intel_reset_driver = {\n\t.probe = intel_reset_probe,\n\t.driver = {\n\t\t.name = \"intel-reset\",\n\t\t.of_match_table = intel_reset_match,\n\t},\n};\n\nstatic int __init intel_reset_init(void)\n{\n\treturn platform_driver_register(&intel_reset_driver);\n}\n\n \npostcore_initcall(intel_reset_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}