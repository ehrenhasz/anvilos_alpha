{
  "module_name": "reset-rzg2l-usbphy-ctrl.c",
  "hash_id": "3560d991316e82da2f32e8e4645a5f46a4e70016303cd7b8a39829aba43647dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-rzg2l-usbphy-ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/reset-controller.h>\n\n#define RESET\t\t\t0x000\n\n#define RESET_SEL_PLLRESET\tBIT(12)\n#define RESET_PLLRESET\t\tBIT(8)\n\n#define RESET_SEL_P2RESET\tBIT(5)\n#define RESET_SEL_P1RESET\tBIT(4)\n#define RESET_PHYRST_2\t\tBIT(1)\n#define RESET_PHYRST_1\t\tBIT(0)\n\n#define PHY_RESET_PORT2\t\t(RESET_SEL_P2RESET | RESET_PHYRST_2)\n#define PHY_RESET_PORT1\t\t(RESET_SEL_P1RESET | RESET_PHYRST_1)\n\n#define NUM_PORTS\t\t2\n\nstruct rzg2l_usbphy_ctrl_priv {\n\tstruct reset_controller_dev rcdev;\n\tstruct reset_control *rstc;\n\tvoid __iomem *base;\n\n\tspinlock_t lock;\n};\n\n#define rcdev_to_priv(x)\tcontainer_of(x, struct rzg2l_usbphy_ctrl_priv, rcdev)\n\nstatic int rzg2l_usbphy_ctrl_assert(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long id)\n{\n\tstruct rzg2l_usbphy_ctrl_priv *priv = rcdev_to_priv(rcdev);\n\tu32 port_mask = PHY_RESET_PORT1 | PHY_RESET_PORT2;\n\tvoid __iomem *base = priv->base;\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tval = readl(base + RESET);\n\tval |= id ? PHY_RESET_PORT2 : PHY_RESET_PORT1;\n\tif (port_mask == (val & port_mask))\n\t\tval |= RESET_PLLRESET;\n\twritel(val, base + RESET);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int rzg2l_usbphy_ctrl_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t      unsigned long id)\n{\n\tstruct rzg2l_usbphy_ctrl_priv *priv = rcdev_to_priv(rcdev);\n\tvoid __iomem *base = priv->base;\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tval = readl(base + RESET);\n\n\tval |= RESET_SEL_PLLRESET;\n\tval &= ~(RESET_PLLRESET | (id ? PHY_RESET_PORT2 : PHY_RESET_PORT1));\n\twritel(val, base + RESET);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int rzg2l_usbphy_ctrl_status(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long id)\n{\n\tstruct rzg2l_usbphy_ctrl_priv *priv = rcdev_to_priv(rcdev);\n\tu32 port_mask;\n\n\tport_mask = id ? PHY_RESET_PORT2 : PHY_RESET_PORT1;\n\n\treturn !!(readl(priv->base + RESET) & port_mask);\n}\n\nstatic const struct of_device_id rzg2l_usbphy_ctrl_match_table[] = {\n\t{ .compatible = \"renesas,rzg2l-usbphy-ctrl\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rzg2l_usbphy_ctrl_match_table);\n\nstatic const struct reset_control_ops rzg2l_usbphy_ctrl_reset_ops = {\n\t.assert = rzg2l_usbphy_ctrl_assert,\n\t.deassert = rzg2l_usbphy_ctrl_deassert,\n\t.status = rzg2l_usbphy_ctrl_status,\n};\n\nstatic int rzg2l_usbphy_ctrl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rzg2l_usbphy_ctrl_priv *priv;\n\tunsigned long flags;\n\tint error;\n\tu32 val;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(priv->rstc))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->rstc),\n\t\t\t\t     \"failed to get reset\\n\");\n\n\terror = reset_control_deassert(priv->rstc);\n\tif (error)\n\t\treturn error;\n\n\tpriv->rcdev.ops = &rzg2l_usbphy_ctrl_reset_ops;\n\tpriv->rcdev.of_reset_n_cells = 1;\n\tpriv->rcdev.nr_resets = NUM_PORTS;\n\tpriv->rcdev.of_node = dev->of_node;\n\tpriv->rcdev.dev = dev;\n\n\terror = devm_reset_controller_register(dev, &priv->rcdev);\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_init(&priv->lock);\n\tdev_set_drvdata(dev, priv);\n\n\tpm_runtime_enable(&pdev->dev);\n\terror = pm_runtime_resume_and_get(&pdev->dev);\n\tif (error < 0) {\n\t\tpm_runtime_disable(&pdev->dev);\n\t\treset_control_assert(priv->rstc);\n\t\treturn dev_err_probe(&pdev->dev, error, \"pm_runtime_resume_and_get failed\");\n\t}\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tval = readl(priv->base + RESET);\n\tval |= RESET_SEL_PLLRESET | RESET_PLLRESET | PHY_RESET_PORT2 | PHY_RESET_PORT1;\n\twritel(val, priv->base + RESET);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int rzg2l_usbphy_ctrl_remove(struct platform_device *pdev)\n{\n\tstruct rzg2l_usbphy_ctrl_priv *priv = dev_get_drvdata(&pdev->dev);\n\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\treset_control_assert(priv->rstc);\n\n\treturn 0;\n}\n\nstatic struct platform_driver rzg2l_usbphy_ctrl_driver = {\n\t.driver = {\n\t\t.name\t\t= \"rzg2l_usbphy_ctrl\",\n\t\t.of_match_table\t= rzg2l_usbphy_ctrl_match_table,\n\t},\n\t.probe\t= rzg2l_usbphy_ctrl_probe,\n\t.remove\t= rzg2l_usbphy_ctrl_remove,\n};\nmodule_platform_driver(rzg2l_usbphy_ctrl_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Renesas RZ/G2L USBPHY Control\");\nMODULE_AUTHOR(\"biju.das.jz@bp.renesas.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}