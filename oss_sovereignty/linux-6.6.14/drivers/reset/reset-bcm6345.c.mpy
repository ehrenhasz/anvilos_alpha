{
  "module_name": "reset-bcm6345.c",
  "hash_id": "2f809cd12d2dae41660a4cb6dc8afb59f58593af7879fab8def7ca4679ee387d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-bcm6345.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n\n#define BCM6345_RESET_NUM\t\t32\n#define BCM6345_RESET_SLEEP_MIN_US\t10000\n#define BCM6345_RESET_SLEEP_MAX_US\t20000\n\nstruct bcm6345_reset {\n\tstruct reset_controller_dev rcdev;\n\tvoid __iomem *base;\n\tspinlock_t lock;\n};\n\nstatic inline struct bcm6345_reset *\nto_bcm6345_reset(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct bcm6345_reset, rcdev);\n}\n\nstatic int bcm6345_reset_update(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id, bool assert)\n{\n\tstruct bcm6345_reset *bcm6345_reset = to_bcm6345_reset(rcdev);\n\tunsigned long flags;\n\tuint32_t val;\n\n\tspin_lock_irqsave(&bcm6345_reset->lock, flags);\n\tval = __raw_readl(bcm6345_reset->base);\n\tif (assert)\n\t\tval &= ~BIT(id);\n\telse\n\t\tval |= BIT(id);\n\t__raw_writel(val, bcm6345_reset->base);\n\tspin_unlock_irqrestore(&bcm6345_reset->lock, flags);\n\n\treturn 0;\n}\n\nstatic int bcm6345_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\treturn bcm6345_reset_update(rcdev, id, true);\n}\n\nstatic int bcm6345_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id)\n{\n\treturn bcm6345_reset_update(rcdev, id, false);\n}\n\nstatic int bcm6345_reset_reset(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tbcm6345_reset_update(rcdev, id, true);\n\tusleep_range(BCM6345_RESET_SLEEP_MIN_US,\n\t\t     BCM6345_RESET_SLEEP_MAX_US);\n\n\tbcm6345_reset_update(rcdev, id, false);\n\t \n\tusleep_range(BCM6345_RESET_SLEEP_MIN_US,\n\t\t     BCM6345_RESET_SLEEP_MAX_US);\n\n\treturn 0;\n}\n\nstatic int bcm6345_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct bcm6345_reset *bcm6345_reset = to_bcm6345_reset(rcdev);\n\n\treturn !(__raw_readl(bcm6345_reset->base) & BIT(id));\n}\n\nstatic const struct reset_control_ops bcm6345_reset_ops = {\n\t.assert = bcm6345_reset_assert,\n\t.deassert = bcm6345_reset_deassert,\n\t.reset = bcm6345_reset_reset,\n\t.status = bcm6345_reset_status,\n};\n\nstatic int bcm6345_reset_probe(struct platform_device *pdev)\n{\n\tstruct bcm6345_reset *bcm6345_reset;\n\n\tbcm6345_reset = devm_kzalloc(&pdev->dev,\n\t\t\t\t     sizeof(*bcm6345_reset), GFP_KERNEL);\n\tif (!bcm6345_reset)\n\t\treturn -ENOMEM;\n\n\tbcm6345_reset->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(bcm6345_reset->base))\n\t\treturn PTR_ERR(bcm6345_reset->base);\n\n\tspin_lock_init(&bcm6345_reset->lock);\n\tbcm6345_reset->rcdev.ops = &bcm6345_reset_ops;\n\tbcm6345_reset->rcdev.owner = THIS_MODULE;\n\tbcm6345_reset->rcdev.of_node = pdev->dev.of_node;\n\tbcm6345_reset->rcdev.of_reset_n_cells = 1;\n\tbcm6345_reset->rcdev.nr_resets = BCM6345_RESET_NUM;\n\n\treturn devm_reset_controller_register(&pdev->dev,\n\t\t\t\t\t      &bcm6345_reset->rcdev);\n}\n\nstatic const struct of_device_id bcm6345_reset_of_match[] = {\n\t{ .compatible = \"brcm,bcm6345-reset\" },\n\t{   },\n};\n\nstatic struct platform_driver bcm6345_reset_driver = {\n\t.probe = bcm6345_reset_probe,\n\t.driver\t= {\n\t\t.name = \"bcm6345-reset\",\n\t\t.of_match_table = bcm6345_reset_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(bcm6345_reset_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}