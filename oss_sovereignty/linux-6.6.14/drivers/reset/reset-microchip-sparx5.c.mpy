{
  "module_name": "reset-microchip-sparx5.c",
  "hash_id": "dcdc22db55e29dc985a8ddd8cbc81aacb6ce270072172c38fbf21392f16af351",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-microchip-sparx5.c",
  "human_readable_source": "\n \n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n\nstruct reset_props {\n\tu32 protect_reg;\n\tu32 protect_bit;\n\tu32 reset_reg;\n\tu32 reset_bit;\n};\n\nstruct mchp_reset_context {\n\tstruct regmap *cpu_ctrl;\n\tstruct regmap *gcb_ctrl;\n\tstruct reset_controller_dev rcdev;\n\tconst struct reset_props *props;\n};\n\nstatic struct regmap_config sparx5_reset_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n};\n\nstatic int sparx5_switch_reset(struct mchp_reset_context *ctx)\n{\n\tu32 val;\n\n\t \n\tregmap_update_bits(ctx->cpu_ctrl, ctx->props->protect_reg,\n\t\t\t   ctx->props->protect_bit, ctx->props->protect_bit);\n\n\t \n\tregmap_write(ctx->gcb_ctrl, ctx->props->reset_reg,\n\t\t     ctx->props->reset_bit);\n\n\t \n\treturn regmap_read_poll_timeout(ctx->gcb_ctrl, ctx->props->reset_reg, val,\n\t\t\t\t\t(val & ctx->props->reset_bit) == 0,\n\t\t\t\t\t1, 100);\n}\n\nstatic int sparx5_reset_noop(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\treturn 0;\n}\n\nstatic const struct reset_control_ops sparx5_reset_ops = {\n\t.reset = sparx5_reset_noop,\n};\n\nstatic int mchp_sparx5_map_syscon(struct platform_device *pdev, char *name,\n\t\t\t\t  struct regmap **target)\n{\n\tstruct device_node *syscon_np;\n\tstruct regmap *regmap;\n\tint err;\n\n\tsyscon_np = of_parse_phandle(pdev->dev.of_node, name, 0);\n\tif (!syscon_np)\n\t\treturn -ENODEV;\n\tregmap = syscon_node_to_regmap(syscon_np);\n\tof_node_put(syscon_np);\n\tif (IS_ERR(regmap)) {\n\t\terr = PTR_ERR(regmap);\n\t\tdev_err(&pdev->dev, \"No '%s' map: %d\\n\", name, err);\n\t\treturn err;\n\t}\n\t*target = regmap;\n\treturn 0;\n}\n\nstatic int mchp_sparx5_map_io(struct platform_device *pdev, int index,\n\t\t\t      struct regmap **target)\n{\n\tstruct resource *res;\n\tstruct regmap *map;\n\tvoid __iomem *mem;\n\n\tmem = devm_platform_get_and_ioremap_resource(pdev, index, &res);\n\tif (IS_ERR(mem)) {\n\t\tdev_err(&pdev->dev, \"Could not map resource %d\\n\", index);\n\t\treturn PTR_ERR(mem);\n\t}\n\tsparx5_reset_regmap_config.name = res->name;\n\tmap = devm_regmap_init_mmio(&pdev->dev, mem, &sparx5_reset_regmap_config);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\t*target = map;\n\treturn 0;\n}\n\nstatic int mchp_sparx5_reset_probe(struct platform_device *pdev)\n{\n\tstruct device_node *dn = pdev->dev.of_node;\n\tstruct mchp_reset_context *ctx;\n\tint err;\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\terr = mchp_sparx5_map_syscon(pdev, \"cpu-syscon\", &ctx->cpu_ctrl);\n\tif (err)\n\t\treturn err;\n\terr = mchp_sparx5_map_io(pdev, 0, &ctx->gcb_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tctx->rcdev.owner = THIS_MODULE;\n\tctx->rcdev.nr_resets = 1;\n\tctx->rcdev.ops = &sparx5_reset_ops;\n\tctx->rcdev.of_node = dn;\n\tctx->props = device_get_match_data(&pdev->dev);\n\n\t \n\terr = sparx5_switch_reset(ctx);\n\tif (err)\n\t\treturn err;\n\n\treturn devm_reset_controller_register(&pdev->dev, &ctx->rcdev);\n}\n\nstatic const struct reset_props reset_props_sparx5 = {\n\t.protect_reg    = 0x84,\n\t.protect_bit    = BIT(10),\n\t.reset_reg      = 0x0,\n\t.reset_bit      = BIT(1),\n};\n\nstatic const struct reset_props reset_props_lan966x = {\n\t.protect_reg    = 0x88,\n\t.protect_bit    = BIT(5),\n\t.reset_reg      = 0x0,\n\t.reset_bit      = BIT(1),\n};\n\nstatic const struct of_device_id mchp_sparx5_reset_of_match[] = {\n\t{\n\t\t.compatible = \"microchip,sparx5-switch-reset\",\n\t\t.data = &reset_props_sparx5,\n\t}, {\n\t\t.compatible = \"microchip,lan966x-switch-reset\",\n\t\t.data = &reset_props_lan966x,\n\t},\n\t{ }\n};\n\nstatic struct platform_driver mchp_sparx5_reset_driver = {\n\t.probe = mchp_sparx5_reset_probe,\n\t.driver = {\n\t\t.name = \"sparx5-switch-reset\",\n\t\t.of_match_table = mchp_sparx5_reset_of_match,\n\t},\n};\n\nstatic int __init mchp_sparx5_reset_init(void)\n{\n\treturn platform_driver_register(&mchp_sparx5_reset_driver);\n}\n\n \npostcore_initcall(mchp_sparx5_reset_init);\n\nMODULE_DESCRIPTION(\"Microchip Sparx5 switch reset driver\");\nMODULE_AUTHOR(\"Steen Hegelund <steen.hegelund@microchip.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}