{
  "module_name": "reset-imx7.c",
  "hash_id": "a400ef51d4676b9f2f93cf120e0dcdeedd5de0e00d6697371f20d75f77ae5935",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-imx7.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/regmap.h>\n#include <dt-bindings/reset/imx7-reset.h>\n#include <dt-bindings/reset/imx8mq-reset.h>\n#include <dt-bindings/reset/imx8mp-reset.h>\n\nstruct imx7_src_signal {\n\tunsigned int offset, bit;\n};\n\nstruct imx7_src_variant {\n\tconst struct imx7_src_signal *signals;\n\tunsigned int signals_num;\n\tstruct reset_control_ops ops;\n};\n\nstruct imx7_src {\n\tstruct reset_controller_dev rcdev;\n\tstruct regmap *regmap;\n\tconst struct imx7_src_signal *signals;\n};\n\nenum imx7_src_registers {\n\tSRC_A7RCR0\t\t= 0x0004,\n\tSRC_M4RCR\t\t= 0x000c,\n\tSRC_ERCR\t\t= 0x0014,\n\tSRC_HSICPHY_RCR\t\t= 0x001c,\n\tSRC_USBOPHY1_RCR\t= 0x0020,\n\tSRC_USBOPHY2_RCR\t= 0x0024,\n\tSRC_MIPIPHY_RCR\t\t= 0x0028,\n\tSRC_PCIEPHY_RCR\t\t= 0x002c,\n\tSRC_DDRC_RCR\t\t= 0x1000,\n};\n\nstatic int imx7_reset_update(struct imx7_src *imx7src,\n\t\t\t     unsigned long id, unsigned int value)\n{\n\tconst struct imx7_src_signal *signal = &imx7src->signals[id];\n\n\treturn regmap_update_bits(imx7src->regmap,\n\t\t\t\t  signal->offset, signal->bit, value);\n}\n\nstatic const struct imx7_src_signal imx7_src_signals[IMX7_RESET_NUM] = {\n\t[IMX7_RESET_A7_CORE_POR_RESET0] = { SRC_A7RCR0, BIT(0) },\n\t[IMX7_RESET_A7_CORE_POR_RESET1] = { SRC_A7RCR0, BIT(1) },\n\t[IMX7_RESET_A7_CORE_RESET0]     = { SRC_A7RCR0, BIT(4) },\n\t[IMX7_RESET_A7_CORE_RESET1]\t= { SRC_A7RCR0, BIT(5) },\n\t[IMX7_RESET_A7_DBG_RESET0]\t= { SRC_A7RCR0, BIT(8) },\n\t[IMX7_RESET_A7_DBG_RESET1]\t= { SRC_A7RCR0, BIT(9) },\n\t[IMX7_RESET_A7_ETM_RESET0]\t= { SRC_A7RCR0, BIT(12) },\n\t[IMX7_RESET_A7_ETM_RESET1]\t= { SRC_A7RCR0, BIT(13) },\n\t[IMX7_RESET_A7_SOC_DBG_RESET]\t= { SRC_A7RCR0, BIT(20) },\n\t[IMX7_RESET_A7_L2RESET]\t\t= { SRC_A7RCR0, BIT(21) },\n\t[IMX7_RESET_SW_M4C_RST]\t\t= { SRC_M4RCR, BIT(1) },\n\t[IMX7_RESET_SW_M4P_RST]\t\t= { SRC_M4RCR, BIT(2) },\n\t[IMX7_RESET_EIM_RST]\t\t= { SRC_ERCR, BIT(0) },\n\t[IMX7_RESET_HSICPHY_PORT_RST]\t= { SRC_HSICPHY_RCR, BIT(1) },\n\t[IMX7_RESET_USBPHY1_POR]\t= { SRC_USBOPHY1_RCR, BIT(0) },\n\t[IMX7_RESET_USBPHY1_PORT_RST]\t= { SRC_USBOPHY1_RCR, BIT(1) },\n\t[IMX7_RESET_USBPHY2_POR]\t= { SRC_USBOPHY2_RCR, BIT(0) },\n\t[IMX7_RESET_USBPHY2_PORT_RST]\t= { SRC_USBOPHY2_RCR, BIT(1) },\n\t[IMX7_RESET_MIPI_PHY_MRST]\t= { SRC_MIPIPHY_RCR, BIT(1) },\n\t[IMX7_RESET_MIPI_PHY_SRST]\t= { SRC_MIPIPHY_RCR, BIT(2) },\n\t[IMX7_RESET_PCIEPHY]\t\t= { SRC_PCIEPHY_RCR, BIT(2) | BIT(1) },\n\t[IMX7_RESET_PCIEPHY_PERST]\t= { SRC_PCIEPHY_RCR, BIT(3) },\n\t[IMX7_RESET_PCIE_CTRL_APPS_EN]\t= { SRC_PCIEPHY_RCR, BIT(6) },\n\t[IMX7_RESET_PCIE_CTRL_APPS_TURNOFF] = { SRC_PCIEPHY_RCR, BIT(11) },\n\t[IMX7_RESET_DDRC_PRST]\t\t= { SRC_DDRC_RCR, BIT(0) },\n\t[IMX7_RESET_DDRC_CORE_RST]\t= { SRC_DDRC_RCR, BIT(1) },\n};\n\nstatic struct imx7_src *to_imx7_src(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct imx7_src, rcdev);\n}\n\nstatic int imx7_reset_set(struct reset_controller_dev *rcdev,\n\t\t\t  unsigned long id, bool assert)\n{\n\tstruct imx7_src *imx7src = to_imx7_src(rcdev);\n\tconst unsigned int bit = imx7src->signals[id].bit;\n\tunsigned int value = assert ? bit : 0;\n\n\tswitch (id) {\n\tcase IMX7_RESET_PCIEPHY:\n\t\t \n\t\tif (!assert)\n\t\t\tudelay(10);\n\t\tbreak;\n\n\tcase IMX7_RESET_PCIE_CTRL_APPS_EN:\n\t\tvalue = assert ? 0 : bit;\n\t\tbreak;\n\t}\n\n\treturn imx7_reset_update(imx7src, id, value);\n}\n\nstatic int imx7_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\treturn imx7_reset_set(rcdev, id, true);\n}\n\nstatic int imx7_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\treturn imx7_reset_set(rcdev, id, false);\n}\n\nstatic const struct imx7_src_variant variant_imx7 = {\n\t.signals = imx7_src_signals,\n\t.signals_num = ARRAY_SIZE(imx7_src_signals),\n\t.ops = {\n\t\t.assert   = imx7_reset_assert,\n\t\t.deassert = imx7_reset_deassert,\n\t},\n};\n\nenum imx8mq_src_registers {\n\tSRC_A53RCR0\t\t= 0x0004,\n\tSRC_HDMI_RCR\t\t= 0x0030,\n\tSRC_DISP_RCR\t\t= 0x0034,\n\tSRC_GPU_RCR\t\t= 0x0040,\n\tSRC_VPU_RCR\t\t= 0x0044,\n\tSRC_PCIE2_RCR\t\t= 0x0048,\n\tSRC_MIPIPHY1_RCR\t= 0x004c,\n\tSRC_MIPIPHY2_RCR\t= 0x0050,\n\tSRC_DDRC2_RCR\t\t= 0x1004,\n};\n\nenum imx8mp_src_registers {\n\tSRC_SUPERMIX_RCR\t= 0x0018,\n\tSRC_AUDIOMIX_RCR\t= 0x001c,\n\tSRC_MLMIX_RCR\t\t= 0x0028,\n\tSRC_GPU2D_RCR\t\t= 0x0038,\n\tSRC_GPU3D_RCR\t\t= 0x003c,\n\tSRC_VPU_G1_RCR\t\t= 0x0048,\n\tSRC_VPU_G2_RCR\t\t= 0x004c,\n\tSRC_VPUVC8KE_RCR\t= 0x0050,\n\tSRC_NOC_RCR\t\t= 0x0054,\n};\n\nstatic const struct imx7_src_signal imx8mq_src_signals[IMX8MQ_RESET_NUM] = {\n\t[IMX8MQ_RESET_A53_CORE_POR_RESET0]\t= { SRC_A53RCR0, BIT(0) },\n\t[IMX8MQ_RESET_A53_CORE_POR_RESET1]\t= { SRC_A53RCR0, BIT(1) },\n\t[IMX8MQ_RESET_A53_CORE_POR_RESET2]\t= { SRC_A53RCR0, BIT(2) },\n\t[IMX8MQ_RESET_A53_CORE_POR_RESET3]\t= { SRC_A53RCR0, BIT(3) },\n\t[IMX8MQ_RESET_A53_CORE_RESET0]\t\t= { SRC_A53RCR0, BIT(4) },\n\t[IMX8MQ_RESET_A53_CORE_RESET1]\t\t= { SRC_A53RCR0, BIT(5) },\n\t[IMX8MQ_RESET_A53_CORE_RESET2]\t\t= { SRC_A53RCR0, BIT(6) },\n\t[IMX8MQ_RESET_A53_CORE_RESET3]\t\t= { SRC_A53RCR0, BIT(7) },\n\t[IMX8MQ_RESET_A53_DBG_RESET0]\t\t= { SRC_A53RCR0, BIT(8) },\n\t[IMX8MQ_RESET_A53_DBG_RESET1]\t\t= { SRC_A53RCR0, BIT(9) },\n\t[IMX8MQ_RESET_A53_DBG_RESET2]\t\t= { SRC_A53RCR0, BIT(10) },\n\t[IMX8MQ_RESET_A53_DBG_RESET3]\t\t= { SRC_A53RCR0, BIT(11) },\n\t[IMX8MQ_RESET_A53_ETM_RESET0]\t\t= { SRC_A53RCR0, BIT(12) },\n\t[IMX8MQ_RESET_A53_ETM_RESET1]\t\t= { SRC_A53RCR0, BIT(13) },\n\t[IMX8MQ_RESET_A53_ETM_RESET2]\t\t= { SRC_A53RCR0, BIT(14) },\n\t[IMX8MQ_RESET_A53_ETM_RESET3]\t\t= { SRC_A53RCR0, BIT(15) },\n\t[IMX8MQ_RESET_A53_SOC_DBG_RESET]\t= { SRC_A53RCR0, BIT(20) },\n\t[IMX8MQ_RESET_A53_L2RESET]\t\t= { SRC_A53RCR0, BIT(21) },\n\t[IMX8MQ_RESET_SW_NON_SCLR_M4C_RST]\t= { SRC_M4RCR, BIT(0) },\n\t[IMX8MQ_RESET_SW_M4C_RST]\t\t= { SRC_M4RCR, BIT(1) },\n\t[IMX8MQ_RESET_SW_M4P_RST]\t\t= { SRC_M4RCR, BIT(2) },\n\t[IMX8MQ_RESET_M4_ENABLE]\t\t= { SRC_M4RCR, BIT(3) },\n\t[IMX8MQ_RESET_OTG1_PHY_RESET]\t\t= { SRC_USBOPHY1_RCR, BIT(0) },\n\t[IMX8MQ_RESET_OTG2_PHY_RESET]\t\t= { SRC_USBOPHY2_RCR, BIT(0) },\n\t[IMX8MQ_RESET_MIPI_DSI_RESET_BYTE_N]\t= { SRC_MIPIPHY_RCR, BIT(1) },\n\t[IMX8MQ_RESET_MIPI_DSI_RESET_N]\t\t= { SRC_MIPIPHY_RCR, BIT(2) },\n\t[IMX8MQ_RESET_MIPI_DSI_DPI_RESET_N]\t= { SRC_MIPIPHY_RCR, BIT(3) },\n\t[IMX8MQ_RESET_MIPI_DSI_ESC_RESET_N]\t= { SRC_MIPIPHY_RCR, BIT(4) },\n\t[IMX8MQ_RESET_MIPI_DSI_PCLK_RESET_N]\t= { SRC_MIPIPHY_RCR, BIT(5) },\n\t[IMX8MQ_RESET_PCIEPHY]\t\t\t= { SRC_PCIEPHY_RCR,\n\t\t\t\t\t\t    BIT(2) | BIT(1) },\n\t[IMX8MQ_RESET_PCIEPHY_PERST]\t\t= { SRC_PCIEPHY_RCR, BIT(3) },\n\t[IMX8MQ_RESET_PCIE_CTRL_APPS_EN]\t= { SRC_PCIEPHY_RCR, BIT(6) },\n\t[IMX8MQ_RESET_PCIE_CTRL_APPS_TURNOFF]\t= { SRC_PCIEPHY_RCR, BIT(11) },\n\t[IMX8MQ_RESET_HDMI_PHY_APB_RESET]\t= { SRC_HDMI_RCR, BIT(0) },\n\t[IMX8MQ_RESET_DISP_RESET]\t\t= { SRC_DISP_RCR, BIT(0) },\n\t[IMX8MQ_RESET_GPU_RESET]\t\t= { SRC_GPU_RCR, BIT(0) },\n\t[IMX8MQ_RESET_VPU_RESET]\t\t= { SRC_VPU_RCR, BIT(0) },\n\t[IMX8MQ_RESET_PCIEPHY2]\t\t\t= { SRC_PCIE2_RCR,\n\t\t\t\t\t\t    BIT(2) | BIT(1) },\n\t[IMX8MQ_RESET_PCIEPHY2_PERST]\t\t= { SRC_PCIE2_RCR, BIT(3) },\n\t[IMX8MQ_RESET_PCIE2_CTRL_APPS_EN]\t= { SRC_PCIE2_RCR, BIT(6) },\n\t[IMX8MQ_RESET_PCIE2_CTRL_APPS_TURNOFF]\t= { SRC_PCIE2_RCR, BIT(11) },\n\t[IMX8MQ_RESET_MIPI_CSI1_CORE_RESET]\t= { SRC_MIPIPHY1_RCR, BIT(0) },\n\t[IMX8MQ_RESET_MIPI_CSI1_PHY_REF_RESET]\t= { SRC_MIPIPHY1_RCR, BIT(1) },\n\t[IMX8MQ_RESET_MIPI_CSI1_ESC_RESET]\t= { SRC_MIPIPHY1_RCR, BIT(2) },\n\t[IMX8MQ_RESET_MIPI_CSI2_CORE_RESET]\t= { SRC_MIPIPHY2_RCR, BIT(0) },\n\t[IMX8MQ_RESET_MIPI_CSI2_PHY_REF_RESET]\t= { SRC_MIPIPHY2_RCR, BIT(1) },\n\t[IMX8MQ_RESET_MIPI_CSI2_ESC_RESET]\t= { SRC_MIPIPHY2_RCR, BIT(2) },\n\t[IMX8MQ_RESET_DDRC1_PRST]\t\t= { SRC_DDRC_RCR, BIT(0) },\n\t[IMX8MQ_RESET_DDRC1_CORE_RESET]\t\t= { SRC_DDRC_RCR, BIT(1) },\n\t[IMX8MQ_RESET_DDRC1_PHY_RESET]\t\t= { SRC_DDRC_RCR, BIT(2) },\n\t[IMX8MQ_RESET_DDRC2_PHY_RESET]\t\t= { SRC_DDRC2_RCR, BIT(0) },\n\t[IMX8MQ_RESET_DDRC2_CORE_RESET]\t\t= { SRC_DDRC2_RCR, BIT(1) },\n\t[IMX8MQ_RESET_DDRC2_PRST]\t\t= { SRC_DDRC2_RCR, BIT(2) },\n};\n\nstatic int imx8mq_reset_set(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id, bool assert)\n{\n\tstruct imx7_src *imx7src = to_imx7_src(rcdev);\n\tconst unsigned int bit = imx7src->signals[id].bit;\n\tunsigned int value = assert ? bit : 0;\n\n\tswitch (id) {\n\tcase IMX8MQ_RESET_PCIEPHY:\n\tcase IMX8MQ_RESET_PCIEPHY2:\n\t\t \n\t\tif (!assert)\n\t\t\tudelay(10);\n\t\tbreak;\n\n\tcase IMX8MQ_RESET_PCIE_CTRL_APPS_EN:\n\tcase IMX8MQ_RESET_PCIE2_CTRL_APPS_EN:\n\tcase IMX8MQ_RESET_MIPI_DSI_PCLK_RESET_N:\n\tcase IMX8MQ_RESET_MIPI_DSI_ESC_RESET_N:\n\tcase IMX8MQ_RESET_MIPI_DSI_DPI_RESET_N:\n\tcase IMX8MQ_RESET_MIPI_DSI_RESET_N:\n\tcase IMX8MQ_RESET_MIPI_DSI_RESET_BYTE_N:\n\tcase IMX8MQ_RESET_M4_ENABLE:\n\t\tvalue = assert ? 0 : bit;\n\t\tbreak;\n\t}\n\n\treturn imx7_reset_update(imx7src, id, value);\n}\n\nstatic int imx8mq_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\treturn imx8mq_reset_set(rcdev, id, true);\n}\n\nstatic int imx8mq_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\treturn imx8mq_reset_set(rcdev, id, false);\n}\n\nstatic const struct imx7_src_variant variant_imx8mq = {\n\t.signals = imx8mq_src_signals,\n\t.signals_num = ARRAY_SIZE(imx8mq_src_signals),\n\t.ops = {\n\t\t.assert   = imx8mq_reset_assert,\n\t\t.deassert = imx8mq_reset_deassert,\n\t},\n};\n\nstatic const struct imx7_src_signal imx8mp_src_signals[IMX8MP_RESET_NUM] = {\n\t[IMX8MP_RESET_A53_CORE_POR_RESET0]\t= { SRC_A53RCR0, BIT(0) },\n\t[IMX8MP_RESET_A53_CORE_POR_RESET1]\t= { SRC_A53RCR0, BIT(1) },\n\t[IMX8MP_RESET_A53_CORE_POR_RESET2]\t= { SRC_A53RCR0, BIT(2) },\n\t[IMX8MP_RESET_A53_CORE_POR_RESET3]\t= { SRC_A53RCR0, BIT(3) },\n\t[IMX8MP_RESET_A53_CORE_RESET0]\t\t= { SRC_A53RCR0, BIT(4) },\n\t[IMX8MP_RESET_A53_CORE_RESET1]\t\t= { SRC_A53RCR0, BIT(5) },\n\t[IMX8MP_RESET_A53_CORE_RESET2]\t\t= { SRC_A53RCR0, BIT(6) },\n\t[IMX8MP_RESET_A53_CORE_RESET3]\t\t= { SRC_A53RCR0, BIT(7) },\n\t[IMX8MP_RESET_A53_DBG_RESET0]\t\t= { SRC_A53RCR0, BIT(8) },\n\t[IMX8MP_RESET_A53_DBG_RESET1]\t\t= { SRC_A53RCR0, BIT(9) },\n\t[IMX8MP_RESET_A53_DBG_RESET2]\t\t= { SRC_A53RCR0, BIT(10) },\n\t[IMX8MP_RESET_A53_DBG_RESET3]\t\t= { SRC_A53RCR0, BIT(11) },\n\t[IMX8MP_RESET_A53_ETM_RESET0]\t\t= { SRC_A53RCR0, BIT(12) },\n\t[IMX8MP_RESET_A53_ETM_RESET1]\t\t= { SRC_A53RCR0, BIT(13) },\n\t[IMX8MP_RESET_A53_ETM_RESET2]\t\t= { SRC_A53RCR0, BIT(14) },\n\t[IMX8MP_RESET_A53_ETM_RESET3]\t\t= { SRC_A53RCR0, BIT(15) },\n\t[IMX8MP_RESET_A53_SOC_DBG_RESET]\t= { SRC_A53RCR0, BIT(20) },\n\t[IMX8MP_RESET_A53_L2RESET]\t\t= { SRC_A53RCR0, BIT(21) },\n\t[IMX8MP_RESET_SW_NON_SCLR_M7C_RST]\t= { SRC_M4RCR, BIT(0) },\n\t[IMX8MP_RESET_OTG1_PHY_RESET]\t\t= { SRC_USBOPHY1_RCR, BIT(0) },\n\t[IMX8MP_RESET_OTG2_PHY_RESET]\t\t= { SRC_USBOPHY2_RCR, BIT(0) },\n\t[IMX8MP_RESET_SUPERMIX_RESET]\t\t= { SRC_SUPERMIX_RCR, BIT(0) },\n\t[IMX8MP_RESET_AUDIOMIX_RESET]\t\t= { SRC_AUDIOMIX_RCR, BIT(0) },\n\t[IMX8MP_RESET_MLMIX_RESET]\t\t= { SRC_MLMIX_RCR, BIT(0) },\n\t[IMX8MP_RESET_PCIEPHY]\t\t\t= { SRC_PCIEPHY_RCR, BIT(2) },\n\t[IMX8MP_RESET_PCIEPHY_PERST]\t\t= { SRC_PCIEPHY_RCR, BIT(3) },\n\t[IMX8MP_RESET_PCIE_CTRL_APPS_EN]\t= { SRC_PCIEPHY_RCR, BIT(6) },\n\t[IMX8MP_RESET_PCIE_CTRL_APPS_TURNOFF]\t= { SRC_PCIEPHY_RCR, BIT(11) },\n\t[IMX8MP_RESET_HDMI_PHY_APB_RESET]\t= { SRC_HDMI_RCR, BIT(0) },\n\t[IMX8MP_RESET_MEDIA_RESET]\t\t= { SRC_DISP_RCR, BIT(0) },\n\t[IMX8MP_RESET_GPU2D_RESET]\t\t= { SRC_GPU2D_RCR, BIT(0) },\n\t[IMX8MP_RESET_GPU3D_RESET]\t\t= { SRC_GPU3D_RCR, BIT(0) },\n\t[IMX8MP_RESET_GPU_RESET]\t\t= { SRC_GPU_RCR, BIT(0) },\n\t[IMX8MP_RESET_VPU_RESET]\t\t= { SRC_VPU_RCR, BIT(0) },\n\t[IMX8MP_RESET_VPU_G1_RESET]\t\t= { SRC_VPU_G1_RCR, BIT(0) },\n\t[IMX8MP_RESET_VPU_G2_RESET]\t\t= { SRC_VPU_G2_RCR, BIT(0) },\n\t[IMX8MP_RESET_VPUVC8KE_RESET]\t\t= { SRC_VPUVC8KE_RCR, BIT(0) },\n\t[IMX8MP_RESET_NOC_RESET]\t\t= { SRC_NOC_RCR, BIT(0) },\n};\n\nstatic int imx8mp_reset_set(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id, bool assert)\n{\n\tstruct imx7_src *imx7src = to_imx7_src(rcdev);\n\tconst unsigned int bit = imx7src->signals[id].bit;\n\tunsigned int value = assert ? bit : 0;\n\n\tswitch (id) {\n\tcase IMX8MP_RESET_PCIEPHY:\n\t\t \n\t\tif (!assert)\n\t\t\tudelay(10);\n\t\tbreak;\n\n\tcase IMX8MP_RESET_PCIE_CTRL_APPS_EN:\n\tcase IMX8MP_RESET_PCIEPHY_PERST:\n\t\tvalue = assert ? 0 : bit;\n\t\tbreak;\n\t}\n\n\treturn imx7_reset_update(imx7src, id, value);\n}\n\nstatic int imx8mp_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\treturn imx8mp_reset_set(rcdev, id, true);\n}\n\nstatic int imx8mp_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\treturn imx8mp_reset_set(rcdev, id, false);\n}\n\nstatic const struct imx7_src_variant variant_imx8mp = {\n\t.signals = imx8mp_src_signals,\n\t.signals_num = ARRAY_SIZE(imx8mp_src_signals),\n\t.ops = {\n\t\t.assert   = imx8mp_reset_assert,\n\t\t.deassert = imx8mp_reset_deassert,\n\t},\n};\n\nstatic int imx7_reset_probe(struct platform_device *pdev)\n{\n\tstruct imx7_src *imx7src;\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap_config config = { .name = \"src\" };\n\tconst struct imx7_src_variant *variant = of_device_get_match_data(dev);\n\n\timx7src = devm_kzalloc(dev, sizeof(*imx7src), GFP_KERNEL);\n\tif (!imx7src)\n\t\treturn -ENOMEM;\n\n\timx7src->signals = variant->signals;\n\timx7src->regmap = syscon_node_to_regmap(dev->of_node);\n\tif (IS_ERR(imx7src->regmap)) {\n\t\tdev_err(dev, \"Unable to get imx7-src regmap\");\n\t\treturn PTR_ERR(imx7src->regmap);\n\t}\n\tregmap_attach_dev(dev, imx7src->regmap, &config);\n\n\timx7src->rcdev.owner     = THIS_MODULE;\n\timx7src->rcdev.nr_resets = variant->signals_num;\n\timx7src->rcdev.ops       = &variant->ops;\n\timx7src->rcdev.of_node   = dev->of_node;\n\n\treturn devm_reset_controller_register(dev, &imx7src->rcdev);\n}\n\nstatic const struct of_device_id imx7_reset_dt_ids[] = {\n\t{ .compatible = \"fsl,imx7d-src\", .data = &variant_imx7 },\n\t{ .compatible = \"fsl,imx8mq-src\", .data = &variant_imx8mq },\n\t{ .compatible = \"fsl,imx8mp-src\", .data = &variant_imx8mp },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, imx7_reset_dt_ids);\n\nstatic struct platform_driver imx7_reset_driver = {\n\t.probe\t= imx7_reset_probe,\n\t.driver = {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= imx7_reset_dt_ids,\n\t},\n};\nmodule_platform_driver(imx7_reset_driver);\n\nMODULE_AUTHOR(\"Andrey Smirnov <andrew.smirnov@gmail.com>\");\nMODULE_DESCRIPTION(\"NXP i.MX7 reset driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}