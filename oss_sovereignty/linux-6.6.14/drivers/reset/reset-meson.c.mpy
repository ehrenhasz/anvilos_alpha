{
  "module_name": "reset-meson.c",
  "hash_id": "de92fac448575da07c6373d01d015f9b46cf9c0ca9223f937c371c2a8257f735",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-meson.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define BITS_PER_REG\t32\n\nstruct meson_reset_param {\n\tint reg_count;\n\tint level_offset;\n};\n\nstruct meson_reset {\n\tvoid __iomem *reg_base;\n\tconst struct meson_reset_param *param;\n\tstruct reset_controller_dev rcdev;\n\tspinlock_t lock;\n};\n\nstatic int meson_reset_reset(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct meson_reset *data =\n\t\tcontainer_of(rcdev, struct meson_reset, rcdev);\n\tunsigned int bank = id / BITS_PER_REG;\n\tunsigned int offset = id % BITS_PER_REG;\n\tvoid __iomem *reg_addr = data->reg_base + (bank << 2);\n\n\twritel(BIT(offset), reg_addr);\n\n\treturn 0;\n}\n\nstatic int meson_reset_level(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id, bool assert)\n{\n\tstruct meson_reset *data =\n\t\tcontainer_of(rcdev, struct meson_reset, rcdev);\n\tunsigned int bank = id / BITS_PER_REG;\n\tunsigned int offset = id % BITS_PER_REG;\n\tvoid __iomem *reg_addr;\n\tunsigned long flags;\n\tu32 reg;\n\n\treg_addr = data->reg_base + data->param->level_offset + (bank << 2);\n\n\tspin_lock_irqsave(&data->lock, flags);\n\n\treg = readl(reg_addr);\n\tif (assert)\n\t\twritel(reg & ~BIT(offset), reg_addr);\n\telse\n\t\twritel(reg | BIT(offset), reg_addr);\n\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\treturn 0;\n}\n\nstatic int meson_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\treturn meson_reset_level(rcdev, id, true);\n}\n\nstatic int meson_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\treturn meson_reset_level(rcdev, id, false);\n}\n\nstatic const struct reset_control_ops meson_reset_ops = {\n\t.reset\t\t= meson_reset_reset,\n\t.assert\t\t= meson_reset_assert,\n\t.deassert\t= meson_reset_deassert,\n};\n\nstatic const struct meson_reset_param meson8b_param = {\n\t.reg_count\t= 8,\n\t.level_offset\t= 0x7c,\n};\n\nstatic const struct meson_reset_param meson_a1_param = {\n\t.reg_count\t= 3,\n\t.level_offset\t= 0x40,\n};\n\nstatic const struct meson_reset_param meson_s4_param = {\n\t.reg_count\t= 6,\n\t.level_offset\t= 0x40,\n};\n\nstatic const struct of_device_id meson_reset_dt_ids[] = {\n\t { .compatible = \"amlogic,meson8b-reset\",    .data = &meson8b_param},\n\t { .compatible = \"amlogic,meson-gxbb-reset\", .data = &meson8b_param},\n\t { .compatible = \"amlogic,meson-axg-reset\",  .data = &meson8b_param},\n\t { .compatible = \"amlogic,meson-a1-reset\",   .data = &meson_a1_param},\n\t { .compatible = \"amlogic,meson-s4-reset\",   .data = &meson_s4_param},\n\t {   },\n};\nMODULE_DEVICE_TABLE(of, meson_reset_dt_ids);\n\nstatic int meson_reset_probe(struct platform_device *pdev)\n{\n\tstruct meson_reset *data;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->reg_base))\n\t\treturn PTR_ERR(data->reg_base);\n\n\tdata->param = of_device_get_match_data(&pdev->dev);\n\tif (!data->param)\n\t\treturn -ENODEV;\n\n\tspin_lock_init(&data->lock);\n\n\tdata->rcdev.owner = THIS_MODULE;\n\tdata->rcdev.nr_resets = data->param->reg_count * BITS_PER_REG;\n\tdata->rcdev.ops = &meson_reset_ops;\n\tdata->rcdev.of_node = pdev->dev.of_node;\n\n\treturn devm_reset_controller_register(&pdev->dev, &data->rcdev);\n}\n\nstatic struct platform_driver meson_reset_driver = {\n\t.probe\t= meson_reset_probe,\n\t.driver = {\n\t\t.name\t\t= \"meson_reset\",\n\t\t.of_match_table\t= meson_reset_dt_ids,\n\t},\n};\nmodule_platform_driver(meson_reset_driver);\n\nMODULE_DESCRIPTION(\"Amlogic Meson Reset Controller driver\");\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}