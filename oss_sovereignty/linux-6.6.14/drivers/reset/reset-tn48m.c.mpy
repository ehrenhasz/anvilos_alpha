{
  "module_name": "reset-tn48m.c",
  "hash_id": "0aeb34fbf5c2374966d41f7352a9eda1b2378b555faef1f02559919c09885a7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-tn48m.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n\n#include <dt-bindings/reset/delta,tn48m-reset.h>\n\n#define TN48M_RESET_REG\t\t0x10\n\n#define TN48M_RESET_TIMEOUT_US\t125000\n#define TN48M_RESET_SLEEP_US\t10\n\nstruct tn48_reset_map {\n\tu8 bit;\n};\n\nstruct tn48_reset_data {\n\tstruct reset_controller_dev rcdev;\n\tstruct regmap *regmap;\n};\n\nstatic const struct tn48_reset_map tn48m_resets[] = {\n\t[CPU_88F7040_RESET] = {0},\n\t[CPU_88F6820_RESET] = {1},\n\t[MAC_98DX3265_RESET] = {2},\n\t[PHY_88E1680_RESET] = {4},\n\t[PHY_88E1512_RESET] = {6},\n\t[POE_RESET] = {7},\n};\n\nstatic inline struct tn48_reset_data *to_tn48_reset_data(\n\t\t\tstruct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct tn48_reset_data, rcdev);\n}\n\nstatic int tn48m_control_reset(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct tn48_reset_data *data = to_tn48_reset_data(rcdev);\n\tunsigned int val;\n\n\tregmap_update_bits(data->regmap, TN48M_RESET_REG,\n\t\t\t   BIT(tn48m_resets[id].bit), 0);\n\n\treturn regmap_read_poll_timeout(data->regmap,\n\t\t\t\t\tTN48M_RESET_REG,\n\t\t\t\t\tval,\n\t\t\t\t\tval & BIT(tn48m_resets[id].bit),\n\t\t\t\t\tTN48M_RESET_SLEEP_US,\n\t\t\t\t\tTN48M_RESET_TIMEOUT_US);\n}\n\nstatic int tn48m_control_status(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct tn48_reset_data *data = to_tn48_reset_data(rcdev);\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(data->regmap, TN48M_RESET_REG, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (BIT(tn48m_resets[id].bit) & regval)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic const struct reset_control_ops tn48_reset_ops = {\n\t.reset\t\t= tn48m_control_reset,\n\t.status\t\t= tn48m_control_status,\n};\n\nstatic int tn48m_reset_probe(struct platform_device *pdev)\n{\n\tstruct tn48_reset_data *data;\n\tstruct regmap *regmap;\n\n\tregmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!regmap)\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = regmap;\n\n\tdata->rcdev.owner = THIS_MODULE;\n\tdata->rcdev.ops = &tn48_reset_ops;\n\tdata->rcdev.nr_resets = ARRAY_SIZE(tn48m_resets);\n\tdata->rcdev.of_node = pdev->dev.of_node;\n\n\treturn devm_reset_controller_register(&pdev->dev, &data->rcdev);\n}\n\nstatic const struct of_device_id tn48m_reset_of_match[] = {\n\t{ .compatible = \"delta,tn48m-reset\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tn48m_reset_of_match);\n\nstatic struct platform_driver tn48m_reset_driver = {\n\t.driver = {\n\t\t.name = \"delta-tn48m-reset\",\n\t\t.of_match_table = tn48m_reset_of_match,\n\t},\n\t.probe = tn48m_reset_probe,\n};\nmodule_platform_driver(tn48m_reset_driver);\n\nMODULE_AUTHOR(\"Robert Marko <robert.marko@sartura.hr>\");\nMODULE_DESCRIPTION(\"Delta TN48M CPLD reset driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}