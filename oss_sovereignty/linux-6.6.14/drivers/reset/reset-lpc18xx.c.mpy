{
  "module_name": "reset-lpc18xx.c",
  "hash_id": "547e48717cf6fc90d2ca752b5fce0a1948b78b9586eddc403f19afc4c2e12f4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-lpc18xx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/reset-controller.h>\n#include <linux/spinlock.h>\n\n \n#define LPC18XX_RGU_CTRL0\t\t0x100\n#define LPC18XX_RGU_CTRL1\t\t0x104\n#define LPC18XX_RGU_ACTIVE_STATUS0\t0x150\n#define LPC18XX_RGU_ACTIVE_STATUS1\t0x154\n\n#define LPC18XX_RGU_RESETS_PER_REG\t32\n\n \n#define LPC18XX_RGU_CORE_RST\t0\n#define LPC43XX_RGU_M0SUB_RST\t12\n#define LPC43XX_RGU_M0APP_RST\t56\n\nstruct lpc18xx_rgu_data {\n\tstruct reset_controller_dev rcdev;\n\tstruct notifier_block restart_nb;\n\tstruct clk *clk_delay;\n\tstruct clk *clk_reg;\n\tvoid __iomem *base;\n\tspinlock_t lock;\n\tu32 delay_us;\n};\n\n#define to_rgu_data(p) container_of(p, struct lpc18xx_rgu_data, rcdev)\n\nstatic int lpc18xx_rgu_restart(struct notifier_block *nb, unsigned long mode,\n\t\t\t       void *cmd)\n{\n\tstruct lpc18xx_rgu_data *rc = container_of(nb, struct lpc18xx_rgu_data,\n\t\t\t\t\t\t   restart_nb);\n\n\twritel(BIT(LPC18XX_RGU_CORE_RST), rc->base + LPC18XX_RGU_CTRL0);\n\tmdelay(2000);\n\n\tpr_emerg(\"%s: unable to restart system\\n\", __func__);\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic int lpc18xx_rgu_setclear_reset(struct reset_controller_dev *rcdev,\n\t\t\t\t      unsigned long id, bool set)\n{\n\tstruct lpc18xx_rgu_data *rc = to_rgu_data(rcdev);\n\tu32 stat_offset = LPC18XX_RGU_ACTIVE_STATUS0;\n\tu32 ctrl_offset = LPC18XX_RGU_CTRL0;\n\tunsigned long flags;\n\tu32 stat, rst_bit;\n\n\tstat_offset += (id / LPC18XX_RGU_RESETS_PER_REG) * sizeof(u32);\n\tctrl_offset += (id / LPC18XX_RGU_RESETS_PER_REG) * sizeof(u32);\n\trst_bit = 1 << (id % LPC18XX_RGU_RESETS_PER_REG);\n\n\tspin_lock_irqsave(&rc->lock, flags);\n\tstat = ~readl(rc->base + stat_offset);\n\tif (set)\n\t\twritel(stat | rst_bit, rc->base + ctrl_offset);\n\telse\n\t\twritel(stat & ~rst_bit, rc->base + ctrl_offset);\n\tspin_unlock_irqrestore(&rc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int lpc18xx_rgu_assert(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\treturn lpc18xx_rgu_setclear_reset(rcdev, id, true);\n}\n\nstatic int lpc18xx_rgu_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\treturn lpc18xx_rgu_setclear_reset(rcdev, id, false);\n}\n\n \nstatic int lpc18xx_rgu_reset(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\tstruct lpc18xx_rgu_data *rc = to_rgu_data(rcdev);\n\n\tlpc18xx_rgu_assert(rcdev, id);\n\tudelay(rc->delay_us);\n\n\tswitch (id) {\n\tcase LPC43XX_RGU_M0SUB_RST:\n\tcase LPC43XX_RGU_M0APP_RST:\n\t\tlpc18xx_rgu_setclear_reset(rcdev, id, false);\n\t}\n\n\treturn 0;\n}\n\nstatic int lpc18xx_rgu_status(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct lpc18xx_rgu_data *rc = to_rgu_data(rcdev);\n\tu32 bit, offset = LPC18XX_RGU_ACTIVE_STATUS0;\n\n\toffset += (id / LPC18XX_RGU_RESETS_PER_REG) * sizeof(u32);\n\tbit = 1 << (id % LPC18XX_RGU_RESETS_PER_REG);\n\n\treturn !(readl(rc->base + offset) & bit);\n}\n\nstatic const struct reset_control_ops lpc18xx_rgu_ops = {\n\t.reset\t\t= lpc18xx_rgu_reset,\n\t.assert\t\t= lpc18xx_rgu_assert,\n\t.deassert\t= lpc18xx_rgu_deassert,\n\t.status\t\t= lpc18xx_rgu_status,\n};\n\nstatic int lpc18xx_rgu_probe(struct platform_device *pdev)\n{\n\tstruct lpc18xx_rgu_data *rc;\n\tu32 fcclk, firc;\n\tint ret;\n\n\trc = devm_kzalloc(&pdev->dev, sizeof(*rc), GFP_KERNEL);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\n\trc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rc->base))\n\t\treturn PTR_ERR(rc->base);\n\n\trc->clk_reg = devm_clk_get(&pdev->dev, \"reg\");\n\tif (IS_ERR(rc->clk_reg)) {\n\t\tdev_err(&pdev->dev, \"reg clock not found\\n\");\n\t\treturn PTR_ERR(rc->clk_reg);\n\t}\n\n\trc->clk_delay = devm_clk_get(&pdev->dev, \"delay\");\n\tif (IS_ERR(rc->clk_delay)) {\n\t\tdev_err(&pdev->dev, \"delay clock not found\\n\");\n\t\treturn PTR_ERR(rc->clk_delay);\n\t}\n\n\tret = clk_prepare_enable(rc->clk_reg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to enable reg clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(rc->clk_delay);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to enable delay clock\\n\");\n\t\tgoto dis_clk_reg;\n\t}\n\n\tfcclk = clk_get_rate(rc->clk_reg) / USEC_PER_SEC;\n\tfirc = clk_get_rate(rc->clk_delay) / USEC_PER_SEC;\n\tif (fcclk == 0 || firc == 0)\n\t\trc->delay_us = 2;\n\telse\n\t\trc->delay_us = DIV_ROUND_UP(fcclk, firc * firc);\n\n\tspin_lock_init(&rc->lock);\n\n\trc->rcdev.owner = THIS_MODULE;\n\trc->rcdev.nr_resets = 64;\n\trc->rcdev.ops = &lpc18xx_rgu_ops;\n\trc->rcdev.of_node = pdev->dev.of_node;\n\n\tret = reset_controller_register(&rc->rcdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to register device\\n\");\n\t\tgoto dis_clks;\n\t}\n\n\trc->restart_nb.priority = 192,\n\trc->restart_nb.notifier_call = lpc18xx_rgu_restart,\n\tret = register_restart_handler(&rc->restart_nb);\n\tif (ret)\n\t\tdev_warn(&pdev->dev, \"failed to register restart handler\\n\");\n\n\treturn 0;\n\ndis_clks:\n\tclk_disable_unprepare(rc->clk_delay);\ndis_clk_reg:\n\tclk_disable_unprepare(rc->clk_reg);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id lpc18xx_rgu_match[] = {\n\t{ .compatible = \"nxp,lpc1850-rgu\" },\n\t{ }\n};\n\nstatic struct platform_driver lpc18xx_rgu_driver = {\n\t.probe\t= lpc18xx_rgu_probe,\n\t.driver\t= {\n\t\t.name\t\t\t= \"lpc18xx-reset\",\n\t\t.of_match_table\t\t= lpc18xx_rgu_match,\n\t\t.suppress_bind_attrs\t= true,\n\t},\n};\nbuiltin_platform_driver(lpc18xx_rgu_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}