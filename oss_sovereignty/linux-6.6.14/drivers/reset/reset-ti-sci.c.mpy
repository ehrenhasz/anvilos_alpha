{
  "module_name": "reset-ti-sci.c",
  "hash_id": "04f093234f8644b187b100049880637f976cd74ba0e34fa20004c4fadf487348",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-ti-sci.c",
  "human_readable_source": "\n \n\n#include <linux/idr.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/soc/ti/ti_sci_protocol.h>\n\n \nstruct ti_sci_reset_control {\n\tu32 dev_id;\n\tu32 reset_mask;\n\tstruct mutex lock;\n};\n\n \nstruct ti_sci_reset_data {\n\tstruct reset_controller_dev rcdev;\n\tstruct device *dev;\n\tconst struct ti_sci_handle *sci;\n\tstruct idr idr;\n};\n\n#define to_ti_sci_reset_data(p)\t\\\n\tcontainer_of((p), struct ti_sci_reset_data, rcdev)\n\n \nstatic int ti_sci_reset_set(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id, bool assert)\n{\n\tstruct ti_sci_reset_data *data = to_ti_sci_reset_data(rcdev);\n\tconst struct ti_sci_handle *sci = data->sci;\n\tconst struct ti_sci_dev_ops *dev_ops = &sci->ops.dev_ops;\n\tstruct ti_sci_reset_control *control;\n\tu32 reset_state;\n\tint ret;\n\n\tcontrol = idr_find(&data->idr, id);\n\tif (!control)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&control->lock);\n\n\tret = dev_ops->get_device_resets(sci, control->dev_id, &reset_state);\n\tif (ret)\n\t\tgoto out;\n\n\tif (assert)\n\t\treset_state |= control->reset_mask;\n\telse\n\t\treset_state &= ~control->reset_mask;\n\n\tret = dev_ops->set_device_resets(sci, control->dev_id, reset_state);\nout:\n\tmutex_unlock(&control->lock);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\treturn ti_sci_reset_set(rcdev, id, true);\n}\n\n \nstatic int ti_sci_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\treturn ti_sci_reset_set(rcdev, id, false);\n}\n\n \nstatic int ti_sci_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct ti_sci_reset_data *data = to_ti_sci_reset_data(rcdev);\n\tconst struct ti_sci_handle *sci = data->sci;\n\tconst struct ti_sci_dev_ops *dev_ops = &sci->ops.dev_ops;\n\tstruct ti_sci_reset_control *control;\n\tu32 reset_state;\n\tint ret;\n\n\tcontrol = idr_find(&data->idr, id);\n\tif (!control)\n\t\treturn -EINVAL;\n\n\tret = dev_ops->get_device_resets(sci, control->dev_id, &reset_state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn reset_state & control->reset_mask;\n}\n\nstatic const struct reset_control_ops ti_sci_reset_ops = {\n\t.assert\t\t= ti_sci_reset_assert,\n\t.deassert\t= ti_sci_reset_deassert,\n\t.status\t\t= ti_sci_reset_status,\n};\n\n \nstatic int ti_sci_reset_of_xlate(struct reset_controller_dev *rcdev,\n\t\t\t\t const struct of_phandle_args *reset_spec)\n{\n\tstruct ti_sci_reset_data *data = to_ti_sci_reset_data(rcdev);\n\tstruct ti_sci_reset_control *control;\n\n\tif (WARN_ON(reset_spec->args_count != rcdev->of_reset_n_cells))\n\t\treturn -EINVAL;\n\n\tcontrol = devm_kzalloc(data->dev, sizeof(*control), GFP_KERNEL);\n\tif (!control)\n\t\treturn -ENOMEM;\n\n\tcontrol->dev_id = reset_spec->args[0];\n\tcontrol->reset_mask = reset_spec->args[1];\n\tmutex_init(&control->lock);\n\n\treturn idr_alloc(&data->idr, control, 0, 0, GFP_KERNEL);\n}\n\nstatic const struct of_device_id ti_sci_reset_of_match[] = {\n\t{ .compatible = \"ti,sci-reset\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ti_sci_reset_of_match);\n\nstatic int ti_sci_reset_probe(struct platform_device *pdev)\n{\n\tstruct ti_sci_reset_data *data;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->sci = devm_ti_sci_get_handle(&pdev->dev);\n\tif (IS_ERR(data->sci))\n\t\treturn PTR_ERR(data->sci);\n\n\tdata->rcdev.ops = &ti_sci_reset_ops;\n\tdata->rcdev.owner = THIS_MODULE;\n\tdata->rcdev.of_node = pdev->dev.of_node;\n\tdata->rcdev.of_reset_n_cells = 2;\n\tdata->rcdev.of_xlate = ti_sci_reset_of_xlate;\n\tdata->dev = &pdev->dev;\n\tidr_init(&data->idr);\n\n\tplatform_set_drvdata(pdev, data);\n\n\treturn reset_controller_register(&data->rcdev);\n}\n\nstatic int ti_sci_reset_remove(struct platform_device *pdev)\n{\n\tstruct ti_sci_reset_data *data = platform_get_drvdata(pdev);\n\n\treset_controller_unregister(&data->rcdev);\n\n\tidr_destroy(&data->idr);\n\n\treturn 0;\n}\n\nstatic struct platform_driver ti_sci_reset_driver = {\n\t.probe = ti_sci_reset_probe,\n\t.remove = ti_sci_reset_remove,\n\t.driver = {\n\t\t.name = \"ti-sci-reset\",\n\t\t.of_match_table = ti_sci_reset_of_match,\n\t},\n};\nmodule_platform_driver(ti_sci_reset_driver);\n\nMODULE_AUTHOR(\"Andrew F. Davis <afd@ti.com>\");\nMODULE_DESCRIPTION(\"TI System Control Interface (TI SCI) Reset driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}