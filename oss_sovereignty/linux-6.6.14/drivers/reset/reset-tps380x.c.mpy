{
  "module_name": "reset-tps380x.c",
  "hash_id": "a089878f4a23d8a4ab06a09b76628b8b5e9fff701a12b04ae36616c9f6b8e2d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-tps380x.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/reset-controller.h>\n\nstruct tps380x_reset {\n\tstruct reset_controller_dev\trcdev;\n\tstruct gpio_desc\t\t*reset_gpio;\n\tunsigned int\t\t\treset_ms;\n};\n\nstruct tps380x_reset_devdata {\n\tunsigned int min_reset_ms;\n\tunsigned int typ_reset_ms;\n\tunsigned int max_reset_ms;\n};\n\nstatic inline\nstruct tps380x_reset *to_tps380x_reset(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct tps380x_reset, rcdev);\n}\n\nstatic int\ntps380x_reset_assert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tstruct tps380x_reset *tps380x = to_tps380x_reset(rcdev);\n\n\tgpiod_set_value_cansleep(tps380x->reset_gpio, 1);\n\n\treturn 0;\n}\n\nstatic int\ntps380x_reset_deassert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tstruct tps380x_reset *tps380x = to_tps380x_reset(rcdev);\n\n\tgpiod_set_value_cansleep(tps380x->reset_gpio, 0);\n\tmsleep(tps380x->reset_ms);\n\n\treturn 0;\n}\n\nstatic const struct reset_control_ops reset_tps380x_ops = {\n\t.assert\t\t= tps380x_reset_assert,\n\t.deassert\t= tps380x_reset_deassert,\n};\n\nstatic int tps380x_reset_of_xlate(struct reset_controller_dev *rcdev,\n\t\t\t\t  const struct of_phandle_args *reset_spec)\n{\n\t \n\treturn 0;\n}\n\nstatic int tps380x_reset_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct tps380x_reset_devdata *devdata;\n\tstruct tps380x_reset *tps380x;\n\n\tdevdata = device_get_match_data(dev);\n\tif (!devdata)\n\t\treturn -EINVAL;\n\n\ttps380x = devm_kzalloc(dev, sizeof(*tps380x), GFP_KERNEL);\n\tif (!tps380x)\n\t\treturn -ENOMEM;\n\n\ttps380x->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tps380x->reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(tps380x->reset_gpio),\n\t\t\t\t     \"Failed to get GPIO\\n\");\n\n\ttps380x->reset_ms = devdata->max_reset_ms;\n\n\ttps380x->rcdev.ops = &reset_tps380x_ops;\n\ttps380x->rcdev.owner = THIS_MODULE;\n\ttps380x->rcdev.dev = dev;\n\ttps380x->rcdev.of_node = dev->of_node;\n\ttps380x->rcdev.of_reset_n_cells = 0;\n\ttps380x->rcdev.of_xlate = tps380x_reset_of_xlate;\n\ttps380x->rcdev.nr_resets = 1;\n\n\treturn devm_reset_controller_register(dev, &tps380x->rcdev);\n}\n\nstatic const struct tps380x_reset_devdata tps3801_reset_data = {\n\t.min_reset_ms = 120,\n\t.typ_reset_ms = 200,\n\t.max_reset_ms = 280,\n};\n\nstatic const struct of_device_id tps380x_reset_dt_ids[] = {\n\t{ .compatible = \"ti,tps3801\", .data = &tps3801_reset_data },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, tps380x_reset_dt_ids);\n\nstatic struct platform_driver tps380x_reset_driver = {\n\t.probe\t= tps380x_reset_probe,\n\t.driver = {\n\t\t.name\t\t= \"tps380x-reset\",\n\t\t.of_match_table\t= tps380x_reset_dt_ids,\n\t},\n};\nmodule_platform_driver(tps380x_reset_driver);\n\nMODULE_AUTHOR(\"Marco Felsch <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"TI TPS380x Supply Voltage Supervisor and Reset Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}