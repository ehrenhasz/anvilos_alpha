{
  "module_name": "reset-syscfg.c",
  "hash_id": "68f2ddfb5d8a01a467d3af49ba7f15a26f26f9e00f3828c883c935f7cc9ee41d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/sti/reset-syscfg.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/types.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n\n#include \"reset-syscfg.h\"\n\n \nstruct syscfg_reset_channel {\n\tstruct regmap_field *reset;\n\tstruct regmap_field *ack;\n};\n\n \nstruct syscfg_reset_controller {\n\tstruct reset_controller_dev rst;\n\tbool active_low;\n\tstruct syscfg_reset_channel *channels;\n};\n\n#define to_syscfg_reset_controller(_rst) \\\n\tcontainer_of(_rst, struct syscfg_reset_controller, rst)\n\nstatic int syscfg_reset_program_hw(struct reset_controller_dev *rcdev,\n\t\t\t\t   unsigned long idx, int assert)\n{\n\tstruct syscfg_reset_controller *rst = to_syscfg_reset_controller(rcdev);\n\tconst struct syscfg_reset_channel *ch;\n\tu32 ctrl_val = rst->active_low ? !assert : !!assert;\n\tint err;\n\n\tif (idx >= rcdev->nr_resets)\n\t\treturn -EINVAL;\n\n\tch = &rst->channels[idx];\n\n\terr = regmap_field_write(ch->reset, ctrl_val);\n\tif (err)\n\t\treturn err;\n\n\tif (ch->ack) {\n\t\tu32 ack_val;\n\n\t\terr = regmap_field_read_poll_timeout(ch->ack, ack_val, (ack_val == ctrl_val),\n\t\t\t\t\t\t     100, USEC_PER_SEC);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int syscfg_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long idx)\n{\n\treturn syscfg_reset_program_hw(rcdev, idx, true);\n}\n\nstatic int syscfg_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long idx)\n{\n\treturn syscfg_reset_program_hw(rcdev, idx, false);\n}\n\nstatic int syscfg_reset_dev(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long idx)\n{\n\tint err;\n\n\terr = syscfg_reset_assert(rcdev, idx);\n\tif (err)\n\t\treturn err;\n\n\treturn syscfg_reset_deassert(rcdev, idx);\n}\n\nstatic int syscfg_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long idx)\n{\n\tstruct syscfg_reset_controller *rst = to_syscfg_reset_controller(rcdev);\n\tconst struct syscfg_reset_channel *ch;\n\tu32 ret_val = 0;\n\tint err;\n\n\tif (idx >= rcdev->nr_resets)\n\t\treturn -EINVAL;\n\n\tch = &rst->channels[idx];\n\tif (ch->ack)\n\t\terr = regmap_field_read(ch->ack, &ret_val);\n\telse\n\t\terr = regmap_field_read(ch->reset, &ret_val);\n\tif (err)\n\t\treturn err;\n\n\treturn rst->active_low ? !ret_val : !!ret_val;\n}\n\nstatic const struct reset_control_ops syscfg_reset_ops = {\n\t.reset    = syscfg_reset_dev,\n\t.assert   = syscfg_reset_assert,\n\t.deassert = syscfg_reset_deassert,\n\t.status   = syscfg_reset_status,\n};\n\nstatic int syscfg_reset_controller_register(struct device *dev,\n\t\t\t\tconst struct syscfg_reset_controller_data *data)\n{\n\tstruct syscfg_reset_controller *rc;\n\tint i, err;\n\n\trc = devm_kzalloc(dev, sizeof(*rc), GFP_KERNEL);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\n\trc->channels = devm_kcalloc(dev, data->nr_channels,\n\t\t\t\t    sizeof(*rc->channels), GFP_KERNEL);\n\tif (!rc->channels)\n\t\treturn -ENOMEM;\n\n\trc->rst.ops = &syscfg_reset_ops;\n\trc->rst.of_node = dev->of_node;\n\trc->rst.nr_resets = data->nr_channels;\n\trc->active_low = data->active_low;\n\n\tfor (i = 0; i < data->nr_channels; i++) {\n\t\tstruct regmap *map;\n\t\tstruct regmap_field *f;\n\t\tconst char *compatible = data->channels[i].compatible;\n\n\t\tmap = syscon_regmap_lookup_by_compatible(compatible);\n\t\tif (IS_ERR(map))\n\t\t\treturn PTR_ERR(map);\n\n\t\tf = devm_regmap_field_alloc(dev, map, data->channels[i].reset);\n\t\tif (IS_ERR(f))\n\t\t\treturn PTR_ERR(f);\n\n\t\trc->channels[i].reset = f;\n\n\t\tif (!data->wait_for_ack)\n\t\t\tcontinue;\n\n\t\tf = devm_regmap_field_alloc(dev, map, data->channels[i].ack);\n\t\tif (IS_ERR(f))\n\t\t\treturn PTR_ERR(f);\n\n\t\trc->channels[i].ack = f;\n\t}\n\n\terr = reset_controller_register(&rc->rst);\n\tif (!err)\n\t\tdev_info(dev, \"registered\\n\");\n\n\treturn err;\n}\n\nint syscfg_reset_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = pdev ? &pdev->dev : NULL;\n\tconst struct of_device_id *match;\n\n\tif (!dev || !dev->driver)\n\t\treturn -ENODEV;\n\n\tmatch = of_match_device(dev->driver->of_match_table, dev);\n\tif (!match || !match->data)\n\t\treturn -EINVAL;\n\n\treturn syscfg_reset_controller_register(dev, match->data);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}