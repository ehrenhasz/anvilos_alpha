{
  "module_name": "reset-zynq.c",
  "hash_id": "6b24b62c8bfe76b5185f9ec5a92156c93f4bb21ab5e06a58cd749ad7b759f9c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-zynq.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\nstruct zynq_reset_data {\n\tstruct regmap *slcr;\n\tstruct reset_controller_dev rcdev;\n\tu32 offset;\n};\n\n#define to_zynq_reset_data(p)\t\t\\\n\tcontainer_of((p), struct zynq_reset_data, rcdev)\n\nstatic int zynq_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\tstruct zynq_reset_data *priv = to_zynq_reset_data(rcdev);\n\n\tint bank = id / BITS_PER_LONG;\n\tint offset = id % BITS_PER_LONG;\n\n\tpr_debug(\"%s: %s reset bank %u offset %u\\n\", KBUILD_MODNAME, __func__,\n\t\t bank, offset);\n\n\treturn regmap_update_bits(priv->slcr,\n\t\t\t\t  priv->offset + (bank * 4),\n\t\t\t\t  BIT(offset),\n\t\t\t\t  BIT(offset));\n}\n\nstatic int zynq_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct zynq_reset_data *priv = to_zynq_reset_data(rcdev);\n\n\tint bank = id / BITS_PER_LONG;\n\tint offset = id % BITS_PER_LONG;\n\n\tpr_debug(\"%s: %s reset bank %u offset %u\\n\", KBUILD_MODNAME, __func__,\n\t\t bank, offset);\n\n\treturn regmap_update_bits(priv->slcr,\n\t\t\t\t  priv->offset + (bank * 4),\n\t\t\t\t  BIT(offset),\n\t\t\t\t  ~BIT(offset));\n}\n\nstatic int zynq_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\tstruct zynq_reset_data *priv = to_zynq_reset_data(rcdev);\n\n\tint bank = id / BITS_PER_LONG;\n\tint offset = id % BITS_PER_LONG;\n\tint ret;\n\tu32 reg;\n\n\tpr_debug(\"%s: %s reset bank %u offset %u\\n\", KBUILD_MODNAME, __func__,\n\t\t bank, offset);\n\n\tret = regmap_read(priv->slcr, priv->offset + (bank * 4), &reg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(reg & BIT(offset));\n}\n\nstatic const struct reset_control_ops zynq_reset_ops = {\n\t.assert\t\t= zynq_reset_assert,\n\t.deassert\t= zynq_reset_deassert,\n\t.status\t\t= zynq_reset_status,\n};\n\nstatic int zynq_reset_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct zynq_reset_data *priv;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->slcr = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t     \"syscon\");\n\tif (IS_ERR(priv->slcr)) {\n\t\tdev_err(&pdev->dev, \"unable to get zynq-slcr regmap\");\n\t\treturn PTR_ERR(priv->slcr);\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"missing IO resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->offset = res->start;\n\n\tpriv->rcdev.owner = THIS_MODULE;\n\tpriv->rcdev.nr_resets = resource_size(res) / 4 * BITS_PER_LONG;\n\tpriv->rcdev.ops = &zynq_reset_ops;\n\tpriv->rcdev.of_node = pdev->dev.of_node;\n\n\treturn devm_reset_controller_register(&pdev->dev, &priv->rcdev);\n}\n\nstatic const struct of_device_id zynq_reset_dt_ids[] = {\n\t{ .compatible = \"xlnx,zynq-reset\", },\n\t{   },\n};\n\nstatic struct platform_driver zynq_reset_driver = {\n\t.probe\t= zynq_reset_probe,\n\t.driver = {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= zynq_reset_dt_ids,\n\t},\n};\nbuiltin_platform_driver(zynq_reset_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}