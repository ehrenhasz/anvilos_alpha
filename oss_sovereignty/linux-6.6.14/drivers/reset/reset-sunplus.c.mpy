{
  "module_name": "reset-sunplus.c",
  "hash_id": "4c78b2dc7bc162a6fdfb14c57caf0222ba46bff76f560dbbbe5b8940242de6de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-sunplus.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/reboot.h>\n\n \n#define BITS_PER_HWM_REG\t16\n\n \nstatic const u32 sp_resets[] = {\n \n\t0x00,\n\t0x02,\n\t0x03,\n\t0x04,\n\t0x05,\n\t0x06,\n\t0x07,\n\t0x08,\n\t0x09,\n\t0x0a,\n\t0x0b,\n\t0x0d,\n\t0x0e,\n\t0x0f,\n\t0x10,\n\t0x12,\n\t0x14,\n\t0x15,\n\t0x16,\n\t0x17,\n\t0x18,\n\t0x19,\n\t0x1a,\n\t0x1b,\n\t0x1c,\n\t0x1d,\n\t0x1e,\n\t0x1f,\n\t0x20,\n\t0x21,\n\t0x22,\n\t0x23,\n\t0x24,\n\t0x25,\n\t0x26,\n\t0x2a,\n\t0x2b,\n\t0x2d,\n\t0x2e,\n\t0x30,\n\t0x31,\n\t0x32,\n\t0x33,\n\t0x3d,\n\t0x3e,\n\t0x3f,\n\t0x42,\n\t0x44,\n\t0x4b,\n\t0x4c,\n\t0x4d,\n\t0x4e,\n\t0x4f,\n\t0x50,\n\t0x55,\n\t0x60,\n\t0x61,\n\t0x6a,\n\t0x6f,\n\t0x70,\n\t0x73,\n\t0x74,\n\t0x86,\n\t0x8a,\n\t0x8b,\n\t0x8d,\n\t0x8e,\n\t0x8f,\n\t0x90,\n\t0x92,\n\t0x93,\n\t0x94,\n\t0x95,\n\t0x96,\n\t0x97,\n\t0x98,\n\t0x99,\n};\n\nstruct sp_reset {\n\tstruct reset_controller_dev rcdev;\n\tstruct notifier_block notifier;\n\tvoid __iomem *base;\n};\n\nstatic inline struct sp_reset *to_sp_reset(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct sp_reset, rcdev);\n}\n\nstatic int sp_reset_update(struct reset_controller_dev *rcdev,\n\t\t\t   unsigned long id, bool assert)\n{\n\tstruct sp_reset *reset = to_sp_reset(rcdev);\n\tint index = sp_resets[id] / BITS_PER_HWM_REG;\n\tint shift = sp_resets[id] % BITS_PER_HWM_REG;\n\tu32 val;\n\n\tval = (1 << (16 + shift)) | (assert << shift);\n\twritel(val, reset->base + (index * 4));\n\n\treturn 0;\n}\n\nstatic int sp_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t   unsigned long id)\n{\n\treturn sp_reset_update(rcdev, id, true);\n}\n\nstatic int sp_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\treturn sp_reset_update(rcdev, id, false);\n}\n\nstatic int sp_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t   unsigned long id)\n{\n\tstruct sp_reset *reset = to_sp_reset(rcdev);\n\tint index = sp_resets[id] / BITS_PER_HWM_REG;\n\tint shift = sp_resets[id] % BITS_PER_HWM_REG;\n\tu32 reg;\n\n\treg = readl(reset->base + (index * 4));\n\n\treturn !!(reg & BIT(shift));\n}\n\nstatic const struct reset_control_ops sp_reset_ops = {\n\t.assert   = sp_reset_assert,\n\t.deassert = sp_reset_deassert,\n\t.status   = sp_reset_status,\n};\n\nstatic int sp_restart(struct notifier_block *nb, unsigned long mode,\n\t\t      void *cmd)\n{\n\tstruct sp_reset *reset = container_of(nb, struct sp_reset, notifier);\n\n\tsp_reset_assert(&reset->rcdev, 0);\n\tsp_reset_deassert(&reset->rcdev, 0);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int sp_reset_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sp_reset *reset;\n\tstruct resource *res;\n\tint ret;\n\n\treset = devm_kzalloc(dev, sizeof(*reset), GFP_KERNEL);\n\tif (!reset)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\treset->base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(reset->base))\n\t\treturn PTR_ERR(reset->base);\n\n\treset->rcdev.ops = &sp_reset_ops;\n\treset->rcdev.owner = THIS_MODULE;\n\treset->rcdev.of_node = dev->of_node;\n\treset->rcdev.nr_resets = resource_size(res) / 4 * BITS_PER_HWM_REG;\n\n\tret = devm_reset_controller_register(dev, &reset->rcdev);\n\tif (ret)\n\t\treturn ret;\n\n\treset->notifier.notifier_call = sp_restart;\n\treset->notifier.priority = 192;\n\n\treturn register_restart_handler(&reset->notifier);\n}\n\nstatic const struct of_device_id sp_reset_dt_ids[] = {\n\t{.compatible = \"sunplus,sp7021-reset\",},\n\t{   },\n};\n\nstatic struct platform_driver sp_reset_driver = {\n\t.probe = sp_reset_probe,\n\t.driver = {\n\t\t.name\t\t\t= \"sunplus-reset\",\n\t\t.of_match_table\t\t= sp_reset_dt_ids,\n\t\t.suppress_bind_attrs\t= true,\n\t},\n};\nbuiltin_platform_driver(sp_reset_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}