{
  "module_name": "reset-uniphier-glue.c",
  "hash_id": "313060627965f771ed20e87adf367f84453b98ad4f88da008d5c8dce7d9e67c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-uniphier-glue.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/reset/reset-simple.h>\n\n#define MAX_CLKS\t2\n#define MAX_RSTS\t2\n\nstruct uniphier_glue_reset_soc_data {\n\tint nclks;\n\tconst char * const *clock_names;\n\tint nrsts;\n\tconst char * const *reset_names;\n};\n\nstruct uniphier_glue_reset_priv {\n\tstruct clk_bulk_data clk[MAX_CLKS];\n\tstruct reset_control_bulk_data rst[MAX_RSTS];\n\tstruct reset_simple_data rdata;\n\tconst struct uniphier_glue_reset_soc_data *data;\n};\n\nstatic void uniphier_clk_disable(void *_priv)\n{\n\tstruct uniphier_glue_reset_priv *priv = _priv;\n\n\tclk_bulk_disable_unprepare(priv->data->nclks, priv->clk);\n}\n\nstatic void uniphier_rst_assert(void *_priv)\n{\n\tstruct uniphier_glue_reset_priv *priv = _priv;\n\n\treset_control_bulk_assert(priv->data->nrsts, priv->rst);\n}\n\nstatic int uniphier_glue_reset_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_glue_reset_priv *priv;\n\tstruct resource *res;\n\tint i, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->data = of_device_get_match_data(dev);\n\tif (WARN_ON(!priv->data || priv->data->nclks > MAX_CLKS ||\n\t\t    priv->data->nrsts > MAX_RSTS))\n\t\treturn -EINVAL;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tpriv->rdata.membase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(priv->rdata.membase))\n\t\treturn PTR_ERR(priv->rdata.membase);\n\n\tfor (i = 0; i < priv->data->nclks; i++)\n\t\tpriv->clk[i].id = priv->data->clock_names[i];\n\tret = devm_clk_bulk_get(dev, priv->data->nclks, priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < priv->data->nrsts; i++)\n\t\tpriv->rst[i].id = priv->data->reset_names[i];\n\tret = devm_reset_control_bulk_get_shared(dev, priv->data->nrsts,\n\t\t\t\t\t\t priv->rst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(priv->data->nclks, priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, uniphier_clk_disable, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_bulk_deassert(priv->data->nrsts, priv->rst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, uniphier_rst_assert, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_init(&priv->rdata.lock);\n\tpriv->rdata.rcdev.owner = THIS_MODULE;\n\tpriv->rdata.rcdev.nr_resets = resource_size(res) * BITS_PER_BYTE;\n\tpriv->rdata.rcdev.ops = &reset_simple_ops;\n\tpriv->rdata.rcdev.of_node = dev->of_node;\n\tpriv->rdata.active_low = true;\n\n\treturn devm_reset_controller_register(dev, &priv->rdata.rcdev);\n}\n\nstatic const char * const uniphier_pro4_clock_reset_names[] = {\n\t\"gio\", \"link\",\n};\n\nstatic const struct uniphier_glue_reset_soc_data uniphier_pro4_data = {\n\t.nclks = ARRAY_SIZE(uniphier_pro4_clock_reset_names),\n\t.clock_names = uniphier_pro4_clock_reset_names,\n\t.nrsts = ARRAY_SIZE(uniphier_pro4_clock_reset_names),\n\t.reset_names = uniphier_pro4_clock_reset_names,\n};\n\nstatic const char * const uniphier_pxs2_clock_reset_names[] = {\n\t\"link\",\n};\n\nstatic const struct uniphier_glue_reset_soc_data uniphier_pxs2_data = {\n\t.nclks = ARRAY_SIZE(uniphier_pxs2_clock_reset_names),\n\t.clock_names = uniphier_pxs2_clock_reset_names,\n\t.nrsts = ARRAY_SIZE(uniphier_pxs2_clock_reset_names),\n\t.reset_names = uniphier_pxs2_clock_reset_names,\n};\n\nstatic const struct of_device_id uniphier_glue_reset_match[] = {\n\t{\n\t\t.compatible = \"socionext,uniphier-pro4-usb3-reset\",\n\t\t.data = &uniphier_pro4_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pro5-usb3-reset\",\n\t\t.data = &uniphier_pro4_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs2-usb3-reset\",\n\t\t.data = &uniphier_pxs2_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-ld20-usb3-reset\",\n\t\t.data = &uniphier_pxs2_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs3-usb3-reset\",\n\t\t.data = &uniphier_pxs2_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-nx1-usb3-reset\",\n\t\t.data = &uniphier_pxs2_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pro4-ahci-reset\",\n\t\t.data = &uniphier_pro4_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs2-ahci-reset\",\n\t\t.data = &uniphier_pxs2_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs3-ahci-reset\",\n\t\t.data = &uniphier_pxs2_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_glue_reset_match);\n\nstatic struct platform_driver uniphier_glue_reset_driver = {\n\t.probe = uniphier_glue_reset_probe,\n\t.driver = {\n\t\t.name = \"uniphier-glue-reset\",\n\t\t.of_match_table = uniphier_glue_reset_match,\n\t},\n};\nmodule_platform_driver(uniphier_glue_reset_driver);\n\nMODULE_AUTHOR(\"Kunihiko Hayashi <hayashi.kunihiko@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier Glue layer reset driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}