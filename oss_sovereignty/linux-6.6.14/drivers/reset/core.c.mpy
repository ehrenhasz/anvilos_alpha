{
  "module_name": "core.c",
  "hash_id": "fde893b053df78ee87e7fe87a023d420a7964c28460a83075c41cfc184feec7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/core.c",
  "human_readable_source": "\n \n#include <linux/atomic.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/acpi.h>\n#include <linux/reset.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n\nstatic DEFINE_MUTEX(reset_list_mutex);\nstatic LIST_HEAD(reset_controller_list);\n\nstatic DEFINE_MUTEX(reset_lookup_mutex);\nstatic LIST_HEAD(reset_lookup_list);\n\n \nstruct reset_control {\n\tstruct reset_controller_dev *rcdev;\n\tstruct list_head list;\n\tunsigned int id;\n\tstruct kref refcnt;\n\tbool acquired;\n\tbool shared;\n\tbool array;\n\tatomic_t deassert_count;\n\tatomic_t triggered_count;\n};\n\n \nstruct reset_control_array {\n\tstruct reset_control base;\n\tunsigned int num_rstcs;\n\tstruct reset_control *rstc[];\n};\n\nstatic const char *rcdev_name(struct reset_controller_dev *rcdev)\n{\n\tif (rcdev->dev)\n\t\treturn dev_name(rcdev->dev);\n\n\tif (rcdev->of_node)\n\t\treturn rcdev->of_node->full_name;\n\n\treturn NULL;\n}\n\n \nstatic int of_reset_simple_xlate(struct reset_controller_dev *rcdev,\n\t\t\t\t const struct of_phandle_args *reset_spec)\n{\n\tif (reset_spec->args[0] >= rcdev->nr_resets)\n\t\treturn -EINVAL;\n\n\treturn reset_spec->args[0];\n}\n\n \nint reset_controller_register(struct reset_controller_dev *rcdev)\n{\n\tif (!rcdev->of_xlate) {\n\t\trcdev->of_reset_n_cells = 1;\n\t\trcdev->of_xlate = of_reset_simple_xlate;\n\t}\n\n\tINIT_LIST_HEAD(&rcdev->reset_control_head);\n\n\tmutex_lock(&reset_list_mutex);\n\tlist_add(&rcdev->list, &reset_controller_list);\n\tmutex_unlock(&reset_list_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(reset_controller_register);\n\n \nvoid reset_controller_unregister(struct reset_controller_dev *rcdev)\n{\n\tmutex_lock(&reset_list_mutex);\n\tlist_del(&rcdev->list);\n\tmutex_unlock(&reset_list_mutex);\n}\nEXPORT_SYMBOL_GPL(reset_controller_unregister);\n\nstatic void devm_reset_controller_release(struct device *dev, void *res)\n{\n\treset_controller_unregister(*(struct reset_controller_dev **)res);\n}\n\n \nint devm_reset_controller_register(struct device *dev,\n\t\t\t\t   struct reset_controller_dev *rcdev)\n{\n\tstruct reset_controller_dev **rcdevp;\n\tint ret;\n\n\trcdevp = devres_alloc(devm_reset_controller_release, sizeof(*rcdevp),\n\t\t\t      GFP_KERNEL);\n\tif (!rcdevp)\n\t\treturn -ENOMEM;\n\n\tret = reset_controller_register(rcdev);\n\tif (ret) {\n\t\tdevres_free(rcdevp);\n\t\treturn ret;\n\t}\n\n\t*rcdevp = rcdev;\n\tdevres_add(dev, rcdevp);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_reset_controller_register);\n\n \nvoid reset_controller_add_lookup(struct reset_control_lookup *lookup,\n\t\t\t\t unsigned int num_entries)\n{\n\tstruct reset_control_lookup *entry;\n\tunsigned int i;\n\n\tmutex_lock(&reset_lookup_mutex);\n\tfor (i = 0; i < num_entries; i++) {\n\t\tentry = &lookup[i];\n\n\t\tif (!entry->dev_id || !entry->provider) {\n\t\t\tpr_warn(\"%s(): reset lookup entry badly specified, skipping\\n\",\n\t\t\t\t__func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_add_tail(&entry->list, &reset_lookup_list);\n\t}\n\tmutex_unlock(&reset_lookup_mutex);\n}\nEXPORT_SYMBOL_GPL(reset_controller_add_lookup);\n\nstatic inline struct reset_control_array *\nrstc_to_array(struct reset_control *rstc) {\n\treturn container_of(rstc, struct reset_control_array, base);\n}\n\nstatic int reset_control_array_reset(struct reset_control_array *resets)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < resets->num_rstcs; i++) {\n\t\tret = reset_control_reset(resets->rstc[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int reset_control_array_rearm(struct reset_control_array *resets)\n{\n\tstruct reset_control *rstc;\n\tint i;\n\n\tfor (i = 0; i < resets->num_rstcs; i++) {\n\t\trstc = resets->rstc[i];\n\n\t\tif (!rstc)\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(IS_ERR(rstc)))\n\t\t\treturn -EINVAL;\n\n\t\tif (rstc->shared) {\n\t\t\tif (WARN_ON(atomic_read(&rstc->deassert_count) != 0))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (!rstc->acquired)\n\t\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < resets->num_rstcs; i++) {\n\t\trstc = resets->rstc[i];\n\n\t\tif (rstc && rstc->shared)\n\t\t\tWARN_ON(atomic_dec_return(&rstc->triggered_count) < 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int reset_control_array_assert(struct reset_control_array *resets)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < resets->num_rstcs; i++) {\n\t\tret = reset_control_assert(resets->rstc[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\treset_control_deassert(resets->rstc[i]);\n\treturn ret;\n}\n\nstatic int reset_control_array_deassert(struct reset_control_array *resets)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < resets->num_rstcs; i++) {\n\t\tret = reset_control_deassert(resets->rstc[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\treset_control_assert(resets->rstc[i]);\n\treturn ret;\n}\n\nstatic int reset_control_array_acquire(struct reset_control_array *resets)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < resets->num_rstcs; i++) {\n\t\terr = reset_control_acquire(resets->rstc[i]);\n\t\tif (err < 0)\n\t\t\tgoto release;\n\t}\n\n\treturn 0;\n\nrelease:\n\twhile (i--)\n\t\treset_control_release(resets->rstc[i]);\n\n\treturn err;\n}\n\nstatic void reset_control_array_release(struct reset_control_array *resets)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < resets->num_rstcs; i++)\n\t\treset_control_release(resets->rstc[i]);\n}\n\nstatic inline bool reset_control_is_array(struct reset_control *rstc)\n{\n\treturn rstc->array;\n}\n\n \nint reset_control_reset(struct reset_control *rstc)\n{\n\tint ret;\n\n\tif (!rstc)\n\t\treturn 0;\n\n\tif (WARN_ON(IS_ERR(rstc)))\n\t\treturn -EINVAL;\n\n\tif (reset_control_is_array(rstc))\n\t\treturn reset_control_array_reset(rstc_to_array(rstc));\n\n\tif (!rstc->rcdev->ops->reset)\n\t\treturn -ENOTSUPP;\n\n\tif (rstc->shared) {\n\t\tif (WARN_ON(atomic_read(&rstc->deassert_count) != 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (atomic_inc_return(&rstc->triggered_count) != 1)\n\t\t\treturn 0;\n\t} else {\n\t\tif (!rstc->acquired)\n\t\t\treturn -EPERM;\n\t}\n\n\tret = rstc->rcdev->ops->reset(rstc->rcdev, rstc->id);\n\tif (rstc->shared && ret)\n\t\tatomic_dec(&rstc->triggered_count);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(reset_control_reset);\n\n \nint reset_control_bulk_reset(int num_rstcs,\n\t\t\t     struct reset_control_bulk_data *rstcs)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < num_rstcs; i++) {\n\t\tret = reset_control_reset(rstcs[i].rstc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(reset_control_bulk_reset);\n\n \nint reset_control_rearm(struct reset_control *rstc)\n{\n\tif (!rstc)\n\t\treturn 0;\n\n\tif (WARN_ON(IS_ERR(rstc)))\n\t\treturn -EINVAL;\n\n\tif (reset_control_is_array(rstc))\n\t\treturn reset_control_array_rearm(rstc_to_array(rstc));\n\n\tif (rstc->shared) {\n\t\tif (WARN_ON(atomic_read(&rstc->deassert_count) != 0))\n\t\t\treturn -EINVAL;\n\n\t\tWARN_ON(atomic_dec_return(&rstc->triggered_count) < 0);\n\t} else {\n\t\tif (!rstc->acquired)\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(reset_control_rearm);\n\n \nint reset_control_assert(struct reset_control *rstc)\n{\n\tif (!rstc)\n\t\treturn 0;\n\n\tif (WARN_ON(IS_ERR(rstc)))\n\t\treturn -EINVAL;\n\n\tif (reset_control_is_array(rstc))\n\t\treturn reset_control_array_assert(rstc_to_array(rstc));\n\n\tif (rstc->shared) {\n\t\tif (WARN_ON(atomic_read(&rstc->triggered_count) != 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(atomic_read(&rstc->deassert_count) == 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (atomic_dec_return(&rstc->deassert_count) != 0)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!rstc->rcdev->ops->assert)\n\t\t\treturn 0;\n\t} else {\n\t\t \n\t\tif (!rstc->rcdev->ops->assert)\n\t\t\treturn -ENOTSUPP;\n\n\t\tif (!rstc->acquired) {\n\t\t\tWARN(1, \"reset %s (ID: %u) is not acquired\\n\",\n\t\t\t     rcdev_name(rstc->rcdev), rstc->id);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn rstc->rcdev->ops->assert(rstc->rcdev, rstc->id);\n}\nEXPORT_SYMBOL_GPL(reset_control_assert);\n\n \nint reset_control_bulk_assert(int num_rstcs,\n\t\t\t      struct reset_control_bulk_data *rstcs)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < num_rstcs; i++) {\n\t\tret = reset_control_assert(rstcs[i].rstc);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\treset_control_deassert(rstcs[i].rstc);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(reset_control_bulk_assert);\n\n \nint reset_control_deassert(struct reset_control *rstc)\n{\n\tif (!rstc)\n\t\treturn 0;\n\n\tif (WARN_ON(IS_ERR(rstc)))\n\t\treturn -EINVAL;\n\n\tif (reset_control_is_array(rstc))\n\t\treturn reset_control_array_deassert(rstc_to_array(rstc));\n\n\tif (rstc->shared) {\n\t\tif (WARN_ON(atomic_read(&rstc->triggered_count) != 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (atomic_inc_return(&rstc->deassert_count) != 1)\n\t\t\treturn 0;\n\t} else {\n\t\tif (!rstc->acquired) {\n\t\t\tWARN(1, \"reset %s (ID: %u) is not acquired\\n\",\n\t\t\t     rcdev_name(rstc->rcdev), rstc->id);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\t \n\tif (!rstc->rcdev->ops->deassert)\n\t\treturn 0;\n\n\treturn rstc->rcdev->ops->deassert(rstc->rcdev, rstc->id);\n}\nEXPORT_SYMBOL_GPL(reset_control_deassert);\n\n \nint reset_control_bulk_deassert(int num_rstcs,\n\t\t\t\tstruct reset_control_bulk_data *rstcs)\n{\n\tint ret, i;\n\n\tfor (i = num_rstcs - 1; i >= 0; i--) {\n\t\tret = reset_control_deassert(rstcs[i].rstc);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (i < num_rstcs)\n\t\treset_control_assert(rstcs[i++].rstc);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(reset_control_bulk_deassert);\n\n \nint reset_control_status(struct reset_control *rstc)\n{\n\tif (!rstc)\n\t\treturn 0;\n\n\tif (WARN_ON(IS_ERR(rstc)) || reset_control_is_array(rstc))\n\t\treturn -EINVAL;\n\n\tif (rstc->rcdev->ops->status)\n\t\treturn rstc->rcdev->ops->status(rstc->rcdev, rstc->id);\n\n\treturn -ENOTSUPP;\n}\nEXPORT_SYMBOL_GPL(reset_control_status);\n\n \nint reset_control_acquire(struct reset_control *rstc)\n{\n\tstruct reset_control *rc;\n\n\tif (!rstc)\n\t\treturn 0;\n\n\tif (WARN_ON(IS_ERR(rstc)))\n\t\treturn -EINVAL;\n\n\tif (reset_control_is_array(rstc))\n\t\treturn reset_control_array_acquire(rstc_to_array(rstc));\n\n\tmutex_lock(&reset_list_mutex);\n\n\tif (rstc->acquired) {\n\t\tmutex_unlock(&reset_list_mutex);\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(rc, &rstc->rcdev->reset_control_head, list) {\n\t\tif (rstc != rc && rstc->id == rc->id) {\n\t\t\tif (rc->acquired) {\n\t\t\t\tmutex_unlock(&reset_list_mutex);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\n\trstc->acquired = true;\n\n\tmutex_unlock(&reset_list_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(reset_control_acquire);\n\n \nint reset_control_bulk_acquire(int num_rstcs,\n\t\t\t       struct reset_control_bulk_data *rstcs)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < num_rstcs; i++) {\n\t\tret = reset_control_acquire(rstcs[i].rstc);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\treset_control_release(rstcs[i].rstc);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(reset_control_bulk_acquire);\n\n \nvoid reset_control_release(struct reset_control *rstc)\n{\n\tif (!rstc || WARN_ON(IS_ERR(rstc)))\n\t\treturn;\n\n\tif (reset_control_is_array(rstc))\n\t\treset_control_array_release(rstc_to_array(rstc));\n\telse\n\t\trstc->acquired = false;\n}\nEXPORT_SYMBOL_GPL(reset_control_release);\n\n \nvoid reset_control_bulk_release(int num_rstcs,\n\t\t\t\tstruct reset_control_bulk_data *rstcs)\n{\n\tint i;\n\n\tfor (i = 0; i < num_rstcs; i++)\n\t\treset_control_release(rstcs[i].rstc);\n}\nEXPORT_SYMBOL_GPL(reset_control_bulk_release);\n\nstatic struct reset_control *\n__reset_control_get_internal(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned int index, bool shared, bool acquired)\n{\n\tstruct reset_control *rstc;\n\n\tlockdep_assert_held(&reset_list_mutex);\n\n\tlist_for_each_entry(rstc, &rcdev->reset_control_head, list) {\n\t\tif (rstc->id == index) {\n\t\t\t \n\t\t\tif (!rstc->shared && !shared && !acquired)\n\t\t\t\tbreak;\n\n\t\t\tif (WARN_ON(!rstc->shared || !shared))\n\t\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\t\tkref_get(&rstc->refcnt);\n\t\t\treturn rstc;\n\t\t}\n\t}\n\n\trstc = kzalloc(sizeof(*rstc), GFP_KERNEL);\n\tif (!rstc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!try_module_get(rcdev->owner)) {\n\t\tkfree(rstc);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\trstc->rcdev = rcdev;\n\tlist_add(&rstc->list, &rcdev->reset_control_head);\n\trstc->id = index;\n\tkref_init(&rstc->refcnt);\n\trstc->acquired = acquired;\n\trstc->shared = shared;\n\n\treturn rstc;\n}\n\nstatic void __reset_control_release(struct kref *kref)\n{\n\tstruct reset_control *rstc = container_of(kref, struct reset_control,\n\t\t\t\t\t\t  refcnt);\n\n\tlockdep_assert_held(&reset_list_mutex);\n\n\tmodule_put(rstc->rcdev->owner);\n\n\tlist_del(&rstc->list);\n\tkfree(rstc);\n}\n\nstatic void __reset_control_put_internal(struct reset_control *rstc)\n{\n\tlockdep_assert_held(&reset_list_mutex);\n\n\tif (IS_ERR_OR_NULL(rstc))\n\t\treturn;\n\n\tkref_put(&rstc->refcnt, __reset_control_release);\n}\n\nstruct reset_control *\n__of_reset_control_get(struct device_node *node, const char *id, int index,\n\t\t       bool shared, bool optional, bool acquired)\n{\n\tstruct reset_control *rstc;\n\tstruct reset_controller_dev *r, *rcdev;\n\tstruct of_phandle_args args;\n\tint rstc_id;\n\tint ret;\n\n\tif (!node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (id) {\n\t\tindex = of_property_match_string(node,\n\t\t\t\t\t\t \"reset-names\", id);\n\t\tif (index == -EILSEQ)\n\t\t\treturn ERR_PTR(index);\n\t\tif (index < 0)\n\t\t\treturn optional ? NULL : ERR_PTR(-ENOENT);\n\t}\n\n\tret = of_parse_phandle_with_args(node, \"resets\", \"#reset-cells\",\n\t\t\t\t\t index, &args);\n\tif (ret == -EINVAL)\n\t\treturn ERR_PTR(ret);\n\tif (ret)\n\t\treturn optional ? NULL : ERR_PTR(ret);\n\n\tmutex_lock(&reset_list_mutex);\n\trcdev = NULL;\n\tlist_for_each_entry(r, &reset_controller_list, list) {\n\t\tif (args.np == r->of_node) {\n\t\t\trcdev = r;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!rcdev) {\n\t\trstc = ERR_PTR(-EPROBE_DEFER);\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON(args.args_count != rcdev->of_reset_n_cells)) {\n\t\trstc = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\trstc_id = rcdev->of_xlate(rcdev, &args);\n\tif (rstc_id < 0) {\n\t\trstc = ERR_PTR(rstc_id);\n\t\tgoto out;\n\t}\n\n\t \n\trstc = __reset_control_get_internal(rcdev, rstc_id, shared, acquired);\n\nout:\n\tmutex_unlock(&reset_list_mutex);\n\tof_node_put(args.np);\n\n\treturn rstc;\n}\nEXPORT_SYMBOL_GPL(__of_reset_control_get);\n\nstatic struct reset_controller_dev *\n__reset_controller_by_name(const char *name)\n{\n\tstruct reset_controller_dev *rcdev;\n\n\tlockdep_assert_held(&reset_list_mutex);\n\n\tlist_for_each_entry(rcdev, &reset_controller_list, list) {\n\t\tif (!rcdev->dev)\n\t\t\tcontinue;\n\n\t\tif (!strcmp(name, dev_name(rcdev->dev)))\n\t\t\treturn rcdev;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct reset_control *\n__reset_control_get_from_lookup(struct device *dev, const char *con_id,\n\t\t\t\tbool shared, bool optional, bool acquired)\n{\n\tconst struct reset_control_lookup *lookup;\n\tstruct reset_controller_dev *rcdev;\n\tconst char *dev_id = dev_name(dev);\n\tstruct reset_control *rstc = NULL;\n\n\tmutex_lock(&reset_lookup_mutex);\n\n\tlist_for_each_entry(lookup, &reset_lookup_list, list) {\n\t\tif (strcmp(lookup->dev_id, dev_id))\n\t\t\tcontinue;\n\n\t\tif ((!con_id && !lookup->con_id) ||\n\t\t    ((con_id && lookup->con_id) &&\n\t\t     !strcmp(con_id, lookup->con_id))) {\n\t\t\tmutex_lock(&reset_list_mutex);\n\t\t\trcdev = __reset_controller_by_name(lookup->provider);\n\t\t\tif (!rcdev) {\n\t\t\t\tmutex_unlock(&reset_list_mutex);\n\t\t\t\tmutex_unlock(&reset_lookup_mutex);\n\t\t\t\t \n\t\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t\t\t}\n\n\t\t\trstc = __reset_control_get_internal(rcdev,\n\t\t\t\t\t\t\t    lookup->index,\n\t\t\t\t\t\t\t    shared, acquired);\n\t\t\tmutex_unlock(&reset_list_mutex);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&reset_lookup_mutex);\n\n\tif (!rstc)\n\t\treturn optional ? NULL : ERR_PTR(-ENOENT);\n\n\treturn rstc;\n}\n\nstruct reset_control *__reset_control_get(struct device *dev, const char *id,\n\t\t\t\t\t  int index, bool shared, bool optional,\n\t\t\t\t\t  bool acquired)\n{\n\tif (WARN_ON(shared && acquired))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (dev->of_node)\n\t\treturn __of_reset_control_get(dev->of_node, id, index, shared,\n\t\t\t\t\t      optional, acquired);\n\n\treturn __reset_control_get_from_lookup(dev, id, shared, optional,\n\t\t\t\t\t       acquired);\n}\nEXPORT_SYMBOL_GPL(__reset_control_get);\n\nint __reset_control_bulk_get(struct device *dev, int num_rstcs,\n\t\t\t     struct reset_control_bulk_data *rstcs,\n\t\t\t     bool shared, bool optional, bool acquired)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < num_rstcs; i++) {\n\t\trstcs[i].rstc = __reset_control_get(dev, rstcs[i].id, 0,\n\t\t\t\t\t\t    shared, optional, acquired);\n\t\tif (IS_ERR(rstcs[i].rstc)) {\n\t\t\tret = PTR_ERR(rstcs[i].rstc);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tmutex_lock(&reset_list_mutex);\n\twhile (i--)\n\t\t__reset_control_put_internal(rstcs[i].rstc);\n\tmutex_unlock(&reset_list_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__reset_control_bulk_get);\n\nstatic void reset_control_array_put(struct reset_control_array *resets)\n{\n\tint i;\n\n\tmutex_lock(&reset_list_mutex);\n\tfor (i = 0; i < resets->num_rstcs; i++)\n\t\t__reset_control_put_internal(resets->rstc[i]);\n\tmutex_unlock(&reset_list_mutex);\n\tkfree(resets);\n}\n\n \nvoid reset_control_put(struct reset_control *rstc)\n{\n\tif (IS_ERR_OR_NULL(rstc))\n\t\treturn;\n\n\tif (reset_control_is_array(rstc)) {\n\t\treset_control_array_put(rstc_to_array(rstc));\n\t\treturn;\n\t}\n\n\tmutex_lock(&reset_list_mutex);\n\t__reset_control_put_internal(rstc);\n\tmutex_unlock(&reset_list_mutex);\n}\nEXPORT_SYMBOL_GPL(reset_control_put);\n\n \nvoid reset_control_bulk_put(int num_rstcs, struct reset_control_bulk_data *rstcs)\n{\n\tmutex_lock(&reset_list_mutex);\n\twhile (num_rstcs--)\n\t\t__reset_control_put_internal(rstcs[num_rstcs].rstc);\n\tmutex_unlock(&reset_list_mutex);\n}\nEXPORT_SYMBOL_GPL(reset_control_bulk_put);\n\nstatic void devm_reset_control_release(struct device *dev, void *res)\n{\n\treset_control_put(*(struct reset_control **)res);\n}\n\nstruct reset_control *\n__devm_reset_control_get(struct device *dev, const char *id, int index,\n\t\t\t bool shared, bool optional, bool acquired)\n{\n\tstruct reset_control **ptr, *rstc;\n\n\tptr = devres_alloc(devm_reset_control_release, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trstc = __reset_control_get(dev, id, index, shared, optional, acquired);\n\tif (IS_ERR_OR_NULL(rstc)) {\n\t\tdevres_free(ptr);\n\t\treturn rstc;\n\t}\n\n\t*ptr = rstc;\n\tdevres_add(dev, ptr);\n\n\treturn rstc;\n}\nEXPORT_SYMBOL_GPL(__devm_reset_control_get);\n\nstruct reset_control_bulk_devres {\n\tint num_rstcs;\n\tstruct reset_control_bulk_data *rstcs;\n};\n\nstatic void devm_reset_control_bulk_release(struct device *dev, void *res)\n{\n\tstruct reset_control_bulk_devres *devres = res;\n\n\treset_control_bulk_put(devres->num_rstcs, devres->rstcs);\n}\n\nint __devm_reset_control_bulk_get(struct device *dev, int num_rstcs,\n\t\t\t\t  struct reset_control_bulk_data *rstcs,\n\t\t\t\t  bool shared, bool optional, bool acquired)\n{\n\tstruct reset_control_bulk_devres *ptr;\n\tint ret;\n\n\tptr = devres_alloc(devm_reset_control_bulk_release, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tret = __reset_control_bulk_get(dev, num_rstcs, rstcs, shared, optional, acquired);\n\tif (ret < 0) {\n\t\tdevres_free(ptr);\n\t\treturn ret;\n\t}\n\n\tptr->num_rstcs = num_rstcs;\n\tptr->rstcs = rstcs;\n\tdevres_add(dev, ptr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__devm_reset_control_bulk_get);\n\n \nint __device_reset(struct device *dev, bool optional)\n{\n\tstruct reset_control *rstc;\n\tint ret;\n\n#ifdef CONFIG_ACPI\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\n\tif (handle) {\n\t\tif (!acpi_has_method(handle, \"_RST\"))\n\t\t\treturn optional ? 0 : -ENOENT;\n\t\tif (ACPI_FAILURE(acpi_evaluate_object(handle, \"_RST\", NULL,\n\t\t\t\t\t\t      NULL)))\n\t\t\treturn -EIO;\n\t}\n#endif\n\n\trstc = __reset_control_get(dev, NULL, 0, 0, optional, true);\n\tif (IS_ERR(rstc))\n\t\treturn PTR_ERR(rstc);\n\n\tret = reset_control_reset(rstc);\n\n\treset_control_put(rstc);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__device_reset);\n\n \n\n \nstatic int of_reset_control_get_count(struct device_node *node)\n{\n\tint count;\n\n\tif (!node)\n\t\treturn -EINVAL;\n\n\tcount = of_count_phandle_with_args(node, \"resets\", \"#reset-cells\");\n\tif (count == 0)\n\t\tcount = -ENOENT;\n\n\treturn count;\n}\n\n \nstruct reset_control *\nof_reset_control_array_get(struct device_node *np, bool shared, bool optional,\n\t\t\t   bool acquired)\n{\n\tstruct reset_control_array *resets;\n\tstruct reset_control *rstc;\n\tint num, i;\n\n\tnum = of_reset_control_get_count(np);\n\tif (num < 0)\n\t\treturn optional ? NULL : ERR_PTR(num);\n\n\tresets = kzalloc(struct_size(resets, rstc, num), GFP_KERNEL);\n\tif (!resets)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < num; i++) {\n\t\trstc = __of_reset_control_get(np, NULL, i, shared, optional,\n\t\t\t\t\t      acquired);\n\t\tif (IS_ERR(rstc))\n\t\t\tgoto err_rst;\n\t\tresets->rstc[i] = rstc;\n\t}\n\tresets->num_rstcs = num;\n\tresets->base.array = true;\n\n\treturn &resets->base;\n\nerr_rst:\n\tmutex_lock(&reset_list_mutex);\n\twhile (--i >= 0)\n\t\t__reset_control_put_internal(resets->rstc[i]);\n\tmutex_unlock(&reset_list_mutex);\n\n\tkfree(resets);\n\n\treturn rstc;\n}\nEXPORT_SYMBOL_GPL(of_reset_control_array_get);\n\n \nstruct reset_control *\ndevm_reset_control_array_get(struct device *dev, bool shared, bool optional)\n{\n\tstruct reset_control **ptr, *rstc;\n\n\tptr = devres_alloc(devm_reset_control_release, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trstc = of_reset_control_array_get(dev->of_node, shared, optional, true);\n\tif (IS_ERR_OR_NULL(rstc)) {\n\t\tdevres_free(ptr);\n\t\treturn rstc;\n\t}\n\n\t*ptr = rstc;\n\tdevres_add(dev, ptr);\n\n\treturn rstc;\n}\nEXPORT_SYMBOL_GPL(devm_reset_control_array_get);\n\nstatic int reset_control_get_count_from_lookup(struct device *dev)\n{\n\tconst struct reset_control_lookup *lookup;\n\tconst char *dev_id;\n\tint count = 0;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tdev_id = dev_name(dev);\n\tmutex_lock(&reset_lookup_mutex);\n\n\tlist_for_each_entry(lookup, &reset_lookup_list, list) {\n\t\tif (!strcmp(lookup->dev_id, dev_id))\n\t\t\tcount++;\n\t}\n\n\tmutex_unlock(&reset_lookup_mutex);\n\n\tif (count == 0)\n\t\tcount = -ENOENT;\n\n\treturn count;\n}\n\n \nint reset_control_get_count(struct device *dev)\n{\n\tif (dev->of_node)\n\t\treturn of_reset_control_get_count(dev->of_node);\n\n\treturn reset_control_get_count_from_lookup(dev);\n}\nEXPORT_SYMBOL_GPL(reset_control_get_count);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}