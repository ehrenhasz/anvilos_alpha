{
  "module_name": "reset-ma35d1.c",
  "hash_id": "bc9ca8c35b3fac40d1167879e03e383598bb3ea828853addec6c0bcc1000dc8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-ma35d1.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/container_of.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/reset-controller.h>\n#include <linux/spinlock.h>\n#include <dt-bindings/reset/nuvoton,ma35d1-reset.h>\n\nstruct ma35d1_reset_data {\n\tstruct reset_controller_dev rcdev;\n\tstruct notifier_block restart_handler;\n\tvoid __iomem *base;\n\t \n\tspinlock_t lock;\n};\n\nstatic const struct {\n\tu32 reg_ofs;\n\tu32 bit;\n} ma35d1_reset_map[] = {\n\t[MA35D1_RESET_CHIP] =    {0x20, 0},\n\t[MA35D1_RESET_CA35CR0] = {0x20, 1},\n\t[MA35D1_RESET_CA35CR1] = {0x20, 2},\n\t[MA35D1_RESET_CM4] =     {0x20, 3},\n\t[MA35D1_RESET_PDMA0] =   {0x20, 4},\n\t[MA35D1_RESET_PDMA1] =   {0x20, 5},\n\t[MA35D1_RESET_PDMA2] =   {0x20, 6},\n\t[MA35D1_RESET_PDMA3] =   {0x20, 7},\n\t[MA35D1_RESET_DISP] =    {0x20, 9},\n\t[MA35D1_RESET_VCAP0] =   {0x20, 10},\n\t[MA35D1_RESET_VCAP1] =   {0x20, 11},\n\t[MA35D1_RESET_GFX] =     {0x20, 12},\n\t[MA35D1_RESET_VDEC] =    {0x20, 13},\n\t[MA35D1_RESET_WHC0] =    {0x20, 14},\n\t[MA35D1_RESET_WHC1] =    {0x20, 15},\n\t[MA35D1_RESET_GMAC0] =   {0x20, 16},\n\t[MA35D1_RESET_GMAC1] =   {0x20, 17},\n\t[MA35D1_RESET_HWSEM] =   {0x20, 18},\n\t[MA35D1_RESET_EBI] =     {0x20, 19},\n\t[MA35D1_RESET_HSUSBH0] = {0x20, 20},\n\t[MA35D1_RESET_HSUSBH1] = {0x20, 21},\n\t[MA35D1_RESET_HSUSBD] =  {0x20, 22},\n\t[MA35D1_RESET_USBHL] =   {0x20, 23},\n\t[MA35D1_RESET_SDH0] =    {0x20, 24},\n\t[MA35D1_RESET_SDH1] =    {0x20, 25},\n\t[MA35D1_RESET_NAND] =    {0x20, 26},\n\t[MA35D1_RESET_GPIO] =    {0x20, 27},\n\t[MA35D1_RESET_MCTLP] =   {0x20, 28},\n\t[MA35D1_RESET_MCTLC] =   {0x20, 29},\n\t[MA35D1_RESET_DDRPUB] =  {0x20, 30},\n\t[MA35D1_RESET_TMR0] =    {0x24, 2},\n\t[MA35D1_RESET_TMR1] =    {0x24, 3},\n\t[MA35D1_RESET_TMR2] =    {0x24, 4},\n\t[MA35D1_RESET_TMR3] =    {0x24, 5},\n\t[MA35D1_RESET_I2C0] =    {0x24, 8},\n\t[MA35D1_RESET_I2C1] =    {0x24, 9},\n\t[MA35D1_RESET_I2C2] =    {0x24, 10},\n\t[MA35D1_RESET_I2C3] =    {0x24, 11},\n\t[MA35D1_RESET_QSPI0] =   {0x24, 12},\n\t[MA35D1_RESET_SPI0] =    {0x24, 13},\n\t[MA35D1_RESET_SPI1] =    {0x24, 14},\n\t[MA35D1_RESET_SPI2] =    {0x24, 15},\n\t[MA35D1_RESET_UART0] =   {0x24, 16},\n\t[MA35D1_RESET_UART1] =   {0x24, 17},\n\t[MA35D1_RESET_UART2] =   {0x24, 18},\n\t[MA35D1_RESET_UART3] =   {0x24, 19},\n\t[MA35D1_RESET_UART4] =   {0x24, 20},\n\t[MA35D1_RESET_UART5] =   {0x24, 21},\n\t[MA35D1_RESET_UART6] =   {0x24, 22},\n\t[MA35D1_RESET_UART7] =   {0x24, 23},\n\t[MA35D1_RESET_CANFD0] =  {0x24, 24},\n\t[MA35D1_RESET_CANFD1] =  {0x24, 25},\n\t[MA35D1_RESET_EADC0] =   {0x24, 28},\n\t[MA35D1_RESET_I2S0] =    {0x24, 29},\n\t[MA35D1_RESET_SC0] =     {0x28, 0},\n\t[MA35D1_RESET_SC1] =     {0x28, 1},\n\t[MA35D1_RESET_QSPI1] =   {0x28, 4},\n\t[MA35D1_RESET_SPI3] =    {0x28, 6},\n\t[MA35D1_RESET_EPWM0] =   {0x28, 16},\n\t[MA35D1_RESET_EPWM1] =   {0x28, 17},\n\t[MA35D1_RESET_QEI0] =    {0x28, 22},\n\t[MA35D1_RESET_QEI1] =    {0x28, 23},\n\t[MA35D1_RESET_ECAP0] =   {0x28, 26},\n\t[MA35D1_RESET_ECAP1] =   {0x28, 27},\n\t[MA35D1_RESET_CANFD2] =  {0x28, 28},\n\t[MA35D1_RESET_ADC0] =    {0x28, 31},\n\t[MA35D1_RESET_TMR4] =    {0x2C, 0},\n\t[MA35D1_RESET_TMR5] =    {0x2C, 1},\n\t[MA35D1_RESET_TMR6] =    {0x2C, 2},\n\t[MA35D1_RESET_TMR7] =    {0x2C, 3},\n\t[MA35D1_RESET_TMR8] =    {0x2C, 4},\n\t[MA35D1_RESET_TMR9] =    {0x2C, 5},\n\t[MA35D1_RESET_TMR10] =   {0x2C, 6},\n\t[MA35D1_RESET_TMR11] =   {0x2C, 7},\n\t[MA35D1_RESET_UART8] =   {0x2C, 8},\n\t[MA35D1_RESET_UART9] =   {0x2C, 9},\n\t[MA35D1_RESET_UART10] =  {0x2C, 10},\n\t[MA35D1_RESET_UART11] =  {0x2C, 11},\n\t[MA35D1_RESET_UART12] =  {0x2C, 12},\n\t[MA35D1_RESET_UART13] =  {0x2C, 13},\n\t[MA35D1_RESET_UART14] =  {0x2C, 14},\n\t[MA35D1_RESET_UART15] =  {0x2C, 15},\n\t[MA35D1_RESET_UART16] =  {0x2C, 16},\n\t[MA35D1_RESET_I2S1] =    {0x2C, 17},\n\t[MA35D1_RESET_I2C4] =    {0x2C, 18},\n\t[MA35D1_RESET_I2C5] =    {0x2C, 19},\n\t[MA35D1_RESET_EPWM2] =   {0x2C, 20},\n\t[MA35D1_RESET_ECAP2] =   {0x2C, 21},\n\t[MA35D1_RESET_QEI2] =    {0x2C, 22},\n\t[MA35D1_RESET_CANFD3] =  {0x2C, 23},\n\t[MA35D1_RESET_KPI] =     {0x2C, 24},\n\t[MA35D1_RESET_GIC] =     {0x2C, 28},\n\t[MA35D1_RESET_SSMCC] =   {0x2C, 30},\n\t[MA35D1_RESET_SSPCC] =   {0x2C, 31}\n};\n\nstatic int ma35d1_restart_handler(struct notifier_block *this, unsigned long mode, void *cmd)\n{\n\tstruct ma35d1_reset_data *data =\n\t\t\t\t container_of(this, struct ma35d1_reset_data, restart_handler);\n\tu32 id = MA35D1_RESET_CHIP;\n\n\twritel_relaxed(BIT(ma35d1_reset_map[id].bit),\n\t\t       data->base + ma35d1_reset_map[id].reg_ofs);\n\treturn 0;\n}\n\nstatic int ma35d1_reset_update(struct reset_controller_dev *rcdev, unsigned long id, bool assert)\n{\n\tstruct ma35d1_reset_data *data = container_of(rcdev, struct ma35d1_reset_data, rcdev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (WARN_ON_ONCE(id >= ARRAY_SIZE(ma35d1_reset_map)))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\treg = readl_relaxed(data->base + ma35d1_reset_map[id].reg_ofs);\n\tif (assert)\n\t\treg |= BIT(ma35d1_reset_map[id].bit);\n\telse\n\t\treg &= ~(BIT(ma35d1_reset_map[id].bit));\n\twritel_relaxed(reg, data->base + ma35d1_reset_map[id].reg_ofs);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ma35d1_reset_assert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\treturn ma35d1_reset_update(rcdev, id, true);\n}\n\nstatic int ma35d1_reset_deassert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\treturn ma35d1_reset_update(rcdev, id, false);\n}\n\nstatic int ma35d1_reset_status(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tstruct ma35d1_reset_data *data = container_of(rcdev, struct ma35d1_reset_data, rcdev);\n\tu32 reg;\n\n\tif (WARN_ON_ONCE(id >= ARRAY_SIZE(ma35d1_reset_map)))\n\t\treturn -EINVAL;\n\n\treg = readl_relaxed(data->base + ma35d1_reset_map[id].reg_ofs);\n\treturn !!(reg & BIT(ma35d1_reset_map[id].bit));\n}\n\nstatic const struct reset_control_ops ma35d1_reset_ops = {\n\t.assert = ma35d1_reset_assert,\n\t.deassert = ma35d1_reset_deassert,\n\t.status = ma35d1_reset_status,\n};\n\nstatic const struct of_device_id ma35d1_reset_dt_ids[] = {\n\t{ .compatible = \"nuvoton,ma35d1-reset\" },\n\t{ },\n};\n\nstatic int ma35d1_reset_probe(struct platform_device *pdev)\n{\n\tstruct ma35d1_reset_data *reset_data;\n\tstruct device *dev = &pdev->dev;\n\tint err;\n\n\tif (!pdev->dev.of_node) {\n\t\tdev_err(&pdev->dev, \"Device tree node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treset_data = devm_kzalloc(dev, sizeof(*reset_data), GFP_KERNEL);\n\tif (!reset_data)\n\t\treturn -ENOMEM;\n\n\treset_data->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reset_data->base))\n\t\treturn PTR_ERR(reset_data->base);\n\n\treset_data->rcdev.owner = THIS_MODULE;\n\treset_data->rcdev.nr_resets = MA35D1_RESET_COUNT;\n\treset_data->rcdev.ops = &ma35d1_reset_ops;\n\treset_data->rcdev.of_node = dev->of_node;\n\treset_data->restart_handler.notifier_call = ma35d1_restart_handler;\n\treset_data->restart_handler.priority = 192;\n\tspin_lock_init(&reset_data->lock);\n\n\terr = register_restart_handler(&reset_data->restart_handler);\n\tif (err)\n\t\tdev_warn(&pdev->dev, \"failed to register restart handler\\n\");\n\n\treturn devm_reset_controller_register(dev, &reset_data->rcdev);\n}\n\nstatic struct platform_driver ma35d1_reset_driver = {\n\t.probe = ma35d1_reset_probe,\n\t.driver = {\n\t\t.name = \"ma35d1-reset\",\n\t\t.of_match_table\t= ma35d1_reset_dt_ids,\n\t},\n};\n\nbuiltin_platform_driver(ma35d1_reset_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}