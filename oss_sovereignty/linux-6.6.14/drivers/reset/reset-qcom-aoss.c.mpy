{
  "module_name": "reset-qcom-aoss.c",
  "hash_id": "5afbf304e5c36c72c6fe3f0997de33293e4f0c9e7fb1aad99d5dc3109e6adacb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-qcom-aoss.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <dt-bindings/reset/qcom,sdm845-aoss.h>\n\nstruct qcom_aoss_reset_map {\n\tunsigned int reg;\n};\n\nstruct qcom_aoss_desc {\n\tconst struct qcom_aoss_reset_map *resets;\n\tsize_t num_resets;\n};\n\nstruct qcom_aoss_reset_data {\n\tstruct reset_controller_dev rcdev;\n\tvoid __iomem *base;\n\tconst struct qcom_aoss_desc *desc;\n};\n\nstatic const struct qcom_aoss_reset_map sdm845_aoss_resets[] = {\n\t[AOSS_CC_MSS_RESTART] = {0x10000},\n\t[AOSS_CC_CAMSS_RESTART] = {0x11000},\n\t[AOSS_CC_VENUS_RESTART] = {0x12000},\n\t[AOSS_CC_GPU_RESTART] = {0x13000},\n\t[AOSS_CC_DISPSS_RESTART] = {0x14000},\n\t[AOSS_CC_WCSS_RESTART] = {0x20000},\n\t[AOSS_CC_LPASS_RESTART] = {0x30000},\n};\n\nstatic const struct qcom_aoss_desc sdm845_aoss_desc = {\n\t.resets = sdm845_aoss_resets,\n\t.num_resets = ARRAY_SIZE(sdm845_aoss_resets),\n};\n\nstatic inline struct qcom_aoss_reset_data *to_qcom_aoss_reset_data(\n\t\t\t\tstruct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct qcom_aoss_reset_data, rcdev);\n}\n\nstatic int qcom_aoss_control_assert(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long idx)\n{\n\tstruct qcom_aoss_reset_data *data = to_qcom_aoss_reset_data(rcdev);\n\tconst struct qcom_aoss_reset_map *map = &data->desc->resets[idx];\n\n\twritel(1, data->base + map->reg);\n\t \n\tusleep_range(200, 300);\n\treturn 0;\n}\n\nstatic int qcom_aoss_control_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t      unsigned long idx)\n{\n\tstruct qcom_aoss_reset_data *data = to_qcom_aoss_reset_data(rcdev);\n\tconst struct qcom_aoss_reset_map *map = &data->desc->resets[idx];\n\n\twritel(0, data->base + map->reg);\n\t \n\tusleep_range(200, 300);\n\treturn 0;\n}\n\nstatic int qcom_aoss_control_reset(struct reset_controller_dev *rcdev,\n\t\t\t\t\tunsigned long idx)\n{\n\tqcom_aoss_control_assert(rcdev, idx);\n\n\treturn qcom_aoss_control_deassert(rcdev, idx);\n}\n\nstatic const struct reset_control_ops qcom_aoss_reset_ops = {\n\t.reset = qcom_aoss_control_reset,\n\t.assert = qcom_aoss_control_assert,\n\t.deassert = qcom_aoss_control_deassert,\n};\n\nstatic int qcom_aoss_reset_probe(struct platform_device *pdev)\n{\n\tstruct qcom_aoss_reset_data *data;\n\tstruct device *dev = &pdev->dev;\n\tconst struct qcom_aoss_desc *desc;\n\tstruct resource *res;\n\n\tdesc = of_device_get_match_data(dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->desc = desc;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tdata->base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(data->base))\n\t\treturn PTR_ERR(data->base);\n\n\tdata->rcdev.owner = THIS_MODULE;\n\tdata->rcdev.ops = &qcom_aoss_reset_ops;\n\tdata->rcdev.nr_resets = desc->num_resets;\n\tdata->rcdev.of_node = dev->of_node;\n\n\treturn devm_reset_controller_register(dev, &data->rcdev);\n}\n\nstatic const struct of_device_id qcom_aoss_reset_of_match[] = {\n\t{ .compatible = \"qcom,sdm845-aoss-cc\", .data = &sdm845_aoss_desc },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qcom_aoss_reset_of_match);\n\nstatic struct platform_driver qcom_aoss_reset_driver = {\n\t.probe = qcom_aoss_reset_probe,\n\t.driver  = {\n\t\t.name = \"qcom_aoss_reset\",\n\t\t.of_match_table = qcom_aoss_reset_of_match,\n\t},\n};\n\nmodule_platform_driver(qcom_aoss_reset_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm AOSS Reset Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}