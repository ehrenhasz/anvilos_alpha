{
  "module_name": "hi6220_reset.c",
  "hash_id": "3b7196467f34b3ae9542103ff51f4f3c387195d51ab66f1501a9753340d453d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/hisilicon/hi6220_reset.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/reset-controller.h>\n#include <linux/reset.h>\n#include <linux/platform_device.h>\n\n#define PERIPH_ASSERT_OFFSET      0x300\n#define PERIPH_DEASSERT_OFFSET    0x304\n#define PERIPH_MAX_INDEX          0x509\n\n#define SC_MEDIA_RSTEN            0x052C\n#define SC_MEDIA_RSTDIS           0x0530\n#define MEDIA_MAX_INDEX           8\n\n#define to_reset_data(x) container_of(x, struct hi6220_reset_data, rc_dev)\n\nenum hi6220_reset_ctrl_type {\n\tPERIPHERAL,\n\tMEDIA,\n\tAO,\n};\n\nstruct hi6220_reset_data {\n\tstruct reset_controller_dev rc_dev;\n\tstruct regmap *regmap;\n};\n\nstatic int hi6220_peripheral_assert(struct reset_controller_dev *rc_dev,\n\t\t\t\t    unsigned long idx)\n{\n\tstruct hi6220_reset_data *data = to_reset_data(rc_dev);\n\tstruct regmap *regmap = data->regmap;\n\tu32 bank = idx >> 8;\n\tu32 offset = idx & 0xff;\n\tu32 reg = PERIPH_ASSERT_OFFSET + bank * 0x10;\n\n\treturn regmap_write(regmap, reg, BIT(offset));\n}\n\nstatic int hi6220_peripheral_deassert(struct reset_controller_dev *rc_dev,\n\t\t\t\t      unsigned long idx)\n{\n\tstruct hi6220_reset_data *data = to_reset_data(rc_dev);\n\tstruct regmap *regmap = data->regmap;\n\tu32 bank = idx >> 8;\n\tu32 offset = idx & 0xff;\n\tu32 reg = PERIPH_DEASSERT_OFFSET + bank * 0x10;\n\n\treturn regmap_write(regmap, reg, BIT(offset));\n}\n\nstatic const struct reset_control_ops hi6220_peripheral_reset_ops = {\n\t.assert = hi6220_peripheral_assert,\n\t.deassert = hi6220_peripheral_deassert,\n};\n\nstatic int hi6220_media_assert(struct reset_controller_dev *rc_dev,\n\t\t\t       unsigned long idx)\n{\n\tstruct hi6220_reset_data *data = to_reset_data(rc_dev);\n\tstruct regmap *regmap = data->regmap;\n\n\treturn regmap_write(regmap, SC_MEDIA_RSTEN, BIT(idx));\n}\n\nstatic int hi6220_media_deassert(struct reset_controller_dev *rc_dev,\n\t\t\t\t unsigned long idx)\n{\n\tstruct hi6220_reset_data *data = to_reset_data(rc_dev);\n\tstruct regmap *regmap = data->regmap;\n\n\treturn regmap_write(regmap, SC_MEDIA_RSTDIS, BIT(idx));\n}\n\nstatic const struct reset_control_ops hi6220_media_reset_ops = {\n\t.assert = hi6220_media_assert,\n\t.deassert = hi6220_media_deassert,\n};\n\n#define AO_SCTRL_SC_PW_CLKEN0     0x800\n#define AO_SCTRL_SC_PW_CLKDIS0    0x804\n\n#define AO_SCTRL_SC_PW_RSTEN0     0x810\n#define AO_SCTRL_SC_PW_RSTDIS0    0x814\n\n#define AO_SCTRL_SC_PW_ISOEN0     0x820\n#define AO_SCTRL_SC_PW_ISODIS0    0x824\n#define AO_MAX_INDEX              12\n\nstatic int hi6220_ao_assert(struct reset_controller_dev *rc_dev,\n\t\t\t       unsigned long idx)\n{\n\tstruct hi6220_reset_data *data = to_reset_data(rc_dev);\n\tstruct regmap *regmap = data->regmap;\n\tint ret;\n\n\tret = regmap_write(regmap, AO_SCTRL_SC_PW_RSTEN0, BIT(idx));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(regmap, AO_SCTRL_SC_PW_ISOEN0, BIT(idx));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(regmap, AO_SCTRL_SC_PW_CLKDIS0, BIT(idx));\n\treturn ret;\n}\n\nstatic int hi6220_ao_deassert(struct reset_controller_dev *rc_dev,\n\t\t\t\t unsigned long idx)\n{\n\tstruct hi6220_reset_data *data = to_reset_data(rc_dev);\n\tstruct regmap *regmap = data->regmap;\n\tint ret;\n\n\t \n\tret = regmap_write(regmap, AO_SCTRL_SC_PW_RSTDIS0, BIT(idx));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(regmap, AO_SCTRL_SC_PW_ISODIS0, BIT(idx));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(regmap, AO_SCTRL_SC_PW_CLKEN0, BIT(idx));\n\treturn ret;\n}\n\nstatic const struct reset_control_ops hi6220_ao_reset_ops = {\n\t.assert = hi6220_ao_assert,\n\t.deassert = hi6220_ao_deassert,\n};\n\nstatic int hi6220_reset_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tenum hi6220_reset_ctrl_type type;\n\tstruct hi6220_reset_data *data;\n\tstruct regmap *regmap;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ttype = (uintptr_t)of_device_get_match_data(dev);\n\n\tregmap = syscon_node_to_regmap(np);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"failed to get reset controller regmap\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tdata->regmap = regmap;\n\tdata->rc_dev.of_node = np;\n\tif (type == MEDIA) {\n\t\tdata->rc_dev.ops = &hi6220_media_reset_ops;\n\t\tdata->rc_dev.nr_resets = MEDIA_MAX_INDEX;\n\t} else if (type == PERIPHERAL) {\n\t\tdata->rc_dev.ops = &hi6220_peripheral_reset_ops;\n\t\tdata->rc_dev.nr_resets = PERIPH_MAX_INDEX;\n\t} else {\n\t\tdata->rc_dev.ops = &hi6220_ao_reset_ops;\n\t\tdata->rc_dev.nr_resets = AO_MAX_INDEX;\n\t}\n\n\treturn reset_controller_register(&data->rc_dev);\n}\n\nstatic const struct of_device_id hi6220_reset_match[] = {\n\t{\n\t\t.compatible = \"hisilicon,hi6220-sysctrl\",\n\t\t.data = (void *)PERIPHERAL,\n\t},\n\t{\n\t\t.compatible = \"hisilicon,hi6220-mediactrl\",\n\t\t.data = (void *)MEDIA,\n\t},\n\t{\n\t\t.compatible = \"hisilicon,hi6220-aoctrl\",\n\t\t.data = (void *)AO,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, hi6220_reset_match);\n\nstatic struct platform_driver hi6220_reset_driver = {\n\t.probe = hi6220_reset_probe,\n\t.driver = {\n\t\t.name = \"reset-hi6220\",\n\t\t.of_match_table = hi6220_reset_match,\n\t},\n};\n\nstatic int __init hi6220_reset_init(void)\n{\n\treturn platform_driver_register(&hi6220_reset_driver);\n}\n\npostcore_initcall(hi6220_reset_init);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}