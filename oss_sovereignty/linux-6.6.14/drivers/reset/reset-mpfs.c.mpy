{
  "module_name": "reset-mpfs.c",
  "hash_id": "c0f0b80c6f28adadaee9763641d2e333250718a13629cba2982b940a436e603c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-mpfs.c",
  "human_readable_source": "\n \n#include <linux/auxiliary_bus.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <dt-bindings/clock/microchip,mpfs-clock.h>\n#include <soc/microchip/mpfs.h>\n\n \n#define MPFS_PERIPH_OFFSET\tCLK_ENVM\n#define MPFS_NUM_RESETS\t\t30u\n#define MPFS_SLEEP_MIN_US\t100\n#define MPFS_SLEEP_MAX_US\t200\n\n \nstatic DEFINE_SPINLOCK(mpfs_reset_lock);\n\n \n\nstatic int mpfs_assert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&mpfs_reset_lock, flags);\n\n\treg = mpfs_reset_read(rcdev->dev);\n\treg |= BIT(id);\n\tmpfs_reset_write(rcdev->dev, reg);\n\n\tspin_unlock_irqrestore(&mpfs_reset_lock, flags);\n\n\treturn 0;\n}\n\nstatic int mpfs_deassert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&mpfs_reset_lock, flags);\n\n\treg = mpfs_reset_read(rcdev->dev);\n\treg &= ~BIT(id);\n\tmpfs_reset_write(rcdev->dev, reg);\n\n\tspin_unlock_irqrestore(&mpfs_reset_lock, flags);\n\n\treturn 0;\n}\n\nstatic int mpfs_status(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tu32 reg = mpfs_reset_read(rcdev->dev);\n\n\t \n\treturn (reg & BIT(id));\n}\n\nstatic int mpfs_reset(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tmpfs_assert(rcdev, id);\n\n\tusleep_range(MPFS_SLEEP_MIN_US, MPFS_SLEEP_MAX_US);\n\n\tmpfs_deassert(rcdev, id);\n\n\treturn 0;\n}\n\nstatic const struct reset_control_ops mpfs_reset_ops = {\n\t.reset = mpfs_reset,\n\t.assert = mpfs_assert,\n\t.deassert = mpfs_deassert,\n\t.status = mpfs_status,\n};\n\nstatic int mpfs_reset_xlate(struct reset_controller_dev *rcdev,\n\t\t\t    const struct of_phandle_args *reset_spec)\n{\n\tunsigned int index = reset_spec->args[0];\n\n\t \n\tif (index == CLK_RESERVED) {\n\t\tdev_err(rcdev->dev, \"Resetting the fabric is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (index < MPFS_PERIPH_OFFSET || index >= (MPFS_PERIPH_OFFSET + rcdev->nr_resets)) {\n\t\tdev_err(rcdev->dev, \"Invalid reset index %u\\n\", index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn index - MPFS_PERIPH_OFFSET;\n}\n\nstatic int mpfs_reset_probe(struct auxiliary_device *adev,\n\t\t\t    const struct auxiliary_device_id *id)\n{\n\tstruct device *dev = &adev->dev;\n\tstruct reset_controller_dev *rcdev;\n\n\trcdev = devm_kzalloc(dev, sizeof(*rcdev), GFP_KERNEL);\n\tif (!rcdev)\n\t\treturn -ENOMEM;\n\n\trcdev->dev = dev;\n\trcdev->dev->parent = dev->parent;\n\trcdev->ops = &mpfs_reset_ops;\n\trcdev->of_node = dev->parent->of_node;\n\trcdev->of_reset_n_cells = 1;\n\trcdev->of_xlate = mpfs_reset_xlate;\n\trcdev->nr_resets = MPFS_NUM_RESETS;\n\n\treturn devm_reset_controller_register(dev, rcdev);\n}\n\nstatic const struct auxiliary_device_id mpfs_reset_ids[] = {\n\t{\n\t\t.name = \"clk_mpfs.reset-mpfs\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(auxiliary, mpfs_reset_ids);\n\nstatic struct auxiliary_driver mpfs_reset_driver = {\n\t.probe\t\t= mpfs_reset_probe,\n\t.id_table\t= mpfs_reset_ids,\n};\n\nmodule_auxiliary_driver(mpfs_reset_driver);\n\nMODULE_DESCRIPTION(\"Microchip PolarFire SoC Reset Driver\");\nMODULE_AUTHOR(\"Conor Dooley <conor.dooley@microchip.com>\");\nMODULE_IMPORT_NS(MCHP_CLK_MPFS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}