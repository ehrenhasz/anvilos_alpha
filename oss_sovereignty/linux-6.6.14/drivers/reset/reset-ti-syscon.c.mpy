{
  "module_name": "reset-ti-syscon.c",
  "hash_id": "d6b1309c12c19db0b5858cec6db776692eb04c1731eb96dc418977f80b9cb854",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-ti-syscon.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n\n#include <dt-bindings/reset/ti-syscon.h>\n\n \nstruct ti_syscon_reset_control {\n\tunsigned int assert_offset;\n\tunsigned int assert_bit;\n\tunsigned int deassert_offset;\n\tunsigned int deassert_bit;\n\tunsigned int status_offset;\n\tunsigned int status_bit;\n\tu32 flags;\n};\n\n \nstruct ti_syscon_reset_data {\n\tstruct reset_controller_dev rcdev;\n\tstruct regmap *regmap;\n\tstruct ti_syscon_reset_control *controls;\n\tunsigned int nr_controls;\n};\n\n#define to_ti_syscon_reset_data(_rcdev)\t\\\n\tcontainer_of(_rcdev, struct ti_syscon_reset_data, rcdev)\n\n \nstatic int ti_syscon_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id)\n{\n\tstruct ti_syscon_reset_data *data = to_ti_syscon_reset_data(rcdev);\n\tstruct ti_syscon_reset_control *control;\n\tunsigned int mask, value;\n\n\tif (id >= data->nr_controls)\n\t\treturn -EINVAL;\n\n\tcontrol = &data->controls[id];\n\n\tif (control->flags & ASSERT_NONE)\n\t\treturn -ENOTSUPP;  \n\n\tmask = BIT(control->assert_bit);\n\tvalue = (control->flags & ASSERT_SET) ? mask : 0x0;\n\n\treturn regmap_write_bits(data->regmap, control->assert_offset, mask, value);\n}\n\n \nstatic int ti_syscon_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long id)\n{\n\tstruct ti_syscon_reset_data *data = to_ti_syscon_reset_data(rcdev);\n\tstruct ti_syscon_reset_control *control;\n\tunsigned int mask, value;\n\n\tif (id >= data->nr_controls)\n\t\treturn -EINVAL;\n\n\tcontrol = &data->controls[id];\n\n\tif (control->flags & DEASSERT_NONE)\n\t\treturn -ENOTSUPP;  \n\n\tmask = BIT(control->deassert_bit);\n\tvalue = (control->flags & DEASSERT_SET) ? mask : 0x0;\n\n\treturn regmap_write_bits(data->regmap, control->deassert_offset, mask, value);\n}\n\n \nstatic int ti_syscon_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id)\n{\n\tstruct ti_syscon_reset_data *data = to_ti_syscon_reset_data(rcdev);\n\tstruct ti_syscon_reset_control *control;\n\tunsigned int reset_state;\n\tint ret;\n\n\tif (id >= data->nr_controls)\n\t\treturn -EINVAL;\n\n\tcontrol = &data->controls[id];\n\n\tif (control->flags & STATUS_NONE)\n\t\treturn -ENOTSUPP;  \n\n\tret = regmap_read(data->regmap, control->status_offset, &reset_state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !(reset_state & BIT(control->status_bit)) ==\n\t\t!(control->flags & STATUS_SET);\n}\n\nstatic const struct reset_control_ops ti_syscon_reset_ops = {\n\t.assert\t\t= ti_syscon_reset_assert,\n\t.deassert\t= ti_syscon_reset_deassert,\n\t.status\t\t= ti_syscon_reset_status,\n};\n\nstatic int ti_syscon_reset_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct ti_syscon_reset_data *data;\n\tstruct regmap *regmap;\n\tconst __be32 *list;\n\tstruct ti_syscon_reset_control *controls;\n\tint size, nr_controls, i;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tregmap = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tlist = of_get_property(np, \"ti,reset-bits\", &size);\n\tif (!list || (size / sizeof(*list)) % 7 != 0) {\n\t\tdev_err(dev, \"invalid DT reset description\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnr_controls = (size / sizeof(*list)) / 7;\n\tcontrols = devm_kcalloc(dev, nr_controls, sizeof(*controls),\n\t\t\t\tGFP_KERNEL);\n\tif (!controls)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nr_controls; i++) {\n\t\tcontrols[i].assert_offset = be32_to_cpup(list++);\n\t\tcontrols[i].assert_bit = be32_to_cpup(list++);\n\t\tcontrols[i].deassert_offset = be32_to_cpup(list++);\n\t\tcontrols[i].deassert_bit = be32_to_cpup(list++);\n\t\tcontrols[i].status_offset = be32_to_cpup(list++);\n\t\tcontrols[i].status_bit = be32_to_cpup(list++);\n\t\tcontrols[i].flags = be32_to_cpup(list++);\n\t}\n\n\tdata->rcdev.ops = &ti_syscon_reset_ops;\n\tdata->rcdev.owner = THIS_MODULE;\n\tdata->rcdev.of_node = np;\n\tdata->rcdev.nr_resets = nr_controls;\n\tdata->regmap = regmap;\n\tdata->controls = controls;\n\tdata->nr_controls = nr_controls;\n\n\treturn devm_reset_controller_register(dev, &data->rcdev);\n}\n\nstatic const struct of_device_id ti_syscon_reset_of_match[] = {\n\t{ .compatible = \"ti,syscon-reset\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ti_syscon_reset_of_match);\n\nstatic struct platform_driver ti_syscon_reset_driver = {\n\t.probe = ti_syscon_reset_probe,\n\t.driver = {\n\t\t.name = \"ti-syscon-reset\",\n\t\t.of_match_table = ti_syscon_reset_of_match,\n\t},\n};\nmodule_platform_driver(ti_syscon_reset_driver);\n\nMODULE_AUTHOR(\"Andrew F. Davis <afd@ti.com>\");\nMODULE_AUTHOR(\"Suman Anna <s-anna@ti.com>\");\nMODULE_DESCRIPTION(\"TI SYSCON Regmap Reset Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}