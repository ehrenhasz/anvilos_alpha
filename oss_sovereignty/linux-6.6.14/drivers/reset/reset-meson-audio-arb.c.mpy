{
  "module_name": "reset-meson-audio-arb.c",
  "hash_id": "e431305c5a7a53dabfbe1591cd42ab3eb9f2a2ccbed4955a0d93dd9156a555b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-meson-audio-arb.c",
  "human_readable_source": "\n\n\n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/spinlock.h>\n\n#include <dt-bindings/reset/amlogic,meson-axg-audio-arb.h>\n\nstruct meson_audio_arb_data {\n\tstruct reset_controller_dev rstc;\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tconst unsigned int *reset_bits;\n\tspinlock_t lock;\n};\n\nstruct meson_audio_arb_match_data {\n\tconst unsigned int *reset_bits;\n\tunsigned int reset_num;\n};\n\n#define ARB_GENERAL_BIT\t31\n\nstatic const unsigned int axg_audio_arb_reset_bits[] = {\n\t[AXG_ARB_TODDR_A]\t= 0,\n\t[AXG_ARB_TODDR_B]\t= 1,\n\t[AXG_ARB_TODDR_C]\t= 2,\n\t[AXG_ARB_FRDDR_A]\t= 4,\n\t[AXG_ARB_FRDDR_B]\t= 5,\n\t[AXG_ARB_FRDDR_C]\t= 6,\n};\n\nstatic const struct meson_audio_arb_match_data axg_audio_arb_match = {\n\t.reset_bits = axg_audio_arb_reset_bits,\n\t.reset_num = ARRAY_SIZE(axg_audio_arb_reset_bits),\n};\n\nstatic const unsigned int sm1_audio_arb_reset_bits[] = {\n\t[AXG_ARB_TODDR_A]\t= 0,\n\t[AXG_ARB_TODDR_B]\t= 1,\n\t[AXG_ARB_TODDR_C]\t= 2,\n\t[AXG_ARB_FRDDR_A]\t= 4,\n\t[AXG_ARB_FRDDR_B]\t= 5,\n\t[AXG_ARB_FRDDR_C]\t= 6,\n\t[AXG_ARB_TODDR_D]\t= 3,\n\t[AXG_ARB_FRDDR_D]\t= 7,\n};\n\nstatic const struct meson_audio_arb_match_data sm1_audio_arb_match = {\n\t.reset_bits = sm1_audio_arb_reset_bits,\n\t.reset_num = ARRAY_SIZE(sm1_audio_arb_reset_bits),\n};\n\nstatic int meson_audio_arb_update(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id, bool assert)\n{\n\tu32 val;\n\tstruct meson_audio_arb_data *arb =\n\t\tcontainer_of(rcdev, struct meson_audio_arb_data, rstc);\n\n\tspin_lock(&arb->lock);\n\tval = readl(arb->regs);\n\n\tif (assert)\n\t\tval &= ~BIT(arb->reset_bits[id]);\n\telse\n\t\tval |= BIT(arb->reset_bits[id]);\n\n\twritel(val, arb->regs);\n\tspin_unlock(&arb->lock);\n\n\treturn 0;\n}\n\nstatic int meson_audio_arb_status(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id)\n{\n\tu32 val;\n\tstruct meson_audio_arb_data *arb =\n\t\tcontainer_of(rcdev, struct meson_audio_arb_data, rstc);\n\n\tval = readl(arb->regs);\n\n\treturn !(val & BIT(arb->reset_bits[id]));\n}\n\nstatic int meson_audio_arb_assert(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id)\n{\n\treturn meson_audio_arb_update(rcdev, id, true);\n}\n\nstatic int meson_audio_arb_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long id)\n{\n\treturn meson_audio_arb_update(rcdev, id, false);\n}\n\nstatic const struct reset_control_ops meson_audio_arb_rstc_ops = {\n\t.assert = meson_audio_arb_assert,\n\t.deassert = meson_audio_arb_deassert,\n\t.status = meson_audio_arb_status,\n};\n\nstatic const struct of_device_id meson_audio_arb_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,meson-axg-audio-arb\",\n\t\t.data = &axg_audio_arb_match,\n\t}, {\n\t\t.compatible = \"amlogic,meson-sm1-audio-arb\",\n\t\t.data = &sm1_audio_arb_match,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, meson_audio_arb_of_match);\n\nstatic int meson_audio_arb_remove(struct platform_device *pdev)\n{\n\tstruct meson_audio_arb_data *arb = platform_get_drvdata(pdev);\n\n\t \n\tspin_lock(&arb->lock);\n\twritel(0, arb->regs);\n\tspin_unlock(&arb->lock);\n\n\tclk_disable_unprepare(arb->clk);\n\n\treturn 0;\n}\n\nstatic int meson_audio_arb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct meson_audio_arb_match_data *data;\n\tstruct meson_audio_arb_data *arb;\n\tstruct resource *res;\n\tint ret;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tarb = devm_kzalloc(dev, sizeof(*arb), GFP_KERNEL);\n\tif (!arb)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, arb);\n\n\tarb->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(arb->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(arb->clk), \"failed to get clock\\n\");\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tarb->regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(arb->regs))\n\t\treturn PTR_ERR(arb->regs);\n\n\tspin_lock_init(&arb->lock);\n\tarb->reset_bits = data->reset_bits;\n\tarb->rstc.nr_resets = data->reset_num;\n\tarb->rstc.ops = &meson_audio_arb_rstc_ops;\n\tarb->rstc.of_node = dev->of_node;\n\tarb->rstc.owner = THIS_MODULE;\n\n\t \n\tret = clk_prepare_enable(arb->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable arb clock\\n\");\n\t\treturn ret;\n\t}\n\twritel(BIT(ARB_GENERAL_BIT), arb->regs);\n\n\t \n\tret = devm_reset_controller_register(dev, &arb->rstc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register arb reset controller\\n\");\n\t\tmeson_audio_arb_remove(pdev);\n\t}\n\n\treturn ret;\n}\n\nstatic struct platform_driver meson_audio_arb_pdrv = {\n\t.probe = meson_audio_arb_probe,\n\t.remove = meson_audio_arb_remove,\n\t.driver = {\n\t\t.name = \"meson-audio-arb-reset\",\n\t\t.of_match_table = meson_audio_arb_of_match,\n\t},\n};\nmodule_platform_driver(meson_audio_arb_pdrv);\n\nMODULE_DESCRIPTION(\"Amlogic A113 Audio Memory Arbiter\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}