{
  "module_name": "reset-hsdk.c",
  "hash_id": "0c8c27bf9cd160860f7b283934817c623f3c94e4988e5cc2a6ce30d434c2e4f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-hsdk.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define to_hsdk_rst(p)\tcontainer_of((p), struct hsdk_rst, rcdev)\n\nstruct hsdk_rst {\n\tvoid __iomem\t\t\t*regs_ctl;\n\tvoid __iomem\t\t\t*regs_rst;\n\tspinlock_t\t\t\tlock;\n\tstruct reset_controller_dev\trcdev;\n};\n\nstatic const u32 rst_map[] = {\n\tBIT(16),  \n\tBIT(17),  \n\tBIT(18),  \n\tBIT(19),  \n\tBIT(20),  \n\tBIT(21),  \n\tBIT(22),  \n\tBIT(25),  \n\tBIT(31),  \n};\n\n#define HSDK_MAX_RESETS\t\t\tARRAY_SIZE(rst_map)\n\n#define CGU_SYS_RST_CTRL\t\t0x0\n#define CGU_IP_SW_RESET\t\t\t0x0\n#define CGU_IP_SW_RESET_DELAY_SHIFT\t16\n#define CGU_IP_SW_RESET_DELAY_MASK\tGENMASK(31, CGU_IP_SW_RESET_DELAY_SHIFT)\n#define CGU_IP_SW_RESET_DELAY\t\t0\n#define CGU_IP_SW_RESET_RESET\t\tBIT(0)\n#define SW_RESET_TIMEOUT\t\t10000\n\nstatic void hsdk_reset_config(struct hsdk_rst *rst, unsigned long id)\n{\n\twritel(rst_map[id], rst->regs_ctl + CGU_SYS_RST_CTRL);\n}\n\nstatic int hsdk_reset_do(struct hsdk_rst *rst)\n{\n\tu32 reg;\n\n\treg = readl(rst->regs_rst + CGU_IP_SW_RESET);\n\treg &= ~CGU_IP_SW_RESET_DELAY_MASK;\n\treg |= CGU_IP_SW_RESET_DELAY << CGU_IP_SW_RESET_DELAY_SHIFT;\n\treg |= CGU_IP_SW_RESET_RESET;\n\twritel(reg, rst->regs_rst + CGU_IP_SW_RESET);\n\n\t \n\treturn readl_poll_timeout_atomic(rst->regs_rst + CGU_IP_SW_RESET, reg,\n\t\t!(reg & CGU_IP_SW_RESET_RESET), 5, SW_RESET_TIMEOUT);\n}\n\nstatic int hsdk_reset_reset(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct hsdk_rst *rst = to_hsdk_rst(rcdev);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rst->lock, flags);\n\thsdk_reset_config(rst, id);\n\tret = hsdk_reset_do(rst);\n\tspin_unlock_irqrestore(&rst->lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct reset_control_ops hsdk_reset_ops = {\n\t.reset\t= hsdk_reset_reset,\n\t.deassert = hsdk_reset_reset,\n};\n\nstatic int hsdk_reset_probe(struct platform_device *pdev)\n{\n\tstruct hsdk_rst *rst;\n\n\trst = devm_kzalloc(&pdev->dev, sizeof(*rst), GFP_KERNEL);\n\tif (!rst)\n\t\treturn -ENOMEM;\n\n\trst->regs_ctl = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rst->regs_ctl))\n\t\treturn PTR_ERR(rst->regs_ctl);\n\n\trst->regs_rst = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(rst->regs_rst))\n\t\treturn PTR_ERR(rst->regs_rst);\n\n\tspin_lock_init(&rst->lock);\n\n\trst->rcdev.owner = THIS_MODULE;\n\trst->rcdev.ops = &hsdk_reset_ops;\n\trst->rcdev.of_node = pdev->dev.of_node;\n\trst->rcdev.nr_resets = HSDK_MAX_RESETS;\n\trst->rcdev.of_reset_n_cells = 1;\n\n\treturn reset_controller_register(&rst->rcdev);\n}\n\nstatic const struct of_device_id hsdk_reset_dt_match[] = {\n\t{ .compatible = \"snps,hsdk-reset\" },\n\t{ },\n};\n\nstatic struct platform_driver hsdk_reset_driver = {\n\t.probe\t= hsdk_reset_probe,\n\t.driver\t= {\n\t\t.name = \"hsdk-reset\",\n\t\t.of_match_table = hsdk_reset_dt_match,\n\t},\n};\nbuiltin_platform_driver(hsdk_reset_driver);\n\nMODULE_AUTHOR(\"Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>\");\nMODULE_DESCRIPTION(\"Synopsys HSDK SDP reset driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}