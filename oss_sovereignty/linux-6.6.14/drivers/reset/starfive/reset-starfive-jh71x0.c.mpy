{
  "module_name": "reset-starfive-jh71x0.c",
  "hash_id": "298aa8e0a99b3608445841fa0d1ad5e6a00e0e182ce002818cbd51b2b00c7e52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/starfive/reset-starfive-jh71x0.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/reset-controller.h>\n#include <linux/spinlock.h>\n\n#include \"reset-starfive-jh71x0.h\"\n\nstruct jh71x0_reset {\n\tstruct reset_controller_dev rcdev;\n\t \n\tspinlock_t lock;\n\tvoid __iomem *assert;\n\tvoid __iomem *status;\n\tconst u32 *asserted;\n};\n\nstatic inline struct jh71x0_reset *\njh71x0_reset_from(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct jh71x0_reset, rcdev);\n}\n\nstatic int jh71x0_reset_update(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id, bool assert)\n{\n\tstruct jh71x0_reset *data = jh71x0_reset_from(rcdev);\n\tunsigned long offset = id / 32;\n\tu32 mask = BIT(id % 32);\n\tvoid __iomem *reg_assert = data->assert + offset * sizeof(u32);\n\tvoid __iomem *reg_status = data->status + offset * sizeof(u32);\n\tu32 done = data->asserted ? data->asserted[offset] & mask : 0;\n\tu32 value;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!assert)\n\t\tdone ^= mask;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\n\tvalue = readl(reg_assert);\n\tif (assert)\n\t\tvalue |= mask;\n\telse\n\t\tvalue &= ~mask;\n\twritel(value, reg_assert);\n\n\t \n\tret = readl_poll_timeout_atomic(reg_status, value, (value & mask) == done, 0, 1000);\n\n\tspin_unlock_irqrestore(&data->lock, flags);\n\treturn ret;\n}\n\nstatic int jh71x0_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\treturn jh71x0_reset_update(rcdev, id, true);\n}\n\nstatic int jh71x0_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\treturn jh71x0_reset_update(rcdev, id, false);\n}\n\nstatic int jh71x0_reset_reset(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tint ret;\n\n\tret = jh71x0_reset_assert(rcdev, id);\n\tif (ret)\n\t\treturn ret;\n\n\treturn jh71x0_reset_deassert(rcdev, id);\n}\n\nstatic int jh71x0_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct jh71x0_reset *data = jh71x0_reset_from(rcdev);\n\tunsigned long offset = id / 32;\n\tu32 mask = BIT(id % 32);\n\tvoid __iomem *reg_status = data->status + offset * sizeof(u32);\n\tu32 value = readl(reg_status);\n\n\treturn !((value ^ data->asserted[offset]) & mask);\n}\n\nstatic const struct reset_control_ops jh71x0_reset_ops = {\n\t.assert\t\t= jh71x0_reset_assert,\n\t.deassert\t= jh71x0_reset_deassert,\n\t.reset\t\t= jh71x0_reset_reset,\n\t.status\t\t= jh71x0_reset_status,\n};\n\nint reset_starfive_jh71x0_register(struct device *dev, struct device_node *of_node,\n\t\t\t\t   void __iomem *assert, void __iomem *status,\n\t\t\t\t   const u32 *asserted, unsigned int nr_resets,\n\t\t\t\t   struct module *owner)\n{\n\tstruct jh71x0_reset *data;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->rcdev.ops = &jh71x0_reset_ops;\n\tdata->rcdev.owner = owner;\n\tdata->rcdev.nr_resets = nr_resets;\n\tdata->rcdev.dev = dev;\n\tdata->rcdev.of_node = of_node;\n\n\tspin_lock_init(&data->lock);\n\tdata->assert = assert;\n\tdata->status = status;\n\tdata->asserted = asserted;\n\n\treturn devm_reset_controller_register(dev, &data->rcdev);\n}\nEXPORT_SYMBOL_GPL(reset_starfive_jh71x0_register);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}