{
  "module_name": "reset-zynqmp.c",
  "hash_id": "3cc9c72f2398c8bad6963dca209b9f893e3878210308d2732847aadb25711337",
  "original_prompt": "Ingested from linux-6.6.14/drivers/reset/reset-zynqmp.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/firmware/xlnx-zynqmp.h>\n\n#define ZYNQMP_NR_RESETS (ZYNQMP_PM_RESET_END - ZYNQMP_PM_RESET_START)\n#define ZYNQMP_RESET_ID ZYNQMP_PM_RESET_START\n#define VERSAL_NR_RESETS\t95\n#define VERSAL_NET_NR_RESETS\t176\n\nstruct zynqmp_reset_soc_data {\n\tu32 reset_id;\n\tu32 num_resets;\n};\n\nstruct zynqmp_reset_data {\n\tstruct reset_controller_dev rcdev;\n\tconst struct zynqmp_reset_soc_data *data;\n};\n\nstatic inline struct zynqmp_reset_data *\nto_zynqmp_reset_data(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct zynqmp_reset_data, rcdev);\n}\n\nstatic int zynqmp_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct zynqmp_reset_data *priv = to_zynqmp_reset_data(rcdev);\n\n\treturn zynqmp_pm_reset_assert(priv->data->reset_id + id,\n\t\t\t\t      PM_RESET_ACTION_ASSERT);\n}\n\nstatic int zynqmp_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\tstruct zynqmp_reset_data *priv = to_zynqmp_reset_data(rcdev);\n\n\treturn zynqmp_pm_reset_assert(priv->data->reset_id + id,\n\t\t\t\t      PM_RESET_ACTION_RELEASE);\n}\n\nstatic int zynqmp_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct zynqmp_reset_data *priv = to_zynqmp_reset_data(rcdev);\n\tint err;\n\tu32 val;\n\n\terr = zynqmp_pm_reset_get_status(priv->data->reset_id + id, &val);\n\tif (err)\n\t\treturn err;\n\n\treturn val;\n}\n\nstatic int zynqmp_reset_reset(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct zynqmp_reset_data *priv = to_zynqmp_reset_data(rcdev);\n\n\treturn zynqmp_pm_reset_assert(priv->data->reset_id + id,\n\t\t\t\t      PM_RESET_ACTION_PULSE);\n}\n\nstatic int zynqmp_reset_of_xlate(struct reset_controller_dev *rcdev,\n\t\t\t\t const struct of_phandle_args *reset_spec)\n{\n\treturn reset_spec->args[0];\n}\n\nstatic const struct zynqmp_reset_soc_data zynqmp_reset_data = {\n\t.reset_id = ZYNQMP_RESET_ID,\n\t.num_resets = ZYNQMP_NR_RESETS,\n};\n\nstatic const struct zynqmp_reset_soc_data versal_reset_data = {\n\t.reset_id = 0,\n\t.num_resets = VERSAL_NR_RESETS,\n};\n\nstatic const struct zynqmp_reset_soc_data versal_net_reset_data = {\n\t.reset_id = 0,\n\t.num_resets = VERSAL_NET_NR_RESETS,\n};\n\nstatic const struct reset_control_ops zynqmp_reset_ops = {\n\t.reset = zynqmp_reset_reset,\n\t.assert = zynqmp_reset_assert,\n\t.deassert = zynqmp_reset_deassert,\n\t.status = zynqmp_reset_status,\n};\n\nstatic int zynqmp_reset_probe(struct platform_device *pdev)\n{\n\tstruct zynqmp_reset_data *priv;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->data = of_device_get_match_data(&pdev->dev);\n\tif (!priv->data)\n\t\treturn -EINVAL;\n\n\tpriv->rcdev.ops = &zynqmp_reset_ops;\n\tpriv->rcdev.owner = THIS_MODULE;\n\tpriv->rcdev.of_node = pdev->dev.of_node;\n\tpriv->rcdev.nr_resets = priv->data->num_resets;\n\tpriv->rcdev.of_reset_n_cells = 1;\n\tpriv->rcdev.of_xlate = zynqmp_reset_of_xlate;\n\n\treturn devm_reset_controller_register(&pdev->dev, &priv->rcdev);\n}\n\nstatic const struct of_device_id zynqmp_reset_dt_ids[] = {\n\t{ .compatible = \"xlnx,zynqmp-reset\", .data = &zynqmp_reset_data, },\n\t{ .compatible = \"xlnx,versal-reset\", .data = &versal_reset_data, },\n\t{ .compatible = \"xlnx,versal-net-reset\", .data = &versal_net_reset_data, },\n\t{   },\n};\n\nstatic struct platform_driver zynqmp_reset_driver = {\n\t.probe\t= zynqmp_reset_probe,\n\t.driver = {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= zynqmp_reset_dt_ids,\n\t},\n};\n\nstatic int __init zynqmp_reset_init(void)\n{\n\treturn platform_driver_register(&zynqmp_reset_driver);\n}\n\narch_initcall(zynqmp_reset_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}