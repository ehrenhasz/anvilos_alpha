{
  "module_name": "tpci200.c",
  "hash_id": "dca32bda38277a0073d31ab5b4a8657ce2f4b526ad22cee6e291cc311cfa55c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ipack/carriers/tpci200.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"tpci200.h\"\n\nstatic const u16 tpci200_status_timeout[] = {\n\tTPCI200_A_TIMEOUT,\n\tTPCI200_B_TIMEOUT,\n\tTPCI200_C_TIMEOUT,\n\tTPCI200_D_TIMEOUT,\n};\n\nstatic const u16 tpci200_status_error[] = {\n\tTPCI200_A_ERROR,\n\tTPCI200_B_ERROR,\n\tTPCI200_C_ERROR,\n\tTPCI200_D_ERROR,\n};\n\nstatic const size_t tpci200_space_size[IPACK_SPACE_COUNT] = {\n\t[IPACK_IO_SPACE]    = TPCI200_IO_SPACE_SIZE,\n\t[IPACK_ID_SPACE]    = TPCI200_ID_SPACE_SIZE,\n\t[IPACK_INT_SPACE]   = TPCI200_INT_SPACE_SIZE,\n\t[IPACK_MEM8_SPACE]  = TPCI200_MEM8_SPACE_SIZE,\n\t[IPACK_MEM16_SPACE] = TPCI200_MEM16_SPACE_SIZE,\n};\n\nstatic const size_t tpci200_space_interval[IPACK_SPACE_COUNT] = {\n\t[IPACK_IO_SPACE]    = TPCI200_IO_SPACE_INTERVAL,\n\t[IPACK_ID_SPACE]    = TPCI200_ID_SPACE_INTERVAL,\n\t[IPACK_INT_SPACE]   = TPCI200_INT_SPACE_INTERVAL,\n\t[IPACK_MEM8_SPACE]  = TPCI200_MEM8_SPACE_INTERVAL,\n\t[IPACK_MEM16_SPACE] = TPCI200_MEM16_SPACE_INTERVAL,\n};\n\nstatic struct tpci200_board *check_slot(struct ipack_device *dev)\n{\n\tstruct tpci200_board *tpci200;\n\n\tif (dev == NULL)\n\t\treturn NULL;\n\n\n\ttpci200 = dev_get_drvdata(dev->bus->parent);\n\n\tif (tpci200 == NULL) {\n\t\tdev_info(&dev->dev, \"carrier board not found\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (dev->slot >= TPCI200_NB_SLOT) {\n\t\tdev_info(&dev->dev,\n\t\t\t \"Slot [%d:%d] doesn't exist! Last tpci200 slot is %d.\\n\",\n\t\t\t dev->bus->bus_nr, dev->slot, TPCI200_NB_SLOT-1);\n\t\treturn NULL;\n\t}\n\n\treturn tpci200;\n}\n\nstatic void tpci200_clear_mask(struct tpci200_board *tpci200,\n\t\t\t       __le16 __iomem *addr, u16 mask)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&tpci200->regs_lock, flags);\n\tiowrite16(ioread16(addr) & (~mask), addr);\n\tspin_unlock_irqrestore(&tpci200->regs_lock, flags);\n}\n\nstatic void tpci200_set_mask(struct tpci200_board *tpci200,\n\t\t\t     __le16 __iomem *addr, u16 mask)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&tpci200->regs_lock, flags);\n\tiowrite16(ioread16(addr) | mask, addr);\n\tspin_unlock_irqrestore(&tpci200->regs_lock, flags);\n}\n\nstatic void tpci200_unregister(struct tpci200_board *tpci200)\n{\n\tfree_irq(tpci200->info->pdev->irq, (void *) tpci200);\n\n\tpci_iounmap(tpci200->info->pdev, tpci200->info->interface_regs);\n\n\tpci_release_region(tpci200->info->pdev, TPCI200_IP_INTERFACE_BAR);\n\tpci_release_region(tpci200->info->pdev, TPCI200_IO_ID_INT_SPACES_BAR);\n\tpci_release_region(tpci200->info->pdev, TPCI200_MEM16_SPACE_BAR);\n\tpci_release_region(tpci200->info->pdev, TPCI200_MEM8_SPACE_BAR);\n\n\tpci_disable_device(tpci200->info->pdev);\n}\n\nstatic void tpci200_enable_irq(struct tpci200_board *tpci200,\n\t\t\t       int islot)\n{\n\ttpci200_set_mask(tpci200,\n\t\t\t&tpci200->info->interface_regs->control[islot],\n\t\t\tTPCI200_INT0_EN | TPCI200_INT1_EN);\n}\n\nstatic void tpci200_disable_irq(struct tpci200_board *tpci200,\n\t\t\t\tint islot)\n{\n\ttpci200_clear_mask(tpci200,\n\t\t\t&tpci200->info->interface_regs->control[islot],\n\t\t\tTPCI200_INT0_EN | TPCI200_INT1_EN);\n}\n\nstatic irqreturn_t tpci200_slot_irq(struct slot_irq *slot_irq)\n{\n\tirqreturn_t ret;\n\n\tif (!slot_irq)\n\t\treturn -ENODEV;\n\tret = slot_irq->handler(slot_irq->arg);\n\n\treturn ret;\n}\n\nstatic irqreturn_t tpci200_interrupt(int irq, void *dev_id)\n{\n\tstruct tpci200_board *tpci200 = (struct tpci200_board *) dev_id;\n\tstruct slot_irq *slot_irq;\n\tirqreturn_t ret;\n\tu16 status_reg;\n\tint i;\n\n\t \n\tstatus_reg = ioread16(&tpci200->info->interface_regs->status);\n\n\t \n\tif (!(status_reg & TPCI200_SLOT_INT_MASK))\n\t\treturn IRQ_NONE;\n\n\t \n\trcu_read_lock();\n\tfor (i = 0; i < TPCI200_NB_SLOT; i++) {\n\t\tif (!(status_reg & ((TPCI200_A_INT0 | TPCI200_A_INT1) << (2 * i))))\n\t\t\tcontinue;\n\t\tslot_irq = rcu_dereference(tpci200->slots[i].irq);\n\t\tret = tpci200_slot_irq(slot_irq);\n\t\tif (ret == -ENODEV) {\n\t\t\tdev_info(&tpci200->info->pdev->dev,\n\t\t\t\t \"No registered ISR for slot [%d:%d]!. IRQ will be disabled.\\n\",\n\t\t\t\t tpci200->number, i);\n\t\t\ttpci200_disable_irq(tpci200, i);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tpci200_free_irq(struct ipack_device *dev)\n{\n\tstruct slot_irq *slot_irq;\n\tstruct tpci200_board *tpci200;\n\n\ttpci200 = check_slot(dev);\n\tif (tpci200 == NULL)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&tpci200->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (tpci200->slots[dev->slot].irq == NULL) {\n\t\tmutex_unlock(&tpci200->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\ttpci200_disable_irq(tpci200, dev->slot);\n\tslot_irq = tpci200->slots[dev->slot].irq;\n\t \n\tRCU_INIT_POINTER(tpci200->slots[dev->slot].irq, NULL);\n\tsynchronize_rcu();\n\tkfree(slot_irq);\n\tmutex_unlock(&tpci200->mutex);\n\treturn 0;\n}\n\nstatic int tpci200_request_irq(struct ipack_device *dev,\n\t\t\t       irqreturn_t (*handler)(void *), void *arg)\n{\n\tint res = 0;\n\tstruct slot_irq *slot_irq;\n\tstruct tpci200_board *tpci200;\n\n\ttpci200 = check_slot(dev);\n\tif (tpci200 == NULL)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&tpci200->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (tpci200->slots[dev->slot].irq != NULL) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Slot [%d:%d] IRQ already registered !\\n\",\n\t\t\tdev->bus->bus_nr,\n\t\t\tdev->slot);\n\t\tres = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tslot_irq = kzalloc(sizeof(struct slot_irq), GFP_KERNEL);\n\tif (slot_irq == NULL) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Slot [%d:%d] unable to allocate memory for IRQ !\\n\",\n\t\t\tdev->bus->bus_nr, dev->slot);\n\t\tres = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tslot_irq->handler = handler;\n\tslot_irq->arg = arg;\n\tslot_irq->holder = dev;\n\n\trcu_assign_pointer(tpci200->slots[dev->slot].irq, slot_irq);\n\ttpci200_enable_irq(tpci200, dev->slot);\n\nout_unlock:\n\tmutex_unlock(&tpci200->mutex);\n\treturn res;\n}\n\nstatic int tpci200_register(struct tpci200_board *tpci200)\n{\n\tint i;\n\tint res;\n\tphys_addr_t ioidint_base;\n\tunsigned short slot_ctrl;\n\n\tif (pci_enable_device(tpci200->info->pdev) < 0)\n\t\treturn -ENODEV;\n\n\t \n\tres = pci_request_region(tpci200->info->pdev, TPCI200_IP_INTERFACE_BAR,\n\t\t\t\t \"Carrier IP interface registers\");\n\tif (res) {\n\t\tdev_err(&tpci200->info->pdev->dev,\n\t\t\t\"(bn 0x%X, sn 0x%X) failed to allocate PCI resource for BAR 2 !\",\n\t\t\ttpci200->info->pdev->bus->number,\n\t\t\ttpci200->info->pdev->devfn);\n\t\tgoto err_disable_device;\n\t}\n\n\t \n\tres = pci_request_region(tpci200->info->pdev,\n\t\t\t\t TPCI200_IO_ID_INT_SPACES_BAR,\n\t\t\t\t \"Carrier IO ID INT space\");\n\tif (res) {\n\t\tdev_err(&tpci200->info->pdev->dev,\n\t\t\t\"(bn 0x%X, sn 0x%X) failed to allocate PCI resource for BAR 3 !\",\n\t\t\ttpci200->info->pdev->bus->number,\n\t\t\ttpci200->info->pdev->devfn);\n\t\tgoto err_ip_interface_bar;\n\t}\n\n\t \n\tres = pci_request_region(tpci200->info->pdev, TPCI200_MEM8_SPACE_BAR,\n\t\t\t\t \"Carrier MEM8 space\");\n\tif (res) {\n\t\tdev_err(&tpci200->info->pdev->dev,\n\t\t\t\"(bn 0x%X, sn 0x%X) failed to allocate PCI resource for BAR 5!\",\n\t\t\ttpci200->info->pdev->bus->number,\n\t\t\ttpci200->info->pdev->devfn);\n\t\tgoto err_io_id_int_spaces_bar;\n\t}\n\n\t \n\tres = pci_request_region(tpci200->info->pdev, TPCI200_MEM16_SPACE_BAR,\n\t\t\t\t \"Carrier MEM16 space\");\n\tif (res) {\n\t\tdev_err(&tpci200->info->pdev->dev,\n\t\t\t\"(bn 0x%X, sn 0x%X) failed to allocate PCI resource for BAR 4!\",\n\t\t\ttpci200->info->pdev->bus->number,\n\t\t\ttpci200->info->pdev->devfn);\n\t\tgoto err_mem8_space_bar;\n\t}\n\n\t \n\ttpci200->info->interface_regs =\n\t\tioremap(pci_resource_start(tpci200->info->pdev,\n\t\t\t\t\t   TPCI200_IP_INTERFACE_BAR),\n\t\t\tTPCI200_IFACE_SIZE);\n\tif (!tpci200->info->interface_regs) {\n\t\tdev_err(&tpci200->info->pdev->dev,\n\t\t\t\"(bn 0x%X, sn 0x%X) failed to map driver user space!\",\n\t\t\ttpci200->info->pdev->bus->number,\n\t\t\ttpci200->info->pdev->devfn);\n\t\tres = -ENOMEM;\n\t\tgoto err_mem16_space_bar;\n\t}\n\n\t \n\tspin_lock_init(&tpci200->regs_lock);\n\n\tioidint_base = pci_resource_start(tpci200->info->pdev,\n\t\t\t\t\t  TPCI200_IO_ID_INT_SPACES_BAR);\n\ttpci200->mod_mem[IPACK_IO_SPACE] = ioidint_base + TPCI200_IO_SPACE_OFF;\n\ttpci200->mod_mem[IPACK_ID_SPACE] = ioidint_base + TPCI200_ID_SPACE_OFF;\n\ttpci200->mod_mem[IPACK_INT_SPACE] =\n\t\tioidint_base + TPCI200_INT_SPACE_OFF;\n\ttpci200->mod_mem[IPACK_MEM8_SPACE] =\n\t\tpci_resource_start(tpci200->info->pdev,\n\t\t\t\t   TPCI200_MEM8_SPACE_BAR);\n\ttpci200->mod_mem[IPACK_MEM16_SPACE] =\n\t\tpci_resource_start(tpci200->info->pdev,\n\t\t\t\t   TPCI200_MEM16_SPACE_BAR);\n\n\t \n\tslot_ctrl = 0;\n\tfor (i = 0; i < TPCI200_NB_SLOT; i++)\n\t\twritew(slot_ctrl, &tpci200->info->interface_regs->control[i]);\n\n\tres = request_irq(tpci200->info->pdev->irq,\n\t\t\t  tpci200_interrupt, IRQF_SHARED,\n\t\t\t  KBUILD_MODNAME, (void *) tpci200);\n\tif (res) {\n\t\tdev_err(&tpci200->info->pdev->dev,\n\t\t\t\"(bn 0x%X, sn 0x%X) unable to register IRQ !\",\n\t\t\ttpci200->info->pdev->bus->number,\n\t\t\ttpci200->info->pdev->devfn);\n\t\tgoto err_interface_regs;\n\t}\n\n\treturn 0;\n\nerr_interface_regs:\n\tpci_iounmap(tpci200->info->pdev, tpci200->info->interface_regs);\nerr_mem16_space_bar:\n\tpci_release_region(tpci200->info->pdev, TPCI200_MEM16_SPACE_BAR);\nerr_mem8_space_bar:\n\tpci_release_region(tpci200->info->pdev, TPCI200_MEM8_SPACE_BAR);\nerr_io_id_int_spaces_bar:\n\tpci_release_region(tpci200->info->pdev, TPCI200_IO_ID_INT_SPACES_BAR);\nerr_ip_interface_bar:\n\tpci_release_region(tpci200->info->pdev, TPCI200_IP_INTERFACE_BAR);\nerr_disable_device:\n\tpci_disable_device(tpci200->info->pdev);\n\treturn res;\n}\n\nstatic int tpci200_get_clockrate(struct ipack_device *dev)\n{\n\tstruct tpci200_board *tpci200 = check_slot(dev);\n\t__le16 __iomem *addr;\n\n\tif (!tpci200)\n\t\treturn -ENODEV;\n\n\taddr = &tpci200->info->interface_regs->control[dev->slot];\n\treturn (ioread16(addr) & TPCI200_CLK32) ? 32 : 8;\n}\n\nstatic int tpci200_set_clockrate(struct ipack_device *dev, int mherz)\n{\n\tstruct tpci200_board *tpci200 = check_slot(dev);\n\t__le16 __iomem *addr;\n\n\tif (!tpci200)\n\t\treturn -ENODEV;\n\n\taddr = &tpci200->info->interface_regs->control[dev->slot];\n\n\tswitch (mherz) {\n\tcase 8:\n\t\ttpci200_clear_mask(tpci200, addr, TPCI200_CLK32);\n\t\tbreak;\n\tcase 32:\n\t\ttpci200_set_mask(tpci200, addr, TPCI200_CLK32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int tpci200_get_error(struct ipack_device *dev)\n{\n\tstruct tpci200_board *tpci200 = check_slot(dev);\n\t__le16 __iomem *addr;\n\tu16 mask;\n\n\tif (!tpci200)\n\t\treturn -ENODEV;\n\n\taddr = &tpci200->info->interface_regs->status;\n\tmask = tpci200_status_error[dev->slot];\n\treturn (ioread16(addr) & mask) ? 1 : 0;\n}\n\nstatic int tpci200_get_timeout(struct ipack_device *dev)\n{\n\tstruct tpci200_board *tpci200 = check_slot(dev);\n\t__le16 __iomem *addr;\n\tu16 mask;\n\n\tif (!tpci200)\n\t\treturn -ENODEV;\n\n\taddr = &tpci200->info->interface_regs->status;\n\tmask = tpci200_status_timeout[dev->slot];\n\n\treturn (ioread16(addr) & mask) ? 1 : 0;\n}\n\nstatic int tpci200_reset_timeout(struct ipack_device *dev)\n{\n\tstruct tpci200_board *tpci200 = check_slot(dev);\n\t__le16 __iomem *addr;\n\tu16 mask;\n\n\tif (!tpci200)\n\t\treturn -ENODEV;\n\n\taddr = &tpci200->info->interface_regs->status;\n\tmask = tpci200_status_timeout[dev->slot];\n\n\tiowrite16(mask, addr);\n\treturn 0;\n}\n\nstatic void tpci200_uninstall(struct tpci200_board *tpci200)\n{\n\ttpci200_unregister(tpci200);\n\tkfree(tpci200->slots);\n}\n\nstatic const struct ipack_bus_ops tpci200_bus_ops = {\n\t.request_irq = tpci200_request_irq,\n\t.free_irq = tpci200_free_irq,\n\t.get_clockrate = tpci200_get_clockrate,\n\t.set_clockrate = tpci200_set_clockrate,\n\t.get_error     = tpci200_get_error,\n\t.get_timeout   = tpci200_get_timeout,\n\t.reset_timeout = tpci200_reset_timeout,\n};\n\nstatic int tpci200_install(struct tpci200_board *tpci200)\n{\n\tint res;\n\n\ttpci200->slots = kcalloc(TPCI200_NB_SLOT, sizeof(struct tpci200_slot),\n\t\t\t\t GFP_KERNEL);\n\tif (tpci200->slots == NULL)\n\t\treturn -ENOMEM;\n\n\tres = tpci200_register(tpci200);\n\tif (res) {\n\t\tkfree(tpci200->slots);\n\t\ttpci200->slots = NULL;\n\t\treturn res;\n\t}\n\n\tmutex_init(&tpci200->mutex);\n\treturn 0;\n}\n\nstatic void tpci200_release_device(struct ipack_device *dev)\n{\n\tkfree(dev);\n}\n\nstatic int tpci200_create_device(struct tpci200_board *tpci200, int i)\n{\n\tint ret;\n\tenum ipack_space space;\n\tstruct ipack_device *dev =\n\t\tkzalloc(sizeof(struct ipack_device), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->slot = i;\n\tdev->bus = tpci200->info->ipack_bus;\n\tdev->release = tpci200_release_device;\n\n\tfor (space = 0; space < IPACK_SPACE_COUNT; space++) {\n\t\tdev->region[space].start =\n\t\t\ttpci200->mod_mem[space]\n\t\t\t+ tpci200_space_interval[space] * i;\n\t\tdev->region[space].size = tpci200_space_size[space];\n\t}\n\n\tret = ipack_device_init(dev);\n\tif (ret < 0) {\n\t\tipack_put_device(dev);\n\t\treturn ret;\n\t}\n\n\tret = ipack_device_add(dev);\n\tif (ret < 0)\n\t\tipack_put_device(dev);\n\n\treturn ret;\n}\n\nstatic int tpci200_pci_probe(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tint ret, i;\n\tstruct tpci200_board *tpci200;\n\tu32 reg32;\n\n\ttpci200 = kzalloc(sizeof(struct tpci200_board), GFP_KERNEL);\n\tif (!tpci200)\n\t\treturn -ENOMEM;\n\n\ttpci200->info = kzalloc(sizeof(struct tpci200_infos), GFP_KERNEL);\n\tif (!tpci200->info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_tpci200;\n\t}\n\n\tpci_dev_get(pdev);\n\n\t \n\tret = pci_request_region(pdev, TPCI200_CFG_MEM_BAR,\n\t\t\t\t KBUILD_MODNAME \" Configuration Memory\");\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate PCI Configuration Memory\");\n\t\tret = -EBUSY;\n\t\tgoto err_tpci200_info;\n\t}\n\ttpci200->info->cfg_regs = ioremap(\n\t\t\tpci_resource_start(pdev, TPCI200_CFG_MEM_BAR),\n\t\t\tpci_resource_len(pdev, TPCI200_CFG_MEM_BAR));\n\tif (!tpci200->info->cfg_regs) {\n\t\tdev_err(&pdev->dev, \"Failed to map PCI Configuration Memory\");\n\t\tret = -EFAULT;\n\t\tgoto err_request_region;\n\t}\n\n\t \n\treg32 = ioread32(tpci200->info->cfg_regs + LAS1_DESC);\n\treg32 |= 1 << LAS_BIT_BIGENDIAN;\n\tiowrite32(reg32, tpci200->info->cfg_regs + LAS1_DESC);\n\n\treg32 = ioread32(tpci200->info->cfg_regs + LAS2_DESC);\n\treg32 |= 1 << LAS_BIT_BIGENDIAN;\n\tiowrite32(reg32, tpci200->info->cfg_regs + LAS2_DESC);\n\n\t \n\ttpci200->info->pdev = pdev;\n\ttpci200->info->id_table = (struct pci_device_id *)id;\n\n\t \n\tret = tpci200_install(tpci200);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"error during tpci200 install\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_cfg_regs;\n\t}\n\n\t \n\ttpci200->info->ipack_bus = ipack_bus_register(&pdev->dev,\n\t\t\t\t\t\t      TPCI200_NB_SLOT,\n\t\t\t\t\t\t      &tpci200_bus_ops,\n\t\t\t\t\t\t      THIS_MODULE);\n\tif (!tpci200->info->ipack_bus) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"error registering the carrier on ipack driver\\n\");\n\t\tret = -EFAULT;\n\t\tgoto err_tpci200_install;\n\t}\n\n\t \n\ttpci200->number = tpci200->info->ipack_bus->bus_nr;\n\tdev_set_drvdata(&pdev->dev, tpci200);\n\n\tfor (i = 0; i < TPCI200_NB_SLOT; i++)\n\t\ttpci200_create_device(tpci200, i);\n\treturn 0;\n\nerr_tpci200_install:\n\ttpci200_uninstall(tpci200);\nerr_cfg_regs:\n\tpci_iounmap(tpci200->info->pdev, tpci200->info->cfg_regs);\nerr_request_region:\n\tpci_release_region(pdev, TPCI200_CFG_MEM_BAR);\nerr_tpci200_info:\n\tkfree(tpci200->info);\n\tpci_dev_put(pdev);\nerr_tpci200:\n\tkfree(tpci200);\n\treturn ret;\n}\n\nstatic void __tpci200_pci_remove(struct tpci200_board *tpci200)\n{\n\tipack_bus_unregister(tpci200->info->ipack_bus);\n\ttpci200_uninstall(tpci200);\n\n\tpci_iounmap(tpci200->info->pdev, tpci200->info->cfg_regs);\n\n\tpci_release_region(tpci200->info->pdev, TPCI200_CFG_MEM_BAR);\n\n\tpci_dev_put(tpci200->info->pdev);\n\n\tkfree(tpci200->info);\n\tkfree(tpci200);\n}\n\nstatic void tpci200_pci_remove(struct pci_dev *dev)\n{\n\tstruct tpci200_board *tpci200 = pci_get_drvdata(dev);\n\n\t__tpci200_pci_remove(tpci200);\n}\n\nstatic const struct pci_device_id tpci200_idtable[] = {\n\t{ TPCI200_VENDOR_ID, TPCI200_DEVICE_ID, TPCI200_SUBVENDOR_ID,\n\t  TPCI200_SUBDEVICE_ID },\n\t{ 0, },\n};\n\nMODULE_DEVICE_TABLE(pci, tpci200_idtable);\n\nstatic struct pci_driver tpci200_pci_drv = {\n\t.name = \"tpci200\",\n\t.id_table = tpci200_idtable,\n\t.probe = tpci200_pci_probe,\n\t.remove = tpci200_pci_remove,\n};\n\nmodule_pci_driver(tpci200_pci_drv);\n\nMODULE_DESCRIPTION(\"TEWS TPCI-200 device driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}