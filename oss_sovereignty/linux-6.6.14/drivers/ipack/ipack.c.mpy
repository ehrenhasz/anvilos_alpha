{
  "module_name": "ipack.c",
  "hash_id": "1e95b66b0d0f7e2a43435499d62f4e3c02ac94bbe544e543534eb08938e0d842",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ipack/ipack.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/io.h>\n#include <linux/ipack.h>\n\n#define to_ipack_dev(device) container_of(device, struct ipack_device, dev)\n#define to_ipack_driver(drv) container_of(drv, struct ipack_driver, driver)\n\nstatic DEFINE_IDA(ipack_ida);\n\nstatic void ipack_device_release(struct device *dev)\n{\n\tstruct ipack_device *device = to_ipack_dev(dev);\n\tkfree(device->id);\n\tdevice->release(device);\n}\n\nstatic inline const struct ipack_device_id *\nipack_match_one_device(const struct ipack_device_id *id,\n\t\t       const struct ipack_device *device)\n{\n\tif ((id->format == IPACK_ANY_FORMAT ||\n\t\t\t\tid->format == device->id_format) &&\n\t    (id->vendor == IPACK_ANY_ID || id->vendor == device->id_vendor) &&\n\t    (id->device == IPACK_ANY_ID || id->device == device->id_device))\n\t\treturn id;\n\treturn NULL;\n}\n\nstatic const struct ipack_device_id *\nipack_match_id(const struct ipack_device_id *ids, struct ipack_device *idev)\n{\n\tif (ids) {\n\t\twhile (ids->vendor || ids->device) {\n\t\t\tif (ipack_match_one_device(ids, idev))\n\t\t\t\treturn ids;\n\t\t\tids++;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int ipack_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct ipack_device *idev = to_ipack_dev(dev);\n\tstruct ipack_driver *idrv = to_ipack_driver(drv);\n\tconst struct ipack_device_id *found_id;\n\n\tfound_id = ipack_match_id(idrv->id_table, idev);\n\treturn found_id ? 1 : 0;\n}\n\nstatic int ipack_bus_probe(struct device *device)\n{\n\tstruct ipack_device *dev = to_ipack_dev(device);\n\tstruct ipack_driver *drv = to_ipack_driver(device->driver);\n\n\treturn drv->ops->probe(dev);\n}\n\nstatic void ipack_bus_remove(struct device *device)\n{\n\tstruct ipack_device *dev = to_ipack_dev(device);\n\tstruct ipack_driver *drv = to_ipack_driver(device->driver);\n\n\tif (drv->ops->remove)\n\t\tdrv->ops->remove(dev);\n}\n\nstatic int ipack_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct ipack_device *idev;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tidev = to_ipack_dev(dev);\n\n\tif (add_uevent_var(env,\n\t\t\t   \"MODALIAS=ipack:f%02Xv%08Xd%08X\", idev->id_format,\n\t\t\t   idev->id_vendor, idev->id_device))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n#define ipack_device_attr(field, format_string)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nfield##_show(struct device *dev, struct device_attribute *attr,\t\t\\\n\t\tchar *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ipack_device *idev = to_ipack_dev(dev);\t\t\t\\\n\treturn sprintf(buf, format_string, idev->field);\t\t\\\n}\n\nstatic ssize_t id_show(struct device *dev,\n\t\t       struct device_attribute *attr, char *buf)\n{\n\tunsigned int i, c, l, s;\n\tstruct ipack_device *idev = to_ipack_dev(dev);\n\n\n\tswitch (idev->id_format) {\n\tcase IPACK_ID_VERSION_1:\n\t\tl = 0x7; s = 1; break;\n\tcase IPACK_ID_VERSION_2:\n\t\tl = 0xf; s = 2; break;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\tc = 0;\n\tfor (i = 0; i < idev->id_avail; i++) {\n\t\tif (i > 0) {\n\t\t\tif ((i & l) == 0)\n\t\t\t\tbuf[c++] = '\\n';\n\t\t\telse if ((i & s) == 0)\n\t\t\t\tbuf[c++] = ' ';\n\t\t}\n\t\tsprintf(&buf[c], \"%02x\", idev->id[i]);\n\t\tc += 2;\n\t}\n\tbuf[c++] = '\\n';\n\treturn c;\n}\n\nstatic ssize_t\nid_vendor_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ipack_device *idev = to_ipack_dev(dev);\n\tswitch (idev->id_format) {\n\tcase IPACK_ID_VERSION_1:\n\t\treturn sprintf(buf, \"0x%02x\\n\", idev->id_vendor);\n\tcase IPACK_ID_VERSION_2:\n\t\treturn sprintf(buf, \"0x%06x\\n\", idev->id_vendor);\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic ssize_t\nid_device_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ipack_device *idev = to_ipack_dev(dev);\n\tswitch (idev->id_format) {\n\tcase IPACK_ID_VERSION_1:\n\t\treturn sprintf(buf, \"0x%02x\\n\", idev->id_device);\n\tcase IPACK_ID_VERSION_2:\n\t\treturn sprintf(buf, \"0x%04x\\n\", idev->id_device);\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ipack_device *idev = to_ipack_dev(dev);\n\n\treturn sprintf(buf, \"ipac:f%02Xv%08Xd%08X\", idev->id_format,\n\t\t       idev->id_vendor, idev->id_device);\n}\n\nipack_device_attr(id_format, \"0x%hhx\\n\");\n\nstatic DEVICE_ATTR_RO(id);\nstatic DEVICE_ATTR_RO(id_device);\nstatic DEVICE_ATTR_RO(id_format);\nstatic DEVICE_ATTR_RO(id_vendor);\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *ipack_attrs[] = {\n\t&dev_attr_id.attr,\n\t&dev_attr_id_device.attr,\n\t&dev_attr_id_format.attr,\n\t&dev_attr_id_vendor.attr,\n\t&dev_attr_modalias.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ipack);\n\nstatic struct bus_type ipack_bus_type = {\n\t.name      = \"ipack\",\n\t.probe     = ipack_bus_probe,\n\t.match     = ipack_bus_match,\n\t.remove    = ipack_bus_remove,\n\t.dev_groups = ipack_groups,\n\t.uevent\t   = ipack_uevent,\n};\n\nstruct ipack_bus_device *ipack_bus_register(struct device *parent, int slots,\n\t\t\t\t\t    const struct ipack_bus_ops *ops,\n\t\t\t\t\t    struct module *owner)\n{\n\tint bus_nr;\n\tstruct ipack_bus_device *bus;\n\n\tbus = kzalloc(sizeof(*bus), GFP_KERNEL);\n\tif (!bus)\n\t\treturn NULL;\n\n\tbus_nr = ida_simple_get(&ipack_ida, 0, 0, GFP_KERNEL);\n\tif (bus_nr < 0) {\n\t\tkfree(bus);\n\t\treturn NULL;\n\t}\n\n\tbus->bus_nr = bus_nr;\n\tbus->parent = parent;\n\tbus->slots = slots;\n\tbus->ops = ops;\n\tbus->owner = owner;\n\treturn bus;\n}\nEXPORT_SYMBOL_GPL(ipack_bus_register);\n\nstatic int ipack_unregister_bus_member(struct device *dev, void *data)\n{\n\tstruct ipack_device *idev = to_ipack_dev(dev);\n\tstruct ipack_bus_device *bus = data;\n\n\tif (idev->bus == bus)\n\t\tipack_device_del(idev);\n\n\treturn 1;\n}\n\nint ipack_bus_unregister(struct ipack_bus_device *bus)\n{\n\tbus_for_each_dev(&ipack_bus_type, NULL, bus,\n\t\tipack_unregister_bus_member);\n\tida_simple_remove(&ipack_ida, bus->bus_nr);\n\tkfree(bus);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipack_bus_unregister);\n\nint ipack_driver_register(struct ipack_driver *edrv, struct module *owner,\n\t\t\t  const char *name)\n{\n\tif (!edrv->ops->probe)\n\t\treturn -EINVAL;\n\n\tedrv->driver.owner = owner;\n\tedrv->driver.name = name;\n\tedrv->driver.bus = &ipack_bus_type;\n\treturn driver_register(&edrv->driver);\n}\nEXPORT_SYMBOL_GPL(ipack_driver_register);\n\nvoid ipack_driver_unregister(struct ipack_driver *edrv)\n{\n\tdriver_unregister(&edrv->driver);\n}\nEXPORT_SYMBOL_GPL(ipack_driver_unregister);\n\nstatic u16 ipack_crc_byte(u16 crc, u8 c)\n{\n\tint i;\n\n\tcrc ^= c << 8;\n\tfor (i = 0; i < 8; i++)\n\t\tcrc = (crc << 1) ^ ((crc & 0x8000) ? 0x1021 : 0);\n\treturn crc;\n}\n\n \nstatic u8 ipack_calc_crc1(struct ipack_device *dev)\n{\n\tu8 c;\n\tu16 crc;\n\tunsigned int i;\n\n\tcrc = 0xffff;\n\tfor (i = 0; i < dev->id_avail; i++) {\n\t\tc = (i != 11) ? dev->id[i] : 0;\n\t\tcrc = ipack_crc_byte(crc, c);\n\t}\n\tcrc = ~crc;\n\treturn crc & 0xff;\n}\n\nstatic u16 ipack_calc_crc2(struct ipack_device *dev)\n{\n\tu8 c;\n\tu16 crc;\n\tunsigned int i;\n\n\tcrc = 0xffff;\n\tfor (i = 0; i < dev->id_avail; i++) {\n\t\tc = ((i != 0x18) && (i != 0x19)) ? dev->id[i] : 0;\n\t\tcrc = ipack_crc_byte(crc, c);\n\t}\n\tcrc = ~crc;\n\treturn crc;\n}\n\nstatic void ipack_parse_id1(struct ipack_device *dev)\n{\n\tu8 *id = dev->id;\n\tu8 crc;\n\n\tdev->id_vendor = id[4];\n\tdev->id_device = id[5];\n\tdev->speed_8mhz = 1;\n\tdev->speed_32mhz = (id[7] == 'H');\n\tcrc = ipack_calc_crc1(dev);\n\tdev->id_crc_correct = (crc == id[11]);\n\tif (!dev->id_crc_correct) {\n\t\tdev_warn(&dev->dev, \"ID CRC invalid found 0x%x, expected 0x%x.\\n\",\n\t\t\t\tid[11], crc);\n\t}\n}\n\nstatic void ipack_parse_id2(struct ipack_device *dev)\n{\n\t__be16 *id = (__be16 *) dev->id;\n\tu16 flags, crc;\n\n\tdev->id_vendor = ((be16_to_cpu(id[3]) & 0xff) << 16)\n\t\t\t + be16_to_cpu(id[4]);\n\tdev->id_device = be16_to_cpu(id[5]);\n\tflags = be16_to_cpu(id[10]);\n\tdev->speed_8mhz = !!(flags & 2);\n\tdev->speed_32mhz = !!(flags & 4);\n\tcrc = ipack_calc_crc2(dev);\n\tdev->id_crc_correct = (crc == be16_to_cpu(id[12]));\n\tif (!dev->id_crc_correct) {\n\t\tdev_warn(&dev->dev, \"ID CRC invalid found 0x%x, expected 0x%x.\\n\",\n\t\t\t\tid[11], crc);\n\t}\n}\n\nstatic int ipack_device_read_id(struct ipack_device *dev)\n{\n\tu8 __iomem *idmem;\n\tint i;\n\tint ret = 0;\n\n\tidmem = ioremap(dev->region[IPACK_ID_SPACE].start,\n\t\t\tdev->region[IPACK_ID_SPACE].size);\n\tif (!idmem) {\n\t\tdev_err(&dev->dev, \"error mapping memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif ((ioread8(idmem + 1) == 'I') &&\n\t\t\t(ioread8(idmem + 3) == 'P') &&\n\t\t\t(ioread8(idmem + 5) == 'A') &&\n\t\t\t((ioread8(idmem + 7) == 'C') ||\n\t\t\t (ioread8(idmem + 7) == 'H'))) {\n\t\tdev->id_format = IPACK_ID_VERSION_1;\n\t\tdev->id_avail = ioread8(idmem + 0x15);\n\t\tif ((dev->id_avail < 0x0c) || (dev->id_avail > 0x40)) {\n\t\t\tdev_warn(&dev->dev, \"invalid id size\");\n\t\t\tdev->id_avail = 0x0c;\n\t\t}\n\t} else if ((ioread8(idmem + 0) == 'I') &&\n\t\t\t(ioread8(idmem + 1) == 'V') &&\n\t\t\t(ioread8(idmem + 2) == 'A') &&\n\t\t\t(ioread8(idmem + 3) == 'T') &&\n\t\t\t(ioread8(idmem + 4) == ' ') &&\n\t\t\t(ioread8(idmem + 5) == '4')) {\n\t\tdev->id_format = IPACK_ID_VERSION_2;\n\t\tdev->id_avail = ioread16be(idmem + 0x16);\n\t\tif ((dev->id_avail < 0x1a) || (dev->id_avail > 0x40)) {\n\t\t\tdev_warn(&dev->dev, \"invalid id size\");\n\t\t\tdev->id_avail = 0x1a;\n\t\t}\n\t} else {\n\t\tdev->id_format = IPACK_ID_VERSION_INVALID;\n\t\tdev->id_avail = 0;\n\t}\n\n\tif (!dev->id_avail) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tdev->id = kmalloc(dev->id_avail, GFP_KERNEL);\n\tif (!dev->id) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < dev->id_avail; i++) {\n\t\tif (dev->id_format == IPACK_ID_VERSION_1)\n\t\t\tdev->id[i] = ioread8(idmem + (i << 1) + 1);\n\t\telse\n\t\t\tdev->id[i] = ioread8(idmem + i);\n\t}\n\n\t \n\tswitch (dev->id_format) {\n\tcase IPACK_ID_VERSION_1:\n\t\tipack_parse_id1(dev);\n\t\tbreak;\n\tcase IPACK_ID_VERSION_2:\n\t\tipack_parse_id2(dev);\n\t\tbreak;\n\t}\n\nout:\n\tiounmap(idmem);\n\n\treturn ret;\n}\n\nint ipack_device_init(struct ipack_device *dev)\n{\n\tint ret;\n\n\tdev->dev.bus = &ipack_bus_type;\n\tdev->dev.release = ipack_device_release;\n\tdev->dev.parent = dev->bus->parent;\n\tret = dev_set_name(&dev->dev,\n\t\t     \"ipack-dev.%u.%u\", dev->bus->bus_nr, dev->slot);\n\tif (ret)\n\t\treturn ret;\n\n\tdevice_initialize(&dev->dev);\n\n\tif (dev->bus->ops->set_clockrate(dev, 8))\n\t\tdev_warn(&dev->dev, \"failed to switch to 8 MHz operation for reading of device ID.\\n\");\n\tif (dev->bus->ops->reset_timeout(dev))\n\t\tdev_warn(&dev->dev, \"failed to reset potential timeout.\");\n\n\tret = ipack_device_read_id(dev);\n\tif (ret < 0) {\n\t\tdev_err(&dev->dev, \"error reading device id section.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (dev->speed_32mhz) {\n\t\tret = dev->bus->ops->set_clockrate(dev, 32);\n\t\tif (ret < 0)\n\t\t\tdev_err(&dev->dev, \"failed to switch to 32 MHz operation.\\n\");\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipack_device_init);\n\nint ipack_device_add(struct ipack_device *dev)\n{\n\treturn device_add(&dev->dev);\n}\nEXPORT_SYMBOL_GPL(ipack_device_add);\n\nvoid ipack_device_del(struct ipack_device *dev)\n{\n\tdevice_del(&dev->dev);\n\tipack_put_device(dev);\n}\nEXPORT_SYMBOL_GPL(ipack_device_del);\n\nvoid ipack_get_device(struct ipack_device *dev)\n{\n\tget_device(&dev->dev);\n}\nEXPORT_SYMBOL_GPL(ipack_get_device);\n\nvoid ipack_put_device(struct ipack_device *dev)\n{\n\tput_device(&dev->dev);\n}\nEXPORT_SYMBOL_GPL(ipack_put_device);\n\nstatic int __init ipack_init(void)\n{\n\tida_init(&ipack_ida);\n\treturn bus_register(&ipack_bus_type);\n}\n\nstatic void __exit ipack_exit(void)\n{\n\tbus_unregister(&ipack_bus_type);\n\tida_destroy(&ipack_ida);\n}\n\nmodule_init(ipack_init);\nmodule_exit(ipack_exit);\n\nMODULE_AUTHOR(\"Samuel Iglesias Gonsalvez <siglesias@igalia.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Industry-pack bus core\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}