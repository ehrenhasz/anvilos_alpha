{
  "module_name": "ipoctal.c",
  "hash_id": "7c2197afd3f02cc06beb7ddc943341cacaef83c76156ce805ad68d9b61c345d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ipack/devices/ipoctal.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/tty.h>\n#include <linux/serial.h>\n#include <linux/tty_flip.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/ipack.h>\n#include \"ipoctal.h\"\n#include \"scc2698.h\"\n\n#define IP_OCTAL_ID_SPACE_VECTOR    0x41\n#define IP_OCTAL_NB_BLOCKS          4\n\nstatic const struct tty_operations ipoctal_fops;\n\nstruct ipoctal_channel {\n\tstruct ipoctal_stats\t\tstats;\n\tunsigned int\t\t\tnb_bytes;\n\twait_queue_head_t\t\tqueue;\n\tspinlock_t\t\t\tlock;\n\tunsigned int\t\t\tpointer_read;\n\tunsigned int\t\t\tpointer_write;\n\tstruct tty_port\t\t\ttty_port;\n\tbool\t\t\t\ttty_registered;\n\tunion scc2698_channel __iomem\t*regs;\n\tunion scc2698_block __iomem\t*block_regs;\n\tunsigned int\t\t\tboard_id;\n\tu8\t\t\t\tisr_rx_rdy_mask;\n\tu8\t\t\t\tisr_tx_rdy_mask;\n\tunsigned int\t\t\trx_enable;\n};\n\nstruct ipoctal {\n\tstruct ipack_device\t\t*dev;\n\tunsigned int\t\t\tboard_id;\n\tstruct ipoctal_channel\t\tchannel[NR_CHANNELS];\n\tstruct tty_driver\t\t*tty_drv;\n\tu8 __iomem\t\t\t*mem8_space;\n\tu8 __iomem\t\t\t*int_space;\n};\n\nstatic inline struct ipoctal *chan_to_ipoctal(struct ipoctal_channel *chan,\n\t\t\t\t\t      unsigned int index)\n{\n\treturn container_of(chan, struct ipoctal, channel[index]);\n}\n\nstatic void ipoctal_reset_channel(struct ipoctal_channel *channel)\n{\n\tiowrite8(CR_DISABLE_RX | CR_DISABLE_TX, &channel->regs->w.cr);\n\tchannel->rx_enable = 0;\n\tiowrite8(CR_CMD_RESET_RX, &channel->regs->w.cr);\n\tiowrite8(CR_CMD_RESET_TX, &channel->regs->w.cr);\n\tiowrite8(CR_CMD_RESET_ERR_STATUS, &channel->regs->w.cr);\n\tiowrite8(CR_CMD_RESET_MR, &channel->regs->w.cr);\n}\n\nstatic int ipoctal_port_activate(struct tty_port *port, struct tty_struct *tty)\n{\n\tstruct ipoctal_channel *channel;\n\n\tchannel = dev_get_drvdata(tty->dev);\n\n\t \n\tiowrite8(CR_ENABLE_RX, &channel->regs->w.cr);\n\tchannel->rx_enable = 1;\n\treturn 0;\n}\n\nstatic int ipoctal_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct ipoctal_channel *channel = dev_get_drvdata(tty->dev);\n\tstruct ipoctal *ipoctal = chan_to_ipoctal(channel, tty->index);\n\tint res;\n\n\tif (!ipack_get_carrier(ipoctal->dev))\n\t\treturn -EBUSY;\n\n\tres = tty_standard_install(driver, tty);\n\tif (res)\n\t\tgoto err_put_carrier;\n\n\ttty->driver_data = channel;\n\n\treturn 0;\n\nerr_put_carrier:\n\tipack_put_carrier(ipoctal->dev);\n\n\treturn res;\n}\n\nstatic int ipoctal_open(struct tty_struct *tty, struct file *file)\n{\n\tstruct ipoctal_channel *channel = tty->driver_data;\n\n\treturn tty_port_open(&channel->tty_port, tty, file);\n}\n\nstatic void ipoctal_reset_stats(struct ipoctal_stats *stats)\n{\n\tstats->tx = 0;\n\tstats->rx = 0;\n\tstats->rcv_break = 0;\n\tstats->framing_err = 0;\n\tstats->overrun_err = 0;\n\tstats->parity_err = 0;\n}\n\nstatic void ipoctal_free_channel(struct ipoctal_channel *channel)\n{\n\tipoctal_reset_stats(&channel->stats);\n\tchannel->pointer_read = 0;\n\tchannel->pointer_write = 0;\n\tchannel->nb_bytes = 0;\n}\n\nstatic void ipoctal_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct ipoctal_channel *channel = tty->driver_data;\n\n\ttty_port_close(&channel->tty_port, tty, filp);\n\tipoctal_free_channel(channel);\n}\n\nstatic int ipoctal_get_icount(struct tty_struct *tty,\n\t\t\t      struct serial_icounter_struct *icount)\n{\n\tstruct ipoctal_channel *channel = tty->driver_data;\n\n\ticount->cts = 0;\n\ticount->dsr = 0;\n\ticount->rng = 0;\n\ticount->dcd = 0;\n\ticount->rx = channel->stats.rx;\n\ticount->tx = channel->stats.tx;\n\ticount->frame = channel->stats.framing_err;\n\ticount->parity = channel->stats.parity_err;\n\ticount->brk = channel->stats.rcv_break;\n\treturn 0;\n}\n\nstatic void ipoctal_irq_rx(struct ipoctal_channel *channel, u8 sr)\n{\n\tstruct tty_port *port = &channel->tty_port;\n\tunsigned char value;\n\tunsigned char flag;\n\tu8 isr;\n\n\tdo {\n\t\tvalue = ioread8(&channel->regs->r.rhr);\n\t\tflag = TTY_NORMAL;\n\t\t \n\t\tif (sr & SR_ERROR) {\n\t\t\tiowrite8(CR_CMD_RESET_ERR_STATUS, &channel->regs->w.cr);\n\n\t\t\tif (sr & SR_OVERRUN_ERROR) {\n\t\t\t\tchannel->stats.overrun_err++;\n\t\t\t\t \n\t\t\t\ttty_insert_flip_char(port, 0, TTY_OVERRUN);\n\t\t\t}\n\t\t\tif (sr & SR_PARITY_ERROR) {\n\t\t\t\tchannel->stats.parity_err++;\n\t\t\t\tflag = TTY_PARITY;\n\t\t\t}\n\t\t\tif (sr & SR_FRAMING_ERROR) {\n\t\t\t\tchannel->stats.framing_err++;\n\t\t\t\tflag = TTY_FRAME;\n\t\t\t}\n\t\t\tif (sr & SR_RECEIVED_BREAK) {\n\t\t\t\tchannel->stats.rcv_break++;\n\t\t\t\tflag = TTY_BREAK;\n\t\t\t}\n\t\t}\n\t\ttty_insert_flip_char(port, value, flag);\n\n\t\t \n\t\tisr = ioread8(&channel->block_regs->r.isr);\n\t\tsr = ioread8(&channel->regs->r.sr);\n\t} while (isr & channel->isr_rx_rdy_mask);\n\n\ttty_flip_buffer_push(port);\n}\n\nstatic void ipoctal_irq_tx(struct ipoctal_channel *channel)\n{\n\tunsigned char value;\n\tunsigned int *pointer_write = &channel->pointer_write;\n\n\tif (channel->nb_bytes == 0)\n\t\treturn;\n\n\tspin_lock(&channel->lock);\n\tvalue = channel->tty_port.xmit_buf[*pointer_write];\n\tiowrite8(value, &channel->regs->w.thr);\n\tchannel->stats.tx++;\n\t(*pointer_write)++;\n\t*pointer_write = *pointer_write % PAGE_SIZE;\n\tchannel->nb_bytes--;\n\tspin_unlock(&channel->lock);\n}\n\nstatic void ipoctal_irq_channel(struct ipoctal_channel *channel)\n{\n\tu8 isr, sr;\n\n\t \n\tisr = ioread8(&channel->block_regs->r.isr);\n\tsr = ioread8(&channel->regs->r.sr);\n\n\tif (isr & (IMR_DELTA_BREAK_A | IMR_DELTA_BREAK_B))\n\t\tiowrite8(CR_CMD_RESET_BREAK_CHANGE, &channel->regs->w.cr);\n\n\tif ((sr & SR_TX_EMPTY) && (channel->nb_bytes == 0)) {\n\t\tiowrite8(CR_DISABLE_TX, &channel->regs->w.cr);\n\t\t \n\t\tif (channel->board_id == IPACK1_DEVICE_ID_SBS_OCTAL_485) {\n\t\t\tiowrite8(CR_CMD_NEGATE_RTSN, &channel->regs->w.cr);\n\t\t\tiowrite8(CR_ENABLE_RX, &channel->regs->w.cr);\n\t\t\tchannel->rx_enable = 1;\n\t\t}\n\t}\n\n\t \n\tif ((isr & channel->isr_rx_rdy_mask) && (sr & SR_RX_READY))\n\t\tipoctal_irq_rx(channel, sr);\n\n\t \n\tif ((isr & channel->isr_tx_rdy_mask) && (sr & SR_TX_READY))\n\t\tipoctal_irq_tx(channel);\n}\n\nstatic irqreturn_t ipoctal_irq_handler(void *arg)\n{\n\tunsigned int i;\n\tstruct ipoctal *ipoctal = arg;\n\n\t \n\treadw(ipoctal->int_space + ACK_INT_REQ0);\n\treadw(ipoctal->int_space + ACK_INT_REQ1);\n\n\t \n\tfor (i = 0; i < NR_CHANNELS; i++)\n\t\tipoctal_irq_channel(&ipoctal->channel[i]);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct tty_port_operations ipoctal_tty_port_ops = {\n\t.dtr_rts = NULL,\n\t.activate = ipoctal_port_activate,\n};\n\nstatic int ipoctal_inst_slot(struct ipoctal *ipoctal, unsigned int bus_nr,\n\t\t\t     unsigned int slot)\n{\n\tint res;\n\tint i;\n\tstruct tty_driver *drv;\n\tstruct ipoctal_channel *channel;\n\tstruct ipack_region *region;\n\tvoid __iomem *addr;\n\tunion scc2698_channel __iomem *chan_regs;\n\tunion scc2698_block __iomem *block_regs;\n\n\tipoctal->board_id = ipoctal->dev->id_device;\n\n\tregion = &ipoctal->dev->region[IPACK_IO_SPACE];\n\taddr = devm_ioremap(&ipoctal->dev->dev,\n\t\t\t\t    region->start, region->size);\n\tif (!addr) {\n\t\tdev_err(&ipoctal->dev->dev,\n\t\t\t\"Unable to map slot [%d:%d] IO space!\\n\",\n\t\t\tbus_nr, slot);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\t \n\tchan_regs =\n\t\t(union scc2698_channel __iomem *) addr;\n\tblock_regs =\n\t\t(union scc2698_block __iomem *) addr;\n\n\tregion = &ipoctal->dev->region[IPACK_INT_SPACE];\n\tipoctal->int_space =\n\t\tdevm_ioremap(&ipoctal->dev->dev,\n\t\t\t\t     region->start, region->size);\n\tif (!ipoctal->int_space) {\n\t\tdev_err(&ipoctal->dev->dev,\n\t\t\t\"Unable to map slot [%d:%d] INT space!\\n\",\n\t\t\tbus_nr, slot);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tregion = &ipoctal->dev->region[IPACK_MEM8_SPACE];\n\tipoctal->mem8_space =\n\t\tdevm_ioremap(&ipoctal->dev->dev,\n\t\t\t\t     region->start, 0x8000);\n\tif (!ipoctal->mem8_space) {\n\t\tdev_err(&ipoctal->dev->dev,\n\t\t\t\"Unable to map slot [%d:%d] MEM8 space!\\n\",\n\t\t\tbus_nr, slot);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\n\t \n\tfor (i = 0; i < NR_CHANNELS ; i++) {\n\t\tstruct ipoctal_channel *channel = &ipoctal->channel[i];\n\t\tchannel->regs = chan_regs + i;\n\t\tchannel->block_regs = block_regs + (i >> 1);\n\t\tchannel->board_id = ipoctal->board_id;\n\t\tif (i & 1) {\n\t\t\tchannel->isr_tx_rdy_mask = ISR_TxRDY_B;\n\t\t\tchannel->isr_rx_rdy_mask = ISR_RxRDY_FFULL_B;\n\t\t} else {\n\t\t\tchannel->isr_tx_rdy_mask = ISR_TxRDY_A;\n\t\t\tchannel->isr_rx_rdy_mask = ISR_RxRDY_FFULL_A;\n\t\t}\n\n\t\tipoctal_reset_channel(channel);\n\t\tiowrite8(MR1_CHRL_8_BITS | MR1_ERROR_CHAR | MR1_RxINT_RxRDY,\n\t\t\t &channel->regs->w.mr);  \n\t\tiowrite8(0, &channel->regs->w.mr);  \n\t\tiowrite8(TX_CLK_9600  | RX_CLK_9600, &channel->regs->w.csr);\n\t}\n\n\tfor (i = 0; i < IP_OCTAL_NB_BLOCKS; i++) {\n\t\tiowrite8(ACR_BRG_SET2, &block_regs[i].w.acr);\n\t\tiowrite8(OPCR_MPP_OUTPUT | OPCR_MPOa_RTSN | OPCR_MPOb_RTSN,\n\t\t\t &block_regs[i].w.opcr);\n\t\tiowrite8(IMR_TxRDY_A | IMR_RxRDY_FFULL_A | IMR_DELTA_BREAK_A |\n\t\t\t IMR_TxRDY_B | IMR_RxRDY_FFULL_B | IMR_DELTA_BREAK_B,\n\t\t\t &block_regs[i].w.imr);\n\t}\n\n\t \n\tiowrite8(1, ipoctal->mem8_space + 1);\n\n\t \n\n\t \n\tdrv = tty_alloc_driver(NR_CHANNELS, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(drv))\n\t\treturn PTR_ERR(drv);\n\n\t \n\tdrv->owner = THIS_MODULE;\n\tdrv->driver_name = KBUILD_MODNAME;\n\tdrv->name = kasprintf(GFP_KERNEL, KBUILD_MODNAME \".%d.%d.\", bus_nr, slot);\n\tif (!drv->name) {\n\t\tres = -ENOMEM;\n\t\tgoto err_put_driver;\n\t}\n\tdrv->major = 0;\n\n\tdrv->minor_start = 0;\n\tdrv->type = TTY_DRIVER_TYPE_SERIAL;\n\tdrv->subtype = SERIAL_TYPE_NORMAL;\n\tdrv->init_termios = tty_std_termios;\n\tdrv->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;\n\tdrv->init_termios.c_ispeed = 9600;\n\tdrv->init_termios.c_ospeed = 9600;\n\n\ttty_set_operations(drv, &ipoctal_fops);\n\tres = tty_register_driver(drv);\n\tif (res) {\n\t\tdev_err(&ipoctal->dev->dev, \"Can't register tty driver.\\n\");\n\t\tgoto err_free_name;\n\t}\n\n\t \n\tipoctal->tty_drv = drv;\n\n\tfor (i = 0; i < NR_CHANNELS; i++) {\n\t\tstruct device *tty_dev;\n\n\t\tchannel = &ipoctal->channel[i];\n\t\ttty_port_init(&channel->tty_port);\n\t\tres = tty_port_alloc_xmit_buf(&channel->tty_port);\n\t\tif (res)\n\t\t\tcontinue;\n\t\tchannel->tty_port.ops = &ipoctal_tty_port_ops;\n\n\t\tipoctal_reset_stats(&channel->stats);\n\t\tchannel->nb_bytes = 0;\n\t\tspin_lock_init(&channel->lock);\n\t\tchannel->pointer_read = 0;\n\t\tchannel->pointer_write = 0;\n\t\ttty_dev = tty_port_register_device_attr(&channel->tty_port, drv,\n\t\t\t\t\t\t\ti, NULL, channel, NULL);\n\t\tif (IS_ERR(tty_dev)) {\n\t\t\tdev_err(&ipoctal->dev->dev, \"Failed to register tty device.\\n\");\n\t\t\ttty_port_free_xmit_buf(&channel->tty_port);\n\t\t\ttty_port_destroy(&channel->tty_port);\n\t\t\tcontinue;\n\t\t}\n\t\tchannel->tty_registered = true;\n\t}\n\n\t \n\tipoctal->dev->bus->ops->request_irq(ipoctal->dev,\n\t\t\t\t       ipoctal_irq_handler, ipoctal);\n\n\treturn 0;\n\nerr_free_name:\n\tkfree(drv->name);\nerr_put_driver:\n\ttty_driver_kref_put(drv);\n\n\treturn res;\n}\n\nstatic inline int ipoctal_copy_write_buffer(struct ipoctal_channel *channel,\n\t\t\t\t\t    const u8 *buf, int count)\n{\n\tunsigned long flags;\n\tint i;\n\tunsigned int *pointer_read = &channel->pointer_read;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tif (i <= (PAGE_SIZE - channel->nb_bytes)) {\n\t\t\tspin_lock_irqsave(&channel->lock, flags);\n\t\t\tchannel->tty_port.xmit_buf[*pointer_read] = buf[i];\n\t\t\t*pointer_read = (*pointer_read + 1) % PAGE_SIZE;\n\t\t\tchannel->nb_bytes++;\n\t\t\tspin_unlock_irqrestore(&channel->lock, flags);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic ssize_t ipoctal_write_tty(struct tty_struct *tty, const u8 *buf,\n\t\t\t\t size_t count)\n{\n\tstruct ipoctal_channel *channel = tty->driver_data;\n\tunsigned int char_copied;\n\n\tchar_copied = ipoctal_copy_write_buffer(channel, buf, count);\n\n\t \n\tif (channel->board_id == IPACK1_DEVICE_ID_SBS_OCTAL_485) {\n\t\tiowrite8(CR_DISABLE_RX, &channel->regs->w.cr);\n\t\tchannel->rx_enable = 0;\n\t\tiowrite8(CR_CMD_ASSERT_RTSN, &channel->regs->w.cr);\n\t}\n\n\t \n\tiowrite8(CR_ENABLE_TX, &channel->regs->w.cr);\n\treturn char_copied;\n}\n\nstatic unsigned int ipoctal_write_room(struct tty_struct *tty)\n{\n\tstruct ipoctal_channel *channel = tty->driver_data;\n\n\treturn PAGE_SIZE - channel->nb_bytes;\n}\n\nstatic unsigned int ipoctal_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct ipoctal_channel *channel = tty->driver_data;\n\n\treturn channel->nb_bytes;\n}\n\nstatic void ipoctal_set_termios(struct tty_struct *tty,\n\t\t\t\tconst struct ktermios *old_termios)\n{\n\tunsigned int cflag;\n\tunsigned char mr1 = 0;\n\tunsigned char mr2 = 0;\n\tunsigned char csr = 0;\n\tstruct ipoctal_channel *channel = tty->driver_data;\n\tspeed_t baud;\n\n\tcflag = tty->termios.c_cflag;\n\n\t \n\tipoctal_reset_channel(channel);\n\n\t \n\tswitch (cflag & CSIZE) {\n\tcase CS6:\n\t\tmr1 |= MR1_CHRL_6_BITS;\n\t\tbreak;\n\tcase CS7:\n\t\tmr1 |= MR1_CHRL_7_BITS;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tmr1 |= MR1_CHRL_8_BITS;\n\t\t \n\t\ttty->termios.c_cflag = (cflag & ~CSIZE) | CS8;\n\t\tbreak;\n\t}\n\n\t \n\tif (cflag & PARENB)\n\t\tif (cflag & PARODD)\n\t\t\tmr1 |= MR1_PARITY_ON | MR1_PARITY_ODD;\n\t\telse\n\t\t\tmr1 |= MR1_PARITY_ON | MR1_PARITY_EVEN;\n\telse\n\t\tmr1 |= MR1_PARITY_OFF;\n\n\t \n\ttty->termios.c_cflag &= ~CMSPAR;\n\n\t \n\tif (cflag & CSTOPB)\n\t\tmr2 |= MR2_STOP_BITS_LENGTH_2;\n\telse\n\t\tmr2 |= MR2_STOP_BITS_LENGTH_1;\n\n\t \n\tswitch (channel->board_id) {\n\tcase IPACK1_DEVICE_ID_SBS_OCTAL_232:\n\t\tif (cflag & CRTSCTS) {\n\t\t\tmr1 |= MR1_RxRTS_CONTROL_ON;\n\t\t\tmr2 |= MR2_TxRTS_CONTROL_OFF | MR2_CTS_ENABLE_TX_ON;\n\t\t} else {\n\t\t\tmr1 |= MR1_RxRTS_CONTROL_OFF;\n\t\t\tmr2 |= MR2_TxRTS_CONTROL_OFF | MR2_CTS_ENABLE_TX_OFF;\n\t\t}\n\t\tbreak;\n\tcase IPACK1_DEVICE_ID_SBS_OCTAL_422:\n\t\tmr1 |= MR1_RxRTS_CONTROL_OFF;\n\t\tmr2 |= MR2_TxRTS_CONTROL_OFF | MR2_CTS_ENABLE_TX_OFF;\n\t\tbreak;\n\tcase IPACK1_DEVICE_ID_SBS_OCTAL_485:\n\t\tmr1 |= MR1_RxRTS_CONTROL_OFF;\n\t\tmr2 |= MR2_TxRTS_CONTROL_ON | MR2_CTS_ENABLE_TX_OFF;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tbaud = tty_get_baud_rate(tty);\n\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\n\t \n\tswitch (baud) {\n\tcase 75:\n\t\tcsr |= TX_CLK_75 | RX_CLK_75;\n\t\tbreak;\n\tcase 110:\n\t\tcsr |= TX_CLK_110 | RX_CLK_110;\n\t\tbreak;\n\tcase 150:\n\t\tcsr |= TX_CLK_150 | RX_CLK_150;\n\t\tbreak;\n\tcase 300:\n\t\tcsr |= TX_CLK_300 | RX_CLK_300;\n\t\tbreak;\n\tcase 600:\n\t\tcsr |= TX_CLK_600 | RX_CLK_600;\n\t\tbreak;\n\tcase 1200:\n\t\tcsr |= TX_CLK_1200 | RX_CLK_1200;\n\t\tbreak;\n\tcase 1800:\n\t\tcsr |= TX_CLK_1800 | RX_CLK_1800;\n\t\tbreak;\n\tcase 2000:\n\t\tcsr |= TX_CLK_2000 | RX_CLK_2000;\n\t\tbreak;\n\tcase 2400:\n\t\tcsr |= TX_CLK_2400 | RX_CLK_2400;\n\t\tbreak;\n\tcase 4800:\n\t\tcsr |= TX_CLK_4800  | RX_CLK_4800;\n\t\tbreak;\n\tcase 9600:\n\t\tcsr |= TX_CLK_9600  | RX_CLK_9600;\n\t\tbreak;\n\tcase 19200:\n\t\tcsr |= TX_CLK_19200 | RX_CLK_19200;\n\t\tbreak;\n\tcase 38400:\n\tdefault:\n\t\tcsr |= TX_CLK_38400 | RX_CLK_38400;\n\t\t \n\t\ttty_termios_encode_baud_rate(&tty->termios, 38400, 38400);\n\t\tbreak;\n\t}\n\n\tmr1 |= MR1_ERROR_CHAR;\n\tmr1 |= MR1_RxINT_RxRDY;\n\n\t \n\tiowrite8(mr1, &channel->regs->w.mr);\n\tiowrite8(mr2, &channel->regs->w.mr);\n\tiowrite8(csr, &channel->regs->w.csr);\n\n\t \n\tif (channel->rx_enable)\n\t\tiowrite8(CR_ENABLE_RX, &channel->regs->w.cr);\n}\n\nstatic void ipoctal_hangup(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\tstruct ipoctal_channel *channel = tty->driver_data;\n\n\tif (channel == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&channel->lock, flags);\n\tchannel->nb_bytes = 0;\n\tchannel->pointer_read = 0;\n\tchannel->pointer_write = 0;\n\tspin_unlock_irqrestore(&channel->lock, flags);\n\n\ttty_port_hangup(&channel->tty_port);\n\n\tipoctal_reset_channel(channel);\n\ttty_port_set_initialized(&channel->tty_port, false);\n\twake_up_interruptible(&channel->tty_port.open_wait);\n}\n\nstatic void ipoctal_shutdown(struct tty_struct *tty)\n{\n\tstruct ipoctal_channel *channel = tty->driver_data;\n\n\tif (channel == NULL)\n\t\treturn;\n\n\tipoctal_reset_channel(channel);\n\ttty_port_set_initialized(&channel->tty_port, false);\n}\n\nstatic void ipoctal_cleanup(struct tty_struct *tty)\n{\n\tstruct ipoctal_channel *channel = tty->driver_data;\n\tstruct ipoctal *ipoctal = chan_to_ipoctal(channel, tty->index);\n\n\t \n\tipack_put_carrier(ipoctal->dev);\n}\n\nstatic const struct tty_operations ipoctal_fops = {\n\t.ioctl =\t\tNULL,\n\t.install =\t\tipoctal_install,\n\t.open =\t\t\tipoctal_open,\n\t.close =\t\tipoctal_close,\n\t.write =\t\tipoctal_write_tty,\n\t.set_termios =\t\tipoctal_set_termios,\n\t.write_room =\t\tipoctal_write_room,\n\t.chars_in_buffer =\tipoctal_chars_in_buffer,\n\t.get_icount =\t\tipoctal_get_icount,\n\t.hangup =\t\tipoctal_hangup,\n\t.shutdown =\t\tipoctal_shutdown,\n\t.cleanup =              ipoctal_cleanup,\n};\n\nstatic int ipoctal_probe(struct ipack_device *dev)\n{\n\tint res;\n\tstruct ipoctal *ipoctal;\n\n\tipoctal = kzalloc(sizeof(struct ipoctal), GFP_KERNEL);\n\tif (ipoctal == NULL)\n\t\treturn -ENOMEM;\n\n\tipoctal->dev = dev;\n\tres = ipoctal_inst_slot(ipoctal, dev->bus->bus_nr, dev->slot);\n\tif (res)\n\t\tgoto out_uninst;\n\n\tdev_set_drvdata(&dev->dev, ipoctal);\n\treturn 0;\n\nout_uninst:\n\tkfree(ipoctal);\n\treturn res;\n}\n\nstatic void __ipoctal_remove(struct ipoctal *ipoctal)\n{\n\tint i;\n\n\tipoctal->dev->bus->ops->free_irq(ipoctal->dev);\n\n\tfor (i = 0; i < NR_CHANNELS; i++) {\n\t\tstruct ipoctal_channel *channel = &ipoctal->channel[i];\n\n\t\tif (!channel->tty_registered)\n\t\t\tcontinue;\n\n\t\ttty_unregister_device(ipoctal->tty_drv, i);\n\t\ttty_port_free_xmit_buf(&channel->tty_port);\n\t\ttty_port_destroy(&channel->tty_port);\n\t}\n\n\ttty_unregister_driver(ipoctal->tty_drv);\n\tkfree(ipoctal->tty_drv->name);\n\ttty_driver_kref_put(ipoctal->tty_drv);\n\tkfree(ipoctal);\n}\n\nstatic void ipoctal_remove(struct ipack_device *idev)\n{\n\t__ipoctal_remove(dev_get_drvdata(&idev->dev));\n}\n\nstatic DEFINE_IPACK_DEVICE_TABLE(ipoctal_ids) = {\n\t{ IPACK_DEVICE(IPACK_ID_VERSION_1, IPACK1_VENDOR_ID_SBS,\n\t\t\tIPACK1_DEVICE_ID_SBS_OCTAL_232) },\n\t{ IPACK_DEVICE(IPACK_ID_VERSION_1, IPACK1_VENDOR_ID_SBS,\n\t\t\tIPACK1_DEVICE_ID_SBS_OCTAL_422) },\n\t{ IPACK_DEVICE(IPACK_ID_VERSION_1, IPACK1_VENDOR_ID_SBS,\n\t\t\tIPACK1_DEVICE_ID_SBS_OCTAL_485) },\n\t{ 0, },\n};\n\nMODULE_DEVICE_TABLE(ipack, ipoctal_ids);\n\nstatic const struct ipack_driver_ops ipoctal_drv_ops = {\n\t.probe  = ipoctal_probe,\n\t.remove = ipoctal_remove,\n};\n\nstatic struct ipack_driver driver = {\n\t.ops      = &ipoctal_drv_ops,\n\t.id_table = ipoctal_ids,\n};\n\nstatic int __init ipoctal_init(void)\n{\n\treturn ipack_driver_register(&driver, THIS_MODULE, KBUILD_MODNAME);\n}\n\nstatic void __exit ipoctal_exit(void)\n{\n\tipack_driver_unregister(&driver);\n}\n\nMODULE_DESCRIPTION(\"IP-Octal 232, 422 and 485 device driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(ipoctal_init);\nmodule_exit(ipoctal_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}