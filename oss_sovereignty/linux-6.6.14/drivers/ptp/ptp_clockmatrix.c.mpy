{
  "module_name": "ptp_clockmatrix.c",
  "hash_id": "fc5e7d429a7c489442528400e23ffc6acdf06fa9bc2777a044e797eda14f33f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_clockmatrix.c",
  "human_readable_source": "\n \n#include <linux/firmware.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/timekeeping.h>\n#include <linux/string.h>\n#include <linux/of.h>\n#include <linux/mfd/rsmu.h>\n#include <linux/mfd/idt8a340_reg.h>\n#include <asm/unaligned.h>\n\n#include \"ptp_private.h\"\n#include \"ptp_clockmatrix.h\"\n\nMODULE_DESCRIPTION(\"Driver for IDT ClockMatrix(TM) family\");\nMODULE_AUTHOR(\"Richard Cochran <richardcochran@gmail.com>\");\nMODULE_AUTHOR(\"IDT support-1588 <IDT-support-1588@lm.renesas.com>\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic char *firmware;\nmodule_param(firmware, charp, 0);\n\n#define SETTIME_CORRECTION (0)\n#define EXTTS_PERIOD_MS (95)\n\nstatic int _idtcm_adjfine(struct idtcm_channel *channel, long scaled_ppm);\n\nstatic inline int idtcm_read(struct idtcm *idtcm,\n\t\t\t     u16 module,\n\t\t\t     u16 regaddr,\n\t\t\t     u8 *buf,\n\t\t\t     u16 count)\n{\n\treturn regmap_bulk_read(idtcm->regmap, module + regaddr, buf, count);\n}\n\nstatic inline int idtcm_write(struct idtcm *idtcm,\n\t\t\t      u16 module,\n\t\t\t      u16 regaddr,\n\t\t\t      u8 *buf,\n\t\t\t      u16 count)\n{\n\treturn regmap_bulk_write(idtcm->regmap, module + regaddr, buf, count);\n}\n\nstatic int contains_full_configuration(struct idtcm *idtcm,\n\t\t\t\t       const struct firmware *fw)\n{\n\tstruct idtcm_fwrc *rec = (struct idtcm_fwrc *)fw->data;\n\tu16 scratch = IDTCM_FW_REG(idtcm->fw_ver, V520, SCRATCH);\n\ts32 full_count;\n\ts32 count = 0;\n\tu16 regaddr;\n\tu8 loaddr;\n\ts32 len;\n\n\t \n\tfull_count = (scratch - GPIO_USER_CONTROL) -\n\t\t     ((scratch >> 7) - (GPIO_USER_CONTROL >> 7)) * 4;\n\n\t \n\tfor (len = fw->size; len > 0; len -= sizeof(*rec)) {\n\t\tregaddr = rec->hiaddr << 8;\n\t\tregaddr |= rec->loaddr;\n\n\t\tloaddr = rec->loaddr;\n\n\t\trec++;\n\n\t\t \n\t\tif (regaddr < GPIO_USER_CONTROL || regaddr >= scratch)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((loaddr > 0x7b && loaddr <= 0x7f) || loaddr > 0xfb)\n\t\t\tcontinue;\n\n\t\tcount++;\n\t}\n\n\treturn (count >= full_count);\n}\n\nstatic int char_array_to_timespec(u8 *buf,\n\t\t\t\t  u8 count,\n\t\t\t\t  struct timespec64 *ts)\n{\n\tu8 i;\n\tu64 nsec;\n\ttime64_t sec;\n\n\tif (count < TOD_BYTE_COUNT)\n\t\treturn 1;\n\n\t \n\tnsec = buf[4];\n\tfor (i = 0; i < 3; i++) {\n\t\tnsec <<= 8;\n\t\tnsec |= buf[3 - i];\n\t}\n\n\tsec = buf[10];\n\tfor (i = 0; i < 5; i++) {\n\t\tsec <<= 8;\n\t\tsec |= buf[9 - i];\n\t}\n\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n\n\treturn 0;\n}\n\nstatic int timespec_to_char_array(struct timespec64 const *ts,\n\t\t\t\t  u8 *buf,\n\t\t\t\t  u8 count)\n{\n\tu8 i;\n\ts32 nsec;\n\ttime64_t sec;\n\n\tif (count < TOD_BYTE_COUNT)\n\t\treturn 1;\n\n\tnsec = ts->tv_nsec;\n\tsec = ts->tv_sec;\n\n\t \n\tbuf[0] = 0;\n\tfor (i = 1; i < 5; i++) {\n\t\tbuf[i] = nsec & 0xff;\n\t\tnsec >>= 8;\n\t}\n\n\tfor (i = 5; i < TOD_BYTE_COUNT; i++) {\n\n\t\tbuf[i] = sec & 0xff;\n\t\tsec >>= 8;\n\t}\n\n\treturn 0;\n}\n\nstatic int idtcm_strverscmp(const char *version1, const char *version2)\n{\n\tu8 ver1[3], ver2[3];\n\tint i;\n\n\tif (sscanf(version1, \"%hhu.%hhu.%hhu\",\n\t\t   &ver1[0], &ver1[1], &ver1[2]) != 3)\n\t\treturn -1;\n\tif (sscanf(version2, \"%hhu.%hhu.%hhu\",\n\t\t   &ver2[0], &ver2[1], &ver2[2]) != 3)\n\t\treturn -1;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (ver1[i] > ver2[i])\n\t\t\treturn 1;\n\t\tif (ver1[i] < ver2[i])\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic enum fw_version idtcm_fw_version(const char *version)\n{\n\tenum fw_version ver = V_DEFAULT;\n\n\tif (idtcm_strverscmp(version, \"4.8.7\") >= 0)\n\t\tver = V487;\n\n\tif (idtcm_strverscmp(version, \"5.2.0\") >= 0)\n\t\tver = V520;\n\n\treturn ver;\n}\n\nstatic int clear_boot_status(struct idtcm *idtcm)\n{\n\tu8 buf[4] = {0};\n\n\treturn idtcm_write(idtcm, GENERAL_STATUS, BOOT_STATUS, buf, sizeof(buf));\n}\n\nstatic int read_boot_status(struct idtcm *idtcm, u32 *status)\n{\n\tint err;\n\tu8 buf[4] = {0};\n\n\terr = idtcm_read(idtcm, GENERAL_STATUS, BOOT_STATUS, buf, sizeof(buf));\n\n\t*status = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\n\n\treturn err;\n}\n\nstatic int wait_for_boot_status_ready(struct idtcm *idtcm)\n{\n\tu32 status = 0;\n\tu8 i = 30;\t \n\tint err;\n\n\tdo {\n\t\terr = read_boot_status(idtcm, &status);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (status == 0xA0)\n\t\t\treturn 0;\n\n\t\tmsleep(100);\n\t\ti--;\n\n\t} while (i);\n\n\tdev_warn(idtcm->dev, \"%s timed out\", __func__);\n\n\treturn -EBUSY;\n}\n\nstatic int arm_tod_read_trig_sel_refclk(struct idtcm_channel *channel, u8 ref)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tu16 tod_read_cmd = IDTCM_FW_REG(idtcm->fw_ver, V520, TOD_READ_SECONDARY_CMD);\n\tu8 val = 0;\n\tint err;\n\n\tval &= ~(WR_REF_INDEX_MASK << WR_REF_INDEX_SHIFT);\n\tval |= (ref << WR_REF_INDEX_SHIFT);\n\n\terr = idtcm_write(idtcm, channel->tod_read_secondary,\n\t\t\t  TOD_READ_SECONDARY_SEL_CFG_0, &val, sizeof(val));\n\tif (err)\n\t\treturn err;\n\n\tval = 0 | (SCSR_TOD_READ_TRIG_SEL_REFCLK << TOD_READ_TRIGGER_SHIFT);\n\n\terr = idtcm_write(idtcm, channel->tod_read_secondary, tod_read_cmd,\n\t\t\t  &val, sizeof(val));\n\tif (err)\n\t\tdev_err(idtcm->dev, \"%s: err = %d\", __func__, err);\n\n\treturn err;\n}\n\nstatic bool is_single_shot(u8 mask)\n{\n\t \n\treturn !(mask <= 8 && is_power_of_2(mask));\n}\n\nstatic int idtcm_extts_enable(struct idtcm_channel *channel,\n\t\t\t      struct ptp_clock_request *rq, int on)\n{\n\tu8 index = rq->extts.index;\n\tstruct idtcm *idtcm;\n\tu8 mask = 1 << index;\n\tint err = 0;\n\tu8 old_mask;\n\tint ref;\n\n\tidtcm = channel->idtcm;\n\told_mask = idtcm->extts_mask;\n\n\t \n\tif (rq->extts.flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t\tPTP_RISING_EDGE |\n\t\t\t\tPTP_FALLING_EDGE |\n\t\t\t\tPTP_STRICT_FLAGS))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((rq->extts.flags & PTP_ENABLE_FEATURE) &&\n\t    (rq->extts.flags & PTP_FALLING_EDGE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (index >= MAX_TOD)\n\t\treturn -EINVAL;\n\n\tif (on) {\n\t\t \n\t\t \n\t\tref = ptp_find_pin(channel->ptp_clock, PTP_PF_EXTTS, channel->tod);\n\n\t\tif (ref < 0) {\n\t\t\tdev_err(idtcm->dev, \"%s: No valid pin found for TOD%d!\\n\",\n\t\t\t\t__func__, channel->tod);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\terr = arm_tod_read_trig_sel_refclk(&idtcm->channel[index], ref);\n\n\t\tif (err == 0) {\n\t\t\tidtcm->extts_mask |= mask;\n\t\t\tidtcm->event_channel[index] = channel;\n\t\t\tidtcm->channel[index].refn = ref;\n\t\t\tidtcm->extts_single_shot = is_single_shot(idtcm->extts_mask);\n\n\t\t\tif (old_mask)\n\t\t\t\treturn 0;\n\n\t\t\tschedule_delayed_work(&idtcm->extts_work,\n\t\t\t\t\t      msecs_to_jiffies(EXTTS_PERIOD_MS));\n\t\t}\n\t} else {\n\t\tidtcm->extts_mask &= ~mask;\n\t\tidtcm->extts_single_shot = is_single_shot(idtcm->extts_mask);\n\n\t\tif (idtcm->extts_mask == 0)\n\t\t\tcancel_delayed_work(&idtcm->extts_work);\n\t}\n\n\treturn err;\n}\n\nstatic int read_sys_apll_status(struct idtcm *idtcm, u8 *status)\n{\n\treturn idtcm_read(idtcm, STATUS, DPLL_SYS_APLL_STATUS, status,\n\t\t\t  sizeof(u8));\n}\n\nstatic int read_sys_dpll_status(struct idtcm *idtcm, u8 *status)\n{\n\treturn idtcm_read(idtcm, STATUS, DPLL_SYS_STATUS, status, sizeof(u8));\n}\n\nstatic int wait_for_sys_apll_dpll_lock(struct idtcm *idtcm)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(LOCK_TIMEOUT_MS);\n\tu8 apll = 0;\n\tu8 dpll = 0;\n\tint err;\n\n\tdo {\n\t\terr = read_sys_apll_status(idtcm, &apll);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = read_sys_dpll_status(idtcm, &dpll);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tapll &= SYS_APLL_LOSS_LOCK_LIVE_MASK;\n\t\tdpll &= DPLL_SYS_STATE_MASK;\n\n\t\tif (apll == SYS_APLL_LOSS_LOCK_LIVE_LOCKED &&\n\t\t    dpll == DPLL_STATE_LOCKED) {\n\t\t\treturn 0;\n\t\t} else if (dpll == DPLL_STATE_FREERUN ||\n\t\t\t   dpll == DPLL_STATE_HOLDOVER ||\n\t\t\t   dpll == DPLL_STATE_OPEN_LOOP) {\n\t\t\tdev_warn(idtcm->dev,\n\t\t\t\t\"No wait state: DPLL_SYS_STATE %d\", dpll);\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\tmsleep(LOCK_POLL_INTERVAL_MS);\n\t} while (time_is_after_jiffies(timeout));\n\n\tdev_warn(idtcm->dev,\n\t\t \"%d ms lock timeout: SYS APLL Loss Lock %d  SYS DPLL state %d\",\n\t\t LOCK_TIMEOUT_MS, apll, dpll);\n\n\treturn -ETIME;\n}\n\nstatic void wait_for_chip_ready(struct idtcm *idtcm)\n{\n\tif (wait_for_boot_status_ready(idtcm))\n\t\tdev_warn(idtcm->dev, \"BOOT_STATUS != 0xA0\");\n\n\tif (wait_for_sys_apll_dpll_lock(idtcm))\n\t\tdev_warn(idtcm->dev,\n\t\t\t \"Continuing while SYS APLL/DPLL is not locked\");\n}\n\nstatic int _idtcm_gettime_triggered(struct idtcm_channel *channel,\n\t\t\t\t    struct timespec64 *ts)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tu16 tod_read_cmd = IDTCM_FW_REG(idtcm->fw_ver, V520, TOD_READ_SECONDARY_CMD);\n\tu8 buf[TOD_BYTE_COUNT];\n\tu8 trigger;\n\tint err;\n\n\terr = idtcm_read(idtcm, channel->tod_read_secondary,\n\t\t\t tod_read_cmd, &trigger, sizeof(trigger));\n\tif (err)\n\t\treturn err;\n\n\tif (trigger & TOD_READ_TRIGGER_MASK)\n\t\treturn -EBUSY;\n\n\terr = idtcm_read(idtcm, channel->tod_read_secondary,\n\t\t\t TOD_READ_SECONDARY_BASE, buf, sizeof(buf));\n\tif (err)\n\t\treturn err;\n\n\treturn char_array_to_timespec(buf, sizeof(buf), ts);\n}\n\nstatic int _idtcm_gettime(struct idtcm_channel *channel,\n\t\t\t  struct timespec64 *ts, u8 timeout)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tu16 tod_read_cmd = IDTCM_FW_REG(idtcm->fw_ver, V520, TOD_READ_PRIMARY_CMD);\n\tu8 buf[TOD_BYTE_COUNT];\n\tu8 trigger;\n\tint err;\n\n\t \n\tdo {\n\t\tif (timeout-- == 0)\n\t\t\treturn -EIO;\n\n\t\tif (idtcm->calculate_overhead_flag)\n\t\t\tidtcm->start_time = ktime_get_raw();\n\n\t\terr = idtcm_read(idtcm, channel->tod_read_primary,\n\t\t\t\t tod_read_cmd, &trigger,\n\t\t\t\t sizeof(trigger));\n\t\tif (err)\n\t\t\treturn err;\n\t} while (trigger & TOD_READ_TRIGGER_MASK);\n\n\terr = idtcm_read(idtcm, channel->tod_read_primary,\n\t\t\t TOD_READ_PRIMARY_BASE, buf, sizeof(buf));\n\tif (err)\n\t\treturn err;\n\n\terr = char_array_to_timespec(buf, sizeof(buf), ts);\n\n\treturn err;\n}\n\nstatic int idtcm_extts_check_channel(struct idtcm *idtcm, u8 todn)\n{\n\tstruct idtcm_channel *ptp_channel, *extts_channel;\n\tstruct ptp_clock_event event;\n\tstruct timespec64 ts;\n\tu32 dco_delay = 0;\n\tint err;\n\n\textts_channel = &idtcm->channel[todn];\n\tptp_channel = idtcm->event_channel[todn];\n\n\tif (extts_channel == ptp_channel)\n\t\tdco_delay = ptp_channel->dco_delay;\n\n\terr = _idtcm_gettime_triggered(extts_channel, &ts);\n\tif (err)\n\t\treturn err;\n\n\t \n\tevent.type = PTP_CLOCK_EXTTS;\n\tevent.index = todn;\n\tevent.timestamp = timespec64_to_ns(&ts) - dco_delay;\n\tptp_clock_event(ptp_channel->ptp_clock, &event);\n\n\treturn err;\n}\n\nstatic int _idtcm_gettime_immediate(struct idtcm_channel *channel,\n\t\t\t\t    struct timespec64 *ts)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\n\tu16 tod_read_cmd = IDTCM_FW_REG(idtcm->fw_ver, V520, TOD_READ_PRIMARY_CMD);\n\tu8 val = (SCSR_TOD_READ_TRIG_SEL_IMMEDIATE << TOD_READ_TRIGGER_SHIFT);\n\tint err;\n\n\terr = idtcm_write(idtcm, channel->tod_read_primary,\n\t\t\t  tod_read_cmd, &val, sizeof(val));\n\tif (err)\n\t\treturn err;\n\n\treturn _idtcm_gettime(channel, ts, 10);\n}\n\nstatic int _sync_pll_output(struct idtcm *idtcm,\n\t\t\t    u8 pll,\n\t\t\t    u8 sync_src,\n\t\t\t    u8 qn,\n\t\t\t    u8 qn_plus_1)\n{\n\tint err;\n\tu8 val;\n\tu16 sync_ctrl0;\n\tu16 sync_ctrl1;\n\tu8 temp;\n\n\tif (qn == 0 && qn_plus_1 == 0)\n\t\treturn 0;\n\n\tswitch (pll) {\n\tcase 0:\n\t\tsync_ctrl0 = HW_Q0_Q1_CH_SYNC_CTRL_0;\n\t\tsync_ctrl1 = HW_Q0_Q1_CH_SYNC_CTRL_1;\n\t\tbreak;\n\tcase 1:\n\t\tsync_ctrl0 = HW_Q2_Q3_CH_SYNC_CTRL_0;\n\t\tsync_ctrl1 = HW_Q2_Q3_CH_SYNC_CTRL_1;\n\t\tbreak;\n\tcase 2:\n\t\tsync_ctrl0 = HW_Q4_Q5_CH_SYNC_CTRL_0;\n\t\tsync_ctrl1 = HW_Q4_Q5_CH_SYNC_CTRL_1;\n\t\tbreak;\n\tcase 3:\n\t\tsync_ctrl0 = HW_Q6_Q7_CH_SYNC_CTRL_0;\n\t\tsync_ctrl1 = HW_Q6_Q7_CH_SYNC_CTRL_1;\n\t\tbreak;\n\tcase 4:\n\t\tsync_ctrl0 = HW_Q8_CH_SYNC_CTRL_0;\n\t\tsync_ctrl1 = HW_Q8_CH_SYNC_CTRL_1;\n\t\tbreak;\n\tcase 5:\n\t\tsync_ctrl0 = HW_Q9_CH_SYNC_CTRL_0;\n\t\tsync_ctrl1 = HW_Q9_CH_SYNC_CTRL_1;\n\t\tbreak;\n\tcase 6:\n\t\tsync_ctrl0 = HW_Q10_CH_SYNC_CTRL_0;\n\t\tsync_ctrl1 = HW_Q10_CH_SYNC_CTRL_1;\n\t\tbreak;\n\tcase 7:\n\t\tsync_ctrl0 = HW_Q11_CH_SYNC_CTRL_0;\n\t\tsync_ctrl1 = HW_Q11_CH_SYNC_CTRL_1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = SYNCTRL1_MASTER_SYNC_RST;\n\n\t \n\terr = idtcm_write(idtcm, 0, sync_ctrl1, &val, sizeof(val));\n\tif (err)\n\t\treturn err;\n\n\terr = idtcm_write(idtcm, 0, sync_ctrl0, &sync_src, sizeof(sync_src));\n\tif (err)\n\t\treturn err;\n\n\t \n\tval |= SYNCTRL1_FBDIV_FRAME_SYNC_TRIG | SYNCTRL1_FBDIV_SYNC_TRIG;\n\n\tif (qn)\n\t\tval |= SYNCTRL1_Q0_DIV_SYNC_TRIG;\n\n\tif (qn_plus_1)\n\t\tval |= SYNCTRL1_Q1_DIV_SYNC_TRIG;\n\n\terr = idtcm_write(idtcm, 0, sync_ctrl1, &val, sizeof(val));\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (pll == 5 && qn_plus_1 != 0) {\n\t\terr = idtcm_read(idtcm, 0, HW_Q8_CTRL_SPARE,\n\t\t\t\t &temp, sizeof(temp));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttemp &= ~(Q9_TO_Q8_SYNC_TRIG);\n\n\t\terr = idtcm_write(idtcm, 0, HW_Q8_CTRL_SPARE,\n\t\t\t\t  &temp, sizeof(temp));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttemp |= Q9_TO_Q8_SYNC_TRIG;\n\n\t\terr = idtcm_write(idtcm, 0, HW_Q8_CTRL_SPARE,\n\t\t\t\t  &temp, sizeof(temp));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (pll == 6 && qn_plus_1 != 0) {\n\t\terr = idtcm_read(idtcm, 0, HW_Q11_CTRL_SPARE,\n\t\t\t\t &temp, sizeof(temp));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttemp &= ~(Q10_TO_Q11_SYNC_TRIG);\n\n\t\terr = idtcm_write(idtcm, 0, HW_Q11_CTRL_SPARE,\n\t\t\t\t  &temp, sizeof(temp));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttemp |= Q10_TO_Q11_SYNC_TRIG;\n\n\t\terr = idtcm_write(idtcm, 0, HW_Q11_CTRL_SPARE,\n\t\t\t\t  &temp, sizeof(temp));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tval &= ~(SYNCTRL1_MASTER_SYNC_RST);\n\terr = idtcm_write(idtcm, 0, sync_ctrl1, &val, sizeof(val));\n\n\treturn err;\n}\n\nstatic int idtcm_sync_pps_output(struct idtcm_channel *channel)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tu8 pll;\n\tu8 qn;\n\tu8 qn_plus_1;\n\tint err = 0;\n\tu8 out8_mux = 0;\n\tu8 out11_mux = 0;\n\tu8 temp;\n\tu16 output_mask = channel->output_mask;\n\n\terr = idtcm_read(idtcm, 0, HW_Q8_CTRL_SPARE,\n\t\t\t &temp, sizeof(temp));\n\tif (err)\n\t\treturn err;\n\n\tif ((temp & Q9_TO_Q8_FANOUT_AND_CLOCK_SYNC_ENABLE_MASK) ==\n\t    Q9_TO_Q8_FANOUT_AND_CLOCK_SYNC_ENABLE_MASK)\n\t\tout8_mux = 1;\n\n\terr = idtcm_read(idtcm, 0, HW_Q11_CTRL_SPARE,\n\t\t\t &temp, sizeof(temp));\n\tif (err)\n\t\treturn err;\n\n\tif ((temp & Q10_TO_Q11_FANOUT_AND_CLOCK_SYNC_ENABLE_MASK) ==\n\t    Q10_TO_Q11_FANOUT_AND_CLOCK_SYNC_ENABLE_MASK)\n\t\tout11_mux = 1;\n\n\tfor (pll = 0; pll < 8; pll++) {\n\t\tqn = 0;\n\t\tqn_plus_1 = 0;\n\n\t\tif (pll < 4) {\n\t\t\t \n\t\t\tqn = output_mask & 0x1;\n\t\t\toutput_mask = output_mask >> 1;\n\t\t\tqn_plus_1 = output_mask & 0x1;\n\t\t\toutput_mask = output_mask >> 1;\n\t\t} else if (pll == 4) {\n\t\t\tif (out8_mux == 0) {\n\t\t\t\tqn = output_mask & 0x1;\n\t\t\t\toutput_mask = output_mask >> 1;\n\t\t\t}\n\t\t} else if (pll == 5) {\n\t\t\tif (out8_mux) {\n\t\t\t\tqn_plus_1 = output_mask & 0x1;\n\t\t\t\toutput_mask = output_mask >> 1;\n\t\t\t}\n\t\t\tqn = output_mask & 0x1;\n\t\t\toutput_mask = output_mask >> 1;\n\t\t} else if (pll == 6) {\n\t\t\tqn = output_mask & 0x1;\n\t\t\toutput_mask = output_mask >> 1;\n\t\t\tif (out11_mux) {\n\t\t\t\tqn_plus_1 = output_mask & 0x1;\n\t\t\t\toutput_mask = output_mask >> 1;\n\t\t\t}\n\t\t} else if (pll == 7) {\n\t\t\tif (out11_mux == 0) {\n\t\t\t\tqn = output_mask & 0x1;\n\t\t\t\toutput_mask = output_mask >> 1;\n\t\t\t}\n\t\t}\n\n\t\tif (qn != 0 || qn_plus_1 != 0)\n\t\t\terr = _sync_pll_output(idtcm, pll, channel->sync_src,\n\t\t\t\t\t       qn, qn_plus_1);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int _idtcm_set_dpll_hw_tod(struct idtcm_channel *channel,\n\t\t\t\t  struct timespec64 const *ts,\n\t\t\t\t  enum hw_tod_write_trig_sel wr_trig)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tu8 buf[TOD_BYTE_COUNT];\n\tu8 cmd;\n\tint err;\n\tstruct timespec64 local_ts = *ts;\n\ts64 total_overhead_ns;\n\n\t \n\terr = idtcm_read(idtcm, channel->hw_dpll_n, HW_DPLL_TOD_CTRL_1,\n\t\t\t &cmd, sizeof(cmd));\n\tif (err)\n\t\treturn err;\n\n\tcmd &= ~(0x0f);\n\tcmd |= wr_trig | 0x08;\n\n\terr = idtcm_write(idtcm, channel->hw_dpll_n, HW_DPLL_TOD_CTRL_1,\n\t\t\t  &cmd, sizeof(cmd));\n\tif (err)\n\t\treturn err;\n\n\tif (wr_trig  != HW_TOD_WR_TRIG_SEL_MSB) {\n\t\terr = timespec_to_char_array(&local_ts, buf, sizeof(buf));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = idtcm_write(idtcm, channel->hw_dpll_n,\n\t\t\t\t  HW_DPLL_TOD_OVR__0, buf, sizeof(buf));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tcmd &= ~(0x08);\n\n\terr = idtcm_write(idtcm, channel->hw_dpll_n, HW_DPLL_TOD_CTRL_1,\n\t\t\t  &cmd, sizeof(cmd));\n\n\tif (wr_trig == HW_TOD_WR_TRIG_SEL_MSB) {\n\t\tif (idtcm->calculate_overhead_flag) {\n\t\t\t \n\t\t\tktime_t diff = ktime_sub(ktime_get_raw(),\n\t\t\t\t\t\t idtcm->start_time);\n\t\t\ttotal_overhead_ns =  ktime_to_ns(diff)\n\t\t\t\t\t     + idtcm->tod_write_overhead_ns\n\t\t\t\t\t     + SETTIME_CORRECTION;\n\n\t\t\ttimespec64_add_ns(&local_ts, total_overhead_ns);\n\n\t\t\tidtcm->calculate_overhead_flag = 0;\n\t\t}\n\n\t\terr = timespec_to_char_array(&local_ts, buf, sizeof(buf));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = idtcm_write(idtcm, channel->hw_dpll_n,\n\t\t\t\t  HW_DPLL_TOD_OVR__0, buf, sizeof(buf));\n\t}\n\n\treturn err;\n}\n\nstatic int _idtcm_set_dpll_scsr_tod(struct idtcm_channel *channel,\n\t\t\t\t    struct timespec64 const *ts,\n\t\t\t\t    enum scsr_tod_write_trig_sel wr_trig,\n\t\t\t\t    enum scsr_tod_write_type_sel wr_type)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tunsigned char buf[TOD_BYTE_COUNT], cmd;\n\tstruct timespec64 local_ts = *ts;\n\tint err, count = 0;\n\n\ttimespec64_add_ns(&local_ts, SETTIME_CORRECTION);\n\n\terr = timespec_to_char_array(&local_ts, buf, sizeof(buf));\n\tif (err)\n\t\treturn err;\n\n\terr = idtcm_write(idtcm, channel->tod_write, TOD_WRITE,\n\t\t\t  buf, sizeof(buf));\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = idtcm_read(idtcm, channel->tod_write, TOD_WRITE_CMD,\n\t\t\t &cmd, sizeof(cmd));\n\tif (err)\n\t\treturn err;\n\n\tcmd &= ~(TOD_WRITE_SELECTION_MASK << TOD_WRITE_SELECTION_SHIFT);\n\tcmd &= ~(TOD_WRITE_TYPE_MASK << TOD_WRITE_TYPE_SHIFT);\n\tcmd |= (wr_trig << TOD_WRITE_SELECTION_SHIFT);\n\tcmd |= (wr_type << TOD_WRITE_TYPE_SHIFT);\n\n\terr = idtcm_write(idtcm, channel->tod_write, TOD_WRITE_CMD,\n\t\t\t   &cmd, sizeof(cmd));\n\tif (err)\n\t\treturn err;\n\n\t \n\twhile (1) {\n\t\t \n\t\tif (wr_trig == SCSR_TOD_WR_TRIG_SEL_TODPPS)\n\t\t\tmsleep(50);\n\n\t\terr = idtcm_read(idtcm, channel->tod_write, TOD_WRITE_CMD,\n\t\t\t\t &cmd, sizeof(cmd));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((cmd & TOD_WRITE_SELECTION_MASK) == 0)\n\t\t\tbreak;\n\n\t\tif (++count > 20) {\n\t\t\tdev_err(idtcm->dev,\n\t\t\t\t\"Timed out waiting for the write counter\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int get_output_base_addr(enum fw_version ver, u8 outn)\n{\n\tint base;\n\n\tswitch (outn) {\n\tcase 0:\n\t\tbase = IDTCM_FW_REG(ver, V520, OUTPUT_0);\n\t\tbreak;\n\tcase 1:\n\t\tbase = IDTCM_FW_REG(ver, V520, OUTPUT_1);\n\t\tbreak;\n\tcase 2:\n\t\tbase = IDTCM_FW_REG(ver, V520, OUTPUT_2);\n\t\tbreak;\n\tcase 3:\n\t\tbase = IDTCM_FW_REG(ver, V520, OUTPUT_3);\n\t\tbreak;\n\tcase 4:\n\t\tbase = IDTCM_FW_REG(ver, V520, OUTPUT_4);\n\t\tbreak;\n\tcase 5:\n\t\tbase = IDTCM_FW_REG(ver, V520, OUTPUT_5);\n\t\tbreak;\n\tcase 6:\n\t\tbase = IDTCM_FW_REG(ver, V520, OUTPUT_6);\n\t\tbreak;\n\tcase 7:\n\t\tbase = IDTCM_FW_REG(ver, V520, OUTPUT_7);\n\t\tbreak;\n\tcase 8:\n\t\tbase = IDTCM_FW_REG(ver, V520, OUTPUT_8);\n\t\tbreak;\n\tcase 9:\n\t\tbase = IDTCM_FW_REG(ver, V520, OUTPUT_9);\n\t\tbreak;\n\tcase 10:\n\t\tbase = IDTCM_FW_REG(ver, V520, OUTPUT_10);\n\t\tbreak;\n\tcase 11:\n\t\tbase = IDTCM_FW_REG(ver, V520, OUTPUT_11);\n\t\tbreak;\n\tdefault:\n\t\tbase = -EINVAL;\n\t}\n\n\treturn base;\n}\n\nstatic int _idtcm_settime_deprecated(struct idtcm_channel *channel,\n\t\t\t\t     struct timespec64 const *ts)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\n\terr = _idtcm_set_dpll_hw_tod(channel, ts, HW_TOD_WR_TRIG_SEL_MSB);\n\tif (err) {\n\t\tdev_err(idtcm->dev,\n\t\t\t\"%s: Set HW ToD failed\", __func__);\n\t\treturn err;\n\t}\n\n\treturn idtcm_sync_pps_output(channel);\n}\n\nstatic int _idtcm_settime(struct idtcm_channel *channel,\n\t\t\t  struct timespec64 const *ts,\n\t\t\t  enum scsr_tod_write_type_sel wr_type)\n{\n\treturn _idtcm_set_dpll_scsr_tod(channel, ts,\n\t\t\t\t\tSCSR_TOD_WR_TRIG_SEL_IMMEDIATE,\n\t\t\t\t\twr_type);\n}\n\nstatic int idtcm_set_phase_pull_in_offset(struct idtcm_channel *channel,\n\t\t\t\t\t  s32 offset_ns)\n{\n\tint err;\n\tint i;\n\tstruct idtcm *idtcm = channel->idtcm;\n\tu8 buf[4];\n\n\tfor (i = 0; i < 4; i++) {\n\t\tbuf[i] = 0xff & (offset_ns);\n\t\toffset_ns >>= 8;\n\t}\n\n\terr = idtcm_write(idtcm, channel->dpll_phase_pull_in, PULL_IN_OFFSET,\n\t\t\t  buf, sizeof(buf));\n\n\treturn err;\n}\n\nstatic int idtcm_set_phase_pull_in_slope_limit(struct idtcm_channel *channel,\n\t\t\t\t\t       u32 max_ffo_ppb)\n{\n\tint err;\n\tu8 i;\n\tstruct idtcm *idtcm = channel->idtcm;\n\tu8 buf[3];\n\n\tif (max_ffo_ppb & 0xff000000)\n\t\tmax_ffo_ppb = 0;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tbuf[i] = 0xff & (max_ffo_ppb);\n\t\tmax_ffo_ppb >>= 8;\n\t}\n\n\terr = idtcm_write(idtcm, channel->dpll_phase_pull_in,\n\t\t\t  PULL_IN_SLOPE_LIMIT, buf, sizeof(buf));\n\n\treturn err;\n}\n\nstatic int idtcm_start_phase_pull_in(struct idtcm_channel *channel)\n{\n\tint err;\n\tstruct idtcm *idtcm = channel->idtcm;\n\tu8 buf;\n\n\terr = idtcm_read(idtcm, channel->dpll_phase_pull_in, PULL_IN_CTRL,\n\t\t\t &buf, sizeof(buf));\n\tif (err)\n\t\treturn err;\n\n\tif (buf == 0) {\n\t\tbuf = 0x01;\n\t\terr = idtcm_write(idtcm, channel->dpll_phase_pull_in,\n\t\t\t\t  PULL_IN_CTRL, &buf, sizeof(buf));\n\t} else {\n\t\terr = -EBUSY;\n\t}\n\n\treturn err;\n}\n\nstatic int do_phase_pull_in_fw(struct idtcm_channel *channel,\n\t\t\t       s32 offset_ns,\n\t\t\t       u32 max_ffo_ppb)\n{\n\tint err;\n\n\terr = idtcm_set_phase_pull_in_offset(channel, -offset_ns);\n\tif (err)\n\t\treturn err;\n\n\terr = idtcm_set_phase_pull_in_slope_limit(channel, max_ffo_ppb);\n\tif (err)\n\t\treturn err;\n\n\terr = idtcm_start_phase_pull_in(channel);\n\n\treturn err;\n}\n\nstatic int set_tod_write_overhead(struct idtcm_channel *channel)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\ts64 current_ns = 0;\n\ts64 lowest_ns = 0;\n\tint err;\n\tu8 i;\n\tktime_t start;\n\tktime_t stop;\n\tktime_t diff;\n\n\tchar buf[TOD_BYTE_COUNT] = {0};\n\n\t \n\tidtcm_write(idtcm, channel->hw_dpll_n, HW_DPLL_TOD_OVR__0,\n\t\t    buf, sizeof(buf));\n\n\tfor (i = 0; i < TOD_WRITE_OVERHEAD_COUNT_MAX; i++) {\n\t\tstart = ktime_get_raw();\n\n\t\terr = idtcm_write(idtcm, channel->hw_dpll_n,\n\t\t\t\t  HW_DPLL_TOD_OVR__0, buf, sizeof(buf));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstop = ktime_get_raw();\n\n\t\tdiff = ktime_sub(stop, start);\n\n\t\tcurrent_ns = ktime_to_ns(diff);\n\n\t\tif (i == 0) {\n\t\t\tlowest_ns = current_ns;\n\t\t} else {\n\t\t\tif (current_ns < lowest_ns)\n\t\t\t\tlowest_ns = current_ns;\n\t\t}\n\t}\n\n\tidtcm->tod_write_overhead_ns = lowest_ns;\n\n\treturn err;\n}\n\nstatic int _idtcm_adjtime_deprecated(struct idtcm_channel *channel, s64 delta)\n{\n\tint err;\n\tstruct idtcm *idtcm = channel->idtcm;\n\tstruct timespec64 ts;\n\ts64 now;\n\n\tif (abs(delta) < PHASE_PULL_IN_THRESHOLD_NS_DEPRECATED) {\n\t\terr = channel->do_phase_pull_in(channel, delta, 0);\n\t} else {\n\t\tidtcm->calculate_overhead_flag = 1;\n\n\t\terr = set_tod_write_overhead(channel);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = _idtcm_gettime_immediate(channel, &ts);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnow = timespec64_to_ns(&ts);\n\t\tnow += delta;\n\n\t\tts = ns_to_timespec64(now);\n\n\t\terr = _idtcm_settime_deprecated(channel, &ts);\n\t}\n\n\treturn err;\n}\n\nstatic int idtcm_state_machine_reset(struct idtcm *idtcm)\n{\n\tu8 byte = SM_RESET_CMD;\n\tu32 status = 0;\n\tint err;\n\tu8 i;\n\n\tclear_boot_status(idtcm);\n\n\terr = idtcm_write(idtcm, RESET_CTRL,\n\t\t\t  IDTCM_FW_REG(idtcm->fw_ver, V520, SM_RESET),\n\t\t\t  &byte, sizeof(byte));\n\n\tif (!err) {\n\t\tfor (i = 0; i < 30; i++) {\n\t\t\tmsleep_interruptible(100);\n\t\t\tread_boot_status(idtcm, &status);\n\n\t\t\tif (status == 0xA0) {\n\t\t\t\tdev_dbg(idtcm->dev,\n\t\t\t\t\t\"SM_RESET completed in %d ms\", i * 100);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!status)\n\t\t\tdev_err(idtcm->dev,\n\t\t\t\t\"Timed out waiting for CM_RESET to complete\");\n\t}\n\n\treturn err;\n}\n\nstatic int idtcm_read_hw_rev_id(struct idtcm *idtcm, u8 *hw_rev_id)\n{\n\treturn idtcm_read(idtcm, HW_REVISION, REV_ID, hw_rev_id, sizeof(u8));\n}\n\nstatic int idtcm_read_product_id(struct idtcm *idtcm, u16 *product_id)\n{\n\tint err;\n\tu8 buf[2] = {0};\n\n\terr = idtcm_read(idtcm, GENERAL_STATUS, PRODUCT_ID, buf, sizeof(buf));\n\n\t*product_id = (buf[1] << 8) | buf[0];\n\n\treturn err;\n}\n\nstatic int idtcm_read_major_release(struct idtcm *idtcm, u8 *major)\n{\n\tint err;\n\tu8 buf = 0;\n\n\terr = idtcm_read(idtcm, GENERAL_STATUS, MAJ_REL, &buf, sizeof(buf));\n\n\t*major = buf >> 1;\n\n\treturn err;\n}\n\nstatic int idtcm_read_minor_release(struct idtcm *idtcm, u8 *minor)\n{\n\treturn idtcm_read(idtcm, GENERAL_STATUS, MIN_REL, minor, sizeof(u8));\n}\n\nstatic int idtcm_read_hotfix_release(struct idtcm *idtcm, u8 *hotfix)\n{\n\treturn idtcm_read(idtcm,\n\t\t\t  GENERAL_STATUS,\n\t\t\t  HOTFIX_REL,\n\t\t\t  hotfix,\n\t\t\t  sizeof(u8));\n}\n\nstatic int idtcm_read_otp_scsr_config_select(struct idtcm *idtcm,\n\t\t\t\t\t     u8 *config_select)\n{\n\treturn idtcm_read(idtcm, GENERAL_STATUS, OTP_SCSR_CONFIG_SELECT,\n\t\t\t  config_select, sizeof(u8));\n}\n\nstatic int set_pll_output_mask(struct idtcm *idtcm, u16 addr, u8 val)\n{\n\tint err = 0;\n\n\tswitch (addr) {\n\tcase TOD0_OUT_ALIGN_MASK_ADDR:\n\t\tSET_U16_LSB(idtcm->channel[0].output_mask, val);\n\t\tbreak;\n\tcase TOD0_OUT_ALIGN_MASK_ADDR + 1:\n\t\tSET_U16_MSB(idtcm->channel[0].output_mask, val);\n\t\tbreak;\n\tcase TOD1_OUT_ALIGN_MASK_ADDR:\n\t\tSET_U16_LSB(idtcm->channel[1].output_mask, val);\n\t\tbreak;\n\tcase TOD1_OUT_ALIGN_MASK_ADDR + 1:\n\t\tSET_U16_MSB(idtcm->channel[1].output_mask, val);\n\t\tbreak;\n\tcase TOD2_OUT_ALIGN_MASK_ADDR:\n\t\tSET_U16_LSB(idtcm->channel[2].output_mask, val);\n\t\tbreak;\n\tcase TOD2_OUT_ALIGN_MASK_ADDR + 1:\n\t\tSET_U16_MSB(idtcm->channel[2].output_mask, val);\n\t\tbreak;\n\tcase TOD3_OUT_ALIGN_MASK_ADDR:\n\t\tSET_U16_LSB(idtcm->channel[3].output_mask, val);\n\t\tbreak;\n\tcase TOD3_OUT_ALIGN_MASK_ADDR + 1:\n\t\tSET_U16_MSB(idtcm->channel[3].output_mask, val);\n\t\tbreak;\n\tdefault:\n\t\terr = -EFAULT;  ;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int set_tod_ptp_pll(struct idtcm *idtcm, u8 index, u8 pll)\n{\n\tif (index >= MAX_TOD) {\n\t\tdev_err(idtcm->dev, \"ToD%d not supported\", index);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pll >= MAX_PLL) {\n\t\tdev_err(idtcm->dev, \"Pll%d not supported\", pll);\n\t\treturn -EINVAL;\n\t}\n\n\tidtcm->channel[index].pll = pll;\n\n\treturn 0;\n}\n\nstatic int check_and_set_masks(struct idtcm *idtcm,\n\t\t\t       u16 regaddr,\n\t\t\t       u8 val)\n{\n\tint err = 0;\n\n\tswitch (regaddr) {\n\tcase TOD_MASK_ADDR:\n\t\tif ((val & 0xf0) || !(val & 0x0f)) {\n\t\t\tdev_err(idtcm->dev, \"Invalid TOD mask 0x%02x\", val);\n\t\t\terr = -EINVAL;\n\t\t} else {\n\t\t\tidtcm->tod_mask = val;\n\t\t}\n\t\tbreak;\n\tcase TOD0_PTP_PLL_ADDR:\n\t\terr = set_tod_ptp_pll(idtcm, 0, val);\n\t\tbreak;\n\tcase TOD1_PTP_PLL_ADDR:\n\t\terr = set_tod_ptp_pll(idtcm, 1, val);\n\t\tbreak;\n\tcase TOD2_PTP_PLL_ADDR:\n\t\terr = set_tod_ptp_pll(idtcm, 2, val);\n\t\tbreak;\n\tcase TOD3_PTP_PLL_ADDR:\n\t\terr = set_tod_ptp_pll(idtcm, 3, val);\n\t\tbreak;\n\tdefault:\n\t\terr = set_pll_output_mask(idtcm, regaddr, val);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void display_pll_and_masks(struct idtcm *idtcm)\n{\n\tu8 i;\n\tu8 mask;\n\n\tdev_dbg(idtcm->dev, \"tod_mask = 0x%02x\", idtcm->tod_mask);\n\n\tfor (i = 0; i < MAX_TOD; i++) {\n\t\tmask = 1 << i;\n\n\t\tif (mask & idtcm->tod_mask)\n\t\t\tdev_dbg(idtcm->dev,\n\t\t\t\t\"TOD%d pll = %d    output_mask = 0x%04x\",\n\t\t\t\ti, idtcm->channel[i].pll,\n\t\t\t\tidtcm->channel[i].output_mask);\n\t}\n}\n\nstatic int idtcm_load_firmware(struct idtcm *idtcm,\n\t\t\t       struct device *dev)\n{\n\tu16 scratch = IDTCM_FW_REG(idtcm->fw_ver, V520, SCRATCH);\n\tchar fname[128] = FW_FILENAME;\n\tconst struct firmware *fw;\n\tstruct idtcm_fwrc *rec;\n\tu32 regaddr;\n\tint err;\n\ts32 len;\n\tu8 val;\n\tu8 loaddr;\n\n\tif (firmware)  \n\t\tsnprintf(fname, sizeof(fname), \"%s\", firmware);\n\n\tdev_info(idtcm->dev, \"requesting firmware '%s'\", fname);\n\n\terr = request_firmware(&fw, fname, dev);\n\tif (err) {\n\t\tdev_err(idtcm->dev,\n\t\t\t\"Failed at line %d in %s!\", __LINE__, __func__);\n\t\treturn err;\n\t}\n\n\tdev_dbg(idtcm->dev, \"firmware size %zu bytes\", fw->size);\n\n\trec = (struct idtcm_fwrc *) fw->data;\n\n\tif (contains_full_configuration(idtcm, fw))\n\t\tidtcm_state_machine_reset(idtcm);\n\n\tfor (len = fw->size; len > 0; len -= sizeof(*rec)) {\n\t\tif (rec->reserved) {\n\t\t\tdev_err(idtcm->dev,\n\t\t\t\t\"bad firmware, reserved field non-zero\");\n\t\t\terr = -EINVAL;\n\t\t} else {\n\t\t\tregaddr = rec->hiaddr << 8;\n\t\t\tregaddr |= rec->loaddr;\n\n\t\t\tval = rec->value;\n\t\t\tloaddr = rec->loaddr;\n\n\t\t\trec++;\n\n\t\t\terr = check_and_set_masks(idtcm, regaddr, val);\n\t\t}\n\n\t\tif (err != -EINVAL) {\n\t\t\terr = 0;\n\n\t\t\t \n\t\t\tif (regaddr < GPIO_USER_CONTROL || regaddr >= scratch)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif ((loaddr > 0x7b && loaddr <= 0x7f) || loaddr > 0xfb)\n\t\t\t\tcontinue;\n\n\t\t\terr = idtcm_write(idtcm, regaddr, 0, &val, sizeof(val));\n\t\t}\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tdisplay_pll_and_masks(idtcm);\n\nout:\n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic int idtcm_output_enable(struct idtcm_channel *channel,\n\t\t\t       bool enable, unsigned int outn)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint base;\n\tint err;\n\tu8 val;\n\n\tbase = get_output_base_addr(idtcm->fw_ver, outn);\n\n\tif (!(base > 0)) {\n\t\tdev_err(idtcm->dev,\n\t\t\t\"%s - Unsupported out%d\", __func__, outn);\n\t\treturn base;\n\t}\n\n\terr = idtcm_read(idtcm, (u16)base, OUT_CTRL_1, &val, sizeof(val));\n\tif (err)\n\t\treturn err;\n\n\tif (enable)\n\t\tval |= SQUELCH_DISABLE;\n\telse\n\t\tval &= ~SQUELCH_DISABLE;\n\n\treturn idtcm_write(idtcm, (u16)base, OUT_CTRL_1, &val, sizeof(val));\n}\n\nstatic int idtcm_perout_enable(struct idtcm_channel *channel,\n\t\t\t       struct ptp_perout_request *perout,\n\t\t\t       bool enable)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tstruct timespec64 ts = {0, 0};\n\tint err;\n\n\terr = idtcm_output_enable(channel, enable, perout->index);\n\n\tif (err) {\n\t\tdev_err(idtcm->dev, \"Unable to set output enable\");\n\t\treturn err;\n\t}\n\n\t \n\treturn _idtcm_settime(channel, &ts, SCSR_TOD_WR_TYPE_SEL_DELTA_PLUS);\n}\n\nstatic int idtcm_get_pll_mode(struct idtcm_channel *channel,\n\t\t\t      enum pll_mode *mode)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\tu8 dpll_mode;\n\n\terr = idtcm_read(idtcm, channel->dpll_n,\n\t\t\t IDTCM_FW_REG(idtcm->fw_ver, V520, DPLL_MODE),\n\t\t\t &dpll_mode, sizeof(dpll_mode));\n\tif (err)\n\t\treturn err;\n\n\t*mode = (dpll_mode >> PLL_MODE_SHIFT) & PLL_MODE_MASK;\n\n\treturn 0;\n}\n\nstatic int idtcm_set_pll_mode(struct idtcm_channel *channel,\n\t\t\t      enum pll_mode mode)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\tu8 dpll_mode;\n\n\terr = idtcm_read(idtcm, channel->dpll_n,\n\t\t\t IDTCM_FW_REG(idtcm->fw_ver, V520, DPLL_MODE),\n\t\t\t &dpll_mode, sizeof(dpll_mode));\n\tif (err)\n\t\treturn err;\n\n\tdpll_mode &= ~(PLL_MODE_MASK << PLL_MODE_SHIFT);\n\n\tdpll_mode |= (mode << PLL_MODE_SHIFT);\n\n\terr = idtcm_write(idtcm, channel->dpll_n,\n\t\t\t  IDTCM_FW_REG(idtcm->fw_ver, V520, DPLL_MODE),\n\t\t\t  &dpll_mode, sizeof(dpll_mode));\n\treturn err;\n}\n\nstatic int idtcm_get_manual_reference(struct idtcm_channel *channel,\n\t\t\t\t      enum manual_reference *ref)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tu8 dpll_manu_ref_cfg;\n\tint err;\n\n\terr = idtcm_read(idtcm, channel->dpll_ctrl_n,\n\t\t\t DPLL_CTRL_DPLL_MANU_REF_CFG,\n\t\t\t &dpll_manu_ref_cfg, sizeof(dpll_manu_ref_cfg));\n\tif (err)\n\t\treturn err;\n\n\tdpll_manu_ref_cfg &= (MANUAL_REFERENCE_MASK << MANUAL_REFERENCE_SHIFT);\n\n\t*ref = dpll_manu_ref_cfg >> MANUAL_REFERENCE_SHIFT;\n\n\treturn 0;\n}\n\nstatic int idtcm_set_manual_reference(struct idtcm_channel *channel,\n\t\t\t\t      enum manual_reference ref)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tu8 dpll_manu_ref_cfg;\n\tint err;\n\n\terr = idtcm_read(idtcm, channel->dpll_ctrl_n,\n\t\t\t DPLL_CTRL_DPLL_MANU_REF_CFG,\n\t\t\t &dpll_manu_ref_cfg, sizeof(dpll_manu_ref_cfg));\n\tif (err)\n\t\treturn err;\n\n\tdpll_manu_ref_cfg &= ~(MANUAL_REFERENCE_MASK << MANUAL_REFERENCE_SHIFT);\n\n\tdpll_manu_ref_cfg |= (ref << MANUAL_REFERENCE_SHIFT);\n\n\terr = idtcm_write(idtcm, channel->dpll_ctrl_n,\n\t\t\t  DPLL_CTRL_DPLL_MANU_REF_CFG,\n\t\t\t  &dpll_manu_ref_cfg, sizeof(dpll_manu_ref_cfg));\n\n\treturn err;\n}\n\nstatic int configure_dpll_mode_write_frequency(struct idtcm_channel *channel)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\n\terr = idtcm_set_pll_mode(channel, PLL_MODE_WRITE_FREQUENCY);\n\n\tif (err)\n\t\tdev_err(idtcm->dev, \"Failed to set pll mode to write frequency\");\n\telse\n\t\tchannel->mode = PTP_PLL_MODE_WRITE_FREQUENCY;\n\n\treturn err;\n}\n\nstatic int configure_dpll_mode_write_phase(struct idtcm_channel *channel)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\n\terr = idtcm_set_pll_mode(channel, PLL_MODE_WRITE_PHASE);\n\n\tif (err)\n\t\tdev_err(idtcm->dev, \"Failed to set pll mode to write phase\");\n\telse\n\t\tchannel->mode = PTP_PLL_MODE_WRITE_PHASE;\n\n\treturn err;\n}\n\nstatic int configure_manual_reference_write_frequency(struct idtcm_channel *channel)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\n\terr = idtcm_set_manual_reference(channel, MANU_REF_WRITE_FREQUENCY);\n\n\tif (err)\n\t\tdev_err(idtcm->dev, \"Failed to set manual reference to write frequency\");\n\telse\n\t\tchannel->mode = PTP_PLL_MODE_WRITE_FREQUENCY;\n\n\treturn err;\n}\n\nstatic int configure_manual_reference_write_phase(struct idtcm_channel *channel)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\n\terr = idtcm_set_manual_reference(channel, MANU_REF_WRITE_PHASE);\n\n\tif (err)\n\t\tdev_err(idtcm->dev, \"Failed to set manual reference to write phase\");\n\telse\n\t\tchannel->mode = PTP_PLL_MODE_WRITE_PHASE;\n\n\treturn err;\n}\n\nstatic int idtcm_stop_phase_pull_in(struct idtcm_channel *channel)\n{\n\tint err;\n\n\terr = _idtcm_adjfine(channel, channel->current_freq_scaled_ppm);\n\tif (err)\n\t\treturn err;\n\n\tchannel->phase_pull_in = false;\n\n\treturn 0;\n}\n\nstatic long idtcm_work_handler(struct ptp_clock_info *ptp)\n{\n\tstruct idtcm_channel *channel = container_of(ptp, struct idtcm_channel, caps);\n\tstruct idtcm *idtcm = channel->idtcm;\n\n\tmutex_lock(idtcm->lock);\n\n\t(void)idtcm_stop_phase_pull_in(channel);\n\n\tmutex_unlock(idtcm->lock);\n\n\t \n\treturn -1;\n}\n\nstatic s32 phase_pull_in_scaled_ppm(s32 current_ppm, s32 phase_pull_in_ppb)\n{\n\t \n\t \n\n\ts64 max_scaled_ppm = div_s64((s64)PHASE_PULL_IN_MAX_PPB << 13, 125);\n\ts64 scaled_ppm = div_s64((s64)phase_pull_in_ppb << 13, 125);\n\n\tcurrent_ppm += scaled_ppm;\n\n\tif (current_ppm > max_scaled_ppm)\n\t\tcurrent_ppm = max_scaled_ppm;\n\telse if (current_ppm < -max_scaled_ppm)\n\t\tcurrent_ppm = -max_scaled_ppm;\n\n\treturn current_ppm;\n}\n\nstatic int do_phase_pull_in_sw(struct idtcm_channel *channel,\n\t\t\t       s32 delta_ns,\n\t\t\t       u32 max_ffo_ppb)\n{\n\ts32 current_ppm = channel->current_freq_scaled_ppm;\n\tu32 duration_ms = MSEC_PER_SEC;\n\ts32 delta_ppm;\n\ts32 ppb;\n\tint err;\n\n\t \n\tif (abs(delta_ns) < PHASE_PULL_IN_MIN_THRESHOLD_NS)\n\t\treturn 0;\n\n\tif (max_ffo_ppb == 0)\n\t\tmax_ffo_ppb = PHASE_PULL_IN_MAX_PPB;\n\n\t \n\tppb = delta_ns;\n\twhile (abs(ppb) > max_ffo_ppb) {\n\t\tduration_ms *= 2;\n\t\tppb /= 2;\n\t}\n\n\tdelta_ppm = phase_pull_in_scaled_ppm(current_ppm, ppb);\n\n\terr = _idtcm_adjfine(channel, delta_ppm);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tptp_schedule_worker(channel->ptp_clock,\n\t\t\t    msecs_to_jiffies(duration_ms) - 1);\n\n\tchannel->phase_pull_in = true;\n\n\treturn 0;\n}\n\nstatic int initialize_operating_mode_with_manual_reference(struct idtcm_channel *channel,\n\t\t\t\t\t\t\t   enum manual_reference ref)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\n\tchannel->mode = PTP_PLL_MODE_UNSUPPORTED;\n\tchannel->configure_write_frequency = configure_manual_reference_write_frequency;\n\tchannel->configure_write_phase = configure_manual_reference_write_phase;\n\tchannel->do_phase_pull_in = do_phase_pull_in_sw;\n\n\tswitch (ref) {\n\tcase MANU_REF_WRITE_PHASE:\n\t\tchannel->mode = PTP_PLL_MODE_WRITE_PHASE;\n\t\tbreak;\n\tcase MANU_REF_WRITE_FREQUENCY:\n\t\tchannel->mode = PTP_PLL_MODE_WRITE_FREQUENCY;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(idtcm->dev,\n\t\t\t \"Unsupported MANUAL_REFERENCE: 0x%02x\", ref);\n\t}\n\n\treturn 0;\n}\n\nstatic int initialize_operating_mode_with_pll_mode(struct idtcm_channel *channel,\n\t\t\t\t\t\t   enum pll_mode mode)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err = 0;\n\n\tchannel->mode = PTP_PLL_MODE_UNSUPPORTED;\n\tchannel->configure_write_frequency = configure_dpll_mode_write_frequency;\n\tchannel->configure_write_phase = configure_dpll_mode_write_phase;\n\tchannel->do_phase_pull_in = do_phase_pull_in_fw;\n\n\tswitch (mode) {\n\tcase  PLL_MODE_WRITE_PHASE:\n\t\tchannel->mode = PTP_PLL_MODE_WRITE_PHASE;\n\t\tbreak;\n\tcase PLL_MODE_WRITE_FREQUENCY:\n\t\tchannel->mode = PTP_PLL_MODE_WRITE_FREQUENCY;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(idtcm->dev,\n\t\t\t\"Unsupported PLL_MODE: 0x%02x\", mode);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int initialize_dco_operating_mode(struct idtcm_channel *channel)\n{\n\tenum manual_reference ref = MANU_REF_XO_DPLL;\n\tenum pll_mode mode = PLL_MODE_DISABLED;\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\n\tchannel->mode = PTP_PLL_MODE_UNSUPPORTED;\n\n\terr = idtcm_get_pll_mode(channel, &mode);\n\tif (err) {\n\t\tdev_err(idtcm->dev, \"Unable to read pll mode!\");\n\t\treturn err;\n\t}\n\n\tif (mode == PLL_MODE_PLL) {\n\t\terr = idtcm_get_manual_reference(channel, &ref);\n\t\tif (err) {\n\t\t\tdev_err(idtcm->dev, \"Unable to read manual reference!\");\n\t\t\treturn err;\n\t\t}\n\t\terr = initialize_operating_mode_with_manual_reference(channel, ref);\n\t} else {\n\t\terr = initialize_operating_mode_with_pll_mode(channel, mode);\n\t}\n\n\tif (channel->mode == PTP_PLL_MODE_WRITE_PHASE)\n\t\tchannel->configure_write_frequency(channel);\n\n\treturn err;\n}\n\n \n\n \nstatic s32 idtcm_getmaxphase(struct ptp_clock_info *ptp __always_unused)\n{\n\treturn MAX_ABS_WRITE_PHASE_NANOSECONDS;\n}\n\n \nstatic int _idtcm_adjphase(struct idtcm_channel *channel, s32 delta_ns)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\tu8 i;\n\tu8 buf[4] = {0};\n\ts32 phase_50ps;\n\n\tif (channel->mode != PTP_PLL_MODE_WRITE_PHASE) {\n\t\terr = channel->configure_write_phase(channel);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tphase_50ps = div_s64((s64)delta_ns * 1000, 50);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tbuf[i] = phase_50ps & 0xff;\n\t\tphase_50ps >>= 8;\n\t}\n\n\terr = idtcm_write(idtcm, channel->dpll_phase, DPLL_WR_PHASE,\n\t\t\t  buf, sizeof(buf));\n\n\treturn err;\n}\n\nstatic int _idtcm_adjfine(struct idtcm_channel *channel, long scaled_ppm)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tu8 i;\n\tint err;\n\tu8 buf[6] = {0};\n\ts64 fcw;\n\n\tif (channel->mode  != PTP_PLL_MODE_WRITE_FREQUENCY) {\n\t\terr = channel->configure_write_frequency(channel);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\n\t \n\tfcw = scaled_ppm * 244140625ULL;\n\n\tfcw = div_s64(fcw, 1776);\n\n\tfor (i = 0; i < 6; i++) {\n\t\tbuf[i] = fcw & 0xff;\n\t\tfcw >>= 8;\n\t}\n\n\terr = idtcm_write(idtcm, channel->dpll_freq, DPLL_WR_FREQ,\n\t\t\t  buf, sizeof(buf));\n\n\treturn err;\n}\n\nstatic int idtcm_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct idtcm_channel *channel = container_of(ptp, struct idtcm_channel, caps);\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\n\tmutex_lock(idtcm->lock);\n\terr = _idtcm_gettime_immediate(channel, ts);\n\tmutex_unlock(idtcm->lock);\n\n\tif (err)\n\t\tdev_err(idtcm->dev, \"Failed at line %d in %s!\",\n\t\t\t__LINE__, __func__);\n\n\treturn err;\n}\n\nstatic int idtcm_settime_deprecated(struct ptp_clock_info *ptp,\n\t\t\t\t    const struct timespec64 *ts)\n{\n\tstruct idtcm_channel *channel = container_of(ptp, struct idtcm_channel, caps);\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\n\tmutex_lock(idtcm->lock);\n\terr = _idtcm_settime_deprecated(channel, ts);\n\tmutex_unlock(idtcm->lock);\n\n\tif (err)\n\t\tdev_err(idtcm->dev,\n\t\t\t\"Failed at line %d in %s!\", __LINE__, __func__);\n\n\treturn err;\n}\n\nstatic int idtcm_settime(struct ptp_clock_info *ptp,\n\t\t\t const struct timespec64 *ts)\n{\n\tstruct idtcm_channel *channel = container_of(ptp, struct idtcm_channel, caps);\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\n\tmutex_lock(idtcm->lock);\n\terr = _idtcm_settime(channel, ts, SCSR_TOD_WR_TYPE_SEL_ABSOLUTE);\n\tmutex_unlock(idtcm->lock);\n\n\tif (err)\n\t\tdev_err(idtcm->dev,\n\t\t\t\"Failed at line %d in %s!\", __LINE__, __func__);\n\n\treturn err;\n}\n\nstatic int idtcm_adjtime_deprecated(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct idtcm_channel *channel = container_of(ptp, struct idtcm_channel, caps);\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\n\tmutex_lock(idtcm->lock);\n\terr = _idtcm_adjtime_deprecated(channel, delta);\n\tmutex_unlock(idtcm->lock);\n\n\tif (err)\n\t\tdev_err(idtcm->dev,\n\t\t\t\"Failed at line %d in %s!\", __LINE__, __func__);\n\n\treturn err;\n}\n\nstatic int idtcm_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct idtcm_channel *channel = container_of(ptp, struct idtcm_channel, caps);\n\tstruct idtcm *idtcm = channel->idtcm;\n\tstruct timespec64 ts;\n\tenum scsr_tod_write_type_sel type;\n\tint err;\n\n\tif (channel->phase_pull_in == true)\n\t\treturn -EBUSY;\n\n\tmutex_lock(idtcm->lock);\n\n\tif (abs(delta) < PHASE_PULL_IN_THRESHOLD_NS) {\n\t\terr = channel->do_phase_pull_in(channel, delta, 0);\n\t} else {\n\t\tif (delta >= 0) {\n\t\t\tts = ns_to_timespec64(delta);\n\t\t\ttype = SCSR_TOD_WR_TYPE_SEL_DELTA_PLUS;\n\t\t} else {\n\t\t\tts = ns_to_timespec64(-delta);\n\t\t\ttype = SCSR_TOD_WR_TYPE_SEL_DELTA_MINUS;\n\t\t}\n\t\terr = _idtcm_settime(channel, &ts, type);\n\t}\n\n\tmutex_unlock(idtcm->lock);\n\n\tif (err)\n\t\tdev_err(idtcm->dev,\n\t\t\t\"Failed at line %d in %s!\", __LINE__, __func__);\n\n\treturn err;\n}\n\nstatic int idtcm_adjphase(struct ptp_clock_info *ptp, s32 delta)\n{\n\tstruct idtcm_channel *channel = container_of(ptp, struct idtcm_channel, caps);\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\n\tmutex_lock(idtcm->lock);\n\terr = _idtcm_adjphase(channel, delta);\n\tmutex_unlock(idtcm->lock);\n\n\tif (err)\n\t\tdev_err(idtcm->dev,\n\t\t\t\"Failed at line %d in %s!\", __LINE__, __func__);\n\n\treturn err;\n}\n\nstatic int idtcm_adjfine(struct ptp_clock_info *ptp,  long scaled_ppm)\n{\n\tstruct idtcm_channel *channel = container_of(ptp, struct idtcm_channel, caps);\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err;\n\n\tif (channel->phase_pull_in == true)\n\t\treturn 0;\n\n\tif (scaled_ppm == channel->current_freq_scaled_ppm)\n\t\treturn 0;\n\n\tmutex_lock(idtcm->lock);\n\terr = _idtcm_adjfine(channel, scaled_ppm);\n\tmutex_unlock(idtcm->lock);\n\n\tif (err)\n\t\tdev_err(idtcm->dev,\n\t\t\t\"Failed at line %d in %s!\", __LINE__, __func__);\n\telse\n\t\tchannel->current_freq_scaled_ppm = scaled_ppm;\n\n\treturn err;\n}\n\nstatic int idtcm_enable(struct ptp_clock_info *ptp,\n\t\t\tstruct ptp_clock_request *rq, int on)\n{\n\tstruct idtcm_channel *channel = container_of(ptp, struct idtcm_channel, caps);\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err = -EOPNOTSUPP;\n\n\tmutex_lock(idtcm->lock);\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_PEROUT:\n\t\tif (!on)\n\t\t\terr = idtcm_perout_enable(channel, &rq->perout, false);\n\t\t \n\t\telse if (rq->perout.start.nsec || rq->perout.period.sec != 1 ||\n\t\t\t rq->perout.period.nsec)\n\t\t\terr = -ERANGE;\n\t\telse\n\t\t\terr = idtcm_perout_enable(channel, &rq->perout, true);\n\t\tbreak;\n\tcase PTP_CLK_REQ_EXTTS:\n\t\terr = idtcm_extts_enable(channel, rq, on);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(idtcm->lock);\n\n\tif (err)\n\t\tdev_err(channel->idtcm->dev,\n\t\t\t\"Failed in %s with err %d!\", __func__, err);\n\n\treturn err;\n}\n\nstatic int idtcm_enable_tod(struct idtcm_channel *channel)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tstruct timespec64 ts = {0, 0};\n\tu16 tod_cfg = IDTCM_FW_REG(idtcm->fw_ver, V520, TOD_CFG);\n\tu8 cfg;\n\tint err;\n\n\t \n\terr = idtcm_read(idtcm, channel->tod_n, tod_cfg, &cfg, sizeof(cfg));\n\tif (err)\n\t\treturn err;\n\n\tcfg |= TOD_ENABLE;\n\n\terr = idtcm_write(idtcm, channel->tod_n, tod_cfg, &cfg, sizeof(cfg));\n\tif (err)\n\t\treturn err;\n\n\tif (idtcm->fw_ver < V487)\n\t\treturn _idtcm_settime_deprecated(channel, &ts);\n\telse\n\t\treturn _idtcm_settime(channel, &ts,\n\t\t\t\t      SCSR_TOD_WR_TYPE_SEL_ABSOLUTE);\n}\n\nstatic void idtcm_set_version_info(struct idtcm *idtcm)\n{\n\tu8 major;\n\tu8 minor;\n\tu8 hotfix;\n\tu16 product_id;\n\tu8 hw_rev_id;\n\tu8 config_select;\n\n\tidtcm_read_major_release(idtcm, &major);\n\tidtcm_read_minor_release(idtcm, &minor);\n\tidtcm_read_hotfix_release(idtcm, &hotfix);\n\n\tidtcm_read_product_id(idtcm, &product_id);\n\tidtcm_read_hw_rev_id(idtcm, &hw_rev_id);\n\n\tidtcm_read_otp_scsr_config_select(idtcm, &config_select);\n\n\tsnprintf(idtcm->version, sizeof(idtcm->version), \"%u.%u.%u\",\n\t\t major, minor, hotfix);\n\n\tidtcm->fw_ver = idtcm_fw_version(idtcm->version);\n\n\tdev_info(idtcm->dev,\n\t\t \"%d.%d.%d, Id: 0x%04x  HW Rev: %d  OTP Config Select: %d\",\n\t\t major, minor, hotfix,\n\t\t product_id, hw_rev_id, config_select);\n}\n\nstatic int idtcm_verify_pin(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t    enum ptp_pin_function func, unsigned int chan)\n{\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_EXTTS:\n\t\tbreak;\n\tcase PTP_PF_PEROUT:\n\tcase PTP_PF_PHYSYNC:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic struct ptp_pin_desc pin_config[MAX_TOD][MAX_REF_CLK];\n\nstatic const struct ptp_clock_info idtcm_caps = {\n\t.owner\t\t= THIS_MODULE,\n\t.max_adj\t= 244000,\n\t.n_per_out\t= 12,\n\t.n_ext_ts\t= MAX_TOD,\n\t.n_pins\t\t= MAX_REF_CLK,\n\t.adjphase\t= &idtcm_adjphase,\n\t.getmaxphase\t= &idtcm_getmaxphase,\n\t.adjfine\t= &idtcm_adjfine,\n\t.adjtime\t= &idtcm_adjtime,\n\t.gettime64\t= &idtcm_gettime,\n\t.settime64\t= &idtcm_settime,\n\t.enable\t\t= &idtcm_enable,\n\t.verify\t\t= &idtcm_verify_pin,\n\t.do_aux_work\t= &idtcm_work_handler,\n};\n\nstatic const struct ptp_clock_info idtcm_caps_deprecated = {\n\t.owner\t\t= THIS_MODULE,\n\t.max_adj\t= 244000,\n\t.n_per_out\t= 12,\n\t.n_ext_ts\t= MAX_TOD,\n\t.n_pins\t\t= MAX_REF_CLK,\n\t.adjphase\t= &idtcm_adjphase,\n\t.getmaxphase    = &idtcm_getmaxphase,\n\t.adjfine\t= &idtcm_adjfine,\n\t.adjtime\t= &idtcm_adjtime_deprecated,\n\t.gettime64\t= &idtcm_gettime,\n\t.settime64\t= &idtcm_settime_deprecated,\n\t.enable\t\t= &idtcm_enable,\n\t.verify\t\t= &idtcm_verify_pin,\n\t.do_aux_work\t= &idtcm_work_handler,\n};\n\nstatic int configure_channel_pll(struct idtcm_channel *channel)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tint err = 0;\n\n\tswitch (channel->pll) {\n\tcase 0:\n\t\tchannel->dpll_freq = DPLL_FREQ_0;\n\t\tchannel->dpll_n = DPLL_0;\n\t\tchannel->hw_dpll_n = HW_DPLL_0;\n\t\tchannel->dpll_phase = DPLL_PHASE_0;\n\t\tchannel->dpll_ctrl_n = DPLL_CTRL_0;\n\t\tchannel->dpll_phase_pull_in = DPLL_PHASE_PULL_IN_0;\n\t\tbreak;\n\tcase 1:\n\t\tchannel->dpll_freq = DPLL_FREQ_1;\n\t\tchannel->dpll_n = DPLL_1;\n\t\tchannel->hw_dpll_n = HW_DPLL_1;\n\t\tchannel->dpll_phase = DPLL_PHASE_1;\n\t\tchannel->dpll_ctrl_n = DPLL_CTRL_1;\n\t\tchannel->dpll_phase_pull_in = DPLL_PHASE_PULL_IN_1;\n\t\tbreak;\n\tcase 2:\n\t\tchannel->dpll_freq = DPLL_FREQ_2;\n\t\tchannel->dpll_n = IDTCM_FW_REG(idtcm->fw_ver, V520, DPLL_2);\n\t\tchannel->hw_dpll_n = HW_DPLL_2;\n\t\tchannel->dpll_phase = DPLL_PHASE_2;\n\t\tchannel->dpll_ctrl_n = DPLL_CTRL_2;\n\t\tchannel->dpll_phase_pull_in = DPLL_PHASE_PULL_IN_2;\n\t\tbreak;\n\tcase 3:\n\t\tchannel->dpll_freq = DPLL_FREQ_3;\n\t\tchannel->dpll_n = DPLL_3;\n\t\tchannel->hw_dpll_n = HW_DPLL_3;\n\t\tchannel->dpll_phase = DPLL_PHASE_3;\n\t\tchannel->dpll_ctrl_n = DPLL_CTRL_3;\n\t\tchannel->dpll_phase_pull_in = DPLL_PHASE_PULL_IN_3;\n\t\tbreak;\n\tcase 4:\n\t\tchannel->dpll_freq = DPLL_FREQ_4;\n\t\tchannel->dpll_n = IDTCM_FW_REG(idtcm->fw_ver, V520, DPLL_4);\n\t\tchannel->hw_dpll_n = HW_DPLL_4;\n\t\tchannel->dpll_phase = DPLL_PHASE_4;\n\t\tchannel->dpll_ctrl_n = DPLL_CTRL_4;\n\t\tchannel->dpll_phase_pull_in = DPLL_PHASE_PULL_IN_4;\n\t\tbreak;\n\tcase 5:\n\t\tchannel->dpll_freq = DPLL_FREQ_5;\n\t\tchannel->dpll_n = DPLL_5;\n\t\tchannel->hw_dpll_n = HW_DPLL_5;\n\t\tchannel->dpll_phase = DPLL_PHASE_5;\n\t\tchannel->dpll_ctrl_n = DPLL_CTRL_5;\n\t\tchannel->dpll_phase_pull_in = DPLL_PHASE_PULL_IN_5;\n\t\tbreak;\n\tcase 6:\n\t\tchannel->dpll_freq = DPLL_FREQ_6;\n\t\tchannel->dpll_n = IDTCM_FW_REG(idtcm->fw_ver, V520, DPLL_6);\n\t\tchannel->hw_dpll_n = HW_DPLL_6;\n\t\tchannel->dpll_phase = DPLL_PHASE_6;\n\t\tchannel->dpll_ctrl_n = DPLL_CTRL_6;\n\t\tchannel->dpll_phase_pull_in = DPLL_PHASE_PULL_IN_6;\n\t\tbreak;\n\tcase 7:\n\t\tchannel->dpll_freq = DPLL_FREQ_7;\n\t\tchannel->dpll_n = DPLL_7;\n\t\tchannel->hw_dpll_n = HW_DPLL_7;\n\t\tchannel->dpll_phase = DPLL_PHASE_7;\n\t\tchannel->dpll_ctrl_n = DPLL_CTRL_7;\n\t\tchannel->dpll_phase_pull_in = DPLL_PHASE_PULL_IN_7;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\n \nstatic u32 idtcm_get_dco_delay(struct idtcm_channel *channel)\n{\n\tstruct idtcm *idtcm = channel->idtcm;\n\tu8 mbuf[8] = {0};\n\tu8 nbuf[2] = {0};\n\tu32 fodFreq;\n\tint err;\n\tu64 m;\n\tu16 n;\n\n\terr = idtcm_read(idtcm, channel->dpll_ctrl_n,\n\t\t\t DPLL_CTRL_DPLL_FOD_FREQ, mbuf, 6);\n\tif (err)\n\t\treturn 0;\n\n\terr = idtcm_read(idtcm, channel->dpll_ctrl_n,\n\t\t\t DPLL_CTRL_DPLL_FOD_FREQ + 6, nbuf, 2);\n\tif (err)\n\t\treturn 0;\n\n\tm = get_unaligned_le64(mbuf);\n\tn = get_unaligned_le16(nbuf);\n\n\tif (n == 0)\n\t\tn = 1;\n\n\tfodFreq = (u32)div_u64(m, n);\n\n\tif (fodFreq >= 500000000)\n\t\treturn (u32)div_u64(18 * (u64)NSEC_PER_SEC, fodFreq);\n\n\treturn 0;\n}\n\nstatic int configure_channel_tod(struct idtcm_channel *channel, u32 index)\n{\n\tenum fw_version fw_ver = channel->idtcm->fw_ver;\n\n\t \n\tswitch (index) {\n\tcase 0:\n\t\tchannel->tod_read_primary = IDTCM_FW_REG(fw_ver, V520, TOD_READ_PRIMARY_0);\n\t\tchannel->tod_read_secondary = IDTCM_FW_REG(fw_ver, V520, TOD_READ_SECONDARY_0);\n\t\tchannel->tod_write = IDTCM_FW_REG(fw_ver, V520, TOD_WRITE_0);\n\t\tchannel->tod_n = IDTCM_FW_REG(fw_ver, V520, TOD_0);\n\t\tchannel->sync_src = SYNC_SOURCE_DPLL0_TOD_PPS;\n\t\tbreak;\n\tcase 1:\n\t\tchannel->tod_read_primary = IDTCM_FW_REG(fw_ver, V520, TOD_READ_PRIMARY_1);\n\t\tchannel->tod_read_secondary = IDTCM_FW_REG(fw_ver, V520, TOD_READ_SECONDARY_1);\n\t\tchannel->tod_write = IDTCM_FW_REG(fw_ver, V520, TOD_WRITE_1);\n\t\tchannel->tod_n = IDTCM_FW_REG(fw_ver, V520, TOD_1);\n\t\tchannel->sync_src = SYNC_SOURCE_DPLL1_TOD_PPS;\n\t\tbreak;\n\tcase 2:\n\t\tchannel->tod_read_primary = IDTCM_FW_REG(fw_ver, V520, TOD_READ_PRIMARY_2);\n\t\tchannel->tod_read_secondary = IDTCM_FW_REG(fw_ver, V520, TOD_READ_SECONDARY_2);\n\t\tchannel->tod_write = IDTCM_FW_REG(fw_ver, V520, TOD_WRITE_2);\n\t\tchannel->tod_n = IDTCM_FW_REG(fw_ver, V520, TOD_2);\n\t\tchannel->sync_src = SYNC_SOURCE_DPLL2_TOD_PPS;\n\t\tbreak;\n\tcase 3:\n\t\tchannel->tod_read_primary = IDTCM_FW_REG(fw_ver, V520, TOD_READ_PRIMARY_3);\n\t\tchannel->tod_read_secondary = IDTCM_FW_REG(fw_ver, V520, TOD_READ_SECONDARY_3);\n\t\tchannel->tod_write = IDTCM_FW_REG(fw_ver, V520, TOD_WRITE_3);\n\t\tchannel->tod_n = IDTCM_FW_REG(fw_ver, V520, TOD_3);\n\t\tchannel->sync_src = SYNC_SOURCE_DPLL3_TOD_PPS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int idtcm_enable_channel(struct idtcm *idtcm, u32 index)\n{\n\tstruct idtcm_channel *channel;\n\tint err;\n\tint i;\n\n\tif (!(index < MAX_TOD))\n\t\treturn -EINVAL;\n\n\tchannel = &idtcm->channel[index];\n\n\tchannel->idtcm = idtcm;\n\tchannel->current_freq_scaled_ppm = 0;\n\n\t \n\terr = configure_channel_pll(channel);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = configure_channel_tod(channel, index);\n\tif (err)\n\t\treturn err;\n\n\tif (idtcm->fw_ver < V487)\n\t\tchannel->caps = idtcm_caps_deprecated;\n\telse\n\t\tchannel->caps = idtcm_caps;\n\n\tsnprintf(channel->caps.name, sizeof(channel->caps.name),\n\t\t \"IDT CM TOD%u\", index);\n\n\tchannel->caps.pin_config = pin_config[index];\n\n\tfor (i = 0; i < channel->caps.n_pins; ++i) {\n\t\tstruct ptp_pin_desc *ppd = &channel->caps.pin_config[i];\n\n\t\tsnprintf(ppd->name, sizeof(ppd->name), \"input_ref%d\", i);\n\t\tppd->index = i;\n\t\tppd->func = PTP_PF_NONE;\n\t\tppd->chan = index;\n\t}\n\n\terr = initialize_dco_operating_mode(channel);\n\tif (err)\n\t\treturn err;\n\n\terr = idtcm_enable_tod(channel);\n\tif (err) {\n\t\tdev_err(idtcm->dev,\n\t\t\t\"Failed at line %d in %s!\", __LINE__, __func__);\n\t\treturn err;\n\t}\n\n\tchannel->dco_delay = idtcm_get_dco_delay(channel);\n\n\tchannel->ptp_clock = ptp_clock_register(&channel->caps, NULL);\n\n\tif (IS_ERR(channel->ptp_clock)) {\n\t\terr = PTR_ERR(channel->ptp_clock);\n\t\tchannel->ptp_clock = NULL;\n\t\treturn err;\n\t}\n\n\tif (!channel->ptp_clock)\n\t\treturn -ENOTSUPP;\n\n\tdev_info(idtcm->dev, \"PLL%d registered as ptp%d\",\n\t\t index, channel->ptp_clock->index);\n\n\treturn 0;\n}\n\nstatic int idtcm_enable_extts_channel(struct idtcm *idtcm, u32 index)\n{\n\tstruct idtcm_channel *channel;\n\tint err;\n\n\tif (!(index < MAX_TOD))\n\t\treturn -EINVAL;\n\n\tchannel = &idtcm->channel[index];\n\tchannel->idtcm = idtcm;\n\n\t \n\terr = configure_channel_tod(channel, index);\n\tif (err)\n\t\treturn err;\n\n\tchannel->idtcm = idtcm;\n\n\treturn 0;\n}\n\nstatic void idtcm_extts_check(struct work_struct *work)\n{\n\tstruct idtcm *idtcm = container_of(work, struct idtcm, extts_work.work);\n\tstruct idtcm_channel *channel;\n\tu8 mask;\n\tint err;\n\tint i;\n\n\tif (idtcm->extts_mask == 0)\n\t\treturn;\n\n\tmutex_lock(idtcm->lock);\n\n\tfor (i = 0; i < MAX_TOD; i++) {\n\t\tmask = 1 << i;\n\n\t\tif ((idtcm->extts_mask & mask) == 0)\n\t\t\tcontinue;\n\n\t\terr = idtcm_extts_check_channel(idtcm, i);\n\n\t\tif (err == 0) {\n\t\t\t \n\t\t\tif (idtcm->extts_single_shot) {\n\t\t\t\tidtcm->extts_mask &= ~mask;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tchannel = &idtcm->channel[i];\n\t\t\t\tarm_tod_read_trig_sel_refclk(channel, channel->refn);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (idtcm->extts_mask)\n\t\tschedule_delayed_work(&idtcm->extts_work,\n\t\t\t\t      msecs_to_jiffies(EXTTS_PERIOD_MS));\n\n\tmutex_unlock(idtcm->lock);\n}\n\nstatic void ptp_clock_unregister_all(struct idtcm *idtcm)\n{\n\tu8 i;\n\tstruct idtcm_channel *channel;\n\n\tfor (i = 0; i < MAX_TOD; i++) {\n\t\tchannel = &idtcm->channel[i];\n\t\tif (channel->ptp_clock)\n\t\t\tptp_clock_unregister(channel->ptp_clock);\n\t}\n}\n\nstatic void set_default_masks(struct idtcm *idtcm)\n{\n\tidtcm->tod_mask = DEFAULT_TOD_MASK;\n\tidtcm->extts_mask = 0;\n\n\tidtcm->channel[0].tod = 0;\n\tidtcm->channel[1].tod = 1;\n\tidtcm->channel[2].tod = 2;\n\tidtcm->channel[3].tod = 3;\n\n\tidtcm->channel[0].pll = DEFAULT_TOD0_PTP_PLL;\n\tidtcm->channel[1].pll = DEFAULT_TOD1_PTP_PLL;\n\tidtcm->channel[2].pll = DEFAULT_TOD2_PTP_PLL;\n\tidtcm->channel[3].pll = DEFAULT_TOD3_PTP_PLL;\n\n\tidtcm->channel[0].output_mask = DEFAULT_OUTPUT_MASK_PLL0;\n\tidtcm->channel[1].output_mask = DEFAULT_OUTPUT_MASK_PLL1;\n\tidtcm->channel[2].output_mask = DEFAULT_OUTPUT_MASK_PLL2;\n\tidtcm->channel[3].output_mask = DEFAULT_OUTPUT_MASK_PLL3;\n}\n\nstatic int idtcm_probe(struct platform_device *pdev)\n{\n\tstruct rsmu_ddata *ddata = dev_get_drvdata(pdev->dev.parent);\n\tstruct idtcm *idtcm;\n\tint err;\n\tu8 i;\n\n\tidtcm = devm_kzalloc(&pdev->dev, sizeof(struct idtcm), GFP_KERNEL);\n\n\tif (!idtcm)\n\t\treturn -ENOMEM;\n\n\tidtcm->dev = &pdev->dev;\n\tidtcm->mfd = pdev->dev.parent;\n\tidtcm->lock = &ddata->lock;\n\tidtcm->regmap = ddata->regmap;\n\tidtcm->calculate_overhead_flag = 0;\n\n\tINIT_DELAYED_WORK(&idtcm->extts_work, idtcm_extts_check);\n\n\tset_default_masks(idtcm);\n\n\tmutex_lock(idtcm->lock);\n\n\tidtcm_set_version_info(idtcm);\n\n\terr = idtcm_load_firmware(idtcm, &pdev->dev);\n\n\tif (err)\n\t\tdev_warn(idtcm->dev, \"loading firmware failed with %d\", err);\n\n\twait_for_chip_ready(idtcm);\n\n\tif (idtcm->tod_mask) {\n\t\tfor (i = 0; i < MAX_TOD; i++) {\n\t\t\tif (idtcm->tod_mask & (1 << i))\n\t\t\t\terr = idtcm_enable_channel(idtcm, i);\n\t\t\telse\n\t\t\t\terr = idtcm_enable_extts_channel(idtcm, i);\n\t\t\tif (err) {\n\t\t\t\tdev_err(idtcm->dev,\n\t\t\t\t\t\"idtcm_enable_channel %d failed!\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_err(idtcm->dev,\n\t\t\t\"no PLLs flagged as PHCs, nothing to do\");\n\t\terr = -ENODEV;\n\t}\n\n\tmutex_unlock(idtcm->lock);\n\n\tif (err) {\n\t\tptp_clock_unregister_all(idtcm);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, idtcm);\n\n\treturn 0;\n}\n\nstatic int idtcm_remove(struct platform_device *pdev)\n{\n\tstruct idtcm *idtcm = platform_get_drvdata(pdev);\n\n\tidtcm->extts_mask = 0;\n\tptp_clock_unregister_all(idtcm);\n\tcancel_delayed_work_sync(&idtcm->extts_work);\n\n\treturn 0;\n}\n\nstatic struct platform_driver idtcm_driver = {\n\t.driver = {\n\t\t.name = \"8a3400x-phc\",\n\t},\n\t.probe = idtcm_probe,\n\t.remove\t= idtcm_remove,\n};\n\nmodule_platform_driver(idtcm_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}