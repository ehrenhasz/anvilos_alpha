{
  "module_name": "ptp_kvm_x86.c",
  "hash_id": "da60bd40d290f282f24c6526827bae9299065849c23c5d40ea990548e0b21f21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_kvm_x86.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <asm/pvclock.h>\n#include <asm/kvmclock.h>\n#include <linux/module.h>\n#include <uapi/asm/kvm_para.h>\n#include <uapi/linux/kvm_para.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/ptp_kvm.h>\n#include <linux/set_memory.h>\n\nstatic phys_addr_t clock_pair_gpa;\nstatic struct kvm_clock_pairing clock_pair_glbl;\nstatic struct kvm_clock_pairing *clock_pair;\n\nint kvm_arch_ptp_init(void)\n{\n\tstruct page *p;\n\tlong ret;\n\n\tif (!kvm_para_available())\n\t\treturn -ENODEV;\n\n\tif (cc_platform_has(CC_ATTR_GUEST_MEM_ENCRYPT)) {\n\t\tp = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\n\t\tclock_pair = page_address(p);\n\t\tret = set_memory_decrypted((unsigned long)clock_pair, 1);\n\t\tif (ret) {\n\t\t\t__free_page(p);\n\t\t\tclock_pair = NULL;\n\t\t\tgoto nofree;\n\t\t}\n\t} else {\n\t\tclock_pair = &clock_pair_glbl;\n\t}\n\n\tclock_pair_gpa = slow_virt_to_phys(clock_pair);\n\tif (!pvclock_get_pvti_cpu0_va()) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tret = kvm_hypercall2(KVM_HC_CLOCK_PAIRING, clock_pair_gpa,\n\t\t\t     KVM_CLOCK_PAIRING_WALLCLOCK);\n\tif (ret == -KVM_ENOSYS) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\treturn ret;\n\nerr:\n\tkvm_arch_ptp_exit();\nnofree:\n\treturn ret;\n}\n\nvoid kvm_arch_ptp_exit(void)\n{\n\tif (cc_platform_has(CC_ATTR_GUEST_MEM_ENCRYPT)) {\n\t\tWARN_ON(set_memory_encrypted((unsigned long)clock_pair, 1));\n\t\tfree_page((unsigned long)clock_pair);\n\t\tclock_pair = NULL;\n\t}\n}\n\nint kvm_arch_ptp_get_clock(struct timespec64 *ts)\n{\n\tlong ret;\n\n\tret = kvm_hypercall2(KVM_HC_CLOCK_PAIRING,\n\t\t\t     clock_pair_gpa,\n\t\t\t     KVM_CLOCK_PAIRING_WALLCLOCK);\n\tif (ret != 0) {\n\t\tpr_err_ratelimited(\"clock offset hypercall ret %lu\\n\", ret);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tts->tv_sec = clock_pair->sec;\n\tts->tv_nsec = clock_pair->nsec;\n\n\treturn 0;\n}\n\nint kvm_arch_ptp_get_crosststamp(u64 *cycle, struct timespec64 *tspec,\n\t\t\t      struct clocksource **cs)\n{\n\tstruct pvclock_vcpu_time_info *src;\n\tunsigned int version;\n\tlong ret;\n\n\tsrc = this_cpu_pvti();\n\n\tdo {\n\t\t \n\t\tversion = pvclock_read_begin(src);\n\n\t\tret = kvm_hypercall2(KVM_HC_CLOCK_PAIRING,\n\t\t\t\t     clock_pair_gpa,\n\t\t\t\t     KVM_CLOCK_PAIRING_WALLCLOCK);\n\t\tif (ret != 0) {\n\t\t\tpr_err_ratelimited(\"clock pairing hypercall ret %lu\\n\", ret);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\ttspec->tv_sec = clock_pair->sec;\n\t\ttspec->tv_nsec = clock_pair->nsec;\n\t\t*cycle = __pvclock_read_cycles(src, clock_pair->tsc);\n\t} while (pvclock_read_retry(src, version));\n\n\t*cs = &kvm_clock;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}