{
  "module_name": "ptp_kvm_common.c",
  "hash_id": "0c98b73af80e6592698b32631bdbefb524203fdd7cd1eee12430d83f4f8cf660",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_kvm_common.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/ptp_kvm.h>\n#include <uapi/linux/kvm_para.h>\n#include <asm/kvm_para.h>\n#include <uapi/asm/kvm_para.h>\n\n#include <linux/ptp_clock_kernel.h>\n\nstruct kvm_ptp_clock {\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info caps;\n};\n\nstatic DEFINE_SPINLOCK(kvm_ptp_lock);\n\nstatic int ptp_kvm_get_time_fn(ktime_t *device_time,\n\t\t\t       struct system_counterval_t *system_counter,\n\t\t\t       void *ctx)\n{\n\tlong ret;\n\tu64 cycle;\n\tstruct timespec64 tspec;\n\tstruct clocksource *cs;\n\n\tspin_lock(&kvm_ptp_lock);\n\n\tpreempt_disable_notrace();\n\tret = kvm_arch_ptp_get_crosststamp(&cycle, &tspec, &cs);\n\tif (ret) {\n\t\tspin_unlock(&kvm_ptp_lock);\n\t\tpreempt_enable_notrace();\n\t\treturn ret;\n\t}\n\n\tpreempt_enable_notrace();\n\n\tsystem_counter->cycles = cycle;\n\tsystem_counter->cs = cs;\n\n\t*device_time = timespec64_to_ktime(tspec);\n\n\tspin_unlock(&kvm_ptp_lock);\n\n\treturn 0;\n}\n\nstatic int ptp_kvm_getcrosststamp(struct ptp_clock_info *ptp,\n\t\t\t\t  struct system_device_crosststamp *xtstamp)\n{\n\treturn get_device_system_crosststamp(ptp_kvm_get_time_fn, NULL,\n\t\t\t\t\t     NULL, xtstamp);\n}\n\n \n\nstatic int ptp_kvm_adjfine(struct ptp_clock_info *ptp, long delta)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ptp_kvm_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ptp_kvm_settime(struct ptp_clock_info *ptp,\n\t\t\t   const struct timespec64 *ts)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ptp_kvm_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tlong ret;\n\tstruct timespec64 tspec;\n\n\tspin_lock(&kvm_ptp_lock);\n\n\tret = kvm_arch_ptp_get_clock(&tspec);\n\tif (ret) {\n\t\tspin_unlock(&kvm_ptp_lock);\n\t\treturn ret;\n\t}\n\n\tspin_unlock(&kvm_ptp_lock);\n\n\tmemcpy(ts, &tspec, sizeof(struct timespec64));\n\n\treturn 0;\n}\n\nstatic int ptp_kvm_enable(struct ptp_clock_info *ptp,\n\t\t\t  struct ptp_clock_request *rq, int on)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct ptp_clock_info ptp_kvm_caps = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"KVM virtual PTP\",\n\t.max_adj\t= 0,\n\t.n_ext_ts\t= 0,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 0,\n\t.adjfine\t= ptp_kvm_adjfine,\n\t.adjtime\t= ptp_kvm_adjtime,\n\t.gettime64\t= ptp_kvm_gettime,\n\t.settime64\t= ptp_kvm_settime,\n\t.enable\t\t= ptp_kvm_enable,\n\t.getcrosststamp = ptp_kvm_getcrosststamp,\n};\n\n \n\nstatic struct kvm_ptp_clock kvm_ptp_clock;\n\nstatic void __exit ptp_kvm_exit(void)\n{\n\tptp_clock_unregister(kvm_ptp_clock.ptp_clock);\n\tkvm_arch_ptp_exit();\n}\n\nstatic int __init ptp_kvm_init(void)\n{\n\tlong ret;\n\n\tret = kvm_arch_ptp_init();\n\tif (ret) {\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\tpr_err(\"fail to initialize ptp_kvm\");\n\t\treturn ret;\n\t}\n\n\tkvm_ptp_clock.caps = ptp_kvm_caps;\n\n\tkvm_ptp_clock.ptp_clock = ptp_clock_register(&kvm_ptp_clock.caps, NULL);\n\n\treturn PTR_ERR_OR_ZERO(kvm_ptp_clock.ptp_clock);\n}\n\nmodule_init(ptp_kvm_init);\nmodule_exit(ptp_kvm_exit);\n\nMODULE_AUTHOR(\"Marcelo Tosatti <mtosatti@redhat.com>\");\nMODULE_DESCRIPTION(\"PTP clock using KVMCLOCK\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}