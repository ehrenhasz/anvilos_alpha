{
  "module_name": "ptp_sysfs.c",
  "hash_id": "379ecef1e7897d3f73c8c24401cf5f434fe648b2efac93ef5c27e838360664f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_sysfs.c",
  "human_readable_source": "\n \n#include <linux/capability.h>\n#include <linux/slab.h>\n\n#include \"ptp_private.h\"\n\nstatic ssize_t clock_name_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *page)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\treturn sysfs_emit(page, \"%s\\n\", ptp->info->name);\n}\nstatic DEVICE_ATTR_RO(clock_name);\n\nstatic ssize_t max_phase_adjustment_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *page)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\n\treturn snprintf(page, PAGE_SIZE - 1, \"%d\\n\",\n\t\t\tptp->info->getmaxphase(ptp->info));\n}\nstatic DEVICE_ATTR_RO(max_phase_adjustment);\n\n#define PTP_SHOW_INT(name, var)\t\t\t\t\t\t\\\nstatic ssize_t var##_show(struct device *dev,\t\t\t\t\\\n\t\t\t   struct device_attribute *attr, char *page)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\t\t\t\\\n\treturn snprintf(page, PAGE_SIZE-1, \"%d\\n\", ptp->info->var);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(name, 0444, var##_show, NULL);\n\nPTP_SHOW_INT(max_adjustment, max_adj);\nPTP_SHOW_INT(n_alarms, n_alarm);\nPTP_SHOW_INT(n_external_timestamps, n_ext_ts);\nPTP_SHOW_INT(n_periodic_outputs, n_per_out);\nPTP_SHOW_INT(n_programmable_pins, n_pins);\nPTP_SHOW_INT(pps_available, pps);\n\nstatic ssize_t extts_enable_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tstruct ptp_clock_info *ops = ptp->info;\n\tstruct ptp_clock_request req = { .type = PTP_CLK_REQ_EXTTS };\n\tint cnt, enable;\n\tint err = -EINVAL;\n\n\tcnt = sscanf(buf, \"%u %d\", &req.extts.index, &enable);\n\tif (cnt != 2)\n\t\tgoto out;\n\tif (req.extts.index >= ops->n_ext_ts)\n\t\tgoto out;\n\n\terr = ops->enable(ops, &req, enable ? 1 : 0);\n\tif (err)\n\t\tgoto out;\n\n\treturn count;\nout:\n\treturn err;\n}\nstatic DEVICE_ATTR(extts_enable, 0220, NULL, extts_enable_store);\n\nstatic ssize_t extts_fifo_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *page)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tstruct timestamp_event_queue *queue = &ptp->tsevq;\n\tstruct ptp_extts_event event;\n\tunsigned long flags;\n\tsize_t qcnt;\n\tint cnt = 0;\n\n\tmemset(&event, 0, sizeof(event));\n\n\tif (mutex_lock_interruptible(&ptp->tsevq_mux))\n\t\treturn -ERESTARTSYS;\n\n\tspin_lock_irqsave(&queue->lock, flags);\n\tqcnt = queue_cnt(queue);\n\tif (qcnt) {\n\t\tevent = queue->buf[queue->head];\n\t\t \n\t\tWRITE_ONCE(queue->head, (queue->head + 1) % PTP_MAX_TIMESTAMPS);\n\t}\n\tspin_unlock_irqrestore(&queue->lock, flags);\n\n\tif (!qcnt)\n\t\tgoto out;\n\n\tcnt = snprintf(page, PAGE_SIZE, \"%u %lld %u\\n\",\n\t\t       event.index, event.t.sec, event.t.nsec);\nout:\n\tmutex_unlock(&ptp->tsevq_mux);\n\treturn cnt;\n}\nstatic DEVICE_ATTR(fifo, 0444, extts_fifo_show, NULL);\n\nstatic ssize_t period_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tstruct ptp_clock_info *ops = ptp->info;\n\tstruct ptp_clock_request req = { .type = PTP_CLK_REQ_PEROUT };\n\tint cnt, enable, err = -EINVAL;\n\n\tcnt = sscanf(buf, \"%u %lld %u %lld %u\", &req.perout.index,\n\t\t     &req.perout.start.sec, &req.perout.start.nsec,\n\t\t     &req.perout.period.sec, &req.perout.period.nsec);\n\tif (cnt != 5)\n\t\tgoto out;\n\tif (req.perout.index >= ops->n_per_out)\n\t\tgoto out;\n\n\tenable = req.perout.period.sec || req.perout.period.nsec;\n\terr = ops->enable(ops, &req, enable);\n\tif (err)\n\t\tgoto out;\n\n\treturn count;\nout:\n\treturn err;\n}\nstatic DEVICE_ATTR(period, 0220, NULL, period_store);\n\nstatic ssize_t pps_enable_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tstruct ptp_clock_info *ops = ptp->info;\n\tstruct ptp_clock_request req = { .type = PTP_CLK_REQ_PPS };\n\tint cnt, enable;\n\tint err = -EINVAL;\n\n\tif (!capable(CAP_SYS_TIME))\n\t\treturn -EPERM;\n\n\tcnt = sscanf(buf, \"%d\", &enable);\n\tif (cnt != 1)\n\t\tgoto out;\n\n\terr = ops->enable(ops, &req, enable ? 1 : 0);\n\tif (err)\n\t\tgoto out;\n\n\treturn count;\nout:\n\treturn err;\n}\nstatic DEVICE_ATTR(pps_enable, 0220, NULL, pps_enable_store);\n\nstatic int unregister_vclock(struct device *dev, void *data)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tstruct ptp_clock_info *info = ptp->info;\n\tstruct ptp_vclock *vclock;\n\tu32 *num = data;\n\n\tvclock = info_to_vclock(info);\n\tdev_info(dev->parent, \"delete virtual clock ptp%d\\n\",\n\t\t vclock->clock->index);\n\n\tptp_vclock_unregister(vclock);\n\t(*num)--;\n\n\t \n\tif (*num == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic ssize_t n_vclocks_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *page)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tssize_t size;\n\n\tif (mutex_lock_interruptible(&ptp->n_vclocks_mux))\n\t\treturn -ERESTARTSYS;\n\n\tsize = snprintf(page, PAGE_SIZE - 1, \"%u\\n\", ptp->n_vclocks);\n\n\tmutex_unlock(&ptp->n_vclocks_mux);\n\n\treturn size;\n}\n\nstatic ssize_t n_vclocks_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tstruct ptp_vclock *vclock;\n\tint err = -EINVAL;\n\tu32 num, i;\n\n\tif (kstrtou32(buf, 0, &num))\n\t\treturn err;\n\n\tif (mutex_lock_interruptible(&ptp->n_vclocks_mux))\n\t\treturn -ERESTARTSYS;\n\n\tif (num > ptp->max_vclocks) {\n\t\tdev_err(dev, \"max value is %d\\n\", ptp->max_vclocks);\n\t\tgoto out;\n\t}\n\n\t \n\tif (num > ptp->n_vclocks) {\n\t\tfor (i = 0; i < num - ptp->n_vclocks; i++) {\n\t\t\tvclock = ptp_vclock_register(ptp);\n\t\t\tif (!vclock)\n\t\t\t\tgoto out;\n\n\t\t\t*(ptp->vclock_index + ptp->n_vclocks + i) =\n\t\t\t\tvclock->clock->index;\n\n\t\t\tdev_info(dev, \"new virtual clock ptp%d\\n\",\n\t\t\t\t vclock->clock->index);\n\t\t}\n\t}\n\n\t \n\tif (num < ptp->n_vclocks) {\n\t\ti = ptp->n_vclocks - num;\n\t\tdevice_for_each_child_reverse(dev, &i,\n\t\t\t\t\t      unregister_vclock);\n\n\t\tfor (i = 1; i <= ptp->n_vclocks - num; i++)\n\t\t\t*(ptp->vclock_index + ptp->n_vclocks - i) = -1;\n\t}\n\n\t \n\tif (!ptp->has_cycles) {\n\t\tif (num == 0)\n\t\t\tdev_info(dev, \"only physical clock in use now\\n\");\n\t\telse\n\t\t\tdev_info(dev, \"guarantee physical clock free running\\n\");\n\t}\n\n\tptp->n_vclocks = num;\n\tmutex_unlock(&ptp->n_vclocks_mux);\n\n\treturn count;\nout:\n\tmutex_unlock(&ptp->n_vclocks_mux);\n\treturn err;\n}\nstatic DEVICE_ATTR_RW(n_vclocks);\n\nstatic ssize_t max_vclocks_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *page)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tssize_t size;\n\n\tsize = snprintf(page, PAGE_SIZE - 1, \"%u\\n\", ptp->max_vclocks);\n\n\treturn size;\n}\n\nstatic ssize_t max_vclocks_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tunsigned int *vclock_index;\n\tint err = -EINVAL;\n\tsize_t size;\n\tu32 max;\n\n\tif (kstrtou32(buf, 0, &max) || max == 0)\n\t\treturn -EINVAL;\n\n\tif (max == ptp->max_vclocks)\n\t\treturn count;\n\n\tif (mutex_lock_interruptible(&ptp->n_vclocks_mux))\n\t\treturn -ERESTARTSYS;\n\n\tif (max < ptp->n_vclocks)\n\t\tgoto out;\n\n\tsize = sizeof(int) * max;\n\tvclock_index = kzalloc(size, GFP_KERNEL);\n\tif (!vclock_index) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsize = sizeof(int) * ptp->n_vclocks;\n\tmemcpy(vclock_index, ptp->vclock_index, size);\n\n\tkfree(ptp->vclock_index);\n\tptp->vclock_index = vclock_index;\n\tptp->max_vclocks = max;\n\n\tmutex_unlock(&ptp->n_vclocks_mux);\n\n\treturn count;\nout:\n\tmutex_unlock(&ptp->n_vclocks_mux);\n\treturn err;\n}\nstatic DEVICE_ATTR_RW(max_vclocks);\n\nstatic struct attribute *ptp_attrs[] = {\n\t&dev_attr_clock_name.attr,\n\n\t&dev_attr_max_adjustment.attr,\n\t&dev_attr_max_phase_adjustment.attr,\n\t&dev_attr_n_alarms.attr,\n\t&dev_attr_n_external_timestamps.attr,\n\t&dev_attr_n_periodic_outputs.attr,\n\t&dev_attr_n_programmable_pins.attr,\n\t&dev_attr_pps_available.attr,\n\n\t&dev_attr_extts_enable.attr,\n\t&dev_attr_fifo.attr,\n\t&dev_attr_period.attr,\n\t&dev_attr_pps_enable.attr,\n\t&dev_attr_n_vclocks.attr,\n\t&dev_attr_max_vclocks.attr,\n\tNULL\n};\n\nstatic umode_t ptp_is_attribute_visible(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tstruct ptp_clock_info *info = ptp->info;\n\tumode_t mode = attr->mode;\n\n\tif (attr == &dev_attr_extts_enable.attr ||\n\t    attr == &dev_attr_fifo.attr) {\n\t\tif (!info->n_ext_ts)\n\t\t\tmode = 0;\n\t} else if (attr == &dev_attr_period.attr) {\n\t\tif (!info->n_per_out)\n\t\t\tmode = 0;\n\t} else if (attr == &dev_attr_pps_enable.attr) {\n\t\tif (!info->pps)\n\t\t\tmode = 0;\n\t} else if (attr == &dev_attr_n_vclocks.attr ||\n\t\t   attr == &dev_attr_max_vclocks.attr) {\n\t\tif (ptp->is_virtual_clock)\n\t\t\tmode = 0;\n\t} else if (attr == &dev_attr_max_phase_adjustment.attr) {\n\t\tif (!info->adjphase || !info->getmaxphase)\n\t\t\tmode = 0;\n\t}\n\n\treturn mode;\n}\n\nstatic const struct attribute_group ptp_group = {\n\t.is_visible\t= ptp_is_attribute_visible,\n\t.attrs\t\t= ptp_attrs,\n};\n\nconst struct attribute_group *ptp_groups[] = {\n\t&ptp_group,\n\tNULL\n};\n\nstatic int ptp_pin_name2index(struct ptp_clock *ptp, const char *name)\n{\n\tint i;\n\tfor (i = 0; i < ptp->info->n_pins; i++) {\n\t\tif (!strcmp(ptp->info->pin_config[i].name, name))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nstatic ssize_t ptp_pin_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *page)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tunsigned int func, chan;\n\tint index;\n\n\tindex = ptp_pin_name2index(ptp, attr->attr.name);\n\tif (index < 0)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&ptp->pincfg_mux))\n\t\treturn -ERESTARTSYS;\n\n\tfunc = ptp->info->pin_config[index].func;\n\tchan = ptp->info->pin_config[index].chan;\n\n\tmutex_unlock(&ptp->pincfg_mux);\n\n\treturn sysfs_emit(page, \"%u %u\\n\", func, chan);\n}\n\nstatic ssize_t ptp_pin_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tunsigned int func, chan;\n\tint cnt, err, index;\n\n\tcnt = sscanf(buf, \"%u %u\", &func, &chan);\n\tif (cnt != 2)\n\t\treturn -EINVAL;\n\n\tindex = ptp_pin_name2index(ptp, attr->attr.name);\n\tif (index < 0)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&ptp->pincfg_mux))\n\t\treturn -ERESTARTSYS;\n\terr = ptp_set_pinfunc(ptp, index, func, chan);\n\tmutex_unlock(&ptp->pincfg_mux);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nint ptp_populate_pin_groups(struct ptp_clock *ptp)\n{\n\tstruct ptp_clock_info *info = ptp->info;\n\tint err = -ENOMEM, i, n_pins = info->n_pins;\n\n\tif (!n_pins)\n\t\treturn 0;\n\n\tptp->pin_dev_attr = kcalloc(n_pins, sizeof(*ptp->pin_dev_attr),\n\t\t\t\t    GFP_KERNEL);\n\tif (!ptp->pin_dev_attr)\n\t\tgoto no_dev_attr;\n\n\tptp->pin_attr = kcalloc(1 + n_pins, sizeof(*ptp->pin_attr), GFP_KERNEL);\n\tif (!ptp->pin_attr)\n\t\tgoto no_pin_attr;\n\n\tfor (i = 0; i < n_pins; i++) {\n\t\tstruct device_attribute *da = &ptp->pin_dev_attr[i];\n\t\tsysfs_attr_init(&da->attr);\n\t\tda->attr.name = info->pin_config[i].name;\n\t\tda->attr.mode = 0644;\n\t\tda->show = ptp_pin_show;\n\t\tda->store = ptp_pin_store;\n\t\tptp->pin_attr[i] = &da->attr;\n\t}\n\n\tptp->pin_attr_group.name = \"pins\";\n\tptp->pin_attr_group.attrs = ptp->pin_attr;\n\n\tptp->pin_attr_groups[0] = &ptp->pin_attr_group;\n\n\treturn 0;\n\nno_pin_attr:\n\tkfree(ptp->pin_dev_attr);\nno_dev_attr:\n\treturn err;\n}\n\nvoid ptp_cleanup_pin_groups(struct ptp_clock *ptp)\n{\n\tkfree(ptp->pin_attr);\n\tkfree(ptp->pin_dev_attr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}