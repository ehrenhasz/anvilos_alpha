{
  "module_name": "ptp_mock.c",
  "hash_id": "2c64270f27dbfa71983833a089f464b4564ce4de7400a70e23a9371348c1d724",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_mock.c",
  "human_readable_source": "\n \n\n#include <linux/ptp_clock_kernel.h>\n#include <linux/ptp_mock.h>\n#include <linux/timecounter.h>\n\n \n#define MOCK_PHC_MAX_ADJ_PPB\t\t32000000\n \n#define MOCK_PHC_CC_SHIFT\t\t31\n#define MOCK_PHC_CC_MULT\t\t(1 << MOCK_PHC_CC_SHIFT)\n#define MOCK_PHC_FADJ_SHIFT\t\t9\n#define MOCK_PHC_FADJ_DENOMINATOR\t15625ULL\n\n \n#define MOCK_PHC_REFRESH_INTERVAL\t(HZ * 5)\n\n#define info_to_phc(d) container_of((d), struct mock_phc, info)\n\nstruct mock_phc {\n\tstruct ptp_clock_info info;\n\tstruct ptp_clock *clock;\n\tstruct timecounter tc;\n\tstruct cyclecounter cc;\n\tspinlock_t lock;\n};\n\nstatic u64 mock_phc_cc_read(const struct cyclecounter *cc)\n{\n\treturn ktime_get_raw_ns();\n}\n\nstatic int mock_phc_adjfine(struct ptp_clock_info *info, long scaled_ppm)\n{\n\tstruct mock_phc *phc = info_to_phc(info);\n\ts64 adj;\n\n\tadj = (s64)scaled_ppm << MOCK_PHC_FADJ_SHIFT;\n\tadj = div_s64(adj, MOCK_PHC_FADJ_DENOMINATOR);\n\n\tspin_lock(&phc->lock);\n\ttimecounter_read(&phc->tc);\n\tphc->cc.mult = MOCK_PHC_CC_MULT + adj;\n\tspin_unlock(&phc->lock);\n\n\treturn 0;\n}\n\nstatic int mock_phc_adjtime(struct ptp_clock_info *info, s64 delta)\n{\n\tstruct mock_phc *phc = info_to_phc(info);\n\n\tspin_lock(&phc->lock);\n\ttimecounter_adjtime(&phc->tc, delta);\n\tspin_unlock(&phc->lock);\n\n\treturn 0;\n}\n\nstatic int mock_phc_settime64(struct ptp_clock_info *info,\n\t\t\t      const struct timespec64 *ts)\n{\n\tstruct mock_phc *phc = info_to_phc(info);\n\tu64 ns = timespec64_to_ns(ts);\n\n\tspin_lock(&phc->lock);\n\ttimecounter_init(&phc->tc, &phc->cc, ns);\n\tspin_unlock(&phc->lock);\n\n\treturn 0;\n}\n\nstatic int mock_phc_gettime64(struct ptp_clock_info *info, struct timespec64 *ts)\n{\n\tstruct mock_phc *phc = info_to_phc(info);\n\tu64 ns;\n\n\tspin_lock(&phc->lock);\n\tns = timecounter_read(&phc->tc);\n\tspin_unlock(&phc->lock);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic long mock_phc_refresh(struct ptp_clock_info *info)\n{\n\tstruct timespec64 ts;\n\n\tmock_phc_gettime64(info, &ts);\n\n\treturn MOCK_PHC_REFRESH_INTERVAL;\n}\n\nint mock_phc_index(struct mock_phc *phc)\n{\n\treturn ptp_clock_index(phc->clock);\n}\nEXPORT_SYMBOL_GPL(mock_phc_index);\n\nstruct mock_phc *mock_phc_create(struct device *dev)\n{\n\tstruct mock_phc *phc;\n\tint err;\n\n\tphc = kzalloc(sizeof(*phc), GFP_KERNEL);\n\tif (!phc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tphc->info = (struct ptp_clock_info) {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"Mock-up PTP clock\",\n\t\t.max_adj\t= MOCK_PHC_MAX_ADJ_PPB,\n\t\t.adjfine\t= mock_phc_adjfine,\n\t\t.adjtime\t= mock_phc_adjtime,\n\t\t.gettime64\t= mock_phc_gettime64,\n\t\t.settime64\t= mock_phc_settime64,\n\t\t.do_aux_work\t= mock_phc_refresh,\n\t};\n\n\tphc->cc = (struct cyclecounter) {\n\t\t.read\t= mock_phc_cc_read,\n\t\t.mask\t= CYCLECOUNTER_MASK(64),\n\t\t.mult\t= MOCK_PHC_CC_MULT,\n\t\t.shift\t= MOCK_PHC_CC_SHIFT,\n\t};\n\n\tspin_lock_init(&phc->lock);\n\ttimecounter_init(&phc->tc, &phc->cc, 0);\n\n\tphc->clock = ptp_clock_register(&phc->info, dev);\n\tif (IS_ERR(phc->clock)) {\n\t\terr = PTR_ERR(phc->clock);\n\t\tgoto out_free_phc;\n\t}\n\n\tptp_schedule_worker(phc->clock, MOCK_PHC_REFRESH_INTERVAL);\n\n\treturn phc;\n\nout_free_phc:\n\tkfree(phc);\nout:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(mock_phc_create);\n\nvoid mock_phc_destroy(struct mock_phc *phc)\n{\n\tptp_clock_unregister(phc->clock);\n\tkfree(phc);\n}\nEXPORT_SYMBOL_GPL(mock_phc_destroy);\n\nMODULE_DESCRIPTION(\"Mock-up PTP Hardware Clock driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}